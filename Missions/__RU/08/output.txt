// starting begin InitMission ;
   0: CALL 5 0 0
// end ;
   4: END
// export HeikeCaptured ; export coopWithGensher ; export HeikeStatus ; export Masha ; export dial_BuildDepotBlocker , dial_BuildArBarrackBlocker , dial_ArriveGensherUnitsBlocker ; export buildingsToBuild , techsToResearch , vehWeaponsToConstruct , availableWeapons , weaponsData , allBuildings ; export HeikeTargetX , HeikeTargetY , GensherTargetX , GensherTargetY ; export allowExitFromMap ; export acceptKurtOffert , askCommanders ; export KurtCanEscape , KurtStatus , KurtWaitingForFreeHeike , KurtWaitingForBuildBarrack ; export KurtAttack , americansAttack , forceStopKurtAttack ; export canSendHeike , canShootTrening ; export BurlakRespect ; export acceptLegionOffert , paidLegionOffert , legionOffertCountdown , legionOffertTime ; export firstMashaQuery , canChooseMashaVehicle ; export buildCompVehicle , buildArabBarrack , testedTeleport ; export lostUnits ; function InitMission ; begin
   5: LD_INT 0
   7: PPUSH
// ResetFog ;
   8: CALL_OW 335
// RandomizeAll ;
  12: CALL_OW 11
// InGameOn ;
  16: CALL_OW 8
// InitMapConfig ;
  20: CALL 358 0 0
// HeikeCaptured = LoadVariable ( 07_HeikeCaptured_1 , 0 ) ;
  24: LD_ADDR_EXP 1
  28: PUSH
  29: LD_STRING 07_HeikeCaptured_1
  31: PPUSH
  32: LD_INT 0
  34: PPUSH
  35: CALL_OW 30
  39: ST_TO_ADDR
// coopWithGensher = 0 ;
  40: LD_ADDR_EXP 2
  44: PUSH
  45: LD_INT 0
  47: ST_TO_ADDR
// HeikeStatus = 0 ;
  48: LD_ADDR_EXP 3
  52: PUSH
  53: LD_INT 0
  55: ST_TO_ADDR
// Masha = [ ] ;
  56: LD_ADDR_EXP 4
  60: PUSH
  61: EMPTY
  62: ST_TO_ADDR
// buildingsToBuild = [ ] ;
  63: LD_ADDR_EXP 8
  67: PUSH
  68: EMPTY
  69: ST_TO_ADDR
// techsToResearch = [ ] ;
  70: LD_ADDR_EXP 9
  74: PUSH
  75: EMPTY
  76: ST_TO_ADDR
// vehWeaponsToConstruct = [ ] ;
  77: LD_ADDR_EXP 10
  81: PUSH
  82: EMPTY
  83: ST_TO_ADDR
// availableWeapons = [ ] ;
  84: LD_ADDR_EXP 11
  88: PUSH
  89: EMPTY
  90: ST_TO_ADDR
// weaponsData = [ ] ;
  91: LD_ADDR_EXP 12
  95: PUSH
  96: EMPTY
  97: ST_TO_ADDR
// allBuildings = [ ] ;
  98: LD_ADDR_EXP 13
 102: PUSH
 103: EMPTY
 104: ST_TO_ADDR
// HeikeTargetX = 0 ;
 105: LD_ADDR_EXP 14
 109: PUSH
 110: LD_INT 0
 112: ST_TO_ADDR
// HeikeTargetY = 0 ;
 113: LD_ADDR_EXP 15
 117: PUSH
 118: LD_INT 0
 120: ST_TO_ADDR
// GensherTargetX = 0 ;
 121: LD_ADDR_EXP 16
 125: PUSH
 126: LD_INT 0
 128: ST_TO_ADDR
// GensherTargetY = 0 ;
 129: LD_ADDR_EXP 17
 133: PUSH
 134: LD_INT 0
 136: ST_TO_ADDR
// allowExitFromMap = 0 ;
 137: LD_ADDR_EXP 18
 141: PUSH
 142: LD_INT 0
 144: ST_TO_ADDR
// acceptKurtOffert = 0 ;
 145: LD_ADDR_EXP 19
 149: PUSH
 150: LD_INT 0
 152: ST_TO_ADDR
// askCommanders = 0 ;
 153: LD_ADDR_EXP 20
 157: PUSH
 158: LD_INT 0
 160: ST_TO_ADDR
// KurtCanEscape = true ;
 161: LD_ADDR_EXP 21
 165: PUSH
 166: LD_INT 1
 168: ST_TO_ADDR
// KurtAttack = false ;
 169: LD_ADDR_EXP 25
 173: PUSH
 174: LD_INT 0
 176: ST_TO_ADDR
// KurtWaitingForFreeHeike = false ;
 177: LD_ADDR_EXP 23
 181: PUSH
 182: LD_INT 0
 184: ST_TO_ADDR
// KurtWaitingForBuildBarrack = false ;
 185: LD_ADDR_EXP 24
 189: PUSH
 190: LD_INT 0
 192: ST_TO_ADDR
// KurtStatus = 0 ;
 193: LD_ADDR_EXP 22
 197: PUSH
 198: LD_INT 0
 200: ST_TO_ADDR
// americansAttack = false ;
 201: LD_ADDR_EXP 26
 205: PUSH
 206: LD_INT 0
 208: ST_TO_ADDR
// forceStopKurtAttack = false ;
 209: LD_ADDR_EXP 27
 213: PUSH
 214: LD_INT 0
 216: ST_TO_ADDR
// canSendHeike = false ;
 217: LD_ADDR_EXP 28
 221: PUSH
 222: LD_INT 0
 224: ST_TO_ADDR
// canShootTrening = false ;
 225: LD_ADDR_EXP 29
 229: PUSH
 230: LD_INT 0
 232: ST_TO_ADDR
// BurlakRespect = 0 ;
 233: LD_ADDR_EXP 30
 237: PUSH
 238: LD_INT 0
 240: ST_TO_ADDR
// acceptLegionOffert = false ;
 241: LD_ADDR_EXP 31
 245: PUSH
 246: LD_INT 0
 248: ST_TO_ADDR
// paidLegionOffert = false ;
 249: LD_ADDR_EXP 32
 253: PUSH
 254: LD_INT 0
 256: ST_TO_ADDR
// legionOffertCountdown = false ;
 257: LD_ADDR_EXP 33
 261: PUSH
 262: LD_INT 0
 264: ST_TO_ADDR
// legionOffertTime = 0 0$60 ;
 265: LD_ADDR_EXP 34
 269: PUSH
 270: LD_INT 2100
 272: ST_TO_ADDR
// canChooseMashaVehicle = false ;
 273: LD_ADDR_EXP 36
 277: PUSH
 278: LD_INT 0
 280: ST_TO_ADDR
// firstMashaQuery = true ;
 281: LD_ADDR_EXP 35
 285: PUSH
 286: LD_INT 1
 288: ST_TO_ADDR
// buildArabBarrack = false ;
 289: LD_ADDR_EXP 38
 293: PUSH
 294: LD_INT 0
 296: ST_TO_ADDR
// buildCompVehicle = false ;
 297: LD_ADDR_EXP 37
 301: PUSH
 302: LD_INT 0
 304: ST_TO_ADDR
// testedTeleport = false ;
 305: LD_ADDR_EXP 39
 309: PUSH
 310: LD_INT 0
 312: ST_TO_ADDR
// lostUnits = 0 ;
 313: LD_ADDR_EXP 40
 317: PUSH
 318: LD_INT 0
 320: ST_TO_ADDR
// PrepareRussians ;
 321: CALL 1292 0 0
// PrepareArabians ;
 325: CALL 3847 0 0
// PrepareAmericans ;
 329: CALL 2975 0 0
// Nef_PrepareNature ;
 333: CALL 4831 0 0
// SpawnTrees ;
 337: CALL 5452 0 0
// MissionIntro ;
 341: CALL 9085 0 0
// end ;
 345: LD_VAR 0 1
 349: RET
// export function CustomInitMacro ; begin
 350: LD_INT 0
 352: PPUSH
// end ; end_of_file
 353: LD_VAR 0 1
 357: RET
// export function InitMapConfig ; begin
 358: LD_INT 0
 360: PPUSH
// BaseMapConfig ;
 361: CALL 374 0 0
// MissionMapConfig ;
 365: CALL 464 0 0
// end ;
 369: LD_VAR 0 1
 373: RET
// export animalsAmount , animalsStats , animalsAgression , missionPrefix , previousMissionPrefix , debugMode ; function BaseMapConfig ; begin
 374: LD_INT 0
 376: PPUSH
// animalsAmount = [ 6 , 3 , 4 , 4 , 1 ] ;
 377: LD_ADDR_EXP 41
 381: PUSH
 382: LD_INT 6
 384: PUSH
 385: LD_INT 3
 387: PUSH
 388: LD_INT 4
 390: PUSH
 391: LD_INT 4
 393: PUSH
 394: LD_INT 1
 396: PUSH
 397: EMPTY
 398: LIST
 399: LIST
 400: LIST
 401: LIST
 402: LIST
 403: ST_TO_ADDR
// animalsStats = [ 2 , 2 , 2 , 2 ] ;
 404: LD_ADDR_EXP 42
 408: PUSH
 409: LD_INT 2
 411: PUSH
 412: LD_INT 2
 414: PUSH
 415: LD_INT 2
 417: PUSH
 418: LD_INT 2
 420: PUSH
 421: EMPTY
 422: LIST
 423: LIST
 424: LIST
 425: LIST
 426: ST_TO_ADDR
// animalsAgression = 3 ;
 427: LD_ADDR_EXP 43
 431: PUSH
 432: LD_INT 3
 434: ST_TO_ADDR
// debugMode = 0 ;
 435: LD_ADDR_EXP 46
 439: PUSH
 440: LD_INT 0
 442: ST_TO_ADDR
// missionPrefix = 08_ ;
 443: LD_ADDR_EXP 44
 447: PUSH
 448: LD_STRING 08_
 450: ST_TO_ADDR
// previousMissionPrefix = 07_ ;
 451: LD_ADDR_EXP 45
 455: PUSH
 456: LD_STRING 07_
 458: ST_TO_ADDR
// end ;
 459: LD_VAR 0 1
 463: RET
// export KurtAttackWaves , americansAttackWaves ; export firstAttackDelay ; export waveCooldown ; export legionReduceAmericansUnits ; export speedMedalTime ; export enemyAttackUnitsData ; export timeToFreeHeike , timeToBuildArBarrack ; export enemySkillLevel ; function MissionMapConfig ; begin
 464: LD_INT 0
 466: PPUSH
// KurtAttackWaves = [ 3 , 4 , 5 , 6 ] [ Difficulty ] ;
 467: LD_ADDR_EXP 47
 471: PUSH
 472: LD_INT 3
 474: PUSH
 475: LD_INT 4
 477: PUSH
 478: LD_INT 5
 480: PUSH
 481: LD_INT 6
 483: PUSH
 484: EMPTY
 485: LIST
 486: LIST
 487: LIST
 488: LIST
 489: PUSH
 490: LD_OWVAR 67
 494: ARRAY
 495: ST_TO_ADDR
// americansAttackWaves = [ 1 , 2 , 3 , 4 ] [ Difficulty ] ;
 496: LD_ADDR_EXP 48
 500: PUSH
 501: LD_INT 1
 503: PUSH
 504: LD_INT 2
 506: PUSH
 507: LD_INT 3
 509: PUSH
 510: LD_INT 4
 512: PUSH
 513: EMPTY
 514: LIST
 515: LIST
 516: LIST
 517: LIST
 518: PUSH
 519: LD_OWVAR 67
 523: ARRAY
 524: ST_TO_ADDR
// enemySkillLevel = [ 3 , 4 , 5 , 6 ] [ Difficulty ] ;
 525: LD_ADDR_EXP 56
 529: PUSH
 530: LD_INT 3
 532: PUSH
 533: LD_INT 4
 535: PUSH
 536: LD_INT 5
 538: PUSH
 539: LD_INT 6
 541: PUSH
 542: EMPTY
 543: LIST
 544: LIST
 545: LIST
 546: LIST
 547: PUSH
 548: LD_OWVAR 67
 552: ARRAY
 553: ST_TO_ADDR
// waveCooldown = 1 1$30 ;
 554: LD_ADDR_EXP 50
 558: PUSH
 559: LD_INT 3150
 561: ST_TO_ADDR
// firstAttackDelay = 1 1$00 ;
 562: LD_ADDR_EXP 49
 566: PUSH
 567: LD_INT 2100
 569: ST_TO_ADDR
// timeToFreeHeike = 2 2$00 ;
 570: LD_ADDR_EXP 54
 574: PUSH
 575: LD_INT 4200
 577: ST_TO_ADDR
// timeToBuildArBarrack = 5 5$00 ;
 578: LD_ADDR_EXP 55
 582: PUSH
 583: LD_INT 10500
 585: ST_TO_ADDR
// legionReduceAmericansUnits = [ 5 , 5 , 6 , 6 ] [ Difficulty ] ;
 586: LD_ADDR_EXP 51
 590: PUSH
 591: LD_INT 5
 593: PUSH
 594: LD_INT 5
 596: PUSH
 597: LD_INT 6
 599: PUSH
 600: LD_INT 6
 602: PUSH
 603: EMPTY
 604: LIST
 605: LIST
 606: LIST
 607: LIST
 608: PUSH
 609: LD_OWVAR 67
 613: ARRAY
 614: ST_TO_ADDR
// speedMedalTime = [ 80 80$0 , 70 70$0 , 60 60$0 , 50 50$0 ] [ Difficulty ] ;
 615: LD_ADDR_EXP 52
 619: PUSH
 620: LD_INT 168000
 622: PUSH
 623: LD_INT 147000
 625: PUSH
 626: LD_INT 126000
 628: PUSH
 629: LD_INT 105000
 631: PUSH
 632: EMPTY
 633: LIST
 634: LIST
 635: LIST
 636: LIST
 637: PUSH
 638: LD_OWVAR 67
 642: ARRAY
 643: ST_TO_ADDR
// enemyAttackUnitsData = [ [ 1 , [ 4 , 5 , 6 , 6 ] [ Difficulty ] , [ 7 , 8 , 9 , 9 ] [ Difficulty ] , [ 1 , 2 , 2 , 3 ] [ Difficulty ] , [ 3 , 3 , 4 , 4 ] [ Difficulty ] , [ 6 , 7 , 8 , 8 ] [ Difficulty ] , [ 10 , 12 , 15 , 15 ] [ Difficulty ] ] , [ 8 , [ 2 , 3 , 4 , 4 ] [ Difficulty ] , [ 6 , 6 , 7 , 7 ] [ Difficulty ] , [ 0 , 1 , 1 , 2 ] [ Difficulty ] , [ 1 , 2 , 3 , 3 ] [ Difficulty ] , [ 1 , 2 , 2 , 2 ] [ Difficulty ] , [ 2 , 3 , 5 , 5 ] [ Difficulty ] ] ] ;
 644: LD_ADDR_EXP 53
 648: PUSH
 649: LD_INT 1
 651: PUSH
 652: LD_INT 4
 654: PUSH
 655: LD_INT 5
 657: PUSH
 658: LD_INT 6
 660: PUSH
 661: LD_INT 6
 663: PUSH
 664: EMPTY
 665: LIST
 666: LIST
 667: LIST
 668: LIST
 669: PUSH
 670: LD_OWVAR 67
 674: ARRAY
 675: PUSH
 676: LD_INT 7
 678: PUSH
 679: LD_INT 8
 681: PUSH
 682: LD_INT 9
 684: PUSH
 685: LD_INT 9
 687: PUSH
 688: EMPTY
 689: LIST
 690: LIST
 691: LIST
 692: LIST
 693: PUSH
 694: LD_OWVAR 67
 698: ARRAY
 699: PUSH
 700: LD_INT 1
 702: PUSH
 703: LD_INT 2
 705: PUSH
 706: LD_INT 2
 708: PUSH
 709: LD_INT 3
 711: PUSH
 712: EMPTY
 713: LIST
 714: LIST
 715: LIST
 716: LIST
 717: PUSH
 718: LD_OWVAR 67
 722: ARRAY
 723: PUSH
 724: LD_INT 3
 726: PUSH
 727: LD_INT 3
 729: PUSH
 730: LD_INT 4
 732: PUSH
 733: LD_INT 4
 735: PUSH
 736: EMPTY
 737: LIST
 738: LIST
 739: LIST
 740: LIST
 741: PUSH
 742: LD_OWVAR 67
 746: ARRAY
 747: PUSH
 748: LD_INT 6
 750: PUSH
 751: LD_INT 7
 753: PUSH
 754: LD_INT 8
 756: PUSH
 757: LD_INT 8
 759: PUSH
 760: EMPTY
 761: LIST
 762: LIST
 763: LIST
 764: LIST
 765: PUSH
 766: LD_OWVAR 67
 770: ARRAY
 771: PUSH
 772: LD_INT 10
 774: PUSH
 775: LD_INT 12
 777: PUSH
 778: LD_INT 15
 780: PUSH
 781: LD_INT 15
 783: PUSH
 784: EMPTY
 785: LIST
 786: LIST
 787: LIST
 788: LIST
 789: PUSH
 790: LD_OWVAR 67
 794: ARRAY
 795: PUSH
 796: EMPTY
 797: LIST
 798: LIST
 799: LIST
 800: LIST
 801: LIST
 802: LIST
 803: LIST
 804: PUSH
 805: LD_INT 8
 807: PUSH
 808: LD_INT 2
 810: PUSH
 811: LD_INT 3
 813: PUSH
 814: LD_INT 4
 816: PUSH
 817: LD_INT 4
 819: PUSH
 820: EMPTY
 821: LIST
 822: LIST
 823: LIST
 824: LIST
 825: PUSH
 826: LD_OWVAR 67
 830: ARRAY
 831: PUSH
 832: LD_INT 6
 834: PUSH
 835: LD_INT 6
 837: PUSH
 838: LD_INT 7
 840: PUSH
 841: LD_INT 7
 843: PUSH
 844: EMPTY
 845: LIST
 846: LIST
 847: LIST
 848: LIST
 849: PUSH
 850: LD_OWVAR 67
 854: ARRAY
 855: PUSH
 856: LD_INT 0
 858: PUSH
 859: LD_INT 1
 861: PUSH
 862: LD_INT 1
 864: PUSH
 865: LD_INT 2
 867: PUSH
 868: EMPTY
 869: LIST
 870: LIST
 871: LIST
 872: LIST
 873: PUSH
 874: LD_OWVAR 67
 878: ARRAY
 879: PUSH
 880: LD_INT 1
 882: PUSH
 883: LD_INT 2
 885: PUSH
 886: LD_INT 3
 888: PUSH
 889: LD_INT 3
 891: PUSH
 892: EMPTY
 893: LIST
 894: LIST
 895: LIST
 896: LIST
 897: PUSH
 898: LD_OWVAR 67
 902: ARRAY
 903: PUSH
 904: LD_INT 1
 906: PUSH
 907: LD_INT 2
 909: PUSH
 910: LD_INT 2
 912: PUSH
 913: LD_INT 2
 915: PUSH
 916: EMPTY
 917: LIST
 918: LIST
 919: LIST
 920: LIST
 921: PUSH
 922: LD_OWVAR 67
 926: ARRAY
 927: PUSH
 928: LD_INT 2
 930: PUSH
 931: LD_INT 3
 933: PUSH
 934: LD_INT 5
 936: PUSH
 937: LD_INT 5
 939: PUSH
 940: EMPTY
 941: LIST
 942: LIST
 943: LIST
 944: LIST
 945: PUSH
 946: LD_OWVAR 67
 950: ARRAY
 951: PUSH
 952: EMPTY
 953: LIST
 954: LIST
 955: LIST
 956: LIST
 957: LIST
 958: LIST
 959: LIST
 960: PUSH
 961: EMPTY
 962: LIST
 963: LIST
 964: ST_TO_ADDR
// end ;
 965: LD_VAR 0 1
 969: RET
// every 0 0$1 trigger debugMode do var i ;
 970: LD_EXP 46
 974: IFFALSE 1289
 976: GO 978
 978: DISABLE
 979: LD_INT 0
 981: PPUSH
// begin enable ;
 982: ENABLE
// FogOff ( your_side ) ;
 983: LD_OWVAR 2
 987: PPUSH
 988: CALL_OW 344
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) do
 992: LD_ADDR_VAR 0 1
 996: PUSH
 997: LD_INT 22
 999: PUSH
1000: LD_OWVAR 2
1004: PUSH
1005: EMPTY
1006: LIST
1007: LIST
1008: PUSH
1009: LD_INT 2
1011: PUSH
1012: LD_INT 21
1014: PUSH
1015: LD_INT 1
1017: PUSH
1018: EMPTY
1019: LIST
1020: LIST
1021: PUSH
1022: LD_INT 21
1024: PUSH
1025: LD_INT 2
1027: PUSH
1028: EMPTY
1029: LIST
1030: LIST
1031: PUSH
1032: EMPTY
1033: LIST
1034: LIST
1035: LIST
1036: PUSH
1037: EMPTY
1038: LIST
1039: LIST
1040: PPUSH
1041: CALL_OW 69
1045: PUSH
1046: FOR_IN
1047: IFFALSE 1063
// SetLives ( i , 1000 ) ;
1049: LD_VAR 0 1
1053: PPUSH
1054: LD_INT 1000
1056: PPUSH
1057: CALL_OW 234
1061: GO 1046
1063: POP
1064: POP
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) do
1065: LD_ADDR_VAR 0 1
1069: PUSH
1070: LD_INT 22
1072: PUSH
1073: LD_OWVAR 2
1077: PUSH
1078: EMPTY
1079: LIST
1080: LIST
1081: PUSH
1082: LD_INT 21
1084: PUSH
1085: LD_INT 1
1087: PUSH
1088: EMPTY
1089: LIST
1090: LIST
1091: PUSH
1092: EMPTY
1093: LIST
1094: LIST
1095: PPUSH
1096: CALL_OW 69
1100: PUSH
1101: FOR_IN
1102: IFFALSE 1166
// begin SetSkill ( i , skill_combat , 10 ) ;
1104: LD_VAR 0 1
1108: PPUSH
1109: LD_INT 1
1111: PPUSH
1112: LD_INT 10
1114: PPUSH
1115: CALL_OW 237
// SetSkill ( i , skill_engineering , 10 ) ;
1119: LD_VAR 0 1
1123: PPUSH
1124: LD_INT 2
1126: PPUSH
1127: LD_INT 10
1129: PPUSH
1130: CALL_OW 237
// SetSkill ( i , skill_mechanical , 10 ) ;
1134: LD_VAR 0 1
1138: PPUSH
1139: LD_INT 3
1141: PPUSH
1142: LD_INT 10
1144: PPUSH
1145: CALL_OW 237
// SetSkill ( i , skill_scientistic , 10 ) ;
1149: LD_VAR 0 1
1153: PPUSH
1154: LD_INT 4
1156: PPUSH
1157: LD_INT 10
1159: PPUSH
1160: CALL_OW 237
// end ;
1164: GO 1101
1166: POP
1167: POP
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) do
1168: LD_ADDR_VAR 0 1
1172: PUSH
1173: LD_INT 22
1175: PUSH
1176: LD_OWVAR 2
1180: PUSH
1181: EMPTY
1182: LIST
1183: LIST
1184: PUSH
1185: LD_INT 2
1187: PUSH
1188: LD_INT 30
1190: PUSH
1191: LD_INT 0
1193: PUSH
1194: EMPTY
1195: LIST
1196: LIST
1197: PUSH
1198: LD_INT 30
1200: PUSH
1201: LD_INT 1
1203: PUSH
1204: EMPTY
1205: LIST
1206: LIST
1207: PUSH
1208: EMPTY
1209: LIST
1210: LIST
1211: LIST
1212: PUSH
1213: EMPTY
1214: LIST
1215: LIST
1216: PPUSH
1217: CALL_OW 69
1221: PUSH
1222: FOR_IN
1223: IFFALSE 1287
// begin SetResourceType ( GetBase ( i ) , mat_cans , 9999 ) ;
1225: LD_VAR 0 1
1229: PPUSH
1230: CALL_OW 274
1234: PPUSH
1235: LD_INT 1
1237: PPUSH
1238: LD_INT 9999
1240: PPUSH
1241: CALL_OW 277
// SetResourceType ( GetBase ( i ) , mat_oil , 9999 ) ;
1245: LD_VAR 0 1
1249: PPUSH
1250: CALL_OW 274
1254: PPUSH
1255: LD_INT 2
1257: PPUSH
1258: LD_INT 9999
1260: PPUSH
1261: CALL_OW 277
// SetResourceType ( GetBase ( i ) , mat_siberit , 9999 ) ;
1265: LD_VAR 0 1
1269: PPUSH
1270: CALL_OW 274
1274: PPUSH
1275: LD_INT 3
1277: PPUSH
1278: LD_INT 9999
1280: PPUSH
1281: CALL_OW 277
// end ;
1285: GO 1222
1287: POP
1288: POP
// end ; end_of_file
1289: PPOPN 1
1291: END
// export Burlak , Karamazov , Petrovova , Gleb , Petrosyan , Titov , Dolgov , Lipshchin , Kirilenkova , Belkov , Belkov2 , Xavier ; export Gnyevko , Kovalyuk , Scholtze , Kuzmov ; export Kozlov , Oblukov , Kapitsova ; export Popov ; export russianEscort ; export function PrepareRussians ; begin
1292: LD_INT 0
1294: PPUSH
// russianEscort = [ ] ;
1295: LD_ADDR_EXP 77
1299: PUSH
1300: EMPTY
1301: ST_TO_ADDR
// Masha = [ ] ;
1302: LD_ADDR_EXP 4
1306: PUSH
1307: EMPTY
1308: ST_TO_ADDR
// PrepareHeroes ;
1309: CALL 1322 0 0
// InitRussianRequiments ;
1313: CALL 2717 0 0
// end ;
1317: LD_VAR 0 1
1321: RET
// function PrepareHeroes ; var i , un , other_survivors , yourUnits , emptyVeh ; begin
1322: LD_INT 0
1324: PPUSH
1325: PPUSH
1326: PPUSH
1327: PPUSH
1328: PPUSH
1329: PPUSH
// uc_side = 3 ;
1330: LD_ADDR_OWVAR 20
1334: PUSH
1335: LD_INT 3
1337: ST_TO_ADDR
// uc_nation = 3 ;
1338: LD_ADDR_OWVAR 21
1342: PUSH
1343: LD_INT 3
1345: ST_TO_ADDR
// Burlak := PrepareUnitExt ( Burlak , true , class_mechanic ) ;
1346: LD_ADDR_EXP 57
1350: PUSH
1351: LD_STRING Burlak
1353: PPUSH
1354: LD_INT 1
1356: PPUSH
1357: LD_INT 3
1359: PPUSH
1360: CALL 5930 0 3
1364: ST_TO_ADDR
// Titov := PrepareUnitExt ( Titov , true , class_soldier ) ;
1365: LD_ADDR_EXP 62
1369: PUSH
1370: LD_STRING Titov
1372: PPUSH
1373: LD_INT 1
1375: PPUSH
1376: LD_INT 1
1378: PPUSH
1379: CALL 5930 0 3
1383: ST_TO_ADDR
// Dolgov := PrepareUnitExt ( Dolgov , true , class_scientistic ) ;
1384: LD_ADDR_EXP 63
1388: PUSH
1389: LD_STRING Dolgov
1391: PPUSH
1392: LD_INT 1
1394: PPUSH
1395: LD_INT 4
1397: PPUSH
1398: CALL 5930 0 3
1402: ST_TO_ADDR
// Lipshchin := PrepareUnitExt ( Lipshchin , true , class_soldier ) ;
1403: LD_ADDR_EXP 64
1407: PUSH
1408: LD_STRING Lipshchin
1410: PPUSH
1411: LD_INT 1
1413: PPUSH
1414: LD_INT 1
1416: PPUSH
1417: CALL 5930 0 3
1421: ST_TO_ADDR
// Karamazov := PrepareUnitExt ( Karamazov , true , class_engineer ) ;
1422: LD_ADDR_EXP 58
1426: PUSH
1427: LD_STRING Karamazov
1429: PPUSH
1430: LD_INT 1
1432: PPUSH
1433: LD_INT 2
1435: PPUSH
1436: CALL 5930 0 3
1440: ST_TO_ADDR
// Petrovova := PrepareUnitExt ( Petrovova , true , class_soldier ) ;
1441: LD_ADDR_EXP 59
1445: PUSH
1446: LD_STRING Petrovova
1448: PPUSH
1449: LD_INT 1
1451: PPUSH
1452: LD_INT 1
1454: PPUSH
1455: CALL 5930 0 3
1459: ST_TO_ADDR
// Gleb := PrepareUnitExt ( Gleb , true , class_soldier ) ;
1460: LD_ADDR_EXP 60
1464: PUSH
1465: LD_STRING Gleb
1467: PPUSH
1468: LD_INT 1
1470: PPUSH
1471: LD_INT 1
1473: PPUSH
1474: CALL 5930 0 3
1478: ST_TO_ADDR
// Petrosyan := PrepareUnitExt ( Petrosyan , true , class_scientistic ) ;
1479: LD_ADDR_EXP 61
1483: PUSH
1484: LD_STRING Petrosyan
1486: PPUSH
1487: LD_INT 1
1489: PPUSH
1490: LD_INT 4
1492: PPUSH
1493: CALL 5930 0 3
1497: ST_TO_ADDR
// Kirilenkova := PrepareUnitExt ( Kirilenkova , true , class_scientistic ) ;
1498: LD_ADDR_EXP 65
1502: PUSH
1503: LD_STRING Kirilenkova
1505: PPUSH
1506: LD_INT 1
1508: PPUSH
1509: LD_INT 4
1511: PPUSH
1512: CALL 5930 0 3
1516: ST_TO_ADDR
// Belkov := PrepareUnitExt ( Belkov , true , class_soldier ) ;
1517: LD_ADDR_EXP 66
1521: PUSH
1522: LD_STRING Belkov
1524: PPUSH
1525: LD_INT 1
1527: PPUSH
1528: LD_INT 1
1530: PPUSH
1531: CALL 5930 0 3
1535: ST_TO_ADDR
// Belkov2 := PrepareUnitExt ( Belkov2 , true , class_soldier ) ;
1536: LD_ADDR_EXP 67
1540: PUSH
1541: LD_STRING Belkov2
1543: PPUSH
1544: LD_INT 1
1546: PPUSH
1547: LD_INT 1
1549: PPUSH
1550: CALL 5930 0 3
1554: ST_TO_ADDR
// Xavier := PrepareUnitExt ( Xavier , true , class_soldier ) ;
1555: LD_ADDR_EXP 68
1559: PUSH
1560: LD_STRING Xavier
1562: PPUSH
1563: LD_INT 1
1565: PPUSH
1566: LD_INT 1
1568: PPUSH
1569: CALL 5930 0 3
1573: ST_TO_ADDR
// Gnyevko := CreateCharacter ( 04_Gnyevko ) ;
1574: LD_ADDR_EXP 69
1578: PUSH
1579: LD_STRING 04_Gnyevko
1581: PPUSH
1582: CALL_OW 34
1586: ST_TO_ADDR
// SetClass ( Gnyevko , class_soldier ) ;
1587: LD_EXP 69
1591: PPUSH
1592: LD_INT 1
1594: PPUSH
1595: CALL_OW 336
// Kovalyuk := CreateCharacter ( 04_Kovalyuk ) ;
1599: LD_ADDR_EXP 70
1603: PUSH
1604: LD_STRING 04_Kovalyuk
1606: PPUSH
1607: CALL_OW 34
1611: ST_TO_ADDR
// SetClass ( Kovalyuk , class_mechanic ) ;
1612: LD_EXP 70
1616: PPUSH
1617: LD_INT 3
1619: PPUSH
1620: CALL_OW 336
// Scholtze := CreateCharacter ( 04_Scholtze ) ;
1624: LD_ADDR_EXP 71
1628: PUSH
1629: LD_STRING 04_Scholtze
1631: PPUSH
1632: CALL_OW 34
1636: ST_TO_ADDR
// SetClass ( Scholtze , class_scientistic ) ;
1637: LD_EXP 71
1641: PPUSH
1642: LD_INT 4
1644: PPUSH
1645: CALL_OW 336
// Kuzmov := CreateCharacter ( 04_Kuzmov ) ;
1649: LD_ADDR_EXP 72
1653: PUSH
1654: LD_STRING 04_Kuzmov
1656: PPUSH
1657: CALL_OW 34
1661: ST_TO_ADDR
// SetClass ( Kuzmov , class_soldier ) ;
1662: LD_EXP 72
1666: PPUSH
1667: LD_INT 1
1669: PPUSH
1670: CALL_OW 336
// Kozlov := PrepareUnitExt ( Kozlov , false , class_engineer ) ;
1674: LD_ADDR_EXP 73
1678: PUSH
1679: LD_STRING Kozlov
1681: PPUSH
1682: LD_INT 0
1684: PPUSH
1685: LD_INT 2
1687: PPUSH
1688: CALL 5930 0 3
1692: ST_TO_ADDR
// Oblukov := PrepareUnitExt ( Oblukov , false , class_soldier ) ;
1693: LD_ADDR_EXP 74
1697: PUSH
1698: LD_STRING Oblukov
1700: PPUSH
1701: LD_INT 0
1703: PPUSH
1704: LD_INT 1
1706: PPUSH
1707: CALL 5930 0 3
1711: ST_TO_ADDR
// Kapitsova := PrepareUnitExt ( Kapitsova , false , class_scientistic ) ;
1712: LD_ADDR_EXP 75
1716: PUSH
1717: LD_STRING Kapitsova
1719: PPUSH
1720: LD_INT 0
1722: PPUSH
1723: LD_INT 4
1725: PPUSH
1726: CALL 5930 0 3
1730: ST_TO_ADDR
// Popov := PrepareUnitExt ( Popov , false , 0 ) ;
1731: LD_ADDR_EXP 76
1735: PUSH
1736: LD_STRING Popov
1738: PPUSH
1739: LD_INT 0
1741: PPUSH
1742: LD_INT 0
1744: PPUSH
1745: CALL 5930 0 3
1749: ST_TO_ADDR
// PlaceUnitsArea ( [ Burlak , Karamazov , Petrovova , Gleb , Petrosyan , Titov , Dolgov , Lipshchin , Kirilenkova , Belkov , Belkov2 , Xavier , Gnyevko , Kovalyuk , Scholtze , Kuzmov , Kozlov , Oblukov , Kapitsova ] , RussianSpawnArea , false ) ;
1750: LD_EXP 57
1754: PUSH
1755: LD_EXP 58
1759: PUSH
1760: LD_EXP 59
1764: PUSH
1765: LD_EXP 60
1769: PUSH
1770: LD_EXP 61
1774: PUSH
1775: LD_EXP 62
1779: PUSH
1780: LD_EXP 63
1784: PUSH
1785: LD_EXP 64
1789: PUSH
1790: LD_EXP 65
1794: PUSH
1795: LD_EXP 66
1799: PUSH
1800: LD_EXP 67
1804: PUSH
1805: LD_EXP 68
1809: PUSH
1810: LD_EXP 69
1814: PUSH
1815: LD_EXP 70
1819: PUSH
1820: LD_EXP 71
1824: PUSH
1825: LD_EXP 72
1829: PUSH
1830: LD_EXP 73
1834: PUSH
1835: LD_EXP 74
1839: PUSH
1840: LD_EXP 75
1844: PUSH
1845: EMPTY
1846: LIST
1847: LIST
1848: LIST
1849: LIST
1850: LIST
1851: LIST
1852: LIST
1853: LIST
1854: LIST
1855: LIST
1856: LIST
1857: LIST
1858: LIST
1859: LIST
1860: LIST
1861: LIST
1862: LIST
1863: LIST
1864: LIST
1865: PPUSH
1866: LD_INT 2
1868: PPUSH
1869: LD_INT 0
1871: PPUSH
1872: CALL 6204 0 3
// PrepareVehicles ;
1876: CALL 2417 0 0
// other_survivors = CreateCharacterSet ( 07_other_survivors ) ;
1880: LD_ADDR_VAR 0 4
1884: PUSH
1885: LD_STRING 07_other_survivors
1887: PPUSH
1888: CALL_OW 31
1892: ST_TO_ADDR
// other_survivors = other_survivors ^ CreateCharacterSet ( 04_other_survivors ) ;
1893: LD_ADDR_VAR 0 4
1897: PUSH
1898: LD_VAR 0 4
1902: PUSH
1903: LD_STRING 04_other_survivors
1905: PPUSH
1906: CALL_OW 31
1910: ADD
1911: ST_TO_ADDR
// other_survivors = other_survivors ^ CreateCharacterSet ( 04_other_survivors_with_popov ) ;
1912: LD_ADDR_VAR 0 4
1916: PUSH
1917: LD_VAR 0 4
1921: PUSH
1922: LD_STRING 04_other_survivors_with_popov
1924: PPUSH
1925: CALL_OW 31
1929: ADD
1930: ST_TO_ADDR
// for un in other_survivors do
1931: LD_ADDR_VAR 0 3
1935: PUSH
1936: LD_VAR 0 4
1940: PUSH
1941: FOR_IN
1942: IFFALSE 2028
// begin emptyVeh = FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_vehicle ] , [ f_empty ] ] ) ;
1944: LD_ADDR_VAR 0 6
1948: PUSH
1949: LD_INT 22
1951: PUSH
1952: LD_INT 3
1954: PUSH
1955: EMPTY
1956: LIST
1957: LIST
1958: PUSH
1959: LD_INT 21
1961: PUSH
1962: LD_INT 2
1964: PUSH
1965: EMPTY
1966: LIST
1967: LIST
1968: PUSH
1969: LD_INT 58
1971: PUSH
1972: EMPTY
1973: LIST
1974: PUSH
1975: EMPTY
1976: LIST
1977: LIST
1978: LIST
1979: PPUSH
1980: CALL_OW 69
1984: ST_TO_ADDR
// if emptyVeh then
1985: LD_VAR 0 6
1989: IFFALSE 2011
// PlaceHumanInUnit ( un , emptyVeh [ 1 ] ) else
1991: LD_VAR 0 3
1995: PPUSH
1996: LD_VAR 0 6
2000: PUSH
2001: LD_INT 1
2003: ARRAY
2004: PPUSH
2005: CALL_OW 52
2009: GO 2026
// PlaceUnitArea ( un , RussianSpawnArea , false ) ;
2011: LD_VAR 0 3
2015: PPUSH
2016: LD_INT 2
2018: PPUSH
2019: LD_INT 0
2021: PPUSH
2022: CALL_OW 49
// end ;
2026: GO 1941
2028: POP
2029: POP
// yourUnits = FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_nation , nation_russian ] ] ) ;
2030: LD_ADDR_VAR 0 5
2034: PUSH
2035: LD_INT 22
2037: PUSH
2038: LD_INT 3
2040: PUSH
2041: EMPTY
2042: LIST
2043: LIST
2044: PUSH
2045: LD_INT 21
2047: PUSH
2048: LD_INT 1
2050: PUSH
2051: EMPTY
2052: LIST
2053: LIST
2054: PUSH
2055: LD_INT 23
2057: PUSH
2058: LD_INT 3
2060: PUSH
2061: EMPTY
2062: LIST
2063: LIST
2064: PUSH
2065: EMPTY
2066: LIST
2067: LIST
2068: LIST
2069: PPUSH
2070: CALL_OW 69
2074: ST_TO_ADDR
// if yourUnits < 15 then
2075: LD_VAR 0 5
2079: PUSH
2080: LD_INT 15
2082: LESS
2083: IFFALSE 2232
// for i := 1 to 15 - yourUnits do
2085: LD_ADDR_VAR 0 2
2089: PUSH
2090: DOUBLE
2091: LD_INT 1
2093: DEC
2094: ST_TO_ADDR
2095: LD_INT 15
2097: PUSH
2098: LD_VAR 0 5
2102: MINUS
2103: PUSH
2104: FOR_TO
2105: IFFALSE 2230
// begin PrepareHuman ( false , rand ( 1 , 4 ) , rand ( 2 , 4 ) ) ;
2107: LD_INT 0
2109: PPUSH
2110: LD_INT 1
2112: PPUSH
2113: LD_INT 4
2115: PPUSH
2116: CALL_OW 12
2120: PPUSH
2121: LD_INT 2
2123: PPUSH
2124: LD_INT 4
2126: PPUSH
2127: CALL_OW 12
2131: PPUSH
2132: CALL_OW 380
// un = CreateHuman ;
2136: LD_ADDR_VAR 0 3
2140: PUSH
2141: CALL_OW 44
2145: ST_TO_ADDR
// emptyVeh = FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_vehicle ] , [ f_empty ] ] ) ;
2146: LD_ADDR_VAR 0 6
2150: PUSH
2151: LD_INT 22
2153: PUSH
2154: LD_INT 3
2156: PUSH
2157: EMPTY
2158: LIST
2159: LIST
2160: PUSH
2161: LD_INT 21
2163: PUSH
2164: LD_INT 2
2166: PUSH
2167: EMPTY
2168: LIST
2169: LIST
2170: PUSH
2171: LD_INT 58
2173: PUSH
2174: EMPTY
2175: LIST
2176: PUSH
2177: EMPTY
2178: LIST
2179: LIST
2180: LIST
2181: PPUSH
2182: CALL_OW 69
2186: ST_TO_ADDR
// if emptyVeh then
2187: LD_VAR 0 6
2191: IFFALSE 2213
// PlaceHumanInUnit ( un , emptyVeh [ 1 ] ) else
2193: LD_VAR 0 3
2197: PPUSH
2198: LD_VAR 0 6
2202: PUSH
2203: LD_INT 1
2205: ARRAY
2206: PPUSH
2207: CALL_OW 52
2211: GO 2228
// PlaceUnitArea ( un , RussianSpawnArea , false ) ;
2213: LD_VAR 0 3
2217: PPUSH
2218: LD_INT 2
2220: PPUSH
2221: LD_INT 0
2223: PPUSH
2224: CALL_OW 49
// end ;
2228: GO 2104
2230: POP
2231: POP
// yourUnits = FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_nation , nation_russian ] ] ) ;
2232: LD_ADDR_VAR 0 5
2236: PUSH
2237: LD_INT 22
2239: PUSH
2240: LD_INT 3
2242: PUSH
2243: EMPTY
2244: LIST
2245: LIST
2246: PUSH
2247: LD_INT 21
2249: PUSH
2250: LD_INT 1
2252: PUSH
2253: EMPTY
2254: LIST
2255: LIST
2256: PUSH
2257: LD_INT 23
2259: PUSH
2260: LD_INT 3
2262: PUSH
2263: EMPTY
2264: LIST
2265: LIST
2266: PUSH
2267: EMPTY
2268: LIST
2269: LIST
2270: LIST
2271: PPUSH
2272: CALL_OW 69
2276: ST_TO_ADDR
// if not UnitFilter ( yourUnits , [ f_class , class_engineer ] ) then
2277: LD_VAR 0 5
2281: PPUSH
2282: LD_INT 25
2284: PUSH
2285: LD_INT 2
2287: PUSH
2288: EMPTY
2289: LIST
2290: LIST
2291: PPUSH
2292: CALL_OW 72
2296: NOT
2297: IFFALSE 2315
// SetClass ( yourUnits [ 1 ] , 2 ) ;
2299: LD_VAR 0 5
2303: PUSH
2304: LD_INT 1
2306: ARRAY
2307: PPUSH
2308: LD_INT 2
2310: PPUSH
2311: CALL_OW 336
// end ;
2315: LD_VAR 0 1
2319: RET
// export function PrepareRussianEscort ; var i , unit ; begin
2320: LD_INT 0
2322: PPUSH
2323: PPUSH
2324: PPUSH
// uc_side = 6 ;
2325: LD_ADDR_OWVAR 20
2329: PUSH
2330: LD_INT 6
2332: ST_TO_ADDR
// uc_nation = 3 ;
2333: LD_ADDR_OWVAR 21
2337: PUSH
2338: LD_INT 3
2340: ST_TO_ADDR
// for i := 1 to 2 do
2341: LD_ADDR_VAR 0 2
2345: PUSH
2346: DOUBLE
2347: LD_INT 1
2349: DEC
2350: ST_TO_ADDR
2351: LD_INT 2
2353: PUSH
2354: FOR_TO
2355: IFFALSE 2410
// begin PrepareSoldier ( false , 4 ) ;
2357: LD_INT 0
2359: PPUSH
2360: LD_INT 4
2362: PPUSH
2363: CALL_OW 381
// unit = CreateHuman ;
2367: LD_ADDR_VAR 0 3
2371: PUSH
2372: CALL_OW 44
2376: ST_TO_ADDR
// russianEscort = russianEscort ^ unit ;
2377: LD_ADDR_EXP 77
2381: PUSH
2382: LD_EXP 77
2386: PUSH
2387: LD_VAR 0 3
2391: ADD
2392: ST_TO_ADDR
// PlaceUnitArea ( unit , RussianSpawn2Area , false ) ;
2393: LD_VAR 0 3
2397: PPUSH
2398: LD_INT 7
2400: PPUSH
2401: LD_INT 0
2403: PPUSH
2404: CALL_OW 49
// end ;
2408: GO 2354
2410: POP
2411: POP
// end ;
2412: LD_VAR 0 1
2416: RET
// function PrepareVehicles ; var i , veh ; begin
2417: LD_INT 0
2419: PPUSH
2420: PPUSH
2421: PPUSH
// uc_side = 3 ;
2422: LD_ADDR_OWVAR 20
2426: PUSH
2427: LD_INT 3
2429: ST_TO_ADDR
// uc_nation = 3 ;
2430: LD_ADDR_OWVAR 21
2434: PUSH
2435: LD_INT 3
2437: ST_TO_ADDR
// for i := 1 to 5 do
2438: LD_ADDR_VAR 0 2
2442: PUSH
2443: DOUBLE
2444: LD_INT 1
2446: DEC
2447: ST_TO_ADDR
2448: LD_INT 5
2450: PUSH
2451: FOR_TO
2452: IFFALSE 2562
// begin PrepareVehicle ( ru_medium_wheeled , engine_combustion , control_manual , ru_cargo_bay , rand ( 60 , 80 ) ) ;
2454: LD_INT 21
2456: PPUSH
2457: LD_INT 1
2459: PPUSH
2460: LD_INT 1
2462: PPUSH
2463: LD_INT 51
2465: PPUSH
2466: LD_INT 60
2468: PPUSH
2469: LD_INT 80
2471: PPUSH
2472: CALL_OW 12
2476: PPUSH
2477: CALL 24239 0 5
// veh = CreateVehicle ;
2481: LD_ADDR_VAR 0 3
2485: PUSH
2486: CALL_OW 45
2490: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
2491: LD_VAR 0 3
2495: PPUSH
2496: LD_INT 4
2498: PPUSH
2499: CALL_OW 233
// PlaceUnitArea ( veh , RussianSpawnArea , false ) ;
2503: LD_VAR 0 3
2507: PPUSH
2508: LD_INT 2
2510: PPUSH
2511: LD_INT 0
2513: PPUSH
2514: CALL_OW 49
// if ( i <> 5 ) then
2518: LD_VAR 0 2
2522: PUSH
2523: LD_INT 5
2525: NONEQUAL
2526: IFFALSE 2545
// AddCargo ( veh , mat_cans , 100 ) else
2528: LD_VAR 0 3
2532: PPUSH
2533: LD_INT 1
2535: PPUSH
2536: LD_INT 100
2538: PPUSH
2539: CALL_OW 291
2543: GO 2560
// AddCargo ( veh , mat_oil , 100 ) ;
2545: LD_VAR 0 3
2549: PPUSH
2550: LD_INT 2
2552: PPUSH
2553: LD_INT 100
2555: PPUSH
2556: CALL_OW 291
// end ;
2560: GO 2451
2562: POP
2563: POP
// PrepareVehicle ( ru_medium_wheeled , engine_combustion , control_manual , ru_crane , rand ( 60 , 80 ) ) ;
2564: LD_INT 21
2566: PPUSH
2567: LD_INT 1
2569: PPUSH
2570: LD_INT 1
2572: PPUSH
2573: LD_INT 52
2575: PPUSH
2576: LD_INT 60
2578: PPUSH
2579: LD_INT 80
2581: PPUSH
2582: CALL_OW 12
2586: PPUSH
2587: CALL 24239 0 5
// veh = CreateVehicle ;
2591: LD_ADDR_VAR 0 3
2595: PUSH
2596: CALL_OW 45
2600: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
2601: LD_VAR 0 3
2605: PPUSH
2606: LD_INT 4
2608: PPUSH
2609: CALL_OW 233
// PlaceUnitArea ( veh , RussianSpawnArea , false ) ;
2613: LD_VAR 0 3
2617: PPUSH
2618: LD_INT 2
2620: PPUSH
2621: LD_INT 0
2623: PPUSH
2624: CALL_OW 49
// for i := 1 to 3 do
2628: LD_ADDR_VAR 0 2
2632: PUSH
2633: DOUBLE
2634: LD_INT 1
2636: DEC
2637: ST_TO_ADDR
2638: LD_INT 3
2640: PUSH
2641: FOR_TO
2642: IFFALSE 2710
// begin PrepareVehicle ( ru_heavy_tracked , engine_combustion , control_manual , ru_bulldozer , rand ( 60 , 80 ) ) ;
2644: LD_INT 24
2646: PPUSH
2647: LD_INT 1
2649: PPUSH
2650: LD_INT 1
2652: PPUSH
2653: LD_INT 53
2655: PPUSH
2656: LD_INT 60
2658: PPUSH
2659: LD_INT 80
2661: PPUSH
2662: CALL_OW 12
2666: PPUSH
2667: CALL 24239 0 5
// veh = CreateVehicle ;
2671: LD_ADDR_VAR 0 3
2675: PUSH
2676: CALL_OW 45
2680: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
2681: LD_VAR 0 3
2685: PPUSH
2686: LD_INT 4
2688: PPUSH
2689: CALL_OW 233
// PlaceUnitArea ( veh , RussianSpawnArea , false ) ;
2693: LD_VAR 0 3
2697: PPUSH
2698: LD_INT 2
2700: PPUSH
2701: LD_INT 0
2703: PPUSH
2704: CALL_OW 49
// end ;
2708: GO 2641
2710: POP
2711: POP
// end ;
2712: LD_VAR 0 1
2716: RET
// function InitRussianRequiments ; var i ; begin
2717: LD_INT 0
2719: PPUSH
2720: PPUSH
// availableWeapons = [ ru_heavy_machine_gun , ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher ] ;
2721: LD_ADDR_EXP 11
2725: PUSH
2726: LD_INT 42
2728: PUSH
2729: LD_INT 43
2731: PUSH
2732: LD_INT 44
2734: PUSH
2735: LD_INT 46
2737: PUSH
2738: LD_INT 45
2740: PUSH
2741: EMPTY
2742: LIST
2743: LIST
2744: LIST
2745: LIST
2746: LIST
2747: ST_TO_ADDR
// for i := 1 to availableWeapons do
2748: LD_ADDR_VAR 0 2
2752: PUSH
2753: DOUBLE
2754: LD_INT 1
2756: DEC
2757: ST_TO_ADDR
2758: LD_EXP 11
2762: PUSH
2763: FOR_TO
2764: IFFALSE 2804
// weaponsData = weaponsData ^ [ [ availableWeapons [ i ] , false , false ] ] ;
2766: LD_ADDR_EXP 12
2770: PUSH
2771: LD_EXP 12
2775: PUSH
2776: LD_EXP 11
2780: PUSH
2781: LD_VAR 0 2
2785: ARRAY
2786: PUSH
2787: LD_INT 0
2789: PUSH
2790: LD_INT 0
2792: PUSH
2793: EMPTY
2794: LIST
2795: LIST
2796: LIST
2797: PUSH
2798: EMPTY
2799: LIST
2800: ADD
2801: ST_TO_ADDR
2802: GO 2763
2804: POP
2805: POP
// for i := 0 to 50 do
2806: LD_ADDR_VAR 0 2
2810: PUSH
2811: DOUBLE
2812: LD_INT 0
2814: DEC
2815: ST_TO_ADDR
2816: LD_INT 50
2818: PUSH
2819: FOR_TO
2820: IFFALSE 2858
// if GetRestrict ( i , 3 ) = state_enabled then
2822: LD_VAR 0 2
2826: PPUSH
2827: LD_INT 3
2829: PPUSH
2830: CALL_OW 323
2834: PUSH
2835: LD_INT 1
2837: EQUAL
2838: IFFALSE 2856
// buildingsToBuild = buildingsToBuild ^ i ;
2840: LD_ADDR_EXP 8
2844: PUSH
2845: LD_EXP 8
2849: PUSH
2850: LD_VAR 0 2
2854: ADD
2855: ST_TO_ADDR
2856: GO 2819
2858: POP
2859: POP
// buildingsToBuild = buildingsToBuild diff [ 0 , 2 , 4 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 14 , 22 , 31 , 32 , 33 , 39 , 40 ] ;
2860: LD_ADDR_EXP 8
2864: PUSH
2865: LD_EXP 8
2869: PUSH
2870: LD_INT 0
2872: PUSH
2873: LD_INT 2
2875: PUSH
2876: LD_INT 4
2878: PUSH
2879: LD_INT 6
2881: PUSH
2882: LD_INT 7
2884: PUSH
2885: LD_INT 8
2887: PUSH
2888: LD_INT 9
2890: PUSH
2891: LD_INT 10
2893: PUSH
2894: LD_INT 11
2896: PUSH
2897: LD_INT 12
2899: PUSH
2900: LD_INT 14
2902: PUSH
2903: LD_INT 22
2905: PUSH
2906: LD_INT 31
2908: PUSH
2909: LD_INT 32
2911: PUSH
2912: LD_INT 33
2914: PUSH
2915: LD_INT 39
2917: PUSH
2918: LD_INT 40
2920: PUSH
2921: EMPTY
2922: LIST
2923: LIST
2924: LIST
2925: LIST
2926: LIST
2927: LIST
2928: LIST
2929: LIST
2930: LIST
2931: LIST
2932: LIST
2933: LIST
2934: LIST
2935: LIST
2936: LIST
2937: LIST
2938: LIST
2939: DIFF
2940: ST_TO_ADDR
// allBuildings = buildingsToBuild ;
2941: LD_ADDR_EXP 13
2945: PUSH
2946: LD_EXP 8
2950: ST_TO_ADDR
// techsToResearch = GetTechNation ( 3 , nation_russian , state_enabled ) ;
2951: LD_ADDR_EXP 9
2955: PUSH
2956: LD_INT 3
2958: PPUSH
2959: LD_INT 3
2961: PPUSH
2962: LD_INT 1
2964: PPUSH
2965: CALL 19287 0 3
2969: ST_TO_ADDR
// end ; end_of_file
2970: LD_VAR 0 1
2974: RET
// export amAttackTeam ; export function PrepareAmericans ; begin
2975: LD_INT 0
2977: PPUSH
// amAttackTeam = [ ] ;
2978: LD_ADDR_EXP 78
2982: PUSH
2983: EMPTY
2984: ST_TO_ADDR
// SpawnAmericansSnipers ;
2985: CALL 3119 0 0
// case Difficulty of 2 :
2989: LD_OWVAR 67
2993: PUSH
2994: LD_INT 2
2996: DOUBLE
2997: EQUAL
2998: IFTRUE 3002
3000: GO 3031
3002: POP
// begin SetTech ( tech_comp1 , 1 , state_researched ) ;
3003: LD_INT 57
3005: PPUSH
3006: LD_INT 1
3008: PPUSH
3009: LD_INT 2
3011: PPUSH
3012: CALL_OW 322
// SetTech ( tech_opto1 , 1 , state_researched ) ;
3016: LD_INT 60
3018: PPUSH
3019: LD_INT 1
3021: PPUSH
3022: LD_INT 2
3024: PPUSH
3025: CALL_OW 322
// end ; 3 .. 4 :
3029: GO 3114
3031: LD_INT 3
3033: DOUBLE
3034: GREATEREQUAL
3035: IFFALSE 3043
3037: LD_INT 4
3039: DOUBLE
3040: LESSEQUAL
3041: IFTRUE 3045
3043: GO 3113
3045: POP
// begin SetTech ( tech_comp1 , 1 , state_researched ) ;
3046: LD_INT 57
3048: PPUSH
3049: LD_INT 1
3051: PPUSH
3052: LD_INT 2
3054: PPUSH
3055: CALL_OW 322
// SetTech ( tech_comp2 , 1 , state_researched ) ;
3059: LD_INT 58
3061: PPUSH
3062: LD_INT 1
3064: PPUSH
3065: LD_INT 2
3067: PPUSH
3068: CALL_OW 322
// SetTech ( tech_weap3 , 1 , state_researched ) ;
3072: LD_INT 53
3074: PPUSH
3075: LD_INT 1
3077: PPUSH
3078: LD_INT 2
3080: PPUSH
3081: CALL_OW 322
// SetTech ( tech_opto1 , 1 , state_researched ) ;
3085: LD_INT 60
3087: PPUSH
3088: LD_INT 1
3090: PPUSH
3091: LD_INT 2
3093: PPUSH
3094: CALL_OW 322
// SetTech ( tech_opto2 , 1 , state_researched ) ;
3098: LD_INT 61
3100: PPUSH
3101: LD_INT 1
3103: PPUSH
3104: LD_INT 2
3106: PPUSH
3107: CALL_OW 322
// end ; end ;
3111: GO 3114
3113: POP
// end ;
3114: LD_VAR 0 1
3118: RET
// export function SpawnAmericansSnipers ; var i , un ; begin
3119: LD_INT 0
3121: PPUSH
3122: PPUSH
3123: PPUSH
// uc_side = 1 ;
3124: LD_ADDR_OWVAR 20
3128: PUSH
3129: LD_INT 1
3131: ST_TO_ADDR
// uc_nation = 1 ;
3132: LD_ADDR_OWVAR 21
3136: PUSH
3137: LD_INT 1
3139: ST_TO_ADDR
// for i := 1 to 8 do
3140: LD_ADDR_VAR 0 2
3144: PUSH
3145: DOUBLE
3146: LD_INT 1
3148: DEC
3149: ST_TO_ADDR
3150: LD_INT 8
3152: PUSH
3153: FOR_TO
3154: IFFALSE 3207
// begin PrepareHuman ( false , class_sniper , enemySkillLevel ) ;
3156: LD_INT 0
3158: PPUSH
3159: LD_INT 5
3161: PPUSH
3162: LD_EXP 56
3166: PPUSH
3167: CALL_OW 380
// un = CreateHuman ;
3171: LD_ADDR_VAR 0 3
3175: PUSH
3176: CALL_OW 44
3180: ST_TO_ADDR
// PlaceUnitArea ( un , AmericansSnipersSpawnArea , false ) ;
3181: LD_VAR 0 3
3185: PPUSH
3186: LD_INT 14
3188: PPUSH
3189: LD_INT 0
3191: PPUSH
3192: CALL_OW 49
// ComHold ( un ) ;
3196: LD_VAR 0 3
3200: PPUSH
3201: CALL_OW 140
// end ;
3205: GO 3153
3207: POP
3208: POP
// end ;
3209: LD_VAR 0 1
3213: RET
// export function SpawnAmAttackTeam ; var i , unit , veh , randVehType , weapon , chassis , amSolds , amSnipers , amVehs ; begin
3214: LD_INT 0
3216: PPUSH
3217: PPUSH
3218: PPUSH
3219: PPUSH
3220: PPUSH
3221: PPUSH
3222: PPUSH
3223: PPUSH
3224: PPUSH
3225: PPUSH
// uc_side = 1 ;
3226: LD_ADDR_OWVAR 20
3230: PUSH
3231: LD_INT 1
3233: ST_TO_ADDR
// uc_nation = 1 ;
3234: LD_ADDR_OWVAR 21
3238: PUSH
3239: LD_INT 1
3241: ST_TO_ADDR
// amSolds = Rand ( enemyAttackUnitsData [ 1 ] [ 2 ] , enemyAttackUnitsData [ 1 ] [ 3 ] ) ;
3242: LD_ADDR_VAR 0 8
3246: PUSH
3247: LD_EXP 53
3251: PUSH
3252: LD_INT 1
3254: ARRAY
3255: PUSH
3256: LD_INT 2
3258: ARRAY
3259: PPUSH
3260: LD_EXP 53
3264: PUSH
3265: LD_INT 1
3267: ARRAY
3268: PUSH
3269: LD_INT 3
3271: ARRAY
3272: PPUSH
3273: CALL_OW 12
3277: ST_TO_ADDR
// amSnipers = Rand ( enemyAttackUnitsData [ 1 ] [ 4 ] , enemyAttackUnitsData [ 1 ] [ 5 ] ) ;
3278: LD_ADDR_VAR 0 9
3282: PUSH
3283: LD_EXP 53
3287: PUSH
3288: LD_INT 1
3290: ARRAY
3291: PUSH
3292: LD_INT 4
3294: ARRAY
3295: PPUSH
3296: LD_EXP 53
3300: PUSH
3301: LD_INT 1
3303: ARRAY
3304: PUSH
3305: LD_INT 5
3307: ARRAY
3308: PPUSH
3309: CALL_OW 12
3313: ST_TO_ADDR
// amVehs = Rand ( enemyAttackUnitsData [ 1 ] [ 6 ] , enemyAttackUnitsData [ 1 ] [ 7 ] ) ;
3314: LD_ADDR_VAR 0 10
3318: PUSH
3319: LD_EXP 53
3323: PUSH
3324: LD_INT 1
3326: ARRAY
3327: PUSH
3328: LD_INT 6
3330: ARRAY
3331: PPUSH
3332: LD_EXP 53
3336: PUSH
3337: LD_INT 1
3339: ARRAY
3340: PUSH
3341: LD_INT 7
3343: ARRAY
3344: PPUSH
3345: CALL_OW 12
3349: ST_TO_ADDR
// if paidLegionOffert then
3350: LD_EXP 32
3354: IFFALSE 3388
// begin amSolds = amSolds - legionReduceAmericansUnits ;
3356: LD_ADDR_VAR 0 8
3360: PUSH
3361: LD_VAR 0 8
3365: PUSH
3366: LD_EXP 51
3370: MINUS
3371: ST_TO_ADDR
// amVehs = amVehs - legionReduceAmericansUnits ;
3372: LD_ADDR_VAR 0 10
3376: PUSH
3377: LD_VAR 0 10
3381: PUSH
3382: LD_EXP 51
3386: MINUS
3387: ST_TO_ADDR
// end ; for i := 1 to amSolds do
3388: LD_ADDR_VAR 0 2
3392: PUSH
3393: DOUBLE
3394: LD_INT 1
3396: DEC
3397: ST_TO_ADDR
3398: LD_VAR 0 8
3402: PUSH
3403: FOR_TO
3404: IFFALSE 3461
// begin PrepareSoldier ( false , enemySkillLevel ) ;
3406: LD_INT 0
3408: PPUSH
3409: LD_EXP 56
3413: PPUSH
3414: CALL_OW 381
// unit = CreateHuman ;
3418: LD_ADDR_VAR 0 3
3422: PUSH
3423: CALL_OW 44
3427: ST_TO_ADDR
// PlaceUnitArea ( unit , AmericanSpawnArea , false ) ;
3428: LD_VAR 0 3
3432: PPUSH
3433: LD_INT 3
3435: PPUSH
3436: LD_INT 0
3438: PPUSH
3439: CALL_OW 49
// amAttackTeam = amAttackTeam ^ unit ;
3443: LD_ADDR_EXP 78
3447: PUSH
3448: LD_EXP 78
3452: PUSH
3453: LD_VAR 0 3
3457: ADD
3458: ST_TO_ADDR
// end ;
3459: GO 3403
3461: POP
3462: POP
// for i := 1 to amSnipers do
3463: LD_ADDR_VAR 0 2
3467: PUSH
3468: DOUBLE
3469: LD_INT 1
3471: DEC
3472: ST_TO_ADDR
3473: LD_VAR 0 9
3477: PUSH
3478: FOR_TO
3479: IFFALSE 3539
// begin PrepareHuman ( false , class_sniper , enemySkillLevel ) ;
3481: LD_INT 0
3483: PPUSH
3484: LD_INT 5
3486: PPUSH
3487: LD_EXP 56
3491: PPUSH
3492: CALL_OW 380
// unit = CreateHuman ;
3496: LD_ADDR_VAR 0 3
3500: PUSH
3501: CALL_OW 44
3505: ST_TO_ADDR
// PlaceUnitArea ( unit , AmericanSpawnArea , false ) ;
3506: LD_VAR 0 3
3510: PPUSH
3511: LD_INT 3
3513: PPUSH
3514: LD_INT 0
3516: PPUSH
3517: CALL_OW 49
// amAttackTeam = amAttackTeam ^ unit ;
3521: LD_ADDR_EXP 78
3525: PUSH
3526: LD_EXP 78
3530: PUSH
3531: LD_VAR 0 3
3535: ADD
3536: ST_TO_ADDR
// end ;
3537: GO 3478
3539: POP
3540: POP
// for i := 1 to amVehs do
3541: LD_ADDR_VAR 0 2
3545: PUSH
3546: DOUBLE
3547: LD_INT 1
3549: DEC
3550: ST_TO_ADDR
3551: LD_VAR 0 10
3555: PUSH
3556: FOR_TO
3557: IFFALSE 3840
// begin randVehType = Rand ( 1 , 4 ) ;
3559: LD_ADDR_VAR 0 5
3563: PUSH
3564: LD_INT 1
3566: PPUSH
3567: LD_INT 4
3569: PPUSH
3570: CALL_OW 12
3574: ST_TO_ADDR
// weapon = [ us_gatling_gun , us_double_gun , us_light_gun , us_rocket_launcher , us_heavy_gun ] [ Rand ( 1 , 5 ) ] ;
3575: LD_ADDR_VAR 0 6
3579: PUSH
3580: LD_INT 4
3582: PUSH
3583: LD_INT 5
3585: PUSH
3586: LD_INT 3
3588: PUSH
3589: LD_INT 7
3591: PUSH
3592: LD_INT 6
3594: PUSH
3595: EMPTY
3596: LIST
3597: LIST
3598: LIST
3599: LIST
3600: LIST
3601: PUSH
3602: LD_INT 1
3604: PPUSH
3605: LD_INT 5
3607: PPUSH
3608: CALL_OW 12
3612: ARRAY
3613: ST_TO_ADDR
// if weapon = us_heavy_gun then
3614: LD_VAR 0 6
3618: PUSH
3619: LD_INT 6
3621: EQUAL
3622: IFFALSE 3634
// chassis = us_heavy_tracked else
3624: LD_ADDR_VAR 0 7
3628: PUSH
3629: LD_INT 4
3631: ST_TO_ADDR
3632: GO 3661
// chassis = [ us_medium_tracked , us_heavy_tracked ] [ Rand ( 1 , 2 ) ] ;
3634: LD_ADDR_VAR 0 7
3638: PUSH
3639: LD_INT 3
3641: PUSH
3642: LD_INT 4
3644: PUSH
3645: EMPTY
3646: LIST
3647: LIST
3648: PUSH
3649: LD_INT 1
3651: PPUSH
3652: LD_INT 2
3654: PPUSH
3655: CALL_OW 12
3659: ARRAY
3660: ST_TO_ADDR
// if randVehType = 1 then
3661: LD_VAR 0 5
3665: PUSH
3666: LD_INT 1
3668: EQUAL
3669: IFFALSE 3704
// PrepareVehicle ( chassis , engine_combustion , control_manual , weapon , Rand ( 70 , 90 ) ) else
3671: LD_VAR 0 7
3675: PPUSH
3676: LD_INT 1
3678: PPUSH
3679: LD_INT 1
3681: PPUSH
3682: LD_VAR 0 6
3686: PPUSH
3687: LD_INT 70
3689: PPUSH
3690: LD_INT 90
3692: PPUSH
3693: CALL_OW 12
3697: PPUSH
3698: CALL 24239 0 5
3702: GO 3735
// PrepareVehicle ( chassis , engine_combustion , control_computer , weapon , Rand ( 70 , 90 ) ) ;
3704: LD_VAR 0 7
3708: PPUSH
3709: LD_INT 1
3711: PPUSH
3712: LD_INT 3
3714: PPUSH
3715: LD_VAR 0 6
3719: PPUSH
3720: LD_INT 70
3722: PPUSH
3723: LD_INT 90
3725: PPUSH
3726: CALL_OW 12
3730: PPUSH
3731: CALL 24239 0 5
// veh = CreateVehicle ;
3735: LD_ADDR_VAR 0 4
3739: PUSH
3740: CALL_OW 45
3744: ST_TO_ADDR
// PlaceUnitArea ( veh , AmericanSpawnArea , false ) ;
3745: LD_VAR 0 4
3749: PPUSH
3750: LD_INT 3
3752: PPUSH
3753: LD_INT 0
3755: PPUSH
3756: CALL_OW 49
// amAttackTeam = amAttackTeam ^ veh ;
3760: LD_ADDR_EXP 78
3764: PUSH
3765: LD_EXP 78
3769: PUSH
3770: LD_VAR 0 4
3774: ADD
3775: ST_TO_ADDR
// if randVehType = 1 then
3776: LD_VAR 0 5
3780: PUSH
3781: LD_INT 1
3783: EQUAL
3784: IFFALSE 3838
// begin PrepareMechanic ( false , enemySkillLevel ) ;
3786: LD_INT 0
3788: PPUSH
3789: LD_EXP 56
3793: PPUSH
3794: CALL_OW 383
// unit = CreateHuman ;
3798: LD_ADDR_VAR 0 3
3802: PUSH
3803: CALL_OW 44
3807: ST_TO_ADDR
// PlaceHumanInUnit ( unit , veh ) ;
3808: LD_VAR 0 3
3812: PPUSH
3813: LD_VAR 0 4
3817: PPUSH
3818: CALL_OW 52
// amAttackTeam = amAttackTeam ^ unit ;
3822: LD_ADDR_EXP 78
3826: PUSH
3827: LD_EXP 78
3831: PUSH
3832: LD_VAR 0 3
3836: ADD
3837: ST_TO_ADDR
// end ; end ;
3838: GO 3556
3840: POP
3841: POP
// end ; end_of_file
3842: LD_VAR 0 1
3846: RET
// export Heike , Kurt , Dietrich ; export KurtEng ; export GensherTeam ; export arAttackTeam ; export function PrepareArabians ; begin
3847: LD_INT 0
3849: PPUSH
// arAttackTeam = [ ] ;
3850: LD_ADDR_EXP 84
3854: PUSH
3855: EMPTY
3856: ST_TO_ADDR
// PrepareHeroes ;
3857: CALL 4262 0 0
// case Difficulty of 2 :
3861: LD_OWVAR 67
3865: PUSH
3866: LD_INT 2
3868: DOUBLE
3869: EQUAL
3870: IFTRUE 3874
3872: GO 3890
3874: POP
// begin SetTech ( tech_stimDrugs , 8 , state_researched ) ;
3875: LD_INT 5
3877: PPUSH
3878: LD_INT 8
3880: PPUSH
3881: LD_INT 2
3883: PPUSH
3884: CALL_OW 322
// end ; 3 :
3888: GO 3941
3890: LD_INT 3
3892: DOUBLE
3893: EQUAL
3894: IFTRUE 3898
3896: GO 3940
3898: POP
// begin SetTech ( tech_stimDrugs , 8 , state_researched ) ;
3899: LD_INT 5
3901: PPUSH
3902: LD_INT 8
3904: PPUSH
3905: LD_INT 2
3907: PPUSH
3908: CALL_OW 322
// SetTech ( tech_bio1 , 8 , state_researched ) ;
3912: LD_INT 66
3914: PPUSH
3915: LD_INT 8
3917: PPUSH
3918: LD_INT 2
3920: PPUSH
3921: CALL_OW 322
// SetTech ( tech_weap3 , 8 , state_researched ) ;
3925: LD_INT 53
3927: PPUSH
3928: LD_INT 8
3930: PPUSH
3931: LD_INT 2
3933: PPUSH
3934: CALL_OW 322
// end ; end ;
3938: GO 3941
3940: POP
// end ;
3941: LD_VAR 0 1
3945: RET
// export function SpawnGensherTeam ; var i , driver , veh ; begin
3946: LD_INT 0
3948: PPUSH
3949: PPUSH
3950: PPUSH
3951: PPUSH
// GensherTeam = [ ] ;
3952: LD_ADDR_EXP 83
3956: PUSH
3957: EMPTY
3958: ST_TO_ADDR
// uc_side = 2 ;
3959: LD_ADDR_OWVAR 20
3963: PUSH
3964: LD_INT 2
3966: ST_TO_ADDR
// uc_nation = 2 ;
3967: LD_ADDR_OWVAR 21
3971: PUSH
3972: LD_INT 2
3974: ST_TO_ADDR
// for i := 1 to 3 do
3975: LD_ADDR_VAR 0 2
3979: PUSH
3980: DOUBLE
3981: LD_INT 1
3983: DEC
3984: ST_TO_ADDR
3985: LD_INT 3
3987: PUSH
3988: FOR_TO
3989: IFFALSE 4148
// begin PrepareSoldier ( sex_male , rand ( 3 , 5 ) ) ;
3991: LD_INT 1
3993: PPUSH
3994: LD_INT 3
3996: PPUSH
3997: LD_INT 5
3999: PPUSH
4000: CALL_OW 12
4004: PPUSH
4005: CALL_OW 381
// driver = CreateHuman ;
4009: LD_ADDR_VAR 0 3
4013: PUSH
4014: CALL_OW 44
4018: ST_TO_ADDR
// PrepareVehicle ( ar_medium_trike , engine_combustion , control_manual , ar_cargo_bay , rand ( 50 , 70 ) ) ;
4019: LD_INT 13
4021: PPUSH
4022: LD_INT 1
4024: PPUSH
4025: LD_INT 1
4027: PPUSH
4028: LD_INT 32
4030: PPUSH
4031: LD_INT 50
4033: PPUSH
4034: LD_INT 70
4036: PPUSH
4037: CALL_OW 12
4041: PPUSH
4042: CALL 24239 0 5
// veh = CreateVehicle ;
4046: LD_ADDR_VAR 0 4
4050: PUSH
4051: CALL_OW 45
4055: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
4056: LD_VAR 0 4
4060: PPUSH
4061: LD_INT 4
4063: PPUSH
4064: CALL_OW 233
// PlaceUnitArea ( veh , GensherSpawnArea , false ) ;
4068: LD_VAR 0 4
4072: PPUSH
4073: LD_INT 4
4075: PPUSH
4076: LD_INT 0
4078: PPUSH
4079: CALL_OW 49
// PlaceHumanInUnit ( driver , veh ) ;
4083: LD_VAR 0 3
4087: PPUSH
4088: LD_VAR 0 4
4092: PPUSH
4093: CALL_OW 52
// AddCargo ( veh , i , 100 ) ;
4097: LD_VAR 0 4
4101: PPUSH
4102: LD_VAR 0 2
4106: PPUSH
4107: LD_INT 100
4109: PPUSH
4110: CALL_OW 291
// GensherTeam = GensherTeam ^ driver ;
4114: LD_ADDR_EXP 83
4118: PUSH
4119: LD_EXP 83
4123: PUSH
4124: LD_VAR 0 3
4128: ADD
4129: ST_TO_ADDR
// GensherTeam = GensherTeam ^ veh ;
4130: LD_ADDR_EXP 83
4134: PUSH
4135: LD_EXP 83
4139: PUSH
4140: LD_VAR 0 4
4144: ADD
4145: ST_TO_ADDR
// end ;
4146: GO 3988
4148: POP
4149: POP
// if IsOK ( KurtEng ) and GetSide ( KurtEng ) = 3 then
4150: LD_EXP 82
4154: PPUSH
4155: CALL_OW 302
4159: PUSH
4160: LD_EXP 82
4164: PPUSH
4165: CALL_OW 255
4169: PUSH
4170: LD_INT 3
4172: EQUAL
4173: AND
4174: IFFALSE 4208
// begin GensherTargetX = GetX ( Kurt ) ;
4176: LD_ADDR_EXP 16
4180: PUSH
4181: LD_EXP 80
4185: PPUSH
4186: CALL_OW 250
4190: ST_TO_ADDR
// GensherTargetY = GetY ( Kurt ) ;
4191: LD_ADDR_EXP 17
4195: PUSH
4196: LD_EXP 80
4200: PPUSH
4201: CALL_OW 251
4205: ST_TO_ADDR
// end else
4206: GO 4238
// begin GensherTargetX = GetX ( Burlak ) ;
4208: LD_ADDR_EXP 16
4212: PUSH
4213: LD_EXP 57
4217: PPUSH
4218: CALL_OW 250
4222: ST_TO_ADDR
// GensherTargetY = GetY ( Burlak ) ;
4223: LD_ADDR_EXP 17
4227: PUSH
4228: LD_EXP 57
4232: PPUSH
4233: CALL_OW 251
4237: ST_TO_ADDR
// end ; ComMoveXY ( GensherTeam , GensherTargetX , GensherTargetY ) ;
4238: LD_EXP 83
4242: PPUSH
4243: LD_EXP 16
4247: PPUSH
4248: LD_EXP 17
4252: PPUSH
4253: CALL_OW 111
// end ;
4257: LD_VAR 0 1
4261: RET
// function PrepareHeroes ; begin
4262: LD_INT 0
4264: PPUSH
// uc_side = 5 ;
4265: LD_ADDR_OWVAR 20
4269: PUSH
4270: LD_INT 5
4272: ST_TO_ADDR
// uc_nation = 2 ;
4273: LD_ADDR_OWVAR 21
4277: PUSH
4278: LD_INT 2
4280: ST_TO_ADDR
// Heike = PrepareUnitExt ( Heike , true , class_engineer ) ;
4281: LD_ADDR_EXP 79
4285: PUSH
4286: LD_STRING Heike
4288: PPUSH
4289: LD_INT 1
4291: PPUSH
4292: LD_INT 2
4294: PPUSH
4295: CALL 5930 0 3
4299: ST_TO_ADDR
// uc_side = 8 ;
4300: LD_ADDR_OWVAR 20
4304: PUSH
4305: LD_INT 8
4307: ST_TO_ADDR
// Kurt = PrepareUnitExt ( Kurt , false , 0 ) ;
4308: LD_ADDR_EXP 80
4312: PUSH
4313: LD_STRING Kurt
4315: PPUSH
4316: LD_INT 0
4318: PPUSH
4319: LD_INT 0
4321: PPUSH
4322: CALL 5930 0 3
4326: ST_TO_ADDR
// uc_side = 2 ;
4327: LD_ADDR_OWVAR 20
4331: PUSH
4332: LD_INT 2
4334: ST_TO_ADDR
// Dietrich = PrepareUnitExt ( Dietrich , false , 0 ) ;
4335: LD_ADDR_EXP 81
4339: PUSH
4340: LD_STRING Dietrich
4342: PPUSH
4343: LD_INT 0
4345: PPUSH
4346: LD_INT 0
4348: PPUSH
4349: CALL 5930 0 3
4353: ST_TO_ADDR
// end ;
4354: LD_VAR 0 1
4358: RET
// export function SpawnArAttackTeam ; var i , unit , veh , weapon , chassis ; begin
4359: LD_INT 0
4361: PPUSH
4362: PPUSH
4363: PPUSH
4364: PPUSH
4365: PPUSH
4366: PPUSH
// uc_side = 8 ;
4367: LD_ADDR_OWVAR 20
4371: PUSH
4372: LD_INT 8
4374: ST_TO_ADDR
// uc_nation = 2 ;
4375: LD_ADDR_OWVAR 21
4379: PUSH
4380: LD_INT 2
4382: ST_TO_ADDR
// for i := 1 to Rand ( enemyAttackUnitsData [ 1 ] [ 2 ] , enemyAttackUnitsData [ 1 ] [ 3 ] ) do
4383: LD_ADDR_VAR 0 2
4387: PUSH
4388: DOUBLE
4389: LD_INT 1
4391: DEC
4392: ST_TO_ADDR
4393: LD_EXP 53
4397: PUSH
4398: LD_INT 1
4400: ARRAY
4401: PUSH
4402: LD_INT 2
4404: ARRAY
4405: PPUSH
4406: LD_EXP 53
4410: PUSH
4411: LD_INT 1
4413: ARRAY
4414: PUSH
4415: LD_INT 3
4417: ARRAY
4418: PPUSH
4419: CALL_OW 12
4423: PUSH
4424: FOR_TO
4425: IFFALSE 4482
// begin PrepareSoldier ( false , enemySkillLevel ) ;
4427: LD_INT 0
4429: PPUSH
4430: LD_EXP 56
4434: PPUSH
4435: CALL_OW 381
// unit = CreateHuman ;
4439: LD_ADDR_VAR 0 3
4443: PUSH
4444: CALL_OW 44
4448: ST_TO_ADDR
// PlaceUnitArea ( unit , KurtUnitsSpawnArea , false ) ;
4449: LD_VAR 0 3
4453: PPUSH
4454: LD_INT 10
4456: PPUSH
4457: LD_INT 0
4459: PPUSH
4460: CALL_OW 49
// arAttackTeam = arAttackTeam ^ unit ;
4464: LD_ADDR_EXP 84
4468: PUSH
4469: LD_EXP 84
4473: PUSH
4474: LD_VAR 0 3
4478: ADD
4479: ST_TO_ADDR
// end ;
4480: GO 4424
4482: POP
4483: POP
// for i := 1 to Rand ( enemyAttackUnitsData [ 1 ] [ 4 ] , enemyAttackUnitsData [ 1 ] [ 5 ] ) do
4484: LD_ADDR_VAR 0 2
4488: PUSH
4489: DOUBLE
4490: LD_INT 1
4492: DEC
4493: ST_TO_ADDR
4494: LD_EXP 53
4498: PUSH
4499: LD_INT 1
4501: ARRAY
4502: PUSH
4503: LD_INT 4
4505: ARRAY
4506: PPUSH
4507: LD_EXP 53
4511: PUSH
4512: LD_INT 1
4514: ARRAY
4515: PUSH
4516: LD_INT 5
4518: ARRAY
4519: PPUSH
4520: CALL_OW 12
4524: PUSH
4525: FOR_TO
4526: IFFALSE 4586
// begin PrepareHuman ( false , class_mortar , enemySkillLevel ) ;
4528: LD_INT 0
4530: PPUSH
4531: LD_INT 8
4533: PPUSH
4534: LD_EXP 56
4538: PPUSH
4539: CALL_OW 380
// unit = CreateHuman ;
4543: LD_ADDR_VAR 0 3
4547: PUSH
4548: CALL_OW 44
4552: ST_TO_ADDR
// PlaceUnitArea ( unit , KurtUnitsSpawnArea , false ) ;
4553: LD_VAR 0 3
4557: PPUSH
4558: LD_INT 10
4560: PPUSH
4561: LD_INT 0
4563: PPUSH
4564: CALL_OW 49
// arAttackTeam = arAttackTeam ^ unit ;
4568: LD_ADDR_EXP 84
4572: PUSH
4573: LD_EXP 84
4577: PUSH
4578: LD_VAR 0 3
4582: ADD
4583: ST_TO_ADDR
// end ;
4584: GO 4525
4586: POP
4587: POP
// for i := 1 to Rand ( enemyAttackUnitsData [ 1 ] [ 6 ] , enemyAttackUnitsData [ 1 ] [ 7 ] ) do
4588: LD_ADDR_VAR 0 2
4592: PUSH
4593: DOUBLE
4594: LD_INT 1
4596: DEC
4597: ST_TO_ADDR
4598: LD_EXP 53
4602: PUSH
4603: LD_INT 1
4605: ARRAY
4606: PUSH
4607: LD_INT 6
4609: ARRAY
4610: PPUSH
4611: LD_EXP 53
4615: PUSH
4616: LD_INT 1
4618: ARRAY
4619: PUSH
4620: LD_INT 7
4622: ARRAY
4623: PPUSH
4624: CALL_OW 12
4628: PUSH
4629: FOR_TO
4630: IFFALSE 4824
// begin weapon = [ ar_gun , ar_flame_thrower , ar_rocket_launcher , ar_light_gun , ar_gatling_gun ] [ Rand ( 1 , 5 ) ] ;
4632: LD_ADDR_VAR 0 5
4636: PUSH
4637: LD_INT 27
4639: PUSH
4640: LD_INT 26
4642: PUSH
4643: LD_INT 28
4645: PUSH
4646: LD_INT 23
4648: PUSH
4649: LD_INT 25
4651: PUSH
4652: EMPTY
4653: LIST
4654: LIST
4655: LIST
4656: LIST
4657: LIST
4658: PUSH
4659: LD_INT 1
4661: PPUSH
4662: LD_INT 5
4664: PPUSH
4665: CALL_OW 12
4669: ARRAY
4670: ST_TO_ADDR
// chassis = [ ar_medium_trike , ar_half_tracked ] [ Rand ( 1 , 2 ) ] ;
4671: LD_ADDR_VAR 0 6
4675: PUSH
4676: LD_INT 13
4678: PUSH
4679: LD_INT 14
4681: PUSH
4682: EMPTY
4683: LIST
4684: LIST
4685: PUSH
4686: LD_INT 1
4688: PPUSH
4689: LD_INT 2
4691: PPUSH
4692: CALL_OW 12
4696: ARRAY
4697: ST_TO_ADDR
// PrepareVehicle ( chassis , engine_combustion , control_manual , weapon , Rand ( 70 , 90 ) ) ;
4698: LD_VAR 0 6
4702: PPUSH
4703: LD_INT 1
4705: PPUSH
4706: LD_INT 1
4708: PPUSH
4709: LD_VAR 0 5
4713: PPUSH
4714: LD_INT 70
4716: PPUSH
4717: LD_INT 90
4719: PPUSH
4720: CALL_OW 12
4724: PPUSH
4725: CALL 24239 0 5
// veh = CreateVehicle ;
4729: LD_ADDR_VAR 0 4
4733: PUSH
4734: CALL_OW 45
4738: ST_TO_ADDR
// PlaceUnitArea ( veh , KurtUnitsSpawnArea , false ) ;
4739: LD_VAR 0 4
4743: PPUSH
4744: LD_INT 10
4746: PPUSH
4747: LD_INT 0
4749: PPUSH
4750: CALL_OW 49
// arAttackTeam = arAttackTeam ^ veh ;
4754: LD_ADDR_EXP 84
4758: PUSH
4759: LD_EXP 84
4763: PUSH
4764: LD_VAR 0 4
4768: ADD
4769: ST_TO_ADDR
// PrepareMechanic ( false , enemySkillLevel ) ;
4770: LD_INT 0
4772: PPUSH
4773: LD_EXP 56
4777: PPUSH
4778: CALL_OW 383
// unit = CreateHuman ;
4782: LD_ADDR_VAR 0 3
4786: PUSH
4787: CALL_OW 44
4791: ST_TO_ADDR
// PlaceHumanInUnit ( unit , veh ) ;
4792: LD_VAR 0 3
4796: PPUSH
4797: LD_VAR 0 4
4801: PPUSH
4802: CALL_OW 52
// arAttackTeam = arAttackTeam ^ unit ;
4806: LD_ADDR_EXP 84
4810: PUSH
4811: LD_EXP 84
4815: PUSH
4816: LD_VAR 0 3
4820: ADD
4821: ST_TO_ADDR
// end ;
4822: GO 4629
4824: POP
4825: POP
// end ; end_of_file
4826: LD_VAR 0 1
4830: RET
// export function Nef_PrepareNature ; var i , un ; begin
4831: LD_INT 0
4833: PPUSH
4834: PPUSH
4835: PPUSH
// for i := 1 to animalsAmount [ 1 ] do
4836: LD_ADDR_VAR 0 2
4840: PUSH
4841: DOUBLE
4842: LD_INT 1
4844: DEC
4845: ST_TO_ADDR
4846: LD_EXP 41
4850: PUSH
4851: LD_INT 1
4853: ARRAY
4854: PUSH
4855: FOR_TO
4856: IFFALSE 4966
// begin uc_side = 0 ;
4858: LD_ADDR_OWVAR 20
4862: PUSH
4863: LD_INT 0
4865: ST_TO_ADDR
// uc_nation = nation_nature ;
4866: LD_ADDR_OWVAR 21
4870: PUSH
4871: LD_INT 0
4873: ST_TO_ADDR
// hc_class = class_apeman ;
4874: LD_ADDR_OWVAR 28
4878: PUSH
4879: LD_INT 12
4881: ST_TO_ADDR
// hc_skills = [ animalsStats [ 1 ] , animalsStats [ 2 ] , animalsStats [ 3 ] , animalsStats [ 4 ] ] ;
4882: LD_ADDR_OWVAR 31
4886: PUSH
4887: LD_EXP 42
4891: PUSH
4892: LD_INT 1
4894: ARRAY
4895: PUSH
4896: LD_EXP 42
4900: PUSH
4901: LD_INT 2
4903: ARRAY
4904: PUSH
4905: LD_EXP 42
4909: PUSH
4910: LD_INT 3
4912: ARRAY
4913: PUSH
4914: LD_EXP 42
4918: PUSH
4919: LD_INT 4
4921: ARRAY
4922: PUSH
4923: EMPTY
4924: LIST
4925: LIST
4926: LIST
4927: LIST
4928: ST_TO_ADDR
// hc_agressivity = animalsAgression ;
4929: LD_ADDR_OWVAR 35
4933: PUSH
4934: LD_EXP 43
4938: ST_TO_ADDR
// un = CreateHuman ;
4939: LD_ADDR_VAR 0 3
4943: PUSH
4944: CALL_OW 44
4948: ST_TO_ADDR
// PlaceUnitArea ( un , NatureArea , false ) ;
4949: LD_VAR 0 3
4953: PPUSH
4954: LD_INT 5
4956: PPUSH
4957: LD_INT 0
4959: PPUSH
4960: CALL_OW 49
// end ;
4964: GO 4855
4966: POP
4967: POP
// for i := 1 to animalsAmount [ 2 ] do
4968: LD_ADDR_VAR 0 2
4972: PUSH
4973: DOUBLE
4974: LD_INT 1
4976: DEC
4977: ST_TO_ADDR
4978: LD_EXP 41
4982: PUSH
4983: LD_INT 2
4985: ARRAY
4986: PUSH
4987: FOR_TO
4988: IFFALSE 5098
// begin uc_side = 0 ;
4990: LD_ADDR_OWVAR 20
4994: PUSH
4995: LD_INT 0
4997: ST_TO_ADDR
// uc_nation = nation_nature ;
4998: LD_ADDR_OWVAR 21
5002: PUSH
5003: LD_INT 0
5005: ST_TO_ADDR
// hc_class = class_phororhacos ;
5006: LD_ADDR_OWVAR 28
5010: PUSH
5011: LD_INT 18
5013: ST_TO_ADDR
// hc_skills = [ animalsStats [ 1 ] , animalsStats [ 2 ] , animalsStats [ 3 ] , animalsStats [ 4 ] ] ;
5014: LD_ADDR_OWVAR 31
5018: PUSH
5019: LD_EXP 42
5023: PUSH
5024: LD_INT 1
5026: ARRAY
5027: PUSH
5028: LD_EXP 42
5032: PUSH
5033: LD_INT 2
5035: ARRAY
5036: PUSH
5037: LD_EXP 42
5041: PUSH
5042: LD_INT 3
5044: ARRAY
5045: PUSH
5046: LD_EXP 42
5050: PUSH
5051: LD_INT 4
5053: ARRAY
5054: PUSH
5055: EMPTY
5056: LIST
5057: LIST
5058: LIST
5059: LIST
5060: ST_TO_ADDR
// hc_agressivity = animalsAgression ;
5061: LD_ADDR_OWVAR 35
5065: PUSH
5066: LD_EXP 43
5070: ST_TO_ADDR
// un = CreateHuman ;
5071: LD_ADDR_VAR 0 3
5075: PUSH
5076: CALL_OW 44
5080: ST_TO_ADDR
// PlaceUnitArea ( un , NatureArea , false ) ;
5081: LD_VAR 0 3
5085: PPUSH
5086: LD_INT 5
5088: PPUSH
5089: LD_INT 0
5091: PPUSH
5092: CALL_OW 49
// end ;
5096: GO 4987
5098: POP
5099: POP
// for i := 1 to animalsAmount [ 3 ] do
5100: LD_ADDR_VAR 0 2
5104: PUSH
5105: DOUBLE
5106: LD_INT 1
5108: DEC
5109: ST_TO_ADDR
5110: LD_EXP 41
5114: PUSH
5115: LD_INT 3
5117: ARRAY
5118: PUSH
5119: FOR_TO
5120: IFFALSE 5230
// begin uc_side = 0 ;
5122: LD_ADDR_OWVAR 20
5126: PUSH
5127: LD_INT 0
5129: ST_TO_ADDR
// uc_nation = nation_nature ;
5130: LD_ADDR_OWVAR 21
5134: PUSH
5135: LD_INT 0
5137: ST_TO_ADDR
// hc_class = class_tiger ;
5138: LD_ADDR_OWVAR 28
5142: PUSH
5143: LD_INT 14
5145: ST_TO_ADDR
// hc_skills = [ animalsStats [ 1 ] , animalsStats [ 2 ] , animalsStats [ 3 ] , animalsStats [ 4 ] ] ;
5146: LD_ADDR_OWVAR 31
5150: PUSH
5151: LD_EXP 42
5155: PUSH
5156: LD_INT 1
5158: ARRAY
5159: PUSH
5160: LD_EXP 42
5164: PUSH
5165: LD_INT 2
5167: ARRAY
5168: PUSH
5169: LD_EXP 42
5173: PUSH
5174: LD_INT 3
5176: ARRAY
5177: PUSH
5178: LD_EXP 42
5182: PUSH
5183: LD_INT 4
5185: ARRAY
5186: PUSH
5187: EMPTY
5188: LIST
5189: LIST
5190: LIST
5191: LIST
5192: ST_TO_ADDR
// hc_agressivity = animalsAgression ;
5193: LD_ADDR_OWVAR 35
5197: PUSH
5198: LD_EXP 43
5202: ST_TO_ADDR
// un = CreateHuman ;
5203: LD_ADDR_VAR 0 3
5207: PUSH
5208: CALL_OW 44
5212: ST_TO_ADDR
// PlaceUnitArea ( un , NatureArea , false ) ;
5213: LD_VAR 0 3
5217: PPUSH
5218: LD_INT 5
5220: PPUSH
5221: LD_INT 0
5223: PPUSH
5224: CALL_OW 49
// end ;
5228: GO 5119
5230: POP
5231: POP
// for i := 1 to animalsAmount [ 4 ] do
5232: LD_ADDR_VAR 0 2
5236: PUSH
5237: DOUBLE
5238: LD_INT 1
5240: DEC
5241: ST_TO_ADDR
5242: LD_EXP 41
5246: PUSH
5247: LD_INT 4
5249: ARRAY
5250: PUSH
5251: FOR_TO
5252: IFFALSE 5362
// begin uc_side = 0 ;
5254: LD_ADDR_OWVAR 20
5258: PUSH
5259: LD_INT 0
5261: ST_TO_ADDR
// uc_nation = nation_nature ;
5262: LD_ADDR_OWVAR 21
5266: PUSH
5267: LD_INT 0
5269: ST_TO_ADDR
// hc_class = 21 ;
5270: LD_ADDR_OWVAR 28
5274: PUSH
5275: LD_INT 21
5277: ST_TO_ADDR
// hc_skills = [ animalsStats [ 1 ] , animalsStats [ 2 ] , animalsStats [ 3 ] , animalsStats [ 4 ] ] ;
5278: LD_ADDR_OWVAR 31
5282: PUSH
5283: LD_EXP 42
5287: PUSH
5288: LD_INT 1
5290: ARRAY
5291: PUSH
5292: LD_EXP 42
5296: PUSH
5297: LD_INT 2
5299: ARRAY
5300: PUSH
5301: LD_EXP 42
5305: PUSH
5306: LD_INT 3
5308: ARRAY
5309: PUSH
5310: LD_EXP 42
5314: PUSH
5315: LD_INT 4
5317: ARRAY
5318: PUSH
5319: EMPTY
5320: LIST
5321: LIST
5322: LIST
5323: LIST
5324: ST_TO_ADDR
// hc_agressivity = animalsAgression ;
5325: LD_ADDR_OWVAR 35
5329: PUSH
5330: LD_EXP 43
5334: ST_TO_ADDR
// un = CreateHuman ;
5335: LD_ADDR_VAR 0 3
5339: PUSH
5340: CALL_OW 44
5344: ST_TO_ADDR
// PlaceUnitArea ( un , NatureArea , false ) ;
5345: LD_VAR 0 3
5349: PPUSH
5350: LD_INT 5
5352: PPUSH
5353: LD_INT 0
5355: PPUSH
5356: CALL_OW 49
// end ;
5360: GO 5251
5362: POP
5363: POP
// for i := 1 to animalsAmount [ 5 ] do
5364: LD_ADDR_VAR 0 2
5368: PUSH
5369: DOUBLE
5370: LD_INT 1
5372: DEC
5373: ST_TO_ADDR
5374: LD_EXP 41
5378: PUSH
5379: LD_INT 5
5381: ARRAY
5382: PUSH
5383: FOR_TO
5384: IFFALSE 5445
// begin uc_side = 0 ;
5386: LD_ADDR_OWVAR 20
5390: PUSH
5391: LD_INT 0
5393: ST_TO_ADDR
// uc_nation = nation_nature ;
5394: LD_ADDR_OWVAR 21
5398: PUSH
5399: LD_INT 0
5401: ST_TO_ADDR
// vc_chassis := 31 ;
5402: LD_ADDR_OWVAR 37
5406: PUSH
5407: LD_INT 31
5409: ST_TO_ADDR
// vc_control := control_rider ;
5410: LD_ADDR_OWVAR 38
5414: PUSH
5415: LD_INT 4
5417: ST_TO_ADDR
// un := CreateVehicle ;
5418: LD_ADDR_VAR 0 3
5422: PUSH
5423: CALL_OW 45
5427: ST_TO_ADDR
// PlaceUnitArea ( un , NatureArea , false ) ;
5428: LD_VAR 0 3
5432: PPUSH
5433: LD_INT 5
5435: PPUSH
5436: LD_INT 0
5438: PPUSH
5439: CALL_OW 49
// end ;
5443: GO 5383
5445: POP
5446: POP
// end ;
5447: LD_VAR 0 1
5451: RET
// export function SpawnTrees ; begin
5452: LD_INT 0
5454: PPUSH
// PlaceTreesToArea ( TreeArea , [ 2 , 10 , 11 , 27 , 35 ] , 40 , 10 , 4 ) ;
5455: LD_INT 1
5457: PPUSH
5458: LD_INT 2
5460: PUSH
5461: LD_INT 10
5463: PUSH
5464: LD_INT 11
5466: PUSH
5467: LD_INT 27
5469: PUSH
5470: LD_INT 35
5472: PUSH
5473: EMPTY
5474: LIST
5475: LIST
5476: LIST
5477: LIST
5478: LIST
5479: PPUSH
5480: LD_INT 40
5482: PPUSH
5483: LD_INT 10
5485: PPUSH
5486: LD_INT 4
5488: PPUSH
5489: CALL_OW 352
// PlaceTreesToArea ( TreeArea , [ 9 , 10 , 27 , 35 , 48 ] , 30 , 10 , 4 ) ;
5493: LD_INT 1
5495: PPUSH
5496: LD_INT 9
5498: PUSH
5499: LD_INT 10
5501: PUSH
5502: LD_INT 27
5504: PUSH
5505: LD_INT 35
5507: PUSH
5508: LD_INT 48
5510: PUSH
5511: EMPTY
5512: LIST
5513: LIST
5514: LIST
5515: LIST
5516: LIST
5517: PPUSH
5518: LD_INT 30
5520: PPUSH
5521: LD_INT 10
5523: PPUSH
5524: LD_INT 4
5526: PPUSH
5527: CALL_OW 352
// PlaceTreesToArea ( TreeArea , [ 2 , 9 , 10 , 11 , 27 ] , 60 , 10 , 4 ) ;
5531: LD_INT 1
5533: PPUSH
5534: LD_INT 2
5536: PUSH
5537: LD_INT 9
5539: PUSH
5540: LD_INT 10
5542: PUSH
5543: LD_INT 11
5545: PUSH
5546: LD_INT 27
5548: PUSH
5549: EMPTY
5550: LIST
5551: LIST
5552: LIST
5553: LIST
5554: LIST
5555: PPUSH
5556: LD_INT 60
5558: PPUSH
5559: LD_INT 10
5561: PPUSH
5562: LD_INT 4
5564: PPUSH
5565: CALL_OW 352
// PlaceTreesToArea ( TreeArea , [ 9 , 10 , 27 , 35 , 48 ] , 90 , 10 , 4 ) ;
5569: LD_INT 1
5571: PPUSH
5572: LD_INT 9
5574: PUSH
5575: LD_INT 10
5577: PUSH
5578: LD_INT 27
5580: PUSH
5581: LD_INT 35
5583: PUSH
5584: LD_INT 48
5586: PUSH
5587: EMPTY
5588: LIST
5589: LIST
5590: LIST
5591: LIST
5592: LIST
5593: PPUSH
5594: LD_INT 90
5596: PPUSH
5597: LD_INT 10
5599: PPUSH
5600: LD_INT 4
5602: PPUSH
5603: CALL_OW 352
// PlaceTreesToArea ( TreeArea , [ 2 , 9 , 10 , 11 , 48 ] , 120 , 10 , 4 ) ;
5607: LD_INT 1
5609: PPUSH
5610: LD_INT 2
5612: PUSH
5613: LD_INT 9
5615: PUSH
5616: LD_INT 10
5618: PUSH
5619: LD_INT 11
5621: PUSH
5622: LD_INT 48
5624: PUSH
5625: EMPTY
5626: LIST
5627: LIST
5628: LIST
5629: LIST
5630: LIST
5631: PPUSH
5632: LD_INT 120
5634: PPUSH
5635: LD_INT 10
5637: PPUSH
5638: LD_INT 4
5640: PPUSH
5641: CALL_OW 352
// PlaceTreesToArea ( TreeArea , [ 2 , 11 , 27 , 35 , 48 ] , 45 , 10 , 4 ) ;
5645: LD_INT 1
5647: PPUSH
5648: LD_INT 2
5650: PUSH
5651: LD_INT 11
5653: PUSH
5654: LD_INT 27
5656: PUSH
5657: LD_INT 35
5659: PUSH
5660: LD_INT 48
5662: PUSH
5663: EMPTY
5664: LIST
5665: LIST
5666: LIST
5667: LIST
5668: LIST
5669: PPUSH
5670: LD_INT 45
5672: PPUSH
5673: LD_INT 10
5675: PPUSH
5676: LD_INT 4
5678: PPUSH
5679: CALL_OW 352
// end ;
5683: LD_VAR 0 1
5687: RET
// every 0 0$1 do var i , un ;
5688: GO 5690
5690: DISABLE
5691: LD_INT 0
5693: PPUSH
5694: PPUSH
// begin if ( GetTech ( tech_apelang , 3 ) = state_enabled or GetTech ( tech_apepsych , 3 ) = state_enabled or GetTech ( tech_apeagres , 3 ) = state_enabled ) and not FilterAllUnits ( [ [ f_or , [ f_class , class_apeman ] , [ f_class , class_apeman_engineer ] , [ f_class , class_apeman_soldier ] ] ] ) then
5695: LD_INT 1
5697: PPUSH
5698: LD_INT 3
5700: PPUSH
5701: CALL_OW 321
5705: PUSH
5706: LD_INT 1
5708: EQUAL
5709: PUSH
5710: LD_INT 2
5712: PPUSH
5713: LD_INT 3
5715: PPUSH
5716: CALL_OW 321
5720: PUSH
5721: LD_INT 1
5723: EQUAL
5724: OR
5725: PUSH
5726: LD_INT 11
5728: PPUSH
5729: LD_INT 3
5731: PPUSH
5732: CALL_OW 321
5736: PUSH
5737: LD_INT 1
5739: EQUAL
5740: OR
5741: PUSH
5742: LD_INT 2
5744: PUSH
5745: LD_INT 25
5747: PUSH
5748: LD_INT 12
5750: PUSH
5751: EMPTY
5752: LIST
5753: LIST
5754: PUSH
5755: LD_INT 25
5757: PUSH
5758: LD_INT 16
5760: PUSH
5761: EMPTY
5762: LIST
5763: LIST
5764: PUSH
5765: LD_INT 25
5767: PUSH
5768: LD_INT 15
5770: PUSH
5771: EMPTY
5772: LIST
5773: LIST
5774: PUSH
5775: EMPTY
5776: LIST
5777: LIST
5778: LIST
5779: LIST
5780: PUSH
5781: EMPTY
5782: LIST
5783: PPUSH
5784: CALL_OW 69
5788: NOT
5789: AND
5790: IFFALSE 5926
// begin for i := 1 to Rand ( 2 , 4 ) do
5792: LD_ADDR_VAR 0 1
5796: PUSH
5797: DOUBLE
5798: LD_INT 1
5800: DEC
5801: ST_TO_ADDR
5802: LD_INT 2
5804: PPUSH
5805: LD_INT 4
5807: PPUSH
5808: CALL_OW 12
5812: PUSH
5813: FOR_TO
5814: IFFALSE 5924
// begin uc_side = 0 ;
5816: LD_ADDR_OWVAR 20
5820: PUSH
5821: LD_INT 0
5823: ST_TO_ADDR
// uc_nation = nation_nature ;
5824: LD_ADDR_OWVAR 21
5828: PUSH
5829: LD_INT 0
5831: ST_TO_ADDR
// hc_class = class_apeman ;
5832: LD_ADDR_OWVAR 28
5836: PUSH
5837: LD_INT 12
5839: ST_TO_ADDR
// hc_skills = [ animalsStats [ 1 ] , animalsStats [ 2 ] , animalsStats [ 3 ] , animalsStats [ 4 ] ] ;
5840: LD_ADDR_OWVAR 31
5844: PUSH
5845: LD_EXP 42
5849: PUSH
5850: LD_INT 1
5852: ARRAY
5853: PUSH
5854: LD_EXP 42
5858: PUSH
5859: LD_INT 2
5861: ARRAY
5862: PUSH
5863: LD_EXP 42
5867: PUSH
5868: LD_INT 3
5870: ARRAY
5871: PUSH
5872: LD_EXP 42
5876: PUSH
5877: LD_INT 4
5879: ARRAY
5880: PUSH
5881: EMPTY
5882: LIST
5883: LIST
5884: LIST
5885: LIST
5886: ST_TO_ADDR
// hc_agressivity = animalsAgression ;
5887: LD_ADDR_OWVAR 35
5891: PUSH
5892: LD_EXP 43
5896: ST_TO_ADDR
// un = CreateHuman ;
5897: LD_ADDR_VAR 0 2
5901: PUSH
5902: CALL_OW 44
5906: ST_TO_ADDR
// PlaceUnitArea ( un , NatureArea , false ) ;
5907: LD_VAR 0 2
5911: PPUSH
5912: LD_INT 5
5914: PPUSH
5915: LD_INT 0
5917: PPUSH
5918: CALL_OW 49
// end ;
5922: GO 5813
5924: POP
5925: POP
// end ; enable ;
5926: ENABLE
// end ; end_of_file
5927: PPOPN 2
5929: END
// export function PrepareUnitExt ( ident , exist_mode , class ) ; var unit ; begin
5930: LD_INT 0
5932: PPUSH
5933: PPUSH
// if debugMode then
5934: LD_EXP 46
5938: IFFALSE 5955
// unit := NewCharacter ( ident ) ;
5940: LD_ADDR_VAR 0 5
5944: PUSH
5945: LD_VAR 0 1
5949: PPUSH
5950: CALL_OW 25
5954: ST_TO_ADDR
// if exist_mode and not debugMode then
5955: LD_VAR 0 2
5959: PUSH
5960: LD_EXP 46
5964: NOT
5965: AND
5966: IFFALSE 5991
// unit := CreateCharacter ( previousMissionPrefix & ident ) else
5968: LD_ADDR_VAR 0 5
5972: PUSH
5973: LD_EXP 45
5977: PUSH
5978: LD_VAR 0 1
5982: STR
5983: PPUSH
5984: CALL_OW 34
5988: ST_TO_ADDR
5989: GO 6013
// if not debugMode then
5991: LD_EXP 46
5995: NOT
5996: IFFALSE 6013
// unit := NewCharacter ( ident ) ;
5998: LD_ADDR_VAR 0 5
6002: PUSH
6003: LD_VAR 0 1
6007: PPUSH
6008: CALL_OW 25
6012: ST_TO_ADDR
// if class then
6013: LD_VAR 0 3
6017: IFFALSE 6033
// SetClass ( unit , class ) ;
6019: LD_VAR 0 5
6023: PPUSH
6024: LD_VAR 0 3
6028: PPUSH
6029: CALL_OW 336
// result := unit ;
6033: LD_ADDR_VAR 0 4
6037: PUSH
6038: LD_VAR 0 5
6042: ST_TO_ADDR
// end ;
6043: LD_VAR 0 4
6047: RET
// export function ExtSaveCharacter ( character , characterStringID , side ) ; begin
6048: LD_INT 0
6050: PPUSH
// if GetSide ( character ) = side and not IsDead ( character ) then
6051: LD_VAR 0 1
6055: PPUSH
6056: CALL_OW 255
6060: PUSH
6061: LD_VAR 0 3
6065: EQUAL
6066: PUSH
6067: LD_VAR 0 1
6071: PPUSH
6072: CALL_OW 301
6076: NOT
6077: AND
6078: IFFALSE 6100
// SaveCharacters ( character , missionPrefix & characterStringID ) ;
6080: LD_VAR 0 1
6084: PPUSH
6085: LD_EXP 44
6089: PUSH
6090: LD_VAR 0 2
6094: STR
6095: PPUSH
6096: CALL_OW 38
// end ;
6100: LD_VAR 0 4
6104: RET
// export function ExtSaveCharacters ( characters , charactersStringID , side ) ; var unit , resultCharactersToSave ; begin
6105: LD_INT 0
6107: PPUSH
6108: PPUSH
6109: PPUSH
// resultCharactersToSave = [ ] ;
6110: LD_ADDR_VAR 0 6
6114: PUSH
6115: EMPTY
6116: ST_TO_ADDR
// for unit in characters do
6117: LD_ADDR_VAR 0 5
6121: PUSH
6122: LD_VAR 0 1
6126: PUSH
6127: FOR_IN
6128: IFFALSE 6177
// if GetSide ( unit ) = side and not IsDead ( unit ) then
6130: LD_VAR 0 5
6134: PPUSH
6135: CALL_OW 255
6139: PUSH
6140: LD_VAR 0 3
6144: EQUAL
6145: PUSH
6146: LD_VAR 0 5
6150: PPUSH
6151: CALL_OW 301
6155: NOT
6156: AND
6157: IFFALSE 6175
// resultCharactersToSave = resultCharactersToSave ^ unit ;
6159: LD_ADDR_VAR 0 6
6163: PUSH
6164: LD_VAR 0 6
6168: PUSH
6169: LD_VAR 0 5
6173: ADD
6174: ST_TO_ADDR
6175: GO 6127
6177: POP
6178: POP
// SaveCharacters ( resultCharactersToSave , missionPrefix & charactersStringID ) ;
6179: LD_VAR 0 6
6183: PPUSH
6184: LD_EXP 44
6188: PUSH
6189: LD_VAR 0 2
6193: STR
6194: PPUSH
6195: CALL_OW 38
// end ;
6199: LD_VAR 0 4
6203: RET
// export function PlaceUnitsArea ( units , area , spawnMode ) ; var unit ; begin
6204: LD_INT 0
6206: PPUSH
6207: PPUSH
// for unit in units do
6208: LD_ADDR_VAR 0 5
6212: PUSH
6213: LD_VAR 0 1
6217: PUSH
6218: FOR_IN
6219: IFFALSE 6242
// PlaceUnitArea ( unit , area , spawnMode ) ;
6221: LD_VAR 0 5
6225: PPUSH
6226: LD_VAR 0 2
6230: PPUSH
6231: LD_VAR 0 3
6235: PPUSH
6236: CALL_OW 49
6240: GO 6218
6242: POP
6243: POP
// end ;
6244: LD_VAR 0 4
6248: RET
// export function DialogRandom ( characters , dialogMID , dialogFID , radio , canTalkHero ) ; var i , speaker , units ; begin
6249: LD_INT 0
6251: PPUSH
6252: PPUSH
6253: PPUSH
6254: PPUSH
// units = characters ;
6255: LD_ADDR_VAR 0 9
6259: PUSH
6260: LD_VAR 0 1
6264: ST_TO_ADDR
// units := units diff [ Burlak , Karamazov , Petrovova , Gleb , Petrosyan , Titov , Dolgov , Lipshchin , Kirilenkova ] ;
6265: LD_ADDR_VAR 0 9
6269: PUSH
6270: LD_VAR 0 9
6274: PUSH
6275: LD_EXP 57
6279: PUSH
6280: LD_EXP 58
6284: PUSH
6285: LD_EXP 59
6289: PUSH
6290: LD_EXP 60
6294: PUSH
6295: LD_EXP 61
6299: PUSH
6300: LD_EXP 62
6304: PUSH
6305: LD_EXP 63
6309: PUSH
6310: LD_EXP 64
6314: PUSH
6315: LD_EXP 65
6319: PUSH
6320: EMPTY
6321: LIST
6322: LIST
6323: LIST
6324: LIST
6325: LIST
6326: LIST
6327: LIST
6328: LIST
6329: LIST
6330: DIFF
6331: ST_TO_ADDR
// if not units and not canTalkHero then
6332: LD_VAR 0 9
6336: NOT
6337: PUSH
6338: LD_VAR 0 5
6342: NOT
6343: AND
6344: IFFALSE 6348
// exit ;
6346: GO 6521
// if not units then
6348: LD_VAR 0 9
6352: NOT
6353: IFFALSE 6374
// units = characters diff [ Burlak ] ;
6355: LD_ADDR_VAR 0 9
6359: PUSH
6360: LD_VAR 0 1
6364: PUSH
6365: LD_EXP 57
6369: PUSH
6370: EMPTY
6371: LIST
6372: DIFF
6373: ST_TO_ADDR
// if not units and canTalkHero then
6374: LD_VAR 0 9
6378: NOT
6379: PUSH
6380: LD_VAR 0 5
6384: AND
6385: IFFALSE 6389
// exit ;
6387: GO 6521
// speaker := units [ rand ( 1 , units ) ] ;
6389: LD_ADDR_VAR 0 8
6393: PUSH
6394: LD_VAR 0 9
6398: PUSH
6399: LD_INT 1
6401: PPUSH
6402: LD_VAR 0 9
6406: PPUSH
6407: CALL_OW 12
6411: ARRAY
6412: ST_TO_ADDR
// if radio then
6413: LD_VAR 0 4
6417: IFFALSE 6466
// begin if GetSex ( speaker ) = sex_male then
6419: LD_VAR 0 8
6423: PPUSH
6424: CALL_OW 258
6428: PUSH
6429: LD_INT 1
6431: EQUAL
6432: IFFALSE 6450
// SayRadio ( speaker , dialogMID ) else
6434: LD_VAR 0 8
6438: PPUSH
6439: LD_VAR 0 2
6443: PPUSH
6444: CALL_OW 94
6448: GO 6464
// SayRadio ( speaker , dialogFID ) ;
6450: LD_VAR 0 8
6454: PPUSH
6455: LD_VAR 0 3
6459: PPUSH
6460: CALL_OW 94
// end else
6464: GO 6511
// begin if GetSex ( speaker ) = sex_male then
6466: LD_VAR 0 8
6470: PPUSH
6471: CALL_OW 258
6475: PUSH
6476: LD_INT 1
6478: EQUAL
6479: IFFALSE 6497
// Say ( speaker , dialogMID ) else
6481: LD_VAR 0 8
6485: PPUSH
6486: LD_VAR 0 2
6490: PPUSH
6491: CALL_OW 88
6495: GO 6511
// Say ( speaker , dialogFID ) ;
6497: LD_VAR 0 8
6501: PPUSH
6502: LD_VAR 0 3
6506: PPUSH
6507: CALL_OW 88
// end ; result := speaker ;
6511: LD_ADDR_VAR 0 6
6515: PUSH
6516: LD_VAR 0 8
6520: ST_TO_ADDR
// end ;
6521: LD_VAR 0 6
6525: RET
// export function RemoveUnits ( units ) ; var unit ; begin
6526: LD_INT 0
6528: PPUSH
6529: PPUSH
// if not units then
6530: LD_VAR 0 1
6534: NOT
6535: IFFALSE 6539
// exit ;
6537: GO 6685
// if Heike in units then
6539: LD_EXP 79
6543: PUSH
6544: LD_VAR 0 1
6548: IN
6549: IFFALSE 6605
// begin if GetAttitude ( 3 , 8 ) = att_neutral then
6551: LD_INT 3
6553: PPUSH
6554: LD_INT 8
6556: PPUSH
6557: CALL_OW 81
6561: PUSH
6562: LD_INT 0
6564: EQUAL
6565: IFFALSE 6577
// HeikeStatus = 1 else
6567: LD_ADDR_EXP 3
6571: PUSH
6572: LD_INT 1
6574: ST_TO_ADDR
6575: GO 6585
// HeikeStatus = 2 ;
6577: LD_ADDR_EXP 3
6581: PUSH
6582: LD_INT 2
6584: ST_TO_ADDR
// forceStopKurtAttack = true ;
6585: LD_ADDR_EXP 27
6589: PUSH
6590: LD_INT 1
6592: ST_TO_ADDR
// SetClass ( Heike , 1 ) ;
6593: LD_EXP 79
6597: PPUSH
6598: LD_INT 1
6600: PPUSH
6601: CALL_OW 336
// end ; if Kurt in units then
6605: LD_EXP 80
6609: PUSH
6610: LD_VAR 0 1
6614: IN
6615: IFFALSE 6659
// begin if GetAttitude ( 3 , 8 ) = att_neutral then
6617: LD_INT 3
6619: PPUSH
6620: LD_INT 8
6622: PPUSH
6623: CALL_OW 81
6627: PUSH
6628: LD_INT 0
6630: EQUAL
6631: IFFALSE 6643
// KurtStatus = 1 else
6633: LD_ADDR_EXP 22
6637: PUSH
6638: LD_INT 1
6640: ST_TO_ADDR
6641: GO 6659
// begin KurtStatus = 2 ;
6643: LD_ADDR_EXP 22
6647: PUSH
6648: LD_INT 2
6650: ST_TO_ADDR
// KurtAttack = 1 ;
6651: LD_ADDR_EXP 25
6655: PUSH
6656: LD_INT 1
6658: ST_TO_ADDR
// end ; end ; for unit in units do
6659: LD_ADDR_VAR 0 3
6663: PUSH
6664: LD_VAR 0 1
6668: PUSH
6669: FOR_IN
6670: IFFALSE 6683
// RemoveUnit ( unit ) ;
6672: LD_VAR 0 3
6676: PPUSH
6677: CALL_OW 64
6681: GO 6669
6683: POP
6684: POP
// end ;
6685: LD_VAR 0 2
6689: RET
// export function GetAmountWeaponsDataBuildOnTurret ( isBuild ) ; var i , amount ; begin
6690: LD_INT 0
6692: PPUSH
6693: PPUSH
6694: PPUSH
// amount = 0 ;
6695: LD_ADDR_VAR 0 4
6699: PUSH
6700: LD_INT 0
6702: ST_TO_ADDR
// for i := 1 to weaponsData do
6703: LD_ADDR_VAR 0 3
6707: PUSH
6708: DOUBLE
6709: LD_INT 1
6711: DEC
6712: ST_TO_ADDR
6713: LD_EXP 12
6717: PUSH
6718: FOR_TO
6719: IFFALSE 6759
// if weaponsData [ i ] [ 2 ] = isBuild then
6721: LD_EXP 12
6725: PUSH
6726: LD_VAR 0 3
6730: ARRAY
6731: PUSH
6732: LD_INT 2
6734: ARRAY
6735: PUSH
6736: LD_VAR 0 1
6740: EQUAL
6741: IFFALSE 6757
// amount = amount + 1 ;
6743: LD_ADDR_VAR 0 4
6747: PUSH
6748: LD_VAR 0 4
6752: PUSH
6753: LD_INT 1
6755: PLUS
6756: ST_TO_ADDR
6757: GO 6718
6759: POP
6760: POP
// if isBuild then
6761: LD_VAR 0 1
6765: IFFALSE 6785
// if amount >= 3 then
6767: LD_VAR 0 4
6771: PUSH
6772: LD_INT 3
6774: GREATEREQUAL
6775: IFFALSE 6785
// amount = 3 ;
6777: LD_ADDR_VAR 0 4
6781: PUSH
6782: LD_INT 3
6784: ST_TO_ADDR
// result = amount ;
6785: LD_ADDR_VAR 0 2
6789: PUSH
6790: LD_VAR 0 4
6794: ST_TO_ADDR
// end ;
6795: LD_VAR 0 2
6799: RET
// export function GetAmountWeaponsDataBuildOnVehicle ( isBuild ) ; var i , amount ; begin
6800: LD_INT 0
6802: PPUSH
6803: PPUSH
6804: PPUSH
// amount = 0 ;
6805: LD_ADDR_VAR 0 4
6809: PUSH
6810: LD_INT 0
6812: ST_TO_ADDR
// for i := 1 to weaponsData do
6813: LD_ADDR_VAR 0 3
6817: PUSH
6818: DOUBLE
6819: LD_INT 1
6821: DEC
6822: ST_TO_ADDR
6823: LD_EXP 12
6827: PUSH
6828: FOR_TO
6829: IFFALSE 6869
// if weaponsData [ i ] [ 3 ] = isBuild then
6831: LD_EXP 12
6835: PUSH
6836: LD_VAR 0 3
6840: ARRAY
6841: PUSH
6842: LD_INT 3
6844: ARRAY
6845: PUSH
6846: LD_VAR 0 1
6850: EQUAL
6851: IFFALSE 6867
// amount = amount + 1 ;
6853: LD_ADDR_VAR 0 4
6857: PUSH
6858: LD_VAR 0 4
6862: PUSH
6863: LD_INT 1
6865: PLUS
6866: ST_TO_ADDR
6867: GO 6828
6869: POP
6870: POP
// result = amount ;
6871: LD_ADDR_VAR 0 2
6875: PUSH
6876: LD_VAR 0 4
6880: ST_TO_ADDR
// end ;
6881: LD_VAR 0 2
6885: RET
// export function SetWeaponDataBuild ( weapon , turret ) ; var i ; begin
6886: LD_INT 0
6888: PPUSH
6889: PPUSH
// if turret then
6890: LD_VAR 0 2
6894: IFFALSE 6992
// begin for i := 1 to weaponsData do
6896: LD_ADDR_VAR 0 4
6900: PUSH
6901: DOUBLE
6902: LD_INT 1
6904: DEC
6905: ST_TO_ADDR
6906: LD_EXP 12
6910: PUSH
6911: FOR_TO
6912: IFFALSE 6988
// if weaponsData [ i ] [ 1 ] = weapon and weaponsData [ i ] [ 2 ] = false then
6914: LD_EXP 12
6918: PUSH
6919: LD_VAR 0 4
6923: ARRAY
6924: PUSH
6925: LD_INT 1
6927: ARRAY
6928: PUSH
6929: LD_VAR 0 1
6933: EQUAL
6934: PUSH
6935: LD_EXP 12
6939: PUSH
6940: LD_VAR 0 4
6944: ARRAY
6945: PUSH
6946: LD_INT 2
6948: ARRAY
6949: PUSH
6950: LD_INT 0
6952: EQUAL
6953: AND
6954: IFFALSE 6986
// weaponsData = ReplaceIn ( weaponsData , [ i , 2 ] , true ) ;
6956: LD_ADDR_EXP 12
6960: PUSH
6961: LD_EXP 12
6965: PPUSH
6966: LD_VAR 0 4
6970: PUSH
6971: LD_INT 2
6973: PUSH
6974: EMPTY
6975: LIST
6976: LIST
6977: PPUSH
6978: LD_INT 1
6980: PPUSH
6981: CALL 24361 0 3
6985: ST_TO_ADDR
6986: GO 6911
6988: POP
6989: POP
// end else
6990: GO 7086
// begin for i := 1 to weaponsData do
6992: LD_ADDR_VAR 0 4
6996: PUSH
6997: DOUBLE
6998: LD_INT 1
7000: DEC
7001: ST_TO_ADDR
7002: LD_EXP 12
7006: PUSH
7007: FOR_TO
7008: IFFALSE 7084
// if weaponsData [ i ] [ 1 ] = weapon and weaponsData [ i ] [ 3 ] = false then
7010: LD_EXP 12
7014: PUSH
7015: LD_VAR 0 4
7019: ARRAY
7020: PUSH
7021: LD_INT 1
7023: ARRAY
7024: PUSH
7025: LD_VAR 0 1
7029: EQUAL
7030: PUSH
7031: LD_EXP 12
7035: PUSH
7036: LD_VAR 0 4
7040: ARRAY
7041: PUSH
7042: LD_INT 3
7044: ARRAY
7045: PUSH
7046: LD_INT 0
7048: EQUAL
7049: AND
7050: IFFALSE 7082
// weaponsData = ReplaceIn ( weaponsData , [ i , 3 ] , true ) ;
7052: LD_ADDR_EXP 12
7056: PUSH
7057: LD_EXP 12
7061: PPUSH
7062: LD_VAR 0 4
7066: PUSH
7067: LD_INT 3
7069: PUSH
7070: EMPTY
7071: LIST
7072: LIST
7073: PPUSH
7074: LD_INT 1
7076: PPUSH
7077: CALL 24361 0 3
7081: ST_TO_ADDR
7082: GO 7007
7084: POP
7085: POP
// end ; end ;
7086: LD_VAR 0 3
7090: RET
// export function ShootTreningController ; var i , unitsInArea , unit , depots , depot , barrelsAreaList , randIndex , randPosX , randPosY , barrelsInArea ; begin
7091: LD_INT 0
7093: PPUSH
7094: PPUSH
7095: PPUSH
7096: PPUSH
7097: PPUSH
7098: PPUSH
7099: PPUSH
7100: PPUSH
7101: PPUSH
7102: PPUSH
7103: PPUSH
// unitsInArea = FilterUnitsInArea ( ShootArea , [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) ;
7104: LD_ADDR_VAR 0 3
7108: PUSH
7109: LD_INT 12
7111: PPUSH
7112: LD_INT 22
7114: PUSH
7115: LD_INT 3
7117: PUSH
7118: EMPTY
7119: LIST
7120: LIST
7121: PUSH
7122: LD_INT 21
7124: PUSH
7125: LD_INT 1
7127: PUSH
7128: EMPTY
7129: LIST
7130: LIST
7131: PUSH
7132: LD_INT 50
7134: PUSH
7135: EMPTY
7136: LIST
7137: PUSH
7138: LD_INT 3
7140: PUSH
7141: LD_INT 60
7143: PUSH
7144: EMPTY
7145: LIST
7146: PUSH
7147: EMPTY
7148: LIST
7149: LIST
7150: PUSH
7151: EMPTY
7152: LIST
7153: LIST
7154: LIST
7155: LIST
7156: PPUSH
7157: CALL_OW 70
7161: ST_TO_ADDR
// depots = FilterAllUnits ( [ [ f_side , 3 ] , [ f_ok ] , [ f_type , unit_building ] , [ f_not , [ f_constructed ] ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
7162: LD_ADDR_VAR 0 5
7166: PUSH
7167: LD_INT 22
7169: PUSH
7170: LD_INT 3
7172: PUSH
7173: EMPTY
7174: LIST
7175: LIST
7176: PUSH
7177: LD_INT 50
7179: PUSH
7180: EMPTY
7181: LIST
7182: PUSH
7183: LD_INT 21
7185: PUSH
7186: LD_INT 3
7188: PUSH
7189: EMPTY
7190: LIST
7191: LIST
7192: PUSH
7193: LD_INT 3
7195: PUSH
7196: LD_INT 57
7198: PUSH
7199: EMPTY
7200: LIST
7201: PUSH
7202: EMPTY
7203: LIST
7204: LIST
7205: PUSH
7206: LD_INT 2
7208: PUSH
7209: LD_INT 30
7211: PUSH
7212: LD_INT 0
7214: PUSH
7215: EMPTY
7216: LIST
7217: LIST
7218: PUSH
7219: LD_INT 30
7221: PUSH
7222: LD_INT 1
7224: PUSH
7225: EMPTY
7226: LIST
7227: LIST
7228: PUSH
7229: EMPTY
7230: LIST
7231: LIST
7232: LIST
7233: PUSH
7234: EMPTY
7235: LIST
7236: LIST
7237: LIST
7238: LIST
7239: LIST
7240: PPUSH
7241: CALL_OW 69
7245: ST_TO_ADDR
// barrelsAreaList = AreaToList ( BarrelsArea , 0 ) ;
7246: LD_ADDR_VAR 0 7
7250: PUSH
7251: LD_INT 13
7253: PPUSH
7254: LD_INT 0
7256: PPUSH
7257: CALL_OW 517
7261: ST_TO_ADDR
// if not depots or not unitsInArea then
7262: LD_VAR 0 5
7266: NOT
7267: PUSH
7268: LD_VAR 0 3
7272: NOT
7273: OR
7274: IFFALSE 7278
// exit ;
7276: GO 7714
// depot = depots [ 1 ] ;
7278: LD_ADDR_VAR 0 6
7282: PUSH
7283: LD_VAR 0 5
7287: PUSH
7288: LD_INT 1
7290: ARRAY
7291: ST_TO_ADDR
// for unit in unitsInArea do
7292: LD_ADDR_VAR 0 4
7296: PUSH
7297: LD_VAR 0 3
7301: PUSH
7302: FOR_IN
7303: IFFALSE 7712
// begin if not GetClass ( unit ) = class_engineer then
7305: LD_VAR 0 4
7309: PPUSH
7310: CALL_OW 257
7314: PUSH
7315: LD_INT 2
7317: EQUAL
7318: NOT
7319: IFFALSE 7356
// begin ComEnterUnit ( unit , depot ) ;
7321: LD_VAR 0 4
7325: PPUSH
7326: LD_VAR 0 6
7330: PPUSH
7331: CALL_OW 120
// AddComChangeProfession ( unit , class_engineer ) ;
7335: LD_VAR 0 4
7339: PPUSH
7340: LD_INT 2
7342: PPUSH
7343: CALL_OW 183
// AddComExitBuilding ( unit ) ;
7347: LD_VAR 0 4
7351: PPUSH
7352: CALL_OW 182
// end ; if GetCargo ( unit , mat_oil ) = 0 then
7356: LD_VAR 0 4
7360: PPUSH
7361: LD_INT 2
7363: PPUSH
7364: CALL_OW 289
7368: PUSH
7369: LD_INT 0
7371: EQUAL
7372: IFFALSE 7391
// AddComTransport ( unit , depot , mat_oil ) ;
7374: LD_VAR 0 4
7378: PPUSH
7379: LD_VAR 0 6
7383: PPUSH
7384: LD_INT 2
7386: PPUSH
7387: CALL_OW 211
// repeat wait ( 0 0$1 ) ;
7391: LD_INT 35
7393: PPUSH
7394: CALL_OW 67
// until not HasTask ( unit ) ;
7398: LD_VAR 0 4
7402: PPUSH
7403: CALL_OW 314
7407: NOT
7408: IFFALSE 7391
// if GetCargo ( unit , mat_oil ) > 0 then
7410: LD_VAR 0 4
7414: PPUSH
7415: LD_INT 2
7417: PPUSH
7418: CALL_OW 289
7422: PUSH
7423: LD_INT 0
7425: GREATER
7426: IFFALSE 7710
// begin randIndex = Rand ( 1 , barrelsAreaList [ 1 ] ) ;
7428: LD_ADDR_VAR 0 8
7432: PUSH
7433: LD_INT 1
7435: PPUSH
7436: LD_VAR 0 7
7440: PUSH
7441: LD_INT 1
7443: ARRAY
7444: PPUSH
7445: CALL_OW 12
7449: ST_TO_ADDR
// randPosX = barrelsAreaList [ 1 ] [ randIndex ] ;
7450: LD_ADDR_VAR 0 9
7454: PUSH
7455: LD_VAR 0 7
7459: PUSH
7460: LD_INT 1
7462: ARRAY
7463: PUSH
7464: LD_VAR 0 8
7468: ARRAY
7469: ST_TO_ADDR
// randPosY = barrelsAreaList [ 2 ] [ RandIndex ] ;
7470: LD_ADDR_VAR 0 10
7474: PUSH
7475: LD_VAR 0 7
7479: PUSH
7480: LD_INT 2
7482: ARRAY
7483: PUSH
7484: LD_VAR 0 8
7488: ARRAY
7489: ST_TO_ADDR
// AddComMoveXY ( unit , randPosX , randPosY ) ;
7490: LD_VAR 0 4
7494: PPUSH
7495: LD_VAR 0 9
7499: PPUSH
7500: LD_VAR 0 10
7504: PPUSH
7505: CALL_OW 171
// AddComUnload ( unit ) ;
7509: LD_VAR 0 4
7513: PPUSH
7514: CALL_OW 219
// AddComMoveXY ( unit , randPosX + 2 , randPosY + 2 ) ;
7518: LD_VAR 0 4
7522: PPUSH
7523: LD_VAR 0 9
7527: PUSH
7528: LD_INT 2
7530: PLUS
7531: PPUSH
7532: LD_VAR 0 10
7536: PUSH
7537: LD_INT 2
7539: PLUS
7540: PPUSH
7541: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
7545: LD_INT 35
7547: PPUSH
7548: CALL_OW 67
// until not HasTask ( unit ) ;
7552: LD_VAR 0 4
7556: PPUSH
7557: CALL_OW 314
7561: NOT
7562: IFFALSE 7545
// barrelsInArea = GetListOfCratesInArea ( ShootArea ) ;
7564: LD_ADDR_VAR 0 11
7568: PUSH
7569: LD_INT 12
7571: PPUSH
7572: CALL_OW 435
7576: ST_TO_ADDR
// for i := 1 to barrelsInArea / 2 do
7577: LD_ADDR_VAR 0 2
7581: PUSH
7582: DOUBLE
7583: LD_INT 1
7585: DEC
7586: ST_TO_ADDR
7587: LD_VAR 0 11
7591: PUSH
7592: LD_INT 2
7594: DIVREAL
7595: PUSH
7596: FOR_TO
7597: IFFALSE 7708
// begin if GetDistUnitXY ( unit , barrelsInArea [ i ] , barrelsInArea [ i + 1 ] ) <= 6 then
7599: LD_VAR 0 4
7603: PPUSH
7604: LD_VAR 0 11
7608: PUSH
7609: LD_VAR 0 2
7613: ARRAY
7614: PPUSH
7615: LD_VAR 0 11
7619: PUSH
7620: LD_VAR 0 2
7624: PUSH
7625: LD_INT 1
7627: PLUS
7628: ARRAY
7629: PPUSH
7630: CALL_OW 297
7634: PUSH
7635: LD_INT 6
7637: LESSEQUAL
7638: IFFALSE 7692
// begin AddComAttackPlace ( unit , barrelsInArea [ i ] , barrelsInArea [ i + 1 ] ) ;
7640: LD_VAR 0 4
7644: PPUSH
7645: LD_VAR 0 11
7649: PUSH
7650: LD_VAR 0 2
7654: ARRAY
7655: PPUSH
7656: LD_VAR 0 11
7660: PUSH
7661: LD_VAR 0 2
7665: PUSH
7666: LD_INT 1
7668: PLUS
7669: ARRAY
7670: PPUSH
7671: CALL_OW 176
// AddExperience ( unit , skill_combat , 5 ) ;
7675: LD_VAR 0 4
7679: PPUSH
7680: LD_INT 1
7682: PPUSH
7683: LD_INT 5
7685: PPUSH
7686: CALL_OW 492
// break ;
7690: GO 7708
// end ; i = i + 2 ;
7692: LD_ADDR_VAR 0 2
7696: PUSH
7697: LD_VAR 0 2
7701: PUSH
7702: LD_INT 2
7704: PLUS
7705: ST_TO_ADDR
// end ;
7706: GO 7596
7708: POP
7709: POP
// end ; end ;
7710: GO 7302
7712: POP
7713: POP
// end ;
7714: LD_VAR 0 1
7718: RET
// export function GoToHunt ( hunter ) ; var i , barracks , barrackTarget , barrackTargetCurrentHP , animals , animal ; begin
7719: LD_INT 0
7721: PPUSH
7722: PPUSH
7723: PPUSH
7724: PPUSH
7725: PPUSH
7726: PPUSH
7727: PPUSH
// animals = [ ] ;
7728: LD_ADDR_VAR 0 7
7732: PUSH
7733: EMPTY
7734: ST_TO_ADDR
// barracks = FilterAllUnits ( [ [ f_ok ] , [ f_not , [ f_constructed ] ] , [ f_or , [ f_btype , b_barracks ] , [ f_btype , b_armoury ] ] ] ) ;
7735: LD_ADDR_VAR 0 4
7739: PUSH
7740: LD_INT 50
7742: PUSH
7743: EMPTY
7744: LIST
7745: PUSH
7746: LD_INT 3
7748: PUSH
7749: LD_INT 57
7751: PUSH
7752: EMPTY
7753: LIST
7754: PUSH
7755: EMPTY
7756: LIST
7757: LIST
7758: PUSH
7759: LD_INT 2
7761: PUSH
7762: LD_INT 30
7764: PUSH
7765: LD_INT 5
7767: PUSH
7768: EMPTY
7769: LIST
7770: LIST
7771: PUSH
7772: LD_INT 30
7774: PUSH
7775: LD_INT 4
7777: PUSH
7778: EMPTY
7779: LIST
7780: LIST
7781: PUSH
7782: EMPTY
7783: LIST
7784: LIST
7785: LIST
7786: PUSH
7787: EMPTY
7788: LIST
7789: LIST
7790: LIST
7791: PPUSH
7792: CALL_OW 69
7796: ST_TO_ADDR
// SetSide ( hunter , 6 ) ;
7797: LD_VAR 0 1
7801: PPUSH
7802: LD_INT 6
7804: PPUSH
7805: CALL_OW 235
// if IsInUnit ( hunter ) then
7809: LD_VAR 0 1
7813: PPUSH
7814: CALL_OW 310
7818: IFFALSE 7860
// begin if GetBType ( IsInUnit ( hunter ) = unit_vehicle ) then
7820: LD_VAR 0 1
7824: PPUSH
7825: CALL_OW 310
7829: PUSH
7830: LD_INT 2
7832: EQUAL
7833: PPUSH
7834: CALL_OW 266
7838: IFFALSE 7851
// ComExitVehicle ( hunter ) else
7840: LD_VAR 0 1
7844: PPUSH
7845: CALL_OW 121
7849: GO 7860
// ComExitBuilding ( hunter ) ;
7851: LD_VAR 0 1
7855: PPUSH
7856: CALL_OW 122
// end ; ComWalk ( hunter ) ;
7860: LD_VAR 0 1
7864: PPUSH
7865: CALL_OW 138
// wait ( 0 0$1 ) ;
7869: LD_INT 35
7871: PPUSH
7872: CALL_OW 67
// if not GetClass ( hunter ) = class_soldier and barracks then
7876: LD_VAR 0 1
7880: PPUSH
7881: CALL_OW 257
7885: PUSH
7886: LD_INT 1
7888: EQUAL
7889: NOT
7890: PUSH
7891: LD_VAR 0 4
7895: AND
7896: IFFALSE 8039
// begin barrackTarget = barracks [ 1 ] ;
7898: LD_ADDR_VAR 0 5
7902: PUSH
7903: LD_VAR 0 4
7907: PUSH
7908: LD_INT 1
7910: ARRAY
7911: ST_TO_ADDR
// barrackTargetCurrentHP = GetLives ( barrackTarget ) ;
7912: LD_ADDR_VAR 0 6
7916: PUSH
7917: LD_VAR 0 5
7921: PPUSH
7922: CALL_OW 256
7926: ST_TO_ADDR
// SetSide ( barrackTarget , 6 ) ;
7927: LD_VAR 0 5
7931: PPUSH
7932: LD_INT 6
7934: PPUSH
7935: CALL_OW 235
// ComEnterUnit ( hunter , barrackTarget ) ;
7939: LD_VAR 0 1
7943: PPUSH
7944: LD_VAR 0 5
7948: PPUSH
7949: CALL_OW 120
// repeat wait ( 0 0$1 ) ;
7953: LD_INT 35
7955: PPUSH
7956: CALL_OW 67
// ComEnterUnit ( hunter , barrackTarget ) ;
7960: LD_VAR 0 1
7964: PPUSH
7965: LD_VAR 0 5
7969: PPUSH
7970: CALL_OW 120
// SetLives ( barrackTarget , barrackTargetCurrentHP ) ;
7974: LD_VAR 0 5
7978: PPUSH
7979: LD_VAR 0 6
7983: PPUSH
7984: CALL_OW 234
// until IsInUnit ( hunter ) ;
7988: LD_VAR 0 1
7992: PPUSH
7993: CALL_OW 310
7997: IFFALSE 7953
// SetClass ( hunter , class_soldier ) ;
7999: LD_VAR 0 1
8003: PPUSH
8004: LD_INT 1
8006: PPUSH
8007: CALL_OW 336
// ComExitBuilding ( hunter ) ;
8011: LD_VAR 0 1
8015: PPUSH
8016: CALL_OW 122
// SetSide ( barrackTarget , 3 ) ;
8020: LD_VAR 0 5
8024: PPUSH
8025: LD_INT 3
8027: PPUSH
8028: CALL_OW 235
// wait ( 0 0$1 ) ;
8032: LD_INT 35
8034: PPUSH
8035: CALL_OW 67
// end ; for i := 1 to 3 do
8039: LD_ADDR_VAR 0 3
8043: PUSH
8044: DOUBLE
8045: LD_INT 1
8047: DEC
8048: ST_TO_ADDR
8049: LD_INT 3
8051: PUSH
8052: FOR_TO
8053: IFFALSE 8158
// begin uc_side = 0 ;
8055: LD_ADDR_OWVAR 20
8059: PUSH
8060: LD_INT 0
8062: ST_TO_ADDR
// uc_nation = nation_nature ;
8063: LD_ADDR_OWVAR 21
8067: PUSH
8068: LD_INT 0
8070: ST_TO_ADDR
// PrepareHuman ( false , [ class_phororhacos , class_tiger , 21 ] [ Rand ( 1 , 3 ) ] , 0 ) ;
8071: LD_INT 0
8073: PPUSH
8074: LD_INT 18
8076: PUSH
8077: LD_INT 14
8079: PUSH
8080: LD_INT 21
8082: PUSH
8083: EMPTY
8084: LIST
8085: LIST
8086: LIST
8087: PUSH
8088: LD_INT 1
8090: PPUSH
8091: LD_INT 3
8093: PPUSH
8094: CALL_OW 12
8098: ARRAY
8099: PPUSH
8100: LD_INT 0
8102: PPUSH
8103: CALL_OW 380
// hc_agressivity = 0 ;
8107: LD_ADDR_OWVAR 35
8111: PUSH
8112: LD_INT 0
8114: ST_TO_ADDR
// animal = CreateHuman ;
8115: LD_ADDR_VAR 0 8
8119: PUSH
8120: CALL_OW 44
8124: ST_TO_ADDR
// PlaceUnitArea ( animal , NatureArea , false ) ;
8125: LD_VAR 0 8
8129: PPUSH
8130: LD_INT 5
8132: PPUSH
8133: LD_INT 0
8135: PPUSH
8136: CALL_OW 49
// animals = animals ^ animal ;
8140: LD_ADDR_VAR 0 7
8144: PUSH
8145: LD_VAR 0 7
8149: PUSH
8150: LD_VAR 0 8
8154: ADD
8155: ST_TO_ADDR
// end ;
8156: GO 8052
8158: POP
8159: POP
// for i := 1 to animals do
8160: LD_ADDR_VAR 0 3
8164: PUSH
8165: DOUBLE
8166: LD_INT 1
8168: DEC
8169: ST_TO_ADDR
8170: LD_VAR 0 7
8174: PUSH
8175: FOR_TO
8176: IFFALSE 8200
// AddComAttackUnit ( hunter , animals [ i ] ) ;
8178: LD_VAR 0 1
8182: PPUSH
8183: LD_VAR 0 7
8187: PUSH
8188: LD_VAR 0 3
8192: ARRAY
8193: PPUSH
8194: CALL_OW 175
8198: GO 8175
8200: POP
8201: POP
// repeat wait ( 0 0$1 ) ;
8202: LD_INT 35
8204: PPUSH
8205: CALL_OW 67
// if GetClass ( hunter ) = class_soldier then
8209: LD_VAR 0 1
8213: PPUSH
8214: CALL_OW 257
8218: PUSH
8219: LD_INT 1
8221: EQUAL
8222: IFFALSE 8269
// begin if GetDistUnits ( hunter , WantsToAttack ( hunter ) ) < 13 then
8224: LD_VAR 0 1
8228: PPUSH
8229: LD_VAR 0 1
8233: PPUSH
8234: CALL_OW 319
8238: PPUSH
8239: CALL_OW 296
8243: PUSH
8244: LD_INT 13
8246: LESS
8247: IFFALSE 8260
// ComCrawl ( hunter ) else
8249: LD_VAR 0 1
8253: PPUSH
8254: CALL_OW 137
8258: GO 8269
// ComWalk ( hunter ) ;
8260: LD_VAR 0 1
8264: PPUSH
8265: CALL_OW 138
// end ; until not HasTask ( hunter ) ;
8269: LD_VAR 0 1
8273: PPUSH
8274: CALL_OW 314
8278: NOT
8279: IFFALSE 8202
// repeat wait ( 0 0$1 ) ;
8281: LD_INT 35
8283: PPUSH
8284: CALL_OW 67
// ComMoveXY ( hunter , GetX ( Burlak ) , GetY ( Burlak ) ) ;
8288: LD_VAR 0 1
8292: PPUSH
8293: LD_EXP 57
8297: PPUSH
8298: CALL_OW 250
8302: PPUSH
8303: LD_EXP 57
8307: PPUSH
8308: CALL_OW 251
8312: PPUSH
8313: CALL_OW 111
// until GetDistUnits ( hunter , Burlak ) <= 9 ;
8317: LD_VAR 0 1
8321: PPUSH
8322: LD_EXP 57
8326: PPUSH
8327: CALL_OW 296
8331: PUSH
8332: LD_INT 9
8334: LESSEQUAL
8335: IFFALSE 8281
// SetSide ( hunter , 3 ) ;
8337: LD_VAR 0 1
8341: PPUSH
8342: LD_INT 3
8344: PPUSH
8345: CALL_OW 235
// CenterOnUnits ( hunter ) ;
8349: LD_VAR 0 1
8353: PPUSH
8354: CALL_OW 85
// AddExperience ( hunter , skill_combat , 3000 ) ;
8358: LD_VAR 0 1
8362: PPUSH
8363: LD_INT 1
8365: PPUSH
8366: LD_INT 3000
8368: PPUSH
8369: CALL_OW 492
// end ;
8373: LD_VAR 0 2
8377: RET
// export function SetMashaData ( vehicle ) ; begin
8378: LD_INT 0
8380: PPUSH
// if Masha then
8381: LD_EXP 4
8385: IFFALSE 8403
// SetMark ( Masha [ 1 ] , 0 ) ;
8387: LD_EXP 4
8391: PUSH
8392: LD_INT 1
8394: ARRAY
8395: PPUSH
8396: LD_INT 0
8398: PPUSH
8399: CALL_OW 242
// Masha = [ vehicle , GetChassis ( vehicle ) , GetEngine ( vehicle ) , GetControl ( vehicle ) , GetWeapon ( vehicle ) ] ;
8403: LD_ADDR_EXP 4
8407: PUSH
8408: LD_VAR 0 1
8412: PUSH
8413: LD_VAR 0 1
8417: PPUSH
8418: CALL_OW 265
8422: PUSH
8423: LD_VAR 0 1
8427: PPUSH
8428: CALL_OW 262
8432: PUSH
8433: LD_VAR 0 1
8437: PPUSH
8438: CALL_OW 263
8442: PUSH
8443: LD_VAR 0 1
8447: PPUSH
8448: CALL_OW 264
8452: PUSH
8453: EMPTY
8454: LIST
8455: LIST
8456: LIST
8457: LIST
8458: LIST
8459: ST_TO_ADDR
// ChangeMissionObjectives ( MMashaDone ) ;
8460: LD_STRING MMashaDone
8462: PPUSH
8463: CALL_OW 337
// SetMark ( vehicle , 1 ) ;
8467: LD_VAR 0 1
8471: PPUSH
8472: LD_INT 1
8474: PPUSH
8475: CALL_OW 242
// end ;
8479: LD_VAR 0 2
8483: RET
// export function SaveBase ( buildings , ident ) ; var i , buildingsToSave ; begin
8484: LD_INT 0
8486: PPUSH
8487: PPUSH
8488: PPUSH
// buildingsToSave = [ ] ;
8489: LD_ADDR_VAR 0 5
8493: PUSH
8494: EMPTY
8495: ST_TO_ADDR
// if not buildings then
8496: LD_VAR 0 1
8500: NOT
8501: IFFALSE 8505
// exit ;
8503: GO 9080
// for i in buildings do
8505: LD_ADDR_VAR 0 4
8509: PUSH
8510: LD_VAR 0 1
8514: PUSH
8515: FOR_IN
8516: IFFALSE 9064
// begin if GetBType ( i ) in [ b_lab , b_lab_half , b_lab_full ] then
8518: LD_VAR 0 4
8522: PPUSH
8523: CALL_OW 266
8527: PUSH
8528: LD_INT 6
8530: PUSH
8531: LD_INT 7
8533: PUSH
8534: LD_INT 8
8536: PUSH
8537: EMPTY
8538: LIST
8539: LIST
8540: LIST
8541: IN
8542: IFFALSE 8667
// buildingsToSave = buildingsToSave ^ [ [ GetBType ( i ) , GetX ( i ) , GetY ( i ) , GetDir ( i ) , GetBLevel ( i ) , GetNation ( i ) , GetLives ( i ) , GetLabKind ( i , 1 ) , GetLabKind ( i , 2 ) ] ] else
8544: LD_ADDR_VAR 0 5
8548: PUSH
8549: LD_VAR 0 5
8553: PUSH
8554: LD_VAR 0 4
8558: PPUSH
8559: CALL_OW 266
8563: PUSH
8564: LD_VAR 0 4
8568: PPUSH
8569: CALL_OW 250
8573: PUSH
8574: LD_VAR 0 4
8578: PPUSH
8579: CALL_OW 251
8583: PUSH
8584: LD_VAR 0 4
8588: PPUSH
8589: CALL_OW 254
8593: PUSH
8594: LD_VAR 0 4
8598: PPUSH
8599: CALL_OW 267
8603: PUSH
8604: LD_VAR 0 4
8608: PPUSH
8609: CALL_OW 248
8613: PUSH
8614: LD_VAR 0 4
8618: PPUSH
8619: CALL_OW 256
8623: PUSH
8624: LD_VAR 0 4
8628: PPUSH
8629: LD_INT 1
8631: PPUSH
8632: CALL_OW 268
8636: PUSH
8637: LD_VAR 0 4
8641: PPUSH
8642: LD_INT 2
8644: PPUSH
8645: CALL_OW 268
8649: PUSH
8650: EMPTY
8651: LIST
8652: LIST
8653: LIST
8654: LIST
8655: LIST
8656: LIST
8657: LIST
8658: LIST
8659: LIST
8660: PUSH
8661: EMPTY
8662: LIST
8663: ADD
8664: ST_TO_ADDR
8665: GO 9062
// if GetBType ( i ) in [ b_bunker , b_turret ] then
8667: LD_VAR 0 4
8671: PPUSH
8672: CALL_OW 266
8676: PUSH
8677: LD_INT 32
8679: PUSH
8680: LD_INT 33
8682: PUSH
8683: EMPTY
8684: LIST
8685: LIST
8686: IN
8687: IFFALSE 8795
// buildingsToSave = buildingsToSave ^ [ [ GetBType ( i ) , GetX ( i ) , GetY ( i ) , GetDir ( i ) , GetBLevel ( i ) , GetNation ( i ) , GetLives ( i ) , GetBWeapon ( i ) ] ] else
8689: LD_ADDR_VAR 0 5
8693: PUSH
8694: LD_VAR 0 5
8698: PUSH
8699: LD_VAR 0 4
8703: PPUSH
8704: CALL_OW 266
8708: PUSH
8709: LD_VAR 0 4
8713: PPUSH
8714: CALL_OW 250
8718: PUSH
8719: LD_VAR 0 4
8723: PPUSH
8724: CALL_OW 251
8728: PUSH
8729: LD_VAR 0 4
8733: PPUSH
8734: CALL_OW 254
8738: PUSH
8739: LD_VAR 0 4
8743: PPUSH
8744: CALL_OW 267
8748: PUSH
8749: LD_VAR 0 4
8753: PPUSH
8754: CALL_OW 248
8758: PUSH
8759: LD_VAR 0 4
8763: PPUSH
8764: CALL_OW 256
8768: PUSH
8769: LD_VAR 0 4
8773: PPUSH
8774: CALL_OW 269
8778: PUSH
8779: EMPTY
8780: LIST
8781: LIST
8782: LIST
8783: LIST
8784: LIST
8785: LIST
8786: LIST
8787: LIST
8788: PUSH
8789: EMPTY
8790: LIST
8791: ADD
8792: ST_TO_ADDR
8793: GO 9062
// if GetBType ( i ) in [ b_depot , b_warehouse ] then
8795: LD_VAR 0 4
8799: PPUSH
8800: CALL_OW 266
8804: PUSH
8805: LD_INT 0
8807: PUSH
8808: LD_INT 1
8810: PUSH
8811: EMPTY
8812: LIST
8813: LIST
8814: IN
8815: IFFALSE 8969
// buildingsToSave = buildingsToSave ^ [ [ GetBType ( i ) , GetX ( i ) , GetY ( i ) , GetDir ( i ) , GetBLevel ( i ) , GetNation ( i ) , GetLives ( i ) , GetResourceType ( GetBase ( i ) , mat_cans ) , GetResourceType ( GetBase ( i ) , mat_oil ) , GetResourceType ( GetBase ( i ) , mat_siberit ) ] ] else
8817: LD_ADDR_VAR 0 5
8821: PUSH
8822: LD_VAR 0 5
8826: PUSH
8827: LD_VAR 0 4
8831: PPUSH
8832: CALL_OW 266
8836: PUSH
8837: LD_VAR 0 4
8841: PPUSH
8842: CALL_OW 250
8846: PUSH
8847: LD_VAR 0 4
8851: PPUSH
8852: CALL_OW 251
8856: PUSH
8857: LD_VAR 0 4
8861: PPUSH
8862: CALL_OW 254
8866: PUSH
8867: LD_VAR 0 4
8871: PPUSH
8872: CALL_OW 267
8876: PUSH
8877: LD_VAR 0 4
8881: PPUSH
8882: CALL_OW 248
8886: PUSH
8887: LD_VAR 0 4
8891: PPUSH
8892: CALL_OW 256
8896: PUSH
8897: LD_VAR 0 4
8901: PPUSH
8902: CALL_OW 274
8906: PPUSH
8907: LD_INT 1
8909: PPUSH
8910: CALL_OW 275
8914: PUSH
8915: LD_VAR 0 4
8919: PPUSH
8920: CALL_OW 274
8924: PPUSH
8925: LD_INT 2
8927: PPUSH
8928: CALL_OW 275
8932: PUSH
8933: LD_VAR 0 4
8937: PPUSH
8938: CALL_OW 274
8942: PPUSH
8943: LD_INT 3
8945: PPUSH
8946: CALL_OW 275
8950: PUSH
8951: EMPTY
8952: LIST
8953: LIST
8954: LIST
8955: LIST
8956: LIST
8957: LIST
8958: LIST
8959: LIST
8960: LIST
8961: LIST
8962: PUSH
8963: EMPTY
8964: LIST
8965: ADD
8966: ST_TO_ADDR
8967: GO 9062
// buildingsToSave = buildingsToSave ^ [ [ GetBType ( i ) , GetX ( i ) , GetY ( i ) , GetDir ( i ) , GetBLevel ( i ) , GetNation ( i ) , GetLives ( i ) ] ] ;
8969: LD_ADDR_VAR 0 5
8973: PUSH
8974: LD_VAR 0 5
8978: PUSH
8979: LD_VAR 0 4
8983: PPUSH
8984: CALL_OW 266
8988: PUSH
8989: LD_VAR 0 4
8993: PPUSH
8994: CALL_OW 250
8998: PUSH
8999: LD_VAR 0 4
9003: PPUSH
9004: CALL_OW 251
9008: PUSH
9009: LD_VAR 0 4
9013: PPUSH
9014: CALL_OW 254
9018: PUSH
9019: LD_VAR 0 4
9023: PPUSH
9024: CALL_OW 267
9028: PUSH
9029: LD_VAR 0 4
9033: PPUSH
9034: CALL_OW 248
9038: PUSH
9039: LD_VAR 0 4
9043: PPUSH
9044: CALL_OW 256
9048: PUSH
9049: EMPTY
9050: LIST
9051: LIST
9052: LIST
9053: LIST
9054: LIST
9055: LIST
9056: LIST
9057: PUSH
9058: EMPTY
9059: LIST
9060: ADD
9061: ST_TO_ADDR
// end ;
9062: GO 8515
9064: POP
9065: POP
// SaveVariable ( buildingsToSave , ident ) ;
9066: LD_VAR 0 5
9070: PPUSH
9071: LD_VAR 0 2
9075: PPUSH
9076: CALL_OW 39
// end ; end_of_file
9080: LD_VAR 0 3
9084: RET
// export function MissionIntro ; begin
9085: LD_INT 0
9087: PPUSH
// CenterNowOnUnits ( Burlak ) ;
9088: LD_EXP 57
9092: PPUSH
9093: CALL_OW 87
// DialogueOn ;
9097: CALL_OW 6
// SayRadio ( Popov , DStart-Pop-1 ) ;
9101: LD_EXP 76
9105: PPUSH
9106: LD_STRING DStart-Pop-1
9108: PPUSH
9109: CALL_OW 94
// Say ( Burlak , DStart-Bur-1 ) ;
9113: LD_EXP 57
9117: PPUSH
9118: LD_STRING DStart-Bur-1
9120: PPUSH
9121: CALL_OW 88
// DialogueOff ;
9125: CALL_OW 7
// IngameOff ;
9129: CALL_OW 9
// ChangeMissionObjectives ( MStart ) ;
9133: LD_STRING MStart
9135: PPUSH
9136: CALL_OW 337
// SaveForQuickRestart ;
9140: CALL_OW 22
// end ;
9144: LD_VAR 0 1
9148: RET
// export function Dial_EscortHeike ( x , y ) ; begin
9149: LD_INT 0
9151: PPUSH
// dial_BuildDepotBlocker = true ;
9152: LD_ADDR_EXP 5
9156: PUSH
9157: LD_INT 1
9159: ST_TO_ADDR
// HeikeTargetX = x ;
9160: LD_ADDR_EXP 14
9164: PUSH
9165: LD_VAR 0 1
9169: ST_TO_ADDR
// HeikeTargetY = y ;
9170: LD_ADDR_EXP 15
9174: PUSH
9175: LD_VAR 0 2
9179: ST_TO_ADDR
// SayRadio ( Popov , DHeike-Pop-1 ) ;
9180: LD_EXP 76
9184: PPUSH
9185: LD_STRING DHeike-Pop-1
9187: PPUSH
9188: CALL_OW 94
// wait ( 0 0$10 ) ;
9192: LD_INT 350
9194: PPUSH
9195: CALL_OW 67
// PrepareRussianEscort ;
9199: CALL 2320 0 0
// PlaceUnitArea ( Heike , RussianSpawn2Area , false ) ;
9203: LD_EXP 79
9207: PPUSH
9208: LD_INT 7
9210: PPUSH
9211: LD_INT 0
9213: PPUSH
9214: CALL_OW 49
// ComMoveXY ( russianEscort , HeikeTargetX , HeikeTargetY ) ;
9218: LD_EXP 77
9222: PPUSH
9223: LD_EXP 14
9227: PPUSH
9228: LD_EXP 15
9232: PPUSH
9233: CALL_OW 111
// AddComMoveToArea ( russianEscort , RussianSpawn2Area ) ;
9237: LD_EXP 77
9241: PPUSH
9242: LD_INT 7
9244: PPUSH
9245: CALL_OW 173
// ComMoveXY ( Heike , HeikeTargetX , HeikeTargetY ) ;
9249: LD_EXP 79
9253: PPUSH
9254: LD_EXP 14
9258: PPUSH
9259: LD_EXP 15
9263: PPUSH
9264: CALL_OW 111
// AddComHold ( Heike ) ;
9268: LD_EXP 79
9272: PPUSH
9273: CALL_OW 200
// end ;
9277: LD_VAR 0 3
9281: RET
// every 1 trigger GetDistUnitXY ( Heike , HeikeTargetX , HeikeTargetY ) <= 5 do
9282: LD_EXP 79
9286: PPUSH
9287: LD_EXP 14
9291: PPUSH
9292: LD_EXP 15
9296: PPUSH
9297: CALL_OW 297
9301: PUSH
9302: LD_INT 5
9304: LESSEQUAL
9305: IFFALSE 9318
9307: GO 9309
9309: DISABLE
// allowExitFromMap = 1 ;
9310: LD_ADDR_EXP 18
9314: PUSH
9315: LD_INT 1
9317: ST_TO_ADDR
9318: END
// every 7 7$0 trigger IsPlaced ( Heike ) and IsOk ( Heike ) and GetAttitude ( 3 , 5 ) = att_friend and HeikeCaptured do
9319: LD_EXP 79
9323: PPUSH
9324: CALL_OW 305
9328: PUSH
9329: LD_EXP 79
9333: PPUSH
9334: CALL_OW 302
9338: AND
9339: PUSH
9340: LD_INT 3
9342: PPUSH
9343: LD_INT 5
9345: PPUSH
9346: CALL_OW 81
9350: PUSH
9351: LD_INT 1
9353: EQUAL
9354: AND
9355: PUSH
9356: LD_EXP 1
9360: AND
9361: IFFALSE 9580
9363: GO 9365
9365: DISABLE
// begin DialogueOn ;
9366: CALL_OW 6
// SayRadio ( Kurt , DMercHelp-Kurt-1 ) ;
9370: LD_EXP 80
9374: PPUSH
9375: LD_STRING DMercHelp-Kurt-1
9377: PPUSH
9378: CALL_OW 94
// Say ( Burlak , DMercHelp-Bur-1 ) ;
9382: LD_EXP 57
9386: PPUSH
9387: LD_STRING DMercHelp-Bur-1
9389: PPUSH
9390: CALL_OW 88
// SayRadio ( Kurt , DMercHelp-Kurt-2 ) ;
9394: LD_EXP 80
9398: PPUSH
9399: LD_STRING DMercHelp-Kurt-2
9401: PPUSH
9402: CALL_OW 94
// Say ( Burlak , DMercHelp-Bur-2 ) ;
9406: LD_EXP 57
9410: PPUSH
9411: LD_STRING DMercHelp-Bur-2
9413: PPUSH
9414: CALL_OW 88
// SayRadio ( Kurt , DMercHelp-Kurt-3 ) ;
9418: LD_EXP 80
9422: PPUSH
9423: LD_STRING DMercHelp-Kurt-3
9425: PPUSH
9426: CALL_OW 94
// case Query ( QMerc ) of 1 :
9430: LD_STRING QMerc
9432: PPUSH
9433: CALL_OW 97
9437: PUSH
9438: LD_INT 1
9440: DOUBLE
9441: EQUAL
9442: IFTRUE 9446
9444: GO 9481
9446: POP
// begin Say ( Burlak , DQrMerc#1-Bur-1 ) ;
9447: LD_EXP 57
9451: PPUSH
9452: LD_STRING DQrMerc#1-Bur-1
9454: PPUSH
9455: CALL_OW 88
// SayRadio ( Kurt , DQrMerc#1-Kurt-1 ) ;
9459: LD_EXP 80
9463: PPUSH
9464: LD_STRING DQrMerc#1-Kurt-1
9466: PPUSH
9467: CALL_OW 94
// acceptKurtOffert = true ;
9471: LD_ADDR_EXP 19
9475: PUSH
9476: LD_INT 1
9478: ST_TO_ADDR
// end ; 2 :
9479: GO 9576
9481: LD_INT 2
9483: DOUBLE
9484: EQUAL
9485: IFTRUE 9489
9487: GO 9544
9489: POP
// begin askCommanders = true ;
9490: LD_ADDR_EXP 20
9494: PUSH
9495: LD_INT 1
9497: ST_TO_ADDR
// Say ( Burlak , DQrMerc#2-Bur-1 ) ;
9498: LD_EXP 57
9502: PPUSH
9503: LD_STRING DQrMerc#2-Bur-1
9505: PPUSH
9506: CALL_OW 88
// SayRadio ( Popov , DQrMerc#2-Pop-1 ) ;
9510: LD_EXP 76
9514: PPUSH
9515: LD_STRING DQrMerc#2-Pop-1
9517: PPUSH
9518: CALL_OW 94
// Say ( Burlak , DQrMerc#2-Bur-2 ) ;
9522: LD_EXP 57
9526: PPUSH
9527: LD_STRING DQrMerc#2-Bur-2
9529: PPUSH
9530: CALL_OW 88
// acceptKurtOffert = true ;
9534: LD_ADDR_EXP 19
9538: PUSH
9539: LD_INT 1
9541: ST_TO_ADDR
// end ; 3 :
9542: GO 9576
9544: LD_INT 3
9546: DOUBLE
9547: EQUAL
9548: IFTRUE 9552
9550: GO 9575
9552: POP
// begin Say ( Burlak , DQrMerc#3-Bur-1 ) ;
9553: LD_EXP 57
9557: PPUSH
9558: LD_STRING DQrMerc#3-Bur-1
9560: PPUSH
9561: CALL_OW 88
// KurtAttack = true ;
9565: LD_ADDR_EXP 25
9569: PUSH
9570: LD_INT 1
9572: ST_TO_ADDR
// end ; end ;
9573: GO 9576
9575: POP
// DialogueOff ;
9576: CALL_OW 7
// end ;
9580: END
// every 0 0$1 trigger acceptKurtOffert do
9581: LD_EXP 19
9585: IFFALSE 9741
9587: GO 9589
9589: DISABLE
// begin PlaceUnitArea ( Kurt , KurtSpawnArea , false ) ;
9590: LD_EXP 80
9594: PPUSH
9595: LD_INT 9
9597: PPUSH
9598: LD_INT 0
9600: PPUSH
9601: CALL_OW 49
// uc_side = 8 ;
9605: LD_ADDR_OWVAR 20
9609: PUSH
9610: LD_INT 8
9612: ST_TO_ADDR
// uc_nation = 2 ;
9613: LD_ADDR_OWVAR 21
9617: PUSH
9618: LD_INT 2
9620: ST_TO_ADDR
// PrepareEngineer ( false , 3 ) ;
9621: LD_INT 0
9623: PPUSH
9624: LD_INT 3
9626: PPUSH
9627: CALL_OW 382
// KurtEng = CreateHuman ;
9631: LD_ADDR_EXP 82
9635: PUSH
9636: CALL_OW 44
9640: ST_TO_ADDR
// PlaceUnitArea ( KurtEng , KurtSpawnArea , false ) ;
9641: LD_EXP 82
9645: PPUSH
9646: LD_INT 9
9648: PPUSH
9649: LD_INT 0
9651: PPUSH
9652: CALL_OW 49
// repeat wait ( 0 0$1 ) ;
9656: LD_INT 35
9658: PPUSH
9659: CALL_OW 67
// ComMoveXY ( [ Kurt , KurtEng ] , GetX ( Burlak ) , GetY ( Burlak ) ) ;
9663: LD_EXP 80
9667: PUSH
9668: LD_EXP 82
9672: PUSH
9673: EMPTY
9674: LIST
9675: LIST
9676: PPUSH
9677: LD_EXP 57
9681: PPUSH
9682: CALL_OW 250
9686: PPUSH
9687: LD_EXP 57
9691: PPUSH
9692: CALL_OW 251
9696: PPUSH
9697: CALL_OW 111
// until GetDistUnits ( Kurt , Burlak ) <= 5 or GetDistUnits ( KurtEng , Burlak ) <= 5 ;
9701: LD_EXP 80
9705: PPUSH
9706: LD_EXP 57
9710: PPUSH
9711: CALL_OW 296
9715: PUSH
9716: LD_INT 5
9718: LESSEQUAL
9719: PUSH
9720: LD_EXP 82
9724: PPUSH
9725: LD_EXP 57
9729: PPUSH
9730: CALL_OW 296
9734: PUSH
9735: LD_INT 5
9737: LESSEQUAL
9738: OR
9739: IFFALSE 9656
// end ;
9741: END
// every 0 0$1 trigger GetDistUnits ( Kurt , Burlak ) <= 5 or GetDistUnits ( KurtEng , Burlak ) <= 5 do
9742: LD_EXP 80
9746: PPUSH
9747: LD_EXP 57
9751: PPUSH
9752: CALL_OW 296
9756: PUSH
9757: LD_INT 5
9759: LESSEQUAL
9760: PUSH
9761: LD_EXP 82
9765: PPUSH
9766: LD_EXP 57
9770: PPUSH
9771: CALL_OW 296
9775: PUSH
9776: LD_INT 5
9778: LESSEQUAL
9779: OR
9780: IFFALSE 9959
9782: GO 9784
9784: DISABLE
// begin KurtWaitingForBuildBarrack = true ;
9785: LD_ADDR_EXP 24
9789: PUSH
9790: LD_INT 1
9792: ST_TO_ADDR
// SetSide ( KurtEng , 3 ) ;
9793: LD_EXP 82
9797: PPUSH
9798: LD_INT 3
9800: PPUSH
9801: CALL_OW 235
// wait ( 1 1$30 ) ;
9805: LD_INT 3150
9807: PPUSH
9808: CALL_OW 67
// DialogueOn ;
9812: CALL_OW 6
// SayRadio ( Dietrich , DArabianRequest-Diet-1 ) ;
9816: LD_EXP 81
9820: PPUSH
9821: LD_STRING DArabianRequest-Diet-1
9823: PPUSH
9824: CALL_OW 94
// Say ( Burlak , DArabianRequest-Bur-1 ) ;
9828: LD_EXP 57
9832: PPUSH
9833: LD_STRING DArabianRequest-Bur-1
9835: PPUSH
9836: CALL_OW 88
// SayRadio ( Dietrich , DArabianRequest-Diet-2 ) ;
9840: LD_EXP 81
9844: PPUSH
9845: LD_STRING DArabianRequest-Diet-2
9847: PPUSH
9848: CALL_OW 94
// DialogueOff ;
9852: CALL_OW 7
// case Query ( QHandOver ) of 1 :
9856: LD_STRING QHandOver
9858: PPUSH
9859: CALL_OW 97
9863: PUSH
9864: LD_INT 1
9866: DOUBLE
9867: EQUAL
9868: IFTRUE 9872
9870: GO 9911
9872: POP
// begin Say ( Burlak , DQrHandOver#1-Bur-1 ) ;
9873: LD_EXP 57
9877: PPUSH
9878: LD_STRING DQrHandOver#1-Bur-1
9880: PPUSH
9881: CALL_OW 88
// SayRadio ( Dietrich , DQrHandOver#1-Diet-1 ) ;
9885: LD_EXP 81
9889: PPUSH
9890: LD_STRING DQrHandOver#1-Diet-1
9892: PPUSH
9893: CALL_OW 94
// coopWithGensher = true ;
9897: LD_ADDR_EXP 2
9901: PUSH
9902: LD_INT 1
9904: ST_TO_ADDR
// SpawnGensherTeam ;
9905: CALL 3946 0 0
// end ; 2 :
9909: GO 9959
9911: LD_INT 2
9913: DOUBLE
9914: EQUAL
9915: IFTRUE 9919
9917: GO 9958
9919: POP
// begin Say ( Burlak , DQrHandOver#2-Bur-1 ) ;
9920: LD_EXP 57
9924: PPUSH
9925: LD_STRING DQrHandOver#2-Bur-1
9927: PPUSH
9928: CALL_OW 88
// SayRadio ( Dietrich , DQrHandOver#2-Diet-1 ) ;
9932: LD_EXP 81
9936: PPUSH
9937: LD_STRING DQrHandOver#2-Diet-1
9939: PPUSH
9940: CALL_OW 94
// Say ( Burlak , DQrHandOver#2-Bur-2 ) ;
9944: LD_EXP 57
9948: PPUSH
9949: LD_STRING DQrHandOver#2-Bur-2
9951: PPUSH
9952: CALL_OW 88
// end ; end ;
9956: GO 9959
9958: POP
// end ;
9959: END
// export function Dial_UpgradeArmoury ; begin
9960: LD_INT 0
9962: PPUSH
// dial_BuildArBarrackBlocker = true ;
9963: LD_ADDR_EXP 6
9967: PUSH
9968: LD_INT 1
9970: ST_TO_ADDR
// buildArabBarrack = true ;
9971: LD_ADDR_EXP 38
9975: PUSH
9976: LD_INT 1
9978: ST_TO_ADDR
// if GetSide ( Kurt ) = 2 or GetSide ( KurtEng ) = 8 then
9979: LD_EXP 80
9983: PPUSH
9984: CALL_OW 255
9988: PUSH
9989: LD_INT 2
9991: EQUAL
9992: PUSH
9993: LD_EXP 82
9997: PPUSH
9998: CALL_OW 255
10002: PUSH
10003: LD_INT 8
10005: EQUAL
10006: OR
10007: IFFALSE 10011
// exit ;
10009: GO 10111
// SetSide ( KurtEng , 8 ) ;
10011: LD_EXP 82
10015: PPUSH
10016: LD_INT 8
10018: PPUSH
10019: CALL_OW 235
// ComStop ( KurtEng ) ;
10023: LD_EXP 82
10027: PPUSH
10028: CALL_OW 141
// DialogueOn ;
10032: CALL_OW 6
// Say ( Kurt , DMercCompleted-Kurt-1 ) ;
10036: LD_EXP 80
10040: PPUSH
10041: LD_STRING DMercCompleted-Kurt-1
10043: PPUSH
10044: CALL_OW 88
// DialogueOff ;
10048: CALL_OW 7
// canSendHeike = true ;
10052: LD_ADDR_EXP 28
10056: PUSH
10057: LD_INT 1
10059: ST_TO_ADDR
// KurtWaitingForFreeHeike = true ;
10060: LD_ADDR_EXP 23
10064: PUSH
10065: LD_INT 1
10067: ST_TO_ADDR
// KurtWaitingForBuildBarrack = false ;
10068: LD_ADDR_EXP 24
10072: PUSH
10073: LD_INT 0
10075: ST_TO_ADDR
// allowExitFromMap = 3 ;
10076: LD_ADDR_EXP 18
10080: PUSH
10081: LD_INT 3
10083: ST_TO_ADDR
// if KurtCanEscape then
10084: LD_EXP 21
10088: IFFALSE 10111
// ComMoveToArea ( [ Kurt , KurtEng ] , KurtExitMapArea ) ;
10090: LD_EXP 80
10094: PUSH
10095: LD_EXP 82
10099: PUSH
10100: EMPTY
10101: LIST
10102: LIST
10103: PPUSH
10104: LD_INT 11
10106: PPUSH
10107: CALL_OW 113
// end ;
10111: LD_VAR 0 1
10115: RET
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 2 ] ] ) and not dial_ArriveGensherUnitsBlocker do var veh , nearGensherUnit , maleSold , waitForKurt ;
10116: LD_INT 22
10118: PUSH
10119: LD_INT 2
10121: PUSH
10122: EMPTY
10123: LIST
10124: LIST
10125: PUSH
10126: EMPTY
10127: LIST
10128: PPUSH
10129: CALL_OW 69
10133: PUSH
10134: LD_EXP 7
10138: NOT
10139: AND
10140: IFFALSE 10913
10142: GO 10144
10144: DISABLE
10145: LD_INT 0
10147: PPUSH
10148: PPUSH
10149: PPUSH
10150: PPUSH
// begin nearGensherUnit = NearestUnitToXY ( UnitFilter ( GensherTeam , [ [ f_type , unit_vehicle ] ] ) , GensherTargetX , GensherTargetY ) ;
10151: LD_ADDR_VAR 0 2
10155: PUSH
10156: LD_EXP 83
10160: PPUSH
10161: LD_INT 21
10163: PUSH
10164: LD_INT 2
10166: PUSH
10167: EMPTY
10168: LIST
10169: LIST
10170: PUSH
10171: EMPTY
10172: LIST
10173: PPUSH
10174: CALL_OW 72
10178: PPUSH
10179: LD_EXP 16
10183: PPUSH
10184: LD_EXP 17
10188: PPUSH
10189: CALL_OW 73
10193: ST_TO_ADDR
// maleSold = UnitsInside ( nearGensherUnit [ 1 ] ) ;
10194: LD_ADDR_VAR 0 3
10198: PUSH
10199: LD_VAR 0 2
10203: PUSH
10204: LD_INT 1
10206: ARRAY
10207: PPUSH
10208: CALL_OW 313
10212: ST_TO_ADDR
// if GetDistUnitXY ( nearGensherUnit , GensherTargetX , GensherTargetY ) <= 5 then
10213: LD_VAR 0 2
10217: PPUSH
10218: LD_EXP 16
10222: PPUSH
10223: LD_EXP 17
10227: PPUSH
10228: CALL_OW 297
10232: PUSH
10233: LD_INT 5
10235: LESSEQUAL
10236: IFFALSE 10912
// begin dial_ArriveGensherUnitsBlocker = true ;
10238: LD_ADDR_EXP 7
10242: PUSH
10243: LD_INT 1
10245: ST_TO_ADDR
// for veh in UnitFilter ( GensherTeam , [ [ f_type , unit_vehicle ] ] ) do
10246: LD_ADDR_VAR 0 1
10250: PUSH
10251: LD_EXP 83
10255: PPUSH
10256: LD_INT 21
10258: PUSH
10259: LD_INT 2
10261: PUSH
10262: EMPTY
10263: LIST
10264: LIST
10265: PUSH
10266: EMPTY
10267: LIST
10268: PPUSH
10269: CALL_OW 72
10273: PUSH
10274: FOR_IN
10275: IFFALSE 10297
// ComExitVehicle ( UnitsInside ( veh ) [ 1 ] ) ;
10277: LD_VAR 0 1
10281: PPUSH
10282: CALL_OW 313
10286: PUSH
10287: LD_INT 1
10289: ARRAY
10290: PPUSH
10291: CALL_OW 121
10295: GO 10274
10297: POP
10298: POP
// wait ( 0 0$1 ) ;
10299: LD_INT 35
10301: PPUSH
10302: CALL_OW 67
// SetSide ( UnitFilter ( GensherTeam , [ [ f_type , unit_vehicle ] ] ) , 3 ) ;
10306: LD_EXP 83
10310: PPUSH
10311: LD_INT 21
10313: PUSH
10314: LD_INT 2
10316: PUSH
10317: EMPTY
10318: LIST
10319: LIST
10320: PUSH
10321: EMPTY
10322: LIST
10323: PPUSH
10324: CALL_OW 72
10328: PPUSH
10329: LD_INT 3
10331: PPUSH
10332: CALL_OW 235
// CenterOnUnits ( maleSold ) ;
10336: LD_VAR 0 3
10340: PPUSH
10341: CALL_OW 85
// DialogueOn ;
10345: CALL_OW 6
// Say ( maleSold , DHandOverCome-ASol1-1 ) ;
10349: LD_VAR 0 3
10353: PPUSH
10354: LD_STRING DHandOverCome-ASol1-1
10356: PPUSH
10357: CALL_OW 88
// Say ( Kurt , DHandOverCome-Kurt-1 ) ;
10361: LD_EXP 80
10365: PPUSH
10366: LD_STRING DHandOverCome-Kurt-1
10368: PPUSH
10369: CALL_OW 88
// DialogueOff ;
10373: CALL_OW 7
// KurtWaitingForBuildBarrack = false ;
10377: LD_ADDR_EXP 24
10381: PUSH
10382: LD_INT 0
10384: ST_TO_ADDR
// if GetDistUnits ( Kurt , UnitFilter ( GensherTeam , [ f_type , unit_vehicle ] ) [ 1 ] ) <= 8 or GetSide ( KurtEng ) = 3 then
10385: LD_EXP 80
10389: PPUSH
10390: LD_EXP 83
10394: PPUSH
10395: LD_INT 21
10397: PUSH
10398: LD_INT 2
10400: PUSH
10401: EMPTY
10402: LIST
10403: LIST
10404: PPUSH
10405: CALL_OW 72
10409: PUSH
10410: LD_INT 1
10412: ARRAY
10413: PPUSH
10414: CALL_OW 296
10418: PUSH
10419: LD_INT 8
10421: LESSEQUAL
10422: PUSH
10423: LD_EXP 82
10427: PPUSH
10428: CALL_OW 255
10432: PUSH
10433: LD_INT 3
10435: EQUAL
10436: OR
10437: IFFALSE 10542
// begin KurtCanEscape = false ;
10439: LD_ADDR_EXP 21
10443: PUSH
10444: LD_INT 0
10446: ST_TO_ADDR
// SetSide ( [ Kurt , KurtEng ] , 2 ) ;
10447: LD_EXP 80
10451: PUSH
10452: LD_EXP 82
10456: PUSH
10457: EMPTY
10458: LIST
10459: LIST
10460: PPUSH
10461: LD_INT 2
10463: PPUSH
10464: CALL_OW 235
// ComStop ( [ Kurt , KurtEng ] ) ;
10468: LD_EXP 80
10472: PUSH
10473: LD_EXP 82
10477: PUSH
10478: EMPTY
10479: LIST
10480: LIST
10481: PPUSH
10482: CALL_OW 141
// ComMoveXY ( [ Kurt , KurtEng ] , GetX ( maleSold ) , GetY ( maleSold ) ) ;
10486: LD_EXP 80
10490: PUSH
10491: LD_EXP 82
10495: PUSH
10496: EMPTY
10497: LIST
10498: LIST
10499: PPUSH
10500: LD_VAR 0 3
10504: PPUSH
10505: CALL_OW 250
10509: PPUSH
10510: LD_VAR 0 3
10514: PPUSH
10515: CALL_OW 251
10519: PPUSH
10520: CALL_OW 111
// waitForKurt = true ;
10524: LD_ADDR_VAR 0 4
10528: PUSH
10529: LD_INT 1
10531: ST_TO_ADDR
// KurtStatus = 3 ;
10532: LD_ADDR_EXP 22
10536: PUSH
10537: LD_INT 3
10539: ST_TO_ADDR
// end else
10540: GO 10780
// if GetDistUnits ( Kurt , UnitFilter ( GensherTeam , [ f_type , unit_vehicle ] ) [ 1 ] ) > 8 then
10542: LD_EXP 80
10546: PPUSH
10547: LD_EXP 83
10551: PPUSH
10552: LD_INT 21
10554: PUSH
10555: LD_INT 2
10557: PUSH
10558: EMPTY
10559: LIST
10560: LIST
10561: PPUSH
10562: CALL_OW 72
10566: PUSH
10567: LD_INT 1
10569: ARRAY
10570: PPUSH
10571: CALL_OW 296
10575: PUSH
10576: LD_INT 8
10578: GREATER
10579: IFFALSE 10780
// begin allowExitFromMap = 4 ;
10581: LD_ADDR_EXP 18
10585: PUSH
10586: LD_INT 4
10588: ST_TO_ADDR
// KurtStatus = 2 ;
10589: LD_ADDR_EXP 22
10593: PUSH
10594: LD_INT 2
10596: ST_TO_ADDR
// ComMoveToArea ( [ Kurt , KurtEng ] , KurtExitMapArea ) ;
10597: LD_EXP 80
10601: PUSH
10602: LD_EXP 82
10606: PUSH
10607: EMPTY
10608: LIST
10609: LIST
10610: PPUSH
10611: LD_INT 11
10613: PPUSH
10614: CALL_OW 113
// repeat ComAttackUnit ( UnitFilter ( GensherTeam , [ [ f_type , unit_human ] ] ) , Kurt ) ;
10618: LD_EXP 83
10622: PPUSH
10623: LD_INT 21
10625: PUSH
10626: LD_INT 1
10628: PUSH
10629: EMPTY
10630: LIST
10631: LIST
10632: PUSH
10633: EMPTY
10634: LIST
10635: PPUSH
10636: CALL_OW 72
10640: PPUSH
10641: LD_EXP 80
10645: PPUSH
10646: CALL_OW 115
// wait ( 0 0$1 ) ;
10650: LD_INT 35
10652: PPUSH
10653: CALL_OW 67
// until GetDistUnits ( NearestUnitToUnit ( UnitFilter ( GensherTeam , [ [ f_type , unit_human ] ] ) , Kurt ) , Kurt ) <= 9 or ( not IsPlaced ( Kurt ) and not IsPlaced ( KurtEng ) ) ;
10657: LD_EXP 83
10661: PPUSH
10662: LD_INT 21
10664: PUSH
10665: LD_INT 1
10667: PUSH
10668: EMPTY
10669: LIST
10670: LIST
10671: PUSH
10672: EMPTY
10673: LIST
10674: PPUSH
10675: CALL_OW 72
10679: PPUSH
10680: LD_EXP 80
10684: PPUSH
10685: CALL_OW 74
10689: PPUSH
10690: LD_EXP 80
10694: PPUSH
10695: CALL_OW 296
10699: PUSH
10700: LD_INT 9
10702: LESSEQUAL
10703: PUSH
10704: LD_EXP 80
10708: PPUSH
10709: CALL_OW 305
10713: NOT
10714: PUSH
10715: LD_EXP 82
10719: PPUSH
10720: CALL_OW 305
10724: NOT
10725: AND
10726: OR
10727: IFFALSE 10618
// ComMoveToArea ( [ Kurt , KurtEng ] , ExitMapArea ) ;
10729: LD_EXP 80
10733: PUSH
10734: LD_EXP 82
10738: PUSH
10739: EMPTY
10740: LIST
10741: LIST
10742: PPUSH
10743: LD_INT 8
10745: PPUSH
10746: CALL_OW 113
// ComMoveToArea ( UnitFilter ( GensherTeam , [ [ f_type , unit_human ] ] ) , ExitMapArea ) ;
10750: LD_EXP 83
10754: PPUSH
10755: LD_INT 21
10757: PUSH
10758: LD_INT 1
10760: PUSH
10761: EMPTY
10762: LIST
10763: LIST
10764: PUSH
10765: EMPTY
10766: LIST
10767: PPUSH
10768: CALL_OW 72
10772: PPUSH
10773: LD_INT 8
10775: PPUSH
10776: CALL_OW 113
// end ; if waitForKurt then
10780: LD_VAR 0 4
10784: IFFALSE 10910
// begin repeat wait ( 0 0$1 ) ;
10786: LD_INT 35
10788: PPUSH
10789: CALL_OW 67
// ComMoveXY ( [ Kurt , KurtEng ] , GetX ( maleSold ) , GetY ( maleSold ) ) ;
10793: LD_EXP 80
10797: PUSH
10798: LD_EXP 82
10802: PUSH
10803: EMPTY
10804: LIST
10805: LIST
10806: PPUSH
10807: LD_VAR 0 3
10811: PPUSH
10812: CALL_OW 250
10816: PPUSH
10817: LD_VAR 0 3
10821: PPUSH
10822: CALL_OW 251
10826: PPUSH
10827: CALL_OW 111
// until GetDistUnits ( Kurt , maleSold ) <= 2 ;
10831: LD_EXP 80
10835: PPUSH
10836: LD_VAR 0 3
10840: PPUSH
10841: CALL_OW 296
10845: PUSH
10846: LD_INT 2
10848: LESSEQUAL
10849: IFFALSE 10786
// allowExitFromMap = 4 ;
10851: LD_ADDR_EXP 18
10855: PUSH
10856: LD_INT 4
10858: ST_TO_ADDR
// ComMoveToArea ( [ Kurt , KurtEng ] , ExitMapArea ) ;
10859: LD_EXP 80
10863: PUSH
10864: LD_EXP 82
10868: PUSH
10869: EMPTY
10870: LIST
10871: LIST
10872: PPUSH
10873: LD_INT 8
10875: PPUSH
10876: CALL_OW 113
// ComMoveToArea ( UnitFilter ( GensherTeam , [ [ f_type , unit_human ] ] ) , ExitMapArea ) ;
10880: LD_EXP 83
10884: PPUSH
10885: LD_INT 21
10887: PUSH
10888: LD_INT 1
10890: PUSH
10891: EMPTY
10892: LIST
10893: LIST
10894: PUSH
10895: EMPTY
10896: LIST
10897: PPUSH
10898: CALL_OW 72
10902: PPUSH
10903: LD_INT 8
10905: PPUSH
10906: CALL_OW 113
// end ; exit ;
10910: GO 10913
// end ; enable ;
10912: ENABLE
// end ;
10913: PPOPN 4
10915: END
// export function Dial_AttackGensher ; var unit ; begin
10916: LD_INT 0
10918: PPUSH
10919: PPUSH
// DialogueOn ;
10920: CALL_OW 6
// SayRadio ( Dietrich , DHandOverSpoiled-Diet-1 ) ;
10924: LD_EXP 81
10928: PPUSH
10929: LD_STRING DHandOverSpoiled-Diet-1
10931: PPUSH
10932: CALL_OW 94
// DialogueOff ;
10936: CALL_OW 7
// SetAttitude ( 3 , 2 , att_enemy , true ) ;
10940: LD_INT 3
10942: PPUSH
10943: LD_INT 2
10945: PPUSH
10946: LD_INT 2
10948: PPUSH
10949: LD_INT 1
10951: PPUSH
10952: CALL_OW 80
// for unit in UnitFilter ( GensherTeam , [ [ f_type , unit_human ] ] ) do
10956: LD_ADDR_VAR 0 2
10960: PUSH
10961: LD_EXP 83
10965: PPUSH
10966: LD_INT 21
10968: PUSH
10969: LD_INT 1
10971: PUSH
10972: EMPTY
10973: LIST
10974: LIST
10975: PUSH
10976: EMPTY
10977: LIST
10978: PPUSH
10979: CALL_OW 72
10983: PUSH
10984: FOR_IN
10985: IFFALSE 11045
// begin if IsInUnit ( unit ) then
10987: LD_VAR 0 2
10991: PPUSH
10992: CALL_OW 310
10996: IFFALSE 11007
// ComExitVehicle ( unit ) ;
10998: LD_VAR 0 2
11002: PPUSH
11003: CALL_OW 121
// wait ( 0 0$01 ) ;
11007: LD_INT 35
11009: PPUSH
11010: CALL_OW 67
// AddComAgressiveMove ( unit , GetX ( Burlak ) , GetY ( Burlak ) ) ;
11014: LD_VAR 0 2
11018: PPUSH
11019: LD_EXP 57
11023: PPUSH
11024: CALL_OW 250
11028: PPUSH
11029: LD_EXP 57
11033: PPUSH
11034: CALL_OW 251
11038: PPUSH
11039: CALL_OW 174
// end ;
11043: GO 10984
11045: POP
11046: POP
// coopWithGensher = 2 ;
11047: LD_ADDR_EXP 2
11051: PUSH
11052: LD_INT 2
11054: ST_TO_ADDR
// end ;
11055: LD_VAR 0 1
11059: RET
// every 0 0$1 trigger canSendHeike and IsOK ( Heike ) and GetSide ( Heike ) = 5 do var legionSold ;
11060: LD_EXP 28
11064: PUSH
11065: LD_EXP 79
11069: PPUSH
11070: CALL_OW 302
11074: AND
11075: PUSH
11076: LD_EXP 79
11080: PPUSH
11081: CALL_OW 255
11085: PUSH
11086: LD_INT 5
11088: EQUAL
11089: AND
11090: IFFALSE 11410
11092: GO 11094
11094: DISABLE
11095: LD_INT 0
11097: PPUSH
// begin if IsSelected ( Heike ) then
11098: LD_EXP 79
11102: PPUSH
11103: CALL_OW 306
11107: IFFALSE 11402
// begin if Query ( QSendHeike ) = 1 then
11109: LD_STRING QSendHeike
11111: PPUSH
11112: CALL_OW 97
11116: PUSH
11117: LD_INT 1
11119: EQUAL
11120: IFFALSE 11402
// begin KurtWaitingForFreeHeike = false ;
11122: LD_ADDR_EXP 23
11126: PUSH
11127: LD_INT 0
11129: ST_TO_ADDR
// ComMoveXY ( Heike , 82 , 46 ) ;
11130: LD_EXP 79
11134: PPUSH
11135: LD_INT 82
11137: PPUSH
11138: LD_INT 46
11140: PPUSH
11141: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
11145: LD_INT 35
11147: PPUSH
11148: CALL_OW 67
// until GetDistUnitXY ( Heike , 82 , 46 ) <= 5 or IsDead ( Heike ) ;
11152: LD_EXP 79
11156: PPUSH
11157: LD_INT 82
11159: PPUSH
11160: LD_INT 46
11162: PPUSH
11163: CALL_OW 297
11167: PUSH
11168: LD_INT 5
11170: LESSEQUAL
11171: PUSH
11172: LD_EXP 79
11176: PPUSH
11177: CALL_OW 301
11181: OR
11182: IFFALSE 11145
// if not askCommanders then
11184: LD_EXP 20
11188: NOT
11189: IFFALSE 11235
// begin DialogueOn ;
11191: CALL_OW 6
// SayRadio ( Popov , DMercPopov-Pop-1 ) ;
11195: LD_EXP 76
11199: PPUSH
11200: LD_STRING DMercPopov-Pop-1
11202: PPUSH
11203: CALL_OW 94
// Say ( Burlak , DMercPopov-Bur-1 ) ;
11207: LD_EXP 57
11211: PPUSH
11212: LD_STRING DMercPopov-Bur-1
11214: PPUSH
11215: CALL_OW 88
// SayRadio ( Popov , DMercPopov-Pop-2 ) ;
11219: LD_EXP 76
11223: PPUSH
11224: LD_STRING DMercPopov-Pop-2
11226: PPUSH
11227: CALL_OW 94
// DialogueOff ;
11231: CALL_OW 7
// end ; uc_side = 8 ;
11235: LD_ADDR_OWVAR 20
11239: PUSH
11240: LD_INT 8
11242: ST_TO_ADDR
// uc_nation = 2 ;
11243: LD_ADDR_OWVAR 21
11247: PUSH
11248: LD_INT 2
11250: ST_TO_ADDR
// PrepareSoldier ( false , 6 ) ;
11251: LD_INT 0
11253: PPUSH
11254: LD_INT 6
11256: PPUSH
11257: CALL_OW 381
// legionSold = CreateHuman ;
11261: LD_ADDR_VAR 0 1
11265: PUSH
11266: CALL_OW 44
11270: ST_TO_ADDR
// PlaceUnitXYR ( legionSold , 26 , 48 , 4 , false ) ;
11271: LD_VAR 0 1
11275: PPUSH
11276: LD_INT 26
11278: PPUSH
11279: LD_INT 48
11281: PPUSH
11282: LD_INT 4
11284: PPUSH
11285: LD_INT 0
11287: PPUSH
11288: CALL_OW 50
// repeat wait ( 0 0$1 ) ;
11292: LD_INT 35
11294: PPUSH
11295: CALL_OW 67
// ComMoveXY ( legionSold , GetX ( Heike ) , GetY ( Heike ) ) ;
11299: LD_VAR 0 1
11303: PPUSH
11304: LD_EXP 79
11308: PPUSH
11309: CALL_OW 250
11313: PPUSH
11314: LD_EXP 79
11318: PPUSH
11319: CALL_OW 251
11323: PPUSH
11324: CALL_OW 111
// until GetDistUnits ( legionSold , Heike ) <= 5 or IsDead ( Heike ) ;
11328: LD_VAR 0 1
11332: PPUSH
11333: LD_EXP 79
11337: PPUSH
11338: CALL_OW 296
11342: PUSH
11343: LD_INT 5
11345: LESSEQUAL
11346: PUSH
11347: LD_EXP 79
11351: PPUSH
11352: CALL_OW 301
11356: OR
11357: IFFALSE 11292
// SetSide ( Heike , 8 ) ;
11359: LD_EXP 79
11363: PPUSH
11364: LD_INT 8
11366: PPUSH
11367: CALL_OW 235
// allowExitFromMap = 3 ;
11371: LD_ADDR_EXP 18
11375: PUSH
11376: LD_INT 3
11378: ST_TO_ADDR
// ComMoveToArea ( [ legionSold , Heike ] , KurtExitMapArea ) ;
11379: LD_VAR 0 1
11383: PUSH
11384: LD_EXP 79
11388: PUSH
11389: EMPTY
11390: LIST
11391: LIST
11392: PPUSH
11393: LD_INT 11
11395: PPUSH
11396: CALL_OW 113
// exit ;
11400: GO 11410
// end ; end ; wait ( 0 0$3 ) ;
11402: LD_INT 105
11404: PPUSH
11405: CALL_OW 67
// enable ;
11409: ENABLE
// end ;
11410: PPOPN 1
11412: END
// export function Dial_PlayerDontSendHeike ; begin
11413: LD_INT 0
11415: PPUSH
// DialogueOn ;
11416: CALL_OW 6
// SayRadio ( Kurt , DMercDeceived-Kurt-1 ) ;
11420: LD_EXP 80
11424: PPUSH
11425: LD_STRING DMercDeceived-Kurt-1
11427: PPUSH
11428: CALL_OW 94
// DialogueOff ;
11432: CALL_OW 7
// SetAttitude ( 3 , 8 , att_enemy , true ) ;
11436: LD_INT 3
11438: PPUSH
11439: LD_INT 8
11441: PPUSH
11442: LD_INT 2
11444: PPUSH
11445: LD_INT 1
11447: PPUSH
11448: CALL_OW 80
// KurtAttack = true ;
11452: LD_ADDR_EXP 25
11456: PUSH
11457: LD_INT 1
11459: ST_TO_ADDR
// end ;
11460: LD_VAR 0 1
11464: RET
// export function Dial_BetrayedKurt1 ; begin
11465: LD_INT 0
11467: PPUSH
// DialogueOn ;
11468: CALL_OW 6
// Say ( Kurt , DMercDeceived-Kurt-1 ) ;
11472: LD_EXP 80
11476: PPUSH
11477: LD_STRING DMercDeceived-Kurt-1
11479: PPUSH
11480: CALL_OW 88
// DialogueOff ;
11484: CALL_OW 7
// if IsPlaced ( Kurt ) then
11488: LD_EXP 80
11492: PPUSH
11493: CALL_OW 305
11497: IFFALSE 11546
// begin SetSide ( KurtEng , 8 ) ;
11499: LD_EXP 82
11503: PPUSH
11504: LD_INT 8
11506: PPUSH
11507: CALL_OW 235
// allowExitFromMap = 3 ;
11511: LD_ADDR_EXP 18
11515: PUSH
11516: LD_INT 3
11518: ST_TO_ADDR
// if KurtCanEscape then
11519: LD_EXP 21
11523: IFFALSE 11546
// ComMoveToArea ( [ Kurt , KurtEng ] , KurtExitMapArea ) ;
11525: LD_EXP 80
11529: PUSH
11530: LD_EXP 82
11534: PUSH
11535: EMPTY
11536: LIST
11537: LIST
11538: PPUSH
11539: LD_INT 11
11541: PPUSH
11542: CALL_OW 113
// end ; end ;
11546: LD_VAR 0 1
11550: RET
// export function Dial_BetrayedKurt2 ; begin
11551: LD_INT 0
11553: PPUSH
// DialogueOn ;
11554: CALL_OW 6
// Say ( Kurt , DMercAmbush-Kurt-1 ) ;
11558: LD_EXP 80
11562: PPUSH
11563: LD_STRING DMercAmbush-Kurt-1
11565: PPUSH
11566: CALL_OW 88
// DialogueOff ;
11570: CALL_OW 7
// if IsPlaced ( Kurt ) then
11574: LD_EXP 80
11578: PPUSH
11579: CALL_OW 305
11583: IFFALSE 11632
// begin SetSide ( KurtEng , 8 ) ;
11585: LD_EXP 82
11589: PPUSH
11590: LD_INT 8
11592: PPUSH
11593: CALL_OW 235
// allowExitFromMap = 3 ;
11597: LD_ADDR_EXP 18
11601: PUSH
11602: LD_INT 3
11604: ST_TO_ADDR
// if KurtCanEscape then
11605: LD_EXP 21
11609: IFFALSE 11632
// ComMoveToArea ( [ Kurt , KurtEng ] , KurtExitMapArea ) ;
11611: LD_EXP 80
11615: PUSH
11616: LD_EXP 82
11620: PUSH
11621: EMPTY
11622: LIST
11623: LIST
11624: PPUSH
11625: LD_INT 11
11627: PPUSH
11628: CALL_OW 113
// end ; end ;
11632: LD_VAR 0 1
11636: RET
// every 0 0$1 trigger GetSide ( KurtEng ) = 3 do var playerUnits , unit ;
11637: LD_EXP 82
11641: PPUSH
11642: CALL_OW 255
11646: PUSH
11647: LD_INT 3
11649: EQUAL
11650: IFFALSE 11797
11652: GO 11654
11654: DISABLE
11655: LD_INT 0
11657: PPUSH
11658: PPUSH
// begin playerUnits = FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
11659: LD_ADDR_VAR 0 1
11663: PUSH
11664: LD_INT 22
11666: PUSH
11667: LD_INT 3
11669: PUSH
11670: EMPTY
11671: LIST
11672: LIST
11673: PUSH
11674: LD_INT 2
11676: PUSH
11677: LD_INT 21
11679: PUSH
11680: LD_INT 1
11682: PUSH
11683: EMPTY
11684: LIST
11685: LIST
11686: PUSH
11687: LD_INT 21
11689: PUSH
11690: LD_INT 2
11692: PUSH
11693: EMPTY
11694: LIST
11695: LIST
11696: PUSH
11697: EMPTY
11698: LIST
11699: LIST
11700: LIST
11701: PUSH
11702: EMPTY
11703: LIST
11704: LIST
11705: PPUSH
11706: CALL_OW 69
11710: ST_TO_ADDR
// for unit in playerUnits do
11711: LD_ADDR_VAR 0 2
11715: PUSH
11716: LD_VAR 0 1
11720: PUSH
11721: FOR_IN
11722: IFFALSE 11751
// begin if WantsToAttack ( unit ) = KurtEng then
11724: LD_VAR 0 2
11728: PPUSH
11729: CALL_OW 319
11733: PUSH
11734: LD_EXP 82
11738: EQUAL
11739: IFFALSE 11749
// begin Dial_BetrayedKurt2 ;
11741: CALL 11551 0 0
// exit ;
11745: POP
11746: POP
11747: GO 11797
// end ; end ;
11749: GO 11721
11751: POP
11752: POP
// if ( IsDying ( KurtEng ) or IsDead ( KurtEng ) ) and GetSide ( KurtEng ) = 3 then
11753: LD_EXP 82
11757: PPUSH
11758: CALL_OW 303
11762: PUSH
11763: LD_EXP 82
11767: PPUSH
11768: CALL_OW 301
11772: OR
11773: PUSH
11774: LD_EXP 82
11778: PPUSH
11779: CALL_OW 255
11783: PUSH
11784: LD_INT 3
11786: EQUAL
11787: AND
11788: IFFALSE 11796
// begin Dial_BetrayedKurt2 ;
11790: CALL 11551 0 0
// exit ;
11794: GO 11797
// end ; enable ;
11796: ENABLE
// end ;
11797: PPOPN 2
11799: END
// every 0 0$1 trigger GetAttitude ( 3 , 8 ) = att_neutral and GetLives ( Kurt ) <= 999 do
11800: LD_INT 3
11802: PPUSH
11803: LD_INT 8
11805: PPUSH
11806: CALL_OW 81
11810: PUSH
11811: LD_INT 0
11813: EQUAL
11814: PUSH
11815: LD_EXP 80
11819: PPUSH
11820: CALL_OW 256
11824: PUSH
11825: LD_INT 999
11827: LESSEQUAL
11828: AND
11829: IFFALSE 11854
11831: GO 11833
11833: DISABLE
// begin Dial_BetrayedKurt1 ;
11834: CALL 11465 0 0
// SetAttitude ( 3 , 8 , att_enemy , true ) ;
11838: LD_INT 3
11840: PPUSH
11841: LD_INT 8
11843: PPUSH
11844: LD_INT 2
11846: PPUSH
11847: LD_INT 1
11849: PPUSH
11850: CALL_OW 80
// end ;
11854: END
// every 0 0$1 trigger buildingsToBuild <= 11 do
11855: LD_EXP 8
11859: PUSH
11860: LD_INT 11
11862: LESSEQUAL
11863: IFFALSE 12112
11865: GO 11867
11867: DISABLE
// begin if not IsOK ( Kuzmov ) and not IsOK ( Oblukov ) then
11868: LD_EXP 72
11872: PPUSH
11873: CALL_OW 302
11877: NOT
11878: PUSH
11879: LD_EXP 74
11883: PPUSH
11884: CALL_OW 302
11888: NOT
11889: AND
11890: IFFALSE 11894
// exit ;
11892: GO 12112
// DialogueOn ;
11894: CALL_OW 6
// if IsOK ( Kuzmov ) then
11898: LD_EXP 72
11902: PPUSH
11903: CALL_OW 302
11907: IFFALSE 11923
// Say ( Kuzmov , DFiringRange-Kuz-1 ) else
11909: LD_EXP 72
11913: PPUSH
11914: LD_STRING DFiringRange-Kuz-1
11916: PPUSH
11917: CALL_OW 88
11921: GO 11935
// Say ( Oblukov , DFiringRange-Obl-1 ) ;
11923: LD_EXP 74
11927: PPUSH
11928: LD_STRING DFiringRange-Obl-1
11930: PPUSH
11931: CALL_OW 88
// Say ( Burlak , DFiringRange-Bur-1 ) ;
11935: LD_EXP 57
11939: PPUSH
11940: LD_STRING DFiringRange-Bur-1
11942: PPUSH
11943: CALL_OW 88
// CenterOnXY ( 99 , 30 ) ;
11947: LD_INT 99
11949: PPUSH
11950: LD_INT 30
11952: PPUSH
11953: CALL_OW 84
// Wait ( 0 0$0.5 ) ;
11957: LD_INT 18
11959: PPUSH
11960: CALL_OW 67
// RevealFogArea ( 3 , ShootArea ) ;
11964: LD_INT 3
11966: PPUSH
11967: LD_INT 12
11969: PPUSH
11970: CALL_OW 332
// SetAreaMapShow ( ShootArea , 1 ) ;
11974: LD_INT 12
11976: PPUSH
11977: LD_INT 1
11979: PPUSH
11980: CALL_OW 424
// if IsOK ( Kuzmov ) then
11984: LD_EXP 72
11988: PPUSH
11989: CALL_OW 302
11993: IFFALSE 12009
// Say ( Kuzmov , DFiringRange-Kuz-2 ) else
11995: LD_EXP 72
11999: PPUSH
12000: LD_STRING DFiringRange-Kuz-2
12002: PPUSH
12003: CALL_OW 88
12007: GO 12021
// Say ( Oblukov , DFiringRange-Obl-2 ) ;
12009: LD_EXP 74
12013: PPUSH
12014: LD_STRING DFiringRange-Obl-2
12016: PPUSH
12017: CALL_OW 88
// case Query ( QShootingGallery ) of 1 :
12021: LD_STRING QShootingGallery
12023: PPUSH
12024: CALL_OW 97
12028: PUSH
12029: LD_INT 1
12031: DOUBLE
12032: EQUAL
12033: IFTRUE 12037
12035: GO 12074
12037: POP
// begin Say ( Burlak , DQrShootingGallery#1-Bur-1 ) ;
12038: LD_EXP 57
12042: PPUSH
12043: LD_STRING DQrShootingGallery#1-Bur-1
12045: PPUSH
12046: CALL_OW 88
// BurlakRespect = BurlakRespect + 1 ;
12050: LD_ADDR_EXP 30
12054: PUSH
12055: LD_EXP 30
12059: PUSH
12060: LD_INT 1
12062: PLUS
12063: ST_TO_ADDR
// canShootTrening = true ;
12064: LD_ADDR_EXP 29
12068: PUSH
12069: LD_INT 1
12071: ST_TO_ADDR
// end ; 2 :
12072: GO 12108
12074: LD_INT 2
12076: DOUBLE
12077: EQUAL
12078: IFTRUE 12082
12080: GO 12107
12082: POP
// begin Say ( Burlak , DQrShootingGallery#2-Bur-1 ) ;
12083: LD_EXP 57
12087: PPUSH
12088: LD_STRING DQrShootingGallery#2-Bur-1
12090: PPUSH
12091: CALL_OW 88
// SetAreaMapShow ( ShootArea , 0 ) ;
12095: LD_INT 12
12097: PPUSH
12098: LD_INT 0
12100: PPUSH
12101: CALL_OW 424
// end ; end ;
12105: GO 12108
12107: POP
// DialogueOff ;
12108: CALL_OW 7
// end ;
12112: END
// every 0 0$1 trigger canShootTrening do
12113: LD_EXP 29
12117: IFFALSE 12127
12119: GO 12121
12121: DISABLE
// begin enable ;
12122: ENABLE
// ShootTreningController ;
12123: CALL 7091 0 0
// end ;
12127: END
// every 0 0$1 trigger buildingsToBuild <= 7 do var hunters , hunter ;
12128: LD_EXP 8
12132: PUSH
12133: LD_INT 7
12135: LESSEQUAL
12136: IFFALSE 12526
12138: GO 12140
12140: DISABLE
12141: LD_INT 0
12143: PPUSH
12144: PPUSH
// begin hunters = [ ] ;
12145: LD_ADDR_VAR 0 1
12149: PUSH
12150: EMPTY
12151: ST_TO_ADDR
// if IsOK ( Belkov ) then
12152: LD_EXP 66
12156: PPUSH
12157: CALL_OW 302
12161: IFFALSE 12179
// hunters = hunters ^ Belkov ;
12163: LD_ADDR_VAR 0 1
12167: PUSH
12168: LD_VAR 0 1
12172: PUSH
12173: LD_EXP 66
12177: ADD
12178: ST_TO_ADDR
// if IsOK ( Karamazov ) then
12179: LD_EXP 58
12183: PPUSH
12184: CALL_OW 302
12188: IFFALSE 12206
// hunters = hunters ^ Karamazov ;
12190: LD_ADDR_VAR 0 1
12194: PUSH
12195: LD_VAR 0 1
12199: PUSH
12200: LD_EXP 58
12204: ADD
12205: ST_TO_ADDR
// if IsOK ( Kozlov ) then
12206: LD_EXP 73
12210: PPUSH
12211: CALL_OW 302
12215: IFFALSE 12233
// hunters = hunters ^ Kozlov ;
12217: LD_ADDR_VAR 0 1
12221: PUSH
12222: LD_VAR 0 1
12226: PUSH
12227: LD_EXP 73
12231: ADD
12232: ST_TO_ADDR
// if not hunters then
12233: LD_VAR 0 1
12237: NOT
12238: IFFALSE 12242
// exit ;
12240: GO 12526
// hunter = hunters [ Rand ( 1 , hunters ) ] ;
12242: LD_ADDR_VAR 0 2
12246: PUSH
12247: LD_VAR 0 1
12251: PUSH
12252: LD_INT 1
12254: PPUSH
12255: LD_VAR 0 1
12259: PPUSH
12260: CALL_OW 12
12264: ARRAY
12265: ST_TO_ADDR
// DialogueOn ;
12266: CALL_OW 6
// case hunter of Belkov :
12270: LD_VAR 0 2
12274: PUSH
12275: LD_EXP 66
12279: DOUBLE
12280: EQUAL
12281: IFTRUE 12285
12283: GO 12300
12285: POP
// Say ( Belkov , DHunting-Bel-1 ) ; Karamazov :
12286: LD_EXP 66
12290: PPUSH
12291: LD_STRING DHunting-Bel-1
12293: PPUSH
12294: CALL_OW 88
12298: GO 12351
12300: LD_EXP 58
12304: DOUBLE
12305: EQUAL
12306: IFTRUE 12310
12308: GO 12325
12310: POP
// Say ( Karamazov , DHunting-Kar-1 ) ; Kozlov :
12311: LD_EXP 58
12315: PPUSH
12316: LD_STRING DHunting-Kar-1
12318: PPUSH
12319: CALL_OW 88
12323: GO 12351
12325: LD_EXP 73
12329: DOUBLE
12330: EQUAL
12331: IFTRUE 12335
12333: GO 12350
12335: POP
// Say ( Kozlov , DHunting-Koz-1 ) ; end ;
12336: LD_EXP 73
12340: PPUSH
12341: LD_STRING DHunting-Koz-1
12343: PPUSH
12344: CALL_OW 88
12348: GO 12351
12350: POP
// Say ( Burlak , DHunting-Bur-1 ) ;
12351: LD_EXP 57
12355: PPUSH
12356: LD_STRING DHunting-Bur-1
12358: PPUSH
12359: CALL_OW 88
// case hunter of Belkov :
12363: LD_VAR 0 2
12367: PUSH
12368: LD_EXP 66
12372: DOUBLE
12373: EQUAL
12374: IFTRUE 12378
12376: GO 12393
12378: POP
// Say ( Belkov , DHunting-Bel-2 ) ; Karamazov :
12379: LD_EXP 66
12383: PPUSH
12384: LD_STRING DHunting-Bel-2
12386: PPUSH
12387: CALL_OW 88
12391: GO 12444
12393: LD_EXP 58
12397: DOUBLE
12398: EQUAL
12399: IFTRUE 12403
12401: GO 12418
12403: POP
// Say ( Karamazov , DHunting-Kar-2 ) ; Kozlov :
12404: LD_EXP 58
12408: PPUSH
12409: LD_STRING DHunting-Kar-2
12411: PPUSH
12412: CALL_OW 88
12416: GO 12444
12418: LD_EXP 73
12422: DOUBLE
12423: EQUAL
12424: IFTRUE 12428
12426: GO 12443
12428: POP
// Say ( Kozlov , DHunting-Koz-2 ) ; end ;
12429: LD_EXP 73
12433: PPUSH
12434: LD_STRING DHunting-Koz-2
12436: PPUSH
12437: CALL_OW 88
12441: GO 12444
12443: POP
// DialogueOff ;
12444: CALL_OW 7
// case Query ( QHunting ) of 1 :
12448: LD_STRING QHunting
12450: PPUSH
12451: CALL_OW 97
12455: PUSH
12456: LD_INT 1
12458: DOUBLE
12459: EQUAL
12460: IFTRUE 12464
12462: GO 12502
12464: POP
// begin Say ( Burlak , DQrHunting#1-Bur-1 ) ;
12465: LD_EXP 57
12469: PPUSH
12470: LD_STRING DQrHunting#1-Bur-1
12472: PPUSH
12473: CALL_OW 88
// BurlakRespect = BurlakRespect + 1 ;
12477: LD_ADDR_EXP 30
12481: PUSH
12482: LD_EXP 30
12486: PUSH
12487: LD_INT 1
12489: PLUS
12490: ST_TO_ADDR
// GoToHunt ( hunter ) ;
12491: LD_VAR 0 2
12495: PPUSH
12496: CALL 7719 0 1
// end ; 2 :
12500: GO 12526
12502: LD_INT 2
12504: DOUBLE
12505: EQUAL
12506: IFTRUE 12510
12508: GO 12525
12510: POP
// Say ( Burlak , DQrHunting#2-Bur-1 ) ; end ;
12511: LD_EXP 57
12515: PPUSH
12516: LD_STRING DQrHunting#2-Bur-1
12518: PPUSH
12519: CALL_OW 88
12523: GO 12526
12525: POP
// end ;
12526: PPOPN 2
12528: END
// every 0 0$1 trigger buildingsToBuild <= 3 do var unit , womans , men , woman , man , depots ;
12529: LD_EXP 8
12533: PUSH
12534: LD_INT 3
12536: LESSEQUAL
12537: IFFALSE 13524
12539: GO 12541
12541: DISABLE
12542: LD_INT 0
12544: PPUSH
12545: PPUSH
12546: PPUSH
12547: PPUSH
12548: PPUSH
12549: PPUSH
// begin womans = [ ] ;
12550: LD_ADDR_VAR 0 2
12554: PUSH
12555: EMPTY
12556: ST_TO_ADDR
// men = [ ] ;
12557: LD_ADDR_VAR 0 3
12561: PUSH
12562: EMPTY
12563: ST_TO_ADDR
// if IsOK ( Petrovova ) then
12564: LD_EXP 59
12568: PPUSH
12569: CALL_OW 302
12573: IFFALSE 12591
// womans = womans ^ Petrovova ;
12575: LD_ADDR_VAR 0 2
12579: PUSH
12580: LD_VAR 0 2
12584: PUSH
12585: LD_EXP 59
12589: ADD
12590: ST_TO_ADDR
// if IsOK ( Kirilenkova ) then
12591: LD_EXP 65
12595: PPUSH
12596: CALL_OW 302
12600: IFFALSE 12618
// womans = womans ^ Kirilenkova ;
12602: LD_ADDR_VAR 0 2
12606: PUSH
12607: LD_VAR 0 2
12611: PUSH
12612: LD_EXP 65
12616: ADD
12617: ST_TO_ADDR
// if IsOK ( Kapitsova ) then
12618: LD_EXP 75
12622: PPUSH
12623: CALL_OW 302
12627: IFFALSE 12645
// womans = womans ^ Kapitsova ;
12629: LD_ADDR_VAR 0 2
12633: PUSH
12634: LD_VAR 0 2
12638: PUSH
12639: LD_EXP 75
12643: ADD
12644: ST_TO_ADDR
// DialogueOn ;
12645: CALL_OW 6
// if womans then
12649: LD_VAR 0 2
12653: IFFALSE 12780
// begin case womans [ Rand ( 1 , womans ) ] of Petrovova :
12655: LD_VAR 0 2
12659: PUSH
12660: LD_INT 1
12662: PPUSH
12663: LD_VAR 0 2
12667: PPUSH
12668: CALL_OW 12
12672: ARRAY
12673: PUSH
12674: LD_EXP 59
12678: DOUBLE
12679: EQUAL
12680: IFTRUE 12684
12682: GO 12709
12684: POP
// begin Say ( Petrovova , DFreeTime-Ptr-1 ) ;
12685: LD_EXP 59
12689: PPUSH
12690: LD_STRING DFreeTime-Ptr-1
12692: PPUSH
12693: CALL_OW 88
// woman = Petrovova ;
12697: LD_ADDR_VAR 0 4
12701: PUSH
12702: LD_EXP 59
12706: ST_TO_ADDR
// end ; Kirilenkova :
12707: GO 12780
12709: LD_EXP 65
12713: DOUBLE
12714: EQUAL
12715: IFTRUE 12719
12717: GO 12744
12719: POP
// begin Say ( Kirilenkova , DFreeTime-Kir-1 ) ;
12720: LD_EXP 65
12724: PPUSH
12725: LD_STRING DFreeTime-Kir-1
12727: PPUSH
12728: CALL_OW 88
// woman = Kirilenkova ;
12732: LD_ADDR_VAR 0 4
12736: PUSH
12737: LD_EXP 65
12741: ST_TO_ADDR
// end ; Kapitsova :
12742: GO 12780
12744: LD_EXP 75
12748: DOUBLE
12749: EQUAL
12750: IFTRUE 12754
12752: GO 12779
12754: POP
// begin Say ( Kapitsova , DFreeTime-Kap-1 ) ;
12755: LD_EXP 75
12759: PPUSH
12760: LD_STRING DFreeTime-Kap-1
12762: PPUSH
12763: CALL_OW 88
// woman = Kapitsova ;
12767: LD_ADDR_VAR 0 4
12771: PUSH
12772: LD_EXP 75
12776: ST_TO_ADDR
// end ; end ;
12777: GO 12780
12779: POP
// end ; if IsOK ( Kuzmov ) then
12780: LD_EXP 72
12784: PPUSH
12785: CALL_OW 302
12789: IFFALSE 12807
// men = men ^ Kuzmov ;
12791: LD_ADDR_VAR 0 3
12795: PUSH
12796: LD_VAR 0 3
12800: PUSH
12801: LD_EXP 72
12805: ADD
12806: ST_TO_ADDR
// if IsOK ( Titov ) then
12807: LD_EXP 62
12811: PPUSH
12812: CALL_OW 302
12816: IFFALSE 12834
// men = men ^ Titov ;
12818: LD_ADDR_VAR 0 3
12822: PUSH
12823: LD_VAR 0 3
12827: PUSH
12828: LD_EXP 62
12832: ADD
12833: ST_TO_ADDR
// if IsOK ( Gnyevko ) then
12834: LD_EXP 69
12838: PPUSH
12839: CALL_OW 302
12843: IFFALSE 12861
// men = men ^ Gnyevko ;
12845: LD_ADDR_VAR 0 3
12849: PUSH
12850: LD_VAR 0 3
12854: PUSH
12855: LD_EXP 69
12859: ADD
12860: ST_TO_ADDR
// if IsOK ( Oblukov ) then
12861: LD_EXP 74
12865: PPUSH
12866: CALL_OW 302
12870: IFFALSE 12888
// men = men ^ Oblukov ;
12872: LD_ADDR_VAR 0 3
12876: PUSH
12877: LD_VAR 0 3
12881: PUSH
12882: LD_EXP 74
12886: ADD
12887: ST_TO_ADDR
// if men then
12888: LD_VAR 0 3
12892: IFFALSE 13054
// begin case men [ Rand ( 1 , men ) ] of Kuzmov :
12894: LD_VAR 0 3
12898: PUSH
12899: LD_INT 1
12901: PPUSH
12902: LD_VAR 0 3
12906: PPUSH
12907: CALL_OW 12
12911: ARRAY
12912: PUSH
12913: LD_EXP 72
12917: DOUBLE
12918: EQUAL
12919: IFTRUE 12923
12921: GO 12948
12923: POP
// begin Say ( Kuzmov , DFreeTime-Kuz-1 ) ;
12924: LD_EXP 72
12928: PPUSH
12929: LD_STRING DFreeTime-Kuz-1
12931: PPUSH
12932: CALL_OW 88
// man = Kuzmov ;
12936: LD_ADDR_VAR 0 5
12940: PUSH
12941: LD_EXP 72
12945: ST_TO_ADDR
// end ; Titov :
12946: GO 13054
12948: LD_EXP 62
12952: DOUBLE
12953: EQUAL
12954: IFTRUE 12958
12956: GO 12983
12958: POP
// begin Say ( Titov , DFreeTime-Tit-1 ) ;
12959: LD_EXP 62
12963: PPUSH
12964: LD_STRING DFreeTime-Tit-1
12966: PPUSH
12967: CALL_OW 88
// man = Titov ;
12971: LD_ADDR_VAR 0 5
12975: PUSH
12976: LD_EXP 62
12980: ST_TO_ADDR
// end ; Gnyevko :
12981: GO 13054
12983: LD_EXP 69
12987: DOUBLE
12988: EQUAL
12989: IFTRUE 12993
12991: GO 13018
12993: POP
// begin Say ( Gnyevko , DFreeTime-Gny-1 ) ;
12994: LD_EXP 69
12998: PPUSH
12999: LD_STRING DFreeTime-Gny-1
13001: PPUSH
13002: CALL_OW 88
// man = Gnyevko ;
13006: LD_ADDR_VAR 0 5
13010: PUSH
13011: LD_EXP 69
13015: ST_TO_ADDR
// end ; Oblukov :
13016: GO 13054
13018: LD_EXP 74
13022: DOUBLE
13023: EQUAL
13024: IFTRUE 13028
13026: GO 13053
13028: POP
// begin Say ( Oblukov , DFreeTime-Obl-1 ) ;
13029: LD_EXP 74
13033: PPUSH
13034: LD_STRING DFreeTime-Obl-1
13036: PPUSH
13037: CALL_OW 88
// man = Oblukov ;
13041: LD_ADDR_VAR 0 5
13045: PUSH
13046: LD_EXP 74
13050: ST_TO_ADDR
// end ; end ;
13051: GO 13054
13053: POP
// end ; DialogueOff ;
13054: CALL_OW 7
// if not woman and not man then
13058: LD_VAR 0 4
13062: NOT
13063: PUSH
13064: LD_VAR 0 5
13068: NOT
13069: AND
13070: IFFALSE 13078
// begin DialogueOff ;
13072: CALL_OW 7
// exit ;
13076: GO 13524
// end ; case Query ( QFreeTime ) of 1 :
13078: LD_STRING QFreeTime
13080: PPUSH
13081: CALL_OW 97
13085: PUSH
13086: LD_INT 1
13088: DOUBLE
13089: EQUAL
13090: IFTRUE 13094
13092: GO 13496
13094: POP
// begin Say ( Burlak , DQrFreeTime#1-Bur-1 ) ;
13095: LD_EXP 57
13099: PPUSH
13100: LD_STRING DQrFreeTime#1-Bur-1
13102: PPUSH
13103: CALL_OW 88
// DialogueOff ;
13107: CALL_OW 7
// BurlakRespect = BurlakRespect + 1 ;
13111: LD_ADDR_EXP 30
13115: PUSH
13116: LD_EXP 30
13120: PUSH
13121: LD_INT 1
13123: PLUS
13124: ST_TO_ADDR
// SetSide ( [ woman , man ] , 6 ) ;
13125: LD_VAR 0 4
13129: PUSH
13130: LD_VAR 0 5
13134: PUSH
13135: EMPTY
13136: LIST
13137: LIST
13138: PPUSH
13139: LD_INT 6
13141: PPUSH
13142: CALL_OW 235
// for unit in [ woman , man ] do
13146: LD_ADDR_VAR 0 1
13150: PUSH
13151: LD_VAR 0 4
13155: PUSH
13156: LD_VAR 0 5
13160: PUSH
13161: EMPTY
13162: LIST
13163: LIST
13164: PUSH
13165: FOR_IN
13166: IFFALSE 13221
// if IsInUnit ( unit ) then
13168: LD_VAR 0 1
13172: PPUSH
13173: CALL_OW 310
13177: IFFALSE 13219
// begin if GetType ( IsInUnit ( unit ) ) = unit_vehicle then
13179: LD_VAR 0 1
13183: PPUSH
13184: CALL_OW 310
13188: PPUSH
13189: CALL_OW 247
13193: PUSH
13194: LD_INT 2
13196: EQUAL
13197: IFFALSE 13210
// ComExitVehicle ( unit ) else
13199: LD_VAR 0 1
13203: PPUSH
13204: CALL_OW 121
13208: GO 13219
// ComExitBuilding ( unit ) ;
13210: LD_VAR 0 1
13214: PPUSH
13215: CALL_OW 122
// end ;
13219: GO 13165
13221: POP
13222: POP
// wait ( 0 0$1 ) ;
13223: LD_INT 35
13225: PPUSH
13226: CALL_OW 67
// ComMoveToArea ( [ woman , man ] , ExitMapArea ) ;
13230: LD_VAR 0 4
13234: PUSH
13235: LD_VAR 0 5
13239: PUSH
13240: EMPTY
13241: LIST
13242: LIST
13243: PPUSH
13244: LD_INT 8
13246: PPUSH
13247: CALL_OW 113
// allowExitFromMap = 1 ;
13251: LD_ADDR_EXP 18
13255: PUSH
13256: LD_INT 1
13258: ST_TO_ADDR
// wait ( 3 3$0 ) ;
13259: LD_INT 6300
13261: PPUSH
13262: CALL_OW 67
// PlaceUnitXYR ( woman , 157 , 29 , 3 , false ) ;
13266: LD_VAR 0 4
13270: PPUSH
13271: LD_INT 157
13273: PPUSH
13274: LD_INT 29
13276: PPUSH
13277: LD_INT 3
13279: PPUSH
13280: LD_INT 0
13282: PPUSH
13283: CALL_OW 50
// PlaceUnitXYR ( man , 157 , 29 , 3 , false ) ;
13287: LD_VAR 0 5
13291: PPUSH
13292: LD_INT 157
13294: PPUSH
13295: LD_INT 29
13297: PPUSH
13298: LD_INT 3
13300: PPUSH
13301: LD_INT 0
13303: PPUSH
13304: CALL_OW 50
// SetSide ( [ woman , man ] , 3 ) ;
13308: LD_VAR 0 4
13312: PUSH
13313: LD_VAR 0 5
13317: PUSH
13318: EMPTY
13319: LIST
13320: LIST
13321: PPUSH
13322: LD_INT 3
13324: PPUSH
13325: CALL_OW 235
// depots = FilterAllUnits ( [ [ f_side , 3 ] , [ [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ] ) ;
13329: LD_ADDR_VAR 0 6
13333: PUSH
13334: LD_INT 22
13336: PUSH
13337: LD_INT 3
13339: PUSH
13340: EMPTY
13341: LIST
13342: LIST
13343: PUSH
13344: LD_INT 2
13346: PUSH
13347: LD_INT 30
13349: PUSH
13350: LD_INT 0
13352: PUSH
13353: EMPTY
13354: LIST
13355: LIST
13356: PUSH
13357: LD_INT 30
13359: PUSH
13360: LD_INT 1
13362: PUSH
13363: EMPTY
13364: LIST
13365: LIST
13366: PUSH
13367: EMPTY
13368: LIST
13369: LIST
13370: LIST
13371: PUSH
13372: EMPTY
13373: LIST
13374: PUSH
13375: EMPTY
13376: LIST
13377: LIST
13378: PPUSH
13379: CALL_OW 69
13383: ST_TO_ADDR
// if depots then
13384: LD_VAR 0 6
13388: IFFALSE 13438
// ComMoveXY ( [ woman , man ] , GetX ( depots [ 1 ] ) , GetY ( depots [ 1 ] ) ) else
13390: LD_VAR 0 4
13394: PUSH
13395: LD_VAR 0 5
13399: PUSH
13400: EMPTY
13401: LIST
13402: LIST
13403: PPUSH
13404: LD_VAR 0 6
13408: PUSH
13409: LD_INT 1
13411: ARRAY
13412: PPUSH
13413: CALL_OW 250
13417: PPUSH
13418: LD_VAR 0 6
13422: PUSH
13423: LD_INT 1
13425: ARRAY
13426: PPUSH
13427: CALL_OW 251
13431: PPUSH
13432: CALL_OW 111
13436: GO 13476
// ComMoveXY ( [ woman , man ] , GetX ( Burlak ) , GetY ( Burlak ) ) ;
13438: LD_VAR 0 4
13442: PUSH
13443: LD_VAR 0 5
13447: PUSH
13448: EMPTY
13449: LIST
13450: LIST
13451: PPUSH
13452: LD_EXP 57
13456: PPUSH
13457: CALL_OW 250
13461: PPUSH
13462: LD_EXP 57
13466: PPUSH
13467: CALL_OW 251
13471: PPUSH
13472: CALL_OW 111
// CenterOnUnits ( [ woman , man ] ) ;
13476: LD_VAR 0 4
13480: PUSH
13481: LD_VAR 0 5
13485: PUSH
13486: EMPTY
13487: LIST
13488: LIST
13489: PPUSH
13490: CALL_OW 85
// end ; 2 :
13494: GO 13520
13496: LD_INT 2
13498: DOUBLE
13499: EQUAL
13500: IFTRUE 13504
13502: GO 13519
13504: POP
// Say ( Burlak , DQrFreeTime#2-Bur-1 ) ; end ;
13505: LD_EXP 57
13509: PPUSH
13510: LD_STRING DQrFreeTime#2-Bur-1
13512: PPUSH
13513: CALL_OW 88
13517: GO 13520
13519: POP
// DialogueOff ;
13520: CALL_OW 7
// end ;
13524: PPOPN 6
13526: END
// every 0 0$1 trigger GetAmountWeaponsDataBuildOnVehicle ( false ) <= 2 do
13527: LD_INT 0
13529: PPUSH
13530: CALL 6800 0 1
13534: PUSH
13535: LD_INT 2
13537: LESSEQUAL
13538: IFFALSE 13673
13540: GO 13542
13542: DISABLE
// begin DialogueOn ;
13543: CALL_OW 6
// if IsOK ( Kozlov ) then
13547: LD_EXP 73
13551: PPUSH
13552: CALL_OW 302
13556: IFFALSE 13572
// Say ( Kozlov , DMasha-Koz-1 ) else
13558: LD_EXP 73
13562: PPUSH
13563: LD_STRING DMasha-Koz-1
13565: PPUSH
13566: CALL_OW 88
13570: GO 13635
// DialogRandom ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_ok ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) , DMasha-Koz-1 ,  , false , false ) ;
13572: LD_INT 22
13574: PUSH
13575: LD_INT 3
13577: PUSH
13578: EMPTY
13579: LIST
13580: LIST
13581: PUSH
13582: LD_INT 50
13584: PUSH
13585: EMPTY
13586: LIST
13587: PUSH
13588: LD_INT 21
13590: PUSH
13591: LD_INT 1
13593: PUSH
13594: EMPTY
13595: LIST
13596: LIST
13597: PUSH
13598: LD_INT 26
13600: PUSH
13601: LD_INT 1
13603: PUSH
13604: EMPTY
13605: LIST
13606: LIST
13607: PUSH
13608: EMPTY
13609: LIST
13610: LIST
13611: LIST
13612: LIST
13613: PPUSH
13614: CALL_OW 69
13618: PPUSH
13619: LD_STRING DMasha-Koz-1
13621: PPUSH
13622: LD_STRING 
13624: PPUSH
13625: LD_INT 0
13627: PPUSH
13628: LD_INT 0
13630: PPUSH
13631: CALL 6249 0 5
// Say ( Burlak , DMasha2-Bur-1 ) ;
13635: LD_EXP 57
13639: PPUSH
13640: LD_STRING DMasha2-Bur-1
13642: PPUSH
13643: CALL_OW 88
// DialogueOff ;
13647: CALL_OW 7
// Query ( QMasha ) ;
13651: LD_STRING QMasha
13653: PPUSH
13654: CALL_OW 97
// ChangeMissionObjectives ( MMasha ) ;
13658: LD_STRING MMasha
13660: PPUSH
13661: CALL_OW 337
// canChooseMashaVehicle = true ;
13665: LD_ADDR_EXP 36
13669: PUSH
13670: LD_INT 1
13672: ST_TO_ADDR
// end ;
13673: END
// export function Dial_ComputerTechResearched ; begin
13674: LD_INT 0
13676: PPUSH
// if IsOk ( Scholtze ) or IsOK ( Kapitsova ) then
13677: LD_EXP 71
13681: PPUSH
13682: CALL_OW 302
13686: PUSH
13687: LD_EXP 75
13691: PPUSH
13692: CALL_OW 302
13696: OR
13697: IFFALSE 13793
// begin DialogueOn ;
13699: CALL_OW 6
// if IsOK ( Scholtze ) then
13703: LD_EXP 71
13707: PPUSH
13708: CALL_OW 302
13712: IFFALSE 13728
// Say ( Scholtze , DAI-Sch-1 ) else
13714: LD_EXP 71
13718: PPUSH
13719: LD_STRING DAI-Sch-1
13721: PPUSH
13722: CALL_OW 88
13726: GO 13740
// Say ( Kapitsova , DAI-Kap-1 ) ;
13728: LD_EXP 75
13732: PPUSH
13733: LD_STRING DAI-Kap-1
13735: PPUSH
13736: CALL_OW 88
// Say ( Burlak , DAI-Bur-1 ) ;
13740: LD_EXP 57
13744: PPUSH
13745: LD_STRING DAI-Bur-1
13747: PPUSH
13748: CALL_OW 88
// if IsOK ( Scholtze ) then
13752: LD_EXP 71
13756: PPUSH
13757: CALL_OW 302
13761: IFFALSE 13777
// Say ( Scholtze , DAI-Sch-2 ) else
13763: LD_EXP 71
13767: PPUSH
13768: LD_STRING DAI-Sch-2
13770: PPUSH
13771: CALL_OW 88
13775: GO 13789
// Say ( Kapitsova , DAI-Kap-2 ) ;
13777: LD_EXP 75
13781: PPUSH
13782: LD_STRING DAI-Kap-2
13784: PPUSH
13785: CALL_OW 88
// DialogueOff ;
13789: CALL_OW 7
// end ; ChangeMissionObjectives ( MAI ) ;
13793: LD_STRING MAI
13795: PPUSH
13796: CALL_OW 337
// end ;
13800: LD_VAR 0 1
13804: RET
// export function Dial_TeleportTechResearched ; begin
13805: LD_INT 0
13807: PPUSH
// if IsOk ( Scholtze ) or IsOK ( Kapitsova ) then
13808: LD_EXP 71
13812: PPUSH
13813: CALL_OW 302
13817: PUSH
13818: LD_EXP 75
13822: PPUSH
13823: CALL_OW 302
13827: OR
13828: IFFALSE 13936
// begin DialogueOn ;
13830: CALL_OW 6
// if IsOK ( Scholtze ) then
13834: LD_EXP 71
13838: PPUSH
13839: CALL_OW 302
13843: IFFALSE 13859
// Say ( Scholtze , DSpontTelep-Sch-1 ) else
13845: LD_EXP 71
13849: PPUSH
13850: LD_STRING DSpontTelep-Sch-1
13852: PPUSH
13853: CALL_OW 88
13857: GO 13871
// Say ( Kapitsova , DSpontTelep-Kap-1 ) ;
13859: LD_EXP 75
13863: PPUSH
13864: LD_STRING DSpontTelep-Kap-1
13866: PPUSH
13867: CALL_OW 88
// Say ( Burlak , DSpontTelep-Bur-1 ) ;
13871: LD_EXP 57
13875: PPUSH
13876: LD_STRING DSpontTelep-Bur-1
13878: PPUSH
13879: CALL_OW 88
// if IsOK ( Scholtze ) then
13883: LD_EXP 71
13887: PPUSH
13888: CALL_OW 302
13892: IFFALSE 13908
// Say ( Scholtze , DSpontTelep-Sch-2 ) else
13894: LD_EXP 71
13898: PPUSH
13899: LD_STRING DSpontTelep-Sch-2
13901: PPUSH
13902: CALL_OW 88
13906: GO 13920
// Say ( Kapitsova , DSpontTelep-Kap-2 ) ;
13908: LD_EXP 75
13912: PPUSH
13913: LD_STRING DSpontTelep-Kap-2
13915: PPUSH
13916: CALL_OW 88
// Say ( Burlak , DSpontTelep-Bur-2 ) ;
13920: LD_EXP 57
13924: PPUSH
13925: LD_STRING DSpontTelep-Bur-2
13927: PPUSH
13928: CALL_OW 88
// DialogueOff ;
13932: CALL_OW 7
// end ; ChangeMissionObjectives ( MTele ) ;
13936: LD_STRING MTele
13938: PPUSH
13939: CALL_OW 337
// end ;
13943: LD_VAR 0 1
13947: RET
// every 0 0$1 trigger buildingsToBuild <= 3 and GetAmountWeaponsDataBuildOnVehicle ( false ) <= 1 and techsToResearch <= 4 do
13948: LD_EXP 8
13952: PUSH
13953: LD_INT 3
13955: LESSEQUAL
13956: PUSH
13957: LD_INT 0
13959: PPUSH
13960: CALL 6800 0 1
13964: PUSH
13965: LD_INT 1
13967: LESSEQUAL
13968: AND
13969: PUSH
13970: LD_EXP 9
13974: PUSH
13975: LD_INT 4
13977: LESSEQUAL
13978: AND
13979: IFFALSE 14180
13981: GO 13983
13983: DISABLE
// begin SayRadio ( Popov , DAmAttackStart-Pop-1 ) ;
13984: LD_EXP 76
13988: PPUSH
13989: LD_STRING DAmAttackStart-Pop-1
13991: PPUSH
13992: CALL_OW 94
// if KurtStatus = 1 and HeikeStatus = 1 then
13996: LD_EXP 22
14000: PUSH
14001: LD_INT 1
14003: EQUAL
14004: PUSH
14005: LD_EXP 3
14009: PUSH
14010: LD_INT 1
14012: EQUAL
14013: AND
14014: IFFALSE 14172
// begin wait ( 0 0$10 ) ;
14016: LD_INT 350
14018: PPUSH
14019: CALL_OW 67
// DialogueOn ;
14023: CALL_OW 6
// SayRadio ( Heike , DLegionFormed-Hke-1 ) ;
14027: LD_EXP 79
14031: PPUSH
14032: LD_STRING DLegionFormed-Hke-1
14034: PPUSH
14035: CALL_OW 94
// Say ( Burlak , DLegionFormed-Bur-1 ) ;
14039: LD_EXP 57
14043: PPUSH
14044: LD_STRING DLegionFormed-Bur-1
14046: PPUSH
14047: CALL_OW 88
// SayRadio ( Heike , DLegionFormed-Hke-2 ) ;
14051: LD_EXP 79
14055: PPUSH
14056: LD_STRING DLegionFormed-Hke-2
14058: PPUSH
14059: CALL_OW 94
// Say ( Burlak , DLegionFormed-Bur-2 ) ;
14063: LD_EXP 57
14067: PPUSH
14068: LD_STRING DLegionFormed-Bur-2
14070: PPUSH
14071: CALL_OW 88
// SayRadio ( Heike , DLegionFormed-Hke-3 ) ;
14075: LD_EXP 79
14079: PPUSH
14080: LD_STRING DLegionFormed-Hke-3
14082: PPUSH
14083: CALL_OW 94
// case Query ( QLegion ) of 1 :
14087: LD_STRING QLegion
14089: PPUSH
14090: CALL_OW 97
14094: PUSH
14095: LD_INT 1
14097: DOUBLE
14098: EQUAL
14099: IFTRUE 14103
14101: GO 14134
14103: POP
// begin acceptLegionOffert = true ;
14104: LD_ADDR_EXP 31
14108: PUSH
14109: LD_INT 1
14111: ST_TO_ADDR
// legionOffertCountdown = true ;
14112: LD_ADDR_EXP 33
14116: PUSH
14117: LD_INT 1
14119: ST_TO_ADDR
// Say ( Burlak , DQrLegion#1-Bur-1 ) ;
14120: LD_EXP 57
14124: PPUSH
14125: LD_STRING DQrLegion#1-Bur-1
14127: PPUSH
14128: CALL_OW 88
// end ; 2 :
14132: GO 14166
14134: LD_INT 2
14136: DOUBLE
14137: EQUAL
14138: IFTRUE 14142
14140: GO 14165
14142: POP
// begin Say ( Burlak , DQrLegion#2-Bur-1 ) ;
14143: LD_EXP 57
14147: PPUSH
14148: LD_STRING DQrLegion#2-Bur-1
14150: PPUSH
14151: CALL_OW 88
// americansAttack = true ;
14155: LD_ADDR_EXP 26
14159: PUSH
14160: LD_INT 1
14162: ST_TO_ADDR
// end ; end ;
14163: GO 14166
14165: POP
// DialogueOff ;
14166: CALL_OW 7
// end else
14170: GO 14180
// begin americansAttack = true ;
14172: LD_ADDR_EXP 26
14176: PUSH
14177: LD_INT 1
14179: ST_TO_ADDR
// end ; end ;
14180: END
// every 0 0$1 trigger legionOffertTime <= 0 0$00 do
14181: LD_EXP 34
14185: PUSH
14186: LD_INT 0
14188: LESSEQUAL
14189: IFFALSE 14210
14191: GO 14193
14193: DISABLE
// begin legionOffertCountdown = false ;
14194: LD_ADDR_EXP 33
14198: PUSH
14199: LD_INT 0
14201: ST_TO_ADDR
// americansAttack = true ;
14202: LD_ADDR_EXP 26
14206: PUSH
14207: LD_INT 1
14209: ST_TO_ADDR
// end ;
14210: END
// every 0 0$1 trigger legionOffertCountdown do var needCrates , depots , depot , crates ;
14211: LD_EXP 33
14215: IFFALSE 14401
14217: GO 14219
14219: DISABLE
14220: LD_INT 0
14222: PPUSH
14223: PPUSH
14224: PPUSH
14225: PPUSH
// begin needCrates = 50 ;
14226: LD_ADDR_VAR 0 1
14230: PUSH
14231: LD_INT 50
14233: ST_TO_ADDR
// crates = 0 ;
14234: LD_ADDR_VAR 0 4
14238: PUSH
14239: LD_INT 0
14241: ST_TO_ADDR
// depots = FilterAllUnits ( [ [ f_side , 3 ] , [ [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ] ) ;
14242: LD_ADDR_VAR 0 2
14246: PUSH
14247: LD_INT 22
14249: PUSH
14250: LD_INT 3
14252: PUSH
14253: EMPTY
14254: LIST
14255: LIST
14256: PUSH
14257: LD_INT 2
14259: PUSH
14260: LD_INT 30
14262: PUSH
14263: LD_INT 0
14265: PUSH
14266: EMPTY
14267: LIST
14268: LIST
14269: PUSH
14270: LD_INT 30
14272: PUSH
14273: LD_INT 1
14275: PUSH
14276: EMPTY
14277: LIST
14278: LIST
14279: PUSH
14280: EMPTY
14281: LIST
14282: LIST
14283: LIST
14284: PUSH
14285: EMPTY
14286: LIST
14287: PUSH
14288: EMPTY
14289: LIST
14290: LIST
14291: PPUSH
14292: CALL_OW 69
14296: ST_TO_ADDR
// for depot in depots do
14297: LD_ADDR_VAR 0 3
14301: PUSH
14302: LD_VAR 0 2
14306: PUSH
14307: FOR_IN
14308: IFFALSE 14399
// begin crates = GetResourceType ( GetBase ( depot ) , mat_cans ) ;
14310: LD_ADDR_VAR 0 4
14314: PUSH
14315: LD_VAR 0 3
14319: PPUSH
14320: CALL_OW 274
14324: PPUSH
14325: LD_INT 1
14327: PPUSH
14328: CALL_OW 275
14332: ST_TO_ADDR
// if crates >= needCrates then
14333: LD_VAR 0 4
14337: PUSH
14338: LD_VAR 0 1
14342: GREATEREQUAL
14343: IFFALSE 14397
// begin SetResourceType ( GetBase ( depot ) , mat_cans , crates - needCrates ) ;
14345: LD_VAR 0 3
14349: PPUSH
14350: CALL_OW 274
14354: PPUSH
14355: LD_INT 1
14357: PPUSH
14358: LD_VAR 0 4
14362: PUSH
14363: LD_VAR 0 1
14367: MINUS
14368: PPUSH
14369: CALL_OW 277
// legionOffertCountdown = false ;
14373: LD_ADDR_EXP 33
14377: PUSH
14378: LD_INT 0
14380: ST_TO_ADDR
// paidLegionOffert = true ;
14381: LD_ADDR_EXP 32
14385: PUSH
14386: LD_INT 1
14388: ST_TO_ADDR
// americansAttack = true ;
14389: LD_ADDR_EXP 26
14393: PUSH
14394: LD_INT 1
14396: ST_TO_ADDR
// end ; end ;
14397: GO 14307
14399: POP
14400: POP
// end ;
14401: PPOPN 4
14403: END
// every 0 0$1 trigger currentAmWave >= americansAttackWaves and FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_type , unit_human ] , [ f_and , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ] ] ) = 0 do
14404: LD_EXP 85
14408: PUSH
14409: LD_EXP 48
14413: GREATEREQUAL
14414: PUSH
14415: LD_INT 22
14417: PUSH
14418: LD_INT 1
14420: PUSH
14421: EMPTY
14422: LIST
14423: LIST
14424: PUSH
14425: LD_INT 2
14427: PUSH
14428: LD_INT 21
14430: PUSH
14431: LD_INT 1
14433: PUSH
14434: EMPTY
14435: LIST
14436: LIST
14437: PUSH
14438: LD_INT 1
14440: PUSH
14441: LD_INT 21
14443: PUSH
14444: LD_INT 2
14446: PUSH
14447: EMPTY
14448: LIST
14449: LIST
14450: PUSH
14451: LD_INT 33
14453: PUSH
14454: LD_INT 3
14456: PUSH
14457: EMPTY
14458: LIST
14459: LIST
14460: PUSH
14461: EMPTY
14462: LIST
14463: LIST
14464: LIST
14465: PUSH
14466: EMPTY
14467: LIST
14468: LIST
14469: LIST
14470: PUSH
14471: EMPTY
14472: LIST
14473: LIST
14474: PPUSH
14475: CALL_OW 69
14479: PUSH
14480: LD_INT 0
14482: EQUAL
14483: AND
14484: IFFALSE 14684
14486: GO 14488
14488: DISABLE
// begin DialogueOn ;
14489: CALL_OW 6
// if IsOK ( Belkov ) then
14493: LD_EXP 66
14497: PPUSH
14498: CALL_OW 302
14502: IFFALSE 14518
// Say ( Belkov , DAmAttackFin-Bel-1 ) else
14504: LD_EXP 66
14508: PPUSH
14509: LD_STRING DAmAttackFin-Bel-1
14511: PPUSH
14512: CALL_OW 88
14516: GO 14541
// if IsOK ( Belkov2 ) then
14518: LD_EXP 67
14522: PPUSH
14523: CALL_OW 302
14527: IFFALSE 14541
// Say ( Belkov2 , DAmAttackFin-Bel-1 ) ;
14529: LD_EXP 67
14533: PPUSH
14534: LD_STRING DAmAttackFin-Bel-1
14536: PPUSH
14537: CALL_OW 88
// if IsOK ( Gnyevko ) then
14541: LD_EXP 69
14545: PPUSH
14546: CALL_OW 302
14550: IFFALSE 14564
// Say ( Gnyevko , DAmAttackFin-Gny-1 ) ;
14552: LD_EXP 69
14556: PPUSH
14557: LD_STRING DAmAttackFin-Gny-1
14559: PPUSH
14560: CALL_OW 88
// if IsOK ( Titov ) then
14564: LD_EXP 62
14568: PPUSH
14569: CALL_OW 302
14573: IFFALSE 14587
// Say ( Titov , DAmAttackFin-Tit-1 ) ;
14575: LD_EXP 62
14579: PPUSH
14580: LD_STRING DAmAttackFin-Tit-1
14582: PPUSH
14583: CALL_OW 88
// if IsOK ( Lipshchin ) then
14587: LD_EXP 64
14591: PPUSH
14592: CALL_OW 302
14596: IFFALSE 14610
// Say ( Lipshchin , DAmAttackFin-Lip-1 ) ;
14598: LD_EXP 64
14602: PPUSH
14603: LD_STRING DAmAttackFin-Lip-1
14605: PPUSH
14606: CALL_OW 88
// if IsOK ( Karamazov ) then
14610: LD_EXP 58
14614: PPUSH
14615: CALL_OW 302
14619: IFFALSE 14633
// Say ( Karamazov , DAmAttackFin-Kar-1 ) ;
14621: LD_EXP 58
14625: PPUSH
14626: LD_STRING DAmAttackFin-Kar-1
14628: PPUSH
14629: CALL_OW 88
// if IsOK ( Oblukov ) then
14633: LD_EXP 74
14637: PPUSH
14638: CALL_OW 302
14642: IFFALSE 14656
// Say ( Oblukov , DAmAttackFin-Obl-1 ) ;
14644: LD_EXP 74
14648: PPUSH
14649: LD_STRING DAmAttackFin-Obl-1
14651: PPUSH
14652: CALL_OW 88
// Say ( Burlak , AmAttackFin-Bur-1 ) ;
14656: LD_EXP 57
14660: PPUSH
14661: LD_STRING AmAttackFin-Bur-1
14663: PPUSH
14664: CALL_OW 88
// SayRadio ( Popov , DAmAttackFin-Pop-1 ) ;
14668: LD_EXP 76
14672: PPUSH
14673: LD_STRING DAmAttackFin-Pop-1
14675: PPUSH
14676: CALL_OW 94
// DialogueOff ;
14680: CALL_OW 7
// end ;
14684: END
// every 0 0$1 trigger buildingsToBuild + ( 3 - GetAmountWeaponsDataBuildOnTurret ( true ) ) = 0 do
14685: LD_EXP 8
14689: PUSH
14690: LD_INT 3
14692: PUSH
14693: LD_INT 1
14695: PPUSH
14696: CALL 6690 0 1
14700: MINUS
14701: PLUS
14702: PUSH
14703: LD_INT 0
14705: EQUAL
14706: IFFALSE 14718
14708: GO 14710
14710: DISABLE
// ChangeMissionObjectives ( MBuildingsDone ) ;
14711: LD_STRING MBuildingsDone
14713: PPUSH
14714: CALL_OW 337
14718: END
// every 0 0$1 trigger GetAmountWeaponsDataBuildOnVehicle ( false ) = 0 do
14719: LD_INT 0
14721: PPUSH
14722: CALL 6800 0 1
14726: PUSH
14727: LD_INT 0
14729: EQUAL
14730: IFFALSE 14742
14732: GO 14734
14734: DISABLE
// ChangeMissionObjectives ( MWeaponsDone ) ;
14735: LD_STRING MWeaponsDone
14737: PPUSH
14738: CALL_OW 337
14742: END
// every 0 0$1 trigger techsToResearch = 0 do
14743: LD_EXP 9
14747: PUSH
14748: LD_INT 0
14750: EQUAL
14751: IFFALSE 14763
14753: GO 14755
14755: DISABLE
// ChangeMissionObjectives ( MTechnoDone ) ;
14756: LD_STRING MTechnoDone
14758: PPUSH
14759: CALL_OW 337
14763: END
// every 0 0$1 trigger americansAttack and not FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_type , unit_human ] , [ f_and , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ] ] ) do
14764: LD_EXP 26
14768: PUSH
14769: LD_INT 22
14771: PUSH
14772: LD_INT 1
14774: PUSH
14775: EMPTY
14776: LIST
14777: LIST
14778: PUSH
14779: LD_INT 2
14781: PUSH
14782: LD_INT 21
14784: PUSH
14785: LD_INT 1
14787: PUSH
14788: EMPTY
14789: LIST
14790: LIST
14791: PUSH
14792: LD_INT 1
14794: PUSH
14795: LD_INT 21
14797: PUSH
14798: LD_INT 2
14800: PUSH
14801: EMPTY
14802: LIST
14803: LIST
14804: PUSH
14805: LD_INT 33
14807: PUSH
14808: LD_INT 3
14810: PUSH
14811: EMPTY
14812: LIST
14813: LIST
14814: PUSH
14815: EMPTY
14816: LIST
14817: LIST
14818: LIST
14819: PUSH
14820: EMPTY
14821: LIST
14822: LIST
14823: LIST
14824: PUSH
14825: EMPTY
14826: LIST
14827: LIST
14828: PPUSH
14829: CALL_OW 69
14833: NOT
14834: AND
14835: IFFALSE 14847
14837: GO 14839
14839: DISABLE
// ChangeMissionObjectives ( MEnemyDone ) ;
14840: LD_STRING MEnemyDone
14842: PPUSH
14843: CALL_OW 337
14847: END
// every 0 0$1 trigger ( buildingsToBuild + ( 3 - GetAmountWeaponsDataBuildOnTurret ( true ) ) ) = 0 and GetAmountWeaponsDataBuildOnVehicle ( false ) = 0 and techsToResearch = 0 and FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] ] ) = 0 and FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_type , unit_human ] , [ f_and , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ] ] ) = 0 and Masha and IsOK ( Masha [ 1 ] ) and buildCompVehicle and testedTeleport do
14848: LD_EXP 8
14852: PUSH
14853: LD_INT 3
14855: PUSH
14856: LD_INT 1
14858: PPUSH
14859: CALL 6690 0 1
14863: MINUS
14864: PLUS
14865: PUSH
14866: LD_INT 0
14868: EQUAL
14869: PUSH
14870: LD_INT 0
14872: PPUSH
14873: CALL 6800 0 1
14877: PUSH
14878: LD_INT 0
14880: EQUAL
14881: AND
14882: PUSH
14883: LD_EXP 9
14887: PUSH
14888: LD_INT 0
14890: EQUAL
14891: AND
14892: PUSH
14893: LD_INT 22
14895: PUSH
14896: LD_INT 8
14898: PUSH
14899: EMPTY
14900: LIST
14901: LIST
14902: PUSH
14903: LD_INT 21
14905: PUSH
14906: LD_INT 1
14908: PUSH
14909: EMPTY
14910: LIST
14911: LIST
14912: PUSH
14913: EMPTY
14914: LIST
14915: LIST
14916: PPUSH
14917: CALL_OW 69
14921: PUSH
14922: LD_INT 0
14924: EQUAL
14925: AND
14926: PUSH
14927: LD_INT 22
14929: PUSH
14930: LD_INT 1
14932: PUSH
14933: EMPTY
14934: LIST
14935: LIST
14936: PUSH
14937: LD_INT 2
14939: PUSH
14940: LD_INT 21
14942: PUSH
14943: LD_INT 1
14945: PUSH
14946: EMPTY
14947: LIST
14948: LIST
14949: PUSH
14950: LD_INT 1
14952: PUSH
14953: LD_INT 21
14955: PUSH
14956: LD_INT 2
14958: PUSH
14959: EMPTY
14960: LIST
14961: LIST
14962: PUSH
14963: LD_INT 33
14965: PUSH
14966: LD_INT 3
14968: PUSH
14969: EMPTY
14970: LIST
14971: LIST
14972: PUSH
14973: EMPTY
14974: LIST
14975: LIST
14976: LIST
14977: PUSH
14978: EMPTY
14979: LIST
14980: LIST
14981: LIST
14982: PUSH
14983: EMPTY
14984: LIST
14985: LIST
14986: PPUSH
14987: CALL_OW 69
14991: PUSH
14992: LD_INT 0
14994: EQUAL
14995: AND
14996: PUSH
14997: LD_EXP 4
15001: AND
15002: PUSH
15003: LD_EXP 4
15007: PUSH
15008: LD_INT 1
15010: ARRAY
15011: PPUSH
15012: CALL_OW 302
15016: AND
15017: PUSH
15018: LD_EXP 37
15022: AND
15023: PUSH
15024: LD_EXP 39
15028: AND
15029: IFFALSE 15038
15031: GO 15033
15033: DISABLE
// begin FinishMission ;
15034: CALL 15243 0 0
// end ;
15038: END
// every 0 0$1 do var unit ;
15039: GO 15041
15041: DISABLE
15042: LD_INT 0
15044: PPUSH
// begin case allowExitFromMap of 1 :
15045: LD_EXP 18
15049: PUSH
15050: LD_INT 1
15052: DOUBLE
15053: EQUAL
15054: IFTRUE 15058
15056: GO 15086
15058: POP
// RemoveUnits ( FilterUnitsInArea ( ExitMapArea , [ [ f_side , 6 ] ] ) ) ; 3 :
15059: LD_INT 8
15061: PPUSH
15062: LD_INT 22
15064: PUSH
15065: LD_INT 6
15067: PUSH
15068: EMPTY
15069: LIST
15070: LIST
15071: PUSH
15072: EMPTY
15073: LIST
15074: PPUSH
15075: CALL_OW 70
15079: PPUSH
15080: CALL 6526 0 1
15084: GO 15209
15086: LD_INT 3
15088: DOUBLE
15089: EQUAL
15090: IFTRUE 15094
15092: GO 15122
15094: POP
// RemoveUnits ( FilterUnitsInArea ( KurtExitMapArea , [ [ f_side , 8 ] ] ) ) ; 4 :
15095: LD_INT 11
15097: PPUSH
15098: LD_INT 22
15100: PUSH
15101: LD_INT 8
15103: PUSH
15104: EMPTY
15105: LIST
15106: LIST
15107: PUSH
15108: EMPTY
15109: LIST
15110: PPUSH
15111: CALL_OW 70
15115: PPUSH
15116: CALL 6526 0 1
15120: GO 15209
15122: LD_INT 4
15124: DOUBLE
15125: EQUAL
15126: IFTRUE 15130
15128: GO 15208
15130: POP
// begin RemoveUnits ( FilterUnitsInArea ( ExitMapArea , [ [ f_side , 8 ] ] ) ) ;
15131: LD_INT 8
15133: PPUSH
15134: LD_INT 22
15136: PUSH
15137: LD_INT 8
15139: PUSH
15140: EMPTY
15141: LIST
15142: LIST
15143: PUSH
15144: EMPTY
15145: LIST
15146: PPUSH
15147: CALL_OW 70
15151: PPUSH
15152: CALL 6526 0 1
// RemoveUnits ( FilterUnitsInArea ( KurtExitMapArea , [ [ f_side , 8 ] ] ) ) ;
15156: LD_INT 11
15158: PPUSH
15159: LD_INT 22
15161: PUSH
15162: LD_INT 8
15164: PUSH
15165: EMPTY
15166: LIST
15167: LIST
15168: PUSH
15169: EMPTY
15170: LIST
15171: PPUSH
15172: CALL_OW 70
15176: PPUSH
15177: CALL 6526 0 1
// RemoveUnits ( FilterUnitsInArea ( ExitMapArea , [ [ f_side , 2 ] ] ) ) ;
15181: LD_INT 8
15183: PPUSH
15184: LD_INT 22
15186: PUSH
15187: LD_INT 2
15189: PUSH
15190: EMPTY
15191: LIST
15192: LIST
15193: PUSH
15194: EMPTY
15195: LIST
15196: PPUSH
15197: CALL_OW 70
15201: PPUSH
15202: CALL 6526 0 1
// end ; end ;
15206: GO 15209
15208: POP
// enable ;
15209: ENABLE
// end ; end_of_file
15210: PPOPN 1
15212: END
// export function Lose_Burlak ; begin
15213: LD_INT 0
15215: PPUSH
// YouLost ( Burlak ) ;
15216: LD_STRING Burlak
15218: PPUSH
15219: CALL_OW 104
// end ;
15223: LD_VAR 0 1
15227: RET
// export function Lost_AttackAlly ; begin
15228: LD_INT 0
15230: PPUSH
// YouLost ( SelfAttack ) ;
15231: LD_STRING SelfAttack
15233: PPUSH
15234: CALL_OW 104
// end ; end_of_file
15238: LD_VAR 0 1
15242: RET
// export function FinishMission ; begin
15243: LD_INT 0
15245: PPUSH
// SetRewards ;
15246: CALL 15267 0 0
// SavePlayerCharacters ;
15250: CALL 15528 0 0
// SaveGlobalVariables ;
15254: CALL 16078 0 0
// YouWin ;
15258: CALL_OW 103
// end ;
15262: LD_VAR 0 1
15266: RET
// function SetRewards ; begin
15267: LD_INT 0
15269: PPUSH
// AddMedal ( ArtisticImpression , 1 ) ;
15270: LD_STRING ArtisticImpression
15272: PPUSH
15273: LD_INT 1
15275: PPUSH
15276: CALL_OW 101
// if not HeikeCaptured then
15280: LD_EXP 1
15284: NOT
15285: IFFALSE 15319
// begin if speedMedalTime >= 0 0$00 then
15287: LD_EXP 52
15291: PUSH
15292: LD_INT 0
15294: GREATEREQUAL
15295: IFFALSE 15309
// AddMedal ( Speed , 1 ) else
15297: LD_STRING Speed
15299: PPUSH
15300: LD_INT 1
15302: PPUSH
15303: CALL_OW 101
15307: GO 15319
// AddMedal ( Speed , 1 ) ;
15309: LD_STRING Speed
15311: PPUSH
15312: LD_INT 1
15314: PPUSH
15315: CALL_OW 101
// end ; if lostUnits then
15319: LD_EXP 40
15323: IFFALSE 15338
// begin AddMedal ( FavouriteCommander , - 1 ) ;
15325: LD_STRING FavouriteCommander
15327: PPUSH
15328: LD_INT 1
15330: NEG
15331: PPUSH
15332: CALL_OW 101
// end else
15336: GO 15430
// begin case BurlakRespect of 0 :
15338: LD_EXP 30
15342: PUSH
15343: LD_INT 0
15345: DOUBLE
15346: EQUAL
15347: IFTRUE 15351
15349: GO 15365
15351: POP
// AddMedal ( FavouriteCommander , - 2 ) ; 1 :
15352: LD_STRING FavouriteCommander
15354: PPUSH
15355: LD_INT 2
15357: NEG
15358: PPUSH
15359: CALL_OW 101
15363: GO 15430
15365: LD_INT 1
15367: DOUBLE
15368: EQUAL
15369: IFTRUE 15373
15371: GO 15387
15373: POP
// AddMedal ( FavouriteCommander , - 3 ) ; 2 :
15374: LD_STRING FavouriteCommander
15376: PPUSH
15377: LD_INT 3
15379: NEG
15380: PPUSH
15381: CALL_OW 101
15385: GO 15430
15387: LD_INT 2
15389: DOUBLE
15390: EQUAL
15391: IFTRUE 15395
15393: GO 15408
15395: POP
// AddMedal ( FavouriteCommander , 1 ) ; 3 :
15396: LD_STRING FavouriteCommander
15398: PPUSH
15399: LD_INT 1
15401: PPUSH
15402: CALL_OW 101
15406: GO 15430
15408: LD_INT 3
15410: DOUBLE
15411: EQUAL
15412: IFTRUE 15416
15414: GO 15429
15416: POP
// AddMedal ( FavouriteCommander , 1 ) ; end ;
15417: LD_STRING FavouriteCommander
15419: PPUSH
15420: LD_INT 1
15422: PPUSH
15423: CALL_OW 101
15427: GO 15430
15429: POP
// end ; if HeikeCaptured then
15430: LD_EXP 1
15434: IFFALSE 15465
// begin if buildArabBarrack then
15436: LD_EXP 38
15440: IFFALSE 15454
// AddMedal ( ArabBarracks , 1 ) else
15442: LD_STRING ArabBarracks
15444: PPUSH
15445: LD_INT 1
15447: PPUSH
15448: CALL_OW 101
15452: GO 15465
// AddMedal ( ArabBarracks , - 1 ) ;
15454: LD_STRING ArabBarracks
15456: PPUSH
15457: LD_INT 1
15459: NEG
15460: PPUSH
15461: CALL_OW 101
// end ; GiveMedals ( Main1 ) ;
15465: LD_STRING Main1
15467: PPUSH
15468: CALL_OW 102
// RewardPeople ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_nation , nation_russian ] , [ f_ok ] ] ) ) ;
15472: LD_INT 22
15474: PUSH
15475: LD_INT 3
15477: PUSH
15478: EMPTY
15479: LIST
15480: LIST
15481: PUSH
15482: LD_INT 21
15484: PUSH
15485: LD_INT 1
15487: PUSH
15488: EMPTY
15489: LIST
15490: LIST
15491: PUSH
15492: LD_INT 23
15494: PUSH
15495: LD_INT 3
15497: PUSH
15498: EMPTY
15499: LIST
15500: LIST
15501: PUSH
15502: LD_INT 50
15504: PUSH
15505: EMPTY
15506: LIST
15507: PUSH
15508: EMPTY
15509: LIST
15510: LIST
15511: LIST
15512: LIST
15513: PPUSH
15514: CALL_OW 69
15518: PPUSH
15519: CALL_OW 43
// end ;
15523: LD_VAR 0 1
15527: RET
// function SavePlayerCharacters ; var randomsToSave ; begin
15528: LD_INT 0
15530: PPUSH
15531: PPUSH
// ExtSaveCharacter ( Burlak , Burlak , 3 ) ;
15532: LD_EXP 57
15536: PPUSH
15537: LD_STRING Burlak
15539: PPUSH
15540: LD_INT 3
15542: PPUSH
15543: CALL 6048 0 3
// ExtSaveCharacter ( Karamazov , Karamazov , 3 ) ;
15547: LD_EXP 58
15551: PPUSH
15552: LD_STRING Karamazov
15554: PPUSH
15555: LD_INT 3
15557: PPUSH
15558: CALL 6048 0 3
// ExtSaveCharacter ( Petrovova , Petrovova , 3 ) ;
15562: LD_EXP 59
15566: PPUSH
15567: LD_STRING Petrovova
15569: PPUSH
15570: LD_INT 3
15572: PPUSH
15573: CALL 6048 0 3
// ExtSaveCharacter ( Gleb , Gleb , 3 ) ;
15577: LD_EXP 60
15581: PPUSH
15582: LD_STRING Gleb
15584: PPUSH
15585: LD_INT 3
15587: PPUSH
15588: CALL 6048 0 3
// ExtSaveCharacter ( Petrosyan , Petrosyan , 3 ) ;
15592: LD_EXP 61
15596: PPUSH
15597: LD_STRING Petrosyan
15599: PPUSH
15600: LD_INT 3
15602: PPUSH
15603: CALL 6048 0 3
// ExtSaveCharacter ( Dolgov , Dolgov , 3 ) ;
15607: LD_EXP 63
15611: PPUSH
15612: LD_STRING Dolgov
15614: PPUSH
15615: LD_INT 3
15617: PPUSH
15618: CALL 6048 0 3
// ExtSaveCharacter ( Lipshchin , Lipshchin , 3 ) ;
15622: LD_EXP 64
15626: PPUSH
15627: LD_STRING Lipshchin
15629: PPUSH
15630: LD_INT 3
15632: PPUSH
15633: CALL 6048 0 3
// ExtSaveCharacter ( Titov , Titov , 3 ) ;
15637: LD_EXP 62
15641: PPUSH
15642: LD_STRING Titov
15644: PPUSH
15645: LD_INT 3
15647: PPUSH
15648: CALL 6048 0 3
// ExtSaveCharacter ( Kirilenkova , Kirilenkova , 3 ) ;
15652: LD_EXP 65
15656: PPUSH
15657: LD_STRING Kirilenkova
15659: PPUSH
15660: LD_INT 3
15662: PPUSH
15663: CALL 6048 0 3
// ExtSaveCharacter ( Belkov , Belkov , 3 ) ;
15667: LD_EXP 66
15671: PPUSH
15672: LD_STRING Belkov
15674: PPUSH
15675: LD_INT 3
15677: PPUSH
15678: CALL 6048 0 3
// ExtSaveCharacter ( Belkov2 , Belkov2 , 3 ) ;
15682: LD_EXP 67
15686: PPUSH
15687: LD_STRING Belkov2
15689: PPUSH
15690: LD_INT 3
15692: PPUSH
15693: CALL 6048 0 3
// ExtSaveCharacter ( Xavier , Xavier , 3 ) ;
15697: LD_EXP 68
15701: PPUSH
15702: LD_STRING Xavier
15704: PPUSH
15705: LD_INT 3
15707: PPUSH
15708: CALL 6048 0 3
// ExtSaveCharacter ( Kozlov , Kozlov , 3 ) ;
15712: LD_EXP 73
15716: PPUSH
15717: LD_STRING Kozlov
15719: PPUSH
15720: LD_INT 3
15722: PPUSH
15723: CALL 6048 0 3
// ExtSaveCharacter ( Oblukov , Oblukov , 3 ) ;
15727: LD_EXP 74
15731: PPUSH
15732: LD_STRING Oblukov
15734: PPUSH
15735: LD_INT 3
15737: PPUSH
15738: CALL 6048 0 3
// ExtSaveCharacter ( Kapitsova , Kapitsova , 3 ) ;
15742: LD_EXP 75
15746: PPUSH
15747: LD_STRING Kapitsova
15749: PPUSH
15750: LD_INT 3
15752: PPUSH
15753: CALL 6048 0 3
// ExtSaveCharacter ( Gnyevko , Gnyevko , 3 ) ;
15757: LD_EXP 69
15761: PPUSH
15762: LD_STRING Gnyevko
15764: PPUSH
15765: LD_INT 3
15767: PPUSH
15768: CALL 6048 0 3
// ExtSaveCharacter ( Kovalyuk , Kovalyuk , 3 ) ;
15772: LD_EXP 70
15776: PPUSH
15777: LD_STRING Kovalyuk
15779: PPUSH
15780: LD_INT 3
15782: PPUSH
15783: CALL 6048 0 3
// ExtSaveCharacter ( Scholtze , Scholtze , 3 ) ;
15787: LD_EXP 71
15791: PPUSH
15792: LD_STRING Scholtze
15794: PPUSH
15795: LD_INT 3
15797: PPUSH
15798: CALL 6048 0 3
// ExtSaveCharacter ( Kuzmov , Kuzmov , 3 ) ;
15802: LD_EXP 72
15806: PPUSH
15807: LD_STRING Kuzmov
15809: PPUSH
15810: LD_INT 3
15812: PPUSH
15813: CALL 6048 0 3
// ExtSaveCharacters ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_or , [ f_class , class_apeman ] , [ f_class , class_apeman_engineer ] , [ f_class , class_apeman_soldier ] ] ] ) , other_apemans , 3 ) ;
15817: LD_INT 22
15819: PUSH
15820: LD_INT 3
15822: PUSH
15823: EMPTY
15824: LIST
15825: LIST
15826: PUSH
15827: LD_INT 21
15829: PUSH
15830: LD_INT 1
15832: PUSH
15833: EMPTY
15834: LIST
15835: LIST
15836: PUSH
15837: LD_INT 2
15839: PUSH
15840: LD_INT 25
15842: PUSH
15843: LD_INT 12
15845: PUSH
15846: EMPTY
15847: LIST
15848: LIST
15849: PUSH
15850: LD_INT 25
15852: PUSH
15853: LD_INT 16
15855: PUSH
15856: EMPTY
15857: LIST
15858: LIST
15859: PUSH
15860: LD_INT 25
15862: PUSH
15863: LD_INT 15
15865: PUSH
15866: EMPTY
15867: LIST
15868: LIST
15869: PUSH
15870: EMPTY
15871: LIST
15872: LIST
15873: LIST
15874: LIST
15875: PUSH
15876: EMPTY
15877: LIST
15878: LIST
15879: LIST
15880: PPUSH
15881: CALL_OW 69
15885: PPUSH
15886: LD_STRING other_apemans
15888: PPUSH
15889: LD_INT 3
15891: PPUSH
15892: CALL 6105 0 3
// randomsToSave = FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_nation , nation_russian ] ] ) diff [ Burlak , Karamazov , Petrovova , Gleb , Petrosyan , Titov , Dolgov , Lipshchin , Kirilenkova , Belkov , Belkov2 , Xavier , Gnyevko , Kovalyuk , Scholtze , Kuzmov , Kozlov , Oblukov , Kapitsova ] ;
15896: LD_ADDR_VAR 0 2
15900: PUSH
15901: LD_INT 22
15903: PUSH
15904: LD_INT 3
15906: PUSH
15907: EMPTY
15908: LIST
15909: LIST
15910: PUSH
15911: LD_INT 21
15913: PUSH
15914: LD_INT 1
15916: PUSH
15917: EMPTY
15918: LIST
15919: LIST
15920: PUSH
15921: LD_INT 23
15923: PUSH
15924: LD_INT 3
15926: PUSH
15927: EMPTY
15928: LIST
15929: LIST
15930: PUSH
15931: EMPTY
15932: LIST
15933: LIST
15934: LIST
15935: PPUSH
15936: CALL_OW 69
15940: PUSH
15941: LD_EXP 57
15945: PUSH
15946: LD_EXP 58
15950: PUSH
15951: LD_EXP 59
15955: PUSH
15956: LD_EXP 60
15960: PUSH
15961: LD_EXP 61
15965: PUSH
15966: LD_EXP 62
15970: PUSH
15971: LD_EXP 63
15975: PUSH
15976: LD_EXP 64
15980: PUSH
15981: LD_EXP 65
15985: PUSH
15986: LD_EXP 66
15990: PUSH
15991: LD_EXP 67
15995: PUSH
15996: LD_EXP 68
16000: PUSH
16001: LD_EXP 69
16005: PUSH
16006: LD_EXP 70
16010: PUSH
16011: LD_EXP 71
16015: PUSH
16016: LD_EXP 72
16020: PUSH
16021: LD_EXP 73
16025: PUSH
16026: LD_EXP 74
16030: PUSH
16031: LD_EXP 75
16035: PUSH
16036: EMPTY
16037: LIST
16038: LIST
16039: LIST
16040: LIST
16041: LIST
16042: LIST
16043: LIST
16044: LIST
16045: LIST
16046: LIST
16047: LIST
16048: LIST
16049: LIST
16050: LIST
16051: LIST
16052: LIST
16053: LIST
16054: LIST
16055: LIST
16056: DIFF
16057: ST_TO_ADDR
// ExtSaveCharacters ( randomsToSave , other_survivors , 3 ) ;
16058: LD_VAR 0 2
16062: PPUSH
16063: LD_STRING other_survivors
16065: PPUSH
16066: LD_INT 3
16068: PPUSH
16069: CALL 6105 0 3
// end ;
16073: LD_VAR 0 1
16077: RET
// function SaveGlobalVariables ; begin
16078: LD_INT 0
16080: PPUSH
// SaveBase ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_building ] ] ) , 08_TrockyBase_1 ) ;
16081: LD_INT 22
16083: PUSH
16084: LD_INT 3
16086: PUSH
16087: EMPTY
16088: LIST
16089: LIST
16090: PUSH
16091: LD_INT 21
16093: PUSH
16094: LD_INT 3
16096: PUSH
16097: EMPTY
16098: LIST
16099: LIST
16100: PUSH
16101: EMPTY
16102: LIST
16103: LIST
16104: PPUSH
16105: CALL_OW 69
16109: PPUSH
16110: LD_STRING 08_TrockyBase_1
16112: PPUSH
16113: CALL 8484 0 2
// SaveVariable ( coopWithGensher , 08_CoopWithGensher_2 ) ;
16117: LD_EXP 2
16121: PPUSH
16122: LD_STRING 08_CoopWithGensher_2
16124: PPUSH
16125: CALL_OW 39
// SaveVariable ( HeikeStatus , 08_HeikeStatus_3 ) ;
16129: LD_EXP 3
16133: PPUSH
16134: LD_STRING 08_HeikeStatus_3
16136: PPUSH
16137: CALL_OW 39
// SaveVariable ( Masha , 08_Masha_4 ) ;
16141: LD_EXP 4
16145: PPUSH
16146: LD_STRING 08_Masha_4
16148: PPUSH
16149: CALL_OW 39
// end ; end_of_file
16153: LD_VAR 0 1
16157: RET
// export function CustomEvent ( event ) ; begin
16158: LD_INT 0
16160: PPUSH
// end ;
16161: LD_VAR 0 2
16165: RET
// on BuildingComplete ( building ) do begin if GetBType ( building ) in buildingsToBuild and GetNation ( building ) = nation_russian then
16166: LD_VAR 0 1
16170: PPUSH
16171: CALL_OW 266
16175: PUSH
16176: LD_EXP 8
16180: IN
16181: PUSH
16182: LD_VAR 0 1
16186: PPUSH
16187: CALL_OW 248
16191: PUSH
16192: LD_INT 3
16194: EQUAL
16195: AND
16196: IFFALSE 16219
// buildingsToBuild = buildingsToBuild diff GetBType ( building ) ;
16198: LD_ADDR_EXP 8
16202: PUSH
16203: LD_EXP 8
16207: PUSH
16208: LD_VAR 0 1
16212: PPUSH
16213: CALL_OW 266
16217: DIFF
16218: ST_TO_ADDR
// if GetBType ( building ) = b_depot then
16219: LD_VAR 0 1
16223: PPUSH
16224: CALL_OW 266
16228: PUSH
16229: LD_INT 0
16231: EQUAL
16232: IFFALSE 16283
// begin SetBName ( building , trockij ) ;
16234: LD_VAR 0 1
16238: PPUSH
16239: LD_STRING trockij
16241: PPUSH
16242: CALL_OW 500
// if not dial_BuildDepotBlocker and HeikeCaptured then
16246: LD_EXP 5
16250: NOT
16251: PUSH
16252: LD_EXP 1
16256: AND
16257: IFFALSE 16283
// Dial_EscortHeike ( GetX ( building ) , GetY ( building ) ) ;
16259: LD_VAR 0 1
16263: PPUSH
16264: CALL_OW 250
16268: PPUSH
16269: LD_VAR 0 1
16273: PPUSH
16274: CALL_OW 251
16278: PPUSH
16279: CALL 9149 0 2
// end ; end ;
16283: PPOPN 1
16285: END
// on UpgradeComplete ( building ) do begin if GetBType ( building ) in buildingsToBuild and GetNation ( building ) = nation_russian then
16286: LD_VAR 0 1
16290: PPUSH
16291: CALL_OW 266
16295: PUSH
16296: LD_EXP 8
16300: IN
16301: PUSH
16302: LD_VAR 0 1
16306: PPUSH
16307: CALL_OW 248
16311: PUSH
16312: LD_INT 3
16314: EQUAL
16315: AND
16316: IFFALSE 16339
// buildingsToBuild = buildingsToBuild diff GetBType ( building ) ;
16318: LD_ADDR_EXP 8
16322: PUSH
16323: LD_EXP 8
16327: PUSH
16328: LD_VAR 0 1
16332: PPUSH
16333: CALL_OW 266
16337: DIFF
16338: ST_TO_ADDR
// if GetBType ( building ) = b_barracks and GetNation ( building ) = 2 and not dial_BuildArBarrackBlocker then
16339: LD_VAR 0 1
16343: PPUSH
16344: CALL_OW 266
16348: PUSH
16349: LD_INT 5
16351: EQUAL
16352: PUSH
16353: LD_VAR 0 1
16357: PPUSH
16358: CALL_OW 248
16362: PUSH
16363: LD_INT 2
16365: EQUAL
16366: AND
16367: PUSH
16368: LD_EXP 6
16372: NOT
16373: AND
16374: IFFALSE 16380
// Dial_UpgradeArmoury ;
16376: CALL 9960 0 0
// end ;
16380: PPOPN 1
16382: END
// on ResearchComplete ( research , building ) do begin if research in techsToResearch then
16383: LD_VAR 0 1
16387: PUSH
16388: LD_EXP 9
16392: IN
16393: IFFALSE 16411
// techsToResearch = techsToResearch diff research ;
16395: LD_ADDR_EXP 9
16399: PUSH
16400: LD_EXP 9
16404: PUSH
16405: LD_VAR 0 1
16409: DIFF
16410: ST_TO_ADDR
// if research = tech_LimTeleport then
16411: LD_VAR 0 1
16415: PUSH
16416: LD_INT 37
16418: EQUAL
16419: IFFALSE 16425
// Dial_TeleportTechResearched ;
16421: CALL 13805 0 0
// if research = tech_AdvAI then
16425: LD_VAR 0 1
16429: PUSH
16430: LD_INT 27
16432: EQUAL
16433: IFFALSE 16439
// Dial_ComputerTechResearched ;
16435: CALL 13674 0 0
// end ;
16439: PPOPN 2
16441: END
// on EnterVehicle ( vehicle , human ) do begin if not canChooseMashaVehicle then
16442: LD_EXP 36
16446: NOT
16447: IFFALSE 16451
// exit ;
16449: GO 16618
// wait ( 0 0$1 ) ;
16451: LD_INT 35
16453: PPUSH
16454: CALL_OW 67
// if GetSide ( vehicle ) = 3 and human = Burlak and GetNation ( vehicle ) = nation_russian and GetWeapon ( vehicle ) in [ ru_heavy_machine_gun , ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher ] then
16458: LD_VAR 0 1
16462: PPUSH
16463: CALL_OW 255
16467: PUSH
16468: LD_INT 3
16470: EQUAL
16471: PUSH
16472: LD_VAR 0 2
16476: PUSH
16477: LD_EXP 57
16481: EQUAL
16482: AND
16483: PUSH
16484: LD_VAR 0 1
16488: PPUSH
16489: CALL_OW 248
16493: PUSH
16494: LD_INT 3
16496: EQUAL
16497: AND
16498: PUSH
16499: LD_VAR 0 1
16503: PPUSH
16504: CALL_OW 264
16508: PUSH
16509: LD_INT 42
16511: PUSH
16512: LD_INT 43
16514: PUSH
16515: LD_INT 44
16517: PUSH
16518: LD_INT 46
16520: PUSH
16521: LD_INT 45
16523: PUSH
16524: EMPTY
16525: LIST
16526: LIST
16527: LIST
16528: LIST
16529: LIST
16530: IN
16531: AND
16532: IFFALSE 16618
// begin if Masha then
16534: LD_EXP 4
16538: IFFALSE 16558
// if Masha [ 1 ] = vehicle then
16540: LD_EXP 4
16544: PUSH
16545: LD_INT 1
16547: ARRAY
16548: PUSH
16549: LD_VAR 0 1
16553: EQUAL
16554: IFFALSE 16558
// exit ;
16556: GO 16618
// if firstMashaQuery then
16558: LD_EXP 35
16562: IFFALSE 16596
// begin firstMashaQuery = false ;
16564: LD_ADDR_EXP 35
16568: PUSH
16569: LD_INT 0
16571: ST_TO_ADDR
// if Query ( QMashaQuery ) = 1 then
16572: LD_STRING QMashaQuery
16574: PPUSH
16575: CALL_OW 97
16579: PUSH
16580: LD_INT 1
16582: EQUAL
16583: IFFALSE 16594
// SetMashaData ( vehicle ) ;
16585: LD_VAR 0 1
16589: PPUSH
16590: CALL 8378 0 1
// end else
16594: GO 16618
// begin if Query ( QMashaQuery2 ) = 1 then
16596: LD_STRING QMashaQuery2
16598: PPUSH
16599: CALL_OW 97
16603: PUSH
16604: LD_INT 1
16606: EQUAL
16607: IFFALSE 16618
// SetMashaData ( vehicle ) ;
16609: LD_VAR 0 1
16613: PPUSH
16614: CALL 8378 0 1
// end ; end ; end ;
16618: PPOPN 2
16620: END
// on UnitDestroyed ( unit ) do begin if Masha then
16621: LD_EXP 4
16625: IFFALSE 16650
// if unit = Masha [ 1 ] then
16627: LD_VAR 0 1
16631: PUSH
16632: LD_EXP 4
16636: PUSH
16637: LD_INT 1
16639: ARRAY
16640: EQUAL
16641: IFFALSE 16650
// Masha = [ ] ;
16643: LD_ADDR_EXP 4
16647: PUSH
16648: EMPTY
16649: ST_TO_ADDR
// if unit = Burlak then
16650: LD_VAR 0 1
16654: PUSH
16655: LD_EXP 57
16659: EQUAL
16660: IFFALSE 16666
// Lose_Burlak ;
16662: CALL 15213 0 0
// if GetType ( unit ) = unit_human and GetNation ( unit ) = nation_russian then
16666: LD_VAR 0 1
16670: PPUSH
16671: CALL_OW 247
16675: PUSH
16676: LD_INT 1
16678: EQUAL
16679: PUSH
16680: LD_VAR 0 1
16684: PPUSH
16685: CALL_OW 248
16689: PUSH
16690: LD_INT 3
16692: EQUAL
16693: AND
16694: IFFALSE 16710
// lostUnits = lostUnits + 1 ;
16696: LD_ADDR_EXP 40
16700: PUSH
16701: LD_EXP 40
16705: PUSH
16706: LD_INT 1
16708: PLUS
16709: ST_TO_ADDR
// end ;
16710: PPOPN 1
16712: END
// on UnitGoesToRed ( unit ) do begin if GetType ( unit ) = unit_vehicle and GetNation ( unit ) = nation_russian and GetTech ( tech_LimTeleport , 3 ) = state_researched and not testedTeleport then
16713: LD_VAR 0 1
16717: PPUSH
16718: CALL_OW 247
16722: PUSH
16723: LD_INT 2
16725: EQUAL
16726: PUSH
16727: LD_VAR 0 1
16731: PPUSH
16732: CALL_OW 248
16736: PUSH
16737: LD_INT 3
16739: EQUAL
16740: AND
16741: PUSH
16742: LD_INT 37
16744: PPUSH
16745: LD_INT 3
16747: PPUSH
16748: CALL_OW 321
16752: PUSH
16753: LD_INT 2
16755: EQUAL
16756: AND
16757: PUSH
16758: LD_EXP 39
16762: NOT
16763: AND
16764: IFFALSE 16781
// begin testedTeleport = true ;
16766: LD_ADDR_EXP 39
16770: PUSH
16771: LD_INT 1
16773: ST_TO_ADDR
// ChangeMissionObjectives ( MTeleDone ) ;
16774: LD_STRING MTeleDone
16776: PPUSH
16777: CALL_OW 337
// end ; if unit = Heike then
16781: LD_VAR 0 1
16785: PUSH
16786: LD_EXP 79
16790: EQUAL
16791: IFFALSE 16834
// begin DialogueOn ;
16793: CALL_OW 6
// CenterNowOnUnits ( Heike ) ;
16797: LD_EXP 79
16801: PPUSH
16802: CALL_OW 87
// ForceSay ( Heike , DHeikeKilled-Hke-1 ) ;
16806: LD_EXP 79
16810: PPUSH
16811: LD_STRING DHeikeKilled-Hke-1
16813: PPUSH
16814: CALL_OW 91
// DialogueOff ;
16818: CALL_OW 7
// SetLives ( Heike , 0 ) ;
16822: LD_EXP 79
16826: PPUSH
16827: LD_INT 0
16829: PPUSH
16830: CALL_OW 234
// end ; end ;
16834: PPOPN 1
16836: END
// on Contact ( side1 , side2 ) do begin if side1 = 3 and side2 = 6 then
16837: LD_VAR 0 1
16841: PUSH
16842: LD_INT 3
16844: EQUAL
16845: PUSH
16846: LD_VAR 0 2
16850: PUSH
16851: LD_INT 6
16853: EQUAL
16854: AND
16855: IFFALSE 16861
// Lost_AttackAlly ;
16857: CALL 15228 0 0
// if side1 = 3 and side2 = 2 then
16861: LD_VAR 0 1
16865: PUSH
16866: LD_INT 3
16868: EQUAL
16869: PUSH
16870: LD_VAR 0 2
16874: PUSH
16875: LD_INT 2
16877: EQUAL
16878: AND
16879: IFFALSE 16885
// Dial_AttackGensher ;
16881: CALL 10916 0 0
// if side1 = 3 and side2 = 5 then
16885: LD_VAR 0 1
16889: PUSH
16890: LD_INT 3
16892: EQUAL
16893: PUSH
16894: LD_VAR 0 2
16898: PUSH
16899: LD_INT 5
16901: EQUAL
16902: AND
16903: IFFALSE 16947
// begin SetAttitude ( 3 , 5 , att_enemy , true ) ;
16905: LD_INT 3
16907: PPUSH
16908: LD_INT 5
16910: PPUSH
16911: LD_INT 2
16913: PPUSH
16914: LD_INT 1
16916: PPUSH
16917: CALL_OW 80
// if acceptKurtOffert and not GetSide ( Kurt ) = 2 then
16921: LD_EXP 19
16925: PUSH
16926: LD_EXP 80
16930: PPUSH
16931: CALL_OW 255
16935: PUSH
16936: LD_INT 2
16938: EQUAL
16939: NOT
16940: AND
16941: IFFALSE 16947
// Dial_BetrayedKurt1 ;
16943: CALL 11465 0 0
// end ; if side1 = 3 and side2 = 8 and GetAttitude ( 3 , 8 ) = att_neutral then
16947: LD_VAR 0 1
16951: PUSH
16952: LD_INT 3
16954: EQUAL
16955: PUSH
16956: LD_VAR 0 2
16960: PUSH
16961: LD_INT 8
16963: EQUAL
16964: AND
16965: PUSH
16966: LD_INT 3
16968: PPUSH
16969: LD_INT 8
16971: PPUSH
16972: CALL_OW 81
16976: PUSH
16977: LD_INT 0
16979: EQUAL
16980: AND
16981: IFFALSE 16993
// begin if acceptKurtOffert then
16983: LD_EXP 19
16987: IFFALSE 16993
// Dial_BetrayedKurt2 ;
16989: CALL 11551 0 0
// end ; end ;
16993: PPOPN 2
16995: END
// on VehicleConstructed ( vehicle , building ) do begin SetWeaponDataBuild ( GetWeapon ( vehicle ) , false ) ;
16996: LD_VAR 0 1
17000: PPUSH
17001: CALL_OW 264
17005: PPUSH
17006: LD_INT 0
17008: PPUSH
17009: CALL 6886 0 2
// if GetControl ( vehicle ) = control_computer and not buildCompVehicle then
17013: LD_VAR 0 1
17017: PPUSH
17018: CALL_OW 263
17022: PUSH
17023: LD_INT 3
17025: EQUAL
17026: PUSH
17027: LD_EXP 37
17031: NOT
17032: AND
17033: IFFALSE 17050
// begin buildCompVehicle = true ;
17035: LD_ADDR_EXP 37
17039: PUSH
17040: LD_INT 1
17042: ST_TO_ADDR
// ChangeMissionObjectives ( MAIDone ) ;
17043: LD_STRING MAIDone
17045: PPUSH
17046: CALL_OW 337
// end ; end ;
17050: PPOPN 2
17052: END
// on WeaponPlaced ( building , factory ) do begin SetWeaponDataBuild ( GetBWeapon ( building ) , true ) ;
17053: LD_VAR 0 1
17057: PPUSH
17058: CALL_OW 269
17062: PPUSH
17063: LD_INT 1
17065: PPUSH
17066: CALL 6886 0 2
// end ;
17070: PPOPN 2
17072: END
// on Command ( comandid ) do var i ;
17073: LD_INT 0
17075: PPUSH
// begin if IsOK ( KurtEng ) and GetSide ( KurtEng ) = 3 then
17076: LD_EXP 82
17080: PPUSH
17081: CALL_OW 302
17085: PUSH
17086: LD_EXP 82
17090: PPUSH
17091: CALL_OW 255
17095: PUSH
17096: LD_INT 3
17098: EQUAL
17099: AND
17100: IFFALSE 17309
// if GetTaskList ( KurtEng ) then
17102: LD_EXP 82
17106: PPUSH
17107: CALL_OW 437
17111: IFFALSE 17309
// begin for i := 1 to ( GetTaskList ( KurtEng ) ) do
17113: LD_ADDR_VAR 0 2
17117: PUSH
17118: DOUBLE
17119: LD_INT 1
17121: DEC
17122: ST_TO_ADDR
17123: LD_EXP 82
17127: PPUSH
17128: CALL_OW 437
17132: PUSH
17133: FOR_TO
17134: IFFALSE 17307
// begin if ( GetTaskList ( KurtEng ) [ i ] [ 1 ] in [ F , H , M , U , V , a , h , u , v , ~ , ^ , > , + , ; , 4 , { ] ) or ( GetTaskList ( KurtEng ) [ i ] [ 1 ] = B and GetTaskList ( KurtEng ) [ i ] [ 5 ] = 36 ) then
17136: LD_EXP 82
17140: PPUSH
17141: CALL_OW 437
17145: PUSH
17146: LD_VAR 0 2
17150: ARRAY
17151: PUSH
17152: LD_INT 1
17154: ARRAY
17155: PUSH
17156: LD_STRING F
17158: PUSH
17159: LD_STRING H
17161: PUSH
17162: LD_STRING M
17164: PUSH
17165: LD_STRING U
17167: PUSH
17168: LD_STRING V
17170: PUSH
17171: LD_STRING a
17173: PUSH
17174: LD_STRING h
17176: PUSH
17177: LD_STRING u
17179: PUSH
17180: LD_STRING v
17182: PUSH
17183: LD_STRING ~
17185: PUSH
17186: LD_STRING ^
17188: PUSH
17189: LD_STRING >
17191: PUSH
17192: LD_STRING +
17194: PUSH
17195: LD_STRING ;
17197: PUSH
17198: LD_STRING 4
17200: PUSH
17201: LD_STRING {
17203: PUSH
17204: EMPTY
17205: LIST
17206: LIST
17207: LIST
17208: LIST
17209: LIST
17210: LIST
17211: LIST
17212: LIST
17213: LIST
17214: LIST
17215: LIST
17216: LIST
17217: LIST
17218: LIST
17219: LIST
17220: LIST
17221: IN
17222: PUSH
17223: LD_EXP 82
17227: PPUSH
17228: CALL_OW 437
17232: PUSH
17233: LD_VAR 0 2
17237: ARRAY
17238: PUSH
17239: LD_INT 1
17241: ARRAY
17242: PUSH
17243: LD_STRING B
17245: EQUAL
17246: PUSH
17247: LD_EXP 82
17251: PPUSH
17252: CALL_OW 437
17256: PUSH
17257: LD_VAR 0 2
17261: ARRAY
17262: PUSH
17263: LD_INT 5
17265: ARRAY
17266: PUSH
17267: LD_INT 36
17269: EQUAL
17270: AND
17271: OR
17272: IFFALSE 17276
// else
17274: GO 17305
// begin RemoveTasks ( KurtEng ) ;
17276: LD_EXP 82
17280: PPUSH
17281: CALL_OW 493
// DialogueOn ;
17285: CALL_OW 6
// Say ( Kurt , DMercRefuseBuild-Kurt-1 ) ;
17289: LD_EXP 80
17293: PPUSH
17294: LD_STRING DMercRefuseBuild-Kurt-1
17296: PPUSH
17297: CALL_OW 88
// DialogueOff ;
17301: CALL_OW 7
// end ; end ;
17305: GO 17133
17307: POP
17308: POP
// end ; end ; end_of_file
17309: PPOPN 2
17311: END
// every 0 0$01 do var timer , cratesSpawned ;
17312: GO 17314
17314: DISABLE
17315: LD_INT 0
17317: PPUSH
17318: PPUSH
// begin timer := 1 1$30 ;
17319: LD_ADDR_VAR 0 1
17323: PUSH
17324: LD_INT 3150
17326: ST_TO_ADDR
// repeat wait ( timer ) ;
17327: LD_VAR 0 1
17331: PPUSH
17332: CALL_OW 67
// if cratesSpawned >= 6 and cratesSpawned < 18 then
17336: LD_VAR 0 2
17340: PUSH
17341: LD_INT 6
17343: GREATEREQUAL
17344: PUSH
17345: LD_VAR 0 2
17349: PUSH
17350: LD_INT 18
17352: LESS
17353: AND
17354: IFFALSE 17370
// timer := timer + 0 0$3 ;
17356: LD_ADDR_VAR 0 1
17360: PUSH
17361: LD_VAR 0 1
17365: PUSH
17366: LD_INT 105
17368: PLUS
17369: ST_TO_ADDR
// if cratesSpawned >= 18 then
17370: LD_VAR 0 2
17374: PUSH
17375: LD_INT 18
17377: GREATEREQUAL
17378: IFFALSE 17394
// timer := timer + 0 0$9 ;
17380: LD_ADDR_VAR 0 1
17384: PUSH
17385: LD_VAR 0 1
17389: PUSH
17390: LD_INT 315
17392: PLUS
17393: ST_TO_ADDR
// if timer > 3 3$00 then
17394: LD_VAR 0 1
17398: PUSH
17399: LD_INT 6300
17401: GREATER
17402: IFFALSE 17412
// timer := 0 0$50 ;
17404: LD_ADDR_VAR 0 1
17408: PUSH
17409: LD_INT 1750
17411: ST_TO_ADDR
// CreateCratesArea ( rand ( 3 , 5 ) , CratesSpawnArea , true ) ;
17412: LD_INT 3
17414: PPUSH
17415: LD_INT 5
17417: PPUSH
17418: CALL_OW 12
17422: PPUSH
17423: LD_INT 15
17425: PPUSH
17426: LD_INT 1
17428: PPUSH
17429: CALL_OW 55
// cratesSpawned = cratesSpawned + 1 ;
17433: LD_ADDR_VAR 0 2
17437: PUSH
17438: LD_VAR 0 2
17442: PUSH
17443: LD_INT 1
17445: PLUS
17446: ST_TO_ADDR
// until false ;
17447: LD_INT 0
17449: IFFALSE 17327
// end ; end_of_file
17451: PPOPN 2
17453: END
// every 0 0$1 do
17454: GO 17456
17456: DISABLE
// begin enable ;
17457: ENABLE
// end ;
17458: END
// every 0 0$1 do var building , playerBuildings , playerBuildingsBType ;
17459: GO 17461
17461: DISABLE
17462: LD_INT 0
17464: PPUSH
17465: PPUSH
17466: PPUSH
// begin playerBuildings = FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_building ] , [ f_nation , nation_russian ] ] ) ;
17467: LD_ADDR_VAR 0 2
17471: PUSH
17472: LD_INT 22
17474: PUSH
17475: LD_INT 3
17477: PUSH
17478: EMPTY
17479: LIST
17480: LIST
17481: PUSH
17482: LD_INT 21
17484: PUSH
17485: LD_INT 3
17487: PUSH
17488: EMPTY
17489: LIST
17490: LIST
17491: PUSH
17492: LD_INT 23
17494: PUSH
17495: LD_INT 3
17497: PUSH
17498: EMPTY
17499: LIST
17500: LIST
17501: PUSH
17502: EMPTY
17503: LIST
17504: LIST
17505: LIST
17506: PPUSH
17507: CALL_OW 69
17511: ST_TO_ADDR
// playerBuildingsBType = [ ] ;
17512: LD_ADDR_VAR 0 3
17516: PUSH
17517: EMPTY
17518: ST_TO_ADDR
// for building in playerBuildings do
17519: LD_ADDR_VAR 0 1
17523: PUSH
17524: LD_VAR 0 2
17528: PUSH
17529: FOR_IN
17530: IFFALSE 17555
// playerBuildingsBType = playerBuildingsBType ^ GetBType ( building ) ;
17532: LD_ADDR_VAR 0 3
17536: PUSH
17537: LD_VAR 0 3
17541: PUSH
17542: LD_VAR 0 1
17546: PPUSH
17547: CALL_OW 266
17551: ADD
17552: ST_TO_ADDR
17553: GO 17529
17555: POP
17556: POP
// for building in allBuildings do
17557: LD_ADDR_VAR 0 1
17561: PUSH
17562: LD_EXP 13
17566: PUSH
17567: FOR_IN
17568: IFFALSE 17614
// if not building in playerBuildingsBType and not building in buildingsToBuild then
17570: LD_VAR 0 1
17574: PUSH
17575: LD_VAR 0 3
17579: IN
17580: NOT
17581: PUSH
17582: LD_VAR 0 1
17586: PUSH
17587: LD_EXP 8
17591: IN
17592: NOT
17593: AND
17594: IFFALSE 17612
// buildingsToBuild = buildingsToBuild ^ building ;
17596: LD_ADDR_EXP 8
17600: PUSH
17601: LD_EXP 8
17605: PUSH
17606: LD_VAR 0 1
17610: ADD
17611: ST_TO_ADDR
17612: GO 17567
17614: POP
17615: POP
// enable ;
17616: ENABLE
// end ;
17617: PPOPN 3
17619: END
// every 0 0$1 trigger legionOffertCountdown do
17620: LD_EXP 33
17624: IFFALSE 17644
17626: GO 17628
17628: DISABLE
// begin legionOffertTime = legionOffertTime - 0 0$01 ;
17629: LD_ADDR_EXP 34
17633: PUSH
17634: LD_EXP 34
17638: PUSH
17639: LD_INT 35
17641: MINUS
17642: ST_TO_ADDR
// enable ;
17643: ENABLE
// end ;
17644: END
// every 0 0$1 trigger KurtWaitingForFreeHeike do
17645: LD_EXP 23
17649: IFFALSE 17683
17651: GO 17653
17653: DISABLE
// begin timeToFreeHeike = timeToFreeHeike - 0 0$01 ;
17654: LD_ADDR_EXP 54
17658: PUSH
17659: LD_EXP 54
17663: PUSH
17664: LD_INT 35
17666: MINUS
17667: ST_TO_ADDR
// if timeToFreeHeike <= 0 0$00 then
17668: LD_EXP 54
17672: PUSH
17673: LD_INT 0
17675: LESSEQUAL
17676: IFFALSE 17682
// Dial_PlayerDontSendHeike ;
17678: CALL 11413 0 0
// enable ;
17682: ENABLE
// end ;
17683: END
// every 0 0$1 trigger KurtWaitingForBuildBarrack and GetSide ( KurtEng ) = 3 do
17684: LD_EXP 24
17688: PUSH
17689: LD_EXP 82
17693: PPUSH
17694: CALL_OW 255
17698: PUSH
17699: LD_INT 3
17701: EQUAL
17702: AND
17703: IFFALSE 17776
17705: GO 17707
17707: DISABLE
// begin timeToBuildArBarrack = timeToBuildArBarrack - 0 0$01 ;
17708: LD_ADDR_EXP 55
17712: PUSH
17713: LD_EXP 55
17717: PUSH
17718: LD_INT 35
17720: MINUS
17721: ST_TO_ADDR
// if timeToBuildArBarrack <= 0 0$00 then
17722: LD_EXP 55
17726: PUSH
17727: LD_INT 0
17729: LESSEQUAL
17730: IFFALSE 17775
// begin Dial_BetrayedKurt1 ;
17732: CALL 11465 0 0
// wait ( 2 2$0 ) ;
17736: LD_INT 4200
17738: PPUSH
17739: CALL_OW 67
// SetAttitude ( 3 , 8 , att_enemy , true ) ;
17743: LD_INT 3
17745: PPUSH
17746: LD_INT 8
17748: PPUSH
17749: LD_INT 2
17751: PPUSH
17752: LD_INT 1
17754: PPUSH
17755: CALL_OW 80
// KurtAttack = true ;
17759: LD_ADDR_EXP 25
17763: PUSH
17764: LD_INT 1
17766: ST_TO_ADDR
// KurtWaitingForBuildBarrack = false ;
17767: LD_ADDR_EXP 24
17771: PUSH
17772: LD_INT 0
17774: ST_TO_ADDR
// end ; enable ;
17775: ENABLE
// end ; end_of_file
17776: END
// export currentAmWave , currentArWave ; every 0 0$1 trigger americansAttack do var i ;
17777: LD_EXP 26
17781: IFFALSE 17927
17783: GO 17785
17785: DISABLE
17786: LD_INT 0
17788: PPUSH
// begin currentAmWave = 0 ;
17789: LD_ADDR_EXP 85
17793: PUSH
17794: LD_INT 0
17796: ST_TO_ADDR
// wait ( firstAttackDelay ) ;
17797: LD_EXP 49
17801: PPUSH
17802: CALL_OW 67
// for i := 1 to americansAttackWaves do
17806: LD_ADDR_VAR 0 1
17810: PUSH
17811: DOUBLE
17812: LD_INT 1
17814: DEC
17815: ST_TO_ADDR
17816: LD_EXP 48
17820: PUSH
17821: FOR_TO
17822: IFFALSE 17925
// begin SpawnAmAttackTeam ;
17824: CALL 3214 0 0
// currentAmWave = currentAmWave + 1 ;
17828: LD_ADDR_EXP 85
17832: PUSH
17833: LD_EXP 85
17837: PUSH
17838: LD_INT 1
17840: PLUS
17841: ST_TO_ADDR
// if currentAmWave = 1 then
17842: LD_EXP 85
17846: PUSH
17847: LD_INT 1
17849: EQUAL
17850: IFFALSE 17914
// begin if paidLegionOffert then
17852: LD_EXP 32
17856: IFFALSE 17895
// begin Say ( Burlak , DAmAttackStart-Bur-1 ) ;
17858: LD_EXP 57
17862: PPUSH
17863: LD_STRING DAmAttackStart-Bur-1
17865: PPUSH
17866: CALL_OW 88
// if IsOK ( Gleb ) then
17870: LD_EXP 60
17874: PPUSH
17875: CALL_OW 302
17879: IFFALSE 17893
// Say ( Gleb , DAmAttackStart-Glb-1 ) ;
17881: LD_EXP 60
17885: PPUSH
17886: LD_STRING DAmAttackStart-Glb-1
17888: PPUSH
17889: CALL_OW 88
// end else
17893: GO 17907
// Say ( Burlak , DAmAttackStart-Bur-2 ) ;
17895: LD_EXP 57
17899: PPUSH
17900: LD_STRING DAmAttackStart-Bur-2
17902: PPUSH
17903: CALL_OW 88
// ChangeMissionObjectives ( MEnemy ) ;
17907: LD_STRING MEnemy
17909: PPUSH
17910: CALL_OW 337
// end ; wait ( waveCooldown ) ;
17914: LD_EXP 50
17918: PPUSH
17919: CALL_OW 67
// end ;
17923: GO 17821
17925: POP
17926: POP
// end ;
17927: PPOPN 1
17929: END
// every 0 0$1 trigger currentAmWave = 1 do
17930: LD_EXP 85
17934: PUSH
17935: LD_INT 1
17937: EQUAL
17938: IFFALSE 18027
17940: GO 17942
17942: DISABLE
// Attack ( [ 0 , amAttackTeam , [ [ 115 , 42 ] , [ 51 , 67 ] ] , [ 0 , 0 , 0 , 1 , 1 , 1 , 0 , 0 , 1 , 0 ] ] ) ;
17943: LD_INT 0
17945: PUSH
17946: LD_EXP 78
17950: PUSH
17951: LD_INT 115
17953: PUSH
17954: LD_INT 42
17956: PUSH
17957: EMPTY
17958: LIST
17959: LIST
17960: PUSH
17961: LD_INT 51
17963: PUSH
17964: LD_INT 67
17966: PUSH
17967: EMPTY
17968: LIST
17969: LIST
17970: PUSH
17971: EMPTY
17972: LIST
17973: LIST
17974: PUSH
17975: LD_INT 0
17977: PUSH
17978: LD_INT 0
17980: PUSH
17981: LD_INT 0
17983: PUSH
17984: LD_INT 1
17986: PUSH
17987: LD_INT 1
17989: PUSH
17990: LD_INT 1
17992: PUSH
17993: LD_INT 0
17995: PUSH
17996: LD_INT 0
17998: PUSH
17999: LD_INT 1
18001: PUSH
18002: LD_INT 0
18004: PUSH
18005: EMPTY
18006: LIST
18007: LIST
18008: LIST
18009: LIST
18010: LIST
18011: LIST
18012: LIST
18013: LIST
18014: LIST
18015: LIST
18016: PUSH
18017: EMPTY
18018: LIST
18019: LIST
18020: LIST
18021: LIST
18022: PPUSH
18023: CALL 80891 0 1
18027: END
// every 0 0$1 trigger currentAmWave = 2 do
18028: LD_EXP 85
18032: PUSH
18033: LD_INT 2
18035: EQUAL
18036: IFFALSE 18125
18038: GO 18040
18040: DISABLE
// Attack ( [ 0 , amAttackTeam , [ [ 115 , 42 ] , [ 51 , 67 ] ] , [ 0 , 0 , 0 , 1 , 1 , 1 , 0 , 0 , 1 , 0 ] ] ) ;
18041: LD_INT 0
18043: PUSH
18044: LD_EXP 78
18048: PUSH
18049: LD_INT 115
18051: PUSH
18052: LD_INT 42
18054: PUSH
18055: EMPTY
18056: LIST
18057: LIST
18058: PUSH
18059: LD_INT 51
18061: PUSH
18062: LD_INT 67
18064: PUSH
18065: EMPTY
18066: LIST
18067: LIST
18068: PUSH
18069: EMPTY
18070: LIST
18071: LIST
18072: PUSH
18073: LD_INT 0
18075: PUSH
18076: LD_INT 0
18078: PUSH
18079: LD_INT 0
18081: PUSH
18082: LD_INT 1
18084: PUSH
18085: LD_INT 1
18087: PUSH
18088: LD_INT 1
18090: PUSH
18091: LD_INT 0
18093: PUSH
18094: LD_INT 0
18096: PUSH
18097: LD_INT 1
18099: PUSH
18100: LD_INT 0
18102: PUSH
18103: EMPTY
18104: LIST
18105: LIST
18106: LIST
18107: LIST
18108: LIST
18109: LIST
18110: LIST
18111: LIST
18112: LIST
18113: LIST
18114: PUSH
18115: EMPTY
18116: LIST
18117: LIST
18118: LIST
18119: LIST
18120: PPUSH
18121: CALL 80891 0 1
18125: END
// every 0 0$1 trigger currentAmWave = 3 do
18126: LD_EXP 85
18130: PUSH
18131: LD_INT 3
18133: EQUAL
18134: IFFALSE 18223
18136: GO 18138
18138: DISABLE
// Attack ( [ 0 , amAttackTeam , [ [ 115 , 42 ] , [ 51 , 67 ] ] , [ 0 , 0 , 0 , 1 , 1 , 1 , 0 , 0 , 1 , 0 ] ] ) ;
18139: LD_INT 0
18141: PUSH
18142: LD_EXP 78
18146: PUSH
18147: LD_INT 115
18149: PUSH
18150: LD_INT 42
18152: PUSH
18153: EMPTY
18154: LIST
18155: LIST
18156: PUSH
18157: LD_INT 51
18159: PUSH
18160: LD_INT 67
18162: PUSH
18163: EMPTY
18164: LIST
18165: LIST
18166: PUSH
18167: EMPTY
18168: LIST
18169: LIST
18170: PUSH
18171: LD_INT 0
18173: PUSH
18174: LD_INT 0
18176: PUSH
18177: LD_INT 0
18179: PUSH
18180: LD_INT 1
18182: PUSH
18183: LD_INT 1
18185: PUSH
18186: LD_INT 1
18188: PUSH
18189: LD_INT 0
18191: PUSH
18192: LD_INT 0
18194: PUSH
18195: LD_INT 1
18197: PUSH
18198: LD_INT 0
18200: PUSH
18201: EMPTY
18202: LIST
18203: LIST
18204: LIST
18205: LIST
18206: LIST
18207: LIST
18208: LIST
18209: LIST
18210: LIST
18211: LIST
18212: PUSH
18213: EMPTY
18214: LIST
18215: LIST
18216: LIST
18217: LIST
18218: PPUSH
18219: CALL 80891 0 1
18223: END
// every 0 0$1 trigger KurtAttack do var i ;
18224: LD_EXP 25
18228: IFFALSE 18349
18230: GO 18232
18232: DISABLE
18233: LD_INT 0
18235: PPUSH
// begin currentArWave = 0 ;
18236: LD_ADDR_EXP 86
18240: PUSH
18241: LD_INT 0
18243: ST_TO_ADDR
// wait ( firstAttackDelay ) ;
18244: LD_EXP 49
18248: PPUSH
18249: CALL_OW 67
// for i := 1 to KurtAttackWaves do
18253: LD_ADDR_VAR 0 1
18257: PUSH
18258: DOUBLE
18259: LD_INT 1
18261: DEC
18262: ST_TO_ADDR
18263: LD_EXP 47
18267: PUSH
18268: FOR_TO
18269: IFFALSE 18347
// begin if KurtAttack and IsOK ( Heike ) then
18271: LD_EXP 25
18275: PUSH
18276: LD_EXP 79
18280: PPUSH
18281: CALL_OW 302
18285: AND
18286: IFFALSE 18345
// begin SpawnArAttackTeam ;
18288: CALL 4359 0 0
// currentArWave = currentArWave + 1 ;
18292: LD_ADDR_EXP 86
18296: PUSH
18297: LD_EXP 86
18301: PUSH
18302: LD_INT 1
18304: PLUS
18305: ST_TO_ADDR
// if currentArWave = 2 then
18306: LD_EXP 86
18310: PUSH
18311: LD_INT 2
18313: EQUAL
18314: IFFALSE 18336
// begin SayRadio ( Kurt , DMercAttack-Kurt-1 ) ;
18316: LD_EXP 80
18320: PPUSH
18321: LD_STRING DMercAttack-Kurt-1
18323: PPUSH
18324: CALL_OW 94
// canSendHeike = true ;
18328: LD_ADDR_EXP 28
18332: PUSH
18333: LD_INT 1
18335: ST_TO_ADDR
// end ; wait ( waveCooldown ) ;
18336: LD_EXP 50
18340: PPUSH
18341: CALL_OW 67
// end ; end ;
18345: GO 18268
18347: POP
18348: POP
// end ;
18349: PPOPN 1
18351: END
// every 0 0$1 trigger currentArWave = 1 do
18352: LD_EXP 86
18356: PUSH
18357: LD_INT 1
18359: EQUAL
18360: IFFALSE 18449
18362: GO 18364
18364: DISABLE
// Attack ( [ 0 , arAttackTeam , [ [ 115 , 42 ] , [ 51 , 67 ] ] , [ 0 , 0 , 0 , 1 , 1 , 1 , 0 , 0 , 1 , 0 ] ] ) ;
18365: LD_INT 0
18367: PUSH
18368: LD_EXP 84
18372: PUSH
18373: LD_INT 115
18375: PUSH
18376: LD_INT 42
18378: PUSH
18379: EMPTY
18380: LIST
18381: LIST
18382: PUSH
18383: LD_INT 51
18385: PUSH
18386: LD_INT 67
18388: PUSH
18389: EMPTY
18390: LIST
18391: LIST
18392: PUSH
18393: EMPTY
18394: LIST
18395: LIST
18396: PUSH
18397: LD_INT 0
18399: PUSH
18400: LD_INT 0
18402: PUSH
18403: LD_INT 0
18405: PUSH
18406: LD_INT 1
18408: PUSH
18409: LD_INT 1
18411: PUSH
18412: LD_INT 1
18414: PUSH
18415: LD_INT 0
18417: PUSH
18418: LD_INT 0
18420: PUSH
18421: LD_INT 1
18423: PUSH
18424: LD_INT 0
18426: PUSH
18427: EMPTY
18428: LIST
18429: LIST
18430: LIST
18431: LIST
18432: LIST
18433: LIST
18434: LIST
18435: LIST
18436: LIST
18437: LIST
18438: PUSH
18439: EMPTY
18440: LIST
18441: LIST
18442: LIST
18443: LIST
18444: PPUSH
18445: CALL 80891 0 1
18449: END
// every 0 0$1 trigger currentArWave = 2 do
18450: LD_EXP 86
18454: PUSH
18455: LD_INT 2
18457: EQUAL
18458: IFFALSE 18547
18460: GO 18462
18462: DISABLE
// Attack ( [ 0 , arAttackTeam , [ [ 115 , 42 ] , [ 51 , 67 ] ] , [ 0 , 0 , 0 , 1 , 1 , 1 , 0 , 0 , 1 , 0 ] ] ) ;
18463: LD_INT 0
18465: PUSH
18466: LD_EXP 84
18470: PUSH
18471: LD_INT 115
18473: PUSH
18474: LD_INT 42
18476: PUSH
18477: EMPTY
18478: LIST
18479: LIST
18480: PUSH
18481: LD_INT 51
18483: PUSH
18484: LD_INT 67
18486: PUSH
18487: EMPTY
18488: LIST
18489: LIST
18490: PUSH
18491: EMPTY
18492: LIST
18493: LIST
18494: PUSH
18495: LD_INT 0
18497: PUSH
18498: LD_INT 0
18500: PUSH
18501: LD_INT 0
18503: PUSH
18504: LD_INT 1
18506: PUSH
18507: LD_INT 1
18509: PUSH
18510: LD_INT 1
18512: PUSH
18513: LD_INT 0
18515: PUSH
18516: LD_INT 0
18518: PUSH
18519: LD_INT 1
18521: PUSH
18522: LD_INT 0
18524: PUSH
18525: EMPTY
18526: LIST
18527: LIST
18528: LIST
18529: LIST
18530: LIST
18531: LIST
18532: LIST
18533: LIST
18534: LIST
18535: LIST
18536: PUSH
18537: EMPTY
18538: LIST
18539: LIST
18540: LIST
18541: LIST
18542: PPUSH
18543: CALL 80891 0 1
18547: END
// every 0 0$1 trigger currentArWave = 3 do
18548: LD_EXP 86
18552: PUSH
18553: LD_INT 3
18555: EQUAL
18556: IFFALSE 18645
18558: GO 18560
18560: DISABLE
// Attack ( [ 0 , arAttackTeam , [ [ 115 , 42 ] , [ 51 , 67 ] ] , [ 0 , 0 , 0 , 1 , 1 , 1 , 0 , 0 , 1 , 0 ] ] ) ;
18561: LD_INT 0
18563: PUSH
18564: LD_EXP 84
18568: PUSH
18569: LD_INT 115
18571: PUSH
18572: LD_INT 42
18574: PUSH
18575: EMPTY
18576: LIST
18577: LIST
18578: PUSH
18579: LD_INT 51
18581: PUSH
18582: LD_INT 67
18584: PUSH
18585: EMPTY
18586: LIST
18587: LIST
18588: PUSH
18589: EMPTY
18590: LIST
18591: LIST
18592: PUSH
18593: LD_INT 0
18595: PUSH
18596: LD_INT 0
18598: PUSH
18599: LD_INT 0
18601: PUSH
18602: LD_INT 1
18604: PUSH
18605: LD_INT 1
18607: PUSH
18608: LD_INT 1
18610: PUSH
18611: LD_INT 0
18613: PUSH
18614: LD_INT 0
18616: PUSH
18617: LD_INT 1
18619: PUSH
18620: LD_INT 0
18622: PUSH
18623: EMPTY
18624: LIST
18625: LIST
18626: LIST
18627: LIST
18628: LIST
18629: LIST
18630: LIST
18631: LIST
18632: LIST
18633: LIST
18634: PUSH
18635: EMPTY
18636: LIST
18637: LIST
18638: LIST
18639: LIST
18640: PPUSH
18641: CALL 80891 0 1
18645: END
// every 0 0$1 trigger currentArWave = 4 do
18646: LD_EXP 86
18650: PUSH
18651: LD_INT 4
18653: EQUAL
18654: IFFALSE 18743
18656: GO 18658
18658: DISABLE
// Attack ( [ 0 , arAttackTeam , [ [ 115 , 42 ] , [ 51 , 67 ] ] , [ 0 , 0 , 0 , 1 , 1 , 1 , 0 , 0 , 1 , 0 ] ] ) ;
18659: LD_INT 0
18661: PUSH
18662: LD_EXP 84
18666: PUSH
18667: LD_INT 115
18669: PUSH
18670: LD_INT 42
18672: PUSH
18673: EMPTY
18674: LIST
18675: LIST
18676: PUSH
18677: LD_INT 51
18679: PUSH
18680: LD_INT 67
18682: PUSH
18683: EMPTY
18684: LIST
18685: LIST
18686: PUSH
18687: EMPTY
18688: LIST
18689: LIST
18690: PUSH
18691: LD_INT 0
18693: PUSH
18694: LD_INT 0
18696: PUSH
18697: LD_INT 0
18699: PUSH
18700: LD_INT 1
18702: PUSH
18703: LD_INT 1
18705: PUSH
18706: LD_INT 1
18708: PUSH
18709: LD_INT 0
18711: PUSH
18712: LD_INT 0
18714: PUSH
18715: LD_INT 1
18717: PUSH
18718: LD_INT 0
18720: PUSH
18721: EMPTY
18722: LIST
18723: LIST
18724: LIST
18725: LIST
18726: LIST
18727: LIST
18728: LIST
18729: LIST
18730: LIST
18731: LIST
18732: PUSH
18733: EMPTY
18734: LIST
18735: LIST
18736: LIST
18737: LIST
18738: PPUSH
18739: CALL 80891 0 1
18743: END
// every 0 0$1 trigger currentArWave = 5 do
18744: LD_EXP 86
18748: PUSH
18749: LD_INT 5
18751: EQUAL
18752: IFFALSE 18841
18754: GO 18756
18756: DISABLE
// Attack ( [ 0 , arAttackTeam , [ [ 115 , 42 ] , [ 51 , 67 ] ] , [ 0 , 0 , 0 , 1 , 1 , 1 , 0 , 0 , 1 , 0 ] ] ) ; end_of_file
18757: LD_INT 0
18759: PUSH
18760: LD_EXP 84
18764: PUSH
18765: LD_INT 115
18767: PUSH
18768: LD_INT 42
18770: PUSH
18771: EMPTY
18772: LIST
18773: LIST
18774: PUSH
18775: LD_INT 51
18777: PUSH
18778: LD_INT 67
18780: PUSH
18781: EMPTY
18782: LIST
18783: LIST
18784: PUSH
18785: EMPTY
18786: LIST
18787: LIST
18788: PUSH
18789: LD_INT 0
18791: PUSH
18792: LD_INT 0
18794: PUSH
18795: LD_INT 0
18797: PUSH
18798: LD_INT 1
18800: PUSH
18801: LD_INT 1
18803: PUSH
18804: LD_INT 1
18806: PUSH
18807: LD_INT 0
18809: PUSH
18810: LD_INT 0
18812: PUSH
18813: LD_INT 1
18815: PUSH
18816: LD_INT 0
18818: PUSH
18819: EMPTY
18820: LIST
18821: LIST
18822: LIST
18823: LIST
18824: LIST
18825: LIST
18826: LIST
18827: LIST
18828: LIST
18829: LIST
18830: PUSH
18831: EMPTY
18832: LIST
18833: LIST
18834: LIST
18835: LIST
18836: PPUSH
18837: CALL 80891 0 1
18841: END
// every 0 0$1 do var arVehs , arVeh , nearPlayerUnit ;
18842: GO 18844
18844: DISABLE
18845: LD_INT 0
18847: PPUSH
18848: PPUSH
18849: PPUSH
// begin enable ;
18850: ENABLE
// arVehs = FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_vehicle ] , [ f_empty ] ] ) ;
18851: LD_ADDR_VAR 0 1
18855: PUSH
18856: LD_INT 22
18858: PUSH
18859: LD_INT 8
18861: PUSH
18862: EMPTY
18863: LIST
18864: LIST
18865: PUSH
18866: LD_INT 21
18868: PUSH
18869: LD_INT 2
18871: PUSH
18872: EMPTY
18873: LIST
18874: LIST
18875: PUSH
18876: LD_INT 58
18878: PUSH
18879: EMPTY
18880: LIST
18881: PUSH
18882: EMPTY
18883: LIST
18884: LIST
18885: LIST
18886: PPUSH
18887: CALL_OW 69
18891: ST_TO_ADDR
// if not arVehs or not GetAttitude ( 3 , 8 ) = att_enemy then
18892: LD_VAR 0 1
18896: NOT
18897: PUSH
18898: LD_INT 3
18900: PPUSH
18901: LD_INT 8
18903: PPUSH
18904: CALL_OW 81
18908: PUSH
18909: LD_INT 2
18911: EQUAL
18912: NOT
18913: OR
18914: IFFALSE 18918
// exit ;
18916: GO 19008
// for arVeh in arVehs do
18918: LD_ADDR_VAR 0 2
18922: PUSH
18923: LD_VAR 0 1
18927: PUSH
18928: FOR_IN
18929: IFFALSE 19006
// begin nearPlayerUnit = NearestUnitToUnit ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) , arVeh ) ;
18931: LD_ADDR_VAR 0 3
18935: PUSH
18936: LD_INT 22
18938: PUSH
18939: LD_INT 3
18941: PUSH
18942: EMPTY
18943: LIST
18944: LIST
18945: PUSH
18946: LD_INT 21
18948: PUSH
18949: LD_INT 1
18951: PUSH
18952: EMPTY
18953: LIST
18954: LIST
18955: PUSH
18956: EMPTY
18957: LIST
18958: LIST
18959: PPUSH
18960: CALL_OW 69
18964: PPUSH
18965: LD_VAR 0 2
18969: PPUSH
18970: CALL_OW 74
18974: ST_TO_ADDR
// if GetDistUnits ( nearPlayerUnit , arVeh ) <= 2 then
18975: LD_VAR 0 3
18979: PPUSH
18980: LD_VAR 0 2
18984: PPUSH
18985: CALL_OW 296
18989: PUSH
18990: LD_INT 2
18992: LESSEQUAL
18993: IFFALSE 19004
// ComSelfDestruction ( arVeh ) ;
18995: LD_VAR 0 2
18999: PPUSH
19000: CALL_OW 577
// end ;
19004: GO 18928
19006: POP
19007: POP
// end ;
19008: PPOPN 3
19010: END
// every 0 0$1 trigger forceStopKurtAttack do
19011: LD_EXP 27
19015: IFFALSE 19081
19017: GO 19019
19019: DISABLE
// begin KurtAttack = false ;
19020: LD_ADDR_EXP 25
19024: PUSH
19025: LD_INT 0
19027: ST_TO_ADDR
// allowExitFromMap = 4 ;
19028: LD_ADDR_EXP 18
19032: PUSH
19033: LD_INT 4
19035: ST_TO_ADDR
// SetAttitude ( 3 , 8 , att_friend , true ) ;
19036: LD_INT 3
19038: PPUSH
19039: LD_INT 8
19041: PPUSH
19042: LD_INT 1
19044: PPUSH
19045: LD_INT 1
19047: PPUSH
19048: CALL_OW 80
// arAttackTeam = [ ] ;
19052: LD_ADDR_EXP 84
19056: PUSH
19057: EMPTY
19058: ST_TO_ADDR
// ComMoveToArea ( FilterAllUnits ( [ f_side , 8 ] ) , KurtExitMapArea ) ;
19059: LD_INT 22
19061: PUSH
19062: LD_INT 8
19064: PUSH
19065: EMPTY
19066: LIST
19067: LIST
19068: PPUSH
19069: CALL_OW 69
19073: PPUSH
19074: LD_INT 11
19076: PPUSH
19077: CALL_OW 113
// end ; end_of_file end_of_file
19081: END
// every 0 0$01 do var timer , cratesSpawned ;
19082: GO 19084
19084: DISABLE
19085: LD_INT 0
19087: PPUSH
19088: PPUSH
// begin timer := 1 1$30 ;
19089: LD_ADDR_VAR 0 1
19093: PUSH
19094: LD_INT 3150
19096: ST_TO_ADDR
// repeat wait ( timer ) ;
19097: LD_VAR 0 1
19101: PPUSH
19102: CALL_OW 67
// if cratesSpawned >= 6 and cratesSpawned < 18 then
19106: LD_VAR 0 2
19110: PUSH
19111: LD_INT 6
19113: GREATEREQUAL
19114: PUSH
19115: LD_VAR 0 2
19119: PUSH
19120: LD_INT 18
19122: LESS
19123: AND
19124: IFFALSE 19140
// timer := timer + 0 0$3 ;
19126: LD_ADDR_VAR 0 1
19130: PUSH
19131: LD_VAR 0 1
19135: PUSH
19136: LD_INT 105
19138: PLUS
19139: ST_TO_ADDR
// if cratesSpawned >= 18 then
19140: LD_VAR 0 2
19144: PUSH
19145: LD_INT 18
19147: GREATEREQUAL
19148: IFFALSE 19164
// timer := timer + 0 0$9 ;
19150: LD_ADDR_VAR 0 1
19154: PUSH
19155: LD_VAR 0 1
19159: PUSH
19160: LD_INT 315
19162: PLUS
19163: ST_TO_ADDR
// if timer > 3 3$00 then
19164: LD_VAR 0 1
19168: PUSH
19169: LD_INT 6300
19171: GREATER
19172: IFFALSE 19182
// timer := 0 0$50 ;
19174: LD_ADDR_VAR 0 1
19178: PUSH
19179: LD_INT 1750
19181: ST_TO_ADDR
// CreateCratesArea ( rand ( 3 , 5 ) , CratesSpawnArea , true ) ;
19182: LD_INT 3
19184: PPUSH
19185: LD_INT 5
19187: PPUSH
19188: CALL_OW 12
19192: PPUSH
19193: LD_INT 15
19195: PPUSH
19196: LD_INT 1
19198: PPUSH
19199: CALL_OW 55
// cratesSpawned = cratesSpawned + 1 ;
19203: LD_ADDR_VAR 0 2
19207: PUSH
19208: LD_VAR 0 2
19212: PUSH
19213: LD_INT 1
19215: PLUS
19216: ST_TO_ADDR
// until false ;
19217: LD_INT 0
19219: IFFALSE 19097
// end ; end_of_file
19221: PPOPN 2
19223: END
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
19224: LD_INT 0
19226: PPUSH
19227: PPUSH
// if exist_mode then
19228: LD_VAR 0 2
19232: IFFALSE 19257
// unit := CreateCharacter ( prefix & ident ) else
19234: LD_ADDR_VAR 0 5
19238: PUSH
19239: LD_VAR 0 3
19243: PUSH
19244: LD_VAR 0 1
19248: STR
19249: PPUSH
19250: CALL_OW 34
19254: ST_TO_ADDR
19255: GO 19272
// unit := NewCharacter ( ident ) ;
19257: LD_ADDR_VAR 0 5
19261: PUSH
19262: LD_VAR 0 1
19266: PPUSH
19267: CALL_OW 25
19271: ST_TO_ADDR
// result := unit ;
19272: LD_ADDR_VAR 0 4
19276: PUSH
19277: LD_VAR 0 5
19281: ST_TO_ADDR
// end ;
19282: LD_VAR 0 4
19286: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
19287: LD_INT 0
19289: PPUSH
19290: PPUSH
// if not side or not nation then
19291: LD_VAR 0 1
19295: NOT
19296: PUSH
19297: LD_VAR 0 2
19301: NOT
19302: OR
19303: IFFALSE 19307
// exit ;
19305: GO 20075
// case nation of nation_american :
19307: LD_VAR 0 2
19311: PUSH
19312: LD_INT 1
19314: DOUBLE
19315: EQUAL
19316: IFTRUE 19320
19318: GO 19534
19320: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 86 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 , 82 , 83 , 84 , 85 , 86 ] ; nation_arabian :
19321: LD_ADDR_VAR 0 4
19325: PUSH
19326: LD_INT 35
19328: PUSH
19329: LD_INT 45
19331: PUSH
19332: LD_INT 46
19334: PUSH
19335: LD_INT 47
19337: PUSH
19338: LD_INT 82
19340: PUSH
19341: LD_INT 83
19343: PUSH
19344: LD_INT 84
19346: PUSH
19347: LD_INT 85
19349: PUSH
19350: LD_INT 86
19352: PUSH
19353: LD_INT 1
19355: PUSH
19356: LD_INT 2
19358: PUSH
19359: LD_INT 6
19361: PUSH
19362: LD_INT 15
19364: PUSH
19365: LD_INT 16
19367: PUSH
19368: LD_INT 7
19370: PUSH
19371: LD_INT 12
19373: PUSH
19374: LD_INT 13
19376: PUSH
19377: LD_INT 10
19379: PUSH
19380: LD_INT 14
19382: PUSH
19383: LD_INT 20
19385: PUSH
19386: LD_INT 21
19388: PUSH
19389: LD_INT 22
19391: PUSH
19392: LD_INT 25
19394: PUSH
19395: LD_INT 32
19397: PUSH
19398: LD_INT 27
19400: PUSH
19401: LD_INT 36
19403: PUSH
19404: LD_INT 69
19406: PUSH
19407: LD_INT 39
19409: PUSH
19410: LD_INT 34
19412: PUSH
19413: LD_INT 40
19415: PUSH
19416: LD_INT 48
19418: PUSH
19419: LD_INT 49
19421: PUSH
19422: LD_INT 50
19424: PUSH
19425: LD_INT 51
19427: PUSH
19428: LD_INT 52
19430: PUSH
19431: LD_INT 53
19433: PUSH
19434: LD_INT 54
19436: PUSH
19437: LD_INT 55
19439: PUSH
19440: LD_INT 56
19442: PUSH
19443: LD_INT 57
19445: PUSH
19446: LD_INT 58
19448: PUSH
19449: LD_INT 59
19451: PUSH
19452: LD_INT 60
19454: PUSH
19455: LD_INT 61
19457: PUSH
19458: LD_INT 62
19460: PUSH
19461: LD_INT 80
19463: PUSH
19464: LD_INT 82
19466: PUSH
19467: LD_INT 83
19469: PUSH
19470: LD_INT 84
19472: PUSH
19473: LD_INT 85
19475: PUSH
19476: LD_INT 86
19478: PUSH
19479: EMPTY
19480: LIST
19481: LIST
19482: LIST
19483: LIST
19484: LIST
19485: LIST
19486: LIST
19487: LIST
19488: LIST
19489: LIST
19490: LIST
19491: LIST
19492: LIST
19493: LIST
19494: LIST
19495: LIST
19496: LIST
19497: LIST
19498: LIST
19499: LIST
19500: LIST
19501: LIST
19502: LIST
19503: LIST
19504: LIST
19505: LIST
19506: LIST
19507: LIST
19508: LIST
19509: LIST
19510: LIST
19511: LIST
19512: LIST
19513: LIST
19514: LIST
19515: LIST
19516: LIST
19517: LIST
19518: LIST
19519: LIST
19520: LIST
19521: LIST
19522: LIST
19523: LIST
19524: LIST
19525: LIST
19526: LIST
19527: LIST
19528: LIST
19529: LIST
19530: LIST
19531: ST_TO_ADDR
19532: GO 19999
19534: LD_INT 2
19536: DOUBLE
19537: EQUAL
19538: IFTRUE 19542
19540: GO 19768
19542: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 87 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 , 82 , 83 , 84 , 85 , 87 , 88 ] ; nation_russian :
19543: LD_ADDR_VAR 0 4
19547: PUSH
19548: LD_INT 35
19550: PUSH
19551: LD_INT 45
19553: PUSH
19554: LD_INT 46
19556: PUSH
19557: LD_INT 47
19559: PUSH
19560: LD_INT 82
19562: PUSH
19563: LD_INT 83
19565: PUSH
19566: LD_INT 84
19568: PUSH
19569: LD_INT 85
19571: PUSH
19572: LD_INT 87
19574: PUSH
19575: LD_INT 70
19577: PUSH
19578: LD_INT 1
19580: PUSH
19581: LD_INT 11
19583: PUSH
19584: LD_INT 3
19586: PUSH
19587: LD_INT 4
19589: PUSH
19590: LD_INT 5
19592: PUSH
19593: LD_INT 6
19595: PUSH
19596: LD_INT 15
19598: PUSH
19599: LD_INT 18
19601: PUSH
19602: LD_INT 7
19604: PUSH
19605: LD_INT 17
19607: PUSH
19608: LD_INT 8
19610: PUSH
19611: LD_INT 20
19613: PUSH
19614: LD_INT 21
19616: PUSH
19617: LD_INT 22
19619: PUSH
19620: LD_INT 72
19622: PUSH
19623: LD_INT 26
19625: PUSH
19626: LD_INT 69
19628: PUSH
19629: LD_INT 39
19631: PUSH
19632: LD_INT 40
19634: PUSH
19635: LD_INT 41
19637: PUSH
19638: LD_INT 42
19640: PUSH
19641: LD_INT 43
19643: PUSH
19644: LD_INT 48
19646: PUSH
19647: LD_INT 49
19649: PUSH
19650: LD_INT 50
19652: PUSH
19653: LD_INT 51
19655: PUSH
19656: LD_INT 52
19658: PUSH
19659: LD_INT 53
19661: PUSH
19662: LD_INT 54
19664: PUSH
19665: LD_INT 55
19667: PUSH
19668: LD_INT 56
19670: PUSH
19671: LD_INT 60
19673: PUSH
19674: LD_INT 61
19676: PUSH
19677: LD_INT 62
19679: PUSH
19680: LD_INT 66
19682: PUSH
19683: LD_INT 67
19685: PUSH
19686: LD_INT 68
19688: PUSH
19689: LD_INT 81
19691: PUSH
19692: LD_INT 82
19694: PUSH
19695: LD_INT 83
19697: PUSH
19698: LD_INT 84
19700: PUSH
19701: LD_INT 85
19703: PUSH
19704: LD_INT 87
19706: PUSH
19707: LD_INT 88
19709: PUSH
19710: EMPTY
19711: LIST
19712: LIST
19713: LIST
19714: LIST
19715: LIST
19716: LIST
19717: LIST
19718: LIST
19719: LIST
19720: LIST
19721: LIST
19722: LIST
19723: LIST
19724: LIST
19725: LIST
19726: LIST
19727: LIST
19728: LIST
19729: LIST
19730: LIST
19731: LIST
19732: LIST
19733: LIST
19734: LIST
19735: LIST
19736: LIST
19737: LIST
19738: LIST
19739: LIST
19740: LIST
19741: LIST
19742: LIST
19743: LIST
19744: LIST
19745: LIST
19746: LIST
19747: LIST
19748: LIST
19749: LIST
19750: LIST
19751: LIST
19752: LIST
19753: LIST
19754: LIST
19755: LIST
19756: LIST
19757: LIST
19758: LIST
19759: LIST
19760: LIST
19761: LIST
19762: LIST
19763: LIST
19764: LIST
19765: ST_TO_ADDR
19766: GO 19999
19768: LD_INT 3
19770: DOUBLE
19771: EQUAL
19772: IFTRUE 19776
19774: GO 19998
19776: POP
// result := [ 46 , 47 , 1 , 2 , 82 , 83 , 84 , 85 , 86 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 , 82 , 83 , 84 , 85 , 86 ] ; end ;
19777: LD_ADDR_VAR 0 4
19781: PUSH
19782: LD_INT 46
19784: PUSH
19785: LD_INT 47
19787: PUSH
19788: LD_INT 1
19790: PUSH
19791: LD_INT 2
19793: PUSH
19794: LD_INT 82
19796: PUSH
19797: LD_INT 83
19799: PUSH
19800: LD_INT 84
19802: PUSH
19803: LD_INT 85
19805: PUSH
19806: LD_INT 86
19808: PUSH
19809: LD_INT 11
19811: PUSH
19812: LD_INT 9
19814: PUSH
19815: LD_INT 20
19817: PUSH
19818: LD_INT 19
19820: PUSH
19821: LD_INT 21
19823: PUSH
19824: LD_INT 24
19826: PUSH
19827: LD_INT 22
19829: PUSH
19830: LD_INT 25
19832: PUSH
19833: LD_INT 28
19835: PUSH
19836: LD_INT 29
19838: PUSH
19839: LD_INT 30
19841: PUSH
19842: LD_INT 31
19844: PUSH
19845: LD_INT 37
19847: PUSH
19848: LD_INT 38
19850: PUSH
19851: LD_INT 32
19853: PUSH
19854: LD_INT 27
19856: PUSH
19857: LD_INT 33
19859: PUSH
19860: LD_INT 69
19862: PUSH
19863: LD_INT 39
19865: PUSH
19866: LD_INT 34
19868: PUSH
19869: LD_INT 40
19871: PUSH
19872: LD_INT 71
19874: PUSH
19875: LD_INT 23
19877: PUSH
19878: LD_INT 44
19880: PUSH
19881: LD_INT 48
19883: PUSH
19884: LD_INT 49
19886: PUSH
19887: LD_INT 50
19889: PUSH
19890: LD_INT 51
19892: PUSH
19893: LD_INT 52
19895: PUSH
19896: LD_INT 53
19898: PUSH
19899: LD_INT 54
19901: PUSH
19902: LD_INT 55
19904: PUSH
19905: LD_INT 56
19907: PUSH
19908: LD_INT 57
19910: PUSH
19911: LD_INT 58
19913: PUSH
19914: LD_INT 59
19916: PUSH
19917: LD_INT 63
19919: PUSH
19920: LD_INT 64
19922: PUSH
19923: LD_INT 65
19925: PUSH
19926: LD_INT 82
19928: PUSH
19929: LD_INT 83
19931: PUSH
19932: LD_INT 84
19934: PUSH
19935: LD_INT 85
19937: PUSH
19938: LD_INT 86
19940: PUSH
19941: EMPTY
19942: LIST
19943: LIST
19944: LIST
19945: LIST
19946: LIST
19947: LIST
19948: LIST
19949: LIST
19950: LIST
19951: LIST
19952: LIST
19953: LIST
19954: LIST
19955: LIST
19956: LIST
19957: LIST
19958: LIST
19959: LIST
19960: LIST
19961: LIST
19962: LIST
19963: LIST
19964: LIST
19965: LIST
19966: LIST
19967: LIST
19968: LIST
19969: LIST
19970: LIST
19971: LIST
19972: LIST
19973: LIST
19974: LIST
19975: LIST
19976: LIST
19977: LIST
19978: LIST
19979: LIST
19980: LIST
19981: LIST
19982: LIST
19983: LIST
19984: LIST
19985: LIST
19986: LIST
19987: LIST
19988: LIST
19989: LIST
19990: LIST
19991: LIST
19992: LIST
19993: LIST
19994: LIST
19995: ST_TO_ADDR
19996: GO 19999
19998: POP
// if state > - 1 and state < 3 then
19999: LD_VAR 0 3
20003: PUSH
20004: LD_INT 1
20006: NEG
20007: GREATER
20008: PUSH
20009: LD_VAR 0 3
20013: PUSH
20014: LD_INT 3
20016: LESS
20017: AND
20018: IFFALSE 20075
// for i in result do
20020: LD_ADDR_VAR 0 5
20024: PUSH
20025: LD_VAR 0 4
20029: PUSH
20030: FOR_IN
20031: IFFALSE 20073
// if GetTech ( i , side ) <> state then
20033: LD_VAR 0 5
20037: PPUSH
20038: LD_VAR 0 1
20042: PPUSH
20043: CALL_OW 321
20047: PUSH
20048: LD_VAR 0 3
20052: NONEQUAL
20053: IFFALSE 20071
// result := result diff i ;
20055: LD_ADDR_VAR 0 4
20059: PUSH
20060: LD_VAR 0 4
20064: PUSH
20065: LD_VAR 0 5
20069: DIFF
20070: ST_TO_ADDR
20071: GO 20030
20073: POP
20074: POP
// end ;
20075: LD_VAR 0 4
20079: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
20080: LD_INT 0
20082: PPUSH
20083: PPUSH
20084: PPUSH
// result := true ;
20085: LD_ADDR_VAR 0 3
20089: PUSH
20090: LD_INT 1
20092: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
20093: LD_ADDR_VAR 0 5
20097: PUSH
20098: LD_VAR 0 2
20102: PPUSH
20103: CALL_OW 480
20107: ST_TO_ADDR
// if not tmp then
20108: LD_VAR 0 5
20112: NOT
20113: IFFALSE 20117
// exit ;
20115: GO 20166
// for i in tmp do
20117: LD_ADDR_VAR 0 4
20121: PUSH
20122: LD_VAR 0 5
20126: PUSH
20127: FOR_IN
20128: IFFALSE 20164
// if GetTech ( i , side ) <> state_researched then
20130: LD_VAR 0 4
20134: PPUSH
20135: LD_VAR 0 1
20139: PPUSH
20140: CALL_OW 321
20144: PUSH
20145: LD_INT 2
20147: NONEQUAL
20148: IFFALSE 20162
// begin result := false ;
20150: LD_ADDR_VAR 0 3
20154: PUSH
20155: LD_INT 0
20157: ST_TO_ADDR
// exit ;
20158: POP
20159: POP
20160: GO 20166
// end ;
20162: GO 20127
20164: POP
20165: POP
// end ;
20166: LD_VAR 0 3
20170: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
20171: LD_INT 0
20173: PPUSH
20174: PPUSH
20175: PPUSH
20176: PPUSH
20177: PPUSH
20178: PPUSH
20179: PPUSH
20180: PPUSH
20181: PPUSH
20182: PPUSH
20183: PPUSH
20184: PPUSH
20185: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
20186: LD_VAR 0 1
20190: NOT
20191: PUSH
20192: LD_VAR 0 1
20196: PPUSH
20197: CALL_OW 257
20201: PUSH
20202: LD_INT 9
20204: NONEQUAL
20205: OR
20206: IFFALSE 20210
// exit ;
20208: GO 20783
// side := GetSide ( unit ) ;
20210: LD_ADDR_VAR 0 9
20214: PUSH
20215: LD_VAR 0 1
20219: PPUSH
20220: CALL_OW 255
20224: ST_TO_ADDR
// tech_space := tech_spacanom ;
20225: LD_ADDR_VAR 0 12
20229: PUSH
20230: LD_INT 29
20232: ST_TO_ADDR
// tech_time := tech_taurad ;
20233: LD_ADDR_VAR 0 13
20237: PUSH
20238: LD_INT 28
20240: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
20241: LD_ADDR_VAR 0 11
20245: PUSH
20246: LD_VAR 0 1
20250: PPUSH
20251: CALL_OW 310
20255: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
20256: LD_VAR 0 11
20260: PPUSH
20261: CALL_OW 247
20265: PUSH
20266: LD_INT 2
20268: EQUAL
20269: IFFALSE 20273
// exit ;
20271: GO 20783
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
20273: LD_ADDR_VAR 0 8
20277: PUSH
20278: LD_INT 81
20280: PUSH
20281: LD_VAR 0 9
20285: PUSH
20286: EMPTY
20287: LIST
20288: LIST
20289: PUSH
20290: LD_INT 3
20292: PUSH
20293: LD_INT 21
20295: PUSH
20296: LD_INT 3
20298: PUSH
20299: EMPTY
20300: LIST
20301: LIST
20302: PUSH
20303: EMPTY
20304: LIST
20305: LIST
20306: PUSH
20307: EMPTY
20308: LIST
20309: LIST
20310: PPUSH
20311: CALL_OW 69
20315: ST_TO_ADDR
// if not tmp then
20316: LD_VAR 0 8
20320: NOT
20321: IFFALSE 20325
// exit ;
20323: GO 20783
// if in_unit then
20325: LD_VAR 0 11
20329: IFFALSE 20353
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
20331: LD_ADDR_VAR 0 10
20335: PUSH
20336: LD_VAR 0 8
20340: PPUSH
20341: LD_VAR 0 11
20345: PPUSH
20346: CALL_OW 74
20350: ST_TO_ADDR
20351: GO 20373
// enemy := NearestUnitToUnit ( tmp , unit ) ;
20353: LD_ADDR_VAR 0 10
20357: PUSH
20358: LD_VAR 0 8
20362: PPUSH
20363: LD_VAR 0 1
20367: PPUSH
20368: CALL_OW 74
20372: ST_TO_ADDR
// if not enemy then
20373: LD_VAR 0 10
20377: NOT
20378: IFFALSE 20382
// exit ;
20380: GO 20783
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
20382: LD_VAR 0 11
20386: PUSH
20387: LD_VAR 0 11
20391: PPUSH
20392: LD_VAR 0 10
20396: PPUSH
20397: CALL_OW 296
20401: PUSH
20402: LD_INT 13
20404: GREATER
20405: AND
20406: PUSH
20407: LD_VAR 0 1
20411: PPUSH
20412: LD_VAR 0 10
20416: PPUSH
20417: CALL_OW 296
20421: PUSH
20422: LD_INT 12
20424: GREATER
20425: OR
20426: IFFALSE 20430
// exit ;
20428: GO 20783
// missile := [ 1 ] ;
20430: LD_ADDR_VAR 0 14
20434: PUSH
20435: LD_INT 1
20437: PUSH
20438: EMPTY
20439: LIST
20440: ST_TO_ADDR
// if Researched ( side , tech_space ) then
20441: LD_VAR 0 9
20445: PPUSH
20446: LD_VAR 0 12
20450: PPUSH
20451: CALL_OW 325
20455: IFFALSE 20484
// missile := Replace ( missile , missile + 1 , 2 ) ;
20457: LD_ADDR_VAR 0 14
20461: PUSH
20462: LD_VAR 0 14
20466: PPUSH
20467: LD_VAR 0 14
20471: PUSH
20472: LD_INT 1
20474: PLUS
20475: PPUSH
20476: LD_INT 2
20478: PPUSH
20479: CALL_OW 1
20483: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
20484: LD_VAR 0 9
20488: PPUSH
20489: LD_VAR 0 13
20493: PPUSH
20494: CALL_OW 325
20498: PUSH
20499: LD_VAR 0 10
20503: PPUSH
20504: CALL_OW 255
20508: PPUSH
20509: LD_VAR 0 13
20513: PPUSH
20514: CALL_OW 325
20518: NOT
20519: AND
20520: IFFALSE 20549
// missile := Replace ( missile , missile + 1 , 3 ) ;
20522: LD_ADDR_VAR 0 14
20526: PUSH
20527: LD_VAR 0 14
20531: PPUSH
20532: LD_VAR 0 14
20536: PUSH
20537: LD_INT 1
20539: PLUS
20540: PPUSH
20541: LD_INT 3
20543: PPUSH
20544: CALL_OW 1
20548: ST_TO_ADDR
// if missile < 2 then
20549: LD_VAR 0 14
20553: PUSH
20554: LD_INT 2
20556: LESS
20557: IFFALSE 20561
// exit ;
20559: GO 20783
// x := GetX ( enemy ) ;
20561: LD_ADDR_VAR 0 4
20565: PUSH
20566: LD_VAR 0 10
20570: PPUSH
20571: CALL_OW 250
20575: ST_TO_ADDR
// y := GetY ( enemy ) ;
20576: LD_ADDR_VAR 0 5
20580: PUSH
20581: LD_VAR 0 10
20585: PPUSH
20586: CALL_OW 251
20590: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
20591: LD_ADDR_VAR 0 6
20595: PUSH
20596: LD_VAR 0 4
20600: PUSH
20601: LD_INT 1
20603: NEG
20604: PPUSH
20605: LD_INT 1
20607: PPUSH
20608: CALL_OW 12
20612: PLUS
20613: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
20614: LD_ADDR_VAR 0 7
20618: PUSH
20619: LD_VAR 0 5
20623: PUSH
20624: LD_INT 1
20626: NEG
20627: PPUSH
20628: LD_INT 1
20630: PPUSH
20631: CALL_OW 12
20635: PLUS
20636: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
20637: LD_VAR 0 6
20641: PPUSH
20642: LD_VAR 0 7
20646: PPUSH
20647: CALL_OW 488
20651: NOT
20652: IFFALSE 20674
// begin _x := x ;
20654: LD_ADDR_VAR 0 6
20658: PUSH
20659: LD_VAR 0 4
20663: ST_TO_ADDR
// _y := y ;
20664: LD_ADDR_VAR 0 7
20668: PUSH
20669: LD_VAR 0 5
20673: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
20674: LD_ADDR_VAR 0 3
20678: PUSH
20679: LD_INT 1
20681: PPUSH
20682: LD_VAR 0 14
20686: PPUSH
20687: CALL_OW 12
20691: ST_TO_ADDR
// case i of 1 :
20692: LD_VAR 0 3
20696: PUSH
20697: LD_INT 1
20699: DOUBLE
20700: EQUAL
20701: IFTRUE 20705
20703: GO 20722
20705: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
20706: LD_VAR 0 1
20710: PPUSH
20711: LD_VAR 0 10
20715: PPUSH
20716: CALL_OW 115
20720: GO 20783
20722: LD_INT 2
20724: DOUBLE
20725: EQUAL
20726: IFTRUE 20730
20728: GO 20752
20730: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
20731: LD_VAR 0 1
20735: PPUSH
20736: LD_VAR 0 6
20740: PPUSH
20741: LD_VAR 0 7
20745: PPUSH
20746: CALL_OW 153
20750: GO 20783
20752: LD_INT 3
20754: DOUBLE
20755: EQUAL
20756: IFTRUE 20760
20758: GO 20782
20760: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
20761: LD_VAR 0 1
20765: PPUSH
20766: LD_VAR 0 6
20770: PPUSH
20771: LD_VAR 0 7
20775: PPUSH
20776: CALL_OW 154
20780: GO 20783
20782: POP
// end ;
20783: LD_VAR 0 2
20787: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
20788: LD_INT 0
20790: PPUSH
20791: PPUSH
20792: PPUSH
20793: PPUSH
20794: PPUSH
20795: PPUSH
// if not unit or not building then
20796: LD_VAR 0 1
20800: NOT
20801: PUSH
20802: LD_VAR 0 2
20806: NOT
20807: OR
20808: IFFALSE 20812
// exit ;
20810: GO 20970
// x := GetX ( building ) ;
20812: LD_ADDR_VAR 0 5
20816: PUSH
20817: LD_VAR 0 2
20821: PPUSH
20822: CALL_OW 250
20826: ST_TO_ADDR
// y := GetY ( building ) ;
20827: LD_ADDR_VAR 0 6
20831: PUSH
20832: LD_VAR 0 2
20836: PPUSH
20837: CALL_OW 251
20841: ST_TO_ADDR
// for i = 0 to 5 do
20842: LD_ADDR_VAR 0 4
20846: PUSH
20847: DOUBLE
20848: LD_INT 0
20850: DEC
20851: ST_TO_ADDR
20852: LD_INT 5
20854: PUSH
20855: FOR_TO
20856: IFFALSE 20968
// begin _x := ShiftX ( x , i , 3 ) ;
20858: LD_ADDR_VAR 0 7
20862: PUSH
20863: LD_VAR 0 5
20867: PPUSH
20868: LD_VAR 0 4
20872: PPUSH
20873: LD_INT 3
20875: PPUSH
20876: CALL_OW 272
20880: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
20881: LD_ADDR_VAR 0 8
20885: PUSH
20886: LD_VAR 0 6
20890: PPUSH
20891: LD_VAR 0 4
20895: PPUSH
20896: LD_INT 3
20898: PPUSH
20899: CALL_OW 273
20903: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
20904: LD_VAR 0 7
20908: PPUSH
20909: LD_VAR 0 8
20913: PPUSH
20914: CALL_OW 488
20918: NOT
20919: IFFALSE 20923
// continue ;
20921: GO 20855
// if HexInfo ( _x , _y ) = 0 then
20923: LD_VAR 0 7
20927: PPUSH
20928: LD_VAR 0 8
20932: PPUSH
20933: CALL_OW 428
20937: PUSH
20938: LD_INT 0
20940: EQUAL
20941: IFFALSE 20966
// begin ComMoveXY ( unit , _x , _y ) ;
20943: LD_VAR 0 1
20947: PPUSH
20948: LD_VAR 0 7
20952: PPUSH
20953: LD_VAR 0 8
20957: PPUSH
20958: CALL_OW 111
// exit ;
20962: POP
20963: POP
20964: GO 20970
// end ; end ;
20966: GO 20855
20968: POP
20969: POP
// end ;
20970: LD_VAR 0 3
20974: RET
// export function ScanBase ( side , base_area ) ; begin
20975: LD_INT 0
20977: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
20978: LD_ADDR_VAR 0 3
20982: PUSH
20983: LD_VAR 0 2
20987: PPUSH
20988: LD_INT 81
20990: PUSH
20991: LD_VAR 0 1
20995: PUSH
20996: EMPTY
20997: LIST
20998: LIST
20999: PPUSH
21000: CALL_OW 70
21004: ST_TO_ADDR
// end ;
21005: LD_VAR 0 3
21009: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
21010: LD_INT 0
21012: PPUSH
21013: PPUSH
21014: PPUSH
21015: PPUSH
// result := false ;
21016: LD_ADDR_VAR 0 2
21020: PUSH
21021: LD_INT 0
21023: ST_TO_ADDR
// side := GetSide ( unit ) ;
21024: LD_ADDR_VAR 0 3
21028: PUSH
21029: LD_VAR 0 1
21033: PPUSH
21034: CALL_OW 255
21038: ST_TO_ADDR
// nat := GetNation ( unit ) ;
21039: LD_ADDR_VAR 0 4
21043: PUSH
21044: LD_VAR 0 1
21048: PPUSH
21049: CALL_OW 248
21053: ST_TO_ADDR
// case nat of 1 :
21054: LD_VAR 0 4
21058: PUSH
21059: LD_INT 1
21061: DOUBLE
21062: EQUAL
21063: IFTRUE 21067
21065: GO 21078
21067: POP
// tech := tech_lassight ; 2 :
21068: LD_ADDR_VAR 0 5
21072: PUSH
21073: LD_INT 12
21075: ST_TO_ADDR
21076: GO 21117
21078: LD_INT 2
21080: DOUBLE
21081: EQUAL
21082: IFTRUE 21086
21084: GO 21097
21086: POP
// tech := tech_mortar ; 3 :
21087: LD_ADDR_VAR 0 5
21091: PUSH
21092: LD_INT 41
21094: ST_TO_ADDR
21095: GO 21117
21097: LD_INT 3
21099: DOUBLE
21100: EQUAL
21101: IFTRUE 21105
21103: GO 21116
21105: POP
// tech := tech_bazooka ; end ;
21106: LD_ADDR_VAR 0 5
21110: PUSH
21111: LD_INT 44
21113: ST_TO_ADDR
21114: GO 21117
21116: POP
// if Researched ( side , tech ) then
21117: LD_VAR 0 3
21121: PPUSH
21122: LD_VAR 0 5
21126: PPUSH
21127: CALL_OW 325
21131: IFFALSE 21158
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
21133: LD_ADDR_VAR 0 2
21137: PUSH
21138: LD_INT 5
21140: PUSH
21141: LD_INT 8
21143: PUSH
21144: LD_INT 9
21146: PUSH
21147: EMPTY
21148: LIST
21149: LIST
21150: LIST
21151: PUSH
21152: LD_VAR 0 4
21156: ARRAY
21157: ST_TO_ADDR
// end ;
21158: LD_VAR 0 2
21162: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
21163: LD_INT 0
21165: PPUSH
21166: PPUSH
21167: PPUSH
// if not mines then
21168: LD_VAR 0 2
21172: NOT
21173: IFFALSE 21177
// exit ;
21175: GO 21321
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
21177: LD_ADDR_VAR 0 5
21181: PUSH
21182: LD_INT 81
21184: PUSH
21185: LD_VAR 0 1
21189: PUSH
21190: EMPTY
21191: LIST
21192: LIST
21193: PUSH
21194: LD_INT 3
21196: PUSH
21197: LD_INT 21
21199: PUSH
21200: LD_INT 3
21202: PUSH
21203: EMPTY
21204: LIST
21205: LIST
21206: PUSH
21207: EMPTY
21208: LIST
21209: LIST
21210: PUSH
21211: EMPTY
21212: LIST
21213: LIST
21214: PPUSH
21215: CALL_OW 69
21219: ST_TO_ADDR
// for i in mines do
21220: LD_ADDR_VAR 0 4
21224: PUSH
21225: LD_VAR 0 2
21229: PUSH
21230: FOR_IN
21231: IFFALSE 21319
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
21233: LD_VAR 0 4
21237: PUSH
21238: LD_INT 1
21240: ARRAY
21241: PPUSH
21242: LD_VAR 0 4
21246: PUSH
21247: LD_INT 2
21249: ARRAY
21250: PPUSH
21251: CALL_OW 458
21255: NOT
21256: IFFALSE 21260
// continue ;
21258: GO 21230
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
21260: LD_VAR 0 4
21264: PUSH
21265: LD_INT 1
21267: ARRAY
21268: PPUSH
21269: LD_VAR 0 4
21273: PUSH
21274: LD_INT 2
21276: ARRAY
21277: PPUSH
21278: CALL_OW 428
21282: PUSH
21283: LD_VAR 0 5
21287: IN
21288: IFFALSE 21317
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
21290: LD_VAR 0 4
21294: PUSH
21295: LD_INT 1
21297: ARRAY
21298: PPUSH
21299: LD_VAR 0 4
21303: PUSH
21304: LD_INT 2
21306: ARRAY
21307: PPUSH
21308: LD_VAR 0 1
21312: PPUSH
21313: CALL_OW 456
// end ;
21317: GO 21230
21319: POP
21320: POP
// end ;
21321: LD_VAR 0 3
21325: RET
// export function Count ( array ) ; var i ; begin
21326: LD_INT 0
21328: PPUSH
21329: PPUSH
// result := 0 ;
21330: LD_ADDR_VAR 0 2
21334: PUSH
21335: LD_INT 0
21337: ST_TO_ADDR
// for i in array do
21338: LD_ADDR_VAR 0 3
21342: PUSH
21343: LD_VAR 0 1
21347: PUSH
21348: FOR_IN
21349: IFFALSE 21373
// if i then
21351: LD_VAR 0 3
21355: IFFALSE 21371
// result := result + 1 ;
21357: LD_ADDR_VAR 0 2
21361: PUSH
21362: LD_VAR 0 2
21366: PUSH
21367: LD_INT 1
21369: PLUS
21370: ST_TO_ADDR
21371: GO 21348
21373: POP
21374: POP
// end ;
21375: LD_VAR 0 2
21379: RET
// export function IsEmpty ( building ) ; begin
21380: LD_INT 0
21382: PPUSH
// if not building then
21383: LD_VAR 0 1
21387: NOT
21388: IFFALSE 21392
// exit ;
21390: GO 21435
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
21392: LD_ADDR_VAR 0 2
21396: PUSH
21397: LD_VAR 0 1
21401: PUSH
21402: LD_INT 22
21404: PUSH
21405: LD_VAR 0 1
21409: PPUSH
21410: CALL_OW 255
21414: PUSH
21415: EMPTY
21416: LIST
21417: LIST
21418: PUSH
21419: LD_INT 58
21421: PUSH
21422: EMPTY
21423: LIST
21424: PUSH
21425: EMPTY
21426: LIST
21427: LIST
21428: PPUSH
21429: CALL_OW 69
21433: IN
21434: ST_TO_ADDR
// end ;
21435: LD_VAR 0 2
21439: RET
// export function IsNotFull ( building ) ; var places ; begin
21440: LD_INT 0
21442: PPUSH
21443: PPUSH
// if not building then
21444: LD_VAR 0 1
21448: NOT
21449: IFFALSE 21453
// exit ;
21451: GO 21624
// result := false ;
21453: LD_ADDR_VAR 0 2
21457: PUSH
21458: LD_INT 0
21460: ST_TO_ADDR
// places := 0 ;
21461: LD_ADDR_VAR 0 3
21465: PUSH
21466: LD_INT 0
21468: ST_TO_ADDR
// case GetBType ( building ) of b_depot , b_warehouse , b_lab , b_lab_half , b_lab_full , b_armoury , b_barracks , b_workshop , b_factory , b_fort :
21469: LD_VAR 0 1
21473: PPUSH
21474: CALL_OW 266
21478: PUSH
21479: LD_INT 0
21481: DOUBLE
21482: EQUAL
21483: IFTRUE 21541
21485: LD_INT 1
21487: DOUBLE
21488: EQUAL
21489: IFTRUE 21541
21491: LD_INT 6
21493: DOUBLE
21494: EQUAL
21495: IFTRUE 21541
21497: LD_INT 7
21499: DOUBLE
21500: EQUAL
21501: IFTRUE 21541
21503: LD_INT 8
21505: DOUBLE
21506: EQUAL
21507: IFTRUE 21541
21509: LD_INT 4
21511: DOUBLE
21512: EQUAL
21513: IFTRUE 21541
21515: LD_INT 5
21517: DOUBLE
21518: EQUAL
21519: IFTRUE 21541
21521: LD_INT 2
21523: DOUBLE
21524: EQUAL
21525: IFTRUE 21541
21527: LD_INT 3
21529: DOUBLE
21530: EQUAL
21531: IFTRUE 21541
21533: LD_INT 35
21535: DOUBLE
21536: EQUAL
21537: IFTRUE 21541
21539: GO 21552
21541: POP
// places := 6 ; b_bunker , b_breastwork :
21542: LD_ADDR_VAR 0 3
21546: PUSH
21547: LD_INT 6
21549: ST_TO_ADDR
21550: GO 21597
21552: LD_INT 32
21554: DOUBLE
21555: EQUAL
21556: IFTRUE 21566
21558: LD_INT 31
21560: DOUBLE
21561: EQUAL
21562: IFTRUE 21566
21564: GO 21577
21566: POP
// places := 1 ; b_control_tower :
21567: LD_ADDR_VAR 0 3
21571: PUSH
21572: LD_INT 1
21574: ST_TO_ADDR
21575: GO 21597
21577: LD_INT 36
21579: DOUBLE
21580: EQUAL
21581: IFTRUE 21585
21583: GO 21596
21585: POP
// places := 3 ; end ;
21586: LD_ADDR_VAR 0 3
21590: PUSH
21591: LD_INT 3
21593: ST_TO_ADDR
21594: GO 21597
21596: POP
// if places then
21597: LD_VAR 0 3
21601: IFFALSE 21624
// result := UnitsInside ( building ) < places ;
21603: LD_ADDR_VAR 0 2
21607: PUSH
21608: LD_VAR 0 1
21612: PPUSH
21613: CALL_OW 313
21617: PUSH
21618: LD_VAR 0 3
21622: LESS
21623: ST_TO_ADDR
// end ;
21624: LD_VAR 0 2
21628: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
21629: LD_INT 0
21631: PPUSH
21632: PPUSH
21633: PPUSH
21634: PPUSH
// tmp := [ ] ;
21635: LD_ADDR_VAR 0 3
21639: PUSH
21640: EMPTY
21641: ST_TO_ADDR
// list := [ ] ;
21642: LD_ADDR_VAR 0 5
21646: PUSH
21647: EMPTY
21648: ST_TO_ADDR
// for i = 16 to 25 do
21649: LD_ADDR_VAR 0 4
21653: PUSH
21654: DOUBLE
21655: LD_INT 16
21657: DEC
21658: ST_TO_ADDR
21659: LD_INT 25
21661: PUSH
21662: FOR_TO
21663: IFFALSE 21736
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
21665: LD_ADDR_VAR 0 3
21669: PUSH
21670: LD_VAR 0 3
21674: PUSH
21675: LD_INT 22
21677: PUSH
21678: LD_VAR 0 1
21682: PPUSH
21683: CALL_OW 255
21687: PUSH
21688: EMPTY
21689: LIST
21690: LIST
21691: PUSH
21692: LD_INT 91
21694: PUSH
21695: LD_VAR 0 1
21699: PUSH
21700: LD_INT 6
21702: PUSH
21703: EMPTY
21704: LIST
21705: LIST
21706: LIST
21707: PUSH
21708: LD_INT 30
21710: PUSH
21711: LD_VAR 0 4
21715: PUSH
21716: EMPTY
21717: LIST
21718: LIST
21719: PUSH
21720: EMPTY
21721: LIST
21722: LIST
21723: LIST
21724: PUSH
21725: EMPTY
21726: LIST
21727: PPUSH
21728: CALL_OW 69
21732: ADD
21733: ST_TO_ADDR
21734: GO 21662
21736: POP
21737: POP
// for i = 1 to tmp do
21738: LD_ADDR_VAR 0 4
21742: PUSH
21743: DOUBLE
21744: LD_INT 1
21746: DEC
21747: ST_TO_ADDR
21748: LD_VAR 0 3
21752: PUSH
21753: FOR_TO
21754: IFFALSE 21842
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
21756: LD_ADDR_VAR 0 5
21760: PUSH
21761: LD_VAR 0 5
21765: PUSH
21766: LD_VAR 0 3
21770: PUSH
21771: LD_VAR 0 4
21775: ARRAY
21776: PPUSH
21777: CALL_OW 266
21781: PUSH
21782: LD_VAR 0 3
21786: PUSH
21787: LD_VAR 0 4
21791: ARRAY
21792: PPUSH
21793: CALL_OW 250
21797: PUSH
21798: LD_VAR 0 3
21802: PUSH
21803: LD_VAR 0 4
21807: ARRAY
21808: PPUSH
21809: CALL_OW 251
21813: PUSH
21814: LD_VAR 0 3
21818: PUSH
21819: LD_VAR 0 4
21823: ARRAY
21824: PPUSH
21825: CALL_OW 254
21829: PUSH
21830: EMPTY
21831: LIST
21832: LIST
21833: LIST
21834: LIST
21835: PUSH
21836: EMPTY
21837: LIST
21838: ADD
21839: ST_TO_ADDR
21840: GO 21753
21842: POP
21843: POP
// result := list ;
21844: LD_ADDR_VAR 0 2
21848: PUSH
21849: LD_VAR 0 5
21853: ST_TO_ADDR
// end ;
21854: LD_VAR 0 2
21858: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
21859: LD_INT 0
21861: PPUSH
21862: PPUSH
21863: PPUSH
21864: PPUSH
21865: PPUSH
21866: PPUSH
21867: PPUSH
// if not factory then
21868: LD_VAR 0 1
21872: NOT
21873: IFFALSE 21877
// exit ;
21875: GO 22470
// if control = control_apeman then
21877: LD_VAR 0 4
21881: PUSH
21882: LD_INT 5
21884: EQUAL
21885: IFFALSE 21994
// begin tmp := UnitsInside ( factory ) ;
21887: LD_ADDR_VAR 0 8
21891: PUSH
21892: LD_VAR 0 1
21896: PPUSH
21897: CALL_OW 313
21901: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
21902: LD_VAR 0 8
21906: PPUSH
21907: LD_INT 25
21909: PUSH
21910: LD_INT 12
21912: PUSH
21913: EMPTY
21914: LIST
21915: LIST
21916: PPUSH
21917: CALL_OW 72
21921: NOT
21922: IFFALSE 21932
// control := control_manual ;
21924: LD_ADDR_VAR 0 4
21928: PUSH
21929: LD_INT 1
21931: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
21932: LD_ADDR_VAR 0 8
21936: PUSH
21937: LD_VAR 0 1
21941: PPUSH
21942: CALL 21629 0 1
21946: ST_TO_ADDR
// if tmp then
21947: LD_VAR 0 8
21951: IFFALSE 21994
// begin for i in tmp do
21953: LD_ADDR_VAR 0 7
21957: PUSH
21958: LD_VAR 0 8
21962: PUSH
21963: FOR_IN
21964: IFFALSE 21992
// if i [ 1 ] = b_ext_radio then
21966: LD_VAR 0 7
21970: PUSH
21971: LD_INT 1
21973: ARRAY
21974: PUSH
21975: LD_INT 22
21977: EQUAL
21978: IFFALSE 21990
// begin control := control_remote ;
21980: LD_ADDR_VAR 0 4
21984: PUSH
21985: LD_INT 2
21987: ST_TO_ADDR
// break ;
21988: GO 21992
// end ;
21990: GO 21963
21992: POP
21993: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
21994: LD_VAR 0 1
21998: PPUSH
21999: LD_VAR 0 2
22003: PPUSH
22004: LD_VAR 0 3
22008: PPUSH
22009: LD_VAR 0 4
22013: PPUSH
22014: LD_VAR 0 5
22018: PPUSH
22019: CALL_OW 448
22023: IFFALSE 22058
// begin result := [ chassis , engine , control , weapon ] ;
22025: LD_ADDR_VAR 0 6
22029: PUSH
22030: LD_VAR 0 2
22034: PUSH
22035: LD_VAR 0 3
22039: PUSH
22040: LD_VAR 0 4
22044: PUSH
22045: LD_VAR 0 5
22049: PUSH
22050: EMPTY
22051: LIST
22052: LIST
22053: LIST
22054: LIST
22055: ST_TO_ADDR
// exit ;
22056: GO 22470
// end ; _chassis := AvailableChassisList ( factory ) ;
22058: LD_ADDR_VAR 0 9
22062: PUSH
22063: LD_VAR 0 1
22067: PPUSH
22068: CALL_OW 475
22072: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
22073: LD_ADDR_VAR 0 11
22077: PUSH
22078: LD_VAR 0 1
22082: PPUSH
22083: CALL_OW 476
22087: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
22088: LD_ADDR_VAR 0 12
22092: PUSH
22093: LD_VAR 0 1
22097: PPUSH
22098: CALL_OW 477
22102: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
22103: LD_ADDR_VAR 0 10
22107: PUSH
22108: LD_VAR 0 1
22112: PPUSH
22113: CALL_OW 478
22117: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
22118: LD_VAR 0 9
22122: NOT
22123: PUSH
22124: LD_VAR 0 11
22128: NOT
22129: OR
22130: PUSH
22131: LD_VAR 0 12
22135: NOT
22136: OR
22137: PUSH
22138: LD_VAR 0 10
22142: NOT
22143: OR
22144: IFFALSE 22179
// begin result := [ chassis , engine , control , weapon ] ;
22146: LD_ADDR_VAR 0 6
22150: PUSH
22151: LD_VAR 0 2
22155: PUSH
22156: LD_VAR 0 3
22160: PUSH
22161: LD_VAR 0 4
22165: PUSH
22166: LD_VAR 0 5
22170: PUSH
22171: EMPTY
22172: LIST
22173: LIST
22174: LIST
22175: LIST
22176: ST_TO_ADDR
// exit ;
22177: GO 22470
// end ; if not chassis in _chassis then
22179: LD_VAR 0 2
22183: PUSH
22184: LD_VAR 0 9
22188: IN
22189: NOT
22190: IFFALSE 22216
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
22192: LD_ADDR_VAR 0 2
22196: PUSH
22197: LD_VAR 0 9
22201: PUSH
22202: LD_INT 1
22204: PPUSH
22205: LD_VAR 0 9
22209: PPUSH
22210: CALL_OW 12
22214: ARRAY
22215: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
22216: LD_VAR 0 2
22220: PPUSH
22221: LD_VAR 0 3
22225: PPUSH
22226: CALL 22475 0 2
22230: NOT
22231: IFFALSE 22290
// repeat engine := _engine [ 1 ] ;
22233: LD_ADDR_VAR 0 3
22237: PUSH
22238: LD_VAR 0 11
22242: PUSH
22243: LD_INT 1
22245: ARRAY
22246: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
22247: LD_ADDR_VAR 0 11
22251: PUSH
22252: LD_VAR 0 11
22256: PPUSH
22257: LD_INT 1
22259: PPUSH
22260: CALL_OW 3
22264: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
22265: LD_VAR 0 2
22269: PPUSH
22270: LD_VAR 0 3
22274: PPUSH
22275: CALL 22475 0 2
22279: PUSH
22280: LD_VAR 0 11
22284: PUSH
22285: EMPTY
22286: EQUAL
22287: OR
22288: IFFALSE 22233
// if not control in _control then
22290: LD_VAR 0 4
22294: PUSH
22295: LD_VAR 0 12
22299: IN
22300: NOT
22301: IFFALSE 22327
// control := _control [ rand ( 1 , _control ) ] ;
22303: LD_ADDR_VAR 0 4
22307: PUSH
22308: LD_VAR 0 12
22312: PUSH
22313: LD_INT 1
22315: PPUSH
22316: LD_VAR 0 12
22320: PPUSH
22321: CALL_OW 12
22325: ARRAY
22326: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
22327: LD_VAR 0 2
22331: PPUSH
22332: LD_VAR 0 5
22336: PPUSH
22337: CALL 22695 0 2
22341: NOT
22342: IFFALSE 22401
// repeat weapon := _weapon [ 1 ] ;
22344: LD_ADDR_VAR 0 5
22348: PUSH
22349: LD_VAR 0 10
22353: PUSH
22354: LD_INT 1
22356: ARRAY
22357: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
22358: LD_ADDR_VAR 0 10
22362: PUSH
22363: LD_VAR 0 10
22367: PPUSH
22368: LD_INT 1
22370: PPUSH
22371: CALL_OW 3
22375: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
22376: LD_VAR 0 2
22380: PPUSH
22381: LD_VAR 0 5
22385: PPUSH
22386: CALL 22695 0 2
22390: PUSH
22391: LD_VAR 0 10
22395: PUSH
22396: EMPTY
22397: EQUAL
22398: OR
22399: IFFALSE 22344
// result := [ ] ;
22401: LD_ADDR_VAR 0 6
22405: PUSH
22406: EMPTY
22407: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
22408: LD_VAR 0 1
22412: PPUSH
22413: LD_VAR 0 2
22417: PPUSH
22418: LD_VAR 0 3
22422: PPUSH
22423: LD_VAR 0 4
22427: PPUSH
22428: LD_VAR 0 5
22432: PPUSH
22433: CALL_OW 448
22437: IFFALSE 22470
// result := [ chassis , engine , control , weapon ] ;
22439: LD_ADDR_VAR 0 6
22443: PUSH
22444: LD_VAR 0 2
22448: PUSH
22449: LD_VAR 0 3
22453: PUSH
22454: LD_VAR 0 4
22458: PUSH
22459: LD_VAR 0 5
22463: PUSH
22464: EMPTY
22465: LIST
22466: LIST
22467: LIST
22468: LIST
22469: ST_TO_ADDR
// end ;
22470: LD_VAR 0 6
22474: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
22475: LD_INT 0
22477: PPUSH
// if not chassis or not engine then
22478: LD_VAR 0 1
22482: NOT
22483: PUSH
22484: LD_VAR 0 2
22488: NOT
22489: OR
22490: IFFALSE 22494
// exit ;
22492: GO 22690
// case engine of engine_solar :
22494: LD_VAR 0 2
22498: PUSH
22499: LD_INT 2
22501: DOUBLE
22502: EQUAL
22503: IFTRUE 22507
22505: GO 22545
22507: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
22508: LD_ADDR_VAR 0 3
22512: PUSH
22513: LD_INT 11
22515: PUSH
22516: LD_INT 12
22518: PUSH
22519: LD_INT 13
22521: PUSH
22522: LD_INT 14
22524: PUSH
22525: LD_INT 1
22527: PUSH
22528: LD_INT 2
22530: PUSH
22531: LD_INT 3
22533: PUSH
22534: EMPTY
22535: LIST
22536: LIST
22537: LIST
22538: LIST
22539: LIST
22540: LIST
22541: LIST
22542: ST_TO_ADDR
22543: GO 22674
22545: LD_INT 1
22547: DOUBLE
22548: EQUAL
22549: IFTRUE 22553
22551: GO 22615
22553: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
22554: LD_ADDR_VAR 0 3
22558: PUSH
22559: LD_INT 11
22561: PUSH
22562: LD_INT 12
22564: PUSH
22565: LD_INT 13
22567: PUSH
22568: LD_INT 14
22570: PUSH
22571: LD_INT 1
22573: PUSH
22574: LD_INT 2
22576: PUSH
22577: LD_INT 3
22579: PUSH
22580: LD_INT 4
22582: PUSH
22583: LD_INT 5
22585: PUSH
22586: LD_INT 21
22588: PUSH
22589: LD_INT 23
22591: PUSH
22592: LD_INT 22
22594: PUSH
22595: LD_INT 24
22597: PUSH
22598: EMPTY
22599: LIST
22600: LIST
22601: LIST
22602: LIST
22603: LIST
22604: LIST
22605: LIST
22606: LIST
22607: LIST
22608: LIST
22609: LIST
22610: LIST
22611: LIST
22612: ST_TO_ADDR
22613: GO 22674
22615: LD_INT 3
22617: DOUBLE
22618: EQUAL
22619: IFTRUE 22623
22621: GO 22673
22623: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
22624: LD_ADDR_VAR 0 3
22628: PUSH
22629: LD_INT 13
22631: PUSH
22632: LD_INT 14
22634: PUSH
22635: LD_INT 2
22637: PUSH
22638: LD_INT 3
22640: PUSH
22641: LD_INT 4
22643: PUSH
22644: LD_INT 5
22646: PUSH
22647: LD_INT 21
22649: PUSH
22650: LD_INT 22
22652: PUSH
22653: LD_INT 23
22655: PUSH
22656: LD_INT 24
22658: PUSH
22659: EMPTY
22660: LIST
22661: LIST
22662: LIST
22663: LIST
22664: LIST
22665: LIST
22666: LIST
22667: LIST
22668: LIST
22669: LIST
22670: ST_TO_ADDR
22671: GO 22674
22673: POP
// result := ( chassis in result ) ;
22674: LD_ADDR_VAR 0 3
22678: PUSH
22679: LD_VAR 0 1
22683: PUSH
22684: LD_VAR 0 3
22688: IN
22689: ST_TO_ADDR
// end ;
22690: LD_VAR 0 3
22694: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
22695: LD_INT 0
22697: PPUSH
// if not chassis or not weapon then
22698: LD_VAR 0 1
22702: NOT
22703: PUSH
22704: LD_VAR 0 2
22708: NOT
22709: OR
22710: IFFALSE 22714
// exit ;
22712: GO 23774
// case weapon of us_machine_gun :
22714: LD_VAR 0 2
22718: PUSH
22719: LD_INT 2
22721: DOUBLE
22722: EQUAL
22723: IFTRUE 22727
22725: GO 22757
22727: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
22728: LD_ADDR_VAR 0 3
22732: PUSH
22733: LD_INT 1
22735: PUSH
22736: LD_INT 2
22738: PUSH
22739: LD_INT 3
22741: PUSH
22742: LD_INT 4
22744: PUSH
22745: LD_INT 5
22747: PUSH
22748: EMPTY
22749: LIST
22750: LIST
22751: LIST
22752: LIST
22753: LIST
22754: ST_TO_ADDR
22755: GO 23758
22757: LD_INT 3
22759: DOUBLE
22760: EQUAL
22761: IFTRUE 22765
22763: GO 22795
22765: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
22766: LD_ADDR_VAR 0 3
22770: PUSH
22771: LD_INT 1
22773: PUSH
22774: LD_INT 2
22776: PUSH
22777: LD_INT 3
22779: PUSH
22780: LD_INT 4
22782: PUSH
22783: LD_INT 5
22785: PUSH
22786: EMPTY
22787: LIST
22788: LIST
22789: LIST
22790: LIST
22791: LIST
22792: ST_TO_ADDR
22793: GO 23758
22795: LD_INT 11
22797: DOUBLE
22798: EQUAL
22799: IFTRUE 22803
22801: GO 22833
22803: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
22804: LD_ADDR_VAR 0 3
22808: PUSH
22809: LD_INT 1
22811: PUSH
22812: LD_INT 2
22814: PUSH
22815: LD_INT 3
22817: PUSH
22818: LD_INT 4
22820: PUSH
22821: LD_INT 5
22823: PUSH
22824: EMPTY
22825: LIST
22826: LIST
22827: LIST
22828: LIST
22829: LIST
22830: ST_TO_ADDR
22831: GO 23758
22833: LD_INT 4
22835: DOUBLE
22836: EQUAL
22837: IFTRUE 22841
22839: GO 22867
22841: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
22842: LD_ADDR_VAR 0 3
22846: PUSH
22847: LD_INT 2
22849: PUSH
22850: LD_INT 3
22852: PUSH
22853: LD_INT 4
22855: PUSH
22856: LD_INT 5
22858: PUSH
22859: EMPTY
22860: LIST
22861: LIST
22862: LIST
22863: LIST
22864: ST_TO_ADDR
22865: GO 23758
22867: LD_INT 5
22869: DOUBLE
22870: EQUAL
22871: IFTRUE 22875
22873: GO 22901
22875: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
22876: LD_ADDR_VAR 0 3
22880: PUSH
22881: LD_INT 2
22883: PUSH
22884: LD_INT 3
22886: PUSH
22887: LD_INT 4
22889: PUSH
22890: LD_INT 5
22892: PUSH
22893: EMPTY
22894: LIST
22895: LIST
22896: LIST
22897: LIST
22898: ST_TO_ADDR
22899: GO 23758
22901: LD_INT 9
22903: DOUBLE
22904: EQUAL
22905: IFTRUE 22909
22907: GO 22935
22909: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
22910: LD_ADDR_VAR 0 3
22914: PUSH
22915: LD_INT 2
22917: PUSH
22918: LD_INT 3
22920: PUSH
22921: LD_INT 4
22923: PUSH
22924: LD_INT 5
22926: PUSH
22927: EMPTY
22928: LIST
22929: LIST
22930: LIST
22931: LIST
22932: ST_TO_ADDR
22933: GO 23758
22935: LD_INT 7
22937: DOUBLE
22938: EQUAL
22939: IFTRUE 22943
22941: GO 22969
22943: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
22944: LD_ADDR_VAR 0 3
22948: PUSH
22949: LD_INT 2
22951: PUSH
22952: LD_INT 3
22954: PUSH
22955: LD_INT 4
22957: PUSH
22958: LD_INT 5
22960: PUSH
22961: EMPTY
22962: LIST
22963: LIST
22964: LIST
22965: LIST
22966: ST_TO_ADDR
22967: GO 23758
22969: LD_INT 12
22971: DOUBLE
22972: EQUAL
22973: IFTRUE 22977
22975: GO 23003
22977: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
22978: LD_ADDR_VAR 0 3
22982: PUSH
22983: LD_INT 2
22985: PUSH
22986: LD_INT 3
22988: PUSH
22989: LD_INT 4
22991: PUSH
22992: LD_INT 5
22994: PUSH
22995: EMPTY
22996: LIST
22997: LIST
22998: LIST
22999: LIST
23000: ST_TO_ADDR
23001: GO 23758
23003: LD_INT 13
23005: DOUBLE
23006: EQUAL
23007: IFTRUE 23011
23009: GO 23037
23011: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
23012: LD_ADDR_VAR 0 3
23016: PUSH
23017: LD_INT 2
23019: PUSH
23020: LD_INT 3
23022: PUSH
23023: LD_INT 4
23025: PUSH
23026: LD_INT 5
23028: PUSH
23029: EMPTY
23030: LIST
23031: LIST
23032: LIST
23033: LIST
23034: ST_TO_ADDR
23035: GO 23758
23037: LD_INT 14
23039: DOUBLE
23040: EQUAL
23041: IFTRUE 23045
23043: GO 23063
23045: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
23046: LD_ADDR_VAR 0 3
23050: PUSH
23051: LD_INT 4
23053: PUSH
23054: LD_INT 5
23056: PUSH
23057: EMPTY
23058: LIST
23059: LIST
23060: ST_TO_ADDR
23061: GO 23758
23063: LD_INT 6
23065: DOUBLE
23066: EQUAL
23067: IFTRUE 23071
23069: GO 23089
23071: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
23072: LD_ADDR_VAR 0 3
23076: PUSH
23077: LD_INT 4
23079: PUSH
23080: LD_INT 5
23082: PUSH
23083: EMPTY
23084: LIST
23085: LIST
23086: ST_TO_ADDR
23087: GO 23758
23089: LD_INT 10
23091: DOUBLE
23092: EQUAL
23093: IFTRUE 23097
23095: GO 23115
23097: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
23098: LD_ADDR_VAR 0 3
23102: PUSH
23103: LD_INT 4
23105: PUSH
23106: LD_INT 5
23108: PUSH
23109: EMPTY
23110: LIST
23111: LIST
23112: ST_TO_ADDR
23113: GO 23758
23115: LD_INT 22
23117: DOUBLE
23118: EQUAL
23119: IFTRUE 23123
23121: GO 23149
23123: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
23124: LD_ADDR_VAR 0 3
23128: PUSH
23129: LD_INT 11
23131: PUSH
23132: LD_INT 12
23134: PUSH
23135: LD_INT 13
23137: PUSH
23138: LD_INT 14
23140: PUSH
23141: EMPTY
23142: LIST
23143: LIST
23144: LIST
23145: LIST
23146: ST_TO_ADDR
23147: GO 23758
23149: LD_INT 23
23151: DOUBLE
23152: EQUAL
23153: IFTRUE 23157
23155: GO 23183
23157: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
23158: LD_ADDR_VAR 0 3
23162: PUSH
23163: LD_INT 11
23165: PUSH
23166: LD_INT 12
23168: PUSH
23169: LD_INT 13
23171: PUSH
23172: LD_INT 14
23174: PUSH
23175: EMPTY
23176: LIST
23177: LIST
23178: LIST
23179: LIST
23180: ST_TO_ADDR
23181: GO 23758
23183: LD_INT 24
23185: DOUBLE
23186: EQUAL
23187: IFTRUE 23191
23189: GO 23217
23191: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
23192: LD_ADDR_VAR 0 3
23196: PUSH
23197: LD_INT 11
23199: PUSH
23200: LD_INT 12
23202: PUSH
23203: LD_INT 13
23205: PUSH
23206: LD_INT 14
23208: PUSH
23209: EMPTY
23210: LIST
23211: LIST
23212: LIST
23213: LIST
23214: ST_TO_ADDR
23215: GO 23758
23217: LD_INT 30
23219: DOUBLE
23220: EQUAL
23221: IFTRUE 23225
23223: GO 23251
23225: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
23226: LD_ADDR_VAR 0 3
23230: PUSH
23231: LD_INT 11
23233: PUSH
23234: LD_INT 12
23236: PUSH
23237: LD_INT 13
23239: PUSH
23240: LD_INT 14
23242: PUSH
23243: EMPTY
23244: LIST
23245: LIST
23246: LIST
23247: LIST
23248: ST_TO_ADDR
23249: GO 23758
23251: LD_INT 25
23253: DOUBLE
23254: EQUAL
23255: IFTRUE 23259
23257: GO 23277
23259: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
23260: LD_ADDR_VAR 0 3
23264: PUSH
23265: LD_INT 13
23267: PUSH
23268: LD_INT 14
23270: PUSH
23271: EMPTY
23272: LIST
23273: LIST
23274: ST_TO_ADDR
23275: GO 23758
23277: LD_INT 27
23279: DOUBLE
23280: EQUAL
23281: IFTRUE 23285
23283: GO 23303
23285: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_mortar :
23286: LD_ADDR_VAR 0 3
23290: PUSH
23291: LD_INT 13
23293: PUSH
23294: LD_INT 14
23296: PUSH
23297: EMPTY
23298: LIST
23299: LIST
23300: ST_TO_ADDR
23301: GO 23758
23303: LD_INT 92
23305: DOUBLE
23306: EQUAL
23307: IFTRUE 23311
23309: GO 23337
23311: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
23312: LD_ADDR_VAR 0 3
23316: PUSH
23317: LD_INT 11
23319: PUSH
23320: LD_INT 12
23322: PUSH
23323: LD_INT 13
23325: PUSH
23326: LD_INT 14
23328: PUSH
23329: EMPTY
23330: LIST
23331: LIST
23332: LIST
23333: LIST
23334: ST_TO_ADDR
23335: GO 23758
23337: LD_INT 28
23339: DOUBLE
23340: EQUAL
23341: IFTRUE 23345
23343: GO 23363
23345: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
23346: LD_ADDR_VAR 0 3
23350: PUSH
23351: LD_INT 13
23353: PUSH
23354: LD_INT 14
23356: PUSH
23357: EMPTY
23358: LIST
23359: LIST
23360: ST_TO_ADDR
23361: GO 23758
23363: LD_INT 29
23365: DOUBLE
23366: EQUAL
23367: IFTRUE 23371
23369: GO 23389
23371: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
23372: LD_ADDR_VAR 0 3
23376: PUSH
23377: LD_INT 13
23379: PUSH
23380: LD_INT 14
23382: PUSH
23383: EMPTY
23384: LIST
23385: LIST
23386: ST_TO_ADDR
23387: GO 23758
23389: LD_INT 31
23391: DOUBLE
23392: EQUAL
23393: IFTRUE 23397
23395: GO 23415
23397: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
23398: LD_ADDR_VAR 0 3
23402: PUSH
23403: LD_INT 13
23405: PUSH
23406: LD_INT 14
23408: PUSH
23409: EMPTY
23410: LIST
23411: LIST
23412: ST_TO_ADDR
23413: GO 23758
23415: LD_INT 26
23417: DOUBLE
23418: EQUAL
23419: IFTRUE 23423
23421: GO 23441
23423: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
23424: LD_ADDR_VAR 0 3
23428: PUSH
23429: LD_INT 13
23431: PUSH
23432: LD_INT 14
23434: PUSH
23435: EMPTY
23436: LIST
23437: LIST
23438: ST_TO_ADDR
23439: GO 23758
23441: LD_INT 42
23443: DOUBLE
23444: EQUAL
23445: IFTRUE 23449
23447: GO 23475
23449: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
23450: LD_ADDR_VAR 0 3
23454: PUSH
23455: LD_INT 21
23457: PUSH
23458: LD_INT 22
23460: PUSH
23461: LD_INT 23
23463: PUSH
23464: LD_INT 24
23466: PUSH
23467: EMPTY
23468: LIST
23469: LIST
23470: LIST
23471: LIST
23472: ST_TO_ADDR
23473: GO 23758
23475: LD_INT 43
23477: DOUBLE
23478: EQUAL
23479: IFTRUE 23483
23481: GO 23509
23483: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
23484: LD_ADDR_VAR 0 3
23488: PUSH
23489: LD_INT 21
23491: PUSH
23492: LD_INT 22
23494: PUSH
23495: LD_INT 23
23497: PUSH
23498: LD_INT 24
23500: PUSH
23501: EMPTY
23502: LIST
23503: LIST
23504: LIST
23505: LIST
23506: ST_TO_ADDR
23507: GO 23758
23509: LD_INT 44
23511: DOUBLE
23512: EQUAL
23513: IFTRUE 23517
23515: GO 23543
23517: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
23518: LD_ADDR_VAR 0 3
23522: PUSH
23523: LD_INT 21
23525: PUSH
23526: LD_INT 22
23528: PUSH
23529: LD_INT 23
23531: PUSH
23532: LD_INT 24
23534: PUSH
23535: EMPTY
23536: LIST
23537: LIST
23538: LIST
23539: LIST
23540: ST_TO_ADDR
23541: GO 23758
23543: LD_INT 45
23545: DOUBLE
23546: EQUAL
23547: IFTRUE 23551
23549: GO 23577
23551: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
23552: LD_ADDR_VAR 0 3
23556: PUSH
23557: LD_INT 21
23559: PUSH
23560: LD_INT 22
23562: PUSH
23563: LD_INT 23
23565: PUSH
23566: LD_INT 24
23568: PUSH
23569: EMPTY
23570: LIST
23571: LIST
23572: LIST
23573: LIST
23574: ST_TO_ADDR
23575: GO 23758
23577: LD_INT 49
23579: DOUBLE
23580: EQUAL
23581: IFTRUE 23585
23583: GO 23611
23585: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
23586: LD_ADDR_VAR 0 3
23590: PUSH
23591: LD_INT 21
23593: PUSH
23594: LD_INT 22
23596: PUSH
23597: LD_INT 23
23599: PUSH
23600: LD_INT 24
23602: PUSH
23603: EMPTY
23604: LIST
23605: LIST
23606: LIST
23607: LIST
23608: ST_TO_ADDR
23609: GO 23758
23611: LD_INT 51
23613: DOUBLE
23614: EQUAL
23615: IFTRUE 23619
23617: GO 23645
23619: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
23620: LD_ADDR_VAR 0 3
23624: PUSH
23625: LD_INT 21
23627: PUSH
23628: LD_INT 22
23630: PUSH
23631: LD_INT 23
23633: PUSH
23634: LD_INT 24
23636: PUSH
23637: EMPTY
23638: LIST
23639: LIST
23640: LIST
23641: LIST
23642: ST_TO_ADDR
23643: GO 23758
23645: LD_INT 52
23647: DOUBLE
23648: EQUAL
23649: IFTRUE 23653
23651: GO 23679
23653: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
23654: LD_ADDR_VAR 0 3
23658: PUSH
23659: LD_INT 21
23661: PUSH
23662: LD_INT 22
23664: PUSH
23665: LD_INT 23
23667: PUSH
23668: LD_INT 24
23670: PUSH
23671: EMPTY
23672: LIST
23673: LIST
23674: LIST
23675: LIST
23676: ST_TO_ADDR
23677: GO 23758
23679: LD_INT 53
23681: DOUBLE
23682: EQUAL
23683: IFTRUE 23687
23685: GO 23705
23687: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
23688: LD_ADDR_VAR 0 3
23692: PUSH
23693: LD_INT 23
23695: PUSH
23696: LD_INT 24
23698: PUSH
23699: EMPTY
23700: LIST
23701: LIST
23702: ST_TO_ADDR
23703: GO 23758
23705: LD_INT 46
23707: DOUBLE
23708: EQUAL
23709: IFTRUE 23713
23711: GO 23731
23713: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
23714: LD_ADDR_VAR 0 3
23718: PUSH
23719: LD_INT 23
23721: PUSH
23722: LD_INT 24
23724: PUSH
23725: EMPTY
23726: LIST
23727: LIST
23728: ST_TO_ADDR
23729: GO 23758
23731: LD_INT 47
23733: DOUBLE
23734: EQUAL
23735: IFTRUE 23739
23737: GO 23757
23739: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
23740: LD_ADDR_VAR 0 3
23744: PUSH
23745: LD_INT 23
23747: PUSH
23748: LD_INT 24
23750: PUSH
23751: EMPTY
23752: LIST
23753: LIST
23754: ST_TO_ADDR
23755: GO 23758
23757: POP
// result := ( chassis in result ) ;
23758: LD_ADDR_VAR 0 3
23762: PUSH
23763: LD_VAR 0 1
23767: PUSH
23768: LD_VAR 0 3
23772: IN
23773: ST_TO_ADDR
// end ;
23774: LD_VAR 0 3
23778: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
23779: LD_INT 0
23781: PPUSH
23782: PPUSH
23783: PPUSH
23784: PPUSH
23785: PPUSH
23786: PPUSH
23787: PPUSH
// result := array ;
23788: LD_ADDR_VAR 0 5
23792: PUSH
23793: LD_VAR 0 1
23797: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
23798: LD_VAR 0 1
23802: NOT
23803: PUSH
23804: LD_VAR 0 2
23808: NOT
23809: OR
23810: PUSH
23811: LD_VAR 0 3
23815: NOT
23816: OR
23817: PUSH
23818: LD_VAR 0 2
23822: PUSH
23823: LD_VAR 0 1
23827: GREATER
23828: OR
23829: PUSH
23830: LD_VAR 0 3
23834: PUSH
23835: LD_VAR 0 1
23839: GREATER
23840: OR
23841: IFFALSE 23845
// exit ;
23843: GO 24141
// if direction then
23845: LD_VAR 0 4
23849: IFFALSE 23913
// begin d := 1 ;
23851: LD_ADDR_VAR 0 9
23855: PUSH
23856: LD_INT 1
23858: ST_TO_ADDR
// if i_from > i_to then
23859: LD_VAR 0 2
23863: PUSH
23864: LD_VAR 0 3
23868: GREATER
23869: IFFALSE 23895
// length := ( array - i_from ) + i_to else
23871: LD_ADDR_VAR 0 11
23875: PUSH
23876: LD_VAR 0 1
23880: PUSH
23881: LD_VAR 0 2
23885: MINUS
23886: PUSH
23887: LD_VAR 0 3
23891: PLUS
23892: ST_TO_ADDR
23893: GO 23911
// length := i_to - i_from ;
23895: LD_ADDR_VAR 0 11
23899: PUSH
23900: LD_VAR 0 3
23904: PUSH
23905: LD_VAR 0 2
23909: MINUS
23910: ST_TO_ADDR
// end else
23911: GO 23974
// begin d := - 1 ;
23913: LD_ADDR_VAR 0 9
23917: PUSH
23918: LD_INT 1
23920: NEG
23921: ST_TO_ADDR
// if i_from > i_to then
23922: LD_VAR 0 2
23926: PUSH
23927: LD_VAR 0 3
23931: GREATER
23932: IFFALSE 23952
// length := i_from - i_to else
23934: LD_ADDR_VAR 0 11
23938: PUSH
23939: LD_VAR 0 2
23943: PUSH
23944: LD_VAR 0 3
23948: MINUS
23949: ST_TO_ADDR
23950: GO 23974
// length := ( array - i_to ) + i_from ;
23952: LD_ADDR_VAR 0 11
23956: PUSH
23957: LD_VAR 0 1
23961: PUSH
23962: LD_VAR 0 3
23966: MINUS
23967: PUSH
23968: LD_VAR 0 2
23972: PLUS
23973: ST_TO_ADDR
// end ; if not length then
23974: LD_VAR 0 11
23978: NOT
23979: IFFALSE 23983
// exit ;
23981: GO 24141
// tmp := array ;
23983: LD_ADDR_VAR 0 10
23987: PUSH
23988: LD_VAR 0 1
23992: ST_TO_ADDR
// for i = 1 to length do
23993: LD_ADDR_VAR 0 6
23997: PUSH
23998: DOUBLE
23999: LD_INT 1
24001: DEC
24002: ST_TO_ADDR
24003: LD_VAR 0 11
24007: PUSH
24008: FOR_TO
24009: IFFALSE 24129
// begin for j = 1 to array do
24011: LD_ADDR_VAR 0 7
24015: PUSH
24016: DOUBLE
24017: LD_INT 1
24019: DEC
24020: ST_TO_ADDR
24021: LD_VAR 0 1
24025: PUSH
24026: FOR_TO
24027: IFFALSE 24115
// begin k := j + d ;
24029: LD_ADDR_VAR 0 8
24033: PUSH
24034: LD_VAR 0 7
24038: PUSH
24039: LD_VAR 0 9
24043: PLUS
24044: ST_TO_ADDR
// if k > array then
24045: LD_VAR 0 8
24049: PUSH
24050: LD_VAR 0 1
24054: GREATER
24055: IFFALSE 24065
// k := 1 ;
24057: LD_ADDR_VAR 0 8
24061: PUSH
24062: LD_INT 1
24064: ST_TO_ADDR
// if not k then
24065: LD_VAR 0 8
24069: NOT
24070: IFFALSE 24082
// k := array ;
24072: LD_ADDR_VAR 0 8
24076: PUSH
24077: LD_VAR 0 1
24081: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
24082: LD_ADDR_VAR 0 10
24086: PUSH
24087: LD_VAR 0 10
24091: PPUSH
24092: LD_VAR 0 8
24096: PPUSH
24097: LD_VAR 0 1
24101: PUSH
24102: LD_VAR 0 7
24106: ARRAY
24107: PPUSH
24108: CALL_OW 1
24112: ST_TO_ADDR
// end ;
24113: GO 24026
24115: POP
24116: POP
// array := tmp ;
24117: LD_ADDR_VAR 0 1
24121: PUSH
24122: LD_VAR 0 10
24126: ST_TO_ADDR
// end ;
24127: GO 24008
24129: POP
24130: POP
// result := array ;
24131: LD_ADDR_VAR 0 5
24135: PUSH
24136: LD_VAR 0 1
24140: ST_TO_ADDR
// end ;
24141: LD_VAR 0 5
24145: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
24146: LD_INT 0
24148: PPUSH
24149: PPUSH
// result := 0 ;
24150: LD_ADDR_VAR 0 3
24154: PUSH
24155: LD_INT 0
24157: ST_TO_ADDR
// if not array or not value in array then
24158: LD_VAR 0 1
24162: NOT
24163: PUSH
24164: LD_VAR 0 2
24168: PUSH
24169: LD_VAR 0 1
24173: IN
24174: NOT
24175: OR
24176: IFFALSE 24180
// exit ;
24178: GO 24234
// for i = 1 to array do
24180: LD_ADDR_VAR 0 4
24184: PUSH
24185: DOUBLE
24186: LD_INT 1
24188: DEC
24189: ST_TO_ADDR
24190: LD_VAR 0 1
24194: PUSH
24195: FOR_TO
24196: IFFALSE 24232
// if value = array [ i ] then
24198: LD_VAR 0 2
24202: PUSH
24203: LD_VAR 0 1
24207: PUSH
24208: LD_VAR 0 4
24212: ARRAY
24213: EQUAL
24214: IFFALSE 24230
// begin result := i ;
24216: LD_ADDR_VAR 0 3
24220: PUSH
24221: LD_VAR 0 4
24225: ST_TO_ADDR
// exit ;
24226: POP
24227: POP
24228: GO 24234
// end ;
24230: GO 24195
24232: POP
24233: POP
// end ;
24234: LD_VAR 0 3
24238: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
24239: LD_INT 0
24241: PPUSH
// vc_chassis := chassis ;
24242: LD_ADDR_OWVAR 37
24246: PUSH
24247: LD_VAR 0 1
24251: ST_TO_ADDR
// vc_engine := engine ;
24252: LD_ADDR_OWVAR 39
24256: PUSH
24257: LD_VAR 0 2
24261: ST_TO_ADDR
// vc_control := control ;
24262: LD_ADDR_OWVAR 38
24266: PUSH
24267: LD_VAR 0 3
24271: ST_TO_ADDR
// vc_weapon := weapon ;
24272: LD_ADDR_OWVAR 40
24276: PUSH
24277: LD_VAR 0 4
24281: ST_TO_ADDR
// vc_fuel_battery := fuel ;
24282: LD_ADDR_OWVAR 41
24286: PUSH
24287: LD_VAR 0 5
24291: ST_TO_ADDR
// end ;
24292: LD_VAR 0 6
24296: RET
// export function WantPlant ( unit ) ; var task ; begin
24297: LD_INT 0
24299: PPUSH
24300: PPUSH
// result := false ;
24301: LD_ADDR_VAR 0 2
24305: PUSH
24306: LD_INT 0
24308: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
24309: LD_ADDR_VAR 0 3
24313: PUSH
24314: LD_VAR 0 1
24318: PPUSH
24319: CALL_OW 437
24323: ST_TO_ADDR
// if task then
24324: LD_VAR 0 3
24328: IFFALSE 24356
// if task [ 1 ] [ 1 ] = p then
24330: LD_VAR 0 3
24334: PUSH
24335: LD_INT 1
24337: ARRAY
24338: PUSH
24339: LD_INT 1
24341: ARRAY
24342: PUSH
24343: LD_STRING p
24345: EQUAL
24346: IFFALSE 24356
// result := true ;
24348: LD_ADDR_VAR 0 2
24352: PUSH
24353: LD_INT 1
24355: ST_TO_ADDR
// end ;
24356: LD_VAR 0 2
24360: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
24361: LD_INT 0
24363: PPUSH
24364: PPUSH
24365: PPUSH
24366: PPUSH
// if pos < 1 then
24367: LD_VAR 0 2
24371: PUSH
24372: LD_INT 1
24374: LESS
24375: IFFALSE 24379
// exit ;
24377: GO 24682
// if pos = 1 then
24379: LD_VAR 0 2
24383: PUSH
24384: LD_INT 1
24386: EQUAL
24387: IFFALSE 24420
// result := Replace ( arr , pos [ 1 ] , value ) else
24389: LD_ADDR_VAR 0 4
24393: PUSH
24394: LD_VAR 0 1
24398: PPUSH
24399: LD_VAR 0 2
24403: PUSH
24404: LD_INT 1
24406: ARRAY
24407: PPUSH
24408: LD_VAR 0 3
24412: PPUSH
24413: CALL_OW 1
24417: ST_TO_ADDR
24418: GO 24682
// begin tmp := arr ;
24420: LD_ADDR_VAR 0 6
24424: PUSH
24425: LD_VAR 0 1
24429: ST_TO_ADDR
// s_arr := [ tmp ] ;
24430: LD_ADDR_VAR 0 7
24434: PUSH
24435: LD_VAR 0 6
24439: PUSH
24440: EMPTY
24441: LIST
24442: ST_TO_ADDR
// for i = 1 to pos - 1 do
24443: LD_ADDR_VAR 0 5
24447: PUSH
24448: DOUBLE
24449: LD_INT 1
24451: DEC
24452: ST_TO_ADDR
24453: LD_VAR 0 2
24457: PUSH
24458: LD_INT 1
24460: MINUS
24461: PUSH
24462: FOR_TO
24463: IFFALSE 24508
// begin tmp := tmp [ pos [ i ] ] ;
24465: LD_ADDR_VAR 0 6
24469: PUSH
24470: LD_VAR 0 6
24474: PUSH
24475: LD_VAR 0 2
24479: PUSH
24480: LD_VAR 0 5
24484: ARRAY
24485: ARRAY
24486: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
24487: LD_ADDR_VAR 0 7
24491: PUSH
24492: LD_VAR 0 7
24496: PUSH
24497: LD_VAR 0 6
24501: PUSH
24502: EMPTY
24503: LIST
24504: ADD
24505: ST_TO_ADDR
// end ;
24506: GO 24462
24508: POP
24509: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
24510: LD_ADDR_VAR 0 6
24514: PUSH
24515: LD_VAR 0 6
24519: PPUSH
24520: LD_VAR 0 2
24524: PUSH
24525: LD_VAR 0 2
24529: ARRAY
24530: PPUSH
24531: LD_VAR 0 3
24535: PPUSH
24536: CALL_OW 1
24540: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
24541: LD_ADDR_VAR 0 7
24545: PUSH
24546: LD_VAR 0 7
24550: PPUSH
24551: LD_VAR 0 7
24555: PPUSH
24556: LD_VAR 0 6
24560: PPUSH
24561: CALL_OW 1
24565: ST_TO_ADDR
// for i = s_arr downto 2 do
24566: LD_ADDR_VAR 0 5
24570: PUSH
24571: DOUBLE
24572: LD_VAR 0 7
24576: INC
24577: ST_TO_ADDR
24578: LD_INT 2
24580: PUSH
24581: FOR_DOWNTO
24582: IFFALSE 24666
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
24584: LD_ADDR_VAR 0 6
24588: PUSH
24589: LD_VAR 0 7
24593: PUSH
24594: LD_VAR 0 5
24598: PUSH
24599: LD_INT 1
24601: MINUS
24602: ARRAY
24603: PPUSH
24604: LD_VAR 0 2
24608: PUSH
24609: LD_VAR 0 5
24613: PUSH
24614: LD_INT 1
24616: MINUS
24617: ARRAY
24618: PPUSH
24619: LD_VAR 0 7
24623: PUSH
24624: LD_VAR 0 5
24628: ARRAY
24629: PPUSH
24630: CALL_OW 1
24634: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
24635: LD_ADDR_VAR 0 7
24639: PUSH
24640: LD_VAR 0 7
24644: PPUSH
24645: LD_VAR 0 5
24649: PUSH
24650: LD_INT 1
24652: MINUS
24653: PPUSH
24654: LD_VAR 0 6
24658: PPUSH
24659: CALL_OW 1
24663: ST_TO_ADDR
// end ;
24664: GO 24581
24666: POP
24667: POP
// result := s_arr [ 1 ] ;
24668: LD_ADDR_VAR 0 4
24672: PUSH
24673: LD_VAR 0 7
24677: PUSH
24678: LD_INT 1
24680: ARRAY
24681: ST_TO_ADDR
// end ; end ;
24682: LD_VAR 0 4
24686: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
24687: LD_INT 0
24689: PPUSH
24690: PPUSH
// if not list then
24691: LD_VAR 0 1
24695: NOT
24696: IFFALSE 24700
// exit ;
24698: GO 24791
// i := list [ pos1 ] ;
24700: LD_ADDR_VAR 0 5
24704: PUSH
24705: LD_VAR 0 1
24709: PUSH
24710: LD_VAR 0 2
24714: ARRAY
24715: ST_TO_ADDR
// if not i then
24716: LD_VAR 0 5
24720: NOT
24721: IFFALSE 24725
// exit ;
24723: GO 24791
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
24725: LD_ADDR_VAR 0 1
24729: PUSH
24730: LD_VAR 0 1
24734: PPUSH
24735: LD_VAR 0 2
24739: PPUSH
24740: LD_VAR 0 1
24744: PUSH
24745: LD_VAR 0 3
24749: ARRAY
24750: PPUSH
24751: CALL_OW 1
24755: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
24756: LD_ADDR_VAR 0 1
24760: PUSH
24761: LD_VAR 0 1
24765: PPUSH
24766: LD_VAR 0 3
24770: PPUSH
24771: LD_VAR 0 5
24775: PPUSH
24776: CALL_OW 1
24780: ST_TO_ADDR
// result := list ;
24781: LD_ADDR_VAR 0 4
24785: PUSH
24786: LD_VAR 0 1
24790: ST_TO_ADDR
// end ;
24791: LD_VAR 0 4
24795: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
24796: LD_INT 0
24798: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
24799: LD_ADDR_VAR 0 5
24803: PUSH
24804: LD_VAR 0 1
24808: PPUSH
24809: CALL_OW 250
24813: PPUSH
24814: LD_VAR 0 1
24818: PPUSH
24819: CALL_OW 251
24823: PPUSH
24824: LD_VAR 0 2
24828: PPUSH
24829: LD_VAR 0 3
24833: PPUSH
24834: LD_VAR 0 4
24838: PPUSH
24839: CALL 24849 0 5
24843: ST_TO_ADDR
// end ;
24844: LD_VAR 0 5
24848: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
24849: LD_INT 0
24851: PPUSH
24852: PPUSH
24853: PPUSH
24854: PPUSH
// if not list then
24855: LD_VAR 0 3
24859: NOT
24860: IFFALSE 24864
// exit ;
24862: GO 25252
// result := [ ] ;
24864: LD_ADDR_VAR 0 6
24868: PUSH
24869: EMPTY
24870: ST_TO_ADDR
// for i in list do
24871: LD_ADDR_VAR 0 7
24875: PUSH
24876: LD_VAR 0 3
24880: PUSH
24881: FOR_IN
24882: IFFALSE 25084
// begin tmp := GetDistUnitXY ( i , x , y ) ;
24884: LD_ADDR_VAR 0 9
24888: PUSH
24889: LD_VAR 0 7
24893: PPUSH
24894: LD_VAR 0 1
24898: PPUSH
24899: LD_VAR 0 2
24903: PPUSH
24904: CALL_OW 297
24908: ST_TO_ADDR
// if not result then
24909: LD_VAR 0 6
24913: NOT
24914: IFFALSE 24940
// result := [ [ i , tmp ] ] else
24916: LD_ADDR_VAR 0 6
24920: PUSH
24921: LD_VAR 0 7
24925: PUSH
24926: LD_VAR 0 9
24930: PUSH
24931: EMPTY
24932: LIST
24933: LIST
24934: PUSH
24935: EMPTY
24936: LIST
24937: ST_TO_ADDR
24938: GO 25082
// begin if result [ result ] [ 2 ] < tmp then
24940: LD_VAR 0 6
24944: PUSH
24945: LD_VAR 0 6
24949: ARRAY
24950: PUSH
24951: LD_INT 2
24953: ARRAY
24954: PUSH
24955: LD_VAR 0 9
24959: LESS
24960: IFFALSE 25002
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
24962: LD_ADDR_VAR 0 6
24966: PUSH
24967: LD_VAR 0 6
24971: PPUSH
24972: LD_VAR 0 6
24976: PUSH
24977: LD_INT 1
24979: PLUS
24980: PPUSH
24981: LD_VAR 0 7
24985: PUSH
24986: LD_VAR 0 9
24990: PUSH
24991: EMPTY
24992: LIST
24993: LIST
24994: PPUSH
24995: CALL_OW 2
24999: ST_TO_ADDR
25000: GO 25082
// for j = 1 to result do
25002: LD_ADDR_VAR 0 8
25006: PUSH
25007: DOUBLE
25008: LD_INT 1
25010: DEC
25011: ST_TO_ADDR
25012: LD_VAR 0 6
25016: PUSH
25017: FOR_TO
25018: IFFALSE 25080
// begin if tmp < result [ j ] [ 2 ] then
25020: LD_VAR 0 9
25024: PUSH
25025: LD_VAR 0 6
25029: PUSH
25030: LD_VAR 0 8
25034: ARRAY
25035: PUSH
25036: LD_INT 2
25038: ARRAY
25039: LESS
25040: IFFALSE 25078
// begin result := Insert ( result , j , [ i , tmp ] ) ;
25042: LD_ADDR_VAR 0 6
25046: PUSH
25047: LD_VAR 0 6
25051: PPUSH
25052: LD_VAR 0 8
25056: PPUSH
25057: LD_VAR 0 7
25061: PUSH
25062: LD_VAR 0 9
25066: PUSH
25067: EMPTY
25068: LIST
25069: LIST
25070: PPUSH
25071: CALL_OW 2
25075: ST_TO_ADDR
// break ;
25076: GO 25080
// end ; end ;
25078: GO 25017
25080: POP
25081: POP
// end ; end ;
25082: GO 24881
25084: POP
25085: POP
// if result and not asc then
25086: LD_VAR 0 6
25090: PUSH
25091: LD_VAR 0 4
25095: NOT
25096: AND
25097: IFFALSE 25172
// begin tmp := result ;
25099: LD_ADDR_VAR 0 9
25103: PUSH
25104: LD_VAR 0 6
25108: ST_TO_ADDR
// for i = tmp downto 1 do
25109: LD_ADDR_VAR 0 7
25113: PUSH
25114: DOUBLE
25115: LD_VAR 0 9
25119: INC
25120: ST_TO_ADDR
25121: LD_INT 1
25123: PUSH
25124: FOR_DOWNTO
25125: IFFALSE 25170
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
25127: LD_ADDR_VAR 0 6
25131: PUSH
25132: LD_VAR 0 6
25136: PPUSH
25137: LD_VAR 0 9
25141: PUSH
25142: LD_VAR 0 7
25146: MINUS
25147: PUSH
25148: LD_INT 1
25150: PLUS
25151: PPUSH
25152: LD_VAR 0 9
25156: PUSH
25157: LD_VAR 0 7
25161: ARRAY
25162: PPUSH
25163: CALL_OW 1
25167: ST_TO_ADDR
25168: GO 25124
25170: POP
25171: POP
// end ; tmp := [ ] ;
25172: LD_ADDR_VAR 0 9
25176: PUSH
25177: EMPTY
25178: ST_TO_ADDR
// if mode then
25179: LD_VAR 0 5
25183: IFFALSE 25252
// begin for i = 1 to result do
25185: LD_ADDR_VAR 0 7
25189: PUSH
25190: DOUBLE
25191: LD_INT 1
25193: DEC
25194: ST_TO_ADDR
25195: LD_VAR 0 6
25199: PUSH
25200: FOR_TO
25201: IFFALSE 25240
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
25203: LD_ADDR_VAR 0 9
25207: PUSH
25208: LD_VAR 0 9
25212: PPUSH
25213: LD_VAR 0 7
25217: PPUSH
25218: LD_VAR 0 6
25222: PUSH
25223: LD_VAR 0 7
25227: ARRAY
25228: PUSH
25229: LD_INT 1
25231: ARRAY
25232: PPUSH
25233: CALL_OW 1
25237: ST_TO_ADDR
25238: GO 25200
25240: POP
25241: POP
// result := tmp ;
25242: LD_ADDR_VAR 0 6
25246: PUSH
25247: LD_VAR 0 9
25251: ST_TO_ADDR
// end ; end ;
25252: LD_VAR 0 6
25256: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
25257: LD_INT 0
25259: PPUSH
25260: PPUSH
25261: PPUSH
25262: PPUSH
25263: PPUSH
25264: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
25265: LD_ADDR_VAR 0 5
25269: PUSH
25270: LD_INT 0
25272: PUSH
25273: LD_INT 0
25275: PUSH
25276: LD_INT 0
25278: PUSH
25279: EMPTY
25280: PUSH
25281: EMPTY
25282: LIST
25283: LIST
25284: LIST
25285: LIST
25286: ST_TO_ADDR
// if not x or not y then
25287: LD_VAR 0 2
25291: NOT
25292: PUSH
25293: LD_VAR 0 3
25297: NOT
25298: OR
25299: IFFALSE 25303
// exit ;
25301: GO 26953
// if not range then
25303: LD_VAR 0 4
25307: NOT
25308: IFFALSE 25318
// range := 10 ;
25310: LD_ADDR_VAR 0 4
25314: PUSH
25315: LD_INT 10
25317: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
25318: LD_ADDR_VAR 0 8
25322: PUSH
25323: LD_INT 81
25325: PUSH
25326: LD_VAR 0 1
25330: PUSH
25331: EMPTY
25332: LIST
25333: LIST
25334: PUSH
25335: LD_INT 92
25337: PUSH
25338: LD_VAR 0 2
25342: PUSH
25343: LD_VAR 0 3
25347: PUSH
25348: LD_VAR 0 4
25352: PUSH
25353: EMPTY
25354: LIST
25355: LIST
25356: LIST
25357: LIST
25358: PUSH
25359: LD_INT 3
25361: PUSH
25362: LD_INT 21
25364: PUSH
25365: LD_INT 3
25367: PUSH
25368: EMPTY
25369: LIST
25370: LIST
25371: PUSH
25372: EMPTY
25373: LIST
25374: LIST
25375: PUSH
25376: EMPTY
25377: LIST
25378: LIST
25379: LIST
25380: PPUSH
25381: CALL_OW 69
25385: ST_TO_ADDR
// if not tmp then
25386: LD_VAR 0 8
25390: NOT
25391: IFFALSE 25395
// exit ;
25393: GO 26953
// for i in tmp do
25395: LD_ADDR_VAR 0 6
25399: PUSH
25400: LD_VAR 0 8
25404: PUSH
25405: FOR_IN
25406: IFFALSE 26928
// begin points := [ 0 , 0 , 0 ] ;
25408: LD_ADDR_VAR 0 9
25412: PUSH
25413: LD_INT 0
25415: PUSH
25416: LD_INT 0
25418: PUSH
25419: LD_INT 0
25421: PUSH
25422: EMPTY
25423: LIST
25424: LIST
25425: LIST
25426: ST_TO_ADDR
// bpoints := 1 ;
25427: LD_ADDR_VAR 0 10
25431: PUSH
25432: LD_INT 1
25434: ST_TO_ADDR
// case GetType ( i ) of unit_human :
25435: LD_VAR 0 6
25439: PPUSH
25440: CALL_OW 247
25444: PUSH
25445: LD_INT 1
25447: DOUBLE
25448: EQUAL
25449: IFTRUE 25453
25451: GO 26031
25453: POP
// begin if GetClass ( i ) = 1 then
25454: LD_VAR 0 6
25458: PPUSH
25459: CALL_OW 257
25463: PUSH
25464: LD_INT 1
25466: EQUAL
25467: IFFALSE 25488
// points := [ 10 , 5 , 3 ] ;
25469: LD_ADDR_VAR 0 9
25473: PUSH
25474: LD_INT 10
25476: PUSH
25477: LD_INT 5
25479: PUSH
25480: LD_INT 3
25482: PUSH
25483: EMPTY
25484: LIST
25485: LIST
25486: LIST
25487: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
25488: LD_VAR 0 6
25492: PPUSH
25493: CALL_OW 257
25497: PUSH
25498: LD_INT 2
25500: PUSH
25501: LD_INT 3
25503: PUSH
25504: LD_INT 4
25506: PUSH
25507: EMPTY
25508: LIST
25509: LIST
25510: LIST
25511: IN
25512: IFFALSE 25533
// points := [ 3 , 2 , 1 ] ;
25514: LD_ADDR_VAR 0 9
25518: PUSH
25519: LD_INT 3
25521: PUSH
25522: LD_INT 2
25524: PUSH
25525: LD_INT 1
25527: PUSH
25528: EMPTY
25529: LIST
25530: LIST
25531: LIST
25532: ST_TO_ADDR
// if GetClass ( i ) = 5 then
25533: LD_VAR 0 6
25537: PPUSH
25538: CALL_OW 257
25542: PUSH
25543: LD_INT 5
25545: EQUAL
25546: IFFALSE 25567
// points := [ 130 , 5 , 2 ] ;
25548: LD_ADDR_VAR 0 9
25552: PUSH
25553: LD_INT 130
25555: PUSH
25556: LD_INT 5
25558: PUSH
25559: LD_INT 2
25561: PUSH
25562: EMPTY
25563: LIST
25564: LIST
25565: LIST
25566: ST_TO_ADDR
// if GetClass ( i ) = 8 then
25567: LD_VAR 0 6
25571: PPUSH
25572: CALL_OW 257
25576: PUSH
25577: LD_INT 8
25579: EQUAL
25580: IFFALSE 25601
// points := [ 35 , 35 , 30 ] ;
25582: LD_ADDR_VAR 0 9
25586: PUSH
25587: LD_INT 35
25589: PUSH
25590: LD_INT 35
25592: PUSH
25593: LD_INT 30
25595: PUSH
25596: EMPTY
25597: LIST
25598: LIST
25599: LIST
25600: ST_TO_ADDR
// if GetClass ( i ) = 9 then
25601: LD_VAR 0 6
25605: PPUSH
25606: CALL_OW 257
25610: PUSH
25611: LD_INT 9
25613: EQUAL
25614: IFFALSE 25635
// points := [ 20 , 55 , 40 ] ;
25616: LD_ADDR_VAR 0 9
25620: PUSH
25621: LD_INT 20
25623: PUSH
25624: LD_INT 55
25626: PUSH
25627: LD_INT 40
25629: PUSH
25630: EMPTY
25631: LIST
25632: LIST
25633: LIST
25634: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
25635: LD_VAR 0 6
25639: PPUSH
25640: CALL_OW 257
25644: PUSH
25645: LD_INT 12
25647: PUSH
25648: LD_INT 16
25650: PUSH
25651: EMPTY
25652: LIST
25653: LIST
25654: IN
25655: IFFALSE 25676
// points := [ 5 , 3 , 2 ] ;
25657: LD_ADDR_VAR 0 9
25661: PUSH
25662: LD_INT 5
25664: PUSH
25665: LD_INT 3
25667: PUSH
25668: LD_INT 2
25670: PUSH
25671: EMPTY
25672: LIST
25673: LIST
25674: LIST
25675: ST_TO_ADDR
// if GetClass ( i ) = 17 then
25676: LD_VAR 0 6
25680: PPUSH
25681: CALL_OW 257
25685: PUSH
25686: LD_INT 17
25688: EQUAL
25689: IFFALSE 25710
// points := [ 100 , 50 , 75 ] ;
25691: LD_ADDR_VAR 0 9
25695: PUSH
25696: LD_INT 100
25698: PUSH
25699: LD_INT 50
25701: PUSH
25702: LD_INT 75
25704: PUSH
25705: EMPTY
25706: LIST
25707: LIST
25708: LIST
25709: ST_TO_ADDR
// if GetClass ( i ) = 15 then
25710: LD_VAR 0 6
25714: PPUSH
25715: CALL_OW 257
25719: PUSH
25720: LD_INT 15
25722: EQUAL
25723: IFFALSE 25744
// points := [ 10 , 5 , 3 ] ;
25725: LD_ADDR_VAR 0 9
25729: PUSH
25730: LD_INT 10
25732: PUSH
25733: LD_INT 5
25735: PUSH
25736: LD_INT 3
25738: PUSH
25739: EMPTY
25740: LIST
25741: LIST
25742: LIST
25743: ST_TO_ADDR
// if GetClass ( i ) = 14 then
25744: LD_VAR 0 6
25748: PPUSH
25749: CALL_OW 257
25753: PUSH
25754: LD_INT 14
25756: EQUAL
25757: IFFALSE 25778
// points := [ 10 , 0 , 0 ] ;
25759: LD_ADDR_VAR 0 9
25763: PUSH
25764: LD_INT 10
25766: PUSH
25767: LD_INT 0
25769: PUSH
25770: LD_INT 0
25772: PUSH
25773: EMPTY
25774: LIST
25775: LIST
25776: LIST
25777: ST_TO_ADDR
// if GetClass ( i ) = 11 then
25778: LD_VAR 0 6
25782: PPUSH
25783: CALL_OW 257
25787: PUSH
25788: LD_INT 11
25790: EQUAL
25791: IFFALSE 25812
// points := [ 30 , 10 , 5 ] ;
25793: LD_ADDR_VAR 0 9
25797: PUSH
25798: LD_INT 30
25800: PUSH
25801: LD_INT 10
25803: PUSH
25804: LD_INT 5
25806: PUSH
25807: EMPTY
25808: LIST
25809: LIST
25810: LIST
25811: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
25812: LD_VAR 0 1
25816: PPUSH
25817: LD_INT 5
25819: PPUSH
25820: CALL_OW 321
25824: PUSH
25825: LD_INT 2
25827: EQUAL
25828: IFFALSE 25845
// bpoints := bpoints * 1.8 ;
25830: LD_ADDR_VAR 0 10
25834: PUSH
25835: LD_VAR 0 10
25839: PUSH
25840: LD_REAL  1.80000000000000E+0000
25843: MUL
25844: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
25845: LD_VAR 0 6
25849: PPUSH
25850: CALL_OW 257
25854: PUSH
25855: LD_INT 1
25857: PUSH
25858: LD_INT 2
25860: PUSH
25861: LD_INT 3
25863: PUSH
25864: LD_INT 4
25866: PUSH
25867: EMPTY
25868: LIST
25869: LIST
25870: LIST
25871: LIST
25872: IN
25873: PUSH
25874: LD_VAR 0 1
25878: PPUSH
25879: LD_INT 51
25881: PPUSH
25882: CALL_OW 321
25886: PUSH
25887: LD_INT 2
25889: EQUAL
25890: AND
25891: IFFALSE 25908
// bpoints := bpoints * 1.2 ;
25893: LD_ADDR_VAR 0 10
25897: PUSH
25898: LD_VAR 0 10
25902: PUSH
25903: LD_REAL  1.20000000000000E+0000
25906: MUL
25907: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
25908: LD_VAR 0 6
25912: PPUSH
25913: CALL_OW 257
25917: PUSH
25918: LD_INT 5
25920: PUSH
25921: LD_INT 7
25923: PUSH
25924: LD_INT 9
25926: PUSH
25927: EMPTY
25928: LIST
25929: LIST
25930: LIST
25931: IN
25932: PUSH
25933: LD_VAR 0 1
25937: PPUSH
25938: LD_INT 52
25940: PPUSH
25941: CALL_OW 321
25945: PUSH
25946: LD_INT 2
25948: EQUAL
25949: AND
25950: IFFALSE 25967
// bpoints := bpoints * 1.5 ;
25952: LD_ADDR_VAR 0 10
25956: PUSH
25957: LD_VAR 0 10
25961: PUSH
25962: LD_REAL  1.50000000000000E+0000
25965: MUL
25966: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
25967: LD_VAR 0 1
25971: PPUSH
25972: LD_INT 66
25974: PPUSH
25975: CALL_OW 321
25979: PUSH
25980: LD_INT 2
25982: EQUAL
25983: IFFALSE 26000
// bpoints := bpoints * 1.1 ;
25985: LD_ADDR_VAR 0 10
25989: PUSH
25990: LD_VAR 0 10
25994: PUSH
25995: LD_REAL  1.10000000000000E+0000
25998: MUL
25999: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
26000: LD_ADDR_VAR 0 10
26004: PUSH
26005: LD_VAR 0 10
26009: PUSH
26010: LD_VAR 0 6
26014: PPUSH
26015: LD_INT 1
26017: PPUSH
26018: CALL_OW 259
26022: PUSH
26023: LD_REAL  1.15000000000000E+0000
26026: MUL
26027: MUL
26028: ST_TO_ADDR
// end ; unit_vehicle :
26029: GO 26857
26031: LD_INT 2
26033: DOUBLE
26034: EQUAL
26035: IFTRUE 26039
26037: GO 26845
26039: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
26040: LD_VAR 0 6
26044: PPUSH
26045: CALL_OW 264
26049: PUSH
26050: LD_INT 2
26052: PUSH
26053: LD_INT 42
26055: PUSH
26056: LD_INT 24
26058: PUSH
26059: EMPTY
26060: LIST
26061: LIST
26062: LIST
26063: IN
26064: IFFALSE 26085
// points := [ 25 , 5 , 3 ] ;
26066: LD_ADDR_VAR 0 9
26070: PUSH
26071: LD_INT 25
26073: PUSH
26074: LD_INT 5
26076: PUSH
26077: LD_INT 3
26079: PUSH
26080: EMPTY
26081: LIST
26082: LIST
26083: LIST
26084: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
26085: LD_VAR 0 6
26089: PPUSH
26090: CALL_OW 264
26094: PUSH
26095: LD_INT 4
26097: PUSH
26098: LD_INT 43
26100: PUSH
26101: LD_INT 25
26103: PUSH
26104: EMPTY
26105: LIST
26106: LIST
26107: LIST
26108: IN
26109: IFFALSE 26130
// points := [ 40 , 15 , 5 ] ;
26111: LD_ADDR_VAR 0 9
26115: PUSH
26116: LD_INT 40
26118: PUSH
26119: LD_INT 15
26121: PUSH
26122: LD_INT 5
26124: PUSH
26125: EMPTY
26126: LIST
26127: LIST
26128: LIST
26129: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
26130: LD_VAR 0 6
26134: PPUSH
26135: CALL_OW 264
26139: PUSH
26140: LD_INT 3
26142: PUSH
26143: LD_INT 23
26145: PUSH
26146: EMPTY
26147: LIST
26148: LIST
26149: IN
26150: IFFALSE 26171
// points := [ 7 , 25 , 8 ] ;
26152: LD_ADDR_VAR 0 9
26156: PUSH
26157: LD_INT 7
26159: PUSH
26160: LD_INT 25
26162: PUSH
26163: LD_INT 8
26165: PUSH
26166: EMPTY
26167: LIST
26168: LIST
26169: LIST
26170: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
26171: LD_VAR 0 6
26175: PPUSH
26176: CALL_OW 264
26180: PUSH
26181: LD_INT 5
26183: PUSH
26184: LD_INT 27
26186: PUSH
26187: LD_INT 44
26189: PUSH
26190: EMPTY
26191: LIST
26192: LIST
26193: LIST
26194: IN
26195: IFFALSE 26216
// points := [ 14 , 50 , 16 ] ;
26197: LD_ADDR_VAR 0 9
26201: PUSH
26202: LD_INT 14
26204: PUSH
26205: LD_INT 50
26207: PUSH
26208: LD_INT 16
26210: PUSH
26211: EMPTY
26212: LIST
26213: LIST
26214: LIST
26215: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
26216: LD_VAR 0 6
26220: PPUSH
26221: CALL_OW 264
26225: PUSH
26226: LD_INT 6
26228: PUSH
26229: LD_INT 46
26231: PUSH
26232: EMPTY
26233: LIST
26234: LIST
26235: IN
26236: IFFALSE 26257
// points := [ 32 , 120 , 70 ] ;
26238: LD_ADDR_VAR 0 9
26242: PUSH
26243: LD_INT 32
26245: PUSH
26246: LD_INT 120
26248: PUSH
26249: LD_INT 70
26251: PUSH
26252: EMPTY
26253: LIST
26254: LIST
26255: LIST
26256: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher , ar_mortar ] then
26257: LD_VAR 0 6
26261: PPUSH
26262: CALL_OW 264
26266: PUSH
26267: LD_INT 7
26269: PUSH
26270: LD_INT 28
26272: PUSH
26273: LD_INT 45
26275: PUSH
26276: LD_INT 92
26278: PUSH
26279: EMPTY
26280: LIST
26281: LIST
26282: LIST
26283: LIST
26284: IN
26285: IFFALSE 26306
// points := [ 35 , 20 , 45 ] ;
26287: LD_ADDR_VAR 0 9
26291: PUSH
26292: LD_INT 35
26294: PUSH
26295: LD_INT 20
26297: PUSH
26298: LD_INT 45
26300: PUSH
26301: EMPTY
26302: LIST
26303: LIST
26304: LIST
26305: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
26306: LD_VAR 0 6
26310: PPUSH
26311: CALL_OW 264
26315: PUSH
26316: LD_INT 47
26318: PUSH
26319: EMPTY
26320: LIST
26321: IN
26322: IFFALSE 26343
// points := [ 67 , 45 , 75 ] ;
26324: LD_ADDR_VAR 0 9
26328: PUSH
26329: LD_INT 67
26331: PUSH
26332: LD_INT 45
26334: PUSH
26335: LD_INT 75
26337: PUSH
26338: EMPTY
26339: LIST
26340: LIST
26341: LIST
26342: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
26343: LD_VAR 0 6
26347: PPUSH
26348: CALL_OW 264
26352: PUSH
26353: LD_INT 26
26355: PUSH
26356: EMPTY
26357: LIST
26358: IN
26359: IFFALSE 26380
// points := [ 120 , 30 , 80 ] ;
26361: LD_ADDR_VAR 0 9
26365: PUSH
26366: LD_INT 120
26368: PUSH
26369: LD_INT 30
26371: PUSH
26372: LD_INT 80
26374: PUSH
26375: EMPTY
26376: LIST
26377: LIST
26378: LIST
26379: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
26380: LD_VAR 0 6
26384: PPUSH
26385: CALL_OW 264
26389: PUSH
26390: LD_INT 22
26392: PUSH
26393: EMPTY
26394: LIST
26395: IN
26396: IFFALSE 26417
// points := [ 40 , 1 , 1 ] ;
26398: LD_ADDR_VAR 0 9
26402: PUSH
26403: LD_INT 40
26405: PUSH
26406: LD_INT 1
26408: PUSH
26409: LD_INT 1
26411: PUSH
26412: EMPTY
26413: LIST
26414: LIST
26415: LIST
26416: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
26417: LD_VAR 0 6
26421: PPUSH
26422: CALL_OW 264
26426: PUSH
26427: LD_INT 29
26429: PUSH
26430: EMPTY
26431: LIST
26432: IN
26433: IFFALSE 26454
// points := [ 70 , 200 , 400 ] ;
26435: LD_ADDR_VAR 0 9
26439: PUSH
26440: LD_INT 70
26442: PUSH
26443: LD_INT 200
26445: PUSH
26446: LD_INT 400
26448: PUSH
26449: EMPTY
26450: LIST
26451: LIST
26452: LIST
26453: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
26454: LD_VAR 0 6
26458: PPUSH
26459: CALL_OW 264
26463: PUSH
26464: LD_INT 14
26466: PUSH
26467: LD_INT 53
26469: PUSH
26470: EMPTY
26471: LIST
26472: LIST
26473: IN
26474: IFFALSE 26495
// points := [ 40 , 10 , 20 ] ;
26476: LD_ADDR_VAR 0 9
26480: PUSH
26481: LD_INT 40
26483: PUSH
26484: LD_INT 10
26486: PUSH
26487: LD_INT 20
26489: PUSH
26490: EMPTY
26491: LIST
26492: LIST
26493: LIST
26494: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
26495: LD_VAR 0 6
26499: PPUSH
26500: CALL_OW 264
26504: PUSH
26505: LD_INT 9
26507: PUSH
26508: EMPTY
26509: LIST
26510: IN
26511: IFFALSE 26532
// points := [ 5 , 70 , 20 ] ;
26513: LD_ADDR_VAR 0 9
26517: PUSH
26518: LD_INT 5
26520: PUSH
26521: LD_INT 70
26523: PUSH
26524: LD_INT 20
26526: PUSH
26527: EMPTY
26528: LIST
26529: LIST
26530: LIST
26531: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
26532: LD_VAR 0 6
26536: PPUSH
26537: CALL_OW 264
26541: PUSH
26542: LD_INT 10
26544: PUSH
26545: EMPTY
26546: LIST
26547: IN
26548: IFFALSE 26569
// points := [ 35 , 110 , 70 ] ;
26550: LD_ADDR_VAR 0 9
26554: PUSH
26555: LD_INT 35
26557: PUSH
26558: LD_INT 110
26560: PUSH
26561: LD_INT 70
26563: PUSH
26564: EMPTY
26565: LIST
26566: LIST
26567: LIST
26568: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
26569: LD_VAR 0 6
26573: PPUSH
26574: CALL_OW 265
26578: PUSH
26579: LD_INT 25
26581: EQUAL
26582: IFFALSE 26603
// points := [ 80 , 65 , 100 ] ;
26584: LD_ADDR_VAR 0 9
26588: PUSH
26589: LD_INT 80
26591: PUSH
26592: LD_INT 65
26594: PUSH
26595: LD_INT 100
26597: PUSH
26598: EMPTY
26599: LIST
26600: LIST
26601: LIST
26602: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
26603: LD_VAR 0 6
26607: PPUSH
26608: CALL_OW 263
26612: PUSH
26613: LD_INT 1
26615: EQUAL
26616: IFFALSE 26651
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
26618: LD_ADDR_VAR 0 10
26622: PUSH
26623: LD_VAR 0 10
26627: PUSH
26628: LD_VAR 0 6
26632: PPUSH
26633: CALL_OW 311
26637: PPUSH
26638: LD_INT 3
26640: PPUSH
26641: CALL_OW 259
26645: PUSH
26646: LD_INT 4
26648: MUL
26649: MUL
26650: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
26651: LD_VAR 0 6
26655: PPUSH
26656: CALL_OW 263
26660: PUSH
26661: LD_INT 2
26663: EQUAL
26664: IFFALSE 26715
// begin j := IsControledBy ( i ) ;
26666: LD_ADDR_VAR 0 7
26670: PUSH
26671: LD_VAR 0 6
26675: PPUSH
26676: CALL_OW 312
26680: ST_TO_ADDR
// if j then
26681: LD_VAR 0 7
26685: IFFALSE 26715
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
26687: LD_ADDR_VAR 0 10
26691: PUSH
26692: LD_VAR 0 10
26696: PUSH
26697: LD_VAR 0 7
26701: PPUSH
26702: LD_INT 3
26704: PPUSH
26705: CALL_OW 259
26709: PUSH
26710: LD_INT 3
26712: MUL
26713: MUL
26714: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
26715: LD_VAR 0 6
26719: PPUSH
26720: CALL_OW 264
26724: PUSH
26725: LD_INT 5
26727: PUSH
26728: LD_INT 6
26730: PUSH
26731: LD_INT 46
26733: PUSH
26734: LD_INT 44
26736: PUSH
26737: LD_INT 47
26739: PUSH
26740: LD_INT 45
26742: PUSH
26743: LD_INT 28
26745: PUSH
26746: LD_INT 7
26748: PUSH
26749: LD_INT 27
26751: PUSH
26752: LD_INT 29
26754: PUSH
26755: EMPTY
26756: LIST
26757: LIST
26758: LIST
26759: LIST
26760: LIST
26761: LIST
26762: LIST
26763: LIST
26764: LIST
26765: LIST
26766: IN
26767: PUSH
26768: LD_VAR 0 1
26772: PPUSH
26773: LD_INT 52
26775: PPUSH
26776: CALL_OW 321
26780: PUSH
26781: LD_INT 2
26783: EQUAL
26784: AND
26785: IFFALSE 26802
// bpoints := bpoints * 1.2 ;
26787: LD_ADDR_VAR 0 10
26791: PUSH
26792: LD_VAR 0 10
26796: PUSH
26797: LD_REAL  1.20000000000000E+0000
26800: MUL
26801: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
26802: LD_VAR 0 6
26806: PPUSH
26807: CALL_OW 264
26811: PUSH
26812: LD_INT 6
26814: PUSH
26815: LD_INT 46
26817: PUSH
26818: LD_INT 47
26820: PUSH
26821: EMPTY
26822: LIST
26823: LIST
26824: LIST
26825: IN
26826: IFFALSE 26843
// bpoints := bpoints * 1.2 ;
26828: LD_ADDR_VAR 0 10
26832: PUSH
26833: LD_VAR 0 10
26837: PUSH
26838: LD_REAL  1.20000000000000E+0000
26841: MUL
26842: ST_TO_ADDR
// end ; unit_building :
26843: GO 26857
26845: LD_INT 3
26847: DOUBLE
26848: EQUAL
26849: IFTRUE 26853
26851: GO 26856
26853: POP
// ; end ;
26854: GO 26857
26856: POP
// for j = 1 to 3 do
26857: LD_ADDR_VAR 0 7
26861: PUSH
26862: DOUBLE
26863: LD_INT 1
26865: DEC
26866: ST_TO_ADDR
26867: LD_INT 3
26869: PUSH
26870: FOR_TO
26871: IFFALSE 26924
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
26873: LD_ADDR_VAR 0 5
26877: PUSH
26878: LD_VAR 0 5
26882: PPUSH
26883: LD_VAR 0 7
26887: PPUSH
26888: LD_VAR 0 5
26892: PUSH
26893: LD_VAR 0 7
26897: ARRAY
26898: PUSH
26899: LD_VAR 0 9
26903: PUSH
26904: LD_VAR 0 7
26908: ARRAY
26909: PUSH
26910: LD_VAR 0 10
26914: MUL
26915: PLUS
26916: PPUSH
26917: CALL_OW 1
26921: ST_TO_ADDR
26922: GO 26870
26924: POP
26925: POP
// end ;
26926: GO 25405
26928: POP
26929: POP
// result := Replace ( result , 4 , tmp ) ;
26930: LD_ADDR_VAR 0 5
26934: PUSH
26935: LD_VAR 0 5
26939: PPUSH
26940: LD_INT 4
26942: PPUSH
26943: LD_VAR 0 8
26947: PPUSH
26948: CALL_OW 1
26952: ST_TO_ADDR
// end ;
26953: LD_VAR 0 5
26957: RET
// export function DangerAtRange ( unit , range ) ; begin
26958: LD_INT 0
26960: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
26961: LD_ADDR_VAR 0 3
26965: PUSH
26966: LD_VAR 0 1
26970: PPUSH
26971: CALL_OW 255
26975: PPUSH
26976: LD_VAR 0 1
26980: PPUSH
26981: CALL_OW 250
26985: PPUSH
26986: LD_VAR 0 1
26990: PPUSH
26991: CALL_OW 251
26995: PPUSH
26996: LD_VAR 0 2
27000: PPUSH
27001: CALL 25257 0 4
27005: ST_TO_ADDR
// end ;
27006: LD_VAR 0 3
27010: RET
// export function DangerInArea ( side , area ) ; begin
27011: LD_INT 0
27013: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
27014: LD_ADDR_VAR 0 3
27018: PUSH
27019: LD_VAR 0 2
27023: PPUSH
27024: LD_INT 81
27026: PUSH
27027: LD_VAR 0 1
27031: PUSH
27032: EMPTY
27033: LIST
27034: LIST
27035: PPUSH
27036: CALL_OW 70
27040: ST_TO_ADDR
// end ;
27041: LD_VAR 0 3
27045: RET
// export function IsExtension ( b ) ; begin
27046: LD_INT 0
27048: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
27049: LD_ADDR_VAR 0 2
27053: PUSH
27054: LD_VAR 0 1
27058: PUSH
27059: LD_INT 23
27061: PUSH
27062: LD_INT 20
27064: PUSH
27065: LD_INT 22
27067: PUSH
27068: LD_INT 17
27070: PUSH
27071: LD_INT 24
27073: PUSH
27074: LD_INT 21
27076: PUSH
27077: LD_INT 19
27079: PUSH
27080: LD_INT 16
27082: PUSH
27083: LD_INT 25
27085: PUSH
27086: LD_INT 18
27088: PUSH
27089: EMPTY
27090: LIST
27091: LIST
27092: LIST
27093: LIST
27094: LIST
27095: LIST
27096: LIST
27097: LIST
27098: LIST
27099: LIST
27100: IN
27101: ST_TO_ADDR
// end ;
27102: LD_VAR 0 2
27106: RET
// export function GetBaseBuildings ( base , area , checkLink ) ; var tmp , i ; begin
27107: LD_INT 0
27109: PPUSH
27110: PPUSH
27111: PPUSH
// result := [ ] ;
27112: LD_ADDR_VAR 0 4
27116: PUSH
27117: EMPTY
27118: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
27119: LD_ADDR_VAR 0 5
27123: PUSH
27124: LD_VAR 0 2
27128: PPUSH
27129: LD_INT 21
27131: PUSH
27132: LD_INT 3
27134: PUSH
27135: EMPTY
27136: LIST
27137: LIST
27138: PPUSH
27139: CALL_OW 70
27143: ST_TO_ADDR
// if not tmp then
27144: LD_VAR 0 5
27148: NOT
27149: IFFALSE 27153
// exit ;
27151: GO 27217
// if checkLink then
27153: LD_VAR 0 3
27157: IFFALSE 27207
// begin for i in tmp do
27159: LD_ADDR_VAR 0 6
27163: PUSH
27164: LD_VAR 0 5
27168: PUSH
27169: FOR_IN
27170: IFFALSE 27205
// if GetBase ( i ) <> base then
27172: LD_VAR 0 6
27176: PPUSH
27177: CALL_OW 274
27181: PUSH
27182: LD_VAR 0 1
27186: NONEQUAL
27187: IFFALSE 27203
// ComLinkToBase ( base , i ) ;
27189: LD_VAR 0 1
27193: PPUSH
27194: LD_VAR 0 6
27198: PPUSH
27199: CALL_OW 169
27203: GO 27169
27205: POP
27206: POP
// end ; result := tmp ;
27207: LD_ADDR_VAR 0 4
27211: PUSH
27212: LD_VAR 0 5
27216: ST_TO_ADDR
// end ;
27217: LD_VAR 0 4
27221: RET
// export function ComComplete ( units , b ) ; var i ; begin
27222: LD_INT 0
27224: PPUSH
27225: PPUSH
// if not units then
27226: LD_VAR 0 1
27230: NOT
27231: IFFALSE 27235
// exit ;
27233: GO 27325
// for i in units do
27235: LD_ADDR_VAR 0 4
27239: PUSH
27240: LD_VAR 0 1
27244: PUSH
27245: FOR_IN
27246: IFFALSE 27323
// if BuildingStatus ( b ) = bs_build then
27248: LD_VAR 0 2
27252: PPUSH
27253: CALL_OW 461
27257: PUSH
27258: LD_INT 1
27260: EQUAL
27261: IFFALSE 27321
// SetTaskList ( i , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
27263: LD_VAR 0 4
27267: PPUSH
27268: LD_STRING h
27270: PUSH
27271: LD_VAR 0 2
27275: PPUSH
27276: CALL_OW 250
27280: PUSH
27281: LD_VAR 0 2
27285: PPUSH
27286: CALL_OW 251
27290: PUSH
27291: LD_VAR 0 2
27295: PUSH
27296: LD_INT 0
27298: PUSH
27299: LD_INT 0
27301: PUSH
27302: LD_INT 0
27304: PUSH
27305: EMPTY
27306: LIST
27307: LIST
27308: LIST
27309: LIST
27310: LIST
27311: LIST
27312: LIST
27313: PUSH
27314: EMPTY
27315: LIST
27316: PPUSH
27317: CALL_OW 446
27321: GO 27245
27323: POP
27324: POP
// end ;
27325: LD_VAR 0 3
27329: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
27330: LD_INT 0
27332: PPUSH
27333: PPUSH
27334: PPUSH
27335: PPUSH
27336: PPUSH
27337: PPUSH
// if not vehicle or GetControl ( vehicle ) <> control_remote then
27338: LD_VAR 0 1
27342: NOT
27343: PUSH
27344: LD_VAR 0 1
27348: PPUSH
27349: CALL_OW 263
27353: PUSH
27354: LD_INT 2
27356: NONEQUAL
27357: OR
27358: IFFALSE 27362
// exit ;
27360: GO 27678
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
27362: LD_ADDR_VAR 0 6
27366: PUSH
27367: LD_INT 22
27369: PUSH
27370: LD_VAR 0 1
27374: PPUSH
27375: CALL_OW 255
27379: PUSH
27380: EMPTY
27381: LIST
27382: LIST
27383: PUSH
27384: LD_INT 2
27386: PUSH
27387: LD_INT 30
27389: PUSH
27390: LD_INT 36
27392: PUSH
27393: EMPTY
27394: LIST
27395: LIST
27396: PUSH
27397: LD_INT 34
27399: PUSH
27400: LD_INT 31
27402: PUSH
27403: EMPTY
27404: LIST
27405: LIST
27406: PUSH
27407: EMPTY
27408: LIST
27409: LIST
27410: LIST
27411: PUSH
27412: EMPTY
27413: LIST
27414: LIST
27415: PPUSH
27416: CALL_OW 69
27420: ST_TO_ADDR
// if not tmp then
27421: LD_VAR 0 6
27425: NOT
27426: IFFALSE 27430
// exit ;
27428: GO 27678
// result := [ ] ;
27430: LD_ADDR_VAR 0 2
27434: PUSH
27435: EMPTY
27436: ST_TO_ADDR
// for i in tmp do
27437: LD_ADDR_VAR 0 3
27441: PUSH
27442: LD_VAR 0 6
27446: PUSH
27447: FOR_IN
27448: IFFALSE 27519
// begin t := UnitsInside ( i ) ;
27450: LD_ADDR_VAR 0 4
27454: PUSH
27455: LD_VAR 0 3
27459: PPUSH
27460: CALL_OW 313
27464: ST_TO_ADDR
// if t then
27465: LD_VAR 0 4
27469: IFFALSE 27517
// for j in t do
27471: LD_ADDR_VAR 0 7
27475: PUSH
27476: LD_VAR 0 4
27480: PUSH
27481: FOR_IN
27482: IFFALSE 27515
// result := Replace ( result , result + 1 , j ) ;
27484: LD_ADDR_VAR 0 2
27488: PUSH
27489: LD_VAR 0 2
27493: PPUSH
27494: LD_VAR 0 2
27498: PUSH
27499: LD_INT 1
27501: PLUS
27502: PPUSH
27503: LD_VAR 0 7
27507: PPUSH
27508: CALL_OW 1
27512: ST_TO_ADDR
27513: GO 27481
27515: POP
27516: POP
// end ;
27517: GO 27447
27519: POP
27520: POP
// if not result then
27521: LD_VAR 0 2
27525: NOT
27526: IFFALSE 27530
// exit ;
27528: GO 27678
// mech := result [ 1 ] ;
27530: LD_ADDR_VAR 0 5
27534: PUSH
27535: LD_VAR 0 2
27539: PUSH
27540: LD_INT 1
27542: ARRAY
27543: ST_TO_ADDR
// if result > 1 then
27544: LD_VAR 0 2
27548: PUSH
27549: LD_INT 1
27551: GREATER
27552: IFFALSE 27664
// begin for i = 2 to result do
27554: LD_ADDR_VAR 0 3
27558: PUSH
27559: DOUBLE
27560: LD_INT 2
27562: DEC
27563: ST_TO_ADDR
27564: LD_VAR 0 2
27568: PUSH
27569: FOR_TO
27570: IFFALSE 27662
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
27572: LD_ADDR_VAR 0 4
27576: PUSH
27577: LD_VAR 0 2
27581: PUSH
27582: LD_VAR 0 3
27586: ARRAY
27587: PPUSH
27588: LD_INT 3
27590: PPUSH
27591: CALL_OW 259
27595: PUSH
27596: LD_VAR 0 2
27600: PUSH
27601: LD_VAR 0 3
27605: ARRAY
27606: PPUSH
27607: CALL_OW 432
27611: MINUS
27612: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
27613: LD_VAR 0 4
27617: PUSH
27618: LD_VAR 0 5
27622: PPUSH
27623: LD_INT 3
27625: PPUSH
27626: CALL_OW 259
27630: PUSH
27631: LD_VAR 0 5
27635: PPUSH
27636: CALL_OW 432
27640: MINUS
27641: GREATEREQUAL
27642: IFFALSE 27660
// mech := result [ i ] ;
27644: LD_ADDR_VAR 0 5
27648: PUSH
27649: LD_VAR 0 2
27653: PUSH
27654: LD_VAR 0 3
27658: ARRAY
27659: ST_TO_ADDR
// end ;
27660: GO 27569
27662: POP
27663: POP
// end ; ComLinkTo ( vehicle , mech ) ;
27664: LD_VAR 0 1
27668: PPUSH
27669: LD_VAR 0 5
27673: PPUSH
27674: CALL_OW 135
// end ;
27678: LD_VAR 0 2
27682: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
27683: LD_INT 0
27685: PPUSH
27686: PPUSH
27687: PPUSH
27688: PPUSH
27689: PPUSH
27690: PPUSH
27691: PPUSH
27692: PPUSH
27693: PPUSH
27694: PPUSH
27695: PPUSH
27696: PPUSH
27697: PPUSH
// result := [ ] ;
27698: LD_ADDR_VAR 0 7
27702: PUSH
27703: EMPTY
27704: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
27705: LD_VAR 0 1
27709: PPUSH
27710: CALL_OW 266
27714: PUSH
27715: LD_INT 0
27717: PUSH
27718: LD_INT 1
27720: PUSH
27721: EMPTY
27722: LIST
27723: LIST
27724: IN
27725: NOT
27726: IFFALSE 27730
// exit ;
27728: GO 29364
// if name then
27730: LD_VAR 0 3
27734: IFFALSE 27750
// SetBName ( base_dep , name ) ;
27736: LD_VAR 0 1
27740: PPUSH
27741: LD_VAR 0 3
27745: PPUSH
27746: CALL_OW 500
// base := GetBase ( base_dep ) ;
27750: LD_ADDR_VAR 0 15
27754: PUSH
27755: LD_VAR 0 1
27759: PPUSH
27760: CALL_OW 274
27764: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
27765: LD_ADDR_VAR 0 16
27769: PUSH
27770: LD_VAR 0 1
27774: PPUSH
27775: CALL_OW 255
27779: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
27780: LD_ADDR_VAR 0 17
27784: PUSH
27785: LD_VAR 0 1
27789: PPUSH
27790: CALL_OW 248
27794: ST_TO_ADDR
// if sources then
27795: LD_VAR 0 5
27799: IFFALSE 27846
// for i = 1 to 3 do
27801: LD_ADDR_VAR 0 8
27805: PUSH
27806: DOUBLE
27807: LD_INT 1
27809: DEC
27810: ST_TO_ADDR
27811: LD_INT 3
27813: PUSH
27814: FOR_TO
27815: IFFALSE 27844
// AddResourceType ( base , i , sources [ i ] ) ;
27817: LD_VAR 0 15
27821: PPUSH
27822: LD_VAR 0 8
27826: PPUSH
27827: LD_VAR 0 5
27831: PUSH
27832: LD_VAR 0 8
27836: ARRAY
27837: PPUSH
27838: CALL_OW 276
27842: GO 27814
27844: POP
27845: POP
// buildings := GetBaseBuildings ( base , area , true ) ;
27846: LD_ADDR_VAR 0 18
27850: PUSH
27851: LD_VAR 0 15
27855: PPUSH
27856: LD_VAR 0 2
27860: PPUSH
27861: LD_INT 1
27863: PPUSH
27864: CALL 27107 0 3
27868: ST_TO_ADDR
// InitHc ;
27869: CALL_OW 19
// InitUc ;
27873: CALL_OW 18
// uc_side := side ;
27877: LD_ADDR_OWVAR 20
27881: PUSH
27882: LD_VAR 0 16
27886: ST_TO_ADDR
// uc_nation := nation ;
27887: LD_ADDR_OWVAR 21
27891: PUSH
27892: LD_VAR 0 17
27896: ST_TO_ADDR
// if buildings then
27897: LD_VAR 0 18
27901: IFFALSE 29223
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
27903: LD_ADDR_VAR 0 19
27907: PUSH
27908: LD_VAR 0 18
27912: PPUSH
27913: LD_INT 2
27915: PUSH
27916: LD_INT 30
27918: PUSH
27919: LD_INT 29
27921: PUSH
27922: EMPTY
27923: LIST
27924: LIST
27925: PUSH
27926: LD_INT 30
27928: PUSH
27929: LD_INT 30
27931: PUSH
27932: EMPTY
27933: LIST
27934: LIST
27935: PUSH
27936: EMPTY
27937: LIST
27938: LIST
27939: LIST
27940: PPUSH
27941: CALL_OW 72
27945: ST_TO_ADDR
// if tmp then
27946: LD_VAR 0 19
27950: IFFALSE 27998
// for i in tmp do
27952: LD_ADDR_VAR 0 8
27956: PUSH
27957: LD_VAR 0 19
27961: PUSH
27962: FOR_IN
27963: IFFALSE 27996
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
27965: LD_VAR 0 8
27969: PPUSH
27970: CALL_OW 250
27974: PPUSH
27975: LD_VAR 0 8
27979: PPUSH
27980: CALL_OW 251
27984: PPUSH
27985: LD_VAR 0 16
27989: PPUSH
27990: CALL_OW 441
27994: GO 27962
27996: POP
27997: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
27998: LD_VAR 0 18
28002: PPUSH
28003: LD_INT 2
28005: PUSH
28006: LD_INT 30
28008: PUSH
28009: LD_INT 32
28011: PUSH
28012: EMPTY
28013: LIST
28014: LIST
28015: PUSH
28016: LD_INT 30
28018: PUSH
28019: LD_INT 33
28021: PUSH
28022: EMPTY
28023: LIST
28024: LIST
28025: PUSH
28026: EMPTY
28027: LIST
28028: LIST
28029: LIST
28030: PPUSH
28031: CALL_OW 72
28035: IFFALSE 28123
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
28037: LD_ADDR_VAR 0 8
28041: PUSH
28042: LD_VAR 0 18
28046: PPUSH
28047: LD_INT 2
28049: PUSH
28050: LD_INT 30
28052: PUSH
28053: LD_INT 32
28055: PUSH
28056: EMPTY
28057: LIST
28058: LIST
28059: PUSH
28060: LD_INT 30
28062: PUSH
28063: LD_INT 33
28065: PUSH
28066: EMPTY
28067: LIST
28068: LIST
28069: PUSH
28070: EMPTY
28071: LIST
28072: LIST
28073: LIST
28074: PPUSH
28075: CALL_OW 72
28079: PUSH
28080: FOR_IN
28081: IFFALSE 28121
// begin if not GetBWeapon ( i ) then
28083: LD_VAR 0 8
28087: PPUSH
28088: CALL_OW 269
28092: NOT
28093: IFFALSE 28119
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
28095: LD_VAR 0 8
28099: PPUSH
28100: LD_VAR 0 8
28104: PPUSH
28105: LD_VAR 0 2
28109: PPUSH
28110: CALL 29369 0 2
28114: PPUSH
28115: CALL_OW 431
// end ;
28119: GO 28080
28121: POP
28122: POP
// end ; for i = 1 to personel do
28123: LD_ADDR_VAR 0 8
28127: PUSH
28128: DOUBLE
28129: LD_INT 1
28131: DEC
28132: ST_TO_ADDR
28133: LD_VAR 0 6
28137: PUSH
28138: FOR_TO
28139: IFFALSE 29203
// begin if i > 4 then
28141: LD_VAR 0 8
28145: PUSH
28146: LD_INT 4
28148: GREATER
28149: IFFALSE 28153
// break ;
28151: GO 29203
// case i of 1 :
28153: LD_VAR 0 8
28157: PUSH
28158: LD_INT 1
28160: DOUBLE
28161: EQUAL
28162: IFTRUE 28166
28164: GO 28246
28166: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
28167: LD_ADDR_VAR 0 12
28171: PUSH
28172: LD_VAR 0 18
28176: PPUSH
28177: LD_INT 22
28179: PUSH
28180: LD_VAR 0 16
28184: PUSH
28185: EMPTY
28186: LIST
28187: LIST
28188: PUSH
28189: LD_INT 58
28191: PUSH
28192: EMPTY
28193: LIST
28194: PUSH
28195: LD_INT 2
28197: PUSH
28198: LD_INT 30
28200: PUSH
28201: LD_INT 32
28203: PUSH
28204: EMPTY
28205: LIST
28206: LIST
28207: PUSH
28208: LD_INT 30
28210: PUSH
28211: LD_INT 4
28213: PUSH
28214: EMPTY
28215: LIST
28216: LIST
28217: PUSH
28218: LD_INT 30
28220: PUSH
28221: LD_INT 5
28223: PUSH
28224: EMPTY
28225: LIST
28226: LIST
28227: PUSH
28228: EMPTY
28229: LIST
28230: LIST
28231: LIST
28232: LIST
28233: PUSH
28234: EMPTY
28235: LIST
28236: LIST
28237: LIST
28238: PPUSH
28239: CALL_OW 72
28243: ST_TO_ADDR
28244: GO 28468
28246: LD_INT 2
28248: DOUBLE
28249: EQUAL
28250: IFTRUE 28254
28252: GO 28316
28254: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
28255: LD_ADDR_VAR 0 12
28259: PUSH
28260: LD_VAR 0 18
28264: PPUSH
28265: LD_INT 22
28267: PUSH
28268: LD_VAR 0 16
28272: PUSH
28273: EMPTY
28274: LIST
28275: LIST
28276: PUSH
28277: LD_INT 2
28279: PUSH
28280: LD_INT 30
28282: PUSH
28283: LD_INT 0
28285: PUSH
28286: EMPTY
28287: LIST
28288: LIST
28289: PUSH
28290: LD_INT 30
28292: PUSH
28293: LD_INT 1
28295: PUSH
28296: EMPTY
28297: LIST
28298: LIST
28299: PUSH
28300: EMPTY
28301: LIST
28302: LIST
28303: LIST
28304: PUSH
28305: EMPTY
28306: LIST
28307: LIST
28308: PPUSH
28309: CALL_OW 72
28313: ST_TO_ADDR
28314: GO 28468
28316: LD_INT 3
28318: DOUBLE
28319: EQUAL
28320: IFTRUE 28324
28322: GO 28386
28324: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
28325: LD_ADDR_VAR 0 12
28329: PUSH
28330: LD_VAR 0 18
28334: PPUSH
28335: LD_INT 22
28337: PUSH
28338: LD_VAR 0 16
28342: PUSH
28343: EMPTY
28344: LIST
28345: LIST
28346: PUSH
28347: LD_INT 2
28349: PUSH
28350: LD_INT 30
28352: PUSH
28353: LD_INT 2
28355: PUSH
28356: EMPTY
28357: LIST
28358: LIST
28359: PUSH
28360: LD_INT 30
28362: PUSH
28363: LD_INT 3
28365: PUSH
28366: EMPTY
28367: LIST
28368: LIST
28369: PUSH
28370: EMPTY
28371: LIST
28372: LIST
28373: LIST
28374: PUSH
28375: EMPTY
28376: LIST
28377: LIST
28378: PPUSH
28379: CALL_OW 72
28383: ST_TO_ADDR
28384: GO 28468
28386: LD_INT 4
28388: DOUBLE
28389: EQUAL
28390: IFTRUE 28394
28392: GO 28467
28394: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
28395: LD_ADDR_VAR 0 12
28399: PUSH
28400: LD_VAR 0 18
28404: PPUSH
28405: LD_INT 22
28407: PUSH
28408: LD_VAR 0 16
28412: PUSH
28413: EMPTY
28414: LIST
28415: LIST
28416: PUSH
28417: LD_INT 2
28419: PUSH
28420: LD_INT 30
28422: PUSH
28423: LD_INT 6
28425: PUSH
28426: EMPTY
28427: LIST
28428: LIST
28429: PUSH
28430: LD_INT 30
28432: PUSH
28433: LD_INT 7
28435: PUSH
28436: EMPTY
28437: LIST
28438: LIST
28439: PUSH
28440: LD_INT 30
28442: PUSH
28443: LD_INT 8
28445: PUSH
28446: EMPTY
28447: LIST
28448: LIST
28449: PUSH
28450: EMPTY
28451: LIST
28452: LIST
28453: LIST
28454: LIST
28455: PUSH
28456: EMPTY
28457: LIST
28458: LIST
28459: PPUSH
28460: CALL_OW 72
28464: ST_TO_ADDR
28465: GO 28468
28467: POP
// if i = 1 then
28468: LD_VAR 0 8
28472: PUSH
28473: LD_INT 1
28475: EQUAL
28476: IFFALSE 28587
// begin tmp := [ ] ;
28478: LD_ADDR_VAR 0 19
28482: PUSH
28483: EMPTY
28484: ST_TO_ADDR
// for j in f do
28485: LD_ADDR_VAR 0 9
28489: PUSH
28490: LD_VAR 0 12
28494: PUSH
28495: FOR_IN
28496: IFFALSE 28569
// if GetBType ( j ) = b_bunker then
28498: LD_VAR 0 9
28502: PPUSH
28503: CALL_OW 266
28507: PUSH
28508: LD_INT 32
28510: EQUAL
28511: IFFALSE 28538
// tmp := Insert ( tmp , 1 , j ) else
28513: LD_ADDR_VAR 0 19
28517: PUSH
28518: LD_VAR 0 19
28522: PPUSH
28523: LD_INT 1
28525: PPUSH
28526: LD_VAR 0 9
28530: PPUSH
28531: CALL_OW 2
28535: ST_TO_ADDR
28536: GO 28567
// tmp := Insert ( tmp , tmp + 1 , j ) ;
28538: LD_ADDR_VAR 0 19
28542: PUSH
28543: LD_VAR 0 19
28547: PPUSH
28548: LD_VAR 0 19
28552: PUSH
28553: LD_INT 1
28555: PLUS
28556: PPUSH
28557: LD_VAR 0 9
28561: PPUSH
28562: CALL_OW 2
28566: ST_TO_ADDR
28567: GO 28495
28569: POP
28570: POP
// if tmp then
28571: LD_VAR 0 19
28575: IFFALSE 28587
// f := tmp ;
28577: LD_ADDR_VAR 0 12
28581: PUSH
28582: LD_VAR 0 19
28586: ST_TO_ADDR
// end ; x := personel [ i ] ;
28587: LD_ADDR_VAR 0 13
28591: PUSH
28592: LD_VAR 0 6
28596: PUSH
28597: LD_VAR 0 8
28601: ARRAY
28602: ST_TO_ADDR
// if x = - 1 then
28603: LD_VAR 0 13
28607: PUSH
28608: LD_INT 1
28610: NEG
28611: EQUAL
28612: IFFALSE 28821
// begin for j in f do
28614: LD_ADDR_VAR 0 9
28618: PUSH
28619: LD_VAR 0 12
28623: PUSH
28624: FOR_IN
28625: IFFALSE 28817
// repeat InitHc ;
28627: CALL_OW 19
// if GetBType ( j ) = b_barracks then
28631: LD_VAR 0 9
28635: PPUSH
28636: CALL_OW 266
28640: PUSH
28641: LD_INT 5
28643: EQUAL
28644: IFFALSE 28714
// begin if UnitsInside ( j ) < 3 then
28646: LD_VAR 0 9
28650: PPUSH
28651: CALL_OW 313
28655: PUSH
28656: LD_INT 3
28658: LESS
28659: IFFALSE 28695
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
28661: LD_INT 0
28663: PPUSH
28664: LD_INT 5
28666: PUSH
28667: LD_INT 8
28669: PUSH
28670: LD_INT 9
28672: PUSH
28673: EMPTY
28674: LIST
28675: LIST
28676: LIST
28677: PUSH
28678: LD_VAR 0 17
28682: ARRAY
28683: PPUSH
28684: LD_VAR 0 4
28688: PPUSH
28689: CALL_OW 380
28693: GO 28712
// PrepareHuman ( false , i , skill ) ;
28695: LD_INT 0
28697: PPUSH
28698: LD_VAR 0 8
28702: PPUSH
28703: LD_VAR 0 4
28707: PPUSH
28708: CALL_OW 380
// end else
28712: GO 28731
// PrepareHuman ( false , i , skill ) ;
28714: LD_INT 0
28716: PPUSH
28717: LD_VAR 0 8
28721: PPUSH
28722: LD_VAR 0 4
28726: PPUSH
28727: CALL_OW 380
// un := CreateHuman ;
28731: LD_ADDR_VAR 0 14
28735: PUSH
28736: CALL_OW 44
28740: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
28741: LD_ADDR_VAR 0 7
28745: PUSH
28746: LD_VAR 0 7
28750: PPUSH
28751: LD_INT 1
28753: PPUSH
28754: LD_VAR 0 14
28758: PPUSH
28759: CALL_OW 2
28763: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
28764: LD_VAR 0 14
28768: PPUSH
28769: LD_VAR 0 9
28773: PPUSH
28774: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
28778: LD_VAR 0 9
28782: PPUSH
28783: CALL_OW 313
28787: PUSH
28788: LD_INT 6
28790: EQUAL
28791: PUSH
28792: LD_VAR 0 9
28796: PPUSH
28797: CALL_OW 266
28801: PUSH
28802: LD_INT 32
28804: PUSH
28805: LD_INT 31
28807: PUSH
28808: EMPTY
28809: LIST
28810: LIST
28811: IN
28812: OR
28813: IFFALSE 28627
28815: GO 28624
28817: POP
28818: POP
// end else
28819: GO 29201
// for j = 1 to x do
28821: LD_ADDR_VAR 0 9
28825: PUSH
28826: DOUBLE
28827: LD_INT 1
28829: DEC
28830: ST_TO_ADDR
28831: LD_VAR 0 13
28835: PUSH
28836: FOR_TO
28837: IFFALSE 29199
// begin InitHc ;
28839: CALL_OW 19
// if not f then
28843: LD_VAR 0 12
28847: NOT
28848: IFFALSE 28937
// begin PrepareHuman ( false , i , skill ) ;
28850: LD_INT 0
28852: PPUSH
28853: LD_VAR 0 8
28857: PPUSH
28858: LD_VAR 0 4
28862: PPUSH
28863: CALL_OW 380
// un := CreateHuman ;
28867: LD_ADDR_VAR 0 14
28871: PUSH
28872: CALL_OW 44
28876: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
28877: LD_ADDR_VAR 0 7
28881: PUSH
28882: LD_VAR 0 7
28886: PPUSH
28887: LD_INT 1
28889: PPUSH
28890: LD_VAR 0 14
28894: PPUSH
28895: CALL_OW 2
28899: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
28900: LD_VAR 0 14
28904: PPUSH
28905: LD_VAR 0 1
28909: PPUSH
28910: CALL_OW 250
28914: PPUSH
28915: LD_VAR 0 1
28919: PPUSH
28920: CALL_OW 251
28924: PPUSH
28925: LD_INT 10
28927: PPUSH
28928: LD_INT 0
28930: PPUSH
28931: CALL_OW 50
// continue ;
28935: GO 28836
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
28937: LD_VAR 0 12
28941: PUSH
28942: LD_INT 1
28944: ARRAY
28945: PPUSH
28946: CALL_OW 313
28950: PUSH
28951: LD_VAR 0 12
28955: PUSH
28956: LD_INT 1
28958: ARRAY
28959: PPUSH
28960: CALL_OW 266
28964: PUSH
28965: LD_INT 32
28967: PUSH
28968: LD_INT 31
28970: PUSH
28971: EMPTY
28972: LIST
28973: LIST
28974: IN
28975: AND
28976: PUSH
28977: LD_VAR 0 12
28981: PUSH
28982: LD_INT 1
28984: ARRAY
28985: PPUSH
28986: CALL_OW 313
28990: PUSH
28991: LD_INT 6
28993: EQUAL
28994: OR
28995: IFFALSE 29015
// f := Delete ( f , 1 ) ;
28997: LD_ADDR_VAR 0 12
29001: PUSH
29002: LD_VAR 0 12
29006: PPUSH
29007: LD_INT 1
29009: PPUSH
29010: CALL_OW 3
29014: ST_TO_ADDR
// if not f then
29015: LD_VAR 0 12
29019: NOT
29020: IFFALSE 29038
// begin x := x + 2 ;
29022: LD_ADDR_VAR 0 13
29026: PUSH
29027: LD_VAR 0 13
29031: PUSH
29032: LD_INT 2
29034: PLUS
29035: ST_TO_ADDR
// continue ;
29036: GO 28836
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
29038: LD_VAR 0 12
29042: PUSH
29043: LD_INT 1
29045: ARRAY
29046: PPUSH
29047: CALL_OW 266
29051: PUSH
29052: LD_INT 5
29054: EQUAL
29055: IFFALSE 29129
// begin if UnitsInside ( f [ 1 ] ) < 3 then
29057: LD_VAR 0 12
29061: PUSH
29062: LD_INT 1
29064: ARRAY
29065: PPUSH
29066: CALL_OW 313
29070: PUSH
29071: LD_INT 3
29073: LESS
29074: IFFALSE 29110
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
29076: LD_INT 0
29078: PPUSH
29079: LD_INT 5
29081: PUSH
29082: LD_INT 8
29084: PUSH
29085: LD_INT 9
29087: PUSH
29088: EMPTY
29089: LIST
29090: LIST
29091: LIST
29092: PUSH
29093: LD_VAR 0 17
29097: ARRAY
29098: PPUSH
29099: LD_VAR 0 4
29103: PPUSH
29104: CALL_OW 380
29108: GO 29127
// PrepareHuman ( false , i , skill ) ;
29110: LD_INT 0
29112: PPUSH
29113: LD_VAR 0 8
29117: PPUSH
29118: LD_VAR 0 4
29122: PPUSH
29123: CALL_OW 380
// end else
29127: GO 29146
// PrepareHuman ( false , i , skill ) ;
29129: LD_INT 0
29131: PPUSH
29132: LD_VAR 0 8
29136: PPUSH
29137: LD_VAR 0 4
29141: PPUSH
29142: CALL_OW 380
// un := CreateHuman ;
29146: LD_ADDR_VAR 0 14
29150: PUSH
29151: CALL_OW 44
29155: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
29156: LD_ADDR_VAR 0 7
29160: PUSH
29161: LD_VAR 0 7
29165: PPUSH
29166: LD_INT 1
29168: PPUSH
29169: LD_VAR 0 14
29173: PPUSH
29174: CALL_OW 2
29178: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
29179: LD_VAR 0 14
29183: PPUSH
29184: LD_VAR 0 12
29188: PUSH
29189: LD_INT 1
29191: ARRAY
29192: PPUSH
29193: CALL_OW 52
// end ;
29197: GO 28836
29199: POP
29200: POP
// end ;
29201: GO 28138
29203: POP
29204: POP
// result := result ^ buildings ;
29205: LD_ADDR_VAR 0 7
29209: PUSH
29210: LD_VAR 0 7
29214: PUSH
29215: LD_VAR 0 18
29219: ADD
29220: ST_TO_ADDR
// end else
29221: GO 29364
// begin for i = 1 to personel do
29223: LD_ADDR_VAR 0 8
29227: PUSH
29228: DOUBLE
29229: LD_INT 1
29231: DEC
29232: ST_TO_ADDR
29233: LD_VAR 0 6
29237: PUSH
29238: FOR_TO
29239: IFFALSE 29362
// begin if i > 4 then
29241: LD_VAR 0 8
29245: PUSH
29246: LD_INT 4
29248: GREATER
29249: IFFALSE 29253
// break ;
29251: GO 29362
// x := personel [ i ] ;
29253: LD_ADDR_VAR 0 13
29257: PUSH
29258: LD_VAR 0 6
29262: PUSH
29263: LD_VAR 0 8
29267: ARRAY
29268: ST_TO_ADDR
// if x = - 1 then
29269: LD_VAR 0 13
29273: PUSH
29274: LD_INT 1
29276: NEG
29277: EQUAL
29278: IFFALSE 29282
// continue ;
29280: GO 29238
// PrepareHuman ( false , i , skill ) ;
29282: LD_INT 0
29284: PPUSH
29285: LD_VAR 0 8
29289: PPUSH
29290: LD_VAR 0 4
29294: PPUSH
29295: CALL_OW 380
// un := CreateHuman ;
29299: LD_ADDR_VAR 0 14
29303: PUSH
29304: CALL_OW 44
29308: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
29309: LD_VAR 0 14
29313: PPUSH
29314: LD_VAR 0 1
29318: PPUSH
29319: CALL_OW 250
29323: PPUSH
29324: LD_VAR 0 1
29328: PPUSH
29329: CALL_OW 251
29333: PPUSH
29334: LD_INT 10
29336: PPUSH
29337: LD_INT 0
29339: PPUSH
29340: CALL_OW 50
// result := result ^ un ;
29344: LD_ADDR_VAR 0 7
29348: PUSH
29349: LD_VAR 0 7
29353: PUSH
29354: LD_VAR 0 14
29358: ADD
29359: ST_TO_ADDR
// end ;
29360: GO 29238
29362: POP
29363: POP
// end ; end ;
29364: LD_VAR 0 7
29368: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
29369: LD_INT 0
29371: PPUSH
29372: PPUSH
29373: PPUSH
29374: PPUSH
29375: PPUSH
29376: PPUSH
29377: PPUSH
29378: PPUSH
29379: PPUSH
29380: PPUSH
29381: PPUSH
29382: PPUSH
29383: PPUSH
29384: PPUSH
29385: PPUSH
29386: PPUSH
// result := false ;
29387: LD_ADDR_VAR 0 3
29391: PUSH
29392: LD_INT 0
29394: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
29395: LD_VAR 0 1
29399: NOT
29400: PUSH
29401: LD_VAR 0 1
29405: PPUSH
29406: CALL_OW 266
29410: PUSH
29411: LD_INT 32
29413: PUSH
29414: LD_INT 33
29416: PUSH
29417: EMPTY
29418: LIST
29419: LIST
29420: IN
29421: NOT
29422: OR
29423: IFFALSE 29427
// exit ;
29425: GO 30536
// nat := GetNation ( tower ) ;
29427: LD_ADDR_VAR 0 12
29431: PUSH
29432: LD_VAR 0 1
29436: PPUSH
29437: CALL_OW 248
29441: ST_TO_ADDR
// side := GetSide ( tower ) ;
29442: LD_ADDR_VAR 0 16
29446: PUSH
29447: LD_VAR 0 1
29451: PPUSH
29452: CALL_OW 255
29456: ST_TO_ADDR
// x := GetX ( tower ) ;
29457: LD_ADDR_VAR 0 10
29461: PUSH
29462: LD_VAR 0 1
29466: PPUSH
29467: CALL_OW 250
29471: ST_TO_ADDR
// y := GetY ( tower ) ;
29472: LD_ADDR_VAR 0 11
29476: PUSH
29477: LD_VAR 0 1
29481: PPUSH
29482: CALL_OW 251
29486: ST_TO_ADDR
// if not x or not y then
29487: LD_VAR 0 10
29491: NOT
29492: PUSH
29493: LD_VAR 0 11
29497: NOT
29498: OR
29499: IFFALSE 29503
// exit ;
29501: GO 30536
// weapon := 0 ;
29503: LD_ADDR_VAR 0 18
29507: PUSH
29508: LD_INT 0
29510: ST_TO_ADDR
// fac_list := [ ] ;
29511: LD_ADDR_VAR 0 17
29515: PUSH
29516: EMPTY
29517: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area , false ) , [ f_btype , b_factory ] ) ;
29518: LD_ADDR_VAR 0 6
29522: PUSH
29523: LD_VAR 0 1
29527: PPUSH
29528: CALL_OW 274
29532: PPUSH
29533: LD_VAR 0 2
29537: PPUSH
29538: LD_INT 0
29540: PPUSH
29541: CALL 27107 0 3
29545: PPUSH
29546: LD_INT 30
29548: PUSH
29549: LD_INT 3
29551: PUSH
29552: EMPTY
29553: LIST
29554: LIST
29555: PPUSH
29556: CALL_OW 72
29560: ST_TO_ADDR
// if not factories then
29561: LD_VAR 0 6
29565: NOT
29566: IFFALSE 29570
// exit ;
29568: GO 30536
// for i in factories do
29570: LD_ADDR_VAR 0 8
29574: PUSH
29575: LD_VAR 0 6
29579: PUSH
29580: FOR_IN
29581: IFFALSE 29606
// fac_list := fac_list union AvailableWeaponList ( i ) ;
29583: LD_ADDR_VAR 0 17
29587: PUSH
29588: LD_VAR 0 17
29592: PUSH
29593: LD_VAR 0 8
29597: PPUSH
29598: CALL_OW 478
29602: UNION
29603: ST_TO_ADDR
29604: GO 29580
29606: POP
29607: POP
// if not fac_list then
29608: LD_VAR 0 17
29612: NOT
29613: IFFALSE 29617
// exit ;
29615: GO 30536
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
29617: LD_ADDR_VAR 0 5
29621: PUSH
29622: LD_INT 4
29624: PUSH
29625: LD_INT 5
29627: PUSH
29628: LD_INT 9
29630: PUSH
29631: LD_INT 10
29633: PUSH
29634: LD_INT 6
29636: PUSH
29637: LD_INT 7
29639: PUSH
29640: LD_INT 11
29642: PUSH
29643: EMPTY
29644: LIST
29645: LIST
29646: LIST
29647: LIST
29648: LIST
29649: LIST
29650: LIST
29651: PUSH
29652: LD_INT 27
29654: PUSH
29655: LD_INT 28
29657: PUSH
29658: LD_INT 26
29660: PUSH
29661: LD_INT 30
29663: PUSH
29664: EMPTY
29665: LIST
29666: LIST
29667: LIST
29668: LIST
29669: PUSH
29670: LD_INT 43
29672: PUSH
29673: LD_INT 44
29675: PUSH
29676: LD_INT 46
29678: PUSH
29679: LD_INT 45
29681: PUSH
29682: LD_INT 47
29684: PUSH
29685: LD_INT 49
29687: PUSH
29688: EMPTY
29689: LIST
29690: LIST
29691: LIST
29692: LIST
29693: LIST
29694: LIST
29695: PUSH
29696: EMPTY
29697: LIST
29698: LIST
29699: LIST
29700: PUSH
29701: LD_VAR 0 12
29705: ARRAY
29706: ST_TO_ADDR
// list := list isect fac_list ;
29707: LD_ADDR_VAR 0 5
29711: PUSH
29712: LD_VAR 0 5
29716: PUSH
29717: LD_VAR 0 17
29721: ISECT
29722: ST_TO_ADDR
// if not list then
29723: LD_VAR 0 5
29727: NOT
29728: IFFALSE 29732
// exit ;
29730: GO 30536
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
29732: LD_VAR 0 12
29736: PUSH
29737: LD_INT 3
29739: EQUAL
29740: PUSH
29741: LD_INT 49
29743: PUSH
29744: LD_VAR 0 5
29748: IN
29749: AND
29750: PUSH
29751: LD_INT 31
29753: PPUSH
29754: LD_VAR 0 16
29758: PPUSH
29759: CALL_OW 321
29763: PUSH
29764: LD_INT 2
29766: EQUAL
29767: AND
29768: IFFALSE 29828
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
29770: LD_INT 22
29772: PUSH
29773: LD_VAR 0 16
29777: PUSH
29778: EMPTY
29779: LIST
29780: LIST
29781: PUSH
29782: LD_INT 35
29784: PUSH
29785: LD_INT 49
29787: PUSH
29788: EMPTY
29789: LIST
29790: LIST
29791: PUSH
29792: LD_INT 91
29794: PUSH
29795: LD_VAR 0 1
29799: PUSH
29800: LD_INT 10
29802: PUSH
29803: EMPTY
29804: LIST
29805: LIST
29806: LIST
29807: PUSH
29808: EMPTY
29809: LIST
29810: LIST
29811: LIST
29812: PPUSH
29813: CALL_OW 69
29817: NOT
29818: IFFALSE 29828
// weapon := ru_time_lapser ;
29820: LD_ADDR_VAR 0 18
29824: PUSH
29825: LD_INT 49
29827: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
29828: LD_VAR 0 12
29832: PUSH
29833: LD_INT 1
29835: PUSH
29836: LD_INT 2
29838: PUSH
29839: EMPTY
29840: LIST
29841: LIST
29842: IN
29843: PUSH
29844: LD_INT 11
29846: PUSH
29847: LD_VAR 0 5
29851: IN
29852: PUSH
29853: LD_INT 30
29855: PUSH
29856: LD_VAR 0 5
29860: IN
29861: OR
29862: AND
29863: PUSH
29864: LD_INT 6
29866: PPUSH
29867: LD_VAR 0 16
29871: PPUSH
29872: CALL_OW 321
29876: PUSH
29877: LD_INT 2
29879: EQUAL
29880: AND
29881: IFFALSE 30046
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
29883: LD_INT 22
29885: PUSH
29886: LD_VAR 0 16
29890: PUSH
29891: EMPTY
29892: LIST
29893: LIST
29894: PUSH
29895: LD_INT 2
29897: PUSH
29898: LD_INT 35
29900: PUSH
29901: LD_INT 11
29903: PUSH
29904: EMPTY
29905: LIST
29906: LIST
29907: PUSH
29908: LD_INT 35
29910: PUSH
29911: LD_INT 30
29913: PUSH
29914: EMPTY
29915: LIST
29916: LIST
29917: PUSH
29918: EMPTY
29919: LIST
29920: LIST
29921: LIST
29922: PUSH
29923: LD_INT 91
29925: PUSH
29926: LD_VAR 0 1
29930: PUSH
29931: LD_INT 18
29933: PUSH
29934: EMPTY
29935: LIST
29936: LIST
29937: LIST
29938: PUSH
29939: EMPTY
29940: LIST
29941: LIST
29942: LIST
29943: PPUSH
29944: CALL_OW 69
29948: NOT
29949: PUSH
29950: LD_INT 22
29952: PUSH
29953: LD_VAR 0 16
29957: PUSH
29958: EMPTY
29959: LIST
29960: LIST
29961: PUSH
29962: LD_INT 2
29964: PUSH
29965: LD_INT 30
29967: PUSH
29968: LD_INT 32
29970: PUSH
29971: EMPTY
29972: LIST
29973: LIST
29974: PUSH
29975: LD_INT 30
29977: PUSH
29978: LD_INT 33
29980: PUSH
29981: EMPTY
29982: LIST
29983: LIST
29984: PUSH
29985: EMPTY
29986: LIST
29987: LIST
29988: LIST
29989: PUSH
29990: LD_INT 91
29992: PUSH
29993: LD_VAR 0 1
29997: PUSH
29998: LD_INT 12
30000: PUSH
30001: EMPTY
30002: LIST
30003: LIST
30004: LIST
30005: PUSH
30006: EMPTY
30007: LIST
30008: LIST
30009: LIST
30010: PUSH
30011: EMPTY
30012: LIST
30013: PPUSH
30014: CALL_OW 69
30018: PUSH
30019: LD_INT 2
30021: GREATER
30022: AND
30023: IFFALSE 30046
// weapon := [ us_radar , ar_radar ] [ nat ] ;
30025: LD_ADDR_VAR 0 18
30029: PUSH
30030: LD_INT 11
30032: PUSH
30033: LD_INT 30
30035: PUSH
30036: EMPTY
30037: LIST
30038: LIST
30039: PUSH
30040: LD_VAR 0 12
30044: ARRAY
30045: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
30046: LD_VAR 0 18
30050: NOT
30051: PUSH
30052: LD_INT 40
30054: PPUSH
30055: LD_VAR 0 16
30059: PPUSH
30060: CALL_OW 321
30064: PUSH
30065: LD_INT 2
30067: EQUAL
30068: AND
30069: PUSH
30070: LD_INT 7
30072: PUSH
30073: LD_VAR 0 5
30077: IN
30078: PUSH
30079: LD_INT 28
30081: PUSH
30082: LD_VAR 0 5
30086: IN
30087: OR
30088: PUSH
30089: LD_INT 45
30091: PUSH
30092: LD_VAR 0 5
30096: IN
30097: OR
30098: AND
30099: IFFALSE 30353
// begin hex := GetHexInfo ( x , y ) ;
30101: LD_ADDR_VAR 0 4
30105: PUSH
30106: LD_VAR 0 10
30110: PPUSH
30111: LD_VAR 0 11
30115: PPUSH
30116: CALL_OW 546
30120: ST_TO_ADDR
// if hex [ 1 ] then
30121: LD_VAR 0 4
30125: PUSH
30126: LD_INT 1
30128: ARRAY
30129: IFFALSE 30133
// exit ;
30131: GO 30536
// height := hex [ 2 ] ;
30133: LD_ADDR_VAR 0 15
30137: PUSH
30138: LD_VAR 0 4
30142: PUSH
30143: LD_INT 2
30145: ARRAY
30146: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
30147: LD_ADDR_VAR 0 14
30151: PUSH
30152: LD_INT 0
30154: PUSH
30155: LD_INT 2
30157: PUSH
30158: LD_INT 3
30160: PUSH
30161: LD_INT 5
30163: PUSH
30164: EMPTY
30165: LIST
30166: LIST
30167: LIST
30168: LIST
30169: ST_TO_ADDR
// for i in tmp do
30170: LD_ADDR_VAR 0 8
30174: PUSH
30175: LD_VAR 0 14
30179: PUSH
30180: FOR_IN
30181: IFFALSE 30351
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
30183: LD_ADDR_VAR 0 9
30187: PUSH
30188: LD_VAR 0 10
30192: PPUSH
30193: LD_VAR 0 8
30197: PPUSH
30198: LD_INT 5
30200: PPUSH
30201: CALL_OW 272
30205: PUSH
30206: LD_VAR 0 11
30210: PPUSH
30211: LD_VAR 0 8
30215: PPUSH
30216: LD_INT 5
30218: PPUSH
30219: CALL_OW 273
30223: PUSH
30224: EMPTY
30225: LIST
30226: LIST
30227: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
30228: LD_VAR 0 9
30232: PUSH
30233: LD_INT 1
30235: ARRAY
30236: PPUSH
30237: LD_VAR 0 9
30241: PUSH
30242: LD_INT 2
30244: ARRAY
30245: PPUSH
30246: CALL_OW 488
30250: IFFALSE 30349
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
30252: LD_ADDR_VAR 0 4
30256: PUSH
30257: LD_VAR 0 9
30261: PUSH
30262: LD_INT 1
30264: ARRAY
30265: PPUSH
30266: LD_VAR 0 9
30270: PUSH
30271: LD_INT 2
30273: ARRAY
30274: PPUSH
30275: CALL_OW 546
30279: ST_TO_ADDR
// if hex [ 1 ] then
30280: LD_VAR 0 4
30284: PUSH
30285: LD_INT 1
30287: ARRAY
30288: IFFALSE 30292
// continue ;
30290: GO 30180
// h := hex [ 2 ] ;
30292: LD_ADDR_VAR 0 13
30296: PUSH
30297: LD_VAR 0 4
30301: PUSH
30302: LD_INT 2
30304: ARRAY
30305: ST_TO_ADDR
// if h + 7 < height then
30306: LD_VAR 0 13
30310: PUSH
30311: LD_INT 7
30313: PLUS
30314: PUSH
30315: LD_VAR 0 15
30319: LESS
30320: IFFALSE 30349
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
30322: LD_ADDR_VAR 0 18
30326: PUSH
30327: LD_INT 7
30329: PUSH
30330: LD_INT 28
30332: PUSH
30333: LD_INT 45
30335: PUSH
30336: EMPTY
30337: LIST
30338: LIST
30339: LIST
30340: PUSH
30341: LD_VAR 0 12
30345: ARRAY
30346: ST_TO_ADDR
// break ;
30347: GO 30351
// end ; end ; end ;
30349: GO 30180
30351: POP
30352: POP
// end ; if not weapon then
30353: LD_VAR 0 18
30357: NOT
30358: IFFALSE 30418
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
30360: LD_ADDR_VAR 0 5
30364: PUSH
30365: LD_VAR 0 5
30369: PUSH
30370: LD_INT 11
30372: PUSH
30373: LD_INT 30
30375: PUSH
30376: LD_INT 49
30378: PUSH
30379: EMPTY
30380: LIST
30381: LIST
30382: LIST
30383: DIFF
30384: ST_TO_ADDR
// if not list then
30385: LD_VAR 0 5
30389: NOT
30390: IFFALSE 30394
// exit ;
30392: GO 30536
// weapon := list [ rand ( 1 , list ) ] ;
30394: LD_ADDR_VAR 0 18
30398: PUSH
30399: LD_VAR 0 5
30403: PUSH
30404: LD_INT 1
30406: PPUSH
30407: LD_VAR 0 5
30411: PPUSH
30412: CALL_OW 12
30416: ARRAY
30417: ST_TO_ADDR
// end ; if weapon then
30418: LD_VAR 0 18
30422: IFFALSE 30536
// begin tmp := CostOfWeapon ( weapon ) ;
30424: LD_ADDR_VAR 0 14
30428: PUSH
30429: LD_VAR 0 18
30433: PPUSH
30434: CALL_OW 451
30438: ST_TO_ADDR
// j := GetBase ( tower ) ;
30439: LD_ADDR_VAR 0 9
30443: PUSH
30444: LD_VAR 0 1
30448: PPUSH
30449: CALL_OW 274
30453: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
30454: LD_VAR 0 9
30458: PPUSH
30459: LD_INT 1
30461: PPUSH
30462: CALL_OW 275
30466: PUSH
30467: LD_VAR 0 14
30471: PUSH
30472: LD_INT 1
30474: ARRAY
30475: GREATEREQUAL
30476: PUSH
30477: LD_VAR 0 9
30481: PPUSH
30482: LD_INT 2
30484: PPUSH
30485: CALL_OW 275
30489: PUSH
30490: LD_VAR 0 14
30494: PUSH
30495: LD_INT 2
30497: ARRAY
30498: GREATEREQUAL
30499: AND
30500: PUSH
30501: LD_VAR 0 9
30505: PPUSH
30506: LD_INT 3
30508: PPUSH
30509: CALL_OW 275
30513: PUSH
30514: LD_VAR 0 14
30518: PUSH
30519: LD_INT 3
30521: ARRAY
30522: GREATEREQUAL
30523: AND
30524: IFFALSE 30536
// result := weapon ;
30526: LD_ADDR_VAR 0 3
30530: PUSH
30531: LD_VAR 0 18
30535: ST_TO_ADDR
// end ; end ;
30536: LD_VAR 0 3
30540: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
30541: LD_INT 0
30543: PPUSH
30544: PPUSH
// result := true ;
30545: LD_ADDR_VAR 0 3
30549: PUSH
30550: LD_INT 1
30552: ST_TO_ADDR
// if array1 = array2 then
30553: LD_VAR 0 1
30557: PUSH
30558: LD_VAR 0 2
30562: EQUAL
30563: IFFALSE 30623
// begin for i = 1 to array1 do
30565: LD_ADDR_VAR 0 4
30569: PUSH
30570: DOUBLE
30571: LD_INT 1
30573: DEC
30574: ST_TO_ADDR
30575: LD_VAR 0 1
30579: PUSH
30580: FOR_TO
30581: IFFALSE 30619
// if array1 [ i ] <> array2 [ i ] then
30583: LD_VAR 0 1
30587: PUSH
30588: LD_VAR 0 4
30592: ARRAY
30593: PUSH
30594: LD_VAR 0 2
30598: PUSH
30599: LD_VAR 0 4
30603: ARRAY
30604: NONEQUAL
30605: IFFALSE 30617
// begin result := false ;
30607: LD_ADDR_VAR 0 3
30611: PUSH
30612: LD_INT 0
30614: ST_TO_ADDR
// break ;
30615: GO 30619
// end ;
30617: GO 30580
30619: POP
30620: POP
// end else
30621: GO 30631
// result := false ;
30623: LD_ADDR_VAR 0 3
30627: PUSH
30628: LD_INT 0
30630: ST_TO_ADDR
// end ;
30631: LD_VAR 0 3
30635: RET
// export function CompareArrayValues ( array1 , array2 ) ; var i ; begin
30636: LD_INT 0
30638: PPUSH
30639: PPUSH
// if not array1 or not array2 then
30640: LD_VAR 0 1
30644: NOT
30645: PUSH
30646: LD_VAR 0 2
30650: NOT
30651: OR
30652: IFFALSE 30656
// exit ;
30654: GO 30720
// result := true ;
30656: LD_ADDR_VAR 0 3
30660: PUSH
30661: LD_INT 1
30663: ST_TO_ADDR
// for i = 1 to array1 do
30664: LD_ADDR_VAR 0 4
30668: PUSH
30669: DOUBLE
30670: LD_INT 1
30672: DEC
30673: ST_TO_ADDR
30674: LD_VAR 0 1
30678: PUSH
30679: FOR_TO
30680: IFFALSE 30718
// if array1 [ i ] <> array2 [ i ] then
30682: LD_VAR 0 1
30686: PUSH
30687: LD_VAR 0 4
30691: ARRAY
30692: PUSH
30693: LD_VAR 0 2
30697: PUSH
30698: LD_VAR 0 4
30702: ARRAY
30703: NONEQUAL
30704: IFFALSE 30716
// begin result := false ;
30706: LD_ADDR_VAR 0 3
30710: PUSH
30711: LD_INT 0
30713: ST_TO_ADDR
// break ;
30714: GO 30718
// end ;
30716: GO 30679
30718: POP
30719: POP
// end ;
30720: LD_VAR 0 3
30724: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
30725: LD_INT 0
30727: PPUSH
30728: PPUSH
30729: PPUSH
// pom := GetBase ( fac ) ;
30730: LD_ADDR_VAR 0 5
30734: PUSH
30735: LD_VAR 0 1
30739: PPUSH
30740: CALL_OW 274
30744: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
30745: LD_ADDR_VAR 0 4
30749: PUSH
30750: LD_VAR 0 2
30754: PUSH
30755: LD_INT 1
30757: ARRAY
30758: PPUSH
30759: LD_VAR 0 2
30763: PUSH
30764: LD_INT 2
30766: ARRAY
30767: PPUSH
30768: LD_VAR 0 2
30772: PUSH
30773: LD_INT 3
30775: ARRAY
30776: PPUSH
30777: LD_VAR 0 2
30781: PUSH
30782: LD_INT 4
30784: ARRAY
30785: PPUSH
30786: CALL_OW 449
30790: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
30791: LD_ADDR_VAR 0 3
30795: PUSH
30796: LD_VAR 0 5
30800: PPUSH
30801: LD_INT 1
30803: PPUSH
30804: CALL_OW 275
30808: PUSH
30809: LD_VAR 0 4
30813: PUSH
30814: LD_INT 1
30816: ARRAY
30817: GREATEREQUAL
30818: PUSH
30819: LD_VAR 0 5
30823: PPUSH
30824: LD_INT 2
30826: PPUSH
30827: CALL_OW 275
30831: PUSH
30832: LD_VAR 0 4
30836: PUSH
30837: LD_INT 2
30839: ARRAY
30840: GREATEREQUAL
30841: AND
30842: PUSH
30843: LD_VAR 0 5
30847: PPUSH
30848: LD_INT 3
30850: PPUSH
30851: CALL_OW 275
30855: PUSH
30856: LD_VAR 0 4
30860: PUSH
30861: LD_INT 3
30863: ARRAY
30864: GREATEREQUAL
30865: AND
30866: ST_TO_ADDR
// end ;
30867: LD_VAR 0 3
30871: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
30872: LD_INT 0
30874: PPUSH
30875: PPUSH
30876: PPUSH
30877: PPUSH
// pom := GetBase ( building ) ;
30878: LD_ADDR_VAR 0 3
30882: PUSH
30883: LD_VAR 0 1
30887: PPUSH
30888: CALL_OW 274
30892: ST_TO_ADDR
// if not pom then
30893: LD_VAR 0 3
30897: NOT
30898: IFFALSE 30902
// exit ;
30900: GO 31072
// btype := GetBType ( building ) ;
30902: LD_ADDR_VAR 0 5
30906: PUSH
30907: LD_VAR 0 1
30911: PPUSH
30912: CALL_OW 266
30916: ST_TO_ADDR
// if btype = b_armoury then
30917: LD_VAR 0 5
30921: PUSH
30922: LD_INT 4
30924: EQUAL
30925: IFFALSE 30935
// btype := b_barracks ;
30927: LD_ADDR_VAR 0 5
30931: PUSH
30932: LD_INT 5
30934: ST_TO_ADDR
// if btype = b_depot then
30935: LD_VAR 0 5
30939: PUSH
30940: LD_INT 0
30942: EQUAL
30943: IFFALSE 30953
// btype := b_warehouse ;
30945: LD_ADDR_VAR 0 5
30949: PUSH
30950: LD_INT 1
30952: ST_TO_ADDR
// if btype = b_workshop then
30953: LD_VAR 0 5
30957: PUSH
30958: LD_INT 2
30960: EQUAL
30961: IFFALSE 30971
// btype := b_factory ;
30963: LD_ADDR_VAR 0 5
30967: PUSH
30968: LD_INT 3
30970: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
30971: LD_ADDR_VAR 0 4
30975: PUSH
30976: LD_VAR 0 5
30980: PPUSH
30981: LD_VAR 0 1
30985: PPUSH
30986: CALL_OW 248
30990: PPUSH
30991: CALL_OW 450
30995: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
30996: LD_ADDR_VAR 0 2
31000: PUSH
31001: LD_VAR 0 3
31005: PPUSH
31006: LD_INT 1
31008: PPUSH
31009: CALL_OW 275
31013: PUSH
31014: LD_VAR 0 4
31018: PUSH
31019: LD_INT 1
31021: ARRAY
31022: GREATEREQUAL
31023: PUSH
31024: LD_VAR 0 3
31028: PPUSH
31029: LD_INT 2
31031: PPUSH
31032: CALL_OW 275
31036: PUSH
31037: LD_VAR 0 4
31041: PUSH
31042: LD_INT 2
31044: ARRAY
31045: GREATEREQUAL
31046: AND
31047: PUSH
31048: LD_VAR 0 3
31052: PPUSH
31053: LD_INT 3
31055: PPUSH
31056: CALL_OW 275
31060: PUSH
31061: LD_VAR 0 4
31065: PUSH
31066: LD_INT 3
31068: ARRAY
31069: GREATEREQUAL
31070: AND
31071: ST_TO_ADDR
// end ;
31072: LD_VAR 0 2
31076: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
31077: LD_INT 0
31079: PPUSH
31080: PPUSH
31081: PPUSH
// pom := GetBase ( building ) ;
31082: LD_ADDR_VAR 0 4
31086: PUSH
31087: LD_VAR 0 1
31091: PPUSH
31092: CALL_OW 274
31096: ST_TO_ADDR
// if not pom then
31097: LD_VAR 0 4
31101: NOT
31102: IFFALSE 31106
// exit ;
31104: GO 31207
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
31106: LD_ADDR_VAR 0 5
31110: PUSH
31111: LD_VAR 0 2
31115: PPUSH
31116: LD_VAR 0 1
31120: PPUSH
31121: CALL_OW 248
31125: PPUSH
31126: CALL_OW 450
31130: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
31131: LD_ADDR_VAR 0 3
31135: PUSH
31136: LD_VAR 0 4
31140: PPUSH
31141: LD_INT 1
31143: PPUSH
31144: CALL_OW 275
31148: PUSH
31149: LD_VAR 0 5
31153: PUSH
31154: LD_INT 1
31156: ARRAY
31157: GREATEREQUAL
31158: PUSH
31159: LD_VAR 0 4
31163: PPUSH
31164: LD_INT 2
31166: PPUSH
31167: CALL_OW 275
31171: PUSH
31172: LD_VAR 0 5
31176: PUSH
31177: LD_INT 2
31179: ARRAY
31180: GREATEREQUAL
31181: AND
31182: PUSH
31183: LD_VAR 0 4
31187: PPUSH
31188: LD_INT 3
31190: PPUSH
31191: CALL_OW 275
31195: PUSH
31196: LD_VAR 0 5
31200: PUSH
31201: LD_INT 3
31203: ARRAY
31204: GREATEREQUAL
31205: AND
31206: ST_TO_ADDR
// end ;
31207: LD_VAR 0 3
31211: RET
// export function TryClearPlaceForBuilding ( btype , x , y , d , buildings , cleaners , parking ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep , driver ; begin
31212: LD_INT 0
31214: PPUSH
31215: PPUSH
31216: PPUSH
31217: PPUSH
31218: PPUSH
31219: PPUSH
31220: PPUSH
31221: PPUSH
31222: PPUSH
31223: PPUSH
31224: PPUSH
// result := false ;
31225: LD_ADDR_VAR 0 8
31229: PUSH
31230: LD_INT 0
31232: ST_TO_ADDR
// if not buildings or not btype or not x or not y then
31233: LD_VAR 0 5
31237: NOT
31238: PUSH
31239: LD_VAR 0 1
31243: NOT
31244: OR
31245: PUSH
31246: LD_VAR 0 2
31250: NOT
31251: OR
31252: PUSH
31253: LD_VAR 0 3
31257: NOT
31258: OR
31259: IFFALSE 31263
// exit ;
31261: GO 32077
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( buildings [ 1 ] ) , 0 ) ;
31263: LD_ADDR_VAR 0 14
31267: PUSH
31268: LD_VAR 0 1
31272: PPUSH
31273: LD_VAR 0 2
31277: PPUSH
31278: LD_VAR 0 3
31282: PPUSH
31283: LD_VAR 0 4
31287: PPUSH
31288: LD_VAR 0 5
31292: PUSH
31293: LD_INT 1
31295: ARRAY
31296: PPUSH
31297: CALL_OW 248
31301: PPUSH
31302: LD_INT 0
31304: PPUSH
31305: CALL 33310 0 6
31309: ST_TO_ADDR
// if not hexes then
31310: LD_VAR 0 14
31314: NOT
31315: IFFALSE 31319
// exit ;
31317: GO 32077
// dep := UnitFilter ( buildings , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
31319: LD_ADDR_VAR 0 17
31323: PUSH
31324: LD_VAR 0 5
31328: PPUSH
31329: LD_INT 22
31331: PUSH
31332: LD_VAR 0 13
31336: PPUSH
31337: CALL_OW 255
31341: PUSH
31342: EMPTY
31343: LIST
31344: LIST
31345: PUSH
31346: LD_INT 2
31348: PUSH
31349: LD_INT 30
31351: PUSH
31352: LD_INT 0
31354: PUSH
31355: EMPTY
31356: LIST
31357: LIST
31358: PUSH
31359: LD_INT 30
31361: PUSH
31362: LD_INT 1
31364: PUSH
31365: EMPTY
31366: LIST
31367: LIST
31368: PUSH
31369: EMPTY
31370: LIST
31371: LIST
31372: LIST
31373: PUSH
31374: EMPTY
31375: LIST
31376: LIST
31377: PPUSH
31378: CALL_OW 72
31382: ST_TO_ADDR
// for i = 1 to hexes do
31383: LD_ADDR_VAR 0 9
31387: PUSH
31388: DOUBLE
31389: LD_INT 1
31391: DEC
31392: ST_TO_ADDR
31393: LD_VAR 0 14
31397: PUSH
31398: FOR_TO
31399: IFFALSE 32075
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
31401: LD_ADDR_VAR 0 13
31405: PUSH
31406: LD_VAR 0 14
31410: PUSH
31411: LD_VAR 0 9
31415: ARRAY
31416: PUSH
31417: LD_INT 1
31419: ARRAY
31420: PPUSH
31421: LD_VAR 0 14
31425: PUSH
31426: LD_VAR 0 9
31430: ARRAY
31431: PUSH
31432: LD_INT 2
31434: ARRAY
31435: PPUSH
31436: CALL_OW 428
31440: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
31441: LD_VAR 0 14
31445: PUSH
31446: LD_VAR 0 9
31450: ARRAY
31451: PUSH
31452: LD_INT 1
31454: ARRAY
31455: PPUSH
31456: LD_VAR 0 14
31460: PUSH
31461: LD_VAR 0 9
31465: ARRAY
31466: PUSH
31467: LD_INT 2
31469: ARRAY
31470: PPUSH
31471: CALL_OW 351
31475: PUSH
31476: LD_VAR 0 14
31480: PUSH
31481: LD_VAR 0 9
31485: ARRAY
31486: PUSH
31487: LD_INT 1
31489: ARRAY
31490: PPUSH
31491: LD_VAR 0 14
31495: PUSH
31496: LD_VAR 0 9
31500: ARRAY
31501: PUSH
31502: LD_INT 2
31504: ARRAY
31505: PPUSH
31506: CALL_OW 488
31510: NOT
31511: OR
31512: PUSH
31513: LD_VAR 0 13
31517: PPUSH
31518: CALL_OW 247
31522: PUSH
31523: LD_INT 3
31525: EQUAL
31526: OR
31527: IFFALSE 31533
// exit ;
31529: POP
31530: POP
31531: GO 32077
// if not tmp then
31533: LD_VAR 0 13
31537: NOT
31538: IFFALSE 31542
// continue ;
31540: GO 31398
// result := true ;
31542: LD_ADDR_VAR 0 8
31546: PUSH
31547: LD_INT 1
31549: ST_TO_ADDR
// if cleaners and GetType ( tmp ) = unit_vehicle and GetControl ( tmp ) = control_manual then
31550: LD_VAR 0 6
31554: PUSH
31555: LD_VAR 0 13
31559: PPUSH
31560: CALL_OW 247
31564: PUSH
31565: LD_INT 2
31567: EQUAL
31568: AND
31569: PUSH
31570: LD_VAR 0 13
31574: PPUSH
31575: CALL_OW 263
31579: PUSH
31580: LD_INT 1
31582: EQUAL
31583: AND
31584: IFFALSE 31748
// begin if IsDrivenBy ( tmp ) then
31586: LD_VAR 0 13
31590: PPUSH
31591: CALL_OW 311
31595: IFFALSE 31599
// continue ;
31597: GO 31398
// if UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) then
31599: LD_VAR 0 6
31603: PPUSH
31604: LD_INT 3
31606: PUSH
31607: LD_INT 60
31609: PUSH
31610: EMPTY
31611: LIST
31612: PUSH
31613: EMPTY
31614: LIST
31615: LIST
31616: PUSH
31617: LD_INT 3
31619: PUSH
31620: LD_INT 55
31622: PUSH
31623: EMPTY
31624: LIST
31625: PUSH
31626: EMPTY
31627: LIST
31628: LIST
31629: PUSH
31630: EMPTY
31631: LIST
31632: LIST
31633: PPUSH
31634: CALL_OW 72
31638: IFFALSE 31746
// begin driver := UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) [ 1 ] ;
31640: LD_ADDR_VAR 0 18
31644: PUSH
31645: LD_VAR 0 6
31649: PPUSH
31650: LD_INT 3
31652: PUSH
31653: LD_INT 60
31655: PUSH
31656: EMPTY
31657: LIST
31658: PUSH
31659: EMPTY
31660: LIST
31661: LIST
31662: PUSH
31663: LD_INT 3
31665: PUSH
31666: LD_INT 55
31668: PUSH
31669: EMPTY
31670: LIST
31671: PUSH
31672: EMPTY
31673: LIST
31674: LIST
31675: PUSH
31676: EMPTY
31677: LIST
31678: LIST
31679: PPUSH
31680: CALL_OW 72
31684: PUSH
31685: LD_INT 1
31687: ARRAY
31688: ST_TO_ADDR
// if IsInUnit ( driver ) then
31689: LD_VAR 0 18
31693: PPUSH
31694: CALL_OW 310
31698: IFFALSE 31709
// ComExit ( driver ) ;
31700: LD_VAR 0 18
31704: PPUSH
31705: CALL 57090 0 1
// AddComEnterUnit ( driver , tmp ) ;
31709: LD_VAR 0 18
31713: PPUSH
31714: LD_VAR 0 13
31718: PPUSH
31719: CALL_OW 180
// AddComMoveToArea ( driver , parking ) ;
31723: LD_VAR 0 18
31727: PPUSH
31728: LD_VAR 0 7
31732: PPUSH
31733: CALL_OW 173
// AddComExitVehicle ( driver ) ;
31737: LD_VAR 0 18
31741: PPUSH
31742: CALL_OW 181
// end ; continue ;
31746: GO 31398
// end ; if not cleaners or not tmp in cleaners then
31748: LD_VAR 0 6
31752: NOT
31753: PUSH
31754: LD_VAR 0 13
31758: PUSH
31759: LD_VAR 0 6
31763: IN
31764: NOT
31765: OR
31766: IFFALSE 32073
// begin if dep then
31768: LD_VAR 0 17
31772: IFFALSE 31908
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
31774: LD_ADDR_VAR 0 16
31778: PUSH
31779: LD_VAR 0 17
31783: PUSH
31784: LD_INT 1
31786: ARRAY
31787: PPUSH
31788: CALL_OW 250
31792: PPUSH
31793: LD_VAR 0 17
31797: PUSH
31798: LD_INT 1
31800: ARRAY
31801: PPUSH
31802: CALL_OW 254
31806: PPUSH
31807: LD_INT 5
31809: PPUSH
31810: CALL_OW 272
31814: PUSH
31815: LD_VAR 0 17
31819: PUSH
31820: LD_INT 1
31822: ARRAY
31823: PPUSH
31824: CALL_OW 251
31828: PPUSH
31829: LD_VAR 0 17
31833: PUSH
31834: LD_INT 1
31836: ARRAY
31837: PPUSH
31838: CALL_OW 254
31842: PPUSH
31843: LD_INT 5
31845: PPUSH
31846: CALL_OW 273
31850: PUSH
31851: EMPTY
31852: LIST
31853: LIST
31854: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
31855: LD_VAR 0 16
31859: PUSH
31860: LD_INT 1
31862: ARRAY
31863: PPUSH
31864: LD_VAR 0 16
31868: PUSH
31869: LD_INT 2
31871: ARRAY
31872: PPUSH
31873: CALL_OW 488
31877: IFFALSE 31908
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
31879: LD_VAR 0 13
31883: PPUSH
31884: LD_VAR 0 16
31888: PUSH
31889: LD_INT 1
31891: ARRAY
31892: PPUSH
31893: LD_VAR 0 16
31897: PUSH
31898: LD_INT 2
31900: ARRAY
31901: PPUSH
31902: CALL_OW 111
// continue ;
31906: GO 31398
// end ; end ; r := GetDir ( tmp ) ;
31908: LD_ADDR_VAR 0 15
31912: PUSH
31913: LD_VAR 0 13
31917: PPUSH
31918: CALL_OW 254
31922: ST_TO_ADDR
// if r = 5 then
31923: LD_VAR 0 15
31927: PUSH
31928: LD_INT 5
31930: EQUAL
31931: IFFALSE 31941
// r := 0 ;
31933: LD_ADDR_VAR 0 15
31937: PUSH
31938: LD_INT 0
31940: ST_TO_ADDR
// for j = r to 5 do
31941: LD_ADDR_VAR 0 10
31945: PUSH
31946: DOUBLE
31947: LD_VAR 0 15
31951: DEC
31952: ST_TO_ADDR
31953: LD_INT 5
31955: PUSH
31956: FOR_TO
31957: IFFALSE 32071
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
31959: LD_ADDR_VAR 0 11
31963: PUSH
31964: LD_VAR 0 13
31968: PPUSH
31969: CALL_OW 250
31973: PPUSH
31974: LD_VAR 0 10
31978: PPUSH
31979: LD_INT 2
31981: PPUSH
31982: CALL_OW 272
31986: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
31987: LD_ADDR_VAR 0 12
31991: PUSH
31992: LD_VAR 0 13
31996: PPUSH
31997: CALL_OW 251
32001: PPUSH
32002: LD_VAR 0 10
32006: PPUSH
32007: LD_INT 2
32009: PPUSH
32010: CALL_OW 273
32014: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
32015: LD_VAR 0 11
32019: PPUSH
32020: LD_VAR 0 12
32024: PPUSH
32025: CALL_OW 488
32029: PUSH
32030: LD_VAR 0 11
32034: PPUSH
32035: LD_VAR 0 12
32039: PPUSH
32040: CALL_OW 428
32044: NOT
32045: AND
32046: IFFALSE 32069
// begin ComMoveXY ( tmp , _x , _y ) ;
32048: LD_VAR 0 13
32052: PPUSH
32053: LD_VAR 0 11
32057: PPUSH
32058: LD_VAR 0 12
32062: PPUSH
32063: CALL_OW 111
// break ;
32067: GO 32071
// end ; end ;
32069: GO 31956
32071: POP
32072: POP
// end ; end ;
32073: GO 31398
32075: POP
32076: POP
// end ;
32077: LD_VAR 0 8
32081: RET
// export function BuildingTechInvented ( side , btype ) ; begin
32082: LD_INT 0
32084: PPUSH
// result := true ;
32085: LD_ADDR_VAR 0 3
32089: PUSH
32090: LD_INT 1
32092: ST_TO_ADDR
// case btype of b_ext_computer , b_turret :
32093: LD_VAR 0 2
32097: PUSH
32098: LD_INT 24
32100: DOUBLE
32101: EQUAL
32102: IFTRUE 32112
32104: LD_INT 33
32106: DOUBLE
32107: EQUAL
32108: IFTRUE 32112
32110: GO 32137
32112: POP
// result := ( GetTech ( tech_ai , side ) = state_researched ) ; b_ext_radar :
32113: LD_ADDR_VAR 0 3
32117: PUSH
32118: LD_INT 32
32120: PPUSH
32121: LD_VAR 0 1
32125: PPUSH
32126: CALL_OW 321
32130: PUSH
32131: LD_INT 2
32133: EQUAL
32134: ST_TO_ADDR
32135: GO 32453
32137: LD_INT 20
32139: DOUBLE
32140: EQUAL
32141: IFTRUE 32145
32143: GO 32170
32145: POP
// result := ( GetTech ( tech_radar , side ) = state_researched ) ; b_ext_radio , b_control_tower :
32146: LD_ADDR_VAR 0 3
32150: PUSH
32151: LD_INT 6
32153: PPUSH
32154: LD_VAR 0 1
32158: PPUSH
32159: CALL_OW 321
32163: PUSH
32164: LD_INT 2
32166: EQUAL
32167: ST_TO_ADDR
32168: GO 32453
32170: LD_INT 22
32172: DOUBLE
32173: EQUAL
32174: IFTRUE 32184
32176: LD_INT 36
32178: DOUBLE
32179: EQUAL
32180: IFTRUE 32184
32182: GO 32209
32184: POP
// result := ( GetTech ( tech_remcont , side ) = state_researched ) ; b_siberite_mine :
32185: LD_ADDR_VAR 0 3
32189: PUSH
32190: LD_INT 15
32192: PPUSH
32193: LD_VAR 0 1
32197: PPUSH
32198: CALL_OW 321
32202: PUSH
32203: LD_INT 2
32205: EQUAL
32206: ST_TO_ADDR
32207: GO 32453
32209: LD_INT 30
32211: DOUBLE
32212: EQUAL
32213: IFTRUE 32217
32215: GO 32242
32217: POP
// result := ( GetTech ( tech_sibdet , side ) = state_researched ) ; b_siberite_power , b_ext_siberium :
32218: LD_ADDR_VAR 0 3
32222: PUSH
32223: LD_INT 20
32225: PPUSH
32226: LD_VAR 0 1
32230: PPUSH
32231: CALL_OW 321
32235: PUSH
32236: LD_INT 2
32238: EQUAL
32239: ST_TO_ADDR
32240: GO 32453
32242: LD_INT 28
32244: DOUBLE
32245: EQUAL
32246: IFTRUE 32256
32248: LD_INT 21
32250: DOUBLE
32251: EQUAL
32252: IFTRUE 32256
32254: GO 32281
32256: POP
// result := ( GetTech ( tech_sibpow , side ) = state_researched ) ; b_ext_track :
32257: LD_ADDR_VAR 0 3
32261: PUSH
32262: LD_INT 21
32264: PPUSH
32265: LD_VAR 0 1
32269: PPUSH
32270: CALL_OW 321
32274: PUSH
32275: LD_INT 2
32277: EQUAL
32278: ST_TO_ADDR
32279: GO 32453
32281: LD_INT 16
32283: DOUBLE
32284: EQUAL
32285: IFTRUE 32289
32287: GO 32314
32289: POP
// result := ( GetTech ( tech_track , side ) = state_researched ) ; b_ext_noncombat , b_ext_stitch :
32290: LD_ADDR_VAR 0 3
32294: PUSH
32295: LD_INT 84
32297: PPUSH
32298: LD_VAR 0 1
32302: PPUSH
32303: CALL_OW 321
32307: PUSH
32308: LD_INT 2
32310: EQUAL
32311: ST_TO_ADDR
32312: GO 32453
32314: LD_INT 19
32316: DOUBLE
32317: EQUAL
32318: IFTRUE 32328
32320: LD_INT 23
32322: DOUBLE
32323: EQUAL
32324: IFTRUE 32328
32326: GO 32353
32328: POP
// result := ( GetTech ( tech_cargo , side ) = state_researched ) ; b_ext_gun :
32329: LD_ADDR_VAR 0 3
32333: PUSH
32334: LD_INT 83
32336: PPUSH
32337: LD_VAR 0 1
32341: PPUSH
32342: CALL_OW 321
32346: PUSH
32347: LD_INT 2
32349: EQUAL
32350: ST_TO_ADDR
32351: GO 32453
32353: LD_INT 17
32355: DOUBLE
32356: EQUAL
32357: IFTRUE 32361
32359: GO 32386
32361: POP
// result := ( GetTech ( tech_gun , side ) = state_researched ) ; b_ext_rocket :
32362: LD_ADDR_VAR 0 3
32366: PUSH
32367: LD_INT 39
32369: PPUSH
32370: LD_VAR 0 1
32374: PPUSH
32375: CALL_OW 321
32379: PUSH
32380: LD_INT 2
32382: EQUAL
32383: ST_TO_ADDR
32384: GO 32453
32386: LD_INT 18
32388: DOUBLE
32389: EQUAL
32390: IFTRUE 32394
32392: GO 32419
32394: POP
// result := ( GetTech ( tech_rocket , side ) = state_researched ) ; b_solar_power :
32395: LD_ADDR_VAR 0 3
32399: PUSH
32400: LD_INT 40
32402: PPUSH
32403: LD_VAR 0 1
32407: PPUSH
32408: CALL_OW 321
32412: PUSH
32413: LD_INT 2
32415: EQUAL
32416: ST_TO_ADDR
32417: GO 32453
32419: LD_INT 27
32421: DOUBLE
32422: EQUAL
32423: IFTRUE 32427
32425: GO 32452
32427: POP
// result := ( GetTech ( tech_solpow , side ) = state_researched ) ; end ;
32428: LD_ADDR_VAR 0 3
32432: PUSH
32433: LD_INT 35
32435: PPUSH
32436: LD_VAR 0 1
32440: PPUSH
32441: CALL_OW 321
32445: PUSH
32446: LD_INT 2
32448: EQUAL
32449: ST_TO_ADDR
32450: GO 32453
32452: POP
// end ;
32453: LD_VAR 0 3
32457: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex , tech ; begin
32458: LD_INT 0
32460: PPUSH
32461: PPUSH
32462: PPUSH
32463: PPUSH
32464: PPUSH
32465: PPUSH
32466: PPUSH
32467: PPUSH
32468: PPUSH
32469: PPUSH
32470: PPUSH
// result := false ;
32471: LD_ADDR_VAR 0 6
32475: PUSH
32476: LD_INT 0
32478: ST_TO_ADDR
// if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
32479: LD_VAR 0 1
32483: NOT
32484: PUSH
32485: LD_VAR 0 1
32489: PPUSH
32490: CALL_OW 266
32494: PUSH
32495: LD_INT 0
32497: PUSH
32498: LD_INT 1
32500: PUSH
32501: EMPTY
32502: LIST
32503: LIST
32504: IN
32505: NOT
32506: OR
32507: PUSH
32508: LD_VAR 0 2
32512: NOT
32513: OR
32514: PUSH
32515: LD_VAR 0 5
32519: PUSH
32520: LD_INT 0
32522: PUSH
32523: LD_INT 1
32525: PUSH
32526: LD_INT 2
32528: PUSH
32529: LD_INT 3
32531: PUSH
32532: LD_INT 4
32534: PUSH
32535: LD_INT 5
32537: PUSH
32538: EMPTY
32539: LIST
32540: LIST
32541: LIST
32542: LIST
32543: LIST
32544: LIST
32545: IN
32546: NOT
32547: OR
32548: PUSH
32549: LD_VAR 0 3
32553: PPUSH
32554: LD_VAR 0 4
32558: PPUSH
32559: CALL_OW 488
32563: NOT
32564: OR
32565: IFFALSE 32569
// exit ;
32567: GO 33305
// side := GetSide ( depot ) ;
32569: LD_ADDR_VAR 0 9
32573: PUSH
32574: LD_VAR 0 1
32578: PPUSH
32579: CALL_OW 255
32583: ST_TO_ADDR
// if not BuildingTechInvented ( side , btype ) then
32584: LD_VAR 0 9
32588: PPUSH
32589: LD_VAR 0 2
32593: PPUSH
32594: CALL 32082 0 2
32598: NOT
32599: IFFALSE 32603
// exit ;
32601: GO 33305
// pom := GetBase ( depot ) ;
32603: LD_ADDR_VAR 0 10
32607: PUSH
32608: LD_VAR 0 1
32612: PPUSH
32613: CALL_OW 274
32617: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
32618: LD_ADDR_VAR 0 11
32622: PUSH
32623: LD_VAR 0 2
32627: PPUSH
32628: LD_VAR 0 1
32632: PPUSH
32633: CALL_OW 248
32637: PPUSH
32638: CALL_OW 450
32642: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
32643: LD_VAR 0 10
32647: PPUSH
32648: LD_INT 1
32650: PPUSH
32651: CALL_OW 275
32655: PUSH
32656: LD_VAR 0 11
32660: PUSH
32661: LD_INT 1
32663: ARRAY
32664: GREATEREQUAL
32665: PUSH
32666: LD_VAR 0 10
32670: PPUSH
32671: LD_INT 2
32673: PPUSH
32674: CALL_OW 275
32678: PUSH
32679: LD_VAR 0 11
32683: PUSH
32684: LD_INT 2
32686: ARRAY
32687: GREATEREQUAL
32688: AND
32689: PUSH
32690: LD_VAR 0 10
32694: PPUSH
32695: LD_INT 3
32697: PPUSH
32698: CALL_OW 275
32702: PUSH
32703: LD_VAR 0 11
32707: PUSH
32708: LD_INT 3
32710: ARRAY
32711: GREATEREQUAL
32712: AND
32713: NOT
32714: IFFALSE 32718
// exit ;
32716: GO 33305
// if GetBType ( depot ) = b_depot then
32718: LD_VAR 0 1
32722: PPUSH
32723: CALL_OW 266
32727: PUSH
32728: LD_INT 0
32730: EQUAL
32731: IFFALSE 32743
// dist := 28 else
32733: LD_ADDR_VAR 0 14
32737: PUSH
32738: LD_INT 28
32740: ST_TO_ADDR
32741: GO 32751
// dist := 36 ;
32743: LD_ADDR_VAR 0 14
32747: PUSH
32748: LD_INT 36
32750: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
32751: LD_VAR 0 1
32755: PPUSH
32756: LD_VAR 0 3
32760: PPUSH
32761: LD_VAR 0 4
32765: PPUSH
32766: CALL_OW 297
32770: PUSH
32771: LD_VAR 0 14
32775: GREATER
32776: IFFALSE 32780
// exit ;
32778: GO 33305
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
32780: LD_ADDR_VAR 0 12
32784: PUSH
32785: LD_VAR 0 2
32789: PPUSH
32790: LD_VAR 0 3
32794: PPUSH
32795: LD_VAR 0 4
32799: PPUSH
32800: LD_VAR 0 5
32804: PPUSH
32805: LD_VAR 0 1
32809: PPUSH
32810: CALL_OW 248
32814: PPUSH
32815: LD_INT 0
32817: PPUSH
32818: CALL 33310 0 6
32822: ST_TO_ADDR
// if not hexes then
32823: LD_VAR 0 12
32827: NOT
32828: IFFALSE 32832
// exit ;
32830: GO 33305
// hex := GetHexInfo ( x , y ) ;
32832: LD_ADDR_VAR 0 15
32836: PUSH
32837: LD_VAR 0 3
32841: PPUSH
32842: LD_VAR 0 4
32846: PPUSH
32847: CALL_OW 546
32851: ST_TO_ADDR
// if hex [ 1 ] then
32852: LD_VAR 0 15
32856: PUSH
32857: LD_INT 1
32859: ARRAY
32860: IFFALSE 32864
// exit ;
32862: GO 33305
// height := hex [ 2 ] ;
32864: LD_ADDR_VAR 0 13
32868: PUSH
32869: LD_VAR 0 15
32873: PUSH
32874: LD_INT 2
32876: ARRAY
32877: ST_TO_ADDR
// for i = 1 to hexes do
32878: LD_ADDR_VAR 0 7
32882: PUSH
32883: DOUBLE
32884: LD_INT 1
32886: DEC
32887: ST_TO_ADDR
32888: LD_VAR 0 12
32892: PUSH
32893: FOR_TO
32894: IFFALSE 33224
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
32896: LD_VAR 0 12
32900: PUSH
32901: LD_VAR 0 7
32905: ARRAY
32906: PUSH
32907: LD_INT 1
32909: ARRAY
32910: PPUSH
32911: LD_VAR 0 12
32915: PUSH
32916: LD_VAR 0 7
32920: ARRAY
32921: PUSH
32922: LD_INT 2
32924: ARRAY
32925: PPUSH
32926: CALL_OW 488
32930: NOT
32931: PUSH
32932: LD_VAR 0 12
32936: PUSH
32937: LD_VAR 0 7
32941: ARRAY
32942: PUSH
32943: LD_INT 1
32945: ARRAY
32946: PPUSH
32947: LD_VAR 0 12
32951: PUSH
32952: LD_VAR 0 7
32956: ARRAY
32957: PUSH
32958: LD_INT 2
32960: ARRAY
32961: PPUSH
32962: CALL_OW 428
32966: PUSH
32967: LD_INT 0
32969: GREATER
32970: OR
32971: PUSH
32972: LD_VAR 0 12
32976: PUSH
32977: LD_VAR 0 7
32981: ARRAY
32982: PUSH
32983: LD_INT 1
32985: ARRAY
32986: PPUSH
32987: LD_VAR 0 12
32991: PUSH
32992: LD_VAR 0 7
32996: ARRAY
32997: PUSH
32998: LD_INT 2
33000: ARRAY
33001: PPUSH
33002: CALL_OW 351
33006: OR
33007: IFFALSE 33013
// exit ;
33009: POP
33010: POP
33011: GO 33305
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
33013: LD_ADDR_VAR 0 8
33017: PUSH
33018: LD_VAR 0 12
33022: PUSH
33023: LD_VAR 0 7
33027: ARRAY
33028: PUSH
33029: LD_INT 1
33031: ARRAY
33032: PPUSH
33033: LD_VAR 0 12
33037: PUSH
33038: LD_VAR 0 7
33042: ARRAY
33043: PUSH
33044: LD_INT 2
33046: ARRAY
33047: PPUSH
33048: CALL_OW 546
33052: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
33053: LD_VAR 0 8
33057: PUSH
33058: LD_INT 1
33060: ARRAY
33061: PUSH
33062: LD_VAR 0 8
33066: PUSH
33067: LD_INT 2
33069: ARRAY
33070: PUSH
33071: LD_VAR 0 13
33075: PUSH
33076: LD_INT 2
33078: PLUS
33079: GREATER
33080: OR
33081: PUSH
33082: LD_VAR 0 8
33086: PUSH
33087: LD_INT 2
33089: ARRAY
33090: PUSH
33091: LD_VAR 0 13
33095: PUSH
33096: LD_INT 2
33098: MINUS
33099: LESS
33100: OR
33101: PUSH
33102: LD_VAR 0 8
33106: PUSH
33107: LD_INT 3
33109: ARRAY
33110: PUSH
33111: LD_INT 0
33113: PUSH
33114: LD_INT 8
33116: PUSH
33117: LD_INT 9
33119: PUSH
33120: LD_INT 10
33122: PUSH
33123: LD_INT 11
33125: PUSH
33126: LD_INT 12
33128: PUSH
33129: LD_INT 13
33131: PUSH
33132: LD_INT 16
33134: PUSH
33135: LD_INT 17
33137: PUSH
33138: LD_INT 18
33140: PUSH
33141: LD_INT 19
33143: PUSH
33144: LD_INT 20
33146: PUSH
33147: LD_INT 21
33149: PUSH
33150: EMPTY
33151: LIST
33152: LIST
33153: LIST
33154: LIST
33155: LIST
33156: LIST
33157: LIST
33158: LIST
33159: LIST
33160: LIST
33161: LIST
33162: LIST
33163: LIST
33164: IN
33165: NOT
33166: OR
33167: PUSH
33168: LD_VAR 0 8
33172: PUSH
33173: LD_INT 5
33175: ARRAY
33176: NOT
33177: OR
33178: PUSH
33179: LD_VAR 0 8
33183: PUSH
33184: LD_INT 6
33186: ARRAY
33187: PUSH
33188: LD_INT 1
33190: PUSH
33191: LD_INT 2
33193: PUSH
33194: LD_INT 7
33196: PUSH
33197: LD_INT 9
33199: PUSH
33200: LD_INT 10
33202: PUSH
33203: LD_INT 11
33205: PUSH
33206: EMPTY
33207: LIST
33208: LIST
33209: LIST
33210: LIST
33211: LIST
33212: LIST
33213: IN
33214: NOT
33215: OR
33216: IFFALSE 33222
// exit ;
33218: POP
33219: POP
33220: GO 33305
// end ;
33222: GO 32893
33224: POP
33225: POP
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
33226: LD_VAR 0 9
33230: PPUSH
33231: LD_VAR 0 3
33235: PPUSH
33236: LD_VAR 0 4
33240: PPUSH
33241: LD_INT 20
33243: PPUSH
33244: CALL 25257 0 4
33248: PUSH
33249: LD_INT 4
33251: ARRAY
33252: IFFALSE 33256
// exit ;
33254: GO 33305
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
33256: LD_VAR 0 2
33260: PUSH
33261: LD_INT 29
33263: PUSH
33264: LD_INT 30
33266: PUSH
33267: EMPTY
33268: LIST
33269: LIST
33270: IN
33271: PUSH
33272: LD_VAR 0 3
33276: PPUSH
33277: LD_VAR 0 4
33281: PPUSH
33282: LD_VAR 0 9
33286: PPUSH
33287: CALL_OW 440
33291: NOT
33292: AND
33293: IFFALSE 33297
// exit ;
33295: GO 33305
// result := true ;
33297: LD_ADDR_VAR 0 6
33301: PUSH
33302: LD_INT 1
33304: ST_TO_ADDR
// end ;
33305: LD_VAR 0 6
33309: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 , fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 , fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ; var fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 , fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ; var fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 , fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ; var fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 , fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ; begin
33310: LD_INT 0
33312: PPUSH
33313: PPUSH
33314: PPUSH
33315: PPUSH
33316: PPUSH
33317: PPUSH
33318: PPUSH
33319: PPUSH
33320: PPUSH
33321: PPUSH
33322: PPUSH
33323: PPUSH
33324: PPUSH
33325: PPUSH
33326: PPUSH
33327: PPUSH
33328: PPUSH
33329: PPUSH
33330: PPUSH
33331: PPUSH
33332: PPUSH
33333: PPUSH
33334: PPUSH
33335: PPUSH
33336: PPUSH
33337: PPUSH
33338: PPUSH
33339: PPUSH
33340: PPUSH
33341: PPUSH
33342: PPUSH
33343: PPUSH
33344: PPUSH
33345: PPUSH
33346: PPUSH
33347: PPUSH
33348: PPUSH
33349: PPUSH
33350: PPUSH
33351: PPUSH
33352: PPUSH
33353: PPUSH
33354: PPUSH
33355: PPUSH
33356: PPUSH
33357: PPUSH
33358: PPUSH
33359: PPUSH
33360: PPUSH
33361: PPUSH
33362: PPUSH
33363: PPUSH
33364: PPUSH
33365: PPUSH
33366: PPUSH
33367: PPUSH
33368: PPUSH
33369: PPUSH
// result = [ ] ;
33370: LD_ADDR_VAR 0 7
33374: PUSH
33375: EMPTY
33376: ST_TO_ADDR
// temp_list = [ ] ;
33377: LD_ADDR_VAR 0 9
33381: PUSH
33382: EMPTY
33383: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
33384: LD_VAR 0 4
33388: PUSH
33389: LD_INT 0
33391: PUSH
33392: LD_INT 1
33394: PUSH
33395: LD_INT 2
33397: PUSH
33398: LD_INT 3
33400: PUSH
33401: LD_INT 4
33403: PUSH
33404: LD_INT 5
33406: PUSH
33407: EMPTY
33408: LIST
33409: LIST
33410: LIST
33411: LIST
33412: LIST
33413: LIST
33414: IN
33415: NOT
33416: PUSH
33417: LD_VAR 0 1
33421: PUSH
33422: LD_INT 0
33424: PUSH
33425: LD_INT 1
33427: PUSH
33428: EMPTY
33429: LIST
33430: LIST
33431: IN
33432: PUSH
33433: LD_VAR 0 5
33437: PUSH
33438: LD_INT 1
33440: PUSH
33441: LD_INT 2
33443: PUSH
33444: LD_INT 3
33446: PUSH
33447: EMPTY
33448: LIST
33449: LIST
33450: LIST
33451: IN
33452: NOT
33453: AND
33454: OR
33455: IFFALSE 33459
// exit ;
33457: GO 51850
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
33459: LD_VAR 0 1
33463: PUSH
33464: LD_INT 6
33466: PUSH
33467: LD_INT 7
33469: PUSH
33470: LD_INT 8
33472: PUSH
33473: LD_INT 13
33475: PUSH
33476: LD_INT 12
33478: PUSH
33479: LD_INT 15
33481: PUSH
33482: LD_INT 11
33484: PUSH
33485: LD_INT 14
33487: PUSH
33488: LD_INT 10
33490: PUSH
33491: EMPTY
33492: LIST
33493: LIST
33494: LIST
33495: LIST
33496: LIST
33497: LIST
33498: LIST
33499: LIST
33500: LIST
33501: IN
33502: IFFALSE 33512
// btype = b_lab ;
33504: LD_ADDR_VAR 0 1
33508: PUSH
33509: LD_INT 6
33511: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
33512: LD_VAR 0 6
33516: PUSH
33517: LD_INT 0
33519: PUSH
33520: LD_INT 1
33522: PUSH
33523: LD_INT 2
33525: PUSH
33526: EMPTY
33527: LIST
33528: LIST
33529: LIST
33530: IN
33531: NOT
33532: PUSH
33533: LD_VAR 0 1
33537: PUSH
33538: LD_INT 0
33540: PUSH
33541: LD_INT 1
33543: PUSH
33544: LD_INT 2
33546: PUSH
33547: LD_INT 3
33549: PUSH
33550: LD_INT 6
33552: PUSH
33553: LD_INT 36
33555: PUSH
33556: LD_INT 4
33558: PUSH
33559: LD_INT 5
33561: PUSH
33562: LD_INT 31
33564: PUSH
33565: LD_INT 32
33567: PUSH
33568: LD_INT 33
33570: PUSH
33571: EMPTY
33572: LIST
33573: LIST
33574: LIST
33575: LIST
33576: LIST
33577: LIST
33578: LIST
33579: LIST
33580: LIST
33581: LIST
33582: LIST
33583: IN
33584: NOT
33585: PUSH
33586: LD_VAR 0 6
33590: PUSH
33591: LD_INT 1
33593: EQUAL
33594: AND
33595: OR
33596: PUSH
33597: LD_VAR 0 1
33601: PUSH
33602: LD_INT 2
33604: PUSH
33605: LD_INT 3
33607: PUSH
33608: EMPTY
33609: LIST
33610: LIST
33611: IN
33612: NOT
33613: PUSH
33614: LD_VAR 0 6
33618: PUSH
33619: LD_INT 2
33621: EQUAL
33622: AND
33623: OR
33624: IFFALSE 33634
// mode = 0 ;
33626: LD_ADDR_VAR 0 6
33630: PUSH
33631: LD_INT 0
33633: ST_TO_ADDR
// case mode of 0 :
33634: LD_VAR 0 6
33638: PUSH
33639: LD_INT 0
33641: DOUBLE
33642: EQUAL
33643: IFTRUE 33647
33645: GO 45100
33647: POP
// begin fDepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
33648: LD_ADDR_VAR 0 11
33652: PUSH
33653: LD_INT 0
33655: PUSH
33656: LD_INT 0
33658: PUSH
33659: EMPTY
33660: LIST
33661: LIST
33662: PUSH
33663: LD_INT 0
33665: PUSH
33666: LD_INT 1
33668: NEG
33669: PUSH
33670: EMPTY
33671: LIST
33672: LIST
33673: PUSH
33674: LD_INT 1
33676: PUSH
33677: LD_INT 0
33679: PUSH
33680: EMPTY
33681: LIST
33682: LIST
33683: PUSH
33684: LD_INT 1
33686: PUSH
33687: LD_INT 1
33689: PUSH
33690: EMPTY
33691: LIST
33692: LIST
33693: PUSH
33694: LD_INT 0
33696: PUSH
33697: LD_INT 1
33699: PUSH
33700: EMPTY
33701: LIST
33702: LIST
33703: PUSH
33704: LD_INT 1
33706: NEG
33707: PUSH
33708: LD_INT 0
33710: PUSH
33711: EMPTY
33712: LIST
33713: LIST
33714: PUSH
33715: LD_INT 1
33717: NEG
33718: PUSH
33719: LD_INT 1
33721: NEG
33722: PUSH
33723: EMPTY
33724: LIST
33725: LIST
33726: PUSH
33727: LD_INT 1
33729: NEG
33730: PUSH
33731: LD_INT 2
33733: NEG
33734: PUSH
33735: EMPTY
33736: LIST
33737: LIST
33738: PUSH
33739: LD_INT 0
33741: PUSH
33742: LD_INT 2
33744: NEG
33745: PUSH
33746: EMPTY
33747: LIST
33748: LIST
33749: PUSH
33750: LD_INT 1
33752: PUSH
33753: LD_INT 1
33755: NEG
33756: PUSH
33757: EMPTY
33758: LIST
33759: LIST
33760: PUSH
33761: LD_INT 1
33763: PUSH
33764: LD_INT 2
33766: PUSH
33767: EMPTY
33768: LIST
33769: LIST
33770: PUSH
33771: LD_INT 0
33773: PUSH
33774: LD_INT 2
33776: PUSH
33777: EMPTY
33778: LIST
33779: LIST
33780: PUSH
33781: LD_INT 1
33783: NEG
33784: PUSH
33785: LD_INT 1
33787: PUSH
33788: EMPTY
33789: LIST
33790: LIST
33791: PUSH
33792: LD_INT 1
33794: PUSH
33795: LD_INT 3
33797: PUSH
33798: EMPTY
33799: LIST
33800: LIST
33801: PUSH
33802: LD_INT 0
33804: PUSH
33805: LD_INT 3
33807: PUSH
33808: EMPTY
33809: LIST
33810: LIST
33811: PUSH
33812: LD_INT 1
33814: NEG
33815: PUSH
33816: LD_INT 2
33818: PUSH
33819: EMPTY
33820: LIST
33821: LIST
33822: PUSH
33823: EMPTY
33824: LIST
33825: LIST
33826: LIST
33827: LIST
33828: LIST
33829: LIST
33830: LIST
33831: LIST
33832: LIST
33833: LIST
33834: LIST
33835: LIST
33836: LIST
33837: LIST
33838: LIST
33839: LIST
33840: ST_TO_ADDR
// fDepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
33841: LD_ADDR_VAR 0 12
33845: PUSH
33846: LD_INT 0
33848: PUSH
33849: LD_INT 0
33851: PUSH
33852: EMPTY
33853: LIST
33854: LIST
33855: PUSH
33856: LD_INT 0
33858: PUSH
33859: LD_INT 1
33861: NEG
33862: PUSH
33863: EMPTY
33864: LIST
33865: LIST
33866: PUSH
33867: LD_INT 1
33869: PUSH
33870: LD_INT 0
33872: PUSH
33873: EMPTY
33874: LIST
33875: LIST
33876: PUSH
33877: LD_INT 1
33879: PUSH
33880: LD_INT 1
33882: PUSH
33883: EMPTY
33884: LIST
33885: LIST
33886: PUSH
33887: LD_INT 0
33889: PUSH
33890: LD_INT 1
33892: PUSH
33893: EMPTY
33894: LIST
33895: LIST
33896: PUSH
33897: LD_INT 1
33899: NEG
33900: PUSH
33901: LD_INT 0
33903: PUSH
33904: EMPTY
33905: LIST
33906: LIST
33907: PUSH
33908: LD_INT 1
33910: NEG
33911: PUSH
33912: LD_INT 1
33914: NEG
33915: PUSH
33916: EMPTY
33917: LIST
33918: LIST
33919: PUSH
33920: LD_INT 1
33922: PUSH
33923: LD_INT 1
33925: NEG
33926: PUSH
33927: EMPTY
33928: LIST
33929: LIST
33930: PUSH
33931: LD_INT 2
33933: PUSH
33934: LD_INT 0
33936: PUSH
33937: EMPTY
33938: LIST
33939: LIST
33940: PUSH
33941: LD_INT 2
33943: PUSH
33944: LD_INT 1
33946: PUSH
33947: EMPTY
33948: LIST
33949: LIST
33950: PUSH
33951: LD_INT 1
33953: NEG
33954: PUSH
33955: LD_INT 1
33957: PUSH
33958: EMPTY
33959: LIST
33960: LIST
33961: PUSH
33962: LD_INT 2
33964: NEG
33965: PUSH
33966: LD_INT 0
33968: PUSH
33969: EMPTY
33970: LIST
33971: LIST
33972: PUSH
33973: LD_INT 2
33975: NEG
33976: PUSH
33977: LD_INT 1
33979: NEG
33980: PUSH
33981: EMPTY
33982: LIST
33983: LIST
33984: PUSH
33985: LD_INT 2
33987: NEG
33988: PUSH
33989: LD_INT 1
33991: PUSH
33992: EMPTY
33993: LIST
33994: LIST
33995: PUSH
33996: LD_INT 3
33998: NEG
33999: PUSH
34000: LD_INT 0
34002: PUSH
34003: EMPTY
34004: LIST
34005: LIST
34006: PUSH
34007: LD_INT 3
34009: NEG
34010: PUSH
34011: LD_INT 1
34013: NEG
34014: PUSH
34015: EMPTY
34016: LIST
34017: LIST
34018: PUSH
34019: EMPTY
34020: LIST
34021: LIST
34022: LIST
34023: LIST
34024: LIST
34025: LIST
34026: LIST
34027: LIST
34028: LIST
34029: LIST
34030: LIST
34031: LIST
34032: LIST
34033: LIST
34034: LIST
34035: LIST
34036: ST_TO_ADDR
// fDepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
34037: LD_ADDR_VAR 0 13
34041: PUSH
34042: LD_INT 0
34044: PUSH
34045: LD_INT 0
34047: PUSH
34048: EMPTY
34049: LIST
34050: LIST
34051: PUSH
34052: LD_INT 0
34054: PUSH
34055: LD_INT 1
34057: NEG
34058: PUSH
34059: EMPTY
34060: LIST
34061: LIST
34062: PUSH
34063: LD_INT 1
34065: PUSH
34066: LD_INT 0
34068: PUSH
34069: EMPTY
34070: LIST
34071: LIST
34072: PUSH
34073: LD_INT 1
34075: PUSH
34076: LD_INT 1
34078: PUSH
34079: EMPTY
34080: LIST
34081: LIST
34082: PUSH
34083: LD_INT 0
34085: PUSH
34086: LD_INT 1
34088: PUSH
34089: EMPTY
34090: LIST
34091: LIST
34092: PUSH
34093: LD_INT 1
34095: NEG
34096: PUSH
34097: LD_INT 0
34099: PUSH
34100: EMPTY
34101: LIST
34102: LIST
34103: PUSH
34104: LD_INT 1
34106: NEG
34107: PUSH
34108: LD_INT 1
34110: NEG
34111: PUSH
34112: EMPTY
34113: LIST
34114: LIST
34115: PUSH
34116: LD_INT 1
34118: NEG
34119: PUSH
34120: LD_INT 2
34122: NEG
34123: PUSH
34124: EMPTY
34125: LIST
34126: LIST
34127: PUSH
34128: LD_INT 2
34130: PUSH
34131: LD_INT 1
34133: PUSH
34134: EMPTY
34135: LIST
34136: LIST
34137: PUSH
34138: LD_INT 2
34140: PUSH
34141: LD_INT 2
34143: PUSH
34144: EMPTY
34145: LIST
34146: LIST
34147: PUSH
34148: LD_INT 1
34150: PUSH
34151: LD_INT 2
34153: PUSH
34154: EMPTY
34155: LIST
34156: LIST
34157: PUSH
34158: LD_INT 2
34160: NEG
34161: PUSH
34162: LD_INT 1
34164: NEG
34165: PUSH
34166: EMPTY
34167: LIST
34168: LIST
34169: PUSH
34170: LD_INT 2
34172: NEG
34173: PUSH
34174: LD_INT 2
34176: NEG
34177: PUSH
34178: EMPTY
34179: LIST
34180: LIST
34181: PUSH
34182: LD_INT 2
34184: NEG
34185: PUSH
34186: LD_INT 3
34188: NEG
34189: PUSH
34190: EMPTY
34191: LIST
34192: LIST
34193: PUSH
34194: LD_INT 3
34196: NEG
34197: PUSH
34198: LD_INT 2
34200: NEG
34201: PUSH
34202: EMPTY
34203: LIST
34204: LIST
34205: PUSH
34206: LD_INT 3
34208: NEG
34209: PUSH
34210: LD_INT 3
34212: NEG
34213: PUSH
34214: EMPTY
34215: LIST
34216: LIST
34217: PUSH
34218: EMPTY
34219: LIST
34220: LIST
34221: LIST
34222: LIST
34223: LIST
34224: LIST
34225: LIST
34226: LIST
34227: LIST
34228: LIST
34229: LIST
34230: LIST
34231: LIST
34232: LIST
34233: LIST
34234: LIST
34235: ST_TO_ADDR
// fDepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
34236: LD_ADDR_VAR 0 14
34240: PUSH
34241: LD_INT 0
34243: PUSH
34244: LD_INT 0
34246: PUSH
34247: EMPTY
34248: LIST
34249: LIST
34250: PUSH
34251: LD_INT 0
34253: PUSH
34254: LD_INT 1
34256: NEG
34257: PUSH
34258: EMPTY
34259: LIST
34260: LIST
34261: PUSH
34262: LD_INT 1
34264: PUSH
34265: LD_INT 0
34267: PUSH
34268: EMPTY
34269: LIST
34270: LIST
34271: PUSH
34272: LD_INT 1
34274: PUSH
34275: LD_INT 1
34277: PUSH
34278: EMPTY
34279: LIST
34280: LIST
34281: PUSH
34282: LD_INT 0
34284: PUSH
34285: LD_INT 1
34287: PUSH
34288: EMPTY
34289: LIST
34290: LIST
34291: PUSH
34292: LD_INT 1
34294: NEG
34295: PUSH
34296: LD_INT 0
34298: PUSH
34299: EMPTY
34300: LIST
34301: LIST
34302: PUSH
34303: LD_INT 1
34305: NEG
34306: PUSH
34307: LD_INT 1
34309: NEG
34310: PUSH
34311: EMPTY
34312: LIST
34313: LIST
34314: PUSH
34315: LD_INT 1
34317: NEG
34318: PUSH
34319: LD_INT 2
34321: NEG
34322: PUSH
34323: EMPTY
34324: LIST
34325: LIST
34326: PUSH
34327: LD_INT 0
34329: PUSH
34330: LD_INT 2
34332: NEG
34333: PUSH
34334: EMPTY
34335: LIST
34336: LIST
34337: PUSH
34338: LD_INT 1
34340: PUSH
34341: LD_INT 1
34343: NEG
34344: PUSH
34345: EMPTY
34346: LIST
34347: LIST
34348: PUSH
34349: LD_INT 1
34351: PUSH
34352: LD_INT 2
34354: PUSH
34355: EMPTY
34356: LIST
34357: LIST
34358: PUSH
34359: LD_INT 0
34361: PUSH
34362: LD_INT 2
34364: PUSH
34365: EMPTY
34366: LIST
34367: LIST
34368: PUSH
34369: LD_INT 1
34371: NEG
34372: PUSH
34373: LD_INT 1
34375: PUSH
34376: EMPTY
34377: LIST
34378: LIST
34379: PUSH
34380: LD_INT 1
34382: NEG
34383: PUSH
34384: LD_INT 3
34386: NEG
34387: PUSH
34388: EMPTY
34389: LIST
34390: LIST
34391: PUSH
34392: LD_INT 0
34394: PUSH
34395: LD_INT 3
34397: NEG
34398: PUSH
34399: EMPTY
34400: LIST
34401: LIST
34402: PUSH
34403: LD_INT 1
34405: PUSH
34406: LD_INT 2
34408: NEG
34409: PUSH
34410: EMPTY
34411: LIST
34412: LIST
34413: PUSH
34414: EMPTY
34415: LIST
34416: LIST
34417: LIST
34418: LIST
34419: LIST
34420: LIST
34421: LIST
34422: LIST
34423: LIST
34424: LIST
34425: LIST
34426: LIST
34427: LIST
34428: LIST
34429: LIST
34430: LIST
34431: ST_TO_ADDR
// fDepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
34432: LD_ADDR_VAR 0 15
34436: PUSH
34437: LD_INT 0
34439: PUSH
34440: LD_INT 0
34442: PUSH
34443: EMPTY
34444: LIST
34445: LIST
34446: PUSH
34447: LD_INT 0
34449: PUSH
34450: LD_INT 1
34452: NEG
34453: PUSH
34454: EMPTY
34455: LIST
34456: LIST
34457: PUSH
34458: LD_INT 1
34460: PUSH
34461: LD_INT 0
34463: PUSH
34464: EMPTY
34465: LIST
34466: LIST
34467: PUSH
34468: LD_INT 1
34470: PUSH
34471: LD_INT 1
34473: PUSH
34474: EMPTY
34475: LIST
34476: LIST
34477: PUSH
34478: LD_INT 0
34480: PUSH
34481: LD_INT 1
34483: PUSH
34484: EMPTY
34485: LIST
34486: LIST
34487: PUSH
34488: LD_INT 1
34490: NEG
34491: PUSH
34492: LD_INT 0
34494: PUSH
34495: EMPTY
34496: LIST
34497: LIST
34498: PUSH
34499: LD_INT 1
34501: NEG
34502: PUSH
34503: LD_INT 1
34505: NEG
34506: PUSH
34507: EMPTY
34508: LIST
34509: LIST
34510: PUSH
34511: LD_INT 1
34513: PUSH
34514: LD_INT 1
34516: NEG
34517: PUSH
34518: EMPTY
34519: LIST
34520: LIST
34521: PUSH
34522: LD_INT 2
34524: PUSH
34525: LD_INT 0
34527: PUSH
34528: EMPTY
34529: LIST
34530: LIST
34531: PUSH
34532: LD_INT 2
34534: PUSH
34535: LD_INT 1
34537: PUSH
34538: EMPTY
34539: LIST
34540: LIST
34541: PUSH
34542: LD_INT 1
34544: NEG
34545: PUSH
34546: LD_INT 1
34548: PUSH
34549: EMPTY
34550: LIST
34551: LIST
34552: PUSH
34553: LD_INT 2
34555: NEG
34556: PUSH
34557: LD_INT 0
34559: PUSH
34560: EMPTY
34561: LIST
34562: LIST
34563: PUSH
34564: LD_INT 2
34566: NEG
34567: PUSH
34568: LD_INT 1
34570: NEG
34571: PUSH
34572: EMPTY
34573: LIST
34574: LIST
34575: PUSH
34576: LD_INT 2
34578: PUSH
34579: LD_INT 1
34581: NEG
34582: PUSH
34583: EMPTY
34584: LIST
34585: LIST
34586: PUSH
34587: LD_INT 3
34589: PUSH
34590: LD_INT 0
34592: PUSH
34593: EMPTY
34594: LIST
34595: LIST
34596: PUSH
34597: LD_INT 3
34599: PUSH
34600: LD_INT 1
34602: PUSH
34603: EMPTY
34604: LIST
34605: LIST
34606: PUSH
34607: EMPTY
34608: LIST
34609: LIST
34610: LIST
34611: LIST
34612: LIST
34613: LIST
34614: LIST
34615: LIST
34616: LIST
34617: LIST
34618: LIST
34619: LIST
34620: LIST
34621: LIST
34622: LIST
34623: LIST
34624: ST_TO_ADDR
// fDepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
34625: LD_ADDR_VAR 0 16
34629: PUSH
34630: LD_INT 0
34632: PUSH
34633: LD_INT 0
34635: PUSH
34636: EMPTY
34637: LIST
34638: LIST
34639: PUSH
34640: LD_INT 0
34642: PUSH
34643: LD_INT 1
34645: NEG
34646: PUSH
34647: EMPTY
34648: LIST
34649: LIST
34650: PUSH
34651: LD_INT 1
34653: PUSH
34654: LD_INT 0
34656: PUSH
34657: EMPTY
34658: LIST
34659: LIST
34660: PUSH
34661: LD_INT 1
34663: PUSH
34664: LD_INT 1
34666: PUSH
34667: EMPTY
34668: LIST
34669: LIST
34670: PUSH
34671: LD_INT 0
34673: PUSH
34674: LD_INT 1
34676: PUSH
34677: EMPTY
34678: LIST
34679: LIST
34680: PUSH
34681: LD_INT 1
34683: NEG
34684: PUSH
34685: LD_INT 0
34687: PUSH
34688: EMPTY
34689: LIST
34690: LIST
34691: PUSH
34692: LD_INT 1
34694: NEG
34695: PUSH
34696: LD_INT 1
34698: NEG
34699: PUSH
34700: EMPTY
34701: LIST
34702: LIST
34703: PUSH
34704: LD_INT 1
34706: NEG
34707: PUSH
34708: LD_INT 2
34710: NEG
34711: PUSH
34712: EMPTY
34713: LIST
34714: LIST
34715: PUSH
34716: LD_INT 2
34718: PUSH
34719: LD_INT 1
34721: PUSH
34722: EMPTY
34723: LIST
34724: LIST
34725: PUSH
34726: LD_INT 2
34728: PUSH
34729: LD_INT 2
34731: PUSH
34732: EMPTY
34733: LIST
34734: LIST
34735: PUSH
34736: LD_INT 1
34738: PUSH
34739: LD_INT 2
34741: PUSH
34742: EMPTY
34743: LIST
34744: LIST
34745: PUSH
34746: LD_INT 2
34748: NEG
34749: PUSH
34750: LD_INT 1
34752: NEG
34753: PUSH
34754: EMPTY
34755: LIST
34756: LIST
34757: PUSH
34758: LD_INT 2
34760: NEG
34761: PUSH
34762: LD_INT 2
34764: NEG
34765: PUSH
34766: EMPTY
34767: LIST
34768: LIST
34769: PUSH
34770: LD_INT 3
34772: PUSH
34773: LD_INT 2
34775: PUSH
34776: EMPTY
34777: LIST
34778: LIST
34779: PUSH
34780: LD_INT 3
34782: PUSH
34783: LD_INT 3
34785: PUSH
34786: EMPTY
34787: LIST
34788: LIST
34789: PUSH
34790: LD_INT 2
34792: PUSH
34793: LD_INT 3
34795: PUSH
34796: EMPTY
34797: LIST
34798: LIST
34799: PUSH
34800: EMPTY
34801: LIST
34802: LIST
34803: LIST
34804: LIST
34805: LIST
34806: LIST
34807: LIST
34808: LIST
34809: LIST
34810: LIST
34811: LIST
34812: LIST
34813: LIST
34814: LIST
34815: LIST
34816: LIST
34817: ST_TO_ADDR
// fDepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
34818: LD_ADDR_VAR 0 17
34822: PUSH
34823: LD_INT 0
34825: PUSH
34826: LD_INT 0
34828: PUSH
34829: EMPTY
34830: LIST
34831: LIST
34832: PUSH
34833: LD_INT 0
34835: PUSH
34836: LD_INT 1
34838: NEG
34839: PUSH
34840: EMPTY
34841: LIST
34842: LIST
34843: PUSH
34844: LD_INT 1
34846: PUSH
34847: LD_INT 0
34849: PUSH
34850: EMPTY
34851: LIST
34852: LIST
34853: PUSH
34854: LD_INT 1
34856: PUSH
34857: LD_INT 1
34859: PUSH
34860: EMPTY
34861: LIST
34862: LIST
34863: PUSH
34864: LD_INT 0
34866: PUSH
34867: LD_INT 1
34869: PUSH
34870: EMPTY
34871: LIST
34872: LIST
34873: PUSH
34874: LD_INT 1
34876: NEG
34877: PUSH
34878: LD_INT 0
34880: PUSH
34881: EMPTY
34882: LIST
34883: LIST
34884: PUSH
34885: LD_INT 1
34887: NEG
34888: PUSH
34889: LD_INT 1
34891: NEG
34892: PUSH
34893: EMPTY
34894: LIST
34895: LIST
34896: PUSH
34897: LD_INT 1
34899: NEG
34900: PUSH
34901: LD_INT 2
34903: NEG
34904: PUSH
34905: EMPTY
34906: LIST
34907: LIST
34908: PUSH
34909: LD_INT 0
34911: PUSH
34912: LD_INT 2
34914: NEG
34915: PUSH
34916: EMPTY
34917: LIST
34918: LIST
34919: PUSH
34920: LD_INT 1
34922: PUSH
34923: LD_INT 1
34925: NEG
34926: PUSH
34927: EMPTY
34928: LIST
34929: LIST
34930: PUSH
34931: LD_INT 2
34933: PUSH
34934: LD_INT 0
34936: PUSH
34937: EMPTY
34938: LIST
34939: LIST
34940: PUSH
34941: LD_INT 2
34943: PUSH
34944: LD_INT 1
34946: PUSH
34947: EMPTY
34948: LIST
34949: LIST
34950: PUSH
34951: LD_INT 2
34953: PUSH
34954: LD_INT 2
34956: PUSH
34957: EMPTY
34958: LIST
34959: LIST
34960: PUSH
34961: LD_INT 1
34963: PUSH
34964: LD_INT 2
34966: PUSH
34967: EMPTY
34968: LIST
34969: LIST
34970: PUSH
34971: LD_INT 0
34973: PUSH
34974: LD_INT 2
34976: PUSH
34977: EMPTY
34978: LIST
34979: LIST
34980: PUSH
34981: LD_INT 1
34983: NEG
34984: PUSH
34985: LD_INT 1
34987: PUSH
34988: EMPTY
34989: LIST
34990: LIST
34991: PUSH
34992: LD_INT 2
34994: NEG
34995: PUSH
34996: LD_INT 0
34998: PUSH
34999: EMPTY
35000: LIST
35001: LIST
35002: PUSH
35003: LD_INT 2
35005: NEG
35006: PUSH
35007: LD_INT 1
35009: NEG
35010: PUSH
35011: EMPTY
35012: LIST
35013: LIST
35014: PUSH
35015: LD_INT 2
35017: NEG
35018: PUSH
35019: LD_INT 2
35021: NEG
35022: PUSH
35023: EMPTY
35024: LIST
35025: LIST
35026: PUSH
35027: EMPTY
35028: LIST
35029: LIST
35030: LIST
35031: LIST
35032: LIST
35033: LIST
35034: LIST
35035: LIST
35036: LIST
35037: LIST
35038: LIST
35039: LIST
35040: LIST
35041: LIST
35042: LIST
35043: LIST
35044: LIST
35045: LIST
35046: LIST
35047: ST_TO_ADDR
// fDepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
35048: LD_ADDR_VAR 0 18
35052: PUSH
35053: LD_INT 0
35055: PUSH
35056: LD_INT 0
35058: PUSH
35059: EMPTY
35060: LIST
35061: LIST
35062: PUSH
35063: LD_INT 0
35065: PUSH
35066: LD_INT 1
35068: NEG
35069: PUSH
35070: EMPTY
35071: LIST
35072: LIST
35073: PUSH
35074: LD_INT 1
35076: PUSH
35077: LD_INT 0
35079: PUSH
35080: EMPTY
35081: LIST
35082: LIST
35083: PUSH
35084: LD_INT 1
35086: PUSH
35087: LD_INT 1
35089: PUSH
35090: EMPTY
35091: LIST
35092: LIST
35093: PUSH
35094: LD_INT 0
35096: PUSH
35097: LD_INT 1
35099: PUSH
35100: EMPTY
35101: LIST
35102: LIST
35103: PUSH
35104: LD_INT 1
35106: NEG
35107: PUSH
35108: LD_INT 0
35110: PUSH
35111: EMPTY
35112: LIST
35113: LIST
35114: PUSH
35115: LD_INT 1
35117: NEG
35118: PUSH
35119: LD_INT 1
35121: NEG
35122: PUSH
35123: EMPTY
35124: LIST
35125: LIST
35126: PUSH
35127: LD_INT 1
35129: NEG
35130: PUSH
35131: LD_INT 2
35133: NEG
35134: PUSH
35135: EMPTY
35136: LIST
35137: LIST
35138: PUSH
35139: LD_INT 0
35141: PUSH
35142: LD_INT 2
35144: NEG
35145: PUSH
35146: EMPTY
35147: LIST
35148: LIST
35149: PUSH
35150: LD_INT 1
35152: PUSH
35153: LD_INT 1
35155: NEG
35156: PUSH
35157: EMPTY
35158: LIST
35159: LIST
35160: PUSH
35161: LD_INT 2
35163: PUSH
35164: LD_INT 0
35166: PUSH
35167: EMPTY
35168: LIST
35169: LIST
35170: PUSH
35171: LD_INT 2
35173: PUSH
35174: LD_INT 1
35176: PUSH
35177: EMPTY
35178: LIST
35179: LIST
35180: PUSH
35181: LD_INT 2
35183: PUSH
35184: LD_INT 2
35186: PUSH
35187: EMPTY
35188: LIST
35189: LIST
35190: PUSH
35191: LD_INT 1
35193: PUSH
35194: LD_INT 2
35196: PUSH
35197: EMPTY
35198: LIST
35199: LIST
35200: PUSH
35201: LD_INT 0
35203: PUSH
35204: LD_INT 2
35206: PUSH
35207: EMPTY
35208: LIST
35209: LIST
35210: PUSH
35211: LD_INT 1
35213: NEG
35214: PUSH
35215: LD_INT 1
35217: PUSH
35218: EMPTY
35219: LIST
35220: LIST
35221: PUSH
35222: LD_INT 2
35224: NEG
35225: PUSH
35226: LD_INT 0
35228: PUSH
35229: EMPTY
35230: LIST
35231: LIST
35232: PUSH
35233: LD_INT 2
35235: NEG
35236: PUSH
35237: LD_INT 1
35239: NEG
35240: PUSH
35241: EMPTY
35242: LIST
35243: LIST
35244: PUSH
35245: LD_INT 2
35247: NEG
35248: PUSH
35249: LD_INT 2
35251: NEG
35252: PUSH
35253: EMPTY
35254: LIST
35255: LIST
35256: PUSH
35257: EMPTY
35258: LIST
35259: LIST
35260: LIST
35261: LIST
35262: LIST
35263: LIST
35264: LIST
35265: LIST
35266: LIST
35267: LIST
35268: LIST
35269: LIST
35270: LIST
35271: LIST
35272: LIST
35273: LIST
35274: LIST
35275: LIST
35276: LIST
35277: ST_TO_ADDR
// fDepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
35278: LD_ADDR_VAR 0 19
35282: PUSH
35283: LD_INT 0
35285: PUSH
35286: LD_INT 0
35288: PUSH
35289: EMPTY
35290: LIST
35291: LIST
35292: PUSH
35293: LD_INT 0
35295: PUSH
35296: LD_INT 1
35298: NEG
35299: PUSH
35300: EMPTY
35301: LIST
35302: LIST
35303: PUSH
35304: LD_INT 1
35306: PUSH
35307: LD_INT 0
35309: PUSH
35310: EMPTY
35311: LIST
35312: LIST
35313: PUSH
35314: LD_INT 1
35316: PUSH
35317: LD_INT 1
35319: PUSH
35320: EMPTY
35321: LIST
35322: LIST
35323: PUSH
35324: LD_INT 0
35326: PUSH
35327: LD_INT 1
35329: PUSH
35330: EMPTY
35331: LIST
35332: LIST
35333: PUSH
35334: LD_INT 1
35336: NEG
35337: PUSH
35338: LD_INT 0
35340: PUSH
35341: EMPTY
35342: LIST
35343: LIST
35344: PUSH
35345: LD_INT 1
35347: NEG
35348: PUSH
35349: LD_INT 1
35351: NEG
35352: PUSH
35353: EMPTY
35354: LIST
35355: LIST
35356: PUSH
35357: LD_INT 1
35359: NEG
35360: PUSH
35361: LD_INT 2
35363: NEG
35364: PUSH
35365: EMPTY
35366: LIST
35367: LIST
35368: PUSH
35369: LD_INT 0
35371: PUSH
35372: LD_INT 2
35374: NEG
35375: PUSH
35376: EMPTY
35377: LIST
35378: LIST
35379: PUSH
35380: LD_INT 1
35382: PUSH
35383: LD_INT 1
35385: NEG
35386: PUSH
35387: EMPTY
35388: LIST
35389: LIST
35390: PUSH
35391: LD_INT 2
35393: PUSH
35394: LD_INT 0
35396: PUSH
35397: EMPTY
35398: LIST
35399: LIST
35400: PUSH
35401: LD_INT 2
35403: PUSH
35404: LD_INT 1
35406: PUSH
35407: EMPTY
35408: LIST
35409: LIST
35410: PUSH
35411: LD_INT 2
35413: PUSH
35414: LD_INT 2
35416: PUSH
35417: EMPTY
35418: LIST
35419: LIST
35420: PUSH
35421: LD_INT 1
35423: PUSH
35424: LD_INT 2
35426: PUSH
35427: EMPTY
35428: LIST
35429: LIST
35430: PUSH
35431: LD_INT 0
35433: PUSH
35434: LD_INT 2
35436: PUSH
35437: EMPTY
35438: LIST
35439: LIST
35440: PUSH
35441: LD_INT 1
35443: NEG
35444: PUSH
35445: LD_INT 1
35447: PUSH
35448: EMPTY
35449: LIST
35450: LIST
35451: PUSH
35452: LD_INT 2
35454: NEG
35455: PUSH
35456: LD_INT 0
35458: PUSH
35459: EMPTY
35460: LIST
35461: LIST
35462: PUSH
35463: LD_INT 2
35465: NEG
35466: PUSH
35467: LD_INT 1
35469: NEG
35470: PUSH
35471: EMPTY
35472: LIST
35473: LIST
35474: PUSH
35475: LD_INT 2
35477: NEG
35478: PUSH
35479: LD_INT 2
35481: NEG
35482: PUSH
35483: EMPTY
35484: LIST
35485: LIST
35486: PUSH
35487: EMPTY
35488: LIST
35489: LIST
35490: LIST
35491: LIST
35492: LIST
35493: LIST
35494: LIST
35495: LIST
35496: LIST
35497: LIST
35498: LIST
35499: LIST
35500: LIST
35501: LIST
35502: LIST
35503: LIST
35504: LIST
35505: LIST
35506: LIST
35507: ST_TO_ADDR
// fDepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
35508: LD_ADDR_VAR 0 20
35512: PUSH
35513: LD_INT 0
35515: PUSH
35516: LD_INT 0
35518: PUSH
35519: EMPTY
35520: LIST
35521: LIST
35522: PUSH
35523: LD_INT 0
35525: PUSH
35526: LD_INT 1
35528: NEG
35529: PUSH
35530: EMPTY
35531: LIST
35532: LIST
35533: PUSH
35534: LD_INT 1
35536: PUSH
35537: LD_INT 0
35539: PUSH
35540: EMPTY
35541: LIST
35542: LIST
35543: PUSH
35544: LD_INT 1
35546: PUSH
35547: LD_INT 1
35549: PUSH
35550: EMPTY
35551: LIST
35552: LIST
35553: PUSH
35554: LD_INT 0
35556: PUSH
35557: LD_INT 1
35559: PUSH
35560: EMPTY
35561: LIST
35562: LIST
35563: PUSH
35564: LD_INT 1
35566: NEG
35567: PUSH
35568: LD_INT 0
35570: PUSH
35571: EMPTY
35572: LIST
35573: LIST
35574: PUSH
35575: LD_INT 1
35577: NEG
35578: PUSH
35579: LD_INT 1
35581: NEG
35582: PUSH
35583: EMPTY
35584: LIST
35585: LIST
35586: PUSH
35587: LD_INT 1
35589: NEG
35590: PUSH
35591: LD_INT 2
35593: NEG
35594: PUSH
35595: EMPTY
35596: LIST
35597: LIST
35598: PUSH
35599: LD_INT 0
35601: PUSH
35602: LD_INT 2
35604: NEG
35605: PUSH
35606: EMPTY
35607: LIST
35608: LIST
35609: PUSH
35610: LD_INT 1
35612: PUSH
35613: LD_INT 1
35615: NEG
35616: PUSH
35617: EMPTY
35618: LIST
35619: LIST
35620: PUSH
35621: LD_INT 2
35623: PUSH
35624: LD_INT 0
35626: PUSH
35627: EMPTY
35628: LIST
35629: LIST
35630: PUSH
35631: LD_INT 2
35633: PUSH
35634: LD_INT 1
35636: PUSH
35637: EMPTY
35638: LIST
35639: LIST
35640: PUSH
35641: LD_INT 2
35643: PUSH
35644: LD_INT 2
35646: PUSH
35647: EMPTY
35648: LIST
35649: LIST
35650: PUSH
35651: LD_INT 1
35653: PUSH
35654: LD_INT 2
35656: PUSH
35657: EMPTY
35658: LIST
35659: LIST
35660: PUSH
35661: LD_INT 0
35663: PUSH
35664: LD_INT 2
35666: PUSH
35667: EMPTY
35668: LIST
35669: LIST
35670: PUSH
35671: LD_INT 1
35673: NEG
35674: PUSH
35675: LD_INT 1
35677: PUSH
35678: EMPTY
35679: LIST
35680: LIST
35681: PUSH
35682: LD_INT 2
35684: NEG
35685: PUSH
35686: LD_INT 0
35688: PUSH
35689: EMPTY
35690: LIST
35691: LIST
35692: PUSH
35693: LD_INT 2
35695: NEG
35696: PUSH
35697: LD_INT 1
35699: NEG
35700: PUSH
35701: EMPTY
35702: LIST
35703: LIST
35704: PUSH
35705: LD_INT 2
35707: NEG
35708: PUSH
35709: LD_INT 2
35711: NEG
35712: PUSH
35713: EMPTY
35714: LIST
35715: LIST
35716: PUSH
35717: EMPTY
35718: LIST
35719: LIST
35720: LIST
35721: LIST
35722: LIST
35723: LIST
35724: LIST
35725: LIST
35726: LIST
35727: LIST
35728: LIST
35729: LIST
35730: LIST
35731: LIST
35732: LIST
35733: LIST
35734: LIST
35735: LIST
35736: LIST
35737: ST_TO_ADDR
// fDepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
35738: LD_ADDR_VAR 0 21
35742: PUSH
35743: LD_INT 0
35745: PUSH
35746: LD_INT 0
35748: PUSH
35749: EMPTY
35750: LIST
35751: LIST
35752: PUSH
35753: LD_INT 0
35755: PUSH
35756: LD_INT 1
35758: NEG
35759: PUSH
35760: EMPTY
35761: LIST
35762: LIST
35763: PUSH
35764: LD_INT 1
35766: PUSH
35767: LD_INT 0
35769: PUSH
35770: EMPTY
35771: LIST
35772: LIST
35773: PUSH
35774: LD_INT 1
35776: PUSH
35777: LD_INT 1
35779: PUSH
35780: EMPTY
35781: LIST
35782: LIST
35783: PUSH
35784: LD_INT 0
35786: PUSH
35787: LD_INT 1
35789: PUSH
35790: EMPTY
35791: LIST
35792: LIST
35793: PUSH
35794: LD_INT 1
35796: NEG
35797: PUSH
35798: LD_INT 0
35800: PUSH
35801: EMPTY
35802: LIST
35803: LIST
35804: PUSH
35805: LD_INT 1
35807: NEG
35808: PUSH
35809: LD_INT 1
35811: NEG
35812: PUSH
35813: EMPTY
35814: LIST
35815: LIST
35816: PUSH
35817: LD_INT 1
35819: NEG
35820: PUSH
35821: LD_INT 2
35823: NEG
35824: PUSH
35825: EMPTY
35826: LIST
35827: LIST
35828: PUSH
35829: LD_INT 0
35831: PUSH
35832: LD_INT 2
35834: NEG
35835: PUSH
35836: EMPTY
35837: LIST
35838: LIST
35839: PUSH
35840: LD_INT 1
35842: PUSH
35843: LD_INT 1
35845: NEG
35846: PUSH
35847: EMPTY
35848: LIST
35849: LIST
35850: PUSH
35851: LD_INT 2
35853: PUSH
35854: LD_INT 0
35856: PUSH
35857: EMPTY
35858: LIST
35859: LIST
35860: PUSH
35861: LD_INT 2
35863: PUSH
35864: LD_INT 1
35866: PUSH
35867: EMPTY
35868: LIST
35869: LIST
35870: PUSH
35871: LD_INT 2
35873: PUSH
35874: LD_INT 2
35876: PUSH
35877: EMPTY
35878: LIST
35879: LIST
35880: PUSH
35881: LD_INT 1
35883: PUSH
35884: LD_INT 2
35886: PUSH
35887: EMPTY
35888: LIST
35889: LIST
35890: PUSH
35891: LD_INT 0
35893: PUSH
35894: LD_INT 2
35896: PUSH
35897: EMPTY
35898: LIST
35899: LIST
35900: PUSH
35901: LD_INT 1
35903: NEG
35904: PUSH
35905: LD_INT 1
35907: PUSH
35908: EMPTY
35909: LIST
35910: LIST
35911: PUSH
35912: LD_INT 2
35914: NEG
35915: PUSH
35916: LD_INT 0
35918: PUSH
35919: EMPTY
35920: LIST
35921: LIST
35922: PUSH
35923: LD_INT 2
35925: NEG
35926: PUSH
35927: LD_INT 1
35929: NEG
35930: PUSH
35931: EMPTY
35932: LIST
35933: LIST
35934: PUSH
35935: LD_INT 2
35937: NEG
35938: PUSH
35939: LD_INT 2
35941: NEG
35942: PUSH
35943: EMPTY
35944: LIST
35945: LIST
35946: PUSH
35947: EMPTY
35948: LIST
35949: LIST
35950: LIST
35951: LIST
35952: LIST
35953: LIST
35954: LIST
35955: LIST
35956: LIST
35957: LIST
35958: LIST
35959: LIST
35960: LIST
35961: LIST
35962: LIST
35963: LIST
35964: LIST
35965: LIST
35966: LIST
35967: ST_TO_ADDR
// fDepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
35968: LD_ADDR_VAR 0 22
35972: PUSH
35973: LD_INT 0
35975: PUSH
35976: LD_INT 0
35978: PUSH
35979: EMPTY
35980: LIST
35981: LIST
35982: PUSH
35983: LD_INT 0
35985: PUSH
35986: LD_INT 1
35988: NEG
35989: PUSH
35990: EMPTY
35991: LIST
35992: LIST
35993: PUSH
35994: LD_INT 1
35996: PUSH
35997: LD_INT 0
35999: PUSH
36000: EMPTY
36001: LIST
36002: LIST
36003: PUSH
36004: LD_INT 1
36006: PUSH
36007: LD_INT 1
36009: PUSH
36010: EMPTY
36011: LIST
36012: LIST
36013: PUSH
36014: LD_INT 0
36016: PUSH
36017: LD_INT 1
36019: PUSH
36020: EMPTY
36021: LIST
36022: LIST
36023: PUSH
36024: LD_INT 1
36026: NEG
36027: PUSH
36028: LD_INT 0
36030: PUSH
36031: EMPTY
36032: LIST
36033: LIST
36034: PUSH
36035: LD_INT 1
36037: NEG
36038: PUSH
36039: LD_INT 1
36041: NEG
36042: PUSH
36043: EMPTY
36044: LIST
36045: LIST
36046: PUSH
36047: LD_INT 1
36049: NEG
36050: PUSH
36051: LD_INT 2
36053: NEG
36054: PUSH
36055: EMPTY
36056: LIST
36057: LIST
36058: PUSH
36059: LD_INT 0
36061: PUSH
36062: LD_INT 2
36064: NEG
36065: PUSH
36066: EMPTY
36067: LIST
36068: LIST
36069: PUSH
36070: LD_INT 1
36072: PUSH
36073: LD_INT 1
36075: NEG
36076: PUSH
36077: EMPTY
36078: LIST
36079: LIST
36080: PUSH
36081: LD_INT 2
36083: PUSH
36084: LD_INT 0
36086: PUSH
36087: EMPTY
36088: LIST
36089: LIST
36090: PUSH
36091: LD_INT 2
36093: PUSH
36094: LD_INT 1
36096: PUSH
36097: EMPTY
36098: LIST
36099: LIST
36100: PUSH
36101: LD_INT 2
36103: PUSH
36104: LD_INT 2
36106: PUSH
36107: EMPTY
36108: LIST
36109: LIST
36110: PUSH
36111: LD_INT 1
36113: PUSH
36114: LD_INT 2
36116: PUSH
36117: EMPTY
36118: LIST
36119: LIST
36120: PUSH
36121: LD_INT 0
36123: PUSH
36124: LD_INT 2
36126: PUSH
36127: EMPTY
36128: LIST
36129: LIST
36130: PUSH
36131: LD_INT 1
36133: NEG
36134: PUSH
36135: LD_INT 1
36137: PUSH
36138: EMPTY
36139: LIST
36140: LIST
36141: PUSH
36142: LD_INT 2
36144: NEG
36145: PUSH
36146: LD_INT 0
36148: PUSH
36149: EMPTY
36150: LIST
36151: LIST
36152: PUSH
36153: LD_INT 2
36155: NEG
36156: PUSH
36157: LD_INT 1
36159: NEG
36160: PUSH
36161: EMPTY
36162: LIST
36163: LIST
36164: PUSH
36165: LD_INT 2
36167: NEG
36168: PUSH
36169: LD_INT 2
36171: NEG
36172: PUSH
36173: EMPTY
36174: LIST
36175: LIST
36176: PUSH
36177: EMPTY
36178: LIST
36179: LIST
36180: LIST
36181: LIST
36182: LIST
36183: LIST
36184: LIST
36185: LIST
36186: LIST
36187: LIST
36188: LIST
36189: LIST
36190: LIST
36191: LIST
36192: LIST
36193: LIST
36194: LIST
36195: LIST
36196: LIST
36197: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
36198: LD_ADDR_VAR 0 23
36202: PUSH
36203: LD_INT 0
36205: PUSH
36206: LD_INT 0
36208: PUSH
36209: EMPTY
36210: LIST
36211: LIST
36212: PUSH
36213: LD_INT 0
36215: PUSH
36216: LD_INT 1
36218: NEG
36219: PUSH
36220: EMPTY
36221: LIST
36222: LIST
36223: PUSH
36224: LD_INT 1
36226: PUSH
36227: LD_INT 0
36229: PUSH
36230: EMPTY
36231: LIST
36232: LIST
36233: PUSH
36234: LD_INT 1
36236: PUSH
36237: LD_INT 1
36239: PUSH
36240: EMPTY
36241: LIST
36242: LIST
36243: PUSH
36244: LD_INT 0
36246: PUSH
36247: LD_INT 1
36249: PUSH
36250: EMPTY
36251: LIST
36252: LIST
36253: PUSH
36254: LD_INT 1
36256: NEG
36257: PUSH
36258: LD_INT 0
36260: PUSH
36261: EMPTY
36262: LIST
36263: LIST
36264: PUSH
36265: LD_INT 1
36267: NEG
36268: PUSH
36269: LD_INT 1
36271: NEG
36272: PUSH
36273: EMPTY
36274: LIST
36275: LIST
36276: PUSH
36277: LD_INT 1
36279: NEG
36280: PUSH
36281: LD_INT 2
36283: NEG
36284: PUSH
36285: EMPTY
36286: LIST
36287: LIST
36288: PUSH
36289: LD_INT 0
36291: PUSH
36292: LD_INT 2
36294: NEG
36295: PUSH
36296: EMPTY
36297: LIST
36298: LIST
36299: PUSH
36300: LD_INT 1
36302: PUSH
36303: LD_INT 1
36305: NEG
36306: PUSH
36307: EMPTY
36308: LIST
36309: LIST
36310: PUSH
36311: LD_INT 2
36313: PUSH
36314: LD_INT 0
36316: PUSH
36317: EMPTY
36318: LIST
36319: LIST
36320: PUSH
36321: LD_INT 2
36323: PUSH
36324: LD_INT 1
36326: PUSH
36327: EMPTY
36328: LIST
36329: LIST
36330: PUSH
36331: LD_INT 2
36333: PUSH
36334: LD_INT 2
36336: PUSH
36337: EMPTY
36338: LIST
36339: LIST
36340: PUSH
36341: LD_INT 1
36343: PUSH
36344: LD_INT 2
36346: PUSH
36347: EMPTY
36348: LIST
36349: LIST
36350: PUSH
36351: LD_INT 0
36353: PUSH
36354: LD_INT 2
36356: PUSH
36357: EMPTY
36358: LIST
36359: LIST
36360: PUSH
36361: LD_INT 1
36363: NEG
36364: PUSH
36365: LD_INT 1
36367: PUSH
36368: EMPTY
36369: LIST
36370: LIST
36371: PUSH
36372: LD_INT 2
36374: NEG
36375: PUSH
36376: LD_INT 0
36378: PUSH
36379: EMPTY
36380: LIST
36381: LIST
36382: PUSH
36383: LD_INT 2
36385: NEG
36386: PUSH
36387: LD_INT 1
36389: NEG
36390: PUSH
36391: EMPTY
36392: LIST
36393: LIST
36394: PUSH
36395: LD_INT 2
36397: NEG
36398: PUSH
36399: LD_INT 2
36401: NEG
36402: PUSH
36403: EMPTY
36404: LIST
36405: LIST
36406: PUSH
36407: LD_INT 2
36409: NEG
36410: PUSH
36411: LD_INT 3
36413: NEG
36414: PUSH
36415: EMPTY
36416: LIST
36417: LIST
36418: PUSH
36419: LD_INT 1
36421: NEG
36422: PUSH
36423: LD_INT 3
36425: NEG
36426: PUSH
36427: EMPTY
36428: LIST
36429: LIST
36430: PUSH
36431: LD_INT 1
36433: PUSH
36434: LD_INT 2
36436: NEG
36437: PUSH
36438: EMPTY
36439: LIST
36440: LIST
36441: PUSH
36442: LD_INT 2
36444: PUSH
36445: LD_INT 1
36447: NEG
36448: PUSH
36449: EMPTY
36450: LIST
36451: LIST
36452: PUSH
36453: EMPTY
36454: LIST
36455: LIST
36456: LIST
36457: LIST
36458: LIST
36459: LIST
36460: LIST
36461: LIST
36462: LIST
36463: LIST
36464: LIST
36465: LIST
36466: LIST
36467: LIST
36468: LIST
36469: LIST
36470: LIST
36471: LIST
36472: LIST
36473: LIST
36474: LIST
36475: LIST
36476: LIST
36477: ST_TO_ADDR
// fDepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
36478: LD_ADDR_VAR 0 24
36482: PUSH
36483: LD_INT 0
36485: PUSH
36486: LD_INT 0
36488: PUSH
36489: EMPTY
36490: LIST
36491: LIST
36492: PUSH
36493: LD_INT 0
36495: PUSH
36496: LD_INT 1
36498: NEG
36499: PUSH
36500: EMPTY
36501: LIST
36502: LIST
36503: PUSH
36504: LD_INT 1
36506: PUSH
36507: LD_INT 0
36509: PUSH
36510: EMPTY
36511: LIST
36512: LIST
36513: PUSH
36514: LD_INT 1
36516: PUSH
36517: LD_INT 1
36519: PUSH
36520: EMPTY
36521: LIST
36522: LIST
36523: PUSH
36524: LD_INT 0
36526: PUSH
36527: LD_INT 1
36529: PUSH
36530: EMPTY
36531: LIST
36532: LIST
36533: PUSH
36534: LD_INT 1
36536: NEG
36537: PUSH
36538: LD_INT 0
36540: PUSH
36541: EMPTY
36542: LIST
36543: LIST
36544: PUSH
36545: LD_INT 1
36547: NEG
36548: PUSH
36549: LD_INT 1
36551: NEG
36552: PUSH
36553: EMPTY
36554: LIST
36555: LIST
36556: PUSH
36557: LD_INT 1
36559: NEG
36560: PUSH
36561: LD_INT 2
36563: NEG
36564: PUSH
36565: EMPTY
36566: LIST
36567: LIST
36568: PUSH
36569: LD_INT 0
36571: PUSH
36572: LD_INT 2
36574: NEG
36575: PUSH
36576: EMPTY
36577: LIST
36578: LIST
36579: PUSH
36580: LD_INT 1
36582: PUSH
36583: LD_INT 1
36585: NEG
36586: PUSH
36587: EMPTY
36588: LIST
36589: LIST
36590: PUSH
36591: LD_INT 2
36593: PUSH
36594: LD_INT 0
36596: PUSH
36597: EMPTY
36598: LIST
36599: LIST
36600: PUSH
36601: LD_INT 2
36603: PUSH
36604: LD_INT 1
36606: PUSH
36607: EMPTY
36608: LIST
36609: LIST
36610: PUSH
36611: LD_INT 2
36613: PUSH
36614: LD_INT 2
36616: PUSH
36617: EMPTY
36618: LIST
36619: LIST
36620: PUSH
36621: LD_INT 1
36623: PUSH
36624: LD_INT 2
36626: PUSH
36627: EMPTY
36628: LIST
36629: LIST
36630: PUSH
36631: LD_INT 0
36633: PUSH
36634: LD_INT 2
36636: PUSH
36637: EMPTY
36638: LIST
36639: LIST
36640: PUSH
36641: LD_INT 1
36643: NEG
36644: PUSH
36645: LD_INT 1
36647: PUSH
36648: EMPTY
36649: LIST
36650: LIST
36651: PUSH
36652: LD_INT 2
36654: NEG
36655: PUSH
36656: LD_INT 0
36658: PUSH
36659: EMPTY
36660: LIST
36661: LIST
36662: PUSH
36663: LD_INT 2
36665: NEG
36666: PUSH
36667: LD_INT 1
36669: NEG
36670: PUSH
36671: EMPTY
36672: LIST
36673: LIST
36674: PUSH
36675: LD_INT 2
36677: NEG
36678: PUSH
36679: LD_INT 2
36681: NEG
36682: PUSH
36683: EMPTY
36684: LIST
36685: LIST
36686: PUSH
36687: LD_INT 1
36689: PUSH
36690: LD_INT 2
36692: NEG
36693: PUSH
36694: EMPTY
36695: LIST
36696: LIST
36697: PUSH
36698: LD_INT 2
36700: PUSH
36701: LD_INT 1
36703: NEG
36704: PUSH
36705: EMPTY
36706: LIST
36707: LIST
36708: PUSH
36709: LD_INT 3
36711: PUSH
36712: LD_INT 1
36714: PUSH
36715: EMPTY
36716: LIST
36717: LIST
36718: PUSH
36719: LD_INT 3
36721: PUSH
36722: LD_INT 2
36724: PUSH
36725: EMPTY
36726: LIST
36727: LIST
36728: PUSH
36729: EMPTY
36730: LIST
36731: LIST
36732: LIST
36733: LIST
36734: LIST
36735: LIST
36736: LIST
36737: LIST
36738: LIST
36739: LIST
36740: LIST
36741: LIST
36742: LIST
36743: LIST
36744: LIST
36745: LIST
36746: LIST
36747: LIST
36748: LIST
36749: LIST
36750: LIST
36751: LIST
36752: LIST
36753: ST_TO_ADDR
// fDepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
36754: LD_ADDR_VAR 0 25
36758: PUSH
36759: LD_INT 0
36761: PUSH
36762: LD_INT 0
36764: PUSH
36765: EMPTY
36766: LIST
36767: LIST
36768: PUSH
36769: LD_INT 0
36771: PUSH
36772: LD_INT 1
36774: NEG
36775: PUSH
36776: EMPTY
36777: LIST
36778: LIST
36779: PUSH
36780: LD_INT 1
36782: PUSH
36783: LD_INT 0
36785: PUSH
36786: EMPTY
36787: LIST
36788: LIST
36789: PUSH
36790: LD_INT 1
36792: PUSH
36793: LD_INT 1
36795: PUSH
36796: EMPTY
36797: LIST
36798: LIST
36799: PUSH
36800: LD_INT 0
36802: PUSH
36803: LD_INT 1
36805: PUSH
36806: EMPTY
36807: LIST
36808: LIST
36809: PUSH
36810: LD_INT 1
36812: NEG
36813: PUSH
36814: LD_INT 0
36816: PUSH
36817: EMPTY
36818: LIST
36819: LIST
36820: PUSH
36821: LD_INT 1
36823: NEG
36824: PUSH
36825: LD_INT 1
36827: NEG
36828: PUSH
36829: EMPTY
36830: LIST
36831: LIST
36832: PUSH
36833: LD_INT 1
36835: NEG
36836: PUSH
36837: LD_INT 2
36839: NEG
36840: PUSH
36841: EMPTY
36842: LIST
36843: LIST
36844: PUSH
36845: LD_INT 0
36847: PUSH
36848: LD_INT 2
36850: NEG
36851: PUSH
36852: EMPTY
36853: LIST
36854: LIST
36855: PUSH
36856: LD_INT 1
36858: PUSH
36859: LD_INT 1
36861: NEG
36862: PUSH
36863: EMPTY
36864: LIST
36865: LIST
36866: PUSH
36867: LD_INT 2
36869: PUSH
36870: LD_INT 0
36872: PUSH
36873: EMPTY
36874: LIST
36875: LIST
36876: PUSH
36877: LD_INT 2
36879: PUSH
36880: LD_INT 1
36882: PUSH
36883: EMPTY
36884: LIST
36885: LIST
36886: PUSH
36887: LD_INT 2
36889: PUSH
36890: LD_INT 2
36892: PUSH
36893: EMPTY
36894: LIST
36895: LIST
36896: PUSH
36897: LD_INT 1
36899: PUSH
36900: LD_INT 2
36902: PUSH
36903: EMPTY
36904: LIST
36905: LIST
36906: PUSH
36907: LD_INT 0
36909: PUSH
36910: LD_INT 2
36912: PUSH
36913: EMPTY
36914: LIST
36915: LIST
36916: PUSH
36917: LD_INT 1
36919: NEG
36920: PUSH
36921: LD_INT 1
36923: PUSH
36924: EMPTY
36925: LIST
36926: LIST
36927: PUSH
36928: LD_INT 2
36930: NEG
36931: PUSH
36932: LD_INT 0
36934: PUSH
36935: EMPTY
36936: LIST
36937: LIST
36938: PUSH
36939: LD_INT 2
36941: NEG
36942: PUSH
36943: LD_INT 1
36945: NEG
36946: PUSH
36947: EMPTY
36948: LIST
36949: LIST
36950: PUSH
36951: LD_INT 2
36953: NEG
36954: PUSH
36955: LD_INT 2
36957: NEG
36958: PUSH
36959: EMPTY
36960: LIST
36961: LIST
36962: PUSH
36963: LD_INT 3
36965: PUSH
36966: LD_INT 1
36968: PUSH
36969: EMPTY
36970: LIST
36971: LIST
36972: PUSH
36973: LD_INT 3
36975: PUSH
36976: LD_INT 2
36978: PUSH
36979: EMPTY
36980: LIST
36981: LIST
36982: PUSH
36983: LD_INT 2
36985: PUSH
36986: LD_INT 3
36988: PUSH
36989: EMPTY
36990: LIST
36991: LIST
36992: PUSH
36993: LD_INT 1
36995: PUSH
36996: LD_INT 3
36998: PUSH
36999: EMPTY
37000: LIST
37001: LIST
37002: PUSH
37003: EMPTY
37004: LIST
37005: LIST
37006: LIST
37007: LIST
37008: LIST
37009: LIST
37010: LIST
37011: LIST
37012: LIST
37013: LIST
37014: LIST
37015: LIST
37016: LIST
37017: LIST
37018: LIST
37019: LIST
37020: LIST
37021: LIST
37022: LIST
37023: LIST
37024: LIST
37025: LIST
37026: LIST
37027: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
37028: LD_ADDR_VAR 0 26
37032: PUSH
37033: LD_INT 0
37035: PUSH
37036: LD_INT 0
37038: PUSH
37039: EMPTY
37040: LIST
37041: LIST
37042: PUSH
37043: LD_INT 0
37045: PUSH
37046: LD_INT 1
37048: NEG
37049: PUSH
37050: EMPTY
37051: LIST
37052: LIST
37053: PUSH
37054: LD_INT 1
37056: PUSH
37057: LD_INT 0
37059: PUSH
37060: EMPTY
37061: LIST
37062: LIST
37063: PUSH
37064: LD_INT 1
37066: PUSH
37067: LD_INT 1
37069: PUSH
37070: EMPTY
37071: LIST
37072: LIST
37073: PUSH
37074: LD_INT 0
37076: PUSH
37077: LD_INT 1
37079: PUSH
37080: EMPTY
37081: LIST
37082: LIST
37083: PUSH
37084: LD_INT 1
37086: NEG
37087: PUSH
37088: LD_INT 0
37090: PUSH
37091: EMPTY
37092: LIST
37093: LIST
37094: PUSH
37095: LD_INT 1
37097: NEG
37098: PUSH
37099: LD_INT 1
37101: NEG
37102: PUSH
37103: EMPTY
37104: LIST
37105: LIST
37106: PUSH
37107: LD_INT 1
37109: NEG
37110: PUSH
37111: LD_INT 2
37113: NEG
37114: PUSH
37115: EMPTY
37116: LIST
37117: LIST
37118: PUSH
37119: LD_INT 0
37121: PUSH
37122: LD_INT 2
37124: NEG
37125: PUSH
37126: EMPTY
37127: LIST
37128: LIST
37129: PUSH
37130: LD_INT 1
37132: PUSH
37133: LD_INT 1
37135: NEG
37136: PUSH
37137: EMPTY
37138: LIST
37139: LIST
37140: PUSH
37141: LD_INT 2
37143: PUSH
37144: LD_INT 0
37146: PUSH
37147: EMPTY
37148: LIST
37149: LIST
37150: PUSH
37151: LD_INT 2
37153: PUSH
37154: LD_INT 1
37156: PUSH
37157: EMPTY
37158: LIST
37159: LIST
37160: PUSH
37161: LD_INT 2
37163: PUSH
37164: LD_INT 2
37166: PUSH
37167: EMPTY
37168: LIST
37169: LIST
37170: PUSH
37171: LD_INT 1
37173: PUSH
37174: LD_INT 2
37176: PUSH
37177: EMPTY
37178: LIST
37179: LIST
37180: PUSH
37181: LD_INT 0
37183: PUSH
37184: LD_INT 2
37186: PUSH
37187: EMPTY
37188: LIST
37189: LIST
37190: PUSH
37191: LD_INT 1
37193: NEG
37194: PUSH
37195: LD_INT 1
37197: PUSH
37198: EMPTY
37199: LIST
37200: LIST
37201: PUSH
37202: LD_INT 2
37204: NEG
37205: PUSH
37206: LD_INT 0
37208: PUSH
37209: EMPTY
37210: LIST
37211: LIST
37212: PUSH
37213: LD_INT 2
37215: NEG
37216: PUSH
37217: LD_INT 1
37219: NEG
37220: PUSH
37221: EMPTY
37222: LIST
37223: LIST
37224: PUSH
37225: LD_INT 2
37227: NEG
37228: PUSH
37229: LD_INT 2
37231: NEG
37232: PUSH
37233: EMPTY
37234: LIST
37235: LIST
37236: PUSH
37237: LD_INT 2
37239: PUSH
37240: LD_INT 3
37242: PUSH
37243: EMPTY
37244: LIST
37245: LIST
37246: PUSH
37247: LD_INT 1
37249: PUSH
37250: LD_INT 3
37252: PUSH
37253: EMPTY
37254: LIST
37255: LIST
37256: PUSH
37257: LD_INT 1
37259: NEG
37260: PUSH
37261: LD_INT 2
37263: PUSH
37264: EMPTY
37265: LIST
37266: LIST
37267: PUSH
37268: LD_INT 2
37270: NEG
37271: PUSH
37272: LD_INT 1
37274: PUSH
37275: EMPTY
37276: LIST
37277: LIST
37278: PUSH
37279: EMPTY
37280: LIST
37281: LIST
37282: LIST
37283: LIST
37284: LIST
37285: LIST
37286: LIST
37287: LIST
37288: LIST
37289: LIST
37290: LIST
37291: LIST
37292: LIST
37293: LIST
37294: LIST
37295: LIST
37296: LIST
37297: LIST
37298: LIST
37299: LIST
37300: LIST
37301: LIST
37302: LIST
37303: ST_TO_ADDR
// fDepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
37304: LD_ADDR_VAR 0 27
37308: PUSH
37309: LD_INT 0
37311: PUSH
37312: LD_INT 0
37314: PUSH
37315: EMPTY
37316: LIST
37317: LIST
37318: PUSH
37319: LD_INT 0
37321: PUSH
37322: LD_INT 1
37324: NEG
37325: PUSH
37326: EMPTY
37327: LIST
37328: LIST
37329: PUSH
37330: LD_INT 1
37332: PUSH
37333: LD_INT 0
37335: PUSH
37336: EMPTY
37337: LIST
37338: LIST
37339: PUSH
37340: LD_INT 1
37342: PUSH
37343: LD_INT 1
37345: PUSH
37346: EMPTY
37347: LIST
37348: LIST
37349: PUSH
37350: LD_INT 0
37352: PUSH
37353: LD_INT 1
37355: PUSH
37356: EMPTY
37357: LIST
37358: LIST
37359: PUSH
37360: LD_INT 1
37362: NEG
37363: PUSH
37364: LD_INT 0
37366: PUSH
37367: EMPTY
37368: LIST
37369: LIST
37370: PUSH
37371: LD_INT 1
37373: NEG
37374: PUSH
37375: LD_INT 1
37377: NEG
37378: PUSH
37379: EMPTY
37380: LIST
37381: LIST
37382: PUSH
37383: LD_INT 1
37385: NEG
37386: PUSH
37387: LD_INT 2
37389: NEG
37390: PUSH
37391: EMPTY
37392: LIST
37393: LIST
37394: PUSH
37395: LD_INT 0
37397: PUSH
37398: LD_INT 2
37400: NEG
37401: PUSH
37402: EMPTY
37403: LIST
37404: LIST
37405: PUSH
37406: LD_INT 1
37408: PUSH
37409: LD_INT 1
37411: NEG
37412: PUSH
37413: EMPTY
37414: LIST
37415: LIST
37416: PUSH
37417: LD_INT 2
37419: PUSH
37420: LD_INT 0
37422: PUSH
37423: EMPTY
37424: LIST
37425: LIST
37426: PUSH
37427: LD_INT 2
37429: PUSH
37430: LD_INT 1
37432: PUSH
37433: EMPTY
37434: LIST
37435: LIST
37436: PUSH
37437: LD_INT 2
37439: PUSH
37440: LD_INT 2
37442: PUSH
37443: EMPTY
37444: LIST
37445: LIST
37446: PUSH
37447: LD_INT 1
37449: PUSH
37450: LD_INT 2
37452: PUSH
37453: EMPTY
37454: LIST
37455: LIST
37456: PUSH
37457: LD_INT 0
37459: PUSH
37460: LD_INT 2
37462: PUSH
37463: EMPTY
37464: LIST
37465: LIST
37466: PUSH
37467: LD_INT 1
37469: NEG
37470: PUSH
37471: LD_INT 1
37473: PUSH
37474: EMPTY
37475: LIST
37476: LIST
37477: PUSH
37478: LD_INT 2
37480: NEG
37481: PUSH
37482: LD_INT 0
37484: PUSH
37485: EMPTY
37486: LIST
37487: LIST
37488: PUSH
37489: LD_INT 2
37491: NEG
37492: PUSH
37493: LD_INT 1
37495: NEG
37496: PUSH
37497: EMPTY
37498: LIST
37499: LIST
37500: PUSH
37501: LD_INT 2
37503: NEG
37504: PUSH
37505: LD_INT 2
37507: NEG
37508: PUSH
37509: EMPTY
37510: LIST
37511: LIST
37512: PUSH
37513: LD_INT 1
37515: NEG
37516: PUSH
37517: LD_INT 2
37519: PUSH
37520: EMPTY
37521: LIST
37522: LIST
37523: PUSH
37524: LD_INT 2
37526: NEG
37527: PUSH
37528: LD_INT 1
37530: PUSH
37531: EMPTY
37532: LIST
37533: LIST
37534: PUSH
37535: LD_INT 3
37537: NEG
37538: PUSH
37539: LD_INT 1
37541: NEG
37542: PUSH
37543: EMPTY
37544: LIST
37545: LIST
37546: PUSH
37547: LD_INT 3
37549: NEG
37550: PUSH
37551: LD_INT 2
37553: NEG
37554: PUSH
37555: EMPTY
37556: LIST
37557: LIST
37558: PUSH
37559: EMPTY
37560: LIST
37561: LIST
37562: LIST
37563: LIST
37564: LIST
37565: LIST
37566: LIST
37567: LIST
37568: LIST
37569: LIST
37570: LIST
37571: LIST
37572: LIST
37573: LIST
37574: LIST
37575: LIST
37576: LIST
37577: LIST
37578: LIST
37579: LIST
37580: LIST
37581: LIST
37582: LIST
37583: ST_TO_ADDR
// fDepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
37584: LD_ADDR_VAR 0 28
37588: PUSH
37589: LD_INT 0
37591: PUSH
37592: LD_INT 0
37594: PUSH
37595: EMPTY
37596: LIST
37597: LIST
37598: PUSH
37599: LD_INT 0
37601: PUSH
37602: LD_INT 1
37604: NEG
37605: PUSH
37606: EMPTY
37607: LIST
37608: LIST
37609: PUSH
37610: LD_INT 1
37612: PUSH
37613: LD_INT 0
37615: PUSH
37616: EMPTY
37617: LIST
37618: LIST
37619: PUSH
37620: LD_INT 1
37622: PUSH
37623: LD_INT 1
37625: PUSH
37626: EMPTY
37627: LIST
37628: LIST
37629: PUSH
37630: LD_INT 0
37632: PUSH
37633: LD_INT 1
37635: PUSH
37636: EMPTY
37637: LIST
37638: LIST
37639: PUSH
37640: LD_INT 1
37642: NEG
37643: PUSH
37644: LD_INT 0
37646: PUSH
37647: EMPTY
37648: LIST
37649: LIST
37650: PUSH
37651: LD_INT 1
37653: NEG
37654: PUSH
37655: LD_INT 1
37657: NEG
37658: PUSH
37659: EMPTY
37660: LIST
37661: LIST
37662: PUSH
37663: LD_INT 1
37665: NEG
37666: PUSH
37667: LD_INT 2
37669: NEG
37670: PUSH
37671: EMPTY
37672: LIST
37673: LIST
37674: PUSH
37675: LD_INT 0
37677: PUSH
37678: LD_INT 2
37680: NEG
37681: PUSH
37682: EMPTY
37683: LIST
37684: LIST
37685: PUSH
37686: LD_INT 1
37688: PUSH
37689: LD_INT 1
37691: NEG
37692: PUSH
37693: EMPTY
37694: LIST
37695: LIST
37696: PUSH
37697: LD_INT 2
37699: PUSH
37700: LD_INT 0
37702: PUSH
37703: EMPTY
37704: LIST
37705: LIST
37706: PUSH
37707: LD_INT 2
37709: PUSH
37710: LD_INT 1
37712: PUSH
37713: EMPTY
37714: LIST
37715: LIST
37716: PUSH
37717: LD_INT 2
37719: PUSH
37720: LD_INT 2
37722: PUSH
37723: EMPTY
37724: LIST
37725: LIST
37726: PUSH
37727: LD_INT 1
37729: PUSH
37730: LD_INT 2
37732: PUSH
37733: EMPTY
37734: LIST
37735: LIST
37736: PUSH
37737: LD_INT 0
37739: PUSH
37740: LD_INT 2
37742: PUSH
37743: EMPTY
37744: LIST
37745: LIST
37746: PUSH
37747: LD_INT 1
37749: NEG
37750: PUSH
37751: LD_INT 1
37753: PUSH
37754: EMPTY
37755: LIST
37756: LIST
37757: PUSH
37758: LD_INT 2
37760: NEG
37761: PUSH
37762: LD_INT 0
37764: PUSH
37765: EMPTY
37766: LIST
37767: LIST
37768: PUSH
37769: LD_INT 2
37771: NEG
37772: PUSH
37773: LD_INT 1
37775: NEG
37776: PUSH
37777: EMPTY
37778: LIST
37779: LIST
37780: PUSH
37781: LD_INT 2
37783: NEG
37784: PUSH
37785: LD_INT 2
37787: NEG
37788: PUSH
37789: EMPTY
37790: LIST
37791: LIST
37792: PUSH
37793: LD_INT 2
37795: NEG
37796: PUSH
37797: LD_INT 3
37799: NEG
37800: PUSH
37801: EMPTY
37802: LIST
37803: LIST
37804: PUSH
37805: LD_INT 1
37807: NEG
37808: PUSH
37809: LD_INT 3
37811: NEG
37812: PUSH
37813: EMPTY
37814: LIST
37815: LIST
37816: PUSH
37817: LD_INT 3
37819: NEG
37820: PUSH
37821: LD_INT 1
37823: NEG
37824: PUSH
37825: EMPTY
37826: LIST
37827: LIST
37828: PUSH
37829: LD_INT 3
37831: NEG
37832: PUSH
37833: LD_INT 2
37835: NEG
37836: PUSH
37837: EMPTY
37838: LIST
37839: LIST
37840: PUSH
37841: EMPTY
37842: LIST
37843: LIST
37844: LIST
37845: LIST
37846: LIST
37847: LIST
37848: LIST
37849: LIST
37850: LIST
37851: LIST
37852: LIST
37853: LIST
37854: LIST
37855: LIST
37856: LIST
37857: LIST
37858: LIST
37859: LIST
37860: LIST
37861: LIST
37862: LIST
37863: LIST
37864: LIST
37865: ST_TO_ADDR
// fFactory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
37866: LD_ADDR_VAR 0 29
37870: PUSH
37871: LD_INT 0
37873: PUSH
37874: LD_INT 0
37876: PUSH
37877: EMPTY
37878: LIST
37879: LIST
37880: PUSH
37881: LD_INT 0
37883: PUSH
37884: LD_INT 1
37886: NEG
37887: PUSH
37888: EMPTY
37889: LIST
37890: LIST
37891: PUSH
37892: LD_INT 1
37894: PUSH
37895: LD_INT 0
37897: PUSH
37898: EMPTY
37899: LIST
37900: LIST
37901: PUSH
37902: LD_INT 1
37904: PUSH
37905: LD_INT 1
37907: PUSH
37908: EMPTY
37909: LIST
37910: LIST
37911: PUSH
37912: LD_INT 0
37914: PUSH
37915: LD_INT 1
37917: PUSH
37918: EMPTY
37919: LIST
37920: LIST
37921: PUSH
37922: LD_INT 1
37924: NEG
37925: PUSH
37926: LD_INT 0
37928: PUSH
37929: EMPTY
37930: LIST
37931: LIST
37932: PUSH
37933: LD_INT 1
37935: NEG
37936: PUSH
37937: LD_INT 1
37939: NEG
37940: PUSH
37941: EMPTY
37942: LIST
37943: LIST
37944: PUSH
37945: LD_INT 1
37947: NEG
37948: PUSH
37949: LD_INT 2
37951: NEG
37952: PUSH
37953: EMPTY
37954: LIST
37955: LIST
37956: PUSH
37957: LD_INT 0
37959: PUSH
37960: LD_INT 2
37962: NEG
37963: PUSH
37964: EMPTY
37965: LIST
37966: LIST
37967: PUSH
37968: LD_INT 1
37970: PUSH
37971: LD_INT 1
37973: NEG
37974: PUSH
37975: EMPTY
37976: LIST
37977: LIST
37978: PUSH
37979: LD_INT 2
37981: PUSH
37982: LD_INT 0
37984: PUSH
37985: EMPTY
37986: LIST
37987: LIST
37988: PUSH
37989: LD_INT 2
37991: PUSH
37992: LD_INT 1
37994: PUSH
37995: EMPTY
37996: LIST
37997: LIST
37998: PUSH
37999: LD_INT 1
38001: PUSH
38002: LD_INT 2
38004: PUSH
38005: EMPTY
38006: LIST
38007: LIST
38008: PUSH
38009: LD_INT 0
38011: PUSH
38012: LD_INT 2
38014: PUSH
38015: EMPTY
38016: LIST
38017: LIST
38018: PUSH
38019: LD_INT 1
38021: NEG
38022: PUSH
38023: LD_INT 1
38025: PUSH
38026: EMPTY
38027: LIST
38028: LIST
38029: PUSH
38030: LD_INT 2
38032: NEG
38033: PUSH
38034: LD_INT 1
38036: NEG
38037: PUSH
38038: EMPTY
38039: LIST
38040: LIST
38041: PUSH
38042: LD_INT 2
38044: NEG
38045: PUSH
38046: LD_INT 2
38048: NEG
38049: PUSH
38050: EMPTY
38051: LIST
38052: LIST
38053: PUSH
38054: LD_INT 2
38056: NEG
38057: PUSH
38058: LD_INT 3
38060: NEG
38061: PUSH
38062: EMPTY
38063: LIST
38064: LIST
38065: PUSH
38066: LD_INT 2
38068: PUSH
38069: LD_INT 1
38071: NEG
38072: PUSH
38073: EMPTY
38074: LIST
38075: LIST
38076: PUSH
38077: LD_INT 3
38079: PUSH
38080: LD_INT 1
38082: PUSH
38083: EMPTY
38084: LIST
38085: LIST
38086: PUSH
38087: LD_INT 1
38089: PUSH
38090: LD_INT 3
38092: PUSH
38093: EMPTY
38094: LIST
38095: LIST
38096: PUSH
38097: LD_INT 1
38099: NEG
38100: PUSH
38101: LD_INT 2
38103: PUSH
38104: EMPTY
38105: LIST
38106: LIST
38107: PUSH
38108: LD_INT 3
38110: NEG
38111: PUSH
38112: LD_INT 2
38114: NEG
38115: PUSH
38116: EMPTY
38117: LIST
38118: LIST
38119: PUSH
38120: EMPTY
38121: LIST
38122: LIST
38123: LIST
38124: LIST
38125: LIST
38126: LIST
38127: LIST
38128: LIST
38129: LIST
38130: LIST
38131: LIST
38132: LIST
38133: LIST
38134: LIST
38135: LIST
38136: LIST
38137: LIST
38138: LIST
38139: LIST
38140: LIST
38141: LIST
38142: LIST
38143: LIST
38144: ST_TO_ADDR
// fFactory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
38145: LD_ADDR_VAR 0 30
38149: PUSH
38150: LD_INT 0
38152: PUSH
38153: LD_INT 0
38155: PUSH
38156: EMPTY
38157: LIST
38158: LIST
38159: PUSH
38160: LD_INT 0
38162: PUSH
38163: LD_INT 1
38165: NEG
38166: PUSH
38167: EMPTY
38168: LIST
38169: LIST
38170: PUSH
38171: LD_INT 1
38173: PUSH
38174: LD_INT 0
38176: PUSH
38177: EMPTY
38178: LIST
38179: LIST
38180: PUSH
38181: LD_INT 1
38183: PUSH
38184: LD_INT 1
38186: PUSH
38187: EMPTY
38188: LIST
38189: LIST
38190: PUSH
38191: LD_INT 0
38193: PUSH
38194: LD_INT 1
38196: PUSH
38197: EMPTY
38198: LIST
38199: LIST
38200: PUSH
38201: LD_INT 1
38203: NEG
38204: PUSH
38205: LD_INT 0
38207: PUSH
38208: EMPTY
38209: LIST
38210: LIST
38211: PUSH
38212: LD_INT 1
38214: NEG
38215: PUSH
38216: LD_INT 1
38218: NEG
38219: PUSH
38220: EMPTY
38221: LIST
38222: LIST
38223: PUSH
38224: LD_INT 1
38226: NEG
38227: PUSH
38228: LD_INT 2
38230: NEG
38231: PUSH
38232: EMPTY
38233: LIST
38234: LIST
38235: PUSH
38236: LD_INT 0
38238: PUSH
38239: LD_INT 2
38241: NEG
38242: PUSH
38243: EMPTY
38244: LIST
38245: LIST
38246: PUSH
38247: LD_INT 1
38249: PUSH
38250: LD_INT 1
38252: NEG
38253: PUSH
38254: EMPTY
38255: LIST
38256: LIST
38257: PUSH
38258: LD_INT 2
38260: PUSH
38261: LD_INT 0
38263: PUSH
38264: EMPTY
38265: LIST
38266: LIST
38267: PUSH
38268: LD_INT 2
38270: PUSH
38271: LD_INT 1
38273: PUSH
38274: EMPTY
38275: LIST
38276: LIST
38277: PUSH
38278: LD_INT 2
38280: PUSH
38281: LD_INT 2
38283: PUSH
38284: EMPTY
38285: LIST
38286: LIST
38287: PUSH
38288: LD_INT 1
38290: PUSH
38291: LD_INT 2
38293: PUSH
38294: EMPTY
38295: LIST
38296: LIST
38297: PUSH
38298: LD_INT 1
38300: NEG
38301: PUSH
38302: LD_INT 1
38304: PUSH
38305: EMPTY
38306: LIST
38307: LIST
38308: PUSH
38309: LD_INT 2
38311: NEG
38312: PUSH
38313: LD_INT 0
38315: PUSH
38316: EMPTY
38317: LIST
38318: LIST
38319: PUSH
38320: LD_INT 2
38322: NEG
38323: PUSH
38324: LD_INT 1
38326: NEG
38327: PUSH
38328: EMPTY
38329: LIST
38330: LIST
38331: PUSH
38332: LD_INT 1
38334: NEG
38335: PUSH
38336: LD_INT 3
38338: NEG
38339: PUSH
38340: EMPTY
38341: LIST
38342: LIST
38343: PUSH
38344: LD_INT 1
38346: PUSH
38347: LD_INT 2
38349: NEG
38350: PUSH
38351: EMPTY
38352: LIST
38353: LIST
38354: PUSH
38355: LD_INT 3
38357: PUSH
38358: LD_INT 2
38360: PUSH
38361: EMPTY
38362: LIST
38363: LIST
38364: PUSH
38365: LD_INT 2
38367: PUSH
38368: LD_INT 3
38370: PUSH
38371: EMPTY
38372: LIST
38373: LIST
38374: PUSH
38375: LD_INT 2
38377: NEG
38378: PUSH
38379: LD_INT 1
38381: PUSH
38382: EMPTY
38383: LIST
38384: LIST
38385: PUSH
38386: LD_INT 3
38388: NEG
38389: PUSH
38390: LD_INT 1
38392: NEG
38393: PUSH
38394: EMPTY
38395: LIST
38396: LIST
38397: PUSH
38398: EMPTY
38399: LIST
38400: LIST
38401: LIST
38402: LIST
38403: LIST
38404: LIST
38405: LIST
38406: LIST
38407: LIST
38408: LIST
38409: LIST
38410: LIST
38411: LIST
38412: LIST
38413: LIST
38414: LIST
38415: LIST
38416: LIST
38417: LIST
38418: LIST
38419: LIST
38420: LIST
38421: LIST
38422: ST_TO_ADDR
// fFactory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
38423: LD_ADDR_VAR 0 31
38427: PUSH
38428: LD_INT 0
38430: PUSH
38431: LD_INT 0
38433: PUSH
38434: EMPTY
38435: LIST
38436: LIST
38437: PUSH
38438: LD_INT 0
38440: PUSH
38441: LD_INT 1
38443: NEG
38444: PUSH
38445: EMPTY
38446: LIST
38447: LIST
38448: PUSH
38449: LD_INT 1
38451: PUSH
38452: LD_INT 0
38454: PUSH
38455: EMPTY
38456: LIST
38457: LIST
38458: PUSH
38459: LD_INT 1
38461: PUSH
38462: LD_INT 1
38464: PUSH
38465: EMPTY
38466: LIST
38467: LIST
38468: PUSH
38469: LD_INT 0
38471: PUSH
38472: LD_INT 1
38474: PUSH
38475: EMPTY
38476: LIST
38477: LIST
38478: PUSH
38479: LD_INT 1
38481: NEG
38482: PUSH
38483: LD_INT 0
38485: PUSH
38486: EMPTY
38487: LIST
38488: LIST
38489: PUSH
38490: LD_INT 1
38492: NEG
38493: PUSH
38494: LD_INT 1
38496: NEG
38497: PUSH
38498: EMPTY
38499: LIST
38500: LIST
38501: PUSH
38502: LD_INT 1
38504: NEG
38505: PUSH
38506: LD_INT 2
38508: NEG
38509: PUSH
38510: EMPTY
38511: LIST
38512: LIST
38513: PUSH
38514: LD_INT 1
38516: PUSH
38517: LD_INT 1
38519: NEG
38520: PUSH
38521: EMPTY
38522: LIST
38523: LIST
38524: PUSH
38525: LD_INT 2
38527: PUSH
38528: LD_INT 0
38530: PUSH
38531: EMPTY
38532: LIST
38533: LIST
38534: PUSH
38535: LD_INT 2
38537: PUSH
38538: LD_INT 1
38540: PUSH
38541: EMPTY
38542: LIST
38543: LIST
38544: PUSH
38545: LD_INT 2
38547: PUSH
38548: LD_INT 2
38550: PUSH
38551: EMPTY
38552: LIST
38553: LIST
38554: PUSH
38555: LD_INT 1
38557: PUSH
38558: LD_INT 2
38560: PUSH
38561: EMPTY
38562: LIST
38563: LIST
38564: PUSH
38565: LD_INT 0
38567: PUSH
38568: LD_INT 2
38570: PUSH
38571: EMPTY
38572: LIST
38573: LIST
38574: PUSH
38575: LD_INT 1
38577: NEG
38578: PUSH
38579: LD_INT 1
38581: PUSH
38582: EMPTY
38583: LIST
38584: LIST
38585: PUSH
38586: LD_INT 2
38588: NEG
38589: PUSH
38590: LD_INT 1
38592: NEG
38593: PUSH
38594: EMPTY
38595: LIST
38596: LIST
38597: PUSH
38598: LD_INT 2
38600: NEG
38601: PUSH
38602: LD_INT 2
38604: NEG
38605: PUSH
38606: EMPTY
38607: LIST
38608: LIST
38609: PUSH
38610: LD_INT 2
38612: NEG
38613: PUSH
38614: LD_INT 3
38616: NEG
38617: PUSH
38618: EMPTY
38619: LIST
38620: LIST
38621: PUSH
38622: LD_INT 2
38624: PUSH
38625: LD_INT 1
38627: NEG
38628: PUSH
38629: EMPTY
38630: LIST
38631: LIST
38632: PUSH
38633: LD_INT 3
38635: PUSH
38636: LD_INT 1
38638: PUSH
38639: EMPTY
38640: LIST
38641: LIST
38642: PUSH
38643: LD_INT 1
38645: PUSH
38646: LD_INT 3
38648: PUSH
38649: EMPTY
38650: LIST
38651: LIST
38652: PUSH
38653: LD_INT 1
38655: NEG
38656: PUSH
38657: LD_INT 2
38659: PUSH
38660: EMPTY
38661: LIST
38662: LIST
38663: PUSH
38664: LD_INT 3
38666: NEG
38667: PUSH
38668: LD_INT 2
38670: NEG
38671: PUSH
38672: EMPTY
38673: LIST
38674: LIST
38675: PUSH
38676: EMPTY
38677: LIST
38678: LIST
38679: LIST
38680: LIST
38681: LIST
38682: LIST
38683: LIST
38684: LIST
38685: LIST
38686: LIST
38687: LIST
38688: LIST
38689: LIST
38690: LIST
38691: LIST
38692: LIST
38693: LIST
38694: LIST
38695: LIST
38696: LIST
38697: LIST
38698: LIST
38699: LIST
38700: ST_TO_ADDR
// fFactory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
38701: LD_ADDR_VAR 0 32
38705: PUSH
38706: LD_INT 0
38708: PUSH
38709: LD_INT 0
38711: PUSH
38712: EMPTY
38713: LIST
38714: LIST
38715: PUSH
38716: LD_INT 0
38718: PUSH
38719: LD_INT 1
38721: NEG
38722: PUSH
38723: EMPTY
38724: LIST
38725: LIST
38726: PUSH
38727: LD_INT 1
38729: PUSH
38730: LD_INT 0
38732: PUSH
38733: EMPTY
38734: LIST
38735: LIST
38736: PUSH
38737: LD_INT 1
38739: PUSH
38740: LD_INT 1
38742: PUSH
38743: EMPTY
38744: LIST
38745: LIST
38746: PUSH
38747: LD_INT 0
38749: PUSH
38750: LD_INT 1
38752: PUSH
38753: EMPTY
38754: LIST
38755: LIST
38756: PUSH
38757: LD_INT 1
38759: NEG
38760: PUSH
38761: LD_INT 0
38763: PUSH
38764: EMPTY
38765: LIST
38766: LIST
38767: PUSH
38768: LD_INT 1
38770: NEG
38771: PUSH
38772: LD_INT 1
38774: NEG
38775: PUSH
38776: EMPTY
38777: LIST
38778: LIST
38779: PUSH
38780: LD_INT 1
38782: NEG
38783: PUSH
38784: LD_INT 2
38786: NEG
38787: PUSH
38788: EMPTY
38789: LIST
38790: LIST
38791: PUSH
38792: LD_INT 0
38794: PUSH
38795: LD_INT 2
38797: NEG
38798: PUSH
38799: EMPTY
38800: LIST
38801: LIST
38802: PUSH
38803: LD_INT 1
38805: PUSH
38806: LD_INT 1
38808: NEG
38809: PUSH
38810: EMPTY
38811: LIST
38812: LIST
38813: PUSH
38814: LD_INT 2
38816: PUSH
38817: LD_INT 1
38819: PUSH
38820: EMPTY
38821: LIST
38822: LIST
38823: PUSH
38824: LD_INT 2
38826: PUSH
38827: LD_INT 2
38829: PUSH
38830: EMPTY
38831: LIST
38832: LIST
38833: PUSH
38834: LD_INT 1
38836: PUSH
38837: LD_INT 2
38839: PUSH
38840: EMPTY
38841: LIST
38842: LIST
38843: PUSH
38844: LD_INT 0
38846: PUSH
38847: LD_INT 2
38849: PUSH
38850: EMPTY
38851: LIST
38852: LIST
38853: PUSH
38854: LD_INT 1
38856: NEG
38857: PUSH
38858: LD_INT 1
38860: PUSH
38861: EMPTY
38862: LIST
38863: LIST
38864: PUSH
38865: LD_INT 2
38867: NEG
38868: PUSH
38869: LD_INT 0
38871: PUSH
38872: EMPTY
38873: LIST
38874: LIST
38875: PUSH
38876: LD_INT 2
38878: NEG
38879: PUSH
38880: LD_INT 1
38882: NEG
38883: PUSH
38884: EMPTY
38885: LIST
38886: LIST
38887: PUSH
38888: LD_INT 1
38890: NEG
38891: PUSH
38892: LD_INT 3
38894: NEG
38895: PUSH
38896: EMPTY
38897: LIST
38898: LIST
38899: PUSH
38900: LD_INT 1
38902: PUSH
38903: LD_INT 2
38905: NEG
38906: PUSH
38907: EMPTY
38908: LIST
38909: LIST
38910: PUSH
38911: LD_INT 3
38913: PUSH
38914: LD_INT 2
38916: PUSH
38917: EMPTY
38918: LIST
38919: LIST
38920: PUSH
38921: LD_INT 2
38923: PUSH
38924: LD_INT 3
38926: PUSH
38927: EMPTY
38928: LIST
38929: LIST
38930: PUSH
38931: LD_INT 2
38933: NEG
38934: PUSH
38935: LD_INT 1
38937: PUSH
38938: EMPTY
38939: LIST
38940: LIST
38941: PUSH
38942: LD_INT 3
38944: NEG
38945: PUSH
38946: LD_INT 1
38948: NEG
38949: PUSH
38950: EMPTY
38951: LIST
38952: LIST
38953: PUSH
38954: EMPTY
38955: LIST
38956: LIST
38957: LIST
38958: LIST
38959: LIST
38960: LIST
38961: LIST
38962: LIST
38963: LIST
38964: LIST
38965: LIST
38966: LIST
38967: LIST
38968: LIST
38969: LIST
38970: LIST
38971: LIST
38972: LIST
38973: LIST
38974: LIST
38975: LIST
38976: LIST
38977: LIST
38978: ST_TO_ADDR
// fFactory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
38979: LD_ADDR_VAR 0 33
38983: PUSH
38984: LD_INT 0
38986: PUSH
38987: LD_INT 0
38989: PUSH
38990: EMPTY
38991: LIST
38992: LIST
38993: PUSH
38994: LD_INT 0
38996: PUSH
38997: LD_INT 1
38999: NEG
39000: PUSH
39001: EMPTY
39002: LIST
39003: LIST
39004: PUSH
39005: LD_INT 1
39007: PUSH
39008: LD_INT 0
39010: PUSH
39011: EMPTY
39012: LIST
39013: LIST
39014: PUSH
39015: LD_INT 1
39017: PUSH
39018: LD_INT 1
39020: PUSH
39021: EMPTY
39022: LIST
39023: LIST
39024: PUSH
39025: LD_INT 0
39027: PUSH
39028: LD_INT 1
39030: PUSH
39031: EMPTY
39032: LIST
39033: LIST
39034: PUSH
39035: LD_INT 1
39037: NEG
39038: PUSH
39039: LD_INT 0
39041: PUSH
39042: EMPTY
39043: LIST
39044: LIST
39045: PUSH
39046: LD_INT 1
39048: NEG
39049: PUSH
39050: LD_INT 1
39052: NEG
39053: PUSH
39054: EMPTY
39055: LIST
39056: LIST
39057: PUSH
39058: LD_INT 1
39060: NEG
39061: PUSH
39062: LD_INT 2
39064: NEG
39065: PUSH
39066: EMPTY
39067: LIST
39068: LIST
39069: PUSH
39070: LD_INT 1
39072: PUSH
39073: LD_INT 1
39075: NEG
39076: PUSH
39077: EMPTY
39078: LIST
39079: LIST
39080: PUSH
39081: LD_INT 2
39083: PUSH
39084: LD_INT 0
39086: PUSH
39087: EMPTY
39088: LIST
39089: LIST
39090: PUSH
39091: LD_INT 2
39093: PUSH
39094: LD_INT 1
39096: PUSH
39097: EMPTY
39098: LIST
39099: LIST
39100: PUSH
39101: LD_INT 1
39103: PUSH
39104: LD_INT 2
39106: PUSH
39107: EMPTY
39108: LIST
39109: LIST
39110: PUSH
39111: LD_INT 0
39113: PUSH
39114: LD_INT 2
39116: PUSH
39117: EMPTY
39118: LIST
39119: LIST
39120: PUSH
39121: LD_INT 1
39123: NEG
39124: PUSH
39125: LD_INT 1
39127: PUSH
39128: EMPTY
39129: LIST
39130: LIST
39131: PUSH
39132: LD_INT 2
39134: NEG
39135: PUSH
39136: LD_INT 0
39138: PUSH
39139: EMPTY
39140: LIST
39141: LIST
39142: PUSH
39143: LD_INT 2
39145: NEG
39146: PUSH
39147: LD_INT 1
39149: NEG
39150: PUSH
39151: EMPTY
39152: LIST
39153: LIST
39154: PUSH
39155: LD_INT 2
39157: NEG
39158: PUSH
39159: LD_INT 2
39161: NEG
39162: PUSH
39163: EMPTY
39164: LIST
39165: LIST
39166: PUSH
39167: LD_INT 2
39169: NEG
39170: PUSH
39171: LD_INT 3
39173: NEG
39174: PUSH
39175: EMPTY
39176: LIST
39177: LIST
39178: PUSH
39179: LD_INT 2
39181: PUSH
39182: LD_INT 1
39184: NEG
39185: PUSH
39186: EMPTY
39187: LIST
39188: LIST
39189: PUSH
39190: LD_INT 3
39192: PUSH
39193: LD_INT 1
39195: PUSH
39196: EMPTY
39197: LIST
39198: LIST
39199: PUSH
39200: LD_INT 1
39202: PUSH
39203: LD_INT 3
39205: PUSH
39206: EMPTY
39207: LIST
39208: LIST
39209: PUSH
39210: LD_INT 1
39212: NEG
39213: PUSH
39214: LD_INT 2
39216: PUSH
39217: EMPTY
39218: LIST
39219: LIST
39220: PUSH
39221: LD_INT 3
39223: NEG
39224: PUSH
39225: LD_INT 2
39227: NEG
39228: PUSH
39229: EMPTY
39230: LIST
39231: LIST
39232: PUSH
39233: EMPTY
39234: LIST
39235: LIST
39236: LIST
39237: LIST
39238: LIST
39239: LIST
39240: LIST
39241: LIST
39242: LIST
39243: LIST
39244: LIST
39245: LIST
39246: LIST
39247: LIST
39248: LIST
39249: LIST
39250: LIST
39251: LIST
39252: LIST
39253: LIST
39254: LIST
39255: LIST
39256: LIST
39257: ST_TO_ADDR
// fFactory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
39258: LD_ADDR_VAR 0 34
39262: PUSH
39263: LD_INT 0
39265: PUSH
39266: LD_INT 0
39268: PUSH
39269: EMPTY
39270: LIST
39271: LIST
39272: PUSH
39273: LD_INT 0
39275: PUSH
39276: LD_INT 1
39278: NEG
39279: PUSH
39280: EMPTY
39281: LIST
39282: LIST
39283: PUSH
39284: LD_INT 1
39286: PUSH
39287: LD_INT 0
39289: PUSH
39290: EMPTY
39291: LIST
39292: LIST
39293: PUSH
39294: LD_INT 1
39296: PUSH
39297: LD_INT 1
39299: PUSH
39300: EMPTY
39301: LIST
39302: LIST
39303: PUSH
39304: LD_INT 0
39306: PUSH
39307: LD_INT 1
39309: PUSH
39310: EMPTY
39311: LIST
39312: LIST
39313: PUSH
39314: LD_INT 1
39316: NEG
39317: PUSH
39318: LD_INT 0
39320: PUSH
39321: EMPTY
39322: LIST
39323: LIST
39324: PUSH
39325: LD_INT 1
39327: NEG
39328: PUSH
39329: LD_INT 1
39331: NEG
39332: PUSH
39333: EMPTY
39334: LIST
39335: LIST
39336: PUSH
39337: LD_INT 1
39339: NEG
39340: PUSH
39341: LD_INT 2
39343: NEG
39344: PUSH
39345: EMPTY
39346: LIST
39347: LIST
39348: PUSH
39349: LD_INT 0
39351: PUSH
39352: LD_INT 2
39354: NEG
39355: PUSH
39356: EMPTY
39357: LIST
39358: LIST
39359: PUSH
39360: LD_INT 1
39362: PUSH
39363: LD_INT 1
39365: NEG
39366: PUSH
39367: EMPTY
39368: LIST
39369: LIST
39370: PUSH
39371: LD_INT 2
39373: PUSH
39374: LD_INT 1
39376: PUSH
39377: EMPTY
39378: LIST
39379: LIST
39380: PUSH
39381: LD_INT 2
39383: PUSH
39384: LD_INT 2
39386: PUSH
39387: EMPTY
39388: LIST
39389: LIST
39390: PUSH
39391: LD_INT 1
39393: PUSH
39394: LD_INT 2
39396: PUSH
39397: EMPTY
39398: LIST
39399: LIST
39400: PUSH
39401: LD_INT 1
39403: NEG
39404: PUSH
39405: LD_INT 1
39407: PUSH
39408: EMPTY
39409: LIST
39410: LIST
39411: PUSH
39412: LD_INT 2
39414: NEG
39415: PUSH
39416: LD_INT 0
39418: PUSH
39419: EMPTY
39420: LIST
39421: LIST
39422: PUSH
39423: LD_INT 2
39425: NEG
39426: PUSH
39427: LD_INT 1
39429: NEG
39430: PUSH
39431: EMPTY
39432: LIST
39433: LIST
39434: PUSH
39435: LD_INT 2
39437: NEG
39438: PUSH
39439: LD_INT 2
39441: NEG
39442: PUSH
39443: EMPTY
39444: LIST
39445: LIST
39446: PUSH
39447: LD_INT 1
39449: NEG
39450: PUSH
39451: LD_INT 3
39453: NEG
39454: PUSH
39455: EMPTY
39456: LIST
39457: LIST
39458: PUSH
39459: LD_INT 1
39461: PUSH
39462: LD_INT 2
39464: NEG
39465: PUSH
39466: EMPTY
39467: LIST
39468: LIST
39469: PUSH
39470: LD_INT 3
39472: PUSH
39473: LD_INT 2
39475: PUSH
39476: EMPTY
39477: LIST
39478: LIST
39479: PUSH
39480: LD_INT 2
39482: PUSH
39483: LD_INT 3
39485: PUSH
39486: EMPTY
39487: LIST
39488: LIST
39489: PUSH
39490: LD_INT 2
39492: NEG
39493: PUSH
39494: LD_INT 1
39496: PUSH
39497: EMPTY
39498: LIST
39499: LIST
39500: PUSH
39501: LD_INT 3
39503: NEG
39504: PUSH
39505: LD_INT 1
39507: NEG
39508: PUSH
39509: EMPTY
39510: LIST
39511: LIST
39512: PUSH
39513: EMPTY
39514: LIST
39515: LIST
39516: LIST
39517: LIST
39518: LIST
39519: LIST
39520: LIST
39521: LIST
39522: LIST
39523: LIST
39524: LIST
39525: LIST
39526: LIST
39527: LIST
39528: LIST
39529: LIST
39530: LIST
39531: LIST
39532: LIST
39533: LIST
39534: LIST
39535: LIST
39536: LIST
39537: ST_TO_ADDR
// fExt0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
39538: LD_ADDR_VAR 0 35
39542: PUSH
39543: LD_INT 0
39545: PUSH
39546: LD_INT 0
39548: PUSH
39549: EMPTY
39550: LIST
39551: LIST
39552: PUSH
39553: LD_INT 0
39555: PUSH
39556: LD_INT 1
39558: NEG
39559: PUSH
39560: EMPTY
39561: LIST
39562: LIST
39563: PUSH
39564: LD_INT 1
39566: PUSH
39567: LD_INT 0
39569: PUSH
39570: EMPTY
39571: LIST
39572: LIST
39573: PUSH
39574: LD_INT 1
39576: PUSH
39577: LD_INT 1
39579: PUSH
39580: EMPTY
39581: LIST
39582: LIST
39583: PUSH
39584: LD_INT 0
39586: PUSH
39587: LD_INT 1
39589: PUSH
39590: EMPTY
39591: LIST
39592: LIST
39593: PUSH
39594: LD_INT 1
39596: NEG
39597: PUSH
39598: LD_INT 0
39600: PUSH
39601: EMPTY
39602: LIST
39603: LIST
39604: PUSH
39605: LD_INT 1
39607: NEG
39608: PUSH
39609: LD_INT 1
39611: NEG
39612: PUSH
39613: EMPTY
39614: LIST
39615: LIST
39616: PUSH
39617: LD_INT 2
39619: PUSH
39620: LD_INT 1
39622: PUSH
39623: EMPTY
39624: LIST
39625: LIST
39626: PUSH
39627: LD_INT 2
39629: NEG
39630: PUSH
39631: LD_INT 1
39633: NEG
39634: PUSH
39635: EMPTY
39636: LIST
39637: LIST
39638: PUSH
39639: EMPTY
39640: LIST
39641: LIST
39642: LIST
39643: LIST
39644: LIST
39645: LIST
39646: LIST
39647: LIST
39648: LIST
39649: ST_TO_ADDR
// fExt1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
39650: LD_ADDR_VAR 0 36
39654: PUSH
39655: LD_INT 0
39657: PUSH
39658: LD_INT 0
39660: PUSH
39661: EMPTY
39662: LIST
39663: LIST
39664: PUSH
39665: LD_INT 0
39667: PUSH
39668: LD_INT 1
39670: NEG
39671: PUSH
39672: EMPTY
39673: LIST
39674: LIST
39675: PUSH
39676: LD_INT 1
39678: PUSH
39679: LD_INT 0
39681: PUSH
39682: EMPTY
39683: LIST
39684: LIST
39685: PUSH
39686: LD_INT 1
39688: PUSH
39689: LD_INT 1
39691: PUSH
39692: EMPTY
39693: LIST
39694: LIST
39695: PUSH
39696: LD_INT 0
39698: PUSH
39699: LD_INT 1
39701: PUSH
39702: EMPTY
39703: LIST
39704: LIST
39705: PUSH
39706: LD_INT 1
39708: NEG
39709: PUSH
39710: LD_INT 0
39712: PUSH
39713: EMPTY
39714: LIST
39715: LIST
39716: PUSH
39717: LD_INT 1
39719: NEG
39720: PUSH
39721: LD_INT 1
39723: NEG
39724: PUSH
39725: EMPTY
39726: LIST
39727: LIST
39728: PUSH
39729: LD_INT 1
39731: NEG
39732: PUSH
39733: LD_INT 2
39735: NEG
39736: PUSH
39737: EMPTY
39738: LIST
39739: LIST
39740: PUSH
39741: LD_INT 1
39743: PUSH
39744: LD_INT 2
39746: PUSH
39747: EMPTY
39748: LIST
39749: LIST
39750: PUSH
39751: EMPTY
39752: LIST
39753: LIST
39754: LIST
39755: LIST
39756: LIST
39757: LIST
39758: LIST
39759: LIST
39760: LIST
39761: ST_TO_ADDR
// fExt2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
39762: LD_ADDR_VAR 0 37
39766: PUSH
39767: LD_INT 0
39769: PUSH
39770: LD_INT 0
39772: PUSH
39773: EMPTY
39774: LIST
39775: LIST
39776: PUSH
39777: LD_INT 0
39779: PUSH
39780: LD_INT 1
39782: NEG
39783: PUSH
39784: EMPTY
39785: LIST
39786: LIST
39787: PUSH
39788: LD_INT 1
39790: PUSH
39791: LD_INT 0
39793: PUSH
39794: EMPTY
39795: LIST
39796: LIST
39797: PUSH
39798: LD_INT 1
39800: PUSH
39801: LD_INT 1
39803: PUSH
39804: EMPTY
39805: LIST
39806: LIST
39807: PUSH
39808: LD_INT 0
39810: PUSH
39811: LD_INT 1
39813: PUSH
39814: EMPTY
39815: LIST
39816: LIST
39817: PUSH
39818: LD_INT 1
39820: NEG
39821: PUSH
39822: LD_INT 0
39824: PUSH
39825: EMPTY
39826: LIST
39827: LIST
39828: PUSH
39829: LD_INT 1
39831: NEG
39832: PUSH
39833: LD_INT 1
39835: NEG
39836: PUSH
39837: EMPTY
39838: LIST
39839: LIST
39840: PUSH
39841: LD_INT 1
39843: PUSH
39844: LD_INT 1
39846: NEG
39847: PUSH
39848: EMPTY
39849: LIST
39850: LIST
39851: PUSH
39852: LD_INT 1
39854: NEG
39855: PUSH
39856: LD_INT 1
39858: PUSH
39859: EMPTY
39860: LIST
39861: LIST
39862: PUSH
39863: EMPTY
39864: LIST
39865: LIST
39866: LIST
39867: LIST
39868: LIST
39869: LIST
39870: LIST
39871: LIST
39872: LIST
39873: ST_TO_ADDR
// fExt3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
39874: LD_ADDR_VAR 0 38
39878: PUSH
39879: LD_INT 0
39881: PUSH
39882: LD_INT 0
39884: PUSH
39885: EMPTY
39886: LIST
39887: LIST
39888: PUSH
39889: LD_INT 0
39891: PUSH
39892: LD_INT 1
39894: NEG
39895: PUSH
39896: EMPTY
39897: LIST
39898: LIST
39899: PUSH
39900: LD_INT 1
39902: PUSH
39903: LD_INT 0
39905: PUSH
39906: EMPTY
39907: LIST
39908: LIST
39909: PUSH
39910: LD_INT 1
39912: PUSH
39913: LD_INT 1
39915: PUSH
39916: EMPTY
39917: LIST
39918: LIST
39919: PUSH
39920: LD_INT 0
39922: PUSH
39923: LD_INT 1
39925: PUSH
39926: EMPTY
39927: LIST
39928: LIST
39929: PUSH
39930: LD_INT 1
39932: NEG
39933: PUSH
39934: LD_INT 0
39936: PUSH
39937: EMPTY
39938: LIST
39939: LIST
39940: PUSH
39941: LD_INT 1
39943: NEG
39944: PUSH
39945: LD_INT 1
39947: NEG
39948: PUSH
39949: EMPTY
39950: LIST
39951: LIST
39952: PUSH
39953: LD_INT 2
39955: PUSH
39956: LD_INT 1
39958: PUSH
39959: EMPTY
39960: LIST
39961: LIST
39962: PUSH
39963: LD_INT 2
39965: NEG
39966: PUSH
39967: LD_INT 1
39969: NEG
39970: PUSH
39971: EMPTY
39972: LIST
39973: LIST
39974: PUSH
39975: EMPTY
39976: LIST
39977: LIST
39978: LIST
39979: LIST
39980: LIST
39981: LIST
39982: LIST
39983: LIST
39984: LIST
39985: ST_TO_ADDR
// fExt4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
39986: LD_ADDR_VAR 0 39
39990: PUSH
39991: LD_INT 0
39993: PUSH
39994: LD_INT 0
39996: PUSH
39997: EMPTY
39998: LIST
39999: LIST
40000: PUSH
40001: LD_INT 0
40003: PUSH
40004: LD_INT 1
40006: NEG
40007: PUSH
40008: EMPTY
40009: LIST
40010: LIST
40011: PUSH
40012: LD_INT 1
40014: PUSH
40015: LD_INT 0
40017: PUSH
40018: EMPTY
40019: LIST
40020: LIST
40021: PUSH
40022: LD_INT 1
40024: PUSH
40025: LD_INT 1
40027: PUSH
40028: EMPTY
40029: LIST
40030: LIST
40031: PUSH
40032: LD_INT 0
40034: PUSH
40035: LD_INT 1
40037: PUSH
40038: EMPTY
40039: LIST
40040: LIST
40041: PUSH
40042: LD_INT 1
40044: NEG
40045: PUSH
40046: LD_INT 0
40048: PUSH
40049: EMPTY
40050: LIST
40051: LIST
40052: PUSH
40053: LD_INT 1
40055: NEG
40056: PUSH
40057: LD_INT 1
40059: NEG
40060: PUSH
40061: EMPTY
40062: LIST
40063: LIST
40064: PUSH
40065: LD_INT 1
40067: NEG
40068: PUSH
40069: LD_INT 2
40071: NEG
40072: PUSH
40073: EMPTY
40074: LIST
40075: LIST
40076: PUSH
40077: LD_INT 1
40079: PUSH
40080: LD_INT 2
40082: PUSH
40083: EMPTY
40084: LIST
40085: LIST
40086: PUSH
40087: EMPTY
40088: LIST
40089: LIST
40090: LIST
40091: LIST
40092: LIST
40093: LIST
40094: LIST
40095: LIST
40096: LIST
40097: ST_TO_ADDR
// fExt5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
40098: LD_ADDR_VAR 0 40
40102: PUSH
40103: LD_INT 0
40105: PUSH
40106: LD_INT 0
40108: PUSH
40109: EMPTY
40110: LIST
40111: LIST
40112: PUSH
40113: LD_INT 0
40115: PUSH
40116: LD_INT 1
40118: NEG
40119: PUSH
40120: EMPTY
40121: LIST
40122: LIST
40123: PUSH
40124: LD_INT 1
40126: PUSH
40127: LD_INT 0
40129: PUSH
40130: EMPTY
40131: LIST
40132: LIST
40133: PUSH
40134: LD_INT 1
40136: PUSH
40137: LD_INT 1
40139: PUSH
40140: EMPTY
40141: LIST
40142: LIST
40143: PUSH
40144: LD_INT 0
40146: PUSH
40147: LD_INT 1
40149: PUSH
40150: EMPTY
40151: LIST
40152: LIST
40153: PUSH
40154: LD_INT 1
40156: NEG
40157: PUSH
40158: LD_INT 0
40160: PUSH
40161: EMPTY
40162: LIST
40163: LIST
40164: PUSH
40165: LD_INT 1
40167: NEG
40168: PUSH
40169: LD_INT 1
40171: NEG
40172: PUSH
40173: EMPTY
40174: LIST
40175: LIST
40176: PUSH
40177: LD_INT 1
40179: PUSH
40180: LD_INT 1
40182: NEG
40183: PUSH
40184: EMPTY
40185: LIST
40186: LIST
40187: PUSH
40188: LD_INT 1
40190: NEG
40191: PUSH
40192: LD_INT 1
40194: PUSH
40195: EMPTY
40196: LIST
40197: LIST
40198: PUSH
40199: EMPTY
40200: LIST
40201: LIST
40202: LIST
40203: LIST
40204: LIST
40205: LIST
40206: LIST
40207: LIST
40208: LIST
40209: ST_TO_ADDR
// fLab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
40210: LD_ADDR_VAR 0 41
40214: PUSH
40215: LD_INT 0
40217: PUSH
40218: LD_INT 0
40220: PUSH
40221: EMPTY
40222: LIST
40223: LIST
40224: PUSH
40225: LD_INT 0
40227: PUSH
40228: LD_INT 1
40230: NEG
40231: PUSH
40232: EMPTY
40233: LIST
40234: LIST
40235: PUSH
40236: LD_INT 1
40238: PUSH
40239: LD_INT 0
40241: PUSH
40242: EMPTY
40243: LIST
40244: LIST
40245: PUSH
40246: LD_INT 1
40248: PUSH
40249: LD_INT 1
40251: PUSH
40252: EMPTY
40253: LIST
40254: LIST
40255: PUSH
40256: LD_INT 0
40258: PUSH
40259: LD_INT 1
40261: PUSH
40262: EMPTY
40263: LIST
40264: LIST
40265: PUSH
40266: LD_INT 1
40268: NEG
40269: PUSH
40270: LD_INT 0
40272: PUSH
40273: EMPTY
40274: LIST
40275: LIST
40276: PUSH
40277: LD_INT 1
40279: NEG
40280: PUSH
40281: LD_INT 1
40283: NEG
40284: PUSH
40285: EMPTY
40286: LIST
40287: LIST
40288: PUSH
40289: LD_INT 1
40291: NEG
40292: PUSH
40293: LD_INT 2
40295: NEG
40296: PUSH
40297: EMPTY
40298: LIST
40299: LIST
40300: PUSH
40301: LD_INT 1
40303: PUSH
40304: LD_INT 1
40306: NEG
40307: PUSH
40308: EMPTY
40309: LIST
40310: LIST
40311: PUSH
40312: LD_INT 2
40314: PUSH
40315: LD_INT 0
40317: PUSH
40318: EMPTY
40319: LIST
40320: LIST
40321: PUSH
40322: LD_INT 2
40324: PUSH
40325: LD_INT 1
40327: PUSH
40328: EMPTY
40329: LIST
40330: LIST
40331: PUSH
40332: LD_INT 2
40334: PUSH
40335: LD_INT 2
40337: PUSH
40338: EMPTY
40339: LIST
40340: LIST
40341: PUSH
40342: LD_INT 1
40344: PUSH
40345: LD_INT 2
40347: PUSH
40348: EMPTY
40349: LIST
40350: LIST
40351: PUSH
40352: LD_INT 1
40354: NEG
40355: PUSH
40356: LD_INT 1
40358: PUSH
40359: EMPTY
40360: LIST
40361: LIST
40362: PUSH
40363: LD_INT 2
40365: NEG
40366: PUSH
40367: LD_INT 0
40369: PUSH
40370: EMPTY
40371: LIST
40372: LIST
40373: PUSH
40374: LD_INT 2
40376: NEG
40377: PUSH
40378: LD_INT 1
40380: NEG
40381: PUSH
40382: EMPTY
40383: LIST
40384: LIST
40385: PUSH
40386: LD_INT 2
40388: NEG
40389: PUSH
40390: LD_INT 2
40392: NEG
40393: PUSH
40394: EMPTY
40395: LIST
40396: LIST
40397: PUSH
40398: LD_INT 2
40400: NEG
40401: PUSH
40402: LD_INT 3
40404: NEG
40405: PUSH
40406: EMPTY
40407: LIST
40408: LIST
40409: PUSH
40410: LD_INT 2
40412: PUSH
40413: LD_INT 1
40415: NEG
40416: PUSH
40417: EMPTY
40418: LIST
40419: LIST
40420: PUSH
40421: LD_INT 3
40423: PUSH
40424: LD_INT 0
40426: PUSH
40427: EMPTY
40428: LIST
40429: LIST
40430: PUSH
40431: LD_INT 3
40433: PUSH
40434: LD_INT 1
40436: PUSH
40437: EMPTY
40438: LIST
40439: LIST
40440: PUSH
40441: LD_INT 3
40443: PUSH
40444: LD_INT 2
40446: PUSH
40447: EMPTY
40448: LIST
40449: LIST
40450: PUSH
40451: LD_INT 3
40453: PUSH
40454: LD_INT 3
40456: PUSH
40457: EMPTY
40458: LIST
40459: LIST
40460: PUSH
40461: LD_INT 2
40463: PUSH
40464: LD_INT 3
40466: PUSH
40467: EMPTY
40468: LIST
40469: LIST
40470: PUSH
40471: LD_INT 2
40473: NEG
40474: PUSH
40475: LD_INT 1
40477: PUSH
40478: EMPTY
40479: LIST
40480: LIST
40481: PUSH
40482: LD_INT 3
40484: NEG
40485: PUSH
40486: LD_INT 0
40488: PUSH
40489: EMPTY
40490: LIST
40491: LIST
40492: PUSH
40493: LD_INT 3
40495: NEG
40496: PUSH
40497: LD_INT 1
40499: NEG
40500: PUSH
40501: EMPTY
40502: LIST
40503: LIST
40504: PUSH
40505: LD_INT 3
40507: NEG
40508: PUSH
40509: LD_INT 2
40511: NEG
40512: PUSH
40513: EMPTY
40514: LIST
40515: LIST
40516: PUSH
40517: LD_INT 3
40519: NEG
40520: PUSH
40521: LD_INT 3
40523: NEG
40524: PUSH
40525: EMPTY
40526: LIST
40527: LIST
40528: PUSH
40529: EMPTY
40530: LIST
40531: LIST
40532: LIST
40533: LIST
40534: LIST
40535: LIST
40536: LIST
40537: LIST
40538: LIST
40539: LIST
40540: LIST
40541: LIST
40542: LIST
40543: LIST
40544: LIST
40545: LIST
40546: LIST
40547: LIST
40548: LIST
40549: LIST
40550: LIST
40551: LIST
40552: LIST
40553: LIST
40554: LIST
40555: LIST
40556: LIST
40557: LIST
40558: LIST
40559: ST_TO_ADDR
// fLab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
40560: LD_ADDR_VAR 0 42
40564: PUSH
40565: LD_INT 0
40567: PUSH
40568: LD_INT 0
40570: PUSH
40571: EMPTY
40572: LIST
40573: LIST
40574: PUSH
40575: LD_INT 0
40577: PUSH
40578: LD_INT 1
40580: NEG
40581: PUSH
40582: EMPTY
40583: LIST
40584: LIST
40585: PUSH
40586: LD_INT 1
40588: PUSH
40589: LD_INT 0
40591: PUSH
40592: EMPTY
40593: LIST
40594: LIST
40595: PUSH
40596: LD_INT 1
40598: PUSH
40599: LD_INT 1
40601: PUSH
40602: EMPTY
40603: LIST
40604: LIST
40605: PUSH
40606: LD_INT 0
40608: PUSH
40609: LD_INT 1
40611: PUSH
40612: EMPTY
40613: LIST
40614: LIST
40615: PUSH
40616: LD_INT 1
40618: NEG
40619: PUSH
40620: LD_INT 0
40622: PUSH
40623: EMPTY
40624: LIST
40625: LIST
40626: PUSH
40627: LD_INT 1
40629: NEG
40630: PUSH
40631: LD_INT 1
40633: NEG
40634: PUSH
40635: EMPTY
40636: LIST
40637: LIST
40638: PUSH
40639: LD_INT 1
40641: NEG
40642: PUSH
40643: LD_INT 2
40645: NEG
40646: PUSH
40647: EMPTY
40648: LIST
40649: LIST
40650: PUSH
40651: LD_INT 0
40653: PUSH
40654: LD_INT 2
40656: NEG
40657: PUSH
40658: EMPTY
40659: LIST
40660: LIST
40661: PUSH
40662: LD_INT 1
40664: PUSH
40665: LD_INT 1
40667: NEG
40668: PUSH
40669: EMPTY
40670: LIST
40671: LIST
40672: PUSH
40673: LD_INT 2
40675: PUSH
40676: LD_INT 1
40678: PUSH
40679: EMPTY
40680: LIST
40681: LIST
40682: PUSH
40683: LD_INT 2
40685: PUSH
40686: LD_INT 2
40688: PUSH
40689: EMPTY
40690: LIST
40691: LIST
40692: PUSH
40693: LD_INT 1
40695: PUSH
40696: LD_INT 2
40698: PUSH
40699: EMPTY
40700: LIST
40701: LIST
40702: PUSH
40703: LD_INT 0
40705: PUSH
40706: LD_INT 2
40708: PUSH
40709: EMPTY
40710: LIST
40711: LIST
40712: PUSH
40713: LD_INT 1
40715: NEG
40716: PUSH
40717: LD_INT 1
40719: PUSH
40720: EMPTY
40721: LIST
40722: LIST
40723: PUSH
40724: LD_INT 2
40726: NEG
40727: PUSH
40728: LD_INT 1
40730: NEG
40731: PUSH
40732: EMPTY
40733: LIST
40734: LIST
40735: PUSH
40736: LD_INT 2
40738: NEG
40739: PUSH
40740: LD_INT 2
40742: NEG
40743: PUSH
40744: EMPTY
40745: LIST
40746: LIST
40747: PUSH
40748: LD_INT 2
40750: NEG
40751: PUSH
40752: LD_INT 3
40754: NEG
40755: PUSH
40756: EMPTY
40757: LIST
40758: LIST
40759: PUSH
40760: LD_INT 1
40762: NEG
40763: PUSH
40764: LD_INT 3
40766: NEG
40767: PUSH
40768: EMPTY
40769: LIST
40770: LIST
40771: PUSH
40772: LD_INT 0
40774: PUSH
40775: LD_INT 3
40777: NEG
40778: PUSH
40779: EMPTY
40780: LIST
40781: LIST
40782: PUSH
40783: LD_INT 1
40785: PUSH
40786: LD_INT 2
40788: NEG
40789: PUSH
40790: EMPTY
40791: LIST
40792: LIST
40793: PUSH
40794: LD_INT 3
40796: PUSH
40797: LD_INT 2
40799: PUSH
40800: EMPTY
40801: LIST
40802: LIST
40803: PUSH
40804: LD_INT 3
40806: PUSH
40807: LD_INT 3
40809: PUSH
40810: EMPTY
40811: LIST
40812: LIST
40813: PUSH
40814: LD_INT 2
40816: PUSH
40817: LD_INT 3
40819: PUSH
40820: EMPTY
40821: LIST
40822: LIST
40823: PUSH
40824: LD_INT 1
40826: PUSH
40827: LD_INT 3
40829: PUSH
40830: EMPTY
40831: LIST
40832: LIST
40833: PUSH
40834: LD_INT 0
40836: PUSH
40837: LD_INT 3
40839: PUSH
40840: EMPTY
40841: LIST
40842: LIST
40843: PUSH
40844: LD_INT 1
40846: NEG
40847: PUSH
40848: LD_INT 2
40850: PUSH
40851: EMPTY
40852: LIST
40853: LIST
40854: PUSH
40855: LD_INT 3
40857: NEG
40858: PUSH
40859: LD_INT 2
40861: NEG
40862: PUSH
40863: EMPTY
40864: LIST
40865: LIST
40866: PUSH
40867: LD_INT 3
40869: NEG
40870: PUSH
40871: LD_INT 3
40873: NEG
40874: PUSH
40875: EMPTY
40876: LIST
40877: LIST
40878: PUSH
40879: EMPTY
40880: LIST
40881: LIST
40882: LIST
40883: LIST
40884: LIST
40885: LIST
40886: LIST
40887: LIST
40888: LIST
40889: LIST
40890: LIST
40891: LIST
40892: LIST
40893: LIST
40894: LIST
40895: LIST
40896: LIST
40897: LIST
40898: LIST
40899: LIST
40900: LIST
40901: LIST
40902: LIST
40903: LIST
40904: LIST
40905: LIST
40906: LIST
40907: LIST
40908: LIST
40909: ST_TO_ADDR
// fLab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
40910: LD_ADDR_VAR 0 43
40914: PUSH
40915: LD_INT 0
40917: PUSH
40918: LD_INT 0
40920: PUSH
40921: EMPTY
40922: LIST
40923: LIST
40924: PUSH
40925: LD_INT 0
40927: PUSH
40928: LD_INT 1
40930: NEG
40931: PUSH
40932: EMPTY
40933: LIST
40934: LIST
40935: PUSH
40936: LD_INT 1
40938: PUSH
40939: LD_INT 0
40941: PUSH
40942: EMPTY
40943: LIST
40944: LIST
40945: PUSH
40946: LD_INT 1
40948: PUSH
40949: LD_INT 1
40951: PUSH
40952: EMPTY
40953: LIST
40954: LIST
40955: PUSH
40956: LD_INT 0
40958: PUSH
40959: LD_INT 1
40961: PUSH
40962: EMPTY
40963: LIST
40964: LIST
40965: PUSH
40966: LD_INT 1
40968: NEG
40969: PUSH
40970: LD_INT 0
40972: PUSH
40973: EMPTY
40974: LIST
40975: LIST
40976: PUSH
40977: LD_INT 1
40979: NEG
40980: PUSH
40981: LD_INT 1
40983: NEG
40984: PUSH
40985: EMPTY
40986: LIST
40987: LIST
40988: PUSH
40989: LD_INT 1
40991: NEG
40992: PUSH
40993: LD_INT 2
40995: NEG
40996: PUSH
40997: EMPTY
40998: LIST
40999: LIST
41000: PUSH
41001: LD_INT 0
41003: PUSH
41004: LD_INT 2
41006: NEG
41007: PUSH
41008: EMPTY
41009: LIST
41010: LIST
41011: PUSH
41012: LD_INT 1
41014: PUSH
41015: LD_INT 1
41017: NEG
41018: PUSH
41019: EMPTY
41020: LIST
41021: LIST
41022: PUSH
41023: LD_INT 2
41025: PUSH
41026: LD_INT 0
41028: PUSH
41029: EMPTY
41030: LIST
41031: LIST
41032: PUSH
41033: LD_INT 2
41035: PUSH
41036: LD_INT 1
41038: PUSH
41039: EMPTY
41040: LIST
41041: LIST
41042: PUSH
41043: LD_INT 1
41045: PUSH
41046: LD_INT 2
41048: PUSH
41049: EMPTY
41050: LIST
41051: LIST
41052: PUSH
41053: LD_INT 0
41055: PUSH
41056: LD_INT 2
41058: PUSH
41059: EMPTY
41060: LIST
41061: LIST
41062: PUSH
41063: LD_INT 1
41065: NEG
41066: PUSH
41067: LD_INT 1
41069: PUSH
41070: EMPTY
41071: LIST
41072: LIST
41073: PUSH
41074: LD_INT 2
41076: NEG
41077: PUSH
41078: LD_INT 0
41080: PUSH
41081: EMPTY
41082: LIST
41083: LIST
41084: PUSH
41085: LD_INT 2
41087: NEG
41088: PUSH
41089: LD_INT 1
41091: NEG
41092: PUSH
41093: EMPTY
41094: LIST
41095: LIST
41096: PUSH
41097: LD_INT 1
41099: NEG
41100: PUSH
41101: LD_INT 3
41103: NEG
41104: PUSH
41105: EMPTY
41106: LIST
41107: LIST
41108: PUSH
41109: LD_INT 0
41111: PUSH
41112: LD_INT 3
41114: NEG
41115: PUSH
41116: EMPTY
41117: LIST
41118: LIST
41119: PUSH
41120: LD_INT 1
41122: PUSH
41123: LD_INT 2
41125: NEG
41126: PUSH
41127: EMPTY
41128: LIST
41129: LIST
41130: PUSH
41131: LD_INT 2
41133: PUSH
41134: LD_INT 1
41136: NEG
41137: PUSH
41138: EMPTY
41139: LIST
41140: LIST
41141: PUSH
41142: LD_INT 3
41144: PUSH
41145: LD_INT 0
41147: PUSH
41148: EMPTY
41149: LIST
41150: LIST
41151: PUSH
41152: LD_INT 3
41154: PUSH
41155: LD_INT 1
41157: PUSH
41158: EMPTY
41159: LIST
41160: LIST
41161: PUSH
41162: LD_INT 1
41164: PUSH
41165: LD_INT 3
41167: PUSH
41168: EMPTY
41169: LIST
41170: LIST
41171: PUSH
41172: LD_INT 0
41174: PUSH
41175: LD_INT 3
41177: PUSH
41178: EMPTY
41179: LIST
41180: LIST
41181: PUSH
41182: LD_INT 1
41184: NEG
41185: PUSH
41186: LD_INT 2
41188: PUSH
41189: EMPTY
41190: LIST
41191: LIST
41192: PUSH
41193: LD_INT 2
41195: NEG
41196: PUSH
41197: LD_INT 1
41199: PUSH
41200: EMPTY
41201: LIST
41202: LIST
41203: PUSH
41204: LD_INT 3
41206: NEG
41207: PUSH
41208: LD_INT 0
41210: PUSH
41211: EMPTY
41212: LIST
41213: LIST
41214: PUSH
41215: LD_INT 3
41217: NEG
41218: PUSH
41219: LD_INT 1
41221: NEG
41222: PUSH
41223: EMPTY
41224: LIST
41225: LIST
41226: PUSH
41227: EMPTY
41228: LIST
41229: LIST
41230: LIST
41231: LIST
41232: LIST
41233: LIST
41234: LIST
41235: LIST
41236: LIST
41237: LIST
41238: LIST
41239: LIST
41240: LIST
41241: LIST
41242: LIST
41243: LIST
41244: LIST
41245: LIST
41246: LIST
41247: LIST
41248: LIST
41249: LIST
41250: LIST
41251: LIST
41252: LIST
41253: LIST
41254: LIST
41255: LIST
41256: LIST
41257: ST_TO_ADDR
// fLab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
41258: LD_ADDR_VAR 0 44
41262: PUSH
41263: LD_INT 0
41265: PUSH
41266: LD_INT 0
41268: PUSH
41269: EMPTY
41270: LIST
41271: LIST
41272: PUSH
41273: LD_INT 0
41275: PUSH
41276: LD_INT 1
41278: NEG
41279: PUSH
41280: EMPTY
41281: LIST
41282: LIST
41283: PUSH
41284: LD_INT 1
41286: PUSH
41287: LD_INT 0
41289: PUSH
41290: EMPTY
41291: LIST
41292: LIST
41293: PUSH
41294: LD_INT 1
41296: PUSH
41297: LD_INT 1
41299: PUSH
41300: EMPTY
41301: LIST
41302: LIST
41303: PUSH
41304: LD_INT 0
41306: PUSH
41307: LD_INT 1
41309: PUSH
41310: EMPTY
41311: LIST
41312: LIST
41313: PUSH
41314: LD_INT 1
41316: NEG
41317: PUSH
41318: LD_INT 0
41320: PUSH
41321: EMPTY
41322: LIST
41323: LIST
41324: PUSH
41325: LD_INT 1
41327: NEG
41328: PUSH
41329: LD_INT 1
41331: NEG
41332: PUSH
41333: EMPTY
41334: LIST
41335: LIST
41336: PUSH
41337: LD_INT 1
41339: NEG
41340: PUSH
41341: LD_INT 2
41343: NEG
41344: PUSH
41345: EMPTY
41346: LIST
41347: LIST
41348: PUSH
41349: LD_INT 1
41351: PUSH
41352: LD_INT 1
41354: NEG
41355: PUSH
41356: EMPTY
41357: LIST
41358: LIST
41359: PUSH
41360: LD_INT 2
41362: PUSH
41363: LD_INT 0
41365: PUSH
41366: EMPTY
41367: LIST
41368: LIST
41369: PUSH
41370: LD_INT 2
41372: PUSH
41373: LD_INT 1
41375: PUSH
41376: EMPTY
41377: LIST
41378: LIST
41379: PUSH
41380: LD_INT 2
41382: PUSH
41383: LD_INT 2
41385: PUSH
41386: EMPTY
41387: LIST
41388: LIST
41389: PUSH
41390: LD_INT 1
41392: PUSH
41393: LD_INT 2
41395: PUSH
41396: EMPTY
41397: LIST
41398: LIST
41399: PUSH
41400: LD_INT 1
41402: NEG
41403: PUSH
41404: LD_INT 1
41406: PUSH
41407: EMPTY
41408: LIST
41409: LIST
41410: PUSH
41411: LD_INT 2
41413: NEG
41414: PUSH
41415: LD_INT 0
41417: PUSH
41418: EMPTY
41419: LIST
41420: LIST
41421: PUSH
41422: LD_INT 2
41424: NEG
41425: PUSH
41426: LD_INT 1
41428: NEG
41429: PUSH
41430: EMPTY
41431: LIST
41432: LIST
41433: PUSH
41434: LD_INT 2
41436: NEG
41437: PUSH
41438: LD_INT 2
41440: NEG
41441: PUSH
41442: EMPTY
41443: LIST
41444: LIST
41445: PUSH
41446: LD_INT 2
41448: NEG
41449: PUSH
41450: LD_INT 3
41452: NEG
41453: PUSH
41454: EMPTY
41455: LIST
41456: LIST
41457: PUSH
41458: LD_INT 2
41460: PUSH
41461: LD_INT 1
41463: NEG
41464: PUSH
41465: EMPTY
41466: LIST
41467: LIST
41468: PUSH
41469: LD_INT 3
41471: PUSH
41472: LD_INT 0
41474: PUSH
41475: EMPTY
41476: LIST
41477: LIST
41478: PUSH
41479: LD_INT 3
41481: PUSH
41482: LD_INT 1
41484: PUSH
41485: EMPTY
41486: LIST
41487: LIST
41488: PUSH
41489: LD_INT 3
41491: PUSH
41492: LD_INT 2
41494: PUSH
41495: EMPTY
41496: LIST
41497: LIST
41498: PUSH
41499: LD_INT 3
41501: PUSH
41502: LD_INT 3
41504: PUSH
41505: EMPTY
41506: LIST
41507: LIST
41508: PUSH
41509: LD_INT 2
41511: PUSH
41512: LD_INT 3
41514: PUSH
41515: EMPTY
41516: LIST
41517: LIST
41518: PUSH
41519: LD_INT 2
41521: NEG
41522: PUSH
41523: LD_INT 1
41525: PUSH
41526: EMPTY
41527: LIST
41528: LIST
41529: PUSH
41530: LD_INT 3
41532: NEG
41533: PUSH
41534: LD_INT 0
41536: PUSH
41537: EMPTY
41538: LIST
41539: LIST
41540: PUSH
41541: LD_INT 3
41543: NEG
41544: PUSH
41545: LD_INT 1
41547: NEG
41548: PUSH
41549: EMPTY
41550: LIST
41551: LIST
41552: PUSH
41553: LD_INT 3
41555: NEG
41556: PUSH
41557: LD_INT 2
41559: NEG
41560: PUSH
41561: EMPTY
41562: LIST
41563: LIST
41564: PUSH
41565: LD_INT 3
41567: NEG
41568: PUSH
41569: LD_INT 3
41571: NEG
41572: PUSH
41573: EMPTY
41574: LIST
41575: LIST
41576: PUSH
41577: EMPTY
41578: LIST
41579: LIST
41580: LIST
41581: LIST
41582: LIST
41583: LIST
41584: LIST
41585: LIST
41586: LIST
41587: LIST
41588: LIST
41589: LIST
41590: LIST
41591: LIST
41592: LIST
41593: LIST
41594: LIST
41595: LIST
41596: LIST
41597: LIST
41598: LIST
41599: LIST
41600: LIST
41601: LIST
41602: LIST
41603: LIST
41604: LIST
41605: LIST
41606: LIST
41607: ST_TO_ADDR
// fLab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
41608: LD_ADDR_VAR 0 45
41612: PUSH
41613: LD_INT 0
41615: PUSH
41616: LD_INT 0
41618: PUSH
41619: EMPTY
41620: LIST
41621: LIST
41622: PUSH
41623: LD_INT 0
41625: PUSH
41626: LD_INT 1
41628: NEG
41629: PUSH
41630: EMPTY
41631: LIST
41632: LIST
41633: PUSH
41634: LD_INT 1
41636: PUSH
41637: LD_INT 0
41639: PUSH
41640: EMPTY
41641: LIST
41642: LIST
41643: PUSH
41644: LD_INT 1
41646: PUSH
41647: LD_INT 1
41649: PUSH
41650: EMPTY
41651: LIST
41652: LIST
41653: PUSH
41654: LD_INT 0
41656: PUSH
41657: LD_INT 1
41659: PUSH
41660: EMPTY
41661: LIST
41662: LIST
41663: PUSH
41664: LD_INT 1
41666: NEG
41667: PUSH
41668: LD_INT 0
41670: PUSH
41671: EMPTY
41672: LIST
41673: LIST
41674: PUSH
41675: LD_INT 1
41677: NEG
41678: PUSH
41679: LD_INT 1
41681: NEG
41682: PUSH
41683: EMPTY
41684: LIST
41685: LIST
41686: PUSH
41687: LD_INT 1
41689: NEG
41690: PUSH
41691: LD_INT 2
41693: NEG
41694: PUSH
41695: EMPTY
41696: LIST
41697: LIST
41698: PUSH
41699: LD_INT 0
41701: PUSH
41702: LD_INT 2
41704: NEG
41705: PUSH
41706: EMPTY
41707: LIST
41708: LIST
41709: PUSH
41710: LD_INT 1
41712: PUSH
41713: LD_INT 1
41715: NEG
41716: PUSH
41717: EMPTY
41718: LIST
41719: LIST
41720: PUSH
41721: LD_INT 2
41723: PUSH
41724: LD_INT 1
41726: PUSH
41727: EMPTY
41728: LIST
41729: LIST
41730: PUSH
41731: LD_INT 2
41733: PUSH
41734: LD_INT 2
41736: PUSH
41737: EMPTY
41738: LIST
41739: LIST
41740: PUSH
41741: LD_INT 1
41743: PUSH
41744: LD_INT 2
41746: PUSH
41747: EMPTY
41748: LIST
41749: LIST
41750: PUSH
41751: LD_INT 0
41753: PUSH
41754: LD_INT 2
41756: PUSH
41757: EMPTY
41758: LIST
41759: LIST
41760: PUSH
41761: LD_INT 1
41763: NEG
41764: PUSH
41765: LD_INT 1
41767: PUSH
41768: EMPTY
41769: LIST
41770: LIST
41771: PUSH
41772: LD_INT 2
41774: NEG
41775: PUSH
41776: LD_INT 1
41778: NEG
41779: PUSH
41780: EMPTY
41781: LIST
41782: LIST
41783: PUSH
41784: LD_INT 2
41786: NEG
41787: PUSH
41788: LD_INT 2
41790: NEG
41791: PUSH
41792: EMPTY
41793: LIST
41794: LIST
41795: PUSH
41796: LD_INT 2
41798: NEG
41799: PUSH
41800: LD_INT 3
41802: NEG
41803: PUSH
41804: EMPTY
41805: LIST
41806: LIST
41807: PUSH
41808: LD_INT 1
41810: NEG
41811: PUSH
41812: LD_INT 3
41814: NEG
41815: PUSH
41816: EMPTY
41817: LIST
41818: LIST
41819: PUSH
41820: LD_INT 0
41822: PUSH
41823: LD_INT 3
41825: NEG
41826: PUSH
41827: EMPTY
41828: LIST
41829: LIST
41830: PUSH
41831: LD_INT 1
41833: PUSH
41834: LD_INT 2
41836: NEG
41837: PUSH
41838: EMPTY
41839: LIST
41840: LIST
41841: PUSH
41842: LD_INT 3
41844: PUSH
41845: LD_INT 2
41847: PUSH
41848: EMPTY
41849: LIST
41850: LIST
41851: PUSH
41852: LD_INT 3
41854: PUSH
41855: LD_INT 3
41857: PUSH
41858: EMPTY
41859: LIST
41860: LIST
41861: PUSH
41862: LD_INT 2
41864: PUSH
41865: LD_INT 3
41867: PUSH
41868: EMPTY
41869: LIST
41870: LIST
41871: PUSH
41872: LD_INT 1
41874: PUSH
41875: LD_INT 3
41877: PUSH
41878: EMPTY
41879: LIST
41880: LIST
41881: PUSH
41882: LD_INT 0
41884: PUSH
41885: LD_INT 3
41887: PUSH
41888: EMPTY
41889: LIST
41890: LIST
41891: PUSH
41892: LD_INT 1
41894: NEG
41895: PUSH
41896: LD_INT 2
41898: PUSH
41899: EMPTY
41900: LIST
41901: LIST
41902: PUSH
41903: LD_INT 3
41905: NEG
41906: PUSH
41907: LD_INT 2
41909: NEG
41910: PUSH
41911: EMPTY
41912: LIST
41913: LIST
41914: PUSH
41915: LD_INT 3
41917: NEG
41918: PUSH
41919: LD_INT 3
41921: NEG
41922: PUSH
41923: EMPTY
41924: LIST
41925: LIST
41926: PUSH
41927: EMPTY
41928: LIST
41929: LIST
41930: LIST
41931: LIST
41932: LIST
41933: LIST
41934: LIST
41935: LIST
41936: LIST
41937: LIST
41938: LIST
41939: LIST
41940: LIST
41941: LIST
41942: LIST
41943: LIST
41944: LIST
41945: LIST
41946: LIST
41947: LIST
41948: LIST
41949: LIST
41950: LIST
41951: LIST
41952: LIST
41953: LIST
41954: LIST
41955: LIST
41956: LIST
41957: ST_TO_ADDR
// fLab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
41958: LD_ADDR_VAR 0 46
41962: PUSH
41963: LD_INT 0
41965: PUSH
41966: LD_INT 0
41968: PUSH
41969: EMPTY
41970: LIST
41971: LIST
41972: PUSH
41973: LD_INT 0
41975: PUSH
41976: LD_INT 1
41978: NEG
41979: PUSH
41980: EMPTY
41981: LIST
41982: LIST
41983: PUSH
41984: LD_INT 1
41986: PUSH
41987: LD_INT 0
41989: PUSH
41990: EMPTY
41991: LIST
41992: LIST
41993: PUSH
41994: LD_INT 1
41996: PUSH
41997: LD_INT 1
41999: PUSH
42000: EMPTY
42001: LIST
42002: LIST
42003: PUSH
42004: LD_INT 0
42006: PUSH
42007: LD_INT 1
42009: PUSH
42010: EMPTY
42011: LIST
42012: LIST
42013: PUSH
42014: LD_INT 1
42016: NEG
42017: PUSH
42018: LD_INT 0
42020: PUSH
42021: EMPTY
42022: LIST
42023: LIST
42024: PUSH
42025: LD_INT 1
42027: NEG
42028: PUSH
42029: LD_INT 1
42031: NEG
42032: PUSH
42033: EMPTY
42034: LIST
42035: LIST
42036: PUSH
42037: LD_INT 1
42039: NEG
42040: PUSH
42041: LD_INT 2
42043: NEG
42044: PUSH
42045: EMPTY
42046: LIST
42047: LIST
42048: PUSH
42049: LD_INT 0
42051: PUSH
42052: LD_INT 2
42054: NEG
42055: PUSH
42056: EMPTY
42057: LIST
42058: LIST
42059: PUSH
42060: LD_INT 1
42062: PUSH
42063: LD_INT 1
42065: NEG
42066: PUSH
42067: EMPTY
42068: LIST
42069: LIST
42070: PUSH
42071: LD_INT 2
42073: PUSH
42074: LD_INT 0
42076: PUSH
42077: EMPTY
42078: LIST
42079: LIST
42080: PUSH
42081: LD_INT 2
42083: PUSH
42084: LD_INT 1
42086: PUSH
42087: EMPTY
42088: LIST
42089: LIST
42090: PUSH
42091: LD_INT 1
42093: PUSH
42094: LD_INT 2
42096: PUSH
42097: EMPTY
42098: LIST
42099: LIST
42100: PUSH
42101: LD_INT 0
42103: PUSH
42104: LD_INT 2
42106: PUSH
42107: EMPTY
42108: LIST
42109: LIST
42110: PUSH
42111: LD_INT 1
42113: NEG
42114: PUSH
42115: LD_INT 1
42117: PUSH
42118: EMPTY
42119: LIST
42120: LIST
42121: PUSH
42122: LD_INT 2
42124: NEG
42125: PUSH
42126: LD_INT 0
42128: PUSH
42129: EMPTY
42130: LIST
42131: LIST
42132: PUSH
42133: LD_INT 2
42135: NEG
42136: PUSH
42137: LD_INT 1
42139: NEG
42140: PUSH
42141: EMPTY
42142: LIST
42143: LIST
42144: PUSH
42145: LD_INT 1
42147: NEG
42148: PUSH
42149: LD_INT 3
42151: NEG
42152: PUSH
42153: EMPTY
42154: LIST
42155: LIST
42156: PUSH
42157: LD_INT 0
42159: PUSH
42160: LD_INT 3
42162: NEG
42163: PUSH
42164: EMPTY
42165: LIST
42166: LIST
42167: PUSH
42168: LD_INT 1
42170: PUSH
42171: LD_INT 2
42173: NEG
42174: PUSH
42175: EMPTY
42176: LIST
42177: LIST
42178: PUSH
42179: LD_INT 2
42181: PUSH
42182: LD_INT 1
42184: NEG
42185: PUSH
42186: EMPTY
42187: LIST
42188: LIST
42189: PUSH
42190: LD_INT 3
42192: PUSH
42193: LD_INT 0
42195: PUSH
42196: EMPTY
42197: LIST
42198: LIST
42199: PUSH
42200: LD_INT 3
42202: PUSH
42203: LD_INT 1
42205: PUSH
42206: EMPTY
42207: LIST
42208: LIST
42209: PUSH
42210: LD_INT 1
42212: PUSH
42213: LD_INT 3
42215: PUSH
42216: EMPTY
42217: LIST
42218: LIST
42219: PUSH
42220: LD_INT 0
42222: PUSH
42223: LD_INT 3
42225: PUSH
42226: EMPTY
42227: LIST
42228: LIST
42229: PUSH
42230: LD_INT 1
42232: NEG
42233: PUSH
42234: LD_INT 2
42236: PUSH
42237: EMPTY
42238: LIST
42239: LIST
42240: PUSH
42241: LD_INT 2
42243: NEG
42244: PUSH
42245: LD_INT 1
42247: PUSH
42248: EMPTY
42249: LIST
42250: LIST
42251: PUSH
42252: LD_INT 3
42254: NEG
42255: PUSH
42256: LD_INT 0
42258: PUSH
42259: EMPTY
42260: LIST
42261: LIST
42262: PUSH
42263: LD_INT 3
42265: NEG
42266: PUSH
42267: LD_INT 1
42269: NEG
42270: PUSH
42271: EMPTY
42272: LIST
42273: LIST
42274: PUSH
42275: EMPTY
42276: LIST
42277: LIST
42278: LIST
42279: LIST
42280: LIST
42281: LIST
42282: LIST
42283: LIST
42284: LIST
42285: LIST
42286: LIST
42287: LIST
42288: LIST
42289: LIST
42290: LIST
42291: LIST
42292: LIST
42293: LIST
42294: LIST
42295: LIST
42296: LIST
42297: LIST
42298: LIST
42299: LIST
42300: LIST
42301: LIST
42302: LIST
42303: LIST
42304: LIST
42305: ST_TO_ADDR
// fControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
42306: LD_ADDR_VAR 0 47
42310: PUSH
42311: LD_INT 0
42313: PUSH
42314: LD_INT 0
42316: PUSH
42317: EMPTY
42318: LIST
42319: LIST
42320: PUSH
42321: LD_INT 0
42323: PUSH
42324: LD_INT 1
42326: NEG
42327: PUSH
42328: EMPTY
42329: LIST
42330: LIST
42331: PUSH
42332: LD_INT 1
42334: PUSH
42335: LD_INT 0
42337: PUSH
42338: EMPTY
42339: LIST
42340: LIST
42341: PUSH
42342: LD_INT 1
42344: PUSH
42345: LD_INT 1
42347: PUSH
42348: EMPTY
42349: LIST
42350: LIST
42351: PUSH
42352: LD_INT 0
42354: PUSH
42355: LD_INT 1
42357: PUSH
42358: EMPTY
42359: LIST
42360: LIST
42361: PUSH
42362: LD_INT 1
42364: NEG
42365: PUSH
42366: LD_INT 0
42368: PUSH
42369: EMPTY
42370: LIST
42371: LIST
42372: PUSH
42373: LD_INT 1
42375: NEG
42376: PUSH
42377: LD_INT 1
42379: NEG
42380: PUSH
42381: EMPTY
42382: LIST
42383: LIST
42384: PUSH
42385: LD_INT 1
42387: NEG
42388: PUSH
42389: LD_INT 2
42391: NEG
42392: PUSH
42393: EMPTY
42394: LIST
42395: LIST
42396: PUSH
42397: LD_INT 0
42399: PUSH
42400: LD_INT 2
42402: NEG
42403: PUSH
42404: EMPTY
42405: LIST
42406: LIST
42407: PUSH
42408: LD_INT 1
42410: PUSH
42411: LD_INT 1
42413: NEG
42414: PUSH
42415: EMPTY
42416: LIST
42417: LIST
42418: PUSH
42419: LD_INT 2
42421: NEG
42422: PUSH
42423: LD_INT 1
42425: NEG
42426: PUSH
42427: EMPTY
42428: LIST
42429: LIST
42430: PUSH
42431: LD_INT 2
42433: NEG
42434: PUSH
42435: LD_INT 2
42437: NEG
42438: PUSH
42439: EMPTY
42440: LIST
42441: LIST
42442: PUSH
42443: EMPTY
42444: LIST
42445: LIST
42446: LIST
42447: LIST
42448: LIST
42449: LIST
42450: LIST
42451: LIST
42452: LIST
42453: LIST
42454: LIST
42455: LIST
42456: ST_TO_ADDR
// fControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
42457: LD_ADDR_VAR 0 48
42461: PUSH
42462: LD_INT 0
42464: PUSH
42465: LD_INT 0
42467: PUSH
42468: EMPTY
42469: LIST
42470: LIST
42471: PUSH
42472: LD_INT 0
42474: PUSH
42475: LD_INT 1
42477: NEG
42478: PUSH
42479: EMPTY
42480: LIST
42481: LIST
42482: PUSH
42483: LD_INT 1
42485: PUSH
42486: LD_INT 0
42488: PUSH
42489: EMPTY
42490: LIST
42491: LIST
42492: PUSH
42493: LD_INT 1
42495: PUSH
42496: LD_INT 1
42498: PUSH
42499: EMPTY
42500: LIST
42501: LIST
42502: PUSH
42503: LD_INT 0
42505: PUSH
42506: LD_INT 1
42508: PUSH
42509: EMPTY
42510: LIST
42511: LIST
42512: PUSH
42513: LD_INT 1
42515: NEG
42516: PUSH
42517: LD_INT 0
42519: PUSH
42520: EMPTY
42521: LIST
42522: LIST
42523: PUSH
42524: LD_INT 1
42526: NEG
42527: PUSH
42528: LD_INT 1
42530: NEG
42531: PUSH
42532: EMPTY
42533: LIST
42534: LIST
42535: PUSH
42536: LD_INT 1
42538: NEG
42539: PUSH
42540: LD_INT 2
42542: NEG
42543: PUSH
42544: EMPTY
42545: LIST
42546: LIST
42547: PUSH
42548: LD_INT 0
42550: PUSH
42551: LD_INT 2
42553: NEG
42554: PUSH
42555: EMPTY
42556: LIST
42557: LIST
42558: PUSH
42559: LD_INT 1
42561: PUSH
42562: LD_INT 1
42564: NEG
42565: PUSH
42566: EMPTY
42567: LIST
42568: LIST
42569: PUSH
42570: LD_INT 2
42572: PUSH
42573: LD_INT 0
42575: PUSH
42576: EMPTY
42577: LIST
42578: LIST
42579: PUSH
42580: LD_INT 2
42582: PUSH
42583: LD_INT 1
42585: PUSH
42586: EMPTY
42587: LIST
42588: LIST
42589: PUSH
42590: EMPTY
42591: LIST
42592: LIST
42593: LIST
42594: LIST
42595: LIST
42596: LIST
42597: LIST
42598: LIST
42599: LIST
42600: LIST
42601: LIST
42602: LIST
42603: ST_TO_ADDR
// fControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
42604: LD_ADDR_VAR 0 49
42608: PUSH
42609: LD_INT 0
42611: PUSH
42612: LD_INT 0
42614: PUSH
42615: EMPTY
42616: LIST
42617: LIST
42618: PUSH
42619: LD_INT 0
42621: PUSH
42622: LD_INT 1
42624: NEG
42625: PUSH
42626: EMPTY
42627: LIST
42628: LIST
42629: PUSH
42630: LD_INT 1
42632: PUSH
42633: LD_INT 0
42635: PUSH
42636: EMPTY
42637: LIST
42638: LIST
42639: PUSH
42640: LD_INT 1
42642: PUSH
42643: LD_INT 1
42645: PUSH
42646: EMPTY
42647: LIST
42648: LIST
42649: PUSH
42650: LD_INT 0
42652: PUSH
42653: LD_INT 1
42655: PUSH
42656: EMPTY
42657: LIST
42658: LIST
42659: PUSH
42660: LD_INT 1
42662: NEG
42663: PUSH
42664: LD_INT 0
42666: PUSH
42667: EMPTY
42668: LIST
42669: LIST
42670: PUSH
42671: LD_INT 1
42673: NEG
42674: PUSH
42675: LD_INT 1
42677: NEG
42678: PUSH
42679: EMPTY
42680: LIST
42681: LIST
42682: PUSH
42683: LD_INT 1
42685: PUSH
42686: LD_INT 1
42688: NEG
42689: PUSH
42690: EMPTY
42691: LIST
42692: LIST
42693: PUSH
42694: LD_INT 2
42696: PUSH
42697: LD_INT 0
42699: PUSH
42700: EMPTY
42701: LIST
42702: LIST
42703: PUSH
42704: LD_INT 2
42706: PUSH
42707: LD_INT 1
42709: PUSH
42710: EMPTY
42711: LIST
42712: LIST
42713: PUSH
42714: LD_INT 2
42716: PUSH
42717: LD_INT 2
42719: PUSH
42720: EMPTY
42721: LIST
42722: LIST
42723: PUSH
42724: LD_INT 1
42726: PUSH
42727: LD_INT 2
42729: PUSH
42730: EMPTY
42731: LIST
42732: LIST
42733: PUSH
42734: EMPTY
42735: LIST
42736: LIST
42737: LIST
42738: LIST
42739: LIST
42740: LIST
42741: LIST
42742: LIST
42743: LIST
42744: LIST
42745: LIST
42746: LIST
42747: ST_TO_ADDR
// fControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
42748: LD_ADDR_VAR 0 50
42752: PUSH
42753: LD_INT 0
42755: PUSH
42756: LD_INT 0
42758: PUSH
42759: EMPTY
42760: LIST
42761: LIST
42762: PUSH
42763: LD_INT 0
42765: PUSH
42766: LD_INT 1
42768: NEG
42769: PUSH
42770: EMPTY
42771: LIST
42772: LIST
42773: PUSH
42774: LD_INT 1
42776: PUSH
42777: LD_INT 0
42779: PUSH
42780: EMPTY
42781: LIST
42782: LIST
42783: PUSH
42784: LD_INT 1
42786: PUSH
42787: LD_INT 1
42789: PUSH
42790: EMPTY
42791: LIST
42792: LIST
42793: PUSH
42794: LD_INT 0
42796: PUSH
42797: LD_INT 1
42799: PUSH
42800: EMPTY
42801: LIST
42802: LIST
42803: PUSH
42804: LD_INT 1
42806: NEG
42807: PUSH
42808: LD_INT 0
42810: PUSH
42811: EMPTY
42812: LIST
42813: LIST
42814: PUSH
42815: LD_INT 1
42817: NEG
42818: PUSH
42819: LD_INT 1
42821: NEG
42822: PUSH
42823: EMPTY
42824: LIST
42825: LIST
42826: PUSH
42827: LD_INT 2
42829: PUSH
42830: LD_INT 1
42832: PUSH
42833: EMPTY
42834: LIST
42835: LIST
42836: PUSH
42837: LD_INT 2
42839: PUSH
42840: LD_INT 2
42842: PUSH
42843: EMPTY
42844: LIST
42845: LIST
42846: PUSH
42847: LD_INT 1
42849: PUSH
42850: LD_INT 2
42852: PUSH
42853: EMPTY
42854: LIST
42855: LIST
42856: PUSH
42857: LD_INT 0
42859: PUSH
42860: LD_INT 2
42862: PUSH
42863: EMPTY
42864: LIST
42865: LIST
42866: PUSH
42867: LD_INT 1
42869: NEG
42870: PUSH
42871: LD_INT 1
42873: PUSH
42874: EMPTY
42875: LIST
42876: LIST
42877: PUSH
42878: EMPTY
42879: LIST
42880: LIST
42881: LIST
42882: LIST
42883: LIST
42884: LIST
42885: LIST
42886: LIST
42887: LIST
42888: LIST
42889: LIST
42890: LIST
42891: ST_TO_ADDR
// fControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
42892: LD_ADDR_VAR 0 51
42896: PUSH
42897: LD_INT 0
42899: PUSH
42900: LD_INT 0
42902: PUSH
42903: EMPTY
42904: LIST
42905: LIST
42906: PUSH
42907: LD_INT 0
42909: PUSH
42910: LD_INT 1
42912: NEG
42913: PUSH
42914: EMPTY
42915: LIST
42916: LIST
42917: PUSH
42918: LD_INT 1
42920: PUSH
42921: LD_INT 0
42923: PUSH
42924: EMPTY
42925: LIST
42926: LIST
42927: PUSH
42928: LD_INT 1
42930: PUSH
42931: LD_INT 1
42933: PUSH
42934: EMPTY
42935: LIST
42936: LIST
42937: PUSH
42938: LD_INT 0
42940: PUSH
42941: LD_INT 1
42943: PUSH
42944: EMPTY
42945: LIST
42946: LIST
42947: PUSH
42948: LD_INT 1
42950: NEG
42951: PUSH
42952: LD_INT 0
42954: PUSH
42955: EMPTY
42956: LIST
42957: LIST
42958: PUSH
42959: LD_INT 1
42961: NEG
42962: PUSH
42963: LD_INT 1
42965: NEG
42966: PUSH
42967: EMPTY
42968: LIST
42969: LIST
42970: PUSH
42971: LD_INT 1
42973: PUSH
42974: LD_INT 2
42976: PUSH
42977: EMPTY
42978: LIST
42979: LIST
42980: PUSH
42981: LD_INT 0
42983: PUSH
42984: LD_INT 2
42986: PUSH
42987: EMPTY
42988: LIST
42989: LIST
42990: PUSH
42991: LD_INT 1
42993: NEG
42994: PUSH
42995: LD_INT 1
42997: PUSH
42998: EMPTY
42999: LIST
43000: LIST
43001: PUSH
43002: LD_INT 2
43004: NEG
43005: PUSH
43006: LD_INT 0
43008: PUSH
43009: EMPTY
43010: LIST
43011: LIST
43012: PUSH
43013: LD_INT 2
43015: NEG
43016: PUSH
43017: LD_INT 1
43019: NEG
43020: PUSH
43021: EMPTY
43022: LIST
43023: LIST
43024: PUSH
43025: EMPTY
43026: LIST
43027: LIST
43028: LIST
43029: LIST
43030: LIST
43031: LIST
43032: LIST
43033: LIST
43034: LIST
43035: LIST
43036: LIST
43037: LIST
43038: ST_TO_ADDR
// fControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
43039: LD_ADDR_VAR 0 52
43043: PUSH
43044: LD_INT 0
43046: PUSH
43047: LD_INT 0
43049: PUSH
43050: EMPTY
43051: LIST
43052: LIST
43053: PUSH
43054: LD_INT 0
43056: PUSH
43057: LD_INT 1
43059: NEG
43060: PUSH
43061: EMPTY
43062: LIST
43063: LIST
43064: PUSH
43065: LD_INT 1
43067: PUSH
43068: LD_INT 0
43070: PUSH
43071: EMPTY
43072: LIST
43073: LIST
43074: PUSH
43075: LD_INT 1
43077: PUSH
43078: LD_INT 1
43080: PUSH
43081: EMPTY
43082: LIST
43083: LIST
43084: PUSH
43085: LD_INT 0
43087: PUSH
43088: LD_INT 1
43090: PUSH
43091: EMPTY
43092: LIST
43093: LIST
43094: PUSH
43095: LD_INT 1
43097: NEG
43098: PUSH
43099: LD_INT 0
43101: PUSH
43102: EMPTY
43103: LIST
43104: LIST
43105: PUSH
43106: LD_INT 1
43108: NEG
43109: PUSH
43110: LD_INT 1
43112: NEG
43113: PUSH
43114: EMPTY
43115: LIST
43116: LIST
43117: PUSH
43118: LD_INT 1
43120: NEG
43121: PUSH
43122: LD_INT 2
43124: NEG
43125: PUSH
43126: EMPTY
43127: LIST
43128: LIST
43129: PUSH
43130: LD_INT 1
43132: NEG
43133: PUSH
43134: LD_INT 1
43136: PUSH
43137: EMPTY
43138: LIST
43139: LIST
43140: PUSH
43141: LD_INT 2
43143: NEG
43144: PUSH
43145: LD_INT 0
43147: PUSH
43148: EMPTY
43149: LIST
43150: LIST
43151: PUSH
43152: LD_INT 2
43154: NEG
43155: PUSH
43156: LD_INT 1
43158: NEG
43159: PUSH
43160: EMPTY
43161: LIST
43162: LIST
43163: PUSH
43164: LD_INT 2
43166: NEG
43167: PUSH
43168: LD_INT 2
43170: NEG
43171: PUSH
43172: EMPTY
43173: LIST
43174: LIST
43175: PUSH
43176: EMPTY
43177: LIST
43178: LIST
43179: LIST
43180: LIST
43181: LIST
43182: LIST
43183: LIST
43184: LIST
43185: LIST
43186: LIST
43187: LIST
43188: LIST
43189: ST_TO_ADDR
// fBarracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
43190: LD_ADDR_VAR 0 53
43194: PUSH
43195: LD_INT 0
43197: PUSH
43198: LD_INT 0
43200: PUSH
43201: EMPTY
43202: LIST
43203: LIST
43204: PUSH
43205: LD_INT 0
43207: PUSH
43208: LD_INT 1
43210: NEG
43211: PUSH
43212: EMPTY
43213: LIST
43214: LIST
43215: PUSH
43216: LD_INT 1
43218: PUSH
43219: LD_INT 0
43221: PUSH
43222: EMPTY
43223: LIST
43224: LIST
43225: PUSH
43226: LD_INT 1
43228: PUSH
43229: LD_INT 1
43231: PUSH
43232: EMPTY
43233: LIST
43234: LIST
43235: PUSH
43236: LD_INT 0
43238: PUSH
43239: LD_INT 1
43241: PUSH
43242: EMPTY
43243: LIST
43244: LIST
43245: PUSH
43246: LD_INT 1
43248: NEG
43249: PUSH
43250: LD_INT 0
43252: PUSH
43253: EMPTY
43254: LIST
43255: LIST
43256: PUSH
43257: LD_INT 1
43259: NEG
43260: PUSH
43261: LD_INT 1
43263: NEG
43264: PUSH
43265: EMPTY
43266: LIST
43267: LIST
43268: PUSH
43269: LD_INT 1
43271: NEG
43272: PUSH
43273: LD_INT 2
43275: NEG
43276: PUSH
43277: EMPTY
43278: LIST
43279: LIST
43280: PUSH
43281: LD_INT 0
43283: PUSH
43284: LD_INT 2
43286: NEG
43287: PUSH
43288: EMPTY
43289: LIST
43290: LIST
43291: PUSH
43292: LD_INT 1
43294: PUSH
43295: LD_INT 1
43297: NEG
43298: PUSH
43299: EMPTY
43300: LIST
43301: LIST
43302: PUSH
43303: LD_INT 2
43305: PUSH
43306: LD_INT 0
43308: PUSH
43309: EMPTY
43310: LIST
43311: LIST
43312: PUSH
43313: LD_INT 2
43315: PUSH
43316: LD_INT 1
43318: PUSH
43319: EMPTY
43320: LIST
43321: LIST
43322: PUSH
43323: LD_INT 2
43325: PUSH
43326: LD_INT 2
43328: PUSH
43329: EMPTY
43330: LIST
43331: LIST
43332: PUSH
43333: LD_INT 1
43335: PUSH
43336: LD_INT 2
43338: PUSH
43339: EMPTY
43340: LIST
43341: LIST
43342: PUSH
43343: LD_INT 0
43345: PUSH
43346: LD_INT 2
43348: PUSH
43349: EMPTY
43350: LIST
43351: LIST
43352: PUSH
43353: LD_INT 1
43355: NEG
43356: PUSH
43357: LD_INT 1
43359: PUSH
43360: EMPTY
43361: LIST
43362: LIST
43363: PUSH
43364: LD_INT 2
43366: NEG
43367: PUSH
43368: LD_INT 0
43370: PUSH
43371: EMPTY
43372: LIST
43373: LIST
43374: PUSH
43375: LD_INT 2
43377: NEG
43378: PUSH
43379: LD_INT 1
43381: NEG
43382: PUSH
43383: EMPTY
43384: LIST
43385: LIST
43386: PUSH
43387: LD_INT 2
43389: NEG
43390: PUSH
43391: LD_INT 2
43393: NEG
43394: PUSH
43395: EMPTY
43396: LIST
43397: LIST
43398: PUSH
43399: EMPTY
43400: LIST
43401: LIST
43402: LIST
43403: LIST
43404: LIST
43405: LIST
43406: LIST
43407: LIST
43408: LIST
43409: LIST
43410: LIST
43411: LIST
43412: LIST
43413: LIST
43414: LIST
43415: LIST
43416: LIST
43417: LIST
43418: LIST
43419: ST_TO_ADDR
// fBarracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
43420: LD_ADDR_VAR 0 54
43424: PUSH
43425: LD_INT 0
43427: PUSH
43428: LD_INT 0
43430: PUSH
43431: EMPTY
43432: LIST
43433: LIST
43434: PUSH
43435: LD_INT 0
43437: PUSH
43438: LD_INT 1
43440: NEG
43441: PUSH
43442: EMPTY
43443: LIST
43444: LIST
43445: PUSH
43446: LD_INT 1
43448: PUSH
43449: LD_INT 0
43451: PUSH
43452: EMPTY
43453: LIST
43454: LIST
43455: PUSH
43456: LD_INT 1
43458: PUSH
43459: LD_INT 1
43461: PUSH
43462: EMPTY
43463: LIST
43464: LIST
43465: PUSH
43466: LD_INT 0
43468: PUSH
43469: LD_INT 1
43471: PUSH
43472: EMPTY
43473: LIST
43474: LIST
43475: PUSH
43476: LD_INT 1
43478: NEG
43479: PUSH
43480: LD_INT 0
43482: PUSH
43483: EMPTY
43484: LIST
43485: LIST
43486: PUSH
43487: LD_INT 1
43489: NEG
43490: PUSH
43491: LD_INT 1
43493: NEG
43494: PUSH
43495: EMPTY
43496: LIST
43497: LIST
43498: PUSH
43499: LD_INT 1
43501: NEG
43502: PUSH
43503: LD_INT 2
43505: NEG
43506: PUSH
43507: EMPTY
43508: LIST
43509: LIST
43510: PUSH
43511: LD_INT 0
43513: PUSH
43514: LD_INT 2
43516: NEG
43517: PUSH
43518: EMPTY
43519: LIST
43520: LIST
43521: PUSH
43522: LD_INT 1
43524: PUSH
43525: LD_INT 1
43527: NEG
43528: PUSH
43529: EMPTY
43530: LIST
43531: LIST
43532: PUSH
43533: LD_INT 2
43535: PUSH
43536: LD_INT 0
43538: PUSH
43539: EMPTY
43540: LIST
43541: LIST
43542: PUSH
43543: LD_INT 2
43545: PUSH
43546: LD_INT 1
43548: PUSH
43549: EMPTY
43550: LIST
43551: LIST
43552: PUSH
43553: LD_INT 2
43555: PUSH
43556: LD_INT 2
43558: PUSH
43559: EMPTY
43560: LIST
43561: LIST
43562: PUSH
43563: LD_INT 1
43565: PUSH
43566: LD_INT 2
43568: PUSH
43569: EMPTY
43570: LIST
43571: LIST
43572: PUSH
43573: LD_INT 0
43575: PUSH
43576: LD_INT 2
43578: PUSH
43579: EMPTY
43580: LIST
43581: LIST
43582: PUSH
43583: LD_INT 1
43585: NEG
43586: PUSH
43587: LD_INT 1
43589: PUSH
43590: EMPTY
43591: LIST
43592: LIST
43593: PUSH
43594: LD_INT 2
43596: NEG
43597: PUSH
43598: LD_INT 0
43600: PUSH
43601: EMPTY
43602: LIST
43603: LIST
43604: PUSH
43605: LD_INT 2
43607: NEG
43608: PUSH
43609: LD_INT 1
43611: NEG
43612: PUSH
43613: EMPTY
43614: LIST
43615: LIST
43616: PUSH
43617: LD_INT 2
43619: NEG
43620: PUSH
43621: LD_INT 2
43623: NEG
43624: PUSH
43625: EMPTY
43626: LIST
43627: LIST
43628: PUSH
43629: EMPTY
43630: LIST
43631: LIST
43632: LIST
43633: LIST
43634: LIST
43635: LIST
43636: LIST
43637: LIST
43638: LIST
43639: LIST
43640: LIST
43641: LIST
43642: LIST
43643: LIST
43644: LIST
43645: LIST
43646: LIST
43647: LIST
43648: LIST
43649: ST_TO_ADDR
// fBarracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
43650: LD_ADDR_VAR 0 55
43654: PUSH
43655: LD_INT 0
43657: PUSH
43658: LD_INT 0
43660: PUSH
43661: EMPTY
43662: LIST
43663: LIST
43664: PUSH
43665: LD_INT 0
43667: PUSH
43668: LD_INT 1
43670: NEG
43671: PUSH
43672: EMPTY
43673: LIST
43674: LIST
43675: PUSH
43676: LD_INT 1
43678: PUSH
43679: LD_INT 0
43681: PUSH
43682: EMPTY
43683: LIST
43684: LIST
43685: PUSH
43686: LD_INT 1
43688: PUSH
43689: LD_INT 1
43691: PUSH
43692: EMPTY
43693: LIST
43694: LIST
43695: PUSH
43696: LD_INT 0
43698: PUSH
43699: LD_INT 1
43701: PUSH
43702: EMPTY
43703: LIST
43704: LIST
43705: PUSH
43706: LD_INT 1
43708: NEG
43709: PUSH
43710: LD_INT 0
43712: PUSH
43713: EMPTY
43714: LIST
43715: LIST
43716: PUSH
43717: LD_INT 1
43719: NEG
43720: PUSH
43721: LD_INT 1
43723: NEG
43724: PUSH
43725: EMPTY
43726: LIST
43727: LIST
43728: PUSH
43729: LD_INT 1
43731: NEG
43732: PUSH
43733: LD_INT 2
43735: NEG
43736: PUSH
43737: EMPTY
43738: LIST
43739: LIST
43740: PUSH
43741: LD_INT 0
43743: PUSH
43744: LD_INT 2
43746: NEG
43747: PUSH
43748: EMPTY
43749: LIST
43750: LIST
43751: PUSH
43752: LD_INT 1
43754: PUSH
43755: LD_INT 1
43757: NEG
43758: PUSH
43759: EMPTY
43760: LIST
43761: LIST
43762: PUSH
43763: LD_INT 2
43765: PUSH
43766: LD_INT 0
43768: PUSH
43769: EMPTY
43770: LIST
43771: LIST
43772: PUSH
43773: LD_INT 2
43775: PUSH
43776: LD_INT 1
43778: PUSH
43779: EMPTY
43780: LIST
43781: LIST
43782: PUSH
43783: LD_INT 2
43785: PUSH
43786: LD_INT 2
43788: PUSH
43789: EMPTY
43790: LIST
43791: LIST
43792: PUSH
43793: LD_INT 1
43795: PUSH
43796: LD_INT 2
43798: PUSH
43799: EMPTY
43800: LIST
43801: LIST
43802: PUSH
43803: LD_INT 0
43805: PUSH
43806: LD_INT 2
43808: PUSH
43809: EMPTY
43810: LIST
43811: LIST
43812: PUSH
43813: LD_INT 1
43815: NEG
43816: PUSH
43817: LD_INT 1
43819: PUSH
43820: EMPTY
43821: LIST
43822: LIST
43823: PUSH
43824: LD_INT 2
43826: NEG
43827: PUSH
43828: LD_INT 0
43830: PUSH
43831: EMPTY
43832: LIST
43833: LIST
43834: PUSH
43835: LD_INT 2
43837: NEG
43838: PUSH
43839: LD_INT 1
43841: NEG
43842: PUSH
43843: EMPTY
43844: LIST
43845: LIST
43846: PUSH
43847: LD_INT 2
43849: NEG
43850: PUSH
43851: LD_INT 2
43853: NEG
43854: PUSH
43855: EMPTY
43856: LIST
43857: LIST
43858: PUSH
43859: EMPTY
43860: LIST
43861: LIST
43862: LIST
43863: LIST
43864: LIST
43865: LIST
43866: LIST
43867: LIST
43868: LIST
43869: LIST
43870: LIST
43871: LIST
43872: LIST
43873: LIST
43874: LIST
43875: LIST
43876: LIST
43877: LIST
43878: LIST
43879: ST_TO_ADDR
// fBarracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
43880: LD_ADDR_VAR 0 56
43884: PUSH
43885: LD_INT 0
43887: PUSH
43888: LD_INT 0
43890: PUSH
43891: EMPTY
43892: LIST
43893: LIST
43894: PUSH
43895: LD_INT 0
43897: PUSH
43898: LD_INT 1
43900: NEG
43901: PUSH
43902: EMPTY
43903: LIST
43904: LIST
43905: PUSH
43906: LD_INT 1
43908: PUSH
43909: LD_INT 0
43911: PUSH
43912: EMPTY
43913: LIST
43914: LIST
43915: PUSH
43916: LD_INT 1
43918: PUSH
43919: LD_INT 1
43921: PUSH
43922: EMPTY
43923: LIST
43924: LIST
43925: PUSH
43926: LD_INT 0
43928: PUSH
43929: LD_INT 1
43931: PUSH
43932: EMPTY
43933: LIST
43934: LIST
43935: PUSH
43936: LD_INT 1
43938: NEG
43939: PUSH
43940: LD_INT 0
43942: PUSH
43943: EMPTY
43944: LIST
43945: LIST
43946: PUSH
43947: LD_INT 1
43949: NEG
43950: PUSH
43951: LD_INT 1
43953: NEG
43954: PUSH
43955: EMPTY
43956: LIST
43957: LIST
43958: PUSH
43959: LD_INT 1
43961: NEG
43962: PUSH
43963: LD_INT 2
43965: NEG
43966: PUSH
43967: EMPTY
43968: LIST
43969: LIST
43970: PUSH
43971: LD_INT 0
43973: PUSH
43974: LD_INT 2
43976: NEG
43977: PUSH
43978: EMPTY
43979: LIST
43980: LIST
43981: PUSH
43982: LD_INT 1
43984: PUSH
43985: LD_INT 1
43987: NEG
43988: PUSH
43989: EMPTY
43990: LIST
43991: LIST
43992: PUSH
43993: LD_INT 2
43995: PUSH
43996: LD_INT 0
43998: PUSH
43999: EMPTY
44000: LIST
44001: LIST
44002: PUSH
44003: LD_INT 2
44005: PUSH
44006: LD_INT 1
44008: PUSH
44009: EMPTY
44010: LIST
44011: LIST
44012: PUSH
44013: LD_INT 2
44015: PUSH
44016: LD_INT 2
44018: PUSH
44019: EMPTY
44020: LIST
44021: LIST
44022: PUSH
44023: LD_INT 1
44025: PUSH
44026: LD_INT 2
44028: PUSH
44029: EMPTY
44030: LIST
44031: LIST
44032: PUSH
44033: LD_INT 0
44035: PUSH
44036: LD_INT 2
44038: PUSH
44039: EMPTY
44040: LIST
44041: LIST
44042: PUSH
44043: LD_INT 1
44045: NEG
44046: PUSH
44047: LD_INT 1
44049: PUSH
44050: EMPTY
44051: LIST
44052: LIST
44053: PUSH
44054: LD_INT 2
44056: NEG
44057: PUSH
44058: LD_INT 0
44060: PUSH
44061: EMPTY
44062: LIST
44063: LIST
44064: PUSH
44065: LD_INT 2
44067: NEG
44068: PUSH
44069: LD_INT 1
44071: NEG
44072: PUSH
44073: EMPTY
44074: LIST
44075: LIST
44076: PUSH
44077: LD_INT 2
44079: NEG
44080: PUSH
44081: LD_INT 2
44083: NEG
44084: PUSH
44085: EMPTY
44086: LIST
44087: LIST
44088: PUSH
44089: EMPTY
44090: LIST
44091: LIST
44092: LIST
44093: LIST
44094: LIST
44095: LIST
44096: LIST
44097: LIST
44098: LIST
44099: LIST
44100: LIST
44101: LIST
44102: LIST
44103: LIST
44104: LIST
44105: LIST
44106: LIST
44107: LIST
44108: LIST
44109: ST_TO_ADDR
// fBarracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
44110: LD_ADDR_VAR 0 57
44114: PUSH
44115: LD_INT 0
44117: PUSH
44118: LD_INT 0
44120: PUSH
44121: EMPTY
44122: LIST
44123: LIST
44124: PUSH
44125: LD_INT 0
44127: PUSH
44128: LD_INT 1
44130: NEG
44131: PUSH
44132: EMPTY
44133: LIST
44134: LIST
44135: PUSH
44136: LD_INT 1
44138: PUSH
44139: LD_INT 0
44141: PUSH
44142: EMPTY
44143: LIST
44144: LIST
44145: PUSH
44146: LD_INT 1
44148: PUSH
44149: LD_INT 1
44151: PUSH
44152: EMPTY
44153: LIST
44154: LIST
44155: PUSH
44156: LD_INT 0
44158: PUSH
44159: LD_INT 1
44161: PUSH
44162: EMPTY
44163: LIST
44164: LIST
44165: PUSH
44166: LD_INT 1
44168: NEG
44169: PUSH
44170: LD_INT 0
44172: PUSH
44173: EMPTY
44174: LIST
44175: LIST
44176: PUSH
44177: LD_INT 1
44179: NEG
44180: PUSH
44181: LD_INT 1
44183: NEG
44184: PUSH
44185: EMPTY
44186: LIST
44187: LIST
44188: PUSH
44189: LD_INT 1
44191: NEG
44192: PUSH
44193: LD_INT 2
44195: NEG
44196: PUSH
44197: EMPTY
44198: LIST
44199: LIST
44200: PUSH
44201: LD_INT 0
44203: PUSH
44204: LD_INT 2
44206: NEG
44207: PUSH
44208: EMPTY
44209: LIST
44210: LIST
44211: PUSH
44212: LD_INT 1
44214: PUSH
44215: LD_INT 1
44217: NEG
44218: PUSH
44219: EMPTY
44220: LIST
44221: LIST
44222: PUSH
44223: LD_INT 2
44225: PUSH
44226: LD_INT 0
44228: PUSH
44229: EMPTY
44230: LIST
44231: LIST
44232: PUSH
44233: LD_INT 2
44235: PUSH
44236: LD_INT 1
44238: PUSH
44239: EMPTY
44240: LIST
44241: LIST
44242: PUSH
44243: LD_INT 2
44245: PUSH
44246: LD_INT 2
44248: PUSH
44249: EMPTY
44250: LIST
44251: LIST
44252: PUSH
44253: LD_INT 1
44255: PUSH
44256: LD_INT 2
44258: PUSH
44259: EMPTY
44260: LIST
44261: LIST
44262: PUSH
44263: LD_INT 0
44265: PUSH
44266: LD_INT 2
44268: PUSH
44269: EMPTY
44270: LIST
44271: LIST
44272: PUSH
44273: LD_INT 1
44275: NEG
44276: PUSH
44277: LD_INT 1
44279: PUSH
44280: EMPTY
44281: LIST
44282: LIST
44283: PUSH
44284: LD_INT 2
44286: NEG
44287: PUSH
44288: LD_INT 0
44290: PUSH
44291: EMPTY
44292: LIST
44293: LIST
44294: PUSH
44295: LD_INT 2
44297: NEG
44298: PUSH
44299: LD_INT 1
44301: NEG
44302: PUSH
44303: EMPTY
44304: LIST
44305: LIST
44306: PUSH
44307: LD_INT 2
44309: NEG
44310: PUSH
44311: LD_INT 2
44313: NEG
44314: PUSH
44315: EMPTY
44316: LIST
44317: LIST
44318: PUSH
44319: EMPTY
44320: LIST
44321: LIST
44322: LIST
44323: LIST
44324: LIST
44325: LIST
44326: LIST
44327: LIST
44328: LIST
44329: LIST
44330: LIST
44331: LIST
44332: LIST
44333: LIST
44334: LIST
44335: LIST
44336: LIST
44337: LIST
44338: LIST
44339: ST_TO_ADDR
// fBarracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
44340: LD_ADDR_VAR 0 58
44344: PUSH
44345: LD_INT 0
44347: PUSH
44348: LD_INT 0
44350: PUSH
44351: EMPTY
44352: LIST
44353: LIST
44354: PUSH
44355: LD_INT 0
44357: PUSH
44358: LD_INT 1
44360: NEG
44361: PUSH
44362: EMPTY
44363: LIST
44364: LIST
44365: PUSH
44366: LD_INT 1
44368: PUSH
44369: LD_INT 0
44371: PUSH
44372: EMPTY
44373: LIST
44374: LIST
44375: PUSH
44376: LD_INT 1
44378: PUSH
44379: LD_INT 1
44381: PUSH
44382: EMPTY
44383: LIST
44384: LIST
44385: PUSH
44386: LD_INT 0
44388: PUSH
44389: LD_INT 1
44391: PUSH
44392: EMPTY
44393: LIST
44394: LIST
44395: PUSH
44396: LD_INT 1
44398: NEG
44399: PUSH
44400: LD_INT 0
44402: PUSH
44403: EMPTY
44404: LIST
44405: LIST
44406: PUSH
44407: LD_INT 1
44409: NEG
44410: PUSH
44411: LD_INT 1
44413: NEG
44414: PUSH
44415: EMPTY
44416: LIST
44417: LIST
44418: PUSH
44419: LD_INT 1
44421: NEG
44422: PUSH
44423: LD_INT 2
44425: NEG
44426: PUSH
44427: EMPTY
44428: LIST
44429: LIST
44430: PUSH
44431: LD_INT 0
44433: PUSH
44434: LD_INT 2
44436: NEG
44437: PUSH
44438: EMPTY
44439: LIST
44440: LIST
44441: PUSH
44442: LD_INT 1
44444: PUSH
44445: LD_INT 1
44447: NEG
44448: PUSH
44449: EMPTY
44450: LIST
44451: LIST
44452: PUSH
44453: LD_INT 2
44455: PUSH
44456: LD_INT 0
44458: PUSH
44459: EMPTY
44460: LIST
44461: LIST
44462: PUSH
44463: LD_INT 2
44465: PUSH
44466: LD_INT 1
44468: PUSH
44469: EMPTY
44470: LIST
44471: LIST
44472: PUSH
44473: LD_INT 2
44475: PUSH
44476: LD_INT 2
44478: PUSH
44479: EMPTY
44480: LIST
44481: LIST
44482: PUSH
44483: LD_INT 1
44485: PUSH
44486: LD_INT 2
44488: PUSH
44489: EMPTY
44490: LIST
44491: LIST
44492: PUSH
44493: LD_INT 0
44495: PUSH
44496: LD_INT 2
44498: PUSH
44499: EMPTY
44500: LIST
44501: LIST
44502: PUSH
44503: LD_INT 1
44505: NEG
44506: PUSH
44507: LD_INT 1
44509: PUSH
44510: EMPTY
44511: LIST
44512: LIST
44513: PUSH
44514: LD_INT 2
44516: NEG
44517: PUSH
44518: LD_INT 0
44520: PUSH
44521: EMPTY
44522: LIST
44523: LIST
44524: PUSH
44525: LD_INT 2
44527: NEG
44528: PUSH
44529: LD_INT 1
44531: NEG
44532: PUSH
44533: EMPTY
44534: LIST
44535: LIST
44536: PUSH
44537: LD_INT 2
44539: NEG
44540: PUSH
44541: LD_INT 2
44543: NEG
44544: PUSH
44545: EMPTY
44546: LIST
44547: LIST
44548: PUSH
44549: EMPTY
44550: LIST
44551: LIST
44552: LIST
44553: LIST
44554: LIST
44555: LIST
44556: LIST
44557: LIST
44558: LIST
44559: LIST
44560: LIST
44561: LIST
44562: LIST
44563: LIST
44564: LIST
44565: LIST
44566: LIST
44567: LIST
44568: LIST
44569: ST_TO_ADDR
// fBunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
44570: LD_ADDR_VAR 0 59
44574: PUSH
44575: LD_INT 0
44577: PUSH
44578: LD_INT 0
44580: PUSH
44581: EMPTY
44582: LIST
44583: LIST
44584: PUSH
44585: LD_INT 0
44587: PUSH
44588: LD_INT 1
44590: NEG
44591: PUSH
44592: EMPTY
44593: LIST
44594: LIST
44595: PUSH
44596: LD_INT 1
44598: PUSH
44599: LD_INT 0
44601: PUSH
44602: EMPTY
44603: LIST
44604: LIST
44605: PUSH
44606: LD_INT 1
44608: PUSH
44609: LD_INT 1
44611: PUSH
44612: EMPTY
44613: LIST
44614: LIST
44615: PUSH
44616: LD_INT 0
44618: PUSH
44619: LD_INT 1
44621: PUSH
44622: EMPTY
44623: LIST
44624: LIST
44625: PUSH
44626: LD_INT 1
44628: NEG
44629: PUSH
44630: LD_INT 0
44632: PUSH
44633: EMPTY
44634: LIST
44635: LIST
44636: PUSH
44637: LD_INT 1
44639: NEG
44640: PUSH
44641: LD_INT 1
44643: NEG
44644: PUSH
44645: EMPTY
44646: LIST
44647: LIST
44648: PUSH
44649: EMPTY
44650: LIST
44651: LIST
44652: LIST
44653: LIST
44654: LIST
44655: LIST
44656: LIST
44657: ST_TO_ADDR
// fBunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
44658: LD_ADDR_VAR 0 60
44662: PUSH
44663: LD_INT 0
44665: PUSH
44666: LD_INT 0
44668: PUSH
44669: EMPTY
44670: LIST
44671: LIST
44672: PUSH
44673: LD_INT 0
44675: PUSH
44676: LD_INT 1
44678: NEG
44679: PUSH
44680: EMPTY
44681: LIST
44682: LIST
44683: PUSH
44684: LD_INT 1
44686: PUSH
44687: LD_INT 0
44689: PUSH
44690: EMPTY
44691: LIST
44692: LIST
44693: PUSH
44694: LD_INT 1
44696: PUSH
44697: LD_INT 1
44699: PUSH
44700: EMPTY
44701: LIST
44702: LIST
44703: PUSH
44704: LD_INT 0
44706: PUSH
44707: LD_INT 1
44709: PUSH
44710: EMPTY
44711: LIST
44712: LIST
44713: PUSH
44714: LD_INT 1
44716: NEG
44717: PUSH
44718: LD_INT 0
44720: PUSH
44721: EMPTY
44722: LIST
44723: LIST
44724: PUSH
44725: LD_INT 1
44727: NEG
44728: PUSH
44729: LD_INT 1
44731: NEG
44732: PUSH
44733: EMPTY
44734: LIST
44735: LIST
44736: PUSH
44737: EMPTY
44738: LIST
44739: LIST
44740: LIST
44741: LIST
44742: LIST
44743: LIST
44744: LIST
44745: ST_TO_ADDR
// fBunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
44746: LD_ADDR_VAR 0 61
44750: PUSH
44751: LD_INT 0
44753: PUSH
44754: LD_INT 0
44756: PUSH
44757: EMPTY
44758: LIST
44759: LIST
44760: PUSH
44761: LD_INT 0
44763: PUSH
44764: LD_INT 1
44766: NEG
44767: PUSH
44768: EMPTY
44769: LIST
44770: LIST
44771: PUSH
44772: LD_INT 1
44774: PUSH
44775: LD_INT 0
44777: PUSH
44778: EMPTY
44779: LIST
44780: LIST
44781: PUSH
44782: LD_INT 1
44784: PUSH
44785: LD_INT 1
44787: PUSH
44788: EMPTY
44789: LIST
44790: LIST
44791: PUSH
44792: LD_INT 0
44794: PUSH
44795: LD_INT 1
44797: PUSH
44798: EMPTY
44799: LIST
44800: LIST
44801: PUSH
44802: LD_INT 1
44804: NEG
44805: PUSH
44806: LD_INT 0
44808: PUSH
44809: EMPTY
44810: LIST
44811: LIST
44812: PUSH
44813: LD_INT 1
44815: NEG
44816: PUSH
44817: LD_INT 1
44819: NEG
44820: PUSH
44821: EMPTY
44822: LIST
44823: LIST
44824: PUSH
44825: EMPTY
44826: LIST
44827: LIST
44828: LIST
44829: LIST
44830: LIST
44831: LIST
44832: LIST
44833: ST_TO_ADDR
// fBunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
44834: LD_ADDR_VAR 0 62
44838: PUSH
44839: LD_INT 0
44841: PUSH
44842: LD_INT 0
44844: PUSH
44845: EMPTY
44846: LIST
44847: LIST
44848: PUSH
44849: LD_INT 0
44851: PUSH
44852: LD_INT 1
44854: NEG
44855: PUSH
44856: EMPTY
44857: LIST
44858: LIST
44859: PUSH
44860: LD_INT 1
44862: PUSH
44863: LD_INT 0
44865: PUSH
44866: EMPTY
44867: LIST
44868: LIST
44869: PUSH
44870: LD_INT 1
44872: PUSH
44873: LD_INT 1
44875: PUSH
44876: EMPTY
44877: LIST
44878: LIST
44879: PUSH
44880: LD_INT 0
44882: PUSH
44883: LD_INT 1
44885: PUSH
44886: EMPTY
44887: LIST
44888: LIST
44889: PUSH
44890: LD_INT 1
44892: NEG
44893: PUSH
44894: LD_INT 0
44896: PUSH
44897: EMPTY
44898: LIST
44899: LIST
44900: PUSH
44901: LD_INT 1
44903: NEG
44904: PUSH
44905: LD_INT 1
44907: NEG
44908: PUSH
44909: EMPTY
44910: LIST
44911: LIST
44912: PUSH
44913: EMPTY
44914: LIST
44915: LIST
44916: LIST
44917: LIST
44918: LIST
44919: LIST
44920: LIST
44921: ST_TO_ADDR
// fBunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
44922: LD_ADDR_VAR 0 63
44926: PUSH
44927: LD_INT 0
44929: PUSH
44930: LD_INT 0
44932: PUSH
44933: EMPTY
44934: LIST
44935: LIST
44936: PUSH
44937: LD_INT 0
44939: PUSH
44940: LD_INT 1
44942: NEG
44943: PUSH
44944: EMPTY
44945: LIST
44946: LIST
44947: PUSH
44948: LD_INT 1
44950: PUSH
44951: LD_INT 0
44953: PUSH
44954: EMPTY
44955: LIST
44956: LIST
44957: PUSH
44958: LD_INT 1
44960: PUSH
44961: LD_INT 1
44963: PUSH
44964: EMPTY
44965: LIST
44966: LIST
44967: PUSH
44968: LD_INT 0
44970: PUSH
44971: LD_INT 1
44973: PUSH
44974: EMPTY
44975: LIST
44976: LIST
44977: PUSH
44978: LD_INT 1
44980: NEG
44981: PUSH
44982: LD_INT 0
44984: PUSH
44985: EMPTY
44986: LIST
44987: LIST
44988: PUSH
44989: LD_INT 1
44991: NEG
44992: PUSH
44993: LD_INT 1
44995: NEG
44996: PUSH
44997: EMPTY
44998: LIST
44999: LIST
45000: PUSH
45001: EMPTY
45002: LIST
45003: LIST
45004: LIST
45005: LIST
45006: LIST
45007: LIST
45008: LIST
45009: ST_TO_ADDR
// fBunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
45010: LD_ADDR_VAR 0 64
45014: PUSH
45015: LD_INT 0
45017: PUSH
45018: LD_INT 0
45020: PUSH
45021: EMPTY
45022: LIST
45023: LIST
45024: PUSH
45025: LD_INT 0
45027: PUSH
45028: LD_INT 1
45030: NEG
45031: PUSH
45032: EMPTY
45033: LIST
45034: LIST
45035: PUSH
45036: LD_INT 1
45038: PUSH
45039: LD_INT 0
45041: PUSH
45042: EMPTY
45043: LIST
45044: LIST
45045: PUSH
45046: LD_INT 1
45048: PUSH
45049: LD_INT 1
45051: PUSH
45052: EMPTY
45053: LIST
45054: LIST
45055: PUSH
45056: LD_INT 0
45058: PUSH
45059: LD_INT 1
45061: PUSH
45062: EMPTY
45063: LIST
45064: LIST
45065: PUSH
45066: LD_INT 1
45068: NEG
45069: PUSH
45070: LD_INT 0
45072: PUSH
45073: EMPTY
45074: LIST
45075: LIST
45076: PUSH
45077: LD_INT 1
45079: NEG
45080: PUSH
45081: LD_INT 1
45083: NEG
45084: PUSH
45085: EMPTY
45086: LIST
45087: LIST
45088: PUSH
45089: EMPTY
45090: LIST
45091: LIST
45092: LIST
45093: LIST
45094: LIST
45095: LIST
45096: LIST
45097: ST_TO_ADDR
// end ; 1 :
45098: GO 50995
45100: LD_INT 1
45102: DOUBLE
45103: EQUAL
45104: IFTRUE 45108
45106: GO 47731
45108: POP
// begin fDepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
45109: LD_ADDR_VAR 0 11
45113: PUSH
45114: LD_INT 1
45116: NEG
45117: PUSH
45118: LD_INT 3
45120: NEG
45121: PUSH
45122: EMPTY
45123: LIST
45124: LIST
45125: PUSH
45126: LD_INT 0
45128: PUSH
45129: LD_INT 3
45131: NEG
45132: PUSH
45133: EMPTY
45134: LIST
45135: LIST
45136: PUSH
45137: LD_INT 1
45139: PUSH
45140: LD_INT 2
45142: NEG
45143: PUSH
45144: EMPTY
45145: LIST
45146: LIST
45147: PUSH
45148: EMPTY
45149: LIST
45150: LIST
45151: LIST
45152: ST_TO_ADDR
// fDepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
45153: LD_ADDR_VAR 0 12
45157: PUSH
45158: LD_INT 2
45160: PUSH
45161: LD_INT 1
45163: NEG
45164: PUSH
45165: EMPTY
45166: LIST
45167: LIST
45168: PUSH
45169: LD_INT 3
45171: PUSH
45172: LD_INT 0
45174: PUSH
45175: EMPTY
45176: LIST
45177: LIST
45178: PUSH
45179: LD_INT 3
45181: PUSH
45182: LD_INT 1
45184: PUSH
45185: EMPTY
45186: LIST
45187: LIST
45188: PUSH
45189: EMPTY
45190: LIST
45191: LIST
45192: LIST
45193: ST_TO_ADDR
// fDepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
45194: LD_ADDR_VAR 0 13
45198: PUSH
45199: LD_INT 3
45201: PUSH
45202: LD_INT 2
45204: PUSH
45205: EMPTY
45206: LIST
45207: LIST
45208: PUSH
45209: LD_INT 3
45211: PUSH
45212: LD_INT 3
45214: PUSH
45215: EMPTY
45216: LIST
45217: LIST
45218: PUSH
45219: LD_INT 2
45221: PUSH
45222: LD_INT 3
45224: PUSH
45225: EMPTY
45226: LIST
45227: LIST
45228: PUSH
45229: EMPTY
45230: LIST
45231: LIST
45232: LIST
45233: ST_TO_ADDR
// fDepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
45234: LD_ADDR_VAR 0 14
45238: PUSH
45239: LD_INT 1
45241: PUSH
45242: LD_INT 3
45244: PUSH
45245: EMPTY
45246: LIST
45247: LIST
45248: PUSH
45249: LD_INT 0
45251: PUSH
45252: LD_INT 3
45254: PUSH
45255: EMPTY
45256: LIST
45257: LIST
45258: PUSH
45259: LD_INT 1
45261: NEG
45262: PUSH
45263: LD_INT 2
45265: PUSH
45266: EMPTY
45267: LIST
45268: LIST
45269: PUSH
45270: EMPTY
45271: LIST
45272: LIST
45273: LIST
45274: ST_TO_ADDR
// fDepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
45275: LD_ADDR_VAR 0 15
45279: PUSH
45280: LD_INT 2
45282: NEG
45283: PUSH
45284: LD_INT 1
45286: PUSH
45287: EMPTY
45288: LIST
45289: LIST
45290: PUSH
45291: LD_INT 3
45293: NEG
45294: PUSH
45295: LD_INT 0
45297: PUSH
45298: EMPTY
45299: LIST
45300: LIST
45301: PUSH
45302: LD_INT 3
45304: NEG
45305: PUSH
45306: LD_INT 1
45308: NEG
45309: PUSH
45310: EMPTY
45311: LIST
45312: LIST
45313: PUSH
45314: EMPTY
45315: LIST
45316: LIST
45317: LIST
45318: ST_TO_ADDR
// fDepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
45319: LD_ADDR_VAR 0 16
45323: PUSH
45324: LD_INT 2
45326: NEG
45327: PUSH
45328: LD_INT 3
45330: NEG
45331: PUSH
45332: EMPTY
45333: LIST
45334: LIST
45335: PUSH
45336: LD_INT 3
45338: NEG
45339: PUSH
45340: LD_INT 2
45342: NEG
45343: PUSH
45344: EMPTY
45345: LIST
45346: LIST
45347: PUSH
45348: LD_INT 3
45350: NEG
45351: PUSH
45352: LD_INT 3
45354: NEG
45355: PUSH
45356: EMPTY
45357: LIST
45358: LIST
45359: PUSH
45360: EMPTY
45361: LIST
45362: LIST
45363: LIST
45364: ST_TO_ADDR
// fDepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
45365: LD_ADDR_VAR 0 17
45369: PUSH
45370: LD_INT 1
45372: NEG
45373: PUSH
45374: LD_INT 3
45376: NEG
45377: PUSH
45378: EMPTY
45379: LIST
45380: LIST
45381: PUSH
45382: LD_INT 0
45384: PUSH
45385: LD_INT 3
45387: NEG
45388: PUSH
45389: EMPTY
45390: LIST
45391: LIST
45392: PUSH
45393: LD_INT 1
45395: PUSH
45396: LD_INT 2
45398: NEG
45399: PUSH
45400: EMPTY
45401: LIST
45402: LIST
45403: PUSH
45404: EMPTY
45405: LIST
45406: LIST
45407: LIST
45408: ST_TO_ADDR
// fDepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
45409: LD_ADDR_VAR 0 18
45413: PUSH
45414: LD_INT 2
45416: PUSH
45417: LD_INT 1
45419: NEG
45420: PUSH
45421: EMPTY
45422: LIST
45423: LIST
45424: PUSH
45425: LD_INT 3
45427: PUSH
45428: LD_INT 0
45430: PUSH
45431: EMPTY
45432: LIST
45433: LIST
45434: PUSH
45435: LD_INT 3
45437: PUSH
45438: LD_INT 1
45440: PUSH
45441: EMPTY
45442: LIST
45443: LIST
45444: PUSH
45445: EMPTY
45446: LIST
45447: LIST
45448: LIST
45449: ST_TO_ADDR
// fDepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
45450: LD_ADDR_VAR 0 19
45454: PUSH
45455: LD_INT 3
45457: PUSH
45458: LD_INT 2
45460: PUSH
45461: EMPTY
45462: LIST
45463: LIST
45464: PUSH
45465: LD_INT 3
45467: PUSH
45468: LD_INT 3
45470: PUSH
45471: EMPTY
45472: LIST
45473: LIST
45474: PUSH
45475: LD_INT 2
45477: PUSH
45478: LD_INT 3
45480: PUSH
45481: EMPTY
45482: LIST
45483: LIST
45484: PUSH
45485: EMPTY
45486: LIST
45487: LIST
45488: LIST
45489: ST_TO_ADDR
// fDepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
45490: LD_ADDR_VAR 0 20
45494: PUSH
45495: LD_INT 1
45497: PUSH
45498: LD_INT 3
45500: PUSH
45501: EMPTY
45502: LIST
45503: LIST
45504: PUSH
45505: LD_INT 0
45507: PUSH
45508: LD_INT 3
45510: PUSH
45511: EMPTY
45512: LIST
45513: LIST
45514: PUSH
45515: LD_INT 1
45517: NEG
45518: PUSH
45519: LD_INT 2
45521: PUSH
45522: EMPTY
45523: LIST
45524: LIST
45525: PUSH
45526: EMPTY
45527: LIST
45528: LIST
45529: LIST
45530: ST_TO_ADDR
// fDepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
45531: LD_ADDR_VAR 0 21
45535: PUSH
45536: LD_INT 2
45538: NEG
45539: PUSH
45540: LD_INT 1
45542: PUSH
45543: EMPTY
45544: LIST
45545: LIST
45546: PUSH
45547: LD_INT 3
45549: NEG
45550: PUSH
45551: LD_INT 0
45553: PUSH
45554: EMPTY
45555: LIST
45556: LIST
45557: PUSH
45558: LD_INT 3
45560: NEG
45561: PUSH
45562: LD_INT 1
45564: NEG
45565: PUSH
45566: EMPTY
45567: LIST
45568: LIST
45569: PUSH
45570: EMPTY
45571: LIST
45572: LIST
45573: LIST
45574: ST_TO_ADDR
// fDepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
45575: LD_ADDR_VAR 0 22
45579: PUSH
45580: LD_INT 2
45582: NEG
45583: PUSH
45584: LD_INT 3
45586: NEG
45587: PUSH
45588: EMPTY
45589: LIST
45590: LIST
45591: PUSH
45592: LD_INT 3
45594: NEG
45595: PUSH
45596: LD_INT 2
45598: NEG
45599: PUSH
45600: EMPTY
45601: LIST
45602: LIST
45603: PUSH
45604: LD_INT 3
45606: NEG
45607: PUSH
45608: LD_INT 3
45610: NEG
45611: PUSH
45612: EMPTY
45613: LIST
45614: LIST
45615: PUSH
45616: EMPTY
45617: LIST
45618: LIST
45619: LIST
45620: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
45621: LD_ADDR_VAR 0 23
45625: PUSH
45626: LD_INT 0
45628: PUSH
45629: LD_INT 3
45631: NEG
45632: PUSH
45633: EMPTY
45634: LIST
45635: LIST
45636: PUSH
45637: LD_INT 1
45639: NEG
45640: PUSH
45641: LD_INT 4
45643: NEG
45644: PUSH
45645: EMPTY
45646: LIST
45647: LIST
45648: PUSH
45649: LD_INT 1
45651: PUSH
45652: LD_INT 3
45654: NEG
45655: PUSH
45656: EMPTY
45657: LIST
45658: LIST
45659: PUSH
45660: EMPTY
45661: LIST
45662: LIST
45663: LIST
45664: ST_TO_ADDR
// fDepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
45665: LD_ADDR_VAR 0 24
45669: PUSH
45670: LD_INT 3
45672: PUSH
45673: LD_INT 0
45675: PUSH
45676: EMPTY
45677: LIST
45678: LIST
45679: PUSH
45680: LD_INT 3
45682: PUSH
45683: LD_INT 1
45685: NEG
45686: PUSH
45687: EMPTY
45688: LIST
45689: LIST
45690: PUSH
45691: LD_INT 4
45693: PUSH
45694: LD_INT 1
45696: PUSH
45697: EMPTY
45698: LIST
45699: LIST
45700: PUSH
45701: EMPTY
45702: LIST
45703: LIST
45704: LIST
45705: ST_TO_ADDR
// fDepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
45706: LD_ADDR_VAR 0 25
45710: PUSH
45711: LD_INT 3
45713: PUSH
45714: LD_INT 3
45716: PUSH
45717: EMPTY
45718: LIST
45719: LIST
45720: PUSH
45721: LD_INT 4
45723: PUSH
45724: LD_INT 3
45726: PUSH
45727: EMPTY
45728: LIST
45729: LIST
45730: PUSH
45731: LD_INT 3
45733: PUSH
45734: LD_INT 4
45736: PUSH
45737: EMPTY
45738: LIST
45739: LIST
45740: PUSH
45741: EMPTY
45742: LIST
45743: LIST
45744: LIST
45745: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
45746: LD_ADDR_VAR 0 26
45750: PUSH
45751: LD_INT 0
45753: PUSH
45754: LD_INT 3
45756: PUSH
45757: EMPTY
45758: LIST
45759: LIST
45760: PUSH
45761: LD_INT 1
45763: PUSH
45764: LD_INT 4
45766: PUSH
45767: EMPTY
45768: LIST
45769: LIST
45770: PUSH
45771: LD_INT 1
45773: NEG
45774: PUSH
45775: LD_INT 3
45777: PUSH
45778: EMPTY
45779: LIST
45780: LIST
45781: PUSH
45782: EMPTY
45783: LIST
45784: LIST
45785: LIST
45786: ST_TO_ADDR
// fDepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
45787: LD_ADDR_VAR 0 27
45791: PUSH
45792: LD_INT 3
45794: NEG
45795: PUSH
45796: LD_INT 0
45798: PUSH
45799: EMPTY
45800: LIST
45801: LIST
45802: PUSH
45803: LD_INT 3
45805: NEG
45806: PUSH
45807: LD_INT 1
45809: PUSH
45810: EMPTY
45811: LIST
45812: LIST
45813: PUSH
45814: LD_INT 4
45816: NEG
45817: PUSH
45818: LD_INT 1
45820: NEG
45821: PUSH
45822: EMPTY
45823: LIST
45824: LIST
45825: PUSH
45826: EMPTY
45827: LIST
45828: LIST
45829: LIST
45830: ST_TO_ADDR
// fDepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
45831: LD_ADDR_VAR 0 28
45835: PUSH
45836: LD_INT 3
45838: NEG
45839: PUSH
45840: LD_INT 3
45842: NEG
45843: PUSH
45844: EMPTY
45845: LIST
45846: LIST
45847: PUSH
45848: LD_INT 3
45850: NEG
45851: PUSH
45852: LD_INT 4
45854: NEG
45855: PUSH
45856: EMPTY
45857: LIST
45858: LIST
45859: PUSH
45860: LD_INT 4
45862: NEG
45863: PUSH
45864: LD_INT 3
45866: NEG
45867: PUSH
45868: EMPTY
45869: LIST
45870: LIST
45871: PUSH
45872: EMPTY
45873: LIST
45874: LIST
45875: LIST
45876: ST_TO_ADDR
// fFactory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
45877: LD_ADDR_VAR 0 29
45881: PUSH
45882: LD_INT 1
45884: NEG
45885: PUSH
45886: LD_INT 3
45888: NEG
45889: PUSH
45890: EMPTY
45891: LIST
45892: LIST
45893: PUSH
45894: LD_INT 0
45896: PUSH
45897: LD_INT 3
45899: NEG
45900: PUSH
45901: EMPTY
45902: LIST
45903: LIST
45904: PUSH
45905: LD_INT 1
45907: PUSH
45908: LD_INT 2
45910: NEG
45911: PUSH
45912: EMPTY
45913: LIST
45914: LIST
45915: PUSH
45916: LD_INT 1
45918: NEG
45919: PUSH
45920: LD_INT 4
45922: NEG
45923: PUSH
45924: EMPTY
45925: LIST
45926: LIST
45927: PUSH
45928: LD_INT 0
45930: PUSH
45931: LD_INT 4
45933: NEG
45934: PUSH
45935: EMPTY
45936: LIST
45937: LIST
45938: PUSH
45939: LD_INT 1
45941: PUSH
45942: LD_INT 3
45944: NEG
45945: PUSH
45946: EMPTY
45947: LIST
45948: LIST
45949: PUSH
45950: LD_INT 1
45952: NEG
45953: PUSH
45954: LD_INT 5
45956: NEG
45957: PUSH
45958: EMPTY
45959: LIST
45960: LIST
45961: PUSH
45962: LD_INT 0
45964: PUSH
45965: LD_INT 5
45967: NEG
45968: PUSH
45969: EMPTY
45970: LIST
45971: LIST
45972: PUSH
45973: LD_INT 1
45975: PUSH
45976: LD_INT 4
45978: NEG
45979: PUSH
45980: EMPTY
45981: LIST
45982: LIST
45983: PUSH
45984: LD_INT 1
45986: NEG
45987: PUSH
45988: LD_INT 6
45990: NEG
45991: PUSH
45992: EMPTY
45993: LIST
45994: LIST
45995: PUSH
45996: LD_INT 0
45998: PUSH
45999: LD_INT 6
46001: NEG
46002: PUSH
46003: EMPTY
46004: LIST
46005: LIST
46006: PUSH
46007: LD_INT 1
46009: PUSH
46010: LD_INT 5
46012: NEG
46013: PUSH
46014: EMPTY
46015: LIST
46016: LIST
46017: PUSH
46018: EMPTY
46019: LIST
46020: LIST
46021: LIST
46022: LIST
46023: LIST
46024: LIST
46025: LIST
46026: LIST
46027: LIST
46028: LIST
46029: LIST
46030: LIST
46031: ST_TO_ADDR
// fFactory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
46032: LD_ADDR_VAR 0 30
46036: PUSH
46037: LD_INT 2
46039: PUSH
46040: LD_INT 1
46042: NEG
46043: PUSH
46044: EMPTY
46045: LIST
46046: LIST
46047: PUSH
46048: LD_INT 3
46050: PUSH
46051: LD_INT 0
46053: PUSH
46054: EMPTY
46055: LIST
46056: LIST
46057: PUSH
46058: LD_INT 3
46060: PUSH
46061: LD_INT 1
46063: PUSH
46064: EMPTY
46065: LIST
46066: LIST
46067: PUSH
46068: LD_INT 3
46070: PUSH
46071: LD_INT 1
46073: NEG
46074: PUSH
46075: EMPTY
46076: LIST
46077: LIST
46078: PUSH
46079: LD_INT 4
46081: PUSH
46082: LD_INT 0
46084: PUSH
46085: EMPTY
46086: LIST
46087: LIST
46088: PUSH
46089: LD_INT 4
46091: PUSH
46092: LD_INT 1
46094: PUSH
46095: EMPTY
46096: LIST
46097: LIST
46098: PUSH
46099: LD_INT 4
46101: PUSH
46102: LD_INT 1
46104: NEG
46105: PUSH
46106: EMPTY
46107: LIST
46108: LIST
46109: PUSH
46110: LD_INT 5
46112: PUSH
46113: LD_INT 0
46115: PUSH
46116: EMPTY
46117: LIST
46118: LIST
46119: PUSH
46120: LD_INT 5
46122: PUSH
46123: LD_INT 1
46125: PUSH
46126: EMPTY
46127: LIST
46128: LIST
46129: PUSH
46130: LD_INT 5
46132: PUSH
46133: LD_INT 1
46135: NEG
46136: PUSH
46137: EMPTY
46138: LIST
46139: LIST
46140: PUSH
46141: LD_INT 6
46143: PUSH
46144: LD_INT 0
46146: PUSH
46147: EMPTY
46148: LIST
46149: LIST
46150: PUSH
46151: LD_INT 6
46153: PUSH
46154: LD_INT 1
46156: PUSH
46157: EMPTY
46158: LIST
46159: LIST
46160: PUSH
46161: EMPTY
46162: LIST
46163: LIST
46164: LIST
46165: LIST
46166: LIST
46167: LIST
46168: LIST
46169: LIST
46170: LIST
46171: LIST
46172: LIST
46173: LIST
46174: ST_TO_ADDR
// fFactory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
46175: LD_ADDR_VAR 0 31
46179: PUSH
46180: LD_INT 3
46182: PUSH
46183: LD_INT 2
46185: PUSH
46186: EMPTY
46187: LIST
46188: LIST
46189: PUSH
46190: LD_INT 3
46192: PUSH
46193: LD_INT 3
46195: PUSH
46196: EMPTY
46197: LIST
46198: LIST
46199: PUSH
46200: LD_INT 2
46202: PUSH
46203: LD_INT 3
46205: PUSH
46206: EMPTY
46207: LIST
46208: LIST
46209: PUSH
46210: LD_INT 4
46212: PUSH
46213: LD_INT 3
46215: PUSH
46216: EMPTY
46217: LIST
46218: LIST
46219: PUSH
46220: LD_INT 4
46222: PUSH
46223: LD_INT 4
46225: PUSH
46226: EMPTY
46227: LIST
46228: LIST
46229: PUSH
46230: LD_INT 3
46232: PUSH
46233: LD_INT 4
46235: PUSH
46236: EMPTY
46237: LIST
46238: LIST
46239: PUSH
46240: LD_INT 5
46242: PUSH
46243: LD_INT 4
46245: PUSH
46246: EMPTY
46247: LIST
46248: LIST
46249: PUSH
46250: LD_INT 5
46252: PUSH
46253: LD_INT 5
46255: PUSH
46256: EMPTY
46257: LIST
46258: LIST
46259: PUSH
46260: LD_INT 4
46262: PUSH
46263: LD_INT 5
46265: PUSH
46266: EMPTY
46267: LIST
46268: LIST
46269: PUSH
46270: LD_INT 6
46272: PUSH
46273: LD_INT 5
46275: PUSH
46276: EMPTY
46277: LIST
46278: LIST
46279: PUSH
46280: LD_INT 6
46282: PUSH
46283: LD_INT 6
46285: PUSH
46286: EMPTY
46287: LIST
46288: LIST
46289: PUSH
46290: LD_INT 5
46292: PUSH
46293: LD_INT 6
46295: PUSH
46296: EMPTY
46297: LIST
46298: LIST
46299: PUSH
46300: EMPTY
46301: LIST
46302: LIST
46303: LIST
46304: LIST
46305: LIST
46306: LIST
46307: LIST
46308: LIST
46309: LIST
46310: LIST
46311: LIST
46312: LIST
46313: ST_TO_ADDR
// fFactory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
46314: LD_ADDR_VAR 0 32
46318: PUSH
46319: LD_INT 1
46321: PUSH
46322: LD_INT 3
46324: PUSH
46325: EMPTY
46326: LIST
46327: LIST
46328: PUSH
46329: LD_INT 0
46331: PUSH
46332: LD_INT 3
46334: PUSH
46335: EMPTY
46336: LIST
46337: LIST
46338: PUSH
46339: LD_INT 1
46341: NEG
46342: PUSH
46343: LD_INT 2
46345: PUSH
46346: EMPTY
46347: LIST
46348: LIST
46349: PUSH
46350: LD_INT 1
46352: PUSH
46353: LD_INT 4
46355: PUSH
46356: EMPTY
46357: LIST
46358: LIST
46359: PUSH
46360: LD_INT 0
46362: PUSH
46363: LD_INT 4
46365: PUSH
46366: EMPTY
46367: LIST
46368: LIST
46369: PUSH
46370: LD_INT 1
46372: NEG
46373: PUSH
46374: LD_INT 3
46376: PUSH
46377: EMPTY
46378: LIST
46379: LIST
46380: PUSH
46381: LD_INT 1
46383: PUSH
46384: LD_INT 5
46386: PUSH
46387: EMPTY
46388: LIST
46389: LIST
46390: PUSH
46391: LD_INT 0
46393: PUSH
46394: LD_INT 5
46396: PUSH
46397: EMPTY
46398: LIST
46399: LIST
46400: PUSH
46401: LD_INT 1
46403: NEG
46404: PUSH
46405: LD_INT 4
46407: PUSH
46408: EMPTY
46409: LIST
46410: LIST
46411: PUSH
46412: LD_INT 1
46414: PUSH
46415: LD_INT 6
46417: PUSH
46418: EMPTY
46419: LIST
46420: LIST
46421: PUSH
46422: LD_INT 0
46424: PUSH
46425: LD_INT 6
46427: PUSH
46428: EMPTY
46429: LIST
46430: LIST
46431: PUSH
46432: LD_INT 1
46434: NEG
46435: PUSH
46436: LD_INT 5
46438: PUSH
46439: EMPTY
46440: LIST
46441: LIST
46442: PUSH
46443: EMPTY
46444: LIST
46445: LIST
46446: LIST
46447: LIST
46448: LIST
46449: LIST
46450: LIST
46451: LIST
46452: LIST
46453: LIST
46454: LIST
46455: LIST
46456: ST_TO_ADDR
// fFactory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
46457: LD_ADDR_VAR 0 33
46461: PUSH
46462: LD_INT 2
46464: NEG
46465: PUSH
46466: LD_INT 1
46468: PUSH
46469: EMPTY
46470: LIST
46471: LIST
46472: PUSH
46473: LD_INT 3
46475: NEG
46476: PUSH
46477: LD_INT 0
46479: PUSH
46480: EMPTY
46481: LIST
46482: LIST
46483: PUSH
46484: LD_INT 3
46486: NEG
46487: PUSH
46488: LD_INT 1
46490: NEG
46491: PUSH
46492: EMPTY
46493: LIST
46494: LIST
46495: PUSH
46496: LD_INT 3
46498: NEG
46499: PUSH
46500: LD_INT 1
46502: PUSH
46503: EMPTY
46504: LIST
46505: LIST
46506: PUSH
46507: LD_INT 4
46509: NEG
46510: PUSH
46511: LD_INT 0
46513: PUSH
46514: EMPTY
46515: LIST
46516: LIST
46517: PUSH
46518: LD_INT 4
46520: NEG
46521: PUSH
46522: LD_INT 1
46524: NEG
46525: PUSH
46526: EMPTY
46527: LIST
46528: LIST
46529: PUSH
46530: LD_INT 4
46532: NEG
46533: PUSH
46534: LD_INT 1
46536: PUSH
46537: EMPTY
46538: LIST
46539: LIST
46540: PUSH
46541: LD_INT 5
46543: NEG
46544: PUSH
46545: LD_INT 0
46547: PUSH
46548: EMPTY
46549: LIST
46550: LIST
46551: PUSH
46552: LD_INT 5
46554: NEG
46555: PUSH
46556: LD_INT 1
46558: NEG
46559: PUSH
46560: EMPTY
46561: LIST
46562: LIST
46563: PUSH
46564: LD_INT 5
46566: NEG
46567: PUSH
46568: LD_INT 1
46570: PUSH
46571: EMPTY
46572: LIST
46573: LIST
46574: PUSH
46575: LD_INT 6
46577: NEG
46578: PUSH
46579: LD_INT 0
46581: PUSH
46582: EMPTY
46583: LIST
46584: LIST
46585: PUSH
46586: LD_INT 6
46588: NEG
46589: PUSH
46590: LD_INT 1
46592: NEG
46593: PUSH
46594: EMPTY
46595: LIST
46596: LIST
46597: PUSH
46598: EMPTY
46599: LIST
46600: LIST
46601: LIST
46602: LIST
46603: LIST
46604: LIST
46605: LIST
46606: LIST
46607: LIST
46608: LIST
46609: LIST
46610: LIST
46611: ST_TO_ADDR
// fFactory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
46612: LD_ADDR_VAR 0 34
46616: PUSH
46617: LD_INT 2
46619: NEG
46620: PUSH
46621: LD_INT 3
46623: NEG
46624: PUSH
46625: EMPTY
46626: LIST
46627: LIST
46628: PUSH
46629: LD_INT 3
46631: NEG
46632: PUSH
46633: LD_INT 2
46635: NEG
46636: PUSH
46637: EMPTY
46638: LIST
46639: LIST
46640: PUSH
46641: LD_INT 3
46643: NEG
46644: PUSH
46645: LD_INT 3
46647: NEG
46648: PUSH
46649: EMPTY
46650: LIST
46651: LIST
46652: PUSH
46653: LD_INT 3
46655: NEG
46656: PUSH
46657: LD_INT 4
46659: NEG
46660: PUSH
46661: EMPTY
46662: LIST
46663: LIST
46664: PUSH
46665: LD_INT 4
46667: NEG
46668: PUSH
46669: LD_INT 3
46671: NEG
46672: PUSH
46673: EMPTY
46674: LIST
46675: LIST
46676: PUSH
46677: LD_INT 4
46679: NEG
46680: PUSH
46681: LD_INT 4
46683: NEG
46684: PUSH
46685: EMPTY
46686: LIST
46687: LIST
46688: PUSH
46689: LD_INT 4
46691: NEG
46692: PUSH
46693: LD_INT 5
46695: NEG
46696: PUSH
46697: EMPTY
46698: LIST
46699: LIST
46700: PUSH
46701: LD_INT 5
46703: NEG
46704: PUSH
46705: LD_INT 4
46707: NEG
46708: PUSH
46709: EMPTY
46710: LIST
46711: LIST
46712: PUSH
46713: LD_INT 5
46715: NEG
46716: PUSH
46717: LD_INT 5
46719: NEG
46720: PUSH
46721: EMPTY
46722: LIST
46723: LIST
46724: PUSH
46725: LD_INT 5
46727: NEG
46728: PUSH
46729: LD_INT 6
46731: NEG
46732: PUSH
46733: EMPTY
46734: LIST
46735: LIST
46736: PUSH
46737: LD_INT 6
46739: NEG
46740: PUSH
46741: LD_INT 5
46743: NEG
46744: PUSH
46745: EMPTY
46746: LIST
46747: LIST
46748: PUSH
46749: LD_INT 6
46751: NEG
46752: PUSH
46753: LD_INT 6
46755: NEG
46756: PUSH
46757: EMPTY
46758: LIST
46759: LIST
46760: PUSH
46761: EMPTY
46762: LIST
46763: LIST
46764: LIST
46765: LIST
46766: LIST
46767: LIST
46768: LIST
46769: LIST
46770: LIST
46771: LIST
46772: LIST
46773: LIST
46774: ST_TO_ADDR
// fLab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
46775: LD_ADDR_VAR 0 41
46779: PUSH
46780: LD_INT 0
46782: PUSH
46783: LD_INT 2
46785: NEG
46786: PUSH
46787: EMPTY
46788: LIST
46789: LIST
46790: PUSH
46791: LD_INT 1
46793: NEG
46794: PUSH
46795: LD_INT 3
46797: NEG
46798: PUSH
46799: EMPTY
46800: LIST
46801: LIST
46802: PUSH
46803: LD_INT 1
46805: PUSH
46806: LD_INT 2
46808: NEG
46809: PUSH
46810: EMPTY
46811: LIST
46812: LIST
46813: PUSH
46814: EMPTY
46815: LIST
46816: LIST
46817: LIST
46818: ST_TO_ADDR
// fLab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
46819: LD_ADDR_VAR 0 42
46823: PUSH
46824: LD_INT 2
46826: PUSH
46827: LD_INT 0
46829: PUSH
46830: EMPTY
46831: LIST
46832: LIST
46833: PUSH
46834: LD_INT 2
46836: PUSH
46837: LD_INT 1
46839: NEG
46840: PUSH
46841: EMPTY
46842: LIST
46843: LIST
46844: PUSH
46845: LD_INT 3
46847: PUSH
46848: LD_INT 1
46850: PUSH
46851: EMPTY
46852: LIST
46853: LIST
46854: PUSH
46855: EMPTY
46856: LIST
46857: LIST
46858: LIST
46859: ST_TO_ADDR
// fLab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
46860: LD_ADDR_VAR 0 43
46864: PUSH
46865: LD_INT 2
46867: PUSH
46868: LD_INT 2
46870: PUSH
46871: EMPTY
46872: LIST
46873: LIST
46874: PUSH
46875: LD_INT 3
46877: PUSH
46878: LD_INT 2
46880: PUSH
46881: EMPTY
46882: LIST
46883: LIST
46884: PUSH
46885: LD_INT 2
46887: PUSH
46888: LD_INT 3
46890: PUSH
46891: EMPTY
46892: LIST
46893: LIST
46894: PUSH
46895: EMPTY
46896: LIST
46897: LIST
46898: LIST
46899: ST_TO_ADDR
// fLab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
46900: LD_ADDR_VAR 0 44
46904: PUSH
46905: LD_INT 0
46907: PUSH
46908: LD_INT 2
46910: PUSH
46911: EMPTY
46912: LIST
46913: LIST
46914: PUSH
46915: LD_INT 1
46917: PUSH
46918: LD_INT 3
46920: PUSH
46921: EMPTY
46922: LIST
46923: LIST
46924: PUSH
46925: LD_INT 1
46927: NEG
46928: PUSH
46929: LD_INT 2
46931: PUSH
46932: EMPTY
46933: LIST
46934: LIST
46935: PUSH
46936: EMPTY
46937: LIST
46938: LIST
46939: LIST
46940: ST_TO_ADDR
// fLab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
46941: LD_ADDR_VAR 0 45
46945: PUSH
46946: LD_INT 2
46948: NEG
46949: PUSH
46950: LD_INT 0
46952: PUSH
46953: EMPTY
46954: LIST
46955: LIST
46956: PUSH
46957: LD_INT 2
46959: NEG
46960: PUSH
46961: LD_INT 1
46963: PUSH
46964: EMPTY
46965: LIST
46966: LIST
46967: PUSH
46968: LD_INT 3
46970: NEG
46971: PUSH
46972: LD_INT 1
46974: NEG
46975: PUSH
46976: EMPTY
46977: LIST
46978: LIST
46979: PUSH
46980: EMPTY
46981: LIST
46982: LIST
46983: LIST
46984: ST_TO_ADDR
// fLab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
46985: LD_ADDR_VAR 0 46
46989: PUSH
46990: LD_INT 2
46992: NEG
46993: PUSH
46994: LD_INT 2
46996: NEG
46997: PUSH
46998: EMPTY
46999: LIST
47000: LIST
47001: PUSH
47002: LD_INT 2
47004: NEG
47005: PUSH
47006: LD_INT 3
47008: NEG
47009: PUSH
47010: EMPTY
47011: LIST
47012: LIST
47013: PUSH
47014: LD_INT 3
47016: NEG
47017: PUSH
47018: LD_INT 2
47020: NEG
47021: PUSH
47022: EMPTY
47023: LIST
47024: LIST
47025: PUSH
47026: EMPTY
47027: LIST
47028: LIST
47029: LIST
47030: ST_TO_ADDR
// fControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
47031: LD_ADDR_VAR 0 47
47035: PUSH
47036: LD_INT 2
47038: NEG
47039: PUSH
47040: LD_INT 3
47042: NEG
47043: PUSH
47044: EMPTY
47045: LIST
47046: LIST
47047: PUSH
47048: LD_INT 1
47050: NEG
47051: PUSH
47052: LD_INT 3
47054: NEG
47055: PUSH
47056: EMPTY
47057: LIST
47058: LIST
47059: PUSH
47060: EMPTY
47061: LIST
47062: LIST
47063: ST_TO_ADDR
// fControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
47064: LD_ADDR_VAR 0 48
47068: PUSH
47069: LD_INT 1
47071: PUSH
47072: LD_INT 2
47074: NEG
47075: PUSH
47076: EMPTY
47077: LIST
47078: LIST
47079: PUSH
47080: LD_INT 2
47082: PUSH
47083: LD_INT 1
47085: NEG
47086: PUSH
47087: EMPTY
47088: LIST
47089: LIST
47090: PUSH
47091: EMPTY
47092: LIST
47093: LIST
47094: ST_TO_ADDR
// fControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
47095: LD_ADDR_VAR 0 49
47099: PUSH
47100: LD_INT 3
47102: PUSH
47103: LD_INT 1
47105: PUSH
47106: EMPTY
47107: LIST
47108: LIST
47109: PUSH
47110: LD_INT 3
47112: PUSH
47113: LD_INT 2
47115: PUSH
47116: EMPTY
47117: LIST
47118: LIST
47119: PUSH
47120: EMPTY
47121: LIST
47122: LIST
47123: ST_TO_ADDR
// fControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
47124: LD_ADDR_VAR 0 50
47128: PUSH
47129: LD_INT 2
47131: PUSH
47132: LD_INT 3
47134: PUSH
47135: EMPTY
47136: LIST
47137: LIST
47138: PUSH
47139: LD_INT 1
47141: PUSH
47142: LD_INT 3
47144: PUSH
47145: EMPTY
47146: LIST
47147: LIST
47148: PUSH
47149: EMPTY
47150: LIST
47151: LIST
47152: ST_TO_ADDR
// fControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
47153: LD_ADDR_VAR 0 51
47157: PUSH
47158: LD_INT 1
47160: NEG
47161: PUSH
47162: LD_INT 2
47164: PUSH
47165: EMPTY
47166: LIST
47167: LIST
47168: PUSH
47169: LD_INT 2
47171: NEG
47172: PUSH
47173: LD_INT 1
47175: PUSH
47176: EMPTY
47177: LIST
47178: LIST
47179: PUSH
47180: EMPTY
47181: LIST
47182: LIST
47183: ST_TO_ADDR
// fControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
47184: LD_ADDR_VAR 0 52
47188: PUSH
47189: LD_INT 3
47191: NEG
47192: PUSH
47193: LD_INT 1
47195: NEG
47196: PUSH
47197: EMPTY
47198: LIST
47199: LIST
47200: PUSH
47201: LD_INT 3
47203: NEG
47204: PUSH
47205: LD_INT 2
47207: NEG
47208: PUSH
47209: EMPTY
47210: LIST
47211: LIST
47212: PUSH
47213: EMPTY
47214: LIST
47215: LIST
47216: ST_TO_ADDR
// fBarracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
47217: LD_ADDR_VAR 0 53
47221: PUSH
47222: LD_INT 1
47224: NEG
47225: PUSH
47226: LD_INT 3
47228: NEG
47229: PUSH
47230: EMPTY
47231: LIST
47232: LIST
47233: PUSH
47234: LD_INT 0
47236: PUSH
47237: LD_INT 3
47239: NEG
47240: PUSH
47241: EMPTY
47242: LIST
47243: LIST
47244: PUSH
47245: LD_INT 1
47247: PUSH
47248: LD_INT 2
47250: NEG
47251: PUSH
47252: EMPTY
47253: LIST
47254: LIST
47255: PUSH
47256: EMPTY
47257: LIST
47258: LIST
47259: LIST
47260: ST_TO_ADDR
// fBarracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
47261: LD_ADDR_VAR 0 54
47265: PUSH
47266: LD_INT 2
47268: PUSH
47269: LD_INT 1
47271: NEG
47272: PUSH
47273: EMPTY
47274: LIST
47275: LIST
47276: PUSH
47277: LD_INT 3
47279: PUSH
47280: LD_INT 0
47282: PUSH
47283: EMPTY
47284: LIST
47285: LIST
47286: PUSH
47287: LD_INT 3
47289: PUSH
47290: LD_INT 1
47292: PUSH
47293: EMPTY
47294: LIST
47295: LIST
47296: PUSH
47297: EMPTY
47298: LIST
47299: LIST
47300: LIST
47301: ST_TO_ADDR
// fBarracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
47302: LD_ADDR_VAR 0 55
47306: PUSH
47307: LD_INT 3
47309: PUSH
47310: LD_INT 2
47312: PUSH
47313: EMPTY
47314: LIST
47315: LIST
47316: PUSH
47317: LD_INT 3
47319: PUSH
47320: LD_INT 3
47322: PUSH
47323: EMPTY
47324: LIST
47325: LIST
47326: PUSH
47327: LD_INT 2
47329: PUSH
47330: LD_INT 3
47332: PUSH
47333: EMPTY
47334: LIST
47335: LIST
47336: PUSH
47337: EMPTY
47338: LIST
47339: LIST
47340: LIST
47341: ST_TO_ADDR
// fBarracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
47342: LD_ADDR_VAR 0 56
47346: PUSH
47347: LD_INT 1
47349: PUSH
47350: LD_INT 3
47352: PUSH
47353: EMPTY
47354: LIST
47355: LIST
47356: PUSH
47357: LD_INT 0
47359: PUSH
47360: LD_INT 3
47362: PUSH
47363: EMPTY
47364: LIST
47365: LIST
47366: PUSH
47367: LD_INT 1
47369: NEG
47370: PUSH
47371: LD_INT 2
47373: PUSH
47374: EMPTY
47375: LIST
47376: LIST
47377: PUSH
47378: EMPTY
47379: LIST
47380: LIST
47381: LIST
47382: ST_TO_ADDR
// fBarracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
47383: LD_ADDR_VAR 0 57
47387: PUSH
47388: LD_INT 2
47390: NEG
47391: PUSH
47392: LD_INT 1
47394: PUSH
47395: EMPTY
47396: LIST
47397: LIST
47398: PUSH
47399: LD_INT 3
47401: NEG
47402: PUSH
47403: LD_INT 0
47405: PUSH
47406: EMPTY
47407: LIST
47408: LIST
47409: PUSH
47410: LD_INT 3
47412: NEG
47413: PUSH
47414: LD_INT 1
47416: NEG
47417: PUSH
47418: EMPTY
47419: LIST
47420: LIST
47421: PUSH
47422: EMPTY
47423: LIST
47424: LIST
47425: LIST
47426: ST_TO_ADDR
// fBarracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
47427: LD_ADDR_VAR 0 58
47431: PUSH
47432: LD_INT 2
47434: NEG
47435: PUSH
47436: LD_INT 3
47438: NEG
47439: PUSH
47440: EMPTY
47441: LIST
47442: LIST
47443: PUSH
47444: LD_INT 3
47446: NEG
47447: PUSH
47448: LD_INT 2
47450: NEG
47451: PUSH
47452: EMPTY
47453: LIST
47454: LIST
47455: PUSH
47456: LD_INT 3
47458: NEG
47459: PUSH
47460: LD_INT 3
47462: NEG
47463: PUSH
47464: EMPTY
47465: LIST
47466: LIST
47467: PUSH
47468: EMPTY
47469: LIST
47470: LIST
47471: LIST
47472: ST_TO_ADDR
// fBunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
47473: LD_ADDR_VAR 0 59
47477: PUSH
47478: LD_INT 1
47480: NEG
47481: PUSH
47482: LD_INT 2
47484: NEG
47485: PUSH
47486: EMPTY
47487: LIST
47488: LIST
47489: PUSH
47490: LD_INT 0
47492: PUSH
47493: LD_INT 2
47495: NEG
47496: PUSH
47497: EMPTY
47498: LIST
47499: LIST
47500: PUSH
47501: LD_INT 1
47503: PUSH
47504: LD_INT 1
47506: NEG
47507: PUSH
47508: EMPTY
47509: LIST
47510: LIST
47511: PUSH
47512: EMPTY
47513: LIST
47514: LIST
47515: LIST
47516: ST_TO_ADDR
// fBunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
47517: LD_ADDR_VAR 0 60
47521: PUSH
47522: LD_INT 1
47524: PUSH
47525: LD_INT 1
47527: NEG
47528: PUSH
47529: EMPTY
47530: LIST
47531: LIST
47532: PUSH
47533: LD_INT 2
47535: PUSH
47536: LD_INT 0
47538: PUSH
47539: EMPTY
47540: LIST
47541: LIST
47542: PUSH
47543: LD_INT 2
47545: PUSH
47546: LD_INT 1
47548: PUSH
47549: EMPTY
47550: LIST
47551: LIST
47552: PUSH
47553: EMPTY
47554: LIST
47555: LIST
47556: LIST
47557: ST_TO_ADDR
// fBunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
47558: LD_ADDR_VAR 0 61
47562: PUSH
47563: LD_INT 2
47565: PUSH
47566: LD_INT 1
47568: PUSH
47569: EMPTY
47570: LIST
47571: LIST
47572: PUSH
47573: LD_INT 2
47575: PUSH
47576: LD_INT 2
47578: PUSH
47579: EMPTY
47580: LIST
47581: LIST
47582: PUSH
47583: LD_INT 1
47585: PUSH
47586: LD_INT 2
47588: PUSH
47589: EMPTY
47590: LIST
47591: LIST
47592: PUSH
47593: EMPTY
47594: LIST
47595: LIST
47596: LIST
47597: ST_TO_ADDR
// fBunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
47598: LD_ADDR_VAR 0 62
47602: PUSH
47603: LD_INT 1
47605: PUSH
47606: LD_INT 2
47608: PUSH
47609: EMPTY
47610: LIST
47611: LIST
47612: PUSH
47613: LD_INT 0
47615: PUSH
47616: LD_INT 2
47618: PUSH
47619: EMPTY
47620: LIST
47621: LIST
47622: PUSH
47623: LD_INT 1
47625: NEG
47626: PUSH
47627: LD_INT 1
47629: PUSH
47630: EMPTY
47631: LIST
47632: LIST
47633: PUSH
47634: EMPTY
47635: LIST
47636: LIST
47637: LIST
47638: ST_TO_ADDR
// fBunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
47639: LD_ADDR_VAR 0 63
47643: PUSH
47644: LD_INT 1
47646: NEG
47647: PUSH
47648: LD_INT 1
47650: PUSH
47651: EMPTY
47652: LIST
47653: LIST
47654: PUSH
47655: LD_INT 2
47657: NEG
47658: PUSH
47659: LD_INT 0
47661: PUSH
47662: EMPTY
47663: LIST
47664: LIST
47665: PUSH
47666: LD_INT 2
47668: NEG
47669: PUSH
47670: LD_INT 1
47672: NEG
47673: PUSH
47674: EMPTY
47675: LIST
47676: LIST
47677: PUSH
47678: EMPTY
47679: LIST
47680: LIST
47681: LIST
47682: ST_TO_ADDR
// fBunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
47683: LD_ADDR_VAR 0 64
47687: PUSH
47688: LD_INT 1
47690: NEG
47691: PUSH
47692: LD_INT 2
47694: NEG
47695: PUSH
47696: EMPTY
47697: LIST
47698: LIST
47699: PUSH
47700: LD_INT 2
47702: NEG
47703: PUSH
47704: LD_INT 1
47706: NEG
47707: PUSH
47708: EMPTY
47709: LIST
47710: LIST
47711: PUSH
47712: LD_INT 2
47714: NEG
47715: PUSH
47716: LD_INT 2
47718: NEG
47719: PUSH
47720: EMPTY
47721: LIST
47722: LIST
47723: PUSH
47724: EMPTY
47725: LIST
47726: LIST
47727: LIST
47728: ST_TO_ADDR
// end ; 2 :
47729: GO 50995
47731: LD_INT 2
47733: DOUBLE
47734: EQUAL
47735: IFTRUE 47739
47737: GO 50994
47739: POP
// begin fFactory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
47740: LD_ADDR_VAR 0 29
47744: PUSH
47745: LD_INT 4
47747: PUSH
47748: LD_INT 0
47750: PUSH
47751: EMPTY
47752: LIST
47753: LIST
47754: PUSH
47755: LD_INT 4
47757: PUSH
47758: LD_INT 1
47760: NEG
47761: PUSH
47762: EMPTY
47763: LIST
47764: LIST
47765: PUSH
47766: LD_INT 5
47768: PUSH
47769: LD_INT 0
47771: PUSH
47772: EMPTY
47773: LIST
47774: LIST
47775: PUSH
47776: LD_INT 5
47778: PUSH
47779: LD_INT 1
47781: PUSH
47782: EMPTY
47783: LIST
47784: LIST
47785: PUSH
47786: LD_INT 4
47788: PUSH
47789: LD_INT 1
47791: PUSH
47792: EMPTY
47793: LIST
47794: LIST
47795: PUSH
47796: LD_INT 3
47798: PUSH
47799: LD_INT 0
47801: PUSH
47802: EMPTY
47803: LIST
47804: LIST
47805: PUSH
47806: LD_INT 3
47808: PUSH
47809: LD_INT 1
47811: NEG
47812: PUSH
47813: EMPTY
47814: LIST
47815: LIST
47816: PUSH
47817: LD_INT 3
47819: PUSH
47820: LD_INT 2
47822: NEG
47823: PUSH
47824: EMPTY
47825: LIST
47826: LIST
47827: PUSH
47828: LD_INT 5
47830: PUSH
47831: LD_INT 2
47833: PUSH
47834: EMPTY
47835: LIST
47836: LIST
47837: PUSH
47838: LD_INT 3
47840: PUSH
47841: LD_INT 3
47843: PUSH
47844: EMPTY
47845: LIST
47846: LIST
47847: PUSH
47848: LD_INT 3
47850: PUSH
47851: LD_INT 2
47853: PUSH
47854: EMPTY
47855: LIST
47856: LIST
47857: PUSH
47858: LD_INT 4
47860: PUSH
47861: LD_INT 3
47863: PUSH
47864: EMPTY
47865: LIST
47866: LIST
47867: PUSH
47868: LD_INT 4
47870: PUSH
47871: LD_INT 4
47873: PUSH
47874: EMPTY
47875: LIST
47876: LIST
47877: PUSH
47878: LD_INT 3
47880: PUSH
47881: LD_INT 4
47883: PUSH
47884: EMPTY
47885: LIST
47886: LIST
47887: PUSH
47888: LD_INT 2
47890: PUSH
47891: LD_INT 3
47893: PUSH
47894: EMPTY
47895: LIST
47896: LIST
47897: PUSH
47898: LD_INT 2
47900: PUSH
47901: LD_INT 2
47903: PUSH
47904: EMPTY
47905: LIST
47906: LIST
47907: PUSH
47908: LD_INT 4
47910: PUSH
47911: LD_INT 2
47913: PUSH
47914: EMPTY
47915: LIST
47916: LIST
47917: PUSH
47918: LD_INT 2
47920: PUSH
47921: LD_INT 4
47923: PUSH
47924: EMPTY
47925: LIST
47926: LIST
47927: PUSH
47928: LD_INT 0
47930: PUSH
47931: LD_INT 4
47933: PUSH
47934: EMPTY
47935: LIST
47936: LIST
47937: PUSH
47938: LD_INT 0
47940: PUSH
47941: LD_INT 3
47943: PUSH
47944: EMPTY
47945: LIST
47946: LIST
47947: PUSH
47948: LD_INT 1
47950: PUSH
47951: LD_INT 4
47953: PUSH
47954: EMPTY
47955: LIST
47956: LIST
47957: PUSH
47958: LD_INT 1
47960: PUSH
47961: LD_INT 5
47963: PUSH
47964: EMPTY
47965: LIST
47966: LIST
47967: PUSH
47968: LD_INT 0
47970: PUSH
47971: LD_INT 5
47973: PUSH
47974: EMPTY
47975: LIST
47976: LIST
47977: PUSH
47978: LD_INT 1
47980: NEG
47981: PUSH
47982: LD_INT 4
47984: PUSH
47985: EMPTY
47986: LIST
47987: LIST
47988: PUSH
47989: LD_INT 1
47991: NEG
47992: PUSH
47993: LD_INT 3
47995: PUSH
47996: EMPTY
47997: LIST
47998: LIST
47999: PUSH
48000: LD_INT 2
48002: PUSH
48003: LD_INT 5
48005: PUSH
48006: EMPTY
48007: LIST
48008: LIST
48009: PUSH
48010: LD_INT 2
48012: NEG
48013: PUSH
48014: LD_INT 3
48016: PUSH
48017: EMPTY
48018: LIST
48019: LIST
48020: PUSH
48021: LD_INT 3
48023: NEG
48024: PUSH
48025: LD_INT 0
48027: PUSH
48028: EMPTY
48029: LIST
48030: LIST
48031: PUSH
48032: LD_INT 3
48034: NEG
48035: PUSH
48036: LD_INT 1
48038: NEG
48039: PUSH
48040: EMPTY
48041: LIST
48042: LIST
48043: PUSH
48044: LD_INT 2
48046: NEG
48047: PUSH
48048: LD_INT 0
48050: PUSH
48051: EMPTY
48052: LIST
48053: LIST
48054: PUSH
48055: LD_INT 2
48057: NEG
48058: PUSH
48059: LD_INT 1
48061: PUSH
48062: EMPTY
48063: LIST
48064: LIST
48065: PUSH
48066: LD_INT 3
48068: NEG
48069: PUSH
48070: LD_INT 1
48072: PUSH
48073: EMPTY
48074: LIST
48075: LIST
48076: PUSH
48077: LD_INT 4
48079: NEG
48080: PUSH
48081: LD_INT 0
48083: PUSH
48084: EMPTY
48085: LIST
48086: LIST
48087: PUSH
48088: LD_INT 4
48090: NEG
48091: PUSH
48092: LD_INT 1
48094: NEG
48095: PUSH
48096: EMPTY
48097: LIST
48098: LIST
48099: PUSH
48100: LD_INT 4
48102: NEG
48103: PUSH
48104: LD_INT 2
48106: NEG
48107: PUSH
48108: EMPTY
48109: LIST
48110: LIST
48111: PUSH
48112: LD_INT 2
48114: NEG
48115: PUSH
48116: LD_INT 2
48118: PUSH
48119: EMPTY
48120: LIST
48121: LIST
48122: PUSH
48123: LD_INT 4
48125: NEG
48126: PUSH
48127: LD_INT 4
48129: NEG
48130: PUSH
48131: EMPTY
48132: LIST
48133: LIST
48134: PUSH
48135: LD_INT 4
48137: NEG
48138: PUSH
48139: LD_INT 5
48141: NEG
48142: PUSH
48143: EMPTY
48144: LIST
48145: LIST
48146: PUSH
48147: LD_INT 3
48149: NEG
48150: PUSH
48151: LD_INT 4
48153: NEG
48154: PUSH
48155: EMPTY
48156: LIST
48157: LIST
48158: PUSH
48159: LD_INT 3
48161: NEG
48162: PUSH
48163: LD_INT 3
48165: NEG
48166: PUSH
48167: EMPTY
48168: LIST
48169: LIST
48170: PUSH
48171: LD_INT 4
48173: NEG
48174: PUSH
48175: LD_INT 3
48177: NEG
48178: PUSH
48179: EMPTY
48180: LIST
48181: LIST
48182: PUSH
48183: LD_INT 5
48185: NEG
48186: PUSH
48187: LD_INT 4
48189: NEG
48190: PUSH
48191: EMPTY
48192: LIST
48193: LIST
48194: PUSH
48195: LD_INT 5
48197: NEG
48198: PUSH
48199: LD_INT 5
48201: NEG
48202: PUSH
48203: EMPTY
48204: LIST
48205: LIST
48206: PUSH
48207: LD_INT 3
48209: NEG
48210: PUSH
48211: LD_INT 5
48213: NEG
48214: PUSH
48215: EMPTY
48216: LIST
48217: LIST
48218: PUSH
48219: LD_INT 5
48221: NEG
48222: PUSH
48223: LD_INT 3
48225: NEG
48226: PUSH
48227: EMPTY
48228: LIST
48229: LIST
48230: PUSH
48231: EMPTY
48232: LIST
48233: LIST
48234: LIST
48235: LIST
48236: LIST
48237: LIST
48238: LIST
48239: LIST
48240: LIST
48241: LIST
48242: LIST
48243: LIST
48244: LIST
48245: LIST
48246: LIST
48247: LIST
48248: LIST
48249: LIST
48250: LIST
48251: LIST
48252: LIST
48253: LIST
48254: LIST
48255: LIST
48256: LIST
48257: LIST
48258: LIST
48259: LIST
48260: LIST
48261: LIST
48262: LIST
48263: LIST
48264: LIST
48265: LIST
48266: LIST
48267: LIST
48268: LIST
48269: LIST
48270: LIST
48271: LIST
48272: LIST
48273: LIST
48274: LIST
48275: LIST
48276: LIST
48277: ST_TO_ADDR
// fFactory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
48278: LD_ADDR_VAR 0 30
48282: PUSH
48283: LD_INT 4
48285: PUSH
48286: LD_INT 4
48288: PUSH
48289: EMPTY
48290: LIST
48291: LIST
48292: PUSH
48293: LD_INT 4
48295: PUSH
48296: LD_INT 3
48298: PUSH
48299: EMPTY
48300: LIST
48301: LIST
48302: PUSH
48303: LD_INT 5
48305: PUSH
48306: LD_INT 4
48308: PUSH
48309: EMPTY
48310: LIST
48311: LIST
48312: PUSH
48313: LD_INT 5
48315: PUSH
48316: LD_INT 5
48318: PUSH
48319: EMPTY
48320: LIST
48321: LIST
48322: PUSH
48323: LD_INT 4
48325: PUSH
48326: LD_INT 5
48328: PUSH
48329: EMPTY
48330: LIST
48331: LIST
48332: PUSH
48333: LD_INT 3
48335: PUSH
48336: LD_INT 4
48338: PUSH
48339: EMPTY
48340: LIST
48341: LIST
48342: PUSH
48343: LD_INT 3
48345: PUSH
48346: LD_INT 3
48348: PUSH
48349: EMPTY
48350: LIST
48351: LIST
48352: PUSH
48353: LD_INT 5
48355: PUSH
48356: LD_INT 3
48358: PUSH
48359: EMPTY
48360: LIST
48361: LIST
48362: PUSH
48363: LD_INT 3
48365: PUSH
48366: LD_INT 5
48368: PUSH
48369: EMPTY
48370: LIST
48371: LIST
48372: PUSH
48373: LD_INT 0
48375: PUSH
48376: LD_INT 3
48378: PUSH
48379: EMPTY
48380: LIST
48381: LIST
48382: PUSH
48383: LD_INT 0
48385: PUSH
48386: LD_INT 2
48388: PUSH
48389: EMPTY
48390: LIST
48391: LIST
48392: PUSH
48393: LD_INT 1
48395: PUSH
48396: LD_INT 3
48398: PUSH
48399: EMPTY
48400: LIST
48401: LIST
48402: PUSH
48403: LD_INT 1
48405: PUSH
48406: LD_INT 4
48408: PUSH
48409: EMPTY
48410: LIST
48411: LIST
48412: PUSH
48413: LD_INT 0
48415: PUSH
48416: LD_INT 4
48418: PUSH
48419: EMPTY
48420: LIST
48421: LIST
48422: PUSH
48423: LD_INT 1
48425: NEG
48426: PUSH
48427: LD_INT 3
48429: PUSH
48430: EMPTY
48431: LIST
48432: LIST
48433: PUSH
48434: LD_INT 1
48436: NEG
48437: PUSH
48438: LD_INT 2
48440: PUSH
48441: EMPTY
48442: LIST
48443: LIST
48444: PUSH
48445: LD_INT 2
48447: PUSH
48448: LD_INT 4
48450: PUSH
48451: EMPTY
48452: LIST
48453: LIST
48454: PUSH
48455: LD_INT 2
48457: NEG
48458: PUSH
48459: LD_INT 2
48461: PUSH
48462: EMPTY
48463: LIST
48464: LIST
48465: PUSH
48466: LD_INT 4
48468: NEG
48469: PUSH
48470: LD_INT 0
48472: PUSH
48473: EMPTY
48474: LIST
48475: LIST
48476: PUSH
48477: LD_INT 4
48479: NEG
48480: PUSH
48481: LD_INT 1
48483: NEG
48484: PUSH
48485: EMPTY
48486: LIST
48487: LIST
48488: PUSH
48489: LD_INT 3
48491: NEG
48492: PUSH
48493: LD_INT 0
48495: PUSH
48496: EMPTY
48497: LIST
48498: LIST
48499: PUSH
48500: LD_INT 3
48502: NEG
48503: PUSH
48504: LD_INT 1
48506: PUSH
48507: EMPTY
48508: LIST
48509: LIST
48510: PUSH
48511: LD_INT 4
48513: NEG
48514: PUSH
48515: LD_INT 1
48517: PUSH
48518: EMPTY
48519: LIST
48520: LIST
48521: PUSH
48522: LD_INT 5
48524: NEG
48525: PUSH
48526: LD_INT 0
48528: PUSH
48529: EMPTY
48530: LIST
48531: LIST
48532: PUSH
48533: LD_INT 5
48535: NEG
48536: PUSH
48537: LD_INT 1
48539: NEG
48540: PUSH
48541: EMPTY
48542: LIST
48543: LIST
48544: PUSH
48545: LD_INT 5
48547: NEG
48548: PUSH
48549: LD_INT 2
48551: NEG
48552: PUSH
48553: EMPTY
48554: LIST
48555: LIST
48556: PUSH
48557: LD_INT 3
48559: NEG
48560: PUSH
48561: LD_INT 2
48563: PUSH
48564: EMPTY
48565: LIST
48566: LIST
48567: PUSH
48568: LD_INT 3
48570: NEG
48571: PUSH
48572: LD_INT 3
48574: NEG
48575: PUSH
48576: EMPTY
48577: LIST
48578: LIST
48579: PUSH
48580: LD_INT 3
48582: NEG
48583: PUSH
48584: LD_INT 4
48586: NEG
48587: PUSH
48588: EMPTY
48589: LIST
48590: LIST
48591: PUSH
48592: LD_INT 2
48594: NEG
48595: PUSH
48596: LD_INT 3
48598: NEG
48599: PUSH
48600: EMPTY
48601: LIST
48602: LIST
48603: PUSH
48604: LD_INT 2
48606: NEG
48607: PUSH
48608: LD_INT 2
48610: NEG
48611: PUSH
48612: EMPTY
48613: LIST
48614: LIST
48615: PUSH
48616: LD_INT 3
48618: NEG
48619: PUSH
48620: LD_INT 2
48622: NEG
48623: PUSH
48624: EMPTY
48625: LIST
48626: LIST
48627: PUSH
48628: LD_INT 4
48630: NEG
48631: PUSH
48632: LD_INT 3
48634: NEG
48635: PUSH
48636: EMPTY
48637: LIST
48638: LIST
48639: PUSH
48640: LD_INT 4
48642: NEG
48643: PUSH
48644: LD_INT 4
48646: NEG
48647: PUSH
48648: EMPTY
48649: LIST
48650: LIST
48651: PUSH
48652: LD_INT 2
48654: NEG
48655: PUSH
48656: LD_INT 4
48658: NEG
48659: PUSH
48660: EMPTY
48661: LIST
48662: LIST
48663: PUSH
48664: LD_INT 4
48666: NEG
48667: PUSH
48668: LD_INT 2
48670: NEG
48671: PUSH
48672: EMPTY
48673: LIST
48674: LIST
48675: PUSH
48676: LD_INT 0
48678: PUSH
48679: LD_INT 4
48681: NEG
48682: PUSH
48683: EMPTY
48684: LIST
48685: LIST
48686: PUSH
48687: LD_INT 0
48689: PUSH
48690: LD_INT 5
48692: NEG
48693: PUSH
48694: EMPTY
48695: LIST
48696: LIST
48697: PUSH
48698: LD_INT 1
48700: PUSH
48701: LD_INT 4
48703: NEG
48704: PUSH
48705: EMPTY
48706: LIST
48707: LIST
48708: PUSH
48709: LD_INT 1
48711: PUSH
48712: LD_INT 3
48714: NEG
48715: PUSH
48716: EMPTY
48717: LIST
48718: LIST
48719: PUSH
48720: LD_INT 0
48722: PUSH
48723: LD_INT 3
48725: NEG
48726: PUSH
48727: EMPTY
48728: LIST
48729: LIST
48730: PUSH
48731: LD_INT 1
48733: NEG
48734: PUSH
48735: LD_INT 4
48737: NEG
48738: PUSH
48739: EMPTY
48740: LIST
48741: LIST
48742: PUSH
48743: LD_INT 1
48745: NEG
48746: PUSH
48747: LD_INT 5
48749: NEG
48750: PUSH
48751: EMPTY
48752: LIST
48753: LIST
48754: PUSH
48755: LD_INT 2
48757: PUSH
48758: LD_INT 3
48760: NEG
48761: PUSH
48762: EMPTY
48763: LIST
48764: LIST
48765: PUSH
48766: LD_INT 2
48768: NEG
48769: PUSH
48770: LD_INT 5
48772: NEG
48773: PUSH
48774: EMPTY
48775: LIST
48776: LIST
48777: PUSH
48778: EMPTY
48779: LIST
48780: LIST
48781: LIST
48782: LIST
48783: LIST
48784: LIST
48785: LIST
48786: LIST
48787: LIST
48788: LIST
48789: LIST
48790: LIST
48791: LIST
48792: LIST
48793: LIST
48794: LIST
48795: LIST
48796: LIST
48797: LIST
48798: LIST
48799: LIST
48800: LIST
48801: LIST
48802: LIST
48803: LIST
48804: LIST
48805: LIST
48806: LIST
48807: LIST
48808: LIST
48809: LIST
48810: LIST
48811: LIST
48812: LIST
48813: LIST
48814: LIST
48815: LIST
48816: LIST
48817: LIST
48818: LIST
48819: LIST
48820: LIST
48821: LIST
48822: LIST
48823: LIST
48824: ST_TO_ADDR
// fFactory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
48825: LD_ADDR_VAR 0 31
48829: PUSH
48830: LD_INT 0
48832: PUSH
48833: LD_INT 4
48835: PUSH
48836: EMPTY
48837: LIST
48838: LIST
48839: PUSH
48840: LD_INT 0
48842: PUSH
48843: LD_INT 3
48845: PUSH
48846: EMPTY
48847: LIST
48848: LIST
48849: PUSH
48850: LD_INT 1
48852: PUSH
48853: LD_INT 4
48855: PUSH
48856: EMPTY
48857: LIST
48858: LIST
48859: PUSH
48860: LD_INT 1
48862: PUSH
48863: LD_INT 5
48865: PUSH
48866: EMPTY
48867: LIST
48868: LIST
48869: PUSH
48870: LD_INT 0
48872: PUSH
48873: LD_INT 5
48875: PUSH
48876: EMPTY
48877: LIST
48878: LIST
48879: PUSH
48880: LD_INT 1
48882: NEG
48883: PUSH
48884: LD_INT 4
48886: PUSH
48887: EMPTY
48888: LIST
48889: LIST
48890: PUSH
48891: LD_INT 1
48893: NEG
48894: PUSH
48895: LD_INT 3
48897: PUSH
48898: EMPTY
48899: LIST
48900: LIST
48901: PUSH
48902: LD_INT 2
48904: PUSH
48905: LD_INT 5
48907: PUSH
48908: EMPTY
48909: LIST
48910: LIST
48911: PUSH
48912: LD_INT 2
48914: NEG
48915: PUSH
48916: LD_INT 3
48918: PUSH
48919: EMPTY
48920: LIST
48921: LIST
48922: PUSH
48923: LD_INT 3
48925: NEG
48926: PUSH
48927: LD_INT 0
48929: PUSH
48930: EMPTY
48931: LIST
48932: LIST
48933: PUSH
48934: LD_INT 3
48936: NEG
48937: PUSH
48938: LD_INT 1
48940: NEG
48941: PUSH
48942: EMPTY
48943: LIST
48944: LIST
48945: PUSH
48946: LD_INT 2
48948: NEG
48949: PUSH
48950: LD_INT 0
48952: PUSH
48953: EMPTY
48954: LIST
48955: LIST
48956: PUSH
48957: LD_INT 2
48959: NEG
48960: PUSH
48961: LD_INT 1
48963: PUSH
48964: EMPTY
48965: LIST
48966: LIST
48967: PUSH
48968: LD_INT 3
48970: NEG
48971: PUSH
48972: LD_INT 1
48974: PUSH
48975: EMPTY
48976: LIST
48977: LIST
48978: PUSH
48979: LD_INT 4
48981: NEG
48982: PUSH
48983: LD_INT 0
48985: PUSH
48986: EMPTY
48987: LIST
48988: LIST
48989: PUSH
48990: LD_INT 4
48992: NEG
48993: PUSH
48994: LD_INT 1
48996: NEG
48997: PUSH
48998: EMPTY
48999: LIST
49000: LIST
49001: PUSH
49002: LD_INT 4
49004: NEG
49005: PUSH
49006: LD_INT 2
49008: NEG
49009: PUSH
49010: EMPTY
49011: LIST
49012: LIST
49013: PUSH
49014: LD_INT 2
49016: NEG
49017: PUSH
49018: LD_INT 2
49020: PUSH
49021: EMPTY
49022: LIST
49023: LIST
49024: PUSH
49025: LD_INT 4
49027: NEG
49028: PUSH
49029: LD_INT 4
49031: NEG
49032: PUSH
49033: EMPTY
49034: LIST
49035: LIST
49036: PUSH
49037: LD_INT 4
49039: NEG
49040: PUSH
49041: LD_INT 5
49043: NEG
49044: PUSH
49045: EMPTY
49046: LIST
49047: LIST
49048: PUSH
49049: LD_INT 3
49051: NEG
49052: PUSH
49053: LD_INT 4
49055: NEG
49056: PUSH
49057: EMPTY
49058: LIST
49059: LIST
49060: PUSH
49061: LD_INT 3
49063: NEG
49064: PUSH
49065: LD_INT 3
49067: NEG
49068: PUSH
49069: EMPTY
49070: LIST
49071: LIST
49072: PUSH
49073: LD_INT 4
49075: NEG
49076: PUSH
49077: LD_INT 3
49079: NEG
49080: PUSH
49081: EMPTY
49082: LIST
49083: LIST
49084: PUSH
49085: LD_INT 5
49087: NEG
49088: PUSH
49089: LD_INT 4
49091: NEG
49092: PUSH
49093: EMPTY
49094: LIST
49095: LIST
49096: PUSH
49097: LD_INT 5
49099: NEG
49100: PUSH
49101: LD_INT 5
49103: NEG
49104: PUSH
49105: EMPTY
49106: LIST
49107: LIST
49108: PUSH
49109: LD_INT 3
49111: NEG
49112: PUSH
49113: LD_INT 5
49115: NEG
49116: PUSH
49117: EMPTY
49118: LIST
49119: LIST
49120: PUSH
49121: LD_INT 5
49123: NEG
49124: PUSH
49125: LD_INT 3
49127: NEG
49128: PUSH
49129: EMPTY
49130: LIST
49131: LIST
49132: PUSH
49133: LD_INT 0
49135: PUSH
49136: LD_INT 3
49138: NEG
49139: PUSH
49140: EMPTY
49141: LIST
49142: LIST
49143: PUSH
49144: LD_INT 0
49146: PUSH
49147: LD_INT 4
49149: NEG
49150: PUSH
49151: EMPTY
49152: LIST
49153: LIST
49154: PUSH
49155: LD_INT 1
49157: PUSH
49158: LD_INT 3
49160: NEG
49161: PUSH
49162: EMPTY
49163: LIST
49164: LIST
49165: PUSH
49166: LD_INT 1
49168: PUSH
49169: LD_INT 2
49171: NEG
49172: PUSH
49173: EMPTY
49174: LIST
49175: LIST
49176: PUSH
49177: LD_INT 0
49179: PUSH
49180: LD_INT 2
49182: NEG
49183: PUSH
49184: EMPTY
49185: LIST
49186: LIST
49187: PUSH
49188: LD_INT 1
49190: NEG
49191: PUSH
49192: LD_INT 3
49194: NEG
49195: PUSH
49196: EMPTY
49197: LIST
49198: LIST
49199: PUSH
49200: LD_INT 1
49202: NEG
49203: PUSH
49204: LD_INT 4
49206: NEG
49207: PUSH
49208: EMPTY
49209: LIST
49210: LIST
49211: PUSH
49212: LD_INT 2
49214: PUSH
49215: LD_INT 2
49217: NEG
49218: PUSH
49219: EMPTY
49220: LIST
49221: LIST
49222: PUSH
49223: LD_INT 2
49225: NEG
49226: PUSH
49227: LD_INT 4
49229: NEG
49230: PUSH
49231: EMPTY
49232: LIST
49233: LIST
49234: PUSH
49235: LD_INT 4
49237: PUSH
49238: LD_INT 0
49240: PUSH
49241: EMPTY
49242: LIST
49243: LIST
49244: PUSH
49245: LD_INT 4
49247: PUSH
49248: LD_INT 1
49250: NEG
49251: PUSH
49252: EMPTY
49253: LIST
49254: LIST
49255: PUSH
49256: LD_INT 5
49258: PUSH
49259: LD_INT 0
49261: PUSH
49262: EMPTY
49263: LIST
49264: LIST
49265: PUSH
49266: LD_INT 5
49268: PUSH
49269: LD_INT 1
49271: PUSH
49272: EMPTY
49273: LIST
49274: LIST
49275: PUSH
49276: LD_INT 4
49278: PUSH
49279: LD_INT 1
49281: PUSH
49282: EMPTY
49283: LIST
49284: LIST
49285: PUSH
49286: LD_INT 3
49288: PUSH
49289: LD_INT 0
49291: PUSH
49292: EMPTY
49293: LIST
49294: LIST
49295: PUSH
49296: LD_INT 3
49298: PUSH
49299: LD_INT 1
49301: NEG
49302: PUSH
49303: EMPTY
49304: LIST
49305: LIST
49306: PUSH
49307: LD_INT 3
49309: PUSH
49310: LD_INT 2
49312: NEG
49313: PUSH
49314: EMPTY
49315: LIST
49316: LIST
49317: PUSH
49318: LD_INT 5
49320: PUSH
49321: LD_INT 2
49323: PUSH
49324: EMPTY
49325: LIST
49326: LIST
49327: PUSH
49328: EMPTY
49329: LIST
49330: LIST
49331: LIST
49332: LIST
49333: LIST
49334: LIST
49335: LIST
49336: LIST
49337: LIST
49338: LIST
49339: LIST
49340: LIST
49341: LIST
49342: LIST
49343: LIST
49344: LIST
49345: LIST
49346: LIST
49347: LIST
49348: LIST
49349: LIST
49350: LIST
49351: LIST
49352: LIST
49353: LIST
49354: LIST
49355: LIST
49356: LIST
49357: LIST
49358: LIST
49359: LIST
49360: LIST
49361: LIST
49362: LIST
49363: LIST
49364: LIST
49365: LIST
49366: LIST
49367: LIST
49368: LIST
49369: LIST
49370: LIST
49371: LIST
49372: LIST
49373: LIST
49374: ST_TO_ADDR
// fFactory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
49375: LD_ADDR_VAR 0 32
49379: PUSH
49380: LD_INT 4
49382: NEG
49383: PUSH
49384: LD_INT 0
49386: PUSH
49387: EMPTY
49388: LIST
49389: LIST
49390: PUSH
49391: LD_INT 4
49393: NEG
49394: PUSH
49395: LD_INT 1
49397: NEG
49398: PUSH
49399: EMPTY
49400: LIST
49401: LIST
49402: PUSH
49403: LD_INT 3
49405: NEG
49406: PUSH
49407: LD_INT 0
49409: PUSH
49410: EMPTY
49411: LIST
49412: LIST
49413: PUSH
49414: LD_INT 3
49416: NEG
49417: PUSH
49418: LD_INT 1
49420: PUSH
49421: EMPTY
49422: LIST
49423: LIST
49424: PUSH
49425: LD_INT 4
49427: NEG
49428: PUSH
49429: LD_INT 1
49431: PUSH
49432: EMPTY
49433: LIST
49434: LIST
49435: PUSH
49436: LD_INT 5
49438: NEG
49439: PUSH
49440: LD_INT 0
49442: PUSH
49443: EMPTY
49444: LIST
49445: LIST
49446: PUSH
49447: LD_INT 5
49449: NEG
49450: PUSH
49451: LD_INT 1
49453: NEG
49454: PUSH
49455: EMPTY
49456: LIST
49457: LIST
49458: PUSH
49459: LD_INT 5
49461: NEG
49462: PUSH
49463: LD_INT 2
49465: NEG
49466: PUSH
49467: EMPTY
49468: LIST
49469: LIST
49470: PUSH
49471: LD_INT 3
49473: NEG
49474: PUSH
49475: LD_INT 2
49477: PUSH
49478: EMPTY
49479: LIST
49480: LIST
49481: PUSH
49482: LD_INT 3
49484: NEG
49485: PUSH
49486: LD_INT 3
49488: NEG
49489: PUSH
49490: EMPTY
49491: LIST
49492: LIST
49493: PUSH
49494: LD_INT 3
49496: NEG
49497: PUSH
49498: LD_INT 4
49500: NEG
49501: PUSH
49502: EMPTY
49503: LIST
49504: LIST
49505: PUSH
49506: LD_INT 2
49508: NEG
49509: PUSH
49510: LD_INT 3
49512: NEG
49513: PUSH
49514: EMPTY
49515: LIST
49516: LIST
49517: PUSH
49518: LD_INT 2
49520: NEG
49521: PUSH
49522: LD_INT 2
49524: NEG
49525: PUSH
49526: EMPTY
49527: LIST
49528: LIST
49529: PUSH
49530: LD_INT 3
49532: NEG
49533: PUSH
49534: LD_INT 2
49536: NEG
49537: PUSH
49538: EMPTY
49539: LIST
49540: LIST
49541: PUSH
49542: LD_INT 4
49544: NEG
49545: PUSH
49546: LD_INT 3
49548: NEG
49549: PUSH
49550: EMPTY
49551: LIST
49552: LIST
49553: PUSH
49554: LD_INT 4
49556: NEG
49557: PUSH
49558: LD_INT 4
49560: NEG
49561: PUSH
49562: EMPTY
49563: LIST
49564: LIST
49565: PUSH
49566: LD_INT 2
49568: NEG
49569: PUSH
49570: LD_INT 4
49572: NEG
49573: PUSH
49574: EMPTY
49575: LIST
49576: LIST
49577: PUSH
49578: LD_INT 4
49580: NEG
49581: PUSH
49582: LD_INT 2
49584: NEG
49585: PUSH
49586: EMPTY
49587: LIST
49588: LIST
49589: PUSH
49590: LD_INT 0
49592: PUSH
49593: LD_INT 4
49595: NEG
49596: PUSH
49597: EMPTY
49598: LIST
49599: LIST
49600: PUSH
49601: LD_INT 0
49603: PUSH
49604: LD_INT 5
49606: NEG
49607: PUSH
49608: EMPTY
49609: LIST
49610: LIST
49611: PUSH
49612: LD_INT 1
49614: PUSH
49615: LD_INT 4
49617: NEG
49618: PUSH
49619: EMPTY
49620: LIST
49621: LIST
49622: PUSH
49623: LD_INT 1
49625: PUSH
49626: LD_INT 3
49628: NEG
49629: PUSH
49630: EMPTY
49631: LIST
49632: LIST
49633: PUSH
49634: LD_INT 0
49636: PUSH
49637: LD_INT 3
49639: NEG
49640: PUSH
49641: EMPTY
49642: LIST
49643: LIST
49644: PUSH
49645: LD_INT 1
49647: NEG
49648: PUSH
49649: LD_INT 4
49651: NEG
49652: PUSH
49653: EMPTY
49654: LIST
49655: LIST
49656: PUSH
49657: LD_INT 1
49659: NEG
49660: PUSH
49661: LD_INT 5
49663: NEG
49664: PUSH
49665: EMPTY
49666: LIST
49667: LIST
49668: PUSH
49669: LD_INT 2
49671: PUSH
49672: LD_INT 3
49674: NEG
49675: PUSH
49676: EMPTY
49677: LIST
49678: LIST
49679: PUSH
49680: LD_INT 2
49682: NEG
49683: PUSH
49684: LD_INT 5
49686: NEG
49687: PUSH
49688: EMPTY
49689: LIST
49690: LIST
49691: PUSH
49692: LD_INT 3
49694: PUSH
49695: LD_INT 0
49697: PUSH
49698: EMPTY
49699: LIST
49700: LIST
49701: PUSH
49702: LD_INT 3
49704: PUSH
49705: LD_INT 1
49707: NEG
49708: PUSH
49709: EMPTY
49710: LIST
49711: LIST
49712: PUSH
49713: LD_INT 4
49715: PUSH
49716: LD_INT 0
49718: PUSH
49719: EMPTY
49720: LIST
49721: LIST
49722: PUSH
49723: LD_INT 4
49725: PUSH
49726: LD_INT 1
49728: PUSH
49729: EMPTY
49730: LIST
49731: LIST
49732: PUSH
49733: LD_INT 3
49735: PUSH
49736: LD_INT 1
49738: PUSH
49739: EMPTY
49740: LIST
49741: LIST
49742: PUSH
49743: LD_INT 2
49745: PUSH
49746: LD_INT 0
49748: PUSH
49749: EMPTY
49750: LIST
49751: LIST
49752: PUSH
49753: LD_INT 2
49755: PUSH
49756: LD_INT 1
49758: NEG
49759: PUSH
49760: EMPTY
49761: LIST
49762: LIST
49763: PUSH
49764: LD_INT 2
49766: PUSH
49767: LD_INT 2
49769: NEG
49770: PUSH
49771: EMPTY
49772: LIST
49773: LIST
49774: PUSH
49775: LD_INT 4
49777: PUSH
49778: LD_INT 2
49780: PUSH
49781: EMPTY
49782: LIST
49783: LIST
49784: PUSH
49785: LD_INT 4
49787: PUSH
49788: LD_INT 4
49790: PUSH
49791: EMPTY
49792: LIST
49793: LIST
49794: PUSH
49795: LD_INT 4
49797: PUSH
49798: LD_INT 3
49800: PUSH
49801: EMPTY
49802: LIST
49803: LIST
49804: PUSH
49805: LD_INT 5
49807: PUSH
49808: LD_INT 4
49810: PUSH
49811: EMPTY
49812: LIST
49813: LIST
49814: PUSH
49815: LD_INT 5
49817: PUSH
49818: LD_INT 5
49820: PUSH
49821: EMPTY
49822: LIST
49823: LIST
49824: PUSH
49825: LD_INT 4
49827: PUSH
49828: LD_INT 5
49830: PUSH
49831: EMPTY
49832: LIST
49833: LIST
49834: PUSH
49835: LD_INT 3
49837: PUSH
49838: LD_INT 4
49840: PUSH
49841: EMPTY
49842: LIST
49843: LIST
49844: PUSH
49845: LD_INT 3
49847: PUSH
49848: LD_INT 3
49850: PUSH
49851: EMPTY
49852: LIST
49853: LIST
49854: PUSH
49855: LD_INT 5
49857: PUSH
49858: LD_INT 3
49860: PUSH
49861: EMPTY
49862: LIST
49863: LIST
49864: PUSH
49865: LD_INT 3
49867: PUSH
49868: LD_INT 5
49870: PUSH
49871: EMPTY
49872: LIST
49873: LIST
49874: PUSH
49875: EMPTY
49876: LIST
49877: LIST
49878: LIST
49879: LIST
49880: LIST
49881: LIST
49882: LIST
49883: LIST
49884: LIST
49885: LIST
49886: LIST
49887: LIST
49888: LIST
49889: LIST
49890: LIST
49891: LIST
49892: LIST
49893: LIST
49894: LIST
49895: LIST
49896: LIST
49897: LIST
49898: LIST
49899: LIST
49900: LIST
49901: LIST
49902: LIST
49903: LIST
49904: LIST
49905: LIST
49906: LIST
49907: LIST
49908: LIST
49909: LIST
49910: LIST
49911: LIST
49912: LIST
49913: LIST
49914: LIST
49915: LIST
49916: LIST
49917: LIST
49918: LIST
49919: LIST
49920: LIST
49921: ST_TO_ADDR
// fFactory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
49922: LD_ADDR_VAR 0 33
49926: PUSH
49927: LD_INT 4
49929: NEG
49930: PUSH
49931: LD_INT 4
49933: NEG
49934: PUSH
49935: EMPTY
49936: LIST
49937: LIST
49938: PUSH
49939: LD_INT 4
49941: NEG
49942: PUSH
49943: LD_INT 5
49945: NEG
49946: PUSH
49947: EMPTY
49948: LIST
49949: LIST
49950: PUSH
49951: LD_INT 3
49953: NEG
49954: PUSH
49955: LD_INT 4
49957: NEG
49958: PUSH
49959: EMPTY
49960: LIST
49961: LIST
49962: PUSH
49963: LD_INT 3
49965: NEG
49966: PUSH
49967: LD_INT 3
49969: NEG
49970: PUSH
49971: EMPTY
49972: LIST
49973: LIST
49974: PUSH
49975: LD_INT 4
49977: NEG
49978: PUSH
49979: LD_INT 3
49981: NEG
49982: PUSH
49983: EMPTY
49984: LIST
49985: LIST
49986: PUSH
49987: LD_INT 5
49989: NEG
49990: PUSH
49991: LD_INT 4
49993: NEG
49994: PUSH
49995: EMPTY
49996: LIST
49997: LIST
49998: PUSH
49999: LD_INT 5
50001: NEG
50002: PUSH
50003: LD_INT 5
50005: NEG
50006: PUSH
50007: EMPTY
50008: LIST
50009: LIST
50010: PUSH
50011: LD_INT 3
50013: NEG
50014: PUSH
50015: LD_INT 5
50017: NEG
50018: PUSH
50019: EMPTY
50020: LIST
50021: LIST
50022: PUSH
50023: LD_INT 5
50025: NEG
50026: PUSH
50027: LD_INT 3
50029: NEG
50030: PUSH
50031: EMPTY
50032: LIST
50033: LIST
50034: PUSH
50035: LD_INT 0
50037: PUSH
50038: LD_INT 3
50040: NEG
50041: PUSH
50042: EMPTY
50043: LIST
50044: LIST
50045: PUSH
50046: LD_INT 0
50048: PUSH
50049: LD_INT 4
50051: NEG
50052: PUSH
50053: EMPTY
50054: LIST
50055: LIST
50056: PUSH
50057: LD_INT 1
50059: PUSH
50060: LD_INT 3
50062: NEG
50063: PUSH
50064: EMPTY
50065: LIST
50066: LIST
50067: PUSH
50068: LD_INT 1
50070: PUSH
50071: LD_INT 2
50073: NEG
50074: PUSH
50075: EMPTY
50076: LIST
50077: LIST
50078: PUSH
50079: LD_INT 0
50081: PUSH
50082: LD_INT 2
50084: NEG
50085: PUSH
50086: EMPTY
50087: LIST
50088: LIST
50089: PUSH
50090: LD_INT 1
50092: NEG
50093: PUSH
50094: LD_INT 3
50096: NEG
50097: PUSH
50098: EMPTY
50099: LIST
50100: LIST
50101: PUSH
50102: LD_INT 1
50104: NEG
50105: PUSH
50106: LD_INT 4
50108: NEG
50109: PUSH
50110: EMPTY
50111: LIST
50112: LIST
50113: PUSH
50114: LD_INT 2
50116: PUSH
50117: LD_INT 2
50119: NEG
50120: PUSH
50121: EMPTY
50122: LIST
50123: LIST
50124: PUSH
50125: LD_INT 2
50127: NEG
50128: PUSH
50129: LD_INT 4
50131: NEG
50132: PUSH
50133: EMPTY
50134: LIST
50135: LIST
50136: PUSH
50137: LD_INT 4
50139: PUSH
50140: LD_INT 0
50142: PUSH
50143: EMPTY
50144: LIST
50145: LIST
50146: PUSH
50147: LD_INT 4
50149: PUSH
50150: LD_INT 1
50152: NEG
50153: PUSH
50154: EMPTY
50155: LIST
50156: LIST
50157: PUSH
50158: LD_INT 5
50160: PUSH
50161: LD_INT 0
50163: PUSH
50164: EMPTY
50165: LIST
50166: LIST
50167: PUSH
50168: LD_INT 5
50170: PUSH
50171: LD_INT 1
50173: PUSH
50174: EMPTY
50175: LIST
50176: LIST
50177: PUSH
50178: LD_INT 4
50180: PUSH
50181: LD_INT 1
50183: PUSH
50184: EMPTY
50185: LIST
50186: LIST
50187: PUSH
50188: LD_INT 3
50190: PUSH
50191: LD_INT 0
50193: PUSH
50194: EMPTY
50195: LIST
50196: LIST
50197: PUSH
50198: LD_INT 3
50200: PUSH
50201: LD_INT 1
50203: NEG
50204: PUSH
50205: EMPTY
50206: LIST
50207: LIST
50208: PUSH
50209: LD_INT 3
50211: PUSH
50212: LD_INT 2
50214: NEG
50215: PUSH
50216: EMPTY
50217: LIST
50218: LIST
50219: PUSH
50220: LD_INT 5
50222: PUSH
50223: LD_INT 2
50225: PUSH
50226: EMPTY
50227: LIST
50228: LIST
50229: PUSH
50230: LD_INT 3
50232: PUSH
50233: LD_INT 3
50235: PUSH
50236: EMPTY
50237: LIST
50238: LIST
50239: PUSH
50240: LD_INT 3
50242: PUSH
50243: LD_INT 2
50245: PUSH
50246: EMPTY
50247: LIST
50248: LIST
50249: PUSH
50250: LD_INT 4
50252: PUSH
50253: LD_INT 3
50255: PUSH
50256: EMPTY
50257: LIST
50258: LIST
50259: PUSH
50260: LD_INT 4
50262: PUSH
50263: LD_INT 4
50265: PUSH
50266: EMPTY
50267: LIST
50268: LIST
50269: PUSH
50270: LD_INT 3
50272: PUSH
50273: LD_INT 4
50275: PUSH
50276: EMPTY
50277: LIST
50278: LIST
50279: PUSH
50280: LD_INT 2
50282: PUSH
50283: LD_INT 3
50285: PUSH
50286: EMPTY
50287: LIST
50288: LIST
50289: PUSH
50290: LD_INT 2
50292: PUSH
50293: LD_INT 2
50295: PUSH
50296: EMPTY
50297: LIST
50298: LIST
50299: PUSH
50300: LD_INT 4
50302: PUSH
50303: LD_INT 2
50305: PUSH
50306: EMPTY
50307: LIST
50308: LIST
50309: PUSH
50310: LD_INT 2
50312: PUSH
50313: LD_INT 4
50315: PUSH
50316: EMPTY
50317: LIST
50318: LIST
50319: PUSH
50320: LD_INT 0
50322: PUSH
50323: LD_INT 4
50325: PUSH
50326: EMPTY
50327: LIST
50328: LIST
50329: PUSH
50330: LD_INT 0
50332: PUSH
50333: LD_INT 3
50335: PUSH
50336: EMPTY
50337: LIST
50338: LIST
50339: PUSH
50340: LD_INT 1
50342: PUSH
50343: LD_INT 4
50345: PUSH
50346: EMPTY
50347: LIST
50348: LIST
50349: PUSH
50350: LD_INT 1
50352: PUSH
50353: LD_INT 5
50355: PUSH
50356: EMPTY
50357: LIST
50358: LIST
50359: PUSH
50360: LD_INT 0
50362: PUSH
50363: LD_INT 5
50365: PUSH
50366: EMPTY
50367: LIST
50368: LIST
50369: PUSH
50370: LD_INT 1
50372: NEG
50373: PUSH
50374: LD_INT 4
50376: PUSH
50377: EMPTY
50378: LIST
50379: LIST
50380: PUSH
50381: LD_INT 1
50383: NEG
50384: PUSH
50385: LD_INT 3
50387: PUSH
50388: EMPTY
50389: LIST
50390: LIST
50391: PUSH
50392: LD_INT 2
50394: PUSH
50395: LD_INT 5
50397: PUSH
50398: EMPTY
50399: LIST
50400: LIST
50401: PUSH
50402: LD_INT 2
50404: NEG
50405: PUSH
50406: LD_INT 3
50408: PUSH
50409: EMPTY
50410: LIST
50411: LIST
50412: PUSH
50413: EMPTY
50414: LIST
50415: LIST
50416: LIST
50417: LIST
50418: LIST
50419: LIST
50420: LIST
50421: LIST
50422: LIST
50423: LIST
50424: LIST
50425: LIST
50426: LIST
50427: LIST
50428: LIST
50429: LIST
50430: LIST
50431: LIST
50432: LIST
50433: LIST
50434: LIST
50435: LIST
50436: LIST
50437: LIST
50438: LIST
50439: LIST
50440: LIST
50441: LIST
50442: LIST
50443: LIST
50444: LIST
50445: LIST
50446: LIST
50447: LIST
50448: LIST
50449: LIST
50450: LIST
50451: LIST
50452: LIST
50453: LIST
50454: LIST
50455: LIST
50456: LIST
50457: LIST
50458: LIST
50459: ST_TO_ADDR
// fFactory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
50460: LD_ADDR_VAR 0 34
50464: PUSH
50465: LD_INT 0
50467: PUSH
50468: LD_INT 4
50470: NEG
50471: PUSH
50472: EMPTY
50473: LIST
50474: LIST
50475: PUSH
50476: LD_INT 0
50478: PUSH
50479: LD_INT 5
50481: NEG
50482: PUSH
50483: EMPTY
50484: LIST
50485: LIST
50486: PUSH
50487: LD_INT 1
50489: PUSH
50490: LD_INT 4
50492: NEG
50493: PUSH
50494: EMPTY
50495: LIST
50496: LIST
50497: PUSH
50498: LD_INT 1
50500: PUSH
50501: LD_INT 3
50503: NEG
50504: PUSH
50505: EMPTY
50506: LIST
50507: LIST
50508: PUSH
50509: LD_INT 0
50511: PUSH
50512: LD_INT 3
50514: NEG
50515: PUSH
50516: EMPTY
50517: LIST
50518: LIST
50519: PUSH
50520: LD_INT 1
50522: NEG
50523: PUSH
50524: LD_INT 4
50526: NEG
50527: PUSH
50528: EMPTY
50529: LIST
50530: LIST
50531: PUSH
50532: LD_INT 1
50534: NEG
50535: PUSH
50536: LD_INT 5
50538: NEG
50539: PUSH
50540: EMPTY
50541: LIST
50542: LIST
50543: PUSH
50544: LD_INT 2
50546: PUSH
50547: LD_INT 3
50549: NEG
50550: PUSH
50551: EMPTY
50552: LIST
50553: LIST
50554: PUSH
50555: LD_INT 2
50557: NEG
50558: PUSH
50559: LD_INT 5
50561: NEG
50562: PUSH
50563: EMPTY
50564: LIST
50565: LIST
50566: PUSH
50567: LD_INT 3
50569: PUSH
50570: LD_INT 0
50572: PUSH
50573: EMPTY
50574: LIST
50575: LIST
50576: PUSH
50577: LD_INT 3
50579: PUSH
50580: LD_INT 1
50582: NEG
50583: PUSH
50584: EMPTY
50585: LIST
50586: LIST
50587: PUSH
50588: LD_INT 4
50590: PUSH
50591: LD_INT 0
50593: PUSH
50594: EMPTY
50595: LIST
50596: LIST
50597: PUSH
50598: LD_INT 4
50600: PUSH
50601: LD_INT 1
50603: PUSH
50604: EMPTY
50605: LIST
50606: LIST
50607: PUSH
50608: LD_INT 3
50610: PUSH
50611: LD_INT 1
50613: PUSH
50614: EMPTY
50615: LIST
50616: LIST
50617: PUSH
50618: LD_INT 2
50620: PUSH
50621: LD_INT 0
50623: PUSH
50624: EMPTY
50625: LIST
50626: LIST
50627: PUSH
50628: LD_INT 2
50630: PUSH
50631: LD_INT 1
50633: NEG
50634: PUSH
50635: EMPTY
50636: LIST
50637: LIST
50638: PUSH
50639: LD_INT 2
50641: PUSH
50642: LD_INT 2
50644: NEG
50645: PUSH
50646: EMPTY
50647: LIST
50648: LIST
50649: PUSH
50650: LD_INT 4
50652: PUSH
50653: LD_INT 2
50655: PUSH
50656: EMPTY
50657: LIST
50658: LIST
50659: PUSH
50660: LD_INT 4
50662: PUSH
50663: LD_INT 4
50665: PUSH
50666: EMPTY
50667: LIST
50668: LIST
50669: PUSH
50670: LD_INT 4
50672: PUSH
50673: LD_INT 3
50675: PUSH
50676: EMPTY
50677: LIST
50678: LIST
50679: PUSH
50680: LD_INT 5
50682: PUSH
50683: LD_INT 4
50685: PUSH
50686: EMPTY
50687: LIST
50688: LIST
50689: PUSH
50690: LD_INT 5
50692: PUSH
50693: LD_INT 5
50695: PUSH
50696: EMPTY
50697: LIST
50698: LIST
50699: PUSH
50700: LD_INT 4
50702: PUSH
50703: LD_INT 5
50705: PUSH
50706: EMPTY
50707: LIST
50708: LIST
50709: PUSH
50710: LD_INT 3
50712: PUSH
50713: LD_INT 4
50715: PUSH
50716: EMPTY
50717: LIST
50718: LIST
50719: PUSH
50720: LD_INT 3
50722: PUSH
50723: LD_INT 3
50725: PUSH
50726: EMPTY
50727: LIST
50728: LIST
50729: PUSH
50730: LD_INT 5
50732: PUSH
50733: LD_INT 3
50735: PUSH
50736: EMPTY
50737: LIST
50738: LIST
50739: PUSH
50740: LD_INT 3
50742: PUSH
50743: LD_INT 5
50745: PUSH
50746: EMPTY
50747: LIST
50748: LIST
50749: PUSH
50750: LD_INT 0
50752: PUSH
50753: LD_INT 3
50755: PUSH
50756: EMPTY
50757: LIST
50758: LIST
50759: PUSH
50760: LD_INT 0
50762: PUSH
50763: LD_INT 2
50765: PUSH
50766: EMPTY
50767: LIST
50768: LIST
50769: PUSH
50770: LD_INT 1
50772: PUSH
50773: LD_INT 3
50775: PUSH
50776: EMPTY
50777: LIST
50778: LIST
50779: PUSH
50780: LD_INT 1
50782: PUSH
50783: LD_INT 4
50785: PUSH
50786: EMPTY
50787: LIST
50788: LIST
50789: PUSH
50790: LD_INT 0
50792: PUSH
50793: LD_INT 4
50795: PUSH
50796: EMPTY
50797: LIST
50798: LIST
50799: PUSH
50800: LD_INT 1
50802: NEG
50803: PUSH
50804: LD_INT 3
50806: PUSH
50807: EMPTY
50808: LIST
50809: LIST
50810: PUSH
50811: LD_INT 1
50813: NEG
50814: PUSH
50815: LD_INT 2
50817: PUSH
50818: EMPTY
50819: LIST
50820: LIST
50821: PUSH
50822: LD_INT 2
50824: PUSH
50825: LD_INT 4
50827: PUSH
50828: EMPTY
50829: LIST
50830: LIST
50831: PUSH
50832: LD_INT 2
50834: NEG
50835: PUSH
50836: LD_INT 2
50838: PUSH
50839: EMPTY
50840: LIST
50841: LIST
50842: PUSH
50843: LD_INT 4
50845: NEG
50846: PUSH
50847: LD_INT 0
50849: PUSH
50850: EMPTY
50851: LIST
50852: LIST
50853: PUSH
50854: LD_INT 4
50856: NEG
50857: PUSH
50858: LD_INT 1
50860: NEG
50861: PUSH
50862: EMPTY
50863: LIST
50864: LIST
50865: PUSH
50866: LD_INT 3
50868: NEG
50869: PUSH
50870: LD_INT 0
50872: PUSH
50873: EMPTY
50874: LIST
50875: LIST
50876: PUSH
50877: LD_INT 3
50879: NEG
50880: PUSH
50881: LD_INT 1
50883: PUSH
50884: EMPTY
50885: LIST
50886: LIST
50887: PUSH
50888: LD_INT 4
50890: NEG
50891: PUSH
50892: LD_INT 1
50894: PUSH
50895: EMPTY
50896: LIST
50897: LIST
50898: PUSH
50899: LD_INT 5
50901: NEG
50902: PUSH
50903: LD_INT 0
50905: PUSH
50906: EMPTY
50907: LIST
50908: LIST
50909: PUSH
50910: LD_INT 5
50912: NEG
50913: PUSH
50914: LD_INT 1
50916: NEG
50917: PUSH
50918: EMPTY
50919: LIST
50920: LIST
50921: PUSH
50922: LD_INT 5
50924: NEG
50925: PUSH
50926: LD_INT 2
50928: NEG
50929: PUSH
50930: EMPTY
50931: LIST
50932: LIST
50933: PUSH
50934: LD_INT 3
50936: NEG
50937: PUSH
50938: LD_INT 2
50940: PUSH
50941: EMPTY
50942: LIST
50943: LIST
50944: PUSH
50945: EMPTY
50946: LIST
50947: LIST
50948: LIST
50949: LIST
50950: LIST
50951: LIST
50952: LIST
50953: LIST
50954: LIST
50955: LIST
50956: LIST
50957: LIST
50958: LIST
50959: LIST
50960: LIST
50961: LIST
50962: LIST
50963: LIST
50964: LIST
50965: LIST
50966: LIST
50967: LIST
50968: LIST
50969: LIST
50970: LIST
50971: LIST
50972: LIST
50973: LIST
50974: LIST
50975: LIST
50976: LIST
50977: LIST
50978: LIST
50979: LIST
50980: LIST
50981: LIST
50982: LIST
50983: LIST
50984: LIST
50985: LIST
50986: LIST
50987: LIST
50988: LIST
50989: LIST
50990: LIST
50991: ST_TO_ADDR
// end ; end ;
50992: GO 50995
50994: POP
// case btype of b_depot , b_warehouse :
50995: LD_VAR 0 1
50999: PUSH
51000: LD_INT 0
51002: DOUBLE
51003: EQUAL
51004: IFTRUE 51014
51006: LD_INT 1
51008: DOUBLE
51009: EQUAL
51010: IFTRUE 51014
51012: GO 51215
51014: POP
// case nation of nation_american :
51015: LD_VAR 0 5
51019: PUSH
51020: LD_INT 1
51022: DOUBLE
51023: EQUAL
51024: IFTRUE 51028
51026: GO 51084
51028: POP
// temp_list = [ fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 ] [ dir + 1 ] ; nation_arabian :
51029: LD_ADDR_VAR 0 9
51033: PUSH
51034: LD_VAR 0 11
51038: PUSH
51039: LD_VAR 0 12
51043: PUSH
51044: LD_VAR 0 13
51048: PUSH
51049: LD_VAR 0 14
51053: PUSH
51054: LD_VAR 0 15
51058: PUSH
51059: LD_VAR 0 16
51063: PUSH
51064: EMPTY
51065: LIST
51066: LIST
51067: LIST
51068: LIST
51069: LIST
51070: LIST
51071: PUSH
51072: LD_VAR 0 4
51076: PUSH
51077: LD_INT 1
51079: PLUS
51080: ARRAY
51081: ST_TO_ADDR
51082: GO 51213
51084: LD_INT 2
51086: DOUBLE
51087: EQUAL
51088: IFTRUE 51092
51090: GO 51148
51092: POP
// temp_list = [ fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 ] [ dir + 1 ] ; nation_russian :
51093: LD_ADDR_VAR 0 9
51097: PUSH
51098: LD_VAR 0 17
51102: PUSH
51103: LD_VAR 0 18
51107: PUSH
51108: LD_VAR 0 19
51112: PUSH
51113: LD_VAR 0 20
51117: PUSH
51118: LD_VAR 0 21
51122: PUSH
51123: LD_VAR 0 22
51127: PUSH
51128: EMPTY
51129: LIST
51130: LIST
51131: LIST
51132: LIST
51133: LIST
51134: LIST
51135: PUSH
51136: LD_VAR 0 4
51140: PUSH
51141: LD_INT 1
51143: PLUS
51144: ARRAY
51145: ST_TO_ADDR
51146: GO 51213
51148: LD_INT 3
51150: DOUBLE
51151: EQUAL
51152: IFTRUE 51156
51154: GO 51212
51156: POP
// temp_list = [ fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
51157: LD_ADDR_VAR 0 9
51161: PUSH
51162: LD_VAR 0 23
51166: PUSH
51167: LD_VAR 0 24
51171: PUSH
51172: LD_VAR 0 25
51176: PUSH
51177: LD_VAR 0 26
51181: PUSH
51182: LD_VAR 0 27
51186: PUSH
51187: LD_VAR 0 28
51191: PUSH
51192: EMPTY
51193: LIST
51194: LIST
51195: LIST
51196: LIST
51197: LIST
51198: LIST
51199: PUSH
51200: LD_VAR 0 4
51204: PUSH
51205: LD_INT 1
51207: PLUS
51208: ARRAY
51209: ST_TO_ADDR
51210: GO 51213
51212: POP
51213: GO 51768
51215: LD_INT 2
51217: DOUBLE
51218: EQUAL
51219: IFTRUE 51229
51221: LD_INT 3
51223: DOUBLE
51224: EQUAL
51225: IFTRUE 51229
51227: GO 51285
51229: POP
// temp_list = [ fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
51230: LD_ADDR_VAR 0 9
51234: PUSH
51235: LD_VAR 0 29
51239: PUSH
51240: LD_VAR 0 30
51244: PUSH
51245: LD_VAR 0 31
51249: PUSH
51250: LD_VAR 0 32
51254: PUSH
51255: LD_VAR 0 33
51259: PUSH
51260: LD_VAR 0 34
51264: PUSH
51265: EMPTY
51266: LIST
51267: LIST
51268: LIST
51269: LIST
51270: LIST
51271: LIST
51272: PUSH
51273: LD_VAR 0 4
51277: PUSH
51278: LD_INT 1
51280: PLUS
51281: ARRAY
51282: ST_TO_ADDR
51283: GO 51768
51285: LD_INT 16
51287: DOUBLE
51288: EQUAL
51289: IFTRUE 51347
51291: LD_INT 17
51293: DOUBLE
51294: EQUAL
51295: IFTRUE 51347
51297: LD_INT 18
51299: DOUBLE
51300: EQUAL
51301: IFTRUE 51347
51303: LD_INT 19
51305: DOUBLE
51306: EQUAL
51307: IFTRUE 51347
51309: LD_INT 22
51311: DOUBLE
51312: EQUAL
51313: IFTRUE 51347
51315: LD_INT 20
51317: DOUBLE
51318: EQUAL
51319: IFTRUE 51347
51321: LD_INT 21
51323: DOUBLE
51324: EQUAL
51325: IFTRUE 51347
51327: LD_INT 23
51329: DOUBLE
51330: EQUAL
51331: IFTRUE 51347
51333: LD_INT 24
51335: DOUBLE
51336: EQUAL
51337: IFTRUE 51347
51339: LD_INT 25
51341: DOUBLE
51342: EQUAL
51343: IFTRUE 51347
51345: GO 51403
51347: POP
// temp_list = [ fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
51348: LD_ADDR_VAR 0 9
51352: PUSH
51353: LD_VAR 0 35
51357: PUSH
51358: LD_VAR 0 36
51362: PUSH
51363: LD_VAR 0 37
51367: PUSH
51368: LD_VAR 0 38
51372: PUSH
51373: LD_VAR 0 39
51377: PUSH
51378: LD_VAR 0 40
51382: PUSH
51383: EMPTY
51384: LIST
51385: LIST
51386: LIST
51387: LIST
51388: LIST
51389: LIST
51390: PUSH
51391: LD_VAR 0 4
51395: PUSH
51396: LD_INT 1
51398: PLUS
51399: ARRAY
51400: ST_TO_ADDR
51401: GO 51768
51403: LD_INT 6
51405: DOUBLE
51406: EQUAL
51407: IFTRUE 51459
51409: LD_INT 7
51411: DOUBLE
51412: EQUAL
51413: IFTRUE 51459
51415: LD_INT 8
51417: DOUBLE
51418: EQUAL
51419: IFTRUE 51459
51421: LD_INT 13
51423: DOUBLE
51424: EQUAL
51425: IFTRUE 51459
51427: LD_INT 12
51429: DOUBLE
51430: EQUAL
51431: IFTRUE 51459
51433: LD_INT 15
51435: DOUBLE
51436: EQUAL
51437: IFTRUE 51459
51439: LD_INT 11
51441: DOUBLE
51442: EQUAL
51443: IFTRUE 51459
51445: LD_INT 14
51447: DOUBLE
51448: EQUAL
51449: IFTRUE 51459
51451: LD_INT 10
51453: DOUBLE
51454: EQUAL
51455: IFTRUE 51459
51457: GO 51515
51459: POP
// temp_list = [ fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 ] [ dir + 1 ] ; b_control_tower :
51460: LD_ADDR_VAR 0 9
51464: PUSH
51465: LD_VAR 0 41
51469: PUSH
51470: LD_VAR 0 42
51474: PUSH
51475: LD_VAR 0 43
51479: PUSH
51480: LD_VAR 0 44
51484: PUSH
51485: LD_VAR 0 45
51489: PUSH
51490: LD_VAR 0 46
51494: PUSH
51495: EMPTY
51496: LIST
51497: LIST
51498: LIST
51499: LIST
51500: LIST
51501: LIST
51502: PUSH
51503: LD_VAR 0 4
51507: PUSH
51508: LD_INT 1
51510: PLUS
51511: ARRAY
51512: ST_TO_ADDR
51513: GO 51768
51515: LD_INT 36
51517: DOUBLE
51518: EQUAL
51519: IFTRUE 51523
51521: GO 51579
51523: POP
// temp_list = [ fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
51524: LD_ADDR_VAR 0 9
51528: PUSH
51529: LD_VAR 0 47
51533: PUSH
51534: LD_VAR 0 48
51538: PUSH
51539: LD_VAR 0 49
51543: PUSH
51544: LD_VAR 0 50
51548: PUSH
51549: LD_VAR 0 51
51553: PUSH
51554: LD_VAR 0 52
51558: PUSH
51559: EMPTY
51560: LIST
51561: LIST
51562: LIST
51563: LIST
51564: LIST
51565: LIST
51566: PUSH
51567: LD_VAR 0 4
51571: PUSH
51572: LD_INT 1
51574: PLUS
51575: ARRAY
51576: ST_TO_ADDR
51577: GO 51768
51579: LD_INT 4
51581: DOUBLE
51582: EQUAL
51583: IFTRUE 51605
51585: LD_INT 5
51587: DOUBLE
51588: EQUAL
51589: IFTRUE 51605
51591: LD_INT 34
51593: DOUBLE
51594: EQUAL
51595: IFTRUE 51605
51597: LD_INT 37
51599: DOUBLE
51600: EQUAL
51601: IFTRUE 51605
51603: GO 51661
51605: POP
// temp_list = [ fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
51606: LD_ADDR_VAR 0 9
51610: PUSH
51611: LD_VAR 0 53
51615: PUSH
51616: LD_VAR 0 54
51620: PUSH
51621: LD_VAR 0 55
51625: PUSH
51626: LD_VAR 0 56
51630: PUSH
51631: LD_VAR 0 57
51635: PUSH
51636: LD_VAR 0 58
51640: PUSH
51641: EMPTY
51642: LIST
51643: LIST
51644: LIST
51645: LIST
51646: LIST
51647: LIST
51648: PUSH
51649: LD_VAR 0 4
51653: PUSH
51654: LD_INT 1
51656: PLUS
51657: ARRAY
51658: ST_TO_ADDR
51659: GO 51768
51661: LD_INT 31
51663: DOUBLE
51664: EQUAL
51665: IFTRUE 51711
51667: LD_INT 32
51669: DOUBLE
51670: EQUAL
51671: IFTRUE 51711
51673: LD_INT 33
51675: DOUBLE
51676: EQUAL
51677: IFTRUE 51711
51679: LD_INT 27
51681: DOUBLE
51682: EQUAL
51683: IFTRUE 51711
51685: LD_INT 26
51687: DOUBLE
51688: EQUAL
51689: IFTRUE 51711
51691: LD_INT 28
51693: DOUBLE
51694: EQUAL
51695: IFTRUE 51711
51697: LD_INT 29
51699: DOUBLE
51700: EQUAL
51701: IFTRUE 51711
51703: LD_INT 30
51705: DOUBLE
51706: EQUAL
51707: IFTRUE 51711
51709: GO 51767
51711: POP
// temp_list = [ fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ] [ dir + 1 ] ; end ;
51712: LD_ADDR_VAR 0 9
51716: PUSH
51717: LD_VAR 0 59
51721: PUSH
51722: LD_VAR 0 60
51726: PUSH
51727: LD_VAR 0 61
51731: PUSH
51732: LD_VAR 0 62
51736: PUSH
51737: LD_VAR 0 63
51741: PUSH
51742: LD_VAR 0 64
51746: PUSH
51747: EMPTY
51748: LIST
51749: LIST
51750: LIST
51751: LIST
51752: LIST
51753: LIST
51754: PUSH
51755: LD_VAR 0 4
51759: PUSH
51760: LD_INT 1
51762: PLUS
51763: ARRAY
51764: ST_TO_ADDR
51765: GO 51768
51767: POP
// temp_list2 = [ ] ;
51768: LD_ADDR_VAR 0 10
51772: PUSH
51773: EMPTY
51774: ST_TO_ADDR
// for i in temp_list do
51775: LD_ADDR_VAR 0 8
51779: PUSH
51780: LD_VAR 0 9
51784: PUSH
51785: FOR_IN
51786: IFFALSE 51838
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
51788: LD_ADDR_VAR 0 10
51792: PUSH
51793: LD_VAR 0 10
51797: PUSH
51798: LD_VAR 0 8
51802: PUSH
51803: LD_INT 1
51805: ARRAY
51806: PUSH
51807: LD_VAR 0 2
51811: PLUS
51812: PUSH
51813: LD_VAR 0 8
51817: PUSH
51818: LD_INT 2
51820: ARRAY
51821: PUSH
51822: LD_VAR 0 3
51826: PLUS
51827: PUSH
51828: EMPTY
51829: LIST
51830: LIST
51831: PUSH
51832: EMPTY
51833: LIST
51834: ADD
51835: ST_TO_ADDR
51836: GO 51785
51838: POP
51839: POP
// result = temp_list2 ;
51840: LD_ADDR_VAR 0 7
51844: PUSH
51845: LD_VAR 0 10
51849: ST_TO_ADDR
// end ;
51850: LD_VAR 0 7
51854: RET
// export function EnemyInRange ( unit , dist ) ; begin
51855: LD_INT 0
51857: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
51858: LD_ADDR_VAR 0 3
51862: PUSH
51863: LD_VAR 0 1
51867: PPUSH
51868: CALL_OW 255
51872: PPUSH
51873: LD_VAR 0 1
51877: PPUSH
51878: CALL_OW 250
51882: PPUSH
51883: LD_VAR 0 1
51887: PPUSH
51888: CALL_OW 251
51892: PPUSH
51893: LD_VAR 0 2
51897: PPUSH
51898: CALL 25257 0 4
51902: PUSH
51903: LD_INT 4
51905: ARRAY
51906: ST_TO_ADDR
// end ;
51907: LD_VAR 0 3
51911: RET
// export function PlayerSeeMe ( unit ) ; begin
51912: LD_INT 0
51914: PPUSH
// result := See ( your_side , unit ) ;
51915: LD_ADDR_VAR 0 2
51919: PUSH
51920: LD_OWVAR 2
51924: PPUSH
51925: LD_VAR 0 1
51929: PPUSH
51930: CALL_OW 292
51934: ST_TO_ADDR
// end ;
51935: LD_VAR 0 2
51939: RET
// export function ReverseDir ( unit ) ; begin
51940: LD_INT 0
51942: PPUSH
// if not unit then
51943: LD_VAR 0 1
51947: NOT
51948: IFFALSE 51952
// exit ;
51950: GO 51975
// result := ( GetDir ( unit ) + 3 ) mod 6 ;
51952: LD_ADDR_VAR 0 2
51956: PUSH
51957: LD_VAR 0 1
51961: PPUSH
51962: CALL_OW 254
51966: PUSH
51967: LD_INT 3
51969: PLUS
51970: PUSH
51971: LD_INT 6
51973: MOD
51974: ST_TO_ADDR
// end ;
51975: LD_VAR 0 2
51979: RET
// export function ReverseArray ( array ) ; var i ; begin
51980: LD_INT 0
51982: PPUSH
51983: PPUSH
// if not array then
51984: LD_VAR 0 1
51988: NOT
51989: IFFALSE 51993
// exit ;
51991: GO 52048
// result := [ ] ;
51993: LD_ADDR_VAR 0 2
51997: PUSH
51998: EMPTY
51999: ST_TO_ADDR
// for i := array downto 1 do
52000: LD_ADDR_VAR 0 3
52004: PUSH
52005: DOUBLE
52006: LD_VAR 0 1
52010: INC
52011: ST_TO_ADDR
52012: LD_INT 1
52014: PUSH
52015: FOR_DOWNTO
52016: IFFALSE 52046
// result := Join ( result , array [ i ] ) ;
52018: LD_ADDR_VAR 0 2
52022: PUSH
52023: LD_VAR 0 2
52027: PPUSH
52028: LD_VAR 0 1
52032: PUSH
52033: LD_VAR 0 3
52037: ARRAY
52038: PPUSH
52039: CALL 56692 0 2
52043: ST_TO_ADDR
52044: GO 52015
52046: POP
52047: POP
// end ;
52048: LD_VAR 0 2
52052: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tdist , tmp , hex ; begin
52053: LD_INT 0
52055: PPUSH
52056: PPUSH
52057: PPUSH
52058: PPUSH
52059: PPUSH
52060: PPUSH
// if not unit or not hexes then
52061: LD_VAR 0 1
52065: NOT
52066: PUSH
52067: LD_VAR 0 2
52071: NOT
52072: OR
52073: IFFALSE 52077
// exit ;
52075: GO 52200
// dist := 9999 ;
52077: LD_ADDR_VAR 0 5
52081: PUSH
52082: LD_INT 9999
52084: ST_TO_ADDR
// for i = 1 to hexes do
52085: LD_ADDR_VAR 0 4
52089: PUSH
52090: DOUBLE
52091: LD_INT 1
52093: DEC
52094: ST_TO_ADDR
52095: LD_VAR 0 2
52099: PUSH
52100: FOR_TO
52101: IFFALSE 52188
// begin tdist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
52103: LD_ADDR_VAR 0 6
52107: PUSH
52108: LD_VAR 0 1
52112: PPUSH
52113: LD_VAR 0 2
52117: PUSH
52118: LD_VAR 0 4
52122: ARRAY
52123: PUSH
52124: LD_INT 1
52126: ARRAY
52127: PPUSH
52128: LD_VAR 0 2
52132: PUSH
52133: LD_VAR 0 4
52137: ARRAY
52138: PUSH
52139: LD_INT 2
52141: ARRAY
52142: PPUSH
52143: CALL_OW 297
52147: ST_TO_ADDR
// if tdist < dist then
52148: LD_VAR 0 6
52152: PUSH
52153: LD_VAR 0 5
52157: LESS
52158: IFFALSE 52186
// begin hex := hexes [ i ] ;
52160: LD_ADDR_VAR 0 8
52164: PUSH
52165: LD_VAR 0 2
52169: PUSH
52170: LD_VAR 0 4
52174: ARRAY
52175: ST_TO_ADDR
// dist := tdist ;
52176: LD_ADDR_VAR 0 5
52180: PUSH
52181: LD_VAR 0 6
52185: ST_TO_ADDR
// end ; end ;
52186: GO 52100
52188: POP
52189: POP
// result := hex ;
52190: LD_ADDR_VAR 0 3
52194: PUSH
52195: LD_VAR 0 8
52199: ST_TO_ADDR
// end ;
52200: LD_VAR 0 3
52204: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
52205: LD_INT 0
52207: PPUSH
52208: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
52209: LD_VAR 0 1
52213: NOT
52214: PUSH
52215: LD_VAR 0 1
52219: PUSH
52220: LD_INT 21
52222: PUSH
52223: LD_INT 2
52225: PUSH
52226: EMPTY
52227: LIST
52228: LIST
52229: PUSH
52230: LD_INT 23
52232: PUSH
52233: LD_INT 2
52235: PUSH
52236: EMPTY
52237: LIST
52238: LIST
52239: PUSH
52240: EMPTY
52241: LIST
52242: LIST
52243: PPUSH
52244: CALL_OW 69
52248: IN
52249: NOT
52250: OR
52251: IFFALSE 52255
// exit ;
52253: GO 52302
// for i = 1 to 3 do
52255: LD_ADDR_VAR 0 3
52259: PUSH
52260: DOUBLE
52261: LD_INT 1
52263: DEC
52264: ST_TO_ADDR
52265: LD_INT 3
52267: PUSH
52268: FOR_TO
52269: IFFALSE 52300
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
52271: LD_VAR 0 1
52275: PPUSH
52276: CALL_OW 250
52280: PPUSH
52281: LD_VAR 0 1
52285: PPUSH
52286: CALL_OW 251
52290: PPUSH
52291: LD_INT 1
52293: PPUSH
52294: CALL_OW 453
52298: GO 52268
52300: POP
52301: POP
// end ;
52302: LD_VAR 0 2
52306: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
52307: LD_INT 0
52309: PPUSH
52310: PPUSH
52311: PPUSH
52312: PPUSH
52313: PPUSH
52314: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
52315: LD_VAR 0 1
52319: NOT
52320: PUSH
52321: LD_VAR 0 2
52325: NOT
52326: OR
52327: PUSH
52328: LD_VAR 0 1
52332: PPUSH
52333: CALL_OW 314
52337: OR
52338: IFFALSE 52342
// exit ;
52340: GO 52809
// if GetLives ( i ) < 250 then
52342: LD_VAR 0 4
52346: PPUSH
52347: CALL_OW 256
52351: PUSH
52352: LD_INT 250
52354: LESS
52355: IFFALSE 52368
// begin ComAutodestruct ( i ) ;
52357: LD_VAR 0 4
52361: PPUSH
52362: CALL 52205 0 1
// exit ;
52366: GO 52809
// end ; x := GetX ( enemy_unit ) ;
52368: LD_ADDR_VAR 0 7
52372: PUSH
52373: LD_VAR 0 2
52377: PPUSH
52378: CALL_OW 250
52382: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
52383: LD_ADDR_VAR 0 8
52387: PUSH
52388: LD_VAR 0 2
52392: PPUSH
52393: CALL_OW 251
52397: ST_TO_ADDR
// if not x or not y then
52398: LD_VAR 0 7
52402: NOT
52403: PUSH
52404: LD_VAR 0 8
52408: NOT
52409: OR
52410: IFFALSE 52414
// exit ;
52412: GO 52809
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
52414: LD_ADDR_VAR 0 6
52418: PUSH
52419: LD_VAR 0 7
52423: PPUSH
52424: LD_INT 0
52426: PPUSH
52427: LD_INT 4
52429: PPUSH
52430: CALL_OW 272
52434: PUSH
52435: LD_VAR 0 8
52439: PPUSH
52440: LD_INT 0
52442: PPUSH
52443: LD_INT 4
52445: PPUSH
52446: CALL_OW 273
52450: PUSH
52451: EMPTY
52452: LIST
52453: LIST
52454: PUSH
52455: LD_VAR 0 7
52459: PPUSH
52460: LD_INT 1
52462: PPUSH
52463: LD_INT 4
52465: PPUSH
52466: CALL_OW 272
52470: PUSH
52471: LD_VAR 0 8
52475: PPUSH
52476: LD_INT 1
52478: PPUSH
52479: LD_INT 4
52481: PPUSH
52482: CALL_OW 273
52486: PUSH
52487: EMPTY
52488: LIST
52489: LIST
52490: PUSH
52491: LD_VAR 0 7
52495: PPUSH
52496: LD_INT 2
52498: PPUSH
52499: LD_INT 4
52501: PPUSH
52502: CALL_OW 272
52506: PUSH
52507: LD_VAR 0 8
52511: PPUSH
52512: LD_INT 2
52514: PPUSH
52515: LD_INT 4
52517: PPUSH
52518: CALL_OW 273
52522: PUSH
52523: EMPTY
52524: LIST
52525: LIST
52526: PUSH
52527: LD_VAR 0 7
52531: PPUSH
52532: LD_INT 3
52534: PPUSH
52535: LD_INT 4
52537: PPUSH
52538: CALL_OW 272
52542: PUSH
52543: LD_VAR 0 8
52547: PPUSH
52548: LD_INT 3
52550: PPUSH
52551: LD_INT 4
52553: PPUSH
52554: CALL_OW 273
52558: PUSH
52559: EMPTY
52560: LIST
52561: LIST
52562: PUSH
52563: LD_VAR 0 7
52567: PPUSH
52568: LD_INT 4
52570: PPUSH
52571: LD_INT 4
52573: PPUSH
52574: CALL_OW 272
52578: PUSH
52579: LD_VAR 0 8
52583: PPUSH
52584: LD_INT 4
52586: PPUSH
52587: LD_INT 4
52589: PPUSH
52590: CALL_OW 273
52594: PUSH
52595: EMPTY
52596: LIST
52597: LIST
52598: PUSH
52599: LD_VAR 0 7
52603: PPUSH
52604: LD_INT 5
52606: PPUSH
52607: LD_INT 4
52609: PPUSH
52610: CALL_OW 272
52614: PUSH
52615: LD_VAR 0 8
52619: PPUSH
52620: LD_INT 5
52622: PPUSH
52623: LD_INT 4
52625: PPUSH
52626: CALL_OW 273
52630: PUSH
52631: EMPTY
52632: LIST
52633: LIST
52634: PUSH
52635: EMPTY
52636: LIST
52637: LIST
52638: LIST
52639: LIST
52640: LIST
52641: LIST
52642: ST_TO_ADDR
// for i = tmp downto 1 do
52643: LD_ADDR_VAR 0 4
52647: PUSH
52648: DOUBLE
52649: LD_VAR 0 6
52653: INC
52654: ST_TO_ADDR
52655: LD_INT 1
52657: PUSH
52658: FOR_DOWNTO
52659: IFFALSE 52760
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
52661: LD_VAR 0 6
52665: PUSH
52666: LD_VAR 0 4
52670: ARRAY
52671: PUSH
52672: LD_INT 1
52674: ARRAY
52675: PPUSH
52676: LD_VAR 0 6
52680: PUSH
52681: LD_VAR 0 4
52685: ARRAY
52686: PUSH
52687: LD_INT 2
52689: ARRAY
52690: PPUSH
52691: CALL_OW 488
52695: NOT
52696: PUSH
52697: LD_VAR 0 6
52701: PUSH
52702: LD_VAR 0 4
52706: ARRAY
52707: PUSH
52708: LD_INT 1
52710: ARRAY
52711: PPUSH
52712: LD_VAR 0 6
52716: PUSH
52717: LD_VAR 0 4
52721: ARRAY
52722: PUSH
52723: LD_INT 2
52725: ARRAY
52726: PPUSH
52727: CALL_OW 428
52731: PUSH
52732: LD_INT 0
52734: NONEQUAL
52735: OR
52736: IFFALSE 52758
// tmp := Delete ( tmp , i ) ;
52738: LD_ADDR_VAR 0 6
52742: PUSH
52743: LD_VAR 0 6
52747: PPUSH
52748: LD_VAR 0 4
52752: PPUSH
52753: CALL_OW 3
52757: ST_TO_ADDR
52758: GO 52658
52760: POP
52761: POP
// j := GetClosestHex ( unit , tmp ) ;
52762: LD_ADDR_VAR 0 5
52766: PUSH
52767: LD_VAR 0 1
52771: PPUSH
52772: LD_VAR 0 6
52776: PPUSH
52777: CALL 52053 0 2
52781: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
52782: LD_VAR 0 1
52786: PPUSH
52787: LD_VAR 0 5
52791: PUSH
52792: LD_INT 1
52794: ARRAY
52795: PPUSH
52796: LD_VAR 0 5
52800: PUSH
52801: LD_INT 2
52803: ARRAY
52804: PPUSH
52805: CALL_OW 111
// end ;
52809: LD_VAR 0 3
52813: RET
// export function PrepareApemanSoldier ( ) ; begin
52814: LD_INT 0
52816: PPUSH
// uc_nation := 0 ;
52817: LD_ADDR_OWVAR 21
52821: PUSH
52822: LD_INT 0
52824: ST_TO_ADDR
// hc_sex := sex_male ;
52825: LD_ADDR_OWVAR 27
52829: PUSH
52830: LD_INT 1
52832: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
52833: LD_ADDR_OWVAR 28
52837: PUSH
52838: LD_INT 15
52840: ST_TO_ADDR
// hc_gallery :=  ;
52841: LD_ADDR_OWVAR 33
52845: PUSH
52846: LD_STRING 
52848: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
52849: LD_ADDR_OWVAR 31
52853: PUSH
52854: LD_INT 0
52856: PPUSH
52857: LD_INT 3
52859: PPUSH
52860: CALL_OW 12
52864: PUSH
52865: LD_INT 0
52867: PPUSH
52868: LD_INT 3
52870: PPUSH
52871: CALL_OW 12
52875: PUSH
52876: LD_INT 0
52878: PUSH
52879: LD_INT 0
52881: PUSH
52882: EMPTY
52883: LIST
52884: LIST
52885: LIST
52886: LIST
52887: ST_TO_ADDR
// end ;
52888: LD_VAR 0 1
52892: RET
// export function PrepareApemanEngineer ( ) ; begin
52893: LD_INT 0
52895: PPUSH
// uc_nation := 0 ;
52896: LD_ADDR_OWVAR 21
52900: PUSH
52901: LD_INT 0
52903: ST_TO_ADDR
// hc_sex := sex_male ;
52904: LD_ADDR_OWVAR 27
52908: PUSH
52909: LD_INT 1
52911: ST_TO_ADDR
// hc_class := class_apeman_engineer ;
52912: LD_ADDR_OWVAR 28
52916: PUSH
52917: LD_INT 16
52919: ST_TO_ADDR
// hc_gallery :=  ;
52920: LD_ADDR_OWVAR 33
52924: PUSH
52925: LD_STRING 
52927: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
52928: LD_ADDR_OWVAR 31
52932: PUSH
52933: LD_INT 0
52935: PPUSH
52936: LD_INT 3
52938: PPUSH
52939: CALL_OW 12
52943: PUSH
52944: LD_INT 0
52946: PPUSH
52947: LD_INT 3
52949: PPUSH
52950: CALL_OW 12
52954: PUSH
52955: LD_INT 0
52957: PUSH
52958: LD_INT 0
52960: PUSH
52961: EMPTY
52962: LIST
52963: LIST
52964: LIST
52965: LIST
52966: ST_TO_ADDR
// end ;
52967: LD_VAR 0 1
52971: RET
// export function PrepareApeman ( agressivity ) ; begin
52972: LD_INT 0
52974: PPUSH
// uc_side := 0 ;
52975: LD_ADDR_OWVAR 20
52979: PUSH
52980: LD_INT 0
52982: ST_TO_ADDR
// uc_nation := 0 ;
52983: LD_ADDR_OWVAR 21
52987: PUSH
52988: LD_INT 0
52990: ST_TO_ADDR
// hc_sex := sex_male ;
52991: LD_ADDR_OWVAR 27
52995: PUSH
52996: LD_INT 1
52998: ST_TO_ADDR
// hc_class := class_apeman ;
52999: LD_ADDR_OWVAR 28
53003: PUSH
53004: LD_INT 12
53006: ST_TO_ADDR
// hc_gallery :=  ;
53007: LD_ADDR_OWVAR 33
53011: PUSH
53012: LD_STRING 
53014: ST_TO_ADDR
// hc_agressivity := rand ( - agressivity , agressivity ) ;
53015: LD_ADDR_OWVAR 35
53019: PUSH
53020: LD_VAR 0 1
53024: NEG
53025: PPUSH
53026: LD_VAR 0 1
53030: PPUSH
53031: CALL_OW 12
53035: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
53036: LD_ADDR_OWVAR 31
53040: PUSH
53041: LD_INT 0
53043: PPUSH
53044: LD_INT 3
53046: PPUSH
53047: CALL_OW 12
53051: PUSH
53052: LD_INT 0
53054: PPUSH
53055: LD_INT 3
53057: PPUSH
53058: CALL_OW 12
53062: PUSH
53063: LD_INT 0
53065: PUSH
53066: LD_INT 0
53068: PUSH
53069: EMPTY
53070: LIST
53071: LIST
53072: LIST
53073: LIST
53074: ST_TO_ADDR
// end ;
53075: LD_VAR 0 2
53079: RET
// export function PrepareTiger ( agressivity ) ; begin
53080: LD_INT 0
53082: PPUSH
// uc_side := 0 ;
53083: LD_ADDR_OWVAR 20
53087: PUSH
53088: LD_INT 0
53090: ST_TO_ADDR
// uc_nation := 0 ;
53091: LD_ADDR_OWVAR 21
53095: PUSH
53096: LD_INT 0
53098: ST_TO_ADDR
// hc_class := class_tiger ;
53099: LD_ADDR_OWVAR 28
53103: PUSH
53104: LD_INT 14
53106: ST_TO_ADDR
// hc_gallery :=  ;
53107: LD_ADDR_OWVAR 33
53111: PUSH
53112: LD_STRING 
53114: ST_TO_ADDR
// hc_agressivity := rand ( - agressivity , agressivity ) ;
53115: LD_ADDR_OWVAR 35
53119: PUSH
53120: LD_VAR 0 1
53124: NEG
53125: PPUSH
53126: LD_VAR 0 1
53130: PPUSH
53131: CALL_OW 12
53135: ST_TO_ADDR
// end ;
53136: LD_VAR 0 2
53140: RET
// export function PrepareEnchidna ( ) ; begin
53141: LD_INT 0
53143: PPUSH
// uc_side := 0 ;
53144: LD_ADDR_OWVAR 20
53148: PUSH
53149: LD_INT 0
53151: ST_TO_ADDR
// uc_nation := 0 ;
53152: LD_ADDR_OWVAR 21
53156: PUSH
53157: LD_INT 0
53159: ST_TO_ADDR
// hc_class := class_baggie ;
53160: LD_ADDR_OWVAR 28
53164: PUSH
53165: LD_INT 13
53167: ST_TO_ADDR
// hc_gallery :=  ;
53168: LD_ADDR_OWVAR 33
53172: PUSH
53173: LD_STRING 
53175: ST_TO_ADDR
// end ;
53176: LD_VAR 0 1
53180: RET
// export function PrepareFrog ( ) ; begin
53181: LD_INT 0
53183: PPUSH
// uc_side := 0 ;
53184: LD_ADDR_OWVAR 20
53188: PUSH
53189: LD_INT 0
53191: ST_TO_ADDR
// uc_nation := 0 ;
53192: LD_ADDR_OWVAR 21
53196: PUSH
53197: LD_INT 0
53199: ST_TO_ADDR
// hc_class := class_frog ;
53200: LD_ADDR_OWVAR 28
53204: PUSH
53205: LD_INT 19
53207: ST_TO_ADDR
// hc_gallery :=  ;
53208: LD_ADDR_OWVAR 33
53212: PUSH
53213: LD_STRING 
53215: ST_TO_ADDR
// end ;
53216: LD_VAR 0 1
53220: RET
// export function PrepareFish ( ) ; begin
53221: LD_INT 0
53223: PPUSH
// uc_side := 0 ;
53224: LD_ADDR_OWVAR 20
53228: PUSH
53229: LD_INT 0
53231: ST_TO_ADDR
// uc_nation := 0 ;
53232: LD_ADDR_OWVAR 21
53236: PUSH
53237: LD_INT 0
53239: ST_TO_ADDR
// hc_class := class_fish ;
53240: LD_ADDR_OWVAR 28
53244: PUSH
53245: LD_INT 20
53247: ST_TO_ADDR
// hc_gallery :=  ;
53248: LD_ADDR_OWVAR 33
53252: PUSH
53253: LD_STRING 
53255: ST_TO_ADDR
// end ;
53256: LD_VAR 0 1
53260: RET
// export function PrepareBird ( ) ; begin
53261: LD_INT 0
53263: PPUSH
// uc_side := 0 ;
53264: LD_ADDR_OWVAR 20
53268: PUSH
53269: LD_INT 0
53271: ST_TO_ADDR
// uc_nation := 0 ;
53272: LD_ADDR_OWVAR 21
53276: PUSH
53277: LD_INT 0
53279: ST_TO_ADDR
// hc_class := class_phororhacos ;
53280: LD_ADDR_OWVAR 28
53284: PUSH
53285: LD_INT 18
53287: ST_TO_ADDR
// hc_gallery :=  ;
53288: LD_ADDR_OWVAR 33
53292: PUSH
53293: LD_STRING 
53295: ST_TO_ADDR
// end ;
53296: LD_VAR 0 1
53300: RET
// export function PrepareHorse ( ) ; begin
53301: LD_INT 0
53303: PPUSH
// uc_side := 0 ;
53304: LD_ADDR_OWVAR 20
53308: PUSH
53309: LD_INT 0
53311: ST_TO_ADDR
// uc_nation := 0 ;
53312: LD_ADDR_OWVAR 21
53316: PUSH
53317: LD_INT 0
53319: ST_TO_ADDR
// hc_class := class_horse ;
53320: LD_ADDR_OWVAR 28
53324: PUSH
53325: LD_INT 21
53327: ST_TO_ADDR
// hc_gallery :=  ;
53328: LD_ADDR_OWVAR 33
53332: PUSH
53333: LD_STRING 
53335: ST_TO_ADDR
// end ;
53336: LD_VAR 0 1
53340: RET
// export function PrepareMastodont ( ) ; begin
53341: LD_INT 0
53343: PPUSH
// uc_side := 0 ;
53344: LD_ADDR_OWVAR 20
53348: PUSH
53349: LD_INT 0
53351: ST_TO_ADDR
// uc_nation := 0 ;
53352: LD_ADDR_OWVAR 21
53356: PUSH
53357: LD_INT 0
53359: ST_TO_ADDR
// vc_chassis := class_mastodont ;
53360: LD_ADDR_OWVAR 37
53364: PUSH
53365: LD_INT 31
53367: ST_TO_ADDR
// vc_control := control_rider ;
53368: LD_ADDR_OWVAR 38
53372: PUSH
53373: LD_INT 4
53375: ST_TO_ADDR
// end ;
53376: LD_VAR 0 1
53380: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
53381: LD_INT 0
53383: PPUSH
53384: PPUSH
53385: PPUSH
// uc_side = 0 ;
53386: LD_ADDR_OWVAR 20
53390: PUSH
53391: LD_INT 0
53393: ST_TO_ADDR
// uc_nation = 0 ;
53394: LD_ADDR_OWVAR 21
53398: PUSH
53399: LD_INT 0
53401: ST_TO_ADDR
// InitHc_All ( ) ;
53402: CALL_OW 584
// InitVc ;
53406: CALL_OW 20
// if mastodonts then
53410: LD_VAR 0 6
53414: IFFALSE 53481
// for i = 1 to mastodonts do
53416: LD_ADDR_VAR 0 11
53420: PUSH
53421: DOUBLE
53422: LD_INT 1
53424: DEC
53425: ST_TO_ADDR
53426: LD_VAR 0 6
53430: PUSH
53431: FOR_TO
53432: IFFALSE 53479
// begin vc_chassis := 31 ;
53434: LD_ADDR_OWVAR 37
53438: PUSH
53439: LD_INT 31
53441: ST_TO_ADDR
// vc_control := control_rider ;
53442: LD_ADDR_OWVAR 38
53446: PUSH
53447: LD_INT 4
53449: ST_TO_ADDR
// animal := CreateVehicle ;
53450: LD_ADDR_VAR 0 12
53454: PUSH
53455: CALL_OW 45
53459: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
53460: LD_VAR 0 12
53464: PPUSH
53465: LD_VAR 0 8
53469: PPUSH
53470: LD_INT 0
53472: PPUSH
53473: CALL 55609 0 3
// end ;
53477: GO 53431
53479: POP
53480: POP
// if horses then
53481: LD_VAR 0 5
53485: IFFALSE 53552
// for i = 1 to horses do
53487: LD_ADDR_VAR 0 11
53491: PUSH
53492: DOUBLE
53493: LD_INT 1
53495: DEC
53496: ST_TO_ADDR
53497: LD_VAR 0 5
53501: PUSH
53502: FOR_TO
53503: IFFALSE 53550
// begin hc_class := 21 ;
53505: LD_ADDR_OWVAR 28
53509: PUSH
53510: LD_INT 21
53512: ST_TO_ADDR
// hc_gallery :=  ;
53513: LD_ADDR_OWVAR 33
53517: PUSH
53518: LD_STRING 
53520: ST_TO_ADDR
// animal := CreateHuman ;
53521: LD_ADDR_VAR 0 12
53525: PUSH
53526: CALL_OW 44
53530: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
53531: LD_VAR 0 12
53535: PPUSH
53536: LD_VAR 0 8
53540: PPUSH
53541: LD_INT 0
53543: PPUSH
53544: CALL 55609 0 3
// end ;
53548: GO 53502
53550: POP
53551: POP
// if birds then
53552: LD_VAR 0 1
53556: IFFALSE 53623
// for i = 1 to birds do
53558: LD_ADDR_VAR 0 11
53562: PUSH
53563: DOUBLE
53564: LD_INT 1
53566: DEC
53567: ST_TO_ADDR
53568: LD_VAR 0 1
53572: PUSH
53573: FOR_TO
53574: IFFALSE 53621
// begin hc_class = 18 ;
53576: LD_ADDR_OWVAR 28
53580: PUSH
53581: LD_INT 18
53583: ST_TO_ADDR
// hc_gallery =  ;
53584: LD_ADDR_OWVAR 33
53588: PUSH
53589: LD_STRING 
53591: ST_TO_ADDR
// animal := CreateHuman ;
53592: LD_ADDR_VAR 0 12
53596: PUSH
53597: CALL_OW 44
53601: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
53602: LD_VAR 0 12
53606: PPUSH
53607: LD_VAR 0 8
53611: PPUSH
53612: LD_INT 0
53614: PPUSH
53615: CALL 55609 0 3
// end ;
53619: GO 53573
53621: POP
53622: POP
// if tigers then
53623: LD_VAR 0 2
53627: IFFALSE 53711
// for i = 1 to tigers do
53629: LD_ADDR_VAR 0 11
53633: PUSH
53634: DOUBLE
53635: LD_INT 1
53637: DEC
53638: ST_TO_ADDR
53639: LD_VAR 0 2
53643: PUSH
53644: FOR_TO
53645: IFFALSE 53709
// begin hc_class = class_tiger ;
53647: LD_ADDR_OWVAR 28
53651: PUSH
53652: LD_INT 14
53654: ST_TO_ADDR
// hc_gallery =  ;
53655: LD_ADDR_OWVAR 33
53659: PUSH
53660: LD_STRING 
53662: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
53663: LD_ADDR_OWVAR 35
53667: PUSH
53668: LD_INT 7
53670: NEG
53671: PPUSH
53672: LD_INT 7
53674: PPUSH
53675: CALL_OW 12
53679: ST_TO_ADDR
// animal := CreateHuman ;
53680: LD_ADDR_VAR 0 12
53684: PUSH
53685: CALL_OW 44
53689: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
53690: LD_VAR 0 12
53694: PPUSH
53695: LD_VAR 0 8
53699: PPUSH
53700: LD_INT 0
53702: PPUSH
53703: CALL 55609 0 3
// end ;
53707: GO 53644
53709: POP
53710: POP
// if apemans then
53711: LD_VAR 0 3
53715: IFFALSE 53838
// for i = 1 to apemans do
53717: LD_ADDR_VAR 0 11
53721: PUSH
53722: DOUBLE
53723: LD_INT 1
53725: DEC
53726: ST_TO_ADDR
53727: LD_VAR 0 3
53731: PUSH
53732: FOR_TO
53733: IFFALSE 53836
// begin hc_class = class_apeman ;
53735: LD_ADDR_OWVAR 28
53739: PUSH
53740: LD_INT 12
53742: ST_TO_ADDR
// hc_gallery =  ;
53743: LD_ADDR_OWVAR 33
53747: PUSH
53748: LD_STRING 
53750: ST_TO_ADDR
// hc_agressivity = rand ( - 2 , 2 ) ;
53751: LD_ADDR_OWVAR 35
53755: PUSH
53756: LD_INT 2
53758: NEG
53759: PPUSH
53760: LD_INT 2
53762: PPUSH
53763: CALL_OW 12
53767: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
53768: LD_ADDR_OWVAR 31
53772: PUSH
53773: LD_INT 1
53775: PPUSH
53776: LD_INT 3
53778: PPUSH
53779: CALL_OW 12
53783: PUSH
53784: LD_INT 1
53786: PPUSH
53787: LD_INT 3
53789: PPUSH
53790: CALL_OW 12
53794: PUSH
53795: LD_INT 0
53797: PUSH
53798: LD_INT 0
53800: PUSH
53801: EMPTY
53802: LIST
53803: LIST
53804: LIST
53805: LIST
53806: ST_TO_ADDR
// animal := CreateHuman ;
53807: LD_ADDR_VAR 0 12
53811: PUSH
53812: CALL_OW 44
53816: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
53817: LD_VAR 0 12
53821: PPUSH
53822: LD_VAR 0 8
53826: PPUSH
53827: LD_INT 0
53829: PPUSH
53830: CALL 55609 0 3
// end ;
53834: GO 53732
53836: POP
53837: POP
// if enchidnas then
53838: LD_VAR 0 4
53842: IFFALSE 53909
// for i = 1 to enchidnas do
53844: LD_ADDR_VAR 0 11
53848: PUSH
53849: DOUBLE
53850: LD_INT 1
53852: DEC
53853: ST_TO_ADDR
53854: LD_VAR 0 4
53858: PUSH
53859: FOR_TO
53860: IFFALSE 53907
// begin hc_class = 13 ;
53862: LD_ADDR_OWVAR 28
53866: PUSH
53867: LD_INT 13
53869: ST_TO_ADDR
// hc_gallery =  ;
53870: LD_ADDR_OWVAR 33
53874: PUSH
53875: LD_STRING 
53877: ST_TO_ADDR
// animal := CreateHuman ;
53878: LD_ADDR_VAR 0 12
53882: PUSH
53883: CALL_OW 44
53887: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
53888: LD_VAR 0 12
53892: PPUSH
53893: LD_VAR 0 8
53897: PPUSH
53898: LD_INT 0
53900: PPUSH
53901: CALL 55609 0 3
// end ;
53905: GO 53859
53907: POP
53908: POP
// if fishes then
53909: LD_VAR 0 7
53913: IFFALSE 53980
// for i = 1 to fishes do
53915: LD_ADDR_VAR 0 11
53919: PUSH
53920: DOUBLE
53921: LD_INT 1
53923: DEC
53924: ST_TO_ADDR
53925: LD_VAR 0 7
53929: PUSH
53930: FOR_TO
53931: IFFALSE 53978
// begin hc_class = 20 ;
53933: LD_ADDR_OWVAR 28
53937: PUSH
53938: LD_INT 20
53940: ST_TO_ADDR
// hc_gallery =  ;
53941: LD_ADDR_OWVAR 33
53945: PUSH
53946: LD_STRING 
53948: ST_TO_ADDR
// animal := CreateHuman ;
53949: LD_ADDR_VAR 0 12
53953: PUSH
53954: CALL_OW 44
53958: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
53959: LD_VAR 0 12
53963: PPUSH
53964: LD_VAR 0 9
53968: PPUSH
53969: LD_INT 0
53971: PPUSH
53972: CALL 55609 0 3
// end ;
53976: GO 53930
53978: POP
53979: POP
// end ;
53980: LD_VAR 0 10
53984: RET
// export function WantHeal ( sci , unit ) ; begin
53985: LD_INT 0
53987: PPUSH
// if GetTaskList ( sci ) > 0 then
53988: LD_VAR 0 1
53992: PPUSH
53993: CALL_OW 437
53997: PUSH
53998: LD_INT 0
54000: GREATER
54001: IFFALSE 54071
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
54003: LD_VAR 0 1
54007: PPUSH
54008: CALL_OW 437
54012: PUSH
54013: LD_INT 1
54015: ARRAY
54016: PUSH
54017: LD_INT 1
54019: ARRAY
54020: PUSH
54021: LD_STRING l
54023: EQUAL
54024: PUSH
54025: LD_VAR 0 1
54029: PPUSH
54030: CALL_OW 437
54034: PUSH
54035: LD_INT 1
54037: ARRAY
54038: PUSH
54039: LD_INT 4
54041: ARRAY
54042: PUSH
54043: LD_VAR 0 2
54047: EQUAL
54048: AND
54049: IFFALSE 54061
// result := true else
54051: LD_ADDR_VAR 0 3
54055: PUSH
54056: LD_INT 1
54058: ST_TO_ADDR
54059: GO 54069
// result := false ;
54061: LD_ADDR_VAR 0 3
54065: PUSH
54066: LD_INT 0
54068: ST_TO_ADDR
// end else
54069: GO 54079
// result := false ;
54071: LD_ADDR_VAR 0 3
54075: PUSH
54076: LD_INT 0
54078: ST_TO_ADDR
// end ;
54079: LD_VAR 0 3
54083: RET
// export function HealTarget ( sci ) ; begin
54084: LD_INT 0
54086: PPUSH
// if not sci then
54087: LD_VAR 0 1
54091: NOT
54092: IFFALSE 54096
// exit ;
54094: GO 54161
// result := 0 ;
54096: LD_ADDR_VAR 0 2
54100: PUSH
54101: LD_INT 0
54103: ST_TO_ADDR
// if GetTaskList ( sci ) then
54104: LD_VAR 0 1
54108: PPUSH
54109: CALL_OW 437
54113: IFFALSE 54161
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
54115: LD_VAR 0 1
54119: PPUSH
54120: CALL_OW 437
54124: PUSH
54125: LD_INT 1
54127: ARRAY
54128: PUSH
54129: LD_INT 1
54131: ARRAY
54132: PUSH
54133: LD_STRING l
54135: EQUAL
54136: IFFALSE 54161
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
54138: LD_ADDR_VAR 0 2
54142: PUSH
54143: LD_VAR 0 1
54147: PPUSH
54148: CALL_OW 437
54152: PUSH
54153: LD_INT 1
54155: ARRAY
54156: PUSH
54157: LD_INT 4
54159: ARRAY
54160: ST_TO_ADDR
// end ;
54161: LD_VAR 0 2
54165: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
54166: LD_INT 0
54168: PPUSH
54169: PPUSH
54170: PPUSH
54171: PPUSH
// if not base_units then
54172: LD_VAR 0 1
54176: NOT
54177: IFFALSE 54181
// exit ;
54179: GO 54268
// result := false ;
54181: LD_ADDR_VAR 0 2
54185: PUSH
54186: LD_INT 0
54188: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
54189: LD_ADDR_VAR 0 5
54193: PUSH
54194: LD_VAR 0 1
54198: PPUSH
54199: LD_INT 21
54201: PUSH
54202: LD_INT 3
54204: PUSH
54205: EMPTY
54206: LIST
54207: LIST
54208: PPUSH
54209: CALL_OW 72
54213: ST_TO_ADDR
// if not tmp then
54214: LD_VAR 0 5
54218: NOT
54219: IFFALSE 54223
// exit ;
54221: GO 54268
// for i in tmp do
54223: LD_ADDR_VAR 0 3
54227: PUSH
54228: LD_VAR 0 5
54232: PUSH
54233: FOR_IN
54234: IFFALSE 54266
// begin result := EnemyInRange ( i , 22 ) ;
54236: LD_ADDR_VAR 0 2
54240: PUSH
54241: LD_VAR 0 3
54245: PPUSH
54246: LD_INT 22
54248: PPUSH
54249: CALL 51855 0 2
54253: ST_TO_ADDR
// if result then
54254: LD_VAR 0 2
54258: IFFALSE 54264
// exit ;
54260: POP
54261: POP
54262: GO 54268
// end ;
54264: GO 54233
54266: POP
54267: POP
// end ;
54268: LD_VAR 0 2
54272: RET
// export function FilterByTag ( units , tag ) ; begin
54273: LD_INT 0
54275: PPUSH
// result := UnitFilter ( units , [ f_tag , tag ] ) ;
54276: LD_ADDR_VAR 0 3
54280: PUSH
54281: LD_VAR 0 1
54285: PPUSH
54286: LD_INT 120
54288: PUSH
54289: LD_VAR 0 2
54293: PUSH
54294: EMPTY
54295: LIST
54296: LIST
54297: PPUSH
54298: CALL_OW 72
54302: ST_TO_ADDR
// end ;
54303: LD_VAR 0 3
54307: RET
// export function IsDriver ( un ) ; begin
54308: LD_INT 0
54310: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
54311: LD_ADDR_VAR 0 2
54315: PUSH
54316: LD_VAR 0 1
54320: PUSH
54321: LD_INT 55
54323: PUSH
54324: EMPTY
54325: LIST
54326: PPUSH
54327: CALL_OW 69
54331: IN
54332: ST_TO_ADDR
// end ;
54333: LD_VAR 0 2
54337: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
54338: LD_INT 0
54340: PPUSH
54341: PPUSH
// list := [ ] ;
54342: LD_ADDR_VAR 0 5
54346: PUSH
54347: EMPTY
54348: ST_TO_ADDR
// case d of 0 :
54349: LD_VAR 0 3
54353: PUSH
54354: LD_INT 0
54356: DOUBLE
54357: EQUAL
54358: IFTRUE 54362
54360: GO 54495
54362: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
54363: LD_ADDR_VAR 0 5
54367: PUSH
54368: LD_VAR 0 1
54372: PUSH
54373: LD_INT 4
54375: MINUS
54376: PUSH
54377: LD_VAR 0 2
54381: PUSH
54382: LD_INT 4
54384: MINUS
54385: PUSH
54386: LD_INT 2
54388: PUSH
54389: EMPTY
54390: LIST
54391: LIST
54392: LIST
54393: PUSH
54394: LD_VAR 0 1
54398: PUSH
54399: LD_INT 3
54401: MINUS
54402: PUSH
54403: LD_VAR 0 2
54407: PUSH
54408: LD_INT 1
54410: PUSH
54411: EMPTY
54412: LIST
54413: LIST
54414: LIST
54415: PUSH
54416: LD_VAR 0 1
54420: PUSH
54421: LD_INT 4
54423: PLUS
54424: PUSH
54425: LD_VAR 0 2
54429: PUSH
54430: LD_INT 4
54432: PUSH
54433: EMPTY
54434: LIST
54435: LIST
54436: LIST
54437: PUSH
54438: LD_VAR 0 1
54442: PUSH
54443: LD_INT 3
54445: PLUS
54446: PUSH
54447: LD_VAR 0 2
54451: PUSH
54452: LD_INT 3
54454: PLUS
54455: PUSH
54456: LD_INT 5
54458: PUSH
54459: EMPTY
54460: LIST
54461: LIST
54462: LIST
54463: PUSH
54464: LD_VAR 0 1
54468: PUSH
54469: LD_VAR 0 2
54473: PUSH
54474: LD_INT 4
54476: PLUS
54477: PUSH
54478: LD_INT 0
54480: PUSH
54481: EMPTY
54482: LIST
54483: LIST
54484: LIST
54485: PUSH
54486: EMPTY
54487: LIST
54488: LIST
54489: LIST
54490: LIST
54491: LIST
54492: ST_TO_ADDR
// end ; 1 :
54493: GO 55193
54495: LD_INT 1
54497: DOUBLE
54498: EQUAL
54499: IFTRUE 54503
54501: GO 54636
54503: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
54504: LD_ADDR_VAR 0 5
54508: PUSH
54509: LD_VAR 0 1
54513: PUSH
54514: LD_VAR 0 2
54518: PUSH
54519: LD_INT 4
54521: MINUS
54522: PUSH
54523: LD_INT 3
54525: PUSH
54526: EMPTY
54527: LIST
54528: LIST
54529: LIST
54530: PUSH
54531: LD_VAR 0 1
54535: PUSH
54536: LD_INT 3
54538: MINUS
54539: PUSH
54540: LD_VAR 0 2
54544: PUSH
54545: LD_INT 3
54547: MINUS
54548: PUSH
54549: LD_INT 2
54551: PUSH
54552: EMPTY
54553: LIST
54554: LIST
54555: LIST
54556: PUSH
54557: LD_VAR 0 1
54561: PUSH
54562: LD_INT 4
54564: MINUS
54565: PUSH
54566: LD_VAR 0 2
54570: PUSH
54571: LD_INT 1
54573: PUSH
54574: EMPTY
54575: LIST
54576: LIST
54577: LIST
54578: PUSH
54579: LD_VAR 0 1
54583: PUSH
54584: LD_VAR 0 2
54588: PUSH
54589: LD_INT 3
54591: PLUS
54592: PUSH
54593: LD_INT 0
54595: PUSH
54596: EMPTY
54597: LIST
54598: LIST
54599: LIST
54600: PUSH
54601: LD_VAR 0 1
54605: PUSH
54606: LD_INT 4
54608: PLUS
54609: PUSH
54610: LD_VAR 0 2
54614: PUSH
54615: LD_INT 4
54617: PLUS
54618: PUSH
54619: LD_INT 5
54621: PUSH
54622: EMPTY
54623: LIST
54624: LIST
54625: LIST
54626: PUSH
54627: EMPTY
54628: LIST
54629: LIST
54630: LIST
54631: LIST
54632: LIST
54633: ST_TO_ADDR
// end ; 2 :
54634: GO 55193
54636: LD_INT 2
54638: DOUBLE
54639: EQUAL
54640: IFTRUE 54644
54642: GO 54773
54644: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
54645: LD_ADDR_VAR 0 5
54649: PUSH
54650: LD_VAR 0 1
54654: PUSH
54655: LD_VAR 0 2
54659: PUSH
54660: LD_INT 3
54662: MINUS
54663: PUSH
54664: LD_INT 3
54666: PUSH
54667: EMPTY
54668: LIST
54669: LIST
54670: LIST
54671: PUSH
54672: LD_VAR 0 1
54676: PUSH
54677: LD_INT 4
54679: PLUS
54680: PUSH
54681: LD_VAR 0 2
54685: PUSH
54686: LD_INT 4
54688: PUSH
54689: EMPTY
54690: LIST
54691: LIST
54692: LIST
54693: PUSH
54694: LD_VAR 0 1
54698: PUSH
54699: LD_VAR 0 2
54703: PUSH
54704: LD_INT 4
54706: PLUS
54707: PUSH
54708: LD_INT 0
54710: PUSH
54711: EMPTY
54712: LIST
54713: LIST
54714: LIST
54715: PUSH
54716: LD_VAR 0 1
54720: PUSH
54721: LD_INT 3
54723: MINUS
54724: PUSH
54725: LD_VAR 0 2
54729: PUSH
54730: LD_INT 1
54732: PUSH
54733: EMPTY
54734: LIST
54735: LIST
54736: LIST
54737: PUSH
54738: LD_VAR 0 1
54742: PUSH
54743: LD_INT 4
54745: MINUS
54746: PUSH
54747: LD_VAR 0 2
54751: PUSH
54752: LD_INT 4
54754: MINUS
54755: PUSH
54756: LD_INT 2
54758: PUSH
54759: EMPTY
54760: LIST
54761: LIST
54762: LIST
54763: PUSH
54764: EMPTY
54765: LIST
54766: LIST
54767: LIST
54768: LIST
54769: LIST
54770: ST_TO_ADDR
// end ; 3 :
54771: GO 55193
54773: LD_INT 3
54775: DOUBLE
54776: EQUAL
54777: IFTRUE 54781
54779: GO 54914
54781: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
54782: LD_ADDR_VAR 0 5
54786: PUSH
54787: LD_VAR 0 1
54791: PUSH
54792: LD_INT 3
54794: PLUS
54795: PUSH
54796: LD_VAR 0 2
54800: PUSH
54801: LD_INT 4
54803: PUSH
54804: EMPTY
54805: LIST
54806: LIST
54807: LIST
54808: PUSH
54809: LD_VAR 0 1
54813: PUSH
54814: LD_INT 4
54816: PLUS
54817: PUSH
54818: LD_VAR 0 2
54822: PUSH
54823: LD_INT 4
54825: PLUS
54826: PUSH
54827: LD_INT 5
54829: PUSH
54830: EMPTY
54831: LIST
54832: LIST
54833: LIST
54834: PUSH
54835: LD_VAR 0 1
54839: PUSH
54840: LD_INT 4
54842: MINUS
54843: PUSH
54844: LD_VAR 0 2
54848: PUSH
54849: LD_INT 1
54851: PUSH
54852: EMPTY
54853: LIST
54854: LIST
54855: LIST
54856: PUSH
54857: LD_VAR 0 1
54861: PUSH
54862: LD_VAR 0 2
54866: PUSH
54867: LD_INT 4
54869: MINUS
54870: PUSH
54871: LD_INT 3
54873: PUSH
54874: EMPTY
54875: LIST
54876: LIST
54877: LIST
54878: PUSH
54879: LD_VAR 0 1
54883: PUSH
54884: LD_INT 3
54886: MINUS
54887: PUSH
54888: LD_VAR 0 2
54892: PUSH
54893: LD_INT 3
54895: MINUS
54896: PUSH
54897: LD_INT 2
54899: PUSH
54900: EMPTY
54901: LIST
54902: LIST
54903: LIST
54904: PUSH
54905: EMPTY
54906: LIST
54907: LIST
54908: LIST
54909: LIST
54910: LIST
54911: ST_TO_ADDR
// end ; 4 :
54912: GO 55193
54914: LD_INT 4
54916: DOUBLE
54917: EQUAL
54918: IFTRUE 54922
54920: GO 55055
54922: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
54923: LD_ADDR_VAR 0 5
54927: PUSH
54928: LD_VAR 0 1
54932: PUSH
54933: LD_VAR 0 2
54937: PUSH
54938: LD_INT 4
54940: PLUS
54941: PUSH
54942: LD_INT 0
54944: PUSH
54945: EMPTY
54946: LIST
54947: LIST
54948: LIST
54949: PUSH
54950: LD_VAR 0 1
54954: PUSH
54955: LD_INT 3
54957: PLUS
54958: PUSH
54959: LD_VAR 0 2
54963: PUSH
54964: LD_INT 3
54966: PLUS
54967: PUSH
54968: LD_INT 5
54970: PUSH
54971: EMPTY
54972: LIST
54973: LIST
54974: LIST
54975: PUSH
54976: LD_VAR 0 1
54980: PUSH
54981: LD_INT 4
54983: PLUS
54984: PUSH
54985: LD_VAR 0 2
54989: PUSH
54990: LD_INT 4
54992: PUSH
54993: EMPTY
54994: LIST
54995: LIST
54996: LIST
54997: PUSH
54998: LD_VAR 0 1
55002: PUSH
55003: LD_VAR 0 2
55007: PUSH
55008: LD_INT 3
55010: MINUS
55011: PUSH
55012: LD_INT 3
55014: PUSH
55015: EMPTY
55016: LIST
55017: LIST
55018: LIST
55019: PUSH
55020: LD_VAR 0 1
55024: PUSH
55025: LD_INT 4
55027: MINUS
55028: PUSH
55029: LD_VAR 0 2
55033: PUSH
55034: LD_INT 4
55036: MINUS
55037: PUSH
55038: LD_INT 2
55040: PUSH
55041: EMPTY
55042: LIST
55043: LIST
55044: LIST
55045: PUSH
55046: EMPTY
55047: LIST
55048: LIST
55049: LIST
55050: LIST
55051: LIST
55052: ST_TO_ADDR
// end ; 5 :
55053: GO 55193
55055: LD_INT 5
55057: DOUBLE
55058: EQUAL
55059: IFTRUE 55063
55061: GO 55192
55063: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
55064: LD_ADDR_VAR 0 5
55068: PUSH
55069: LD_VAR 0 1
55073: PUSH
55074: LD_INT 4
55076: MINUS
55077: PUSH
55078: LD_VAR 0 2
55082: PUSH
55083: LD_INT 1
55085: PUSH
55086: EMPTY
55087: LIST
55088: LIST
55089: LIST
55090: PUSH
55091: LD_VAR 0 1
55095: PUSH
55096: LD_VAR 0 2
55100: PUSH
55101: LD_INT 4
55103: MINUS
55104: PUSH
55105: LD_INT 3
55107: PUSH
55108: EMPTY
55109: LIST
55110: LIST
55111: LIST
55112: PUSH
55113: LD_VAR 0 1
55117: PUSH
55118: LD_INT 4
55120: PLUS
55121: PUSH
55122: LD_VAR 0 2
55126: PUSH
55127: LD_INT 4
55129: PLUS
55130: PUSH
55131: LD_INT 5
55133: PUSH
55134: EMPTY
55135: LIST
55136: LIST
55137: LIST
55138: PUSH
55139: LD_VAR 0 1
55143: PUSH
55144: LD_INT 3
55146: PLUS
55147: PUSH
55148: LD_VAR 0 2
55152: PUSH
55153: LD_INT 4
55155: PUSH
55156: EMPTY
55157: LIST
55158: LIST
55159: LIST
55160: PUSH
55161: LD_VAR 0 1
55165: PUSH
55166: LD_VAR 0 2
55170: PUSH
55171: LD_INT 3
55173: PLUS
55174: PUSH
55175: LD_INT 0
55177: PUSH
55178: EMPTY
55179: LIST
55180: LIST
55181: LIST
55182: PUSH
55183: EMPTY
55184: LIST
55185: LIST
55186: LIST
55187: LIST
55188: LIST
55189: ST_TO_ADDR
// end ; end ;
55190: GO 55193
55192: POP
// result := list ;
55193: LD_ADDR_VAR 0 4
55197: PUSH
55198: LD_VAR 0 5
55202: ST_TO_ADDR
// end ;
55203: LD_VAR 0 4
55207: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
55208: LD_INT 0
55210: PPUSH
55211: PPUSH
55212: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
55213: LD_VAR 0 1
55217: NOT
55218: PUSH
55219: LD_VAR 0 2
55223: PUSH
55224: LD_INT 1
55226: PUSH
55227: LD_INT 2
55229: PUSH
55230: LD_INT 3
55232: PUSH
55233: LD_INT 4
55235: PUSH
55236: EMPTY
55237: LIST
55238: LIST
55239: LIST
55240: LIST
55241: IN
55242: NOT
55243: OR
55244: IFFALSE 55248
// exit ;
55246: GO 55331
// tmp := [ ] ;
55248: LD_ADDR_VAR 0 5
55252: PUSH
55253: EMPTY
55254: ST_TO_ADDR
// for i in units do
55255: LD_ADDR_VAR 0 4
55259: PUSH
55260: LD_VAR 0 1
55264: PUSH
55265: FOR_IN
55266: IFFALSE 55300
// tmp := Join ( tmp , GetSkill ( i , class ) ) ;
55268: LD_ADDR_VAR 0 5
55272: PUSH
55273: LD_VAR 0 5
55277: PPUSH
55278: LD_VAR 0 4
55282: PPUSH
55283: LD_VAR 0 2
55287: PPUSH
55288: CALL_OW 259
55292: PPUSH
55293: CALL 56692 0 2
55297: ST_TO_ADDR
55298: GO 55265
55300: POP
55301: POP
// if not tmp then
55302: LD_VAR 0 5
55306: NOT
55307: IFFALSE 55311
// exit ;
55309: GO 55331
// result := SortListByListDesc ( units , tmp ) ;
55311: LD_ADDR_VAR 0 3
55315: PUSH
55316: LD_VAR 0 1
55320: PPUSH
55321: LD_VAR 0 5
55325: PPUSH
55326: CALL_OW 77
55330: ST_TO_ADDR
// end ;
55331: LD_VAR 0 3
55335: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
55336: LD_INT 0
55338: PPUSH
55339: PPUSH
55340: PPUSH
// result := false ;
55341: LD_ADDR_VAR 0 3
55345: PUSH
55346: LD_INT 0
55348: ST_TO_ADDR
// if not building then
55349: LD_VAR 0 2
55353: NOT
55354: IFFALSE 55358
// exit ;
55356: GO 55496
// x := GetX ( building ) ;
55358: LD_ADDR_VAR 0 4
55362: PUSH
55363: LD_VAR 0 2
55367: PPUSH
55368: CALL_OW 250
55372: ST_TO_ADDR
// y := GetY ( building ) ;
55373: LD_ADDR_VAR 0 5
55377: PUSH
55378: LD_VAR 0 2
55382: PPUSH
55383: CALL_OW 251
55387: ST_TO_ADDR
// if not x or not y then
55388: LD_VAR 0 4
55392: NOT
55393: PUSH
55394: LD_VAR 0 5
55398: NOT
55399: OR
55400: IFFALSE 55404
// exit ;
55402: GO 55496
// if GetTaskList ( unit ) then
55404: LD_VAR 0 1
55408: PPUSH
55409: CALL_OW 437
55413: IFFALSE 55496
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
55415: LD_STRING e
55417: PUSH
55418: LD_VAR 0 1
55422: PPUSH
55423: CALL_OW 437
55427: PUSH
55428: LD_INT 1
55430: ARRAY
55431: PUSH
55432: LD_INT 1
55434: ARRAY
55435: EQUAL
55436: PUSH
55437: LD_VAR 0 4
55441: PUSH
55442: LD_VAR 0 1
55446: PPUSH
55447: CALL_OW 437
55451: PUSH
55452: LD_INT 1
55454: ARRAY
55455: PUSH
55456: LD_INT 2
55458: ARRAY
55459: EQUAL
55460: AND
55461: PUSH
55462: LD_VAR 0 5
55466: PUSH
55467: LD_VAR 0 1
55471: PPUSH
55472: CALL_OW 437
55476: PUSH
55477: LD_INT 1
55479: ARRAY
55480: PUSH
55481: LD_INT 3
55483: ARRAY
55484: EQUAL
55485: AND
55486: IFFALSE 55496
// result := true end ;
55488: LD_ADDR_VAR 0 3
55492: PUSH
55493: LD_INT 1
55495: ST_TO_ADDR
// end ;
55496: LD_VAR 0 3
55500: RET
// export function UnitGoingToXY ( unit , x , y ) ; begin
55501: LD_INT 0
55503: PPUSH
// result := false ;
55504: LD_ADDR_VAR 0 4
55508: PUSH
55509: LD_INT 0
55511: ST_TO_ADDR
// if GetTaskList ( unit ) then
55512: LD_VAR 0 1
55516: PPUSH
55517: CALL_OW 437
55521: IFFALSE 55604
// begin if M = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
55523: LD_STRING M
55525: PUSH
55526: LD_VAR 0 1
55530: PPUSH
55531: CALL_OW 437
55535: PUSH
55536: LD_INT 1
55538: ARRAY
55539: PUSH
55540: LD_INT 1
55542: ARRAY
55543: EQUAL
55544: PUSH
55545: LD_VAR 0 2
55549: PUSH
55550: LD_VAR 0 1
55554: PPUSH
55555: CALL_OW 437
55559: PUSH
55560: LD_INT 1
55562: ARRAY
55563: PUSH
55564: LD_INT 2
55566: ARRAY
55567: EQUAL
55568: AND
55569: PUSH
55570: LD_VAR 0 3
55574: PUSH
55575: LD_VAR 0 1
55579: PPUSH
55580: CALL_OW 437
55584: PUSH
55585: LD_INT 1
55587: ARRAY
55588: PUSH
55589: LD_INT 3
55591: ARRAY
55592: EQUAL
55593: AND
55594: IFFALSE 55604
// result := true ;
55596: LD_ADDR_VAR 0 4
55600: PUSH
55601: LD_INT 1
55603: ST_TO_ADDR
// end ; end ;
55604: LD_VAR 0 4
55608: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
55609: LD_INT 0
55611: PPUSH
55612: PPUSH
55613: PPUSH
55614: PPUSH
// if not unit or not area then
55615: LD_VAR 0 1
55619: NOT
55620: PUSH
55621: LD_VAR 0 2
55625: NOT
55626: OR
55627: IFFALSE 55631
// exit ;
55629: GO 55795
// tmp := AreaToList ( area , i ) ;
55631: LD_ADDR_VAR 0 6
55635: PUSH
55636: LD_VAR 0 2
55640: PPUSH
55641: LD_VAR 0 5
55645: PPUSH
55646: CALL_OW 517
55650: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
55651: LD_ADDR_VAR 0 5
55655: PUSH
55656: DOUBLE
55657: LD_INT 1
55659: DEC
55660: ST_TO_ADDR
55661: LD_VAR 0 6
55665: PUSH
55666: LD_INT 1
55668: ARRAY
55669: PUSH
55670: FOR_TO
55671: IFFALSE 55793
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
55673: LD_ADDR_VAR 0 7
55677: PUSH
55678: LD_VAR 0 6
55682: PUSH
55683: LD_INT 1
55685: ARRAY
55686: PUSH
55687: LD_VAR 0 5
55691: ARRAY
55692: PUSH
55693: LD_VAR 0 6
55697: PUSH
55698: LD_INT 2
55700: ARRAY
55701: PUSH
55702: LD_VAR 0 5
55706: ARRAY
55707: PUSH
55708: EMPTY
55709: LIST
55710: LIST
55711: ST_TO_ADDR
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
55712: LD_VAR 0 7
55716: PUSH
55717: LD_INT 1
55719: ARRAY
55720: PPUSH
55721: LD_VAR 0 7
55725: PUSH
55726: LD_INT 2
55728: ARRAY
55729: PPUSH
55730: CALL_OW 428
55734: PUSH
55735: LD_INT 0
55737: EQUAL
55738: IFFALSE 55791
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
55740: LD_VAR 0 1
55744: PPUSH
55745: LD_VAR 0 7
55749: PUSH
55750: LD_INT 1
55752: ARRAY
55753: PPUSH
55754: LD_VAR 0 7
55758: PUSH
55759: LD_INT 2
55761: ARRAY
55762: PPUSH
55763: LD_VAR 0 3
55767: PPUSH
55768: CALL_OW 48
// result := IsPlaced ( unit ) ;
55772: LD_ADDR_VAR 0 4
55776: PUSH
55777: LD_VAR 0 1
55781: PPUSH
55782: CALL_OW 305
55786: ST_TO_ADDR
// exit ;
55787: POP
55788: POP
55789: GO 55795
// end ; end ;
55791: GO 55670
55793: POP
55794: POP
// end ;
55795: LD_VAR 0 4
55799: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
55800: LD_INT 0
55802: PPUSH
55803: PPUSH
55804: PPUSH
// if not side or side > 8 then
55805: LD_VAR 0 1
55809: NOT
55810: PUSH
55811: LD_VAR 0 1
55815: PUSH
55816: LD_INT 8
55818: GREATER
55819: OR
55820: IFFALSE 55824
// exit ;
55822: GO 56011
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
55824: LD_ADDR_VAR 0 4
55828: PUSH
55829: LD_INT 22
55831: PUSH
55832: LD_VAR 0 1
55836: PUSH
55837: EMPTY
55838: LIST
55839: LIST
55840: PUSH
55841: LD_INT 21
55843: PUSH
55844: LD_INT 3
55846: PUSH
55847: EMPTY
55848: LIST
55849: LIST
55850: PUSH
55851: EMPTY
55852: LIST
55853: LIST
55854: PPUSH
55855: CALL_OW 69
55859: ST_TO_ADDR
// if not tmp then
55860: LD_VAR 0 4
55864: NOT
55865: IFFALSE 55869
// exit ;
55867: GO 56011
// enable_addtolog := true ;
55869: LD_ADDR_OWVAR 81
55873: PUSH
55874: LD_INT 1
55876: ST_TO_ADDR
// AddToLog ( [ ) ;
55877: LD_STRING [
55879: PPUSH
55880: CALL_OW 561
// for i in tmp do
55884: LD_ADDR_VAR 0 3
55888: PUSH
55889: LD_VAR 0 4
55893: PUSH
55894: FOR_IN
55895: IFFALSE 56002
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
55897: LD_STRING [
55899: PUSH
55900: LD_VAR 0 3
55904: PPUSH
55905: CALL_OW 266
55909: STR
55910: PUSH
55911: LD_STRING , 
55913: STR
55914: PUSH
55915: LD_VAR 0 3
55919: PPUSH
55920: CALL_OW 250
55924: STR
55925: PUSH
55926: LD_STRING , 
55928: STR
55929: PUSH
55930: LD_VAR 0 3
55934: PPUSH
55935: CALL_OW 251
55939: STR
55940: PUSH
55941: LD_STRING , 
55943: STR
55944: PUSH
55945: LD_VAR 0 3
55949: PPUSH
55950: CALL_OW 254
55954: STR
55955: PUSH
55956: LD_STRING , 
55958: STR
55959: PUSH
55960: LD_VAR 0 3
55964: PPUSH
55965: LD_INT 1
55967: PPUSH
55968: CALL_OW 268
55972: STR
55973: PUSH
55974: LD_STRING , 
55976: STR
55977: PUSH
55978: LD_VAR 0 3
55982: PPUSH
55983: LD_INT 2
55985: PPUSH
55986: CALL_OW 268
55990: STR
55991: PUSH
55992: LD_STRING ],
55994: STR
55995: PPUSH
55996: CALL_OW 561
// end ;
56000: GO 55894
56002: POP
56003: POP
// AddToLog ( ]; ) ;
56004: LD_STRING ];
56006: PPUSH
56007: CALL_OW 561
// end ;
56011: LD_VAR 0 2
56015: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
56016: LD_INT 0
56018: PPUSH
56019: PPUSH
56020: PPUSH
56021: PPUSH
56022: PPUSH
// if not area or not rate or not max then
56023: LD_VAR 0 1
56027: NOT
56028: PUSH
56029: LD_VAR 0 2
56033: NOT
56034: OR
56035: PUSH
56036: LD_VAR 0 4
56040: NOT
56041: OR
56042: IFFALSE 56046
// exit ;
56044: GO 56235
// while 1 do
56046: LD_INT 1
56048: IFFALSE 56235
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
56050: LD_ADDR_VAR 0 9
56054: PUSH
56055: LD_VAR 0 1
56059: PPUSH
56060: LD_INT 1
56062: PPUSH
56063: CALL_OW 287
56067: PUSH
56068: LD_INT 10
56070: MUL
56071: ST_TO_ADDR
// r := rate / 10 ;
56072: LD_ADDR_VAR 0 7
56076: PUSH
56077: LD_VAR 0 2
56081: PUSH
56082: LD_INT 10
56084: DIVREAL
56085: ST_TO_ADDR
// time := 1 1$00 ;
56086: LD_ADDR_VAR 0 8
56090: PUSH
56091: LD_INT 2100
56093: ST_TO_ADDR
// if amount < min then
56094: LD_VAR 0 9
56098: PUSH
56099: LD_VAR 0 3
56103: LESS
56104: IFFALSE 56122
// r := r * 2 else
56106: LD_ADDR_VAR 0 7
56110: PUSH
56111: LD_VAR 0 7
56115: PUSH
56116: LD_INT 2
56118: MUL
56119: ST_TO_ADDR
56120: GO 56148
// if amount > max then
56122: LD_VAR 0 9
56126: PUSH
56127: LD_VAR 0 4
56131: GREATER
56132: IFFALSE 56148
// r := r / 2 ;
56134: LD_ADDR_VAR 0 7
56138: PUSH
56139: LD_VAR 0 7
56143: PUSH
56144: LD_INT 2
56146: DIVREAL
56147: ST_TO_ADDR
// time := time / r ;
56148: LD_ADDR_VAR 0 8
56152: PUSH
56153: LD_VAR 0 8
56157: PUSH
56158: LD_VAR 0 7
56162: DIVREAL
56163: ST_TO_ADDR
// if time < 0 then
56164: LD_VAR 0 8
56168: PUSH
56169: LD_INT 0
56171: LESS
56172: IFFALSE 56189
// time := time * - 1 ;
56174: LD_ADDR_VAR 0 8
56178: PUSH
56179: LD_VAR 0 8
56183: PUSH
56184: LD_INT 1
56186: NEG
56187: MUL
56188: ST_TO_ADDR
// wait ( time + rand ( 0 0$01 , 0 0$25 ) ) ;
56189: LD_VAR 0 8
56193: PUSH
56194: LD_INT 35
56196: PPUSH
56197: LD_INT 875
56199: PPUSH
56200: CALL_OW 12
56204: PLUS
56205: PPUSH
56206: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
56210: LD_INT 1
56212: PPUSH
56213: LD_INT 5
56215: PPUSH
56216: CALL_OW 12
56220: PPUSH
56221: LD_VAR 0 1
56225: PPUSH
56226: LD_INT 1
56228: PPUSH
56229: CALL_OW 55
// end ;
56233: GO 56046
// end ;
56235: LD_VAR 0 5
56239: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
56240: LD_INT 0
56242: PPUSH
56243: PPUSH
56244: PPUSH
56245: PPUSH
56246: PPUSH
56247: PPUSH
56248: PPUSH
56249: PPUSH
// if not turrets or not factories then
56250: LD_VAR 0 1
56254: NOT
56255: PUSH
56256: LD_VAR 0 2
56260: NOT
56261: OR
56262: IFFALSE 56266
// exit ;
56264: GO 56573
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
56266: LD_ADDR_VAR 0 10
56270: PUSH
56271: LD_INT 5
56273: PUSH
56274: LD_INT 6
56276: PUSH
56277: EMPTY
56278: LIST
56279: LIST
56280: PUSH
56281: LD_INT 2
56283: PUSH
56284: LD_INT 4
56286: PUSH
56287: EMPTY
56288: LIST
56289: LIST
56290: PUSH
56291: LD_INT 3
56293: PUSH
56294: LD_INT 5
56296: PUSH
56297: EMPTY
56298: LIST
56299: LIST
56300: PUSH
56301: EMPTY
56302: LIST
56303: LIST
56304: LIST
56305: PUSH
56306: LD_INT 24
56308: PUSH
56309: LD_INT 25
56311: PUSH
56312: EMPTY
56313: LIST
56314: LIST
56315: PUSH
56316: LD_INT 23
56318: PUSH
56319: LD_INT 27
56321: PUSH
56322: EMPTY
56323: LIST
56324: LIST
56325: PUSH
56326: EMPTY
56327: LIST
56328: LIST
56329: PUSH
56330: LD_INT 42
56332: PUSH
56333: LD_INT 43
56335: PUSH
56336: EMPTY
56337: LIST
56338: LIST
56339: PUSH
56340: LD_INT 44
56342: PUSH
56343: LD_INT 46
56345: PUSH
56346: EMPTY
56347: LIST
56348: LIST
56349: PUSH
56350: LD_INT 45
56352: PUSH
56353: LD_INT 47
56355: PUSH
56356: EMPTY
56357: LIST
56358: LIST
56359: PUSH
56360: EMPTY
56361: LIST
56362: LIST
56363: LIST
56364: PUSH
56365: EMPTY
56366: LIST
56367: LIST
56368: LIST
56369: ST_TO_ADDR
// result := [ ] ;
56370: LD_ADDR_VAR 0 3
56374: PUSH
56375: EMPTY
56376: ST_TO_ADDR
// for i in turrets do
56377: LD_ADDR_VAR 0 4
56381: PUSH
56382: LD_VAR 0 1
56386: PUSH
56387: FOR_IN
56388: IFFALSE 56571
// begin nat := GetNation ( i ) ;
56390: LD_ADDR_VAR 0 7
56394: PUSH
56395: LD_VAR 0 4
56399: PPUSH
56400: CALL_OW 248
56404: ST_TO_ADDR
// weapon := 0 ;
56405: LD_ADDR_VAR 0 8
56409: PUSH
56410: LD_INT 0
56412: ST_TO_ADDR
// if not nat then
56413: LD_VAR 0 7
56417: NOT
56418: IFFALSE 56422
// continue ;
56420: GO 56387
// for j in list [ nat ] do
56422: LD_ADDR_VAR 0 5
56426: PUSH
56427: LD_VAR 0 10
56431: PUSH
56432: LD_VAR 0 7
56436: ARRAY
56437: PUSH
56438: FOR_IN
56439: IFFALSE 56480
// if GetBWeapon ( i ) = j [ 1 ] then
56441: LD_VAR 0 4
56445: PPUSH
56446: CALL_OW 269
56450: PUSH
56451: LD_VAR 0 5
56455: PUSH
56456: LD_INT 1
56458: ARRAY
56459: EQUAL
56460: IFFALSE 56478
// begin weapon := j [ 2 ] ;
56462: LD_ADDR_VAR 0 8
56466: PUSH
56467: LD_VAR 0 5
56471: PUSH
56472: LD_INT 2
56474: ARRAY
56475: ST_TO_ADDR
// break ;
56476: GO 56480
// end ;
56478: GO 56438
56480: POP
56481: POP
// if not weapon then
56482: LD_VAR 0 8
56486: NOT
56487: IFFALSE 56491
// continue ;
56489: GO 56387
// for k in factories do
56491: LD_ADDR_VAR 0 6
56495: PUSH
56496: LD_VAR 0 2
56500: PUSH
56501: FOR_IN
56502: IFFALSE 56567
// begin weapons := AvailableWeaponList ( k ) ;
56504: LD_ADDR_VAR 0 9
56508: PUSH
56509: LD_VAR 0 6
56513: PPUSH
56514: CALL_OW 478
56518: ST_TO_ADDR
// if not weapons then
56519: LD_VAR 0 9
56523: NOT
56524: IFFALSE 56528
// continue ;
56526: GO 56501
// if weapon in weapons then
56528: LD_VAR 0 8
56532: PUSH
56533: LD_VAR 0 9
56537: IN
56538: IFFALSE 56565
// begin result := [ i , weapon ] ;
56540: LD_ADDR_VAR 0 3
56544: PUSH
56545: LD_VAR 0 4
56549: PUSH
56550: LD_VAR 0 8
56554: PUSH
56555: EMPTY
56556: LIST
56557: LIST
56558: ST_TO_ADDR
// exit ;
56559: POP
56560: POP
56561: POP
56562: POP
56563: GO 56573
// end ; end ;
56565: GO 56501
56567: POP
56568: POP
// end ;
56569: GO 56387
56571: POP
56572: POP
// end ;
56573: LD_VAR 0 3
56577: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
56578: LD_INT 0
56580: PPUSH
// if not side or side > 8 then
56581: LD_VAR 0 3
56585: NOT
56586: PUSH
56587: LD_VAR 0 3
56591: PUSH
56592: LD_INT 8
56594: GREATER
56595: OR
56596: IFFALSE 56600
// exit ;
56598: GO 56659
// if not range then
56600: LD_VAR 0 4
56604: NOT
56605: IFFALSE 56616
// range := - 12 ;
56607: LD_ADDR_VAR 0 4
56611: PUSH
56612: LD_INT 12
56614: NEG
56615: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
56616: LD_VAR 0 1
56620: PPUSH
56621: LD_VAR 0 2
56625: PPUSH
56626: LD_VAR 0 3
56630: PPUSH
56631: LD_VAR 0 4
56635: PPUSH
56636: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
56640: LD_VAR 0 1
56644: PPUSH
56645: LD_VAR 0 2
56649: PPUSH
56650: LD_VAR 0 3
56654: PPUSH
56655: CALL_OW 331
// end ;
56659: LD_VAR 0 5
56663: RET
// export function Video ( mode ) ; begin
56664: LD_INT 0
56666: PPUSH
// ingame_video = mode ;
56667: LD_ADDR_OWVAR 52
56671: PUSH
56672: LD_VAR 0 1
56676: ST_TO_ADDR
// interface_hidden = mode ;
56677: LD_ADDR_OWVAR 54
56681: PUSH
56682: LD_VAR 0 1
56686: ST_TO_ADDR
// end ;
56687: LD_VAR 0 2
56691: RET
// export function Join ( array , element ) ; begin
56692: LD_INT 0
56694: PPUSH
// result := Replace ( array , array + 1 , element ) ;
56695: LD_ADDR_VAR 0 3
56699: PUSH
56700: LD_VAR 0 1
56704: PPUSH
56705: LD_VAR 0 1
56709: PUSH
56710: LD_INT 1
56712: PLUS
56713: PPUSH
56714: LD_VAR 0 2
56718: PPUSH
56719: CALL_OW 1
56723: ST_TO_ADDR
// end ;
56724: LD_VAR 0 3
56728: RET
// export function JoinUnion ( array , element ) ; begin
56729: LD_INT 0
56731: PPUSH
// result := array union element ;
56732: LD_ADDR_VAR 0 3
56736: PUSH
56737: LD_VAR 0 1
56741: PUSH
56742: LD_VAR 0 2
56746: UNION
56747: ST_TO_ADDR
// end ;
56748: LD_VAR 0 3
56752: RET
// export function GetBehemoths ( side ) ; begin
56753: LD_INT 0
56755: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , ru_behemoth ] ] ) ;
56756: LD_ADDR_VAR 0 2
56760: PUSH
56761: LD_INT 22
56763: PUSH
56764: LD_VAR 0 1
56768: PUSH
56769: EMPTY
56770: LIST
56771: LIST
56772: PUSH
56773: LD_INT 31
56775: PUSH
56776: LD_INT 25
56778: PUSH
56779: EMPTY
56780: LIST
56781: LIST
56782: PUSH
56783: EMPTY
56784: LIST
56785: LIST
56786: PPUSH
56787: CALL_OW 69
56791: ST_TO_ADDR
// end ;
56792: LD_VAR 0 2
56796: RET
// export function Shuffle ( array ) ; var i , index ; begin
56797: LD_INT 0
56799: PPUSH
56800: PPUSH
56801: PPUSH
// result := [ ] ;
56802: LD_ADDR_VAR 0 2
56806: PUSH
56807: EMPTY
56808: ST_TO_ADDR
// if not array then
56809: LD_VAR 0 1
56813: NOT
56814: IFFALSE 56818
// exit ;
56816: GO 56917
// Randomize ;
56818: CALL_OW 10
// for i = array downto 1 do
56822: LD_ADDR_VAR 0 3
56826: PUSH
56827: DOUBLE
56828: LD_VAR 0 1
56832: INC
56833: ST_TO_ADDR
56834: LD_INT 1
56836: PUSH
56837: FOR_DOWNTO
56838: IFFALSE 56915
// begin index := rand ( 1 , array ) ;
56840: LD_ADDR_VAR 0 4
56844: PUSH
56845: LD_INT 1
56847: PPUSH
56848: LD_VAR 0 1
56852: PPUSH
56853: CALL_OW 12
56857: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
56858: LD_ADDR_VAR 0 2
56862: PUSH
56863: LD_VAR 0 2
56867: PPUSH
56868: LD_VAR 0 2
56872: PUSH
56873: LD_INT 1
56875: PLUS
56876: PPUSH
56877: LD_VAR 0 1
56881: PUSH
56882: LD_VAR 0 4
56886: ARRAY
56887: PPUSH
56888: CALL_OW 2
56892: ST_TO_ADDR
// array := Delete ( array , index ) ;
56893: LD_ADDR_VAR 0 1
56897: PUSH
56898: LD_VAR 0 1
56902: PPUSH
56903: LD_VAR 0 4
56907: PPUSH
56908: CALL_OW 3
56912: ST_TO_ADDR
// end ;
56913: GO 56837
56915: POP
56916: POP
// end ;
56917: LD_VAR 0 2
56921: RET
// export function GetBaseMaterials ( base ) ; begin
56922: LD_INT 0
56924: PPUSH
// result := [ 0 , 0 , 0 ] ;
56925: LD_ADDR_VAR 0 2
56929: PUSH
56930: LD_INT 0
56932: PUSH
56933: LD_INT 0
56935: PUSH
56936: LD_INT 0
56938: PUSH
56939: EMPTY
56940: LIST
56941: LIST
56942: LIST
56943: ST_TO_ADDR
// if not base then
56944: LD_VAR 0 1
56948: NOT
56949: IFFALSE 56953
// exit ;
56951: GO 57002
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
56953: LD_ADDR_VAR 0 2
56957: PUSH
56958: LD_VAR 0 1
56962: PPUSH
56963: LD_INT 1
56965: PPUSH
56966: CALL_OW 275
56970: PUSH
56971: LD_VAR 0 1
56975: PPUSH
56976: LD_INT 2
56978: PPUSH
56979: CALL_OW 275
56983: PUSH
56984: LD_VAR 0 1
56988: PPUSH
56989: LD_INT 3
56991: PPUSH
56992: CALL_OW 275
56996: PUSH
56997: EMPTY
56998: LIST
56999: LIST
57000: LIST
57001: ST_TO_ADDR
// end ;
57002: LD_VAR 0 2
57006: RET
// export function ShrinkArray ( array , size ) ; var i ; begin
57007: LD_INT 0
57009: PPUSH
57010: PPUSH
// result := array ;
57011: LD_ADDR_VAR 0 3
57015: PUSH
57016: LD_VAR 0 1
57020: ST_TO_ADDR
// if size >= result then
57021: LD_VAR 0 2
57025: PUSH
57026: LD_VAR 0 3
57030: GREATEREQUAL
57031: IFFALSE 57035
// exit ;
57033: GO 57085
// if size then
57035: LD_VAR 0 2
57039: IFFALSE 57085
// for i := array downto size do
57041: LD_ADDR_VAR 0 4
57045: PUSH
57046: DOUBLE
57047: LD_VAR 0 1
57051: INC
57052: ST_TO_ADDR
57053: LD_VAR 0 2
57057: PUSH
57058: FOR_DOWNTO
57059: IFFALSE 57083
// result := Delete ( result , result ) ;
57061: LD_ADDR_VAR 0 3
57065: PUSH
57066: LD_VAR 0 3
57070: PPUSH
57071: LD_VAR 0 3
57075: PPUSH
57076: CALL_OW 3
57080: ST_TO_ADDR
57081: GO 57058
57083: POP
57084: POP
// end ;
57085: LD_VAR 0 3
57089: RET
// export function ComExit ( unit ) ; var tmp ; begin
57090: LD_INT 0
57092: PPUSH
57093: PPUSH
// if not IsInUnit ( unit ) then
57094: LD_VAR 0 1
57098: PPUSH
57099: CALL_OW 310
57103: NOT
57104: IFFALSE 57108
// exit ;
57106: GO 57168
// tmp := IsInUnit ( unit ) ;
57108: LD_ADDR_VAR 0 3
57112: PUSH
57113: LD_VAR 0 1
57117: PPUSH
57118: CALL_OW 310
57122: ST_TO_ADDR
// if GetType ( tmp ) = unit_vehicle then
57123: LD_VAR 0 3
57127: PPUSH
57128: CALL_OW 247
57132: PUSH
57133: LD_INT 2
57135: EQUAL
57136: IFFALSE 57149
// ComExitVehicle ( unit ) else
57138: LD_VAR 0 1
57142: PPUSH
57143: CALL_OW 121
57147: GO 57158
// ComExitBuilding ( unit ) ;
57149: LD_VAR 0 1
57153: PPUSH
57154: CALL_OW 122
// result := tmp ;
57158: LD_ADDR_VAR 0 2
57162: PUSH
57163: LD_VAR 0 3
57167: ST_TO_ADDR
// end ;
57168: LD_VAR 0 2
57172: RET
// export function ComExitAll ( units ) ; var i ; begin
57173: LD_INT 0
57175: PPUSH
57176: PPUSH
// if not units then
57177: LD_VAR 0 1
57181: NOT
57182: IFFALSE 57186
// exit ;
57184: GO 57212
// for i in units do
57186: LD_ADDR_VAR 0 3
57190: PUSH
57191: LD_VAR 0 1
57195: PUSH
57196: FOR_IN
57197: IFFALSE 57210
// ComExit ( i ) ;
57199: LD_VAR 0 3
57203: PPUSH
57204: CALL 57090 0 1
57208: GO 57196
57210: POP
57211: POP
// end ;
57212: LD_VAR 0 2
57216: RET
// export function ResetHc ; begin
57217: LD_INT 0
57219: PPUSH
// InitHc ;
57220: CALL_OW 19
// hc_importance := 0 ;
57224: LD_ADDR_OWVAR 32
57228: PUSH
57229: LD_INT 0
57231: ST_TO_ADDR
// end ;
57232: LD_VAR 0 1
57236: RET
// export function PointBetweenXY ( x1 , y1 , x2 , y2 ) ; var _x , _y ; begin
57237: LD_INT 0
57239: PPUSH
57240: PPUSH
57241: PPUSH
// _x := ( x1 + x2 ) div 2 ;
57242: LD_ADDR_VAR 0 6
57246: PUSH
57247: LD_VAR 0 1
57251: PUSH
57252: LD_VAR 0 3
57256: PLUS
57257: PUSH
57258: LD_INT 2
57260: DIV
57261: ST_TO_ADDR
// if _x < 0 then
57262: LD_VAR 0 6
57266: PUSH
57267: LD_INT 0
57269: LESS
57270: IFFALSE 57287
// _x := _x * - 1 ;
57272: LD_ADDR_VAR 0 6
57276: PUSH
57277: LD_VAR 0 6
57281: PUSH
57282: LD_INT 1
57284: NEG
57285: MUL
57286: ST_TO_ADDR
// _y := ( y1 + y2 ) div 2 ;
57287: LD_ADDR_VAR 0 7
57291: PUSH
57292: LD_VAR 0 2
57296: PUSH
57297: LD_VAR 0 4
57301: PLUS
57302: PUSH
57303: LD_INT 2
57305: DIV
57306: ST_TO_ADDR
// if _y < 0 then
57307: LD_VAR 0 7
57311: PUSH
57312: LD_INT 0
57314: LESS
57315: IFFALSE 57332
// _y := _y * - 1 ;
57317: LD_ADDR_VAR 0 7
57321: PUSH
57322: LD_VAR 0 7
57326: PUSH
57327: LD_INT 1
57329: NEG
57330: MUL
57331: ST_TO_ADDR
// result := [ _x , _y ] ;
57332: LD_ADDR_VAR 0 5
57336: PUSH
57337: LD_VAR 0 6
57341: PUSH
57342: LD_VAR 0 7
57346: PUSH
57347: EMPTY
57348: LIST
57349: LIST
57350: ST_TO_ADDR
// end ;
57351: LD_VAR 0 5
57355: RET
// export function NotGoToAreaUnit ( unit , area , goAway ) ; var x , y , task ; begin
57356: LD_INT 0
57358: PPUSH
57359: PPUSH
57360: PPUSH
57361: PPUSH
// task := GetTaskList ( unit ) ;
57362: LD_ADDR_VAR 0 7
57366: PUSH
57367: LD_VAR 0 1
57371: PPUSH
57372: CALL_OW 437
57376: ST_TO_ADDR
// if not task and not IsInArea ( unit , area ) then
57377: LD_VAR 0 7
57381: NOT
57382: PUSH
57383: LD_VAR 0 1
57387: PPUSH
57388: LD_VAR 0 2
57392: PPUSH
57393: CALL_OW 308
57397: NOT
57398: AND
57399: IFFALSE 57403
// exit ;
57401: GO 57521
// if IsInArea ( unit , area ) then
57403: LD_VAR 0 1
57407: PPUSH
57408: LD_VAR 0 2
57412: PPUSH
57413: CALL_OW 308
57417: IFFALSE 57435
// begin ComMoveToArea ( unit , goAway ) ;
57419: LD_VAR 0 1
57423: PPUSH
57424: LD_VAR 0 3
57428: PPUSH
57429: CALL_OW 113
// exit ;
57433: GO 57521
// end ; if task [ 1 ] [ 1 ] <> M then
57435: LD_VAR 0 7
57439: PUSH
57440: LD_INT 1
57442: ARRAY
57443: PUSH
57444: LD_INT 1
57446: ARRAY
57447: PUSH
57448: LD_STRING M
57450: NONEQUAL
57451: IFFALSE 57455
// exit ;
57453: GO 57521
// x := task [ 1 ] [ 2 ] ;
57455: LD_ADDR_VAR 0 5
57459: PUSH
57460: LD_VAR 0 7
57464: PUSH
57465: LD_INT 1
57467: ARRAY
57468: PUSH
57469: LD_INT 2
57471: ARRAY
57472: ST_TO_ADDR
// y := task [ 1 ] [ 3 ] ;
57473: LD_ADDR_VAR 0 6
57477: PUSH
57478: LD_VAR 0 7
57482: PUSH
57483: LD_INT 1
57485: ARRAY
57486: PUSH
57487: LD_INT 3
57489: ARRAY
57490: ST_TO_ADDR
// if InArea ( x , y , area ) then
57491: LD_VAR 0 5
57495: PPUSH
57496: LD_VAR 0 6
57500: PPUSH
57501: LD_VAR 0 2
57505: PPUSH
57506: CALL_OW 309
57510: IFFALSE 57521
// ComStop ( unit ) ;
57512: LD_VAR 0 1
57516: PPUSH
57517: CALL_OW 141
// end ;
57521: LD_VAR 0 4
57525: RET
// export function Abs ( value ) ; begin
57526: LD_INT 0
57528: PPUSH
// result := value ;
57529: LD_ADDR_VAR 0 2
57533: PUSH
57534: LD_VAR 0 1
57538: ST_TO_ADDR
// if value < 0 then
57539: LD_VAR 0 1
57543: PUSH
57544: LD_INT 0
57546: LESS
57547: IFFALSE 57564
// result := value * - 1 ;
57549: LD_ADDR_VAR 0 2
57553: PUSH
57554: LD_VAR 0 1
57558: PUSH
57559: LD_INT 1
57561: NEG
57562: MUL
57563: ST_TO_ADDR
// end ;
57564: LD_VAR 0 2
57568: RET
// export function ComMoveToNearbyEntrance ( unit , building ) ; var x , _x , y , _y , d , r , i ; begin
57569: LD_INT 0
57571: PPUSH
57572: PPUSH
57573: PPUSH
57574: PPUSH
57575: PPUSH
57576: PPUSH
57577: PPUSH
57578: PPUSH
// if not unit or not building then
57579: LD_VAR 0 1
57583: NOT
57584: PUSH
57585: LD_VAR 0 2
57589: NOT
57590: OR
57591: IFFALSE 57595
// exit ;
57593: GO 57821
// x := GetX ( building ) ;
57595: LD_ADDR_VAR 0 4
57599: PUSH
57600: LD_VAR 0 2
57604: PPUSH
57605: CALL_OW 250
57609: ST_TO_ADDR
// y := GetY ( building ) ;
57610: LD_ADDR_VAR 0 6
57614: PUSH
57615: LD_VAR 0 2
57619: PPUSH
57620: CALL_OW 251
57624: ST_TO_ADDR
// d := GetDir ( building ) ;
57625: LD_ADDR_VAR 0 8
57629: PUSH
57630: LD_VAR 0 2
57634: PPUSH
57635: CALL_OW 254
57639: ST_TO_ADDR
// r := 4 ;
57640: LD_ADDR_VAR 0 9
57644: PUSH
57645: LD_INT 4
57647: ST_TO_ADDR
// for i := 1 to 5 do
57648: LD_ADDR_VAR 0 10
57652: PUSH
57653: DOUBLE
57654: LD_INT 1
57656: DEC
57657: ST_TO_ADDR
57658: LD_INT 5
57660: PUSH
57661: FOR_TO
57662: IFFALSE 57819
// begin _x := ShiftX ( x , d , r + i ) ;
57664: LD_ADDR_VAR 0 5
57668: PUSH
57669: LD_VAR 0 4
57673: PPUSH
57674: LD_VAR 0 8
57678: PPUSH
57679: LD_VAR 0 9
57683: PUSH
57684: LD_VAR 0 10
57688: PLUS
57689: PPUSH
57690: CALL_OW 272
57694: ST_TO_ADDR
// _y := ShiftY ( y , d , r + i ) ;
57695: LD_ADDR_VAR 0 7
57699: PUSH
57700: LD_VAR 0 6
57704: PPUSH
57705: LD_VAR 0 8
57709: PPUSH
57710: LD_VAR 0 9
57714: PUSH
57715: LD_VAR 0 10
57719: PLUS
57720: PPUSH
57721: CALL_OW 273
57725: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not GetType ( HexInfo ( _x , _y ) ) in [ unit_building , unit_vehicle ] then
57726: LD_VAR 0 5
57730: PPUSH
57731: LD_VAR 0 7
57735: PPUSH
57736: CALL_OW 488
57740: PUSH
57741: LD_VAR 0 5
57745: PPUSH
57746: LD_VAR 0 7
57750: PPUSH
57751: CALL_OW 428
57755: PPUSH
57756: CALL_OW 247
57760: PUSH
57761: LD_INT 3
57763: PUSH
57764: LD_INT 2
57766: PUSH
57767: EMPTY
57768: LIST
57769: LIST
57770: IN
57771: NOT
57772: AND
57773: IFFALSE 57817
// begin ComMoveXY ( unit , _x , _y ) ;
57775: LD_VAR 0 1
57779: PPUSH
57780: LD_VAR 0 5
57784: PPUSH
57785: LD_VAR 0 7
57789: PPUSH
57790: CALL_OW 111
// result := [ _x , _y ] ;
57794: LD_ADDR_VAR 0 3
57798: PUSH
57799: LD_VAR 0 5
57803: PUSH
57804: LD_VAR 0 7
57808: PUSH
57809: EMPTY
57810: LIST
57811: LIST
57812: ST_TO_ADDR
// exit ;
57813: POP
57814: POP
57815: GO 57821
// end ; end ;
57817: GO 57661
57819: POP
57820: POP
// end ;
57821: LD_VAR 0 3
57825: RET
// export function SideAttackedSide ( side1 , side2 ) ; var i , un ; begin
57826: LD_INT 0
57828: PPUSH
57829: PPUSH
57830: PPUSH
// result := 0 ;
57831: LD_ADDR_VAR 0 3
57835: PUSH
57836: LD_INT 0
57838: ST_TO_ADDR
// if side1 < 0 or side1 > 8 or side2 < 0 or side2 > 8 then
57839: LD_VAR 0 1
57843: PUSH
57844: LD_INT 0
57846: LESS
57847: PUSH
57848: LD_VAR 0 1
57852: PUSH
57853: LD_INT 8
57855: GREATER
57856: OR
57857: PUSH
57858: LD_VAR 0 2
57862: PUSH
57863: LD_INT 0
57865: LESS
57866: OR
57867: PUSH
57868: LD_VAR 0 2
57872: PUSH
57873: LD_INT 8
57875: GREATER
57876: OR
57877: IFFALSE 57881
// exit ;
57879: GO 57956
// for i in FilterAllUnits ( [ f_side , side2 ] ) do
57881: LD_ADDR_VAR 0 4
57885: PUSH
57886: LD_INT 22
57888: PUSH
57889: LD_VAR 0 2
57893: PUSH
57894: EMPTY
57895: LIST
57896: LIST
57897: PPUSH
57898: CALL_OW 69
57902: PUSH
57903: FOR_IN
57904: IFFALSE 57954
// begin un := UnitShoot ( i ) ;
57906: LD_ADDR_VAR 0 5
57910: PUSH
57911: LD_VAR 0 4
57915: PPUSH
57916: CALL_OW 504
57920: ST_TO_ADDR
// if GetSide ( un ) = side1 then
57921: LD_VAR 0 5
57925: PPUSH
57926: CALL_OW 255
57930: PUSH
57931: LD_VAR 0 1
57935: EQUAL
57936: IFFALSE 57952
// begin result := un ;
57938: LD_ADDR_VAR 0 3
57942: PUSH
57943: LD_VAR 0 5
57947: ST_TO_ADDR
// exit ;
57948: POP
57949: POP
57950: GO 57956
// end ; end ;
57952: GO 57903
57954: POP
57955: POP
// end ;
57956: LD_VAR 0 3
57960: RET
// export function GetCargoBay ( units ) ; begin
57961: LD_INT 0
57963: PPUSH
// result := UnitFilter ( units , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ) ;
57964: LD_ADDR_VAR 0 2
57968: PUSH
57969: LD_VAR 0 1
57973: PPUSH
57974: LD_INT 2
57976: PUSH
57977: LD_INT 34
57979: PUSH
57980: LD_INT 12
57982: PUSH
57983: EMPTY
57984: LIST
57985: LIST
57986: PUSH
57987: LD_INT 34
57989: PUSH
57990: LD_INT 51
57992: PUSH
57993: EMPTY
57994: LIST
57995: LIST
57996: PUSH
57997: LD_INT 34
57999: PUSH
58000: LD_INT 32
58002: PUSH
58003: EMPTY
58004: LIST
58005: LIST
58006: PUSH
58007: LD_INT 34
58009: PUSH
58010: LD_INT 89
58012: PUSH
58013: EMPTY
58014: LIST
58015: LIST
58016: PUSH
58017: EMPTY
58018: LIST
58019: LIST
58020: LIST
58021: LIST
58022: LIST
58023: PPUSH
58024: CALL_OW 72
58028: ST_TO_ADDR
// end ;
58029: LD_VAR 0 2
58033: RET
// export function Negate ( value ) ; begin
58034: LD_INT 0
58036: PPUSH
// result := not value ;
58037: LD_ADDR_VAR 0 2
58041: PUSH
58042: LD_VAR 0 1
58046: NOT
58047: ST_TO_ADDR
// end ;
58048: LD_VAR 0 2
58052: RET
// export function Inc ( value ) ; begin
58053: LD_INT 0
58055: PPUSH
// result := value + 1 ;
58056: LD_ADDR_VAR 0 2
58060: PUSH
58061: LD_VAR 0 1
58065: PUSH
58066: LD_INT 1
58068: PLUS
58069: ST_TO_ADDR
// end ;
58070: LD_VAR 0 2
58074: RET
// export function Dec ( value ) ; begin
58075: LD_INT 0
58077: PPUSH
// result := value - 1 ;
58078: LD_ADDR_VAR 0 2
58082: PUSH
58083: LD_VAR 0 1
58087: PUSH
58088: LD_INT 1
58090: MINUS
58091: ST_TO_ADDR
// end ;
58092: LD_VAR 0 2
58096: RET
// export function GetDirFromHex ( x1 , y1 , x2 , y2 ) ; var i , _x , _y , tmp , distance , centerDist , centerPoint ; begin
58097: LD_INT 0
58099: PPUSH
58100: PPUSH
58101: PPUSH
58102: PPUSH
58103: PPUSH
58104: PPUSH
58105: PPUSH
58106: PPUSH
// if not ValidHex ( x1 , y1 ) or not ValidHex ( x2 , y2 ) then
58107: LD_VAR 0 1
58111: PPUSH
58112: LD_VAR 0 2
58116: PPUSH
58117: CALL_OW 488
58121: NOT
58122: PUSH
58123: LD_VAR 0 3
58127: PPUSH
58128: LD_VAR 0 4
58132: PPUSH
58133: CALL_OW 488
58137: NOT
58138: OR
58139: IFFALSE 58152
// begin result := - 1 ;
58141: LD_ADDR_VAR 0 5
58145: PUSH
58146: LD_INT 1
58148: NEG
58149: ST_TO_ADDR
// exit ;
58150: GO 58387
// end ; centerPoint := PointBetweenXY ( x1 , y1 , x2 , y2 ) ;
58152: LD_ADDR_VAR 0 12
58156: PUSH
58157: LD_VAR 0 1
58161: PPUSH
58162: LD_VAR 0 2
58166: PPUSH
58167: LD_VAR 0 3
58171: PPUSH
58172: LD_VAR 0 4
58176: PPUSH
58177: CALL 57237 0 4
58181: ST_TO_ADDR
// centerDist := GetDistXY ( x1 , y1 , centerPoint [ 1 ] , centerPoint [ 2 ] ) ;
58182: LD_ADDR_VAR 0 11
58186: PUSH
58187: LD_VAR 0 1
58191: PPUSH
58192: LD_VAR 0 2
58196: PPUSH
58197: LD_VAR 0 12
58201: PUSH
58202: LD_INT 1
58204: ARRAY
58205: PPUSH
58206: LD_VAR 0 12
58210: PUSH
58211: LD_INT 2
58213: ARRAY
58214: PPUSH
58215: CALL_OW 298
58219: ST_TO_ADDR
// distance := 9999 ;
58220: LD_ADDR_VAR 0 10
58224: PUSH
58225: LD_INT 9999
58227: ST_TO_ADDR
// for i := 0 to 5 do
58228: LD_ADDR_VAR 0 6
58232: PUSH
58233: DOUBLE
58234: LD_INT 0
58236: DEC
58237: ST_TO_ADDR
58238: LD_INT 5
58240: PUSH
58241: FOR_TO
58242: IFFALSE 58385
// begin _x := ShiftX ( x1 , i , centerDist ) ;
58244: LD_ADDR_VAR 0 7
58248: PUSH
58249: LD_VAR 0 1
58253: PPUSH
58254: LD_VAR 0 6
58258: PPUSH
58259: LD_VAR 0 11
58263: PPUSH
58264: CALL_OW 272
58268: ST_TO_ADDR
// _y := ShiftY ( y1 , i , centerDist ) ;
58269: LD_ADDR_VAR 0 8
58273: PUSH
58274: LD_VAR 0 2
58278: PPUSH
58279: LD_VAR 0 6
58283: PPUSH
58284: LD_VAR 0 11
58288: PPUSH
58289: CALL_OW 273
58293: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
58294: LD_VAR 0 7
58298: PPUSH
58299: LD_VAR 0 8
58303: PPUSH
58304: CALL_OW 488
58308: NOT
58309: IFFALSE 58313
// continue ;
58311: GO 58241
// tmp := GetDistXY ( centerPoint [ 1 ] , centerPoint [ 2 ] , _x , _y ) ;
58313: LD_ADDR_VAR 0 9
58317: PUSH
58318: LD_VAR 0 12
58322: PUSH
58323: LD_INT 1
58325: ARRAY
58326: PPUSH
58327: LD_VAR 0 12
58331: PUSH
58332: LD_INT 2
58334: ARRAY
58335: PPUSH
58336: LD_VAR 0 7
58340: PPUSH
58341: LD_VAR 0 8
58345: PPUSH
58346: CALL_OW 298
58350: ST_TO_ADDR
// if tmp < distance then
58351: LD_VAR 0 9
58355: PUSH
58356: LD_VAR 0 10
58360: LESS
58361: IFFALSE 58383
// begin result := i ;
58363: LD_ADDR_VAR 0 5
58367: PUSH
58368: LD_VAR 0 6
58372: ST_TO_ADDR
// distance := tmp ;
58373: LD_ADDR_VAR 0 10
58377: PUSH
58378: LD_VAR 0 9
58382: ST_TO_ADDR
// end ; end ;
58383: GO 58241
58385: POP
58386: POP
// end ;
58387: LD_VAR 0 5
58391: RET
// export function ComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
58392: LD_INT 0
58394: PPUSH
58395: PPUSH
// if not driver or not IsInUnit ( driver ) then
58396: LD_VAR 0 1
58400: NOT
58401: PUSH
58402: LD_VAR 0 1
58406: PPUSH
58407: CALL_OW 310
58411: NOT
58412: OR
58413: IFFALSE 58417
// exit ;
58415: GO 58507
// vehicle := IsInUnit ( driver ) ;
58417: LD_ADDR_VAR 0 3
58421: PUSH
58422: LD_VAR 0 1
58426: PPUSH
58427: CALL_OW 310
58431: ST_TO_ADDR
// SetTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
58432: LD_VAR 0 1
58436: PPUSH
58437: LD_STRING \
58439: PUSH
58440: LD_INT 0
58442: PUSH
58443: LD_INT 0
58445: PUSH
58446: LD_INT 0
58448: PUSH
58449: LD_INT 0
58451: PUSH
58452: LD_INT 0
58454: PUSH
58455: LD_INT 0
58457: PUSH
58458: EMPTY
58459: LIST
58460: LIST
58461: LIST
58462: LIST
58463: LIST
58464: LIST
58465: LIST
58466: PUSH
58467: LD_STRING E
58469: PUSH
58470: LD_INT 0
58472: PUSH
58473: LD_INT 0
58475: PUSH
58476: LD_VAR 0 3
58480: PUSH
58481: LD_INT 0
58483: PUSH
58484: LD_INT 0
58486: PUSH
58487: LD_INT 0
58489: PUSH
58490: EMPTY
58491: LIST
58492: LIST
58493: LIST
58494: LIST
58495: LIST
58496: LIST
58497: LIST
58498: PUSH
58499: EMPTY
58500: LIST
58501: LIST
58502: PPUSH
58503: CALL_OW 446
// end ;
58507: LD_VAR 0 2
58511: RET
// export function AddComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
58512: LD_INT 0
58514: PPUSH
58515: PPUSH
// if not driver or not IsInUnit ( driver ) then
58516: LD_VAR 0 1
58520: NOT
58521: PUSH
58522: LD_VAR 0 1
58526: PPUSH
58527: CALL_OW 310
58531: NOT
58532: OR
58533: IFFALSE 58537
// exit ;
58535: GO 58627
// vehicle := IsInUnit ( driver ) ;
58537: LD_ADDR_VAR 0 3
58541: PUSH
58542: LD_VAR 0 1
58546: PPUSH
58547: CALL_OW 310
58551: ST_TO_ADDR
// AddTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
58552: LD_VAR 0 1
58556: PPUSH
58557: LD_STRING \
58559: PUSH
58560: LD_INT 0
58562: PUSH
58563: LD_INT 0
58565: PUSH
58566: LD_INT 0
58568: PUSH
58569: LD_INT 0
58571: PUSH
58572: LD_INT 0
58574: PUSH
58575: LD_INT 0
58577: PUSH
58578: EMPTY
58579: LIST
58580: LIST
58581: LIST
58582: LIST
58583: LIST
58584: LIST
58585: LIST
58586: PUSH
58587: LD_STRING E
58589: PUSH
58590: LD_INT 0
58592: PUSH
58593: LD_INT 0
58595: PUSH
58596: LD_VAR 0 3
58600: PUSH
58601: LD_INT 0
58603: PUSH
58604: LD_INT 0
58606: PUSH
58607: LD_INT 0
58609: PUSH
58610: EMPTY
58611: LIST
58612: LIST
58613: LIST
58614: LIST
58615: LIST
58616: LIST
58617: LIST
58618: PUSH
58619: EMPTY
58620: LIST
58621: LIST
58622: PPUSH
58623: CALL_OW 447
// end ;
58627: LD_VAR 0 2
58631: RET
// export function SortByHealth ( units , asc ) ; var i , tmp ; begin
58632: LD_INT 0
58634: PPUSH
58635: PPUSH
58636: PPUSH
// tmp := [ ] ;
58637: LD_ADDR_VAR 0 5
58641: PUSH
58642: EMPTY
58643: ST_TO_ADDR
// for i in units do
58644: LD_ADDR_VAR 0 4
58648: PUSH
58649: LD_VAR 0 1
58653: PUSH
58654: FOR_IN
58655: IFFALSE 58693
// tmp := Insert ( tmp , tmp + 1 , GetLives ( i ) ) ;
58657: LD_ADDR_VAR 0 5
58661: PUSH
58662: LD_VAR 0 5
58666: PPUSH
58667: LD_VAR 0 5
58671: PUSH
58672: LD_INT 1
58674: PLUS
58675: PPUSH
58676: LD_VAR 0 4
58680: PPUSH
58681: CALL_OW 256
58685: PPUSH
58686: CALL_OW 2
58690: ST_TO_ADDR
58691: GO 58654
58693: POP
58694: POP
// if not tmp then
58695: LD_VAR 0 5
58699: NOT
58700: IFFALSE 58704
// exit ;
58702: GO 58752
// if asc then
58704: LD_VAR 0 2
58708: IFFALSE 58732
// result := SortListByListAsc ( units , tmp ) else
58710: LD_ADDR_VAR 0 3
58714: PUSH
58715: LD_VAR 0 1
58719: PPUSH
58720: LD_VAR 0 5
58724: PPUSH
58725: CALL_OW 76
58729: ST_TO_ADDR
58730: GO 58752
// result := SortListByListDesc ( units , tmp ) ;
58732: LD_ADDR_VAR 0 3
58736: PUSH
58737: LD_VAR 0 1
58741: PPUSH
58742: LD_VAR 0 5
58746: PPUSH
58747: CALL_OW 77
58751: ST_TO_ADDR
// end ;
58752: LD_VAR 0 3
58756: RET
// export function WantToRepairVehicle ( mech , vehicle ) ; var task ; begin
58757: LD_INT 0
58759: PPUSH
58760: PPUSH
// task := GetTaskList ( mech ) ;
58761: LD_ADDR_VAR 0 4
58765: PUSH
58766: LD_VAR 0 1
58770: PPUSH
58771: CALL_OW 437
58775: ST_TO_ADDR
// if not task then
58776: LD_VAR 0 4
58780: NOT
58781: IFFALSE 58785
// exit ;
58783: GO 58827
// result := task [ 1 ] [ 1 ] = r and task [ 1 ] [ 4 ] = vehicle ;
58785: LD_ADDR_VAR 0 3
58789: PUSH
58790: LD_VAR 0 4
58794: PUSH
58795: LD_INT 1
58797: ARRAY
58798: PUSH
58799: LD_INT 1
58801: ARRAY
58802: PUSH
58803: LD_STRING r
58805: EQUAL
58806: PUSH
58807: LD_VAR 0 4
58811: PUSH
58812: LD_INT 1
58814: ARRAY
58815: PUSH
58816: LD_INT 4
58818: ARRAY
58819: PUSH
58820: LD_VAR 0 2
58824: EQUAL
58825: AND
58826: ST_TO_ADDR
// end ;
58827: LD_VAR 0 3
58831: RET
// export function PlaceUnitXYD ( unit , x , y , d , mode ) ; begin
58832: LD_INT 0
58834: PPUSH
// SetDir ( unit , d ) ;
58835: LD_VAR 0 1
58839: PPUSH
58840: LD_VAR 0 4
58844: PPUSH
58845: CALL_OW 233
// PlaceUnitXY ( unit , x , y , mode ) ;
58849: LD_VAR 0 1
58853: PPUSH
58854: LD_VAR 0 2
58858: PPUSH
58859: LD_VAR 0 3
58863: PPUSH
58864: LD_VAR 0 5
58868: PPUSH
58869: CALL_OW 48
// end ;
58873: LD_VAR 0 6
58877: RET
// export function ToNaturalNumber ( number ) ; begin
58878: LD_INT 0
58880: PPUSH
// result := number div 1 ;
58881: LD_ADDR_VAR 0 2
58885: PUSH
58886: LD_VAR 0 1
58890: PUSH
58891: LD_INT 1
58893: DIV
58894: ST_TO_ADDR
// if number < 0 then
58895: LD_VAR 0 1
58899: PUSH
58900: LD_INT 0
58902: LESS
58903: IFFALSE 58913
// result := 0 ;
58905: LD_ADDR_VAR 0 2
58909: PUSH
58910: LD_INT 0
58912: ST_TO_ADDR
// end ;
58913: LD_VAR 0 2
58917: RET
// export function SortByClass ( units , class ) ; var un ; begin
58918: LD_INT 0
58920: PPUSH
58921: PPUSH
// if not units or not class then
58922: LD_VAR 0 1
58926: NOT
58927: PUSH
58928: LD_VAR 0 2
58932: NOT
58933: OR
58934: IFFALSE 58938
// exit ;
58936: GO 59033
// result := [ ] ;
58938: LD_ADDR_VAR 0 3
58942: PUSH
58943: EMPTY
58944: ST_TO_ADDR
// for un in units do
58945: LD_ADDR_VAR 0 4
58949: PUSH
58950: LD_VAR 0 1
58954: PUSH
58955: FOR_IN
58956: IFFALSE 59031
// if GetClass ( un ) = class then
58958: LD_VAR 0 4
58962: PPUSH
58963: CALL_OW 257
58967: PUSH
58968: LD_VAR 0 2
58972: EQUAL
58973: IFFALSE 59000
// result := Insert ( result , 1 , un ) else
58975: LD_ADDR_VAR 0 3
58979: PUSH
58980: LD_VAR 0 3
58984: PPUSH
58985: LD_INT 1
58987: PPUSH
58988: LD_VAR 0 4
58992: PPUSH
58993: CALL_OW 2
58997: ST_TO_ADDR
58998: GO 59029
// result := Replace ( result , result + 1 , un ) ;
59000: LD_ADDR_VAR 0 3
59004: PUSH
59005: LD_VAR 0 3
59009: PPUSH
59010: LD_VAR 0 3
59014: PUSH
59015: LD_INT 1
59017: PLUS
59018: PPUSH
59019: LD_VAR 0 4
59023: PPUSH
59024: CALL_OW 1
59028: ST_TO_ADDR
59029: GO 58955
59031: POP
59032: POP
// end ;
59033: LD_VAR 0 3
59037: RET
// export function GetCratesNearbyXY ( x , y , r ) ; var _x , _y , min_y , min_x , max_x , max_y ; begin
59038: LD_INT 0
59040: PPUSH
59041: PPUSH
59042: PPUSH
59043: PPUSH
59044: PPUSH
59045: PPUSH
59046: PPUSH
// result := [ ] ;
59047: LD_ADDR_VAR 0 4
59051: PUSH
59052: EMPTY
59053: ST_TO_ADDR
// if x - r < 0 then
59054: LD_VAR 0 1
59058: PUSH
59059: LD_VAR 0 3
59063: MINUS
59064: PUSH
59065: LD_INT 0
59067: LESS
59068: IFFALSE 59080
// min_x := 0 else
59070: LD_ADDR_VAR 0 8
59074: PUSH
59075: LD_INT 0
59077: ST_TO_ADDR
59078: GO 59096
// min_x := x - r ;
59080: LD_ADDR_VAR 0 8
59084: PUSH
59085: LD_VAR 0 1
59089: PUSH
59090: LD_VAR 0 3
59094: MINUS
59095: ST_TO_ADDR
// if y - r < 0 then
59096: LD_VAR 0 2
59100: PUSH
59101: LD_VAR 0 3
59105: MINUS
59106: PUSH
59107: LD_INT 0
59109: LESS
59110: IFFALSE 59122
// min_y := 0 else
59112: LD_ADDR_VAR 0 7
59116: PUSH
59117: LD_INT 0
59119: ST_TO_ADDR
59120: GO 59138
// min_y := y - r ;
59122: LD_ADDR_VAR 0 7
59126: PUSH
59127: LD_VAR 0 2
59131: PUSH
59132: LD_VAR 0 3
59136: MINUS
59137: ST_TO_ADDR
// max_x := x + r ;
59138: LD_ADDR_VAR 0 9
59142: PUSH
59143: LD_VAR 0 1
59147: PUSH
59148: LD_VAR 0 3
59152: PLUS
59153: ST_TO_ADDR
// max_y := y + r ;
59154: LD_ADDR_VAR 0 10
59158: PUSH
59159: LD_VAR 0 2
59163: PUSH
59164: LD_VAR 0 3
59168: PLUS
59169: ST_TO_ADDR
// for _x = min_x to max_x do
59170: LD_ADDR_VAR 0 5
59174: PUSH
59175: DOUBLE
59176: LD_VAR 0 8
59180: DEC
59181: ST_TO_ADDR
59182: LD_VAR 0 9
59186: PUSH
59187: FOR_TO
59188: IFFALSE 59289
// for _y = min_y to max_y do
59190: LD_ADDR_VAR 0 6
59194: PUSH
59195: DOUBLE
59196: LD_VAR 0 7
59200: DEC
59201: ST_TO_ADDR
59202: LD_VAR 0 10
59206: PUSH
59207: FOR_TO
59208: IFFALSE 59285
// begin if not ValidHex ( _x , _y ) then
59210: LD_VAR 0 5
59214: PPUSH
59215: LD_VAR 0 6
59219: PPUSH
59220: CALL_OW 488
59224: NOT
59225: IFFALSE 59229
// continue ;
59227: GO 59207
// if GetResourceTypeXY ( _x , _y ) then
59229: LD_VAR 0 5
59233: PPUSH
59234: LD_VAR 0 6
59238: PPUSH
59239: CALL_OW 283
59243: IFFALSE 59283
// result := Replace ( result , result + 1 , [ _x , _y ] ) ;
59245: LD_ADDR_VAR 0 4
59249: PUSH
59250: LD_VAR 0 4
59254: PPUSH
59255: LD_VAR 0 4
59259: PUSH
59260: LD_INT 1
59262: PLUS
59263: PPUSH
59264: LD_VAR 0 5
59268: PUSH
59269: LD_VAR 0 6
59273: PUSH
59274: EMPTY
59275: LIST
59276: LIST
59277: PPUSH
59278: CALL_OW 1
59282: ST_TO_ADDR
// end ;
59283: GO 59207
59285: POP
59286: POP
59287: GO 59187
59289: POP
59290: POP
// end ;
59291: LD_VAR 0 4
59295: RET
// export function AgressiveMove ( units , path ) ; var i , enemy , nearEnemy , cr , side , tag , ignoreCratesWeapon ; begin
59296: LD_INT 0
59298: PPUSH
59299: PPUSH
59300: PPUSH
59301: PPUSH
59302: PPUSH
59303: PPUSH
59304: PPUSH
59305: PPUSH
// if not units then
59306: LD_VAR 0 1
59310: NOT
59311: IFFALSE 59315
// exit ;
59313: GO 59839
// result := UnitFilter ( units , [ f_ok ] ) ;
59315: LD_ADDR_VAR 0 3
59319: PUSH
59320: LD_VAR 0 1
59324: PPUSH
59325: LD_INT 50
59327: PUSH
59328: EMPTY
59329: LIST
59330: PPUSH
59331: CALL_OW 72
59335: ST_TO_ADDR
// side := GetSide ( units [ 1 ] ) ;
59336: LD_ADDR_VAR 0 8
59340: PUSH
59341: LD_VAR 0 1
59345: PUSH
59346: LD_INT 1
59348: ARRAY
59349: PPUSH
59350: CALL_OW 255
59354: ST_TO_ADDR
// ignoreCratesWeapon := [ ar_selfpropelled_bomb , ar_bio_bomb , ru_time_lapser ] ;
59355: LD_ADDR_VAR 0 10
59359: PUSH
59360: LD_INT 29
59362: PUSH
59363: LD_INT 91
59365: PUSH
59366: LD_INT 49
59368: PUSH
59369: EMPTY
59370: LIST
59371: LIST
59372: LIST
59373: ST_TO_ADDR
// if not result then
59374: LD_VAR 0 3
59378: NOT
59379: IFFALSE 59383
// exit ;
59381: GO 59839
// enemy := FilterAllUnits ( [ f_enemy , side ] ) ;
59383: LD_ADDR_VAR 0 5
59387: PUSH
59388: LD_INT 81
59390: PUSH
59391: LD_VAR 0 8
59395: PUSH
59396: EMPTY
59397: LIST
59398: LIST
59399: PPUSH
59400: CALL_OW 69
59404: ST_TO_ADDR
// for i in result do
59405: LD_ADDR_VAR 0 4
59409: PUSH
59410: LD_VAR 0 3
59414: PUSH
59415: FOR_IN
59416: IFFALSE 59837
// begin tag := GetTag ( i ) + 1 ;
59418: LD_ADDR_VAR 0 9
59422: PUSH
59423: LD_VAR 0 4
59427: PPUSH
59428: CALL_OW 110
59432: PUSH
59433: LD_INT 1
59435: PLUS
59436: ST_TO_ADDR
// cr := GetCratesNearbyXY ( GetX ( i ) , GetY ( i ) , 6 ) ;
59437: LD_ADDR_VAR 0 7
59441: PUSH
59442: LD_VAR 0 4
59446: PPUSH
59447: CALL_OW 250
59451: PPUSH
59452: LD_VAR 0 4
59456: PPUSH
59457: CALL_OW 251
59461: PPUSH
59462: LD_INT 6
59464: PPUSH
59465: CALL 59038 0 3
59469: ST_TO_ADDR
// if GetType ( i ) = unit_vehicle and cr and not GetWeapon ( i ) in ignoreCratesWeapon then
59470: LD_VAR 0 4
59474: PPUSH
59475: CALL_OW 247
59479: PUSH
59480: LD_INT 2
59482: EQUAL
59483: PUSH
59484: LD_VAR 0 7
59488: AND
59489: PUSH
59490: LD_VAR 0 4
59494: PPUSH
59495: CALL_OW 264
59499: PUSH
59500: LD_VAR 0 10
59504: IN
59505: NOT
59506: AND
59507: IFFALSE 59546
// ComAttackPlace ( i , cr [ 1 ] [ 1 ] , cr [ 1 ] [ 2 ] ) else
59509: LD_VAR 0 4
59513: PPUSH
59514: LD_VAR 0 7
59518: PUSH
59519: LD_INT 1
59521: ARRAY
59522: PUSH
59523: LD_INT 1
59525: ARRAY
59526: PPUSH
59527: LD_VAR 0 7
59531: PUSH
59532: LD_INT 1
59534: ARRAY
59535: PUSH
59536: LD_INT 2
59538: ARRAY
59539: PPUSH
59540: CALL_OW 116
59544: GO 59835
// if path > tag then
59546: LD_VAR 0 2
59550: PUSH
59551: LD_VAR 0 9
59555: GREATER
59556: IFFALSE 59764
// begin nearEnemy := UnitFilter ( enemy , [ f_dist , i , 8 ] ) ;
59558: LD_ADDR_VAR 0 6
59562: PUSH
59563: LD_VAR 0 5
59567: PPUSH
59568: LD_INT 91
59570: PUSH
59571: LD_VAR 0 4
59575: PUSH
59576: LD_INT 8
59578: PUSH
59579: EMPTY
59580: LIST
59581: LIST
59582: LIST
59583: PPUSH
59584: CALL_OW 72
59588: ST_TO_ADDR
// if nearEnemy then
59589: LD_VAR 0 6
59593: IFFALSE 59662
// begin if GetWeapon ( i ) = ru_time_lapser then
59595: LD_VAR 0 4
59599: PPUSH
59600: CALL_OW 264
59604: PUSH
59605: LD_INT 49
59607: EQUAL
59608: IFFALSE 59636
// ComMoveUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) else
59610: LD_VAR 0 4
59614: PPUSH
59615: LD_VAR 0 6
59619: PPUSH
59620: LD_VAR 0 4
59624: PPUSH
59625: CALL_OW 74
59629: PPUSH
59630: CALL_OW 112
59634: GO 59660
// ComAttackUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) ;
59636: LD_VAR 0 4
59640: PPUSH
59641: LD_VAR 0 6
59645: PPUSH
59646: LD_VAR 0 4
59650: PPUSH
59651: CALL_OW 74
59655: PPUSH
59656: CALL_OW 115
// end else
59660: GO 59762
// if GetDistUnitXY ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) > 6 then
59662: LD_VAR 0 4
59666: PPUSH
59667: LD_VAR 0 2
59671: PUSH
59672: LD_VAR 0 9
59676: ARRAY
59677: PUSH
59678: LD_INT 1
59680: ARRAY
59681: PPUSH
59682: LD_VAR 0 2
59686: PUSH
59687: LD_VAR 0 9
59691: ARRAY
59692: PUSH
59693: LD_INT 2
59695: ARRAY
59696: PPUSH
59697: CALL_OW 297
59701: PUSH
59702: LD_INT 6
59704: GREATER
59705: IFFALSE 59748
// ComAgressiveMove ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) else
59707: LD_VAR 0 4
59711: PPUSH
59712: LD_VAR 0 2
59716: PUSH
59717: LD_VAR 0 9
59721: ARRAY
59722: PUSH
59723: LD_INT 1
59725: ARRAY
59726: PPUSH
59727: LD_VAR 0 2
59731: PUSH
59732: LD_VAR 0 9
59736: ARRAY
59737: PUSH
59738: LD_INT 2
59740: ARRAY
59741: PPUSH
59742: CALL_OW 114
59746: GO 59762
// SetTag ( i , tag ) ;
59748: LD_VAR 0 4
59752: PPUSH
59753: LD_VAR 0 9
59757: PPUSH
59758: CALL_OW 109
// end else
59762: GO 59835
// if enemy then
59764: LD_VAR 0 5
59768: IFFALSE 59835
// begin if GetWeapon ( i ) = ru_time_lapser then
59770: LD_VAR 0 4
59774: PPUSH
59775: CALL_OW 264
59779: PUSH
59780: LD_INT 49
59782: EQUAL
59783: IFFALSE 59811
// ComMoveUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
59785: LD_VAR 0 4
59789: PPUSH
59790: LD_VAR 0 5
59794: PPUSH
59795: LD_VAR 0 4
59799: PPUSH
59800: CALL_OW 74
59804: PPUSH
59805: CALL_OW 112
59809: GO 59835
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
59811: LD_VAR 0 4
59815: PPUSH
59816: LD_VAR 0 5
59820: PPUSH
59821: LD_VAR 0 4
59825: PPUSH
59826: CALL_OW 74
59830: PPUSH
59831: CALL_OW 115
// end ; end ;
59835: GO 59415
59837: POP
59838: POP
// end ;
59839: LD_VAR 0 3
59843: RET
// export function ComLookAtDir ( unit , direction ) ; var x , y ; begin
59844: LD_INT 0
59846: PPUSH
59847: PPUSH
59848: PPUSH
// if not unit or IsInUnit ( unit ) then
59849: LD_VAR 0 1
59853: NOT
59854: PUSH
59855: LD_VAR 0 1
59859: PPUSH
59860: CALL_OW 310
59864: OR
59865: IFFALSE 59869
// exit ;
59867: GO 59960
// x := ShiftX ( GetX ( unit ) , direction , 1 ) ;
59869: LD_ADDR_VAR 0 4
59873: PUSH
59874: LD_VAR 0 1
59878: PPUSH
59879: CALL_OW 250
59883: PPUSH
59884: LD_VAR 0 2
59888: PPUSH
59889: LD_INT 1
59891: PPUSH
59892: CALL_OW 272
59896: ST_TO_ADDR
// y := ShiftY ( GetY ( unit ) , direction , 1 ) ;
59897: LD_ADDR_VAR 0 5
59901: PUSH
59902: LD_VAR 0 1
59906: PPUSH
59907: CALL_OW 251
59911: PPUSH
59912: LD_VAR 0 2
59916: PPUSH
59917: LD_INT 1
59919: PPUSH
59920: CALL_OW 273
59924: ST_TO_ADDR
// if ValidHex ( x , y ) then
59925: LD_VAR 0 4
59929: PPUSH
59930: LD_VAR 0 5
59934: PPUSH
59935: CALL_OW 488
59939: IFFALSE 59960
// ComTurnXY ( unit , x , y ) ;
59941: LD_VAR 0 1
59945: PPUSH
59946: LD_VAR 0 4
59950: PPUSH
59951: LD_VAR 0 5
59955: PPUSH
59956: CALL_OW 118
// end ;
59960: LD_VAR 0 3
59964: RET
// export function SeeUnits ( side , units ) ; var i ; begin
59965: LD_INT 0
59967: PPUSH
59968: PPUSH
// result := false ;
59969: LD_ADDR_VAR 0 3
59973: PUSH
59974: LD_INT 0
59976: ST_TO_ADDR
// if not units then
59977: LD_VAR 0 2
59981: NOT
59982: IFFALSE 59986
// exit ;
59984: GO 60031
// for i in units do
59986: LD_ADDR_VAR 0 4
59990: PUSH
59991: LD_VAR 0 2
59995: PUSH
59996: FOR_IN
59997: IFFALSE 60029
// if See ( side , i ) then
59999: LD_VAR 0 1
60003: PPUSH
60004: LD_VAR 0 4
60008: PPUSH
60009: CALL_OW 292
60013: IFFALSE 60027
// begin result := true ;
60015: LD_ADDR_VAR 0 3
60019: PUSH
60020: LD_INT 1
60022: ST_TO_ADDR
// exit ;
60023: POP
60024: POP
60025: GO 60031
// end ;
60027: GO 59996
60029: POP
60030: POP
// end ;
60031: LD_VAR 0 3
60035: RET
// export function GetNearestPoint ( unit , points ) ; var i , dist , tmpDist ; begin
60036: LD_INT 0
60038: PPUSH
60039: PPUSH
60040: PPUSH
60041: PPUSH
// if not unit or not points then
60042: LD_VAR 0 1
60046: NOT
60047: PUSH
60048: LD_VAR 0 2
60052: NOT
60053: OR
60054: IFFALSE 60058
// exit ;
60056: GO 60148
// dist := 99999 ;
60058: LD_ADDR_VAR 0 5
60062: PUSH
60063: LD_INT 99999
60065: ST_TO_ADDR
// for i in points do
60066: LD_ADDR_VAR 0 4
60070: PUSH
60071: LD_VAR 0 2
60075: PUSH
60076: FOR_IN
60077: IFFALSE 60146
// begin tmpDist := GetDistUnitXY ( unit , i [ 1 ] , i [ 2 ] ) ;
60079: LD_ADDR_VAR 0 6
60083: PUSH
60084: LD_VAR 0 1
60088: PPUSH
60089: LD_VAR 0 4
60093: PUSH
60094: LD_INT 1
60096: ARRAY
60097: PPUSH
60098: LD_VAR 0 4
60102: PUSH
60103: LD_INT 2
60105: ARRAY
60106: PPUSH
60107: CALL_OW 297
60111: ST_TO_ADDR
// if tmpDist < dist then
60112: LD_VAR 0 6
60116: PUSH
60117: LD_VAR 0 5
60121: LESS
60122: IFFALSE 60144
// begin result := i ;
60124: LD_ADDR_VAR 0 3
60128: PUSH
60129: LD_VAR 0 4
60133: ST_TO_ADDR
// dist := tmpDist ;
60134: LD_ADDR_VAR 0 5
60138: PUSH
60139: LD_VAR 0 6
60143: ST_TO_ADDR
// end ; end ;
60144: GO 60076
60146: POP
60147: POP
// end ;
60148: LD_VAR 0 3
60152: RET
// export function CreateBehemoth ( side , x , y , d ) ; begin
60153: LD_INT 0
60155: PPUSH
// uc_side := side ;
60156: LD_ADDR_OWVAR 20
60160: PUSH
60161: LD_VAR 0 1
60165: ST_TO_ADDR
// uc_nation := 3 ;
60166: LD_ADDR_OWVAR 21
60170: PUSH
60171: LD_INT 3
60173: ST_TO_ADDR
// vc_chassis := 25 ;
60174: LD_ADDR_OWVAR 37
60178: PUSH
60179: LD_INT 25
60181: ST_TO_ADDR
// vc_engine := engine_siberite ;
60182: LD_ADDR_OWVAR 39
60186: PUSH
60187: LD_INT 3
60189: ST_TO_ADDR
// vc_control := control_computer ;
60190: LD_ADDR_OWVAR 38
60194: PUSH
60195: LD_INT 3
60197: ST_TO_ADDR
// vc_weapon := 59 ;
60198: LD_ADDR_OWVAR 40
60202: PUSH
60203: LD_INT 59
60205: ST_TO_ADDR
// result := CreateVehicle ;
60206: LD_ADDR_VAR 0 5
60210: PUSH
60211: CALL_OW 45
60215: ST_TO_ADDR
// SetDir ( result , d ) ;
60216: LD_VAR 0 5
60220: PPUSH
60221: LD_VAR 0 4
60225: PPUSH
60226: CALL_OW 233
// PlaceUnitXY ( result , x , y , false ) ;
60230: LD_VAR 0 5
60234: PPUSH
60235: LD_VAR 0 2
60239: PPUSH
60240: LD_VAR 0 3
60244: PPUSH
60245: LD_INT 0
60247: PPUSH
60248: CALL_OW 48
// end ;
60252: LD_VAR 0 5
60256: RET
// export function GetMultiCargo ( cargo ) ; var i , tmp ; begin
60257: LD_INT 0
60259: PPUSH
60260: PPUSH
60261: PPUSH
// result := [ 0 , 0 , 0 , 0 ] ;
60262: LD_ADDR_VAR 0 2
60266: PUSH
60267: LD_INT 0
60269: PUSH
60270: LD_INT 0
60272: PUSH
60273: LD_INT 0
60275: PUSH
60276: LD_INT 0
60278: PUSH
60279: EMPTY
60280: LIST
60281: LIST
60282: LIST
60283: LIST
60284: ST_TO_ADDR
// if not cargo or not GetWeapon ( cargo ) in [ us_cargo_bay , ru_cargo_bay , ar_cargo_bay , ru_big_cargo_bay ] then
60285: LD_VAR 0 1
60289: NOT
60290: PUSH
60291: LD_VAR 0 1
60295: PPUSH
60296: CALL_OW 264
60300: PUSH
60301: LD_INT 12
60303: PUSH
60304: LD_INT 51
60306: PUSH
60307: LD_INT 32
60309: PUSH
60310: LD_INT 89
60312: PUSH
60313: EMPTY
60314: LIST
60315: LIST
60316: LIST
60317: LIST
60318: IN
60319: NOT
60320: OR
60321: IFFALSE 60325
// exit ;
60323: GO 60423
// for i := 1 to 3 do
60325: LD_ADDR_VAR 0 3
60329: PUSH
60330: DOUBLE
60331: LD_INT 1
60333: DEC
60334: ST_TO_ADDR
60335: LD_INT 3
60337: PUSH
60338: FOR_TO
60339: IFFALSE 60421
// begin tmp := GetCargo ( cargo , i ) ;
60341: LD_ADDR_VAR 0 4
60345: PUSH
60346: LD_VAR 0 1
60350: PPUSH
60351: LD_VAR 0 3
60355: PPUSH
60356: CALL_OW 289
60360: ST_TO_ADDR
// result := Replace ( result , i , tmp ) ;
60361: LD_ADDR_VAR 0 2
60365: PUSH
60366: LD_VAR 0 2
60370: PPUSH
60371: LD_VAR 0 3
60375: PPUSH
60376: LD_VAR 0 4
60380: PPUSH
60381: CALL_OW 1
60385: ST_TO_ADDR
// result := Replace ( result , 4 , result [ 4 ] + tmp ) ;
60386: LD_ADDR_VAR 0 2
60390: PUSH
60391: LD_VAR 0 2
60395: PPUSH
60396: LD_INT 4
60398: PPUSH
60399: LD_VAR 0 2
60403: PUSH
60404: LD_INT 4
60406: ARRAY
60407: PUSH
60408: LD_VAR 0 4
60412: PLUS
60413: PPUSH
60414: CALL_OW 1
60418: ST_TO_ADDR
// end ;
60419: GO 60338
60421: POP
60422: POP
// end ;
60423: LD_VAR 0 2
60427: RET
// export function Length ( array ) ; begin
60428: LD_INT 0
60430: PPUSH
// result := array + 0 ;
60431: LD_ADDR_VAR 0 2
60435: PUSH
60436: LD_VAR 0 1
60440: PUSH
60441: LD_INT 0
60443: PLUS
60444: ST_TO_ADDR
// end ;
60445: LD_VAR 0 2
60449: RET
// export function PrepareArray ( array ) ; begin
60450: LD_INT 0
60452: PPUSH
// result := array diff 0 ;
60453: LD_ADDR_VAR 0 2
60457: PUSH
60458: LD_VAR 0 1
60462: PUSH
60463: LD_INT 0
60465: DIFF
60466: ST_TO_ADDR
// if not result [ 1 ] then
60467: LD_VAR 0 2
60471: PUSH
60472: LD_INT 1
60474: ARRAY
60475: NOT
60476: IFFALSE 60496
// result := Delete ( result , 1 ) ;
60478: LD_ADDR_VAR 0 2
60482: PUSH
60483: LD_VAR 0 2
60487: PPUSH
60488: LD_INT 1
60490: PPUSH
60491: CALL_OW 3
60495: ST_TO_ADDR
// end ;
60496: LD_VAR 0 2
60500: RET
// export function IsInSibRocketRange ( x , y , area ) ; var i , sibRocketRange , tmp ; begin
60501: LD_INT 0
60503: PPUSH
60504: PPUSH
60505: PPUSH
60506: PPUSH
// sibRocketRange := 25 ;
60507: LD_ADDR_VAR 0 6
60511: PUSH
60512: LD_INT 25
60514: ST_TO_ADDR
// result := false ;
60515: LD_ADDR_VAR 0 4
60519: PUSH
60520: LD_INT 0
60522: ST_TO_ADDR
// for i := 0 to 5 do
60523: LD_ADDR_VAR 0 5
60527: PUSH
60528: DOUBLE
60529: LD_INT 0
60531: DEC
60532: ST_TO_ADDR
60533: LD_INT 5
60535: PUSH
60536: FOR_TO
60537: IFFALSE 60604
// if InArea ( ShiftX ( x , i , sibRocketRange ) , ShiftY ( y , i , sibRocketRange ) , area ) then
60539: LD_VAR 0 1
60543: PPUSH
60544: LD_VAR 0 5
60548: PPUSH
60549: LD_VAR 0 6
60553: PPUSH
60554: CALL_OW 272
60558: PPUSH
60559: LD_VAR 0 2
60563: PPUSH
60564: LD_VAR 0 5
60568: PPUSH
60569: LD_VAR 0 6
60573: PPUSH
60574: CALL_OW 273
60578: PPUSH
60579: LD_VAR 0 3
60583: PPUSH
60584: CALL_OW 309
60588: IFFALSE 60602
// begin result := true ;
60590: LD_ADDR_VAR 0 4
60594: PUSH
60595: LD_INT 1
60597: ST_TO_ADDR
// exit ;
60598: POP
60599: POP
60600: GO 60606
// end ;
60602: GO 60536
60604: POP
60605: POP
// end ;
60606: LD_VAR 0 4
60610: RET
// export function SayRadioNoFaceNoName ( unit , dialog ) ; begin
60611: LD_INT 0
60613: PPUSH
// SayEX ( unit , dialog , false , false , true , false ) ;
60614: LD_VAR 0 1
60618: PPUSH
60619: LD_VAR 0 2
60623: PPUSH
60624: LD_INT 0
60626: PPUSH
60627: LD_INT 0
60629: PPUSH
60630: LD_INT 1
60632: PPUSH
60633: LD_INT 0
60635: PPUSH
60636: CALL_OW 587
// end ; end_of_file
60640: LD_VAR 0 3
60644: RET
// export function SOS_UnitDestroyed ( un ) ; var i , eff , side ; begin
60645: LD_INT 0
60647: PPUSH
60648: PPUSH
60649: PPUSH
60650: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
60651: LD_VAR 0 1
60655: PPUSH
60656: CALL_OW 264
60660: PUSH
60661: LD_INT 91
60663: EQUAL
60664: IFFALSE 60736
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
60666: LD_INT 68
60668: PPUSH
60669: LD_VAR 0 1
60673: PPUSH
60674: CALL_OW 255
60678: PPUSH
60679: CALL_OW 321
60683: PUSH
60684: LD_INT 2
60686: EQUAL
60687: IFFALSE 60699
// eff := 70 else
60689: LD_ADDR_VAR 0 4
60693: PUSH
60694: LD_INT 70
60696: ST_TO_ADDR
60697: GO 60707
// eff := 30 ;
60699: LD_ADDR_VAR 0 4
60703: PUSH
60704: LD_INT 30
60706: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
60707: LD_VAR 0 1
60711: PPUSH
60712: CALL_OW 250
60716: PPUSH
60717: LD_VAR 0 1
60721: PPUSH
60722: CALL_OW 251
60726: PPUSH
60727: LD_VAR 0 4
60731: PPUSH
60732: CALL_OW 495
// end ; end ;
60736: LD_VAR 0 2
60740: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
60741: LD_INT 0
60743: PPUSH
// end ;
60744: LD_VAR 0 4
60748: RET
// export function SOS_Command ( cmd ) ; begin
60749: LD_INT 0
60751: PPUSH
// end ;
60752: LD_VAR 0 2
60756: RET
// export function SOS_CommandUnitXY ( cmd , un , target , x , y ) ; begin
60757: LD_INT 0
60759: PPUSH
// end ;
60760: LD_VAR 0 6
60764: RET
// export function SOS_VehicleConstructed ( vehicle , factory ) ; var driver ; begin
60765: LD_INT 0
60767: PPUSH
60768: PPUSH
// if not vehicle or not factory then
60769: LD_VAR 0 1
60773: NOT
60774: PUSH
60775: LD_VAR 0 2
60779: NOT
60780: OR
60781: IFFALSE 60785
// exit ;
60783: GO 61016
// if factoryWaypoints >= factory then
60785: LD_EXP 156
60789: PUSH
60790: LD_VAR 0 2
60794: GREATEREQUAL
60795: IFFALSE 61016
// if factoryWaypoints [ factory ] then
60797: LD_EXP 156
60801: PUSH
60802: LD_VAR 0 2
60806: ARRAY
60807: IFFALSE 61016
// begin if GetControl ( vehicle ) = control_manual then
60809: LD_VAR 0 1
60813: PPUSH
60814: CALL_OW 263
60818: PUSH
60819: LD_INT 1
60821: EQUAL
60822: IFFALSE 60903
// begin driver := IsDrivenBy ( vehicle ) ;
60824: LD_ADDR_VAR 0 4
60828: PUSH
60829: LD_VAR 0 1
60833: PPUSH
60834: CALL_OW 311
60838: ST_TO_ADDR
// AddComMoveXY ( driver , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
60839: LD_VAR 0 4
60843: PPUSH
60844: LD_EXP 156
60848: PUSH
60849: LD_VAR 0 2
60853: ARRAY
60854: PUSH
60855: LD_INT 3
60857: ARRAY
60858: PPUSH
60859: LD_EXP 156
60863: PUSH
60864: LD_VAR 0 2
60868: ARRAY
60869: PUSH
60870: LD_INT 4
60872: ARRAY
60873: PPUSH
60874: CALL_OW 171
// AddComExitVehicle ( driver ) ;
60878: LD_VAR 0 4
60882: PPUSH
60883: CALL_OW 181
// AddComEnterUnit ( driver , factory ) ;
60887: LD_VAR 0 4
60891: PPUSH
60892: LD_VAR 0 2
60896: PPUSH
60897: CALL_OW 180
// end else
60901: GO 61016
// if GetControl ( vehicle ) = control_remote then
60903: LD_VAR 0 1
60907: PPUSH
60908: CALL_OW 263
60912: PUSH
60913: LD_INT 2
60915: EQUAL
60916: IFFALSE 60977
// begin wait ( 0 0$2 ) ;
60918: LD_INT 70
60920: PPUSH
60921: CALL_OW 67
// if Connect ( vehicle ) then
60925: LD_VAR 0 1
60929: PPUSH
60930: CALL 27330 0 1
60934: IFFALSE 60975
// AddComMoveXY ( vehicle , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
60936: LD_VAR 0 1
60940: PPUSH
60941: LD_EXP 156
60945: PUSH
60946: LD_VAR 0 2
60950: ARRAY
60951: PUSH
60952: LD_INT 3
60954: ARRAY
60955: PPUSH
60956: LD_EXP 156
60960: PUSH
60961: LD_VAR 0 2
60965: ARRAY
60966: PUSH
60967: LD_INT 4
60969: ARRAY
60970: PPUSH
60971: CALL_OW 171
// end else
60975: GO 61016
// AddComMoveXY ( vehicle , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
60977: LD_VAR 0 1
60981: PPUSH
60982: LD_EXP 156
60986: PUSH
60987: LD_VAR 0 2
60991: ARRAY
60992: PUSH
60993: LD_INT 3
60995: ARRAY
60996: PPUSH
60997: LD_EXP 156
61001: PUSH
61002: LD_VAR 0 2
61006: ARRAY
61007: PUSH
61008: LD_INT 4
61010: ARRAY
61011: PPUSH
61012: CALL_OW 171
// end ; end ;
61016: LD_VAR 0 3
61020: RET
// export function SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; begin
61021: LD_INT 0
61023: PPUSH
// if cmd = 250 and GetWeapon ( unit ) = ar_miner then
61024: LD_VAR 0 1
61028: PUSH
61029: LD_INT 250
61031: EQUAL
61032: PUSH
61033: LD_VAR 0 2
61037: PPUSH
61038: CALL_OW 264
61042: PUSH
61043: LD_INT 81
61045: EQUAL
61046: AND
61047: IFFALSE 61068
// MinerPlaceMine ( unit , x , y ) ;
61049: LD_VAR 0 2
61053: PPUSH
61054: LD_VAR 0 4
61058: PPUSH
61059: LD_VAR 0 5
61063: PPUSH
61064: CALL 63453 0 3
// if cmd = 251 and GetWeapon ( unit ) = ar_miner then
61068: LD_VAR 0 1
61072: PUSH
61073: LD_INT 251
61075: EQUAL
61076: PUSH
61077: LD_VAR 0 2
61081: PPUSH
61082: CALL_OW 264
61086: PUSH
61087: LD_INT 81
61089: EQUAL
61090: AND
61091: IFFALSE 61112
// MinerDetonateMine ( unit , x , y ) ;
61093: LD_VAR 0 2
61097: PPUSH
61098: LD_VAR 0 4
61102: PPUSH
61103: LD_VAR 0 5
61107: PPUSH
61108: CALL 63728 0 3
// if cmd = 252 and GetWeapon ( unit ) = ar_miner then
61112: LD_VAR 0 1
61116: PUSH
61117: LD_INT 252
61119: EQUAL
61120: PUSH
61121: LD_VAR 0 2
61125: PPUSH
61126: CALL_OW 264
61130: PUSH
61131: LD_INT 81
61133: EQUAL
61134: AND
61135: IFFALSE 61156
// MinerCreateMinefield ( unit , x , y ) ;
61137: LD_VAR 0 2
61141: PPUSH
61142: LD_VAR 0 4
61146: PPUSH
61147: LD_VAR 0 5
61151: PPUSH
61152: CALL 64145 0 3
// if cmd = 253 and GetClass ( unit ) = class_sniper then
61156: LD_VAR 0 1
61160: PUSH
61161: LD_INT 253
61163: EQUAL
61164: PUSH
61165: LD_VAR 0 2
61169: PPUSH
61170: CALL_OW 257
61174: PUSH
61175: LD_INT 5
61177: EQUAL
61178: AND
61179: IFFALSE 61200
// ComBinocular ( unit , x , y ) ;
61181: LD_VAR 0 2
61185: PPUSH
61186: LD_VAR 0 4
61190: PPUSH
61191: LD_VAR 0 5
61195: PPUSH
61196: CALL 64514 0 3
// if cmd = 254 and GetWeapon ( unit ) = us_hack and GetControl ( selectedUnit ) = control_computer then
61200: LD_VAR 0 1
61204: PUSH
61205: LD_INT 254
61207: EQUAL
61208: PUSH
61209: LD_VAR 0 2
61213: PPUSH
61214: CALL_OW 264
61218: PUSH
61219: LD_INT 99
61221: EQUAL
61222: AND
61223: PUSH
61224: LD_VAR 0 3
61228: PPUSH
61229: CALL_OW 263
61233: PUSH
61234: LD_INT 3
61236: EQUAL
61237: AND
61238: IFFALSE 61254
// HackDestroyVehicle ( unit , selectedUnit ) ;
61240: LD_VAR 0 2
61244: PPUSH
61245: LD_VAR 0 3
61249: PPUSH
61250: CALL 62817 0 2
// if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
61254: LD_VAR 0 1
61258: PUSH
61259: LD_INT 255
61261: EQUAL
61262: PUSH
61263: LD_VAR 0 2
61267: PPUSH
61268: CALL_OW 264
61272: PUSH
61273: LD_INT 14
61275: PUSH
61276: LD_INT 53
61278: PUSH
61279: EMPTY
61280: LIST
61281: LIST
61282: IN
61283: AND
61284: PUSH
61285: LD_VAR 0 4
61289: PPUSH
61290: LD_VAR 0 5
61294: PPUSH
61295: CALL_OW 488
61299: AND
61300: IFFALSE 61324
// CutTreeXYR ( unit , x , y , 12 ) ;
61302: LD_VAR 0 2
61306: PPUSH
61307: LD_VAR 0 4
61311: PPUSH
61312: LD_VAR 0 5
61316: PPUSH
61317: LD_INT 12
61319: PPUSH
61320: CALL 61387 0 4
// if cmd = 256 then
61324: LD_VAR 0 1
61328: PUSH
61329: LD_INT 256
61331: EQUAL
61332: IFFALSE 61353
// SetFactoryWaypoint ( unit , x , y ) ;
61334: LD_VAR 0 2
61338: PPUSH
61339: LD_VAR 0 4
61343: PPUSH
61344: LD_VAR 0 5
61348: PPUSH
61349: CALL 79417 0 3
// if cmd = 257 then
61353: LD_VAR 0 1
61357: PUSH
61358: LD_INT 257
61360: EQUAL
61361: IFFALSE 61382
// SetWarehouseGatheringPoint ( unit , x , y ) ;
61363: LD_VAR 0 2
61367: PPUSH
61368: LD_VAR 0 4
61372: PPUSH
61373: LD_VAR 0 5
61377: PPUSH
61378: CALL 79779 0 3
// end ;
61382: LD_VAR 0 6
61386: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
61387: LD_INT 0
61389: PPUSH
61390: PPUSH
61391: PPUSH
61392: PPUSH
61393: PPUSH
61394: PPUSH
61395: PPUSH
61396: PPUSH
61397: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
61398: LD_VAR 0 1
61402: NOT
61403: PUSH
61404: LD_VAR 0 2
61408: PPUSH
61409: LD_VAR 0 3
61413: PPUSH
61414: CALL_OW 488
61418: NOT
61419: OR
61420: PUSH
61421: LD_VAR 0 4
61425: NOT
61426: OR
61427: IFFALSE 61431
// exit ;
61429: GO 61771
// list := [ ] ;
61431: LD_ADDR_VAR 0 13
61435: PUSH
61436: EMPTY
61437: ST_TO_ADDR
// if x - r < 0 then
61438: LD_VAR 0 2
61442: PUSH
61443: LD_VAR 0 4
61447: MINUS
61448: PUSH
61449: LD_INT 0
61451: LESS
61452: IFFALSE 61464
// min_x := 0 else
61454: LD_ADDR_VAR 0 7
61458: PUSH
61459: LD_INT 0
61461: ST_TO_ADDR
61462: GO 61480
// min_x := x - r ;
61464: LD_ADDR_VAR 0 7
61468: PUSH
61469: LD_VAR 0 2
61473: PUSH
61474: LD_VAR 0 4
61478: MINUS
61479: ST_TO_ADDR
// if y - r < 0 then
61480: LD_VAR 0 3
61484: PUSH
61485: LD_VAR 0 4
61489: MINUS
61490: PUSH
61491: LD_INT 0
61493: LESS
61494: IFFALSE 61506
// min_y := 0 else
61496: LD_ADDR_VAR 0 8
61500: PUSH
61501: LD_INT 0
61503: ST_TO_ADDR
61504: GO 61522
// min_y := y - r ;
61506: LD_ADDR_VAR 0 8
61510: PUSH
61511: LD_VAR 0 3
61515: PUSH
61516: LD_VAR 0 4
61520: MINUS
61521: ST_TO_ADDR
// max_x := x + r ;
61522: LD_ADDR_VAR 0 9
61526: PUSH
61527: LD_VAR 0 2
61531: PUSH
61532: LD_VAR 0 4
61536: PLUS
61537: ST_TO_ADDR
// max_y := y + r ;
61538: LD_ADDR_VAR 0 10
61542: PUSH
61543: LD_VAR 0 3
61547: PUSH
61548: LD_VAR 0 4
61552: PLUS
61553: ST_TO_ADDR
// for _x = min_x to max_x do
61554: LD_ADDR_VAR 0 11
61558: PUSH
61559: DOUBLE
61560: LD_VAR 0 7
61564: DEC
61565: ST_TO_ADDR
61566: LD_VAR 0 9
61570: PUSH
61571: FOR_TO
61572: IFFALSE 61689
// for _y = min_y to max_y do
61574: LD_ADDR_VAR 0 12
61578: PUSH
61579: DOUBLE
61580: LD_VAR 0 8
61584: DEC
61585: ST_TO_ADDR
61586: LD_VAR 0 10
61590: PUSH
61591: FOR_TO
61592: IFFALSE 61685
// begin if not ValidHex ( _x , _y ) then
61594: LD_VAR 0 11
61598: PPUSH
61599: LD_VAR 0 12
61603: PPUSH
61604: CALL_OW 488
61608: NOT
61609: IFFALSE 61613
// continue ;
61611: GO 61591
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
61613: LD_VAR 0 11
61617: PPUSH
61618: LD_VAR 0 12
61622: PPUSH
61623: CALL_OW 351
61627: PUSH
61628: LD_VAR 0 11
61632: PPUSH
61633: LD_VAR 0 12
61637: PPUSH
61638: CALL_OW 554
61642: AND
61643: IFFALSE 61683
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
61645: LD_ADDR_VAR 0 13
61649: PUSH
61650: LD_VAR 0 13
61654: PPUSH
61655: LD_VAR 0 13
61659: PUSH
61660: LD_INT 1
61662: PLUS
61663: PPUSH
61664: LD_VAR 0 11
61668: PUSH
61669: LD_VAR 0 12
61673: PUSH
61674: EMPTY
61675: LIST
61676: LIST
61677: PPUSH
61678: CALL_OW 2
61682: ST_TO_ADDR
// end ;
61683: GO 61591
61685: POP
61686: POP
61687: GO 61571
61689: POP
61690: POP
// if not list then
61691: LD_VAR 0 13
61695: NOT
61696: IFFALSE 61700
// exit ;
61698: GO 61771
// for i in list do
61700: LD_ADDR_VAR 0 6
61704: PUSH
61705: LD_VAR 0 13
61709: PUSH
61710: FOR_IN
61711: IFFALSE 61769
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
61713: LD_VAR 0 1
61717: PPUSH
61718: LD_STRING M
61720: PUSH
61721: LD_VAR 0 6
61725: PUSH
61726: LD_INT 1
61728: ARRAY
61729: PUSH
61730: LD_VAR 0 6
61734: PUSH
61735: LD_INT 2
61737: ARRAY
61738: PUSH
61739: LD_INT 0
61741: PUSH
61742: LD_INT 0
61744: PUSH
61745: LD_INT 0
61747: PUSH
61748: LD_INT 0
61750: PUSH
61751: EMPTY
61752: LIST
61753: LIST
61754: LIST
61755: LIST
61756: LIST
61757: LIST
61758: LIST
61759: PUSH
61760: EMPTY
61761: LIST
61762: PPUSH
61763: CALL_OW 447
61767: GO 61710
61769: POP
61770: POP
// end ;
61771: LD_VAR 0 5
61775: RET
// export initHack , hackTanks , hackTanksCaptured , hackLimit , hackDist , hackCounter ; every 0 0$1 trigger not initHack do
61776: LD_EXP 87
61780: NOT
61781: IFFALSE 61831
61783: GO 61785
61785: DISABLE
// begin initHack := true ;
61786: LD_ADDR_EXP 87
61790: PUSH
61791: LD_INT 1
61793: ST_TO_ADDR
// hackTanks := [ ] ;
61794: LD_ADDR_EXP 88
61798: PUSH
61799: EMPTY
61800: ST_TO_ADDR
// hackTanksCaptured := [ ] ;
61801: LD_ADDR_EXP 89
61805: PUSH
61806: EMPTY
61807: ST_TO_ADDR
// hackLimit := 3 ;
61808: LD_ADDR_EXP 90
61812: PUSH
61813: LD_INT 3
61815: ST_TO_ADDR
// hackDist := 12 ;
61816: LD_ADDR_EXP 91
61820: PUSH
61821: LD_INT 12
61823: ST_TO_ADDR
// hackCounter := [ ] ;
61824: LD_ADDR_EXP 92
61828: PUSH
61829: EMPTY
61830: ST_TO_ADDR
// end ;
61831: END
// every 0 0$1 trigger initHack and FilterAllUnits ( [ f_weapon , us_hack ] ) do var i , tmp ;
61832: LD_EXP 87
61836: PUSH
61837: LD_INT 34
61839: PUSH
61840: LD_INT 99
61842: PUSH
61843: EMPTY
61844: LIST
61845: LIST
61846: PPUSH
61847: CALL_OW 69
61851: AND
61852: IFFALSE 62105
61854: GO 61856
61856: DISABLE
61857: LD_INT 0
61859: PPUSH
61860: PPUSH
// begin enable ;
61861: ENABLE
// for i in FilterAllUnits ( [ f_weapon , us_hack ] ) do
61862: LD_ADDR_VAR 0 1
61866: PUSH
61867: LD_INT 34
61869: PUSH
61870: LD_INT 99
61872: PUSH
61873: EMPTY
61874: LIST
61875: LIST
61876: PPUSH
61877: CALL_OW 69
61881: PUSH
61882: FOR_IN
61883: IFFALSE 62103
// begin if not i in hackTanks then
61885: LD_VAR 0 1
61889: PUSH
61890: LD_EXP 88
61894: IN
61895: NOT
61896: IFFALSE 61979
// begin hackTanks := Replace ( hackTanks , hackTanks + 1 , i ) ;
61898: LD_ADDR_EXP 88
61902: PUSH
61903: LD_EXP 88
61907: PPUSH
61908: LD_EXP 88
61912: PUSH
61913: LD_INT 1
61915: PLUS
61916: PPUSH
61917: LD_VAR 0 1
61921: PPUSH
61922: CALL_OW 1
61926: ST_TO_ADDR
// hackTanksCaptured := Replace ( hackTanksCaptured , hackTanksCaptured + 1 , [ ] ) ;
61927: LD_ADDR_EXP 89
61931: PUSH
61932: LD_EXP 89
61936: PPUSH
61937: LD_EXP 89
61941: PUSH
61942: LD_INT 1
61944: PLUS
61945: PPUSH
61946: EMPTY
61947: PPUSH
61948: CALL_OW 1
61952: ST_TO_ADDR
// hackCounter := Replace ( hackCounter , hackCounter + 1 , [ ] ) ;
61953: LD_ADDR_EXP 92
61957: PUSH
61958: LD_EXP 92
61962: PPUSH
61963: LD_EXP 92
61967: PUSH
61968: LD_INT 1
61970: PLUS
61971: PPUSH
61972: EMPTY
61973: PPUSH
61974: CALL_OW 1
61978: ST_TO_ADDR
// end ; if not IsOk ( i ) then
61979: LD_VAR 0 1
61983: PPUSH
61984: CALL_OW 302
61988: NOT
61989: IFFALSE 62002
// begin HackUnlinkAll ( i ) ;
61991: LD_VAR 0 1
61995: PPUSH
61996: CALL 62108 0 1
// continue ;
62000: GO 61882
// end ; HackCheckCapturedStatus ( i ) ;
62002: LD_VAR 0 1
62006: PPUSH
62007: CALL 62551 0 1
// tmp := FilterAllUnits ( [ [ f_enemy , GetSide ( i ) ] , [ f_control , control_computer ] , [ f_dist , i , hackDist ] , [ f_ok ] ] ) ;
62011: LD_ADDR_VAR 0 2
62015: PUSH
62016: LD_INT 81
62018: PUSH
62019: LD_VAR 0 1
62023: PPUSH
62024: CALL_OW 255
62028: PUSH
62029: EMPTY
62030: LIST
62031: LIST
62032: PUSH
62033: LD_INT 33
62035: PUSH
62036: LD_INT 3
62038: PUSH
62039: EMPTY
62040: LIST
62041: LIST
62042: PUSH
62043: LD_INT 91
62045: PUSH
62046: LD_VAR 0 1
62050: PUSH
62051: LD_EXP 91
62055: PUSH
62056: EMPTY
62057: LIST
62058: LIST
62059: LIST
62060: PUSH
62061: LD_INT 50
62063: PUSH
62064: EMPTY
62065: LIST
62066: PUSH
62067: EMPTY
62068: LIST
62069: LIST
62070: LIST
62071: LIST
62072: PPUSH
62073: CALL_OW 69
62077: ST_TO_ADDR
// if not tmp then
62078: LD_VAR 0 2
62082: NOT
62083: IFFALSE 62087
// continue ;
62085: GO 61882
// HackLink ( i , tmp ) ;
62087: LD_VAR 0 1
62091: PPUSH
62092: LD_VAR 0 2
62096: PPUSH
62097: CALL 62244 0 2
// end ;
62101: GO 61882
62103: POP
62104: POP
// end ;
62105: PPOPN 2
62107: END
// function HackUnlinkAll ( hack ) ; var i , index ; begin
62108: LD_INT 0
62110: PPUSH
62111: PPUSH
62112: PPUSH
// if not hack in hackTanks then
62113: LD_VAR 0 1
62117: PUSH
62118: LD_EXP 88
62122: IN
62123: NOT
62124: IFFALSE 62128
// exit ;
62126: GO 62239
// index := GetElementIndex ( hackTanks , hack ) ;
62128: LD_ADDR_VAR 0 4
62132: PUSH
62133: LD_EXP 88
62137: PPUSH
62138: LD_VAR 0 1
62142: PPUSH
62143: CALL 24146 0 2
62147: ST_TO_ADDR
// if hackTanksCaptured [ index ] then
62148: LD_EXP 89
62152: PUSH
62153: LD_VAR 0 4
62157: ARRAY
62158: IFFALSE 62239
// begin for i in hackTanksCaptured [ index ] do
62160: LD_ADDR_VAR 0 3
62164: PUSH
62165: LD_EXP 89
62169: PUSH
62170: LD_VAR 0 4
62174: ARRAY
62175: PUSH
62176: FOR_IN
62177: IFFALSE 62203
// SetSide ( i [ 1 ] , i [ 2 ] ) ;
62179: LD_VAR 0 3
62183: PUSH
62184: LD_INT 1
62186: ARRAY
62187: PPUSH
62188: LD_VAR 0 3
62192: PUSH
62193: LD_INT 2
62195: ARRAY
62196: PPUSH
62197: CALL_OW 235
62201: GO 62176
62203: POP
62204: POP
// hackTanksCaptured := Replace ( hackTanksCaptured , index , [ ] ) ;
62205: LD_ADDR_EXP 89
62209: PUSH
62210: LD_EXP 89
62214: PPUSH
62215: LD_VAR 0 4
62219: PPUSH
62220: EMPTY
62221: PPUSH
62222: CALL_OW 1
62226: ST_TO_ADDR
// SetUnitDisplayNumber ( hack , 0 ) ;
62227: LD_VAR 0 1
62231: PPUSH
62232: LD_INT 0
62234: PPUSH
62235: CALL_OW 505
// end ; end ;
62239: LD_VAR 0 2
62243: RET
// function HackLink ( hack , vehicles ) ; var i , index ; begin
62244: LD_INT 0
62246: PPUSH
62247: PPUSH
62248: PPUSH
// if not hack in hackTanks or not vehicles then
62249: LD_VAR 0 1
62253: PUSH
62254: LD_EXP 88
62258: IN
62259: NOT
62260: PUSH
62261: LD_VAR 0 2
62265: NOT
62266: OR
62267: IFFALSE 62271
// exit ;
62269: GO 62546
// vehicles := SortByDistanceUnit ( hack , vehicles , true , true ) ;
62271: LD_ADDR_VAR 0 2
62275: PUSH
62276: LD_VAR 0 1
62280: PPUSH
62281: LD_VAR 0 2
62285: PPUSH
62286: LD_INT 1
62288: PPUSH
62289: LD_INT 1
62291: PPUSH
62292: CALL 24796 0 4
62296: ST_TO_ADDR
// index := GetElementIndex ( hackTanks , hack ) ;
62297: LD_ADDR_VAR 0 5
62301: PUSH
62302: LD_EXP 88
62306: PPUSH
62307: LD_VAR 0 1
62311: PPUSH
62312: CALL 24146 0 2
62316: ST_TO_ADDR
// if hackTanksCaptured [ index ] < hackLimit then
62317: LD_EXP 89
62321: PUSH
62322: LD_VAR 0 5
62326: ARRAY
62327: PUSH
62328: LD_EXP 90
62332: LESS
62333: IFFALSE 62522
// begin for i := 1 to vehicles do
62335: LD_ADDR_VAR 0 4
62339: PUSH
62340: DOUBLE
62341: LD_INT 1
62343: DEC
62344: ST_TO_ADDR
62345: LD_VAR 0 2
62349: PUSH
62350: FOR_TO
62351: IFFALSE 62520
// begin if hackTanksCaptured [ index ] = hackLimit then
62353: LD_EXP 89
62357: PUSH
62358: LD_VAR 0 5
62362: ARRAY
62363: PUSH
62364: LD_EXP 90
62368: EQUAL
62369: IFFALSE 62373
// break ;
62371: GO 62520
// hackCounter := Replace ( hackCounter , index , hackCounter [ index ] + 1 ) ;
62373: LD_ADDR_EXP 92
62377: PUSH
62378: LD_EXP 92
62382: PPUSH
62383: LD_VAR 0 5
62387: PPUSH
62388: LD_EXP 92
62392: PUSH
62393: LD_VAR 0 5
62397: ARRAY
62398: PUSH
62399: LD_INT 1
62401: PLUS
62402: PPUSH
62403: CALL_OW 1
62407: ST_TO_ADDR
// hackTanksCaptured := ReplaceIn ( hackTanksCaptured , [ index , hackTanksCaptured [ index ] + 1 ] , [ vehicles [ i ] , GetSide ( vehicles [ i ] ) ] ) ;
62408: LD_ADDR_EXP 89
62412: PUSH
62413: LD_EXP 89
62417: PPUSH
62418: LD_VAR 0 5
62422: PUSH
62423: LD_EXP 89
62427: PUSH
62428: LD_VAR 0 5
62432: ARRAY
62433: PUSH
62434: LD_INT 1
62436: PLUS
62437: PUSH
62438: EMPTY
62439: LIST
62440: LIST
62441: PPUSH
62442: LD_VAR 0 2
62446: PUSH
62447: LD_VAR 0 4
62451: ARRAY
62452: PUSH
62453: LD_VAR 0 2
62457: PUSH
62458: LD_VAR 0 4
62462: ARRAY
62463: PPUSH
62464: CALL_OW 255
62468: PUSH
62469: EMPTY
62470: LIST
62471: LIST
62472: PPUSH
62473: CALL 24361 0 3
62477: ST_TO_ADDR
// SetSide ( vehicles [ i ] , GetSide ( hack ) ) ;
62478: LD_VAR 0 2
62482: PUSH
62483: LD_VAR 0 4
62487: ARRAY
62488: PPUSH
62489: LD_VAR 0 1
62493: PPUSH
62494: CALL_OW 255
62498: PPUSH
62499: CALL_OW 235
// ComStop ( vehicles [ i ] ) ;
62503: LD_VAR 0 2
62507: PUSH
62508: LD_VAR 0 4
62512: ARRAY
62513: PPUSH
62514: CALL_OW 141
// end ;
62518: GO 62350
62520: POP
62521: POP
// end ; SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
62522: LD_VAR 0 1
62526: PPUSH
62527: LD_EXP 89
62531: PUSH
62532: LD_VAR 0 5
62536: ARRAY
62537: PUSH
62538: LD_INT 0
62540: PLUS
62541: PPUSH
62542: CALL_OW 505
// end ;
62546: LD_VAR 0 3
62550: RET
// function HackCheckCapturedStatus ( hack ) ; var i , index , tmp ; begin
62551: LD_INT 0
62553: PPUSH
62554: PPUSH
62555: PPUSH
62556: PPUSH
// if not hack in hackTanks then
62557: LD_VAR 0 1
62561: PUSH
62562: LD_EXP 88
62566: IN
62567: NOT
62568: IFFALSE 62572
// exit ;
62570: GO 62812
// index := GetElementIndex ( hackTanks , hack ) ;
62572: LD_ADDR_VAR 0 4
62576: PUSH
62577: LD_EXP 88
62581: PPUSH
62582: LD_VAR 0 1
62586: PPUSH
62587: CALL 24146 0 2
62591: ST_TO_ADDR
// for i := hackTanksCaptured [ index ] downto 1 do
62592: LD_ADDR_VAR 0 3
62596: PUSH
62597: DOUBLE
62598: LD_EXP 89
62602: PUSH
62603: LD_VAR 0 4
62607: ARRAY
62608: INC
62609: ST_TO_ADDR
62610: LD_INT 1
62612: PUSH
62613: FOR_DOWNTO
62614: IFFALSE 62786
// begin tmp := hackTanksCaptured [ index ] [ i ] ;
62616: LD_ADDR_VAR 0 5
62620: PUSH
62621: LD_EXP 89
62625: PUSH
62626: LD_VAR 0 4
62630: ARRAY
62631: PUSH
62632: LD_VAR 0 3
62636: ARRAY
62637: ST_TO_ADDR
// if not IsOk ( tmp [ 1 ] ) or GetSide ( tmp [ 1 ] ) <> GetSide ( hack ) then
62638: LD_VAR 0 5
62642: PUSH
62643: LD_INT 1
62645: ARRAY
62646: PPUSH
62647: CALL_OW 302
62651: NOT
62652: PUSH
62653: LD_VAR 0 5
62657: PUSH
62658: LD_INT 1
62660: ARRAY
62661: PPUSH
62662: CALL_OW 255
62666: PUSH
62667: LD_VAR 0 1
62671: PPUSH
62672: CALL_OW 255
62676: NONEQUAL
62677: OR
62678: IFFALSE 62784
// begin if IsPlaced ( tmp [ 1 ] ) and GetSide ( tmp [ 1 ] ) = GetSide ( hack ) then
62680: LD_VAR 0 5
62684: PUSH
62685: LD_INT 1
62687: ARRAY
62688: PPUSH
62689: CALL_OW 305
62693: PUSH
62694: LD_VAR 0 5
62698: PUSH
62699: LD_INT 1
62701: ARRAY
62702: PPUSH
62703: CALL_OW 255
62707: PUSH
62708: LD_VAR 0 1
62712: PPUSH
62713: CALL_OW 255
62717: EQUAL
62718: AND
62719: IFFALSE 62743
// SetSide ( tmp [ 1 ] , tmp [ 2 ] ) ;
62721: LD_VAR 0 5
62725: PUSH
62726: LD_INT 1
62728: ARRAY
62729: PPUSH
62730: LD_VAR 0 5
62734: PUSH
62735: LD_INT 2
62737: ARRAY
62738: PPUSH
62739: CALL_OW 235
// hackTanksCaptured := Replace ( hackTanksCaptured , index , Delete ( hackTanksCaptured [ index ] , i ) ) ;
62743: LD_ADDR_EXP 89
62747: PUSH
62748: LD_EXP 89
62752: PPUSH
62753: LD_VAR 0 4
62757: PPUSH
62758: LD_EXP 89
62762: PUSH
62763: LD_VAR 0 4
62767: ARRAY
62768: PPUSH
62769: LD_VAR 0 3
62773: PPUSH
62774: CALL_OW 3
62778: PPUSH
62779: CALL_OW 1
62783: ST_TO_ADDR
// end ; end ;
62784: GO 62613
62786: POP
62787: POP
// SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
62788: LD_VAR 0 1
62792: PPUSH
62793: LD_EXP 89
62797: PUSH
62798: LD_VAR 0 4
62802: ARRAY
62803: PUSH
62804: LD_INT 0
62806: PLUS
62807: PPUSH
62808: CALL_OW 505
// end ;
62812: LD_VAR 0 2
62816: RET
// export function HackDestroyVehicle ( hack , vehicle ) ; var i , index , tmp ; begin
62817: LD_INT 0
62819: PPUSH
62820: PPUSH
62821: PPUSH
62822: PPUSH
// if not hack in hackTanks then
62823: LD_VAR 0 1
62827: PUSH
62828: LD_EXP 88
62832: IN
62833: NOT
62834: IFFALSE 62838
// exit ;
62836: GO 62923
// index := GetElementIndex ( hackTanks , hack ) ;
62838: LD_ADDR_VAR 0 5
62842: PUSH
62843: LD_EXP 88
62847: PPUSH
62848: LD_VAR 0 1
62852: PPUSH
62853: CALL 24146 0 2
62857: ST_TO_ADDR
// for i := 1 to hackTanksCaptured [ index ] do
62858: LD_ADDR_VAR 0 4
62862: PUSH
62863: DOUBLE
62864: LD_INT 1
62866: DEC
62867: ST_TO_ADDR
62868: LD_EXP 89
62872: PUSH
62873: LD_VAR 0 5
62877: ARRAY
62878: PUSH
62879: FOR_TO
62880: IFFALSE 62921
// if hackTanksCaptured [ index ] [ i ] [ 1 ] = vehicle then
62882: LD_EXP 89
62886: PUSH
62887: LD_VAR 0 5
62891: ARRAY
62892: PUSH
62893: LD_VAR 0 4
62897: ARRAY
62898: PUSH
62899: LD_INT 1
62901: ARRAY
62902: PUSH
62903: LD_VAR 0 2
62907: EQUAL
62908: IFFALSE 62919
// KillUnit ( vehicle ) ;
62910: LD_VAR 0 2
62914: PPUSH
62915: CALL_OW 66
62919: GO 62879
62921: POP
62922: POP
// end ;
62923: LD_VAR 0 3
62927: RET
// export initMiner , minersList , minerMinesList , minesLimitPerVehicle ; every 0 0$1 trigger not initMiner do
62928: LD_EXP 93
62932: NOT
62933: IFFALSE 62968
62935: GO 62937
62937: DISABLE
// begin initMiner := true ;
62938: LD_ADDR_EXP 93
62942: PUSH
62943: LD_INT 1
62945: ST_TO_ADDR
// minersList := [ ] ;
62946: LD_ADDR_EXP 94
62950: PUSH
62951: EMPTY
62952: ST_TO_ADDR
// minerMinesList := [ ] ;
62953: LD_ADDR_EXP 95
62957: PUSH
62958: EMPTY
62959: ST_TO_ADDR
// minesLimitPerVehicle := 5 ;
62960: LD_ADDR_EXP 96
62964: PUSH
62965: LD_INT 5
62967: ST_TO_ADDR
// end ;
62968: END
// every 0 0$1 trigger initMiner and FilterAllUnits ( [ f_weapon , ar_miner ] ) do var i , j , side , tmp ;
62969: LD_EXP 93
62973: PUSH
62974: LD_INT 34
62976: PUSH
62977: LD_INT 81
62979: PUSH
62980: EMPTY
62981: LIST
62982: LIST
62983: PPUSH
62984: CALL_OW 69
62988: AND
62989: IFFALSE 63450
62991: GO 62993
62993: DISABLE
62994: LD_INT 0
62996: PPUSH
62997: PPUSH
62998: PPUSH
62999: PPUSH
// begin enable ;
63000: ENABLE
// for i in FilterAllUnits ( [ f_weapon , ar_miner ] ) do
63001: LD_ADDR_VAR 0 1
63005: PUSH
63006: LD_INT 34
63008: PUSH
63009: LD_INT 81
63011: PUSH
63012: EMPTY
63013: LIST
63014: LIST
63015: PPUSH
63016: CALL_OW 69
63020: PUSH
63021: FOR_IN
63022: IFFALSE 63094
// begin if not i in minersList then
63024: LD_VAR 0 1
63028: PUSH
63029: LD_EXP 94
63033: IN
63034: NOT
63035: IFFALSE 63092
// begin minersList := Replace ( minersList , minersList + 1 , i ) ;
63037: LD_ADDR_EXP 94
63041: PUSH
63042: LD_EXP 94
63046: PPUSH
63047: LD_EXP 94
63051: PUSH
63052: LD_INT 1
63054: PLUS
63055: PPUSH
63056: LD_VAR 0 1
63060: PPUSH
63061: CALL_OW 1
63065: ST_TO_ADDR
// minerMinesList := Replace ( minerMinesList , minerMinesList + 1 , [ ] ) ;
63066: LD_ADDR_EXP 95
63070: PUSH
63071: LD_EXP 95
63075: PPUSH
63076: LD_EXP 95
63080: PUSH
63081: LD_INT 1
63083: PLUS
63084: PPUSH
63085: EMPTY
63086: PPUSH
63087: CALL_OW 1
63091: ST_TO_ADDR
// end end ;
63092: GO 63021
63094: POP
63095: POP
// for i := minerMinesList downto 1 do
63096: LD_ADDR_VAR 0 1
63100: PUSH
63101: DOUBLE
63102: LD_EXP 95
63106: INC
63107: ST_TO_ADDR
63108: LD_INT 1
63110: PUSH
63111: FOR_DOWNTO
63112: IFFALSE 63448
// begin if IsLive ( minersList [ i ] ) then
63114: LD_EXP 94
63118: PUSH
63119: LD_VAR 0 1
63123: ARRAY
63124: PPUSH
63125: CALL_OW 300
63129: IFFALSE 63157
// SetUnitDisplayNumber ( minersList [ i ] , minerMinesList [ i ] ) ;
63131: LD_EXP 94
63135: PUSH
63136: LD_VAR 0 1
63140: ARRAY
63141: PPUSH
63142: LD_EXP 95
63146: PUSH
63147: LD_VAR 0 1
63151: ARRAY
63152: PPUSH
63153: CALL_OW 505
// if not minerMinesList [ i ] then
63157: LD_EXP 95
63161: PUSH
63162: LD_VAR 0 1
63166: ARRAY
63167: NOT
63168: IFFALSE 63172
// continue ;
63170: GO 63111
// for j := minerMinesList [ i ] downto 1 do
63172: LD_ADDR_VAR 0 2
63176: PUSH
63177: DOUBLE
63178: LD_EXP 95
63182: PUSH
63183: LD_VAR 0 1
63187: ARRAY
63188: INC
63189: ST_TO_ADDR
63190: LD_INT 1
63192: PUSH
63193: FOR_DOWNTO
63194: IFFALSE 63444
// begin side := GetSide ( minersList [ i ] ) ;
63196: LD_ADDR_VAR 0 3
63200: PUSH
63201: LD_EXP 94
63205: PUSH
63206: LD_VAR 0 1
63210: ARRAY
63211: PPUSH
63212: CALL_OW 255
63216: ST_TO_ADDR
// tmp := HexInfo ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) ;
63217: LD_ADDR_VAR 0 4
63221: PUSH
63222: LD_EXP 95
63226: PUSH
63227: LD_VAR 0 1
63231: ARRAY
63232: PUSH
63233: LD_VAR 0 2
63237: ARRAY
63238: PUSH
63239: LD_INT 1
63241: ARRAY
63242: PPUSH
63243: LD_EXP 95
63247: PUSH
63248: LD_VAR 0 1
63252: ARRAY
63253: PUSH
63254: LD_VAR 0 2
63258: ARRAY
63259: PUSH
63260: LD_INT 2
63262: ARRAY
63263: PPUSH
63264: CALL_OW 428
63268: ST_TO_ADDR
// if not tmp then
63269: LD_VAR 0 4
63273: NOT
63274: IFFALSE 63278
// continue ;
63276: GO 63193
// if tmp in FilterAllUnits ( [ f_enemy , side ] ) and MineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) then
63278: LD_VAR 0 4
63282: PUSH
63283: LD_INT 81
63285: PUSH
63286: LD_VAR 0 3
63290: PUSH
63291: EMPTY
63292: LIST
63293: LIST
63294: PPUSH
63295: CALL_OW 69
63299: IN
63300: PUSH
63301: LD_EXP 95
63305: PUSH
63306: LD_VAR 0 1
63310: ARRAY
63311: PUSH
63312: LD_VAR 0 2
63316: ARRAY
63317: PUSH
63318: LD_INT 1
63320: ARRAY
63321: PPUSH
63322: LD_EXP 95
63326: PUSH
63327: LD_VAR 0 1
63331: ARRAY
63332: PUSH
63333: LD_VAR 0 2
63337: ARRAY
63338: PUSH
63339: LD_INT 2
63341: ARRAY
63342: PPUSH
63343: CALL_OW 458
63347: AND
63348: IFFALSE 63442
// begin LaunchMineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] , side ) ;
63350: LD_EXP 95
63354: PUSH
63355: LD_VAR 0 1
63359: ARRAY
63360: PUSH
63361: LD_VAR 0 2
63365: ARRAY
63366: PUSH
63367: LD_INT 1
63369: ARRAY
63370: PPUSH
63371: LD_EXP 95
63375: PUSH
63376: LD_VAR 0 1
63380: ARRAY
63381: PUSH
63382: LD_VAR 0 2
63386: ARRAY
63387: PUSH
63388: LD_INT 2
63390: ARRAY
63391: PPUSH
63392: LD_VAR 0 3
63396: PPUSH
63397: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , i , Delete ( minerMinesList [ i ] , j ) ) ;
63401: LD_ADDR_EXP 95
63405: PUSH
63406: LD_EXP 95
63410: PPUSH
63411: LD_VAR 0 1
63415: PPUSH
63416: LD_EXP 95
63420: PUSH
63421: LD_VAR 0 1
63425: ARRAY
63426: PPUSH
63427: LD_VAR 0 2
63431: PPUSH
63432: CALL_OW 3
63436: PPUSH
63437: CALL_OW 1
63441: ST_TO_ADDR
// end ; end ;
63442: GO 63193
63444: POP
63445: POP
// end ;
63446: GO 63111
63448: POP
63449: POP
// end ;
63450: PPOPN 4
63452: END
// export function MinerPlaceMine ( unit , x , y ) ; var index ; begin
63453: LD_INT 0
63455: PPUSH
63456: PPUSH
// result := false ;
63457: LD_ADDR_VAR 0 4
63461: PUSH
63462: LD_INT 0
63464: ST_TO_ADDR
// if not GetWeapon ( unit ) = ar_miner then
63465: LD_VAR 0 1
63469: PPUSH
63470: CALL_OW 264
63474: PUSH
63475: LD_INT 81
63477: EQUAL
63478: NOT
63479: IFFALSE 63483
// exit ;
63481: GO 63723
// index := GetElementIndex ( minersList , unit ) ;
63483: LD_ADDR_VAR 0 5
63487: PUSH
63488: LD_EXP 94
63492: PPUSH
63493: LD_VAR 0 1
63497: PPUSH
63498: CALL 24146 0 2
63502: ST_TO_ADDR
// if minerMinesList [ index ] >= minesLimitPerVehicle then
63503: LD_EXP 95
63507: PUSH
63508: LD_VAR 0 5
63512: ARRAY
63513: PUSH
63514: LD_EXP 96
63518: GREATEREQUAL
63519: IFFALSE 63523
// exit ;
63521: GO 63723
// ComMoveXY ( unit , x , y ) ;
63523: LD_VAR 0 1
63527: PPUSH
63528: LD_VAR 0 2
63532: PPUSH
63533: LD_VAR 0 3
63537: PPUSH
63538: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
63542: LD_INT 35
63544: PPUSH
63545: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) and HasTask ( unit ) then
63549: LD_VAR 0 1
63553: PPUSH
63554: LD_VAR 0 2
63558: PPUSH
63559: LD_VAR 0 3
63563: PPUSH
63564: CALL 55501 0 3
63568: NOT
63569: PUSH
63570: LD_VAR 0 1
63574: PPUSH
63575: CALL_OW 314
63579: AND
63580: IFFALSE 63584
// exit ;
63582: GO 63723
// until HexInfo ( x , y ) = unit and not HasTask ( unit ) ;
63584: LD_VAR 0 2
63588: PPUSH
63589: LD_VAR 0 3
63593: PPUSH
63594: CALL_OW 428
63598: PUSH
63599: LD_VAR 0 1
63603: EQUAL
63604: PUSH
63605: LD_VAR 0 1
63609: PPUSH
63610: CALL_OW 314
63614: NOT
63615: AND
63616: IFFALSE 63542
// PlaySoundXY ( x , y , PlantMine ) ;
63618: LD_VAR 0 2
63622: PPUSH
63623: LD_VAR 0 3
63627: PPUSH
63628: LD_STRING PlantMine
63630: PPUSH
63631: CALL_OW 366
// PlaceMine ( x , y , GetSide ( unit ) , 0 ) ;
63635: LD_VAR 0 2
63639: PPUSH
63640: LD_VAR 0 3
63644: PPUSH
63645: LD_VAR 0 1
63649: PPUSH
63650: CALL_OW 255
63654: PPUSH
63655: LD_INT 0
63657: PPUSH
63658: CALL_OW 454
// minerMinesList := ReplaceIn ( minerMinesList , [ index , minerMinesList [ index ] + 1 ] , [ x , y ] ) ;
63662: LD_ADDR_EXP 95
63666: PUSH
63667: LD_EXP 95
63671: PPUSH
63672: LD_VAR 0 5
63676: PUSH
63677: LD_EXP 95
63681: PUSH
63682: LD_VAR 0 5
63686: ARRAY
63687: PUSH
63688: LD_INT 1
63690: PLUS
63691: PUSH
63692: EMPTY
63693: LIST
63694: LIST
63695: PPUSH
63696: LD_VAR 0 2
63700: PUSH
63701: LD_VAR 0 3
63705: PUSH
63706: EMPTY
63707: LIST
63708: LIST
63709: PPUSH
63710: CALL 24361 0 3
63714: ST_TO_ADDR
// result := true ;
63715: LD_ADDR_VAR 0 4
63719: PUSH
63720: LD_INT 1
63722: ST_TO_ADDR
// end ;
63723: LD_VAR 0 4
63727: RET
// export function MinerDetonateMine ( unit , x , y ) ; var i , index ; begin
63728: LD_INT 0
63730: PPUSH
63731: PPUSH
63732: PPUSH
// if not unit in minersList then
63733: LD_VAR 0 1
63737: PUSH
63738: LD_EXP 94
63742: IN
63743: NOT
63744: IFFALSE 63748
// exit ;
63746: GO 64140
// index := GetElementIndex ( minersList , unit ) ;
63748: LD_ADDR_VAR 0 6
63752: PUSH
63753: LD_EXP 94
63757: PPUSH
63758: LD_VAR 0 1
63762: PPUSH
63763: CALL 24146 0 2
63767: ST_TO_ADDR
// for i := minerMinesList [ index ] downto 1 do
63768: LD_ADDR_VAR 0 5
63772: PUSH
63773: DOUBLE
63774: LD_EXP 95
63778: PUSH
63779: LD_VAR 0 6
63783: ARRAY
63784: INC
63785: ST_TO_ADDR
63786: LD_INT 1
63788: PUSH
63789: FOR_DOWNTO
63790: IFFALSE 63951
// begin if minerMinesList [ index ] [ i ] [ 1 ] = x and minerMinesList [ index ] [ i ] [ 2 ] = y then
63792: LD_EXP 95
63796: PUSH
63797: LD_VAR 0 6
63801: ARRAY
63802: PUSH
63803: LD_VAR 0 5
63807: ARRAY
63808: PUSH
63809: LD_INT 1
63811: ARRAY
63812: PUSH
63813: LD_VAR 0 2
63817: EQUAL
63818: PUSH
63819: LD_EXP 95
63823: PUSH
63824: LD_VAR 0 6
63828: ARRAY
63829: PUSH
63830: LD_VAR 0 5
63834: ARRAY
63835: PUSH
63836: LD_INT 2
63838: ARRAY
63839: PUSH
63840: LD_VAR 0 3
63844: EQUAL
63845: AND
63846: IFFALSE 63949
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
63848: LD_EXP 95
63852: PUSH
63853: LD_VAR 0 6
63857: ARRAY
63858: PUSH
63859: LD_VAR 0 5
63863: ARRAY
63864: PUSH
63865: LD_INT 1
63867: ARRAY
63868: PPUSH
63869: LD_EXP 95
63873: PUSH
63874: LD_VAR 0 6
63878: ARRAY
63879: PUSH
63880: LD_VAR 0 5
63884: ARRAY
63885: PUSH
63886: LD_INT 2
63888: ARRAY
63889: PPUSH
63890: LD_VAR 0 1
63894: PPUSH
63895: CALL_OW 255
63899: PPUSH
63900: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
63904: LD_ADDR_EXP 95
63908: PUSH
63909: LD_EXP 95
63913: PPUSH
63914: LD_VAR 0 6
63918: PPUSH
63919: LD_EXP 95
63923: PUSH
63924: LD_VAR 0 6
63928: ARRAY
63929: PPUSH
63930: LD_VAR 0 5
63934: PPUSH
63935: CALL_OW 3
63939: PPUSH
63940: CALL_OW 1
63944: ST_TO_ADDR
// exit ;
63945: POP
63946: POP
63947: GO 64140
// end ; end ;
63949: GO 63789
63951: POP
63952: POP
// for i := minerMinesList [ index ] downto 1 do
63953: LD_ADDR_VAR 0 5
63957: PUSH
63958: DOUBLE
63959: LD_EXP 95
63963: PUSH
63964: LD_VAR 0 6
63968: ARRAY
63969: INC
63970: ST_TO_ADDR
63971: LD_INT 1
63973: PUSH
63974: FOR_DOWNTO
63975: IFFALSE 64138
// begin if GetDistXY ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , x , y ) < 6 then
63977: LD_EXP 95
63981: PUSH
63982: LD_VAR 0 6
63986: ARRAY
63987: PUSH
63988: LD_VAR 0 5
63992: ARRAY
63993: PUSH
63994: LD_INT 1
63996: ARRAY
63997: PPUSH
63998: LD_EXP 95
64002: PUSH
64003: LD_VAR 0 6
64007: ARRAY
64008: PUSH
64009: LD_VAR 0 5
64013: ARRAY
64014: PUSH
64015: LD_INT 2
64017: ARRAY
64018: PPUSH
64019: LD_VAR 0 2
64023: PPUSH
64024: LD_VAR 0 3
64028: PPUSH
64029: CALL_OW 298
64033: PUSH
64034: LD_INT 6
64036: LESS
64037: IFFALSE 64136
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
64039: LD_EXP 95
64043: PUSH
64044: LD_VAR 0 6
64048: ARRAY
64049: PUSH
64050: LD_VAR 0 5
64054: ARRAY
64055: PUSH
64056: LD_INT 1
64058: ARRAY
64059: PPUSH
64060: LD_EXP 95
64064: PUSH
64065: LD_VAR 0 6
64069: ARRAY
64070: PUSH
64071: LD_VAR 0 5
64075: ARRAY
64076: PUSH
64077: LD_INT 2
64079: ARRAY
64080: PPUSH
64081: LD_VAR 0 1
64085: PPUSH
64086: CALL_OW 255
64090: PPUSH
64091: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
64095: LD_ADDR_EXP 95
64099: PUSH
64100: LD_EXP 95
64104: PPUSH
64105: LD_VAR 0 6
64109: PPUSH
64110: LD_EXP 95
64114: PUSH
64115: LD_VAR 0 6
64119: ARRAY
64120: PPUSH
64121: LD_VAR 0 5
64125: PPUSH
64126: CALL_OW 3
64130: PPUSH
64131: CALL_OW 1
64135: ST_TO_ADDR
// end ; end ;
64136: GO 63974
64138: POP
64139: POP
// end ;
64140: LD_VAR 0 4
64144: RET
// export function MinerCreateMinefield ( unit , x , y ) ; var i , index , tmp , minesFreeAmount , _x , _y , _d , _r ; begin
64145: LD_INT 0
64147: PPUSH
64148: PPUSH
64149: PPUSH
64150: PPUSH
64151: PPUSH
64152: PPUSH
64153: PPUSH
64154: PPUSH
64155: PPUSH
// if not GetWeapon ( unit ) = ar_miner or not unit in minersList then
64156: LD_VAR 0 1
64160: PPUSH
64161: CALL_OW 264
64165: PUSH
64166: LD_INT 81
64168: EQUAL
64169: NOT
64170: PUSH
64171: LD_VAR 0 1
64175: PUSH
64176: LD_EXP 94
64180: IN
64181: NOT
64182: OR
64183: IFFALSE 64187
// exit ;
64185: GO 64509
// index := GetElementIndex ( minersList , unit ) ;
64187: LD_ADDR_VAR 0 6
64191: PUSH
64192: LD_EXP 94
64196: PPUSH
64197: LD_VAR 0 1
64201: PPUSH
64202: CALL 24146 0 2
64206: ST_TO_ADDR
// minesFreeAmount := minesLimitPerVehicle - minerMinesList [ index ] ;
64207: LD_ADDR_VAR 0 8
64211: PUSH
64212: LD_EXP 96
64216: PUSH
64217: LD_EXP 95
64221: PUSH
64222: LD_VAR 0 6
64226: ARRAY
64227: MINUS
64228: ST_TO_ADDR
// if not minesFreeAmount then
64229: LD_VAR 0 8
64233: NOT
64234: IFFALSE 64238
// exit ;
64236: GO 64509
// tmp := [ ] ;
64238: LD_ADDR_VAR 0 7
64242: PUSH
64243: EMPTY
64244: ST_TO_ADDR
// for i := 1 to minesFreeAmount do
64245: LD_ADDR_VAR 0 5
64249: PUSH
64250: DOUBLE
64251: LD_INT 1
64253: DEC
64254: ST_TO_ADDR
64255: LD_VAR 0 8
64259: PUSH
64260: FOR_TO
64261: IFFALSE 64456
// begin _d := rand ( 0 , 5 ) ;
64263: LD_ADDR_VAR 0 11
64267: PUSH
64268: LD_INT 0
64270: PPUSH
64271: LD_INT 5
64273: PPUSH
64274: CALL_OW 12
64278: ST_TO_ADDR
// _r := rand ( 2 , 6 ) ;
64279: LD_ADDR_VAR 0 12
64283: PUSH
64284: LD_INT 2
64286: PPUSH
64287: LD_INT 6
64289: PPUSH
64290: CALL_OW 12
64294: ST_TO_ADDR
// _x := ShiftX ( x , _d , _r ) ;
64295: LD_ADDR_VAR 0 9
64299: PUSH
64300: LD_VAR 0 2
64304: PPUSH
64305: LD_VAR 0 11
64309: PPUSH
64310: LD_VAR 0 12
64314: PPUSH
64315: CALL_OW 272
64319: ST_TO_ADDR
// _y := ShiftY ( y , _d , _r ) ;
64320: LD_ADDR_VAR 0 10
64324: PUSH
64325: LD_VAR 0 3
64329: PPUSH
64330: LD_VAR 0 11
64334: PPUSH
64335: LD_VAR 0 12
64339: PPUSH
64340: CALL_OW 273
64344: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not [ _x , _y ] in tmp and not MineAtPos ( _x , _y ) then
64345: LD_VAR 0 9
64349: PPUSH
64350: LD_VAR 0 10
64354: PPUSH
64355: CALL_OW 488
64359: PUSH
64360: LD_VAR 0 9
64364: PUSH
64365: LD_VAR 0 10
64369: PUSH
64370: EMPTY
64371: LIST
64372: LIST
64373: PUSH
64374: LD_VAR 0 7
64378: IN
64379: NOT
64380: AND
64381: PUSH
64382: LD_VAR 0 9
64386: PPUSH
64387: LD_VAR 0 10
64391: PPUSH
64392: CALL_OW 458
64396: NOT
64397: AND
64398: IFFALSE 64440
// tmp := Replace ( tmp , tmp + 1 , [ _x , _y ] ) else
64400: LD_ADDR_VAR 0 7
64404: PUSH
64405: LD_VAR 0 7
64409: PPUSH
64410: LD_VAR 0 7
64414: PUSH
64415: LD_INT 1
64417: PLUS
64418: PPUSH
64419: LD_VAR 0 9
64423: PUSH
64424: LD_VAR 0 10
64428: PUSH
64429: EMPTY
64430: LIST
64431: LIST
64432: PPUSH
64433: CALL_OW 1
64437: ST_TO_ADDR
64438: GO 64454
// i := i - 1 ;
64440: LD_ADDR_VAR 0 5
64444: PUSH
64445: LD_VAR 0 5
64449: PUSH
64450: LD_INT 1
64452: MINUS
64453: ST_TO_ADDR
// end ;
64454: GO 64260
64456: POP
64457: POP
// for i in tmp do
64458: LD_ADDR_VAR 0 5
64462: PUSH
64463: LD_VAR 0 7
64467: PUSH
64468: FOR_IN
64469: IFFALSE 64507
// if not MinerPlaceMine ( unit , i [ 1 ] , i [ 2 ] ) then
64471: LD_VAR 0 1
64475: PPUSH
64476: LD_VAR 0 5
64480: PUSH
64481: LD_INT 1
64483: ARRAY
64484: PPUSH
64485: LD_VAR 0 5
64489: PUSH
64490: LD_INT 2
64492: ARRAY
64493: PPUSH
64494: CALL 63453 0 3
64498: NOT
64499: IFFALSE 64505
// exit ;
64501: POP
64502: POP
64503: GO 64509
64505: GO 64468
64507: POP
64508: POP
// end ;
64509: LD_VAR 0 4
64513: RET
// export function ComBinocular ( unit , x , y ) ; var dist , side , viewRange , _x , _y , _d ; begin
64514: LD_INT 0
64516: PPUSH
64517: PPUSH
64518: PPUSH
64519: PPUSH
64520: PPUSH
64521: PPUSH
64522: PPUSH
// if not GetClass ( unit ) = class_sniper then
64523: LD_VAR 0 1
64527: PPUSH
64528: CALL_OW 257
64532: PUSH
64533: LD_INT 5
64535: EQUAL
64536: NOT
64537: IFFALSE 64541
// exit ;
64539: GO 64929
// dist := 8 ;
64541: LD_ADDR_VAR 0 5
64545: PUSH
64546: LD_INT 8
64548: ST_TO_ADDR
// viewRange := 12 ;
64549: LD_ADDR_VAR 0 7
64553: PUSH
64554: LD_INT 12
64556: ST_TO_ADDR
// side := GetSide ( unit ) ;
64557: LD_ADDR_VAR 0 6
64561: PUSH
64562: LD_VAR 0 1
64566: PPUSH
64567: CALL_OW 255
64571: ST_TO_ADDR
// if GetTech ( tech_opto2 , side ) = state_researched then
64572: LD_INT 61
64574: PPUSH
64575: LD_VAR 0 6
64579: PPUSH
64580: CALL_OW 321
64584: PUSH
64585: LD_INT 2
64587: EQUAL
64588: IFFALSE 64598
// viewRange := 16 ;
64590: LD_ADDR_VAR 0 7
64594: PUSH
64595: LD_INT 16
64597: ST_TO_ADDR
// if GetDistUnitXY ( unit , x , y ) > dist then
64598: LD_VAR 0 1
64602: PPUSH
64603: LD_VAR 0 2
64607: PPUSH
64608: LD_VAR 0 3
64612: PPUSH
64613: CALL_OW 297
64617: PUSH
64618: LD_VAR 0 5
64622: GREATER
64623: IFFALSE 64702
// begin ComMoveXY ( unit , x , y ) ;
64625: LD_VAR 0 1
64629: PPUSH
64630: LD_VAR 0 2
64634: PPUSH
64635: LD_VAR 0 3
64639: PPUSH
64640: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
64644: LD_INT 35
64646: PPUSH
64647: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) then
64651: LD_VAR 0 1
64655: PPUSH
64656: LD_VAR 0 2
64660: PPUSH
64661: LD_VAR 0 3
64665: PPUSH
64666: CALL 55501 0 3
64670: NOT
64671: IFFALSE 64675
// exit ;
64673: GO 64929
// until GetDistUnitXY ( unit , x , y ) < dist ;
64675: LD_VAR 0 1
64679: PPUSH
64680: LD_VAR 0 2
64684: PPUSH
64685: LD_VAR 0 3
64689: PPUSH
64690: CALL_OW 297
64694: PUSH
64695: LD_VAR 0 5
64699: LESS
64700: IFFALSE 64644
// end ; ComTurnXY ( unit , x , y ) ;
64702: LD_VAR 0 1
64706: PPUSH
64707: LD_VAR 0 2
64711: PPUSH
64712: LD_VAR 0 3
64716: PPUSH
64717: CALL_OW 118
// wait ( 5 ) ;
64721: LD_INT 5
64723: PPUSH
64724: CALL_OW 67
// _d := GetDir ( unit ) ;
64728: LD_ADDR_VAR 0 10
64732: PUSH
64733: LD_VAR 0 1
64737: PPUSH
64738: CALL_OW 254
64742: ST_TO_ADDR
// _x := ShiftX ( GetX ( unit ) , _d , dist ) ;
64743: LD_ADDR_VAR 0 8
64747: PUSH
64748: LD_VAR 0 1
64752: PPUSH
64753: CALL_OW 250
64757: PPUSH
64758: LD_VAR 0 10
64762: PPUSH
64763: LD_VAR 0 5
64767: PPUSH
64768: CALL_OW 272
64772: ST_TO_ADDR
// _y := ShiftY ( GetY ( unit ) , _d , dist ) ;
64773: LD_ADDR_VAR 0 9
64777: PUSH
64778: LD_VAR 0 1
64782: PPUSH
64783: CALL_OW 251
64787: PPUSH
64788: LD_VAR 0 10
64792: PPUSH
64793: LD_VAR 0 5
64797: PPUSH
64798: CALL_OW 273
64802: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
64803: LD_VAR 0 8
64807: PPUSH
64808: LD_VAR 0 9
64812: PPUSH
64813: CALL_OW 488
64817: NOT
64818: IFFALSE 64822
// exit ;
64820: GO 64929
// ComAnimCustom ( unit , 1 ) ;
64822: LD_VAR 0 1
64826: PPUSH
64827: LD_INT 1
64829: PPUSH
64830: CALL_OW 592
// PlaceSeeing ( _x , _y , side , viewRange ) ;
64834: LD_VAR 0 8
64838: PPUSH
64839: LD_VAR 0 9
64843: PPUSH
64844: LD_VAR 0 6
64848: PPUSH
64849: LD_VAR 0 7
64853: PPUSH
64854: CALL_OW 330
// repeat wait ( 1 ) ;
64858: LD_INT 1
64860: PPUSH
64861: CALL_OW 67
// until IsIdle ( unit ) or HasTask ( unit ) or not IsOk ( unit ) or IsDead ( unit ) ;
64865: LD_VAR 0 1
64869: PPUSH
64870: CALL_OW 316
64874: PUSH
64875: LD_VAR 0 1
64879: PPUSH
64880: CALL_OW 314
64884: OR
64885: PUSH
64886: LD_VAR 0 1
64890: PPUSH
64891: CALL_OW 302
64895: NOT
64896: OR
64897: PUSH
64898: LD_VAR 0 1
64902: PPUSH
64903: CALL_OW 301
64907: OR
64908: IFFALSE 64858
// RemoveSeeing ( _x , _y , side ) ;
64910: LD_VAR 0 8
64914: PPUSH
64915: LD_VAR 0 9
64919: PPUSH
64920: LD_VAR 0 6
64924: PPUSH
64925: CALL_OW 331
// end ; end_of_file
64929: LD_VAR 0 4
64933: RET
// export globalGameSaveCounter ; every 0 0$1 do
64934: GO 64936
64936: DISABLE
// begin enable ;
64937: ENABLE
// ToLua ( updateTimer( & tick & ); ) ;
64938: LD_STRING updateTimer(
64940: PUSH
64941: LD_OWVAR 1
64945: STR
64946: PUSH
64947: LD_STRING );
64949: STR
64950: PPUSH
64951: CALL_OW 559
// end ;
64955: END
// every 0 0$1 do
64956: GO 64958
64958: DISABLE
// begin globalGameSaveCounter := 0 ;
64959: LD_ADDR_EXP 97
64963: PUSH
64964: LD_INT 0
64966: ST_TO_ADDR
// ToLua ( setGameSaveCounter(0) ) ;
64967: LD_STRING setGameSaveCounter(0)
64969: PPUSH
64970: CALL_OW 559
// ToLua ( initStreamRollete(); ) ;
64974: LD_STRING initStreamRollete();
64976: PPUSH
64977: CALL_OW 559
// InitStreamMode ;
64981: CALL 66307 0 0
// DefineStreamItems ( false ) ;
64985: LD_INT 0
64987: PPUSH
64988: CALL 66771 0 1
// end ;
64992: END
// export function SOS_MapStart ( ) ; begin
64993: LD_INT 0
64995: PPUSH
// if streamModeActive then
64996: LD_EXP 98
65000: IFFALSE 65009
// DefineStreamItems ( true ) ;
65002: LD_INT 1
65004: PPUSH
65005: CALL 66771 0 1
// UpdateLuaVariables ( ) ;
65009: CALL 65026 0 0
// UpdateFactoryWaypoints ( ) ;
65013: CALL 79632 0 0
// UpdateWarehouseGatheringPoints ( ) ;
65017: CALL 79889 0 0
// end ;
65021: LD_VAR 0 1
65025: RET
// function UpdateLuaVariables ( ) ; begin
65026: LD_INT 0
65028: PPUSH
// if globalGameSaveCounter then
65029: LD_EXP 97
65033: IFFALSE 65067
// begin globalGameSaveCounter := Inc ( globalGameSaveCounter ) ;
65035: LD_ADDR_EXP 97
65039: PUSH
65040: LD_EXP 97
65044: PPUSH
65045: CALL 58053 0 1
65049: ST_TO_ADDR
// ToLua ( setGameSaveCounter( & globalGameSaveCounter & ) ) ;
65050: LD_STRING setGameSaveCounter(
65052: PUSH
65053: LD_EXP 97
65057: STR
65058: PUSH
65059: LD_STRING )
65061: STR
65062: PPUSH
65063: CALL_OW 559
// end ; ToLua ( setGameDifficulty( & Difficulty & ) ) ;
65067: LD_STRING setGameDifficulty(
65069: PUSH
65070: LD_OWVAR 67
65074: STR
65075: PUSH
65076: LD_STRING )
65078: STR
65079: PPUSH
65080: CALL_OW 559
// end ;
65084: LD_VAR 0 1
65088: RET
// export function SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
65089: LD_INT 0
65091: PPUSH
// if p2 = stream_mode then
65092: LD_VAR 0 2
65096: PUSH
65097: LD_INT 100
65099: EQUAL
65100: IFFALSE 66103
// begin if not StreamModeActive then
65102: LD_EXP 98
65106: NOT
65107: IFFALSE 65117
// StreamModeActive := true ;
65109: LD_ADDR_EXP 98
65113: PUSH
65114: LD_INT 1
65116: ST_TO_ADDR
// if p3 = 0 then
65117: LD_VAR 0 3
65121: PUSH
65122: LD_INT 0
65124: EQUAL
65125: IFFALSE 65131
// InitStreamMode ;
65127: CALL 66307 0 0
// if p3 = 1 then
65131: LD_VAR 0 3
65135: PUSH
65136: LD_INT 1
65138: EQUAL
65139: IFFALSE 65149
// sRocket := true ;
65141: LD_ADDR_EXP 103
65145: PUSH
65146: LD_INT 1
65148: ST_TO_ADDR
// if p3 = 2 then
65149: LD_VAR 0 3
65153: PUSH
65154: LD_INT 2
65156: EQUAL
65157: IFFALSE 65167
// sSpeed := true ;
65159: LD_ADDR_EXP 102
65163: PUSH
65164: LD_INT 1
65166: ST_TO_ADDR
// if p3 = 3 then
65167: LD_VAR 0 3
65171: PUSH
65172: LD_INT 3
65174: EQUAL
65175: IFFALSE 65185
// sEngine := true ;
65177: LD_ADDR_EXP 104
65181: PUSH
65182: LD_INT 1
65184: ST_TO_ADDR
// if p3 = 4 then
65185: LD_VAR 0 3
65189: PUSH
65190: LD_INT 4
65192: EQUAL
65193: IFFALSE 65203
// sSpec := true ;
65195: LD_ADDR_EXP 101
65199: PUSH
65200: LD_INT 1
65202: ST_TO_ADDR
// if p3 = 5 then
65203: LD_VAR 0 3
65207: PUSH
65208: LD_INT 5
65210: EQUAL
65211: IFFALSE 65221
// sLevel := true ;
65213: LD_ADDR_EXP 105
65217: PUSH
65218: LD_INT 1
65220: ST_TO_ADDR
// if p3 = 6 then
65221: LD_VAR 0 3
65225: PUSH
65226: LD_INT 6
65228: EQUAL
65229: IFFALSE 65239
// sArmoury := true ;
65231: LD_ADDR_EXP 106
65235: PUSH
65236: LD_INT 1
65238: ST_TO_ADDR
// if p3 = 7 then
65239: LD_VAR 0 3
65243: PUSH
65244: LD_INT 7
65246: EQUAL
65247: IFFALSE 65257
// sRadar := true ;
65249: LD_ADDR_EXP 107
65253: PUSH
65254: LD_INT 1
65256: ST_TO_ADDR
// if p3 = 8 then
65257: LD_VAR 0 3
65261: PUSH
65262: LD_INT 8
65264: EQUAL
65265: IFFALSE 65275
// sBunker := true ;
65267: LD_ADDR_EXP 108
65271: PUSH
65272: LD_INT 1
65274: ST_TO_ADDR
// if p3 = 9 then
65275: LD_VAR 0 3
65279: PUSH
65280: LD_INT 9
65282: EQUAL
65283: IFFALSE 65293
// sHack := true ;
65285: LD_ADDR_EXP 109
65289: PUSH
65290: LD_INT 1
65292: ST_TO_ADDR
// if p3 = 10 then
65293: LD_VAR 0 3
65297: PUSH
65298: LD_INT 10
65300: EQUAL
65301: IFFALSE 65311
// sFire := true ;
65303: LD_ADDR_EXP 110
65307: PUSH
65308: LD_INT 1
65310: ST_TO_ADDR
// if p3 = 11 then
65311: LD_VAR 0 3
65315: PUSH
65316: LD_INT 11
65318: EQUAL
65319: IFFALSE 65329
// sRefresh := true ;
65321: LD_ADDR_EXP 111
65325: PUSH
65326: LD_INT 1
65328: ST_TO_ADDR
// if p3 = 12 then
65329: LD_VAR 0 3
65333: PUSH
65334: LD_INT 12
65336: EQUAL
65337: IFFALSE 65347
// sExp := true ;
65339: LD_ADDR_EXP 112
65343: PUSH
65344: LD_INT 1
65346: ST_TO_ADDR
// if p3 = 13 then
65347: LD_VAR 0 3
65351: PUSH
65352: LD_INT 13
65354: EQUAL
65355: IFFALSE 65365
// sDepot := true ;
65357: LD_ADDR_EXP 113
65361: PUSH
65362: LD_INT 1
65364: ST_TO_ADDR
// if p3 = 14 then
65365: LD_VAR 0 3
65369: PUSH
65370: LD_INT 14
65372: EQUAL
65373: IFFALSE 65383
// sFlag := true ;
65375: LD_ADDR_EXP 114
65379: PUSH
65380: LD_INT 1
65382: ST_TO_ADDR
// if p3 = 15 then
65383: LD_VAR 0 3
65387: PUSH
65388: LD_INT 15
65390: EQUAL
65391: IFFALSE 65401
// sKamikadze := true ;
65393: LD_ADDR_EXP 122
65397: PUSH
65398: LD_INT 1
65400: ST_TO_ADDR
// if p3 = 16 then
65401: LD_VAR 0 3
65405: PUSH
65406: LD_INT 16
65408: EQUAL
65409: IFFALSE 65419
// sTroll := true ;
65411: LD_ADDR_EXP 123
65415: PUSH
65416: LD_INT 1
65418: ST_TO_ADDR
// if p3 = 17 then
65419: LD_VAR 0 3
65423: PUSH
65424: LD_INT 17
65426: EQUAL
65427: IFFALSE 65437
// sSlow := true ;
65429: LD_ADDR_EXP 124
65433: PUSH
65434: LD_INT 1
65436: ST_TO_ADDR
// if p3 = 18 then
65437: LD_VAR 0 3
65441: PUSH
65442: LD_INT 18
65444: EQUAL
65445: IFFALSE 65455
// sLack := true ;
65447: LD_ADDR_EXP 125
65451: PUSH
65452: LD_INT 1
65454: ST_TO_ADDR
// if p3 = 19 then
65455: LD_VAR 0 3
65459: PUSH
65460: LD_INT 19
65462: EQUAL
65463: IFFALSE 65473
// sTank := true ;
65465: LD_ADDR_EXP 127
65469: PUSH
65470: LD_INT 1
65472: ST_TO_ADDR
// if p3 = 20 then
65473: LD_VAR 0 3
65477: PUSH
65478: LD_INT 20
65480: EQUAL
65481: IFFALSE 65491
// sRemote := true ;
65483: LD_ADDR_EXP 128
65487: PUSH
65488: LD_INT 1
65490: ST_TO_ADDR
// if p3 = 21 then
65491: LD_VAR 0 3
65495: PUSH
65496: LD_INT 21
65498: EQUAL
65499: IFFALSE 65509
// sPowell := true ;
65501: LD_ADDR_EXP 129
65505: PUSH
65506: LD_INT 1
65508: ST_TO_ADDR
// if p3 = 22 then
65509: LD_VAR 0 3
65513: PUSH
65514: LD_INT 22
65516: EQUAL
65517: IFFALSE 65527
// sTeleport := true ;
65519: LD_ADDR_EXP 132
65523: PUSH
65524: LD_INT 1
65526: ST_TO_ADDR
// if p3 = 23 then
65527: LD_VAR 0 3
65531: PUSH
65532: LD_INT 23
65534: EQUAL
65535: IFFALSE 65545
// sOilTower := true ;
65537: LD_ADDR_EXP 134
65541: PUSH
65542: LD_INT 1
65544: ST_TO_ADDR
// if p3 = 24 then
65545: LD_VAR 0 3
65549: PUSH
65550: LD_INT 24
65552: EQUAL
65553: IFFALSE 65563
// sShovel := true ;
65555: LD_ADDR_EXP 135
65559: PUSH
65560: LD_INT 1
65562: ST_TO_ADDR
// if p3 = 25 then
65563: LD_VAR 0 3
65567: PUSH
65568: LD_INT 25
65570: EQUAL
65571: IFFALSE 65581
// sSheik := true ;
65573: LD_ADDR_EXP 136
65577: PUSH
65578: LD_INT 1
65580: ST_TO_ADDR
// if p3 = 26 then
65581: LD_VAR 0 3
65585: PUSH
65586: LD_INT 26
65588: EQUAL
65589: IFFALSE 65599
// sEarthquake := true ;
65591: LD_ADDR_EXP 138
65595: PUSH
65596: LD_INT 1
65598: ST_TO_ADDR
// if p3 = 27 then
65599: LD_VAR 0 3
65603: PUSH
65604: LD_INT 27
65606: EQUAL
65607: IFFALSE 65617
// sAI := true ;
65609: LD_ADDR_EXP 139
65613: PUSH
65614: LD_INT 1
65616: ST_TO_ADDR
// if p3 = 28 then
65617: LD_VAR 0 3
65621: PUSH
65622: LD_INT 28
65624: EQUAL
65625: IFFALSE 65635
// sCargo := true ;
65627: LD_ADDR_EXP 142
65631: PUSH
65632: LD_INT 1
65634: ST_TO_ADDR
// if p3 = 29 then
65635: LD_VAR 0 3
65639: PUSH
65640: LD_INT 29
65642: EQUAL
65643: IFFALSE 65653
// sDLaser := true ;
65645: LD_ADDR_EXP 143
65649: PUSH
65650: LD_INT 1
65652: ST_TO_ADDR
// if p3 = 30 then
65653: LD_VAR 0 3
65657: PUSH
65658: LD_INT 30
65660: EQUAL
65661: IFFALSE 65671
// sExchange := true ;
65663: LD_ADDR_EXP 144
65667: PUSH
65668: LD_INT 1
65670: ST_TO_ADDR
// if p3 = 31 then
65671: LD_VAR 0 3
65675: PUSH
65676: LD_INT 31
65678: EQUAL
65679: IFFALSE 65689
// sFac := true ;
65681: LD_ADDR_EXP 145
65685: PUSH
65686: LD_INT 1
65688: ST_TO_ADDR
// if p3 = 32 then
65689: LD_VAR 0 3
65693: PUSH
65694: LD_INT 32
65696: EQUAL
65697: IFFALSE 65707
// sPower := true ;
65699: LD_ADDR_EXP 146
65703: PUSH
65704: LD_INT 1
65706: ST_TO_ADDR
// if p3 = 33 then
65707: LD_VAR 0 3
65711: PUSH
65712: LD_INT 33
65714: EQUAL
65715: IFFALSE 65725
// sRandom := true ;
65717: LD_ADDR_EXP 147
65721: PUSH
65722: LD_INT 1
65724: ST_TO_ADDR
// if p3 = 34 then
65725: LD_VAR 0 3
65729: PUSH
65730: LD_INT 34
65732: EQUAL
65733: IFFALSE 65743
// sShield := true ;
65735: LD_ADDR_EXP 148
65739: PUSH
65740: LD_INT 1
65742: ST_TO_ADDR
// if p3 = 35 then
65743: LD_VAR 0 3
65747: PUSH
65748: LD_INT 35
65750: EQUAL
65751: IFFALSE 65761
// sTime := true ;
65753: LD_ADDR_EXP 149
65757: PUSH
65758: LD_INT 1
65760: ST_TO_ADDR
// if p3 = 36 then
65761: LD_VAR 0 3
65765: PUSH
65766: LD_INT 36
65768: EQUAL
65769: IFFALSE 65779
// sTools := true ;
65771: LD_ADDR_EXP 150
65775: PUSH
65776: LD_INT 1
65778: ST_TO_ADDR
// if p3 = 101 then
65779: LD_VAR 0 3
65783: PUSH
65784: LD_INT 101
65786: EQUAL
65787: IFFALSE 65797
// sSold := true ;
65789: LD_ADDR_EXP 115
65793: PUSH
65794: LD_INT 1
65796: ST_TO_ADDR
// if p3 = 102 then
65797: LD_VAR 0 3
65801: PUSH
65802: LD_INT 102
65804: EQUAL
65805: IFFALSE 65815
// sDiff := true ;
65807: LD_ADDR_EXP 116
65811: PUSH
65812: LD_INT 1
65814: ST_TO_ADDR
// if p3 = 103 then
65815: LD_VAR 0 3
65819: PUSH
65820: LD_INT 103
65822: EQUAL
65823: IFFALSE 65833
// sFog := true ;
65825: LD_ADDR_EXP 119
65829: PUSH
65830: LD_INT 1
65832: ST_TO_ADDR
// if p3 = 104 then
65833: LD_VAR 0 3
65837: PUSH
65838: LD_INT 104
65840: EQUAL
65841: IFFALSE 65851
// sReset := true ;
65843: LD_ADDR_EXP 120
65847: PUSH
65848: LD_INT 1
65850: ST_TO_ADDR
// if p3 = 105 then
65851: LD_VAR 0 3
65855: PUSH
65856: LD_INT 105
65858: EQUAL
65859: IFFALSE 65869
// sSun := true ;
65861: LD_ADDR_EXP 121
65865: PUSH
65866: LD_INT 1
65868: ST_TO_ADDR
// if p3 = 106 then
65869: LD_VAR 0 3
65873: PUSH
65874: LD_INT 106
65876: EQUAL
65877: IFFALSE 65887
// sTiger := true ;
65879: LD_ADDR_EXP 117
65883: PUSH
65884: LD_INT 1
65886: ST_TO_ADDR
// if p3 = 107 then
65887: LD_VAR 0 3
65891: PUSH
65892: LD_INT 107
65894: EQUAL
65895: IFFALSE 65905
// sBomb := true ;
65897: LD_ADDR_EXP 118
65901: PUSH
65902: LD_INT 1
65904: ST_TO_ADDR
// if p3 = 108 then
65905: LD_VAR 0 3
65909: PUSH
65910: LD_INT 108
65912: EQUAL
65913: IFFALSE 65923
// sWound := true ;
65915: LD_ADDR_EXP 126
65919: PUSH
65920: LD_INT 1
65922: ST_TO_ADDR
// if p3 = 109 then
65923: LD_VAR 0 3
65927: PUSH
65928: LD_INT 109
65930: EQUAL
65931: IFFALSE 65941
// sBetray := true ;
65933: LD_ADDR_EXP 130
65937: PUSH
65938: LD_INT 1
65940: ST_TO_ADDR
// if p3 = 110 then
65941: LD_VAR 0 3
65945: PUSH
65946: LD_INT 110
65948: EQUAL
65949: IFFALSE 65959
// sContamin := true ;
65951: LD_ADDR_EXP 131
65955: PUSH
65956: LD_INT 1
65958: ST_TO_ADDR
// if p3 = 111 then
65959: LD_VAR 0 3
65963: PUSH
65964: LD_INT 111
65966: EQUAL
65967: IFFALSE 65977
// sOil := true ;
65969: LD_ADDR_EXP 133
65973: PUSH
65974: LD_INT 1
65976: ST_TO_ADDR
// if p3 = 112 then
65977: LD_VAR 0 3
65981: PUSH
65982: LD_INT 112
65984: EQUAL
65985: IFFALSE 65995
// sStu := true ;
65987: LD_ADDR_EXP 137
65991: PUSH
65992: LD_INT 1
65994: ST_TO_ADDR
// if p3 = 113 then
65995: LD_VAR 0 3
65999: PUSH
66000: LD_INT 113
66002: EQUAL
66003: IFFALSE 66013
// sBazooka := true ;
66005: LD_ADDR_EXP 140
66009: PUSH
66010: LD_INT 1
66012: ST_TO_ADDR
// if p3 = 114 then
66013: LD_VAR 0 3
66017: PUSH
66018: LD_INT 114
66020: EQUAL
66021: IFFALSE 66031
// sMortar := true ;
66023: LD_ADDR_EXP 141
66027: PUSH
66028: LD_INT 1
66030: ST_TO_ADDR
// if p3 = 115 then
66031: LD_VAR 0 3
66035: PUSH
66036: LD_INT 115
66038: EQUAL
66039: IFFALSE 66049
// sRanger := true ;
66041: LD_ADDR_EXP 151
66045: PUSH
66046: LD_INT 1
66048: ST_TO_ADDR
// if p3 = 116 then
66049: LD_VAR 0 3
66053: PUSH
66054: LD_INT 116
66056: EQUAL
66057: IFFALSE 66067
// sComputer := true ;
66059: LD_ADDR_EXP 152
66063: PUSH
66064: LD_INT 1
66066: ST_TO_ADDR
// if p3 = 117 then
66067: LD_VAR 0 3
66071: PUSH
66072: LD_INT 117
66074: EQUAL
66075: IFFALSE 66085
// s30 := true ;
66077: LD_ADDR_EXP 153
66081: PUSH
66082: LD_INT 1
66084: ST_TO_ADDR
// if p3 = 118 then
66085: LD_VAR 0 3
66089: PUSH
66090: LD_INT 118
66092: EQUAL
66093: IFFALSE 66103
// s60 := true ;
66095: LD_ADDR_EXP 154
66099: PUSH
66100: LD_INT 1
66102: ST_TO_ADDR
// end ; if p2 = hack_mode then
66103: LD_VAR 0 2
66107: PUSH
66108: LD_INT 101
66110: EQUAL
66111: IFFALSE 66239
// begin case p3 of 1 :
66113: LD_VAR 0 3
66117: PUSH
66118: LD_INT 1
66120: DOUBLE
66121: EQUAL
66122: IFTRUE 66126
66124: GO 66133
66126: POP
// hHackUnlimitedResources ; 2 :
66127: CALL 78378 0 0
66131: GO 66239
66133: LD_INT 2
66135: DOUBLE
66136: EQUAL
66137: IFTRUE 66141
66139: GO 66148
66141: POP
// hHackSetLevel10 ; 3 :
66142: CALL 78511 0 0
66146: GO 66239
66148: LD_INT 3
66150: DOUBLE
66151: EQUAL
66152: IFTRUE 66156
66154: GO 66163
66156: POP
// hHackSetLevel10YourUnits ; 4 :
66157: CALL 78596 0 0
66161: GO 66239
66163: LD_INT 4
66165: DOUBLE
66166: EQUAL
66167: IFTRUE 66171
66169: GO 66178
66171: POP
// hHackInvincible ; 5 :
66172: CALL 79044 0 0
66176: GO 66239
66178: LD_INT 5
66180: DOUBLE
66181: EQUAL
66182: IFTRUE 66186
66184: GO 66193
66186: POP
// hHackInvisible ; 6 :
66187: CALL 79155 0 0
66191: GO 66239
66193: LD_INT 6
66195: DOUBLE
66196: EQUAL
66197: IFTRUE 66201
66199: GO 66208
66201: POP
// hHackChangeYourSide ; 7 :
66202: CALL 79212 0 0
66206: GO 66239
66208: LD_INT 7
66210: DOUBLE
66211: EQUAL
66212: IFTRUE 66216
66214: GO 66223
66216: POP
// hHackChangeUnitSide ; 8 :
66217: CALL 79254 0 0
66221: GO 66239
66223: LD_INT 8
66225: DOUBLE
66226: EQUAL
66227: IFTRUE 66231
66229: GO 66238
66231: POP
// hHackFog ; end ;
66232: CALL 79355 0 0
66236: GO 66239
66238: POP
// end ; if p2 = game_save_mode then
66239: LD_VAR 0 2
66243: PUSH
66244: LD_INT 102
66246: EQUAL
66247: IFFALSE 66302
// begin if p3 = 1 then
66249: LD_VAR 0 3
66253: PUSH
66254: LD_INT 1
66256: EQUAL
66257: IFFALSE 66269
// globalGameSaveCounter := p4 ;
66259: LD_ADDR_EXP 97
66263: PUSH
66264: LD_VAR 0 4
66268: ST_TO_ADDR
// if p3 = 2 and globalGameSaveCounter then
66269: LD_VAR 0 3
66273: PUSH
66274: LD_INT 2
66276: EQUAL
66277: PUSH
66278: LD_EXP 97
66282: AND
66283: IFFALSE 66302
// ToLua ( setGameSaveCounter( & globalGameSaveCounter & ) ) ;
66285: LD_STRING setGameSaveCounter(
66287: PUSH
66288: LD_EXP 97
66292: STR
66293: PUSH
66294: LD_STRING )
66296: STR
66297: PPUSH
66298: CALL_OW 559
// end ; end ;
66302: LD_VAR 0 7
66306: RET
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger , sComputer , s30 , s60 ; function InitStreamMode ; begin
66307: LD_INT 0
66309: PPUSH
// streamModeActive := false ;
66310: LD_ADDR_EXP 98
66314: PUSH
66315: LD_INT 0
66317: ST_TO_ADDR
// normalCounter := 36 ;
66318: LD_ADDR_EXP 99
66322: PUSH
66323: LD_INT 36
66325: ST_TO_ADDR
// hardcoreCounter := 18 ;
66326: LD_ADDR_EXP 100
66330: PUSH
66331: LD_INT 18
66333: ST_TO_ADDR
// sRocket := false ;
66334: LD_ADDR_EXP 103
66338: PUSH
66339: LD_INT 0
66341: ST_TO_ADDR
// sSpeed := false ;
66342: LD_ADDR_EXP 102
66346: PUSH
66347: LD_INT 0
66349: ST_TO_ADDR
// sEngine := false ;
66350: LD_ADDR_EXP 104
66354: PUSH
66355: LD_INT 0
66357: ST_TO_ADDR
// sSpec := false ;
66358: LD_ADDR_EXP 101
66362: PUSH
66363: LD_INT 0
66365: ST_TO_ADDR
// sLevel := false ;
66366: LD_ADDR_EXP 105
66370: PUSH
66371: LD_INT 0
66373: ST_TO_ADDR
// sArmoury := false ;
66374: LD_ADDR_EXP 106
66378: PUSH
66379: LD_INT 0
66381: ST_TO_ADDR
// sRadar := false ;
66382: LD_ADDR_EXP 107
66386: PUSH
66387: LD_INT 0
66389: ST_TO_ADDR
// sBunker := false ;
66390: LD_ADDR_EXP 108
66394: PUSH
66395: LD_INT 0
66397: ST_TO_ADDR
// sHack := false ;
66398: LD_ADDR_EXP 109
66402: PUSH
66403: LD_INT 0
66405: ST_TO_ADDR
// sFire := false ;
66406: LD_ADDR_EXP 110
66410: PUSH
66411: LD_INT 0
66413: ST_TO_ADDR
// sRefresh := false ;
66414: LD_ADDR_EXP 111
66418: PUSH
66419: LD_INT 0
66421: ST_TO_ADDR
// sExp := false ;
66422: LD_ADDR_EXP 112
66426: PUSH
66427: LD_INT 0
66429: ST_TO_ADDR
// sDepot := false ;
66430: LD_ADDR_EXP 113
66434: PUSH
66435: LD_INT 0
66437: ST_TO_ADDR
// sFlag := false ;
66438: LD_ADDR_EXP 114
66442: PUSH
66443: LD_INT 0
66445: ST_TO_ADDR
// sKamikadze := false ;
66446: LD_ADDR_EXP 122
66450: PUSH
66451: LD_INT 0
66453: ST_TO_ADDR
// sTroll := false ;
66454: LD_ADDR_EXP 123
66458: PUSH
66459: LD_INT 0
66461: ST_TO_ADDR
// sSlow := false ;
66462: LD_ADDR_EXP 124
66466: PUSH
66467: LD_INT 0
66469: ST_TO_ADDR
// sLack := false ;
66470: LD_ADDR_EXP 125
66474: PUSH
66475: LD_INT 0
66477: ST_TO_ADDR
// sTank := false ;
66478: LD_ADDR_EXP 127
66482: PUSH
66483: LD_INT 0
66485: ST_TO_ADDR
// sRemote := false ;
66486: LD_ADDR_EXP 128
66490: PUSH
66491: LD_INT 0
66493: ST_TO_ADDR
// sPowell := false ;
66494: LD_ADDR_EXP 129
66498: PUSH
66499: LD_INT 0
66501: ST_TO_ADDR
// sTeleport := false ;
66502: LD_ADDR_EXP 132
66506: PUSH
66507: LD_INT 0
66509: ST_TO_ADDR
// sOilTower := false ;
66510: LD_ADDR_EXP 134
66514: PUSH
66515: LD_INT 0
66517: ST_TO_ADDR
// sShovel := false ;
66518: LD_ADDR_EXP 135
66522: PUSH
66523: LD_INT 0
66525: ST_TO_ADDR
// sSheik := false ;
66526: LD_ADDR_EXP 136
66530: PUSH
66531: LD_INT 0
66533: ST_TO_ADDR
// sEarthquake := false ;
66534: LD_ADDR_EXP 138
66538: PUSH
66539: LD_INT 0
66541: ST_TO_ADDR
// sAI := false ;
66542: LD_ADDR_EXP 139
66546: PUSH
66547: LD_INT 0
66549: ST_TO_ADDR
// sCargo := false ;
66550: LD_ADDR_EXP 142
66554: PUSH
66555: LD_INT 0
66557: ST_TO_ADDR
// sDLaser := false ;
66558: LD_ADDR_EXP 143
66562: PUSH
66563: LD_INT 0
66565: ST_TO_ADDR
// sExchange := false ;
66566: LD_ADDR_EXP 144
66570: PUSH
66571: LD_INT 0
66573: ST_TO_ADDR
// sFac := false ;
66574: LD_ADDR_EXP 145
66578: PUSH
66579: LD_INT 0
66581: ST_TO_ADDR
// sPower := false ;
66582: LD_ADDR_EXP 146
66586: PUSH
66587: LD_INT 0
66589: ST_TO_ADDR
// sRandom := false ;
66590: LD_ADDR_EXP 147
66594: PUSH
66595: LD_INT 0
66597: ST_TO_ADDR
// sShield := false ;
66598: LD_ADDR_EXP 148
66602: PUSH
66603: LD_INT 0
66605: ST_TO_ADDR
// sTime := false ;
66606: LD_ADDR_EXP 149
66610: PUSH
66611: LD_INT 0
66613: ST_TO_ADDR
// sTools := false ;
66614: LD_ADDR_EXP 150
66618: PUSH
66619: LD_INT 0
66621: ST_TO_ADDR
// sSold := false ;
66622: LD_ADDR_EXP 115
66626: PUSH
66627: LD_INT 0
66629: ST_TO_ADDR
// sDiff := false ;
66630: LD_ADDR_EXP 116
66634: PUSH
66635: LD_INT 0
66637: ST_TO_ADDR
// sFog := false ;
66638: LD_ADDR_EXP 119
66642: PUSH
66643: LD_INT 0
66645: ST_TO_ADDR
// sReset := false ;
66646: LD_ADDR_EXP 120
66650: PUSH
66651: LD_INT 0
66653: ST_TO_ADDR
// sSun := false ;
66654: LD_ADDR_EXP 121
66658: PUSH
66659: LD_INT 0
66661: ST_TO_ADDR
// sTiger := false ;
66662: LD_ADDR_EXP 117
66666: PUSH
66667: LD_INT 0
66669: ST_TO_ADDR
// sBomb := false ;
66670: LD_ADDR_EXP 118
66674: PUSH
66675: LD_INT 0
66677: ST_TO_ADDR
// sWound := false ;
66678: LD_ADDR_EXP 126
66682: PUSH
66683: LD_INT 0
66685: ST_TO_ADDR
// sBetray := false ;
66686: LD_ADDR_EXP 130
66690: PUSH
66691: LD_INT 0
66693: ST_TO_ADDR
// sContamin := false ;
66694: LD_ADDR_EXP 131
66698: PUSH
66699: LD_INT 0
66701: ST_TO_ADDR
// sOil := false ;
66702: LD_ADDR_EXP 133
66706: PUSH
66707: LD_INT 0
66709: ST_TO_ADDR
// sStu := false ;
66710: LD_ADDR_EXP 137
66714: PUSH
66715: LD_INT 0
66717: ST_TO_ADDR
// sBazooka := false ;
66718: LD_ADDR_EXP 140
66722: PUSH
66723: LD_INT 0
66725: ST_TO_ADDR
// sMortar := false ;
66726: LD_ADDR_EXP 141
66730: PUSH
66731: LD_INT 0
66733: ST_TO_ADDR
// sRanger := false ;
66734: LD_ADDR_EXP 151
66738: PUSH
66739: LD_INT 0
66741: ST_TO_ADDR
// sComputer := false ;
66742: LD_ADDR_EXP 152
66746: PUSH
66747: LD_INT 0
66749: ST_TO_ADDR
// s30 := false ;
66750: LD_ADDR_EXP 153
66754: PUSH
66755: LD_INT 0
66757: ST_TO_ADDR
// s60 := false ;
66758: LD_ADDR_EXP 154
66762: PUSH
66763: LD_INT 0
66765: ST_TO_ADDR
// end ;
66766: LD_VAR 0 1
66770: RET
// function DefineStreamItems ( isGameLoad ) ; var tmp , flags , normal , hardcore , active , i ; begin
66771: LD_INT 0
66773: PPUSH
66774: PPUSH
66775: PPUSH
66776: PPUSH
66777: PPUSH
66778: PPUSH
66779: PPUSH
// result := [ ] ;
66780: LD_ADDR_VAR 0 2
66784: PUSH
66785: EMPTY
66786: ST_TO_ADDR
// if campaign_id = 1 then
66787: LD_OWVAR 69
66791: PUSH
66792: LD_INT 1
66794: EQUAL
66795: IFFALSE 69961
// begin case mission_number of 1 :
66797: LD_OWVAR 70
66801: PUSH
66802: LD_INT 1
66804: DOUBLE
66805: EQUAL
66806: IFTRUE 66810
66808: GO 66886
66810: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 , 116 , 117 , 118 ] ] ; 2 :
66811: LD_ADDR_VAR 0 2
66815: PUSH
66816: LD_INT 2
66818: PUSH
66819: LD_INT 4
66821: PUSH
66822: LD_INT 11
66824: PUSH
66825: LD_INT 12
66827: PUSH
66828: LD_INT 15
66830: PUSH
66831: LD_INT 16
66833: PUSH
66834: LD_INT 22
66836: PUSH
66837: LD_INT 23
66839: PUSH
66840: LD_INT 26
66842: PUSH
66843: EMPTY
66844: LIST
66845: LIST
66846: LIST
66847: LIST
66848: LIST
66849: LIST
66850: LIST
66851: LIST
66852: LIST
66853: PUSH
66854: LD_INT 101
66856: PUSH
66857: LD_INT 102
66859: PUSH
66860: LD_INT 106
66862: PUSH
66863: LD_INT 116
66865: PUSH
66866: LD_INT 117
66868: PUSH
66869: LD_INT 118
66871: PUSH
66872: EMPTY
66873: LIST
66874: LIST
66875: LIST
66876: LIST
66877: LIST
66878: LIST
66879: PUSH
66880: EMPTY
66881: LIST
66882: LIST
66883: ST_TO_ADDR
66884: GO 69959
66886: LD_INT 2
66888: DOUBLE
66889: EQUAL
66890: IFTRUE 66894
66892: GO 66978
66894: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 3 :
66895: LD_ADDR_VAR 0 2
66899: PUSH
66900: LD_INT 2
66902: PUSH
66903: LD_INT 4
66905: PUSH
66906: LD_INT 11
66908: PUSH
66909: LD_INT 12
66911: PUSH
66912: LD_INT 15
66914: PUSH
66915: LD_INT 16
66917: PUSH
66918: LD_INT 22
66920: PUSH
66921: LD_INT 23
66923: PUSH
66924: LD_INT 26
66926: PUSH
66927: EMPTY
66928: LIST
66929: LIST
66930: LIST
66931: LIST
66932: LIST
66933: LIST
66934: LIST
66935: LIST
66936: LIST
66937: PUSH
66938: LD_INT 101
66940: PUSH
66941: LD_INT 102
66943: PUSH
66944: LD_INT 105
66946: PUSH
66947: LD_INT 106
66949: PUSH
66950: LD_INT 108
66952: PUSH
66953: LD_INT 116
66955: PUSH
66956: LD_INT 117
66958: PUSH
66959: LD_INT 118
66961: PUSH
66962: EMPTY
66963: LIST
66964: LIST
66965: LIST
66966: LIST
66967: LIST
66968: LIST
66969: LIST
66970: LIST
66971: PUSH
66972: EMPTY
66973: LIST
66974: LIST
66975: ST_TO_ADDR
66976: GO 69959
66978: LD_INT 3
66980: DOUBLE
66981: EQUAL
66982: IFTRUE 66986
66984: GO 67074
66986: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 4 :
66987: LD_ADDR_VAR 0 2
66991: PUSH
66992: LD_INT 2
66994: PUSH
66995: LD_INT 4
66997: PUSH
66998: LD_INT 5
67000: PUSH
67001: LD_INT 11
67003: PUSH
67004: LD_INT 12
67006: PUSH
67007: LD_INT 15
67009: PUSH
67010: LD_INT 16
67012: PUSH
67013: LD_INT 22
67015: PUSH
67016: LD_INT 26
67018: PUSH
67019: LD_INT 36
67021: PUSH
67022: EMPTY
67023: LIST
67024: LIST
67025: LIST
67026: LIST
67027: LIST
67028: LIST
67029: LIST
67030: LIST
67031: LIST
67032: LIST
67033: PUSH
67034: LD_INT 101
67036: PUSH
67037: LD_INT 102
67039: PUSH
67040: LD_INT 105
67042: PUSH
67043: LD_INT 106
67045: PUSH
67046: LD_INT 108
67048: PUSH
67049: LD_INT 116
67051: PUSH
67052: LD_INT 117
67054: PUSH
67055: LD_INT 118
67057: PUSH
67058: EMPTY
67059: LIST
67060: LIST
67061: LIST
67062: LIST
67063: LIST
67064: LIST
67065: LIST
67066: LIST
67067: PUSH
67068: EMPTY
67069: LIST
67070: LIST
67071: ST_TO_ADDR
67072: GO 69959
67074: LD_INT 4
67076: DOUBLE
67077: EQUAL
67078: IFTRUE 67082
67080: GO 67178
67082: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 5 :
67083: LD_ADDR_VAR 0 2
67087: PUSH
67088: LD_INT 2
67090: PUSH
67091: LD_INT 4
67093: PUSH
67094: LD_INT 5
67096: PUSH
67097: LD_INT 8
67099: PUSH
67100: LD_INT 11
67102: PUSH
67103: LD_INT 12
67105: PUSH
67106: LD_INT 15
67108: PUSH
67109: LD_INT 16
67111: PUSH
67112: LD_INT 22
67114: PUSH
67115: LD_INT 23
67117: PUSH
67118: LD_INT 26
67120: PUSH
67121: LD_INT 36
67123: PUSH
67124: EMPTY
67125: LIST
67126: LIST
67127: LIST
67128: LIST
67129: LIST
67130: LIST
67131: LIST
67132: LIST
67133: LIST
67134: LIST
67135: LIST
67136: LIST
67137: PUSH
67138: LD_INT 101
67140: PUSH
67141: LD_INT 102
67143: PUSH
67144: LD_INT 105
67146: PUSH
67147: LD_INT 106
67149: PUSH
67150: LD_INT 108
67152: PUSH
67153: LD_INT 116
67155: PUSH
67156: LD_INT 117
67158: PUSH
67159: LD_INT 118
67161: PUSH
67162: EMPTY
67163: LIST
67164: LIST
67165: LIST
67166: LIST
67167: LIST
67168: LIST
67169: LIST
67170: LIST
67171: PUSH
67172: EMPTY
67173: LIST
67174: LIST
67175: ST_TO_ADDR
67176: GO 69959
67178: LD_INT 5
67180: DOUBLE
67181: EQUAL
67182: IFTRUE 67186
67184: GO 67298
67186: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 6 :
67187: LD_ADDR_VAR 0 2
67191: PUSH
67192: LD_INT 2
67194: PUSH
67195: LD_INT 4
67197: PUSH
67198: LD_INT 5
67200: PUSH
67201: LD_INT 6
67203: PUSH
67204: LD_INT 8
67206: PUSH
67207: LD_INT 11
67209: PUSH
67210: LD_INT 12
67212: PUSH
67213: LD_INT 15
67215: PUSH
67216: LD_INT 16
67218: PUSH
67219: LD_INT 22
67221: PUSH
67222: LD_INT 23
67224: PUSH
67225: LD_INT 25
67227: PUSH
67228: LD_INT 26
67230: PUSH
67231: LD_INT 36
67233: PUSH
67234: EMPTY
67235: LIST
67236: LIST
67237: LIST
67238: LIST
67239: LIST
67240: LIST
67241: LIST
67242: LIST
67243: LIST
67244: LIST
67245: LIST
67246: LIST
67247: LIST
67248: LIST
67249: PUSH
67250: LD_INT 101
67252: PUSH
67253: LD_INT 102
67255: PUSH
67256: LD_INT 105
67258: PUSH
67259: LD_INT 106
67261: PUSH
67262: LD_INT 108
67264: PUSH
67265: LD_INT 109
67267: PUSH
67268: LD_INT 112
67270: PUSH
67271: LD_INT 116
67273: PUSH
67274: LD_INT 117
67276: PUSH
67277: LD_INT 118
67279: PUSH
67280: EMPTY
67281: LIST
67282: LIST
67283: LIST
67284: LIST
67285: LIST
67286: LIST
67287: LIST
67288: LIST
67289: LIST
67290: LIST
67291: PUSH
67292: EMPTY
67293: LIST
67294: LIST
67295: ST_TO_ADDR
67296: GO 69959
67298: LD_INT 6
67300: DOUBLE
67301: EQUAL
67302: IFTRUE 67306
67304: GO 67438
67306: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 7 :
67307: LD_ADDR_VAR 0 2
67311: PUSH
67312: LD_INT 2
67314: PUSH
67315: LD_INT 4
67317: PUSH
67318: LD_INT 5
67320: PUSH
67321: LD_INT 6
67323: PUSH
67324: LD_INT 8
67326: PUSH
67327: LD_INT 11
67329: PUSH
67330: LD_INT 12
67332: PUSH
67333: LD_INT 15
67335: PUSH
67336: LD_INT 16
67338: PUSH
67339: LD_INT 20
67341: PUSH
67342: LD_INT 21
67344: PUSH
67345: LD_INT 22
67347: PUSH
67348: LD_INT 23
67350: PUSH
67351: LD_INT 25
67353: PUSH
67354: LD_INT 26
67356: PUSH
67357: LD_INT 30
67359: PUSH
67360: LD_INT 31
67362: PUSH
67363: LD_INT 32
67365: PUSH
67366: LD_INT 36
67368: PUSH
67369: EMPTY
67370: LIST
67371: LIST
67372: LIST
67373: LIST
67374: LIST
67375: LIST
67376: LIST
67377: LIST
67378: LIST
67379: LIST
67380: LIST
67381: LIST
67382: LIST
67383: LIST
67384: LIST
67385: LIST
67386: LIST
67387: LIST
67388: LIST
67389: PUSH
67390: LD_INT 101
67392: PUSH
67393: LD_INT 102
67395: PUSH
67396: LD_INT 105
67398: PUSH
67399: LD_INT 106
67401: PUSH
67402: LD_INT 108
67404: PUSH
67405: LD_INT 109
67407: PUSH
67408: LD_INT 112
67410: PUSH
67411: LD_INT 116
67413: PUSH
67414: LD_INT 117
67416: PUSH
67417: LD_INT 118
67419: PUSH
67420: EMPTY
67421: LIST
67422: LIST
67423: LIST
67424: LIST
67425: LIST
67426: LIST
67427: LIST
67428: LIST
67429: LIST
67430: LIST
67431: PUSH
67432: EMPTY
67433: LIST
67434: LIST
67435: ST_TO_ADDR
67436: GO 69959
67438: LD_INT 7
67440: DOUBLE
67441: EQUAL
67442: IFTRUE 67446
67444: GO 67558
67446: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 , 116 , 117 , 118 ] ] ; 8 :
67447: LD_ADDR_VAR 0 2
67451: PUSH
67452: LD_INT 2
67454: PUSH
67455: LD_INT 4
67457: PUSH
67458: LD_INT 5
67460: PUSH
67461: LD_INT 7
67463: PUSH
67464: LD_INT 11
67466: PUSH
67467: LD_INT 12
67469: PUSH
67470: LD_INT 15
67472: PUSH
67473: LD_INT 16
67475: PUSH
67476: LD_INT 20
67478: PUSH
67479: LD_INT 21
67481: PUSH
67482: LD_INT 22
67484: PUSH
67485: LD_INT 23
67487: PUSH
67488: LD_INT 25
67490: PUSH
67491: LD_INT 26
67493: PUSH
67494: EMPTY
67495: LIST
67496: LIST
67497: LIST
67498: LIST
67499: LIST
67500: LIST
67501: LIST
67502: LIST
67503: LIST
67504: LIST
67505: LIST
67506: LIST
67507: LIST
67508: LIST
67509: PUSH
67510: LD_INT 101
67512: PUSH
67513: LD_INT 102
67515: PUSH
67516: LD_INT 103
67518: PUSH
67519: LD_INT 105
67521: PUSH
67522: LD_INT 106
67524: PUSH
67525: LD_INT 108
67527: PUSH
67528: LD_INT 112
67530: PUSH
67531: LD_INT 116
67533: PUSH
67534: LD_INT 117
67536: PUSH
67537: LD_INT 118
67539: PUSH
67540: EMPTY
67541: LIST
67542: LIST
67543: LIST
67544: LIST
67545: LIST
67546: LIST
67547: LIST
67548: LIST
67549: LIST
67550: LIST
67551: PUSH
67552: EMPTY
67553: LIST
67554: LIST
67555: ST_TO_ADDR
67556: GO 69959
67558: LD_INT 8
67560: DOUBLE
67561: EQUAL
67562: IFTRUE 67566
67564: GO 67706
67566: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 9 :
67567: LD_ADDR_VAR 0 2
67571: PUSH
67572: LD_INT 2
67574: PUSH
67575: LD_INT 4
67577: PUSH
67578: LD_INT 5
67580: PUSH
67581: LD_INT 6
67583: PUSH
67584: LD_INT 7
67586: PUSH
67587: LD_INT 8
67589: PUSH
67590: LD_INT 11
67592: PUSH
67593: LD_INT 12
67595: PUSH
67596: LD_INT 15
67598: PUSH
67599: LD_INT 16
67601: PUSH
67602: LD_INT 20
67604: PUSH
67605: LD_INT 21
67607: PUSH
67608: LD_INT 22
67610: PUSH
67611: LD_INT 23
67613: PUSH
67614: LD_INT 25
67616: PUSH
67617: LD_INT 26
67619: PUSH
67620: LD_INT 30
67622: PUSH
67623: LD_INT 31
67625: PUSH
67626: LD_INT 32
67628: PUSH
67629: LD_INT 36
67631: PUSH
67632: EMPTY
67633: LIST
67634: LIST
67635: LIST
67636: LIST
67637: LIST
67638: LIST
67639: LIST
67640: LIST
67641: LIST
67642: LIST
67643: LIST
67644: LIST
67645: LIST
67646: LIST
67647: LIST
67648: LIST
67649: LIST
67650: LIST
67651: LIST
67652: LIST
67653: PUSH
67654: LD_INT 101
67656: PUSH
67657: LD_INT 102
67659: PUSH
67660: LD_INT 103
67662: PUSH
67663: LD_INT 105
67665: PUSH
67666: LD_INT 106
67668: PUSH
67669: LD_INT 108
67671: PUSH
67672: LD_INT 109
67674: PUSH
67675: LD_INT 112
67677: PUSH
67678: LD_INT 116
67680: PUSH
67681: LD_INT 117
67683: PUSH
67684: LD_INT 118
67686: PUSH
67687: EMPTY
67688: LIST
67689: LIST
67690: LIST
67691: LIST
67692: LIST
67693: LIST
67694: LIST
67695: LIST
67696: LIST
67697: LIST
67698: LIST
67699: PUSH
67700: EMPTY
67701: LIST
67702: LIST
67703: ST_TO_ADDR
67704: GO 69959
67706: LD_INT 9
67708: DOUBLE
67709: EQUAL
67710: IFTRUE 67714
67712: GO 67862
67714: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 , 116 , 117 , 118 ] ] ; 10 :
67715: LD_ADDR_VAR 0 2
67719: PUSH
67720: LD_INT 2
67722: PUSH
67723: LD_INT 4
67725: PUSH
67726: LD_INT 5
67728: PUSH
67729: LD_INT 6
67731: PUSH
67732: LD_INT 7
67734: PUSH
67735: LD_INT 8
67737: PUSH
67738: LD_INT 11
67740: PUSH
67741: LD_INT 12
67743: PUSH
67744: LD_INT 15
67746: PUSH
67747: LD_INT 16
67749: PUSH
67750: LD_INT 20
67752: PUSH
67753: LD_INT 21
67755: PUSH
67756: LD_INT 22
67758: PUSH
67759: LD_INT 23
67761: PUSH
67762: LD_INT 25
67764: PUSH
67765: LD_INT 26
67767: PUSH
67768: LD_INT 28
67770: PUSH
67771: LD_INT 30
67773: PUSH
67774: LD_INT 31
67776: PUSH
67777: LD_INT 32
67779: PUSH
67780: LD_INT 36
67782: PUSH
67783: EMPTY
67784: LIST
67785: LIST
67786: LIST
67787: LIST
67788: LIST
67789: LIST
67790: LIST
67791: LIST
67792: LIST
67793: LIST
67794: LIST
67795: LIST
67796: LIST
67797: LIST
67798: LIST
67799: LIST
67800: LIST
67801: LIST
67802: LIST
67803: LIST
67804: LIST
67805: PUSH
67806: LD_INT 101
67808: PUSH
67809: LD_INT 102
67811: PUSH
67812: LD_INT 103
67814: PUSH
67815: LD_INT 105
67817: PUSH
67818: LD_INT 106
67820: PUSH
67821: LD_INT 108
67823: PUSH
67824: LD_INT 109
67826: PUSH
67827: LD_INT 112
67829: PUSH
67830: LD_INT 114
67832: PUSH
67833: LD_INT 116
67835: PUSH
67836: LD_INT 117
67838: PUSH
67839: LD_INT 118
67841: PUSH
67842: EMPTY
67843: LIST
67844: LIST
67845: LIST
67846: LIST
67847: LIST
67848: LIST
67849: LIST
67850: LIST
67851: LIST
67852: LIST
67853: LIST
67854: LIST
67855: PUSH
67856: EMPTY
67857: LIST
67858: LIST
67859: ST_TO_ADDR
67860: GO 69959
67862: LD_INT 10
67864: DOUBLE
67865: EQUAL
67866: IFTRUE 67870
67868: GO 68066
67870: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 11 :
67871: LD_ADDR_VAR 0 2
67875: PUSH
67876: LD_INT 2
67878: PUSH
67879: LD_INT 4
67881: PUSH
67882: LD_INT 5
67884: PUSH
67885: LD_INT 6
67887: PUSH
67888: LD_INT 7
67890: PUSH
67891: LD_INT 8
67893: PUSH
67894: LD_INT 9
67896: PUSH
67897: LD_INT 10
67899: PUSH
67900: LD_INT 11
67902: PUSH
67903: LD_INT 12
67905: PUSH
67906: LD_INT 13
67908: PUSH
67909: LD_INT 14
67911: PUSH
67912: LD_INT 15
67914: PUSH
67915: LD_INT 16
67917: PUSH
67918: LD_INT 17
67920: PUSH
67921: LD_INT 18
67923: PUSH
67924: LD_INT 19
67926: PUSH
67927: LD_INT 20
67929: PUSH
67930: LD_INT 21
67932: PUSH
67933: LD_INT 22
67935: PUSH
67936: LD_INT 23
67938: PUSH
67939: LD_INT 24
67941: PUSH
67942: LD_INT 25
67944: PUSH
67945: LD_INT 26
67947: PUSH
67948: LD_INT 28
67950: PUSH
67951: LD_INT 30
67953: PUSH
67954: LD_INT 31
67956: PUSH
67957: LD_INT 32
67959: PUSH
67960: LD_INT 36
67962: PUSH
67963: EMPTY
67964: LIST
67965: LIST
67966: LIST
67967: LIST
67968: LIST
67969: LIST
67970: LIST
67971: LIST
67972: LIST
67973: LIST
67974: LIST
67975: LIST
67976: LIST
67977: LIST
67978: LIST
67979: LIST
67980: LIST
67981: LIST
67982: LIST
67983: LIST
67984: LIST
67985: LIST
67986: LIST
67987: LIST
67988: LIST
67989: LIST
67990: LIST
67991: LIST
67992: LIST
67993: PUSH
67994: LD_INT 101
67996: PUSH
67997: LD_INT 102
67999: PUSH
68000: LD_INT 103
68002: PUSH
68003: LD_INT 104
68005: PUSH
68006: LD_INT 105
68008: PUSH
68009: LD_INT 106
68011: PUSH
68012: LD_INT 107
68014: PUSH
68015: LD_INT 108
68017: PUSH
68018: LD_INT 109
68020: PUSH
68021: LD_INT 110
68023: PUSH
68024: LD_INT 111
68026: PUSH
68027: LD_INT 112
68029: PUSH
68030: LD_INT 114
68032: PUSH
68033: LD_INT 116
68035: PUSH
68036: LD_INT 117
68038: PUSH
68039: LD_INT 118
68041: PUSH
68042: EMPTY
68043: LIST
68044: LIST
68045: LIST
68046: LIST
68047: LIST
68048: LIST
68049: LIST
68050: LIST
68051: LIST
68052: LIST
68053: LIST
68054: LIST
68055: LIST
68056: LIST
68057: LIST
68058: LIST
68059: PUSH
68060: EMPTY
68061: LIST
68062: LIST
68063: ST_TO_ADDR
68064: GO 69959
68066: LD_INT 11
68068: DOUBLE
68069: EQUAL
68070: IFTRUE 68074
68072: GO 68278
68074: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 12 :
68075: LD_ADDR_VAR 0 2
68079: PUSH
68080: LD_INT 2
68082: PUSH
68083: LD_INT 3
68085: PUSH
68086: LD_INT 4
68088: PUSH
68089: LD_INT 5
68091: PUSH
68092: LD_INT 6
68094: PUSH
68095: LD_INT 7
68097: PUSH
68098: LD_INT 8
68100: PUSH
68101: LD_INT 9
68103: PUSH
68104: LD_INT 10
68106: PUSH
68107: LD_INT 11
68109: PUSH
68110: LD_INT 12
68112: PUSH
68113: LD_INT 13
68115: PUSH
68116: LD_INT 14
68118: PUSH
68119: LD_INT 15
68121: PUSH
68122: LD_INT 16
68124: PUSH
68125: LD_INT 17
68127: PUSH
68128: LD_INT 18
68130: PUSH
68131: LD_INT 19
68133: PUSH
68134: LD_INT 20
68136: PUSH
68137: LD_INT 21
68139: PUSH
68140: LD_INT 22
68142: PUSH
68143: LD_INT 23
68145: PUSH
68146: LD_INT 24
68148: PUSH
68149: LD_INT 25
68151: PUSH
68152: LD_INT 26
68154: PUSH
68155: LD_INT 28
68157: PUSH
68158: LD_INT 30
68160: PUSH
68161: LD_INT 31
68163: PUSH
68164: LD_INT 32
68166: PUSH
68167: LD_INT 34
68169: PUSH
68170: LD_INT 36
68172: PUSH
68173: EMPTY
68174: LIST
68175: LIST
68176: LIST
68177: LIST
68178: LIST
68179: LIST
68180: LIST
68181: LIST
68182: LIST
68183: LIST
68184: LIST
68185: LIST
68186: LIST
68187: LIST
68188: LIST
68189: LIST
68190: LIST
68191: LIST
68192: LIST
68193: LIST
68194: LIST
68195: LIST
68196: LIST
68197: LIST
68198: LIST
68199: LIST
68200: LIST
68201: LIST
68202: LIST
68203: LIST
68204: LIST
68205: PUSH
68206: LD_INT 101
68208: PUSH
68209: LD_INT 102
68211: PUSH
68212: LD_INT 103
68214: PUSH
68215: LD_INT 104
68217: PUSH
68218: LD_INT 105
68220: PUSH
68221: LD_INT 106
68223: PUSH
68224: LD_INT 107
68226: PUSH
68227: LD_INT 108
68229: PUSH
68230: LD_INT 109
68232: PUSH
68233: LD_INT 110
68235: PUSH
68236: LD_INT 111
68238: PUSH
68239: LD_INT 112
68241: PUSH
68242: LD_INT 114
68244: PUSH
68245: LD_INT 116
68247: PUSH
68248: LD_INT 117
68250: PUSH
68251: LD_INT 118
68253: PUSH
68254: EMPTY
68255: LIST
68256: LIST
68257: LIST
68258: LIST
68259: LIST
68260: LIST
68261: LIST
68262: LIST
68263: LIST
68264: LIST
68265: LIST
68266: LIST
68267: LIST
68268: LIST
68269: LIST
68270: LIST
68271: PUSH
68272: EMPTY
68273: LIST
68274: LIST
68275: ST_TO_ADDR
68276: GO 69959
68278: LD_INT 12
68280: DOUBLE
68281: EQUAL
68282: IFTRUE 68286
68284: GO 68506
68286: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 13 :
68287: LD_ADDR_VAR 0 2
68291: PUSH
68292: LD_INT 1
68294: PUSH
68295: LD_INT 2
68297: PUSH
68298: LD_INT 3
68300: PUSH
68301: LD_INT 4
68303: PUSH
68304: LD_INT 5
68306: PUSH
68307: LD_INT 6
68309: PUSH
68310: LD_INT 7
68312: PUSH
68313: LD_INT 8
68315: PUSH
68316: LD_INT 9
68318: PUSH
68319: LD_INT 10
68321: PUSH
68322: LD_INT 11
68324: PUSH
68325: LD_INT 12
68327: PUSH
68328: LD_INT 13
68330: PUSH
68331: LD_INT 14
68333: PUSH
68334: LD_INT 15
68336: PUSH
68337: LD_INT 16
68339: PUSH
68340: LD_INT 17
68342: PUSH
68343: LD_INT 18
68345: PUSH
68346: LD_INT 19
68348: PUSH
68349: LD_INT 20
68351: PUSH
68352: LD_INT 21
68354: PUSH
68355: LD_INT 22
68357: PUSH
68358: LD_INT 23
68360: PUSH
68361: LD_INT 24
68363: PUSH
68364: LD_INT 25
68366: PUSH
68367: LD_INT 26
68369: PUSH
68370: LD_INT 27
68372: PUSH
68373: LD_INT 28
68375: PUSH
68376: LD_INT 30
68378: PUSH
68379: LD_INT 31
68381: PUSH
68382: LD_INT 32
68384: PUSH
68385: LD_INT 33
68387: PUSH
68388: LD_INT 34
68390: PUSH
68391: LD_INT 36
68393: PUSH
68394: EMPTY
68395: LIST
68396: LIST
68397: LIST
68398: LIST
68399: LIST
68400: LIST
68401: LIST
68402: LIST
68403: LIST
68404: LIST
68405: LIST
68406: LIST
68407: LIST
68408: LIST
68409: LIST
68410: LIST
68411: LIST
68412: LIST
68413: LIST
68414: LIST
68415: LIST
68416: LIST
68417: LIST
68418: LIST
68419: LIST
68420: LIST
68421: LIST
68422: LIST
68423: LIST
68424: LIST
68425: LIST
68426: LIST
68427: LIST
68428: LIST
68429: PUSH
68430: LD_INT 101
68432: PUSH
68433: LD_INT 102
68435: PUSH
68436: LD_INT 103
68438: PUSH
68439: LD_INT 104
68441: PUSH
68442: LD_INT 105
68444: PUSH
68445: LD_INT 106
68447: PUSH
68448: LD_INT 107
68450: PUSH
68451: LD_INT 108
68453: PUSH
68454: LD_INT 109
68456: PUSH
68457: LD_INT 110
68459: PUSH
68460: LD_INT 111
68462: PUSH
68463: LD_INT 112
68465: PUSH
68466: LD_INT 113
68468: PUSH
68469: LD_INT 114
68471: PUSH
68472: LD_INT 116
68474: PUSH
68475: LD_INT 117
68477: PUSH
68478: LD_INT 118
68480: PUSH
68481: EMPTY
68482: LIST
68483: LIST
68484: LIST
68485: LIST
68486: LIST
68487: LIST
68488: LIST
68489: LIST
68490: LIST
68491: LIST
68492: LIST
68493: LIST
68494: LIST
68495: LIST
68496: LIST
68497: LIST
68498: LIST
68499: PUSH
68500: EMPTY
68501: LIST
68502: LIST
68503: ST_TO_ADDR
68504: GO 69959
68506: LD_INT 13
68508: DOUBLE
68509: EQUAL
68510: IFTRUE 68514
68512: GO 68722
68514: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 14 :
68515: LD_ADDR_VAR 0 2
68519: PUSH
68520: LD_INT 1
68522: PUSH
68523: LD_INT 2
68525: PUSH
68526: LD_INT 3
68528: PUSH
68529: LD_INT 4
68531: PUSH
68532: LD_INT 5
68534: PUSH
68535: LD_INT 8
68537: PUSH
68538: LD_INT 9
68540: PUSH
68541: LD_INT 10
68543: PUSH
68544: LD_INT 11
68546: PUSH
68547: LD_INT 12
68549: PUSH
68550: LD_INT 14
68552: PUSH
68553: LD_INT 15
68555: PUSH
68556: LD_INT 16
68558: PUSH
68559: LD_INT 17
68561: PUSH
68562: LD_INT 18
68564: PUSH
68565: LD_INT 19
68567: PUSH
68568: LD_INT 20
68570: PUSH
68571: LD_INT 21
68573: PUSH
68574: LD_INT 22
68576: PUSH
68577: LD_INT 23
68579: PUSH
68580: LD_INT 24
68582: PUSH
68583: LD_INT 25
68585: PUSH
68586: LD_INT 26
68588: PUSH
68589: LD_INT 27
68591: PUSH
68592: LD_INT 28
68594: PUSH
68595: LD_INT 30
68597: PUSH
68598: LD_INT 31
68600: PUSH
68601: LD_INT 32
68603: PUSH
68604: LD_INT 33
68606: PUSH
68607: LD_INT 34
68609: PUSH
68610: LD_INT 36
68612: PUSH
68613: EMPTY
68614: LIST
68615: LIST
68616: LIST
68617: LIST
68618: LIST
68619: LIST
68620: LIST
68621: LIST
68622: LIST
68623: LIST
68624: LIST
68625: LIST
68626: LIST
68627: LIST
68628: LIST
68629: LIST
68630: LIST
68631: LIST
68632: LIST
68633: LIST
68634: LIST
68635: LIST
68636: LIST
68637: LIST
68638: LIST
68639: LIST
68640: LIST
68641: LIST
68642: LIST
68643: LIST
68644: LIST
68645: PUSH
68646: LD_INT 101
68648: PUSH
68649: LD_INT 102
68651: PUSH
68652: LD_INT 103
68654: PUSH
68655: LD_INT 104
68657: PUSH
68658: LD_INT 105
68660: PUSH
68661: LD_INT 106
68663: PUSH
68664: LD_INT 107
68666: PUSH
68667: LD_INT 108
68669: PUSH
68670: LD_INT 109
68672: PUSH
68673: LD_INT 110
68675: PUSH
68676: LD_INT 111
68678: PUSH
68679: LD_INT 112
68681: PUSH
68682: LD_INT 113
68684: PUSH
68685: LD_INT 114
68687: PUSH
68688: LD_INT 116
68690: PUSH
68691: LD_INT 117
68693: PUSH
68694: LD_INT 118
68696: PUSH
68697: EMPTY
68698: LIST
68699: LIST
68700: LIST
68701: LIST
68702: LIST
68703: LIST
68704: LIST
68705: LIST
68706: LIST
68707: LIST
68708: LIST
68709: LIST
68710: LIST
68711: LIST
68712: LIST
68713: LIST
68714: LIST
68715: PUSH
68716: EMPTY
68717: LIST
68718: LIST
68719: ST_TO_ADDR
68720: GO 69959
68722: LD_INT 14
68724: DOUBLE
68725: EQUAL
68726: IFTRUE 68730
68728: GO 68954
68730: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 15 :
68731: LD_ADDR_VAR 0 2
68735: PUSH
68736: LD_INT 1
68738: PUSH
68739: LD_INT 2
68741: PUSH
68742: LD_INT 3
68744: PUSH
68745: LD_INT 4
68747: PUSH
68748: LD_INT 5
68750: PUSH
68751: LD_INT 6
68753: PUSH
68754: LD_INT 7
68756: PUSH
68757: LD_INT 8
68759: PUSH
68760: LD_INT 9
68762: PUSH
68763: LD_INT 10
68765: PUSH
68766: LD_INT 11
68768: PUSH
68769: LD_INT 12
68771: PUSH
68772: LD_INT 13
68774: PUSH
68775: LD_INT 14
68777: PUSH
68778: LD_INT 15
68780: PUSH
68781: LD_INT 16
68783: PUSH
68784: LD_INT 17
68786: PUSH
68787: LD_INT 18
68789: PUSH
68790: LD_INT 19
68792: PUSH
68793: LD_INT 20
68795: PUSH
68796: LD_INT 21
68798: PUSH
68799: LD_INT 22
68801: PUSH
68802: LD_INT 23
68804: PUSH
68805: LD_INT 24
68807: PUSH
68808: LD_INT 25
68810: PUSH
68811: LD_INT 26
68813: PUSH
68814: LD_INT 27
68816: PUSH
68817: LD_INT 28
68819: PUSH
68820: LD_INT 29
68822: PUSH
68823: LD_INT 30
68825: PUSH
68826: LD_INT 31
68828: PUSH
68829: LD_INT 32
68831: PUSH
68832: LD_INT 33
68834: PUSH
68835: LD_INT 34
68837: PUSH
68838: LD_INT 36
68840: PUSH
68841: EMPTY
68842: LIST
68843: LIST
68844: LIST
68845: LIST
68846: LIST
68847: LIST
68848: LIST
68849: LIST
68850: LIST
68851: LIST
68852: LIST
68853: LIST
68854: LIST
68855: LIST
68856: LIST
68857: LIST
68858: LIST
68859: LIST
68860: LIST
68861: LIST
68862: LIST
68863: LIST
68864: LIST
68865: LIST
68866: LIST
68867: LIST
68868: LIST
68869: LIST
68870: LIST
68871: LIST
68872: LIST
68873: LIST
68874: LIST
68875: LIST
68876: LIST
68877: PUSH
68878: LD_INT 101
68880: PUSH
68881: LD_INT 102
68883: PUSH
68884: LD_INT 103
68886: PUSH
68887: LD_INT 104
68889: PUSH
68890: LD_INT 105
68892: PUSH
68893: LD_INT 106
68895: PUSH
68896: LD_INT 107
68898: PUSH
68899: LD_INT 108
68901: PUSH
68902: LD_INT 109
68904: PUSH
68905: LD_INT 110
68907: PUSH
68908: LD_INT 111
68910: PUSH
68911: LD_INT 112
68913: PUSH
68914: LD_INT 113
68916: PUSH
68917: LD_INT 114
68919: PUSH
68920: LD_INT 116
68922: PUSH
68923: LD_INT 117
68925: PUSH
68926: LD_INT 118
68928: PUSH
68929: EMPTY
68930: LIST
68931: LIST
68932: LIST
68933: LIST
68934: LIST
68935: LIST
68936: LIST
68937: LIST
68938: LIST
68939: LIST
68940: LIST
68941: LIST
68942: LIST
68943: LIST
68944: LIST
68945: LIST
68946: LIST
68947: PUSH
68948: EMPTY
68949: LIST
68950: LIST
68951: ST_TO_ADDR
68952: GO 69959
68954: LD_INT 15
68956: DOUBLE
68957: EQUAL
68958: IFTRUE 68962
68960: GO 69186
68962: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 16 :
68963: LD_ADDR_VAR 0 2
68967: PUSH
68968: LD_INT 1
68970: PUSH
68971: LD_INT 2
68973: PUSH
68974: LD_INT 3
68976: PUSH
68977: LD_INT 4
68979: PUSH
68980: LD_INT 5
68982: PUSH
68983: LD_INT 6
68985: PUSH
68986: LD_INT 7
68988: PUSH
68989: LD_INT 8
68991: PUSH
68992: LD_INT 9
68994: PUSH
68995: LD_INT 10
68997: PUSH
68998: LD_INT 11
69000: PUSH
69001: LD_INT 12
69003: PUSH
69004: LD_INT 13
69006: PUSH
69007: LD_INT 14
69009: PUSH
69010: LD_INT 15
69012: PUSH
69013: LD_INT 16
69015: PUSH
69016: LD_INT 17
69018: PUSH
69019: LD_INT 18
69021: PUSH
69022: LD_INT 19
69024: PUSH
69025: LD_INT 20
69027: PUSH
69028: LD_INT 21
69030: PUSH
69031: LD_INT 22
69033: PUSH
69034: LD_INT 23
69036: PUSH
69037: LD_INT 24
69039: PUSH
69040: LD_INT 25
69042: PUSH
69043: LD_INT 26
69045: PUSH
69046: LD_INT 27
69048: PUSH
69049: LD_INT 28
69051: PUSH
69052: LD_INT 29
69054: PUSH
69055: LD_INT 30
69057: PUSH
69058: LD_INT 31
69060: PUSH
69061: LD_INT 32
69063: PUSH
69064: LD_INT 33
69066: PUSH
69067: LD_INT 34
69069: PUSH
69070: LD_INT 36
69072: PUSH
69073: EMPTY
69074: LIST
69075: LIST
69076: LIST
69077: LIST
69078: LIST
69079: LIST
69080: LIST
69081: LIST
69082: LIST
69083: LIST
69084: LIST
69085: LIST
69086: LIST
69087: LIST
69088: LIST
69089: LIST
69090: LIST
69091: LIST
69092: LIST
69093: LIST
69094: LIST
69095: LIST
69096: LIST
69097: LIST
69098: LIST
69099: LIST
69100: LIST
69101: LIST
69102: LIST
69103: LIST
69104: LIST
69105: LIST
69106: LIST
69107: LIST
69108: LIST
69109: PUSH
69110: LD_INT 101
69112: PUSH
69113: LD_INT 102
69115: PUSH
69116: LD_INT 103
69118: PUSH
69119: LD_INT 104
69121: PUSH
69122: LD_INT 105
69124: PUSH
69125: LD_INT 106
69127: PUSH
69128: LD_INT 107
69130: PUSH
69131: LD_INT 108
69133: PUSH
69134: LD_INT 109
69136: PUSH
69137: LD_INT 110
69139: PUSH
69140: LD_INT 111
69142: PUSH
69143: LD_INT 112
69145: PUSH
69146: LD_INT 113
69148: PUSH
69149: LD_INT 114
69151: PUSH
69152: LD_INT 116
69154: PUSH
69155: LD_INT 117
69157: PUSH
69158: LD_INT 118
69160: PUSH
69161: EMPTY
69162: LIST
69163: LIST
69164: LIST
69165: LIST
69166: LIST
69167: LIST
69168: LIST
69169: LIST
69170: LIST
69171: LIST
69172: LIST
69173: LIST
69174: LIST
69175: LIST
69176: LIST
69177: LIST
69178: LIST
69179: PUSH
69180: EMPTY
69181: LIST
69182: LIST
69183: ST_TO_ADDR
69184: GO 69959
69186: LD_INT 16
69188: DOUBLE
69189: EQUAL
69190: IFTRUE 69194
69192: GO 69330
69194: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 17 :
69195: LD_ADDR_VAR 0 2
69199: PUSH
69200: LD_INT 2
69202: PUSH
69203: LD_INT 4
69205: PUSH
69206: LD_INT 5
69208: PUSH
69209: LD_INT 7
69211: PUSH
69212: LD_INT 11
69214: PUSH
69215: LD_INT 12
69217: PUSH
69218: LD_INT 15
69220: PUSH
69221: LD_INT 16
69223: PUSH
69224: LD_INT 20
69226: PUSH
69227: LD_INT 21
69229: PUSH
69230: LD_INT 22
69232: PUSH
69233: LD_INT 23
69235: PUSH
69236: LD_INT 25
69238: PUSH
69239: LD_INT 26
69241: PUSH
69242: LD_INT 30
69244: PUSH
69245: LD_INT 31
69247: PUSH
69248: LD_INT 32
69250: PUSH
69251: LD_INT 33
69253: PUSH
69254: LD_INT 34
69256: PUSH
69257: EMPTY
69258: LIST
69259: LIST
69260: LIST
69261: LIST
69262: LIST
69263: LIST
69264: LIST
69265: LIST
69266: LIST
69267: LIST
69268: LIST
69269: LIST
69270: LIST
69271: LIST
69272: LIST
69273: LIST
69274: LIST
69275: LIST
69276: LIST
69277: PUSH
69278: LD_INT 101
69280: PUSH
69281: LD_INT 102
69283: PUSH
69284: LD_INT 103
69286: PUSH
69287: LD_INT 106
69289: PUSH
69290: LD_INT 108
69292: PUSH
69293: LD_INT 112
69295: PUSH
69296: LD_INT 113
69298: PUSH
69299: LD_INT 114
69301: PUSH
69302: LD_INT 116
69304: PUSH
69305: LD_INT 117
69307: PUSH
69308: LD_INT 118
69310: PUSH
69311: EMPTY
69312: LIST
69313: LIST
69314: LIST
69315: LIST
69316: LIST
69317: LIST
69318: LIST
69319: LIST
69320: LIST
69321: LIST
69322: LIST
69323: PUSH
69324: EMPTY
69325: LIST
69326: LIST
69327: ST_TO_ADDR
69328: GO 69959
69330: LD_INT 17
69332: DOUBLE
69333: EQUAL
69334: IFTRUE 69338
69336: GO 69562
69338: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 18 :
69339: LD_ADDR_VAR 0 2
69343: PUSH
69344: LD_INT 1
69346: PUSH
69347: LD_INT 2
69349: PUSH
69350: LD_INT 3
69352: PUSH
69353: LD_INT 4
69355: PUSH
69356: LD_INT 5
69358: PUSH
69359: LD_INT 6
69361: PUSH
69362: LD_INT 7
69364: PUSH
69365: LD_INT 8
69367: PUSH
69368: LD_INT 9
69370: PUSH
69371: LD_INT 10
69373: PUSH
69374: LD_INT 11
69376: PUSH
69377: LD_INT 12
69379: PUSH
69380: LD_INT 13
69382: PUSH
69383: LD_INT 14
69385: PUSH
69386: LD_INT 15
69388: PUSH
69389: LD_INT 16
69391: PUSH
69392: LD_INT 17
69394: PUSH
69395: LD_INT 18
69397: PUSH
69398: LD_INT 19
69400: PUSH
69401: LD_INT 20
69403: PUSH
69404: LD_INT 21
69406: PUSH
69407: LD_INT 22
69409: PUSH
69410: LD_INT 23
69412: PUSH
69413: LD_INT 24
69415: PUSH
69416: LD_INT 25
69418: PUSH
69419: LD_INT 26
69421: PUSH
69422: LD_INT 27
69424: PUSH
69425: LD_INT 28
69427: PUSH
69428: LD_INT 29
69430: PUSH
69431: LD_INT 30
69433: PUSH
69434: LD_INT 31
69436: PUSH
69437: LD_INT 32
69439: PUSH
69440: LD_INT 33
69442: PUSH
69443: LD_INT 34
69445: PUSH
69446: LD_INT 36
69448: PUSH
69449: EMPTY
69450: LIST
69451: LIST
69452: LIST
69453: LIST
69454: LIST
69455: LIST
69456: LIST
69457: LIST
69458: LIST
69459: LIST
69460: LIST
69461: LIST
69462: LIST
69463: LIST
69464: LIST
69465: LIST
69466: LIST
69467: LIST
69468: LIST
69469: LIST
69470: LIST
69471: LIST
69472: LIST
69473: LIST
69474: LIST
69475: LIST
69476: LIST
69477: LIST
69478: LIST
69479: LIST
69480: LIST
69481: LIST
69482: LIST
69483: LIST
69484: LIST
69485: PUSH
69486: LD_INT 101
69488: PUSH
69489: LD_INT 102
69491: PUSH
69492: LD_INT 103
69494: PUSH
69495: LD_INT 104
69497: PUSH
69498: LD_INT 105
69500: PUSH
69501: LD_INT 106
69503: PUSH
69504: LD_INT 107
69506: PUSH
69507: LD_INT 108
69509: PUSH
69510: LD_INT 109
69512: PUSH
69513: LD_INT 110
69515: PUSH
69516: LD_INT 111
69518: PUSH
69519: LD_INT 112
69521: PUSH
69522: LD_INT 113
69524: PUSH
69525: LD_INT 114
69527: PUSH
69528: LD_INT 116
69530: PUSH
69531: LD_INT 117
69533: PUSH
69534: LD_INT 118
69536: PUSH
69537: EMPTY
69538: LIST
69539: LIST
69540: LIST
69541: LIST
69542: LIST
69543: LIST
69544: LIST
69545: LIST
69546: LIST
69547: LIST
69548: LIST
69549: LIST
69550: LIST
69551: LIST
69552: LIST
69553: LIST
69554: LIST
69555: PUSH
69556: EMPTY
69557: LIST
69558: LIST
69559: ST_TO_ADDR
69560: GO 69959
69562: LD_INT 18
69564: DOUBLE
69565: EQUAL
69566: IFTRUE 69570
69568: GO 69718
69570: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; 19 :
69571: LD_ADDR_VAR 0 2
69575: PUSH
69576: LD_INT 2
69578: PUSH
69579: LD_INT 4
69581: PUSH
69582: LD_INT 5
69584: PUSH
69585: LD_INT 7
69587: PUSH
69588: LD_INT 11
69590: PUSH
69591: LD_INT 12
69593: PUSH
69594: LD_INT 15
69596: PUSH
69597: LD_INT 16
69599: PUSH
69600: LD_INT 20
69602: PUSH
69603: LD_INT 21
69605: PUSH
69606: LD_INT 22
69608: PUSH
69609: LD_INT 23
69611: PUSH
69612: LD_INT 25
69614: PUSH
69615: LD_INT 26
69617: PUSH
69618: LD_INT 30
69620: PUSH
69621: LD_INT 31
69623: PUSH
69624: LD_INT 32
69626: PUSH
69627: LD_INT 33
69629: PUSH
69630: LD_INT 34
69632: PUSH
69633: LD_INT 35
69635: PUSH
69636: LD_INT 36
69638: PUSH
69639: EMPTY
69640: LIST
69641: LIST
69642: LIST
69643: LIST
69644: LIST
69645: LIST
69646: LIST
69647: LIST
69648: LIST
69649: LIST
69650: LIST
69651: LIST
69652: LIST
69653: LIST
69654: LIST
69655: LIST
69656: LIST
69657: LIST
69658: LIST
69659: LIST
69660: LIST
69661: PUSH
69662: LD_INT 101
69664: PUSH
69665: LD_INT 102
69667: PUSH
69668: LD_INT 103
69670: PUSH
69671: LD_INT 106
69673: PUSH
69674: LD_INT 108
69676: PUSH
69677: LD_INT 112
69679: PUSH
69680: LD_INT 113
69682: PUSH
69683: LD_INT 114
69685: PUSH
69686: LD_INT 115
69688: PUSH
69689: LD_INT 116
69691: PUSH
69692: LD_INT 117
69694: PUSH
69695: LD_INT 118
69697: PUSH
69698: EMPTY
69699: LIST
69700: LIST
69701: LIST
69702: LIST
69703: LIST
69704: LIST
69705: LIST
69706: LIST
69707: LIST
69708: LIST
69709: LIST
69710: LIST
69711: PUSH
69712: EMPTY
69713: LIST
69714: LIST
69715: ST_TO_ADDR
69716: GO 69959
69718: LD_INT 19
69720: DOUBLE
69721: EQUAL
69722: IFTRUE 69726
69724: GO 69958
69726: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; end ;
69727: LD_ADDR_VAR 0 2
69731: PUSH
69732: LD_INT 1
69734: PUSH
69735: LD_INT 2
69737: PUSH
69738: LD_INT 3
69740: PUSH
69741: LD_INT 4
69743: PUSH
69744: LD_INT 5
69746: PUSH
69747: LD_INT 6
69749: PUSH
69750: LD_INT 7
69752: PUSH
69753: LD_INT 8
69755: PUSH
69756: LD_INT 9
69758: PUSH
69759: LD_INT 10
69761: PUSH
69762: LD_INT 11
69764: PUSH
69765: LD_INT 12
69767: PUSH
69768: LD_INT 13
69770: PUSH
69771: LD_INT 14
69773: PUSH
69774: LD_INT 15
69776: PUSH
69777: LD_INT 16
69779: PUSH
69780: LD_INT 17
69782: PUSH
69783: LD_INT 18
69785: PUSH
69786: LD_INT 19
69788: PUSH
69789: LD_INT 20
69791: PUSH
69792: LD_INT 21
69794: PUSH
69795: LD_INT 22
69797: PUSH
69798: LD_INT 23
69800: PUSH
69801: LD_INT 24
69803: PUSH
69804: LD_INT 25
69806: PUSH
69807: LD_INT 26
69809: PUSH
69810: LD_INT 27
69812: PUSH
69813: LD_INT 28
69815: PUSH
69816: LD_INT 29
69818: PUSH
69819: LD_INT 30
69821: PUSH
69822: LD_INT 31
69824: PUSH
69825: LD_INT 32
69827: PUSH
69828: LD_INT 33
69830: PUSH
69831: LD_INT 34
69833: PUSH
69834: LD_INT 35
69836: PUSH
69837: LD_INT 36
69839: PUSH
69840: EMPTY
69841: LIST
69842: LIST
69843: LIST
69844: LIST
69845: LIST
69846: LIST
69847: LIST
69848: LIST
69849: LIST
69850: LIST
69851: LIST
69852: LIST
69853: LIST
69854: LIST
69855: LIST
69856: LIST
69857: LIST
69858: LIST
69859: LIST
69860: LIST
69861: LIST
69862: LIST
69863: LIST
69864: LIST
69865: LIST
69866: LIST
69867: LIST
69868: LIST
69869: LIST
69870: LIST
69871: LIST
69872: LIST
69873: LIST
69874: LIST
69875: LIST
69876: LIST
69877: PUSH
69878: LD_INT 101
69880: PUSH
69881: LD_INT 102
69883: PUSH
69884: LD_INT 103
69886: PUSH
69887: LD_INT 104
69889: PUSH
69890: LD_INT 105
69892: PUSH
69893: LD_INT 106
69895: PUSH
69896: LD_INT 107
69898: PUSH
69899: LD_INT 108
69901: PUSH
69902: LD_INT 109
69904: PUSH
69905: LD_INT 110
69907: PUSH
69908: LD_INT 111
69910: PUSH
69911: LD_INT 112
69913: PUSH
69914: LD_INT 113
69916: PUSH
69917: LD_INT 114
69919: PUSH
69920: LD_INT 115
69922: PUSH
69923: LD_INT 116
69925: PUSH
69926: LD_INT 117
69928: PUSH
69929: LD_INT 118
69931: PUSH
69932: EMPTY
69933: LIST
69934: LIST
69935: LIST
69936: LIST
69937: LIST
69938: LIST
69939: LIST
69940: LIST
69941: LIST
69942: LIST
69943: LIST
69944: LIST
69945: LIST
69946: LIST
69947: LIST
69948: LIST
69949: LIST
69950: LIST
69951: PUSH
69952: EMPTY
69953: LIST
69954: LIST
69955: ST_TO_ADDR
69956: GO 69959
69958: POP
// end else
69959: GO 70190
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ;
69961: LD_ADDR_VAR 0 2
69965: PUSH
69966: LD_INT 1
69968: PUSH
69969: LD_INT 2
69971: PUSH
69972: LD_INT 3
69974: PUSH
69975: LD_INT 4
69977: PUSH
69978: LD_INT 5
69980: PUSH
69981: LD_INT 6
69983: PUSH
69984: LD_INT 7
69986: PUSH
69987: LD_INT 8
69989: PUSH
69990: LD_INT 9
69992: PUSH
69993: LD_INT 10
69995: PUSH
69996: LD_INT 11
69998: PUSH
69999: LD_INT 12
70001: PUSH
70002: LD_INT 13
70004: PUSH
70005: LD_INT 14
70007: PUSH
70008: LD_INT 15
70010: PUSH
70011: LD_INT 16
70013: PUSH
70014: LD_INT 17
70016: PUSH
70017: LD_INT 18
70019: PUSH
70020: LD_INT 19
70022: PUSH
70023: LD_INT 20
70025: PUSH
70026: LD_INT 21
70028: PUSH
70029: LD_INT 22
70031: PUSH
70032: LD_INT 23
70034: PUSH
70035: LD_INT 24
70037: PUSH
70038: LD_INT 25
70040: PUSH
70041: LD_INT 26
70043: PUSH
70044: LD_INT 27
70046: PUSH
70047: LD_INT 28
70049: PUSH
70050: LD_INT 29
70052: PUSH
70053: LD_INT 30
70055: PUSH
70056: LD_INT 31
70058: PUSH
70059: LD_INT 32
70061: PUSH
70062: LD_INT 33
70064: PUSH
70065: LD_INT 34
70067: PUSH
70068: LD_INT 35
70070: PUSH
70071: LD_INT 36
70073: PUSH
70074: EMPTY
70075: LIST
70076: LIST
70077: LIST
70078: LIST
70079: LIST
70080: LIST
70081: LIST
70082: LIST
70083: LIST
70084: LIST
70085: LIST
70086: LIST
70087: LIST
70088: LIST
70089: LIST
70090: LIST
70091: LIST
70092: LIST
70093: LIST
70094: LIST
70095: LIST
70096: LIST
70097: LIST
70098: LIST
70099: LIST
70100: LIST
70101: LIST
70102: LIST
70103: LIST
70104: LIST
70105: LIST
70106: LIST
70107: LIST
70108: LIST
70109: LIST
70110: LIST
70111: PUSH
70112: LD_INT 101
70114: PUSH
70115: LD_INT 102
70117: PUSH
70118: LD_INT 103
70120: PUSH
70121: LD_INT 104
70123: PUSH
70124: LD_INT 105
70126: PUSH
70127: LD_INT 106
70129: PUSH
70130: LD_INT 107
70132: PUSH
70133: LD_INT 108
70135: PUSH
70136: LD_INT 109
70138: PUSH
70139: LD_INT 110
70141: PUSH
70142: LD_INT 111
70144: PUSH
70145: LD_INT 112
70147: PUSH
70148: LD_INT 113
70150: PUSH
70151: LD_INT 114
70153: PUSH
70154: LD_INT 115
70156: PUSH
70157: LD_INT 116
70159: PUSH
70160: LD_INT 117
70162: PUSH
70163: LD_INT 118
70165: PUSH
70166: EMPTY
70167: LIST
70168: LIST
70169: LIST
70170: LIST
70171: LIST
70172: LIST
70173: LIST
70174: LIST
70175: LIST
70176: LIST
70177: LIST
70178: LIST
70179: LIST
70180: LIST
70181: LIST
70182: LIST
70183: LIST
70184: LIST
70185: PUSH
70186: EMPTY
70187: LIST
70188: LIST
70189: ST_TO_ADDR
// if result then
70190: LD_VAR 0 2
70194: IFFALSE 70980
// begin normal :=  ;
70196: LD_ADDR_VAR 0 5
70200: PUSH
70201: LD_STRING 
70203: ST_TO_ADDR
// hardcore :=  ;
70204: LD_ADDR_VAR 0 6
70208: PUSH
70209: LD_STRING 
70211: ST_TO_ADDR
// active :=  ;
70212: LD_ADDR_VAR 0 7
70216: PUSH
70217: LD_STRING 
70219: ST_TO_ADDR
// for i = 1 to normalCounter do
70220: LD_ADDR_VAR 0 8
70224: PUSH
70225: DOUBLE
70226: LD_INT 1
70228: DEC
70229: ST_TO_ADDR
70230: LD_EXP 99
70234: PUSH
70235: FOR_TO
70236: IFFALSE 70337
// begin tmp := 0 ;
70238: LD_ADDR_VAR 0 3
70242: PUSH
70243: LD_STRING 0
70245: ST_TO_ADDR
// if result [ 1 ] then
70246: LD_VAR 0 2
70250: PUSH
70251: LD_INT 1
70253: ARRAY
70254: IFFALSE 70319
// if result [ 1 ] [ 1 ] = i then
70256: LD_VAR 0 2
70260: PUSH
70261: LD_INT 1
70263: ARRAY
70264: PUSH
70265: LD_INT 1
70267: ARRAY
70268: PUSH
70269: LD_VAR 0 8
70273: EQUAL
70274: IFFALSE 70319
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
70276: LD_ADDR_VAR 0 2
70280: PUSH
70281: LD_VAR 0 2
70285: PPUSH
70286: LD_INT 1
70288: PPUSH
70289: LD_VAR 0 2
70293: PUSH
70294: LD_INT 1
70296: ARRAY
70297: PPUSH
70298: LD_INT 1
70300: PPUSH
70301: CALL_OW 3
70305: PPUSH
70306: CALL_OW 1
70310: ST_TO_ADDR
// tmp := 1 ;
70311: LD_ADDR_VAR 0 3
70315: PUSH
70316: LD_STRING 1
70318: ST_TO_ADDR
// end ; normal := normal & tmp ;
70319: LD_ADDR_VAR 0 5
70323: PUSH
70324: LD_VAR 0 5
70328: PUSH
70329: LD_VAR 0 3
70333: STR
70334: ST_TO_ADDR
// end ;
70335: GO 70235
70337: POP
70338: POP
// for i = 1 to hardcoreCounter do
70339: LD_ADDR_VAR 0 8
70343: PUSH
70344: DOUBLE
70345: LD_INT 1
70347: DEC
70348: ST_TO_ADDR
70349: LD_EXP 100
70353: PUSH
70354: FOR_TO
70355: IFFALSE 70460
// begin tmp := 0 ;
70357: LD_ADDR_VAR 0 3
70361: PUSH
70362: LD_STRING 0
70364: ST_TO_ADDR
// if result [ 2 ] then
70365: LD_VAR 0 2
70369: PUSH
70370: LD_INT 2
70372: ARRAY
70373: IFFALSE 70442
// if result [ 2 ] [ 1 ] = 100 + i then
70375: LD_VAR 0 2
70379: PUSH
70380: LD_INT 2
70382: ARRAY
70383: PUSH
70384: LD_INT 1
70386: ARRAY
70387: PUSH
70388: LD_INT 100
70390: PUSH
70391: LD_VAR 0 8
70395: PLUS
70396: EQUAL
70397: IFFALSE 70442
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
70399: LD_ADDR_VAR 0 2
70403: PUSH
70404: LD_VAR 0 2
70408: PPUSH
70409: LD_INT 2
70411: PPUSH
70412: LD_VAR 0 2
70416: PUSH
70417: LD_INT 2
70419: ARRAY
70420: PPUSH
70421: LD_INT 1
70423: PPUSH
70424: CALL_OW 3
70428: PPUSH
70429: CALL_OW 1
70433: ST_TO_ADDR
// tmp := 1 ;
70434: LD_ADDR_VAR 0 3
70438: PUSH
70439: LD_STRING 1
70441: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
70442: LD_ADDR_VAR 0 6
70446: PUSH
70447: LD_VAR 0 6
70451: PUSH
70452: LD_VAR 0 3
70456: STR
70457: ST_TO_ADDR
// end ;
70458: GO 70354
70460: POP
70461: POP
// if isGameLoad then
70462: LD_VAR 0 1
70466: IFFALSE 70941
// begin flags := [ sRocket , sSpeed , sEngine , sSpec , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sKamikadze , sTroll , sSlow , sLack , sTank , sRemote , sPowell , sTeleport , sOilTower , sShovel , sSheik , sEarthquake , sAI , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sSold , sDiff , sFog , sReset , sSun , sTiger , sBomb , sWound , sBetray , sContamin , sOil , sStu , sBazooka , sMortar , sRanger , sComputer , s30 , s60 ] ;
70468: LD_ADDR_VAR 0 4
70472: PUSH
70473: LD_EXP 103
70477: PUSH
70478: LD_EXP 102
70482: PUSH
70483: LD_EXP 104
70487: PUSH
70488: LD_EXP 101
70492: PUSH
70493: LD_EXP 105
70497: PUSH
70498: LD_EXP 106
70502: PUSH
70503: LD_EXP 107
70507: PUSH
70508: LD_EXP 108
70512: PUSH
70513: LD_EXP 109
70517: PUSH
70518: LD_EXP 110
70522: PUSH
70523: LD_EXP 111
70527: PUSH
70528: LD_EXP 112
70532: PUSH
70533: LD_EXP 113
70537: PUSH
70538: LD_EXP 114
70542: PUSH
70543: LD_EXP 122
70547: PUSH
70548: LD_EXP 123
70552: PUSH
70553: LD_EXP 124
70557: PUSH
70558: LD_EXP 125
70562: PUSH
70563: LD_EXP 127
70567: PUSH
70568: LD_EXP 128
70572: PUSH
70573: LD_EXP 129
70577: PUSH
70578: LD_EXP 132
70582: PUSH
70583: LD_EXP 134
70587: PUSH
70588: LD_EXP 135
70592: PUSH
70593: LD_EXP 136
70597: PUSH
70598: LD_EXP 138
70602: PUSH
70603: LD_EXP 139
70607: PUSH
70608: LD_EXP 142
70612: PUSH
70613: LD_EXP 143
70617: PUSH
70618: LD_EXP 144
70622: PUSH
70623: LD_EXP 145
70627: PUSH
70628: LD_EXP 146
70632: PUSH
70633: LD_EXP 147
70637: PUSH
70638: LD_EXP 148
70642: PUSH
70643: LD_EXP 149
70647: PUSH
70648: LD_EXP 150
70652: PUSH
70653: LD_EXP 115
70657: PUSH
70658: LD_EXP 116
70662: PUSH
70663: LD_EXP 119
70667: PUSH
70668: LD_EXP 120
70672: PUSH
70673: LD_EXP 121
70677: PUSH
70678: LD_EXP 117
70682: PUSH
70683: LD_EXP 118
70687: PUSH
70688: LD_EXP 126
70692: PUSH
70693: LD_EXP 130
70697: PUSH
70698: LD_EXP 131
70702: PUSH
70703: LD_EXP 133
70707: PUSH
70708: LD_EXP 137
70712: PUSH
70713: LD_EXP 140
70717: PUSH
70718: LD_EXP 141
70722: PUSH
70723: LD_EXP 151
70727: PUSH
70728: LD_EXP 152
70732: PUSH
70733: LD_EXP 153
70737: PUSH
70738: LD_EXP 154
70742: PUSH
70743: EMPTY
70744: LIST
70745: LIST
70746: LIST
70747: LIST
70748: LIST
70749: LIST
70750: LIST
70751: LIST
70752: LIST
70753: LIST
70754: LIST
70755: LIST
70756: LIST
70757: LIST
70758: LIST
70759: LIST
70760: LIST
70761: LIST
70762: LIST
70763: LIST
70764: LIST
70765: LIST
70766: LIST
70767: LIST
70768: LIST
70769: LIST
70770: LIST
70771: LIST
70772: LIST
70773: LIST
70774: LIST
70775: LIST
70776: LIST
70777: LIST
70778: LIST
70779: LIST
70780: LIST
70781: LIST
70782: LIST
70783: LIST
70784: LIST
70785: LIST
70786: LIST
70787: LIST
70788: LIST
70789: LIST
70790: LIST
70791: LIST
70792: LIST
70793: LIST
70794: LIST
70795: LIST
70796: LIST
70797: LIST
70798: ST_TO_ADDR
// tmp :=  ;
70799: LD_ADDR_VAR 0 3
70803: PUSH
70804: LD_STRING 
70806: ST_TO_ADDR
// for i = 1 to normalCounter do
70807: LD_ADDR_VAR 0 8
70811: PUSH
70812: DOUBLE
70813: LD_INT 1
70815: DEC
70816: ST_TO_ADDR
70817: LD_EXP 99
70821: PUSH
70822: FOR_TO
70823: IFFALSE 70859
// begin if flags [ i ] then
70825: LD_VAR 0 4
70829: PUSH
70830: LD_VAR 0 8
70834: ARRAY
70835: IFFALSE 70857
// tmp := tmp & i & ; ;
70837: LD_ADDR_VAR 0 3
70841: PUSH
70842: LD_VAR 0 3
70846: PUSH
70847: LD_VAR 0 8
70851: STR
70852: PUSH
70853: LD_STRING ;
70855: STR
70856: ST_TO_ADDR
// end ;
70857: GO 70822
70859: POP
70860: POP
// for i = 1 to hardcoreCounter do
70861: LD_ADDR_VAR 0 8
70865: PUSH
70866: DOUBLE
70867: LD_INT 1
70869: DEC
70870: ST_TO_ADDR
70871: LD_EXP 100
70875: PUSH
70876: FOR_TO
70877: IFFALSE 70923
// begin if flags [ normalCounter + i ] then
70879: LD_VAR 0 4
70883: PUSH
70884: LD_EXP 99
70888: PUSH
70889: LD_VAR 0 8
70893: PLUS
70894: ARRAY
70895: IFFALSE 70921
// tmp := tmp & ( 100 + i ) & ; ;
70897: LD_ADDR_VAR 0 3
70901: PUSH
70902: LD_VAR 0 3
70906: PUSH
70907: LD_INT 100
70909: PUSH
70910: LD_VAR 0 8
70914: PLUS
70915: STR
70916: PUSH
70917: LD_STRING ;
70919: STR
70920: ST_TO_ADDR
// end ;
70921: GO 70876
70923: POP
70924: POP
// if tmp then
70925: LD_VAR 0 3
70929: IFFALSE 70941
// active := tmp ;
70931: LD_ADDR_VAR 0 7
70935: PUSH
70936: LD_VAR 0 3
70940: ST_TO_ADDR
// end ; ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & "," & active & ") ) ;
70941: LD_STRING getStreamItemsFromMission("
70943: PUSH
70944: LD_VAR 0 5
70948: STR
70949: PUSH
70950: LD_STRING ","
70952: STR
70953: PUSH
70954: LD_VAR 0 6
70958: STR
70959: PUSH
70960: LD_STRING ","
70962: STR
70963: PUSH
70964: LD_VAR 0 7
70968: STR
70969: PUSH
70970: LD_STRING ")
70972: STR
70973: PPUSH
70974: CALL_OW 559
// end else
70978: GO 70987
// ToLua ( getStreamItemsFromMission("","","") ) ;
70980: LD_STRING getStreamItemsFromMission("","","")
70982: PPUSH
70983: CALL_OW 559
// end ;
70987: LD_VAR 0 2
70991: RET
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
70992: LD_EXP 98
70996: PUSH
70997: LD_EXP 103
71001: AND
71002: IFFALSE 71126
71004: GO 71006
71006: DISABLE
71007: LD_INT 0
71009: PPUSH
71010: PPUSH
// begin enable ;
71011: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
71012: LD_ADDR_VAR 0 2
71016: PUSH
71017: LD_INT 22
71019: PUSH
71020: LD_OWVAR 2
71024: PUSH
71025: EMPTY
71026: LIST
71027: LIST
71028: PUSH
71029: LD_INT 2
71031: PUSH
71032: LD_INT 34
71034: PUSH
71035: LD_INT 7
71037: PUSH
71038: EMPTY
71039: LIST
71040: LIST
71041: PUSH
71042: LD_INT 34
71044: PUSH
71045: LD_INT 45
71047: PUSH
71048: EMPTY
71049: LIST
71050: LIST
71051: PUSH
71052: LD_INT 34
71054: PUSH
71055: LD_INT 28
71057: PUSH
71058: EMPTY
71059: LIST
71060: LIST
71061: PUSH
71062: LD_INT 34
71064: PUSH
71065: LD_INT 47
71067: PUSH
71068: EMPTY
71069: LIST
71070: LIST
71071: PUSH
71072: EMPTY
71073: LIST
71074: LIST
71075: LIST
71076: LIST
71077: LIST
71078: PUSH
71079: EMPTY
71080: LIST
71081: LIST
71082: PPUSH
71083: CALL_OW 69
71087: ST_TO_ADDR
// if not tmp then
71088: LD_VAR 0 2
71092: NOT
71093: IFFALSE 71097
// exit ;
71095: GO 71126
// for i in tmp do
71097: LD_ADDR_VAR 0 1
71101: PUSH
71102: LD_VAR 0 2
71106: PUSH
71107: FOR_IN
71108: IFFALSE 71124
// begin SetLives ( i , 0 ) ;
71110: LD_VAR 0 1
71114: PPUSH
71115: LD_INT 0
71117: PPUSH
71118: CALL_OW 234
// end ;
71122: GO 71107
71124: POP
71125: POP
// end ;
71126: PPOPN 2
71128: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
71129: LD_EXP 98
71133: PUSH
71134: LD_EXP 104
71138: AND
71139: IFFALSE 71223
71141: GO 71143
71143: DISABLE
71144: LD_INT 0
71146: PPUSH
71147: PPUSH
// begin enable ;
71148: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
71149: LD_ADDR_VAR 0 2
71153: PUSH
71154: LD_INT 22
71156: PUSH
71157: LD_OWVAR 2
71161: PUSH
71162: EMPTY
71163: LIST
71164: LIST
71165: PUSH
71166: LD_INT 32
71168: PUSH
71169: LD_INT 3
71171: PUSH
71172: EMPTY
71173: LIST
71174: LIST
71175: PUSH
71176: EMPTY
71177: LIST
71178: LIST
71179: PPUSH
71180: CALL_OW 69
71184: ST_TO_ADDR
// if not tmp then
71185: LD_VAR 0 2
71189: NOT
71190: IFFALSE 71194
// exit ;
71192: GO 71223
// for i in tmp do
71194: LD_ADDR_VAR 0 1
71198: PUSH
71199: LD_VAR 0 2
71203: PUSH
71204: FOR_IN
71205: IFFALSE 71221
// begin SetLives ( i , 0 ) ;
71207: LD_VAR 0 1
71211: PPUSH
71212: LD_INT 0
71214: PPUSH
71215: CALL_OW 234
// end ;
71219: GO 71204
71221: POP
71222: POP
// end ;
71223: PPOPN 2
71225: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
71226: LD_EXP 98
71230: PUSH
71231: LD_EXP 101
71235: AND
71236: IFFALSE 71329
71238: GO 71240
71240: DISABLE
71241: LD_INT 0
71243: PPUSH
// begin enable ;
71244: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
71245: LD_ADDR_VAR 0 1
71249: PUSH
71250: LD_INT 22
71252: PUSH
71253: LD_OWVAR 2
71257: PUSH
71258: EMPTY
71259: LIST
71260: LIST
71261: PUSH
71262: LD_INT 2
71264: PUSH
71265: LD_INT 25
71267: PUSH
71268: LD_INT 5
71270: PUSH
71271: EMPTY
71272: LIST
71273: LIST
71274: PUSH
71275: LD_INT 25
71277: PUSH
71278: LD_INT 9
71280: PUSH
71281: EMPTY
71282: LIST
71283: LIST
71284: PUSH
71285: LD_INT 25
71287: PUSH
71288: LD_INT 8
71290: PUSH
71291: EMPTY
71292: LIST
71293: LIST
71294: PUSH
71295: EMPTY
71296: LIST
71297: LIST
71298: LIST
71299: LIST
71300: PUSH
71301: EMPTY
71302: LIST
71303: LIST
71304: PPUSH
71305: CALL_OW 69
71309: PUSH
71310: FOR_IN
71311: IFFALSE 71327
// begin SetClass ( i , 1 ) ;
71313: LD_VAR 0 1
71317: PPUSH
71318: LD_INT 1
71320: PPUSH
71321: CALL_OW 336
// end ;
71325: GO 71310
71327: POP
71328: POP
// end ;
71329: PPOPN 1
71331: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
71332: LD_EXP 98
71336: PUSH
71337: LD_EXP 102
71341: AND
71342: PUSH
71343: LD_OWVAR 65
71347: PUSH
71348: LD_INT 7
71350: LESS
71351: AND
71352: IFFALSE 71366
71354: GO 71356
71356: DISABLE
// begin enable ;
71357: ENABLE
// game_speed := 7 ;
71358: LD_ADDR_OWVAR 65
71362: PUSH
71363: LD_INT 7
71365: ST_TO_ADDR
// end ;
71366: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
71367: LD_EXP 98
71371: PUSH
71372: LD_EXP 105
71376: AND
71377: IFFALSE 71579
71379: GO 71381
71381: DISABLE
71382: LD_INT 0
71384: PPUSH
71385: PPUSH
71386: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
71387: LD_ADDR_VAR 0 3
71391: PUSH
71392: LD_INT 81
71394: PUSH
71395: LD_OWVAR 2
71399: PUSH
71400: EMPTY
71401: LIST
71402: LIST
71403: PUSH
71404: LD_INT 21
71406: PUSH
71407: LD_INT 1
71409: PUSH
71410: EMPTY
71411: LIST
71412: LIST
71413: PUSH
71414: EMPTY
71415: LIST
71416: LIST
71417: PPUSH
71418: CALL_OW 69
71422: ST_TO_ADDR
// if not tmp then
71423: LD_VAR 0 3
71427: NOT
71428: IFFALSE 71432
// exit ;
71430: GO 71579
// if tmp > 5 then
71432: LD_VAR 0 3
71436: PUSH
71437: LD_INT 5
71439: GREATER
71440: IFFALSE 71452
// k := 5 else
71442: LD_ADDR_VAR 0 2
71446: PUSH
71447: LD_INT 5
71449: ST_TO_ADDR
71450: GO 71462
// k := tmp ;
71452: LD_ADDR_VAR 0 2
71456: PUSH
71457: LD_VAR 0 3
71461: ST_TO_ADDR
// for i := 1 to k do
71462: LD_ADDR_VAR 0 1
71466: PUSH
71467: DOUBLE
71468: LD_INT 1
71470: DEC
71471: ST_TO_ADDR
71472: LD_VAR 0 2
71476: PUSH
71477: FOR_TO
71478: IFFALSE 71577
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
71480: LD_VAR 0 3
71484: PUSH
71485: LD_VAR 0 1
71489: ARRAY
71490: PPUSH
71491: LD_VAR 0 1
71495: PUSH
71496: LD_INT 4
71498: MOD
71499: PUSH
71500: LD_INT 1
71502: PLUS
71503: PPUSH
71504: CALL_OW 259
71508: PUSH
71509: LD_INT 10
71511: LESS
71512: IFFALSE 71575
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
71514: LD_VAR 0 3
71518: PUSH
71519: LD_VAR 0 1
71523: ARRAY
71524: PPUSH
71525: LD_VAR 0 1
71529: PUSH
71530: LD_INT 4
71532: MOD
71533: PUSH
71534: LD_INT 1
71536: PLUS
71537: PPUSH
71538: LD_VAR 0 3
71542: PUSH
71543: LD_VAR 0 1
71547: ARRAY
71548: PPUSH
71549: LD_VAR 0 1
71553: PUSH
71554: LD_INT 4
71556: MOD
71557: PUSH
71558: LD_INT 1
71560: PLUS
71561: PPUSH
71562: CALL_OW 259
71566: PUSH
71567: LD_INT 1
71569: PLUS
71570: PPUSH
71571: CALL_OW 237
71575: GO 71477
71577: POP
71578: POP
// end ;
71579: PPOPN 3
71581: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
71582: LD_EXP 98
71586: PUSH
71587: LD_EXP 106
71591: AND
71592: IFFALSE 71612
71594: GO 71596
71596: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
71597: LD_INT 4
71599: PPUSH
71600: LD_OWVAR 2
71604: PPUSH
71605: LD_INT 0
71607: PPUSH
71608: CALL_OW 324
71612: END
// every 0 0$1 trigger StreamModeActive and sShovel do
71613: LD_EXP 98
71617: PUSH
71618: LD_EXP 135
71622: AND
71623: IFFALSE 71643
71625: GO 71627
71627: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
71628: LD_INT 19
71630: PPUSH
71631: LD_OWVAR 2
71635: PPUSH
71636: LD_INT 0
71638: PPUSH
71639: CALL_OW 324
71643: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
71644: LD_EXP 98
71648: PUSH
71649: LD_EXP 107
71653: AND
71654: IFFALSE 71756
71656: GO 71658
71658: DISABLE
71659: LD_INT 0
71661: PPUSH
71662: PPUSH
// begin enable ;
71663: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
71664: LD_ADDR_VAR 0 2
71668: PUSH
71669: LD_INT 22
71671: PUSH
71672: LD_OWVAR 2
71676: PUSH
71677: EMPTY
71678: LIST
71679: LIST
71680: PUSH
71681: LD_INT 2
71683: PUSH
71684: LD_INT 34
71686: PUSH
71687: LD_INT 11
71689: PUSH
71690: EMPTY
71691: LIST
71692: LIST
71693: PUSH
71694: LD_INT 34
71696: PUSH
71697: LD_INT 30
71699: PUSH
71700: EMPTY
71701: LIST
71702: LIST
71703: PUSH
71704: EMPTY
71705: LIST
71706: LIST
71707: LIST
71708: PUSH
71709: EMPTY
71710: LIST
71711: LIST
71712: PPUSH
71713: CALL_OW 69
71717: ST_TO_ADDR
// if not tmp then
71718: LD_VAR 0 2
71722: NOT
71723: IFFALSE 71727
// exit ;
71725: GO 71756
// for i in tmp do
71727: LD_ADDR_VAR 0 1
71731: PUSH
71732: LD_VAR 0 2
71736: PUSH
71737: FOR_IN
71738: IFFALSE 71754
// begin SetLives ( i , 0 ) ;
71740: LD_VAR 0 1
71744: PPUSH
71745: LD_INT 0
71747: PPUSH
71748: CALL_OW 234
// end ;
71752: GO 71737
71754: POP
71755: POP
// end ;
71756: PPOPN 2
71758: END
// every 0 0$1 trigger StreamModeActive and sBunker do
71759: LD_EXP 98
71763: PUSH
71764: LD_EXP 108
71768: AND
71769: IFFALSE 71789
71771: GO 71773
71773: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
71774: LD_INT 32
71776: PPUSH
71777: LD_OWVAR 2
71781: PPUSH
71782: LD_INT 0
71784: PPUSH
71785: CALL_OW 324
71789: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
71790: LD_EXP 98
71794: PUSH
71795: LD_EXP 109
71799: AND
71800: IFFALSE 71981
71802: GO 71804
71804: DISABLE
71805: LD_INT 0
71807: PPUSH
71808: PPUSH
71809: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
71810: LD_ADDR_VAR 0 2
71814: PUSH
71815: LD_INT 22
71817: PUSH
71818: LD_OWVAR 2
71822: PUSH
71823: EMPTY
71824: LIST
71825: LIST
71826: PUSH
71827: LD_INT 33
71829: PUSH
71830: LD_INT 3
71832: PUSH
71833: EMPTY
71834: LIST
71835: LIST
71836: PUSH
71837: EMPTY
71838: LIST
71839: LIST
71840: PPUSH
71841: CALL_OW 69
71845: ST_TO_ADDR
// if not tmp then
71846: LD_VAR 0 2
71850: NOT
71851: IFFALSE 71855
// exit ;
71853: GO 71981
// side := 0 ;
71855: LD_ADDR_VAR 0 3
71859: PUSH
71860: LD_INT 0
71862: ST_TO_ADDR
// for i := 1 to 8 do
71863: LD_ADDR_VAR 0 1
71867: PUSH
71868: DOUBLE
71869: LD_INT 1
71871: DEC
71872: ST_TO_ADDR
71873: LD_INT 8
71875: PUSH
71876: FOR_TO
71877: IFFALSE 71925
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
71879: LD_OWVAR 2
71883: PUSH
71884: LD_VAR 0 1
71888: NONEQUAL
71889: PUSH
71890: LD_OWVAR 2
71894: PPUSH
71895: LD_VAR 0 1
71899: PPUSH
71900: CALL_OW 81
71904: PUSH
71905: LD_INT 2
71907: EQUAL
71908: AND
71909: IFFALSE 71923
// begin side := i ;
71911: LD_ADDR_VAR 0 3
71915: PUSH
71916: LD_VAR 0 1
71920: ST_TO_ADDR
// break ;
71921: GO 71925
// end ;
71923: GO 71876
71925: POP
71926: POP
// if not side then
71927: LD_VAR 0 3
71931: NOT
71932: IFFALSE 71936
// exit ;
71934: GO 71981
// for i := 1 to tmp do
71936: LD_ADDR_VAR 0 1
71940: PUSH
71941: DOUBLE
71942: LD_INT 1
71944: DEC
71945: ST_TO_ADDR
71946: LD_VAR 0 2
71950: PUSH
71951: FOR_TO
71952: IFFALSE 71979
// if Prob ( 60 ) then
71954: LD_INT 60
71956: PPUSH
71957: CALL_OW 13
71961: IFFALSE 71977
// SetSide ( i , side ) ;
71963: LD_VAR 0 1
71967: PPUSH
71968: LD_VAR 0 3
71972: PPUSH
71973: CALL_OW 235
71977: GO 71951
71979: POP
71980: POP
// end ;
71981: PPOPN 3
71983: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
71984: LD_EXP 98
71988: PUSH
71989: LD_EXP 111
71993: AND
71994: IFFALSE 72113
71996: GO 71998
71998: DISABLE
71999: LD_INT 0
72001: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
72002: LD_ADDR_VAR 0 1
72006: PUSH
72007: LD_INT 22
72009: PUSH
72010: LD_OWVAR 2
72014: PUSH
72015: EMPTY
72016: LIST
72017: LIST
72018: PUSH
72019: LD_INT 21
72021: PUSH
72022: LD_INT 1
72024: PUSH
72025: EMPTY
72026: LIST
72027: LIST
72028: PUSH
72029: LD_INT 3
72031: PUSH
72032: LD_INT 23
72034: PUSH
72035: LD_INT 0
72037: PUSH
72038: EMPTY
72039: LIST
72040: LIST
72041: PUSH
72042: EMPTY
72043: LIST
72044: LIST
72045: PUSH
72046: EMPTY
72047: LIST
72048: LIST
72049: LIST
72050: PPUSH
72051: CALL_OW 69
72055: PUSH
72056: FOR_IN
72057: IFFALSE 72111
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
72059: LD_VAR 0 1
72063: PPUSH
72064: CALL_OW 257
72068: PUSH
72069: LD_INT 1
72071: PUSH
72072: LD_INT 2
72074: PUSH
72075: LD_INT 3
72077: PUSH
72078: LD_INT 4
72080: PUSH
72081: EMPTY
72082: LIST
72083: LIST
72084: LIST
72085: LIST
72086: IN
72087: IFFALSE 72109
// SetClass ( un , rand ( 1 , 4 ) ) ;
72089: LD_VAR 0 1
72093: PPUSH
72094: LD_INT 1
72096: PPUSH
72097: LD_INT 4
72099: PPUSH
72100: CALL_OW 12
72104: PPUSH
72105: CALL_OW 336
72109: GO 72056
72111: POP
72112: POP
// end ;
72113: PPOPN 1
72115: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
72116: LD_EXP 98
72120: PUSH
72121: LD_EXP 110
72125: AND
72126: IFFALSE 72205
72128: GO 72130
72130: DISABLE
72131: LD_INT 0
72133: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
72134: LD_ADDR_VAR 0 1
72138: PUSH
72139: LD_INT 22
72141: PUSH
72142: LD_OWVAR 2
72146: PUSH
72147: EMPTY
72148: LIST
72149: LIST
72150: PUSH
72151: LD_INT 21
72153: PUSH
72154: LD_INT 3
72156: PUSH
72157: EMPTY
72158: LIST
72159: LIST
72160: PUSH
72161: EMPTY
72162: LIST
72163: LIST
72164: PPUSH
72165: CALL_OW 69
72169: ST_TO_ADDR
// if not tmp then
72170: LD_VAR 0 1
72174: NOT
72175: IFFALSE 72179
// exit ;
72177: GO 72205
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
72179: LD_VAR 0 1
72183: PUSH
72184: LD_INT 1
72186: PPUSH
72187: LD_VAR 0 1
72191: PPUSH
72192: CALL_OW 12
72196: ARRAY
72197: PPUSH
72198: LD_INT 100
72200: PPUSH
72201: CALL_OW 234
// end ;
72205: PPOPN 1
72207: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
72208: LD_EXP 98
72212: PUSH
72213: LD_EXP 112
72217: AND
72218: IFFALSE 72316
72220: GO 72222
72222: DISABLE
72223: LD_INT 0
72225: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
72226: LD_ADDR_VAR 0 1
72230: PUSH
72231: LD_INT 22
72233: PUSH
72234: LD_OWVAR 2
72238: PUSH
72239: EMPTY
72240: LIST
72241: LIST
72242: PUSH
72243: LD_INT 21
72245: PUSH
72246: LD_INT 1
72248: PUSH
72249: EMPTY
72250: LIST
72251: LIST
72252: PUSH
72253: EMPTY
72254: LIST
72255: LIST
72256: PPUSH
72257: CALL_OW 69
72261: ST_TO_ADDR
// if not tmp then
72262: LD_VAR 0 1
72266: NOT
72267: IFFALSE 72271
// exit ;
72269: GO 72316
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
72271: LD_VAR 0 1
72275: PUSH
72276: LD_INT 1
72278: PPUSH
72279: LD_VAR 0 1
72283: PPUSH
72284: CALL_OW 12
72288: ARRAY
72289: PPUSH
72290: LD_INT 1
72292: PPUSH
72293: LD_INT 4
72295: PPUSH
72296: CALL_OW 12
72300: PPUSH
72301: LD_INT 3000
72303: PPUSH
72304: LD_INT 9000
72306: PPUSH
72307: CALL_OW 12
72311: PPUSH
72312: CALL_OW 492
// end ;
72316: PPOPN 1
72318: END
// every 0 0$1 trigger StreamModeActive and sDepot do
72319: LD_EXP 98
72323: PUSH
72324: LD_EXP 113
72328: AND
72329: IFFALSE 72349
72331: GO 72333
72333: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
72334: LD_INT 1
72336: PPUSH
72337: LD_OWVAR 2
72341: PPUSH
72342: LD_INT 0
72344: PPUSH
72345: CALL_OW 324
72349: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
72350: LD_EXP 98
72354: PUSH
72355: LD_EXP 114
72359: AND
72360: IFFALSE 72443
72362: GO 72364
72364: DISABLE
72365: LD_INT 0
72367: PPUSH
72368: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
72369: LD_ADDR_VAR 0 2
72373: PUSH
72374: LD_INT 22
72376: PUSH
72377: LD_OWVAR 2
72381: PUSH
72382: EMPTY
72383: LIST
72384: LIST
72385: PUSH
72386: LD_INT 21
72388: PUSH
72389: LD_INT 3
72391: PUSH
72392: EMPTY
72393: LIST
72394: LIST
72395: PUSH
72396: EMPTY
72397: LIST
72398: LIST
72399: PPUSH
72400: CALL_OW 69
72404: ST_TO_ADDR
// if not tmp then
72405: LD_VAR 0 2
72409: NOT
72410: IFFALSE 72414
// exit ;
72412: GO 72443
// for i in tmp do
72414: LD_ADDR_VAR 0 1
72418: PUSH
72419: LD_VAR 0 2
72423: PUSH
72424: FOR_IN
72425: IFFALSE 72441
// SetBLevel ( i , 10 ) ;
72427: LD_VAR 0 1
72431: PPUSH
72432: LD_INT 10
72434: PPUSH
72435: CALL_OW 241
72439: GO 72424
72441: POP
72442: POP
// end ;
72443: PPOPN 2
72445: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
72446: LD_EXP 98
72450: PUSH
72451: LD_EXP 115
72455: AND
72456: IFFALSE 72567
72458: GO 72460
72460: DISABLE
72461: LD_INT 0
72463: PPUSH
72464: PPUSH
72465: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
72466: LD_ADDR_VAR 0 3
72470: PUSH
72471: LD_INT 22
72473: PUSH
72474: LD_OWVAR 2
72478: PUSH
72479: EMPTY
72480: LIST
72481: LIST
72482: PUSH
72483: LD_INT 25
72485: PUSH
72486: LD_INT 1
72488: PUSH
72489: EMPTY
72490: LIST
72491: LIST
72492: PUSH
72493: EMPTY
72494: LIST
72495: LIST
72496: PPUSH
72497: CALL_OW 69
72501: ST_TO_ADDR
// if not tmp then
72502: LD_VAR 0 3
72506: NOT
72507: IFFALSE 72511
// exit ;
72509: GO 72567
// un := tmp [ rand ( 1 , tmp ) ] ;
72511: LD_ADDR_VAR 0 2
72515: PUSH
72516: LD_VAR 0 3
72520: PUSH
72521: LD_INT 1
72523: PPUSH
72524: LD_VAR 0 3
72528: PPUSH
72529: CALL_OW 12
72533: ARRAY
72534: ST_TO_ADDR
// if Crawls ( un ) then
72535: LD_VAR 0 2
72539: PPUSH
72540: CALL_OW 318
72544: IFFALSE 72555
// ComWalk ( un ) ;
72546: LD_VAR 0 2
72550: PPUSH
72551: CALL_OW 138
// SetClass ( un , class_sniper ) ;
72555: LD_VAR 0 2
72559: PPUSH
72560: LD_INT 5
72562: PPUSH
72563: CALL_OW 336
// end ;
72567: PPOPN 3
72569: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 4 do
72570: LD_EXP 98
72574: PUSH
72575: LD_EXP 116
72579: AND
72580: PUSH
72581: LD_OWVAR 67
72585: PUSH
72586: LD_INT 4
72588: LESS
72589: AND
72590: IFFALSE 72609
72592: GO 72594
72594: DISABLE
// begin Difficulty := Difficulty + 1 ;
72595: LD_ADDR_OWVAR 67
72599: PUSH
72600: LD_OWVAR 67
72604: PUSH
72605: LD_INT 1
72607: PLUS
72608: ST_TO_ADDR
// end ;
72609: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
72610: LD_EXP 98
72614: PUSH
72615: LD_EXP 117
72619: AND
72620: IFFALSE 72723
72622: GO 72624
72624: DISABLE
72625: LD_INT 0
72627: PPUSH
// begin for i := 1 to 5 do
72628: LD_ADDR_VAR 0 1
72632: PUSH
72633: DOUBLE
72634: LD_INT 1
72636: DEC
72637: ST_TO_ADDR
72638: LD_INT 5
72640: PUSH
72641: FOR_TO
72642: IFFALSE 72721
// begin uc_nation := nation_nature ;
72644: LD_ADDR_OWVAR 21
72648: PUSH
72649: LD_INT 0
72651: ST_TO_ADDR
// uc_side := 0 ;
72652: LD_ADDR_OWVAR 20
72656: PUSH
72657: LD_INT 0
72659: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
72660: LD_ADDR_OWVAR 29
72664: PUSH
72665: LD_INT 12
72667: PUSH
72668: LD_INT 12
72670: PUSH
72671: EMPTY
72672: LIST
72673: LIST
72674: ST_TO_ADDR
// hc_agressivity := 20 ;
72675: LD_ADDR_OWVAR 35
72679: PUSH
72680: LD_INT 20
72682: ST_TO_ADDR
// hc_class := class_tiger ;
72683: LD_ADDR_OWVAR 28
72687: PUSH
72688: LD_INT 14
72690: ST_TO_ADDR
// hc_gallery :=  ;
72691: LD_ADDR_OWVAR 33
72695: PUSH
72696: LD_STRING 
72698: ST_TO_ADDR
// hc_name :=  ;
72699: LD_ADDR_OWVAR 26
72703: PUSH
72704: LD_STRING 
72706: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
72707: CALL_OW 44
72711: PPUSH
72712: LD_INT 0
72714: PPUSH
72715: CALL_OW 51
// end ;
72719: GO 72641
72721: POP
72722: POP
// end ;
72723: PPOPN 1
72725: END
// every 0 0$1 trigger StreamModeActive and sBomb do
72726: LD_EXP 98
72730: PUSH
72731: LD_EXP 118
72735: AND
72736: IFFALSE 72745
72738: GO 72740
72740: DISABLE
// StreamSibBomb ;
72741: CALL 72746 0 0
72745: END
// export function StreamSibBomb ; var i , x , y ; begin
72746: LD_INT 0
72748: PPUSH
72749: PPUSH
72750: PPUSH
72751: PPUSH
// result := false ;
72752: LD_ADDR_VAR 0 1
72756: PUSH
72757: LD_INT 0
72759: ST_TO_ADDR
// for i := 1 to 16 do
72760: LD_ADDR_VAR 0 2
72764: PUSH
72765: DOUBLE
72766: LD_INT 1
72768: DEC
72769: ST_TO_ADDR
72770: LD_INT 16
72772: PUSH
72773: FOR_TO
72774: IFFALSE 72973
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
72776: LD_ADDR_VAR 0 3
72780: PUSH
72781: LD_INT 10
72783: PUSH
72784: LD_INT 20
72786: PUSH
72787: LD_INT 30
72789: PUSH
72790: LD_INT 40
72792: PUSH
72793: LD_INT 50
72795: PUSH
72796: LD_INT 60
72798: PUSH
72799: LD_INT 70
72801: PUSH
72802: LD_INT 80
72804: PUSH
72805: LD_INT 90
72807: PUSH
72808: LD_INT 100
72810: PUSH
72811: LD_INT 110
72813: PUSH
72814: LD_INT 120
72816: PUSH
72817: LD_INT 130
72819: PUSH
72820: LD_INT 140
72822: PUSH
72823: LD_INT 150
72825: PUSH
72826: EMPTY
72827: LIST
72828: LIST
72829: LIST
72830: LIST
72831: LIST
72832: LIST
72833: LIST
72834: LIST
72835: LIST
72836: LIST
72837: LIST
72838: LIST
72839: LIST
72840: LIST
72841: LIST
72842: PUSH
72843: LD_INT 1
72845: PPUSH
72846: LD_INT 15
72848: PPUSH
72849: CALL_OW 12
72853: ARRAY
72854: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
72855: LD_ADDR_VAR 0 4
72859: PUSH
72860: LD_INT 10
72862: PUSH
72863: LD_INT 20
72865: PUSH
72866: LD_INT 30
72868: PUSH
72869: LD_INT 40
72871: PUSH
72872: LD_INT 50
72874: PUSH
72875: LD_INT 60
72877: PUSH
72878: LD_INT 70
72880: PUSH
72881: LD_INT 80
72883: PUSH
72884: LD_INT 90
72886: PUSH
72887: LD_INT 100
72889: PUSH
72890: LD_INT 110
72892: PUSH
72893: LD_INT 120
72895: PUSH
72896: LD_INT 130
72898: PUSH
72899: LD_INT 140
72901: PUSH
72902: LD_INT 150
72904: PUSH
72905: EMPTY
72906: LIST
72907: LIST
72908: LIST
72909: LIST
72910: LIST
72911: LIST
72912: LIST
72913: LIST
72914: LIST
72915: LIST
72916: LIST
72917: LIST
72918: LIST
72919: LIST
72920: LIST
72921: PUSH
72922: LD_INT 1
72924: PPUSH
72925: LD_INT 15
72927: PPUSH
72928: CALL_OW 12
72932: ARRAY
72933: ST_TO_ADDR
// if ValidHex ( x , y ) then
72934: LD_VAR 0 3
72938: PPUSH
72939: LD_VAR 0 4
72943: PPUSH
72944: CALL_OW 488
72948: IFFALSE 72971
// begin result := [ x , y ] ;
72950: LD_ADDR_VAR 0 1
72954: PUSH
72955: LD_VAR 0 3
72959: PUSH
72960: LD_VAR 0 4
72964: PUSH
72965: EMPTY
72966: LIST
72967: LIST
72968: ST_TO_ADDR
// break ;
72969: GO 72973
// end ; end ;
72971: GO 72773
72973: POP
72974: POP
// if result then
72975: LD_VAR 0 1
72979: IFFALSE 73039
// begin ToLua ( playSibBomb() ) ;
72981: LD_STRING playSibBomb()
72983: PPUSH
72984: CALL_OW 559
// wait ( 0 0$14 ) ;
72988: LD_INT 490
72990: PPUSH
72991: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
72995: LD_VAR 0 1
72999: PUSH
73000: LD_INT 1
73002: ARRAY
73003: PPUSH
73004: LD_VAR 0 1
73008: PUSH
73009: LD_INT 2
73011: ARRAY
73012: PPUSH
73013: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
73017: LD_VAR 0 1
73021: PUSH
73022: LD_INT 1
73024: ARRAY
73025: PPUSH
73026: LD_VAR 0 1
73030: PUSH
73031: LD_INT 2
73033: ARRAY
73034: PPUSH
73035: CALL_OW 429
// end ; end ;
73039: LD_VAR 0 1
73043: RET
// every 0 0$1 trigger StreamModeActive and sReset do
73044: LD_EXP 98
73048: PUSH
73049: LD_EXP 120
73053: AND
73054: IFFALSE 73066
73056: GO 73058
73058: DISABLE
// YouLost (  ) ;
73059: LD_STRING 
73061: PPUSH
73062: CALL_OW 104
73066: END
// every 0 0$1 trigger StreamModeActive and sFog do
73067: LD_EXP 98
73071: PUSH
73072: LD_EXP 119
73076: AND
73077: IFFALSE 73091
73079: GO 73081
73081: DISABLE
// FogOff ( your_side ) ;
73082: LD_OWVAR 2
73086: PPUSH
73087: CALL_OW 344
73091: END
// every 0 0$1 trigger StreamModeActive and sSun do
73092: LD_EXP 98
73096: PUSH
73097: LD_EXP 121
73101: AND
73102: IFFALSE 73130
73104: GO 73106
73106: DISABLE
// begin solar_recharge_percent := 0 ;
73107: LD_ADDR_OWVAR 79
73111: PUSH
73112: LD_INT 0
73114: ST_TO_ADDR
// wait ( 5 5$00 ) ;
73115: LD_INT 10500
73117: PPUSH
73118: CALL_OW 67
// solar_recharge_percent := 100 ;
73122: LD_ADDR_OWVAR 79
73126: PUSH
73127: LD_INT 100
73129: ST_TO_ADDR
// end ;
73130: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
73131: LD_EXP 98
73135: PUSH
73136: LD_EXP 122
73140: AND
73141: IFFALSE 73380
73143: GO 73145
73145: DISABLE
73146: LD_INT 0
73148: PPUSH
73149: PPUSH
73150: PPUSH
// begin tmp := [ ] ;
73151: LD_ADDR_VAR 0 3
73155: PUSH
73156: EMPTY
73157: ST_TO_ADDR
// for i := 1 to 6 do
73158: LD_ADDR_VAR 0 1
73162: PUSH
73163: DOUBLE
73164: LD_INT 1
73166: DEC
73167: ST_TO_ADDR
73168: LD_INT 6
73170: PUSH
73171: FOR_TO
73172: IFFALSE 73277
// begin uc_nation := nation_nature ;
73174: LD_ADDR_OWVAR 21
73178: PUSH
73179: LD_INT 0
73181: ST_TO_ADDR
// uc_side := 0 ;
73182: LD_ADDR_OWVAR 20
73186: PUSH
73187: LD_INT 0
73189: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
73190: LD_ADDR_OWVAR 29
73194: PUSH
73195: LD_INT 12
73197: PUSH
73198: LD_INT 12
73200: PUSH
73201: EMPTY
73202: LIST
73203: LIST
73204: ST_TO_ADDR
// hc_agressivity := 20 ;
73205: LD_ADDR_OWVAR 35
73209: PUSH
73210: LD_INT 20
73212: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
73213: LD_ADDR_OWVAR 28
73217: PUSH
73218: LD_INT 17
73220: ST_TO_ADDR
// hc_gallery :=  ;
73221: LD_ADDR_OWVAR 33
73225: PUSH
73226: LD_STRING 
73228: ST_TO_ADDR
// hc_name :=  ;
73229: LD_ADDR_OWVAR 26
73233: PUSH
73234: LD_STRING 
73236: ST_TO_ADDR
// un := CreateHuman ;
73237: LD_ADDR_VAR 0 2
73241: PUSH
73242: CALL_OW 44
73246: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
73247: LD_VAR 0 2
73251: PPUSH
73252: LD_INT 1
73254: PPUSH
73255: CALL_OW 51
// tmp := tmp ^ un ;
73259: LD_ADDR_VAR 0 3
73263: PUSH
73264: LD_VAR 0 3
73268: PUSH
73269: LD_VAR 0 2
73273: ADD
73274: ST_TO_ADDR
// end ;
73275: GO 73171
73277: POP
73278: POP
// repeat wait ( 0 0$1 ) ;
73279: LD_INT 35
73281: PPUSH
73282: CALL_OW 67
// for un in tmp do
73286: LD_ADDR_VAR 0 2
73290: PUSH
73291: LD_VAR 0 3
73295: PUSH
73296: FOR_IN
73297: IFFALSE 73371
// begin if IsDead ( un ) then
73299: LD_VAR 0 2
73303: PPUSH
73304: CALL_OW 301
73308: IFFALSE 73328
// begin tmp := tmp diff un ;
73310: LD_ADDR_VAR 0 3
73314: PUSH
73315: LD_VAR 0 3
73319: PUSH
73320: LD_VAR 0 2
73324: DIFF
73325: ST_TO_ADDR
// continue ;
73326: GO 73296
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
73328: LD_VAR 0 2
73332: PPUSH
73333: LD_INT 3
73335: PUSH
73336: LD_INT 22
73338: PUSH
73339: LD_INT 0
73341: PUSH
73342: EMPTY
73343: LIST
73344: LIST
73345: PUSH
73346: EMPTY
73347: LIST
73348: LIST
73349: PPUSH
73350: CALL_OW 69
73354: PPUSH
73355: LD_VAR 0 2
73359: PPUSH
73360: CALL_OW 74
73364: PPUSH
73365: CALL_OW 115
// end ;
73369: GO 73296
73371: POP
73372: POP
// until not tmp ;
73373: LD_VAR 0 3
73377: NOT
73378: IFFALSE 73279
// end ;
73380: PPOPN 3
73382: END
// every 0 0$1 trigger StreamModeActive and sTroll do
73383: LD_EXP 98
73387: PUSH
73388: LD_EXP 123
73392: AND
73393: IFFALSE 73447
73395: GO 73397
73397: DISABLE
// begin ToLua ( displayTroll(); ) ;
73398: LD_STRING displayTroll();
73400: PPUSH
73401: CALL_OW 559
// wait ( 3 3$00 ) ;
73405: LD_INT 6300
73407: PPUSH
73408: CALL_OW 67
// ToLua ( hideTroll(); ) ;
73412: LD_STRING hideTroll();
73414: PPUSH
73415: CALL_OW 559
// wait ( 1 1$00 ) ;
73419: LD_INT 2100
73421: PPUSH
73422: CALL_OW 67
// ToLua ( displayTroll(); ) ;
73426: LD_STRING displayTroll();
73428: PPUSH
73429: CALL_OW 559
// wait ( 1 1$00 ) ;
73433: LD_INT 2100
73435: PPUSH
73436: CALL_OW 67
// ToLua ( hideTroll(); ) ;
73440: LD_STRING hideTroll();
73442: PPUSH
73443: CALL_OW 559
// end ;
73447: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
73448: LD_EXP 98
73452: PUSH
73453: LD_EXP 124
73457: AND
73458: IFFALSE 73521
73460: GO 73462
73462: DISABLE
73463: LD_INT 0
73465: PPUSH
// begin p := 0 ;
73466: LD_ADDR_VAR 0 1
73470: PUSH
73471: LD_INT 0
73473: ST_TO_ADDR
// repeat game_speed := 1 ;
73474: LD_ADDR_OWVAR 65
73478: PUSH
73479: LD_INT 1
73481: ST_TO_ADDR
// wait ( 0 0$1 ) ;
73482: LD_INT 35
73484: PPUSH
73485: CALL_OW 67
// p := p + 1 ;
73489: LD_ADDR_VAR 0 1
73493: PUSH
73494: LD_VAR 0 1
73498: PUSH
73499: LD_INT 1
73501: PLUS
73502: ST_TO_ADDR
// until p >= 60 ;
73503: LD_VAR 0 1
73507: PUSH
73508: LD_INT 60
73510: GREATEREQUAL
73511: IFFALSE 73474
// game_speed := 4 ;
73513: LD_ADDR_OWVAR 65
73517: PUSH
73518: LD_INT 4
73520: ST_TO_ADDR
// end ;
73521: PPOPN 1
73523: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
73524: LD_EXP 98
73528: PUSH
73529: LD_EXP 125
73533: AND
73534: IFFALSE 73680
73536: GO 73538
73538: DISABLE
73539: LD_INT 0
73541: PPUSH
73542: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
73543: LD_ADDR_VAR 0 1
73547: PUSH
73548: LD_INT 22
73550: PUSH
73551: LD_OWVAR 2
73555: PUSH
73556: EMPTY
73557: LIST
73558: LIST
73559: PUSH
73560: LD_INT 2
73562: PUSH
73563: LD_INT 30
73565: PUSH
73566: LD_INT 0
73568: PUSH
73569: EMPTY
73570: LIST
73571: LIST
73572: PUSH
73573: LD_INT 30
73575: PUSH
73576: LD_INT 1
73578: PUSH
73579: EMPTY
73580: LIST
73581: LIST
73582: PUSH
73583: EMPTY
73584: LIST
73585: LIST
73586: LIST
73587: PUSH
73588: EMPTY
73589: LIST
73590: LIST
73591: PPUSH
73592: CALL_OW 69
73596: ST_TO_ADDR
// if not depot then
73597: LD_VAR 0 1
73601: NOT
73602: IFFALSE 73606
// exit ;
73604: GO 73680
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
73606: LD_ADDR_VAR 0 2
73610: PUSH
73611: LD_VAR 0 1
73615: PUSH
73616: LD_INT 1
73618: PPUSH
73619: LD_VAR 0 1
73623: PPUSH
73624: CALL_OW 12
73628: ARRAY
73629: PPUSH
73630: CALL_OW 274
73634: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
73635: LD_VAR 0 2
73639: PPUSH
73640: LD_INT 1
73642: PPUSH
73643: LD_INT 0
73645: PPUSH
73646: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
73650: LD_VAR 0 2
73654: PPUSH
73655: LD_INT 2
73657: PPUSH
73658: LD_INT 0
73660: PPUSH
73661: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
73665: LD_VAR 0 2
73669: PPUSH
73670: LD_INT 3
73672: PPUSH
73673: LD_INT 0
73675: PPUSH
73676: CALL_OW 277
// end ;
73680: PPOPN 2
73682: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
73683: LD_EXP 98
73687: PUSH
73688: LD_EXP 126
73692: AND
73693: IFFALSE 73790
73695: GO 73697
73697: DISABLE
73698: LD_INT 0
73700: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
73701: LD_ADDR_VAR 0 1
73705: PUSH
73706: LD_INT 22
73708: PUSH
73709: LD_OWVAR 2
73713: PUSH
73714: EMPTY
73715: LIST
73716: LIST
73717: PUSH
73718: LD_INT 21
73720: PUSH
73721: LD_INT 1
73723: PUSH
73724: EMPTY
73725: LIST
73726: LIST
73727: PUSH
73728: LD_INT 3
73730: PUSH
73731: LD_INT 23
73733: PUSH
73734: LD_INT 0
73736: PUSH
73737: EMPTY
73738: LIST
73739: LIST
73740: PUSH
73741: EMPTY
73742: LIST
73743: LIST
73744: PUSH
73745: EMPTY
73746: LIST
73747: LIST
73748: LIST
73749: PPUSH
73750: CALL_OW 69
73754: ST_TO_ADDR
// if not tmp then
73755: LD_VAR 0 1
73759: NOT
73760: IFFALSE 73764
// exit ;
73762: GO 73790
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
73764: LD_VAR 0 1
73768: PUSH
73769: LD_INT 1
73771: PPUSH
73772: LD_VAR 0 1
73776: PPUSH
73777: CALL_OW 12
73781: ARRAY
73782: PPUSH
73783: LD_INT 200
73785: PPUSH
73786: CALL_OW 234
// end ;
73790: PPOPN 1
73792: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
73793: LD_EXP 98
73797: PUSH
73798: LD_EXP 127
73802: AND
73803: IFFALSE 73882
73805: GO 73807
73807: DISABLE
73808: LD_INT 0
73810: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
73811: LD_ADDR_VAR 0 1
73815: PUSH
73816: LD_INT 22
73818: PUSH
73819: LD_OWVAR 2
73823: PUSH
73824: EMPTY
73825: LIST
73826: LIST
73827: PUSH
73828: LD_INT 21
73830: PUSH
73831: LD_INT 2
73833: PUSH
73834: EMPTY
73835: LIST
73836: LIST
73837: PUSH
73838: EMPTY
73839: LIST
73840: LIST
73841: PPUSH
73842: CALL_OW 69
73846: ST_TO_ADDR
// if not tmp then
73847: LD_VAR 0 1
73851: NOT
73852: IFFALSE 73856
// exit ;
73854: GO 73882
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
73856: LD_VAR 0 1
73860: PUSH
73861: LD_INT 1
73863: PPUSH
73864: LD_VAR 0 1
73868: PPUSH
73869: CALL_OW 12
73873: ARRAY
73874: PPUSH
73875: LD_INT 60
73877: PPUSH
73878: CALL_OW 234
// end ;
73882: PPOPN 1
73884: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
73885: LD_EXP 98
73889: PUSH
73890: LD_EXP 128
73894: AND
73895: IFFALSE 73994
73897: GO 73899
73899: DISABLE
73900: LD_INT 0
73902: PPUSH
73903: PPUSH
// begin enable ;
73904: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
73905: LD_ADDR_VAR 0 1
73909: PUSH
73910: LD_INT 22
73912: PUSH
73913: LD_OWVAR 2
73917: PUSH
73918: EMPTY
73919: LIST
73920: LIST
73921: PUSH
73922: LD_INT 61
73924: PUSH
73925: EMPTY
73926: LIST
73927: PUSH
73928: LD_INT 33
73930: PUSH
73931: LD_INT 2
73933: PUSH
73934: EMPTY
73935: LIST
73936: LIST
73937: PUSH
73938: EMPTY
73939: LIST
73940: LIST
73941: LIST
73942: PPUSH
73943: CALL_OW 69
73947: ST_TO_ADDR
// if not tmp then
73948: LD_VAR 0 1
73952: NOT
73953: IFFALSE 73957
// exit ;
73955: GO 73994
// for i in tmp do
73957: LD_ADDR_VAR 0 2
73961: PUSH
73962: LD_VAR 0 1
73966: PUSH
73967: FOR_IN
73968: IFFALSE 73992
// if IsControledBy ( i ) then
73970: LD_VAR 0 2
73974: PPUSH
73975: CALL_OW 312
73979: IFFALSE 73990
// ComUnlink ( i ) ;
73981: LD_VAR 0 2
73985: PPUSH
73986: CALL_OW 136
73990: GO 73967
73992: POP
73993: POP
// end ;
73994: PPOPN 2
73996: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
73997: LD_EXP 98
74001: PUSH
74002: LD_EXP 129
74006: AND
74007: IFFALSE 74147
74009: GO 74011
74011: DISABLE
74012: LD_INT 0
74014: PPUSH
74015: PPUSH
// begin ToLua ( displayPowell(); ) ;
74016: LD_STRING displayPowell();
74018: PPUSH
74019: CALL_OW 559
// uc_side := 0 ;
74023: LD_ADDR_OWVAR 20
74027: PUSH
74028: LD_INT 0
74030: ST_TO_ADDR
// uc_nation := 2 ;
74031: LD_ADDR_OWVAR 21
74035: PUSH
74036: LD_INT 2
74038: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
74039: LD_ADDR_OWVAR 37
74043: PUSH
74044: LD_INT 14
74046: ST_TO_ADDR
// vc_engine := engine_siberite ;
74047: LD_ADDR_OWVAR 39
74051: PUSH
74052: LD_INT 3
74054: ST_TO_ADDR
// vc_control := control_apeman ;
74055: LD_ADDR_OWVAR 38
74059: PUSH
74060: LD_INT 5
74062: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
74063: LD_ADDR_OWVAR 40
74067: PUSH
74068: LD_INT 29
74070: ST_TO_ADDR
// un := CreateVehicle ;
74071: LD_ADDR_VAR 0 2
74075: PUSH
74076: CALL_OW 45
74080: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
74081: LD_VAR 0 2
74085: PPUSH
74086: LD_INT 1
74088: PPUSH
74089: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
74093: LD_INT 35
74095: PPUSH
74096: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
74100: LD_VAR 0 2
74104: PPUSH
74105: LD_INT 22
74107: PUSH
74108: LD_OWVAR 2
74112: PUSH
74113: EMPTY
74114: LIST
74115: LIST
74116: PPUSH
74117: CALL_OW 69
74121: PPUSH
74122: LD_VAR 0 2
74126: PPUSH
74127: CALL_OW 74
74131: PPUSH
74132: CALL_OW 115
// until IsDead ( un ) ;
74136: LD_VAR 0 2
74140: PPUSH
74141: CALL_OW 301
74145: IFFALSE 74093
// end ;
74147: PPOPN 2
74149: END
// every 0 0$1 trigger StreamModeActive and sStu do
74150: LD_EXP 98
74154: PUSH
74155: LD_EXP 137
74159: AND
74160: IFFALSE 74176
74162: GO 74164
74164: DISABLE
// begin ToLua ( displayStucuk(); ) ;
74165: LD_STRING displayStucuk();
74167: PPUSH
74168: CALL_OW 559
// ResetFog ;
74172: CALL_OW 335
// end ;
74176: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
74177: LD_EXP 98
74181: PUSH
74182: LD_EXP 130
74186: AND
74187: IFFALSE 74328
74189: GO 74191
74191: DISABLE
74192: LD_INT 0
74194: PPUSH
74195: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
74196: LD_ADDR_VAR 0 2
74200: PUSH
74201: LD_INT 22
74203: PUSH
74204: LD_OWVAR 2
74208: PUSH
74209: EMPTY
74210: LIST
74211: LIST
74212: PUSH
74213: LD_INT 21
74215: PUSH
74216: LD_INT 1
74218: PUSH
74219: EMPTY
74220: LIST
74221: LIST
74222: PUSH
74223: EMPTY
74224: LIST
74225: LIST
74226: PPUSH
74227: CALL_OW 69
74231: ST_TO_ADDR
// if not tmp then
74232: LD_VAR 0 2
74236: NOT
74237: IFFALSE 74241
// exit ;
74239: GO 74328
// un := tmp [ rand ( 1 , tmp ) ] ;
74241: LD_ADDR_VAR 0 1
74245: PUSH
74246: LD_VAR 0 2
74250: PUSH
74251: LD_INT 1
74253: PPUSH
74254: LD_VAR 0 2
74258: PPUSH
74259: CALL_OW 12
74263: ARRAY
74264: ST_TO_ADDR
// SetSide ( un , 0 ) ;
74265: LD_VAR 0 1
74269: PPUSH
74270: LD_INT 0
74272: PPUSH
74273: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
74277: LD_VAR 0 1
74281: PPUSH
74282: LD_OWVAR 3
74286: PUSH
74287: LD_VAR 0 1
74291: DIFF
74292: PPUSH
74293: LD_VAR 0 1
74297: PPUSH
74298: CALL_OW 74
74302: PPUSH
74303: CALL_OW 115
// wait ( 0 0$20 ) ;
74307: LD_INT 700
74309: PPUSH
74310: CALL_OW 67
// SetSide ( un , your_side ) ;
74314: LD_VAR 0 1
74318: PPUSH
74319: LD_OWVAR 2
74323: PPUSH
74324: CALL_OW 235
// end ;
74328: PPOPN 2
74330: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
74331: LD_EXP 98
74335: PUSH
74336: LD_EXP 131
74340: AND
74341: IFFALSE 74447
74343: GO 74345
74345: DISABLE
74346: LD_INT 0
74348: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
74349: LD_ADDR_VAR 0 1
74353: PUSH
74354: LD_INT 22
74356: PUSH
74357: LD_OWVAR 2
74361: PUSH
74362: EMPTY
74363: LIST
74364: LIST
74365: PUSH
74366: LD_INT 2
74368: PUSH
74369: LD_INT 30
74371: PUSH
74372: LD_INT 0
74374: PUSH
74375: EMPTY
74376: LIST
74377: LIST
74378: PUSH
74379: LD_INT 30
74381: PUSH
74382: LD_INT 1
74384: PUSH
74385: EMPTY
74386: LIST
74387: LIST
74388: PUSH
74389: EMPTY
74390: LIST
74391: LIST
74392: LIST
74393: PUSH
74394: EMPTY
74395: LIST
74396: LIST
74397: PPUSH
74398: CALL_OW 69
74402: ST_TO_ADDR
// if not depot then
74403: LD_VAR 0 1
74407: NOT
74408: IFFALSE 74412
// exit ;
74410: GO 74447
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
74412: LD_VAR 0 1
74416: PUSH
74417: LD_INT 1
74419: ARRAY
74420: PPUSH
74421: CALL_OW 250
74425: PPUSH
74426: LD_VAR 0 1
74430: PUSH
74431: LD_INT 1
74433: ARRAY
74434: PPUSH
74435: CALL_OW 251
74439: PPUSH
74440: LD_INT 70
74442: PPUSH
74443: CALL_OW 495
// end ;
74447: PPOPN 1
74449: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
74450: LD_EXP 98
74454: PUSH
74455: LD_EXP 132
74459: AND
74460: IFFALSE 74671
74462: GO 74464
74464: DISABLE
74465: LD_INT 0
74467: PPUSH
74468: PPUSH
74469: PPUSH
74470: PPUSH
74471: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
74472: LD_ADDR_VAR 0 5
74476: PUSH
74477: LD_INT 22
74479: PUSH
74480: LD_OWVAR 2
74484: PUSH
74485: EMPTY
74486: LIST
74487: LIST
74488: PUSH
74489: LD_INT 21
74491: PUSH
74492: LD_INT 1
74494: PUSH
74495: EMPTY
74496: LIST
74497: LIST
74498: PUSH
74499: EMPTY
74500: LIST
74501: LIST
74502: PPUSH
74503: CALL_OW 69
74507: ST_TO_ADDR
// if not tmp then
74508: LD_VAR 0 5
74512: NOT
74513: IFFALSE 74517
// exit ;
74515: GO 74671
// for i in tmp do
74517: LD_ADDR_VAR 0 1
74521: PUSH
74522: LD_VAR 0 5
74526: PUSH
74527: FOR_IN
74528: IFFALSE 74669
// begin d := rand ( 0 , 5 ) ;
74530: LD_ADDR_VAR 0 4
74534: PUSH
74535: LD_INT 0
74537: PPUSH
74538: LD_INT 5
74540: PPUSH
74541: CALL_OW 12
74545: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
74546: LD_ADDR_VAR 0 2
74550: PUSH
74551: LD_VAR 0 1
74555: PPUSH
74556: CALL_OW 250
74560: PPUSH
74561: LD_VAR 0 4
74565: PPUSH
74566: LD_INT 3
74568: PPUSH
74569: LD_INT 12
74571: PPUSH
74572: CALL_OW 12
74576: PPUSH
74577: CALL_OW 272
74581: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
74582: LD_ADDR_VAR 0 3
74586: PUSH
74587: LD_VAR 0 1
74591: PPUSH
74592: CALL_OW 251
74596: PPUSH
74597: LD_VAR 0 4
74601: PPUSH
74602: LD_INT 3
74604: PPUSH
74605: LD_INT 12
74607: PPUSH
74608: CALL_OW 12
74612: PPUSH
74613: CALL_OW 273
74617: ST_TO_ADDR
// if ValidHex ( x , y ) then
74618: LD_VAR 0 2
74622: PPUSH
74623: LD_VAR 0 3
74627: PPUSH
74628: CALL_OW 488
74632: IFFALSE 74667
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
74634: LD_VAR 0 1
74638: PPUSH
74639: LD_VAR 0 2
74643: PPUSH
74644: LD_VAR 0 3
74648: PPUSH
74649: LD_INT 3
74651: PPUSH
74652: LD_INT 6
74654: PPUSH
74655: CALL_OW 12
74659: PPUSH
74660: LD_INT 1
74662: PPUSH
74663: CALL_OW 483
// end ;
74667: GO 74527
74669: POP
74670: POP
// end ;
74671: PPOPN 5
74673: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
74674: LD_EXP 98
74678: PUSH
74679: LD_EXP 133
74683: AND
74684: IFFALSE 74778
74686: GO 74688
74688: DISABLE
74689: LD_INT 0
74691: PPUSH
74692: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
74693: LD_ADDR_VAR 0 2
74697: PUSH
74698: LD_INT 22
74700: PUSH
74701: LD_OWVAR 2
74705: PUSH
74706: EMPTY
74707: LIST
74708: LIST
74709: PUSH
74710: LD_INT 32
74712: PUSH
74713: LD_INT 1
74715: PUSH
74716: EMPTY
74717: LIST
74718: LIST
74719: PUSH
74720: LD_INT 21
74722: PUSH
74723: LD_INT 2
74725: PUSH
74726: EMPTY
74727: LIST
74728: LIST
74729: PUSH
74730: EMPTY
74731: LIST
74732: LIST
74733: LIST
74734: PPUSH
74735: CALL_OW 69
74739: ST_TO_ADDR
// if not tmp then
74740: LD_VAR 0 2
74744: NOT
74745: IFFALSE 74749
// exit ;
74747: GO 74778
// for i in tmp do
74749: LD_ADDR_VAR 0 1
74753: PUSH
74754: LD_VAR 0 2
74758: PUSH
74759: FOR_IN
74760: IFFALSE 74776
// SetFuel ( i , 0 ) ;
74762: LD_VAR 0 1
74766: PPUSH
74767: LD_INT 0
74769: PPUSH
74770: CALL_OW 240
74774: GO 74759
74776: POP
74777: POP
// end ;
74778: PPOPN 2
74780: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
74781: LD_EXP 98
74785: PUSH
74786: LD_EXP 134
74790: AND
74791: IFFALSE 74857
74793: GO 74795
74795: DISABLE
74796: LD_INT 0
74798: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
74799: LD_ADDR_VAR 0 1
74803: PUSH
74804: LD_INT 22
74806: PUSH
74807: LD_OWVAR 2
74811: PUSH
74812: EMPTY
74813: LIST
74814: LIST
74815: PUSH
74816: LD_INT 30
74818: PUSH
74819: LD_INT 29
74821: PUSH
74822: EMPTY
74823: LIST
74824: LIST
74825: PUSH
74826: EMPTY
74827: LIST
74828: LIST
74829: PPUSH
74830: CALL_OW 69
74834: ST_TO_ADDR
// if not tmp then
74835: LD_VAR 0 1
74839: NOT
74840: IFFALSE 74844
// exit ;
74842: GO 74857
// DestroyUnit ( tmp [ 1 ] ) ;
74844: LD_VAR 0 1
74848: PUSH
74849: LD_INT 1
74851: ARRAY
74852: PPUSH
74853: CALL_OW 65
// end ;
74857: PPOPN 1
74859: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
74860: LD_EXP 98
74864: PUSH
74865: LD_EXP 136
74869: AND
74870: IFFALSE 74999
74872: GO 74874
74874: DISABLE
74875: LD_INT 0
74877: PPUSH
// begin uc_side := 0 ;
74878: LD_ADDR_OWVAR 20
74882: PUSH
74883: LD_INT 0
74885: ST_TO_ADDR
// uc_nation := nation_arabian ;
74886: LD_ADDR_OWVAR 21
74890: PUSH
74891: LD_INT 2
74893: ST_TO_ADDR
// hc_gallery :=  ;
74894: LD_ADDR_OWVAR 33
74898: PUSH
74899: LD_STRING 
74901: ST_TO_ADDR
// hc_name :=  ;
74902: LD_ADDR_OWVAR 26
74906: PUSH
74907: LD_STRING 
74909: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
74910: LD_INT 1
74912: PPUSH
74913: LD_INT 11
74915: PPUSH
74916: LD_INT 10
74918: PPUSH
74919: CALL_OW 380
// un := CreateHuman ;
74923: LD_ADDR_VAR 0 1
74927: PUSH
74928: CALL_OW 44
74932: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
74933: LD_VAR 0 1
74937: PPUSH
74938: LD_INT 1
74940: PPUSH
74941: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
74945: LD_INT 35
74947: PPUSH
74948: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
74952: LD_VAR 0 1
74956: PPUSH
74957: LD_INT 22
74959: PUSH
74960: LD_OWVAR 2
74964: PUSH
74965: EMPTY
74966: LIST
74967: LIST
74968: PPUSH
74969: CALL_OW 69
74973: PPUSH
74974: LD_VAR 0 1
74978: PPUSH
74979: CALL_OW 74
74983: PPUSH
74984: CALL_OW 115
// until IsDead ( un ) ;
74988: LD_VAR 0 1
74992: PPUSH
74993: CALL_OW 301
74997: IFFALSE 74945
// end ;
74999: PPOPN 1
75001: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
75002: LD_EXP 98
75006: PUSH
75007: LD_EXP 138
75011: AND
75012: IFFALSE 75024
75014: GO 75016
75016: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
75017: LD_STRING earthquake(getX(game), 0, 32)
75019: PPUSH
75020: CALL_OW 559
75024: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
75025: LD_EXP 98
75029: PUSH
75030: LD_EXP 139
75034: AND
75035: IFFALSE 75126
75037: GO 75039
75039: DISABLE
75040: LD_INT 0
75042: PPUSH
// begin enable ;
75043: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
75044: LD_ADDR_VAR 0 1
75048: PUSH
75049: LD_INT 22
75051: PUSH
75052: LD_OWVAR 2
75056: PUSH
75057: EMPTY
75058: LIST
75059: LIST
75060: PUSH
75061: LD_INT 21
75063: PUSH
75064: LD_INT 2
75066: PUSH
75067: EMPTY
75068: LIST
75069: LIST
75070: PUSH
75071: LD_INT 33
75073: PUSH
75074: LD_INT 3
75076: PUSH
75077: EMPTY
75078: LIST
75079: LIST
75080: PUSH
75081: EMPTY
75082: LIST
75083: LIST
75084: LIST
75085: PPUSH
75086: CALL_OW 69
75090: ST_TO_ADDR
// if not tmp then
75091: LD_VAR 0 1
75095: NOT
75096: IFFALSE 75100
// exit ;
75098: GO 75126
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
75100: LD_VAR 0 1
75104: PUSH
75105: LD_INT 1
75107: PPUSH
75108: LD_VAR 0 1
75112: PPUSH
75113: CALL_OW 12
75117: ARRAY
75118: PPUSH
75119: LD_INT 1
75121: PPUSH
75122: CALL_OW 234
// end ;
75126: PPOPN 1
75128: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
75129: LD_EXP 98
75133: PUSH
75134: LD_EXP 140
75138: AND
75139: IFFALSE 75280
75141: GO 75143
75143: DISABLE
75144: LD_INT 0
75146: PPUSH
75147: PPUSH
75148: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
75149: LD_ADDR_VAR 0 3
75153: PUSH
75154: LD_INT 22
75156: PUSH
75157: LD_OWVAR 2
75161: PUSH
75162: EMPTY
75163: LIST
75164: LIST
75165: PUSH
75166: LD_INT 25
75168: PUSH
75169: LD_INT 1
75171: PUSH
75172: EMPTY
75173: LIST
75174: LIST
75175: PUSH
75176: EMPTY
75177: LIST
75178: LIST
75179: PPUSH
75180: CALL_OW 69
75184: ST_TO_ADDR
// if not tmp then
75185: LD_VAR 0 3
75189: NOT
75190: IFFALSE 75194
// exit ;
75192: GO 75280
// un := tmp [ rand ( 1 , tmp ) ] ;
75194: LD_ADDR_VAR 0 2
75198: PUSH
75199: LD_VAR 0 3
75203: PUSH
75204: LD_INT 1
75206: PPUSH
75207: LD_VAR 0 3
75211: PPUSH
75212: CALL_OW 12
75216: ARRAY
75217: ST_TO_ADDR
// if Crawls ( un ) then
75218: LD_VAR 0 2
75222: PPUSH
75223: CALL_OW 318
75227: IFFALSE 75238
// ComWalk ( un ) ;
75229: LD_VAR 0 2
75233: PPUSH
75234: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
75238: LD_VAR 0 2
75242: PPUSH
75243: LD_INT 9
75245: PPUSH
75246: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
75250: LD_INT 28
75252: PPUSH
75253: LD_OWVAR 2
75257: PPUSH
75258: LD_INT 2
75260: PPUSH
75261: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
75265: LD_INT 29
75267: PPUSH
75268: LD_OWVAR 2
75272: PPUSH
75273: LD_INT 2
75275: PPUSH
75276: CALL_OW 322
// end ;
75280: PPOPN 3
75282: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
75283: LD_EXP 98
75287: PUSH
75288: LD_EXP 141
75292: AND
75293: IFFALSE 75404
75295: GO 75297
75297: DISABLE
75298: LD_INT 0
75300: PPUSH
75301: PPUSH
75302: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
75303: LD_ADDR_VAR 0 3
75307: PUSH
75308: LD_INT 22
75310: PUSH
75311: LD_OWVAR 2
75315: PUSH
75316: EMPTY
75317: LIST
75318: LIST
75319: PUSH
75320: LD_INT 25
75322: PUSH
75323: LD_INT 1
75325: PUSH
75326: EMPTY
75327: LIST
75328: LIST
75329: PUSH
75330: EMPTY
75331: LIST
75332: LIST
75333: PPUSH
75334: CALL_OW 69
75338: ST_TO_ADDR
// if not tmp then
75339: LD_VAR 0 3
75343: NOT
75344: IFFALSE 75348
// exit ;
75346: GO 75404
// un := tmp [ rand ( 1 , tmp ) ] ;
75348: LD_ADDR_VAR 0 2
75352: PUSH
75353: LD_VAR 0 3
75357: PUSH
75358: LD_INT 1
75360: PPUSH
75361: LD_VAR 0 3
75365: PPUSH
75366: CALL_OW 12
75370: ARRAY
75371: ST_TO_ADDR
// if Crawls ( un ) then
75372: LD_VAR 0 2
75376: PPUSH
75377: CALL_OW 318
75381: IFFALSE 75392
// ComWalk ( un ) ;
75383: LD_VAR 0 2
75387: PPUSH
75388: CALL_OW 138
// SetClass ( un , class_mortar ) ;
75392: LD_VAR 0 2
75396: PPUSH
75397: LD_INT 8
75399: PPUSH
75400: CALL_OW 336
// end ;
75404: PPOPN 3
75406: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
75407: LD_EXP 98
75411: PUSH
75412: LD_EXP 142
75416: AND
75417: IFFALSE 75561
75419: GO 75421
75421: DISABLE
75422: LD_INT 0
75424: PPUSH
75425: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
75426: LD_ADDR_VAR 0 2
75430: PUSH
75431: LD_INT 22
75433: PUSH
75434: LD_OWVAR 2
75438: PUSH
75439: EMPTY
75440: LIST
75441: LIST
75442: PUSH
75443: LD_INT 21
75445: PUSH
75446: LD_INT 2
75448: PUSH
75449: EMPTY
75450: LIST
75451: LIST
75452: PUSH
75453: LD_INT 2
75455: PUSH
75456: LD_INT 34
75458: PUSH
75459: LD_INT 12
75461: PUSH
75462: EMPTY
75463: LIST
75464: LIST
75465: PUSH
75466: LD_INT 34
75468: PUSH
75469: LD_INT 51
75471: PUSH
75472: EMPTY
75473: LIST
75474: LIST
75475: PUSH
75476: LD_INT 34
75478: PUSH
75479: LD_INT 32
75481: PUSH
75482: EMPTY
75483: LIST
75484: LIST
75485: PUSH
75486: EMPTY
75487: LIST
75488: LIST
75489: LIST
75490: LIST
75491: PUSH
75492: EMPTY
75493: LIST
75494: LIST
75495: LIST
75496: PPUSH
75497: CALL_OW 69
75501: ST_TO_ADDR
// if not tmp then
75502: LD_VAR 0 2
75506: NOT
75507: IFFALSE 75511
// exit ;
75509: GO 75561
// for i in tmp do
75511: LD_ADDR_VAR 0 1
75515: PUSH
75516: LD_VAR 0 2
75520: PUSH
75521: FOR_IN
75522: IFFALSE 75559
// if GetCargo ( i , mat_artifact ) = 0 then
75524: LD_VAR 0 1
75528: PPUSH
75529: LD_INT 4
75531: PPUSH
75532: CALL_OW 289
75536: PUSH
75537: LD_INT 0
75539: EQUAL
75540: IFFALSE 75557
// SetCargo ( i , mat_siberit , 100 ) ;
75542: LD_VAR 0 1
75546: PPUSH
75547: LD_INT 3
75549: PPUSH
75550: LD_INT 100
75552: PPUSH
75553: CALL_OW 290
75557: GO 75521
75559: POP
75560: POP
// end ;
75561: PPOPN 2
75563: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
75564: LD_EXP 98
75568: PUSH
75569: LD_EXP 143
75573: AND
75574: IFFALSE 75757
75576: GO 75578
75578: DISABLE
75579: LD_INT 0
75581: PPUSH
75582: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
75583: LD_ADDR_VAR 0 2
75587: PUSH
75588: LD_INT 22
75590: PUSH
75591: LD_OWVAR 2
75595: PUSH
75596: EMPTY
75597: LIST
75598: LIST
75599: PPUSH
75600: CALL_OW 69
75604: ST_TO_ADDR
// if not tmp then
75605: LD_VAR 0 2
75609: NOT
75610: IFFALSE 75614
// exit ;
75612: GO 75757
// for i := 1 to 2 do
75614: LD_ADDR_VAR 0 1
75618: PUSH
75619: DOUBLE
75620: LD_INT 1
75622: DEC
75623: ST_TO_ADDR
75624: LD_INT 2
75626: PUSH
75627: FOR_TO
75628: IFFALSE 75755
// begin uc_side := your_side ;
75630: LD_ADDR_OWVAR 20
75634: PUSH
75635: LD_OWVAR 2
75639: ST_TO_ADDR
// uc_nation := nation_american ;
75640: LD_ADDR_OWVAR 21
75644: PUSH
75645: LD_INT 1
75647: ST_TO_ADDR
// vc_chassis := us_morphling ;
75648: LD_ADDR_OWVAR 37
75652: PUSH
75653: LD_INT 5
75655: ST_TO_ADDR
// vc_engine := engine_siberite ;
75656: LD_ADDR_OWVAR 39
75660: PUSH
75661: LD_INT 3
75663: ST_TO_ADDR
// vc_control := control_computer ;
75664: LD_ADDR_OWVAR 38
75668: PUSH
75669: LD_INT 3
75671: ST_TO_ADDR
// vc_weapon := us_double_laser ;
75672: LD_ADDR_OWVAR 40
75676: PUSH
75677: LD_INT 10
75679: ST_TO_ADDR
// if not IsInUnit ( tmp [ 1 ] ) then
75680: LD_VAR 0 2
75684: PUSH
75685: LD_INT 1
75687: ARRAY
75688: PPUSH
75689: CALL_OW 310
75693: NOT
75694: IFFALSE 75741
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) else
75696: CALL_OW 45
75700: PPUSH
75701: LD_VAR 0 2
75705: PUSH
75706: LD_INT 1
75708: ARRAY
75709: PPUSH
75710: CALL_OW 250
75714: PPUSH
75715: LD_VAR 0 2
75719: PUSH
75720: LD_INT 1
75722: ARRAY
75723: PPUSH
75724: CALL_OW 251
75728: PPUSH
75729: LD_INT 12
75731: PPUSH
75732: LD_INT 1
75734: PPUSH
75735: CALL_OW 50
75739: GO 75753
// PlaceUnitAnywhere ( CreateVehicle , true ) ;
75741: CALL_OW 45
75745: PPUSH
75746: LD_INT 1
75748: PPUSH
75749: CALL_OW 51
// end ;
75753: GO 75627
75755: POP
75756: POP
// end ;
75757: PPOPN 2
75759: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
75760: LD_EXP 98
75764: PUSH
75765: LD_EXP 144
75769: AND
75770: IFFALSE 75992
75772: GO 75774
75774: DISABLE
75775: LD_INT 0
75777: PPUSH
75778: PPUSH
75779: PPUSH
75780: PPUSH
75781: PPUSH
75782: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
75783: LD_ADDR_VAR 0 6
75787: PUSH
75788: LD_INT 22
75790: PUSH
75791: LD_OWVAR 2
75795: PUSH
75796: EMPTY
75797: LIST
75798: LIST
75799: PUSH
75800: LD_INT 21
75802: PUSH
75803: LD_INT 1
75805: PUSH
75806: EMPTY
75807: LIST
75808: LIST
75809: PUSH
75810: LD_INT 3
75812: PUSH
75813: LD_INT 23
75815: PUSH
75816: LD_INT 0
75818: PUSH
75819: EMPTY
75820: LIST
75821: LIST
75822: PUSH
75823: EMPTY
75824: LIST
75825: LIST
75826: PUSH
75827: EMPTY
75828: LIST
75829: LIST
75830: LIST
75831: PPUSH
75832: CALL_OW 69
75836: ST_TO_ADDR
// if not tmp then
75837: LD_VAR 0 6
75841: NOT
75842: IFFALSE 75846
// exit ;
75844: GO 75992
// s1 := rand ( 1 , 4 ) ;
75846: LD_ADDR_VAR 0 2
75850: PUSH
75851: LD_INT 1
75853: PPUSH
75854: LD_INT 4
75856: PPUSH
75857: CALL_OW 12
75861: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
75862: LD_ADDR_VAR 0 4
75866: PUSH
75867: LD_VAR 0 6
75871: PUSH
75872: LD_INT 1
75874: ARRAY
75875: PPUSH
75876: LD_VAR 0 2
75880: PPUSH
75881: CALL_OW 259
75885: ST_TO_ADDR
// if s1 = 1 then
75886: LD_VAR 0 2
75890: PUSH
75891: LD_INT 1
75893: EQUAL
75894: IFFALSE 75914
// s2 := rand ( 2 , 4 ) else
75896: LD_ADDR_VAR 0 3
75900: PUSH
75901: LD_INT 2
75903: PPUSH
75904: LD_INT 4
75906: PPUSH
75907: CALL_OW 12
75911: ST_TO_ADDR
75912: GO 75922
// s2 := 1 ;
75914: LD_ADDR_VAR 0 3
75918: PUSH
75919: LD_INT 1
75921: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
75922: LD_ADDR_VAR 0 5
75926: PUSH
75927: LD_VAR 0 6
75931: PUSH
75932: LD_INT 1
75934: ARRAY
75935: PPUSH
75936: LD_VAR 0 3
75940: PPUSH
75941: CALL_OW 259
75945: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
75946: LD_VAR 0 6
75950: PUSH
75951: LD_INT 1
75953: ARRAY
75954: PPUSH
75955: LD_VAR 0 2
75959: PPUSH
75960: LD_VAR 0 5
75964: PPUSH
75965: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
75969: LD_VAR 0 6
75973: PUSH
75974: LD_INT 1
75976: ARRAY
75977: PPUSH
75978: LD_VAR 0 3
75982: PPUSH
75983: LD_VAR 0 4
75987: PPUSH
75988: CALL_OW 237
// end ;
75992: PPOPN 6
75994: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
75995: LD_EXP 98
75999: PUSH
76000: LD_EXP 145
76004: AND
76005: IFFALSE 76084
76007: GO 76009
76009: DISABLE
76010: LD_INT 0
76012: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
76013: LD_ADDR_VAR 0 1
76017: PUSH
76018: LD_INT 22
76020: PUSH
76021: LD_OWVAR 2
76025: PUSH
76026: EMPTY
76027: LIST
76028: LIST
76029: PUSH
76030: LD_INT 30
76032: PUSH
76033: LD_INT 3
76035: PUSH
76036: EMPTY
76037: LIST
76038: LIST
76039: PUSH
76040: EMPTY
76041: LIST
76042: LIST
76043: PPUSH
76044: CALL_OW 69
76048: ST_TO_ADDR
// if not tmp then
76049: LD_VAR 0 1
76053: NOT
76054: IFFALSE 76058
// exit ;
76056: GO 76084
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
76058: LD_VAR 0 1
76062: PUSH
76063: LD_INT 1
76065: PPUSH
76066: LD_VAR 0 1
76070: PPUSH
76071: CALL_OW 12
76075: ARRAY
76076: PPUSH
76077: LD_INT 1
76079: PPUSH
76080: CALL_OW 234
// end ;
76084: PPOPN 1
76086: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
76087: LD_EXP 98
76091: PUSH
76092: LD_EXP 146
76096: AND
76097: IFFALSE 76209
76099: GO 76101
76101: DISABLE
76102: LD_INT 0
76104: PPUSH
76105: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
76106: LD_ADDR_VAR 0 2
76110: PUSH
76111: LD_INT 22
76113: PUSH
76114: LD_OWVAR 2
76118: PUSH
76119: EMPTY
76120: LIST
76121: LIST
76122: PUSH
76123: LD_INT 2
76125: PUSH
76126: LD_INT 30
76128: PUSH
76129: LD_INT 27
76131: PUSH
76132: EMPTY
76133: LIST
76134: LIST
76135: PUSH
76136: LD_INT 30
76138: PUSH
76139: LD_INT 26
76141: PUSH
76142: EMPTY
76143: LIST
76144: LIST
76145: PUSH
76146: LD_INT 30
76148: PUSH
76149: LD_INT 28
76151: PUSH
76152: EMPTY
76153: LIST
76154: LIST
76155: PUSH
76156: EMPTY
76157: LIST
76158: LIST
76159: LIST
76160: LIST
76161: PUSH
76162: EMPTY
76163: LIST
76164: LIST
76165: PPUSH
76166: CALL_OW 69
76170: ST_TO_ADDR
// if not tmp then
76171: LD_VAR 0 2
76175: NOT
76176: IFFALSE 76180
// exit ;
76178: GO 76209
// for i in tmp do
76180: LD_ADDR_VAR 0 1
76184: PUSH
76185: LD_VAR 0 2
76189: PUSH
76190: FOR_IN
76191: IFFALSE 76207
// SetLives ( i , 1 ) ;
76193: LD_VAR 0 1
76197: PPUSH
76198: LD_INT 1
76200: PPUSH
76201: CALL_OW 234
76205: GO 76190
76207: POP
76208: POP
// end ;
76209: PPOPN 2
76211: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
76212: LD_EXP 98
76216: PUSH
76217: LD_EXP 147
76221: AND
76222: IFFALSE 76509
76224: GO 76226
76226: DISABLE
76227: LD_INT 0
76229: PPUSH
76230: PPUSH
76231: PPUSH
// begin i := rand ( 1 , 7 ) ;
76232: LD_ADDR_VAR 0 1
76236: PUSH
76237: LD_INT 1
76239: PPUSH
76240: LD_INT 7
76242: PPUSH
76243: CALL_OW 12
76247: ST_TO_ADDR
// case i of 1 :
76248: LD_VAR 0 1
76252: PUSH
76253: LD_INT 1
76255: DOUBLE
76256: EQUAL
76257: IFTRUE 76261
76259: GO 76271
76261: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
76262: LD_STRING earthquake(getX(game), 0, 32)
76264: PPUSH
76265: CALL_OW 559
76269: GO 76509
76271: LD_INT 2
76273: DOUBLE
76274: EQUAL
76275: IFTRUE 76279
76277: GO 76293
76279: POP
// begin ToLua ( displayStucuk(); ) ;
76280: LD_STRING displayStucuk();
76282: PPUSH
76283: CALL_OW 559
// ResetFog ;
76287: CALL_OW 335
// end ; 3 :
76291: GO 76509
76293: LD_INT 3
76295: DOUBLE
76296: EQUAL
76297: IFTRUE 76301
76299: GO 76405
76301: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
76302: LD_ADDR_VAR 0 2
76306: PUSH
76307: LD_INT 22
76309: PUSH
76310: LD_OWVAR 2
76314: PUSH
76315: EMPTY
76316: LIST
76317: LIST
76318: PUSH
76319: LD_INT 25
76321: PUSH
76322: LD_INT 1
76324: PUSH
76325: EMPTY
76326: LIST
76327: LIST
76328: PUSH
76329: EMPTY
76330: LIST
76331: LIST
76332: PPUSH
76333: CALL_OW 69
76337: ST_TO_ADDR
// if not tmp then
76338: LD_VAR 0 2
76342: NOT
76343: IFFALSE 76347
// exit ;
76345: GO 76509
// un := tmp [ rand ( 1 , tmp ) ] ;
76347: LD_ADDR_VAR 0 3
76351: PUSH
76352: LD_VAR 0 2
76356: PUSH
76357: LD_INT 1
76359: PPUSH
76360: LD_VAR 0 2
76364: PPUSH
76365: CALL_OW 12
76369: ARRAY
76370: ST_TO_ADDR
// if Crawls ( un ) then
76371: LD_VAR 0 3
76375: PPUSH
76376: CALL_OW 318
76380: IFFALSE 76391
// ComWalk ( un ) ;
76382: LD_VAR 0 3
76386: PPUSH
76387: CALL_OW 138
// SetClass ( un , class_mortar ) ;
76391: LD_VAR 0 3
76395: PPUSH
76396: LD_INT 8
76398: PPUSH
76399: CALL_OW 336
// end ; 4 :
76403: GO 76509
76405: LD_INT 4
76407: DOUBLE
76408: EQUAL
76409: IFTRUE 76413
76411: GO 76487
76413: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
76414: LD_ADDR_VAR 0 2
76418: PUSH
76419: LD_INT 22
76421: PUSH
76422: LD_OWVAR 2
76426: PUSH
76427: EMPTY
76428: LIST
76429: LIST
76430: PUSH
76431: LD_INT 30
76433: PUSH
76434: LD_INT 29
76436: PUSH
76437: EMPTY
76438: LIST
76439: LIST
76440: PUSH
76441: EMPTY
76442: LIST
76443: LIST
76444: PPUSH
76445: CALL_OW 69
76449: ST_TO_ADDR
// if not tmp then
76450: LD_VAR 0 2
76454: NOT
76455: IFFALSE 76459
// exit ;
76457: GO 76509
// CenterNowOnUnits ( tmp [ 1 ] ) ;
76459: LD_VAR 0 2
76463: PUSH
76464: LD_INT 1
76466: ARRAY
76467: PPUSH
76468: CALL_OW 87
// DestroyUnit ( tmp [ 1 ] ) ;
76472: LD_VAR 0 2
76476: PUSH
76477: LD_INT 1
76479: ARRAY
76480: PPUSH
76481: CALL_OW 65
// end ; 5 .. 7 :
76485: GO 76509
76487: LD_INT 5
76489: DOUBLE
76490: GREATEREQUAL
76491: IFFALSE 76499
76493: LD_INT 7
76495: DOUBLE
76496: LESSEQUAL
76497: IFTRUE 76501
76499: GO 76508
76501: POP
// StreamSibBomb ; end ;
76502: CALL 72746 0 0
76506: GO 76509
76508: POP
// end ;
76509: PPOPN 3
76511: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
76512: LD_EXP 98
76516: PUSH
76517: LD_EXP 148
76521: AND
76522: IFFALSE 76678
76524: GO 76526
76526: DISABLE
76527: LD_INT 0
76529: PPUSH
76530: PPUSH
76531: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
76532: LD_ADDR_VAR 0 2
76536: PUSH
76537: LD_INT 81
76539: PUSH
76540: LD_OWVAR 2
76544: PUSH
76545: EMPTY
76546: LIST
76547: LIST
76548: PUSH
76549: LD_INT 2
76551: PUSH
76552: LD_INT 21
76554: PUSH
76555: LD_INT 1
76557: PUSH
76558: EMPTY
76559: LIST
76560: LIST
76561: PUSH
76562: LD_INT 21
76564: PUSH
76565: LD_INT 2
76567: PUSH
76568: EMPTY
76569: LIST
76570: LIST
76571: PUSH
76572: EMPTY
76573: LIST
76574: LIST
76575: LIST
76576: PUSH
76577: EMPTY
76578: LIST
76579: LIST
76580: PPUSH
76581: CALL_OW 69
76585: ST_TO_ADDR
// if not tmp then
76586: LD_VAR 0 2
76590: NOT
76591: IFFALSE 76595
// exit ;
76593: GO 76678
// p := 0 ;
76595: LD_ADDR_VAR 0 3
76599: PUSH
76600: LD_INT 0
76602: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
76603: LD_INT 35
76605: PPUSH
76606: CALL_OW 67
// p := p + 1 ;
76610: LD_ADDR_VAR 0 3
76614: PUSH
76615: LD_VAR 0 3
76619: PUSH
76620: LD_INT 1
76622: PLUS
76623: ST_TO_ADDR
// for i in tmp do
76624: LD_ADDR_VAR 0 1
76628: PUSH
76629: LD_VAR 0 2
76633: PUSH
76634: FOR_IN
76635: IFFALSE 76666
// if GetLives ( i ) < 1000 then
76637: LD_VAR 0 1
76641: PPUSH
76642: CALL_OW 256
76646: PUSH
76647: LD_INT 1000
76649: LESS
76650: IFFALSE 76664
// SetLives ( i , 1000 ) ;
76652: LD_VAR 0 1
76656: PPUSH
76657: LD_INT 1000
76659: PPUSH
76660: CALL_OW 234
76664: GO 76634
76666: POP
76667: POP
// until p > 20 ;
76668: LD_VAR 0 3
76672: PUSH
76673: LD_INT 20
76675: GREATER
76676: IFFALSE 76603
// end ;
76678: PPOPN 3
76680: END
// every 0 0$1 trigger StreamModeActive and sTime do
76681: LD_EXP 98
76685: PUSH
76686: LD_EXP 149
76690: AND
76691: IFFALSE 76726
76693: GO 76695
76695: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
76696: LD_INT 28
76698: PPUSH
76699: LD_OWVAR 2
76703: PPUSH
76704: LD_INT 2
76706: PPUSH
76707: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
76711: LD_INT 30
76713: PPUSH
76714: LD_OWVAR 2
76718: PPUSH
76719: LD_INT 2
76721: PPUSH
76722: CALL_OW 322
// end ;
76726: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
76727: LD_EXP 98
76731: PUSH
76732: LD_EXP 150
76736: AND
76737: IFFALSE 76858
76739: GO 76741
76741: DISABLE
76742: LD_INT 0
76744: PPUSH
76745: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
76746: LD_ADDR_VAR 0 2
76750: PUSH
76751: LD_INT 22
76753: PUSH
76754: LD_OWVAR 2
76758: PUSH
76759: EMPTY
76760: LIST
76761: LIST
76762: PUSH
76763: LD_INT 21
76765: PUSH
76766: LD_INT 1
76768: PUSH
76769: EMPTY
76770: LIST
76771: LIST
76772: PUSH
76773: LD_INT 3
76775: PUSH
76776: LD_INT 23
76778: PUSH
76779: LD_INT 0
76781: PUSH
76782: EMPTY
76783: LIST
76784: LIST
76785: PUSH
76786: EMPTY
76787: LIST
76788: LIST
76789: PUSH
76790: EMPTY
76791: LIST
76792: LIST
76793: LIST
76794: PPUSH
76795: CALL_OW 69
76799: ST_TO_ADDR
// if not tmp then
76800: LD_VAR 0 2
76804: NOT
76805: IFFALSE 76809
// exit ;
76807: GO 76858
// for i in tmp do
76809: LD_ADDR_VAR 0 1
76813: PUSH
76814: LD_VAR 0 2
76818: PUSH
76819: FOR_IN
76820: IFFALSE 76856
// begin if Crawls ( i ) then
76822: LD_VAR 0 1
76826: PPUSH
76827: CALL_OW 318
76831: IFFALSE 76842
// ComWalk ( i ) ;
76833: LD_VAR 0 1
76837: PPUSH
76838: CALL_OW 138
// SetClass ( i , 2 ) ;
76842: LD_VAR 0 1
76846: PPUSH
76847: LD_INT 2
76849: PPUSH
76850: CALL_OW 336
// end ;
76854: GO 76819
76856: POP
76857: POP
// end ;
76858: PPOPN 2
76860: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
76861: LD_EXP 98
76865: PUSH
76866: LD_EXP 151
76870: AND
76871: IFFALSE 77159
76873: GO 76875
76875: DISABLE
76876: LD_INT 0
76878: PPUSH
76879: PPUSH
76880: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
76881: LD_OWVAR 2
76885: PPUSH
76886: LD_INT 9
76888: PPUSH
76889: LD_INT 1
76891: PPUSH
76892: LD_INT 1
76894: PPUSH
76895: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
76899: LD_INT 9
76901: PPUSH
76902: LD_OWVAR 2
76906: PPUSH
76907: CALL_OW 343
// uc_side := 9 ;
76911: LD_ADDR_OWVAR 20
76915: PUSH
76916: LD_INT 9
76918: ST_TO_ADDR
// uc_nation := 2 ;
76919: LD_ADDR_OWVAR 21
76923: PUSH
76924: LD_INT 2
76926: ST_TO_ADDR
// hc_name := Dark Warrior ;
76927: LD_ADDR_OWVAR 26
76931: PUSH
76932: LD_STRING Dark Warrior
76934: ST_TO_ADDR
// hc_gallery :=  ;
76935: LD_ADDR_OWVAR 33
76939: PUSH
76940: LD_STRING 
76942: ST_TO_ADDR
// hc_noskilllimit := true ;
76943: LD_ADDR_OWVAR 76
76947: PUSH
76948: LD_INT 1
76950: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
76951: LD_ADDR_OWVAR 31
76955: PUSH
76956: LD_INT 30
76958: PUSH
76959: LD_INT 30
76961: PUSH
76962: LD_INT 30
76964: PUSH
76965: LD_INT 30
76967: PUSH
76968: EMPTY
76969: LIST
76970: LIST
76971: LIST
76972: LIST
76973: ST_TO_ADDR
// un := CreateHuman ;
76974: LD_ADDR_VAR 0 3
76978: PUSH
76979: CALL_OW 44
76983: ST_TO_ADDR
// hc_noskilllimit := false ;
76984: LD_ADDR_OWVAR 76
76988: PUSH
76989: LD_INT 0
76991: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
76992: LD_VAR 0 3
76996: PPUSH
76997: LD_INT 1
76999: PPUSH
77000: CALL_OW 51
// ToLua ( playRanger() ) ;
77004: LD_STRING playRanger()
77006: PPUSH
77007: CALL_OW 559
// p := 0 ;
77011: LD_ADDR_VAR 0 2
77015: PUSH
77016: LD_INT 0
77018: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
77019: LD_INT 35
77021: PPUSH
77022: CALL_OW 67
// p := p + 1 ;
77026: LD_ADDR_VAR 0 2
77030: PUSH
77031: LD_VAR 0 2
77035: PUSH
77036: LD_INT 1
77038: PLUS
77039: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
77040: LD_VAR 0 3
77044: PPUSH
77045: CALL_OW 256
77049: PUSH
77050: LD_INT 1000
77052: LESS
77053: IFFALSE 77067
// SetLives ( un , 1000 ) ;
77055: LD_VAR 0 3
77059: PPUSH
77060: LD_INT 1000
77062: PPUSH
77063: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
77067: LD_VAR 0 3
77071: PPUSH
77072: LD_INT 81
77074: PUSH
77075: LD_OWVAR 2
77079: PUSH
77080: EMPTY
77081: LIST
77082: LIST
77083: PUSH
77084: LD_INT 91
77086: PUSH
77087: LD_VAR 0 3
77091: PUSH
77092: LD_INT 30
77094: PUSH
77095: EMPTY
77096: LIST
77097: LIST
77098: LIST
77099: PUSH
77100: EMPTY
77101: LIST
77102: LIST
77103: PPUSH
77104: CALL_OW 69
77108: PPUSH
77109: LD_VAR 0 3
77113: PPUSH
77114: CALL_OW 74
77118: PPUSH
77119: CALL_OW 115
// until p > 80 or IsDead ( un ) ;
77123: LD_VAR 0 2
77127: PUSH
77128: LD_INT 80
77130: GREATER
77131: PUSH
77132: LD_VAR 0 3
77136: PPUSH
77137: CALL_OW 301
77141: OR
77142: IFFALSE 77019
// if un then
77144: LD_VAR 0 3
77148: IFFALSE 77159
// RemoveUnit ( un ) ;
77150: LD_VAR 0 3
77154: PPUSH
77155: CALL_OW 64
// end ;
77159: PPOPN 3
77161: END
// every 0 0$1 trigger sComputer do var i , tmp , j ;
77162: LD_EXP 152
77166: IFFALSE 77282
77168: GO 77170
77170: DISABLE
77171: LD_INT 0
77173: PPUSH
77174: PPUSH
77175: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
77176: LD_ADDR_VAR 0 2
77180: PUSH
77181: LD_INT 81
77183: PUSH
77184: LD_OWVAR 2
77188: PUSH
77189: EMPTY
77190: LIST
77191: LIST
77192: PUSH
77193: LD_INT 21
77195: PUSH
77196: LD_INT 1
77198: PUSH
77199: EMPTY
77200: LIST
77201: LIST
77202: PUSH
77203: EMPTY
77204: LIST
77205: LIST
77206: PPUSH
77207: CALL_OW 69
77211: ST_TO_ADDR
// ToLua ( playComputer() ) ;
77212: LD_STRING playComputer()
77214: PPUSH
77215: CALL_OW 559
// if not tmp then
77219: LD_VAR 0 2
77223: NOT
77224: IFFALSE 77228
// exit ;
77226: GO 77282
// for i in tmp do
77228: LD_ADDR_VAR 0 1
77232: PUSH
77233: LD_VAR 0 2
77237: PUSH
77238: FOR_IN
77239: IFFALSE 77280
// for j := 1 to 4 do
77241: LD_ADDR_VAR 0 3
77245: PUSH
77246: DOUBLE
77247: LD_INT 1
77249: DEC
77250: ST_TO_ADDR
77251: LD_INT 4
77253: PUSH
77254: FOR_TO
77255: IFFALSE 77276
// SetSkill ( i , j , 10 ) ;
77257: LD_VAR 0 1
77261: PPUSH
77262: LD_VAR 0 3
77266: PPUSH
77267: LD_INT 10
77269: PPUSH
77270: CALL_OW 237
77274: GO 77254
77276: POP
77277: POP
77278: GO 77238
77280: POP
77281: POP
// end ;
77282: PPOPN 3
77284: END
// every 0 0$1 trigger s30 do var i , tmp ;
77285: LD_EXP 153
77289: IFFALSE 77358
77291: GO 77293
77293: DISABLE
77294: LD_INT 0
77296: PPUSH
77297: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
77298: LD_ADDR_VAR 0 2
77302: PUSH
77303: LD_INT 22
77305: PUSH
77306: LD_OWVAR 2
77310: PUSH
77311: EMPTY
77312: LIST
77313: LIST
77314: PPUSH
77315: CALL_OW 69
77319: ST_TO_ADDR
// if not tmp then
77320: LD_VAR 0 2
77324: NOT
77325: IFFALSE 77329
// exit ;
77327: GO 77358
// for i in tmp do
77329: LD_ADDR_VAR 0 1
77333: PUSH
77334: LD_VAR 0 2
77338: PUSH
77339: FOR_IN
77340: IFFALSE 77356
// SetLives ( i , 300 ) ;
77342: LD_VAR 0 1
77346: PPUSH
77347: LD_INT 300
77349: PPUSH
77350: CALL_OW 234
77354: GO 77339
77356: POP
77357: POP
// end ;
77358: PPOPN 2
77360: END
// every 0 0$1 trigger s60 do var i , tmp ;
77361: LD_EXP 154
77365: IFFALSE 77434
77367: GO 77369
77369: DISABLE
77370: LD_INT 0
77372: PPUSH
77373: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
77374: LD_ADDR_VAR 0 2
77378: PUSH
77379: LD_INT 22
77381: PUSH
77382: LD_OWVAR 2
77386: PUSH
77387: EMPTY
77388: LIST
77389: LIST
77390: PPUSH
77391: CALL_OW 69
77395: ST_TO_ADDR
// if not tmp then
77396: LD_VAR 0 2
77400: NOT
77401: IFFALSE 77405
// exit ;
77403: GO 77434
// for i in tmp do
77405: LD_ADDR_VAR 0 1
77409: PUSH
77410: LD_VAR 0 2
77414: PUSH
77415: FOR_IN
77416: IFFALSE 77432
// SetLives ( i , 600 ) ;
77418: LD_VAR 0 1
77422: PPUSH
77423: LD_INT 600
77425: PPUSH
77426: CALL_OW 234
77430: GO 77415
77432: POP
77433: POP
// end ;
77434: PPOPN 2
77436: END
// export function SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
77437: LD_INT 0
77439: PPUSH
// case cmd of 301 :
77440: LD_VAR 0 1
77444: PUSH
77445: LD_INT 301
77447: DOUBLE
77448: EQUAL
77449: IFTRUE 77453
77451: GO 77485
77453: POP
// hHackSpawnHuman ( p1 , p2 , p3 , x , y ) ; 302 :
77454: LD_VAR 0 6
77458: PPUSH
77459: LD_VAR 0 7
77463: PPUSH
77464: LD_VAR 0 8
77468: PPUSH
77469: LD_VAR 0 4
77473: PPUSH
77474: LD_VAR 0 5
77478: PPUSH
77479: CALL 78686 0 5
77483: GO 77606
77485: LD_INT 302
77487: DOUBLE
77488: EQUAL
77489: IFTRUE 77493
77491: GO 77530
77493: POP
// hHackSpawnVehicle ( p1 , p2 , p3 , p4 , x , y ) ; 303 :
77494: LD_VAR 0 6
77498: PPUSH
77499: LD_VAR 0 7
77503: PPUSH
77504: LD_VAR 0 8
77508: PPUSH
77509: LD_VAR 0 9
77513: PPUSH
77514: LD_VAR 0 4
77518: PPUSH
77519: LD_VAR 0 5
77523: PPUSH
77524: CALL 78777 0 6
77528: GO 77606
77530: LD_INT 303
77532: DOUBLE
77533: EQUAL
77534: IFTRUE 77538
77536: GO 77575
77538: POP
// hHackSpawnBuilding ( p1 , p2 , p3 , p4 , x , y ) ; 304 :
77539: LD_VAR 0 6
77543: PPUSH
77544: LD_VAR 0 7
77548: PPUSH
77549: LD_VAR 0 8
77553: PPUSH
77554: LD_VAR 0 9
77558: PPUSH
77559: LD_VAR 0 4
77563: PPUSH
77564: LD_VAR 0 5
77568: PPUSH
77569: CALL 77611 0 6
77573: GO 77606
77575: LD_INT 304
77577: DOUBLE
77578: EQUAL
77579: IFTRUE 77583
77581: GO 77605
77583: POP
// hHackTeleport ( unit , x , y ) ; end ;
77584: LD_VAR 0 2
77588: PPUSH
77589: LD_VAR 0 4
77593: PPUSH
77594: LD_VAR 0 5
77598: PPUSH
77599: CALL 79370 0 3
77603: GO 77606
77605: POP
// end ;
77606: LD_VAR 0 12
77610: RET
// export function hHackSpawnBuilding ( nation , btype , dir , weapon , x , y ) ; var b ; begin
77611: LD_INT 0
77613: PPUSH
77614: PPUSH
// if nation < 1 or nation > 3 or HexInfo ( x , y ) then
77615: LD_VAR 0 1
77619: PUSH
77620: LD_INT 1
77622: LESS
77623: PUSH
77624: LD_VAR 0 1
77628: PUSH
77629: LD_INT 3
77631: GREATER
77632: OR
77633: PUSH
77634: LD_VAR 0 5
77638: PPUSH
77639: LD_VAR 0 6
77643: PPUSH
77644: CALL_OW 428
77648: OR
77649: IFFALSE 77653
// exit ;
77651: GO 78373
// uc_side := your_side ;
77653: LD_ADDR_OWVAR 20
77657: PUSH
77658: LD_OWVAR 2
77662: ST_TO_ADDR
// uc_nation := nation ;
77663: LD_ADDR_OWVAR 21
77667: PUSH
77668: LD_VAR 0 1
77672: ST_TO_ADDR
// bc_level = 1 ;
77673: LD_ADDR_OWVAR 43
77677: PUSH
77678: LD_INT 1
77680: ST_TO_ADDR
// case btype of 1 :
77681: LD_VAR 0 2
77685: PUSH
77686: LD_INT 1
77688: DOUBLE
77689: EQUAL
77690: IFTRUE 77694
77692: GO 77705
77694: POP
// bc_type := b_depot ; 2 :
77695: LD_ADDR_OWVAR 42
77699: PUSH
77700: LD_INT 0
77702: ST_TO_ADDR
77703: GO 78317
77705: LD_INT 2
77707: DOUBLE
77708: EQUAL
77709: IFTRUE 77713
77711: GO 77724
77713: POP
// bc_type := b_warehouse ; 3 :
77714: LD_ADDR_OWVAR 42
77718: PUSH
77719: LD_INT 1
77721: ST_TO_ADDR
77722: GO 78317
77724: LD_INT 3
77726: DOUBLE
77727: EQUAL
77728: IFTRUE 77732
77730: GO 77743
77732: POP
// bc_type := b_lab ; 4 .. 9 :
77733: LD_ADDR_OWVAR 42
77737: PUSH
77738: LD_INT 6
77740: ST_TO_ADDR
77741: GO 78317
77743: LD_INT 4
77745: DOUBLE
77746: GREATEREQUAL
77747: IFFALSE 77755
77749: LD_INT 9
77751: DOUBLE
77752: LESSEQUAL
77753: IFTRUE 77757
77755: GO 77809
77757: POP
// begin bc_type := b_lab_half ;
77758: LD_ADDR_OWVAR 42
77762: PUSH
77763: LD_INT 7
77765: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_opto , b_lab_spacetime , b_lab_biological ] [ btype - 3 ] ;
77766: LD_ADDR_OWVAR 44
77770: PUSH
77771: LD_INT 10
77773: PUSH
77774: LD_INT 11
77776: PUSH
77777: LD_INT 12
77779: PUSH
77780: LD_INT 15
77782: PUSH
77783: LD_INT 14
77785: PUSH
77786: LD_INT 13
77788: PUSH
77789: EMPTY
77790: LIST
77791: LIST
77792: LIST
77793: LIST
77794: LIST
77795: LIST
77796: PUSH
77797: LD_VAR 0 2
77801: PUSH
77802: LD_INT 3
77804: MINUS
77805: ARRAY
77806: ST_TO_ADDR
// end ; 10 .. 13 :
77807: GO 78317
77809: LD_INT 10
77811: DOUBLE
77812: GREATEREQUAL
77813: IFFALSE 77821
77815: LD_INT 13
77817: DOUBLE
77818: LESSEQUAL
77819: IFTRUE 77823
77821: GO 77900
77823: POP
// begin bc_type := b_lab_full ;
77824: LD_ADDR_OWVAR 42
77828: PUSH
77829: LD_INT 8
77831: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_computer , b_lab_spacetime , b_lab_biological ] [ btype - 9 ] ;
77832: LD_ADDR_OWVAR 44
77836: PUSH
77837: LD_INT 10
77839: PUSH
77840: LD_INT 12
77842: PUSH
77843: LD_INT 14
77845: PUSH
77846: LD_INT 13
77848: PUSH
77849: EMPTY
77850: LIST
77851: LIST
77852: LIST
77853: LIST
77854: PUSH
77855: LD_VAR 0 2
77859: PUSH
77860: LD_INT 9
77862: MINUS
77863: ARRAY
77864: ST_TO_ADDR
// bc_kind2 := [ b_lab_siberium , b_lab_opto , b_lab_computer , b_lab_opto ] [ btype - 9 ] ;
77865: LD_ADDR_OWVAR 45
77869: PUSH
77870: LD_INT 11
77872: PUSH
77873: LD_INT 15
77875: PUSH
77876: LD_INT 12
77878: PUSH
77879: LD_INT 15
77881: PUSH
77882: EMPTY
77883: LIST
77884: LIST
77885: LIST
77886: LIST
77887: PUSH
77888: LD_VAR 0 2
77892: PUSH
77893: LD_INT 9
77895: MINUS
77896: ARRAY
77897: ST_TO_ADDR
// end ; 14 :
77898: GO 78317
77900: LD_INT 14
77902: DOUBLE
77903: EQUAL
77904: IFTRUE 77908
77906: GO 77919
77908: POP
// bc_type := b_workshop ; 15 :
77909: LD_ADDR_OWVAR 42
77913: PUSH
77914: LD_INT 2
77916: ST_TO_ADDR
77917: GO 78317
77919: LD_INT 15
77921: DOUBLE
77922: EQUAL
77923: IFTRUE 77927
77925: GO 77938
77927: POP
// bc_type := b_factory ; 16 :
77928: LD_ADDR_OWVAR 42
77932: PUSH
77933: LD_INT 3
77935: ST_TO_ADDR
77936: GO 78317
77938: LD_INT 16
77940: DOUBLE
77941: EQUAL
77942: IFTRUE 77946
77944: GO 77957
77946: POP
// bc_type := b_ext_gun ; 17 :
77947: LD_ADDR_OWVAR 42
77951: PUSH
77952: LD_INT 17
77954: ST_TO_ADDR
77955: GO 78317
77957: LD_INT 17
77959: DOUBLE
77960: EQUAL
77961: IFTRUE 77965
77963: GO 77993
77965: POP
// bc_type := [ b_ext_noncombat , b_ext_stitch , b_ext_noncombat ] [ nation ] ; 18 :
77966: LD_ADDR_OWVAR 42
77970: PUSH
77971: LD_INT 19
77973: PUSH
77974: LD_INT 23
77976: PUSH
77977: LD_INT 19
77979: PUSH
77980: EMPTY
77981: LIST
77982: LIST
77983: LIST
77984: PUSH
77985: LD_VAR 0 1
77989: ARRAY
77990: ST_TO_ADDR
77991: GO 78317
77993: LD_INT 18
77995: DOUBLE
77996: EQUAL
77997: IFTRUE 78001
77999: GO 78012
78001: POP
// bc_type := b_ext_radar ; 19 :
78002: LD_ADDR_OWVAR 42
78006: PUSH
78007: LD_INT 20
78009: ST_TO_ADDR
78010: GO 78317
78012: LD_INT 19
78014: DOUBLE
78015: EQUAL
78016: IFTRUE 78020
78018: GO 78031
78020: POP
// bc_type := b_ext_radio ; 20 :
78021: LD_ADDR_OWVAR 42
78025: PUSH
78026: LD_INT 22
78028: ST_TO_ADDR
78029: GO 78317
78031: LD_INT 20
78033: DOUBLE
78034: EQUAL
78035: IFTRUE 78039
78037: GO 78050
78039: POP
// bc_type := b_ext_siberium ; 21 :
78040: LD_ADDR_OWVAR 42
78044: PUSH
78045: LD_INT 21
78047: ST_TO_ADDR
78048: GO 78317
78050: LD_INT 21
78052: DOUBLE
78053: EQUAL
78054: IFTRUE 78058
78056: GO 78069
78058: POP
// bc_type := b_ext_computer ; 22 :
78059: LD_ADDR_OWVAR 42
78063: PUSH
78064: LD_INT 24
78066: ST_TO_ADDR
78067: GO 78317
78069: LD_INT 22
78071: DOUBLE
78072: EQUAL
78073: IFTRUE 78077
78075: GO 78088
78077: POP
// bc_type := b_ext_track ; 23 :
78078: LD_ADDR_OWVAR 42
78082: PUSH
78083: LD_INT 16
78085: ST_TO_ADDR
78086: GO 78317
78088: LD_INT 23
78090: DOUBLE
78091: EQUAL
78092: IFTRUE 78096
78094: GO 78107
78096: POP
// bc_type := b_ext_laser ; 24 :
78097: LD_ADDR_OWVAR 42
78101: PUSH
78102: LD_INT 25
78104: ST_TO_ADDR
78105: GO 78317
78107: LD_INT 24
78109: DOUBLE
78110: EQUAL
78111: IFTRUE 78115
78113: GO 78126
78115: POP
// bc_type := b_control_tower ; 25 :
78116: LD_ADDR_OWVAR 42
78120: PUSH
78121: LD_INT 36
78123: ST_TO_ADDR
78124: GO 78317
78126: LD_INT 25
78128: DOUBLE
78129: EQUAL
78130: IFTRUE 78134
78132: GO 78145
78134: POP
// bc_type := b_breastwork ; 26 :
78135: LD_ADDR_OWVAR 42
78139: PUSH
78140: LD_INT 31
78142: ST_TO_ADDR
78143: GO 78317
78145: LD_INT 26
78147: DOUBLE
78148: EQUAL
78149: IFTRUE 78153
78151: GO 78164
78153: POP
// bc_type := b_bunker ; 27 :
78154: LD_ADDR_OWVAR 42
78158: PUSH
78159: LD_INT 32
78161: ST_TO_ADDR
78162: GO 78317
78164: LD_INT 27
78166: DOUBLE
78167: EQUAL
78168: IFTRUE 78172
78170: GO 78183
78172: POP
// bc_type := b_turret ; 28 :
78173: LD_ADDR_OWVAR 42
78177: PUSH
78178: LD_INT 33
78180: ST_TO_ADDR
78181: GO 78317
78183: LD_INT 28
78185: DOUBLE
78186: EQUAL
78187: IFTRUE 78191
78189: GO 78202
78191: POP
// bc_type := b_armoury ; 29 :
78192: LD_ADDR_OWVAR 42
78196: PUSH
78197: LD_INT 4
78199: ST_TO_ADDR
78200: GO 78317
78202: LD_INT 29
78204: DOUBLE
78205: EQUAL
78206: IFTRUE 78210
78208: GO 78221
78210: POP
// bc_type := b_barracks ; 30 :
78211: LD_ADDR_OWVAR 42
78215: PUSH
78216: LD_INT 5
78218: ST_TO_ADDR
78219: GO 78317
78221: LD_INT 30
78223: DOUBLE
78224: EQUAL
78225: IFTRUE 78229
78227: GO 78240
78229: POP
// bc_type := b_solar_power ; 31 :
78230: LD_ADDR_OWVAR 42
78234: PUSH
78235: LD_INT 27
78237: ST_TO_ADDR
78238: GO 78317
78240: LD_INT 31
78242: DOUBLE
78243: EQUAL
78244: IFTRUE 78248
78246: GO 78259
78248: POP
// bc_type := b_oil_power ; 32 :
78249: LD_ADDR_OWVAR 42
78253: PUSH
78254: LD_INT 26
78256: ST_TO_ADDR
78257: GO 78317
78259: LD_INT 32
78261: DOUBLE
78262: EQUAL
78263: IFTRUE 78267
78265: GO 78278
78267: POP
// bc_type := b_siberite_power ; 33 :
78268: LD_ADDR_OWVAR 42
78272: PUSH
78273: LD_INT 28
78275: ST_TO_ADDR
78276: GO 78317
78278: LD_INT 33
78280: DOUBLE
78281: EQUAL
78282: IFTRUE 78286
78284: GO 78297
78286: POP
// bc_type := b_oil_mine ; 34 :
78287: LD_ADDR_OWVAR 42
78291: PUSH
78292: LD_INT 29
78294: ST_TO_ADDR
78295: GO 78317
78297: LD_INT 34
78299: DOUBLE
78300: EQUAL
78301: IFTRUE 78305
78303: GO 78316
78305: POP
// bc_type := b_siberite_mine ; end ;
78306: LD_ADDR_OWVAR 42
78310: PUSH
78311: LD_INT 30
78313: ST_TO_ADDR
78314: GO 78317
78316: POP
// b := CreateAndPlaceBuildingXYD ( x , y , dir ) ;
78317: LD_ADDR_VAR 0 8
78321: PUSH
78322: LD_VAR 0 5
78326: PPUSH
78327: LD_VAR 0 6
78331: PPUSH
78332: LD_VAR 0 3
78336: PPUSH
78337: CALL_OW 47
78341: ST_TO_ADDR
// if bc_type in [ b_bunker , b_turret ] then
78342: LD_OWVAR 42
78346: PUSH
78347: LD_INT 32
78349: PUSH
78350: LD_INT 33
78352: PUSH
78353: EMPTY
78354: LIST
78355: LIST
78356: IN
78357: IFFALSE 78373
// PlaceWeaponTurret ( b , weapon ) ;
78359: LD_VAR 0 8
78363: PPUSH
78364: LD_VAR 0 4
78368: PPUSH
78369: CALL_OW 431
// end ;
78373: LD_VAR 0 7
78377: RET
// export function hHackUnlimitedResources ; var i , j , tmp ; begin
78378: LD_INT 0
78380: PPUSH
78381: PPUSH
78382: PPUSH
78383: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
78384: LD_ADDR_VAR 0 4
78388: PUSH
78389: LD_INT 22
78391: PUSH
78392: LD_OWVAR 2
78396: PUSH
78397: EMPTY
78398: LIST
78399: LIST
78400: PUSH
78401: LD_INT 2
78403: PUSH
78404: LD_INT 30
78406: PUSH
78407: LD_INT 0
78409: PUSH
78410: EMPTY
78411: LIST
78412: LIST
78413: PUSH
78414: LD_INT 30
78416: PUSH
78417: LD_INT 1
78419: PUSH
78420: EMPTY
78421: LIST
78422: LIST
78423: PUSH
78424: EMPTY
78425: LIST
78426: LIST
78427: LIST
78428: PUSH
78429: EMPTY
78430: LIST
78431: LIST
78432: PPUSH
78433: CALL_OW 69
78437: ST_TO_ADDR
// if not tmp then
78438: LD_VAR 0 4
78442: NOT
78443: IFFALSE 78447
// exit ;
78445: GO 78506
// for i in tmp do
78447: LD_ADDR_VAR 0 2
78451: PUSH
78452: LD_VAR 0 4
78456: PUSH
78457: FOR_IN
78458: IFFALSE 78504
// for j = 1 to 3 do
78460: LD_ADDR_VAR 0 3
78464: PUSH
78465: DOUBLE
78466: LD_INT 1
78468: DEC
78469: ST_TO_ADDR
78470: LD_INT 3
78472: PUSH
78473: FOR_TO
78474: IFFALSE 78500
// SetResourceType ( GetBase ( i ) , j , 99999 ) ;
78476: LD_VAR 0 2
78480: PPUSH
78481: CALL_OW 274
78485: PPUSH
78486: LD_VAR 0 3
78490: PPUSH
78491: LD_INT 99999
78493: PPUSH
78494: CALL_OW 277
78498: GO 78473
78500: POP
78501: POP
78502: GO 78457
78504: POP
78505: POP
// end ;
78506: LD_VAR 0 1
78510: RET
// export function hHackSetLevel10 ; var i , j ; begin
78511: LD_INT 0
78513: PPUSH
78514: PPUSH
78515: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
78516: LD_ADDR_VAR 0 2
78520: PUSH
78521: LD_INT 21
78523: PUSH
78524: LD_INT 1
78526: PUSH
78527: EMPTY
78528: LIST
78529: LIST
78530: PPUSH
78531: CALL_OW 69
78535: PUSH
78536: FOR_IN
78537: IFFALSE 78589
// if IsSelected ( i ) then
78539: LD_VAR 0 2
78543: PPUSH
78544: CALL_OW 306
78548: IFFALSE 78587
// begin for j := 1 to 4 do
78550: LD_ADDR_VAR 0 3
78554: PUSH
78555: DOUBLE
78556: LD_INT 1
78558: DEC
78559: ST_TO_ADDR
78560: LD_INT 4
78562: PUSH
78563: FOR_TO
78564: IFFALSE 78585
// SetSkill ( i , j , 10 ) ;
78566: LD_VAR 0 2
78570: PPUSH
78571: LD_VAR 0 3
78575: PPUSH
78576: LD_INT 10
78578: PPUSH
78579: CALL_OW 237
78583: GO 78563
78585: POP
78586: POP
// end ;
78587: GO 78536
78589: POP
78590: POP
// end ;
78591: LD_VAR 0 1
78595: RET
// export function hHackSetLevel10YourUnits ; var i , j ; begin
78596: LD_INT 0
78598: PPUSH
78599: PPUSH
78600: PPUSH
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) do
78601: LD_ADDR_VAR 0 2
78605: PUSH
78606: LD_INT 22
78608: PUSH
78609: LD_OWVAR 2
78613: PUSH
78614: EMPTY
78615: LIST
78616: LIST
78617: PUSH
78618: LD_INT 21
78620: PUSH
78621: LD_INT 1
78623: PUSH
78624: EMPTY
78625: LIST
78626: LIST
78627: PUSH
78628: EMPTY
78629: LIST
78630: LIST
78631: PPUSH
78632: CALL_OW 69
78636: PUSH
78637: FOR_IN
78638: IFFALSE 78679
// begin for j := 1 to 4 do
78640: LD_ADDR_VAR 0 3
78644: PUSH
78645: DOUBLE
78646: LD_INT 1
78648: DEC
78649: ST_TO_ADDR
78650: LD_INT 4
78652: PUSH
78653: FOR_TO
78654: IFFALSE 78675
// SetSkill ( i , j , 10 ) ;
78656: LD_VAR 0 2
78660: PPUSH
78661: LD_VAR 0 3
78665: PPUSH
78666: LD_INT 10
78668: PPUSH
78669: CALL_OW 237
78673: GO 78653
78675: POP
78676: POP
// end ;
78677: GO 78637
78679: POP
78680: POP
// end ;
78681: LD_VAR 0 1
78685: RET
// export function hHackSpawnHuman ( nation , class , skill , x , y ) ; begin
78686: LD_INT 0
78688: PPUSH
// uc_side := your_side ;
78689: LD_ADDR_OWVAR 20
78693: PUSH
78694: LD_OWVAR 2
78698: ST_TO_ADDR
// uc_nation := nation ;
78699: LD_ADDR_OWVAR 21
78703: PUSH
78704: LD_VAR 0 1
78708: ST_TO_ADDR
// InitHc ;
78709: CALL_OW 19
// PrepareHuman ( false , class , skill ) ;
78713: LD_INT 0
78715: PPUSH
78716: LD_VAR 0 2
78720: PPUSH
78721: LD_VAR 0 3
78725: PPUSH
78726: CALL_OW 380
// if HexInfo ( x , y ) = 0 then
78730: LD_VAR 0 4
78734: PPUSH
78735: LD_VAR 0 5
78739: PPUSH
78740: CALL_OW 428
78744: PUSH
78745: LD_INT 0
78747: EQUAL
78748: IFFALSE 78772
// PlaceUnitXY ( CreateHuman , x , y , true ) ;
78750: CALL_OW 44
78754: PPUSH
78755: LD_VAR 0 4
78759: PPUSH
78760: LD_VAR 0 5
78764: PPUSH
78765: LD_INT 1
78767: PPUSH
78768: CALL_OW 48
// end ;
78772: LD_VAR 0 6
78776: RET
// export function hHackSpawnVehicle ( chassis , engine , control , weapon , x , y ) ; var un ; begin
78777: LD_INT 0
78779: PPUSH
78780: PPUSH
// uc_side := your_side ;
78781: LD_ADDR_OWVAR 20
78785: PUSH
78786: LD_OWVAR 2
78790: ST_TO_ADDR
// if chassis in [ 1 , 2 , 3 , 4 , 5 ] then
78791: LD_VAR 0 1
78795: PUSH
78796: LD_INT 1
78798: PUSH
78799: LD_INT 2
78801: PUSH
78802: LD_INT 3
78804: PUSH
78805: LD_INT 4
78807: PUSH
78808: LD_INT 5
78810: PUSH
78811: EMPTY
78812: LIST
78813: LIST
78814: LIST
78815: LIST
78816: LIST
78817: IN
78818: IFFALSE 78830
// uc_nation := nation_american else
78820: LD_ADDR_OWVAR 21
78824: PUSH
78825: LD_INT 1
78827: ST_TO_ADDR
78828: GO 78873
// if chassis in [ 11 , 12 , 13 , 14 ] then
78830: LD_VAR 0 1
78834: PUSH
78835: LD_INT 11
78837: PUSH
78838: LD_INT 12
78840: PUSH
78841: LD_INT 13
78843: PUSH
78844: LD_INT 14
78846: PUSH
78847: EMPTY
78848: LIST
78849: LIST
78850: LIST
78851: LIST
78852: IN
78853: IFFALSE 78865
// uc_nation := nation_arabian else
78855: LD_ADDR_OWVAR 21
78859: PUSH
78860: LD_INT 2
78862: ST_TO_ADDR
78863: GO 78873
// uc_nation := nation_russian ;
78865: LD_ADDR_OWVAR 21
78869: PUSH
78870: LD_INT 3
78872: ST_TO_ADDR
// vc_chassis := chassis ;
78873: LD_ADDR_OWVAR 37
78877: PUSH
78878: LD_VAR 0 1
78882: ST_TO_ADDR
// vc_engine := engine ;
78883: LD_ADDR_OWVAR 39
78887: PUSH
78888: LD_VAR 0 2
78892: ST_TO_ADDR
// vc_control := control ;
78893: LD_ADDR_OWVAR 38
78897: PUSH
78898: LD_VAR 0 3
78902: ST_TO_ADDR
// vc_weapon := weapon ;
78903: LD_ADDR_OWVAR 40
78907: PUSH
78908: LD_VAR 0 4
78912: ST_TO_ADDR
// un := CreateVehicle ;
78913: LD_ADDR_VAR 0 8
78917: PUSH
78918: CALL_OW 45
78922: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
78923: LD_VAR 0 8
78927: PPUSH
78928: LD_INT 0
78930: PPUSH
78931: LD_INT 5
78933: PPUSH
78934: CALL_OW 12
78938: PPUSH
78939: CALL_OW 233
// PlaceUnitXY ( un , x , y , true ) ;
78943: LD_VAR 0 8
78947: PPUSH
78948: LD_VAR 0 5
78952: PPUSH
78953: LD_VAR 0 6
78957: PPUSH
78958: LD_INT 1
78960: PPUSH
78961: CALL_OW 48
// end ;
78965: LD_VAR 0 7
78969: RET
// export hInvincible ; every 1 do
78970: GO 78972
78972: DISABLE
// hInvincible := [ ] ;
78973: LD_ADDR_EXP 155
78977: PUSH
78978: EMPTY
78979: ST_TO_ADDR
78980: END
// every 10 do var i ;
78981: GO 78983
78983: DISABLE
78984: LD_INT 0
78986: PPUSH
// begin enable ;
78987: ENABLE
// if not hInvincible then
78988: LD_EXP 155
78992: NOT
78993: IFFALSE 78997
// exit ;
78995: GO 79041
// for i in hInvincible do
78997: LD_ADDR_VAR 0 1
79001: PUSH
79002: LD_EXP 155
79006: PUSH
79007: FOR_IN
79008: IFFALSE 79039
// if GetLives ( i ) < 1000 then
79010: LD_VAR 0 1
79014: PPUSH
79015: CALL_OW 256
79019: PUSH
79020: LD_INT 1000
79022: LESS
79023: IFFALSE 79037
// SetLives ( i , 1000 ) ;
79025: LD_VAR 0 1
79029: PPUSH
79030: LD_INT 1000
79032: PPUSH
79033: CALL_OW 234
79037: GO 79007
79039: POP
79040: POP
// end ;
79041: PPOPN 1
79043: END
// export function hHackInvincible ; var i ; begin
79044: LD_INT 0
79046: PPUSH
79047: PPUSH
// for i in FilterAllUnits ( [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ) do
79048: LD_ADDR_VAR 0 2
79052: PUSH
79053: LD_INT 2
79055: PUSH
79056: LD_INT 21
79058: PUSH
79059: LD_INT 1
79061: PUSH
79062: EMPTY
79063: LIST
79064: LIST
79065: PUSH
79066: LD_INT 21
79068: PUSH
79069: LD_INT 2
79071: PUSH
79072: EMPTY
79073: LIST
79074: LIST
79075: PUSH
79076: EMPTY
79077: LIST
79078: LIST
79079: LIST
79080: PPUSH
79081: CALL_OW 69
79085: PUSH
79086: FOR_IN
79087: IFFALSE 79148
// if IsSelected ( i ) then
79089: LD_VAR 0 2
79093: PPUSH
79094: CALL_OW 306
79098: IFFALSE 79146
// begin if i in hInvincible then
79100: LD_VAR 0 2
79104: PUSH
79105: LD_EXP 155
79109: IN
79110: IFFALSE 79130
// hInvincible := hInvincible diff i else
79112: LD_ADDR_EXP 155
79116: PUSH
79117: LD_EXP 155
79121: PUSH
79122: LD_VAR 0 2
79126: DIFF
79127: ST_TO_ADDR
79128: GO 79146
// hInvincible := hInvincible union i ;
79130: LD_ADDR_EXP 155
79134: PUSH
79135: LD_EXP 155
79139: PUSH
79140: LD_VAR 0 2
79144: UNION
79145: ST_TO_ADDR
// end ;
79146: GO 79086
79148: POP
79149: POP
// end ;
79150: LD_VAR 0 1
79154: RET
// export function hHackInvisible ; var i , j ; begin
79155: LD_INT 0
79157: PPUSH
79158: PPUSH
79159: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
79160: LD_ADDR_VAR 0 2
79164: PUSH
79165: LD_INT 21
79167: PUSH
79168: LD_INT 1
79170: PUSH
79171: EMPTY
79172: LIST
79173: LIST
79174: PPUSH
79175: CALL_OW 69
79179: PUSH
79180: FOR_IN
79181: IFFALSE 79205
// if IsSelected ( i ) then
79183: LD_VAR 0 2
79187: PPUSH
79188: CALL_OW 306
79192: IFFALSE 79203
// ComForceInvisible ( i ) ;
79194: LD_VAR 0 2
79198: PPUSH
79199: CALL_OW 496
79203: GO 79180
79205: POP
79206: POP
// end ;
79207: LD_VAR 0 1
79211: RET
// export function hHackChangeYourSide ; begin
79212: LD_INT 0
79214: PPUSH
// if your_side = 8 then
79215: LD_OWVAR 2
79219: PUSH
79220: LD_INT 8
79222: EQUAL
79223: IFFALSE 79235
// your_side := 0 else
79225: LD_ADDR_OWVAR 2
79229: PUSH
79230: LD_INT 0
79232: ST_TO_ADDR
79233: GO 79249
// your_side := your_side + 1 ;
79235: LD_ADDR_OWVAR 2
79239: PUSH
79240: LD_OWVAR 2
79244: PUSH
79245: LD_INT 1
79247: PLUS
79248: ST_TO_ADDR
// end ;
79249: LD_VAR 0 1
79253: RET
// export function hHackChangeUnitSide ; var i , j ; begin
79254: LD_INT 0
79256: PPUSH
79257: PPUSH
79258: PPUSH
// for i in all_units do
79259: LD_ADDR_VAR 0 2
79263: PUSH
79264: LD_OWVAR 3
79268: PUSH
79269: FOR_IN
79270: IFFALSE 79348
// if IsSelected ( i ) then
79272: LD_VAR 0 2
79276: PPUSH
79277: CALL_OW 306
79281: IFFALSE 79346
// begin j := GetSide ( i ) ;
79283: LD_ADDR_VAR 0 3
79287: PUSH
79288: LD_VAR 0 2
79292: PPUSH
79293: CALL_OW 255
79297: ST_TO_ADDR
// if j = 8 then
79298: LD_VAR 0 3
79302: PUSH
79303: LD_INT 8
79305: EQUAL
79306: IFFALSE 79318
// j := 0 else
79308: LD_ADDR_VAR 0 3
79312: PUSH
79313: LD_INT 0
79315: ST_TO_ADDR
79316: GO 79332
// j := j + 1 ;
79318: LD_ADDR_VAR 0 3
79322: PUSH
79323: LD_VAR 0 3
79327: PUSH
79328: LD_INT 1
79330: PLUS
79331: ST_TO_ADDR
// SetSide ( i , j ) ;
79332: LD_VAR 0 2
79336: PPUSH
79337: LD_VAR 0 3
79341: PPUSH
79342: CALL_OW 235
// end ;
79346: GO 79269
79348: POP
79349: POP
// end ;
79350: LD_VAR 0 1
79354: RET
// export function hHackFog ; begin
79355: LD_INT 0
79357: PPUSH
// FogOff ( true ) ;
79358: LD_INT 1
79360: PPUSH
79361: CALL_OW 344
// end ;
79365: LD_VAR 0 1
79369: RET
// export function hHackTeleport ( unit , x , y ) ; begin
79370: LD_INT 0
79372: PPUSH
// TeleportUnit ( unit , x , y , 1 , true ) ;
79373: LD_VAR 0 1
79377: PPUSH
79378: LD_VAR 0 2
79382: PPUSH
79383: LD_VAR 0 3
79387: PPUSH
79388: LD_INT 1
79390: PPUSH
79391: LD_INT 1
79393: PPUSH
79394: CALL_OW 483
// CenterOnXY ( x , y ) ;
79398: LD_VAR 0 2
79402: PPUSH
79403: LD_VAR 0 3
79407: PPUSH
79408: CALL_OW 84
// end ;
79412: LD_VAR 0 4
79416: RET
// export factoryWaypoints ; export function SetFactoryWaypoint ( factory , x , y ) ; var i ; begin
79417: LD_INT 0
79419: PPUSH
79420: PPUSH
// if not factory or not ValidHex ( x , y ) or ( GetBType ( factory ) <> b_factory and not GetType ( factory ) = unit_human ) then
79421: LD_VAR 0 1
79425: NOT
79426: PUSH
79427: LD_VAR 0 2
79431: PPUSH
79432: LD_VAR 0 3
79436: PPUSH
79437: CALL_OW 488
79441: NOT
79442: OR
79443: PUSH
79444: LD_VAR 0 1
79448: PPUSH
79449: CALL_OW 266
79453: PUSH
79454: LD_INT 3
79456: NONEQUAL
79457: PUSH
79458: LD_VAR 0 1
79462: PPUSH
79463: CALL_OW 247
79467: PUSH
79468: LD_INT 1
79470: EQUAL
79471: NOT
79472: AND
79473: OR
79474: IFFALSE 79478
// exit ;
79476: GO 79627
// if GetType ( factory ) = unit_human then
79478: LD_VAR 0 1
79482: PPUSH
79483: CALL_OW 247
79487: PUSH
79488: LD_INT 1
79490: EQUAL
79491: IFFALSE 79508
// factory := IsInUnit ( factory ) ;
79493: LD_ADDR_VAR 0 1
79497: PUSH
79498: LD_VAR 0 1
79502: PPUSH
79503: CALL_OW 310
79507: ST_TO_ADDR
// if GetBType ( factory ) <> b_factory then
79508: LD_VAR 0 1
79512: PPUSH
79513: CALL_OW 266
79517: PUSH
79518: LD_INT 3
79520: NONEQUAL
79521: IFFALSE 79525
// exit ;
79523: GO 79627
// if HexInfo ( x , y ) = factory then
79525: LD_VAR 0 2
79529: PPUSH
79530: LD_VAR 0 3
79534: PPUSH
79535: CALL_OW 428
79539: PUSH
79540: LD_VAR 0 1
79544: EQUAL
79545: IFFALSE 79572
// factoryWaypoints := Replace ( factoryWaypoints , factory , 0 ) else
79547: LD_ADDR_EXP 156
79551: PUSH
79552: LD_EXP 156
79556: PPUSH
79557: LD_VAR 0 1
79561: PPUSH
79562: LD_INT 0
79564: PPUSH
79565: CALL_OW 1
79569: ST_TO_ADDR
79570: GO 79623
// factoryWaypoints := Replace ( factoryWaypoints , factory , [ GetSide ( factory ) , factory , x , y ] ) ;
79572: LD_ADDR_EXP 156
79576: PUSH
79577: LD_EXP 156
79581: PPUSH
79582: LD_VAR 0 1
79586: PPUSH
79587: LD_VAR 0 1
79591: PPUSH
79592: CALL_OW 255
79596: PUSH
79597: LD_VAR 0 1
79601: PUSH
79602: LD_VAR 0 2
79606: PUSH
79607: LD_VAR 0 3
79611: PUSH
79612: EMPTY
79613: LIST
79614: LIST
79615: LIST
79616: LIST
79617: PPUSH
79618: CALL_OW 1
79622: ST_TO_ADDR
// UpdateFactoryWaypoints ;
79623: CALL 79632 0 0
// end ;
79627: LD_VAR 0 4
79631: RET
// export function UpdateFactoryWaypoints ( ) ; var i , list ; begin
79632: LD_INT 0
79634: PPUSH
79635: PPUSH
79636: PPUSH
// ToLua ( resetFactoryWaypoint(); ) ;
79637: LD_STRING resetFactoryWaypoint();
79639: PPUSH
79640: CALL_OW 559
// if factoryWaypoints then
79644: LD_EXP 156
79648: IFFALSE 79774
// begin list := PrepareArray ( factoryWaypoints ) ;
79650: LD_ADDR_VAR 0 3
79654: PUSH
79655: LD_EXP 156
79659: PPUSH
79660: CALL 60450 0 1
79664: ST_TO_ADDR
// for i := 1 to list do
79665: LD_ADDR_VAR 0 2
79669: PUSH
79670: DOUBLE
79671: LD_INT 1
79673: DEC
79674: ST_TO_ADDR
79675: LD_VAR 0 3
79679: PUSH
79680: FOR_TO
79681: IFFALSE 79772
// ToLua ( setFactoryWaypointXY( & list [ i ] [ 1 ] & , & list [ i ] [ 2 ] & , & list [ i ] [ 3 ] & , & list [ i ] [ 4 ] & ) ) ;
79683: LD_STRING setFactoryWaypointXY(
79685: PUSH
79686: LD_VAR 0 3
79690: PUSH
79691: LD_VAR 0 2
79695: ARRAY
79696: PUSH
79697: LD_INT 1
79699: ARRAY
79700: STR
79701: PUSH
79702: LD_STRING ,
79704: STR
79705: PUSH
79706: LD_VAR 0 3
79710: PUSH
79711: LD_VAR 0 2
79715: ARRAY
79716: PUSH
79717: LD_INT 2
79719: ARRAY
79720: STR
79721: PUSH
79722: LD_STRING ,
79724: STR
79725: PUSH
79726: LD_VAR 0 3
79730: PUSH
79731: LD_VAR 0 2
79735: ARRAY
79736: PUSH
79737: LD_INT 3
79739: ARRAY
79740: STR
79741: PUSH
79742: LD_STRING ,
79744: STR
79745: PUSH
79746: LD_VAR 0 3
79750: PUSH
79751: LD_VAR 0 2
79755: ARRAY
79756: PUSH
79757: LD_INT 4
79759: ARRAY
79760: STR
79761: PUSH
79762: LD_STRING )
79764: STR
79765: PPUSH
79766: CALL_OW 559
79770: GO 79680
79772: POP
79773: POP
// end ; end ;
79774: LD_VAR 0 1
79778: RET
// export warehouseGatheringPoints , warehouseCratesCollectors ; export function SetWarehouseGatheringPoint ( warehouse , x , y ) ; begin
79779: LD_INT 0
79781: PPUSH
// if HexInfo ( x , y ) = warehouse then
79782: LD_VAR 0 2
79786: PPUSH
79787: LD_VAR 0 3
79791: PPUSH
79792: CALL_OW 428
79796: PUSH
79797: LD_VAR 0 1
79801: EQUAL
79802: IFFALSE 79829
// warehouseGatheringPoints := Replace ( warehouseGatheringPoints , warehouse , 0 ) else
79804: LD_ADDR_EXP 157
79808: PUSH
79809: LD_EXP 157
79813: PPUSH
79814: LD_VAR 0 1
79818: PPUSH
79819: LD_INT 0
79821: PPUSH
79822: CALL_OW 1
79826: ST_TO_ADDR
79827: GO 79880
// warehouseGatheringPoints := Replace ( warehouseGatheringPoints , warehouse , [ GetSide ( warehouse ) , warehouse , x , y ] ) ;
79829: LD_ADDR_EXP 157
79833: PUSH
79834: LD_EXP 157
79838: PPUSH
79839: LD_VAR 0 1
79843: PPUSH
79844: LD_VAR 0 1
79848: PPUSH
79849: CALL_OW 255
79853: PUSH
79854: LD_VAR 0 1
79858: PUSH
79859: LD_VAR 0 2
79863: PUSH
79864: LD_VAR 0 3
79868: PUSH
79869: EMPTY
79870: LIST
79871: LIST
79872: LIST
79873: LIST
79874: PPUSH
79875: CALL_OW 1
79879: ST_TO_ADDR
// UpdateWarehouseGatheringPoints ;
79880: CALL 79889 0 0
// end ;
79884: LD_VAR 0 4
79888: RET
// export function UpdateWarehouseGatheringPoints ( ) ; var i , list ; begin
79889: LD_INT 0
79891: PPUSH
79892: PPUSH
79893: PPUSH
// ToLua ( resetWarehouseGatheringPoints(); ) ;
79894: LD_STRING resetWarehouseGatheringPoints();
79896: PPUSH
79897: CALL_OW 559
// if warehouseGatheringPoints then
79901: LD_EXP 157
79905: IFFALSE 80031
// begin list := PrepareArray ( warehouseGatheringPoints ) ;
79907: LD_ADDR_VAR 0 3
79911: PUSH
79912: LD_EXP 157
79916: PPUSH
79917: CALL 60450 0 1
79921: ST_TO_ADDR
// for i := 1 to list do
79922: LD_ADDR_VAR 0 2
79926: PUSH
79927: DOUBLE
79928: LD_INT 1
79930: DEC
79931: ST_TO_ADDR
79932: LD_VAR 0 3
79936: PUSH
79937: FOR_TO
79938: IFFALSE 80029
// ToLua ( setWarehouseGatheringPointXY( & list [ i ] [ 1 ] & , & list [ i ] [ 2 ] & , & list [ i ] [ 3 ] & , & list [ i ] [ 4 ] & ) ) ;
79940: LD_STRING setWarehouseGatheringPointXY(
79942: PUSH
79943: LD_VAR 0 3
79947: PUSH
79948: LD_VAR 0 2
79952: ARRAY
79953: PUSH
79954: LD_INT 1
79956: ARRAY
79957: STR
79958: PUSH
79959: LD_STRING ,
79961: STR
79962: PUSH
79963: LD_VAR 0 3
79967: PUSH
79968: LD_VAR 0 2
79972: ARRAY
79973: PUSH
79974: LD_INT 2
79976: ARRAY
79977: STR
79978: PUSH
79979: LD_STRING ,
79981: STR
79982: PUSH
79983: LD_VAR 0 3
79987: PUSH
79988: LD_VAR 0 2
79992: ARRAY
79993: PUSH
79994: LD_INT 3
79996: ARRAY
79997: STR
79998: PUSH
79999: LD_STRING ,
80001: STR
80002: PUSH
80003: LD_VAR 0 3
80007: PUSH
80008: LD_VAR 0 2
80012: ARRAY
80013: PUSH
80014: LD_INT 4
80016: ARRAY
80017: STR
80018: PUSH
80019: LD_STRING )
80021: STR
80022: PPUSH
80023: CALL_OW 559
80027: GO 79937
80029: POP
80030: POP
// end ; end ;
80031: LD_VAR 0 1
80035: RET
// every 0 0$20 trigger warehouseGatheringPoints do var i , j , list , tmp , side , x , y , depot , cratesNearbyPoint ;
80036: LD_EXP 157
80040: IFFALSE 80725
80042: GO 80044
80044: DISABLE
80045: LD_INT 0
80047: PPUSH
80048: PPUSH
80049: PPUSH
80050: PPUSH
80051: PPUSH
80052: PPUSH
80053: PPUSH
80054: PPUSH
80055: PPUSH
// begin enable ;
80056: ENABLE
// list := PrepareArray ( warehouseGatheringPoints ) ;
80057: LD_ADDR_VAR 0 3
80061: PUSH
80062: LD_EXP 157
80066: PPUSH
80067: CALL 60450 0 1
80071: ST_TO_ADDR
// if not list then
80072: LD_VAR 0 3
80076: NOT
80077: IFFALSE 80081
// exit ;
80079: GO 80725
// for i := 1 to list do
80081: LD_ADDR_VAR 0 1
80085: PUSH
80086: DOUBLE
80087: LD_INT 1
80089: DEC
80090: ST_TO_ADDR
80091: LD_VAR 0 3
80095: PUSH
80096: FOR_TO
80097: IFFALSE 80723
// begin depot := list [ i ] [ 2 ] ;
80099: LD_ADDR_VAR 0 8
80103: PUSH
80104: LD_VAR 0 3
80108: PUSH
80109: LD_VAR 0 1
80113: ARRAY
80114: PUSH
80115: LD_INT 2
80117: ARRAY
80118: ST_TO_ADDR
// side := list [ i ] [ 1 ] ;
80119: LD_ADDR_VAR 0 5
80123: PUSH
80124: LD_VAR 0 3
80128: PUSH
80129: LD_VAR 0 1
80133: ARRAY
80134: PUSH
80135: LD_INT 1
80137: ARRAY
80138: ST_TO_ADDR
// if IsDead ( depot ) or side <> GetSide ( depot ) then
80139: LD_VAR 0 8
80143: PPUSH
80144: CALL_OW 301
80148: PUSH
80149: LD_VAR 0 5
80153: PUSH
80154: LD_VAR 0 8
80158: PPUSH
80159: CALL_OW 255
80163: NONEQUAL
80164: OR
80165: IFFALSE 80194
// begin warehouseGatheringPoints := Replace ( warehouseGatheringPoints , depot , 0 ) ;
80167: LD_ADDR_EXP 157
80171: PUSH
80172: LD_EXP 157
80176: PPUSH
80177: LD_VAR 0 8
80181: PPUSH
80182: LD_INT 0
80184: PPUSH
80185: CALL_OW 1
80189: ST_TO_ADDR
// exit ;
80190: POP
80191: POP
80192: GO 80725
// end ; x := list [ i ] [ 3 ] ;
80194: LD_ADDR_VAR 0 6
80198: PUSH
80199: LD_VAR 0 3
80203: PUSH
80204: LD_VAR 0 1
80208: ARRAY
80209: PUSH
80210: LD_INT 3
80212: ARRAY
80213: ST_TO_ADDR
// y := list [ i ] [ 4 ] ;
80214: LD_ADDR_VAR 0 7
80218: PUSH
80219: LD_VAR 0 3
80223: PUSH
80224: LD_VAR 0 1
80228: ARRAY
80229: PUSH
80230: LD_INT 4
80232: ARRAY
80233: ST_TO_ADDR
// cratesNearbyPoint := GetCratesNearbyXY ( x , y , 16 ) ;
80234: LD_ADDR_VAR 0 9
80238: PUSH
80239: LD_VAR 0 6
80243: PPUSH
80244: LD_VAR 0 7
80248: PPUSH
80249: LD_INT 16
80251: PPUSH
80252: CALL 59038 0 3
80256: ST_TO_ADDR
// if not cratesNearbyPoint then
80257: LD_VAR 0 9
80261: NOT
80262: IFFALSE 80268
// exit ;
80264: POP
80265: POP
80266: GO 80725
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_hastask ] ] , [ f_dist , depot , 6 ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] ] ] ) union UnitFilter ( UnitsInside ( depot ) , [ [ f_not , [ f_hastask ] ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] ] ] ) ;
80268: LD_ADDR_VAR 0 4
80272: PUSH
80273: LD_INT 22
80275: PUSH
80276: LD_VAR 0 5
80280: PUSH
80281: EMPTY
80282: LIST
80283: LIST
80284: PUSH
80285: LD_INT 3
80287: PUSH
80288: LD_INT 60
80290: PUSH
80291: EMPTY
80292: LIST
80293: PUSH
80294: EMPTY
80295: LIST
80296: LIST
80297: PUSH
80298: LD_INT 91
80300: PUSH
80301: LD_VAR 0 8
80305: PUSH
80306: LD_INT 6
80308: PUSH
80309: EMPTY
80310: LIST
80311: LIST
80312: LIST
80313: PUSH
80314: LD_INT 2
80316: PUSH
80317: LD_INT 25
80319: PUSH
80320: LD_INT 2
80322: PUSH
80323: EMPTY
80324: LIST
80325: LIST
80326: PUSH
80327: LD_INT 25
80329: PUSH
80330: LD_INT 16
80332: PUSH
80333: EMPTY
80334: LIST
80335: LIST
80336: PUSH
80337: EMPTY
80338: LIST
80339: LIST
80340: LIST
80341: PUSH
80342: EMPTY
80343: LIST
80344: LIST
80345: LIST
80346: LIST
80347: PPUSH
80348: CALL_OW 69
80352: PUSH
80353: LD_VAR 0 8
80357: PPUSH
80358: CALL_OW 313
80362: PPUSH
80363: LD_INT 3
80365: PUSH
80366: LD_INT 60
80368: PUSH
80369: EMPTY
80370: LIST
80371: PUSH
80372: EMPTY
80373: LIST
80374: LIST
80375: PUSH
80376: LD_INT 2
80378: PUSH
80379: LD_INT 25
80381: PUSH
80382: LD_INT 2
80384: PUSH
80385: EMPTY
80386: LIST
80387: LIST
80388: PUSH
80389: LD_INT 25
80391: PUSH
80392: LD_INT 16
80394: PUSH
80395: EMPTY
80396: LIST
80397: LIST
80398: PUSH
80399: EMPTY
80400: LIST
80401: LIST
80402: LIST
80403: PUSH
80404: EMPTY
80405: LIST
80406: LIST
80407: PPUSH
80408: CALL_OW 72
80412: UNION
80413: ST_TO_ADDR
// if tmp then
80414: LD_VAR 0 4
80418: IFFALSE 80498
// begin tmp := ShrinkArray ( tmp , 3 ) ;
80420: LD_ADDR_VAR 0 4
80424: PUSH
80425: LD_VAR 0 4
80429: PPUSH
80430: LD_INT 3
80432: PPUSH
80433: CALL 57007 0 2
80437: ST_TO_ADDR
// for j in tmp do
80438: LD_ADDR_VAR 0 2
80442: PUSH
80443: LD_VAR 0 4
80447: PUSH
80448: FOR_IN
80449: IFFALSE 80492
// begin if IsInUnit ( j ) then
80451: LD_VAR 0 2
80455: PPUSH
80456: CALL_OW 310
80460: IFFALSE 80471
// ComExit ( j ) ;
80462: LD_VAR 0 2
80466: PPUSH
80467: CALL 57090 0 1
// AddComCollect ( j , x , y ) ;
80471: LD_VAR 0 2
80475: PPUSH
80476: LD_VAR 0 6
80480: PPUSH
80481: LD_VAR 0 7
80485: PPUSH
80486: CALL_OW 177
// end ;
80490: GO 80448
80492: POP
80493: POP
// exit ;
80494: POP
80495: POP
80496: GO 80725
// end ; tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_dist , depot , 8 ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ] ) ;
80498: LD_ADDR_VAR 0 4
80502: PUSH
80503: LD_INT 22
80505: PUSH
80506: LD_VAR 0 5
80510: PUSH
80511: EMPTY
80512: LIST
80513: LIST
80514: PUSH
80515: LD_INT 91
80517: PUSH
80518: LD_VAR 0 8
80522: PUSH
80523: LD_INT 8
80525: PUSH
80526: EMPTY
80527: LIST
80528: LIST
80529: LIST
80530: PUSH
80531: LD_INT 2
80533: PUSH
80534: LD_INT 34
80536: PUSH
80537: LD_INT 12
80539: PUSH
80540: EMPTY
80541: LIST
80542: LIST
80543: PUSH
80544: LD_INT 34
80546: PUSH
80547: LD_INT 51
80549: PUSH
80550: EMPTY
80551: LIST
80552: LIST
80553: PUSH
80554: LD_INT 34
80556: PUSH
80557: LD_INT 32
80559: PUSH
80560: EMPTY
80561: LIST
80562: LIST
80563: PUSH
80564: LD_INT 34
80566: PUSH
80567: LD_INT 89
80569: PUSH
80570: EMPTY
80571: LIST
80572: LIST
80573: PUSH
80574: EMPTY
80575: LIST
80576: LIST
80577: LIST
80578: LIST
80579: LIST
80580: PUSH
80581: EMPTY
80582: LIST
80583: LIST
80584: LIST
80585: PPUSH
80586: CALL_OW 69
80590: ST_TO_ADDR
// if tmp then
80591: LD_VAR 0 4
80595: IFFALSE 80721
// begin for j in tmp do
80597: LD_ADDR_VAR 0 2
80601: PUSH
80602: LD_VAR 0 4
80606: PUSH
80607: FOR_IN
80608: IFFALSE 80719
// if ( GetEngine ( j ) = engine_siberite or GetFuel ( j ) > 20 ) and not HasTask ( j ) and ( GetControl ( j ) <> control_manual or IsDrivenBy ( j ) ) then
80610: LD_VAR 0 2
80614: PPUSH
80615: CALL_OW 262
80619: PUSH
80620: LD_INT 3
80622: EQUAL
80623: PUSH
80624: LD_VAR 0 2
80628: PPUSH
80629: CALL_OW 261
80633: PUSH
80634: LD_INT 20
80636: GREATER
80637: OR
80638: PUSH
80639: LD_VAR 0 2
80643: PPUSH
80644: CALL_OW 314
80648: NOT
80649: AND
80650: PUSH
80651: LD_VAR 0 2
80655: PPUSH
80656: CALL_OW 263
80660: PUSH
80661: LD_INT 1
80663: NONEQUAL
80664: PUSH
80665: LD_VAR 0 2
80669: PPUSH
80670: CALL_OW 311
80674: OR
80675: AND
80676: IFFALSE 80717
// begin ComCollect ( j , x , y ) ;
80678: LD_VAR 0 2
80682: PPUSH
80683: LD_VAR 0 6
80687: PPUSH
80688: LD_VAR 0 7
80692: PPUSH
80693: CALL_OW 117
// AddComMoveUnit ( j , depot ) ;
80697: LD_VAR 0 2
80701: PPUSH
80702: LD_VAR 0 8
80706: PPUSH
80707: CALL_OW 172
// exit ;
80711: POP
80712: POP
80713: POP
80714: POP
80715: GO 80725
// end ;
80717: GO 80607
80719: POP
80720: POP
// end ; end ;
80721: GO 80096
80723: POP
80724: POP
// end ; end_of_file
80725: PPOPN 9
80727: END
// export ru_radar on TargetableSAIL ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) do begin case cmd of 200 .. 299 :
80728: LD_VAR 0 1
80732: PUSH
80733: LD_INT 200
80735: DOUBLE
80736: GREATEREQUAL
80737: IFFALSE 80745
80739: LD_INT 299
80741: DOUBLE
80742: LESSEQUAL
80743: IFTRUE 80747
80745: GO 80779
80747: POP
// SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; 300 .. 399 :
80748: LD_VAR 0 1
80752: PPUSH
80753: LD_VAR 0 2
80757: PPUSH
80758: LD_VAR 0 3
80762: PPUSH
80763: LD_VAR 0 4
80767: PPUSH
80768: LD_VAR 0 5
80772: PPUSH
80773: CALL 61021 0 5
80777: GO 80856
80779: LD_INT 300
80781: DOUBLE
80782: GREATEREQUAL
80783: IFFALSE 80791
80785: LD_INT 399
80787: DOUBLE
80788: LESSEQUAL
80789: IFTRUE 80793
80791: GO 80855
80793: POP
// SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; end ;
80794: LD_VAR 0 1
80798: PPUSH
80799: LD_VAR 0 2
80803: PPUSH
80804: LD_VAR 0 3
80808: PPUSH
80809: LD_VAR 0 4
80813: PPUSH
80814: LD_VAR 0 5
80818: PPUSH
80819: LD_VAR 0 6
80823: PPUSH
80824: LD_VAR 0 7
80828: PPUSH
80829: LD_VAR 0 8
80833: PPUSH
80834: LD_VAR 0 9
80838: PPUSH
80839: LD_VAR 0 10
80843: PPUSH
80844: LD_VAR 0 11
80848: PPUSH
80849: CALL 77437 0 11
80853: GO 80856
80855: POP
// end ;
80856: PPOPN 11
80858: END
// on CommandUnitXY ( cmd , un , target , x , y ) do begin SOS_CommandUnitXY ( cmd , un , target , x , y ) ;
80859: LD_VAR 0 1
80863: PPUSH
80864: LD_VAR 0 2
80868: PPUSH
80869: LD_VAR 0 3
80873: PPUSH
80874: LD_VAR 0 4
80878: PPUSH
80879: LD_VAR 0 5
80883: PPUSH
80884: CALL 60757 0 5
// end ; end_of_file
80888: PPOPN 5
80890: END
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
80891: LD_INT 0
80893: PPUSH
80894: PPUSH
80895: PPUSH
80896: PPUSH
80897: PPUSH
80898: PPUSH
80899: PPUSH
80900: PPUSH
80901: PPUSH
80902: PPUSH
80903: PPUSH
80904: PPUSH
80905: PPUSH
80906: PPUSH
80907: PPUSH
80908: PPUSH
80909: PPUSH
80910: PPUSH
80911: PPUSH
80912: PPUSH
80913: PPUSH
80914: PPUSH
80915: PPUSH
80916: PPUSH
80917: PPUSH
80918: PPUSH
80919: PPUSH
80920: PPUSH
80921: PPUSH
80922: PPUSH
80923: PPUSH
80924: PPUSH
80925: PPUSH
80926: PPUSH
// if not list then
80927: LD_VAR 0 1
80931: NOT
80932: IFFALSE 80936
// exit ;
80934: GO 85595
// base := list [ 1 ] ;
80936: LD_ADDR_VAR 0 3
80940: PUSH
80941: LD_VAR 0 1
80945: PUSH
80946: LD_INT 1
80948: ARRAY
80949: ST_TO_ADDR
// group := list [ 2 ] ;
80950: LD_ADDR_VAR 0 4
80954: PUSH
80955: LD_VAR 0 1
80959: PUSH
80960: LD_INT 2
80962: ARRAY
80963: ST_TO_ADDR
// path := list [ 3 ] ;
80964: LD_ADDR_VAR 0 5
80968: PUSH
80969: LD_VAR 0 1
80973: PUSH
80974: LD_INT 3
80976: ARRAY
80977: ST_TO_ADDR
// flags := list [ 4 ] ;
80978: LD_ADDR_VAR 0 6
80982: PUSH
80983: LD_VAR 0 1
80987: PUSH
80988: LD_INT 4
80990: ARRAY
80991: ST_TO_ADDR
// mined := [ ] ;
80992: LD_ADDR_VAR 0 27
80996: PUSH
80997: EMPTY
80998: ST_TO_ADDR
// bombed := [ ] ;
80999: LD_ADDR_VAR 0 28
81003: PUSH
81004: EMPTY
81005: ST_TO_ADDR
// healers := [ ] ;
81006: LD_ADDR_VAR 0 31
81010: PUSH
81011: EMPTY
81012: ST_TO_ADDR
// to_heal := [ ] ;
81013: LD_ADDR_VAR 0 30
81017: PUSH
81018: EMPTY
81019: ST_TO_ADDR
// repairs := [ ] ;
81020: LD_ADDR_VAR 0 33
81024: PUSH
81025: EMPTY
81026: ST_TO_ADDR
// to_repair := [ ] ;
81027: LD_ADDR_VAR 0 32
81031: PUSH
81032: EMPTY
81033: ST_TO_ADDR
// if not group or not path then
81034: LD_VAR 0 4
81038: NOT
81039: PUSH
81040: LD_VAR 0 5
81044: NOT
81045: OR
81046: IFFALSE 81050
// exit ;
81048: GO 85595
// side := GetSide ( group [ 1 ] ) ;
81050: LD_ADDR_VAR 0 35
81054: PUSH
81055: LD_VAR 0 4
81059: PUSH
81060: LD_INT 1
81062: ARRAY
81063: PPUSH
81064: CALL_OW 255
81068: ST_TO_ADDR
// if flags then
81069: LD_VAR 0 6
81073: IFFALSE 81217
// begin f_ignore_area := flags [ 1 ] ;
81075: LD_ADDR_VAR 0 17
81079: PUSH
81080: LD_VAR 0 6
81084: PUSH
81085: LD_INT 1
81087: ARRAY
81088: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
81089: LD_ADDR_VAR 0 18
81093: PUSH
81094: LD_VAR 0 6
81098: PUSH
81099: LD_INT 2
81101: ARRAY
81102: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
81103: LD_ADDR_VAR 0 19
81107: PUSH
81108: LD_VAR 0 6
81112: PUSH
81113: LD_INT 3
81115: ARRAY
81116: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
81117: LD_ADDR_VAR 0 20
81121: PUSH
81122: LD_VAR 0 6
81126: PUSH
81127: LD_INT 4
81129: ARRAY
81130: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
81131: LD_ADDR_VAR 0 21
81135: PUSH
81136: LD_VAR 0 6
81140: PUSH
81141: LD_INT 5
81143: ARRAY
81144: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
81145: LD_ADDR_VAR 0 22
81149: PUSH
81150: LD_VAR 0 6
81154: PUSH
81155: LD_INT 6
81157: ARRAY
81158: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
81159: LD_ADDR_VAR 0 23
81163: PUSH
81164: LD_VAR 0 6
81168: PUSH
81169: LD_INT 7
81171: ARRAY
81172: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
81173: LD_ADDR_VAR 0 24
81177: PUSH
81178: LD_VAR 0 6
81182: PUSH
81183: LD_INT 8
81185: ARRAY
81186: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
81187: LD_ADDR_VAR 0 25
81191: PUSH
81192: LD_VAR 0 6
81196: PUSH
81197: LD_INT 9
81199: ARRAY
81200: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
81201: LD_ADDR_VAR 0 26
81205: PUSH
81206: LD_VAR 0 6
81210: PUSH
81211: LD_INT 10
81213: ARRAY
81214: ST_TO_ADDR
// end else
81215: GO 81297
// begin f_ignore_area := false ;
81217: LD_ADDR_VAR 0 17
81221: PUSH
81222: LD_INT 0
81224: ST_TO_ADDR
// f_capture := false ;
81225: LD_ADDR_VAR 0 18
81229: PUSH
81230: LD_INT 0
81232: ST_TO_ADDR
// f_ignore_civ := false ;
81233: LD_ADDR_VAR 0 19
81237: PUSH
81238: LD_INT 0
81240: ST_TO_ADDR
// f_murder := false ;
81241: LD_ADDR_VAR 0 20
81245: PUSH
81246: LD_INT 0
81248: ST_TO_ADDR
// f_mines := false ;
81249: LD_ADDR_VAR 0 21
81253: PUSH
81254: LD_INT 0
81256: ST_TO_ADDR
// f_repair := false ;
81257: LD_ADDR_VAR 0 22
81261: PUSH
81262: LD_INT 0
81264: ST_TO_ADDR
// f_heal := false ;
81265: LD_ADDR_VAR 0 23
81269: PUSH
81270: LD_INT 0
81272: ST_TO_ADDR
// f_spacetime := false ;
81273: LD_ADDR_VAR 0 24
81277: PUSH
81278: LD_INT 0
81280: ST_TO_ADDR
// f_attack_depot := false ;
81281: LD_ADDR_VAR 0 25
81285: PUSH
81286: LD_INT 0
81288: ST_TO_ADDR
// f_crawl := false ;
81289: LD_ADDR_VAR 0 26
81293: PUSH
81294: LD_INT 0
81296: ST_TO_ADDR
// end ; if f_heal then
81297: LD_VAR 0 23
81301: IFFALSE 81328
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
81303: LD_ADDR_VAR 0 31
81307: PUSH
81308: LD_VAR 0 4
81312: PPUSH
81313: LD_INT 25
81315: PUSH
81316: LD_INT 4
81318: PUSH
81319: EMPTY
81320: LIST
81321: LIST
81322: PPUSH
81323: CALL_OW 72
81327: ST_TO_ADDR
// if f_repair then
81328: LD_VAR 0 22
81332: IFFALSE 81359
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
81334: LD_ADDR_VAR 0 33
81338: PUSH
81339: LD_VAR 0 4
81343: PPUSH
81344: LD_INT 25
81346: PUSH
81347: LD_INT 3
81349: PUSH
81350: EMPTY
81351: LIST
81352: LIST
81353: PPUSH
81354: CALL_OW 72
81358: ST_TO_ADDR
// units_path := [ ] ;
81359: LD_ADDR_VAR 0 16
81363: PUSH
81364: EMPTY
81365: ST_TO_ADDR
// for i = 1 to group do
81366: LD_ADDR_VAR 0 7
81370: PUSH
81371: DOUBLE
81372: LD_INT 1
81374: DEC
81375: ST_TO_ADDR
81376: LD_VAR 0 4
81380: PUSH
81381: FOR_TO
81382: IFFALSE 81411
// units_path := Replace ( units_path , i , path ) ;
81384: LD_ADDR_VAR 0 16
81388: PUSH
81389: LD_VAR 0 16
81393: PPUSH
81394: LD_VAR 0 7
81398: PPUSH
81399: LD_VAR 0 5
81403: PPUSH
81404: CALL_OW 1
81408: ST_TO_ADDR
81409: GO 81381
81411: POP
81412: POP
// repeat for i = group downto 1 do
81413: LD_ADDR_VAR 0 7
81417: PUSH
81418: DOUBLE
81419: LD_VAR 0 4
81423: INC
81424: ST_TO_ADDR
81425: LD_INT 1
81427: PUSH
81428: FOR_DOWNTO
81429: IFFALSE 85551
// begin wait ( 5 ) ;
81431: LD_INT 5
81433: PPUSH
81434: CALL_OW 67
// tmp := [ ] ;
81438: LD_ADDR_VAR 0 14
81442: PUSH
81443: EMPTY
81444: ST_TO_ADDR
// attacking := false ;
81445: LD_ADDR_VAR 0 29
81449: PUSH
81450: LD_INT 0
81452: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
81453: LD_VAR 0 4
81457: PUSH
81458: LD_VAR 0 7
81462: ARRAY
81463: PPUSH
81464: CALL_OW 301
81468: PUSH
81469: LD_VAR 0 4
81473: PUSH
81474: LD_VAR 0 7
81478: ARRAY
81479: NOT
81480: OR
81481: IFFALSE 81590
// begin if GetType ( group [ i ] ) = unit_human then
81483: LD_VAR 0 4
81487: PUSH
81488: LD_VAR 0 7
81492: ARRAY
81493: PPUSH
81494: CALL_OW 247
81498: PUSH
81499: LD_INT 1
81501: EQUAL
81502: IFFALSE 81548
// begin to_heal := to_heal diff group [ i ] ;
81504: LD_ADDR_VAR 0 30
81508: PUSH
81509: LD_VAR 0 30
81513: PUSH
81514: LD_VAR 0 4
81518: PUSH
81519: LD_VAR 0 7
81523: ARRAY
81524: DIFF
81525: ST_TO_ADDR
// healers := healers diff group [ i ] ;
81526: LD_ADDR_VAR 0 31
81530: PUSH
81531: LD_VAR 0 31
81535: PUSH
81536: LD_VAR 0 4
81540: PUSH
81541: LD_VAR 0 7
81545: ARRAY
81546: DIFF
81547: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
81548: LD_ADDR_VAR 0 4
81552: PUSH
81553: LD_VAR 0 4
81557: PPUSH
81558: LD_VAR 0 7
81562: PPUSH
81563: CALL_OW 3
81567: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
81568: LD_ADDR_VAR 0 16
81572: PUSH
81573: LD_VAR 0 16
81577: PPUSH
81578: LD_VAR 0 7
81582: PPUSH
81583: CALL_OW 3
81587: ST_TO_ADDR
// continue ;
81588: GO 81428
// end ; if f_repair then
81590: LD_VAR 0 22
81594: IFFALSE 82083
// begin if GetType ( group [ i ] ) = unit_vehicle then
81596: LD_VAR 0 4
81600: PUSH
81601: LD_VAR 0 7
81605: ARRAY
81606: PPUSH
81607: CALL_OW 247
81611: PUSH
81612: LD_INT 2
81614: EQUAL
81615: IFFALSE 81805
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
81617: LD_VAR 0 4
81621: PUSH
81622: LD_VAR 0 7
81626: ARRAY
81627: PPUSH
81628: CALL_OW 256
81632: PUSH
81633: LD_INT 700
81635: LESS
81636: PUSH
81637: LD_VAR 0 4
81641: PUSH
81642: LD_VAR 0 7
81646: ARRAY
81647: PUSH
81648: LD_VAR 0 32
81652: IN
81653: NOT
81654: AND
81655: IFFALSE 81679
// to_repair := to_repair union group [ i ] ;
81657: LD_ADDR_VAR 0 32
81661: PUSH
81662: LD_VAR 0 32
81666: PUSH
81667: LD_VAR 0 4
81671: PUSH
81672: LD_VAR 0 7
81676: ARRAY
81677: UNION
81678: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
81679: LD_VAR 0 4
81683: PUSH
81684: LD_VAR 0 7
81688: ARRAY
81689: PPUSH
81690: CALL_OW 256
81694: PUSH
81695: LD_INT 1000
81697: EQUAL
81698: PUSH
81699: LD_VAR 0 4
81703: PUSH
81704: LD_VAR 0 7
81708: ARRAY
81709: PUSH
81710: LD_VAR 0 32
81714: IN
81715: AND
81716: IFFALSE 81740
// to_repair := to_repair diff group [ i ] ;
81718: LD_ADDR_VAR 0 32
81722: PUSH
81723: LD_VAR 0 32
81727: PUSH
81728: LD_VAR 0 4
81732: PUSH
81733: LD_VAR 0 7
81737: ARRAY
81738: DIFF
81739: ST_TO_ADDR
// if group [ i ] in to_repair then
81740: LD_VAR 0 4
81744: PUSH
81745: LD_VAR 0 7
81749: ARRAY
81750: PUSH
81751: LD_VAR 0 32
81755: IN
81756: IFFALSE 81803
// begin if not IsInArea ( group [ i ] , f_repair ) then
81758: LD_VAR 0 4
81762: PUSH
81763: LD_VAR 0 7
81767: ARRAY
81768: PPUSH
81769: LD_VAR 0 22
81773: PPUSH
81774: CALL_OW 308
81778: NOT
81779: IFFALSE 81801
// ComMoveToArea ( group [ i ] , f_repair ) ;
81781: LD_VAR 0 4
81785: PUSH
81786: LD_VAR 0 7
81790: ARRAY
81791: PPUSH
81792: LD_VAR 0 22
81796: PPUSH
81797: CALL_OW 113
// continue ;
81801: GO 81428
// end ; end else
81803: GO 82083
// if group [ i ] in repairs then
81805: LD_VAR 0 4
81809: PUSH
81810: LD_VAR 0 7
81814: ARRAY
81815: PUSH
81816: LD_VAR 0 33
81820: IN
81821: IFFALSE 82083
// begin if IsInUnit ( group [ i ] ) then
81823: LD_VAR 0 4
81827: PUSH
81828: LD_VAR 0 7
81832: ARRAY
81833: PPUSH
81834: CALL_OW 310
81838: IFFALSE 81906
// begin z := IsInUnit ( group [ i ] ) ;
81840: LD_ADDR_VAR 0 13
81844: PUSH
81845: LD_VAR 0 4
81849: PUSH
81850: LD_VAR 0 7
81854: ARRAY
81855: PPUSH
81856: CALL_OW 310
81860: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
81861: LD_VAR 0 13
81865: PUSH
81866: LD_VAR 0 32
81870: IN
81871: PUSH
81872: LD_VAR 0 13
81876: PPUSH
81877: LD_VAR 0 22
81881: PPUSH
81882: CALL_OW 308
81886: AND
81887: IFFALSE 81904
// ComExitVehicle ( group [ i ] ) ;
81889: LD_VAR 0 4
81893: PUSH
81894: LD_VAR 0 7
81898: ARRAY
81899: PPUSH
81900: CALL_OW 121
// end else
81904: GO 82083
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
81906: LD_ADDR_VAR 0 13
81910: PUSH
81911: LD_VAR 0 4
81915: PPUSH
81916: LD_INT 95
81918: PUSH
81919: LD_VAR 0 22
81923: PUSH
81924: EMPTY
81925: LIST
81926: LIST
81927: PUSH
81928: LD_INT 58
81930: PUSH
81931: EMPTY
81932: LIST
81933: PUSH
81934: EMPTY
81935: LIST
81936: LIST
81937: PPUSH
81938: CALL_OW 72
81942: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
81943: LD_VAR 0 4
81947: PUSH
81948: LD_VAR 0 7
81952: ARRAY
81953: PPUSH
81954: CALL_OW 314
81958: NOT
81959: IFFALSE 82081
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
81961: LD_ADDR_VAR 0 10
81965: PUSH
81966: LD_VAR 0 13
81970: PPUSH
81971: LD_VAR 0 4
81975: PUSH
81976: LD_VAR 0 7
81980: ARRAY
81981: PPUSH
81982: CALL_OW 74
81986: ST_TO_ADDR
// if not x then
81987: LD_VAR 0 10
81991: NOT
81992: IFFALSE 81996
// continue ;
81994: GO 81428
// if GetLives ( x ) < 1000 then
81996: LD_VAR 0 10
82000: PPUSH
82001: CALL_OW 256
82005: PUSH
82006: LD_INT 1000
82008: LESS
82009: IFFALSE 82033
// ComRepairVehicle ( group [ i ] , x ) else
82011: LD_VAR 0 4
82015: PUSH
82016: LD_VAR 0 7
82020: ARRAY
82021: PPUSH
82022: LD_VAR 0 10
82026: PPUSH
82027: CALL_OW 129
82031: GO 82081
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
82033: LD_VAR 0 23
82037: PUSH
82038: LD_VAR 0 4
82042: PUSH
82043: LD_VAR 0 7
82047: ARRAY
82048: PPUSH
82049: CALL_OW 256
82053: PUSH
82054: LD_INT 1000
82056: LESS
82057: AND
82058: NOT
82059: IFFALSE 82081
// ComEnterUnit ( group [ i ] , x ) ;
82061: LD_VAR 0 4
82065: PUSH
82066: LD_VAR 0 7
82070: ARRAY
82071: PPUSH
82072: LD_VAR 0 10
82076: PPUSH
82077: CALL_OW 120
// end ; continue ;
82081: GO 81428
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
82083: LD_VAR 0 23
82087: PUSH
82088: LD_VAR 0 4
82092: PUSH
82093: LD_VAR 0 7
82097: ARRAY
82098: PPUSH
82099: CALL_OW 247
82103: PUSH
82104: LD_INT 1
82106: EQUAL
82107: AND
82108: IFFALSE 82586
// begin if group [ i ] in healers then
82110: LD_VAR 0 4
82114: PUSH
82115: LD_VAR 0 7
82119: ARRAY
82120: PUSH
82121: LD_VAR 0 31
82125: IN
82126: IFFALSE 82399
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
82128: LD_VAR 0 4
82132: PUSH
82133: LD_VAR 0 7
82137: ARRAY
82138: PPUSH
82139: LD_VAR 0 23
82143: PPUSH
82144: CALL_OW 308
82148: NOT
82149: PUSH
82150: LD_VAR 0 4
82154: PUSH
82155: LD_VAR 0 7
82159: ARRAY
82160: PPUSH
82161: CALL_OW 314
82165: NOT
82166: AND
82167: IFFALSE 82191
// ComMoveToArea ( group [ i ] , f_heal ) else
82169: LD_VAR 0 4
82173: PUSH
82174: LD_VAR 0 7
82178: ARRAY
82179: PPUSH
82180: LD_VAR 0 23
82184: PPUSH
82185: CALL_OW 113
82189: GO 82397
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
82191: LD_VAR 0 4
82195: PUSH
82196: LD_VAR 0 7
82200: ARRAY
82201: PPUSH
82202: CALL 54084 0 1
82206: PPUSH
82207: CALL_OW 256
82211: PUSH
82212: LD_INT 1000
82214: EQUAL
82215: IFFALSE 82234
// ComStop ( group [ i ] ) else
82217: LD_VAR 0 4
82221: PUSH
82222: LD_VAR 0 7
82226: ARRAY
82227: PPUSH
82228: CALL_OW 141
82232: GO 82397
// if not HasTask ( group [ i ] ) and to_heal then
82234: LD_VAR 0 4
82238: PUSH
82239: LD_VAR 0 7
82243: ARRAY
82244: PPUSH
82245: CALL_OW 314
82249: NOT
82250: PUSH
82251: LD_VAR 0 30
82255: AND
82256: IFFALSE 82397
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
82258: LD_ADDR_VAR 0 13
82262: PUSH
82263: LD_VAR 0 30
82267: PPUSH
82268: LD_INT 3
82270: PUSH
82271: LD_INT 54
82273: PUSH
82274: EMPTY
82275: LIST
82276: PUSH
82277: EMPTY
82278: LIST
82279: LIST
82280: PPUSH
82281: CALL_OW 72
82285: PPUSH
82286: LD_VAR 0 4
82290: PUSH
82291: LD_VAR 0 7
82295: ARRAY
82296: PPUSH
82297: CALL_OW 74
82301: ST_TO_ADDR
// if z then
82302: LD_VAR 0 13
82306: IFFALSE 82397
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
82308: LD_INT 91
82310: PUSH
82311: LD_VAR 0 13
82315: PUSH
82316: LD_INT 10
82318: PUSH
82319: EMPTY
82320: LIST
82321: LIST
82322: LIST
82323: PUSH
82324: LD_INT 81
82326: PUSH
82327: LD_VAR 0 13
82331: PPUSH
82332: CALL_OW 255
82336: PUSH
82337: EMPTY
82338: LIST
82339: LIST
82340: PUSH
82341: EMPTY
82342: LIST
82343: LIST
82344: PPUSH
82345: CALL_OW 69
82349: PUSH
82350: LD_INT 0
82352: EQUAL
82353: IFFALSE 82377
// ComHeal ( group [ i ] , z ) else
82355: LD_VAR 0 4
82359: PUSH
82360: LD_VAR 0 7
82364: ARRAY
82365: PPUSH
82366: LD_VAR 0 13
82370: PPUSH
82371: CALL_OW 128
82375: GO 82397
// ComMoveToArea ( group [ i ] , f_heal ) ;
82377: LD_VAR 0 4
82381: PUSH
82382: LD_VAR 0 7
82386: ARRAY
82387: PPUSH
82388: LD_VAR 0 23
82392: PPUSH
82393: CALL_OW 113
// end ; continue ;
82397: GO 81428
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
82399: LD_VAR 0 4
82403: PUSH
82404: LD_VAR 0 7
82408: ARRAY
82409: PPUSH
82410: CALL_OW 256
82414: PUSH
82415: LD_INT 700
82417: LESS
82418: PUSH
82419: LD_VAR 0 4
82423: PUSH
82424: LD_VAR 0 7
82428: ARRAY
82429: PUSH
82430: LD_VAR 0 30
82434: IN
82435: NOT
82436: AND
82437: IFFALSE 82461
// to_heal := to_heal union group [ i ] ;
82439: LD_ADDR_VAR 0 30
82443: PUSH
82444: LD_VAR 0 30
82448: PUSH
82449: LD_VAR 0 4
82453: PUSH
82454: LD_VAR 0 7
82458: ARRAY
82459: UNION
82460: ST_TO_ADDR
// if group [ i ] in to_heal then
82461: LD_VAR 0 4
82465: PUSH
82466: LD_VAR 0 7
82470: ARRAY
82471: PUSH
82472: LD_VAR 0 30
82476: IN
82477: IFFALSE 82586
// begin if GetLives ( group [ i ] ) = 1000 then
82479: LD_VAR 0 4
82483: PUSH
82484: LD_VAR 0 7
82488: ARRAY
82489: PPUSH
82490: CALL_OW 256
82494: PUSH
82495: LD_INT 1000
82497: EQUAL
82498: IFFALSE 82524
// to_heal := to_heal diff group [ i ] else
82500: LD_ADDR_VAR 0 30
82504: PUSH
82505: LD_VAR 0 30
82509: PUSH
82510: LD_VAR 0 4
82514: PUSH
82515: LD_VAR 0 7
82519: ARRAY
82520: DIFF
82521: ST_TO_ADDR
82522: GO 82586
// begin if not IsInArea ( group [ i ] , to_heal ) then
82524: LD_VAR 0 4
82528: PUSH
82529: LD_VAR 0 7
82533: ARRAY
82534: PPUSH
82535: LD_VAR 0 30
82539: PPUSH
82540: CALL_OW 308
82544: NOT
82545: IFFALSE 82569
// ComMoveToArea ( group [ i ] , f_heal ) else
82547: LD_VAR 0 4
82551: PUSH
82552: LD_VAR 0 7
82556: ARRAY
82557: PPUSH
82558: LD_VAR 0 23
82562: PPUSH
82563: CALL_OW 113
82567: GO 82584
// ComHold ( group [ i ] ) ;
82569: LD_VAR 0 4
82573: PUSH
82574: LD_VAR 0 7
82578: ARRAY
82579: PPUSH
82580: CALL_OW 140
// continue ;
82584: GO 81428
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
82586: LD_VAR 0 4
82590: PUSH
82591: LD_VAR 0 7
82595: ARRAY
82596: PPUSH
82597: LD_INT 10
82599: PPUSH
82600: CALL 51855 0 2
82604: NOT
82605: PUSH
82606: LD_VAR 0 16
82610: PUSH
82611: LD_VAR 0 7
82615: ARRAY
82616: PUSH
82617: EMPTY
82618: EQUAL
82619: NOT
82620: AND
82621: IFFALSE 82887
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
82623: LD_VAR 0 4
82627: PUSH
82628: LD_VAR 0 7
82632: ARRAY
82633: PPUSH
82634: CALL_OW 262
82638: PUSH
82639: LD_INT 1
82641: PUSH
82642: LD_INT 2
82644: PUSH
82645: EMPTY
82646: LIST
82647: LIST
82648: IN
82649: IFFALSE 82690
// if GetFuel ( group [ i ] ) < 10 then
82651: LD_VAR 0 4
82655: PUSH
82656: LD_VAR 0 7
82660: ARRAY
82661: PPUSH
82662: CALL_OW 261
82666: PUSH
82667: LD_INT 10
82669: LESS
82670: IFFALSE 82690
// SetFuel ( group [ i ] , 12 ) ;
82672: LD_VAR 0 4
82676: PUSH
82677: LD_VAR 0 7
82681: ARRAY
82682: PPUSH
82683: LD_INT 12
82685: PPUSH
82686: CALL_OW 240
// if units_path [ i ] then
82690: LD_VAR 0 16
82694: PUSH
82695: LD_VAR 0 7
82699: ARRAY
82700: IFFALSE 82885
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
82702: LD_VAR 0 4
82706: PUSH
82707: LD_VAR 0 7
82711: ARRAY
82712: PPUSH
82713: LD_VAR 0 16
82717: PUSH
82718: LD_VAR 0 7
82722: ARRAY
82723: PUSH
82724: LD_INT 1
82726: ARRAY
82727: PUSH
82728: LD_INT 1
82730: ARRAY
82731: PPUSH
82732: LD_VAR 0 16
82736: PUSH
82737: LD_VAR 0 7
82741: ARRAY
82742: PUSH
82743: LD_INT 1
82745: ARRAY
82746: PUSH
82747: LD_INT 2
82749: ARRAY
82750: PPUSH
82751: CALL_OW 297
82755: PUSH
82756: LD_INT 6
82758: GREATER
82759: IFFALSE 82834
// begin if not HasTask ( group [ i ] ) then
82761: LD_VAR 0 4
82765: PUSH
82766: LD_VAR 0 7
82770: ARRAY
82771: PPUSH
82772: CALL_OW 314
82776: NOT
82777: IFFALSE 82832
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
82779: LD_VAR 0 4
82783: PUSH
82784: LD_VAR 0 7
82788: ARRAY
82789: PPUSH
82790: LD_VAR 0 16
82794: PUSH
82795: LD_VAR 0 7
82799: ARRAY
82800: PUSH
82801: LD_INT 1
82803: ARRAY
82804: PUSH
82805: LD_INT 1
82807: ARRAY
82808: PPUSH
82809: LD_VAR 0 16
82813: PUSH
82814: LD_VAR 0 7
82818: ARRAY
82819: PUSH
82820: LD_INT 1
82822: ARRAY
82823: PUSH
82824: LD_INT 2
82826: ARRAY
82827: PPUSH
82828: CALL_OW 114
// end else
82832: GO 82885
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
82834: LD_ADDR_VAR 0 15
82838: PUSH
82839: LD_VAR 0 16
82843: PUSH
82844: LD_VAR 0 7
82848: ARRAY
82849: PPUSH
82850: LD_INT 1
82852: PPUSH
82853: CALL_OW 3
82857: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
82858: LD_ADDR_VAR 0 16
82862: PUSH
82863: LD_VAR 0 16
82867: PPUSH
82868: LD_VAR 0 7
82872: PPUSH
82873: LD_VAR 0 15
82877: PPUSH
82878: CALL_OW 1
82882: ST_TO_ADDR
// continue ;
82883: GO 81428
// end ; end ; end else
82885: GO 85549
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
82887: LD_ADDR_VAR 0 14
82891: PUSH
82892: LD_INT 81
82894: PUSH
82895: LD_VAR 0 4
82899: PUSH
82900: LD_VAR 0 7
82904: ARRAY
82905: PPUSH
82906: CALL_OW 255
82910: PUSH
82911: EMPTY
82912: LIST
82913: LIST
82914: PPUSH
82915: CALL_OW 69
82919: ST_TO_ADDR
// if not tmp then
82920: LD_VAR 0 14
82924: NOT
82925: IFFALSE 82929
// continue ;
82927: GO 81428
// if f_ignore_area then
82929: LD_VAR 0 17
82933: IFFALSE 83021
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
82935: LD_ADDR_VAR 0 15
82939: PUSH
82940: LD_VAR 0 14
82944: PPUSH
82945: LD_INT 3
82947: PUSH
82948: LD_INT 92
82950: PUSH
82951: LD_VAR 0 17
82955: PUSH
82956: LD_INT 1
82958: ARRAY
82959: PUSH
82960: LD_VAR 0 17
82964: PUSH
82965: LD_INT 2
82967: ARRAY
82968: PUSH
82969: LD_VAR 0 17
82973: PUSH
82974: LD_INT 3
82976: ARRAY
82977: PUSH
82978: EMPTY
82979: LIST
82980: LIST
82981: LIST
82982: LIST
82983: PUSH
82984: EMPTY
82985: LIST
82986: LIST
82987: PPUSH
82988: CALL_OW 72
82992: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
82993: LD_VAR 0 14
82997: PUSH
82998: LD_VAR 0 15
83002: DIFF
83003: IFFALSE 83021
// tmp := tmp diff tmp2 ;
83005: LD_ADDR_VAR 0 14
83009: PUSH
83010: LD_VAR 0 14
83014: PUSH
83015: LD_VAR 0 15
83019: DIFF
83020: ST_TO_ADDR
// end ; if not f_murder then
83021: LD_VAR 0 20
83025: NOT
83026: IFFALSE 83084
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
83028: LD_ADDR_VAR 0 15
83032: PUSH
83033: LD_VAR 0 14
83037: PPUSH
83038: LD_INT 3
83040: PUSH
83041: LD_INT 50
83043: PUSH
83044: EMPTY
83045: LIST
83046: PUSH
83047: EMPTY
83048: LIST
83049: LIST
83050: PPUSH
83051: CALL_OW 72
83055: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
83056: LD_VAR 0 14
83060: PUSH
83061: LD_VAR 0 15
83065: DIFF
83066: IFFALSE 83084
// tmp := tmp diff tmp2 ;
83068: LD_ADDR_VAR 0 14
83072: PUSH
83073: LD_VAR 0 14
83077: PUSH
83078: LD_VAR 0 15
83082: DIFF
83083: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
83084: LD_ADDR_VAR 0 14
83088: PUSH
83089: LD_VAR 0 4
83093: PUSH
83094: LD_VAR 0 7
83098: ARRAY
83099: PPUSH
83100: LD_VAR 0 14
83104: PPUSH
83105: LD_INT 1
83107: PPUSH
83108: LD_INT 1
83110: PPUSH
83111: CALL 24796 0 4
83115: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
83116: LD_VAR 0 4
83120: PUSH
83121: LD_VAR 0 7
83125: ARRAY
83126: PPUSH
83127: CALL_OW 257
83131: PUSH
83132: LD_INT 1
83134: EQUAL
83135: IFFALSE 83583
// begin if WantPlant ( group [ i ] ) then
83137: LD_VAR 0 4
83141: PUSH
83142: LD_VAR 0 7
83146: ARRAY
83147: PPUSH
83148: CALL 24297 0 1
83152: IFFALSE 83156
// continue ;
83154: GO 81428
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
83156: LD_VAR 0 18
83160: PUSH
83161: LD_VAR 0 4
83165: PUSH
83166: LD_VAR 0 7
83170: ARRAY
83171: PPUSH
83172: CALL_OW 310
83176: NOT
83177: AND
83178: PUSH
83179: LD_VAR 0 14
83183: PUSH
83184: LD_INT 1
83186: ARRAY
83187: PUSH
83188: LD_VAR 0 14
83192: PPUSH
83193: LD_INT 21
83195: PUSH
83196: LD_INT 2
83198: PUSH
83199: EMPTY
83200: LIST
83201: LIST
83202: PUSH
83203: LD_INT 58
83205: PUSH
83206: EMPTY
83207: LIST
83208: PUSH
83209: EMPTY
83210: LIST
83211: LIST
83212: PPUSH
83213: CALL_OW 72
83217: IN
83218: AND
83219: IFFALSE 83255
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
83221: LD_VAR 0 4
83225: PUSH
83226: LD_VAR 0 7
83230: ARRAY
83231: PPUSH
83232: LD_VAR 0 14
83236: PUSH
83237: LD_INT 1
83239: ARRAY
83240: PPUSH
83241: CALL_OW 120
// attacking := true ;
83245: LD_ADDR_VAR 0 29
83249: PUSH
83250: LD_INT 1
83252: ST_TO_ADDR
// continue ;
83253: GO 81428
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
83255: LD_VAR 0 26
83259: PUSH
83260: LD_VAR 0 4
83264: PUSH
83265: LD_VAR 0 7
83269: ARRAY
83270: PPUSH
83271: CALL_OW 257
83275: PUSH
83276: LD_INT 1
83278: EQUAL
83279: AND
83280: PUSH
83281: LD_VAR 0 4
83285: PUSH
83286: LD_VAR 0 7
83290: ARRAY
83291: PPUSH
83292: CALL_OW 256
83296: PUSH
83297: LD_INT 800
83299: LESS
83300: AND
83301: PUSH
83302: LD_VAR 0 4
83306: PUSH
83307: LD_VAR 0 7
83311: ARRAY
83312: PPUSH
83313: CALL_OW 318
83317: NOT
83318: AND
83319: IFFALSE 83336
// ComCrawl ( group [ i ] ) ;
83321: LD_VAR 0 4
83325: PUSH
83326: LD_VAR 0 7
83330: ARRAY
83331: PPUSH
83332: CALL_OW 137
// if f_mines then
83336: LD_VAR 0 21
83340: IFFALSE 83583
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
83342: LD_VAR 0 14
83346: PUSH
83347: LD_INT 1
83349: ARRAY
83350: PPUSH
83351: CALL_OW 247
83355: PUSH
83356: LD_INT 3
83358: EQUAL
83359: PUSH
83360: LD_VAR 0 14
83364: PUSH
83365: LD_INT 1
83367: ARRAY
83368: PUSH
83369: LD_VAR 0 27
83373: IN
83374: NOT
83375: AND
83376: IFFALSE 83583
// begin x := GetX ( tmp [ 1 ] ) ;
83378: LD_ADDR_VAR 0 10
83382: PUSH
83383: LD_VAR 0 14
83387: PUSH
83388: LD_INT 1
83390: ARRAY
83391: PPUSH
83392: CALL_OW 250
83396: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
83397: LD_ADDR_VAR 0 11
83401: PUSH
83402: LD_VAR 0 14
83406: PUSH
83407: LD_INT 1
83409: ARRAY
83410: PPUSH
83411: CALL_OW 251
83415: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
83416: LD_ADDR_VAR 0 12
83420: PUSH
83421: LD_VAR 0 4
83425: PUSH
83426: LD_VAR 0 7
83430: ARRAY
83431: PPUSH
83432: CALL 51940 0 1
83436: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
83437: LD_VAR 0 4
83441: PUSH
83442: LD_VAR 0 7
83446: ARRAY
83447: PPUSH
83448: LD_VAR 0 10
83452: PPUSH
83453: LD_VAR 0 11
83457: PPUSH
83458: LD_VAR 0 14
83462: PUSH
83463: LD_INT 1
83465: ARRAY
83466: PPUSH
83467: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
83471: LD_VAR 0 4
83475: PUSH
83476: LD_VAR 0 7
83480: ARRAY
83481: PPUSH
83482: LD_VAR 0 10
83486: PPUSH
83487: LD_VAR 0 12
83491: PPUSH
83492: LD_INT 7
83494: PPUSH
83495: CALL_OW 272
83499: PPUSH
83500: LD_VAR 0 11
83504: PPUSH
83505: LD_VAR 0 12
83509: PPUSH
83510: LD_INT 7
83512: PPUSH
83513: CALL_OW 273
83517: PPUSH
83518: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
83522: LD_VAR 0 4
83526: PUSH
83527: LD_VAR 0 7
83531: ARRAY
83532: PPUSH
83533: LD_INT 71
83535: PPUSH
83536: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
83540: LD_ADDR_VAR 0 27
83544: PUSH
83545: LD_VAR 0 27
83549: PPUSH
83550: LD_VAR 0 27
83554: PUSH
83555: LD_INT 1
83557: PLUS
83558: PPUSH
83559: LD_VAR 0 14
83563: PUSH
83564: LD_INT 1
83566: ARRAY
83567: PPUSH
83568: CALL_OW 1
83572: ST_TO_ADDR
// attacking := true ;
83573: LD_ADDR_VAR 0 29
83577: PUSH
83578: LD_INT 1
83580: ST_TO_ADDR
// continue ;
83581: GO 81428
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
83583: LD_VAR 0 4
83587: PUSH
83588: LD_VAR 0 7
83592: ARRAY
83593: PPUSH
83594: CALL_OW 257
83598: PUSH
83599: LD_INT 17
83601: EQUAL
83602: PUSH
83603: LD_VAR 0 4
83607: PUSH
83608: LD_VAR 0 7
83612: ARRAY
83613: PPUSH
83614: CALL_OW 110
83618: PUSH
83619: LD_INT 71
83621: EQUAL
83622: NOT
83623: AND
83624: IFFALSE 83770
// begin attacking := false ;
83626: LD_ADDR_VAR 0 29
83630: PUSH
83631: LD_INT 0
83633: ST_TO_ADDR
// k := 5 ;
83634: LD_ADDR_VAR 0 9
83638: PUSH
83639: LD_INT 5
83641: ST_TO_ADDR
// if tmp < k then
83642: LD_VAR 0 14
83646: PUSH
83647: LD_VAR 0 9
83651: LESS
83652: IFFALSE 83664
// k := tmp ;
83654: LD_ADDR_VAR 0 9
83658: PUSH
83659: LD_VAR 0 14
83663: ST_TO_ADDR
// for j = 1 to k do
83664: LD_ADDR_VAR 0 8
83668: PUSH
83669: DOUBLE
83670: LD_INT 1
83672: DEC
83673: ST_TO_ADDR
83674: LD_VAR 0 9
83678: PUSH
83679: FOR_TO
83680: IFFALSE 83768
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
83682: LD_VAR 0 14
83686: PUSH
83687: LD_VAR 0 8
83691: ARRAY
83692: PUSH
83693: LD_VAR 0 14
83697: PPUSH
83698: LD_INT 58
83700: PUSH
83701: EMPTY
83702: LIST
83703: PPUSH
83704: CALL_OW 72
83708: IN
83709: NOT
83710: IFFALSE 83766
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
83712: LD_VAR 0 4
83716: PUSH
83717: LD_VAR 0 7
83721: ARRAY
83722: PPUSH
83723: LD_VAR 0 14
83727: PUSH
83728: LD_VAR 0 8
83732: ARRAY
83733: PPUSH
83734: CALL_OW 115
// attacking := true ;
83738: LD_ADDR_VAR 0 29
83742: PUSH
83743: LD_INT 1
83745: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
83746: LD_VAR 0 4
83750: PUSH
83751: LD_VAR 0 7
83755: ARRAY
83756: PPUSH
83757: LD_INT 71
83759: PPUSH
83760: CALL_OW 109
// continue ;
83764: GO 83679
// end ; end ;
83766: GO 83679
83768: POP
83769: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
83770: LD_VAR 0 4
83774: PUSH
83775: LD_VAR 0 7
83779: ARRAY
83780: PPUSH
83781: CALL_OW 257
83785: PUSH
83786: LD_INT 8
83788: EQUAL
83789: PUSH
83790: LD_VAR 0 4
83794: PUSH
83795: LD_VAR 0 7
83799: ARRAY
83800: PPUSH
83801: CALL_OW 264
83805: PUSH
83806: LD_INT 28
83808: PUSH
83809: LD_INT 45
83811: PUSH
83812: LD_INT 7
83814: PUSH
83815: LD_INT 47
83817: PUSH
83818: EMPTY
83819: LIST
83820: LIST
83821: LIST
83822: LIST
83823: IN
83824: OR
83825: IFFALSE 84081
// begin attacking := false ;
83827: LD_ADDR_VAR 0 29
83831: PUSH
83832: LD_INT 0
83834: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
83835: LD_VAR 0 14
83839: PUSH
83840: LD_INT 1
83842: ARRAY
83843: PPUSH
83844: CALL_OW 266
83848: PUSH
83849: LD_INT 32
83851: PUSH
83852: LD_INT 31
83854: PUSH
83855: LD_INT 33
83857: PUSH
83858: LD_INT 4
83860: PUSH
83861: LD_INT 5
83863: PUSH
83864: EMPTY
83865: LIST
83866: LIST
83867: LIST
83868: LIST
83869: LIST
83870: IN
83871: IFFALSE 84057
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
83873: LD_ADDR_VAR 0 9
83877: PUSH
83878: LD_VAR 0 14
83882: PUSH
83883: LD_INT 1
83885: ARRAY
83886: PPUSH
83887: CALL_OW 266
83891: PPUSH
83892: LD_VAR 0 14
83896: PUSH
83897: LD_INT 1
83899: ARRAY
83900: PPUSH
83901: CALL_OW 250
83905: PPUSH
83906: LD_VAR 0 14
83910: PUSH
83911: LD_INT 1
83913: ARRAY
83914: PPUSH
83915: CALL_OW 251
83919: PPUSH
83920: LD_VAR 0 14
83924: PUSH
83925: LD_INT 1
83927: ARRAY
83928: PPUSH
83929: CALL_OW 254
83933: PPUSH
83934: LD_VAR 0 14
83938: PUSH
83939: LD_INT 1
83941: ARRAY
83942: PPUSH
83943: CALL_OW 248
83947: PPUSH
83948: LD_INT 0
83950: PPUSH
83951: CALL 33310 0 6
83955: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
83956: LD_ADDR_VAR 0 8
83960: PUSH
83961: LD_VAR 0 4
83965: PUSH
83966: LD_VAR 0 7
83970: ARRAY
83971: PPUSH
83972: LD_VAR 0 9
83976: PPUSH
83977: CALL 52053 0 2
83981: ST_TO_ADDR
// if j then
83982: LD_VAR 0 8
83986: IFFALSE 84055
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
83988: LD_VAR 0 8
83992: PUSH
83993: LD_INT 1
83995: ARRAY
83996: PPUSH
83997: LD_VAR 0 8
84001: PUSH
84002: LD_INT 2
84004: ARRAY
84005: PPUSH
84006: CALL_OW 488
84010: IFFALSE 84055
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
84012: LD_VAR 0 4
84016: PUSH
84017: LD_VAR 0 7
84021: ARRAY
84022: PPUSH
84023: LD_VAR 0 8
84027: PUSH
84028: LD_INT 1
84030: ARRAY
84031: PPUSH
84032: LD_VAR 0 8
84036: PUSH
84037: LD_INT 2
84039: ARRAY
84040: PPUSH
84041: CALL_OW 116
// attacking := true ;
84045: LD_ADDR_VAR 0 29
84049: PUSH
84050: LD_INT 1
84052: ST_TO_ADDR
// continue ;
84053: GO 81428
// end ; end else
84055: GO 84081
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
84057: LD_VAR 0 4
84061: PUSH
84062: LD_VAR 0 7
84066: ARRAY
84067: PPUSH
84068: LD_VAR 0 14
84072: PUSH
84073: LD_INT 1
84075: ARRAY
84076: PPUSH
84077: CALL_OW 115
// end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
84081: LD_VAR 0 4
84085: PUSH
84086: LD_VAR 0 7
84090: ARRAY
84091: PPUSH
84092: CALL_OW 265
84096: PUSH
84097: LD_INT 11
84099: EQUAL
84100: IFFALSE 84378
// begin k := 10 ;
84102: LD_ADDR_VAR 0 9
84106: PUSH
84107: LD_INT 10
84109: ST_TO_ADDR
// x := 0 ;
84110: LD_ADDR_VAR 0 10
84114: PUSH
84115: LD_INT 0
84117: ST_TO_ADDR
// if tmp < k then
84118: LD_VAR 0 14
84122: PUSH
84123: LD_VAR 0 9
84127: LESS
84128: IFFALSE 84140
// k := tmp ;
84130: LD_ADDR_VAR 0 9
84134: PUSH
84135: LD_VAR 0 14
84139: ST_TO_ADDR
// for j = k downto 1 do
84140: LD_ADDR_VAR 0 8
84144: PUSH
84145: DOUBLE
84146: LD_VAR 0 9
84150: INC
84151: ST_TO_ADDR
84152: LD_INT 1
84154: PUSH
84155: FOR_DOWNTO
84156: IFFALSE 84231
// begin if GetType ( tmp [ j ] ) = unit_human then
84158: LD_VAR 0 14
84162: PUSH
84163: LD_VAR 0 8
84167: ARRAY
84168: PPUSH
84169: CALL_OW 247
84173: PUSH
84174: LD_INT 1
84176: EQUAL
84177: IFFALSE 84229
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
84179: LD_VAR 0 4
84183: PUSH
84184: LD_VAR 0 7
84188: ARRAY
84189: PPUSH
84190: LD_VAR 0 14
84194: PUSH
84195: LD_VAR 0 8
84199: ARRAY
84200: PPUSH
84201: CALL 52307 0 2
// x := tmp [ j ] ;
84205: LD_ADDR_VAR 0 10
84209: PUSH
84210: LD_VAR 0 14
84214: PUSH
84215: LD_VAR 0 8
84219: ARRAY
84220: ST_TO_ADDR
// attacking := true ;
84221: LD_ADDR_VAR 0 29
84225: PUSH
84226: LD_INT 1
84228: ST_TO_ADDR
// end ; end ;
84229: GO 84155
84231: POP
84232: POP
// if not x then
84233: LD_VAR 0 10
84237: NOT
84238: IFFALSE 84378
// begin attacking := true ;
84240: LD_ADDR_VAR 0 29
84244: PUSH
84245: LD_INT 1
84247: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
84248: LD_VAR 0 4
84252: PUSH
84253: LD_VAR 0 7
84257: ARRAY
84258: PPUSH
84259: CALL_OW 250
84263: PPUSH
84264: LD_VAR 0 4
84268: PUSH
84269: LD_VAR 0 7
84273: ARRAY
84274: PPUSH
84275: CALL_OW 251
84279: PPUSH
84280: CALL_OW 546
84284: PUSH
84285: LD_INT 2
84287: ARRAY
84288: PUSH
84289: LD_VAR 0 14
84293: PUSH
84294: LD_INT 1
84296: ARRAY
84297: PPUSH
84298: CALL_OW 250
84302: PPUSH
84303: LD_VAR 0 14
84307: PUSH
84308: LD_INT 1
84310: ARRAY
84311: PPUSH
84312: CALL_OW 251
84316: PPUSH
84317: CALL_OW 546
84321: PUSH
84322: LD_INT 2
84324: ARRAY
84325: EQUAL
84326: IFFALSE 84354
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
84328: LD_VAR 0 4
84332: PUSH
84333: LD_VAR 0 7
84337: ARRAY
84338: PPUSH
84339: LD_VAR 0 14
84343: PUSH
84344: LD_INT 1
84346: ARRAY
84347: PPUSH
84348: CALL 52307 0 2
84352: GO 84378
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
84354: LD_VAR 0 4
84358: PUSH
84359: LD_VAR 0 7
84363: ARRAY
84364: PPUSH
84365: LD_VAR 0 14
84369: PUSH
84370: LD_INT 1
84372: ARRAY
84373: PPUSH
84374: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
84378: LD_VAR 0 4
84382: PUSH
84383: LD_VAR 0 7
84387: ARRAY
84388: PPUSH
84389: CALL_OW 264
84393: PUSH
84394: LD_INT 29
84396: EQUAL
84397: IFFALSE 84763
// begin if WantsToAttack ( group [ i ] ) in bombed then
84399: LD_VAR 0 4
84403: PUSH
84404: LD_VAR 0 7
84408: ARRAY
84409: PPUSH
84410: CALL_OW 319
84414: PUSH
84415: LD_VAR 0 28
84419: IN
84420: IFFALSE 84424
// continue ;
84422: GO 81428
// k := 8 ;
84424: LD_ADDR_VAR 0 9
84428: PUSH
84429: LD_INT 8
84431: ST_TO_ADDR
// x := 0 ;
84432: LD_ADDR_VAR 0 10
84436: PUSH
84437: LD_INT 0
84439: ST_TO_ADDR
// if tmp < k then
84440: LD_VAR 0 14
84444: PUSH
84445: LD_VAR 0 9
84449: LESS
84450: IFFALSE 84462
// k := tmp ;
84452: LD_ADDR_VAR 0 9
84456: PUSH
84457: LD_VAR 0 14
84461: ST_TO_ADDR
// for j = 1 to k do
84462: LD_ADDR_VAR 0 8
84466: PUSH
84467: DOUBLE
84468: LD_INT 1
84470: DEC
84471: ST_TO_ADDR
84472: LD_VAR 0 9
84476: PUSH
84477: FOR_TO
84478: IFFALSE 84610
// begin if GetType ( tmp [ j ] ) = unit_building then
84480: LD_VAR 0 14
84484: PUSH
84485: LD_VAR 0 8
84489: ARRAY
84490: PPUSH
84491: CALL_OW 247
84495: PUSH
84496: LD_INT 3
84498: EQUAL
84499: IFFALSE 84608
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
84501: LD_VAR 0 14
84505: PUSH
84506: LD_VAR 0 8
84510: ARRAY
84511: PUSH
84512: LD_VAR 0 28
84516: IN
84517: NOT
84518: PUSH
84519: LD_VAR 0 14
84523: PUSH
84524: LD_VAR 0 8
84528: ARRAY
84529: PPUSH
84530: CALL_OW 313
84534: AND
84535: IFFALSE 84608
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
84537: LD_VAR 0 4
84541: PUSH
84542: LD_VAR 0 7
84546: ARRAY
84547: PPUSH
84548: LD_VAR 0 14
84552: PUSH
84553: LD_VAR 0 8
84557: ARRAY
84558: PPUSH
84559: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
84563: LD_ADDR_VAR 0 28
84567: PUSH
84568: LD_VAR 0 28
84572: PPUSH
84573: LD_VAR 0 28
84577: PUSH
84578: LD_INT 1
84580: PLUS
84581: PPUSH
84582: LD_VAR 0 14
84586: PUSH
84587: LD_VAR 0 8
84591: ARRAY
84592: PPUSH
84593: CALL_OW 1
84597: ST_TO_ADDR
// attacking := true ;
84598: LD_ADDR_VAR 0 29
84602: PUSH
84603: LD_INT 1
84605: ST_TO_ADDR
// break ;
84606: GO 84610
// end ; end ;
84608: GO 84477
84610: POP
84611: POP
// if not attacking and f_attack_depot then
84612: LD_VAR 0 29
84616: NOT
84617: PUSH
84618: LD_VAR 0 25
84622: AND
84623: IFFALSE 84718
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
84625: LD_ADDR_VAR 0 13
84629: PUSH
84630: LD_VAR 0 14
84634: PPUSH
84635: LD_INT 2
84637: PUSH
84638: LD_INT 30
84640: PUSH
84641: LD_INT 0
84643: PUSH
84644: EMPTY
84645: LIST
84646: LIST
84647: PUSH
84648: LD_INT 30
84650: PUSH
84651: LD_INT 1
84653: PUSH
84654: EMPTY
84655: LIST
84656: LIST
84657: PUSH
84658: EMPTY
84659: LIST
84660: LIST
84661: LIST
84662: PPUSH
84663: CALL_OW 72
84667: ST_TO_ADDR
// if z then
84668: LD_VAR 0 13
84672: IFFALSE 84718
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
84674: LD_VAR 0 4
84678: PUSH
84679: LD_VAR 0 7
84683: ARRAY
84684: PPUSH
84685: LD_VAR 0 13
84689: PPUSH
84690: LD_VAR 0 4
84694: PUSH
84695: LD_VAR 0 7
84699: ARRAY
84700: PPUSH
84701: CALL_OW 74
84705: PPUSH
84706: CALL_OW 115
// attacking := true ;
84710: LD_ADDR_VAR 0 29
84714: PUSH
84715: LD_INT 1
84717: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
84718: LD_VAR 0 4
84722: PUSH
84723: LD_VAR 0 7
84727: ARRAY
84728: PPUSH
84729: CALL_OW 256
84733: PUSH
84734: LD_INT 500
84736: LESS
84737: IFFALSE 84763
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
84739: LD_VAR 0 4
84743: PUSH
84744: LD_VAR 0 7
84748: ARRAY
84749: PPUSH
84750: LD_VAR 0 14
84754: PUSH
84755: LD_INT 1
84757: ARRAY
84758: PPUSH
84759: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
84763: LD_VAR 0 4
84767: PUSH
84768: LD_VAR 0 7
84772: ARRAY
84773: PPUSH
84774: CALL_OW 264
84778: PUSH
84779: LD_INT 49
84781: EQUAL
84782: IFFALSE 84903
// begin if not HasTask ( group [ i ] ) then
84784: LD_VAR 0 4
84788: PUSH
84789: LD_VAR 0 7
84793: ARRAY
84794: PPUSH
84795: CALL_OW 314
84799: NOT
84800: IFFALSE 84903
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
84802: LD_ADDR_VAR 0 9
84806: PUSH
84807: LD_INT 81
84809: PUSH
84810: LD_VAR 0 4
84814: PUSH
84815: LD_VAR 0 7
84819: ARRAY
84820: PPUSH
84821: CALL_OW 255
84825: PUSH
84826: EMPTY
84827: LIST
84828: LIST
84829: PPUSH
84830: CALL_OW 69
84834: PPUSH
84835: LD_VAR 0 4
84839: PUSH
84840: LD_VAR 0 7
84844: ARRAY
84845: PPUSH
84846: CALL_OW 74
84850: ST_TO_ADDR
// if k then
84851: LD_VAR 0 9
84855: IFFALSE 84903
// if GetDistUnits ( group [ i ] , k ) > 10 then
84857: LD_VAR 0 4
84861: PUSH
84862: LD_VAR 0 7
84866: ARRAY
84867: PPUSH
84868: LD_VAR 0 9
84872: PPUSH
84873: CALL_OW 296
84877: PUSH
84878: LD_INT 10
84880: GREATER
84881: IFFALSE 84903
// ComMoveUnit ( group [ i ] , k ) ;
84883: LD_VAR 0 4
84887: PUSH
84888: LD_VAR 0 7
84892: ARRAY
84893: PPUSH
84894: LD_VAR 0 9
84898: PPUSH
84899: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
84903: LD_VAR 0 4
84907: PUSH
84908: LD_VAR 0 7
84912: ARRAY
84913: PPUSH
84914: CALL_OW 256
84918: PUSH
84919: LD_INT 250
84921: LESS
84922: PUSH
84923: LD_VAR 0 4
84927: PUSH
84928: LD_VAR 0 7
84932: ARRAY
84933: PUSH
84934: LD_INT 21
84936: PUSH
84937: LD_INT 2
84939: PUSH
84940: EMPTY
84941: LIST
84942: LIST
84943: PUSH
84944: LD_INT 23
84946: PUSH
84947: LD_INT 2
84949: PUSH
84950: EMPTY
84951: LIST
84952: LIST
84953: PUSH
84954: EMPTY
84955: LIST
84956: LIST
84957: PPUSH
84958: CALL_OW 69
84962: IN
84963: AND
84964: IFFALSE 85089
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
84966: LD_ADDR_VAR 0 9
84970: PUSH
84971: LD_OWVAR 3
84975: PUSH
84976: LD_VAR 0 4
84980: PUSH
84981: LD_VAR 0 7
84985: ARRAY
84986: DIFF
84987: PPUSH
84988: LD_VAR 0 4
84992: PUSH
84993: LD_VAR 0 7
84997: ARRAY
84998: PPUSH
84999: CALL_OW 74
85003: ST_TO_ADDR
// if not k then
85004: LD_VAR 0 9
85008: NOT
85009: IFFALSE 85013
// continue ;
85011: GO 81428
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
85013: LD_VAR 0 9
85017: PUSH
85018: LD_INT 81
85020: PUSH
85021: LD_VAR 0 4
85025: PUSH
85026: LD_VAR 0 7
85030: ARRAY
85031: PPUSH
85032: CALL_OW 255
85036: PUSH
85037: EMPTY
85038: LIST
85039: LIST
85040: PPUSH
85041: CALL_OW 69
85045: IN
85046: PUSH
85047: LD_VAR 0 9
85051: PPUSH
85052: LD_VAR 0 4
85056: PUSH
85057: LD_VAR 0 7
85061: ARRAY
85062: PPUSH
85063: CALL_OW 296
85067: PUSH
85068: LD_INT 5
85070: LESS
85071: AND
85072: IFFALSE 85089
// ComAutodestruct ( group [ i ] ) ;
85074: LD_VAR 0 4
85078: PUSH
85079: LD_VAR 0 7
85083: ARRAY
85084: PPUSH
85085: CALL 52205 0 1
// end ; if f_attack_depot then
85089: LD_VAR 0 25
85093: IFFALSE 85205
// begin k := 6 ;
85095: LD_ADDR_VAR 0 9
85099: PUSH
85100: LD_INT 6
85102: ST_TO_ADDR
// if tmp < k then
85103: LD_VAR 0 14
85107: PUSH
85108: LD_VAR 0 9
85112: LESS
85113: IFFALSE 85125
// k := tmp ;
85115: LD_ADDR_VAR 0 9
85119: PUSH
85120: LD_VAR 0 14
85124: ST_TO_ADDR
// for j = 1 to k do
85125: LD_ADDR_VAR 0 8
85129: PUSH
85130: DOUBLE
85131: LD_INT 1
85133: DEC
85134: ST_TO_ADDR
85135: LD_VAR 0 9
85139: PUSH
85140: FOR_TO
85141: IFFALSE 85203
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
85143: LD_VAR 0 8
85147: PPUSH
85148: CALL_OW 266
85152: PUSH
85153: LD_INT 0
85155: PUSH
85156: LD_INT 1
85158: PUSH
85159: EMPTY
85160: LIST
85161: LIST
85162: IN
85163: IFFALSE 85201
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
85165: LD_VAR 0 4
85169: PUSH
85170: LD_VAR 0 7
85174: ARRAY
85175: PPUSH
85176: LD_VAR 0 14
85180: PUSH
85181: LD_VAR 0 8
85185: ARRAY
85186: PPUSH
85187: CALL_OW 115
// attacking := true ;
85191: LD_ADDR_VAR 0 29
85195: PUSH
85196: LD_INT 1
85198: ST_TO_ADDR
// break ;
85199: GO 85203
// end ;
85201: GO 85140
85203: POP
85204: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
85205: LD_VAR 0 4
85209: PUSH
85210: LD_VAR 0 7
85214: ARRAY
85215: PPUSH
85216: CALL_OW 302
85220: PUSH
85221: LD_VAR 0 29
85225: NOT
85226: AND
85227: IFFALSE 85549
// begin if GetTag ( group [ i ] ) = 71 then
85229: LD_VAR 0 4
85233: PUSH
85234: LD_VAR 0 7
85238: ARRAY
85239: PPUSH
85240: CALL_OW 110
85244: PUSH
85245: LD_INT 71
85247: EQUAL
85248: IFFALSE 85289
// begin if HasTask ( group [ i ] ) then
85250: LD_VAR 0 4
85254: PUSH
85255: LD_VAR 0 7
85259: ARRAY
85260: PPUSH
85261: CALL_OW 314
85265: IFFALSE 85271
// continue else
85267: GO 81428
85269: GO 85289
// SetTag ( group [ i ] , 0 ) ;
85271: LD_VAR 0 4
85275: PUSH
85276: LD_VAR 0 7
85280: ARRAY
85281: PPUSH
85282: LD_INT 0
85284: PPUSH
85285: CALL_OW 109
// end ; k := 8 ;
85289: LD_ADDR_VAR 0 9
85293: PUSH
85294: LD_INT 8
85296: ST_TO_ADDR
// x := 0 ;
85297: LD_ADDR_VAR 0 10
85301: PUSH
85302: LD_INT 0
85304: ST_TO_ADDR
// if tmp < k then
85305: LD_VAR 0 14
85309: PUSH
85310: LD_VAR 0 9
85314: LESS
85315: IFFALSE 85327
// k := tmp ;
85317: LD_ADDR_VAR 0 9
85321: PUSH
85322: LD_VAR 0 14
85326: ST_TO_ADDR
// for j = 1 to k do
85327: LD_ADDR_VAR 0 8
85331: PUSH
85332: DOUBLE
85333: LD_INT 1
85335: DEC
85336: ST_TO_ADDR
85337: LD_VAR 0 9
85341: PUSH
85342: FOR_TO
85343: IFFALSE 85441
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
85345: LD_VAR 0 14
85349: PUSH
85350: LD_VAR 0 8
85354: ARRAY
85355: PPUSH
85356: CALL_OW 247
85360: PUSH
85361: LD_INT 1
85363: EQUAL
85364: PUSH
85365: LD_VAR 0 14
85369: PUSH
85370: LD_VAR 0 8
85374: ARRAY
85375: PPUSH
85376: CALL_OW 256
85380: PUSH
85381: LD_INT 250
85383: LESS
85384: PUSH
85385: LD_VAR 0 20
85389: AND
85390: PUSH
85391: LD_VAR 0 20
85395: NOT
85396: PUSH
85397: LD_VAR 0 14
85401: PUSH
85402: LD_VAR 0 8
85406: ARRAY
85407: PPUSH
85408: CALL_OW 256
85412: PUSH
85413: LD_INT 250
85415: GREATEREQUAL
85416: AND
85417: OR
85418: AND
85419: IFFALSE 85439
// begin x := tmp [ j ] ;
85421: LD_ADDR_VAR 0 10
85425: PUSH
85426: LD_VAR 0 14
85430: PUSH
85431: LD_VAR 0 8
85435: ARRAY
85436: ST_TO_ADDR
// break ;
85437: GO 85441
// end ;
85439: GO 85342
85441: POP
85442: POP
// if x then
85443: LD_VAR 0 10
85447: IFFALSE 85471
// ComAttackUnit ( group [ i ] , x ) else
85449: LD_VAR 0 4
85453: PUSH
85454: LD_VAR 0 7
85458: ARRAY
85459: PPUSH
85460: LD_VAR 0 10
85464: PPUSH
85465: CALL_OW 115
85469: GO 85495
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
85471: LD_VAR 0 4
85475: PUSH
85476: LD_VAR 0 7
85480: ARRAY
85481: PPUSH
85482: LD_VAR 0 14
85486: PUSH
85487: LD_INT 1
85489: ARRAY
85490: PPUSH
85491: CALL_OW 115
// if not HasTask ( group [ i ] ) then
85495: LD_VAR 0 4
85499: PUSH
85500: LD_VAR 0 7
85504: ARRAY
85505: PPUSH
85506: CALL_OW 314
85510: NOT
85511: IFFALSE 85549
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
85513: LD_VAR 0 4
85517: PUSH
85518: LD_VAR 0 7
85522: ARRAY
85523: PPUSH
85524: LD_VAR 0 14
85528: PPUSH
85529: LD_VAR 0 4
85533: PUSH
85534: LD_VAR 0 7
85538: ARRAY
85539: PPUSH
85540: CALL_OW 74
85544: PPUSH
85545: CALL_OW 115
// end ; end ; end ;
85549: GO 81428
85551: POP
85552: POP
// wait ( 0 0$2 ) ;
85553: LD_INT 70
85555: PPUSH
85556: CALL_OW 67
// until not group or group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
85560: LD_VAR 0 4
85564: NOT
85565: PUSH
85566: LD_VAR 0 4
85570: PUSH
85571: EMPTY
85572: EQUAL
85573: OR
85574: PUSH
85575: LD_INT 81
85577: PUSH
85578: LD_VAR 0 35
85582: PUSH
85583: EMPTY
85584: LIST
85585: LIST
85586: PPUSH
85587: CALL_OW 69
85591: NOT
85592: OR
85593: IFFALSE 81413
// end ;
85595: LD_VAR 0 2
85599: RET
// export function BasicDefend ( base , solds ) ; var enemy , e , side , i , hex ; begin
85600: LD_INT 0
85602: PPUSH
85603: PPUSH
85604: PPUSH
85605: PPUSH
85606: PPUSH
85607: PPUSH
// if not base or not mc_bases [ base ] or not solds then
85608: LD_VAR 0 1
85612: NOT
85613: PUSH
85614: LD_EXP 161
85618: PUSH
85619: LD_VAR 0 1
85623: ARRAY
85624: NOT
85625: OR
85626: PUSH
85627: LD_VAR 0 2
85631: NOT
85632: OR
85633: IFFALSE 85637
// exit ;
85635: GO 86191
// side := mc_sides [ base ] ;
85637: LD_ADDR_VAR 0 6
85641: PUSH
85642: LD_EXP 187
85646: PUSH
85647: LD_VAR 0 1
85651: ARRAY
85652: ST_TO_ADDR
// if not side then
85653: LD_VAR 0 6
85657: NOT
85658: IFFALSE 85662
// exit ;
85660: GO 86191
// for i in solds do
85662: LD_ADDR_VAR 0 7
85666: PUSH
85667: LD_VAR 0 2
85671: PUSH
85672: FOR_IN
85673: IFFALSE 85734
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
85675: LD_VAR 0 7
85679: PPUSH
85680: CALL_OW 310
85684: PPUSH
85685: CALL_OW 266
85689: PUSH
85690: LD_INT 32
85692: PUSH
85693: LD_INT 31
85695: PUSH
85696: EMPTY
85697: LIST
85698: LIST
85699: IN
85700: IFFALSE 85720
// solds := solds diff i else
85702: LD_ADDR_VAR 0 2
85706: PUSH
85707: LD_VAR 0 2
85711: PUSH
85712: LD_VAR 0 7
85716: DIFF
85717: ST_TO_ADDR
85718: GO 85732
// SetTag ( i , 18 ) ;
85720: LD_VAR 0 7
85724: PPUSH
85725: LD_INT 18
85727: PPUSH
85728: CALL_OW 109
85732: GO 85672
85734: POP
85735: POP
// if not solds then
85736: LD_VAR 0 2
85740: NOT
85741: IFFALSE 85745
// exit ;
85743: GO 86191
// repeat wait ( 0 0$2 ) ;
85745: LD_INT 70
85747: PPUSH
85748: CALL_OW 67
// enemy := mc_scan [ base ] ;
85752: LD_ADDR_VAR 0 4
85756: PUSH
85757: LD_EXP 184
85761: PUSH
85762: LD_VAR 0 1
85766: ARRAY
85767: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
85768: LD_EXP 161
85772: PUSH
85773: LD_VAR 0 1
85777: ARRAY
85778: NOT
85779: PUSH
85780: LD_EXP 161
85784: PUSH
85785: LD_VAR 0 1
85789: ARRAY
85790: PUSH
85791: EMPTY
85792: EQUAL
85793: OR
85794: IFFALSE 85831
// begin for i in solds do
85796: LD_ADDR_VAR 0 7
85800: PUSH
85801: LD_VAR 0 2
85805: PUSH
85806: FOR_IN
85807: IFFALSE 85820
// ComStop ( i ) ;
85809: LD_VAR 0 7
85813: PPUSH
85814: CALL_OW 141
85818: GO 85806
85820: POP
85821: POP
// solds := [ ] ;
85822: LD_ADDR_VAR 0 2
85826: PUSH
85827: EMPTY
85828: ST_TO_ADDR
// exit ;
85829: GO 86191
// end ; for i in solds do
85831: LD_ADDR_VAR 0 7
85835: PUSH
85836: LD_VAR 0 2
85840: PUSH
85841: FOR_IN
85842: IFFALSE 86163
// begin if IsInUnit ( i ) then
85844: LD_VAR 0 7
85848: PPUSH
85849: CALL_OW 310
85853: IFFALSE 85864
// ComExitBuilding ( i ) ;
85855: LD_VAR 0 7
85859: PPUSH
85860: CALL_OW 122
// if GetLives ( i ) > 500 then
85864: LD_VAR 0 7
85868: PPUSH
85869: CALL_OW 256
85873: PUSH
85874: LD_INT 500
85876: GREATER
85877: IFFALSE 85930
// begin e := NearestUnitToUnit ( enemy , i ) ;
85879: LD_ADDR_VAR 0 5
85883: PUSH
85884: LD_VAR 0 4
85888: PPUSH
85889: LD_VAR 0 7
85893: PPUSH
85894: CALL_OW 74
85898: ST_TO_ADDR
// ComAgressiveMove ( i , GetX ( e ) , GetY ( e ) ) ;
85899: LD_VAR 0 7
85903: PPUSH
85904: LD_VAR 0 5
85908: PPUSH
85909: CALL_OW 250
85913: PPUSH
85914: LD_VAR 0 5
85918: PPUSH
85919: CALL_OW 251
85923: PPUSH
85924: CALL_OW 114
// end else
85928: GO 86161
// if GetDistUnits ( i , NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ) > 10 then
85930: LD_VAR 0 7
85934: PPUSH
85935: LD_EXP 161
85939: PUSH
85940: LD_VAR 0 1
85944: ARRAY
85945: PPUSH
85946: LD_INT 2
85948: PUSH
85949: LD_INT 30
85951: PUSH
85952: LD_INT 0
85954: PUSH
85955: EMPTY
85956: LIST
85957: LIST
85958: PUSH
85959: LD_INT 30
85961: PUSH
85962: LD_INT 1
85964: PUSH
85965: EMPTY
85966: LIST
85967: LIST
85968: PUSH
85969: LD_INT 30
85971: PUSH
85972: LD_INT 6
85974: PUSH
85975: EMPTY
85976: LIST
85977: LIST
85978: PUSH
85979: EMPTY
85980: LIST
85981: LIST
85982: LIST
85983: LIST
85984: PPUSH
85985: CALL_OW 72
85989: PPUSH
85990: LD_VAR 0 7
85994: PPUSH
85995: CALL_OW 74
85999: PPUSH
86000: CALL_OW 296
86004: PUSH
86005: LD_INT 10
86007: GREATER
86008: IFFALSE 86161
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
86010: LD_ADDR_VAR 0 8
86014: PUSH
86015: LD_EXP 161
86019: PUSH
86020: LD_VAR 0 1
86024: ARRAY
86025: PPUSH
86026: LD_INT 2
86028: PUSH
86029: LD_INT 30
86031: PUSH
86032: LD_INT 0
86034: PUSH
86035: EMPTY
86036: LIST
86037: LIST
86038: PUSH
86039: LD_INT 30
86041: PUSH
86042: LD_INT 1
86044: PUSH
86045: EMPTY
86046: LIST
86047: LIST
86048: PUSH
86049: LD_INT 30
86051: PUSH
86052: LD_INT 6
86054: PUSH
86055: EMPTY
86056: LIST
86057: LIST
86058: PUSH
86059: EMPTY
86060: LIST
86061: LIST
86062: LIST
86063: LIST
86064: PPUSH
86065: CALL_OW 72
86069: PPUSH
86070: LD_VAR 0 7
86074: PPUSH
86075: CALL_OW 74
86079: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
86080: LD_VAR 0 7
86084: PPUSH
86085: LD_VAR 0 8
86089: PPUSH
86090: CALL_OW 250
86094: PPUSH
86095: LD_INT 3
86097: PPUSH
86098: LD_INT 5
86100: PPUSH
86101: CALL_OW 272
86105: PPUSH
86106: LD_VAR 0 8
86110: PPUSH
86111: CALL_OW 251
86115: PPUSH
86116: LD_INT 3
86118: PPUSH
86119: LD_INT 5
86121: PPUSH
86122: CALL_OW 273
86126: PPUSH
86127: CALL_OW 111
// SetTag ( i , 0 ) ;
86131: LD_VAR 0 7
86135: PPUSH
86136: LD_INT 0
86138: PPUSH
86139: CALL_OW 109
// solds := solds diff i ;
86143: LD_ADDR_VAR 0 2
86147: PUSH
86148: LD_VAR 0 2
86152: PUSH
86153: LD_VAR 0 7
86157: DIFF
86158: ST_TO_ADDR
// continue ;
86159: GO 85841
// end ; end ;
86161: GO 85841
86163: POP
86164: POP
// until not solds or not enemy ;
86165: LD_VAR 0 2
86169: NOT
86170: PUSH
86171: LD_VAR 0 4
86175: NOT
86176: OR
86177: IFFALSE 85745
// MC_Reset ( base , 18 ) ;
86179: LD_VAR 0 1
86183: PPUSH
86184: LD_INT 18
86186: PPUSH
86187: CALL 92353 0 2
// end ;
86191: LD_VAR 0 3
86195: RET
// export function Defend ( base , defenders ) ; var i , j , x , depot , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend , class , enemy ; begin
86196: LD_INT 0
86198: PPUSH
86199: PPUSH
86200: PPUSH
86201: PPUSH
86202: PPUSH
86203: PPUSH
86204: PPUSH
86205: PPUSH
86206: PPUSH
86207: PPUSH
86208: PPUSH
86209: PPUSH
86210: PPUSH
86211: PPUSH
86212: PPUSH
86213: PPUSH
86214: PPUSH
86215: PPUSH
86216: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
86217: LD_ADDR_VAR 0 12
86221: PUSH
86222: LD_EXP 161
86226: PUSH
86227: LD_VAR 0 1
86231: ARRAY
86232: PPUSH
86233: LD_INT 25
86235: PUSH
86236: LD_INT 3
86238: PUSH
86239: EMPTY
86240: LIST
86241: LIST
86242: PPUSH
86243: CALL_OW 72
86247: ST_TO_ADDR
// if mc_remote_driver [ base ] then
86248: LD_EXP 201
86252: PUSH
86253: LD_VAR 0 1
86257: ARRAY
86258: IFFALSE 86282
// mechs := mechs diff mc_remote_driver [ base ] ;
86260: LD_ADDR_VAR 0 12
86264: PUSH
86265: LD_VAR 0 12
86269: PUSH
86270: LD_EXP 201
86274: PUSH
86275: LD_VAR 0 1
86279: ARRAY
86280: DIFF
86281: ST_TO_ADDR
// for i in mechs do
86282: LD_ADDR_VAR 0 4
86286: PUSH
86287: LD_VAR 0 12
86291: PUSH
86292: FOR_IN
86293: IFFALSE 86328
// if GetTag ( i ) > 0 then
86295: LD_VAR 0 4
86299: PPUSH
86300: CALL_OW 110
86304: PUSH
86305: LD_INT 0
86307: GREATER
86308: IFFALSE 86326
// mechs := mechs diff i ;
86310: LD_ADDR_VAR 0 12
86314: PUSH
86315: LD_VAR 0 12
86319: PUSH
86320: LD_VAR 0 4
86324: DIFF
86325: ST_TO_ADDR
86326: GO 86292
86328: POP
86329: POP
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
86330: LD_ADDR_VAR 0 8
86334: PUSH
86335: LD_EXP 161
86339: PUSH
86340: LD_VAR 0 1
86344: ARRAY
86345: PPUSH
86346: LD_INT 2
86348: PUSH
86349: LD_INT 25
86351: PUSH
86352: LD_INT 1
86354: PUSH
86355: EMPTY
86356: LIST
86357: LIST
86358: PUSH
86359: LD_INT 25
86361: PUSH
86362: LD_INT 5
86364: PUSH
86365: EMPTY
86366: LIST
86367: LIST
86368: PUSH
86369: LD_INT 25
86371: PUSH
86372: LD_INT 8
86374: PUSH
86375: EMPTY
86376: LIST
86377: LIST
86378: PUSH
86379: LD_INT 25
86381: PUSH
86382: LD_INT 9
86384: PUSH
86385: EMPTY
86386: LIST
86387: LIST
86388: PUSH
86389: EMPTY
86390: LIST
86391: LIST
86392: LIST
86393: LIST
86394: LIST
86395: PPUSH
86396: CALL_OW 72
86400: ST_TO_ADDR
// if not defenders and not solds then
86401: LD_VAR 0 2
86405: NOT
86406: PUSH
86407: LD_VAR 0 8
86411: NOT
86412: AND
86413: IFFALSE 86417
// exit ;
86415: GO 88187
// depot_under_attack := false ;
86417: LD_ADDR_VAR 0 16
86421: PUSH
86422: LD_INT 0
86424: ST_TO_ADDR
// sold_defenders := [ ] ;
86425: LD_ADDR_VAR 0 17
86429: PUSH
86430: EMPTY
86431: ST_TO_ADDR
// if mechs then
86432: LD_VAR 0 12
86436: IFFALSE 86589
// for i in UnitFilter ( defenders , [ f_type , unit_vehicle ] ) do
86438: LD_ADDR_VAR 0 4
86442: PUSH
86443: LD_VAR 0 2
86447: PPUSH
86448: LD_INT 21
86450: PUSH
86451: LD_INT 2
86453: PUSH
86454: EMPTY
86455: LIST
86456: LIST
86457: PPUSH
86458: CALL_OW 72
86462: PUSH
86463: FOR_IN
86464: IFFALSE 86587
// begin if GetTag ( i ) <> 20 then
86466: LD_VAR 0 4
86470: PPUSH
86471: CALL_OW 110
86475: PUSH
86476: LD_INT 20
86478: NONEQUAL
86479: IFFALSE 86493
// SetTag ( i , 20 ) ;
86481: LD_VAR 0 4
86485: PPUSH
86486: LD_INT 20
86488: PPUSH
86489: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) then
86493: LD_VAR 0 4
86497: PPUSH
86498: CALL_OW 263
86502: PUSH
86503: LD_INT 1
86505: EQUAL
86506: PUSH
86507: LD_VAR 0 4
86511: PPUSH
86512: CALL_OW 311
86516: NOT
86517: AND
86518: IFFALSE 86585
// begin un := mechs [ 1 ] ;
86520: LD_ADDR_VAR 0 10
86524: PUSH
86525: LD_VAR 0 12
86529: PUSH
86530: LD_INT 1
86532: ARRAY
86533: ST_TO_ADDR
// ComExit ( un ) ;
86534: LD_VAR 0 10
86538: PPUSH
86539: CALL 57090 0 1
// AddComEnterUnit ( un , i ) ;
86543: LD_VAR 0 10
86547: PPUSH
86548: LD_VAR 0 4
86552: PPUSH
86553: CALL_OW 180
// SetTag ( un , 19 ) ;
86557: LD_VAR 0 10
86561: PPUSH
86562: LD_INT 19
86564: PPUSH
86565: CALL_OW 109
// mechs := mechs diff un ;
86569: LD_ADDR_VAR 0 12
86573: PUSH
86574: LD_VAR 0 12
86578: PUSH
86579: LD_VAR 0 10
86583: DIFF
86584: ST_TO_ADDR
// end ; end ;
86585: GO 86463
86587: POP
86588: POP
// if solds then
86589: LD_VAR 0 8
86593: IFFALSE 86652
// for i in solds do
86595: LD_ADDR_VAR 0 4
86599: PUSH
86600: LD_VAR 0 8
86604: PUSH
86605: FOR_IN
86606: IFFALSE 86650
// if not GetTag ( i ) then
86608: LD_VAR 0 4
86612: PPUSH
86613: CALL_OW 110
86617: NOT
86618: IFFALSE 86648
// begin defenders := defenders union i ;
86620: LD_ADDR_VAR 0 2
86624: PUSH
86625: LD_VAR 0 2
86629: PUSH
86630: LD_VAR 0 4
86634: UNION
86635: ST_TO_ADDR
// SetTag ( i , 18 ) ;
86636: LD_VAR 0 4
86640: PPUSH
86641: LD_INT 18
86643: PPUSH
86644: CALL_OW 109
// end ;
86648: GO 86605
86650: POP
86651: POP
// repeat wait ( 0 0$2 ) ;
86652: LD_INT 70
86654: PPUSH
86655: CALL_OW 67
// enemy := mc_scan [ base ] ;
86659: LD_ADDR_VAR 0 21
86663: PUSH
86664: LD_EXP 184
86668: PUSH
86669: LD_VAR 0 1
86673: ARRAY
86674: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
86675: LD_EXP 161
86679: PUSH
86680: LD_VAR 0 1
86684: ARRAY
86685: NOT
86686: PUSH
86687: LD_EXP 161
86691: PUSH
86692: LD_VAR 0 1
86696: ARRAY
86697: PUSH
86698: EMPTY
86699: EQUAL
86700: OR
86701: IFFALSE 86738
// begin for i in defenders do
86703: LD_ADDR_VAR 0 4
86707: PUSH
86708: LD_VAR 0 2
86712: PUSH
86713: FOR_IN
86714: IFFALSE 86727
// ComStop ( i ) ;
86716: LD_VAR 0 4
86720: PPUSH
86721: CALL_OW 141
86725: GO 86713
86727: POP
86728: POP
// defenders := [ ] ;
86729: LD_ADDR_VAR 0 2
86733: PUSH
86734: EMPTY
86735: ST_TO_ADDR
// exit ;
86736: GO 88187
// end ; for i in defenders do
86738: LD_ADDR_VAR 0 4
86742: PUSH
86743: LD_VAR 0 2
86747: PUSH
86748: FOR_IN
86749: IFFALSE 87647
// begin e := NearestUnitToUnit ( enemy , i ) ;
86751: LD_ADDR_VAR 0 13
86755: PUSH
86756: LD_VAR 0 21
86760: PPUSH
86761: LD_VAR 0 4
86765: PPUSH
86766: CALL_OW 74
86770: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
86771: LD_ADDR_VAR 0 7
86775: PUSH
86776: LD_EXP 161
86780: PUSH
86781: LD_VAR 0 1
86785: ARRAY
86786: PPUSH
86787: LD_INT 2
86789: PUSH
86790: LD_INT 30
86792: PUSH
86793: LD_INT 0
86795: PUSH
86796: EMPTY
86797: LIST
86798: LIST
86799: PUSH
86800: LD_INT 30
86802: PUSH
86803: LD_INT 1
86805: PUSH
86806: EMPTY
86807: LIST
86808: LIST
86809: PUSH
86810: EMPTY
86811: LIST
86812: LIST
86813: LIST
86814: PPUSH
86815: CALL_OW 72
86819: ST_TO_ADDR
// depot_under_attack := ( not depot or UnitFilter ( depot , [ f_not , [ f_lives , 600 ] ] ) ) ;
86820: LD_ADDR_VAR 0 16
86824: PUSH
86825: LD_VAR 0 7
86829: NOT
86830: PUSH
86831: LD_VAR 0 7
86835: PPUSH
86836: LD_INT 3
86838: PUSH
86839: LD_INT 24
86841: PUSH
86842: LD_INT 600
86844: PUSH
86845: EMPTY
86846: LIST
86847: LIST
86848: PUSH
86849: EMPTY
86850: LIST
86851: LIST
86852: PPUSH
86853: CALL_OW 72
86857: OR
86858: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
86859: LD_VAR 0 4
86863: PPUSH
86864: CALL_OW 247
86868: PUSH
86869: LD_INT 2
86871: DOUBLE
86872: EQUAL
86873: IFTRUE 86877
86875: GO 87273
86877: POP
// begin if GetLives ( i ) = 1000 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
86878: LD_VAR 0 4
86882: PPUSH
86883: CALL_OW 256
86887: PUSH
86888: LD_INT 1000
86890: EQUAL
86891: PUSH
86892: LD_VAR 0 4
86896: PPUSH
86897: LD_VAR 0 13
86901: PPUSH
86902: CALL_OW 296
86906: PUSH
86907: LD_INT 40
86909: LESS
86910: PUSH
86911: LD_VAR 0 13
86915: PPUSH
86916: LD_EXP 186
86920: PUSH
86921: LD_VAR 0 1
86925: ARRAY
86926: PPUSH
86927: CALL_OW 308
86931: OR
86932: AND
86933: IFFALSE 87055
// begin if GetEngine ( i ) = engine_combustion and GetFuel ( i ) < 30 and depot then
86935: LD_VAR 0 4
86939: PPUSH
86940: CALL_OW 262
86944: PUSH
86945: LD_INT 1
86947: EQUAL
86948: PUSH
86949: LD_VAR 0 4
86953: PPUSH
86954: CALL_OW 261
86958: PUSH
86959: LD_INT 30
86961: LESS
86962: AND
86963: PUSH
86964: LD_VAR 0 7
86968: AND
86969: IFFALSE 87039
// begin ComMoveUnit ( i , NearestUnitToUnit ( depot , i ) ) ;
86971: LD_VAR 0 4
86975: PPUSH
86976: LD_VAR 0 7
86980: PPUSH
86981: LD_VAR 0 4
86985: PPUSH
86986: CALL_OW 74
86990: PPUSH
86991: CALL_OW 112
// if GetDistUnits ( i , NearestUnitToUnit ( depot , i ) ) < 6 then
86995: LD_VAR 0 4
86999: PPUSH
87000: LD_VAR 0 7
87004: PPUSH
87005: LD_VAR 0 4
87009: PPUSH
87010: CALL_OW 74
87014: PPUSH
87015: CALL_OW 296
87019: PUSH
87020: LD_INT 6
87022: LESS
87023: IFFALSE 87037
// SetFuel ( i , 100 ) ;
87025: LD_VAR 0 4
87029: PPUSH
87030: LD_INT 100
87032: PPUSH
87033: CALL_OW 240
// end else
87037: GO 87053
// ComAttackUnit ( i , e ) ;
87039: LD_VAR 0 4
87043: PPUSH
87044: LD_VAR 0 13
87048: PPUSH
87049: CALL_OW 115
// end else
87053: GO 87156
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
87055: LD_VAR 0 13
87059: PPUSH
87060: LD_EXP 186
87064: PUSH
87065: LD_VAR 0 1
87069: ARRAY
87070: PPUSH
87071: CALL_OW 308
87075: NOT
87076: PUSH
87077: LD_VAR 0 4
87081: PPUSH
87082: LD_VAR 0 13
87086: PPUSH
87087: CALL_OW 296
87091: PUSH
87092: LD_INT 40
87094: GREATEREQUAL
87095: AND
87096: PUSH
87097: LD_VAR 0 4
87101: PPUSH
87102: CALL_OW 256
87106: PUSH
87107: LD_INT 650
87109: LESSEQUAL
87110: OR
87111: PUSH
87112: LD_VAR 0 4
87116: PPUSH
87117: LD_EXP 185
87121: PUSH
87122: LD_VAR 0 1
87126: ARRAY
87127: PPUSH
87128: CALL_OW 308
87132: NOT
87133: AND
87134: IFFALSE 87156
// ComMoveToArea ( i , mc_parking [ base ] ) ;
87136: LD_VAR 0 4
87140: PPUSH
87141: LD_EXP 185
87145: PUSH
87146: LD_VAR 0 1
87150: ARRAY
87151: PPUSH
87152: CALL_OW 113
// if GetLives ( i ) < 1000 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
87156: LD_VAR 0 4
87160: PPUSH
87161: CALL_OW 256
87165: PUSH
87166: LD_INT 1000
87168: LESS
87169: PUSH
87170: LD_VAR 0 4
87174: PPUSH
87175: CALL_OW 263
87179: PUSH
87180: LD_INT 1
87182: EQUAL
87183: AND
87184: PUSH
87185: LD_VAR 0 4
87189: PPUSH
87190: CALL_OW 311
87194: AND
87195: PUSH
87196: LD_VAR 0 4
87200: PPUSH
87201: LD_EXP 185
87205: PUSH
87206: LD_VAR 0 1
87210: ARRAY
87211: PPUSH
87212: CALL_OW 308
87216: AND
87217: IFFALSE 87271
// begin mech := IsDrivenBy ( i ) ;
87219: LD_ADDR_VAR 0 9
87223: PUSH
87224: LD_VAR 0 4
87228: PPUSH
87229: CALL_OW 311
87233: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
87234: LD_VAR 0 9
87238: PPUSH
87239: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
87243: LD_VAR 0 9
87247: PPUSH
87248: LD_VAR 0 4
87252: PPUSH
87253: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
87257: LD_VAR 0 9
87261: PPUSH
87262: LD_VAR 0 4
87266: PPUSH
87267: CALL_OW 180
// end ; end ; unit_human :
87271: GO 87618
87273: LD_INT 1
87275: DOUBLE
87276: EQUAL
87277: IFTRUE 87281
87279: GO 87617
87281: POP
// begin b := IsInUnit ( i ) ;
87282: LD_ADDR_VAR 0 18
87286: PUSH
87287: LD_VAR 0 4
87291: PPUSH
87292: CALL_OW 310
87296: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
87297: LD_ADDR_VAR 0 19
87301: PUSH
87302: LD_VAR 0 18
87306: NOT
87307: PUSH
87308: LD_VAR 0 18
87312: PPUSH
87313: CALL_OW 266
87317: PUSH
87318: LD_INT 32
87320: PUSH
87321: LD_INT 31
87323: PUSH
87324: EMPTY
87325: LIST
87326: LIST
87327: IN
87328: OR
87329: ST_TO_ADDR
// if GetBType ( b ) = b_barracks and GetClass ( i ) in [ 1 , 2 , 3 , 4 ] then
87330: LD_VAR 0 18
87334: PPUSH
87335: CALL_OW 266
87339: PUSH
87340: LD_INT 5
87342: EQUAL
87343: PUSH
87344: LD_VAR 0 4
87348: PPUSH
87349: CALL_OW 257
87353: PUSH
87354: LD_INT 1
87356: PUSH
87357: LD_INT 2
87359: PUSH
87360: LD_INT 3
87362: PUSH
87363: LD_INT 4
87365: PUSH
87366: EMPTY
87367: LIST
87368: LIST
87369: LIST
87370: LIST
87371: IN
87372: AND
87373: IFFALSE 87410
// begin class := AllowSpecClass ( i ) ;
87375: LD_ADDR_VAR 0 20
87379: PUSH
87380: LD_VAR 0 4
87384: PPUSH
87385: CALL 21010 0 1
87389: ST_TO_ADDR
// if class then
87390: LD_VAR 0 20
87394: IFFALSE 87410
// ComChangeProfession ( i , class ) ;
87396: LD_VAR 0 4
87400: PPUSH
87401: LD_VAR 0 20
87405: PPUSH
87406: CALL_OW 123
// end ; if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
87410: LD_VAR 0 16
87414: PUSH
87415: LD_VAR 0 2
87419: PPUSH
87420: LD_INT 21
87422: PUSH
87423: LD_INT 2
87425: PUSH
87426: EMPTY
87427: LIST
87428: LIST
87429: PPUSH
87430: CALL_OW 72
87434: PUSH
87435: LD_INT 1
87437: LESSEQUAL
87438: OR
87439: PUSH
87440: LD_VAR 0 19
87444: AND
87445: PUSH
87446: LD_VAR 0 4
87450: PUSH
87451: LD_VAR 0 17
87455: IN
87456: NOT
87457: AND
87458: IFFALSE 87551
// begin if b then
87460: LD_VAR 0 18
87464: IFFALSE 87513
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
87466: LD_VAR 0 18
87470: PPUSH
87471: LD_VAR 0 21
87475: PPUSH
87476: LD_VAR 0 18
87480: PPUSH
87481: CALL_OW 74
87485: PPUSH
87486: CALL_OW 296
87490: PUSH
87491: LD_INT 10
87493: LESS
87494: PUSH
87495: LD_VAR 0 18
87499: PPUSH
87500: CALL_OW 461
87504: PUSH
87505: LD_INT 7
87507: NONEQUAL
87508: AND
87509: IFFALSE 87513
// continue ;
87511: GO 86748
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
87513: LD_ADDR_VAR 0 17
87517: PUSH
87518: LD_VAR 0 17
87522: PPUSH
87523: LD_VAR 0 17
87527: PUSH
87528: LD_INT 1
87530: PLUS
87531: PPUSH
87532: LD_VAR 0 4
87536: PPUSH
87537: CALL_OW 1
87541: ST_TO_ADDR
// ComExitBuilding ( i ) ;
87542: LD_VAR 0 4
87546: PPUSH
87547: CALL_OW 122
// end ; if sold_defenders then
87551: LD_VAR 0 17
87555: IFFALSE 87615
// if i in sold_defenders then
87557: LD_VAR 0 4
87561: PUSH
87562: LD_VAR 0 17
87566: IN
87567: IFFALSE 87615
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
87569: LD_VAR 0 4
87573: PPUSH
87574: CALL_OW 314
87578: NOT
87579: PUSH
87580: LD_VAR 0 4
87584: PPUSH
87585: LD_VAR 0 13
87589: PPUSH
87590: CALL_OW 296
87594: PUSH
87595: LD_INT 30
87597: LESS
87598: AND
87599: IFFALSE 87615
// ComAttackUnit ( i , e ) ;
87601: LD_VAR 0 4
87605: PPUSH
87606: LD_VAR 0 13
87610: PPUSH
87611: CALL_OW 115
// end ; end ; end ;
87615: GO 87618
87617: POP
// if IsDead ( i ) then
87618: LD_VAR 0 4
87622: PPUSH
87623: CALL_OW 301
87627: IFFALSE 87645
// defenders := defenders diff i ;
87629: LD_ADDR_VAR 0 2
87633: PUSH
87634: LD_VAR 0 2
87638: PUSH
87639: LD_VAR 0 4
87643: DIFF
87644: ST_TO_ADDR
// end ;
87645: GO 86748
87647: POP
87648: POP
// until not enemy or not defenders or not mc_bases [ base ] ;
87649: LD_VAR 0 21
87653: NOT
87654: PUSH
87655: LD_VAR 0 2
87659: NOT
87660: OR
87661: PUSH
87662: LD_EXP 161
87666: PUSH
87667: LD_VAR 0 1
87671: ARRAY
87672: NOT
87673: OR
87674: IFFALSE 86652
// MC_Reset ( base , 18 ) ;
87676: LD_VAR 0 1
87680: PPUSH
87681: LD_INT 18
87683: PPUSH
87684: CALL 92353 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
87688: LD_ADDR_VAR 0 2
87692: PUSH
87693: LD_VAR 0 2
87697: PUSH
87698: LD_VAR 0 2
87702: PPUSH
87703: LD_INT 2
87705: PUSH
87706: LD_INT 25
87708: PUSH
87709: LD_INT 1
87711: PUSH
87712: EMPTY
87713: LIST
87714: LIST
87715: PUSH
87716: LD_INT 25
87718: PUSH
87719: LD_INT 5
87721: PUSH
87722: EMPTY
87723: LIST
87724: LIST
87725: PUSH
87726: LD_INT 25
87728: PUSH
87729: LD_INT 8
87731: PUSH
87732: EMPTY
87733: LIST
87734: LIST
87735: PUSH
87736: LD_INT 25
87738: PUSH
87739: LD_INT 9
87741: PUSH
87742: EMPTY
87743: LIST
87744: LIST
87745: PUSH
87746: EMPTY
87747: LIST
87748: LIST
87749: LIST
87750: LIST
87751: LIST
87752: PPUSH
87753: CALL_OW 72
87757: DIFF
87758: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
87759: LD_VAR 0 21
87763: NOT
87764: PUSH
87765: LD_VAR 0 2
87769: PPUSH
87770: LD_INT 21
87772: PUSH
87773: LD_INT 2
87775: PUSH
87776: EMPTY
87777: LIST
87778: LIST
87779: PPUSH
87780: CALL_OW 72
87784: AND
87785: IFFALSE 88123
// begin tmp := FilterByTag ( defenders , 19 ) ;
87787: LD_ADDR_VAR 0 11
87791: PUSH
87792: LD_VAR 0 2
87796: PPUSH
87797: LD_INT 19
87799: PPUSH
87800: CALL 54273 0 2
87804: ST_TO_ADDR
// if tmp then
87805: LD_VAR 0 11
87809: IFFALSE 87879
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
87811: LD_ADDR_VAR 0 11
87815: PUSH
87816: LD_VAR 0 11
87820: PPUSH
87821: LD_INT 25
87823: PUSH
87824: LD_INT 3
87826: PUSH
87827: EMPTY
87828: LIST
87829: LIST
87830: PPUSH
87831: CALL_OW 72
87835: ST_TO_ADDR
// if tmp then
87836: LD_VAR 0 11
87840: IFFALSE 87879
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
87842: LD_ADDR_EXP 173
87846: PUSH
87847: LD_EXP 173
87851: PPUSH
87852: LD_VAR 0 1
87856: PPUSH
87857: LD_EXP 173
87861: PUSH
87862: LD_VAR 0 1
87866: ARRAY
87867: PUSH
87868: LD_VAR 0 11
87872: UNION
87873: PPUSH
87874: CALL_OW 1
87878: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
87879: LD_VAR 0 1
87883: PPUSH
87884: LD_INT 19
87886: PPUSH
87887: CALL 92353 0 2
// repeat wait ( 0 0$1 ) ;
87891: LD_INT 35
87893: PPUSH
87894: CALL_OW 67
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
87898: LD_EXP 161
87902: PUSH
87903: LD_VAR 0 1
87907: ARRAY
87908: NOT
87909: PUSH
87910: LD_EXP 161
87914: PUSH
87915: LD_VAR 0 1
87919: ARRAY
87920: PUSH
87921: EMPTY
87922: EQUAL
87923: OR
87924: IFFALSE 87961
// begin for i in defenders do
87926: LD_ADDR_VAR 0 4
87930: PUSH
87931: LD_VAR 0 2
87935: PUSH
87936: FOR_IN
87937: IFFALSE 87950
// ComStop ( i ) ;
87939: LD_VAR 0 4
87943: PPUSH
87944: CALL_OW 141
87948: GO 87936
87950: POP
87951: POP
// defenders := [ ] ;
87952: LD_ADDR_VAR 0 2
87956: PUSH
87957: EMPTY
87958: ST_TO_ADDR
// exit ;
87959: GO 88187
// end ; for i in defenders do
87961: LD_ADDR_VAR 0 4
87965: PUSH
87966: LD_VAR 0 2
87970: PUSH
87971: FOR_IN
87972: IFFALSE 88061
// begin if not IsInArea ( i , mc_parking [ base ] ) then
87974: LD_VAR 0 4
87978: PPUSH
87979: LD_EXP 185
87983: PUSH
87984: LD_VAR 0 1
87988: ARRAY
87989: PPUSH
87990: CALL_OW 308
87994: NOT
87995: IFFALSE 88019
// ComMoveToArea ( i , mc_parking [ base ] ) else
87997: LD_VAR 0 4
88001: PPUSH
88002: LD_EXP 185
88006: PUSH
88007: LD_VAR 0 1
88011: ARRAY
88012: PPUSH
88013: CALL_OW 113
88017: GO 88059
// if GetControl ( i ) = control_manual then
88019: LD_VAR 0 4
88023: PPUSH
88024: CALL_OW 263
88028: PUSH
88029: LD_INT 1
88031: EQUAL
88032: IFFALSE 88059
// if IsDrivenBy ( i ) then
88034: LD_VAR 0 4
88038: PPUSH
88039: CALL_OW 311
88043: IFFALSE 88059
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
88045: LD_VAR 0 4
88049: PPUSH
88050: CALL_OW 311
88054: PPUSH
88055: CALL_OW 121
// end ;
88059: GO 87971
88061: POP
88062: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] or not mc_bases [ base ] ;
88063: LD_VAR 0 2
88067: PPUSH
88068: LD_INT 95
88070: PUSH
88071: LD_EXP 185
88075: PUSH
88076: LD_VAR 0 1
88080: ARRAY
88081: PUSH
88082: EMPTY
88083: LIST
88084: LIST
88085: PPUSH
88086: CALL_OW 72
88090: PUSH
88091: LD_VAR 0 2
88095: EQUAL
88096: PUSH
88097: LD_EXP 184
88101: PUSH
88102: LD_VAR 0 1
88106: ARRAY
88107: OR
88108: PUSH
88109: LD_EXP 161
88113: PUSH
88114: LD_VAR 0 1
88118: ARRAY
88119: NOT
88120: OR
88121: IFFALSE 87891
// end ; mc_defender := Replace ( mc_defender , base , UnitFilter ( defenders , [ f_type , unit_vehicle ] ) ) ;
88123: LD_ADDR_EXP 183
88127: PUSH
88128: LD_EXP 183
88132: PPUSH
88133: LD_VAR 0 1
88137: PPUSH
88138: LD_VAR 0 2
88142: PPUSH
88143: LD_INT 21
88145: PUSH
88146: LD_INT 2
88148: PUSH
88149: EMPTY
88150: LIST
88151: LIST
88152: PPUSH
88153: CALL_OW 72
88157: PPUSH
88158: CALL_OW 1
88162: ST_TO_ADDR
// MC_Reset ( base , 19 ) ;
88163: LD_VAR 0 1
88167: PPUSH
88168: LD_INT 19
88170: PPUSH
88171: CALL 92353 0 2
// MC_Reset ( base , 20 ) ;
88175: LD_VAR 0 1
88179: PPUSH
88180: LD_INT 20
88182: PPUSH
88183: CALL 92353 0 2
// end ; end_of_file
88187: LD_VAR 0 3
88191: RET
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use , mc_is_defending ; export function InitMacro ; var i ; begin
88192: LD_INT 0
88194: PPUSH
88195: PPUSH
// skirmish := false ;
88196: LD_ADDR_EXP 159
88200: PUSH
88201: LD_INT 0
88203: ST_TO_ADDR
// debug_mc := false ;
88204: LD_ADDR_EXP 160
88208: PUSH
88209: LD_INT 0
88211: ST_TO_ADDR
// mc_bases := [ ] ;
88212: LD_ADDR_EXP 161
88216: PUSH
88217: EMPTY
88218: ST_TO_ADDR
// mc_sides := [ ] ;
88219: LD_ADDR_EXP 187
88223: PUSH
88224: EMPTY
88225: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
88226: LD_ADDR_EXP 162
88230: PUSH
88231: EMPTY
88232: ST_TO_ADDR
// mc_building_repairs := [ ] ;
88233: LD_ADDR_EXP 163
88237: PUSH
88238: EMPTY
88239: ST_TO_ADDR
// mc_need_heal := [ ] ;
88240: LD_ADDR_EXP 164
88244: PUSH
88245: EMPTY
88246: ST_TO_ADDR
// mc_healers := [ ] ;
88247: LD_ADDR_EXP 165
88251: PUSH
88252: EMPTY
88253: ST_TO_ADDR
// mc_build_list := [ ] ;
88254: LD_ADDR_EXP 166
88258: PUSH
88259: EMPTY
88260: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
88261: LD_ADDR_EXP 193
88265: PUSH
88266: EMPTY
88267: ST_TO_ADDR
// mc_builders := [ ] ;
88268: LD_ADDR_EXP 167
88272: PUSH
88273: EMPTY
88274: ST_TO_ADDR
// mc_construct_list := [ ] ;
88275: LD_ADDR_EXP 168
88279: PUSH
88280: EMPTY
88281: ST_TO_ADDR
// mc_turret_list := [ ] ;
88282: LD_ADDR_EXP 169
88286: PUSH
88287: EMPTY
88288: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
88289: LD_ADDR_EXP 170
88293: PUSH
88294: EMPTY
88295: ST_TO_ADDR
// mc_miners := [ ] ;
88296: LD_ADDR_EXP 175
88300: PUSH
88301: EMPTY
88302: ST_TO_ADDR
// mc_mines := [ ] ;
88303: LD_ADDR_EXP 174
88307: PUSH
88308: EMPTY
88309: ST_TO_ADDR
// mc_minefields := [ ] ;
88310: LD_ADDR_EXP 176
88314: PUSH
88315: EMPTY
88316: ST_TO_ADDR
// mc_crates := [ ] ;
88317: LD_ADDR_EXP 177
88321: PUSH
88322: EMPTY
88323: ST_TO_ADDR
// mc_crates_collector := [ ] ;
88324: LD_ADDR_EXP 178
88328: PUSH
88329: EMPTY
88330: ST_TO_ADDR
// mc_crates_area := [ ] ;
88331: LD_ADDR_EXP 179
88335: PUSH
88336: EMPTY
88337: ST_TO_ADDR
// mc_vehicles := [ ] ;
88338: LD_ADDR_EXP 180
88342: PUSH
88343: EMPTY
88344: ST_TO_ADDR
// mc_attack := [ ] ;
88345: LD_ADDR_EXP 181
88349: PUSH
88350: EMPTY
88351: ST_TO_ADDR
// mc_produce := [ ] ;
88352: LD_ADDR_EXP 182
88356: PUSH
88357: EMPTY
88358: ST_TO_ADDR
// mc_defender := [ ] ;
88359: LD_ADDR_EXP 183
88363: PUSH
88364: EMPTY
88365: ST_TO_ADDR
// mc_parking := [ ] ;
88366: LD_ADDR_EXP 185
88370: PUSH
88371: EMPTY
88372: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
88373: LD_ADDR_EXP 171
88377: PUSH
88378: EMPTY
88379: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
88380: LD_ADDR_EXP 173
88384: PUSH
88385: EMPTY
88386: ST_TO_ADDR
// mc_scan := [ ] ;
88387: LD_ADDR_EXP 184
88391: PUSH
88392: EMPTY
88393: ST_TO_ADDR
// mc_scan_area := [ ] ;
88394: LD_ADDR_EXP 186
88398: PUSH
88399: EMPTY
88400: ST_TO_ADDR
// mc_tech := [ ] ;
88401: LD_ADDR_EXP 188
88405: PUSH
88406: EMPTY
88407: ST_TO_ADDR
// mc_class := [ ] ;
88408: LD_ADDR_EXP 202
88412: PUSH
88413: EMPTY
88414: ST_TO_ADDR
// mc_class_case_use := [ ] ;
88415: LD_ADDR_EXP 203
88419: PUSH
88420: EMPTY
88421: ST_TO_ADDR
// mc_is_defending := [ ] ;
88422: LD_ADDR_EXP 204
88426: PUSH
88427: EMPTY
88428: ST_TO_ADDR
// mc_lab_upgrade := [ ] ;
88429: LD_ADDR_EXP 195
88433: PUSH
88434: EMPTY
88435: ST_TO_ADDR
// end ;
88436: LD_VAR 0 1
88440: RET
// export function MC_Kill ( base ) ; begin
88441: LD_INT 0
88443: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
88444: LD_ADDR_EXP 161
88448: PUSH
88449: LD_EXP 161
88453: PPUSH
88454: LD_VAR 0 1
88458: PPUSH
88459: EMPTY
88460: PPUSH
88461: CALL_OW 1
88465: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
88466: LD_ADDR_EXP 162
88470: PUSH
88471: LD_EXP 162
88475: PPUSH
88476: LD_VAR 0 1
88480: PPUSH
88481: EMPTY
88482: PPUSH
88483: CALL_OW 1
88487: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
88488: LD_ADDR_EXP 163
88492: PUSH
88493: LD_EXP 163
88497: PPUSH
88498: LD_VAR 0 1
88502: PPUSH
88503: EMPTY
88504: PPUSH
88505: CALL_OW 1
88509: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
88510: LD_ADDR_EXP 164
88514: PUSH
88515: LD_EXP 164
88519: PPUSH
88520: LD_VAR 0 1
88524: PPUSH
88525: EMPTY
88526: PPUSH
88527: CALL_OW 1
88531: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
88532: LD_ADDR_EXP 165
88536: PUSH
88537: LD_EXP 165
88541: PPUSH
88542: LD_VAR 0 1
88546: PPUSH
88547: EMPTY
88548: PPUSH
88549: CALL_OW 1
88553: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
88554: LD_ADDR_EXP 166
88558: PUSH
88559: LD_EXP 166
88563: PPUSH
88564: LD_VAR 0 1
88568: PPUSH
88569: EMPTY
88570: PPUSH
88571: CALL_OW 1
88575: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
88576: LD_ADDR_EXP 167
88580: PUSH
88581: LD_EXP 167
88585: PPUSH
88586: LD_VAR 0 1
88590: PPUSH
88591: EMPTY
88592: PPUSH
88593: CALL_OW 1
88597: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
88598: LD_ADDR_EXP 168
88602: PUSH
88603: LD_EXP 168
88607: PPUSH
88608: LD_VAR 0 1
88612: PPUSH
88613: EMPTY
88614: PPUSH
88615: CALL_OW 1
88619: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
88620: LD_ADDR_EXP 169
88624: PUSH
88625: LD_EXP 169
88629: PPUSH
88630: LD_VAR 0 1
88634: PPUSH
88635: EMPTY
88636: PPUSH
88637: CALL_OW 1
88641: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
88642: LD_ADDR_EXP 170
88646: PUSH
88647: LD_EXP 170
88651: PPUSH
88652: LD_VAR 0 1
88656: PPUSH
88657: EMPTY
88658: PPUSH
88659: CALL_OW 1
88663: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
88664: LD_ADDR_EXP 171
88668: PUSH
88669: LD_EXP 171
88673: PPUSH
88674: LD_VAR 0 1
88678: PPUSH
88679: EMPTY
88680: PPUSH
88681: CALL_OW 1
88685: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
88686: LD_ADDR_EXP 172
88690: PUSH
88691: LD_EXP 172
88695: PPUSH
88696: LD_VAR 0 1
88700: PPUSH
88701: LD_INT 0
88703: PPUSH
88704: CALL_OW 1
88708: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
88709: LD_ADDR_EXP 173
88713: PUSH
88714: LD_EXP 173
88718: PPUSH
88719: LD_VAR 0 1
88723: PPUSH
88724: EMPTY
88725: PPUSH
88726: CALL_OW 1
88730: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
88731: LD_ADDR_EXP 174
88735: PUSH
88736: LD_EXP 174
88740: PPUSH
88741: LD_VAR 0 1
88745: PPUSH
88746: EMPTY
88747: PPUSH
88748: CALL_OW 1
88752: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
88753: LD_ADDR_EXP 175
88757: PUSH
88758: LD_EXP 175
88762: PPUSH
88763: LD_VAR 0 1
88767: PPUSH
88768: EMPTY
88769: PPUSH
88770: CALL_OW 1
88774: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
88775: LD_ADDR_EXP 176
88779: PUSH
88780: LD_EXP 176
88784: PPUSH
88785: LD_VAR 0 1
88789: PPUSH
88790: EMPTY
88791: PPUSH
88792: CALL_OW 1
88796: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
88797: LD_ADDR_EXP 177
88801: PUSH
88802: LD_EXP 177
88806: PPUSH
88807: LD_VAR 0 1
88811: PPUSH
88812: EMPTY
88813: PPUSH
88814: CALL_OW 1
88818: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
88819: LD_ADDR_EXP 178
88823: PUSH
88824: LD_EXP 178
88828: PPUSH
88829: LD_VAR 0 1
88833: PPUSH
88834: EMPTY
88835: PPUSH
88836: CALL_OW 1
88840: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
88841: LD_ADDR_EXP 179
88845: PUSH
88846: LD_EXP 179
88850: PPUSH
88851: LD_VAR 0 1
88855: PPUSH
88856: EMPTY
88857: PPUSH
88858: CALL_OW 1
88862: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
88863: LD_ADDR_EXP 180
88867: PUSH
88868: LD_EXP 180
88872: PPUSH
88873: LD_VAR 0 1
88877: PPUSH
88878: EMPTY
88879: PPUSH
88880: CALL_OW 1
88884: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
88885: LD_ADDR_EXP 181
88889: PUSH
88890: LD_EXP 181
88894: PPUSH
88895: LD_VAR 0 1
88899: PPUSH
88900: EMPTY
88901: PPUSH
88902: CALL_OW 1
88906: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
88907: LD_ADDR_EXP 182
88911: PUSH
88912: LD_EXP 182
88916: PPUSH
88917: LD_VAR 0 1
88921: PPUSH
88922: EMPTY
88923: PPUSH
88924: CALL_OW 1
88928: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
88929: LD_ADDR_EXP 183
88933: PUSH
88934: LD_EXP 183
88938: PPUSH
88939: LD_VAR 0 1
88943: PPUSH
88944: EMPTY
88945: PPUSH
88946: CALL_OW 1
88950: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
88951: LD_ADDR_EXP 184
88955: PUSH
88956: LD_EXP 184
88960: PPUSH
88961: LD_VAR 0 1
88965: PPUSH
88966: EMPTY
88967: PPUSH
88968: CALL_OW 1
88972: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
88973: LD_ADDR_EXP 185
88977: PUSH
88978: LD_EXP 185
88982: PPUSH
88983: LD_VAR 0 1
88987: PPUSH
88988: EMPTY
88989: PPUSH
88990: CALL_OW 1
88994: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
88995: LD_ADDR_EXP 186
88999: PUSH
89000: LD_EXP 186
89004: PPUSH
89005: LD_VAR 0 1
89009: PPUSH
89010: EMPTY
89011: PPUSH
89012: CALL_OW 1
89016: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
89017: LD_ADDR_EXP 188
89021: PUSH
89022: LD_EXP 188
89026: PPUSH
89027: LD_VAR 0 1
89031: PPUSH
89032: EMPTY
89033: PPUSH
89034: CALL_OW 1
89038: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
89039: LD_ADDR_EXP 190
89043: PUSH
89044: LD_EXP 190
89048: PPUSH
89049: LD_VAR 0 1
89053: PPUSH
89054: EMPTY
89055: PPUSH
89056: CALL_OW 1
89060: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
89061: LD_ADDR_EXP 191
89065: PUSH
89066: LD_EXP 191
89070: PPUSH
89071: LD_VAR 0 1
89075: PPUSH
89076: EMPTY
89077: PPUSH
89078: CALL_OW 1
89082: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
89083: LD_ADDR_EXP 192
89087: PUSH
89088: LD_EXP 192
89092: PPUSH
89093: LD_VAR 0 1
89097: PPUSH
89098: EMPTY
89099: PPUSH
89100: CALL_OW 1
89104: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
89105: LD_ADDR_EXP 193
89109: PUSH
89110: LD_EXP 193
89114: PPUSH
89115: LD_VAR 0 1
89119: PPUSH
89120: EMPTY
89121: PPUSH
89122: CALL_OW 1
89126: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
89127: LD_ADDR_EXP 194
89131: PUSH
89132: LD_EXP 194
89136: PPUSH
89137: LD_VAR 0 1
89141: PPUSH
89142: EMPTY
89143: PPUSH
89144: CALL_OW 1
89148: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
89149: LD_ADDR_EXP 195
89153: PUSH
89154: LD_EXP 195
89158: PPUSH
89159: LD_VAR 0 1
89163: PPUSH
89164: EMPTY
89165: PPUSH
89166: CALL_OW 1
89170: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
89171: LD_ADDR_EXP 196
89175: PUSH
89176: LD_EXP 196
89180: PPUSH
89181: LD_VAR 0 1
89185: PPUSH
89186: EMPTY
89187: PPUSH
89188: CALL_OW 1
89192: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
89193: LD_ADDR_EXP 197
89197: PUSH
89198: LD_EXP 197
89202: PPUSH
89203: LD_VAR 0 1
89207: PPUSH
89208: EMPTY
89209: PPUSH
89210: CALL_OW 1
89214: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
89215: LD_ADDR_EXP 198
89219: PUSH
89220: LD_EXP 198
89224: PPUSH
89225: LD_VAR 0 1
89229: PPUSH
89230: EMPTY
89231: PPUSH
89232: CALL_OW 1
89236: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
89237: LD_ADDR_EXP 199
89241: PUSH
89242: LD_EXP 199
89246: PPUSH
89247: LD_VAR 0 1
89251: PPUSH
89252: EMPTY
89253: PPUSH
89254: CALL_OW 1
89258: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
89259: LD_ADDR_EXP 200
89263: PUSH
89264: LD_EXP 200
89268: PPUSH
89269: LD_VAR 0 1
89273: PPUSH
89274: EMPTY
89275: PPUSH
89276: CALL_OW 1
89280: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
89281: LD_ADDR_EXP 201
89285: PUSH
89286: LD_EXP 201
89290: PPUSH
89291: LD_VAR 0 1
89295: PPUSH
89296: EMPTY
89297: PPUSH
89298: CALL_OW 1
89302: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
89303: LD_ADDR_EXP 202
89307: PUSH
89308: LD_EXP 202
89312: PPUSH
89313: LD_VAR 0 1
89317: PPUSH
89318: EMPTY
89319: PPUSH
89320: CALL_OW 1
89324: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
89325: LD_ADDR_EXP 203
89329: PUSH
89330: LD_EXP 203
89334: PPUSH
89335: LD_VAR 0 1
89339: PPUSH
89340: LD_INT 0
89342: PPUSH
89343: CALL_OW 1
89347: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
89348: LD_ADDR_EXP 204
89352: PUSH
89353: LD_EXP 204
89357: PPUSH
89358: LD_VAR 0 1
89362: PPUSH
89363: LD_INT 0
89365: PPUSH
89366: CALL_OW 1
89370: ST_TO_ADDR
// end ;
89371: LD_VAR 0 2
89375: RET
// export function MC_Add ( side , units ) ; var base ; begin
89376: LD_INT 0
89378: PPUSH
89379: PPUSH
// base := mc_bases + 1 ;
89380: LD_ADDR_VAR 0 4
89384: PUSH
89385: LD_EXP 161
89389: PUSH
89390: LD_INT 1
89392: PLUS
89393: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
89394: LD_ADDR_EXP 187
89398: PUSH
89399: LD_EXP 187
89403: PPUSH
89404: LD_VAR 0 4
89408: PPUSH
89409: LD_VAR 0 1
89413: PPUSH
89414: CALL_OW 1
89418: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
89419: LD_ADDR_EXP 161
89423: PUSH
89424: LD_EXP 161
89428: PPUSH
89429: LD_VAR 0 4
89433: PPUSH
89434: LD_VAR 0 2
89438: PPUSH
89439: CALL_OW 1
89443: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
89444: LD_ADDR_EXP 162
89448: PUSH
89449: LD_EXP 162
89453: PPUSH
89454: LD_VAR 0 4
89458: PPUSH
89459: EMPTY
89460: PPUSH
89461: CALL_OW 1
89465: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
89466: LD_ADDR_EXP 163
89470: PUSH
89471: LD_EXP 163
89475: PPUSH
89476: LD_VAR 0 4
89480: PPUSH
89481: EMPTY
89482: PPUSH
89483: CALL_OW 1
89487: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
89488: LD_ADDR_EXP 164
89492: PUSH
89493: LD_EXP 164
89497: PPUSH
89498: LD_VAR 0 4
89502: PPUSH
89503: EMPTY
89504: PPUSH
89505: CALL_OW 1
89509: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
89510: LD_ADDR_EXP 165
89514: PUSH
89515: LD_EXP 165
89519: PPUSH
89520: LD_VAR 0 4
89524: PPUSH
89525: EMPTY
89526: PPUSH
89527: CALL_OW 1
89531: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
89532: LD_ADDR_EXP 166
89536: PUSH
89537: LD_EXP 166
89541: PPUSH
89542: LD_VAR 0 4
89546: PPUSH
89547: EMPTY
89548: PPUSH
89549: CALL_OW 1
89553: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
89554: LD_ADDR_EXP 167
89558: PUSH
89559: LD_EXP 167
89563: PPUSH
89564: LD_VAR 0 4
89568: PPUSH
89569: EMPTY
89570: PPUSH
89571: CALL_OW 1
89575: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
89576: LD_ADDR_EXP 168
89580: PUSH
89581: LD_EXP 168
89585: PPUSH
89586: LD_VAR 0 4
89590: PPUSH
89591: EMPTY
89592: PPUSH
89593: CALL_OW 1
89597: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
89598: LD_ADDR_EXP 169
89602: PUSH
89603: LD_EXP 169
89607: PPUSH
89608: LD_VAR 0 4
89612: PPUSH
89613: EMPTY
89614: PPUSH
89615: CALL_OW 1
89619: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
89620: LD_ADDR_EXP 170
89624: PUSH
89625: LD_EXP 170
89629: PPUSH
89630: LD_VAR 0 4
89634: PPUSH
89635: EMPTY
89636: PPUSH
89637: CALL_OW 1
89641: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
89642: LD_ADDR_EXP 171
89646: PUSH
89647: LD_EXP 171
89651: PPUSH
89652: LD_VAR 0 4
89656: PPUSH
89657: EMPTY
89658: PPUSH
89659: CALL_OW 1
89663: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
89664: LD_ADDR_EXP 172
89668: PUSH
89669: LD_EXP 172
89673: PPUSH
89674: LD_VAR 0 4
89678: PPUSH
89679: LD_INT 0
89681: PPUSH
89682: CALL_OW 1
89686: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
89687: LD_ADDR_EXP 173
89691: PUSH
89692: LD_EXP 173
89696: PPUSH
89697: LD_VAR 0 4
89701: PPUSH
89702: EMPTY
89703: PPUSH
89704: CALL_OW 1
89708: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
89709: LD_ADDR_EXP 174
89713: PUSH
89714: LD_EXP 174
89718: PPUSH
89719: LD_VAR 0 4
89723: PPUSH
89724: EMPTY
89725: PPUSH
89726: CALL_OW 1
89730: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
89731: LD_ADDR_EXP 175
89735: PUSH
89736: LD_EXP 175
89740: PPUSH
89741: LD_VAR 0 4
89745: PPUSH
89746: EMPTY
89747: PPUSH
89748: CALL_OW 1
89752: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
89753: LD_ADDR_EXP 176
89757: PUSH
89758: LD_EXP 176
89762: PPUSH
89763: LD_VAR 0 4
89767: PPUSH
89768: EMPTY
89769: PPUSH
89770: CALL_OW 1
89774: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
89775: LD_ADDR_EXP 177
89779: PUSH
89780: LD_EXP 177
89784: PPUSH
89785: LD_VAR 0 4
89789: PPUSH
89790: EMPTY
89791: PPUSH
89792: CALL_OW 1
89796: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
89797: LD_ADDR_EXP 178
89801: PUSH
89802: LD_EXP 178
89806: PPUSH
89807: LD_VAR 0 4
89811: PPUSH
89812: EMPTY
89813: PPUSH
89814: CALL_OW 1
89818: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
89819: LD_ADDR_EXP 179
89823: PUSH
89824: LD_EXP 179
89828: PPUSH
89829: LD_VAR 0 4
89833: PPUSH
89834: EMPTY
89835: PPUSH
89836: CALL_OW 1
89840: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
89841: LD_ADDR_EXP 180
89845: PUSH
89846: LD_EXP 180
89850: PPUSH
89851: LD_VAR 0 4
89855: PPUSH
89856: EMPTY
89857: PPUSH
89858: CALL_OW 1
89862: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
89863: LD_ADDR_EXP 181
89867: PUSH
89868: LD_EXP 181
89872: PPUSH
89873: LD_VAR 0 4
89877: PPUSH
89878: EMPTY
89879: PPUSH
89880: CALL_OW 1
89884: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
89885: LD_ADDR_EXP 182
89889: PUSH
89890: LD_EXP 182
89894: PPUSH
89895: LD_VAR 0 4
89899: PPUSH
89900: EMPTY
89901: PPUSH
89902: CALL_OW 1
89906: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
89907: LD_ADDR_EXP 183
89911: PUSH
89912: LD_EXP 183
89916: PPUSH
89917: LD_VAR 0 4
89921: PPUSH
89922: EMPTY
89923: PPUSH
89924: CALL_OW 1
89928: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
89929: LD_ADDR_EXP 184
89933: PUSH
89934: LD_EXP 184
89938: PPUSH
89939: LD_VAR 0 4
89943: PPUSH
89944: EMPTY
89945: PPUSH
89946: CALL_OW 1
89950: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
89951: LD_ADDR_EXP 185
89955: PUSH
89956: LD_EXP 185
89960: PPUSH
89961: LD_VAR 0 4
89965: PPUSH
89966: EMPTY
89967: PPUSH
89968: CALL_OW 1
89972: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
89973: LD_ADDR_EXP 186
89977: PUSH
89978: LD_EXP 186
89982: PPUSH
89983: LD_VAR 0 4
89987: PPUSH
89988: EMPTY
89989: PPUSH
89990: CALL_OW 1
89994: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
89995: LD_ADDR_EXP 188
89999: PUSH
90000: LD_EXP 188
90004: PPUSH
90005: LD_VAR 0 4
90009: PPUSH
90010: EMPTY
90011: PPUSH
90012: CALL_OW 1
90016: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
90017: LD_ADDR_EXP 190
90021: PUSH
90022: LD_EXP 190
90026: PPUSH
90027: LD_VAR 0 4
90031: PPUSH
90032: EMPTY
90033: PPUSH
90034: CALL_OW 1
90038: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
90039: LD_ADDR_EXP 191
90043: PUSH
90044: LD_EXP 191
90048: PPUSH
90049: LD_VAR 0 4
90053: PPUSH
90054: EMPTY
90055: PPUSH
90056: CALL_OW 1
90060: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
90061: LD_ADDR_EXP 192
90065: PUSH
90066: LD_EXP 192
90070: PPUSH
90071: LD_VAR 0 4
90075: PPUSH
90076: EMPTY
90077: PPUSH
90078: CALL_OW 1
90082: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
90083: LD_ADDR_EXP 193
90087: PUSH
90088: LD_EXP 193
90092: PPUSH
90093: LD_VAR 0 4
90097: PPUSH
90098: EMPTY
90099: PPUSH
90100: CALL_OW 1
90104: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
90105: LD_ADDR_EXP 194
90109: PUSH
90110: LD_EXP 194
90114: PPUSH
90115: LD_VAR 0 4
90119: PPUSH
90120: EMPTY
90121: PPUSH
90122: CALL_OW 1
90126: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
90127: LD_ADDR_EXP 195
90131: PUSH
90132: LD_EXP 195
90136: PPUSH
90137: LD_VAR 0 4
90141: PPUSH
90142: EMPTY
90143: PPUSH
90144: CALL_OW 1
90148: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
90149: LD_ADDR_EXP 196
90153: PUSH
90154: LD_EXP 196
90158: PPUSH
90159: LD_VAR 0 4
90163: PPUSH
90164: EMPTY
90165: PPUSH
90166: CALL_OW 1
90170: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
90171: LD_ADDR_EXP 197
90175: PUSH
90176: LD_EXP 197
90180: PPUSH
90181: LD_VAR 0 4
90185: PPUSH
90186: EMPTY
90187: PPUSH
90188: CALL_OW 1
90192: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
90193: LD_ADDR_EXP 198
90197: PUSH
90198: LD_EXP 198
90202: PPUSH
90203: LD_VAR 0 4
90207: PPUSH
90208: EMPTY
90209: PPUSH
90210: CALL_OW 1
90214: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
90215: LD_ADDR_EXP 199
90219: PUSH
90220: LD_EXP 199
90224: PPUSH
90225: LD_VAR 0 4
90229: PPUSH
90230: EMPTY
90231: PPUSH
90232: CALL_OW 1
90236: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
90237: LD_ADDR_EXP 200
90241: PUSH
90242: LD_EXP 200
90246: PPUSH
90247: LD_VAR 0 4
90251: PPUSH
90252: EMPTY
90253: PPUSH
90254: CALL_OW 1
90258: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
90259: LD_ADDR_EXP 201
90263: PUSH
90264: LD_EXP 201
90268: PPUSH
90269: LD_VAR 0 4
90273: PPUSH
90274: EMPTY
90275: PPUSH
90276: CALL_OW 1
90280: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
90281: LD_ADDR_EXP 202
90285: PUSH
90286: LD_EXP 202
90290: PPUSH
90291: LD_VAR 0 4
90295: PPUSH
90296: EMPTY
90297: PPUSH
90298: CALL_OW 1
90302: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
90303: LD_ADDR_EXP 203
90307: PUSH
90308: LD_EXP 203
90312: PPUSH
90313: LD_VAR 0 4
90317: PPUSH
90318: LD_INT 0
90320: PPUSH
90321: CALL_OW 1
90325: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
90326: LD_ADDR_EXP 204
90330: PUSH
90331: LD_EXP 204
90335: PPUSH
90336: LD_VAR 0 4
90340: PPUSH
90341: LD_INT 0
90343: PPUSH
90344: CALL_OW 1
90348: ST_TO_ADDR
// result := base ;
90349: LD_ADDR_VAR 0 3
90353: PUSH
90354: LD_VAR 0 4
90358: ST_TO_ADDR
// end ;
90359: LD_VAR 0 3
90363: RET
// export function MC_Start ( ) ; var i ; begin
90364: LD_INT 0
90366: PPUSH
90367: PPUSH
// for i = 1 to mc_bases do
90368: LD_ADDR_VAR 0 2
90372: PUSH
90373: DOUBLE
90374: LD_INT 1
90376: DEC
90377: ST_TO_ADDR
90378: LD_EXP 161
90382: PUSH
90383: FOR_TO
90384: IFFALSE 91484
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
90386: LD_ADDR_EXP 161
90390: PUSH
90391: LD_EXP 161
90395: PPUSH
90396: LD_VAR 0 2
90400: PPUSH
90401: LD_EXP 161
90405: PUSH
90406: LD_VAR 0 2
90410: ARRAY
90411: PUSH
90412: LD_INT 0
90414: DIFF
90415: PPUSH
90416: CALL_OW 1
90420: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
90421: LD_ADDR_EXP 162
90425: PUSH
90426: LD_EXP 162
90430: PPUSH
90431: LD_VAR 0 2
90435: PPUSH
90436: EMPTY
90437: PPUSH
90438: CALL_OW 1
90442: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
90443: LD_ADDR_EXP 163
90447: PUSH
90448: LD_EXP 163
90452: PPUSH
90453: LD_VAR 0 2
90457: PPUSH
90458: EMPTY
90459: PPUSH
90460: CALL_OW 1
90464: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
90465: LD_ADDR_EXP 164
90469: PUSH
90470: LD_EXP 164
90474: PPUSH
90475: LD_VAR 0 2
90479: PPUSH
90480: EMPTY
90481: PPUSH
90482: CALL_OW 1
90486: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
90487: LD_ADDR_EXP 165
90491: PUSH
90492: LD_EXP 165
90496: PPUSH
90497: LD_VAR 0 2
90501: PPUSH
90502: EMPTY
90503: PUSH
90504: EMPTY
90505: PUSH
90506: EMPTY
90507: LIST
90508: LIST
90509: PPUSH
90510: CALL_OW 1
90514: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
90515: LD_ADDR_EXP 166
90519: PUSH
90520: LD_EXP 166
90524: PPUSH
90525: LD_VAR 0 2
90529: PPUSH
90530: EMPTY
90531: PPUSH
90532: CALL_OW 1
90536: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
90537: LD_ADDR_EXP 193
90541: PUSH
90542: LD_EXP 193
90546: PPUSH
90547: LD_VAR 0 2
90551: PPUSH
90552: EMPTY
90553: PPUSH
90554: CALL_OW 1
90558: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
90559: LD_ADDR_EXP 167
90563: PUSH
90564: LD_EXP 167
90568: PPUSH
90569: LD_VAR 0 2
90573: PPUSH
90574: EMPTY
90575: PPUSH
90576: CALL_OW 1
90580: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
90581: LD_ADDR_EXP 168
90585: PUSH
90586: LD_EXP 168
90590: PPUSH
90591: LD_VAR 0 2
90595: PPUSH
90596: EMPTY
90597: PPUSH
90598: CALL_OW 1
90602: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
90603: LD_ADDR_EXP 169
90607: PUSH
90608: LD_EXP 169
90612: PPUSH
90613: LD_VAR 0 2
90617: PPUSH
90618: LD_EXP 161
90622: PUSH
90623: LD_VAR 0 2
90627: ARRAY
90628: PPUSH
90629: LD_INT 2
90631: PUSH
90632: LD_INT 30
90634: PUSH
90635: LD_INT 32
90637: PUSH
90638: EMPTY
90639: LIST
90640: LIST
90641: PUSH
90642: LD_INT 30
90644: PUSH
90645: LD_INT 33
90647: PUSH
90648: EMPTY
90649: LIST
90650: LIST
90651: PUSH
90652: EMPTY
90653: LIST
90654: LIST
90655: LIST
90656: PPUSH
90657: CALL_OW 72
90661: PPUSH
90662: CALL_OW 1
90666: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
90667: LD_ADDR_EXP 170
90671: PUSH
90672: LD_EXP 170
90676: PPUSH
90677: LD_VAR 0 2
90681: PPUSH
90682: LD_EXP 161
90686: PUSH
90687: LD_VAR 0 2
90691: ARRAY
90692: PPUSH
90693: LD_INT 2
90695: PUSH
90696: LD_INT 30
90698: PUSH
90699: LD_INT 32
90701: PUSH
90702: EMPTY
90703: LIST
90704: LIST
90705: PUSH
90706: LD_INT 30
90708: PUSH
90709: LD_INT 31
90711: PUSH
90712: EMPTY
90713: LIST
90714: LIST
90715: PUSH
90716: EMPTY
90717: LIST
90718: LIST
90719: LIST
90720: PUSH
90721: LD_INT 58
90723: PUSH
90724: EMPTY
90725: LIST
90726: PUSH
90727: EMPTY
90728: LIST
90729: LIST
90730: PPUSH
90731: CALL_OW 72
90735: PPUSH
90736: CALL_OW 1
90740: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
90741: LD_ADDR_EXP 171
90745: PUSH
90746: LD_EXP 171
90750: PPUSH
90751: LD_VAR 0 2
90755: PPUSH
90756: EMPTY
90757: PPUSH
90758: CALL_OW 1
90762: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
90763: LD_ADDR_EXP 175
90767: PUSH
90768: LD_EXP 175
90772: PPUSH
90773: LD_VAR 0 2
90777: PPUSH
90778: EMPTY
90779: PPUSH
90780: CALL_OW 1
90784: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
90785: LD_ADDR_EXP 174
90789: PUSH
90790: LD_EXP 174
90794: PPUSH
90795: LD_VAR 0 2
90799: PPUSH
90800: EMPTY
90801: PPUSH
90802: CALL_OW 1
90806: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
90807: LD_ADDR_EXP 176
90811: PUSH
90812: LD_EXP 176
90816: PPUSH
90817: LD_VAR 0 2
90821: PPUSH
90822: EMPTY
90823: PPUSH
90824: CALL_OW 1
90828: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
90829: LD_ADDR_EXP 177
90833: PUSH
90834: LD_EXP 177
90838: PPUSH
90839: LD_VAR 0 2
90843: PPUSH
90844: EMPTY
90845: PPUSH
90846: CALL_OW 1
90850: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
90851: LD_ADDR_EXP 178
90855: PUSH
90856: LD_EXP 178
90860: PPUSH
90861: LD_VAR 0 2
90865: PPUSH
90866: EMPTY
90867: PPUSH
90868: CALL_OW 1
90872: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
90873: LD_ADDR_EXP 179
90877: PUSH
90878: LD_EXP 179
90882: PPUSH
90883: LD_VAR 0 2
90887: PPUSH
90888: EMPTY
90889: PPUSH
90890: CALL_OW 1
90894: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
90895: LD_ADDR_EXP 180
90899: PUSH
90900: LD_EXP 180
90904: PPUSH
90905: LD_VAR 0 2
90909: PPUSH
90910: EMPTY
90911: PPUSH
90912: CALL_OW 1
90916: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
90917: LD_ADDR_EXP 181
90921: PUSH
90922: LD_EXP 181
90926: PPUSH
90927: LD_VAR 0 2
90931: PPUSH
90932: EMPTY
90933: PPUSH
90934: CALL_OW 1
90938: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
90939: LD_ADDR_EXP 182
90943: PUSH
90944: LD_EXP 182
90948: PPUSH
90949: LD_VAR 0 2
90953: PPUSH
90954: EMPTY
90955: PPUSH
90956: CALL_OW 1
90960: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
90961: LD_ADDR_EXP 183
90965: PUSH
90966: LD_EXP 183
90970: PPUSH
90971: LD_VAR 0 2
90975: PPUSH
90976: EMPTY
90977: PPUSH
90978: CALL_OW 1
90982: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
90983: LD_ADDR_EXP 172
90987: PUSH
90988: LD_EXP 172
90992: PPUSH
90993: LD_VAR 0 2
90997: PPUSH
90998: LD_INT 0
91000: PPUSH
91001: CALL_OW 1
91005: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
91006: LD_ADDR_EXP 185
91010: PUSH
91011: LD_EXP 185
91015: PPUSH
91016: LD_VAR 0 2
91020: PPUSH
91021: LD_INT 0
91023: PPUSH
91024: CALL_OW 1
91028: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
91029: LD_ADDR_EXP 173
91033: PUSH
91034: LD_EXP 173
91038: PPUSH
91039: LD_VAR 0 2
91043: PPUSH
91044: EMPTY
91045: PPUSH
91046: CALL_OW 1
91050: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
91051: LD_ADDR_EXP 184
91055: PUSH
91056: LD_EXP 184
91060: PPUSH
91061: LD_VAR 0 2
91065: PPUSH
91066: LD_INT 0
91068: PPUSH
91069: CALL_OW 1
91073: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
91074: LD_ADDR_EXP 186
91078: PUSH
91079: LD_EXP 186
91083: PPUSH
91084: LD_VAR 0 2
91088: PPUSH
91089: EMPTY
91090: PPUSH
91091: CALL_OW 1
91095: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
91096: LD_ADDR_EXP 189
91100: PUSH
91101: LD_EXP 189
91105: PPUSH
91106: LD_VAR 0 2
91110: PPUSH
91111: LD_INT 0
91113: PPUSH
91114: CALL_OW 1
91118: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
91119: LD_ADDR_EXP 190
91123: PUSH
91124: LD_EXP 190
91128: PPUSH
91129: LD_VAR 0 2
91133: PPUSH
91134: EMPTY
91135: PPUSH
91136: CALL_OW 1
91140: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
91141: LD_ADDR_EXP 191
91145: PUSH
91146: LD_EXP 191
91150: PPUSH
91151: LD_VAR 0 2
91155: PPUSH
91156: EMPTY
91157: PPUSH
91158: CALL_OW 1
91162: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
91163: LD_ADDR_EXP 192
91167: PUSH
91168: LD_EXP 192
91172: PPUSH
91173: LD_VAR 0 2
91177: PPUSH
91178: EMPTY
91179: PPUSH
91180: CALL_OW 1
91184: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
91185: LD_ADDR_EXP 194
91189: PUSH
91190: LD_EXP 194
91194: PPUSH
91195: LD_VAR 0 2
91199: PPUSH
91200: LD_EXP 161
91204: PUSH
91205: LD_VAR 0 2
91209: ARRAY
91210: PPUSH
91211: LD_INT 2
91213: PUSH
91214: LD_INT 30
91216: PUSH
91217: LD_INT 6
91219: PUSH
91220: EMPTY
91221: LIST
91222: LIST
91223: PUSH
91224: LD_INT 30
91226: PUSH
91227: LD_INT 7
91229: PUSH
91230: EMPTY
91231: LIST
91232: LIST
91233: PUSH
91234: LD_INT 30
91236: PUSH
91237: LD_INT 8
91239: PUSH
91240: EMPTY
91241: LIST
91242: LIST
91243: PUSH
91244: EMPTY
91245: LIST
91246: LIST
91247: LIST
91248: LIST
91249: PPUSH
91250: CALL_OW 72
91254: PPUSH
91255: CALL_OW 1
91259: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
91260: LD_ADDR_EXP 195
91264: PUSH
91265: LD_EXP 195
91269: PPUSH
91270: LD_VAR 0 2
91274: PPUSH
91275: EMPTY
91276: PPUSH
91277: CALL_OW 1
91281: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
91282: LD_ADDR_EXP 196
91286: PUSH
91287: LD_EXP 196
91291: PPUSH
91292: LD_VAR 0 2
91296: PPUSH
91297: EMPTY
91298: PPUSH
91299: CALL_OW 1
91303: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
91304: LD_ADDR_EXP 197
91308: PUSH
91309: LD_EXP 197
91313: PPUSH
91314: LD_VAR 0 2
91318: PPUSH
91319: EMPTY
91320: PPUSH
91321: CALL_OW 1
91325: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
91326: LD_ADDR_EXP 198
91330: PUSH
91331: LD_EXP 198
91335: PPUSH
91336: LD_VAR 0 2
91340: PPUSH
91341: EMPTY
91342: PPUSH
91343: CALL_OW 1
91347: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
91348: LD_ADDR_EXP 199
91352: PUSH
91353: LD_EXP 199
91357: PPUSH
91358: LD_VAR 0 2
91362: PPUSH
91363: EMPTY
91364: PPUSH
91365: CALL_OW 1
91369: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
91370: LD_ADDR_EXP 200
91374: PUSH
91375: LD_EXP 200
91379: PPUSH
91380: LD_VAR 0 2
91384: PPUSH
91385: EMPTY
91386: PPUSH
91387: CALL_OW 1
91391: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
91392: LD_ADDR_EXP 201
91396: PUSH
91397: LD_EXP 201
91401: PPUSH
91402: LD_VAR 0 2
91406: PPUSH
91407: EMPTY
91408: PPUSH
91409: CALL_OW 1
91413: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
91414: LD_ADDR_EXP 202
91418: PUSH
91419: LD_EXP 202
91423: PPUSH
91424: LD_VAR 0 2
91428: PPUSH
91429: EMPTY
91430: PPUSH
91431: CALL_OW 1
91435: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
91436: LD_ADDR_EXP 203
91440: PUSH
91441: LD_EXP 203
91445: PPUSH
91446: LD_VAR 0 2
91450: PPUSH
91451: LD_INT 0
91453: PPUSH
91454: CALL_OW 1
91458: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , i , false ) ;
91459: LD_ADDR_EXP 204
91463: PUSH
91464: LD_EXP 204
91468: PPUSH
91469: LD_VAR 0 2
91473: PPUSH
91474: LD_INT 0
91476: PPUSH
91477: CALL_OW 1
91481: ST_TO_ADDR
// end ;
91482: GO 90383
91484: POP
91485: POP
// MC_InitSides ( ) ;
91486: CALL 91772 0 0
// MC_InitResearch ( ) ;
91490: CALL 91511 0 0
// CustomInitMacro ( ) ;
91494: CALL 350 0 0
// skirmish := true ;
91498: LD_ADDR_EXP 159
91502: PUSH
91503: LD_INT 1
91505: ST_TO_ADDR
// end ;
91506: LD_VAR 0 1
91510: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
91511: LD_INT 0
91513: PPUSH
91514: PPUSH
91515: PPUSH
91516: PPUSH
91517: PPUSH
91518: PPUSH
// if not mc_bases then
91519: LD_EXP 161
91523: NOT
91524: IFFALSE 91528
// exit ;
91526: GO 91767
// for i = 1 to 8 do
91528: LD_ADDR_VAR 0 2
91532: PUSH
91533: DOUBLE
91534: LD_INT 1
91536: DEC
91537: ST_TO_ADDR
91538: LD_INT 8
91540: PUSH
91541: FOR_TO
91542: IFFALSE 91568
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
91544: LD_ADDR_EXP 188
91548: PUSH
91549: LD_EXP 188
91553: PPUSH
91554: LD_VAR 0 2
91558: PPUSH
91559: EMPTY
91560: PPUSH
91561: CALL_OW 1
91565: ST_TO_ADDR
91566: GO 91541
91568: POP
91569: POP
// tmp := [ ] ;
91570: LD_ADDR_VAR 0 5
91574: PUSH
91575: EMPTY
91576: ST_TO_ADDR
// for i = 1 to mc_sides do
91577: LD_ADDR_VAR 0 2
91581: PUSH
91582: DOUBLE
91583: LD_INT 1
91585: DEC
91586: ST_TO_ADDR
91587: LD_EXP 187
91591: PUSH
91592: FOR_TO
91593: IFFALSE 91651
// if not mc_sides [ i ] in tmp then
91595: LD_EXP 187
91599: PUSH
91600: LD_VAR 0 2
91604: ARRAY
91605: PUSH
91606: LD_VAR 0 5
91610: IN
91611: NOT
91612: IFFALSE 91649
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
91614: LD_ADDR_VAR 0 5
91618: PUSH
91619: LD_VAR 0 5
91623: PPUSH
91624: LD_VAR 0 5
91628: PUSH
91629: LD_INT 1
91631: PLUS
91632: PPUSH
91633: LD_EXP 187
91637: PUSH
91638: LD_VAR 0 2
91642: ARRAY
91643: PPUSH
91644: CALL_OW 2
91648: ST_TO_ADDR
91649: GO 91592
91651: POP
91652: POP
// if not tmp then
91653: LD_VAR 0 5
91657: NOT
91658: IFFALSE 91662
// exit ;
91660: GO 91767
// for j in tmp do
91662: LD_ADDR_VAR 0 3
91666: PUSH
91667: LD_VAR 0 5
91671: PUSH
91672: FOR_IN
91673: IFFALSE 91765
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
91675: LD_ADDR_VAR 0 6
91679: PUSH
91680: LD_INT 22
91682: PUSH
91683: LD_VAR 0 3
91687: PUSH
91688: EMPTY
91689: LIST
91690: LIST
91691: PPUSH
91692: CALL_OW 69
91696: ST_TO_ADDR
// if not un then
91697: LD_VAR 0 6
91701: NOT
91702: IFFALSE 91706
// continue ;
91704: GO 91672
// nation := GetNation ( un [ 1 ] ) ;
91706: LD_ADDR_VAR 0 4
91710: PUSH
91711: LD_VAR 0 6
91715: PUSH
91716: LD_INT 1
91718: ARRAY
91719: PPUSH
91720: CALL_OW 248
91724: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
91725: LD_ADDR_EXP 188
91729: PUSH
91730: LD_EXP 188
91734: PPUSH
91735: LD_VAR 0 3
91739: PPUSH
91740: LD_VAR 0 3
91744: PPUSH
91745: LD_VAR 0 4
91749: PPUSH
91750: LD_INT 1
91752: PPUSH
91753: CALL 19287 0 3
91757: PPUSH
91758: CALL_OW 1
91762: ST_TO_ADDR
// end ;
91763: GO 91672
91765: POP
91766: POP
// end ;
91767: LD_VAR 0 1
91771: RET
// export function MC_InitSides ( ) ; var i ; begin
91772: LD_INT 0
91774: PPUSH
91775: PPUSH
// if not mc_bases then
91776: LD_EXP 161
91780: NOT
91781: IFFALSE 91785
// exit ;
91783: GO 91859
// for i = 1 to mc_bases do
91785: LD_ADDR_VAR 0 2
91789: PUSH
91790: DOUBLE
91791: LD_INT 1
91793: DEC
91794: ST_TO_ADDR
91795: LD_EXP 161
91799: PUSH
91800: FOR_TO
91801: IFFALSE 91857
// if mc_bases [ i ] then
91803: LD_EXP 161
91807: PUSH
91808: LD_VAR 0 2
91812: ARRAY
91813: IFFALSE 91855
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
91815: LD_ADDR_EXP 187
91819: PUSH
91820: LD_EXP 187
91824: PPUSH
91825: LD_VAR 0 2
91829: PPUSH
91830: LD_EXP 161
91834: PUSH
91835: LD_VAR 0 2
91839: ARRAY
91840: PUSH
91841: LD_INT 1
91843: ARRAY
91844: PPUSH
91845: CALL_OW 255
91849: PPUSH
91850: CALL_OW 1
91854: ST_TO_ADDR
91855: GO 91800
91857: POP
91858: POP
// end ;
91859: LD_VAR 0 1
91863: RET
// every 0 0$03 trigger skirmish do
91864: LD_EXP 159
91868: IFFALSE 92022
91870: GO 91872
91872: DISABLE
// begin enable ;
91873: ENABLE
// MC_CheckBuildings ( ) ;
91874: CALL 96520 0 0
// MC_CheckPeopleLife ( ) ;
91878: CALL 96681 0 0
// RaiseSailEvent ( 100 ) ;
91882: LD_INT 100
91884: PPUSH
91885: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
91889: LD_INT 103
91891: PPUSH
91892: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
91896: LD_INT 104
91898: PPUSH
91899: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
91903: LD_INT 105
91905: PPUSH
91906: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
91910: LD_INT 106
91912: PPUSH
91913: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
91917: LD_INT 107
91919: PPUSH
91920: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
91924: LD_INT 108
91926: PPUSH
91927: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
91931: LD_INT 109
91933: PPUSH
91934: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
91938: LD_INT 110
91940: PPUSH
91941: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
91945: LD_INT 111
91947: PPUSH
91948: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
91952: LD_INT 112
91954: PPUSH
91955: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
91959: LD_INT 113
91961: PPUSH
91962: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
91966: LD_INT 120
91968: PPUSH
91969: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
91973: LD_INT 121
91975: PPUSH
91976: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
91980: LD_INT 122
91982: PPUSH
91983: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
91987: LD_INT 123
91989: PPUSH
91990: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
91994: LD_INT 124
91996: PPUSH
91997: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
92001: LD_INT 125
92003: PPUSH
92004: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
92008: LD_INT 126
92010: PPUSH
92011: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
92015: LD_INT 200
92017: PPUSH
92018: CALL_OW 427
// end ;
92022: END
// on SailEvent ( event ) do begin if event < 100 then
92023: LD_VAR 0 1
92027: PUSH
92028: LD_INT 100
92030: LESS
92031: IFFALSE 92042
// CustomEvent ( event ) ;
92033: LD_VAR 0 1
92037: PPUSH
92038: CALL 16158 0 1
// if event = 100 then
92042: LD_VAR 0 1
92046: PUSH
92047: LD_INT 100
92049: EQUAL
92050: IFFALSE 92056
// MC_ClassManager ( ) ;
92052: CALL 92448 0 0
// if event = 101 then
92056: LD_VAR 0 1
92060: PUSH
92061: LD_INT 101
92063: EQUAL
92064: IFFALSE 92070
// MC_RepairBuildings ( ) ;
92066: CALL 97266 0 0
// if event = 102 then
92070: LD_VAR 0 1
92074: PUSH
92075: LD_INT 102
92077: EQUAL
92078: IFFALSE 92084
// MC_Heal ( ) ;
92080: CALL 98201 0 0
// if event = 103 then
92084: LD_VAR 0 1
92088: PUSH
92089: LD_INT 103
92091: EQUAL
92092: IFFALSE 92098
// MC_Build ( ) ;
92094: CALL 98623 0 0
// if event = 104 then
92098: LD_VAR 0 1
92102: PUSH
92103: LD_INT 104
92105: EQUAL
92106: IFFALSE 92112
// MC_TurretWeapon ( ) ;
92108: CALL 100257 0 0
// if event = 105 then
92112: LD_VAR 0 1
92116: PUSH
92117: LD_INT 105
92119: EQUAL
92120: IFFALSE 92126
// MC_BuildUpgrade ( ) ;
92122: CALL 99808 0 0
// if event = 106 then
92126: LD_VAR 0 1
92130: PUSH
92131: LD_INT 106
92133: EQUAL
92134: IFFALSE 92140
// MC_PlantMines ( ) ;
92136: CALL 100687 0 0
// if event = 107 then
92140: LD_VAR 0 1
92144: PUSH
92145: LD_INT 107
92147: EQUAL
92148: IFFALSE 92154
// MC_CollectCrates ( ) ;
92150: CALL 101478 0 0
// if event = 108 then
92154: LD_VAR 0 1
92158: PUSH
92159: LD_INT 108
92161: EQUAL
92162: IFFALSE 92168
// MC_LinkRemoteControl ( ) ;
92164: CALL 103328 0 0
// if event = 109 then
92168: LD_VAR 0 1
92172: PUSH
92173: LD_INT 109
92175: EQUAL
92176: IFFALSE 92182
// MC_ProduceVehicle ( ) ;
92178: CALL 103509 0 0
// if event = 110 then
92182: LD_VAR 0 1
92186: PUSH
92187: LD_INT 110
92189: EQUAL
92190: IFFALSE 92196
// MC_SendAttack ( ) ;
92192: CALL 103975 0 0
// if event = 111 then
92196: LD_VAR 0 1
92200: PUSH
92201: LD_INT 111
92203: EQUAL
92204: IFFALSE 92210
// MC_Defend ( ) ;
92206: CALL 104083 0 0
// if event = 112 then
92210: LD_VAR 0 1
92214: PUSH
92215: LD_INT 112
92217: EQUAL
92218: IFFALSE 92224
// MC_Research ( ) ;
92220: CALL 104963 0 0
// if event = 113 then
92224: LD_VAR 0 1
92228: PUSH
92229: LD_INT 113
92231: EQUAL
92232: IFFALSE 92238
// MC_MinesTrigger ( ) ;
92234: CALL 106077 0 0
// if event = 120 then
92238: LD_VAR 0 1
92242: PUSH
92243: LD_INT 120
92245: EQUAL
92246: IFFALSE 92252
// MC_RepairVehicle ( ) ;
92248: CALL 106176 0 0
// if event = 121 then
92252: LD_VAR 0 1
92256: PUSH
92257: LD_INT 121
92259: EQUAL
92260: IFFALSE 92266
// MC_TameApe ( ) ;
92262: CALL 106945 0 0
// if event = 122 then
92266: LD_VAR 0 1
92270: PUSH
92271: LD_INT 122
92273: EQUAL
92274: IFFALSE 92280
// MC_ChangeApeClass ( ) ;
92276: CALL 107774 0 0
// if event = 123 then
92280: LD_VAR 0 1
92284: PUSH
92285: LD_INT 123
92287: EQUAL
92288: IFFALSE 92294
// MC_Bazooka ( ) ;
92290: CALL 108424 0 0
// if event = 124 then
92294: LD_VAR 0 1
92298: PUSH
92299: LD_INT 124
92301: EQUAL
92302: IFFALSE 92308
// MC_TeleportExit ( ) ;
92304: CALL 108622 0 0
// if event = 125 then
92308: LD_VAR 0 1
92312: PUSH
92313: LD_INT 125
92315: EQUAL
92316: IFFALSE 92322
// MC_Deposits ( ) ;
92318: CALL 109269 0 0
// if event = 126 then
92322: LD_VAR 0 1
92326: PUSH
92327: LD_INT 126
92329: EQUAL
92330: IFFALSE 92336
// MC_RemoteDriver ( ) ;
92332: CALL 109894 0 0
// if event = 200 then
92336: LD_VAR 0 1
92340: PUSH
92341: LD_INT 200
92343: EQUAL
92344: IFFALSE 92350
// MC_Idle ( ) ;
92346: CALL 111843 0 0
// end ;
92350: PPOPN 1
92352: END
// export function MC_Reset ( base , tag ) ; var i ; begin
92353: LD_INT 0
92355: PPUSH
92356: PPUSH
// if not mc_bases [ base ] or not tag then
92357: LD_EXP 161
92361: PUSH
92362: LD_VAR 0 1
92366: ARRAY
92367: NOT
92368: PUSH
92369: LD_VAR 0 2
92373: NOT
92374: OR
92375: IFFALSE 92379
// exit ;
92377: GO 92443
// for i in mc_bases [ base ] union mc_ape [ base ] do
92379: LD_ADDR_VAR 0 4
92383: PUSH
92384: LD_EXP 161
92388: PUSH
92389: LD_VAR 0 1
92393: ARRAY
92394: PUSH
92395: LD_EXP 190
92399: PUSH
92400: LD_VAR 0 1
92404: ARRAY
92405: UNION
92406: PUSH
92407: FOR_IN
92408: IFFALSE 92441
// if GetTag ( i ) = tag then
92410: LD_VAR 0 4
92414: PPUSH
92415: CALL_OW 110
92419: PUSH
92420: LD_VAR 0 2
92424: EQUAL
92425: IFFALSE 92439
// SetTag ( i , 0 ) ;
92427: LD_VAR 0 4
92431: PPUSH
92432: LD_INT 0
92434: PPUSH
92435: CALL_OW 109
92439: GO 92407
92441: POP
92442: POP
// end ;
92443: LD_VAR 0 3
92447: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
92448: LD_INT 0
92450: PPUSH
92451: PPUSH
92452: PPUSH
92453: PPUSH
92454: PPUSH
92455: PPUSH
92456: PPUSH
92457: PPUSH
// if not mc_bases then
92458: LD_EXP 161
92462: NOT
92463: IFFALSE 92467
// exit ;
92465: GO 92925
// for i = 1 to mc_bases do
92467: LD_ADDR_VAR 0 2
92471: PUSH
92472: DOUBLE
92473: LD_INT 1
92475: DEC
92476: ST_TO_ADDR
92477: LD_EXP 161
92481: PUSH
92482: FOR_TO
92483: IFFALSE 92923
// begin tmp := MC_ClassCheckReq ( i ) ;
92485: LD_ADDR_VAR 0 4
92489: PUSH
92490: LD_VAR 0 2
92494: PPUSH
92495: CALL 92930 0 1
92499: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
92500: LD_ADDR_EXP 202
92504: PUSH
92505: LD_EXP 202
92509: PPUSH
92510: LD_VAR 0 2
92514: PPUSH
92515: LD_VAR 0 4
92519: PPUSH
92520: CALL_OW 1
92524: ST_TO_ADDR
// if not tmp then
92525: LD_VAR 0 4
92529: NOT
92530: IFFALSE 92534
// continue ;
92532: GO 92482
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
92534: LD_ADDR_VAR 0 6
92538: PUSH
92539: LD_EXP 161
92543: PUSH
92544: LD_VAR 0 2
92548: ARRAY
92549: PPUSH
92550: LD_INT 2
92552: PUSH
92553: LD_INT 30
92555: PUSH
92556: LD_INT 4
92558: PUSH
92559: EMPTY
92560: LIST
92561: LIST
92562: PUSH
92563: LD_INT 30
92565: PUSH
92566: LD_INT 5
92568: PUSH
92569: EMPTY
92570: LIST
92571: LIST
92572: PUSH
92573: EMPTY
92574: LIST
92575: LIST
92576: LIST
92577: PPUSH
92578: CALL_OW 72
92582: PUSH
92583: LD_EXP 161
92587: PUSH
92588: LD_VAR 0 2
92592: ARRAY
92593: PPUSH
92594: LD_INT 2
92596: PUSH
92597: LD_INT 30
92599: PUSH
92600: LD_INT 0
92602: PUSH
92603: EMPTY
92604: LIST
92605: LIST
92606: PUSH
92607: LD_INT 30
92609: PUSH
92610: LD_INT 1
92612: PUSH
92613: EMPTY
92614: LIST
92615: LIST
92616: PUSH
92617: EMPTY
92618: LIST
92619: LIST
92620: LIST
92621: PPUSH
92622: CALL_OW 72
92626: PUSH
92627: LD_EXP 161
92631: PUSH
92632: LD_VAR 0 2
92636: ARRAY
92637: PPUSH
92638: LD_INT 30
92640: PUSH
92641: LD_INT 3
92643: PUSH
92644: EMPTY
92645: LIST
92646: LIST
92647: PPUSH
92648: CALL_OW 72
92652: PUSH
92653: LD_EXP 161
92657: PUSH
92658: LD_VAR 0 2
92662: ARRAY
92663: PPUSH
92664: LD_INT 2
92666: PUSH
92667: LD_INT 30
92669: PUSH
92670: LD_INT 6
92672: PUSH
92673: EMPTY
92674: LIST
92675: LIST
92676: PUSH
92677: LD_INT 30
92679: PUSH
92680: LD_INT 7
92682: PUSH
92683: EMPTY
92684: LIST
92685: LIST
92686: PUSH
92687: LD_INT 30
92689: PUSH
92690: LD_INT 8
92692: PUSH
92693: EMPTY
92694: LIST
92695: LIST
92696: PUSH
92697: EMPTY
92698: LIST
92699: LIST
92700: LIST
92701: LIST
92702: PPUSH
92703: CALL_OW 72
92707: PUSH
92708: EMPTY
92709: LIST
92710: LIST
92711: LIST
92712: LIST
92713: ST_TO_ADDR
// for j = 1 to 4 do
92714: LD_ADDR_VAR 0 3
92718: PUSH
92719: DOUBLE
92720: LD_INT 1
92722: DEC
92723: ST_TO_ADDR
92724: LD_INT 4
92726: PUSH
92727: FOR_TO
92728: IFFALSE 92919
// begin if not tmp [ j ] then
92730: LD_VAR 0 4
92734: PUSH
92735: LD_VAR 0 3
92739: ARRAY
92740: NOT
92741: IFFALSE 92745
// continue ;
92743: GO 92727
// for p in tmp [ j ] do
92745: LD_ADDR_VAR 0 5
92749: PUSH
92750: LD_VAR 0 4
92754: PUSH
92755: LD_VAR 0 3
92759: ARRAY
92760: PUSH
92761: FOR_IN
92762: IFFALSE 92915
// begin if not b [ j ] then
92764: LD_VAR 0 6
92768: PUSH
92769: LD_VAR 0 3
92773: ARRAY
92774: NOT
92775: IFFALSE 92779
// break ;
92777: GO 92915
// e := 0 ;
92779: LD_ADDR_VAR 0 7
92783: PUSH
92784: LD_INT 0
92786: ST_TO_ADDR
// for k in b [ j ] do
92787: LD_ADDR_VAR 0 8
92791: PUSH
92792: LD_VAR 0 6
92796: PUSH
92797: LD_VAR 0 3
92801: ARRAY
92802: PUSH
92803: FOR_IN
92804: IFFALSE 92831
// if IsNotFull ( k ) then
92806: LD_VAR 0 8
92810: PPUSH
92811: CALL 21440 0 1
92815: IFFALSE 92829
// begin e := k ;
92817: LD_ADDR_VAR 0 7
92821: PUSH
92822: LD_VAR 0 8
92826: ST_TO_ADDR
// break ;
92827: GO 92831
// end ;
92829: GO 92803
92831: POP
92832: POP
// if e and not UnitGoingToBuilding ( p , e ) then
92833: LD_VAR 0 7
92837: PUSH
92838: LD_VAR 0 5
92842: PPUSH
92843: LD_VAR 0 7
92847: PPUSH
92848: CALL 55336 0 2
92852: NOT
92853: AND
92854: IFFALSE 92913
// begin if IsInUnit ( p ) then
92856: LD_VAR 0 5
92860: PPUSH
92861: CALL_OW 310
92865: IFFALSE 92876
// ComExitBuilding ( p ) ;
92867: LD_VAR 0 5
92871: PPUSH
92872: CALL_OW 122
// ComEnterUnit ( p , e ) ;
92876: LD_VAR 0 5
92880: PPUSH
92881: LD_VAR 0 7
92885: PPUSH
92886: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
92890: LD_VAR 0 5
92894: PPUSH
92895: LD_VAR 0 3
92899: PPUSH
92900: CALL_OW 183
// AddComExitBuilding ( p ) ;
92904: LD_VAR 0 5
92908: PPUSH
92909: CALL_OW 182
// end ; end ;
92913: GO 92761
92915: POP
92916: POP
// end ;
92917: GO 92727
92919: POP
92920: POP
// end ;
92921: GO 92482
92923: POP
92924: POP
// end ;
92925: LD_VAR 0 1
92929: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
92930: LD_INT 0
92932: PPUSH
92933: PPUSH
92934: PPUSH
92935: PPUSH
92936: PPUSH
92937: PPUSH
92938: PPUSH
92939: PPUSH
92940: PPUSH
92941: PPUSH
92942: PPUSH
92943: PPUSH
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
92944: LD_VAR 0 1
92948: NOT
92949: PUSH
92950: LD_EXP 161
92954: PUSH
92955: LD_VAR 0 1
92959: ARRAY
92960: NOT
92961: OR
92962: PUSH
92963: LD_EXP 161
92967: PUSH
92968: LD_VAR 0 1
92972: ARRAY
92973: PPUSH
92974: LD_INT 2
92976: PUSH
92977: LD_INT 30
92979: PUSH
92980: LD_INT 0
92982: PUSH
92983: EMPTY
92984: LIST
92985: LIST
92986: PUSH
92987: LD_INT 30
92989: PUSH
92990: LD_INT 1
92992: PUSH
92993: EMPTY
92994: LIST
92995: LIST
92996: PUSH
92997: EMPTY
92998: LIST
92999: LIST
93000: LIST
93001: PPUSH
93002: CALL_OW 72
93006: NOT
93007: OR
93008: IFFALSE 93012
// exit ;
93010: GO 96515
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
93012: LD_ADDR_VAR 0 4
93016: PUSH
93017: LD_EXP 161
93021: PUSH
93022: LD_VAR 0 1
93026: ARRAY
93027: PPUSH
93028: LD_INT 2
93030: PUSH
93031: LD_INT 25
93033: PUSH
93034: LD_INT 1
93036: PUSH
93037: EMPTY
93038: LIST
93039: LIST
93040: PUSH
93041: LD_INT 25
93043: PUSH
93044: LD_INT 2
93046: PUSH
93047: EMPTY
93048: LIST
93049: LIST
93050: PUSH
93051: LD_INT 25
93053: PUSH
93054: LD_INT 3
93056: PUSH
93057: EMPTY
93058: LIST
93059: LIST
93060: PUSH
93061: LD_INT 25
93063: PUSH
93064: LD_INT 4
93066: PUSH
93067: EMPTY
93068: LIST
93069: LIST
93070: PUSH
93071: LD_INT 25
93073: PUSH
93074: LD_INT 5
93076: PUSH
93077: EMPTY
93078: LIST
93079: LIST
93080: PUSH
93081: LD_INT 25
93083: PUSH
93084: LD_INT 8
93086: PUSH
93087: EMPTY
93088: LIST
93089: LIST
93090: PUSH
93091: LD_INT 25
93093: PUSH
93094: LD_INT 9
93096: PUSH
93097: EMPTY
93098: LIST
93099: LIST
93100: PUSH
93101: EMPTY
93102: LIST
93103: LIST
93104: LIST
93105: LIST
93106: LIST
93107: LIST
93108: LIST
93109: LIST
93110: PPUSH
93111: CALL_OW 72
93115: ST_TO_ADDR
// if not tmp then
93116: LD_VAR 0 4
93120: NOT
93121: IFFALSE 93125
// exit ;
93123: GO 96515
// for i in tmp do
93125: LD_ADDR_VAR 0 3
93129: PUSH
93130: LD_VAR 0 4
93134: PUSH
93135: FOR_IN
93136: IFFALSE 93167
// if GetTag ( i ) then
93138: LD_VAR 0 3
93142: PPUSH
93143: CALL_OW 110
93147: IFFALSE 93165
// tmp := tmp diff i ;
93149: LD_ADDR_VAR 0 4
93153: PUSH
93154: LD_VAR 0 4
93158: PUSH
93159: LD_VAR 0 3
93163: DIFF
93164: ST_TO_ADDR
93165: GO 93135
93167: POP
93168: POP
// if not tmp then
93169: LD_VAR 0 4
93173: NOT
93174: IFFALSE 93178
// exit ;
93176: GO 96515
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
93178: LD_ADDR_VAR 0 5
93182: PUSH
93183: LD_EXP 161
93187: PUSH
93188: LD_VAR 0 1
93192: ARRAY
93193: PPUSH
93194: LD_INT 2
93196: PUSH
93197: LD_INT 25
93199: PUSH
93200: LD_INT 1
93202: PUSH
93203: EMPTY
93204: LIST
93205: LIST
93206: PUSH
93207: LD_INT 25
93209: PUSH
93210: LD_INT 5
93212: PUSH
93213: EMPTY
93214: LIST
93215: LIST
93216: PUSH
93217: LD_INT 25
93219: PUSH
93220: LD_INT 8
93222: PUSH
93223: EMPTY
93224: LIST
93225: LIST
93226: PUSH
93227: LD_INT 25
93229: PUSH
93230: LD_INT 9
93232: PUSH
93233: EMPTY
93234: LIST
93235: LIST
93236: PUSH
93237: EMPTY
93238: LIST
93239: LIST
93240: LIST
93241: LIST
93242: LIST
93243: PPUSH
93244: CALL_OW 72
93248: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
93249: LD_ADDR_VAR 0 6
93253: PUSH
93254: LD_EXP 161
93258: PUSH
93259: LD_VAR 0 1
93263: ARRAY
93264: PPUSH
93265: LD_INT 25
93267: PUSH
93268: LD_INT 2
93270: PUSH
93271: EMPTY
93272: LIST
93273: LIST
93274: PPUSH
93275: CALL_OW 72
93279: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
93280: LD_ADDR_VAR 0 7
93284: PUSH
93285: LD_EXP 161
93289: PUSH
93290: LD_VAR 0 1
93294: ARRAY
93295: PPUSH
93296: LD_INT 25
93298: PUSH
93299: LD_INT 3
93301: PUSH
93302: EMPTY
93303: LIST
93304: LIST
93305: PPUSH
93306: CALL_OW 72
93310: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
93311: LD_ADDR_VAR 0 8
93315: PUSH
93316: LD_EXP 161
93320: PUSH
93321: LD_VAR 0 1
93325: ARRAY
93326: PPUSH
93327: LD_INT 25
93329: PUSH
93330: LD_INT 4
93332: PUSH
93333: EMPTY
93334: LIST
93335: LIST
93336: PUSH
93337: LD_INT 24
93339: PUSH
93340: LD_INT 251
93342: PUSH
93343: EMPTY
93344: LIST
93345: LIST
93346: PUSH
93347: EMPTY
93348: LIST
93349: LIST
93350: PPUSH
93351: CALL_OW 72
93355: ST_TO_ADDR
// if mc_is_defending [ base ] then
93356: LD_EXP 204
93360: PUSH
93361: LD_VAR 0 1
93365: ARRAY
93366: IFFALSE 93827
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
93368: LD_ADDR_EXP 203
93372: PUSH
93373: LD_EXP 203
93377: PPUSH
93378: LD_VAR 0 1
93382: PPUSH
93383: LD_INT 4
93385: PPUSH
93386: CALL_OW 1
93390: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
93391: LD_ADDR_VAR 0 12
93395: PUSH
93396: LD_EXP 161
93400: PUSH
93401: LD_VAR 0 1
93405: ARRAY
93406: PPUSH
93407: LD_INT 2
93409: PUSH
93410: LD_INT 30
93412: PUSH
93413: LD_INT 4
93415: PUSH
93416: EMPTY
93417: LIST
93418: LIST
93419: PUSH
93420: LD_INT 30
93422: PUSH
93423: LD_INT 5
93425: PUSH
93426: EMPTY
93427: LIST
93428: LIST
93429: PUSH
93430: EMPTY
93431: LIST
93432: LIST
93433: LIST
93434: PPUSH
93435: CALL_OW 72
93439: ST_TO_ADDR
// if not b then
93440: LD_VAR 0 12
93444: NOT
93445: IFFALSE 93449
// exit ;
93447: GO 96515
// p := [ ] ;
93449: LD_ADDR_VAR 0 11
93453: PUSH
93454: EMPTY
93455: ST_TO_ADDR
// if sci >= 2 then
93456: LD_VAR 0 8
93460: PUSH
93461: LD_INT 2
93463: GREATEREQUAL
93464: IFFALSE 93495
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
93466: LD_ADDR_VAR 0 8
93470: PUSH
93471: LD_VAR 0 8
93475: PUSH
93476: LD_INT 1
93478: ARRAY
93479: PUSH
93480: LD_VAR 0 8
93484: PUSH
93485: LD_INT 2
93487: ARRAY
93488: PUSH
93489: EMPTY
93490: LIST
93491: LIST
93492: ST_TO_ADDR
93493: GO 93556
// if sci = 1 then
93495: LD_VAR 0 8
93499: PUSH
93500: LD_INT 1
93502: EQUAL
93503: IFFALSE 93524
// sci := [ sci [ 1 ] ] else
93505: LD_ADDR_VAR 0 8
93509: PUSH
93510: LD_VAR 0 8
93514: PUSH
93515: LD_INT 1
93517: ARRAY
93518: PUSH
93519: EMPTY
93520: LIST
93521: ST_TO_ADDR
93522: GO 93556
// if sci = 0 then
93524: LD_VAR 0 8
93528: PUSH
93529: LD_INT 0
93531: EQUAL
93532: IFFALSE 93556
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
93534: LD_ADDR_VAR 0 11
93538: PUSH
93539: LD_VAR 0 4
93543: PPUSH
93544: LD_INT 4
93546: PPUSH
93547: CALL 55208 0 2
93551: PUSH
93552: LD_INT 1
93554: ARRAY
93555: ST_TO_ADDR
// if eng > 4 then
93556: LD_VAR 0 6
93560: PUSH
93561: LD_INT 4
93563: GREATER
93564: IFFALSE 93610
// for i = eng downto 4 do
93566: LD_ADDR_VAR 0 3
93570: PUSH
93571: DOUBLE
93572: LD_VAR 0 6
93576: INC
93577: ST_TO_ADDR
93578: LD_INT 4
93580: PUSH
93581: FOR_DOWNTO
93582: IFFALSE 93608
// eng := eng diff eng [ i ] ;
93584: LD_ADDR_VAR 0 6
93588: PUSH
93589: LD_VAR 0 6
93593: PUSH
93594: LD_VAR 0 6
93598: PUSH
93599: LD_VAR 0 3
93603: ARRAY
93604: DIFF
93605: ST_TO_ADDR
93606: GO 93581
93608: POP
93609: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
93610: LD_ADDR_VAR 0 4
93614: PUSH
93615: LD_VAR 0 4
93619: PUSH
93620: LD_VAR 0 5
93624: PUSH
93625: LD_VAR 0 6
93629: UNION
93630: PUSH
93631: LD_VAR 0 7
93635: UNION
93636: PUSH
93637: LD_VAR 0 8
93641: UNION
93642: DIFF
93643: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
93644: LD_ADDR_VAR 0 13
93648: PUSH
93649: LD_EXP 161
93653: PUSH
93654: LD_VAR 0 1
93658: ARRAY
93659: PPUSH
93660: LD_INT 2
93662: PUSH
93663: LD_INT 30
93665: PUSH
93666: LD_INT 32
93668: PUSH
93669: EMPTY
93670: LIST
93671: LIST
93672: PUSH
93673: LD_INT 30
93675: PUSH
93676: LD_INT 31
93678: PUSH
93679: EMPTY
93680: LIST
93681: LIST
93682: PUSH
93683: EMPTY
93684: LIST
93685: LIST
93686: LIST
93687: PPUSH
93688: CALL_OW 72
93692: PUSH
93693: LD_EXP 161
93697: PUSH
93698: LD_VAR 0 1
93702: ARRAY
93703: PPUSH
93704: LD_INT 2
93706: PUSH
93707: LD_INT 30
93709: PUSH
93710: LD_INT 4
93712: PUSH
93713: EMPTY
93714: LIST
93715: LIST
93716: PUSH
93717: LD_INT 30
93719: PUSH
93720: LD_INT 5
93722: PUSH
93723: EMPTY
93724: LIST
93725: LIST
93726: PUSH
93727: EMPTY
93728: LIST
93729: LIST
93730: LIST
93731: PPUSH
93732: CALL_OW 72
93736: PUSH
93737: LD_INT 6
93739: MUL
93740: PLUS
93741: ST_TO_ADDR
// if bcount < tmp then
93742: LD_VAR 0 13
93746: PUSH
93747: LD_VAR 0 4
93751: LESS
93752: IFFALSE 93798
// for i = tmp downto bcount do
93754: LD_ADDR_VAR 0 3
93758: PUSH
93759: DOUBLE
93760: LD_VAR 0 4
93764: INC
93765: ST_TO_ADDR
93766: LD_VAR 0 13
93770: PUSH
93771: FOR_DOWNTO
93772: IFFALSE 93796
// tmp := Delete ( tmp , tmp ) ;
93774: LD_ADDR_VAR 0 4
93778: PUSH
93779: LD_VAR 0 4
93783: PPUSH
93784: LD_VAR 0 4
93788: PPUSH
93789: CALL_OW 3
93793: ST_TO_ADDR
93794: GO 93771
93796: POP
93797: POP
// result := [ tmp , 0 , 0 , p ] ;
93798: LD_ADDR_VAR 0 2
93802: PUSH
93803: LD_VAR 0 4
93807: PUSH
93808: LD_INT 0
93810: PUSH
93811: LD_INT 0
93813: PUSH
93814: LD_VAR 0 11
93818: PUSH
93819: EMPTY
93820: LIST
93821: LIST
93822: LIST
93823: LIST
93824: ST_TO_ADDR
// exit ;
93825: GO 96515
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
93827: LD_EXP 161
93831: PUSH
93832: LD_VAR 0 1
93836: ARRAY
93837: PPUSH
93838: LD_INT 2
93840: PUSH
93841: LD_INT 30
93843: PUSH
93844: LD_INT 6
93846: PUSH
93847: EMPTY
93848: LIST
93849: LIST
93850: PUSH
93851: LD_INT 30
93853: PUSH
93854: LD_INT 7
93856: PUSH
93857: EMPTY
93858: LIST
93859: LIST
93860: PUSH
93861: LD_INT 30
93863: PUSH
93864: LD_INT 8
93866: PUSH
93867: EMPTY
93868: LIST
93869: LIST
93870: PUSH
93871: EMPTY
93872: LIST
93873: LIST
93874: LIST
93875: LIST
93876: PPUSH
93877: CALL_OW 72
93881: NOT
93882: PUSH
93883: LD_EXP 161
93887: PUSH
93888: LD_VAR 0 1
93892: ARRAY
93893: PPUSH
93894: LD_INT 30
93896: PUSH
93897: LD_INT 3
93899: PUSH
93900: EMPTY
93901: LIST
93902: LIST
93903: PPUSH
93904: CALL_OW 72
93908: NOT
93909: AND
93910: IFFALSE 93982
// begin if eng = tmp then
93912: LD_VAR 0 6
93916: PUSH
93917: LD_VAR 0 4
93921: EQUAL
93922: IFFALSE 93926
// exit ;
93924: GO 96515
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
93926: LD_ADDR_EXP 203
93930: PUSH
93931: LD_EXP 203
93935: PPUSH
93936: LD_VAR 0 1
93940: PPUSH
93941: LD_INT 1
93943: PPUSH
93944: CALL_OW 1
93948: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
93949: LD_ADDR_VAR 0 2
93953: PUSH
93954: LD_INT 0
93956: PUSH
93957: LD_VAR 0 4
93961: PUSH
93962: LD_VAR 0 6
93966: DIFF
93967: PUSH
93968: LD_INT 0
93970: PUSH
93971: LD_INT 0
93973: PUSH
93974: EMPTY
93975: LIST
93976: LIST
93977: LIST
93978: LIST
93979: ST_TO_ADDR
// exit ;
93980: GO 96515
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
93982: LD_EXP 188
93986: PUSH
93987: LD_EXP 187
93991: PUSH
93992: LD_VAR 0 1
93996: ARRAY
93997: ARRAY
93998: PUSH
93999: LD_EXP 161
94003: PUSH
94004: LD_VAR 0 1
94008: ARRAY
94009: PPUSH
94010: LD_INT 2
94012: PUSH
94013: LD_INT 30
94015: PUSH
94016: LD_INT 6
94018: PUSH
94019: EMPTY
94020: LIST
94021: LIST
94022: PUSH
94023: LD_INT 30
94025: PUSH
94026: LD_INT 7
94028: PUSH
94029: EMPTY
94030: LIST
94031: LIST
94032: PUSH
94033: LD_INT 30
94035: PUSH
94036: LD_INT 8
94038: PUSH
94039: EMPTY
94040: LIST
94041: LIST
94042: PUSH
94043: EMPTY
94044: LIST
94045: LIST
94046: LIST
94047: LIST
94048: PPUSH
94049: CALL_OW 72
94053: AND
94054: PUSH
94055: LD_EXP 161
94059: PUSH
94060: LD_VAR 0 1
94064: ARRAY
94065: PPUSH
94066: LD_INT 30
94068: PUSH
94069: LD_INT 3
94071: PUSH
94072: EMPTY
94073: LIST
94074: LIST
94075: PPUSH
94076: CALL_OW 72
94080: NOT
94081: AND
94082: IFFALSE 94296
// begin if sci >= 6 then
94084: LD_VAR 0 8
94088: PUSH
94089: LD_INT 6
94091: GREATEREQUAL
94092: IFFALSE 94096
// exit ;
94094: GO 96515
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
94096: LD_ADDR_EXP 203
94100: PUSH
94101: LD_EXP 203
94105: PPUSH
94106: LD_VAR 0 1
94110: PPUSH
94111: LD_INT 2
94113: PPUSH
94114: CALL_OW 1
94118: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
94119: LD_ADDR_VAR 0 9
94123: PUSH
94124: LD_VAR 0 4
94128: PUSH
94129: LD_VAR 0 8
94133: DIFF
94134: PPUSH
94135: LD_INT 4
94137: PPUSH
94138: CALL 55208 0 2
94142: ST_TO_ADDR
// p := [ ] ;
94143: LD_ADDR_VAR 0 11
94147: PUSH
94148: EMPTY
94149: ST_TO_ADDR
// if sci < 6 and sort > 6 then
94150: LD_VAR 0 8
94154: PUSH
94155: LD_INT 6
94157: LESS
94158: PUSH
94159: LD_VAR 0 9
94163: PUSH
94164: LD_INT 6
94166: GREATER
94167: AND
94168: IFFALSE 94249
// begin for i = 1 to 6 - sci do
94170: LD_ADDR_VAR 0 3
94174: PUSH
94175: DOUBLE
94176: LD_INT 1
94178: DEC
94179: ST_TO_ADDR
94180: LD_INT 6
94182: PUSH
94183: LD_VAR 0 8
94187: MINUS
94188: PUSH
94189: FOR_TO
94190: IFFALSE 94245
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
94192: LD_ADDR_VAR 0 11
94196: PUSH
94197: LD_VAR 0 11
94201: PPUSH
94202: LD_VAR 0 11
94206: PUSH
94207: LD_INT 1
94209: PLUS
94210: PPUSH
94211: LD_VAR 0 9
94215: PUSH
94216: LD_INT 1
94218: ARRAY
94219: PPUSH
94220: CALL_OW 2
94224: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
94225: LD_ADDR_VAR 0 9
94229: PUSH
94230: LD_VAR 0 9
94234: PPUSH
94235: LD_INT 1
94237: PPUSH
94238: CALL_OW 3
94242: ST_TO_ADDR
// end ;
94243: GO 94189
94245: POP
94246: POP
// end else
94247: GO 94269
// if sort then
94249: LD_VAR 0 9
94253: IFFALSE 94269
// p := sort [ 1 ] ;
94255: LD_ADDR_VAR 0 11
94259: PUSH
94260: LD_VAR 0 9
94264: PUSH
94265: LD_INT 1
94267: ARRAY
94268: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
94269: LD_ADDR_VAR 0 2
94273: PUSH
94274: LD_INT 0
94276: PUSH
94277: LD_INT 0
94279: PUSH
94280: LD_INT 0
94282: PUSH
94283: LD_VAR 0 11
94287: PUSH
94288: EMPTY
94289: LIST
94290: LIST
94291: LIST
94292: LIST
94293: ST_TO_ADDR
// exit ;
94294: GO 96515
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
94296: LD_EXP 188
94300: PUSH
94301: LD_EXP 187
94305: PUSH
94306: LD_VAR 0 1
94310: ARRAY
94311: ARRAY
94312: PUSH
94313: LD_EXP 161
94317: PUSH
94318: LD_VAR 0 1
94322: ARRAY
94323: PPUSH
94324: LD_INT 2
94326: PUSH
94327: LD_INT 30
94329: PUSH
94330: LD_INT 6
94332: PUSH
94333: EMPTY
94334: LIST
94335: LIST
94336: PUSH
94337: LD_INT 30
94339: PUSH
94340: LD_INT 7
94342: PUSH
94343: EMPTY
94344: LIST
94345: LIST
94346: PUSH
94347: LD_INT 30
94349: PUSH
94350: LD_INT 8
94352: PUSH
94353: EMPTY
94354: LIST
94355: LIST
94356: PUSH
94357: EMPTY
94358: LIST
94359: LIST
94360: LIST
94361: LIST
94362: PPUSH
94363: CALL_OW 72
94367: AND
94368: PUSH
94369: LD_EXP 161
94373: PUSH
94374: LD_VAR 0 1
94378: ARRAY
94379: PPUSH
94380: LD_INT 30
94382: PUSH
94383: LD_INT 3
94385: PUSH
94386: EMPTY
94387: LIST
94388: LIST
94389: PPUSH
94390: CALL_OW 72
94394: AND
94395: IFFALSE 95129
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
94397: LD_ADDR_EXP 203
94401: PUSH
94402: LD_EXP 203
94406: PPUSH
94407: LD_VAR 0 1
94411: PPUSH
94412: LD_INT 3
94414: PPUSH
94415: CALL_OW 1
94419: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
94420: LD_ADDR_VAR 0 2
94424: PUSH
94425: LD_INT 0
94427: PUSH
94428: LD_INT 0
94430: PUSH
94431: LD_INT 0
94433: PUSH
94434: LD_INT 0
94436: PUSH
94437: EMPTY
94438: LIST
94439: LIST
94440: LIST
94441: LIST
94442: ST_TO_ADDR
// if not eng then
94443: LD_VAR 0 6
94447: NOT
94448: IFFALSE 94511
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
94450: LD_ADDR_VAR 0 11
94454: PUSH
94455: LD_VAR 0 4
94459: PPUSH
94460: LD_INT 2
94462: PPUSH
94463: CALL 55208 0 2
94467: PUSH
94468: LD_INT 1
94470: ARRAY
94471: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
94472: LD_ADDR_VAR 0 2
94476: PUSH
94477: LD_VAR 0 2
94481: PPUSH
94482: LD_INT 2
94484: PPUSH
94485: LD_VAR 0 11
94489: PPUSH
94490: CALL_OW 1
94494: ST_TO_ADDR
// tmp := tmp diff p ;
94495: LD_ADDR_VAR 0 4
94499: PUSH
94500: LD_VAR 0 4
94504: PUSH
94505: LD_VAR 0 11
94509: DIFF
94510: ST_TO_ADDR
// end ; if tmp and sci < 6 then
94511: LD_VAR 0 4
94515: PUSH
94516: LD_VAR 0 8
94520: PUSH
94521: LD_INT 6
94523: LESS
94524: AND
94525: IFFALSE 94713
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
94527: LD_ADDR_VAR 0 9
94531: PUSH
94532: LD_VAR 0 4
94536: PUSH
94537: LD_VAR 0 8
94541: PUSH
94542: LD_VAR 0 7
94546: UNION
94547: DIFF
94548: PPUSH
94549: LD_INT 4
94551: PPUSH
94552: CALL 55208 0 2
94556: ST_TO_ADDR
// p := [ ] ;
94557: LD_ADDR_VAR 0 11
94561: PUSH
94562: EMPTY
94563: ST_TO_ADDR
// if sort then
94564: LD_VAR 0 9
94568: IFFALSE 94684
// for i = 1 to 6 - sci do
94570: LD_ADDR_VAR 0 3
94574: PUSH
94575: DOUBLE
94576: LD_INT 1
94578: DEC
94579: ST_TO_ADDR
94580: LD_INT 6
94582: PUSH
94583: LD_VAR 0 8
94587: MINUS
94588: PUSH
94589: FOR_TO
94590: IFFALSE 94682
// begin if i = sort then
94592: LD_VAR 0 3
94596: PUSH
94597: LD_VAR 0 9
94601: EQUAL
94602: IFFALSE 94606
// break ;
94604: GO 94682
// if GetClass ( i ) = 4 then
94606: LD_VAR 0 3
94610: PPUSH
94611: CALL_OW 257
94615: PUSH
94616: LD_INT 4
94618: EQUAL
94619: IFFALSE 94623
// continue ;
94621: GO 94589
// p := Insert ( p , p + 1 , sort [ i ] ) ;
94623: LD_ADDR_VAR 0 11
94627: PUSH
94628: LD_VAR 0 11
94632: PPUSH
94633: LD_VAR 0 11
94637: PUSH
94638: LD_INT 1
94640: PLUS
94641: PPUSH
94642: LD_VAR 0 9
94646: PUSH
94647: LD_VAR 0 3
94651: ARRAY
94652: PPUSH
94653: CALL_OW 2
94657: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
94658: LD_ADDR_VAR 0 4
94662: PUSH
94663: LD_VAR 0 4
94667: PUSH
94668: LD_VAR 0 9
94672: PUSH
94673: LD_VAR 0 3
94677: ARRAY
94678: DIFF
94679: ST_TO_ADDR
// end ;
94680: GO 94589
94682: POP
94683: POP
// if p then
94684: LD_VAR 0 11
94688: IFFALSE 94713
// result := Replace ( result , 4 , p ) ;
94690: LD_ADDR_VAR 0 2
94694: PUSH
94695: LD_VAR 0 2
94699: PPUSH
94700: LD_INT 4
94702: PPUSH
94703: LD_VAR 0 11
94707: PPUSH
94708: CALL_OW 1
94712: ST_TO_ADDR
// end ; if tmp and mech < 6 then
94713: LD_VAR 0 4
94717: PUSH
94718: LD_VAR 0 7
94722: PUSH
94723: LD_INT 6
94725: LESS
94726: AND
94727: IFFALSE 94915
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
94729: LD_ADDR_VAR 0 9
94733: PUSH
94734: LD_VAR 0 4
94738: PUSH
94739: LD_VAR 0 8
94743: PUSH
94744: LD_VAR 0 7
94748: UNION
94749: DIFF
94750: PPUSH
94751: LD_INT 3
94753: PPUSH
94754: CALL 55208 0 2
94758: ST_TO_ADDR
// p := [ ] ;
94759: LD_ADDR_VAR 0 11
94763: PUSH
94764: EMPTY
94765: ST_TO_ADDR
// if sort then
94766: LD_VAR 0 9
94770: IFFALSE 94886
// for i = 1 to 6 - mech do
94772: LD_ADDR_VAR 0 3
94776: PUSH
94777: DOUBLE
94778: LD_INT 1
94780: DEC
94781: ST_TO_ADDR
94782: LD_INT 6
94784: PUSH
94785: LD_VAR 0 7
94789: MINUS
94790: PUSH
94791: FOR_TO
94792: IFFALSE 94884
// begin if i = sort then
94794: LD_VAR 0 3
94798: PUSH
94799: LD_VAR 0 9
94803: EQUAL
94804: IFFALSE 94808
// break ;
94806: GO 94884
// if GetClass ( i ) = 3 then
94808: LD_VAR 0 3
94812: PPUSH
94813: CALL_OW 257
94817: PUSH
94818: LD_INT 3
94820: EQUAL
94821: IFFALSE 94825
// continue ;
94823: GO 94791
// p := Insert ( p , p + 1 , sort [ i ] ) ;
94825: LD_ADDR_VAR 0 11
94829: PUSH
94830: LD_VAR 0 11
94834: PPUSH
94835: LD_VAR 0 11
94839: PUSH
94840: LD_INT 1
94842: PLUS
94843: PPUSH
94844: LD_VAR 0 9
94848: PUSH
94849: LD_VAR 0 3
94853: ARRAY
94854: PPUSH
94855: CALL_OW 2
94859: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
94860: LD_ADDR_VAR 0 4
94864: PUSH
94865: LD_VAR 0 4
94869: PUSH
94870: LD_VAR 0 9
94874: PUSH
94875: LD_VAR 0 3
94879: ARRAY
94880: DIFF
94881: ST_TO_ADDR
// end ;
94882: GO 94791
94884: POP
94885: POP
// if p then
94886: LD_VAR 0 11
94890: IFFALSE 94915
// result := Replace ( result , 3 , p ) ;
94892: LD_ADDR_VAR 0 2
94896: PUSH
94897: LD_VAR 0 2
94901: PPUSH
94902: LD_INT 3
94904: PPUSH
94905: LD_VAR 0 11
94909: PPUSH
94910: CALL_OW 1
94914: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
94915: LD_VAR 0 4
94919: PUSH
94920: LD_INT 6
94922: GREATER
94923: PUSH
94924: LD_VAR 0 6
94928: PUSH
94929: LD_INT 6
94931: LESS
94932: AND
94933: IFFALSE 95127
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
94935: LD_ADDR_VAR 0 9
94939: PUSH
94940: LD_VAR 0 4
94944: PUSH
94945: LD_VAR 0 8
94949: PUSH
94950: LD_VAR 0 7
94954: UNION
94955: PUSH
94956: LD_VAR 0 6
94960: UNION
94961: DIFF
94962: PPUSH
94963: LD_INT 2
94965: PPUSH
94966: CALL 55208 0 2
94970: ST_TO_ADDR
// p := [ ] ;
94971: LD_ADDR_VAR 0 11
94975: PUSH
94976: EMPTY
94977: ST_TO_ADDR
// if sort then
94978: LD_VAR 0 9
94982: IFFALSE 95098
// for i = 1 to 6 - eng do
94984: LD_ADDR_VAR 0 3
94988: PUSH
94989: DOUBLE
94990: LD_INT 1
94992: DEC
94993: ST_TO_ADDR
94994: LD_INT 6
94996: PUSH
94997: LD_VAR 0 6
95001: MINUS
95002: PUSH
95003: FOR_TO
95004: IFFALSE 95096
// begin if i = sort then
95006: LD_VAR 0 3
95010: PUSH
95011: LD_VAR 0 9
95015: EQUAL
95016: IFFALSE 95020
// break ;
95018: GO 95096
// if GetClass ( i ) = 2 then
95020: LD_VAR 0 3
95024: PPUSH
95025: CALL_OW 257
95029: PUSH
95030: LD_INT 2
95032: EQUAL
95033: IFFALSE 95037
// continue ;
95035: GO 95003
// p := Insert ( p , p + 1 , sort [ i ] ) ;
95037: LD_ADDR_VAR 0 11
95041: PUSH
95042: LD_VAR 0 11
95046: PPUSH
95047: LD_VAR 0 11
95051: PUSH
95052: LD_INT 1
95054: PLUS
95055: PPUSH
95056: LD_VAR 0 9
95060: PUSH
95061: LD_VAR 0 3
95065: ARRAY
95066: PPUSH
95067: CALL_OW 2
95071: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
95072: LD_ADDR_VAR 0 4
95076: PUSH
95077: LD_VAR 0 4
95081: PUSH
95082: LD_VAR 0 9
95086: PUSH
95087: LD_VAR 0 3
95091: ARRAY
95092: DIFF
95093: ST_TO_ADDR
// end ;
95094: GO 95003
95096: POP
95097: POP
// if p then
95098: LD_VAR 0 11
95102: IFFALSE 95127
// result := Replace ( result , 2 , p ) ;
95104: LD_ADDR_VAR 0 2
95108: PUSH
95109: LD_VAR 0 2
95113: PPUSH
95114: LD_INT 2
95116: PPUSH
95117: LD_VAR 0 11
95121: PPUSH
95122: CALL_OW 1
95126: ST_TO_ADDR
// end ; exit ;
95127: GO 96515
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
95129: LD_EXP 188
95133: PUSH
95134: LD_EXP 187
95138: PUSH
95139: LD_VAR 0 1
95143: ARRAY
95144: ARRAY
95145: NOT
95146: PUSH
95147: LD_EXP 161
95151: PUSH
95152: LD_VAR 0 1
95156: ARRAY
95157: PPUSH
95158: LD_INT 30
95160: PUSH
95161: LD_INT 3
95163: PUSH
95164: EMPTY
95165: LIST
95166: LIST
95167: PPUSH
95168: CALL_OW 72
95172: AND
95173: PUSH
95174: LD_EXP 166
95178: PUSH
95179: LD_VAR 0 1
95183: ARRAY
95184: AND
95185: IFFALSE 95793
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
95187: LD_ADDR_EXP 203
95191: PUSH
95192: LD_EXP 203
95196: PPUSH
95197: LD_VAR 0 1
95201: PPUSH
95202: LD_INT 5
95204: PPUSH
95205: CALL_OW 1
95209: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
95210: LD_ADDR_VAR 0 2
95214: PUSH
95215: LD_INT 0
95217: PUSH
95218: LD_INT 0
95220: PUSH
95221: LD_INT 0
95223: PUSH
95224: LD_INT 0
95226: PUSH
95227: EMPTY
95228: LIST
95229: LIST
95230: LIST
95231: LIST
95232: ST_TO_ADDR
// if sci > 1 then
95233: LD_VAR 0 8
95237: PUSH
95238: LD_INT 1
95240: GREATER
95241: IFFALSE 95269
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
95243: LD_ADDR_VAR 0 4
95247: PUSH
95248: LD_VAR 0 4
95252: PUSH
95253: LD_VAR 0 8
95257: PUSH
95258: LD_VAR 0 8
95262: PUSH
95263: LD_INT 1
95265: ARRAY
95266: DIFF
95267: DIFF
95268: ST_TO_ADDR
// if tmp and not sci then
95269: LD_VAR 0 4
95273: PUSH
95274: LD_VAR 0 8
95278: NOT
95279: AND
95280: IFFALSE 95349
// begin sort := SortBySkill ( tmp , 4 ) ;
95282: LD_ADDR_VAR 0 9
95286: PUSH
95287: LD_VAR 0 4
95291: PPUSH
95292: LD_INT 4
95294: PPUSH
95295: CALL 55208 0 2
95299: ST_TO_ADDR
// if sort then
95300: LD_VAR 0 9
95304: IFFALSE 95320
// p := sort [ 1 ] ;
95306: LD_ADDR_VAR 0 11
95310: PUSH
95311: LD_VAR 0 9
95315: PUSH
95316: LD_INT 1
95318: ARRAY
95319: ST_TO_ADDR
// if p then
95320: LD_VAR 0 11
95324: IFFALSE 95349
// result := Replace ( result , 4 , p ) ;
95326: LD_ADDR_VAR 0 2
95330: PUSH
95331: LD_VAR 0 2
95335: PPUSH
95336: LD_INT 4
95338: PPUSH
95339: LD_VAR 0 11
95343: PPUSH
95344: CALL_OW 1
95348: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
95349: LD_ADDR_VAR 0 4
95353: PUSH
95354: LD_VAR 0 4
95358: PUSH
95359: LD_VAR 0 7
95363: DIFF
95364: ST_TO_ADDR
// if tmp and mech < 6 then
95365: LD_VAR 0 4
95369: PUSH
95370: LD_VAR 0 7
95374: PUSH
95375: LD_INT 6
95377: LESS
95378: AND
95379: IFFALSE 95567
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
95381: LD_ADDR_VAR 0 9
95385: PUSH
95386: LD_VAR 0 4
95390: PUSH
95391: LD_VAR 0 8
95395: PUSH
95396: LD_VAR 0 7
95400: UNION
95401: DIFF
95402: PPUSH
95403: LD_INT 3
95405: PPUSH
95406: CALL 55208 0 2
95410: ST_TO_ADDR
// p := [ ] ;
95411: LD_ADDR_VAR 0 11
95415: PUSH
95416: EMPTY
95417: ST_TO_ADDR
// if sort then
95418: LD_VAR 0 9
95422: IFFALSE 95538
// for i = 1 to 6 - mech do
95424: LD_ADDR_VAR 0 3
95428: PUSH
95429: DOUBLE
95430: LD_INT 1
95432: DEC
95433: ST_TO_ADDR
95434: LD_INT 6
95436: PUSH
95437: LD_VAR 0 7
95441: MINUS
95442: PUSH
95443: FOR_TO
95444: IFFALSE 95536
// begin if i = sort then
95446: LD_VAR 0 3
95450: PUSH
95451: LD_VAR 0 9
95455: EQUAL
95456: IFFALSE 95460
// break ;
95458: GO 95536
// if GetClass ( i ) = 3 then
95460: LD_VAR 0 3
95464: PPUSH
95465: CALL_OW 257
95469: PUSH
95470: LD_INT 3
95472: EQUAL
95473: IFFALSE 95477
// continue ;
95475: GO 95443
// p := Insert ( p , p + 1 , sort [ i ] ) ;
95477: LD_ADDR_VAR 0 11
95481: PUSH
95482: LD_VAR 0 11
95486: PPUSH
95487: LD_VAR 0 11
95491: PUSH
95492: LD_INT 1
95494: PLUS
95495: PPUSH
95496: LD_VAR 0 9
95500: PUSH
95501: LD_VAR 0 3
95505: ARRAY
95506: PPUSH
95507: CALL_OW 2
95511: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
95512: LD_ADDR_VAR 0 4
95516: PUSH
95517: LD_VAR 0 4
95521: PUSH
95522: LD_VAR 0 9
95526: PUSH
95527: LD_VAR 0 3
95531: ARRAY
95532: DIFF
95533: ST_TO_ADDR
// end ;
95534: GO 95443
95536: POP
95537: POP
// if p then
95538: LD_VAR 0 11
95542: IFFALSE 95567
// result := Replace ( result , 3 , p ) ;
95544: LD_ADDR_VAR 0 2
95548: PUSH
95549: LD_VAR 0 2
95553: PPUSH
95554: LD_INT 3
95556: PPUSH
95557: LD_VAR 0 11
95561: PPUSH
95562: CALL_OW 1
95566: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
95567: LD_ADDR_VAR 0 4
95571: PUSH
95572: LD_VAR 0 4
95576: PUSH
95577: LD_VAR 0 6
95581: DIFF
95582: ST_TO_ADDR
// if tmp and eng < 6 then
95583: LD_VAR 0 4
95587: PUSH
95588: LD_VAR 0 6
95592: PUSH
95593: LD_INT 6
95595: LESS
95596: AND
95597: IFFALSE 95791
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
95599: LD_ADDR_VAR 0 9
95603: PUSH
95604: LD_VAR 0 4
95608: PUSH
95609: LD_VAR 0 8
95613: PUSH
95614: LD_VAR 0 7
95618: UNION
95619: PUSH
95620: LD_VAR 0 6
95624: UNION
95625: DIFF
95626: PPUSH
95627: LD_INT 2
95629: PPUSH
95630: CALL 55208 0 2
95634: ST_TO_ADDR
// p := [ ] ;
95635: LD_ADDR_VAR 0 11
95639: PUSH
95640: EMPTY
95641: ST_TO_ADDR
// if sort then
95642: LD_VAR 0 9
95646: IFFALSE 95762
// for i = 1 to 6 - eng do
95648: LD_ADDR_VAR 0 3
95652: PUSH
95653: DOUBLE
95654: LD_INT 1
95656: DEC
95657: ST_TO_ADDR
95658: LD_INT 6
95660: PUSH
95661: LD_VAR 0 6
95665: MINUS
95666: PUSH
95667: FOR_TO
95668: IFFALSE 95760
// begin if i = sort then
95670: LD_VAR 0 3
95674: PUSH
95675: LD_VAR 0 9
95679: EQUAL
95680: IFFALSE 95684
// break ;
95682: GO 95760
// if GetClass ( i ) = 2 then
95684: LD_VAR 0 3
95688: PPUSH
95689: CALL_OW 257
95693: PUSH
95694: LD_INT 2
95696: EQUAL
95697: IFFALSE 95701
// continue ;
95699: GO 95667
// p := Insert ( p , p + 1 , sort [ i ] ) ;
95701: LD_ADDR_VAR 0 11
95705: PUSH
95706: LD_VAR 0 11
95710: PPUSH
95711: LD_VAR 0 11
95715: PUSH
95716: LD_INT 1
95718: PLUS
95719: PPUSH
95720: LD_VAR 0 9
95724: PUSH
95725: LD_VAR 0 3
95729: ARRAY
95730: PPUSH
95731: CALL_OW 2
95735: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
95736: LD_ADDR_VAR 0 4
95740: PUSH
95741: LD_VAR 0 4
95745: PUSH
95746: LD_VAR 0 9
95750: PUSH
95751: LD_VAR 0 3
95755: ARRAY
95756: DIFF
95757: ST_TO_ADDR
// end ;
95758: GO 95667
95760: POP
95761: POP
// if p then
95762: LD_VAR 0 11
95766: IFFALSE 95791
// result := Replace ( result , 2 , p ) ;
95768: LD_ADDR_VAR 0 2
95772: PUSH
95773: LD_VAR 0 2
95777: PPUSH
95778: LD_INT 2
95780: PPUSH
95781: LD_VAR 0 11
95785: PPUSH
95786: CALL_OW 1
95790: ST_TO_ADDR
// end ; exit ;
95791: GO 96515
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
95793: LD_EXP 188
95797: PUSH
95798: LD_EXP 187
95802: PUSH
95803: LD_VAR 0 1
95807: ARRAY
95808: ARRAY
95809: NOT
95810: PUSH
95811: LD_EXP 161
95815: PUSH
95816: LD_VAR 0 1
95820: ARRAY
95821: PPUSH
95822: LD_INT 30
95824: PUSH
95825: LD_INT 3
95827: PUSH
95828: EMPTY
95829: LIST
95830: LIST
95831: PPUSH
95832: CALL_OW 72
95836: AND
95837: PUSH
95838: LD_EXP 166
95842: PUSH
95843: LD_VAR 0 1
95847: ARRAY
95848: NOT
95849: AND
95850: IFFALSE 96515
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
95852: LD_ADDR_EXP 203
95856: PUSH
95857: LD_EXP 203
95861: PPUSH
95862: LD_VAR 0 1
95866: PPUSH
95867: LD_INT 6
95869: PPUSH
95870: CALL_OW 1
95874: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
95875: LD_ADDR_VAR 0 2
95879: PUSH
95880: LD_INT 0
95882: PUSH
95883: LD_INT 0
95885: PUSH
95886: LD_INT 0
95888: PUSH
95889: LD_INT 0
95891: PUSH
95892: EMPTY
95893: LIST
95894: LIST
95895: LIST
95896: LIST
95897: ST_TO_ADDR
// if sci >= 1 then
95898: LD_VAR 0 8
95902: PUSH
95903: LD_INT 1
95905: GREATEREQUAL
95906: IFFALSE 95928
// tmp := tmp diff sci [ 1 ] ;
95908: LD_ADDR_VAR 0 4
95912: PUSH
95913: LD_VAR 0 4
95917: PUSH
95918: LD_VAR 0 8
95922: PUSH
95923: LD_INT 1
95925: ARRAY
95926: DIFF
95927: ST_TO_ADDR
// if tmp and not sci then
95928: LD_VAR 0 4
95932: PUSH
95933: LD_VAR 0 8
95937: NOT
95938: AND
95939: IFFALSE 96008
// begin sort := SortBySkill ( tmp , 4 ) ;
95941: LD_ADDR_VAR 0 9
95945: PUSH
95946: LD_VAR 0 4
95950: PPUSH
95951: LD_INT 4
95953: PPUSH
95954: CALL 55208 0 2
95958: ST_TO_ADDR
// if sort then
95959: LD_VAR 0 9
95963: IFFALSE 95979
// p := sort [ 1 ] ;
95965: LD_ADDR_VAR 0 11
95969: PUSH
95970: LD_VAR 0 9
95974: PUSH
95975: LD_INT 1
95977: ARRAY
95978: ST_TO_ADDR
// if p then
95979: LD_VAR 0 11
95983: IFFALSE 96008
// result := Replace ( result , 4 , p ) ;
95985: LD_ADDR_VAR 0 2
95989: PUSH
95990: LD_VAR 0 2
95994: PPUSH
95995: LD_INT 4
95997: PPUSH
95998: LD_VAR 0 11
96002: PPUSH
96003: CALL_OW 1
96007: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
96008: LD_ADDR_VAR 0 4
96012: PUSH
96013: LD_VAR 0 4
96017: PUSH
96018: LD_VAR 0 7
96022: DIFF
96023: ST_TO_ADDR
// if tmp and mech < 6 then
96024: LD_VAR 0 4
96028: PUSH
96029: LD_VAR 0 7
96033: PUSH
96034: LD_INT 6
96036: LESS
96037: AND
96038: IFFALSE 96220
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
96040: LD_ADDR_VAR 0 9
96044: PUSH
96045: LD_VAR 0 4
96049: PUSH
96050: LD_VAR 0 7
96054: DIFF
96055: PPUSH
96056: LD_INT 3
96058: PPUSH
96059: CALL 55208 0 2
96063: ST_TO_ADDR
// p := [ ] ;
96064: LD_ADDR_VAR 0 11
96068: PUSH
96069: EMPTY
96070: ST_TO_ADDR
// if sort then
96071: LD_VAR 0 9
96075: IFFALSE 96191
// for i = 1 to 6 - mech do
96077: LD_ADDR_VAR 0 3
96081: PUSH
96082: DOUBLE
96083: LD_INT 1
96085: DEC
96086: ST_TO_ADDR
96087: LD_INT 6
96089: PUSH
96090: LD_VAR 0 7
96094: MINUS
96095: PUSH
96096: FOR_TO
96097: IFFALSE 96189
// begin if i = sort then
96099: LD_VAR 0 3
96103: PUSH
96104: LD_VAR 0 9
96108: EQUAL
96109: IFFALSE 96113
// break ;
96111: GO 96189
// if GetClass ( i ) = 3 then
96113: LD_VAR 0 3
96117: PPUSH
96118: CALL_OW 257
96122: PUSH
96123: LD_INT 3
96125: EQUAL
96126: IFFALSE 96130
// continue ;
96128: GO 96096
// p := Insert ( p , p + 1 , sort [ i ] ) ;
96130: LD_ADDR_VAR 0 11
96134: PUSH
96135: LD_VAR 0 11
96139: PPUSH
96140: LD_VAR 0 11
96144: PUSH
96145: LD_INT 1
96147: PLUS
96148: PPUSH
96149: LD_VAR 0 9
96153: PUSH
96154: LD_VAR 0 3
96158: ARRAY
96159: PPUSH
96160: CALL_OW 2
96164: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
96165: LD_ADDR_VAR 0 4
96169: PUSH
96170: LD_VAR 0 4
96174: PUSH
96175: LD_VAR 0 9
96179: PUSH
96180: LD_VAR 0 3
96184: ARRAY
96185: DIFF
96186: ST_TO_ADDR
// end ;
96187: GO 96096
96189: POP
96190: POP
// if p then
96191: LD_VAR 0 11
96195: IFFALSE 96220
// result := Replace ( result , 3 , p ) ;
96197: LD_ADDR_VAR 0 2
96201: PUSH
96202: LD_VAR 0 2
96206: PPUSH
96207: LD_INT 3
96209: PPUSH
96210: LD_VAR 0 11
96214: PPUSH
96215: CALL_OW 1
96219: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
96220: LD_ADDR_VAR 0 4
96224: PUSH
96225: LD_VAR 0 4
96229: PUSH
96230: LD_VAR 0 6
96234: DIFF
96235: ST_TO_ADDR
// if tmp and eng < 4 then
96236: LD_VAR 0 4
96240: PUSH
96241: LD_VAR 0 6
96245: PUSH
96246: LD_INT 4
96248: LESS
96249: AND
96250: IFFALSE 96440
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
96252: LD_ADDR_VAR 0 9
96256: PUSH
96257: LD_VAR 0 4
96261: PUSH
96262: LD_VAR 0 7
96266: PUSH
96267: LD_VAR 0 6
96271: UNION
96272: DIFF
96273: PPUSH
96274: LD_INT 2
96276: PPUSH
96277: CALL 55208 0 2
96281: ST_TO_ADDR
// p := [ ] ;
96282: LD_ADDR_VAR 0 11
96286: PUSH
96287: EMPTY
96288: ST_TO_ADDR
// if sort then
96289: LD_VAR 0 9
96293: IFFALSE 96409
// for i = 1 to 4 - eng do
96295: LD_ADDR_VAR 0 3
96299: PUSH
96300: DOUBLE
96301: LD_INT 1
96303: DEC
96304: ST_TO_ADDR
96305: LD_INT 4
96307: PUSH
96308: LD_VAR 0 6
96312: MINUS
96313: PUSH
96314: FOR_TO
96315: IFFALSE 96407
// begin if i = sort then
96317: LD_VAR 0 3
96321: PUSH
96322: LD_VAR 0 9
96326: EQUAL
96327: IFFALSE 96331
// break ;
96329: GO 96407
// if GetClass ( i ) = 2 then
96331: LD_VAR 0 3
96335: PPUSH
96336: CALL_OW 257
96340: PUSH
96341: LD_INT 2
96343: EQUAL
96344: IFFALSE 96348
// continue ;
96346: GO 96314
// p := Insert ( p , p + 1 , sort [ i ] ) ;
96348: LD_ADDR_VAR 0 11
96352: PUSH
96353: LD_VAR 0 11
96357: PPUSH
96358: LD_VAR 0 11
96362: PUSH
96363: LD_INT 1
96365: PLUS
96366: PPUSH
96367: LD_VAR 0 9
96371: PUSH
96372: LD_VAR 0 3
96376: ARRAY
96377: PPUSH
96378: CALL_OW 2
96382: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
96383: LD_ADDR_VAR 0 4
96387: PUSH
96388: LD_VAR 0 4
96392: PUSH
96393: LD_VAR 0 9
96397: PUSH
96398: LD_VAR 0 3
96402: ARRAY
96403: DIFF
96404: ST_TO_ADDR
// end ;
96405: GO 96314
96407: POP
96408: POP
// if p then
96409: LD_VAR 0 11
96413: IFFALSE 96438
// result := Replace ( result , 2 , p ) ;
96415: LD_ADDR_VAR 0 2
96419: PUSH
96420: LD_VAR 0 2
96424: PPUSH
96425: LD_INT 2
96427: PPUSH
96428: LD_VAR 0 11
96432: PPUSH
96433: CALL_OW 1
96437: ST_TO_ADDR
// end else
96438: GO 96484
// for i = eng downto 5 do
96440: LD_ADDR_VAR 0 3
96444: PUSH
96445: DOUBLE
96446: LD_VAR 0 6
96450: INC
96451: ST_TO_ADDR
96452: LD_INT 5
96454: PUSH
96455: FOR_DOWNTO
96456: IFFALSE 96482
// tmp := tmp union eng [ i ] ;
96458: LD_ADDR_VAR 0 4
96462: PUSH
96463: LD_VAR 0 4
96467: PUSH
96468: LD_VAR 0 6
96472: PUSH
96473: LD_VAR 0 3
96477: ARRAY
96478: UNION
96479: ST_TO_ADDR
96480: GO 96455
96482: POP
96483: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
96484: LD_ADDR_VAR 0 2
96488: PUSH
96489: LD_VAR 0 2
96493: PPUSH
96494: LD_INT 1
96496: PPUSH
96497: LD_VAR 0 4
96501: PUSH
96502: LD_VAR 0 5
96506: DIFF
96507: PPUSH
96508: CALL_OW 1
96512: ST_TO_ADDR
// exit ;
96513: GO 96515
// end ; end ;
96515: LD_VAR 0 2
96519: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
96520: LD_INT 0
96522: PPUSH
96523: PPUSH
96524: PPUSH
// if not mc_bases then
96525: LD_EXP 161
96529: NOT
96530: IFFALSE 96534
// exit ;
96532: GO 96676
// for i = 1 to mc_bases do
96534: LD_ADDR_VAR 0 2
96538: PUSH
96539: DOUBLE
96540: LD_INT 1
96542: DEC
96543: ST_TO_ADDR
96544: LD_EXP 161
96548: PUSH
96549: FOR_TO
96550: IFFALSE 96667
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
96552: LD_ADDR_VAR 0 3
96556: PUSH
96557: LD_EXP 161
96561: PUSH
96562: LD_VAR 0 2
96566: ARRAY
96567: PPUSH
96568: LD_INT 21
96570: PUSH
96571: LD_INT 3
96573: PUSH
96574: EMPTY
96575: LIST
96576: LIST
96577: PUSH
96578: LD_INT 3
96580: PUSH
96581: LD_INT 2
96583: PUSH
96584: LD_INT 30
96586: PUSH
96587: LD_INT 29
96589: PUSH
96590: EMPTY
96591: LIST
96592: LIST
96593: PUSH
96594: LD_INT 30
96596: PUSH
96597: LD_INT 30
96599: PUSH
96600: EMPTY
96601: LIST
96602: LIST
96603: PUSH
96604: EMPTY
96605: LIST
96606: LIST
96607: LIST
96608: PUSH
96609: EMPTY
96610: LIST
96611: LIST
96612: PUSH
96613: LD_INT 3
96615: PUSH
96616: LD_INT 24
96618: PUSH
96619: LD_INT 1000
96621: PUSH
96622: EMPTY
96623: LIST
96624: LIST
96625: PUSH
96626: EMPTY
96627: LIST
96628: LIST
96629: PUSH
96630: EMPTY
96631: LIST
96632: LIST
96633: LIST
96634: PPUSH
96635: CALL_OW 72
96639: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
96640: LD_ADDR_EXP 162
96644: PUSH
96645: LD_EXP 162
96649: PPUSH
96650: LD_VAR 0 2
96654: PPUSH
96655: LD_VAR 0 3
96659: PPUSH
96660: CALL_OW 1
96664: ST_TO_ADDR
// end ;
96665: GO 96549
96667: POP
96668: POP
// RaiseSailEvent ( 101 ) ;
96669: LD_INT 101
96671: PPUSH
96672: CALL_OW 427
// end ;
96676: LD_VAR 0 1
96680: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
96681: LD_INT 0
96683: PPUSH
96684: PPUSH
96685: PPUSH
96686: PPUSH
96687: PPUSH
96688: PPUSH
96689: PPUSH
// if not mc_bases then
96690: LD_EXP 161
96694: NOT
96695: IFFALSE 96699
// exit ;
96697: GO 97261
// for i = 1 to mc_bases do
96699: LD_ADDR_VAR 0 2
96703: PUSH
96704: DOUBLE
96705: LD_INT 1
96707: DEC
96708: ST_TO_ADDR
96709: LD_EXP 161
96713: PUSH
96714: FOR_TO
96715: IFFALSE 97252
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 1000 ] ] ] ] ) ;
96717: LD_ADDR_VAR 0 5
96721: PUSH
96722: LD_EXP 161
96726: PUSH
96727: LD_VAR 0 2
96731: ARRAY
96732: PUSH
96733: LD_EXP 190
96737: PUSH
96738: LD_VAR 0 2
96742: ARRAY
96743: UNION
96744: PPUSH
96745: LD_INT 21
96747: PUSH
96748: LD_INT 1
96750: PUSH
96751: EMPTY
96752: LIST
96753: LIST
96754: PUSH
96755: LD_INT 1
96757: PUSH
96758: LD_INT 3
96760: PUSH
96761: LD_INT 54
96763: PUSH
96764: EMPTY
96765: LIST
96766: PUSH
96767: EMPTY
96768: LIST
96769: LIST
96770: PUSH
96771: LD_INT 3
96773: PUSH
96774: LD_INT 24
96776: PUSH
96777: LD_INT 1000
96779: PUSH
96780: EMPTY
96781: LIST
96782: LIST
96783: PUSH
96784: EMPTY
96785: LIST
96786: LIST
96787: PUSH
96788: EMPTY
96789: LIST
96790: LIST
96791: LIST
96792: PUSH
96793: EMPTY
96794: LIST
96795: LIST
96796: PPUSH
96797: CALL_OW 72
96801: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
96802: LD_ADDR_VAR 0 6
96806: PUSH
96807: LD_EXP 161
96811: PUSH
96812: LD_VAR 0 2
96816: ARRAY
96817: PPUSH
96818: LD_INT 21
96820: PUSH
96821: LD_INT 1
96823: PUSH
96824: EMPTY
96825: LIST
96826: LIST
96827: PUSH
96828: LD_INT 1
96830: PUSH
96831: LD_INT 3
96833: PUSH
96834: LD_INT 54
96836: PUSH
96837: EMPTY
96838: LIST
96839: PUSH
96840: EMPTY
96841: LIST
96842: LIST
96843: PUSH
96844: LD_INT 3
96846: PUSH
96847: LD_INT 24
96849: PUSH
96850: LD_INT 250
96852: PUSH
96853: EMPTY
96854: LIST
96855: LIST
96856: PUSH
96857: EMPTY
96858: LIST
96859: LIST
96860: PUSH
96861: EMPTY
96862: LIST
96863: LIST
96864: LIST
96865: PUSH
96866: EMPTY
96867: LIST
96868: LIST
96869: PPUSH
96870: CALL_OW 72
96874: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
96875: LD_ADDR_VAR 0 7
96879: PUSH
96880: LD_VAR 0 5
96884: PUSH
96885: LD_VAR 0 6
96889: DIFF
96890: ST_TO_ADDR
// if not need_heal_1 then
96891: LD_VAR 0 6
96895: NOT
96896: IFFALSE 96929
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
96898: LD_ADDR_EXP 164
96902: PUSH
96903: LD_EXP 164
96907: PPUSH
96908: LD_VAR 0 2
96912: PUSH
96913: LD_INT 1
96915: PUSH
96916: EMPTY
96917: LIST
96918: LIST
96919: PPUSH
96920: EMPTY
96921: PPUSH
96922: CALL 24361 0 3
96926: ST_TO_ADDR
96927: GO 96999
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
96929: LD_ADDR_EXP 164
96933: PUSH
96934: LD_EXP 164
96938: PPUSH
96939: LD_VAR 0 2
96943: PUSH
96944: LD_INT 1
96946: PUSH
96947: EMPTY
96948: LIST
96949: LIST
96950: PPUSH
96951: LD_EXP 164
96955: PUSH
96956: LD_VAR 0 2
96960: ARRAY
96961: PUSH
96962: LD_INT 1
96964: ARRAY
96965: PPUSH
96966: LD_INT 3
96968: PUSH
96969: LD_INT 24
96971: PUSH
96972: LD_INT 1000
96974: PUSH
96975: EMPTY
96976: LIST
96977: LIST
96978: PUSH
96979: EMPTY
96980: LIST
96981: LIST
96982: PPUSH
96983: CALL_OW 72
96987: PUSH
96988: LD_VAR 0 6
96992: UNION
96993: PPUSH
96994: CALL 24361 0 3
96998: ST_TO_ADDR
// if not need_heal_2 then
96999: LD_VAR 0 7
97003: NOT
97004: IFFALSE 97037
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
97006: LD_ADDR_EXP 164
97010: PUSH
97011: LD_EXP 164
97015: PPUSH
97016: LD_VAR 0 2
97020: PUSH
97021: LD_INT 2
97023: PUSH
97024: EMPTY
97025: LIST
97026: LIST
97027: PPUSH
97028: EMPTY
97029: PPUSH
97030: CALL 24361 0 3
97034: ST_TO_ADDR
97035: GO 97069
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
97037: LD_ADDR_EXP 164
97041: PUSH
97042: LD_EXP 164
97046: PPUSH
97047: LD_VAR 0 2
97051: PUSH
97052: LD_INT 2
97054: PUSH
97055: EMPTY
97056: LIST
97057: LIST
97058: PPUSH
97059: LD_VAR 0 7
97063: PPUSH
97064: CALL 24361 0 3
97068: ST_TO_ADDR
// if need_heal_2 then
97069: LD_VAR 0 7
97073: IFFALSE 97234
// for j in need_heal_2 do
97075: LD_ADDR_VAR 0 3
97079: PUSH
97080: LD_VAR 0 7
97084: PUSH
97085: FOR_IN
97086: IFFALSE 97232
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
97088: LD_ADDR_VAR 0 5
97092: PUSH
97093: LD_EXP 161
97097: PUSH
97098: LD_VAR 0 2
97102: ARRAY
97103: PPUSH
97104: LD_INT 2
97106: PUSH
97107: LD_INT 30
97109: PUSH
97110: LD_INT 6
97112: PUSH
97113: EMPTY
97114: LIST
97115: LIST
97116: PUSH
97117: LD_INT 30
97119: PUSH
97120: LD_INT 7
97122: PUSH
97123: EMPTY
97124: LIST
97125: LIST
97126: PUSH
97127: LD_INT 30
97129: PUSH
97130: LD_INT 8
97132: PUSH
97133: EMPTY
97134: LIST
97135: LIST
97136: PUSH
97137: LD_INT 30
97139: PUSH
97140: LD_INT 0
97142: PUSH
97143: EMPTY
97144: LIST
97145: LIST
97146: PUSH
97147: LD_INT 30
97149: PUSH
97150: LD_INT 1
97152: PUSH
97153: EMPTY
97154: LIST
97155: LIST
97156: PUSH
97157: EMPTY
97158: LIST
97159: LIST
97160: LIST
97161: LIST
97162: LIST
97163: LIST
97164: PPUSH
97165: CALL_OW 72
97169: ST_TO_ADDR
// if tmp then
97170: LD_VAR 0 5
97174: IFFALSE 97230
// begin k := NearestUnitToUnit ( tmp , j ) ;
97176: LD_ADDR_VAR 0 4
97180: PUSH
97181: LD_VAR 0 5
97185: PPUSH
97186: LD_VAR 0 3
97190: PPUSH
97191: CALL_OW 74
97195: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 5 then
97196: LD_VAR 0 3
97200: PPUSH
97201: LD_VAR 0 4
97205: PPUSH
97206: CALL_OW 296
97210: PUSH
97211: LD_INT 5
97213: GREATER
97214: IFFALSE 97230
// ComMoveToNearbyEntrance ( j , k ) ;
97216: LD_VAR 0 3
97220: PPUSH
97221: LD_VAR 0 4
97225: PPUSH
97226: CALL 57569 0 2
// end ; end ;
97230: GO 97085
97232: POP
97233: POP
// if not need_heal_1 and not need_heal_2 then
97234: LD_VAR 0 6
97238: NOT
97239: PUSH
97240: LD_VAR 0 7
97244: NOT
97245: AND
97246: IFFALSE 97250
// continue ;
97248: GO 96714
// end ;
97250: GO 96714
97252: POP
97253: POP
// RaiseSailEvent ( 102 ) ;
97254: LD_INT 102
97256: PPUSH
97257: CALL_OW 427
// end ;
97261: LD_VAR 0 1
97265: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes , to_repair_tmp , to_repair ; begin
97266: LD_INT 0
97268: PPUSH
97269: PPUSH
97270: PPUSH
97271: PPUSH
97272: PPUSH
97273: PPUSH
97274: PPUSH
97275: PPUSH
// if not mc_bases then
97276: LD_EXP 161
97280: NOT
97281: IFFALSE 97285
// exit ;
97283: GO 98196
// for i = 1 to mc_bases do
97285: LD_ADDR_VAR 0 2
97289: PUSH
97290: DOUBLE
97291: LD_INT 1
97293: DEC
97294: ST_TO_ADDR
97295: LD_EXP 161
97299: PUSH
97300: FOR_TO
97301: IFFALSE 98194
// begin if not mc_building_need_repair [ i ] then
97303: LD_EXP 162
97307: PUSH
97308: LD_VAR 0 2
97312: ARRAY
97313: NOT
97314: IFFALSE 97499
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ] ) ;
97316: LD_ADDR_VAR 0 6
97320: PUSH
97321: LD_EXP 180
97325: PUSH
97326: LD_VAR 0 2
97330: ARRAY
97331: PPUSH
97332: LD_INT 3
97334: PUSH
97335: LD_INT 24
97337: PUSH
97338: LD_INT 1000
97340: PUSH
97341: EMPTY
97342: LIST
97343: LIST
97344: PUSH
97345: EMPTY
97346: LIST
97347: LIST
97348: PUSH
97349: LD_INT 2
97351: PUSH
97352: LD_INT 34
97354: PUSH
97355: LD_INT 13
97357: PUSH
97358: EMPTY
97359: LIST
97360: LIST
97361: PUSH
97362: LD_INT 34
97364: PUSH
97365: LD_INT 52
97367: PUSH
97368: EMPTY
97369: LIST
97370: LIST
97371: PUSH
97372: LD_INT 34
97374: PUSH
97375: LD_INT 88
97377: PUSH
97378: EMPTY
97379: LIST
97380: LIST
97381: PUSH
97382: EMPTY
97383: LIST
97384: LIST
97385: LIST
97386: LIST
97387: PUSH
97388: EMPTY
97389: LIST
97390: LIST
97391: PPUSH
97392: CALL_OW 72
97396: ST_TO_ADDR
// if cranes then
97397: LD_VAR 0 6
97401: IFFALSE 97463
// for j in cranes do
97403: LD_ADDR_VAR 0 3
97407: PUSH
97408: LD_VAR 0 6
97412: PUSH
97413: FOR_IN
97414: IFFALSE 97461
// if not IsInArea ( j , mc_parking [ i ] ) then
97416: LD_VAR 0 3
97420: PPUSH
97421: LD_EXP 185
97425: PUSH
97426: LD_VAR 0 2
97430: ARRAY
97431: PPUSH
97432: CALL_OW 308
97436: NOT
97437: IFFALSE 97459
// ComMoveToArea ( j , mc_parking [ i ] ) ;
97439: LD_VAR 0 3
97443: PPUSH
97444: LD_EXP 185
97448: PUSH
97449: LD_VAR 0 2
97453: ARRAY
97454: PPUSH
97455: CALL_OW 113
97459: GO 97413
97461: POP
97462: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
97463: LD_ADDR_EXP 163
97467: PUSH
97468: LD_EXP 163
97472: PPUSH
97473: LD_VAR 0 2
97477: PPUSH
97478: EMPTY
97479: PPUSH
97480: CALL_OW 1
97484: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
97485: LD_VAR 0 2
97489: PPUSH
97490: LD_INT 101
97492: PPUSH
97493: CALL 92353 0 2
// continue ;
97497: GO 97300
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
97499: LD_ADDR_EXP 167
97503: PUSH
97504: LD_EXP 167
97508: PPUSH
97509: LD_VAR 0 2
97513: PPUSH
97514: EMPTY
97515: PPUSH
97516: CALL_OW 1
97520: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
97521: LD_VAR 0 2
97525: PPUSH
97526: LD_INT 103
97528: PPUSH
97529: CALL 92353 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) ;
97533: LD_ADDR_VAR 0 5
97537: PUSH
97538: LD_EXP 161
97542: PUSH
97543: LD_VAR 0 2
97547: ARRAY
97548: PUSH
97549: LD_EXP 190
97553: PUSH
97554: LD_VAR 0 2
97558: ARRAY
97559: UNION
97560: PPUSH
97561: LD_INT 2
97563: PUSH
97564: LD_INT 25
97566: PUSH
97567: LD_INT 2
97569: PUSH
97570: EMPTY
97571: LIST
97572: LIST
97573: PUSH
97574: LD_INT 25
97576: PUSH
97577: LD_INT 16
97579: PUSH
97580: EMPTY
97581: LIST
97582: LIST
97583: PUSH
97584: EMPTY
97585: LIST
97586: LIST
97587: LIST
97588: PUSH
97589: EMPTY
97590: LIST
97591: PPUSH
97592: CALL_OW 72
97596: ST_TO_ADDR
// if mc_need_heal [ i ] then
97597: LD_EXP 164
97601: PUSH
97602: LD_VAR 0 2
97606: ARRAY
97607: IFFALSE 97651
// tmp := tmp diff ( mc_need_heal [ i ] [ 1 ] union mc_need_heal [ i ] [ 2 ] ) ;
97609: LD_ADDR_VAR 0 5
97613: PUSH
97614: LD_VAR 0 5
97618: PUSH
97619: LD_EXP 164
97623: PUSH
97624: LD_VAR 0 2
97628: ARRAY
97629: PUSH
97630: LD_INT 1
97632: ARRAY
97633: PUSH
97634: LD_EXP 164
97638: PUSH
97639: LD_VAR 0 2
97643: ARRAY
97644: PUSH
97645: LD_INT 2
97647: ARRAY
97648: UNION
97649: DIFF
97650: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ) ;
97651: LD_ADDR_VAR 0 6
97655: PUSH
97656: LD_EXP 180
97660: PUSH
97661: LD_VAR 0 2
97665: ARRAY
97666: PPUSH
97667: LD_INT 2
97669: PUSH
97670: LD_INT 34
97672: PUSH
97673: LD_INT 13
97675: PUSH
97676: EMPTY
97677: LIST
97678: LIST
97679: PUSH
97680: LD_INT 34
97682: PUSH
97683: LD_INT 52
97685: PUSH
97686: EMPTY
97687: LIST
97688: LIST
97689: PUSH
97690: LD_INT 34
97692: PUSH
97693: LD_INT 88
97695: PUSH
97696: EMPTY
97697: LIST
97698: LIST
97699: PUSH
97700: EMPTY
97701: LIST
97702: LIST
97703: LIST
97704: LIST
97705: PPUSH
97706: CALL_OW 72
97710: ST_TO_ADDR
// if cranes then
97711: LD_VAR 0 6
97715: IFFALSE 97883
// begin for j in cranes do
97717: LD_ADDR_VAR 0 3
97721: PUSH
97722: LD_VAR 0 6
97726: PUSH
97727: FOR_IN
97728: IFFALSE 97881
// begin if GetLives ( j ) = 1000 and not HasTask ( j ) then
97730: LD_VAR 0 3
97734: PPUSH
97735: CALL_OW 256
97739: PUSH
97740: LD_INT 1000
97742: EQUAL
97743: PUSH
97744: LD_VAR 0 3
97748: PPUSH
97749: CALL_OW 314
97753: NOT
97754: AND
97755: IFFALSE 97821
// begin to_repair := NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ;
97757: LD_ADDR_VAR 0 8
97761: PUSH
97762: LD_EXP 162
97766: PUSH
97767: LD_VAR 0 2
97771: ARRAY
97772: PPUSH
97773: LD_VAR 0 3
97777: PPUSH
97778: CALL_OW 74
97782: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 10 then
97783: LD_VAR 0 8
97787: PPUSH
97788: LD_INT 16
97790: PPUSH
97791: CALL 26958 0 2
97795: PUSH
97796: LD_INT 4
97798: ARRAY
97799: PUSH
97800: LD_INT 10
97802: LESS
97803: IFFALSE 97819
// ComRepairBuilding ( j , to_repair ) ;
97805: LD_VAR 0 3
97809: PPUSH
97810: LD_VAR 0 8
97814: PPUSH
97815: CALL_OW 130
// end else
97819: GO 97879
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
97821: LD_VAR 0 3
97825: PPUSH
97826: CALL_OW 256
97830: PUSH
97831: LD_INT 500
97833: LESS
97834: PUSH
97835: LD_VAR 0 3
97839: PPUSH
97840: LD_EXP 185
97844: PUSH
97845: LD_VAR 0 2
97849: ARRAY
97850: PPUSH
97851: CALL_OW 308
97855: NOT
97856: AND
97857: IFFALSE 97879
// ComMoveToArea ( j , mc_parking [ i ] ) ;
97859: LD_VAR 0 3
97863: PPUSH
97864: LD_EXP 185
97868: PUSH
97869: LD_VAR 0 2
97873: ARRAY
97874: PPUSH
97875: CALL_OW 113
// end ;
97879: GO 97727
97881: POP
97882: POP
// end ; if tmp > 3 then
97883: LD_VAR 0 5
97887: PUSH
97888: LD_INT 3
97890: GREATER
97891: IFFALSE 97911
// tmp := ShrinkArray ( tmp , 4 ) ;
97893: LD_ADDR_VAR 0 5
97897: PUSH
97898: LD_VAR 0 5
97902: PPUSH
97903: LD_INT 4
97905: PPUSH
97906: CALL 57007 0 2
97910: ST_TO_ADDR
// if not tmp then
97911: LD_VAR 0 5
97915: NOT
97916: IFFALSE 97920
// continue ;
97918: GO 97300
// for j in tmp do
97920: LD_ADDR_VAR 0 3
97924: PUSH
97925: LD_VAR 0 5
97929: PUSH
97930: FOR_IN
97931: IFFALSE 98190
// begin if IsInUnit ( j ) then
97933: LD_VAR 0 3
97937: PPUSH
97938: CALL_OW 310
97942: IFFALSE 97953
// ComExitBuilding ( j ) ;
97944: LD_VAR 0 3
97948: PPUSH
97949: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
97953: LD_VAR 0 3
97957: PUSH
97958: LD_EXP 163
97962: PUSH
97963: LD_VAR 0 2
97967: ARRAY
97968: IN
97969: NOT
97970: IFFALSE 98028
// begin SetTag ( j , 101 ) ;
97972: LD_VAR 0 3
97976: PPUSH
97977: LD_INT 101
97979: PPUSH
97980: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
97984: LD_ADDR_EXP 163
97988: PUSH
97989: LD_EXP 163
97993: PPUSH
97994: LD_VAR 0 2
97998: PUSH
97999: LD_EXP 163
98003: PUSH
98004: LD_VAR 0 2
98008: ARRAY
98009: PUSH
98010: LD_INT 1
98012: PLUS
98013: PUSH
98014: EMPTY
98015: LIST
98016: LIST
98017: PPUSH
98018: LD_VAR 0 3
98022: PPUSH
98023: CALL 24361 0 3
98027: ST_TO_ADDR
// end ; wait ( 1 ) ;
98028: LD_INT 1
98030: PPUSH
98031: CALL_OW 67
// to_repair_tmp := mc_building_need_repair [ i ] ;
98035: LD_ADDR_VAR 0 7
98039: PUSH
98040: LD_EXP 162
98044: PUSH
98045: LD_VAR 0 2
98049: ARRAY
98050: ST_TO_ADDR
// if mc_scan [ i ] then
98051: LD_EXP 184
98055: PUSH
98056: LD_VAR 0 2
98060: ARRAY
98061: IFFALSE 98123
// to_repair_tmp := UnitFilter ( mc_building_need_repair [ i ] , [ f_not , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_breastwork ] ] ) ;
98063: LD_ADDR_VAR 0 7
98067: PUSH
98068: LD_EXP 162
98072: PUSH
98073: LD_VAR 0 2
98077: ARRAY
98078: PPUSH
98079: LD_INT 3
98081: PUSH
98082: LD_INT 30
98084: PUSH
98085: LD_INT 32
98087: PUSH
98088: EMPTY
98089: LIST
98090: LIST
98091: PUSH
98092: LD_INT 30
98094: PUSH
98095: LD_INT 33
98097: PUSH
98098: EMPTY
98099: LIST
98100: LIST
98101: PUSH
98102: LD_INT 30
98104: PUSH
98105: LD_INT 31
98107: PUSH
98108: EMPTY
98109: LIST
98110: LIST
98111: PUSH
98112: EMPTY
98113: LIST
98114: LIST
98115: LIST
98116: LIST
98117: PPUSH
98118: CALL_OW 72
98122: ST_TO_ADDR
// if not to_repair_tmp then
98123: LD_VAR 0 7
98127: NOT
98128: IFFALSE 98132
// continue ;
98130: GO 97930
// to_repair := NearestUnitToUnit ( to_repair_tmp , j ) ;
98132: LD_ADDR_VAR 0 8
98136: PUSH
98137: LD_VAR 0 7
98141: PPUSH
98142: LD_VAR 0 3
98146: PPUSH
98147: CALL_OW 74
98151: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 14 then
98152: LD_VAR 0 8
98156: PPUSH
98157: LD_INT 16
98159: PPUSH
98160: CALL 26958 0 2
98164: PUSH
98165: LD_INT 4
98167: ARRAY
98168: PUSH
98169: LD_INT 14
98171: LESS
98172: IFFALSE 98188
// ComRepairBuilding ( j , to_repair ) ;
98174: LD_VAR 0 3
98178: PPUSH
98179: LD_VAR 0 8
98183: PPUSH
98184: CALL_OW 130
// end ;
98188: GO 97930
98190: POP
98191: POP
// end ;
98192: GO 97300
98194: POP
98195: POP
// end ;
98196: LD_VAR 0 1
98200: RET
// export function MC_Heal ; var i , j , tmp ; begin
98201: LD_INT 0
98203: PPUSH
98204: PPUSH
98205: PPUSH
98206: PPUSH
// if not mc_bases then
98207: LD_EXP 161
98211: NOT
98212: IFFALSE 98216
// exit ;
98214: GO 98618
// for i = 1 to mc_bases do
98216: LD_ADDR_VAR 0 2
98220: PUSH
98221: DOUBLE
98222: LD_INT 1
98224: DEC
98225: ST_TO_ADDR
98226: LD_EXP 161
98230: PUSH
98231: FOR_TO
98232: IFFALSE 98616
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
98234: LD_EXP 164
98238: PUSH
98239: LD_VAR 0 2
98243: ARRAY
98244: PUSH
98245: LD_INT 1
98247: ARRAY
98248: NOT
98249: PUSH
98250: LD_EXP 164
98254: PUSH
98255: LD_VAR 0 2
98259: ARRAY
98260: PUSH
98261: LD_INT 2
98263: ARRAY
98264: NOT
98265: AND
98266: IFFALSE 98304
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
98268: LD_ADDR_EXP 165
98272: PUSH
98273: LD_EXP 165
98277: PPUSH
98278: LD_VAR 0 2
98282: PPUSH
98283: EMPTY
98284: PPUSH
98285: CALL_OW 1
98289: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
98290: LD_VAR 0 2
98294: PPUSH
98295: LD_INT 102
98297: PPUSH
98298: CALL 92353 0 2
// continue ;
98302: GO 98231
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
98304: LD_ADDR_VAR 0 4
98308: PUSH
98309: LD_EXP 161
98313: PUSH
98314: LD_VAR 0 2
98318: ARRAY
98319: PPUSH
98320: LD_INT 25
98322: PUSH
98323: LD_INT 4
98325: PUSH
98326: EMPTY
98327: LIST
98328: LIST
98329: PPUSH
98330: CALL_OW 72
98334: ST_TO_ADDR
// if not tmp then
98335: LD_VAR 0 4
98339: NOT
98340: IFFALSE 98344
// continue ;
98342: GO 98231
// if mc_taming [ i ] then
98344: LD_EXP 192
98348: PUSH
98349: LD_VAR 0 2
98353: ARRAY
98354: IFFALSE 98378
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
98356: LD_ADDR_EXP 192
98360: PUSH
98361: LD_EXP 192
98365: PPUSH
98366: LD_VAR 0 2
98370: PPUSH
98371: EMPTY
98372: PPUSH
98373: CALL_OW 1
98377: ST_TO_ADDR
// for j in tmp do
98378: LD_ADDR_VAR 0 3
98382: PUSH
98383: LD_VAR 0 4
98387: PUSH
98388: FOR_IN
98389: IFFALSE 98612
// begin if IsInUnit ( j ) then
98391: LD_VAR 0 3
98395: PPUSH
98396: CALL_OW 310
98400: IFFALSE 98411
// ComExitBuilding ( j ) ;
98402: LD_VAR 0 3
98406: PPUSH
98407: CALL_OW 122
// if not j in mc_healers [ i ] then
98411: LD_VAR 0 3
98415: PUSH
98416: LD_EXP 165
98420: PUSH
98421: LD_VAR 0 2
98425: ARRAY
98426: IN
98427: NOT
98428: IFFALSE 98474
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
98430: LD_ADDR_EXP 165
98434: PUSH
98435: LD_EXP 165
98439: PPUSH
98440: LD_VAR 0 2
98444: PUSH
98445: LD_EXP 165
98449: PUSH
98450: LD_VAR 0 2
98454: ARRAY
98455: PUSH
98456: LD_INT 1
98458: PLUS
98459: PUSH
98460: EMPTY
98461: LIST
98462: LIST
98463: PPUSH
98464: LD_VAR 0 3
98468: PPUSH
98469: CALL 24361 0 3
98473: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
98474: LD_VAR 0 3
98478: PPUSH
98479: CALL_OW 110
98483: PUSH
98484: LD_INT 102
98486: NONEQUAL
98487: IFFALSE 98501
// SetTag ( j , 102 ) ;
98489: LD_VAR 0 3
98493: PPUSH
98494: LD_INT 102
98496: PPUSH
98497: CALL_OW 109
// Wait ( 3 ) ;
98501: LD_INT 3
98503: PPUSH
98504: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
98508: LD_EXP 164
98512: PUSH
98513: LD_VAR 0 2
98517: ARRAY
98518: PUSH
98519: LD_INT 1
98521: ARRAY
98522: IFFALSE 98554
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
98524: LD_VAR 0 3
98528: PPUSH
98529: LD_EXP 164
98533: PUSH
98534: LD_VAR 0 2
98538: ARRAY
98539: PUSH
98540: LD_INT 1
98542: ARRAY
98543: PUSH
98544: LD_INT 1
98546: ARRAY
98547: PPUSH
98548: CALL_OW 128
98552: GO 98610
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
98554: LD_VAR 0 3
98558: PPUSH
98559: CALL_OW 314
98563: NOT
98564: PUSH
98565: LD_EXP 164
98569: PUSH
98570: LD_VAR 0 2
98574: ARRAY
98575: PUSH
98576: LD_INT 2
98578: ARRAY
98579: AND
98580: IFFALSE 98610
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
98582: LD_VAR 0 3
98586: PPUSH
98587: LD_EXP 164
98591: PUSH
98592: LD_VAR 0 2
98596: ARRAY
98597: PUSH
98598: LD_INT 2
98600: ARRAY
98601: PUSH
98602: LD_INT 1
98604: ARRAY
98605: PPUSH
98606: CALL_OW 128
// end ;
98610: GO 98388
98612: POP
98613: POP
// end ;
98614: GO 98231
98616: POP
98617: POP
// end ;
98618: LD_VAR 0 1
98622: RET
// export function MC_Build ( ) ; var i , j , k , tmp , depot ; begin
98623: LD_INT 0
98625: PPUSH
98626: PPUSH
98627: PPUSH
98628: PPUSH
98629: PPUSH
98630: PPUSH
// if not mc_bases then
98631: LD_EXP 161
98635: NOT
98636: IFFALSE 98640
// exit ;
98638: GO 99803
// for i = 1 to mc_bases do
98640: LD_ADDR_VAR 0 2
98644: PUSH
98645: DOUBLE
98646: LD_INT 1
98648: DEC
98649: ST_TO_ADDR
98650: LD_EXP 161
98654: PUSH
98655: FOR_TO
98656: IFFALSE 99801
// begin if mc_scan [ i ] then
98658: LD_EXP 184
98662: PUSH
98663: LD_VAR 0 2
98667: ARRAY
98668: IFFALSE 98672
// continue ;
98670: GO 98655
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
98672: LD_EXP 166
98676: PUSH
98677: LD_VAR 0 2
98681: ARRAY
98682: NOT
98683: PUSH
98684: LD_EXP 168
98688: PUSH
98689: LD_VAR 0 2
98693: ARRAY
98694: NOT
98695: AND
98696: PUSH
98697: LD_EXP 167
98701: PUSH
98702: LD_VAR 0 2
98706: ARRAY
98707: AND
98708: IFFALSE 98746
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
98710: LD_ADDR_EXP 167
98714: PUSH
98715: LD_EXP 167
98719: PPUSH
98720: LD_VAR 0 2
98724: PPUSH
98725: EMPTY
98726: PPUSH
98727: CALL_OW 1
98731: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
98732: LD_VAR 0 2
98736: PPUSH
98737: LD_INT 103
98739: PPUSH
98740: CALL 92353 0 2
// continue ;
98744: GO 98655
// end ; if mc_construct_list [ i ] then
98746: LD_EXP 168
98750: PUSH
98751: LD_VAR 0 2
98755: ARRAY
98756: IFFALSE 98976
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
98758: LD_ADDR_VAR 0 5
98762: PUSH
98763: LD_EXP 161
98767: PUSH
98768: LD_VAR 0 2
98772: ARRAY
98773: PPUSH
98774: LD_INT 25
98776: PUSH
98777: LD_INT 2
98779: PUSH
98780: EMPTY
98781: LIST
98782: LIST
98783: PPUSH
98784: CALL_OW 72
98788: PUSH
98789: LD_EXP 163
98793: PUSH
98794: LD_VAR 0 2
98798: ARRAY
98799: DIFF
98800: ST_TO_ADDR
// if not tmp then
98801: LD_VAR 0 5
98805: NOT
98806: IFFALSE 98810
// continue ;
98808: GO 98655
// for j in tmp do
98810: LD_ADDR_VAR 0 3
98814: PUSH
98815: LD_VAR 0 5
98819: PUSH
98820: FOR_IN
98821: IFFALSE 98972
// begin if not mc_builders [ i ] then
98823: LD_EXP 167
98827: PUSH
98828: LD_VAR 0 2
98832: ARRAY
98833: NOT
98834: IFFALSE 98892
// begin SetTag ( j , 103 ) ;
98836: LD_VAR 0 3
98840: PPUSH
98841: LD_INT 103
98843: PPUSH
98844: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
98848: LD_ADDR_EXP 167
98852: PUSH
98853: LD_EXP 167
98857: PPUSH
98858: LD_VAR 0 2
98862: PUSH
98863: LD_EXP 167
98867: PUSH
98868: LD_VAR 0 2
98872: ARRAY
98873: PUSH
98874: LD_INT 1
98876: PLUS
98877: PUSH
98878: EMPTY
98879: LIST
98880: LIST
98881: PPUSH
98882: LD_VAR 0 3
98886: PPUSH
98887: CALL 24361 0 3
98891: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
98892: LD_VAR 0 3
98896: PPUSH
98897: CALL_OW 310
98901: IFFALSE 98912
// ComExitBuilding ( j ) ;
98903: LD_VAR 0 3
98907: PPUSH
98908: CALL_OW 122
// wait ( 3 ) ;
98912: LD_INT 3
98914: PPUSH
98915: CALL_OW 67
// if not mc_construct_list [ i ] then
98919: LD_EXP 168
98923: PUSH
98924: LD_VAR 0 2
98928: ARRAY
98929: NOT
98930: IFFALSE 98934
// break ;
98932: GO 98972
// if not HasTask ( j ) then
98934: LD_VAR 0 3
98938: PPUSH
98939: CALL_OW 314
98943: NOT
98944: IFFALSE 98970
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
98946: LD_VAR 0 3
98950: PPUSH
98951: LD_EXP 168
98955: PUSH
98956: LD_VAR 0 2
98960: ARRAY
98961: PUSH
98962: LD_INT 1
98964: ARRAY
98965: PPUSH
98966: CALL 27222 0 2
// end ;
98970: GO 98820
98972: POP
98973: POP
// end else
98974: GO 99799
// if mc_build_list [ i ] then
98976: LD_EXP 166
98980: PUSH
98981: LD_VAR 0 2
98985: ARRAY
98986: IFFALSE 99799
// begin if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
98988: LD_EXP 166
98992: PUSH
98993: LD_VAR 0 2
98997: ARRAY
98998: PUSH
98999: LD_INT 1
99001: ARRAY
99002: PUSH
99003: LD_INT 1
99005: ARRAY
99006: PPUSH
99007: CALL 27046 0 1
99011: PUSH
99012: LD_EXP 161
99016: PUSH
99017: LD_VAR 0 2
99021: ARRAY
99022: PPUSH
99023: LD_INT 2
99025: PUSH
99026: LD_INT 30
99028: PUSH
99029: LD_INT 2
99031: PUSH
99032: EMPTY
99033: LIST
99034: LIST
99035: PUSH
99036: LD_INT 30
99038: PUSH
99039: LD_INT 3
99041: PUSH
99042: EMPTY
99043: LIST
99044: LIST
99045: PUSH
99046: EMPTY
99047: LIST
99048: LIST
99049: LIST
99050: PPUSH
99051: CALL_OW 72
99055: NOT
99056: AND
99057: IFFALSE 99162
// begin for j = 1 to mc_build_list [ i ] do
99059: LD_ADDR_VAR 0 3
99063: PUSH
99064: DOUBLE
99065: LD_INT 1
99067: DEC
99068: ST_TO_ADDR
99069: LD_EXP 166
99073: PUSH
99074: LD_VAR 0 2
99078: ARRAY
99079: PUSH
99080: FOR_TO
99081: IFFALSE 99160
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
99083: LD_EXP 166
99087: PUSH
99088: LD_VAR 0 2
99092: ARRAY
99093: PUSH
99094: LD_VAR 0 3
99098: ARRAY
99099: PUSH
99100: LD_INT 1
99102: ARRAY
99103: PUSH
99104: LD_INT 2
99106: EQUAL
99107: IFFALSE 99158
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
99109: LD_ADDR_EXP 166
99113: PUSH
99114: LD_EXP 166
99118: PPUSH
99119: LD_VAR 0 2
99123: PPUSH
99124: LD_EXP 166
99128: PUSH
99129: LD_VAR 0 2
99133: ARRAY
99134: PPUSH
99135: LD_VAR 0 3
99139: PPUSH
99140: LD_INT 1
99142: PPUSH
99143: LD_INT 0
99145: PPUSH
99146: CALL 23779 0 4
99150: PPUSH
99151: CALL_OW 1
99155: ST_TO_ADDR
// break ;
99156: GO 99160
// end ;
99158: GO 99080
99160: POP
99161: POP
// end ; depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
99162: LD_ADDR_VAR 0 6
99166: PUSH
99167: LD_EXP 161
99171: PUSH
99172: LD_VAR 0 2
99176: ARRAY
99177: PPUSH
99178: LD_INT 2
99180: PUSH
99181: LD_INT 30
99183: PUSH
99184: LD_INT 0
99186: PUSH
99187: EMPTY
99188: LIST
99189: LIST
99190: PUSH
99191: LD_INT 30
99193: PUSH
99194: LD_INT 1
99196: PUSH
99197: EMPTY
99198: LIST
99199: LIST
99200: PUSH
99201: EMPTY
99202: LIST
99203: LIST
99204: LIST
99205: PPUSH
99206: CALL_OW 72
99210: ST_TO_ADDR
// for k := 1 to depot do
99211: LD_ADDR_VAR 0 4
99215: PUSH
99216: DOUBLE
99217: LD_INT 1
99219: DEC
99220: ST_TO_ADDR
99221: LD_VAR 0 6
99225: PUSH
99226: FOR_TO
99227: IFFALSE 99797
// begin if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or CanBeBuilt ( depot [ k ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) then
99229: LD_EXP 166
99233: PUSH
99234: LD_VAR 0 2
99238: ARRAY
99239: PUSH
99240: LD_INT 1
99242: ARRAY
99243: PUSH
99244: LD_INT 1
99246: ARRAY
99247: PUSH
99248: LD_INT 0
99250: EQUAL
99251: PUSH
99252: LD_VAR 0 6
99256: PUSH
99257: LD_VAR 0 4
99261: ARRAY
99262: PPUSH
99263: LD_EXP 166
99267: PUSH
99268: LD_VAR 0 2
99272: ARRAY
99273: PUSH
99274: LD_INT 1
99276: ARRAY
99277: PUSH
99278: LD_INT 1
99280: ARRAY
99281: PPUSH
99282: LD_EXP 166
99286: PUSH
99287: LD_VAR 0 2
99291: ARRAY
99292: PUSH
99293: LD_INT 1
99295: ARRAY
99296: PUSH
99297: LD_INT 2
99299: ARRAY
99300: PPUSH
99301: LD_EXP 166
99305: PUSH
99306: LD_VAR 0 2
99310: ARRAY
99311: PUSH
99312: LD_INT 1
99314: ARRAY
99315: PUSH
99316: LD_INT 3
99318: ARRAY
99319: PPUSH
99320: LD_EXP 166
99324: PUSH
99325: LD_VAR 0 2
99329: ARRAY
99330: PUSH
99331: LD_INT 1
99333: ARRAY
99334: PUSH
99335: LD_INT 4
99337: ARRAY
99338: PPUSH
99339: CALL 32458 0 5
99343: OR
99344: IFFALSE 99625
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
99346: LD_ADDR_VAR 0 5
99350: PUSH
99351: LD_EXP 161
99355: PUSH
99356: LD_VAR 0 2
99360: ARRAY
99361: PPUSH
99362: LD_INT 25
99364: PUSH
99365: LD_INT 2
99367: PUSH
99368: EMPTY
99369: LIST
99370: LIST
99371: PPUSH
99372: CALL_OW 72
99376: PUSH
99377: LD_EXP 163
99381: PUSH
99382: LD_VAR 0 2
99386: ARRAY
99387: DIFF
99388: ST_TO_ADDR
// if not tmp then
99389: LD_VAR 0 5
99393: NOT
99394: IFFALSE 99398
// continue ;
99396: GO 99226
// for j in tmp do
99398: LD_ADDR_VAR 0 3
99402: PUSH
99403: LD_VAR 0 5
99407: PUSH
99408: FOR_IN
99409: IFFALSE 99621
// begin if not mc_builders [ i ] then
99411: LD_EXP 167
99415: PUSH
99416: LD_VAR 0 2
99420: ARRAY
99421: NOT
99422: IFFALSE 99480
// begin SetTag ( j , 103 ) ;
99424: LD_VAR 0 3
99428: PPUSH
99429: LD_INT 103
99431: PPUSH
99432: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
99436: LD_ADDR_EXP 167
99440: PUSH
99441: LD_EXP 167
99445: PPUSH
99446: LD_VAR 0 2
99450: PUSH
99451: LD_EXP 167
99455: PUSH
99456: LD_VAR 0 2
99460: ARRAY
99461: PUSH
99462: LD_INT 1
99464: PLUS
99465: PUSH
99466: EMPTY
99467: LIST
99468: LIST
99469: PPUSH
99470: LD_VAR 0 3
99474: PPUSH
99475: CALL 24361 0 3
99479: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
99480: LD_VAR 0 3
99484: PPUSH
99485: CALL_OW 310
99489: IFFALSE 99500
// ComExitBuilding ( j ) ;
99491: LD_VAR 0 3
99495: PPUSH
99496: CALL_OW 122
// wait ( 3 ) ;
99500: LD_INT 3
99502: PPUSH
99503: CALL_OW 67
// if not mc_build_list [ i ] then
99507: LD_EXP 166
99511: PUSH
99512: LD_VAR 0 2
99516: ARRAY
99517: NOT
99518: IFFALSE 99522
// break ;
99520: GO 99621
// if not HasTask ( j ) then
99522: LD_VAR 0 3
99526: PPUSH
99527: CALL_OW 314
99531: NOT
99532: IFFALSE 99619
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
99534: LD_VAR 0 3
99538: PPUSH
99539: LD_EXP 166
99543: PUSH
99544: LD_VAR 0 2
99548: ARRAY
99549: PUSH
99550: LD_INT 1
99552: ARRAY
99553: PUSH
99554: LD_INT 1
99556: ARRAY
99557: PPUSH
99558: LD_EXP 166
99562: PUSH
99563: LD_VAR 0 2
99567: ARRAY
99568: PUSH
99569: LD_INT 1
99571: ARRAY
99572: PUSH
99573: LD_INT 2
99575: ARRAY
99576: PPUSH
99577: LD_EXP 166
99581: PUSH
99582: LD_VAR 0 2
99586: ARRAY
99587: PUSH
99588: LD_INT 1
99590: ARRAY
99591: PUSH
99592: LD_INT 3
99594: ARRAY
99595: PPUSH
99596: LD_EXP 166
99600: PUSH
99601: LD_VAR 0 2
99605: ARRAY
99606: PUSH
99607: LD_INT 1
99609: ARRAY
99610: PUSH
99611: LD_INT 4
99613: ARRAY
99614: PPUSH
99615: CALL_OW 145
// end ;
99619: GO 99408
99621: POP
99622: POP
// end else
99623: GO 99795
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] , UnitFilter ( mc_bases [ i ] , [ f_type , unit_building ] ) , [ ] ) then
99625: LD_EXP 161
99629: PUSH
99630: LD_VAR 0 2
99634: ARRAY
99635: PPUSH
99636: LD_EXP 166
99640: PUSH
99641: LD_VAR 0 2
99645: ARRAY
99646: PUSH
99647: LD_INT 1
99649: ARRAY
99650: PUSH
99651: LD_INT 1
99653: ARRAY
99654: PPUSH
99655: LD_EXP 166
99659: PUSH
99660: LD_VAR 0 2
99664: ARRAY
99665: PUSH
99666: LD_INT 1
99668: ARRAY
99669: PUSH
99670: LD_INT 2
99672: ARRAY
99673: PPUSH
99674: LD_EXP 166
99678: PUSH
99679: LD_VAR 0 2
99683: ARRAY
99684: PUSH
99685: LD_INT 1
99687: ARRAY
99688: PUSH
99689: LD_INT 3
99691: ARRAY
99692: PPUSH
99693: LD_EXP 166
99697: PUSH
99698: LD_VAR 0 2
99702: ARRAY
99703: PUSH
99704: LD_INT 1
99706: ARRAY
99707: PUSH
99708: LD_INT 4
99710: ARRAY
99711: PPUSH
99712: LD_EXP 161
99716: PUSH
99717: LD_VAR 0 2
99721: ARRAY
99722: PPUSH
99723: LD_INT 21
99725: PUSH
99726: LD_INT 3
99728: PUSH
99729: EMPTY
99730: LIST
99731: LIST
99732: PPUSH
99733: CALL_OW 72
99737: PPUSH
99738: EMPTY
99739: PPUSH
99740: CALL 31212 0 7
99744: NOT
99745: IFFALSE 99795
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
99747: LD_ADDR_EXP 166
99751: PUSH
99752: LD_EXP 166
99756: PPUSH
99757: LD_VAR 0 2
99761: PPUSH
99762: LD_EXP 166
99766: PUSH
99767: LD_VAR 0 2
99771: ARRAY
99772: PPUSH
99773: LD_INT 1
99775: PPUSH
99776: LD_INT 1
99778: NEG
99779: PPUSH
99780: LD_INT 0
99782: PPUSH
99783: CALL 23779 0 4
99787: PPUSH
99788: CALL_OW 1
99792: ST_TO_ADDR
// continue ;
99793: GO 99226
// end ; end ;
99795: GO 99226
99797: POP
99798: POP
// end ; end ;
99799: GO 98655
99801: POP
99802: POP
// end ;
99803: LD_VAR 0 1
99807: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
99808: LD_INT 0
99810: PPUSH
99811: PPUSH
99812: PPUSH
99813: PPUSH
99814: PPUSH
99815: PPUSH
// if not mc_bases then
99816: LD_EXP 161
99820: NOT
99821: IFFALSE 99825
// exit ;
99823: GO 100252
// for i = 1 to mc_bases do
99825: LD_ADDR_VAR 0 2
99829: PUSH
99830: DOUBLE
99831: LD_INT 1
99833: DEC
99834: ST_TO_ADDR
99835: LD_EXP 161
99839: PUSH
99840: FOR_TO
99841: IFFALSE 100250
// begin tmp := mc_build_upgrade [ i ] ;
99843: LD_ADDR_VAR 0 4
99847: PUSH
99848: LD_EXP 193
99852: PUSH
99853: LD_VAR 0 2
99857: ARRAY
99858: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
99859: LD_ADDR_VAR 0 6
99863: PUSH
99864: LD_EXP 194
99868: PUSH
99869: LD_VAR 0 2
99873: ARRAY
99874: PPUSH
99875: LD_INT 2
99877: PUSH
99878: LD_INT 30
99880: PUSH
99881: LD_INT 6
99883: PUSH
99884: EMPTY
99885: LIST
99886: LIST
99887: PUSH
99888: LD_INT 30
99890: PUSH
99891: LD_INT 7
99893: PUSH
99894: EMPTY
99895: LIST
99896: LIST
99897: PUSH
99898: EMPTY
99899: LIST
99900: LIST
99901: LIST
99902: PPUSH
99903: CALL_OW 72
99907: ST_TO_ADDR
// if not tmp and not lab then
99908: LD_VAR 0 4
99912: NOT
99913: PUSH
99914: LD_VAR 0 6
99918: NOT
99919: AND
99920: IFFALSE 99924
// continue ;
99922: GO 99840
// if tmp then
99924: LD_VAR 0 4
99928: IFFALSE 100048
// for j in tmp do
99930: LD_ADDR_VAR 0 3
99934: PUSH
99935: LD_VAR 0 4
99939: PUSH
99940: FOR_IN
99941: IFFALSE 100046
// begin if UpgradeCost ( j ) then
99943: LD_VAR 0 3
99947: PPUSH
99948: CALL 30872 0 1
99952: IFFALSE 100044
// begin ComUpgrade ( j ) ;
99954: LD_VAR 0 3
99958: PPUSH
99959: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
99963: LD_ADDR_EXP 193
99967: PUSH
99968: LD_EXP 193
99972: PPUSH
99973: LD_VAR 0 2
99977: PPUSH
99978: LD_EXP 193
99982: PUSH
99983: LD_VAR 0 2
99987: ARRAY
99988: PUSH
99989: LD_VAR 0 3
99993: DIFF
99994: PPUSH
99995: CALL_OW 1
99999: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
100000: LD_ADDR_EXP 168
100004: PUSH
100005: LD_EXP 168
100009: PPUSH
100010: LD_VAR 0 2
100014: PUSH
100015: LD_EXP 168
100019: PUSH
100020: LD_VAR 0 2
100024: ARRAY
100025: PUSH
100026: LD_INT 1
100028: PLUS
100029: PUSH
100030: EMPTY
100031: LIST
100032: LIST
100033: PPUSH
100034: LD_VAR 0 3
100038: PPUSH
100039: CALL 24361 0 3
100043: ST_TO_ADDR
// end ; end ;
100044: GO 99940
100046: POP
100047: POP
// if not lab or not mc_lab_upgrade [ i ] then
100048: LD_VAR 0 6
100052: NOT
100053: PUSH
100054: LD_EXP 195
100058: PUSH
100059: LD_VAR 0 2
100063: ARRAY
100064: NOT
100065: OR
100066: IFFALSE 100070
// continue ;
100068: GO 99840
// for j in lab do
100070: LD_ADDR_VAR 0 3
100074: PUSH
100075: LD_VAR 0 6
100079: PUSH
100080: FOR_IN
100081: IFFALSE 100246
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
100083: LD_VAR 0 3
100087: PPUSH
100088: CALL_OW 266
100092: PUSH
100093: LD_INT 6
100095: PUSH
100096: LD_INT 7
100098: PUSH
100099: EMPTY
100100: LIST
100101: LIST
100102: IN
100103: PUSH
100104: LD_VAR 0 3
100108: PPUSH
100109: CALL_OW 461
100113: PUSH
100114: LD_INT 1
100116: NONEQUAL
100117: AND
100118: IFFALSE 100244
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
100120: LD_VAR 0 3
100124: PPUSH
100125: LD_EXP 195
100129: PUSH
100130: LD_VAR 0 2
100134: ARRAY
100135: PUSH
100136: LD_INT 1
100138: ARRAY
100139: PPUSH
100140: CALL 31077 0 2
100144: IFFALSE 100244
// begin ComCancel ( j ) ;
100146: LD_VAR 0 3
100150: PPUSH
100151: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
100155: LD_VAR 0 3
100159: PPUSH
100160: LD_EXP 195
100164: PUSH
100165: LD_VAR 0 2
100169: ARRAY
100170: PUSH
100171: LD_INT 1
100173: ARRAY
100174: PPUSH
100175: CALL_OW 207
// if not j in mc_construct_list [ i ] then
100179: LD_VAR 0 3
100183: PUSH
100184: LD_EXP 168
100188: PUSH
100189: LD_VAR 0 2
100193: ARRAY
100194: IN
100195: NOT
100196: IFFALSE 100242
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
100198: LD_ADDR_EXP 168
100202: PUSH
100203: LD_EXP 168
100207: PPUSH
100208: LD_VAR 0 2
100212: PUSH
100213: LD_EXP 168
100217: PUSH
100218: LD_VAR 0 2
100222: ARRAY
100223: PUSH
100224: LD_INT 1
100226: PLUS
100227: PUSH
100228: EMPTY
100229: LIST
100230: LIST
100231: PPUSH
100232: LD_VAR 0 3
100236: PPUSH
100237: CALL 24361 0 3
100241: ST_TO_ADDR
// break ;
100242: GO 100246
// end ; end ; end ;
100244: GO 100080
100246: POP
100247: POP
// end ;
100248: GO 99840
100250: POP
100251: POP
// end ;
100252: LD_VAR 0 1
100256: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
100257: LD_INT 0
100259: PPUSH
100260: PPUSH
100261: PPUSH
100262: PPUSH
100263: PPUSH
100264: PPUSH
100265: PPUSH
100266: PPUSH
100267: PPUSH
// if not mc_bases then
100268: LD_EXP 161
100272: NOT
100273: IFFALSE 100277
// exit ;
100275: GO 100682
// for i = 1 to mc_bases do
100277: LD_ADDR_VAR 0 2
100281: PUSH
100282: DOUBLE
100283: LD_INT 1
100285: DEC
100286: ST_TO_ADDR
100287: LD_EXP 161
100291: PUSH
100292: FOR_TO
100293: IFFALSE 100680
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
100295: LD_EXP 169
100299: PUSH
100300: LD_VAR 0 2
100304: ARRAY
100305: NOT
100306: PUSH
100307: LD_EXP 161
100311: PUSH
100312: LD_VAR 0 2
100316: ARRAY
100317: PPUSH
100318: LD_INT 30
100320: PUSH
100321: LD_INT 3
100323: PUSH
100324: EMPTY
100325: LIST
100326: LIST
100327: PPUSH
100328: CALL_OW 72
100332: NOT
100333: OR
100334: IFFALSE 100338
// continue ;
100336: GO 100292
// busy := false ;
100338: LD_ADDR_VAR 0 8
100342: PUSH
100343: LD_INT 0
100345: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
100346: LD_ADDR_VAR 0 4
100350: PUSH
100351: LD_EXP 161
100355: PUSH
100356: LD_VAR 0 2
100360: ARRAY
100361: PPUSH
100362: LD_INT 30
100364: PUSH
100365: LD_INT 3
100367: PUSH
100368: EMPTY
100369: LIST
100370: LIST
100371: PPUSH
100372: CALL_OW 72
100376: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
100377: LD_ADDR_VAR 0 6
100381: PUSH
100382: LD_EXP 169
100386: PUSH
100387: LD_VAR 0 2
100391: ARRAY
100392: PPUSH
100393: LD_INT 2
100395: PUSH
100396: LD_INT 30
100398: PUSH
100399: LD_INT 32
100401: PUSH
100402: EMPTY
100403: LIST
100404: LIST
100405: PUSH
100406: LD_INT 30
100408: PUSH
100409: LD_INT 33
100411: PUSH
100412: EMPTY
100413: LIST
100414: LIST
100415: PUSH
100416: EMPTY
100417: LIST
100418: LIST
100419: LIST
100420: PPUSH
100421: CALL_OW 72
100425: ST_TO_ADDR
// if not t then
100426: LD_VAR 0 6
100430: NOT
100431: IFFALSE 100435
// continue ;
100433: GO 100292
// for j in tmp do
100435: LD_ADDR_VAR 0 3
100439: PUSH
100440: LD_VAR 0 4
100444: PUSH
100445: FOR_IN
100446: IFFALSE 100476
// if not BuildingStatus ( j ) = bs_idle then
100448: LD_VAR 0 3
100452: PPUSH
100453: CALL_OW 461
100457: PUSH
100458: LD_INT 2
100460: EQUAL
100461: NOT
100462: IFFALSE 100474
// begin busy := true ;
100464: LD_ADDR_VAR 0 8
100468: PUSH
100469: LD_INT 1
100471: ST_TO_ADDR
// break ;
100472: GO 100476
// end ;
100474: GO 100445
100476: POP
100477: POP
// if busy then
100478: LD_VAR 0 8
100482: IFFALSE 100486
// continue ;
100484: GO 100292
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
100486: LD_ADDR_VAR 0 7
100490: PUSH
100491: LD_VAR 0 6
100495: PPUSH
100496: LD_INT 35
100498: PUSH
100499: LD_INT 0
100501: PUSH
100502: EMPTY
100503: LIST
100504: LIST
100505: PPUSH
100506: CALL_OW 72
100510: ST_TO_ADDR
// if tw then
100511: LD_VAR 0 7
100515: IFFALSE 100592
// begin tw := tw [ 1 ] ;
100517: LD_ADDR_VAR 0 7
100521: PUSH
100522: LD_VAR 0 7
100526: PUSH
100527: LD_INT 1
100529: ARRAY
100530: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
100531: LD_ADDR_VAR 0 9
100535: PUSH
100536: LD_VAR 0 7
100540: PPUSH
100541: LD_EXP 186
100545: PUSH
100546: LD_VAR 0 2
100550: ARRAY
100551: PPUSH
100552: CALL 29369 0 2
100556: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
100557: LD_EXP 200
100561: PUSH
100562: LD_VAR 0 2
100566: ARRAY
100567: IFFALSE 100590
// if not weapon in mc_allowed_tower_weapons [ i ] then
100569: LD_VAR 0 9
100573: PUSH
100574: LD_EXP 200
100578: PUSH
100579: LD_VAR 0 2
100583: ARRAY
100584: IN
100585: NOT
100586: IFFALSE 100590
// continue ;
100588: GO 100292
// end else
100590: GO 100655
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
100592: LD_ADDR_VAR 0 5
100596: PUSH
100597: LD_EXP 169
100601: PUSH
100602: LD_VAR 0 2
100606: ARRAY
100607: PPUSH
100608: LD_VAR 0 4
100612: PPUSH
100613: CALL 56240 0 2
100617: ST_TO_ADDR
// if not tmp2 then
100618: LD_VAR 0 5
100622: NOT
100623: IFFALSE 100627
// continue ;
100625: GO 100292
// tw := tmp2 [ 1 ] ;
100627: LD_ADDR_VAR 0 7
100631: PUSH
100632: LD_VAR 0 5
100636: PUSH
100637: LD_INT 1
100639: ARRAY
100640: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
100641: LD_ADDR_VAR 0 9
100645: PUSH
100646: LD_VAR 0 5
100650: PUSH
100651: LD_INT 2
100653: ARRAY
100654: ST_TO_ADDR
// end ; if not weapon then
100655: LD_VAR 0 9
100659: NOT
100660: IFFALSE 100664
// continue ;
100662: GO 100292
// ComPlaceWeapon ( tw , weapon ) ;
100664: LD_VAR 0 7
100668: PPUSH
100669: LD_VAR 0 9
100673: PPUSH
100674: CALL_OW 148
// end ;
100678: GO 100292
100680: POP
100681: POP
// end ;
100682: LD_VAR 0 1
100686: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list , r ; begin
100687: LD_INT 0
100689: PPUSH
100690: PPUSH
100691: PPUSH
100692: PPUSH
100693: PPUSH
100694: PPUSH
100695: PPUSH
// if not mc_bases then
100696: LD_EXP 161
100700: NOT
100701: IFFALSE 100705
// exit ;
100703: GO 101473
// for i = 1 to mc_bases do
100705: LD_ADDR_VAR 0 2
100709: PUSH
100710: DOUBLE
100711: LD_INT 1
100713: DEC
100714: ST_TO_ADDR
100715: LD_EXP 161
100719: PUSH
100720: FOR_TO
100721: IFFALSE 101471
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] or mc_scan [ i ] then
100723: LD_EXP 174
100727: PUSH
100728: LD_VAR 0 2
100732: ARRAY
100733: NOT
100734: PUSH
100735: LD_EXP 174
100739: PUSH
100740: LD_VAR 0 2
100744: ARRAY
100745: PUSH
100746: LD_EXP 175
100750: PUSH
100751: LD_VAR 0 2
100755: ARRAY
100756: EQUAL
100757: OR
100758: PUSH
100759: LD_EXP 184
100763: PUSH
100764: LD_VAR 0 2
100768: ARRAY
100769: OR
100770: IFFALSE 100774
// continue ;
100772: GO 100720
// if mc_miners [ i ] then
100774: LD_EXP 175
100778: PUSH
100779: LD_VAR 0 2
100783: ARRAY
100784: IFFALSE 101158
// begin for j = mc_miners [ i ] downto 1 do
100786: LD_ADDR_VAR 0 3
100790: PUSH
100791: DOUBLE
100792: LD_EXP 175
100796: PUSH
100797: LD_VAR 0 2
100801: ARRAY
100802: INC
100803: ST_TO_ADDR
100804: LD_INT 1
100806: PUSH
100807: FOR_DOWNTO
100808: IFFALSE 101156
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
100810: LD_EXP 175
100814: PUSH
100815: LD_VAR 0 2
100819: ARRAY
100820: PUSH
100821: LD_VAR 0 3
100825: ARRAY
100826: PPUSH
100827: CALL_OW 301
100831: PUSH
100832: LD_EXP 175
100836: PUSH
100837: LD_VAR 0 2
100841: ARRAY
100842: PUSH
100843: LD_VAR 0 3
100847: ARRAY
100848: PPUSH
100849: CALL_OW 257
100853: PUSH
100854: LD_INT 1
100856: NONEQUAL
100857: OR
100858: IFFALSE 100921
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
100860: LD_ADDR_VAR 0 5
100864: PUSH
100865: LD_EXP 175
100869: PUSH
100870: LD_VAR 0 2
100874: ARRAY
100875: PUSH
100876: LD_EXP 175
100880: PUSH
100881: LD_VAR 0 2
100885: ARRAY
100886: PUSH
100887: LD_VAR 0 3
100891: ARRAY
100892: DIFF
100893: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
100894: LD_ADDR_EXP 175
100898: PUSH
100899: LD_EXP 175
100903: PPUSH
100904: LD_VAR 0 2
100908: PPUSH
100909: LD_VAR 0 5
100913: PPUSH
100914: CALL_OW 1
100918: ST_TO_ADDR
// continue ;
100919: GO 100807
// end ; if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and not HasTask ( mc_miners [ i ] [ j ] ) then
100921: LD_EXP 175
100925: PUSH
100926: LD_VAR 0 2
100930: ARRAY
100931: PUSH
100932: LD_VAR 0 3
100936: ARRAY
100937: PPUSH
100938: CALL_OW 257
100942: PUSH
100943: LD_INT 1
100945: EQUAL
100946: PUSH
100947: LD_EXP 175
100951: PUSH
100952: LD_VAR 0 2
100956: ARRAY
100957: PUSH
100958: LD_VAR 0 3
100962: ARRAY
100963: PPUSH
100964: CALL_OW 459
100968: NOT
100969: AND
100970: PUSH
100971: LD_EXP 175
100975: PUSH
100976: LD_VAR 0 2
100980: ARRAY
100981: PUSH
100982: LD_VAR 0 3
100986: ARRAY
100987: PPUSH
100988: CALL_OW 314
100992: NOT
100993: AND
100994: IFFALSE 101154
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
100996: LD_EXP 175
101000: PUSH
101001: LD_VAR 0 2
101005: ARRAY
101006: PUSH
101007: LD_VAR 0 3
101011: ARRAY
101012: PPUSH
101013: CALL_OW 310
101017: IFFALSE 101040
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
101019: LD_EXP 175
101023: PUSH
101024: LD_VAR 0 2
101028: ARRAY
101029: PUSH
101030: LD_VAR 0 3
101034: ARRAY
101035: PPUSH
101036: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
101040: LD_EXP 175
101044: PUSH
101045: LD_VAR 0 2
101049: ARRAY
101050: PUSH
101051: LD_VAR 0 3
101055: ARRAY
101056: PPUSH
101057: CALL_OW 314
101061: NOT
101062: IFFALSE 101154
// begin r := rand ( 1 , mc_mines [ i ] ) ;
101064: LD_ADDR_VAR 0 7
101068: PUSH
101069: LD_INT 1
101071: PPUSH
101072: LD_EXP 174
101076: PUSH
101077: LD_VAR 0 2
101081: ARRAY
101082: PPUSH
101083: CALL_OW 12
101087: ST_TO_ADDR
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ r ] [ 1 ] , mc_mines [ i ] [ r ] [ 2 ] , 0 ) ;
101088: LD_EXP 175
101092: PUSH
101093: LD_VAR 0 2
101097: ARRAY
101098: PUSH
101099: LD_VAR 0 3
101103: ARRAY
101104: PPUSH
101105: LD_EXP 174
101109: PUSH
101110: LD_VAR 0 2
101114: ARRAY
101115: PUSH
101116: LD_VAR 0 7
101120: ARRAY
101121: PUSH
101122: LD_INT 1
101124: ARRAY
101125: PPUSH
101126: LD_EXP 174
101130: PUSH
101131: LD_VAR 0 2
101135: ARRAY
101136: PUSH
101137: LD_VAR 0 7
101141: ARRAY
101142: PUSH
101143: LD_INT 2
101145: ARRAY
101146: PPUSH
101147: LD_INT 0
101149: PPUSH
101150: CALL_OW 193
// end ; end ; end ;
101154: GO 100807
101156: POP
101157: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
101158: LD_ADDR_VAR 0 5
101162: PUSH
101163: LD_EXP 161
101167: PUSH
101168: LD_VAR 0 2
101172: ARRAY
101173: PPUSH
101174: LD_INT 2
101176: PUSH
101177: LD_INT 30
101179: PUSH
101180: LD_INT 4
101182: PUSH
101183: EMPTY
101184: LIST
101185: LIST
101186: PUSH
101187: LD_INT 30
101189: PUSH
101190: LD_INT 5
101192: PUSH
101193: EMPTY
101194: LIST
101195: LIST
101196: PUSH
101197: LD_INT 30
101199: PUSH
101200: LD_INT 32
101202: PUSH
101203: EMPTY
101204: LIST
101205: LIST
101206: PUSH
101207: EMPTY
101208: LIST
101209: LIST
101210: LIST
101211: LIST
101212: PPUSH
101213: CALL_OW 72
101217: ST_TO_ADDR
// if not tmp then
101218: LD_VAR 0 5
101222: NOT
101223: IFFALSE 101227
// continue ;
101225: GO 100720
// list := [ ] ;
101227: LD_ADDR_VAR 0 6
101231: PUSH
101232: EMPTY
101233: ST_TO_ADDR
// for j in tmp do
101234: LD_ADDR_VAR 0 3
101238: PUSH
101239: LD_VAR 0 5
101243: PUSH
101244: FOR_IN
101245: IFFALSE 101314
// begin for k in UnitsInside ( j ) do
101247: LD_ADDR_VAR 0 4
101251: PUSH
101252: LD_VAR 0 3
101256: PPUSH
101257: CALL_OW 313
101261: PUSH
101262: FOR_IN
101263: IFFALSE 101310
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
101265: LD_VAR 0 4
101269: PPUSH
101270: CALL_OW 257
101274: PUSH
101275: LD_INT 1
101277: EQUAL
101278: PUSH
101279: LD_VAR 0 4
101283: PPUSH
101284: CALL_OW 459
101288: NOT
101289: AND
101290: IFFALSE 101308
// list := list ^ k ;
101292: LD_ADDR_VAR 0 6
101296: PUSH
101297: LD_VAR 0 6
101301: PUSH
101302: LD_VAR 0 4
101306: ADD
101307: ST_TO_ADDR
101308: GO 101262
101310: POP
101311: POP
// end ;
101312: GO 101244
101314: POP
101315: POP
// list := list diff mc_miners [ i ] ;
101316: LD_ADDR_VAR 0 6
101320: PUSH
101321: LD_VAR 0 6
101325: PUSH
101326: LD_EXP 175
101330: PUSH
101331: LD_VAR 0 2
101335: ARRAY
101336: DIFF
101337: ST_TO_ADDR
// if not list then
101338: LD_VAR 0 6
101342: NOT
101343: IFFALSE 101347
// continue ;
101345: GO 100720
// k := mc_mines [ i ] - mc_miners [ i ] ;
101347: LD_ADDR_VAR 0 4
101351: PUSH
101352: LD_EXP 174
101356: PUSH
101357: LD_VAR 0 2
101361: ARRAY
101362: PUSH
101363: LD_EXP 175
101367: PUSH
101368: LD_VAR 0 2
101372: ARRAY
101373: MINUS
101374: ST_TO_ADDR
// if k > list then
101375: LD_VAR 0 4
101379: PUSH
101380: LD_VAR 0 6
101384: GREATER
101385: IFFALSE 101397
// k := list ;
101387: LD_ADDR_VAR 0 4
101391: PUSH
101392: LD_VAR 0 6
101396: ST_TO_ADDR
// for j = 1 to k do
101397: LD_ADDR_VAR 0 3
101401: PUSH
101402: DOUBLE
101403: LD_INT 1
101405: DEC
101406: ST_TO_ADDR
101407: LD_VAR 0 4
101411: PUSH
101412: FOR_TO
101413: IFFALSE 101467
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
101415: LD_ADDR_EXP 175
101419: PUSH
101420: LD_EXP 175
101424: PPUSH
101425: LD_VAR 0 2
101429: PUSH
101430: LD_EXP 175
101434: PUSH
101435: LD_VAR 0 2
101439: ARRAY
101440: PUSH
101441: LD_INT 1
101443: PLUS
101444: PUSH
101445: EMPTY
101446: LIST
101447: LIST
101448: PPUSH
101449: LD_VAR 0 6
101453: PUSH
101454: LD_VAR 0 3
101458: ARRAY
101459: PPUSH
101460: CALL 24361 0 3
101464: ST_TO_ADDR
101465: GO 101412
101467: POP
101468: POP
// end ;
101469: GO 100720
101471: POP
101472: POP
// end ;
101473: LD_VAR 0 1
101477: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , side , target , cargo , depot , fac , components ; begin
101478: LD_INT 0
101480: PPUSH
101481: PPUSH
101482: PPUSH
101483: PPUSH
101484: PPUSH
101485: PPUSH
101486: PPUSH
101487: PPUSH
101488: PPUSH
101489: PPUSH
101490: PPUSH
// if not mc_bases then
101491: LD_EXP 161
101495: NOT
101496: IFFALSE 101500
// exit ;
101498: GO 103323
// for i = 1 to mc_bases do
101500: LD_ADDR_VAR 0 2
101504: PUSH
101505: DOUBLE
101506: LD_INT 1
101508: DEC
101509: ST_TO_ADDR
101510: LD_EXP 161
101514: PUSH
101515: FOR_TO
101516: IFFALSE 103321
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
101518: LD_EXP 161
101522: PUSH
101523: LD_VAR 0 2
101527: ARRAY
101528: NOT
101529: PUSH
101530: LD_EXP 168
101534: PUSH
101535: LD_VAR 0 2
101539: ARRAY
101540: OR
101541: IFFALSE 101545
// continue ;
101543: GO 101515
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
101545: LD_EXP 177
101549: PUSH
101550: LD_VAR 0 2
101554: ARRAY
101555: NOT
101556: PUSH
101557: LD_EXP 178
101561: PUSH
101562: LD_VAR 0 2
101566: ARRAY
101567: AND
101568: IFFALSE 101606
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
101570: LD_ADDR_EXP 178
101574: PUSH
101575: LD_EXP 178
101579: PPUSH
101580: LD_VAR 0 2
101584: PPUSH
101585: EMPTY
101586: PPUSH
101587: CALL_OW 1
101591: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
101592: LD_VAR 0 2
101596: PPUSH
101597: LD_INT 107
101599: PPUSH
101600: CALL 92353 0 2
// continue ;
101604: GO 101515
// end ; target := [ ] ;
101606: LD_ADDR_VAR 0 7
101610: PUSH
101611: EMPTY
101612: ST_TO_ADDR
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
101613: LD_ADDR_VAR 0 6
101617: PUSH
101618: LD_EXP 161
101622: PUSH
101623: LD_VAR 0 2
101627: ARRAY
101628: PUSH
101629: LD_INT 1
101631: ARRAY
101632: PPUSH
101633: CALL_OW 255
101637: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
101638: LD_ADDR_VAR 0 9
101642: PUSH
101643: LD_EXP 161
101647: PUSH
101648: LD_VAR 0 2
101652: ARRAY
101653: PPUSH
101654: LD_INT 2
101656: PUSH
101657: LD_INT 30
101659: PUSH
101660: LD_INT 0
101662: PUSH
101663: EMPTY
101664: LIST
101665: LIST
101666: PUSH
101667: LD_INT 30
101669: PUSH
101670: LD_INT 1
101672: PUSH
101673: EMPTY
101674: LIST
101675: LIST
101676: PUSH
101677: EMPTY
101678: LIST
101679: LIST
101680: LIST
101681: PPUSH
101682: CALL_OW 72
101686: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
101687: LD_ADDR_VAR 0 3
101691: PUSH
101692: DOUBLE
101693: LD_EXP 177
101697: PUSH
101698: LD_VAR 0 2
101702: ARRAY
101703: INC
101704: ST_TO_ADDR
101705: LD_INT 1
101707: PUSH
101708: FOR_DOWNTO
101709: IFFALSE 101954
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
101711: LD_EXP 177
101715: PUSH
101716: LD_VAR 0 2
101720: ARRAY
101721: PUSH
101722: LD_VAR 0 3
101726: ARRAY
101727: PUSH
101728: LD_INT 2
101730: ARRAY
101731: PPUSH
101732: LD_EXP 177
101736: PUSH
101737: LD_VAR 0 2
101741: ARRAY
101742: PUSH
101743: LD_VAR 0 3
101747: ARRAY
101748: PUSH
101749: LD_INT 3
101751: ARRAY
101752: PPUSH
101753: CALL_OW 488
101757: PUSH
101758: LD_EXP 177
101762: PUSH
101763: LD_VAR 0 2
101767: ARRAY
101768: PUSH
101769: LD_VAR 0 3
101773: ARRAY
101774: PUSH
101775: LD_INT 2
101777: ARRAY
101778: PPUSH
101779: LD_EXP 177
101783: PUSH
101784: LD_VAR 0 2
101788: ARRAY
101789: PUSH
101790: LD_VAR 0 3
101794: ARRAY
101795: PUSH
101796: LD_INT 3
101798: ARRAY
101799: PPUSH
101800: CALL_OW 284
101804: PUSH
101805: LD_INT 0
101807: EQUAL
101808: AND
101809: IFFALSE 101864
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
101811: LD_ADDR_VAR 0 5
101815: PUSH
101816: LD_EXP 177
101820: PUSH
101821: LD_VAR 0 2
101825: ARRAY
101826: PPUSH
101827: LD_VAR 0 3
101831: PPUSH
101832: CALL_OW 3
101836: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
101837: LD_ADDR_EXP 177
101841: PUSH
101842: LD_EXP 177
101846: PPUSH
101847: LD_VAR 0 2
101851: PPUSH
101852: LD_VAR 0 5
101856: PPUSH
101857: CALL_OW 1
101861: ST_TO_ADDR
// continue ;
101862: GO 101708
// end ; if DangerAtRangeXY ( side , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
101864: LD_VAR 0 6
101868: PPUSH
101869: LD_EXP 177
101873: PUSH
101874: LD_VAR 0 2
101878: ARRAY
101879: PUSH
101880: LD_VAR 0 3
101884: ARRAY
101885: PUSH
101886: LD_INT 2
101888: ARRAY
101889: PPUSH
101890: LD_EXP 177
101894: PUSH
101895: LD_VAR 0 2
101899: ARRAY
101900: PUSH
101901: LD_VAR 0 3
101905: ARRAY
101906: PUSH
101907: LD_INT 3
101909: ARRAY
101910: PPUSH
101911: LD_INT 30
101913: PPUSH
101914: CALL 25257 0 4
101918: PUSH
101919: LD_INT 4
101921: ARRAY
101922: PUSH
101923: LD_INT 0
101925: EQUAL
101926: IFFALSE 101952
// begin target := mc_crates [ i ] [ j ] ;
101928: LD_ADDR_VAR 0 7
101932: PUSH
101933: LD_EXP 177
101937: PUSH
101938: LD_VAR 0 2
101942: ARRAY
101943: PUSH
101944: LD_VAR 0 3
101948: ARRAY
101949: ST_TO_ADDR
// break ;
101950: GO 101954
// end ; end ;
101952: GO 101708
101954: POP
101955: POP
// if not target then
101956: LD_VAR 0 7
101960: NOT
101961: IFFALSE 101965
// continue ;
101963: GO 101515
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
101965: LD_ADDR_VAR 0 8
101969: PUSH
101970: LD_EXP 180
101974: PUSH
101975: LD_VAR 0 2
101979: ARRAY
101980: PPUSH
101981: LD_INT 2
101983: PUSH
101984: LD_INT 3
101986: PUSH
101987: LD_INT 58
101989: PUSH
101990: EMPTY
101991: LIST
101992: PUSH
101993: EMPTY
101994: LIST
101995: LIST
101996: PUSH
101997: LD_INT 61
101999: PUSH
102000: EMPTY
102001: LIST
102002: PUSH
102003: LD_INT 33
102005: PUSH
102006: LD_INT 5
102008: PUSH
102009: EMPTY
102010: LIST
102011: LIST
102012: PUSH
102013: LD_INT 33
102015: PUSH
102016: LD_INT 3
102018: PUSH
102019: EMPTY
102020: LIST
102021: LIST
102022: PUSH
102023: EMPTY
102024: LIST
102025: LIST
102026: LIST
102027: LIST
102028: LIST
102029: PUSH
102030: LD_INT 2
102032: PUSH
102033: LD_INT 34
102035: PUSH
102036: LD_INT 32
102038: PUSH
102039: EMPTY
102040: LIST
102041: LIST
102042: PUSH
102043: LD_INT 34
102045: PUSH
102046: LD_INT 51
102048: PUSH
102049: EMPTY
102050: LIST
102051: LIST
102052: PUSH
102053: LD_INT 34
102055: PUSH
102056: LD_INT 12
102058: PUSH
102059: EMPTY
102060: LIST
102061: LIST
102062: PUSH
102063: EMPTY
102064: LIST
102065: LIST
102066: LIST
102067: LIST
102068: PUSH
102069: EMPTY
102070: LIST
102071: LIST
102072: PPUSH
102073: CALL_OW 72
102077: ST_TO_ADDR
// if not cargo then
102078: LD_VAR 0 8
102082: NOT
102083: IFFALSE 102789
// begin if mc_crates_collector [ i ] < 5 then
102085: LD_EXP 178
102089: PUSH
102090: LD_VAR 0 2
102094: ARRAY
102095: PUSH
102096: LD_INT 5
102098: LESS
102099: IFFALSE 102465
// begin if mc_ape [ i ] then
102101: LD_EXP 190
102105: PUSH
102106: LD_VAR 0 2
102110: ARRAY
102111: IFFALSE 102158
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
102113: LD_ADDR_VAR 0 5
102117: PUSH
102118: LD_EXP 190
102122: PUSH
102123: LD_VAR 0 2
102127: ARRAY
102128: PPUSH
102129: LD_INT 25
102131: PUSH
102132: LD_INT 16
102134: PUSH
102135: EMPTY
102136: LIST
102137: LIST
102138: PUSH
102139: LD_INT 24
102141: PUSH
102142: LD_INT 750
102144: PUSH
102145: EMPTY
102146: LIST
102147: LIST
102148: PUSH
102149: EMPTY
102150: LIST
102151: LIST
102152: PPUSH
102153: CALL_OW 72
102157: ST_TO_ADDR
// if not tmp then
102158: LD_VAR 0 5
102162: NOT
102163: IFFALSE 102210
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
102165: LD_ADDR_VAR 0 5
102169: PUSH
102170: LD_EXP 161
102174: PUSH
102175: LD_VAR 0 2
102179: ARRAY
102180: PPUSH
102181: LD_INT 25
102183: PUSH
102184: LD_INT 2
102186: PUSH
102187: EMPTY
102188: LIST
102189: LIST
102190: PUSH
102191: LD_INT 24
102193: PUSH
102194: LD_INT 750
102196: PUSH
102197: EMPTY
102198: LIST
102199: LIST
102200: PUSH
102201: EMPTY
102202: LIST
102203: LIST
102204: PPUSH
102205: CALL_OW 72
102209: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
102210: LD_EXP 190
102214: PUSH
102215: LD_VAR 0 2
102219: ARRAY
102220: PUSH
102221: LD_EXP 161
102225: PUSH
102226: LD_VAR 0 2
102230: ARRAY
102231: PPUSH
102232: LD_INT 25
102234: PUSH
102235: LD_INT 2
102237: PUSH
102238: EMPTY
102239: LIST
102240: LIST
102241: PUSH
102242: LD_INT 24
102244: PUSH
102245: LD_INT 750
102247: PUSH
102248: EMPTY
102249: LIST
102250: LIST
102251: PUSH
102252: EMPTY
102253: LIST
102254: LIST
102255: PPUSH
102256: CALL_OW 72
102260: AND
102261: PUSH
102262: LD_VAR 0 5
102266: PUSH
102267: LD_INT 5
102269: LESS
102270: AND
102271: IFFALSE 102353
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
102273: LD_ADDR_VAR 0 3
102277: PUSH
102278: LD_EXP 161
102282: PUSH
102283: LD_VAR 0 2
102287: ARRAY
102288: PPUSH
102289: LD_INT 25
102291: PUSH
102292: LD_INT 2
102294: PUSH
102295: EMPTY
102296: LIST
102297: LIST
102298: PUSH
102299: LD_INT 24
102301: PUSH
102302: LD_INT 750
102304: PUSH
102305: EMPTY
102306: LIST
102307: LIST
102308: PUSH
102309: EMPTY
102310: LIST
102311: LIST
102312: PPUSH
102313: CALL_OW 72
102317: PUSH
102318: FOR_IN
102319: IFFALSE 102351
// begin tmp := tmp union j ;
102321: LD_ADDR_VAR 0 5
102325: PUSH
102326: LD_VAR 0 5
102330: PUSH
102331: LD_VAR 0 3
102335: UNION
102336: ST_TO_ADDR
// if tmp >= 5 then
102337: LD_VAR 0 5
102341: PUSH
102342: LD_INT 5
102344: GREATEREQUAL
102345: IFFALSE 102349
// break ;
102347: GO 102351
// end ;
102349: GO 102318
102351: POP
102352: POP
// end ; if not tmp then
102353: LD_VAR 0 5
102357: NOT
102358: IFFALSE 102362
// continue ;
102360: GO 101515
// for j in tmp do
102362: LD_ADDR_VAR 0 3
102366: PUSH
102367: LD_VAR 0 5
102371: PUSH
102372: FOR_IN
102373: IFFALSE 102463
// if not GetTag ( j ) then
102375: LD_VAR 0 3
102379: PPUSH
102380: CALL_OW 110
102384: NOT
102385: IFFALSE 102461
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
102387: LD_ADDR_EXP 178
102391: PUSH
102392: LD_EXP 178
102396: PPUSH
102397: LD_VAR 0 2
102401: PUSH
102402: LD_EXP 178
102406: PUSH
102407: LD_VAR 0 2
102411: ARRAY
102412: PUSH
102413: LD_INT 1
102415: PLUS
102416: PUSH
102417: EMPTY
102418: LIST
102419: LIST
102420: PPUSH
102421: LD_VAR 0 3
102425: PPUSH
102426: CALL 24361 0 3
102430: ST_TO_ADDR
// SetTag ( j , 107 ) ;
102431: LD_VAR 0 3
102435: PPUSH
102436: LD_INT 107
102438: PPUSH
102439: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
102443: LD_EXP 178
102447: PUSH
102448: LD_VAR 0 2
102452: ARRAY
102453: PUSH
102454: LD_INT 5
102456: GREATEREQUAL
102457: IFFALSE 102461
// break ;
102459: GO 102463
// end ;
102461: GO 102372
102463: POP
102464: POP
// end ; if mc_crates_collector [ i ] and target then
102465: LD_EXP 178
102469: PUSH
102470: LD_VAR 0 2
102474: ARRAY
102475: PUSH
102476: LD_VAR 0 7
102480: AND
102481: IFFALSE 102787
// begin if mc_crates_collector [ i ] < target [ 1 ] then
102483: LD_EXP 178
102487: PUSH
102488: LD_VAR 0 2
102492: ARRAY
102493: PUSH
102494: LD_VAR 0 7
102498: PUSH
102499: LD_INT 1
102501: ARRAY
102502: LESS
102503: IFFALSE 102523
// tmp := mc_crates_collector [ i ] else
102505: LD_ADDR_VAR 0 5
102509: PUSH
102510: LD_EXP 178
102514: PUSH
102515: LD_VAR 0 2
102519: ARRAY
102520: ST_TO_ADDR
102521: GO 102537
// tmp := target [ 1 ] ;
102523: LD_ADDR_VAR 0 5
102527: PUSH
102528: LD_VAR 0 7
102532: PUSH
102533: LD_INT 1
102535: ARRAY
102536: ST_TO_ADDR
// k := 0 ;
102537: LD_ADDR_VAR 0 4
102541: PUSH
102542: LD_INT 0
102544: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
102545: LD_ADDR_VAR 0 3
102549: PUSH
102550: LD_EXP 178
102554: PUSH
102555: LD_VAR 0 2
102559: ARRAY
102560: PUSH
102561: FOR_IN
102562: IFFALSE 102785
// begin k := k + 1 ;
102564: LD_ADDR_VAR 0 4
102568: PUSH
102569: LD_VAR 0 4
102573: PUSH
102574: LD_INT 1
102576: PLUS
102577: ST_TO_ADDR
// if k > tmp then
102578: LD_VAR 0 4
102582: PUSH
102583: LD_VAR 0 5
102587: GREATER
102588: IFFALSE 102592
// break ;
102590: GO 102785
// if not GetClass ( j ) in [ 2 , 16 ] then
102592: LD_VAR 0 3
102596: PPUSH
102597: CALL_OW 257
102601: PUSH
102602: LD_INT 2
102604: PUSH
102605: LD_INT 16
102607: PUSH
102608: EMPTY
102609: LIST
102610: LIST
102611: IN
102612: NOT
102613: IFFALSE 102666
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
102615: LD_ADDR_EXP 178
102619: PUSH
102620: LD_EXP 178
102624: PPUSH
102625: LD_VAR 0 2
102629: PPUSH
102630: LD_EXP 178
102634: PUSH
102635: LD_VAR 0 2
102639: ARRAY
102640: PUSH
102641: LD_VAR 0 3
102645: DIFF
102646: PPUSH
102647: CALL_OW 1
102651: ST_TO_ADDR
// SetTag ( j , 0 ) ;
102652: LD_VAR 0 3
102656: PPUSH
102657: LD_INT 0
102659: PPUSH
102660: CALL_OW 109
// continue ;
102664: GO 102561
// end ; if IsInUnit ( j ) then
102666: LD_VAR 0 3
102670: PPUSH
102671: CALL_OW 310
102675: IFFALSE 102686
// ComExitBuilding ( j ) ;
102677: LD_VAR 0 3
102681: PPUSH
102682: CALL_OW 122
// wait ( 3 ) ;
102686: LD_INT 3
102688: PPUSH
102689: CALL_OW 67
// if HasTask ( j ) and DangerAtRangeXY ( side , target [ 2 ] , target [ 3 ] , 30 ) [ 4 ] then
102693: LD_VAR 0 3
102697: PPUSH
102698: CALL_OW 314
102702: PUSH
102703: LD_VAR 0 6
102707: PPUSH
102708: LD_VAR 0 7
102712: PUSH
102713: LD_INT 2
102715: ARRAY
102716: PPUSH
102717: LD_VAR 0 7
102721: PUSH
102722: LD_INT 3
102724: ARRAY
102725: PPUSH
102726: LD_INT 30
102728: PPUSH
102729: CALL 25257 0 4
102733: PUSH
102734: LD_INT 4
102736: ARRAY
102737: AND
102738: IFFALSE 102756
// ComStandNearbyBuilding ( j , depot ) else
102740: LD_VAR 0 3
102744: PPUSH
102745: LD_VAR 0 9
102749: PPUSH
102750: CALL 20788 0 2
102754: GO 102783
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
102756: LD_VAR 0 3
102760: PPUSH
102761: LD_VAR 0 7
102765: PUSH
102766: LD_INT 2
102768: ARRAY
102769: PPUSH
102770: LD_VAR 0 7
102774: PUSH
102775: LD_INT 3
102777: ARRAY
102778: PPUSH
102779: CALL_OW 117
// end ;
102783: GO 102561
102785: POP
102786: POP
// end ; end else
102787: GO 103319
// begin for j in cargo do
102789: LD_ADDR_VAR 0 3
102793: PUSH
102794: LD_VAR 0 8
102798: PUSH
102799: FOR_IN
102800: IFFALSE 103317
// begin if GetTag ( j ) <> 0 then
102802: LD_VAR 0 3
102806: PPUSH
102807: CALL_OW 110
102811: PUSH
102812: LD_INT 0
102814: NONEQUAL
102815: IFFALSE 102819
// continue ;
102817: GO 102799
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
102819: LD_VAR 0 3
102823: PPUSH
102824: CALL_OW 256
102828: PUSH
102829: LD_INT 1000
102831: LESS
102832: PUSH
102833: LD_VAR 0 3
102837: PPUSH
102838: LD_EXP 185
102842: PUSH
102843: LD_VAR 0 2
102847: ARRAY
102848: PPUSH
102849: CALL_OW 308
102853: NOT
102854: AND
102855: IFFALSE 102877
// ComMoveToArea ( j , mc_parking [ i ] ) ;
102857: LD_VAR 0 3
102861: PPUSH
102862: LD_EXP 185
102866: PUSH
102867: LD_VAR 0 2
102871: ARRAY
102872: PPUSH
102873: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
102877: LD_VAR 0 3
102881: PPUSH
102882: CALL_OW 256
102886: PUSH
102887: LD_INT 1000
102889: LESS
102890: PUSH
102891: LD_VAR 0 3
102895: PPUSH
102896: LD_EXP 185
102900: PUSH
102901: LD_VAR 0 2
102905: ARRAY
102906: PPUSH
102907: CALL_OW 308
102911: AND
102912: IFFALSE 102916
// continue ;
102914: GO 102799
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
102916: LD_VAR 0 3
102920: PPUSH
102921: CALL_OW 262
102925: PUSH
102926: LD_INT 2
102928: EQUAL
102929: PUSH
102930: LD_VAR 0 3
102934: PPUSH
102935: CALL_OW 261
102939: PUSH
102940: LD_INT 15
102942: LESS
102943: AND
102944: IFFALSE 102948
// continue ;
102946: GO 102799
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
102948: LD_VAR 0 3
102952: PPUSH
102953: CALL_OW 262
102957: PUSH
102958: LD_INT 1
102960: EQUAL
102961: PUSH
102962: LD_VAR 0 3
102966: PPUSH
102967: CALL_OW 261
102971: PUSH
102972: LD_INT 10
102974: LESS
102975: AND
102976: IFFALSE 103256
// begin if not depot then
102978: LD_VAR 0 9
102982: NOT
102983: IFFALSE 102987
// continue ;
102985: GO 102799
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
102987: LD_VAR 0 3
102991: PPUSH
102992: LD_VAR 0 9
102996: PPUSH
102997: LD_VAR 0 3
103001: PPUSH
103002: CALL_OW 74
103006: PPUSH
103007: CALL_OW 296
103011: PUSH
103012: LD_INT 6
103014: LESS
103015: IFFALSE 103031
// SetFuel ( j , 100 ) else
103017: LD_VAR 0 3
103021: PPUSH
103022: LD_INT 100
103024: PPUSH
103025: CALL_OW 240
103029: GO 103256
// if GetFuel ( j ) = 0 then
103031: LD_VAR 0 3
103035: PPUSH
103036: CALL_OW 261
103040: PUSH
103041: LD_INT 0
103043: EQUAL
103044: IFFALSE 103256
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
103046: LD_ADDR_EXP 180
103050: PUSH
103051: LD_EXP 180
103055: PPUSH
103056: LD_VAR 0 2
103060: PPUSH
103061: LD_EXP 180
103065: PUSH
103066: LD_VAR 0 2
103070: ARRAY
103071: PUSH
103072: LD_VAR 0 3
103076: DIFF
103077: PPUSH
103078: CALL_OW 1
103082: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
103083: LD_VAR 0 3
103087: PPUSH
103088: CALL_OW 263
103092: PUSH
103093: LD_INT 1
103095: EQUAL
103096: IFFALSE 103112
// ComExitVehicle ( IsInUnit ( j ) ) ;
103098: LD_VAR 0 3
103102: PPUSH
103103: CALL_OW 310
103107: PPUSH
103108: CALL_OW 121
// if GetControl ( j ) = control_remote then
103112: LD_VAR 0 3
103116: PPUSH
103117: CALL_OW 263
103121: PUSH
103122: LD_INT 2
103124: EQUAL
103125: IFFALSE 103136
// ComUnlink ( j ) ;
103127: LD_VAR 0 3
103131: PPUSH
103132: CALL_OW 136
// fac := MC_GetBuildings ( i , b_factory ) ;
103136: LD_ADDR_VAR 0 10
103140: PUSH
103141: LD_VAR 0 2
103145: PPUSH
103146: LD_INT 3
103148: PPUSH
103149: CALL 112923 0 2
103153: ST_TO_ADDR
// if fac then
103154: LD_VAR 0 10
103158: IFFALSE 103254
// begin for k in fac do
103160: LD_ADDR_VAR 0 4
103164: PUSH
103165: LD_VAR 0 10
103169: PUSH
103170: FOR_IN
103171: IFFALSE 103252
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
103173: LD_ADDR_VAR 0 11
103177: PUSH
103178: LD_VAR 0 10
103182: PPUSH
103183: LD_VAR 0 3
103187: PPUSH
103188: CALL_OW 265
103192: PPUSH
103193: LD_VAR 0 3
103197: PPUSH
103198: CALL_OW 262
103202: PPUSH
103203: LD_VAR 0 3
103207: PPUSH
103208: CALL_OW 263
103212: PPUSH
103213: LD_VAR 0 3
103217: PPUSH
103218: CALL_OW 264
103222: PPUSH
103223: CALL 21859 0 5
103227: ST_TO_ADDR
// if components then
103228: LD_VAR 0 11
103232: IFFALSE 103250
// begin MC_InsertProduceList ( i , components ) ;
103234: LD_VAR 0 2
103238: PPUSH
103239: LD_VAR 0 11
103243: PPUSH
103244: CALL 112468 0 2
// break ;
103248: GO 103252
// end ; end ;
103250: GO 103170
103252: POP
103253: POP
// end ; continue ;
103254: GO 102799
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
103256: LD_VAR 0 3
103260: PPUSH
103261: LD_INT 1
103263: PPUSH
103264: CALL_OW 289
103268: PUSH
103269: LD_INT 100
103271: LESS
103272: PUSH
103273: LD_VAR 0 3
103277: PPUSH
103278: CALL_OW 314
103282: NOT
103283: AND
103284: IFFALSE 103313
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
103286: LD_VAR 0 3
103290: PPUSH
103291: LD_VAR 0 7
103295: PUSH
103296: LD_INT 2
103298: ARRAY
103299: PPUSH
103300: LD_VAR 0 7
103304: PUSH
103305: LD_INT 3
103307: ARRAY
103308: PPUSH
103309: CALL_OW 117
// break ;
103313: GO 103317
// end ;
103315: GO 102799
103317: POP
103318: POP
// end ; end ;
103319: GO 101515
103321: POP
103322: POP
// end ;
103323: LD_VAR 0 1
103327: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
103328: LD_INT 0
103330: PPUSH
103331: PPUSH
103332: PPUSH
103333: PPUSH
// if not mc_bases then
103334: LD_EXP 161
103338: NOT
103339: IFFALSE 103343
// exit ;
103341: GO 103504
// for i = 1 to mc_bases do
103343: LD_ADDR_VAR 0 2
103347: PUSH
103348: DOUBLE
103349: LD_INT 1
103351: DEC
103352: ST_TO_ADDR
103353: LD_EXP 161
103357: PUSH
103358: FOR_TO
103359: IFFALSE 103502
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
103361: LD_ADDR_VAR 0 4
103365: PUSH
103366: LD_EXP 180
103370: PUSH
103371: LD_VAR 0 2
103375: ARRAY
103376: PUSH
103377: LD_EXP 183
103381: PUSH
103382: LD_VAR 0 2
103386: ARRAY
103387: UNION
103388: PPUSH
103389: LD_INT 33
103391: PUSH
103392: LD_INT 2
103394: PUSH
103395: EMPTY
103396: LIST
103397: LIST
103398: PPUSH
103399: CALL_OW 72
103403: ST_TO_ADDR
// if tmp then
103404: LD_VAR 0 4
103408: IFFALSE 103500
// for j in tmp do
103410: LD_ADDR_VAR 0 3
103414: PUSH
103415: LD_VAR 0 4
103419: PUSH
103420: FOR_IN
103421: IFFALSE 103498
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
103423: LD_VAR 0 3
103427: PPUSH
103428: CALL_OW 312
103432: NOT
103433: PUSH
103434: LD_VAR 0 3
103438: PPUSH
103439: CALL_OW 256
103443: PUSH
103444: LD_INT 250
103446: GREATEREQUAL
103447: AND
103448: IFFALSE 103461
// Connect ( j ) else
103450: LD_VAR 0 3
103454: PPUSH
103455: CALL 27330 0 1
103459: GO 103496
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
103461: LD_VAR 0 3
103465: PPUSH
103466: CALL_OW 256
103470: PUSH
103471: LD_INT 250
103473: LESS
103474: PUSH
103475: LD_VAR 0 3
103479: PPUSH
103480: CALL_OW 312
103484: AND
103485: IFFALSE 103496
// ComUnlink ( j ) ;
103487: LD_VAR 0 3
103491: PPUSH
103492: CALL_OW 136
103496: GO 103420
103498: POP
103499: POP
// end ;
103500: GO 103358
103502: POP
103503: POP
// end ;
103504: LD_VAR 0 1
103508: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
103509: LD_INT 0
103511: PPUSH
103512: PPUSH
103513: PPUSH
103514: PPUSH
103515: PPUSH
// if not mc_bases then
103516: LD_EXP 161
103520: NOT
103521: IFFALSE 103525
// exit ;
103523: GO 103970
// for i = 1 to mc_bases do
103525: LD_ADDR_VAR 0 2
103529: PUSH
103530: DOUBLE
103531: LD_INT 1
103533: DEC
103534: ST_TO_ADDR
103535: LD_EXP 161
103539: PUSH
103540: FOR_TO
103541: IFFALSE 103968
// begin if not mc_produce [ i ] then
103543: LD_EXP 182
103547: PUSH
103548: LD_VAR 0 2
103552: ARRAY
103553: NOT
103554: IFFALSE 103558
// continue ;
103556: GO 103540
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
103558: LD_ADDR_VAR 0 5
103562: PUSH
103563: LD_EXP 161
103567: PUSH
103568: LD_VAR 0 2
103572: ARRAY
103573: PPUSH
103574: LD_INT 30
103576: PUSH
103577: LD_INT 3
103579: PUSH
103580: EMPTY
103581: LIST
103582: LIST
103583: PPUSH
103584: CALL_OW 72
103588: ST_TO_ADDR
// if not fac then
103589: LD_VAR 0 5
103593: NOT
103594: IFFALSE 103598
// continue ;
103596: GO 103540
// for j in fac do
103598: LD_ADDR_VAR 0 3
103602: PUSH
103603: LD_VAR 0 5
103607: PUSH
103608: FOR_IN
103609: IFFALSE 103964
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
103611: LD_VAR 0 3
103615: PPUSH
103616: CALL_OW 461
103620: PUSH
103621: LD_INT 2
103623: NONEQUAL
103624: PUSH
103625: LD_VAR 0 3
103629: PPUSH
103630: LD_INT 15
103632: PPUSH
103633: CALL 26958 0 2
103637: PUSH
103638: LD_INT 4
103640: ARRAY
103641: OR
103642: IFFALSE 103646
// continue ;
103644: GO 103608
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
103646: LD_VAR 0 3
103650: PPUSH
103651: LD_EXP 182
103655: PUSH
103656: LD_VAR 0 2
103660: ARRAY
103661: PUSH
103662: LD_INT 1
103664: ARRAY
103665: PUSH
103666: LD_INT 1
103668: ARRAY
103669: PPUSH
103670: LD_EXP 182
103674: PUSH
103675: LD_VAR 0 2
103679: ARRAY
103680: PUSH
103681: LD_INT 1
103683: ARRAY
103684: PUSH
103685: LD_INT 2
103687: ARRAY
103688: PPUSH
103689: LD_EXP 182
103693: PUSH
103694: LD_VAR 0 2
103698: ARRAY
103699: PUSH
103700: LD_INT 1
103702: ARRAY
103703: PUSH
103704: LD_INT 3
103706: ARRAY
103707: PPUSH
103708: LD_EXP 182
103712: PUSH
103713: LD_VAR 0 2
103717: ARRAY
103718: PUSH
103719: LD_INT 1
103721: ARRAY
103722: PUSH
103723: LD_INT 4
103725: ARRAY
103726: PPUSH
103727: CALL_OW 448
103731: PUSH
103732: LD_VAR 0 3
103736: PPUSH
103737: LD_EXP 182
103741: PUSH
103742: LD_VAR 0 2
103746: ARRAY
103747: PUSH
103748: LD_INT 1
103750: ARRAY
103751: PUSH
103752: LD_INT 1
103754: ARRAY
103755: PUSH
103756: LD_EXP 182
103760: PUSH
103761: LD_VAR 0 2
103765: ARRAY
103766: PUSH
103767: LD_INT 1
103769: ARRAY
103770: PUSH
103771: LD_INT 2
103773: ARRAY
103774: PUSH
103775: LD_EXP 182
103779: PUSH
103780: LD_VAR 0 2
103784: ARRAY
103785: PUSH
103786: LD_INT 1
103788: ARRAY
103789: PUSH
103790: LD_INT 3
103792: ARRAY
103793: PUSH
103794: LD_EXP 182
103798: PUSH
103799: LD_VAR 0 2
103803: ARRAY
103804: PUSH
103805: LD_INT 1
103807: ARRAY
103808: PUSH
103809: LD_INT 4
103811: ARRAY
103812: PUSH
103813: EMPTY
103814: LIST
103815: LIST
103816: LIST
103817: LIST
103818: PPUSH
103819: CALL 30725 0 2
103823: AND
103824: IFFALSE 103962
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
103826: LD_VAR 0 3
103830: PPUSH
103831: LD_EXP 182
103835: PUSH
103836: LD_VAR 0 2
103840: ARRAY
103841: PUSH
103842: LD_INT 1
103844: ARRAY
103845: PUSH
103846: LD_INT 1
103848: ARRAY
103849: PPUSH
103850: LD_EXP 182
103854: PUSH
103855: LD_VAR 0 2
103859: ARRAY
103860: PUSH
103861: LD_INT 1
103863: ARRAY
103864: PUSH
103865: LD_INT 2
103867: ARRAY
103868: PPUSH
103869: LD_EXP 182
103873: PUSH
103874: LD_VAR 0 2
103878: ARRAY
103879: PUSH
103880: LD_INT 1
103882: ARRAY
103883: PUSH
103884: LD_INT 3
103886: ARRAY
103887: PPUSH
103888: LD_EXP 182
103892: PUSH
103893: LD_VAR 0 2
103897: ARRAY
103898: PUSH
103899: LD_INT 1
103901: ARRAY
103902: PUSH
103903: LD_INT 4
103905: ARRAY
103906: PPUSH
103907: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
103911: LD_ADDR_VAR 0 4
103915: PUSH
103916: LD_EXP 182
103920: PUSH
103921: LD_VAR 0 2
103925: ARRAY
103926: PPUSH
103927: LD_INT 1
103929: PPUSH
103930: CALL_OW 3
103934: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
103935: LD_ADDR_EXP 182
103939: PUSH
103940: LD_EXP 182
103944: PPUSH
103945: LD_VAR 0 2
103949: PPUSH
103950: LD_VAR 0 4
103954: PPUSH
103955: CALL_OW 1
103959: ST_TO_ADDR
// break ;
103960: GO 103964
// end ; end ;
103962: GO 103608
103964: POP
103965: POP
// end ;
103966: GO 103540
103968: POP
103969: POP
// end ;
103970: LD_VAR 0 1
103974: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
103975: LD_INT 0
103977: PPUSH
103978: PPUSH
103979: PPUSH
// if not mc_bases then
103980: LD_EXP 161
103984: NOT
103985: IFFALSE 103989
// exit ;
103987: GO 104078
// for i = 1 to mc_bases do
103989: LD_ADDR_VAR 0 2
103993: PUSH
103994: DOUBLE
103995: LD_INT 1
103997: DEC
103998: ST_TO_ADDR
103999: LD_EXP 161
104003: PUSH
104004: FOR_TO
104005: IFFALSE 104076
// begin if mc_attack [ i ] then
104007: LD_EXP 181
104011: PUSH
104012: LD_VAR 0 2
104016: ARRAY
104017: IFFALSE 104074
// begin tmp := mc_attack [ i ] [ 1 ] ;
104019: LD_ADDR_VAR 0 3
104023: PUSH
104024: LD_EXP 181
104028: PUSH
104029: LD_VAR 0 2
104033: ARRAY
104034: PUSH
104035: LD_INT 1
104037: ARRAY
104038: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
104039: LD_ADDR_EXP 181
104043: PUSH
104044: LD_EXP 181
104048: PPUSH
104049: LD_VAR 0 2
104053: PPUSH
104054: EMPTY
104055: PPUSH
104056: CALL_OW 1
104060: ST_TO_ADDR
// Attack ( tmp ) ;
104061: LD_VAR 0 3
104065: PPUSH
104066: CALL 80891 0 1
// exit ;
104070: POP
104071: POP
104072: GO 104078
// end ; end ;
104074: GO 104004
104076: POP
104077: POP
// end ;
104078: LD_VAR 0 1
104082: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
104083: LD_INT 0
104085: PPUSH
104086: PPUSH
104087: PPUSH
104088: PPUSH
104089: PPUSH
104090: PPUSH
104091: PPUSH
// if not mc_bases then
104092: LD_EXP 161
104096: NOT
104097: IFFALSE 104101
// exit ;
104099: GO 104958
// for i = 1 to mc_bases do
104101: LD_ADDR_VAR 0 2
104105: PUSH
104106: DOUBLE
104107: LD_INT 1
104109: DEC
104110: ST_TO_ADDR
104111: LD_EXP 161
104115: PUSH
104116: FOR_TO
104117: IFFALSE 104956
// begin if not mc_bases [ i ] then
104119: LD_EXP 161
104123: PUSH
104124: LD_VAR 0 2
104128: ARRAY
104129: NOT
104130: IFFALSE 104134
// continue ;
104132: GO 104116
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
104134: LD_ADDR_VAR 0 7
104138: PUSH
104139: LD_EXP 161
104143: PUSH
104144: LD_VAR 0 2
104148: ARRAY
104149: PUSH
104150: LD_INT 1
104152: ARRAY
104153: PPUSH
104154: CALL 21010 0 1
104158: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
104159: LD_ADDR_EXP 184
104163: PUSH
104164: LD_EXP 184
104168: PPUSH
104169: LD_VAR 0 2
104173: PPUSH
104174: LD_EXP 161
104178: PUSH
104179: LD_VAR 0 2
104183: ARRAY
104184: PUSH
104185: LD_INT 1
104187: ARRAY
104188: PPUSH
104189: CALL_OW 255
104193: PPUSH
104194: LD_EXP 186
104198: PUSH
104199: LD_VAR 0 2
104203: ARRAY
104204: PPUSH
104205: CALL 20975 0 2
104209: PPUSH
104210: CALL_OW 1
104214: ST_TO_ADDR
// if not mc_scan [ i ] then
104215: LD_EXP 184
104219: PUSH
104220: LD_VAR 0 2
104224: ARRAY
104225: NOT
104226: IFFALSE 104404
// begin mc_is_defending := Replace ( mc_is_defending , i , false ) ;
104228: LD_ADDR_EXP 204
104232: PUSH
104233: LD_EXP 204
104237: PPUSH
104238: LD_VAR 0 2
104242: PPUSH
104243: LD_INT 0
104245: PPUSH
104246: CALL_OW 1
104250: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
104251: LD_ADDR_VAR 0 4
104255: PUSH
104256: LD_EXP 161
104260: PUSH
104261: LD_VAR 0 2
104265: ARRAY
104266: PPUSH
104267: LD_INT 2
104269: PUSH
104270: LD_INT 25
104272: PUSH
104273: LD_INT 5
104275: PUSH
104276: EMPTY
104277: LIST
104278: LIST
104279: PUSH
104280: LD_INT 25
104282: PUSH
104283: LD_INT 8
104285: PUSH
104286: EMPTY
104287: LIST
104288: LIST
104289: PUSH
104290: LD_INT 25
104292: PUSH
104293: LD_INT 9
104295: PUSH
104296: EMPTY
104297: LIST
104298: LIST
104299: PUSH
104300: EMPTY
104301: LIST
104302: LIST
104303: LIST
104304: LIST
104305: PPUSH
104306: CALL_OW 72
104310: ST_TO_ADDR
// if not tmp then
104311: LD_VAR 0 4
104315: NOT
104316: IFFALSE 104320
// continue ;
104318: GO 104116
// for j in tmp do
104320: LD_ADDR_VAR 0 3
104324: PUSH
104325: LD_VAR 0 4
104329: PUSH
104330: FOR_IN
104331: IFFALSE 104402
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
104333: LD_VAR 0 3
104337: PPUSH
104338: CALL_OW 310
104342: PPUSH
104343: CALL_OW 266
104347: PUSH
104348: LD_INT 5
104350: EQUAL
104351: PUSH
104352: LD_VAR 0 3
104356: PPUSH
104357: CALL_OW 257
104361: PUSH
104362: LD_INT 1
104364: EQUAL
104365: AND
104366: PUSH
104367: LD_VAR 0 3
104371: PPUSH
104372: CALL_OW 459
104376: NOT
104377: AND
104378: PUSH
104379: LD_VAR 0 7
104383: AND
104384: IFFALSE 104400
// ComChangeProfession ( j , class ) ;
104386: LD_VAR 0 3
104390: PPUSH
104391: LD_VAR 0 7
104395: PPUSH
104396: CALL_OW 123
104400: GO 104330
104402: POP
104403: POP
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and not mc_defender [ i ] and ( UnitFilter ( mc_bases [ i ] , [ [ f_ok ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) < 4 or UnitFilter ( mc_bases [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ) then
104404: LD_EXP 184
104408: PUSH
104409: LD_VAR 0 2
104413: ARRAY
104414: PUSH
104415: LD_EXP 204
104419: PUSH
104420: LD_VAR 0 2
104424: ARRAY
104425: NOT
104426: AND
104427: PUSH
104428: LD_EXP 183
104432: PUSH
104433: LD_VAR 0 2
104437: ARRAY
104438: NOT
104439: AND
104440: PUSH
104441: LD_EXP 161
104445: PUSH
104446: LD_VAR 0 2
104450: ARRAY
104451: PPUSH
104452: LD_INT 50
104454: PUSH
104455: EMPTY
104456: LIST
104457: PUSH
104458: LD_INT 2
104460: PUSH
104461: LD_INT 30
104463: PUSH
104464: LD_INT 32
104466: PUSH
104467: EMPTY
104468: LIST
104469: LIST
104470: PUSH
104471: LD_INT 30
104473: PUSH
104474: LD_INT 33
104476: PUSH
104477: EMPTY
104478: LIST
104479: LIST
104480: PUSH
104481: LD_INT 30
104483: PUSH
104484: LD_INT 4
104486: PUSH
104487: EMPTY
104488: LIST
104489: LIST
104490: PUSH
104491: LD_INT 30
104493: PUSH
104494: LD_INT 5
104496: PUSH
104497: EMPTY
104498: LIST
104499: LIST
104500: PUSH
104501: EMPTY
104502: LIST
104503: LIST
104504: LIST
104505: LIST
104506: LIST
104507: PUSH
104508: EMPTY
104509: LIST
104510: LIST
104511: PPUSH
104512: CALL_OW 72
104516: PUSH
104517: LD_INT 4
104519: LESS
104520: PUSH
104521: LD_EXP 161
104525: PUSH
104526: LD_VAR 0 2
104530: ARRAY
104531: PPUSH
104532: LD_INT 3
104534: PUSH
104535: LD_INT 24
104537: PUSH
104538: LD_INT 1000
104540: PUSH
104541: EMPTY
104542: LIST
104543: LIST
104544: PUSH
104545: EMPTY
104546: LIST
104547: LIST
104548: PUSH
104549: LD_INT 2
104551: PUSH
104552: LD_INT 30
104554: PUSH
104555: LD_INT 0
104557: PUSH
104558: EMPTY
104559: LIST
104560: LIST
104561: PUSH
104562: LD_INT 30
104564: PUSH
104565: LD_INT 1
104567: PUSH
104568: EMPTY
104569: LIST
104570: LIST
104571: PUSH
104572: EMPTY
104573: LIST
104574: LIST
104575: LIST
104576: PUSH
104577: EMPTY
104578: LIST
104579: LIST
104580: PPUSH
104581: CALL_OW 72
104585: OR
104586: AND
104587: IFFALSE 104838
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
104589: LD_ADDR_EXP 204
104593: PUSH
104594: LD_EXP 204
104598: PPUSH
104599: LD_VAR 0 2
104603: PPUSH
104604: LD_INT 1
104606: PPUSH
104607: CALL_OW 1
104611: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
104612: LD_ADDR_VAR 0 4
104616: PUSH
104617: LD_EXP 161
104621: PUSH
104622: LD_VAR 0 2
104626: ARRAY
104627: PPUSH
104628: LD_INT 2
104630: PUSH
104631: LD_INT 25
104633: PUSH
104634: LD_INT 1
104636: PUSH
104637: EMPTY
104638: LIST
104639: LIST
104640: PUSH
104641: LD_INT 25
104643: PUSH
104644: LD_INT 5
104646: PUSH
104647: EMPTY
104648: LIST
104649: LIST
104650: PUSH
104651: LD_INT 25
104653: PUSH
104654: LD_INT 8
104656: PUSH
104657: EMPTY
104658: LIST
104659: LIST
104660: PUSH
104661: LD_INT 25
104663: PUSH
104664: LD_INT 9
104666: PUSH
104667: EMPTY
104668: LIST
104669: LIST
104670: PUSH
104671: EMPTY
104672: LIST
104673: LIST
104674: LIST
104675: LIST
104676: LIST
104677: PPUSH
104678: CALL_OW 72
104682: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
104683: LD_ADDR_VAR 0 4
104687: PUSH
104688: LD_VAR 0 4
104692: PUSH
104693: LD_VAR 0 4
104697: PPUSH
104698: LD_INT 18
104700: PPUSH
104701: CALL 54273 0 2
104705: DIFF
104706: ST_TO_ADDR
// if not tmp and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
104707: LD_VAR 0 4
104711: NOT
104712: PUSH
104713: LD_EXP 161
104717: PUSH
104718: LD_VAR 0 2
104722: ARRAY
104723: PPUSH
104724: LD_INT 2
104726: PUSH
104727: LD_INT 30
104729: PUSH
104730: LD_INT 4
104732: PUSH
104733: EMPTY
104734: LIST
104735: LIST
104736: PUSH
104737: LD_INT 30
104739: PUSH
104740: LD_INT 5
104742: PUSH
104743: EMPTY
104744: LIST
104745: LIST
104746: PUSH
104747: EMPTY
104748: LIST
104749: LIST
104750: LIST
104751: PPUSH
104752: CALL_OW 72
104756: NOT
104757: AND
104758: IFFALSE 104820
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ) ;
104760: LD_ADDR_VAR 0 4
104764: PUSH
104765: LD_EXP 161
104769: PUSH
104770: LD_VAR 0 2
104774: ARRAY
104775: PPUSH
104776: LD_INT 2
104778: PUSH
104779: LD_INT 25
104781: PUSH
104782: LD_INT 2
104784: PUSH
104785: EMPTY
104786: LIST
104787: LIST
104788: PUSH
104789: LD_INT 25
104791: PUSH
104792: LD_INT 3
104794: PUSH
104795: EMPTY
104796: LIST
104797: LIST
104798: PUSH
104799: LD_INT 25
104801: PUSH
104802: LD_INT 4
104804: PUSH
104805: EMPTY
104806: LIST
104807: LIST
104808: PUSH
104809: EMPTY
104810: LIST
104811: LIST
104812: LIST
104813: LIST
104814: PPUSH
104815: CALL_OW 72
104819: ST_TO_ADDR
// BasicDefend ( i , tmp ) ;
104820: LD_VAR 0 2
104824: PPUSH
104825: LD_VAR 0 4
104829: PPUSH
104830: CALL 85600 0 2
// exit ;
104834: POP
104835: POP
104836: GO 104958
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and mc_defender [ i ] then
104838: LD_EXP 184
104842: PUSH
104843: LD_VAR 0 2
104847: ARRAY
104848: PUSH
104849: LD_EXP 204
104853: PUSH
104854: LD_VAR 0 2
104858: ARRAY
104859: NOT
104860: AND
104861: PUSH
104862: LD_EXP 183
104866: PUSH
104867: LD_VAR 0 2
104871: ARRAY
104872: AND
104873: IFFALSE 104954
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
104875: LD_ADDR_EXP 204
104879: PUSH
104880: LD_EXP 204
104884: PPUSH
104885: LD_VAR 0 2
104889: PPUSH
104890: LD_INT 1
104892: PPUSH
104893: CALL_OW 1
104897: ST_TO_ADDR
// tmp := mc_defender [ i ] ;
104898: LD_ADDR_VAR 0 4
104902: PUSH
104903: LD_EXP 183
104907: PUSH
104908: LD_VAR 0 2
104912: ARRAY
104913: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
104914: LD_ADDR_EXP 183
104918: PUSH
104919: LD_EXP 183
104923: PPUSH
104924: LD_VAR 0 2
104928: PPUSH
104929: EMPTY
104930: PPUSH
104931: CALL_OW 1
104935: ST_TO_ADDR
// Defend ( i , tmp ) ;
104936: LD_VAR 0 2
104940: PPUSH
104941: LD_VAR 0 4
104945: PPUSH
104946: CALL 86196 0 2
// exit ;
104950: POP
104951: POP
104952: GO 104958
// end ; end ;
104954: GO 104116
104956: POP
104957: POP
// end ;
104958: LD_VAR 0 1
104962: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
104963: LD_INT 0
104965: PPUSH
104966: PPUSH
104967: PPUSH
104968: PPUSH
104969: PPUSH
104970: PPUSH
104971: PPUSH
104972: PPUSH
104973: PPUSH
104974: PPUSH
104975: PPUSH
// if not mc_bases then
104976: LD_EXP 161
104980: NOT
104981: IFFALSE 104985
// exit ;
104983: GO 106072
// for i = 1 to mc_bases do
104985: LD_ADDR_VAR 0 2
104989: PUSH
104990: DOUBLE
104991: LD_INT 1
104993: DEC
104994: ST_TO_ADDR
104995: LD_EXP 161
104999: PUSH
105000: FOR_TO
105001: IFFALSE 106070
// begin tmp := mc_lab [ i ] ;
105003: LD_ADDR_VAR 0 6
105007: PUSH
105008: LD_EXP 194
105012: PUSH
105013: LD_VAR 0 2
105017: ARRAY
105018: ST_TO_ADDR
// if not tmp then
105019: LD_VAR 0 6
105023: NOT
105024: IFFALSE 105028
// continue ;
105026: GO 105000
// idle_lab := 0 ;
105028: LD_ADDR_VAR 0 11
105032: PUSH
105033: LD_INT 0
105035: ST_TO_ADDR
// for j in tmp do
105036: LD_ADDR_VAR 0 3
105040: PUSH
105041: LD_VAR 0 6
105045: PUSH
105046: FOR_IN
105047: IFFALSE 106066
// begin researching := false ;
105049: LD_ADDR_VAR 0 10
105053: PUSH
105054: LD_INT 0
105056: ST_TO_ADDR
// side := GetSide ( j ) ;
105057: LD_ADDR_VAR 0 4
105061: PUSH
105062: LD_VAR 0 3
105066: PPUSH
105067: CALL_OW 255
105071: ST_TO_ADDR
// if not mc_tech [ side ] then
105072: LD_EXP 188
105076: PUSH
105077: LD_VAR 0 4
105081: ARRAY
105082: NOT
105083: IFFALSE 105087
// continue ;
105085: GO 105046
// if BuildingStatus ( j ) = bs_idle then
105087: LD_VAR 0 3
105091: PPUSH
105092: CALL_OW 461
105096: PUSH
105097: LD_INT 2
105099: EQUAL
105100: IFFALSE 105288
// begin if idle_lab and UnitsInside ( j ) < 6 then
105102: LD_VAR 0 11
105106: PUSH
105107: LD_VAR 0 3
105111: PPUSH
105112: CALL_OW 313
105116: PUSH
105117: LD_INT 6
105119: LESS
105120: AND
105121: IFFALSE 105192
// begin tmp2 := UnitsInside ( idle_lab ) ;
105123: LD_ADDR_VAR 0 9
105127: PUSH
105128: LD_VAR 0 11
105132: PPUSH
105133: CALL_OW 313
105137: ST_TO_ADDR
// if tmp2 then
105138: LD_VAR 0 9
105142: IFFALSE 105184
// for x in tmp2 do
105144: LD_ADDR_VAR 0 7
105148: PUSH
105149: LD_VAR 0 9
105153: PUSH
105154: FOR_IN
105155: IFFALSE 105182
// begin ComExitBuilding ( x ) ;
105157: LD_VAR 0 7
105161: PPUSH
105162: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
105166: LD_VAR 0 7
105170: PPUSH
105171: LD_VAR 0 3
105175: PPUSH
105176: CALL_OW 180
// end ;
105180: GO 105154
105182: POP
105183: POP
// idle_lab := 0 ;
105184: LD_ADDR_VAR 0 11
105188: PUSH
105189: LD_INT 0
105191: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
105192: LD_ADDR_VAR 0 5
105196: PUSH
105197: LD_EXP 188
105201: PUSH
105202: LD_VAR 0 4
105206: ARRAY
105207: PUSH
105208: FOR_IN
105209: IFFALSE 105269
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
105211: LD_VAR 0 3
105215: PPUSH
105216: LD_VAR 0 5
105220: PPUSH
105221: CALL_OW 430
105225: PUSH
105226: LD_VAR 0 4
105230: PPUSH
105231: LD_VAR 0 5
105235: PPUSH
105236: CALL 20080 0 2
105240: AND
105241: IFFALSE 105267
// begin researching := true ;
105243: LD_ADDR_VAR 0 10
105247: PUSH
105248: LD_INT 1
105250: ST_TO_ADDR
// ComResearch ( j , t ) ;
105251: LD_VAR 0 3
105255: PPUSH
105256: LD_VAR 0 5
105260: PPUSH
105261: CALL_OW 124
// break ;
105265: GO 105269
// end ;
105267: GO 105208
105269: POP
105270: POP
// if not researching then
105271: LD_VAR 0 10
105275: NOT
105276: IFFALSE 105288
// idle_lab := j ;
105278: LD_ADDR_VAR 0 11
105282: PUSH
105283: LD_VAR 0 3
105287: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
105288: LD_VAR 0 3
105292: PPUSH
105293: CALL_OW 461
105297: PUSH
105298: LD_INT 10
105300: EQUAL
105301: IFFALSE 105889
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
105303: LD_EXP 190
105307: PUSH
105308: LD_VAR 0 2
105312: ARRAY
105313: NOT
105314: PUSH
105315: LD_EXP 191
105319: PUSH
105320: LD_VAR 0 2
105324: ARRAY
105325: NOT
105326: AND
105327: PUSH
105328: LD_EXP 188
105332: PUSH
105333: LD_VAR 0 4
105337: ARRAY
105338: PUSH
105339: LD_INT 1
105341: GREATER
105342: AND
105343: IFFALSE 105474
// begin ComCancel ( j ) ;
105345: LD_VAR 0 3
105349: PPUSH
105350: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
105354: LD_ADDR_EXP 188
105358: PUSH
105359: LD_EXP 188
105363: PPUSH
105364: LD_VAR 0 4
105368: PPUSH
105369: LD_EXP 188
105373: PUSH
105374: LD_VAR 0 4
105378: ARRAY
105379: PPUSH
105380: LD_EXP 188
105384: PUSH
105385: LD_VAR 0 4
105389: ARRAY
105390: PUSH
105391: LD_INT 1
105393: MINUS
105394: PPUSH
105395: LD_EXP 188
105399: PUSH
105400: LD_VAR 0 4
105404: ARRAY
105405: PPUSH
105406: LD_INT 0
105408: PPUSH
105409: CALL 23779 0 4
105413: PPUSH
105414: CALL_OW 1
105418: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
105419: LD_ADDR_EXP 188
105423: PUSH
105424: LD_EXP 188
105428: PPUSH
105429: LD_VAR 0 4
105433: PPUSH
105434: LD_EXP 188
105438: PUSH
105439: LD_VAR 0 4
105443: ARRAY
105444: PPUSH
105445: LD_EXP 188
105449: PUSH
105450: LD_VAR 0 4
105454: ARRAY
105455: PPUSH
105456: LD_INT 1
105458: PPUSH
105459: LD_INT 0
105461: PPUSH
105462: CALL 23779 0 4
105466: PPUSH
105467: CALL_OW 1
105471: ST_TO_ADDR
// continue ;
105472: GO 105046
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
105474: LD_EXP 190
105478: PUSH
105479: LD_VAR 0 2
105483: ARRAY
105484: PUSH
105485: LD_EXP 191
105489: PUSH
105490: LD_VAR 0 2
105494: ARRAY
105495: NOT
105496: AND
105497: IFFALSE 105624
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
105499: LD_ADDR_EXP 191
105503: PUSH
105504: LD_EXP 191
105508: PPUSH
105509: LD_VAR 0 2
105513: PUSH
105514: LD_EXP 191
105518: PUSH
105519: LD_VAR 0 2
105523: ARRAY
105524: PUSH
105525: LD_INT 1
105527: PLUS
105528: PUSH
105529: EMPTY
105530: LIST
105531: LIST
105532: PPUSH
105533: LD_EXP 190
105537: PUSH
105538: LD_VAR 0 2
105542: ARRAY
105543: PUSH
105544: LD_INT 1
105546: ARRAY
105547: PPUSH
105548: CALL 24361 0 3
105552: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
105553: LD_EXP 190
105557: PUSH
105558: LD_VAR 0 2
105562: ARRAY
105563: PUSH
105564: LD_INT 1
105566: ARRAY
105567: PPUSH
105568: LD_INT 112
105570: PPUSH
105571: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
105575: LD_ADDR_VAR 0 9
105579: PUSH
105580: LD_EXP 190
105584: PUSH
105585: LD_VAR 0 2
105589: ARRAY
105590: PPUSH
105591: LD_INT 1
105593: PPUSH
105594: CALL_OW 3
105598: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
105599: LD_ADDR_EXP 190
105603: PUSH
105604: LD_EXP 190
105608: PPUSH
105609: LD_VAR 0 2
105613: PPUSH
105614: LD_VAR 0 9
105618: PPUSH
105619: CALL_OW 1
105623: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
105624: LD_EXP 190
105628: PUSH
105629: LD_VAR 0 2
105633: ARRAY
105634: PUSH
105635: LD_EXP 191
105639: PUSH
105640: LD_VAR 0 2
105644: ARRAY
105645: AND
105646: PUSH
105647: LD_EXP 191
105651: PUSH
105652: LD_VAR 0 2
105656: ARRAY
105657: PUSH
105658: LD_INT 1
105660: ARRAY
105661: PPUSH
105662: CALL_OW 310
105666: NOT
105667: AND
105668: PUSH
105669: LD_VAR 0 3
105673: PPUSH
105674: CALL_OW 313
105678: PUSH
105679: LD_INT 6
105681: EQUAL
105682: AND
105683: IFFALSE 105739
// begin tmp2 := UnitsInside ( j ) ;
105685: LD_ADDR_VAR 0 9
105689: PUSH
105690: LD_VAR 0 3
105694: PPUSH
105695: CALL_OW 313
105699: ST_TO_ADDR
// if tmp2 = 6 then
105700: LD_VAR 0 9
105704: PUSH
105705: LD_INT 6
105707: EQUAL
105708: IFFALSE 105739
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
105710: LD_VAR 0 9
105714: PUSH
105715: LD_INT 1
105717: ARRAY
105718: PPUSH
105719: LD_INT 112
105721: PPUSH
105722: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
105726: LD_VAR 0 9
105730: PUSH
105731: LD_INT 1
105733: ARRAY
105734: PPUSH
105735: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
105739: LD_EXP 191
105743: PUSH
105744: LD_VAR 0 2
105748: ARRAY
105749: PUSH
105750: LD_EXP 191
105754: PUSH
105755: LD_VAR 0 2
105759: ARRAY
105760: PUSH
105761: LD_INT 1
105763: ARRAY
105764: PPUSH
105765: CALL_OW 314
105769: NOT
105770: AND
105771: PUSH
105772: LD_EXP 191
105776: PUSH
105777: LD_VAR 0 2
105781: ARRAY
105782: PUSH
105783: LD_INT 1
105785: ARRAY
105786: PPUSH
105787: CALL_OW 310
105791: NOT
105792: AND
105793: IFFALSE 105819
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
105795: LD_EXP 191
105799: PUSH
105800: LD_VAR 0 2
105804: ARRAY
105805: PUSH
105806: LD_INT 1
105808: ARRAY
105809: PPUSH
105810: LD_VAR 0 3
105814: PPUSH
105815: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
105819: LD_EXP 191
105823: PUSH
105824: LD_VAR 0 2
105828: ARRAY
105829: PUSH
105830: LD_INT 1
105832: ARRAY
105833: PPUSH
105834: CALL_OW 310
105838: PUSH
105839: LD_EXP 191
105843: PUSH
105844: LD_VAR 0 2
105848: ARRAY
105849: PUSH
105850: LD_INT 1
105852: ARRAY
105853: PPUSH
105854: CALL_OW 310
105858: PPUSH
105859: CALL_OW 461
105863: PUSH
105864: LD_INT 3
105866: NONEQUAL
105867: AND
105868: IFFALSE 105889
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
105870: LD_EXP 191
105874: PUSH
105875: LD_VAR 0 2
105879: ARRAY
105880: PUSH
105881: LD_INT 1
105883: ARRAY
105884: PPUSH
105885: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
105889: LD_VAR 0 3
105893: PPUSH
105894: CALL_OW 461
105898: PUSH
105899: LD_INT 6
105901: EQUAL
105902: PUSH
105903: LD_VAR 0 6
105907: PUSH
105908: LD_INT 1
105910: GREATER
105911: AND
105912: IFFALSE 106064
// begin sci := [ ] ;
105914: LD_ADDR_VAR 0 8
105918: PUSH
105919: EMPTY
105920: ST_TO_ADDR
// for x in ( tmp diff j ) do
105921: LD_ADDR_VAR 0 7
105925: PUSH
105926: LD_VAR 0 6
105930: PUSH
105931: LD_VAR 0 3
105935: DIFF
105936: PUSH
105937: FOR_IN
105938: IFFALSE 105990
// begin if sci = 6 then
105940: LD_VAR 0 8
105944: PUSH
105945: LD_INT 6
105947: EQUAL
105948: IFFALSE 105952
// break ;
105950: GO 105990
// if BuildingStatus ( x ) = bs_idle then
105952: LD_VAR 0 7
105956: PPUSH
105957: CALL_OW 461
105961: PUSH
105962: LD_INT 2
105964: EQUAL
105965: IFFALSE 105988
// sci := sci ^ UnitsInside ( x ) ;
105967: LD_ADDR_VAR 0 8
105971: PUSH
105972: LD_VAR 0 8
105976: PUSH
105977: LD_VAR 0 7
105981: PPUSH
105982: CALL_OW 313
105986: ADD
105987: ST_TO_ADDR
// end ;
105988: GO 105937
105990: POP
105991: POP
// if not sci then
105992: LD_VAR 0 8
105996: NOT
105997: IFFALSE 106001
// continue ;
105999: GO 105046
// for x in sci do
106001: LD_ADDR_VAR 0 7
106005: PUSH
106006: LD_VAR 0 8
106010: PUSH
106011: FOR_IN
106012: IFFALSE 106062
// if IsInUnit ( x ) and not HasTask ( x ) then
106014: LD_VAR 0 7
106018: PPUSH
106019: CALL_OW 310
106023: PUSH
106024: LD_VAR 0 7
106028: PPUSH
106029: CALL_OW 314
106033: NOT
106034: AND
106035: IFFALSE 106060
// begin ComExitBuilding ( x ) ;
106037: LD_VAR 0 7
106041: PPUSH
106042: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
106046: LD_VAR 0 7
106050: PPUSH
106051: LD_VAR 0 3
106055: PPUSH
106056: CALL_OW 180
// end ;
106060: GO 106011
106062: POP
106063: POP
// end ; end ;
106064: GO 105046
106066: POP
106067: POP
// end ;
106068: GO 105000
106070: POP
106071: POP
// end ;
106072: LD_VAR 0 1
106076: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
106077: LD_INT 0
106079: PPUSH
106080: PPUSH
// if not mc_bases then
106081: LD_EXP 161
106085: NOT
106086: IFFALSE 106090
// exit ;
106088: GO 106171
// for i = 1 to mc_bases do
106090: LD_ADDR_VAR 0 2
106094: PUSH
106095: DOUBLE
106096: LD_INT 1
106098: DEC
106099: ST_TO_ADDR
106100: LD_EXP 161
106104: PUSH
106105: FOR_TO
106106: IFFALSE 106169
// if mc_mines [ i ] and mc_miners [ i ] then
106108: LD_EXP 174
106112: PUSH
106113: LD_VAR 0 2
106117: ARRAY
106118: PUSH
106119: LD_EXP 175
106123: PUSH
106124: LD_VAR 0 2
106128: ARRAY
106129: AND
106130: IFFALSE 106167
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
106132: LD_EXP 175
106136: PUSH
106137: LD_VAR 0 2
106141: ARRAY
106142: PUSH
106143: LD_INT 1
106145: ARRAY
106146: PPUSH
106147: CALL_OW 255
106151: PPUSH
106152: LD_EXP 174
106156: PUSH
106157: LD_VAR 0 2
106161: ARRAY
106162: PPUSH
106163: CALL 21163 0 2
106167: GO 106105
106169: POP
106170: POP
// end ;
106171: LD_VAR 0 1
106175: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
106176: LD_INT 0
106178: PPUSH
106179: PPUSH
106180: PPUSH
106181: PPUSH
106182: PPUSH
106183: PPUSH
106184: PPUSH
106185: PPUSH
// if not mc_bases or not mc_parking then
106186: LD_EXP 161
106190: NOT
106191: PUSH
106192: LD_EXP 185
106196: NOT
106197: OR
106198: IFFALSE 106202
// exit ;
106200: GO 106940
// for i = 1 to mc_bases do
106202: LD_ADDR_VAR 0 2
106206: PUSH
106207: DOUBLE
106208: LD_INT 1
106210: DEC
106211: ST_TO_ADDR
106212: LD_EXP 161
106216: PUSH
106217: FOR_TO
106218: IFFALSE 106938
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
106220: LD_EXP 161
106224: PUSH
106225: LD_VAR 0 2
106229: ARRAY
106230: NOT
106231: PUSH
106232: LD_EXP 185
106236: PUSH
106237: LD_VAR 0 2
106241: ARRAY
106242: NOT
106243: OR
106244: IFFALSE 106248
// continue ;
106246: GO 106217
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
106248: LD_ADDR_VAR 0 5
106252: PUSH
106253: LD_EXP 161
106257: PUSH
106258: LD_VAR 0 2
106262: ARRAY
106263: PUSH
106264: LD_INT 1
106266: ARRAY
106267: PPUSH
106268: CALL_OW 255
106272: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
106273: LD_ADDR_VAR 0 6
106277: PUSH
106278: LD_EXP 161
106282: PUSH
106283: LD_VAR 0 2
106287: ARRAY
106288: PPUSH
106289: LD_INT 30
106291: PUSH
106292: LD_INT 3
106294: PUSH
106295: EMPTY
106296: LIST
106297: LIST
106298: PPUSH
106299: CALL_OW 72
106303: ST_TO_ADDR
// if not fac then
106304: LD_VAR 0 6
106308: NOT
106309: IFFALSE 106360
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
106311: LD_ADDR_VAR 0 6
106315: PUSH
106316: LD_EXP 161
106320: PUSH
106321: LD_VAR 0 2
106325: ARRAY
106326: PPUSH
106327: LD_INT 2
106329: PUSH
106330: LD_INT 30
106332: PUSH
106333: LD_INT 0
106335: PUSH
106336: EMPTY
106337: LIST
106338: LIST
106339: PUSH
106340: LD_INT 30
106342: PUSH
106343: LD_INT 1
106345: PUSH
106346: EMPTY
106347: LIST
106348: LIST
106349: PUSH
106350: EMPTY
106351: LIST
106352: LIST
106353: LIST
106354: PPUSH
106355: CALL_OW 72
106359: ST_TO_ADDR
// if not fac then
106360: LD_VAR 0 6
106364: NOT
106365: IFFALSE 106369
// continue ;
106367: GO 106217
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_hastask ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
106369: LD_ADDR_VAR 0 7
106373: PUSH
106374: LD_EXP 185
106378: PUSH
106379: LD_VAR 0 2
106383: ARRAY
106384: PPUSH
106385: LD_INT 22
106387: PUSH
106388: LD_VAR 0 5
106392: PUSH
106393: EMPTY
106394: LIST
106395: LIST
106396: PUSH
106397: LD_INT 21
106399: PUSH
106400: LD_INT 2
106402: PUSH
106403: EMPTY
106404: LIST
106405: LIST
106406: PUSH
106407: LD_INT 3
106409: PUSH
106410: LD_INT 60
106412: PUSH
106413: EMPTY
106414: LIST
106415: PUSH
106416: EMPTY
106417: LIST
106418: LIST
106419: PUSH
106420: LD_INT 3
106422: PUSH
106423: LD_INT 24
106425: PUSH
106426: LD_INT 1000
106428: PUSH
106429: EMPTY
106430: LIST
106431: LIST
106432: PUSH
106433: EMPTY
106434: LIST
106435: LIST
106436: PUSH
106437: EMPTY
106438: LIST
106439: LIST
106440: LIST
106441: LIST
106442: PPUSH
106443: CALL_OW 70
106447: ST_TO_ADDR
// for j in fac do
106448: LD_ADDR_VAR 0 3
106452: PUSH
106453: LD_VAR 0 6
106457: PUSH
106458: FOR_IN
106459: IFFALSE 106554
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_hastask ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
106461: LD_ADDR_VAR 0 7
106465: PUSH
106466: LD_VAR 0 7
106470: PUSH
106471: LD_INT 22
106473: PUSH
106474: LD_VAR 0 5
106478: PUSH
106479: EMPTY
106480: LIST
106481: LIST
106482: PUSH
106483: LD_INT 91
106485: PUSH
106486: LD_VAR 0 3
106490: PUSH
106491: LD_INT 15
106493: PUSH
106494: EMPTY
106495: LIST
106496: LIST
106497: LIST
106498: PUSH
106499: LD_INT 21
106501: PUSH
106502: LD_INT 2
106504: PUSH
106505: EMPTY
106506: LIST
106507: LIST
106508: PUSH
106509: LD_INT 3
106511: PUSH
106512: LD_INT 60
106514: PUSH
106515: EMPTY
106516: LIST
106517: PUSH
106518: EMPTY
106519: LIST
106520: LIST
106521: PUSH
106522: LD_INT 3
106524: PUSH
106525: LD_INT 24
106527: PUSH
106528: LD_INT 1000
106530: PUSH
106531: EMPTY
106532: LIST
106533: LIST
106534: PUSH
106535: EMPTY
106536: LIST
106537: LIST
106538: PUSH
106539: EMPTY
106540: LIST
106541: LIST
106542: LIST
106543: LIST
106544: LIST
106545: PPUSH
106546: CALL_OW 69
106550: UNION
106551: ST_TO_ADDR
106552: GO 106458
106554: POP
106555: POP
// if not vehs then
106556: LD_VAR 0 7
106560: NOT
106561: IFFALSE 106587
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
106563: LD_ADDR_EXP 173
106567: PUSH
106568: LD_EXP 173
106572: PPUSH
106573: LD_VAR 0 2
106577: PPUSH
106578: EMPTY
106579: PPUSH
106580: CALL_OW 1
106584: ST_TO_ADDR
// continue ;
106585: GO 106217
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
106587: LD_ADDR_VAR 0 8
106591: PUSH
106592: LD_EXP 161
106596: PUSH
106597: LD_VAR 0 2
106601: ARRAY
106602: PPUSH
106603: LD_INT 30
106605: PUSH
106606: LD_INT 3
106608: PUSH
106609: EMPTY
106610: LIST
106611: LIST
106612: PPUSH
106613: CALL_OW 72
106617: ST_TO_ADDR
// if tmp then
106618: LD_VAR 0 8
106622: IFFALSE 106725
// begin for j in tmp do
106624: LD_ADDR_VAR 0 3
106628: PUSH
106629: LD_VAR 0 8
106633: PUSH
106634: FOR_IN
106635: IFFALSE 106723
// for k in UnitsInside ( j ) do
106637: LD_ADDR_VAR 0 4
106641: PUSH
106642: LD_VAR 0 3
106646: PPUSH
106647: CALL_OW 313
106651: PUSH
106652: FOR_IN
106653: IFFALSE 106719
// if k then
106655: LD_VAR 0 4
106659: IFFALSE 106717
// if not k in mc_repair_vehicle [ i ] then
106661: LD_VAR 0 4
106665: PUSH
106666: LD_EXP 173
106670: PUSH
106671: LD_VAR 0 2
106675: ARRAY
106676: IN
106677: NOT
106678: IFFALSE 106717
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
106680: LD_ADDR_EXP 173
106684: PUSH
106685: LD_EXP 173
106689: PPUSH
106690: LD_VAR 0 2
106694: PPUSH
106695: LD_EXP 173
106699: PUSH
106700: LD_VAR 0 2
106704: ARRAY
106705: PUSH
106706: LD_VAR 0 4
106710: UNION
106711: PPUSH
106712: CALL_OW 1
106716: ST_TO_ADDR
106717: GO 106652
106719: POP
106720: POP
106721: GO 106634
106723: POP
106724: POP
// end ; if not mc_repair_vehicle [ i ] then
106725: LD_EXP 173
106729: PUSH
106730: LD_VAR 0 2
106734: ARRAY
106735: NOT
106736: IFFALSE 106740
// continue ;
106738: GO 106217
// for j in mc_repair_vehicle [ i ] do
106740: LD_ADDR_VAR 0 3
106744: PUSH
106745: LD_EXP 173
106749: PUSH
106750: LD_VAR 0 2
106754: ARRAY
106755: PUSH
106756: FOR_IN
106757: IFFALSE 106934
// begin if GetClass ( j ) <> 3 then
106759: LD_VAR 0 3
106763: PPUSH
106764: CALL_OW 257
106768: PUSH
106769: LD_INT 3
106771: NONEQUAL
106772: IFFALSE 106813
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
106774: LD_ADDR_EXP 173
106778: PUSH
106779: LD_EXP 173
106783: PPUSH
106784: LD_VAR 0 2
106788: PPUSH
106789: LD_EXP 173
106793: PUSH
106794: LD_VAR 0 2
106798: ARRAY
106799: PUSH
106800: LD_VAR 0 3
106804: DIFF
106805: PPUSH
106806: CALL_OW 1
106810: ST_TO_ADDR
// continue ;
106811: GO 106756
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
106813: LD_VAR 0 3
106817: PPUSH
106818: CALL_OW 311
106822: NOT
106823: PUSH
106824: LD_VAR 0 3
106828: PUSH
106829: LD_EXP 164
106833: PUSH
106834: LD_VAR 0 2
106838: ARRAY
106839: PUSH
106840: LD_INT 1
106842: ARRAY
106843: IN
106844: NOT
106845: AND
106846: PUSH
106847: LD_VAR 0 3
106851: PUSH
106852: LD_EXP 164
106856: PUSH
106857: LD_VAR 0 2
106861: ARRAY
106862: PUSH
106863: LD_INT 2
106865: ARRAY
106866: IN
106867: NOT
106868: AND
106869: IFFALSE 106932
// begin if IsInUnit ( j ) then
106871: LD_VAR 0 3
106875: PPUSH
106876: CALL_OW 310
106880: IFFALSE 106893
// ComExitBuilding ( j ) else
106882: LD_VAR 0 3
106886: PPUSH
106887: CALL_OW 122
106891: GO 106932
// if not WantToRepairVehicle ( j , vehs [ 1 ] ) then
106893: LD_VAR 0 3
106897: PPUSH
106898: LD_VAR 0 7
106902: PUSH
106903: LD_INT 1
106905: ARRAY
106906: PPUSH
106907: CALL 58757 0 2
106911: NOT
106912: IFFALSE 106932
// ComRepairVehicle ( j , vehs [ 1 ] ) ;
106914: LD_VAR 0 3
106918: PPUSH
106919: LD_VAR 0 7
106923: PUSH
106924: LD_INT 1
106926: ARRAY
106927: PPUSH
106928: CALL_OW 129
// end ; end ;
106932: GO 106756
106934: POP
106935: POP
// end ;
106936: GO 106217
106938: POP
106939: POP
// end ;
106940: LD_VAR 0 1
106944: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
106945: LD_INT 0
106947: PPUSH
106948: PPUSH
106949: PPUSH
106950: PPUSH
106951: PPUSH
106952: PPUSH
106953: PPUSH
106954: PPUSH
106955: PPUSH
106956: PPUSH
106957: PPUSH
// if not mc_bases then
106958: LD_EXP 161
106962: NOT
106963: IFFALSE 106967
// exit ;
106965: GO 107769
// for i = 1 to mc_bases do
106967: LD_ADDR_VAR 0 2
106971: PUSH
106972: DOUBLE
106973: LD_INT 1
106975: DEC
106976: ST_TO_ADDR
106977: LD_EXP 161
106981: PUSH
106982: FOR_TO
106983: IFFALSE 107767
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
106985: LD_EXP 189
106989: PUSH
106990: LD_VAR 0 2
106994: ARRAY
106995: NOT
106996: PUSH
106997: LD_EXP 164
107001: PUSH
107002: LD_VAR 0 2
107006: ARRAY
107007: PUSH
107008: LD_INT 1
107010: ARRAY
107011: OR
107012: PUSH
107013: LD_EXP 164
107017: PUSH
107018: LD_VAR 0 2
107022: ARRAY
107023: PUSH
107024: LD_INT 2
107026: ARRAY
107027: OR
107028: PUSH
107029: LD_EXP 187
107033: PUSH
107034: LD_VAR 0 2
107038: ARRAY
107039: PPUSH
107040: LD_INT 1
107042: PPUSH
107043: CALL_OW 325
107047: NOT
107048: OR
107049: PUSH
107050: LD_EXP 184
107054: PUSH
107055: LD_VAR 0 2
107059: ARRAY
107060: OR
107061: IFFALSE 107065
// continue ;
107063: GO 106982
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
107065: LD_ADDR_VAR 0 8
107069: PUSH
107070: LD_EXP 161
107074: PUSH
107075: LD_VAR 0 2
107079: ARRAY
107080: PPUSH
107081: LD_INT 25
107083: PUSH
107084: LD_INT 4
107086: PUSH
107087: EMPTY
107088: LIST
107089: LIST
107090: PUSH
107091: LD_INT 50
107093: PUSH
107094: EMPTY
107095: LIST
107096: PUSH
107097: LD_INT 3
107099: PUSH
107100: LD_INT 60
107102: PUSH
107103: EMPTY
107104: LIST
107105: PUSH
107106: EMPTY
107107: LIST
107108: LIST
107109: PUSH
107110: EMPTY
107111: LIST
107112: LIST
107113: LIST
107114: PPUSH
107115: CALL_OW 72
107119: PUSH
107120: LD_EXP 165
107124: PUSH
107125: LD_VAR 0 2
107129: ARRAY
107130: DIFF
107131: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
107132: LD_ADDR_VAR 0 9
107136: PUSH
107137: LD_EXP 161
107141: PUSH
107142: LD_VAR 0 2
107146: ARRAY
107147: PPUSH
107148: LD_INT 2
107150: PUSH
107151: LD_INT 30
107153: PUSH
107154: LD_INT 0
107156: PUSH
107157: EMPTY
107158: LIST
107159: LIST
107160: PUSH
107161: LD_INT 30
107163: PUSH
107164: LD_INT 1
107166: PUSH
107167: EMPTY
107168: LIST
107169: LIST
107170: PUSH
107171: EMPTY
107172: LIST
107173: LIST
107174: LIST
107175: PPUSH
107176: CALL_OW 72
107180: ST_TO_ADDR
// if not tmp or not dep then
107181: LD_VAR 0 8
107185: NOT
107186: PUSH
107187: LD_VAR 0 9
107191: NOT
107192: OR
107193: IFFALSE 107197
// continue ;
107195: GO 106982
// side := GetSide ( tmp [ 1 ] ) ;
107197: LD_ADDR_VAR 0 11
107201: PUSH
107202: LD_VAR 0 8
107206: PUSH
107207: LD_INT 1
107209: ARRAY
107210: PPUSH
107211: CALL_OW 255
107215: ST_TO_ADDR
// dep := dep [ 1 ] ;
107216: LD_ADDR_VAR 0 9
107220: PUSH
107221: LD_VAR 0 9
107225: PUSH
107226: LD_INT 1
107228: ARRAY
107229: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
107230: LD_ADDR_VAR 0 7
107234: PUSH
107235: LD_EXP 189
107239: PUSH
107240: LD_VAR 0 2
107244: ARRAY
107245: PPUSH
107246: LD_INT 22
107248: PUSH
107249: LD_INT 0
107251: PUSH
107252: EMPTY
107253: LIST
107254: LIST
107255: PUSH
107256: LD_INT 25
107258: PUSH
107259: LD_INT 12
107261: PUSH
107262: EMPTY
107263: LIST
107264: LIST
107265: PUSH
107266: EMPTY
107267: LIST
107268: LIST
107269: PPUSH
107270: CALL_OW 70
107274: PUSH
107275: LD_INT 22
107277: PUSH
107278: LD_INT 0
107280: PUSH
107281: EMPTY
107282: LIST
107283: LIST
107284: PUSH
107285: LD_INT 25
107287: PUSH
107288: LD_INT 12
107290: PUSH
107291: EMPTY
107292: LIST
107293: LIST
107294: PUSH
107295: LD_INT 91
107297: PUSH
107298: LD_VAR 0 9
107302: PUSH
107303: LD_INT 20
107305: PUSH
107306: EMPTY
107307: LIST
107308: LIST
107309: LIST
107310: PUSH
107311: EMPTY
107312: LIST
107313: LIST
107314: LIST
107315: PPUSH
107316: CALL_OW 69
107320: UNION
107321: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
107322: LD_ADDR_VAR 0 10
107326: PUSH
107327: LD_EXP 189
107331: PUSH
107332: LD_VAR 0 2
107336: ARRAY
107337: PPUSH
107338: LD_INT 81
107340: PUSH
107341: LD_VAR 0 11
107345: PUSH
107346: EMPTY
107347: LIST
107348: LIST
107349: PPUSH
107350: CALL_OW 70
107354: ST_TO_ADDR
// if not apes or danger_at_area then
107355: LD_VAR 0 7
107359: NOT
107360: PUSH
107361: LD_VAR 0 10
107365: OR
107366: IFFALSE 107416
// begin if mc_taming [ i ] then
107368: LD_EXP 192
107372: PUSH
107373: LD_VAR 0 2
107377: ARRAY
107378: IFFALSE 107414
// begin MC_Reset ( i , 121 ) ;
107380: LD_VAR 0 2
107384: PPUSH
107385: LD_INT 121
107387: PPUSH
107388: CALL 92353 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
107392: LD_ADDR_EXP 192
107396: PUSH
107397: LD_EXP 192
107401: PPUSH
107402: LD_VAR 0 2
107406: PPUSH
107407: EMPTY
107408: PPUSH
107409: CALL_OW 1
107413: ST_TO_ADDR
// end ; continue ;
107414: GO 106982
// end ; for j in tmp do
107416: LD_ADDR_VAR 0 3
107420: PUSH
107421: LD_VAR 0 8
107425: PUSH
107426: FOR_IN
107427: IFFALSE 107763
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
107429: LD_VAR 0 3
107433: PUSH
107434: LD_EXP 192
107438: PUSH
107439: LD_VAR 0 2
107443: ARRAY
107444: IN
107445: NOT
107446: PUSH
107447: LD_EXP 192
107451: PUSH
107452: LD_VAR 0 2
107456: ARRAY
107457: PUSH
107458: LD_INT 3
107460: LESS
107461: AND
107462: IFFALSE 107520
// begin SetTag ( j , 121 ) ;
107464: LD_VAR 0 3
107468: PPUSH
107469: LD_INT 121
107471: PPUSH
107472: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
107476: LD_ADDR_EXP 192
107480: PUSH
107481: LD_EXP 192
107485: PPUSH
107486: LD_VAR 0 2
107490: PUSH
107491: LD_EXP 192
107495: PUSH
107496: LD_VAR 0 2
107500: ARRAY
107501: PUSH
107502: LD_INT 1
107504: PLUS
107505: PUSH
107506: EMPTY
107507: LIST
107508: LIST
107509: PPUSH
107510: LD_VAR 0 3
107514: PPUSH
107515: CALL 24361 0 3
107519: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
107520: LD_VAR 0 3
107524: PUSH
107525: LD_EXP 192
107529: PUSH
107530: LD_VAR 0 2
107534: ARRAY
107535: IN
107536: IFFALSE 107761
// begin if GetClass ( j ) <> 4 then
107538: LD_VAR 0 3
107542: PPUSH
107543: CALL_OW 257
107547: PUSH
107548: LD_INT 4
107550: NONEQUAL
107551: IFFALSE 107604
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
107553: LD_ADDR_EXP 192
107557: PUSH
107558: LD_EXP 192
107562: PPUSH
107563: LD_VAR 0 2
107567: PPUSH
107568: LD_EXP 192
107572: PUSH
107573: LD_VAR 0 2
107577: ARRAY
107578: PUSH
107579: LD_VAR 0 3
107583: DIFF
107584: PPUSH
107585: CALL_OW 1
107589: ST_TO_ADDR
// SetTag ( j , 0 ) ;
107590: LD_VAR 0 3
107594: PPUSH
107595: LD_INT 0
107597: PPUSH
107598: CALL_OW 109
// continue ;
107602: GO 107426
// end ; if IsInUnit ( j ) then
107604: LD_VAR 0 3
107608: PPUSH
107609: CALL_OW 310
107613: IFFALSE 107624
// ComExitBuilding ( j ) ;
107615: LD_VAR 0 3
107619: PPUSH
107620: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
107624: LD_ADDR_VAR 0 6
107628: PUSH
107629: LD_VAR 0 7
107633: PPUSH
107634: LD_VAR 0 3
107638: PPUSH
107639: CALL_OW 74
107643: ST_TO_ADDR
// if not ape then
107644: LD_VAR 0 6
107648: NOT
107649: IFFALSE 107653
// break ;
107651: GO 107763
// x := GetX ( ape ) ;
107653: LD_ADDR_VAR 0 4
107657: PUSH
107658: LD_VAR 0 6
107662: PPUSH
107663: CALL_OW 250
107667: ST_TO_ADDR
// y := GetY ( ape ) ;
107668: LD_ADDR_VAR 0 5
107672: PUSH
107673: LD_VAR 0 6
107677: PPUSH
107678: CALL_OW 251
107682: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
107683: LD_VAR 0 4
107687: PPUSH
107688: LD_VAR 0 5
107692: PPUSH
107693: CALL_OW 488
107697: NOT
107698: PUSH
107699: LD_VAR 0 11
107703: PPUSH
107704: LD_VAR 0 4
107708: PPUSH
107709: LD_VAR 0 5
107713: PPUSH
107714: LD_INT 20
107716: PPUSH
107717: CALL 25257 0 4
107721: PUSH
107722: LD_INT 4
107724: ARRAY
107725: OR
107726: IFFALSE 107730
// break ;
107728: GO 107763
// if not HasTask ( j ) then
107730: LD_VAR 0 3
107734: PPUSH
107735: CALL_OW 314
107739: NOT
107740: IFFALSE 107761
// ComTameXY ( j , x , y ) ;
107742: LD_VAR 0 3
107746: PPUSH
107747: LD_VAR 0 4
107751: PPUSH
107752: LD_VAR 0 5
107756: PPUSH
107757: CALL_OW 131
// end ; end ;
107761: GO 107426
107763: POP
107764: POP
// end ;
107765: GO 106982
107767: POP
107768: POP
// end ;
107769: LD_VAR 0 1
107773: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
107774: LD_INT 0
107776: PPUSH
107777: PPUSH
107778: PPUSH
107779: PPUSH
107780: PPUSH
107781: PPUSH
107782: PPUSH
107783: PPUSH
// if not mc_bases then
107784: LD_EXP 161
107788: NOT
107789: IFFALSE 107793
// exit ;
107791: GO 108419
// for i = 1 to mc_bases do
107793: LD_ADDR_VAR 0 2
107797: PUSH
107798: DOUBLE
107799: LD_INT 1
107801: DEC
107802: ST_TO_ADDR
107803: LD_EXP 161
107807: PUSH
107808: FOR_TO
107809: IFFALSE 108417
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
107811: LD_EXP 190
107815: PUSH
107816: LD_VAR 0 2
107820: ARRAY
107821: NOT
107822: PUSH
107823: LD_EXP 190
107827: PUSH
107828: LD_VAR 0 2
107832: ARRAY
107833: PPUSH
107834: LD_INT 25
107836: PUSH
107837: LD_INT 12
107839: PUSH
107840: EMPTY
107841: LIST
107842: LIST
107843: PPUSH
107844: CALL_OW 72
107848: NOT
107849: OR
107850: IFFALSE 107854
// continue ;
107852: GO 107808
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
107854: LD_ADDR_VAR 0 5
107858: PUSH
107859: LD_EXP 190
107863: PUSH
107864: LD_VAR 0 2
107868: ARRAY
107869: PUSH
107870: LD_INT 1
107872: ARRAY
107873: PPUSH
107874: CALL_OW 255
107878: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
107879: LD_VAR 0 5
107883: PPUSH
107884: LD_INT 2
107886: PPUSH
107887: CALL_OW 325
107891: IFFALSE 108144
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
107893: LD_ADDR_VAR 0 4
107897: PUSH
107898: LD_EXP 190
107902: PUSH
107903: LD_VAR 0 2
107907: ARRAY
107908: PPUSH
107909: LD_INT 25
107911: PUSH
107912: LD_INT 16
107914: PUSH
107915: EMPTY
107916: LIST
107917: LIST
107918: PPUSH
107919: CALL_OW 72
107923: ST_TO_ADDR
// if tmp < 6 then
107924: LD_VAR 0 4
107928: PUSH
107929: LD_INT 6
107931: LESS
107932: IFFALSE 108144
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
107934: LD_ADDR_VAR 0 6
107938: PUSH
107939: LD_EXP 161
107943: PUSH
107944: LD_VAR 0 2
107948: ARRAY
107949: PPUSH
107950: LD_INT 2
107952: PUSH
107953: LD_INT 30
107955: PUSH
107956: LD_INT 0
107958: PUSH
107959: EMPTY
107960: LIST
107961: LIST
107962: PUSH
107963: LD_INT 30
107965: PUSH
107966: LD_INT 1
107968: PUSH
107969: EMPTY
107970: LIST
107971: LIST
107972: PUSH
107973: EMPTY
107974: LIST
107975: LIST
107976: LIST
107977: PPUSH
107978: CALL_OW 72
107982: ST_TO_ADDR
// if depot then
107983: LD_VAR 0 6
107987: IFFALSE 108144
// begin selected := 0 ;
107989: LD_ADDR_VAR 0 7
107993: PUSH
107994: LD_INT 0
107996: ST_TO_ADDR
// for j in depot do
107997: LD_ADDR_VAR 0 3
108001: PUSH
108002: LD_VAR 0 6
108006: PUSH
108007: FOR_IN
108008: IFFALSE 108039
// begin if UnitsInside ( j ) < 6 then
108010: LD_VAR 0 3
108014: PPUSH
108015: CALL_OW 313
108019: PUSH
108020: LD_INT 6
108022: LESS
108023: IFFALSE 108037
// begin selected := j ;
108025: LD_ADDR_VAR 0 7
108029: PUSH
108030: LD_VAR 0 3
108034: ST_TO_ADDR
// break ;
108035: GO 108039
// end ; end ;
108037: GO 108007
108039: POP
108040: POP
// if selected then
108041: LD_VAR 0 7
108045: IFFALSE 108144
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
108047: LD_ADDR_VAR 0 3
108051: PUSH
108052: LD_EXP 190
108056: PUSH
108057: LD_VAR 0 2
108061: ARRAY
108062: PPUSH
108063: LD_INT 25
108065: PUSH
108066: LD_INT 12
108068: PUSH
108069: EMPTY
108070: LIST
108071: LIST
108072: PPUSH
108073: CALL_OW 72
108077: PUSH
108078: FOR_IN
108079: IFFALSE 108142
// if not HasTask ( j ) then
108081: LD_VAR 0 3
108085: PPUSH
108086: CALL_OW 314
108090: NOT
108091: IFFALSE 108140
// begin if not IsInUnit ( j ) then
108093: LD_VAR 0 3
108097: PPUSH
108098: CALL_OW 310
108102: NOT
108103: IFFALSE 108119
// ComEnterUnit ( j , selected ) ;
108105: LD_VAR 0 3
108109: PPUSH
108110: LD_VAR 0 7
108114: PPUSH
108115: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
108119: LD_VAR 0 3
108123: PPUSH
108124: LD_INT 16
108126: PPUSH
108127: CALL_OW 183
// AddComExitBuilding ( j ) ;
108131: LD_VAR 0 3
108135: PPUSH
108136: CALL_OW 182
// end ;
108140: GO 108078
108142: POP
108143: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
108144: LD_VAR 0 5
108148: PPUSH
108149: LD_INT 11
108151: PPUSH
108152: CALL_OW 325
108156: IFFALSE 108415
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
108158: LD_ADDR_VAR 0 4
108162: PUSH
108163: LD_EXP 190
108167: PUSH
108168: LD_VAR 0 2
108172: ARRAY
108173: PPUSH
108174: LD_INT 25
108176: PUSH
108177: LD_INT 16
108179: PUSH
108180: EMPTY
108181: LIST
108182: LIST
108183: PPUSH
108184: CALL_OW 72
108188: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
108189: LD_VAR 0 4
108193: PUSH
108194: LD_INT 6
108196: GREATEREQUAL
108197: PUSH
108198: LD_VAR 0 5
108202: PPUSH
108203: LD_INT 2
108205: PPUSH
108206: CALL_OW 325
108210: NOT
108211: OR
108212: IFFALSE 108415
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
108214: LD_ADDR_VAR 0 8
108218: PUSH
108219: LD_EXP 161
108223: PUSH
108224: LD_VAR 0 2
108228: ARRAY
108229: PPUSH
108230: LD_INT 2
108232: PUSH
108233: LD_INT 30
108235: PUSH
108236: LD_INT 4
108238: PUSH
108239: EMPTY
108240: LIST
108241: LIST
108242: PUSH
108243: LD_INT 30
108245: PUSH
108246: LD_INT 5
108248: PUSH
108249: EMPTY
108250: LIST
108251: LIST
108252: PUSH
108253: EMPTY
108254: LIST
108255: LIST
108256: LIST
108257: PPUSH
108258: CALL_OW 72
108262: ST_TO_ADDR
// if barracks then
108263: LD_VAR 0 8
108267: IFFALSE 108415
// begin selected := 0 ;
108269: LD_ADDR_VAR 0 7
108273: PUSH
108274: LD_INT 0
108276: ST_TO_ADDR
// for j in barracks do
108277: LD_ADDR_VAR 0 3
108281: PUSH
108282: LD_VAR 0 8
108286: PUSH
108287: FOR_IN
108288: IFFALSE 108319
// begin if UnitsInside ( j ) < 6 then
108290: LD_VAR 0 3
108294: PPUSH
108295: CALL_OW 313
108299: PUSH
108300: LD_INT 6
108302: LESS
108303: IFFALSE 108317
// begin selected := j ;
108305: LD_ADDR_VAR 0 7
108309: PUSH
108310: LD_VAR 0 3
108314: ST_TO_ADDR
// break ;
108315: GO 108319
// end ; end ;
108317: GO 108287
108319: POP
108320: POP
// if selected then
108321: LD_VAR 0 7
108325: IFFALSE 108415
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
108327: LD_ADDR_VAR 0 3
108331: PUSH
108332: LD_EXP 190
108336: PUSH
108337: LD_VAR 0 2
108341: ARRAY
108342: PPUSH
108343: LD_INT 25
108345: PUSH
108346: LD_INT 12
108348: PUSH
108349: EMPTY
108350: LIST
108351: LIST
108352: PPUSH
108353: CALL_OW 72
108357: PUSH
108358: FOR_IN
108359: IFFALSE 108413
// if not IsInUnit ( j ) and not HasTask ( j ) then
108361: LD_VAR 0 3
108365: PPUSH
108366: CALL_OW 310
108370: NOT
108371: PUSH
108372: LD_VAR 0 3
108376: PPUSH
108377: CALL_OW 314
108381: NOT
108382: AND
108383: IFFALSE 108411
// begin ComEnterUnit ( j , selected ) ;
108385: LD_VAR 0 3
108389: PPUSH
108390: LD_VAR 0 7
108394: PPUSH
108395: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
108399: LD_VAR 0 3
108403: PPUSH
108404: LD_INT 15
108406: PPUSH
108407: CALL_OW 183
// end ;
108411: GO 108358
108413: POP
108414: POP
// end ; end ; end ; end ; end ;
108415: GO 107808
108417: POP
108418: POP
// end ;
108419: LD_VAR 0 1
108423: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
108424: LD_INT 0
108426: PPUSH
108427: PPUSH
108428: PPUSH
108429: PPUSH
// if not mc_bases then
108430: LD_EXP 161
108434: NOT
108435: IFFALSE 108439
// exit ;
108437: GO 108617
// for i = 1 to mc_bases do
108439: LD_ADDR_VAR 0 2
108443: PUSH
108444: DOUBLE
108445: LD_INT 1
108447: DEC
108448: ST_TO_ADDR
108449: LD_EXP 161
108453: PUSH
108454: FOR_TO
108455: IFFALSE 108615
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
108457: LD_ADDR_VAR 0 4
108461: PUSH
108462: LD_EXP 161
108466: PUSH
108467: LD_VAR 0 2
108471: ARRAY
108472: PPUSH
108473: LD_INT 25
108475: PUSH
108476: LD_INT 9
108478: PUSH
108479: EMPTY
108480: LIST
108481: LIST
108482: PPUSH
108483: CALL_OW 72
108487: ST_TO_ADDR
// if not tmp then
108488: LD_VAR 0 4
108492: NOT
108493: IFFALSE 108497
// continue ;
108495: GO 108454
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
108497: LD_EXP 187
108501: PUSH
108502: LD_VAR 0 2
108506: ARRAY
108507: PPUSH
108508: LD_INT 29
108510: PPUSH
108511: CALL_OW 325
108515: NOT
108516: PUSH
108517: LD_EXP 187
108521: PUSH
108522: LD_VAR 0 2
108526: ARRAY
108527: PPUSH
108528: LD_INT 28
108530: PPUSH
108531: CALL_OW 325
108535: NOT
108536: AND
108537: IFFALSE 108541
// continue ;
108539: GO 108454
// for j in tmp do
108541: LD_ADDR_VAR 0 3
108545: PUSH
108546: LD_VAR 0 4
108550: PUSH
108551: FOR_IN
108552: IFFALSE 108611
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
108554: LD_VAR 0 3
108558: PUSH
108559: LD_EXP 164
108563: PUSH
108564: LD_VAR 0 2
108568: ARRAY
108569: PUSH
108570: LD_INT 1
108572: ARRAY
108573: IN
108574: NOT
108575: PUSH
108576: LD_VAR 0 3
108580: PUSH
108581: LD_EXP 164
108585: PUSH
108586: LD_VAR 0 2
108590: ARRAY
108591: PUSH
108592: LD_INT 2
108594: ARRAY
108595: IN
108596: NOT
108597: AND
108598: IFFALSE 108609
// ComSpaceTimeShoot ( j ) ;
108600: LD_VAR 0 3
108604: PPUSH
108605: CALL 20171 0 1
108609: GO 108551
108611: POP
108612: POP
// end ;
108613: GO 108454
108615: POP
108616: POP
// end ;
108617: LD_VAR 0 1
108621: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
108622: LD_INT 0
108624: PPUSH
108625: PPUSH
108626: PPUSH
108627: PPUSH
108628: PPUSH
108629: PPUSH
108630: PPUSH
108631: PPUSH
108632: PPUSH
// if not mc_bases then
108633: LD_EXP 161
108637: NOT
108638: IFFALSE 108642
// exit ;
108640: GO 109264
// for i = 1 to mc_bases do
108642: LD_ADDR_VAR 0 2
108646: PUSH
108647: DOUBLE
108648: LD_INT 1
108650: DEC
108651: ST_TO_ADDR
108652: LD_EXP 161
108656: PUSH
108657: FOR_TO
108658: IFFALSE 109262
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
108660: LD_EXP 196
108664: PUSH
108665: LD_VAR 0 2
108669: ARRAY
108670: NOT
108671: PUSH
108672: LD_INT 38
108674: PPUSH
108675: LD_EXP 187
108679: PUSH
108680: LD_VAR 0 2
108684: ARRAY
108685: PPUSH
108686: CALL_OW 321
108690: PUSH
108691: LD_INT 2
108693: NONEQUAL
108694: OR
108695: IFFALSE 108699
// continue ;
108697: GO 108657
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
108699: LD_ADDR_VAR 0 8
108703: PUSH
108704: LD_EXP 161
108708: PUSH
108709: LD_VAR 0 2
108713: ARRAY
108714: PPUSH
108715: LD_INT 30
108717: PUSH
108718: LD_INT 34
108720: PUSH
108721: EMPTY
108722: LIST
108723: LIST
108724: PPUSH
108725: CALL_OW 72
108729: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
108730: LD_ADDR_VAR 0 9
108734: PUSH
108735: LD_EXP 161
108739: PUSH
108740: LD_VAR 0 2
108744: ARRAY
108745: PPUSH
108746: LD_INT 25
108748: PUSH
108749: LD_INT 4
108751: PUSH
108752: EMPTY
108753: LIST
108754: LIST
108755: PPUSH
108756: CALL_OW 72
108760: PPUSH
108761: LD_INT 0
108763: PPUSH
108764: CALL 54273 0 2
108768: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
108769: LD_VAR 0 9
108773: NOT
108774: PUSH
108775: LD_VAR 0 8
108779: NOT
108780: OR
108781: PUSH
108782: LD_EXP 161
108786: PUSH
108787: LD_VAR 0 2
108791: ARRAY
108792: PPUSH
108793: LD_INT 124
108795: PPUSH
108796: CALL 54273 0 2
108800: OR
108801: IFFALSE 108805
// continue ;
108803: GO 108657
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
108805: LD_EXP 197
108809: PUSH
108810: LD_VAR 0 2
108814: ARRAY
108815: PUSH
108816: LD_EXP 196
108820: PUSH
108821: LD_VAR 0 2
108825: ARRAY
108826: LESS
108827: PUSH
108828: LD_EXP 197
108832: PUSH
108833: LD_VAR 0 2
108837: ARRAY
108838: PUSH
108839: LD_VAR 0 8
108843: LESS
108844: AND
108845: IFFALSE 109260
// begin tmp := sci [ 1 ] ;
108847: LD_ADDR_VAR 0 7
108851: PUSH
108852: LD_VAR 0 9
108856: PUSH
108857: LD_INT 1
108859: ARRAY
108860: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
108861: LD_VAR 0 7
108865: PPUSH
108866: LD_INT 124
108868: PPUSH
108869: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
108873: LD_ADDR_VAR 0 3
108877: PUSH
108878: DOUBLE
108879: LD_EXP 196
108883: PUSH
108884: LD_VAR 0 2
108888: ARRAY
108889: INC
108890: ST_TO_ADDR
108891: LD_EXP 196
108895: PUSH
108896: LD_VAR 0 2
108900: ARRAY
108901: PUSH
108902: FOR_DOWNTO
108903: IFFALSE 109246
// begin if IsInUnit ( tmp ) then
108905: LD_VAR 0 7
108909: PPUSH
108910: CALL_OW 310
108914: IFFALSE 108925
// ComExitBuilding ( tmp ) ;
108916: LD_VAR 0 7
108920: PPUSH
108921: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
108925: LD_INT 35
108927: PPUSH
108928: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
108932: LD_VAR 0 7
108936: PPUSH
108937: CALL_OW 310
108941: NOT
108942: PUSH
108943: LD_VAR 0 7
108947: PPUSH
108948: CALL_OW 314
108952: NOT
108953: AND
108954: IFFALSE 108925
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
108956: LD_ADDR_VAR 0 6
108960: PUSH
108961: LD_VAR 0 7
108965: PPUSH
108966: CALL_OW 250
108970: PUSH
108971: LD_VAR 0 7
108975: PPUSH
108976: CALL_OW 251
108980: PUSH
108981: EMPTY
108982: LIST
108983: LIST
108984: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
108985: LD_INT 35
108987: PPUSH
108988: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
108992: LD_ADDR_VAR 0 4
108996: PUSH
108997: LD_EXP 196
109001: PUSH
109002: LD_VAR 0 2
109006: ARRAY
109007: PUSH
109008: LD_VAR 0 3
109012: ARRAY
109013: PUSH
109014: LD_INT 1
109016: ARRAY
109017: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
109018: LD_ADDR_VAR 0 5
109022: PUSH
109023: LD_EXP 196
109027: PUSH
109028: LD_VAR 0 2
109032: ARRAY
109033: PUSH
109034: LD_VAR 0 3
109038: ARRAY
109039: PUSH
109040: LD_INT 2
109042: ARRAY
109043: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
109044: LD_VAR 0 7
109048: PPUSH
109049: LD_INT 10
109051: PPUSH
109052: CALL 26958 0 2
109056: PUSH
109057: LD_INT 4
109059: ARRAY
109060: IFFALSE 109098
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
109062: LD_VAR 0 7
109066: PPUSH
109067: LD_VAR 0 6
109071: PUSH
109072: LD_INT 1
109074: ARRAY
109075: PPUSH
109076: LD_VAR 0 6
109080: PUSH
109081: LD_INT 2
109083: ARRAY
109084: PPUSH
109085: CALL_OW 111
// wait ( 0 0$10 ) ;
109089: LD_INT 350
109091: PPUSH
109092: CALL_OW 67
// end else
109096: GO 109124
// begin ComMoveXY ( tmp , x , y ) ;
109098: LD_VAR 0 7
109102: PPUSH
109103: LD_VAR 0 4
109107: PPUSH
109108: LD_VAR 0 5
109112: PPUSH
109113: CALL_OW 111
// wait ( 0 0$3 ) ;
109117: LD_INT 105
109119: PPUSH
109120: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
109124: LD_VAR 0 7
109128: PPUSH
109129: LD_VAR 0 4
109133: PPUSH
109134: LD_VAR 0 5
109138: PPUSH
109139: CALL_OW 307
109143: IFFALSE 108985
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
109145: LD_VAR 0 7
109149: PPUSH
109150: LD_VAR 0 4
109154: PPUSH
109155: LD_VAR 0 5
109159: PPUSH
109160: LD_VAR 0 8
109164: PUSH
109165: LD_VAR 0 3
109169: ARRAY
109170: PPUSH
109171: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
109175: LD_INT 35
109177: PPUSH
109178: CALL_OW 67
// until not HasTask ( tmp ) ;
109182: LD_VAR 0 7
109186: PPUSH
109187: CALL_OW 314
109191: NOT
109192: IFFALSE 109175
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
109194: LD_ADDR_EXP 197
109198: PUSH
109199: LD_EXP 197
109203: PPUSH
109204: LD_VAR 0 2
109208: PUSH
109209: LD_EXP 197
109213: PUSH
109214: LD_VAR 0 2
109218: ARRAY
109219: PUSH
109220: LD_INT 1
109222: PLUS
109223: PUSH
109224: EMPTY
109225: LIST
109226: LIST
109227: PPUSH
109228: LD_VAR 0 8
109232: PUSH
109233: LD_VAR 0 3
109237: ARRAY
109238: PPUSH
109239: CALL 24361 0 3
109243: ST_TO_ADDR
// end ;
109244: GO 108902
109246: POP
109247: POP
// MC_Reset ( i , 124 ) ;
109248: LD_VAR 0 2
109252: PPUSH
109253: LD_INT 124
109255: PPUSH
109256: CALL 92353 0 2
// end ; end ;
109260: GO 108657
109262: POP
109263: POP
// end ;
109264: LD_VAR 0 1
109268: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
109269: LD_INT 0
109271: PPUSH
109272: PPUSH
109273: PPUSH
// if not mc_bases then
109274: LD_EXP 161
109278: NOT
109279: IFFALSE 109283
// exit ;
109281: GO 109889
// for i = 1 to mc_bases do
109283: LD_ADDR_VAR 0 2
109287: PUSH
109288: DOUBLE
109289: LD_INT 1
109291: DEC
109292: ST_TO_ADDR
109293: LD_EXP 161
109297: PUSH
109298: FOR_TO
109299: IFFALSE 109887
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
109301: LD_ADDR_VAR 0 3
109305: PUSH
109306: LD_EXP 161
109310: PUSH
109311: LD_VAR 0 2
109315: ARRAY
109316: PPUSH
109317: LD_INT 25
109319: PUSH
109320: LD_INT 4
109322: PUSH
109323: EMPTY
109324: LIST
109325: LIST
109326: PPUSH
109327: CALL_OW 72
109331: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
109332: LD_VAR 0 3
109336: NOT
109337: PUSH
109338: LD_EXP 198
109342: PUSH
109343: LD_VAR 0 2
109347: ARRAY
109348: NOT
109349: OR
109350: PUSH
109351: LD_EXP 161
109355: PUSH
109356: LD_VAR 0 2
109360: ARRAY
109361: PPUSH
109362: LD_INT 2
109364: PUSH
109365: LD_INT 30
109367: PUSH
109368: LD_INT 0
109370: PUSH
109371: EMPTY
109372: LIST
109373: LIST
109374: PUSH
109375: LD_INT 30
109377: PUSH
109378: LD_INT 1
109380: PUSH
109381: EMPTY
109382: LIST
109383: LIST
109384: PUSH
109385: EMPTY
109386: LIST
109387: LIST
109388: LIST
109389: PPUSH
109390: CALL_OW 72
109394: NOT
109395: OR
109396: IFFALSE 109446
// begin if mc_deposits_finder [ i ] then
109398: LD_EXP 199
109402: PUSH
109403: LD_VAR 0 2
109407: ARRAY
109408: IFFALSE 109444
// begin MC_Reset ( i , 125 ) ;
109410: LD_VAR 0 2
109414: PPUSH
109415: LD_INT 125
109417: PPUSH
109418: CALL 92353 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
109422: LD_ADDR_EXP 199
109426: PUSH
109427: LD_EXP 199
109431: PPUSH
109432: LD_VAR 0 2
109436: PPUSH
109437: EMPTY
109438: PPUSH
109439: CALL_OW 1
109443: ST_TO_ADDR
// end ; continue ;
109444: GO 109298
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
109446: LD_EXP 198
109450: PUSH
109451: LD_VAR 0 2
109455: ARRAY
109456: PUSH
109457: LD_INT 1
109459: ARRAY
109460: PUSH
109461: LD_INT 3
109463: ARRAY
109464: PUSH
109465: LD_INT 1
109467: EQUAL
109468: PUSH
109469: LD_INT 20
109471: PPUSH
109472: LD_EXP 187
109476: PUSH
109477: LD_VAR 0 2
109481: ARRAY
109482: PPUSH
109483: CALL_OW 321
109487: PUSH
109488: LD_INT 2
109490: NONEQUAL
109491: AND
109492: IFFALSE 109542
// begin if mc_deposits_finder [ i ] then
109494: LD_EXP 199
109498: PUSH
109499: LD_VAR 0 2
109503: ARRAY
109504: IFFALSE 109540
// begin MC_Reset ( i , 125 ) ;
109506: LD_VAR 0 2
109510: PPUSH
109511: LD_INT 125
109513: PPUSH
109514: CALL 92353 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
109518: LD_ADDR_EXP 199
109522: PUSH
109523: LD_EXP 199
109527: PPUSH
109528: LD_VAR 0 2
109532: PPUSH
109533: EMPTY
109534: PPUSH
109535: CALL_OW 1
109539: ST_TO_ADDR
// end ; continue ;
109540: GO 109298
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
109542: LD_EXP 198
109546: PUSH
109547: LD_VAR 0 2
109551: ARRAY
109552: PUSH
109553: LD_INT 1
109555: ARRAY
109556: PUSH
109557: LD_INT 1
109559: ARRAY
109560: PPUSH
109561: LD_EXP 198
109565: PUSH
109566: LD_VAR 0 2
109570: ARRAY
109571: PUSH
109572: LD_INT 1
109574: ARRAY
109575: PUSH
109576: LD_INT 2
109578: ARRAY
109579: PPUSH
109580: LD_EXP 187
109584: PUSH
109585: LD_VAR 0 2
109589: ARRAY
109590: PPUSH
109591: CALL_OW 440
109595: IFFALSE 109638
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
109597: LD_ADDR_EXP 198
109601: PUSH
109602: LD_EXP 198
109606: PPUSH
109607: LD_VAR 0 2
109611: PPUSH
109612: LD_EXP 198
109616: PUSH
109617: LD_VAR 0 2
109621: ARRAY
109622: PPUSH
109623: LD_INT 1
109625: PPUSH
109626: CALL_OW 3
109630: PPUSH
109631: CALL_OW 1
109635: ST_TO_ADDR
109636: GO 109885
// begin if not mc_deposits_finder [ i ] then
109638: LD_EXP 199
109642: PUSH
109643: LD_VAR 0 2
109647: ARRAY
109648: NOT
109649: IFFALSE 109701
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
109651: LD_ADDR_EXP 199
109655: PUSH
109656: LD_EXP 199
109660: PPUSH
109661: LD_VAR 0 2
109665: PPUSH
109666: LD_VAR 0 3
109670: PUSH
109671: LD_INT 1
109673: ARRAY
109674: PUSH
109675: EMPTY
109676: LIST
109677: PPUSH
109678: CALL_OW 1
109682: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
109683: LD_VAR 0 3
109687: PUSH
109688: LD_INT 1
109690: ARRAY
109691: PPUSH
109692: LD_INT 125
109694: PPUSH
109695: CALL_OW 109
// end else
109699: GO 109885
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
109701: LD_EXP 199
109705: PUSH
109706: LD_VAR 0 2
109710: ARRAY
109711: PUSH
109712: LD_INT 1
109714: ARRAY
109715: PPUSH
109716: CALL_OW 310
109720: IFFALSE 109743
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
109722: LD_EXP 199
109726: PUSH
109727: LD_VAR 0 2
109731: ARRAY
109732: PUSH
109733: LD_INT 1
109735: ARRAY
109736: PPUSH
109737: CALL_OW 122
109741: GO 109885
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
109743: LD_EXP 199
109747: PUSH
109748: LD_VAR 0 2
109752: ARRAY
109753: PUSH
109754: LD_INT 1
109756: ARRAY
109757: PPUSH
109758: CALL_OW 314
109762: NOT
109763: PUSH
109764: LD_EXP 199
109768: PUSH
109769: LD_VAR 0 2
109773: ARRAY
109774: PUSH
109775: LD_INT 1
109777: ARRAY
109778: PPUSH
109779: LD_EXP 198
109783: PUSH
109784: LD_VAR 0 2
109788: ARRAY
109789: PUSH
109790: LD_INT 1
109792: ARRAY
109793: PUSH
109794: LD_INT 1
109796: ARRAY
109797: PPUSH
109798: LD_EXP 198
109802: PUSH
109803: LD_VAR 0 2
109807: ARRAY
109808: PUSH
109809: LD_INT 1
109811: ARRAY
109812: PUSH
109813: LD_INT 2
109815: ARRAY
109816: PPUSH
109817: CALL_OW 297
109821: PUSH
109822: LD_INT 6
109824: GREATER
109825: AND
109826: IFFALSE 109885
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
109828: LD_EXP 199
109832: PUSH
109833: LD_VAR 0 2
109837: ARRAY
109838: PUSH
109839: LD_INT 1
109841: ARRAY
109842: PPUSH
109843: LD_EXP 198
109847: PUSH
109848: LD_VAR 0 2
109852: ARRAY
109853: PUSH
109854: LD_INT 1
109856: ARRAY
109857: PUSH
109858: LD_INT 1
109860: ARRAY
109861: PPUSH
109862: LD_EXP 198
109866: PUSH
109867: LD_VAR 0 2
109871: ARRAY
109872: PUSH
109873: LD_INT 1
109875: ARRAY
109876: PUSH
109877: LD_INT 2
109879: ARRAY
109880: PPUSH
109881: CALL_OW 111
// end ; end ; end ;
109885: GO 109298
109887: POP
109888: POP
// end ;
109889: LD_VAR 0 1
109893: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
109894: LD_INT 0
109896: PPUSH
109897: PPUSH
109898: PPUSH
109899: PPUSH
109900: PPUSH
109901: PPUSH
109902: PPUSH
109903: PPUSH
109904: PPUSH
109905: PPUSH
109906: PPUSH
// if not mc_bases then
109907: LD_EXP 161
109911: NOT
109912: IFFALSE 109916
// exit ;
109914: GO 110856
// for i = 1 to mc_bases do
109916: LD_ADDR_VAR 0 2
109920: PUSH
109921: DOUBLE
109922: LD_INT 1
109924: DEC
109925: ST_TO_ADDR
109926: LD_EXP 161
109930: PUSH
109931: FOR_TO
109932: IFFALSE 110854
// begin if not mc_bases [ i ] or mc_scan [ i ] then
109934: LD_EXP 161
109938: PUSH
109939: LD_VAR 0 2
109943: ARRAY
109944: NOT
109945: PUSH
109946: LD_EXP 184
109950: PUSH
109951: LD_VAR 0 2
109955: ARRAY
109956: OR
109957: IFFALSE 109961
// continue ;
109959: GO 109931
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
109961: LD_ADDR_VAR 0 7
109965: PUSH
109966: LD_EXP 161
109970: PUSH
109971: LD_VAR 0 2
109975: ARRAY
109976: PUSH
109977: LD_INT 1
109979: ARRAY
109980: PPUSH
109981: CALL_OW 248
109985: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
109986: LD_VAR 0 7
109990: PUSH
109991: LD_INT 3
109993: EQUAL
109994: PUSH
109995: LD_EXP 180
109999: PUSH
110000: LD_VAR 0 2
110004: ARRAY
110005: PUSH
110006: LD_EXP 183
110010: PUSH
110011: LD_VAR 0 2
110015: ARRAY
110016: UNION
110017: PPUSH
110018: LD_INT 33
110020: PUSH
110021: LD_INT 2
110023: PUSH
110024: EMPTY
110025: LIST
110026: LIST
110027: PPUSH
110028: CALL_OW 72
110032: NOT
110033: OR
110034: IFFALSE 110038
// continue ;
110036: GO 109931
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
110038: LD_ADDR_VAR 0 9
110042: PUSH
110043: LD_EXP 161
110047: PUSH
110048: LD_VAR 0 2
110052: ARRAY
110053: PPUSH
110054: LD_INT 30
110056: PUSH
110057: LD_INT 36
110059: PUSH
110060: EMPTY
110061: LIST
110062: LIST
110063: PPUSH
110064: CALL_OW 72
110068: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
110069: LD_ADDR_VAR 0 10
110073: PUSH
110074: LD_EXP 180
110078: PUSH
110079: LD_VAR 0 2
110083: ARRAY
110084: PPUSH
110085: LD_INT 34
110087: PUSH
110088: LD_INT 31
110090: PUSH
110091: EMPTY
110092: LIST
110093: LIST
110094: PPUSH
110095: CALL_OW 72
110099: ST_TO_ADDR
// if not cts and not mcts then
110100: LD_VAR 0 9
110104: NOT
110105: PUSH
110106: LD_VAR 0 10
110110: NOT
110111: AND
110112: IFFALSE 110116
// continue ;
110114: GO 109931
// x := cts ;
110116: LD_ADDR_VAR 0 11
110120: PUSH
110121: LD_VAR 0 9
110125: ST_TO_ADDR
// if not x then
110126: LD_VAR 0 11
110130: NOT
110131: IFFALSE 110143
// x := mcts ;
110133: LD_ADDR_VAR 0 11
110137: PUSH
110138: LD_VAR 0 10
110142: ST_TO_ADDR
// if not x then
110143: LD_VAR 0 11
110147: NOT
110148: IFFALSE 110152
// continue ;
110150: GO 109931
// if mc_remote_driver [ i ] then
110152: LD_EXP 201
110156: PUSH
110157: LD_VAR 0 2
110161: ARRAY
110162: IFFALSE 110549
// for j in mc_remote_driver [ i ] do
110164: LD_ADDR_VAR 0 3
110168: PUSH
110169: LD_EXP 201
110173: PUSH
110174: LD_VAR 0 2
110178: ARRAY
110179: PUSH
110180: FOR_IN
110181: IFFALSE 110547
// begin if GetClass ( j ) <> 3 then
110183: LD_VAR 0 3
110187: PPUSH
110188: CALL_OW 257
110192: PUSH
110193: LD_INT 3
110195: NONEQUAL
110196: IFFALSE 110249
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
110198: LD_ADDR_EXP 201
110202: PUSH
110203: LD_EXP 201
110207: PPUSH
110208: LD_VAR 0 2
110212: PPUSH
110213: LD_EXP 201
110217: PUSH
110218: LD_VAR 0 2
110222: ARRAY
110223: PUSH
110224: LD_VAR 0 3
110228: DIFF
110229: PPUSH
110230: CALL_OW 1
110234: ST_TO_ADDR
// SetTag ( j , 0 ) ;
110235: LD_VAR 0 3
110239: PPUSH
110240: LD_INT 0
110242: PPUSH
110243: CALL_OW 109
// continue ;
110247: GO 110180
// end ; if UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) and not IsDriver ( j ) then
110249: LD_EXP 180
110253: PUSH
110254: LD_VAR 0 2
110258: ARRAY
110259: PPUSH
110260: LD_INT 34
110262: PUSH
110263: LD_INT 31
110265: PUSH
110266: EMPTY
110267: LIST
110268: LIST
110269: PUSH
110270: LD_INT 58
110272: PUSH
110273: EMPTY
110274: LIST
110275: PUSH
110276: EMPTY
110277: LIST
110278: LIST
110279: PPUSH
110280: CALL_OW 72
110284: PUSH
110285: LD_VAR 0 3
110289: PPUSH
110290: CALL 54308 0 1
110294: NOT
110295: AND
110296: IFFALSE 110367
// begin if IsInUnit ( j ) then
110298: LD_VAR 0 3
110302: PPUSH
110303: CALL_OW 310
110307: IFFALSE 110318
// ComExitBuilding ( j ) ;
110309: LD_VAR 0 3
110313: PPUSH
110314: CALL_OW 122
// AddComEnterUnit ( j , UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) [ 1 ] ) ;
110318: LD_VAR 0 3
110322: PPUSH
110323: LD_EXP 180
110327: PUSH
110328: LD_VAR 0 2
110332: ARRAY
110333: PPUSH
110334: LD_INT 34
110336: PUSH
110337: LD_INT 31
110339: PUSH
110340: EMPTY
110341: LIST
110342: LIST
110343: PUSH
110344: LD_INT 58
110346: PUSH
110347: EMPTY
110348: LIST
110349: PUSH
110350: EMPTY
110351: LIST
110352: LIST
110353: PPUSH
110354: CALL_OW 72
110358: PUSH
110359: LD_INT 1
110361: ARRAY
110362: PPUSH
110363: CALL_OW 180
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
110367: LD_VAR 0 3
110371: PPUSH
110372: CALL_OW 310
110376: NOT
110377: PUSH
110378: LD_VAR 0 3
110382: PPUSH
110383: CALL_OW 310
110387: PPUSH
110388: CALL_OW 266
110392: PUSH
110393: LD_INT 36
110395: NONEQUAL
110396: PUSH
110397: LD_VAR 0 3
110401: PPUSH
110402: CALL 54308 0 1
110406: NOT
110407: AND
110408: OR
110409: IFFALSE 110545
// begin if IsInUnit ( j ) then
110411: LD_VAR 0 3
110415: PPUSH
110416: CALL_OW 310
110420: IFFALSE 110431
// ComExitBuilding ( j ) ;
110422: LD_VAR 0 3
110426: PPUSH
110427: CALL_OW 122
// ct := 0 ;
110431: LD_ADDR_VAR 0 8
110435: PUSH
110436: LD_INT 0
110438: ST_TO_ADDR
// for k in x do
110439: LD_ADDR_VAR 0 4
110443: PUSH
110444: LD_VAR 0 11
110448: PUSH
110449: FOR_IN
110450: IFFALSE 110523
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
110452: LD_VAR 0 4
110456: PPUSH
110457: CALL_OW 264
110461: PUSH
110462: LD_INT 31
110464: EQUAL
110465: PUSH
110466: LD_VAR 0 4
110470: PPUSH
110471: CALL_OW 311
110475: NOT
110476: AND
110477: PUSH
110478: LD_VAR 0 4
110482: PPUSH
110483: CALL_OW 266
110487: PUSH
110488: LD_INT 36
110490: EQUAL
110491: PUSH
110492: LD_VAR 0 4
110496: PPUSH
110497: CALL_OW 313
110501: PUSH
110502: LD_INT 3
110504: LESS
110505: AND
110506: OR
110507: IFFALSE 110521
// begin ct := k ;
110509: LD_ADDR_VAR 0 8
110513: PUSH
110514: LD_VAR 0 4
110518: ST_TO_ADDR
// break ;
110519: GO 110523
// end ;
110521: GO 110449
110523: POP
110524: POP
// if ct then
110525: LD_VAR 0 8
110529: IFFALSE 110545
// ComEnterUnit ( j , ct ) ;
110531: LD_VAR 0 3
110535: PPUSH
110536: LD_VAR 0 8
110540: PPUSH
110541: CALL_OW 120
// end ; end ;
110545: GO 110180
110547: POP
110548: POP
// places := 0 ;
110549: LD_ADDR_VAR 0 5
110553: PUSH
110554: LD_INT 0
110556: ST_TO_ADDR
// for j = 1 to x do
110557: LD_ADDR_VAR 0 3
110561: PUSH
110562: DOUBLE
110563: LD_INT 1
110565: DEC
110566: ST_TO_ADDR
110567: LD_VAR 0 11
110571: PUSH
110572: FOR_TO
110573: IFFALSE 110649
// if GetWeapon ( x [ j ] ) = ar_control_tower then
110575: LD_VAR 0 11
110579: PUSH
110580: LD_VAR 0 3
110584: ARRAY
110585: PPUSH
110586: CALL_OW 264
110590: PUSH
110591: LD_INT 31
110593: EQUAL
110594: IFFALSE 110612
// places := places + 1 else
110596: LD_ADDR_VAR 0 5
110600: PUSH
110601: LD_VAR 0 5
110605: PUSH
110606: LD_INT 1
110608: PLUS
110609: ST_TO_ADDR
110610: GO 110647
// if GetBType ( x [ j ] ) = b_control_tower then
110612: LD_VAR 0 11
110616: PUSH
110617: LD_VAR 0 3
110621: ARRAY
110622: PPUSH
110623: CALL_OW 266
110627: PUSH
110628: LD_INT 36
110630: EQUAL
110631: IFFALSE 110647
// places := places + 3 ;
110633: LD_ADDR_VAR 0 5
110637: PUSH
110638: LD_VAR 0 5
110642: PUSH
110643: LD_INT 3
110645: PLUS
110646: ST_TO_ADDR
110647: GO 110572
110649: POP
110650: POP
// if places = 0 or places <= mc_remote_driver [ i ] then
110651: LD_VAR 0 5
110655: PUSH
110656: LD_INT 0
110658: EQUAL
110659: PUSH
110660: LD_VAR 0 5
110664: PUSH
110665: LD_EXP 201
110669: PUSH
110670: LD_VAR 0 2
110674: ARRAY
110675: LESSEQUAL
110676: OR
110677: IFFALSE 110681
// continue ;
110679: GO 109931
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
110681: LD_ADDR_VAR 0 6
110685: PUSH
110686: LD_EXP 161
110690: PUSH
110691: LD_VAR 0 2
110695: ARRAY
110696: PPUSH
110697: LD_INT 25
110699: PUSH
110700: LD_INT 3
110702: PUSH
110703: EMPTY
110704: LIST
110705: LIST
110706: PPUSH
110707: CALL_OW 72
110711: PUSH
110712: LD_EXP 201
110716: PUSH
110717: LD_VAR 0 2
110721: ARRAY
110722: DIFF
110723: PPUSH
110724: LD_INT 3
110726: PPUSH
110727: CALL 55208 0 2
110731: ST_TO_ADDR
// for j in tmp do
110732: LD_ADDR_VAR 0 3
110736: PUSH
110737: LD_VAR 0 6
110741: PUSH
110742: FOR_IN
110743: IFFALSE 110778
// if GetTag ( j ) > 0 then
110745: LD_VAR 0 3
110749: PPUSH
110750: CALL_OW 110
110754: PUSH
110755: LD_INT 0
110757: GREATER
110758: IFFALSE 110776
// tmp := tmp diff j ;
110760: LD_ADDR_VAR 0 6
110764: PUSH
110765: LD_VAR 0 6
110769: PUSH
110770: LD_VAR 0 3
110774: DIFF
110775: ST_TO_ADDR
110776: GO 110742
110778: POP
110779: POP
// if not tmp then
110780: LD_VAR 0 6
110784: NOT
110785: IFFALSE 110789
// continue ;
110787: GO 109931
// if places then
110789: LD_VAR 0 5
110793: IFFALSE 110852
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
110795: LD_ADDR_EXP 201
110799: PUSH
110800: LD_EXP 201
110804: PPUSH
110805: LD_VAR 0 2
110809: PPUSH
110810: LD_EXP 201
110814: PUSH
110815: LD_VAR 0 2
110819: ARRAY
110820: PUSH
110821: LD_VAR 0 6
110825: PUSH
110826: LD_INT 1
110828: ARRAY
110829: UNION
110830: PPUSH
110831: CALL_OW 1
110835: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
110836: LD_VAR 0 6
110840: PUSH
110841: LD_INT 1
110843: ARRAY
110844: PPUSH
110845: LD_INT 126
110847: PPUSH
110848: CALL_OW 109
// end ; end ;
110852: GO 109931
110854: POP
110855: POP
// end ;
110856: LD_VAR 0 1
110860: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
110861: LD_INT 0
110863: PPUSH
110864: PPUSH
110865: PPUSH
110866: PPUSH
110867: PPUSH
110868: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
110869: LD_VAR 0 1
110873: NOT
110874: PUSH
110875: LD_VAR 0 2
110879: NOT
110880: OR
110881: PUSH
110882: LD_VAR 0 3
110886: NOT
110887: OR
110888: PUSH
110889: LD_VAR 0 4
110893: PUSH
110894: LD_INT 1
110896: PUSH
110897: LD_INT 2
110899: PUSH
110900: LD_INT 3
110902: PUSH
110903: LD_INT 4
110905: PUSH
110906: LD_INT 5
110908: PUSH
110909: LD_INT 8
110911: PUSH
110912: LD_INT 9
110914: PUSH
110915: LD_INT 15
110917: PUSH
110918: LD_INT 16
110920: PUSH
110921: EMPTY
110922: LIST
110923: LIST
110924: LIST
110925: LIST
110926: LIST
110927: LIST
110928: LIST
110929: LIST
110930: LIST
110931: IN
110932: NOT
110933: OR
110934: IFFALSE 110938
// exit ;
110936: GO 111838
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
110938: LD_ADDR_VAR 0 2
110942: PUSH
110943: LD_VAR 0 2
110947: PPUSH
110948: LD_INT 21
110950: PUSH
110951: LD_INT 3
110953: PUSH
110954: EMPTY
110955: LIST
110956: LIST
110957: PUSH
110958: LD_INT 24
110960: PUSH
110961: LD_INT 250
110963: PUSH
110964: EMPTY
110965: LIST
110966: LIST
110967: PUSH
110968: EMPTY
110969: LIST
110970: LIST
110971: PPUSH
110972: CALL_OW 72
110976: ST_TO_ADDR
// case class of 1 , 15 :
110977: LD_VAR 0 4
110981: PUSH
110982: LD_INT 1
110984: DOUBLE
110985: EQUAL
110986: IFTRUE 110996
110988: LD_INT 15
110990: DOUBLE
110991: EQUAL
110992: IFTRUE 110996
110994: GO 111081
110996: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
110997: LD_ADDR_VAR 0 8
111001: PUSH
111002: LD_VAR 0 2
111006: PPUSH
111007: LD_INT 2
111009: PUSH
111010: LD_INT 30
111012: PUSH
111013: LD_INT 32
111015: PUSH
111016: EMPTY
111017: LIST
111018: LIST
111019: PUSH
111020: LD_INT 30
111022: PUSH
111023: LD_INT 31
111025: PUSH
111026: EMPTY
111027: LIST
111028: LIST
111029: PUSH
111030: EMPTY
111031: LIST
111032: LIST
111033: LIST
111034: PPUSH
111035: CALL_OW 72
111039: PUSH
111040: LD_VAR 0 2
111044: PPUSH
111045: LD_INT 2
111047: PUSH
111048: LD_INT 30
111050: PUSH
111051: LD_INT 4
111053: PUSH
111054: EMPTY
111055: LIST
111056: LIST
111057: PUSH
111058: LD_INT 30
111060: PUSH
111061: LD_INT 5
111063: PUSH
111064: EMPTY
111065: LIST
111066: LIST
111067: PUSH
111068: EMPTY
111069: LIST
111070: LIST
111071: LIST
111072: PPUSH
111073: CALL_OW 72
111077: ADD
111078: ST_TO_ADDR
111079: GO 111327
111081: LD_INT 2
111083: DOUBLE
111084: EQUAL
111085: IFTRUE 111095
111087: LD_INT 16
111089: DOUBLE
111090: EQUAL
111091: IFTRUE 111095
111093: GO 111141
111095: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
111096: LD_ADDR_VAR 0 8
111100: PUSH
111101: LD_VAR 0 2
111105: PPUSH
111106: LD_INT 2
111108: PUSH
111109: LD_INT 30
111111: PUSH
111112: LD_INT 0
111114: PUSH
111115: EMPTY
111116: LIST
111117: LIST
111118: PUSH
111119: LD_INT 30
111121: PUSH
111122: LD_INT 1
111124: PUSH
111125: EMPTY
111126: LIST
111127: LIST
111128: PUSH
111129: EMPTY
111130: LIST
111131: LIST
111132: LIST
111133: PPUSH
111134: CALL_OW 72
111138: ST_TO_ADDR
111139: GO 111327
111141: LD_INT 3
111143: DOUBLE
111144: EQUAL
111145: IFTRUE 111149
111147: GO 111195
111149: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
111150: LD_ADDR_VAR 0 8
111154: PUSH
111155: LD_VAR 0 2
111159: PPUSH
111160: LD_INT 2
111162: PUSH
111163: LD_INT 30
111165: PUSH
111166: LD_INT 2
111168: PUSH
111169: EMPTY
111170: LIST
111171: LIST
111172: PUSH
111173: LD_INT 30
111175: PUSH
111176: LD_INT 3
111178: PUSH
111179: EMPTY
111180: LIST
111181: LIST
111182: PUSH
111183: EMPTY
111184: LIST
111185: LIST
111186: LIST
111187: PPUSH
111188: CALL_OW 72
111192: ST_TO_ADDR
111193: GO 111327
111195: LD_INT 4
111197: DOUBLE
111198: EQUAL
111199: IFTRUE 111203
111201: GO 111260
111203: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
111204: LD_ADDR_VAR 0 8
111208: PUSH
111209: LD_VAR 0 2
111213: PPUSH
111214: LD_INT 2
111216: PUSH
111217: LD_INT 30
111219: PUSH
111220: LD_INT 6
111222: PUSH
111223: EMPTY
111224: LIST
111225: LIST
111226: PUSH
111227: LD_INT 30
111229: PUSH
111230: LD_INT 7
111232: PUSH
111233: EMPTY
111234: LIST
111235: LIST
111236: PUSH
111237: LD_INT 30
111239: PUSH
111240: LD_INT 8
111242: PUSH
111243: EMPTY
111244: LIST
111245: LIST
111246: PUSH
111247: EMPTY
111248: LIST
111249: LIST
111250: LIST
111251: LIST
111252: PPUSH
111253: CALL_OW 72
111257: ST_TO_ADDR
111258: GO 111327
111260: LD_INT 5
111262: DOUBLE
111263: EQUAL
111264: IFTRUE 111280
111266: LD_INT 8
111268: DOUBLE
111269: EQUAL
111270: IFTRUE 111280
111272: LD_INT 9
111274: DOUBLE
111275: EQUAL
111276: IFTRUE 111280
111278: GO 111326
111280: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
111281: LD_ADDR_VAR 0 8
111285: PUSH
111286: LD_VAR 0 2
111290: PPUSH
111291: LD_INT 2
111293: PUSH
111294: LD_INT 30
111296: PUSH
111297: LD_INT 4
111299: PUSH
111300: EMPTY
111301: LIST
111302: LIST
111303: PUSH
111304: LD_INT 30
111306: PUSH
111307: LD_INT 5
111309: PUSH
111310: EMPTY
111311: LIST
111312: LIST
111313: PUSH
111314: EMPTY
111315: LIST
111316: LIST
111317: LIST
111318: PPUSH
111319: CALL_OW 72
111323: ST_TO_ADDR
111324: GO 111327
111326: POP
// if not tmp then
111327: LD_VAR 0 8
111331: NOT
111332: IFFALSE 111336
// exit ;
111334: GO 111838
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
111336: LD_VAR 0 4
111340: PUSH
111341: LD_INT 1
111343: PUSH
111344: LD_INT 15
111346: PUSH
111347: EMPTY
111348: LIST
111349: LIST
111350: IN
111351: PUSH
111352: LD_EXP 170
111356: PUSH
111357: LD_VAR 0 1
111361: ARRAY
111362: AND
111363: IFFALSE 111519
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
111365: LD_ADDR_VAR 0 9
111369: PUSH
111370: LD_EXP 170
111374: PUSH
111375: LD_VAR 0 1
111379: ARRAY
111380: PUSH
111381: LD_INT 1
111383: ARRAY
111384: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
111385: LD_VAR 0 9
111389: PUSH
111390: LD_EXP 171
111394: PUSH
111395: LD_VAR 0 1
111399: ARRAY
111400: IN
111401: NOT
111402: IFFALSE 111517
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
111404: LD_ADDR_EXP 171
111408: PUSH
111409: LD_EXP 171
111413: PPUSH
111414: LD_VAR 0 1
111418: PUSH
111419: LD_EXP 171
111423: PUSH
111424: LD_VAR 0 1
111428: ARRAY
111429: PUSH
111430: LD_INT 1
111432: PLUS
111433: PUSH
111434: EMPTY
111435: LIST
111436: LIST
111437: PPUSH
111438: LD_VAR 0 9
111442: PPUSH
111443: CALL 24361 0 3
111447: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
111448: LD_ADDR_EXP 170
111452: PUSH
111453: LD_EXP 170
111457: PPUSH
111458: LD_VAR 0 1
111462: PPUSH
111463: LD_EXP 170
111467: PUSH
111468: LD_VAR 0 1
111472: ARRAY
111473: PUSH
111474: LD_VAR 0 9
111478: DIFF
111479: PPUSH
111480: CALL_OW 1
111484: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
111485: LD_VAR 0 3
111489: PPUSH
111490: LD_EXP 171
111494: PUSH
111495: LD_VAR 0 1
111499: ARRAY
111500: PUSH
111501: LD_EXP 171
111505: PUSH
111506: LD_VAR 0 1
111510: ARRAY
111511: ARRAY
111512: PPUSH
111513: CALL_OW 120
// end ; exit ;
111517: GO 111838
// end ; if tmp > 1 then
111519: LD_VAR 0 8
111523: PUSH
111524: LD_INT 1
111526: GREATER
111527: IFFALSE 111631
// for i = 2 to tmp do
111529: LD_ADDR_VAR 0 6
111533: PUSH
111534: DOUBLE
111535: LD_INT 2
111537: DEC
111538: ST_TO_ADDR
111539: LD_VAR 0 8
111543: PUSH
111544: FOR_TO
111545: IFFALSE 111629
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
111547: LD_VAR 0 8
111551: PUSH
111552: LD_VAR 0 6
111556: ARRAY
111557: PPUSH
111558: CALL_OW 461
111562: PUSH
111563: LD_INT 6
111565: EQUAL
111566: IFFALSE 111627
// begin x := tmp [ i ] ;
111568: LD_ADDR_VAR 0 9
111572: PUSH
111573: LD_VAR 0 8
111577: PUSH
111578: LD_VAR 0 6
111582: ARRAY
111583: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
111584: LD_ADDR_VAR 0 8
111588: PUSH
111589: LD_VAR 0 8
111593: PPUSH
111594: LD_VAR 0 6
111598: PPUSH
111599: CALL_OW 3
111603: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
111604: LD_ADDR_VAR 0 8
111608: PUSH
111609: LD_VAR 0 8
111613: PPUSH
111614: LD_INT 1
111616: PPUSH
111617: LD_VAR 0 9
111621: PPUSH
111622: CALL_OW 2
111626: ST_TO_ADDR
// end ;
111627: GO 111544
111629: POP
111630: POP
// for i in tmp do
111631: LD_ADDR_VAR 0 6
111635: PUSH
111636: LD_VAR 0 8
111640: PUSH
111641: FOR_IN
111642: IFFALSE 111711
// begin if ( UnitsInside ( i ) < 6 and not GetBType ( i ) in [ b_breastwork , b_bunker ] ) or UnitsInside ( i ) = 0 then
111644: LD_VAR 0 6
111648: PPUSH
111649: CALL_OW 313
111653: PUSH
111654: LD_INT 6
111656: LESS
111657: PUSH
111658: LD_VAR 0 6
111662: PPUSH
111663: CALL_OW 266
111667: PUSH
111668: LD_INT 31
111670: PUSH
111671: LD_INT 32
111673: PUSH
111674: EMPTY
111675: LIST
111676: LIST
111677: IN
111678: NOT
111679: AND
111680: PUSH
111681: LD_VAR 0 6
111685: PPUSH
111686: CALL_OW 313
111690: PUSH
111691: LD_INT 0
111693: EQUAL
111694: OR
111695: IFFALSE 111709
// begin j := i ;
111697: LD_ADDR_VAR 0 7
111701: PUSH
111702: LD_VAR 0 6
111706: ST_TO_ADDR
// break ;
111707: GO 111711
// end ; end ;
111709: GO 111641
111711: POP
111712: POP
// if j then
111713: LD_VAR 0 7
111717: IFFALSE 111735
// ComEnterUnit ( unit , j ) else
111719: LD_VAR 0 3
111723: PPUSH
111724: LD_VAR 0 7
111728: PPUSH
111729: CALL_OW 120
111733: GO 111838
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
111735: LD_ADDR_VAR 0 10
111739: PUSH
111740: LD_VAR 0 2
111744: PPUSH
111745: LD_INT 2
111747: PUSH
111748: LD_INT 30
111750: PUSH
111751: LD_INT 0
111753: PUSH
111754: EMPTY
111755: LIST
111756: LIST
111757: PUSH
111758: LD_INT 30
111760: PUSH
111761: LD_INT 1
111763: PUSH
111764: EMPTY
111765: LIST
111766: LIST
111767: PUSH
111768: EMPTY
111769: LIST
111770: LIST
111771: LIST
111772: PPUSH
111773: CALL_OW 72
111777: ST_TO_ADDR
// if depot then
111778: LD_VAR 0 10
111782: IFFALSE 111838
// begin depot := NearestUnitToUnit ( depot , unit ) ;
111784: LD_ADDR_VAR 0 10
111788: PUSH
111789: LD_VAR 0 10
111793: PPUSH
111794: LD_VAR 0 3
111798: PPUSH
111799: CALL_OW 74
111803: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
111804: LD_VAR 0 3
111808: PPUSH
111809: LD_VAR 0 10
111813: PPUSH
111814: CALL_OW 296
111818: PUSH
111819: LD_INT 10
111821: GREATER
111822: IFFALSE 111838
// ComStandNearbyBuilding ( unit , depot ) ;
111824: LD_VAR 0 3
111828: PPUSH
111829: LD_VAR 0 10
111833: PPUSH
111834: CALL 20788 0 2
// end ; end ; end ;
111838: LD_VAR 0 5
111842: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
111843: LD_INT 0
111845: PPUSH
111846: PPUSH
111847: PPUSH
111848: PPUSH
// if not mc_bases then
111849: LD_EXP 161
111853: NOT
111854: IFFALSE 111858
// exit ;
111856: GO 112097
// for i = 1 to mc_bases do
111858: LD_ADDR_VAR 0 2
111862: PUSH
111863: DOUBLE
111864: LD_INT 1
111866: DEC
111867: ST_TO_ADDR
111868: LD_EXP 161
111872: PUSH
111873: FOR_TO
111874: IFFALSE 112095
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
111876: LD_ADDR_VAR 0 4
111880: PUSH
111881: LD_EXP 161
111885: PUSH
111886: LD_VAR 0 2
111890: ARRAY
111891: PPUSH
111892: LD_INT 21
111894: PUSH
111895: LD_INT 1
111897: PUSH
111898: EMPTY
111899: LIST
111900: LIST
111901: PPUSH
111902: CALL_OW 72
111906: PUSH
111907: LD_EXP 190
111911: PUSH
111912: LD_VAR 0 2
111916: ARRAY
111917: UNION
111918: ST_TO_ADDR
// if not tmp then
111919: LD_VAR 0 4
111923: NOT
111924: IFFALSE 111928
// continue ;
111926: GO 111873
// for j in tmp do
111928: LD_ADDR_VAR 0 3
111932: PUSH
111933: LD_VAR 0 4
111937: PUSH
111938: FOR_IN
111939: IFFALSE 112091
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
111941: LD_VAR 0 3
111945: PPUSH
111946: CALL_OW 110
111950: NOT
111951: PUSH
111952: LD_VAR 0 3
111956: PPUSH
111957: CALL_OW 314
111961: NOT
111962: AND
111963: PUSH
111964: LD_VAR 0 3
111968: PPUSH
111969: CALL_OW 311
111973: NOT
111974: AND
111975: PUSH
111976: LD_VAR 0 3
111980: PPUSH
111981: CALL_OW 310
111985: NOT
111986: AND
111987: PUSH
111988: LD_VAR 0 3
111992: PUSH
111993: LD_EXP 164
111997: PUSH
111998: LD_VAR 0 2
112002: ARRAY
112003: PUSH
112004: LD_INT 1
112006: ARRAY
112007: IN
112008: NOT
112009: AND
112010: PUSH
112011: LD_VAR 0 3
112015: PUSH
112016: LD_EXP 164
112020: PUSH
112021: LD_VAR 0 2
112025: ARRAY
112026: PUSH
112027: LD_INT 2
112029: ARRAY
112030: IN
112031: NOT
112032: AND
112033: PUSH
112034: LD_VAR 0 3
112038: PUSH
112039: LD_EXP 173
112043: PUSH
112044: LD_VAR 0 2
112048: ARRAY
112049: IN
112050: NOT
112051: AND
112052: IFFALSE 112089
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
112054: LD_VAR 0 2
112058: PPUSH
112059: LD_EXP 161
112063: PUSH
112064: LD_VAR 0 2
112068: ARRAY
112069: PPUSH
112070: LD_VAR 0 3
112074: PPUSH
112075: LD_VAR 0 3
112079: PPUSH
112080: CALL_OW 257
112084: PPUSH
112085: CALL 110861 0 4
// end ;
112089: GO 111938
112091: POP
112092: POP
// end ;
112093: GO 111873
112095: POP
112096: POP
// end ;
112097: LD_VAR 0 1
112101: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , x , j ; begin
112102: LD_INT 0
112104: PPUSH
112105: PPUSH
112106: PPUSH
112107: PPUSH
112108: PPUSH
112109: PPUSH
// if not mc_bases [ base ] then
112110: LD_EXP 161
112114: PUSH
112115: LD_VAR 0 1
112119: ARRAY
112120: NOT
112121: IFFALSE 112125
// exit ;
112123: GO 112307
// tmp := [ ] ;
112125: LD_ADDR_VAR 0 6
112129: PUSH
112130: EMPTY
112131: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
112132: LD_ADDR_VAR 0 7
112136: PUSH
112137: LD_VAR 0 3
112141: PPUSH
112142: LD_INT 0
112144: PPUSH
112145: CALL_OW 517
112149: ST_TO_ADDR
// if not list then
112150: LD_VAR 0 7
112154: NOT
112155: IFFALSE 112159
// exit ;
112157: GO 112307
// for i = 1 to amount do
112159: LD_ADDR_VAR 0 5
112163: PUSH
112164: DOUBLE
112165: LD_INT 1
112167: DEC
112168: ST_TO_ADDR
112169: LD_VAR 0 2
112173: PUSH
112174: FOR_TO
112175: IFFALSE 112255
// begin x := rand ( 1 , list [ 1 ] ) ;
112177: LD_ADDR_VAR 0 8
112181: PUSH
112182: LD_INT 1
112184: PPUSH
112185: LD_VAR 0 7
112189: PUSH
112190: LD_INT 1
112192: ARRAY
112193: PPUSH
112194: CALL_OW 12
112198: ST_TO_ADDR
// tmp := Replace ( tmp , i , [ list [ 1 ] [ x ] , list [ 2 ] [ x ] ] ) ;
112199: LD_ADDR_VAR 0 6
112203: PUSH
112204: LD_VAR 0 6
112208: PPUSH
112209: LD_VAR 0 5
112213: PPUSH
112214: LD_VAR 0 7
112218: PUSH
112219: LD_INT 1
112221: ARRAY
112222: PUSH
112223: LD_VAR 0 8
112227: ARRAY
112228: PUSH
112229: LD_VAR 0 7
112233: PUSH
112234: LD_INT 2
112236: ARRAY
112237: PUSH
112238: LD_VAR 0 8
112242: ARRAY
112243: PUSH
112244: EMPTY
112245: LIST
112246: LIST
112247: PPUSH
112248: CALL_OW 1
112252: ST_TO_ADDR
// end ;
112253: GO 112174
112255: POP
112256: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
112257: LD_ADDR_EXP 174
112261: PUSH
112262: LD_EXP 174
112266: PPUSH
112267: LD_VAR 0 1
112271: PPUSH
112272: LD_VAR 0 6
112276: PPUSH
112277: CALL_OW 1
112281: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
112282: LD_ADDR_EXP 176
112286: PUSH
112287: LD_EXP 176
112291: PPUSH
112292: LD_VAR 0 1
112296: PPUSH
112297: LD_VAR 0 3
112301: PPUSH
112302: CALL_OW 1
112306: ST_TO_ADDR
// end ;
112307: LD_VAR 0 4
112311: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
112312: LD_INT 0
112314: PPUSH
// if not mc_bases [ base ] then
112315: LD_EXP 161
112319: PUSH
112320: LD_VAR 0 1
112324: ARRAY
112325: NOT
112326: IFFALSE 112330
// exit ;
112328: GO 112355
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
112330: LD_ADDR_EXP 166
112334: PUSH
112335: LD_EXP 166
112339: PPUSH
112340: LD_VAR 0 1
112344: PPUSH
112345: LD_VAR 0 2
112349: PPUSH
112350: CALL_OW 1
112354: ST_TO_ADDR
// end ;
112355: LD_VAR 0 3
112359: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
112360: LD_INT 0
112362: PPUSH
// if not mc_bases [ base ] then
112363: LD_EXP 161
112367: PUSH
112368: LD_VAR 0 1
112372: ARRAY
112373: NOT
112374: IFFALSE 112378
// exit ;
112376: GO 112415
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
112378: LD_ADDR_EXP 166
112382: PUSH
112383: LD_EXP 166
112387: PPUSH
112388: LD_VAR 0 1
112392: PPUSH
112393: LD_EXP 166
112397: PUSH
112398: LD_VAR 0 1
112402: ARRAY
112403: PUSH
112404: LD_VAR 0 2
112408: UNION
112409: PPUSH
112410: CALL_OW 1
112414: ST_TO_ADDR
// end ;
112415: LD_VAR 0 3
112419: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
112420: LD_INT 0
112422: PPUSH
// if not mc_bases [ base ] then
112423: LD_EXP 161
112427: PUSH
112428: LD_VAR 0 1
112432: ARRAY
112433: NOT
112434: IFFALSE 112438
// exit ;
112436: GO 112463
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
112438: LD_ADDR_EXP 182
112442: PUSH
112443: LD_EXP 182
112447: PPUSH
112448: LD_VAR 0 1
112452: PPUSH
112453: LD_VAR 0 2
112457: PPUSH
112458: CALL_OW 1
112462: ST_TO_ADDR
// end ;
112463: LD_VAR 0 3
112467: RET
// export function MC_InsertProduceList ( base , components ) ; begin
112468: LD_INT 0
112470: PPUSH
// if not mc_bases [ base ] then
112471: LD_EXP 161
112475: PUSH
112476: LD_VAR 0 1
112480: ARRAY
112481: NOT
112482: IFFALSE 112486
// exit ;
112484: GO 112523
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
112486: LD_ADDR_EXP 182
112490: PUSH
112491: LD_EXP 182
112495: PPUSH
112496: LD_VAR 0 1
112500: PPUSH
112501: LD_EXP 182
112505: PUSH
112506: LD_VAR 0 1
112510: ARRAY
112511: PUSH
112512: LD_VAR 0 2
112516: ADD
112517: PPUSH
112518: CALL_OW 1
112522: ST_TO_ADDR
// end ;
112523: LD_VAR 0 3
112527: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
112528: LD_INT 0
112530: PPUSH
// if not mc_bases [ base ] then
112531: LD_EXP 161
112535: PUSH
112536: LD_VAR 0 1
112540: ARRAY
112541: NOT
112542: IFFALSE 112546
// exit ;
112544: GO 112600
// mc_defender := Replace ( mc_defender , base , deflist ) ;
112546: LD_ADDR_EXP 183
112550: PUSH
112551: LD_EXP 183
112555: PPUSH
112556: LD_VAR 0 1
112560: PPUSH
112561: LD_VAR 0 2
112565: PPUSH
112566: CALL_OW 1
112570: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
112571: LD_ADDR_EXP 172
112575: PUSH
112576: LD_EXP 172
112580: PPUSH
112581: LD_VAR 0 1
112585: PPUSH
112586: LD_VAR 0 2
112590: PUSH
112591: LD_INT 0
112593: PLUS
112594: PPUSH
112595: CALL_OW 1
112599: ST_TO_ADDR
// end ;
112600: LD_VAR 0 3
112604: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
112605: LD_INT 0
112607: PPUSH
// if not mc_bases [ base ] then
112608: LD_EXP 161
112612: PUSH
112613: LD_VAR 0 1
112617: ARRAY
112618: NOT
112619: IFFALSE 112623
// exit ;
112621: GO 112648
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
112623: LD_ADDR_EXP 172
112627: PUSH
112628: LD_EXP 172
112632: PPUSH
112633: LD_VAR 0 1
112637: PPUSH
112638: LD_VAR 0 2
112642: PPUSH
112643: CALL_OW 1
112647: ST_TO_ADDR
// end ;
112648: LD_VAR 0 3
112652: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
112653: LD_INT 0
112655: PPUSH
112656: PPUSH
112657: PPUSH
112658: PPUSH
// if not mc_bases [ base ] then
112659: LD_EXP 161
112663: PUSH
112664: LD_VAR 0 1
112668: ARRAY
112669: NOT
112670: IFFALSE 112674
// exit ;
112672: GO 112739
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
112674: LD_ADDR_EXP 181
112678: PUSH
112679: LD_EXP 181
112683: PPUSH
112684: LD_VAR 0 1
112688: PUSH
112689: LD_EXP 181
112693: PUSH
112694: LD_VAR 0 1
112698: ARRAY
112699: PUSH
112700: LD_INT 1
112702: PLUS
112703: PUSH
112704: EMPTY
112705: LIST
112706: LIST
112707: PPUSH
112708: LD_VAR 0 1
112712: PUSH
112713: LD_VAR 0 2
112717: PUSH
112718: LD_VAR 0 3
112722: PUSH
112723: LD_VAR 0 4
112727: PUSH
112728: EMPTY
112729: LIST
112730: LIST
112731: LIST
112732: LIST
112733: PPUSH
112734: CALL 24361 0 3
112738: ST_TO_ADDR
// end ;
112739: LD_VAR 0 5
112743: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
112744: LD_INT 0
112746: PPUSH
// if not mc_bases [ base ] then
112747: LD_EXP 161
112751: PUSH
112752: LD_VAR 0 1
112756: ARRAY
112757: NOT
112758: IFFALSE 112762
// exit ;
112760: GO 112787
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
112762: LD_ADDR_EXP 198
112766: PUSH
112767: LD_EXP 198
112771: PPUSH
112772: LD_VAR 0 1
112776: PPUSH
112777: LD_VAR 0 2
112781: PPUSH
112782: CALL_OW 1
112786: ST_TO_ADDR
// end ;
112787: LD_VAR 0 3
112791: RET
// export function MC_GetMinesField ( base ) ; begin
112792: LD_INT 0
112794: PPUSH
// result := mc_mines [ base ] ;
112795: LD_ADDR_VAR 0 2
112799: PUSH
112800: LD_EXP 174
112804: PUSH
112805: LD_VAR 0 1
112809: ARRAY
112810: ST_TO_ADDR
// end ;
112811: LD_VAR 0 2
112815: RET
// export function MC_GetProduceList ( base ) ; begin
112816: LD_INT 0
112818: PPUSH
// result := mc_produce [ base ] ;
112819: LD_ADDR_VAR 0 2
112823: PUSH
112824: LD_EXP 182
112828: PUSH
112829: LD_VAR 0 1
112833: ARRAY
112834: ST_TO_ADDR
// end ;
112835: LD_VAR 0 2
112839: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
112840: LD_INT 0
112842: PPUSH
112843: PPUSH
// if not mc_bases then
112844: LD_EXP 161
112848: NOT
112849: IFFALSE 112853
// exit ;
112851: GO 112918
// if mc_bases [ base ] then
112853: LD_EXP 161
112857: PUSH
112858: LD_VAR 0 1
112862: ARRAY
112863: IFFALSE 112918
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
112865: LD_ADDR_VAR 0 3
112869: PUSH
112870: LD_EXP 161
112874: PUSH
112875: LD_VAR 0 1
112879: ARRAY
112880: PPUSH
112881: LD_INT 30
112883: PUSH
112884: LD_VAR 0 2
112888: PUSH
112889: EMPTY
112890: LIST
112891: LIST
112892: PPUSH
112893: CALL_OW 72
112897: ST_TO_ADDR
// if result then
112898: LD_VAR 0 3
112902: IFFALSE 112918
// result := result [ 1 ] ;
112904: LD_ADDR_VAR 0 3
112908: PUSH
112909: LD_VAR 0 3
112913: PUSH
112914: LD_INT 1
112916: ARRAY
112917: ST_TO_ADDR
// end ; end ;
112918: LD_VAR 0 3
112922: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
112923: LD_INT 0
112925: PPUSH
112926: PPUSH
// if not mc_bases then
112927: LD_EXP 161
112931: NOT
112932: IFFALSE 112936
// exit ;
112934: GO 112981
// if mc_bases [ base ] then
112936: LD_EXP 161
112940: PUSH
112941: LD_VAR 0 1
112945: ARRAY
112946: IFFALSE 112981
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
112948: LD_ADDR_VAR 0 3
112952: PUSH
112953: LD_EXP 161
112957: PUSH
112958: LD_VAR 0 1
112962: ARRAY
112963: PPUSH
112964: LD_INT 30
112966: PUSH
112967: LD_VAR 0 2
112971: PUSH
112972: EMPTY
112973: LIST
112974: LIST
112975: PPUSH
112976: CALL_OW 72
112980: ST_TO_ADDR
// end ;
112981: LD_VAR 0 3
112985: RET
// export function MC_SetTame ( base , area ) ; begin
112986: LD_INT 0
112988: PPUSH
// if not mc_bases or not base then
112989: LD_EXP 161
112993: NOT
112994: PUSH
112995: LD_VAR 0 1
112999: NOT
113000: OR
113001: IFFALSE 113005
// exit ;
113003: GO 113030
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
113005: LD_ADDR_EXP 189
113009: PUSH
113010: LD_EXP 189
113014: PPUSH
113015: LD_VAR 0 1
113019: PPUSH
113020: LD_VAR 0 2
113024: PPUSH
113025: CALL_OW 1
113029: ST_TO_ADDR
// end ;
113030: LD_VAR 0 3
113034: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
113035: LD_INT 0
113037: PPUSH
113038: PPUSH
// if not mc_bases or not base then
113039: LD_EXP 161
113043: NOT
113044: PUSH
113045: LD_VAR 0 1
113049: NOT
113050: OR
113051: IFFALSE 113055
// exit ;
113053: GO 113157
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
113055: LD_ADDR_VAR 0 4
113059: PUSH
113060: LD_EXP 161
113064: PUSH
113065: LD_VAR 0 1
113069: ARRAY
113070: PPUSH
113071: LD_INT 30
113073: PUSH
113074: LD_VAR 0 2
113078: PUSH
113079: EMPTY
113080: LIST
113081: LIST
113082: PPUSH
113083: CALL_OW 72
113087: ST_TO_ADDR
// if not tmp then
113088: LD_VAR 0 4
113092: NOT
113093: IFFALSE 113097
// exit ;
113095: GO 113157
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
113097: LD_ADDR_EXP 193
113101: PUSH
113102: LD_EXP 193
113106: PPUSH
113107: LD_VAR 0 1
113111: PPUSH
113112: LD_EXP 193
113116: PUSH
113117: LD_VAR 0 1
113121: ARRAY
113122: PPUSH
113123: LD_EXP 193
113127: PUSH
113128: LD_VAR 0 1
113132: ARRAY
113133: PUSH
113134: LD_INT 1
113136: PLUS
113137: PPUSH
113138: LD_VAR 0 4
113142: PUSH
113143: LD_INT 1
113145: ARRAY
113146: PPUSH
113147: CALL_OW 2
113151: PPUSH
113152: CALL_OW 1
113156: ST_TO_ADDR
// end ;
113157: LD_VAR 0 3
113161: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
113162: LD_INT 0
113164: PPUSH
113165: PPUSH
// if not mc_bases or not base or not kinds then
113166: LD_EXP 161
113170: NOT
113171: PUSH
113172: LD_VAR 0 1
113176: NOT
113177: OR
113178: PUSH
113179: LD_VAR 0 2
113183: NOT
113184: OR
113185: IFFALSE 113189
// exit ;
113187: GO 113250
// for i in kinds do
113189: LD_ADDR_VAR 0 4
113193: PUSH
113194: LD_VAR 0 2
113198: PUSH
113199: FOR_IN
113200: IFFALSE 113248
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
113202: LD_ADDR_EXP 195
113206: PUSH
113207: LD_EXP 195
113211: PPUSH
113212: LD_VAR 0 1
113216: PUSH
113217: LD_EXP 195
113221: PUSH
113222: LD_VAR 0 1
113226: ARRAY
113227: PUSH
113228: LD_INT 1
113230: PLUS
113231: PUSH
113232: EMPTY
113233: LIST
113234: LIST
113235: PPUSH
113236: LD_VAR 0 4
113240: PPUSH
113241: CALL 24361 0 3
113245: ST_TO_ADDR
113246: GO 113199
113248: POP
113249: POP
// end ;
113250: LD_VAR 0 3
113254: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
113255: LD_INT 0
113257: PPUSH
// if not mc_bases or not base or not areas then
113258: LD_EXP 161
113262: NOT
113263: PUSH
113264: LD_VAR 0 1
113268: NOT
113269: OR
113270: PUSH
113271: LD_VAR 0 2
113275: NOT
113276: OR
113277: IFFALSE 113281
// exit ;
113279: GO 113306
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
113281: LD_ADDR_EXP 179
113285: PUSH
113286: LD_EXP 179
113290: PPUSH
113291: LD_VAR 0 1
113295: PPUSH
113296: LD_VAR 0 2
113300: PPUSH
113301: CALL_OW 1
113305: ST_TO_ADDR
// end ;
113306: LD_VAR 0 3
113310: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
113311: LD_INT 0
113313: PPUSH
// if not mc_bases or not base or not teleports_exit then
113314: LD_EXP 161
113318: NOT
113319: PUSH
113320: LD_VAR 0 1
113324: NOT
113325: OR
113326: PUSH
113327: LD_VAR 0 2
113331: NOT
113332: OR
113333: IFFALSE 113337
// exit ;
113335: GO 113362
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
113337: LD_ADDR_EXP 196
113341: PUSH
113342: LD_EXP 196
113346: PPUSH
113347: LD_VAR 0 1
113351: PPUSH
113352: LD_VAR 0 2
113356: PPUSH
113357: CALL_OW 1
113361: ST_TO_ADDR
// end ;
113362: LD_VAR 0 3
113366: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
113367: LD_INT 0
113369: PPUSH
113370: PPUSH
113371: PPUSH
// if not mc_bases or not base or not ext_list then
113372: LD_EXP 161
113376: NOT
113377: PUSH
113378: LD_VAR 0 1
113382: NOT
113383: OR
113384: PUSH
113385: LD_VAR 0 5
113389: NOT
113390: OR
113391: IFFALSE 113395
// exit ;
113393: GO 113568
// tmp := GetFacExtXYD ( x , y , d ) ;
113395: LD_ADDR_VAR 0 8
113399: PUSH
113400: LD_VAR 0 2
113404: PPUSH
113405: LD_VAR 0 3
113409: PPUSH
113410: LD_VAR 0 4
113414: PPUSH
113415: CALL 54338 0 3
113419: ST_TO_ADDR
// if not tmp then
113420: LD_VAR 0 8
113424: NOT
113425: IFFALSE 113429
// exit ;
113427: GO 113568
// for i in tmp do
113429: LD_ADDR_VAR 0 7
113433: PUSH
113434: LD_VAR 0 8
113438: PUSH
113439: FOR_IN
113440: IFFALSE 113566
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
113442: LD_ADDR_EXP 166
113446: PUSH
113447: LD_EXP 166
113451: PPUSH
113452: LD_VAR 0 1
113456: PPUSH
113457: LD_EXP 166
113461: PUSH
113462: LD_VAR 0 1
113466: ARRAY
113467: PPUSH
113468: LD_EXP 166
113472: PUSH
113473: LD_VAR 0 1
113477: ARRAY
113478: PUSH
113479: LD_INT 1
113481: PLUS
113482: PPUSH
113483: LD_VAR 0 5
113487: PUSH
113488: LD_INT 1
113490: ARRAY
113491: PUSH
113492: LD_VAR 0 7
113496: PUSH
113497: LD_INT 1
113499: ARRAY
113500: PUSH
113501: LD_VAR 0 7
113505: PUSH
113506: LD_INT 2
113508: ARRAY
113509: PUSH
113510: LD_VAR 0 7
113514: PUSH
113515: LD_INT 3
113517: ARRAY
113518: PUSH
113519: EMPTY
113520: LIST
113521: LIST
113522: LIST
113523: LIST
113524: PPUSH
113525: CALL_OW 2
113529: PPUSH
113530: CALL_OW 1
113534: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
113535: LD_ADDR_VAR 0 5
113539: PUSH
113540: LD_VAR 0 5
113544: PPUSH
113545: LD_INT 1
113547: PPUSH
113548: CALL_OW 3
113552: ST_TO_ADDR
// if not ext_list then
113553: LD_VAR 0 5
113557: NOT
113558: IFFALSE 113564
// exit ;
113560: POP
113561: POP
113562: GO 113568
// end ;
113564: GO 113439
113566: POP
113567: POP
// end ;
113568: LD_VAR 0 6
113572: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
113573: LD_INT 0
113575: PPUSH
// if not mc_bases or not base or not weapon_list then
113576: LD_EXP 161
113580: NOT
113581: PUSH
113582: LD_VAR 0 1
113586: NOT
113587: OR
113588: PUSH
113589: LD_VAR 0 2
113593: NOT
113594: OR
113595: IFFALSE 113599
// exit ;
113597: GO 113624
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
113599: LD_ADDR_EXP 200
113603: PUSH
113604: LD_EXP 200
113608: PPUSH
113609: LD_VAR 0 1
113613: PPUSH
113614: LD_VAR 0 2
113618: PPUSH
113619: CALL_OW 1
113623: ST_TO_ADDR
// end ;
113624: LD_VAR 0 3
113628: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
113629: LD_INT 0
113631: PPUSH
// if not mc_bases or not base or not tech_list then
113632: LD_EXP 161
113636: NOT
113637: PUSH
113638: LD_VAR 0 1
113642: NOT
113643: OR
113644: PUSH
113645: LD_VAR 0 2
113649: NOT
113650: OR
113651: IFFALSE 113655
// exit ;
113653: GO 113680
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
113655: LD_ADDR_EXP 188
113659: PUSH
113660: LD_EXP 188
113664: PPUSH
113665: LD_VAR 0 1
113669: PPUSH
113670: LD_VAR 0 2
113674: PPUSH
113675: CALL_OW 1
113679: ST_TO_ADDR
// end ;
113680: LD_VAR 0 3
113684: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
113685: LD_INT 0
113687: PPUSH
// if not mc_bases or not parking_area or not base then
113688: LD_EXP 161
113692: NOT
113693: PUSH
113694: LD_VAR 0 2
113698: NOT
113699: OR
113700: PUSH
113701: LD_VAR 0 1
113705: NOT
113706: OR
113707: IFFALSE 113711
// exit ;
113709: GO 113736
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
113711: LD_ADDR_EXP 185
113715: PUSH
113716: LD_EXP 185
113720: PPUSH
113721: LD_VAR 0 1
113725: PPUSH
113726: LD_VAR 0 2
113730: PPUSH
113731: CALL_OW 1
113735: ST_TO_ADDR
// end ;
113736: LD_VAR 0 3
113740: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
113741: LD_INT 0
113743: PPUSH
// if not mc_bases or not base or not scan_area then
113744: LD_EXP 161
113748: NOT
113749: PUSH
113750: LD_VAR 0 1
113754: NOT
113755: OR
113756: PUSH
113757: LD_VAR 0 2
113761: NOT
113762: OR
113763: IFFALSE 113767
// exit ;
113765: GO 113792
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
113767: LD_ADDR_EXP 186
113771: PUSH
113772: LD_EXP 186
113776: PPUSH
113777: LD_VAR 0 1
113781: PPUSH
113782: LD_VAR 0 2
113786: PPUSH
113787: CALL_OW 1
113791: ST_TO_ADDR
// end ;
113792: LD_VAR 0 3
113796: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
113797: LD_INT 0
113799: PPUSH
113800: PPUSH
// if not mc_bases or not base then
113801: LD_EXP 161
113805: NOT
113806: PUSH
113807: LD_VAR 0 1
113811: NOT
113812: OR
113813: IFFALSE 113817
// exit ;
113815: GO 113881
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
113817: LD_ADDR_VAR 0 3
113821: PUSH
113822: LD_INT 1
113824: PUSH
113825: LD_INT 2
113827: PUSH
113828: LD_INT 3
113830: PUSH
113831: LD_INT 4
113833: PUSH
113834: LD_INT 11
113836: PUSH
113837: EMPTY
113838: LIST
113839: LIST
113840: LIST
113841: LIST
113842: LIST
113843: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
113844: LD_ADDR_EXP 188
113848: PUSH
113849: LD_EXP 188
113853: PPUSH
113854: LD_VAR 0 1
113858: PPUSH
113859: LD_EXP 188
113863: PUSH
113864: LD_VAR 0 1
113868: ARRAY
113869: PUSH
113870: LD_VAR 0 3
113874: DIFF
113875: PPUSH
113876: CALL_OW 1
113880: ST_TO_ADDR
// end ;
113881: LD_VAR 0 2
113885: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
113886: LD_INT 0
113888: PPUSH
// result := mc_vehicles [ base ] ;
113889: LD_ADDR_VAR 0 3
113893: PUSH
113894: LD_EXP 180
113898: PUSH
113899: LD_VAR 0 1
113903: ARRAY
113904: ST_TO_ADDR
// if onlyCombat then
113905: LD_VAR 0 2
113909: IFFALSE 114081
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
113911: LD_ADDR_VAR 0 3
113915: PUSH
113916: LD_VAR 0 3
113920: PUSH
113921: LD_VAR 0 3
113925: PPUSH
113926: LD_INT 2
113928: PUSH
113929: LD_INT 34
113931: PUSH
113932: LD_INT 12
113934: PUSH
113935: EMPTY
113936: LIST
113937: LIST
113938: PUSH
113939: LD_INT 34
113941: PUSH
113942: LD_INT 51
113944: PUSH
113945: EMPTY
113946: LIST
113947: LIST
113948: PUSH
113949: LD_INT 34
113951: PUSH
113952: LD_INT 89
113954: PUSH
113955: EMPTY
113956: LIST
113957: LIST
113958: PUSH
113959: LD_INT 34
113961: PUSH
113962: LD_INT 32
113964: PUSH
113965: EMPTY
113966: LIST
113967: LIST
113968: PUSH
113969: LD_INT 34
113971: PUSH
113972: LD_INT 13
113974: PUSH
113975: EMPTY
113976: LIST
113977: LIST
113978: PUSH
113979: LD_INT 34
113981: PUSH
113982: LD_INT 52
113984: PUSH
113985: EMPTY
113986: LIST
113987: LIST
113988: PUSH
113989: LD_INT 34
113991: PUSH
113992: LD_INT 88
113994: PUSH
113995: EMPTY
113996: LIST
113997: LIST
113998: PUSH
113999: LD_INT 34
114001: PUSH
114002: LD_INT 14
114004: PUSH
114005: EMPTY
114006: LIST
114007: LIST
114008: PUSH
114009: LD_INT 34
114011: PUSH
114012: LD_INT 53
114014: PUSH
114015: EMPTY
114016: LIST
114017: LIST
114018: PUSH
114019: LD_INT 34
114021: PUSH
114022: LD_INT 98
114024: PUSH
114025: EMPTY
114026: LIST
114027: LIST
114028: PUSH
114029: LD_INT 34
114031: PUSH
114032: LD_INT 31
114034: PUSH
114035: EMPTY
114036: LIST
114037: LIST
114038: PUSH
114039: LD_INT 34
114041: PUSH
114042: LD_INT 48
114044: PUSH
114045: EMPTY
114046: LIST
114047: LIST
114048: PUSH
114049: LD_INT 34
114051: PUSH
114052: LD_INT 8
114054: PUSH
114055: EMPTY
114056: LIST
114057: LIST
114058: PUSH
114059: EMPTY
114060: LIST
114061: LIST
114062: LIST
114063: LIST
114064: LIST
114065: LIST
114066: LIST
114067: LIST
114068: LIST
114069: LIST
114070: LIST
114071: LIST
114072: LIST
114073: LIST
114074: PPUSH
114075: CALL_OW 72
114079: DIFF
114080: ST_TO_ADDR
// end ; end_of_file
114081: LD_VAR 0 3
114085: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
114086: LD_INT 0
114088: PPUSH
114089: PPUSH
114090: PPUSH
// if not mc_bases or not skirmish then
114091: LD_EXP 161
114095: NOT
114096: PUSH
114097: LD_EXP 159
114101: NOT
114102: OR
114103: IFFALSE 114107
// exit ;
114105: GO 114272
// for i = 1 to mc_bases do
114107: LD_ADDR_VAR 0 4
114111: PUSH
114112: DOUBLE
114113: LD_INT 1
114115: DEC
114116: ST_TO_ADDR
114117: LD_EXP 161
114121: PUSH
114122: FOR_TO
114123: IFFALSE 114270
// begin if sci in mc_bases [ i ] then
114125: LD_VAR 0 2
114129: PUSH
114130: LD_EXP 161
114134: PUSH
114135: LD_VAR 0 4
114139: ARRAY
114140: IN
114141: IFFALSE 114268
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
114143: LD_ADDR_EXP 190
114147: PUSH
114148: LD_EXP 190
114152: PPUSH
114153: LD_VAR 0 4
114157: PUSH
114158: LD_EXP 190
114162: PUSH
114163: LD_VAR 0 4
114167: ARRAY
114168: PUSH
114169: LD_INT 1
114171: PLUS
114172: PUSH
114173: EMPTY
114174: LIST
114175: LIST
114176: PPUSH
114177: LD_VAR 0 1
114181: PPUSH
114182: CALL 24361 0 3
114186: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
114187: LD_ADDR_VAR 0 5
114191: PUSH
114192: LD_EXP 161
114196: PUSH
114197: LD_VAR 0 4
114201: ARRAY
114202: PPUSH
114203: LD_INT 2
114205: PUSH
114206: LD_INT 30
114208: PUSH
114209: LD_INT 0
114211: PUSH
114212: EMPTY
114213: LIST
114214: LIST
114215: PUSH
114216: LD_INT 30
114218: PUSH
114219: LD_INT 1
114221: PUSH
114222: EMPTY
114223: LIST
114224: LIST
114225: PUSH
114226: EMPTY
114227: LIST
114228: LIST
114229: LIST
114230: PPUSH
114231: CALL_OW 72
114235: PPUSH
114236: LD_VAR 0 1
114240: PPUSH
114241: CALL_OW 74
114245: ST_TO_ADDR
// if tmp then
114246: LD_VAR 0 5
114250: IFFALSE 114266
// ComStandNearbyBuilding ( ape , tmp ) ;
114252: LD_VAR 0 1
114256: PPUSH
114257: LD_VAR 0 5
114261: PPUSH
114262: CALL 20788 0 2
// break ;
114266: GO 114270
// end ; end ;
114268: GO 114122
114270: POP
114271: POP
// end ;
114272: LD_VAR 0 3
114276: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
114277: LD_INT 0
114279: PPUSH
114280: PPUSH
114281: PPUSH
// if not mc_bases or not skirmish then
114282: LD_EXP 161
114286: NOT
114287: PUSH
114288: LD_EXP 159
114292: NOT
114293: OR
114294: IFFALSE 114298
// exit ;
114296: GO 114387
// for i = 1 to mc_bases do
114298: LD_ADDR_VAR 0 4
114302: PUSH
114303: DOUBLE
114304: LD_INT 1
114306: DEC
114307: ST_TO_ADDR
114308: LD_EXP 161
114312: PUSH
114313: FOR_TO
114314: IFFALSE 114385
// begin if building in mc_busy_turret_list [ i ] then
114316: LD_VAR 0 1
114320: PUSH
114321: LD_EXP 171
114325: PUSH
114326: LD_VAR 0 4
114330: ARRAY
114331: IN
114332: IFFALSE 114383
// begin tmp := mc_busy_turret_list [ i ] diff building ;
114334: LD_ADDR_VAR 0 5
114338: PUSH
114339: LD_EXP 171
114343: PUSH
114344: LD_VAR 0 4
114348: ARRAY
114349: PUSH
114350: LD_VAR 0 1
114354: DIFF
114355: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
114356: LD_ADDR_EXP 171
114360: PUSH
114361: LD_EXP 171
114365: PPUSH
114366: LD_VAR 0 4
114370: PPUSH
114371: LD_VAR 0 5
114375: PPUSH
114376: CALL_OW 1
114380: ST_TO_ADDR
// break ;
114381: GO 114385
// end ; end ;
114383: GO 114313
114385: POP
114386: POP
// end ;
114387: LD_VAR 0 3
114391: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
114392: LD_INT 0
114394: PPUSH
114395: PPUSH
114396: PPUSH
// if not mc_bases or not skirmish then
114397: LD_EXP 161
114401: NOT
114402: PUSH
114403: LD_EXP 159
114407: NOT
114408: OR
114409: IFFALSE 114413
// exit ;
114411: GO 114612
// for i = 1 to mc_bases do
114413: LD_ADDR_VAR 0 5
114417: PUSH
114418: DOUBLE
114419: LD_INT 1
114421: DEC
114422: ST_TO_ADDR
114423: LD_EXP 161
114427: PUSH
114428: FOR_TO
114429: IFFALSE 114610
// if building in mc_bases [ i ] then
114431: LD_VAR 0 1
114435: PUSH
114436: LD_EXP 161
114440: PUSH
114441: LD_VAR 0 5
114445: ARRAY
114446: IN
114447: IFFALSE 114608
// begin tmp := mc_bases [ i ] diff building ;
114449: LD_ADDR_VAR 0 6
114453: PUSH
114454: LD_EXP 161
114458: PUSH
114459: LD_VAR 0 5
114463: ARRAY
114464: PUSH
114465: LD_VAR 0 1
114469: DIFF
114470: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
114471: LD_ADDR_EXP 161
114475: PUSH
114476: LD_EXP 161
114480: PPUSH
114481: LD_VAR 0 5
114485: PPUSH
114486: LD_VAR 0 6
114490: PPUSH
114491: CALL_OW 1
114495: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
114496: LD_VAR 0 1
114500: PUSH
114501: LD_EXP 169
114505: PUSH
114506: LD_VAR 0 5
114510: ARRAY
114511: IN
114512: IFFALSE 114551
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
114514: LD_ADDR_EXP 169
114518: PUSH
114519: LD_EXP 169
114523: PPUSH
114524: LD_VAR 0 5
114528: PPUSH
114529: LD_EXP 169
114533: PUSH
114534: LD_VAR 0 5
114538: ARRAY
114539: PUSH
114540: LD_VAR 0 1
114544: DIFF
114545: PPUSH
114546: CALL_OW 1
114550: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
114551: LD_VAR 0 1
114555: PUSH
114556: LD_EXP 170
114560: PUSH
114561: LD_VAR 0 5
114565: ARRAY
114566: IN
114567: IFFALSE 114606
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
114569: LD_ADDR_EXP 170
114573: PUSH
114574: LD_EXP 170
114578: PPUSH
114579: LD_VAR 0 5
114583: PPUSH
114584: LD_EXP 170
114588: PUSH
114589: LD_VAR 0 5
114593: ARRAY
114594: PUSH
114595: LD_VAR 0 1
114599: DIFF
114600: PPUSH
114601: CALL_OW 1
114605: ST_TO_ADDR
// break ;
114606: GO 114610
// end ;
114608: GO 114428
114610: POP
114611: POP
// end ;
114612: LD_VAR 0 4
114616: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
114617: LD_INT 0
114619: PPUSH
114620: PPUSH
114621: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
114622: LD_EXP 161
114626: NOT
114627: PUSH
114628: LD_EXP 159
114632: NOT
114633: OR
114634: PUSH
114635: LD_VAR 0 3
114639: PUSH
114640: LD_EXP 187
114644: IN
114645: NOT
114646: OR
114647: IFFALSE 114651
// exit ;
114649: GO 114774
// for i = 1 to mc_vehicles do
114651: LD_ADDR_VAR 0 6
114655: PUSH
114656: DOUBLE
114657: LD_INT 1
114659: DEC
114660: ST_TO_ADDR
114661: LD_EXP 180
114665: PUSH
114666: FOR_TO
114667: IFFALSE 114772
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
114669: LD_VAR 0 2
114673: PUSH
114674: LD_EXP 180
114678: PUSH
114679: LD_VAR 0 6
114683: ARRAY
114684: IN
114685: PUSH
114686: LD_VAR 0 1
114690: PUSH
114691: LD_EXP 180
114695: PUSH
114696: LD_VAR 0 6
114700: ARRAY
114701: IN
114702: OR
114703: IFFALSE 114770
// begin tmp := mc_vehicles [ i ] diff old ;
114705: LD_ADDR_VAR 0 7
114709: PUSH
114710: LD_EXP 180
114714: PUSH
114715: LD_VAR 0 6
114719: ARRAY
114720: PUSH
114721: LD_VAR 0 2
114725: DIFF
114726: ST_TO_ADDR
// tmp := tmp diff new ;
114727: LD_ADDR_VAR 0 7
114731: PUSH
114732: LD_VAR 0 7
114736: PUSH
114737: LD_VAR 0 1
114741: DIFF
114742: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
114743: LD_ADDR_EXP 180
114747: PUSH
114748: LD_EXP 180
114752: PPUSH
114753: LD_VAR 0 6
114757: PPUSH
114758: LD_VAR 0 7
114762: PPUSH
114763: CALL_OW 1
114767: ST_TO_ADDR
// break ;
114768: GO 114772
// end ;
114770: GO 114666
114772: POP
114773: POP
// end ;
114774: LD_VAR 0 5
114778: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
114779: LD_INT 0
114781: PPUSH
114782: PPUSH
114783: PPUSH
114784: PPUSH
// if not mc_bases or not skirmish then
114785: LD_EXP 161
114789: NOT
114790: PUSH
114791: LD_EXP 159
114795: NOT
114796: OR
114797: IFFALSE 114801
// exit ;
114799: GO 115183
// side := GetSide ( vehicle ) ;
114801: LD_ADDR_VAR 0 5
114805: PUSH
114806: LD_VAR 0 1
114810: PPUSH
114811: CALL_OW 255
114815: ST_TO_ADDR
// for i = 1 to mc_bases do
114816: LD_ADDR_VAR 0 4
114820: PUSH
114821: DOUBLE
114822: LD_INT 1
114824: DEC
114825: ST_TO_ADDR
114826: LD_EXP 161
114830: PUSH
114831: FOR_TO
114832: IFFALSE 115181
// begin if factory in mc_bases [ i ] then
114834: LD_VAR 0 2
114838: PUSH
114839: LD_EXP 161
114843: PUSH
114844: LD_VAR 0 4
114848: ARRAY
114849: IN
114850: IFFALSE 115179
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ar_crane , ru_siberium_rocket , us_siberium_rocket ] then
114852: LD_EXP 183
114856: PUSH
114857: LD_VAR 0 4
114861: ARRAY
114862: PUSH
114863: LD_EXP 172
114867: PUSH
114868: LD_VAR 0 4
114872: ARRAY
114873: LESS
114874: PUSH
114875: LD_VAR 0 1
114879: PPUSH
114880: CALL_OW 264
114884: PUSH
114885: LD_INT 31
114887: PUSH
114888: LD_INT 32
114890: PUSH
114891: LD_INT 51
114893: PUSH
114894: LD_INT 89
114896: PUSH
114897: LD_INT 12
114899: PUSH
114900: LD_INT 30
114902: PUSH
114903: LD_INT 98
114905: PUSH
114906: LD_INT 11
114908: PUSH
114909: LD_INT 53
114911: PUSH
114912: LD_INT 14
114914: PUSH
114915: LD_INT 91
114917: PUSH
114918: LD_INT 29
114920: PUSH
114921: LD_INT 99
114923: PUSH
114924: LD_INT 13
114926: PUSH
114927: LD_INT 52
114929: PUSH
114930: LD_INT 88
114932: PUSH
114933: LD_INT 48
114935: PUSH
114936: LD_INT 8
114938: PUSH
114939: EMPTY
114940: LIST
114941: LIST
114942: LIST
114943: LIST
114944: LIST
114945: LIST
114946: LIST
114947: LIST
114948: LIST
114949: LIST
114950: LIST
114951: LIST
114952: LIST
114953: LIST
114954: LIST
114955: LIST
114956: LIST
114957: LIST
114958: IN
114959: NOT
114960: AND
114961: IFFALSE 115009
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
114963: LD_ADDR_EXP 183
114967: PUSH
114968: LD_EXP 183
114972: PPUSH
114973: LD_VAR 0 4
114977: PUSH
114978: LD_EXP 183
114982: PUSH
114983: LD_VAR 0 4
114987: ARRAY
114988: PUSH
114989: LD_INT 1
114991: PLUS
114992: PUSH
114993: EMPTY
114994: LIST
114995: LIST
114996: PPUSH
114997: LD_VAR 0 1
115001: PPUSH
115002: CALL 24361 0 3
115006: ST_TO_ADDR
115007: GO 115053
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
115009: LD_ADDR_EXP 180
115013: PUSH
115014: LD_EXP 180
115018: PPUSH
115019: LD_VAR 0 4
115023: PUSH
115024: LD_EXP 180
115028: PUSH
115029: LD_VAR 0 4
115033: ARRAY
115034: PUSH
115035: LD_INT 1
115037: PLUS
115038: PUSH
115039: EMPTY
115040: LIST
115041: LIST
115042: PPUSH
115043: LD_VAR 0 1
115047: PPUSH
115048: CALL 24361 0 3
115052: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
115053: LD_VAR 0 1
115057: PPUSH
115058: CALL_OW 263
115062: PUSH
115063: LD_INT 2
115065: EQUAL
115066: IFFALSE 115095
// begin repeat wait ( 0 0$3 ) ;
115068: LD_INT 105
115070: PPUSH
115071: CALL_OW 67
// Connect ( vehicle ) ;
115075: LD_VAR 0 1
115079: PPUSH
115080: CALL 27330 0 1
// until IsControledBy ( vehicle ) ;
115084: LD_VAR 0 1
115088: PPUSH
115089: CALL_OW 312
115093: IFFALSE 115068
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
115095: LD_VAR 0 1
115099: PPUSH
115100: LD_EXP 185
115104: PUSH
115105: LD_VAR 0 4
115109: ARRAY
115110: PPUSH
115111: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
115115: LD_VAR 0 1
115119: PPUSH
115120: CALL_OW 263
115124: PUSH
115125: LD_INT 1
115127: NONEQUAL
115128: IFFALSE 115132
// break ;
115130: GO 115181
// repeat wait ( 0 0$1 ) ;
115132: LD_INT 35
115134: PPUSH
115135: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
115139: LD_VAR 0 1
115143: PPUSH
115144: LD_EXP 185
115148: PUSH
115149: LD_VAR 0 4
115153: ARRAY
115154: PPUSH
115155: CALL_OW 308
115159: IFFALSE 115132
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
115161: LD_VAR 0 1
115165: PPUSH
115166: CALL_OW 311
115170: PPUSH
115171: CALL_OW 121
// exit ;
115175: POP
115176: POP
115177: GO 115183
// end ; end ;
115179: GO 114831
115181: POP
115182: POP
// end ;
115183: LD_VAR 0 3
115187: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
115188: LD_INT 0
115190: PPUSH
115191: PPUSH
115192: PPUSH
115193: PPUSH
// if not mc_bases or not skirmish then
115194: LD_EXP 161
115198: NOT
115199: PUSH
115200: LD_EXP 159
115204: NOT
115205: OR
115206: IFFALSE 115210
// exit ;
115208: GO 115563
// repeat wait ( 0 0$1 ) ;
115210: LD_INT 35
115212: PPUSH
115213: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
115217: LD_VAR 0 2
115221: PPUSH
115222: LD_VAR 0 3
115226: PPUSH
115227: CALL_OW 284
115231: IFFALSE 115210
// if GetResourceTypeXY ( x , y ) = mat_artefact then
115233: LD_VAR 0 2
115237: PPUSH
115238: LD_VAR 0 3
115242: PPUSH
115243: CALL_OW 283
115247: PUSH
115248: LD_INT 4
115250: EQUAL
115251: IFFALSE 115255
// exit ;
115253: GO 115563
// for i = 1 to mc_bases do
115255: LD_ADDR_VAR 0 7
115259: PUSH
115260: DOUBLE
115261: LD_INT 1
115263: DEC
115264: ST_TO_ADDR
115265: LD_EXP 161
115269: PUSH
115270: FOR_TO
115271: IFFALSE 115561
// begin if mc_crates_area [ i ] then
115273: LD_EXP 179
115277: PUSH
115278: LD_VAR 0 7
115282: ARRAY
115283: IFFALSE 115394
// for j in mc_crates_area [ i ] do
115285: LD_ADDR_VAR 0 8
115289: PUSH
115290: LD_EXP 179
115294: PUSH
115295: LD_VAR 0 7
115299: ARRAY
115300: PUSH
115301: FOR_IN
115302: IFFALSE 115392
// if InArea ( x , y , j ) then
115304: LD_VAR 0 2
115308: PPUSH
115309: LD_VAR 0 3
115313: PPUSH
115314: LD_VAR 0 8
115318: PPUSH
115319: CALL_OW 309
115323: IFFALSE 115390
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
115325: LD_ADDR_EXP 177
115329: PUSH
115330: LD_EXP 177
115334: PPUSH
115335: LD_VAR 0 7
115339: PUSH
115340: LD_EXP 177
115344: PUSH
115345: LD_VAR 0 7
115349: ARRAY
115350: PUSH
115351: LD_INT 1
115353: PLUS
115354: PUSH
115355: EMPTY
115356: LIST
115357: LIST
115358: PPUSH
115359: LD_VAR 0 4
115363: PUSH
115364: LD_VAR 0 2
115368: PUSH
115369: LD_VAR 0 3
115373: PUSH
115374: EMPTY
115375: LIST
115376: LIST
115377: LIST
115378: PPUSH
115379: CALL 24361 0 3
115383: ST_TO_ADDR
// exit ;
115384: POP
115385: POP
115386: POP
115387: POP
115388: GO 115563
// end ;
115390: GO 115301
115392: POP
115393: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
115394: LD_ADDR_VAR 0 9
115398: PUSH
115399: LD_EXP 161
115403: PUSH
115404: LD_VAR 0 7
115408: ARRAY
115409: PPUSH
115410: LD_INT 2
115412: PUSH
115413: LD_INT 30
115415: PUSH
115416: LD_INT 0
115418: PUSH
115419: EMPTY
115420: LIST
115421: LIST
115422: PUSH
115423: LD_INT 30
115425: PUSH
115426: LD_INT 1
115428: PUSH
115429: EMPTY
115430: LIST
115431: LIST
115432: PUSH
115433: EMPTY
115434: LIST
115435: LIST
115436: LIST
115437: PPUSH
115438: CALL_OW 72
115442: ST_TO_ADDR
// if not depot then
115443: LD_VAR 0 9
115447: NOT
115448: IFFALSE 115452
// continue ;
115450: GO 115270
// for j in depot do
115452: LD_ADDR_VAR 0 8
115456: PUSH
115457: LD_VAR 0 9
115461: PUSH
115462: FOR_IN
115463: IFFALSE 115557
// if GetDistUnitXY ( j , x , y ) < 30 then
115465: LD_VAR 0 8
115469: PPUSH
115470: LD_VAR 0 2
115474: PPUSH
115475: LD_VAR 0 3
115479: PPUSH
115480: CALL_OW 297
115484: PUSH
115485: LD_INT 30
115487: LESS
115488: IFFALSE 115555
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
115490: LD_ADDR_EXP 177
115494: PUSH
115495: LD_EXP 177
115499: PPUSH
115500: LD_VAR 0 7
115504: PUSH
115505: LD_EXP 177
115509: PUSH
115510: LD_VAR 0 7
115514: ARRAY
115515: PUSH
115516: LD_INT 1
115518: PLUS
115519: PUSH
115520: EMPTY
115521: LIST
115522: LIST
115523: PPUSH
115524: LD_VAR 0 4
115528: PUSH
115529: LD_VAR 0 2
115533: PUSH
115534: LD_VAR 0 3
115538: PUSH
115539: EMPTY
115540: LIST
115541: LIST
115542: LIST
115543: PPUSH
115544: CALL 24361 0 3
115548: ST_TO_ADDR
// exit ;
115549: POP
115550: POP
115551: POP
115552: POP
115553: GO 115563
// end ;
115555: GO 115462
115557: POP
115558: POP
// end ;
115559: GO 115270
115561: POP
115562: POP
// end ;
115563: LD_VAR 0 6
115567: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
115568: LD_INT 0
115570: PPUSH
115571: PPUSH
115572: PPUSH
115573: PPUSH
// if not mc_bases or not skirmish then
115574: LD_EXP 161
115578: NOT
115579: PUSH
115580: LD_EXP 159
115584: NOT
115585: OR
115586: IFFALSE 115590
// exit ;
115588: GO 115867
// side := GetSide ( lab ) ;
115590: LD_ADDR_VAR 0 4
115594: PUSH
115595: LD_VAR 0 2
115599: PPUSH
115600: CALL_OW 255
115604: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
115605: LD_VAR 0 4
115609: PUSH
115610: LD_EXP 187
115614: IN
115615: NOT
115616: PUSH
115617: LD_EXP 188
115621: NOT
115622: OR
115623: PUSH
115624: LD_EXP 161
115628: NOT
115629: OR
115630: IFFALSE 115634
// exit ;
115632: GO 115867
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
115634: LD_ADDR_EXP 188
115638: PUSH
115639: LD_EXP 188
115643: PPUSH
115644: LD_VAR 0 4
115648: PPUSH
115649: LD_EXP 188
115653: PUSH
115654: LD_VAR 0 4
115658: ARRAY
115659: PUSH
115660: LD_VAR 0 1
115664: DIFF
115665: PPUSH
115666: CALL_OW 1
115670: ST_TO_ADDR
// for i = 1 to mc_bases do
115671: LD_ADDR_VAR 0 5
115675: PUSH
115676: DOUBLE
115677: LD_INT 1
115679: DEC
115680: ST_TO_ADDR
115681: LD_EXP 161
115685: PUSH
115686: FOR_TO
115687: IFFALSE 115865
// begin if lab in mc_bases [ i ] then
115689: LD_VAR 0 2
115693: PUSH
115694: LD_EXP 161
115698: PUSH
115699: LD_VAR 0 5
115703: ARRAY
115704: IN
115705: IFFALSE 115863
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
115707: LD_VAR 0 1
115711: PUSH
115712: LD_INT 11
115714: PUSH
115715: LD_INT 4
115717: PUSH
115718: LD_INT 3
115720: PUSH
115721: LD_INT 2
115723: PUSH
115724: EMPTY
115725: LIST
115726: LIST
115727: LIST
115728: LIST
115729: IN
115730: PUSH
115731: LD_EXP 191
115735: PUSH
115736: LD_VAR 0 5
115740: ARRAY
115741: AND
115742: IFFALSE 115863
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
115744: LD_ADDR_VAR 0 6
115748: PUSH
115749: LD_EXP 191
115753: PUSH
115754: LD_VAR 0 5
115758: ARRAY
115759: PUSH
115760: LD_INT 1
115762: ARRAY
115763: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
115764: LD_ADDR_EXP 191
115768: PUSH
115769: LD_EXP 191
115773: PPUSH
115774: LD_VAR 0 5
115778: PPUSH
115779: EMPTY
115780: PPUSH
115781: CALL_OW 1
115785: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
115786: LD_VAR 0 6
115790: PPUSH
115791: LD_INT 0
115793: PPUSH
115794: CALL_OW 109
// ComExitBuilding ( tmp ) ;
115798: LD_VAR 0 6
115802: PPUSH
115803: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
115807: LD_ADDR_EXP 190
115811: PUSH
115812: LD_EXP 190
115816: PPUSH
115817: LD_VAR 0 5
115821: PPUSH
115822: LD_EXP 190
115826: PUSH
115827: LD_VAR 0 5
115831: ARRAY
115832: PPUSH
115833: LD_INT 1
115835: PPUSH
115836: LD_VAR 0 6
115840: PPUSH
115841: CALL_OW 2
115845: PPUSH
115846: CALL_OW 1
115850: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
115851: LD_VAR 0 5
115855: PPUSH
115856: LD_INT 112
115858: PPUSH
115859: CALL 92353 0 2
// end ; end ; end ;
115863: GO 115686
115865: POP
115866: POP
// end ;
115867: LD_VAR 0 3
115871: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
115872: LD_INT 0
115874: PPUSH
115875: PPUSH
115876: PPUSH
115877: PPUSH
115878: PPUSH
115879: PPUSH
115880: PPUSH
115881: PPUSH
// if not mc_bases or not skirmish then
115882: LD_EXP 161
115886: NOT
115887: PUSH
115888: LD_EXP 159
115892: NOT
115893: OR
115894: IFFALSE 115898
// exit ;
115896: GO 117267
// for i = 1 to mc_bases do
115898: LD_ADDR_VAR 0 3
115902: PUSH
115903: DOUBLE
115904: LD_INT 1
115906: DEC
115907: ST_TO_ADDR
115908: LD_EXP 161
115912: PUSH
115913: FOR_TO
115914: IFFALSE 117265
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
115916: LD_VAR 0 1
115920: PUSH
115921: LD_EXP 161
115925: PUSH
115926: LD_VAR 0 3
115930: ARRAY
115931: IN
115932: PUSH
115933: LD_VAR 0 1
115937: PUSH
115938: LD_EXP 168
115942: PUSH
115943: LD_VAR 0 3
115947: ARRAY
115948: IN
115949: OR
115950: PUSH
115951: LD_VAR 0 1
115955: PUSH
115956: LD_EXP 183
115960: PUSH
115961: LD_VAR 0 3
115965: ARRAY
115966: IN
115967: OR
115968: PUSH
115969: LD_VAR 0 1
115973: PUSH
115974: LD_EXP 180
115978: PUSH
115979: LD_VAR 0 3
115983: ARRAY
115984: IN
115985: OR
115986: PUSH
115987: LD_VAR 0 1
115991: PUSH
115992: LD_EXP 190
115996: PUSH
115997: LD_VAR 0 3
116001: ARRAY
116002: IN
116003: OR
116004: PUSH
116005: LD_VAR 0 1
116009: PUSH
116010: LD_EXP 191
116014: PUSH
116015: LD_VAR 0 3
116019: ARRAY
116020: IN
116021: OR
116022: IFFALSE 117263
// begin if un in mc_ape [ i ] then
116024: LD_VAR 0 1
116028: PUSH
116029: LD_EXP 190
116033: PUSH
116034: LD_VAR 0 3
116038: ARRAY
116039: IN
116040: IFFALSE 116079
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
116042: LD_ADDR_EXP 190
116046: PUSH
116047: LD_EXP 190
116051: PPUSH
116052: LD_VAR 0 3
116056: PPUSH
116057: LD_EXP 190
116061: PUSH
116062: LD_VAR 0 3
116066: ARRAY
116067: PUSH
116068: LD_VAR 0 1
116072: DIFF
116073: PPUSH
116074: CALL_OW 1
116078: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
116079: LD_VAR 0 1
116083: PUSH
116084: LD_EXP 191
116088: PUSH
116089: LD_VAR 0 3
116093: ARRAY
116094: IN
116095: IFFALSE 116119
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
116097: LD_ADDR_EXP 191
116101: PUSH
116102: LD_EXP 191
116106: PPUSH
116107: LD_VAR 0 3
116111: PPUSH
116112: EMPTY
116113: PPUSH
116114: CALL_OW 1
116118: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane , ar_control_tower ] ) then
116119: LD_VAR 0 1
116123: PPUSH
116124: CALL_OW 247
116128: PUSH
116129: LD_INT 2
116131: EQUAL
116132: PUSH
116133: LD_VAR 0 1
116137: PPUSH
116138: CALL_OW 110
116142: PUSH
116143: LD_INT 20
116145: EQUAL
116146: PUSH
116147: LD_VAR 0 1
116151: PUSH
116152: LD_EXP 183
116156: PUSH
116157: LD_VAR 0 3
116161: ARRAY
116162: IN
116163: OR
116164: PUSH
116165: LD_VAR 0 1
116169: PPUSH
116170: CALL_OW 264
116174: PUSH
116175: LD_INT 12
116177: PUSH
116178: LD_INT 51
116180: PUSH
116181: LD_INT 89
116183: PUSH
116184: LD_INT 32
116186: PUSH
116187: LD_INT 13
116189: PUSH
116190: LD_INT 52
116192: PUSH
116193: LD_INT 31
116195: PUSH
116196: EMPTY
116197: LIST
116198: LIST
116199: LIST
116200: LIST
116201: LIST
116202: LIST
116203: LIST
116204: IN
116205: OR
116206: AND
116207: IFFALSE 116515
// begin if un in mc_defender [ i ] then
116209: LD_VAR 0 1
116213: PUSH
116214: LD_EXP 183
116218: PUSH
116219: LD_VAR 0 3
116223: ARRAY
116224: IN
116225: IFFALSE 116264
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
116227: LD_ADDR_EXP 183
116231: PUSH
116232: LD_EXP 183
116236: PPUSH
116237: LD_VAR 0 3
116241: PPUSH
116242: LD_EXP 183
116246: PUSH
116247: LD_VAR 0 3
116251: ARRAY
116252: PUSH
116253: LD_VAR 0 1
116257: DIFF
116258: PPUSH
116259: CALL_OW 1
116263: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
116264: LD_ADDR_VAR 0 8
116268: PUSH
116269: LD_VAR 0 3
116273: PPUSH
116274: LD_INT 3
116276: PPUSH
116277: CALL 112923 0 2
116281: ST_TO_ADDR
// if fac then
116282: LD_VAR 0 8
116286: IFFALSE 116515
// begin for j in fac do
116288: LD_ADDR_VAR 0 4
116292: PUSH
116293: LD_VAR 0 8
116297: PUSH
116298: FOR_IN
116299: IFFALSE 116513
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
116301: LD_ADDR_VAR 0 9
116305: PUSH
116306: LD_VAR 0 8
116310: PPUSH
116311: LD_VAR 0 1
116315: PPUSH
116316: CALL_OW 265
116320: PPUSH
116321: LD_VAR 0 1
116325: PPUSH
116326: CALL_OW 262
116330: PPUSH
116331: LD_VAR 0 1
116335: PPUSH
116336: CALL_OW 263
116340: PPUSH
116341: LD_VAR 0 1
116345: PPUSH
116346: CALL_OW 264
116350: PPUSH
116351: CALL 21859 0 5
116355: ST_TO_ADDR
// if components then
116356: LD_VAR 0 9
116360: IFFALSE 116511
// begin if GetWeapon ( un ) = ar_control_tower then
116362: LD_VAR 0 1
116366: PPUSH
116367: CALL_OW 264
116371: PUSH
116372: LD_INT 31
116374: EQUAL
116375: IFFALSE 116492
// begin SetTag ( IsDrivenBy ( un ) , 0 ) ;
116377: LD_VAR 0 1
116381: PPUSH
116382: CALL_OW 311
116386: PPUSH
116387: LD_INT 0
116389: PPUSH
116390: CALL_OW 109
// mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff IsDrivenBy ( un ) ) ;
116394: LD_ADDR_EXP 201
116398: PUSH
116399: LD_EXP 201
116403: PPUSH
116404: LD_VAR 0 3
116408: PPUSH
116409: LD_EXP 201
116413: PUSH
116414: LD_VAR 0 3
116418: ARRAY
116419: PUSH
116420: LD_VAR 0 1
116424: PPUSH
116425: CALL_OW 311
116429: DIFF
116430: PPUSH
116431: CALL_OW 1
116435: ST_TO_ADDR
// tmp := Insert ( mc_produce [ i ] , 1 , components ) ;
116436: LD_ADDR_VAR 0 7
116440: PUSH
116441: LD_EXP 182
116445: PUSH
116446: LD_VAR 0 3
116450: ARRAY
116451: PPUSH
116452: LD_INT 1
116454: PPUSH
116455: LD_VAR 0 9
116459: PPUSH
116460: CALL_OW 2
116464: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
116465: LD_ADDR_EXP 182
116469: PUSH
116470: LD_EXP 182
116474: PPUSH
116475: LD_VAR 0 3
116479: PPUSH
116480: LD_VAR 0 7
116484: PPUSH
116485: CALL_OW 1
116489: ST_TO_ADDR
// end else
116490: GO 116509
// MC_InsertProduceList ( i , [ components ] ) ;
116492: LD_VAR 0 3
116496: PPUSH
116497: LD_VAR 0 9
116501: PUSH
116502: EMPTY
116503: LIST
116504: PPUSH
116505: CALL 112468 0 2
// break ;
116509: GO 116513
// end ; end ;
116511: GO 116298
116513: POP
116514: POP
// end ; end ; if GetType ( un ) = unit_building then
116515: LD_VAR 0 1
116519: PPUSH
116520: CALL_OW 247
116524: PUSH
116525: LD_INT 3
116527: EQUAL
116528: IFFALSE 116931
// begin btype := GetBType ( un ) ;
116530: LD_ADDR_VAR 0 5
116534: PUSH
116535: LD_VAR 0 1
116539: PPUSH
116540: CALL_OW 266
116544: ST_TO_ADDR
// if btype in [ b_oil_mine , b_siberite_mine ] then
116545: LD_VAR 0 5
116549: PUSH
116550: LD_INT 29
116552: PUSH
116553: LD_INT 30
116555: PUSH
116556: EMPTY
116557: LIST
116558: LIST
116559: IN
116560: IFFALSE 116633
// begin if not GetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) then
116562: LD_VAR 0 1
116566: PPUSH
116567: CALL_OW 250
116571: PPUSH
116572: LD_VAR 0 1
116576: PPUSH
116577: CALL_OW 251
116581: PPUSH
116582: LD_VAR 0 1
116586: PPUSH
116587: CALL_OW 255
116591: PPUSH
116592: CALL_OW 440
116596: NOT
116597: IFFALSE 116633
// SetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) ;
116599: LD_VAR 0 1
116603: PPUSH
116604: CALL_OW 250
116608: PPUSH
116609: LD_VAR 0 1
116613: PPUSH
116614: CALL_OW 251
116618: PPUSH
116619: LD_VAR 0 1
116623: PPUSH
116624: CALL_OW 255
116628: PPUSH
116629: CALL_OW 441
// end ; if btype = b_warehouse then
116633: LD_VAR 0 5
116637: PUSH
116638: LD_INT 1
116640: EQUAL
116641: IFFALSE 116659
// begin btype := b_depot ;
116643: LD_ADDR_VAR 0 5
116647: PUSH
116648: LD_INT 0
116650: ST_TO_ADDR
// pos := 1 ;
116651: LD_ADDR_VAR 0 6
116655: PUSH
116656: LD_INT 1
116658: ST_TO_ADDR
// end ; if btype = b_factory then
116659: LD_VAR 0 5
116663: PUSH
116664: LD_INT 3
116666: EQUAL
116667: IFFALSE 116685
// begin btype := b_workshop ;
116669: LD_ADDR_VAR 0 5
116673: PUSH
116674: LD_INT 2
116676: ST_TO_ADDR
// pos := 1 ;
116677: LD_ADDR_VAR 0 6
116681: PUSH
116682: LD_INT 1
116684: ST_TO_ADDR
// end ; if btype = b_barracks then
116685: LD_VAR 0 5
116689: PUSH
116690: LD_INT 5
116692: EQUAL
116693: IFFALSE 116703
// btype := b_armoury ;
116695: LD_ADDR_VAR 0 5
116699: PUSH
116700: LD_INT 4
116702: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
116703: LD_VAR 0 5
116707: PUSH
116708: LD_INT 7
116710: PUSH
116711: LD_INT 8
116713: PUSH
116714: EMPTY
116715: LIST
116716: LIST
116717: IN
116718: IFFALSE 116728
// btype := b_lab ;
116720: LD_ADDR_VAR 0 5
116724: PUSH
116725: LD_INT 6
116727: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
116728: LD_ADDR_EXP 166
116732: PUSH
116733: LD_EXP 166
116737: PPUSH
116738: LD_VAR 0 3
116742: PUSH
116743: LD_EXP 166
116747: PUSH
116748: LD_VAR 0 3
116752: ARRAY
116753: PUSH
116754: LD_INT 1
116756: PLUS
116757: PUSH
116758: EMPTY
116759: LIST
116760: LIST
116761: PPUSH
116762: LD_VAR 0 5
116766: PUSH
116767: LD_VAR 0 1
116771: PPUSH
116772: CALL_OW 250
116776: PUSH
116777: LD_VAR 0 1
116781: PPUSH
116782: CALL_OW 251
116786: PUSH
116787: LD_VAR 0 1
116791: PPUSH
116792: CALL_OW 254
116796: PUSH
116797: EMPTY
116798: LIST
116799: LIST
116800: LIST
116801: LIST
116802: PPUSH
116803: CALL 24361 0 3
116807: ST_TO_ADDR
// if pos = 1 then
116808: LD_VAR 0 6
116812: PUSH
116813: LD_INT 1
116815: EQUAL
116816: IFFALSE 116931
// begin tmp := mc_build_list [ i ] ;
116818: LD_ADDR_VAR 0 7
116822: PUSH
116823: LD_EXP 166
116827: PUSH
116828: LD_VAR 0 3
116832: ARRAY
116833: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
116834: LD_VAR 0 7
116838: PPUSH
116839: LD_INT 2
116841: PUSH
116842: LD_INT 30
116844: PUSH
116845: LD_INT 0
116847: PUSH
116848: EMPTY
116849: LIST
116850: LIST
116851: PUSH
116852: LD_INT 30
116854: PUSH
116855: LD_INT 1
116857: PUSH
116858: EMPTY
116859: LIST
116860: LIST
116861: PUSH
116862: EMPTY
116863: LIST
116864: LIST
116865: LIST
116866: PPUSH
116867: CALL_OW 72
116871: IFFALSE 116881
// pos := 2 ;
116873: LD_ADDR_VAR 0 6
116877: PUSH
116878: LD_INT 2
116880: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
116881: LD_ADDR_VAR 0 7
116885: PUSH
116886: LD_VAR 0 7
116890: PPUSH
116891: LD_VAR 0 6
116895: PPUSH
116896: LD_VAR 0 7
116900: PPUSH
116901: CALL 24687 0 3
116905: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
116906: LD_ADDR_EXP 166
116910: PUSH
116911: LD_EXP 166
116915: PPUSH
116916: LD_VAR 0 3
116920: PPUSH
116921: LD_VAR 0 7
116925: PPUSH
116926: CALL_OW 1
116930: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
116931: LD_VAR 0 1
116935: PUSH
116936: LD_EXP 161
116940: PUSH
116941: LD_VAR 0 3
116945: ARRAY
116946: IN
116947: IFFALSE 116986
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
116949: LD_ADDR_EXP 161
116953: PUSH
116954: LD_EXP 161
116958: PPUSH
116959: LD_VAR 0 3
116963: PPUSH
116964: LD_EXP 161
116968: PUSH
116969: LD_VAR 0 3
116973: ARRAY
116974: PUSH
116975: LD_VAR 0 1
116979: DIFF
116980: PPUSH
116981: CALL_OW 1
116985: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
116986: LD_VAR 0 1
116990: PUSH
116991: LD_EXP 168
116995: PUSH
116996: LD_VAR 0 3
117000: ARRAY
117001: IN
117002: IFFALSE 117041
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
117004: LD_ADDR_EXP 168
117008: PUSH
117009: LD_EXP 168
117013: PPUSH
117014: LD_VAR 0 3
117018: PPUSH
117019: LD_EXP 168
117023: PUSH
117024: LD_VAR 0 3
117028: ARRAY
117029: PUSH
117030: LD_VAR 0 1
117034: DIFF
117035: PPUSH
117036: CALL_OW 1
117040: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
117041: LD_VAR 0 1
117045: PUSH
117046: LD_EXP 180
117050: PUSH
117051: LD_VAR 0 3
117055: ARRAY
117056: IN
117057: IFFALSE 117096
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
117059: LD_ADDR_EXP 180
117063: PUSH
117064: LD_EXP 180
117068: PPUSH
117069: LD_VAR 0 3
117073: PPUSH
117074: LD_EXP 180
117078: PUSH
117079: LD_VAR 0 3
117083: ARRAY
117084: PUSH
117085: LD_VAR 0 1
117089: DIFF
117090: PPUSH
117091: CALL_OW 1
117095: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
117096: LD_VAR 0 1
117100: PUSH
117101: LD_EXP 183
117105: PUSH
117106: LD_VAR 0 3
117110: ARRAY
117111: IN
117112: IFFALSE 117151
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
117114: LD_ADDR_EXP 183
117118: PUSH
117119: LD_EXP 183
117123: PPUSH
117124: LD_VAR 0 3
117128: PPUSH
117129: LD_EXP 183
117133: PUSH
117134: LD_VAR 0 3
117138: ARRAY
117139: PUSH
117140: LD_VAR 0 1
117144: DIFF
117145: PPUSH
117146: CALL_OW 1
117150: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
117151: LD_VAR 0 1
117155: PUSH
117156: LD_EXP 170
117160: PUSH
117161: LD_VAR 0 3
117165: ARRAY
117166: IN
117167: IFFALSE 117206
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
117169: LD_ADDR_EXP 170
117173: PUSH
117174: LD_EXP 170
117178: PPUSH
117179: LD_VAR 0 3
117183: PPUSH
117184: LD_EXP 170
117188: PUSH
117189: LD_VAR 0 3
117193: ARRAY
117194: PUSH
117195: LD_VAR 0 1
117199: DIFF
117200: PPUSH
117201: CALL_OW 1
117205: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
117206: LD_VAR 0 1
117210: PUSH
117211: LD_EXP 169
117215: PUSH
117216: LD_VAR 0 3
117220: ARRAY
117221: IN
117222: IFFALSE 117261
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
117224: LD_ADDR_EXP 169
117228: PUSH
117229: LD_EXP 169
117233: PPUSH
117234: LD_VAR 0 3
117238: PPUSH
117239: LD_EXP 169
117243: PUSH
117244: LD_VAR 0 3
117248: ARRAY
117249: PUSH
117250: LD_VAR 0 1
117254: DIFF
117255: PPUSH
117256: CALL_OW 1
117260: ST_TO_ADDR
// end ; break ;
117261: GO 117265
// end ;
117263: GO 115913
117265: POP
117266: POP
// end ;
117267: LD_VAR 0 2
117271: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
117272: LD_INT 0
117274: PPUSH
117275: PPUSH
117276: PPUSH
// if not mc_bases or not skirmish then
117277: LD_EXP 161
117281: NOT
117282: PUSH
117283: LD_EXP 159
117287: NOT
117288: OR
117289: IFFALSE 117293
// exit ;
117291: GO 117508
// for i = 1 to mc_bases do
117293: LD_ADDR_VAR 0 3
117297: PUSH
117298: DOUBLE
117299: LD_INT 1
117301: DEC
117302: ST_TO_ADDR
117303: LD_EXP 161
117307: PUSH
117308: FOR_TO
117309: IFFALSE 117506
// begin if building in mc_construct_list [ i ] then
117311: LD_VAR 0 1
117315: PUSH
117316: LD_EXP 168
117320: PUSH
117321: LD_VAR 0 3
117325: ARRAY
117326: IN
117327: IFFALSE 117504
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
117329: LD_ADDR_EXP 168
117333: PUSH
117334: LD_EXP 168
117338: PPUSH
117339: LD_VAR 0 3
117343: PPUSH
117344: LD_EXP 168
117348: PUSH
117349: LD_VAR 0 3
117353: ARRAY
117354: PUSH
117355: LD_VAR 0 1
117359: DIFF
117360: PPUSH
117361: CALL_OW 1
117365: ST_TO_ADDR
// if building in mc_lab [ i ] then
117366: LD_VAR 0 1
117370: PUSH
117371: LD_EXP 194
117375: PUSH
117376: LD_VAR 0 3
117380: ARRAY
117381: IN
117382: IFFALSE 117437
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
117384: LD_ADDR_EXP 195
117388: PUSH
117389: LD_EXP 195
117393: PPUSH
117394: LD_VAR 0 3
117398: PPUSH
117399: LD_EXP 195
117403: PUSH
117404: LD_VAR 0 3
117408: ARRAY
117409: PPUSH
117410: LD_INT 1
117412: PPUSH
117413: LD_EXP 195
117417: PUSH
117418: LD_VAR 0 3
117422: ARRAY
117423: PPUSH
117424: LD_INT 0
117426: PPUSH
117427: CALL 23779 0 4
117431: PPUSH
117432: CALL_OW 1
117436: ST_TO_ADDR
// if not building in mc_bases [ i ] then
117437: LD_VAR 0 1
117441: PUSH
117442: LD_EXP 161
117446: PUSH
117447: LD_VAR 0 3
117451: ARRAY
117452: IN
117453: NOT
117454: IFFALSE 117500
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
117456: LD_ADDR_EXP 161
117460: PUSH
117461: LD_EXP 161
117465: PPUSH
117466: LD_VAR 0 3
117470: PUSH
117471: LD_EXP 161
117475: PUSH
117476: LD_VAR 0 3
117480: ARRAY
117481: PUSH
117482: LD_INT 1
117484: PLUS
117485: PUSH
117486: EMPTY
117487: LIST
117488: LIST
117489: PPUSH
117490: LD_VAR 0 1
117494: PPUSH
117495: CALL 24361 0 3
117499: ST_TO_ADDR
// exit ;
117500: POP
117501: POP
117502: GO 117508
// end ; end ;
117504: GO 117308
117506: POP
117507: POP
// end ;
117508: LD_VAR 0 2
117512: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
117513: LD_INT 0
117515: PPUSH
117516: PPUSH
117517: PPUSH
117518: PPUSH
117519: PPUSH
117520: PPUSH
117521: PPUSH
// if not mc_bases or not skirmish then
117522: LD_EXP 161
117526: NOT
117527: PUSH
117528: LD_EXP 159
117532: NOT
117533: OR
117534: IFFALSE 117538
// exit ;
117536: GO 118199
// for i = 1 to mc_bases do
117538: LD_ADDR_VAR 0 3
117542: PUSH
117543: DOUBLE
117544: LD_INT 1
117546: DEC
117547: ST_TO_ADDR
117548: LD_EXP 161
117552: PUSH
117553: FOR_TO
117554: IFFALSE 118197
// begin if building in mc_construct_list [ i ] then
117556: LD_VAR 0 1
117560: PUSH
117561: LD_EXP 168
117565: PUSH
117566: LD_VAR 0 3
117570: ARRAY
117571: IN
117572: IFFALSE 118195
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
117574: LD_ADDR_EXP 168
117578: PUSH
117579: LD_EXP 168
117583: PPUSH
117584: LD_VAR 0 3
117588: PPUSH
117589: LD_EXP 168
117593: PUSH
117594: LD_VAR 0 3
117598: ARRAY
117599: PUSH
117600: LD_VAR 0 1
117604: DIFF
117605: PPUSH
117606: CALL_OW 1
117610: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
117611: LD_ADDR_EXP 161
117615: PUSH
117616: LD_EXP 161
117620: PPUSH
117621: LD_VAR 0 3
117625: PUSH
117626: LD_EXP 161
117630: PUSH
117631: LD_VAR 0 3
117635: ARRAY
117636: PUSH
117637: LD_INT 1
117639: PLUS
117640: PUSH
117641: EMPTY
117642: LIST
117643: LIST
117644: PPUSH
117645: LD_VAR 0 1
117649: PPUSH
117650: CALL 24361 0 3
117654: ST_TO_ADDR
// btype := GetBType ( building ) ;
117655: LD_ADDR_VAR 0 5
117659: PUSH
117660: LD_VAR 0 1
117664: PPUSH
117665: CALL_OW 266
117669: ST_TO_ADDR
// side := GetSide ( building ) ;
117670: LD_ADDR_VAR 0 8
117674: PUSH
117675: LD_VAR 0 1
117679: PPUSH
117680: CALL_OW 255
117684: ST_TO_ADDR
// if btype = b_lab then
117685: LD_VAR 0 5
117689: PUSH
117690: LD_INT 6
117692: EQUAL
117693: IFFALSE 117743
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
117695: LD_ADDR_EXP 194
117699: PUSH
117700: LD_EXP 194
117704: PPUSH
117705: LD_VAR 0 3
117709: PUSH
117710: LD_EXP 194
117714: PUSH
117715: LD_VAR 0 3
117719: ARRAY
117720: PUSH
117721: LD_INT 1
117723: PLUS
117724: PUSH
117725: EMPTY
117726: LIST
117727: LIST
117728: PPUSH
117729: LD_VAR 0 1
117733: PPUSH
117734: CALL 24361 0 3
117738: ST_TO_ADDR
// exit ;
117739: POP
117740: POP
117741: GO 118199
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
117743: LD_VAR 0 5
117747: PUSH
117748: LD_INT 0
117750: PUSH
117751: LD_INT 2
117753: PUSH
117754: LD_INT 4
117756: PUSH
117757: EMPTY
117758: LIST
117759: LIST
117760: LIST
117761: IN
117762: IFFALSE 117886
// begin if btype = b_armoury then
117764: LD_VAR 0 5
117768: PUSH
117769: LD_INT 4
117771: EQUAL
117772: IFFALSE 117782
// btype := b_barracks ;
117774: LD_ADDR_VAR 0 5
117778: PUSH
117779: LD_INT 5
117781: ST_TO_ADDR
// if btype = b_depot then
117782: LD_VAR 0 5
117786: PUSH
117787: LD_INT 0
117789: EQUAL
117790: IFFALSE 117800
// btype := b_warehouse ;
117792: LD_ADDR_VAR 0 5
117796: PUSH
117797: LD_INT 1
117799: ST_TO_ADDR
// if btype = b_workshop then
117800: LD_VAR 0 5
117804: PUSH
117805: LD_INT 2
117807: EQUAL
117808: IFFALSE 117818
// btype := b_factory ;
117810: LD_ADDR_VAR 0 5
117814: PUSH
117815: LD_INT 3
117817: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
117818: LD_VAR 0 5
117822: PPUSH
117823: LD_VAR 0 8
117827: PPUSH
117828: CALL_OW 323
117832: PUSH
117833: LD_INT 1
117835: EQUAL
117836: IFFALSE 117882
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
117838: LD_ADDR_EXP 193
117842: PUSH
117843: LD_EXP 193
117847: PPUSH
117848: LD_VAR 0 3
117852: PUSH
117853: LD_EXP 193
117857: PUSH
117858: LD_VAR 0 3
117862: ARRAY
117863: PUSH
117864: LD_INT 1
117866: PLUS
117867: PUSH
117868: EMPTY
117869: LIST
117870: LIST
117871: PPUSH
117872: LD_VAR 0 1
117876: PPUSH
117877: CALL 24361 0 3
117881: ST_TO_ADDR
// exit ;
117882: POP
117883: POP
117884: GO 118199
// end ; if btype in [ b_bunker , b_turret ] then
117886: LD_VAR 0 5
117890: PUSH
117891: LD_INT 32
117893: PUSH
117894: LD_INT 33
117896: PUSH
117897: EMPTY
117898: LIST
117899: LIST
117900: IN
117901: IFFALSE 118191
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
117903: LD_ADDR_EXP 169
117907: PUSH
117908: LD_EXP 169
117912: PPUSH
117913: LD_VAR 0 3
117917: PUSH
117918: LD_EXP 169
117922: PUSH
117923: LD_VAR 0 3
117927: ARRAY
117928: PUSH
117929: LD_INT 1
117931: PLUS
117932: PUSH
117933: EMPTY
117934: LIST
117935: LIST
117936: PPUSH
117937: LD_VAR 0 1
117941: PPUSH
117942: CALL 24361 0 3
117946: ST_TO_ADDR
// if btype = b_bunker then
117947: LD_VAR 0 5
117951: PUSH
117952: LD_INT 32
117954: EQUAL
117955: IFFALSE 118191
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
117957: LD_ADDR_EXP 170
117961: PUSH
117962: LD_EXP 170
117966: PPUSH
117967: LD_VAR 0 3
117971: PUSH
117972: LD_EXP 170
117976: PUSH
117977: LD_VAR 0 3
117981: ARRAY
117982: PUSH
117983: LD_INT 1
117985: PLUS
117986: PUSH
117987: EMPTY
117988: LIST
117989: LIST
117990: PPUSH
117991: LD_VAR 0 1
117995: PPUSH
117996: CALL 24361 0 3
118000: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
118001: LD_ADDR_VAR 0 6
118005: PUSH
118006: LD_EXP 161
118010: PUSH
118011: LD_VAR 0 3
118015: ARRAY
118016: PPUSH
118017: LD_INT 25
118019: PUSH
118020: LD_INT 1
118022: PUSH
118023: EMPTY
118024: LIST
118025: LIST
118026: PUSH
118027: LD_INT 3
118029: PUSH
118030: LD_INT 54
118032: PUSH
118033: EMPTY
118034: LIST
118035: PUSH
118036: EMPTY
118037: LIST
118038: LIST
118039: PUSH
118040: EMPTY
118041: LIST
118042: LIST
118043: PPUSH
118044: CALL_OW 72
118048: ST_TO_ADDR
// if tmp then
118049: LD_VAR 0 6
118053: IFFALSE 118059
// exit ;
118055: POP
118056: POP
118057: GO 118199
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
118059: LD_ADDR_VAR 0 6
118063: PUSH
118064: LD_EXP 161
118068: PUSH
118069: LD_VAR 0 3
118073: ARRAY
118074: PPUSH
118075: LD_INT 2
118077: PUSH
118078: LD_INT 30
118080: PUSH
118081: LD_INT 4
118083: PUSH
118084: EMPTY
118085: LIST
118086: LIST
118087: PUSH
118088: LD_INT 30
118090: PUSH
118091: LD_INT 5
118093: PUSH
118094: EMPTY
118095: LIST
118096: LIST
118097: PUSH
118098: EMPTY
118099: LIST
118100: LIST
118101: LIST
118102: PPUSH
118103: CALL_OW 72
118107: ST_TO_ADDR
// if not tmp then
118108: LD_VAR 0 6
118112: NOT
118113: IFFALSE 118119
// exit ;
118115: POP
118116: POP
118117: GO 118199
// for j in tmp do
118119: LD_ADDR_VAR 0 4
118123: PUSH
118124: LD_VAR 0 6
118128: PUSH
118129: FOR_IN
118130: IFFALSE 118189
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
118132: LD_ADDR_VAR 0 7
118136: PUSH
118137: LD_VAR 0 4
118141: PPUSH
118142: CALL_OW 313
118146: PPUSH
118147: LD_INT 25
118149: PUSH
118150: LD_INT 1
118152: PUSH
118153: EMPTY
118154: LIST
118155: LIST
118156: PPUSH
118157: CALL_OW 72
118161: ST_TO_ADDR
// if units then
118162: LD_VAR 0 7
118166: IFFALSE 118187
// begin ComExitBuilding ( units [ 1 ] ) ;
118168: LD_VAR 0 7
118172: PUSH
118173: LD_INT 1
118175: ARRAY
118176: PPUSH
118177: CALL_OW 122
// exit ;
118181: POP
118182: POP
118183: POP
118184: POP
118185: GO 118199
// end ; end ;
118187: GO 118129
118189: POP
118190: POP
// end ; end ; exit ;
118191: POP
118192: POP
118193: GO 118199
// end ; end ;
118195: GO 117553
118197: POP
118198: POP
// end ;
118199: LD_VAR 0 2
118203: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
118204: LD_INT 0
118206: PPUSH
118207: PPUSH
118208: PPUSH
118209: PPUSH
118210: PPUSH
118211: PPUSH
118212: PPUSH
// if not mc_bases or not skirmish then
118213: LD_EXP 161
118217: NOT
118218: PUSH
118219: LD_EXP 159
118223: NOT
118224: OR
118225: IFFALSE 118229
// exit ;
118227: GO 118494
// btype := GetBType ( building ) ;
118229: LD_ADDR_VAR 0 6
118233: PUSH
118234: LD_VAR 0 1
118238: PPUSH
118239: CALL_OW 266
118243: ST_TO_ADDR
// x := GetX ( building ) ;
118244: LD_ADDR_VAR 0 7
118248: PUSH
118249: LD_VAR 0 1
118253: PPUSH
118254: CALL_OW 250
118258: ST_TO_ADDR
// y := GetY ( building ) ;
118259: LD_ADDR_VAR 0 8
118263: PUSH
118264: LD_VAR 0 1
118268: PPUSH
118269: CALL_OW 251
118273: ST_TO_ADDR
// d := GetDir ( building ) ;
118274: LD_ADDR_VAR 0 9
118278: PUSH
118279: LD_VAR 0 1
118283: PPUSH
118284: CALL_OW 254
118288: ST_TO_ADDR
// for i = 1 to mc_bases do
118289: LD_ADDR_VAR 0 4
118293: PUSH
118294: DOUBLE
118295: LD_INT 1
118297: DEC
118298: ST_TO_ADDR
118299: LD_EXP 161
118303: PUSH
118304: FOR_TO
118305: IFFALSE 118492
// begin if not mc_build_list [ i ] then
118307: LD_EXP 166
118311: PUSH
118312: LD_VAR 0 4
118316: ARRAY
118317: NOT
118318: IFFALSE 118322
// continue ;
118320: GO 118304
// for j := 1 to mc_build_list [ i ] do
118322: LD_ADDR_VAR 0 5
118326: PUSH
118327: DOUBLE
118328: LD_INT 1
118330: DEC
118331: ST_TO_ADDR
118332: LD_EXP 166
118336: PUSH
118337: LD_VAR 0 4
118341: ARRAY
118342: PUSH
118343: FOR_TO
118344: IFFALSE 118488
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ j ] ) then
118346: LD_VAR 0 6
118350: PUSH
118351: LD_VAR 0 7
118355: PUSH
118356: LD_VAR 0 8
118360: PUSH
118361: LD_VAR 0 9
118365: PUSH
118366: EMPTY
118367: LIST
118368: LIST
118369: LIST
118370: LIST
118371: PPUSH
118372: LD_EXP 166
118376: PUSH
118377: LD_VAR 0 4
118381: ARRAY
118382: PUSH
118383: LD_VAR 0 5
118387: ARRAY
118388: PPUSH
118389: CALL 30541 0 2
118393: IFFALSE 118486
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , j ) ) ;
118395: LD_ADDR_EXP 166
118399: PUSH
118400: LD_EXP 166
118404: PPUSH
118405: LD_VAR 0 4
118409: PPUSH
118410: LD_EXP 166
118414: PUSH
118415: LD_VAR 0 4
118419: ARRAY
118420: PPUSH
118421: LD_VAR 0 5
118425: PPUSH
118426: CALL_OW 3
118430: PPUSH
118431: CALL_OW 1
118435: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
118436: LD_ADDR_EXP 168
118440: PUSH
118441: LD_EXP 168
118445: PPUSH
118446: LD_VAR 0 4
118450: PUSH
118451: LD_EXP 168
118455: PUSH
118456: LD_VAR 0 4
118460: ARRAY
118461: PUSH
118462: LD_INT 1
118464: PLUS
118465: PUSH
118466: EMPTY
118467: LIST
118468: LIST
118469: PPUSH
118470: LD_VAR 0 1
118474: PPUSH
118475: CALL 24361 0 3
118479: ST_TO_ADDR
// exit ;
118480: POP
118481: POP
118482: POP
118483: POP
118484: GO 118494
// end ;
118486: GO 118343
118488: POP
118489: POP
// end ;
118490: GO 118304
118492: POP
118493: POP
// end ;
118494: LD_VAR 0 3
118498: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
118499: LD_INT 0
118501: PPUSH
118502: PPUSH
118503: PPUSH
// if not mc_bases or not skirmish then
118504: LD_EXP 161
118508: NOT
118509: PUSH
118510: LD_EXP 159
118514: NOT
118515: OR
118516: IFFALSE 118520
// exit ;
118518: GO 118710
// for i = 1 to mc_bases do
118520: LD_ADDR_VAR 0 4
118524: PUSH
118525: DOUBLE
118526: LD_INT 1
118528: DEC
118529: ST_TO_ADDR
118530: LD_EXP 161
118534: PUSH
118535: FOR_TO
118536: IFFALSE 118623
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
118538: LD_VAR 0 1
118542: PUSH
118543: LD_EXP 169
118547: PUSH
118548: LD_VAR 0 4
118552: ARRAY
118553: IN
118554: PUSH
118555: LD_VAR 0 1
118559: PUSH
118560: LD_EXP 170
118564: PUSH
118565: LD_VAR 0 4
118569: ARRAY
118570: IN
118571: NOT
118572: AND
118573: IFFALSE 118621
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
118575: LD_ADDR_EXP 170
118579: PUSH
118580: LD_EXP 170
118584: PPUSH
118585: LD_VAR 0 4
118589: PUSH
118590: LD_EXP 170
118594: PUSH
118595: LD_VAR 0 4
118599: ARRAY
118600: PUSH
118601: LD_INT 1
118603: PLUS
118604: PUSH
118605: EMPTY
118606: LIST
118607: LIST
118608: PPUSH
118609: LD_VAR 0 1
118613: PPUSH
118614: CALL 24361 0 3
118618: ST_TO_ADDR
// break ;
118619: GO 118623
// end ; end ;
118621: GO 118535
118623: POP
118624: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
118625: LD_VAR 0 1
118629: PPUSH
118630: CALL_OW 257
118634: PUSH
118635: LD_EXP 187
118639: IN
118640: PUSH
118641: LD_VAR 0 1
118645: PPUSH
118646: CALL_OW 266
118650: PUSH
118651: LD_INT 5
118653: EQUAL
118654: AND
118655: PUSH
118656: LD_VAR 0 2
118660: PPUSH
118661: CALL_OW 110
118665: PUSH
118666: LD_INT 18
118668: NONEQUAL
118669: AND
118670: IFFALSE 118710
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
118672: LD_VAR 0 2
118676: PPUSH
118677: CALL_OW 257
118681: PUSH
118682: LD_INT 5
118684: PUSH
118685: LD_INT 8
118687: PUSH
118688: LD_INT 9
118690: PUSH
118691: EMPTY
118692: LIST
118693: LIST
118694: LIST
118695: IN
118696: IFFALSE 118710
// SetClass ( unit , 1 ) ;
118698: LD_VAR 0 2
118702: PPUSH
118703: LD_INT 1
118705: PPUSH
118706: CALL_OW 336
// end ;
118710: LD_VAR 0 3
118714: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
118715: LD_INT 0
118717: PPUSH
118718: PPUSH
// if not mc_bases or not skirmish then
118719: LD_EXP 161
118723: NOT
118724: PUSH
118725: LD_EXP 159
118729: NOT
118730: OR
118731: IFFALSE 118735
// exit ;
118733: GO 118851
// if GetLives ( abandoned_vehicle ) > 250 then
118735: LD_VAR 0 2
118739: PPUSH
118740: CALL_OW 256
118744: PUSH
118745: LD_INT 250
118747: GREATER
118748: IFFALSE 118752
// exit ;
118750: GO 118851
// for i = 1 to mc_bases do
118752: LD_ADDR_VAR 0 6
118756: PUSH
118757: DOUBLE
118758: LD_INT 1
118760: DEC
118761: ST_TO_ADDR
118762: LD_EXP 161
118766: PUSH
118767: FOR_TO
118768: IFFALSE 118849
// begin if driver in mc_bases [ i ] then
118770: LD_VAR 0 1
118774: PUSH
118775: LD_EXP 161
118779: PUSH
118780: LD_VAR 0 6
118784: ARRAY
118785: IN
118786: IFFALSE 118847
// begin ComMoveToNearbyEntrance ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
118788: LD_VAR 0 1
118792: PPUSH
118793: LD_EXP 161
118797: PUSH
118798: LD_VAR 0 6
118802: ARRAY
118803: PPUSH
118804: LD_INT 2
118806: PUSH
118807: LD_INT 30
118809: PUSH
118810: LD_INT 0
118812: PUSH
118813: EMPTY
118814: LIST
118815: LIST
118816: PUSH
118817: LD_INT 30
118819: PUSH
118820: LD_INT 1
118822: PUSH
118823: EMPTY
118824: LIST
118825: LIST
118826: PUSH
118827: EMPTY
118828: LIST
118829: LIST
118830: LIST
118831: PPUSH
118832: CALL_OW 72
118836: PUSH
118837: LD_INT 1
118839: ARRAY
118840: PPUSH
118841: CALL 57569 0 2
// break ;
118845: GO 118849
// end ; end ;
118847: GO 118767
118849: POP
118850: POP
// end ;
118851: LD_VAR 0 5
118855: RET
