// starting begin InitMission ;
   0: CALL 5 0 0
// end ;
   4: END
// export HeikeCaptured ; export coopWithGensher ; export HeikeStatus ; export Masha ; export dial_BuildDepotBlocker , dial_BuildArBarrackBlocker , dial_ArriveGensherUnitsBlocker ; export buildingsToBuild , techsToResearch , vehWeaponsToConstruct , availableWeapons , weaponsData , allBuildings ; export HeikeTargetX , HeikeTargetY , GensherTargetX , GensherTargetY ; export allowExitFromMap ; export acceptKurtOffert , askCommanders ; export KurtCanEscape , KurtStatus , KurtWaitingForFreeHeike , KurtWaitingForBuildBarrack ; export KurtAttack , americansAttack , forceStopKurtAttack ; export canSendHeike , canShootTrening ; export BurlakRespect ; export acceptLegionOffert , paidLegionOffert , legionOffertCountdown , legionOffertTime ; export firstMashaQuery , canChooseMashaVehicle ; export buildCompVehicle , buildArabBarrack , testedTeleport ; export lostUnits ; function InitMission ; begin
   5: LD_INT 0
   7: PPUSH
// ResetFog ;
   8: CALL_OW 335
// RandomizeAll ;
  12: CALL_OW 11
// InGameOn ;
  16: CALL_OW 8
// InitMapConfig ;
  20: CALL 358 0 0
// HeikeCaptured = LoadVariable ( 07_HeikeCaptured_1 , 0 ) ;
  24: LD_ADDR_EXP 1
  28: PUSH
  29: LD_STRING 07_HeikeCaptured_1
  31: PPUSH
  32: LD_INT 0
  34: PPUSH
  35: CALL_OW 30
  39: ST_TO_ADDR
// coopWithGensher = 0 ;
  40: LD_ADDR_EXP 2
  44: PUSH
  45: LD_INT 0
  47: ST_TO_ADDR
// HeikeStatus = 0 ;
  48: LD_ADDR_EXP 3
  52: PUSH
  53: LD_INT 0
  55: ST_TO_ADDR
// Masha = [ ] ;
  56: LD_ADDR_EXP 4
  60: PUSH
  61: EMPTY
  62: ST_TO_ADDR
// buildingsToBuild = [ ] ;
  63: LD_ADDR_EXP 8
  67: PUSH
  68: EMPTY
  69: ST_TO_ADDR
// techsToResearch = [ ] ;
  70: LD_ADDR_EXP 9
  74: PUSH
  75: EMPTY
  76: ST_TO_ADDR
// vehWeaponsToConstruct = [ ] ;
  77: LD_ADDR_EXP 10
  81: PUSH
  82: EMPTY
  83: ST_TO_ADDR
// availableWeapons = [ ] ;
  84: LD_ADDR_EXP 11
  88: PUSH
  89: EMPTY
  90: ST_TO_ADDR
// weaponsData = [ ] ;
  91: LD_ADDR_EXP 12
  95: PUSH
  96: EMPTY
  97: ST_TO_ADDR
// allBuildings = [ ] ;
  98: LD_ADDR_EXP 13
 102: PUSH
 103: EMPTY
 104: ST_TO_ADDR
// HeikeTargetX = 0 ;
 105: LD_ADDR_EXP 14
 109: PUSH
 110: LD_INT 0
 112: ST_TO_ADDR
// HeikeTargetY = 0 ;
 113: LD_ADDR_EXP 15
 117: PUSH
 118: LD_INT 0
 120: ST_TO_ADDR
// GensherTargetX = 0 ;
 121: LD_ADDR_EXP 16
 125: PUSH
 126: LD_INT 0
 128: ST_TO_ADDR
// GensherTargetY = 0 ;
 129: LD_ADDR_EXP 17
 133: PUSH
 134: LD_INT 0
 136: ST_TO_ADDR
// allowExitFromMap = 0 ;
 137: LD_ADDR_EXP 18
 141: PUSH
 142: LD_INT 0
 144: ST_TO_ADDR
// acceptKurtOffert = 0 ;
 145: LD_ADDR_EXP 19
 149: PUSH
 150: LD_INT 0
 152: ST_TO_ADDR
// askCommanders = 0 ;
 153: LD_ADDR_EXP 20
 157: PUSH
 158: LD_INT 0
 160: ST_TO_ADDR
// KurtCanEscape = true ;
 161: LD_ADDR_EXP 21
 165: PUSH
 166: LD_INT 1
 168: ST_TO_ADDR
// KurtAttack = false ;
 169: LD_ADDR_EXP 25
 173: PUSH
 174: LD_INT 0
 176: ST_TO_ADDR
// KurtWaitingForFreeHeike = false ;
 177: LD_ADDR_EXP 23
 181: PUSH
 182: LD_INT 0
 184: ST_TO_ADDR
// KurtWaitingForBuildBarrack = false ;
 185: LD_ADDR_EXP 24
 189: PUSH
 190: LD_INT 0
 192: ST_TO_ADDR
// KurtStatus = 0 ;
 193: LD_ADDR_EXP 22
 197: PUSH
 198: LD_INT 0
 200: ST_TO_ADDR
// americansAttack = false ;
 201: LD_ADDR_EXP 26
 205: PUSH
 206: LD_INT 0
 208: ST_TO_ADDR
// forceStopKurtAttack = false ;
 209: LD_ADDR_EXP 27
 213: PUSH
 214: LD_INT 0
 216: ST_TO_ADDR
// canSendHeike = false ;
 217: LD_ADDR_EXP 28
 221: PUSH
 222: LD_INT 0
 224: ST_TO_ADDR
// canShootTrening = false ;
 225: LD_ADDR_EXP 29
 229: PUSH
 230: LD_INT 0
 232: ST_TO_ADDR
// BurlakRespect = 0 ;
 233: LD_ADDR_EXP 30
 237: PUSH
 238: LD_INT 0
 240: ST_TO_ADDR
// acceptLegionOffert = false ;
 241: LD_ADDR_EXP 31
 245: PUSH
 246: LD_INT 0
 248: ST_TO_ADDR
// paidLegionOffert = false ;
 249: LD_ADDR_EXP 32
 253: PUSH
 254: LD_INT 0
 256: ST_TO_ADDR
// legionOffertCountdown = false ;
 257: LD_ADDR_EXP 33
 261: PUSH
 262: LD_INT 0
 264: ST_TO_ADDR
// legionOffertTime = 0 0$60 ;
 265: LD_ADDR_EXP 34
 269: PUSH
 270: LD_INT 2100
 272: ST_TO_ADDR
// canChooseMashaVehicle = false ;
 273: LD_ADDR_EXP 36
 277: PUSH
 278: LD_INT 0
 280: ST_TO_ADDR
// firstMashaQuery = true ;
 281: LD_ADDR_EXP 35
 285: PUSH
 286: LD_INT 1
 288: ST_TO_ADDR
// buildArabBarrack = false ;
 289: LD_ADDR_EXP 38
 293: PUSH
 294: LD_INT 0
 296: ST_TO_ADDR
// buildCompVehicle = false ;
 297: LD_ADDR_EXP 37
 301: PUSH
 302: LD_INT 0
 304: ST_TO_ADDR
// testedTeleport = false ;
 305: LD_ADDR_EXP 39
 309: PUSH
 310: LD_INT 0
 312: ST_TO_ADDR
// lostUnits = 0 ;
 313: LD_ADDR_EXP 40
 317: PUSH
 318: LD_INT 0
 320: ST_TO_ADDR
// PrepareRussians ;
 321: CALL 1224 0 0
// PrepareArabians ;
 325: CALL 3773 0 0
// PrepareAmericans ;
 329: CALL 2907 0 0
// Nef_PrepareNature ;
 333: CALL 4757 0 0
// SpawnTrees ;
 337: CALL 5378 0 0
// MissionIntro ;
 341: CALL 9011 0 0
// end ;
 345: LD_VAR 0 1
 349: RET
// export function CustomInitMacro ; begin
 350: LD_INT 0
 352: PPUSH
// end ; end_of_file
 353: LD_VAR 0 1
 357: RET
// export function InitMapConfig ; begin
 358: LD_INT 0
 360: PPUSH
// BaseMapConfig ;
 361: CALL 374 0 0
// MissionMapConfig ;
 365: CALL 464 0 0
// end ;
 369: LD_VAR 0 1
 373: RET
// export animalsAmount , animalsStats , animalsAgression , missionPrefix , previousMissionPrefix , debugMode ; function BaseMapConfig ; begin
 374: LD_INT 0
 376: PPUSH
// animalsAmount = [ 6 , 3 , 4 , 4 , 1 ] ;
 377: LD_ADDR_EXP 41
 381: PUSH
 382: LD_INT 6
 384: PUSH
 385: LD_INT 3
 387: PUSH
 388: LD_INT 4
 390: PUSH
 391: LD_INT 4
 393: PUSH
 394: LD_INT 1
 396: PUSH
 397: EMPTY
 398: LIST
 399: LIST
 400: LIST
 401: LIST
 402: LIST
 403: ST_TO_ADDR
// animalsStats = [ 2 , 2 , 2 , 2 ] ;
 404: LD_ADDR_EXP 42
 408: PUSH
 409: LD_INT 2
 411: PUSH
 412: LD_INT 2
 414: PUSH
 415: LD_INT 2
 417: PUSH
 418: LD_INT 2
 420: PUSH
 421: EMPTY
 422: LIST
 423: LIST
 424: LIST
 425: LIST
 426: ST_TO_ADDR
// animalsAgression = 3 ;
 427: LD_ADDR_EXP 43
 431: PUSH
 432: LD_INT 3
 434: ST_TO_ADDR
// debugMode = 0 ;
 435: LD_ADDR_EXP 46
 439: PUSH
 440: LD_INT 0
 442: ST_TO_ADDR
// missionPrefix = 08_ ;
 443: LD_ADDR_EXP 44
 447: PUSH
 448: LD_STRING 08_
 450: ST_TO_ADDR
// previousMissionPrefix = 07_ ;
 451: LD_ADDR_EXP 45
 455: PUSH
 456: LD_STRING 07_
 458: ST_TO_ADDR
// end ;
 459: LD_VAR 0 1
 463: RET
// export KurtAttackWaves , americansAttackWaves ; export firstAttackDelay ; export waveCooldown ; export legionReduceAmericansUnits ; export speedMedalTime ; export enemyAttackUnitsData ; export timeToFreeHeike , timeToBuildArBarrack ; export enemySkillLevel ; function MissionMapConfig ; begin
 464: LD_INT 0
 466: PPUSH
// KurtAttackWaves = [ 3 , 4 , 5 ] [ Difficulty ] ;
 467: LD_ADDR_EXP 47
 471: PUSH
 472: LD_INT 3
 474: PUSH
 475: LD_INT 4
 477: PUSH
 478: LD_INT 5
 480: PUSH
 481: EMPTY
 482: LIST
 483: LIST
 484: LIST
 485: PUSH
 486: LD_OWVAR 67
 490: ARRAY
 491: ST_TO_ADDR
// americansAttackWaves = [ 1 , 2 , 3 ] [ Difficulty ] ;
 492: LD_ADDR_EXP 48
 496: PUSH
 497: LD_INT 1
 499: PUSH
 500: LD_INT 2
 502: PUSH
 503: LD_INT 3
 505: PUSH
 506: EMPTY
 507: LIST
 508: LIST
 509: LIST
 510: PUSH
 511: LD_OWVAR 67
 515: ARRAY
 516: ST_TO_ADDR
// enemySkillLevel = [ 3 , 4 , 5 ] [ Difficulty ] ;
 517: LD_ADDR_EXP 56
 521: PUSH
 522: LD_INT 3
 524: PUSH
 525: LD_INT 4
 527: PUSH
 528: LD_INT 5
 530: PUSH
 531: EMPTY
 532: LIST
 533: LIST
 534: LIST
 535: PUSH
 536: LD_OWVAR 67
 540: ARRAY
 541: ST_TO_ADDR
// waveCooldown = 1 1$30 ;
 542: LD_ADDR_EXP 50
 546: PUSH
 547: LD_INT 3150
 549: ST_TO_ADDR
// firstAttackDelay = 1 1$00 ;
 550: LD_ADDR_EXP 49
 554: PUSH
 555: LD_INT 2100
 557: ST_TO_ADDR
// timeToFreeHeike = 2 2$00 ;
 558: LD_ADDR_EXP 54
 562: PUSH
 563: LD_INT 4200
 565: ST_TO_ADDR
// timeToBuildArBarrack = 5 5$00 ;
 566: LD_ADDR_EXP 55
 570: PUSH
 571: LD_INT 10500
 573: ST_TO_ADDR
// legionReduceAmericansUnits = [ 5 , 5 , 6 ] [ Difficulty ] ;
 574: LD_ADDR_EXP 51
 578: PUSH
 579: LD_INT 5
 581: PUSH
 582: LD_INT 5
 584: PUSH
 585: LD_INT 6
 587: PUSH
 588: EMPTY
 589: LIST
 590: LIST
 591: LIST
 592: PUSH
 593: LD_OWVAR 67
 597: ARRAY
 598: ST_TO_ADDR
// speedMedalTime = [ 80 80$0 , 70 70$0 , 60 60$0 ] [ Difficulty ] ;
 599: LD_ADDR_EXP 52
 603: PUSH
 604: LD_INT 168000
 606: PUSH
 607: LD_INT 147000
 609: PUSH
 610: LD_INT 126000
 612: PUSH
 613: EMPTY
 614: LIST
 615: LIST
 616: LIST
 617: PUSH
 618: LD_OWVAR 67
 622: ARRAY
 623: ST_TO_ADDR
// enemyAttackUnitsData = [ [ 1 , [ 4 , 5 , 6 ] [ Difficulty ] , [ 7 , 8 , 9 ] [ Difficulty ] , [ 1 , 2 , 2 ] [ Difficulty ] , [ 3 , 3 , 4 ] [ Difficulty ] , [ 6 , 7 , 8 ] [ Difficulty ] , [ 10 , 12 , 15 ] [ Difficulty ] ] , [ 8 , [ 2 , 3 , 4 ] [ Difficulty ] , [ 6 , 6 , 7 ] [ Difficulty ] , [ 0 , 1 , 1 ] [ Difficulty ] , [ 1 , 2 , 3 ] [ Difficulty ] , [ 1 , 2 , 2 ] [ Difficulty ] , [ 2 , 3 , 5 ] [ Difficulty ] ] ] ;
 624: LD_ADDR_EXP 53
 628: PUSH
 629: LD_INT 1
 631: PUSH
 632: LD_INT 4
 634: PUSH
 635: LD_INT 5
 637: PUSH
 638: LD_INT 6
 640: PUSH
 641: EMPTY
 642: LIST
 643: LIST
 644: LIST
 645: PUSH
 646: LD_OWVAR 67
 650: ARRAY
 651: PUSH
 652: LD_INT 7
 654: PUSH
 655: LD_INT 8
 657: PUSH
 658: LD_INT 9
 660: PUSH
 661: EMPTY
 662: LIST
 663: LIST
 664: LIST
 665: PUSH
 666: LD_OWVAR 67
 670: ARRAY
 671: PUSH
 672: LD_INT 1
 674: PUSH
 675: LD_INT 2
 677: PUSH
 678: LD_INT 2
 680: PUSH
 681: EMPTY
 682: LIST
 683: LIST
 684: LIST
 685: PUSH
 686: LD_OWVAR 67
 690: ARRAY
 691: PUSH
 692: LD_INT 3
 694: PUSH
 695: LD_INT 3
 697: PUSH
 698: LD_INT 4
 700: PUSH
 701: EMPTY
 702: LIST
 703: LIST
 704: LIST
 705: PUSH
 706: LD_OWVAR 67
 710: ARRAY
 711: PUSH
 712: LD_INT 6
 714: PUSH
 715: LD_INT 7
 717: PUSH
 718: LD_INT 8
 720: PUSH
 721: EMPTY
 722: LIST
 723: LIST
 724: LIST
 725: PUSH
 726: LD_OWVAR 67
 730: ARRAY
 731: PUSH
 732: LD_INT 10
 734: PUSH
 735: LD_INT 12
 737: PUSH
 738: LD_INT 15
 740: PUSH
 741: EMPTY
 742: LIST
 743: LIST
 744: LIST
 745: PUSH
 746: LD_OWVAR 67
 750: ARRAY
 751: PUSH
 752: EMPTY
 753: LIST
 754: LIST
 755: LIST
 756: LIST
 757: LIST
 758: LIST
 759: LIST
 760: PUSH
 761: LD_INT 8
 763: PUSH
 764: LD_INT 2
 766: PUSH
 767: LD_INT 3
 769: PUSH
 770: LD_INT 4
 772: PUSH
 773: EMPTY
 774: LIST
 775: LIST
 776: LIST
 777: PUSH
 778: LD_OWVAR 67
 782: ARRAY
 783: PUSH
 784: LD_INT 6
 786: PUSH
 787: LD_INT 6
 789: PUSH
 790: LD_INT 7
 792: PUSH
 793: EMPTY
 794: LIST
 795: LIST
 796: LIST
 797: PUSH
 798: LD_OWVAR 67
 802: ARRAY
 803: PUSH
 804: LD_INT 0
 806: PUSH
 807: LD_INT 1
 809: PUSH
 810: LD_INT 1
 812: PUSH
 813: EMPTY
 814: LIST
 815: LIST
 816: LIST
 817: PUSH
 818: LD_OWVAR 67
 822: ARRAY
 823: PUSH
 824: LD_INT 1
 826: PUSH
 827: LD_INT 2
 829: PUSH
 830: LD_INT 3
 832: PUSH
 833: EMPTY
 834: LIST
 835: LIST
 836: LIST
 837: PUSH
 838: LD_OWVAR 67
 842: ARRAY
 843: PUSH
 844: LD_INT 1
 846: PUSH
 847: LD_INT 2
 849: PUSH
 850: LD_INT 2
 852: PUSH
 853: EMPTY
 854: LIST
 855: LIST
 856: LIST
 857: PUSH
 858: LD_OWVAR 67
 862: ARRAY
 863: PUSH
 864: LD_INT 2
 866: PUSH
 867: LD_INT 3
 869: PUSH
 870: LD_INT 5
 872: PUSH
 873: EMPTY
 874: LIST
 875: LIST
 876: LIST
 877: PUSH
 878: LD_OWVAR 67
 882: ARRAY
 883: PUSH
 884: EMPTY
 885: LIST
 886: LIST
 887: LIST
 888: LIST
 889: LIST
 890: LIST
 891: LIST
 892: PUSH
 893: EMPTY
 894: LIST
 895: LIST
 896: ST_TO_ADDR
// end ;
 897: LD_VAR 0 1
 901: RET
// every 0 0$1 trigger debugMode do var i ;
 902: LD_EXP 46
 906: IFFALSE 1221
 908: GO 910
 910: DISABLE
 911: LD_INT 0
 913: PPUSH
// begin enable ;
 914: ENABLE
// FogOff ( your_side ) ;
 915: LD_OWVAR 2
 919: PPUSH
 920: CALL_OW 344
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) do
 924: LD_ADDR_VAR 0 1
 928: PUSH
 929: LD_INT 22
 931: PUSH
 932: LD_OWVAR 2
 936: PUSH
 937: EMPTY
 938: LIST
 939: LIST
 940: PUSH
 941: LD_INT 2
 943: PUSH
 944: LD_INT 21
 946: PUSH
 947: LD_INT 1
 949: PUSH
 950: EMPTY
 951: LIST
 952: LIST
 953: PUSH
 954: LD_INT 21
 956: PUSH
 957: LD_INT 2
 959: PUSH
 960: EMPTY
 961: LIST
 962: LIST
 963: PUSH
 964: EMPTY
 965: LIST
 966: LIST
 967: LIST
 968: PUSH
 969: EMPTY
 970: LIST
 971: LIST
 972: PPUSH
 973: CALL_OW 69
 977: PUSH
 978: FOR_IN
 979: IFFALSE 995
// SetLives ( i , 1000 ) ;
 981: LD_VAR 0 1
 985: PPUSH
 986: LD_INT 1000
 988: PPUSH
 989: CALL_OW 234
 993: GO 978
 995: POP
 996: POP
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) do
 997: LD_ADDR_VAR 0 1
1001: PUSH
1002: LD_INT 22
1004: PUSH
1005: LD_OWVAR 2
1009: PUSH
1010: EMPTY
1011: LIST
1012: LIST
1013: PUSH
1014: LD_INT 21
1016: PUSH
1017: LD_INT 1
1019: PUSH
1020: EMPTY
1021: LIST
1022: LIST
1023: PUSH
1024: EMPTY
1025: LIST
1026: LIST
1027: PPUSH
1028: CALL_OW 69
1032: PUSH
1033: FOR_IN
1034: IFFALSE 1098
// begin SetSkill ( i , skill_combat , 10 ) ;
1036: LD_VAR 0 1
1040: PPUSH
1041: LD_INT 1
1043: PPUSH
1044: LD_INT 10
1046: PPUSH
1047: CALL_OW 237
// SetSkill ( i , skill_engineering , 10 ) ;
1051: LD_VAR 0 1
1055: PPUSH
1056: LD_INT 2
1058: PPUSH
1059: LD_INT 10
1061: PPUSH
1062: CALL_OW 237
// SetSkill ( i , skill_mechanical , 10 ) ;
1066: LD_VAR 0 1
1070: PPUSH
1071: LD_INT 3
1073: PPUSH
1074: LD_INT 10
1076: PPUSH
1077: CALL_OW 237
// SetSkill ( i , skill_scientistic , 10 ) ;
1081: LD_VAR 0 1
1085: PPUSH
1086: LD_INT 4
1088: PPUSH
1089: LD_INT 10
1091: PPUSH
1092: CALL_OW 237
// end ;
1096: GO 1033
1098: POP
1099: POP
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) do
1100: LD_ADDR_VAR 0 1
1104: PUSH
1105: LD_INT 22
1107: PUSH
1108: LD_OWVAR 2
1112: PUSH
1113: EMPTY
1114: LIST
1115: LIST
1116: PUSH
1117: LD_INT 2
1119: PUSH
1120: LD_INT 30
1122: PUSH
1123: LD_INT 0
1125: PUSH
1126: EMPTY
1127: LIST
1128: LIST
1129: PUSH
1130: LD_INT 30
1132: PUSH
1133: LD_INT 1
1135: PUSH
1136: EMPTY
1137: LIST
1138: LIST
1139: PUSH
1140: EMPTY
1141: LIST
1142: LIST
1143: LIST
1144: PUSH
1145: EMPTY
1146: LIST
1147: LIST
1148: PPUSH
1149: CALL_OW 69
1153: PUSH
1154: FOR_IN
1155: IFFALSE 1219
// begin SetResourceType ( GetBase ( i ) , mat_cans , 9999 ) ;
1157: LD_VAR 0 1
1161: PPUSH
1162: CALL_OW 274
1166: PPUSH
1167: LD_INT 1
1169: PPUSH
1170: LD_INT 9999
1172: PPUSH
1173: CALL_OW 277
// SetResourceType ( GetBase ( i ) , mat_oil , 9999 ) ;
1177: LD_VAR 0 1
1181: PPUSH
1182: CALL_OW 274
1186: PPUSH
1187: LD_INT 2
1189: PPUSH
1190: LD_INT 9999
1192: PPUSH
1193: CALL_OW 277
// SetResourceType ( GetBase ( i ) , mat_siberit , 9999 ) ;
1197: LD_VAR 0 1
1201: PPUSH
1202: CALL_OW 274
1206: PPUSH
1207: LD_INT 3
1209: PPUSH
1210: LD_INT 9999
1212: PPUSH
1213: CALL_OW 277
// end ;
1217: GO 1154
1219: POP
1220: POP
// end ; end_of_file
1221: PPOPN 1
1223: END
// export Burlak , Karamazov , Petrovova , Gleb , Petrosyan , Titov , Dolgov , Lipshchin , Kirilenkova , Belkov , Belkov2 , Xavier ; export Gnyevko , Kovalyuk , Scholtze , Kuzmov ; export Kozlov , Oblukov , Kapitsova ; export Popov ; export russianEscort ; export function PrepareRussians ; begin
1224: LD_INT 0
1226: PPUSH
// russianEscort = [ ] ;
1227: LD_ADDR_EXP 77
1231: PUSH
1232: EMPTY
1233: ST_TO_ADDR
// Masha = [ ] ;
1234: LD_ADDR_EXP 4
1238: PUSH
1239: EMPTY
1240: ST_TO_ADDR
// PrepareHeroes ;
1241: CALL 1254 0 0
// InitRussianRequiments ;
1245: CALL 2649 0 0
// end ;
1249: LD_VAR 0 1
1253: RET
// function PrepareHeroes ; var i , un , other_survivors , yourUnits , emptyVeh ; begin
1254: LD_INT 0
1256: PPUSH
1257: PPUSH
1258: PPUSH
1259: PPUSH
1260: PPUSH
1261: PPUSH
// uc_side = 3 ;
1262: LD_ADDR_OWVAR 20
1266: PUSH
1267: LD_INT 3
1269: ST_TO_ADDR
// uc_nation = 3 ;
1270: LD_ADDR_OWVAR 21
1274: PUSH
1275: LD_INT 3
1277: ST_TO_ADDR
// Burlak := PrepareUnitExt ( Burlak , true , class_mechanic ) ;
1278: LD_ADDR_EXP 57
1282: PUSH
1283: LD_STRING Burlak
1285: PPUSH
1286: LD_INT 1
1288: PPUSH
1289: LD_INT 3
1291: PPUSH
1292: CALL 5856 0 3
1296: ST_TO_ADDR
// Titov := PrepareUnitExt ( Titov , true , class_soldier ) ;
1297: LD_ADDR_EXP 62
1301: PUSH
1302: LD_STRING Titov
1304: PPUSH
1305: LD_INT 1
1307: PPUSH
1308: LD_INT 1
1310: PPUSH
1311: CALL 5856 0 3
1315: ST_TO_ADDR
// Dolgov := PrepareUnitExt ( Dolgov , true , class_scientistic ) ;
1316: LD_ADDR_EXP 63
1320: PUSH
1321: LD_STRING Dolgov
1323: PPUSH
1324: LD_INT 1
1326: PPUSH
1327: LD_INT 4
1329: PPUSH
1330: CALL 5856 0 3
1334: ST_TO_ADDR
// Lipshchin := PrepareUnitExt ( Lipshchin , true , class_soldier ) ;
1335: LD_ADDR_EXP 64
1339: PUSH
1340: LD_STRING Lipshchin
1342: PPUSH
1343: LD_INT 1
1345: PPUSH
1346: LD_INT 1
1348: PPUSH
1349: CALL 5856 0 3
1353: ST_TO_ADDR
// Karamazov := PrepareUnitExt ( Karamazov , true , class_engineer ) ;
1354: LD_ADDR_EXP 58
1358: PUSH
1359: LD_STRING Karamazov
1361: PPUSH
1362: LD_INT 1
1364: PPUSH
1365: LD_INT 2
1367: PPUSH
1368: CALL 5856 0 3
1372: ST_TO_ADDR
// Petrovova := PrepareUnitExt ( Petrovova , true , class_soldier ) ;
1373: LD_ADDR_EXP 59
1377: PUSH
1378: LD_STRING Petrovova
1380: PPUSH
1381: LD_INT 1
1383: PPUSH
1384: LD_INT 1
1386: PPUSH
1387: CALL 5856 0 3
1391: ST_TO_ADDR
// Gleb := PrepareUnitExt ( Gleb , true , class_soldier ) ;
1392: LD_ADDR_EXP 60
1396: PUSH
1397: LD_STRING Gleb
1399: PPUSH
1400: LD_INT 1
1402: PPUSH
1403: LD_INT 1
1405: PPUSH
1406: CALL 5856 0 3
1410: ST_TO_ADDR
// Petrosyan := PrepareUnitExt ( Petrosyan , true , class_scientistic ) ;
1411: LD_ADDR_EXP 61
1415: PUSH
1416: LD_STRING Petrosyan
1418: PPUSH
1419: LD_INT 1
1421: PPUSH
1422: LD_INT 4
1424: PPUSH
1425: CALL 5856 0 3
1429: ST_TO_ADDR
// Kirilenkova := PrepareUnitExt ( Kirilenkova , true , class_scientistic ) ;
1430: LD_ADDR_EXP 65
1434: PUSH
1435: LD_STRING Kirilenkova
1437: PPUSH
1438: LD_INT 1
1440: PPUSH
1441: LD_INT 4
1443: PPUSH
1444: CALL 5856 0 3
1448: ST_TO_ADDR
// Belkov := PrepareUnitExt ( Belkov , true , class_soldier ) ;
1449: LD_ADDR_EXP 66
1453: PUSH
1454: LD_STRING Belkov
1456: PPUSH
1457: LD_INT 1
1459: PPUSH
1460: LD_INT 1
1462: PPUSH
1463: CALL 5856 0 3
1467: ST_TO_ADDR
// Belkov2 := PrepareUnitExt ( Belkov2 , true , class_soldier ) ;
1468: LD_ADDR_EXP 67
1472: PUSH
1473: LD_STRING Belkov2
1475: PPUSH
1476: LD_INT 1
1478: PPUSH
1479: LD_INT 1
1481: PPUSH
1482: CALL 5856 0 3
1486: ST_TO_ADDR
// Xavier := PrepareUnitExt ( Xavier , true , class_soldier ) ;
1487: LD_ADDR_EXP 68
1491: PUSH
1492: LD_STRING Xavier
1494: PPUSH
1495: LD_INT 1
1497: PPUSH
1498: LD_INT 1
1500: PPUSH
1501: CALL 5856 0 3
1505: ST_TO_ADDR
// Gnyevko := CreateCharacter ( 04_Gnyevko ) ;
1506: LD_ADDR_EXP 69
1510: PUSH
1511: LD_STRING 04_Gnyevko
1513: PPUSH
1514: CALL_OW 34
1518: ST_TO_ADDR
// SetClass ( Gnyevko , class_soldier ) ;
1519: LD_EXP 69
1523: PPUSH
1524: LD_INT 1
1526: PPUSH
1527: CALL_OW 336
// Kovalyuk := CreateCharacter ( 04_Kovalyuk ) ;
1531: LD_ADDR_EXP 70
1535: PUSH
1536: LD_STRING 04_Kovalyuk
1538: PPUSH
1539: CALL_OW 34
1543: ST_TO_ADDR
// SetClass ( Kovalyuk , class_mechanic ) ;
1544: LD_EXP 70
1548: PPUSH
1549: LD_INT 3
1551: PPUSH
1552: CALL_OW 336
// Scholtze := CreateCharacter ( 04_Scholtze ) ;
1556: LD_ADDR_EXP 71
1560: PUSH
1561: LD_STRING 04_Scholtze
1563: PPUSH
1564: CALL_OW 34
1568: ST_TO_ADDR
// SetClass ( Scholtze , class_scientistic ) ;
1569: LD_EXP 71
1573: PPUSH
1574: LD_INT 4
1576: PPUSH
1577: CALL_OW 336
// Kuzmov := CreateCharacter ( 04_Kuzmov ) ;
1581: LD_ADDR_EXP 72
1585: PUSH
1586: LD_STRING 04_Kuzmov
1588: PPUSH
1589: CALL_OW 34
1593: ST_TO_ADDR
// SetClass ( Kuzmov , class_soldier ) ;
1594: LD_EXP 72
1598: PPUSH
1599: LD_INT 1
1601: PPUSH
1602: CALL_OW 336
// Kozlov := PrepareUnitExt ( Kozlov , false , class_engineer ) ;
1606: LD_ADDR_EXP 73
1610: PUSH
1611: LD_STRING Kozlov
1613: PPUSH
1614: LD_INT 0
1616: PPUSH
1617: LD_INT 2
1619: PPUSH
1620: CALL 5856 0 3
1624: ST_TO_ADDR
// Oblukov := PrepareUnitExt ( Oblukov , false , class_soldier ) ;
1625: LD_ADDR_EXP 74
1629: PUSH
1630: LD_STRING Oblukov
1632: PPUSH
1633: LD_INT 0
1635: PPUSH
1636: LD_INT 1
1638: PPUSH
1639: CALL 5856 0 3
1643: ST_TO_ADDR
// Kapitsova := PrepareUnitExt ( Kapitsova , false , class_scientistic ) ;
1644: LD_ADDR_EXP 75
1648: PUSH
1649: LD_STRING Kapitsova
1651: PPUSH
1652: LD_INT 0
1654: PPUSH
1655: LD_INT 4
1657: PPUSH
1658: CALL 5856 0 3
1662: ST_TO_ADDR
// Popov := PrepareUnitExt ( Popov , false , 0 ) ;
1663: LD_ADDR_EXP 76
1667: PUSH
1668: LD_STRING Popov
1670: PPUSH
1671: LD_INT 0
1673: PPUSH
1674: LD_INT 0
1676: PPUSH
1677: CALL 5856 0 3
1681: ST_TO_ADDR
// PlaceUnitsArea ( [ Burlak , Karamazov , Petrovova , Gleb , Petrosyan , Titov , Dolgov , Lipshchin , Kirilenkova , Belkov , Belkov2 , Xavier , Gnyevko , Kovalyuk , Scholtze , Kuzmov , Kozlov , Oblukov , Kapitsova ] , RussianSpawnArea , false ) ;
1682: LD_EXP 57
1686: PUSH
1687: LD_EXP 58
1691: PUSH
1692: LD_EXP 59
1696: PUSH
1697: LD_EXP 60
1701: PUSH
1702: LD_EXP 61
1706: PUSH
1707: LD_EXP 62
1711: PUSH
1712: LD_EXP 63
1716: PUSH
1717: LD_EXP 64
1721: PUSH
1722: LD_EXP 65
1726: PUSH
1727: LD_EXP 66
1731: PUSH
1732: LD_EXP 67
1736: PUSH
1737: LD_EXP 68
1741: PUSH
1742: LD_EXP 69
1746: PUSH
1747: LD_EXP 70
1751: PUSH
1752: LD_EXP 71
1756: PUSH
1757: LD_EXP 72
1761: PUSH
1762: LD_EXP 73
1766: PUSH
1767: LD_EXP 74
1771: PUSH
1772: LD_EXP 75
1776: PUSH
1777: EMPTY
1778: LIST
1779: LIST
1780: LIST
1781: LIST
1782: LIST
1783: LIST
1784: LIST
1785: LIST
1786: LIST
1787: LIST
1788: LIST
1789: LIST
1790: LIST
1791: LIST
1792: LIST
1793: LIST
1794: LIST
1795: LIST
1796: LIST
1797: PPUSH
1798: LD_INT 2
1800: PPUSH
1801: LD_INT 0
1803: PPUSH
1804: CALL 6130 0 3
// PrepareVehicles ;
1808: CALL 2349 0 0
// other_survivors = CreateCharacterSet ( 07_other_survivors ) ;
1812: LD_ADDR_VAR 0 4
1816: PUSH
1817: LD_STRING 07_other_survivors
1819: PPUSH
1820: CALL_OW 31
1824: ST_TO_ADDR
// other_survivors = other_survivors ^ CreateCharacterSet ( 04_other_survivors ) ;
1825: LD_ADDR_VAR 0 4
1829: PUSH
1830: LD_VAR 0 4
1834: PUSH
1835: LD_STRING 04_other_survivors
1837: PPUSH
1838: CALL_OW 31
1842: ADD
1843: ST_TO_ADDR
// other_survivors = other_survivors ^ CreateCharacterSet ( 04_other_survivors_with_popov ) ;
1844: LD_ADDR_VAR 0 4
1848: PUSH
1849: LD_VAR 0 4
1853: PUSH
1854: LD_STRING 04_other_survivors_with_popov
1856: PPUSH
1857: CALL_OW 31
1861: ADD
1862: ST_TO_ADDR
// for un in other_survivors do
1863: LD_ADDR_VAR 0 3
1867: PUSH
1868: LD_VAR 0 4
1872: PUSH
1873: FOR_IN
1874: IFFALSE 1960
// begin emptyVeh = FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_vehicle ] , [ f_empty ] ] ) ;
1876: LD_ADDR_VAR 0 6
1880: PUSH
1881: LD_INT 22
1883: PUSH
1884: LD_INT 3
1886: PUSH
1887: EMPTY
1888: LIST
1889: LIST
1890: PUSH
1891: LD_INT 21
1893: PUSH
1894: LD_INT 2
1896: PUSH
1897: EMPTY
1898: LIST
1899: LIST
1900: PUSH
1901: LD_INT 58
1903: PUSH
1904: EMPTY
1905: LIST
1906: PUSH
1907: EMPTY
1908: LIST
1909: LIST
1910: LIST
1911: PPUSH
1912: CALL_OW 69
1916: ST_TO_ADDR
// if emptyVeh then
1917: LD_VAR 0 6
1921: IFFALSE 1943
// PlaceHumanInUnit ( un , emptyVeh [ 1 ] ) else
1923: LD_VAR 0 3
1927: PPUSH
1928: LD_VAR 0 6
1932: PUSH
1933: LD_INT 1
1935: ARRAY
1936: PPUSH
1937: CALL_OW 52
1941: GO 1958
// PlaceUnitArea ( un , RussianSpawnArea , false ) ;
1943: LD_VAR 0 3
1947: PPUSH
1948: LD_INT 2
1950: PPUSH
1951: LD_INT 0
1953: PPUSH
1954: CALL_OW 49
// end ;
1958: GO 1873
1960: POP
1961: POP
// yourUnits = FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_nation , nation_russian ] ] ) ;
1962: LD_ADDR_VAR 0 5
1966: PUSH
1967: LD_INT 22
1969: PUSH
1970: LD_INT 3
1972: PUSH
1973: EMPTY
1974: LIST
1975: LIST
1976: PUSH
1977: LD_INT 21
1979: PUSH
1980: LD_INT 1
1982: PUSH
1983: EMPTY
1984: LIST
1985: LIST
1986: PUSH
1987: LD_INT 23
1989: PUSH
1990: LD_INT 3
1992: PUSH
1993: EMPTY
1994: LIST
1995: LIST
1996: PUSH
1997: EMPTY
1998: LIST
1999: LIST
2000: LIST
2001: PPUSH
2002: CALL_OW 69
2006: ST_TO_ADDR
// if yourUnits < 15 then
2007: LD_VAR 0 5
2011: PUSH
2012: LD_INT 15
2014: LESS
2015: IFFALSE 2164
// for i := 1 to 15 - yourUnits do
2017: LD_ADDR_VAR 0 2
2021: PUSH
2022: DOUBLE
2023: LD_INT 1
2025: DEC
2026: ST_TO_ADDR
2027: LD_INT 15
2029: PUSH
2030: LD_VAR 0 5
2034: MINUS
2035: PUSH
2036: FOR_TO
2037: IFFALSE 2162
// begin PrepareHuman ( false , rand ( 1 , 4 ) , rand ( 2 , 4 ) ) ;
2039: LD_INT 0
2041: PPUSH
2042: LD_INT 1
2044: PPUSH
2045: LD_INT 4
2047: PPUSH
2048: CALL_OW 12
2052: PPUSH
2053: LD_INT 2
2055: PPUSH
2056: LD_INT 4
2058: PPUSH
2059: CALL_OW 12
2063: PPUSH
2064: CALL_OW 380
// un = CreateHuman ;
2068: LD_ADDR_VAR 0 3
2072: PUSH
2073: CALL_OW 44
2077: ST_TO_ADDR
// emptyVeh = FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_vehicle ] , [ f_empty ] ] ) ;
2078: LD_ADDR_VAR 0 6
2082: PUSH
2083: LD_INT 22
2085: PUSH
2086: LD_INT 3
2088: PUSH
2089: EMPTY
2090: LIST
2091: LIST
2092: PUSH
2093: LD_INT 21
2095: PUSH
2096: LD_INT 2
2098: PUSH
2099: EMPTY
2100: LIST
2101: LIST
2102: PUSH
2103: LD_INT 58
2105: PUSH
2106: EMPTY
2107: LIST
2108: PUSH
2109: EMPTY
2110: LIST
2111: LIST
2112: LIST
2113: PPUSH
2114: CALL_OW 69
2118: ST_TO_ADDR
// if emptyVeh then
2119: LD_VAR 0 6
2123: IFFALSE 2145
// PlaceHumanInUnit ( un , emptyVeh [ 1 ] ) else
2125: LD_VAR 0 3
2129: PPUSH
2130: LD_VAR 0 6
2134: PUSH
2135: LD_INT 1
2137: ARRAY
2138: PPUSH
2139: CALL_OW 52
2143: GO 2160
// PlaceUnitArea ( un , RussianSpawnArea , false ) ;
2145: LD_VAR 0 3
2149: PPUSH
2150: LD_INT 2
2152: PPUSH
2153: LD_INT 0
2155: PPUSH
2156: CALL_OW 49
// end ;
2160: GO 2036
2162: POP
2163: POP
// yourUnits = FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_nation , nation_russian ] ] ) ;
2164: LD_ADDR_VAR 0 5
2168: PUSH
2169: LD_INT 22
2171: PUSH
2172: LD_INT 3
2174: PUSH
2175: EMPTY
2176: LIST
2177: LIST
2178: PUSH
2179: LD_INT 21
2181: PUSH
2182: LD_INT 1
2184: PUSH
2185: EMPTY
2186: LIST
2187: LIST
2188: PUSH
2189: LD_INT 23
2191: PUSH
2192: LD_INT 3
2194: PUSH
2195: EMPTY
2196: LIST
2197: LIST
2198: PUSH
2199: EMPTY
2200: LIST
2201: LIST
2202: LIST
2203: PPUSH
2204: CALL_OW 69
2208: ST_TO_ADDR
// if not UnitFilter ( yourUnits , [ f_class , class_engineer ] ) then
2209: LD_VAR 0 5
2213: PPUSH
2214: LD_INT 25
2216: PUSH
2217: LD_INT 2
2219: PUSH
2220: EMPTY
2221: LIST
2222: LIST
2223: PPUSH
2224: CALL_OW 72
2228: NOT
2229: IFFALSE 2247
// SetClass ( yourUnits [ 1 ] , 2 ) ;
2231: LD_VAR 0 5
2235: PUSH
2236: LD_INT 1
2238: ARRAY
2239: PPUSH
2240: LD_INT 2
2242: PPUSH
2243: CALL_OW 336
// end ;
2247: LD_VAR 0 1
2251: RET
// export function PrepareRussianEscort ; var i , unit ; begin
2252: LD_INT 0
2254: PPUSH
2255: PPUSH
2256: PPUSH
// uc_side = 6 ;
2257: LD_ADDR_OWVAR 20
2261: PUSH
2262: LD_INT 6
2264: ST_TO_ADDR
// uc_nation = 3 ;
2265: LD_ADDR_OWVAR 21
2269: PUSH
2270: LD_INT 3
2272: ST_TO_ADDR
// for i := 1 to 2 do
2273: LD_ADDR_VAR 0 2
2277: PUSH
2278: DOUBLE
2279: LD_INT 1
2281: DEC
2282: ST_TO_ADDR
2283: LD_INT 2
2285: PUSH
2286: FOR_TO
2287: IFFALSE 2342
// begin PrepareSoldier ( false , 4 ) ;
2289: LD_INT 0
2291: PPUSH
2292: LD_INT 4
2294: PPUSH
2295: CALL_OW 381
// unit = CreateHuman ;
2299: LD_ADDR_VAR 0 3
2303: PUSH
2304: CALL_OW 44
2308: ST_TO_ADDR
// russianEscort = russianEscort ^ unit ;
2309: LD_ADDR_EXP 77
2313: PUSH
2314: LD_EXP 77
2318: PUSH
2319: LD_VAR 0 3
2323: ADD
2324: ST_TO_ADDR
// PlaceUnitArea ( unit , RussianSpawn2Area , false ) ;
2325: LD_VAR 0 3
2329: PPUSH
2330: LD_INT 7
2332: PPUSH
2333: LD_INT 0
2335: PPUSH
2336: CALL_OW 49
// end ;
2340: GO 2286
2342: POP
2343: POP
// end ;
2344: LD_VAR 0 1
2348: RET
// function PrepareVehicles ; var i , veh ; begin
2349: LD_INT 0
2351: PPUSH
2352: PPUSH
2353: PPUSH
// uc_side = 3 ;
2354: LD_ADDR_OWVAR 20
2358: PUSH
2359: LD_INT 3
2361: ST_TO_ADDR
// uc_nation = 3 ;
2362: LD_ADDR_OWVAR 21
2366: PUSH
2367: LD_INT 3
2369: ST_TO_ADDR
// for i := 1 to 5 do
2370: LD_ADDR_VAR 0 2
2374: PUSH
2375: DOUBLE
2376: LD_INT 1
2378: DEC
2379: ST_TO_ADDR
2380: LD_INT 5
2382: PUSH
2383: FOR_TO
2384: IFFALSE 2494
// begin PrepareVehicle ( ru_medium_wheeled , engine_combustion , control_manual , ru_cargo_bay , rand ( 60 , 80 ) ) ;
2386: LD_INT 21
2388: PPUSH
2389: LD_INT 1
2391: PPUSH
2392: LD_INT 1
2394: PPUSH
2395: LD_INT 51
2397: PPUSH
2398: LD_INT 60
2400: PPUSH
2401: LD_INT 80
2403: PPUSH
2404: CALL_OW 12
2408: PPUSH
2409: CALL 23974 0 5
// veh = CreateVehicle ;
2413: LD_ADDR_VAR 0 3
2417: PUSH
2418: CALL_OW 45
2422: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
2423: LD_VAR 0 3
2427: PPUSH
2428: LD_INT 4
2430: PPUSH
2431: CALL_OW 233
// PlaceUnitArea ( veh , RussianSpawnArea , false ) ;
2435: LD_VAR 0 3
2439: PPUSH
2440: LD_INT 2
2442: PPUSH
2443: LD_INT 0
2445: PPUSH
2446: CALL_OW 49
// if ( i <> 5 ) then
2450: LD_VAR 0 2
2454: PUSH
2455: LD_INT 5
2457: NONEQUAL
2458: IFFALSE 2477
// AddCargo ( veh , mat_cans , 100 ) else
2460: LD_VAR 0 3
2464: PPUSH
2465: LD_INT 1
2467: PPUSH
2468: LD_INT 100
2470: PPUSH
2471: CALL_OW 291
2475: GO 2492
// AddCargo ( veh , mat_oil , 100 ) ;
2477: LD_VAR 0 3
2481: PPUSH
2482: LD_INT 2
2484: PPUSH
2485: LD_INT 100
2487: PPUSH
2488: CALL_OW 291
// end ;
2492: GO 2383
2494: POP
2495: POP
// PrepareVehicle ( ru_medium_wheeled , engine_combustion , control_manual , ru_crane , rand ( 60 , 80 ) ) ;
2496: LD_INT 21
2498: PPUSH
2499: LD_INT 1
2501: PPUSH
2502: LD_INT 1
2504: PPUSH
2505: LD_INT 52
2507: PPUSH
2508: LD_INT 60
2510: PPUSH
2511: LD_INT 80
2513: PPUSH
2514: CALL_OW 12
2518: PPUSH
2519: CALL 23974 0 5
// veh = CreateVehicle ;
2523: LD_ADDR_VAR 0 3
2527: PUSH
2528: CALL_OW 45
2532: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
2533: LD_VAR 0 3
2537: PPUSH
2538: LD_INT 4
2540: PPUSH
2541: CALL_OW 233
// PlaceUnitArea ( veh , RussianSpawnArea , false ) ;
2545: LD_VAR 0 3
2549: PPUSH
2550: LD_INT 2
2552: PPUSH
2553: LD_INT 0
2555: PPUSH
2556: CALL_OW 49
// for i := 1 to 3 do
2560: LD_ADDR_VAR 0 2
2564: PUSH
2565: DOUBLE
2566: LD_INT 1
2568: DEC
2569: ST_TO_ADDR
2570: LD_INT 3
2572: PUSH
2573: FOR_TO
2574: IFFALSE 2642
// begin PrepareVehicle ( ru_heavy_tracked , engine_combustion , control_manual , ru_bulldozer , rand ( 60 , 80 ) ) ;
2576: LD_INT 24
2578: PPUSH
2579: LD_INT 1
2581: PPUSH
2582: LD_INT 1
2584: PPUSH
2585: LD_INT 53
2587: PPUSH
2588: LD_INT 60
2590: PPUSH
2591: LD_INT 80
2593: PPUSH
2594: CALL_OW 12
2598: PPUSH
2599: CALL 23974 0 5
// veh = CreateVehicle ;
2603: LD_ADDR_VAR 0 3
2607: PUSH
2608: CALL_OW 45
2612: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
2613: LD_VAR 0 3
2617: PPUSH
2618: LD_INT 4
2620: PPUSH
2621: CALL_OW 233
// PlaceUnitArea ( veh , RussianSpawnArea , false ) ;
2625: LD_VAR 0 3
2629: PPUSH
2630: LD_INT 2
2632: PPUSH
2633: LD_INT 0
2635: PPUSH
2636: CALL_OW 49
// end ;
2640: GO 2573
2642: POP
2643: POP
// end ;
2644: LD_VAR 0 1
2648: RET
// function InitRussianRequiments ; var i ; begin
2649: LD_INT 0
2651: PPUSH
2652: PPUSH
// availableWeapons = [ ru_heavy_machine_gun , ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher ] ;
2653: LD_ADDR_EXP 11
2657: PUSH
2658: LD_INT 42
2660: PUSH
2661: LD_INT 43
2663: PUSH
2664: LD_INT 44
2666: PUSH
2667: LD_INT 46
2669: PUSH
2670: LD_INT 45
2672: PUSH
2673: EMPTY
2674: LIST
2675: LIST
2676: LIST
2677: LIST
2678: LIST
2679: ST_TO_ADDR
// for i := 1 to availableWeapons do
2680: LD_ADDR_VAR 0 2
2684: PUSH
2685: DOUBLE
2686: LD_INT 1
2688: DEC
2689: ST_TO_ADDR
2690: LD_EXP 11
2694: PUSH
2695: FOR_TO
2696: IFFALSE 2736
// weaponsData = weaponsData ^ [ [ availableWeapons [ i ] , false , false ] ] ;
2698: LD_ADDR_EXP 12
2702: PUSH
2703: LD_EXP 12
2707: PUSH
2708: LD_EXP 11
2712: PUSH
2713: LD_VAR 0 2
2717: ARRAY
2718: PUSH
2719: LD_INT 0
2721: PUSH
2722: LD_INT 0
2724: PUSH
2725: EMPTY
2726: LIST
2727: LIST
2728: LIST
2729: PUSH
2730: EMPTY
2731: LIST
2732: ADD
2733: ST_TO_ADDR
2734: GO 2695
2736: POP
2737: POP
// for i := 0 to 50 do
2738: LD_ADDR_VAR 0 2
2742: PUSH
2743: DOUBLE
2744: LD_INT 0
2746: DEC
2747: ST_TO_ADDR
2748: LD_INT 50
2750: PUSH
2751: FOR_TO
2752: IFFALSE 2790
// if GetRestrict ( i , 3 ) = state_enabled then
2754: LD_VAR 0 2
2758: PPUSH
2759: LD_INT 3
2761: PPUSH
2762: CALL_OW 323
2766: PUSH
2767: LD_INT 1
2769: EQUAL
2770: IFFALSE 2788
// buildingsToBuild = buildingsToBuild ^ i ;
2772: LD_ADDR_EXP 8
2776: PUSH
2777: LD_EXP 8
2781: PUSH
2782: LD_VAR 0 2
2786: ADD
2787: ST_TO_ADDR
2788: GO 2751
2790: POP
2791: POP
// buildingsToBuild = buildingsToBuild diff [ 0 , 2 , 4 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 14 , 22 , 31 , 32 , 33 , 39 , 40 ] ;
2792: LD_ADDR_EXP 8
2796: PUSH
2797: LD_EXP 8
2801: PUSH
2802: LD_INT 0
2804: PUSH
2805: LD_INT 2
2807: PUSH
2808: LD_INT 4
2810: PUSH
2811: LD_INT 6
2813: PUSH
2814: LD_INT 7
2816: PUSH
2817: LD_INT 8
2819: PUSH
2820: LD_INT 9
2822: PUSH
2823: LD_INT 10
2825: PUSH
2826: LD_INT 11
2828: PUSH
2829: LD_INT 12
2831: PUSH
2832: LD_INT 14
2834: PUSH
2835: LD_INT 22
2837: PUSH
2838: LD_INT 31
2840: PUSH
2841: LD_INT 32
2843: PUSH
2844: LD_INT 33
2846: PUSH
2847: LD_INT 39
2849: PUSH
2850: LD_INT 40
2852: PUSH
2853: EMPTY
2854: LIST
2855: LIST
2856: LIST
2857: LIST
2858: LIST
2859: LIST
2860: LIST
2861: LIST
2862: LIST
2863: LIST
2864: LIST
2865: LIST
2866: LIST
2867: LIST
2868: LIST
2869: LIST
2870: LIST
2871: DIFF
2872: ST_TO_ADDR
// allBuildings = buildingsToBuild ;
2873: LD_ADDR_EXP 13
2877: PUSH
2878: LD_EXP 8
2882: ST_TO_ADDR
// techsToResearch = GetTechNation ( 3 , nation_russian , state_enabled ) ;
2883: LD_ADDR_EXP 9
2887: PUSH
2888: LD_INT 3
2890: PPUSH
2891: LD_INT 3
2893: PPUSH
2894: LD_INT 1
2896: PPUSH
2897: CALL 19213 0 3
2901: ST_TO_ADDR
// end ; end_of_file
2902: LD_VAR 0 1
2906: RET
// export amAttackTeam ; export function PrepareAmericans ; begin
2907: LD_INT 0
2909: PPUSH
// amAttackTeam = [ ] ;
2910: LD_ADDR_EXP 78
2914: PUSH
2915: EMPTY
2916: ST_TO_ADDR
// SpawnAmericansSnipers ;
2917: CALL 3045 0 0
// case Difficulty of 2 :
2921: LD_OWVAR 67
2925: PUSH
2926: LD_INT 2
2928: DOUBLE
2929: EQUAL
2930: IFTRUE 2934
2932: GO 2963
2934: POP
// begin SetTech ( tech_comp1 , 1 , state_researched ) ;
2935: LD_INT 57
2937: PPUSH
2938: LD_INT 1
2940: PPUSH
2941: LD_INT 2
2943: PPUSH
2944: CALL_OW 322
// SetTech ( tech_opto1 , 1 , state_researched ) ;
2948: LD_INT 60
2950: PPUSH
2951: LD_INT 1
2953: PPUSH
2954: LD_INT 2
2956: PPUSH
2957: CALL_OW 322
// end ; 3 :
2961: GO 3040
2963: LD_INT 3
2965: DOUBLE
2966: EQUAL
2967: IFTRUE 2971
2969: GO 3039
2971: POP
// begin SetTech ( tech_comp1 , 1 , state_researched ) ;
2972: LD_INT 57
2974: PPUSH
2975: LD_INT 1
2977: PPUSH
2978: LD_INT 2
2980: PPUSH
2981: CALL_OW 322
// SetTech ( tech_comp2 , 1 , state_researched ) ;
2985: LD_INT 58
2987: PPUSH
2988: LD_INT 1
2990: PPUSH
2991: LD_INT 2
2993: PPUSH
2994: CALL_OW 322
// SetTech ( tech_weap3 , 1 , state_researched ) ;
2998: LD_INT 53
3000: PPUSH
3001: LD_INT 1
3003: PPUSH
3004: LD_INT 2
3006: PPUSH
3007: CALL_OW 322
// SetTech ( tech_opto1 , 1 , state_researched ) ;
3011: LD_INT 60
3013: PPUSH
3014: LD_INT 1
3016: PPUSH
3017: LD_INT 2
3019: PPUSH
3020: CALL_OW 322
// SetTech ( tech_opto2 , 1 , state_researched ) ;
3024: LD_INT 61
3026: PPUSH
3027: LD_INT 1
3029: PPUSH
3030: LD_INT 2
3032: PPUSH
3033: CALL_OW 322
// end ; end ;
3037: GO 3040
3039: POP
// end ;
3040: LD_VAR 0 1
3044: RET
// export function SpawnAmericansSnipers ; var i , un ; begin
3045: LD_INT 0
3047: PPUSH
3048: PPUSH
3049: PPUSH
// uc_side = 1 ;
3050: LD_ADDR_OWVAR 20
3054: PUSH
3055: LD_INT 1
3057: ST_TO_ADDR
// uc_nation = 1 ;
3058: LD_ADDR_OWVAR 21
3062: PUSH
3063: LD_INT 1
3065: ST_TO_ADDR
// for i := 1 to 8 do
3066: LD_ADDR_VAR 0 2
3070: PUSH
3071: DOUBLE
3072: LD_INT 1
3074: DEC
3075: ST_TO_ADDR
3076: LD_INT 8
3078: PUSH
3079: FOR_TO
3080: IFFALSE 3133
// begin PrepareHuman ( false , class_sniper , enemySkillLevel ) ;
3082: LD_INT 0
3084: PPUSH
3085: LD_INT 5
3087: PPUSH
3088: LD_EXP 56
3092: PPUSH
3093: CALL_OW 380
// un = CreateHuman ;
3097: LD_ADDR_VAR 0 3
3101: PUSH
3102: CALL_OW 44
3106: ST_TO_ADDR
// PlaceUnitArea ( un , AmericansSnipersSpawnArea , false ) ;
3107: LD_VAR 0 3
3111: PPUSH
3112: LD_INT 14
3114: PPUSH
3115: LD_INT 0
3117: PPUSH
3118: CALL_OW 49
// ComHold ( un ) ;
3122: LD_VAR 0 3
3126: PPUSH
3127: CALL_OW 140
// end ;
3131: GO 3079
3133: POP
3134: POP
// end ;
3135: LD_VAR 0 1
3139: RET
// export function SpawnAmAttackTeam ; var i , unit , veh , randVehType , weapon , chassis , amSolds , amSnipers , amVehs ; begin
3140: LD_INT 0
3142: PPUSH
3143: PPUSH
3144: PPUSH
3145: PPUSH
3146: PPUSH
3147: PPUSH
3148: PPUSH
3149: PPUSH
3150: PPUSH
3151: PPUSH
// uc_side = 1 ;
3152: LD_ADDR_OWVAR 20
3156: PUSH
3157: LD_INT 1
3159: ST_TO_ADDR
// uc_nation = 1 ;
3160: LD_ADDR_OWVAR 21
3164: PUSH
3165: LD_INT 1
3167: ST_TO_ADDR
// amSolds = Rand ( enemyAttackUnitsData [ 1 ] [ 2 ] , enemyAttackUnitsData [ 1 ] [ 3 ] ) ;
3168: LD_ADDR_VAR 0 8
3172: PUSH
3173: LD_EXP 53
3177: PUSH
3178: LD_INT 1
3180: ARRAY
3181: PUSH
3182: LD_INT 2
3184: ARRAY
3185: PPUSH
3186: LD_EXP 53
3190: PUSH
3191: LD_INT 1
3193: ARRAY
3194: PUSH
3195: LD_INT 3
3197: ARRAY
3198: PPUSH
3199: CALL_OW 12
3203: ST_TO_ADDR
// amSnipers = Rand ( enemyAttackUnitsData [ 1 ] [ 4 ] , enemyAttackUnitsData [ 1 ] [ 5 ] ) ;
3204: LD_ADDR_VAR 0 9
3208: PUSH
3209: LD_EXP 53
3213: PUSH
3214: LD_INT 1
3216: ARRAY
3217: PUSH
3218: LD_INT 4
3220: ARRAY
3221: PPUSH
3222: LD_EXP 53
3226: PUSH
3227: LD_INT 1
3229: ARRAY
3230: PUSH
3231: LD_INT 5
3233: ARRAY
3234: PPUSH
3235: CALL_OW 12
3239: ST_TO_ADDR
// amVehs = Rand ( enemyAttackUnitsData [ 1 ] [ 6 ] , enemyAttackUnitsData [ 1 ] [ 7 ] ) ;
3240: LD_ADDR_VAR 0 10
3244: PUSH
3245: LD_EXP 53
3249: PUSH
3250: LD_INT 1
3252: ARRAY
3253: PUSH
3254: LD_INT 6
3256: ARRAY
3257: PPUSH
3258: LD_EXP 53
3262: PUSH
3263: LD_INT 1
3265: ARRAY
3266: PUSH
3267: LD_INT 7
3269: ARRAY
3270: PPUSH
3271: CALL_OW 12
3275: ST_TO_ADDR
// if paidLegionOffert then
3276: LD_EXP 32
3280: IFFALSE 3314
// begin amSolds = amSolds - legionReduceAmericansUnits ;
3282: LD_ADDR_VAR 0 8
3286: PUSH
3287: LD_VAR 0 8
3291: PUSH
3292: LD_EXP 51
3296: MINUS
3297: ST_TO_ADDR
// amVehs = amVehs - legionReduceAmericansUnits ;
3298: LD_ADDR_VAR 0 10
3302: PUSH
3303: LD_VAR 0 10
3307: PUSH
3308: LD_EXP 51
3312: MINUS
3313: ST_TO_ADDR
// end ; for i := 1 to amSolds do
3314: LD_ADDR_VAR 0 2
3318: PUSH
3319: DOUBLE
3320: LD_INT 1
3322: DEC
3323: ST_TO_ADDR
3324: LD_VAR 0 8
3328: PUSH
3329: FOR_TO
3330: IFFALSE 3387
// begin PrepareSoldier ( false , enemySkillLevel ) ;
3332: LD_INT 0
3334: PPUSH
3335: LD_EXP 56
3339: PPUSH
3340: CALL_OW 381
// unit = CreateHuman ;
3344: LD_ADDR_VAR 0 3
3348: PUSH
3349: CALL_OW 44
3353: ST_TO_ADDR
// PlaceUnitArea ( unit , AmericanSpawnArea , false ) ;
3354: LD_VAR 0 3
3358: PPUSH
3359: LD_INT 3
3361: PPUSH
3362: LD_INT 0
3364: PPUSH
3365: CALL_OW 49
// amAttackTeam = amAttackTeam ^ unit ;
3369: LD_ADDR_EXP 78
3373: PUSH
3374: LD_EXP 78
3378: PUSH
3379: LD_VAR 0 3
3383: ADD
3384: ST_TO_ADDR
// end ;
3385: GO 3329
3387: POP
3388: POP
// for i := 1 to amSnipers do
3389: LD_ADDR_VAR 0 2
3393: PUSH
3394: DOUBLE
3395: LD_INT 1
3397: DEC
3398: ST_TO_ADDR
3399: LD_VAR 0 9
3403: PUSH
3404: FOR_TO
3405: IFFALSE 3465
// begin PrepareHuman ( false , class_sniper , enemySkillLevel ) ;
3407: LD_INT 0
3409: PPUSH
3410: LD_INT 5
3412: PPUSH
3413: LD_EXP 56
3417: PPUSH
3418: CALL_OW 380
// unit = CreateHuman ;
3422: LD_ADDR_VAR 0 3
3426: PUSH
3427: CALL_OW 44
3431: ST_TO_ADDR
// PlaceUnitArea ( unit , AmericanSpawnArea , false ) ;
3432: LD_VAR 0 3
3436: PPUSH
3437: LD_INT 3
3439: PPUSH
3440: LD_INT 0
3442: PPUSH
3443: CALL_OW 49
// amAttackTeam = amAttackTeam ^ unit ;
3447: LD_ADDR_EXP 78
3451: PUSH
3452: LD_EXP 78
3456: PUSH
3457: LD_VAR 0 3
3461: ADD
3462: ST_TO_ADDR
// end ;
3463: GO 3404
3465: POP
3466: POP
// for i := 1 to amVehs do
3467: LD_ADDR_VAR 0 2
3471: PUSH
3472: DOUBLE
3473: LD_INT 1
3475: DEC
3476: ST_TO_ADDR
3477: LD_VAR 0 10
3481: PUSH
3482: FOR_TO
3483: IFFALSE 3766
// begin randVehType = Rand ( 1 , 4 ) ;
3485: LD_ADDR_VAR 0 5
3489: PUSH
3490: LD_INT 1
3492: PPUSH
3493: LD_INT 4
3495: PPUSH
3496: CALL_OW 12
3500: ST_TO_ADDR
// weapon = [ us_gatling_gun , us_double_gun , us_light_gun , us_rocket_launcher , us_heavy_gun ] [ Rand ( 1 , 5 ) ] ;
3501: LD_ADDR_VAR 0 6
3505: PUSH
3506: LD_INT 4
3508: PUSH
3509: LD_INT 5
3511: PUSH
3512: LD_INT 3
3514: PUSH
3515: LD_INT 7
3517: PUSH
3518: LD_INT 6
3520: PUSH
3521: EMPTY
3522: LIST
3523: LIST
3524: LIST
3525: LIST
3526: LIST
3527: PUSH
3528: LD_INT 1
3530: PPUSH
3531: LD_INT 5
3533: PPUSH
3534: CALL_OW 12
3538: ARRAY
3539: ST_TO_ADDR
// if weapon = us_heavy_gun then
3540: LD_VAR 0 6
3544: PUSH
3545: LD_INT 6
3547: EQUAL
3548: IFFALSE 3560
// chassis = us_heavy_tracked else
3550: LD_ADDR_VAR 0 7
3554: PUSH
3555: LD_INT 4
3557: ST_TO_ADDR
3558: GO 3587
// chassis = [ us_medium_tracked , us_heavy_tracked ] [ Rand ( 1 , 2 ) ] ;
3560: LD_ADDR_VAR 0 7
3564: PUSH
3565: LD_INT 3
3567: PUSH
3568: LD_INT 4
3570: PUSH
3571: EMPTY
3572: LIST
3573: LIST
3574: PUSH
3575: LD_INT 1
3577: PPUSH
3578: LD_INT 2
3580: PPUSH
3581: CALL_OW 12
3585: ARRAY
3586: ST_TO_ADDR
// if randVehType = 1 then
3587: LD_VAR 0 5
3591: PUSH
3592: LD_INT 1
3594: EQUAL
3595: IFFALSE 3630
// PrepareVehicle ( chassis , engine_combustion , control_manual , weapon , Rand ( 70 , 90 ) ) else
3597: LD_VAR 0 7
3601: PPUSH
3602: LD_INT 1
3604: PPUSH
3605: LD_INT 1
3607: PPUSH
3608: LD_VAR 0 6
3612: PPUSH
3613: LD_INT 70
3615: PPUSH
3616: LD_INT 90
3618: PPUSH
3619: CALL_OW 12
3623: PPUSH
3624: CALL 23974 0 5
3628: GO 3661
// PrepareVehicle ( chassis , engine_combustion , control_computer , weapon , Rand ( 70 , 90 ) ) ;
3630: LD_VAR 0 7
3634: PPUSH
3635: LD_INT 1
3637: PPUSH
3638: LD_INT 3
3640: PPUSH
3641: LD_VAR 0 6
3645: PPUSH
3646: LD_INT 70
3648: PPUSH
3649: LD_INT 90
3651: PPUSH
3652: CALL_OW 12
3656: PPUSH
3657: CALL 23974 0 5
// veh = CreateVehicle ;
3661: LD_ADDR_VAR 0 4
3665: PUSH
3666: CALL_OW 45
3670: ST_TO_ADDR
// PlaceUnitArea ( veh , AmericanSpawnArea , false ) ;
3671: LD_VAR 0 4
3675: PPUSH
3676: LD_INT 3
3678: PPUSH
3679: LD_INT 0
3681: PPUSH
3682: CALL_OW 49
// amAttackTeam = amAttackTeam ^ veh ;
3686: LD_ADDR_EXP 78
3690: PUSH
3691: LD_EXP 78
3695: PUSH
3696: LD_VAR 0 4
3700: ADD
3701: ST_TO_ADDR
// if randVehType = 1 then
3702: LD_VAR 0 5
3706: PUSH
3707: LD_INT 1
3709: EQUAL
3710: IFFALSE 3764
// begin PrepareMechanic ( false , enemySkillLevel ) ;
3712: LD_INT 0
3714: PPUSH
3715: LD_EXP 56
3719: PPUSH
3720: CALL_OW 383
// unit = CreateHuman ;
3724: LD_ADDR_VAR 0 3
3728: PUSH
3729: CALL_OW 44
3733: ST_TO_ADDR
// PlaceHumanInUnit ( unit , veh ) ;
3734: LD_VAR 0 3
3738: PPUSH
3739: LD_VAR 0 4
3743: PPUSH
3744: CALL_OW 52
// amAttackTeam = amAttackTeam ^ unit ;
3748: LD_ADDR_EXP 78
3752: PUSH
3753: LD_EXP 78
3757: PUSH
3758: LD_VAR 0 3
3762: ADD
3763: ST_TO_ADDR
// end ; end ;
3764: GO 3482
3766: POP
3767: POP
// end ; end_of_file
3768: LD_VAR 0 1
3772: RET
// export Heike , Kurt , Dietrich ; export KurtEng ; export GensherTeam ; export arAttackTeam ; export function PrepareArabians ; begin
3773: LD_INT 0
3775: PPUSH
// arAttackTeam = [ ] ;
3776: LD_ADDR_EXP 84
3780: PUSH
3781: EMPTY
3782: ST_TO_ADDR
// PrepareHeroes ;
3783: CALL 4188 0 0
// case Difficulty of 2 :
3787: LD_OWVAR 67
3791: PUSH
3792: LD_INT 2
3794: DOUBLE
3795: EQUAL
3796: IFTRUE 3800
3798: GO 3816
3800: POP
// begin SetTech ( tech_stimDrugs , 8 , state_researched ) ;
3801: LD_INT 5
3803: PPUSH
3804: LD_INT 8
3806: PPUSH
3807: LD_INT 2
3809: PPUSH
3810: CALL_OW 322
// end ; 3 :
3814: GO 3867
3816: LD_INT 3
3818: DOUBLE
3819: EQUAL
3820: IFTRUE 3824
3822: GO 3866
3824: POP
// begin SetTech ( tech_stimDrugs , 8 , state_researched ) ;
3825: LD_INT 5
3827: PPUSH
3828: LD_INT 8
3830: PPUSH
3831: LD_INT 2
3833: PPUSH
3834: CALL_OW 322
// SetTech ( tech_bio1 , 8 , state_researched ) ;
3838: LD_INT 66
3840: PPUSH
3841: LD_INT 8
3843: PPUSH
3844: LD_INT 2
3846: PPUSH
3847: CALL_OW 322
// SetTech ( tech_weap3 , 8 , state_researched ) ;
3851: LD_INT 53
3853: PPUSH
3854: LD_INT 8
3856: PPUSH
3857: LD_INT 2
3859: PPUSH
3860: CALL_OW 322
// end ; end ;
3864: GO 3867
3866: POP
// end ;
3867: LD_VAR 0 1
3871: RET
// export function SpawnGensherTeam ; var i , driver , veh ; begin
3872: LD_INT 0
3874: PPUSH
3875: PPUSH
3876: PPUSH
3877: PPUSH
// GensherTeam = [ ] ;
3878: LD_ADDR_EXP 83
3882: PUSH
3883: EMPTY
3884: ST_TO_ADDR
// uc_side = 2 ;
3885: LD_ADDR_OWVAR 20
3889: PUSH
3890: LD_INT 2
3892: ST_TO_ADDR
// uc_nation = 2 ;
3893: LD_ADDR_OWVAR 21
3897: PUSH
3898: LD_INT 2
3900: ST_TO_ADDR
// for i := 1 to 3 do
3901: LD_ADDR_VAR 0 2
3905: PUSH
3906: DOUBLE
3907: LD_INT 1
3909: DEC
3910: ST_TO_ADDR
3911: LD_INT 3
3913: PUSH
3914: FOR_TO
3915: IFFALSE 4074
// begin PrepareSoldier ( sex_male , rand ( 3 , 5 ) ) ;
3917: LD_INT 1
3919: PPUSH
3920: LD_INT 3
3922: PPUSH
3923: LD_INT 5
3925: PPUSH
3926: CALL_OW 12
3930: PPUSH
3931: CALL_OW 381
// driver = CreateHuman ;
3935: LD_ADDR_VAR 0 3
3939: PUSH
3940: CALL_OW 44
3944: ST_TO_ADDR
// PrepareVehicle ( ar_medium_trike , engine_combustion , control_manual , ar_cargo_bay , rand ( 50 , 70 ) ) ;
3945: LD_INT 13
3947: PPUSH
3948: LD_INT 1
3950: PPUSH
3951: LD_INT 1
3953: PPUSH
3954: LD_INT 32
3956: PPUSH
3957: LD_INT 50
3959: PPUSH
3960: LD_INT 70
3962: PPUSH
3963: CALL_OW 12
3967: PPUSH
3968: CALL 23974 0 5
// veh = CreateVehicle ;
3972: LD_ADDR_VAR 0 4
3976: PUSH
3977: CALL_OW 45
3981: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
3982: LD_VAR 0 4
3986: PPUSH
3987: LD_INT 4
3989: PPUSH
3990: CALL_OW 233
// PlaceUnitArea ( veh , GensherSpawnArea , false ) ;
3994: LD_VAR 0 4
3998: PPUSH
3999: LD_INT 4
4001: PPUSH
4002: LD_INT 0
4004: PPUSH
4005: CALL_OW 49
// PlaceHumanInUnit ( driver , veh ) ;
4009: LD_VAR 0 3
4013: PPUSH
4014: LD_VAR 0 4
4018: PPUSH
4019: CALL_OW 52
// AddCargo ( veh , i , 100 ) ;
4023: LD_VAR 0 4
4027: PPUSH
4028: LD_VAR 0 2
4032: PPUSH
4033: LD_INT 100
4035: PPUSH
4036: CALL_OW 291
// GensherTeam = GensherTeam ^ driver ;
4040: LD_ADDR_EXP 83
4044: PUSH
4045: LD_EXP 83
4049: PUSH
4050: LD_VAR 0 3
4054: ADD
4055: ST_TO_ADDR
// GensherTeam = GensherTeam ^ veh ;
4056: LD_ADDR_EXP 83
4060: PUSH
4061: LD_EXP 83
4065: PUSH
4066: LD_VAR 0 4
4070: ADD
4071: ST_TO_ADDR
// end ;
4072: GO 3914
4074: POP
4075: POP
// if IsOK ( KurtEng ) and GetSide ( KurtEng ) = 3 then
4076: LD_EXP 82
4080: PPUSH
4081: CALL_OW 302
4085: PUSH
4086: LD_EXP 82
4090: PPUSH
4091: CALL_OW 255
4095: PUSH
4096: LD_INT 3
4098: EQUAL
4099: AND
4100: IFFALSE 4134
// begin GensherTargetX = GetX ( Kurt ) ;
4102: LD_ADDR_EXP 16
4106: PUSH
4107: LD_EXP 80
4111: PPUSH
4112: CALL_OW 250
4116: ST_TO_ADDR
// GensherTargetY = GetY ( Kurt ) ;
4117: LD_ADDR_EXP 17
4121: PUSH
4122: LD_EXP 80
4126: PPUSH
4127: CALL_OW 251
4131: ST_TO_ADDR
// end else
4132: GO 4164
// begin GensherTargetX = GetX ( Burlak ) ;
4134: LD_ADDR_EXP 16
4138: PUSH
4139: LD_EXP 57
4143: PPUSH
4144: CALL_OW 250
4148: ST_TO_ADDR
// GensherTargetY = GetY ( Burlak ) ;
4149: LD_ADDR_EXP 17
4153: PUSH
4154: LD_EXP 57
4158: PPUSH
4159: CALL_OW 251
4163: ST_TO_ADDR
// end ; ComMoveXY ( GensherTeam , GensherTargetX , GensherTargetY ) ;
4164: LD_EXP 83
4168: PPUSH
4169: LD_EXP 16
4173: PPUSH
4174: LD_EXP 17
4178: PPUSH
4179: CALL_OW 111
// end ;
4183: LD_VAR 0 1
4187: RET
// function PrepareHeroes ; begin
4188: LD_INT 0
4190: PPUSH
// uc_side = 5 ;
4191: LD_ADDR_OWVAR 20
4195: PUSH
4196: LD_INT 5
4198: ST_TO_ADDR
// uc_nation = 2 ;
4199: LD_ADDR_OWVAR 21
4203: PUSH
4204: LD_INT 2
4206: ST_TO_ADDR
// Heike = PrepareUnitExt ( Heike , true , class_engineer ) ;
4207: LD_ADDR_EXP 79
4211: PUSH
4212: LD_STRING Heike
4214: PPUSH
4215: LD_INT 1
4217: PPUSH
4218: LD_INT 2
4220: PPUSH
4221: CALL 5856 0 3
4225: ST_TO_ADDR
// uc_side = 8 ;
4226: LD_ADDR_OWVAR 20
4230: PUSH
4231: LD_INT 8
4233: ST_TO_ADDR
// Kurt = PrepareUnitExt ( Kurt , false , 0 ) ;
4234: LD_ADDR_EXP 80
4238: PUSH
4239: LD_STRING Kurt
4241: PPUSH
4242: LD_INT 0
4244: PPUSH
4245: LD_INT 0
4247: PPUSH
4248: CALL 5856 0 3
4252: ST_TO_ADDR
// uc_side = 2 ;
4253: LD_ADDR_OWVAR 20
4257: PUSH
4258: LD_INT 2
4260: ST_TO_ADDR
// Dietrich = PrepareUnitExt ( Dietrich , false , 0 ) ;
4261: LD_ADDR_EXP 81
4265: PUSH
4266: LD_STRING Dietrich
4268: PPUSH
4269: LD_INT 0
4271: PPUSH
4272: LD_INT 0
4274: PPUSH
4275: CALL 5856 0 3
4279: ST_TO_ADDR
// end ;
4280: LD_VAR 0 1
4284: RET
// export function SpawnArAttackTeam ; var i , unit , veh , weapon , chassis ; begin
4285: LD_INT 0
4287: PPUSH
4288: PPUSH
4289: PPUSH
4290: PPUSH
4291: PPUSH
4292: PPUSH
// uc_side = 8 ;
4293: LD_ADDR_OWVAR 20
4297: PUSH
4298: LD_INT 8
4300: ST_TO_ADDR
// uc_nation = 2 ;
4301: LD_ADDR_OWVAR 21
4305: PUSH
4306: LD_INT 2
4308: ST_TO_ADDR
// for i := 1 to Rand ( enemyAttackUnitsData [ 1 ] [ 2 ] , enemyAttackUnitsData [ 1 ] [ 3 ] ) do
4309: LD_ADDR_VAR 0 2
4313: PUSH
4314: DOUBLE
4315: LD_INT 1
4317: DEC
4318: ST_TO_ADDR
4319: LD_EXP 53
4323: PUSH
4324: LD_INT 1
4326: ARRAY
4327: PUSH
4328: LD_INT 2
4330: ARRAY
4331: PPUSH
4332: LD_EXP 53
4336: PUSH
4337: LD_INT 1
4339: ARRAY
4340: PUSH
4341: LD_INT 3
4343: ARRAY
4344: PPUSH
4345: CALL_OW 12
4349: PUSH
4350: FOR_TO
4351: IFFALSE 4408
// begin PrepareSoldier ( false , enemySkillLevel ) ;
4353: LD_INT 0
4355: PPUSH
4356: LD_EXP 56
4360: PPUSH
4361: CALL_OW 381
// unit = CreateHuman ;
4365: LD_ADDR_VAR 0 3
4369: PUSH
4370: CALL_OW 44
4374: ST_TO_ADDR
// PlaceUnitArea ( unit , KurtUnitsSpawnArea , false ) ;
4375: LD_VAR 0 3
4379: PPUSH
4380: LD_INT 10
4382: PPUSH
4383: LD_INT 0
4385: PPUSH
4386: CALL_OW 49
// arAttackTeam = arAttackTeam ^ unit ;
4390: LD_ADDR_EXP 84
4394: PUSH
4395: LD_EXP 84
4399: PUSH
4400: LD_VAR 0 3
4404: ADD
4405: ST_TO_ADDR
// end ;
4406: GO 4350
4408: POP
4409: POP
// for i := 1 to Rand ( enemyAttackUnitsData [ 1 ] [ 4 ] , enemyAttackUnitsData [ 1 ] [ 5 ] ) do
4410: LD_ADDR_VAR 0 2
4414: PUSH
4415: DOUBLE
4416: LD_INT 1
4418: DEC
4419: ST_TO_ADDR
4420: LD_EXP 53
4424: PUSH
4425: LD_INT 1
4427: ARRAY
4428: PUSH
4429: LD_INT 4
4431: ARRAY
4432: PPUSH
4433: LD_EXP 53
4437: PUSH
4438: LD_INT 1
4440: ARRAY
4441: PUSH
4442: LD_INT 5
4444: ARRAY
4445: PPUSH
4446: CALL_OW 12
4450: PUSH
4451: FOR_TO
4452: IFFALSE 4512
// begin PrepareHuman ( false , class_mortar , enemySkillLevel ) ;
4454: LD_INT 0
4456: PPUSH
4457: LD_INT 8
4459: PPUSH
4460: LD_EXP 56
4464: PPUSH
4465: CALL_OW 380
// unit = CreateHuman ;
4469: LD_ADDR_VAR 0 3
4473: PUSH
4474: CALL_OW 44
4478: ST_TO_ADDR
// PlaceUnitArea ( unit , KurtUnitsSpawnArea , false ) ;
4479: LD_VAR 0 3
4483: PPUSH
4484: LD_INT 10
4486: PPUSH
4487: LD_INT 0
4489: PPUSH
4490: CALL_OW 49
// arAttackTeam = arAttackTeam ^ unit ;
4494: LD_ADDR_EXP 84
4498: PUSH
4499: LD_EXP 84
4503: PUSH
4504: LD_VAR 0 3
4508: ADD
4509: ST_TO_ADDR
// end ;
4510: GO 4451
4512: POP
4513: POP
// for i := 1 to Rand ( enemyAttackUnitsData [ 1 ] [ 6 ] , enemyAttackUnitsData [ 1 ] [ 7 ] ) do
4514: LD_ADDR_VAR 0 2
4518: PUSH
4519: DOUBLE
4520: LD_INT 1
4522: DEC
4523: ST_TO_ADDR
4524: LD_EXP 53
4528: PUSH
4529: LD_INT 1
4531: ARRAY
4532: PUSH
4533: LD_INT 6
4535: ARRAY
4536: PPUSH
4537: LD_EXP 53
4541: PUSH
4542: LD_INT 1
4544: ARRAY
4545: PUSH
4546: LD_INT 7
4548: ARRAY
4549: PPUSH
4550: CALL_OW 12
4554: PUSH
4555: FOR_TO
4556: IFFALSE 4750
// begin weapon = [ ar_gun , ar_flame_thrower , ar_rocket_launcher , ar_light_gun , ar_gatling_gun ] [ Rand ( 1 , 5 ) ] ;
4558: LD_ADDR_VAR 0 5
4562: PUSH
4563: LD_INT 27
4565: PUSH
4566: LD_INT 26
4568: PUSH
4569: LD_INT 28
4571: PUSH
4572: LD_INT 23
4574: PUSH
4575: LD_INT 25
4577: PUSH
4578: EMPTY
4579: LIST
4580: LIST
4581: LIST
4582: LIST
4583: LIST
4584: PUSH
4585: LD_INT 1
4587: PPUSH
4588: LD_INT 5
4590: PPUSH
4591: CALL_OW 12
4595: ARRAY
4596: ST_TO_ADDR
// chassis = [ ar_medium_trike , ar_half_tracked ] [ Rand ( 1 , 2 ) ] ;
4597: LD_ADDR_VAR 0 6
4601: PUSH
4602: LD_INT 13
4604: PUSH
4605: LD_INT 14
4607: PUSH
4608: EMPTY
4609: LIST
4610: LIST
4611: PUSH
4612: LD_INT 1
4614: PPUSH
4615: LD_INT 2
4617: PPUSH
4618: CALL_OW 12
4622: ARRAY
4623: ST_TO_ADDR
// PrepareVehicle ( chassis , engine_combustion , control_manual , weapon , Rand ( 70 , 90 ) ) ;
4624: LD_VAR 0 6
4628: PPUSH
4629: LD_INT 1
4631: PPUSH
4632: LD_INT 1
4634: PPUSH
4635: LD_VAR 0 5
4639: PPUSH
4640: LD_INT 70
4642: PPUSH
4643: LD_INT 90
4645: PPUSH
4646: CALL_OW 12
4650: PPUSH
4651: CALL 23974 0 5
// veh = CreateVehicle ;
4655: LD_ADDR_VAR 0 4
4659: PUSH
4660: CALL_OW 45
4664: ST_TO_ADDR
// PlaceUnitArea ( veh , KurtUnitsSpawnArea , false ) ;
4665: LD_VAR 0 4
4669: PPUSH
4670: LD_INT 10
4672: PPUSH
4673: LD_INT 0
4675: PPUSH
4676: CALL_OW 49
// arAttackTeam = arAttackTeam ^ veh ;
4680: LD_ADDR_EXP 84
4684: PUSH
4685: LD_EXP 84
4689: PUSH
4690: LD_VAR 0 4
4694: ADD
4695: ST_TO_ADDR
// PrepareMechanic ( false , enemySkillLevel ) ;
4696: LD_INT 0
4698: PPUSH
4699: LD_EXP 56
4703: PPUSH
4704: CALL_OW 383
// unit = CreateHuman ;
4708: LD_ADDR_VAR 0 3
4712: PUSH
4713: CALL_OW 44
4717: ST_TO_ADDR
// PlaceHumanInUnit ( unit , veh ) ;
4718: LD_VAR 0 3
4722: PPUSH
4723: LD_VAR 0 4
4727: PPUSH
4728: CALL_OW 52
// arAttackTeam = arAttackTeam ^ unit ;
4732: LD_ADDR_EXP 84
4736: PUSH
4737: LD_EXP 84
4741: PUSH
4742: LD_VAR 0 3
4746: ADD
4747: ST_TO_ADDR
// end ;
4748: GO 4555
4750: POP
4751: POP
// end ; end_of_file
4752: LD_VAR 0 1
4756: RET
// export function Nef_PrepareNature ; var i , un ; begin
4757: LD_INT 0
4759: PPUSH
4760: PPUSH
4761: PPUSH
// for i := 1 to animalsAmount [ 1 ] do
4762: LD_ADDR_VAR 0 2
4766: PUSH
4767: DOUBLE
4768: LD_INT 1
4770: DEC
4771: ST_TO_ADDR
4772: LD_EXP 41
4776: PUSH
4777: LD_INT 1
4779: ARRAY
4780: PUSH
4781: FOR_TO
4782: IFFALSE 4892
// begin uc_side = 0 ;
4784: LD_ADDR_OWVAR 20
4788: PUSH
4789: LD_INT 0
4791: ST_TO_ADDR
// uc_nation = nation_nature ;
4792: LD_ADDR_OWVAR 21
4796: PUSH
4797: LD_INT 0
4799: ST_TO_ADDR
// hc_class = class_apeman ;
4800: LD_ADDR_OWVAR 28
4804: PUSH
4805: LD_INT 12
4807: ST_TO_ADDR
// hc_skills = [ animalsStats [ 1 ] , animalsStats [ 2 ] , animalsStats [ 3 ] , animalsStats [ 4 ] ] ;
4808: LD_ADDR_OWVAR 31
4812: PUSH
4813: LD_EXP 42
4817: PUSH
4818: LD_INT 1
4820: ARRAY
4821: PUSH
4822: LD_EXP 42
4826: PUSH
4827: LD_INT 2
4829: ARRAY
4830: PUSH
4831: LD_EXP 42
4835: PUSH
4836: LD_INT 3
4838: ARRAY
4839: PUSH
4840: LD_EXP 42
4844: PUSH
4845: LD_INT 4
4847: ARRAY
4848: PUSH
4849: EMPTY
4850: LIST
4851: LIST
4852: LIST
4853: LIST
4854: ST_TO_ADDR
// hc_agressivity = animalsAgression ;
4855: LD_ADDR_OWVAR 35
4859: PUSH
4860: LD_EXP 43
4864: ST_TO_ADDR
// un = CreateHuman ;
4865: LD_ADDR_VAR 0 3
4869: PUSH
4870: CALL_OW 44
4874: ST_TO_ADDR
// PlaceUnitArea ( un , NatureArea , false ) ;
4875: LD_VAR 0 3
4879: PPUSH
4880: LD_INT 5
4882: PPUSH
4883: LD_INT 0
4885: PPUSH
4886: CALL_OW 49
// end ;
4890: GO 4781
4892: POP
4893: POP
// for i := 1 to animalsAmount [ 2 ] do
4894: LD_ADDR_VAR 0 2
4898: PUSH
4899: DOUBLE
4900: LD_INT 1
4902: DEC
4903: ST_TO_ADDR
4904: LD_EXP 41
4908: PUSH
4909: LD_INT 2
4911: ARRAY
4912: PUSH
4913: FOR_TO
4914: IFFALSE 5024
// begin uc_side = 0 ;
4916: LD_ADDR_OWVAR 20
4920: PUSH
4921: LD_INT 0
4923: ST_TO_ADDR
// uc_nation = nation_nature ;
4924: LD_ADDR_OWVAR 21
4928: PUSH
4929: LD_INT 0
4931: ST_TO_ADDR
// hc_class = class_phororhacos ;
4932: LD_ADDR_OWVAR 28
4936: PUSH
4937: LD_INT 18
4939: ST_TO_ADDR
// hc_skills = [ animalsStats [ 1 ] , animalsStats [ 2 ] , animalsStats [ 3 ] , animalsStats [ 4 ] ] ;
4940: LD_ADDR_OWVAR 31
4944: PUSH
4945: LD_EXP 42
4949: PUSH
4950: LD_INT 1
4952: ARRAY
4953: PUSH
4954: LD_EXP 42
4958: PUSH
4959: LD_INT 2
4961: ARRAY
4962: PUSH
4963: LD_EXP 42
4967: PUSH
4968: LD_INT 3
4970: ARRAY
4971: PUSH
4972: LD_EXP 42
4976: PUSH
4977: LD_INT 4
4979: ARRAY
4980: PUSH
4981: EMPTY
4982: LIST
4983: LIST
4984: LIST
4985: LIST
4986: ST_TO_ADDR
// hc_agressivity = animalsAgression ;
4987: LD_ADDR_OWVAR 35
4991: PUSH
4992: LD_EXP 43
4996: ST_TO_ADDR
// un = CreateHuman ;
4997: LD_ADDR_VAR 0 3
5001: PUSH
5002: CALL_OW 44
5006: ST_TO_ADDR
// PlaceUnitArea ( un , NatureArea , false ) ;
5007: LD_VAR 0 3
5011: PPUSH
5012: LD_INT 5
5014: PPUSH
5015: LD_INT 0
5017: PPUSH
5018: CALL_OW 49
// end ;
5022: GO 4913
5024: POP
5025: POP
// for i := 1 to animalsAmount [ 3 ] do
5026: LD_ADDR_VAR 0 2
5030: PUSH
5031: DOUBLE
5032: LD_INT 1
5034: DEC
5035: ST_TO_ADDR
5036: LD_EXP 41
5040: PUSH
5041: LD_INT 3
5043: ARRAY
5044: PUSH
5045: FOR_TO
5046: IFFALSE 5156
// begin uc_side = 0 ;
5048: LD_ADDR_OWVAR 20
5052: PUSH
5053: LD_INT 0
5055: ST_TO_ADDR
// uc_nation = nation_nature ;
5056: LD_ADDR_OWVAR 21
5060: PUSH
5061: LD_INT 0
5063: ST_TO_ADDR
// hc_class = class_tiger ;
5064: LD_ADDR_OWVAR 28
5068: PUSH
5069: LD_INT 14
5071: ST_TO_ADDR
// hc_skills = [ animalsStats [ 1 ] , animalsStats [ 2 ] , animalsStats [ 3 ] , animalsStats [ 4 ] ] ;
5072: LD_ADDR_OWVAR 31
5076: PUSH
5077: LD_EXP 42
5081: PUSH
5082: LD_INT 1
5084: ARRAY
5085: PUSH
5086: LD_EXP 42
5090: PUSH
5091: LD_INT 2
5093: ARRAY
5094: PUSH
5095: LD_EXP 42
5099: PUSH
5100: LD_INT 3
5102: ARRAY
5103: PUSH
5104: LD_EXP 42
5108: PUSH
5109: LD_INT 4
5111: ARRAY
5112: PUSH
5113: EMPTY
5114: LIST
5115: LIST
5116: LIST
5117: LIST
5118: ST_TO_ADDR
// hc_agressivity = animalsAgression ;
5119: LD_ADDR_OWVAR 35
5123: PUSH
5124: LD_EXP 43
5128: ST_TO_ADDR
// un = CreateHuman ;
5129: LD_ADDR_VAR 0 3
5133: PUSH
5134: CALL_OW 44
5138: ST_TO_ADDR
// PlaceUnitArea ( un , NatureArea , false ) ;
5139: LD_VAR 0 3
5143: PPUSH
5144: LD_INT 5
5146: PPUSH
5147: LD_INT 0
5149: PPUSH
5150: CALL_OW 49
// end ;
5154: GO 5045
5156: POP
5157: POP
// for i := 1 to animalsAmount [ 4 ] do
5158: LD_ADDR_VAR 0 2
5162: PUSH
5163: DOUBLE
5164: LD_INT 1
5166: DEC
5167: ST_TO_ADDR
5168: LD_EXP 41
5172: PUSH
5173: LD_INT 4
5175: ARRAY
5176: PUSH
5177: FOR_TO
5178: IFFALSE 5288
// begin uc_side = 0 ;
5180: LD_ADDR_OWVAR 20
5184: PUSH
5185: LD_INT 0
5187: ST_TO_ADDR
// uc_nation = nation_nature ;
5188: LD_ADDR_OWVAR 21
5192: PUSH
5193: LD_INT 0
5195: ST_TO_ADDR
// hc_class = 21 ;
5196: LD_ADDR_OWVAR 28
5200: PUSH
5201: LD_INT 21
5203: ST_TO_ADDR
// hc_skills = [ animalsStats [ 1 ] , animalsStats [ 2 ] , animalsStats [ 3 ] , animalsStats [ 4 ] ] ;
5204: LD_ADDR_OWVAR 31
5208: PUSH
5209: LD_EXP 42
5213: PUSH
5214: LD_INT 1
5216: ARRAY
5217: PUSH
5218: LD_EXP 42
5222: PUSH
5223: LD_INT 2
5225: ARRAY
5226: PUSH
5227: LD_EXP 42
5231: PUSH
5232: LD_INT 3
5234: ARRAY
5235: PUSH
5236: LD_EXP 42
5240: PUSH
5241: LD_INT 4
5243: ARRAY
5244: PUSH
5245: EMPTY
5246: LIST
5247: LIST
5248: LIST
5249: LIST
5250: ST_TO_ADDR
// hc_agressivity = animalsAgression ;
5251: LD_ADDR_OWVAR 35
5255: PUSH
5256: LD_EXP 43
5260: ST_TO_ADDR
// un = CreateHuman ;
5261: LD_ADDR_VAR 0 3
5265: PUSH
5266: CALL_OW 44
5270: ST_TO_ADDR
// PlaceUnitArea ( un , NatureArea , false ) ;
5271: LD_VAR 0 3
5275: PPUSH
5276: LD_INT 5
5278: PPUSH
5279: LD_INT 0
5281: PPUSH
5282: CALL_OW 49
// end ;
5286: GO 5177
5288: POP
5289: POP
// for i := 1 to animalsAmount [ 5 ] do
5290: LD_ADDR_VAR 0 2
5294: PUSH
5295: DOUBLE
5296: LD_INT 1
5298: DEC
5299: ST_TO_ADDR
5300: LD_EXP 41
5304: PUSH
5305: LD_INT 5
5307: ARRAY
5308: PUSH
5309: FOR_TO
5310: IFFALSE 5371
// begin uc_side = 0 ;
5312: LD_ADDR_OWVAR 20
5316: PUSH
5317: LD_INT 0
5319: ST_TO_ADDR
// uc_nation = nation_nature ;
5320: LD_ADDR_OWVAR 21
5324: PUSH
5325: LD_INT 0
5327: ST_TO_ADDR
// vc_chassis := 31 ;
5328: LD_ADDR_OWVAR 37
5332: PUSH
5333: LD_INT 31
5335: ST_TO_ADDR
// vc_control := control_rider ;
5336: LD_ADDR_OWVAR 38
5340: PUSH
5341: LD_INT 4
5343: ST_TO_ADDR
// un := CreateVehicle ;
5344: LD_ADDR_VAR 0 3
5348: PUSH
5349: CALL_OW 45
5353: ST_TO_ADDR
// PlaceUnitArea ( un , NatureArea , false ) ;
5354: LD_VAR 0 3
5358: PPUSH
5359: LD_INT 5
5361: PPUSH
5362: LD_INT 0
5364: PPUSH
5365: CALL_OW 49
// end ;
5369: GO 5309
5371: POP
5372: POP
// end ;
5373: LD_VAR 0 1
5377: RET
// export function SpawnTrees ; begin
5378: LD_INT 0
5380: PPUSH
// PlaceTreesToArea ( TreeArea , [ 2 , 10 , 11 , 27 , 35 ] , 40 , 10 , 4 ) ;
5381: LD_INT 1
5383: PPUSH
5384: LD_INT 2
5386: PUSH
5387: LD_INT 10
5389: PUSH
5390: LD_INT 11
5392: PUSH
5393: LD_INT 27
5395: PUSH
5396: LD_INT 35
5398: PUSH
5399: EMPTY
5400: LIST
5401: LIST
5402: LIST
5403: LIST
5404: LIST
5405: PPUSH
5406: LD_INT 40
5408: PPUSH
5409: LD_INT 10
5411: PPUSH
5412: LD_INT 4
5414: PPUSH
5415: CALL_OW 352
// PlaceTreesToArea ( TreeArea , [ 9 , 10 , 27 , 35 , 48 ] , 30 , 10 , 4 ) ;
5419: LD_INT 1
5421: PPUSH
5422: LD_INT 9
5424: PUSH
5425: LD_INT 10
5427: PUSH
5428: LD_INT 27
5430: PUSH
5431: LD_INT 35
5433: PUSH
5434: LD_INT 48
5436: PUSH
5437: EMPTY
5438: LIST
5439: LIST
5440: LIST
5441: LIST
5442: LIST
5443: PPUSH
5444: LD_INT 30
5446: PPUSH
5447: LD_INT 10
5449: PPUSH
5450: LD_INT 4
5452: PPUSH
5453: CALL_OW 352
// PlaceTreesToArea ( TreeArea , [ 2 , 9 , 10 , 11 , 27 ] , 60 , 10 , 4 ) ;
5457: LD_INT 1
5459: PPUSH
5460: LD_INT 2
5462: PUSH
5463: LD_INT 9
5465: PUSH
5466: LD_INT 10
5468: PUSH
5469: LD_INT 11
5471: PUSH
5472: LD_INT 27
5474: PUSH
5475: EMPTY
5476: LIST
5477: LIST
5478: LIST
5479: LIST
5480: LIST
5481: PPUSH
5482: LD_INT 60
5484: PPUSH
5485: LD_INT 10
5487: PPUSH
5488: LD_INT 4
5490: PPUSH
5491: CALL_OW 352
// PlaceTreesToArea ( TreeArea , [ 9 , 10 , 27 , 35 , 48 ] , 90 , 10 , 4 ) ;
5495: LD_INT 1
5497: PPUSH
5498: LD_INT 9
5500: PUSH
5501: LD_INT 10
5503: PUSH
5504: LD_INT 27
5506: PUSH
5507: LD_INT 35
5509: PUSH
5510: LD_INT 48
5512: PUSH
5513: EMPTY
5514: LIST
5515: LIST
5516: LIST
5517: LIST
5518: LIST
5519: PPUSH
5520: LD_INT 90
5522: PPUSH
5523: LD_INT 10
5525: PPUSH
5526: LD_INT 4
5528: PPUSH
5529: CALL_OW 352
// PlaceTreesToArea ( TreeArea , [ 2 , 9 , 10 , 11 , 48 ] , 120 , 10 , 4 ) ;
5533: LD_INT 1
5535: PPUSH
5536: LD_INT 2
5538: PUSH
5539: LD_INT 9
5541: PUSH
5542: LD_INT 10
5544: PUSH
5545: LD_INT 11
5547: PUSH
5548: LD_INT 48
5550: PUSH
5551: EMPTY
5552: LIST
5553: LIST
5554: LIST
5555: LIST
5556: LIST
5557: PPUSH
5558: LD_INT 120
5560: PPUSH
5561: LD_INT 10
5563: PPUSH
5564: LD_INT 4
5566: PPUSH
5567: CALL_OW 352
// PlaceTreesToArea ( TreeArea , [ 2 , 11 , 27 , 35 , 48 ] , 45 , 10 , 4 ) ;
5571: LD_INT 1
5573: PPUSH
5574: LD_INT 2
5576: PUSH
5577: LD_INT 11
5579: PUSH
5580: LD_INT 27
5582: PUSH
5583: LD_INT 35
5585: PUSH
5586: LD_INT 48
5588: PUSH
5589: EMPTY
5590: LIST
5591: LIST
5592: LIST
5593: LIST
5594: LIST
5595: PPUSH
5596: LD_INT 45
5598: PPUSH
5599: LD_INT 10
5601: PPUSH
5602: LD_INT 4
5604: PPUSH
5605: CALL_OW 352
// end ;
5609: LD_VAR 0 1
5613: RET
// every 0 0$1 do var i , un ;
5614: GO 5616
5616: DISABLE
5617: LD_INT 0
5619: PPUSH
5620: PPUSH
// begin if ( GetTech ( tech_apelang , 3 ) = state_enabled or GetTech ( tech_apepsych , 3 ) = state_enabled or GetTech ( tech_apeagres , 3 ) = state_enabled ) and not FilterAllUnits ( [ [ f_or , [ f_class , class_apeman ] , [ f_class , class_apeman_engineer ] , [ f_class , class_apeman_soldier ] ] ] ) then
5621: LD_INT 1
5623: PPUSH
5624: LD_INT 3
5626: PPUSH
5627: CALL_OW 321
5631: PUSH
5632: LD_INT 1
5634: EQUAL
5635: PUSH
5636: LD_INT 2
5638: PPUSH
5639: LD_INT 3
5641: PPUSH
5642: CALL_OW 321
5646: PUSH
5647: LD_INT 1
5649: EQUAL
5650: OR
5651: PUSH
5652: LD_INT 11
5654: PPUSH
5655: LD_INT 3
5657: PPUSH
5658: CALL_OW 321
5662: PUSH
5663: LD_INT 1
5665: EQUAL
5666: OR
5667: PUSH
5668: LD_INT 2
5670: PUSH
5671: LD_INT 25
5673: PUSH
5674: LD_INT 12
5676: PUSH
5677: EMPTY
5678: LIST
5679: LIST
5680: PUSH
5681: LD_INT 25
5683: PUSH
5684: LD_INT 16
5686: PUSH
5687: EMPTY
5688: LIST
5689: LIST
5690: PUSH
5691: LD_INT 25
5693: PUSH
5694: LD_INT 15
5696: PUSH
5697: EMPTY
5698: LIST
5699: LIST
5700: PUSH
5701: EMPTY
5702: LIST
5703: LIST
5704: LIST
5705: LIST
5706: PUSH
5707: EMPTY
5708: LIST
5709: PPUSH
5710: CALL_OW 69
5714: NOT
5715: AND
5716: IFFALSE 5852
// begin for i := 1 to Rand ( 2 , 4 ) do
5718: LD_ADDR_VAR 0 1
5722: PUSH
5723: DOUBLE
5724: LD_INT 1
5726: DEC
5727: ST_TO_ADDR
5728: LD_INT 2
5730: PPUSH
5731: LD_INT 4
5733: PPUSH
5734: CALL_OW 12
5738: PUSH
5739: FOR_TO
5740: IFFALSE 5850
// begin uc_side = 0 ;
5742: LD_ADDR_OWVAR 20
5746: PUSH
5747: LD_INT 0
5749: ST_TO_ADDR
// uc_nation = nation_nature ;
5750: LD_ADDR_OWVAR 21
5754: PUSH
5755: LD_INT 0
5757: ST_TO_ADDR
// hc_class = class_apeman ;
5758: LD_ADDR_OWVAR 28
5762: PUSH
5763: LD_INT 12
5765: ST_TO_ADDR
// hc_skills = [ animalsStats [ 1 ] , animalsStats [ 2 ] , animalsStats [ 3 ] , animalsStats [ 4 ] ] ;
5766: LD_ADDR_OWVAR 31
5770: PUSH
5771: LD_EXP 42
5775: PUSH
5776: LD_INT 1
5778: ARRAY
5779: PUSH
5780: LD_EXP 42
5784: PUSH
5785: LD_INT 2
5787: ARRAY
5788: PUSH
5789: LD_EXP 42
5793: PUSH
5794: LD_INT 3
5796: ARRAY
5797: PUSH
5798: LD_EXP 42
5802: PUSH
5803: LD_INT 4
5805: ARRAY
5806: PUSH
5807: EMPTY
5808: LIST
5809: LIST
5810: LIST
5811: LIST
5812: ST_TO_ADDR
// hc_agressivity = animalsAgression ;
5813: LD_ADDR_OWVAR 35
5817: PUSH
5818: LD_EXP 43
5822: ST_TO_ADDR
// un = CreateHuman ;
5823: LD_ADDR_VAR 0 2
5827: PUSH
5828: CALL_OW 44
5832: ST_TO_ADDR
// PlaceUnitArea ( un , NatureArea , false ) ;
5833: LD_VAR 0 2
5837: PPUSH
5838: LD_INT 5
5840: PPUSH
5841: LD_INT 0
5843: PPUSH
5844: CALL_OW 49
// end ;
5848: GO 5739
5850: POP
5851: POP
// end ; enable ;
5852: ENABLE
// end ; end_of_file
5853: PPOPN 2
5855: END
// export function PrepareUnitExt ( ident , exist_mode , class ) ; var unit ; begin
5856: LD_INT 0
5858: PPUSH
5859: PPUSH
// if debugMode then
5860: LD_EXP 46
5864: IFFALSE 5881
// unit := NewCharacter ( ident ) ;
5866: LD_ADDR_VAR 0 5
5870: PUSH
5871: LD_VAR 0 1
5875: PPUSH
5876: CALL_OW 25
5880: ST_TO_ADDR
// if exist_mode and not debugMode then
5881: LD_VAR 0 2
5885: PUSH
5886: LD_EXP 46
5890: NOT
5891: AND
5892: IFFALSE 5917
// unit := CreateCharacter ( previousMissionPrefix & ident ) else
5894: LD_ADDR_VAR 0 5
5898: PUSH
5899: LD_EXP 45
5903: PUSH
5904: LD_VAR 0 1
5908: STR
5909: PPUSH
5910: CALL_OW 34
5914: ST_TO_ADDR
5915: GO 5939
// if not debugMode then
5917: LD_EXP 46
5921: NOT
5922: IFFALSE 5939
// unit := NewCharacter ( ident ) ;
5924: LD_ADDR_VAR 0 5
5928: PUSH
5929: LD_VAR 0 1
5933: PPUSH
5934: CALL_OW 25
5938: ST_TO_ADDR
// if class then
5939: LD_VAR 0 3
5943: IFFALSE 5959
// SetClass ( unit , class ) ;
5945: LD_VAR 0 5
5949: PPUSH
5950: LD_VAR 0 3
5954: PPUSH
5955: CALL_OW 336
// result := unit ;
5959: LD_ADDR_VAR 0 4
5963: PUSH
5964: LD_VAR 0 5
5968: ST_TO_ADDR
// end ;
5969: LD_VAR 0 4
5973: RET
// export function ExtSaveCharacter ( character , characterStringID , side ) ; begin
5974: LD_INT 0
5976: PPUSH
// if GetSide ( character ) = side and not IsDead ( character ) then
5977: LD_VAR 0 1
5981: PPUSH
5982: CALL_OW 255
5986: PUSH
5987: LD_VAR 0 3
5991: EQUAL
5992: PUSH
5993: LD_VAR 0 1
5997: PPUSH
5998: CALL_OW 301
6002: NOT
6003: AND
6004: IFFALSE 6026
// SaveCharacters ( character , missionPrefix & characterStringID ) ;
6006: LD_VAR 0 1
6010: PPUSH
6011: LD_EXP 44
6015: PUSH
6016: LD_VAR 0 2
6020: STR
6021: PPUSH
6022: CALL_OW 38
// end ;
6026: LD_VAR 0 4
6030: RET
// export function ExtSaveCharacters ( characters , charactersStringID , side ) ; var unit , resultCharactersToSave ; begin
6031: LD_INT 0
6033: PPUSH
6034: PPUSH
6035: PPUSH
// resultCharactersToSave = [ ] ;
6036: LD_ADDR_VAR 0 6
6040: PUSH
6041: EMPTY
6042: ST_TO_ADDR
// for unit in characters do
6043: LD_ADDR_VAR 0 5
6047: PUSH
6048: LD_VAR 0 1
6052: PUSH
6053: FOR_IN
6054: IFFALSE 6103
// if GetSide ( unit ) = side and not IsDead ( unit ) then
6056: LD_VAR 0 5
6060: PPUSH
6061: CALL_OW 255
6065: PUSH
6066: LD_VAR 0 3
6070: EQUAL
6071: PUSH
6072: LD_VAR 0 5
6076: PPUSH
6077: CALL_OW 301
6081: NOT
6082: AND
6083: IFFALSE 6101
// resultCharactersToSave = resultCharactersToSave ^ unit ;
6085: LD_ADDR_VAR 0 6
6089: PUSH
6090: LD_VAR 0 6
6094: PUSH
6095: LD_VAR 0 5
6099: ADD
6100: ST_TO_ADDR
6101: GO 6053
6103: POP
6104: POP
// SaveCharacters ( resultCharactersToSave , missionPrefix & charactersStringID ) ;
6105: LD_VAR 0 6
6109: PPUSH
6110: LD_EXP 44
6114: PUSH
6115: LD_VAR 0 2
6119: STR
6120: PPUSH
6121: CALL_OW 38
// end ;
6125: LD_VAR 0 4
6129: RET
// export function PlaceUnitsArea ( units , area , spawnMode ) ; var unit ; begin
6130: LD_INT 0
6132: PPUSH
6133: PPUSH
// for unit in units do
6134: LD_ADDR_VAR 0 5
6138: PUSH
6139: LD_VAR 0 1
6143: PUSH
6144: FOR_IN
6145: IFFALSE 6168
// PlaceUnitArea ( unit , area , spawnMode ) ;
6147: LD_VAR 0 5
6151: PPUSH
6152: LD_VAR 0 2
6156: PPUSH
6157: LD_VAR 0 3
6161: PPUSH
6162: CALL_OW 49
6166: GO 6144
6168: POP
6169: POP
// end ;
6170: LD_VAR 0 4
6174: RET
// export function DialogRandom ( characters , dialogMID , dialogFID , radio , canTalkHero ) ; var i , speaker , units ; begin
6175: LD_INT 0
6177: PPUSH
6178: PPUSH
6179: PPUSH
6180: PPUSH
// units = characters ;
6181: LD_ADDR_VAR 0 9
6185: PUSH
6186: LD_VAR 0 1
6190: ST_TO_ADDR
// units := units diff [ Burlak , Karamazov , Petrovova , Gleb , Petrosyan , Titov , Dolgov , Lipshchin , Kirilenkova ] ;
6191: LD_ADDR_VAR 0 9
6195: PUSH
6196: LD_VAR 0 9
6200: PUSH
6201: LD_EXP 57
6205: PUSH
6206: LD_EXP 58
6210: PUSH
6211: LD_EXP 59
6215: PUSH
6216: LD_EXP 60
6220: PUSH
6221: LD_EXP 61
6225: PUSH
6226: LD_EXP 62
6230: PUSH
6231: LD_EXP 63
6235: PUSH
6236: LD_EXP 64
6240: PUSH
6241: LD_EXP 65
6245: PUSH
6246: EMPTY
6247: LIST
6248: LIST
6249: LIST
6250: LIST
6251: LIST
6252: LIST
6253: LIST
6254: LIST
6255: LIST
6256: DIFF
6257: ST_TO_ADDR
// if not units and not canTalkHero then
6258: LD_VAR 0 9
6262: NOT
6263: PUSH
6264: LD_VAR 0 5
6268: NOT
6269: AND
6270: IFFALSE 6274
// exit ;
6272: GO 6447
// if not units then
6274: LD_VAR 0 9
6278: NOT
6279: IFFALSE 6300
// units = characters diff [ Burlak ] ;
6281: LD_ADDR_VAR 0 9
6285: PUSH
6286: LD_VAR 0 1
6290: PUSH
6291: LD_EXP 57
6295: PUSH
6296: EMPTY
6297: LIST
6298: DIFF
6299: ST_TO_ADDR
// if not units and canTalkHero then
6300: LD_VAR 0 9
6304: NOT
6305: PUSH
6306: LD_VAR 0 5
6310: AND
6311: IFFALSE 6315
// exit ;
6313: GO 6447
// speaker := units [ rand ( 1 , units ) ] ;
6315: LD_ADDR_VAR 0 8
6319: PUSH
6320: LD_VAR 0 9
6324: PUSH
6325: LD_INT 1
6327: PPUSH
6328: LD_VAR 0 9
6332: PPUSH
6333: CALL_OW 12
6337: ARRAY
6338: ST_TO_ADDR
// if radio then
6339: LD_VAR 0 4
6343: IFFALSE 6392
// begin if GetSex ( speaker ) = sex_male then
6345: LD_VAR 0 8
6349: PPUSH
6350: CALL_OW 258
6354: PUSH
6355: LD_INT 1
6357: EQUAL
6358: IFFALSE 6376
// SayRadio ( speaker , dialogMID ) else
6360: LD_VAR 0 8
6364: PPUSH
6365: LD_VAR 0 2
6369: PPUSH
6370: CALL_OW 94
6374: GO 6390
// SayRadio ( speaker , dialogFID ) ;
6376: LD_VAR 0 8
6380: PPUSH
6381: LD_VAR 0 3
6385: PPUSH
6386: CALL_OW 94
// end else
6390: GO 6437
// begin if GetSex ( speaker ) = sex_male then
6392: LD_VAR 0 8
6396: PPUSH
6397: CALL_OW 258
6401: PUSH
6402: LD_INT 1
6404: EQUAL
6405: IFFALSE 6423
// Say ( speaker , dialogMID ) else
6407: LD_VAR 0 8
6411: PPUSH
6412: LD_VAR 0 2
6416: PPUSH
6417: CALL_OW 88
6421: GO 6437
// Say ( speaker , dialogFID ) ;
6423: LD_VAR 0 8
6427: PPUSH
6428: LD_VAR 0 3
6432: PPUSH
6433: CALL_OW 88
// end ; result := speaker ;
6437: LD_ADDR_VAR 0 6
6441: PUSH
6442: LD_VAR 0 8
6446: ST_TO_ADDR
// end ;
6447: LD_VAR 0 6
6451: RET
// export function RemoveUnits ( units ) ; var unit ; begin
6452: LD_INT 0
6454: PPUSH
6455: PPUSH
// if not units then
6456: LD_VAR 0 1
6460: NOT
6461: IFFALSE 6465
// exit ;
6463: GO 6611
// if Heike in units then
6465: LD_EXP 79
6469: PUSH
6470: LD_VAR 0 1
6474: IN
6475: IFFALSE 6531
// begin if GetAttitude ( 3 , 8 ) = att_neutral then
6477: LD_INT 3
6479: PPUSH
6480: LD_INT 8
6482: PPUSH
6483: CALL_OW 81
6487: PUSH
6488: LD_INT 0
6490: EQUAL
6491: IFFALSE 6503
// HeikeStatus = 1 else
6493: LD_ADDR_EXP 3
6497: PUSH
6498: LD_INT 1
6500: ST_TO_ADDR
6501: GO 6511
// HeikeStatus = 2 ;
6503: LD_ADDR_EXP 3
6507: PUSH
6508: LD_INT 2
6510: ST_TO_ADDR
// forceStopKurtAttack = true ;
6511: LD_ADDR_EXP 27
6515: PUSH
6516: LD_INT 1
6518: ST_TO_ADDR
// SetClass ( Heike , 1 ) ;
6519: LD_EXP 79
6523: PPUSH
6524: LD_INT 1
6526: PPUSH
6527: CALL_OW 336
// end ; if Kurt in units then
6531: LD_EXP 80
6535: PUSH
6536: LD_VAR 0 1
6540: IN
6541: IFFALSE 6585
// begin if GetAttitude ( 3 , 8 ) = att_neutral then
6543: LD_INT 3
6545: PPUSH
6546: LD_INT 8
6548: PPUSH
6549: CALL_OW 81
6553: PUSH
6554: LD_INT 0
6556: EQUAL
6557: IFFALSE 6569
// KurtStatus = 1 else
6559: LD_ADDR_EXP 22
6563: PUSH
6564: LD_INT 1
6566: ST_TO_ADDR
6567: GO 6585
// begin KurtStatus = 2 ;
6569: LD_ADDR_EXP 22
6573: PUSH
6574: LD_INT 2
6576: ST_TO_ADDR
// KurtAttack = 1 ;
6577: LD_ADDR_EXP 25
6581: PUSH
6582: LD_INT 1
6584: ST_TO_ADDR
// end ; end ; for unit in units do
6585: LD_ADDR_VAR 0 3
6589: PUSH
6590: LD_VAR 0 1
6594: PUSH
6595: FOR_IN
6596: IFFALSE 6609
// RemoveUnit ( unit ) ;
6598: LD_VAR 0 3
6602: PPUSH
6603: CALL_OW 64
6607: GO 6595
6609: POP
6610: POP
// end ;
6611: LD_VAR 0 2
6615: RET
// export function GetAmountWeaponsDataBuildOnTurret ( isBuild ) ; var i , amount ; begin
6616: LD_INT 0
6618: PPUSH
6619: PPUSH
6620: PPUSH
// amount = 0 ;
6621: LD_ADDR_VAR 0 4
6625: PUSH
6626: LD_INT 0
6628: ST_TO_ADDR
// for i := 1 to weaponsData do
6629: LD_ADDR_VAR 0 3
6633: PUSH
6634: DOUBLE
6635: LD_INT 1
6637: DEC
6638: ST_TO_ADDR
6639: LD_EXP 12
6643: PUSH
6644: FOR_TO
6645: IFFALSE 6685
// if weaponsData [ i ] [ 2 ] = isBuild then
6647: LD_EXP 12
6651: PUSH
6652: LD_VAR 0 3
6656: ARRAY
6657: PUSH
6658: LD_INT 2
6660: ARRAY
6661: PUSH
6662: LD_VAR 0 1
6666: EQUAL
6667: IFFALSE 6683
// amount = amount + 1 ;
6669: LD_ADDR_VAR 0 4
6673: PUSH
6674: LD_VAR 0 4
6678: PUSH
6679: LD_INT 1
6681: PLUS
6682: ST_TO_ADDR
6683: GO 6644
6685: POP
6686: POP
// if isBuild then
6687: LD_VAR 0 1
6691: IFFALSE 6711
// if amount >= 3 then
6693: LD_VAR 0 4
6697: PUSH
6698: LD_INT 3
6700: GREATEREQUAL
6701: IFFALSE 6711
// amount = 3 ;
6703: LD_ADDR_VAR 0 4
6707: PUSH
6708: LD_INT 3
6710: ST_TO_ADDR
// result = amount ;
6711: LD_ADDR_VAR 0 2
6715: PUSH
6716: LD_VAR 0 4
6720: ST_TO_ADDR
// end ;
6721: LD_VAR 0 2
6725: RET
// export function GetAmountWeaponsDataBuildOnVehicle ( isBuild ) ; var i , amount ; begin
6726: LD_INT 0
6728: PPUSH
6729: PPUSH
6730: PPUSH
// amount = 0 ;
6731: LD_ADDR_VAR 0 4
6735: PUSH
6736: LD_INT 0
6738: ST_TO_ADDR
// for i := 1 to weaponsData do
6739: LD_ADDR_VAR 0 3
6743: PUSH
6744: DOUBLE
6745: LD_INT 1
6747: DEC
6748: ST_TO_ADDR
6749: LD_EXP 12
6753: PUSH
6754: FOR_TO
6755: IFFALSE 6795
// if weaponsData [ i ] [ 3 ] = isBuild then
6757: LD_EXP 12
6761: PUSH
6762: LD_VAR 0 3
6766: ARRAY
6767: PUSH
6768: LD_INT 3
6770: ARRAY
6771: PUSH
6772: LD_VAR 0 1
6776: EQUAL
6777: IFFALSE 6793
// amount = amount + 1 ;
6779: LD_ADDR_VAR 0 4
6783: PUSH
6784: LD_VAR 0 4
6788: PUSH
6789: LD_INT 1
6791: PLUS
6792: ST_TO_ADDR
6793: GO 6754
6795: POP
6796: POP
// result = amount ;
6797: LD_ADDR_VAR 0 2
6801: PUSH
6802: LD_VAR 0 4
6806: ST_TO_ADDR
// end ;
6807: LD_VAR 0 2
6811: RET
// export function SetWeaponDataBuild ( weapon , turret ) ; var i ; begin
6812: LD_INT 0
6814: PPUSH
6815: PPUSH
// if turret then
6816: LD_VAR 0 2
6820: IFFALSE 6918
// begin for i := 1 to weaponsData do
6822: LD_ADDR_VAR 0 4
6826: PUSH
6827: DOUBLE
6828: LD_INT 1
6830: DEC
6831: ST_TO_ADDR
6832: LD_EXP 12
6836: PUSH
6837: FOR_TO
6838: IFFALSE 6914
// if weaponsData [ i ] [ 1 ] = weapon and weaponsData [ i ] [ 2 ] = false then
6840: LD_EXP 12
6844: PUSH
6845: LD_VAR 0 4
6849: ARRAY
6850: PUSH
6851: LD_INT 1
6853: ARRAY
6854: PUSH
6855: LD_VAR 0 1
6859: EQUAL
6860: PUSH
6861: LD_EXP 12
6865: PUSH
6866: LD_VAR 0 4
6870: ARRAY
6871: PUSH
6872: LD_INT 2
6874: ARRAY
6875: PUSH
6876: LD_INT 0
6878: EQUAL
6879: AND
6880: IFFALSE 6912
// weaponsData = ReplaceIn ( weaponsData , [ i , 2 ] , true ) ;
6882: LD_ADDR_EXP 12
6886: PUSH
6887: LD_EXP 12
6891: PPUSH
6892: LD_VAR 0 4
6896: PUSH
6897: LD_INT 2
6899: PUSH
6900: EMPTY
6901: LIST
6902: LIST
6903: PPUSH
6904: LD_INT 1
6906: PPUSH
6907: CALL 24096 0 3
6911: ST_TO_ADDR
6912: GO 6837
6914: POP
6915: POP
// end else
6916: GO 7012
// begin for i := 1 to weaponsData do
6918: LD_ADDR_VAR 0 4
6922: PUSH
6923: DOUBLE
6924: LD_INT 1
6926: DEC
6927: ST_TO_ADDR
6928: LD_EXP 12
6932: PUSH
6933: FOR_TO
6934: IFFALSE 7010
// if weaponsData [ i ] [ 1 ] = weapon and weaponsData [ i ] [ 3 ] = false then
6936: LD_EXP 12
6940: PUSH
6941: LD_VAR 0 4
6945: ARRAY
6946: PUSH
6947: LD_INT 1
6949: ARRAY
6950: PUSH
6951: LD_VAR 0 1
6955: EQUAL
6956: PUSH
6957: LD_EXP 12
6961: PUSH
6962: LD_VAR 0 4
6966: ARRAY
6967: PUSH
6968: LD_INT 3
6970: ARRAY
6971: PUSH
6972: LD_INT 0
6974: EQUAL
6975: AND
6976: IFFALSE 7008
// weaponsData = ReplaceIn ( weaponsData , [ i , 3 ] , true ) ;
6978: LD_ADDR_EXP 12
6982: PUSH
6983: LD_EXP 12
6987: PPUSH
6988: LD_VAR 0 4
6992: PUSH
6993: LD_INT 3
6995: PUSH
6996: EMPTY
6997: LIST
6998: LIST
6999: PPUSH
7000: LD_INT 1
7002: PPUSH
7003: CALL 24096 0 3
7007: ST_TO_ADDR
7008: GO 6933
7010: POP
7011: POP
// end ; end ;
7012: LD_VAR 0 3
7016: RET
// export function ShootTreningController ; var i , unitsInArea , unit , depots , depot , barrelsAreaList , randIndex , randPosX , randPosY , barrelsInArea ; begin
7017: LD_INT 0
7019: PPUSH
7020: PPUSH
7021: PPUSH
7022: PPUSH
7023: PPUSH
7024: PPUSH
7025: PPUSH
7026: PPUSH
7027: PPUSH
7028: PPUSH
7029: PPUSH
// unitsInArea = FilterUnitsInArea ( ShootArea , [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) ;
7030: LD_ADDR_VAR 0 3
7034: PUSH
7035: LD_INT 12
7037: PPUSH
7038: LD_INT 22
7040: PUSH
7041: LD_INT 3
7043: PUSH
7044: EMPTY
7045: LIST
7046: LIST
7047: PUSH
7048: LD_INT 21
7050: PUSH
7051: LD_INT 1
7053: PUSH
7054: EMPTY
7055: LIST
7056: LIST
7057: PUSH
7058: LD_INT 50
7060: PUSH
7061: EMPTY
7062: LIST
7063: PUSH
7064: LD_INT 3
7066: PUSH
7067: LD_INT 60
7069: PUSH
7070: EMPTY
7071: LIST
7072: PUSH
7073: EMPTY
7074: LIST
7075: LIST
7076: PUSH
7077: EMPTY
7078: LIST
7079: LIST
7080: LIST
7081: LIST
7082: PPUSH
7083: CALL_OW 70
7087: ST_TO_ADDR
// depots = FilterAllUnits ( [ [ f_side , 3 ] , [ f_ok ] , [ f_type , unit_building ] , [ f_not , [ f_constructed ] ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
7088: LD_ADDR_VAR 0 5
7092: PUSH
7093: LD_INT 22
7095: PUSH
7096: LD_INT 3
7098: PUSH
7099: EMPTY
7100: LIST
7101: LIST
7102: PUSH
7103: LD_INT 50
7105: PUSH
7106: EMPTY
7107: LIST
7108: PUSH
7109: LD_INT 21
7111: PUSH
7112: LD_INT 3
7114: PUSH
7115: EMPTY
7116: LIST
7117: LIST
7118: PUSH
7119: LD_INT 3
7121: PUSH
7122: LD_INT 57
7124: PUSH
7125: EMPTY
7126: LIST
7127: PUSH
7128: EMPTY
7129: LIST
7130: LIST
7131: PUSH
7132: LD_INT 2
7134: PUSH
7135: LD_INT 30
7137: PUSH
7138: LD_INT 0
7140: PUSH
7141: EMPTY
7142: LIST
7143: LIST
7144: PUSH
7145: LD_INT 30
7147: PUSH
7148: LD_INT 1
7150: PUSH
7151: EMPTY
7152: LIST
7153: LIST
7154: PUSH
7155: EMPTY
7156: LIST
7157: LIST
7158: LIST
7159: PUSH
7160: EMPTY
7161: LIST
7162: LIST
7163: LIST
7164: LIST
7165: LIST
7166: PPUSH
7167: CALL_OW 69
7171: ST_TO_ADDR
// barrelsAreaList = AreaToList ( BarrelsArea , 0 ) ;
7172: LD_ADDR_VAR 0 7
7176: PUSH
7177: LD_INT 13
7179: PPUSH
7180: LD_INT 0
7182: PPUSH
7183: CALL_OW 517
7187: ST_TO_ADDR
// if not depots or not unitsInArea then
7188: LD_VAR 0 5
7192: NOT
7193: PUSH
7194: LD_VAR 0 3
7198: NOT
7199: OR
7200: IFFALSE 7204
// exit ;
7202: GO 7640
// depot = depots [ 1 ] ;
7204: LD_ADDR_VAR 0 6
7208: PUSH
7209: LD_VAR 0 5
7213: PUSH
7214: LD_INT 1
7216: ARRAY
7217: ST_TO_ADDR
// for unit in unitsInArea do
7218: LD_ADDR_VAR 0 4
7222: PUSH
7223: LD_VAR 0 3
7227: PUSH
7228: FOR_IN
7229: IFFALSE 7638
// begin if not GetClass ( unit ) = class_engineer then
7231: LD_VAR 0 4
7235: PPUSH
7236: CALL_OW 257
7240: PUSH
7241: LD_INT 2
7243: EQUAL
7244: NOT
7245: IFFALSE 7282
// begin ComEnterUnit ( unit , depot ) ;
7247: LD_VAR 0 4
7251: PPUSH
7252: LD_VAR 0 6
7256: PPUSH
7257: CALL_OW 120
// AddComChangeProfession ( unit , class_engineer ) ;
7261: LD_VAR 0 4
7265: PPUSH
7266: LD_INT 2
7268: PPUSH
7269: CALL_OW 183
// AddComExitBuilding ( unit ) ;
7273: LD_VAR 0 4
7277: PPUSH
7278: CALL_OW 182
// end ; if GetCargo ( unit , mat_oil ) = 0 then
7282: LD_VAR 0 4
7286: PPUSH
7287: LD_INT 2
7289: PPUSH
7290: CALL_OW 289
7294: PUSH
7295: LD_INT 0
7297: EQUAL
7298: IFFALSE 7317
// AddComTransport ( unit , depot , mat_oil ) ;
7300: LD_VAR 0 4
7304: PPUSH
7305: LD_VAR 0 6
7309: PPUSH
7310: LD_INT 2
7312: PPUSH
7313: CALL_OW 211
// repeat wait ( 0 0$1 ) ;
7317: LD_INT 35
7319: PPUSH
7320: CALL_OW 67
// until not HasTask ( unit ) ;
7324: LD_VAR 0 4
7328: PPUSH
7329: CALL_OW 314
7333: NOT
7334: IFFALSE 7317
// if GetCargo ( unit , mat_oil ) > 0 then
7336: LD_VAR 0 4
7340: PPUSH
7341: LD_INT 2
7343: PPUSH
7344: CALL_OW 289
7348: PUSH
7349: LD_INT 0
7351: GREATER
7352: IFFALSE 7636
// begin randIndex = Rand ( 1 , barrelsAreaList [ 1 ] ) ;
7354: LD_ADDR_VAR 0 8
7358: PUSH
7359: LD_INT 1
7361: PPUSH
7362: LD_VAR 0 7
7366: PUSH
7367: LD_INT 1
7369: ARRAY
7370: PPUSH
7371: CALL_OW 12
7375: ST_TO_ADDR
// randPosX = barrelsAreaList [ 1 ] [ randIndex ] ;
7376: LD_ADDR_VAR 0 9
7380: PUSH
7381: LD_VAR 0 7
7385: PUSH
7386: LD_INT 1
7388: ARRAY
7389: PUSH
7390: LD_VAR 0 8
7394: ARRAY
7395: ST_TO_ADDR
// randPosY = barrelsAreaList [ 2 ] [ RandIndex ] ;
7396: LD_ADDR_VAR 0 10
7400: PUSH
7401: LD_VAR 0 7
7405: PUSH
7406: LD_INT 2
7408: ARRAY
7409: PUSH
7410: LD_VAR 0 8
7414: ARRAY
7415: ST_TO_ADDR
// AddComMoveXY ( unit , randPosX , randPosY ) ;
7416: LD_VAR 0 4
7420: PPUSH
7421: LD_VAR 0 9
7425: PPUSH
7426: LD_VAR 0 10
7430: PPUSH
7431: CALL_OW 171
// AddComUnload ( unit ) ;
7435: LD_VAR 0 4
7439: PPUSH
7440: CALL_OW 219
// AddComMoveXY ( unit , randPosX + 2 , randPosY + 2 ) ;
7444: LD_VAR 0 4
7448: PPUSH
7449: LD_VAR 0 9
7453: PUSH
7454: LD_INT 2
7456: PLUS
7457: PPUSH
7458: LD_VAR 0 10
7462: PUSH
7463: LD_INT 2
7465: PLUS
7466: PPUSH
7467: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
7471: LD_INT 35
7473: PPUSH
7474: CALL_OW 67
// until not HasTask ( unit ) ;
7478: LD_VAR 0 4
7482: PPUSH
7483: CALL_OW 314
7487: NOT
7488: IFFALSE 7471
// barrelsInArea = GetListOfCratesInArea ( ShootArea ) ;
7490: LD_ADDR_VAR 0 11
7494: PUSH
7495: LD_INT 12
7497: PPUSH
7498: CALL_OW 435
7502: ST_TO_ADDR
// for i := 1 to barrelsInArea / 2 do
7503: LD_ADDR_VAR 0 2
7507: PUSH
7508: DOUBLE
7509: LD_INT 1
7511: DEC
7512: ST_TO_ADDR
7513: LD_VAR 0 11
7517: PUSH
7518: LD_INT 2
7520: DIVREAL
7521: PUSH
7522: FOR_TO
7523: IFFALSE 7634
// begin if GetDistUnitXY ( unit , barrelsInArea [ i ] , barrelsInArea [ i + 1 ] ) <= 6 then
7525: LD_VAR 0 4
7529: PPUSH
7530: LD_VAR 0 11
7534: PUSH
7535: LD_VAR 0 2
7539: ARRAY
7540: PPUSH
7541: LD_VAR 0 11
7545: PUSH
7546: LD_VAR 0 2
7550: PUSH
7551: LD_INT 1
7553: PLUS
7554: ARRAY
7555: PPUSH
7556: CALL_OW 297
7560: PUSH
7561: LD_INT 6
7563: LESSEQUAL
7564: IFFALSE 7618
// begin AddComAttackPlace ( unit , barrelsInArea [ i ] , barrelsInArea [ i + 1 ] ) ;
7566: LD_VAR 0 4
7570: PPUSH
7571: LD_VAR 0 11
7575: PUSH
7576: LD_VAR 0 2
7580: ARRAY
7581: PPUSH
7582: LD_VAR 0 11
7586: PUSH
7587: LD_VAR 0 2
7591: PUSH
7592: LD_INT 1
7594: PLUS
7595: ARRAY
7596: PPUSH
7597: CALL_OW 176
// AddExperience ( unit , skill_combat , 5 ) ;
7601: LD_VAR 0 4
7605: PPUSH
7606: LD_INT 1
7608: PPUSH
7609: LD_INT 5
7611: PPUSH
7612: CALL_OW 492
// break ;
7616: GO 7634
// end ; i = i + 2 ;
7618: LD_ADDR_VAR 0 2
7622: PUSH
7623: LD_VAR 0 2
7627: PUSH
7628: LD_INT 2
7630: PLUS
7631: ST_TO_ADDR
// end ;
7632: GO 7522
7634: POP
7635: POP
// end ; end ;
7636: GO 7228
7638: POP
7639: POP
// end ;
7640: LD_VAR 0 1
7644: RET
// export function GoToHunt ( hunter ) ; var i , barracks , barrackTarget , barrackTargetCurrentHP , animals , animal ; begin
7645: LD_INT 0
7647: PPUSH
7648: PPUSH
7649: PPUSH
7650: PPUSH
7651: PPUSH
7652: PPUSH
7653: PPUSH
// animals = [ ] ;
7654: LD_ADDR_VAR 0 7
7658: PUSH
7659: EMPTY
7660: ST_TO_ADDR
// barracks = FilterAllUnits ( [ [ f_ok ] , [ f_not , [ f_constructed ] ] , [ f_or , [ f_btype , b_barracks ] , [ f_btype , b_armoury ] ] ] ) ;
7661: LD_ADDR_VAR 0 4
7665: PUSH
7666: LD_INT 50
7668: PUSH
7669: EMPTY
7670: LIST
7671: PUSH
7672: LD_INT 3
7674: PUSH
7675: LD_INT 57
7677: PUSH
7678: EMPTY
7679: LIST
7680: PUSH
7681: EMPTY
7682: LIST
7683: LIST
7684: PUSH
7685: LD_INT 2
7687: PUSH
7688: LD_INT 30
7690: PUSH
7691: LD_INT 5
7693: PUSH
7694: EMPTY
7695: LIST
7696: LIST
7697: PUSH
7698: LD_INT 30
7700: PUSH
7701: LD_INT 4
7703: PUSH
7704: EMPTY
7705: LIST
7706: LIST
7707: PUSH
7708: EMPTY
7709: LIST
7710: LIST
7711: LIST
7712: PUSH
7713: EMPTY
7714: LIST
7715: LIST
7716: LIST
7717: PPUSH
7718: CALL_OW 69
7722: ST_TO_ADDR
// SetSide ( hunter , 6 ) ;
7723: LD_VAR 0 1
7727: PPUSH
7728: LD_INT 6
7730: PPUSH
7731: CALL_OW 235
// if IsInUnit ( hunter ) then
7735: LD_VAR 0 1
7739: PPUSH
7740: CALL_OW 310
7744: IFFALSE 7786
// begin if GetBType ( IsInUnit ( hunter ) = unit_vehicle ) then
7746: LD_VAR 0 1
7750: PPUSH
7751: CALL_OW 310
7755: PUSH
7756: LD_INT 2
7758: EQUAL
7759: PPUSH
7760: CALL_OW 266
7764: IFFALSE 7777
// ComExitVehicle ( hunter ) else
7766: LD_VAR 0 1
7770: PPUSH
7771: CALL_OW 121
7775: GO 7786
// ComExitBuilding ( hunter ) ;
7777: LD_VAR 0 1
7781: PPUSH
7782: CALL_OW 122
// end ; ComWalk ( hunter ) ;
7786: LD_VAR 0 1
7790: PPUSH
7791: CALL_OW 138
// wait ( 0 0$1 ) ;
7795: LD_INT 35
7797: PPUSH
7798: CALL_OW 67
// if not GetClass ( hunter ) = class_soldier and barracks then
7802: LD_VAR 0 1
7806: PPUSH
7807: CALL_OW 257
7811: PUSH
7812: LD_INT 1
7814: EQUAL
7815: NOT
7816: PUSH
7817: LD_VAR 0 4
7821: AND
7822: IFFALSE 7965
// begin barrackTarget = barracks [ 1 ] ;
7824: LD_ADDR_VAR 0 5
7828: PUSH
7829: LD_VAR 0 4
7833: PUSH
7834: LD_INT 1
7836: ARRAY
7837: ST_TO_ADDR
// barrackTargetCurrentHP = GetLives ( barrackTarget ) ;
7838: LD_ADDR_VAR 0 6
7842: PUSH
7843: LD_VAR 0 5
7847: PPUSH
7848: CALL_OW 256
7852: ST_TO_ADDR
// SetSide ( barrackTarget , 6 ) ;
7853: LD_VAR 0 5
7857: PPUSH
7858: LD_INT 6
7860: PPUSH
7861: CALL_OW 235
// ComEnterUnit ( hunter , barrackTarget ) ;
7865: LD_VAR 0 1
7869: PPUSH
7870: LD_VAR 0 5
7874: PPUSH
7875: CALL_OW 120
// repeat wait ( 0 0$1 ) ;
7879: LD_INT 35
7881: PPUSH
7882: CALL_OW 67
// ComEnterUnit ( hunter , barrackTarget ) ;
7886: LD_VAR 0 1
7890: PPUSH
7891: LD_VAR 0 5
7895: PPUSH
7896: CALL_OW 120
// SetLives ( barrackTarget , barrackTargetCurrentHP ) ;
7900: LD_VAR 0 5
7904: PPUSH
7905: LD_VAR 0 6
7909: PPUSH
7910: CALL_OW 234
// until IsInUnit ( hunter ) ;
7914: LD_VAR 0 1
7918: PPUSH
7919: CALL_OW 310
7923: IFFALSE 7879
// SetClass ( hunter , class_soldier ) ;
7925: LD_VAR 0 1
7929: PPUSH
7930: LD_INT 1
7932: PPUSH
7933: CALL_OW 336
// ComExitBuilding ( hunter ) ;
7937: LD_VAR 0 1
7941: PPUSH
7942: CALL_OW 122
// SetSide ( barrackTarget , 3 ) ;
7946: LD_VAR 0 5
7950: PPUSH
7951: LD_INT 3
7953: PPUSH
7954: CALL_OW 235
// wait ( 0 0$1 ) ;
7958: LD_INT 35
7960: PPUSH
7961: CALL_OW 67
// end ; for i := 1 to 3 do
7965: LD_ADDR_VAR 0 3
7969: PUSH
7970: DOUBLE
7971: LD_INT 1
7973: DEC
7974: ST_TO_ADDR
7975: LD_INT 3
7977: PUSH
7978: FOR_TO
7979: IFFALSE 8084
// begin uc_side = 0 ;
7981: LD_ADDR_OWVAR 20
7985: PUSH
7986: LD_INT 0
7988: ST_TO_ADDR
// uc_nation = nation_nature ;
7989: LD_ADDR_OWVAR 21
7993: PUSH
7994: LD_INT 0
7996: ST_TO_ADDR
// PrepareHuman ( false , [ class_phororhacos , class_tiger , 21 ] [ Rand ( 1 , 3 ) ] , 0 ) ;
7997: LD_INT 0
7999: PPUSH
8000: LD_INT 18
8002: PUSH
8003: LD_INT 14
8005: PUSH
8006: LD_INT 21
8008: PUSH
8009: EMPTY
8010: LIST
8011: LIST
8012: LIST
8013: PUSH
8014: LD_INT 1
8016: PPUSH
8017: LD_INT 3
8019: PPUSH
8020: CALL_OW 12
8024: ARRAY
8025: PPUSH
8026: LD_INT 0
8028: PPUSH
8029: CALL_OW 380
// hc_agressivity = 0 ;
8033: LD_ADDR_OWVAR 35
8037: PUSH
8038: LD_INT 0
8040: ST_TO_ADDR
// animal = CreateHuman ;
8041: LD_ADDR_VAR 0 8
8045: PUSH
8046: CALL_OW 44
8050: ST_TO_ADDR
// PlaceUnitArea ( animal , NatureArea , false ) ;
8051: LD_VAR 0 8
8055: PPUSH
8056: LD_INT 5
8058: PPUSH
8059: LD_INT 0
8061: PPUSH
8062: CALL_OW 49
// animals = animals ^ animal ;
8066: LD_ADDR_VAR 0 7
8070: PUSH
8071: LD_VAR 0 7
8075: PUSH
8076: LD_VAR 0 8
8080: ADD
8081: ST_TO_ADDR
// end ;
8082: GO 7978
8084: POP
8085: POP
// for i := 1 to animals do
8086: LD_ADDR_VAR 0 3
8090: PUSH
8091: DOUBLE
8092: LD_INT 1
8094: DEC
8095: ST_TO_ADDR
8096: LD_VAR 0 7
8100: PUSH
8101: FOR_TO
8102: IFFALSE 8126
// AddComAttackUnit ( hunter , animals [ i ] ) ;
8104: LD_VAR 0 1
8108: PPUSH
8109: LD_VAR 0 7
8113: PUSH
8114: LD_VAR 0 3
8118: ARRAY
8119: PPUSH
8120: CALL_OW 175
8124: GO 8101
8126: POP
8127: POP
// repeat wait ( 0 0$1 ) ;
8128: LD_INT 35
8130: PPUSH
8131: CALL_OW 67
// if GetClass ( hunter ) = class_soldier then
8135: LD_VAR 0 1
8139: PPUSH
8140: CALL_OW 257
8144: PUSH
8145: LD_INT 1
8147: EQUAL
8148: IFFALSE 8195
// begin if GetDistUnits ( hunter , WantsToAttack ( hunter ) ) < 13 then
8150: LD_VAR 0 1
8154: PPUSH
8155: LD_VAR 0 1
8159: PPUSH
8160: CALL_OW 319
8164: PPUSH
8165: CALL_OW 296
8169: PUSH
8170: LD_INT 13
8172: LESS
8173: IFFALSE 8186
// ComCrawl ( hunter ) else
8175: LD_VAR 0 1
8179: PPUSH
8180: CALL_OW 137
8184: GO 8195
// ComWalk ( hunter ) ;
8186: LD_VAR 0 1
8190: PPUSH
8191: CALL_OW 138
// end ; until not HasTask ( hunter ) ;
8195: LD_VAR 0 1
8199: PPUSH
8200: CALL_OW 314
8204: NOT
8205: IFFALSE 8128
// repeat wait ( 0 0$1 ) ;
8207: LD_INT 35
8209: PPUSH
8210: CALL_OW 67
// ComMoveXY ( hunter , GetX ( Burlak ) , GetY ( Burlak ) ) ;
8214: LD_VAR 0 1
8218: PPUSH
8219: LD_EXP 57
8223: PPUSH
8224: CALL_OW 250
8228: PPUSH
8229: LD_EXP 57
8233: PPUSH
8234: CALL_OW 251
8238: PPUSH
8239: CALL_OW 111
// until GetDistUnits ( hunter , Burlak ) <= 9 ;
8243: LD_VAR 0 1
8247: PPUSH
8248: LD_EXP 57
8252: PPUSH
8253: CALL_OW 296
8257: PUSH
8258: LD_INT 9
8260: LESSEQUAL
8261: IFFALSE 8207
// SetSide ( hunter , 3 ) ;
8263: LD_VAR 0 1
8267: PPUSH
8268: LD_INT 3
8270: PPUSH
8271: CALL_OW 235
// CenterOnUnits ( hunter ) ;
8275: LD_VAR 0 1
8279: PPUSH
8280: CALL_OW 85
// AddExperience ( hunter , skill_combat , 3000 ) ;
8284: LD_VAR 0 1
8288: PPUSH
8289: LD_INT 1
8291: PPUSH
8292: LD_INT 3000
8294: PPUSH
8295: CALL_OW 492
// end ;
8299: LD_VAR 0 2
8303: RET
// export function SetMashaData ( vehicle ) ; begin
8304: LD_INT 0
8306: PPUSH
// if Masha then
8307: LD_EXP 4
8311: IFFALSE 8329
// SetMark ( Masha [ 1 ] , 0 ) ;
8313: LD_EXP 4
8317: PUSH
8318: LD_INT 1
8320: ARRAY
8321: PPUSH
8322: LD_INT 0
8324: PPUSH
8325: CALL_OW 242
// Masha = [ vehicle , GetChassis ( vehicle ) , GetEngine ( vehicle ) , GetControl ( vehicle ) , GetWeapon ( vehicle ) ] ;
8329: LD_ADDR_EXP 4
8333: PUSH
8334: LD_VAR 0 1
8338: PUSH
8339: LD_VAR 0 1
8343: PPUSH
8344: CALL_OW 265
8348: PUSH
8349: LD_VAR 0 1
8353: PPUSH
8354: CALL_OW 262
8358: PUSH
8359: LD_VAR 0 1
8363: PPUSH
8364: CALL_OW 263
8368: PUSH
8369: LD_VAR 0 1
8373: PPUSH
8374: CALL_OW 264
8378: PUSH
8379: EMPTY
8380: LIST
8381: LIST
8382: LIST
8383: LIST
8384: LIST
8385: ST_TO_ADDR
// ChangeMissionObjectives ( MMashaDone ) ;
8386: LD_STRING MMashaDone
8388: PPUSH
8389: CALL_OW 337
// SetMark ( vehicle , 1 ) ;
8393: LD_VAR 0 1
8397: PPUSH
8398: LD_INT 1
8400: PPUSH
8401: CALL_OW 242
// end ;
8405: LD_VAR 0 2
8409: RET
// export function SaveBase ( buildings , ident ) ; var i , buildingsToSave ; begin
8410: LD_INT 0
8412: PPUSH
8413: PPUSH
8414: PPUSH
// buildingsToSave = [ ] ;
8415: LD_ADDR_VAR 0 5
8419: PUSH
8420: EMPTY
8421: ST_TO_ADDR
// if not buildings then
8422: LD_VAR 0 1
8426: NOT
8427: IFFALSE 8431
// exit ;
8429: GO 9006
// for i in buildings do
8431: LD_ADDR_VAR 0 4
8435: PUSH
8436: LD_VAR 0 1
8440: PUSH
8441: FOR_IN
8442: IFFALSE 8990
// begin if GetBType ( i ) in [ b_lab , b_lab_half , b_lab_full ] then
8444: LD_VAR 0 4
8448: PPUSH
8449: CALL_OW 266
8453: PUSH
8454: LD_INT 6
8456: PUSH
8457: LD_INT 7
8459: PUSH
8460: LD_INT 8
8462: PUSH
8463: EMPTY
8464: LIST
8465: LIST
8466: LIST
8467: IN
8468: IFFALSE 8593
// buildingsToSave = buildingsToSave ^ [ [ GetBType ( i ) , GetX ( i ) , GetY ( i ) , GetDir ( i ) , GetBLevel ( i ) , GetNation ( i ) , GetLives ( i ) , GetLabKind ( i , 1 ) , GetLabKind ( i , 2 ) ] ] else
8470: LD_ADDR_VAR 0 5
8474: PUSH
8475: LD_VAR 0 5
8479: PUSH
8480: LD_VAR 0 4
8484: PPUSH
8485: CALL_OW 266
8489: PUSH
8490: LD_VAR 0 4
8494: PPUSH
8495: CALL_OW 250
8499: PUSH
8500: LD_VAR 0 4
8504: PPUSH
8505: CALL_OW 251
8509: PUSH
8510: LD_VAR 0 4
8514: PPUSH
8515: CALL_OW 254
8519: PUSH
8520: LD_VAR 0 4
8524: PPUSH
8525: CALL_OW 267
8529: PUSH
8530: LD_VAR 0 4
8534: PPUSH
8535: CALL_OW 248
8539: PUSH
8540: LD_VAR 0 4
8544: PPUSH
8545: CALL_OW 256
8549: PUSH
8550: LD_VAR 0 4
8554: PPUSH
8555: LD_INT 1
8557: PPUSH
8558: CALL_OW 268
8562: PUSH
8563: LD_VAR 0 4
8567: PPUSH
8568: LD_INT 2
8570: PPUSH
8571: CALL_OW 268
8575: PUSH
8576: EMPTY
8577: LIST
8578: LIST
8579: LIST
8580: LIST
8581: LIST
8582: LIST
8583: LIST
8584: LIST
8585: LIST
8586: PUSH
8587: EMPTY
8588: LIST
8589: ADD
8590: ST_TO_ADDR
8591: GO 8988
// if GetBType ( i ) in [ b_bunker , b_turret ] then
8593: LD_VAR 0 4
8597: PPUSH
8598: CALL_OW 266
8602: PUSH
8603: LD_INT 32
8605: PUSH
8606: LD_INT 33
8608: PUSH
8609: EMPTY
8610: LIST
8611: LIST
8612: IN
8613: IFFALSE 8721
// buildingsToSave = buildingsToSave ^ [ [ GetBType ( i ) , GetX ( i ) , GetY ( i ) , GetDir ( i ) , GetBLevel ( i ) , GetNation ( i ) , GetLives ( i ) , GetBWeapon ( i ) ] ] else
8615: LD_ADDR_VAR 0 5
8619: PUSH
8620: LD_VAR 0 5
8624: PUSH
8625: LD_VAR 0 4
8629: PPUSH
8630: CALL_OW 266
8634: PUSH
8635: LD_VAR 0 4
8639: PPUSH
8640: CALL_OW 250
8644: PUSH
8645: LD_VAR 0 4
8649: PPUSH
8650: CALL_OW 251
8654: PUSH
8655: LD_VAR 0 4
8659: PPUSH
8660: CALL_OW 254
8664: PUSH
8665: LD_VAR 0 4
8669: PPUSH
8670: CALL_OW 267
8674: PUSH
8675: LD_VAR 0 4
8679: PPUSH
8680: CALL_OW 248
8684: PUSH
8685: LD_VAR 0 4
8689: PPUSH
8690: CALL_OW 256
8694: PUSH
8695: LD_VAR 0 4
8699: PPUSH
8700: CALL_OW 269
8704: PUSH
8705: EMPTY
8706: LIST
8707: LIST
8708: LIST
8709: LIST
8710: LIST
8711: LIST
8712: LIST
8713: LIST
8714: PUSH
8715: EMPTY
8716: LIST
8717: ADD
8718: ST_TO_ADDR
8719: GO 8988
// if GetBType ( i ) in [ b_depot , b_warehouse ] then
8721: LD_VAR 0 4
8725: PPUSH
8726: CALL_OW 266
8730: PUSH
8731: LD_INT 0
8733: PUSH
8734: LD_INT 1
8736: PUSH
8737: EMPTY
8738: LIST
8739: LIST
8740: IN
8741: IFFALSE 8895
// buildingsToSave = buildingsToSave ^ [ [ GetBType ( i ) , GetX ( i ) , GetY ( i ) , GetDir ( i ) , GetBLevel ( i ) , GetNation ( i ) , GetLives ( i ) , GetResourceType ( GetBase ( i ) , mat_cans ) , GetResourceType ( GetBase ( i ) , mat_oil ) , GetResourceType ( GetBase ( i ) , mat_siberit ) ] ] else
8743: LD_ADDR_VAR 0 5
8747: PUSH
8748: LD_VAR 0 5
8752: PUSH
8753: LD_VAR 0 4
8757: PPUSH
8758: CALL_OW 266
8762: PUSH
8763: LD_VAR 0 4
8767: PPUSH
8768: CALL_OW 250
8772: PUSH
8773: LD_VAR 0 4
8777: PPUSH
8778: CALL_OW 251
8782: PUSH
8783: LD_VAR 0 4
8787: PPUSH
8788: CALL_OW 254
8792: PUSH
8793: LD_VAR 0 4
8797: PPUSH
8798: CALL_OW 267
8802: PUSH
8803: LD_VAR 0 4
8807: PPUSH
8808: CALL_OW 248
8812: PUSH
8813: LD_VAR 0 4
8817: PPUSH
8818: CALL_OW 256
8822: PUSH
8823: LD_VAR 0 4
8827: PPUSH
8828: CALL_OW 274
8832: PPUSH
8833: LD_INT 1
8835: PPUSH
8836: CALL_OW 275
8840: PUSH
8841: LD_VAR 0 4
8845: PPUSH
8846: CALL_OW 274
8850: PPUSH
8851: LD_INT 2
8853: PPUSH
8854: CALL_OW 275
8858: PUSH
8859: LD_VAR 0 4
8863: PPUSH
8864: CALL_OW 274
8868: PPUSH
8869: LD_INT 3
8871: PPUSH
8872: CALL_OW 275
8876: PUSH
8877: EMPTY
8878: LIST
8879: LIST
8880: LIST
8881: LIST
8882: LIST
8883: LIST
8884: LIST
8885: LIST
8886: LIST
8887: LIST
8888: PUSH
8889: EMPTY
8890: LIST
8891: ADD
8892: ST_TO_ADDR
8893: GO 8988
// buildingsToSave = buildingsToSave ^ [ [ GetBType ( i ) , GetX ( i ) , GetY ( i ) , GetDir ( i ) , GetBLevel ( i ) , GetNation ( i ) , GetLives ( i ) ] ] ;
8895: LD_ADDR_VAR 0 5
8899: PUSH
8900: LD_VAR 0 5
8904: PUSH
8905: LD_VAR 0 4
8909: PPUSH
8910: CALL_OW 266
8914: PUSH
8915: LD_VAR 0 4
8919: PPUSH
8920: CALL_OW 250
8924: PUSH
8925: LD_VAR 0 4
8929: PPUSH
8930: CALL_OW 251
8934: PUSH
8935: LD_VAR 0 4
8939: PPUSH
8940: CALL_OW 254
8944: PUSH
8945: LD_VAR 0 4
8949: PPUSH
8950: CALL_OW 267
8954: PUSH
8955: LD_VAR 0 4
8959: PPUSH
8960: CALL_OW 248
8964: PUSH
8965: LD_VAR 0 4
8969: PPUSH
8970: CALL_OW 256
8974: PUSH
8975: EMPTY
8976: LIST
8977: LIST
8978: LIST
8979: LIST
8980: LIST
8981: LIST
8982: LIST
8983: PUSH
8984: EMPTY
8985: LIST
8986: ADD
8987: ST_TO_ADDR
// end ;
8988: GO 8441
8990: POP
8991: POP
// SaveVariable ( buildingsToSave , ident ) ;
8992: LD_VAR 0 5
8996: PPUSH
8997: LD_VAR 0 2
9001: PPUSH
9002: CALL_OW 39
// end ; end_of_file
9006: LD_VAR 0 3
9010: RET
// export function MissionIntro ; begin
9011: LD_INT 0
9013: PPUSH
// CenterNowOnUnits ( Burlak ) ;
9014: LD_EXP 57
9018: PPUSH
9019: CALL_OW 87
// DialogueOn ;
9023: CALL_OW 6
// SayRadio ( Popov , DStart-Pop-1 ) ;
9027: LD_EXP 76
9031: PPUSH
9032: LD_STRING DStart-Pop-1
9034: PPUSH
9035: CALL_OW 94
// Say ( Burlak , DStart-Bur-1 ) ;
9039: LD_EXP 57
9043: PPUSH
9044: LD_STRING DStart-Bur-1
9046: PPUSH
9047: CALL_OW 88
// DialogueOff ;
9051: CALL_OW 7
// IngameOff ;
9055: CALL_OW 9
// ChangeMissionObjectives ( MStart ) ;
9059: LD_STRING MStart
9061: PPUSH
9062: CALL_OW 337
// SaveForQuickRestart ;
9066: CALL_OW 22
// end ;
9070: LD_VAR 0 1
9074: RET
// export function Dial_EscortHeike ( x , y ) ; begin
9075: LD_INT 0
9077: PPUSH
// dial_BuildDepotBlocker = true ;
9078: LD_ADDR_EXP 5
9082: PUSH
9083: LD_INT 1
9085: ST_TO_ADDR
// HeikeTargetX = x ;
9086: LD_ADDR_EXP 14
9090: PUSH
9091: LD_VAR 0 1
9095: ST_TO_ADDR
// HeikeTargetY = y ;
9096: LD_ADDR_EXP 15
9100: PUSH
9101: LD_VAR 0 2
9105: ST_TO_ADDR
// SayRadio ( Popov , DHeike-Pop-1 ) ;
9106: LD_EXP 76
9110: PPUSH
9111: LD_STRING DHeike-Pop-1
9113: PPUSH
9114: CALL_OW 94
// wait ( 0 0$10 ) ;
9118: LD_INT 350
9120: PPUSH
9121: CALL_OW 67
// PrepareRussianEscort ;
9125: CALL 2252 0 0
// PlaceUnitArea ( Heike , RussianSpawn2Area , false ) ;
9129: LD_EXP 79
9133: PPUSH
9134: LD_INT 7
9136: PPUSH
9137: LD_INT 0
9139: PPUSH
9140: CALL_OW 49
// ComMoveXY ( russianEscort , HeikeTargetX , HeikeTargetY ) ;
9144: LD_EXP 77
9148: PPUSH
9149: LD_EXP 14
9153: PPUSH
9154: LD_EXP 15
9158: PPUSH
9159: CALL_OW 111
// AddComMoveToArea ( russianEscort , RussianSpawn2Area ) ;
9163: LD_EXP 77
9167: PPUSH
9168: LD_INT 7
9170: PPUSH
9171: CALL_OW 173
// ComMoveXY ( Heike , HeikeTargetX , HeikeTargetY ) ;
9175: LD_EXP 79
9179: PPUSH
9180: LD_EXP 14
9184: PPUSH
9185: LD_EXP 15
9189: PPUSH
9190: CALL_OW 111
// AddComHold ( Heike ) ;
9194: LD_EXP 79
9198: PPUSH
9199: CALL_OW 200
// end ;
9203: LD_VAR 0 3
9207: RET
// every 1 trigger GetDistUnitXY ( Heike , HeikeTargetX , HeikeTargetY ) <= 5 do
9208: LD_EXP 79
9212: PPUSH
9213: LD_EXP 14
9217: PPUSH
9218: LD_EXP 15
9222: PPUSH
9223: CALL_OW 297
9227: PUSH
9228: LD_INT 5
9230: LESSEQUAL
9231: IFFALSE 9244
9233: GO 9235
9235: DISABLE
// allowExitFromMap = 1 ;
9236: LD_ADDR_EXP 18
9240: PUSH
9241: LD_INT 1
9243: ST_TO_ADDR
9244: END
// every 7 7$0 trigger IsPlaced ( Heike ) and IsOk ( Heike ) and GetAttitude ( 3 , 5 ) = att_friend and HeikeCaptured do
9245: LD_EXP 79
9249: PPUSH
9250: CALL_OW 305
9254: PUSH
9255: LD_EXP 79
9259: PPUSH
9260: CALL_OW 302
9264: AND
9265: PUSH
9266: LD_INT 3
9268: PPUSH
9269: LD_INT 5
9271: PPUSH
9272: CALL_OW 81
9276: PUSH
9277: LD_INT 1
9279: EQUAL
9280: AND
9281: PUSH
9282: LD_EXP 1
9286: AND
9287: IFFALSE 9506
9289: GO 9291
9291: DISABLE
// begin DialogueOn ;
9292: CALL_OW 6
// SayRadio ( Kurt , DMercHelp-Kurt-1 ) ;
9296: LD_EXP 80
9300: PPUSH
9301: LD_STRING DMercHelp-Kurt-1
9303: PPUSH
9304: CALL_OW 94
// Say ( Burlak , DMercHelp-Bur-1 ) ;
9308: LD_EXP 57
9312: PPUSH
9313: LD_STRING DMercHelp-Bur-1
9315: PPUSH
9316: CALL_OW 88
// SayRadio ( Kurt , DMercHelp-Kurt-2 ) ;
9320: LD_EXP 80
9324: PPUSH
9325: LD_STRING DMercHelp-Kurt-2
9327: PPUSH
9328: CALL_OW 94
// Say ( Burlak , DMercHelp-Bur-2 ) ;
9332: LD_EXP 57
9336: PPUSH
9337: LD_STRING DMercHelp-Bur-2
9339: PPUSH
9340: CALL_OW 88
// SayRadio ( Kurt , DMercHelp-Kurt-3 ) ;
9344: LD_EXP 80
9348: PPUSH
9349: LD_STRING DMercHelp-Kurt-3
9351: PPUSH
9352: CALL_OW 94
// case Query ( QMerc ) of 1 :
9356: LD_STRING QMerc
9358: PPUSH
9359: CALL_OW 97
9363: PUSH
9364: LD_INT 1
9366: DOUBLE
9367: EQUAL
9368: IFTRUE 9372
9370: GO 9407
9372: POP
// begin Say ( Burlak , DQrMerc#1-Bur-1 ) ;
9373: LD_EXP 57
9377: PPUSH
9378: LD_STRING DQrMerc#1-Bur-1
9380: PPUSH
9381: CALL_OW 88
// SayRadio ( Kurt , DQrMerc#1-Kurt-1 ) ;
9385: LD_EXP 80
9389: PPUSH
9390: LD_STRING DQrMerc#1-Kurt-1
9392: PPUSH
9393: CALL_OW 94
// acceptKurtOffert = true ;
9397: LD_ADDR_EXP 19
9401: PUSH
9402: LD_INT 1
9404: ST_TO_ADDR
// end ; 2 :
9405: GO 9502
9407: LD_INT 2
9409: DOUBLE
9410: EQUAL
9411: IFTRUE 9415
9413: GO 9470
9415: POP
// begin askCommanders = true ;
9416: LD_ADDR_EXP 20
9420: PUSH
9421: LD_INT 1
9423: ST_TO_ADDR
// Say ( Burlak , DQrMerc#2-Bur-1 ) ;
9424: LD_EXP 57
9428: PPUSH
9429: LD_STRING DQrMerc#2-Bur-1
9431: PPUSH
9432: CALL_OW 88
// SayRadio ( Popov , DQrMerc#2-Pop-1 ) ;
9436: LD_EXP 76
9440: PPUSH
9441: LD_STRING DQrMerc#2-Pop-1
9443: PPUSH
9444: CALL_OW 94
// Say ( Burlak , DQrMerc#2-Bur-2 ) ;
9448: LD_EXP 57
9452: PPUSH
9453: LD_STRING DQrMerc#2-Bur-2
9455: PPUSH
9456: CALL_OW 88
// acceptKurtOffert = true ;
9460: LD_ADDR_EXP 19
9464: PUSH
9465: LD_INT 1
9467: ST_TO_ADDR
// end ; 3 :
9468: GO 9502
9470: LD_INT 3
9472: DOUBLE
9473: EQUAL
9474: IFTRUE 9478
9476: GO 9501
9478: POP
// begin Say ( Burlak , DQrMerc#3-Bur-1 ) ;
9479: LD_EXP 57
9483: PPUSH
9484: LD_STRING DQrMerc#3-Bur-1
9486: PPUSH
9487: CALL_OW 88
// KurtAttack = true ;
9491: LD_ADDR_EXP 25
9495: PUSH
9496: LD_INT 1
9498: ST_TO_ADDR
// end ; end ;
9499: GO 9502
9501: POP
// DialogueOff ;
9502: CALL_OW 7
// end ;
9506: END
// every 0 0$1 trigger acceptKurtOffert do
9507: LD_EXP 19
9511: IFFALSE 9667
9513: GO 9515
9515: DISABLE
// begin PlaceUnitArea ( Kurt , KurtSpawnArea , false ) ;
9516: LD_EXP 80
9520: PPUSH
9521: LD_INT 9
9523: PPUSH
9524: LD_INT 0
9526: PPUSH
9527: CALL_OW 49
// uc_side = 8 ;
9531: LD_ADDR_OWVAR 20
9535: PUSH
9536: LD_INT 8
9538: ST_TO_ADDR
// uc_nation = 2 ;
9539: LD_ADDR_OWVAR 21
9543: PUSH
9544: LD_INT 2
9546: ST_TO_ADDR
// PrepareEngineer ( false , 3 ) ;
9547: LD_INT 0
9549: PPUSH
9550: LD_INT 3
9552: PPUSH
9553: CALL_OW 382
// KurtEng = CreateHuman ;
9557: LD_ADDR_EXP 82
9561: PUSH
9562: CALL_OW 44
9566: ST_TO_ADDR
// PlaceUnitArea ( KurtEng , KurtSpawnArea , false ) ;
9567: LD_EXP 82
9571: PPUSH
9572: LD_INT 9
9574: PPUSH
9575: LD_INT 0
9577: PPUSH
9578: CALL_OW 49
// repeat wait ( 0 0$1 ) ;
9582: LD_INT 35
9584: PPUSH
9585: CALL_OW 67
// ComMoveXY ( [ Kurt , KurtEng ] , GetX ( Burlak ) , GetY ( Burlak ) ) ;
9589: LD_EXP 80
9593: PUSH
9594: LD_EXP 82
9598: PUSH
9599: EMPTY
9600: LIST
9601: LIST
9602: PPUSH
9603: LD_EXP 57
9607: PPUSH
9608: CALL_OW 250
9612: PPUSH
9613: LD_EXP 57
9617: PPUSH
9618: CALL_OW 251
9622: PPUSH
9623: CALL_OW 111
// until GetDistUnits ( Kurt , Burlak ) <= 5 or GetDistUnits ( KurtEng , Burlak ) <= 5 ;
9627: LD_EXP 80
9631: PPUSH
9632: LD_EXP 57
9636: PPUSH
9637: CALL_OW 296
9641: PUSH
9642: LD_INT 5
9644: LESSEQUAL
9645: PUSH
9646: LD_EXP 82
9650: PPUSH
9651: LD_EXP 57
9655: PPUSH
9656: CALL_OW 296
9660: PUSH
9661: LD_INT 5
9663: LESSEQUAL
9664: OR
9665: IFFALSE 9582
// end ;
9667: END
// every 0 0$1 trigger GetDistUnits ( Kurt , Burlak ) <= 5 or GetDistUnits ( KurtEng , Burlak ) <= 5 do
9668: LD_EXP 80
9672: PPUSH
9673: LD_EXP 57
9677: PPUSH
9678: CALL_OW 296
9682: PUSH
9683: LD_INT 5
9685: LESSEQUAL
9686: PUSH
9687: LD_EXP 82
9691: PPUSH
9692: LD_EXP 57
9696: PPUSH
9697: CALL_OW 296
9701: PUSH
9702: LD_INT 5
9704: LESSEQUAL
9705: OR
9706: IFFALSE 9885
9708: GO 9710
9710: DISABLE
// begin KurtWaitingForBuildBarrack = true ;
9711: LD_ADDR_EXP 24
9715: PUSH
9716: LD_INT 1
9718: ST_TO_ADDR
// SetSide ( KurtEng , 3 ) ;
9719: LD_EXP 82
9723: PPUSH
9724: LD_INT 3
9726: PPUSH
9727: CALL_OW 235
// wait ( 1 1$30 ) ;
9731: LD_INT 3150
9733: PPUSH
9734: CALL_OW 67
// DialogueOn ;
9738: CALL_OW 6
// SayRadio ( Dietrich , DArabianRequest-Diet-1 ) ;
9742: LD_EXP 81
9746: PPUSH
9747: LD_STRING DArabianRequest-Diet-1
9749: PPUSH
9750: CALL_OW 94
// Say ( Burlak , DArabianRequest-Bur-1 ) ;
9754: LD_EXP 57
9758: PPUSH
9759: LD_STRING DArabianRequest-Bur-1
9761: PPUSH
9762: CALL_OW 88
// SayRadio ( Dietrich , DArabianRequest-Diet-2 ) ;
9766: LD_EXP 81
9770: PPUSH
9771: LD_STRING DArabianRequest-Diet-2
9773: PPUSH
9774: CALL_OW 94
// DialogueOff ;
9778: CALL_OW 7
// case Query ( QHandOver ) of 1 :
9782: LD_STRING QHandOver
9784: PPUSH
9785: CALL_OW 97
9789: PUSH
9790: LD_INT 1
9792: DOUBLE
9793: EQUAL
9794: IFTRUE 9798
9796: GO 9837
9798: POP
// begin Say ( Burlak , DQrHandOver#1-Bur-1 ) ;
9799: LD_EXP 57
9803: PPUSH
9804: LD_STRING DQrHandOver#1-Bur-1
9806: PPUSH
9807: CALL_OW 88
// SayRadio ( Dietrich , DQrHandOver#1-Diet-1 ) ;
9811: LD_EXP 81
9815: PPUSH
9816: LD_STRING DQrHandOver#1-Diet-1
9818: PPUSH
9819: CALL_OW 94
// coopWithGensher = true ;
9823: LD_ADDR_EXP 2
9827: PUSH
9828: LD_INT 1
9830: ST_TO_ADDR
// SpawnGensherTeam ;
9831: CALL 3872 0 0
// end ; 2 :
9835: GO 9885
9837: LD_INT 2
9839: DOUBLE
9840: EQUAL
9841: IFTRUE 9845
9843: GO 9884
9845: POP
// begin Say ( Burlak , DQrHandOver#2-Bur-1 ) ;
9846: LD_EXP 57
9850: PPUSH
9851: LD_STRING DQrHandOver#2-Bur-1
9853: PPUSH
9854: CALL_OW 88
// SayRadio ( Dietrich , DQrHandOver#2-Diet-1 ) ;
9858: LD_EXP 81
9862: PPUSH
9863: LD_STRING DQrHandOver#2-Diet-1
9865: PPUSH
9866: CALL_OW 94
// Say ( Burlak , DQrHandOver#2-Bur-2 ) ;
9870: LD_EXP 57
9874: PPUSH
9875: LD_STRING DQrHandOver#2-Bur-2
9877: PPUSH
9878: CALL_OW 88
// end ; end ;
9882: GO 9885
9884: POP
// end ;
9885: END
// export function Dial_UpgradeArmoury ; begin
9886: LD_INT 0
9888: PPUSH
// dial_BuildArBarrackBlocker = true ;
9889: LD_ADDR_EXP 6
9893: PUSH
9894: LD_INT 1
9896: ST_TO_ADDR
// buildArabBarrack = true ;
9897: LD_ADDR_EXP 38
9901: PUSH
9902: LD_INT 1
9904: ST_TO_ADDR
// if GetSide ( Kurt ) = 2 or GetSide ( KurtEng ) = 8 then
9905: LD_EXP 80
9909: PPUSH
9910: CALL_OW 255
9914: PUSH
9915: LD_INT 2
9917: EQUAL
9918: PUSH
9919: LD_EXP 82
9923: PPUSH
9924: CALL_OW 255
9928: PUSH
9929: LD_INT 8
9931: EQUAL
9932: OR
9933: IFFALSE 9937
// exit ;
9935: GO 10037
// SetSide ( KurtEng , 8 ) ;
9937: LD_EXP 82
9941: PPUSH
9942: LD_INT 8
9944: PPUSH
9945: CALL_OW 235
// ComStop ( KurtEng ) ;
9949: LD_EXP 82
9953: PPUSH
9954: CALL_OW 141
// DialogueOn ;
9958: CALL_OW 6
// Say ( Kurt , DMercCompleted-Kurt-1 ) ;
9962: LD_EXP 80
9966: PPUSH
9967: LD_STRING DMercCompleted-Kurt-1
9969: PPUSH
9970: CALL_OW 88
// DialogueOff ;
9974: CALL_OW 7
// canSendHeike = true ;
9978: LD_ADDR_EXP 28
9982: PUSH
9983: LD_INT 1
9985: ST_TO_ADDR
// KurtWaitingForFreeHeike = true ;
9986: LD_ADDR_EXP 23
9990: PUSH
9991: LD_INT 1
9993: ST_TO_ADDR
// KurtWaitingForBuildBarrack = false ;
9994: LD_ADDR_EXP 24
9998: PUSH
9999: LD_INT 0
10001: ST_TO_ADDR
// allowExitFromMap = 3 ;
10002: LD_ADDR_EXP 18
10006: PUSH
10007: LD_INT 3
10009: ST_TO_ADDR
// if KurtCanEscape then
10010: LD_EXP 21
10014: IFFALSE 10037
// ComMoveToArea ( [ Kurt , KurtEng ] , KurtExitMapArea ) ;
10016: LD_EXP 80
10020: PUSH
10021: LD_EXP 82
10025: PUSH
10026: EMPTY
10027: LIST
10028: LIST
10029: PPUSH
10030: LD_INT 11
10032: PPUSH
10033: CALL_OW 113
// end ;
10037: LD_VAR 0 1
10041: RET
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 2 ] ] ) and not dial_ArriveGensherUnitsBlocker do var veh , nearGensherUnit , maleSold , waitForKurt ;
10042: LD_INT 22
10044: PUSH
10045: LD_INT 2
10047: PUSH
10048: EMPTY
10049: LIST
10050: LIST
10051: PUSH
10052: EMPTY
10053: LIST
10054: PPUSH
10055: CALL_OW 69
10059: PUSH
10060: LD_EXP 7
10064: NOT
10065: AND
10066: IFFALSE 10839
10068: GO 10070
10070: DISABLE
10071: LD_INT 0
10073: PPUSH
10074: PPUSH
10075: PPUSH
10076: PPUSH
// begin nearGensherUnit = NearestUnitToXY ( UnitFilter ( GensherTeam , [ [ f_type , unit_vehicle ] ] ) , GensherTargetX , GensherTargetY ) ;
10077: LD_ADDR_VAR 0 2
10081: PUSH
10082: LD_EXP 83
10086: PPUSH
10087: LD_INT 21
10089: PUSH
10090: LD_INT 2
10092: PUSH
10093: EMPTY
10094: LIST
10095: LIST
10096: PUSH
10097: EMPTY
10098: LIST
10099: PPUSH
10100: CALL_OW 72
10104: PPUSH
10105: LD_EXP 16
10109: PPUSH
10110: LD_EXP 17
10114: PPUSH
10115: CALL_OW 73
10119: ST_TO_ADDR
// maleSold = UnitsInside ( nearGensherUnit [ 1 ] ) ;
10120: LD_ADDR_VAR 0 3
10124: PUSH
10125: LD_VAR 0 2
10129: PUSH
10130: LD_INT 1
10132: ARRAY
10133: PPUSH
10134: CALL_OW 313
10138: ST_TO_ADDR
// if GetDistUnitXY ( nearGensherUnit , GensherTargetX , GensherTargetY ) <= 5 then
10139: LD_VAR 0 2
10143: PPUSH
10144: LD_EXP 16
10148: PPUSH
10149: LD_EXP 17
10153: PPUSH
10154: CALL_OW 297
10158: PUSH
10159: LD_INT 5
10161: LESSEQUAL
10162: IFFALSE 10838
// begin dial_ArriveGensherUnitsBlocker = true ;
10164: LD_ADDR_EXP 7
10168: PUSH
10169: LD_INT 1
10171: ST_TO_ADDR
// for veh in UnitFilter ( GensherTeam , [ [ f_type , unit_vehicle ] ] ) do
10172: LD_ADDR_VAR 0 1
10176: PUSH
10177: LD_EXP 83
10181: PPUSH
10182: LD_INT 21
10184: PUSH
10185: LD_INT 2
10187: PUSH
10188: EMPTY
10189: LIST
10190: LIST
10191: PUSH
10192: EMPTY
10193: LIST
10194: PPUSH
10195: CALL_OW 72
10199: PUSH
10200: FOR_IN
10201: IFFALSE 10223
// ComExitVehicle ( UnitsInside ( veh ) [ 1 ] ) ;
10203: LD_VAR 0 1
10207: PPUSH
10208: CALL_OW 313
10212: PUSH
10213: LD_INT 1
10215: ARRAY
10216: PPUSH
10217: CALL_OW 121
10221: GO 10200
10223: POP
10224: POP
// wait ( 0 0$1 ) ;
10225: LD_INT 35
10227: PPUSH
10228: CALL_OW 67
// SetSide ( UnitFilter ( GensherTeam , [ [ f_type , unit_vehicle ] ] ) , 3 ) ;
10232: LD_EXP 83
10236: PPUSH
10237: LD_INT 21
10239: PUSH
10240: LD_INT 2
10242: PUSH
10243: EMPTY
10244: LIST
10245: LIST
10246: PUSH
10247: EMPTY
10248: LIST
10249: PPUSH
10250: CALL_OW 72
10254: PPUSH
10255: LD_INT 3
10257: PPUSH
10258: CALL_OW 235
// CenterOnUnits ( maleSold ) ;
10262: LD_VAR 0 3
10266: PPUSH
10267: CALL_OW 85
// DialogueOn ;
10271: CALL_OW 6
// Say ( maleSold , DHandOverCome-ASol1-1 ) ;
10275: LD_VAR 0 3
10279: PPUSH
10280: LD_STRING DHandOverCome-ASol1-1
10282: PPUSH
10283: CALL_OW 88
// Say ( Kurt , DHandOverCome-Kurt-1 ) ;
10287: LD_EXP 80
10291: PPUSH
10292: LD_STRING DHandOverCome-Kurt-1
10294: PPUSH
10295: CALL_OW 88
// DialogueOff ;
10299: CALL_OW 7
// KurtWaitingForBuildBarrack = false ;
10303: LD_ADDR_EXP 24
10307: PUSH
10308: LD_INT 0
10310: ST_TO_ADDR
// if GetDistUnits ( Kurt , UnitFilter ( GensherTeam , [ f_type , unit_vehicle ] ) [ 1 ] ) <= 8 or GetSide ( KurtEng ) = 3 then
10311: LD_EXP 80
10315: PPUSH
10316: LD_EXP 83
10320: PPUSH
10321: LD_INT 21
10323: PUSH
10324: LD_INT 2
10326: PUSH
10327: EMPTY
10328: LIST
10329: LIST
10330: PPUSH
10331: CALL_OW 72
10335: PUSH
10336: LD_INT 1
10338: ARRAY
10339: PPUSH
10340: CALL_OW 296
10344: PUSH
10345: LD_INT 8
10347: LESSEQUAL
10348: PUSH
10349: LD_EXP 82
10353: PPUSH
10354: CALL_OW 255
10358: PUSH
10359: LD_INT 3
10361: EQUAL
10362: OR
10363: IFFALSE 10468
// begin KurtCanEscape = false ;
10365: LD_ADDR_EXP 21
10369: PUSH
10370: LD_INT 0
10372: ST_TO_ADDR
// SetSide ( [ Kurt , KurtEng ] , 2 ) ;
10373: LD_EXP 80
10377: PUSH
10378: LD_EXP 82
10382: PUSH
10383: EMPTY
10384: LIST
10385: LIST
10386: PPUSH
10387: LD_INT 2
10389: PPUSH
10390: CALL_OW 235
// ComStop ( [ Kurt , KurtEng ] ) ;
10394: LD_EXP 80
10398: PUSH
10399: LD_EXP 82
10403: PUSH
10404: EMPTY
10405: LIST
10406: LIST
10407: PPUSH
10408: CALL_OW 141
// ComMoveXY ( [ Kurt , KurtEng ] , GetX ( maleSold ) , GetY ( maleSold ) ) ;
10412: LD_EXP 80
10416: PUSH
10417: LD_EXP 82
10421: PUSH
10422: EMPTY
10423: LIST
10424: LIST
10425: PPUSH
10426: LD_VAR 0 3
10430: PPUSH
10431: CALL_OW 250
10435: PPUSH
10436: LD_VAR 0 3
10440: PPUSH
10441: CALL_OW 251
10445: PPUSH
10446: CALL_OW 111
// waitForKurt = true ;
10450: LD_ADDR_VAR 0 4
10454: PUSH
10455: LD_INT 1
10457: ST_TO_ADDR
// KurtStatus = 3 ;
10458: LD_ADDR_EXP 22
10462: PUSH
10463: LD_INT 3
10465: ST_TO_ADDR
// end else
10466: GO 10706
// if GetDistUnits ( Kurt , UnitFilter ( GensherTeam , [ f_type , unit_vehicle ] ) [ 1 ] ) > 8 then
10468: LD_EXP 80
10472: PPUSH
10473: LD_EXP 83
10477: PPUSH
10478: LD_INT 21
10480: PUSH
10481: LD_INT 2
10483: PUSH
10484: EMPTY
10485: LIST
10486: LIST
10487: PPUSH
10488: CALL_OW 72
10492: PUSH
10493: LD_INT 1
10495: ARRAY
10496: PPUSH
10497: CALL_OW 296
10501: PUSH
10502: LD_INT 8
10504: GREATER
10505: IFFALSE 10706
// begin allowExitFromMap = 4 ;
10507: LD_ADDR_EXP 18
10511: PUSH
10512: LD_INT 4
10514: ST_TO_ADDR
// KurtStatus = 2 ;
10515: LD_ADDR_EXP 22
10519: PUSH
10520: LD_INT 2
10522: ST_TO_ADDR
// ComMoveToArea ( [ Kurt , KurtEng ] , KurtExitMapArea ) ;
10523: LD_EXP 80
10527: PUSH
10528: LD_EXP 82
10532: PUSH
10533: EMPTY
10534: LIST
10535: LIST
10536: PPUSH
10537: LD_INT 11
10539: PPUSH
10540: CALL_OW 113
// repeat ComAttackUnit ( UnitFilter ( GensherTeam , [ [ f_type , unit_human ] ] ) , Kurt ) ;
10544: LD_EXP 83
10548: PPUSH
10549: LD_INT 21
10551: PUSH
10552: LD_INT 1
10554: PUSH
10555: EMPTY
10556: LIST
10557: LIST
10558: PUSH
10559: EMPTY
10560: LIST
10561: PPUSH
10562: CALL_OW 72
10566: PPUSH
10567: LD_EXP 80
10571: PPUSH
10572: CALL_OW 115
// wait ( 0 0$1 ) ;
10576: LD_INT 35
10578: PPUSH
10579: CALL_OW 67
// until GetDistUnits ( NearestUnitToUnit ( UnitFilter ( GensherTeam , [ [ f_type , unit_human ] ] ) , Kurt ) , Kurt ) <= 9 or ( not IsPlaced ( Kurt ) and not IsPlaced ( KurtEng ) ) ;
10583: LD_EXP 83
10587: PPUSH
10588: LD_INT 21
10590: PUSH
10591: LD_INT 1
10593: PUSH
10594: EMPTY
10595: LIST
10596: LIST
10597: PUSH
10598: EMPTY
10599: LIST
10600: PPUSH
10601: CALL_OW 72
10605: PPUSH
10606: LD_EXP 80
10610: PPUSH
10611: CALL_OW 74
10615: PPUSH
10616: LD_EXP 80
10620: PPUSH
10621: CALL_OW 296
10625: PUSH
10626: LD_INT 9
10628: LESSEQUAL
10629: PUSH
10630: LD_EXP 80
10634: PPUSH
10635: CALL_OW 305
10639: NOT
10640: PUSH
10641: LD_EXP 82
10645: PPUSH
10646: CALL_OW 305
10650: NOT
10651: AND
10652: OR
10653: IFFALSE 10544
// ComMoveToArea ( [ Kurt , KurtEng ] , ExitMapArea ) ;
10655: LD_EXP 80
10659: PUSH
10660: LD_EXP 82
10664: PUSH
10665: EMPTY
10666: LIST
10667: LIST
10668: PPUSH
10669: LD_INT 8
10671: PPUSH
10672: CALL_OW 113
// ComMoveToArea ( UnitFilter ( GensherTeam , [ [ f_type , unit_human ] ] ) , ExitMapArea ) ;
10676: LD_EXP 83
10680: PPUSH
10681: LD_INT 21
10683: PUSH
10684: LD_INT 1
10686: PUSH
10687: EMPTY
10688: LIST
10689: LIST
10690: PUSH
10691: EMPTY
10692: LIST
10693: PPUSH
10694: CALL_OW 72
10698: PPUSH
10699: LD_INT 8
10701: PPUSH
10702: CALL_OW 113
// end ; if waitForKurt then
10706: LD_VAR 0 4
10710: IFFALSE 10836
// begin repeat wait ( 0 0$1 ) ;
10712: LD_INT 35
10714: PPUSH
10715: CALL_OW 67
// ComMoveXY ( [ Kurt , KurtEng ] , GetX ( maleSold ) , GetY ( maleSold ) ) ;
10719: LD_EXP 80
10723: PUSH
10724: LD_EXP 82
10728: PUSH
10729: EMPTY
10730: LIST
10731: LIST
10732: PPUSH
10733: LD_VAR 0 3
10737: PPUSH
10738: CALL_OW 250
10742: PPUSH
10743: LD_VAR 0 3
10747: PPUSH
10748: CALL_OW 251
10752: PPUSH
10753: CALL_OW 111
// until GetDistUnits ( Kurt , maleSold ) <= 2 ;
10757: LD_EXP 80
10761: PPUSH
10762: LD_VAR 0 3
10766: PPUSH
10767: CALL_OW 296
10771: PUSH
10772: LD_INT 2
10774: LESSEQUAL
10775: IFFALSE 10712
// allowExitFromMap = 4 ;
10777: LD_ADDR_EXP 18
10781: PUSH
10782: LD_INT 4
10784: ST_TO_ADDR
// ComMoveToArea ( [ Kurt , KurtEng ] , ExitMapArea ) ;
10785: LD_EXP 80
10789: PUSH
10790: LD_EXP 82
10794: PUSH
10795: EMPTY
10796: LIST
10797: LIST
10798: PPUSH
10799: LD_INT 8
10801: PPUSH
10802: CALL_OW 113
// ComMoveToArea ( UnitFilter ( GensherTeam , [ [ f_type , unit_human ] ] ) , ExitMapArea ) ;
10806: LD_EXP 83
10810: PPUSH
10811: LD_INT 21
10813: PUSH
10814: LD_INT 1
10816: PUSH
10817: EMPTY
10818: LIST
10819: LIST
10820: PUSH
10821: EMPTY
10822: LIST
10823: PPUSH
10824: CALL_OW 72
10828: PPUSH
10829: LD_INT 8
10831: PPUSH
10832: CALL_OW 113
// end ; exit ;
10836: GO 10839
// end ; enable ;
10838: ENABLE
// end ;
10839: PPOPN 4
10841: END
// export function Dial_AttackGensher ; var unit ; begin
10842: LD_INT 0
10844: PPUSH
10845: PPUSH
// DialogueOn ;
10846: CALL_OW 6
// SayRadio ( Dietrich , DHandOverSpoiled-Diet-1 ) ;
10850: LD_EXP 81
10854: PPUSH
10855: LD_STRING DHandOverSpoiled-Diet-1
10857: PPUSH
10858: CALL_OW 94
// DialogueOff ;
10862: CALL_OW 7
// SetAttitude ( 3 , 2 , att_enemy , true ) ;
10866: LD_INT 3
10868: PPUSH
10869: LD_INT 2
10871: PPUSH
10872: LD_INT 2
10874: PPUSH
10875: LD_INT 1
10877: PPUSH
10878: CALL_OW 80
// for unit in UnitFilter ( GensherTeam , [ [ f_type , unit_human ] ] ) do
10882: LD_ADDR_VAR 0 2
10886: PUSH
10887: LD_EXP 83
10891: PPUSH
10892: LD_INT 21
10894: PUSH
10895: LD_INT 1
10897: PUSH
10898: EMPTY
10899: LIST
10900: LIST
10901: PUSH
10902: EMPTY
10903: LIST
10904: PPUSH
10905: CALL_OW 72
10909: PUSH
10910: FOR_IN
10911: IFFALSE 10971
// begin if IsInUnit ( unit ) then
10913: LD_VAR 0 2
10917: PPUSH
10918: CALL_OW 310
10922: IFFALSE 10933
// ComExitVehicle ( unit ) ;
10924: LD_VAR 0 2
10928: PPUSH
10929: CALL_OW 121
// wait ( 0 0$01 ) ;
10933: LD_INT 35
10935: PPUSH
10936: CALL_OW 67
// AddComAgressiveMove ( unit , GetX ( Burlak ) , GetY ( Burlak ) ) ;
10940: LD_VAR 0 2
10944: PPUSH
10945: LD_EXP 57
10949: PPUSH
10950: CALL_OW 250
10954: PPUSH
10955: LD_EXP 57
10959: PPUSH
10960: CALL_OW 251
10964: PPUSH
10965: CALL_OW 174
// end ;
10969: GO 10910
10971: POP
10972: POP
// coopWithGensher = 2 ;
10973: LD_ADDR_EXP 2
10977: PUSH
10978: LD_INT 2
10980: ST_TO_ADDR
// end ;
10981: LD_VAR 0 1
10985: RET
// every 0 0$1 trigger canSendHeike and IsOK ( Heike ) and GetSide ( Heike ) = 5 do var legionSold ;
10986: LD_EXP 28
10990: PUSH
10991: LD_EXP 79
10995: PPUSH
10996: CALL_OW 302
11000: AND
11001: PUSH
11002: LD_EXP 79
11006: PPUSH
11007: CALL_OW 255
11011: PUSH
11012: LD_INT 5
11014: EQUAL
11015: AND
11016: IFFALSE 11336
11018: GO 11020
11020: DISABLE
11021: LD_INT 0
11023: PPUSH
// begin if IsSelected ( Heike ) then
11024: LD_EXP 79
11028: PPUSH
11029: CALL_OW 306
11033: IFFALSE 11328
// begin if Query ( QSendHeike ) = 1 then
11035: LD_STRING QSendHeike
11037: PPUSH
11038: CALL_OW 97
11042: PUSH
11043: LD_INT 1
11045: EQUAL
11046: IFFALSE 11328
// begin KurtWaitingForFreeHeike = false ;
11048: LD_ADDR_EXP 23
11052: PUSH
11053: LD_INT 0
11055: ST_TO_ADDR
// ComMoveXY ( Heike , 82 , 46 ) ;
11056: LD_EXP 79
11060: PPUSH
11061: LD_INT 82
11063: PPUSH
11064: LD_INT 46
11066: PPUSH
11067: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
11071: LD_INT 35
11073: PPUSH
11074: CALL_OW 67
// until GetDistUnitXY ( Heike , 82 , 46 ) <= 5 or IsDead ( Heike ) ;
11078: LD_EXP 79
11082: PPUSH
11083: LD_INT 82
11085: PPUSH
11086: LD_INT 46
11088: PPUSH
11089: CALL_OW 297
11093: PUSH
11094: LD_INT 5
11096: LESSEQUAL
11097: PUSH
11098: LD_EXP 79
11102: PPUSH
11103: CALL_OW 301
11107: OR
11108: IFFALSE 11071
// if not askCommanders then
11110: LD_EXP 20
11114: NOT
11115: IFFALSE 11161
// begin DialogueOn ;
11117: CALL_OW 6
// SayRadio ( Popov , DMercPopov-Pop-1 ) ;
11121: LD_EXP 76
11125: PPUSH
11126: LD_STRING DMercPopov-Pop-1
11128: PPUSH
11129: CALL_OW 94
// Say ( Burlak , DMercPopov-Bur-1 ) ;
11133: LD_EXP 57
11137: PPUSH
11138: LD_STRING DMercPopov-Bur-1
11140: PPUSH
11141: CALL_OW 88
// SayRadio ( Popov , DMercPopov-Pop-2 ) ;
11145: LD_EXP 76
11149: PPUSH
11150: LD_STRING DMercPopov-Pop-2
11152: PPUSH
11153: CALL_OW 94
// DialogueOff ;
11157: CALL_OW 7
// end ; uc_side = 8 ;
11161: LD_ADDR_OWVAR 20
11165: PUSH
11166: LD_INT 8
11168: ST_TO_ADDR
// uc_nation = 2 ;
11169: LD_ADDR_OWVAR 21
11173: PUSH
11174: LD_INT 2
11176: ST_TO_ADDR
// PrepareSoldier ( false , 6 ) ;
11177: LD_INT 0
11179: PPUSH
11180: LD_INT 6
11182: PPUSH
11183: CALL_OW 381
// legionSold = CreateHuman ;
11187: LD_ADDR_VAR 0 1
11191: PUSH
11192: CALL_OW 44
11196: ST_TO_ADDR
// PlaceUnitXYR ( legionSold , 26 , 48 , 4 , false ) ;
11197: LD_VAR 0 1
11201: PPUSH
11202: LD_INT 26
11204: PPUSH
11205: LD_INT 48
11207: PPUSH
11208: LD_INT 4
11210: PPUSH
11211: LD_INT 0
11213: PPUSH
11214: CALL_OW 50
// repeat wait ( 0 0$1 ) ;
11218: LD_INT 35
11220: PPUSH
11221: CALL_OW 67
// ComMoveXY ( legionSold , GetX ( Heike ) , GetY ( Heike ) ) ;
11225: LD_VAR 0 1
11229: PPUSH
11230: LD_EXP 79
11234: PPUSH
11235: CALL_OW 250
11239: PPUSH
11240: LD_EXP 79
11244: PPUSH
11245: CALL_OW 251
11249: PPUSH
11250: CALL_OW 111
// until GetDistUnits ( legionSold , Heike ) <= 5 or IsDead ( Heike ) ;
11254: LD_VAR 0 1
11258: PPUSH
11259: LD_EXP 79
11263: PPUSH
11264: CALL_OW 296
11268: PUSH
11269: LD_INT 5
11271: LESSEQUAL
11272: PUSH
11273: LD_EXP 79
11277: PPUSH
11278: CALL_OW 301
11282: OR
11283: IFFALSE 11218
// SetSide ( Heike , 8 ) ;
11285: LD_EXP 79
11289: PPUSH
11290: LD_INT 8
11292: PPUSH
11293: CALL_OW 235
// allowExitFromMap = 3 ;
11297: LD_ADDR_EXP 18
11301: PUSH
11302: LD_INT 3
11304: ST_TO_ADDR
// ComMoveToArea ( [ legionSold , Heike ] , KurtExitMapArea ) ;
11305: LD_VAR 0 1
11309: PUSH
11310: LD_EXP 79
11314: PUSH
11315: EMPTY
11316: LIST
11317: LIST
11318: PPUSH
11319: LD_INT 11
11321: PPUSH
11322: CALL_OW 113
// exit ;
11326: GO 11336
// end ; end ; wait ( 0 0$3 ) ;
11328: LD_INT 105
11330: PPUSH
11331: CALL_OW 67
// enable ;
11335: ENABLE
// end ;
11336: PPOPN 1
11338: END
// export function Dial_PlayerDontSendHeike ; begin
11339: LD_INT 0
11341: PPUSH
// DialogueOn ;
11342: CALL_OW 6
// SayRadio ( Kurt , DMercDeceived-Kurt-1 ) ;
11346: LD_EXP 80
11350: PPUSH
11351: LD_STRING DMercDeceived-Kurt-1
11353: PPUSH
11354: CALL_OW 94
// DialogueOff ;
11358: CALL_OW 7
// SetAttitude ( 3 , 8 , att_enemy , true ) ;
11362: LD_INT 3
11364: PPUSH
11365: LD_INT 8
11367: PPUSH
11368: LD_INT 2
11370: PPUSH
11371: LD_INT 1
11373: PPUSH
11374: CALL_OW 80
// KurtAttack = true ;
11378: LD_ADDR_EXP 25
11382: PUSH
11383: LD_INT 1
11385: ST_TO_ADDR
// end ;
11386: LD_VAR 0 1
11390: RET
// export function Dial_BetrayedKurt1 ; begin
11391: LD_INT 0
11393: PPUSH
// DialogueOn ;
11394: CALL_OW 6
// Say ( Kurt , DMercDeceived-Kurt-1 ) ;
11398: LD_EXP 80
11402: PPUSH
11403: LD_STRING DMercDeceived-Kurt-1
11405: PPUSH
11406: CALL_OW 88
// DialogueOff ;
11410: CALL_OW 7
// if IsPlaced ( Kurt ) then
11414: LD_EXP 80
11418: PPUSH
11419: CALL_OW 305
11423: IFFALSE 11472
// begin SetSide ( KurtEng , 8 ) ;
11425: LD_EXP 82
11429: PPUSH
11430: LD_INT 8
11432: PPUSH
11433: CALL_OW 235
// allowExitFromMap = 3 ;
11437: LD_ADDR_EXP 18
11441: PUSH
11442: LD_INT 3
11444: ST_TO_ADDR
// if KurtCanEscape then
11445: LD_EXP 21
11449: IFFALSE 11472
// ComMoveToArea ( [ Kurt , KurtEng ] , KurtExitMapArea ) ;
11451: LD_EXP 80
11455: PUSH
11456: LD_EXP 82
11460: PUSH
11461: EMPTY
11462: LIST
11463: LIST
11464: PPUSH
11465: LD_INT 11
11467: PPUSH
11468: CALL_OW 113
// end ; end ;
11472: LD_VAR 0 1
11476: RET
// export function Dial_BetrayedKurt2 ; begin
11477: LD_INT 0
11479: PPUSH
// DialogueOn ;
11480: CALL_OW 6
// Say ( Kurt , DMercAmbush-Kurt-1 ) ;
11484: LD_EXP 80
11488: PPUSH
11489: LD_STRING DMercAmbush-Kurt-1
11491: PPUSH
11492: CALL_OW 88
// DialogueOff ;
11496: CALL_OW 7
// if IsPlaced ( Kurt ) then
11500: LD_EXP 80
11504: PPUSH
11505: CALL_OW 305
11509: IFFALSE 11558
// begin SetSide ( KurtEng , 8 ) ;
11511: LD_EXP 82
11515: PPUSH
11516: LD_INT 8
11518: PPUSH
11519: CALL_OW 235
// allowExitFromMap = 3 ;
11523: LD_ADDR_EXP 18
11527: PUSH
11528: LD_INT 3
11530: ST_TO_ADDR
// if KurtCanEscape then
11531: LD_EXP 21
11535: IFFALSE 11558
// ComMoveToArea ( [ Kurt , KurtEng ] , KurtExitMapArea ) ;
11537: LD_EXP 80
11541: PUSH
11542: LD_EXP 82
11546: PUSH
11547: EMPTY
11548: LIST
11549: LIST
11550: PPUSH
11551: LD_INT 11
11553: PPUSH
11554: CALL_OW 113
// end ; end ;
11558: LD_VAR 0 1
11562: RET
// every 0 0$1 trigger GetSide ( KurtEng ) = 3 do var playerUnits , unit ;
11563: LD_EXP 82
11567: PPUSH
11568: CALL_OW 255
11572: PUSH
11573: LD_INT 3
11575: EQUAL
11576: IFFALSE 11723
11578: GO 11580
11580: DISABLE
11581: LD_INT 0
11583: PPUSH
11584: PPUSH
// begin playerUnits = FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
11585: LD_ADDR_VAR 0 1
11589: PUSH
11590: LD_INT 22
11592: PUSH
11593: LD_INT 3
11595: PUSH
11596: EMPTY
11597: LIST
11598: LIST
11599: PUSH
11600: LD_INT 2
11602: PUSH
11603: LD_INT 21
11605: PUSH
11606: LD_INT 1
11608: PUSH
11609: EMPTY
11610: LIST
11611: LIST
11612: PUSH
11613: LD_INT 21
11615: PUSH
11616: LD_INT 2
11618: PUSH
11619: EMPTY
11620: LIST
11621: LIST
11622: PUSH
11623: EMPTY
11624: LIST
11625: LIST
11626: LIST
11627: PUSH
11628: EMPTY
11629: LIST
11630: LIST
11631: PPUSH
11632: CALL_OW 69
11636: ST_TO_ADDR
// for unit in playerUnits do
11637: LD_ADDR_VAR 0 2
11641: PUSH
11642: LD_VAR 0 1
11646: PUSH
11647: FOR_IN
11648: IFFALSE 11677
// begin if WantsToAttack ( unit ) = KurtEng then
11650: LD_VAR 0 2
11654: PPUSH
11655: CALL_OW 319
11659: PUSH
11660: LD_EXP 82
11664: EQUAL
11665: IFFALSE 11675
// begin Dial_BetrayedKurt2 ;
11667: CALL 11477 0 0
// exit ;
11671: POP
11672: POP
11673: GO 11723
// end ; end ;
11675: GO 11647
11677: POP
11678: POP
// if ( IsDying ( KurtEng ) or IsDead ( KurtEng ) ) and GetSide ( KurtEng ) = 3 then
11679: LD_EXP 82
11683: PPUSH
11684: CALL_OW 303
11688: PUSH
11689: LD_EXP 82
11693: PPUSH
11694: CALL_OW 301
11698: OR
11699: PUSH
11700: LD_EXP 82
11704: PPUSH
11705: CALL_OW 255
11709: PUSH
11710: LD_INT 3
11712: EQUAL
11713: AND
11714: IFFALSE 11722
// begin Dial_BetrayedKurt2 ;
11716: CALL 11477 0 0
// exit ;
11720: GO 11723
// end ; enable ;
11722: ENABLE
// end ;
11723: PPOPN 2
11725: END
// every 0 0$1 trigger GetAttitude ( 3 , 8 ) = att_neutral and GetLives ( Kurt ) <= 999 do
11726: LD_INT 3
11728: PPUSH
11729: LD_INT 8
11731: PPUSH
11732: CALL_OW 81
11736: PUSH
11737: LD_INT 0
11739: EQUAL
11740: PUSH
11741: LD_EXP 80
11745: PPUSH
11746: CALL_OW 256
11750: PUSH
11751: LD_INT 999
11753: LESSEQUAL
11754: AND
11755: IFFALSE 11780
11757: GO 11759
11759: DISABLE
// begin Dial_BetrayedKurt1 ;
11760: CALL 11391 0 0
// SetAttitude ( 3 , 8 , att_enemy , true ) ;
11764: LD_INT 3
11766: PPUSH
11767: LD_INT 8
11769: PPUSH
11770: LD_INT 2
11772: PPUSH
11773: LD_INT 1
11775: PPUSH
11776: CALL_OW 80
// end ;
11780: END
// every 0 0$1 trigger buildingsToBuild <= 11 do
11781: LD_EXP 8
11785: PUSH
11786: LD_INT 11
11788: LESSEQUAL
11789: IFFALSE 12038
11791: GO 11793
11793: DISABLE
// begin if not IsOK ( Kuzmov ) and not IsOK ( Oblukov ) then
11794: LD_EXP 72
11798: PPUSH
11799: CALL_OW 302
11803: NOT
11804: PUSH
11805: LD_EXP 74
11809: PPUSH
11810: CALL_OW 302
11814: NOT
11815: AND
11816: IFFALSE 11820
// exit ;
11818: GO 12038
// DialogueOn ;
11820: CALL_OW 6
// if IsOK ( Kuzmov ) then
11824: LD_EXP 72
11828: PPUSH
11829: CALL_OW 302
11833: IFFALSE 11849
// Say ( Kuzmov , DFiringRange-Kuz-1 ) else
11835: LD_EXP 72
11839: PPUSH
11840: LD_STRING DFiringRange-Kuz-1
11842: PPUSH
11843: CALL_OW 88
11847: GO 11861
// Say ( Oblukov , DFiringRange-Obl-1 ) ;
11849: LD_EXP 74
11853: PPUSH
11854: LD_STRING DFiringRange-Obl-1
11856: PPUSH
11857: CALL_OW 88
// Say ( Burlak , DFiringRange-Bur-1 ) ;
11861: LD_EXP 57
11865: PPUSH
11866: LD_STRING DFiringRange-Bur-1
11868: PPUSH
11869: CALL_OW 88
// CenterOnXY ( 99 , 30 ) ;
11873: LD_INT 99
11875: PPUSH
11876: LD_INT 30
11878: PPUSH
11879: CALL_OW 84
// Wait ( 0 0$0.5 ) ;
11883: LD_INT 18
11885: PPUSH
11886: CALL_OW 67
// RevealFogArea ( 3 , ShootArea ) ;
11890: LD_INT 3
11892: PPUSH
11893: LD_INT 12
11895: PPUSH
11896: CALL_OW 332
// SetAreaMapShow ( ShootArea , 1 ) ;
11900: LD_INT 12
11902: PPUSH
11903: LD_INT 1
11905: PPUSH
11906: CALL_OW 424
// if IsOK ( Kuzmov ) then
11910: LD_EXP 72
11914: PPUSH
11915: CALL_OW 302
11919: IFFALSE 11935
// Say ( Kuzmov , DFiringRange-Kuz-2 ) else
11921: LD_EXP 72
11925: PPUSH
11926: LD_STRING DFiringRange-Kuz-2
11928: PPUSH
11929: CALL_OW 88
11933: GO 11947
// Say ( Oblukov , DFiringRange-Obl-2 ) ;
11935: LD_EXP 74
11939: PPUSH
11940: LD_STRING DFiringRange-Obl-2
11942: PPUSH
11943: CALL_OW 88
// case Query ( QShootingGallery ) of 1 :
11947: LD_STRING QShootingGallery
11949: PPUSH
11950: CALL_OW 97
11954: PUSH
11955: LD_INT 1
11957: DOUBLE
11958: EQUAL
11959: IFTRUE 11963
11961: GO 12000
11963: POP
// begin Say ( Burlak , DQrShootingGallery#1-Bur-1 ) ;
11964: LD_EXP 57
11968: PPUSH
11969: LD_STRING DQrShootingGallery#1-Bur-1
11971: PPUSH
11972: CALL_OW 88
// BurlakRespect = BurlakRespect + 1 ;
11976: LD_ADDR_EXP 30
11980: PUSH
11981: LD_EXP 30
11985: PUSH
11986: LD_INT 1
11988: PLUS
11989: ST_TO_ADDR
// canShootTrening = true ;
11990: LD_ADDR_EXP 29
11994: PUSH
11995: LD_INT 1
11997: ST_TO_ADDR
// end ; 2 :
11998: GO 12034
12000: LD_INT 2
12002: DOUBLE
12003: EQUAL
12004: IFTRUE 12008
12006: GO 12033
12008: POP
// begin Say ( Burlak , DQrShootingGallery#2-Bur-1 ) ;
12009: LD_EXP 57
12013: PPUSH
12014: LD_STRING DQrShootingGallery#2-Bur-1
12016: PPUSH
12017: CALL_OW 88
// SetAreaMapShow ( ShootArea , 0 ) ;
12021: LD_INT 12
12023: PPUSH
12024: LD_INT 0
12026: PPUSH
12027: CALL_OW 424
// end ; end ;
12031: GO 12034
12033: POP
// DialogueOff ;
12034: CALL_OW 7
// end ;
12038: END
// every 0 0$1 trigger canShootTrening do
12039: LD_EXP 29
12043: IFFALSE 12053
12045: GO 12047
12047: DISABLE
// begin enable ;
12048: ENABLE
// ShootTreningController ;
12049: CALL 7017 0 0
// end ;
12053: END
// every 0 0$1 trigger buildingsToBuild <= 7 do var hunters , hunter ;
12054: LD_EXP 8
12058: PUSH
12059: LD_INT 7
12061: LESSEQUAL
12062: IFFALSE 12452
12064: GO 12066
12066: DISABLE
12067: LD_INT 0
12069: PPUSH
12070: PPUSH
// begin hunters = [ ] ;
12071: LD_ADDR_VAR 0 1
12075: PUSH
12076: EMPTY
12077: ST_TO_ADDR
// if IsOK ( Belkov ) then
12078: LD_EXP 66
12082: PPUSH
12083: CALL_OW 302
12087: IFFALSE 12105
// hunters = hunters ^ Belkov ;
12089: LD_ADDR_VAR 0 1
12093: PUSH
12094: LD_VAR 0 1
12098: PUSH
12099: LD_EXP 66
12103: ADD
12104: ST_TO_ADDR
// if IsOK ( Karamazov ) then
12105: LD_EXP 58
12109: PPUSH
12110: CALL_OW 302
12114: IFFALSE 12132
// hunters = hunters ^ Karamazov ;
12116: LD_ADDR_VAR 0 1
12120: PUSH
12121: LD_VAR 0 1
12125: PUSH
12126: LD_EXP 58
12130: ADD
12131: ST_TO_ADDR
// if IsOK ( Kozlov ) then
12132: LD_EXP 73
12136: PPUSH
12137: CALL_OW 302
12141: IFFALSE 12159
// hunters = hunters ^ Kozlov ;
12143: LD_ADDR_VAR 0 1
12147: PUSH
12148: LD_VAR 0 1
12152: PUSH
12153: LD_EXP 73
12157: ADD
12158: ST_TO_ADDR
// if not hunters then
12159: LD_VAR 0 1
12163: NOT
12164: IFFALSE 12168
// exit ;
12166: GO 12452
// hunter = hunters [ Rand ( 1 , hunters ) ] ;
12168: LD_ADDR_VAR 0 2
12172: PUSH
12173: LD_VAR 0 1
12177: PUSH
12178: LD_INT 1
12180: PPUSH
12181: LD_VAR 0 1
12185: PPUSH
12186: CALL_OW 12
12190: ARRAY
12191: ST_TO_ADDR
// DialogueOn ;
12192: CALL_OW 6
// case hunter of Belkov :
12196: LD_VAR 0 2
12200: PUSH
12201: LD_EXP 66
12205: DOUBLE
12206: EQUAL
12207: IFTRUE 12211
12209: GO 12226
12211: POP
// Say ( Belkov , DHunting-Bel-1 ) ; Karamazov :
12212: LD_EXP 66
12216: PPUSH
12217: LD_STRING DHunting-Bel-1
12219: PPUSH
12220: CALL_OW 88
12224: GO 12277
12226: LD_EXP 58
12230: DOUBLE
12231: EQUAL
12232: IFTRUE 12236
12234: GO 12251
12236: POP
// Say ( Karamazov , DHunting-Kar-1 ) ; Kozlov :
12237: LD_EXP 58
12241: PPUSH
12242: LD_STRING DHunting-Kar-1
12244: PPUSH
12245: CALL_OW 88
12249: GO 12277
12251: LD_EXP 73
12255: DOUBLE
12256: EQUAL
12257: IFTRUE 12261
12259: GO 12276
12261: POP
// Say ( Kozlov , DHunting-Koz-1 ) ; end ;
12262: LD_EXP 73
12266: PPUSH
12267: LD_STRING DHunting-Koz-1
12269: PPUSH
12270: CALL_OW 88
12274: GO 12277
12276: POP
// Say ( Burlak , DHunting-Bur-1 ) ;
12277: LD_EXP 57
12281: PPUSH
12282: LD_STRING DHunting-Bur-1
12284: PPUSH
12285: CALL_OW 88
// case hunter of Belkov :
12289: LD_VAR 0 2
12293: PUSH
12294: LD_EXP 66
12298: DOUBLE
12299: EQUAL
12300: IFTRUE 12304
12302: GO 12319
12304: POP
// Say ( Belkov , DHunting-Bel-2 ) ; Karamazov :
12305: LD_EXP 66
12309: PPUSH
12310: LD_STRING DHunting-Bel-2
12312: PPUSH
12313: CALL_OW 88
12317: GO 12370
12319: LD_EXP 58
12323: DOUBLE
12324: EQUAL
12325: IFTRUE 12329
12327: GO 12344
12329: POP
// Say ( Karamazov , DHunting-Kar-2 ) ; Kozlov :
12330: LD_EXP 58
12334: PPUSH
12335: LD_STRING DHunting-Kar-2
12337: PPUSH
12338: CALL_OW 88
12342: GO 12370
12344: LD_EXP 73
12348: DOUBLE
12349: EQUAL
12350: IFTRUE 12354
12352: GO 12369
12354: POP
// Say ( Kozlov , DHunting-Koz-2 ) ; end ;
12355: LD_EXP 73
12359: PPUSH
12360: LD_STRING DHunting-Koz-2
12362: PPUSH
12363: CALL_OW 88
12367: GO 12370
12369: POP
// DialogueOff ;
12370: CALL_OW 7
// case Query ( QHunting ) of 1 :
12374: LD_STRING QHunting
12376: PPUSH
12377: CALL_OW 97
12381: PUSH
12382: LD_INT 1
12384: DOUBLE
12385: EQUAL
12386: IFTRUE 12390
12388: GO 12428
12390: POP
// begin Say ( Burlak , DQrHunting#1-Bur-1 ) ;
12391: LD_EXP 57
12395: PPUSH
12396: LD_STRING DQrHunting#1-Bur-1
12398: PPUSH
12399: CALL_OW 88
// BurlakRespect = BurlakRespect + 1 ;
12403: LD_ADDR_EXP 30
12407: PUSH
12408: LD_EXP 30
12412: PUSH
12413: LD_INT 1
12415: PLUS
12416: ST_TO_ADDR
// GoToHunt ( hunter ) ;
12417: LD_VAR 0 2
12421: PPUSH
12422: CALL 7645 0 1
// end ; 2 :
12426: GO 12452
12428: LD_INT 2
12430: DOUBLE
12431: EQUAL
12432: IFTRUE 12436
12434: GO 12451
12436: POP
// Say ( Burlak , DQrHunting#2-Bur-1 ) ; end ;
12437: LD_EXP 57
12441: PPUSH
12442: LD_STRING DQrHunting#2-Bur-1
12444: PPUSH
12445: CALL_OW 88
12449: GO 12452
12451: POP
// end ;
12452: PPOPN 2
12454: END
// every 0 0$1 trigger buildingsToBuild <= 3 do var unit , womans , men , woman , man , depots ;
12455: LD_EXP 8
12459: PUSH
12460: LD_INT 3
12462: LESSEQUAL
12463: IFFALSE 13450
12465: GO 12467
12467: DISABLE
12468: LD_INT 0
12470: PPUSH
12471: PPUSH
12472: PPUSH
12473: PPUSH
12474: PPUSH
12475: PPUSH
// begin womans = [ ] ;
12476: LD_ADDR_VAR 0 2
12480: PUSH
12481: EMPTY
12482: ST_TO_ADDR
// men = [ ] ;
12483: LD_ADDR_VAR 0 3
12487: PUSH
12488: EMPTY
12489: ST_TO_ADDR
// if IsOK ( Petrovova ) then
12490: LD_EXP 59
12494: PPUSH
12495: CALL_OW 302
12499: IFFALSE 12517
// womans = womans ^ Petrovova ;
12501: LD_ADDR_VAR 0 2
12505: PUSH
12506: LD_VAR 0 2
12510: PUSH
12511: LD_EXP 59
12515: ADD
12516: ST_TO_ADDR
// if IsOK ( Kirilenkova ) then
12517: LD_EXP 65
12521: PPUSH
12522: CALL_OW 302
12526: IFFALSE 12544
// womans = womans ^ Kirilenkova ;
12528: LD_ADDR_VAR 0 2
12532: PUSH
12533: LD_VAR 0 2
12537: PUSH
12538: LD_EXP 65
12542: ADD
12543: ST_TO_ADDR
// if IsOK ( Kapitsova ) then
12544: LD_EXP 75
12548: PPUSH
12549: CALL_OW 302
12553: IFFALSE 12571
// womans = womans ^ Kapitsova ;
12555: LD_ADDR_VAR 0 2
12559: PUSH
12560: LD_VAR 0 2
12564: PUSH
12565: LD_EXP 75
12569: ADD
12570: ST_TO_ADDR
// DialogueOn ;
12571: CALL_OW 6
// if womans then
12575: LD_VAR 0 2
12579: IFFALSE 12706
// begin case womans [ Rand ( 1 , womans ) ] of Petrovova :
12581: LD_VAR 0 2
12585: PUSH
12586: LD_INT 1
12588: PPUSH
12589: LD_VAR 0 2
12593: PPUSH
12594: CALL_OW 12
12598: ARRAY
12599: PUSH
12600: LD_EXP 59
12604: DOUBLE
12605: EQUAL
12606: IFTRUE 12610
12608: GO 12635
12610: POP
// begin Say ( Petrovova , DFreeTime-Ptr-1 ) ;
12611: LD_EXP 59
12615: PPUSH
12616: LD_STRING DFreeTime-Ptr-1
12618: PPUSH
12619: CALL_OW 88
// woman = Petrovova ;
12623: LD_ADDR_VAR 0 4
12627: PUSH
12628: LD_EXP 59
12632: ST_TO_ADDR
// end ; Kirilenkova :
12633: GO 12706
12635: LD_EXP 65
12639: DOUBLE
12640: EQUAL
12641: IFTRUE 12645
12643: GO 12670
12645: POP
// begin Say ( Kirilenkova , DFreeTime-Kir-1 ) ;
12646: LD_EXP 65
12650: PPUSH
12651: LD_STRING DFreeTime-Kir-1
12653: PPUSH
12654: CALL_OW 88
// woman = Kirilenkova ;
12658: LD_ADDR_VAR 0 4
12662: PUSH
12663: LD_EXP 65
12667: ST_TO_ADDR
// end ; Kapitsova :
12668: GO 12706
12670: LD_EXP 75
12674: DOUBLE
12675: EQUAL
12676: IFTRUE 12680
12678: GO 12705
12680: POP
// begin Say ( Kapitsova , DFreeTime-Kap-1 ) ;
12681: LD_EXP 75
12685: PPUSH
12686: LD_STRING DFreeTime-Kap-1
12688: PPUSH
12689: CALL_OW 88
// woman = Kapitsova ;
12693: LD_ADDR_VAR 0 4
12697: PUSH
12698: LD_EXP 75
12702: ST_TO_ADDR
// end ; end ;
12703: GO 12706
12705: POP
// end ; if IsOK ( Kuzmov ) then
12706: LD_EXP 72
12710: PPUSH
12711: CALL_OW 302
12715: IFFALSE 12733
// men = men ^ Kuzmov ;
12717: LD_ADDR_VAR 0 3
12721: PUSH
12722: LD_VAR 0 3
12726: PUSH
12727: LD_EXP 72
12731: ADD
12732: ST_TO_ADDR
// if IsOK ( Titov ) then
12733: LD_EXP 62
12737: PPUSH
12738: CALL_OW 302
12742: IFFALSE 12760
// men = men ^ Titov ;
12744: LD_ADDR_VAR 0 3
12748: PUSH
12749: LD_VAR 0 3
12753: PUSH
12754: LD_EXP 62
12758: ADD
12759: ST_TO_ADDR
// if IsOK ( Gnyevko ) then
12760: LD_EXP 69
12764: PPUSH
12765: CALL_OW 302
12769: IFFALSE 12787
// men = men ^ Gnyevko ;
12771: LD_ADDR_VAR 0 3
12775: PUSH
12776: LD_VAR 0 3
12780: PUSH
12781: LD_EXP 69
12785: ADD
12786: ST_TO_ADDR
// if IsOK ( Oblukov ) then
12787: LD_EXP 74
12791: PPUSH
12792: CALL_OW 302
12796: IFFALSE 12814
// men = men ^ Oblukov ;
12798: LD_ADDR_VAR 0 3
12802: PUSH
12803: LD_VAR 0 3
12807: PUSH
12808: LD_EXP 74
12812: ADD
12813: ST_TO_ADDR
// if men then
12814: LD_VAR 0 3
12818: IFFALSE 12980
// begin case men [ Rand ( 1 , men ) ] of Kuzmov :
12820: LD_VAR 0 3
12824: PUSH
12825: LD_INT 1
12827: PPUSH
12828: LD_VAR 0 3
12832: PPUSH
12833: CALL_OW 12
12837: ARRAY
12838: PUSH
12839: LD_EXP 72
12843: DOUBLE
12844: EQUAL
12845: IFTRUE 12849
12847: GO 12874
12849: POP
// begin Say ( Kuzmov , DFreeTime-Kuz-1 ) ;
12850: LD_EXP 72
12854: PPUSH
12855: LD_STRING DFreeTime-Kuz-1
12857: PPUSH
12858: CALL_OW 88
// man = Kuzmov ;
12862: LD_ADDR_VAR 0 5
12866: PUSH
12867: LD_EXP 72
12871: ST_TO_ADDR
// end ; Titov :
12872: GO 12980
12874: LD_EXP 62
12878: DOUBLE
12879: EQUAL
12880: IFTRUE 12884
12882: GO 12909
12884: POP
// begin Say ( Titov , DFreeTime-Tit-1 ) ;
12885: LD_EXP 62
12889: PPUSH
12890: LD_STRING DFreeTime-Tit-1
12892: PPUSH
12893: CALL_OW 88
// man = Titov ;
12897: LD_ADDR_VAR 0 5
12901: PUSH
12902: LD_EXP 62
12906: ST_TO_ADDR
// end ; Gnyevko :
12907: GO 12980
12909: LD_EXP 69
12913: DOUBLE
12914: EQUAL
12915: IFTRUE 12919
12917: GO 12944
12919: POP
// begin Say ( Gnyevko , DFreeTime-Gny-1 ) ;
12920: LD_EXP 69
12924: PPUSH
12925: LD_STRING DFreeTime-Gny-1
12927: PPUSH
12928: CALL_OW 88
// man = Gnyevko ;
12932: LD_ADDR_VAR 0 5
12936: PUSH
12937: LD_EXP 69
12941: ST_TO_ADDR
// end ; Oblukov :
12942: GO 12980
12944: LD_EXP 74
12948: DOUBLE
12949: EQUAL
12950: IFTRUE 12954
12952: GO 12979
12954: POP
// begin Say ( Oblukov , DFreeTime-Obl-1 ) ;
12955: LD_EXP 74
12959: PPUSH
12960: LD_STRING DFreeTime-Obl-1
12962: PPUSH
12963: CALL_OW 88
// man = Oblukov ;
12967: LD_ADDR_VAR 0 5
12971: PUSH
12972: LD_EXP 74
12976: ST_TO_ADDR
// end ; end ;
12977: GO 12980
12979: POP
// end ; DialogueOff ;
12980: CALL_OW 7
// if not woman and not man then
12984: LD_VAR 0 4
12988: NOT
12989: PUSH
12990: LD_VAR 0 5
12994: NOT
12995: AND
12996: IFFALSE 13004
// begin DialogueOff ;
12998: CALL_OW 7
// exit ;
13002: GO 13450
// end ; case Query ( QFreeTime ) of 1 :
13004: LD_STRING QFreeTime
13006: PPUSH
13007: CALL_OW 97
13011: PUSH
13012: LD_INT 1
13014: DOUBLE
13015: EQUAL
13016: IFTRUE 13020
13018: GO 13422
13020: POP
// begin Say ( Burlak , DQrFreeTime#1-Bur-1 ) ;
13021: LD_EXP 57
13025: PPUSH
13026: LD_STRING DQrFreeTime#1-Bur-1
13028: PPUSH
13029: CALL_OW 88
// DialogueOff ;
13033: CALL_OW 7
// BurlakRespect = BurlakRespect + 1 ;
13037: LD_ADDR_EXP 30
13041: PUSH
13042: LD_EXP 30
13046: PUSH
13047: LD_INT 1
13049: PLUS
13050: ST_TO_ADDR
// SetSide ( [ woman , man ] , 6 ) ;
13051: LD_VAR 0 4
13055: PUSH
13056: LD_VAR 0 5
13060: PUSH
13061: EMPTY
13062: LIST
13063: LIST
13064: PPUSH
13065: LD_INT 6
13067: PPUSH
13068: CALL_OW 235
// for unit in [ woman , man ] do
13072: LD_ADDR_VAR 0 1
13076: PUSH
13077: LD_VAR 0 4
13081: PUSH
13082: LD_VAR 0 5
13086: PUSH
13087: EMPTY
13088: LIST
13089: LIST
13090: PUSH
13091: FOR_IN
13092: IFFALSE 13147
// if IsInUnit ( unit ) then
13094: LD_VAR 0 1
13098: PPUSH
13099: CALL_OW 310
13103: IFFALSE 13145
// begin if GetType ( IsInUnit ( unit ) ) = unit_vehicle then
13105: LD_VAR 0 1
13109: PPUSH
13110: CALL_OW 310
13114: PPUSH
13115: CALL_OW 247
13119: PUSH
13120: LD_INT 2
13122: EQUAL
13123: IFFALSE 13136
// ComExitVehicle ( unit ) else
13125: LD_VAR 0 1
13129: PPUSH
13130: CALL_OW 121
13134: GO 13145
// ComExitBuilding ( unit ) ;
13136: LD_VAR 0 1
13140: PPUSH
13141: CALL_OW 122
// end ;
13145: GO 13091
13147: POP
13148: POP
// wait ( 0 0$1 ) ;
13149: LD_INT 35
13151: PPUSH
13152: CALL_OW 67
// ComMoveToArea ( [ woman , man ] , ExitMapArea ) ;
13156: LD_VAR 0 4
13160: PUSH
13161: LD_VAR 0 5
13165: PUSH
13166: EMPTY
13167: LIST
13168: LIST
13169: PPUSH
13170: LD_INT 8
13172: PPUSH
13173: CALL_OW 113
// allowExitFromMap = 1 ;
13177: LD_ADDR_EXP 18
13181: PUSH
13182: LD_INT 1
13184: ST_TO_ADDR
// wait ( 3 3$0 ) ;
13185: LD_INT 6300
13187: PPUSH
13188: CALL_OW 67
// PlaceUnitXYR ( woman , 157 , 29 , 3 , false ) ;
13192: LD_VAR 0 4
13196: PPUSH
13197: LD_INT 157
13199: PPUSH
13200: LD_INT 29
13202: PPUSH
13203: LD_INT 3
13205: PPUSH
13206: LD_INT 0
13208: PPUSH
13209: CALL_OW 50
// PlaceUnitXYR ( man , 157 , 29 , 3 , false ) ;
13213: LD_VAR 0 5
13217: PPUSH
13218: LD_INT 157
13220: PPUSH
13221: LD_INT 29
13223: PPUSH
13224: LD_INT 3
13226: PPUSH
13227: LD_INT 0
13229: PPUSH
13230: CALL_OW 50
// SetSide ( [ woman , man ] , 3 ) ;
13234: LD_VAR 0 4
13238: PUSH
13239: LD_VAR 0 5
13243: PUSH
13244: EMPTY
13245: LIST
13246: LIST
13247: PPUSH
13248: LD_INT 3
13250: PPUSH
13251: CALL_OW 235
// depots = FilterAllUnits ( [ [ f_side , 3 ] , [ [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ] ) ;
13255: LD_ADDR_VAR 0 6
13259: PUSH
13260: LD_INT 22
13262: PUSH
13263: LD_INT 3
13265: PUSH
13266: EMPTY
13267: LIST
13268: LIST
13269: PUSH
13270: LD_INT 2
13272: PUSH
13273: LD_INT 30
13275: PUSH
13276: LD_INT 0
13278: PUSH
13279: EMPTY
13280: LIST
13281: LIST
13282: PUSH
13283: LD_INT 30
13285: PUSH
13286: LD_INT 1
13288: PUSH
13289: EMPTY
13290: LIST
13291: LIST
13292: PUSH
13293: EMPTY
13294: LIST
13295: LIST
13296: LIST
13297: PUSH
13298: EMPTY
13299: LIST
13300: PUSH
13301: EMPTY
13302: LIST
13303: LIST
13304: PPUSH
13305: CALL_OW 69
13309: ST_TO_ADDR
// if depots then
13310: LD_VAR 0 6
13314: IFFALSE 13364
// ComMoveXY ( [ woman , man ] , GetX ( depots [ 1 ] ) , GetY ( depots [ 1 ] ) ) else
13316: LD_VAR 0 4
13320: PUSH
13321: LD_VAR 0 5
13325: PUSH
13326: EMPTY
13327: LIST
13328: LIST
13329: PPUSH
13330: LD_VAR 0 6
13334: PUSH
13335: LD_INT 1
13337: ARRAY
13338: PPUSH
13339: CALL_OW 250
13343: PPUSH
13344: LD_VAR 0 6
13348: PUSH
13349: LD_INT 1
13351: ARRAY
13352: PPUSH
13353: CALL_OW 251
13357: PPUSH
13358: CALL_OW 111
13362: GO 13402
// ComMoveXY ( [ woman , man ] , GetX ( Burlak ) , GetY ( Burlak ) ) ;
13364: LD_VAR 0 4
13368: PUSH
13369: LD_VAR 0 5
13373: PUSH
13374: EMPTY
13375: LIST
13376: LIST
13377: PPUSH
13378: LD_EXP 57
13382: PPUSH
13383: CALL_OW 250
13387: PPUSH
13388: LD_EXP 57
13392: PPUSH
13393: CALL_OW 251
13397: PPUSH
13398: CALL_OW 111
// CenterOnUnits ( [ woman , man ] ) ;
13402: LD_VAR 0 4
13406: PUSH
13407: LD_VAR 0 5
13411: PUSH
13412: EMPTY
13413: LIST
13414: LIST
13415: PPUSH
13416: CALL_OW 85
// end ; 2 :
13420: GO 13446
13422: LD_INT 2
13424: DOUBLE
13425: EQUAL
13426: IFTRUE 13430
13428: GO 13445
13430: POP
// Say ( Burlak , DQrFreeTime#2-Bur-1 ) ; end ;
13431: LD_EXP 57
13435: PPUSH
13436: LD_STRING DQrFreeTime#2-Bur-1
13438: PPUSH
13439: CALL_OW 88
13443: GO 13446
13445: POP
// DialogueOff ;
13446: CALL_OW 7
// end ;
13450: PPOPN 6
13452: END
// every 0 0$1 trigger GetAmountWeaponsDataBuildOnVehicle ( false ) <= 2 do
13453: LD_INT 0
13455: PPUSH
13456: CALL 6726 0 1
13460: PUSH
13461: LD_INT 2
13463: LESSEQUAL
13464: IFFALSE 13599
13466: GO 13468
13468: DISABLE
// begin DialogueOn ;
13469: CALL_OW 6
// if IsOK ( Kozlov ) then
13473: LD_EXP 73
13477: PPUSH
13478: CALL_OW 302
13482: IFFALSE 13498
// Say ( Kozlov , DMasha-Koz-1 ) else
13484: LD_EXP 73
13488: PPUSH
13489: LD_STRING DMasha-Koz-1
13491: PPUSH
13492: CALL_OW 88
13496: GO 13561
// DialogRandom ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_ok ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) , DMasha-Koz-1 ,  , false , false ) ;
13498: LD_INT 22
13500: PUSH
13501: LD_INT 3
13503: PUSH
13504: EMPTY
13505: LIST
13506: LIST
13507: PUSH
13508: LD_INT 50
13510: PUSH
13511: EMPTY
13512: LIST
13513: PUSH
13514: LD_INT 21
13516: PUSH
13517: LD_INT 1
13519: PUSH
13520: EMPTY
13521: LIST
13522: LIST
13523: PUSH
13524: LD_INT 26
13526: PUSH
13527: LD_INT 1
13529: PUSH
13530: EMPTY
13531: LIST
13532: LIST
13533: PUSH
13534: EMPTY
13535: LIST
13536: LIST
13537: LIST
13538: LIST
13539: PPUSH
13540: CALL_OW 69
13544: PPUSH
13545: LD_STRING DMasha-Koz-1
13547: PPUSH
13548: LD_STRING 
13550: PPUSH
13551: LD_INT 0
13553: PPUSH
13554: LD_INT 0
13556: PPUSH
13557: CALL 6175 0 5
// Say ( Burlak , DMasha2-Bur-1 ) ;
13561: LD_EXP 57
13565: PPUSH
13566: LD_STRING DMasha2-Bur-1
13568: PPUSH
13569: CALL_OW 88
// DialogueOff ;
13573: CALL_OW 7
// Query ( QMasha ) ;
13577: LD_STRING QMasha
13579: PPUSH
13580: CALL_OW 97
// ChangeMissionObjectives ( MMasha ) ;
13584: LD_STRING MMasha
13586: PPUSH
13587: CALL_OW 337
// canChooseMashaVehicle = true ;
13591: LD_ADDR_EXP 36
13595: PUSH
13596: LD_INT 1
13598: ST_TO_ADDR
// end ;
13599: END
// export function Dial_ComputerTechResearched ; begin
13600: LD_INT 0
13602: PPUSH
// if IsOk ( Scholtze ) or IsOK ( Kapitsova ) then
13603: LD_EXP 71
13607: PPUSH
13608: CALL_OW 302
13612: PUSH
13613: LD_EXP 75
13617: PPUSH
13618: CALL_OW 302
13622: OR
13623: IFFALSE 13719
// begin DialogueOn ;
13625: CALL_OW 6
// if IsOK ( Scholtze ) then
13629: LD_EXP 71
13633: PPUSH
13634: CALL_OW 302
13638: IFFALSE 13654
// Say ( Scholtze , DAI-Sch-1 ) else
13640: LD_EXP 71
13644: PPUSH
13645: LD_STRING DAI-Sch-1
13647: PPUSH
13648: CALL_OW 88
13652: GO 13666
// Say ( Kapitsova , DAI-Kap-1 ) ;
13654: LD_EXP 75
13658: PPUSH
13659: LD_STRING DAI-Kap-1
13661: PPUSH
13662: CALL_OW 88
// Say ( Burlak , DAI-Bur-1 ) ;
13666: LD_EXP 57
13670: PPUSH
13671: LD_STRING DAI-Bur-1
13673: PPUSH
13674: CALL_OW 88
// if IsOK ( Scholtze ) then
13678: LD_EXP 71
13682: PPUSH
13683: CALL_OW 302
13687: IFFALSE 13703
// Say ( Scholtze , DAI-Sch-2 ) else
13689: LD_EXP 71
13693: PPUSH
13694: LD_STRING DAI-Sch-2
13696: PPUSH
13697: CALL_OW 88
13701: GO 13715
// Say ( Kapitsova , DAI-Kap-2 ) ;
13703: LD_EXP 75
13707: PPUSH
13708: LD_STRING DAI-Kap-2
13710: PPUSH
13711: CALL_OW 88
// DialogueOff ;
13715: CALL_OW 7
// end ; ChangeMissionObjectives ( MAI ) ;
13719: LD_STRING MAI
13721: PPUSH
13722: CALL_OW 337
// end ;
13726: LD_VAR 0 1
13730: RET
// export function Dial_TeleportTechResearched ; begin
13731: LD_INT 0
13733: PPUSH
// if IsOk ( Scholtze ) or IsOK ( Kapitsova ) then
13734: LD_EXP 71
13738: PPUSH
13739: CALL_OW 302
13743: PUSH
13744: LD_EXP 75
13748: PPUSH
13749: CALL_OW 302
13753: OR
13754: IFFALSE 13862
// begin DialogueOn ;
13756: CALL_OW 6
// if IsOK ( Scholtze ) then
13760: LD_EXP 71
13764: PPUSH
13765: CALL_OW 302
13769: IFFALSE 13785
// Say ( Scholtze , DSpontTelep-Sch-1 ) else
13771: LD_EXP 71
13775: PPUSH
13776: LD_STRING DSpontTelep-Sch-1
13778: PPUSH
13779: CALL_OW 88
13783: GO 13797
// Say ( Kapitsova , DSpontTelep-Kap-1 ) ;
13785: LD_EXP 75
13789: PPUSH
13790: LD_STRING DSpontTelep-Kap-1
13792: PPUSH
13793: CALL_OW 88
// Say ( Burlak , DSpontTelep-Bur-1 ) ;
13797: LD_EXP 57
13801: PPUSH
13802: LD_STRING DSpontTelep-Bur-1
13804: PPUSH
13805: CALL_OW 88
// if IsOK ( Scholtze ) then
13809: LD_EXP 71
13813: PPUSH
13814: CALL_OW 302
13818: IFFALSE 13834
// Say ( Scholtze , DSpontTelep-Sch-2 ) else
13820: LD_EXP 71
13824: PPUSH
13825: LD_STRING DSpontTelep-Sch-2
13827: PPUSH
13828: CALL_OW 88
13832: GO 13846
// Say ( Kapitsova , DSpontTelep-Kap-2 ) ;
13834: LD_EXP 75
13838: PPUSH
13839: LD_STRING DSpontTelep-Kap-2
13841: PPUSH
13842: CALL_OW 88
// Say ( Burlak , DSpontTelep-Bur-2 ) ;
13846: LD_EXP 57
13850: PPUSH
13851: LD_STRING DSpontTelep-Bur-2
13853: PPUSH
13854: CALL_OW 88
// DialogueOff ;
13858: CALL_OW 7
// end ; ChangeMissionObjectives ( MTele ) ;
13862: LD_STRING MTele
13864: PPUSH
13865: CALL_OW 337
// end ;
13869: LD_VAR 0 1
13873: RET
// every 0 0$1 trigger buildingsToBuild <= 3 and GetAmountWeaponsDataBuildOnVehicle ( false ) <= 1 and techsToResearch <= 4 do
13874: LD_EXP 8
13878: PUSH
13879: LD_INT 3
13881: LESSEQUAL
13882: PUSH
13883: LD_INT 0
13885: PPUSH
13886: CALL 6726 0 1
13890: PUSH
13891: LD_INT 1
13893: LESSEQUAL
13894: AND
13895: PUSH
13896: LD_EXP 9
13900: PUSH
13901: LD_INT 4
13903: LESSEQUAL
13904: AND
13905: IFFALSE 14106
13907: GO 13909
13909: DISABLE
// begin SayRadio ( Popov , DAmAttackStart-Pop-1 ) ;
13910: LD_EXP 76
13914: PPUSH
13915: LD_STRING DAmAttackStart-Pop-1
13917: PPUSH
13918: CALL_OW 94
// if KurtStatus = 1 and HeikeStatus = 1 then
13922: LD_EXP 22
13926: PUSH
13927: LD_INT 1
13929: EQUAL
13930: PUSH
13931: LD_EXP 3
13935: PUSH
13936: LD_INT 1
13938: EQUAL
13939: AND
13940: IFFALSE 14098
// begin wait ( 0 0$10 ) ;
13942: LD_INT 350
13944: PPUSH
13945: CALL_OW 67
// DialogueOn ;
13949: CALL_OW 6
// SayRadio ( Heike , DLegionFormed-Hke-1 ) ;
13953: LD_EXP 79
13957: PPUSH
13958: LD_STRING DLegionFormed-Hke-1
13960: PPUSH
13961: CALL_OW 94
// Say ( Burlak , DLegionFormed-Bur-1 ) ;
13965: LD_EXP 57
13969: PPUSH
13970: LD_STRING DLegionFormed-Bur-1
13972: PPUSH
13973: CALL_OW 88
// SayRadio ( Heike , DLegionFormed-Hke-2 ) ;
13977: LD_EXP 79
13981: PPUSH
13982: LD_STRING DLegionFormed-Hke-2
13984: PPUSH
13985: CALL_OW 94
// Say ( Burlak , DLegionFormed-Bur-2 ) ;
13989: LD_EXP 57
13993: PPUSH
13994: LD_STRING DLegionFormed-Bur-2
13996: PPUSH
13997: CALL_OW 88
// SayRadio ( Heike , DLegionFormed-Hke-3 ) ;
14001: LD_EXP 79
14005: PPUSH
14006: LD_STRING DLegionFormed-Hke-3
14008: PPUSH
14009: CALL_OW 94
// case Query ( QLegion ) of 1 :
14013: LD_STRING QLegion
14015: PPUSH
14016: CALL_OW 97
14020: PUSH
14021: LD_INT 1
14023: DOUBLE
14024: EQUAL
14025: IFTRUE 14029
14027: GO 14060
14029: POP
// begin acceptLegionOffert = true ;
14030: LD_ADDR_EXP 31
14034: PUSH
14035: LD_INT 1
14037: ST_TO_ADDR
// legionOffertCountdown = true ;
14038: LD_ADDR_EXP 33
14042: PUSH
14043: LD_INT 1
14045: ST_TO_ADDR
// Say ( Burlak , DQrLegion#1-Bur-1 ) ;
14046: LD_EXP 57
14050: PPUSH
14051: LD_STRING DQrLegion#1-Bur-1
14053: PPUSH
14054: CALL_OW 88
// end ; 2 :
14058: GO 14092
14060: LD_INT 2
14062: DOUBLE
14063: EQUAL
14064: IFTRUE 14068
14066: GO 14091
14068: POP
// begin Say ( Burlak , DQrLegion#2-Bur-1 ) ;
14069: LD_EXP 57
14073: PPUSH
14074: LD_STRING DQrLegion#2-Bur-1
14076: PPUSH
14077: CALL_OW 88
// americansAttack = true ;
14081: LD_ADDR_EXP 26
14085: PUSH
14086: LD_INT 1
14088: ST_TO_ADDR
// end ; end ;
14089: GO 14092
14091: POP
// DialogueOff ;
14092: CALL_OW 7
// end else
14096: GO 14106
// begin americansAttack = true ;
14098: LD_ADDR_EXP 26
14102: PUSH
14103: LD_INT 1
14105: ST_TO_ADDR
// end ; end ;
14106: END
// every 0 0$1 trigger legionOffertTime <= 0 0$00 do
14107: LD_EXP 34
14111: PUSH
14112: LD_INT 0
14114: LESSEQUAL
14115: IFFALSE 14136
14117: GO 14119
14119: DISABLE
// begin legionOffertCountdown = false ;
14120: LD_ADDR_EXP 33
14124: PUSH
14125: LD_INT 0
14127: ST_TO_ADDR
// americansAttack = true ;
14128: LD_ADDR_EXP 26
14132: PUSH
14133: LD_INT 1
14135: ST_TO_ADDR
// end ;
14136: END
// every 0 0$1 trigger legionOffertCountdown do var needCrates , depots , depot , crates ;
14137: LD_EXP 33
14141: IFFALSE 14327
14143: GO 14145
14145: DISABLE
14146: LD_INT 0
14148: PPUSH
14149: PPUSH
14150: PPUSH
14151: PPUSH
// begin needCrates = 50 ;
14152: LD_ADDR_VAR 0 1
14156: PUSH
14157: LD_INT 50
14159: ST_TO_ADDR
// crates = 0 ;
14160: LD_ADDR_VAR 0 4
14164: PUSH
14165: LD_INT 0
14167: ST_TO_ADDR
// depots = FilterAllUnits ( [ [ f_side , 3 ] , [ [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ] ) ;
14168: LD_ADDR_VAR 0 2
14172: PUSH
14173: LD_INT 22
14175: PUSH
14176: LD_INT 3
14178: PUSH
14179: EMPTY
14180: LIST
14181: LIST
14182: PUSH
14183: LD_INT 2
14185: PUSH
14186: LD_INT 30
14188: PUSH
14189: LD_INT 0
14191: PUSH
14192: EMPTY
14193: LIST
14194: LIST
14195: PUSH
14196: LD_INT 30
14198: PUSH
14199: LD_INT 1
14201: PUSH
14202: EMPTY
14203: LIST
14204: LIST
14205: PUSH
14206: EMPTY
14207: LIST
14208: LIST
14209: LIST
14210: PUSH
14211: EMPTY
14212: LIST
14213: PUSH
14214: EMPTY
14215: LIST
14216: LIST
14217: PPUSH
14218: CALL_OW 69
14222: ST_TO_ADDR
// for depot in depots do
14223: LD_ADDR_VAR 0 3
14227: PUSH
14228: LD_VAR 0 2
14232: PUSH
14233: FOR_IN
14234: IFFALSE 14325
// begin crates = GetResourceType ( GetBase ( depot ) , mat_cans ) ;
14236: LD_ADDR_VAR 0 4
14240: PUSH
14241: LD_VAR 0 3
14245: PPUSH
14246: CALL_OW 274
14250: PPUSH
14251: LD_INT 1
14253: PPUSH
14254: CALL_OW 275
14258: ST_TO_ADDR
// if crates >= needCrates then
14259: LD_VAR 0 4
14263: PUSH
14264: LD_VAR 0 1
14268: GREATEREQUAL
14269: IFFALSE 14323
// begin SetResourceType ( GetBase ( depot ) , mat_cans , crates - needCrates ) ;
14271: LD_VAR 0 3
14275: PPUSH
14276: CALL_OW 274
14280: PPUSH
14281: LD_INT 1
14283: PPUSH
14284: LD_VAR 0 4
14288: PUSH
14289: LD_VAR 0 1
14293: MINUS
14294: PPUSH
14295: CALL_OW 277
// legionOffertCountdown = false ;
14299: LD_ADDR_EXP 33
14303: PUSH
14304: LD_INT 0
14306: ST_TO_ADDR
// paidLegionOffert = true ;
14307: LD_ADDR_EXP 32
14311: PUSH
14312: LD_INT 1
14314: ST_TO_ADDR
// americansAttack = true ;
14315: LD_ADDR_EXP 26
14319: PUSH
14320: LD_INT 1
14322: ST_TO_ADDR
// end ; end ;
14323: GO 14233
14325: POP
14326: POP
// end ;
14327: PPOPN 4
14329: END
// every 0 0$1 trigger currentAmWave >= americansAttackWaves and FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_type , unit_human ] , [ f_and , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ] ] ) = 0 do
14330: LD_EXP 85
14334: PUSH
14335: LD_EXP 48
14339: GREATEREQUAL
14340: PUSH
14341: LD_INT 22
14343: PUSH
14344: LD_INT 1
14346: PUSH
14347: EMPTY
14348: LIST
14349: LIST
14350: PUSH
14351: LD_INT 2
14353: PUSH
14354: LD_INT 21
14356: PUSH
14357: LD_INT 1
14359: PUSH
14360: EMPTY
14361: LIST
14362: LIST
14363: PUSH
14364: LD_INT 1
14366: PUSH
14367: LD_INT 21
14369: PUSH
14370: LD_INT 2
14372: PUSH
14373: EMPTY
14374: LIST
14375: LIST
14376: PUSH
14377: LD_INT 33
14379: PUSH
14380: LD_INT 3
14382: PUSH
14383: EMPTY
14384: LIST
14385: LIST
14386: PUSH
14387: EMPTY
14388: LIST
14389: LIST
14390: LIST
14391: PUSH
14392: EMPTY
14393: LIST
14394: LIST
14395: LIST
14396: PUSH
14397: EMPTY
14398: LIST
14399: LIST
14400: PPUSH
14401: CALL_OW 69
14405: PUSH
14406: LD_INT 0
14408: EQUAL
14409: AND
14410: IFFALSE 14610
14412: GO 14414
14414: DISABLE
// begin DialogueOn ;
14415: CALL_OW 6
// if IsOK ( Belkov ) then
14419: LD_EXP 66
14423: PPUSH
14424: CALL_OW 302
14428: IFFALSE 14444
// Say ( Belkov , DAmAttackFin-Bel-1 ) else
14430: LD_EXP 66
14434: PPUSH
14435: LD_STRING DAmAttackFin-Bel-1
14437: PPUSH
14438: CALL_OW 88
14442: GO 14467
// if IsOK ( Belkov2 ) then
14444: LD_EXP 67
14448: PPUSH
14449: CALL_OW 302
14453: IFFALSE 14467
// Say ( Belkov2 , DAmAttackFin-Bel-1 ) ;
14455: LD_EXP 67
14459: PPUSH
14460: LD_STRING DAmAttackFin-Bel-1
14462: PPUSH
14463: CALL_OW 88
// if IsOK ( Gnyevko ) then
14467: LD_EXP 69
14471: PPUSH
14472: CALL_OW 302
14476: IFFALSE 14490
// Say ( Gnyevko , DAmAttackFin-Gny-1 ) ;
14478: LD_EXP 69
14482: PPUSH
14483: LD_STRING DAmAttackFin-Gny-1
14485: PPUSH
14486: CALL_OW 88
// if IsOK ( Titov ) then
14490: LD_EXP 62
14494: PPUSH
14495: CALL_OW 302
14499: IFFALSE 14513
// Say ( Titov , DAmAttackFin-Tit-1 ) ;
14501: LD_EXP 62
14505: PPUSH
14506: LD_STRING DAmAttackFin-Tit-1
14508: PPUSH
14509: CALL_OW 88
// if IsOK ( Lipshchin ) then
14513: LD_EXP 64
14517: PPUSH
14518: CALL_OW 302
14522: IFFALSE 14536
// Say ( Lipshchin , DAmAttackFin-Lip-1 ) ;
14524: LD_EXP 64
14528: PPUSH
14529: LD_STRING DAmAttackFin-Lip-1
14531: PPUSH
14532: CALL_OW 88
// if IsOK ( Karamazov ) then
14536: LD_EXP 58
14540: PPUSH
14541: CALL_OW 302
14545: IFFALSE 14559
// Say ( Karamazov , DAmAttackFin-Kar-1 ) ;
14547: LD_EXP 58
14551: PPUSH
14552: LD_STRING DAmAttackFin-Kar-1
14554: PPUSH
14555: CALL_OW 88
// if IsOK ( Oblukov ) then
14559: LD_EXP 74
14563: PPUSH
14564: CALL_OW 302
14568: IFFALSE 14582
// Say ( Oblukov , DAmAttackFin-Obl-1 ) ;
14570: LD_EXP 74
14574: PPUSH
14575: LD_STRING DAmAttackFin-Obl-1
14577: PPUSH
14578: CALL_OW 88
// Say ( Burlak , AmAttackFin-Bur-1 ) ;
14582: LD_EXP 57
14586: PPUSH
14587: LD_STRING AmAttackFin-Bur-1
14589: PPUSH
14590: CALL_OW 88
// SayRadio ( Popov , DAmAttackFin-Pop-1 ) ;
14594: LD_EXP 76
14598: PPUSH
14599: LD_STRING DAmAttackFin-Pop-1
14601: PPUSH
14602: CALL_OW 94
// DialogueOff ;
14606: CALL_OW 7
// end ;
14610: END
// every 0 0$1 trigger buildingsToBuild + ( 3 - GetAmountWeaponsDataBuildOnTurret ( true ) ) = 0 do
14611: LD_EXP 8
14615: PUSH
14616: LD_INT 3
14618: PUSH
14619: LD_INT 1
14621: PPUSH
14622: CALL 6616 0 1
14626: MINUS
14627: PLUS
14628: PUSH
14629: LD_INT 0
14631: EQUAL
14632: IFFALSE 14644
14634: GO 14636
14636: DISABLE
// ChangeMissionObjectives ( MBuildingsDone ) ;
14637: LD_STRING MBuildingsDone
14639: PPUSH
14640: CALL_OW 337
14644: END
// every 0 0$1 trigger GetAmountWeaponsDataBuildOnVehicle ( false ) = 0 do
14645: LD_INT 0
14647: PPUSH
14648: CALL 6726 0 1
14652: PUSH
14653: LD_INT 0
14655: EQUAL
14656: IFFALSE 14668
14658: GO 14660
14660: DISABLE
// ChangeMissionObjectives ( MWeaponsDone ) ;
14661: LD_STRING MWeaponsDone
14663: PPUSH
14664: CALL_OW 337
14668: END
// every 0 0$1 trigger techsToResearch = 0 do
14669: LD_EXP 9
14673: PUSH
14674: LD_INT 0
14676: EQUAL
14677: IFFALSE 14689
14679: GO 14681
14681: DISABLE
// ChangeMissionObjectives ( MTechnoDone ) ;
14682: LD_STRING MTechnoDone
14684: PPUSH
14685: CALL_OW 337
14689: END
// every 0 0$1 trigger americansAttack and not FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_type , unit_human ] , [ f_and , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ] ] ) do
14690: LD_EXP 26
14694: PUSH
14695: LD_INT 22
14697: PUSH
14698: LD_INT 1
14700: PUSH
14701: EMPTY
14702: LIST
14703: LIST
14704: PUSH
14705: LD_INT 2
14707: PUSH
14708: LD_INT 21
14710: PUSH
14711: LD_INT 1
14713: PUSH
14714: EMPTY
14715: LIST
14716: LIST
14717: PUSH
14718: LD_INT 1
14720: PUSH
14721: LD_INT 21
14723: PUSH
14724: LD_INT 2
14726: PUSH
14727: EMPTY
14728: LIST
14729: LIST
14730: PUSH
14731: LD_INT 33
14733: PUSH
14734: LD_INT 3
14736: PUSH
14737: EMPTY
14738: LIST
14739: LIST
14740: PUSH
14741: EMPTY
14742: LIST
14743: LIST
14744: LIST
14745: PUSH
14746: EMPTY
14747: LIST
14748: LIST
14749: LIST
14750: PUSH
14751: EMPTY
14752: LIST
14753: LIST
14754: PPUSH
14755: CALL_OW 69
14759: NOT
14760: AND
14761: IFFALSE 14773
14763: GO 14765
14765: DISABLE
// ChangeMissionObjectives ( MEnemyDone ) ;
14766: LD_STRING MEnemyDone
14768: PPUSH
14769: CALL_OW 337
14773: END
// every 0 0$1 trigger ( buildingsToBuild + ( 3 - GetAmountWeaponsDataBuildOnTurret ( true ) ) ) = 0 and GetAmountWeaponsDataBuildOnVehicle ( false ) = 0 and techsToResearch = 0 and FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] ] ) = 0 and FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_type , unit_human ] , [ f_and , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ] ] ) = 0 and Masha and IsOK ( Masha [ 1 ] ) and buildCompVehicle and testedTeleport do
14774: LD_EXP 8
14778: PUSH
14779: LD_INT 3
14781: PUSH
14782: LD_INT 1
14784: PPUSH
14785: CALL 6616 0 1
14789: MINUS
14790: PLUS
14791: PUSH
14792: LD_INT 0
14794: EQUAL
14795: PUSH
14796: LD_INT 0
14798: PPUSH
14799: CALL 6726 0 1
14803: PUSH
14804: LD_INT 0
14806: EQUAL
14807: AND
14808: PUSH
14809: LD_EXP 9
14813: PUSH
14814: LD_INT 0
14816: EQUAL
14817: AND
14818: PUSH
14819: LD_INT 22
14821: PUSH
14822: LD_INT 8
14824: PUSH
14825: EMPTY
14826: LIST
14827: LIST
14828: PUSH
14829: LD_INT 21
14831: PUSH
14832: LD_INT 1
14834: PUSH
14835: EMPTY
14836: LIST
14837: LIST
14838: PUSH
14839: EMPTY
14840: LIST
14841: LIST
14842: PPUSH
14843: CALL_OW 69
14847: PUSH
14848: LD_INT 0
14850: EQUAL
14851: AND
14852: PUSH
14853: LD_INT 22
14855: PUSH
14856: LD_INT 1
14858: PUSH
14859: EMPTY
14860: LIST
14861: LIST
14862: PUSH
14863: LD_INT 2
14865: PUSH
14866: LD_INT 21
14868: PUSH
14869: LD_INT 1
14871: PUSH
14872: EMPTY
14873: LIST
14874: LIST
14875: PUSH
14876: LD_INT 1
14878: PUSH
14879: LD_INT 21
14881: PUSH
14882: LD_INT 2
14884: PUSH
14885: EMPTY
14886: LIST
14887: LIST
14888: PUSH
14889: LD_INT 33
14891: PUSH
14892: LD_INT 3
14894: PUSH
14895: EMPTY
14896: LIST
14897: LIST
14898: PUSH
14899: EMPTY
14900: LIST
14901: LIST
14902: LIST
14903: PUSH
14904: EMPTY
14905: LIST
14906: LIST
14907: LIST
14908: PUSH
14909: EMPTY
14910: LIST
14911: LIST
14912: PPUSH
14913: CALL_OW 69
14917: PUSH
14918: LD_INT 0
14920: EQUAL
14921: AND
14922: PUSH
14923: LD_EXP 4
14927: AND
14928: PUSH
14929: LD_EXP 4
14933: PUSH
14934: LD_INT 1
14936: ARRAY
14937: PPUSH
14938: CALL_OW 302
14942: AND
14943: PUSH
14944: LD_EXP 37
14948: AND
14949: PUSH
14950: LD_EXP 39
14954: AND
14955: IFFALSE 14964
14957: GO 14959
14959: DISABLE
// begin FinishMission ;
14960: CALL 15169 0 0
// end ;
14964: END
// every 0 0$1 do var unit ;
14965: GO 14967
14967: DISABLE
14968: LD_INT 0
14970: PPUSH
// begin case allowExitFromMap of 1 :
14971: LD_EXP 18
14975: PUSH
14976: LD_INT 1
14978: DOUBLE
14979: EQUAL
14980: IFTRUE 14984
14982: GO 15012
14984: POP
// RemoveUnits ( FilterUnitsInArea ( ExitMapArea , [ [ f_side , 6 ] ] ) ) ; 3 :
14985: LD_INT 8
14987: PPUSH
14988: LD_INT 22
14990: PUSH
14991: LD_INT 6
14993: PUSH
14994: EMPTY
14995: LIST
14996: LIST
14997: PUSH
14998: EMPTY
14999: LIST
15000: PPUSH
15001: CALL_OW 70
15005: PPUSH
15006: CALL 6452 0 1
15010: GO 15135
15012: LD_INT 3
15014: DOUBLE
15015: EQUAL
15016: IFTRUE 15020
15018: GO 15048
15020: POP
// RemoveUnits ( FilterUnitsInArea ( KurtExitMapArea , [ [ f_side , 8 ] ] ) ) ; 4 :
15021: LD_INT 11
15023: PPUSH
15024: LD_INT 22
15026: PUSH
15027: LD_INT 8
15029: PUSH
15030: EMPTY
15031: LIST
15032: LIST
15033: PUSH
15034: EMPTY
15035: LIST
15036: PPUSH
15037: CALL_OW 70
15041: PPUSH
15042: CALL 6452 0 1
15046: GO 15135
15048: LD_INT 4
15050: DOUBLE
15051: EQUAL
15052: IFTRUE 15056
15054: GO 15134
15056: POP
// begin RemoveUnits ( FilterUnitsInArea ( ExitMapArea , [ [ f_side , 8 ] ] ) ) ;
15057: LD_INT 8
15059: PPUSH
15060: LD_INT 22
15062: PUSH
15063: LD_INT 8
15065: PUSH
15066: EMPTY
15067: LIST
15068: LIST
15069: PUSH
15070: EMPTY
15071: LIST
15072: PPUSH
15073: CALL_OW 70
15077: PPUSH
15078: CALL 6452 0 1
// RemoveUnits ( FilterUnitsInArea ( KurtExitMapArea , [ [ f_side , 8 ] ] ) ) ;
15082: LD_INT 11
15084: PPUSH
15085: LD_INT 22
15087: PUSH
15088: LD_INT 8
15090: PUSH
15091: EMPTY
15092: LIST
15093: LIST
15094: PUSH
15095: EMPTY
15096: LIST
15097: PPUSH
15098: CALL_OW 70
15102: PPUSH
15103: CALL 6452 0 1
// RemoveUnits ( FilterUnitsInArea ( ExitMapArea , [ [ f_side , 2 ] ] ) ) ;
15107: LD_INT 8
15109: PPUSH
15110: LD_INT 22
15112: PUSH
15113: LD_INT 2
15115: PUSH
15116: EMPTY
15117: LIST
15118: LIST
15119: PUSH
15120: EMPTY
15121: LIST
15122: PPUSH
15123: CALL_OW 70
15127: PPUSH
15128: CALL 6452 0 1
// end ; end ;
15132: GO 15135
15134: POP
// enable ;
15135: ENABLE
// end ; end_of_file
15136: PPOPN 1
15138: END
// export function Lose_Burlak ; begin
15139: LD_INT 0
15141: PPUSH
// YouLost ( Burlak ) ;
15142: LD_STRING Burlak
15144: PPUSH
15145: CALL_OW 104
// end ;
15149: LD_VAR 0 1
15153: RET
// export function Lost_AttackAlly ; begin
15154: LD_INT 0
15156: PPUSH
// YouLost ( SelfAttack ) ;
15157: LD_STRING SelfAttack
15159: PPUSH
15160: CALL_OW 104
// end ; end_of_file
15164: LD_VAR 0 1
15168: RET
// export function FinishMission ; begin
15169: LD_INT 0
15171: PPUSH
// SetRewards ;
15172: CALL 15193 0 0
// SavePlayerCharacters ;
15176: CALL 15454 0 0
// SaveGlobalVariables ;
15180: CALL 16004 0 0
// YouWin ;
15184: CALL_OW 103
// end ;
15188: LD_VAR 0 1
15192: RET
// function SetRewards ; begin
15193: LD_INT 0
15195: PPUSH
// AddMedal ( ArtisticImpression , 1 ) ;
15196: LD_STRING ArtisticImpression
15198: PPUSH
15199: LD_INT 1
15201: PPUSH
15202: CALL_OW 101
// if not HeikeCaptured then
15206: LD_EXP 1
15210: NOT
15211: IFFALSE 15245
// begin if speedMedalTime >= 0 0$00 then
15213: LD_EXP 52
15217: PUSH
15218: LD_INT 0
15220: GREATEREQUAL
15221: IFFALSE 15235
// AddMedal ( Speed , 1 ) else
15223: LD_STRING Speed
15225: PPUSH
15226: LD_INT 1
15228: PPUSH
15229: CALL_OW 101
15233: GO 15245
// AddMedal ( Speed , 1 ) ;
15235: LD_STRING Speed
15237: PPUSH
15238: LD_INT 1
15240: PPUSH
15241: CALL_OW 101
// end ; if lostUnits then
15245: LD_EXP 40
15249: IFFALSE 15264
// begin AddMedal ( FavouriteCommander , - 1 ) ;
15251: LD_STRING FavouriteCommander
15253: PPUSH
15254: LD_INT 1
15256: NEG
15257: PPUSH
15258: CALL_OW 101
// end else
15262: GO 15356
// begin case BurlakRespect of 0 :
15264: LD_EXP 30
15268: PUSH
15269: LD_INT 0
15271: DOUBLE
15272: EQUAL
15273: IFTRUE 15277
15275: GO 15291
15277: POP
// AddMedal ( FavouriteCommander , - 2 ) ; 1 :
15278: LD_STRING FavouriteCommander
15280: PPUSH
15281: LD_INT 2
15283: NEG
15284: PPUSH
15285: CALL_OW 101
15289: GO 15356
15291: LD_INT 1
15293: DOUBLE
15294: EQUAL
15295: IFTRUE 15299
15297: GO 15313
15299: POP
// AddMedal ( FavouriteCommander , - 3 ) ; 2 :
15300: LD_STRING FavouriteCommander
15302: PPUSH
15303: LD_INT 3
15305: NEG
15306: PPUSH
15307: CALL_OW 101
15311: GO 15356
15313: LD_INT 2
15315: DOUBLE
15316: EQUAL
15317: IFTRUE 15321
15319: GO 15334
15321: POP
// AddMedal ( FavouriteCommander , 1 ) ; 3 :
15322: LD_STRING FavouriteCommander
15324: PPUSH
15325: LD_INT 1
15327: PPUSH
15328: CALL_OW 101
15332: GO 15356
15334: LD_INT 3
15336: DOUBLE
15337: EQUAL
15338: IFTRUE 15342
15340: GO 15355
15342: POP
// AddMedal ( FavouriteCommander , 1 ) ; end ;
15343: LD_STRING FavouriteCommander
15345: PPUSH
15346: LD_INT 1
15348: PPUSH
15349: CALL_OW 101
15353: GO 15356
15355: POP
// end ; if HeikeCaptured then
15356: LD_EXP 1
15360: IFFALSE 15391
// begin if buildArabBarrack then
15362: LD_EXP 38
15366: IFFALSE 15380
// AddMedal ( ArabBarracks , 1 ) else
15368: LD_STRING ArabBarracks
15370: PPUSH
15371: LD_INT 1
15373: PPUSH
15374: CALL_OW 101
15378: GO 15391
// AddMedal ( ArabBarracks , - 1 ) ;
15380: LD_STRING ArabBarracks
15382: PPUSH
15383: LD_INT 1
15385: NEG
15386: PPUSH
15387: CALL_OW 101
// end ; GiveMedals ( Main1 ) ;
15391: LD_STRING Main1
15393: PPUSH
15394: CALL_OW 102
// RewardPeople ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_nation , nation_russian ] , [ f_ok ] ] ) ) ;
15398: LD_INT 22
15400: PUSH
15401: LD_INT 3
15403: PUSH
15404: EMPTY
15405: LIST
15406: LIST
15407: PUSH
15408: LD_INT 21
15410: PUSH
15411: LD_INT 1
15413: PUSH
15414: EMPTY
15415: LIST
15416: LIST
15417: PUSH
15418: LD_INT 23
15420: PUSH
15421: LD_INT 3
15423: PUSH
15424: EMPTY
15425: LIST
15426: LIST
15427: PUSH
15428: LD_INT 50
15430: PUSH
15431: EMPTY
15432: LIST
15433: PUSH
15434: EMPTY
15435: LIST
15436: LIST
15437: LIST
15438: LIST
15439: PPUSH
15440: CALL_OW 69
15444: PPUSH
15445: CALL_OW 43
// end ;
15449: LD_VAR 0 1
15453: RET
// function SavePlayerCharacters ; var randomsToSave ; begin
15454: LD_INT 0
15456: PPUSH
15457: PPUSH
// ExtSaveCharacter ( Burlak , Burlak , 3 ) ;
15458: LD_EXP 57
15462: PPUSH
15463: LD_STRING Burlak
15465: PPUSH
15466: LD_INT 3
15468: PPUSH
15469: CALL 5974 0 3
// ExtSaveCharacter ( Karamazov , Karamazov , 3 ) ;
15473: LD_EXP 58
15477: PPUSH
15478: LD_STRING Karamazov
15480: PPUSH
15481: LD_INT 3
15483: PPUSH
15484: CALL 5974 0 3
// ExtSaveCharacter ( Petrovova , Petrovova , 3 ) ;
15488: LD_EXP 59
15492: PPUSH
15493: LD_STRING Petrovova
15495: PPUSH
15496: LD_INT 3
15498: PPUSH
15499: CALL 5974 0 3
// ExtSaveCharacter ( Gleb , Gleb , 3 ) ;
15503: LD_EXP 60
15507: PPUSH
15508: LD_STRING Gleb
15510: PPUSH
15511: LD_INT 3
15513: PPUSH
15514: CALL 5974 0 3
// ExtSaveCharacter ( Petrosyan , Petrosyan , 3 ) ;
15518: LD_EXP 61
15522: PPUSH
15523: LD_STRING Petrosyan
15525: PPUSH
15526: LD_INT 3
15528: PPUSH
15529: CALL 5974 0 3
// ExtSaveCharacter ( Dolgov , Dolgov , 3 ) ;
15533: LD_EXP 63
15537: PPUSH
15538: LD_STRING Dolgov
15540: PPUSH
15541: LD_INT 3
15543: PPUSH
15544: CALL 5974 0 3
// ExtSaveCharacter ( Lipshchin , Lipshchin , 3 ) ;
15548: LD_EXP 64
15552: PPUSH
15553: LD_STRING Lipshchin
15555: PPUSH
15556: LD_INT 3
15558: PPUSH
15559: CALL 5974 0 3
// ExtSaveCharacter ( Titov , Titov , 3 ) ;
15563: LD_EXP 62
15567: PPUSH
15568: LD_STRING Titov
15570: PPUSH
15571: LD_INT 3
15573: PPUSH
15574: CALL 5974 0 3
// ExtSaveCharacter ( Kirilenkova , Kirilenkova , 3 ) ;
15578: LD_EXP 65
15582: PPUSH
15583: LD_STRING Kirilenkova
15585: PPUSH
15586: LD_INT 3
15588: PPUSH
15589: CALL 5974 0 3
// ExtSaveCharacter ( Belkov , Belkov , 3 ) ;
15593: LD_EXP 66
15597: PPUSH
15598: LD_STRING Belkov
15600: PPUSH
15601: LD_INT 3
15603: PPUSH
15604: CALL 5974 0 3
// ExtSaveCharacter ( Belkov2 , Belkov2 , 3 ) ;
15608: LD_EXP 67
15612: PPUSH
15613: LD_STRING Belkov2
15615: PPUSH
15616: LD_INT 3
15618: PPUSH
15619: CALL 5974 0 3
// ExtSaveCharacter ( Xavier , Xavier , 3 ) ;
15623: LD_EXP 68
15627: PPUSH
15628: LD_STRING Xavier
15630: PPUSH
15631: LD_INT 3
15633: PPUSH
15634: CALL 5974 0 3
// ExtSaveCharacter ( Kozlov , Kozlov , 3 ) ;
15638: LD_EXP 73
15642: PPUSH
15643: LD_STRING Kozlov
15645: PPUSH
15646: LD_INT 3
15648: PPUSH
15649: CALL 5974 0 3
// ExtSaveCharacter ( Oblukov , Oblukov , 3 ) ;
15653: LD_EXP 74
15657: PPUSH
15658: LD_STRING Oblukov
15660: PPUSH
15661: LD_INT 3
15663: PPUSH
15664: CALL 5974 0 3
// ExtSaveCharacter ( Kapitsova , Kapitsova , 3 ) ;
15668: LD_EXP 75
15672: PPUSH
15673: LD_STRING Kapitsova
15675: PPUSH
15676: LD_INT 3
15678: PPUSH
15679: CALL 5974 0 3
// ExtSaveCharacter ( Gnyevko , Gnyevko , 3 ) ;
15683: LD_EXP 69
15687: PPUSH
15688: LD_STRING Gnyevko
15690: PPUSH
15691: LD_INT 3
15693: PPUSH
15694: CALL 5974 0 3
// ExtSaveCharacter ( Kovalyuk , Kovalyuk , 3 ) ;
15698: LD_EXP 70
15702: PPUSH
15703: LD_STRING Kovalyuk
15705: PPUSH
15706: LD_INT 3
15708: PPUSH
15709: CALL 5974 0 3
// ExtSaveCharacter ( Scholtze , Scholtze , 3 ) ;
15713: LD_EXP 71
15717: PPUSH
15718: LD_STRING Scholtze
15720: PPUSH
15721: LD_INT 3
15723: PPUSH
15724: CALL 5974 0 3
// ExtSaveCharacter ( Kuzmov , Kuzmov , 3 ) ;
15728: LD_EXP 72
15732: PPUSH
15733: LD_STRING Kuzmov
15735: PPUSH
15736: LD_INT 3
15738: PPUSH
15739: CALL 5974 0 3
// ExtSaveCharacters ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_or , [ f_class , class_apeman ] , [ f_class , class_apeman_engineer ] , [ f_class , class_apeman_soldier ] ] ] ) , other_apemans , 3 ) ;
15743: LD_INT 22
15745: PUSH
15746: LD_INT 3
15748: PUSH
15749: EMPTY
15750: LIST
15751: LIST
15752: PUSH
15753: LD_INT 21
15755: PUSH
15756: LD_INT 1
15758: PUSH
15759: EMPTY
15760: LIST
15761: LIST
15762: PUSH
15763: LD_INT 2
15765: PUSH
15766: LD_INT 25
15768: PUSH
15769: LD_INT 12
15771: PUSH
15772: EMPTY
15773: LIST
15774: LIST
15775: PUSH
15776: LD_INT 25
15778: PUSH
15779: LD_INT 16
15781: PUSH
15782: EMPTY
15783: LIST
15784: LIST
15785: PUSH
15786: LD_INT 25
15788: PUSH
15789: LD_INT 15
15791: PUSH
15792: EMPTY
15793: LIST
15794: LIST
15795: PUSH
15796: EMPTY
15797: LIST
15798: LIST
15799: LIST
15800: LIST
15801: PUSH
15802: EMPTY
15803: LIST
15804: LIST
15805: LIST
15806: PPUSH
15807: CALL_OW 69
15811: PPUSH
15812: LD_STRING other_apemans
15814: PPUSH
15815: LD_INT 3
15817: PPUSH
15818: CALL 6031 0 3
// randomsToSave = FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_nation , nation_russian ] ] ) diff [ Burlak , Karamazov , Petrovova , Gleb , Petrosyan , Titov , Dolgov , Lipshchin , Kirilenkova , Belkov , Belkov2 , Xavier , Gnyevko , Kovalyuk , Scholtze , Kuzmov , Kozlov , Oblukov , Kapitsova ] ;
15822: LD_ADDR_VAR 0 2
15826: PUSH
15827: LD_INT 22
15829: PUSH
15830: LD_INT 3
15832: PUSH
15833: EMPTY
15834: LIST
15835: LIST
15836: PUSH
15837: LD_INT 21
15839: PUSH
15840: LD_INT 1
15842: PUSH
15843: EMPTY
15844: LIST
15845: LIST
15846: PUSH
15847: LD_INT 23
15849: PUSH
15850: LD_INT 3
15852: PUSH
15853: EMPTY
15854: LIST
15855: LIST
15856: PUSH
15857: EMPTY
15858: LIST
15859: LIST
15860: LIST
15861: PPUSH
15862: CALL_OW 69
15866: PUSH
15867: LD_EXP 57
15871: PUSH
15872: LD_EXP 58
15876: PUSH
15877: LD_EXP 59
15881: PUSH
15882: LD_EXP 60
15886: PUSH
15887: LD_EXP 61
15891: PUSH
15892: LD_EXP 62
15896: PUSH
15897: LD_EXP 63
15901: PUSH
15902: LD_EXP 64
15906: PUSH
15907: LD_EXP 65
15911: PUSH
15912: LD_EXP 66
15916: PUSH
15917: LD_EXP 67
15921: PUSH
15922: LD_EXP 68
15926: PUSH
15927: LD_EXP 69
15931: PUSH
15932: LD_EXP 70
15936: PUSH
15937: LD_EXP 71
15941: PUSH
15942: LD_EXP 72
15946: PUSH
15947: LD_EXP 73
15951: PUSH
15952: LD_EXP 74
15956: PUSH
15957: LD_EXP 75
15961: PUSH
15962: EMPTY
15963: LIST
15964: LIST
15965: LIST
15966: LIST
15967: LIST
15968: LIST
15969: LIST
15970: LIST
15971: LIST
15972: LIST
15973: LIST
15974: LIST
15975: LIST
15976: LIST
15977: LIST
15978: LIST
15979: LIST
15980: LIST
15981: LIST
15982: DIFF
15983: ST_TO_ADDR
// ExtSaveCharacters ( randomsToSave , other_survivors , 3 ) ;
15984: LD_VAR 0 2
15988: PPUSH
15989: LD_STRING other_survivors
15991: PPUSH
15992: LD_INT 3
15994: PPUSH
15995: CALL 6031 0 3
// end ;
15999: LD_VAR 0 1
16003: RET
// function SaveGlobalVariables ; begin
16004: LD_INT 0
16006: PPUSH
// SaveBase ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_building ] ] ) , 08_TrockyBase_1 ) ;
16007: LD_INT 22
16009: PUSH
16010: LD_INT 3
16012: PUSH
16013: EMPTY
16014: LIST
16015: LIST
16016: PUSH
16017: LD_INT 21
16019: PUSH
16020: LD_INT 3
16022: PUSH
16023: EMPTY
16024: LIST
16025: LIST
16026: PUSH
16027: EMPTY
16028: LIST
16029: LIST
16030: PPUSH
16031: CALL_OW 69
16035: PPUSH
16036: LD_STRING 08_TrockyBase_1
16038: PPUSH
16039: CALL 8410 0 2
// SaveVariable ( coopWithGensher , 08_CoopWithGensher_2 ) ;
16043: LD_EXP 2
16047: PPUSH
16048: LD_STRING 08_CoopWithGensher_2
16050: PPUSH
16051: CALL_OW 39
// SaveVariable ( HeikeStatus , 08_HeikeStatus_3 ) ;
16055: LD_EXP 3
16059: PPUSH
16060: LD_STRING 08_HeikeStatus_3
16062: PPUSH
16063: CALL_OW 39
// SaveVariable ( Masha , 08_Masha_4 ) ;
16067: LD_EXP 4
16071: PPUSH
16072: LD_STRING 08_Masha_4
16074: PPUSH
16075: CALL_OW 39
// end ; end_of_file
16079: LD_VAR 0 1
16083: RET
// export function CustomEvent ( event ) ; begin
16084: LD_INT 0
16086: PPUSH
// end ;
16087: LD_VAR 0 2
16091: RET
// on BuildingComplete ( building ) do begin if GetBType ( building ) in buildingsToBuild and GetNation ( building ) = nation_russian then
16092: LD_VAR 0 1
16096: PPUSH
16097: CALL_OW 266
16101: PUSH
16102: LD_EXP 8
16106: IN
16107: PUSH
16108: LD_VAR 0 1
16112: PPUSH
16113: CALL_OW 248
16117: PUSH
16118: LD_INT 3
16120: EQUAL
16121: AND
16122: IFFALSE 16145
// buildingsToBuild = buildingsToBuild diff GetBType ( building ) ;
16124: LD_ADDR_EXP 8
16128: PUSH
16129: LD_EXP 8
16133: PUSH
16134: LD_VAR 0 1
16138: PPUSH
16139: CALL_OW 266
16143: DIFF
16144: ST_TO_ADDR
// if GetBType ( building ) = b_depot then
16145: LD_VAR 0 1
16149: PPUSH
16150: CALL_OW 266
16154: PUSH
16155: LD_INT 0
16157: EQUAL
16158: IFFALSE 16209
// begin SetBName ( building , trockij ) ;
16160: LD_VAR 0 1
16164: PPUSH
16165: LD_STRING trockij
16167: PPUSH
16168: CALL_OW 500
// if not dial_BuildDepotBlocker and HeikeCaptured then
16172: LD_EXP 5
16176: NOT
16177: PUSH
16178: LD_EXP 1
16182: AND
16183: IFFALSE 16209
// Dial_EscortHeike ( GetX ( building ) , GetY ( building ) ) ;
16185: LD_VAR 0 1
16189: PPUSH
16190: CALL_OW 250
16194: PPUSH
16195: LD_VAR 0 1
16199: PPUSH
16200: CALL_OW 251
16204: PPUSH
16205: CALL 9075 0 2
// end ; end ;
16209: PPOPN 1
16211: END
// on UpgradeComplete ( building ) do begin if GetBType ( building ) in buildingsToBuild and GetNation ( building ) = nation_russian then
16212: LD_VAR 0 1
16216: PPUSH
16217: CALL_OW 266
16221: PUSH
16222: LD_EXP 8
16226: IN
16227: PUSH
16228: LD_VAR 0 1
16232: PPUSH
16233: CALL_OW 248
16237: PUSH
16238: LD_INT 3
16240: EQUAL
16241: AND
16242: IFFALSE 16265
// buildingsToBuild = buildingsToBuild diff GetBType ( building ) ;
16244: LD_ADDR_EXP 8
16248: PUSH
16249: LD_EXP 8
16253: PUSH
16254: LD_VAR 0 1
16258: PPUSH
16259: CALL_OW 266
16263: DIFF
16264: ST_TO_ADDR
// if GetBType ( building ) = b_barracks and GetNation ( building ) = 2 and not dial_BuildArBarrackBlocker then
16265: LD_VAR 0 1
16269: PPUSH
16270: CALL_OW 266
16274: PUSH
16275: LD_INT 5
16277: EQUAL
16278: PUSH
16279: LD_VAR 0 1
16283: PPUSH
16284: CALL_OW 248
16288: PUSH
16289: LD_INT 2
16291: EQUAL
16292: AND
16293: PUSH
16294: LD_EXP 6
16298: NOT
16299: AND
16300: IFFALSE 16306
// Dial_UpgradeArmoury ;
16302: CALL 9886 0 0
// end ;
16306: PPOPN 1
16308: END
// on ResearchComplete ( research , building ) do begin if research in techsToResearch then
16309: LD_VAR 0 1
16313: PUSH
16314: LD_EXP 9
16318: IN
16319: IFFALSE 16337
// techsToResearch = techsToResearch diff research ;
16321: LD_ADDR_EXP 9
16325: PUSH
16326: LD_EXP 9
16330: PUSH
16331: LD_VAR 0 1
16335: DIFF
16336: ST_TO_ADDR
// if research = tech_LimTeleport then
16337: LD_VAR 0 1
16341: PUSH
16342: LD_INT 37
16344: EQUAL
16345: IFFALSE 16351
// Dial_TeleportTechResearched ;
16347: CALL 13731 0 0
// if research = tech_AdvAI then
16351: LD_VAR 0 1
16355: PUSH
16356: LD_INT 27
16358: EQUAL
16359: IFFALSE 16365
// Dial_ComputerTechResearched ;
16361: CALL 13600 0 0
// end ;
16365: PPOPN 2
16367: END
// on EnterVehicle ( vehicle , human ) do begin if not canChooseMashaVehicle then
16368: LD_EXP 36
16372: NOT
16373: IFFALSE 16377
// exit ;
16375: GO 16544
// wait ( 0 0$1 ) ;
16377: LD_INT 35
16379: PPUSH
16380: CALL_OW 67
// if GetSide ( vehicle ) = 3 and human = Burlak and GetNation ( vehicle ) = nation_russian and GetWeapon ( vehicle ) in [ ru_heavy_machine_gun , ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher ] then
16384: LD_VAR 0 1
16388: PPUSH
16389: CALL_OW 255
16393: PUSH
16394: LD_INT 3
16396: EQUAL
16397: PUSH
16398: LD_VAR 0 2
16402: PUSH
16403: LD_EXP 57
16407: EQUAL
16408: AND
16409: PUSH
16410: LD_VAR 0 1
16414: PPUSH
16415: CALL_OW 248
16419: PUSH
16420: LD_INT 3
16422: EQUAL
16423: AND
16424: PUSH
16425: LD_VAR 0 1
16429: PPUSH
16430: CALL_OW 264
16434: PUSH
16435: LD_INT 42
16437: PUSH
16438: LD_INT 43
16440: PUSH
16441: LD_INT 44
16443: PUSH
16444: LD_INT 46
16446: PUSH
16447: LD_INT 45
16449: PUSH
16450: EMPTY
16451: LIST
16452: LIST
16453: LIST
16454: LIST
16455: LIST
16456: IN
16457: AND
16458: IFFALSE 16544
// begin if Masha then
16460: LD_EXP 4
16464: IFFALSE 16484
// if Masha [ 1 ] = vehicle then
16466: LD_EXP 4
16470: PUSH
16471: LD_INT 1
16473: ARRAY
16474: PUSH
16475: LD_VAR 0 1
16479: EQUAL
16480: IFFALSE 16484
// exit ;
16482: GO 16544
// if firstMashaQuery then
16484: LD_EXP 35
16488: IFFALSE 16522
// begin firstMashaQuery = false ;
16490: LD_ADDR_EXP 35
16494: PUSH
16495: LD_INT 0
16497: ST_TO_ADDR
// if Query ( QMashaQuery ) = 1 then
16498: LD_STRING QMashaQuery
16500: PPUSH
16501: CALL_OW 97
16505: PUSH
16506: LD_INT 1
16508: EQUAL
16509: IFFALSE 16520
// SetMashaData ( vehicle ) ;
16511: LD_VAR 0 1
16515: PPUSH
16516: CALL 8304 0 1
// end else
16520: GO 16544
// begin if Query ( QMashaQuery2 ) = 1 then
16522: LD_STRING QMashaQuery2
16524: PPUSH
16525: CALL_OW 97
16529: PUSH
16530: LD_INT 1
16532: EQUAL
16533: IFFALSE 16544
// SetMashaData ( vehicle ) ;
16535: LD_VAR 0 1
16539: PPUSH
16540: CALL 8304 0 1
// end ; end ; end ;
16544: PPOPN 2
16546: END
// on UnitDestroyed ( unit ) do begin if Masha then
16547: LD_EXP 4
16551: IFFALSE 16576
// if unit = Masha [ 1 ] then
16553: LD_VAR 0 1
16557: PUSH
16558: LD_EXP 4
16562: PUSH
16563: LD_INT 1
16565: ARRAY
16566: EQUAL
16567: IFFALSE 16576
// Masha = [ ] ;
16569: LD_ADDR_EXP 4
16573: PUSH
16574: EMPTY
16575: ST_TO_ADDR
// if unit = Burlak then
16576: LD_VAR 0 1
16580: PUSH
16581: LD_EXP 57
16585: EQUAL
16586: IFFALSE 16592
// Lose_Burlak ;
16588: CALL 15139 0 0
// if GetType ( unit ) = unit_human and GetNation ( unit ) = nation_russian then
16592: LD_VAR 0 1
16596: PPUSH
16597: CALL_OW 247
16601: PUSH
16602: LD_INT 1
16604: EQUAL
16605: PUSH
16606: LD_VAR 0 1
16610: PPUSH
16611: CALL_OW 248
16615: PUSH
16616: LD_INT 3
16618: EQUAL
16619: AND
16620: IFFALSE 16636
// lostUnits = lostUnits + 1 ;
16622: LD_ADDR_EXP 40
16626: PUSH
16627: LD_EXP 40
16631: PUSH
16632: LD_INT 1
16634: PLUS
16635: ST_TO_ADDR
// end ;
16636: PPOPN 1
16638: END
// on UnitGoesToRed ( unit ) do begin if GetType ( unit ) = unit_vehicle and GetNation ( unit ) = nation_russian and GetTech ( tech_LimTeleport , 3 ) = state_researched and not testedTeleport then
16639: LD_VAR 0 1
16643: PPUSH
16644: CALL_OW 247
16648: PUSH
16649: LD_INT 2
16651: EQUAL
16652: PUSH
16653: LD_VAR 0 1
16657: PPUSH
16658: CALL_OW 248
16662: PUSH
16663: LD_INT 3
16665: EQUAL
16666: AND
16667: PUSH
16668: LD_INT 37
16670: PPUSH
16671: LD_INT 3
16673: PPUSH
16674: CALL_OW 321
16678: PUSH
16679: LD_INT 2
16681: EQUAL
16682: AND
16683: PUSH
16684: LD_EXP 39
16688: NOT
16689: AND
16690: IFFALSE 16707
// begin testedTeleport = true ;
16692: LD_ADDR_EXP 39
16696: PUSH
16697: LD_INT 1
16699: ST_TO_ADDR
// ChangeMissionObjectives ( MTeleDone ) ;
16700: LD_STRING MTeleDone
16702: PPUSH
16703: CALL_OW 337
// end ; if unit = Heike then
16707: LD_VAR 0 1
16711: PUSH
16712: LD_EXP 79
16716: EQUAL
16717: IFFALSE 16760
// begin DialogueOn ;
16719: CALL_OW 6
// CenterNowOnUnits ( Heike ) ;
16723: LD_EXP 79
16727: PPUSH
16728: CALL_OW 87
// ForceSay ( Heike , DHeikeKilled-Hke-1 ) ;
16732: LD_EXP 79
16736: PPUSH
16737: LD_STRING DHeikeKilled-Hke-1
16739: PPUSH
16740: CALL_OW 91
// DialogueOff ;
16744: CALL_OW 7
// SetLives ( Heike , 0 ) ;
16748: LD_EXP 79
16752: PPUSH
16753: LD_INT 0
16755: PPUSH
16756: CALL_OW 234
// end ; end ;
16760: PPOPN 1
16762: END
// on Contact ( side1 , side2 ) do begin if side1 = 3 and side2 = 6 then
16763: LD_VAR 0 1
16767: PUSH
16768: LD_INT 3
16770: EQUAL
16771: PUSH
16772: LD_VAR 0 2
16776: PUSH
16777: LD_INT 6
16779: EQUAL
16780: AND
16781: IFFALSE 16787
// Lost_AttackAlly ;
16783: CALL 15154 0 0
// if side1 = 3 and side2 = 2 then
16787: LD_VAR 0 1
16791: PUSH
16792: LD_INT 3
16794: EQUAL
16795: PUSH
16796: LD_VAR 0 2
16800: PUSH
16801: LD_INT 2
16803: EQUAL
16804: AND
16805: IFFALSE 16811
// Dial_AttackGensher ;
16807: CALL 10842 0 0
// if side1 = 3 and side2 = 5 then
16811: LD_VAR 0 1
16815: PUSH
16816: LD_INT 3
16818: EQUAL
16819: PUSH
16820: LD_VAR 0 2
16824: PUSH
16825: LD_INT 5
16827: EQUAL
16828: AND
16829: IFFALSE 16873
// begin SetAttitude ( 3 , 5 , att_enemy , true ) ;
16831: LD_INT 3
16833: PPUSH
16834: LD_INT 5
16836: PPUSH
16837: LD_INT 2
16839: PPUSH
16840: LD_INT 1
16842: PPUSH
16843: CALL_OW 80
// if acceptKurtOffert and not GetSide ( Kurt ) = 2 then
16847: LD_EXP 19
16851: PUSH
16852: LD_EXP 80
16856: PPUSH
16857: CALL_OW 255
16861: PUSH
16862: LD_INT 2
16864: EQUAL
16865: NOT
16866: AND
16867: IFFALSE 16873
// Dial_BetrayedKurt1 ;
16869: CALL 11391 0 0
// end ; if side1 = 3 and side2 = 8 and GetAttitude ( 3 , 8 ) = att_neutral then
16873: LD_VAR 0 1
16877: PUSH
16878: LD_INT 3
16880: EQUAL
16881: PUSH
16882: LD_VAR 0 2
16886: PUSH
16887: LD_INT 8
16889: EQUAL
16890: AND
16891: PUSH
16892: LD_INT 3
16894: PPUSH
16895: LD_INT 8
16897: PPUSH
16898: CALL_OW 81
16902: PUSH
16903: LD_INT 0
16905: EQUAL
16906: AND
16907: IFFALSE 16919
// begin if acceptKurtOffert then
16909: LD_EXP 19
16913: IFFALSE 16919
// Dial_BetrayedKurt2 ;
16915: CALL 11477 0 0
// end ; end ;
16919: PPOPN 2
16921: END
// on VehicleConstructed ( vehicle , building ) do begin SetWeaponDataBuild ( GetWeapon ( vehicle ) , false ) ;
16922: LD_VAR 0 1
16926: PPUSH
16927: CALL_OW 264
16931: PPUSH
16932: LD_INT 0
16934: PPUSH
16935: CALL 6812 0 2
// if GetControl ( vehicle ) = control_computer and not buildCompVehicle then
16939: LD_VAR 0 1
16943: PPUSH
16944: CALL_OW 263
16948: PUSH
16949: LD_INT 3
16951: EQUAL
16952: PUSH
16953: LD_EXP 37
16957: NOT
16958: AND
16959: IFFALSE 16976
// begin buildCompVehicle = true ;
16961: LD_ADDR_EXP 37
16965: PUSH
16966: LD_INT 1
16968: ST_TO_ADDR
// ChangeMissionObjectives ( MAIDone ) ;
16969: LD_STRING MAIDone
16971: PPUSH
16972: CALL_OW 337
// end ; end ;
16976: PPOPN 2
16978: END
// on WeaponPlaced ( building , factory ) do begin SetWeaponDataBuild ( GetBWeapon ( building ) , true ) ;
16979: LD_VAR 0 1
16983: PPUSH
16984: CALL_OW 269
16988: PPUSH
16989: LD_INT 1
16991: PPUSH
16992: CALL 6812 0 2
// end ;
16996: PPOPN 2
16998: END
// on Command ( comandid ) do var i ;
16999: LD_INT 0
17001: PPUSH
// begin if IsOK ( KurtEng ) and GetSide ( KurtEng ) = 3 then
17002: LD_EXP 82
17006: PPUSH
17007: CALL_OW 302
17011: PUSH
17012: LD_EXP 82
17016: PPUSH
17017: CALL_OW 255
17021: PUSH
17022: LD_INT 3
17024: EQUAL
17025: AND
17026: IFFALSE 17235
// if GetTaskList ( KurtEng ) then
17028: LD_EXP 82
17032: PPUSH
17033: CALL_OW 437
17037: IFFALSE 17235
// begin for i := 1 to ( GetTaskList ( KurtEng ) ) do
17039: LD_ADDR_VAR 0 2
17043: PUSH
17044: DOUBLE
17045: LD_INT 1
17047: DEC
17048: ST_TO_ADDR
17049: LD_EXP 82
17053: PPUSH
17054: CALL_OW 437
17058: PUSH
17059: FOR_TO
17060: IFFALSE 17233
// begin if ( GetTaskList ( KurtEng ) [ i ] [ 1 ] in [ F , H , M , U , V , a , h , u , v , ~ , ^ , > , + , ; , 4 , { ] ) or ( GetTaskList ( KurtEng ) [ i ] [ 1 ] = B and GetTaskList ( KurtEng ) [ i ] [ 5 ] = 36 ) then
17062: LD_EXP 82
17066: PPUSH
17067: CALL_OW 437
17071: PUSH
17072: LD_VAR 0 2
17076: ARRAY
17077: PUSH
17078: LD_INT 1
17080: ARRAY
17081: PUSH
17082: LD_STRING F
17084: PUSH
17085: LD_STRING H
17087: PUSH
17088: LD_STRING M
17090: PUSH
17091: LD_STRING U
17093: PUSH
17094: LD_STRING V
17096: PUSH
17097: LD_STRING a
17099: PUSH
17100: LD_STRING h
17102: PUSH
17103: LD_STRING u
17105: PUSH
17106: LD_STRING v
17108: PUSH
17109: LD_STRING ~
17111: PUSH
17112: LD_STRING ^
17114: PUSH
17115: LD_STRING >
17117: PUSH
17118: LD_STRING +
17120: PUSH
17121: LD_STRING ;
17123: PUSH
17124: LD_STRING 4
17126: PUSH
17127: LD_STRING {
17129: PUSH
17130: EMPTY
17131: LIST
17132: LIST
17133: LIST
17134: LIST
17135: LIST
17136: LIST
17137: LIST
17138: LIST
17139: LIST
17140: LIST
17141: LIST
17142: LIST
17143: LIST
17144: LIST
17145: LIST
17146: LIST
17147: IN
17148: PUSH
17149: LD_EXP 82
17153: PPUSH
17154: CALL_OW 437
17158: PUSH
17159: LD_VAR 0 2
17163: ARRAY
17164: PUSH
17165: LD_INT 1
17167: ARRAY
17168: PUSH
17169: LD_STRING B
17171: EQUAL
17172: PUSH
17173: LD_EXP 82
17177: PPUSH
17178: CALL_OW 437
17182: PUSH
17183: LD_VAR 0 2
17187: ARRAY
17188: PUSH
17189: LD_INT 5
17191: ARRAY
17192: PUSH
17193: LD_INT 36
17195: EQUAL
17196: AND
17197: OR
17198: IFFALSE 17202
// else
17200: GO 17231
// begin RemoveTasks ( KurtEng ) ;
17202: LD_EXP 82
17206: PPUSH
17207: CALL_OW 493
// DialogueOn ;
17211: CALL_OW 6
// Say ( Kurt , DMercRefuseBuild-Kurt-1 ) ;
17215: LD_EXP 80
17219: PPUSH
17220: LD_STRING DMercRefuseBuild-Kurt-1
17222: PPUSH
17223: CALL_OW 88
// DialogueOff ;
17227: CALL_OW 7
// end ; end ;
17231: GO 17059
17233: POP
17234: POP
// end ; end ; end_of_file
17235: PPOPN 2
17237: END
// every 0 0$01 do var timer , cratesSpawned ;
17238: GO 17240
17240: DISABLE
17241: LD_INT 0
17243: PPUSH
17244: PPUSH
// begin timer := 1 1$30 ;
17245: LD_ADDR_VAR 0 1
17249: PUSH
17250: LD_INT 3150
17252: ST_TO_ADDR
// repeat wait ( timer ) ;
17253: LD_VAR 0 1
17257: PPUSH
17258: CALL_OW 67
// if cratesSpawned >= 6 and cratesSpawned < 18 then
17262: LD_VAR 0 2
17266: PUSH
17267: LD_INT 6
17269: GREATEREQUAL
17270: PUSH
17271: LD_VAR 0 2
17275: PUSH
17276: LD_INT 18
17278: LESS
17279: AND
17280: IFFALSE 17296
// timer := timer + 0 0$3 ;
17282: LD_ADDR_VAR 0 1
17286: PUSH
17287: LD_VAR 0 1
17291: PUSH
17292: LD_INT 105
17294: PLUS
17295: ST_TO_ADDR
// if cratesSpawned >= 18 then
17296: LD_VAR 0 2
17300: PUSH
17301: LD_INT 18
17303: GREATEREQUAL
17304: IFFALSE 17320
// timer := timer + 0 0$9 ;
17306: LD_ADDR_VAR 0 1
17310: PUSH
17311: LD_VAR 0 1
17315: PUSH
17316: LD_INT 315
17318: PLUS
17319: ST_TO_ADDR
// if timer > 3 3$00 then
17320: LD_VAR 0 1
17324: PUSH
17325: LD_INT 6300
17327: GREATER
17328: IFFALSE 17338
// timer := 0 0$50 ;
17330: LD_ADDR_VAR 0 1
17334: PUSH
17335: LD_INT 1750
17337: ST_TO_ADDR
// CreateCratesArea ( rand ( 3 , 5 ) , CratesSpawnArea , true ) ;
17338: LD_INT 3
17340: PPUSH
17341: LD_INT 5
17343: PPUSH
17344: CALL_OW 12
17348: PPUSH
17349: LD_INT 15
17351: PPUSH
17352: LD_INT 1
17354: PPUSH
17355: CALL_OW 55
// cratesSpawned = cratesSpawned + 1 ;
17359: LD_ADDR_VAR 0 2
17363: PUSH
17364: LD_VAR 0 2
17368: PUSH
17369: LD_INT 1
17371: PLUS
17372: ST_TO_ADDR
// until false ;
17373: LD_INT 0
17375: IFFALSE 17253
// end ; end_of_file
17377: PPOPN 2
17379: END
// every 0 0$1 do
17380: GO 17382
17382: DISABLE
// begin enable ;
17383: ENABLE
// end ;
17384: END
// every 0 0$1 do var building , playerBuildings , playerBuildingsBType ;
17385: GO 17387
17387: DISABLE
17388: LD_INT 0
17390: PPUSH
17391: PPUSH
17392: PPUSH
// begin playerBuildings = FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_building ] , [ f_nation , nation_russian ] ] ) ;
17393: LD_ADDR_VAR 0 2
17397: PUSH
17398: LD_INT 22
17400: PUSH
17401: LD_INT 3
17403: PUSH
17404: EMPTY
17405: LIST
17406: LIST
17407: PUSH
17408: LD_INT 21
17410: PUSH
17411: LD_INT 3
17413: PUSH
17414: EMPTY
17415: LIST
17416: LIST
17417: PUSH
17418: LD_INT 23
17420: PUSH
17421: LD_INT 3
17423: PUSH
17424: EMPTY
17425: LIST
17426: LIST
17427: PUSH
17428: EMPTY
17429: LIST
17430: LIST
17431: LIST
17432: PPUSH
17433: CALL_OW 69
17437: ST_TO_ADDR
// playerBuildingsBType = [ ] ;
17438: LD_ADDR_VAR 0 3
17442: PUSH
17443: EMPTY
17444: ST_TO_ADDR
// for building in playerBuildings do
17445: LD_ADDR_VAR 0 1
17449: PUSH
17450: LD_VAR 0 2
17454: PUSH
17455: FOR_IN
17456: IFFALSE 17481
// playerBuildingsBType = playerBuildingsBType ^ GetBType ( building ) ;
17458: LD_ADDR_VAR 0 3
17462: PUSH
17463: LD_VAR 0 3
17467: PUSH
17468: LD_VAR 0 1
17472: PPUSH
17473: CALL_OW 266
17477: ADD
17478: ST_TO_ADDR
17479: GO 17455
17481: POP
17482: POP
// for building in allBuildings do
17483: LD_ADDR_VAR 0 1
17487: PUSH
17488: LD_EXP 13
17492: PUSH
17493: FOR_IN
17494: IFFALSE 17540
// if not building in playerBuildingsBType and not building in buildingsToBuild then
17496: LD_VAR 0 1
17500: PUSH
17501: LD_VAR 0 3
17505: IN
17506: NOT
17507: PUSH
17508: LD_VAR 0 1
17512: PUSH
17513: LD_EXP 8
17517: IN
17518: NOT
17519: AND
17520: IFFALSE 17538
// buildingsToBuild = buildingsToBuild ^ building ;
17522: LD_ADDR_EXP 8
17526: PUSH
17527: LD_EXP 8
17531: PUSH
17532: LD_VAR 0 1
17536: ADD
17537: ST_TO_ADDR
17538: GO 17493
17540: POP
17541: POP
// enable ;
17542: ENABLE
// end ;
17543: PPOPN 3
17545: END
// every 0 0$1 trigger legionOffertCountdown do
17546: LD_EXP 33
17550: IFFALSE 17570
17552: GO 17554
17554: DISABLE
// begin legionOffertTime = legionOffertTime - 0 0$01 ;
17555: LD_ADDR_EXP 34
17559: PUSH
17560: LD_EXP 34
17564: PUSH
17565: LD_INT 35
17567: MINUS
17568: ST_TO_ADDR
// enable ;
17569: ENABLE
// end ;
17570: END
// every 0 0$1 trigger KurtWaitingForFreeHeike do
17571: LD_EXP 23
17575: IFFALSE 17609
17577: GO 17579
17579: DISABLE
// begin timeToFreeHeike = timeToFreeHeike - 0 0$01 ;
17580: LD_ADDR_EXP 54
17584: PUSH
17585: LD_EXP 54
17589: PUSH
17590: LD_INT 35
17592: MINUS
17593: ST_TO_ADDR
// if timeToFreeHeike <= 0 0$00 then
17594: LD_EXP 54
17598: PUSH
17599: LD_INT 0
17601: LESSEQUAL
17602: IFFALSE 17608
// Dial_PlayerDontSendHeike ;
17604: CALL 11339 0 0
// enable ;
17608: ENABLE
// end ;
17609: END
// every 0 0$1 trigger KurtWaitingForBuildBarrack and GetSide ( KurtEng ) = 3 do
17610: LD_EXP 24
17614: PUSH
17615: LD_EXP 82
17619: PPUSH
17620: CALL_OW 255
17624: PUSH
17625: LD_INT 3
17627: EQUAL
17628: AND
17629: IFFALSE 17702
17631: GO 17633
17633: DISABLE
// begin timeToBuildArBarrack = timeToBuildArBarrack - 0 0$01 ;
17634: LD_ADDR_EXP 55
17638: PUSH
17639: LD_EXP 55
17643: PUSH
17644: LD_INT 35
17646: MINUS
17647: ST_TO_ADDR
// if timeToBuildArBarrack <= 0 0$00 then
17648: LD_EXP 55
17652: PUSH
17653: LD_INT 0
17655: LESSEQUAL
17656: IFFALSE 17701
// begin Dial_BetrayedKurt1 ;
17658: CALL 11391 0 0
// wait ( 2 2$0 ) ;
17662: LD_INT 4200
17664: PPUSH
17665: CALL_OW 67
// SetAttitude ( 3 , 8 , att_enemy , true ) ;
17669: LD_INT 3
17671: PPUSH
17672: LD_INT 8
17674: PPUSH
17675: LD_INT 2
17677: PPUSH
17678: LD_INT 1
17680: PPUSH
17681: CALL_OW 80
// KurtAttack = true ;
17685: LD_ADDR_EXP 25
17689: PUSH
17690: LD_INT 1
17692: ST_TO_ADDR
// KurtWaitingForBuildBarrack = false ;
17693: LD_ADDR_EXP 24
17697: PUSH
17698: LD_INT 0
17700: ST_TO_ADDR
// end ; enable ;
17701: ENABLE
// end ; end_of_file
17702: END
// export currentAmWave , currentArWave ; every 0 0$1 trigger americansAttack do var i ;
17703: LD_EXP 26
17707: IFFALSE 17853
17709: GO 17711
17711: DISABLE
17712: LD_INT 0
17714: PPUSH
// begin currentAmWave = 0 ;
17715: LD_ADDR_EXP 85
17719: PUSH
17720: LD_INT 0
17722: ST_TO_ADDR
// wait ( firstAttackDelay ) ;
17723: LD_EXP 49
17727: PPUSH
17728: CALL_OW 67
// for i := 1 to americansAttackWaves do
17732: LD_ADDR_VAR 0 1
17736: PUSH
17737: DOUBLE
17738: LD_INT 1
17740: DEC
17741: ST_TO_ADDR
17742: LD_EXP 48
17746: PUSH
17747: FOR_TO
17748: IFFALSE 17851
// begin SpawnAmAttackTeam ;
17750: CALL 3140 0 0
// currentAmWave = currentAmWave + 1 ;
17754: LD_ADDR_EXP 85
17758: PUSH
17759: LD_EXP 85
17763: PUSH
17764: LD_INT 1
17766: PLUS
17767: ST_TO_ADDR
// if currentAmWave = 1 then
17768: LD_EXP 85
17772: PUSH
17773: LD_INT 1
17775: EQUAL
17776: IFFALSE 17840
// begin if paidLegionOffert then
17778: LD_EXP 32
17782: IFFALSE 17821
// begin Say ( Burlak , DAmAttackStart-Bur-1 ) ;
17784: LD_EXP 57
17788: PPUSH
17789: LD_STRING DAmAttackStart-Bur-1
17791: PPUSH
17792: CALL_OW 88
// if IsOK ( Gleb ) then
17796: LD_EXP 60
17800: PPUSH
17801: CALL_OW 302
17805: IFFALSE 17819
// Say ( Gleb , DAmAttackStart-Glb-1 ) ;
17807: LD_EXP 60
17811: PPUSH
17812: LD_STRING DAmAttackStart-Glb-1
17814: PPUSH
17815: CALL_OW 88
// end else
17819: GO 17833
// Say ( Burlak , DAmAttackStart-Bur-2 ) ;
17821: LD_EXP 57
17825: PPUSH
17826: LD_STRING DAmAttackStart-Bur-2
17828: PPUSH
17829: CALL_OW 88
// ChangeMissionObjectives ( MEnemy ) ;
17833: LD_STRING MEnemy
17835: PPUSH
17836: CALL_OW 337
// end ; wait ( waveCooldown ) ;
17840: LD_EXP 50
17844: PPUSH
17845: CALL_OW 67
// end ;
17849: GO 17747
17851: POP
17852: POP
// end ;
17853: PPOPN 1
17855: END
// every 0 0$1 trigger currentAmWave = 1 do
17856: LD_EXP 85
17860: PUSH
17861: LD_INT 1
17863: EQUAL
17864: IFFALSE 17953
17866: GO 17868
17868: DISABLE
// Attack ( [ 0 , amAttackTeam , [ [ 115 , 42 ] , [ 51 , 67 ] ] , [ 0 , 0 , 0 , 1 , 1 , 1 , 0 , 0 , 1 , 0 ] ] ) ;
17869: LD_INT 0
17871: PUSH
17872: LD_EXP 78
17876: PUSH
17877: LD_INT 115
17879: PUSH
17880: LD_INT 42
17882: PUSH
17883: EMPTY
17884: LIST
17885: LIST
17886: PUSH
17887: LD_INT 51
17889: PUSH
17890: LD_INT 67
17892: PUSH
17893: EMPTY
17894: LIST
17895: LIST
17896: PUSH
17897: EMPTY
17898: LIST
17899: LIST
17900: PUSH
17901: LD_INT 0
17903: PUSH
17904: LD_INT 0
17906: PUSH
17907: LD_INT 0
17909: PUSH
17910: LD_INT 1
17912: PUSH
17913: LD_INT 1
17915: PUSH
17916: LD_INT 1
17918: PUSH
17919: LD_INT 0
17921: PUSH
17922: LD_INT 0
17924: PUSH
17925: LD_INT 1
17927: PUSH
17928: LD_INT 0
17930: PUSH
17931: EMPTY
17932: LIST
17933: LIST
17934: LIST
17935: LIST
17936: LIST
17937: LIST
17938: LIST
17939: LIST
17940: LIST
17941: LIST
17942: PUSH
17943: EMPTY
17944: LIST
17945: LIST
17946: LIST
17947: LIST
17948: PPUSH
17949: CALL 73735 0 1
17953: END
// every 0 0$1 trigger currentAmWave = 2 do
17954: LD_EXP 85
17958: PUSH
17959: LD_INT 2
17961: EQUAL
17962: IFFALSE 18051
17964: GO 17966
17966: DISABLE
// Attack ( [ 0 , amAttackTeam , [ [ 115 , 42 ] , [ 51 , 67 ] ] , [ 0 , 0 , 0 , 1 , 1 , 1 , 0 , 0 , 1 , 0 ] ] ) ;
17967: LD_INT 0
17969: PUSH
17970: LD_EXP 78
17974: PUSH
17975: LD_INT 115
17977: PUSH
17978: LD_INT 42
17980: PUSH
17981: EMPTY
17982: LIST
17983: LIST
17984: PUSH
17985: LD_INT 51
17987: PUSH
17988: LD_INT 67
17990: PUSH
17991: EMPTY
17992: LIST
17993: LIST
17994: PUSH
17995: EMPTY
17996: LIST
17997: LIST
17998: PUSH
17999: LD_INT 0
18001: PUSH
18002: LD_INT 0
18004: PUSH
18005: LD_INT 0
18007: PUSH
18008: LD_INT 1
18010: PUSH
18011: LD_INT 1
18013: PUSH
18014: LD_INT 1
18016: PUSH
18017: LD_INT 0
18019: PUSH
18020: LD_INT 0
18022: PUSH
18023: LD_INT 1
18025: PUSH
18026: LD_INT 0
18028: PUSH
18029: EMPTY
18030: LIST
18031: LIST
18032: LIST
18033: LIST
18034: LIST
18035: LIST
18036: LIST
18037: LIST
18038: LIST
18039: LIST
18040: PUSH
18041: EMPTY
18042: LIST
18043: LIST
18044: LIST
18045: LIST
18046: PPUSH
18047: CALL 73735 0 1
18051: END
// every 0 0$1 trigger currentAmWave = 3 do
18052: LD_EXP 85
18056: PUSH
18057: LD_INT 3
18059: EQUAL
18060: IFFALSE 18149
18062: GO 18064
18064: DISABLE
// Attack ( [ 0 , amAttackTeam , [ [ 115 , 42 ] , [ 51 , 67 ] ] , [ 0 , 0 , 0 , 1 , 1 , 1 , 0 , 0 , 1 , 0 ] ] ) ;
18065: LD_INT 0
18067: PUSH
18068: LD_EXP 78
18072: PUSH
18073: LD_INT 115
18075: PUSH
18076: LD_INT 42
18078: PUSH
18079: EMPTY
18080: LIST
18081: LIST
18082: PUSH
18083: LD_INT 51
18085: PUSH
18086: LD_INT 67
18088: PUSH
18089: EMPTY
18090: LIST
18091: LIST
18092: PUSH
18093: EMPTY
18094: LIST
18095: LIST
18096: PUSH
18097: LD_INT 0
18099: PUSH
18100: LD_INT 0
18102: PUSH
18103: LD_INT 0
18105: PUSH
18106: LD_INT 1
18108: PUSH
18109: LD_INT 1
18111: PUSH
18112: LD_INT 1
18114: PUSH
18115: LD_INT 0
18117: PUSH
18118: LD_INT 0
18120: PUSH
18121: LD_INT 1
18123: PUSH
18124: LD_INT 0
18126: PUSH
18127: EMPTY
18128: LIST
18129: LIST
18130: LIST
18131: LIST
18132: LIST
18133: LIST
18134: LIST
18135: LIST
18136: LIST
18137: LIST
18138: PUSH
18139: EMPTY
18140: LIST
18141: LIST
18142: LIST
18143: LIST
18144: PPUSH
18145: CALL 73735 0 1
18149: END
// every 0 0$1 trigger KurtAttack do var i ;
18150: LD_EXP 25
18154: IFFALSE 18275
18156: GO 18158
18158: DISABLE
18159: LD_INT 0
18161: PPUSH
// begin currentArWave = 0 ;
18162: LD_ADDR_EXP 86
18166: PUSH
18167: LD_INT 0
18169: ST_TO_ADDR
// wait ( firstAttackDelay ) ;
18170: LD_EXP 49
18174: PPUSH
18175: CALL_OW 67
// for i := 1 to KurtAttackWaves do
18179: LD_ADDR_VAR 0 1
18183: PUSH
18184: DOUBLE
18185: LD_INT 1
18187: DEC
18188: ST_TO_ADDR
18189: LD_EXP 47
18193: PUSH
18194: FOR_TO
18195: IFFALSE 18273
// begin if KurtAttack and IsOK ( Heike ) then
18197: LD_EXP 25
18201: PUSH
18202: LD_EXP 79
18206: PPUSH
18207: CALL_OW 302
18211: AND
18212: IFFALSE 18271
// begin SpawnArAttackTeam ;
18214: CALL 4285 0 0
// currentArWave = currentArWave + 1 ;
18218: LD_ADDR_EXP 86
18222: PUSH
18223: LD_EXP 86
18227: PUSH
18228: LD_INT 1
18230: PLUS
18231: ST_TO_ADDR
// if currentArWave = 2 then
18232: LD_EXP 86
18236: PUSH
18237: LD_INT 2
18239: EQUAL
18240: IFFALSE 18262
// begin SayRadio ( Kurt , DMercAttack-Kurt-1 ) ;
18242: LD_EXP 80
18246: PPUSH
18247: LD_STRING DMercAttack-Kurt-1
18249: PPUSH
18250: CALL_OW 94
// canSendHeike = true ;
18254: LD_ADDR_EXP 28
18258: PUSH
18259: LD_INT 1
18261: ST_TO_ADDR
// end ; wait ( waveCooldown ) ;
18262: LD_EXP 50
18266: PPUSH
18267: CALL_OW 67
// end ; end ;
18271: GO 18194
18273: POP
18274: POP
// end ;
18275: PPOPN 1
18277: END
// every 0 0$1 trigger currentArWave = 1 do
18278: LD_EXP 86
18282: PUSH
18283: LD_INT 1
18285: EQUAL
18286: IFFALSE 18375
18288: GO 18290
18290: DISABLE
// Attack ( [ 0 , arAttackTeam , [ [ 115 , 42 ] , [ 51 , 67 ] ] , [ 0 , 0 , 0 , 1 , 1 , 1 , 0 , 0 , 1 , 0 ] ] ) ;
18291: LD_INT 0
18293: PUSH
18294: LD_EXP 84
18298: PUSH
18299: LD_INT 115
18301: PUSH
18302: LD_INT 42
18304: PUSH
18305: EMPTY
18306: LIST
18307: LIST
18308: PUSH
18309: LD_INT 51
18311: PUSH
18312: LD_INT 67
18314: PUSH
18315: EMPTY
18316: LIST
18317: LIST
18318: PUSH
18319: EMPTY
18320: LIST
18321: LIST
18322: PUSH
18323: LD_INT 0
18325: PUSH
18326: LD_INT 0
18328: PUSH
18329: LD_INT 0
18331: PUSH
18332: LD_INT 1
18334: PUSH
18335: LD_INT 1
18337: PUSH
18338: LD_INT 1
18340: PUSH
18341: LD_INT 0
18343: PUSH
18344: LD_INT 0
18346: PUSH
18347: LD_INT 1
18349: PUSH
18350: LD_INT 0
18352: PUSH
18353: EMPTY
18354: LIST
18355: LIST
18356: LIST
18357: LIST
18358: LIST
18359: LIST
18360: LIST
18361: LIST
18362: LIST
18363: LIST
18364: PUSH
18365: EMPTY
18366: LIST
18367: LIST
18368: LIST
18369: LIST
18370: PPUSH
18371: CALL 73735 0 1
18375: END
// every 0 0$1 trigger currentArWave = 2 do
18376: LD_EXP 86
18380: PUSH
18381: LD_INT 2
18383: EQUAL
18384: IFFALSE 18473
18386: GO 18388
18388: DISABLE
// Attack ( [ 0 , arAttackTeam , [ [ 115 , 42 ] , [ 51 , 67 ] ] , [ 0 , 0 , 0 , 1 , 1 , 1 , 0 , 0 , 1 , 0 ] ] ) ;
18389: LD_INT 0
18391: PUSH
18392: LD_EXP 84
18396: PUSH
18397: LD_INT 115
18399: PUSH
18400: LD_INT 42
18402: PUSH
18403: EMPTY
18404: LIST
18405: LIST
18406: PUSH
18407: LD_INT 51
18409: PUSH
18410: LD_INT 67
18412: PUSH
18413: EMPTY
18414: LIST
18415: LIST
18416: PUSH
18417: EMPTY
18418: LIST
18419: LIST
18420: PUSH
18421: LD_INT 0
18423: PUSH
18424: LD_INT 0
18426: PUSH
18427: LD_INT 0
18429: PUSH
18430: LD_INT 1
18432: PUSH
18433: LD_INT 1
18435: PUSH
18436: LD_INT 1
18438: PUSH
18439: LD_INT 0
18441: PUSH
18442: LD_INT 0
18444: PUSH
18445: LD_INT 1
18447: PUSH
18448: LD_INT 0
18450: PUSH
18451: EMPTY
18452: LIST
18453: LIST
18454: LIST
18455: LIST
18456: LIST
18457: LIST
18458: LIST
18459: LIST
18460: LIST
18461: LIST
18462: PUSH
18463: EMPTY
18464: LIST
18465: LIST
18466: LIST
18467: LIST
18468: PPUSH
18469: CALL 73735 0 1
18473: END
// every 0 0$1 trigger currentArWave = 3 do
18474: LD_EXP 86
18478: PUSH
18479: LD_INT 3
18481: EQUAL
18482: IFFALSE 18571
18484: GO 18486
18486: DISABLE
// Attack ( [ 0 , arAttackTeam , [ [ 115 , 42 ] , [ 51 , 67 ] ] , [ 0 , 0 , 0 , 1 , 1 , 1 , 0 , 0 , 1 , 0 ] ] ) ;
18487: LD_INT 0
18489: PUSH
18490: LD_EXP 84
18494: PUSH
18495: LD_INT 115
18497: PUSH
18498: LD_INT 42
18500: PUSH
18501: EMPTY
18502: LIST
18503: LIST
18504: PUSH
18505: LD_INT 51
18507: PUSH
18508: LD_INT 67
18510: PUSH
18511: EMPTY
18512: LIST
18513: LIST
18514: PUSH
18515: EMPTY
18516: LIST
18517: LIST
18518: PUSH
18519: LD_INT 0
18521: PUSH
18522: LD_INT 0
18524: PUSH
18525: LD_INT 0
18527: PUSH
18528: LD_INT 1
18530: PUSH
18531: LD_INT 1
18533: PUSH
18534: LD_INT 1
18536: PUSH
18537: LD_INT 0
18539: PUSH
18540: LD_INT 0
18542: PUSH
18543: LD_INT 1
18545: PUSH
18546: LD_INT 0
18548: PUSH
18549: EMPTY
18550: LIST
18551: LIST
18552: LIST
18553: LIST
18554: LIST
18555: LIST
18556: LIST
18557: LIST
18558: LIST
18559: LIST
18560: PUSH
18561: EMPTY
18562: LIST
18563: LIST
18564: LIST
18565: LIST
18566: PPUSH
18567: CALL 73735 0 1
18571: END
// every 0 0$1 trigger currentArWave = 4 do
18572: LD_EXP 86
18576: PUSH
18577: LD_INT 4
18579: EQUAL
18580: IFFALSE 18669
18582: GO 18584
18584: DISABLE
// Attack ( [ 0 , arAttackTeam , [ [ 115 , 42 ] , [ 51 , 67 ] ] , [ 0 , 0 , 0 , 1 , 1 , 1 , 0 , 0 , 1 , 0 ] ] ) ;
18585: LD_INT 0
18587: PUSH
18588: LD_EXP 84
18592: PUSH
18593: LD_INT 115
18595: PUSH
18596: LD_INT 42
18598: PUSH
18599: EMPTY
18600: LIST
18601: LIST
18602: PUSH
18603: LD_INT 51
18605: PUSH
18606: LD_INT 67
18608: PUSH
18609: EMPTY
18610: LIST
18611: LIST
18612: PUSH
18613: EMPTY
18614: LIST
18615: LIST
18616: PUSH
18617: LD_INT 0
18619: PUSH
18620: LD_INT 0
18622: PUSH
18623: LD_INT 0
18625: PUSH
18626: LD_INT 1
18628: PUSH
18629: LD_INT 1
18631: PUSH
18632: LD_INT 1
18634: PUSH
18635: LD_INT 0
18637: PUSH
18638: LD_INT 0
18640: PUSH
18641: LD_INT 1
18643: PUSH
18644: LD_INT 0
18646: PUSH
18647: EMPTY
18648: LIST
18649: LIST
18650: LIST
18651: LIST
18652: LIST
18653: LIST
18654: LIST
18655: LIST
18656: LIST
18657: LIST
18658: PUSH
18659: EMPTY
18660: LIST
18661: LIST
18662: LIST
18663: LIST
18664: PPUSH
18665: CALL 73735 0 1
18669: END
// every 0 0$1 trigger currentArWave = 5 do
18670: LD_EXP 86
18674: PUSH
18675: LD_INT 5
18677: EQUAL
18678: IFFALSE 18767
18680: GO 18682
18682: DISABLE
// Attack ( [ 0 , arAttackTeam , [ [ 115 , 42 ] , [ 51 , 67 ] ] , [ 0 , 0 , 0 , 1 , 1 , 1 , 0 , 0 , 1 , 0 ] ] ) ; end_of_file
18683: LD_INT 0
18685: PUSH
18686: LD_EXP 84
18690: PUSH
18691: LD_INT 115
18693: PUSH
18694: LD_INT 42
18696: PUSH
18697: EMPTY
18698: LIST
18699: LIST
18700: PUSH
18701: LD_INT 51
18703: PUSH
18704: LD_INT 67
18706: PUSH
18707: EMPTY
18708: LIST
18709: LIST
18710: PUSH
18711: EMPTY
18712: LIST
18713: LIST
18714: PUSH
18715: LD_INT 0
18717: PUSH
18718: LD_INT 0
18720: PUSH
18721: LD_INT 0
18723: PUSH
18724: LD_INT 1
18726: PUSH
18727: LD_INT 1
18729: PUSH
18730: LD_INT 1
18732: PUSH
18733: LD_INT 0
18735: PUSH
18736: LD_INT 0
18738: PUSH
18739: LD_INT 1
18741: PUSH
18742: LD_INT 0
18744: PUSH
18745: EMPTY
18746: LIST
18747: LIST
18748: LIST
18749: LIST
18750: LIST
18751: LIST
18752: LIST
18753: LIST
18754: LIST
18755: LIST
18756: PUSH
18757: EMPTY
18758: LIST
18759: LIST
18760: LIST
18761: LIST
18762: PPUSH
18763: CALL 73735 0 1
18767: END
// every 0 0$1 do var arVehs , arVeh , nearPlayerUnit ;
18768: GO 18770
18770: DISABLE
18771: LD_INT 0
18773: PPUSH
18774: PPUSH
18775: PPUSH
// begin enable ;
18776: ENABLE
// arVehs = FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_vehicle ] , [ f_empty ] ] ) ;
18777: LD_ADDR_VAR 0 1
18781: PUSH
18782: LD_INT 22
18784: PUSH
18785: LD_INT 8
18787: PUSH
18788: EMPTY
18789: LIST
18790: LIST
18791: PUSH
18792: LD_INT 21
18794: PUSH
18795: LD_INT 2
18797: PUSH
18798: EMPTY
18799: LIST
18800: LIST
18801: PUSH
18802: LD_INT 58
18804: PUSH
18805: EMPTY
18806: LIST
18807: PUSH
18808: EMPTY
18809: LIST
18810: LIST
18811: LIST
18812: PPUSH
18813: CALL_OW 69
18817: ST_TO_ADDR
// if not arVehs or not GetAttitude ( 3 , 8 ) = att_enemy then
18818: LD_VAR 0 1
18822: NOT
18823: PUSH
18824: LD_INT 3
18826: PPUSH
18827: LD_INT 8
18829: PPUSH
18830: CALL_OW 81
18834: PUSH
18835: LD_INT 2
18837: EQUAL
18838: NOT
18839: OR
18840: IFFALSE 18844
// exit ;
18842: GO 18934
// for arVeh in arVehs do
18844: LD_ADDR_VAR 0 2
18848: PUSH
18849: LD_VAR 0 1
18853: PUSH
18854: FOR_IN
18855: IFFALSE 18932
// begin nearPlayerUnit = NearestUnitToUnit ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) , arVeh ) ;
18857: LD_ADDR_VAR 0 3
18861: PUSH
18862: LD_INT 22
18864: PUSH
18865: LD_INT 3
18867: PUSH
18868: EMPTY
18869: LIST
18870: LIST
18871: PUSH
18872: LD_INT 21
18874: PUSH
18875: LD_INT 1
18877: PUSH
18878: EMPTY
18879: LIST
18880: LIST
18881: PUSH
18882: EMPTY
18883: LIST
18884: LIST
18885: PPUSH
18886: CALL_OW 69
18890: PPUSH
18891: LD_VAR 0 2
18895: PPUSH
18896: CALL_OW 74
18900: ST_TO_ADDR
// if GetDistUnits ( nearPlayerUnit , arVeh ) <= 2 then
18901: LD_VAR 0 3
18905: PPUSH
18906: LD_VAR 0 2
18910: PPUSH
18911: CALL_OW 296
18915: PUSH
18916: LD_INT 2
18918: LESSEQUAL
18919: IFFALSE 18930
// ComSelfDestruction ( arVeh ) ;
18921: LD_VAR 0 2
18925: PPUSH
18926: CALL_OW 577
// end ;
18930: GO 18854
18932: POP
18933: POP
// end ;
18934: PPOPN 3
18936: END
// every 0 0$1 trigger forceStopKurtAttack do
18937: LD_EXP 27
18941: IFFALSE 19007
18943: GO 18945
18945: DISABLE
// begin KurtAttack = false ;
18946: LD_ADDR_EXP 25
18950: PUSH
18951: LD_INT 0
18953: ST_TO_ADDR
// allowExitFromMap = 4 ;
18954: LD_ADDR_EXP 18
18958: PUSH
18959: LD_INT 4
18961: ST_TO_ADDR
// SetAttitude ( 3 , 8 , att_friend , true ) ;
18962: LD_INT 3
18964: PPUSH
18965: LD_INT 8
18967: PPUSH
18968: LD_INT 1
18970: PPUSH
18971: LD_INT 1
18973: PPUSH
18974: CALL_OW 80
// arAttackTeam = [ ] ;
18978: LD_ADDR_EXP 84
18982: PUSH
18983: EMPTY
18984: ST_TO_ADDR
// ComMoveToArea ( FilterAllUnits ( [ f_side , 8 ] ) , KurtExitMapArea ) ;
18985: LD_INT 22
18987: PUSH
18988: LD_INT 8
18990: PUSH
18991: EMPTY
18992: LIST
18993: LIST
18994: PPUSH
18995: CALL_OW 69
18999: PPUSH
19000: LD_INT 11
19002: PPUSH
19003: CALL_OW 113
// end ; end_of_file end_of_file
19007: END
// every 0 0$01 do var timer , cratesSpawned ;
19008: GO 19010
19010: DISABLE
19011: LD_INT 0
19013: PPUSH
19014: PPUSH
// begin timer := 1 1$30 ;
19015: LD_ADDR_VAR 0 1
19019: PUSH
19020: LD_INT 3150
19022: ST_TO_ADDR
// repeat wait ( timer ) ;
19023: LD_VAR 0 1
19027: PPUSH
19028: CALL_OW 67
// if cratesSpawned >= 6 and cratesSpawned < 18 then
19032: LD_VAR 0 2
19036: PUSH
19037: LD_INT 6
19039: GREATEREQUAL
19040: PUSH
19041: LD_VAR 0 2
19045: PUSH
19046: LD_INT 18
19048: LESS
19049: AND
19050: IFFALSE 19066
// timer := timer + 0 0$3 ;
19052: LD_ADDR_VAR 0 1
19056: PUSH
19057: LD_VAR 0 1
19061: PUSH
19062: LD_INT 105
19064: PLUS
19065: ST_TO_ADDR
// if cratesSpawned >= 18 then
19066: LD_VAR 0 2
19070: PUSH
19071: LD_INT 18
19073: GREATEREQUAL
19074: IFFALSE 19090
// timer := timer + 0 0$9 ;
19076: LD_ADDR_VAR 0 1
19080: PUSH
19081: LD_VAR 0 1
19085: PUSH
19086: LD_INT 315
19088: PLUS
19089: ST_TO_ADDR
// if timer > 3 3$00 then
19090: LD_VAR 0 1
19094: PUSH
19095: LD_INT 6300
19097: GREATER
19098: IFFALSE 19108
// timer := 0 0$50 ;
19100: LD_ADDR_VAR 0 1
19104: PUSH
19105: LD_INT 1750
19107: ST_TO_ADDR
// CreateCratesArea ( rand ( 3 , 5 ) , CratesSpawnArea , true ) ;
19108: LD_INT 3
19110: PPUSH
19111: LD_INT 5
19113: PPUSH
19114: CALL_OW 12
19118: PPUSH
19119: LD_INT 15
19121: PPUSH
19122: LD_INT 1
19124: PPUSH
19125: CALL_OW 55
// cratesSpawned = cratesSpawned + 1 ;
19129: LD_ADDR_VAR 0 2
19133: PUSH
19134: LD_VAR 0 2
19138: PUSH
19139: LD_INT 1
19141: PLUS
19142: ST_TO_ADDR
// until false ;
19143: LD_INT 0
19145: IFFALSE 19023
// end ; end_of_file
19147: PPOPN 2
19149: END
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
19150: LD_INT 0
19152: PPUSH
19153: PPUSH
// if exist_mode then
19154: LD_VAR 0 2
19158: IFFALSE 19183
// unit := CreateCharacter ( prefix & ident ) else
19160: LD_ADDR_VAR 0 5
19164: PUSH
19165: LD_VAR 0 3
19169: PUSH
19170: LD_VAR 0 1
19174: STR
19175: PPUSH
19176: CALL_OW 34
19180: ST_TO_ADDR
19181: GO 19198
// unit := NewCharacter ( ident ) ;
19183: LD_ADDR_VAR 0 5
19187: PUSH
19188: LD_VAR 0 1
19192: PPUSH
19193: CALL_OW 25
19197: ST_TO_ADDR
// result := unit ;
19198: LD_ADDR_VAR 0 4
19202: PUSH
19203: LD_VAR 0 5
19207: ST_TO_ADDR
// end ;
19208: LD_VAR 0 4
19212: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
19213: LD_INT 0
19215: PPUSH
19216: PPUSH
// if not side or not nation then
19217: LD_VAR 0 1
19221: NOT
19222: PUSH
19223: LD_VAR 0 2
19227: NOT
19228: OR
19229: IFFALSE 19233
// exit ;
19231: GO 19997
// case nation of nation_american :
19233: LD_VAR 0 2
19237: PUSH
19238: LD_INT 1
19240: DOUBLE
19241: EQUAL
19242: IFTRUE 19246
19244: GO 19460
19246: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 86 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 , 82 , 83 , 84 , 85 , 86 ] ; nation_arabian :
19247: LD_ADDR_VAR 0 4
19251: PUSH
19252: LD_INT 35
19254: PUSH
19255: LD_INT 45
19257: PUSH
19258: LD_INT 46
19260: PUSH
19261: LD_INT 47
19263: PUSH
19264: LD_INT 82
19266: PUSH
19267: LD_INT 83
19269: PUSH
19270: LD_INT 84
19272: PUSH
19273: LD_INT 85
19275: PUSH
19276: LD_INT 86
19278: PUSH
19279: LD_INT 1
19281: PUSH
19282: LD_INT 2
19284: PUSH
19285: LD_INT 6
19287: PUSH
19288: LD_INT 15
19290: PUSH
19291: LD_INT 16
19293: PUSH
19294: LD_INT 7
19296: PUSH
19297: LD_INT 12
19299: PUSH
19300: LD_INT 13
19302: PUSH
19303: LD_INT 10
19305: PUSH
19306: LD_INT 14
19308: PUSH
19309: LD_INT 20
19311: PUSH
19312: LD_INT 21
19314: PUSH
19315: LD_INT 22
19317: PUSH
19318: LD_INT 25
19320: PUSH
19321: LD_INT 32
19323: PUSH
19324: LD_INT 27
19326: PUSH
19327: LD_INT 36
19329: PUSH
19330: LD_INT 69
19332: PUSH
19333: LD_INT 39
19335: PUSH
19336: LD_INT 34
19338: PUSH
19339: LD_INT 40
19341: PUSH
19342: LD_INT 48
19344: PUSH
19345: LD_INT 49
19347: PUSH
19348: LD_INT 50
19350: PUSH
19351: LD_INT 51
19353: PUSH
19354: LD_INT 52
19356: PUSH
19357: LD_INT 53
19359: PUSH
19360: LD_INT 54
19362: PUSH
19363: LD_INT 55
19365: PUSH
19366: LD_INT 56
19368: PUSH
19369: LD_INT 57
19371: PUSH
19372: LD_INT 58
19374: PUSH
19375: LD_INT 59
19377: PUSH
19378: LD_INT 60
19380: PUSH
19381: LD_INT 61
19383: PUSH
19384: LD_INT 62
19386: PUSH
19387: LD_INT 80
19389: PUSH
19390: LD_INT 82
19392: PUSH
19393: LD_INT 83
19395: PUSH
19396: LD_INT 84
19398: PUSH
19399: LD_INT 85
19401: PUSH
19402: LD_INT 86
19404: PUSH
19405: EMPTY
19406: LIST
19407: LIST
19408: LIST
19409: LIST
19410: LIST
19411: LIST
19412: LIST
19413: LIST
19414: LIST
19415: LIST
19416: LIST
19417: LIST
19418: LIST
19419: LIST
19420: LIST
19421: LIST
19422: LIST
19423: LIST
19424: LIST
19425: LIST
19426: LIST
19427: LIST
19428: LIST
19429: LIST
19430: LIST
19431: LIST
19432: LIST
19433: LIST
19434: LIST
19435: LIST
19436: LIST
19437: LIST
19438: LIST
19439: LIST
19440: LIST
19441: LIST
19442: LIST
19443: LIST
19444: LIST
19445: LIST
19446: LIST
19447: LIST
19448: LIST
19449: LIST
19450: LIST
19451: LIST
19452: LIST
19453: LIST
19454: LIST
19455: LIST
19456: LIST
19457: ST_TO_ADDR
19458: GO 19921
19460: LD_INT 2
19462: DOUBLE
19463: EQUAL
19464: IFTRUE 19468
19466: GO 19690
19468: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 87 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 , 82 , 83 , 84 , 85 , 87 ] ; nation_russian :
19469: LD_ADDR_VAR 0 4
19473: PUSH
19474: LD_INT 35
19476: PUSH
19477: LD_INT 45
19479: PUSH
19480: LD_INT 46
19482: PUSH
19483: LD_INT 47
19485: PUSH
19486: LD_INT 82
19488: PUSH
19489: LD_INT 83
19491: PUSH
19492: LD_INT 84
19494: PUSH
19495: LD_INT 85
19497: PUSH
19498: LD_INT 87
19500: PUSH
19501: LD_INT 70
19503: PUSH
19504: LD_INT 1
19506: PUSH
19507: LD_INT 11
19509: PUSH
19510: LD_INT 3
19512: PUSH
19513: LD_INT 4
19515: PUSH
19516: LD_INT 5
19518: PUSH
19519: LD_INT 6
19521: PUSH
19522: LD_INT 15
19524: PUSH
19525: LD_INT 18
19527: PUSH
19528: LD_INT 7
19530: PUSH
19531: LD_INT 17
19533: PUSH
19534: LD_INT 8
19536: PUSH
19537: LD_INT 20
19539: PUSH
19540: LD_INT 21
19542: PUSH
19543: LD_INT 22
19545: PUSH
19546: LD_INT 72
19548: PUSH
19549: LD_INT 26
19551: PUSH
19552: LD_INT 69
19554: PUSH
19555: LD_INT 39
19557: PUSH
19558: LD_INT 40
19560: PUSH
19561: LD_INT 41
19563: PUSH
19564: LD_INT 42
19566: PUSH
19567: LD_INT 43
19569: PUSH
19570: LD_INT 48
19572: PUSH
19573: LD_INT 49
19575: PUSH
19576: LD_INT 50
19578: PUSH
19579: LD_INT 51
19581: PUSH
19582: LD_INT 52
19584: PUSH
19585: LD_INT 53
19587: PUSH
19588: LD_INT 54
19590: PUSH
19591: LD_INT 55
19593: PUSH
19594: LD_INT 56
19596: PUSH
19597: LD_INT 60
19599: PUSH
19600: LD_INT 61
19602: PUSH
19603: LD_INT 62
19605: PUSH
19606: LD_INT 66
19608: PUSH
19609: LD_INT 67
19611: PUSH
19612: LD_INT 68
19614: PUSH
19615: LD_INT 81
19617: PUSH
19618: LD_INT 82
19620: PUSH
19621: LD_INT 83
19623: PUSH
19624: LD_INT 84
19626: PUSH
19627: LD_INT 85
19629: PUSH
19630: LD_INT 87
19632: PUSH
19633: EMPTY
19634: LIST
19635: LIST
19636: LIST
19637: LIST
19638: LIST
19639: LIST
19640: LIST
19641: LIST
19642: LIST
19643: LIST
19644: LIST
19645: LIST
19646: LIST
19647: LIST
19648: LIST
19649: LIST
19650: LIST
19651: LIST
19652: LIST
19653: LIST
19654: LIST
19655: LIST
19656: LIST
19657: LIST
19658: LIST
19659: LIST
19660: LIST
19661: LIST
19662: LIST
19663: LIST
19664: LIST
19665: LIST
19666: LIST
19667: LIST
19668: LIST
19669: LIST
19670: LIST
19671: LIST
19672: LIST
19673: LIST
19674: LIST
19675: LIST
19676: LIST
19677: LIST
19678: LIST
19679: LIST
19680: LIST
19681: LIST
19682: LIST
19683: LIST
19684: LIST
19685: LIST
19686: LIST
19687: ST_TO_ADDR
19688: GO 19921
19690: LD_INT 3
19692: DOUBLE
19693: EQUAL
19694: IFTRUE 19698
19696: GO 19920
19698: POP
// result := [ 46 , 47 , 1 , 2 , 82 , 83 , 84 , 85 , 86 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 , 82 , 83 , 84 , 85 , 86 ] ; end ;
19699: LD_ADDR_VAR 0 4
19703: PUSH
19704: LD_INT 46
19706: PUSH
19707: LD_INT 47
19709: PUSH
19710: LD_INT 1
19712: PUSH
19713: LD_INT 2
19715: PUSH
19716: LD_INT 82
19718: PUSH
19719: LD_INT 83
19721: PUSH
19722: LD_INT 84
19724: PUSH
19725: LD_INT 85
19727: PUSH
19728: LD_INT 86
19730: PUSH
19731: LD_INT 11
19733: PUSH
19734: LD_INT 9
19736: PUSH
19737: LD_INT 20
19739: PUSH
19740: LD_INT 19
19742: PUSH
19743: LD_INT 21
19745: PUSH
19746: LD_INT 24
19748: PUSH
19749: LD_INT 22
19751: PUSH
19752: LD_INT 25
19754: PUSH
19755: LD_INT 28
19757: PUSH
19758: LD_INT 29
19760: PUSH
19761: LD_INT 30
19763: PUSH
19764: LD_INT 31
19766: PUSH
19767: LD_INT 37
19769: PUSH
19770: LD_INT 38
19772: PUSH
19773: LD_INT 32
19775: PUSH
19776: LD_INT 27
19778: PUSH
19779: LD_INT 33
19781: PUSH
19782: LD_INT 69
19784: PUSH
19785: LD_INT 39
19787: PUSH
19788: LD_INT 34
19790: PUSH
19791: LD_INT 40
19793: PUSH
19794: LD_INT 71
19796: PUSH
19797: LD_INT 23
19799: PUSH
19800: LD_INT 44
19802: PUSH
19803: LD_INT 48
19805: PUSH
19806: LD_INT 49
19808: PUSH
19809: LD_INT 50
19811: PUSH
19812: LD_INT 51
19814: PUSH
19815: LD_INT 52
19817: PUSH
19818: LD_INT 53
19820: PUSH
19821: LD_INT 54
19823: PUSH
19824: LD_INT 55
19826: PUSH
19827: LD_INT 56
19829: PUSH
19830: LD_INT 57
19832: PUSH
19833: LD_INT 58
19835: PUSH
19836: LD_INT 59
19838: PUSH
19839: LD_INT 63
19841: PUSH
19842: LD_INT 64
19844: PUSH
19845: LD_INT 65
19847: PUSH
19848: LD_INT 82
19850: PUSH
19851: LD_INT 83
19853: PUSH
19854: LD_INT 84
19856: PUSH
19857: LD_INT 85
19859: PUSH
19860: LD_INT 86
19862: PUSH
19863: EMPTY
19864: LIST
19865: LIST
19866: LIST
19867: LIST
19868: LIST
19869: LIST
19870: LIST
19871: LIST
19872: LIST
19873: LIST
19874: LIST
19875: LIST
19876: LIST
19877: LIST
19878: LIST
19879: LIST
19880: LIST
19881: LIST
19882: LIST
19883: LIST
19884: LIST
19885: LIST
19886: LIST
19887: LIST
19888: LIST
19889: LIST
19890: LIST
19891: LIST
19892: LIST
19893: LIST
19894: LIST
19895: LIST
19896: LIST
19897: LIST
19898: LIST
19899: LIST
19900: LIST
19901: LIST
19902: LIST
19903: LIST
19904: LIST
19905: LIST
19906: LIST
19907: LIST
19908: LIST
19909: LIST
19910: LIST
19911: LIST
19912: LIST
19913: LIST
19914: LIST
19915: LIST
19916: LIST
19917: ST_TO_ADDR
19918: GO 19921
19920: POP
// if state > - 1 and state < 3 then
19921: LD_VAR 0 3
19925: PUSH
19926: LD_INT 1
19928: NEG
19929: GREATER
19930: PUSH
19931: LD_VAR 0 3
19935: PUSH
19936: LD_INT 3
19938: LESS
19939: AND
19940: IFFALSE 19997
// for i in result do
19942: LD_ADDR_VAR 0 5
19946: PUSH
19947: LD_VAR 0 4
19951: PUSH
19952: FOR_IN
19953: IFFALSE 19995
// if GetTech ( i , side ) <> state then
19955: LD_VAR 0 5
19959: PPUSH
19960: LD_VAR 0 1
19964: PPUSH
19965: CALL_OW 321
19969: PUSH
19970: LD_VAR 0 3
19974: NONEQUAL
19975: IFFALSE 19993
// result := result diff i ;
19977: LD_ADDR_VAR 0 4
19981: PUSH
19982: LD_VAR 0 4
19986: PUSH
19987: LD_VAR 0 5
19991: DIFF
19992: ST_TO_ADDR
19993: GO 19952
19995: POP
19996: POP
// end ;
19997: LD_VAR 0 4
20001: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
20002: LD_INT 0
20004: PPUSH
20005: PPUSH
20006: PPUSH
// result := true ;
20007: LD_ADDR_VAR 0 3
20011: PUSH
20012: LD_INT 1
20014: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
20015: LD_ADDR_VAR 0 5
20019: PUSH
20020: LD_VAR 0 2
20024: PPUSH
20025: CALL_OW 480
20029: ST_TO_ADDR
// if not tmp then
20030: LD_VAR 0 5
20034: NOT
20035: IFFALSE 20039
// exit ;
20037: GO 20088
// for i in tmp do
20039: LD_ADDR_VAR 0 4
20043: PUSH
20044: LD_VAR 0 5
20048: PUSH
20049: FOR_IN
20050: IFFALSE 20086
// if GetTech ( i , side ) <> state_researched then
20052: LD_VAR 0 4
20056: PPUSH
20057: LD_VAR 0 1
20061: PPUSH
20062: CALL_OW 321
20066: PUSH
20067: LD_INT 2
20069: NONEQUAL
20070: IFFALSE 20084
// begin result := false ;
20072: LD_ADDR_VAR 0 3
20076: PUSH
20077: LD_INT 0
20079: ST_TO_ADDR
// exit ;
20080: POP
20081: POP
20082: GO 20088
// end ;
20084: GO 20049
20086: POP
20087: POP
// end ;
20088: LD_VAR 0 3
20092: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
20093: LD_INT 0
20095: PPUSH
20096: PPUSH
20097: PPUSH
20098: PPUSH
20099: PPUSH
20100: PPUSH
20101: PPUSH
20102: PPUSH
20103: PPUSH
20104: PPUSH
20105: PPUSH
20106: PPUSH
20107: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
20108: LD_VAR 0 1
20112: NOT
20113: PUSH
20114: LD_VAR 0 1
20118: PPUSH
20119: CALL_OW 257
20123: PUSH
20124: LD_INT 9
20126: NONEQUAL
20127: OR
20128: IFFALSE 20132
// exit ;
20130: GO 20705
// side := GetSide ( unit ) ;
20132: LD_ADDR_VAR 0 9
20136: PUSH
20137: LD_VAR 0 1
20141: PPUSH
20142: CALL_OW 255
20146: ST_TO_ADDR
// tech_space := tech_spacanom ;
20147: LD_ADDR_VAR 0 12
20151: PUSH
20152: LD_INT 29
20154: ST_TO_ADDR
// tech_time := tech_taurad ;
20155: LD_ADDR_VAR 0 13
20159: PUSH
20160: LD_INT 28
20162: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
20163: LD_ADDR_VAR 0 11
20167: PUSH
20168: LD_VAR 0 1
20172: PPUSH
20173: CALL_OW 310
20177: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
20178: LD_VAR 0 11
20182: PPUSH
20183: CALL_OW 247
20187: PUSH
20188: LD_INT 2
20190: EQUAL
20191: IFFALSE 20195
// exit ;
20193: GO 20705
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
20195: LD_ADDR_VAR 0 8
20199: PUSH
20200: LD_INT 81
20202: PUSH
20203: LD_VAR 0 9
20207: PUSH
20208: EMPTY
20209: LIST
20210: LIST
20211: PUSH
20212: LD_INT 3
20214: PUSH
20215: LD_INT 21
20217: PUSH
20218: LD_INT 3
20220: PUSH
20221: EMPTY
20222: LIST
20223: LIST
20224: PUSH
20225: EMPTY
20226: LIST
20227: LIST
20228: PUSH
20229: EMPTY
20230: LIST
20231: LIST
20232: PPUSH
20233: CALL_OW 69
20237: ST_TO_ADDR
// if not tmp then
20238: LD_VAR 0 8
20242: NOT
20243: IFFALSE 20247
// exit ;
20245: GO 20705
// if in_unit then
20247: LD_VAR 0 11
20251: IFFALSE 20275
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
20253: LD_ADDR_VAR 0 10
20257: PUSH
20258: LD_VAR 0 8
20262: PPUSH
20263: LD_VAR 0 11
20267: PPUSH
20268: CALL_OW 74
20272: ST_TO_ADDR
20273: GO 20295
// enemy := NearestUnitToUnit ( tmp , unit ) ;
20275: LD_ADDR_VAR 0 10
20279: PUSH
20280: LD_VAR 0 8
20284: PPUSH
20285: LD_VAR 0 1
20289: PPUSH
20290: CALL_OW 74
20294: ST_TO_ADDR
// if not enemy then
20295: LD_VAR 0 10
20299: NOT
20300: IFFALSE 20304
// exit ;
20302: GO 20705
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
20304: LD_VAR 0 11
20308: PUSH
20309: LD_VAR 0 11
20313: PPUSH
20314: LD_VAR 0 10
20318: PPUSH
20319: CALL_OW 296
20323: PUSH
20324: LD_INT 13
20326: GREATER
20327: AND
20328: PUSH
20329: LD_VAR 0 1
20333: PPUSH
20334: LD_VAR 0 10
20338: PPUSH
20339: CALL_OW 296
20343: PUSH
20344: LD_INT 12
20346: GREATER
20347: OR
20348: IFFALSE 20352
// exit ;
20350: GO 20705
// missile := [ 1 ] ;
20352: LD_ADDR_VAR 0 14
20356: PUSH
20357: LD_INT 1
20359: PUSH
20360: EMPTY
20361: LIST
20362: ST_TO_ADDR
// if Researched ( side , tech_space ) then
20363: LD_VAR 0 9
20367: PPUSH
20368: LD_VAR 0 12
20372: PPUSH
20373: CALL_OW 325
20377: IFFALSE 20406
// missile := Insert ( missile , missile + 1 , 2 ) ;
20379: LD_ADDR_VAR 0 14
20383: PUSH
20384: LD_VAR 0 14
20388: PPUSH
20389: LD_VAR 0 14
20393: PUSH
20394: LD_INT 1
20396: PLUS
20397: PPUSH
20398: LD_INT 2
20400: PPUSH
20401: CALL_OW 2
20405: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
20406: LD_VAR 0 9
20410: PPUSH
20411: LD_VAR 0 13
20415: PPUSH
20416: CALL_OW 325
20420: PUSH
20421: LD_VAR 0 10
20425: PPUSH
20426: CALL_OW 255
20430: PPUSH
20431: LD_VAR 0 13
20435: PPUSH
20436: CALL_OW 325
20440: NOT
20441: AND
20442: IFFALSE 20471
// missile := Insert ( missile , missile + 1 , 3 ) ;
20444: LD_ADDR_VAR 0 14
20448: PUSH
20449: LD_VAR 0 14
20453: PPUSH
20454: LD_VAR 0 14
20458: PUSH
20459: LD_INT 1
20461: PLUS
20462: PPUSH
20463: LD_INT 3
20465: PPUSH
20466: CALL_OW 2
20470: ST_TO_ADDR
// if missile < 2 then
20471: LD_VAR 0 14
20475: PUSH
20476: LD_INT 2
20478: LESS
20479: IFFALSE 20483
// exit ;
20481: GO 20705
// x := GetX ( enemy ) ;
20483: LD_ADDR_VAR 0 4
20487: PUSH
20488: LD_VAR 0 10
20492: PPUSH
20493: CALL_OW 250
20497: ST_TO_ADDR
// y := GetY ( enemy ) ;
20498: LD_ADDR_VAR 0 5
20502: PUSH
20503: LD_VAR 0 10
20507: PPUSH
20508: CALL_OW 251
20512: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
20513: LD_ADDR_VAR 0 6
20517: PUSH
20518: LD_VAR 0 4
20522: PUSH
20523: LD_INT 1
20525: NEG
20526: PPUSH
20527: LD_INT 1
20529: PPUSH
20530: CALL_OW 12
20534: PLUS
20535: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
20536: LD_ADDR_VAR 0 7
20540: PUSH
20541: LD_VAR 0 5
20545: PUSH
20546: LD_INT 1
20548: NEG
20549: PPUSH
20550: LD_INT 1
20552: PPUSH
20553: CALL_OW 12
20557: PLUS
20558: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
20559: LD_VAR 0 6
20563: PPUSH
20564: LD_VAR 0 7
20568: PPUSH
20569: CALL_OW 488
20573: NOT
20574: IFFALSE 20596
// begin _x := x ;
20576: LD_ADDR_VAR 0 6
20580: PUSH
20581: LD_VAR 0 4
20585: ST_TO_ADDR
// _y := y ;
20586: LD_ADDR_VAR 0 7
20590: PUSH
20591: LD_VAR 0 5
20595: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
20596: LD_ADDR_VAR 0 3
20600: PUSH
20601: LD_INT 1
20603: PPUSH
20604: LD_VAR 0 14
20608: PPUSH
20609: CALL_OW 12
20613: ST_TO_ADDR
// case i of 1 :
20614: LD_VAR 0 3
20618: PUSH
20619: LD_INT 1
20621: DOUBLE
20622: EQUAL
20623: IFTRUE 20627
20625: GO 20644
20627: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
20628: LD_VAR 0 1
20632: PPUSH
20633: LD_VAR 0 10
20637: PPUSH
20638: CALL_OW 115
20642: GO 20705
20644: LD_INT 2
20646: DOUBLE
20647: EQUAL
20648: IFTRUE 20652
20650: GO 20674
20652: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
20653: LD_VAR 0 1
20657: PPUSH
20658: LD_VAR 0 6
20662: PPUSH
20663: LD_VAR 0 7
20667: PPUSH
20668: CALL_OW 153
20672: GO 20705
20674: LD_INT 3
20676: DOUBLE
20677: EQUAL
20678: IFTRUE 20682
20680: GO 20704
20682: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
20683: LD_VAR 0 1
20687: PPUSH
20688: LD_VAR 0 6
20692: PPUSH
20693: LD_VAR 0 7
20697: PPUSH
20698: CALL_OW 154
20702: GO 20705
20704: POP
// end ;
20705: LD_VAR 0 2
20709: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
20710: LD_INT 0
20712: PPUSH
20713: PPUSH
20714: PPUSH
20715: PPUSH
20716: PPUSH
20717: PPUSH
// if not unit or not building then
20718: LD_VAR 0 1
20722: NOT
20723: PUSH
20724: LD_VAR 0 2
20728: NOT
20729: OR
20730: IFFALSE 20734
// exit ;
20732: GO 20892
// x := GetX ( building ) ;
20734: LD_ADDR_VAR 0 5
20738: PUSH
20739: LD_VAR 0 2
20743: PPUSH
20744: CALL_OW 250
20748: ST_TO_ADDR
// y := GetY ( building ) ;
20749: LD_ADDR_VAR 0 6
20753: PUSH
20754: LD_VAR 0 2
20758: PPUSH
20759: CALL_OW 251
20763: ST_TO_ADDR
// for i = 0 to 5 do
20764: LD_ADDR_VAR 0 4
20768: PUSH
20769: DOUBLE
20770: LD_INT 0
20772: DEC
20773: ST_TO_ADDR
20774: LD_INT 5
20776: PUSH
20777: FOR_TO
20778: IFFALSE 20890
// begin _x := ShiftX ( x , i , 3 ) ;
20780: LD_ADDR_VAR 0 7
20784: PUSH
20785: LD_VAR 0 5
20789: PPUSH
20790: LD_VAR 0 4
20794: PPUSH
20795: LD_INT 3
20797: PPUSH
20798: CALL_OW 272
20802: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
20803: LD_ADDR_VAR 0 8
20807: PUSH
20808: LD_VAR 0 6
20812: PPUSH
20813: LD_VAR 0 4
20817: PPUSH
20818: LD_INT 3
20820: PPUSH
20821: CALL_OW 273
20825: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
20826: LD_VAR 0 7
20830: PPUSH
20831: LD_VAR 0 8
20835: PPUSH
20836: CALL_OW 488
20840: NOT
20841: IFFALSE 20845
// continue ;
20843: GO 20777
// if HexInfo ( _x , _y ) = 0 then
20845: LD_VAR 0 7
20849: PPUSH
20850: LD_VAR 0 8
20854: PPUSH
20855: CALL_OW 428
20859: PUSH
20860: LD_INT 0
20862: EQUAL
20863: IFFALSE 20888
// begin ComMoveXY ( unit , _x , _y ) ;
20865: LD_VAR 0 1
20869: PPUSH
20870: LD_VAR 0 7
20874: PPUSH
20875: LD_VAR 0 8
20879: PPUSH
20880: CALL_OW 111
// exit ;
20884: POP
20885: POP
20886: GO 20892
// end ; end ;
20888: GO 20777
20890: POP
20891: POP
// end ;
20892: LD_VAR 0 3
20896: RET
// export function ScanBase ( side , base_area ) ; begin
20897: LD_INT 0
20899: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
20900: LD_ADDR_VAR 0 3
20904: PUSH
20905: LD_VAR 0 2
20909: PPUSH
20910: LD_INT 81
20912: PUSH
20913: LD_VAR 0 1
20917: PUSH
20918: EMPTY
20919: LIST
20920: LIST
20921: PPUSH
20922: CALL_OW 70
20926: ST_TO_ADDR
// end ;
20927: LD_VAR 0 3
20931: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
20932: LD_INT 0
20934: PPUSH
20935: PPUSH
20936: PPUSH
20937: PPUSH
// result := false ;
20938: LD_ADDR_VAR 0 2
20942: PUSH
20943: LD_INT 0
20945: ST_TO_ADDR
// side := GetSide ( unit ) ;
20946: LD_ADDR_VAR 0 3
20950: PUSH
20951: LD_VAR 0 1
20955: PPUSH
20956: CALL_OW 255
20960: ST_TO_ADDR
// nat := GetNation ( unit ) ;
20961: LD_ADDR_VAR 0 4
20965: PUSH
20966: LD_VAR 0 1
20970: PPUSH
20971: CALL_OW 248
20975: ST_TO_ADDR
// case nat of 1 :
20976: LD_VAR 0 4
20980: PUSH
20981: LD_INT 1
20983: DOUBLE
20984: EQUAL
20985: IFTRUE 20989
20987: GO 21000
20989: POP
// tech := tech_lassight ; 2 :
20990: LD_ADDR_VAR 0 5
20994: PUSH
20995: LD_INT 12
20997: ST_TO_ADDR
20998: GO 21039
21000: LD_INT 2
21002: DOUBLE
21003: EQUAL
21004: IFTRUE 21008
21006: GO 21019
21008: POP
// tech := tech_mortar ; 3 :
21009: LD_ADDR_VAR 0 5
21013: PUSH
21014: LD_INT 41
21016: ST_TO_ADDR
21017: GO 21039
21019: LD_INT 3
21021: DOUBLE
21022: EQUAL
21023: IFTRUE 21027
21025: GO 21038
21027: POP
// tech := tech_bazooka ; end ;
21028: LD_ADDR_VAR 0 5
21032: PUSH
21033: LD_INT 44
21035: ST_TO_ADDR
21036: GO 21039
21038: POP
// if Researched ( side , tech ) then
21039: LD_VAR 0 3
21043: PPUSH
21044: LD_VAR 0 5
21048: PPUSH
21049: CALL_OW 325
21053: IFFALSE 21080
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
21055: LD_ADDR_VAR 0 2
21059: PUSH
21060: LD_INT 5
21062: PUSH
21063: LD_INT 8
21065: PUSH
21066: LD_INT 9
21068: PUSH
21069: EMPTY
21070: LIST
21071: LIST
21072: LIST
21073: PUSH
21074: LD_VAR 0 4
21078: ARRAY
21079: ST_TO_ADDR
// end ;
21080: LD_VAR 0 2
21084: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
21085: LD_INT 0
21087: PPUSH
21088: PPUSH
21089: PPUSH
// if not mines then
21090: LD_VAR 0 2
21094: NOT
21095: IFFALSE 21099
// exit ;
21097: GO 21243
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
21099: LD_ADDR_VAR 0 5
21103: PUSH
21104: LD_INT 81
21106: PUSH
21107: LD_VAR 0 1
21111: PUSH
21112: EMPTY
21113: LIST
21114: LIST
21115: PUSH
21116: LD_INT 3
21118: PUSH
21119: LD_INT 21
21121: PUSH
21122: LD_INT 3
21124: PUSH
21125: EMPTY
21126: LIST
21127: LIST
21128: PUSH
21129: EMPTY
21130: LIST
21131: LIST
21132: PUSH
21133: EMPTY
21134: LIST
21135: LIST
21136: PPUSH
21137: CALL_OW 69
21141: ST_TO_ADDR
// for i in mines do
21142: LD_ADDR_VAR 0 4
21146: PUSH
21147: LD_VAR 0 2
21151: PUSH
21152: FOR_IN
21153: IFFALSE 21241
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
21155: LD_VAR 0 4
21159: PUSH
21160: LD_INT 1
21162: ARRAY
21163: PPUSH
21164: LD_VAR 0 4
21168: PUSH
21169: LD_INT 2
21171: ARRAY
21172: PPUSH
21173: CALL_OW 458
21177: NOT
21178: IFFALSE 21182
// continue ;
21180: GO 21152
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
21182: LD_VAR 0 4
21186: PUSH
21187: LD_INT 1
21189: ARRAY
21190: PPUSH
21191: LD_VAR 0 4
21195: PUSH
21196: LD_INT 2
21198: ARRAY
21199: PPUSH
21200: CALL_OW 428
21204: PUSH
21205: LD_VAR 0 5
21209: IN
21210: IFFALSE 21239
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
21212: LD_VAR 0 4
21216: PUSH
21217: LD_INT 1
21219: ARRAY
21220: PPUSH
21221: LD_VAR 0 4
21225: PUSH
21226: LD_INT 2
21228: ARRAY
21229: PPUSH
21230: LD_VAR 0 1
21234: PPUSH
21235: CALL_OW 456
// end ;
21239: GO 21152
21241: POP
21242: POP
// end ;
21243: LD_VAR 0 3
21247: RET
// export function Count ( array ) ; var i ; begin
21248: LD_INT 0
21250: PPUSH
21251: PPUSH
// result := 0 ;
21252: LD_ADDR_VAR 0 2
21256: PUSH
21257: LD_INT 0
21259: ST_TO_ADDR
// for i in array do
21260: LD_ADDR_VAR 0 3
21264: PUSH
21265: LD_VAR 0 1
21269: PUSH
21270: FOR_IN
21271: IFFALSE 21295
// if i then
21273: LD_VAR 0 3
21277: IFFALSE 21293
// result := result + 1 ;
21279: LD_ADDR_VAR 0 2
21283: PUSH
21284: LD_VAR 0 2
21288: PUSH
21289: LD_INT 1
21291: PLUS
21292: ST_TO_ADDR
21293: GO 21270
21295: POP
21296: POP
// end ;
21297: LD_VAR 0 2
21301: RET
// export function IsEmpty ( building ) ; begin
21302: LD_INT 0
21304: PPUSH
// if not building then
21305: LD_VAR 0 1
21309: NOT
21310: IFFALSE 21314
// exit ;
21312: GO 21357
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
21314: LD_ADDR_VAR 0 2
21318: PUSH
21319: LD_VAR 0 1
21323: PUSH
21324: LD_INT 22
21326: PUSH
21327: LD_VAR 0 1
21331: PPUSH
21332: CALL_OW 255
21336: PUSH
21337: EMPTY
21338: LIST
21339: LIST
21340: PUSH
21341: LD_INT 58
21343: PUSH
21344: EMPTY
21345: LIST
21346: PUSH
21347: EMPTY
21348: LIST
21349: LIST
21350: PPUSH
21351: CALL_OW 69
21355: IN
21356: ST_TO_ADDR
// end ;
21357: LD_VAR 0 2
21361: RET
// export function IsNotFull ( building ) ; begin
21362: LD_INT 0
21364: PPUSH
// if not building then
21365: LD_VAR 0 1
21369: NOT
21370: IFFALSE 21374
// exit ;
21372: GO 21393
// result := UnitsInside ( building ) < 6 ;
21374: LD_ADDR_VAR 0 2
21378: PUSH
21379: LD_VAR 0 1
21383: PPUSH
21384: CALL_OW 313
21388: PUSH
21389: LD_INT 6
21391: LESS
21392: ST_TO_ADDR
// end ;
21393: LD_VAR 0 2
21397: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
21398: LD_INT 0
21400: PPUSH
21401: PPUSH
21402: PPUSH
21403: PPUSH
// tmp := [ ] ;
21404: LD_ADDR_VAR 0 3
21408: PUSH
21409: EMPTY
21410: ST_TO_ADDR
// list := [ ] ;
21411: LD_ADDR_VAR 0 5
21415: PUSH
21416: EMPTY
21417: ST_TO_ADDR
// for i = 16 to 25 do
21418: LD_ADDR_VAR 0 4
21422: PUSH
21423: DOUBLE
21424: LD_INT 16
21426: DEC
21427: ST_TO_ADDR
21428: LD_INT 25
21430: PUSH
21431: FOR_TO
21432: IFFALSE 21505
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
21434: LD_ADDR_VAR 0 3
21438: PUSH
21439: LD_VAR 0 3
21443: PUSH
21444: LD_INT 22
21446: PUSH
21447: LD_VAR 0 1
21451: PPUSH
21452: CALL_OW 255
21456: PUSH
21457: EMPTY
21458: LIST
21459: LIST
21460: PUSH
21461: LD_INT 91
21463: PUSH
21464: LD_VAR 0 1
21468: PUSH
21469: LD_INT 6
21471: PUSH
21472: EMPTY
21473: LIST
21474: LIST
21475: LIST
21476: PUSH
21477: LD_INT 30
21479: PUSH
21480: LD_VAR 0 4
21484: PUSH
21485: EMPTY
21486: LIST
21487: LIST
21488: PUSH
21489: EMPTY
21490: LIST
21491: LIST
21492: LIST
21493: PUSH
21494: EMPTY
21495: LIST
21496: PPUSH
21497: CALL_OW 69
21501: ADD
21502: ST_TO_ADDR
21503: GO 21431
21505: POP
21506: POP
// for i = 1 to tmp do
21507: LD_ADDR_VAR 0 4
21511: PUSH
21512: DOUBLE
21513: LD_INT 1
21515: DEC
21516: ST_TO_ADDR
21517: LD_VAR 0 3
21521: PUSH
21522: FOR_TO
21523: IFFALSE 21611
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
21525: LD_ADDR_VAR 0 5
21529: PUSH
21530: LD_VAR 0 5
21534: PUSH
21535: LD_VAR 0 3
21539: PUSH
21540: LD_VAR 0 4
21544: ARRAY
21545: PPUSH
21546: CALL_OW 266
21550: PUSH
21551: LD_VAR 0 3
21555: PUSH
21556: LD_VAR 0 4
21560: ARRAY
21561: PPUSH
21562: CALL_OW 250
21566: PUSH
21567: LD_VAR 0 3
21571: PUSH
21572: LD_VAR 0 4
21576: ARRAY
21577: PPUSH
21578: CALL_OW 251
21582: PUSH
21583: LD_VAR 0 3
21587: PUSH
21588: LD_VAR 0 4
21592: ARRAY
21593: PPUSH
21594: CALL_OW 254
21598: PUSH
21599: EMPTY
21600: LIST
21601: LIST
21602: LIST
21603: LIST
21604: PUSH
21605: EMPTY
21606: LIST
21607: ADD
21608: ST_TO_ADDR
21609: GO 21522
21611: POP
21612: POP
// result := list ;
21613: LD_ADDR_VAR 0 2
21617: PUSH
21618: LD_VAR 0 5
21622: ST_TO_ADDR
// end ;
21623: LD_VAR 0 2
21627: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
21628: LD_INT 0
21630: PPUSH
21631: PPUSH
21632: PPUSH
21633: PPUSH
21634: PPUSH
21635: PPUSH
21636: PPUSH
// if not factory then
21637: LD_VAR 0 1
21641: NOT
21642: IFFALSE 21646
// exit ;
21644: GO 22239
// if control = control_apeman then
21646: LD_VAR 0 4
21650: PUSH
21651: LD_INT 5
21653: EQUAL
21654: IFFALSE 21763
// begin tmp := UnitsInside ( factory ) ;
21656: LD_ADDR_VAR 0 8
21660: PUSH
21661: LD_VAR 0 1
21665: PPUSH
21666: CALL_OW 313
21670: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
21671: LD_VAR 0 8
21675: PPUSH
21676: LD_INT 25
21678: PUSH
21679: LD_INT 12
21681: PUSH
21682: EMPTY
21683: LIST
21684: LIST
21685: PPUSH
21686: CALL_OW 72
21690: NOT
21691: IFFALSE 21701
// control := control_manual ;
21693: LD_ADDR_VAR 0 4
21697: PUSH
21698: LD_INT 1
21700: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
21701: LD_ADDR_VAR 0 8
21705: PUSH
21706: LD_VAR 0 1
21710: PPUSH
21711: CALL 21398 0 1
21715: ST_TO_ADDR
// if tmp then
21716: LD_VAR 0 8
21720: IFFALSE 21763
// begin for i in tmp do
21722: LD_ADDR_VAR 0 7
21726: PUSH
21727: LD_VAR 0 8
21731: PUSH
21732: FOR_IN
21733: IFFALSE 21761
// if i [ 1 ] = b_ext_radio then
21735: LD_VAR 0 7
21739: PUSH
21740: LD_INT 1
21742: ARRAY
21743: PUSH
21744: LD_INT 22
21746: EQUAL
21747: IFFALSE 21759
// begin control := control_remote ;
21749: LD_ADDR_VAR 0 4
21753: PUSH
21754: LD_INT 2
21756: ST_TO_ADDR
// break ;
21757: GO 21761
// end ;
21759: GO 21732
21761: POP
21762: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
21763: LD_VAR 0 1
21767: PPUSH
21768: LD_VAR 0 2
21772: PPUSH
21773: LD_VAR 0 3
21777: PPUSH
21778: LD_VAR 0 4
21782: PPUSH
21783: LD_VAR 0 5
21787: PPUSH
21788: CALL_OW 448
21792: IFFALSE 21827
// begin result := [ chassis , engine , control , weapon ] ;
21794: LD_ADDR_VAR 0 6
21798: PUSH
21799: LD_VAR 0 2
21803: PUSH
21804: LD_VAR 0 3
21808: PUSH
21809: LD_VAR 0 4
21813: PUSH
21814: LD_VAR 0 5
21818: PUSH
21819: EMPTY
21820: LIST
21821: LIST
21822: LIST
21823: LIST
21824: ST_TO_ADDR
// exit ;
21825: GO 22239
// end ; _chassis := AvailableChassisList ( factory ) ;
21827: LD_ADDR_VAR 0 9
21831: PUSH
21832: LD_VAR 0 1
21836: PPUSH
21837: CALL_OW 475
21841: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
21842: LD_ADDR_VAR 0 11
21846: PUSH
21847: LD_VAR 0 1
21851: PPUSH
21852: CALL_OW 476
21856: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
21857: LD_ADDR_VAR 0 12
21861: PUSH
21862: LD_VAR 0 1
21866: PPUSH
21867: CALL_OW 477
21871: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
21872: LD_ADDR_VAR 0 10
21876: PUSH
21877: LD_VAR 0 1
21881: PPUSH
21882: CALL_OW 478
21886: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
21887: LD_VAR 0 9
21891: NOT
21892: PUSH
21893: LD_VAR 0 11
21897: NOT
21898: OR
21899: PUSH
21900: LD_VAR 0 12
21904: NOT
21905: OR
21906: PUSH
21907: LD_VAR 0 10
21911: NOT
21912: OR
21913: IFFALSE 21948
// begin result := [ chassis , engine , control , weapon ] ;
21915: LD_ADDR_VAR 0 6
21919: PUSH
21920: LD_VAR 0 2
21924: PUSH
21925: LD_VAR 0 3
21929: PUSH
21930: LD_VAR 0 4
21934: PUSH
21935: LD_VAR 0 5
21939: PUSH
21940: EMPTY
21941: LIST
21942: LIST
21943: LIST
21944: LIST
21945: ST_TO_ADDR
// exit ;
21946: GO 22239
// end ; if not chassis in _chassis then
21948: LD_VAR 0 2
21952: PUSH
21953: LD_VAR 0 9
21957: IN
21958: NOT
21959: IFFALSE 21985
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
21961: LD_ADDR_VAR 0 2
21965: PUSH
21966: LD_VAR 0 9
21970: PUSH
21971: LD_INT 1
21973: PPUSH
21974: LD_VAR 0 9
21978: PPUSH
21979: CALL_OW 12
21983: ARRAY
21984: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
21985: LD_VAR 0 2
21989: PPUSH
21990: LD_VAR 0 3
21994: PPUSH
21995: CALL 22244 0 2
21999: NOT
22000: IFFALSE 22059
// repeat engine := _engine [ 1 ] ;
22002: LD_ADDR_VAR 0 3
22006: PUSH
22007: LD_VAR 0 11
22011: PUSH
22012: LD_INT 1
22014: ARRAY
22015: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
22016: LD_ADDR_VAR 0 11
22020: PUSH
22021: LD_VAR 0 11
22025: PPUSH
22026: LD_INT 1
22028: PPUSH
22029: CALL_OW 3
22033: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
22034: LD_VAR 0 2
22038: PPUSH
22039: LD_VAR 0 3
22043: PPUSH
22044: CALL 22244 0 2
22048: PUSH
22049: LD_VAR 0 11
22053: PUSH
22054: EMPTY
22055: EQUAL
22056: OR
22057: IFFALSE 22002
// if not control in _control then
22059: LD_VAR 0 4
22063: PUSH
22064: LD_VAR 0 12
22068: IN
22069: NOT
22070: IFFALSE 22096
// control := _control [ rand ( 1 , _control ) ] ;
22072: LD_ADDR_VAR 0 4
22076: PUSH
22077: LD_VAR 0 12
22081: PUSH
22082: LD_INT 1
22084: PPUSH
22085: LD_VAR 0 12
22089: PPUSH
22090: CALL_OW 12
22094: ARRAY
22095: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
22096: LD_VAR 0 2
22100: PPUSH
22101: LD_VAR 0 5
22105: PPUSH
22106: CALL 22464 0 2
22110: NOT
22111: IFFALSE 22170
// repeat weapon := _weapon [ 1 ] ;
22113: LD_ADDR_VAR 0 5
22117: PUSH
22118: LD_VAR 0 10
22122: PUSH
22123: LD_INT 1
22125: ARRAY
22126: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
22127: LD_ADDR_VAR 0 10
22131: PUSH
22132: LD_VAR 0 10
22136: PPUSH
22137: LD_INT 1
22139: PPUSH
22140: CALL_OW 3
22144: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
22145: LD_VAR 0 2
22149: PPUSH
22150: LD_VAR 0 5
22154: PPUSH
22155: CALL 22464 0 2
22159: PUSH
22160: LD_VAR 0 10
22164: PUSH
22165: EMPTY
22166: EQUAL
22167: OR
22168: IFFALSE 22113
// result := [ ] ;
22170: LD_ADDR_VAR 0 6
22174: PUSH
22175: EMPTY
22176: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
22177: LD_VAR 0 1
22181: PPUSH
22182: LD_VAR 0 2
22186: PPUSH
22187: LD_VAR 0 3
22191: PPUSH
22192: LD_VAR 0 4
22196: PPUSH
22197: LD_VAR 0 5
22201: PPUSH
22202: CALL_OW 448
22206: IFFALSE 22239
// result := [ chassis , engine , control , weapon ] ;
22208: LD_ADDR_VAR 0 6
22212: PUSH
22213: LD_VAR 0 2
22217: PUSH
22218: LD_VAR 0 3
22222: PUSH
22223: LD_VAR 0 4
22227: PUSH
22228: LD_VAR 0 5
22232: PUSH
22233: EMPTY
22234: LIST
22235: LIST
22236: LIST
22237: LIST
22238: ST_TO_ADDR
// end ;
22239: LD_VAR 0 6
22243: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
22244: LD_INT 0
22246: PPUSH
// if not chassis or not engine then
22247: LD_VAR 0 1
22251: NOT
22252: PUSH
22253: LD_VAR 0 2
22257: NOT
22258: OR
22259: IFFALSE 22263
// exit ;
22261: GO 22459
// case engine of engine_solar :
22263: LD_VAR 0 2
22267: PUSH
22268: LD_INT 2
22270: DOUBLE
22271: EQUAL
22272: IFTRUE 22276
22274: GO 22314
22276: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
22277: LD_ADDR_VAR 0 3
22281: PUSH
22282: LD_INT 11
22284: PUSH
22285: LD_INT 12
22287: PUSH
22288: LD_INT 13
22290: PUSH
22291: LD_INT 14
22293: PUSH
22294: LD_INT 1
22296: PUSH
22297: LD_INT 2
22299: PUSH
22300: LD_INT 3
22302: PUSH
22303: EMPTY
22304: LIST
22305: LIST
22306: LIST
22307: LIST
22308: LIST
22309: LIST
22310: LIST
22311: ST_TO_ADDR
22312: GO 22443
22314: LD_INT 1
22316: DOUBLE
22317: EQUAL
22318: IFTRUE 22322
22320: GO 22384
22322: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
22323: LD_ADDR_VAR 0 3
22327: PUSH
22328: LD_INT 11
22330: PUSH
22331: LD_INT 12
22333: PUSH
22334: LD_INT 13
22336: PUSH
22337: LD_INT 14
22339: PUSH
22340: LD_INT 1
22342: PUSH
22343: LD_INT 2
22345: PUSH
22346: LD_INT 3
22348: PUSH
22349: LD_INT 4
22351: PUSH
22352: LD_INT 5
22354: PUSH
22355: LD_INT 21
22357: PUSH
22358: LD_INT 23
22360: PUSH
22361: LD_INT 22
22363: PUSH
22364: LD_INT 24
22366: PUSH
22367: EMPTY
22368: LIST
22369: LIST
22370: LIST
22371: LIST
22372: LIST
22373: LIST
22374: LIST
22375: LIST
22376: LIST
22377: LIST
22378: LIST
22379: LIST
22380: LIST
22381: ST_TO_ADDR
22382: GO 22443
22384: LD_INT 3
22386: DOUBLE
22387: EQUAL
22388: IFTRUE 22392
22390: GO 22442
22392: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
22393: LD_ADDR_VAR 0 3
22397: PUSH
22398: LD_INT 13
22400: PUSH
22401: LD_INT 14
22403: PUSH
22404: LD_INT 2
22406: PUSH
22407: LD_INT 3
22409: PUSH
22410: LD_INT 4
22412: PUSH
22413: LD_INT 5
22415: PUSH
22416: LD_INT 21
22418: PUSH
22419: LD_INT 22
22421: PUSH
22422: LD_INT 23
22424: PUSH
22425: LD_INT 24
22427: PUSH
22428: EMPTY
22429: LIST
22430: LIST
22431: LIST
22432: LIST
22433: LIST
22434: LIST
22435: LIST
22436: LIST
22437: LIST
22438: LIST
22439: ST_TO_ADDR
22440: GO 22443
22442: POP
// result := ( chassis in result ) ;
22443: LD_ADDR_VAR 0 3
22447: PUSH
22448: LD_VAR 0 1
22452: PUSH
22453: LD_VAR 0 3
22457: IN
22458: ST_TO_ADDR
// end ;
22459: LD_VAR 0 3
22463: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
22464: LD_INT 0
22466: PPUSH
// if not chassis or not weapon then
22467: LD_VAR 0 1
22471: NOT
22472: PUSH
22473: LD_VAR 0 2
22477: NOT
22478: OR
22479: IFFALSE 22483
// exit ;
22481: GO 23509
// case weapon of us_machine_gun :
22483: LD_VAR 0 2
22487: PUSH
22488: LD_INT 2
22490: DOUBLE
22491: EQUAL
22492: IFTRUE 22496
22494: GO 22526
22496: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
22497: LD_ADDR_VAR 0 3
22501: PUSH
22502: LD_INT 1
22504: PUSH
22505: LD_INT 2
22507: PUSH
22508: LD_INT 3
22510: PUSH
22511: LD_INT 4
22513: PUSH
22514: LD_INT 5
22516: PUSH
22517: EMPTY
22518: LIST
22519: LIST
22520: LIST
22521: LIST
22522: LIST
22523: ST_TO_ADDR
22524: GO 23493
22526: LD_INT 3
22528: DOUBLE
22529: EQUAL
22530: IFTRUE 22534
22532: GO 22564
22534: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
22535: LD_ADDR_VAR 0 3
22539: PUSH
22540: LD_INT 1
22542: PUSH
22543: LD_INT 2
22545: PUSH
22546: LD_INT 3
22548: PUSH
22549: LD_INT 4
22551: PUSH
22552: LD_INT 5
22554: PUSH
22555: EMPTY
22556: LIST
22557: LIST
22558: LIST
22559: LIST
22560: LIST
22561: ST_TO_ADDR
22562: GO 23493
22564: LD_INT 11
22566: DOUBLE
22567: EQUAL
22568: IFTRUE 22572
22570: GO 22602
22572: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
22573: LD_ADDR_VAR 0 3
22577: PUSH
22578: LD_INT 1
22580: PUSH
22581: LD_INT 2
22583: PUSH
22584: LD_INT 3
22586: PUSH
22587: LD_INT 4
22589: PUSH
22590: LD_INT 5
22592: PUSH
22593: EMPTY
22594: LIST
22595: LIST
22596: LIST
22597: LIST
22598: LIST
22599: ST_TO_ADDR
22600: GO 23493
22602: LD_INT 4
22604: DOUBLE
22605: EQUAL
22606: IFTRUE 22610
22608: GO 22636
22610: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
22611: LD_ADDR_VAR 0 3
22615: PUSH
22616: LD_INT 2
22618: PUSH
22619: LD_INT 3
22621: PUSH
22622: LD_INT 4
22624: PUSH
22625: LD_INT 5
22627: PUSH
22628: EMPTY
22629: LIST
22630: LIST
22631: LIST
22632: LIST
22633: ST_TO_ADDR
22634: GO 23493
22636: LD_INT 5
22638: DOUBLE
22639: EQUAL
22640: IFTRUE 22644
22642: GO 22670
22644: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
22645: LD_ADDR_VAR 0 3
22649: PUSH
22650: LD_INT 2
22652: PUSH
22653: LD_INT 3
22655: PUSH
22656: LD_INT 4
22658: PUSH
22659: LD_INT 5
22661: PUSH
22662: EMPTY
22663: LIST
22664: LIST
22665: LIST
22666: LIST
22667: ST_TO_ADDR
22668: GO 23493
22670: LD_INT 9
22672: DOUBLE
22673: EQUAL
22674: IFTRUE 22678
22676: GO 22704
22678: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
22679: LD_ADDR_VAR 0 3
22683: PUSH
22684: LD_INT 2
22686: PUSH
22687: LD_INT 3
22689: PUSH
22690: LD_INT 4
22692: PUSH
22693: LD_INT 5
22695: PUSH
22696: EMPTY
22697: LIST
22698: LIST
22699: LIST
22700: LIST
22701: ST_TO_ADDR
22702: GO 23493
22704: LD_INT 7
22706: DOUBLE
22707: EQUAL
22708: IFTRUE 22712
22710: GO 22738
22712: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
22713: LD_ADDR_VAR 0 3
22717: PUSH
22718: LD_INT 2
22720: PUSH
22721: LD_INT 3
22723: PUSH
22724: LD_INT 4
22726: PUSH
22727: LD_INT 5
22729: PUSH
22730: EMPTY
22731: LIST
22732: LIST
22733: LIST
22734: LIST
22735: ST_TO_ADDR
22736: GO 23493
22738: LD_INT 12
22740: DOUBLE
22741: EQUAL
22742: IFTRUE 22746
22744: GO 22772
22746: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
22747: LD_ADDR_VAR 0 3
22751: PUSH
22752: LD_INT 2
22754: PUSH
22755: LD_INT 3
22757: PUSH
22758: LD_INT 4
22760: PUSH
22761: LD_INT 5
22763: PUSH
22764: EMPTY
22765: LIST
22766: LIST
22767: LIST
22768: LIST
22769: ST_TO_ADDR
22770: GO 23493
22772: LD_INT 13
22774: DOUBLE
22775: EQUAL
22776: IFTRUE 22780
22778: GO 22806
22780: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
22781: LD_ADDR_VAR 0 3
22785: PUSH
22786: LD_INT 2
22788: PUSH
22789: LD_INT 3
22791: PUSH
22792: LD_INT 4
22794: PUSH
22795: LD_INT 5
22797: PUSH
22798: EMPTY
22799: LIST
22800: LIST
22801: LIST
22802: LIST
22803: ST_TO_ADDR
22804: GO 23493
22806: LD_INT 14
22808: DOUBLE
22809: EQUAL
22810: IFTRUE 22814
22812: GO 22832
22814: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
22815: LD_ADDR_VAR 0 3
22819: PUSH
22820: LD_INT 4
22822: PUSH
22823: LD_INT 5
22825: PUSH
22826: EMPTY
22827: LIST
22828: LIST
22829: ST_TO_ADDR
22830: GO 23493
22832: LD_INT 6
22834: DOUBLE
22835: EQUAL
22836: IFTRUE 22840
22838: GO 22858
22840: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
22841: LD_ADDR_VAR 0 3
22845: PUSH
22846: LD_INT 4
22848: PUSH
22849: LD_INT 5
22851: PUSH
22852: EMPTY
22853: LIST
22854: LIST
22855: ST_TO_ADDR
22856: GO 23493
22858: LD_INT 10
22860: DOUBLE
22861: EQUAL
22862: IFTRUE 22866
22864: GO 22884
22866: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
22867: LD_ADDR_VAR 0 3
22871: PUSH
22872: LD_INT 4
22874: PUSH
22875: LD_INT 5
22877: PUSH
22878: EMPTY
22879: LIST
22880: LIST
22881: ST_TO_ADDR
22882: GO 23493
22884: LD_INT 22
22886: DOUBLE
22887: EQUAL
22888: IFTRUE 22892
22890: GO 22918
22892: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
22893: LD_ADDR_VAR 0 3
22897: PUSH
22898: LD_INT 11
22900: PUSH
22901: LD_INT 12
22903: PUSH
22904: LD_INT 13
22906: PUSH
22907: LD_INT 14
22909: PUSH
22910: EMPTY
22911: LIST
22912: LIST
22913: LIST
22914: LIST
22915: ST_TO_ADDR
22916: GO 23493
22918: LD_INT 23
22920: DOUBLE
22921: EQUAL
22922: IFTRUE 22926
22924: GO 22952
22926: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
22927: LD_ADDR_VAR 0 3
22931: PUSH
22932: LD_INT 11
22934: PUSH
22935: LD_INT 12
22937: PUSH
22938: LD_INT 13
22940: PUSH
22941: LD_INT 14
22943: PUSH
22944: EMPTY
22945: LIST
22946: LIST
22947: LIST
22948: LIST
22949: ST_TO_ADDR
22950: GO 23493
22952: LD_INT 24
22954: DOUBLE
22955: EQUAL
22956: IFTRUE 22960
22958: GO 22986
22960: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
22961: LD_ADDR_VAR 0 3
22965: PUSH
22966: LD_INT 11
22968: PUSH
22969: LD_INT 12
22971: PUSH
22972: LD_INT 13
22974: PUSH
22975: LD_INT 14
22977: PUSH
22978: EMPTY
22979: LIST
22980: LIST
22981: LIST
22982: LIST
22983: ST_TO_ADDR
22984: GO 23493
22986: LD_INT 30
22988: DOUBLE
22989: EQUAL
22990: IFTRUE 22994
22992: GO 23020
22994: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
22995: LD_ADDR_VAR 0 3
22999: PUSH
23000: LD_INT 11
23002: PUSH
23003: LD_INT 12
23005: PUSH
23006: LD_INT 13
23008: PUSH
23009: LD_INT 14
23011: PUSH
23012: EMPTY
23013: LIST
23014: LIST
23015: LIST
23016: LIST
23017: ST_TO_ADDR
23018: GO 23493
23020: LD_INT 25
23022: DOUBLE
23023: EQUAL
23024: IFTRUE 23028
23026: GO 23046
23028: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
23029: LD_ADDR_VAR 0 3
23033: PUSH
23034: LD_INT 13
23036: PUSH
23037: LD_INT 14
23039: PUSH
23040: EMPTY
23041: LIST
23042: LIST
23043: ST_TO_ADDR
23044: GO 23493
23046: LD_INT 27
23048: DOUBLE
23049: EQUAL
23050: IFTRUE 23054
23052: GO 23072
23054: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
23055: LD_ADDR_VAR 0 3
23059: PUSH
23060: LD_INT 13
23062: PUSH
23063: LD_INT 14
23065: PUSH
23066: EMPTY
23067: LIST
23068: LIST
23069: ST_TO_ADDR
23070: GO 23493
23072: LD_INT 28
23074: DOUBLE
23075: EQUAL
23076: IFTRUE 23080
23078: GO 23098
23080: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
23081: LD_ADDR_VAR 0 3
23085: PUSH
23086: LD_INT 13
23088: PUSH
23089: LD_INT 14
23091: PUSH
23092: EMPTY
23093: LIST
23094: LIST
23095: ST_TO_ADDR
23096: GO 23493
23098: LD_INT 29
23100: DOUBLE
23101: EQUAL
23102: IFTRUE 23106
23104: GO 23124
23106: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
23107: LD_ADDR_VAR 0 3
23111: PUSH
23112: LD_INT 13
23114: PUSH
23115: LD_INT 14
23117: PUSH
23118: EMPTY
23119: LIST
23120: LIST
23121: ST_TO_ADDR
23122: GO 23493
23124: LD_INT 31
23126: DOUBLE
23127: EQUAL
23128: IFTRUE 23132
23130: GO 23150
23132: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
23133: LD_ADDR_VAR 0 3
23137: PUSH
23138: LD_INT 13
23140: PUSH
23141: LD_INT 14
23143: PUSH
23144: EMPTY
23145: LIST
23146: LIST
23147: ST_TO_ADDR
23148: GO 23493
23150: LD_INT 26
23152: DOUBLE
23153: EQUAL
23154: IFTRUE 23158
23156: GO 23176
23158: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
23159: LD_ADDR_VAR 0 3
23163: PUSH
23164: LD_INT 13
23166: PUSH
23167: LD_INT 14
23169: PUSH
23170: EMPTY
23171: LIST
23172: LIST
23173: ST_TO_ADDR
23174: GO 23493
23176: LD_INT 42
23178: DOUBLE
23179: EQUAL
23180: IFTRUE 23184
23182: GO 23210
23184: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
23185: LD_ADDR_VAR 0 3
23189: PUSH
23190: LD_INT 21
23192: PUSH
23193: LD_INT 22
23195: PUSH
23196: LD_INT 23
23198: PUSH
23199: LD_INT 24
23201: PUSH
23202: EMPTY
23203: LIST
23204: LIST
23205: LIST
23206: LIST
23207: ST_TO_ADDR
23208: GO 23493
23210: LD_INT 43
23212: DOUBLE
23213: EQUAL
23214: IFTRUE 23218
23216: GO 23244
23218: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
23219: LD_ADDR_VAR 0 3
23223: PUSH
23224: LD_INT 21
23226: PUSH
23227: LD_INT 22
23229: PUSH
23230: LD_INT 23
23232: PUSH
23233: LD_INT 24
23235: PUSH
23236: EMPTY
23237: LIST
23238: LIST
23239: LIST
23240: LIST
23241: ST_TO_ADDR
23242: GO 23493
23244: LD_INT 44
23246: DOUBLE
23247: EQUAL
23248: IFTRUE 23252
23250: GO 23278
23252: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
23253: LD_ADDR_VAR 0 3
23257: PUSH
23258: LD_INT 21
23260: PUSH
23261: LD_INT 22
23263: PUSH
23264: LD_INT 23
23266: PUSH
23267: LD_INT 24
23269: PUSH
23270: EMPTY
23271: LIST
23272: LIST
23273: LIST
23274: LIST
23275: ST_TO_ADDR
23276: GO 23493
23278: LD_INT 45
23280: DOUBLE
23281: EQUAL
23282: IFTRUE 23286
23284: GO 23312
23286: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
23287: LD_ADDR_VAR 0 3
23291: PUSH
23292: LD_INT 21
23294: PUSH
23295: LD_INT 22
23297: PUSH
23298: LD_INT 23
23300: PUSH
23301: LD_INT 24
23303: PUSH
23304: EMPTY
23305: LIST
23306: LIST
23307: LIST
23308: LIST
23309: ST_TO_ADDR
23310: GO 23493
23312: LD_INT 49
23314: DOUBLE
23315: EQUAL
23316: IFTRUE 23320
23318: GO 23346
23320: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
23321: LD_ADDR_VAR 0 3
23325: PUSH
23326: LD_INT 21
23328: PUSH
23329: LD_INT 22
23331: PUSH
23332: LD_INT 23
23334: PUSH
23335: LD_INT 24
23337: PUSH
23338: EMPTY
23339: LIST
23340: LIST
23341: LIST
23342: LIST
23343: ST_TO_ADDR
23344: GO 23493
23346: LD_INT 51
23348: DOUBLE
23349: EQUAL
23350: IFTRUE 23354
23352: GO 23380
23354: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
23355: LD_ADDR_VAR 0 3
23359: PUSH
23360: LD_INT 21
23362: PUSH
23363: LD_INT 22
23365: PUSH
23366: LD_INT 23
23368: PUSH
23369: LD_INT 24
23371: PUSH
23372: EMPTY
23373: LIST
23374: LIST
23375: LIST
23376: LIST
23377: ST_TO_ADDR
23378: GO 23493
23380: LD_INT 52
23382: DOUBLE
23383: EQUAL
23384: IFTRUE 23388
23386: GO 23414
23388: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
23389: LD_ADDR_VAR 0 3
23393: PUSH
23394: LD_INT 21
23396: PUSH
23397: LD_INT 22
23399: PUSH
23400: LD_INT 23
23402: PUSH
23403: LD_INT 24
23405: PUSH
23406: EMPTY
23407: LIST
23408: LIST
23409: LIST
23410: LIST
23411: ST_TO_ADDR
23412: GO 23493
23414: LD_INT 53
23416: DOUBLE
23417: EQUAL
23418: IFTRUE 23422
23420: GO 23440
23422: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
23423: LD_ADDR_VAR 0 3
23427: PUSH
23428: LD_INT 23
23430: PUSH
23431: LD_INT 24
23433: PUSH
23434: EMPTY
23435: LIST
23436: LIST
23437: ST_TO_ADDR
23438: GO 23493
23440: LD_INT 46
23442: DOUBLE
23443: EQUAL
23444: IFTRUE 23448
23446: GO 23466
23448: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
23449: LD_ADDR_VAR 0 3
23453: PUSH
23454: LD_INT 23
23456: PUSH
23457: LD_INT 24
23459: PUSH
23460: EMPTY
23461: LIST
23462: LIST
23463: ST_TO_ADDR
23464: GO 23493
23466: LD_INT 47
23468: DOUBLE
23469: EQUAL
23470: IFTRUE 23474
23472: GO 23492
23474: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
23475: LD_ADDR_VAR 0 3
23479: PUSH
23480: LD_INT 23
23482: PUSH
23483: LD_INT 24
23485: PUSH
23486: EMPTY
23487: LIST
23488: LIST
23489: ST_TO_ADDR
23490: GO 23493
23492: POP
// result := ( chassis in result ) ;
23493: LD_ADDR_VAR 0 3
23497: PUSH
23498: LD_VAR 0 1
23502: PUSH
23503: LD_VAR 0 3
23507: IN
23508: ST_TO_ADDR
// end ;
23509: LD_VAR 0 3
23513: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
23514: LD_INT 0
23516: PPUSH
23517: PPUSH
23518: PPUSH
23519: PPUSH
23520: PPUSH
23521: PPUSH
23522: PPUSH
// result := array ;
23523: LD_ADDR_VAR 0 5
23527: PUSH
23528: LD_VAR 0 1
23532: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
23533: LD_VAR 0 1
23537: NOT
23538: PUSH
23539: LD_VAR 0 2
23543: NOT
23544: OR
23545: PUSH
23546: LD_VAR 0 3
23550: NOT
23551: OR
23552: PUSH
23553: LD_VAR 0 2
23557: PUSH
23558: LD_VAR 0 1
23562: GREATER
23563: OR
23564: PUSH
23565: LD_VAR 0 3
23569: PUSH
23570: LD_VAR 0 1
23574: GREATER
23575: OR
23576: IFFALSE 23580
// exit ;
23578: GO 23876
// if direction then
23580: LD_VAR 0 4
23584: IFFALSE 23648
// begin d := 1 ;
23586: LD_ADDR_VAR 0 9
23590: PUSH
23591: LD_INT 1
23593: ST_TO_ADDR
// if i_from > i_to then
23594: LD_VAR 0 2
23598: PUSH
23599: LD_VAR 0 3
23603: GREATER
23604: IFFALSE 23630
// length := ( array - i_from ) + i_to else
23606: LD_ADDR_VAR 0 11
23610: PUSH
23611: LD_VAR 0 1
23615: PUSH
23616: LD_VAR 0 2
23620: MINUS
23621: PUSH
23622: LD_VAR 0 3
23626: PLUS
23627: ST_TO_ADDR
23628: GO 23646
// length := i_to - i_from ;
23630: LD_ADDR_VAR 0 11
23634: PUSH
23635: LD_VAR 0 3
23639: PUSH
23640: LD_VAR 0 2
23644: MINUS
23645: ST_TO_ADDR
// end else
23646: GO 23709
// begin d := - 1 ;
23648: LD_ADDR_VAR 0 9
23652: PUSH
23653: LD_INT 1
23655: NEG
23656: ST_TO_ADDR
// if i_from > i_to then
23657: LD_VAR 0 2
23661: PUSH
23662: LD_VAR 0 3
23666: GREATER
23667: IFFALSE 23687
// length := i_from - i_to else
23669: LD_ADDR_VAR 0 11
23673: PUSH
23674: LD_VAR 0 2
23678: PUSH
23679: LD_VAR 0 3
23683: MINUS
23684: ST_TO_ADDR
23685: GO 23709
// length := ( array - i_to ) + i_from ;
23687: LD_ADDR_VAR 0 11
23691: PUSH
23692: LD_VAR 0 1
23696: PUSH
23697: LD_VAR 0 3
23701: MINUS
23702: PUSH
23703: LD_VAR 0 2
23707: PLUS
23708: ST_TO_ADDR
// end ; if not length then
23709: LD_VAR 0 11
23713: NOT
23714: IFFALSE 23718
// exit ;
23716: GO 23876
// tmp := array ;
23718: LD_ADDR_VAR 0 10
23722: PUSH
23723: LD_VAR 0 1
23727: ST_TO_ADDR
// for i = 1 to length do
23728: LD_ADDR_VAR 0 6
23732: PUSH
23733: DOUBLE
23734: LD_INT 1
23736: DEC
23737: ST_TO_ADDR
23738: LD_VAR 0 11
23742: PUSH
23743: FOR_TO
23744: IFFALSE 23864
// begin for j = 1 to array do
23746: LD_ADDR_VAR 0 7
23750: PUSH
23751: DOUBLE
23752: LD_INT 1
23754: DEC
23755: ST_TO_ADDR
23756: LD_VAR 0 1
23760: PUSH
23761: FOR_TO
23762: IFFALSE 23850
// begin k := j + d ;
23764: LD_ADDR_VAR 0 8
23768: PUSH
23769: LD_VAR 0 7
23773: PUSH
23774: LD_VAR 0 9
23778: PLUS
23779: ST_TO_ADDR
// if k > array then
23780: LD_VAR 0 8
23784: PUSH
23785: LD_VAR 0 1
23789: GREATER
23790: IFFALSE 23800
// k := 1 ;
23792: LD_ADDR_VAR 0 8
23796: PUSH
23797: LD_INT 1
23799: ST_TO_ADDR
// if not k then
23800: LD_VAR 0 8
23804: NOT
23805: IFFALSE 23817
// k := array ;
23807: LD_ADDR_VAR 0 8
23811: PUSH
23812: LD_VAR 0 1
23816: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
23817: LD_ADDR_VAR 0 10
23821: PUSH
23822: LD_VAR 0 10
23826: PPUSH
23827: LD_VAR 0 8
23831: PPUSH
23832: LD_VAR 0 1
23836: PUSH
23837: LD_VAR 0 7
23841: ARRAY
23842: PPUSH
23843: CALL_OW 1
23847: ST_TO_ADDR
// end ;
23848: GO 23761
23850: POP
23851: POP
// array := tmp ;
23852: LD_ADDR_VAR 0 1
23856: PUSH
23857: LD_VAR 0 10
23861: ST_TO_ADDR
// end ;
23862: GO 23743
23864: POP
23865: POP
// result := array ;
23866: LD_ADDR_VAR 0 5
23870: PUSH
23871: LD_VAR 0 1
23875: ST_TO_ADDR
// end ;
23876: LD_VAR 0 5
23880: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
23881: LD_INT 0
23883: PPUSH
23884: PPUSH
// result := 0 ;
23885: LD_ADDR_VAR 0 3
23889: PUSH
23890: LD_INT 0
23892: ST_TO_ADDR
// if not array or not value in array then
23893: LD_VAR 0 1
23897: NOT
23898: PUSH
23899: LD_VAR 0 2
23903: PUSH
23904: LD_VAR 0 1
23908: IN
23909: NOT
23910: OR
23911: IFFALSE 23915
// exit ;
23913: GO 23969
// for i = 1 to array do
23915: LD_ADDR_VAR 0 4
23919: PUSH
23920: DOUBLE
23921: LD_INT 1
23923: DEC
23924: ST_TO_ADDR
23925: LD_VAR 0 1
23929: PUSH
23930: FOR_TO
23931: IFFALSE 23967
// if value = array [ i ] then
23933: LD_VAR 0 2
23937: PUSH
23938: LD_VAR 0 1
23942: PUSH
23943: LD_VAR 0 4
23947: ARRAY
23948: EQUAL
23949: IFFALSE 23965
// begin result := i ;
23951: LD_ADDR_VAR 0 3
23955: PUSH
23956: LD_VAR 0 4
23960: ST_TO_ADDR
// exit ;
23961: POP
23962: POP
23963: GO 23969
// end ;
23965: GO 23930
23967: POP
23968: POP
// end ;
23969: LD_VAR 0 3
23973: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
23974: LD_INT 0
23976: PPUSH
// vc_chassis := chassis ;
23977: LD_ADDR_OWVAR 37
23981: PUSH
23982: LD_VAR 0 1
23986: ST_TO_ADDR
// vc_engine := engine ;
23987: LD_ADDR_OWVAR 39
23991: PUSH
23992: LD_VAR 0 2
23996: ST_TO_ADDR
// vc_control := control ;
23997: LD_ADDR_OWVAR 38
24001: PUSH
24002: LD_VAR 0 3
24006: ST_TO_ADDR
// vc_weapon := weapon ;
24007: LD_ADDR_OWVAR 40
24011: PUSH
24012: LD_VAR 0 4
24016: ST_TO_ADDR
// vc_fuel_battery := fuel ;
24017: LD_ADDR_OWVAR 41
24021: PUSH
24022: LD_VAR 0 5
24026: ST_TO_ADDR
// end ;
24027: LD_VAR 0 6
24031: RET
// export function WantPlant ( unit ) ; var task ; begin
24032: LD_INT 0
24034: PPUSH
24035: PPUSH
// result := false ;
24036: LD_ADDR_VAR 0 2
24040: PUSH
24041: LD_INT 0
24043: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
24044: LD_ADDR_VAR 0 3
24048: PUSH
24049: LD_VAR 0 1
24053: PPUSH
24054: CALL_OW 437
24058: ST_TO_ADDR
// if task then
24059: LD_VAR 0 3
24063: IFFALSE 24091
// if task [ 1 ] [ 1 ] = p then
24065: LD_VAR 0 3
24069: PUSH
24070: LD_INT 1
24072: ARRAY
24073: PUSH
24074: LD_INT 1
24076: ARRAY
24077: PUSH
24078: LD_STRING p
24080: EQUAL
24081: IFFALSE 24091
// result := true ;
24083: LD_ADDR_VAR 0 2
24087: PUSH
24088: LD_INT 1
24090: ST_TO_ADDR
// end ;
24091: LD_VAR 0 2
24095: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
24096: LD_INT 0
24098: PPUSH
24099: PPUSH
24100: PPUSH
24101: PPUSH
// if pos < 1 then
24102: LD_VAR 0 2
24106: PUSH
24107: LD_INT 1
24109: LESS
24110: IFFALSE 24114
// exit ;
24112: GO 24417
// if pos = 1 then
24114: LD_VAR 0 2
24118: PUSH
24119: LD_INT 1
24121: EQUAL
24122: IFFALSE 24155
// result := Replace ( arr , pos [ 1 ] , value ) else
24124: LD_ADDR_VAR 0 4
24128: PUSH
24129: LD_VAR 0 1
24133: PPUSH
24134: LD_VAR 0 2
24138: PUSH
24139: LD_INT 1
24141: ARRAY
24142: PPUSH
24143: LD_VAR 0 3
24147: PPUSH
24148: CALL_OW 1
24152: ST_TO_ADDR
24153: GO 24417
// begin tmp := arr ;
24155: LD_ADDR_VAR 0 6
24159: PUSH
24160: LD_VAR 0 1
24164: ST_TO_ADDR
// s_arr := [ tmp ] ;
24165: LD_ADDR_VAR 0 7
24169: PUSH
24170: LD_VAR 0 6
24174: PUSH
24175: EMPTY
24176: LIST
24177: ST_TO_ADDR
// for i = 1 to pos - 1 do
24178: LD_ADDR_VAR 0 5
24182: PUSH
24183: DOUBLE
24184: LD_INT 1
24186: DEC
24187: ST_TO_ADDR
24188: LD_VAR 0 2
24192: PUSH
24193: LD_INT 1
24195: MINUS
24196: PUSH
24197: FOR_TO
24198: IFFALSE 24243
// begin tmp := tmp [ pos [ i ] ] ;
24200: LD_ADDR_VAR 0 6
24204: PUSH
24205: LD_VAR 0 6
24209: PUSH
24210: LD_VAR 0 2
24214: PUSH
24215: LD_VAR 0 5
24219: ARRAY
24220: ARRAY
24221: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
24222: LD_ADDR_VAR 0 7
24226: PUSH
24227: LD_VAR 0 7
24231: PUSH
24232: LD_VAR 0 6
24236: PUSH
24237: EMPTY
24238: LIST
24239: ADD
24240: ST_TO_ADDR
// end ;
24241: GO 24197
24243: POP
24244: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
24245: LD_ADDR_VAR 0 6
24249: PUSH
24250: LD_VAR 0 6
24254: PPUSH
24255: LD_VAR 0 2
24259: PUSH
24260: LD_VAR 0 2
24264: ARRAY
24265: PPUSH
24266: LD_VAR 0 3
24270: PPUSH
24271: CALL_OW 1
24275: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
24276: LD_ADDR_VAR 0 7
24280: PUSH
24281: LD_VAR 0 7
24285: PPUSH
24286: LD_VAR 0 7
24290: PPUSH
24291: LD_VAR 0 6
24295: PPUSH
24296: CALL_OW 1
24300: ST_TO_ADDR
// for i = s_arr downto 2 do
24301: LD_ADDR_VAR 0 5
24305: PUSH
24306: DOUBLE
24307: LD_VAR 0 7
24311: INC
24312: ST_TO_ADDR
24313: LD_INT 2
24315: PUSH
24316: FOR_DOWNTO
24317: IFFALSE 24401
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
24319: LD_ADDR_VAR 0 6
24323: PUSH
24324: LD_VAR 0 7
24328: PUSH
24329: LD_VAR 0 5
24333: PUSH
24334: LD_INT 1
24336: MINUS
24337: ARRAY
24338: PPUSH
24339: LD_VAR 0 2
24343: PUSH
24344: LD_VAR 0 5
24348: PUSH
24349: LD_INT 1
24351: MINUS
24352: ARRAY
24353: PPUSH
24354: LD_VAR 0 7
24358: PUSH
24359: LD_VAR 0 5
24363: ARRAY
24364: PPUSH
24365: CALL_OW 1
24369: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
24370: LD_ADDR_VAR 0 7
24374: PUSH
24375: LD_VAR 0 7
24379: PPUSH
24380: LD_VAR 0 5
24384: PUSH
24385: LD_INT 1
24387: MINUS
24388: PPUSH
24389: LD_VAR 0 6
24393: PPUSH
24394: CALL_OW 1
24398: ST_TO_ADDR
// end ;
24399: GO 24316
24401: POP
24402: POP
// result := s_arr [ 1 ] ;
24403: LD_ADDR_VAR 0 4
24407: PUSH
24408: LD_VAR 0 7
24412: PUSH
24413: LD_INT 1
24415: ARRAY
24416: ST_TO_ADDR
// end ; end ;
24417: LD_VAR 0 4
24421: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
24422: LD_INT 0
24424: PPUSH
24425: PPUSH
// if not list then
24426: LD_VAR 0 1
24430: NOT
24431: IFFALSE 24435
// exit ;
24433: GO 24526
// i := list [ pos1 ] ;
24435: LD_ADDR_VAR 0 5
24439: PUSH
24440: LD_VAR 0 1
24444: PUSH
24445: LD_VAR 0 2
24449: ARRAY
24450: ST_TO_ADDR
// if not i then
24451: LD_VAR 0 5
24455: NOT
24456: IFFALSE 24460
// exit ;
24458: GO 24526
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
24460: LD_ADDR_VAR 0 1
24464: PUSH
24465: LD_VAR 0 1
24469: PPUSH
24470: LD_VAR 0 2
24474: PPUSH
24475: LD_VAR 0 1
24479: PUSH
24480: LD_VAR 0 3
24484: ARRAY
24485: PPUSH
24486: CALL_OW 1
24490: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
24491: LD_ADDR_VAR 0 1
24495: PUSH
24496: LD_VAR 0 1
24500: PPUSH
24501: LD_VAR 0 3
24505: PPUSH
24506: LD_VAR 0 5
24510: PPUSH
24511: CALL_OW 1
24515: ST_TO_ADDR
// result := list ;
24516: LD_ADDR_VAR 0 4
24520: PUSH
24521: LD_VAR 0 1
24525: ST_TO_ADDR
// end ;
24526: LD_VAR 0 4
24530: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
24531: LD_INT 0
24533: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
24534: LD_ADDR_VAR 0 5
24538: PUSH
24539: LD_VAR 0 1
24543: PPUSH
24544: CALL_OW 250
24548: PPUSH
24549: LD_VAR 0 1
24553: PPUSH
24554: CALL_OW 251
24558: PPUSH
24559: LD_VAR 0 2
24563: PPUSH
24564: LD_VAR 0 3
24568: PPUSH
24569: LD_VAR 0 4
24573: PPUSH
24574: CALL 24584 0 5
24578: ST_TO_ADDR
// end ;
24579: LD_VAR 0 5
24583: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
24584: LD_INT 0
24586: PPUSH
24587: PPUSH
24588: PPUSH
24589: PPUSH
// if not list then
24590: LD_VAR 0 3
24594: NOT
24595: IFFALSE 24599
// exit ;
24597: GO 24987
// result := [ ] ;
24599: LD_ADDR_VAR 0 6
24603: PUSH
24604: EMPTY
24605: ST_TO_ADDR
// for i in list do
24606: LD_ADDR_VAR 0 7
24610: PUSH
24611: LD_VAR 0 3
24615: PUSH
24616: FOR_IN
24617: IFFALSE 24819
// begin tmp := GetDistUnitXY ( i , x , y ) ;
24619: LD_ADDR_VAR 0 9
24623: PUSH
24624: LD_VAR 0 7
24628: PPUSH
24629: LD_VAR 0 1
24633: PPUSH
24634: LD_VAR 0 2
24638: PPUSH
24639: CALL_OW 297
24643: ST_TO_ADDR
// if not result then
24644: LD_VAR 0 6
24648: NOT
24649: IFFALSE 24675
// result := [ [ i , tmp ] ] else
24651: LD_ADDR_VAR 0 6
24655: PUSH
24656: LD_VAR 0 7
24660: PUSH
24661: LD_VAR 0 9
24665: PUSH
24666: EMPTY
24667: LIST
24668: LIST
24669: PUSH
24670: EMPTY
24671: LIST
24672: ST_TO_ADDR
24673: GO 24817
// begin if result [ result ] [ 2 ] < tmp then
24675: LD_VAR 0 6
24679: PUSH
24680: LD_VAR 0 6
24684: ARRAY
24685: PUSH
24686: LD_INT 2
24688: ARRAY
24689: PUSH
24690: LD_VAR 0 9
24694: LESS
24695: IFFALSE 24737
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
24697: LD_ADDR_VAR 0 6
24701: PUSH
24702: LD_VAR 0 6
24706: PPUSH
24707: LD_VAR 0 6
24711: PUSH
24712: LD_INT 1
24714: PLUS
24715: PPUSH
24716: LD_VAR 0 7
24720: PUSH
24721: LD_VAR 0 9
24725: PUSH
24726: EMPTY
24727: LIST
24728: LIST
24729: PPUSH
24730: CALL_OW 2
24734: ST_TO_ADDR
24735: GO 24817
// for j = 1 to result do
24737: LD_ADDR_VAR 0 8
24741: PUSH
24742: DOUBLE
24743: LD_INT 1
24745: DEC
24746: ST_TO_ADDR
24747: LD_VAR 0 6
24751: PUSH
24752: FOR_TO
24753: IFFALSE 24815
// begin if tmp < result [ j ] [ 2 ] then
24755: LD_VAR 0 9
24759: PUSH
24760: LD_VAR 0 6
24764: PUSH
24765: LD_VAR 0 8
24769: ARRAY
24770: PUSH
24771: LD_INT 2
24773: ARRAY
24774: LESS
24775: IFFALSE 24813
// begin result := Insert ( result , j , [ i , tmp ] ) ;
24777: LD_ADDR_VAR 0 6
24781: PUSH
24782: LD_VAR 0 6
24786: PPUSH
24787: LD_VAR 0 8
24791: PPUSH
24792: LD_VAR 0 7
24796: PUSH
24797: LD_VAR 0 9
24801: PUSH
24802: EMPTY
24803: LIST
24804: LIST
24805: PPUSH
24806: CALL_OW 2
24810: ST_TO_ADDR
// break ;
24811: GO 24815
// end ; end ;
24813: GO 24752
24815: POP
24816: POP
// end ; end ;
24817: GO 24616
24819: POP
24820: POP
// if result and not asc then
24821: LD_VAR 0 6
24825: PUSH
24826: LD_VAR 0 4
24830: NOT
24831: AND
24832: IFFALSE 24907
// begin tmp := result ;
24834: LD_ADDR_VAR 0 9
24838: PUSH
24839: LD_VAR 0 6
24843: ST_TO_ADDR
// for i = tmp downto 1 do
24844: LD_ADDR_VAR 0 7
24848: PUSH
24849: DOUBLE
24850: LD_VAR 0 9
24854: INC
24855: ST_TO_ADDR
24856: LD_INT 1
24858: PUSH
24859: FOR_DOWNTO
24860: IFFALSE 24905
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
24862: LD_ADDR_VAR 0 6
24866: PUSH
24867: LD_VAR 0 6
24871: PPUSH
24872: LD_VAR 0 9
24876: PUSH
24877: LD_VAR 0 7
24881: MINUS
24882: PUSH
24883: LD_INT 1
24885: PLUS
24886: PPUSH
24887: LD_VAR 0 9
24891: PUSH
24892: LD_VAR 0 7
24896: ARRAY
24897: PPUSH
24898: CALL_OW 1
24902: ST_TO_ADDR
24903: GO 24859
24905: POP
24906: POP
// end ; tmp := [ ] ;
24907: LD_ADDR_VAR 0 9
24911: PUSH
24912: EMPTY
24913: ST_TO_ADDR
// if mode then
24914: LD_VAR 0 5
24918: IFFALSE 24987
// begin for i = 1 to result do
24920: LD_ADDR_VAR 0 7
24924: PUSH
24925: DOUBLE
24926: LD_INT 1
24928: DEC
24929: ST_TO_ADDR
24930: LD_VAR 0 6
24934: PUSH
24935: FOR_TO
24936: IFFALSE 24975
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
24938: LD_ADDR_VAR 0 9
24942: PUSH
24943: LD_VAR 0 9
24947: PPUSH
24948: LD_VAR 0 7
24952: PPUSH
24953: LD_VAR 0 6
24957: PUSH
24958: LD_VAR 0 7
24962: ARRAY
24963: PUSH
24964: LD_INT 1
24966: ARRAY
24967: PPUSH
24968: CALL_OW 1
24972: ST_TO_ADDR
24973: GO 24935
24975: POP
24976: POP
// result := tmp ;
24977: LD_ADDR_VAR 0 6
24981: PUSH
24982: LD_VAR 0 9
24986: ST_TO_ADDR
// end ; end ;
24987: LD_VAR 0 6
24991: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
24992: LD_INT 0
24994: PPUSH
24995: PPUSH
24996: PPUSH
24997: PPUSH
24998: PPUSH
24999: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
25000: LD_ADDR_VAR 0 5
25004: PUSH
25005: LD_INT 0
25007: PUSH
25008: LD_INT 0
25010: PUSH
25011: LD_INT 0
25013: PUSH
25014: EMPTY
25015: PUSH
25016: EMPTY
25017: LIST
25018: LIST
25019: LIST
25020: LIST
25021: ST_TO_ADDR
// if not x or not y then
25022: LD_VAR 0 2
25026: NOT
25027: PUSH
25028: LD_VAR 0 3
25032: NOT
25033: OR
25034: IFFALSE 25038
// exit ;
25036: GO 26684
// if not range then
25038: LD_VAR 0 4
25042: NOT
25043: IFFALSE 25053
// range := 10 ;
25045: LD_ADDR_VAR 0 4
25049: PUSH
25050: LD_INT 10
25052: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
25053: LD_ADDR_VAR 0 8
25057: PUSH
25058: LD_INT 81
25060: PUSH
25061: LD_VAR 0 1
25065: PUSH
25066: EMPTY
25067: LIST
25068: LIST
25069: PUSH
25070: LD_INT 92
25072: PUSH
25073: LD_VAR 0 2
25077: PUSH
25078: LD_VAR 0 3
25082: PUSH
25083: LD_VAR 0 4
25087: PUSH
25088: EMPTY
25089: LIST
25090: LIST
25091: LIST
25092: LIST
25093: PUSH
25094: LD_INT 3
25096: PUSH
25097: LD_INT 21
25099: PUSH
25100: LD_INT 3
25102: PUSH
25103: EMPTY
25104: LIST
25105: LIST
25106: PUSH
25107: EMPTY
25108: LIST
25109: LIST
25110: PUSH
25111: EMPTY
25112: LIST
25113: LIST
25114: LIST
25115: PPUSH
25116: CALL_OW 69
25120: ST_TO_ADDR
// if not tmp then
25121: LD_VAR 0 8
25125: NOT
25126: IFFALSE 25130
// exit ;
25128: GO 26684
// for i in tmp do
25130: LD_ADDR_VAR 0 6
25134: PUSH
25135: LD_VAR 0 8
25139: PUSH
25140: FOR_IN
25141: IFFALSE 26659
// begin points := [ 0 , 0 , 0 ] ;
25143: LD_ADDR_VAR 0 9
25147: PUSH
25148: LD_INT 0
25150: PUSH
25151: LD_INT 0
25153: PUSH
25154: LD_INT 0
25156: PUSH
25157: EMPTY
25158: LIST
25159: LIST
25160: LIST
25161: ST_TO_ADDR
// bpoints := 1 ;
25162: LD_ADDR_VAR 0 10
25166: PUSH
25167: LD_INT 1
25169: ST_TO_ADDR
// case GetType ( i ) of unit_human :
25170: LD_VAR 0 6
25174: PPUSH
25175: CALL_OW 247
25179: PUSH
25180: LD_INT 1
25182: DOUBLE
25183: EQUAL
25184: IFTRUE 25188
25186: GO 25766
25188: POP
// begin if GetClass ( i ) = 1 then
25189: LD_VAR 0 6
25193: PPUSH
25194: CALL_OW 257
25198: PUSH
25199: LD_INT 1
25201: EQUAL
25202: IFFALSE 25223
// points := [ 10 , 5 , 3 ] ;
25204: LD_ADDR_VAR 0 9
25208: PUSH
25209: LD_INT 10
25211: PUSH
25212: LD_INT 5
25214: PUSH
25215: LD_INT 3
25217: PUSH
25218: EMPTY
25219: LIST
25220: LIST
25221: LIST
25222: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
25223: LD_VAR 0 6
25227: PPUSH
25228: CALL_OW 257
25232: PUSH
25233: LD_INT 2
25235: PUSH
25236: LD_INT 3
25238: PUSH
25239: LD_INT 4
25241: PUSH
25242: EMPTY
25243: LIST
25244: LIST
25245: LIST
25246: IN
25247: IFFALSE 25268
// points := [ 3 , 2 , 1 ] ;
25249: LD_ADDR_VAR 0 9
25253: PUSH
25254: LD_INT 3
25256: PUSH
25257: LD_INT 2
25259: PUSH
25260: LD_INT 1
25262: PUSH
25263: EMPTY
25264: LIST
25265: LIST
25266: LIST
25267: ST_TO_ADDR
// if GetClass ( i ) = 5 then
25268: LD_VAR 0 6
25272: PPUSH
25273: CALL_OW 257
25277: PUSH
25278: LD_INT 5
25280: EQUAL
25281: IFFALSE 25302
// points := [ 130 , 5 , 2 ] ;
25283: LD_ADDR_VAR 0 9
25287: PUSH
25288: LD_INT 130
25290: PUSH
25291: LD_INT 5
25293: PUSH
25294: LD_INT 2
25296: PUSH
25297: EMPTY
25298: LIST
25299: LIST
25300: LIST
25301: ST_TO_ADDR
// if GetClass ( i ) = 8 then
25302: LD_VAR 0 6
25306: PPUSH
25307: CALL_OW 257
25311: PUSH
25312: LD_INT 8
25314: EQUAL
25315: IFFALSE 25336
// points := [ 35 , 35 , 30 ] ;
25317: LD_ADDR_VAR 0 9
25321: PUSH
25322: LD_INT 35
25324: PUSH
25325: LD_INT 35
25327: PUSH
25328: LD_INT 30
25330: PUSH
25331: EMPTY
25332: LIST
25333: LIST
25334: LIST
25335: ST_TO_ADDR
// if GetClass ( i ) = 9 then
25336: LD_VAR 0 6
25340: PPUSH
25341: CALL_OW 257
25345: PUSH
25346: LD_INT 9
25348: EQUAL
25349: IFFALSE 25370
// points := [ 20 , 55 , 40 ] ;
25351: LD_ADDR_VAR 0 9
25355: PUSH
25356: LD_INT 20
25358: PUSH
25359: LD_INT 55
25361: PUSH
25362: LD_INT 40
25364: PUSH
25365: EMPTY
25366: LIST
25367: LIST
25368: LIST
25369: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
25370: LD_VAR 0 6
25374: PPUSH
25375: CALL_OW 257
25379: PUSH
25380: LD_INT 12
25382: PUSH
25383: LD_INT 16
25385: PUSH
25386: EMPTY
25387: LIST
25388: LIST
25389: IN
25390: IFFALSE 25411
// points := [ 5 , 3 , 2 ] ;
25392: LD_ADDR_VAR 0 9
25396: PUSH
25397: LD_INT 5
25399: PUSH
25400: LD_INT 3
25402: PUSH
25403: LD_INT 2
25405: PUSH
25406: EMPTY
25407: LIST
25408: LIST
25409: LIST
25410: ST_TO_ADDR
// if GetClass ( i ) = 17 then
25411: LD_VAR 0 6
25415: PPUSH
25416: CALL_OW 257
25420: PUSH
25421: LD_INT 17
25423: EQUAL
25424: IFFALSE 25445
// points := [ 100 , 50 , 75 ] ;
25426: LD_ADDR_VAR 0 9
25430: PUSH
25431: LD_INT 100
25433: PUSH
25434: LD_INT 50
25436: PUSH
25437: LD_INT 75
25439: PUSH
25440: EMPTY
25441: LIST
25442: LIST
25443: LIST
25444: ST_TO_ADDR
// if GetClass ( i ) = 15 then
25445: LD_VAR 0 6
25449: PPUSH
25450: CALL_OW 257
25454: PUSH
25455: LD_INT 15
25457: EQUAL
25458: IFFALSE 25479
// points := [ 10 , 5 , 3 ] ;
25460: LD_ADDR_VAR 0 9
25464: PUSH
25465: LD_INT 10
25467: PUSH
25468: LD_INT 5
25470: PUSH
25471: LD_INT 3
25473: PUSH
25474: EMPTY
25475: LIST
25476: LIST
25477: LIST
25478: ST_TO_ADDR
// if GetClass ( i ) = 14 then
25479: LD_VAR 0 6
25483: PPUSH
25484: CALL_OW 257
25488: PUSH
25489: LD_INT 14
25491: EQUAL
25492: IFFALSE 25513
// points := [ 10 , 0 , 0 ] ;
25494: LD_ADDR_VAR 0 9
25498: PUSH
25499: LD_INT 10
25501: PUSH
25502: LD_INT 0
25504: PUSH
25505: LD_INT 0
25507: PUSH
25508: EMPTY
25509: LIST
25510: LIST
25511: LIST
25512: ST_TO_ADDR
// if GetClass ( i ) = 11 then
25513: LD_VAR 0 6
25517: PPUSH
25518: CALL_OW 257
25522: PUSH
25523: LD_INT 11
25525: EQUAL
25526: IFFALSE 25547
// points := [ 30 , 10 , 5 ] ;
25528: LD_ADDR_VAR 0 9
25532: PUSH
25533: LD_INT 30
25535: PUSH
25536: LD_INT 10
25538: PUSH
25539: LD_INT 5
25541: PUSH
25542: EMPTY
25543: LIST
25544: LIST
25545: LIST
25546: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
25547: LD_VAR 0 1
25551: PPUSH
25552: LD_INT 5
25554: PPUSH
25555: CALL_OW 321
25559: PUSH
25560: LD_INT 2
25562: EQUAL
25563: IFFALSE 25580
// bpoints := bpoints * 1.8 ;
25565: LD_ADDR_VAR 0 10
25569: PUSH
25570: LD_VAR 0 10
25574: PUSH
25575: LD_REAL  1.80000000000000E+0000
25578: MUL
25579: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
25580: LD_VAR 0 6
25584: PPUSH
25585: CALL_OW 257
25589: PUSH
25590: LD_INT 1
25592: PUSH
25593: LD_INT 2
25595: PUSH
25596: LD_INT 3
25598: PUSH
25599: LD_INT 4
25601: PUSH
25602: EMPTY
25603: LIST
25604: LIST
25605: LIST
25606: LIST
25607: IN
25608: PUSH
25609: LD_VAR 0 1
25613: PPUSH
25614: LD_INT 51
25616: PPUSH
25617: CALL_OW 321
25621: PUSH
25622: LD_INT 2
25624: EQUAL
25625: AND
25626: IFFALSE 25643
// bpoints := bpoints * 1.2 ;
25628: LD_ADDR_VAR 0 10
25632: PUSH
25633: LD_VAR 0 10
25637: PUSH
25638: LD_REAL  1.20000000000000E+0000
25641: MUL
25642: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
25643: LD_VAR 0 6
25647: PPUSH
25648: CALL_OW 257
25652: PUSH
25653: LD_INT 5
25655: PUSH
25656: LD_INT 7
25658: PUSH
25659: LD_INT 9
25661: PUSH
25662: EMPTY
25663: LIST
25664: LIST
25665: LIST
25666: IN
25667: PUSH
25668: LD_VAR 0 1
25672: PPUSH
25673: LD_INT 52
25675: PPUSH
25676: CALL_OW 321
25680: PUSH
25681: LD_INT 2
25683: EQUAL
25684: AND
25685: IFFALSE 25702
// bpoints := bpoints * 1.5 ;
25687: LD_ADDR_VAR 0 10
25691: PUSH
25692: LD_VAR 0 10
25696: PUSH
25697: LD_REAL  1.50000000000000E+0000
25700: MUL
25701: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
25702: LD_VAR 0 1
25706: PPUSH
25707: LD_INT 66
25709: PPUSH
25710: CALL_OW 321
25714: PUSH
25715: LD_INT 2
25717: EQUAL
25718: IFFALSE 25735
// bpoints := bpoints * 1.1 ;
25720: LD_ADDR_VAR 0 10
25724: PUSH
25725: LD_VAR 0 10
25729: PUSH
25730: LD_REAL  1.10000000000000E+0000
25733: MUL
25734: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
25735: LD_ADDR_VAR 0 10
25739: PUSH
25740: LD_VAR 0 10
25744: PUSH
25745: LD_VAR 0 6
25749: PPUSH
25750: LD_INT 1
25752: PPUSH
25753: CALL_OW 259
25757: PUSH
25758: LD_REAL  1.15000000000000E+0000
25761: MUL
25762: MUL
25763: ST_TO_ADDR
// end ; unit_vehicle :
25764: GO 26588
25766: LD_INT 2
25768: DOUBLE
25769: EQUAL
25770: IFTRUE 25774
25772: GO 26576
25774: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
25775: LD_VAR 0 6
25779: PPUSH
25780: CALL_OW 264
25784: PUSH
25785: LD_INT 2
25787: PUSH
25788: LD_INT 42
25790: PUSH
25791: LD_INT 24
25793: PUSH
25794: EMPTY
25795: LIST
25796: LIST
25797: LIST
25798: IN
25799: IFFALSE 25820
// points := [ 25 , 5 , 3 ] ;
25801: LD_ADDR_VAR 0 9
25805: PUSH
25806: LD_INT 25
25808: PUSH
25809: LD_INT 5
25811: PUSH
25812: LD_INT 3
25814: PUSH
25815: EMPTY
25816: LIST
25817: LIST
25818: LIST
25819: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
25820: LD_VAR 0 6
25824: PPUSH
25825: CALL_OW 264
25829: PUSH
25830: LD_INT 4
25832: PUSH
25833: LD_INT 43
25835: PUSH
25836: LD_INT 25
25838: PUSH
25839: EMPTY
25840: LIST
25841: LIST
25842: LIST
25843: IN
25844: IFFALSE 25865
// points := [ 40 , 15 , 5 ] ;
25846: LD_ADDR_VAR 0 9
25850: PUSH
25851: LD_INT 40
25853: PUSH
25854: LD_INT 15
25856: PUSH
25857: LD_INT 5
25859: PUSH
25860: EMPTY
25861: LIST
25862: LIST
25863: LIST
25864: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
25865: LD_VAR 0 6
25869: PPUSH
25870: CALL_OW 264
25874: PUSH
25875: LD_INT 3
25877: PUSH
25878: LD_INT 23
25880: PUSH
25881: EMPTY
25882: LIST
25883: LIST
25884: IN
25885: IFFALSE 25906
// points := [ 7 , 25 , 8 ] ;
25887: LD_ADDR_VAR 0 9
25891: PUSH
25892: LD_INT 7
25894: PUSH
25895: LD_INT 25
25897: PUSH
25898: LD_INT 8
25900: PUSH
25901: EMPTY
25902: LIST
25903: LIST
25904: LIST
25905: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
25906: LD_VAR 0 6
25910: PPUSH
25911: CALL_OW 264
25915: PUSH
25916: LD_INT 5
25918: PUSH
25919: LD_INT 27
25921: PUSH
25922: LD_INT 44
25924: PUSH
25925: EMPTY
25926: LIST
25927: LIST
25928: LIST
25929: IN
25930: IFFALSE 25951
// points := [ 14 , 50 , 16 ] ;
25932: LD_ADDR_VAR 0 9
25936: PUSH
25937: LD_INT 14
25939: PUSH
25940: LD_INT 50
25942: PUSH
25943: LD_INT 16
25945: PUSH
25946: EMPTY
25947: LIST
25948: LIST
25949: LIST
25950: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
25951: LD_VAR 0 6
25955: PPUSH
25956: CALL_OW 264
25960: PUSH
25961: LD_INT 6
25963: PUSH
25964: LD_INT 46
25966: PUSH
25967: EMPTY
25968: LIST
25969: LIST
25970: IN
25971: IFFALSE 25992
// points := [ 32 , 120 , 70 ] ;
25973: LD_ADDR_VAR 0 9
25977: PUSH
25978: LD_INT 32
25980: PUSH
25981: LD_INT 120
25983: PUSH
25984: LD_INT 70
25986: PUSH
25987: EMPTY
25988: LIST
25989: LIST
25990: LIST
25991: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] then
25992: LD_VAR 0 6
25996: PPUSH
25997: CALL_OW 264
26001: PUSH
26002: LD_INT 7
26004: PUSH
26005: LD_INT 28
26007: PUSH
26008: LD_INT 45
26010: PUSH
26011: EMPTY
26012: LIST
26013: LIST
26014: LIST
26015: IN
26016: IFFALSE 26037
// points := [ 35 , 20 , 45 ] ;
26018: LD_ADDR_VAR 0 9
26022: PUSH
26023: LD_INT 35
26025: PUSH
26026: LD_INT 20
26028: PUSH
26029: LD_INT 45
26031: PUSH
26032: EMPTY
26033: LIST
26034: LIST
26035: LIST
26036: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
26037: LD_VAR 0 6
26041: PPUSH
26042: CALL_OW 264
26046: PUSH
26047: LD_INT 47
26049: PUSH
26050: EMPTY
26051: LIST
26052: IN
26053: IFFALSE 26074
// points := [ 67 , 45 , 75 ] ;
26055: LD_ADDR_VAR 0 9
26059: PUSH
26060: LD_INT 67
26062: PUSH
26063: LD_INT 45
26065: PUSH
26066: LD_INT 75
26068: PUSH
26069: EMPTY
26070: LIST
26071: LIST
26072: LIST
26073: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
26074: LD_VAR 0 6
26078: PPUSH
26079: CALL_OW 264
26083: PUSH
26084: LD_INT 26
26086: PUSH
26087: EMPTY
26088: LIST
26089: IN
26090: IFFALSE 26111
// points := [ 120 , 30 , 80 ] ;
26092: LD_ADDR_VAR 0 9
26096: PUSH
26097: LD_INT 120
26099: PUSH
26100: LD_INT 30
26102: PUSH
26103: LD_INT 80
26105: PUSH
26106: EMPTY
26107: LIST
26108: LIST
26109: LIST
26110: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
26111: LD_VAR 0 6
26115: PPUSH
26116: CALL_OW 264
26120: PUSH
26121: LD_INT 22
26123: PUSH
26124: EMPTY
26125: LIST
26126: IN
26127: IFFALSE 26148
// points := [ 40 , 1 , 1 ] ;
26129: LD_ADDR_VAR 0 9
26133: PUSH
26134: LD_INT 40
26136: PUSH
26137: LD_INT 1
26139: PUSH
26140: LD_INT 1
26142: PUSH
26143: EMPTY
26144: LIST
26145: LIST
26146: LIST
26147: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
26148: LD_VAR 0 6
26152: PPUSH
26153: CALL_OW 264
26157: PUSH
26158: LD_INT 29
26160: PUSH
26161: EMPTY
26162: LIST
26163: IN
26164: IFFALSE 26185
// points := [ 70 , 200 , 400 ] ;
26166: LD_ADDR_VAR 0 9
26170: PUSH
26171: LD_INT 70
26173: PUSH
26174: LD_INT 200
26176: PUSH
26177: LD_INT 400
26179: PUSH
26180: EMPTY
26181: LIST
26182: LIST
26183: LIST
26184: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
26185: LD_VAR 0 6
26189: PPUSH
26190: CALL_OW 264
26194: PUSH
26195: LD_INT 14
26197: PUSH
26198: LD_INT 53
26200: PUSH
26201: EMPTY
26202: LIST
26203: LIST
26204: IN
26205: IFFALSE 26226
// points := [ 40 , 10 , 20 ] ;
26207: LD_ADDR_VAR 0 9
26211: PUSH
26212: LD_INT 40
26214: PUSH
26215: LD_INT 10
26217: PUSH
26218: LD_INT 20
26220: PUSH
26221: EMPTY
26222: LIST
26223: LIST
26224: LIST
26225: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
26226: LD_VAR 0 6
26230: PPUSH
26231: CALL_OW 264
26235: PUSH
26236: LD_INT 9
26238: PUSH
26239: EMPTY
26240: LIST
26241: IN
26242: IFFALSE 26263
// points := [ 5 , 70 , 20 ] ;
26244: LD_ADDR_VAR 0 9
26248: PUSH
26249: LD_INT 5
26251: PUSH
26252: LD_INT 70
26254: PUSH
26255: LD_INT 20
26257: PUSH
26258: EMPTY
26259: LIST
26260: LIST
26261: LIST
26262: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
26263: LD_VAR 0 6
26267: PPUSH
26268: CALL_OW 264
26272: PUSH
26273: LD_INT 10
26275: PUSH
26276: EMPTY
26277: LIST
26278: IN
26279: IFFALSE 26300
// points := [ 35 , 110 , 70 ] ;
26281: LD_ADDR_VAR 0 9
26285: PUSH
26286: LD_INT 35
26288: PUSH
26289: LD_INT 110
26291: PUSH
26292: LD_INT 70
26294: PUSH
26295: EMPTY
26296: LIST
26297: LIST
26298: LIST
26299: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
26300: LD_VAR 0 6
26304: PPUSH
26305: CALL_OW 265
26309: PUSH
26310: LD_INT 25
26312: EQUAL
26313: IFFALSE 26334
// points := [ 80 , 65 , 100 ] ;
26315: LD_ADDR_VAR 0 9
26319: PUSH
26320: LD_INT 80
26322: PUSH
26323: LD_INT 65
26325: PUSH
26326: LD_INT 100
26328: PUSH
26329: EMPTY
26330: LIST
26331: LIST
26332: LIST
26333: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
26334: LD_VAR 0 6
26338: PPUSH
26339: CALL_OW 263
26343: PUSH
26344: LD_INT 1
26346: EQUAL
26347: IFFALSE 26382
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
26349: LD_ADDR_VAR 0 10
26353: PUSH
26354: LD_VAR 0 10
26358: PUSH
26359: LD_VAR 0 6
26363: PPUSH
26364: CALL_OW 311
26368: PPUSH
26369: LD_INT 3
26371: PPUSH
26372: CALL_OW 259
26376: PUSH
26377: LD_INT 4
26379: MUL
26380: MUL
26381: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
26382: LD_VAR 0 6
26386: PPUSH
26387: CALL_OW 263
26391: PUSH
26392: LD_INT 2
26394: EQUAL
26395: IFFALSE 26446
// begin j := IsControledBy ( i ) ;
26397: LD_ADDR_VAR 0 7
26401: PUSH
26402: LD_VAR 0 6
26406: PPUSH
26407: CALL_OW 312
26411: ST_TO_ADDR
// if j then
26412: LD_VAR 0 7
26416: IFFALSE 26446
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
26418: LD_ADDR_VAR 0 10
26422: PUSH
26423: LD_VAR 0 10
26427: PUSH
26428: LD_VAR 0 7
26432: PPUSH
26433: LD_INT 3
26435: PPUSH
26436: CALL_OW 259
26440: PUSH
26441: LD_INT 3
26443: MUL
26444: MUL
26445: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
26446: LD_VAR 0 6
26450: PPUSH
26451: CALL_OW 264
26455: PUSH
26456: LD_INT 5
26458: PUSH
26459: LD_INT 6
26461: PUSH
26462: LD_INT 46
26464: PUSH
26465: LD_INT 44
26467: PUSH
26468: LD_INT 47
26470: PUSH
26471: LD_INT 45
26473: PUSH
26474: LD_INT 28
26476: PUSH
26477: LD_INT 7
26479: PUSH
26480: LD_INT 27
26482: PUSH
26483: LD_INT 29
26485: PUSH
26486: EMPTY
26487: LIST
26488: LIST
26489: LIST
26490: LIST
26491: LIST
26492: LIST
26493: LIST
26494: LIST
26495: LIST
26496: LIST
26497: IN
26498: PUSH
26499: LD_VAR 0 1
26503: PPUSH
26504: LD_INT 52
26506: PPUSH
26507: CALL_OW 321
26511: PUSH
26512: LD_INT 2
26514: EQUAL
26515: AND
26516: IFFALSE 26533
// bpoints := bpoints * 1.2 ;
26518: LD_ADDR_VAR 0 10
26522: PUSH
26523: LD_VAR 0 10
26527: PUSH
26528: LD_REAL  1.20000000000000E+0000
26531: MUL
26532: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
26533: LD_VAR 0 6
26537: PPUSH
26538: CALL_OW 264
26542: PUSH
26543: LD_INT 6
26545: PUSH
26546: LD_INT 46
26548: PUSH
26549: LD_INT 47
26551: PUSH
26552: EMPTY
26553: LIST
26554: LIST
26555: LIST
26556: IN
26557: IFFALSE 26574
// bpoints := bpoints * 1.2 ;
26559: LD_ADDR_VAR 0 10
26563: PUSH
26564: LD_VAR 0 10
26568: PUSH
26569: LD_REAL  1.20000000000000E+0000
26572: MUL
26573: ST_TO_ADDR
// end ; unit_building :
26574: GO 26588
26576: LD_INT 3
26578: DOUBLE
26579: EQUAL
26580: IFTRUE 26584
26582: GO 26587
26584: POP
// ; end ;
26585: GO 26588
26587: POP
// for j = 1 to 3 do
26588: LD_ADDR_VAR 0 7
26592: PUSH
26593: DOUBLE
26594: LD_INT 1
26596: DEC
26597: ST_TO_ADDR
26598: LD_INT 3
26600: PUSH
26601: FOR_TO
26602: IFFALSE 26655
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
26604: LD_ADDR_VAR 0 5
26608: PUSH
26609: LD_VAR 0 5
26613: PPUSH
26614: LD_VAR 0 7
26618: PPUSH
26619: LD_VAR 0 5
26623: PUSH
26624: LD_VAR 0 7
26628: ARRAY
26629: PUSH
26630: LD_VAR 0 9
26634: PUSH
26635: LD_VAR 0 7
26639: ARRAY
26640: PUSH
26641: LD_VAR 0 10
26645: MUL
26646: PLUS
26647: PPUSH
26648: CALL_OW 1
26652: ST_TO_ADDR
26653: GO 26601
26655: POP
26656: POP
// end ;
26657: GO 25140
26659: POP
26660: POP
// result := Replace ( result , 4 , tmp ) ;
26661: LD_ADDR_VAR 0 5
26665: PUSH
26666: LD_VAR 0 5
26670: PPUSH
26671: LD_INT 4
26673: PPUSH
26674: LD_VAR 0 8
26678: PPUSH
26679: CALL_OW 1
26683: ST_TO_ADDR
// end ;
26684: LD_VAR 0 5
26688: RET
// export function DangerAtRange ( unit , range ) ; begin
26689: LD_INT 0
26691: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
26692: LD_ADDR_VAR 0 3
26696: PUSH
26697: LD_VAR 0 1
26701: PPUSH
26702: CALL_OW 255
26706: PPUSH
26707: LD_VAR 0 1
26711: PPUSH
26712: CALL_OW 250
26716: PPUSH
26717: LD_VAR 0 1
26721: PPUSH
26722: CALL_OW 251
26726: PPUSH
26727: LD_VAR 0 2
26731: PPUSH
26732: CALL 24992 0 4
26736: ST_TO_ADDR
// end ;
26737: LD_VAR 0 3
26741: RET
// export function DangerInArea ( side , area ) ; begin
26742: LD_INT 0
26744: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
26745: LD_ADDR_VAR 0 3
26749: PUSH
26750: LD_VAR 0 2
26754: PPUSH
26755: LD_INT 81
26757: PUSH
26758: LD_VAR 0 1
26762: PUSH
26763: EMPTY
26764: LIST
26765: LIST
26766: PPUSH
26767: CALL_OW 70
26771: ST_TO_ADDR
// end ;
26772: LD_VAR 0 3
26776: RET
// export function IsExtension ( b ) ; begin
26777: LD_INT 0
26779: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
26780: LD_ADDR_VAR 0 2
26784: PUSH
26785: LD_VAR 0 1
26789: PUSH
26790: LD_INT 23
26792: PUSH
26793: LD_INT 20
26795: PUSH
26796: LD_INT 22
26798: PUSH
26799: LD_INT 17
26801: PUSH
26802: LD_INT 24
26804: PUSH
26805: LD_INT 21
26807: PUSH
26808: LD_INT 19
26810: PUSH
26811: LD_INT 16
26813: PUSH
26814: LD_INT 25
26816: PUSH
26817: LD_INT 18
26819: PUSH
26820: EMPTY
26821: LIST
26822: LIST
26823: LIST
26824: LIST
26825: LIST
26826: LIST
26827: LIST
26828: LIST
26829: LIST
26830: LIST
26831: IN
26832: ST_TO_ADDR
// end ;
26833: LD_VAR 0 2
26837: RET
// export function GetBaseBuildings ( base , area ) ; var tmp , i ; begin
26838: LD_INT 0
26840: PPUSH
26841: PPUSH
26842: PPUSH
// result := [ ] ;
26843: LD_ADDR_VAR 0 3
26847: PUSH
26848: EMPTY
26849: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
26850: LD_ADDR_VAR 0 4
26854: PUSH
26855: LD_VAR 0 2
26859: PPUSH
26860: LD_INT 21
26862: PUSH
26863: LD_INT 3
26865: PUSH
26866: EMPTY
26867: LIST
26868: LIST
26869: PPUSH
26870: CALL_OW 70
26874: ST_TO_ADDR
// if not tmp then
26875: LD_VAR 0 4
26879: NOT
26880: IFFALSE 26884
// exit ;
26882: GO 26942
// for i in tmp do
26884: LD_ADDR_VAR 0 5
26888: PUSH
26889: LD_VAR 0 4
26893: PUSH
26894: FOR_IN
26895: IFFALSE 26930
// if GetBase ( i ) <> base then
26897: LD_VAR 0 5
26901: PPUSH
26902: CALL_OW 274
26906: PUSH
26907: LD_VAR 0 1
26911: NONEQUAL
26912: IFFALSE 26928
// ComLinkToBase ( base , i ) ;
26914: LD_VAR 0 1
26918: PPUSH
26919: LD_VAR 0 5
26923: PPUSH
26924: CALL_OW 169
26928: GO 26894
26930: POP
26931: POP
// result := tmp ;
26932: LD_ADDR_VAR 0 3
26936: PUSH
26937: LD_VAR 0 4
26941: ST_TO_ADDR
// end ;
26942: LD_VAR 0 3
26946: RET
// export function ComComplete ( unit , b ) ; var i ; begin
26947: LD_INT 0
26949: PPUSH
26950: PPUSH
// if BuildingStatus ( b ) = bs_build then
26951: LD_VAR 0 2
26955: PPUSH
26956: CALL_OW 461
26960: PUSH
26961: LD_INT 1
26963: EQUAL
26964: IFFALSE 27024
// SetTaskList ( unit , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
26966: LD_VAR 0 1
26970: PPUSH
26971: LD_STRING h
26973: PUSH
26974: LD_VAR 0 2
26978: PPUSH
26979: CALL_OW 250
26983: PUSH
26984: LD_VAR 0 2
26988: PPUSH
26989: CALL_OW 251
26993: PUSH
26994: LD_VAR 0 2
26998: PUSH
26999: LD_INT 0
27001: PUSH
27002: LD_INT 0
27004: PUSH
27005: LD_INT 0
27007: PUSH
27008: EMPTY
27009: LIST
27010: LIST
27011: LIST
27012: LIST
27013: LIST
27014: LIST
27015: LIST
27016: PUSH
27017: EMPTY
27018: LIST
27019: PPUSH
27020: CALL_OW 446
// end ;
27024: LD_VAR 0 3
27028: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
27029: LD_INT 0
27031: PPUSH
27032: PPUSH
27033: PPUSH
27034: PPUSH
27035: PPUSH
27036: PPUSH
// if not vehicle or not GetControl ( vehicle ) = control_remote then
27037: LD_VAR 0 1
27041: NOT
27042: PUSH
27043: LD_VAR 0 1
27047: PPUSH
27048: CALL_OW 263
27052: PUSH
27053: LD_INT 2
27055: EQUAL
27056: NOT
27057: OR
27058: IFFALSE 27062
// exit ;
27060: GO 27378
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
27062: LD_ADDR_VAR 0 6
27066: PUSH
27067: LD_INT 22
27069: PUSH
27070: LD_VAR 0 1
27074: PPUSH
27075: CALL_OW 255
27079: PUSH
27080: EMPTY
27081: LIST
27082: LIST
27083: PUSH
27084: LD_INT 2
27086: PUSH
27087: LD_INT 30
27089: PUSH
27090: LD_INT 36
27092: PUSH
27093: EMPTY
27094: LIST
27095: LIST
27096: PUSH
27097: LD_INT 34
27099: PUSH
27100: LD_INT 31
27102: PUSH
27103: EMPTY
27104: LIST
27105: LIST
27106: PUSH
27107: EMPTY
27108: LIST
27109: LIST
27110: LIST
27111: PUSH
27112: EMPTY
27113: LIST
27114: LIST
27115: PPUSH
27116: CALL_OW 69
27120: ST_TO_ADDR
// if not tmp then
27121: LD_VAR 0 6
27125: NOT
27126: IFFALSE 27130
// exit ;
27128: GO 27378
// result := [ ] ;
27130: LD_ADDR_VAR 0 2
27134: PUSH
27135: EMPTY
27136: ST_TO_ADDR
// for i in tmp do
27137: LD_ADDR_VAR 0 3
27141: PUSH
27142: LD_VAR 0 6
27146: PUSH
27147: FOR_IN
27148: IFFALSE 27219
// begin t := UnitsInside ( i ) ;
27150: LD_ADDR_VAR 0 4
27154: PUSH
27155: LD_VAR 0 3
27159: PPUSH
27160: CALL_OW 313
27164: ST_TO_ADDR
// if t then
27165: LD_VAR 0 4
27169: IFFALSE 27217
// for j in t do
27171: LD_ADDR_VAR 0 7
27175: PUSH
27176: LD_VAR 0 4
27180: PUSH
27181: FOR_IN
27182: IFFALSE 27215
// result := Insert ( result , result + 1 , j ) ;
27184: LD_ADDR_VAR 0 2
27188: PUSH
27189: LD_VAR 0 2
27193: PPUSH
27194: LD_VAR 0 2
27198: PUSH
27199: LD_INT 1
27201: PLUS
27202: PPUSH
27203: LD_VAR 0 7
27207: PPUSH
27208: CALL_OW 2
27212: ST_TO_ADDR
27213: GO 27181
27215: POP
27216: POP
// end ;
27217: GO 27147
27219: POP
27220: POP
// if not result then
27221: LD_VAR 0 2
27225: NOT
27226: IFFALSE 27230
// exit ;
27228: GO 27378
// mech := result [ 1 ] ;
27230: LD_ADDR_VAR 0 5
27234: PUSH
27235: LD_VAR 0 2
27239: PUSH
27240: LD_INT 1
27242: ARRAY
27243: ST_TO_ADDR
// if result > 1 then
27244: LD_VAR 0 2
27248: PUSH
27249: LD_INT 1
27251: GREATER
27252: IFFALSE 27364
// for i = 2 to result do
27254: LD_ADDR_VAR 0 3
27258: PUSH
27259: DOUBLE
27260: LD_INT 2
27262: DEC
27263: ST_TO_ADDR
27264: LD_VAR 0 2
27268: PUSH
27269: FOR_TO
27270: IFFALSE 27362
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
27272: LD_ADDR_VAR 0 4
27276: PUSH
27277: LD_VAR 0 2
27281: PUSH
27282: LD_VAR 0 3
27286: ARRAY
27287: PPUSH
27288: LD_INT 3
27290: PPUSH
27291: CALL_OW 259
27295: PUSH
27296: LD_VAR 0 2
27300: PUSH
27301: LD_VAR 0 3
27305: ARRAY
27306: PPUSH
27307: CALL_OW 432
27311: MINUS
27312: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
27313: LD_VAR 0 4
27317: PUSH
27318: LD_VAR 0 5
27322: PPUSH
27323: LD_INT 3
27325: PPUSH
27326: CALL_OW 259
27330: PUSH
27331: LD_VAR 0 5
27335: PPUSH
27336: CALL_OW 432
27340: MINUS
27341: GREATEREQUAL
27342: IFFALSE 27360
// mech := result [ i ] ;
27344: LD_ADDR_VAR 0 5
27348: PUSH
27349: LD_VAR 0 2
27353: PUSH
27354: LD_VAR 0 3
27358: ARRAY
27359: ST_TO_ADDR
// end ;
27360: GO 27269
27362: POP
27363: POP
// ComLinkTo ( vehicle , mech ) ;
27364: LD_VAR 0 1
27368: PPUSH
27369: LD_VAR 0 5
27373: PPUSH
27374: CALL_OW 135
// end ;
27378: LD_VAR 0 2
27382: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
27383: LD_INT 0
27385: PPUSH
27386: PPUSH
27387: PPUSH
27388: PPUSH
27389: PPUSH
27390: PPUSH
27391: PPUSH
27392: PPUSH
27393: PPUSH
27394: PPUSH
27395: PPUSH
27396: PPUSH
27397: PPUSH
// result := [ ] ;
27398: LD_ADDR_VAR 0 7
27402: PUSH
27403: EMPTY
27404: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
27405: LD_VAR 0 1
27409: PPUSH
27410: CALL_OW 266
27414: PUSH
27415: LD_INT 0
27417: PUSH
27418: LD_INT 1
27420: PUSH
27421: EMPTY
27422: LIST
27423: LIST
27424: IN
27425: NOT
27426: IFFALSE 27430
// exit ;
27428: GO 29061
// if name then
27430: LD_VAR 0 3
27434: IFFALSE 27450
// SetBName ( base_dep , name ) ;
27436: LD_VAR 0 1
27440: PPUSH
27441: LD_VAR 0 3
27445: PPUSH
27446: CALL_OW 500
// base := GetBase ( base_dep ) ;
27450: LD_ADDR_VAR 0 15
27454: PUSH
27455: LD_VAR 0 1
27459: PPUSH
27460: CALL_OW 274
27464: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
27465: LD_ADDR_VAR 0 16
27469: PUSH
27470: LD_VAR 0 1
27474: PPUSH
27475: CALL_OW 255
27479: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
27480: LD_ADDR_VAR 0 17
27484: PUSH
27485: LD_VAR 0 1
27489: PPUSH
27490: CALL_OW 248
27494: ST_TO_ADDR
// if sources then
27495: LD_VAR 0 5
27499: IFFALSE 27546
// for i = 1 to 3 do
27501: LD_ADDR_VAR 0 8
27505: PUSH
27506: DOUBLE
27507: LD_INT 1
27509: DEC
27510: ST_TO_ADDR
27511: LD_INT 3
27513: PUSH
27514: FOR_TO
27515: IFFALSE 27544
// AddResourceType ( base , i , sources [ i ] ) ;
27517: LD_VAR 0 15
27521: PPUSH
27522: LD_VAR 0 8
27526: PPUSH
27527: LD_VAR 0 5
27531: PUSH
27532: LD_VAR 0 8
27536: ARRAY
27537: PPUSH
27538: CALL_OW 276
27542: GO 27514
27544: POP
27545: POP
// buildings := GetBaseBuildings ( base , area ) ;
27546: LD_ADDR_VAR 0 18
27550: PUSH
27551: LD_VAR 0 15
27555: PPUSH
27556: LD_VAR 0 2
27560: PPUSH
27561: CALL 26838 0 2
27565: ST_TO_ADDR
// InitHc ;
27566: CALL_OW 19
// InitUc ;
27570: CALL_OW 18
// uc_side := side ;
27574: LD_ADDR_OWVAR 20
27578: PUSH
27579: LD_VAR 0 16
27583: ST_TO_ADDR
// uc_nation := nation ;
27584: LD_ADDR_OWVAR 21
27588: PUSH
27589: LD_VAR 0 17
27593: ST_TO_ADDR
// if buildings then
27594: LD_VAR 0 18
27598: IFFALSE 28920
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
27600: LD_ADDR_VAR 0 19
27604: PUSH
27605: LD_VAR 0 18
27609: PPUSH
27610: LD_INT 2
27612: PUSH
27613: LD_INT 30
27615: PUSH
27616: LD_INT 29
27618: PUSH
27619: EMPTY
27620: LIST
27621: LIST
27622: PUSH
27623: LD_INT 30
27625: PUSH
27626: LD_INT 30
27628: PUSH
27629: EMPTY
27630: LIST
27631: LIST
27632: PUSH
27633: EMPTY
27634: LIST
27635: LIST
27636: LIST
27637: PPUSH
27638: CALL_OW 72
27642: ST_TO_ADDR
// if tmp then
27643: LD_VAR 0 19
27647: IFFALSE 27695
// for i in tmp do
27649: LD_ADDR_VAR 0 8
27653: PUSH
27654: LD_VAR 0 19
27658: PUSH
27659: FOR_IN
27660: IFFALSE 27693
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
27662: LD_VAR 0 8
27666: PPUSH
27667: CALL_OW 250
27671: PPUSH
27672: LD_VAR 0 8
27676: PPUSH
27677: CALL_OW 251
27681: PPUSH
27682: LD_VAR 0 16
27686: PPUSH
27687: CALL_OW 441
27691: GO 27659
27693: POP
27694: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
27695: LD_VAR 0 18
27699: PPUSH
27700: LD_INT 2
27702: PUSH
27703: LD_INT 30
27705: PUSH
27706: LD_INT 32
27708: PUSH
27709: EMPTY
27710: LIST
27711: LIST
27712: PUSH
27713: LD_INT 30
27715: PUSH
27716: LD_INT 33
27718: PUSH
27719: EMPTY
27720: LIST
27721: LIST
27722: PUSH
27723: EMPTY
27724: LIST
27725: LIST
27726: LIST
27727: PPUSH
27728: CALL_OW 72
27732: IFFALSE 27820
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
27734: LD_ADDR_VAR 0 8
27738: PUSH
27739: LD_VAR 0 18
27743: PPUSH
27744: LD_INT 2
27746: PUSH
27747: LD_INT 30
27749: PUSH
27750: LD_INT 32
27752: PUSH
27753: EMPTY
27754: LIST
27755: LIST
27756: PUSH
27757: LD_INT 30
27759: PUSH
27760: LD_INT 33
27762: PUSH
27763: EMPTY
27764: LIST
27765: LIST
27766: PUSH
27767: EMPTY
27768: LIST
27769: LIST
27770: LIST
27771: PPUSH
27772: CALL_OW 72
27776: PUSH
27777: FOR_IN
27778: IFFALSE 27818
// begin if not GetBWeapon ( i ) then
27780: LD_VAR 0 8
27784: PPUSH
27785: CALL_OW 269
27789: NOT
27790: IFFALSE 27816
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
27792: LD_VAR 0 8
27796: PPUSH
27797: LD_VAR 0 8
27801: PPUSH
27802: LD_VAR 0 2
27806: PPUSH
27807: CALL 29066 0 2
27811: PPUSH
27812: CALL_OW 431
// end ;
27816: GO 27777
27818: POP
27819: POP
// end ; for i = 1 to personel do
27820: LD_ADDR_VAR 0 8
27824: PUSH
27825: DOUBLE
27826: LD_INT 1
27828: DEC
27829: ST_TO_ADDR
27830: LD_VAR 0 6
27834: PUSH
27835: FOR_TO
27836: IFFALSE 28900
// begin if i > 4 then
27838: LD_VAR 0 8
27842: PUSH
27843: LD_INT 4
27845: GREATER
27846: IFFALSE 27850
// break ;
27848: GO 28900
// case i of 1 :
27850: LD_VAR 0 8
27854: PUSH
27855: LD_INT 1
27857: DOUBLE
27858: EQUAL
27859: IFTRUE 27863
27861: GO 27943
27863: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
27864: LD_ADDR_VAR 0 12
27868: PUSH
27869: LD_VAR 0 18
27873: PPUSH
27874: LD_INT 22
27876: PUSH
27877: LD_VAR 0 16
27881: PUSH
27882: EMPTY
27883: LIST
27884: LIST
27885: PUSH
27886: LD_INT 58
27888: PUSH
27889: EMPTY
27890: LIST
27891: PUSH
27892: LD_INT 2
27894: PUSH
27895: LD_INT 30
27897: PUSH
27898: LD_INT 32
27900: PUSH
27901: EMPTY
27902: LIST
27903: LIST
27904: PUSH
27905: LD_INT 30
27907: PUSH
27908: LD_INT 4
27910: PUSH
27911: EMPTY
27912: LIST
27913: LIST
27914: PUSH
27915: LD_INT 30
27917: PUSH
27918: LD_INT 5
27920: PUSH
27921: EMPTY
27922: LIST
27923: LIST
27924: PUSH
27925: EMPTY
27926: LIST
27927: LIST
27928: LIST
27929: LIST
27930: PUSH
27931: EMPTY
27932: LIST
27933: LIST
27934: LIST
27935: PPUSH
27936: CALL_OW 72
27940: ST_TO_ADDR
27941: GO 28165
27943: LD_INT 2
27945: DOUBLE
27946: EQUAL
27947: IFTRUE 27951
27949: GO 28013
27951: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
27952: LD_ADDR_VAR 0 12
27956: PUSH
27957: LD_VAR 0 18
27961: PPUSH
27962: LD_INT 22
27964: PUSH
27965: LD_VAR 0 16
27969: PUSH
27970: EMPTY
27971: LIST
27972: LIST
27973: PUSH
27974: LD_INT 2
27976: PUSH
27977: LD_INT 30
27979: PUSH
27980: LD_INT 0
27982: PUSH
27983: EMPTY
27984: LIST
27985: LIST
27986: PUSH
27987: LD_INT 30
27989: PUSH
27990: LD_INT 1
27992: PUSH
27993: EMPTY
27994: LIST
27995: LIST
27996: PUSH
27997: EMPTY
27998: LIST
27999: LIST
28000: LIST
28001: PUSH
28002: EMPTY
28003: LIST
28004: LIST
28005: PPUSH
28006: CALL_OW 72
28010: ST_TO_ADDR
28011: GO 28165
28013: LD_INT 3
28015: DOUBLE
28016: EQUAL
28017: IFTRUE 28021
28019: GO 28083
28021: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
28022: LD_ADDR_VAR 0 12
28026: PUSH
28027: LD_VAR 0 18
28031: PPUSH
28032: LD_INT 22
28034: PUSH
28035: LD_VAR 0 16
28039: PUSH
28040: EMPTY
28041: LIST
28042: LIST
28043: PUSH
28044: LD_INT 2
28046: PUSH
28047: LD_INT 30
28049: PUSH
28050: LD_INT 2
28052: PUSH
28053: EMPTY
28054: LIST
28055: LIST
28056: PUSH
28057: LD_INT 30
28059: PUSH
28060: LD_INT 3
28062: PUSH
28063: EMPTY
28064: LIST
28065: LIST
28066: PUSH
28067: EMPTY
28068: LIST
28069: LIST
28070: LIST
28071: PUSH
28072: EMPTY
28073: LIST
28074: LIST
28075: PPUSH
28076: CALL_OW 72
28080: ST_TO_ADDR
28081: GO 28165
28083: LD_INT 4
28085: DOUBLE
28086: EQUAL
28087: IFTRUE 28091
28089: GO 28164
28091: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
28092: LD_ADDR_VAR 0 12
28096: PUSH
28097: LD_VAR 0 18
28101: PPUSH
28102: LD_INT 22
28104: PUSH
28105: LD_VAR 0 16
28109: PUSH
28110: EMPTY
28111: LIST
28112: LIST
28113: PUSH
28114: LD_INT 2
28116: PUSH
28117: LD_INT 30
28119: PUSH
28120: LD_INT 6
28122: PUSH
28123: EMPTY
28124: LIST
28125: LIST
28126: PUSH
28127: LD_INT 30
28129: PUSH
28130: LD_INT 7
28132: PUSH
28133: EMPTY
28134: LIST
28135: LIST
28136: PUSH
28137: LD_INT 30
28139: PUSH
28140: LD_INT 8
28142: PUSH
28143: EMPTY
28144: LIST
28145: LIST
28146: PUSH
28147: EMPTY
28148: LIST
28149: LIST
28150: LIST
28151: LIST
28152: PUSH
28153: EMPTY
28154: LIST
28155: LIST
28156: PPUSH
28157: CALL_OW 72
28161: ST_TO_ADDR
28162: GO 28165
28164: POP
// if i = 1 then
28165: LD_VAR 0 8
28169: PUSH
28170: LD_INT 1
28172: EQUAL
28173: IFFALSE 28284
// begin tmp := [ ] ;
28175: LD_ADDR_VAR 0 19
28179: PUSH
28180: EMPTY
28181: ST_TO_ADDR
// for j in f do
28182: LD_ADDR_VAR 0 9
28186: PUSH
28187: LD_VAR 0 12
28191: PUSH
28192: FOR_IN
28193: IFFALSE 28266
// if GetBType ( j ) = b_bunker then
28195: LD_VAR 0 9
28199: PPUSH
28200: CALL_OW 266
28204: PUSH
28205: LD_INT 32
28207: EQUAL
28208: IFFALSE 28235
// tmp := Insert ( tmp , 1 , j ) else
28210: LD_ADDR_VAR 0 19
28214: PUSH
28215: LD_VAR 0 19
28219: PPUSH
28220: LD_INT 1
28222: PPUSH
28223: LD_VAR 0 9
28227: PPUSH
28228: CALL_OW 2
28232: ST_TO_ADDR
28233: GO 28264
// tmp := Insert ( tmp , tmp + 1 , j ) ;
28235: LD_ADDR_VAR 0 19
28239: PUSH
28240: LD_VAR 0 19
28244: PPUSH
28245: LD_VAR 0 19
28249: PUSH
28250: LD_INT 1
28252: PLUS
28253: PPUSH
28254: LD_VAR 0 9
28258: PPUSH
28259: CALL_OW 2
28263: ST_TO_ADDR
28264: GO 28192
28266: POP
28267: POP
// if tmp then
28268: LD_VAR 0 19
28272: IFFALSE 28284
// f := tmp ;
28274: LD_ADDR_VAR 0 12
28278: PUSH
28279: LD_VAR 0 19
28283: ST_TO_ADDR
// end ; x := personel [ i ] ;
28284: LD_ADDR_VAR 0 13
28288: PUSH
28289: LD_VAR 0 6
28293: PUSH
28294: LD_VAR 0 8
28298: ARRAY
28299: ST_TO_ADDR
// if x = - 1 then
28300: LD_VAR 0 13
28304: PUSH
28305: LD_INT 1
28307: NEG
28308: EQUAL
28309: IFFALSE 28518
// begin for j in f do
28311: LD_ADDR_VAR 0 9
28315: PUSH
28316: LD_VAR 0 12
28320: PUSH
28321: FOR_IN
28322: IFFALSE 28514
// repeat InitHc ;
28324: CALL_OW 19
// if GetBType ( j ) = b_barracks then
28328: LD_VAR 0 9
28332: PPUSH
28333: CALL_OW 266
28337: PUSH
28338: LD_INT 5
28340: EQUAL
28341: IFFALSE 28411
// begin if UnitsInside ( j ) < 3 then
28343: LD_VAR 0 9
28347: PPUSH
28348: CALL_OW 313
28352: PUSH
28353: LD_INT 3
28355: LESS
28356: IFFALSE 28392
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
28358: LD_INT 0
28360: PPUSH
28361: LD_INT 5
28363: PUSH
28364: LD_INT 8
28366: PUSH
28367: LD_INT 9
28369: PUSH
28370: EMPTY
28371: LIST
28372: LIST
28373: LIST
28374: PUSH
28375: LD_VAR 0 17
28379: ARRAY
28380: PPUSH
28381: LD_VAR 0 4
28385: PPUSH
28386: CALL_OW 380
28390: GO 28409
// PrepareHuman ( false , i , skill ) ;
28392: LD_INT 0
28394: PPUSH
28395: LD_VAR 0 8
28399: PPUSH
28400: LD_VAR 0 4
28404: PPUSH
28405: CALL_OW 380
// end else
28409: GO 28428
// PrepareHuman ( false , i , skill ) ;
28411: LD_INT 0
28413: PPUSH
28414: LD_VAR 0 8
28418: PPUSH
28419: LD_VAR 0 4
28423: PPUSH
28424: CALL_OW 380
// un := CreateHuman ;
28428: LD_ADDR_VAR 0 14
28432: PUSH
28433: CALL_OW 44
28437: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
28438: LD_ADDR_VAR 0 7
28442: PUSH
28443: LD_VAR 0 7
28447: PPUSH
28448: LD_INT 1
28450: PPUSH
28451: LD_VAR 0 14
28455: PPUSH
28456: CALL_OW 2
28460: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
28461: LD_VAR 0 14
28465: PPUSH
28466: LD_VAR 0 9
28470: PPUSH
28471: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
28475: LD_VAR 0 9
28479: PPUSH
28480: CALL_OW 313
28484: PUSH
28485: LD_INT 6
28487: EQUAL
28488: PUSH
28489: LD_VAR 0 9
28493: PPUSH
28494: CALL_OW 266
28498: PUSH
28499: LD_INT 32
28501: PUSH
28502: LD_INT 31
28504: PUSH
28505: EMPTY
28506: LIST
28507: LIST
28508: IN
28509: OR
28510: IFFALSE 28324
28512: GO 28321
28514: POP
28515: POP
// end else
28516: GO 28898
// for j = 1 to x do
28518: LD_ADDR_VAR 0 9
28522: PUSH
28523: DOUBLE
28524: LD_INT 1
28526: DEC
28527: ST_TO_ADDR
28528: LD_VAR 0 13
28532: PUSH
28533: FOR_TO
28534: IFFALSE 28896
// begin InitHc ;
28536: CALL_OW 19
// if not f then
28540: LD_VAR 0 12
28544: NOT
28545: IFFALSE 28634
// begin PrepareHuman ( false , i , skill ) ;
28547: LD_INT 0
28549: PPUSH
28550: LD_VAR 0 8
28554: PPUSH
28555: LD_VAR 0 4
28559: PPUSH
28560: CALL_OW 380
// un := CreateHuman ;
28564: LD_ADDR_VAR 0 14
28568: PUSH
28569: CALL_OW 44
28573: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
28574: LD_ADDR_VAR 0 7
28578: PUSH
28579: LD_VAR 0 7
28583: PPUSH
28584: LD_INT 1
28586: PPUSH
28587: LD_VAR 0 14
28591: PPUSH
28592: CALL_OW 2
28596: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
28597: LD_VAR 0 14
28601: PPUSH
28602: LD_VAR 0 1
28606: PPUSH
28607: CALL_OW 250
28611: PPUSH
28612: LD_VAR 0 1
28616: PPUSH
28617: CALL_OW 251
28621: PPUSH
28622: LD_INT 10
28624: PPUSH
28625: LD_INT 0
28627: PPUSH
28628: CALL_OW 50
// continue ;
28632: GO 28533
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
28634: LD_VAR 0 12
28638: PUSH
28639: LD_INT 1
28641: ARRAY
28642: PPUSH
28643: CALL_OW 313
28647: PUSH
28648: LD_VAR 0 12
28652: PUSH
28653: LD_INT 1
28655: ARRAY
28656: PPUSH
28657: CALL_OW 266
28661: PUSH
28662: LD_INT 32
28664: PUSH
28665: LD_INT 31
28667: PUSH
28668: EMPTY
28669: LIST
28670: LIST
28671: IN
28672: AND
28673: PUSH
28674: LD_VAR 0 12
28678: PUSH
28679: LD_INT 1
28681: ARRAY
28682: PPUSH
28683: CALL_OW 313
28687: PUSH
28688: LD_INT 6
28690: EQUAL
28691: OR
28692: IFFALSE 28712
// f := Delete ( f , 1 ) ;
28694: LD_ADDR_VAR 0 12
28698: PUSH
28699: LD_VAR 0 12
28703: PPUSH
28704: LD_INT 1
28706: PPUSH
28707: CALL_OW 3
28711: ST_TO_ADDR
// if not f then
28712: LD_VAR 0 12
28716: NOT
28717: IFFALSE 28735
// begin x := x + 2 ;
28719: LD_ADDR_VAR 0 13
28723: PUSH
28724: LD_VAR 0 13
28728: PUSH
28729: LD_INT 2
28731: PLUS
28732: ST_TO_ADDR
// continue ;
28733: GO 28533
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
28735: LD_VAR 0 12
28739: PUSH
28740: LD_INT 1
28742: ARRAY
28743: PPUSH
28744: CALL_OW 266
28748: PUSH
28749: LD_INT 5
28751: EQUAL
28752: IFFALSE 28826
// begin if UnitsInside ( f [ 1 ] ) < 3 then
28754: LD_VAR 0 12
28758: PUSH
28759: LD_INT 1
28761: ARRAY
28762: PPUSH
28763: CALL_OW 313
28767: PUSH
28768: LD_INT 3
28770: LESS
28771: IFFALSE 28807
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
28773: LD_INT 0
28775: PPUSH
28776: LD_INT 5
28778: PUSH
28779: LD_INT 8
28781: PUSH
28782: LD_INT 9
28784: PUSH
28785: EMPTY
28786: LIST
28787: LIST
28788: LIST
28789: PUSH
28790: LD_VAR 0 17
28794: ARRAY
28795: PPUSH
28796: LD_VAR 0 4
28800: PPUSH
28801: CALL_OW 380
28805: GO 28824
// PrepareHuman ( false , i , skill ) ;
28807: LD_INT 0
28809: PPUSH
28810: LD_VAR 0 8
28814: PPUSH
28815: LD_VAR 0 4
28819: PPUSH
28820: CALL_OW 380
// end else
28824: GO 28843
// PrepareHuman ( false , i , skill ) ;
28826: LD_INT 0
28828: PPUSH
28829: LD_VAR 0 8
28833: PPUSH
28834: LD_VAR 0 4
28838: PPUSH
28839: CALL_OW 380
// un := CreateHuman ;
28843: LD_ADDR_VAR 0 14
28847: PUSH
28848: CALL_OW 44
28852: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
28853: LD_ADDR_VAR 0 7
28857: PUSH
28858: LD_VAR 0 7
28862: PPUSH
28863: LD_INT 1
28865: PPUSH
28866: LD_VAR 0 14
28870: PPUSH
28871: CALL_OW 2
28875: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
28876: LD_VAR 0 14
28880: PPUSH
28881: LD_VAR 0 12
28885: PUSH
28886: LD_INT 1
28888: ARRAY
28889: PPUSH
28890: CALL_OW 52
// end ;
28894: GO 28533
28896: POP
28897: POP
// end ;
28898: GO 27835
28900: POP
28901: POP
// result := result ^ buildings ;
28902: LD_ADDR_VAR 0 7
28906: PUSH
28907: LD_VAR 0 7
28911: PUSH
28912: LD_VAR 0 18
28916: ADD
28917: ST_TO_ADDR
// end else
28918: GO 29061
// begin for i = 1 to personel do
28920: LD_ADDR_VAR 0 8
28924: PUSH
28925: DOUBLE
28926: LD_INT 1
28928: DEC
28929: ST_TO_ADDR
28930: LD_VAR 0 6
28934: PUSH
28935: FOR_TO
28936: IFFALSE 29059
// begin if i > 4 then
28938: LD_VAR 0 8
28942: PUSH
28943: LD_INT 4
28945: GREATER
28946: IFFALSE 28950
// break ;
28948: GO 29059
// x := personel [ i ] ;
28950: LD_ADDR_VAR 0 13
28954: PUSH
28955: LD_VAR 0 6
28959: PUSH
28960: LD_VAR 0 8
28964: ARRAY
28965: ST_TO_ADDR
// if x = - 1 then
28966: LD_VAR 0 13
28970: PUSH
28971: LD_INT 1
28973: NEG
28974: EQUAL
28975: IFFALSE 28979
// continue ;
28977: GO 28935
// PrepareHuman ( false , i , skill ) ;
28979: LD_INT 0
28981: PPUSH
28982: LD_VAR 0 8
28986: PPUSH
28987: LD_VAR 0 4
28991: PPUSH
28992: CALL_OW 380
// un := CreateHuman ;
28996: LD_ADDR_VAR 0 14
29000: PUSH
29001: CALL_OW 44
29005: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
29006: LD_VAR 0 14
29010: PPUSH
29011: LD_VAR 0 1
29015: PPUSH
29016: CALL_OW 250
29020: PPUSH
29021: LD_VAR 0 1
29025: PPUSH
29026: CALL_OW 251
29030: PPUSH
29031: LD_INT 10
29033: PPUSH
29034: LD_INT 0
29036: PPUSH
29037: CALL_OW 50
// result := result ^ un ;
29041: LD_ADDR_VAR 0 7
29045: PUSH
29046: LD_VAR 0 7
29050: PUSH
29051: LD_VAR 0 14
29055: ADD
29056: ST_TO_ADDR
// end ;
29057: GO 28935
29059: POP
29060: POP
// end ; end ;
29061: LD_VAR 0 7
29065: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
29066: LD_INT 0
29068: PPUSH
29069: PPUSH
29070: PPUSH
29071: PPUSH
29072: PPUSH
29073: PPUSH
29074: PPUSH
29075: PPUSH
29076: PPUSH
29077: PPUSH
29078: PPUSH
29079: PPUSH
29080: PPUSH
29081: PPUSH
29082: PPUSH
29083: PPUSH
// result := false ;
29084: LD_ADDR_VAR 0 3
29088: PUSH
29089: LD_INT 0
29091: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
29092: LD_VAR 0 1
29096: NOT
29097: PUSH
29098: LD_VAR 0 1
29102: PPUSH
29103: CALL_OW 266
29107: PUSH
29108: LD_INT 32
29110: PUSH
29111: LD_INT 33
29113: PUSH
29114: EMPTY
29115: LIST
29116: LIST
29117: IN
29118: NOT
29119: OR
29120: IFFALSE 29124
// exit ;
29122: GO 30260
// nat := GetNation ( tower ) ;
29124: LD_ADDR_VAR 0 12
29128: PUSH
29129: LD_VAR 0 1
29133: PPUSH
29134: CALL_OW 248
29138: ST_TO_ADDR
// side := GetSide ( tower ) ;
29139: LD_ADDR_VAR 0 16
29143: PUSH
29144: LD_VAR 0 1
29148: PPUSH
29149: CALL_OW 255
29153: ST_TO_ADDR
// x := GetX ( tower ) ;
29154: LD_ADDR_VAR 0 10
29158: PUSH
29159: LD_VAR 0 1
29163: PPUSH
29164: CALL_OW 250
29168: ST_TO_ADDR
// y := GetY ( tower ) ;
29169: LD_ADDR_VAR 0 11
29173: PUSH
29174: LD_VAR 0 1
29178: PPUSH
29179: CALL_OW 251
29183: ST_TO_ADDR
// if not x or not y then
29184: LD_VAR 0 10
29188: NOT
29189: PUSH
29190: LD_VAR 0 11
29194: NOT
29195: OR
29196: IFFALSE 29200
// exit ;
29198: GO 30260
// weapon := 0 ;
29200: LD_ADDR_VAR 0 18
29204: PUSH
29205: LD_INT 0
29207: ST_TO_ADDR
// fac_list := [ ] ;
29208: LD_ADDR_VAR 0 17
29212: PUSH
29213: EMPTY
29214: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area ) , [ f_btype , b_factory ] ) ;
29215: LD_ADDR_VAR 0 6
29219: PUSH
29220: LD_VAR 0 1
29224: PPUSH
29225: CALL_OW 274
29229: PPUSH
29230: LD_VAR 0 2
29234: PPUSH
29235: CALL 26838 0 2
29239: PPUSH
29240: LD_INT 30
29242: PUSH
29243: LD_INT 3
29245: PUSH
29246: EMPTY
29247: LIST
29248: LIST
29249: PPUSH
29250: CALL_OW 72
29254: ST_TO_ADDR
// if not factories then
29255: LD_VAR 0 6
29259: NOT
29260: IFFALSE 29264
// exit ;
29262: GO 30260
// for i in factories do
29264: LD_ADDR_VAR 0 8
29268: PUSH
29269: LD_VAR 0 6
29273: PUSH
29274: FOR_IN
29275: IFFALSE 29300
// fac_list := fac_list union AvailableWeaponList ( i ) ;
29277: LD_ADDR_VAR 0 17
29281: PUSH
29282: LD_VAR 0 17
29286: PUSH
29287: LD_VAR 0 8
29291: PPUSH
29292: CALL_OW 478
29296: UNION
29297: ST_TO_ADDR
29298: GO 29274
29300: POP
29301: POP
// if not fac_list then
29302: LD_VAR 0 17
29306: NOT
29307: IFFALSE 29311
// exit ;
29309: GO 30260
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
29311: LD_ADDR_VAR 0 5
29315: PUSH
29316: LD_INT 4
29318: PUSH
29319: LD_INT 5
29321: PUSH
29322: LD_INT 9
29324: PUSH
29325: LD_INT 10
29327: PUSH
29328: LD_INT 6
29330: PUSH
29331: LD_INT 7
29333: PUSH
29334: LD_INT 11
29336: PUSH
29337: EMPTY
29338: LIST
29339: LIST
29340: LIST
29341: LIST
29342: LIST
29343: LIST
29344: LIST
29345: PUSH
29346: LD_INT 27
29348: PUSH
29349: LD_INT 28
29351: PUSH
29352: LD_INT 26
29354: PUSH
29355: LD_INT 30
29357: PUSH
29358: EMPTY
29359: LIST
29360: LIST
29361: LIST
29362: LIST
29363: PUSH
29364: LD_INT 43
29366: PUSH
29367: LD_INT 44
29369: PUSH
29370: LD_INT 46
29372: PUSH
29373: LD_INT 45
29375: PUSH
29376: LD_INT 47
29378: PUSH
29379: LD_INT 49
29381: PUSH
29382: EMPTY
29383: LIST
29384: LIST
29385: LIST
29386: LIST
29387: LIST
29388: LIST
29389: PUSH
29390: EMPTY
29391: LIST
29392: LIST
29393: LIST
29394: PUSH
29395: LD_VAR 0 12
29399: ARRAY
29400: ST_TO_ADDR
// for i in list do
29401: LD_ADDR_VAR 0 8
29405: PUSH
29406: LD_VAR 0 5
29410: PUSH
29411: FOR_IN
29412: IFFALSE 29445
// if not i in fac_list then
29414: LD_VAR 0 8
29418: PUSH
29419: LD_VAR 0 17
29423: IN
29424: NOT
29425: IFFALSE 29443
// list := list diff i ;
29427: LD_ADDR_VAR 0 5
29431: PUSH
29432: LD_VAR 0 5
29436: PUSH
29437: LD_VAR 0 8
29441: DIFF
29442: ST_TO_ADDR
29443: GO 29411
29445: POP
29446: POP
// if not list then
29447: LD_VAR 0 5
29451: NOT
29452: IFFALSE 29456
// exit ;
29454: GO 30260
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
29456: LD_VAR 0 12
29460: PUSH
29461: LD_INT 3
29463: EQUAL
29464: PUSH
29465: LD_INT 49
29467: PUSH
29468: LD_VAR 0 5
29472: IN
29473: AND
29474: PUSH
29475: LD_INT 31
29477: PPUSH
29478: LD_VAR 0 16
29482: PPUSH
29483: CALL_OW 321
29487: PUSH
29488: LD_INT 2
29490: EQUAL
29491: AND
29492: IFFALSE 29552
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
29494: LD_INT 22
29496: PUSH
29497: LD_VAR 0 16
29501: PUSH
29502: EMPTY
29503: LIST
29504: LIST
29505: PUSH
29506: LD_INT 35
29508: PUSH
29509: LD_INT 49
29511: PUSH
29512: EMPTY
29513: LIST
29514: LIST
29515: PUSH
29516: LD_INT 91
29518: PUSH
29519: LD_VAR 0 1
29523: PUSH
29524: LD_INT 10
29526: PUSH
29527: EMPTY
29528: LIST
29529: LIST
29530: LIST
29531: PUSH
29532: EMPTY
29533: LIST
29534: LIST
29535: LIST
29536: PPUSH
29537: CALL_OW 69
29541: NOT
29542: IFFALSE 29552
// weapon := ru_time_lapser ;
29544: LD_ADDR_VAR 0 18
29548: PUSH
29549: LD_INT 49
29551: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
29552: LD_VAR 0 12
29556: PUSH
29557: LD_INT 1
29559: PUSH
29560: LD_INT 2
29562: PUSH
29563: EMPTY
29564: LIST
29565: LIST
29566: IN
29567: PUSH
29568: LD_INT 11
29570: PUSH
29571: LD_VAR 0 5
29575: IN
29576: PUSH
29577: LD_INT 30
29579: PUSH
29580: LD_VAR 0 5
29584: IN
29585: OR
29586: AND
29587: PUSH
29588: LD_INT 6
29590: PPUSH
29591: LD_VAR 0 16
29595: PPUSH
29596: CALL_OW 321
29600: PUSH
29601: LD_INT 2
29603: EQUAL
29604: AND
29605: IFFALSE 29770
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
29607: LD_INT 22
29609: PUSH
29610: LD_VAR 0 16
29614: PUSH
29615: EMPTY
29616: LIST
29617: LIST
29618: PUSH
29619: LD_INT 2
29621: PUSH
29622: LD_INT 35
29624: PUSH
29625: LD_INT 11
29627: PUSH
29628: EMPTY
29629: LIST
29630: LIST
29631: PUSH
29632: LD_INT 35
29634: PUSH
29635: LD_INT 30
29637: PUSH
29638: EMPTY
29639: LIST
29640: LIST
29641: PUSH
29642: EMPTY
29643: LIST
29644: LIST
29645: LIST
29646: PUSH
29647: LD_INT 91
29649: PUSH
29650: LD_VAR 0 1
29654: PUSH
29655: LD_INT 18
29657: PUSH
29658: EMPTY
29659: LIST
29660: LIST
29661: LIST
29662: PUSH
29663: EMPTY
29664: LIST
29665: LIST
29666: LIST
29667: PPUSH
29668: CALL_OW 69
29672: NOT
29673: PUSH
29674: LD_INT 22
29676: PUSH
29677: LD_VAR 0 16
29681: PUSH
29682: EMPTY
29683: LIST
29684: LIST
29685: PUSH
29686: LD_INT 2
29688: PUSH
29689: LD_INT 30
29691: PUSH
29692: LD_INT 32
29694: PUSH
29695: EMPTY
29696: LIST
29697: LIST
29698: PUSH
29699: LD_INT 30
29701: PUSH
29702: LD_INT 33
29704: PUSH
29705: EMPTY
29706: LIST
29707: LIST
29708: PUSH
29709: EMPTY
29710: LIST
29711: LIST
29712: LIST
29713: PUSH
29714: LD_INT 91
29716: PUSH
29717: LD_VAR 0 1
29721: PUSH
29722: LD_INT 12
29724: PUSH
29725: EMPTY
29726: LIST
29727: LIST
29728: LIST
29729: PUSH
29730: EMPTY
29731: LIST
29732: LIST
29733: LIST
29734: PUSH
29735: EMPTY
29736: LIST
29737: PPUSH
29738: CALL_OW 69
29742: PUSH
29743: LD_INT 2
29745: GREATER
29746: AND
29747: IFFALSE 29770
// weapon := [ us_radar , ar_radar ] [ nat ] ;
29749: LD_ADDR_VAR 0 18
29753: PUSH
29754: LD_INT 11
29756: PUSH
29757: LD_INT 30
29759: PUSH
29760: EMPTY
29761: LIST
29762: LIST
29763: PUSH
29764: LD_VAR 0 12
29768: ARRAY
29769: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
29770: LD_VAR 0 18
29774: NOT
29775: PUSH
29776: LD_INT 40
29778: PPUSH
29779: LD_VAR 0 16
29783: PPUSH
29784: CALL_OW 321
29788: PUSH
29789: LD_INT 2
29791: EQUAL
29792: AND
29793: PUSH
29794: LD_INT 7
29796: PUSH
29797: LD_VAR 0 5
29801: IN
29802: PUSH
29803: LD_INT 28
29805: PUSH
29806: LD_VAR 0 5
29810: IN
29811: OR
29812: PUSH
29813: LD_INT 45
29815: PUSH
29816: LD_VAR 0 5
29820: IN
29821: OR
29822: AND
29823: IFFALSE 30077
// begin hex := GetHexInfo ( x , y ) ;
29825: LD_ADDR_VAR 0 4
29829: PUSH
29830: LD_VAR 0 10
29834: PPUSH
29835: LD_VAR 0 11
29839: PPUSH
29840: CALL_OW 546
29844: ST_TO_ADDR
// if hex [ 1 ] then
29845: LD_VAR 0 4
29849: PUSH
29850: LD_INT 1
29852: ARRAY
29853: IFFALSE 29857
// exit ;
29855: GO 30260
// height := hex [ 2 ] ;
29857: LD_ADDR_VAR 0 15
29861: PUSH
29862: LD_VAR 0 4
29866: PUSH
29867: LD_INT 2
29869: ARRAY
29870: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
29871: LD_ADDR_VAR 0 14
29875: PUSH
29876: LD_INT 0
29878: PUSH
29879: LD_INT 2
29881: PUSH
29882: LD_INT 3
29884: PUSH
29885: LD_INT 5
29887: PUSH
29888: EMPTY
29889: LIST
29890: LIST
29891: LIST
29892: LIST
29893: ST_TO_ADDR
// for i in tmp do
29894: LD_ADDR_VAR 0 8
29898: PUSH
29899: LD_VAR 0 14
29903: PUSH
29904: FOR_IN
29905: IFFALSE 30075
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
29907: LD_ADDR_VAR 0 9
29911: PUSH
29912: LD_VAR 0 10
29916: PPUSH
29917: LD_VAR 0 8
29921: PPUSH
29922: LD_INT 5
29924: PPUSH
29925: CALL_OW 272
29929: PUSH
29930: LD_VAR 0 11
29934: PPUSH
29935: LD_VAR 0 8
29939: PPUSH
29940: LD_INT 5
29942: PPUSH
29943: CALL_OW 273
29947: PUSH
29948: EMPTY
29949: LIST
29950: LIST
29951: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
29952: LD_VAR 0 9
29956: PUSH
29957: LD_INT 1
29959: ARRAY
29960: PPUSH
29961: LD_VAR 0 9
29965: PUSH
29966: LD_INT 2
29968: ARRAY
29969: PPUSH
29970: CALL_OW 488
29974: IFFALSE 30073
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
29976: LD_ADDR_VAR 0 4
29980: PUSH
29981: LD_VAR 0 9
29985: PUSH
29986: LD_INT 1
29988: ARRAY
29989: PPUSH
29990: LD_VAR 0 9
29994: PUSH
29995: LD_INT 2
29997: ARRAY
29998: PPUSH
29999: CALL_OW 546
30003: ST_TO_ADDR
// if hex [ 1 ] then
30004: LD_VAR 0 4
30008: PUSH
30009: LD_INT 1
30011: ARRAY
30012: IFFALSE 30016
// continue ;
30014: GO 29904
// h := hex [ 2 ] ;
30016: LD_ADDR_VAR 0 13
30020: PUSH
30021: LD_VAR 0 4
30025: PUSH
30026: LD_INT 2
30028: ARRAY
30029: ST_TO_ADDR
// if h + 7 < height then
30030: LD_VAR 0 13
30034: PUSH
30035: LD_INT 7
30037: PLUS
30038: PUSH
30039: LD_VAR 0 15
30043: LESS
30044: IFFALSE 30073
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
30046: LD_ADDR_VAR 0 18
30050: PUSH
30051: LD_INT 7
30053: PUSH
30054: LD_INT 28
30056: PUSH
30057: LD_INT 45
30059: PUSH
30060: EMPTY
30061: LIST
30062: LIST
30063: LIST
30064: PUSH
30065: LD_VAR 0 12
30069: ARRAY
30070: ST_TO_ADDR
// break ;
30071: GO 30075
// end ; end ; end ;
30073: GO 29904
30075: POP
30076: POP
// end ; if not weapon then
30077: LD_VAR 0 18
30081: NOT
30082: IFFALSE 30142
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
30084: LD_ADDR_VAR 0 5
30088: PUSH
30089: LD_VAR 0 5
30093: PUSH
30094: LD_INT 11
30096: PUSH
30097: LD_INT 30
30099: PUSH
30100: LD_INT 49
30102: PUSH
30103: EMPTY
30104: LIST
30105: LIST
30106: LIST
30107: DIFF
30108: ST_TO_ADDR
// if not list then
30109: LD_VAR 0 5
30113: NOT
30114: IFFALSE 30118
// exit ;
30116: GO 30260
// weapon := list [ rand ( 1 , list ) ] ;
30118: LD_ADDR_VAR 0 18
30122: PUSH
30123: LD_VAR 0 5
30127: PUSH
30128: LD_INT 1
30130: PPUSH
30131: LD_VAR 0 5
30135: PPUSH
30136: CALL_OW 12
30140: ARRAY
30141: ST_TO_ADDR
// end ; if weapon then
30142: LD_VAR 0 18
30146: IFFALSE 30260
// begin tmp := CostOfWeapon ( weapon ) ;
30148: LD_ADDR_VAR 0 14
30152: PUSH
30153: LD_VAR 0 18
30157: PPUSH
30158: CALL_OW 451
30162: ST_TO_ADDR
// j := GetBase ( tower ) ;
30163: LD_ADDR_VAR 0 9
30167: PUSH
30168: LD_VAR 0 1
30172: PPUSH
30173: CALL_OW 274
30177: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
30178: LD_VAR 0 9
30182: PPUSH
30183: LD_INT 1
30185: PPUSH
30186: CALL_OW 275
30190: PUSH
30191: LD_VAR 0 14
30195: PUSH
30196: LD_INT 1
30198: ARRAY
30199: GREATEREQUAL
30200: PUSH
30201: LD_VAR 0 9
30205: PPUSH
30206: LD_INT 2
30208: PPUSH
30209: CALL_OW 275
30213: PUSH
30214: LD_VAR 0 14
30218: PUSH
30219: LD_INT 2
30221: ARRAY
30222: GREATEREQUAL
30223: AND
30224: PUSH
30225: LD_VAR 0 9
30229: PPUSH
30230: LD_INT 3
30232: PPUSH
30233: CALL_OW 275
30237: PUSH
30238: LD_VAR 0 14
30242: PUSH
30243: LD_INT 3
30245: ARRAY
30246: GREATEREQUAL
30247: AND
30248: IFFALSE 30260
// result := weapon ;
30250: LD_ADDR_VAR 0 3
30254: PUSH
30255: LD_VAR 0 18
30259: ST_TO_ADDR
// end ; end ;
30260: LD_VAR 0 3
30264: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
30265: LD_INT 0
30267: PPUSH
30268: PPUSH
// result := true ;
30269: LD_ADDR_VAR 0 3
30273: PUSH
30274: LD_INT 1
30276: ST_TO_ADDR
// if array1 = array2 then
30277: LD_VAR 0 1
30281: PUSH
30282: LD_VAR 0 2
30286: EQUAL
30287: IFFALSE 30347
// begin for i = 1 to array1 do
30289: LD_ADDR_VAR 0 4
30293: PUSH
30294: DOUBLE
30295: LD_INT 1
30297: DEC
30298: ST_TO_ADDR
30299: LD_VAR 0 1
30303: PUSH
30304: FOR_TO
30305: IFFALSE 30343
// if array1 [ i ] <> array2 [ i ] then
30307: LD_VAR 0 1
30311: PUSH
30312: LD_VAR 0 4
30316: ARRAY
30317: PUSH
30318: LD_VAR 0 2
30322: PUSH
30323: LD_VAR 0 4
30327: ARRAY
30328: NONEQUAL
30329: IFFALSE 30341
// begin result := false ;
30331: LD_ADDR_VAR 0 3
30335: PUSH
30336: LD_INT 0
30338: ST_TO_ADDR
// break ;
30339: GO 30343
// end ;
30341: GO 30304
30343: POP
30344: POP
// end else
30345: GO 30355
// result := false ;
30347: LD_ADDR_VAR 0 3
30351: PUSH
30352: LD_INT 0
30354: ST_TO_ADDR
// end ;
30355: LD_VAR 0 3
30359: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
30360: LD_INT 0
30362: PPUSH
30363: PPUSH
30364: PPUSH
// pom := GetBase ( fac ) ;
30365: LD_ADDR_VAR 0 5
30369: PUSH
30370: LD_VAR 0 1
30374: PPUSH
30375: CALL_OW 274
30379: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
30380: LD_ADDR_VAR 0 4
30384: PUSH
30385: LD_VAR 0 2
30389: PUSH
30390: LD_INT 1
30392: ARRAY
30393: PPUSH
30394: LD_VAR 0 2
30398: PUSH
30399: LD_INT 2
30401: ARRAY
30402: PPUSH
30403: LD_VAR 0 2
30407: PUSH
30408: LD_INT 3
30410: ARRAY
30411: PPUSH
30412: LD_VAR 0 2
30416: PUSH
30417: LD_INT 4
30419: ARRAY
30420: PPUSH
30421: CALL_OW 449
30425: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
30426: LD_ADDR_VAR 0 3
30430: PUSH
30431: LD_VAR 0 5
30435: PPUSH
30436: LD_INT 1
30438: PPUSH
30439: CALL_OW 275
30443: PUSH
30444: LD_VAR 0 4
30448: PUSH
30449: LD_INT 1
30451: ARRAY
30452: GREATEREQUAL
30453: PUSH
30454: LD_VAR 0 5
30458: PPUSH
30459: LD_INT 2
30461: PPUSH
30462: CALL_OW 275
30466: PUSH
30467: LD_VAR 0 4
30471: PUSH
30472: LD_INT 2
30474: ARRAY
30475: GREATEREQUAL
30476: AND
30477: PUSH
30478: LD_VAR 0 5
30482: PPUSH
30483: LD_INT 3
30485: PPUSH
30486: CALL_OW 275
30490: PUSH
30491: LD_VAR 0 4
30495: PUSH
30496: LD_INT 3
30498: ARRAY
30499: GREATEREQUAL
30500: AND
30501: ST_TO_ADDR
// end ;
30502: LD_VAR 0 3
30506: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
30507: LD_INT 0
30509: PPUSH
30510: PPUSH
30511: PPUSH
30512: PPUSH
// pom := GetBase ( building ) ;
30513: LD_ADDR_VAR 0 3
30517: PUSH
30518: LD_VAR 0 1
30522: PPUSH
30523: CALL_OW 274
30527: ST_TO_ADDR
// if not pom then
30528: LD_VAR 0 3
30532: NOT
30533: IFFALSE 30537
// exit ;
30535: GO 30707
// btype := GetBType ( building ) ;
30537: LD_ADDR_VAR 0 5
30541: PUSH
30542: LD_VAR 0 1
30546: PPUSH
30547: CALL_OW 266
30551: ST_TO_ADDR
// if btype = b_armoury then
30552: LD_VAR 0 5
30556: PUSH
30557: LD_INT 4
30559: EQUAL
30560: IFFALSE 30570
// btype := b_barracks ;
30562: LD_ADDR_VAR 0 5
30566: PUSH
30567: LD_INT 5
30569: ST_TO_ADDR
// if btype = b_depot then
30570: LD_VAR 0 5
30574: PUSH
30575: LD_INT 0
30577: EQUAL
30578: IFFALSE 30588
// btype := b_warehouse ;
30580: LD_ADDR_VAR 0 5
30584: PUSH
30585: LD_INT 1
30587: ST_TO_ADDR
// if btype = b_workshop then
30588: LD_VAR 0 5
30592: PUSH
30593: LD_INT 2
30595: EQUAL
30596: IFFALSE 30606
// btype := b_factory ;
30598: LD_ADDR_VAR 0 5
30602: PUSH
30603: LD_INT 3
30605: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
30606: LD_ADDR_VAR 0 4
30610: PUSH
30611: LD_VAR 0 5
30615: PPUSH
30616: LD_VAR 0 1
30620: PPUSH
30621: CALL_OW 248
30625: PPUSH
30626: CALL_OW 450
30630: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
30631: LD_ADDR_VAR 0 2
30635: PUSH
30636: LD_VAR 0 3
30640: PPUSH
30641: LD_INT 1
30643: PPUSH
30644: CALL_OW 275
30648: PUSH
30649: LD_VAR 0 4
30653: PUSH
30654: LD_INT 1
30656: ARRAY
30657: GREATEREQUAL
30658: PUSH
30659: LD_VAR 0 3
30663: PPUSH
30664: LD_INT 2
30666: PPUSH
30667: CALL_OW 275
30671: PUSH
30672: LD_VAR 0 4
30676: PUSH
30677: LD_INT 2
30679: ARRAY
30680: GREATEREQUAL
30681: AND
30682: PUSH
30683: LD_VAR 0 3
30687: PPUSH
30688: LD_INT 3
30690: PPUSH
30691: CALL_OW 275
30695: PUSH
30696: LD_VAR 0 4
30700: PUSH
30701: LD_INT 3
30703: ARRAY
30704: GREATEREQUAL
30705: AND
30706: ST_TO_ADDR
// end ;
30707: LD_VAR 0 2
30711: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
30712: LD_INT 0
30714: PPUSH
30715: PPUSH
30716: PPUSH
// pom := GetBase ( building ) ;
30717: LD_ADDR_VAR 0 4
30721: PUSH
30722: LD_VAR 0 1
30726: PPUSH
30727: CALL_OW 274
30731: ST_TO_ADDR
// if not pom then
30732: LD_VAR 0 4
30736: NOT
30737: IFFALSE 30741
// exit ;
30739: GO 30842
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
30741: LD_ADDR_VAR 0 5
30745: PUSH
30746: LD_VAR 0 2
30750: PPUSH
30751: LD_VAR 0 1
30755: PPUSH
30756: CALL_OW 248
30760: PPUSH
30761: CALL_OW 450
30765: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
30766: LD_ADDR_VAR 0 3
30770: PUSH
30771: LD_VAR 0 4
30775: PPUSH
30776: LD_INT 1
30778: PPUSH
30779: CALL_OW 275
30783: PUSH
30784: LD_VAR 0 5
30788: PUSH
30789: LD_INT 1
30791: ARRAY
30792: GREATEREQUAL
30793: PUSH
30794: LD_VAR 0 4
30798: PPUSH
30799: LD_INT 2
30801: PPUSH
30802: CALL_OW 275
30806: PUSH
30807: LD_VAR 0 5
30811: PUSH
30812: LD_INT 2
30814: ARRAY
30815: GREATEREQUAL
30816: AND
30817: PUSH
30818: LD_VAR 0 4
30822: PPUSH
30823: LD_INT 3
30825: PPUSH
30826: CALL_OW 275
30830: PUSH
30831: LD_VAR 0 5
30835: PUSH
30836: LD_INT 3
30838: ARRAY
30839: GREATEREQUAL
30840: AND
30841: ST_TO_ADDR
// end ;
30842: LD_VAR 0 3
30846: RET
// export function TryClearPlaceForBuilding ( base , btype , x , y , d ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep ; begin
30847: LD_INT 0
30849: PPUSH
30850: PPUSH
30851: PPUSH
30852: PPUSH
30853: PPUSH
30854: PPUSH
30855: PPUSH
30856: PPUSH
30857: PPUSH
30858: PPUSH
// result := false ;
30859: LD_ADDR_VAR 0 6
30863: PUSH
30864: LD_INT 0
30866: ST_TO_ADDR
// if not base or not btype or not x or not y then
30867: LD_VAR 0 1
30871: NOT
30872: PUSH
30873: LD_VAR 0 2
30877: NOT
30878: OR
30879: PUSH
30880: LD_VAR 0 3
30884: NOT
30885: OR
30886: PUSH
30887: LD_VAR 0 4
30891: NOT
30892: OR
30893: IFFALSE 30897
// exit ;
30895: GO 31506
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( base [ 1 ] ) , 0 ) ;
30897: LD_ADDR_VAR 0 12
30901: PUSH
30902: LD_VAR 0 2
30906: PPUSH
30907: LD_VAR 0 3
30911: PPUSH
30912: LD_VAR 0 4
30916: PPUSH
30917: LD_VAR 0 5
30921: PPUSH
30922: LD_VAR 0 1
30926: PUSH
30927: LD_INT 1
30929: ARRAY
30930: PPUSH
30931: CALL_OW 248
30935: PPUSH
30936: LD_INT 0
30938: PPUSH
30939: CALL 32343 0 6
30943: ST_TO_ADDR
// if not hexes then
30944: LD_VAR 0 12
30948: NOT
30949: IFFALSE 30953
// exit ;
30951: GO 31506
// for i = 1 to hexes do
30953: LD_ADDR_VAR 0 7
30957: PUSH
30958: DOUBLE
30959: LD_INT 1
30961: DEC
30962: ST_TO_ADDR
30963: LD_VAR 0 12
30967: PUSH
30968: FOR_TO
30969: IFFALSE 31504
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
30971: LD_ADDR_VAR 0 11
30975: PUSH
30976: LD_VAR 0 12
30980: PUSH
30981: LD_VAR 0 7
30985: ARRAY
30986: PUSH
30987: LD_INT 1
30989: ARRAY
30990: PPUSH
30991: LD_VAR 0 12
30995: PUSH
30996: LD_VAR 0 7
31000: ARRAY
31001: PUSH
31002: LD_INT 2
31004: ARRAY
31005: PPUSH
31006: CALL_OW 428
31010: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
31011: LD_VAR 0 12
31015: PUSH
31016: LD_VAR 0 7
31020: ARRAY
31021: PUSH
31022: LD_INT 1
31024: ARRAY
31025: PPUSH
31026: LD_VAR 0 12
31030: PUSH
31031: LD_VAR 0 7
31035: ARRAY
31036: PUSH
31037: LD_INT 2
31039: ARRAY
31040: PPUSH
31041: CALL_OW 351
31045: PUSH
31046: LD_VAR 0 12
31050: PUSH
31051: LD_VAR 0 7
31055: ARRAY
31056: PUSH
31057: LD_INT 1
31059: ARRAY
31060: PPUSH
31061: LD_VAR 0 12
31065: PUSH
31066: LD_VAR 0 7
31070: ARRAY
31071: PUSH
31072: LD_INT 2
31074: ARRAY
31075: PPUSH
31076: CALL_OW 488
31080: NOT
31081: OR
31082: PUSH
31083: LD_VAR 0 11
31087: PPUSH
31088: CALL_OW 247
31092: PUSH
31093: LD_INT 3
31095: EQUAL
31096: OR
31097: IFFALSE 31103
// exit ;
31099: POP
31100: POP
31101: GO 31506
// if not tmp or not tmp in base then
31103: LD_VAR 0 11
31107: NOT
31108: PUSH
31109: LD_VAR 0 11
31113: PUSH
31114: LD_VAR 0 1
31118: IN
31119: NOT
31120: OR
31121: IFFALSE 31125
// continue ;
31123: GO 30968
// result := true ;
31125: LD_ADDR_VAR 0 6
31129: PUSH
31130: LD_INT 1
31132: ST_TO_ADDR
// dep := UnitFilter ( base , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
31133: LD_ADDR_VAR 0 15
31137: PUSH
31138: LD_VAR 0 1
31142: PPUSH
31143: LD_INT 22
31145: PUSH
31146: LD_VAR 0 11
31150: PPUSH
31151: CALL_OW 255
31155: PUSH
31156: EMPTY
31157: LIST
31158: LIST
31159: PUSH
31160: LD_INT 2
31162: PUSH
31163: LD_INT 30
31165: PUSH
31166: LD_INT 0
31168: PUSH
31169: EMPTY
31170: LIST
31171: LIST
31172: PUSH
31173: LD_INT 30
31175: PUSH
31176: LD_INT 1
31178: PUSH
31179: EMPTY
31180: LIST
31181: LIST
31182: PUSH
31183: EMPTY
31184: LIST
31185: LIST
31186: LIST
31187: PUSH
31188: EMPTY
31189: LIST
31190: LIST
31191: PPUSH
31192: CALL_OW 72
31196: ST_TO_ADDR
// if dep then
31197: LD_VAR 0 15
31201: IFFALSE 31337
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
31203: LD_ADDR_VAR 0 14
31207: PUSH
31208: LD_VAR 0 15
31212: PUSH
31213: LD_INT 1
31215: ARRAY
31216: PPUSH
31217: CALL_OW 250
31221: PPUSH
31222: LD_VAR 0 15
31226: PUSH
31227: LD_INT 1
31229: ARRAY
31230: PPUSH
31231: CALL_OW 254
31235: PPUSH
31236: LD_INT 5
31238: PPUSH
31239: CALL_OW 272
31243: PUSH
31244: LD_VAR 0 15
31248: PUSH
31249: LD_INT 1
31251: ARRAY
31252: PPUSH
31253: CALL_OW 251
31257: PPUSH
31258: LD_VAR 0 15
31262: PUSH
31263: LD_INT 1
31265: ARRAY
31266: PPUSH
31267: CALL_OW 254
31271: PPUSH
31272: LD_INT 5
31274: PPUSH
31275: CALL_OW 273
31279: PUSH
31280: EMPTY
31281: LIST
31282: LIST
31283: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
31284: LD_VAR 0 14
31288: PUSH
31289: LD_INT 1
31291: ARRAY
31292: PPUSH
31293: LD_VAR 0 14
31297: PUSH
31298: LD_INT 2
31300: ARRAY
31301: PPUSH
31302: CALL_OW 488
31306: IFFALSE 31337
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
31308: LD_VAR 0 11
31312: PPUSH
31313: LD_VAR 0 14
31317: PUSH
31318: LD_INT 1
31320: ARRAY
31321: PPUSH
31322: LD_VAR 0 14
31326: PUSH
31327: LD_INT 2
31329: ARRAY
31330: PPUSH
31331: CALL_OW 111
// continue ;
31335: GO 30968
// end ; end ; r := GetDir ( tmp ) ;
31337: LD_ADDR_VAR 0 13
31341: PUSH
31342: LD_VAR 0 11
31346: PPUSH
31347: CALL_OW 254
31351: ST_TO_ADDR
// if r = 5 then
31352: LD_VAR 0 13
31356: PUSH
31357: LD_INT 5
31359: EQUAL
31360: IFFALSE 31370
// r := 0 ;
31362: LD_ADDR_VAR 0 13
31366: PUSH
31367: LD_INT 0
31369: ST_TO_ADDR
// for j = r to 5 do
31370: LD_ADDR_VAR 0 8
31374: PUSH
31375: DOUBLE
31376: LD_VAR 0 13
31380: DEC
31381: ST_TO_ADDR
31382: LD_INT 5
31384: PUSH
31385: FOR_TO
31386: IFFALSE 31500
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
31388: LD_ADDR_VAR 0 9
31392: PUSH
31393: LD_VAR 0 11
31397: PPUSH
31398: CALL_OW 250
31402: PPUSH
31403: LD_VAR 0 8
31407: PPUSH
31408: LD_INT 2
31410: PPUSH
31411: CALL_OW 272
31415: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
31416: LD_ADDR_VAR 0 10
31420: PUSH
31421: LD_VAR 0 11
31425: PPUSH
31426: CALL_OW 251
31430: PPUSH
31431: LD_VAR 0 8
31435: PPUSH
31436: LD_INT 2
31438: PPUSH
31439: CALL_OW 273
31443: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
31444: LD_VAR 0 9
31448: PPUSH
31449: LD_VAR 0 10
31453: PPUSH
31454: CALL_OW 488
31458: PUSH
31459: LD_VAR 0 9
31463: PPUSH
31464: LD_VAR 0 10
31468: PPUSH
31469: CALL_OW 428
31473: NOT
31474: AND
31475: IFFALSE 31498
// begin ComMoveXY ( tmp , _x , _y ) ;
31477: LD_VAR 0 11
31481: PPUSH
31482: LD_VAR 0 9
31486: PPUSH
31487: LD_VAR 0 10
31491: PPUSH
31492: CALL_OW 111
// break ;
31496: GO 31500
// end ; end ;
31498: GO 31385
31500: POP
31501: POP
// end ;
31502: GO 30968
31504: POP
31505: POP
// end ;
31506: LD_VAR 0 6
31510: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex ; begin
31511: LD_INT 0
31513: PPUSH
31514: PPUSH
31515: PPUSH
31516: PPUSH
31517: PPUSH
31518: PPUSH
31519: PPUSH
31520: PPUSH
31521: PPUSH
31522: PPUSH
// result := false ;
31523: LD_ADDR_VAR 0 6
31527: PUSH
31528: LD_INT 0
31530: ST_TO_ADDR
// if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
31531: LD_VAR 0 1
31535: NOT
31536: PUSH
31537: LD_VAR 0 1
31541: PPUSH
31542: CALL_OW 266
31546: PUSH
31547: LD_INT 0
31549: PUSH
31550: LD_INT 1
31552: PUSH
31553: EMPTY
31554: LIST
31555: LIST
31556: IN
31557: NOT
31558: OR
31559: PUSH
31560: LD_VAR 0 2
31564: NOT
31565: OR
31566: PUSH
31567: LD_VAR 0 5
31571: PUSH
31572: LD_INT 0
31574: PUSH
31575: LD_INT 1
31577: PUSH
31578: LD_INT 2
31580: PUSH
31581: LD_INT 3
31583: PUSH
31584: LD_INT 4
31586: PUSH
31587: LD_INT 5
31589: PUSH
31590: EMPTY
31591: LIST
31592: LIST
31593: LIST
31594: LIST
31595: LIST
31596: LIST
31597: IN
31598: NOT
31599: OR
31600: PUSH
31601: LD_VAR 0 3
31605: PPUSH
31606: LD_VAR 0 4
31610: PPUSH
31611: CALL_OW 488
31615: NOT
31616: OR
31617: IFFALSE 31621
// exit ;
31619: GO 32338
// pom := GetBase ( depot ) ;
31621: LD_ADDR_VAR 0 10
31625: PUSH
31626: LD_VAR 0 1
31630: PPUSH
31631: CALL_OW 274
31635: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
31636: LD_ADDR_VAR 0 11
31640: PUSH
31641: LD_VAR 0 2
31645: PPUSH
31646: LD_VAR 0 1
31650: PPUSH
31651: CALL_OW 248
31655: PPUSH
31656: CALL_OW 450
31660: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
31661: LD_VAR 0 10
31665: PPUSH
31666: LD_INT 1
31668: PPUSH
31669: CALL_OW 275
31673: PUSH
31674: LD_VAR 0 11
31678: PUSH
31679: LD_INT 1
31681: ARRAY
31682: GREATEREQUAL
31683: PUSH
31684: LD_VAR 0 10
31688: PPUSH
31689: LD_INT 2
31691: PPUSH
31692: CALL_OW 275
31696: PUSH
31697: LD_VAR 0 11
31701: PUSH
31702: LD_INT 2
31704: ARRAY
31705: GREATEREQUAL
31706: AND
31707: PUSH
31708: LD_VAR 0 10
31712: PPUSH
31713: LD_INT 3
31715: PPUSH
31716: CALL_OW 275
31720: PUSH
31721: LD_VAR 0 11
31725: PUSH
31726: LD_INT 3
31728: ARRAY
31729: GREATEREQUAL
31730: AND
31731: NOT
31732: IFFALSE 31736
// exit ;
31734: GO 32338
// if GetBType ( depot ) = b_depot then
31736: LD_VAR 0 1
31740: PPUSH
31741: CALL_OW 266
31745: PUSH
31746: LD_INT 0
31748: EQUAL
31749: IFFALSE 31761
// dist := 28 else
31751: LD_ADDR_VAR 0 14
31755: PUSH
31756: LD_INT 28
31758: ST_TO_ADDR
31759: GO 31769
// dist := 36 ;
31761: LD_ADDR_VAR 0 14
31765: PUSH
31766: LD_INT 36
31768: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
31769: LD_VAR 0 1
31773: PPUSH
31774: LD_VAR 0 3
31778: PPUSH
31779: LD_VAR 0 4
31783: PPUSH
31784: CALL_OW 297
31788: PUSH
31789: LD_VAR 0 14
31793: GREATER
31794: IFFALSE 31798
// exit ;
31796: GO 32338
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
31798: LD_ADDR_VAR 0 12
31802: PUSH
31803: LD_VAR 0 2
31807: PPUSH
31808: LD_VAR 0 3
31812: PPUSH
31813: LD_VAR 0 4
31817: PPUSH
31818: LD_VAR 0 5
31822: PPUSH
31823: LD_VAR 0 1
31827: PPUSH
31828: CALL_OW 248
31832: PPUSH
31833: LD_INT 0
31835: PPUSH
31836: CALL 32343 0 6
31840: ST_TO_ADDR
// if not hexes then
31841: LD_VAR 0 12
31845: NOT
31846: IFFALSE 31850
// exit ;
31848: GO 32338
// hex := GetHexInfo ( x , y ) ;
31850: LD_ADDR_VAR 0 15
31854: PUSH
31855: LD_VAR 0 3
31859: PPUSH
31860: LD_VAR 0 4
31864: PPUSH
31865: CALL_OW 546
31869: ST_TO_ADDR
// if hex [ 1 ] then
31870: LD_VAR 0 15
31874: PUSH
31875: LD_INT 1
31877: ARRAY
31878: IFFALSE 31882
// exit ;
31880: GO 32338
// height := hex [ 2 ] ;
31882: LD_ADDR_VAR 0 13
31886: PUSH
31887: LD_VAR 0 15
31891: PUSH
31892: LD_INT 2
31894: ARRAY
31895: ST_TO_ADDR
// for i = 1 to hexes do
31896: LD_ADDR_VAR 0 7
31900: PUSH
31901: DOUBLE
31902: LD_INT 1
31904: DEC
31905: ST_TO_ADDR
31906: LD_VAR 0 12
31910: PUSH
31911: FOR_TO
31912: IFFALSE 32242
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
31914: LD_VAR 0 12
31918: PUSH
31919: LD_VAR 0 7
31923: ARRAY
31924: PUSH
31925: LD_INT 1
31927: ARRAY
31928: PPUSH
31929: LD_VAR 0 12
31933: PUSH
31934: LD_VAR 0 7
31938: ARRAY
31939: PUSH
31940: LD_INT 2
31942: ARRAY
31943: PPUSH
31944: CALL_OW 488
31948: NOT
31949: PUSH
31950: LD_VAR 0 12
31954: PUSH
31955: LD_VAR 0 7
31959: ARRAY
31960: PUSH
31961: LD_INT 1
31963: ARRAY
31964: PPUSH
31965: LD_VAR 0 12
31969: PUSH
31970: LD_VAR 0 7
31974: ARRAY
31975: PUSH
31976: LD_INT 2
31978: ARRAY
31979: PPUSH
31980: CALL_OW 428
31984: PUSH
31985: LD_INT 0
31987: GREATER
31988: OR
31989: PUSH
31990: LD_VAR 0 12
31994: PUSH
31995: LD_VAR 0 7
31999: ARRAY
32000: PUSH
32001: LD_INT 1
32003: ARRAY
32004: PPUSH
32005: LD_VAR 0 12
32009: PUSH
32010: LD_VAR 0 7
32014: ARRAY
32015: PUSH
32016: LD_INT 2
32018: ARRAY
32019: PPUSH
32020: CALL_OW 351
32024: OR
32025: IFFALSE 32031
// exit ;
32027: POP
32028: POP
32029: GO 32338
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
32031: LD_ADDR_VAR 0 8
32035: PUSH
32036: LD_VAR 0 12
32040: PUSH
32041: LD_VAR 0 7
32045: ARRAY
32046: PUSH
32047: LD_INT 1
32049: ARRAY
32050: PPUSH
32051: LD_VAR 0 12
32055: PUSH
32056: LD_VAR 0 7
32060: ARRAY
32061: PUSH
32062: LD_INT 2
32064: ARRAY
32065: PPUSH
32066: CALL_OW 546
32070: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
32071: LD_VAR 0 8
32075: PUSH
32076: LD_INT 1
32078: ARRAY
32079: PUSH
32080: LD_VAR 0 8
32084: PUSH
32085: LD_INT 2
32087: ARRAY
32088: PUSH
32089: LD_VAR 0 13
32093: PUSH
32094: LD_INT 2
32096: PLUS
32097: GREATER
32098: OR
32099: PUSH
32100: LD_VAR 0 8
32104: PUSH
32105: LD_INT 2
32107: ARRAY
32108: PUSH
32109: LD_VAR 0 13
32113: PUSH
32114: LD_INT 2
32116: MINUS
32117: LESS
32118: OR
32119: PUSH
32120: LD_VAR 0 8
32124: PUSH
32125: LD_INT 3
32127: ARRAY
32128: PUSH
32129: LD_INT 0
32131: PUSH
32132: LD_INT 8
32134: PUSH
32135: LD_INT 9
32137: PUSH
32138: LD_INT 10
32140: PUSH
32141: LD_INT 11
32143: PUSH
32144: LD_INT 12
32146: PUSH
32147: LD_INT 13
32149: PUSH
32150: LD_INT 16
32152: PUSH
32153: LD_INT 17
32155: PUSH
32156: LD_INT 18
32158: PUSH
32159: LD_INT 19
32161: PUSH
32162: LD_INT 20
32164: PUSH
32165: LD_INT 21
32167: PUSH
32168: EMPTY
32169: LIST
32170: LIST
32171: LIST
32172: LIST
32173: LIST
32174: LIST
32175: LIST
32176: LIST
32177: LIST
32178: LIST
32179: LIST
32180: LIST
32181: LIST
32182: IN
32183: NOT
32184: OR
32185: PUSH
32186: LD_VAR 0 8
32190: PUSH
32191: LD_INT 5
32193: ARRAY
32194: NOT
32195: OR
32196: PUSH
32197: LD_VAR 0 8
32201: PUSH
32202: LD_INT 6
32204: ARRAY
32205: PUSH
32206: LD_INT 1
32208: PUSH
32209: LD_INT 2
32211: PUSH
32212: LD_INT 7
32214: PUSH
32215: LD_INT 9
32217: PUSH
32218: LD_INT 10
32220: PUSH
32221: LD_INT 11
32223: PUSH
32224: EMPTY
32225: LIST
32226: LIST
32227: LIST
32228: LIST
32229: LIST
32230: LIST
32231: IN
32232: NOT
32233: OR
32234: IFFALSE 32240
// exit ;
32236: POP
32237: POP
32238: GO 32338
// end ;
32240: GO 31911
32242: POP
32243: POP
// side := GetSide ( depot ) ;
32244: LD_ADDR_VAR 0 9
32248: PUSH
32249: LD_VAR 0 1
32253: PPUSH
32254: CALL_OW 255
32258: ST_TO_ADDR
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
32259: LD_VAR 0 9
32263: PPUSH
32264: LD_VAR 0 3
32268: PPUSH
32269: LD_VAR 0 4
32273: PPUSH
32274: LD_INT 20
32276: PPUSH
32277: CALL 24992 0 4
32281: PUSH
32282: LD_INT 4
32284: ARRAY
32285: IFFALSE 32289
// exit ;
32287: GO 32338
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
32289: LD_VAR 0 2
32293: PUSH
32294: LD_INT 29
32296: PUSH
32297: LD_INT 30
32299: PUSH
32300: EMPTY
32301: LIST
32302: LIST
32303: IN
32304: PUSH
32305: LD_VAR 0 3
32309: PPUSH
32310: LD_VAR 0 4
32314: PPUSH
32315: LD_VAR 0 9
32319: PPUSH
32320: CALL_OW 440
32324: NOT
32325: AND
32326: IFFALSE 32330
// exit ;
32328: GO 32338
// result := true ;
32330: LD_ADDR_VAR 0 6
32334: PUSH
32335: LD_INT 1
32337: ST_TO_ADDR
// end ;
32338: LD_VAR 0 6
32342: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 , fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 , fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ; var fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 , fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ; var fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 , fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ; var fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 , fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ; begin
32343: LD_INT 0
32345: PPUSH
32346: PPUSH
32347: PPUSH
32348: PPUSH
32349: PPUSH
32350: PPUSH
32351: PPUSH
32352: PPUSH
32353: PPUSH
32354: PPUSH
32355: PPUSH
32356: PPUSH
32357: PPUSH
32358: PPUSH
32359: PPUSH
32360: PPUSH
32361: PPUSH
32362: PPUSH
32363: PPUSH
32364: PPUSH
32365: PPUSH
32366: PPUSH
32367: PPUSH
32368: PPUSH
32369: PPUSH
32370: PPUSH
32371: PPUSH
32372: PPUSH
32373: PPUSH
32374: PPUSH
32375: PPUSH
32376: PPUSH
32377: PPUSH
32378: PPUSH
32379: PPUSH
32380: PPUSH
32381: PPUSH
32382: PPUSH
32383: PPUSH
32384: PPUSH
32385: PPUSH
32386: PPUSH
32387: PPUSH
32388: PPUSH
32389: PPUSH
32390: PPUSH
32391: PPUSH
32392: PPUSH
32393: PPUSH
32394: PPUSH
32395: PPUSH
32396: PPUSH
32397: PPUSH
32398: PPUSH
32399: PPUSH
32400: PPUSH
32401: PPUSH
32402: PPUSH
// result = [ ] ;
32403: LD_ADDR_VAR 0 7
32407: PUSH
32408: EMPTY
32409: ST_TO_ADDR
// temp_list = [ ] ;
32410: LD_ADDR_VAR 0 9
32414: PUSH
32415: EMPTY
32416: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
32417: LD_VAR 0 4
32421: PUSH
32422: LD_INT 0
32424: PUSH
32425: LD_INT 1
32427: PUSH
32428: LD_INT 2
32430: PUSH
32431: LD_INT 3
32433: PUSH
32434: LD_INT 4
32436: PUSH
32437: LD_INT 5
32439: PUSH
32440: EMPTY
32441: LIST
32442: LIST
32443: LIST
32444: LIST
32445: LIST
32446: LIST
32447: IN
32448: NOT
32449: PUSH
32450: LD_VAR 0 1
32454: PUSH
32455: LD_INT 0
32457: PUSH
32458: LD_INT 1
32460: PUSH
32461: EMPTY
32462: LIST
32463: LIST
32464: IN
32465: PUSH
32466: LD_VAR 0 5
32470: PUSH
32471: LD_INT 1
32473: PUSH
32474: LD_INT 2
32476: PUSH
32477: LD_INT 3
32479: PUSH
32480: EMPTY
32481: LIST
32482: LIST
32483: LIST
32484: IN
32485: NOT
32486: AND
32487: OR
32488: IFFALSE 32492
// exit ;
32490: GO 50883
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
32492: LD_VAR 0 1
32496: PUSH
32497: LD_INT 6
32499: PUSH
32500: LD_INT 7
32502: PUSH
32503: LD_INT 8
32505: PUSH
32506: LD_INT 13
32508: PUSH
32509: LD_INT 12
32511: PUSH
32512: LD_INT 15
32514: PUSH
32515: LD_INT 11
32517: PUSH
32518: LD_INT 14
32520: PUSH
32521: LD_INT 10
32523: PUSH
32524: EMPTY
32525: LIST
32526: LIST
32527: LIST
32528: LIST
32529: LIST
32530: LIST
32531: LIST
32532: LIST
32533: LIST
32534: IN
32535: IFFALSE 32545
// btype = b_lab ;
32537: LD_ADDR_VAR 0 1
32541: PUSH
32542: LD_INT 6
32544: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
32545: LD_VAR 0 6
32549: PUSH
32550: LD_INT 0
32552: PUSH
32553: LD_INT 1
32555: PUSH
32556: LD_INT 2
32558: PUSH
32559: EMPTY
32560: LIST
32561: LIST
32562: LIST
32563: IN
32564: NOT
32565: PUSH
32566: LD_VAR 0 1
32570: PUSH
32571: LD_INT 0
32573: PUSH
32574: LD_INT 1
32576: PUSH
32577: LD_INT 2
32579: PUSH
32580: LD_INT 3
32582: PUSH
32583: LD_INT 6
32585: PUSH
32586: LD_INT 36
32588: PUSH
32589: LD_INT 4
32591: PUSH
32592: LD_INT 5
32594: PUSH
32595: LD_INT 31
32597: PUSH
32598: LD_INT 32
32600: PUSH
32601: LD_INT 33
32603: PUSH
32604: EMPTY
32605: LIST
32606: LIST
32607: LIST
32608: LIST
32609: LIST
32610: LIST
32611: LIST
32612: LIST
32613: LIST
32614: LIST
32615: LIST
32616: IN
32617: NOT
32618: PUSH
32619: LD_VAR 0 6
32623: PUSH
32624: LD_INT 1
32626: EQUAL
32627: AND
32628: OR
32629: PUSH
32630: LD_VAR 0 1
32634: PUSH
32635: LD_INT 2
32637: PUSH
32638: LD_INT 3
32640: PUSH
32641: EMPTY
32642: LIST
32643: LIST
32644: IN
32645: NOT
32646: PUSH
32647: LD_VAR 0 6
32651: PUSH
32652: LD_INT 2
32654: EQUAL
32655: AND
32656: OR
32657: IFFALSE 32667
// mode = 0 ;
32659: LD_ADDR_VAR 0 6
32663: PUSH
32664: LD_INT 0
32666: ST_TO_ADDR
// case mode of 0 :
32667: LD_VAR 0 6
32671: PUSH
32672: LD_INT 0
32674: DOUBLE
32675: EQUAL
32676: IFTRUE 32680
32678: GO 44133
32680: POP
// begin fDepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
32681: LD_ADDR_VAR 0 11
32685: PUSH
32686: LD_INT 0
32688: PUSH
32689: LD_INT 0
32691: PUSH
32692: EMPTY
32693: LIST
32694: LIST
32695: PUSH
32696: LD_INT 0
32698: PUSH
32699: LD_INT 1
32701: NEG
32702: PUSH
32703: EMPTY
32704: LIST
32705: LIST
32706: PUSH
32707: LD_INT 1
32709: PUSH
32710: LD_INT 0
32712: PUSH
32713: EMPTY
32714: LIST
32715: LIST
32716: PUSH
32717: LD_INT 1
32719: PUSH
32720: LD_INT 1
32722: PUSH
32723: EMPTY
32724: LIST
32725: LIST
32726: PUSH
32727: LD_INT 0
32729: PUSH
32730: LD_INT 1
32732: PUSH
32733: EMPTY
32734: LIST
32735: LIST
32736: PUSH
32737: LD_INT 1
32739: NEG
32740: PUSH
32741: LD_INT 0
32743: PUSH
32744: EMPTY
32745: LIST
32746: LIST
32747: PUSH
32748: LD_INT 1
32750: NEG
32751: PUSH
32752: LD_INT 1
32754: NEG
32755: PUSH
32756: EMPTY
32757: LIST
32758: LIST
32759: PUSH
32760: LD_INT 1
32762: NEG
32763: PUSH
32764: LD_INT 2
32766: NEG
32767: PUSH
32768: EMPTY
32769: LIST
32770: LIST
32771: PUSH
32772: LD_INT 0
32774: PUSH
32775: LD_INT 2
32777: NEG
32778: PUSH
32779: EMPTY
32780: LIST
32781: LIST
32782: PUSH
32783: LD_INT 1
32785: PUSH
32786: LD_INT 1
32788: NEG
32789: PUSH
32790: EMPTY
32791: LIST
32792: LIST
32793: PUSH
32794: LD_INT 1
32796: PUSH
32797: LD_INT 2
32799: PUSH
32800: EMPTY
32801: LIST
32802: LIST
32803: PUSH
32804: LD_INT 0
32806: PUSH
32807: LD_INT 2
32809: PUSH
32810: EMPTY
32811: LIST
32812: LIST
32813: PUSH
32814: LD_INT 1
32816: NEG
32817: PUSH
32818: LD_INT 1
32820: PUSH
32821: EMPTY
32822: LIST
32823: LIST
32824: PUSH
32825: LD_INT 1
32827: PUSH
32828: LD_INT 3
32830: PUSH
32831: EMPTY
32832: LIST
32833: LIST
32834: PUSH
32835: LD_INT 0
32837: PUSH
32838: LD_INT 3
32840: PUSH
32841: EMPTY
32842: LIST
32843: LIST
32844: PUSH
32845: LD_INT 1
32847: NEG
32848: PUSH
32849: LD_INT 2
32851: PUSH
32852: EMPTY
32853: LIST
32854: LIST
32855: PUSH
32856: EMPTY
32857: LIST
32858: LIST
32859: LIST
32860: LIST
32861: LIST
32862: LIST
32863: LIST
32864: LIST
32865: LIST
32866: LIST
32867: LIST
32868: LIST
32869: LIST
32870: LIST
32871: LIST
32872: LIST
32873: ST_TO_ADDR
// fDepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
32874: LD_ADDR_VAR 0 12
32878: PUSH
32879: LD_INT 0
32881: PUSH
32882: LD_INT 0
32884: PUSH
32885: EMPTY
32886: LIST
32887: LIST
32888: PUSH
32889: LD_INT 0
32891: PUSH
32892: LD_INT 1
32894: NEG
32895: PUSH
32896: EMPTY
32897: LIST
32898: LIST
32899: PUSH
32900: LD_INT 1
32902: PUSH
32903: LD_INT 0
32905: PUSH
32906: EMPTY
32907: LIST
32908: LIST
32909: PUSH
32910: LD_INT 1
32912: PUSH
32913: LD_INT 1
32915: PUSH
32916: EMPTY
32917: LIST
32918: LIST
32919: PUSH
32920: LD_INT 0
32922: PUSH
32923: LD_INT 1
32925: PUSH
32926: EMPTY
32927: LIST
32928: LIST
32929: PUSH
32930: LD_INT 1
32932: NEG
32933: PUSH
32934: LD_INT 0
32936: PUSH
32937: EMPTY
32938: LIST
32939: LIST
32940: PUSH
32941: LD_INT 1
32943: NEG
32944: PUSH
32945: LD_INT 1
32947: NEG
32948: PUSH
32949: EMPTY
32950: LIST
32951: LIST
32952: PUSH
32953: LD_INT 1
32955: PUSH
32956: LD_INT 1
32958: NEG
32959: PUSH
32960: EMPTY
32961: LIST
32962: LIST
32963: PUSH
32964: LD_INT 2
32966: PUSH
32967: LD_INT 0
32969: PUSH
32970: EMPTY
32971: LIST
32972: LIST
32973: PUSH
32974: LD_INT 2
32976: PUSH
32977: LD_INT 1
32979: PUSH
32980: EMPTY
32981: LIST
32982: LIST
32983: PUSH
32984: LD_INT 1
32986: NEG
32987: PUSH
32988: LD_INT 1
32990: PUSH
32991: EMPTY
32992: LIST
32993: LIST
32994: PUSH
32995: LD_INT 2
32997: NEG
32998: PUSH
32999: LD_INT 0
33001: PUSH
33002: EMPTY
33003: LIST
33004: LIST
33005: PUSH
33006: LD_INT 2
33008: NEG
33009: PUSH
33010: LD_INT 1
33012: NEG
33013: PUSH
33014: EMPTY
33015: LIST
33016: LIST
33017: PUSH
33018: LD_INT 2
33020: NEG
33021: PUSH
33022: LD_INT 1
33024: PUSH
33025: EMPTY
33026: LIST
33027: LIST
33028: PUSH
33029: LD_INT 3
33031: NEG
33032: PUSH
33033: LD_INT 0
33035: PUSH
33036: EMPTY
33037: LIST
33038: LIST
33039: PUSH
33040: LD_INT 3
33042: NEG
33043: PUSH
33044: LD_INT 1
33046: NEG
33047: PUSH
33048: EMPTY
33049: LIST
33050: LIST
33051: PUSH
33052: EMPTY
33053: LIST
33054: LIST
33055: LIST
33056: LIST
33057: LIST
33058: LIST
33059: LIST
33060: LIST
33061: LIST
33062: LIST
33063: LIST
33064: LIST
33065: LIST
33066: LIST
33067: LIST
33068: LIST
33069: ST_TO_ADDR
// fDepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
33070: LD_ADDR_VAR 0 13
33074: PUSH
33075: LD_INT 0
33077: PUSH
33078: LD_INT 0
33080: PUSH
33081: EMPTY
33082: LIST
33083: LIST
33084: PUSH
33085: LD_INT 0
33087: PUSH
33088: LD_INT 1
33090: NEG
33091: PUSH
33092: EMPTY
33093: LIST
33094: LIST
33095: PUSH
33096: LD_INT 1
33098: PUSH
33099: LD_INT 0
33101: PUSH
33102: EMPTY
33103: LIST
33104: LIST
33105: PUSH
33106: LD_INT 1
33108: PUSH
33109: LD_INT 1
33111: PUSH
33112: EMPTY
33113: LIST
33114: LIST
33115: PUSH
33116: LD_INT 0
33118: PUSH
33119: LD_INT 1
33121: PUSH
33122: EMPTY
33123: LIST
33124: LIST
33125: PUSH
33126: LD_INT 1
33128: NEG
33129: PUSH
33130: LD_INT 0
33132: PUSH
33133: EMPTY
33134: LIST
33135: LIST
33136: PUSH
33137: LD_INT 1
33139: NEG
33140: PUSH
33141: LD_INT 1
33143: NEG
33144: PUSH
33145: EMPTY
33146: LIST
33147: LIST
33148: PUSH
33149: LD_INT 1
33151: NEG
33152: PUSH
33153: LD_INT 2
33155: NEG
33156: PUSH
33157: EMPTY
33158: LIST
33159: LIST
33160: PUSH
33161: LD_INT 2
33163: PUSH
33164: LD_INT 1
33166: PUSH
33167: EMPTY
33168: LIST
33169: LIST
33170: PUSH
33171: LD_INT 2
33173: PUSH
33174: LD_INT 2
33176: PUSH
33177: EMPTY
33178: LIST
33179: LIST
33180: PUSH
33181: LD_INT 1
33183: PUSH
33184: LD_INT 2
33186: PUSH
33187: EMPTY
33188: LIST
33189: LIST
33190: PUSH
33191: LD_INT 2
33193: NEG
33194: PUSH
33195: LD_INT 1
33197: NEG
33198: PUSH
33199: EMPTY
33200: LIST
33201: LIST
33202: PUSH
33203: LD_INT 2
33205: NEG
33206: PUSH
33207: LD_INT 2
33209: NEG
33210: PUSH
33211: EMPTY
33212: LIST
33213: LIST
33214: PUSH
33215: LD_INT 2
33217: NEG
33218: PUSH
33219: LD_INT 3
33221: NEG
33222: PUSH
33223: EMPTY
33224: LIST
33225: LIST
33226: PUSH
33227: LD_INT 3
33229: NEG
33230: PUSH
33231: LD_INT 2
33233: NEG
33234: PUSH
33235: EMPTY
33236: LIST
33237: LIST
33238: PUSH
33239: LD_INT 3
33241: NEG
33242: PUSH
33243: LD_INT 3
33245: NEG
33246: PUSH
33247: EMPTY
33248: LIST
33249: LIST
33250: PUSH
33251: EMPTY
33252: LIST
33253: LIST
33254: LIST
33255: LIST
33256: LIST
33257: LIST
33258: LIST
33259: LIST
33260: LIST
33261: LIST
33262: LIST
33263: LIST
33264: LIST
33265: LIST
33266: LIST
33267: LIST
33268: ST_TO_ADDR
// fDepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
33269: LD_ADDR_VAR 0 14
33273: PUSH
33274: LD_INT 0
33276: PUSH
33277: LD_INT 0
33279: PUSH
33280: EMPTY
33281: LIST
33282: LIST
33283: PUSH
33284: LD_INT 0
33286: PUSH
33287: LD_INT 1
33289: NEG
33290: PUSH
33291: EMPTY
33292: LIST
33293: LIST
33294: PUSH
33295: LD_INT 1
33297: PUSH
33298: LD_INT 0
33300: PUSH
33301: EMPTY
33302: LIST
33303: LIST
33304: PUSH
33305: LD_INT 1
33307: PUSH
33308: LD_INT 1
33310: PUSH
33311: EMPTY
33312: LIST
33313: LIST
33314: PUSH
33315: LD_INT 0
33317: PUSH
33318: LD_INT 1
33320: PUSH
33321: EMPTY
33322: LIST
33323: LIST
33324: PUSH
33325: LD_INT 1
33327: NEG
33328: PUSH
33329: LD_INT 0
33331: PUSH
33332: EMPTY
33333: LIST
33334: LIST
33335: PUSH
33336: LD_INT 1
33338: NEG
33339: PUSH
33340: LD_INT 1
33342: NEG
33343: PUSH
33344: EMPTY
33345: LIST
33346: LIST
33347: PUSH
33348: LD_INT 1
33350: NEG
33351: PUSH
33352: LD_INT 2
33354: NEG
33355: PUSH
33356: EMPTY
33357: LIST
33358: LIST
33359: PUSH
33360: LD_INT 0
33362: PUSH
33363: LD_INT 2
33365: NEG
33366: PUSH
33367: EMPTY
33368: LIST
33369: LIST
33370: PUSH
33371: LD_INT 1
33373: PUSH
33374: LD_INT 1
33376: NEG
33377: PUSH
33378: EMPTY
33379: LIST
33380: LIST
33381: PUSH
33382: LD_INT 1
33384: PUSH
33385: LD_INT 2
33387: PUSH
33388: EMPTY
33389: LIST
33390: LIST
33391: PUSH
33392: LD_INT 0
33394: PUSH
33395: LD_INT 2
33397: PUSH
33398: EMPTY
33399: LIST
33400: LIST
33401: PUSH
33402: LD_INT 1
33404: NEG
33405: PUSH
33406: LD_INT 1
33408: PUSH
33409: EMPTY
33410: LIST
33411: LIST
33412: PUSH
33413: LD_INT 1
33415: NEG
33416: PUSH
33417: LD_INT 3
33419: NEG
33420: PUSH
33421: EMPTY
33422: LIST
33423: LIST
33424: PUSH
33425: LD_INT 0
33427: PUSH
33428: LD_INT 3
33430: NEG
33431: PUSH
33432: EMPTY
33433: LIST
33434: LIST
33435: PUSH
33436: LD_INT 1
33438: PUSH
33439: LD_INT 2
33441: NEG
33442: PUSH
33443: EMPTY
33444: LIST
33445: LIST
33446: PUSH
33447: EMPTY
33448: LIST
33449: LIST
33450: LIST
33451: LIST
33452: LIST
33453: LIST
33454: LIST
33455: LIST
33456: LIST
33457: LIST
33458: LIST
33459: LIST
33460: LIST
33461: LIST
33462: LIST
33463: LIST
33464: ST_TO_ADDR
// fDepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
33465: LD_ADDR_VAR 0 15
33469: PUSH
33470: LD_INT 0
33472: PUSH
33473: LD_INT 0
33475: PUSH
33476: EMPTY
33477: LIST
33478: LIST
33479: PUSH
33480: LD_INT 0
33482: PUSH
33483: LD_INT 1
33485: NEG
33486: PUSH
33487: EMPTY
33488: LIST
33489: LIST
33490: PUSH
33491: LD_INT 1
33493: PUSH
33494: LD_INT 0
33496: PUSH
33497: EMPTY
33498: LIST
33499: LIST
33500: PUSH
33501: LD_INT 1
33503: PUSH
33504: LD_INT 1
33506: PUSH
33507: EMPTY
33508: LIST
33509: LIST
33510: PUSH
33511: LD_INT 0
33513: PUSH
33514: LD_INT 1
33516: PUSH
33517: EMPTY
33518: LIST
33519: LIST
33520: PUSH
33521: LD_INT 1
33523: NEG
33524: PUSH
33525: LD_INT 0
33527: PUSH
33528: EMPTY
33529: LIST
33530: LIST
33531: PUSH
33532: LD_INT 1
33534: NEG
33535: PUSH
33536: LD_INT 1
33538: NEG
33539: PUSH
33540: EMPTY
33541: LIST
33542: LIST
33543: PUSH
33544: LD_INT 1
33546: PUSH
33547: LD_INT 1
33549: NEG
33550: PUSH
33551: EMPTY
33552: LIST
33553: LIST
33554: PUSH
33555: LD_INT 2
33557: PUSH
33558: LD_INT 0
33560: PUSH
33561: EMPTY
33562: LIST
33563: LIST
33564: PUSH
33565: LD_INT 2
33567: PUSH
33568: LD_INT 1
33570: PUSH
33571: EMPTY
33572: LIST
33573: LIST
33574: PUSH
33575: LD_INT 1
33577: NEG
33578: PUSH
33579: LD_INT 1
33581: PUSH
33582: EMPTY
33583: LIST
33584: LIST
33585: PUSH
33586: LD_INT 2
33588: NEG
33589: PUSH
33590: LD_INT 0
33592: PUSH
33593: EMPTY
33594: LIST
33595: LIST
33596: PUSH
33597: LD_INT 2
33599: NEG
33600: PUSH
33601: LD_INT 1
33603: NEG
33604: PUSH
33605: EMPTY
33606: LIST
33607: LIST
33608: PUSH
33609: LD_INT 2
33611: PUSH
33612: LD_INT 1
33614: NEG
33615: PUSH
33616: EMPTY
33617: LIST
33618: LIST
33619: PUSH
33620: LD_INT 3
33622: PUSH
33623: LD_INT 0
33625: PUSH
33626: EMPTY
33627: LIST
33628: LIST
33629: PUSH
33630: LD_INT 3
33632: PUSH
33633: LD_INT 1
33635: PUSH
33636: EMPTY
33637: LIST
33638: LIST
33639: PUSH
33640: EMPTY
33641: LIST
33642: LIST
33643: LIST
33644: LIST
33645: LIST
33646: LIST
33647: LIST
33648: LIST
33649: LIST
33650: LIST
33651: LIST
33652: LIST
33653: LIST
33654: LIST
33655: LIST
33656: LIST
33657: ST_TO_ADDR
// fDepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
33658: LD_ADDR_VAR 0 16
33662: PUSH
33663: LD_INT 0
33665: PUSH
33666: LD_INT 0
33668: PUSH
33669: EMPTY
33670: LIST
33671: LIST
33672: PUSH
33673: LD_INT 0
33675: PUSH
33676: LD_INT 1
33678: NEG
33679: PUSH
33680: EMPTY
33681: LIST
33682: LIST
33683: PUSH
33684: LD_INT 1
33686: PUSH
33687: LD_INT 0
33689: PUSH
33690: EMPTY
33691: LIST
33692: LIST
33693: PUSH
33694: LD_INT 1
33696: PUSH
33697: LD_INT 1
33699: PUSH
33700: EMPTY
33701: LIST
33702: LIST
33703: PUSH
33704: LD_INT 0
33706: PUSH
33707: LD_INT 1
33709: PUSH
33710: EMPTY
33711: LIST
33712: LIST
33713: PUSH
33714: LD_INT 1
33716: NEG
33717: PUSH
33718: LD_INT 0
33720: PUSH
33721: EMPTY
33722: LIST
33723: LIST
33724: PUSH
33725: LD_INT 1
33727: NEG
33728: PUSH
33729: LD_INT 1
33731: NEG
33732: PUSH
33733: EMPTY
33734: LIST
33735: LIST
33736: PUSH
33737: LD_INT 1
33739: NEG
33740: PUSH
33741: LD_INT 2
33743: NEG
33744: PUSH
33745: EMPTY
33746: LIST
33747: LIST
33748: PUSH
33749: LD_INT 2
33751: PUSH
33752: LD_INT 1
33754: PUSH
33755: EMPTY
33756: LIST
33757: LIST
33758: PUSH
33759: LD_INT 2
33761: PUSH
33762: LD_INT 2
33764: PUSH
33765: EMPTY
33766: LIST
33767: LIST
33768: PUSH
33769: LD_INT 1
33771: PUSH
33772: LD_INT 2
33774: PUSH
33775: EMPTY
33776: LIST
33777: LIST
33778: PUSH
33779: LD_INT 2
33781: NEG
33782: PUSH
33783: LD_INT 1
33785: NEG
33786: PUSH
33787: EMPTY
33788: LIST
33789: LIST
33790: PUSH
33791: LD_INT 2
33793: NEG
33794: PUSH
33795: LD_INT 2
33797: NEG
33798: PUSH
33799: EMPTY
33800: LIST
33801: LIST
33802: PUSH
33803: LD_INT 3
33805: PUSH
33806: LD_INT 2
33808: PUSH
33809: EMPTY
33810: LIST
33811: LIST
33812: PUSH
33813: LD_INT 3
33815: PUSH
33816: LD_INT 3
33818: PUSH
33819: EMPTY
33820: LIST
33821: LIST
33822: PUSH
33823: LD_INT 2
33825: PUSH
33826: LD_INT 3
33828: PUSH
33829: EMPTY
33830: LIST
33831: LIST
33832: PUSH
33833: EMPTY
33834: LIST
33835: LIST
33836: LIST
33837: LIST
33838: LIST
33839: LIST
33840: LIST
33841: LIST
33842: LIST
33843: LIST
33844: LIST
33845: LIST
33846: LIST
33847: LIST
33848: LIST
33849: LIST
33850: ST_TO_ADDR
// fDepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
33851: LD_ADDR_VAR 0 17
33855: PUSH
33856: LD_INT 0
33858: PUSH
33859: LD_INT 0
33861: PUSH
33862: EMPTY
33863: LIST
33864: LIST
33865: PUSH
33866: LD_INT 0
33868: PUSH
33869: LD_INT 1
33871: NEG
33872: PUSH
33873: EMPTY
33874: LIST
33875: LIST
33876: PUSH
33877: LD_INT 1
33879: PUSH
33880: LD_INT 0
33882: PUSH
33883: EMPTY
33884: LIST
33885: LIST
33886: PUSH
33887: LD_INT 1
33889: PUSH
33890: LD_INT 1
33892: PUSH
33893: EMPTY
33894: LIST
33895: LIST
33896: PUSH
33897: LD_INT 0
33899: PUSH
33900: LD_INT 1
33902: PUSH
33903: EMPTY
33904: LIST
33905: LIST
33906: PUSH
33907: LD_INT 1
33909: NEG
33910: PUSH
33911: LD_INT 0
33913: PUSH
33914: EMPTY
33915: LIST
33916: LIST
33917: PUSH
33918: LD_INT 1
33920: NEG
33921: PUSH
33922: LD_INT 1
33924: NEG
33925: PUSH
33926: EMPTY
33927: LIST
33928: LIST
33929: PUSH
33930: LD_INT 1
33932: NEG
33933: PUSH
33934: LD_INT 2
33936: NEG
33937: PUSH
33938: EMPTY
33939: LIST
33940: LIST
33941: PUSH
33942: LD_INT 0
33944: PUSH
33945: LD_INT 2
33947: NEG
33948: PUSH
33949: EMPTY
33950: LIST
33951: LIST
33952: PUSH
33953: LD_INT 1
33955: PUSH
33956: LD_INT 1
33958: NEG
33959: PUSH
33960: EMPTY
33961: LIST
33962: LIST
33963: PUSH
33964: LD_INT 2
33966: PUSH
33967: LD_INT 0
33969: PUSH
33970: EMPTY
33971: LIST
33972: LIST
33973: PUSH
33974: LD_INT 2
33976: PUSH
33977: LD_INT 1
33979: PUSH
33980: EMPTY
33981: LIST
33982: LIST
33983: PUSH
33984: LD_INT 2
33986: PUSH
33987: LD_INT 2
33989: PUSH
33990: EMPTY
33991: LIST
33992: LIST
33993: PUSH
33994: LD_INT 1
33996: PUSH
33997: LD_INT 2
33999: PUSH
34000: EMPTY
34001: LIST
34002: LIST
34003: PUSH
34004: LD_INT 0
34006: PUSH
34007: LD_INT 2
34009: PUSH
34010: EMPTY
34011: LIST
34012: LIST
34013: PUSH
34014: LD_INT 1
34016: NEG
34017: PUSH
34018: LD_INT 1
34020: PUSH
34021: EMPTY
34022: LIST
34023: LIST
34024: PUSH
34025: LD_INT 2
34027: NEG
34028: PUSH
34029: LD_INT 0
34031: PUSH
34032: EMPTY
34033: LIST
34034: LIST
34035: PUSH
34036: LD_INT 2
34038: NEG
34039: PUSH
34040: LD_INT 1
34042: NEG
34043: PUSH
34044: EMPTY
34045: LIST
34046: LIST
34047: PUSH
34048: LD_INT 2
34050: NEG
34051: PUSH
34052: LD_INT 2
34054: NEG
34055: PUSH
34056: EMPTY
34057: LIST
34058: LIST
34059: PUSH
34060: EMPTY
34061: LIST
34062: LIST
34063: LIST
34064: LIST
34065: LIST
34066: LIST
34067: LIST
34068: LIST
34069: LIST
34070: LIST
34071: LIST
34072: LIST
34073: LIST
34074: LIST
34075: LIST
34076: LIST
34077: LIST
34078: LIST
34079: LIST
34080: ST_TO_ADDR
// fDepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
34081: LD_ADDR_VAR 0 18
34085: PUSH
34086: LD_INT 0
34088: PUSH
34089: LD_INT 0
34091: PUSH
34092: EMPTY
34093: LIST
34094: LIST
34095: PUSH
34096: LD_INT 0
34098: PUSH
34099: LD_INT 1
34101: NEG
34102: PUSH
34103: EMPTY
34104: LIST
34105: LIST
34106: PUSH
34107: LD_INT 1
34109: PUSH
34110: LD_INT 0
34112: PUSH
34113: EMPTY
34114: LIST
34115: LIST
34116: PUSH
34117: LD_INT 1
34119: PUSH
34120: LD_INT 1
34122: PUSH
34123: EMPTY
34124: LIST
34125: LIST
34126: PUSH
34127: LD_INT 0
34129: PUSH
34130: LD_INT 1
34132: PUSH
34133: EMPTY
34134: LIST
34135: LIST
34136: PUSH
34137: LD_INT 1
34139: NEG
34140: PUSH
34141: LD_INT 0
34143: PUSH
34144: EMPTY
34145: LIST
34146: LIST
34147: PUSH
34148: LD_INT 1
34150: NEG
34151: PUSH
34152: LD_INT 1
34154: NEG
34155: PUSH
34156: EMPTY
34157: LIST
34158: LIST
34159: PUSH
34160: LD_INT 1
34162: NEG
34163: PUSH
34164: LD_INT 2
34166: NEG
34167: PUSH
34168: EMPTY
34169: LIST
34170: LIST
34171: PUSH
34172: LD_INT 0
34174: PUSH
34175: LD_INT 2
34177: NEG
34178: PUSH
34179: EMPTY
34180: LIST
34181: LIST
34182: PUSH
34183: LD_INT 1
34185: PUSH
34186: LD_INT 1
34188: NEG
34189: PUSH
34190: EMPTY
34191: LIST
34192: LIST
34193: PUSH
34194: LD_INT 2
34196: PUSH
34197: LD_INT 0
34199: PUSH
34200: EMPTY
34201: LIST
34202: LIST
34203: PUSH
34204: LD_INT 2
34206: PUSH
34207: LD_INT 1
34209: PUSH
34210: EMPTY
34211: LIST
34212: LIST
34213: PUSH
34214: LD_INT 2
34216: PUSH
34217: LD_INT 2
34219: PUSH
34220: EMPTY
34221: LIST
34222: LIST
34223: PUSH
34224: LD_INT 1
34226: PUSH
34227: LD_INT 2
34229: PUSH
34230: EMPTY
34231: LIST
34232: LIST
34233: PUSH
34234: LD_INT 0
34236: PUSH
34237: LD_INT 2
34239: PUSH
34240: EMPTY
34241: LIST
34242: LIST
34243: PUSH
34244: LD_INT 1
34246: NEG
34247: PUSH
34248: LD_INT 1
34250: PUSH
34251: EMPTY
34252: LIST
34253: LIST
34254: PUSH
34255: LD_INT 2
34257: NEG
34258: PUSH
34259: LD_INT 0
34261: PUSH
34262: EMPTY
34263: LIST
34264: LIST
34265: PUSH
34266: LD_INT 2
34268: NEG
34269: PUSH
34270: LD_INT 1
34272: NEG
34273: PUSH
34274: EMPTY
34275: LIST
34276: LIST
34277: PUSH
34278: LD_INT 2
34280: NEG
34281: PUSH
34282: LD_INT 2
34284: NEG
34285: PUSH
34286: EMPTY
34287: LIST
34288: LIST
34289: PUSH
34290: EMPTY
34291: LIST
34292: LIST
34293: LIST
34294: LIST
34295: LIST
34296: LIST
34297: LIST
34298: LIST
34299: LIST
34300: LIST
34301: LIST
34302: LIST
34303: LIST
34304: LIST
34305: LIST
34306: LIST
34307: LIST
34308: LIST
34309: LIST
34310: ST_TO_ADDR
// fDepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
34311: LD_ADDR_VAR 0 19
34315: PUSH
34316: LD_INT 0
34318: PUSH
34319: LD_INT 0
34321: PUSH
34322: EMPTY
34323: LIST
34324: LIST
34325: PUSH
34326: LD_INT 0
34328: PUSH
34329: LD_INT 1
34331: NEG
34332: PUSH
34333: EMPTY
34334: LIST
34335: LIST
34336: PUSH
34337: LD_INT 1
34339: PUSH
34340: LD_INT 0
34342: PUSH
34343: EMPTY
34344: LIST
34345: LIST
34346: PUSH
34347: LD_INT 1
34349: PUSH
34350: LD_INT 1
34352: PUSH
34353: EMPTY
34354: LIST
34355: LIST
34356: PUSH
34357: LD_INT 0
34359: PUSH
34360: LD_INT 1
34362: PUSH
34363: EMPTY
34364: LIST
34365: LIST
34366: PUSH
34367: LD_INT 1
34369: NEG
34370: PUSH
34371: LD_INT 0
34373: PUSH
34374: EMPTY
34375: LIST
34376: LIST
34377: PUSH
34378: LD_INT 1
34380: NEG
34381: PUSH
34382: LD_INT 1
34384: NEG
34385: PUSH
34386: EMPTY
34387: LIST
34388: LIST
34389: PUSH
34390: LD_INT 1
34392: NEG
34393: PUSH
34394: LD_INT 2
34396: NEG
34397: PUSH
34398: EMPTY
34399: LIST
34400: LIST
34401: PUSH
34402: LD_INT 0
34404: PUSH
34405: LD_INT 2
34407: NEG
34408: PUSH
34409: EMPTY
34410: LIST
34411: LIST
34412: PUSH
34413: LD_INT 1
34415: PUSH
34416: LD_INT 1
34418: NEG
34419: PUSH
34420: EMPTY
34421: LIST
34422: LIST
34423: PUSH
34424: LD_INT 2
34426: PUSH
34427: LD_INT 0
34429: PUSH
34430: EMPTY
34431: LIST
34432: LIST
34433: PUSH
34434: LD_INT 2
34436: PUSH
34437: LD_INT 1
34439: PUSH
34440: EMPTY
34441: LIST
34442: LIST
34443: PUSH
34444: LD_INT 2
34446: PUSH
34447: LD_INT 2
34449: PUSH
34450: EMPTY
34451: LIST
34452: LIST
34453: PUSH
34454: LD_INT 1
34456: PUSH
34457: LD_INT 2
34459: PUSH
34460: EMPTY
34461: LIST
34462: LIST
34463: PUSH
34464: LD_INT 0
34466: PUSH
34467: LD_INT 2
34469: PUSH
34470: EMPTY
34471: LIST
34472: LIST
34473: PUSH
34474: LD_INT 1
34476: NEG
34477: PUSH
34478: LD_INT 1
34480: PUSH
34481: EMPTY
34482: LIST
34483: LIST
34484: PUSH
34485: LD_INT 2
34487: NEG
34488: PUSH
34489: LD_INT 0
34491: PUSH
34492: EMPTY
34493: LIST
34494: LIST
34495: PUSH
34496: LD_INT 2
34498: NEG
34499: PUSH
34500: LD_INT 1
34502: NEG
34503: PUSH
34504: EMPTY
34505: LIST
34506: LIST
34507: PUSH
34508: LD_INT 2
34510: NEG
34511: PUSH
34512: LD_INT 2
34514: NEG
34515: PUSH
34516: EMPTY
34517: LIST
34518: LIST
34519: PUSH
34520: EMPTY
34521: LIST
34522: LIST
34523: LIST
34524: LIST
34525: LIST
34526: LIST
34527: LIST
34528: LIST
34529: LIST
34530: LIST
34531: LIST
34532: LIST
34533: LIST
34534: LIST
34535: LIST
34536: LIST
34537: LIST
34538: LIST
34539: LIST
34540: ST_TO_ADDR
// fDepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
34541: LD_ADDR_VAR 0 20
34545: PUSH
34546: LD_INT 0
34548: PUSH
34549: LD_INT 0
34551: PUSH
34552: EMPTY
34553: LIST
34554: LIST
34555: PUSH
34556: LD_INT 0
34558: PUSH
34559: LD_INT 1
34561: NEG
34562: PUSH
34563: EMPTY
34564: LIST
34565: LIST
34566: PUSH
34567: LD_INT 1
34569: PUSH
34570: LD_INT 0
34572: PUSH
34573: EMPTY
34574: LIST
34575: LIST
34576: PUSH
34577: LD_INT 1
34579: PUSH
34580: LD_INT 1
34582: PUSH
34583: EMPTY
34584: LIST
34585: LIST
34586: PUSH
34587: LD_INT 0
34589: PUSH
34590: LD_INT 1
34592: PUSH
34593: EMPTY
34594: LIST
34595: LIST
34596: PUSH
34597: LD_INT 1
34599: NEG
34600: PUSH
34601: LD_INT 0
34603: PUSH
34604: EMPTY
34605: LIST
34606: LIST
34607: PUSH
34608: LD_INT 1
34610: NEG
34611: PUSH
34612: LD_INT 1
34614: NEG
34615: PUSH
34616: EMPTY
34617: LIST
34618: LIST
34619: PUSH
34620: LD_INT 1
34622: NEG
34623: PUSH
34624: LD_INT 2
34626: NEG
34627: PUSH
34628: EMPTY
34629: LIST
34630: LIST
34631: PUSH
34632: LD_INT 0
34634: PUSH
34635: LD_INT 2
34637: NEG
34638: PUSH
34639: EMPTY
34640: LIST
34641: LIST
34642: PUSH
34643: LD_INT 1
34645: PUSH
34646: LD_INT 1
34648: NEG
34649: PUSH
34650: EMPTY
34651: LIST
34652: LIST
34653: PUSH
34654: LD_INT 2
34656: PUSH
34657: LD_INT 0
34659: PUSH
34660: EMPTY
34661: LIST
34662: LIST
34663: PUSH
34664: LD_INT 2
34666: PUSH
34667: LD_INT 1
34669: PUSH
34670: EMPTY
34671: LIST
34672: LIST
34673: PUSH
34674: LD_INT 2
34676: PUSH
34677: LD_INT 2
34679: PUSH
34680: EMPTY
34681: LIST
34682: LIST
34683: PUSH
34684: LD_INT 1
34686: PUSH
34687: LD_INT 2
34689: PUSH
34690: EMPTY
34691: LIST
34692: LIST
34693: PUSH
34694: LD_INT 0
34696: PUSH
34697: LD_INT 2
34699: PUSH
34700: EMPTY
34701: LIST
34702: LIST
34703: PUSH
34704: LD_INT 1
34706: NEG
34707: PUSH
34708: LD_INT 1
34710: PUSH
34711: EMPTY
34712: LIST
34713: LIST
34714: PUSH
34715: LD_INT 2
34717: NEG
34718: PUSH
34719: LD_INT 0
34721: PUSH
34722: EMPTY
34723: LIST
34724: LIST
34725: PUSH
34726: LD_INT 2
34728: NEG
34729: PUSH
34730: LD_INT 1
34732: NEG
34733: PUSH
34734: EMPTY
34735: LIST
34736: LIST
34737: PUSH
34738: LD_INT 2
34740: NEG
34741: PUSH
34742: LD_INT 2
34744: NEG
34745: PUSH
34746: EMPTY
34747: LIST
34748: LIST
34749: PUSH
34750: EMPTY
34751: LIST
34752: LIST
34753: LIST
34754: LIST
34755: LIST
34756: LIST
34757: LIST
34758: LIST
34759: LIST
34760: LIST
34761: LIST
34762: LIST
34763: LIST
34764: LIST
34765: LIST
34766: LIST
34767: LIST
34768: LIST
34769: LIST
34770: ST_TO_ADDR
// fDepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
34771: LD_ADDR_VAR 0 21
34775: PUSH
34776: LD_INT 0
34778: PUSH
34779: LD_INT 0
34781: PUSH
34782: EMPTY
34783: LIST
34784: LIST
34785: PUSH
34786: LD_INT 0
34788: PUSH
34789: LD_INT 1
34791: NEG
34792: PUSH
34793: EMPTY
34794: LIST
34795: LIST
34796: PUSH
34797: LD_INT 1
34799: PUSH
34800: LD_INT 0
34802: PUSH
34803: EMPTY
34804: LIST
34805: LIST
34806: PUSH
34807: LD_INT 1
34809: PUSH
34810: LD_INT 1
34812: PUSH
34813: EMPTY
34814: LIST
34815: LIST
34816: PUSH
34817: LD_INT 0
34819: PUSH
34820: LD_INT 1
34822: PUSH
34823: EMPTY
34824: LIST
34825: LIST
34826: PUSH
34827: LD_INT 1
34829: NEG
34830: PUSH
34831: LD_INT 0
34833: PUSH
34834: EMPTY
34835: LIST
34836: LIST
34837: PUSH
34838: LD_INT 1
34840: NEG
34841: PUSH
34842: LD_INT 1
34844: NEG
34845: PUSH
34846: EMPTY
34847: LIST
34848: LIST
34849: PUSH
34850: LD_INT 1
34852: NEG
34853: PUSH
34854: LD_INT 2
34856: NEG
34857: PUSH
34858: EMPTY
34859: LIST
34860: LIST
34861: PUSH
34862: LD_INT 0
34864: PUSH
34865: LD_INT 2
34867: NEG
34868: PUSH
34869: EMPTY
34870: LIST
34871: LIST
34872: PUSH
34873: LD_INT 1
34875: PUSH
34876: LD_INT 1
34878: NEG
34879: PUSH
34880: EMPTY
34881: LIST
34882: LIST
34883: PUSH
34884: LD_INT 2
34886: PUSH
34887: LD_INT 0
34889: PUSH
34890: EMPTY
34891: LIST
34892: LIST
34893: PUSH
34894: LD_INT 2
34896: PUSH
34897: LD_INT 1
34899: PUSH
34900: EMPTY
34901: LIST
34902: LIST
34903: PUSH
34904: LD_INT 2
34906: PUSH
34907: LD_INT 2
34909: PUSH
34910: EMPTY
34911: LIST
34912: LIST
34913: PUSH
34914: LD_INT 1
34916: PUSH
34917: LD_INT 2
34919: PUSH
34920: EMPTY
34921: LIST
34922: LIST
34923: PUSH
34924: LD_INT 0
34926: PUSH
34927: LD_INT 2
34929: PUSH
34930: EMPTY
34931: LIST
34932: LIST
34933: PUSH
34934: LD_INT 1
34936: NEG
34937: PUSH
34938: LD_INT 1
34940: PUSH
34941: EMPTY
34942: LIST
34943: LIST
34944: PUSH
34945: LD_INT 2
34947: NEG
34948: PUSH
34949: LD_INT 0
34951: PUSH
34952: EMPTY
34953: LIST
34954: LIST
34955: PUSH
34956: LD_INT 2
34958: NEG
34959: PUSH
34960: LD_INT 1
34962: NEG
34963: PUSH
34964: EMPTY
34965: LIST
34966: LIST
34967: PUSH
34968: LD_INT 2
34970: NEG
34971: PUSH
34972: LD_INT 2
34974: NEG
34975: PUSH
34976: EMPTY
34977: LIST
34978: LIST
34979: PUSH
34980: EMPTY
34981: LIST
34982: LIST
34983: LIST
34984: LIST
34985: LIST
34986: LIST
34987: LIST
34988: LIST
34989: LIST
34990: LIST
34991: LIST
34992: LIST
34993: LIST
34994: LIST
34995: LIST
34996: LIST
34997: LIST
34998: LIST
34999: LIST
35000: ST_TO_ADDR
// fDepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
35001: LD_ADDR_VAR 0 22
35005: PUSH
35006: LD_INT 0
35008: PUSH
35009: LD_INT 0
35011: PUSH
35012: EMPTY
35013: LIST
35014: LIST
35015: PUSH
35016: LD_INT 0
35018: PUSH
35019: LD_INT 1
35021: NEG
35022: PUSH
35023: EMPTY
35024: LIST
35025: LIST
35026: PUSH
35027: LD_INT 1
35029: PUSH
35030: LD_INT 0
35032: PUSH
35033: EMPTY
35034: LIST
35035: LIST
35036: PUSH
35037: LD_INT 1
35039: PUSH
35040: LD_INT 1
35042: PUSH
35043: EMPTY
35044: LIST
35045: LIST
35046: PUSH
35047: LD_INT 0
35049: PUSH
35050: LD_INT 1
35052: PUSH
35053: EMPTY
35054: LIST
35055: LIST
35056: PUSH
35057: LD_INT 1
35059: NEG
35060: PUSH
35061: LD_INT 0
35063: PUSH
35064: EMPTY
35065: LIST
35066: LIST
35067: PUSH
35068: LD_INT 1
35070: NEG
35071: PUSH
35072: LD_INT 1
35074: NEG
35075: PUSH
35076: EMPTY
35077: LIST
35078: LIST
35079: PUSH
35080: LD_INT 1
35082: NEG
35083: PUSH
35084: LD_INT 2
35086: NEG
35087: PUSH
35088: EMPTY
35089: LIST
35090: LIST
35091: PUSH
35092: LD_INT 0
35094: PUSH
35095: LD_INT 2
35097: NEG
35098: PUSH
35099: EMPTY
35100: LIST
35101: LIST
35102: PUSH
35103: LD_INT 1
35105: PUSH
35106: LD_INT 1
35108: NEG
35109: PUSH
35110: EMPTY
35111: LIST
35112: LIST
35113: PUSH
35114: LD_INT 2
35116: PUSH
35117: LD_INT 0
35119: PUSH
35120: EMPTY
35121: LIST
35122: LIST
35123: PUSH
35124: LD_INT 2
35126: PUSH
35127: LD_INT 1
35129: PUSH
35130: EMPTY
35131: LIST
35132: LIST
35133: PUSH
35134: LD_INT 2
35136: PUSH
35137: LD_INT 2
35139: PUSH
35140: EMPTY
35141: LIST
35142: LIST
35143: PUSH
35144: LD_INT 1
35146: PUSH
35147: LD_INT 2
35149: PUSH
35150: EMPTY
35151: LIST
35152: LIST
35153: PUSH
35154: LD_INT 0
35156: PUSH
35157: LD_INT 2
35159: PUSH
35160: EMPTY
35161: LIST
35162: LIST
35163: PUSH
35164: LD_INT 1
35166: NEG
35167: PUSH
35168: LD_INT 1
35170: PUSH
35171: EMPTY
35172: LIST
35173: LIST
35174: PUSH
35175: LD_INT 2
35177: NEG
35178: PUSH
35179: LD_INT 0
35181: PUSH
35182: EMPTY
35183: LIST
35184: LIST
35185: PUSH
35186: LD_INT 2
35188: NEG
35189: PUSH
35190: LD_INT 1
35192: NEG
35193: PUSH
35194: EMPTY
35195: LIST
35196: LIST
35197: PUSH
35198: LD_INT 2
35200: NEG
35201: PUSH
35202: LD_INT 2
35204: NEG
35205: PUSH
35206: EMPTY
35207: LIST
35208: LIST
35209: PUSH
35210: EMPTY
35211: LIST
35212: LIST
35213: LIST
35214: LIST
35215: LIST
35216: LIST
35217: LIST
35218: LIST
35219: LIST
35220: LIST
35221: LIST
35222: LIST
35223: LIST
35224: LIST
35225: LIST
35226: LIST
35227: LIST
35228: LIST
35229: LIST
35230: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
35231: LD_ADDR_VAR 0 23
35235: PUSH
35236: LD_INT 0
35238: PUSH
35239: LD_INT 0
35241: PUSH
35242: EMPTY
35243: LIST
35244: LIST
35245: PUSH
35246: LD_INT 0
35248: PUSH
35249: LD_INT 1
35251: NEG
35252: PUSH
35253: EMPTY
35254: LIST
35255: LIST
35256: PUSH
35257: LD_INT 1
35259: PUSH
35260: LD_INT 0
35262: PUSH
35263: EMPTY
35264: LIST
35265: LIST
35266: PUSH
35267: LD_INT 1
35269: PUSH
35270: LD_INT 1
35272: PUSH
35273: EMPTY
35274: LIST
35275: LIST
35276: PUSH
35277: LD_INT 0
35279: PUSH
35280: LD_INT 1
35282: PUSH
35283: EMPTY
35284: LIST
35285: LIST
35286: PUSH
35287: LD_INT 1
35289: NEG
35290: PUSH
35291: LD_INT 0
35293: PUSH
35294: EMPTY
35295: LIST
35296: LIST
35297: PUSH
35298: LD_INT 1
35300: NEG
35301: PUSH
35302: LD_INT 1
35304: NEG
35305: PUSH
35306: EMPTY
35307: LIST
35308: LIST
35309: PUSH
35310: LD_INT 1
35312: NEG
35313: PUSH
35314: LD_INT 2
35316: NEG
35317: PUSH
35318: EMPTY
35319: LIST
35320: LIST
35321: PUSH
35322: LD_INT 0
35324: PUSH
35325: LD_INT 2
35327: NEG
35328: PUSH
35329: EMPTY
35330: LIST
35331: LIST
35332: PUSH
35333: LD_INT 1
35335: PUSH
35336: LD_INT 1
35338: NEG
35339: PUSH
35340: EMPTY
35341: LIST
35342: LIST
35343: PUSH
35344: LD_INT 2
35346: PUSH
35347: LD_INT 0
35349: PUSH
35350: EMPTY
35351: LIST
35352: LIST
35353: PUSH
35354: LD_INT 2
35356: PUSH
35357: LD_INT 1
35359: PUSH
35360: EMPTY
35361: LIST
35362: LIST
35363: PUSH
35364: LD_INT 2
35366: PUSH
35367: LD_INT 2
35369: PUSH
35370: EMPTY
35371: LIST
35372: LIST
35373: PUSH
35374: LD_INT 1
35376: PUSH
35377: LD_INT 2
35379: PUSH
35380: EMPTY
35381: LIST
35382: LIST
35383: PUSH
35384: LD_INT 0
35386: PUSH
35387: LD_INT 2
35389: PUSH
35390: EMPTY
35391: LIST
35392: LIST
35393: PUSH
35394: LD_INT 1
35396: NEG
35397: PUSH
35398: LD_INT 1
35400: PUSH
35401: EMPTY
35402: LIST
35403: LIST
35404: PUSH
35405: LD_INT 2
35407: NEG
35408: PUSH
35409: LD_INT 0
35411: PUSH
35412: EMPTY
35413: LIST
35414: LIST
35415: PUSH
35416: LD_INT 2
35418: NEG
35419: PUSH
35420: LD_INT 1
35422: NEG
35423: PUSH
35424: EMPTY
35425: LIST
35426: LIST
35427: PUSH
35428: LD_INT 2
35430: NEG
35431: PUSH
35432: LD_INT 2
35434: NEG
35435: PUSH
35436: EMPTY
35437: LIST
35438: LIST
35439: PUSH
35440: LD_INT 2
35442: NEG
35443: PUSH
35444: LD_INT 3
35446: NEG
35447: PUSH
35448: EMPTY
35449: LIST
35450: LIST
35451: PUSH
35452: LD_INT 1
35454: NEG
35455: PUSH
35456: LD_INT 3
35458: NEG
35459: PUSH
35460: EMPTY
35461: LIST
35462: LIST
35463: PUSH
35464: LD_INT 1
35466: PUSH
35467: LD_INT 2
35469: NEG
35470: PUSH
35471: EMPTY
35472: LIST
35473: LIST
35474: PUSH
35475: LD_INT 2
35477: PUSH
35478: LD_INT 1
35480: NEG
35481: PUSH
35482: EMPTY
35483: LIST
35484: LIST
35485: PUSH
35486: EMPTY
35487: LIST
35488: LIST
35489: LIST
35490: LIST
35491: LIST
35492: LIST
35493: LIST
35494: LIST
35495: LIST
35496: LIST
35497: LIST
35498: LIST
35499: LIST
35500: LIST
35501: LIST
35502: LIST
35503: LIST
35504: LIST
35505: LIST
35506: LIST
35507: LIST
35508: LIST
35509: LIST
35510: ST_TO_ADDR
// fDepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
35511: LD_ADDR_VAR 0 24
35515: PUSH
35516: LD_INT 0
35518: PUSH
35519: LD_INT 0
35521: PUSH
35522: EMPTY
35523: LIST
35524: LIST
35525: PUSH
35526: LD_INT 0
35528: PUSH
35529: LD_INT 1
35531: NEG
35532: PUSH
35533: EMPTY
35534: LIST
35535: LIST
35536: PUSH
35537: LD_INT 1
35539: PUSH
35540: LD_INT 0
35542: PUSH
35543: EMPTY
35544: LIST
35545: LIST
35546: PUSH
35547: LD_INT 1
35549: PUSH
35550: LD_INT 1
35552: PUSH
35553: EMPTY
35554: LIST
35555: LIST
35556: PUSH
35557: LD_INT 0
35559: PUSH
35560: LD_INT 1
35562: PUSH
35563: EMPTY
35564: LIST
35565: LIST
35566: PUSH
35567: LD_INT 1
35569: NEG
35570: PUSH
35571: LD_INT 0
35573: PUSH
35574: EMPTY
35575: LIST
35576: LIST
35577: PUSH
35578: LD_INT 1
35580: NEG
35581: PUSH
35582: LD_INT 1
35584: NEG
35585: PUSH
35586: EMPTY
35587: LIST
35588: LIST
35589: PUSH
35590: LD_INT 1
35592: NEG
35593: PUSH
35594: LD_INT 2
35596: NEG
35597: PUSH
35598: EMPTY
35599: LIST
35600: LIST
35601: PUSH
35602: LD_INT 0
35604: PUSH
35605: LD_INT 2
35607: NEG
35608: PUSH
35609: EMPTY
35610: LIST
35611: LIST
35612: PUSH
35613: LD_INT 1
35615: PUSH
35616: LD_INT 1
35618: NEG
35619: PUSH
35620: EMPTY
35621: LIST
35622: LIST
35623: PUSH
35624: LD_INT 2
35626: PUSH
35627: LD_INT 0
35629: PUSH
35630: EMPTY
35631: LIST
35632: LIST
35633: PUSH
35634: LD_INT 2
35636: PUSH
35637: LD_INT 1
35639: PUSH
35640: EMPTY
35641: LIST
35642: LIST
35643: PUSH
35644: LD_INT 2
35646: PUSH
35647: LD_INT 2
35649: PUSH
35650: EMPTY
35651: LIST
35652: LIST
35653: PUSH
35654: LD_INT 1
35656: PUSH
35657: LD_INT 2
35659: PUSH
35660: EMPTY
35661: LIST
35662: LIST
35663: PUSH
35664: LD_INT 0
35666: PUSH
35667: LD_INT 2
35669: PUSH
35670: EMPTY
35671: LIST
35672: LIST
35673: PUSH
35674: LD_INT 1
35676: NEG
35677: PUSH
35678: LD_INT 1
35680: PUSH
35681: EMPTY
35682: LIST
35683: LIST
35684: PUSH
35685: LD_INT 2
35687: NEG
35688: PUSH
35689: LD_INT 0
35691: PUSH
35692: EMPTY
35693: LIST
35694: LIST
35695: PUSH
35696: LD_INT 2
35698: NEG
35699: PUSH
35700: LD_INT 1
35702: NEG
35703: PUSH
35704: EMPTY
35705: LIST
35706: LIST
35707: PUSH
35708: LD_INT 2
35710: NEG
35711: PUSH
35712: LD_INT 2
35714: NEG
35715: PUSH
35716: EMPTY
35717: LIST
35718: LIST
35719: PUSH
35720: LD_INT 1
35722: PUSH
35723: LD_INT 2
35725: NEG
35726: PUSH
35727: EMPTY
35728: LIST
35729: LIST
35730: PUSH
35731: LD_INT 2
35733: PUSH
35734: LD_INT 1
35736: NEG
35737: PUSH
35738: EMPTY
35739: LIST
35740: LIST
35741: PUSH
35742: LD_INT 3
35744: PUSH
35745: LD_INT 1
35747: PUSH
35748: EMPTY
35749: LIST
35750: LIST
35751: PUSH
35752: LD_INT 3
35754: PUSH
35755: LD_INT 2
35757: PUSH
35758: EMPTY
35759: LIST
35760: LIST
35761: PUSH
35762: EMPTY
35763: LIST
35764: LIST
35765: LIST
35766: LIST
35767: LIST
35768: LIST
35769: LIST
35770: LIST
35771: LIST
35772: LIST
35773: LIST
35774: LIST
35775: LIST
35776: LIST
35777: LIST
35778: LIST
35779: LIST
35780: LIST
35781: LIST
35782: LIST
35783: LIST
35784: LIST
35785: LIST
35786: ST_TO_ADDR
// fDepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
35787: LD_ADDR_VAR 0 25
35791: PUSH
35792: LD_INT 0
35794: PUSH
35795: LD_INT 0
35797: PUSH
35798: EMPTY
35799: LIST
35800: LIST
35801: PUSH
35802: LD_INT 0
35804: PUSH
35805: LD_INT 1
35807: NEG
35808: PUSH
35809: EMPTY
35810: LIST
35811: LIST
35812: PUSH
35813: LD_INT 1
35815: PUSH
35816: LD_INT 0
35818: PUSH
35819: EMPTY
35820: LIST
35821: LIST
35822: PUSH
35823: LD_INT 1
35825: PUSH
35826: LD_INT 1
35828: PUSH
35829: EMPTY
35830: LIST
35831: LIST
35832: PUSH
35833: LD_INT 0
35835: PUSH
35836: LD_INT 1
35838: PUSH
35839: EMPTY
35840: LIST
35841: LIST
35842: PUSH
35843: LD_INT 1
35845: NEG
35846: PUSH
35847: LD_INT 0
35849: PUSH
35850: EMPTY
35851: LIST
35852: LIST
35853: PUSH
35854: LD_INT 1
35856: NEG
35857: PUSH
35858: LD_INT 1
35860: NEG
35861: PUSH
35862: EMPTY
35863: LIST
35864: LIST
35865: PUSH
35866: LD_INT 1
35868: NEG
35869: PUSH
35870: LD_INT 2
35872: NEG
35873: PUSH
35874: EMPTY
35875: LIST
35876: LIST
35877: PUSH
35878: LD_INT 0
35880: PUSH
35881: LD_INT 2
35883: NEG
35884: PUSH
35885: EMPTY
35886: LIST
35887: LIST
35888: PUSH
35889: LD_INT 1
35891: PUSH
35892: LD_INT 1
35894: NEG
35895: PUSH
35896: EMPTY
35897: LIST
35898: LIST
35899: PUSH
35900: LD_INT 2
35902: PUSH
35903: LD_INT 0
35905: PUSH
35906: EMPTY
35907: LIST
35908: LIST
35909: PUSH
35910: LD_INT 2
35912: PUSH
35913: LD_INT 1
35915: PUSH
35916: EMPTY
35917: LIST
35918: LIST
35919: PUSH
35920: LD_INT 2
35922: PUSH
35923: LD_INT 2
35925: PUSH
35926: EMPTY
35927: LIST
35928: LIST
35929: PUSH
35930: LD_INT 1
35932: PUSH
35933: LD_INT 2
35935: PUSH
35936: EMPTY
35937: LIST
35938: LIST
35939: PUSH
35940: LD_INT 0
35942: PUSH
35943: LD_INT 2
35945: PUSH
35946: EMPTY
35947: LIST
35948: LIST
35949: PUSH
35950: LD_INT 1
35952: NEG
35953: PUSH
35954: LD_INT 1
35956: PUSH
35957: EMPTY
35958: LIST
35959: LIST
35960: PUSH
35961: LD_INT 2
35963: NEG
35964: PUSH
35965: LD_INT 0
35967: PUSH
35968: EMPTY
35969: LIST
35970: LIST
35971: PUSH
35972: LD_INT 2
35974: NEG
35975: PUSH
35976: LD_INT 1
35978: NEG
35979: PUSH
35980: EMPTY
35981: LIST
35982: LIST
35983: PUSH
35984: LD_INT 2
35986: NEG
35987: PUSH
35988: LD_INT 2
35990: NEG
35991: PUSH
35992: EMPTY
35993: LIST
35994: LIST
35995: PUSH
35996: LD_INT 3
35998: PUSH
35999: LD_INT 1
36001: PUSH
36002: EMPTY
36003: LIST
36004: LIST
36005: PUSH
36006: LD_INT 3
36008: PUSH
36009: LD_INT 2
36011: PUSH
36012: EMPTY
36013: LIST
36014: LIST
36015: PUSH
36016: LD_INT 2
36018: PUSH
36019: LD_INT 3
36021: PUSH
36022: EMPTY
36023: LIST
36024: LIST
36025: PUSH
36026: LD_INT 1
36028: PUSH
36029: LD_INT 3
36031: PUSH
36032: EMPTY
36033: LIST
36034: LIST
36035: PUSH
36036: EMPTY
36037: LIST
36038: LIST
36039: LIST
36040: LIST
36041: LIST
36042: LIST
36043: LIST
36044: LIST
36045: LIST
36046: LIST
36047: LIST
36048: LIST
36049: LIST
36050: LIST
36051: LIST
36052: LIST
36053: LIST
36054: LIST
36055: LIST
36056: LIST
36057: LIST
36058: LIST
36059: LIST
36060: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
36061: LD_ADDR_VAR 0 26
36065: PUSH
36066: LD_INT 0
36068: PUSH
36069: LD_INT 0
36071: PUSH
36072: EMPTY
36073: LIST
36074: LIST
36075: PUSH
36076: LD_INT 0
36078: PUSH
36079: LD_INT 1
36081: NEG
36082: PUSH
36083: EMPTY
36084: LIST
36085: LIST
36086: PUSH
36087: LD_INT 1
36089: PUSH
36090: LD_INT 0
36092: PUSH
36093: EMPTY
36094: LIST
36095: LIST
36096: PUSH
36097: LD_INT 1
36099: PUSH
36100: LD_INT 1
36102: PUSH
36103: EMPTY
36104: LIST
36105: LIST
36106: PUSH
36107: LD_INT 0
36109: PUSH
36110: LD_INT 1
36112: PUSH
36113: EMPTY
36114: LIST
36115: LIST
36116: PUSH
36117: LD_INT 1
36119: NEG
36120: PUSH
36121: LD_INT 0
36123: PUSH
36124: EMPTY
36125: LIST
36126: LIST
36127: PUSH
36128: LD_INT 1
36130: NEG
36131: PUSH
36132: LD_INT 1
36134: NEG
36135: PUSH
36136: EMPTY
36137: LIST
36138: LIST
36139: PUSH
36140: LD_INT 1
36142: NEG
36143: PUSH
36144: LD_INT 2
36146: NEG
36147: PUSH
36148: EMPTY
36149: LIST
36150: LIST
36151: PUSH
36152: LD_INT 0
36154: PUSH
36155: LD_INT 2
36157: NEG
36158: PUSH
36159: EMPTY
36160: LIST
36161: LIST
36162: PUSH
36163: LD_INT 1
36165: PUSH
36166: LD_INT 1
36168: NEG
36169: PUSH
36170: EMPTY
36171: LIST
36172: LIST
36173: PUSH
36174: LD_INT 2
36176: PUSH
36177: LD_INT 0
36179: PUSH
36180: EMPTY
36181: LIST
36182: LIST
36183: PUSH
36184: LD_INT 2
36186: PUSH
36187: LD_INT 1
36189: PUSH
36190: EMPTY
36191: LIST
36192: LIST
36193: PUSH
36194: LD_INT 2
36196: PUSH
36197: LD_INT 2
36199: PUSH
36200: EMPTY
36201: LIST
36202: LIST
36203: PUSH
36204: LD_INT 1
36206: PUSH
36207: LD_INT 2
36209: PUSH
36210: EMPTY
36211: LIST
36212: LIST
36213: PUSH
36214: LD_INT 0
36216: PUSH
36217: LD_INT 2
36219: PUSH
36220: EMPTY
36221: LIST
36222: LIST
36223: PUSH
36224: LD_INT 1
36226: NEG
36227: PUSH
36228: LD_INT 1
36230: PUSH
36231: EMPTY
36232: LIST
36233: LIST
36234: PUSH
36235: LD_INT 2
36237: NEG
36238: PUSH
36239: LD_INT 0
36241: PUSH
36242: EMPTY
36243: LIST
36244: LIST
36245: PUSH
36246: LD_INT 2
36248: NEG
36249: PUSH
36250: LD_INT 1
36252: NEG
36253: PUSH
36254: EMPTY
36255: LIST
36256: LIST
36257: PUSH
36258: LD_INT 2
36260: NEG
36261: PUSH
36262: LD_INT 2
36264: NEG
36265: PUSH
36266: EMPTY
36267: LIST
36268: LIST
36269: PUSH
36270: LD_INT 2
36272: PUSH
36273: LD_INT 3
36275: PUSH
36276: EMPTY
36277: LIST
36278: LIST
36279: PUSH
36280: LD_INT 1
36282: PUSH
36283: LD_INT 3
36285: PUSH
36286: EMPTY
36287: LIST
36288: LIST
36289: PUSH
36290: LD_INT 1
36292: NEG
36293: PUSH
36294: LD_INT 2
36296: PUSH
36297: EMPTY
36298: LIST
36299: LIST
36300: PUSH
36301: LD_INT 2
36303: NEG
36304: PUSH
36305: LD_INT 1
36307: PUSH
36308: EMPTY
36309: LIST
36310: LIST
36311: PUSH
36312: EMPTY
36313: LIST
36314: LIST
36315: LIST
36316: LIST
36317: LIST
36318: LIST
36319: LIST
36320: LIST
36321: LIST
36322: LIST
36323: LIST
36324: LIST
36325: LIST
36326: LIST
36327: LIST
36328: LIST
36329: LIST
36330: LIST
36331: LIST
36332: LIST
36333: LIST
36334: LIST
36335: LIST
36336: ST_TO_ADDR
// fDepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
36337: LD_ADDR_VAR 0 27
36341: PUSH
36342: LD_INT 0
36344: PUSH
36345: LD_INT 0
36347: PUSH
36348: EMPTY
36349: LIST
36350: LIST
36351: PUSH
36352: LD_INT 0
36354: PUSH
36355: LD_INT 1
36357: NEG
36358: PUSH
36359: EMPTY
36360: LIST
36361: LIST
36362: PUSH
36363: LD_INT 1
36365: PUSH
36366: LD_INT 0
36368: PUSH
36369: EMPTY
36370: LIST
36371: LIST
36372: PUSH
36373: LD_INT 1
36375: PUSH
36376: LD_INT 1
36378: PUSH
36379: EMPTY
36380: LIST
36381: LIST
36382: PUSH
36383: LD_INT 0
36385: PUSH
36386: LD_INT 1
36388: PUSH
36389: EMPTY
36390: LIST
36391: LIST
36392: PUSH
36393: LD_INT 1
36395: NEG
36396: PUSH
36397: LD_INT 0
36399: PUSH
36400: EMPTY
36401: LIST
36402: LIST
36403: PUSH
36404: LD_INT 1
36406: NEG
36407: PUSH
36408: LD_INT 1
36410: NEG
36411: PUSH
36412: EMPTY
36413: LIST
36414: LIST
36415: PUSH
36416: LD_INT 1
36418: NEG
36419: PUSH
36420: LD_INT 2
36422: NEG
36423: PUSH
36424: EMPTY
36425: LIST
36426: LIST
36427: PUSH
36428: LD_INT 0
36430: PUSH
36431: LD_INT 2
36433: NEG
36434: PUSH
36435: EMPTY
36436: LIST
36437: LIST
36438: PUSH
36439: LD_INT 1
36441: PUSH
36442: LD_INT 1
36444: NEG
36445: PUSH
36446: EMPTY
36447: LIST
36448: LIST
36449: PUSH
36450: LD_INT 2
36452: PUSH
36453: LD_INT 0
36455: PUSH
36456: EMPTY
36457: LIST
36458: LIST
36459: PUSH
36460: LD_INT 2
36462: PUSH
36463: LD_INT 1
36465: PUSH
36466: EMPTY
36467: LIST
36468: LIST
36469: PUSH
36470: LD_INT 2
36472: PUSH
36473: LD_INT 2
36475: PUSH
36476: EMPTY
36477: LIST
36478: LIST
36479: PUSH
36480: LD_INT 1
36482: PUSH
36483: LD_INT 2
36485: PUSH
36486: EMPTY
36487: LIST
36488: LIST
36489: PUSH
36490: LD_INT 0
36492: PUSH
36493: LD_INT 2
36495: PUSH
36496: EMPTY
36497: LIST
36498: LIST
36499: PUSH
36500: LD_INT 1
36502: NEG
36503: PUSH
36504: LD_INT 1
36506: PUSH
36507: EMPTY
36508: LIST
36509: LIST
36510: PUSH
36511: LD_INT 2
36513: NEG
36514: PUSH
36515: LD_INT 0
36517: PUSH
36518: EMPTY
36519: LIST
36520: LIST
36521: PUSH
36522: LD_INT 2
36524: NEG
36525: PUSH
36526: LD_INT 1
36528: NEG
36529: PUSH
36530: EMPTY
36531: LIST
36532: LIST
36533: PUSH
36534: LD_INT 2
36536: NEG
36537: PUSH
36538: LD_INT 2
36540: NEG
36541: PUSH
36542: EMPTY
36543: LIST
36544: LIST
36545: PUSH
36546: LD_INT 1
36548: NEG
36549: PUSH
36550: LD_INT 2
36552: PUSH
36553: EMPTY
36554: LIST
36555: LIST
36556: PUSH
36557: LD_INT 2
36559: NEG
36560: PUSH
36561: LD_INT 1
36563: PUSH
36564: EMPTY
36565: LIST
36566: LIST
36567: PUSH
36568: LD_INT 3
36570: NEG
36571: PUSH
36572: LD_INT 1
36574: NEG
36575: PUSH
36576: EMPTY
36577: LIST
36578: LIST
36579: PUSH
36580: LD_INT 3
36582: NEG
36583: PUSH
36584: LD_INT 2
36586: NEG
36587: PUSH
36588: EMPTY
36589: LIST
36590: LIST
36591: PUSH
36592: EMPTY
36593: LIST
36594: LIST
36595: LIST
36596: LIST
36597: LIST
36598: LIST
36599: LIST
36600: LIST
36601: LIST
36602: LIST
36603: LIST
36604: LIST
36605: LIST
36606: LIST
36607: LIST
36608: LIST
36609: LIST
36610: LIST
36611: LIST
36612: LIST
36613: LIST
36614: LIST
36615: LIST
36616: ST_TO_ADDR
// fDepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
36617: LD_ADDR_VAR 0 28
36621: PUSH
36622: LD_INT 0
36624: PUSH
36625: LD_INT 0
36627: PUSH
36628: EMPTY
36629: LIST
36630: LIST
36631: PUSH
36632: LD_INT 0
36634: PUSH
36635: LD_INT 1
36637: NEG
36638: PUSH
36639: EMPTY
36640: LIST
36641: LIST
36642: PUSH
36643: LD_INT 1
36645: PUSH
36646: LD_INT 0
36648: PUSH
36649: EMPTY
36650: LIST
36651: LIST
36652: PUSH
36653: LD_INT 1
36655: PUSH
36656: LD_INT 1
36658: PUSH
36659: EMPTY
36660: LIST
36661: LIST
36662: PUSH
36663: LD_INT 0
36665: PUSH
36666: LD_INT 1
36668: PUSH
36669: EMPTY
36670: LIST
36671: LIST
36672: PUSH
36673: LD_INT 1
36675: NEG
36676: PUSH
36677: LD_INT 0
36679: PUSH
36680: EMPTY
36681: LIST
36682: LIST
36683: PUSH
36684: LD_INT 1
36686: NEG
36687: PUSH
36688: LD_INT 1
36690: NEG
36691: PUSH
36692: EMPTY
36693: LIST
36694: LIST
36695: PUSH
36696: LD_INT 1
36698: NEG
36699: PUSH
36700: LD_INT 2
36702: NEG
36703: PUSH
36704: EMPTY
36705: LIST
36706: LIST
36707: PUSH
36708: LD_INT 0
36710: PUSH
36711: LD_INT 2
36713: NEG
36714: PUSH
36715: EMPTY
36716: LIST
36717: LIST
36718: PUSH
36719: LD_INT 1
36721: PUSH
36722: LD_INT 1
36724: NEG
36725: PUSH
36726: EMPTY
36727: LIST
36728: LIST
36729: PUSH
36730: LD_INT 2
36732: PUSH
36733: LD_INT 0
36735: PUSH
36736: EMPTY
36737: LIST
36738: LIST
36739: PUSH
36740: LD_INT 2
36742: PUSH
36743: LD_INT 1
36745: PUSH
36746: EMPTY
36747: LIST
36748: LIST
36749: PUSH
36750: LD_INT 2
36752: PUSH
36753: LD_INT 2
36755: PUSH
36756: EMPTY
36757: LIST
36758: LIST
36759: PUSH
36760: LD_INT 1
36762: PUSH
36763: LD_INT 2
36765: PUSH
36766: EMPTY
36767: LIST
36768: LIST
36769: PUSH
36770: LD_INT 0
36772: PUSH
36773: LD_INT 2
36775: PUSH
36776: EMPTY
36777: LIST
36778: LIST
36779: PUSH
36780: LD_INT 1
36782: NEG
36783: PUSH
36784: LD_INT 1
36786: PUSH
36787: EMPTY
36788: LIST
36789: LIST
36790: PUSH
36791: LD_INT 2
36793: NEG
36794: PUSH
36795: LD_INT 0
36797: PUSH
36798: EMPTY
36799: LIST
36800: LIST
36801: PUSH
36802: LD_INT 2
36804: NEG
36805: PUSH
36806: LD_INT 1
36808: NEG
36809: PUSH
36810: EMPTY
36811: LIST
36812: LIST
36813: PUSH
36814: LD_INT 2
36816: NEG
36817: PUSH
36818: LD_INT 2
36820: NEG
36821: PUSH
36822: EMPTY
36823: LIST
36824: LIST
36825: PUSH
36826: LD_INT 2
36828: NEG
36829: PUSH
36830: LD_INT 3
36832: NEG
36833: PUSH
36834: EMPTY
36835: LIST
36836: LIST
36837: PUSH
36838: LD_INT 1
36840: NEG
36841: PUSH
36842: LD_INT 3
36844: NEG
36845: PUSH
36846: EMPTY
36847: LIST
36848: LIST
36849: PUSH
36850: LD_INT 3
36852: NEG
36853: PUSH
36854: LD_INT 1
36856: NEG
36857: PUSH
36858: EMPTY
36859: LIST
36860: LIST
36861: PUSH
36862: LD_INT 3
36864: NEG
36865: PUSH
36866: LD_INT 2
36868: NEG
36869: PUSH
36870: EMPTY
36871: LIST
36872: LIST
36873: PUSH
36874: EMPTY
36875: LIST
36876: LIST
36877: LIST
36878: LIST
36879: LIST
36880: LIST
36881: LIST
36882: LIST
36883: LIST
36884: LIST
36885: LIST
36886: LIST
36887: LIST
36888: LIST
36889: LIST
36890: LIST
36891: LIST
36892: LIST
36893: LIST
36894: LIST
36895: LIST
36896: LIST
36897: LIST
36898: ST_TO_ADDR
// fFactory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
36899: LD_ADDR_VAR 0 29
36903: PUSH
36904: LD_INT 0
36906: PUSH
36907: LD_INT 0
36909: PUSH
36910: EMPTY
36911: LIST
36912: LIST
36913: PUSH
36914: LD_INT 0
36916: PUSH
36917: LD_INT 1
36919: NEG
36920: PUSH
36921: EMPTY
36922: LIST
36923: LIST
36924: PUSH
36925: LD_INT 1
36927: PUSH
36928: LD_INT 0
36930: PUSH
36931: EMPTY
36932: LIST
36933: LIST
36934: PUSH
36935: LD_INT 1
36937: PUSH
36938: LD_INT 1
36940: PUSH
36941: EMPTY
36942: LIST
36943: LIST
36944: PUSH
36945: LD_INT 0
36947: PUSH
36948: LD_INT 1
36950: PUSH
36951: EMPTY
36952: LIST
36953: LIST
36954: PUSH
36955: LD_INT 1
36957: NEG
36958: PUSH
36959: LD_INT 0
36961: PUSH
36962: EMPTY
36963: LIST
36964: LIST
36965: PUSH
36966: LD_INT 1
36968: NEG
36969: PUSH
36970: LD_INT 1
36972: NEG
36973: PUSH
36974: EMPTY
36975: LIST
36976: LIST
36977: PUSH
36978: LD_INT 1
36980: NEG
36981: PUSH
36982: LD_INT 2
36984: NEG
36985: PUSH
36986: EMPTY
36987: LIST
36988: LIST
36989: PUSH
36990: LD_INT 0
36992: PUSH
36993: LD_INT 2
36995: NEG
36996: PUSH
36997: EMPTY
36998: LIST
36999: LIST
37000: PUSH
37001: LD_INT 1
37003: PUSH
37004: LD_INT 1
37006: NEG
37007: PUSH
37008: EMPTY
37009: LIST
37010: LIST
37011: PUSH
37012: LD_INT 2
37014: PUSH
37015: LD_INT 0
37017: PUSH
37018: EMPTY
37019: LIST
37020: LIST
37021: PUSH
37022: LD_INT 2
37024: PUSH
37025: LD_INT 1
37027: PUSH
37028: EMPTY
37029: LIST
37030: LIST
37031: PUSH
37032: LD_INT 1
37034: PUSH
37035: LD_INT 2
37037: PUSH
37038: EMPTY
37039: LIST
37040: LIST
37041: PUSH
37042: LD_INT 0
37044: PUSH
37045: LD_INT 2
37047: PUSH
37048: EMPTY
37049: LIST
37050: LIST
37051: PUSH
37052: LD_INT 1
37054: NEG
37055: PUSH
37056: LD_INT 1
37058: PUSH
37059: EMPTY
37060: LIST
37061: LIST
37062: PUSH
37063: LD_INT 2
37065: NEG
37066: PUSH
37067: LD_INT 1
37069: NEG
37070: PUSH
37071: EMPTY
37072: LIST
37073: LIST
37074: PUSH
37075: LD_INT 2
37077: NEG
37078: PUSH
37079: LD_INT 2
37081: NEG
37082: PUSH
37083: EMPTY
37084: LIST
37085: LIST
37086: PUSH
37087: LD_INT 2
37089: NEG
37090: PUSH
37091: LD_INT 3
37093: NEG
37094: PUSH
37095: EMPTY
37096: LIST
37097: LIST
37098: PUSH
37099: LD_INT 2
37101: PUSH
37102: LD_INT 1
37104: NEG
37105: PUSH
37106: EMPTY
37107: LIST
37108: LIST
37109: PUSH
37110: LD_INT 3
37112: PUSH
37113: LD_INT 1
37115: PUSH
37116: EMPTY
37117: LIST
37118: LIST
37119: PUSH
37120: LD_INT 1
37122: PUSH
37123: LD_INT 3
37125: PUSH
37126: EMPTY
37127: LIST
37128: LIST
37129: PUSH
37130: LD_INT 1
37132: NEG
37133: PUSH
37134: LD_INT 2
37136: PUSH
37137: EMPTY
37138: LIST
37139: LIST
37140: PUSH
37141: LD_INT 3
37143: NEG
37144: PUSH
37145: LD_INT 2
37147: NEG
37148: PUSH
37149: EMPTY
37150: LIST
37151: LIST
37152: PUSH
37153: EMPTY
37154: LIST
37155: LIST
37156: LIST
37157: LIST
37158: LIST
37159: LIST
37160: LIST
37161: LIST
37162: LIST
37163: LIST
37164: LIST
37165: LIST
37166: LIST
37167: LIST
37168: LIST
37169: LIST
37170: LIST
37171: LIST
37172: LIST
37173: LIST
37174: LIST
37175: LIST
37176: LIST
37177: ST_TO_ADDR
// fFactory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
37178: LD_ADDR_VAR 0 30
37182: PUSH
37183: LD_INT 0
37185: PUSH
37186: LD_INT 0
37188: PUSH
37189: EMPTY
37190: LIST
37191: LIST
37192: PUSH
37193: LD_INT 0
37195: PUSH
37196: LD_INT 1
37198: NEG
37199: PUSH
37200: EMPTY
37201: LIST
37202: LIST
37203: PUSH
37204: LD_INT 1
37206: PUSH
37207: LD_INT 0
37209: PUSH
37210: EMPTY
37211: LIST
37212: LIST
37213: PUSH
37214: LD_INT 1
37216: PUSH
37217: LD_INT 1
37219: PUSH
37220: EMPTY
37221: LIST
37222: LIST
37223: PUSH
37224: LD_INT 0
37226: PUSH
37227: LD_INT 1
37229: PUSH
37230: EMPTY
37231: LIST
37232: LIST
37233: PUSH
37234: LD_INT 1
37236: NEG
37237: PUSH
37238: LD_INT 0
37240: PUSH
37241: EMPTY
37242: LIST
37243: LIST
37244: PUSH
37245: LD_INT 1
37247: NEG
37248: PUSH
37249: LD_INT 1
37251: NEG
37252: PUSH
37253: EMPTY
37254: LIST
37255: LIST
37256: PUSH
37257: LD_INT 1
37259: NEG
37260: PUSH
37261: LD_INT 2
37263: NEG
37264: PUSH
37265: EMPTY
37266: LIST
37267: LIST
37268: PUSH
37269: LD_INT 0
37271: PUSH
37272: LD_INT 2
37274: NEG
37275: PUSH
37276: EMPTY
37277: LIST
37278: LIST
37279: PUSH
37280: LD_INT 1
37282: PUSH
37283: LD_INT 1
37285: NEG
37286: PUSH
37287: EMPTY
37288: LIST
37289: LIST
37290: PUSH
37291: LD_INT 2
37293: PUSH
37294: LD_INT 0
37296: PUSH
37297: EMPTY
37298: LIST
37299: LIST
37300: PUSH
37301: LD_INT 2
37303: PUSH
37304: LD_INT 1
37306: PUSH
37307: EMPTY
37308: LIST
37309: LIST
37310: PUSH
37311: LD_INT 2
37313: PUSH
37314: LD_INT 2
37316: PUSH
37317: EMPTY
37318: LIST
37319: LIST
37320: PUSH
37321: LD_INT 1
37323: PUSH
37324: LD_INT 2
37326: PUSH
37327: EMPTY
37328: LIST
37329: LIST
37330: PUSH
37331: LD_INT 1
37333: NEG
37334: PUSH
37335: LD_INT 1
37337: PUSH
37338: EMPTY
37339: LIST
37340: LIST
37341: PUSH
37342: LD_INT 2
37344: NEG
37345: PUSH
37346: LD_INT 0
37348: PUSH
37349: EMPTY
37350: LIST
37351: LIST
37352: PUSH
37353: LD_INT 2
37355: NEG
37356: PUSH
37357: LD_INT 1
37359: NEG
37360: PUSH
37361: EMPTY
37362: LIST
37363: LIST
37364: PUSH
37365: LD_INT 1
37367: NEG
37368: PUSH
37369: LD_INT 3
37371: NEG
37372: PUSH
37373: EMPTY
37374: LIST
37375: LIST
37376: PUSH
37377: LD_INT 1
37379: PUSH
37380: LD_INT 2
37382: NEG
37383: PUSH
37384: EMPTY
37385: LIST
37386: LIST
37387: PUSH
37388: LD_INT 3
37390: PUSH
37391: LD_INT 2
37393: PUSH
37394: EMPTY
37395: LIST
37396: LIST
37397: PUSH
37398: LD_INT 2
37400: PUSH
37401: LD_INT 3
37403: PUSH
37404: EMPTY
37405: LIST
37406: LIST
37407: PUSH
37408: LD_INT 2
37410: NEG
37411: PUSH
37412: LD_INT 1
37414: PUSH
37415: EMPTY
37416: LIST
37417: LIST
37418: PUSH
37419: LD_INT 3
37421: NEG
37422: PUSH
37423: LD_INT 1
37425: NEG
37426: PUSH
37427: EMPTY
37428: LIST
37429: LIST
37430: PUSH
37431: EMPTY
37432: LIST
37433: LIST
37434: LIST
37435: LIST
37436: LIST
37437: LIST
37438: LIST
37439: LIST
37440: LIST
37441: LIST
37442: LIST
37443: LIST
37444: LIST
37445: LIST
37446: LIST
37447: LIST
37448: LIST
37449: LIST
37450: LIST
37451: LIST
37452: LIST
37453: LIST
37454: LIST
37455: ST_TO_ADDR
// fFactory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
37456: LD_ADDR_VAR 0 31
37460: PUSH
37461: LD_INT 0
37463: PUSH
37464: LD_INT 0
37466: PUSH
37467: EMPTY
37468: LIST
37469: LIST
37470: PUSH
37471: LD_INT 0
37473: PUSH
37474: LD_INT 1
37476: NEG
37477: PUSH
37478: EMPTY
37479: LIST
37480: LIST
37481: PUSH
37482: LD_INT 1
37484: PUSH
37485: LD_INT 0
37487: PUSH
37488: EMPTY
37489: LIST
37490: LIST
37491: PUSH
37492: LD_INT 1
37494: PUSH
37495: LD_INT 1
37497: PUSH
37498: EMPTY
37499: LIST
37500: LIST
37501: PUSH
37502: LD_INT 0
37504: PUSH
37505: LD_INT 1
37507: PUSH
37508: EMPTY
37509: LIST
37510: LIST
37511: PUSH
37512: LD_INT 1
37514: NEG
37515: PUSH
37516: LD_INT 0
37518: PUSH
37519: EMPTY
37520: LIST
37521: LIST
37522: PUSH
37523: LD_INT 1
37525: NEG
37526: PUSH
37527: LD_INT 1
37529: NEG
37530: PUSH
37531: EMPTY
37532: LIST
37533: LIST
37534: PUSH
37535: LD_INT 1
37537: NEG
37538: PUSH
37539: LD_INT 2
37541: NEG
37542: PUSH
37543: EMPTY
37544: LIST
37545: LIST
37546: PUSH
37547: LD_INT 1
37549: PUSH
37550: LD_INT 1
37552: NEG
37553: PUSH
37554: EMPTY
37555: LIST
37556: LIST
37557: PUSH
37558: LD_INT 2
37560: PUSH
37561: LD_INT 0
37563: PUSH
37564: EMPTY
37565: LIST
37566: LIST
37567: PUSH
37568: LD_INT 2
37570: PUSH
37571: LD_INT 1
37573: PUSH
37574: EMPTY
37575: LIST
37576: LIST
37577: PUSH
37578: LD_INT 2
37580: PUSH
37581: LD_INT 2
37583: PUSH
37584: EMPTY
37585: LIST
37586: LIST
37587: PUSH
37588: LD_INT 1
37590: PUSH
37591: LD_INT 2
37593: PUSH
37594: EMPTY
37595: LIST
37596: LIST
37597: PUSH
37598: LD_INT 0
37600: PUSH
37601: LD_INT 2
37603: PUSH
37604: EMPTY
37605: LIST
37606: LIST
37607: PUSH
37608: LD_INT 1
37610: NEG
37611: PUSH
37612: LD_INT 1
37614: PUSH
37615: EMPTY
37616: LIST
37617: LIST
37618: PUSH
37619: LD_INT 2
37621: NEG
37622: PUSH
37623: LD_INT 1
37625: NEG
37626: PUSH
37627: EMPTY
37628: LIST
37629: LIST
37630: PUSH
37631: LD_INT 2
37633: NEG
37634: PUSH
37635: LD_INT 2
37637: NEG
37638: PUSH
37639: EMPTY
37640: LIST
37641: LIST
37642: PUSH
37643: LD_INT 2
37645: NEG
37646: PUSH
37647: LD_INT 3
37649: NEG
37650: PUSH
37651: EMPTY
37652: LIST
37653: LIST
37654: PUSH
37655: LD_INT 2
37657: PUSH
37658: LD_INT 1
37660: NEG
37661: PUSH
37662: EMPTY
37663: LIST
37664: LIST
37665: PUSH
37666: LD_INT 3
37668: PUSH
37669: LD_INT 1
37671: PUSH
37672: EMPTY
37673: LIST
37674: LIST
37675: PUSH
37676: LD_INT 1
37678: PUSH
37679: LD_INT 3
37681: PUSH
37682: EMPTY
37683: LIST
37684: LIST
37685: PUSH
37686: LD_INT 1
37688: NEG
37689: PUSH
37690: LD_INT 2
37692: PUSH
37693: EMPTY
37694: LIST
37695: LIST
37696: PUSH
37697: LD_INT 3
37699: NEG
37700: PUSH
37701: LD_INT 2
37703: NEG
37704: PUSH
37705: EMPTY
37706: LIST
37707: LIST
37708: PUSH
37709: EMPTY
37710: LIST
37711: LIST
37712: LIST
37713: LIST
37714: LIST
37715: LIST
37716: LIST
37717: LIST
37718: LIST
37719: LIST
37720: LIST
37721: LIST
37722: LIST
37723: LIST
37724: LIST
37725: LIST
37726: LIST
37727: LIST
37728: LIST
37729: LIST
37730: LIST
37731: LIST
37732: LIST
37733: ST_TO_ADDR
// fFactory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
37734: LD_ADDR_VAR 0 32
37738: PUSH
37739: LD_INT 0
37741: PUSH
37742: LD_INT 0
37744: PUSH
37745: EMPTY
37746: LIST
37747: LIST
37748: PUSH
37749: LD_INT 0
37751: PUSH
37752: LD_INT 1
37754: NEG
37755: PUSH
37756: EMPTY
37757: LIST
37758: LIST
37759: PUSH
37760: LD_INT 1
37762: PUSH
37763: LD_INT 0
37765: PUSH
37766: EMPTY
37767: LIST
37768: LIST
37769: PUSH
37770: LD_INT 1
37772: PUSH
37773: LD_INT 1
37775: PUSH
37776: EMPTY
37777: LIST
37778: LIST
37779: PUSH
37780: LD_INT 0
37782: PUSH
37783: LD_INT 1
37785: PUSH
37786: EMPTY
37787: LIST
37788: LIST
37789: PUSH
37790: LD_INT 1
37792: NEG
37793: PUSH
37794: LD_INT 0
37796: PUSH
37797: EMPTY
37798: LIST
37799: LIST
37800: PUSH
37801: LD_INT 1
37803: NEG
37804: PUSH
37805: LD_INT 1
37807: NEG
37808: PUSH
37809: EMPTY
37810: LIST
37811: LIST
37812: PUSH
37813: LD_INT 1
37815: NEG
37816: PUSH
37817: LD_INT 2
37819: NEG
37820: PUSH
37821: EMPTY
37822: LIST
37823: LIST
37824: PUSH
37825: LD_INT 0
37827: PUSH
37828: LD_INT 2
37830: NEG
37831: PUSH
37832: EMPTY
37833: LIST
37834: LIST
37835: PUSH
37836: LD_INT 1
37838: PUSH
37839: LD_INT 1
37841: NEG
37842: PUSH
37843: EMPTY
37844: LIST
37845: LIST
37846: PUSH
37847: LD_INT 2
37849: PUSH
37850: LD_INT 1
37852: PUSH
37853: EMPTY
37854: LIST
37855: LIST
37856: PUSH
37857: LD_INT 2
37859: PUSH
37860: LD_INT 2
37862: PUSH
37863: EMPTY
37864: LIST
37865: LIST
37866: PUSH
37867: LD_INT 1
37869: PUSH
37870: LD_INT 2
37872: PUSH
37873: EMPTY
37874: LIST
37875: LIST
37876: PUSH
37877: LD_INT 0
37879: PUSH
37880: LD_INT 2
37882: PUSH
37883: EMPTY
37884: LIST
37885: LIST
37886: PUSH
37887: LD_INT 1
37889: NEG
37890: PUSH
37891: LD_INT 1
37893: PUSH
37894: EMPTY
37895: LIST
37896: LIST
37897: PUSH
37898: LD_INT 2
37900: NEG
37901: PUSH
37902: LD_INT 0
37904: PUSH
37905: EMPTY
37906: LIST
37907: LIST
37908: PUSH
37909: LD_INT 2
37911: NEG
37912: PUSH
37913: LD_INT 1
37915: NEG
37916: PUSH
37917: EMPTY
37918: LIST
37919: LIST
37920: PUSH
37921: LD_INT 1
37923: NEG
37924: PUSH
37925: LD_INT 3
37927: NEG
37928: PUSH
37929: EMPTY
37930: LIST
37931: LIST
37932: PUSH
37933: LD_INT 1
37935: PUSH
37936: LD_INT 2
37938: NEG
37939: PUSH
37940: EMPTY
37941: LIST
37942: LIST
37943: PUSH
37944: LD_INT 3
37946: PUSH
37947: LD_INT 2
37949: PUSH
37950: EMPTY
37951: LIST
37952: LIST
37953: PUSH
37954: LD_INT 2
37956: PUSH
37957: LD_INT 3
37959: PUSH
37960: EMPTY
37961: LIST
37962: LIST
37963: PUSH
37964: LD_INT 2
37966: NEG
37967: PUSH
37968: LD_INT 1
37970: PUSH
37971: EMPTY
37972: LIST
37973: LIST
37974: PUSH
37975: LD_INT 3
37977: NEG
37978: PUSH
37979: LD_INT 1
37981: NEG
37982: PUSH
37983: EMPTY
37984: LIST
37985: LIST
37986: PUSH
37987: EMPTY
37988: LIST
37989: LIST
37990: LIST
37991: LIST
37992: LIST
37993: LIST
37994: LIST
37995: LIST
37996: LIST
37997: LIST
37998: LIST
37999: LIST
38000: LIST
38001: LIST
38002: LIST
38003: LIST
38004: LIST
38005: LIST
38006: LIST
38007: LIST
38008: LIST
38009: LIST
38010: LIST
38011: ST_TO_ADDR
// fFactory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
38012: LD_ADDR_VAR 0 33
38016: PUSH
38017: LD_INT 0
38019: PUSH
38020: LD_INT 0
38022: PUSH
38023: EMPTY
38024: LIST
38025: LIST
38026: PUSH
38027: LD_INT 0
38029: PUSH
38030: LD_INT 1
38032: NEG
38033: PUSH
38034: EMPTY
38035: LIST
38036: LIST
38037: PUSH
38038: LD_INT 1
38040: PUSH
38041: LD_INT 0
38043: PUSH
38044: EMPTY
38045: LIST
38046: LIST
38047: PUSH
38048: LD_INT 1
38050: PUSH
38051: LD_INT 1
38053: PUSH
38054: EMPTY
38055: LIST
38056: LIST
38057: PUSH
38058: LD_INT 0
38060: PUSH
38061: LD_INT 1
38063: PUSH
38064: EMPTY
38065: LIST
38066: LIST
38067: PUSH
38068: LD_INT 1
38070: NEG
38071: PUSH
38072: LD_INT 0
38074: PUSH
38075: EMPTY
38076: LIST
38077: LIST
38078: PUSH
38079: LD_INT 1
38081: NEG
38082: PUSH
38083: LD_INT 1
38085: NEG
38086: PUSH
38087: EMPTY
38088: LIST
38089: LIST
38090: PUSH
38091: LD_INT 1
38093: NEG
38094: PUSH
38095: LD_INT 2
38097: NEG
38098: PUSH
38099: EMPTY
38100: LIST
38101: LIST
38102: PUSH
38103: LD_INT 1
38105: PUSH
38106: LD_INT 1
38108: NEG
38109: PUSH
38110: EMPTY
38111: LIST
38112: LIST
38113: PUSH
38114: LD_INT 2
38116: PUSH
38117: LD_INT 0
38119: PUSH
38120: EMPTY
38121: LIST
38122: LIST
38123: PUSH
38124: LD_INT 2
38126: PUSH
38127: LD_INT 1
38129: PUSH
38130: EMPTY
38131: LIST
38132: LIST
38133: PUSH
38134: LD_INT 1
38136: PUSH
38137: LD_INT 2
38139: PUSH
38140: EMPTY
38141: LIST
38142: LIST
38143: PUSH
38144: LD_INT 0
38146: PUSH
38147: LD_INT 2
38149: PUSH
38150: EMPTY
38151: LIST
38152: LIST
38153: PUSH
38154: LD_INT 1
38156: NEG
38157: PUSH
38158: LD_INT 1
38160: PUSH
38161: EMPTY
38162: LIST
38163: LIST
38164: PUSH
38165: LD_INT 2
38167: NEG
38168: PUSH
38169: LD_INT 0
38171: PUSH
38172: EMPTY
38173: LIST
38174: LIST
38175: PUSH
38176: LD_INT 2
38178: NEG
38179: PUSH
38180: LD_INT 1
38182: NEG
38183: PUSH
38184: EMPTY
38185: LIST
38186: LIST
38187: PUSH
38188: LD_INT 2
38190: NEG
38191: PUSH
38192: LD_INT 2
38194: NEG
38195: PUSH
38196: EMPTY
38197: LIST
38198: LIST
38199: PUSH
38200: LD_INT 2
38202: NEG
38203: PUSH
38204: LD_INT 3
38206: NEG
38207: PUSH
38208: EMPTY
38209: LIST
38210: LIST
38211: PUSH
38212: LD_INT 2
38214: PUSH
38215: LD_INT 1
38217: NEG
38218: PUSH
38219: EMPTY
38220: LIST
38221: LIST
38222: PUSH
38223: LD_INT 3
38225: PUSH
38226: LD_INT 1
38228: PUSH
38229: EMPTY
38230: LIST
38231: LIST
38232: PUSH
38233: LD_INT 1
38235: PUSH
38236: LD_INT 3
38238: PUSH
38239: EMPTY
38240: LIST
38241: LIST
38242: PUSH
38243: LD_INT 1
38245: NEG
38246: PUSH
38247: LD_INT 2
38249: PUSH
38250: EMPTY
38251: LIST
38252: LIST
38253: PUSH
38254: LD_INT 3
38256: NEG
38257: PUSH
38258: LD_INT 2
38260: NEG
38261: PUSH
38262: EMPTY
38263: LIST
38264: LIST
38265: PUSH
38266: EMPTY
38267: LIST
38268: LIST
38269: LIST
38270: LIST
38271: LIST
38272: LIST
38273: LIST
38274: LIST
38275: LIST
38276: LIST
38277: LIST
38278: LIST
38279: LIST
38280: LIST
38281: LIST
38282: LIST
38283: LIST
38284: LIST
38285: LIST
38286: LIST
38287: LIST
38288: LIST
38289: LIST
38290: ST_TO_ADDR
// fFactory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
38291: LD_ADDR_VAR 0 34
38295: PUSH
38296: LD_INT 0
38298: PUSH
38299: LD_INT 0
38301: PUSH
38302: EMPTY
38303: LIST
38304: LIST
38305: PUSH
38306: LD_INT 0
38308: PUSH
38309: LD_INT 1
38311: NEG
38312: PUSH
38313: EMPTY
38314: LIST
38315: LIST
38316: PUSH
38317: LD_INT 1
38319: PUSH
38320: LD_INT 0
38322: PUSH
38323: EMPTY
38324: LIST
38325: LIST
38326: PUSH
38327: LD_INT 1
38329: PUSH
38330: LD_INT 1
38332: PUSH
38333: EMPTY
38334: LIST
38335: LIST
38336: PUSH
38337: LD_INT 0
38339: PUSH
38340: LD_INT 1
38342: PUSH
38343: EMPTY
38344: LIST
38345: LIST
38346: PUSH
38347: LD_INT 1
38349: NEG
38350: PUSH
38351: LD_INT 0
38353: PUSH
38354: EMPTY
38355: LIST
38356: LIST
38357: PUSH
38358: LD_INT 1
38360: NEG
38361: PUSH
38362: LD_INT 1
38364: NEG
38365: PUSH
38366: EMPTY
38367: LIST
38368: LIST
38369: PUSH
38370: LD_INT 1
38372: NEG
38373: PUSH
38374: LD_INT 2
38376: NEG
38377: PUSH
38378: EMPTY
38379: LIST
38380: LIST
38381: PUSH
38382: LD_INT 0
38384: PUSH
38385: LD_INT 2
38387: NEG
38388: PUSH
38389: EMPTY
38390: LIST
38391: LIST
38392: PUSH
38393: LD_INT 1
38395: PUSH
38396: LD_INT 1
38398: NEG
38399: PUSH
38400: EMPTY
38401: LIST
38402: LIST
38403: PUSH
38404: LD_INT 2
38406: PUSH
38407: LD_INT 1
38409: PUSH
38410: EMPTY
38411: LIST
38412: LIST
38413: PUSH
38414: LD_INT 2
38416: PUSH
38417: LD_INT 2
38419: PUSH
38420: EMPTY
38421: LIST
38422: LIST
38423: PUSH
38424: LD_INT 1
38426: PUSH
38427: LD_INT 2
38429: PUSH
38430: EMPTY
38431: LIST
38432: LIST
38433: PUSH
38434: LD_INT 1
38436: NEG
38437: PUSH
38438: LD_INT 1
38440: PUSH
38441: EMPTY
38442: LIST
38443: LIST
38444: PUSH
38445: LD_INT 2
38447: NEG
38448: PUSH
38449: LD_INT 0
38451: PUSH
38452: EMPTY
38453: LIST
38454: LIST
38455: PUSH
38456: LD_INT 2
38458: NEG
38459: PUSH
38460: LD_INT 1
38462: NEG
38463: PUSH
38464: EMPTY
38465: LIST
38466: LIST
38467: PUSH
38468: LD_INT 2
38470: NEG
38471: PUSH
38472: LD_INT 2
38474: NEG
38475: PUSH
38476: EMPTY
38477: LIST
38478: LIST
38479: PUSH
38480: LD_INT 1
38482: NEG
38483: PUSH
38484: LD_INT 3
38486: NEG
38487: PUSH
38488: EMPTY
38489: LIST
38490: LIST
38491: PUSH
38492: LD_INT 1
38494: PUSH
38495: LD_INT 2
38497: NEG
38498: PUSH
38499: EMPTY
38500: LIST
38501: LIST
38502: PUSH
38503: LD_INT 3
38505: PUSH
38506: LD_INT 2
38508: PUSH
38509: EMPTY
38510: LIST
38511: LIST
38512: PUSH
38513: LD_INT 2
38515: PUSH
38516: LD_INT 3
38518: PUSH
38519: EMPTY
38520: LIST
38521: LIST
38522: PUSH
38523: LD_INT 2
38525: NEG
38526: PUSH
38527: LD_INT 1
38529: PUSH
38530: EMPTY
38531: LIST
38532: LIST
38533: PUSH
38534: LD_INT 3
38536: NEG
38537: PUSH
38538: LD_INT 1
38540: NEG
38541: PUSH
38542: EMPTY
38543: LIST
38544: LIST
38545: PUSH
38546: EMPTY
38547: LIST
38548: LIST
38549: LIST
38550: LIST
38551: LIST
38552: LIST
38553: LIST
38554: LIST
38555: LIST
38556: LIST
38557: LIST
38558: LIST
38559: LIST
38560: LIST
38561: LIST
38562: LIST
38563: LIST
38564: LIST
38565: LIST
38566: LIST
38567: LIST
38568: LIST
38569: LIST
38570: ST_TO_ADDR
// fExt0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
38571: LD_ADDR_VAR 0 35
38575: PUSH
38576: LD_INT 0
38578: PUSH
38579: LD_INT 0
38581: PUSH
38582: EMPTY
38583: LIST
38584: LIST
38585: PUSH
38586: LD_INT 0
38588: PUSH
38589: LD_INT 1
38591: NEG
38592: PUSH
38593: EMPTY
38594: LIST
38595: LIST
38596: PUSH
38597: LD_INT 1
38599: PUSH
38600: LD_INT 0
38602: PUSH
38603: EMPTY
38604: LIST
38605: LIST
38606: PUSH
38607: LD_INT 1
38609: PUSH
38610: LD_INT 1
38612: PUSH
38613: EMPTY
38614: LIST
38615: LIST
38616: PUSH
38617: LD_INT 0
38619: PUSH
38620: LD_INT 1
38622: PUSH
38623: EMPTY
38624: LIST
38625: LIST
38626: PUSH
38627: LD_INT 1
38629: NEG
38630: PUSH
38631: LD_INT 0
38633: PUSH
38634: EMPTY
38635: LIST
38636: LIST
38637: PUSH
38638: LD_INT 1
38640: NEG
38641: PUSH
38642: LD_INT 1
38644: NEG
38645: PUSH
38646: EMPTY
38647: LIST
38648: LIST
38649: PUSH
38650: LD_INT 2
38652: PUSH
38653: LD_INT 1
38655: PUSH
38656: EMPTY
38657: LIST
38658: LIST
38659: PUSH
38660: LD_INT 2
38662: NEG
38663: PUSH
38664: LD_INT 1
38666: NEG
38667: PUSH
38668: EMPTY
38669: LIST
38670: LIST
38671: PUSH
38672: EMPTY
38673: LIST
38674: LIST
38675: LIST
38676: LIST
38677: LIST
38678: LIST
38679: LIST
38680: LIST
38681: LIST
38682: ST_TO_ADDR
// fExt1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
38683: LD_ADDR_VAR 0 36
38687: PUSH
38688: LD_INT 0
38690: PUSH
38691: LD_INT 0
38693: PUSH
38694: EMPTY
38695: LIST
38696: LIST
38697: PUSH
38698: LD_INT 0
38700: PUSH
38701: LD_INT 1
38703: NEG
38704: PUSH
38705: EMPTY
38706: LIST
38707: LIST
38708: PUSH
38709: LD_INT 1
38711: PUSH
38712: LD_INT 0
38714: PUSH
38715: EMPTY
38716: LIST
38717: LIST
38718: PUSH
38719: LD_INT 1
38721: PUSH
38722: LD_INT 1
38724: PUSH
38725: EMPTY
38726: LIST
38727: LIST
38728: PUSH
38729: LD_INT 0
38731: PUSH
38732: LD_INT 1
38734: PUSH
38735: EMPTY
38736: LIST
38737: LIST
38738: PUSH
38739: LD_INT 1
38741: NEG
38742: PUSH
38743: LD_INT 0
38745: PUSH
38746: EMPTY
38747: LIST
38748: LIST
38749: PUSH
38750: LD_INT 1
38752: NEG
38753: PUSH
38754: LD_INT 1
38756: NEG
38757: PUSH
38758: EMPTY
38759: LIST
38760: LIST
38761: PUSH
38762: LD_INT 1
38764: NEG
38765: PUSH
38766: LD_INT 2
38768: NEG
38769: PUSH
38770: EMPTY
38771: LIST
38772: LIST
38773: PUSH
38774: LD_INT 1
38776: PUSH
38777: LD_INT 2
38779: PUSH
38780: EMPTY
38781: LIST
38782: LIST
38783: PUSH
38784: EMPTY
38785: LIST
38786: LIST
38787: LIST
38788: LIST
38789: LIST
38790: LIST
38791: LIST
38792: LIST
38793: LIST
38794: ST_TO_ADDR
// fExt2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
38795: LD_ADDR_VAR 0 37
38799: PUSH
38800: LD_INT 0
38802: PUSH
38803: LD_INT 0
38805: PUSH
38806: EMPTY
38807: LIST
38808: LIST
38809: PUSH
38810: LD_INT 0
38812: PUSH
38813: LD_INT 1
38815: NEG
38816: PUSH
38817: EMPTY
38818: LIST
38819: LIST
38820: PUSH
38821: LD_INT 1
38823: PUSH
38824: LD_INT 0
38826: PUSH
38827: EMPTY
38828: LIST
38829: LIST
38830: PUSH
38831: LD_INT 1
38833: PUSH
38834: LD_INT 1
38836: PUSH
38837: EMPTY
38838: LIST
38839: LIST
38840: PUSH
38841: LD_INT 0
38843: PUSH
38844: LD_INT 1
38846: PUSH
38847: EMPTY
38848: LIST
38849: LIST
38850: PUSH
38851: LD_INT 1
38853: NEG
38854: PUSH
38855: LD_INT 0
38857: PUSH
38858: EMPTY
38859: LIST
38860: LIST
38861: PUSH
38862: LD_INT 1
38864: NEG
38865: PUSH
38866: LD_INT 1
38868: NEG
38869: PUSH
38870: EMPTY
38871: LIST
38872: LIST
38873: PUSH
38874: LD_INT 1
38876: PUSH
38877: LD_INT 1
38879: NEG
38880: PUSH
38881: EMPTY
38882: LIST
38883: LIST
38884: PUSH
38885: LD_INT 1
38887: NEG
38888: PUSH
38889: LD_INT 1
38891: PUSH
38892: EMPTY
38893: LIST
38894: LIST
38895: PUSH
38896: EMPTY
38897: LIST
38898: LIST
38899: LIST
38900: LIST
38901: LIST
38902: LIST
38903: LIST
38904: LIST
38905: LIST
38906: ST_TO_ADDR
// fExt3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
38907: LD_ADDR_VAR 0 38
38911: PUSH
38912: LD_INT 0
38914: PUSH
38915: LD_INT 0
38917: PUSH
38918: EMPTY
38919: LIST
38920: LIST
38921: PUSH
38922: LD_INT 0
38924: PUSH
38925: LD_INT 1
38927: NEG
38928: PUSH
38929: EMPTY
38930: LIST
38931: LIST
38932: PUSH
38933: LD_INT 1
38935: PUSH
38936: LD_INT 0
38938: PUSH
38939: EMPTY
38940: LIST
38941: LIST
38942: PUSH
38943: LD_INT 1
38945: PUSH
38946: LD_INT 1
38948: PUSH
38949: EMPTY
38950: LIST
38951: LIST
38952: PUSH
38953: LD_INT 0
38955: PUSH
38956: LD_INT 1
38958: PUSH
38959: EMPTY
38960: LIST
38961: LIST
38962: PUSH
38963: LD_INT 1
38965: NEG
38966: PUSH
38967: LD_INT 0
38969: PUSH
38970: EMPTY
38971: LIST
38972: LIST
38973: PUSH
38974: LD_INT 1
38976: NEG
38977: PUSH
38978: LD_INT 1
38980: NEG
38981: PUSH
38982: EMPTY
38983: LIST
38984: LIST
38985: PUSH
38986: LD_INT 2
38988: PUSH
38989: LD_INT 1
38991: PUSH
38992: EMPTY
38993: LIST
38994: LIST
38995: PUSH
38996: LD_INT 2
38998: NEG
38999: PUSH
39000: LD_INT 1
39002: NEG
39003: PUSH
39004: EMPTY
39005: LIST
39006: LIST
39007: PUSH
39008: EMPTY
39009: LIST
39010: LIST
39011: LIST
39012: LIST
39013: LIST
39014: LIST
39015: LIST
39016: LIST
39017: LIST
39018: ST_TO_ADDR
// fExt4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
39019: LD_ADDR_VAR 0 39
39023: PUSH
39024: LD_INT 0
39026: PUSH
39027: LD_INT 0
39029: PUSH
39030: EMPTY
39031: LIST
39032: LIST
39033: PUSH
39034: LD_INT 0
39036: PUSH
39037: LD_INT 1
39039: NEG
39040: PUSH
39041: EMPTY
39042: LIST
39043: LIST
39044: PUSH
39045: LD_INT 1
39047: PUSH
39048: LD_INT 0
39050: PUSH
39051: EMPTY
39052: LIST
39053: LIST
39054: PUSH
39055: LD_INT 1
39057: PUSH
39058: LD_INT 1
39060: PUSH
39061: EMPTY
39062: LIST
39063: LIST
39064: PUSH
39065: LD_INT 0
39067: PUSH
39068: LD_INT 1
39070: PUSH
39071: EMPTY
39072: LIST
39073: LIST
39074: PUSH
39075: LD_INT 1
39077: NEG
39078: PUSH
39079: LD_INT 0
39081: PUSH
39082: EMPTY
39083: LIST
39084: LIST
39085: PUSH
39086: LD_INT 1
39088: NEG
39089: PUSH
39090: LD_INT 1
39092: NEG
39093: PUSH
39094: EMPTY
39095: LIST
39096: LIST
39097: PUSH
39098: LD_INT 1
39100: NEG
39101: PUSH
39102: LD_INT 2
39104: NEG
39105: PUSH
39106: EMPTY
39107: LIST
39108: LIST
39109: PUSH
39110: LD_INT 1
39112: PUSH
39113: LD_INT 2
39115: PUSH
39116: EMPTY
39117: LIST
39118: LIST
39119: PUSH
39120: EMPTY
39121: LIST
39122: LIST
39123: LIST
39124: LIST
39125: LIST
39126: LIST
39127: LIST
39128: LIST
39129: LIST
39130: ST_TO_ADDR
// fExt5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
39131: LD_ADDR_VAR 0 40
39135: PUSH
39136: LD_INT 0
39138: PUSH
39139: LD_INT 0
39141: PUSH
39142: EMPTY
39143: LIST
39144: LIST
39145: PUSH
39146: LD_INT 0
39148: PUSH
39149: LD_INT 1
39151: NEG
39152: PUSH
39153: EMPTY
39154: LIST
39155: LIST
39156: PUSH
39157: LD_INT 1
39159: PUSH
39160: LD_INT 0
39162: PUSH
39163: EMPTY
39164: LIST
39165: LIST
39166: PUSH
39167: LD_INT 1
39169: PUSH
39170: LD_INT 1
39172: PUSH
39173: EMPTY
39174: LIST
39175: LIST
39176: PUSH
39177: LD_INT 0
39179: PUSH
39180: LD_INT 1
39182: PUSH
39183: EMPTY
39184: LIST
39185: LIST
39186: PUSH
39187: LD_INT 1
39189: NEG
39190: PUSH
39191: LD_INT 0
39193: PUSH
39194: EMPTY
39195: LIST
39196: LIST
39197: PUSH
39198: LD_INT 1
39200: NEG
39201: PUSH
39202: LD_INT 1
39204: NEG
39205: PUSH
39206: EMPTY
39207: LIST
39208: LIST
39209: PUSH
39210: LD_INT 1
39212: PUSH
39213: LD_INT 1
39215: NEG
39216: PUSH
39217: EMPTY
39218: LIST
39219: LIST
39220: PUSH
39221: LD_INT 1
39223: NEG
39224: PUSH
39225: LD_INT 1
39227: PUSH
39228: EMPTY
39229: LIST
39230: LIST
39231: PUSH
39232: EMPTY
39233: LIST
39234: LIST
39235: LIST
39236: LIST
39237: LIST
39238: LIST
39239: LIST
39240: LIST
39241: LIST
39242: ST_TO_ADDR
// fLab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
39243: LD_ADDR_VAR 0 41
39247: PUSH
39248: LD_INT 0
39250: PUSH
39251: LD_INT 0
39253: PUSH
39254: EMPTY
39255: LIST
39256: LIST
39257: PUSH
39258: LD_INT 0
39260: PUSH
39261: LD_INT 1
39263: NEG
39264: PUSH
39265: EMPTY
39266: LIST
39267: LIST
39268: PUSH
39269: LD_INT 1
39271: PUSH
39272: LD_INT 0
39274: PUSH
39275: EMPTY
39276: LIST
39277: LIST
39278: PUSH
39279: LD_INT 1
39281: PUSH
39282: LD_INT 1
39284: PUSH
39285: EMPTY
39286: LIST
39287: LIST
39288: PUSH
39289: LD_INT 0
39291: PUSH
39292: LD_INT 1
39294: PUSH
39295: EMPTY
39296: LIST
39297: LIST
39298: PUSH
39299: LD_INT 1
39301: NEG
39302: PUSH
39303: LD_INT 0
39305: PUSH
39306: EMPTY
39307: LIST
39308: LIST
39309: PUSH
39310: LD_INT 1
39312: NEG
39313: PUSH
39314: LD_INT 1
39316: NEG
39317: PUSH
39318: EMPTY
39319: LIST
39320: LIST
39321: PUSH
39322: LD_INT 1
39324: NEG
39325: PUSH
39326: LD_INT 2
39328: NEG
39329: PUSH
39330: EMPTY
39331: LIST
39332: LIST
39333: PUSH
39334: LD_INT 1
39336: PUSH
39337: LD_INT 1
39339: NEG
39340: PUSH
39341: EMPTY
39342: LIST
39343: LIST
39344: PUSH
39345: LD_INT 2
39347: PUSH
39348: LD_INT 0
39350: PUSH
39351: EMPTY
39352: LIST
39353: LIST
39354: PUSH
39355: LD_INT 2
39357: PUSH
39358: LD_INT 1
39360: PUSH
39361: EMPTY
39362: LIST
39363: LIST
39364: PUSH
39365: LD_INT 2
39367: PUSH
39368: LD_INT 2
39370: PUSH
39371: EMPTY
39372: LIST
39373: LIST
39374: PUSH
39375: LD_INT 1
39377: PUSH
39378: LD_INT 2
39380: PUSH
39381: EMPTY
39382: LIST
39383: LIST
39384: PUSH
39385: LD_INT 1
39387: NEG
39388: PUSH
39389: LD_INT 1
39391: PUSH
39392: EMPTY
39393: LIST
39394: LIST
39395: PUSH
39396: LD_INT 2
39398: NEG
39399: PUSH
39400: LD_INT 0
39402: PUSH
39403: EMPTY
39404: LIST
39405: LIST
39406: PUSH
39407: LD_INT 2
39409: NEG
39410: PUSH
39411: LD_INT 1
39413: NEG
39414: PUSH
39415: EMPTY
39416: LIST
39417: LIST
39418: PUSH
39419: LD_INT 2
39421: NEG
39422: PUSH
39423: LD_INT 2
39425: NEG
39426: PUSH
39427: EMPTY
39428: LIST
39429: LIST
39430: PUSH
39431: LD_INT 2
39433: NEG
39434: PUSH
39435: LD_INT 3
39437: NEG
39438: PUSH
39439: EMPTY
39440: LIST
39441: LIST
39442: PUSH
39443: LD_INT 2
39445: PUSH
39446: LD_INT 1
39448: NEG
39449: PUSH
39450: EMPTY
39451: LIST
39452: LIST
39453: PUSH
39454: LD_INT 3
39456: PUSH
39457: LD_INT 0
39459: PUSH
39460: EMPTY
39461: LIST
39462: LIST
39463: PUSH
39464: LD_INT 3
39466: PUSH
39467: LD_INT 1
39469: PUSH
39470: EMPTY
39471: LIST
39472: LIST
39473: PUSH
39474: LD_INT 3
39476: PUSH
39477: LD_INT 2
39479: PUSH
39480: EMPTY
39481: LIST
39482: LIST
39483: PUSH
39484: LD_INT 3
39486: PUSH
39487: LD_INT 3
39489: PUSH
39490: EMPTY
39491: LIST
39492: LIST
39493: PUSH
39494: LD_INT 2
39496: PUSH
39497: LD_INT 3
39499: PUSH
39500: EMPTY
39501: LIST
39502: LIST
39503: PUSH
39504: LD_INT 2
39506: NEG
39507: PUSH
39508: LD_INT 1
39510: PUSH
39511: EMPTY
39512: LIST
39513: LIST
39514: PUSH
39515: LD_INT 3
39517: NEG
39518: PUSH
39519: LD_INT 0
39521: PUSH
39522: EMPTY
39523: LIST
39524: LIST
39525: PUSH
39526: LD_INT 3
39528: NEG
39529: PUSH
39530: LD_INT 1
39532: NEG
39533: PUSH
39534: EMPTY
39535: LIST
39536: LIST
39537: PUSH
39538: LD_INT 3
39540: NEG
39541: PUSH
39542: LD_INT 2
39544: NEG
39545: PUSH
39546: EMPTY
39547: LIST
39548: LIST
39549: PUSH
39550: LD_INT 3
39552: NEG
39553: PUSH
39554: LD_INT 3
39556: NEG
39557: PUSH
39558: EMPTY
39559: LIST
39560: LIST
39561: PUSH
39562: EMPTY
39563: LIST
39564: LIST
39565: LIST
39566: LIST
39567: LIST
39568: LIST
39569: LIST
39570: LIST
39571: LIST
39572: LIST
39573: LIST
39574: LIST
39575: LIST
39576: LIST
39577: LIST
39578: LIST
39579: LIST
39580: LIST
39581: LIST
39582: LIST
39583: LIST
39584: LIST
39585: LIST
39586: LIST
39587: LIST
39588: LIST
39589: LIST
39590: LIST
39591: LIST
39592: ST_TO_ADDR
// fLab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
39593: LD_ADDR_VAR 0 42
39597: PUSH
39598: LD_INT 0
39600: PUSH
39601: LD_INT 0
39603: PUSH
39604: EMPTY
39605: LIST
39606: LIST
39607: PUSH
39608: LD_INT 0
39610: PUSH
39611: LD_INT 1
39613: NEG
39614: PUSH
39615: EMPTY
39616: LIST
39617: LIST
39618: PUSH
39619: LD_INT 1
39621: PUSH
39622: LD_INT 0
39624: PUSH
39625: EMPTY
39626: LIST
39627: LIST
39628: PUSH
39629: LD_INT 1
39631: PUSH
39632: LD_INT 1
39634: PUSH
39635: EMPTY
39636: LIST
39637: LIST
39638: PUSH
39639: LD_INT 0
39641: PUSH
39642: LD_INT 1
39644: PUSH
39645: EMPTY
39646: LIST
39647: LIST
39648: PUSH
39649: LD_INT 1
39651: NEG
39652: PUSH
39653: LD_INT 0
39655: PUSH
39656: EMPTY
39657: LIST
39658: LIST
39659: PUSH
39660: LD_INT 1
39662: NEG
39663: PUSH
39664: LD_INT 1
39666: NEG
39667: PUSH
39668: EMPTY
39669: LIST
39670: LIST
39671: PUSH
39672: LD_INT 1
39674: NEG
39675: PUSH
39676: LD_INT 2
39678: NEG
39679: PUSH
39680: EMPTY
39681: LIST
39682: LIST
39683: PUSH
39684: LD_INT 0
39686: PUSH
39687: LD_INT 2
39689: NEG
39690: PUSH
39691: EMPTY
39692: LIST
39693: LIST
39694: PUSH
39695: LD_INT 1
39697: PUSH
39698: LD_INT 1
39700: NEG
39701: PUSH
39702: EMPTY
39703: LIST
39704: LIST
39705: PUSH
39706: LD_INT 2
39708: PUSH
39709: LD_INT 1
39711: PUSH
39712: EMPTY
39713: LIST
39714: LIST
39715: PUSH
39716: LD_INT 2
39718: PUSH
39719: LD_INT 2
39721: PUSH
39722: EMPTY
39723: LIST
39724: LIST
39725: PUSH
39726: LD_INT 1
39728: PUSH
39729: LD_INT 2
39731: PUSH
39732: EMPTY
39733: LIST
39734: LIST
39735: PUSH
39736: LD_INT 0
39738: PUSH
39739: LD_INT 2
39741: PUSH
39742: EMPTY
39743: LIST
39744: LIST
39745: PUSH
39746: LD_INT 1
39748: NEG
39749: PUSH
39750: LD_INT 1
39752: PUSH
39753: EMPTY
39754: LIST
39755: LIST
39756: PUSH
39757: LD_INT 2
39759: NEG
39760: PUSH
39761: LD_INT 1
39763: NEG
39764: PUSH
39765: EMPTY
39766: LIST
39767: LIST
39768: PUSH
39769: LD_INT 2
39771: NEG
39772: PUSH
39773: LD_INT 2
39775: NEG
39776: PUSH
39777: EMPTY
39778: LIST
39779: LIST
39780: PUSH
39781: LD_INT 2
39783: NEG
39784: PUSH
39785: LD_INT 3
39787: NEG
39788: PUSH
39789: EMPTY
39790: LIST
39791: LIST
39792: PUSH
39793: LD_INT 1
39795: NEG
39796: PUSH
39797: LD_INT 3
39799: NEG
39800: PUSH
39801: EMPTY
39802: LIST
39803: LIST
39804: PUSH
39805: LD_INT 0
39807: PUSH
39808: LD_INT 3
39810: NEG
39811: PUSH
39812: EMPTY
39813: LIST
39814: LIST
39815: PUSH
39816: LD_INT 1
39818: PUSH
39819: LD_INT 2
39821: NEG
39822: PUSH
39823: EMPTY
39824: LIST
39825: LIST
39826: PUSH
39827: LD_INT 3
39829: PUSH
39830: LD_INT 2
39832: PUSH
39833: EMPTY
39834: LIST
39835: LIST
39836: PUSH
39837: LD_INT 3
39839: PUSH
39840: LD_INT 3
39842: PUSH
39843: EMPTY
39844: LIST
39845: LIST
39846: PUSH
39847: LD_INT 2
39849: PUSH
39850: LD_INT 3
39852: PUSH
39853: EMPTY
39854: LIST
39855: LIST
39856: PUSH
39857: LD_INT 1
39859: PUSH
39860: LD_INT 3
39862: PUSH
39863: EMPTY
39864: LIST
39865: LIST
39866: PUSH
39867: LD_INT 0
39869: PUSH
39870: LD_INT 3
39872: PUSH
39873: EMPTY
39874: LIST
39875: LIST
39876: PUSH
39877: LD_INT 1
39879: NEG
39880: PUSH
39881: LD_INT 2
39883: PUSH
39884: EMPTY
39885: LIST
39886: LIST
39887: PUSH
39888: LD_INT 3
39890: NEG
39891: PUSH
39892: LD_INT 2
39894: NEG
39895: PUSH
39896: EMPTY
39897: LIST
39898: LIST
39899: PUSH
39900: LD_INT 3
39902: NEG
39903: PUSH
39904: LD_INT 3
39906: NEG
39907: PUSH
39908: EMPTY
39909: LIST
39910: LIST
39911: PUSH
39912: EMPTY
39913: LIST
39914: LIST
39915: LIST
39916: LIST
39917: LIST
39918: LIST
39919: LIST
39920: LIST
39921: LIST
39922: LIST
39923: LIST
39924: LIST
39925: LIST
39926: LIST
39927: LIST
39928: LIST
39929: LIST
39930: LIST
39931: LIST
39932: LIST
39933: LIST
39934: LIST
39935: LIST
39936: LIST
39937: LIST
39938: LIST
39939: LIST
39940: LIST
39941: LIST
39942: ST_TO_ADDR
// fLab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
39943: LD_ADDR_VAR 0 43
39947: PUSH
39948: LD_INT 0
39950: PUSH
39951: LD_INT 0
39953: PUSH
39954: EMPTY
39955: LIST
39956: LIST
39957: PUSH
39958: LD_INT 0
39960: PUSH
39961: LD_INT 1
39963: NEG
39964: PUSH
39965: EMPTY
39966: LIST
39967: LIST
39968: PUSH
39969: LD_INT 1
39971: PUSH
39972: LD_INT 0
39974: PUSH
39975: EMPTY
39976: LIST
39977: LIST
39978: PUSH
39979: LD_INT 1
39981: PUSH
39982: LD_INT 1
39984: PUSH
39985: EMPTY
39986: LIST
39987: LIST
39988: PUSH
39989: LD_INT 0
39991: PUSH
39992: LD_INT 1
39994: PUSH
39995: EMPTY
39996: LIST
39997: LIST
39998: PUSH
39999: LD_INT 1
40001: NEG
40002: PUSH
40003: LD_INT 0
40005: PUSH
40006: EMPTY
40007: LIST
40008: LIST
40009: PUSH
40010: LD_INT 1
40012: NEG
40013: PUSH
40014: LD_INT 1
40016: NEG
40017: PUSH
40018: EMPTY
40019: LIST
40020: LIST
40021: PUSH
40022: LD_INT 1
40024: NEG
40025: PUSH
40026: LD_INT 2
40028: NEG
40029: PUSH
40030: EMPTY
40031: LIST
40032: LIST
40033: PUSH
40034: LD_INT 0
40036: PUSH
40037: LD_INT 2
40039: NEG
40040: PUSH
40041: EMPTY
40042: LIST
40043: LIST
40044: PUSH
40045: LD_INT 1
40047: PUSH
40048: LD_INT 1
40050: NEG
40051: PUSH
40052: EMPTY
40053: LIST
40054: LIST
40055: PUSH
40056: LD_INT 2
40058: PUSH
40059: LD_INT 0
40061: PUSH
40062: EMPTY
40063: LIST
40064: LIST
40065: PUSH
40066: LD_INT 2
40068: PUSH
40069: LD_INT 1
40071: PUSH
40072: EMPTY
40073: LIST
40074: LIST
40075: PUSH
40076: LD_INT 1
40078: PUSH
40079: LD_INT 2
40081: PUSH
40082: EMPTY
40083: LIST
40084: LIST
40085: PUSH
40086: LD_INT 0
40088: PUSH
40089: LD_INT 2
40091: PUSH
40092: EMPTY
40093: LIST
40094: LIST
40095: PUSH
40096: LD_INT 1
40098: NEG
40099: PUSH
40100: LD_INT 1
40102: PUSH
40103: EMPTY
40104: LIST
40105: LIST
40106: PUSH
40107: LD_INT 2
40109: NEG
40110: PUSH
40111: LD_INT 0
40113: PUSH
40114: EMPTY
40115: LIST
40116: LIST
40117: PUSH
40118: LD_INT 2
40120: NEG
40121: PUSH
40122: LD_INT 1
40124: NEG
40125: PUSH
40126: EMPTY
40127: LIST
40128: LIST
40129: PUSH
40130: LD_INT 1
40132: NEG
40133: PUSH
40134: LD_INT 3
40136: NEG
40137: PUSH
40138: EMPTY
40139: LIST
40140: LIST
40141: PUSH
40142: LD_INT 0
40144: PUSH
40145: LD_INT 3
40147: NEG
40148: PUSH
40149: EMPTY
40150: LIST
40151: LIST
40152: PUSH
40153: LD_INT 1
40155: PUSH
40156: LD_INT 2
40158: NEG
40159: PUSH
40160: EMPTY
40161: LIST
40162: LIST
40163: PUSH
40164: LD_INT 2
40166: PUSH
40167: LD_INT 1
40169: NEG
40170: PUSH
40171: EMPTY
40172: LIST
40173: LIST
40174: PUSH
40175: LD_INT 3
40177: PUSH
40178: LD_INT 0
40180: PUSH
40181: EMPTY
40182: LIST
40183: LIST
40184: PUSH
40185: LD_INT 3
40187: PUSH
40188: LD_INT 1
40190: PUSH
40191: EMPTY
40192: LIST
40193: LIST
40194: PUSH
40195: LD_INT 1
40197: PUSH
40198: LD_INT 3
40200: PUSH
40201: EMPTY
40202: LIST
40203: LIST
40204: PUSH
40205: LD_INT 0
40207: PUSH
40208: LD_INT 3
40210: PUSH
40211: EMPTY
40212: LIST
40213: LIST
40214: PUSH
40215: LD_INT 1
40217: NEG
40218: PUSH
40219: LD_INT 2
40221: PUSH
40222: EMPTY
40223: LIST
40224: LIST
40225: PUSH
40226: LD_INT 2
40228: NEG
40229: PUSH
40230: LD_INT 1
40232: PUSH
40233: EMPTY
40234: LIST
40235: LIST
40236: PUSH
40237: LD_INT 3
40239: NEG
40240: PUSH
40241: LD_INT 0
40243: PUSH
40244: EMPTY
40245: LIST
40246: LIST
40247: PUSH
40248: LD_INT 3
40250: NEG
40251: PUSH
40252: LD_INT 1
40254: NEG
40255: PUSH
40256: EMPTY
40257: LIST
40258: LIST
40259: PUSH
40260: EMPTY
40261: LIST
40262: LIST
40263: LIST
40264: LIST
40265: LIST
40266: LIST
40267: LIST
40268: LIST
40269: LIST
40270: LIST
40271: LIST
40272: LIST
40273: LIST
40274: LIST
40275: LIST
40276: LIST
40277: LIST
40278: LIST
40279: LIST
40280: LIST
40281: LIST
40282: LIST
40283: LIST
40284: LIST
40285: LIST
40286: LIST
40287: LIST
40288: LIST
40289: LIST
40290: ST_TO_ADDR
// fLab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
40291: LD_ADDR_VAR 0 44
40295: PUSH
40296: LD_INT 0
40298: PUSH
40299: LD_INT 0
40301: PUSH
40302: EMPTY
40303: LIST
40304: LIST
40305: PUSH
40306: LD_INT 0
40308: PUSH
40309: LD_INT 1
40311: NEG
40312: PUSH
40313: EMPTY
40314: LIST
40315: LIST
40316: PUSH
40317: LD_INT 1
40319: PUSH
40320: LD_INT 0
40322: PUSH
40323: EMPTY
40324: LIST
40325: LIST
40326: PUSH
40327: LD_INT 1
40329: PUSH
40330: LD_INT 1
40332: PUSH
40333: EMPTY
40334: LIST
40335: LIST
40336: PUSH
40337: LD_INT 0
40339: PUSH
40340: LD_INT 1
40342: PUSH
40343: EMPTY
40344: LIST
40345: LIST
40346: PUSH
40347: LD_INT 1
40349: NEG
40350: PUSH
40351: LD_INT 0
40353: PUSH
40354: EMPTY
40355: LIST
40356: LIST
40357: PUSH
40358: LD_INT 1
40360: NEG
40361: PUSH
40362: LD_INT 1
40364: NEG
40365: PUSH
40366: EMPTY
40367: LIST
40368: LIST
40369: PUSH
40370: LD_INT 1
40372: NEG
40373: PUSH
40374: LD_INT 2
40376: NEG
40377: PUSH
40378: EMPTY
40379: LIST
40380: LIST
40381: PUSH
40382: LD_INT 1
40384: PUSH
40385: LD_INT 1
40387: NEG
40388: PUSH
40389: EMPTY
40390: LIST
40391: LIST
40392: PUSH
40393: LD_INT 2
40395: PUSH
40396: LD_INT 0
40398: PUSH
40399: EMPTY
40400: LIST
40401: LIST
40402: PUSH
40403: LD_INT 2
40405: PUSH
40406: LD_INT 1
40408: PUSH
40409: EMPTY
40410: LIST
40411: LIST
40412: PUSH
40413: LD_INT 2
40415: PUSH
40416: LD_INT 2
40418: PUSH
40419: EMPTY
40420: LIST
40421: LIST
40422: PUSH
40423: LD_INT 1
40425: PUSH
40426: LD_INT 2
40428: PUSH
40429: EMPTY
40430: LIST
40431: LIST
40432: PUSH
40433: LD_INT 1
40435: NEG
40436: PUSH
40437: LD_INT 1
40439: PUSH
40440: EMPTY
40441: LIST
40442: LIST
40443: PUSH
40444: LD_INT 2
40446: NEG
40447: PUSH
40448: LD_INT 0
40450: PUSH
40451: EMPTY
40452: LIST
40453: LIST
40454: PUSH
40455: LD_INT 2
40457: NEG
40458: PUSH
40459: LD_INT 1
40461: NEG
40462: PUSH
40463: EMPTY
40464: LIST
40465: LIST
40466: PUSH
40467: LD_INT 2
40469: NEG
40470: PUSH
40471: LD_INT 2
40473: NEG
40474: PUSH
40475: EMPTY
40476: LIST
40477: LIST
40478: PUSH
40479: LD_INT 2
40481: NEG
40482: PUSH
40483: LD_INT 3
40485: NEG
40486: PUSH
40487: EMPTY
40488: LIST
40489: LIST
40490: PUSH
40491: LD_INT 2
40493: PUSH
40494: LD_INT 1
40496: NEG
40497: PUSH
40498: EMPTY
40499: LIST
40500: LIST
40501: PUSH
40502: LD_INT 3
40504: PUSH
40505: LD_INT 0
40507: PUSH
40508: EMPTY
40509: LIST
40510: LIST
40511: PUSH
40512: LD_INT 3
40514: PUSH
40515: LD_INT 1
40517: PUSH
40518: EMPTY
40519: LIST
40520: LIST
40521: PUSH
40522: LD_INT 3
40524: PUSH
40525: LD_INT 2
40527: PUSH
40528: EMPTY
40529: LIST
40530: LIST
40531: PUSH
40532: LD_INT 3
40534: PUSH
40535: LD_INT 3
40537: PUSH
40538: EMPTY
40539: LIST
40540: LIST
40541: PUSH
40542: LD_INT 2
40544: PUSH
40545: LD_INT 3
40547: PUSH
40548: EMPTY
40549: LIST
40550: LIST
40551: PUSH
40552: LD_INT 2
40554: NEG
40555: PUSH
40556: LD_INT 1
40558: PUSH
40559: EMPTY
40560: LIST
40561: LIST
40562: PUSH
40563: LD_INT 3
40565: NEG
40566: PUSH
40567: LD_INT 0
40569: PUSH
40570: EMPTY
40571: LIST
40572: LIST
40573: PUSH
40574: LD_INT 3
40576: NEG
40577: PUSH
40578: LD_INT 1
40580: NEG
40581: PUSH
40582: EMPTY
40583: LIST
40584: LIST
40585: PUSH
40586: LD_INT 3
40588: NEG
40589: PUSH
40590: LD_INT 2
40592: NEG
40593: PUSH
40594: EMPTY
40595: LIST
40596: LIST
40597: PUSH
40598: LD_INT 3
40600: NEG
40601: PUSH
40602: LD_INT 3
40604: NEG
40605: PUSH
40606: EMPTY
40607: LIST
40608: LIST
40609: PUSH
40610: EMPTY
40611: LIST
40612: LIST
40613: LIST
40614: LIST
40615: LIST
40616: LIST
40617: LIST
40618: LIST
40619: LIST
40620: LIST
40621: LIST
40622: LIST
40623: LIST
40624: LIST
40625: LIST
40626: LIST
40627: LIST
40628: LIST
40629: LIST
40630: LIST
40631: LIST
40632: LIST
40633: LIST
40634: LIST
40635: LIST
40636: LIST
40637: LIST
40638: LIST
40639: LIST
40640: ST_TO_ADDR
// fLab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
40641: LD_ADDR_VAR 0 45
40645: PUSH
40646: LD_INT 0
40648: PUSH
40649: LD_INT 0
40651: PUSH
40652: EMPTY
40653: LIST
40654: LIST
40655: PUSH
40656: LD_INT 0
40658: PUSH
40659: LD_INT 1
40661: NEG
40662: PUSH
40663: EMPTY
40664: LIST
40665: LIST
40666: PUSH
40667: LD_INT 1
40669: PUSH
40670: LD_INT 0
40672: PUSH
40673: EMPTY
40674: LIST
40675: LIST
40676: PUSH
40677: LD_INT 1
40679: PUSH
40680: LD_INT 1
40682: PUSH
40683: EMPTY
40684: LIST
40685: LIST
40686: PUSH
40687: LD_INT 0
40689: PUSH
40690: LD_INT 1
40692: PUSH
40693: EMPTY
40694: LIST
40695: LIST
40696: PUSH
40697: LD_INT 1
40699: NEG
40700: PUSH
40701: LD_INT 0
40703: PUSH
40704: EMPTY
40705: LIST
40706: LIST
40707: PUSH
40708: LD_INT 1
40710: NEG
40711: PUSH
40712: LD_INT 1
40714: NEG
40715: PUSH
40716: EMPTY
40717: LIST
40718: LIST
40719: PUSH
40720: LD_INT 1
40722: NEG
40723: PUSH
40724: LD_INT 2
40726: NEG
40727: PUSH
40728: EMPTY
40729: LIST
40730: LIST
40731: PUSH
40732: LD_INT 0
40734: PUSH
40735: LD_INT 2
40737: NEG
40738: PUSH
40739: EMPTY
40740: LIST
40741: LIST
40742: PUSH
40743: LD_INT 1
40745: PUSH
40746: LD_INT 1
40748: NEG
40749: PUSH
40750: EMPTY
40751: LIST
40752: LIST
40753: PUSH
40754: LD_INT 2
40756: PUSH
40757: LD_INT 1
40759: PUSH
40760: EMPTY
40761: LIST
40762: LIST
40763: PUSH
40764: LD_INT 2
40766: PUSH
40767: LD_INT 2
40769: PUSH
40770: EMPTY
40771: LIST
40772: LIST
40773: PUSH
40774: LD_INT 1
40776: PUSH
40777: LD_INT 2
40779: PUSH
40780: EMPTY
40781: LIST
40782: LIST
40783: PUSH
40784: LD_INT 0
40786: PUSH
40787: LD_INT 2
40789: PUSH
40790: EMPTY
40791: LIST
40792: LIST
40793: PUSH
40794: LD_INT 1
40796: NEG
40797: PUSH
40798: LD_INT 1
40800: PUSH
40801: EMPTY
40802: LIST
40803: LIST
40804: PUSH
40805: LD_INT 2
40807: NEG
40808: PUSH
40809: LD_INT 1
40811: NEG
40812: PUSH
40813: EMPTY
40814: LIST
40815: LIST
40816: PUSH
40817: LD_INT 2
40819: NEG
40820: PUSH
40821: LD_INT 2
40823: NEG
40824: PUSH
40825: EMPTY
40826: LIST
40827: LIST
40828: PUSH
40829: LD_INT 2
40831: NEG
40832: PUSH
40833: LD_INT 3
40835: NEG
40836: PUSH
40837: EMPTY
40838: LIST
40839: LIST
40840: PUSH
40841: LD_INT 1
40843: NEG
40844: PUSH
40845: LD_INT 3
40847: NEG
40848: PUSH
40849: EMPTY
40850: LIST
40851: LIST
40852: PUSH
40853: LD_INT 0
40855: PUSH
40856: LD_INT 3
40858: NEG
40859: PUSH
40860: EMPTY
40861: LIST
40862: LIST
40863: PUSH
40864: LD_INT 1
40866: PUSH
40867: LD_INT 2
40869: NEG
40870: PUSH
40871: EMPTY
40872: LIST
40873: LIST
40874: PUSH
40875: LD_INT 3
40877: PUSH
40878: LD_INT 2
40880: PUSH
40881: EMPTY
40882: LIST
40883: LIST
40884: PUSH
40885: LD_INT 3
40887: PUSH
40888: LD_INT 3
40890: PUSH
40891: EMPTY
40892: LIST
40893: LIST
40894: PUSH
40895: LD_INT 2
40897: PUSH
40898: LD_INT 3
40900: PUSH
40901: EMPTY
40902: LIST
40903: LIST
40904: PUSH
40905: LD_INT 1
40907: PUSH
40908: LD_INT 3
40910: PUSH
40911: EMPTY
40912: LIST
40913: LIST
40914: PUSH
40915: LD_INT 0
40917: PUSH
40918: LD_INT 3
40920: PUSH
40921: EMPTY
40922: LIST
40923: LIST
40924: PUSH
40925: LD_INT 1
40927: NEG
40928: PUSH
40929: LD_INT 2
40931: PUSH
40932: EMPTY
40933: LIST
40934: LIST
40935: PUSH
40936: LD_INT 3
40938: NEG
40939: PUSH
40940: LD_INT 2
40942: NEG
40943: PUSH
40944: EMPTY
40945: LIST
40946: LIST
40947: PUSH
40948: LD_INT 3
40950: NEG
40951: PUSH
40952: LD_INT 3
40954: NEG
40955: PUSH
40956: EMPTY
40957: LIST
40958: LIST
40959: PUSH
40960: EMPTY
40961: LIST
40962: LIST
40963: LIST
40964: LIST
40965: LIST
40966: LIST
40967: LIST
40968: LIST
40969: LIST
40970: LIST
40971: LIST
40972: LIST
40973: LIST
40974: LIST
40975: LIST
40976: LIST
40977: LIST
40978: LIST
40979: LIST
40980: LIST
40981: LIST
40982: LIST
40983: LIST
40984: LIST
40985: LIST
40986: LIST
40987: LIST
40988: LIST
40989: LIST
40990: ST_TO_ADDR
// fLab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
40991: LD_ADDR_VAR 0 46
40995: PUSH
40996: LD_INT 0
40998: PUSH
40999: LD_INT 0
41001: PUSH
41002: EMPTY
41003: LIST
41004: LIST
41005: PUSH
41006: LD_INT 0
41008: PUSH
41009: LD_INT 1
41011: NEG
41012: PUSH
41013: EMPTY
41014: LIST
41015: LIST
41016: PUSH
41017: LD_INT 1
41019: PUSH
41020: LD_INT 0
41022: PUSH
41023: EMPTY
41024: LIST
41025: LIST
41026: PUSH
41027: LD_INT 1
41029: PUSH
41030: LD_INT 1
41032: PUSH
41033: EMPTY
41034: LIST
41035: LIST
41036: PUSH
41037: LD_INT 0
41039: PUSH
41040: LD_INT 1
41042: PUSH
41043: EMPTY
41044: LIST
41045: LIST
41046: PUSH
41047: LD_INT 1
41049: NEG
41050: PUSH
41051: LD_INT 0
41053: PUSH
41054: EMPTY
41055: LIST
41056: LIST
41057: PUSH
41058: LD_INT 1
41060: NEG
41061: PUSH
41062: LD_INT 1
41064: NEG
41065: PUSH
41066: EMPTY
41067: LIST
41068: LIST
41069: PUSH
41070: LD_INT 1
41072: NEG
41073: PUSH
41074: LD_INT 2
41076: NEG
41077: PUSH
41078: EMPTY
41079: LIST
41080: LIST
41081: PUSH
41082: LD_INT 0
41084: PUSH
41085: LD_INT 2
41087: NEG
41088: PUSH
41089: EMPTY
41090: LIST
41091: LIST
41092: PUSH
41093: LD_INT 1
41095: PUSH
41096: LD_INT 1
41098: NEG
41099: PUSH
41100: EMPTY
41101: LIST
41102: LIST
41103: PUSH
41104: LD_INT 2
41106: PUSH
41107: LD_INT 0
41109: PUSH
41110: EMPTY
41111: LIST
41112: LIST
41113: PUSH
41114: LD_INT 2
41116: PUSH
41117: LD_INT 1
41119: PUSH
41120: EMPTY
41121: LIST
41122: LIST
41123: PUSH
41124: LD_INT 1
41126: PUSH
41127: LD_INT 2
41129: PUSH
41130: EMPTY
41131: LIST
41132: LIST
41133: PUSH
41134: LD_INT 0
41136: PUSH
41137: LD_INT 2
41139: PUSH
41140: EMPTY
41141: LIST
41142: LIST
41143: PUSH
41144: LD_INT 1
41146: NEG
41147: PUSH
41148: LD_INT 1
41150: PUSH
41151: EMPTY
41152: LIST
41153: LIST
41154: PUSH
41155: LD_INT 2
41157: NEG
41158: PUSH
41159: LD_INT 0
41161: PUSH
41162: EMPTY
41163: LIST
41164: LIST
41165: PUSH
41166: LD_INT 2
41168: NEG
41169: PUSH
41170: LD_INT 1
41172: NEG
41173: PUSH
41174: EMPTY
41175: LIST
41176: LIST
41177: PUSH
41178: LD_INT 1
41180: NEG
41181: PUSH
41182: LD_INT 3
41184: NEG
41185: PUSH
41186: EMPTY
41187: LIST
41188: LIST
41189: PUSH
41190: LD_INT 0
41192: PUSH
41193: LD_INT 3
41195: NEG
41196: PUSH
41197: EMPTY
41198: LIST
41199: LIST
41200: PUSH
41201: LD_INT 1
41203: PUSH
41204: LD_INT 2
41206: NEG
41207: PUSH
41208: EMPTY
41209: LIST
41210: LIST
41211: PUSH
41212: LD_INT 2
41214: PUSH
41215: LD_INT 1
41217: NEG
41218: PUSH
41219: EMPTY
41220: LIST
41221: LIST
41222: PUSH
41223: LD_INT 3
41225: PUSH
41226: LD_INT 0
41228: PUSH
41229: EMPTY
41230: LIST
41231: LIST
41232: PUSH
41233: LD_INT 3
41235: PUSH
41236: LD_INT 1
41238: PUSH
41239: EMPTY
41240: LIST
41241: LIST
41242: PUSH
41243: LD_INT 1
41245: PUSH
41246: LD_INT 3
41248: PUSH
41249: EMPTY
41250: LIST
41251: LIST
41252: PUSH
41253: LD_INT 0
41255: PUSH
41256: LD_INT 3
41258: PUSH
41259: EMPTY
41260: LIST
41261: LIST
41262: PUSH
41263: LD_INT 1
41265: NEG
41266: PUSH
41267: LD_INT 2
41269: PUSH
41270: EMPTY
41271: LIST
41272: LIST
41273: PUSH
41274: LD_INT 2
41276: NEG
41277: PUSH
41278: LD_INT 1
41280: PUSH
41281: EMPTY
41282: LIST
41283: LIST
41284: PUSH
41285: LD_INT 3
41287: NEG
41288: PUSH
41289: LD_INT 0
41291: PUSH
41292: EMPTY
41293: LIST
41294: LIST
41295: PUSH
41296: LD_INT 3
41298: NEG
41299: PUSH
41300: LD_INT 1
41302: NEG
41303: PUSH
41304: EMPTY
41305: LIST
41306: LIST
41307: PUSH
41308: EMPTY
41309: LIST
41310: LIST
41311: LIST
41312: LIST
41313: LIST
41314: LIST
41315: LIST
41316: LIST
41317: LIST
41318: LIST
41319: LIST
41320: LIST
41321: LIST
41322: LIST
41323: LIST
41324: LIST
41325: LIST
41326: LIST
41327: LIST
41328: LIST
41329: LIST
41330: LIST
41331: LIST
41332: LIST
41333: LIST
41334: LIST
41335: LIST
41336: LIST
41337: LIST
41338: ST_TO_ADDR
// fControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
41339: LD_ADDR_VAR 0 47
41343: PUSH
41344: LD_INT 0
41346: PUSH
41347: LD_INT 0
41349: PUSH
41350: EMPTY
41351: LIST
41352: LIST
41353: PUSH
41354: LD_INT 0
41356: PUSH
41357: LD_INT 1
41359: NEG
41360: PUSH
41361: EMPTY
41362: LIST
41363: LIST
41364: PUSH
41365: LD_INT 1
41367: PUSH
41368: LD_INT 0
41370: PUSH
41371: EMPTY
41372: LIST
41373: LIST
41374: PUSH
41375: LD_INT 1
41377: PUSH
41378: LD_INT 1
41380: PUSH
41381: EMPTY
41382: LIST
41383: LIST
41384: PUSH
41385: LD_INT 0
41387: PUSH
41388: LD_INT 1
41390: PUSH
41391: EMPTY
41392: LIST
41393: LIST
41394: PUSH
41395: LD_INT 1
41397: NEG
41398: PUSH
41399: LD_INT 0
41401: PUSH
41402: EMPTY
41403: LIST
41404: LIST
41405: PUSH
41406: LD_INT 1
41408: NEG
41409: PUSH
41410: LD_INT 1
41412: NEG
41413: PUSH
41414: EMPTY
41415: LIST
41416: LIST
41417: PUSH
41418: LD_INT 1
41420: NEG
41421: PUSH
41422: LD_INT 2
41424: NEG
41425: PUSH
41426: EMPTY
41427: LIST
41428: LIST
41429: PUSH
41430: LD_INT 0
41432: PUSH
41433: LD_INT 2
41435: NEG
41436: PUSH
41437: EMPTY
41438: LIST
41439: LIST
41440: PUSH
41441: LD_INT 1
41443: PUSH
41444: LD_INT 1
41446: NEG
41447: PUSH
41448: EMPTY
41449: LIST
41450: LIST
41451: PUSH
41452: LD_INT 2
41454: NEG
41455: PUSH
41456: LD_INT 1
41458: NEG
41459: PUSH
41460: EMPTY
41461: LIST
41462: LIST
41463: PUSH
41464: LD_INT 2
41466: NEG
41467: PUSH
41468: LD_INT 2
41470: NEG
41471: PUSH
41472: EMPTY
41473: LIST
41474: LIST
41475: PUSH
41476: EMPTY
41477: LIST
41478: LIST
41479: LIST
41480: LIST
41481: LIST
41482: LIST
41483: LIST
41484: LIST
41485: LIST
41486: LIST
41487: LIST
41488: LIST
41489: ST_TO_ADDR
// fControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
41490: LD_ADDR_VAR 0 48
41494: PUSH
41495: LD_INT 0
41497: PUSH
41498: LD_INT 0
41500: PUSH
41501: EMPTY
41502: LIST
41503: LIST
41504: PUSH
41505: LD_INT 0
41507: PUSH
41508: LD_INT 1
41510: NEG
41511: PUSH
41512: EMPTY
41513: LIST
41514: LIST
41515: PUSH
41516: LD_INT 1
41518: PUSH
41519: LD_INT 0
41521: PUSH
41522: EMPTY
41523: LIST
41524: LIST
41525: PUSH
41526: LD_INT 1
41528: PUSH
41529: LD_INT 1
41531: PUSH
41532: EMPTY
41533: LIST
41534: LIST
41535: PUSH
41536: LD_INT 0
41538: PUSH
41539: LD_INT 1
41541: PUSH
41542: EMPTY
41543: LIST
41544: LIST
41545: PUSH
41546: LD_INT 1
41548: NEG
41549: PUSH
41550: LD_INT 0
41552: PUSH
41553: EMPTY
41554: LIST
41555: LIST
41556: PUSH
41557: LD_INT 1
41559: NEG
41560: PUSH
41561: LD_INT 1
41563: NEG
41564: PUSH
41565: EMPTY
41566: LIST
41567: LIST
41568: PUSH
41569: LD_INT 1
41571: NEG
41572: PUSH
41573: LD_INT 2
41575: NEG
41576: PUSH
41577: EMPTY
41578: LIST
41579: LIST
41580: PUSH
41581: LD_INT 0
41583: PUSH
41584: LD_INT 2
41586: NEG
41587: PUSH
41588: EMPTY
41589: LIST
41590: LIST
41591: PUSH
41592: LD_INT 1
41594: PUSH
41595: LD_INT 1
41597: NEG
41598: PUSH
41599: EMPTY
41600: LIST
41601: LIST
41602: PUSH
41603: LD_INT 2
41605: PUSH
41606: LD_INT 0
41608: PUSH
41609: EMPTY
41610: LIST
41611: LIST
41612: PUSH
41613: LD_INT 2
41615: PUSH
41616: LD_INT 1
41618: PUSH
41619: EMPTY
41620: LIST
41621: LIST
41622: PUSH
41623: EMPTY
41624: LIST
41625: LIST
41626: LIST
41627: LIST
41628: LIST
41629: LIST
41630: LIST
41631: LIST
41632: LIST
41633: LIST
41634: LIST
41635: LIST
41636: ST_TO_ADDR
// fControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
41637: LD_ADDR_VAR 0 49
41641: PUSH
41642: LD_INT 0
41644: PUSH
41645: LD_INT 0
41647: PUSH
41648: EMPTY
41649: LIST
41650: LIST
41651: PUSH
41652: LD_INT 0
41654: PUSH
41655: LD_INT 1
41657: NEG
41658: PUSH
41659: EMPTY
41660: LIST
41661: LIST
41662: PUSH
41663: LD_INT 1
41665: PUSH
41666: LD_INT 0
41668: PUSH
41669: EMPTY
41670: LIST
41671: LIST
41672: PUSH
41673: LD_INT 1
41675: PUSH
41676: LD_INT 1
41678: PUSH
41679: EMPTY
41680: LIST
41681: LIST
41682: PUSH
41683: LD_INT 0
41685: PUSH
41686: LD_INT 1
41688: PUSH
41689: EMPTY
41690: LIST
41691: LIST
41692: PUSH
41693: LD_INT 1
41695: NEG
41696: PUSH
41697: LD_INT 0
41699: PUSH
41700: EMPTY
41701: LIST
41702: LIST
41703: PUSH
41704: LD_INT 1
41706: NEG
41707: PUSH
41708: LD_INT 1
41710: NEG
41711: PUSH
41712: EMPTY
41713: LIST
41714: LIST
41715: PUSH
41716: LD_INT 1
41718: PUSH
41719: LD_INT 1
41721: NEG
41722: PUSH
41723: EMPTY
41724: LIST
41725: LIST
41726: PUSH
41727: LD_INT 2
41729: PUSH
41730: LD_INT 0
41732: PUSH
41733: EMPTY
41734: LIST
41735: LIST
41736: PUSH
41737: LD_INT 2
41739: PUSH
41740: LD_INT 1
41742: PUSH
41743: EMPTY
41744: LIST
41745: LIST
41746: PUSH
41747: LD_INT 2
41749: PUSH
41750: LD_INT 2
41752: PUSH
41753: EMPTY
41754: LIST
41755: LIST
41756: PUSH
41757: LD_INT 1
41759: PUSH
41760: LD_INT 2
41762: PUSH
41763: EMPTY
41764: LIST
41765: LIST
41766: PUSH
41767: EMPTY
41768: LIST
41769: LIST
41770: LIST
41771: LIST
41772: LIST
41773: LIST
41774: LIST
41775: LIST
41776: LIST
41777: LIST
41778: LIST
41779: LIST
41780: ST_TO_ADDR
// fControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
41781: LD_ADDR_VAR 0 50
41785: PUSH
41786: LD_INT 0
41788: PUSH
41789: LD_INT 0
41791: PUSH
41792: EMPTY
41793: LIST
41794: LIST
41795: PUSH
41796: LD_INT 0
41798: PUSH
41799: LD_INT 1
41801: NEG
41802: PUSH
41803: EMPTY
41804: LIST
41805: LIST
41806: PUSH
41807: LD_INT 1
41809: PUSH
41810: LD_INT 0
41812: PUSH
41813: EMPTY
41814: LIST
41815: LIST
41816: PUSH
41817: LD_INT 1
41819: PUSH
41820: LD_INT 1
41822: PUSH
41823: EMPTY
41824: LIST
41825: LIST
41826: PUSH
41827: LD_INT 0
41829: PUSH
41830: LD_INT 1
41832: PUSH
41833: EMPTY
41834: LIST
41835: LIST
41836: PUSH
41837: LD_INT 1
41839: NEG
41840: PUSH
41841: LD_INT 0
41843: PUSH
41844: EMPTY
41845: LIST
41846: LIST
41847: PUSH
41848: LD_INT 1
41850: NEG
41851: PUSH
41852: LD_INT 1
41854: NEG
41855: PUSH
41856: EMPTY
41857: LIST
41858: LIST
41859: PUSH
41860: LD_INT 2
41862: PUSH
41863: LD_INT 1
41865: PUSH
41866: EMPTY
41867: LIST
41868: LIST
41869: PUSH
41870: LD_INT 2
41872: PUSH
41873: LD_INT 2
41875: PUSH
41876: EMPTY
41877: LIST
41878: LIST
41879: PUSH
41880: LD_INT 1
41882: PUSH
41883: LD_INT 2
41885: PUSH
41886: EMPTY
41887: LIST
41888: LIST
41889: PUSH
41890: LD_INT 0
41892: PUSH
41893: LD_INT 2
41895: PUSH
41896: EMPTY
41897: LIST
41898: LIST
41899: PUSH
41900: LD_INT 1
41902: NEG
41903: PUSH
41904: LD_INT 1
41906: PUSH
41907: EMPTY
41908: LIST
41909: LIST
41910: PUSH
41911: EMPTY
41912: LIST
41913: LIST
41914: LIST
41915: LIST
41916: LIST
41917: LIST
41918: LIST
41919: LIST
41920: LIST
41921: LIST
41922: LIST
41923: LIST
41924: ST_TO_ADDR
// fControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
41925: LD_ADDR_VAR 0 51
41929: PUSH
41930: LD_INT 0
41932: PUSH
41933: LD_INT 0
41935: PUSH
41936: EMPTY
41937: LIST
41938: LIST
41939: PUSH
41940: LD_INT 0
41942: PUSH
41943: LD_INT 1
41945: NEG
41946: PUSH
41947: EMPTY
41948: LIST
41949: LIST
41950: PUSH
41951: LD_INT 1
41953: PUSH
41954: LD_INT 0
41956: PUSH
41957: EMPTY
41958: LIST
41959: LIST
41960: PUSH
41961: LD_INT 1
41963: PUSH
41964: LD_INT 1
41966: PUSH
41967: EMPTY
41968: LIST
41969: LIST
41970: PUSH
41971: LD_INT 0
41973: PUSH
41974: LD_INT 1
41976: PUSH
41977: EMPTY
41978: LIST
41979: LIST
41980: PUSH
41981: LD_INT 1
41983: NEG
41984: PUSH
41985: LD_INT 0
41987: PUSH
41988: EMPTY
41989: LIST
41990: LIST
41991: PUSH
41992: LD_INT 1
41994: NEG
41995: PUSH
41996: LD_INT 1
41998: NEG
41999: PUSH
42000: EMPTY
42001: LIST
42002: LIST
42003: PUSH
42004: LD_INT 1
42006: PUSH
42007: LD_INT 2
42009: PUSH
42010: EMPTY
42011: LIST
42012: LIST
42013: PUSH
42014: LD_INT 0
42016: PUSH
42017: LD_INT 2
42019: PUSH
42020: EMPTY
42021: LIST
42022: LIST
42023: PUSH
42024: LD_INT 1
42026: NEG
42027: PUSH
42028: LD_INT 1
42030: PUSH
42031: EMPTY
42032: LIST
42033: LIST
42034: PUSH
42035: LD_INT 2
42037: NEG
42038: PUSH
42039: LD_INT 0
42041: PUSH
42042: EMPTY
42043: LIST
42044: LIST
42045: PUSH
42046: LD_INT 2
42048: NEG
42049: PUSH
42050: LD_INT 1
42052: NEG
42053: PUSH
42054: EMPTY
42055: LIST
42056: LIST
42057: PUSH
42058: EMPTY
42059: LIST
42060: LIST
42061: LIST
42062: LIST
42063: LIST
42064: LIST
42065: LIST
42066: LIST
42067: LIST
42068: LIST
42069: LIST
42070: LIST
42071: ST_TO_ADDR
// fControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
42072: LD_ADDR_VAR 0 52
42076: PUSH
42077: LD_INT 0
42079: PUSH
42080: LD_INT 0
42082: PUSH
42083: EMPTY
42084: LIST
42085: LIST
42086: PUSH
42087: LD_INT 0
42089: PUSH
42090: LD_INT 1
42092: NEG
42093: PUSH
42094: EMPTY
42095: LIST
42096: LIST
42097: PUSH
42098: LD_INT 1
42100: PUSH
42101: LD_INT 0
42103: PUSH
42104: EMPTY
42105: LIST
42106: LIST
42107: PUSH
42108: LD_INT 1
42110: PUSH
42111: LD_INT 1
42113: PUSH
42114: EMPTY
42115: LIST
42116: LIST
42117: PUSH
42118: LD_INT 0
42120: PUSH
42121: LD_INT 1
42123: PUSH
42124: EMPTY
42125: LIST
42126: LIST
42127: PUSH
42128: LD_INT 1
42130: NEG
42131: PUSH
42132: LD_INT 0
42134: PUSH
42135: EMPTY
42136: LIST
42137: LIST
42138: PUSH
42139: LD_INT 1
42141: NEG
42142: PUSH
42143: LD_INT 1
42145: NEG
42146: PUSH
42147: EMPTY
42148: LIST
42149: LIST
42150: PUSH
42151: LD_INT 1
42153: NEG
42154: PUSH
42155: LD_INT 2
42157: NEG
42158: PUSH
42159: EMPTY
42160: LIST
42161: LIST
42162: PUSH
42163: LD_INT 1
42165: NEG
42166: PUSH
42167: LD_INT 1
42169: PUSH
42170: EMPTY
42171: LIST
42172: LIST
42173: PUSH
42174: LD_INT 2
42176: NEG
42177: PUSH
42178: LD_INT 0
42180: PUSH
42181: EMPTY
42182: LIST
42183: LIST
42184: PUSH
42185: LD_INT 2
42187: NEG
42188: PUSH
42189: LD_INT 1
42191: NEG
42192: PUSH
42193: EMPTY
42194: LIST
42195: LIST
42196: PUSH
42197: LD_INT 2
42199: NEG
42200: PUSH
42201: LD_INT 2
42203: NEG
42204: PUSH
42205: EMPTY
42206: LIST
42207: LIST
42208: PUSH
42209: EMPTY
42210: LIST
42211: LIST
42212: LIST
42213: LIST
42214: LIST
42215: LIST
42216: LIST
42217: LIST
42218: LIST
42219: LIST
42220: LIST
42221: LIST
42222: ST_TO_ADDR
// fBarracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
42223: LD_ADDR_VAR 0 53
42227: PUSH
42228: LD_INT 0
42230: PUSH
42231: LD_INT 0
42233: PUSH
42234: EMPTY
42235: LIST
42236: LIST
42237: PUSH
42238: LD_INT 0
42240: PUSH
42241: LD_INT 1
42243: NEG
42244: PUSH
42245: EMPTY
42246: LIST
42247: LIST
42248: PUSH
42249: LD_INT 1
42251: PUSH
42252: LD_INT 0
42254: PUSH
42255: EMPTY
42256: LIST
42257: LIST
42258: PUSH
42259: LD_INT 1
42261: PUSH
42262: LD_INT 1
42264: PUSH
42265: EMPTY
42266: LIST
42267: LIST
42268: PUSH
42269: LD_INT 0
42271: PUSH
42272: LD_INT 1
42274: PUSH
42275: EMPTY
42276: LIST
42277: LIST
42278: PUSH
42279: LD_INT 1
42281: NEG
42282: PUSH
42283: LD_INT 0
42285: PUSH
42286: EMPTY
42287: LIST
42288: LIST
42289: PUSH
42290: LD_INT 1
42292: NEG
42293: PUSH
42294: LD_INT 1
42296: NEG
42297: PUSH
42298: EMPTY
42299: LIST
42300: LIST
42301: PUSH
42302: LD_INT 1
42304: NEG
42305: PUSH
42306: LD_INT 2
42308: NEG
42309: PUSH
42310: EMPTY
42311: LIST
42312: LIST
42313: PUSH
42314: LD_INT 0
42316: PUSH
42317: LD_INT 2
42319: NEG
42320: PUSH
42321: EMPTY
42322: LIST
42323: LIST
42324: PUSH
42325: LD_INT 1
42327: PUSH
42328: LD_INT 1
42330: NEG
42331: PUSH
42332: EMPTY
42333: LIST
42334: LIST
42335: PUSH
42336: LD_INT 2
42338: PUSH
42339: LD_INT 0
42341: PUSH
42342: EMPTY
42343: LIST
42344: LIST
42345: PUSH
42346: LD_INT 2
42348: PUSH
42349: LD_INT 1
42351: PUSH
42352: EMPTY
42353: LIST
42354: LIST
42355: PUSH
42356: LD_INT 2
42358: PUSH
42359: LD_INT 2
42361: PUSH
42362: EMPTY
42363: LIST
42364: LIST
42365: PUSH
42366: LD_INT 1
42368: PUSH
42369: LD_INT 2
42371: PUSH
42372: EMPTY
42373: LIST
42374: LIST
42375: PUSH
42376: LD_INT 0
42378: PUSH
42379: LD_INT 2
42381: PUSH
42382: EMPTY
42383: LIST
42384: LIST
42385: PUSH
42386: LD_INT 1
42388: NEG
42389: PUSH
42390: LD_INT 1
42392: PUSH
42393: EMPTY
42394: LIST
42395: LIST
42396: PUSH
42397: LD_INT 2
42399: NEG
42400: PUSH
42401: LD_INT 0
42403: PUSH
42404: EMPTY
42405: LIST
42406: LIST
42407: PUSH
42408: LD_INT 2
42410: NEG
42411: PUSH
42412: LD_INT 1
42414: NEG
42415: PUSH
42416: EMPTY
42417: LIST
42418: LIST
42419: PUSH
42420: LD_INT 2
42422: NEG
42423: PUSH
42424: LD_INT 2
42426: NEG
42427: PUSH
42428: EMPTY
42429: LIST
42430: LIST
42431: PUSH
42432: EMPTY
42433: LIST
42434: LIST
42435: LIST
42436: LIST
42437: LIST
42438: LIST
42439: LIST
42440: LIST
42441: LIST
42442: LIST
42443: LIST
42444: LIST
42445: LIST
42446: LIST
42447: LIST
42448: LIST
42449: LIST
42450: LIST
42451: LIST
42452: ST_TO_ADDR
// fBarracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
42453: LD_ADDR_VAR 0 54
42457: PUSH
42458: LD_INT 0
42460: PUSH
42461: LD_INT 0
42463: PUSH
42464: EMPTY
42465: LIST
42466: LIST
42467: PUSH
42468: LD_INT 0
42470: PUSH
42471: LD_INT 1
42473: NEG
42474: PUSH
42475: EMPTY
42476: LIST
42477: LIST
42478: PUSH
42479: LD_INT 1
42481: PUSH
42482: LD_INT 0
42484: PUSH
42485: EMPTY
42486: LIST
42487: LIST
42488: PUSH
42489: LD_INT 1
42491: PUSH
42492: LD_INT 1
42494: PUSH
42495: EMPTY
42496: LIST
42497: LIST
42498: PUSH
42499: LD_INT 0
42501: PUSH
42502: LD_INT 1
42504: PUSH
42505: EMPTY
42506: LIST
42507: LIST
42508: PUSH
42509: LD_INT 1
42511: NEG
42512: PUSH
42513: LD_INT 0
42515: PUSH
42516: EMPTY
42517: LIST
42518: LIST
42519: PUSH
42520: LD_INT 1
42522: NEG
42523: PUSH
42524: LD_INT 1
42526: NEG
42527: PUSH
42528: EMPTY
42529: LIST
42530: LIST
42531: PUSH
42532: LD_INT 1
42534: NEG
42535: PUSH
42536: LD_INT 2
42538: NEG
42539: PUSH
42540: EMPTY
42541: LIST
42542: LIST
42543: PUSH
42544: LD_INT 0
42546: PUSH
42547: LD_INT 2
42549: NEG
42550: PUSH
42551: EMPTY
42552: LIST
42553: LIST
42554: PUSH
42555: LD_INT 1
42557: PUSH
42558: LD_INT 1
42560: NEG
42561: PUSH
42562: EMPTY
42563: LIST
42564: LIST
42565: PUSH
42566: LD_INT 2
42568: PUSH
42569: LD_INT 0
42571: PUSH
42572: EMPTY
42573: LIST
42574: LIST
42575: PUSH
42576: LD_INT 2
42578: PUSH
42579: LD_INT 1
42581: PUSH
42582: EMPTY
42583: LIST
42584: LIST
42585: PUSH
42586: LD_INT 2
42588: PUSH
42589: LD_INT 2
42591: PUSH
42592: EMPTY
42593: LIST
42594: LIST
42595: PUSH
42596: LD_INT 1
42598: PUSH
42599: LD_INT 2
42601: PUSH
42602: EMPTY
42603: LIST
42604: LIST
42605: PUSH
42606: LD_INT 0
42608: PUSH
42609: LD_INT 2
42611: PUSH
42612: EMPTY
42613: LIST
42614: LIST
42615: PUSH
42616: LD_INT 1
42618: NEG
42619: PUSH
42620: LD_INT 1
42622: PUSH
42623: EMPTY
42624: LIST
42625: LIST
42626: PUSH
42627: LD_INT 2
42629: NEG
42630: PUSH
42631: LD_INT 0
42633: PUSH
42634: EMPTY
42635: LIST
42636: LIST
42637: PUSH
42638: LD_INT 2
42640: NEG
42641: PUSH
42642: LD_INT 1
42644: NEG
42645: PUSH
42646: EMPTY
42647: LIST
42648: LIST
42649: PUSH
42650: LD_INT 2
42652: NEG
42653: PUSH
42654: LD_INT 2
42656: NEG
42657: PUSH
42658: EMPTY
42659: LIST
42660: LIST
42661: PUSH
42662: EMPTY
42663: LIST
42664: LIST
42665: LIST
42666: LIST
42667: LIST
42668: LIST
42669: LIST
42670: LIST
42671: LIST
42672: LIST
42673: LIST
42674: LIST
42675: LIST
42676: LIST
42677: LIST
42678: LIST
42679: LIST
42680: LIST
42681: LIST
42682: ST_TO_ADDR
// fBarracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
42683: LD_ADDR_VAR 0 55
42687: PUSH
42688: LD_INT 0
42690: PUSH
42691: LD_INT 0
42693: PUSH
42694: EMPTY
42695: LIST
42696: LIST
42697: PUSH
42698: LD_INT 0
42700: PUSH
42701: LD_INT 1
42703: NEG
42704: PUSH
42705: EMPTY
42706: LIST
42707: LIST
42708: PUSH
42709: LD_INT 1
42711: PUSH
42712: LD_INT 0
42714: PUSH
42715: EMPTY
42716: LIST
42717: LIST
42718: PUSH
42719: LD_INT 1
42721: PUSH
42722: LD_INT 1
42724: PUSH
42725: EMPTY
42726: LIST
42727: LIST
42728: PUSH
42729: LD_INT 0
42731: PUSH
42732: LD_INT 1
42734: PUSH
42735: EMPTY
42736: LIST
42737: LIST
42738: PUSH
42739: LD_INT 1
42741: NEG
42742: PUSH
42743: LD_INT 0
42745: PUSH
42746: EMPTY
42747: LIST
42748: LIST
42749: PUSH
42750: LD_INT 1
42752: NEG
42753: PUSH
42754: LD_INT 1
42756: NEG
42757: PUSH
42758: EMPTY
42759: LIST
42760: LIST
42761: PUSH
42762: LD_INT 1
42764: NEG
42765: PUSH
42766: LD_INT 2
42768: NEG
42769: PUSH
42770: EMPTY
42771: LIST
42772: LIST
42773: PUSH
42774: LD_INT 0
42776: PUSH
42777: LD_INT 2
42779: NEG
42780: PUSH
42781: EMPTY
42782: LIST
42783: LIST
42784: PUSH
42785: LD_INT 1
42787: PUSH
42788: LD_INT 1
42790: NEG
42791: PUSH
42792: EMPTY
42793: LIST
42794: LIST
42795: PUSH
42796: LD_INT 2
42798: PUSH
42799: LD_INT 0
42801: PUSH
42802: EMPTY
42803: LIST
42804: LIST
42805: PUSH
42806: LD_INT 2
42808: PUSH
42809: LD_INT 1
42811: PUSH
42812: EMPTY
42813: LIST
42814: LIST
42815: PUSH
42816: LD_INT 2
42818: PUSH
42819: LD_INT 2
42821: PUSH
42822: EMPTY
42823: LIST
42824: LIST
42825: PUSH
42826: LD_INT 1
42828: PUSH
42829: LD_INT 2
42831: PUSH
42832: EMPTY
42833: LIST
42834: LIST
42835: PUSH
42836: LD_INT 0
42838: PUSH
42839: LD_INT 2
42841: PUSH
42842: EMPTY
42843: LIST
42844: LIST
42845: PUSH
42846: LD_INT 1
42848: NEG
42849: PUSH
42850: LD_INT 1
42852: PUSH
42853: EMPTY
42854: LIST
42855: LIST
42856: PUSH
42857: LD_INT 2
42859: NEG
42860: PUSH
42861: LD_INT 0
42863: PUSH
42864: EMPTY
42865: LIST
42866: LIST
42867: PUSH
42868: LD_INT 2
42870: NEG
42871: PUSH
42872: LD_INT 1
42874: NEG
42875: PUSH
42876: EMPTY
42877: LIST
42878: LIST
42879: PUSH
42880: LD_INT 2
42882: NEG
42883: PUSH
42884: LD_INT 2
42886: NEG
42887: PUSH
42888: EMPTY
42889: LIST
42890: LIST
42891: PUSH
42892: EMPTY
42893: LIST
42894: LIST
42895: LIST
42896: LIST
42897: LIST
42898: LIST
42899: LIST
42900: LIST
42901: LIST
42902: LIST
42903: LIST
42904: LIST
42905: LIST
42906: LIST
42907: LIST
42908: LIST
42909: LIST
42910: LIST
42911: LIST
42912: ST_TO_ADDR
// fBarracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
42913: LD_ADDR_VAR 0 56
42917: PUSH
42918: LD_INT 0
42920: PUSH
42921: LD_INT 0
42923: PUSH
42924: EMPTY
42925: LIST
42926: LIST
42927: PUSH
42928: LD_INT 0
42930: PUSH
42931: LD_INT 1
42933: NEG
42934: PUSH
42935: EMPTY
42936: LIST
42937: LIST
42938: PUSH
42939: LD_INT 1
42941: PUSH
42942: LD_INT 0
42944: PUSH
42945: EMPTY
42946: LIST
42947: LIST
42948: PUSH
42949: LD_INT 1
42951: PUSH
42952: LD_INT 1
42954: PUSH
42955: EMPTY
42956: LIST
42957: LIST
42958: PUSH
42959: LD_INT 0
42961: PUSH
42962: LD_INT 1
42964: PUSH
42965: EMPTY
42966: LIST
42967: LIST
42968: PUSH
42969: LD_INT 1
42971: NEG
42972: PUSH
42973: LD_INT 0
42975: PUSH
42976: EMPTY
42977: LIST
42978: LIST
42979: PUSH
42980: LD_INT 1
42982: NEG
42983: PUSH
42984: LD_INT 1
42986: NEG
42987: PUSH
42988: EMPTY
42989: LIST
42990: LIST
42991: PUSH
42992: LD_INT 1
42994: NEG
42995: PUSH
42996: LD_INT 2
42998: NEG
42999: PUSH
43000: EMPTY
43001: LIST
43002: LIST
43003: PUSH
43004: LD_INT 0
43006: PUSH
43007: LD_INT 2
43009: NEG
43010: PUSH
43011: EMPTY
43012: LIST
43013: LIST
43014: PUSH
43015: LD_INT 1
43017: PUSH
43018: LD_INT 1
43020: NEG
43021: PUSH
43022: EMPTY
43023: LIST
43024: LIST
43025: PUSH
43026: LD_INT 2
43028: PUSH
43029: LD_INT 0
43031: PUSH
43032: EMPTY
43033: LIST
43034: LIST
43035: PUSH
43036: LD_INT 2
43038: PUSH
43039: LD_INT 1
43041: PUSH
43042: EMPTY
43043: LIST
43044: LIST
43045: PUSH
43046: LD_INT 2
43048: PUSH
43049: LD_INT 2
43051: PUSH
43052: EMPTY
43053: LIST
43054: LIST
43055: PUSH
43056: LD_INT 1
43058: PUSH
43059: LD_INT 2
43061: PUSH
43062: EMPTY
43063: LIST
43064: LIST
43065: PUSH
43066: LD_INT 0
43068: PUSH
43069: LD_INT 2
43071: PUSH
43072: EMPTY
43073: LIST
43074: LIST
43075: PUSH
43076: LD_INT 1
43078: NEG
43079: PUSH
43080: LD_INT 1
43082: PUSH
43083: EMPTY
43084: LIST
43085: LIST
43086: PUSH
43087: LD_INT 2
43089: NEG
43090: PUSH
43091: LD_INT 0
43093: PUSH
43094: EMPTY
43095: LIST
43096: LIST
43097: PUSH
43098: LD_INT 2
43100: NEG
43101: PUSH
43102: LD_INT 1
43104: NEG
43105: PUSH
43106: EMPTY
43107: LIST
43108: LIST
43109: PUSH
43110: LD_INT 2
43112: NEG
43113: PUSH
43114: LD_INT 2
43116: NEG
43117: PUSH
43118: EMPTY
43119: LIST
43120: LIST
43121: PUSH
43122: EMPTY
43123: LIST
43124: LIST
43125: LIST
43126: LIST
43127: LIST
43128: LIST
43129: LIST
43130: LIST
43131: LIST
43132: LIST
43133: LIST
43134: LIST
43135: LIST
43136: LIST
43137: LIST
43138: LIST
43139: LIST
43140: LIST
43141: LIST
43142: ST_TO_ADDR
// fBarracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
43143: LD_ADDR_VAR 0 57
43147: PUSH
43148: LD_INT 0
43150: PUSH
43151: LD_INT 0
43153: PUSH
43154: EMPTY
43155: LIST
43156: LIST
43157: PUSH
43158: LD_INT 0
43160: PUSH
43161: LD_INT 1
43163: NEG
43164: PUSH
43165: EMPTY
43166: LIST
43167: LIST
43168: PUSH
43169: LD_INT 1
43171: PUSH
43172: LD_INT 0
43174: PUSH
43175: EMPTY
43176: LIST
43177: LIST
43178: PUSH
43179: LD_INT 1
43181: PUSH
43182: LD_INT 1
43184: PUSH
43185: EMPTY
43186: LIST
43187: LIST
43188: PUSH
43189: LD_INT 0
43191: PUSH
43192: LD_INT 1
43194: PUSH
43195: EMPTY
43196: LIST
43197: LIST
43198: PUSH
43199: LD_INT 1
43201: NEG
43202: PUSH
43203: LD_INT 0
43205: PUSH
43206: EMPTY
43207: LIST
43208: LIST
43209: PUSH
43210: LD_INT 1
43212: NEG
43213: PUSH
43214: LD_INT 1
43216: NEG
43217: PUSH
43218: EMPTY
43219: LIST
43220: LIST
43221: PUSH
43222: LD_INT 1
43224: NEG
43225: PUSH
43226: LD_INT 2
43228: NEG
43229: PUSH
43230: EMPTY
43231: LIST
43232: LIST
43233: PUSH
43234: LD_INT 0
43236: PUSH
43237: LD_INT 2
43239: NEG
43240: PUSH
43241: EMPTY
43242: LIST
43243: LIST
43244: PUSH
43245: LD_INT 1
43247: PUSH
43248: LD_INT 1
43250: NEG
43251: PUSH
43252: EMPTY
43253: LIST
43254: LIST
43255: PUSH
43256: LD_INT 2
43258: PUSH
43259: LD_INT 0
43261: PUSH
43262: EMPTY
43263: LIST
43264: LIST
43265: PUSH
43266: LD_INT 2
43268: PUSH
43269: LD_INT 1
43271: PUSH
43272: EMPTY
43273: LIST
43274: LIST
43275: PUSH
43276: LD_INT 2
43278: PUSH
43279: LD_INT 2
43281: PUSH
43282: EMPTY
43283: LIST
43284: LIST
43285: PUSH
43286: LD_INT 1
43288: PUSH
43289: LD_INT 2
43291: PUSH
43292: EMPTY
43293: LIST
43294: LIST
43295: PUSH
43296: LD_INT 0
43298: PUSH
43299: LD_INT 2
43301: PUSH
43302: EMPTY
43303: LIST
43304: LIST
43305: PUSH
43306: LD_INT 1
43308: NEG
43309: PUSH
43310: LD_INT 1
43312: PUSH
43313: EMPTY
43314: LIST
43315: LIST
43316: PUSH
43317: LD_INT 2
43319: NEG
43320: PUSH
43321: LD_INT 0
43323: PUSH
43324: EMPTY
43325: LIST
43326: LIST
43327: PUSH
43328: LD_INT 2
43330: NEG
43331: PUSH
43332: LD_INT 1
43334: NEG
43335: PUSH
43336: EMPTY
43337: LIST
43338: LIST
43339: PUSH
43340: LD_INT 2
43342: NEG
43343: PUSH
43344: LD_INT 2
43346: NEG
43347: PUSH
43348: EMPTY
43349: LIST
43350: LIST
43351: PUSH
43352: EMPTY
43353: LIST
43354: LIST
43355: LIST
43356: LIST
43357: LIST
43358: LIST
43359: LIST
43360: LIST
43361: LIST
43362: LIST
43363: LIST
43364: LIST
43365: LIST
43366: LIST
43367: LIST
43368: LIST
43369: LIST
43370: LIST
43371: LIST
43372: ST_TO_ADDR
// fBarracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
43373: LD_ADDR_VAR 0 58
43377: PUSH
43378: LD_INT 0
43380: PUSH
43381: LD_INT 0
43383: PUSH
43384: EMPTY
43385: LIST
43386: LIST
43387: PUSH
43388: LD_INT 0
43390: PUSH
43391: LD_INT 1
43393: NEG
43394: PUSH
43395: EMPTY
43396: LIST
43397: LIST
43398: PUSH
43399: LD_INT 1
43401: PUSH
43402: LD_INT 0
43404: PUSH
43405: EMPTY
43406: LIST
43407: LIST
43408: PUSH
43409: LD_INT 1
43411: PUSH
43412: LD_INT 1
43414: PUSH
43415: EMPTY
43416: LIST
43417: LIST
43418: PUSH
43419: LD_INT 0
43421: PUSH
43422: LD_INT 1
43424: PUSH
43425: EMPTY
43426: LIST
43427: LIST
43428: PUSH
43429: LD_INT 1
43431: NEG
43432: PUSH
43433: LD_INT 0
43435: PUSH
43436: EMPTY
43437: LIST
43438: LIST
43439: PUSH
43440: LD_INT 1
43442: NEG
43443: PUSH
43444: LD_INT 1
43446: NEG
43447: PUSH
43448: EMPTY
43449: LIST
43450: LIST
43451: PUSH
43452: LD_INT 1
43454: NEG
43455: PUSH
43456: LD_INT 2
43458: NEG
43459: PUSH
43460: EMPTY
43461: LIST
43462: LIST
43463: PUSH
43464: LD_INT 0
43466: PUSH
43467: LD_INT 2
43469: NEG
43470: PUSH
43471: EMPTY
43472: LIST
43473: LIST
43474: PUSH
43475: LD_INT 1
43477: PUSH
43478: LD_INT 1
43480: NEG
43481: PUSH
43482: EMPTY
43483: LIST
43484: LIST
43485: PUSH
43486: LD_INT 2
43488: PUSH
43489: LD_INT 0
43491: PUSH
43492: EMPTY
43493: LIST
43494: LIST
43495: PUSH
43496: LD_INT 2
43498: PUSH
43499: LD_INT 1
43501: PUSH
43502: EMPTY
43503: LIST
43504: LIST
43505: PUSH
43506: LD_INT 2
43508: PUSH
43509: LD_INT 2
43511: PUSH
43512: EMPTY
43513: LIST
43514: LIST
43515: PUSH
43516: LD_INT 1
43518: PUSH
43519: LD_INT 2
43521: PUSH
43522: EMPTY
43523: LIST
43524: LIST
43525: PUSH
43526: LD_INT 0
43528: PUSH
43529: LD_INT 2
43531: PUSH
43532: EMPTY
43533: LIST
43534: LIST
43535: PUSH
43536: LD_INT 1
43538: NEG
43539: PUSH
43540: LD_INT 1
43542: PUSH
43543: EMPTY
43544: LIST
43545: LIST
43546: PUSH
43547: LD_INT 2
43549: NEG
43550: PUSH
43551: LD_INT 0
43553: PUSH
43554: EMPTY
43555: LIST
43556: LIST
43557: PUSH
43558: LD_INT 2
43560: NEG
43561: PUSH
43562: LD_INT 1
43564: NEG
43565: PUSH
43566: EMPTY
43567: LIST
43568: LIST
43569: PUSH
43570: LD_INT 2
43572: NEG
43573: PUSH
43574: LD_INT 2
43576: NEG
43577: PUSH
43578: EMPTY
43579: LIST
43580: LIST
43581: PUSH
43582: EMPTY
43583: LIST
43584: LIST
43585: LIST
43586: LIST
43587: LIST
43588: LIST
43589: LIST
43590: LIST
43591: LIST
43592: LIST
43593: LIST
43594: LIST
43595: LIST
43596: LIST
43597: LIST
43598: LIST
43599: LIST
43600: LIST
43601: LIST
43602: ST_TO_ADDR
// fBunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
43603: LD_ADDR_VAR 0 59
43607: PUSH
43608: LD_INT 0
43610: PUSH
43611: LD_INT 0
43613: PUSH
43614: EMPTY
43615: LIST
43616: LIST
43617: PUSH
43618: LD_INT 0
43620: PUSH
43621: LD_INT 1
43623: NEG
43624: PUSH
43625: EMPTY
43626: LIST
43627: LIST
43628: PUSH
43629: LD_INT 1
43631: PUSH
43632: LD_INT 0
43634: PUSH
43635: EMPTY
43636: LIST
43637: LIST
43638: PUSH
43639: LD_INT 1
43641: PUSH
43642: LD_INT 1
43644: PUSH
43645: EMPTY
43646: LIST
43647: LIST
43648: PUSH
43649: LD_INT 0
43651: PUSH
43652: LD_INT 1
43654: PUSH
43655: EMPTY
43656: LIST
43657: LIST
43658: PUSH
43659: LD_INT 1
43661: NEG
43662: PUSH
43663: LD_INT 0
43665: PUSH
43666: EMPTY
43667: LIST
43668: LIST
43669: PUSH
43670: LD_INT 1
43672: NEG
43673: PUSH
43674: LD_INT 1
43676: NEG
43677: PUSH
43678: EMPTY
43679: LIST
43680: LIST
43681: PUSH
43682: EMPTY
43683: LIST
43684: LIST
43685: LIST
43686: LIST
43687: LIST
43688: LIST
43689: LIST
43690: ST_TO_ADDR
// fBunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
43691: LD_ADDR_VAR 0 60
43695: PUSH
43696: LD_INT 0
43698: PUSH
43699: LD_INT 0
43701: PUSH
43702: EMPTY
43703: LIST
43704: LIST
43705: PUSH
43706: LD_INT 0
43708: PUSH
43709: LD_INT 1
43711: NEG
43712: PUSH
43713: EMPTY
43714: LIST
43715: LIST
43716: PUSH
43717: LD_INT 1
43719: PUSH
43720: LD_INT 0
43722: PUSH
43723: EMPTY
43724: LIST
43725: LIST
43726: PUSH
43727: LD_INT 1
43729: PUSH
43730: LD_INT 1
43732: PUSH
43733: EMPTY
43734: LIST
43735: LIST
43736: PUSH
43737: LD_INT 0
43739: PUSH
43740: LD_INT 1
43742: PUSH
43743: EMPTY
43744: LIST
43745: LIST
43746: PUSH
43747: LD_INT 1
43749: NEG
43750: PUSH
43751: LD_INT 0
43753: PUSH
43754: EMPTY
43755: LIST
43756: LIST
43757: PUSH
43758: LD_INT 1
43760: NEG
43761: PUSH
43762: LD_INT 1
43764: NEG
43765: PUSH
43766: EMPTY
43767: LIST
43768: LIST
43769: PUSH
43770: EMPTY
43771: LIST
43772: LIST
43773: LIST
43774: LIST
43775: LIST
43776: LIST
43777: LIST
43778: ST_TO_ADDR
// fBunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
43779: LD_ADDR_VAR 0 61
43783: PUSH
43784: LD_INT 0
43786: PUSH
43787: LD_INT 0
43789: PUSH
43790: EMPTY
43791: LIST
43792: LIST
43793: PUSH
43794: LD_INT 0
43796: PUSH
43797: LD_INT 1
43799: NEG
43800: PUSH
43801: EMPTY
43802: LIST
43803: LIST
43804: PUSH
43805: LD_INT 1
43807: PUSH
43808: LD_INT 0
43810: PUSH
43811: EMPTY
43812: LIST
43813: LIST
43814: PUSH
43815: LD_INT 1
43817: PUSH
43818: LD_INT 1
43820: PUSH
43821: EMPTY
43822: LIST
43823: LIST
43824: PUSH
43825: LD_INT 0
43827: PUSH
43828: LD_INT 1
43830: PUSH
43831: EMPTY
43832: LIST
43833: LIST
43834: PUSH
43835: LD_INT 1
43837: NEG
43838: PUSH
43839: LD_INT 0
43841: PUSH
43842: EMPTY
43843: LIST
43844: LIST
43845: PUSH
43846: LD_INT 1
43848: NEG
43849: PUSH
43850: LD_INT 1
43852: NEG
43853: PUSH
43854: EMPTY
43855: LIST
43856: LIST
43857: PUSH
43858: EMPTY
43859: LIST
43860: LIST
43861: LIST
43862: LIST
43863: LIST
43864: LIST
43865: LIST
43866: ST_TO_ADDR
// fBunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
43867: LD_ADDR_VAR 0 62
43871: PUSH
43872: LD_INT 0
43874: PUSH
43875: LD_INT 0
43877: PUSH
43878: EMPTY
43879: LIST
43880: LIST
43881: PUSH
43882: LD_INT 0
43884: PUSH
43885: LD_INT 1
43887: NEG
43888: PUSH
43889: EMPTY
43890: LIST
43891: LIST
43892: PUSH
43893: LD_INT 1
43895: PUSH
43896: LD_INT 0
43898: PUSH
43899: EMPTY
43900: LIST
43901: LIST
43902: PUSH
43903: LD_INT 1
43905: PUSH
43906: LD_INT 1
43908: PUSH
43909: EMPTY
43910: LIST
43911: LIST
43912: PUSH
43913: LD_INT 0
43915: PUSH
43916: LD_INT 1
43918: PUSH
43919: EMPTY
43920: LIST
43921: LIST
43922: PUSH
43923: LD_INT 1
43925: NEG
43926: PUSH
43927: LD_INT 0
43929: PUSH
43930: EMPTY
43931: LIST
43932: LIST
43933: PUSH
43934: LD_INT 1
43936: NEG
43937: PUSH
43938: LD_INT 1
43940: NEG
43941: PUSH
43942: EMPTY
43943: LIST
43944: LIST
43945: PUSH
43946: EMPTY
43947: LIST
43948: LIST
43949: LIST
43950: LIST
43951: LIST
43952: LIST
43953: LIST
43954: ST_TO_ADDR
// fBunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
43955: LD_ADDR_VAR 0 63
43959: PUSH
43960: LD_INT 0
43962: PUSH
43963: LD_INT 0
43965: PUSH
43966: EMPTY
43967: LIST
43968: LIST
43969: PUSH
43970: LD_INT 0
43972: PUSH
43973: LD_INT 1
43975: NEG
43976: PUSH
43977: EMPTY
43978: LIST
43979: LIST
43980: PUSH
43981: LD_INT 1
43983: PUSH
43984: LD_INT 0
43986: PUSH
43987: EMPTY
43988: LIST
43989: LIST
43990: PUSH
43991: LD_INT 1
43993: PUSH
43994: LD_INT 1
43996: PUSH
43997: EMPTY
43998: LIST
43999: LIST
44000: PUSH
44001: LD_INT 0
44003: PUSH
44004: LD_INT 1
44006: PUSH
44007: EMPTY
44008: LIST
44009: LIST
44010: PUSH
44011: LD_INT 1
44013: NEG
44014: PUSH
44015: LD_INT 0
44017: PUSH
44018: EMPTY
44019: LIST
44020: LIST
44021: PUSH
44022: LD_INT 1
44024: NEG
44025: PUSH
44026: LD_INT 1
44028: NEG
44029: PUSH
44030: EMPTY
44031: LIST
44032: LIST
44033: PUSH
44034: EMPTY
44035: LIST
44036: LIST
44037: LIST
44038: LIST
44039: LIST
44040: LIST
44041: LIST
44042: ST_TO_ADDR
// fBunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
44043: LD_ADDR_VAR 0 64
44047: PUSH
44048: LD_INT 0
44050: PUSH
44051: LD_INT 0
44053: PUSH
44054: EMPTY
44055: LIST
44056: LIST
44057: PUSH
44058: LD_INT 0
44060: PUSH
44061: LD_INT 1
44063: NEG
44064: PUSH
44065: EMPTY
44066: LIST
44067: LIST
44068: PUSH
44069: LD_INT 1
44071: PUSH
44072: LD_INT 0
44074: PUSH
44075: EMPTY
44076: LIST
44077: LIST
44078: PUSH
44079: LD_INT 1
44081: PUSH
44082: LD_INT 1
44084: PUSH
44085: EMPTY
44086: LIST
44087: LIST
44088: PUSH
44089: LD_INT 0
44091: PUSH
44092: LD_INT 1
44094: PUSH
44095: EMPTY
44096: LIST
44097: LIST
44098: PUSH
44099: LD_INT 1
44101: NEG
44102: PUSH
44103: LD_INT 0
44105: PUSH
44106: EMPTY
44107: LIST
44108: LIST
44109: PUSH
44110: LD_INT 1
44112: NEG
44113: PUSH
44114: LD_INT 1
44116: NEG
44117: PUSH
44118: EMPTY
44119: LIST
44120: LIST
44121: PUSH
44122: EMPTY
44123: LIST
44124: LIST
44125: LIST
44126: LIST
44127: LIST
44128: LIST
44129: LIST
44130: ST_TO_ADDR
// end ; 1 :
44131: GO 50028
44133: LD_INT 1
44135: DOUBLE
44136: EQUAL
44137: IFTRUE 44141
44139: GO 46764
44141: POP
// begin fDepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
44142: LD_ADDR_VAR 0 11
44146: PUSH
44147: LD_INT 1
44149: NEG
44150: PUSH
44151: LD_INT 3
44153: NEG
44154: PUSH
44155: EMPTY
44156: LIST
44157: LIST
44158: PUSH
44159: LD_INT 0
44161: PUSH
44162: LD_INT 3
44164: NEG
44165: PUSH
44166: EMPTY
44167: LIST
44168: LIST
44169: PUSH
44170: LD_INT 1
44172: PUSH
44173: LD_INT 2
44175: NEG
44176: PUSH
44177: EMPTY
44178: LIST
44179: LIST
44180: PUSH
44181: EMPTY
44182: LIST
44183: LIST
44184: LIST
44185: ST_TO_ADDR
// fDepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
44186: LD_ADDR_VAR 0 12
44190: PUSH
44191: LD_INT 2
44193: PUSH
44194: LD_INT 1
44196: NEG
44197: PUSH
44198: EMPTY
44199: LIST
44200: LIST
44201: PUSH
44202: LD_INT 3
44204: PUSH
44205: LD_INT 0
44207: PUSH
44208: EMPTY
44209: LIST
44210: LIST
44211: PUSH
44212: LD_INT 3
44214: PUSH
44215: LD_INT 1
44217: PUSH
44218: EMPTY
44219: LIST
44220: LIST
44221: PUSH
44222: EMPTY
44223: LIST
44224: LIST
44225: LIST
44226: ST_TO_ADDR
// fDepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
44227: LD_ADDR_VAR 0 13
44231: PUSH
44232: LD_INT 3
44234: PUSH
44235: LD_INT 2
44237: PUSH
44238: EMPTY
44239: LIST
44240: LIST
44241: PUSH
44242: LD_INT 3
44244: PUSH
44245: LD_INT 3
44247: PUSH
44248: EMPTY
44249: LIST
44250: LIST
44251: PUSH
44252: LD_INT 2
44254: PUSH
44255: LD_INT 3
44257: PUSH
44258: EMPTY
44259: LIST
44260: LIST
44261: PUSH
44262: EMPTY
44263: LIST
44264: LIST
44265: LIST
44266: ST_TO_ADDR
// fDepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
44267: LD_ADDR_VAR 0 14
44271: PUSH
44272: LD_INT 1
44274: PUSH
44275: LD_INT 3
44277: PUSH
44278: EMPTY
44279: LIST
44280: LIST
44281: PUSH
44282: LD_INT 0
44284: PUSH
44285: LD_INT 3
44287: PUSH
44288: EMPTY
44289: LIST
44290: LIST
44291: PUSH
44292: LD_INT 1
44294: NEG
44295: PUSH
44296: LD_INT 2
44298: PUSH
44299: EMPTY
44300: LIST
44301: LIST
44302: PUSH
44303: EMPTY
44304: LIST
44305: LIST
44306: LIST
44307: ST_TO_ADDR
// fDepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
44308: LD_ADDR_VAR 0 15
44312: PUSH
44313: LD_INT 2
44315: NEG
44316: PUSH
44317: LD_INT 1
44319: PUSH
44320: EMPTY
44321: LIST
44322: LIST
44323: PUSH
44324: LD_INT 3
44326: NEG
44327: PUSH
44328: LD_INT 0
44330: PUSH
44331: EMPTY
44332: LIST
44333: LIST
44334: PUSH
44335: LD_INT 3
44337: NEG
44338: PUSH
44339: LD_INT 1
44341: NEG
44342: PUSH
44343: EMPTY
44344: LIST
44345: LIST
44346: PUSH
44347: EMPTY
44348: LIST
44349: LIST
44350: LIST
44351: ST_TO_ADDR
// fDepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
44352: LD_ADDR_VAR 0 16
44356: PUSH
44357: LD_INT 2
44359: NEG
44360: PUSH
44361: LD_INT 3
44363: NEG
44364: PUSH
44365: EMPTY
44366: LIST
44367: LIST
44368: PUSH
44369: LD_INT 3
44371: NEG
44372: PUSH
44373: LD_INT 2
44375: NEG
44376: PUSH
44377: EMPTY
44378: LIST
44379: LIST
44380: PUSH
44381: LD_INT 3
44383: NEG
44384: PUSH
44385: LD_INT 3
44387: NEG
44388: PUSH
44389: EMPTY
44390: LIST
44391: LIST
44392: PUSH
44393: EMPTY
44394: LIST
44395: LIST
44396: LIST
44397: ST_TO_ADDR
// fDepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
44398: LD_ADDR_VAR 0 17
44402: PUSH
44403: LD_INT 1
44405: NEG
44406: PUSH
44407: LD_INT 3
44409: NEG
44410: PUSH
44411: EMPTY
44412: LIST
44413: LIST
44414: PUSH
44415: LD_INT 0
44417: PUSH
44418: LD_INT 3
44420: NEG
44421: PUSH
44422: EMPTY
44423: LIST
44424: LIST
44425: PUSH
44426: LD_INT 1
44428: PUSH
44429: LD_INT 2
44431: NEG
44432: PUSH
44433: EMPTY
44434: LIST
44435: LIST
44436: PUSH
44437: EMPTY
44438: LIST
44439: LIST
44440: LIST
44441: ST_TO_ADDR
// fDepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
44442: LD_ADDR_VAR 0 18
44446: PUSH
44447: LD_INT 2
44449: PUSH
44450: LD_INT 1
44452: NEG
44453: PUSH
44454: EMPTY
44455: LIST
44456: LIST
44457: PUSH
44458: LD_INT 3
44460: PUSH
44461: LD_INT 0
44463: PUSH
44464: EMPTY
44465: LIST
44466: LIST
44467: PUSH
44468: LD_INT 3
44470: PUSH
44471: LD_INT 1
44473: PUSH
44474: EMPTY
44475: LIST
44476: LIST
44477: PUSH
44478: EMPTY
44479: LIST
44480: LIST
44481: LIST
44482: ST_TO_ADDR
// fDepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
44483: LD_ADDR_VAR 0 19
44487: PUSH
44488: LD_INT 3
44490: PUSH
44491: LD_INT 2
44493: PUSH
44494: EMPTY
44495: LIST
44496: LIST
44497: PUSH
44498: LD_INT 3
44500: PUSH
44501: LD_INT 3
44503: PUSH
44504: EMPTY
44505: LIST
44506: LIST
44507: PUSH
44508: LD_INT 2
44510: PUSH
44511: LD_INT 3
44513: PUSH
44514: EMPTY
44515: LIST
44516: LIST
44517: PUSH
44518: EMPTY
44519: LIST
44520: LIST
44521: LIST
44522: ST_TO_ADDR
// fDepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
44523: LD_ADDR_VAR 0 20
44527: PUSH
44528: LD_INT 1
44530: PUSH
44531: LD_INT 3
44533: PUSH
44534: EMPTY
44535: LIST
44536: LIST
44537: PUSH
44538: LD_INT 0
44540: PUSH
44541: LD_INT 3
44543: PUSH
44544: EMPTY
44545: LIST
44546: LIST
44547: PUSH
44548: LD_INT 1
44550: NEG
44551: PUSH
44552: LD_INT 2
44554: PUSH
44555: EMPTY
44556: LIST
44557: LIST
44558: PUSH
44559: EMPTY
44560: LIST
44561: LIST
44562: LIST
44563: ST_TO_ADDR
// fDepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
44564: LD_ADDR_VAR 0 21
44568: PUSH
44569: LD_INT 2
44571: NEG
44572: PUSH
44573: LD_INT 1
44575: PUSH
44576: EMPTY
44577: LIST
44578: LIST
44579: PUSH
44580: LD_INT 3
44582: NEG
44583: PUSH
44584: LD_INT 0
44586: PUSH
44587: EMPTY
44588: LIST
44589: LIST
44590: PUSH
44591: LD_INT 3
44593: NEG
44594: PUSH
44595: LD_INT 1
44597: NEG
44598: PUSH
44599: EMPTY
44600: LIST
44601: LIST
44602: PUSH
44603: EMPTY
44604: LIST
44605: LIST
44606: LIST
44607: ST_TO_ADDR
// fDepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
44608: LD_ADDR_VAR 0 22
44612: PUSH
44613: LD_INT 2
44615: NEG
44616: PUSH
44617: LD_INT 3
44619: NEG
44620: PUSH
44621: EMPTY
44622: LIST
44623: LIST
44624: PUSH
44625: LD_INT 3
44627: NEG
44628: PUSH
44629: LD_INT 2
44631: NEG
44632: PUSH
44633: EMPTY
44634: LIST
44635: LIST
44636: PUSH
44637: LD_INT 3
44639: NEG
44640: PUSH
44641: LD_INT 3
44643: NEG
44644: PUSH
44645: EMPTY
44646: LIST
44647: LIST
44648: PUSH
44649: EMPTY
44650: LIST
44651: LIST
44652: LIST
44653: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
44654: LD_ADDR_VAR 0 23
44658: PUSH
44659: LD_INT 0
44661: PUSH
44662: LD_INT 3
44664: NEG
44665: PUSH
44666: EMPTY
44667: LIST
44668: LIST
44669: PUSH
44670: LD_INT 1
44672: NEG
44673: PUSH
44674: LD_INT 4
44676: NEG
44677: PUSH
44678: EMPTY
44679: LIST
44680: LIST
44681: PUSH
44682: LD_INT 1
44684: PUSH
44685: LD_INT 3
44687: NEG
44688: PUSH
44689: EMPTY
44690: LIST
44691: LIST
44692: PUSH
44693: EMPTY
44694: LIST
44695: LIST
44696: LIST
44697: ST_TO_ADDR
// fDepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
44698: LD_ADDR_VAR 0 24
44702: PUSH
44703: LD_INT 3
44705: PUSH
44706: LD_INT 0
44708: PUSH
44709: EMPTY
44710: LIST
44711: LIST
44712: PUSH
44713: LD_INT 3
44715: PUSH
44716: LD_INT 1
44718: NEG
44719: PUSH
44720: EMPTY
44721: LIST
44722: LIST
44723: PUSH
44724: LD_INT 4
44726: PUSH
44727: LD_INT 1
44729: PUSH
44730: EMPTY
44731: LIST
44732: LIST
44733: PUSH
44734: EMPTY
44735: LIST
44736: LIST
44737: LIST
44738: ST_TO_ADDR
// fDepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
44739: LD_ADDR_VAR 0 25
44743: PUSH
44744: LD_INT 3
44746: PUSH
44747: LD_INT 3
44749: PUSH
44750: EMPTY
44751: LIST
44752: LIST
44753: PUSH
44754: LD_INT 4
44756: PUSH
44757: LD_INT 3
44759: PUSH
44760: EMPTY
44761: LIST
44762: LIST
44763: PUSH
44764: LD_INT 3
44766: PUSH
44767: LD_INT 4
44769: PUSH
44770: EMPTY
44771: LIST
44772: LIST
44773: PUSH
44774: EMPTY
44775: LIST
44776: LIST
44777: LIST
44778: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
44779: LD_ADDR_VAR 0 26
44783: PUSH
44784: LD_INT 0
44786: PUSH
44787: LD_INT 3
44789: PUSH
44790: EMPTY
44791: LIST
44792: LIST
44793: PUSH
44794: LD_INT 1
44796: PUSH
44797: LD_INT 4
44799: PUSH
44800: EMPTY
44801: LIST
44802: LIST
44803: PUSH
44804: LD_INT 1
44806: NEG
44807: PUSH
44808: LD_INT 3
44810: PUSH
44811: EMPTY
44812: LIST
44813: LIST
44814: PUSH
44815: EMPTY
44816: LIST
44817: LIST
44818: LIST
44819: ST_TO_ADDR
// fDepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
44820: LD_ADDR_VAR 0 27
44824: PUSH
44825: LD_INT 3
44827: NEG
44828: PUSH
44829: LD_INT 0
44831: PUSH
44832: EMPTY
44833: LIST
44834: LIST
44835: PUSH
44836: LD_INT 3
44838: NEG
44839: PUSH
44840: LD_INT 1
44842: PUSH
44843: EMPTY
44844: LIST
44845: LIST
44846: PUSH
44847: LD_INT 4
44849: NEG
44850: PUSH
44851: LD_INT 1
44853: NEG
44854: PUSH
44855: EMPTY
44856: LIST
44857: LIST
44858: PUSH
44859: EMPTY
44860: LIST
44861: LIST
44862: LIST
44863: ST_TO_ADDR
// fDepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
44864: LD_ADDR_VAR 0 28
44868: PUSH
44869: LD_INT 3
44871: NEG
44872: PUSH
44873: LD_INT 3
44875: NEG
44876: PUSH
44877: EMPTY
44878: LIST
44879: LIST
44880: PUSH
44881: LD_INT 3
44883: NEG
44884: PUSH
44885: LD_INT 4
44887: NEG
44888: PUSH
44889: EMPTY
44890: LIST
44891: LIST
44892: PUSH
44893: LD_INT 4
44895: NEG
44896: PUSH
44897: LD_INT 3
44899: NEG
44900: PUSH
44901: EMPTY
44902: LIST
44903: LIST
44904: PUSH
44905: EMPTY
44906: LIST
44907: LIST
44908: LIST
44909: ST_TO_ADDR
// fFactory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
44910: LD_ADDR_VAR 0 29
44914: PUSH
44915: LD_INT 1
44917: NEG
44918: PUSH
44919: LD_INT 3
44921: NEG
44922: PUSH
44923: EMPTY
44924: LIST
44925: LIST
44926: PUSH
44927: LD_INT 0
44929: PUSH
44930: LD_INT 3
44932: NEG
44933: PUSH
44934: EMPTY
44935: LIST
44936: LIST
44937: PUSH
44938: LD_INT 1
44940: PUSH
44941: LD_INT 2
44943: NEG
44944: PUSH
44945: EMPTY
44946: LIST
44947: LIST
44948: PUSH
44949: LD_INT 1
44951: NEG
44952: PUSH
44953: LD_INT 4
44955: NEG
44956: PUSH
44957: EMPTY
44958: LIST
44959: LIST
44960: PUSH
44961: LD_INT 0
44963: PUSH
44964: LD_INT 4
44966: NEG
44967: PUSH
44968: EMPTY
44969: LIST
44970: LIST
44971: PUSH
44972: LD_INT 1
44974: PUSH
44975: LD_INT 3
44977: NEG
44978: PUSH
44979: EMPTY
44980: LIST
44981: LIST
44982: PUSH
44983: LD_INT 1
44985: NEG
44986: PUSH
44987: LD_INT 5
44989: NEG
44990: PUSH
44991: EMPTY
44992: LIST
44993: LIST
44994: PUSH
44995: LD_INT 0
44997: PUSH
44998: LD_INT 5
45000: NEG
45001: PUSH
45002: EMPTY
45003: LIST
45004: LIST
45005: PUSH
45006: LD_INT 1
45008: PUSH
45009: LD_INT 4
45011: NEG
45012: PUSH
45013: EMPTY
45014: LIST
45015: LIST
45016: PUSH
45017: LD_INT 1
45019: NEG
45020: PUSH
45021: LD_INT 6
45023: NEG
45024: PUSH
45025: EMPTY
45026: LIST
45027: LIST
45028: PUSH
45029: LD_INT 0
45031: PUSH
45032: LD_INT 6
45034: NEG
45035: PUSH
45036: EMPTY
45037: LIST
45038: LIST
45039: PUSH
45040: LD_INT 1
45042: PUSH
45043: LD_INT 5
45045: NEG
45046: PUSH
45047: EMPTY
45048: LIST
45049: LIST
45050: PUSH
45051: EMPTY
45052: LIST
45053: LIST
45054: LIST
45055: LIST
45056: LIST
45057: LIST
45058: LIST
45059: LIST
45060: LIST
45061: LIST
45062: LIST
45063: LIST
45064: ST_TO_ADDR
// fFactory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
45065: LD_ADDR_VAR 0 30
45069: PUSH
45070: LD_INT 2
45072: PUSH
45073: LD_INT 1
45075: NEG
45076: PUSH
45077: EMPTY
45078: LIST
45079: LIST
45080: PUSH
45081: LD_INT 3
45083: PUSH
45084: LD_INT 0
45086: PUSH
45087: EMPTY
45088: LIST
45089: LIST
45090: PUSH
45091: LD_INT 3
45093: PUSH
45094: LD_INT 1
45096: PUSH
45097: EMPTY
45098: LIST
45099: LIST
45100: PUSH
45101: LD_INT 3
45103: PUSH
45104: LD_INT 1
45106: NEG
45107: PUSH
45108: EMPTY
45109: LIST
45110: LIST
45111: PUSH
45112: LD_INT 4
45114: PUSH
45115: LD_INT 0
45117: PUSH
45118: EMPTY
45119: LIST
45120: LIST
45121: PUSH
45122: LD_INT 4
45124: PUSH
45125: LD_INT 1
45127: PUSH
45128: EMPTY
45129: LIST
45130: LIST
45131: PUSH
45132: LD_INT 4
45134: PUSH
45135: LD_INT 1
45137: NEG
45138: PUSH
45139: EMPTY
45140: LIST
45141: LIST
45142: PUSH
45143: LD_INT 5
45145: PUSH
45146: LD_INT 0
45148: PUSH
45149: EMPTY
45150: LIST
45151: LIST
45152: PUSH
45153: LD_INT 5
45155: PUSH
45156: LD_INT 1
45158: PUSH
45159: EMPTY
45160: LIST
45161: LIST
45162: PUSH
45163: LD_INT 5
45165: PUSH
45166: LD_INT 1
45168: NEG
45169: PUSH
45170: EMPTY
45171: LIST
45172: LIST
45173: PUSH
45174: LD_INT 6
45176: PUSH
45177: LD_INT 0
45179: PUSH
45180: EMPTY
45181: LIST
45182: LIST
45183: PUSH
45184: LD_INT 6
45186: PUSH
45187: LD_INT 1
45189: PUSH
45190: EMPTY
45191: LIST
45192: LIST
45193: PUSH
45194: EMPTY
45195: LIST
45196: LIST
45197: LIST
45198: LIST
45199: LIST
45200: LIST
45201: LIST
45202: LIST
45203: LIST
45204: LIST
45205: LIST
45206: LIST
45207: ST_TO_ADDR
// fFactory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
45208: LD_ADDR_VAR 0 31
45212: PUSH
45213: LD_INT 3
45215: PUSH
45216: LD_INT 2
45218: PUSH
45219: EMPTY
45220: LIST
45221: LIST
45222: PUSH
45223: LD_INT 3
45225: PUSH
45226: LD_INT 3
45228: PUSH
45229: EMPTY
45230: LIST
45231: LIST
45232: PUSH
45233: LD_INT 2
45235: PUSH
45236: LD_INT 3
45238: PUSH
45239: EMPTY
45240: LIST
45241: LIST
45242: PUSH
45243: LD_INT 4
45245: PUSH
45246: LD_INT 3
45248: PUSH
45249: EMPTY
45250: LIST
45251: LIST
45252: PUSH
45253: LD_INT 4
45255: PUSH
45256: LD_INT 4
45258: PUSH
45259: EMPTY
45260: LIST
45261: LIST
45262: PUSH
45263: LD_INT 3
45265: PUSH
45266: LD_INT 4
45268: PUSH
45269: EMPTY
45270: LIST
45271: LIST
45272: PUSH
45273: LD_INT 5
45275: PUSH
45276: LD_INT 4
45278: PUSH
45279: EMPTY
45280: LIST
45281: LIST
45282: PUSH
45283: LD_INT 5
45285: PUSH
45286: LD_INT 5
45288: PUSH
45289: EMPTY
45290: LIST
45291: LIST
45292: PUSH
45293: LD_INT 4
45295: PUSH
45296: LD_INT 5
45298: PUSH
45299: EMPTY
45300: LIST
45301: LIST
45302: PUSH
45303: LD_INT 6
45305: PUSH
45306: LD_INT 5
45308: PUSH
45309: EMPTY
45310: LIST
45311: LIST
45312: PUSH
45313: LD_INT 6
45315: PUSH
45316: LD_INT 6
45318: PUSH
45319: EMPTY
45320: LIST
45321: LIST
45322: PUSH
45323: LD_INT 5
45325: PUSH
45326: LD_INT 6
45328: PUSH
45329: EMPTY
45330: LIST
45331: LIST
45332: PUSH
45333: EMPTY
45334: LIST
45335: LIST
45336: LIST
45337: LIST
45338: LIST
45339: LIST
45340: LIST
45341: LIST
45342: LIST
45343: LIST
45344: LIST
45345: LIST
45346: ST_TO_ADDR
// fFactory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
45347: LD_ADDR_VAR 0 32
45351: PUSH
45352: LD_INT 1
45354: PUSH
45355: LD_INT 3
45357: PUSH
45358: EMPTY
45359: LIST
45360: LIST
45361: PUSH
45362: LD_INT 0
45364: PUSH
45365: LD_INT 3
45367: PUSH
45368: EMPTY
45369: LIST
45370: LIST
45371: PUSH
45372: LD_INT 1
45374: NEG
45375: PUSH
45376: LD_INT 2
45378: PUSH
45379: EMPTY
45380: LIST
45381: LIST
45382: PUSH
45383: LD_INT 1
45385: PUSH
45386: LD_INT 4
45388: PUSH
45389: EMPTY
45390: LIST
45391: LIST
45392: PUSH
45393: LD_INT 0
45395: PUSH
45396: LD_INT 4
45398: PUSH
45399: EMPTY
45400: LIST
45401: LIST
45402: PUSH
45403: LD_INT 1
45405: NEG
45406: PUSH
45407: LD_INT 3
45409: PUSH
45410: EMPTY
45411: LIST
45412: LIST
45413: PUSH
45414: LD_INT 1
45416: PUSH
45417: LD_INT 5
45419: PUSH
45420: EMPTY
45421: LIST
45422: LIST
45423: PUSH
45424: LD_INT 0
45426: PUSH
45427: LD_INT 5
45429: PUSH
45430: EMPTY
45431: LIST
45432: LIST
45433: PUSH
45434: LD_INT 1
45436: NEG
45437: PUSH
45438: LD_INT 4
45440: PUSH
45441: EMPTY
45442: LIST
45443: LIST
45444: PUSH
45445: LD_INT 1
45447: PUSH
45448: LD_INT 6
45450: PUSH
45451: EMPTY
45452: LIST
45453: LIST
45454: PUSH
45455: LD_INT 0
45457: PUSH
45458: LD_INT 6
45460: PUSH
45461: EMPTY
45462: LIST
45463: LIST
45464: PUSH
45465: LD_INT 1
45467: NEG
45468: PUSH
45469: LD_INT 5
45471: PUSH
45472: EMPTY
45473: LIST
45474: LIST
45475: PUSH
45476: EMPTY
45477: LIST
45478: LIST
45479: LIST
45480: LIST
45481: LIST
45482: LIST
45483: LIST
45484: LIST
45485: LIST
45486: LIST
45487: LIST
45488: LIST
45489: ST_TO_ADDR
// fFactory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
45490: LD_ADDR_VAR 0 33
45494: PUSH
45495: LD_INT 2
45497: NEG
45498: PUSH
45499: LD_INT 1
45501: PUSH
45502: EMPTY
45503: LIST
45504: LIST
45505: PUSH
45506: LD_INT 3
45508: NEG
45509: PUSH
45510: LD_INT 0
45512: PUSH
45513: EMPTY
45514: LIST
45515: LIST
45516: PUSH
45517: LD_INT 3
45519: NEG
45520: PUSH
45521: LD_INT 1
45523: NEG
45524: PUSH
45525: EMPTY
45526: LIST
45527: LIST
45528: PUSH
45529: LD_INT 3
45531: NEG
45532: PUSH
45533: LD_INT 1
45535: PUSH
45536: EMPTY
45537: LIST
45538: LIST
45539: PUSH
45540: LD_INT 4
45542: NEG
45543: PUSH
45544: LD_INT 0
45546: PUSH
45547: EMPTY
45548: LIST
45549: LIST
45550: PUSH
45551: LD_INT 4
45553: NEG
45554: PUSH
45555: LD_INT 1
45557: NEG
45558: PUSH
45559: EMPTY
45560: LIST
45561: LIST
45562: PUSH
45563: LD_INT 4
45565: NEG
45566: PUSH
45567: LD_INT 1
45569: PUSH
45570: EMPTY
45571: LIST
45572: LIST
45573: PUSH
45574: LD_INT 5
45576: NEG
45577: PUSH
45578: LD_INT 0
45580: PUSH
45581: EMPTY
45582: LIST
45583: LIST
45584: PUSH
45585: LD_INT 5
45587: NEG
45588: PUSH
45589: LD_INT 1
45591: NEG
45592: PUSH
45593: EMPTY
45594: LIST
45595: LIST
45596: PUSH
45597: LD_INT 5
45599: NEG
45600: PUSH
45601: LD_INT 1
45603: PUSH
45604: EMPTY
45605: LIST
45606: LIST
45607: PUSH
45608: LD_INT 6
45610: NEG
45611: PUSH
45612: LD_INT 0
45614: PUSH
45615: EMPTY
45616: LIST
45617: LIST
45618: PUSH
45619: LD_INT 6
45621: NEG
45622: PUSH
45623: LD_INT 1
45625: NEG
45626: PUSH
45627: EMPTY
45628: LIST
45629: LIST
45630: PUSH
45631: EMPTY
45632: LIST
45633: LIST
45634: LIST
45635: LIST
45636: LIST
45637: LIST
45638: LIST
45639: LIST
45640: LIST
45641: LIST
45642: LIST
45643: LIST
45644: ST_TO_ADDR
// fFactory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
45645: LD_ADDR_VAR 0 34
45649: PUSH
45650: LD_INT 2
45652: NEG
45653: PUSH
45654: LD_INT 3
45656: NEG
45657: PUSH
45658: EMPTY
45659: LIST
45660: LIST
45661: PUSH
45662: LD_INT 3
45664: NEG
45665: PUSH
45666: LD_INT 2
45668: NEG
45669: PUSH
45670: EMPTY
45671: LIST
45672: LIST
45673: PUSH
45674: LD_INT 3
45676: NEG
45677: PUSH
45678: LD_INT 3
45680: NEG
45681: PUSH
45682: EMPTY
45683: LIST
45684: LIST
45685: PUSH
45686: LD_INT 3
45688: NEG
45689: PUSH
45690: LD_INT 4
45692: NEG
45693: PUSH
45694: EMPTY
45695: LIST
45696: LIST
45697: PUSH
45698: LD_INT 4
45700: NEG
45701: PUSH
45702: LD_INT 3
45704: NEG
45705: PUSH
45706: EMPTY
45707: LIST
45708: LIST
45709: PUSH
45710: LD_INT 4
45712: NEG
45713: PUSH
45714: LD_INT 4
45716: NEG
45717: PUSH
45718: EMPTY
45719: LIST
45720: LIST
45721: PUSH
45722: LD_INT 4
45724: NEG
45725: PUSH
45726: LD_INT 5
45728: NEG
45729: PUSH
45730: EMPTY
45731: LIST
45732: LIST
45733: PUSH
45734: LD_INT 5
45736: NEG
45737: PUSH
45738: LD_INT 4
45740: NEG
45741: PUSH
45742: EMPTY
45743: LIST
45744: LIST
45745: PUSH
45746: LD_INT 5
45748: NEG
45749: PUSH
45750: LD_INT 5
45752: NEG
45753: PUSH
45754: EMPTY
45755: LIST
45756: LIST
45757: PUSH
45758: LD_INT 5
45760: NEG
45761: PUSH
45762: LD_INT 6
45764: NEG
45765: PUSH
45766: EMPTY
45767: LIST
45768: LIST
45769: PUSH
45770: LD_INT 6
45772: NEG
45773: PUSH
45774: LD_INT 5
45776: NEG
45777: PUSH
45778: EMPTY
45779: LIST
45780: LIST
45781: PUSH
45782: LD_INT 6
45784: NEG
45785: PUSH
45786: LD_INT 6
45788: NEG
45789: PUSH
45790: EMPTY
45791: LIST
45792: LIST
45793: PUSH
45794: EMPTY
45795: LIST
45796: LIST
45797: LIST
45798: LIST
45799: LIST
45800: LIST
45801: LIST
45802: LIST
45803: LIST
45804: LIST
45805: LIST
45806: LIST
45807: ST_TO_ADDR
// fLab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
45808: LD_ADDR_VAR 0 41
45812: PUSH
45813: LD_INT 0
45815: PUSH
45816: LD_INT 2
45818: NEG
45819: PUSH
45820: EMPTY
45821: LIST
45822: LIST
45823: PUSH
45824: LD_INT 1
45826: NEG
45827: PUSH
45828: LD_INT 3
45830: NEG
45831: PUSH
45832: EMPTY
45833: LIST
45834: LIST
45835: PUSH
45836: LD_INT 1
45838: PUSH
45839: LD_INT 2
45841: NEG
45842: PUSH
45843: EMPTY
45844: LIST
45845: LIST
45846: PUSH
45847: EMPTY
45848: LIST
45849: LIST
45850: LIST
45851: ST_TO_ADDR
// fLab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
45852: LD_ADDR_VAR 0 42
45856: PUSH
45857: LD_INT 2
45859: PUSH
45860: LD_INT 0
45862: PUSH
45863: EMPTY
45864: LIST
45865: LIST
45866: PUSH
45867: LD_INT 2
45869: PUSH
45870: LD_INT 1
45872: NEG
45873: PUSH
45874: EMPTY
45875: LIST
45876: LIST
45877: PUSH
45878: LD_INT 3
45880: PUSH
45881: LD_INT 1
45883: PUSH
45884: EMPTY
45885: LIST
45886: LIST
45887: PUSH
45888: EMPTY
45889: LIST
45890: LIST
45891: LIST
45892: ST_TO_ADDR
// fLab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
45893: LD_ADDR_VAR 0 43
45897: PUSH
45898: LD_INT 2
45900: PUSH
45901: LD_INT 2
45903: PUSH
45904: EMPTY
45905: LIST
45906: LIST
45907: PUSH
45908: LD_INT 3
45910: PUSH
45911: LD_INT 2
45913: PUSH
45914: EMPTY
45915: LIST
45916: LIST
45917: PUSH
45918: LD_INT 2
45920: PUSH
45921: LD_INT 3
45923: PUSH
45924: EMPTY
45925: LIST
45926: LIST
45927: PUSH
45928: EMPTY
45929: LIST
45930: LIST
45931: LIST
45932: ST_TO_ADDR
// fLab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
45933: LD_ADDR_VAR 0 44
45937: PUSH
45938: LD_INT 0
45940: PUSH
45941: LD_INT 2
45943: PUSH
45944: EMPTY
45945: LIST
45946: LIST
45947: PUSH
45948: LD_INT 1
45950: PUSH
45951: LD_INT 3
45953: PUSH
45954: EMPTY
45955: LIST
45956: LIST
45957: PUSH
45958: LD_INT 1
45960: NEG
45961: PUSH
45962: LD_INT 2
45964: PUSH
45965: EMPTY
45966: LIST
45967: LIST
45968: PUSH
45969: EMPTY
45970: LIST
45971: LIST
45972: LIST
45973: ST_TO_ADDR
// fLab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
45974: LD_ADDR_VAR 0 45
45978: PUSH
45979: LD_INT 2
45981: NEG
45982: PUSH
45983: LD_INT 0
45985: PUSH
45986: EMPTY
45987: LIST
45988: LIST
45989: PUSH
45990: LD_INT 2
45992: NEG
45993: PUSH
45994: LD_INT 1
45996: PUSH
45997: EMPTY
45998: LIST
45999: LIST
46000: PUSH
46001: LD_INT 3
46003: NEG
46004: PUSH
46005: LD_INT 1
46007: NEG
46008: PUSH
46009: EMPTY
46010: LIST
46011: LIST
46012: PUSH
46013: EMPTY
46014: LIST
46015: LIST
46016: LIST
46017: ST_TO_ADDR
// fLab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
46018: LD_ADDR_VAR 0 46
46022: PUSH
46023: LD_INT 2
46025: NEG
46026: PUSH
46027: LD_INT 2
46029: NEG
46030: PUSH
46031: EMPTY
46032: LIST
46033: LIST
46034: PUSH
46035: LD_INT 2
46037: NEG
46038: PUSH
46039: LD_INT 3
46041: NEG
46042: PUSH
46043: EMPTY
46044: LIST
46045: LIST
46046: PUSH
46047: LD_INT 3
46049: NEG
46050: PUSH
46051: LD_INT 2
46053: NEG
46054: PUSH
46055: EMPTY
46056: LIST
46057: LIST
46058: PUSH
46059: EMPTY
46060: LIST
46061: LIST
46062: LIST
46063: ST_TO_ADDR
// fControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
46064: LD_ADDR_VAR 0 47
46068: PUSH
46069: LD_INT 2
46071: NEG
46072: PUSH
46073: LD_INT 3
46075: NEG
46076: PUSH
46077: EMPTY
46078: LIST
46079: LIST
46080: PUSH
46081: LD_INT 1
46083: NEG
46084: PUSH
46085: LD_INT 3
46087: NEG
46088: PUSH
46089: EMPTY
46090: LIST
46091: LIST
46092: PUSH
46093: EMPTY
46094: LIST
46095: LIST
46096: ST_TO_ADDR
// fControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
46097: LD_ADDR_VAR 0 48
46101: PUSH
46102: LD_INT 1
46104: PUSH
46105: LD_INT 2
46107: NEG
46108: PUSH
46109: EMPTY
46110: LIST
46111: LIST
46112: PUSH
46113: LD_INT 2
46115: PUSH
46116: LD_INT 1
46118: NEG
46119: PUSH
46120: EMPTY
46121: LIST
46122: LIST
46123: PUSH
46124: EMPTY
46125: LIST
46126: LIST
46127: ST_TO_ADDR
// fControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
46128: LD_ADDR_VAR 0 49
46132: PUSH
46133: LD_INT 3
46135: PUSH
46136: LD_INT 1
46138: PUSH
46139: EMPTY
46140: LIST
46141: LIST
46142: PUSH
46143: LD_INT 3
46145: PUSH
46146: LD_INT 2
46148: PUSH
46149: EMPTY
46150: LIST
46151: LIST
46152: PUSH
46153: EMPTY
46154: LIST
46155: LIST
46156: ST_TO_ADDR
// fControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
46157: LD_ADDR_VAR 0 50
46161: PUSH
46162: LD_INT 2
46164: PUSH
46165: LD_INT 3
46167: PUSH
46168: EMPTY
46169: LIST
46170: LIST
46171: PUSH
46172: LD_INT 1
46174: PUSH
46175: LD_INT 3
46177: PUSH
46178: EMPTY
46179: LIST
46180: LIST
46181: PUSH
46182: EMPTY
46183: LIST
46184: LIST
46185: ST_TO_ADDR
// fControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
46186: LD_ADDR_VAR 0 51
46190: PUSH
46191: LD_INT 1
46193: NEG
46194: PUSH
46195: LD_INT 2
46197: PUSH
46198: EMPTY
46199: LIST
46200: LIST
46201: PUSH
46202: LD_INT 2
46204: NEG
46205: PUSH
46206: LD_INT 1
46208: PUSH
46209: EMPTY
46210: LIST
46211: LIST
46212: PUSH
46213: EMPTY
46214: LIST
46215: LIST
46216: ST_TO_ADDR
// fControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
46217: LD_ADDR_VAR 0 52
46221: PUSH
46222: LD_INT 3
46224: NEG
46225: PUSH
46226: LD_INT 1
46228: NEG
46229: PUSH
46230: EMPTY
46231: LIST
46232: LIST
46233: PUSH
46234: LD_INT 3
46236: NEG
46237: PUSH
46238: LD_INT 2
46240: NEG
46241: PUSH
46242: EMPTY
46243: LIST
46244: LIST
46245: PUSH
46246: EMPTY
46247: LIST
46248: LIST
46249: ST_TO_ADDR
// fBarracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
46250: LD_ADDR_VAR 0 53
46254: PUSH
46255: LD_INT 1
46257: NEG
46258: PUSH
46259: LD_INT 3
46261: NEG
46262: PUSH
46263: EMPTY
46264: LIST
46265: LIST
46266: PUSH
46267: LD_INT 0
46269: PUSH
46270: LD_INT 3
46272: NEG
46273: PUSH
46274: EMPTY
46275: LIST
46276: LIST
46277: PUSH
46278: LD_INT 1
46280: PUSH
46281: LD_INT 2
46283: NEG
46284: PUSH
46285: EMPTY
46286: LIST
46287: LIST
46288: PUSH
46289: EMPTY
46290: LIST
46291: LIST
46292: LIST
46293: ST_TO_ADDR
// fBarracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
46294: LD_ADDR_VAR 0 54
46298: PUSH
46299: LD_INT 2
46301: PUSH
46302: LD_INT 1
46304: NEG
46305: PUSH
46306: EMPTY
46307: LIST
46308: LIST
46309: PUSH
46310: LD_INT 3
46312: PUSH
46313: LD_INT 0
46315: PUSH
46316: EMPTY
46317: LIST
46318: LIST
46319: PUSH
46320: LD_INT 3
46322: PUSH
46323: LD_INT 1
46325: PUSH
46326: EMPTY
46327: LIST
46328: LIST
46329: PUSH
46330: EMPTY
46331: LIST
46332: LIST
46333: LIST
46334: ST_TO_ADDR
// fBarracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
46335: LD_ADDR_VAR 0 55
46339: PUSH
46340: LD_INT 3
46342: PUSH
46343: LD_INT 2
46345: PUSH
46346: EMPTY
46347: LIST
46348: LIST
46349: PUSH
46350: LD_INT 3
46352: PUSH
46353: LD_INT 3
46355: PUSH
46356: EMPTY
46357: LIST
46358: LIST
46359: PUSH
46360: LD_INT 2
46362: PUSH
46363: LD_INT 3
46365: PUSH
46366: EMPTY
46367: LIST
46368: LIST
46369: PUSH
46370: EMPTY
46371: LIST
46372: LIST
46373: LIST
46374: ST_TO_ADDR
// fBarracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
46375: LD_ADDR_VAR 0 56
46379: PUSH
46380: LD_INT 1
46382: PUSH
46383: LD_INT 3
46385: PUSH
46386: EMPTY
46387: LIST
46388: LIST
46389: PUSH
46390: LD_INT 0
46392: PUSH
46393: LD_INT 3
46395: PUSH
46396: EMPTY
46397: LIST
46398: LIST
46399: PUSH
46400: LD_INT 1
46402: NEG
46403: PUSH
46404: LD_INT 2
46406: PUSH
46407: EMPTY
46408: LIST
46409: LIST
46410: PUSH
46411: EMPTY
46412: LIST
46413: LIST
46414: LIST
46415: ST_TO_ADDR
// fBarracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
46416: LD_ADDR_VAR 0 57
46420: PUSH
46421: LD_INT 2
46423: NEG
46424: PUSH
46425: LD_INT 1
46427: PUSH
46428: EMPTY
46429: LIST
46430: LIST
46431: PUSH
46432: LD_INT 3
46434: NEG
46435: PUSH
46436: LD_INT 0
46438: PUSH
46439: EMPTY
46440: LIST
46441: LIST
46442: PUSH
46443: LD_INT 3
46445: NEG
46446: PUSH
46447: LD_INT 1
46449: NEG
46450: PUSH
46451: EMPTY
46452: LIST
46453: LIST
46454: PUSH
46455: EMPTY
46456: LIST
46457: LIST
46458: LIST
46459: ST_TO_ADDR
// fBarracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
46460: LD_ADDR_VAR 0 58
46464: PUSH
46465: LD_INT 2
46467: NEG
46468: PUSH
46469: LD_INT 3
46471: NEG
46472: PUSH
46473: EMPTY
46474: LIST
46475: LIST
46476: PUSH
46477: LD_INT 3
46479: NEG
46480: PUSH
46481: LD_INT 2
46483: NEG
46484: PUSH
46485: EMPTY
46486: LIST
46487: LIST
46488: PUSH
46489: LD_INT 3
46491: NEG
46492: PUSH
46493: LD_INT 3
46495: NEG
46496: PUSH
46497: EMPTY
46498: LIST
46499: LIST
46500: PUSH
46501: EMPTY
46502: LIST
46503: LIST
46504: LIST
46505: ST_TO_ADDR
// fBunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
46506: LD_ADDR_VAR 0 59
46510: PUSH
46511: LD_INT 1
46513: NEG
46514: PUSH
46515: LD_INT 2
46517: NEG
46518: PUSH
46519: EMPTY
46520: LIST
46521: LIST
46522: PUSH
46523: LD_INT 0
46525: PUSH
46526: LD_INT 2
46528: NEG
46529: PUSH
46530: EMPTY
46531: LIST
46532: LIST
46533: PUSH
46534: LD_INT 1
46536: PUSH
46537: LD_INT 1
46539: NEG
46540: PUSH
46541: EMPTY
46542: LIST
46543: LIST
46544: PUSH
46545: EMPTY
46546: LIST
46547: LIST
46548: LIST
46549: ST_TO_ADDR
// fBunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
46550: LD_ADDR_VAR 0 60
46554: PUSH
46555: LD_INT 1
46557: PUSH
46558: LD_INT 1
46560: NEG
46561: PUSH
46562: EMPTY
46563: LIST
46564: LIST
46565: PUSH
46566: LD_INT 2
46568: PUSH
46569: LD_INT 0
46571: PUSH
46572: EMPTY
46573: LIST
46574: LIST
46575: PUSH
46576: LD_INT 2
46578: PUSH
46579: LD_INT 1
46581: PUSH
46582: EMPTY
46583: LIST
46584: LIST
46585: PUSH
46586: EMPTY
46587: LIST
46588: LIST
46589: LIST
46590: ST_TO_ADDR
// fBunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
46591: LD_ADDR_VAR 0 61
46595: PUSH
46596: LD_INT 2
46598: PUSH
46599: LD_INT 1
46601: PUSH
46602: EMPTY
46603: LIST
46604: LIST
46605: PUSH
46606: LD_INT 2
46608: PUSH
46609: LD_INT 2
46611: PUSH
46612: EMPTY
46613: LIST
46614: LIST
46615: PUSH
46616: LD_INT 1
46618: PUSH
46619: LD_INT 2
46621: PUSH
46622: EMPTY
46623: LIST
46624: LIST
46625: PUSH
46626: EMPTY
46627: LIST
46628: LIST
46629: LIST
46630: ST_TO_ADDR
// fBunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
46631: LD_ADDR_VAR 0 62
46635: PUSH
46636: LD_INT 1
46638: PUSH
46639: LD_INT 2
46641: PUSH
46642: EMPTY
46643: LIST
46644: LIST
46645: PUSH
46646: LD_INT 0
46648: PUSH
46649: LD_INT 2
46651: PUSH
46652: EMPTY
46653: LIST
46654: LIST
46655: PUSH
46656: LD_INT 1
46658: NEG
46659: PUSH
46660: LD_INT 1
46662: PUSH
46663: EMPTY
46664: LIST
46665: LIST
46666: PUSH
46667: EMPTY
46668: LIST
46669: LIST
46670: LIST
46671: ST_TO_ADDR
// fBunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
46672: LD_ADDR_VAR 0 63
46676: PUSH
46677: LD_INT 1
46679: NEG
46680: PUSH
46681: LD_INT 1
46683: PUSH
46684: EMPTY
46685: LIST
46686: LIST
46687: PUSH
46688: LD_INT 2
46690: NEG
46691: PUSH
46692: LD_INT 0
46694: PUSH
46695: EMPTY
46696: LIST
46697: LIST
46698: PUSH
46699: LD_INT 2
46701: NEG
46702: PUSH
46703: LD_INT 1
46705: NEG
46706: PUSH
46707: EMPTY
46708: LIST
46709: LIST
46710: PUSH
46711: EMPTY
46712: LIST
46713: LIST
46714: LIST
46715: ST_TO_ADDR
// fBunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
46716: LD_ADDR_VAR 0 64
46720: PUSH
46721: LD_INT 1
46723: NEG
46724: PUSH
46725: LD_INT 2
46727: NEG
46728: PUSH
46729: EMPTY
46730: LIST
46731: LIST
46732: PUSH
46733: LD_INT 2
46735: NEG
46736: PUSH
46737: LD_INT 1
46739: NEG
46740: PUSH
46741: EMPTY
46742: LIST
46743: LIST
46744: PUSH
46745: LD_INT 2
46747: NEG
46748: PUSH
46749: LD_INT 2
46751: NEG
46752: PUSH
46753: EMPTY
46754: LIST
46755: LIST
46756: PUSH
46757: EMPTY
46758: LIST
46759: LIST
46760: LIST
46761: ST_TO_ADDR
// end ; 2 :
46762: GO 50028
46764: LD_INT 2
46766: DOUBLE
46767: EQUAL
46768: IFTRUE 46772
46770: GO 50027
46772: POP
// begin fFactory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
46773: LD_ADDR_VAR 0 29
46777: PUSH
46778: LD_INT 4
46780: PUSH
46781: LD_INT 0
46783: PUSH
46784: EMPTY
46785: LIST
46786: LIST
46787: PUSH
46788: LD_INT 4
46790: PUSH
46791: LD_INT 1
46793: NEG
46794: PUSH
46795: EMPTY
46796: LIST
46797: LIST
46798: PUSH
46799: LD_INT 5
46801: PUSH
46802: LD_INT 0
46804: PUSH
46805: EMPTY
46806: LIST
46807: LIST
46808: PUSH
46809: LD_INT 5
46811: PUSH
46812: LD_INT 1
46814: PUSH
46815: EMPTY
46816: LIST
46817: LIST
46818: PUSH
46819: LD_INT 4
46821: PUSH
46822: LD_INT 1
46824: PUSH
46825: EMPTY
46826: LIST
46827: LIST
46828: PUSH
46829: LD_INT 3
46831: PUSH
46832: LD_INT 0
46834: PUSH
46835: EMPTY
46836: LIST
46837: LIST
46838: PUSH
46839: LD_INT 3
46841: PUSH
46842: LD_INT 1
46844: NEG
46845: PUSH
46846: EMPTY
46847: LIST
46848: LIST
46849: PUSH
46850: LD_INT 3
46852: PUSH
46853: LD_INT 2
46855: NEG
46856: PUSH
46857: EMPTY
46858: LIST
46859: LIST
46860: PUSH
46861: LD_INT 5
46863: PUSH
46864: LD_INT 2
46866: PUSH
46867: EMPTY
46868: LIST
46869: LIST
46870: PUSH
46871: LD_INT 3
46873: PUSH
46874: LD_INT 3
46876: PUSH
46877: EMPTY
46878: LIST
46879: LIST
46880: PUSH
46881: LD_INT 3
46883: PUSH
46884: LD_INT 2
46886: PUSH
46887: EMPTY
46888: LIST
46889: LIST
46890: PUSH
46891: LD_INT 4
46893: PUSH
46894: LD_INT 3
46896: PUSH
46897: EMPTY
46898: LIST
46899: LIST
46900: PUSH
46901: LD_INT 4
46903: PUSH
46904: LD_INT 4
46906: PUSH
46907: EMPTY
46908: LIST
46909: LIST
46910: PUSH
46911: LD_INT 3
46913: PUSH
46914: LD_INT 4
46916: PUSH
46917: EMPTY
46918: LIST
46919: LIST
46920: PUSH
46921: LD_INT 2
46923: PUSH
46924: LD_INT 3
46926: PUSH
46927: EMPTY
46928: LIST
46929: LIST
46930: PUSH
46931: LD_INT 2
46933: PUSH
46934: LD_INT 2
46936: PUSH
46937: EMPTY
46938: LIST
46939: LIST
46940: PUSH
46941: LD_INT 4
46943: PUSH
46944: LD_INT 2
46946: PUSH
46947: EMPTY
46948: LIST
46949: LIST
46950: PUSH
46951: LD_INT 2
46953: PUSH
46954: LD_INT 4
46956: PUSH
46957: EMPTY
46958: LIST
46959: LIST
46960: PUSH
46961: LD_INT 0
46963: PUSH
46964: LD_INT 4
46966: PUSH
46967: EMPTY
46968: LIST
46969: LIST
46970: PUSH
46971: LD_INT 0
46973: PUSH
46974: LD_INT 3
46976: PUSH
46977: EMPTY
46978: LIST
46979: LIST
46980: PUSH
46981: LD_INT 1
46983: PUSH
46984: LD_INT 4
46986: PUSH
46987: EMPTY
46988: LIST
46989: LIST
46990: PUSH
46991: LD_INT 1
46993: PUSH
46994: LD_INT 5
46996: PUSH
46997: EMPTY
46998: LIST
46999: LIST
47000: PUSH
47001: LD_INT 0
47003: PUSH
47004: LD_INT 5
47006: PUSH
47007: EMPTY
47008: LIST
47009: LIST
47010: PUSH
47011: LD_INT 1
47013: NEG
47014: PUSH
47015: LD_INT 4
47017: PUSH
47018: EMPTY
47019: LIST
47020: LIST
47021: PUSH
47022: LD_INT 1
47024: NEG
47025: PUSH
47026: LD_INT 3
47028: PUSH
47029: EMPTY
47030: LIST
47031: LIST
47032: PUSH
47033: LD_INT 2
47035: PUSH
47036: LD_INT 5
47038: PUSH
47039: EMPTY
47040: LIST
47041: LIST
47042: PUSH
47043: LD_INT 2
47045: NEG
47046: PUSH
47047: LD_INT 3
47049: PUSH
47050: EMPTY
47051: LIST
47052: LIST
47053: PUSH
47054: LD_INT 3
47056: NEG
47057: PUSH
47058: LD_INT 0
47060: PUSH
47061: EMPTY
47062: LIST
47063: LIST
47064: PUSH
47065: LD_INT 3
47067: NEG
47068: PUSH
47069: LD_INT 1
47071: NEG
47072: PUSH
47073: EMPTY
47074: LIST
47075: LIST
47076: PUSH
47077: LD_INT 2
47079: NEG
47080: PUSH
47081: LD_INT 0
47083: PUSH
47084: EMPTY
47085: LIST
47086: LIST
47087: PUSH
47088: LD_INT 2
47090: NEG
47091: PUSH
47092: LD_INT 1
47094: PUSH
47095: EMPTY
47096: LIST
47097: LIST
47098: PUSH
47099: LD_INT 3
47101: NEG
47102: PUSH
47103: LD_INT 1
47105: PUSH
47106: EMPTY
47107: LIST
47108: LIST
47109: PUSH
47110: LD_INT 4
47112: NEG
47113: PUSH
47114: LD_INT 0
47116: PUSH
47117: EMPTY
47118: LIST
47119: LIST
47120: PUSH
47121: LD_INT 4
47123: NEG
47124: PUSH
47125: LD_INT 1
47127: NEG
47128: PUSH
47129: EMPTY
47130: LIST
47131: LIST
47132: PUSH
47133: LD_INT 4
47135: NEG
47136: PUSH
47137: LD_INT 2
47139: NEG
47140: PUSH
47141: EMPTY
47142: LIST
47143: LIST
47144: PUSH
47145: LD_INT 2
47147: NEG
47148: PUSH
47149: LD_INT 2
47151: PUSH
47152: EMPTY
47153: LIST
47154: LIST
47155: PUSH
47156: LD_INT 4
47158: NEG
47159: PUSH
47160: LD_INT 4
47162: NEG
47163: PUSH
47164: EMPTY
47165: LIST
47166: LIST
47167: PUSH
47168: LD_INT 4
47170: NEG
47171: PUSH
47172: LD_INT 5
47174: NEG
47175: PUSH
47176: EMPTY
47177: LIST
47178: LIST
47179: PUSH
47180: LD_INT 3
47182: NEG
47183: PUSH
47184: LD_INT 4
47186: NEG
47187: PUSH
47188: EMPTY
47189: LIST
47190: LIST
47191: PUSH
47192: LD_INT 3
47194: NEG
47195: PUSH
47196: LD_INT 3
47198: NEG
47199: PUSH
47200: EMPTY
47201: LIST
47202: LIST
47203: PUSH
47204: LD_INT 4
47206: NEG
47207: PUSH
47208: LD_INT 3
47210: NEG
47211: PUSH
47212: EMPTY
47213: LIST
47214: LIST
47215: PUSH
47216: LD_INT 5
47218: NEG
47219: PUSH
47220: LD_INT 4
47222: NEG
47223: PUSH
47224: EMPTY
47225: LIST
47226: LIST
47227: PUSH
47228: LD_INT 5
47230: NEG
47231: PUSH
47232: LD_INT 5
47234: NEG
47235: PUSH
47236: EMPTY
47237: LIST
47238: LIST
47239: PUSH
47240: LD_INT 3
47242: NEG
47243: PUSH
47244: LD_INT 5
47246: NEG
47247: PUSH
47248: EMPTY
47249: LIST
47250: LIST
47251: PUSH
47252: LD_INT 5
47254: NEG
47255: PUSH
47256: LD_INT 3
47258: NEG
47259: PUSH
47260: EMPTY
47261: LIST
47262: LIST
47263: PUSH
47264: EMPTY
47265: LIST
47266: LIST
47267: LIST
47268: LIST
47269: LIST
47270: LIST
47271: LIST
47272: LIST
47273: LIST
47274: LIST
47275: LIST
47276: LIST
47277: LIST
47278: LIST
47279: LIST
47280: LIST
47281: LIST
47282: LIST
47283: LIST
47284: LIST
47285: LIST
47286: LIST
47287: LIST
47288: LIST
47289: LIST
47290: LIST
47291: LIST
47292: LIST
47293: LIST
47294: LIST
47295: LIST
47296: LIST
47297: LIST
47298: LIST
47299: LIST
47300: LIST
47301: LIST
47302: LIST
47303: LIST
47304: LIST
47305: LIST
47306: LIST
47307: LIST
47308: LIST
47309: LIST
47310: ST_TO_ADDR
// fFactory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
47311: LD_ADDR_VAR 0 30
47315: PUSH
47316: LD_INT 4
47318: PUSH
47319: LD_INT 4
47321: PUSH
47322: EMPTY
47323: LIST
47324: LIST
47325: PUSH
47326: LD_INT 4
47328: PUSH
47329: LD_INT 3
47331: PUSH
47332: EMPTY
47333: LIST
47334: LIST
47335: PUSH
47336: LD_INT 5
47338: PUSH
47339: LD_INT 4
47341: PUSH
47342: EMPTY
47343: LIST
47344: LIST
47345: PUSH
47346: LD_INT 5
47348: PUSH
47349: LD_INT 5
47351: PUSH
47352: EMPTY
47353: LIST
47354: LIST
47355: PUSH
47356: LD_INT 4
47358: PUSH
47359: LD_INT 5
47361: PUSH
47362: EMPTY
47363: LIST
47364: LIST
47365: PUSH
47366: LD_INT 3
47368: PUSH
47369: LD_INT 4
47371: PUSH
47372: EMPTY
47373: LIST
47374: LIST
47375: PUSH
47376: LD_INT 3
47378: PUSH
47379: LD_INT 3
47381: PUSH
47382: EMPTY
47383: LIST
47384: LIST
47385: PUSH
47386: LD_INT 5
47388: PUSH
47389: LD_INT 3
47391: PUSH
47392: EMPTY
47393: LIST
47394: LIST
47395: PUSH
47396: LD_INT 3
47398: PUSH
47399: LD_INT 5
47401: PUSH
47402: EMPTY
47403: LIST
47404: LIST
47405: PUSH
47406: LD_INT 0
47408: PUSH
47409: LD_INT 3
47411: PUSH
47412: EMPTY
47413: LIST
47414: LIST
47415: PUSH
47416: LD_INT 0
47418: PUSH
47419: LD_INT 2
47421: PUSH
47422: EMPTY
47423: LIST
47424: LIST
47425: PUSH
47426: LD_INT 1
47428: PUSH
47429: LD_INT 3
47431: PUSH
47432: EMPTY
47433: LIST
47434: LIST
47435: PUSH
47436: LD_INT 1
47438: PUSH
47439: LD_INT 4
47441: PUSH
47442: EMPTY
47443: LIST
47444: LIST
47445: PUSH
47446: LD_INT 0
47448: PUSH
47449: LD_INT 4
47451: PUSH
47452: EMPTY
47453: LIST
47454: LIST
47455: PUSH
47456: LD_INT 1
47458: NEG
47459: PUSH
47460: LD_INT 3
47462: PUSH
47463: EMPTY
47464: LIST
47465: LIST
47466: PUSH
47467: LD_INT 1
47469: NEG
47470: PUSH
47471: LD_INT 2
47473: PUSH
47474: EMPTY
47475: LIST
47476: LIST
47477: PUSH
47478: LD_INT 2
47480: PUSH
47481: LD_INT 4
47483: PUSH
47484: EMPTY
47485: LIST
47486: LIST
47487: PUSH
47488: LD_INT 2
47490: NEG
47491: PUSH
47492: LD_INT 2
47494: PUSH
47495: EMPTY
47496: LIST
47497: LIST
47498: PUSH
47499: LD_INT 4
47501: NEG
47502: PUSH
47503: LD_INT 0
47505: PUSH
47506: EMPTY
47507: LIST
47508: LIST
47509: PUSH
47510: LD_INT 4
47512: NEG
47513: PUSH
47514: LD_INT 1
47516: NEG
47517: PUSH
47518: EMPTY
47519: LIST
47520: LIST
47521: PUSH
47522: LD_INT 3
47524: NEG
47525: PUSH
47526: LD_INT 0
47528: PUSH
47529: EMPTY
47530: LIST
47531: LIST
47532: PUSH
47533: LD_INT 3
47535: NEG
47536: PUSH
47537: LD_INT 1
47539: PUSH
47540: EMPTY
47541: LIST
47542: LIST
47543: PUSH
47544: LD_INT 4
47546: NEG
47547: PUSH
47548: LD_INT 1
47550: PUSH
47551: EMPTY
47552: LIST
47553: LIST
47554: PUSH
47555: LD_INT 5
47557: NEG
47558: PUSH
47559: LD_INT 0
47561: PUSH
47562: EMPTY
47563: LIST
47564: LIST
47565: PUSH
47566: LD_INT 5
47568: NEG
47569: PUSH
47570: LD_INT 1
47572: NEG
47573: PUSH
47574: EMPTY
47575: LIST
47576: LIST
47577: PUSH
47578: LD_INT 5
47580: NEG
47581: PUSH
47582: LD_INT 2
47584: NEG
47585: PUSH
47586: EMPTY
47587: LIST
47588: LIST
47589: PUSH
47590: LD_INT 3
47592: NEG
47593: PUSH
47594: LD_INT 2
47596: PUSH
47597: EMPTY
47598: LIST
47599: LIST
47600: PUSH
47601: LD_INT 3
47603: NEG
47604: PUSH
47605: LD_INT 3
47607: NEG
47608: PUSH
47609: EMPTY
47610: LIST
47611: LIST
47612: PUSH
47613: LD_INT 3
47615: NEG
47616: PUSH
47617: LD_INT 4
47619: NEG
47620: PUSH
47621: EMPTY
47622: LIST
47623: LIST
47624: PUSH
47625: LD_INT 2
47627: NEG
47628: PUSH
47629: LD_INT 3
47631: NEG
47632: PUSH
47633: EMPTY
47634: LIST
47635: LIST
47636: PUSH
47637: LD_INT 2
47639: NEG
47640: PUSH
47641: LD_INT 2
47643: NEG
47644: PUSH
47645: EMPTY
47646: LIST
47647: LIST
47648: PUSH
47649: LD_INT 3
47651: NEG
47652: PUSH
47653: LD_INT 2
47655: NEG
47656: PUSH
47657: EMPTY
47658: LIST
47659: LIST
47660: PUSH
47661: LD_INT 4
47663: NEG
47664: PUSH
47665: LD_INT 3
47667: NEG
47668: PUSH
47669: EMPTY
47670: LIST
47671: LIST
47672: PUSH
47673: LD_INT 4
47675: NEG
47676: PUSH
47677: LD_INT 4
47679: NEG
47680: PUSH
47681: EMPTY
47682: LIST
47683: LIST
47684: PUSH
47685: LD_INT 2
47687: NEG
47688: PUSH
47689: LD_INT 4
47691: NEG
47692: PUSH
47693: EMPTY
47694: LIST
47695: LIST
47696: PUSH
47697: LD_INT 4
47699: NEG
47700: PUSH
47701: LD_INT 2
47703: NEG
47704: PUSH
47705: EMPTY
47706: LIST
47707: LIST
47708: PUSH
47709: LD_INT 0
47711: PUSH
47712: LD_INT 4
47714: NEG
47715: PUSH
47716: EMPTY
47717: LIST
47718: LIST
47719: PUSH
47720: LD_INT 0
47722: PUSH
47723: LD_INT 5
47725: NEG
47726: PUSH
47727: EMPTY
47728: LIST
47729: LIST
47730: PUSH
47731: LD_INT 1
47733: PUSH
47734: LD_INT 4
47736: NEG
47737: PUSH
47738: EMPTY
47739: LIST
47740: LIST
47741: PUSH
47742: LD_INT 1
47744: PUSH
47745: LD_INT 3
47747: NEG
47748: PUSH
47749: EMPTY
47750: LIST
47751: LIST
47752: PUSH
47753: LD_INT 0
47755: PUSH
47756: LD_INT 3
47758: NEG
47759: PUSH
47760: EMPTY
47761: LIST
47762: LIST
47763: PUSH
47764: LD_INT 1
47766: NEG
47767: PUSH
47768: LD_INT 4
47770: NEG
47771: PUSH
47772: EMPTY
47773: LIST
47774: LIST
47775: PUSH
47776: LD_INT 1
47778: NEG
47779: PUSH
47780: LD_INT 5
47782: NEG
47783: PUSH
47784: EMPTY
47785: LIST
47786: LIST
47787: PUSH
47788: LD_INT 2
47790: PUSH
47791: LD_INT 3
47793: NEG
47794: PUSH
47795: EMPTY
47796: LIST
47797: LIST
47798: PUSH
47799: LD_INT 2
47801: NEG
47802: PUSH
47803: LD_INT 5
47805: NEG
47806: PUSH
47807: EMPTY
47808: LIST
47809: LIST
47810: PUSH
47811: EMPTY
47812: LIST
47813: LIST
47814: LIST
47815: LIST
47816: LIST
47817: LIST
47818: LIST
47819: LIST
47820: LIST
47821: LIST
47822: LIST
47823: LIST
47824: LIST
47825: LIST
47826: LIST
47827: LIST
47828: LIST
47829: LIST
47830: LIST
47831: LIST
47832: LIST
47833: LIST
47834: LIST
47835: LIST
47836: LIST
47837: LIST
47838: LIST
47839: LIST
47840: LIST
47841: LIST
47842: LIST
47843: LIST
47844: LIST
47845: LIST
47846: LIST
47847: LIST
47848: LIST
47849: LIST
47850: LIST
47851: LIST
47852: LIST
47853: LIST
47854: LIST
47855: LIST
47856: LIST
47857: ST_TO_ADDR
// fFactory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
47858: LD_ADDR_VAR 0 31
47862: PUSH
47863: LD_INT 0
47865: PUSH
47866: LD_INT 4
47868: PUSH
47869: EMPTY
47870: LIST
47871: LIST
47872: PUSH
47873: LD_INT 0
47875: PUSH
47876: LD_INT 3
47878: PUSH
47879: EMPTY
47880: LIST
47881: LIST
47882: PUSH
47883: LD_INT 1
47885: PUSH
47886: LD_INT 4
47888: PUSH
47889: EMPTY
47890: LIST
47891: LIST
47892: PUSH
47893: LD_INT 1
47895: PUSH
47896: LD_INT 5
47898: PUSH
47899: EMPTY
47900: LIST
47901: LIST
47902: PUSH
47903: LD_INT 0
47905: PUSH
47906: LD_INT 5
47908: PUSH
47909: EMPTY
47910: LIST
47911: LIST
47912: PUSH
47913: LD_INT 1
47915: NEG
47916: PUSH
47917: LD_INT 4
47919: PUSH
47920: EMPTY
47921: LIST
47922: LIST
47923: PUSH
47924: LD_INT 1
47926: NEG
47927: PUSH
47928: LD_INT 3
47930: PUSH
47931: EMPTY
47932: LIST
47933: LIST
47934: PUSH
47935: LD_INT 2
47937: PUSH
47938: LD_INT 5
47940: PUSH
47941: EMPTY
47942: LIST
47943: LIST
47944: PUSH
47945: LD_INT 2
47947: NEG
47948: PUSH
47949: LD_INT 3
47951: PUSH
47952: EMPTY
47953: LIST
47954: LIST
47955: PUSH
47956: LD_INT 3
47958: NEG
47959: PUSH
47960: LD_INT 0
47962: PUSH
47963: EMPTY
47964: LIST
47965: LIST
47966: PUSH
47967: LD_INT 3
47969: NEG
47970: PUSH
47971: LD_INT 1
47973: NEG
47974: PUSH
47975: EMPTY
47976: LIST
47977: LIST
47978: PUSH
47979: LD_INT 2
47981: NEG
47982: PUSH
47983: LD_INT 0
47985: PUSH
47986: EMPTY
47987: LIST
47988: LIST
47989: PUSH
47990: LD_INT 2
47992: NEG
47993: PUSH
47994: LD_INT 1
47996: PUSH
47997: EMPTY
47998: LIST
47999: LIST
48000: PUSH
48001: LD_INT 3
48003: NEG
48004: PUSH
48005: LD_INT 1
48007: PUSH
48008: EMPTY
48009: LIST
48010: LIST
48011: PUSH
48012: LD_INT 4
48014: NEG
48015: PUSH
48016: LD_INT 0
48018: PUSH
48019: EMPTY
48020: LIST
48021: LIST
48022: PUSH
48023: LD_INT 4
48025: NEG
48026: PUSH
48027: LD_INT 1
48029: NEG
48030: PUSH
48031: EMPTY
48032: LIST
48033: LIST
48034: PUSH
48035: LD_INT 4
48037: NEG
48038: PUSH
48039: LD_INT 2
48041: NEG
48042: PUSH
48043: EMPTY
48044: LIST
48045: LIST
48046: PUSH
48047: LD_INT 2
48049: NEG
48050: PUSH
48051: LD_INT 2
48053: PUSH
48054: EMPTY
48055: LIST
48056: LIST
48057: PUSH
48058: LD_INT 4
48060: NEG
48061: PUSH
48062: LD_INT 4
48064: NEG
48065: PUSH
48066: EMPTY
48067: LIST
48068: LIST
48069: PUSH
48070: LD_INT 4
48072: NEG
48073: PUSH
48074: LD_INT 5
48076: NEG
48077: PUSH
48078: EMPTY
48079: LIST
48080: LIST
48081: PUSH
48082: LD_INT 3
48084: NEG
48085: PUSH
48086: LD_INT 4
48088: NEG
48089: PUSH
48090: EMPTY
48091: LIST
48092: LIST
48093: PUSH
48094: LD_INT 3
48096: NEG
48097: PUSH
48098: LD_INT 3
48100: NEG
48101: PUSH
48102: EMPTY
48103: LIST
48104: LIST
48105: PUSH
48106: LD_INT 4
48108: NEG
48109: PUSH
48110: LD_INT 3
48112: NEG
48113: PUSH
48114: EMPTY
48115: LIST
48116: LIST
48117: PUSH
48118: LD_INT 5
48120: NEG
48121: PUSH
48122: LD_INT 4
48124: NEG
48125: PUSH
48126: EMPTY
48127: LIST
48128: LIST
48129: PUSH
48130: LD_INT 5
48132: NEG
48133: PUSH
48134: LD_INT 5
48136: NEG
48137: PUSH
48138: EMPTY
48139: LIST
48140: LIST
48141: PUSH
48142: LD_INT 3
48144: NEG
48145: PUSH
48146: LD_INT 5
48148: NEG
48149: PUSH
48150: EMPTY
48151: LIST
48152: LIST
48153: PUSH
48154: LD_INT 5
48156: NEG
48157: PUSH
48158: LD_INT 3
48160: NEG
48161: PUSH
48162: EMPTY
48163: LIST
48164: LIST
48165: PUSH
48166: LD_INT 0
48168: PUSH
48169: LD_INT 3
48171: NEG
48172: PUSH
48173: EMPTY
48174: LIST
48175: LIST
48176: PUSH
48177: LD_INT 0
48179: PUSH
48180: LD_INT 4
48182: NEG
48183: PUSH
48184: EMPTY
48185: LIST
48186: LIST
48187: PUSH
48188: LD_INT 1
48190: PUSH
48191: LD_INT 3
48193: NEG
48194: PUSH
48195: EMPTY
48196: LIST
48197: LIST
48198: PUSH
48199: LD_INT 1
48201: PUSH
48202: LD_INT 2
48204: NEG
48205: PUSH
48206: EMPTY
48207: LIST
48208: LIST
48209: PUSH
48210: LD_INT 0
48212: PUSH
48213: LD_INT 2
48215: NEG
48216: PUSH
48217: EMPTY
48218: LIST
48219: LIST
48220: PUSH
48221: LD_INT 1
48223: NEG
48224: PUSH
48225: LD_INT 3
48227: NEG
48228: PUSH
48229: EMPTY
48230: LIST
48231: LIST
48232: PUSH
48233: LD_INT 1
48235: NEG
48236: PUSH
48237: LD_INT 4
48239: NEG
48240: PUSH
48241: EMPTY
48242: LIST
48243: LIST
48244: PUSH
48245: LD_INT 2
48247: PUSH
48248: LD_INT 2
48250: NEG
48251: PUSH
48252: EMPTY
48253: LIST
48254: LIST
48255: PUSH
48256: LD_INT 2
48258: NEG
48259: PUSH
48260: LD_INT 4
48262: NEG
48263: PUSH
48264: EMPTY
48265: LIST
48266: LIST
48267: PUSH
48268: LD_INT 4
48270: PUSH
48271: LD_INT 0
48273: PUSH
48274: EMPTY
48275: LIST
48276: LIST
48277: PUSH
48278: LD_INT 4
48280: PUSH
48281: LD_INT 1
48283: NEG
48284: PUSH
48285: EMPTY
48286: LIST
48287: LIST
48288: PUSH
48289: LD_INT 5
48291: PUSH
48292: LD_INT 0
48294: PUSH
48295: EMPTY
48296: LIST
48297: LIST
48298: PUSH
48299: LD_INT 5
48301: PUSH
48302: LD_INT 1
48304: PUSH
48305: EMPTY
48306: LIST
48307: LIST
48308: PUSH
48309: LD_INT 4
48311: PUSH
48312: LD_INT 1
48314: PUSH
48315: EMPTY
48316: LIST
48317: LIST
48318: PUSH
48319: LD_INT 3
48321: PUSH
48322: LD_INT 0
48324: PUSH
48325: EMPTY
48326: LIST
48327: LIST
48328: PUSH
48329: LD_INT 3
48331: PUSH
48332: LD_INT 1
48334: NEG
48335: PUSH
48336: EMPTY
48337: LIST
48338: LIST
48339: PUSH
48340: LD_INT 3
48342: PUSH
48343: LD_INT 2
48345: NEG
48346: PUSH
48347: EMPTY
48348: LIST
48349: LIST
48350: PUSH
48351: LD_INT 5
48353: PUSH
48354: LD_INT 2
48356: PUSH
48357: EMPTY
48358: LIST
48359: LIST
48360: PUSH
48361: EMPTY
48362: LIST
48363: LIST
48364: LIST
48365: LIST
48366: LIST
48367: LIST
48368: LIST
48369: LIST
48370: LIST
48371: LIST
48372: LIST
48373: LIST
48374: LIST
48375: LIST
48376: LIST
48377: LIST
48378: LIST
48379: LIST
48380: LIST
48381: LIST
48382: LIST
48383: LIST
48384: LIST
48385: LIST
48386: LIST
48387: LIST
48388: LIST
48389: LIST
48390: LIST
48391: LIST
48392: LIST
48393: LIST
48394: LIST
48395: LIST
48396: LIST
48397: LIST
48398: LIST
48399: LIST
48400: LIST
48401: LIST
48402: LIST
48403: LIST
48404: LIST
48405: LIST
48406: LIST
48407: ST_TO_ADDR
// fFactory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
48408: LD_ADDR_VAR 0 32
48412: PUSH
48413: LD_INT 4
48415: NEG
48416: PUSH
48417: LD_INT 0
48419: PUSH
48420: EMPTY
48421: LIST
48422: LIST
48423: PUSH
48424: LD_INT 4
48426: NEG
48427: PUSH
48428: LD_INT 1
48430: NEG
48431: PUSH
48432: EMPTY
48433: LIST
48434: LIST
48435: PUSH
48436: LD_INT 3
48438: NEG
48439: PUSH
48440: LD_INT 0
48442: PUSH
48443: EMPTY
48444: LIST
48445: LIST
48446: PUSH
48447: LD_INT 3
48449: NEG
48450: PUSH
48451: LD_INT 1
48453: PUSH
48454: EMPTY
48455: LIST
48456: LIST
48457: PUSH
48458: LD_INT 4
48460: NEG
48461: PUSH
48462: LD_INT 1
48464: PUSH
48465: EMPTY
48466: LIST
48467: LIST
48468: PUSH
48469: LD_INT 5
48471: NEG
48472: PUSH
48473: LD_INT 0
48475: PUSH
48476: EMPTY
48477: LIST
48478: LIST
48479: PUSH
48480: LD_INT 5
48482: NEG
48483: PUSH
48484: LD_INT 1
48486: NEG
48487: PUSH
48488: EMPTY
48489: LIST
48490: LIST
48491: PUSH
48492: LD_INT 5
48494: NEG
48495: PUSH
48496: LD_INT 2
48498: NEG
48499: PUSH
48500: EMPTY
48501: LIST
48502: LIST
48503: PUSH
48504: LD_INT 3
48506: NEG
48507: PUSH
48508: LD_INT 2
48510: PUSH
48511: EMPTY
48512: LIST
48513: LIST
48514: PUSH
48515: LD_INT 3
48517: NEG
48518: PUSH
48519: LD_INT 3
48521: NEG
48522: PUSH
48523: EMPTY
48524: LIST
48525: LIST
48526: PUSH
48527: LD_INT 3
48529: NEG
48530: PUSH
48531: LD_INT 4
48533: NEG
48534: PUSH
48535: EMPTY
48536: LIST
48537: LIST
48538: PUSH
48539: LD_INT 2
48541: NEG
48542: PUSH
48543: LD_INT 3
48545: NEG
48546: PUSH
48547: EMPTY
48548: LIST
48549: LIST
48550: PUSH
48551: LD_INT 2
48553: NEG
48554: PUSH
48555: LD_INT 2
48557: NEG
48558: PUSH
48559: EMPTY
48560: LIST
48561: LIST
48562: PUSH
48563: LD_INT 3
48565: NEG
48566: PUSH
48567: LD_INT 2
48569: NEG
48570: PUSH
48571: EMPTY
48572: LIST
48573: LIST
48574: PUSH
48575: LD_INT 4
48577: NEG
48578: PUSH
48579: LD_INT 3
48581: NEG
48582: PUSH
48583: EMPTY
48584: LIST
48585: LIST
48586: PUSH
48587: LD_INT 4
48589: NEG
48590: PUSH
48591: LD_INT 4
48593: NEG
48594: PUSH
48595: EMPTY
48596: LIST
48597: LIST
48598: PUSH
48599: LD_INT 2
48601: NEG
48602: PUSH
48603: LD_INT 4
48605: NEG
48606: PUSH
48607: EMPTY
48608: LIST
48609: LIST
48610: PUSH
48611: LD_INT 4
48613: NEG
48614: PUSH
48615: LD_INT 2
48617: NEG
48618: PUSH
48619: EMPTY
48620: LIST
48621: LIST
48622: PUSH
48623: LD_INT 0
48625: PUSH
48626: LD_INT 4
48628: NEG
48629: PUSH
48630: EMPTY
48631: LIST
48632: LIST
48633: PUSH
48634: LD_INT 0
48636: PUSH
48637: LD_INT 5
48639: NEG
48640: PUSH
48641: EMPTY
48642: LIST
48643: LIST
48644: PUSH
48645: LD_INT 1
48647: PUSH
48648: LD_INT 4
48650: NEG
48651: PUSH
48652: EMPTY
48653: LIST
48654: LIST
48655: PUSH
48656: LD_INT 1
48658: PUSH
48659: LD_INT 3
48661: NEG
48662: PUSH
48663: EMPTY
48664: LIST
48665: LIST
48666: PUSH
48667: LD_INT 0
48669: PUSH
48670: LD_INT 3
48672: NEG
48673: PUSH
48674: EMPTY
48675: LIST
48676: LIST
48677: PUSH
48678: LD_INT 1
48680: NEG
48681: PUSH
48682: LD_INT 4
48684: NEG
48685: PUSH
48686: EMPTY
48687: LIST
48688: LIST
48689: PUSH
48690: LD_INT 1
48692: NEG
48693: PUSH
48694: LD_INT 5
48696: NEG
48697: PUSH
48698: EMPTY
48699: LIST
48700: LIST
48701: PUSH
48702: LD_INT 2
48704: PUSH
48705: LD_INT 3
48707: NEG
48708: PUSH
48709: EMPTY
48710: LIST
48711: LIST
48712: PUSH
48713: LD_INT 2
48715: NEG
48716: PUSH
48717: LD_INT 5
48719: NEG
48720: PUSH
48721: EMPTY
48722: LIST
48723: LIST
48724: PUSH
48725: LD_INT 3
48727: PUSH
48728: LD_INT 0
48730: PUSH
48731: EMPTY
48732: LIST
48733: LIST
48734: PUSH
48735: LD_INT 3
48737: PUSH
48738: LD_INT 1
48740: NEG
48741: PUSH
48742: EMPTY
48743: LIST
48744: LIST
48745: PUSH
48746: LD_INT 4
48748: PUSH
48749: LD_INT 0
48751: PUSH
48752: EMPTY
48753: LIST
48754: LIST
48755: PUSH
48756: LD_INT 4
48758: PUSH
48759: LD_INT 1
48761: PUSH
48762: EMPTY
48763: LIST
48764: LIST
48765: PUSH
48766: LD_INT 3
48768: PUSH
48769: LD_INT 1
48771: PUSH
48772: EMPTY
48773: LIST
48774: LIST
48775: PUSH
48776: LD_INT 2
48778: PUSH
48779: LD_INT 0
48781: PUSH
48782: EMPTY
48783: LIST
48784: LIST
48785: PUSH
48786: LD_INT 2
48788: PUSH
48789: LD_INT 1
48791: NEG
48792: PUSH
48793: EMPTY
48794: LIST
48795: LIST
48796: PUSH
48797: LD_INT 2
48799: PUSH
48800: LD_INT 2
48802: NEG
48803: PUSH
48804: EMPTY
48805: LIST
48806: LIST
48807: PUSH
48808: LD_INT 4
48810: PUSH
48811: LD_INT 2
48813: PUSH
48814: EMPTY
48815: LIST
48816: LIST
48817: PUSH
48818: LD_INT 4
48820: PUSH
48821: LD_INT 4
48823: PUSH
48824: EMPTY
48825: LIST
48826: LIST
48827: PUSH
48828: LD_INT 4
48830: PUSH
48831: LD_INT 3
48833: PUSH
48834: EMPTY
48835: LIST
48836: LIST
48837: PUSH
48838: LD_INT 5
48840: PUSH
48841: LD_INT 4
48843: PUSH
48844: EMPTY
48845: LIST
48846: LIST
48847: PUSH
48848: LD_INT 5
48850: PUSH
48851: LD_INT 5
48853: PUSH
48854: EMPTY
48855: LIST
48856: LIST
48857: PUSH
48858: LD_INT 4
48860: PUSH
48861: LD_INT 5
48863: PUSH
48864: EMPTY
48865: LIST
48866: LIST
48867: PUSH
48868: LD_INT 3
48870: PUSH
48871: LD_INT 4
48873: PUSH
48874: EMPTY
48875: LIST
48876: LIST
48877: PUSH
48878: LD_INT 3
48880: PUSH
48881: LD_INT 3
48883: PUSH
48884: EMPTY
48885: LIST
48886: LIST
48887: PUSH
48888: LD_INT 5
48890: PUSH
48891: LD_INT 3
48893: PUSH
48894: EMPTY
48895: LIST
48896: LIST
48897: PUSH
48898: LD_INT 3
48900: PUSH
48901: LD_INT 5
48903: PUSH
48904: EMPTY
48905: LIST
48906: LIST
48907: PUSH
48908: EMPTY
48909: LIST
48910: LIST
48911: LIST
48912: LIST
48913: LIST
48914: LIST
48915: LIST
48916: LIST
48917: LIST
48918: LIST
48919: LIST
48920: LIST
48921: LIST
48922: LIST
48923: LIST
48924: LIST
48925: LIST
48926: LIST
48927: LIST
48928: LIST
48929: LIST
48930: LIST
48931: LIST
48932: LIST
48933: LIST
48934: LIST
48935: LIST
48936: LIST
48937: LIST
48938: LIST
48939: LIST
48940: LIST
48941: LIST
48942: LIST
48943: LIST
48944: LIST
48945: LIST
48946: LIST
48947: LIST
48948: LIST
48949: LIST
48950: LIST
48951: LIST
48952: LIST
48953: LIST
48954: ST_TO_ADDR
// fFactory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
48955: LD_ADDR_VAR 0 33
48959: PUSH
48960: LD_INT 4
48962: NEG
48963: PUSH
48964: LD_INT 4
48966: NEG
48967: PUSH
48968: EMPTY
48969: LIST
48970: LIST
48971: PUSH
48972: LD_INT 4
48974: NEG
48975: PUSH
48976: LD_INT 5
48978: NEG
48979: PUSH
48980: EMPTY
48981: LIST
48982: LIST
48983: PUSH
48984: LD_INT 3
48986: NEG
48987: PUSH
48988: LD_INT 4
48990: NEG
48991: PUSH
48992: EMPTY
48993: LIST
48994: LIST
48995: PUSH
48996: LD_INT 3
48998: NEG
48999: PUSH
49000: LD_INT 3
49002: NEG
49003: PUSH
49004: EMPTY
49005: LIST
49006: LIST
49007: PUSH
49008: LD_INT 4
49010: NEG
49011: PUSH
49012: LD_INT 3
49014: NEG
49015: PUSH
49016: EMPTY
49017: LIST
49018: LIST
49019: PUSH
49020: LD_INT 5
49022: NEG
49023: PUSH
49024: LD_INT 4
49026: NEG
49027: PUSH
49028: EMPTY
49029: LIST
49030: LIST
49031: PUSH
49032: LD_INT 5
49034: NEG
49035: PUSH
49036: LD_INT 5
49038: NEG
49039: PUSH
49040: EMPTY
49041: LIST
49042: LIST
49043: PUSH
49044: LD_INT 3
49046: NEG
49047: PUSH
49048: LD_INT 5
49050: NEG
49051: PUSH
49052: EMPTY
49053: LIST
49054: LIST
49055: PUSH
49056: LD_INT 5
49058: NEG
49059: PUSH
49060: LD_INT 3
49062: NEG
49063: PUSH
49064: EMPTY
49065: LIST
49066: LIST
49067: PUSH
49068: LD_INT 0
49070: PUSH
49071: LD_INT 3
49073: NEG
49074: PUSH
49075: EMPTY
49076: LIST
49077: LIST
49078: PUSH
49079: LD_INT 0
49081: PUSH
49082: LD_INT 4
49084: NEG
49085: PUSH
49086: EMPTY
49087: LIST
49088: LIST
49089: PUSH
49090: LD_INT 1
49092: PUSH
49093: LD_INT 3
49095: NEG
49096: PUSH
49097: EMPTY
49098: LIST
49099: LIST
49100: PUSH
49101: LD_INT 1
49103: PUSH
49104: LD_INT 2
49106: NEG
49107: PUSH
49108: EMPTY
49109: LIST
49110: LIST
49111: PUSH
49112: LD_INT 0
49114: PUSH
49115: LD_INT 2
49117: NEG
49118: PUSH
49119: EMPTY
49120: LIST
49121: LIST
49122: PUSH
49123: LD_INT 1
49125: NEG
49126: PUSH
49127: LD_INT 3
49129: NEG
49130: PUSH
49131: EMPTY
49132: LIST
49133: LIST
49134: PUSH
49135: LD_INT 1
49137: NEG
49138: PUSH
49139: LD_INT 4
49141: NEG
49142: PUSH
49143: EMPTY
49144: LIST
49145: LIST
49146: PUSH
49147: LD_INT 2
49149: PUSH
49150: LD_INT 2
49152: NEG
49153: PUSH
49154: EMPTY
49155: LIST
49156: LIST
49157: PUSH
49158: LD_INT 2
49160: NEG
49161: PUSH
49162: LD_INT 4
49164: NEG
49165: PUSH
49166: EMPTY
49167: LIST
49168: LIST
49169: PUSH
49170: LD_INT 4
49172: PUSH
49173: LD_INT 0
49175: PUSH
49176: EMPTY
49177: LIST
49178: LIST
49179: PUSH
49180: LD_INT 4
49182: PUSH
49183: LD_INT 1
49185: NEG
49186: PUSH
49187: EMPTY
49188: LIST
49189: LIST
49190: PUSH
49191: LD_INT 5
49193: PUSH
49194: LD_INT 0
49196: PUSH
49197: EMPTY
49198: LIST
49199: LIST
49200: PUSH
49201: LD_INT 5
49203: PUSH
49204: LD_INT 1
49206: PUSH
49207: EMPTY
49208: LIST
49209: LIST
49210: PUSH
49211: LD_INT 4
49213: PUSH
49214: LD_INT 1
49216: PUSH
49217: EMPTY
49218: LIST
49219: LIST
49220: PUSH
49221: LD_INT 3
49223: PUSH
49224: LD_INT 0
49226: PUSH
49227: EMPTY
49228: LIST
49229: LIST
49230: PUSH
49231: LD_INT 3
49233: PUSH
49234: LD_INT 1
49236: NEG
49237: PUSH
49238: EMPTY
49239: LIST
49240: LIST
49241: PUSH
49242: LD_INT 3
49244: PUSH
49245: LD_INT 2
49247: NEG
49248: PUSH
49249: EMPTY
49250: LIST
49251: LIST
49252: PUSH
49253: LD_INT 5
49255: PUSH
49256: LD_INT 2
49258: PUSH
49259: EMPTY
49260: LIST
49261: LIST
49262: PUSH
49263: LD_INT 3
49265: PUSH
49266: LD_INT 3
49268: PUSH
49269: EMPTY
49270: LIST
49271: LIST
49272: PUSH
49273: LD_INT 3
49275: PUSH
49276: LD_INT 2
49278: PUSH
49279: EMPTY
49280: LIST
49281: LIST
49282: PUSH
49283: LD_INT 4
49285: PUSH
49286: LD_INT 3
49288: PUSH
49289: EMPTY
49290: LIST
49291: LIST
49292: PUSH
49293: LD_INT 4
49295: PUSH
49296: LD_INT 4
49298: PUSH
49299: EMPTY
49300: LIST
49301: LIST
49302: PUSH
49303: LD_INT 3
49305: PUSH
49306: LD_INT 4
49308: PUSH
49309: EMPTY
49310: LIST
49311: LIST
49312: PUSH
49313: LD_INT 2
49315: PUSH
49316: LD_INT 3
49318: PUSH
49319: EMPTY
49320: LIST
49321: LIST
49322: PUSH
49323: LD_INT 2
49325: PUSH
49326: LD_INT 2
49328: PUSH
49329: EMPTY
49330: LIST
49331: LIST
49332: PUSH
49333: LD_INT 4
49335: PUSH
49336: LD_INT 2
49338: PUSH
49339: EMPTY
49340: LIST
49341: LIST
49342: PUSH
49343: LD_INT 2
49345: PUSH
49346: LD_INT 4
49348: PUSH
49349: EMPTY
49350: LIST
49351: LIST
49352: PUSH
49353: LD_INT 0
49355: PUSH
49356: LD_INT 4
49358: PUSH
49359: EMPTY
49360: LIST
49361: LIST
49362: PUSH
49363: LD_INT 0
49365: PUSH
49366: LD_INT 3
49368: PUSH
49369: EMPTY
49370: LIST
49371: LIST
49372: PUSH
49373: LD_INT 1
49375: PUSH
49376: LD_INT 4
49378: PUSH
49379: EMPTY
49380: LIST
49381: LIST
49382: PUSH
49383: LD_INT 1
49385: PUSH
49386: LD_INT 5
49388: PUSH
49389: EMPTY
49390: LIST
49391: LIST
49392: PUSH
49393: LD_INT 0
49395: PUSH
49396: LD_INT 5
49398: PUSH
49399: EMPTY
49400: LIST
49401: LIST
49402: PUSH
49403: LD_INT 1
49405: NEG
49406: PUSH
49407: LD_INT 4
49409: PUSH
49410: EMPTY
49411: LIST
49412: LIST
49413: PUSH
49414: LD_INT 1
49416: NEG
49417: PUSH
49418: LD_INT 3
49420: PUSH
49421: EMPTY
49422: LIST
49423: LIST
49424: PUSH
49425: LD_INT 2
49427: PUSH
49428: LD_INT 5
49430: PUSH
49431: EMPTY
49432: LIST
49433: LIST
49434: PUSH
49435: LD_INT 2
49437: NEG
49438: PUSH
49439: LD_INT 3
49441: PUSH
49442: EMPTY
49443: LIST
49444: LIST
49445: PUSH
49446: EMPTY
49447: LIST
49448: LIST
49449: LIST
49450: LIST
49451: LIST
49452: LIST
49453: LIST
49454: LIST
49455: LIST
49456: LIST
49457: LIST
49458: LIST
49459: LIST
49460: LIST
49461: LIST
49462: LIST
49463: LIST
49464: LIST
49465: LIST
49466: LIST
49467: LIST
49468: LIST
49469: LIST
49470: LIST
49471: LIST
49472: LIST
49473: LIST
49474: LIST
49475: LIST
49476: LIST
49477: LIST
49478: LIST
49479: LIST
49480: LIST
49481: LIST
49482: LIST
49483: LIST
49484: LIST
49485: LIST
49486: LIST
49487: LIST
49488: LIST
49489: LIST
49490: LIST
49491: LIST
49492: ST_TO_ADDR
// fFactory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
49493: LD_ADDR_VAR 0 34
49497: PUSH
49498: LD_INT 0
49500: PUSH
49501: LD_INT 4
49503: NEG
49504: PUSH
49505: EMPTY
49506: LIST
49507: LIST
49508: PUSH
49509: LD_INT 0
49511: PUSH
49512: LD_INT 5
49514: NEG
49515: PUSH
49516: EMPTY
49517: LIST
49518: LIST
49519: PUSH
49520: LD_INT 1
49522: PUSH
49523: LD_INT 4
49525: NEG
49526: PUSH
49527: EMPTY
49528: LIST
49529: LIST
49530: PUSH
49531: LD_INT 1
49533: PUSH
49534: LD_INT 3
49536: NEG
49537: PUSH
49538: EMPTY
49539: LIST
49540: LIST
49541: PUSH
49542: LD_INT 0
49544: PUSH
49545: LD_INT 3
49547: NEG
49548: PUSH
49549: EMPTY
49550: LIST
49551: LIST
49552: PUSH
49553: LD_INT 1
49555: NEG
49556: PUSH
49557: LD_INT 4
49559: NEG
49560: PUSH
49561: EMPTY
49562: LIST
49563: LIST
49564: PUSH
49565: LD_INT 1
49567: NEG
49568: PUSH
49569: LD_INT 5
49571: NEG
49572: PUSH
49573: EMPTY
49574: LIST
49575: LIST
49576: PUSH
49577: LD_INT 2
49579: PUSH
49580: LD_INT 3
49582: NEG
49583: PUSH
49584: EMPTY
49585: LIST
49586: LIST
49587: PUSH
49588: LD_INT 2
49590: NEG
49591: PUSH
49592: LD_INT 5
49594: NEG
49595: PUSH
49596: EMPTY
49597: LIST
49598: LIST
49599: PUSH
49600: LD_INT 3
49602: PUSH
49603: LD_INT 0
49605: PUSH
49606: EMPTY
49607: LIST
49608: LIST
49609: PUSH
49610: LD_INT 3
49612: PUSH
49613: LD_INT 1
49615: NEG
49616: PUSH
49617: EMPTY
49618: LIST
49619: LIST
49620: PUSH
49621: LD_INT 4
49623: PUSH
49624: LD_INT 0
49626: PUSH
49627: EMPTY
49628: LIST
49629: LIST
49630: PUSH
49631: LD_INT 4
49633: PUSH
49634: LD_INT 1
49636: PUSH
49637: EMPTY
49638: LIST
49639: LIST
49640: PUSH
49641: LD_INT 3
49643: PUSH
49644: LD_INT 1
49646: PUSH
49647: EMPTY
49648: LIST
49649: LIST
49650: PUSH
49651: LD_INT 2
49653: PUSH
49654: LD_INT 0
49656: PUSH
49657: EMPTY
49658: LIST
49659: LIST
49660: PUSH
49661: LD_INT 2
49663: PUSH
49664: LD_INT 1
49666: NEG
49667: PUSH
49668: EMPTY
49669: LIST
49670: LIST
49671: PUSH
49672: LD_INT 2
49674: PUSH
49675: LD_INT 2
49677: NEG
49678: PUSH
49679: EMPTY
49680: LIST
49681: LIST
49682: PUSH
49683: LD_INT 4
49685: PUSH
49686: LD_INT 2
49688: PUSH
49689: EMPTY
49690: LIST
49691: LIST
49692: PUSH
49693: LD_INT 4
49695: PUSH
49696: LD_INT 4
49698: PUSH
49699: EMPTY
49700: LIST
49701: LIST
49702: PUSH
49703: LD_INT 4
49705: PUSH
49706: LD_INT 3
49708: PUSH
49709: EMPTY
49710: LIST
49711: LIST
49712: PUSH
49713: LD_INT 5
49715: PUSH
49716: LD_INT 4
49718: PUSH
49719: EMPTY
49720: LIST
49721: LIST
49722: PUSH
49723: LD_INT 5
49725: PUSH
49726: LD_INT 5
49728: PUSH
49729: EMPTY
49730: LIST
49731: LIST
49732: PUSH
49733: LD_INT 4
49735: PUSH
49736: LD_INT 5
49738: PUSH
49739: EMPTY
49740: LIST
49741: LIST
49742: PUSH
49743: LD_INT 3
49745: PUSH
49746: LD_INT 4
49748: PUSH
49749: EMPTY
49750: LIST
49751: LIST
49752: PUSH
49753: LD_INT 3
49755: PUSH
49756: LD_INT 3
49758: PUSH
49759: EMPTY
49760: LIST
49761: LIST
49762: PUSH
49763: LD_INT 5
49765: PUSH
49766: LD_INT 3
49768: PUSH
49769: EMPTY
49770: LIST
49771: LIST
49772: PUSH
49773: LD_INT 3
49775: PUSH
49776: LD_INT 5
49778: PUSH
49779: EMPTY
49780: LIST
49781: LIST
49782: PUSH
49783: LD_INT 0
49785: PUSH
49786: LD_INT 3
49788: PUSH
49789: EMPTY
49790: LIST
49791: LIST
49792: PUSH
49793: LD_INT 0
49795: PUSH
49796: LD_INT 2
49798: PUSH
49799: EMPTY
49800: LIST
49801: LIST
49802: PUSH
49803: LD_INT 1
49805: PUSH
49806: LD_INT 3
49808: PUSH
49809: EMPTY
49810: LIST
49811: LIST
49812: PUSH
49813: LD_INT 1
49815: PUSH
49816: LD_INT 4
49818: PUSH
49819: EMPTY
49820: LIST
49821: LIST
49822: PUSH
49823: LD_INT 0
49825: PUSH
49826: LD_INT 4
49828: PUSH
49829: EMPTY
49830: LIST
49831: LIST
49832: PUSH
49833: LD_INT 1
49835: NEG
49836: PUSH
49837: LD_INT 3
49839: PUSH
49840: EMPTY
49841: LIST
49842: LIST
49843: PUSH
49844: LD_INT 1
49846: NEG
49847: PUSH
49848: LD_INT 2
49850: PUSH
49851: EMPTY
49852: LIST
49853: LIST
49854: PUSH
49855: LD_INT 2
49857: PUSH
49858: LD_INT 4
49860: PUSH
49861: EMPTY
49862: LIST
49863: LIST
49864: PUSH
49865: LD_INT 2
49867: NEG
49868: PUSH
49869: LD_INT 2
49871: PUSH
49872: EMPTY
49873: LIST
49874: LIST
49875: PUSH
49876: LD_INT 4
49878: NEG
49879: PUSH
49880: LD_INT 0
49882: PUSH
49883: EMPTY
49884: LIST
49885: LIST
49886: PUSH
49887: LD_INT 4
49889: NEG
49890: PUSH
49891: LD_INT 1
49893: NEG
49894: PUSH
49895: EMPTY
49896: LIST
49897: LIST
49898: PUSH
49899: LD_INT 3
49901: NEG
49902: PUSH
49903: LD_INT 0
49905: PUSH
49906: EMPTY
49907: LIST
49908: LIST
49909: PUSH
49910: LD_INT 3
49912: NEG
49913: PUSH
49914: LD_INT 1
49916: PUSH
49917: EMPTY
49918: LIST
49919: LIST
49920: PUSH
49921: LD_INT 4
49923: NEG
49924: PUSH
49925: LD_INT 1
49927: PUSH
49928: EMPTY
49929: LIST
49930: LIST
49931: PUSH
49932: LD_INT 5
49934: NEG
49935: PUSH
49936: LD_INT 0
49938: PUSH
49939: EMPTY
49940: LIST
49941: LIST
49942: PUSH
49943: LD_INT 5
49945: NEG
49946: PUSH
49947: LD_INT 1
49949: NEG
49950: PUSH
49951: EMPTY
49952: LIST
49953: LIST
49954: PUSH
49955: LD_INT 5
49957: NEG
49958: PUSH
49959: LD_INT 2
49961: NEG
49962: PUSH
49963: EMPTY
49964: LIST
49965: LIST
49966: PUSH
49967: LD_INT 3
49969: NEG
49970: PUSH
49971: LD_INT 2
49973: PUSH
49974: EMPTY
49975: LIST
49976: LIST
49977: PUSH
49978: EMPTY
49979: LIST
49980: LIST
49981: LIST
49982: LIST
49983: LIST
49984: LIST
49985: LIST
49986: LIST
49987: LIST
49988: LIST
49989: LIST
49990: LIST
49991: LIST
49992: LIST
49993: LIST
49994: LIST
49995: LIST
49996: LIST
49997: LIST
49998: LIST
49999: LIST
50000: LIST
50001: LIST
50002: LIST
50003: LIST
50004: LIST
50005: LIST
50006: LIST
50007: LIST
50008: LIST
50009: LIST
50010: LIST
50011: LIST
50012: LIST
50013: LIST
50014: LIST
50015: LIST
50016: LIST
50017: LIST
50018: LIST
50019: LIST
50020: LIST
50021: LIST
50022: LIST
50023: LIST
50024: ST_TO_ADDR
// end ; end ;
50025: GO 50028
50027: POP
// case btype of b_depot , b_warehouse :
50028: LD_VAR 0 1
50032: PUSH
50033: LD_INT 0
50035: DOUBLE
50036: EQUAL
50037: IFTRUE 50047
50039: LD_INT 1
50041: DOUBLE
50042: EQUAL
50043: IFTRUE 50047
50045: GO 50248
50047: POP
// case nation of nation_american :
50048: LD_VAR 0 5
50052: PUSH
50053: LD_INT 1
50055: DOUBLE
50056: EQUAL
50057: IFTRUE 50061
50059: GO 50117
50061: POP
// temp_list = [ fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 ] [ dir + 1 ] ; nation_arabian :
50062: LD_ADDR_VAR 0 9
50066: PUSH
50067: LD_VAR 0 11
50071: PUSH
50072: LD_VAR 0 12
50076: PUSH
50077: LD_VAR 0 13
50081: PUSH
50082: LD_VAR 0 14
50086: PUSH
50087: LD_VAR 0 15
50091: PUSH
50092: LD_VAR 0 16
50096: PUSH
50097: EMPTY
50098: LIST
50099: LIST
50100: LIST
50101: LIST
50102: LIST
50103: LIST
50104: PUSH
50105: LD_VAR 0 4
50109: PUSH
50110: LD_INT 1
50112: PLUS
50113: ARRAY
50114: ST_TO_ADDR
50115: GO 50246
50117: LD_INT 2
50119: DOUBLE
50120: EQUAL
50121: IFTRUE 50125
50123: GO 50181
50125: POP
// temp_list = [ fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 ] [ dir + 1 ] ; nation_russian :
50126: LD_ADDR_VAR 0 9
50130: PUSH
50131: LD_VAR 0 17
50135: PUSH
50136: LD_VAR 0 18
50140: PUSH
50141: LD_VAR 0 19
50145: PUSH
50146: LD_VAR 0 20
50150: PUSH
50151: LD_VAR 0 21
50155: PUSH
50156: LD_VAR 0 22
50160: PUSH
50161: EMPTY
50162: LIST
50163: LIST
50164: LIST
50165: LIST
50166: LIST
50167: LIST
50168: PUSH
50169: LD_VAR 0 4
50173: PUSH
50174: LD_INT 1
50176: PLUS
50177: ARRAY
50178: ST_TO_ADDR
50179: GO 50246
50181: LD_INT 3
50183: DOUBLE
50184: EQUAL
50185: IFTRUE 50189
50187: GO 50245
50189: POP
// temp_list = [ fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
50190: LD_ADDR_VAR 0 9
50194: PUSH
50195: LD_VAR 0 23
50199: PUSH
50200: LD_VAR 0 24
50204: PUSH
50205: LD_VAR 0 25
50209: PUSH
50210: LD_VAR 0 26
50214: PUSH
50215: LD_VAR 0 27
50219: PUSH
50220: LD_VAR 0 28
50224: PUSH
50225: EMPTY
50226: LIST
50227: LIST
50228: LIST
50229: LIST
50230: LIST
50231: LIST
50232: PUSH
50233: LD_VAR 0 4
50237: PUSH
50238: LD_INT 1
50240: PLUS
50241: ARRAY
50242: ST_TO_ADDR
50243: GO 50246
50245: POP
50246: GO 50801
50248: LD_INT 2
50250: DOUBLE
50251: EQUAL
50252: IFTRUE 50262
50254: LD_INT 3
50256: DOUBLE
50257: EQUAL
50258: IFTRUE 50262
50260: GO 50318
50262: POP
// temp_list = [ fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
50263: LD_ADDR_VAR 0 9
50267: PUSH
50268: LD_VAR 0 29
50272: PUSH
50273: LD_VAR 0 30
50277: PUSH
50278: LD_VAR 0 31
50282: PUSH
50283: LD_VAR 0 32
50287: PUSH
50288: LD_VAR 0 33
50292: PUSH
50293: LD_VAR 0 34
50297: PUSH
50298: EMPTY
50299: LIST
50300: LIST
50301: LIST
50302: LIST
50303: LIST
50304: LIST
50305: PUSH
50306: LD_VAR 0 4
50310: PUSH
50311: LD_INT 1
50313: PLUS
50314: ARRAY
50315: ST_TO_ADDR
50316: GO 50801
50318: LD_INT 16
50320: DOUBLE
50321: EQUAL
50322: IFTRUE 50380
50324: LD_INT 17
50326: DOUBLE
50327: EQUAL
50328: IFTRUE 50380
50330: LD_INT 18
50332: DOUBLE
50333: EQUAL
50334: IFTRUE 50380
50336: LD_INT 19
50338: DOUBLE
50339: EQUAL
50340: IFTRUE 50380
50342: LD_INT 22
50344: DOUBLE
50345: EQUAL
50346: IFTRUE 50380
50348: LD_INT 20
50350: DOUBLE
50351: EQUAL
50352: IFTRUE 50380
50354: LD_INT 21
50356: DOUBLE
50357: EQUAL
50358: IFTRUE 50380
50360: LD_INT 23
50362: DOUBLE
50363: EQUAL
50364: IFTRUE 50380
50366: LD_INT 24
50368: DOUBLE
50369: EQUAL
50370: IFTRUE 50380
50372: LD_INT 25
50374: DOUBLE
50375: EQUAL
50376: IFTRUE 50380
50378: GO 50436
50380: POP
// temp_list = [ fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
50381: LD_ADDR_VAR 0 9
50385: PUSH
50386: LD_VAR 0 35
50390: PUSH
50391: LD_VAR 0 36
50395: PUSH
50396: LD_VAR 0 37
50400: PUSH
50401: LD_VAR 0 38
50405: PUSH
50406: LD_VAR 0 39
50410: PUSH
50411: LD_VAR 0 40
50415: PUSH
50416: EMPTY
50417: LIST
50418: LIST
50419: LIST
50420: LIST
50421: LIST
50422: LIST
50423: PUSH
50424: LD_VAR 0 4
50428: PUSH
50429: LD_INT 1
50431: PLUS
50432: ARRAY
50433: ST_TO_ADDR
50434: GO 50801
50436: LD_INT 6
50438: DOUBLE
50439: EQUAL
50440: IFTRUE 50492
50442: LD_INT 7
50444: DOUBLE
50445: EQUAL
50446: IFTRUE 50492
50448: LD_INT 8
50450: DOUBLE
50451: EQUAL
50452: IFTRUE 50492
50454: LD_INT 13
50456: DOUBLE
50457: EQUAL
50458: IFTRUE 50492
50460: LD_INT 12
50462: DOUBLE
50463: EQUAL
50464: IFTRUE 50492
50466: LD_INT 15
50468: DOUBLE
50469: EQUAL
50470: IFTRUE 50492
50472: LD_INT 11
50474: DOUBLE
50475: EQUAL
50476: IFTRUE 50492
50478: LD_INT 14
50480: DOUBLE
50481: EQUAL
50482: IFTRUE 50492
50484: LD_INT 10
50486: DOUBLE
50487: EQUAL
50488: IFTRUE 50492
50490: GO 50548
50492: POP
// temp_list = [ fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 ] [ dir + 1 ] ; b_control_tower :
50493: LD_ADDR_VAR 0 9
50497: PUSH
50498: LD_VAR 0 41
50502: PUSH
50503: LD_VAR 0 42
50507: PUSH
50508: LD_VAR 0 43
50512: PUSH
50513: LD_VAR 0 44
50517: PUSH
50518: LD_VAR 0 45
50522: PUSH
50523: LD_VAR 0 46
50527: PUSH
50528: EMPTY
50529: LIST
50530: LIST
50531: LIST
50532: LIST
50533: LIST
50534: LIST
50535: PUSH
50536: LD_VAR 0 4
50540: PUSH
50541: LD_INT 1
50543: PLUS
50544: ARRAY
50545: ST_TO_ADDR
50546: GO 50801
50548: LD_INT 36
50550: DOUBLE
50551: EQUAL
50552: IFTRUE 50556
50554: GO 50612
50556: POP
// temp_list = [ fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
50557: LD_ADDR_VAR 0 9
50561: PUSH
50562: LD_VAR 0 47
50566: PUSH
50567: LD_VAR 0 48
50571: PUSH
50572: LD_VAR 0 49
50576: PUSH
50577: LD_VAR 0 50
50581: PUSH
50582: LD_VAR 0 51
50586: PUSH
50587: LD_VAR 0 52
50591: PUSH
50592: EMPTY
50593: LIST
50594: LIST
50595: LIST
50596: LIST
50597: LIST
50598: LIST
50599: PUSH
50600: LD_VAR 0 4
50604: PUSH
50605: LD_INT 1
50607: PLUS
50608: ARRAY
50609: ST_TO_ADDR
50610: GO 50801
50612: LD_INT 4
50614: DOUBLE
50615: EQUAL
50616: IFTRUE 50638
50618: LD_INT 5
50620: DOUBLE
50621: EQUAL
50622: IFTRUE 50638
50624: LD_INT 34
50626: DOUBLE
50627: EQUAL
50628: IFTRUE 50638
50630: LD_INT 37
50632: DOUBLE
50633: EQUAL
50634: IFTRUE 50638
50636: GO 50694
50638: POP
// temp_list = [ fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
50639: LD_ADDR_VAR 0 9
50643: PUSH
50644: LD_VAR 0 53
50648: PUSH
50649: LD_VAR 0 54
50653: PUSH
50654: LD_VAR 0 55
50658: PUSH
50659: LD_VAR 0 56
50663: PUSH
50664: LD_VAR 0 57
50668: PUSH
50669: LD_VAR 0 58
50673: PUSH
50674: EMPTY
50675: LIST
50676: LIST
50677: LIST
50678: LIST
50679: LIST
50680: LIST
50681: PUSH
50682: LD_VAR 0 4
50686: PUSH
50687: LD_INT 1
50689: PLUS
50690: ARRAY
50691: ST_TO_ADDR
50692: GO 50801
50694: LD_INT 31
50696: DOUBLE
50697: EQUAL
50698: IFTRUE 50744
50700: LD_INT 32
50702: DOUBLE
50703: EQUAL
50704: IFTRUE 50744
50706: LD_INT 33
50708: DOUBLE
50709: EQUAL
50710: IFTRUE 50744
50712: LD_INT 27
50714: DOUBLE
50715: EQUAL
50716: IFTRUE 50744
50718: LD_INT 26
50720: DOUBLE
50721: EQUAL
50722: IFTRUE 50744
50724: LD_INT 28
50726: DOUBLE
50727: EQUAL
50728: IFTRUE 50744
50730: LD_INT 29
50732: DOUBLE
50733: EQUAL
50734: IFTRUE 50744
50736: LD_INT 30
50738: DOUBLE
50739: EQUAL
50740: IFTRUE 50744
50742: GO 50800
50744: POP
// temp_list = [ fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ] [ dir + 1 ] ; end ;
50745: LD_ADDR_VAR 0 9
50749: PUSH
50750: LD_VAR 0 59
50754: PUSH
50755: LD_VAR 0 60
50759: PUSH
50760: LD_VAR 0 61
50764: PUSH
50765: LD_VAR 0 62
50769: PUSH
50770: LD_VAR 0 63
50774: PUSH
50775: LD_VAR 0 64
50779: PUSH
50780: EMPTY
50781: LIST
50782: LIST
50783: LIST
50784: LIST
50785: LIST
50786: LIST
50787: PUSH
50788: LD_VAR 0 4
50792: PUSH
50793: LD_INT 1
50795: PLUS
50796: ARRAY
50797: ST_TO_ADDR
50798: GO 50801
50800: POP
// temp_list2 = [ ] ;
50801: LD_ADDR_VAR 0 10
50805: PUSH
50806: EMPTY
50807: ST_TO_ADDR
// for i in temp_list do
50808: LD_ADDR_VAR 0 8
50812: PUSH
50813: LD_VAR 0 9
50817: PUSH
50818: FOR_IN
50819: IFFALSE 50871
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
50821: LD_ADDR_VAR 0 10
50825: PUSH
50826: LD_VAR 0 10
50830: PUSH
50831: LD_VAR 0 8
50835: PUSH
50836: LD_INT 1
50838: ARRAY
50839: PUSH
50840: LD_VAR 0 2
50844: PLUS
50845: PUSH
50846: LD_VAR 0 8
50850: PUSH
50851: LD_INT 2
50853: ARRAY
50854: PUSH
50855: LD_VAR 0 3
50859: PLUS
50860: PUSH
50861: EMPTY
50862: LIST
50863: LIST
50864: PUSH
50865: EMPTY
50866: LIST
50867: ADD
50868: ST_TO_ADDR
50869: GO 50818
50871: POP
50872: POP
// result = temp_list2 ;
50873: LD_ADDR_VAR 0 7
50877: PUSH
50878: LD_VAR 0 10
50882: ST_TO_ADDR
// end ;
50883: LD_VAR 0 7
50887: RET
// export function EnemyInRange ( unit , dist ) ; begin
50888: LD_INT 0
50890: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
50891: LD_ADDR_VAR 0 3
50895: PUSH
50896: LD_VAR 0 1
50900: PPUSH
50901: CALL_OW 255
50905: PPUSH
50906: LD_VAR 0 1
50910: PPUSH
50911: CALL_OW 250
50915: PPUSH
50916: LD_VAR 0 1
50920: PPUSH
50921: CALL_OW 251
50925: PPUSH
50926: LD_VAR 0 2
50930: PPUSH
50931: CALL 24992 0 4
50935: PUSH
50936: LD_INT 4
50938: ARRAY
50939: ST_TO_ADDR
// end ;
50940: LD_VAR 0 3
50944: RET
// export function PlayerSeeMe ( unit ) ; begin
50945: LD_INT 0
50947: PPUSH
// result := See ( your_side , unit ) ;
50948: LD_ADDR_VAR 0 2
50952: PUSH
50953: LD_OWVAR 2
50957: PPUSH
50958: LD_VAR 0 1
50962: PPUSH
50963: CALL_OW 292
50967: ST_TO_ADDR
// end ;
50968: LD_VAR 0 2
50972: RET
// export function ReverseDir ( unit ) ; begin
50973: LD_INT 0
50975: PPUSH
// if not unit then
50976: LD_VAR 0 1
50980: NOT
50981: IFFALSE 50985
// exit ;
50983: GO 51008
// result := ( GetDir ( unit ) + 3 ) mod 6 ;
50985: LD_ADDR_VAR 0 2
50989: PUSH
50990: LD_VAR 0 1
50994: PPUSH
50995: CALL_OW 254
50999: PUSH
51000: LD_INT 3
51002: PLUS
51003: PUSH
51004: LD_INT 6
51006: MOD
51007: ST_TO_ADDR
// end ;
51008: LD_VAR 0 2
51012: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tmp , hex ; begin
51013: LD_INT 0
51015: PPUSH
51016: PPUSH
51017: PPUSH
51018: PPUSH
51019: PPUSH
// if not hexes then
51020: LD_VAR 0 2
51024: NOT
51025: IFFALSE 51029
// exit ;
51027: GO 51177
// dist := 9999 ;
51029: LD_ADDR_VAR 0 5
51033: PUSH
51034: LD_INT 9999
51036: ST_TO_ADDR
// for i = 1 to hexes do
51037: LD_ADDR_VAR 0 4
51041: PUSH
51042: DOUBLE
51043: LD_INT 1
51045: DEC
51046: ST_TO_ADDR
51047: LD_VAR 0 2
51051: PUSH
51052: FOR_TO
51053: IFFALSE 51165
// begin if GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) < dist then
51055: LD_VAR 0 1
51059: PPUSH
51060: LD_VAR 0 2
51064: PUSH
51065: LD_VAR 0 4
51069: ARRAY
51070: PUSH
51071: LD_INT 1
51073: ARRAY
51074: PPUSH
51075: LD_VAR 0 2
51079: PUSH
51080: LD_VAR 0 4
51084: ARRAY
51085: PUSH
51086: LD_INT 2
51088: ARRAY
51089: PPUSH
51090: CALL_OW 297
51094: PUSH
51095: LD_VAR 0 5
51099: LESS
51100: IFFALSE 51163
// begin hex := hexes [ i ] ;
51102: LD_ADDR_VAR 0 7
51106: PUSH
51107: LD_VAR 0 2
51111: PUSH
51112: LD_VAR 0 4
51116: ARRAY
51117: ST_TO_ADDR
// dist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
51118: LD_ADDR_VAR 0 5
51122: PUSH
51123: LD_VAR 0 1
51127: PPUSH
51128: LD_VAR 0 2
51132: PUSH
51133: LD_VAR 0 4
51137: ARRAY
51138: PUSH
51139: LD_INT 1
51141: ARRAY
51142: PPUSH
51143: LD_VAR 0 2
51147: PUSH
51148: LD_VAR 0 4
51152: ARRAY
51153: PUSH
51154: LD_INT 2
51156: ARRAY
51157: PPUSH
51158: CALL_OW 297
51162: ST_TO_ADDR
// end ; end ;
51163: GO 51052
51165: POP
51166: POP
// result := hex ;
51167: LD_ADDR_VAR 0 3
51171: PUSH
51172: LD_VAR 0 7
51176: ST_TO_ADDR
// end ;
51177: LD_VAR 0 3
51181: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
51182: LD_INT 0
51184: PPUSH
51185: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
51186: LD_VAR 0 1
51190: NOT
51191: PUSH
51192: LD_VAR 0 1
51196: PUSH
51197: LD_INT 21
51199: PUSH
51200: LD_INT 2
51202: PUSH
51203: EMPTY
51204: LIST
51205: LIST
51206: PUSH
51207: LD_INT 23
51209: PUSH
51210: LD_INT 2
51212: PUSH
51213: EMPTY
51214: LIST
51215: LIST
51216: PUSH
51217: EMPTY
51218: LIST
51219: LIST
51220: PPUSH
51221: CALL_OW 69
51225: IN
51226: NOT
51227: OR
51228: IFFALSE 51232
// exit ;
51230: GO 51279
// for i = 1 to 3 do
51232: LD_ADDR_VAR 0 3
51236: PUSH
51237: DOUBLE
51238: LD_INT 1
51240: DEC
51241: ST_TO_ADDR
51242: LD_INT 3
51244: PUSH
51245: FOR_TO
51246: IFFALSE 51277
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
51248: LD_VAR 0 1
51252: PPUSH
51253: CALL_OW 250
51257: PPUSH
51258: LD_VAR 0 1
51262: PPUSH
51263: CALL_OW 251
51267: PPUSH
51268: LD_INT 1
51270: PPUSH
51271: CALL_OW 453
51275: GO 51245
51277: POP
51278: POP
// end ;
51279: LD_VAR 0 2
51283: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
51284: LD_INT 0
51286: PPUSH
51287: PPUSH
51288: PPUSH
51289: PPUSH
51290: PPUSH
51291: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
51292: LD_VAR 0 1
51296: NOT
51297: PUSH
51298: LD_VAR 0 2
51302: NOT
51303: OR
51304: PUSH
51305: LD_VAR 0 1
51309: PPUSH
51310: CALL_OW 314
51314: OR
51315: IFFALSE 51319
// exit ;
51317: GO 51760
// x := GetX ( enemy_unit ) ;
51319: LD_ADDR_VAR 0 7
51323: PUSH
51324: LD_VAR 0 2
51328: PPUSH
51329: CALL_OW 250
51333: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
51334: LD_ADDR_VAR 0 8
51338: PUSH
51339: LD_VAR 0 2
51343: PPUSH
51344: CALL_OW 251
51348: ST_TO_ADDR
// if not x or not y then
51349: LD_VAR 0 7
51353: NOT
51354: PUSH
51355: LD_VAR 0 8
51359: NOT
51360: OR
51361: IFFALSE 51365
// exit ;
51363: GO 51760
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
51365: LD_ADDR_VAR 0 6
51369: PUSH
51370: LD_VAR 0 7
51374: PPUSH
51375: LD_INT 0
51377: PPUSH
51378: LD_INT 4
51380: PPUSH
51381: CALL_OW 272
51385: PUSH
51386: LD_VAR 0 8
51390: PPUSH
51391: LD_INT 0
51393: PPUSH
51394: LD_INT 4
51396: PPUSH
51397: CALL_OW 273
51401: PUSH
51402: EMPTY
51403: LIST
51404: LIST
51405: PUSH
51406: LD_VAR 0 7
51410: PPUSH
51411: LD_INT 1
51413: PPUSH
51414: LD_INT 4
51416: PPUSH
51417: CALL_OW 272
51421: PUSH
51422: LD_VAR 0 8
51426: PPUSH
51427: LD_INT 1
51429: PPUSH
51430: LD_INT 4
51432: PPUSH
51433: CALL_OW 273
51437: PUSH
51438: EMPTY
51439: LIST
51440: LIST
51441: PUSH
51442: LD_VAR 0 7
51446: PPUSH
51447: LD_INT 2
51449: PPUSH
51450: LD_INT 4
51452: PPUSH
51453: CALL_OW 272
51457: PUSH
51458: LD_VAR 0 8
51462: PPUSH
51463: LD_INT 2
51465: PPUSH
51466: LD_INT 4
51468: PPUSH
51469: CALL_OW 273
51473: PUSH
51474: EMPTY
51475: LIST
51476: LIST
51477: PUSH
51478: LD_VAR 0 7
51482: PPUSH
51483: LD_INT 3
51485: PPUSH
51486: LD_INT 4
51488: PPUSH
51489: CALL_OW 272
51493: PUSH
51494: LD_VAR 0 8
51498: PPUSH
51499: LD_INT 3
51501: PPUSH
51502: LD_INT 4
51504: PPUSH
51505: CALL_OW 273
51509: PUSH
51510: EMPTY
51511: LIST
51512: LIST
51513: PUSH
51514: LD_VAR 0 7
51518: PPUSH
51519: LD_INT 4
51521: PPUSH
51522: LD_INT 4
51524: PPUSH
51525: CALL_OW 272
51529: PUSH
51530: LD_VAR 0 8
51534: PPUSH
51535: LD_INT 4
51537: PPUSH
51538: LD_INT 4
51540: PPUSH
51541: CALL_OW 273
51545: PUSH
51546: EMPTY
51547: LIST
51548: LIST
51549: PUSH
51550: LD_VAR 0 7
51554: PPUSH
51555: LD_INT 5
51557: PPUSH
51558: LD_INT 4
51560: PPUSH
51561: CALL_OW 272
51565: PUSH
51566: LD_VAR 0 8
51570: PPUSH
51571: LD_INT 5
51573: PPUSH
51574: LD_INT 4
51576: PPUSH
51577: CALL_OW 273
51581: PUSH
51582: EMPTY
51583: LIST
51584: LIST
51585: PUSH
51586: EMPTY
51587: LIST
51588: LIST
51589: LIST
51590: LIST
51591: LIST
51592: LIST
51593: ST_TO_ADDR
// for i = tmp downto 1 do
51594: LD_ADDR_VAR 0 4
51598: PUSH
51599: DOUBLE
51600: LD_VAR 0 6
51604: INC
51605: ST_TO_ADDR
51606: LD_INT 1
51608: PUSH
51609: FOR_DOWNTO
51610: IFFALSE 51711
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
51612: LD_VAR 0 6
51616: PUSH
51617: LD_VAR 0 4
51621: ARRAY
51622: PUSH
51623: LD_INT 1
51625: ARRAY
51626: PPUSH
51627: LD_VAR 0 6
51631: PUSH
51632: LD_VAR 0 4
51636: ARRAY
51637: PUSH
51638: LD_INT 2
51640: ARRAY
51641: PPUSH
51642: CALL_OW 488
51646: NOT
51647: PUSH
51648: LD_VAR 0 6
51652: PUSH
51653: LD_VAR 0 4
51657: ARRAY
51658: PUSH
51659: LD_INT 1
51661: ARRAY
51662: PPUSH
51663: LD_VAR 0 6
51667: PUSH
51668: LD_VAR 0 4
51672: ARRAY
51673: PUSH
51674: LD_INT 2
51676: ARRAY
51677: PPUSH
51678: CALL_OW 428
51682: PUSH
51683: LD_INT 0
51685: NONEQUAL
51686: OR
51687: IFFALSE 51709
// tmp := Delete ( tmp , i ) ;
51689: LD_ADDR_VAR 0 6
51693: PUSH
51694: LD_VAR 0 6
51698: PPUSH
51699: LD_VAR 0 4
51703: PPUSH
51704: CALL_OW 3
51708: ST_TO_ADDR
51709: GO 51609
51711: POP
51712: POP
// j := GetClosestHex ( unit , tmp ) ;
51713: LD_ADDR_VAR 0 5
51717: PUSH
51718: LD_VAR 0 1
51722: PPUSH
51723: LD_VAR 0 6
51727: PPUSH
51728: CALL 51013 0 2
51732: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
51733: LD_VAR 0 1
51737: PPUSH
51738: LD_VAR 0 5
51742: PUSH
51743: LD_INT 1
51745: ARRAY
51746: PPUSH
51747: LD_VAR 0 5
51751: PUSH
51752: LD_INT 2
51754: ARRAY
51755: PPUSH
51756: CALL_OW 111
// end ;
51760: LD_VAR 0 3
51764: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
51765: LD_INT 0
51767: PPUSH
51768: PPUSH
51769: PPUSH
// uc_side = 0 ;
51770: LD_ADDR_OWVAR 20
51774: PUSH
51775: LD_INT 0
51777: ST_TO_ADDR
// uc_nation = 0 ;
51778: LD_ADDR_OWVAR 21
51782: PUSH
51783: LD_INT 0
51785: ST_TO_ADDR
// InitHc_All ( ) ;
51786: CALL_OW 584
// InitVc ;
51790: CALL_OW 20
// if mastodonts then
51794: LD_VAR 0 6
51798: IFFALSE 51865
// for i = 1 to mastodonts do
51800: LD_ADDR_VAR 0 11
51804: PUSH
51805: DOUBLE
51806: LD_INT 1
51808: DEC
51809: ST_TO_ADDR
51810: LD_VAR 0 6
51814: PUSH
51815: FOR_TO
51816: IFFALSE 51863
// begin vc_chassis := 31 ;
51818: LD_ADDR_OWVAR 37
51822: PUSH
51823: LD_INT 31
51825: ST_TO_ADDR
// vc_control := control_rider ;
51826: LD_ADDR_OWVAR 38
51830: PUSH
51831: LD_INT 4
51833: ST_TO_ADDR
// animal := CreateVehicle ;
51834: LD_ADDR_VAR 0 12
51838: PUSH
51839: CALL_OW 45
51843: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
51844: LD_VAR 0 12
51848: PPUSH
51849: LD_VAR 0 8
51853: PPUSH
51854: LD_INT 0
51856: PPUSH
51857: CALL 54053 0 3
// end ;
51861: GO 51815
51863: POP
51864: POP
// if horses then
51865: LD_VAR 0 5
51869: IFFALSE 51936
// for i = 1 to horses do
51871: LD_ADDR_VAR 0 11
51875: PUSH
51876: DOUBLE
51877: LD_INT 1
51879: DEC
51880: ST_TO_ADDR
51881: LD_VAR 0 5
51885: PUSH
51886: FOR_TO
51887: IFFALSE 51934
// begin hc_class := 21 ;
51889: LD_ADDR_OWVAR 28
51893: PUSH
51894: LD_INT 21
51896: ST_TO_ADDR
// hc_gallery :=  ;
51897: LD_ADDR_OWVAR 33
51901: PUSH
51902: LD_STRING 
51904: ST_TO_ADDR
// animal := CreateHuman ;
51905: LD_ADDR_VAR 0 12
51909: PUSH
51910: CALL_OW 44
51914: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
51915: LD_VAR 0 12
51919: PPUSH
51920: LD_VAR 0 8
51924: PPUSH
51925: LD_INT 0
51927: PPUSH
51928: CALL 54053 0 3
// end ;
51932: GO 51886
51934: POP
51935: POP
// if birds then
51936: LD_VAR 0 1
51940: IFFALSE 52007
// for i = 1 to birds do
51942: LD_ADDR_VAR 0 11
51946: PUSH
51947: DOUBLE
51948: LD_INT 1
51950: DEC
51951: ST_TO_ADDR
51952: LD_VAR 0 1
51956: PUSH
51957: FOR_TO
51958: IFFALSE 52005
// begin hc_class = 18 ;
51960: LD_ADDR_OWVAR 28
51964: PUSH
51965: LD_INT 18
51967: ST_TO_ADDR
// hc_gallery =  ;
51968: LD_ADDR_OWVAR 33
51972: PUSH
51973: LD_STRING 
51975: ST_TO_ADDR
// animal := CreateHuman ;
51976: LD_ADDR_VAR 0 12
51980: PUSH
51981: CALL_OW 44
51985: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
51986: LD_VAR 0 12
51990: PPUSH
51991: LD_VAR 0 8
51995: PPUSH
51996: LD_INT 0
51998: PPUSH
51999: CALL 54053 0 3
// end ;
52003: GO 51957
52005: POP
52006: POP
// if tigers then
52007: LD_VAR 0 2
52011: IFFALSE 52095
// for i = 1 to tigers do
52013: LD_ADDR_VAR 0 11
52017: PUSH
52018: DOUBLE
52019: LD_INT 1
52021: DEC
52022: ST_TO_ADDR
52023: LD_VAR 0 2
52027: PUSH
52028: FOR_TO
52029: IFFALSE 52093
// begin hc_class = class_tiger ;
52031: LD_ADDR_OWVAR 28
52035: PUSH
52036: LD_INT 14
52038: ST_TO_ADDR
// hc_gallery =  ;
52039: LD_ADDR_OWVAR 33
52043: PUSH
52044: LD_STRING 
52046: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
52047: LD_ADDR_OWVAR 35
52051: PUSH
52052: LD_INT 7
52054: NEG
52055: PPUSH
52056: LD_INT 7
52058: PPUSH
52059: CALL_OW 12
52063: ST_TO_ADDR
// animal := CreateHuman ;
52064: LD_ADDR_VAR 0 12
52068: PUSH
52069: CALL_OW 44
52073: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
52074: LD_VAR 0 12
52078: PPUSH
52079: LD_VAR 0 8
52083: PPUSH
52084: LD_INT 0
52086: PPUSH
52087: CALL 54053 0 3
// end ;
52091: GO 52028
52093: POP
52094: POP
// if apemans then
52095: LD_VAR 0 3
52099: IFFALSE 52222
// for i = 1 to apemans do
52101: LD_ADDR_VAR 0 11
52105: PUSH
52106: DOUBLE
52107: LD_INT 1
52109: DEC
52110: ST_TO_ADDR
52111: LD_VAR 0 3
52115: PUSH
52116: FOR_TO
52117: IFFALSE 52220
// begin hc_class = class_apeman ;
52119: LD_ADDR_OWVAR 28
52123: PUSH
52124: LD_INT 12
52126: ST_TO_ADDR
// hc_gallery =  ;
52127: LD_ADDR_OWVAR 33
52131: PUSH
52132: LD_STRING 
52134: ST_TO_ADDR
// hc_agressivity = rand ( - 5 , 5 ) ;
52135: LD_ADDR_OWVAR 35
52139: PUSH
52140: LD_INT 5
52142: NEG
52143: PPUSH
52144: LD_INT 5
52146: PPUSH
52147: CALL_OW 12
52151: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
52152: LD_ADDR_OWVAR 31
52156: PUSH
52157: LD_INT 1
52159: PPUSH
52160: LD_INT 3
52162: PPUSH
52163: CALL_OW 12
52167: PUSH
52168: LD_INT 1
52170: PPUSH
52171: LD_INT 3
52173: PPUSH
52174: CALL_OW 12
52178: PUSH
52179: LD_INT 0
52181: PUSH
52182: LD_INT 0
52184: PUSH
52185: EMPTY
52186: LIST
52187: LIST
52188: LIST
52189: LIST
52190: ST_TO_ADDR
// animal := CreateHuman ;
52191: LD_ADDR_VAR 0 12
52195: PUSH
52196: CALL_OW 44
52200: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
52201: LD_VAR 0 12
52205: PPUSH
52206: LD_VAR 0 8
52210: PPUSH
52211: LD_INT 0
52213: PPUSH
52214: CALL 54053 0 3
// end ;
52218: GO 52116
52220: POP
52221: POP
// if enchidnas then
52222: LD_VAR 0 4
52226: IFFALSE 52293
// for i = 1 to enchidnas do
52228: LD_ADDR_VAR 0 11
52232: PUSH
52233: DOUBLE
52234: LD_INT 1
52236: DEC
52237: ST_TO_ADDR
52238: LD_VAR 0 4
52242: PUSH
52243: FOR_TO
52244: IFFALSE 52291
// begin hc_class = 13 ;
52246: LD_ADDR_OWVAR 28
52250: PUSH
52251: LD_INT 13
52253: ST_TO_ADDR
// hc_gallery =  ;
52254: LD_ADDR_OWVAR 33
52258: PUSH
52259: LD_STRING 
52261: ST_TO_ADDR
// animal := CreateHuman ;
52262: LD_ADDR_VAR 0 12
52266: PUSH
52267: CALL_OW 44
52271: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
52272: LD_VAR 0 12
52276: PPUSH
52277: LD_VAR 0 8
52281: PPUSH
52282: LD_INT 0
52284: PPUSH
52285: CALL 54053 0 3
// end ;
52289: GO 52243
52291: POP
52292: POP
// if fishes then
52293: LD_VAR 0 7
52297: IFFALSE 52364
// for i = 1 to fishes do
52299: LD_ADDR_VAR 0 11
52303: PUSH
52304: DOUBLE
52305: LD_INT 1
52307: DEC
52308: ST_TO_ADDR
52309: LD_VAR 0 7
52313: PUSH
52314: FOR_TO
52315: IFFALSE 52362
// begin hc_class = 20 ;
52317: LD_ADDR_OWVAR 28
52321: PUSH
52322: LD_INT 20
52324: ST_TO_ADDR
// hc_gallery =  ;
52325: LD_ADDR_OWVAR 33
52329: PUSH
52330: LD_STRING 
52332: ST_TO_ADDR
// animal := CreateHuman ;
52333: LD_ADDR_VAR 0 12
52337: PUSH
52338: CALL_OW 44
52342: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
52343: LD_VAR 0 12
52347: PPUSH
52348: LD_VAR 0 9
52352: PPUSH
52353: LD_INT 0
52355: PPUSH
52356: CALL 54053 0 3
// end ;
52360: GO 52314
52362: POP
52363: POP
// end ;
52364: LD_VAR 0 10
52368: RET
// export function WantHeal ( sci , unit ) ; begin
52369: LD_INT 0
52371: PPUSH
// if GetTaskList ( sci ) > 0 then
52372: LD_VAR 0 1
52376: PPUSH
52377: CALL_OW 437
52381: PUSH
52382: LD_INT 0
52384: GREATER
52385: IFFALSE 52455
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
52387: LD_VAR 0 1
52391: PPUSH
52392: CALL_OW 437
52396: PUSH
52397: LD_INT 1
52399: ARRAY
52400: PUSH
52401: LD_INT 1
52403: ARRAY
52404: PUSH
52405: LD_STRING l
52407: EQUAL
52408: PUSH
52409: LD_VAR 0 1
52413: PPUSH
52414: CALL_OW 437
52418: PUSH
52419: LD_INT 1
52421: ARRAY
52422: PUSH
52423: LD_INT 4
52425: ARRAY
52426: PUSH
52427: LD_VAR 0 2
52431: EQUAL
52432: AND
52433: IFFALSE 52445
// result := true else
52435: LD_ADDR_VAR 0 3
52439: PUSH
52440: LD_INT 1
52442: ST_TO_ADDR
52443: GO 52453
// result := false ;
52445: LD_ADDR_VAR 0 3
52449: PUSH
52450: LD_INT 0
52452: ST_TO_ADDR
// end else
52453: GO 52463
// result := false ;
52455: LD_ADDR_VAR 0 3
52459: PUSH
52460: LD_INT 0
52462: ST_TO_ADDR
// end ;
52463: LD_VAR 0 3
52467: RET
// export function HealTarget ( sci ) ; begin
52468: LD_INT 0
52470: PPUSH
// if not sci then
52471: LD_VAR 0 1
52475: NOT
52476: IFFALSE 52480
// exit ;
52478: GO 52545
// result := 0 ;
52480: LD_ADDR_VAR 0 2
52484: PUSH
52485: LD_INT 0
52487: ST_TO_ADDR
// if GetTaskList ( sci ) then
52488: LD_VAR 0 1
52492: PPUSH
52493: CALL_OW 437
52497: IFFALSE 52545
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
52499: LD_VAR 0 1
52503: PPUSH
52504: CALL_OW 437
52508: PUSH
52509: LD_INT 1
52511: ARRAY
52512: PUSH
52513: LD_INT 1
52515: ARRAY
52516: PUSH
52517: LD_STRING l
52519: EQUAL
52520: IFFALSE 52545
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
52522: LD_ADDR_VAR 0 2
52526: PUSH
52527: LD_VAR 0 1
52531: PPUSH
52532: CALL_OW 437
52536: PUSH
52537: LD_INT 1
52539: ARRAY
52540: PUSH
52541: LD_INT 4
52543: ARRAY
52544: ST_TO_ADDR
// end ;
52545: LD_VAR 0 2
52549: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
52550: LD_INT 0
52552: PPUSH
52553: PPUSH
52554: PPUSH
52555: PPUSH
// if not base_units then
52556: LD_VAR 0 1
52560: NOT
52561: IFFALSE 52565
// exit ;
52563: GO 52652
// result := false ;
52565: LD_ADDR_VAR 0 2
52569: PUSH
52570: LD_INT 0
52572: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
52573: LD_ADDR_VAR 0 5
52577: PUSH
52578: LD_VAR 0 1
52582: PPUSH
52583: LD_INT 21
52585: PUSH
52586: LD_INT 3
52588: PUSH
52589: EMPTY
52590: LIST
52591: LIST
52592: PPUSH
52593: CALL_OW 72
52597: ST_TO_ADDR
// if not tmp then
52598: LD_VAR 0 5
52602: NOT
52603: IFFALSE 52607
// exit ;
52605: GO 52652
// for i in tmp do
52607: LD_ADDR_VAR 0 3
52611: PUSH
52612: LD_VAR 0 5
52616: PUSH
52617: FOR_IN
52618: IFFALSE 52650
// begin result := EnemyInRange ( i , 22 ) ;
52620: LD_ADDR_VAR 0 2
52624: PUSH
52625: LD_VAR 0 3
52629: PPUSH
52630: LD_INT 22
52632: PPUSH
52633: CALL 50888 0 2
52637: ST_TO_ADDR
// if result then
52638: LD_VAR 0 2
52642: IFFALSE 52648
// exit ;
52644: POP
52645: POP
52646: GO 52652
// end ;
52648: GO 52617
52650: POP
52651: POP
// end ;
52652: LD_VAR 0 2
52656: RET
// export function FilterByTag ( units , tag ) ; var i ; begin
52657: LD_INT 0
52659: PPUSH
52660: PPUSH
// if not units then
52661: LD_VAR 0 1
52665: NOT
52666: IFFALSE 52670
// exit ;
52668: GO 52740
// result := [ ] ;
52670: LD_ADDR_VAR 0 3
52674: PUSH
52675: EMPTY
52676: ST_TO_ADDR
// for i in units do
52677: LD_ADDR_VAR 0 4
52681: PUSH
52682: LD_VAR 0 1
52686: PUSH
52687: FOR_IN
52688: IFFALSE 52738
// if GetTag ( i ) = tag then
52690: LD_VAR 0 4
52694: PPUSH
52695: CALL_OW 110
52699: PUSH
52700: LD_VAR 0 2
52704: EQUAL
52705: IFFALSE 52736
// result := Insert ( result , result + 1 , i ) ;
52707: LD_ADDR_VAR 0 3
52711: PUSH
52712: LD_VAR 0 3
52716: PPUSH
52717: LD_VAR 0 3
52721: PUSH
52722: LD_INT 1
52724: PLUS
52725: PPUSH
52726: LD_VAR 0 4
52730: PPUSH
52731: CALL_OW 2
52735: ST_TO_ADDR
52736: GO 52687
52738: POP
52739: POP
// end ;
52740: LD_VAR 0 3
52744: RET
// export function IsDriver ( un ) ; begin
52745: LD_INT 0
52747: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
52748: LD_ADDR_VAR 0 2
52752: PUSH
52753: LD_VAR 0 1
52757: PUSH
52758: LD_INT 55
52760: PUSH
52761: EMPTY
52762: LIST
52763: PPUSH
52764: CALL_OW 69
52768: IN
52769: ST_TO_ADDR
// end ;
52770: LD_VAR 0 2
52774: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
52775: LD_INT 0
52777: PPUSH
52778: PPUSH
// list := [ ] ;
52779: LD_ADDR_VAR 0 5
52783: PUSH
52784: EMPTY
52785: ST_TO_ADDR
// case d of 0 :
52786: LD_VAR 0 3
52790: PUSH
52791: LD_INT 0
52793: DOUBLE
52794: EQUAL
52795: IFTRUE 52799
52797: GO 52932
52799: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
52800: LD_ADDR_VAR 0 5
52804: PUSH
52805: LD_VAR 0 1
52809: PUSH
52810: LD_INT 4
52812: MINUS
52813: PUSH
52814: LD_VAR 0 2
52818: PUSH
52819: LD_INT 4
52821: MINUS
52822: PUSH
52823: LD_INT 2
52825: PUSH
52826: EMPTY
52827: LIST
52828: LIST
52829: LIST
52830: PUSH
52831: LD_VAR 0 1
52835: PUSH
52836: LD_INT 3
52838: MINUS
52839: PUSH
52840: LD_VAR 0 2
52844: PUSH
52845: LD_INT 1
52847: PUSH
52848: EMPTY
52849: LIST
52850: LIST
52851: LIST
52852: PUSH
52853: LD_VAR 0 1
52857: PUSH
52858: LD_INT 4
52860: PLUS
52861: PUSH
52862: LD_VAR 0 2
52866: PUSH
52867: LD_INT 4
52869: PUSH
52870: EMPTY
52871: LIST
52872: LIST
52873: LIST
52874: PUSH
52875: LD_VAR 0 1
52879: PUSH
52880: LD_INT 3
52882: PLUS
52883: PUSH
52884: LD_VAR 0 2
52888: PUSH
52889: LD_INT 3
52891: PLUS
52892: PUSH
52893: LD_INT 5
52895: PUSH
52896: EMPTY
52897: LIST
52898: LIST
52899: LIST
52900: PUSH
52901: LD_VAR 0 1
52905: PUSH
52906: LD_VAR 0 2
52910: PUSH
52911: LD_INT 4
52913: PLUS
52914: PUSH
52915: LD_INT 0
52917: PUSH
52918: EMPTY
52919: LIST
52920: LIST
52921: LIST
52922: PUSH
52923: EMPTY
52924: LIST
52925: LIST
52926: LIST
52927: LIST
52928: LIST
52929: ST_TO_ADDR
// end ; 1 :
52930: GO 53630
52932: LD_INT 1
52934: DOUBLE
52935: EQUAL
52936: IFTRUE 52940
52938: GO 53073
52940: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
52941: LD_ADDR_VAR 0 5
52945: PUSH
52946: LD_VAR 0 1
52950: PUSH
52951: LD_VAR 0 2
52955: PUSH
52956: LD_INT 4
52958: MINUS
52959: PUSH
52960: LD_INT 3
52962: PUSH
52963: EMPTY
52964: LIST
52965: LIST
52966: LIST
52967: PUSH
52968: LD_VAR 0 1
52972: PUSH
52973: LD_INT 3
52975: MINUS
52976: PUSH
52977: LD_VAR 0 2
52981: PUSH
52982: LD_INT 3
52984: MINUS
52985: PUSH
52986: LD_INT 2
52988: PUSH
52989: EMPTY
52990: LIST
52991: LIST
52992: LIST
52993: PUSH
52994: LD_VAR 0 1
52998: PUSH
52999: LD_INT 4
53001: MINUS
53002: PUSH
53003: LD_VAR 0 2
53007: PUSH
53008: LD_INT 1
53010: PUSH
53011: EMPTY
53012: LIST
53013: LIST
53014: LIST
53015: PUSH
53016: LD_VAR 0 1
53020: PUSH
53021: LD_VAR 0 2
53025: PUSH
53026: LD_INT 3
53028: PLUS
53029: PUSH
53030: LD_INT 0
53032: PUSH
53033: EMPTY
53034: LIST
53035: LIST
53036: LIST
53037: PUSH
53038: LD_VAR 0 1
53042: PUSH
53043: LD_INT 4
53045: PLUS
53046: PUSH
53047: LD_VAR 0 2
53051: PUSH
53052: LD_INT 4
53054: PLUS
53055: PUSH
53056: LD_INT 5
53058: PUSH
53059: EMPTY
53060: LIST
53061: LIST
53062: LIST
53063: PUSH
53064: EMPTY
53065: LIST
53066: LIST
53067: LIST
53068: LIST
53069: LIST
53070: ST_TO_ADDR
// end ; 2 :
53071: GO 53630
53073: LD_INT 2
53075: DOUBLE
53076: EQUAL
53077: IFTRUE 53081
53079: GO 53210
53081: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
53082: LD_ADDR_VAR 0 5
53086: PUSH
53087: LD_VAR 0 1
53091: PUSH
53092: LD_VAR 0 2
53096: PUSH
53097: LD_INT 3
53099: MINUS
53100: PUSH
53101: LD_INT 3
53103: PUSH
53104: EMPTY
53105: LIST
53106: LIST
53107: LIST
53108: PUSH
53109: LD_VAR 0 1
53113: PUSH
53114: LD_INT 4
53116: PLUS
53117: PUSH
53118: LD_VAR 0 2
53122: PUSH
53123: LD_INT 4
53125: PUSH
53126: EMPTY
53127: LIST
53128: LIST
53129: LIST
53130: PUSH
53131: LD_VAR 0 1
53135: PUSH
53136: LD_VAR 0 2
53140: PUSH
53141: LD_INT 4
53143: PLUS
53144: PUSH
53145: LD_INT 0
53147: PUSH
53148: EMPTY
53149: LIST
53150: LIST
53151: LIST
53152: PUSH
53153: LD_VAR 0 1
53157: PUSH
53158: LD_INT 3
53160: MINUS
53161: PUSH
53162: LD_VAR 0 2
53166: PUSH
53167: LD_INT 1
53169: PUSH
53170: EMPTY
53171: LIST
53172: LIST
53173: LIST
53174: PUSH
53175: LD_VAR 0 1
53179: PUSH
53180: LD_INT 4
53182: MINUS
53183: PUSH
53184: LD_VAR 0 2
53188: PUSH
53189: LD_INT 4
53191: MINUS
53192: PUSH
53193: LD_INT 2
53195: PUSH
53196: EMPTY
53197: LIST
53198: LIST
53199: LIST
53200: PUSH
53201: EMPTY
53202: LIST
53203: LIST
53204: LIST
53205: LIST
53206: LIST
53207: ST_TO_ADDR
// end ; 3 :
53208: GO 53630
53210: LD_INT 3
53212: DOUBLE
53213: EQUAL
53214: IFTRUE 53218
53216: GO 53351
53218: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
53219: LD_ADDR_VAR 0 5
53223: PUSH
53224: LD_VAR 0 1
53228: PUSH
53229: LD_INT 3
53231: PLUS
53232: PUSH
53233: LD_VAR 0 2
53237: PUSH
53238: LD_INT 4
53240: PUSH
53241: EMPTY
53242: LIST
53243: LIST
53244: LIST
53245: PUSH
53246: LD_VAR 0 1
53250: PUSH
53251: LD_INT 4
53253: PLUS
53254: PUSH
53255: LD_VAR 0 2
53259: PUSH
53260: LD_INT 4
53262: PLUS
53263: PUSH
53264: LD_INT 5
53266: PUSH
53267: EMPTY
53268: LIST
53269: LIST
53270: LIST
53271: PUSH
53272: LD_VAR 0 1
53276: PUSH
53277: LD_INT 4
53279: MINUS
53280: PUSH
53281: LD_VAR 0 2
53285: PUSH
53286: LD_INT 1
53288: PUSH
53289: EMPTY
53290: LIST
53291: LIST
53292: LIST
53293: PUSH
53294: LD_VAR 0 1
53298: PUSH
53299: LD_VAR 0 2
53303: PUSH
53304: LD_INT 4
53306: MINUS
53307: PUSH
53308: LD_INT 3
53310: PUSH
53311: EMPTY
53312: LIST
53313: LIST
53314: LIST
53315: PUSH
53316: LD_VAR 0 1
53320: PUSH
53321: LD_INT 3
53323: MINUS
53324: PUSH
53325: LD_VAR 0 2
53329: PUSH
53330: LD_INT 3
53332: MINUS
53333: PUSH
53334: LD_INT 2
53336: PUSH
53337: EMPTY
53338: LIST
53339: LIST
53340: LIST
53341: PUSH
53342: EMPTY
53343: LIST
53344: LIST
53345: LIST
53346: LIST
53347: LIST
53348: ST_TO_ADDR
// end ; 4 :
53349: GO 53630
53351: LD_INT 4
53353: DOUBLE
53354: EQUAL
53355: IFTRUE 53359
53357: GO 53492
53359: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
53360: LD_ADDR_VAR 0 5
53364: PUSH
53365: LD_VAR 0 1
53369: PUSH
53370: LD_VAR 0 2
53374: PUSH
53375: LD_INT 4
53377: PLUS
53378: PUSH
53379: LD_INT 0
53381: PUSH
53382: EMPTY
53383: LIST
53384: LIST
53385: LIST
53386: PUSH
53387: LD_VAR 0 1
53391: PUSH
53392: LD_INT 3
53394: PLUS
53395: PUSH
53396: LD_VAR 0 2
53400: PUSH
53401: LD_INT 3
53403: PLUS
53404: PUSH
53405: LD_INT 5
53407: PUSH
53408: EMPTY
53409: LIST
53410: LIST
53411: LIST
53412: PUSH
53413: LD_VAR 0 1
53417: PUSH
53418: LD_INT 4
53420: PLUS
53421: PUSH
53422: LD_VAR 0 2
53426: PUSH
53427: LD_INT 4
53429: PUSH
53430: EMPTY
53431: LIST
53432: LIST
53433: LIST
53434: PUSH
53435: LD_VAR 0 1
53439: PUSH
53440: LD_VAR 0 2
53444: PUSH
53445: LD_INT 3
53447: MINUS
53448: PUSH
53449: LD_INT 3
53451: PUSH
53452: EMPTY
53453: LIST
53454: LIST
53455: LIST
53456: PUSH
53457: LD_VAR 0 1
53461: PUSH
53462: LD_INT 4
53464: MINUS
53465: PUSH
53466: LD_VAR 0 2
53470: PUSH
53471: LD_INT 4
53473: MINUS
53474: PUSH
53475: LD_INT 2
53477: PUSH
53478: EMPTY
53479: LIST
53480: LIST
53481: LIST
53482: PUSH
53483: EMPTY
53484: LIST
53485: LIST
53486: LIST
53487: LIST
53488: LIST
53489: ST_TO_ADDR
// end ; 5 :
53490: GO 53630
53492: LD_INT 5
53494: DOUBLE
53495: EQUAL
53496: IFTRUE 53500
53498: GO 53629
53500: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
53501: LD_ADDR_VAR 0 5
53505: PUSH
53506: LD_VAR 0 1
53510: PUSH
53511: LD_INT 4
53513: MINUS
53514: PUSH
53515: LD_VAR 0 2
53519: PUSH
53520: LD_INT 1
53522: PUSH
53523: EMPTY
53524: LIST
53525: LIST
53526: LIST
53527: PUSH
53528: LD_VAR 0 1
53532: PUSH
53533: LD_VAR 0 2
53537: PUSH
53538: LD_INT 4
53540: MINUS
53541: PUSH
53542: LD_INT 3
53544: PUSH
53545: EMPTY
53546: LIST
53547: LIST
53548: LIST
53549: PUSH
53550: LD_VAR 0 1
53554: PUSH
53555: LD_INT 4
53557: PLUS
53558: PUSH
53559: LD_VAR 0 2
53563: PUSH
53564: LD_INT 4
53566: PLUS
53567: PUSH
53568: LD_INT 5
53570: PUSH
53571: EMPTY
53572: LIST
53573: LIST
53574: LIST
53575: PUSH
53576: LD_VAR 0 1
53580: PUSH
53581: LD_INT 3
53583: PLUS
53584: PUSH
53585: LD_VAR 0 2
53589: PUSH
53590: LD_INT 4
53592: PUSH
53593: EMPTY
53594: LIST
53595: LIST
53596: LIST
53597: PUSH
53598: LD_VAR 0 1
53602: PUSH
53603: LD_VAR 0 2
53607: PUSH
53608: LD_INT 3
53610: PLUS
53611: PUSH
53612: LD_INT 0
53614: PUSH
53615: EMPTY
53616: LIST
53617: LIST
53618: LIST
53619: PUSH
53620: EMPTY
53621: LIST
53622: LIST
53623: LIST
53624: LIST
53625: LIST
53626: ST_TO_ADDR
// end ; end ;
53627: GO 53630
53629: POP
// result := list ;
53630: LD_ADDR_VAR 0 4
53634: PUSH
53635: LD_VAR 0 5
53639: ST_TO_ADDR
// end ;
53640: LD_VAR 0 4
53644: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
53645: LD_INT 0
53647: PPUSH
53648: PPUSH
53649: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
53650: LD_VAR 0 1
53654: NOT
53655: PUSH
53656: LD_VAR 0 2
53660: PUSH
53661: LD_INT 1
53663: PUSH
53664: LD_INT 2
53666: PUSH
53667: LD_INT 3
53669: PUSH
53670: LD_INT 4
53672: PUSH
53673: EMPTY
53674: LIST
53675: LIST
53676: LIST
53677: LIST
53678: IN
53679: NOT
53680: OR
53681: IFFALSE 53685
// exit ;
53683: GO 53777
// tmp := [ ] ;
53685: LD_ADDR_VAR 0 5
53689: PUSH
53690: EMPTY
53691: ST_TO_ADDR
// for i in units do
53692: LD_ADDR_VAR 0 4
53696: PUSH
53697: LD_VAR 0 1
53701: PUSH
53702: FOR_IN
53703: IFFALSE 53746
// tmp := Insert ( tmp , tmp + 1 , GetSkill ( i , class ) ) ;
53705: LD_ADDR_VAR 0 5
53709: PUSH
53710: LD_VAR 0 5
53714: PPUSH
53715: LD_VAR 0 5
53719: PUSH
53720: LD_INT 1
53722: PLUS
53723: PPUSH
53724: LD_VAR 0 4
53728: PPUSH
53729: LD_VAR 0 2
53733: PPUSH
53734: CALL_OW 259
53738: PPUSH
53739: CALL_OW 2
53743: ST_TO_ADDR
53744: GO 53702
53746: POP
53747: POP
// if not tmp then
53748: LD_VAR 0 5
53752: NOT
53753: IFFALSE 53757
// exit ;
53755: GO 53777
// result := SortListByListDesc ( units , tmp ) ;
53757: LD_ADDR_VAR 0 3
53761: PUSH
53762: LD_VAR 0 1
53766: PPUSH
53767: LD_VAR 0 5
53771: PPUSH
53772: CALL_OW 77
53776: ST_TO_ADDR
// end ;
53777: LD_VAR 0 3
53781: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
53782: LD_INT 0
53784: PPUSH
53785: PPUSH
53786: PPUSH
// result := false ;
53787: LD_ADDR_VAR 0 3
53791: PUSH
53792: LD_INT 0
53794: ST_TO_ADDR
// x := GetX ( building ) ;
53795: LD_ADDR_VAR 0 4
53799: PUSH
53800: LD_VAR 0 2
53804: PPUSH
53805: CALL_OW 250
53809: ST_TO_ADDR
// y := GetY ( building ) ;
53810: LD_ADDR_VAR 0 5
53814: PUSH
53815: LD_VAR 0 2
53819: PPUSH
53820: CALL_OW 251
53824: ST_TO_ADDR
// if not building or not x or not y then
53825: LD_VAR 0 2
53829: NOT
53830: PUSH
53831: LD_VAR 0 4
53835: NOT
53836: OR
53837: PUSH
53838: LD_VAR 0 5
53842: NOT
53843: OR
53844: IFFALSE 53848
// exit ;
53846: GO 53940
// if GetTaskList ( unit ) then
53848: LD_VAR 0 1
53852: PPUSH
53853: CALL_OW 437
53857: IFFALSE 53940
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
53859: LD_STRING e
53861: PUSH
53862: LD_VAR 0 1
53866: PPUSH
53867: CALL_OW 437
53871: PUSH
53872: LD_INT 1
53874: ARRAY
53875: PUSH
53876: LD_INT 1
53878: ARRAY
53879: EQUAL
53880: PUSH
53881: LD_VAR 0 4
53885: PUSH
53886: LD_VAR 0 1
53890: PPUSH
53891: CALL_OW 437
53895: PUSH
53896: LD_INT 1
53898: ARRAY
53899: PUSH
53900: LD_INT 2
53902: ARRAY
53903: EQUAL
53904: AND
53905: PUSH
53906: LD_VAR 0 5
53910: PUSH
53911: LD_VAR 0 1
53915: PPUSH
53916: CALL_OW 437
53920: PUSH
53921: LD_INT 1
53923: ARRAY
53924: PUSH
53925: LD_INT 3
53927: ARRAY
53928: EQUAL
53929: AND
53930: IFFALSE 53940
// result := true end ;
53932: LD_ADDR_VAR 0 3
53936: PUSH
53937: LD_INT 1
53939: ST_TO_ADDR
// end ;
53940: LD_VAR 0 3
53944: RET
// export function UnitGoingToXY ( unit , x , y ) ; begin
53945: LD_INT 0
53947: PPUSH
// result := false ;
53948: LD_ADDR_VAR 0 4
53952: PUSH
53953: LD_INT 0
53955: ST_TO_ADDR
// if GetTaskList ( unit ) then
53956: LD_VAR 0 1
53960: PPUSH
53961: CALL_OW 437
53965: IFFALSE 54048
// begin if M = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
53967: LD_STRING M
53969: PUSH
53970: LD_VAR 0 1
53974: PPUSH
53975: CALL_OW 437
53979: PUSH
53980: LD_INT 1
53982: ARRAY
53983: PUSH
53984: LD_INT 1
53986: ARRAY
53987: EQUAL
53988: PUSH
53989: LD_VAR 0 2
53993: PUSH
53994: LD_VAR 0 1
53998: PPUSH
53999: CALL_OW 437
54003: PUSH
54004: LD_INT 1
54006: ARRAY
54007: PUSH
54008: LD_INT 2
54010: ARRAY
54011: EQUAL
54012: AND
54013: PUSH
54014: LD_VAR 0 3
54018: PUSH
54019: LD_VAR 0 1
54023: PPUSH
54024: CALL_OW 437
54028: PUSH
54029: LD_INT 1
54031: ARRAY
54032: PUSH
54033: LD_INT 3
54035: ARRAY
54036: EQUAL
54037: AND
54038: IFFALSE 54048
// result := true ;
54040: LD_ADDR_VAR 0 4
54044: PUSH
54045: LD_INT 1
54047: ST_TO_ADDR
// end ; end ;
54048: LD_VAR 0 4
54052: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
54053: LD_INT 0
54055: PPUSH
54056: PPUSH
54057: PPUSH
54058: PPUSH
// if not unit or not area then
54059: LD_VAR 0 1
54063: NOT
54064: PUSH
54065: LD_VAR 0 2
54069: NOT
54070: OR
54071: IFFALSE 54075
// exit ;
54073: GO 54239
// tmp := AreaToList ( area , i ) ;
54075: LD_ADDR_VAR 0 6
54079: PUSH
54080: LD_VAR 0 2
54084: PPUSH
54085: LD_VAR 0 5
54089: PPUSH
54090: CALL_OW 517
54094: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
54095: LD_ADDR_VAR 0 5
54099: PUSH
54100: DOUBLE
54101: LD_INT 1
54103: DEC
54104: ST_TO_ADDR
54105: LD_VAR 0 6
54109: PUSH
54110: LD_INT 1
54112: ARRAY
54113: PUSH
54114: FOR_TO
54115: IFFALSE 54237
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
54117: LD_ADDR_VAR 0 7
54121: PUSH
54122: LD_VAR 0 6
54126: PUSH
54127: LD_INT 1
54129: ARRAY
54130: PUSH
54131: LD_VAR 0 5
54135: ARRAY
54136: PUSH
54137: LD_VAR 0 6
54141: PUSH
54142: LD_INT 2
54144: ARRAY
54145: PUSH
54146: LD_VAR 0 5
54150: ARRAY
54151: PUSH
54152: EMPTY
54153: LIST
54154: LIST
54155: ST_TO_ADDR
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
54156: LD_VAR 0 7
54160: PUSH
54161: LD_INT 1
54163: ARRAY
54164: PPUSH
54165: LD_VAR 0 7
54169: PUSH
54170: LD_INT 2
54172: ARRAY
54173: PPUSH
54174: CALL_OW 428
54178: PUSH
54179: LD_INT 0
54181: EQUAL
54182: IFFALSE 54235
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
54184: LD_VAR 0 1
54188: PPUSH
54189: LD_VAR 0 7
54193: PUSH
54194: LD_INT 1
54196: ARRAY
54197: PPUSH
54198: LD_VAR 0 7
54202: PUSH
54203: LD_INT 2
54205: ARRAY
54206: PPUSH
54207: LD_VAR 0 3
54211: PPUSH
54212: CALL_OW 48
// result := IsPlaced ( unit ) ;
54216: LD_ADDR_VAR 0 4
54220: PUSH
54221: LD_VAR 0 1
54225: PPUSH
54226: CALL_OW 305
54230: ST_TO_ADDR
// exit ;
54231: POP
54232: POP
54233: GO 54239
// end ; end ;
54235: GO 54114
54237: POP
54238: POP
// end ;
54239: LD_VAR 0 4
54243: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
54244: LD_INT 0
54246: PPUSH
54247: PPUSH
54248: PPUSH
// if not side or side > 8 then
54249: LD_VAR 0 1
54253: NOT
54254: PUSH
54255: LD_VAR 0 1
54259: PUSH
54260: LD_INT 8
54262: GREATER
54263: OR
54264: IFFALSE 54268
// exit ;
54266: GO 54455
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
54268: LD_ADDR_VAR 0 4
54272: PUSH
54273: LD_INT 22
54275: PUSH
54276: LD_VAR 0 1
54280: PUSH
54281: EMPTY
54282: LIST
54283: LIST
54284: PUSH
54285: LD_INT 21
54287: PUSH
54288: LD_INT 3
54290: PUSH
54291: EMPTY
54292: LIST
54293: LIST
54294: PUSH
54295: EMPTY
54296: LIST
54297: LIST
54298: PPUSH
54299: CALL_OW 69
54303: ST_TO_ADDR
// if not tmp then
54304: LD_VAR 0 4
54308: NOT
54309: IFFALSE 54313
// exit ;
54311: GO 54455
// enable_addtolog := true ;
54313: LD_ADDR_OWVAR 81
54317: PUSH
54318: LD_INT 1
54320: ST_TO_ADDR
// AddToLog ( [ ) ;
54321: LD_STRING [
54323: PPUSH
54324: CALL_OW 561
// for i in tmp do
54328: LD_ADDR_VAR 0 3
54332: PUSH
54333: LD_VAR 0 4
54337: PUSH
54338: FOR_IN
54339: IFFALSE 54446
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
54341: LD_STRING [
54343: PUSH
54344: LD_VAR 0 3
54348: PPUSH
54349: CALL_OW 266
54353: STR
54354: PUSH
54355: LD_STRING , 
54357: STR
54358: PUSH
54359: LD_VAR 0 3
54363: PPUSH
54364: CALL_OW 250
54368: STR
54369: PUSH
54370: LD_STRING , 
54372: STR
54373: PUSH
54374: LD_VAR 0 3
54378: PPUSH
54379: CALL_OW 251
54383: STR
54384: PUSH
54385: LD_STRING , 
54387: STR
54388: PUSH
54389: LD_VAR 0 3
54393: PPUSH
54394: CALL_OW 254
54398: STR
54399: PUSH
54400: LD_STRING , 
54402: STR
54403: PUSH
54404: LD_VAR 0 3
54408: PPUSH
54409: LD_INT 1
54411: PPUSH
54412: CALL_OW 268
54416: STR
54417: PUSH
54418: LD_STRING , 
54420: STR
54421: PUSH
54422: LD_VAR 0 3
54426: PPUSH
54427: LD_INT 2
54429: PPUSH
54430: CALL_OW 268
54434: STR
54435: PUSH
54436: LD_STRING ],
54438: STR
54439: PPUSH
54440: CALL_OW 561
// end ;
54444: GO 54338
54446: POP
54447: POP
// AddToLog ( ]; ) ;
54448: LD_STRING ];
54450: PPUSH
54451: CALL_OW 561
// end ;
54455: LD_VAR 0 2
54459: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
54460: LD_INT 0
54462: PPUSH
54463: PPUSH
54464: PPUSH
54465: PPUSH
54466: PPUSH
// if not area or not rate or not max then
54467: LD_VAR 0 1
54471: NOT
54472: PUSH
54473: LD_VAR 0 2
54477: NOT
54478: OR
54479: PUSH
54480: LD_VAR 0 4
54484: NOT
54485: OR
54486: IFFALSE 54490
// exit ;
54488: GO 54682
// while 1 do
54490: LD_INT 1
54492: IFFALSE 54682
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
54494: LD_ADDR_VAR 0 9
54498: PUSH
54499: LD_VAR 0 1
54503: PPUSH
54504: LD_INT 1
54506: PPUSH
54507: CALL_OW 287
54511: PUSH
54512: LD_INT 10
54514: MUL
54515: ST_TO_ADDR
// r := rate / 10 ;
54516: LD_ADDR_VAR 0 7
54520: PUSH
54521: LD_VAR 0 2
54525: PUSH
54526: LD_INT 10
54528: DIVREAL
54529: ST_TO_ADDR
// time := 1 1$00 ;
54530: LD_ADDR_VAR 0 8
54534: PUSH
54535: LD_INT 2100
54537: ST_TO_ADDR
// if amount < min then
54538: LD_VAR 0 9
54542: PUSH
54543: LD_VAR 0 3
54547: LESS
54548: IFFALSE 54566
// r := r * 2 else
54550: LD_ADDR_VAR 0 7
54554: PUSH
54555: LD_VAR 0 7
54559: PUSH
54560: LD_INT 2
54562: MUL
54563: ST_TO_ADDR
54564: GO 54592
// if amount > max then
54566: LD_VAR 0 9
54570: PUSH
54571: LD_VAR 0 4
54575: GREATER
54576: IFFALSE 54592
// r := r / 2 ;
54578: LD_ADDR_VAR 0 7
54582: PUSH
54583: LD_VAR 0 7
54587: PUSH
54588: LD_INT 2
54590: DIVREAL
54591: ST_TO_ADDR
// time := time / r ;
54592: LD_ADDR_VAR 0 8
54596: PUSH
54597: LD_VAR 0 8
54601: PUSH
54602: LD_VAR 0 7
54606: DIVREAL
54607: ST_TO_ADDR
// if time < 0 then
54608: LD_VAR 0 8
54612: PUSH
54613: LD_INT 0
54615: LESS
54616: IFFALSE 54633
// time := time * - 1 ;
54618: LD_ADDR_VAR 0 8
54622: PUSH
54623: LD_VAR 0 8
54627: PUSH
54628: LD_INT 1
54630: NEG
54631: MUL
54632: ST_TO_ADDR
// wait ( time ) ;
54633: LD_VAR 0 8
54637: PPUSH
54638: CALL_OW 67
// wait ( rand ( 0 0$01 , 0 0$25 ) ) ;
54642: LD_INT 35
54644: PPUSH
54645: LD_INT 875
54647: PPUSH
54648: CALL_OW 12
54652: PPUSH
54653: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
54657: LD_INT 1
54659: PPUSH
54660: LD_INT 5
54662: PPUSH
54663: CALL_OW 12
54667: PPUSH
54668: LD_VAR 0 1
54672: PPUSH
54673: LD_INT 1
54675: PPUSH
54676: CALL_OW 55
// end ;
54680: GO 54490
// end ;
54682: LD_VAR 0 5
54686: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
54687: LD_INT 0
54689: PPUSH
54690: PPUSH
54691: PPUSH
54692: PPUSH
54693: PPUSH
54694: PPUSH
54695: PPUSH
54696: PPUSH
// if not turrets or not factories then
54697: LD_VAR 0 1
54701: NOT
54702: PUSH
54703: LD_VAR 0 2
54707: NOT
54708: OR
54709: IFFALSE 54713
// exit ;
54711: GO 55020
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
54713: LD_ADDR_VAR 0 10
54717: PUSH
54718: LD_INT 5
54720: PUSH
54721: LD_INT 6
54723: PUSH
54724: EMPTY
54725: LIST
54726: LIST
54727: PUSH
54728: LD_INT 2
54730: PUSH
54731: LD_INT 4
54733: PUSH
54734: EMPTY
54735: LIST
54736: LIST
54737: PUSH
54738: LD_INT 3
54740: PUSH
54741: LD_INT 5
54743: PUSH
54744: EMPTY
54745: LIST
54746: LIST
54747: PUSH
54748: EMPTY
54749: LIST
54750: LIST
54751: LIST
54752: PUSH
54753: LD_INT 24
54755: PUSH
54756: LD_INT 25
54758: PUSH
54759: EMPTY
54760: LIST
54761: LIST
54762: PUSH
54763: LD_INT 23
54765: PUSH
54766: LD_INT 27
54768: PUSH
54769: EMPTY
54770: LIST
54771: LIST
54772: PUSH
54773: EMPTY
54774: LIST
54775: LIST
54776: PUSH
54777: LD_INT 42
54779: PUSH
54780: LD_INT 43
54782: PUSH
54783: EMPTY
54784: LIST
54785: LIST
54786: PUSH
54787: LD_INT 44
54789: PUSH
54790: LD_INT 46
54792: PUSH
54793: EMPTY
54794: LIST
54795: LIST
54796: PUSH
54797: LD_INT 45
54799: PUSH
54800: LD_INT 47
54802: PUSH
54803: EMPTY
54804: LIST
54805: LIST
54806: PUSH
54807: EMPTY
54808: LIST
54809: LIST
54810: LIST
54811: PUSH
54812: EMPTY
54813: LIST
54814: LIST
54815: LIST
54816: ST_TO_ADDR
// result := [ ] ;
54817: LD_ADDR_VAR 0 3
54821: PUSH
54822: EMPTY
54823: ST_TO_ADDR
// for i in turrets do
54824: LD_ADDR_VAR 0 4
54828: PUSH
54829: LD_VAR 0 1
54833: PUSH
54834: FOR_IN
54835: IFFALSE 55018
// begin nat := GetNation ( i ) ;
54837: LD_ADDR_VAR 0 7
54841: PUSH
54842: LD_VAR 0 4
54846: PPUSH
54847: CALL_OW 248
54851: ST_TO_ADDR
// weapon := 0 ;
54852: LD_ADDR_VAR 0 8
54856: PUSH
54857: LD_INT 0
54859: ST_TO_ADDR
// if not nat then
54860: LD_VAR 0 7
54864: NOT
54865: IFFALSE 54869
// continue ;
54867: GO 54834
// for j in list [ nat ] do
54869: LD_ADDR_VAR 0 5
54873: PUSH
54874: LD_VAR 0 10
54878: PUSH
54879: LD_VAR 0 7
54883: ARRAY
54884: PUSH
54885: FOR_IN
54886: IFFALSE 54927
// if GetBWeapon ( i ) = j [ 1 ] then
54888: LD_VAR 0 4
54892: PPUSH
54893: CALL_OW 269
54897: PUSH
54898: LD_VAR 0 5
54902: PUSH
54903: LD_INT 1
54905: ARRAY
54906: EQUAL
54907: IFFALSE 54925
// begin weapon := j [ 2 ] ;
54909: LD_ADDR_VAR 0 8
54913: PUSH
54914: LD_VAR 0 5
54918: PUSH
54919: LD_INT 2
54921: ARRAY
54922: ST_TO_ADDR
// break ;
54923: GO 54927
// end ;
54925: GO 54885
54927: POP
54928: POP
// if not weapon then
54929: LD_VAR 0 8
54933: NOT
54934: IFFALSE 54938
// continue ;
54936: GO 54834
// for k in factories do
54938: LD_ADDR_VAR 0 6
54942: PUSH
54943: LD_VAR 0 2
54947: PUSH
54948: FOR_IN
54949: IFFALSE 55014
// begin weapons := AvailableWeaponList ( k ) ;
54951: LD_ADDR_VAR 0 9
54955: PUSH
54956: LD_VAR 0 6
54960: PPUSH
54961: CALL_OW 478
54965: ST_TO_ADDR
// if not weapons then
54966: LD_VAR 0 9
54970: NOT
54971: IFFALSE 54975
// continue ;
54973: GO 54948
// if weapon in weapons then
54975: LD_VAR 0 8
54979: PUSH
54980: LD_VAR 0 9
54984: IN
54985: IFFALSE 55012
// begin result := [ i , weapon ] ;
54987: LD_ADDR_VAR 0 3
54991: PUSH
54992: LD_VAR 0 4
54996: PUSH
54997: LD_VAR 0 8
55001: PUSH
55002: EMPTY
55003: LIST
55004: LIST
55005: ST_TO_ADDR
// exit ;
55006: POP
55007: POP
55008: POP
55009: POP
55010: GO 55020
// end ; end ;
55012: GO 54948
55014: POP
55015: POP
// end ;
55016: GO 54834
55018: POP
55019: POP
// end ;
55020: LD_VAR 0 3
55024: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
55025: LD_INT 0
55027: PPUSH
// if not side or side > 8 then
55028: LD_VAR 0 3
55032: NOT
55033: PUSH
55034: LD_VAR 0 3
55038: PUSH
55039: LD_INT 8
55041: GREATER
55042: OR
55043: IFFALSE 55047
// exit ;
55045: GO 55106
// if not range then
55047: LD_VAR 0 4
55051: NOT
55052: IFFALSE 55063
// range := - 12 ;
55054: LD_ADDR_VAR 0 4
55058: PUSH
55059: LD_INT 12
55061: NEG
55062: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
55063: LD_VAR 0 1
55067: PPUSH
55068: LD_VAR 0 2
55072: PPUSH
55073: LD_VAR 0 3
55077: PPUSH
55078: LD_VAR 0 4
55082: PPUSH
55083: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
55087: LD_VAR 0 1
55091: PPUSH
55092: LD_VAR 0 2
55096: PPUSH
55097: LD_VAR 0 3
55101: PPUSH
55102: CALL_OW 331
// end ;
55106: LD_VAR 0 5
55110: RET
// export function Video ( mode ) ; begin
55111: LD_INT 0
55113: PPUSH
// ingame_video = mode ;
55114: LD_ADDR_OWVAR 52
55118: PUSH
55119: LD_VAR 0 1
55123: ST_TO_ADDR
// interface_hidden = mode ;
55124: LD_ADDR_OWVAR 54
55128: PUSH
55129: LD_VAR 0 1
55133: ST_TO_ADDR
// end ;
55134: LD_VAR 0 2
55138: RET
// export function Join ( array , element ) ; begin
55139: LD_INT 0
55141: PPUSH
// result := Replace ( array , array + 1 , element ) ;
55142: LD_ADDR_VAR 0 3
55146: PUSH
55147: LD_VAR 0 1
55151: PPUSH
55152: LD_VAR 0 1
55156: PUSH
55157: LD_INT 1
55159: PLUS
55160: PPUSH
55161: LD_VAR 0 2
55165: PPUSH
55166: CALL_OW 1
55170: ST_TO_ADDR
// end ;
55171: LD_VAR 0 3
55175: RET
// export function JoinUnion ( array , element ) ; begin
55176: LD_INT 0
55178: PPUSH
// result := array union element ;
55179: LD_ADDR_VAR 0 3
55183: PUSH
55184: LD_VAR 0 1
55188: PUSH
55189: LD_VAR 0 2
55193: UNION
55194: ST_TO_ADDR
// end ;
55195: LD_VAR 0 3
55199: RET
// export function GetBehemoths ( side ) ; begin
55200: LD_INT 0
55202: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , 25 ] ] ) ;
55203: LD_ADDR_VAR 0 2
55207: PUSH
55208: LD_INT 22
55210: PUSH
55211: LD_VAR 0 1
55215: PUSH
55216: EMPTY
55217: LIST
55218: LIST
55219: PUSH
55220: LD_INT 31
55222: PUSH
55223: LD_INT 25
55225: PUSH
55226: EMPTY
55227: LIST
55228: LIST
55229: PUSH
55230: EMPTY
55231: LIST
55232: LIST
55233: PPUSH
55234: CALL_OW 69
55238: ST_TO_ADDR
// end ;
55239: LD_VAR 0 2
55243: RET
// export function Shuffle ( array ) ; var i , index ; begin
55244: LD_INT 0
55246: PPUSH
55247: PPUSH
55248: PPUSH
// result := [ ] ;
55249: LD_ADDR_VAR 0 2
55253: PUSH
55254: EMPTY
55255: ST_TO_ADDR
// if not array then
55256: LD_VAR 0 1
55260: NOT
55261: IFFALSE 55265
// exit ;
55263: GO 55364
// Randomize ;
55265: CALL_OW 10
// for i = array downto 1 do
55269: LD_ADDR_VAR 0 3
55273: PUSH
55274: DOUBLE
55275: LD_VAR 0 1
55279: INC
55280: ST_TO_ADDR
55281: LD_INT 1
55283: PUSH
55284: FOR_DOWNTO
55285: IFFALSE 55362
// begin index := rand ( 1 , array ) ;
55287: LD_ADDR_VAR 0 4
55291: PUSH
55292: LD_INT 1
55294: PPUSH
55295: LD_VAR 0 1
55299: PPUSH
55300: CALL_OW 12
55304: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
55305: LD_ADDR_VAR 0 2
55309: PUSH
55310: LD_VAR 0 2
55314: PPUSH
55315: LD_VAR 0 2
55319: PUSH
55320: LD_INT 1
55322: PLUS
55323: PPUSH
55324: LD_VAR 0 1
55328: PUSH
55329: LD_VAR 0 4
55333: ARRAY
55334: PPUSH
55335: CALL_OW 2
55339: ST_TO_ADDR
// array := Delete ( array , index ) ;
55340: LD_ADDR_VAR 0 1
55344: PUSH
55345: LD_VAR 0 1
55349: PPUSH
55350: LD_VAR 0 4
55354: PPUSH
55355: CALL_OW 3
55359: ST_TO_ADDR
// end ;
55360: GO 55284
55362: POP
55363: POP
// end ;
55364: LD_VAR 0 2
55368: RET
// export function GetBaseMaterials ( base ) ; begin
55369: LD_INT 0
55371: PPUSH
// result := [ 0 , 0 , 0 ] ;
55372: LD_ADDR_VAR 0 2
55376: PUSH
55377: LD_INT 0
55379: PUSH
55380: LD_INT 0
55382: PUSH
55383: LD_INT 0
55385: PUSH
55386: EMPTY
55387: LIST
55388: LIST
55389: LIST
55390: ST_TO_ADDR
// if not base then
55391: LD_VAR 0 1
55395: NOT
55396: IFFALSE 55400
// exit ;
55398: GO 55449
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
55400: LD_ADDR_VAR 0 2
55404: PUSH
55405: LD_VAR 0 1
55409: PPUSH
55410: LD_INT 1
55412: PPUSH
55413: CALL_OW 275
55417: PUSH
55418: LD_VAR 0 1
55422: PPUSH
55423: LD_INT 2
55425: PPUSH
55426: CALL_OW 275
55430: PUSH
55431: LD_VAR 0 1
55435: PPUSH
55436: LD_INT 3
55438: PPUSH
55439: CALL_OW 275
55443: PUSH
55444: EMPTY
55445: LIST
55446: LIST
55447: LIST
55448: ST_TO_ADDR
// end ;
55449: LD_VAR 0 2
55453: RET
// export function ShrinkArray ( array , size ) ; var i ; begin
55454: LD_INT 0
55456: PPUSH
55457: PPUSH
// result := array ;
55458: LD_ADDR_VAR 0 3
55462: PUSH
55463: LD_VAR 0 1
55467: ST_TO_ADDR
// if size > 0 then
55468: LD_VAR 0 2
55472: PUSH
55473: LD_INT 0
55475: GREATER
55476: IFFALSE 55522
// for i := array downto size do
55478: LD_ADDR_VAR 0 4
55482: PUSH
55483: DOUBLE
55484: LD_VAR 0 1
55488: INC
55489: ST_TO_ADDR
55490: LD_VAR 0 2
55494: PUSH
55495: FOR_DOWNTO
55496: IFFALSE 55520
// result := Delete ( result , result ) ;
55498: LD_ADDR_VAR 0 3
55502: PUSH
55503: LD_VAR 0 3
55507: PPUSH
55508: LD_VAR 0 3
55512: PPUSH
55513: CALL_OW 3
55517: ST_TO_ADDR
55518: GO 55495
55520: POP
55521: POP
// end ;
55522: LD_VAR 0 3
55526: RET
// export function ComExit ( unit ) ; var tmp ; begin
55527: LD_INT 0
55529: PPUSH
55530: PPUSH
// if not IsInUnit ( unit ) then
55531: LD_VAR 0 1
55535: PPUSH
55536: CALL_OW 310
55540: NOT
55541: IFFALSE 55545
// exit ;
55543: GO 55605
// tmp := IsInUnit ( unit ) ;
55545: LD_ADDR_VAR 0 3
55549: PUSH
55550: LD_VAR 0 1
55554: PPUSH
55555: CALL_OW 310
55559: ST_TO_ADDR
// if GetType ( tmp ) = unit_vehicle then
55560: LD_VAR 0 3
55564: PPUSH
55565: CALL_OW 247
55569: PUSH
55570: LD_INT 2
55572: EQUAL
55573: IFFALSE 55586
// ComExitVehicle ( unit ) else
55575: LD_VAR 0 1
55579: PPUSH
55580: CALL_OW 121
55584: GO 55595
// ComExitBuilding ( unit ) ;
55586: LD_VAR 0 1
55590: PPUSH
55591: CALL_OW 122
// result := tmp ;
55595: LD_ADDR_VAR 0 2
55599: PUSH
55600: LD_VAR 0 3
55604: ST_TO_ADDR
// end ;
55605: LD_VAR 0 2
55609: RET
// export function ResetHc ; begin
55610: LD_INT 0
55612: PPUSH
// InitHc ;
55613: CALL_OW 19
// hc_importance := 0 ;
55617: LD_ADDR_OWVAR 32
55621: PUSH
55622: LD_INT 0
55624: ST_TO_ADDR
// end ;
55625: LD_VAR 0 1
55629: RET
// export function PointBetweenXY ( x1 , y1 , x2 , y2 ) ; var _x , _y ; begin
55630: LD_INT 0
55632: PPUSH
55633: PPUSH
55634: PPUSH
// _x := ( x1 + x2 ) div 2 ;
55635: LD_ADDR_VAR 0 6
55639: PUSH
55640: LD_VAR 0 1
55644: PUSH
55645: LD_VAR 0 3
55649: PLUS
55650: PUSH
55651: LD_INT 2
55653: DIV
55654: ST_TO_ADDR
// if _x < 0 then
55655: LD_VAR 0 6
55659: PUSH
55660: LD_INT 0
55662: LESS
55663: IFFALSE 55680
// _x := _x * - 1 ;
55665: LD_ADDR_VAR 0 6
55669: PUSH
55670: LD_VAR 0 6
55674: PUSH
55675: LD_INT 1
55677: NEG
55678: MUL
55679: ST_TO_ADDR
// _y := ( y1 + y2 ) div 2 ;
55680: LD_ADDR_VAR 0 7
55684: PUSH
55685: LD_VAR 0 2
55689: PUSH
55690: LD_VAR 0 4
55694: PLUS
55695: PUSH
55696: LD_INT 2
55698: DIV
55699: ST_TO_ADDR
// if _y < 0 then
55700: LD_VAR 0 7
55704: PUSH
55705: LD_INT 0
55707: LESS
55708: IFFALSE 55725
// _y := _y * - 1 ;
55710: LD_ADDR_VAR 0 7
55714: PUSH
55715: LD_VAR 0 7
55719: PUSH
55720: LD_INT 1
55722: NEG
55723: MUL
55724: ST_TO_ADDR
// result := [ _x , _y ] ;
55725: LD_ADDR_VAR 0 5
55729: PUSH
55730: LD_VAR 0 6
55734: PUSH
55735: LD_VAR 0 7
55739: PUSH
55740: EMPTY
55741: LIST
55742: LIST
55743: ST_TO_ADDR
// end ;
55744: LD_VAR 0 5
55748: RET
// export function NotGoToAreaUnit ( unit , area , goAway ) ; var x , y , task ; begin
55749: LD_INT 0
55751: PPUSH
55752: PPUSH
55753: PPUSH
55754: PPUSH
// task := GetTaskList ( unit ) ;
55755: LD_ADDR_VAR 0 7
55759: PUSH
55760: LD_VAR 0 1
55764: PPUSH
55765: CALL_OW 437
55769: ST_TO_ADDR
// if not task and not IsInArea ( unit , area ) then
55770: LD_VAR 0 7
55774: NOT
55775: PUSH
55776: LD_VAR 0 1
55780: PPUSH
55781: LD_VAR 0 2
55785: PPUSH
55786: CALL_OW 308
55790: NOT
55791: AND
55792: IFFALSE 55796
// exit ;
55794: GO 55914
// if IsInArea ( unit , area ) then
55796: LD_VAR 0 1
55800: PPUSH
55801: LD_VAR 0 2
55805: PPUSH
55806: CALL_OW 308
55810: IFFALSE 55828
// begin ComMoveToArea ( unit , goAway ) ;
55812: LD_VAR 0 1
55816: PPUSH
55817: LD_VAR 0 3
55821: PPUSH
55822: CALL_OW 113
// exit ;
55826: GO 55914
// end ; if task [ 1 ] [ 1 ] <> M then
55828: LD_VAR 0 7
55832: PUSH
55833: LD_INT 1
55835: ARRAY
55836: PUSH
55837: LD_INT 1
55839: ARRAY
55840: PUSH
55841: LD_STRING M
55843: NONEQUAL
55844: IFFALSE 55848
// exit ;
55846: GO 55914
// x := task [ 1 ] [ 2 ] ;
55848: LD_ADDR_VAR 0 5
55852: PUSH
55853: LD_VAR 0 7
55857: PUSH
55858: LD_INT 1
55860: ARRAY
55861: PUSH
55862: LD_INT 2
55864: ARRAY
55865: ST_TO_ADDR
// y := task [ 1 ] [ 3 ] ;
55866: LD_ADDR_VAR 0 6
55870: PUSH
55871: LD_VAR 0 7
55875: PUSH
55876: LD_INT 1
55878: ARRAY
55879: PUSH
55880: LD_INT 3
55882: ARRAY
55883: ST_TO_ADDR
// if InArea ( x , y , area ) then
55884: LD_VAR 0 5
55888: PPUSH
55889: LD_VAR 0 6
55893: PPUSH
55894: LD_VAR 0 2
55898: PPUSH
55899: CALL_OW 309
55903: IFFALSE 55914
// ComStop ( unit ) ;
55905: LD_VAR 0 1
55909: PPUSH
55910: CALL_OW 141
// end ;
55914: LD_VAR 0 4
55918: RET
// export function Abs ( value ) ; begin
55919: LD_INT 0
55921: PPUSH
// result := value ;
55922: LD_ADDR_VAR 0 2
55926: PUSH
55927: LD_VAR 0 1
55931: ST_TO_ADDR
// if value < 0 then
55932: LD_VAR 0 1
55936: PUSH
55937: LD_INT 0
55939: LESS
55940: IFFALSE 55957
// result := value * - 1 ;
55942: LD_ADDR_VAR 0 2
55946: PUSH
55947: LD_VAR 0 1
55951: PUSH
55952: LD_INT 1
55954: NEG
55955: MUL
55956: ST_TO_ADDR
// end ;
55957: LD_VAR 0 2
55961: RET
// export function ComMoveToNearbyEntrance ( unit , building ) ; var x , _x , y , _y , d , r , i ; begin
55962: LD_INT 0
55964: PPUSH
55965: PPUSH
55966: PPUSH
55967: PPUSH
55968: PPUSH
55969: PPUSH
55970: PPUSH
55971: PPUSH
// if not unit or not building then
55972: LD_VAR 0 1
55976: NOT
55977: PUSH
55978: LD_VAR 0 2
55982: NOT
55983: OR
55984: IFFALSE 55988
// exit ;
55986: GO 56214
// x := GetX ( building ) ;
55988: LD_ADDR_VAR 0 4
55992: PUSH
55993: LD_VAR 0 2
55997: PPUSH
55998: CALL_OW 250
56002: ST_TO_ADDR
// y := GetY ( building ) ;
56003: LD_ADDR_VAR 0 6
56007: PUSH
56008: LD_VAR 0 2
56012: PPUSH
56013: CALL_OW 251
56017: ST_TO_ADDR
// d := GetDir ( building ) ;
56018: LD_ADDR_VAR 0 8
56022: PUSH
56023: LD_VAR 0 2
56027: PPUSH
56028: CALL_OW 254
56032: ST_TO_ADDR
// r := 4 ;
56033: LD_ADDR_VAR 0 9
56037: PUSH
56038: LD_INT 4
56040: ST_TO_ADDR
// for i := 1 to 5 do
56041: LD_ADDR_VAR 0 10
56045: PUSH
56046: DOUBLE
56047: LD_INT 1
56049: DEC
56050: ST_TO_ADDR
56051: LD_INT 5
56053: PUSH
56054: FOR_TO
56055: IFFALSE 56212
// begin _x := ShiftX ( x , d , r + i ) ;
56057: LD_ADDR_VAR 0 5
56061: PUSH
56062: LD_VAR 0 4
56066: PPUSH
56067: LD_VAR 0 8
56071: PPUSH
56072: LD_VAR 0 9
56076: PUSH
56077: LD_VAR 0 10
56081: PLUS
56082: PPUSH
56083: CALL_OW 272
56087: ST_TO_ADDR
// _y := ShiftY ( y , d , r + i ) ;
56088: LD_ADDR_VAR 0 7
56092: PUSH
56093: LD_VAR 0 6
56097: PPUSH
56098: LD_VAR 0 8
56102: PPUSH
56103: LD_VAR 0 9
56107: PUSH
56108: LD_VAR 0 10
56112: PLUS
56113: PPUSH
56114: CALL_OW 273
56118: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not GetType ( HexInfo ( _x , _y ) ) in [ unit_building , unit_vehicle ] then
56119: LD_VAR 0 5
56123: PPUSH
56124: LD_VAR 0 7
56128: PPUSH
56129: CALL_OW 488
56133: PUSH
56134: LD_VAR 0 5
56138: PPUSH
56139: LD_VAR 0 7
56143: PPUSH
56144: CALL_OW 428
56148: PPUSH
56149: CALL_OW 247
56153: PUSH
56154: LD_INT 3
56156: PUSH
56157: LD_INT 2
56159: PUSH
56160: EMPTY
56161: LIST
56162: LIST
56163: IN
56164: NOT
56165: AND
56166: IFFALSE 56210
// begin ComMoveXY ( unit , _x , _y ) ;
56168: LD_VAR 0 1
56172: PPUSH
56173: LD_VAR 0 5
56177: PPUSH
56178: LD_VAR 0 7
56182: PPUSH
56183: CALL_OW 111
// result := [ _x , _y ] ;
56187: LD_ADDR_VAR 0 3
56191: PUSH
56192: LD_VAR 0 5
56196: PUSH
56197: LD_VAR 0 7
56201: PUSH
56202: EMPTY
56203: LIST
56204: LIST
56205: ST_TO_ADDR
// exit ;
56206: POP
56207: POP
56208: GO 56214
// end ; end ;
56210: GO 56054
56212: POP
56213: POP
// end ;
56214: LD_VAR 0 3
56218: RET
// export function SideAttackedSide ( side1 , side2 ) ; var i , un ; begin
56219: LD_INT 0
56221: PPUSH
56222: PPUSH
56223: PPUSH
// result := 0 ;
56224: LD_ADDR_VAR 0 3
56228: PUSH
56229: LD_INT 0
56231: ST_TO_ADDR
// if side1 < 0 or side1 > 8 or side2 < 0 or side2 > 8 then
56232: LD_VAR 0 1
56236: PUSH
56237: LD_INT 0
56239: LESS
56240: PUSH
56241: LD_VAR 0 1
56245: PUSH
56246: LD_INT 8
56248: GREATER
56249: OR
56250: PUSH
56251: LD_VAR 0 2
56255: PUSH
56256: LD_INT 0
56258: LESS
56259: OR
56260: PUSH
56261: LD_VAR 0 2
56265: PUSH
56266: LD_INT 8
56268: GREATER
56269: OR
56270: IFFALSE 56274
// exit ;
56272: GO 56349
// for i in FilterAllUnits ( [ f_side , side2 ] ) do
56274: LD_ADDR_VAR 0 4
56278: PUSH
56279: LD_INT 22
56281: PUSH
56282: LD_VAR 0 2
56286: PUSH
56287: EMPTY
56288: LIST
56289: LIST
56290: PPUSH
56291: CALL_OW 69
56295: PUSH
56296: FOR_IN
56297: IFFALSE 56347
// begin un := UnitShoot ( i ) ;
56299: LD_ADDR_VAR 0 5
56303: PUSH
56304: LD_VAR 0 4
56308: PPUSH
56309: CALL_OW 504
56313: ST_TO_ADDR
// if GetSide ( un ) = side1 then
56314: LD_VAR 0 5
56318: PPUSH
56319: CALL_OW 255
56323: PUSH
56324: LD_VAR 0 1
56328: EQUAL
56329: IFFALSE 56345
// begin result := un ;
56331: LD_ADDR_VAR 0 3
56335: PUSH
56336: LD_VAR 0 5
56340: ST_TO_ADDR
// exit ;
56341: POP
56342: POP
56343: GO 56349
// end ; end ;
56345: GO 56296
56347: POP
56348: POP
// end ; end_of_file
56349: LD_VAR 0 3
56353: RET
// export function SOS_UnitDestroyed ( un ) ; var i , eff , side ; begin
56354: LD_INT 0
56356: PPUSH
56357: PPUSH
56358: PPUSH
56359: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
56360: LD_VAR 0 1
56364: PPUSH
56365: CALL_OW 264
56369: PUSH
56370: LD_EXP 158
56374: EQUAL
56375: IFFALSE 56447
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
56377: LD_INT 68
56379: PPUSH
56380: LD_VAR 0 1
56384: PPUSH
56385: CALL_OW 255
56389: PPUSH
56390: CALL_OW 321
56394: PUSH
56395: LD_INT 2
56397: EQUAL
56398: IFFALSE 56410
// eff := 70 else
56400: LD_ADDR_VAR 0 4
56404: PUSH
56405: LD_INT 70
56407: ST_TO_ADDR
56408: GO 56418
// eff := 30 ;
56410: LD_ADDR_VAR 0 4
56414: PUSH
56415: LD_INT 30
56417: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
56418: LD_VAR 0 1
56422: PPUSH
56423: CALL_OW 250
56427: PPUSH
56428: LD_VAR 0 1
56432: PPUSH
56433: CALL_OW 251
56437: PPUSH
56438: LD_VAR 0 4
56442: PPUSH
56443: CALL_OW 495
// end ; end ;
56447: LD_VAR 0 2
56451: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
56452: LD_INT 0
56454: PPUSH
// end ;
56455: LD_VAR 0 4
56459: RET
// export function SOS_Command ( cmd ) ; begin
56460: LD_INT 0
56462: PPUSH
// end ;
56463: LD_VAR 0 2
56467: RET
// export function SOS_CommandUnitXY ( cmd , un , target , x , y ) ; begin
56468: LD_INT 0
56470: PPUSH
// if cmd = 121 then
56471: LD_VAR 0 1
56475: PUSH
56476: LD_INT 121
56478: EQUAL
56479: IFFALSE 56481
// end ;
56481: LD_VAR 0 6
56485: RET
// export function SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; begin
56486: LD_INT 0
56488: PPUSH
// if cmd = 250 and GetWeapon ( unit ) = ar_miner then
56489: LD_VAR 0 1
56493: PUSH
56494: LD_INT 250
56496: EQUAL
56497: PUSH
56498: LD_VAR 0 2
56502: PPUSH
56503: CALL_OW 264
56507: PUSH
56508: LD_EXP 161
56512: EQUAL
56513: AND
56514: IFFALSE 56535
// MinerPlaceMine ( unit , x , y ) ;
56516: LD_VAR 0 2
56520: PPUSH
56521: LD_VAR 0 4
56525: PPUSH
56526: LD_VAR 0 5
56530: PPUSH
56531: CALL 58884 0 3
// if cmd = 251 and GetWeapon ( unit ) = ar_miner then
56535: LD_VAR 0 1
56539: PUSH
56540: LD_INT 251
56542: EQUAL
56543: PUSH
56544: LD_VAR 0 2
56548: PPUSH
56549: CALL_OW 264
56553: PUSH
56554: LD_EXP 161
56558: EQUAL
56559: AND
56560: IFFALSE 56581
// MinerDetonateMine ( unit , x , y ) ;
56562: LD_VAR 0 2
56566: PPUSH
56567: LD_VAR 0 4
56571: PPUSH
56572: LD_VAR 0 5
56576: PPUSH
56577: CALL 59161 0 3
// if cmd = 252 and GetWeapon ( unit ) = ar_miner then
56581: LD_VAR 0 1
56585: PUSH
56586: LD_INT 252
56588: EQUAL
56589: PUSH
56590: LD_VAR 0 2
56594: PPUSH
56595: CALL_OW 264
56599: PUSH
56600: LD_EXP 161
56604: EQUAL
56605: AND
56606: IFFALSE 56627
// MinerCreateMinefield ( unit , x , y ) ;
56608: LD_VAR 0 2
56612: PPUSH
56613: LD_VAR 0 4
56617: PPUSH
56618: LD_VAR 0 5
56622: PPUSH
56623: CALL 59578 0 3
// if cmd = 253 and GetClass ( unit ) = class_sniper then
56627: LD_VAR 0 1
56631: PUSH
56632: LD_INT 253
56634: EQUAL
56635: PUSH
56636: LD_VAR 0 2
56640: PPUSH
56641: CALL_OW 257
56645: PUSH
56646: LD_INT 5
56648: EQUAL
56649: AND
56650: IFFALSE 56671
// ComBinocular ( unit , x , y ) ;
56652: LD_VAR 0 2
56656: PPUSH
56657: LD_VAR 0 4
56661: PPUSH
56662: LD_VAR 0 5
56666: PPUSH
56667: CALL 59949 0 3
// if cmd = 254 and GetWeapon ( unit ) = us_hack and GetControl ( selectedUnit ) = control_computer then
56671: LD_VAR 0 1
56675: PUSH
56676: LD_INT 254
56678: EQUAL
56679: PUSH
56680: LD_VAR 0 2
56684: PPUSH
56685: CALL_OW 264
56689: PUSH
56690: LD_EXP 156
56694: EQUAL
56695: AND
56696: PUSH
56697: LD_VAR 0 3
56701: PPUSH
56702: CALL_OW 263
56706: PUSH
56707: LD_INT 3
56709: EQUAL
56710: AND
56711: IFFALSE 56727
// HackDestroyVehicle ( unit , selectedUnit ) ;
56713: LD_VAR 0 2
56717: PPUSH
56718: LD_VAR 0 3
56722: PPUSH
56723: CALL 58244 0 2
// if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
56727: LD_VAR 0 1
56731: PUSH
56732: LD_INT 255
56734: EQUAL
56735: PUSH
56736: LD_VAR 0 2
56740: PPUSH
56741: CALL_OW 264
56745: PUSH
56746: LD_INT 14
56748: PUSH
56749: LD_INT 53
56751: PUSH
56752: EMPTY
56753: LIST
56754: LIST
56755: IN
56756: AND
56757: PUSH
56758: LD_VAR 0 4
56762: PPUSH
56763: LD_VAR 0 5
56767: PPUSH
56768: CALL_OW 488
56772: AND
56773: IFFALSE 56797
// CutTreeXYR ( unit , x , y , 12 ) ;
56775: LD_VAR 0 2
56779: PPUSH
56780: LD_VAR 0 4
56784: PPUSH
56785: LD_VAR 0 5
56789: PPUSH
56790: LD_INT 12
56792: PPUSH
56793: CALL 56810 0 4
// end ;
56797: LD_VAR 0 6
56801: RET
// export initPlantMineScript , plantMineList ; export function ComGroupPlantMineXY ( units , x , y ) ; begin
56802: LD_INT 0
56804: PPUSH
// end ;
56805: LD_VAR 0 4
56809: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
56810: LD_INT 0
56812: PPUSH
56813: PPUSH
56814: PPUSH
56815: PPUSH
56816: PPUSH
56817: PPUSH
56818: PPUSH
56819: PPUSH
56820: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
56821: LD_VAR 0 1
56825: NOT
56826: PUSH
56827: LD_VAR 0 2
56831: PPUSH
56832: LD_VAR 0 3
56836: PPUSH
56837: CALL_OW 488
56841: NOT
56842: OR
56843: PUSH
56844: LD_VAR 0 4
56848: NOT
56849: OR
56850: IFFALSE 56854
// exit ;
56852: GO 57194
// list := [ ] ;
56854: LD_ADDR_VAR 0 13
56858: PUSH
56859: EMPTY
56860: ST_TO_ADDR
// if x - r < 0 then
56861: LD_VAR 0 2
56865: PUSH
56866: LD_VAR 0 4
56870: MINUS
56871: PUSH
56872: LD_INT 0
56874: LESS
56875: IFFALSE 56887
// min_x := 0 else
56877: LD_ADDR_VAR 0 7
56881: PUSH
56882: LD_INT 0
56884: ST_TO_ADDR
56885: GO 56903
// min_x := x - r ;
56887: LD_ADDR_VAR 0 7
56891: PUSH
56892: LD_VAR 0 2
56896: PUSH
56897: LD_VAR 0 4
56901: MINUS
56902: ST_TO_ADDR
// if y - r < 0 then
56903: LD_VAR 0 3
56907: PUSH
56908: LD_VAR 0 4
56912: MINUS
56913: PUSH
56914: LD_INT 0
56916: LESS
56917: IFFALSE 56929
// min_y := 0 else
56919: LD_ADDR_VAR 0 8
56923: PUSH
56924: LD_INT 0
56926: ST_TO_ADDR
56927: GO 56945
// min_y := y - r ;
56929: LD_ADDR_VAR 0 8
56933: PUSH
56934: LD_VAR 0 3
56938: PUSH
56939: LD_VAR 0 4
56943: MINUS
56944: ST_TO_ADDR
// max_x := x + r ;
56945: LD_ADDR_VAR 0 9
56949: PUSH
56950: LD_VAR 0 2
56954: PUSH
56955: LD_VAR 0 4
56959: PLUS
56960: ST_TO_ADDR
// max_y := y + r ;
56961: LD_ADDR_VAR 0 10
56965: PUSH
56966: LD_VAR 0 3
56970: PUSH
56971: LD_VAR 0 4
56975: PLUS
56976: ST_TO_ADDR
// for _x = min_x to max_x do
56977: LD_ADDR_VAR 0 11
56981: PUSH
56982: DOUBLE
56983: LD_VAR 0 7
56987: DEC
56988: ST_TO_ADDR
56989: LD_VAR 0 9
56993: PUSH
56994: FOR_TO
56995: IFFALSE 57112
// for _y = min_y to max_y do
56997: LD_ADDR_VAR 0 12
57001: PUSH
57002: DOUBLE
57003: LD_VAR 0 8
57007: DEC
57008: ST_TO_ADDR
57009: LD_VAR 0 10
57013: PUSH
57014: FOR_TO
57015: IFFALSE 57108
// begin if not ValidHex ( _x , _y ) then
57017: LD_VAR 0 11
57021: PPUSH
57022: LD_VAR 0 12
57026: PPUSH
57027: CALL_OW 488
57031: NOT
57032: IFFALSE 57036
// continue ;
57034: GO 57014
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
57036: LD_VAR 0 11
57040: PPUSH
57041: LD_VAR 0 12
57045: PPUSH
57046: CALL_OW 351
57050: PUSH
57051: LD_VAR 0 11
57055: PPUSH
57056: LD_VAR 0 12
57060: PPUSH
57061: CALL_OW 554
57065: AND
57066: IFFALSE 57106
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
57068: LD_ADDR_VAR 0 13
57072: PUSH
57073: LD_VAR 0 13
57077: PPUSH
57078: LD_VAR 0 13
57082: PUSH
57083: LD_INT 1
57085: PLUS
57086: PPUSH
57087: LD_VAR 0 11
57091: PUSH
57092: LD_VAR 0 12
57096: PUSH
57097: EMPTY
57098: LIST
57099: LIST
57100: PPUSH
57101: CALL_OW 2
57105: ST_TO_ADDR
// end ;
57106: GO 57014
57108: POP
57109: POP
57110: GO 56994
57112: POP
57113: POP
// if not list then
57114: LD_VAR 0 13
57118: NOT
57119: IFFALSE 57123
// exit ;
57121: GO 57194
// for i in list do
57123: LD_ADDR_VAR 0 6
57127: PUSH
57128: LD_VAR 0 13
57132: PUSH
57133: FOR_IN
57134: IFFALSE 57192
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
57136: LD_VAR 0 1
57140: PPUSH
57141: LD_STRING M
57143: PUSH
57144: LD_VAR 0 6
57148: PUSH
57149: LD_INT 1
57151: ARRAY
57152: PUSH
57153: LD_VAR 0 6
57157: PUSH
57158: LD_INT 2
57160: ARRAY
57161: PUSH
57162: LD_INT 0
57164: PUSH
57165: LD_INT 0
57167: PUSH
57168: LD_INT 0
57170: PUSH
57171: LD_INT 0
57173: PUSH
57174: EMPTY
57175: LIST
57176: LIST
57177: LIST
57178: LIST
57179: LIST
57180: LIST
57181: LIST
57182: PUSH
57183: EMPTY
57184: LIST
57185: PPUSH
57186: CALL_OW 447
57190: GO 57133
57192: POP
57193: POP
// end ;
57194: LD_VAR 0 5
57198: RET
// export initHack , hackTanks , hackTanksCaptured , hackLimit , hackDist , hackCounter ; every 0 0$1 trigger not initHack do
57199: LD_EXP 89
57203: NOT
57204: IFFALSE 57254
57206: GO 57208
57208: DISABLE
// begin initHack := true ;
57209: LD_ADDR_EXP 89
57213: PUSH
57214: LD_INT 1
57216: ST_TO_ADDR
// hackTanks := [ ] ;
57217: LD_ADDR_EXP 90
57221: PUSH
57222: EMPTY
57223: ST_TO_ADDR
// hackTanksCaptured := [ ] ;
57224: LD_ADDR_EXP 91
57228: PUSH
57229: EMPTY
57230: ST_TO_ADDR
// hackLimit := 3 ;
57231: LD_ADDR_EXP 92
57235: PUSH
57236: LD_INT 3
57238: ST_TO_ADDR
// hackDist := 12 ;
57239: LD_ADDR_EXP 93
57243: PUSH
57244: LD_INT 12
57246: ST_TO_ADDR
// hackCounter := [ ] ;
57247: LD_ADDR_EXP 94
57251: PUSH
57252: EMPTY
57253: ST_TO_ADDR
// end ;
57254: END
// every 0 0$1 trigger initHack and FilterAllUnits ( [ f_weapon , us_hack ] ) do var i , tmp ;
57255: LD_EXP 89
57259: PUSH
57260: LD_INT 34
57262: PUSH
57263: LD_EXP 156
57267: PUSH
57268: EMPTY
57269: LIST
57270: LIST
57271: PPUSH
57272: CALL_OW 69
57276: AND
57277: IFFALSE 57532
57279: GO 57281
57281: DISABLE
57282: LD_INT 0
57284: PPUSH
57285: PPUSH
// begin enable ;
57286: ENABLE
// for i in FilterAllUnits ( [ f_weapon , us_hack ] ) do
57287: LD_ADDR_VAR 0 1
57291: PUSH
57292: LD_INT 34
57294: PUSH
57295: LD_EXP 156
57299: PUSH
57300: EMPTY
57301: LIST
57302: LIST
57303: PPUSH
57304: CALL_OW 69
57308: PUSH
57309: FOR_IN
57310: IFFALSE 57530
// begin if not i in hackTanks then
57312: LD_VAR 0 1
57316: PUSH
57317: LD_EXP 90
57321: IN
57322: NOT
57323: IFFALSE 57406
// begin hackTanks := Replace ( hackTanks , hackTanks + 1 , i ) ;
57325: LD_ADDR_EXP 90
57329: PUSH
57330: LD_EXP 90
57334: PPUSH
57335: LD_EXP 90
57339: PUSH
57340: LD_INT 1
57342: PLUS
57343: PPUSH
57344: LD_VAR 0 1
57348: PPUSH
57349: CALL_OW 1
57353: ST_TO_ADDR
// hackTanksCaptured := Replace ( hackTanksCaptured , hackTanksCaptured + 1 , [ ] ) ;
57354: LD_ADDR_EXP 91
57358: PUSH
57359: LD_EXP 91
57363: PPUSH
57364: LD_EXP 91
57368: PUSH
57369: LD_INT 1
57371: PLUS
57372: PPUSH
57373: EMPTY
57374: PPUSH
57375: CALL_OW 1
57379: ST_TO_ADDR
// hackCounter := Replace ( hackCounter , hackCounter + 1 , [ ] ) ;
57380: LD_ADDR_EXP 94
57384: PUSH
57385: LD_EXP 94
57389: PPUSH
57390: LD_EXP 94
57394: PUSH
57395: LD_INT 1
57397: PLUS
57398: PPUSH
57399: EMPTY
57400: PPUSH
57401: CALL_OW 1
57405: ST_TO_ADDR
// end ; if not IsOk ( i ) then
57406: LD_VAR 0 1
57410: PPUSH
57411: CALL_OW 302
57415: NOT
57416: IFFALSE 57429
// begin HackUnlinkAll ( i ) ;
57418: LD_VAR 0 1
57422: PPUSH
57423: CALL 57535 0 1
// continue ;
57427: GO 57309
// end ; HackCheckCapturedStatus ( i ) ;
57429: LD_VAR 0 1
57433: PPUSH
57434: CALL 57978 0 1
// tmp := FilterAllUnits ( [ [ f_enemy , GetSide ( i ) ] , [ f_control , control_computer ] , [ f_dist , i , hackDist ] , [ f_ok ] ] ) ;
57438: LD_ADDR_VAR 0 2
57442: PUSH
57443: LD_INT 81
57445: PUSH
57446: LD_VAR 0 1
57450: PPUSH
57451: CALL_OW 255
57455: PUSH
57456: EMPTY
57457: LIST
57458: LIST
57459: PUSH
57460: LD_INT 33
57462: PUSH
57463: LD_INT 3
57465: PUSH
57466: EMPTY
57467: LIST
57468: LIST
57469: PUSH
57470: LD_INT 91
57472: PUSH
57473: LD_VAR 0 1
57477: PUSH
57478: LD_EXP 93
57482: PUSH
57483: EMPTY
57484: LIST
57485: LIST
57486: LIST
57487: PUSH
57488: LD_INT 50
57490: PUSH
57491: EMPTY
57492: LIST
57493: PUSH
57494: EMPTY
57495: LIST
57496: LIST
57497: LIST
57498: LIST
57499: PPUSH
57500: CALL_OW 69
57504: ST_TO_ADDR
// if not tmp then
57505: LD_VAR 0 2
57509: NOT
57510: IFFALSE 57514
// continue ;
57512: GO 57309
// HackLink ( i , tmp ) ;
57514: LD_VAR 0 1
57518: PPUSH
57519: LD_VAR 0 2
57523: PPUSH
57524: CALL 57671 0 2
// end ;
57528: GO 57309
57530: POP
57531: POP
// end ;
57532: PPOPN 2
57534: END
// function HackUnlinkAll ( hack ) ; var i , index ; begin
57535: LD_INT 0
57537: PPUSH
57538: PPUSH
57539: PPUSH
// if not hack in hackTanks then
57540: LD_VAR 0 1
57544: PUSH
57545: LD_EXP 90
57549: IN
57550: NOT
57551: IFFALSE 57555
// exit ;
57553: GO 57666
// index := GetElementIndex ( hackTanks , hack ) ;
57555: LD_ADDR_VAR 0 4
57559: PUSH
57560: LD_EXP 90
57564: PPUSH
57565: LD_VAR 0 1
57569: PPUSH
57570: CALL 23881 0 2
57574: ST_TO_ADDR
// if hackTanksCaptured [ index ] then
57575: LD_EXP 91
57579: PUSH
57580: LD_VAR 0 4
57584: ARRAY
57585: IFFALSE 57666
// begin for i in hackTanksCaptured [ index ] do
57587: LD_ADDR_VAR 0 3
57591: PUSH
57592: LD_EXP 91
57596: PUSH
57597: LD_VAR 0 4
57601: ARRAY
57602: PUSH
57603: FOR_IN
57604: IFFALSE 57630
// SetSide ( i [ 1 ] , i [ 2 ] ) ;
57606: LD_VAR 0 3
57610: PUSH
57611: LD_INT 1
57613: ARRAY
57614: PPUSH
57615: LD_VAR 0 3
57619: PUSH
57620: LD_INT 2
57622: ARRAY
57623: PPUSH
57624: CALL_OW 235
57628: GO 57603
57630: POP
57631: POP
// hackTanksCaptured := Replace ( hackTanksCaptured , index , [ ] ) ;
57632: LD_ADDR_EXP 91
57636: PUSH
57637: LD_EXP 91
57641: PPUSH
57642: LD_VAR 0 4
57646: PPUSH
57647: EMPTY
57648: PPUSH
57649: CALL_OW 1
57653: ST_TO_ADDR
// SetUnitDisplayNumber ( hack , 0 ) ;
57654: LD_VAR 0 1
57658: PPUSH
57659: LD_INT 0
57661: PPUSH
57662: CALL_OW 505
// end ; end ;
57666: LD_VAR 0 2
57670: RET
// function HackLink ( hack , vehicles ) ; var i , index ; begin
57671: LD_INT 0
57673: PPUSH
57674: PPUSH
57675: PPUSH
// if not hack in hackTanks or not vehicles then
57676: LD_VAR 0 1
57680: PUSH
57681: LD_EXP 90
57685: IN
57686: NOT
57687: PUSH
57688: LD_VAR 0 2
57692: NOT
57693: OR
57694: IFFALSE 57698
// exit ;
57696: GO 57973
// vehicles := SortByDistanceUnit ( hack , vehicles , true , true ) ;
57698: LD_ADDR_VAR 0 2
57702: PUSH
57703: LD_VAR 0 1
57707: PPUSH
57708: LD_VAR 0 2
57712: PPUSH
57713: LD_INT 1
57715: PPUSH
57716: LD_INT 1
57718: PPUSH
57719: CALL 24531 0 4
57723: ST_TO_ADDR
// index := GetElementIndex ( hackTanks , hack ) ;
57724: LD_ADDR_VAR 0 5
57728: PUSH
57729: LD_EXP 90
57733: PPUSH
57734: LD_VAR 0 1
57738: PPUSH
57739: CALL 23881 0 2
57743: ST_TO_ADDR
// if hackTanksCaptured [ index ] < hackLimit then
57744: LD_EXP 91
57748: PUSH
57749: LD_VAR 0 5
57753: ARRAY
57754: PUSH
57755: LD_EXP 92
57759: LESS
57760: IFFALSE 57949
// begin for i := 1 to vehicles do
57762: LD_ADDR_VAR 0 4
57766: PUSH
57767: DOUBLE
57768: LD_INT 1
57770: DEC
57771: ST_TO_ADDR
57772: LD_VAR 0 2
57776: PUSH
57777: FOR_TO
57778: IFFALSE 57947
// begin if hackTanksCaptured [ index ] = hackLimit then
57780: LD_EXP 91
57784: PUSH
57785: LD_VAR 0 5
57789: ARRAY
57790: PUSH
57791: LD_EXP 92
57795: EQUAL
57796: IFFALSE 57800
// break ;
57798: GO 57947
// hackCounter := Replace ( hackCounter , index , hackCounter [ index ] + 1 ) ;
57800: LD_ADDR_EXP 94
57804: PUSH
57805: LD_EXP 94
57809: PPUSH
57810: LD_VAR 0 5
57814: PPUSH
57815: LD_EXP 94
57819: PUSH
57820: LD_VAR 0 5
57824: ARRAY
57825: PUSH
57826: LD_INT 1
57828: PLUS
57829: PPUSH
57830: CALL_OW 1
57834: ST_TO_ADDR
// hackTanksCaptured := ReplaceIn ( hackTanksCaptured , [ index , hackTanksCaptured [ index ] + 1 ] , [ vehicles [ i ] , GetSide ( vehicles [ i ] ) ] ) ;
57835: LD_ADDR_EXP 91
57839: PUSH
57840: LD_EXP 91
57844: PPUSH
57845: LD_VAR 0 5
57849: PUSH
57850: LD_EXP 91
57854: PUSH
57855: LD_VAR 0 5
57859: ARRAY
57860: PUSH
57861: LD_INT 1
57863: PLUS
57864: PUSH
57865: EMPTY
57866: LIST
57867: LIST
57868: PPUSH
57869: LD_VAR 0 2
57873: PUSH
57874: LD_VAR 0 4
57878: ARRAY
57879: PUSH
57880: LD_VAR 0 2
57884: PUSH
57885: LD_VAR 0 4
57889: ARRAY
57890: PPUSH
57891: CALL_OW 255
57895: PUSH
57896: EMPTY
57897: LIST
57898: LIST
57899: PPUSH
57900: CALL 24096 0 3
57904: ST_TO_ADDR
// SetSide ( vehicles [ i ] , GetSide ( hack ) ) ;
57905: LD_VAR 0 2
57909: PUSH
57910: LD_VAR 0 4
57914: ARRAY
57915: PPUSH
57916: LD_VAR 0 1
57920: PPUSH
57921: CALL_OW 255
57925: PPUSH
57926: CALL_OW 235
// ComStop ( vehicles [ i ] ) ;
57930: LD_VAR 0 2
57934: PUSH
57935: LD_VAR 0 4
57939: ARRAY
57940: PPUSH
57941: CALL_OW 141
// end ;
57945: GO 57777
57947: POP
57948: POP
// end ; SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
57949: LD_VAR 0 1
57953: PPUSH
57954: LD_EXP 91
57958: PUSH
57959: LD_VAR 0 5
57963: ARRAY
57964: PUSH
57965: LD_INT 0
57967: PLUS
57968: PPUSH
57969: CALL_OW 505
// end ;
57973: LD_VAR 0 3
57977: RET
// function HackCheckCapturedStatus ( hack ) ; var i , index , tmp ; begin
57978: LD_INT 0
57980: PPUSH
57981: PPUSH
57982: PPUSH
57983: PPUSH
// if not hack in hackTanks then
57984: LD_VAR 0 1
57988: PUSH
57989: LD_EXP 90
57993: IN
57994: NOT
57995: IFFALSE 57999
// exit ;
57997: GO 58239
// index := GetElementIndex ( hackTanks , hack ) ;
57999: LD_ADDR_VAR 0 4
58003: PUSH
58004: LD_EXP 90
58008: PPUSH
58009: LD_VAR 0 1
58013: PPUSH
58014: CALL 23881 0 2
58018: ST_TO_ADDR
// for i := hackTanksCaptured [ index ] downto 1 do
58019: LD_ADDR_VAR 0 3
58023: PUSH
58024: DOUBLE
58025: LD_EXP 91
58029: PUSH
58030: LD_VAR 0 4
58034: ARRAY
58035: INC
58036: ST_TO_ADDR
58037: LD_INT 1
58039: PUSH
58040: FOR_DOWNTO
58041: IFFALSE 58213
// begin tmp := hackTanksCaptured [ index ] [ i ] ;
58043: LD_ADDR_VAR 0 5
58047: PUSH
58048: LD_EXP 91
58052: PUSH
58053: LD_VAR 0 4
58057: ARRAY
58058: PUSH
58059: LD_VAR 0 3
58063: ARRAY
58064: ST_TO_ADDR
// if not IsOk ( tmp [ 1 ] ) or GetSide ( tmp [ 1 ] ) <> GetSide ( hack ) then
58065: LD_VAR 0 5
58069: PUSH
58070: LD_INT 1
58072: ARRAY
58073: PPUSH
58074: CALL_OW 302
58078: NOT
58079: PUSH
58080: LD_VAR 0 5
58084: PUSH
58085: LD_INT 1
58087: ARRAY
58088: PPUSH
58089: CALL_OW 255
58093: PUSH
58094: LD_VAR 0 1
58098: PPUSH
58099: CALL_OW 255
58103: NONEQUAL
58104: OR
58105: IFFALSE 58211
// begin if IsPlaced ( tmp [ 1 ] ) and GetSide ( tmp [ 1 ] ) = GetSide ( hack ) then
58107: LD_VAR 0 5
58111: PUSH
58112: LD_INT 1
58114: ARRAY
58115: PPUSH
58116: CALL_OW 305
58120: PUSH
58121: LD_VAR 0 5
58125: PUSH
58126: LD_INT 1
58128: ARRAY
58129: PPUSH
58130: CALL_OW 255
58134: PUSH
58135: LD_VAR 0 1
58139: PPUSH
58140: CALL_OW 255
58144: EQUAL
58145: AND
58146: IFFALSE 58170
// SetSide ( tmp [ 1 ] , tmp [ 2 ] ) ;
58148: LD_VAR 0 5
58152: PUSH
58153: LD_INT 1
58155: ARRAY
58156: PPUSH
58157: LD_VAR 0 5
58161: PUSH
58162: LD_INT 2
58164: ARRAY
58165: PPUSH
58166: CALL_OW 235
// hackTanksCaptured := Replace ( hackTanksCaptured , index , Delete ( hackTanksCaptured [ index ] , i ) ) ;
58170: LD_ADDR_EXP 91
58174: PUSH
58175: LD_EXP 91
58179: PPUSH
58180: LD_VAR 0 4
58184: PPUSH
58185: LD_EXP 91
58189: PUSH
58190: LD_VAR 0 4
58194: ARRAY
58195: PPUSH
58196: LD_VAR 0 3
58200: PPUSH
58201: CALL_OW 3
58205: PPUSH
58206: CALL_OW 1
58210: ST_TO_ADDR
// end ; end ;
58211: GO 58040
58213: POP
58214: POP
// SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
58215: LD_VAR 0 1
58219: PPUSH
58220: LD_EXP 91
58224: PUSH
58225: LD_VAR 0 4
58229: ARRAY
58230: PUSH
58231: LD_INT 0
58233: PLUS
58234: PPUSH
58235: CALL_OW 505
// end ;
58239: LD_VAR 0 2
58243: RET
// export function HackDestroyVehicle ( hack , vehicle ) ; var i , index , tmp ; begin
58244: LD_INT 0
58246: PPUSH
58247: PPUSH
58248: PPUSH
58249: PPUSH
// if not hack in hackTanks then
58250: LD_VAR 0 1
58254: PUSH
58255: LD_EXP 90
58259: IN
58260: NOT
58261: IFFALSE 58265
// exit ;
58263: GO 58350
// index := GetElementIndex ( hackTanks , hack ) ;
58265: LD_ADDR_VAR 0 5
58269: PUSH
58270: LD_EXP 90
58274: PPUSH
58275: LD_VAR 0 1
58279: PPUSH
58280: CALL 23881 0 2
58284: ST_TO_ADDR
// for i := 1 to hackTanksCaptured [ index ] do
58285: LD_ADDR_VAR 0 4
58289: PUSH
58290: DOUBLE
58291: LD_INT 1
58293: DEC
58294: ST_TO_ADDR
58295: LD_EXP 91
58299: PUSH
58300: LD_VAR 0 5
58304: ARRAY
58305: PUSH
58306: FOR_TO
58307: IFFALSE 58348
// if hackTanksCaptured [ index ] [ i ] [ 1 ] = vehicle then
58309: LD_EXP 91
58313: PUSH
58314: LD_VAR 0 5
58318: ARRAY
58319: PUSH
58320: LD_VAR 0 4
58324: ARRAY
58325: PUSH
58326: LD_INT 1
58328: ARRAY
58329: PUSH
58330: LD_VAR 0 2
58334: EQUAL
58335: IFFALSE 58346
// KillUnit ( vehicle ) ;
58337: LD_VAR 0 2
58341: PPUSH
58342: CALL_OW 66
58346: GO 58306
58348: POP
58349: POP
// end ;
58350: LD_VAR 0 3
58354: RET
// export initMiner , minersList , minerMinesList , minesLimitPerVehicle ; every 0 0$1 trigger not initMiner do
58355: LD_EXP 95
58359: NOT
58360: IFFALSE 58395
58362: GO 58364
58364: DISABLE
// begin initMiner := true ;
58365: LD_ADDR_EXP 95
58369: PUSH
58370: LD_INT 1
58372: ST_TO_ADDR
// minersList := [ ] ;
58373: LD_ADDR_EXP 96
58377: PUSH
58378: EMPTY
58379: ST_TO_ADDR
// minerMinesList := [ ] ;
58380: LD_ADDR_EXP 97
58384: PUSH
58385: EMPTY
58386: ST_TO_ADDR
// minesLimitPerVehicle := 5 ;
58387: LD_ADDR_EXP 98
58391: PUSH
58392: LD_INT 5
58394: ST_TO_ADDR
// end ;
58395: END
// every 0 0$1 trigger initMiner and FilterAllUnits ( [ f_weapon , ar_miner ] ) do var i , j , side , tmp ;
58396: LD_EXP 95
58400: PUSH
58401: LD_INT 34
58403: PUSH
58404: LD_EXP 161
58408: PUSH
58409: EMPTY
58410: LIST
58411: LIST
58412: PPUSH
58413: CALL_OW 69
58417: AND
58418: IFFALSE 58881
58420: GO 58422
58422: DISABLE
58423: LD_INT 0
58425: PPUSH
58426: PPUSH
58427: PPUSH
58428: PPUSH
// begin enable ;
58429: ENABLE
// for i in FilterAllUnits ( [ f_weapon , ar_miner ] ) do
58430: LD_ADDR_VAR 0 1
58434: PUSH
58435: LD_INT 34
58437: PUSH
58438: LD_EXP 161
58442: PUSH
58443: EMPTY
58444: LIST
58445: LIST
58446: PPUSH
58447: CALL_OW 69
58451: PUSH
58452: FOR_IN
58453: IFFALSE 58525
// begin if not i in minersList then
58455: LD_VAR 0 1
58459: PUSH
58460: LD_EXP 96
58464: IN
58465: NOT
58466: IFFALSE 58523
// begin minersList := Replace ( minersList , minersList + 1 , i ) ;
58468: LD_ADDR_EXP 96
58472: PUSH
58473: LD_EXP 96
58477: PPUSH
58478: LD_EXP 96
58482: PUSH
58483: LD_INT 1
58485: PLUS
58486: PPUSH
58487: LD_VAR 0 1
58491: PPUSH
58492: CALL_OW 1
58496: ST_TO_ADDR
// minerMinesList := Replace ( minerMinesList , minerMinesList + 1 , [ ] ) ;
58497: LD_ADDR_EXP 97
58501: PUSH
58502: LD_EXP 97
58506: PPUSH
58507: LD_EXP 97
58511: PUSH
58512: LD_INT 1
58514: PLUS
58515: PPUSH
58516: EMPTY
58517: PPUSH
58518: CALL_OW 1
58522: ST_TO_ADDR
// end end ;
58523: GO 58452
58525: POP
58526: POP
// for i := minerMinesList downto 1 do
58527: LD_ADDR_VAR 0 1
58531: PUSH
58532: DOUBLE
58533: LD_EXP 97
58537: INC
58538: ST_TO_ADDR
58539: LD_INT 1
58541: PUSH
58542: FOR_DOWNTO
58543: IFFALSE 58879
// begin if IsLive ( minersList [ i ] ) then
58545: LD_EXP 96
58549: PUSH
58550: LD_VAR 0 1
58554: ARRAY
58555: PPUSH
58556: CALL_OW 300
58560: IFFALSE 58588
// SetUnitDisplayNumber ( minersList [ i ] , minerMinesList [ i ] ) ;
58562: LD_EXP 96
58566: PUSH
58567: LD_VAR 0 1
58571: ARRAY
58572: PPUSH
58573: LD_EXP 97
58577: PUSH
58578: LD_VAR 0 1
58582: ARRAY
58583: PPUSH
58584: CALL_OW 505
// if not minerMinesList [ i ] then
58588: LD_EXP 97
58592: PUSH
58593: LD_VAR 0 1
58597: ARRAY
58598: NOT
58599: IFFALSE 58603
// continue ;
58601: GO 58542
// for j := minerMinesList [ i ] downto 1 do
58603: LD_ADDR_VAR 0 2
58607: PUSH
58608: DOUBLE
58609: LD_EXP 97
58613: PUSH
58614: LD_VAR 0 1
58618: ARRAY
58619: INC
58620: ST_TO_ADDR
58621: LD_INT 1
58623: PUSH
58624: FOR_DOWNTO
58625: IFFALSE 58875
// begin side := GetSide ( minersList [ i ] ) ;
58627: LD_ADDR_VAR 0 3
58631: PUSH
58632: LD_EXP 96
58636: PUSH
58637: LD_VAR 0 1
58641: ARRAY
58642: PPUSH
58643: CALL_OW 255
58647: ST_TO_ADDR
// tmp := HexInfo ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) ;
58648: LD_ADDR_VAR 0 4
58652: PUSH
58653: LD_EXP 97
58657: PUSH
58658: LD_VAR 0 1
58662: ARRAY
58663: PUSH
58664: LD_VAR 0 2
58668: ARRAY
58669: PUSH
58670: LD_INT 1
58672: ARRAY
58673: PPUSH
58674: LD_EXP 97
58678: PUSH
58679: LD_VAR 0 1
58683: ARRAY
58684: PUSH
58685: LD_VAR 0 2
58689: ARRAY
58690: PUSH
58691: LD_INT 2
58693: ARRAY
58694: PPUSH
58695: CALL_OW 428
58699: ST_TO_ADDR
// if not tmp then
58700: LD_VAR 0 4
58704: NOT
58705: IFFALSE 58709
// continue ;
58707: GO 58624
// if tmp in FilterAllUnits ( [ f_enemy , side ] ) and MineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) then
58709: LD_VAR 0 4
58713: PUSH
58714: LD_INT 81
58716: PUSH
58717: LD_VAR 0 3
58721: PUSH
58722: EMPTY
58723: LIST
58724: LIST
58725: PPUSH
58726: CALL_OW 69
58730: IN
58731: PUSH
58732: LD_EXP 97
58736: PUSH
58737: LD_VAR 0 1
58741: ARRAY
58742: PUSH
58743: LD_VAR 0 2
58747: ARRAY
58748: PUSH
58749: LD_INT 1
58751: ARRAY
58752: PPUSH
58753: LD_EXP 97
58757: PUSH
58758: LD_VAR 0 1
58762: ARRAY
58763: PUSH
58764: LD_VAR 0 2
58768: ARRAY
58769: PUSH
58770: LD_INT 2
58772: ARRAY
58773: PPUSH
58774: CALL_OW 458
58778: AND
58779: IFFALSE 58873
// begin LaunchMineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] , side ) ;
58781: LD_EXP 97
58785: PUSH
58786: LD_VAR 0 1
58790: ARRAY
58791: PUSH
58792: LD_VAR 0 2
58796: ARRAY
58797: PUSH
58798: LD_INT 1
58800: ARRAY
58801: PPUSH
58802: LD_EXP 97
58806: PUSH
58807: LD_VAR 0 1
58811: ARRAY
58812: PUSH
58813: LD_VAR 0 2
58817: ARRAY
58818: PUSH
58819: LD_INT 2
58821: ARRAY
58822: PPUSH
58823: LD_VAR 0 3
58827: PPUSH
58828: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , i , Delete ( minerMinesList [ i ] , j ) ) ;
58832: LD_ADDR_EXP 97
58836: PUSH
58837: LD_EXP 97
58841: PPUSH
58842: LD_VAR 0 1
58846: PPUSH
58847: LD_EXP 97
58851: PUSH
58852: LD_VAR 0 1
58856: ARRAY
58857: PPUSH
58858: LD_VAR 0 2
58862: PPUSH
58863: CALL_OW 3
58867: PPUSH
58868: CALL_OW 1
58872: ST_TO_ADDR
// end ; end ;
58873: GO 58624
58875: POP
58876: POP
// end ;
58877: GO 58542
58879: POP
58880: POP
// end ;
58881: PPOPN 4
58883: END
// export function MinerPlaceMine ( unit , x , y ) ; var index ; begin
58884: LD_INT 0
58886: PPUSH
58887: PPUSH
// result := false ;
58888: LD_ADDR_VAR 0 4
58892: PUSH
58893: LD_INT 0
58895: ST_TO_ADDR
// if not GetWeapon ( unit ) = ar_miner then
58896: LD_VAR 0 1
58900: PPUSH
58901: CALL_OW 264
58905: PUSH
58906: LD_EXP 161
58910: EQUAL
58911: NOT
58912: IFFALSE 58916
// exit ;
58914: GO 59156
// index := GetElementIndex ( minersList , unit ) ;
58916: LD_ADDR_VAR 0 5
58920: PUSH
58921: LD_EXP 96
58925: PPUSH
58926: LD_VAR 0 1
58930: PPUSH
58931: CALL 23881 0 2
58935: ST_TO_ADDR
// if minerMinesList [ index ] >= minesLimitPerVehicle then
58936: LD_EXP 97
58940: PUSH
58941: LD_VAR 0 5
58945: ARRAY
58946: PUSH
58947: LD_EXP 98
58951: GREATEREQUAL
58952: IFFALSE 58956
// exit ;
58954: GO 59156
// ComMoveXY ( unit , x , y ) ;
58956: LD_VAR 0 1
58960: PPUSH
58961: LD_VAR 0 2
58965: PPUSH
58966: LD_VAR 0 3
58970: PPUSH
58971: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
58975: LD_INT 35
58977: PPUSH
58978: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) and HasTask ( unit ) then
58982: LD_VAR 0 1
58986: PPUSH
58987: LD_VAR 0 2
58991: PPUSH
58992: LD_VAR 0 3
58996: PPUSH
58997: CALL 53945 0 3
59001: NOT
59002: PUSH
59003: LD_VAR 0 1
59007: PPUSH
59008: CALL_OW 314
59012: AND
59013: IFFALSE 59017
// exit ;
59015: GO 59156
// until HexInfo ( x , y ) = unit and not HasTask ( unit ) ;
59017: LD_VAR 0 2
59021: PPUSH
59022: LD_VAR 0 3
59026: PPUSH
59027: CALL_OW 428
59031: PUSH
59032: LD_VAR 0 1
59036: EQUAL
59037: PUSH
59038: LD_VAR 0 1
59042: PPUSH
59043: CALL_OW 314
59047: NOT
59048: AND
59049: IFFALSE 58975
// PlaySoundXY ( x , y , PlantMine ) ;
59051: LD_VAR 0 2
59055: PPUSH
59056: LD_VAR 0 3
59060: PPUSH
59061: LD_STRING PlantMine
59063: PPUSH
59064: CALL_OW 366
// PlaceMine ( x , y , GetSide ( unit ) , 0 ) ;
59068: LD_VAR 0 2
59072: PPUSH
59073: LD_VAR 0 3
59077: PPUSH
59078: LD_VAR 0 1
59082: PPUSH
59083: CALL_OW 255
59087: PPUSH
59088: LD_INT 0
59090: PPUSH
59091: CALL_OW 454
// minerMinesList := ReplaceIn ( minerMinesList , [ index , minerMinesList [ index ] + 1 ] , [ x , y ] ) ;
59095: LD_ADDR_EXP 97
59099: PUSH
59100: LD_EXP 97
59104: PPUSH
59105: LD_VAR 0 5
59109: PUSH
59110: LD_EXP 97
59114: PUSH
59115: LD_VAR 0 5
59119: ARRAY
59120: PUSH
59121: LD_INT 1
59123: PLUS
59124: PUSH
59125: EMPTY
59126: LIST
59127: LIST
59128: PPUSH
59129: LD_VAR 0 2
59133: PUSH
59134: LD_VAR 0 3
59138: PUSH
59139: EMPTY
59140: LIST
59141: LIST
59142: PPUSH
59143: CALL 24096 0 3
59147: ST_TO_ADDR
// result := true ;
59148: LD_ADDR_VAR 0 4
59152: PUSH
59153: LD_INT 1
59155: ST_TO_ADDR
// end ;
59156: LD_VAR 0 4
59160: RET
// export function MinerDetonateMine ( unit , x , y ) ; var i , index ; begin
59161: LD_INT 0
59163: PPUSH
59164: PPUSH
59165: PPUSH
// if not unit in minersList then
59166: LD_VAR 0 1
59170: PUSH
59171: LD_EXP 96
59175: IN
59176: NOT
59177: IFFALSE 59181
// exit ;
59179: GO 59573
// index := GetElementIndex ( minersList , unit ) ;
59181: LD_ADDR_VAR 0 6
59185: PUSH
59186: LD_EXP 96
59190: PPUSH
59191: LD_VAR 0 1
59195: PPUSH
59196: CALL 23881 0 2
59200: ST_TO_ADDR
// for i := minerMinesList [ index ] downto 1 do
59201: LD_ADDR_VAR 0 5
59205: PUSH
59206: DOUBLE
59207: LD_EXP 97
59211: PUSH
59212: LD_VAR 0 6
59216: ARRAY
59217: INC
59218: ST_TO_ADDR
59219: LD_INT 1
59221: PUSH
59222: FOR_DOWNTO
59223: IFFALSE 59384
// begin if minerMinesList [ index ] [ i ] [ 1 ] = x and minerMinesList [ index ] [ i ] [ 2 ] = y then
59225: LD_EXP 97
59229: PUSH
59230: LD_VAR 0 6
59234: ARRAY
59235: PUSH
59236: LD_VAR 0 5
59240: ARRAY
59241: PUSH
59242: LD_INT 1
59244: ARRAY
59245: PUSH
59246: LD_VAR 0 2
59250: EQUAL
59251: PUSH
59252: LD_EXP 97
59256: PUSH
59257: LD_VAR 0 6
59261: ARRAY
59262: PUSH
59263: LD_VAR 0 5
59267: ARRAY
59268: PUSH
59269: LD_INT 2
59271: ARRAY
59272: PUSH
59273: LD_VAR 0 3
59277: EQUAL
59278: AND
59279: IFFALSE 59382
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
59281: LD_EXP 97
59285: PUSH
59286: LD_VAR 0 6
59290: ARRAY
59291: PUSH
59292: LD_VAR 0 5
59296: ARRAY
59297: PUSH
59298: LD_INT 1
59300: ARRAY
59301: PPUSH
59302: LD_EXP 97
59306: PUSH
59307: LD_VAR 0 6
59311: ARRAY
59312: PUSH
59313: LD_VAR 0 5
59317: ARRAY
59318: PUSH
59319: LD_INT 2
59321: ARRAY
59322: PPUSH
59323: LD_VAR 0 1
59327: PPUSH
59328: CALL_OW 255
59332: PPUSH
59333: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
59337: LD_ADDR_EXP 97
59341: PUSH
59342: LD_EXP 97
59346: PPUSH
59347: LD_VAR 0 6
59351: PPUSH
59352: LD_EXP 97
59356: PUSH
59357: LD_VAR 0 6
59361: ARRAY
59362: PPUSH
59363: LD_VAR 0 5
59367: PPUSH
59368: CALL_OW 3
59372: PPUSH
59373: CALL_OW 1
59377: ST_TO_ADDR
// exit ;
59378: POP
59379: POP
59380: GO 59573
// end ; end ;
59382: GO 59222
59384: POP
59385: POP
// for i := minerMinesList [ index ] downto 1 do
59386: LD_ADDR_VAR 0 5
59390: PUSH
59391: DOUBLE
59392: LD_EXP 97
59396: PUSH
59397: LD_VAR 0 6
59401: ARRAY
59402: INC
59403: ST_TO_ADDR
59404: LD_INT 1
59406: PUSH
59407: FOR_DOWNTO
59408: IFFALSE 59571
// begin if GetDistXY ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , x , y ) < 6 then
59410: LD_EXP 97
59414: PUSH
59415: LD_VAR 0 6
59419: ARRAY
59420: PUSH
59421: LD_VAR 0 5
59425: ARRAY
59426: PUSH
59427: LD_INT 1
59429: ARRAY
59430: PPUSH
59431: LD_EXP 97
59435: PUSH
59436: LD_VAR 0 6
59440: ARRAY
59441: PUSH
59442: LD_VAR 0 5
59446: ARRAY
59447: PUSH
59448: LD_INT 2
59450: ARRAY
59451: PPUSH
59452: LD_VAR 0 2
59456: PPUSH
59457: LD_VAR 0 3
59461: PPUSH
59462: CALL_OW 298
59466: PUSH
59467: LD_INT 6
59469: LESS
59470: IFFALSE 59569
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
59472: LD_EXP 97
59476: PUSH
59477: LD_VAR 0 6
59481: ARRAY
59482: PUSH
59483: LD_VAR 0 5
59487: ARRAY
59488: PUSH
59489: LD_INT 1
59491: ARRAY
59492: PPUSH
59493: LD_EXP 97
59497: PUSH
59498: LD_VAR 0 6
59502: ARRAY
59503: PUSH
59504: LD_VAR 0 5
59508: ARRAY
59509: PUSH
59510: LD_INT 2
59512: ARRAY
59513: PPUSH
59514: LD_VAR 0 1
59518: PPUSH
59519: CALL_OW 255
59523: PPUSH
59524: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
59528: LD_ADDR_EXP 97
59532: PUSH
59533: LD_EXP 97
59537: PPUSH
59538: LD_VAR 0 6
59542: PPUSH
59543: LD_EXP 97
59547: PUSH
59548: LD_VAR 0 6
59552: ARRAY
59553: PPUSH
59554: LD_VAR 0 5
59558: PPUSH
59559: CALL_OW 3
59563: PPUSH
59564: CALL_OW 1
59568: ST_TO_ADDR
// end ; end ;
59569: GO 59407
59571: POP
59572: POP
// end ;
59573: LD_VAR 0 4
59577: RET
// export function MinerCreateMinefield ( unit , x , y ) ; var i , index , tmp , minesFreeAmount , _x , _y , _d , _r ; begin
59578: LD_INT 0
59580: PPUSH
59581: PPUSH
59582: PPUSH
59583: PPUSH
59584: PPUSH
59585: PPUSH
59586: PPUSH
59587: PPUSH
59588: PPUSH
// if not GetWeapon ( unit ) = ar_miner or not unit in minersList then
59589: LD_VAR 0 1
59593: PPUSH
59594: CALL_OW 264
59598: PUSH
59599: LD_EXP 161
59603: EQUAL
59604: NOT
59605: PUSH
59606: LD_VAR 0 1
59610: PUSH
59611: LD_EXP 96
59615: IN
59616: NOT
59617: OR
59618: IFFALSE 59622
// exit ;
59620: GO 59944
// index := GetElementIndex ( minersList , unit ) ;
59622: LD_ADDR_VAR 0 6
59626: PUSH
59627: LD_EXP 96
59631: PPUSH
59632: LD_VAR 0 1
59636: PPUSH
59637: CALL 23881 0 2
59641: ST_TO_ADDR
// minesFreeAmount := minesLimitPerVehicle - minerMinesList [ index ] ;
59642: LD_ADDR_VAR 0 8
59646: PUSH
59647: LD_EXP 98
59651: PUSH
59652: LD_EXP 97
59656: PUSH
59657: LD_VAR 0 6
59661: ARRAY
59662: MINUS
59663: ST_TO_ADDR
// if not minesFreeAmount then
59664: LD_VAR 0 8
59668: NOT
59669: IFFALSE 59673
// exit ;
59671: GO 59944
// tmp := [ ] ;
59673: LD_ADDR_VAR 0 7
59677: PUSH
59678: EMPTY
59679: ST_TO_ADDR
// for i := 1 to minesFreeAmount do
59680: LD_ADDR_VAR 0 5
59684: PUSH
59685: DOUBLE
59686: LD_INT 1
59688: DEC
59689: ST_TO_ADDR
59690: LD_VAR 0 8
59694: PUSH
59695: FOR_TO
59696: IFFALSE 59891
// begin _d := rand ( 0 , 5 ) ;
59698: LD_ADDR_VAR 0 11
59702: PUSH
59703: LD_INT 0
59705: PPUSH
59706: LD_INT 5
59708: PPUSH
59709: CALL_OW 12
59713: ST_TO_ADDR
// _r := rand ( 2 , 6 ) ;
59714: LD_ADDR_VAR 0 12
59718: PUSH
59719: LD_INT 2
59721: PPUSH
59722: LD_INT 6
59724: PPUSH
59725: CALL_OW 12
59729: ST_TO_ADDR
// _x := ShiftX ( x , _d , _r ) ;
59730: LD_ADDR_VAR 0 9
59734: PUSH
59735: LD_VAR 0 2
59739: PPUSH
59740: LD_VAR 0 11
59744: PPUSH
59745: LD_VAR 0 12
59749: PPUSH
59750: CALL_OW 272
59754: ST_TO_ADDR
// _y := ShiftY ( y , _d , _r ) ;
59755: LD_ADDR_VAR 0 10
59759: PUSH
59760: LD_VAR 0 3
59764: PPUSH
59765: LD_VAR 0 11
59769: PPUSH
59770: LD_VAR 0 12
59774: PPUSH
59775: CALL_OW 273
59779: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not [ _x , _y ] in tmp and not MineAtPos ( _x , _y ) then
59780: LD_VAR 0 9
59784: PPUSH
59785: LD_VAR 0 10
59789: PPUSH
59790: CALL_OW 488
59794: PUSH
59795: LD_VAR 0 9
59799: PUSH
59800: LD_VAR 0 10
59804: PUSH
59805: EMPTY
59806: LIST
59807: LIST
59808: PUSH
59809: LD_VAR 0 7
59813: IN
59814: NOT
59815: AND
59816: PUSH
59817: LD_VAR 0 9
59821: PPUSH
59822: LD_VAR 0 10
59826: PPUSH
59827: CALL_OW 458
59831: NOT
59832: AND
59833: IFFALSE 59875
// tmp := Replace ( tmp , tmp + 1 , [ _x , _y ] ) else
59835: LD_ADDR_VAR 0 7
59839: PUSH
59840: LD_VAR 0 7
59844: PPUSH
59845: LD_VAR 0 7
59849: PUSH
59850: LD_INT 1
59852: PLUS
59853: PPUSH
59854: LD_VAR 0 9
59858: PUSH
59859: LD_VAR 0 10
59863: PUSH
59864: EMPTY
59865: LIST
59866: LIST
59867: PPUSH
59868: CALL_OW 1
59872: ST_TO_ADDR
59873: GO 59889
// i := i - 1 ;
59875: LD_ADDR_VAR 0 5
59879: PUSH
59880: LD_VAR 0 5
59884: PUSH
59885: LD_INT 1
59887: MINUS
59888: ST_TO_ADDR
// end ;
59889: GO 59695
59891: POP
59892: POP
// for i in tmp do
59893: LD_ADDR_VAR 0 5
59897: PUSH
59898: LD_VAR 0 7
59902: PUSH
59903: FOR_IN
59904: IFFALSE 59942
// if not MinerPlaceMine ( unit , i [ 1 ] , i [ 2 ] ) then
59906: LD_VAR 0 1
59910: PPUSH
59911: LD_VAR 0 5
59915: PUSH
59916: LD_INT 1
59918: ARRAY
59919: PPUSH
59920: LD_VAR 0 5
59924: PUSH
59925: LD_INT 2
59927: ARRAY
59928: PPUSH
59929: CALL 58884 0 3
59933: NOT
59934: IFFALSE 59940
// exit ;
59936: POP
59937: POP
59938: GO 59944
59940: GO 59903
59942: POP
59943: POP
// end ;
59944: LD_VAR 0 4
59948: RET
// export function ComBinocular ( unit , x , y ) ; var dist , side , viewRange , _x , _y , _d ; begin
59949: LD_INT 0
59951: PPUSH
59952: PPUSH
59953: PPUSH
59954: PPUSH
59955: PPUSH
59956: PPUSH
59957: PPUSH
// if not GetClass ( unit ) = class_sniper then
59958: LD_VAR 0 1
59962: PPUSH
59963: CALL_OW 257
59967: PUSH
59968: LD_INT 5
59970: EQUAL
59971: NOT
59972: IFFALSE 59976
// exit ;
59974: GO 60364
// dist := 8 ;
59976: LD_ADDR_VAR 0 5
59980: PUSH
59981: LD_INT 8
59983: ST_TO_ADDR
// viewRange := 12 ;
59984: LD_ADDR_VAR 0 7
59988: PUSH
59989: LD_INT 12
59991: ST_TO_ADDR
// side := GetSide ( unit ) ;
59992: LD_ADDR_VAR 0 6
59996: PUSH
59997: LD_VAR 0 1
60001: PPUSH
60002: CALL_OW 255
60006: ST_TO_ADDR
// if GetTech ( tech_opto2 , side ) = state_researched then
60007: LD_INT 61
60009: PPUSH
60010: LD_VAR 0 6
60014: PPUSH
60015: CALL_OW 321
60019: PUSH
60020: LD_INT 2
60022: EQUAL
60023: IFFALSE 60033
// viewRange := 16 ;
60025: LD_ADDR_VAR 0 7
60029: PUSH
60030: LD_INT 16
60032: ST_TO_ADDR
// if GetDistUnitXY ( unit , x , y ) > dist then
60033: LD_VAR 0 1
60037: PPUSH
60038: LD_VAR 0 2
60042: PPUSH
60043: LD_VAR 0 3
60047: PPUSH
60048: CALL_OW 297
60052: PUSH
60053: LD_VAR 0 5
60057: GREATER
60058: IFFALSE 60137
// begin ComMoveXY ( unit , x , y ) ;
60060: LD_VAR 0 1
60064: PPUSH
60065: LD_VAR 0 2
60069: PPUSH
60070: LD_VAR 0 3
60074: PPUSH
60075: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
60079: LD_INT 35
60081: PPUSH
60082: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) then
60086: LD_VAR 0 1
60090: PPUSH
60091: LD_VAR 0 2
60095: PPUSH
60096: LD_VAR 0 3
60100: PPUSH
60101: CALL 53945 0 3
60105: NOT
60106: IFFALSE 60110
// exit ;
60108: GO 60364
// until GetDistUnitXY ( unit , x , y ) < dist ;
60110: LD_VAR 0 1
60114: PPUSH
60115: LD_VAR 0 2
60119: PPUSH
60120: LD_VAR 0 3
60124: PPUSH
60125: CALL_OW 297
60129: PUSH
60130: LD_VAR 0 5
60134: LESS
60135: IFFALSE 60079
// end ; ComTurnXY ( unit , x , y ) ;
60137: LD_VAR 0 1
60141: PPUSH
60142: LD_VAR 0 2
60146: PPUSH
60147: LD_VAR 0 3
60151: PPUSH
60152: CALL_OW 118
// wait ( 5 ) ;
60156: LD_INT 5
60158: PPUSH
60159: CALL_OW 67
// _d := GetDir ( unit ) ;
60163: LD_ADDR_VAR 0 10
60167: PUSH
60168: LD_VAR 0 1
60172: PPUSH
60173: CALL_OW 254
60177: ST_TO_ADDR
// _x := ShiftX ( GetX ( unit ) , _d , dist ) ;
60178: LD_ADDR_VAR 0 8
60182: PUSH
60183: LD_VAR 0 1
60187: PPUSH
60188: CALL_OW 250
60192: PPUSH
60193: LD_VAR 0 10
60197: PPUSH
60198: LD_VAR 0 5
60202: PPUSH
60203: CALL_OW 272
60207: ST_TO_ADDR
// _y := ShiftY ( GetY ( unit ) , _d , dist ) ;
60208: LD_ADDR_VAR 0 9
60212: PUSH
60213: LD_VAR 0 1
60217: PPUSH
60218: CALL_OW 251
60222: PPUSH
60223: LD_VAR 0 10
60227: PPUSH
60228: LD_VAR 0 5
60232: PPUSH
60233: CALL_OW 273
60237: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
60238: LD_VAR 0 8
60242: PPUSH
60243: LD_VAR 0 9
60247: PPUSH
60248: CALL_OW 488
60252: NOT
60253: IFFALSE 60257
// exit ;
60255: GO 60364
// ComAnimCustom ( unit , 1 ) ;
60257: LD_VAR 0 1
60261: PPUSH
60262: LD_INT 1
60264: PPUSH
60265: CALL_OW 592
// PlaceSeeing ( _x , _y , side , viewRange ) ;
60269: LD_VAR 0 8
60273: PPUSH
60274: LD_VAR 0 9
60278: PPUSH
60279: LD_VAR 0 6
60283: PPUSH
60284: LD_VAR 0 7
60288: PPUSH
60289: CALL_OW 330
// repeat wait ( 1 ) ;
60293: LD_INT 1
60295: PPUSH
60296: CALL_OW 67
// until IsIdle ( unit ) or HasTask ( unit ) or not IsOk ( unit ) or IsDead ( unit ) ;
60300: LD_VAR 0 1
60304: PPUSH
60305: CALL_OW 316
60309: PUSH
60310: LD_VAR 0 1
60314: PPUSH
60315: CALL_OW 314
60319: OR
60320: PUSH
60321: LD_VAR 0 1
60325: PPUSH
60326: CALL_OW 302
60330: NOT
60331: OR
60332: PUSH
60333: LD_VAR 0 1
60337: PPUSH
60338: CALL_OW 301
60342: OR
60343: IFFALSE 60293
// RemoveSeeing ( _x , _y , side ) ;
60345: LD_VAR 0 8
60349: PPUSH
60350: LD_VAR 0 9
60354: PPUSH
60355: LD_VAR 0 6
60359: PPUSH
60360: CALL_OW 331
// end ; end_of_file
60364: LD_VAR 0 4
60368: RET
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin if p2 = 100 then
60369: LD_VAR 0 2
60373: PUSH
60374: LD_INT 100
60376: EQUAL
60377: IFFALSE 61326
// begin if not StreamModeActive then
60379: LD_EXP 99
60383: NOT
60384: IFFALSE 60394
// StreamModeActive := true ;
60386: LD_ADDR_EXP 99
60390: PUSH
60391: LD_INT 1
60393: ST_TO_ADDR
// if p3 = 0 then
60394: LD_VAR 0 3
60398: PUSH
60399: LD_INT 0
60401: EQUAL
60402: IFFALSE 60408
// InitStreamMode ;
60404: CALL 61484 0 0
// if p3 = 1 then
60408: LD_VAR 0 3
60412: PUSH
60413: LD_INT 1
60415: EQUAL
60416: IFFALSE 60426
// sRocket := true ;
60418: LD_ADDR_EXP 104
60422: PUSH
60423: LD_INT 1
60425: ST_TO_ADDR
// if p3 = 2 then
60426: LD_VAR 0 3
60430: PUSH
60431: LD_INT 2
60433: EQUAL
60434: IFFALSE 60444
// sSpeed := true ;
60436: LD_ADDR_EXP 103
60440: PUSH
60441: LD_INT 1
60443: ST_TO_ADDR
// if p3 = 3 then
60444: LD_VAR 0 3
60448: PUSH
60449: LD_INT 3
60451: EQUAL
60452: IFFALSE 60462
// sEngine := true ;
60454: LD_ADDR_EXP 105
60458: PUSH
60459: LD_INT 1
60461: ST_TO_ADDR
// if p3 = 4 then
60462: LD_VAR 0 3
60466: PUSH
60467: LD_INT 4
60469: EQUAL
60470: IFFALSE 60480
// sSpec := true ;
60472: LD_ADDR_EXP 102
60476: PUSH
60477: LD_INT 1
60479: ST_TO_ADDR
// if p3 = 5 then
60480: LD_VAR 0 3
60484: PUSH
60485: LD_INT 5
60487: EQUAL
60488: IFFALSE 60498
// sLevel := true ;
60490: LD_ADDR_EXP 106
60494: PUSH
60495: LD_INT 1
60497: ST_TO_ADDR
// if p3 = 6 then
60498: LD_VAR 0 3
60502: PUSH
60503: LD_INT 6
60505: EQUAL
60506: IFFALSE 60516
// sArmoury := true ;
60508: LD_ADDR_EXP 107
60512: PUSH
60513: LD_INT 1
60515: ST_TO_ADDR
// if p3 = 7 then
60516: LD_VAR 0 3
60520: PUSH
60521: LD_INT 7
60523: EQUAL
60524: IFFALSE 60534
// sRadar := true ;
60526: LD_ADDR_EXP 108
60530: PUSH
60531: LD_INT 1
60533: ST_TO_ADDR
// if p3 = 8 then
60534: LD_VAR 0 3
60538: PUSH
60539: LD_INT 8
60541: EQUAL
60542: IFFALSE 60552
// sBunker := true ;
60544: LD_ADDR_EXP 109
60548: PUSH
60549: LD_INT 1
60551: ST_TO_ADDR
// if p3 = 9 then
60552: LD_VAR 0 3
60556: PUSH
60557: LD_INT 9
60559: EQUAL
60560: IFFALSE 60570
// sHack := true ;
60562: LD_ADDR_EXP 110
60566: PUSH
60567: LD_INT 1
60569: ST_TO_ADDR
// if p3 = 10 then
60570: LD_VAR 0 3
60574: PUSH
60575: LD_INT 10
60577: EQUAL
60578: IFFALSE 60588
// sFire := true ;
60580: LD_ADDR_EXP 111
60584: PUSH
60585: LD_INT 1
60587: ST_TO_ADDR
// if p3 = 11 then
60588: LD_VAR 0 3
60592: PUSH
60593: LD_INT 11
60595: EQUAL
60596: IFFALSE 60606
// sRefresh := true ;
60598: LD_ADDR_EXP 112
60602: PUSH
60603: LD_INT 1
60605: ST_TO_ADDR
// if p3 = 12 then
60606: LD_VAR 0 3
60610: PUSH
60611: LD_INT 12
60613: EQUAL
60614: IFFALSE 60624
// sExp := true ;
60616: LD_ADDR_EXP 113
60620: PUSH
60621: LD_INT 1
60623: ST_TO_ADDR
// if p3 = 13 then
60624: LD_VAR 0 3
60628: PUSH
60629: LD_INT 13
60631: EQUAL
60632: IFFALSE 60642
// sDepot := true ;
60634: LD_ADDR_EXP 114
60638: PUSH
60639: LD_INT 1
60641: ST_TO_ADDR
// if p3 = 14 then
60642: LD_VAR 0 3
60646: PUSH
60647: LD_INT 14
60649: EQUAL
60650: IFFALSE 60660
// sFlag := true ;
60652: LD_ADDR_EXP 115
60656: PUSH
60657: LD_INT 1
60659: ST_TO_ADDR
// if p3 = 15 then
60660: LD_VAR 0 3
60664: PUSH
60665: LD_INT 15
60667: EQUAL
60668: IFFALSE 60678
// sKamikadze := true ;
60670: LD_ADDR_EXP 123
60674: PUSH
60675: LD_INT 1
60677: ST_TO_ADDR
// if p3 = 16 then
60678: LD_VAR 0 3
60682: PUSH
60683: LD_INT 16
60685: EQUAL
60686: IFFALSE 60696
// sTroll := true ;
60688: LD_ADDR_EXP 124
60692: PUSH
60693: LD_INT 1
60695: ST_TO_ADDR
// if p3 = 17 then
60696: LD_VAR 0 3
60700: PUSH
60701: LD_INT 17
60703: EQUAL
60704: IFFALSE 60714
// sSlow := true ;
60706: LD_ADDR_EXP 125
60710: PUSH
60711: LD_INT 1
60713: ST_TO_ADDR
// if p3 = 18 then
60714: LD_VAR 0 3
60718: PUSH
60719: LD_INT 18
60721: EQUAL
60722: IFFALSE 60732
// sLack := true ;
60724: LD_ADDR_EXP 126
60728: PUSH
60729: LD_INT 1
60731: ST_TO_ADDR
// if p3 = 19 then
60732: LD_VAR 0 3
60736: PUSH
60737: LD_INT 19
60739: EQUAL
60740: IFFALSE 60750
// sTank := true ;
60742: LD_ADDR_EXP 128
60746: PUSH
60747: LD_INT 1
60749: ST_TO_ADDR
// if p3 = 20 then
60750: LD_VAR 0 3
60754: PUSH
60755: LD_INT 20
60757: EQUAL
60758: IFFALSE 60768
// sRemote := true ;
60760: LD_ADDR_EXP 129
60764: PUSH
60765: LD_INT 1
60767: ST_TO_ADDR
// if p3 = 21 then
60768: LD_VAR 0 3
60772: PUSH
60773: LD_INT 21
60775: EQUAL
60776: IFFALSE 60786
// sPowell := true ;
60778: LD_ADDR_EXP 130
60782: PUSH
60783: LD_INT 1
60785: ST_TO_ADDR
// if p3 = 22 then
60786: LD_VAR 0 3
60790: PUSH
60791: LD_INT 22
60793: EQUAL
60794: IFFALSE 60804
// sTeleport := true ;
60796: LD_ADDR_EXP 133
60800: PUSH
60801: LD_INT 1
60803: ST_TO_ADDR
// if p3 = 23 then
60804: LD_VAR 0 3
60808: PUSH
60809: LD_INT 23
60811: EQUAL
60812: IFFALSE 60822
// sOilTower := true ;
60814: LD_ADDR_EXP 135
60818: PUSH
60819: LD_INT 1
60821: ST_TO_ADDR
// if p3 = 24 then
60822: LD_VAR 0 3
60826: PUSH
60827: LD_INT 24
60829: EQUAL
60830: IFFALSE 60840
// sShovel := true ;
60832: LD_ADDR_EXP 136
60836: PUSH
60837: LD_INT 1
60839: ST_TO_ADDR
// if p3 = 25 then
60840: LD_VAR 0 3
60844: PUSH
60845: LD_INT 25
60847: EQUAL
60848: IFFALSE 60858
// sSheik := true ;
60850: LD_ADDR_EXP 137
60854: PUSH
60855: LD_INT 1
60857: ST_TO_ADDR
// if p3 = 26 then
60858: LD_VAR 0 3
60862: PUSH
60863: LD_INT 26
60865: EQUAL
60866: IFFALSE 60876
// sEarthquake := true ;
60868: LD_ADDR_EXP 139
60872: PUSH
60873: LD_INT 1
60875: ST_TO_ADDR
// if p3 = 27 then
60876: LD_VAR 0 3
60880: PUSH
60881: LD_INT 27
60883: EQUAL
60884: IFFALSE 60894
// sAI := true ;
60886: LD_ADDR_EXP 140
60890: PUSH
60891: LD_INT 1
60893: ST_TO_ADDR
// if p3 = 28 then
60894: LD_VAR 0 3
60898: PUSH
60899: LD_INT 28
60901: EQUAL
60902: IFFALSE 60912
// sCargo := true ;
60904: LD_ADDR_EXP 143
60908: PUSH
60909: LD_INT 1
60911: ST_TO_ADDR
// if p3 = 29 then
60912: LD_VAR 0 3
60916: PUSH
60917: LD_INT 29
60919: EQUAL
60920: IFFALSE 60930
// sDLaser := true ;
60922: LD_ADDR_EXP 144
60926: PUSH
60927: LD_INT 1
60929: ST_TO_ADDR
// if p3 = 30 then
60930: LD_VAR 0 3
60934: PUSH
60935: LD_INT 30
60937: EQUAL
60938: IFFALSE 60948
// sExchange := true ;
60940: LD_ADDR_EXP 145
60944: PUSH
60945: LD_INT 1
60947: ST_TO_ADDR
// if p3 = 31 then
60948: LD_VAR 0 3
60952: PUSH
60953: LD_INT 31
60955: EQUAL
60956: IFFALSE 60966
// sFac := true ;
60958: LD_ADDR_EXP 146
60962: PUSH
60963: LD_INT 1
60965: ST_TO_ADDR
// if p3 = 32 then
60966: LD_VAR 0 3
60970: PUSH
60971: LD_INT 32
60973: EQUAL
60974: IFFALSE 60984
// sPower := true ;
60976: LD_ADDR_EXP 147
60980: PUSH
60981: LD_INT 1
60983: ST_TO_ADDR
// if p3 = 33 then
60984: LD_VAR 0 3
60988: PUSH
60989: LD_INT 33
60991: EQUAL
60992: IFFALSE 61002
// sRandom := true ;
60994: LD_ADDR_EXP 148
60998: PUSH
60999: LD_INT 1
61001: ST_TO_ADDR
// if p3 = 34 then
61002: LD_VAR 0 3
61006: PUSH
61007: LD_INT 34
61009: EQUAL
61010: IFFALSE 61020
// sShield := true ;
61012: LD_ADDR_EXP 149
61016: PUSH
61017: LD_INT 1
61019: ST_TO_ADDR
// if p3 = 35 then
61020: LD_VAR 0 3
61024: PUSH
61025: LD_INT 35
61027: EQUAL
61028: IFFALSE 61038
// sTime := true ;
61030: LD_ADDR_EXP 150
61034: PUSH
61035: LD_INT 1
61037: ST_TO_ADDR
// if p3 = 36 then
61038: LD_VAR 0 3
61042: PUSH
61043: LD_INT 36
61045: EQUAL
61046: IFFALSE 61056
// sTools := true ;
61048: LD_ADDR_EXP 151
61052: PUSH
61053: LD_INT 1
61055: ST_TO_ADDR
// if p3 = 101 then
61056: LD_VAR 0 3
61060: PUSH
61061: LD_INT 101
61063: EQUAL
61064: IFFALSE 61074
// sSold := true ;
61066: LD_ADDR_EXP 116
61070: PUSH
61071: LD_INT 1
61073: ST_TO_ADDR
// if p3 = 102 then
61074: LD_VAR 0 3
61078: PUSH
61079: LD_INT 102
61081: EQUAL
61082: IFFALSE 61092
// sDiff := true ;
61084: LD_ADDR_EXP 117
61088: PUSH
61089: LD_INT 1
61091: ST_TO_ADDR
// if p3 = 103 then
61092: LD_VAR 0 3
61096: PUSH
61097: LD_INT 103
61099: EQUAL
61100: IFFALSE 61110
// sFog := true ;
61102: LD_ADDR_EXP 120
61106: PUSH
61107: LD_INT 1
61109: ST_TO_ADDR
// if p3 = 104 then
61110: LD_VAR 0 3
61114: PUSH
61115: LD_INT 104
61117: EQUAL
61118: IFFALSE 61128
// sReset := true ;
61120: LD_ADDR_EXP 121
61124: PUSH
61125: LD_INT 1
61127: ST_TO_ADDR
// if p3 = 105 then
61128: LD_VAR 0 3
61132: PUSH
61133: LD_INT 105
61135: EQUAL
61136: IFFALSE 61146
// sSun := true ;
61138: LD_ADDR_EXP 122
61142: PUSH
61143: LD_INT 1
61145: ST_TO_ADDR
// if p3 = 106 then
61146: LD_VAR 0 3
61150: PUSH
61151: LD_INT 106
61153: EQUAL
61154: IFFALSE 61164
// sTiger := true ;
61156: LD_ADDR_EXP 118
61160: PUSH
61161: LD_INT 1
61163: ST_TO_ADDR
// if p3 = 107 then
61164: LD_VAR 0 3
61168: PUSH
61169: LD_INT 107
61171: EQUAL
61172: IFFALSE 61182
// sBomb := true ;
61174: LD_ADDR_EXP 119
61178: PUSH
61179: LD_INT 1
61181: ST_TO_ADDR
// if p3 = 108 then
61182: LD_VAR 0 3
61186: PUSH
61187: LD_INT 108
61189: EQUAL
61190: IFFALSE 61200
// sWound := true ;
61192: LD_ADDR_EXP 127
61196: PUSH
61197: LD_INT 1
61199: ST_TO_ADDR
// if p3 = 109 then
61200: LD_VAR 0 3
61204: PUSH
61205: LD_INT 109
61207: EQUAL
61208: IFFALSE 61218
// sBetray := true ;
61210: LD_ADDR_EXP 131
61214: PUSH
61215: LD_INT 1
61217: ST_TO_ADDR
// if p3 = 110 then
61218: LD_VAR 0 3
61222: PUSH
61223: LD_INT 110
61225: EQUAL
61226: IFFALSE 61236
// sContamin := true ;
61228: LD_ADDR_EXP 132
61232: PUSH
61233: LD_INT 1
61235: ST_TO_ADDR
// if p3 = 111 then
61236: LD_VAR 0 3
61240: PUSH
61241: LD_INT 111
61243: EQUAL
61244: IFFALSE 61254
// sOil := true ;
61246: LD_ADDR_EXP 134
61250: PUSH
61251: LD_INT 1
61253: ST_TO_ADDR
// if p3 = 112 then
61254: LD_VAR 0 3
61258: PUSH
61259: LD_INT 112
61261: EQUAL
61262: IFFALSE 61272
// sStu := true ;
61264: LD_ADDR_EXP 138
61268: PUSH
61269: LD_INT 1
61271: ST_TO_ADDR
// if p3 = 113 then
61272: LD_VAR 0 3
61276: PUSH
61277: LD_INT 113
61279: EQUAL
61280: IFFALSE 61290
// sBazooka := true ;
61282: LD_ADDR_EXP 141
61286: PUSH
61287: LD_INT 1
61289: ST_TO_ADDR
// if p3 = 114 then
61290: LD_VAR 0 3
61294: PUSH
61295: LD_INT 114
61297: EQUAL
61298: IFFALSE 61308
// sMortar := true ;
61300: LD_ADDR_EXP 142
61304: PUSH
61305: LD_INT 1
61307: ST_TO_ADDR
// if p3 = 115 then
61308: LD_VAR 0 3
61312: PUSH
61313: LD_INT 115
61315: EQUAL
61316: IFFALSE 61326
// sRanger := true ;
61318: LD_ADDR_EXP 152
61322: PUSH
61323: LD_INT 1
61325: ST_TO_ADDR
// end ; if p2 = 101 then
61326: LD_VAR 0 2
61330: PUSH
61331: LD_INT 101
61333: EQUAL
61334: IFFALSE 61462
// begin case p3 of 1 :
61336: LD_VAR 0 3
61340: PUSH
61341: LD_INT 1
61343: DOUBLE
61344: EQUAL
61345: IFTRUE 61349
61347: GO 61356
61349: POP
// hHackUnlimitedResources ; 2 :
61350: CALL 72497 0 0
61354: GO 61462
61356: LD_INT 2
61358: DOUBLE
61359: EQUAL
61360: IFTRUE 61364
61362: GO 61371
61364: POP
// hHackSetLevel10 ; 3 :
61365: CALL 72630 0 0
61369: GO 61462
61371: LD_INT 3
61373: DOUBLE
61374: EQUAL
61375: IFTRUE 61379
61377: GO 61386
61379: POP
// hHackSetLevel10YourUnits ; 4 :
61380: CALL 72715 0 0
61384: GO 61462
61386: LD_INT 4
61388: DOUBLE
61389: EQUAL
61390: IFTRUE 61394
61392: GO 61401
61394: POP
// hHackInvincible ; 5 :
61395: CALL 73163 0 0
61399: GO 61462
61401: LD_INT 5
61403: DOUBLE
61404: EQUAL
61405: IFTRUE 61409
61407: GO 61416
61409: POP
// hHackInvisible ; 6 :
61410: CALL 73274 0 0
61414: GO 61462
61416: LD_INT 6
61418: DOUBLE
61419: EQUAL
61420: IFTRUE 61424
61422: GO 61431
61424: POP
// hHackChangeYourSide ; 7 :
61425: CALL 73331 0 0
61429: GO 61462
61431: LD_INT 7
61433: DOUBLE
61434: EQUAL
61435: IFTRUE 61439
61437: GO 61446
61439: POP
// hHackChangeUnitSide ; 8 :
61440: CALL 73373 0 0
61444: GO 61462
61446: LD_INT 8
61448: DOUBLE
61449: EQUAL
61450: IFTRUE 61454
61452: GO 61461
61454: POP
// hHackFog ; end ;
61455: CALL 73474 0 0
61459: GO 61462
61461: POP
// end ; end ;
61462: PPOPN 6
61464: END
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger ; every 0 0$1 do
61465: GO 61467
61467: DISABLE
// begin ToLua ( initStreamRollete(); ) ;
61468: LD_STRING initStreamRollete();
61470: PPUSH
61471: CALL_OW 559
// InitStreamMode ;
61475: CALL 61484 0 0
// DefineStreamItems ( ) ;
61479: CALL 61924 0 0
// end ;
61483: END
// function InitStreamMode ; begin
61484: LD_INT 0
61486: PPUSH
// streamModeActive := false ;
61487: LD_ADDR_EXP 99
61491: PUSH
61492: LD_INT 0
61494: ST_TO_ADDR
// normalCounter := 36 ;
61495: LD_ADDR_EXP 100
61499: PUSH
61500: LD_INT 36
61502: ST_TO_ADDR
// hardcoreCounter := 16 ;
61503: LD_ADDR_EXP 101
61507: PUSH
61508: LD_INT 16
61510: ST_TO_ADDR
// sRocket := false ;
61511: LD_ADDR_EXP 104
61515: PUSH
61516: LD_INT 0
61518: ST_TO_ADDR
// sSpeed := false ;
61519: LD_ADDR_EXP 103
61523: PUSH
61524: LD_INT 0
61526: ST_TO_ADDR
// sEngine := false ;
61527: LD_ADDR_EXP 105
61531: PUSH
61532: LD_INT 0
61534: ST_TO_ADDR
// sSpec := false ;
61535: LD_ADDR_EXP 102
61539: PUSH
61540: LD_INT 0
61542: ST_TO_ADDR
// sLevel := false ;
61543: LD_ADDR_EXP 106
61547: PUSH
61548: LD_INT 0
61550: ST_TO_ADDR
// sArmoury := false ;
61551: LD_ADDR_EXP 107
61555: PUSH
61556: LD_INT 0
61558: ST_TO_ADDR
// sRadar := false ;
61559: LD_ADDR_EXP 108
61563: PUSH
61564: LD_INT 0
61566: ST_TO_ADDR
// sBunker := false ;
61567: LD_ADDR_EXP 109
61571: PUSH
61572: LD_INT 0
61574: ST_TO_ADDR
// sHack := false ;
61575: LD_ADDR_EXP 110
61579: PUSH
61580: LD_INT 0
61582: ST_TO_ADDR
// sFire := false ;
61583: LD_ADDR_EXP 111
61587: PUSH
61588: LD_INT 0
61590: ST_TO_ADDR
// sRefresh := false ;
61591: LD_ADDR_EXP 112
61595: PUSH
61596: LD_INT 0
61598: ST_TO_ADDR
// sExp := false ;
61599: LD_ADDR_EXP 113
61603: PUSH
61604: LD_INT 0
61606: ST_TO_ADDR
// sDepot := false ;
61607: LD_ADDR_EXP 114
61611: PUSH
61612: LD_INT 0
61614: ST_TO_ADDR
// sFlag := false ;
61615: LD_ADDR_EXP 115
61619: PUSH
61620: LD_INT 0
61622: ST_TO_ADDR
// sKamikadze := false ;
61623: LD_ADDR_EXP 123
61627: PUSH
61628: LD_INT 0
61630: ST_TO_ADDR
// sTroll := false ;
61631: LD_ADDR_EXP 124
61635: PUSH
61636: LD_INT 0
61638: ST_TO_ADDR
// sSlow := false ;
61639: LD_ADDR_EXP 125
61643: PUSH
61644: LD_INT 0
61646: ST_TO_ADDR
// sLack := false ;
61647: LD_ADDR_EXP 126
61651: PUSH
61652: LD_INT 0
61654: ST_TO_ADDR
// sTank := false ;
61655: LD_ADDR_EXP 128
61659: PUSH
61660: LD_INT 0
61662: ST_TO_ADDR
// sRemote := false ;
61663: LD_ADDR_EXP 129
61667: PUSH
61668: LD_INT 0
61670: ST_TO_ADDR
// sPowell := false ;
61671: LD_ADDR_EXP 130
61675: PUSH
61676: LD_INT 0
61678: ST_TO_ADDR
// sTeleport := false ;
61679: LD_ADDR_EXP 133
61683: PUSH
61684: LD_INT 0
61686: ST_TO_ADDR
// sOilTower := false ;
61687: LD_ADDR_EXP 135
61691: PUSH
61692: LD_INT 0
61694: ST_TO_ADDR
// sShovel := false ;
61695: LD_ADDR_EXP 136
61699: PUSH
61700: LD_INT 0
61702: ST_TO_ADDR
// sSheik := false ;
61703: LD_ADDR_EXP 137
61707: PUSH
61708: LD_INT 0
61710: ST_TO_ADDR
// sEarthquake := false ;
61711: LD_ADDR_EXP 139
61715: PUSH
61716: LD_INT 0
61718: ST_TO_ADDR
// sAI := false ;
61719: LD_ADDR_EXP 140
61723: PUSH
61724: LD_INT 0
61726: ST_TO_ADDR
// sCargo := false ;
61727: LD_ADDR_EXP 143
61731: PUSH
61732: LD_INT 0
61734: ST_TO_ADDR
// sDLaser := false ;
61735: LD_ADDR_EXP 144
61739: PUSH
61740: LD_INT 0
61742: ST_TO_ADDR
// sExchange := false ;
61743: LD_ADDR_EXP 145
61747: PUSH
61748: LD_INT 0
61750: ST_TO_ADDR
// sFac := false ;
61751: LD_ADDR_EXP 146
61755: PUSH
61756: LD_INT 0
61758: ST_TO_ADDR
// sPower := false ;
61759: LD_ADDR_EXP 147
61763: PUSH
61764: LD_INT 0
61766: ST_TO_ADDR
// sRandom := false ;
61767: LD_ADDR_EXP 148
61771: PUSH
61772: LD_INT 0
61774: ST_TO_ADDR
// sShield := false ;
61775: LD_ADDR_EXP 149
61779: PUSH
61780: LD_INT 0
61782: ST_TO_ADDR
// sTime := false ;
61783: LD_ADDR_EXP 150
61787: PUSH
61788: LD_INT 0
61790: ST_TO_ADDR
// sTools := false ;
61791: LD_ADDR_EXP 151
61795: PUSH
61796: LD_INT 0
61798: ST_TO_ADDR
// sSold := false ;
61799: LD_ADDR_EXP 116
61803: PUSH
61804: LD_INT 0
61806: ST_TO_ADDR
// sDiff := false ;
61807: LD_ADDR_EXP 117
61811: PUSH
61812: LD_INT 0
61814: ST_TO_ADDR
// sFog := false ;
61815: LD_ADDR_EXP 120
61819: PUSH
61820: LD_INT 0
61822: ST_TO_ADDR
// sReset := false ;
61823: LD_ADDR_EXP 121
61827: PUSH
61828: LD_INT 0
61830: ST_TO_ADDR
// sSun := false ;
61831: LD_ADDR_EXP 122
61835: PUSH
61836: LD_INT 0
61838: ST_TO_ADDR
// sTiger := false ;
61839: LD_ADDR_EXP 118
61843: PUSH
61844: LD_INT 0
61846: ST_TO_ADDR
// sBomb := false ;
61847: LD_ADDR_EXP 119
61851: PUSH
61852: LD_INT 0
61854: ST_TO_ADDR
// sWound := false ;
61855: LD_ADDR_EXP 127
61859: PUSH
61860: LD_INT 0
61862: ST_TO_ADDR
// sBetray := false ;
61863: LD_ADDR_EXP 131
61867: PUSH
61868: LD_INT 0
61870: ST_TO_ADDR
// sContamin := false ;
61871: LD_ADDR_EXP 132
61875: PUSH
61876: LD_INT 0
61878: ST_TO_ADDR
// sOil := false ;
61879: LD_ADDR_EXP 134
61883: PUSH
61884: LD_INT 0
61886: ST_TO_ADDR
// sStu := false ;
61887: LD_ADDR_EXP 138
61891: PUSH
61892: LD_INT 0
61894: ST_TO_ADDR
// sBazooka := false ;
61895: LD_ADDR_EXP 141
61899: PUSH
61900: LD_INT 0
61902: ST_TO_ADDR
// sMortar := false ;
61903: LD_ADDR_EXP 142
61907: PUSH
61908: LD_INT 0
61910: ST_TO_ADDR
// sRanger := false ;
61911: LD_ADDR_EXP 152
61915: PUSH
61916: LD_INT 0
61918: ST_TO_ADDR
// end ;
61919: LD_VAR 0 1
61923: RET
// function DefineStreamItems ( ) ; var tmp , normal , hardcore , i ; begin
61924: LD_INT 0
61926: PPUSH
61927: PPUSH
61928: PPUSH
61929: PPUSH
61930: PPUSH
// result := [ ] ;
61931: LD_ADDR_VAR 0 1
61935: PUSH
61936: EMPTY
61937: ST_TO_ADDR
// if campaign_id = 1 then
61938: LD_OWVAR 69
61942: PUSH
61943: LD_INT 1
61945: EQUAL
61946: IFFALSE 64884
// begin case mission_number of 1 :
61948: LD_OWVAR 70
61952: PUSH
61953: LD_INT 1
61955: DOUBLE
61956: EQUAL
61957: IFTRUE 61961
61959: GO 62025
61961: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 ] ] ; 2 :
61962: LD_ADDR_VAR 0 1
61966: PUSH
61967: LD_INT 2
61969: PUSH
61970: LD_INT 4
61972: PUSH
61973: LD_INT 11
61975: PUSH
61976: LD_INT 12
61978: PUSH
61979: LD_INT 15
61981: PUSH
61982: LD_INT 16
61984: PUSH
61985: LD_INT 22
61987: PUSH
61988: LD_INT 23
61990: PUSH
61991: LD_INT 26
61993: PUSH
61994: EMPTY
61995: LIST
61996: LIST
61997: LIST
61998: LIST
61999: LIST
62000: LIST
62001: LIST
62002: LIST
62003: LIST
62004: PUSH
62005: LD_INT 101
62007: PUSH
62008: LD_INT 102
62010: PUSH
62011: LD_INT 106
62013: PUSH
62014: EMPTY
62015: LIST
62016: LIST
62017: LIST
62018: PUSH
62019: EMPTY
62020: LIST
62021: LIST
62022: ST_TO_ADDR
62023: GO 64882
62025: LD_INT 2
62027: DOUBLE
62028: EQUAL
62029: IFTRUE 62033
62031: GO 62105
62033: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 3 :
62034: LD_ADDR_VAR 0 1
62038: PUSH
62039: LD_INT 2
62041: PUSH
62042: LD_INT 4
62044: PUSH
62045: LD_INT 11
62047: PUSH
62048: LD_INT 12
62050: PUSH
62051: LD_INT 15
62053: PUSH
62054: LD_INT 16
62056: PUSH
62057: LD_INT 22
62059: PUSH
62060: LD_INT 23
62062: PUSH
62063: LD_INT 26
62065: PUSH
62066: EMPTY
62067: LIST
62068: LIST
62069: LIST
62070: LIST
62071: LIST
62072: LIST
62073: LIST
62074: LIST
62075: LIST
62076: PUSH
62077: LD_INT 101
62079: PUSH
62080: LD_INT 102
62082: PUSH
62083: LD_INT 105
62085: PUSH
62086: LD_INT 106
62088: PUSH
62089: LD_INT 108
62091: PUSH
62092: EMPTY
62093: LIST
62094: LIST
62095: LIST
62096: LIST
62097: LIST
62098: PUSH
62099: EMPTY
62100: LIST
62101: LIST
62102: ST_TO_ADDR
62103: GO 64882
62105: LD_INT 3
62107: DOUBLE
62108: EQUAL
62109: IFTRUE 62113
62111: GO 62189
62113: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 4 :
62114: LD_ADDR_VAR 0 1
62118: PUSH
62119: LD_INT 2
62121: PUSH
62122: LD_INT 4
62124: PUSH
62125: LD_INT 5
62127: PUSH
62128: LD_INT 11
62130: PUSH
62131: LD_INT 12
62133: PUSH
62134: LD_INT 15
62136: PUSH
62137: LD_INT 16
62139: PUSH
62140: LD_INT 22
62142: PUSH
62143: LD_INT 26
62145: PUSH
62146: LD_INT 36
62148: PUSH
62149: EMPTY
62150: LIST
62151: LIST
62152: LIST
62153: LIST
62154: LIST
62155: LIST
62156: LIST
62157: LIST
62158: LIST
62159: LIST
62160: PUSH
62161: LD_INT 101
62163: PUSH
62164: LD_INT 102
62166: PUSH
62167: LD_INT 105
62169: PUSH
62170: LD_INT 106
62172: PUSH
62173: LD_INT 108
62175: PUSH
62176: EMPTY
62177: LIST
62178: LIST
62179: LIST
62180: LIST
62181: LIST
62182: PUSH
62183: EMPTY
62184: LIST
62185: LIST
62186: ST_TO_ADDR
62187: GO 64882
62189: LD_INT 4
62191: DOUBLE
62192: EQUAL
62193: IFTRUE 62197
62195: GO 62281
62197: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 5 :
62198: LD_ADDR_VAR 0 1
62202: PUSH
62203: LD_INT 2
62205: PUSH
62206: LD_INT 4
62208: PUSH
62209: LD_INT 5
62211: PUSH
62212: LD_INT 8
62214: PUSH
62215: LD_INT 11
62217: PUSH
62218: LD_INT 12
62220: PUSH
62221: LD_INT 15
62223: PUSH
62224: LD_INT 16
62226: PUSH
62227: LD_INT 22
62229: PUSH
62230: LD_INT 23
62232: PUSH
62233: LD_INT 26
62235: PUSH
62236: LD_INT 36
62238: PUSH
62239: EMPTY
62240: LIST
62241: LIST
62242: LIST
62243: LIST
62244: LIST
62245: LIST
62246: LIST
62247: LIST
62248: LIST
62249: LIST
62250: LIST
62251: LIST
62252: PUSH
62253: LD_INT 101
62255: PUSH
62256: LD_INT 102
62258: PUSH
62259: LD_INT 105
62261: PUSH
62262: LD_INT 106
62264: PUSH
62265: LD_INT 108
62267: PUSH
62268: EMPTY
62269: LIST
62270: LIST
62271: LIST
62272: LIST
62273: LIST
62274: PUSH
62275: EMPTY
62276: LIST
62277: LIST
62278: ST_TO_ADDR
62279: GO 64882
62281: LD_INT 5
62283: DOUBLE
62284: EQUAL
62285: IFTRUE 62289
62287: GO 62389
62289: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 6 :
62290: LD_ADDR_VAR 0 1
62294: PUSH
62295: LD_INT 2
62297: PUSH
62298: LD_INT 4
62300: PUSH
62301: LD_INT 5
62303: PUSH
62304: LD_INT 6
62306: PUSH
62307: LD_INT 8
62309: PUSH
62310: LD_INT 11
62312: PUSH
62313: LD_INT 12
62315: PUSH
62316: LD_INT 15
62318: PUSH
62319: LD_INT 16
62321: PUSH
62322: LD_INT 22
62324: PUSH
62325: LD_INT 23
62327: PUSH
62328: LD_INT 25
62330: PUSH
62331: LD_INT 26
62333: PUSH
62334: LD_INT 36
62336: PUSH
62337: EMPTY
62338: LIST
62339: LIST
62340: LIST
62341: LIST
62342: LIST
62343: LIST
62344: LIST
62345: LIST
62346: LIST
62347: LIST
62348: LIST
62349: LIST
62350: LIST
62351: LIST
62352: PUSH
62353: LD_INT 101
62355: PUSH
62356: LD_INT 102
62358: PUSH
62359: LD_INT 105
62361: PUSH
62362: LD_INT 106
62364: PUSH
62365: LD_INT 108
62367: PUSH
62368: LD_INT 109
62370: PUSH
62371: LD_INT 112
62373: PUSH
62374: EMPTY
62375: LIST
62376: LIST
62377: LIST
62378: LIST
62379: LIST
62380: LIST
62381: LIST
62382: PUSH
62383: EMPTY
62384: LIST
62385: LIST
62386: ST_TO_ADDR
62387: GO 64882
62389: LD_INT 6
62391: DOUBLE
62392: EQUAL
62393: IFTRUE 62397
62395: GO 62517
62397: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 7 :
62398: LD_ADDR_VAR 0 1
62402: PUSH
62403: LD_INT 2
62405: PUSH
62406: LD_INT 4
62408: PUSH
62409: LD_INT 5
62411: PUSH
62412: LD_INT 6
62414: PUSH
62415: LD_INT 8
62417: PUSH
62418: LD_INT 11
62420: PUSH
62421: LD_INT 12
62423: PUSH
62424: LD_INT 15
62426: PUSH
62427: LD_INT 16
62429: PUSH
62430: LD_INT 20
62432: PUSH
62433: LD_INT 21
62435: PUSH
62436: LD_INT 22
62438: PUSH
62439: LD_INT 23
62441: PUSH
62442: LD_INT 25
62444: PUSH
62445: LD_INT 26
62447: PUSH
62448: LD_INT 30
62450: PUSH
62451: LD_INT 31
62453: PUSH
62454: LD_INT 32
62456: PUSH
62457: LD_INT 36
62459: PUSH
62460: EMPTY
62461: LIST
62462: LIST
62463: LIST
62464: LIST
62465: LIST
62466: LIST
62467: LIST
62468: LIST
62469: LIST
62470: LIST
62471: LIST
62472: LIST
62473: LIST
62474: LIST
62475: LIST
62476: LIST
62477: LIST
62478: LIST
62479: LIST
62480: PUSH
62481: LD_INT 101
62483: PUSH
62484: LD_INT 102
62486: PUSH
62487: LD_INT 105
62489: PUSH
62490: LD_INT 106
62492: PUSH
62493: LD_INT 108
62495: PUSH
62496: LD_INT 109
62498: PUSH
62499: LD_INT 112
62501: PUSH
62502: EMPTY
62503: LIST
62504: LIST
62505: LIST
62506: LIST
62507: LIST
62508: LIST
62509: LIST
62510: PUSH
62511: EMPTY
62512: LIST
62513: LIST
62514: ST_TO_ADDR
62515: GO 64882
62517: LD_INT 7
62519: DOUBLE
62520: EQUAL
62521: IFTRUE 62525
62523: GO 62625
62525: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 ] ] ; 8 :
62526: LD_ADDR_VAR 0 1
62530: PUSH
62531: LD_INT 2
62533: PUSH
62534: LD_INT 4
62536: PUSH
62537: LD_INT 5
62539: PUSH
62540: LD_INT 7
62542: PUSH
62543: LD_INT 11
62545: PUSH
62546: LD_INT 12
62548: PUSH
62549: LD_INT 15
62551: PUSH
62552: LD_INT 16
62554: PUSH
62555: LD_INT 20
62557: PUSH
62558: LD_INT 21
62560: PUSH
62561: LD_INT 22
62563: PUSH
62564: LD_INT 23
62566: PUSH
62567: LD_INT 25
62569: PUSH
62570: LD_INT 26
62572: PUSH
62573: EMPTY
62574: LIST
62575: LIST
62576: LIST
62577: LIST
62578: LIST
62579: LIST
62580: LIST
62581: LIST
62582: LIST
62583: LIST
62584: LIST
62585: LIST
62586: LIST
62587: LIST
62588: PUSH
62589: LD_INT 101
62591: PUSH
62592: LD_INT 102
62594: PUSH
62595: LD_INT 103
62597: PUSH
62598: LD_INT 105
62600: PUSH
62601: LD_INT 106
62603: PUSH
62604: LD_INT 108
62606: PUSH
62607: LD_INT 112
62609: PUSH
62610: EMPTY
62611: LIST
62612: LIST
62613: LIST
62614: LIST
62615: LIST
62616: LIST
62617: LIST
62618: PUSH
62619: EMPTY
62620: LIST
62621: LIST
62622: ST_TO_ADDR
62623: GO 64882
62625: LD_INT 8
62627: DOUBLE
62628: EQUAL
62629: IFTRUE 62633
62631: GO 62761
62633: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 ] ] ; 9 :
62634: LD_ADDR_VAR 0 1
62638: PUSH
62639: LD_INT 2
62641: PUSH
62642: LD_INT 4
62644: PUSH
62645: LD_INT 5
62647: PUSH
62648: LD_INT 6
62650: PUSH
62651: LD_INT 7
62653: PUSH
62654: LD_INT 8
62656: PUSH
62657: LD_INT 11
62659: PUSH
62660: LD_INT 12
62662: PUSH
62663: LD_INT 15
62665: PUSH
62666: LD_INT 16
62668: PUSH
62669: LD_INT 20
62671: PUSH
62672: LD_INT 21
62674: PUSH
62675: LD_INT 22
62677: PUSH
62678: LD_INT 23
62680: PUSH
62681: LD_INT 25
62683: PUSH
62684: LD_INT 26
62686: PUSH
62687: LD_INT 30
62689: PUSH
62690: LD_INT 31
62692: PUSH
62693: LD_INT 32
62695: PUSH
62696: LD_INT 36
62698: PUSH
62699: EMPTY
62700: LIST
62701: LIST
62702: LIST
62703: LIST
62704: LIST
62705: LIST
62706: LIST
62707: LIST
62708: LIST
62709: LIST
62710: LIST
62711: LIST
62712: LIST
62713: LIST
62714: LIST
62715: LIST
62716: LIST
62717: LIST
62718: LIST
62719: LIST
62720: PUSH
62721: LD_INT 101
62723: PUSH
62724: LD_INT 102
62726: PUSH
62727: LD_INT 103
62729: PUSH
62730: LD_INT 105
62732: PUSH
62733: LD_INT 106
62735: PUSH
62736: LD_INT 108
62738: PUSH
62739: LD_INT 109
62741: PUSH
62742: LD_INT 112
62744: PUSH
62745: EMPTY
62746: LIST
62747: LIST
62748: LIST
62749: LIST
62750: LIST
62751: LIST
62752: LIST
62753: LIST
62754: PUSH
62755: EMPTY
62756: LIST
62757: LIST
62758: ST_TO_ADDR
62759: GO 64882
62761: LD_INT 9
62763: DOUBLE
62764: EQUAL
62765: IFTRUE 62769
62767: GO 62905
62769: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 ] ] ; 10 :
62770: LD_ADDR_VAR 0 1
62774: PUSH
62775: LD_INT 2
62777: PUSH
62778: LD_INT 4
62780: PUSH
62781: LD_INT 5
62783: PUSH
62784: LD_INT 6
62786: PUSH
62787: LD_INT 7
62789: PUSH
62790: LD_INT 8
62792: PUSH
62793: LD_INT 11
62795: PUSH
62796: LD_INT 12
62798: PUSH
62799: LD_INT 15
62801: PUSH
62802: LD_INT 16
62804: PUSH
62805: LD_INT 20
62807: PUSH
62808: LD_INT 21
62810: PUSH
62811: LD_INT 22
62813: PUSH
62814: LD_INT 23
62816: PUSH
62817: LD_INT 25
62819: PUSH
62820: LD_INT 26
62822: PUSH
62823: LD_INT 28
62825: PUSH
62826: LD_INT 30
62828: PUSH
62829: LD_INT 31
62831: PUSH
62832: LD_INT 32
62834: PUSH
62835: LD_INT 36
62837: PUSH
62838: EMPTY
62839: LIST
62840: LIST
62841: LIST
62842: LIST
62843: LIST
62844: LIST
62845: LIST
62846: LIST
62847: LIST
62848: LIST
62849: LIST
62850: LIST
62851: LIST
62852: LIST
62853: LIST
62854: LIST
62855: LIST
62856: LIST
62857: LIST
62858: LIST
62859: LIST
62860: PUSH
62861: LD_INT 101
62863: PUSH
62864: LD_INT 102
62866: PUSH
62867: LD_INT 103
62869: PUSH
62870: LD_INT 105
62872: PUSH
62873: LD_INT 106
62875: PUSH
62876: LD_INT 108
62878: PUSH
62879: LD_INT 109
62881: PUSH
62882: LD_INT 112
62884: PUSH
62885: LD_INT 114
62887: PUSH
62888: EMPTY
62889: LIST
62890: LIST
62891: LIST
62892: LIST
62893: LIST
62894: LIST
62895: LIST
62896: LIST
62897: LIST
62898: PUSH
62899: EMPTY
62900: LIST
62901: LIST
62902: ST_TO_ADDR
62903: GO 64882
62905: LD_INT 10
62907: DOUBLE
62908: EQUAL
62909: IFTRUE 62913
62911: GO 63097
62913: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 11 :
62914: LD_ADDR_VAR 0 1
62918: PUSH
62919: LD_INT 2
62921: PUSH
62922: LD_INT 4
62924: PUSH
62925: LD_INT 5
62927: PUSH
62928: LD_INT 6
62930: PUSH
62931: LD_INT 7
62933: PUSH
62934: LD_INT 8
62936: PUSH
62937: LD_INT 9
62939: PUSH
62940: LD_INT 10
62942: PUSH
62943: LD_INT 11
62945: PUSH
62946: LD_INT 12
62948: PUSH
62949: LD_INT 13
62951: PUSH
62952: LD_INT 14
62954: PUSH
62955: LD_INT 15
62957: PUSH
62958: LD_INT 16
62960: PUSH
62961: LD_INT 17
62963: PUSH
62964: LD_INT 18
62966: PUSH
62967: LD_INT 19
62969: PUSH
62970: LD_INT 20
62972: PUSH
62973: LD_INT 21
62975: PUSH
62976: LD_INT 22
62978: PUSH
62979: LD_INT 23
62981: PUSH
62982: LD_INT 24
62984: PUSH
62985: LD_INT 25
62987: PUSH
62988: LD_INT 26
62990: PUSH
62991: LD_INT 28
62993: PUSH
62994: LD_INT 30
62996: PUSH
62997: LD_INT 31
62999: PUSH
63000: LD_INT 32
63002: PUSH
63003: LD_INT 36
63005: PUSH
63006: EMPTY
63007: LIST
63008: LIST
63009: LIST
63010: LIST
63011: LIST
63012: LIST
63013: LIST
63014: LIST
63015: LIST
63016: LIST
63017: LIST
63018: LIST
63019: LIST
63020: LIST
63021: LIST
63022: LIST
63023: LIST
63024: LIST
63025: LIST
63026: LIST
63027: LIST
63028: LIST
63029: LIST
63030: LIST
63031: LIST
63032: LIST
63033: LIST
63034: LIST
63035: LIST
63036: PUSH
63037: LD_INT 101
63039: PUSH
63040: LD_INT 102
63042: PUSH
63043: LD_INT 103
63045: PUSH
63046: LD_INT 104
63048: PUSH
63049: LD_INT 105
63051: PUSH
63052: LD_INT 106
63054: PUSH
63055: LD_INT 107
63057: PUSH
63058: LD_INT 108
63060: PUSH
63061: LD_INT 109
63063: PUSH
63064: LD_INT 110
63066: PUSH
63067: LD_INT 111
63069: PUSH
63070: LD_INT 112
63072: PUSH
63073: LD_INT 114
63075: PUSH
63076: EMPTY
63077: LIST
63078: LIST
63079: LIST
63080: LIST
63081: LIST
63082: LIST
63083: LIST
63084: LIST
63085: LIST
63086: LIST
63087: LIST
63088: LIST
63089: LIST
63090: PUSH
63091: EMPTY
63092: LIST
63093: LIST
63094: ST_TO_ADDR
63095: GO 64882
63097: LD_INT 11
63099: DOUBLE
63100: EQUAL
63101: IFTRUE 63105
63103: GO 63297
63105: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 12 :
63106: LD_ADDR_VAR 0 1
63110: PUSH
63111: LD_INT 2
63113: PUSH
63114: LD_INT 3
63116: PUSH
63117: LD_INT 4
63119: PUSH
63120: LD_INT 5
63122: PUSH
63123: LD_INT 6
63125: PUSH
63126: LD_INT 7
63128: PUSH
63129: LD_INT 8
63131: PUSH
63132: LD_INT 9
63134: PUSH
63135: LD_INT 10
63137: PUSH
63138: LD_INT 11
63140: PUSH
63141: LD_INT 12
63143: PUSH
63144: LD_INT 13
63146: PUSH
63147: LD_INT 14
63149: PUSH
63150: LD_INT 15
63152: PUSH
63153: LD_INT 16
63155: PUSH
63156: LD_INT 17
63158: PUSH
63159: LD_INT 18
63161: PUSH
63162: LD_INT 19
63164: PUSH
63165: LD_INT 20
63167: PUSH
63168: LD_INT 21
63170: PUSH
63171: LD_INT 22
63173: PUSH
63174: LD_INT 23
63176: PUSH
63177: LD_INT 24
63179: PUSH
63180: LD_INT 25
63182: PUSH
63183: LD_INT 26
63185: PUSH
63186: LD_INT 28
63188: PUSH
63189: LD_INT 30
63191: PUSH
63192: LD_INT 31
63194: PUSH
63195: LD_INT 32
63197: PUSH
63198: LD_INT 34
63200: PUSH
63201: LD_INT 36
63203: PUSH
63204: EMPTY
63205: LIST
63206: LIST
63207: LIST
63208: LIST
63209: LIST
63210: LIST
63211: LIST
63212: LIST
63213: LIST
63214: LIST
63215: LIST
63216: LIST
63217: LIST
63218: LIST
63219: LIST
63220: LIST
63221: LIST
63222: LIST
63223: LIST
63224: LIST
63225: LIST
63226: LIST
63227: LIST
63228: LIST
63229: LIST
63230: LIST
63231: LIST
63232: LIST
63233: LIST
63234: LIST
63235: LIST
63236: PUSH
63237: LD_INT 101
63239: PUSH
63240: LD_INT 102
63242: PUSH
63243: LD_INT 103
63245: PUSH
63246: LD_INT 104
63248: PUSH
63249: LD_INT 105
63251: PUSH
63252: LD_INT 106
63254: PUSH
63255: LD_INT 107
63257: PUSH
63258: LD_INT 108
63260: PUSH
63261: LD_INT 109
63263: PUSH
63264: LD_INT 110
63266: PUSH
63267: LD_INT 111
63269: PUSH
63270: LD_INT 112
63272: PUSH
63273: LD_INT 114
63275: PUSH
63276: EMPTY
63277: LIST
63278: LIST
63279: LIST
63280: LIST
63281: LIST
63282: LIST
63283: LIST
63284: LIST
63285: LIST
63286: LIST
63287: LIST
63288: LIST
63289: LIST
63290: PUSH
63291: EMPTY
63292: LIST
63293: LIST
63294: ST_TO_ADDR
63295: GO 64882
63297: LD_INT 12
63299: DOUBLE
63300: EQUAL
63301: IFTRUE 63305
63303: GO 63513
63305: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 13 :
63306: LD_ADDR_VAR 0 1
63310: PUSH
63311: LD_INT 1
63313: PUSH
63314: LD_INT 2
63316: PUSH
63317: LD_INT 3
63319: PUSH
63320: LD_INT 4
63322: PUSH
63323: LD_INT 5
63325: PUSH
63326: LD_INT 6
63328: PUSH
63329: LD_INT 7
63331: PUSH
63332: LD_INT 8
63334: PUSH
63335: LD_INT 9
63337: PUSH
63338: LD_INT 10
63340: PUSH
63341: LD_INT 11
63343: PUSH
63344: LD_INT 12
63346: PUSH
63347: LD_INT 13
63349: PUSH
63350: LD_INT 14
63352: PUSH
63353: LD_INT 15
63355: PUSH
63356: LD_INT 16
63358: PUSH
63359: LD_INT 17
63361: PUSH
63362: LD_INT 18
63364: PUSH
63365: LD_INT 19
63367: PUSH
63368: LD_INT 20
63370: PUSH
63371: LD_INT 21
63373: PUSH
63374: LD_INT 22
63376: PUSH
63377: LD_INT 23
63379: PUSH
63380: LD_INT 24
63382: PUSH
63383: LD_INT 25
63385: PUSH
63386: LD_INT 26
63388: PUSH
63389: LD_INT 27
63391: PUSH
63392: LD_INT 28
63394: PUSH
63395: LD_INT 30
63397: PUSH
63398: LD_INT 31
63400: PUSH
63401: LD_INT 32
63403: PUSH
63404: LD_INT 33
63406: PUSH
63407: LD_INT 34
63409: PUSH
63410: LD_INT 36
63412: PUSH
63413: EMPTY
63414: LIST
63415: LIST
63416: LIST
63417: LIST
63418: LIST
63419: LIST
63420: LIST
63421: LIST
63422: LIST
63423: LIST
63424: LIST
63425: LIST
63426: LIST
63427: LIST
63428: LIST
63429: LIST
63430: LIST
63431: LIST
63432: LIST
63433: LIST
63434: LIST
63435: LIST
63436: LIST
63437: LIST
63438: LIST
63439: LIST
63440: LIST
63441: LIST
63442: LIST
63443: LIST
63444: LIST
63445: LIST
63446: LIST
63447: LIST
63448: PUSH
63449: LD_INT 101
63451: PUSH
63452: LD_INT 102
63454: PUSH
63455: LD_INT 103
63457: PUSH
63458: LD_INT 104
63460: PUSH
63461: LD_INT 105
63463: PUSH
63464: LD_INT 106
63466: PUSH
63467: LD_INT 107
63469: PUSH
63470: LD_INT 108
63472: PUSH
63473: LD_INT 109
63475: PUSH
63476: LD_INT 110
63478: PUSH
63479: LD_INT 111
63481: PUSH
63482: LD_INT 112
63484: PUSH
63485: LD_INT 113
63487: PUSH
63488: LD_INT 114
63490: PUSH
63491: EMPTY
63492: LIST
63493: LIST
63494: LIST
63495: LIST
63496: LIST
63497: LIST
63498: LIST
63499: LIST
63500: LIST
63501: LIST
63502: LIST
63503: LIST
63504: LIST
63505: LIST
63506: PUSH
63507: EMPTY
63508: LIST
63509: LIST
63510: ST_TO_ADDR
63511: GO 64882
63513: LD_INT 13
63515: DOUBLE
63516: EQUAL
63517: IFTRUE 63521
63519: GO 63717
63521: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 14 :
63522: LD_ADDR_VAR 0 1
63526: PUSH
63527: LD_INT 1
63529: PUSH
63530: LD_INT 2
63532: PUSH
63533: LD_INT 3
63535: PUSH
63536: LD_INT 4
63538: PUSH
63539: LD_INT 5
63541: PUSH
63542: LD_INT 8
63544: PUSH
63545: LD_INT 9
63547: PUSH
63548: LD_INT 10
63550: PUSH
63551: LD_INT 11
63553: PUSH
63554: LD_INT 12
63556: PUSH
63557: LD_INT 14
63559: PUSH
63560: LD_INT 15
63562: PUSH
63563: LD_INT 16
63565: PUSH
63566: LD_INT 17
63568: PUSH
63569: LD_INT 18
63571: PUSH
63572: LD_INT 19
63574: PUSH
63575: LD_INT 20
63577: PUSH
63578: LD_INT 21
63580: PUSH
63581: LD_INT 22
63583: PUSH
63584: LD_INT 23
63586: PUSH
63587: LD_INT 24
63589: PUSH
63590: LD_INT 25
63592: PUSH
63593: LD_INT 26
63595: PUSH
63596: LD_INT 27
63598: PUSH
63599: LD_INT 28
63601: PUSH
63602: LD_INT 30
63604: PUSH
63605: LD_INT 31
63607: PUSH
63608: LD_INT 32
63610: PUSH
63611: LD_INT 33
63613: PUSH
63614: LD_INT 34
63616: PUSH
63617: LD_INT 36
63619: PUSH
63620: EMPTY
63621: LIST
63622: LIST
63623: LIST
63624: LIST
63625: LIST
63626: LIST
63627: LIST
63628: LIST
63629: LIST
63630: LIST
63631: LIST
63632: LIST
63633: LIST
63634: LIST
63635: LIST
63636: LIST
63637: LIST
63638: LIST
63639: LIST
63640: LIST
63641: LIST
63642: LIST
63643: LIST
63644: LIST
63645: LIST
63646: LIST
63647: LIST
63648: LIST
63649: LIST
63650: LIST
63651: LIST
63652: PUSH
63653: LD_INT 101
63655: PUSH
63656: LD_INT 102
63658: PUSH
63659: LD_INT 103
63661: PUSH
63662: LD_INT 104
63664: PUSH
63665: LD_INT 105
63667: PUSH
63668: LD_INT 106
63670: PUSH
63671: LD_INT 107
63673: PUSH
63674: LD_INT 108
63676: PUSH
63677: LD_INT 109
63679: PUSH
63680: LD_INT 110
63682: PUSH
63683: LD_INT 111
63685: PUSH
63686: LD_INT 112
63688: PUSH
63689: LD_INT 113
63691: PUSH
63692: LD_INT 114
63694: PUSH
63695: EMPTY
63696: LIST
63697: LIST
63698: LIST
63699: LIST
63700: LIST
63701: LIST
63702: LIST
63703: LIST
63704: LIST
63705: LIST
63706: LIST
63707: LIST
63708: LIST
63709: LIST
63710: PUSH
63711: EMPTY
63712: LIST
63713: LIST
63714: ST_TO_ADDR
63715: GO 64882
63717: LD_INT 14
63719: DOUBLE
63720: EQUAL
63721: IFTRUE 63725
63723: GO 63937
63725: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 15 :
63726: LD_ADDR_VAR 0 1
63730: PUSH
63731: LD_INT 1
63733: PUSH
63734: LD_INT 2
63736: PUSH
63737: LD_INT 3
63739: PUSH
63740: LD_INT 4
63742: PUSH
63743: LD_INT 5
63745: PUSH
63746: LD_INT 6
63748: PUSH
63749: LD_INT 7
63751: PUSH
63752: LD_INT 8
63754: PUSH
63755: LD_INT 9
63757: PUSH
63758: LD_INT 10
63760: PUSH
63761: LD_INT 11
63763: PUSH
63764: LD_INT 12
63766: PUSH
63767: LD_INT 13
63769: PUSH
63770: LD_INT 14
63772: PUSH
63773: LD_INT 15
63775: PUSH
63776: LD_INT 16
63778: PUSH
63779: LD_INT 17
63781: PUSH
63782: LD_INT 18
63784: PUSH
63785: LD_INT 19
63787: PUSH
63788: LD_INT 20
63790: PUSH
63791: LD_INT 21
63793: PUSH
63794: LD_INT 22
63796: PUSH
63797: LD_INT 23
63799: PUSH
63800: LD_INT 24
63802: PUSH
63803: LD_INT 25
63805: PUSH
63806: LD_INT 26
63808: PUSH
63809: LD_INT 27
63811: PUSH
63812: LD_INT 28
63814: PUSH
63815: LD_INT 29
63817: PUSH
63818: LD_INT 30
63820: PUSH
63821: LD_INT 31
63823: PUSH
63824: LD_INT 32
63826: PUSH
63827: LD_INT 33
63829: PUSH
63830: LD_INT 34
63832: PUSH
63833: LD_INT 36
63835: PUSH
63836: EMPTY
63837: LIST
63838: LIST
63839: LIST
63840: LIST
63841: LIST
63842: LIST
63843: LIST
63844: LIST
63845: LIST
63846: LIST
63847: LIST
63848: LIST
63849: LIST
63850: LIST
63851: LIST
63852: LIST
63853: LIST
63854: LIST
63855: LIST
63856: LIST
63857: LIST
63858: LIST
63859: LIST
63860: LIST
63861: LIST
63862: LIST
63863: LIST
63864: LIST
63865: LIST
63866: LIST
63867: LIST
63868: LIST
63869: LIST
63870: LIST
63871: LIST
63872: PUSH
63873: LD_INT 101
63875: PUSH
63876: LD_INT 102
63878: PUSH
63879: LD_INT 103
63881: PUSH
63882: LD_INT 104
63884: PUSH
63885: LD_INT 105
63887: PUSH
63888: LD_INT 106
63890: PUSH
63891: LD_INT 107
63893: PUSH
63894: LD_INT 108
63896: PUSH
63897: LD_INT 109
63899: PUSH
63900: LD_INT 110
63902: PUSH
63903: LD_INT 111
63905: PUSH
63906: LD_INT 112
63908: PUSH
63909: LD_INT 113
63911: PUSH
63912: LD_INT 114
63914: PUSH
63915: EMPTY
63916: LIST
63917: LIST
63918: LIST
63919: LIST
63920: LIST
63921: LIST
63922: LIST
63923: LIST
63924: LIST
63925: LIST
63926: LIST
63927: LIST
63928: LIST
63929: LIST
63930: PUSH
63931: EMPTY
63932: LIST
63933: LIST
63934: ST_TO_ADDR
63935: GO 64882
63937: LD_INT 15
63939: DOUBLE
63940: EQUAL
63941: IFTRUE 63945
63943: GO 64157
63945: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 16 :
63946: LD_ADDR_VAR 0 1
63950: PUSH
63951: LD_INT 1
63953: PUSH
63954: LD_INT 2
63956: PUSH
63957: LD_INT 3
63959: PUSH
63960: LD_INT 4
63962: PUSH
63963: LD_INT 5
63965: PUSH
63966: LD_INT 6
63968: PUSH
63969: LD_INT 7
63971: PUSH
63972: LD_INT 8
63974: PUSH
63975: LD_INT 9
63977: PUSH
63978: LD_INT 10
63980: PUSH
63981: LD_INT 11
63983: PUSH
63984: LD_INT 12
63986: PUSH
63987: LD_INT 13
63989: PUSH
63990: LD_INT 14
63992: PUSH
63993: LD_INT 15
63995: PUSH
63996: LD_INT 16
63998: PUSH
63999: LD_INT 17
64001: PUSH
64002: LD_INT 18
64004: PUSH
64005: LD_INT 19
64007: PUSH
64008: LD_INT 20
64010: PUSH
64011: LD_INT 21
64013: PUSH
64014: LD_INT 22
64016: PUSH
64017: LD_INT 23
64019: PUSH
64020: LD_INT 24
64022: PUSH
64023: LD_INT 25
64025: PUSH
64026: LD_INT 26
64028: PUSH
64029: LD_INT 27
64031: PUSH
64032: LD_INT 28
64034: PUSH
64035: LD_INT 29
64037: PUSH
64038: LD_INT 30
64040: PUSH
64041: LD_INT 31
64043: PUSH
64044: LD_INT 32
64046: PUSH
64047: LD_INT 33
64049: PUSH
64050: LD_INT 34
64052: PUSH
64053: LD_INT 36
64055: PUSH
64056: EMPTY
64057: LIST
64058: LIST
64059: LIST
64060: LIST
64061: LIST
64062: LIST
64063: LIST
64064: LIST
64065: LIST
64066: LIST
64067: LIST
64068: LIST
64069: LIST
64070: LIST
64071: LIST
64072: LIST
64073: LIST
64074: LIST
64075: LIST
64076: LIST
64077: LIST
64078: LIST
64079: LIST
64080: LIST
64081: LIST
64082: LIST
64083: LIST
64084: LIST
64085: LIST
64086: LIST
64087: LIST
64088: LIST
64089: LIST
64090: LIST
64091: LIST
64092: PUSH
64093: LD_INT 101
64095: PUSH
64096: LD_INT 102
64098: PUSH
64099: LD_INT 103
64101: PUSH
64102: LD_INT 104
64104: PUSH
64105: LD_INT 105
64107: PUSH
64108: LD_INT 106
64110: PUSH
64111: LD_INT 107
64113: PUSH
64114: LD_INT 108
64116: PUSH
64117: LD_INT 109
64119: PUSH
64120: LD_INT 110
64122: PUSH
64123: LD_INT 111
64125: PUSH
64126: LD_INT 112
64128: PUSH
64129: LD_INT 113
64131: PUSH
64132: LD_INT 114
64134: PUSH
64135: EMPTY
64136: LIST
64137: LIST
64138: LIST
64139: LIST
64140: LIST
64141: LIST
64142: LIST
64143: LIST
64144: LIST
64145: LIST
64146: LIST
64147: LIST
64148: LIST
64149: LIST
64150: PUSH
64151: EMPTY
64152: LIST
64153: LIST
64154: ST_TO_ADDR
64155: GO 64882
64157: LD_INT 16
64159: DOUBLE
64160: EQUAL
64161: IFTRUE 64165
64163: GO 64289
64165: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 ] ] ; 17 :
64166: LD_ADDR_VAR 0 1
64170: PUSH
64171: LD_INT 2
64173: PUSH
64174: LD_INT 4
64176: PUSH
64177: LD_INT 5
64179: PUSH
64180: LD_INT 7
64182: PUSH
64183: LD_INT 11
64185: PUSH
64186: LD_INT 12
64188: PUSH
64189: LD_INT 15
64191: PUSH
64192: LD_INT 16
64194: PUSH
64195: LD_INT 20
64197: PUSH
64198: LD_INT 21
64200: PUSH
64201: LD_INT 22
64203: PUSH
64204: LD_INT 23
64206: PUSH
64207: LD_INT 25
64209: PUSH
64210: LD_INT 26
64212: PUSH
64213: LD_INT 30
64215: PUSH
64216: LD_INT 31
64218: PUSH
64219: LD_INT 32
64221: PUSH
64222: LD_INT 33
64224: PUSH
64225: LD_INT 34
64227: PUSH
64228: EMPTY
64229: LIST
64230: LIST
64231: LIST
64232: LIST
64233: LIST
64234: LIST
64235: LIST
64236: LIST
64237: LIST
64238: LIST
64239: LIST
64240: LIST
64241: LIST
64242: LIST
64243: LIST
64244: LIST
64245: LIST
64246: LIST
64247: LIST
64248: PUSH
64249: LD_INT 101
64251: PUSH
64252: LD_INT 102
64254: PUSH
64255: LD_INT 103
64257: PUSH
64258: LD_INT 106
64260: PUSH
64261: LD_INT 108
64263: PUSH
64264: LD_INT 112
64266: PUSH
64267: LD_INT 113
64269: PUSH
64270: LD_INT 114
64272: PUSH
64273: EMPTY
64274: LIST
64275: LIST
64276: LIST
64277: LIST
64278: LIST
64279: LIST
64280: LIST
64281: LIST
64282: PUSH
64283: EMPTY
64284: LIST
64285: LIST
64286: ST_TO_ADDR
64287: GO 64882
64289: LD_INT 17
64291: DOUBLE
64292: EQUAL
64293: IFTRUE 64297
64295: GO 64509
64297: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 18 :
64298: LD_ADDR_VAR 0 1
64302: PUSH
64303: LD_INT 1
64305: PUSH
64306: LD_INT 2
64308: PUSH
64309: LD_INT 3
64311: PUSH
64312: LD_INT 4
64314: PUSH
64315: LD_INT 5
64317: PUSH
64318: LD_INT 6
64320: PUSH
64321: LD_INT 7
64323: PUSH
64324: LD_INT 8
64326: PUSH
64327: LD_INT 9
64329: PUSH
64330: LD_INT 10
64332: PUSH
64333: LD_INT 11
64335: PUSH
64336: LD_INT 12
64338: PUSH
64339: LD_INT 13
64341: PUSH
64342: LD_INT 14
64344: PUSH
64345: LD_INT 15
64347: PUSH
64348: LD_INT 16
64350: PUSH
64351: LD_INT 17
64353: PUSH
64354: LD_INT 18
64356: PUSH
64357: LD_INT 19
64359: PUSH
64360: LD_INT 20
64362: PUSH
64363: LD_INT 21
64365: PUSH
64366: LD_INT 22
64368: PUSH
64369: LD_INT 23
64371: PUSH
64372: LD_INT 24
64374: PUSH
64375: LD_INT 25
64377: PUSH
64378: LD_INT 26
64380: PUSH
64381: LD_INT 27
64383: PUSH
64384: LD_INT 28
64386: PUSH
64387: LD_INT 29
64389: PUSH
64390: LD_INT 30
64392: PUSH
64393: LD_INT 31
64395: PUSH
64396: LD_INT 32
64398: PUSH
64399: LD_INT 33
64401: PUSH
64402: LD_INT 34
64404: PUSH
64405: LD_INT 36
64407: PUSH
64408: EMPTY
64409: LIST
64410: LIST
64411: LIST
64412: LIST
64413: LIST
64414: LIST
64415: LIST
64416: LIST
64417: LIST
64418: LIST
64419: LIST
64420: LIST
64421: LIST
64422: LIST
64423: LIST
64424: LIST
64425: LIST
64426: LIST
64427: LIST
64428: LIST
64429: LIST
64430: LIST
64431: LIST
64432: LIST
64433: LIST
64434: LIST
64435: LIST
64436: LIST
64437: LIST
64438: LIST
64439: LIST
64440: LIST
64441: LIST
64442: LIST
64443: LIST
64444: PUSH
64445: LD_INT 101
64447: PUSH
64448: LD_INT 102
64450: PUSH
64451: LD_INT 103
64453: PUSH
64454: LD_INT 104
64456: PUSH
64457: LD_INT 105
64459: PUSH
64460: LD_INT 106
64462: PUSH
64463: LD_INT 107
64465: PUSH
64466: LD_INT 108
64468: PUSH
64469: LD_INT 109
64471: PUSH
64472: LD_INT 110
64474: PUSH
64475: LD_INT 111
64477: PUSH
64478: LD_INT 112
64480: PUSH
64481: LD_INT 113
64483: PUSH
64484: LD_INT 114
64486: PUSH
64487: EMPTY
64488: LIST
64489: LIST
64490: LIST
64491: LIST
64492: LIST
64493: LIST
64494: LIST
64495: LIST
64496: LIST
64497: LIST
64498: LIST
64499: LIST
64500: LIST
64501: LIST
64502: PUSH
64503: EMPTY
64504: LIST
64505: LIST
64506: ST_TO_ADDR
64507: GO 64882
64509: LD_INT 18
64511: DOUBLE
64512: EQUAL
64513: IFTRUE 64517
64515: GO 64653
64517: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 ] ] ; 19 :
64518: LD_ADDR_VAR 0 1
64522: PUSH
64523: LD_INT 2
64525: PUSH
64526: LD_INT 4
64528: PUSH
64529: LD_INT 5
64531: PUSH
64532: LD_INT 7
64534: PUSH
64535: LD_INT 11
64537: PUSH
64538: LD_INT 12
64540: PUSH
64541: LD_INT 15
64543: PUSH
64544: LD_INT 16
64546: PUSH
64547: LD_INT 20
64549: PUSH
64550: LD_INT 21
64552: PUSH
64553: LD_INT 22
64555: PUSH
64556: LD_INT 23
64558: PUSH
64559: LD_INT 25
64561: PUSH
64562: LD_INT 26
64564: PUSH
64565: LD_INT 30
64567: PUSH
64568: LD_INT 31
64570: PUSH
64571: LD_INT 32
64573: PUSH
64574: LD_INT 33
64576: PUSH
64577: LD_INT 34
64579: PUSH
64580: LD_INT 35
64582: PUSH
64583: LD_INT 36
64585: PUSH
64586: EMPTY
64587: LIST
64588: LIST
64589: LIST
64590: LIST
64591: LIST
64592: LIST
64593: LIST
64594: LIST
64595: LIST
64596: LIST
64597: LIST
64598: LIST
64599: LIST
64600: LIST
64601: LIST
64602: LIST
64603: LIST
64604: LIST
64605: LIST
64606: LIST
64607: LIST
64608: PUSH
64609: LD_INT 101
64611: PUSH
64612: LD_INT 102
64614: PUSH
64615: LD_INT 103
64617: PUSH
64618: LD_INT 106
64620: PUSH
64621: LD_INT 108
64623: PUSH
64624: LD_INT 112
64626: PUSH
64627: LD_INT 113
64629: PUSH
64630: LD_INT 114
64632: PUSH
64633: LD_INT 115
64635: PUSH
64636: EMPTY
64637: LIST
64638: LIST
64639: LIST
64640: LIST
64641: LIST
64642: LIST
64643: LIST
64644: LIST
64645: LIST
64646: PUSH
64647: EMPTY
64648: LIST
64649: LIST
64650: ST_TO_ADDR
64651: GO 64882
64653: LD_INT 19
64655: DOUBLE
64656: EQUAL
64657: IFTRUE 64661
64659: GO 64881
64661: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ; end ;
64662: LD_ADDR_VAR 0 1
64666: PUSH
64667: LD_INT 1
64669: PUSH
64670: LD_INT 2
64672: PUSH
64673: LD_INT 3
64675: PUSH
64676: LD_INT 4
64678: PUSH
64679: LD_INT 5
64681: PUSH
64682: LD_INT 6
64684: PUSH
64685: LD_INT 7
64687: PUSH
64688: LD_INT 8
64690: PUSH
64691: LD_INT 9
64693: PUSH
64694: LD_INT 10
64696: PUSH
64697: LD_INT 11
64699: PUSH
64700: LD_INT 12
64702: PUSH
64703: LD_INT 13
64705: PUSH
64706: LD_INT 14
64708: PUSH
64709: LD_INT 15
64711: PUSH
64712: LD_INT 16
64714: PUSH
64715: LD_INT 17
64717: PUSH
64718: LD_INT 18
64720: PUSH
64721: LD_INT 19
64723: PUSH
64724: LD_INT 20
64726: PUSH
64727: LD_INT 21
64729: PUSH
64730: LD_INT 22
64732: PUSH
64733: LD_INT 23
64735: PUSH
64736: LD_INT 24
64738: PUSH
64739: LD_INT 25
64741: PUSH
64742: LD_INT 26
64744: PUSH
64745: LD_INT 27
64747: PUSH
64748: LD_INT 28
64750: PUSH
64751: LD_INT 29
64753: PUSH
64754: LD_INT 30
64756: PUSH
64757: LD_INT 31
64759: PUSH
64760: LD_INT 32
64762: PUSH
64763: LD_INT 33
64765: PUSH
64766: LD_INT 34
64768: PUSH
64769: LD_INT 35
64771: PUSH
64772: LD_INT 36
64774: PUSH
64775: EMPTY
64776: LIST
64777: LIST
64778: LIST
64779: LIST
64780: LIST
64781: LIST
64782: LIST
64783: LIST
64784: LIST
64785: LIST
64786: LIST
64787: LIST
64788: LIST
64789: LIST
64790: LIST
64791: LIST
64792: LIST
64793: LIST
64794: LIST
64795: LIST
64796: LIST
64797: LIST
64798: LIST
64799: LIST
64800: LIST
64801: LIST
64802: LIST
64803: LIST
64804: LIST
64805: LIST
64806: LIST
64807: LIST
64808: LIST
64809: LIST
64810: LIST
64811: LIST
64812: PUSH
64813: LD_INT 101
64815: PUSH
64816: LD_INT 102
64818: PUSH
64819: LD_INT 103
64821: PUSH
64822: LD_INT 104
64824: PUSH
64825: LD_INT 105
64827: PUSH
64828: LD_INT 106
64830: PUSH
64831: LD_INT 107
64833: PUSH
64834: LD_INT 108
64836: PUSH
64837: LD_INT 109
64839: PUSH
64840: LD_INT 110
64842: PUSH
64843: LD_INT 111
64845: PUSH
64846: LD_INT 112
64848: PUSH
64849: LD_INT 113
64851: PUSH
64852: LD_INT 114
64854: PUSH
64855: LD_INT 115
64857: PUSH
64858: EMPTY
64859: LIST
64860: LIST
64861: LIST
64862: LIST
64863: LIST
64864: LIST
64865: LIST
64866: LIST
64867: LIST
64868: LIST
64869: LIST
64870: LIST
64871: LIST
64872: LIST
64873: LIST
64874: PUSH
64875: EMPTY
64876: LIST
64877: LIST
64878: ST_TO_ADDR
64879: GO 64882
64881: POP
// end else
64882: GO 65101
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ;
64884: LD_ADDR_VAR 0 1
64888: PUSH
64889: LD_INT 1
64891: PUSH
64892: LD_INT 2
64894: PUSH
64895: LD_INT 3
64897: PUSH
64898: LD_INT 4
64900: PUSH
64901: LD_INT 5
64903: PUSH
64904: LD_INT 6
64906: PUSH
64907: LD_INT 7
64909: PUSH
64910: LD_INT 8
64912: PUSH
64913: LD_INT 9
64915: PUSH
64916: LD_INT 10
64918: PUSH
64919: LD_INT 11
64921: PUSH
64922: LD_INT 12
64924: PUSH
64925: LD_INT 13
64927: PUSH
64928: LD_INT 14
64930: PUSH
64931: LD_INT 15
64933: PUSH
64934: LD_INT 16
64936: PUSH
64937: LD_INT 17
64939: PUSH
64940: LD_INT 18
64942: PUSH
64943: LD_INT 19
64945: PUSH
64946: LD_INT 20
64948: PUSH
64949: LD_INT 21
64951: PUSH
64952: LD_INT 22
64954: PUSH
64955: LD_INT 23
64957: PUSH
64958: LD_INT 24
64960: PUSH
64961: LD_INT 25
64963: PUSH
64964: LD_INT 26
64966: PUSH
64967: LD_INT 27
64969: PUSH
64970: LD_INT 28
64972: PUSH
64973: LD_INT 29
64975: PUSH
64976: LD_INT 30
64978: PUSH
64979: LD_INT 31
64981: PUSH
64982: LD_INT 32
64984: PUSH
64985: LD_INT 33
64987: PUSH
64988: LD_INT 34
64990: PUSH
64991: LD_INT 35
64993: PUSH
64994: LD_INT 36
64996: PUSH
64997: EMPTY
64998: LIST
64999: LIST
65000: LIST
65001: LIST
65002: LIST
65003: LIST
65004: LIST
65005: LIST
65006: LIST
65007: LIST
65008: LIST
65009: LIST
65010: LIST
65011: LIST
65012: LIST
65013: LIST
65014: LIST
65015: LIST
65016: LIST
65017: LIST
65018: LIST
65019: LIST
65020: LIST
65021: LIST
65022: LIST
65023: LIST
65024: LIST
65025: LIST
65026: LIST
65027: LIST
65028: LIST
65029: LIST
65030: LIST
65031: LIST
65032: LIST
65033: LIST
65034: PUSH
65035: LD_INT 101
65037: PUSH
65038: LD_INT 102
65040: PUSH
65041: LD_INT 103
65043: PUSH
65044: LD_INT 104
65046: PUSH
65047: LD_INT 105
65049: PUSH
65050: LD_INT 106
65052: PUSH
65053: LD_INT 107
65055: PUSH
65056: LD_INT 108
65058: PUSH
65059: LD_INT 109
65061: PUSH
65062: LD_INT 110
65064: PUSH
65065: LD_INT 111
65067: PUSH
65068: LD_INT 112
65070: PUSH
65071: LD_INT 113
65073: PUSH
65074: LD_INT 114
65076: PUSH
65077: LD_INT 115
65079: PUSH
65080: EMPTY
65081: LIST
65082: LIST
65083: LIST
65084: LIST
65085: LIST
65086: LIST
65087: LIST
65088: LIST
65089: LIST
65090: LIST
65091: LIST
65092: LIST
65093: LIST
65094: LIST
65095: LIST
65096: PUSH
65097: EMPTY
65098: LIST
65099: LIST
65100: ST_TO_ADDR
// if result then
65101: LD_VAR 0 1
65105: IFFALSE 65394
// begin normal :=  ;
65107: LD_ADDR_VAR 0 3
65111: PUSH
65112: LD_STRING 
65114: ST_TO_ADDR
// hardcore :=  ;
65115: LD_ADDR_VAR 0 4
65119: PUSH
65120: LD_STRING 
65122: ST_TO_ADDR
// for i = 1 to normalCounter do
65123: LD_ADDR_VAR 0 5
65127: PUSH
65128: DOUBLE
65129: LD_INT 1
65131: DEC
65132: ST_TO_ADDR
65133: LD_EXP 100
65137: PUSH
65138: FOR_TO
65139: IFFALSE 65240
// begin tmp := 0 ;
65141: LD_ADDR_VAR 0 2
65145: PUSH
65146: LD_STRING 0
65148: ST_TO_ADDR
// if result [ 1 ] then
65149: LD_VAR 0 1
65153: PUSH
65154: LD_INT 1
65156: ARRAY
65157: IFFALSE 65222
// if result [ 1 ] [ 1 ] = i then
65159: LD_VAR 0 1
65163: PUSH
65164: LD_INT 1
65166: ARRAY
65167: PUSH
65168: LD_INT 1
65170: ARRAY
65171: PUSH
65172: LD_VAR 0 5
65176: EQUAL
65177: IFFALSE 65222
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
65179: LD_ADDR_VAR 0 1
65183: PUSH
65184: LD_VAR 0 1
65188: PPUSH
65189: LD_INT 1
65191: PPUSH
65192: LD_VAR 0 1
65196: PUSH
65197: LD_INT 1
65199: ARRAY
65200: PPUSH
65201: LD_INT 1
65203: PPUSH
65204: CALL_OW 3
65208: PPUSH
65209: CALL_OW 1
65213: ST_TO_ADDR
// tmp := 1 ;
65214: LD_ADDR_VAR 0 2
65218: PUSH
65219: LD_STRING 1
65221: ST_TO_ADDR
// end ; normal := normal & tmp ;
65222: LD_ADDR_VAR 0 3
65226: PUSH
65227: LD_VAR 0 3
65231: PUSH
65232: LD_VAR 0 2
65236: STR
65237: ST_TO_ADDR
// end ;
65238: GO 65138
65240: POP
65241: POP
// for i = 1 to hardcoreCounter do
65242: LD_ADDR_VAR 0 5
65246: PUSH
65247: DOUBLE
65248: LD_INT 1
65250: DEC
65251: ST_TO_ADDR
65252: LD_EXP 101
65256: PUSH
65257: FOR_TO
65258: IFFALSE 65363
// begin tmp := 0 ;
65260: LD_ADDR_VAR 0 2
65264: PUSH
65265: LD_STRING 0
65267: ST_TO_ADDR
// if result [ 2 ] then
65268: LD_VAR 0 1
65272: PUSH
65273: LD_INT 2
65275: ARRAY
65276: IFFALSE 65345
// if result [ 2 ] [ 1 ] = 100 + i then
65278: LD_VAR 0 1
65282: PUSH
65283: LD_INT 2
65285: ARRAY
65286: PUSH
65287: LD_INT 1
65289: ARRAY
65290: PUSH
65291: LD_INT 100
65293: PUSH
65294: LD_VAR 0 5
65298: PLUS
65299: EQUAL
65300: IFFALSE 65345
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
65302: LD_ADDR_VAR 0 1
65306: PUSH
65307: LD_VAR 0 1
65311: PPUSH
65312: LD_INT 2
65314: PPUSH
65315: LD_VAR 0 1
65319: PUSH
65320: LD_INT 2
65322: ARRAY
65323: PPUSH
65324: LD_INT 1
65326: PPUSH
65327: CALL_OW 3
65331: PPUSH
65332: CALL_OW 1
65336: ST_TO_ADDR
// tmp := 1 ;
65337: LD_ADDR_VAR 0 2
65341: PUSH
65342: LD_STRING 1
65344: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
65345: LD_ADDR_VAR 0 4
65349: PUSH
65350: LD_VAR 0 4
65354: PUSH
65355: LD_VAR 0 2
65359: STR
65360: ST_TO_ADDR
// end ;
65361: GO 65257
65363: POP
65364: POP
// ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & ") ) ;
65365: LD_STRING getStreamItemsFromMission("
65367: PUSH
65368: LD_VAR 0 3
65372: STR
65373: PUSH
65374: LD_STRING ","
65376: STR
65377: PUSH
65378: LD_VAR 0 4
65382: STR
65383: PUSH
65384: LD_STRING ")
65386: STR
65387: PPUSH
65388: CALL_OW 559
// end else
65392: GO 65401
// ToLua ( getStreamItemsFromMission("","") ) ;
65394: LD_STRING getStreamItemsFromMission("","")
65396: PPUSH
65397: CALL_OW 559
// end ;
65401: LD_VAR 0 1
65405: RET
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
65406: LD_EXP 99
65410: PUSH
65411: LD_EXP 104
65415: AND
65416: IFFALSE 65540
65418: GO 65420
65420: DISABLE
65421: LD_INT 0
65423: PPUSH
65424: PPUSH
// begin enable ;
65425: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
65426: LD_ADDR_VAR 0 2
65430: PUSH
65431: LD_INT 22
65433: PUSH
65434: LD_OWVAR 2
65438: PUSH
65439: EMPTY
65440: LIST
65441: LIST
65442: PUSH
65443: LD_INT 2
65445: PUSH
65446: LD_INT 34
65448: PUSH
65449: LD_INT 7
65451: PUSH
65452: EMPTY
65453: LIST
65454: LIST
65455: PUSH
65456: LD_INT 34
65458: PUSH
65459: LD_INT 45
65461: PUSH
65462: EMPTY
65463: LIST
65464: LIST
65465: PUSH
65466: LD_INT 34
65468: PUSH
65469: LD_INT 28
65471: PUSH
65472: EMPTY
65473: LIST
65474: LIST
65475: PUSH
65476: LD_INT 34
65478: PUSH
65479: LD_INT 47
65481: PUSH
65482: EMPTY
65483: LIST
65484: LIST
65485: PUSH
65486: EMPTY
65487: LIST
65488: LIST
65489: LIST
65490: LIST
65491: LIST
65492: PUSH
65493: EMPTY
65494: LIST
65495: LIST
65496: PPUSH
65497: CALL_OW 69
65501: ST_TO_ADDR
// if not tmp then
65502: LD_VAR 0 2
65506: NOT
65507: IFFALSE 65511
// exit ;
65509: GO 65540
// for i in tmp do
65511: LD_ADDR_VAR 0 1
65515: PUSH
65516: LD_VAR 0 2
65520: PUSH
65521: FOR_IN
65522: IFFALSE 65538
// begin SetLives ( i , 0 ) ;
65524: LD_VAR 0 1
65528: PPUSH
65529: LD_INT 0
65531: PPUSH
65532: CALL_OW 234
// end ;
65536: GO 65521
65538: POP
65539: POP
// end ;
65540: PPOPN 2
65542: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
65543: LD_EXP 99
65547: PUSH
65548: LD_EXP 105
65552: AND
65553: IFFALSE 65637
65555: GO 65557
65557: DISABLE
65558: LD_INT 0
65560: PPUSH
65561: PPUSH
// begin enable ;
65562: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
65563: LD_ADDR_VAR 0 2
65567: PUSH
65568: LD_INT 22
65570: PUSH
65571: LD_OWVAR 2
65575: PUSH
65576: EMPTY
65577: LIST
65578: LIST
65579: PUSH
65580: LD_INT 32
65582: PUSH
65583: LD_INT 3
65585: PUSH
65586: EMPTY
65587: LIST
65588: LIST
65589: PUSH
65590: EMPTY
65591: LIST
65592: LIST
65593: PPUSH
65594: CALL_OW 69
65598: ST_TO_ADDR
// if not tmp then
65599: LD_VAR 0 2
65603: NOT
65604: IFFALSE 65608
// exit ;
65606: GO 65637
// for i in tmp do
65608: LD_ADDR_VAR 0 1
65612: PUSH
65613: LD_VAR 0 2
65617: PUSH
65618: FOR_IN
65619: IFFALSE 65635
// begin SetLives ( i , 0 ) ;
65621: LD_VAR 0 1
65625: PPUSH
65626: LD_INT 0
65628: PPUSH
65629: CALL_OW 234
// end ;
65633: GO 65618
65635: POP
65636: POP
// end ;
65637: PPOPN 2
65639: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
65640: LD_EXP 99
65644: PUSH
65645: LD_EXP 102
65649: AND
65650: IFFALSE 65743
65652: GO 65654
65654: DISABLE
65655: LD_INT 0
65657: PPUSH
// begin enable ;
65658: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
65659: LD_ADDR_VAR 0 1
65663: PUSH
65664: LD_INT 22
65666: PUSH
65667: LD_OWVAR 2
65671: PUSH
65672: EMPTY
65673: LIST
65674: LIST
65675: PUSH
65676: LD_INT 2
65678: PUSH
65679: LD_INT 25
65681: PUSH
65682: LD_INT 5
65684: PUSH
65685: EMPTY
65686: LIST
65687: LIST
65688: PUSH
65689: LD_INT 25
65691: PUSH
65692: LD_INT 9
65694: PUSH
65695: EMPTY
65696: LIST
65697: LIST
65698: PUSH
65699: LD_INT 25
65701: PUSH
65702: LD_INT 8
65704: PUSH
65705: EMPTY
65706: LIST
65707: LIST
65708: PUSH
65709: EMPTY
65710: LIST
65711: LIST
65712: LIST
65713: LIST
65714: PUSH
65715: EMPTY
65716: LIST
65717: LIST
65718: PPUSH
65719: CALL_OW 69
65723: PUSH
65724: FOR_IN
65725: IFFALSE 65741
// begin SetClass ( i , 1 ) ;
65727: LD_VAR 0 1
65731: PPUSH
65732: LD_INT 1
65734: PPUSH
65735: CALL_OW 336
// end ;
65739: GO 65724
65741: POP
65742: POP
// end ;
65743: PPOPN 1
65745: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
65746: LD_EXP 99
65750: PUSH
65751: LD_EXP 103
65755: AND
65756: PUSH
65757: LD_OWVAR 65
65761: PUSH
65762: LD_INT 7
65764: LESS
65765: AND
65766: IFFALSE 65780
65768: GO 65770
65770: DISABLE
// begin enable ;
65771: ENABLE
// game_speed := 7 ;
65772: LD_ADDR_OWVAR 65
65776: PUSH
65777: LD_INT 7
65779: ST_TO_ADDR
// end ;
65780: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
65781: LD_EXP 99
65785: PUSH
65786: LD_EXP 106
65790: AND
65791: IFFALSE 65993
65793: GO 65795
65795: DISABLE
65796: LD_INT 0
65798: PPUSH
65799: PPUSH
65800: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
65801: LD_ADDR_VAR 0 3
65805: PUSH
65806: LD_INT 81
65808: PUSH
65809: LD_OWVAR 2
65813: PUSH
65814: EMPTY
65815: LIST
65816: LIST
65817: PUSH
65818: LD_INT 21
65820: PUSH
65821: LD_INT 1
65823: PUSH
65824: EMPTY
65825: LIST
65826: LIST
65827: PUSH
65828: EMPTY
65829: LIST
65830: LIST
65831: PPUSH
65832: CALL_OW 69
65836: ST_TO_ADDR
// if not tmp then
65837: LD_VAR 0 3
65841: NOT
65842: IFFALSE 65846
// exit ;
65844: GO 65993
// if tmp > 5 then
65846: LD_VAR 0 3
65850: PUSH
65851: LD_INT 5
65853: GREATER
65854: IFFALSE 65866
// k := 5 else
65856: LD_ADDR_VAR 0 2
65860: PUSH
65861: LD_INT 5
65863: ST_TO_ADDR
65864: GO 65876
// k := tmp ;
65866: LD_ADDR_VAR 0 2
65870: PUSH
65871: LD_VAR 0 3
65875: ST_TO_ADDR
// for i := 1 to k do
65876: LD_ADDR_VAR 0 1
65880: PUSH
65881: DOUBLE
65882: LD_INT 1
65884: DEC
65885: ST_TO_ADDR
65886: LD_VAR 0 2
65890: PUSH
65891: FOR_TO
65892: IFFALSE 65991
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
65894: LD_VAR 0 3
65898: PUSH
65899: LD_VAR 0 1
65903: ARRAY
65904: PPUSH
65905: LD_VAR 0 1
65909: PUSH
65910: LD_INT 4
65912: MOD
65913: PUSH
65914: LD_INT 1
65916: PLUS
65917: PPUSH
65918: CALL_OW 259
65922: PUSH
65923: LD_INT 10
65925: LESS
65926: IFFALSE 65989
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
65928: LD_VAR 0 3
65932: PUSH
65933: LD_VAR 0 1
65937: ARRAY
65938: PPUSH
65939: LD_VAR 0 1
65943: PUSH
65944: LD_INT 4
65946: MOD
65947: PUSH
65948: LD_INT 1
65950: PLUS
65951: PPUSH
65952: LD_VAR 0 3
65956: PUSH
65957: LD_VAR 0 1
65961: ARRAY
65962: PPUSH
65963: LD_VAR 0 1
65967: PUSH
65968: LD_INT 4
65970: MOD
65971: PUSH
65972: LD_INT 1
65974: PLUS
65975: PPUSH
65976: CALL_OW 259
65980: PUSH
65981: LD_INT 1
65983: PLUS
65984: PPUSH
65985: CALL_OW 237
65989: GO 65891
65991: POP
65992: POP
// end ;
65993: PPOPN 3
65995: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
65996: LD_EXP 99
66000: PUSH
66001: LD_EXP 107
66005: AND
66006: IFFALSE 66026
66008: GO 66010
66010: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
66011: LD_INT 4
66013: PPUSH
66014: LD_OWVAR 2
66018: PPUSH
66019: LD_INT 0
66021: PPUSH
66022: CALL_OW 324
66026: END
// every 0 0$1 trigger StreamModeActive and sShovel do
66027: LD_EXP 99
66031: PUSH
66032: LD_EXP 136
66036: AND
66037: IFFALSE 66057
66039: GO 66041
66041: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
66042: LD_INT 19
66044: PPUSH
66045: LD_OWVAR 2
66049: PPUSH
66050: LD_INT 0
66052: PPUSH
66053: CALL_OW 324
66057: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
66058: LD_EXP 99
66062: PUSH
66063: LD_EXP 108
66067: AND
66068: IFFALSE 66170
66070: GO 66072
66072: DISABLE
66073: LD_INT 0
66075: PPUSH
66076: PPUSH
// begin enable ;
66077: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
66078: LD_ADDR_VAR 0 2
66082: PUSH
66083: LD_INT 22
66085: PUSH
66086: LD_OWVAR 2
66090: PUSH
66091: EMPTY
66092: LIST
66093: LIST
66094: PUSH
66095: LD_INT 2
66097: PUSH
66098: LD_INT 34
66100: PUSH
66101: LD_INT 11
66103: PUSH
66104: EMPTY
66105: LIST
66106: LIST
66107: PUSH
66108: LD_INT 34
66110: PUSH
66111: LD_INT 30
66113: PUSH
66114: EMPTY
66115: LIST
66116: LIST
66117: PUSH
66118: EMPTY
66119: LIST
66120: LIST
66121: LIST
66122: PUSH
66123: EMPTY
66124: LIST
66125: LIST
66126: PPUSH
66127: CALL_OW 69
66131: ST_TO_ADDR
// if not tmp then
66132: LD_VAR 0 2
66136: NOT
66137: IFFALSE 66141
// exit ;
66139: GO 66170
// for i in tmp do
66141: LD_ADDR_VAR 0 1
66145: PUSH
66146: LD_VAR 0 2
66150: PUSH
66151: FOR_IN
66152: IFFALSE 66168
// begin SetLives ( i , 0 ) ;
66154: LD_VAR 0 1
66158: PPUSH
66159: LD_INT 0
66161: PPUSH
66162: CALL_OW 234
// end ;
66166: GO 66151
66168: POP
66169: POP
// end ;
66170: PPOPN 2
66172: END
// every 0 0$1 trigger StreamModeActive and sBunker do
66173: LD_EXP 99
66177: PUSH
66178: LD_EXP 109
66182: AND
66183: IFFALSE 66203
66185: GO 66187
66187: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
66188: LD_INT 32
66190: PPUSH
66191: LD_OWVAR 2
66195: PPUSH
66196: LD_INT 0
66198: PPUSH
66199: CALL_OW 324
66203: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
66204: LD_EXP 99
66208: PUSH
66209: LD_EXP 110
66213: AND
66214: IFFALSE 66395
66216: GO 66218
66218: DISABLE
66219: LD_INT 0
66221: PPUSH
66222: PPUSH
66223: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
66224: LD_ADDR_VAR 0 2
66228: PUSH
66229: LD_INT 22
66231: PUSH
66232: LD_OWVAR 2
66236: PUSH
66237: EMPTY
66238: LIST
66239: LIST
66240: PUSH
66241: LD_INT 33
66243: PUSH
66244: LD_INT 3
66246: PUSH
66247: EMPTY
66248: LIST
66249: LIST
66250: PUSH
66251: EMPTY
66252: LIST
66253: LIST
66254: PPUSH
66255: CALL_OW 69
66259: ST_TO_ADDR
// if not tmp then
66260: LD_VAR 0 2
66264: NOT
66265: IFFALSE 66269
// exit ;
66267: GO 66395
// side := 0 ;
66269: LD_ADDR_VAR 0 3
66273: PUSH
66274: LD_INT 0
66276: ST_TO_ADDR
// for i := 1 to 8 do
66277: LD_ADDR_VAR 0 1
66281: PUSH
66282: DOUBLE
66283: LD_INT 1
66285: DEC
66286: ST_TO_ADDR
66287: LD_INT 8
66289: PUSH
66290: FOR_TO
66291: IFFALSE 66339
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
66293: LD_OWVAR 2
66297: PUSH
66298: LD_VAR 0 1
66302: NONEQUAL
66303: PUSH
66304: LD_OWVAR 2
66308: PPUSH
66309: LD_VAR 0 1
66313: PPUSH
66314: CALL_OW 81
66318: PUSH
66319: LD_INT 2
66321: EQUAL
66322: AND
66323: IFFALSE 66337
// begin side := i ;
66325: LD_ADDR_VAR 0 3
66329: PUSH
66330: LD_VAR 0 1
66334: ST_TO_ADDR
// break ;
66335: GO 66339
// end ;
66337: GO 66290
66339: POP
66340: POP
// if not side then
66341: LD_VAR 0 3
66345: NOT
66346: IFFALSE 66350
// exit ;
66348: GO 66395
// for i := 1 to tmp do
66350: LD_ADDR_VAR 0 1
66354: PUSH
66355: DOUBLE
66356: LD_INT 1
66358: DEC
66359: ST_TO_ADDR
66360: LD_VAR 0 2
66364: PUSH
66365: FOR_TO
66366: IFFALSE 66393
// if Prob ( 60 ) then
66368: LD_INT 60
66370: PPUSH
66371: CALL_OW 13
66375: IFFALSE 66391
// SetSide ( i , side ) ;
66377: LD_VAR 0 1
66381: PPUSH
66382: LD_VAR 0 3
66386: PPUSH
66387: CALL_OW 235
66391: GO 66365
66393: POP
66394: POP
// end ;
66395: PPOPN 3
66397: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
66398: LD_EXP 99
66402: PUSH
66403: LD_EXP 112
66407: AND
66408: IFFALSE 66527
66410: GO 66412
66412: DISABLE
66413: LD_INT 0
66415: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
66416: LD_ADDR_VAR 0 1
66420: PUSH
66421: LD_INT 22
66423: PUSH
66424: LD_OWVAR 2
66428: PUSH
66429: EMPTY
66430: LIST
66431: LIST
66432: PUSH
66433: LD_INT 21
66435: PUSH
66436: LD_INT 1
66438: PUSH
66439: EMPTY
66440: LIST
66441: LIST
66442: PUSH
66443: LD_INT 3
66445: PUSH
66446: LD_INT 23
66448: PUSH
66449: LD_INT 0
66451: PUSH
66452: EMPTY
66453: LIST
66454: LIST
66455: PUSH
66456: EMPTY
66457: LIST
66458: LIST
66459: PUSH
66460: EMPTY
66461: LIST
66462: LIST
66463: LIST
66464: PPUSH
66465: CALL_OW 69
66469: PUSH
66470: FOR_IN
66471: IFFALSE 66525
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
66473: LD_VAR 0 1
66477: PPUSH
66478: CALL_OW 257
66482: PUSH
66483: LD_INT 1
66485: PUSH
66486: LD_INT 2
66488: PUSH
66489: LD_INT 3
66491: PUSH
66492: LD_INT 4
66494: PUSH
66495: EMPTY
66496: LIST
66497: LIST
66498: LIST
66499: LIST
66500: IN
66501: IFFALSE 66523
// SetClass ( un , rand ( 1 , 4 ) ) ;
66503: LD_VAR 0 1
66507: PPUSH
66508: LD_INT 1
66510: PPUSH
66511: LD_INT 4
66513: PPUSH
66514: CALL_OW 12
66518: PPUSH
66519: CALL_OW 336
66523: GO 66470
66525: POP
66526: POP
// end ;
66527: PPOPN 1
66529: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
66530: LD_EXP 99
66534: PUSH
66535: LD_EXP 111
66539: AND
66540: IFFALSE 66619
66542: GO 66544
66544: DISABLE
66545: LD_INT 0
66547: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
66548: LD_ADDR_VAR 0 1
66552: PUSH
66553: LD_INT 22
66555: PUSH
66556: LD_OWVAR 2
66560: PUSH
66561: EMPTY
66562: LIST
66563: LIST
66564: PUSH
66565: LD_INT 21
66567: PUSH
66568: LD_INT 3
66570: PUSH
66571: EMPTY
66572: LIST
66573: LIST
66574: PUSH
66575: EMPTY
66576: LIST
66577: LIST
66578: PPUSH
66579: CALL_OW 69
66583: ST_TO_ADDR
// if not tmp then
66584: LD_VAR 0 1
66588: NOT
66589: IFFALSE 66593
// exit ;
66591: GO 66619
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
66593: LD_VAR 0 1
66597: PUSH
66598: LD_INT 1
66600: PPUSH
66601: LD_VAR 0 1
66605: PPUSH
66606: CALL_OW 12
66610: ARRAY
66611: PPUSH
66612: LD_INT 100
66614: PPUSH
66615: CALL_OW 234
// end ;
66619: PPOPN 1
66621: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
66622: LD_EXP 99
66626: PUSH
66627: LD_EXP 113
66631: AND
66632: IFFALSE 66730
66634: GO 66636
66636: DISABLE
66637: LD_INT 0
66639: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
66640: LD_ADDR_VAR 0 1
66644: PUSH
66645: LD_INT 22
66647: PUSH
66648: LD_OWVAR 2
66652: PUSH
66653: EMPTY
66654: LIST
66655: LIST
66656: PUSH
66657: LD_INT 21
66659: PUSH
66660: LD_INT 1
66662: PUSH
66663: EMPTY
66664: LIST
66665: LIST
66666: PUSH
66667: EMPTY
66668: LIST
66669: LIST
66670: PPUSH
66671: CALL_OW 69
66675: ST_TO_ADDR
// if not tmp then
66676: LD_VAR 0 1
66680: NOT
66681: IFFALSE 66685
// exit ;
66683: GO 66730
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
66685: LD_VAR 0 1
66689: PUSH
66690: LD_INT 1
66692: PPUSH
66693: LD_VAR 0 1
66697: PPUSH
66698: CALL_OW 12
66702: ARRAY
66703: PPUSH
66704: LD_INT 1
66706: PPUSH
66707: LD_INT 4
66709: PPUSH
66710: CALL_OW 12
66714: PPUSH
66715: LD_INT 3000
66717: PPUSH
66718: LD_INT 9000
66720: PPUSH
66721: CALL_OW 12
66725: PPUSH
66726: CALL_OW 492
// end ;
66730: PPOPN 1
66732: END
// every 0 0$1 trigger StreamModeActive and sDepot do
66733: LD_EXP 99
66737: PUSH
66738: LD_EXP 114
66742: AND
66743: IFFALSE 66763
66745: GO 66747
66747: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
66748: LD_INT 1
66750: PPUSH
66751: LD_OWVAR 2
66755: PPUSH
66756: LD_INT 0
66758: PPUSH
66759: CALL_OW 324
66763: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
66764: LD_EXP 99
66768: PUSH
66769: LD_EXP 115
66773: AND
66774: IFFALSE 66857
66776: GO 66778
66778: DISABLE
66779: LD_INT 0
66781: PPUSH
66782: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
66783: LD_ADDR_VAR 0 2
66787: PUSH
66788: LD_INT 22
66790: PUSH
66791: LD_OWVAR 2
66795: PUSH
66796: EMPTY
66797: LIST
66798: LIST
66799: PUSH
66800: LD_INT 21
66802: PUSH
66803: LD_INT 3
66805: PUSH
66806: EMPTY
66807: LIST
66808: LIST
66809: PUSH
66810: EMPTY
66811: LIST
66812: LIST
66813: PPUSH
66814: CALL_OW 69
66818: ST_TO_ADDR
// if not tmp then
66819: LD_VAR 0 2
66823: NOT
66824: IFFALSE 66828
// exit ;
66826: GO 66857
// for i in tmp do
66828: LD_ADDR_VAR 0 1
66832: PUSH
66833: LD_VAR 0 2
66837: PUSH
66838: FOR_IN
66839: IFFALSE 66855
// SetBLevel ( i , 10 ) ;
66841: LD_VAR 0 1
66845: PPUSH
66846: LD_INT 10
66848: PPUSH
66849: CALL_OW 241
66853: GO 66838
66855: POP
66856: POP
// end ;
66857: PPOPN 2
66859: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
66860: LD_EXP 99
66864: PUSH
66865: LD_EXP 116
66869: AND
66870: IFFALSE 66981
66872: GO 66874
66874: DISABLE
66875: LD_INT 0
66877: PPUSH
66878: PPUSH
66879: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
66880: LD_ADDR_VAR 0 3
66884: PUSH
66885: LD_INT 22
66887: PUSH
66888: LD_OWVAR 2
66892: PUSH
66893: EMPTY
66894: LIST
66895: LIST
66896: PUSH
66897: LD_INT 25
66899: PUSH
66900: LD_INT 1
66902: PUSH
66903: EMPTY
66904: LIST
66905: LIST
66906: PUSH
66907: EMPTY
66908: LIST
66909: LIST
66910: PPUSH
66911: CALL_OW 69
66915: ST_TO_ADDR
// if not tmp then
66916: LD_VAR 0 3
66920: NOT
66921: IFFALSE 66925
// exit ;
66923: GO 66981
// un := tmp [ rand ( 1 , tmp ) ] ;
66925: LD_ADDR_VAR 0 2
66929: PUSH
66930: LD_VAR 0 3
66934: PUSH
66935: LD_INT 1
66937: PPUSH
66938: LD_VAR 0 3
66942: PPUSH
66943: CALL_OW 12
66947: ARRAY
66948: ST_TO_ADDR
// if Crawls ( un ) then
66949: LD_VAR 0 2
66953: PPUSH
66954: CALL_OW 318
66958: IFFALSE 66969
// ComWalk ( un ) ;
66960: LD_VAR 0 2
66964: PPUSH
66965: CALL_OW 138
// SetClass ( un , class_sniper ) ;
66969: LD_VAR 0 2
66973: PPUSH
66974: LD_INT 5
66976: PPUSH
66977: CALL_OW 336
// end ;
66981: PPOPN 3
66983: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 3 do
66984: LD_EXP 99
66988: PUSH
66989: LD_EXP 117
66993: AND
66994: PUSH
66995: LD_OWVAR 67
66999: PUSH
67000: LD_INT 3
67002: LESS
67003: AND
67004: IFFALSE 67023
67006: GO 67008
67008: DISABLE
// Difficulty := Difficulty + 1 ;
67009: LD_ADDR_OWVAR 67
67013: PUSH
67014: LD_OWVAR 67
67018: PUSH
67019: LD_INT 1
67021: PLUS
67022: ST_TO_ADDR
67023: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
67024: LD_EXP 99
67028: PUSH
67029: LD_EXP 118
67033: AND
67034: IFFALSE 67137
67036: GO 67038
67038: DISABLE
67039: LD_INT 0
67041: PPUSH
// begin for i := 1 to 5 do
67042: LD_ADDR_VAR 0 1
67046: PUSH
67047: DOUBLE
67048: LD_INT 1
67050: DEC
67051: ST_TO_ADDR
67052: LD_INT 5
67054: PUSH
67055: FOR_TO
67056: IFFALSE 67135
// begin uc_nation := nation_nature ;
67058: LD_ADDR_OWVAR 21
67062: PUSH
67063: LD_INT 0
67065: ST_TO_ADDR
// uc_side := 0 ;
67066: LD_ADDR_OWVAR 20
67070: PUSH
67071: LD_INT 0
67073: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
67074: LD_ADDR_OWVAR 29
67078: PUSH
67079: LD_INT 12
67081: PUSH
67082: LD_INT 12
67084: PUSH
67085: EMPTY
67086: LIST
67087: LIST
67088: ST_TO_ADDR
// hc_agressivity := 20 ;
67089: LD_ADDR_OWVAR 35
67093: PUSH
67094: LD_INT 20
67096: ST_TO_ADDR
// hc_class := class_tiger ;
67097: LD_ADDR_OWVAR 28
67101: PUSH
67102: LD_INT 14
67104: ST_TO_ADDR
// hc_gallery :=  ;
67105: LD_ADDR_OWVAR 33
67109: PUSH
67110: LD_STRING 
67112: ST_TO_ADDR
// hc_name :=  ;
67113: LD_ADDR_OWVAR 26
67117: PUSH
67118: LD_STRING 
67120: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
67121: CALL_OW 44
67125: PPUSH
67126: LD_INT 0
67128: PPUSH
67129: CALL_OW 51
// end ;
67133: GO 67055
67135: POP
67136: POP
// end ;
67137: PPOPN 1
67139: END
// every 0 0$1 trigger StreamModeActive and sBomb do
67140: LD_EXP 99
67144: PUSH
67145: LD_EXP 119
67149: AND
67150: IFFALSE 67159
67152: GO 67154
67154: DISABLE
// StreamSibBomb ;
67155: CALL 67160 0 0
67159: END
// export function StreamSibBomb ; var i , x , y ; begin
67160: LD_INT 0
67162: PPUSH
67163: PPUSH
67164: PPUSH
67165: PPUSH
// result := false ;
67166: LD_ADDR_VAR 0 1
67170: PUSH
67171: LD_INT 0
67173: ST_TO_ADDR
// for i := 1 to 16 do
67174: LD_ADDR_VAR 0 2
67178: PUSH
67179: DOUBLE
67180: LD_INT 1
67182: DEC
67183: ST_TO_ADDR
67184: LD_INT 16
67186: PUSH
67187: FOR_TO
67188: IFFALSE 67387
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
67190: LD_ADDR_VAR 0 3
67194: PUSH
67195: LD_INT 10
67197: PUSH
67198: LD_INT 20
67200: PUSH
67201: LD_INT 30
67203: PUSH
67204: LD_INT 40
67206: PUSH
67207: LD_INT 50
67209: PUSH
67210: LD_INT 60
67212: PUSH
67213: LD_INT 70
67215: PUSH
67216: LD_INT 80
67218: PUSH
67219: LD_INT 90
67221: PUSH
67222: LD_INT 100
67224: PUSH
67225: LD_INT 110
67227: PUSH
67228: LD_INT 120
67230: PUSH
67231: LD_INT 130
67233: PUSH
67234: LD_INT 140
67236: PUSH
67237: LD_INT 150
67239: PUSH
67240: EMPTY
67241: LIST
67242: LIST
67243: LIST
67244: LIST
67245: LIST
67246: LIST
67247: LIST
67248: LIST
67249: LIST
67250: LIST
67251: LIST
67252: LIST
67253: LIST
67254: LIST
67255: LIST
67256: PUSH
67257: LD_INT 1
67259: PPUSH
67260: LD_INT 15
67262: PPUSH
67263: CALL_OW 12
67267: ARRAY
67268: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
67269: LD_ADDR_VAR 0 4
67273: PUSH
67274: LD_INT 10
67276: PUSH
67277: LD_INT 20
67279: PUSH
67280: LD_INT 30
67282: PUSH
67283: LD_INT 40
67285: PUSH
67286: LD_INT 50
67288: PUSH
67289: LD_INT 60
67291: PUSH
67292: LD_INT 70
67294: PUSH
67295: LD_INT 80
67297: PUSH
67298: LD_INT 90
67300: PUSH
67301: LD_INT 100
67303: PUSH
67304: LD_INT 110
67306: PUSH
67307: LD_INT 120
67309: PUSH
67310: LD_INT 130
67312: PUSH
67313: LD_INT 140
67315: PUSH
67316: LD_INT 150
67318: PUSH
67319: EMPTY
67320: LIST
67321: LIST
67322: LIST
67323: LIST
67324: LIST
67325: LIST
67326: LIST
67327: LIST
67328: LIST
67329: LIST
67330: LIST
67331: LIST
67332: LIST
67333: LIST
67334: LIST
67335: PUSH
67336: LD_INT 1
67338: PPUSH
67339: LD_INT 15
67341: PPUSH
67342: CALL_OW 12
67346: ARRAY
67347: ST_TO_ADDR
// if ValidHex ( x , y ) then
67348: LD_VAR 0 3
67352: PPUSH
67353: LD_VAR 0 4
67357: PPUSH
67358: CALL_OW 488
67362: IFFALSE 67385
// begin result := [ x , y ] ;
67364: LD_ADDR_VAR 0 1
67368: PUSH
67369: LD_VAR 0 3
67373: PUSH
67374: LD_VAR 0 4
67378: PUSH
67379: EMPTY
67380: LIST
67381: LIST
67382: ST_TO_ADDR
// break ;
67383: GO 67387
// end ; end ;
67385: GO 67187
67387: POP
67388: POP
// if result then
67389: LD_VAR 0 1
67393: IFFALSE 67453
// begin ToLua ( playSibBomb() ) ;
67395: LD_STRING playSibBomb()
67397: PPUSH
67398: CALL_OW 559
// wait ( 0 0$14 ) ;
67402: LD_INT 490
67404: PPUSH
67405: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
67409: LD_VAR 0 1
67413: PUSH
67414: LD_INT 1
67416: ARRAY
67417: PPUSH
67418: LD_VAR 0 1
67422: PUSH
67423: LD_INT 2
67425: ARRAY
67426: PPUSH
67427: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
67431: LD_VAR 0 1
67435: PUSH
67436: LD_INT 1
67438: ARRAY
67439: PPUSH
67440: LD_VAR 0 1
67444: PUSH
67445: LD_INT 2
67447: ARRAY
67448: PPUSH
67449: CALL_OW 429
// end ; end ;
67453: LD_VAR 0 1
67457: RET
// every 0 0$1 trigger StreamModeActive and sReset do
67458: LD_EXP 99
67462: PUSH
67463: LD_EXP 121
67467: AND
67468: IFFALSE 67480
67470: GO 67472
67472: DISABLE
// YouLost (  ) ;
67473: LD_STRING 
67475: PPUSH
67476: CALL_OW 104
67480: END
// every 0 0$1 trigger StreamModeActive and sFog do
67481: LD_EXP 99
67485: PUSH
67486: LD_EXP 120
67490: AND
67491: IFFALSE 67505
67493: GO 67495
67495: DISABLE
// FogOff ( your_side ) ;
67496: LD_OWVAR 2
67500: PPUSH
67501: CALL_OW 344
67505: END
// every 0 0$1 trigger StreamModeActive and sSun do
67506: LD_EXP 99
67510: PUSH
67511: LD_EXP 122
67515: AND
67516: IFFALSE 67544
67518: GO 67520
67520: DISABLE
// begin solar_recharge_percent := 0 ;
67521: LD_ADDR_OWVAR 79
67525: PUSH
67526: LD_INT 0
67528: ST_TO_ADDR
// wait ( 5 5$00 ) ;
67529: LD_INT 10500
67531: PPUSH
67532: CALL_OW 67
// solar_recharge_percent := 100 ;
67536: LD_ADDR_OWVAR 79
67540: PUSH
67541: LD_INT 100
67543: ST_TO_ADDR
// end ;
67544: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
67545: LD_EXP 99
67549: PUSH
67550: LD_EXP 123
67554: AND
67555: IFFALSE 67794
67557: GO 67559
67559: DISABLE
67560: LD_INT 0
67562: PPUSH
67563: PPUSH
67564: PPUSH
// begin tmp := [ ] ;
67565: LD_ADDR_VAR 0 3
67569: PUSH
67570: EMPTY
67571: ST_TO_ADDR
// for i := 1 to 6 do
67572: LD_ADDR_VAR 0 1
67576: PUSH
67577: DOUBLE
67578: LD_INT 1
67580: DEC
67581: ST_TO_ADDR
67582: LD_INT 6
67584: PUSH
67585: FOR_TO
67586: IFFALSE 67691
// begin uc_nation := nation_nature ;
67588: LD_ADDR_OWVAR 21
67592: PUSH
67593: LD_INT 0
67595: ST_TO_ADDR
// uc_side := 0 ;
67596: LD_ADDR_OWVAR 20
67600: PUSH
67601: LD_INT 0
67603: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
67604: LD_ADDR_OWVAR 29
67608: PUSH
67609: LD_INT 12
67611: PUSH
67612: LD_INT 12
67614: PUSH
67615: EMPTY
67616: LIST
67617: LIST
67618: ST_TO_ADDR
// hc_agressivity := 20 ;
67619: LD_ADDR_OWVAR 35
67623: PUSH
67624: LD_INT 20
67626: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
67627: LD_ADDR_OWVAR 28
67631: PUSH
67632: LD_INT 17
67634: ST_TO_ADDR
// hc_gallery :=  ;
67635: LD_ADDR_OWVAR 33
67639: PUSH
67640: LD_STRING 
67642: ST_TO_ADDR
// hc_name :=  ;
67643: LD_ADDR_OWVAR 26
67647: PUSH
67648: LD_STRING 
67650: ST_TO_ADDR
// un := CreateHuman ;
67651: LD_ADDR_VAR 0 2
67655: PUSH
67656: CALL_OW 44
67660: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
67661: LD_VAR 0 2
67665: PPUSH
67666: LD_INT 1
67668: PPUSH
67669: CALL_OW 51
// tmp := tmp ^ un ;
67673: LD_ADDR_VAR 0 3
67677: PUSH
67678: LD_VAR 0 3
67682: PUSH
67683: LD_VAR 0 2
67687: ADD
67688: ST_TO_ADDR
// end ;
67689: GO 67585
67691: POP
67692: POP
// repeat wait ( 0 0$1 ) ;
67693: LD_INT 35
67695: PPUSH
67696: CALL_OW 67
// for un in tmp do
67700: LD_ADDR_VAR 0 2
67704: PUSH
67705: LD_VAR 0 3
67709: PUSH
67710: FOR_IN
67711: IFFALSE 67785
// begin if IsDead ( un ) then
67713: LD_VAR 0 2
67717: PPUSH
67718: CALL_OW 301
67722: IFFALSE 67742
// begin tmp := tmp diff un ;
67724: LD_ADDR_VAR 0 3
67728: PUSH
67729: LD_VAR 0 3
67733: PUSH
67734: LD_VAR 0 2
67738: DIFF
67739: ST_TO_ADDR
// continue ;
67740: GO 67710
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
67742: LD_VAR 0 2
67746: PPUSH
67747: LD_INT 3
67749: PUSH
67750: LD_INT 22
67752: PUSH
67753: LD_INT 0
67755: PUSH
67756: EMPTY
67757: LIST
67758: LIST
67759: PUSH
67760: EMPTY
67761: LIST
67762: LIST
67763: PPUSH
67764: CALL_OW 69
67768: PPUSH
67769: LD_VAR 0 2
67773: PPUSH
67774: CALL_OW 74
67778: PPUSH
67779: CALL_OW 115
// end ;
67783: GO 67710
67785: POP
67786: POP
// until not tmp ;
67787: LD_VAR 0 3
67791: NOT
67792: IFFALSE 67693
// end ;
67794: PPOPN 3
67796: END
// every 0 0$1 trigger StreamModeActive and sTroll do
67797: LD_EXP 99
67801: PUSH
67802: LD_EXP 124
67806: AND
67807: IFFALSE 67861
67809: GO 67811
67811: DISABLE
// begin ToLua ( displayTroll(); ) ;
67812: LD_STRING displayTroll();
67814: PPUSH
67815: CALL_OW 559
// wait ( 3 3$00 ) ;
67819: LD_INT 6300
67821: PPUSH
67822: CALL_OW 67
// ToLua ( hideTroll(); ) ;
67826: LD_STRING hideTroll();
67828: PPUSH
67829: CALL_OW 559
// wait ( 1 1$00 ) ;
67833: LD_INT 2100
67835: PPUSH
67836: CALL_OW 67
// ToLua ( displayTroll(); ) ;
67840: LD_STRING displayTroll();
67842: PPUSH
67843: CALL_OW 559
// wait ( 1 1$00 ) ;
67847: LD_INT 2100
67849: PPUSH
67850: CALL_OW 67
// ToLua ( hideTroll(); ) ;
67854: LD_STRING hideTroll();
67856: PPUSH
67857: CALL_OW 559
// end ;
67861: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
67862: LD_EXP 99
67866: PUSH
67867: LD_EXP 125
67871: AND
67872: IFFALSE 67935
67874: GO 67876
67876: DISABLE
67877: LD_INT 0
67879: PPUSH
// begin p := 0 ;
67880: LD_ADDR_VAR 0 1
67884: PUSH
67885: LD_INT 0
67887: ST_TO_ADDR
// repeat game_speed := 1 ;
67888: LD_ADDR_OWVAR 65
67892: PUSH
67893: LD_INT 1
67895: ST_TO_ADDR
// wait ( 0 0$1 ) ;
67896: LD_INT 35
67898: PPUSH
67899: CALL_OW 67
// p := p + 1 ;
67903: LD_ADDR_VAR 0 1
67907: PUSH
67908: LD_VAR 0 1
67912: PUSH
67913: LD_INT 1
67915: PLUS
67916: ST_TO_ADDR
// until p >= 60 ;
67917: LD_VAR 0 1
67921: PUSH
67922: LD_INT 60
67924: GREATEREQUAL
67925: IFFALSE 67888
// game_speed := 4 ;
67927: LD_ADDR_OWVAR 65
67931: PUSH
67932: LD_INT 4
67934: ST_TO_ADDR
// end ;
67935: PPOPN 1
67937: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
67938: LD_EXP 99
67942: PUSH
67943: LD_EXP 126
67947: AND
67948: IFFALSE 68094
67950: GO 67952
67952: DISABLE
67953: LD_INT 0
67955: PPUSH
67956: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
67957: LD_ADDR_VAR 0 1
67961: PUSH
67962: LD_INT 22
67964: PUSH
67965: LD_OWVAR 2
67969: PUSH
67970: EMPTY
67971: LIST
67972: LIST
67973: PUSH
67974: LD_INT 2
67976: PUSH
67977: LD_INT 30
67979: PUSH
67980: LD_INT 0
67982: PUSH
67983: EMPTY
67984: LIST
67985: LIST
67986: PUSH
67987: LD_INT 30
67989: PUSH
67990: LD_INT 1
67992: PUSH
67993: EMPTY
67994: LIST
67995: LIST
67996: PUSH
67997: EMPTY
67998: LIST
67999: LIST
68000: LIST
68001: PUSH
68002: EMPTY
68003: LIST
68004: LIST
68005: PPUSH
68006: CALL_OW 69
68010: ST_TO_ADDR
// if not depot then
68011: LD_VAR 0 1
68015: NOT
68016: IFFALSE 68020
// exit ;
68018: GO 68094
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
68020: LD_ADDR_VAR 0 2
68024: PUSH
68025: LD_VAR 0 1
68029: PUSH
68030: LD_INT 1
68032: PPUSH
68033: LD_VAR 0 1
68037: PPUSH
68038: CALL_OW 12
68042: ARRAY
68043: PPUSH
68044: CALL_OW 274
68048: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
68049: LD_VAR 0 2
68053: PPUSH
68054: LD_INT 1
68056: PPUSH
68057: LD_INT 0
68059: PPUSH
68060: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
68064: LD_VAR 0 2
68068: PPUSH
68069: LD_INT 2
68071: PPUSH
68072: LD_INT 0
68074: PPUSH
68075: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
68079: LD_VAR 0 2
68083: PPUSH
68084: LD_INT 3
68086: PPUSH
68087: LD_INT 0
68089: PPUSH
68090: CALL_OW 277
// end ;
68094: PPOPN 2
68096: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
68097: LD_EXP 99
68101: PUSH
68102: LD_EXP 127
68106: AND
68107: IFFALSE 68204
68109: GO 68111
68111: DISABLE
68112: LD_INT 0
68114: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
68115: LD_ADDR_VAR 0 1
68119: PUSH
68120: LD_INT 22
68122: PUSH
68123: LD_OWVAR 2
68127: PUSH
68128: EMPTY
68129: LIST
68130: LIST
68131: PUSH
68132: LD_INT 21
68134: PUSH
68135: LD_INT 1
68137: PUSH
68138: EMPTY
68139: LIST
68140: LIST
68141: PUSH
68142: LD_INT 3
68144: PUSH
68145: LD_INT 23
68147: PUSH
68148: LD_INT 0
68150: PUSH
68151: EMPTY
68152: LIST
68153: LIST
68154: PUSH
68155: EMPTY
68156: LIST
68157: LIST
68158: PUSH
68159: EMPTY
68160: LIST
68161: LIST
68162: LIST
68163: PPUSH
68164: CALL_OW 69
68168: ST_TO_ADDR
// if not tmp then
68169: LD_VAR 0 1
68173: NOT
68174: IFFALSE 68178
// exit ;
68176: GO 68204
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
68178: LD_VAR 0 1
68182: PUSH
68183: LD_INT 1
68185: PPUSH
68186: LD_VAR 0 1
68190: PPUSH
68191: CALL_OW 12
68195: ARRAY
68196: PPUSH
68197: LD_INT 200
68199: PPUSH
68200: CALL_OW 234
// end ;
68204: PPOPN 1
68206: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
68207: LD_EXP 99
68211: PUSH
68212: LD_EXP 128
68216: AND
68217: IFFALSE 68296
68219: GO 68221
68221: DISABLE
68222: LD_INT 0
68224: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
68225: LD_ADDR_VAR 0 1
68229: PUSH
68230: LD_INT 22
68232: PUSH
68233: LD_OWVAR 2
68237: PUSH
68238: EMPTY
68239: LIST
68240: LIST
68241: PUSH
68242: LD_INT 21
68244: PUSH
68245: LD_INT 2
68247: PUSH
68248: EMPTY
68249: LIST
68250: LIST
68251: PUSH
68252: EMPTY
68253: LIST
68254: LIST
68255: PPUSH
68256: CALL_OW 69
68260: ST_TO_ADDR
// if not tmp then
68261: LD_VAR 0 1
68265: NOT
68266: IFFALSE 68270
// exit ;
68268: GO 68296
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
68270: LD_VAR 0 1
68274: PUSH
68275: LD_INT 1
68277: PPUSH
68278: LD_VAR 0 1
68282: PPUSH
68283: CALL_OW 12
68287: ARRAY
68288: PPUSH
68289: LD_INT 60
68291: PPUSH
68292: CALL_OW 234
// end ;
68296: PPOPN 1
68298: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
68299: LD_EXP 99
68303: PUSH
68304: LD_EXP 129
68308: AND
68309: IFFALSE 68408
68311: GO 68313
68313: DISABLE
68314: LD_INT 0
68316: PPUSH
68317: PPUSH
// begin enable ;
68318: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
68319: LD_ADDR_VAR 0 1
68323: PUSH
68324: LD_INT 22
68326: PUSH
68327: LD_OWVAR 2
68331: PUSH
68332: EMPTY
68333: LIST
68334: LIST
68335: PUSH
68336: LD_INT 61
68338: PUSH
68339: EMPTY
68340: LIST
68341: PUSH
68342: LD_INT 33
68344: PUSH
68345: LD_INT 2
68347: PUSH
68348: EMPTY
68349: LIST
68350: LIST
68351: PUSH
68352: EMPTY
68353: LIST
68354: LIST
68355: LIST
68356: PPUSH
68357: CALL_OW 69
68361: ST_TO_ADDR
// if not tmp then
68362: LD_VAR 0 1
68366: NOT
68367: IFFALSE 68371
// exit ;
68369: GO 68408
// for i in tmp do
68371: LD_ADDR_VAR 0 2
68375: PUSH
68376: LD_VAR 0 1
68380: PUSH
68381: FOR_IN
68382: IFFALSE 68406
// if IsControledBy ( i ) then
68384: LD_VAR 0 2
68388: PPUSH
68389: CALL_OW 312
68393: IFFALSE 68404
// ComUnlink ( i ) ;
68395: LD_VAR 0 2
68399: PPUSH
68400: CALL_OW 136
68404: GO 68381
68406: POP
68407: POP
// end ;
68408: PPOPN 2
68410: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
68411: LD_EXP 99
68415: PUSH
68416: LD_EXP 130
68420: AND
68421: IFFALSE 68561
68423: GO 68425
68425: DISABLE
68426: LD_INT 0
68428: PPUSH
68429: PPUSH
// begin ToLua ( displayPowell(); ) ;
68430: LD_STRING displayPowell();
68432: PPUSH
68433: CALL_OW 559
// uc_side := 0 ;
68437: LD_ADDR_OWVAR 20
68441: PUSH
68442: LD_INT 0
68444: ST_TO_ADDR
// uc_nation := 2 ;
68445: LD_ADDR_OWVAR 21
68449: PUSH
68450: LD_INT 2
68452: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
68453: LD_ADDR_OWVAR 37
68457: PUSH
68458: LD_INT 14
68460: ST_TO_ADDR
// vc_engine := engine_siberite ;
68461: LD_ADDR_OWVAR 39
68465: PUSH
68466: LD_INT 3
68468: ST_TO_ADDR
// vc_control := control_apeman ;
68469: LD_ADDR_OWVAR 38
68473: PUSH
68474: LD_INT 5
68476: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
68477: LD_ADDR_OWVAR 40
68481: PUSH
68482: LD_INT 29
68484: ST_TO_ADDR
// un := CreateVehicle ;
68485: LD_ADDR_VAR 0 2
68489: PUSH
68490: CALL_OW 45
68494: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
68495: LD_VAR 0 2
68499: PPUSH
68500: LD_INT 1
68502: PPUSH
68503: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
68507: LD_INT 35
68509: PPUSH
68510: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
68514: LD_VAR 0 2
68518: PPUSH
68519: LD_INT 22
68521: PUSH
68522: LD_OWVAR 2
68526: PUSH
68527: EMPTY
68528: LIST
68529: LIST
68530: PPUSH
68531: CALL_OW 69
68535: PPUSH
68536: LD_VAR 0 2
68540: PPUSH
68541: CALL_OW 74
68545: PPUSH
68546: CALL_OW 115
// until IsDead ( un ) ;
68550: LD_VAR 0 2
68554: PPUSH
68555: CALL_OW 301
68559: IFFALSE 68507
// end ;
68561: PPOPN 2
68563: END
// every 0 0$1 trigger StreamModeActive and sStu do
68564: LD_EXP 99
68568: PUSH
68569: LD_EXP 138
68573: AND
68574: IFFALSE 68590
68576: GO 68578
68578: DISABLE
// begin ToLua ( displayStucuk(); ) ;
68579: LD_STRING displayStucuk();
68581: PPUSH
68582: CALL_OW 559
// ResetFog ;
68586: CALL_OW 335
// end ;
68590: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
68591: LD_EXP 99
68595: PUSH
68596: LD_EXP 131
68600: AND
68601: IFFALSE 68742
68603: GO 68605
68605: DISABLE
68606: LD_INT 0
68608: PPUSH
68609: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
68610: LD_ADDR_VAR 0 2
68614: PUSH
68615: LD_INT 22
68617: PUSH
68618: LD_OWVAR 2
68622: PUSH
68623: EMPTY
68624: LIST
68625: LIST
68626: PUSH
68627: LD_INT 21
68629: PUSH
68630: LD_INT 1
68632: PUSH
68633: EMPTY
68634: LIST
68635: LIST
68636: PUSH
68637: EMPTY
68638: LIST
68639: LIST
68640: PPUSH
68641: CALL_OW 69
68645: ST_TO_ADDR
// if not tmp then
68646: LD_VAR 0 2
68650: NOT
68651: IFFALSE 68655
// exit ;
68653: GO 68742
// un := tmp [ rand ( 1 , tmp ) ] ;
68655: LD_ADDR_VAR 0 1
68659: PUSH
68660: LD_VAR 0 2
68664: PUSH
68665: LD_INT 1
68667: PPUSH
68668: LD_VAR 0 2
68672: PPUSH
68673: CALL_OW 12
68677: ARRAY
68678: ST_TO_ADDR
// SetSide ( un , 0 ) ;
68679: LD_VAR 0 1
68683: PPUSH
68684: LD_INT 0
68686: PPUSH
68687: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
68691: LD_VAR 0 1
68695: PPUSH
68696: LD_OWVAR 3
68700: PUSH
68701: LD_VAR 0 1
68705: DIFF
68706: PPUSH
68707: LD_VAR 0 1
68711: PPUSH
68712: CALL_OW 74
68716: PPUSH
68717: CALL_OW 115
// wait ( 0 0$20 ) ;
68721: LD_INT 700
68723: PPUSH
68724: CALL_OW 67
// SetSide ( un , your_side ) ;
68728: LD_VAR 0 1
68732: PPUSH
68733: LD_OWVAR 2
68737: PPUSH
68738: CALL_OW 235
// end ;
68742: PPOPN 2
68744: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
68745: LD_EXP 99
68749: PUSH
68750: LD_EXP 132
68754: AND
68755: IFFALSE 68861
68757: GO 68759
68759: DISABLE
68760: LD_INT 0
68762: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
68763: LD_ADDR_VAR 0 1
68767: PUSH
68768: LD_INT 22
68770: PUSH
68771: LD_OWVAR 2
68775: PUSH
68776: EMPTY
68777: LIST
68778: LIST
68779: PUSH
68780: LD_INT 2
68782: PUSH
68783: LD_INT 30
68785: PUSH
68786: LD_INT 0
68788: PUSH
68789: EMPTY
68790: LIST
68791: LIST
68792: PUSH
68793: LD_INT 30
68795: PUSH
68796: LD_INT 1
68798: PUSH
68799: EMPTY
68800: LIST
68801: LIST
68802: PUSH
68803: EMPTY
68804: LIST
68805: LIST
68806: LIST
68807: PUSH
68808: EMPTY
68809: LIST
68810: LIST
68811: PPUSH
68812: CALL_OW 69
68816: ST_TO_ADDR
// if not depot then
68817: LD_VAR 0 1
68821: NOT
68822: IFFALSE 68826
// exit ;
68824: GO 68861
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
68826: LD_VAR 0 1
68830: PUSH
68831: LD_INT 1
68833: ARRAY
68834: PPUSH
68835: CALL_OW 250
68839: PPUSH
68840: LD_VAR 0 1
68844: PUSH
68845: LD_INT 1
68847: ARRAY
68848: PPUSH
68849: CALL_OW 251
68853: PPUSH
68854: LD_INT 70
68856: PPUSH
68857: CALL_OW 495
// end ;
68861: PPOPN 1
68863: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
68864: LD_EXP 99
68868: PUSH
68869: LD_EXP 133
68873: AND
68874: IFFALSE 69085
68876: GO 68878
68878: DISABLE
68879: LD_INT 0
68881: PPUSH
68882: PPUSH
68883: PPUSH
68884: PPUSH
68885: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
68886: LD_ADDR_VAR 0 5
68890: PUSH
68891: LD_INT 22
68893: PUSH
68894: LD_OWVAR 2
68898: PUSH
68899: EMPTY
68900: LIST
68901: LIST
68902: PUSH
68903: LD_INT 21
68905: PUSH
68906: LD_INT 1
68908: PUSH
68909: EMPTY
68910: LIST
68911: LIST
68912: PUSH
68913: EMPTY
68914: LIST
68915: LIST
68916: PPUSH
68917: CALL_OW 69
68921: ST_TO_ADDR
// if not tmp then
68922: LD_VAR 0 5
68926: NOT
68927: IFFALSE 68931
// exit ;
68929: GO 69085
// for i in tmp do
68931: LD_ADDR_VAR 0 1
68935: PUSH
68936: LD_VAR 0 5
68940: PUSH
68941: FOR_IN
68942: IFFALSE 69083
// begin d := rand ( 0 , 5 ) ;
68944: LD_ADDR_VAR 0 4
68948: PUSH
68949: LD_INT 0
68951: PPUSH
68952: LD_INT 5
68954: PPUSH
68955: CALL_OW 12
68959: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
68960: LD_ADDR_VAR 0 2
68964: PUSH
68965: LD_VAR 0 1
68969: PPUSH
68970: CALL_OW 250
68974: PPUSH
68975: LD_VAR 0 4
68979: PPUSH
68980: LD_INT 3
68982: PPUSH
68983: LD_INT 12
68985: PPUSH
68986: CALL_OW 12
68990: PPUSH
68991: CALL_OW 272
68995: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
68996: LD_ADDR_VAR 0 3
69000: PUSH
69001: LD_VAR 0 1
69005: PPUSH
69006: CALL_OW 251
69010: PPUSH
69011: LD_VAR 0 4
69015: PPUSH
69016: LD_INT 3
69018: PPUSH
69019: LD_INT 12
69021: PPUSH
69022: CALL_OW 12
69026: PPUSH
69027: CALL_OW 273
69031: ST_TO_ADDR
// if ValidHex ( x , y ) then
69032: LD_VAR 0 2
69036: PPUSH
69037: LD_VAR 0 3
69041: PPUSH
69042: CALL_OW 488
69046: IFFALSE 69081
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
69048: LD_VAR 0 1
69052: PPUSH
69053: LD_VAR 0 2
69057: PPUSH
69058: LD_VAR 0 3
69062: PPUSH
69063: LD_INT 3
69065: PPUSH
69066: LD_INT 6
69068: PPUSH
69069: CALL_OW 12
69073: PPUSH
69074: LD_INT 1
69076: PPUSH
69077: CALL_OW 483
// end ;
69081: GO 68941
69083: POP
69084: POP
// end ;
69085: PPOPN 5
69087: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
69088: LD_EXP 99
69092: PUSH
69093: LD_EXP 134
69097: AND
69098: IFFALSE 69192
69100: GO 69102
69102: DISABLE
69103: LD_INT 0
69105: PPUSH
69106: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
69107: LD_ADDR_VAR 0 2
69111: PUSH
69112: LD_INT 22
69114: PUSH
69115: LD_OWVAR 2
69119: PUSH
69120: EMPTY
69121: LIST
69122: LIST
69123: PUSH
69124: LD_INT 32
69126: PUSH
69127: LD_INT 1
69129: PUSH
69130: EMPTY
69131: LIST
69132: LIST
69133: PUSH
69134: LD_INT 21
69136: PUSH
69137: LD_INT 2
69139: PUSH
69140: EMPTY
69141: LIST
69142: LIST
69143: PUSH
69144: EMPTY
69145: LIST
69146: LIST
69147: LIST
69148: PPUSH
69149: CALL_OW 69
69153: ST_TO_ADDR
// if not tmp then
69154: LD_VAR 0 2
69158: NOT
69159: IFFALSE 69163
// exit ;
69161: GO 69192
// for i in tmp do
69163: LD_ADDR_VAR 0 1
69167: PUSH
69168: LD_VAR 0 2
69172: PUSH
69173: FOR_IN
69174: IFFALSE 69190
// SetFuel ( i , 0 ) ;
69176: LD_VAR 0 1
69180: PPUSH
69181: LD_INT 0
69183: PPUSH
69184: CALL_OW 240
69188: GO 69173
69190: POP
69191: POP
// end ;
69192: PPOPN 2
69194: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
69195: LD_EXP 99
69199: PUSH
69200: LD_EXP 135
69204: AND
69205: IFFALSE 69271
69207: GO 69209
69209: DISABLE
69210: LD_INT 0
69212: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
69213: LD_ADDR_VAR 0 1
69217: PUSH
69218: LD_INT 22
69220: PUSH
69221: LD_OWVAR 2
69225: PUSH
69226: EMPTY
69227: LIST
69228: LIST
69229: PUSH
69230: LD_INT 30
69232: PUSH
69233: LD_INT 29
69235: PUSH
69236: EMPTY
69237: LIST
69238: LIST
69239: PUSH
69240: EMPTY
69241: LIST
69242: LIST
69243: PPUSH
69244: CALL_OW 69
69248: ST_TO_ADDR
// if not tmp then
69249: LD_VAR 0 1
69253: NOT
69254: IFFALSE 69258
// exit ;
69256: GO 69271
// DestroyUnit ( tmp [ 1 ] ) ;
69258: LD_VAR 0 1
69262: PUSH
69263: LD_INT 1
69265: ARRAY
69266: PPUSH
69267: CALL_OW 65
// end ;
69271: PPOPN 1
69273: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
69274: LD_EXP 99
69278: PUSH
69279: LD_EXP 137
69283: AND
69284: IFFALSE 69413
69286: GO 69288
69288: DISABLE
69289: LD_INT 0
69291: PPUSH
// begin uc_side := 0 ;
69292: LD_ADDR_OWVAR 20
69296: PUSH
69297: LD_INT 0
69299: ST_TO_ADDR
// uc_nation := nation_arabian ;
69300: LD_ADDR_OWVAR 21
69304: PUSH
69305: LD_INT 2
69307: ST_TO_ADDR
// hc_gallery :=  ;
69308: LD_ADDR_OWVAR 33
69312: PUSH
69313: LD_STRING 
69315: ST_TO_ADDR
// hc_name :=  ;
69316: LD_ADDR_OWVAR 26
69320: PUSH
69321: LD_STRING 
69323: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
69324: LD_INT 1
69326: PPUSH
69327: LD_INT 11
69329: PPUSH
69330: LD_INT 10
69332: PPUSH
69333: CALL_OW 380
// un := CreateHuman ;
69337: LD_ADDR_VAR 0 1
69341: PUSH
69342: CALL_OW 44
69346: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
69347: LD_VAR 0 1
69351: PPUSH
69352: LD_INT 1
69354: PPUSH
69355: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
69359: LD_INT 35
69361: PPUSH
69362: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
69366: LD_VAR 0 1
69370: PPUSH
69371: LD_INT 22
69373: PUSH
69374: LD_OWVAR 2
69378: PUSH
69379: EMPTY
69380: LIST
69381: LIST
69382: PPUSH
69383: CALL_OW 69
69387: PPUSH
69388: LD_VAR 0 1
69392: PPUSH
69393: CALL_OW 74
69397: PPUSH
69398: CALL_OW 115
// until IsDead ( un ) ;
69402: LD_VAR 0 1
69406: PPUSH
69407: CALL_OW 301
69411: IFFALSE 69359
// end ;
69413: PPOPN 1
69415: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
69416: LD_EXP 99
69420: PUSH
69421: LD_EXP 139
69425: AND
69426: IFFALSE 69438
69428: GO 69430
69430: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
69431: LD_STRING earthquake(getX(game), 0, 32)
69433: PPUSH
69434: CALL_OW 559
69438: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
69439: LD_EXP 99
69443: PUSH
69444: LD_EXP 140
69448: AND
69449: IFFALSE 69540
69451: GO 69453
69453: DISABLE
69454: LD_INT 0
69456: PPUSH
// begin enable ;
69457: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
69458: LD_ADDR_VAR 0 1
69462: PUSH
69463: LD_INT 22
69465: PUSH
69466: LD_OWVAR 2
69470: PUSH
69471: EMPTY
69472: LIST
69473: LIST
69474: PUSH
69475: LD_INT 21
69477: PUSH
69478: LD_INT 2
69480: PUSH
69481: EMPTY
69482: LIST
69483: LIST
69484: PUSH
69485: LD_INT 33
69487: PUSH
69488: LD_INT 3
69490: PUSH
69491: EMPTY
69492: LIST
69493: LIST
69494: PUSH
69495: EMPTY
69496: LIST
69497: LIST
69498: LIST
69499: PPUSH
69500: CALL_OW 69
69504: ST_TO_ADDR
// if not tmp then
69505: LD_VAR 0 1
69509: NOT
69510: IFFALSE 69514
// exit ;
69512: GO 69540
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
69514: LD_VAR 0 1
69518: PUSH
69519: LD_INT 1
69521: PPUSH
69522: LD_VAR 0 1
69526: PPUSH
69527: CALL_OW 12
69531: ARRAY
69532: PPUSH
69533: LD_INT 1
69535: PPUSH
69536: CALL_OW 234
// end ;
69540: PPOPN 1
69542: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
69543: LD_EXP 99
69547: PUSH
69548: LD_EXP 141
69552: AND
69553: IFFALSE 69694
69555: GO 69557
69557: DISABLE
69558: LD_INT 0
69560: PPUSH
69561: PPUSH
69562: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
69563: LD_ADDR_VAR 0 3
69567: PUSH
69568: LD_INT 22
69570: PUSH
69571: LD_OWVAR 2
69575: PUSH
69576: EMPTY
69577: LIST
69578: LIST
69579: PUSH
69580: LD_INT 25
69582: PUSH
69583: LD_INT 1
69585: PUSH
69586: EMPTY
69587: LIST
69588: LIST
69589: PUSH
69590: EMPTY
69591: LIST
69592: LIST
69593: PPUSH
69594: CALL_OW 69
69598: ST_TO_ADDR
// if not tmp then
69599: LD_VAR 0 3
69603: NOT
69604: IFFALSE 69608
// exit ;
69606: GO 69694
// un := tmp [ rand ( 1 , tmp ) ] ;
69608: LD_ADDR_VAR 0 2
69612: PUSH
69613: LD_VAR 0 3
69617: PUSH
69618: LD_INT 1
69620: PPUSH
69621: LD_VAR 0 3
69625: PPUSH
69626: CALL_OW 12
69630: ARRAY
69631: ST_TO_ADDR
// if Crawls ( un ) then
69632: LD_VAR 0 2
69636: PPUSH
69637: CALL_OW 318
69641: IFFALSE 69652
// ComWalk ( un ) ;
69643: LD_VAR 0 2
69647: PPUSH
69648: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
69652: LD_VAR 0 2
69656: PPUSH
69657: LD_INT 9
69659: PPUSH
69660: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
69664: LD_INT 28
69666: PPUSH
69667: LD_OWVAR 2
69671: PPUSH
69672: LD_INT 2
69674: PPUSH
69675: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
69679: LD_INT 29
69681: PPUSH
69682: LD_OWVAR 2
69686: PPUSH
69687: LD_INT 2
69689: PPUSH
69690: CALL_OW 322
// end ;
69694: PPOPN 3
69696: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
69697: LD_EXP 99
69701: PUSH
69702: LD_EXP 142
69706: AND
69707: IFFALSE 69818
69709: GO 69711
69711: DISABLE
69712: LD_INT 0
69714: PPUSH
69715: PPUSH
69716: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
69717: LD_ADDR_VAR 0 3
69721: PUSH
69722: LD_INT 22
69724: PUSH
69725: LD_OWVAR 2
69729: PUSH
69730: EMPTY
69731: LIST
69732: LIST
69733: PUSH
69734: LD_INT 25
69736: PUSH
69737: LD_INT 1
69739: PUSH
69740: EMPTY
69741: LIST
69742: LIST
69743: PUSH
69744: EMPTY
69745: LIST
69746: LIST
69747: PPUSH
69748: CALL_OW 69
69752: ST_TO_ADDR
// if not tmp then
69753: LD_VAR 0 3
69757: NOT
69758: IFFALSE 69762
// exit ;
69760: GO 69818
// un := tmp [ rand ( 1 , tmp ) ] ;
69762: LD_ADDR_VAR 0 2
69766: PUSH
69767: LD_VAR 0 3
69771: PUSH
69772: LD_INT 1
69774: PPUSH
69775: LD_VAR 0 3
69779: PPUSH
69780: CALL_OW 12
69784: ARRAY
69785: ST_TO_ADDR
// if Crawls ( un ) then
69786: LD_VAR 0 2
69790: PPUSH
69791: CALL_OW 318
69795: IFFALSE 69806
// ComWalk ( un ) ;
69797: LD_VAR 0 2
69801: PPUSH
69802: CALL_OW 138
// SetClass ( un , class_mortar ) ;
69806: LD_VAR 0 2
69810: PPUSH
69811: LD_INT 8
69813: PPUSH
69814: CALL_OW 336
// end ;
69818: PPOPN 3
69820: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
69821: LD_EXP 99
69825: PUSH
69826: LD_EXP 143
69830: AND
69831: IFFALSE 69975
69833: GO 69835
69835: DISABLE
69836: LD_INT 0
69838: PPUSH
69839: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
69840: LD_ADDR_VAR 0 2
69844: PUSH
69845: LD_INT 22
69847: PUSH
69848: LD_OWVAR 2
69852: PUSH
69853: EMPTY
69854: LIST
69855: LIST
69856: PUSH
69857: LD_INT 21
69859: PUSH
69860: LD_INT 2
69862: PUSH
69863: EMPTY
69864: LIST
69865: LIST
69866: PUSH
69867: LD_INT 2
69869: PUSH
69870: LD_INT 34
69872: PUSH
69873: LD_INT 12
69875: PUSH
69876: EMPTY
69877: LIST
69878: LIST
69879: PUSH
69880: LD_INT 34
69882: PUSH
69883: LD_INT 51
69885: PUSH
69886: EMPTY
69887: LIST
69888: LIST
69889: PUSH
69890: LD_INT 34
69892: PUSH
69893: LD_INT 32
69895: PUSH
69896: EMPTY
69897: LIST
69898: LIST
69899: PUSH
69900: EMPTY
69901: LIST
69902: LIST
69903: LIST
69904: LIST
69905: PUSH
69906: EMPTY
69907: LIST
69908: LIST
69909: LIST
69910: PPUSH
69911: CALL_OW 69
69915: ST_TO_ADDR
// if not tmp then
69916: LD_VAR 0 2
69920: NOT
69921: IFFALSE 69925
// exit ;
69923: GO 69975
// for i in tmp do
69925: LD_ADDR_VAR 0 1
69929: PUSH
69930: LD_VAR 0 2
69934: PUSH
69935: FOR_IN
69936: IFFALSE 69973
// if GetCargo ( i , mat_artifact ) = 0 then
69938: LD_VAR 0 1
69942: PPUSH
69943: LD_INT 4
69945: PPUSH
69946: CALL_OW 289
69950: PUSH
69951: LD_INT 0
69953: EQUAL
69954: IFFALSE 69971
// SetCargo ( i , mat_siberit , 100 ) ;
69956: LD_VAR 0 1
69960: PPUSH
69961: LD_INT 3
69963: PPUSH
69964: LD_INT 100
69966: PPUSH
69967: CALL_OW 290
69971: GO 69935
69973: POP
69974: POP
// end ;
69975: PPOPN 2
69977: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
69978: LD_EXP 99
69982: PUSH
69983: LD_EXP 144
69987: AND
69988: IFFALSE 70171
69990: GO 69992
69992: DISABLE
69993: LD_INT 0
69995: PPUSH
69996: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
69997: LD_ADDR_VAR 0 2
70001: PUSH
70002: LD_INT 22
70004: PUSH
70005: LD_OWVAR 2
70009: PUSH
70010: EMPTY
70011: LIST
70012: LIST
70013: PPUSH
70014: CALL_OW 69
70018: ST_TO_ADDR
// if not tmp then
70019: LD_VAR 0 2
70023: NOT
70024: IFFALSE 70028
// exit ;
70026: GO 70171
// for i := 1 to 2 do
70028: LD_ADDR_VAR 0 1
70032: PUSH
70033: DOUBLE
70034: LD_INT 1
70036: DEC
70037: ST_TO_ADDR
70038: LD_INT 2
70040: PUSH
70041: FOR_TO
70042: IFFALSE 70169
// begin uc_side := your_side ;
70044: LD_ADDR_OWVAR 20
70048: PUSH
70049: LD_OWVAR 2
70053: ST_TO_ADDR
// uc_nation := nation_american ;
70054: LD_ADDR_OWVAR 21
70058: PUSH
70059: LD_INT 1
70061: ST_TO_ADDR
// vc_chassis := us_morphling ;
70062: LD_ADDR_OWVAR 37
70066: PUSH
70067: LD_INT 5
70069: ST_TO_ADDR
// vc_engine := engine_siberite ;
70070: LD_ADDR_OWVAR 39
70074: PUSH
70075: LD_INT 3
70077: ST_TO_ADDR
// vc_control := control_computer ;
70078: LD_ADDR_OWVAR 38
70082: PUSH
70083: LD_INT 3
70085: ST_TO_ADDR
// vc_weapon := us_double_laser ;
70086: LD_ADDR_OWVAR 40
70090: PUSH
70091: LD_INT 10
70093: ST_TO_ADDR
// if not IsInUnit ( tmp [ 1 ] ) then
70094: LD_VAR 0 2
70098: PUSH
70099: LD_INT 1
70101: ARRAY
70102: PPUSH
70103: CALL_OW 310
70107: NOT
70108: IFFALSE 70155
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) else
70110: CALL_OW 45
70114: PPUSH
70115: LD_VAR 0 2
70119: PUSH
70120: LD_INT 1
70122: ARRAY
70123: PPUSH
70124: CALL_OW 250
70128: PPUSH
70129: LD_VAR 0 2
70133: PUSH
70134: LD_INT 1
70136: ARRAY
70137: PPUSH
70138: CALL_OW 251
70142: PPUSH
70143: LD_INT 12
70145: PPUSH
70146: LD_INT 1
70148: PPUSH
70149: CALL_OW 50
70153: GO 70167
// PlaceUnitAnywhere ( CreateVehicle , true ) ;
70155: CALL_OW 45
70159: PPUSH
70160: LD_INT 1
70162: PPUSH
70163: CALL_OW 51
// end ;
70167: GO 70041
70169: POP
70170: POP
// end ;
70171: PPOPN 2
70173: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
70174: LD_EXP 99
70178: PUSH
70179: LD_EXP 145
70183: AND
70184: IFFALSE 70406
70186: GO 70188
70188: DISABLE
70189: LD_INT 0
70191: PPUSH
70192: PPUSH
70193: PPUSH
70194: PPUSH
70195: PPUSH
70196: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
70197: LD_ADDR_VAR 0 6
70201: PUSH
70202: LD_INT 22
70204: PUSH
70205: LD_OWVAR 2
70209: PUSH
70210: EMPTY
70211: LIST
70212: LIST
70213: PUSH
70214: LD_INT 21
70216: PUSH
70217: LD_INT 1
70219: PUSH
70220: EMPTY
70221: LIST
70222: LIST
70223: PUSH
70224: LD_INT 3
70226: PUSH
70227: LD_INT 23
70229: PUSH
70230: LD_INT 0
70232: PUSH
70233: EMPTY
70234: LIST
70235: LIST
70236: PUSH
70237: EMPTY
70238: LIST
70239: LIST
70240: PUSH
70241: EMPTY
70242: LIST
70243: LIST
70244: LIST
70245: PPUSH
70246: CALL_OW 69
70250: ST_TO_ADDR
// if not tmp then
70251: LD_VAR 0 6
70255: NOT
70256: IFFALSE 70260
// exit ;
70258: GO 70406
// s1 := rand ( 1 , 4 ) ;
70260: LD_ADDR_VAR 0 2
70264: PUSH
70265: LD_INT 1
70267: PPUSH
70268: LD_INT 4
70270: PPUSH
70271: CALL_OW 12
70275: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
70276: LD_ADDR_VAR 0 4
70280: PUSH
70281: LD_VAR 0 6
70285: PUSH
70286: LD_INT 1
70288: ARRAY
70289: PPUSH
70290: LD_VAR 0 2
70294: PPUSH
70295: CALL_OW 259
70299: ST_TO_ADDR
// if s1 = 1 then
70300: LD_VAR 0 2
70304: PUSH
70305: LD_INT 1
70307: EQUAL
70308: IFFALSE 70328
// s2 := rand ( 2 , 4 ) else
70310: LD_ADDR_VAR 0 3
70314: PUSH
70315: LD_INT 2
70317: PPUSH
70318: LD_INT 4
70320: PPUSH
70321: CALL_OW 12
70325: ST_TO_ADDR
70326: GO 70336
// s2 := 1 ;
70328: LD_ADDR_VAR 0 3
70332: PUSH
70333: LD_INT 1
70335: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
70336: LD_ADDR_VAR 0 5
70340: PUSH
70341: LD_VAR 0 6
70345: PUSH
70346: LD_INT 1
70348: ARRAY
70349: PPUSH
70350: LD_VAR 0 3
70354: PPUSH
70355: CALL_OW 259
70359: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
70360: LD_VAR 0 6
70364: PUSH
70365: LD_INT 1
70367: ARRAY
70368: PPUSH
70369: LD_VAR 0 2
70373: PPUSH
70374: LD_VAR 0 5
70378: PPUSH
70379: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
70383: LD_VAR 0 6
70387: PUSH
70388: LD_INT 1
70390: ARRAY
70391: PPUSH
70392: LD_VAR 0 3
70396: PPUSH
70397: LD_VAR 0 4
70401: PPUSH
70402: CALL_OW 237
// end ;
70406: PPOPN 6
70408: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
70409: LD_EXP 99
70413: PUSH
70414: LD_EXP 146
70418: AND
70419: IFFALSE 70498
70421: GO 70423
70423: DISABLE
70424: LD_INT 0
70426: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
70427: LD_ADDR_VAR 0 1
70431: PUSH
70432: LD_INT 22
70434: PUSH
70435: LD_OWVAR 2
70439: PUSH
70440: EMPTY
70441: LIST
70442: LIST
70443: PUSH
70444: LD_INT 30
70446: PUSH
70447: LD_INT 3
70449: PUSH
70450: EMPTY
70451: LIST
70452: LIST
70453: PUSH
70454: EMPTY
70455: LIST
70456: LIST
70457: PPUSH
70458: CALL_OW 69
70462: ST_TO_ADDR
// if not tmp then
70463: LD_VAR 0 1
70467: NOT
70468: IFFALSE 70472
// exit ;
70470: GO 70498
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
70472: LD_VAR 0 1
70476: PUSH
70477: LD_INT 1
70479: PPUSH
70480: LD_VAR 0 1
70484: PPUSH
70485: CALL_OW 12
70489: ARRAY
70490: PPUSH
70491: LD_INT 1
70493: PPUSH
70494: CALL_OW 234
// end ;
70498: PPOPN 1
70500: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
70501: LD_EXP 99
70505: PUSH
70506: LD_EXP 147
70510: AND
70511: IFFALSE 70623
70513: GO 70515
70515: DISABLE
70516: LD_INT 0
70518: PPUSH
70519: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
70520: LD_ADDR_VAR 0 2
70524: PUSH
70525: LD_INT 22
70527: PUSH
70528: LD_OWVAR 2
70532: PUSH
70533: EMPTY
70534: LIST
70535: LIST
70536: PUSH
70537: LD_INT 2
70539: PUSH
70540: LD_INT 30
70542: PUSH
70543: LD_INT 27
70545: PUSH
70546: EMPTY
70547: LIST
70548: LIST
70549: PUSH
70550: LD_INT 30
70552: PUSH
70553: LD_INT 26
70555: PUSH
70556: EMPTY
70557: LIST
70558: LIST
70559: PUSH
70560: LD_INT 30
70562: PUSH
70563: LD_INT 28
70565: PUSH
70566: EMPTY
70567: LIST
70568: LIST
70569: PUSH
70570: EMPTY
70571: LIST
70572: LIST
70573: LIST
70574: LIST
70575: PUSH
70576: EMPTY
70577: LIST
70578: LIST
70579: PPUSH
70580: CALL_OW 69
70584: ST_TO_ADDR
// if not tmp then
70585: LD_VAR 0 2
70589: NOT
70590: IFFALSE 70594
// exit ;
70592: GO 70623
// for i in tmp do
70594: LD_ADDR_VAR 0 1
70598: PUSH
70599: LD_VAR 0 2
70603: PUSH
70604: FOR_IN
70605: IFFALSE 70621
// SetLives ( i , 1 ) ;
70607: LD_VAR 0 1
70611: PPUSH
70612: LD_INT 1
70614: PPUSH
70615: CALL_OW 234
70619: GO 70604
70621: POP
70622: POP
// end ;
70623: PPOPN 2
70625: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
70626: LD_EXP 99
70630: PUSH
70631: LD_EXP 148
70635: AND
70636: IFFALSE 70910
70638: GO 70640
70640: DISABLE
70641: LD_INT 0
70643: PPUSH
70644: PPUSH
70645: PPUSH
// begin i := rand ( 1 , 7 ) ;
70646: LD_ADDR_VAR 0 1
70650: PUSH
70651: LD_INT 1
70653: PPUSH
70654: LD_INT 7
70656: PPUSH
70657: CALL_OW 12
70661: ST_TO_ADDR
// case i of 1 :
70662: LD_VAR 0 1
70666: PUSH
70667: LD_INT 1
70669: DOUBLE
70670: EQUAL
70671: IFTRUE 70675
70673: GO 70685
70675: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
70676: LD_STRING earthquake(getX(game), 0, 32)
70678: PPUSH
70679: CALL_OW 559
70683: GO 70910
70685: LD_INT 2
70687: DOUBLE
70688: EQUAL
70689: IFTRUE 70693
70691: GO 70707
70693: POP
// begin ToLua ( displayStucuk(); ) ;
70694: LD_STRING displayStucuk();
70696: PPUSH
70697: CALL_OW 559
// ResetFog ;
70701: CALL_OW 335
// end ; 3 :
70705: GO 70910
70707: LD_INT 3
70709: DOUBLE
70710: EQUAL
70711: IFTRUE 70715
70713: GO 70819
70715: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
70716: LD_ADDR_VAR 0 2
70720: PUSH
70721: LD_INT 22
70723: PUSH
70724: LD_OWVAR 2
70728: PUSH
70729: EMPTY
70730: LIST
70731: LIST
70732: PUSH
70733: LD_INT 25
70735: PUSH
70736: LD_INT 1
70738: PUSH
70739: EMPTY
70740: LIST
70741: LIST
70742: PUSH
70743: EMPTY
70744: LIST
70745: LIST
70746: PPUSH
70747: CALL_OW 69
70751: ST_TO_ADDR
// if not tmp then
70752: LD_VAR 0 2
70756: NOT
70757: IFFALSE 70761
// exit ;
70759: GO 70910
// un := tmp [ rand ( 1 , tmp ) ] ;
70761: LD_ADDR_VAR 0 3
70765: PUSH
70766: LD_VAR 0 2
70770: PUSH
70771: LD_INT 1
70773: PPUSH
70774: LD_VAR 0 2
70778: PPUSH
70779: CALL_OW 12
70783: ARRAY
70784: ST_TO_ADDR
// if Crawls ( un ) then
70785: LD_VAR 0 3
70789: PPUSH
70790: CALL_OW 318
70794: IFFALSE 70805
// ComWalk ( un ) ;
70796: LD_VAR 0 3
70800: PPUSH
70801: CALL_OW 138
// SetClass ( un , class_mortar ) ;
70805: LD_VAR 0 3
70809: PPUSH
70810: LD_INT 8
70812: PPUSH
70813: CALL_OW 336
// end ; 4 :
70817: GO 70910
70819: LD_INT 4
70821: DOUBLE
70822: EQUAL
70823: IFTRUE 70827
70825: GO 70888
70827: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
70828: LD_ADDR_VAR 0 2
70832: PUSH
70833: LD_INT 22
70835: PUSH
70836: LD_OWVAR 2
70840: PUSH
70841: EMPTY
70842: LIST
70843: LIST
70844: PUSH
70845: LD_INT 30
70847: PUSH
70848: LD_INT 29
70850: PUSH
70851: EMPTY
70852: LIST
70853: LIST
70854: PUSH
70855: EMPTY
70856: LIST
70857: LIST
70858: PPUSH
70859: CALL_OW 69
70863: ST_TO_ADDR
// if not tmp then
70864: LD_VAR 0 2
70868: NOT
70869: IFFALSE 70873
// exit ;
70871: GO 70910
// DestroyUnit ( tmp [ 1 ] ) ;
70873: LD_VAR 0 2
70877: PUSH
70878: LD_INT 1
70880: ARRAY
70881: PPUSH
70882: CALL_OW 65
// end ; 5 .. 7 :
70886: GO 70910
70888: LD_INT 5
70890: DOUBLE
70891: GREATEREQUAL
70892: IFFALSE 70900
70894: LD_INT 7
70896: DOUBLE
70897: LESSEQUAL
70898: IFTRUE 70902
70900: GO 70909
70902: POP
// StreamSibBomb ; end ;
70903: CALL 67160 0 0
70907: GO 70910
70909: POP
// end ;
70910: PPOPN 3
70912: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
70913: LD_EXP 99
70917: PUSH
70918: LD_EXP 149
70922: AND
70923: IFFALSE 71079
70925: GO 70927
70927: DISABLE
70928: LD_INT 0
70930: PPUSH
70931: PPUSH
70932: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
70933: LD_ADDR_VAR 0 2
70937: PUSH
70938: LD_INT 81
70940: PUSH
70941: LD_OWVAR 2
70945: PUSH
70946: EMPTY
70947: LIST
70948: LIST
70949: PUSH
70950: LD_INT 2
70952: PUSH
70953: LD_INT 21
70955: PUSH
70956: LD_INT 1
70958: PUSH
70959: EMPTY
70960: LIST
70961: LIST
70962: PUSH
70963: LD_INT 21
70965: PUSH
70966: LD_INT 2
70968: PUSH
70969: EMPTY
70970: LIST
70971: LIST
70972: PUSH
70973: EMPTY
70974: LIST
70975: LIST
70976: LIST
70977: PUSH
70978: EMPTY
70979: LIST
70980: LIST
70981: PPUSH
70982: CALL_OW 69
70986: ST_TO_ADDR
// if not tmp then
70987: LD_VAR 0 2
70991: NOT
70992: IFFALSE 70996
// exit ;
70994: GO 71079
// p := 0 ;
70996: LD_ADDR_VAR 0 3
71000: PUSH
71001: LD_INT 0
71003: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
71004: LD_INT 35
71006: PPUSH
71007: CALL_OW 67
// p := p + 1 ;
71011: LD_ADDR_VAR 0 3
71015: PUSH
71016: LD_VAR 0 3
71020: PUSH
71021: LD_INT 1
71023: PLUS
71024: ST_TO_ADDR
// for i in tmp do
71025: LD_ADDR_VAR 0 1
71029: PUSH
71030: LD_VAR 0 2
71034: PUSH
71035: FOR_IN
71036: IFFALSE 71067
// if GetLives ( i ) < 1000 then
71038: LD_VAR 0 1
71042: PPUSH
71043: CALL_OW 256
71047: PUSH
71048: LD_INT 1000
71050: LESS
71051: IFFALSE 71065
// SetLives ( i , 1000 ) ;
71053: LD_VAR 0 1
71057: PPUSH
71058: LD_INT 1000
71060: PPUSH
71061: CALL_OW 234
71065: GO 71035
71067: POP
71068: POP
// until p > 20 ;
71069: LD_VAR 0 3
71073: PUSH
71074: LD_INT 20
71076: GREATER
71077: IFFALSE 71004
// end ;
71079: PPOPN 3
71081: END
// every 0 0$1 trigger StreamModeActive and sTime do
71082: LD_EXP 99
71086: PUSH
71087: LD_EXP 150
71091: AND
71092: IFFALSE 71127
71094: GO 71096
71096: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
71097: LD_INT 28
71099: PPUSH
71100: LD_OWVAR 2
71104: PPUSH
71105: LD_INT 2
71107: PPUSH
71108: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
71112: LD_INT 30
71114: PPUSH
71115: LD_OWVAR 2
71119: PPUSH
71120: LD_INT 2
71122: PPUSH
71123: CALL_OW 322
// end ;
71127: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
71128: LD_EXP 99
71132: PUSH
71133: LD_EXP 151
71137: AND
71138: IFFALSE 71259
71140: GO 71142
71142: DISABLE
71143: LD_INT 0
71145: PPUSH
71146: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
71147: LD_ADDR_VAR 0 2
71151: PUSH
71152: LD_INT 22
71154: PUSH
71155: LD_OWVAR 2
71159: PUSH
71160: EMPTY
71161: LIST
71162: LIST
71163: PUSH
71164: LD_INT 21
71166: PUSH
71167: LD_INT 1
71169: PUSH
71170: EMPTY
71171: LIST
71172: LIST
71173: PUSH
71174: LD_INT 3
71176: PUSH
71177: LD_INT 23
71179: PUSH
71180: LD_INT 0
71182: PUSH
71183: EMPTY
71184: LIST
71185: LIST
71186: PUSH
71187: EMPTY
71188: LIST
71189: LIST
71190: PUSH
71191: EMPTY
71192: LIST
71193: LIST
71194: LIST
71195: PPUSH
71196: CALL_OW 69
71200: ST_TO_ADDR
// if not tmp then
71201: LD_VAR 0 2
71205: NOT
71206: IFFALSE 71210
// exit ;
71208: GO 71259
// for i in tmp do
71210: LD_ADDR_VAR 0 1
71214: PUSH
71215: LD_VAR 0 2
71219: PUSH
71220: FOR_IN
71221: IFFALSE 71257
// begin if Crawls ( i ) then
71223: LD_VAR 0 1
71227: PPUSH
71228: CALL_OW 318
71232: IFFALSE 71243
// ComWalk ( i ) ;
71234: LD_VAR 0 1
71238: PPUSH
71239: CALL_OW 138
// SetClass ( i , 2 ) ;
71243: LD_VAR 0 1
71247: PPUSH
71248: LD_INT 2
71250: PPUSH
71251: CALL_OW 336
// end ;
71255: GO 71220
71257: POP
71258: POP
// end ;
71259: PPOPN 2
71261: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
71262: LD_EXP 99
71266: PUSH
71267: LD_EXP 152
71271: AND
71272: IFFALSE 71553
71274: GO 71276
71276: DISABLE
71277: LD_INT 0
71279: PPUSH
71280: PPUSH
71281: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
71282: LD_OWVAR 2
71286: PPUSH
71287: LD_INT 9
71289: PPUSH
71290: LD_INT 1
71292: PPUSH
71293: LD_INT 1
71295: PPUSH
71296: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
71300: LD_INT 9
71302: PPUSH
71303: LD_OWVAR 2
71307: PPUSH
71308: CALL_OW 343
// uc_side := 9 ;
71312: LD_ADDR_OWVAR 20
71316: PUSH
71317: LD_INT 9
71319: ST_TO_ADDR
// uc_nation := 2 ;
71320: LD_ADDR_OWVAR 21
71324: PUSH
71325: LD_INT 2
71327: ST_TO_ADDR
// hc_name := Dark Warrior ;
71328: LD_ADDR_OWVAR 26
71332: PUSH
71333: LD_STRING Dark Warrior
71335: ST_TO_ADDR
// hc_gallery :=  ;
71336: LD_ADDR_OWVAR 33
71340: PUSH
71341: LD_STRING 
71343: ST_TO_ADDR
// hc_noskilllimit := true ;
71344: LD_ADDR_OWVAR 76
71348: PUSH
71349: LD_INT 1
71351: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
71352: LD_ADDR_OWVAR 31
71356: PUSH
71357: LD_INT 30
71359: PUSH
71360: LD_INT 30
71362: PUSH
71363: LD_INT 30
71365: PUSH
71366: LD_INT 30
71368: PUSH
71369: EMPTY
71370: LIST
71371: LIST
71372: LIST
71373: LIST
71374: ST_TO_ADDR
// un := CreateHuman ;
71375: LD_ADDR_VAR 0 3
71379: PUSH
71380: CALL_OW 44
71384: ST_TO_ADDR
// hc_noskilllimit := false ;
71385: LD_ADDR_OWVAR 76
71389: PUSH
71390: LD_INT 0
71392: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
71393: LD_VAR 0 3
71397: PPUSH
71398: LD_INT 1
71400: PPUSH
71401: CALL_OW 51
// p := 0 ;
71405: LD_ADDR_VAR 0 2
71409: PUSH
71410: LD_INT 0
71412: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
71413: LD_INT 35
71415: PPUSH
71416: CALL_OW 67
// p := p + 1 ;
71420: LD_ADDR_VAR 0 2
71424: PUSH
71425: LD_VAR 0 2
71429: PUSH
71430: LD_INT 1
71432: PLUS
71433: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
71434: LD_VAR 0 3
71438: PPUSH
71439: CALL_OW 256
71443: PUSH
71444: LD_INT 1000
71446: LESS
71447: IFFALSE 71461
// SetLives ( un , 1000 ) ;
71449: LD_VAR 0 3
71453: PPUSH
71454: LD_INT 1000
71456: PPUSH
71457: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
71461: LD_VAR 0 3
71465: PPUSH
71466: LD_INT 81
71468: PUSH
71469: LD_OWVAR 2
71473: PUSH
71474: EMPTY
71475: LIST
71476: LIST
71477: PUSH
71478: LD_INT 91
71480: PUSH
71481: LD_VAR 0 3
71485: PUSH
71486: LD_INT 30
71488: PUSH
71489: EMPTY
71490: LIST
71491: LIST
71492: LIST
71493: PUSH
71494: EMPTY
71495: LIST
71496: LIST
71497: PPUSH
71498: CALL_OW 69
71502: PPUSH
71503: LD_VAR 0 3
71507: PPUSH
71508: CALL_OW 74
71512: PPUSH
71513: CALL_OW 115
// until p > 60 or IsDead ( un ) ;
71517: LD_VAR 0 2
71521: PUSH
71522: LD_INT 60
71524: GREATER
71525: PUSH
71526: LD_VAR 0 3
71530: PPUSH
71531: CALL_OW 301
71535: OR
71536: IFFALSE 71413
// if un then
71538: LD_VAR 0 3
71542: IFFALSE 71553
// RemoveUnit ( un ) ;
71544: LD_VAR 0 3
71548: PPUSH
71549: CALL_OW 64
// end ;
71553: PPOPN 3
71555: END
// export function SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
71556: LD_INT 0
71558: PPUSH
// case cmd of 301 :
71559: LD_VAR 0 1
71563: PUSH
71564: LD_INT 301
71566: DOUBLE
71567: EQUAL
71568: IFTRUE 71572
71570: GO 71604
71572: POP
// hHackSpawnHuman ( p1 , p2 , p3 , x , y ) ; 302 :
71573: LD_VAR 0 6
71577: PPUSH
71578: LD_VAR 0 7
71582: PPUSH
71583: LD_VAR 0 8
71587: PPUSH
71588: LD_VAR 0 4
71592: PPUSH
71593: LD_VAR 0 5
71597: PPUSH
71598: CALL 72805 0 5
71602: GO 71725
71604: LD_INT 302
71606: DOUBLE
71607: EQUAL
71608: IFTRUE 71612
71610: GO 71649
71612: POP
// hHackSpawnVehicle ( p1 , p2 , p3 , p4 , x , y ) ; 303 :
71613: LD_VAR 0 6
71617: PPUSH
71618: LD_VAR 0 7
71622: PPUSH
71623: LD_VAR 0 8
71627: PPUSH
71628: LD_VAR 0 9
71632: PPUSH
71633: LD_VAR 0 4
71637: PPUSH
71638: LD_VAR 0 5
71642: PPUSH
71643: CALL 72896 0 6
71647: GO 71725
71649: LD_INT 303
71651: DOUBLE
71652: EQUAL
71653: IFTRUE 71657
71655: GO 71694
71657: POP
// hHackSpawnBuilding ( p1 , p2 , p3 , p4 , x , y ) ; 304 :
71658: LD_VAR 0 6
71662: PPUSH
71663: LD_VAR 0 7
71667: PPUSH
71668: LD_VAR 0 8
71672: PPUSH
71673: LD_VAR 0 9
71677: PPUSH
71678: LD_VAR 0 4
71682: PPUSH
71683: LD_VAR 0 5
71687: PPUSH
71688: CALL 71730 0 6
71692: GO 71725
71694: LD_INT 304
71696: DOUBLE
71697: EQUAL
71698: IFTRUE 71702
71700: GO 71724
71702: POP
// hHackTeleport ( unit , x , y ) ; end ;
71703: LD_VAR 0 2
71707: PPUSH
71708: LD_VAR 0 4
71712: PPUSH
71713: LD_VAR 0 5
71717: PPUSH
71718: CALL 73489 0 3
71722: GO 71725
71724: POP
// end ;
71725: LD_VAR 0 12
71729: RET
// export function hHackSpawnBuilding ( nation , btype , dir , weapon , x , y ) ; var b ; begin
71730: LD_INT 0
71732: PPUSH
71733: PPUSH
// if nation < 1 or nation > 3 or HexInfo ( x , y ) then
71734: LD_VAR 0 1
71738: PUSH
71739: LD_INT 1
71741: LESS
71742: PUSH
71743: LD_VAR 0 1
71747: PUSH
71748: LD_INT 3
71750: GREATER
71751: OR
71752: PUSH
71753: LD_VAR 0 5
71757: PPUSH
71758: LD_VAR 0 6
71762: PPUSH
71763: CALL_OW 428
71767: OR
71768: IFFALSE 71772
// exit ;
71770: GO 72492
// uc_side := your_side ;
71772: LD_ADDR_OWVAR 20
71776: PUSH
71777: LD_OWVAR 2
71781: ST_TO_ADDR
// uc_nation := nation ;
71782: LD_ADDR_OWVAR 21
71786: PUSH
71787: LD_VAR 0 1
71791: ST_TO_ADDR
// bc_level = 1 ;
71792: LD_ADDR_OWVAR 43
71796: PUSH
71797: LD_INT 1
71799: ST_TO_ADDR
// case btype of 1 :
71800: LD_VAR 0 2
71804: PUSH
71805: LD_INT 1
71807: DOUBLE
71808: EQUAL
71809: IFTRUE 71813
71811: GO 71824
71813: POP
// bc_type := b_depot ; 2 :
71814: LD_ADDR_OWVAR 42
71818: PUSH
71819: LD_INT 0
71821: ST_TO_ADDR
71822: GO 72436
71824: LD_INT 2
71826: DOUBLE
71827: EQUAL
71828: IFTRUE 71832
71830: GO 71843
71832: POP
// bc_type := b_warehouse ; 3 :
71833: LD_ADDR_OWVAR 42
71837: PUSH
71838: LD_INT 1
71840: ST_TO_ADDR
71841: GO 72436
71843: LD_INT 3
71845: DOUBLE
71846: EQUAL
71847: IFTRUE 71851
71849: GO 71862
71851: POP
// bc_type := b_lab ; 4 .. 9 :
71852: LD_ADDR_OWVAR 42
71856: PUSH
71857: LD_INT 6
71859: ST_TO_ADDR
71860: GO 72436
71862: LD_INT 4
71864: DOUBLE
71865: GREATEREQUAL
71866: IFFALSE 71874
71868: LD_INT 9
71870: DOUBLE
71871: LESSEQUAL
71872: IFTRUE 71876
71874: GO 71928
71876: POP
// begin bc_type := b_lab_half ;
71877: LD_ADDR_OWVAR 42
71881: PUSH
71882: LD_INT 7
71884: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_opto , b_lab_spacetime , b_lab_biological ] [ btype - 3 ] ;
71885: LD_ADDR_OWVAR 44
71889: PUSH
71890: LD_INT 10
71892: PUSH
71893: LD_INT 11
71895: PUSH
71896: LD_INT 12
71898: PUSH
71899: LD_INT 15
71901: PUSH
71902: LD_INT 14
71904: PUSH
71905: LD_INT 13
71907: PUSH
71908: EMPTY
71909: LIST
71910: LIST
71911: LIST
71912: LIST
71913: LIST
71914: LIST
71915: PUSH
71916: LD_VAR 0 2
71920: PUSH
71921: LD_INT 3
71923: MINUS
71924: ARRAY
71925: ST_TO_ADDR
// end ; 10 .. 13 :
71926: GO 72436
71928: LD_INT 10
71930: DOUBLE
71931: GREATEREQUAL
71932: IFFALSE 71940
71934: LD_INT 13
71936: DOUBLE
71937: LESSEQUAL
71938: IFTRUE 71942
71940: GO 72019
71942: POP
// begin bc_type := b_lab_full ;
71943: LD_ADDR_OWVAR 42
71947: PUSH
71948: LD_INT 8
71950: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_computer , b_lab_spacetime , b_lab_biological ] [ btype - 9 ] ;
71951: LD_ADDR_OWVAR 44
71955: PUSH
71956: LD_INT 10
71958: PUSH
71959: LD_INT 12
71961: PUSH
71962: LD_INT 14
71964: PUSH
71965: LD_INT 13
71967: PUSH
71968: EMPTY
71969: LIST
71970: LIST
71971: LIST
71972: LIST
71973: PUSH
71974: LD_VAR 0 2
71978: PUSH
71979: LD_INT 9
71981: MINUS
71982: ARRAY
71983: ST_TO_ADDR
// bc_kind2 := [ b_lab_siberium , b_lab_opto , b_lab_computer , b_lab_opto ] [ btype - 9 ] ;
71984: LD_ADDR_OWVAR 45
71988: PUSH
71989: LD_INT 11
71991: PUSH
71992: LD_INT 15
71994: PUSH
71995: LD_INT 12
71997: PUSH
71998: LD_INT 15
72000: PUSH
72001: EMPTY
72002: LIST
72003: LIST
72004: LIST
72005: LIST
72006: PUSH
72007: LD_VAR 0 2
72011: PUSH
72012: LD_INT 9
72014: MINUS
72015: ARRAY
72016: ST_TO_ADDR
// end ; 14 :
72017: GO 72436
72019: LD_INT 14
72021: DOUBLE
72022: EQUAL
72023: IFTRUE 72027
72025: GO 72038
72027: POP
// bc_type := b_workshop ; 15 :
72028: LD_ADDR_OWVAR 42
72032: PUSH
72033: LD_INT 2
72035: ST_TO_ADDR
72036: GO 72436
72038: LD_INT 15
72040: DOUBLE
72041: EQUAL
72042: IFTRUE 72046
72044: GO 72057
72046: POP
// bc_type := b_factory ; 16 :
72047: LD_ADDR_OWVAR 42
72051: PUSH
72052: LD_INT 3
72054: ST_TO_ADDR
72055: GO 72436
72057: LD_INT 16
72059: DOUBLE
72060: EQUAL
72061: IFTRUE 72065
72063: GO 72076
72065: POP
// bc_type := b_ext_gun ; 17 :
72066: LD_ADDR_OWVAR 42
72070: PUSH
72071: LD_INT 17
72073: ST_TO_ADDR
72074: GO 72436
72076: LD_INT 17
72078: DOUBLE
72079: EQUAL
72080: IFTRUE 72084
72082: GO 72112
72084: POP
// bc_type := [ b_ext_noncombat , b_ext_stitch , b_ext_noncombat ] [ nation ] ; 18 :
72085: LD_ADDR_OWVAR 42
72089: PUSH
72090: LD_INT 19
72092: PUSH
72093: LD_INT 23
72095: PUSH
72096: LD_INT 19
72098: PUSH
72099: EMPTY
72100: LIST
72101: LIST
72102: LIST
72103: PUSH
72104: LD_VAR 0 1
72108: ARRAY
72109: ST_TO_ADDR
72110: GO 72436
72112: LD_INT 18
72114: DOUBLE
72115: EQUAL
72116: IFTRUE 72120
72118: GO 72131
72120: POP
// bc_type := b_ext_radar ; 19 :
72121: LD_ADDR_OWVAR 42
72125: PUSH
72126: LD_INT 20
72128: ST_TO_ADDR
72129: GO 72436
72131: LD_INT 19
72133: DOUBLE
72134: EQUAL
72135: IFTRUE 72139
72137: GO 72150
72139: POP
// bc_type := b_ext_radio ; 20 :
72140: LD_ADDR_OWVAR 42
72144: PUSH
72145: LD_INT 22
72147: ST_TO_ADDR
72148: GO 72436
72150: LD_INT 20
72152: DOUBLE
72153: EQUAL
72154: IFTRUE 72158
72156: GO 72169
72158: POP
// bc_type := b_ext_siberium ; 21 :
72159: LD_ADDR_OWVAR 42
72163: PUSH
72164: LD_INT 21
72166: ST_TO_ADDR
72167: GO 72436
72169: LD_INT 21
72171: DOUBLE
72172: EQUAL
72173: IFTRUE 72177
72175: GO 72188
72177: POP
// bc_type := b_ext_computer ; 22 :
72178: LD_ADDR_OWVAR 42
72182: PUSH
72183: LD_INT 24
72185: ST_TO_ADDR
72186: GO 72436
72188: LD_INT 22
72190: DOUBLE
72191: EQUAL
72192: IFTRUE 72196
72194: GO 72207
72196: POP
// bc_type := b_ext_track ; 23 :
72197: LD_ADDR_OWVAR 42
72201: PUSH
72202: LD_INT 16
72204: ST_TO_ADDR
72205: GO 72436
72207: LD_INT 23
72209: DOUBLE
72210: EQUAL
72211: IFTRUE 72215
72213: GO 72226
72215: POP
// bc_type := b_ext_laser ; 24 :
72216: LD_ADDR_OWVAR 42
72220: PUSH
72221: LD_INT 25
72223: ST_TO_ADDR
72224: GO 72436
72226: LD_INT 24
72228: DOUBLE
72229: EQUAL
72230: IFTRUE 72234
72232: GO 72245
72234: POP
// bc_type := b_control_tower ; 25 :
72235: LD_ADDR_OWVAR 42
72239: PUSH
72240: LD_INT 36
72242: ST_TO_ADDR
72243: GO 72436
72245: LD_INT 25
72247: DOUBLE
72248: EQUAL
72249: IFTRUE 72253
72251: GO 72264
72253: POP
// bc_type := b_breastwork ; 26 :
72254: LD_ADDR_OWVAR 42
72258: PUSH
72259: LD_INT 31
72261: ST_TO_ADDR
72262: GO 72436
72264: LD_INT 26
72266: DOUBLE
72267: EQUAL
72268: IFTRUE 72272
72270: GO 72283
72272: POP
// bc_type := b_bunker ; 27 :
72273: LD_ADDR_OWVAR 42
72277: PUSH
72278: LD_INT 32
72280: ST_TO_ADDR
72281: GO 72436
72283: LD_INT 27
72285: DOUBLE
72286: EQUAL
72287: IFTRUE 72291
72289: GO 72302
72291: POP
// bc_type := b_turret ; 28 :
72292: LD_ADDR_OWVAR 42
72296: PUSH
72297: LD_INT 33
72299: ST_TO_ADDR
72300: GO 72436
72302: LD_INT 28
72304: DOUBLE
72305: EQUAL
72306: IFTRUE 72310
72308: GO 72321
72310: POP
// bc_type := b_armoury ; 29 :
72311: LD_ADDR_OWVAR 42
72315: PUSH
72316: LD_INT 4
72318: ST_TO_ADDR
72319: GO 72436
72321: LD_INT 29
72323: DOUBLE
72324: EQUAL
72325: IFTRUE 72329
72327: GO 72340
72329: POP
// bc_type := b_barracks ; 30 :
72330: LD_ADDR_OWVAR 42
72334: PUSH
72335: LD_INT 5
72337: ST_TO_ADDR
72338: GO 72436
72340: LD_INT 30
72342: DOUBLE
72343: EQUAL
72344: IFTRUE 72348
72346: GO 72359
72348: POP
// bc_type := b_solar_power ; 31 :
72349: LD_ADDR_OWVAR 42
72353: PUSH
72354: LD_INT 27
72356: ST_TO_ADDR
72357: GO 72436
72359: LD_INT 31
72361: DOUBLE
72362: EQUAL
72363: IFTRUE 72367
72365: GO 72378
72367: POP
// bc_type := b_oil_power ; 32 :
72368: LD_ADDR_OWVAR 42
72372: PUSH
72373: LD_INT 26
72375: ST_TO_ADDR
72376: GO 72436
72378: LD_INT 32
72380: DOUBLE
72381: EQUAL
72382: IFTRUE 72386
72384: GO 72397
72386: POP
// bc_type := b_siberite_power ; 33 :
72387: LD_ADDR_OWVAR 42
72391: PUSH
72392: LD_INT 28
72394: ST_TO_ADDR
72395: GO 72436
72397: LD_INT 33
72399: DOUBLE
72400: EQUAL
72401: IFTRUE 72405
72403: GO 72416
72405: POP
// bc_type := b_oil_mine ; 34 :
72406: LD_ADDR_OWVAR 42
72410: PUSH
72411: LD_INT 29
72413: ST_TO_ADDR
72414: GO 72436
72416: LD_INT 34
72418: DOUBLE
72419: EQUAL
72420: IFTRUE 72424
72422: GO 72435
72424: POP
// bc_type := b_siberite_mine ; end ;
72425: LD_ADDR_OWVAR 42
72429: PUSH
72430: LD_INT 30
72432: ST_TO_ADDR
72433: GO 72436
72435: POP
// b := CreateAndPlaceBuildingXYD ( x , y , dir ) ;
72436: LD_ADDR_VAR 0 8
72440: PUSH
72441: LD_VAR 0 5
72445: PPUSH
72446: LD_VAR 0 6
72450: PPUSH
72451: LD_VAR 0 3
72455: PPUSH
72456: CALL_OW 47
72460: ST_TO_ADDR
// if bc_type in [ b_bunker , b_turret ] then
72461: LD_OWVAR 42
72465: PUSH
72466: LD_INT 32
72468: PUSH
72469: LD_INT 33
72471: PUSH
72472: EMPTY
72473: LIST
72474: LIST
72475: IN
72476: IFFALSE 72492
// PlaceWeaponTurret ( b , weapon ) ;
72478: LD_VAR 0 8
72482: PPUSH
72483: LD_VAR 0 4
72487: PPUSH
72488: CALL_OW 431
// end ;
72492: LD_VAR 0 7
72496: RET
// export function hHackUnlimitedResources ; var i , j , tmp ; begin
72497: LD_INT 0
72499: PPUSH
72500: PPUSH
72501: PPUSH
72502: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
72503: LD_ADDR_VAR 0 4
72507: PUSH
72508: LD_INT 22
72510: PUSH
72511: LD_OWVAR 2
72515: PUSH
72516: EMPTY
72517: LIST
72518: LIST
72519: PUSH
72520: LD_INT 2
72522: PUSH
72523: LD_INT 30
72525: PUSH
72526: LD_INT 0
72528: PUSH
72529: EMPTY
72530: LIST
72531: LIST
72532: PUSH
72533: LD_INT 30
72535: PUSH
72536: LD_INT 1
72538: PUSH
72539: EMPTY
72540: LIST
72541: LIST
72542: PUSH
72543: EMPTY
72544: LIST
72545: LIST
72546: LIST
72547: PUSH
72548: EMPTY
72549: LIST
72550: LIST
72551: PPUSH
72552: CALL_OW 69
72556: ST_TO_ADDR
// if not tmp then
72557: LD_VAR 0 4
72561: NOT
72562: IFFALSE 72566
// exit ;
72564: GO 72625
// for i in tmp do
72566: LD_ADDR_VAR 0 2
72570: PUSH
72571: LD_VAR 0 4
72575: PUSH
72576: FOR_IN
72577: IFFALSE 72623
// for j = 1 to 3 do
72579: LD_ADDR_VAR 0 3
72583: PUSH
72584: DOUBLE
72585: LD_INT 1
72587: DEC
72588: ST_TO_ADDR
72589: LD_INT 3
72591: PUSH
72592: FOR_TO
72593: IFFALSE 72619
// SetResourceType ( GetBase ( i ) , j , 99999 ) ;
72595: LD_VAR 0 2
72599: PPUSH
72600: CALL_OW 274
72604: PPUSH
72605: LD_VAR 0 3
72609: PPUSH
72610: LD_INT 99999
72612: PPUSH
72613: CALL_OW 277
72617: GO 72592
72619: POP
72620: POP
72621: GO 72576
72623: POP
72624: POP
// end ;
72625: LD_VAR 0 1
72629: RET
// export function hHackSetLevel10 ; var i , j ; begin
72630: LD_INT 0
72632: PPUSH
72633: PPUSH
72634: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
72635: LD_ADDR_VAR 0 2
72639: PUSH
72640: LD_INT 21
72642: PUSH
72643: LD_INT 1
72645: PUSH
72646: EMPTY
72647: LIST
72648: LIST
72649: PPUSH
72650: CALL_OW 69
72654: PUSH
72655: FOR_IN
72656: IFFALSE 72708
// if IsSelected ( i ) then
72658: LD_VAR 0 2
72662: PPUSH
72663: CALL_OW 306
72667: IFFALSE 72706
// begin for j := 1 to 4 do
72669: LD_ADDR_VAR 0 3
72673: PUSH
72674: DOUBLE
72675: LD_INT 1
72677: DEC
72678: ST_TO_ADDR
72679: LD_INT 4
72681: PUSH
72682: FOR_TO
72683: IFFALSE 72704
// SetSkill ( i , j , 10 ) ;
72685: LD_VAR 0 2
72689: PPUSH
72690: LD_VAR 0 3
72694: PPUSH
72695: LD_INT 10
72697: PPUSH
72698: CALL_OW 237
72702: GO 72682
72704: POP
72705: POP
// end ;
72706: GO 72655
72708: POP
72709: POP
// end ;
72710: LD_VAR 0 1
72714: RET
// export function hHackSetLevel10YourUnits ; var i , j ; begin
72715: LD_INT 0
72717: PPUSH
72718: PPUSH
72719: PPUSH
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) do
72720: LD_ADDR_VAR 0 2
72724: PUSH
72725: LD_INT 22
72727: PUSH
72728: LD_OWVAR 2
72732: PUSH
72733: EMPTY
72734: LIST
72735: LIST
72736: PUSH
72737: LD_INT 21
72739: PUSH
72740: LD_INT 1
72742: PUSH
72743: EMPTY
72744: LIST
72745: LIST
72746: PUSH
72747: EMPTY
72748: LIST
72749: LIST
72750: PPUSH
72751: CALL_OW 69
72755: PUSH
72756: FOR_IN
72757: IFFALSE 72798
// begin for j := 1 to 4 do
72759: LD_ADDR_VAR 0 3
72763: PUSH
72764: DOUBLE
72765: LD_INT 1
72767: DEC
72768: ST_TO_ADDR
72769: LD_INT 4
72771: PUSH
72772: FOR_TO
72773: IFFALSE 72794
// SetSkill ( i , j , 10 ) ;
72775: LD_VAR 0 2
72779: PPUSH
72780: LD_VAR 0 3
72784: PPUSH
72785: LD_INT 10
72787: PPUSH
72788: CALL_OW 237
72792: GO 72772
72794: POP
72795: POP
// end ;
72796: GO 72756
72798: POP
72799: POP
// end ;
72800: LD_VAR 0 1
72804: RET
// export function hHackSpawnHuman ( nation , class , skill , x , y ) ; begin
72805: LD_INT 0
72807: PPUSH
// uc_side := your_side ;
72808: LD_ADDR_OWVAR 20
72812: PUSH
72813: LD_OWVAR 2
72817: ST_TO_ADDR
// uc_nation := nation ;
72818: LD_ADDR_OWVAR 21
72822: PUSH
72823: LD_VAR 0 1
72827: ST_TO_ADDR
// InitHc ;
72828: CALL_OW 19
// PrepareHuman ( false , class , skill ) ;
72832: LD_INT 0
72834: PPUSH
72835: LD_VAR 0 2
72839: PPUSH
72840: LD_VAR 0 3
72844: PPUSH
72845: CALL_OW 380
// if HexInfo ( x , y ) = 0 then
72849: LD_VAR 0 4
72853: PPUSH
72854: LD_VAR 0 5
72858: PPUSH
72859: CALL_OW 428
72863: PUSH
72864: LD_INT 0
72866: EQUAL
72867: IFFALSE 72891
// PlaceUnitXY ( CreateHuman , x , y , true ) ;
72869: CALL_OW 44
72873: PPUSH
72874: LD_VAR 0 4
72878: PPUSH
72879: LD_VAR 0 5
72883: PPUSH
72884: LD_INT 1
72886: PPUSH
72887: CALL_OW 48
// end ;
72891: LD_VAR 0 6
72895: RET
// export function hHackSpawnVehicle ( chassis , engine , control , weapon , x , y ) ; var un ; begin
72896: LD_INT 0
72898: PPUSH
72899: PPUSH
// uc_side := your_side ;
72900: LD_ADDR_OWVAR 20
72904: PUSH
72905: LD_OWVAR 2
72909: ST_TO_ADDR
// if chassis in [ 1 , 2 , 3 , 4 , 5 ] then
72910: LD_VAR 0 1
72914: PUSH
72915: LD_INT 1
72917: PUSH
72918: LD_INT 2
72920: PUSH
72921: LD_INT 3
72923: PUSH
72924: LD_INT 4
72926: PUSH
72927: LD_INT 5
72929: PUSH
72930: EMPTY
72931: LIST
72932: LIST
72933: LIST
72934: LIST
72935: LIST
72936: IN
72937: IFFALSE 72949
// uc_nation := nation_american else
72939: LD_ADDR_OWVAR 21
72943: PUSH
72944: LD_INT 1
72946: ST_TO_ADDR
72947: GO 72992
// if chassis in [ 11 , 12 , 13 , 14 ] then
72949: LD_VAR 0 1
72953: PUSH
72954: LD_INT 11
72956: PUSH
72957: LD_INT 12
72959: PUSH
72960: LD_INT 13
72962: PUSH
72963: LD_INT 14
72965: PUSH
72966: EMPTY
72967: LIST
72968: LIST
72969: LIST
72970: LIST
72971: IN
72972: IFFALSE 72984
// uc_nation := nation_arabian else
72974: LD_ADDR_OWVAR 21
72978: PUSH
72979: LD_INT 2
72981: ST_TO_ADDR
72982: GO 72992
// uc_nation := nation_russian ;
72984: LD_ADDR_OWVAR 21
72988: PUSH
72989: LD_INT 3
72991: ST_TO_ADDR
// vc_chassis := chassis ;
72992: LD_ADDR_OWVAR 37
72996: PUSH
72997: LD_VAR 0 1
73001: ST_TO_ADDR
// vc_engine := engine ;
73002: LD_ADDR_OWVAR 39
73006: PUSH
73007: LD_VAR 0 2
73011: ST_TO_ADDR
// vc_control := control ;
73012: LD_ADDR_OWVAR 38
73016: PUSH
73017: LD_VAR 0 3
73021: ST_TO_ADDR
// vc_weapon := weapon ;
73022: LD_ADDR_OWVAR 40
73026: PUSH
73027: LD_VAR 0 4
73031: ST_TO_ADDR
// un := CreateVehicle ;
73032: LD_ADDR_VAR 0 8
73036: PUSH
73037: CALL_OW 45
73041: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
73042: LD_VAR 0 8
73046: PPUSH
73047: LD_INT 0
73049: PPUSH
73050: LD_INT 5
73052: PPUSH
73053: CALL_OW 12
73057: PPUSH
73058: CALL_OW 233
// PlaceUnitXY ( un , x , y , true ) ;
73062: LD_VAR 0 8
73066: PPUSH
73067: LD_VAR 0 5
73071: PPUSH
73072: LD_VAR 0 6
73076: PPUSH
73077: LD_INT 1
73079: PPUSH
73080: CALL_OW 48
// end ;
73084: LD_VAR 0 7
73088: RET
// export hInvincible ; every 1 do
73089: GO 73091
73091: DISABLE
// hInvincible := [ ] ;
73092: LD_ADDR_EXP 153
73096: PUSH
73097: EMPTY
73098: ST_TO_ADDR
73099: END
// every 10 do var i ;
73100: GO 73102
73102: DISABLE
73103: LD_INT 0
73105: PPUSH
// begin enable ;
73106: ENABLE
// if not hInvincible then
73107: LD_EXP 153
73111: NOT
73112: IFFALSE 73116
// exit ;
73114: GO 73160
// for i in hInvincible do
73116: LD_ADDR_VAR 0 1
73120: PUSH
73121: LD_EXP 153
73125: PUSH
73126: FOR_IN
73127: IFFALSE 73158
// if GetLives ( i ) < 1000 then
73129: LD_VAR 0 1
73133: PPUSH
73134: CALL_OW 256
73138: PUSH
73139: LD_INT 1000
73141: LESS
73142: IFFALSE 73156
// SetLives ( i , 1000 ) ;
73144: LD_VAR 0 1
73148: PPUSH
73149: LD_INT 1000
73151: PPUSH
73152: CALL_OW 234
73156: GO 73126
73158: POP
73159: POP
// end ;
73160: PPOPN 1
73162: END
// export function hHackInvincible ; var i ; begin
73163: LD_INT 0
73165: PPUSH
73166: PPUSH
// for i in FilterAllUnits ( [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ) do
73167: LD_ADDR_VAR 0 2
73171: PUSH
73172: LD_INT 2
73174: PUSH
73175: LD_INT 21
73177: PUSH
73178: LD_INT 1
73180: PUSH
73181: EMPTY
73182: LIST
73183: LIST
73184: PUSH
73185: LD_INT 21
73187: PUSH
73188: LD_INT 2
73190: PUSH
73191: EMPTY
73192: LIST
73193: LIST
73194: PUSH
73195: EMPTY
73196: LIST
73197: LIST
73198: LIST
73199: PPUSH
73200: CALL_OW 69
73204: PUSH
73205: FOR_IN
73206: IFFALSE 73267
// if IsSelected ( i ) then
73208: LD_VAR 0 2
73212: PPUSH
73213: CALL_OW 306
73217: IFFALSE 73265
// begin if i in hInvincible then
73219: LD_VAR 0 2
73223: PUSH
73224: LD_EXP 153
73228: IN
73229: IFFALSE 73249
// hInvincible := hInvincible diff i else
73231: LD_ADDR_EXP 153
73235: PUSH
73236: LD_EXP 153
73240: PUSH
73241: LD_VAR 0 2
73245: DIFF
73246: ST_TO_ADDR
73247: GO 73265
// hInvincible := hInvincible union i ;
73249: LD_ADDR_EXP 153
73253: PUSH
73254: LD_EXP 153
73258: PUSH
73259: LD_VAR 0 2
73263: UNION
73264: ST_TO_ADDR
// end ;
73265: GO 73205
73267: POP
73268: POP
// end ;
73269: LD_VAR 0 1
73273: RET
// export function hHackInvisible ; var i , j ; begin
73274: LD_INT 0
73276: PPUSH
73277: PPUSH
73278: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
73279: LD_ADDR_VAR 0 2
73283: PUSH
73284: LD_INT 21
73286: PUSH
73287: LD_INT 1
73289: PUSH
73290: EMPTY
73291: LIST
73292: LIST
73293: PPUSH
73294: CALL_OW 69
73298: PUSH
73299: FOR_IN
73300: IFFALSE 73324
// if IsSelected ( i ) then
73302: LD_VAR 0 2
73306: PPUSH
73307: CALL_OW 306
73311: IFFALSE 73322
// ComForceInvisible ( i ) ;
73313: LD_VAR 0 2
73317: PPUSH
73318: CALL_OW 496
73322: GO 73299
73324: POP
73325: POP
// end ;
73326: LD_VAR 0 1
73330: RET
// export function hHackChangeYourSide ; begin
73331: LD_INT 0
73333: PPUSH
// if your_side = 8 then
73334: LD_OWVAR 2
73338: PUSH
73339: LD_INT 8
73341: EQUAL
73342: IFFALSE 73354
// your_side := 0 else
73344: LD_ADDR_OWVAR 2
73348: PUSH
73349: LD_INT 0
73351: ST_TO_ADDR
73352: GO 73368
// your_side := your_side + 1 ;
73354: LD_ADDR_OWVAR 2
73358: PUSH
73359: LD_OWVAR 2
73363: PUSH
73364: LD_INT 1
73366: PLUS
73367: ST_TO_ADDR
// end ;
73368: LD_VAR 0 1
73372: RET
// export function hHackChangeUnitSide ; var i , j ; begin
73373: LD_INT 0
73375: PPUSH
73376: PPUSH
73377: PPUSH
// for i in all_units do
73378: LD_ADDR_VAR 0 2
73382: PUSH
73383: LD_OWVAR 3
73387: PUSH
73388: FOR_IN
73389: IFFALSE 73467
// if IsSelected ( i ) then
73391: LD_VAR 0 2
73395: PPUSH
73396: CALL_OW 306
73400: IFFALSE 73465
// begin j := GetSide ( i ) ;
73402: LD_ADDR_VAR 0 3
73406: PUSH
73407: LD_VAR 0 2
73411: PPUSH
73412: CALL_OW 255
73416: ST_TO_ADDR
// if j = 8 then
73417: LD_VAR 0 3
73421: PUSH
73422: LD_INT 8
73424: EQUAL
73425: IFFALSE 73437
// j := 0 else
73427: LD_ADDR_VAR 0 3
73431: PUSH
73432: LD_INT 0
73434: ST_TO_ADDR
73435: GO 73451
// j := j + 1 ;
73437: LD_ADDR_VAR 0 3
73441: PUSH
73442: LD_VAR 0 3
73446: PUSH
73447: LD_INT 1
73449: PLUS
73450: ST_TO_ADDR
// SetSide ( i , j ) ;
73451: LD_VAR 0 2
73455: PPUSH
73456: LD_VAR 0 3
73460: PPUSH
73461: CALL_OW 235
// end ;
73465: GO 73388
73467: POP
73468: POP
// end ;
73469: LD_VAR 0 1
73473: RET
// export function hHackFog ; begin
73474: LD_INT 0
73476: PPUSH
// FogOff ( true ) ;
73477: LD_INT 1
73479: PPUSH
73480: CALL_OW 344
// end ;
73484: LD_VAR 0 1
73488: RET
// export function hHackTeleport ( unit , x , y ) ; begin
73489: LD_INT 0
73491: PPUSH
// TeleportUnit ( unit , x , y , 1 , true ) ;
73492: LD_VAR 0 1
73496: PPUSH
73497: LD_VAR 0 2
73501: PPUSH
73502: LD_VAR 0 3
73506: PPUSH
73507: LD_INT 1
73509: PPUSH
73510: LD_INT 1
73512: PPUSH
73513: CALL_OW 483
// CenterOnXY ( x , y ) ;
73517: LD_VAR 0 2
73521: PPUSH
73522: LD_VAR 0 3
73526: PPUSH
73527: CALL_OW 84
// end ; end_of_file
73531: LD_VAR 0 4
73535: RET
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb , ar_heavy_mortar , ar_crane , ar_miner ; export tech_Artillery , tech_RadMat , tech_BasicTools , tech_Cargo , tech_Track , tech_Crane , tech_Bulldozer , tech_Hovercraft ; export function InitGlobalVariables ; begin
73536: LD_INT 0
73538: PPUSH
// ar_miner := 81 ;
73539: LD_ADDR_EXP 161
73543: PUSH
73544: LD_INT 81
73546: ST_TO_ADDR
// ar_crane := 88 ;
73547: LD_ADDR_EXP 160
73551: PUSH
73552: LD_INT 88
73554: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
73555: LD_ADDR_EXP 155
73559: PUSH
73560: LD_INT 89
73562: ST_TO_ADDR
// us_hack := 99 ;
73563: LD_ADDR_EXP 156
73567: PUSH
73568: LD_INT 99
73570: ST_TO_ADDR
// us_artillery := 97 ;
73571: LD_ADDR_EXP 157
73575: PUSH
73576: LD_INT 97
73578: ST_TO_ADDR
// ar_bio_bomb := 91 ;
73579: LD_ADDR_EXP 158
73583: PUSH
73584: LD_INT 91
73586: ST_TO_ADDR
// ar_heavy_mortar := 92 ;
73587: LD_ADDR_EXP 159
73591: PUSH
73592: LD_INT 92
73594: ST_TO_ADDR
// ru_radar := 98 ;
73595: LD_ADDR_EXP 154
73599: PUSH
73600: LD_INT 98
73602: ST_TO_ADDR
// tech_Artillery := 80 ;
73603: LD_ADDR_EXP 162
73607: PUSH
73608: LD_INT 80
73610: ST_TO_ADDR
// tech_RadMat := 81 ;
73611: LD_ADDR_EXP 163
73615: PUSH
73616: LD_INT 81
73618: ST_TO_ADDR
// tech_BasicTools := 82 ;
73619: LD_ADDR_EXP 164
73623: PUSH
73624: LD_INT 82
73626: ST_TO_ADDR
// tech_Cargo := 83 ;
73627: LD_ADDR_EXP 165
73631: PUSH
73632: LD_INT 83
73634: ST_TO_ADDR
// tech_Track := 84 ;
73635: LD_ADDR_EXP 166
73639: PUSH
73640: LD_INT 84
73642: ST_TO_ADDR
// tech_Crane := 85 ;
73643: LD_ADDR_EXP 167
73647: PUSH
73648: LD_INT 85
73650: ST_TO_ADDR
// tech_Bulldozer := 86 ;
73651: LD_ADDR_EXP 168
73655: PUSH
73656: LD_INT 86
73658: ST_TO_ADDR
// tech_Hovercraft := 87 ;
73659: LD_ADDR_EXP 169
73663: PUSH
73664: LD_INT 87
73666: ST_TO_ADDR
// end ;
73667: LD_VAR 0 1
73671: RET
// every 1 do
73672: GO 73674
73674: DISABLE
// InitGlobalVariables ; end_of_file
73675: CALL 73536 0 0
73679: END
// on TargetableSAIL ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) do begin case cmd of 200 .. 299 :
73680: LD_VAR 0 1
73684: PUSH
73685: LD_INT 200
73687: DOUBLE
73688: GREATEREQUAL
73689: IFFALSE 73697
73691: LD_INT 299
73693: DOUBLE
73694: LESSEQUAL
73695: IFTRUE 73699
73697: GO 73731
73699: POP
// SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; end ;
73700: LD_VAR 0 1
73704: PPUSH
73705: LD_VAR 0 2
73709: PPUSH
73710: LD_VAR 0 3
73714: PPUSH
73715: LD_VAR 0 4
73719: PPUSH
73720: LD_VAR 0 5
73724: PPUSH
73725: CALL 56486 0 5
73729: GO 73732
73731: POP
// end ; end_of_file
73732: PPOPN 11
73734: END
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
73735: LD_INT 0
73737: PPUSH
73738: PPUSH
73739: PPUSH
73740: PPUSH
73741: PPUSH
73742: PPUSH
73743: PPUSH
73744: PPUSH
73745: PPUSH
73746: PPUSH
73747: PPUSH
73748: PPUSH
73749: PPUSH
73750: PPUSH
73751: PPUSH
73752: PPUSH
73753: PPUSH
73754: PPUSH
73755: PPUSH
73756: PPUSH
73757: PPUSH
73758: PPUSH
73759: PPUSH
73760: PPUSH
73761: PPUSH
73762: PPUSH
73763: PPUSH
73764: PPUSH
73765: PPUSH
73766: PPUSH
73767: PPUSH
73768: PPUSH
73769: PPUSH
73770: PPUSH
// if not list then
73771: LD_VAR 0 1
73775: NOT
73776: IFFALSE 73780
// exit ;
73778: GO 78439
// base := list [ 1 ] ;
73780: LD_ADDR_VAR 0 3
73784: PUSH
73785: LD_VAR 0 1
73789: PUSH
73790: LD_INT 1
73792: ARRAY
73793: ST_TO_ADDR
// group := list [ 2 ] ;
73794: LD_ADDR_VAR 0 4
73798: PUSH
73799: LD_VAR 0 1
73803: PUSH
73804: LD_INT 2
73806: ARRAY
73807: ST_TO_ADDR
// path := list [ 3 ] ;
73808: LD_ADDR_VAR 0 5
73812: PUSH
73813: LD_VAR 0 1
73817: PUSH
73818: LD_INT 3
73820: ARRAY
73821: ST_TO_ADDR
// flags := list [ 4 ] ;
73822: LD_ADDR_VAR 0 6
73826: PUSH
73827: LD_VAR 0 1
73831: PUSH
73832: LD_INT 4
73834: ARRAY
73835: ST_TO_ADDR
// mined := [ ] ;
73836: LD_ADDR_VAR 0 27
73840: PUSH
73841: EMPTY
73842: ST_TO_ADDR
// bombed := [ ] ;
73843: LD_ADDR_VAR 0 28
73847: PUSH
73848: EMPTY
73849: ST_TO_ADDR
// healers := [ ] ;
73850: LD_ADDR_VAR 0 31
73854: PUSH
73855: EMPTY
73856: ST_TO_ADDR
// to_heal := [ ] ;
73857: LD_ADDR_VAR 0 30
73861: PUSH
73862: EMPTY
73863: ST_TO_ADDR
// repairs := [ ] ;
73864: LD_ADDR_VAR 0 33
73868: PUSH
73869: EMPTY
73870: ST_TO_ADDR
// to_repair := [ ] ;
73871: LD_ADDR_VAR 0 32
73875: PUSH
73876: EMPTY
73877: ST_TO_ADDR
// if not group or not path then
73878: LD_VAR 0 4
73882: NOT
73883: PUSH
73884: LD_VAR 0 5
73888: NOT
73889: OR
73890: IFFALSE 73894
// exit ;
73892: GO 78439
// side := GetSide ( group [ 1 ] ) ;
73894: LD_ADDR_VAR 0 35
73898: PUSH
73899: LD_VAR 0 4
73903: PUSH
73904: LD_INT 1
73906: ARRAY
73907: PPUSH
73908: CALL_OW 255
73912: ST_TO_ADDR
// if flags then
73913: LD_VAR 0 6
73917: IFFALSE 74061
// begin f_ignore_area := flags [ 1 ] ;
73919: LD_ADDR_VAR 0 17
73923: PUSH
73924: LD_VAR 0 6
73928: PUSH
73929: LD_INT 1
73931: ARRAY
73932: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
73933: LD_ADDR_VAR 0 18
73937: PUSH
73938: LD_VAR 0 6
73942: PUSH
73943: LD_INT 2
73945: ARRAY
73946: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
73947: LD_ADDR_VAR 0 19
73951: PUSH
73952: LD_VAR 0 6
73956: PUSH
73957: LD_INT 3
73959: ARRAY
73960: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
73961: LD_ADDR_VAR 0 20
73965: PUSH
73966: LD_VAR 0 6
73970: PUSH
73971: LD_INT 4
73973: ARRAY
73974: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
73975: LD_ADDR_VAR 0 21
73979: PUSH
73980: LD_VAR 0 6
73984: PUSH
73985: LD_INT 5
73987: ARRAY
73988: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
73989: LD_ADDR_VAR 0 22
73993: PUSH
73994: LD_VAR 0 6
73998: PUSH
73999: LD_INT 6
74001: ARRAY
74002: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
74003: LD_ADDR_VAR 0 23
74007: PUSH
74008: LD_VAR 0 6
74012: PUSH
74013: LD_INT 7
74015: ARRAY
74016: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
74017: LD_ADDR_VAR 0 24
74021: PUSH
74022: LD_VAR 0 6
74026: PUSH
74027: LD_INT 8
74029: ARRAY
74030: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
74031: LD_ADDR_VAR 0 25
74035: PUSH
74036: LD_VAR 0 6
74040: PUSH
74041: LD_INT 9
74043: ARRAY
74044: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
74045: LD_ADDR_VAR 0 26
74049: PUSH
74050: LD_VAR 0 6
74054: PUSH
74055: LD_INT 10
74057: ARRAY
74058: ST_TO_ADDR
// end else
74059: GO 74141
// begin f_ignore_area := false ;
74061: LD_ADDR_VAR 0 17
74065: PUSH
74066: LD_INT 0
74068: ST_TO_ADDR
// f_capture := false ;
74069: LD_ADDR_VAR 0 18
74073: PUSH
74074: LD_INT 0
74076: ST_TO_ADDR
// f_ignore_civ := false ;
74077: LD_ADDR_VAR 0 19
74081: PUSH
74082: LD_INT 0
74084: ST_TO_ADDR
// f_murder := false ;
74085: LD_ADDR_VAR 0 20
74089: PUSH
74090: LD_INT 0
74092: ST_TO_ADDR
// f_mines := false ;
74093: LD_ADDR_VAR 0 21
74097: PUSH
74098: LD_INT 0
74100: ST_TO_ADDR
// f_repair := false ;
74101: LD_ADDR_VAR 0 22
74105: PUSH
74106: LD_INT 0
74108: ST_TO_ADDR
// f_heal := false ;
74109: LD_ADDR_VAR 0 23
74113: PUSH
74114: LD_INT 0
74116: ST_TO_ADDR
// f_spacetime := false ;
74117: LD_ADDR_VAR 0 24
74121: PUSH
74122: LD_INT 0
74124: ST_TO_ADDR
// f_attack_depot := false ;
74125: LD_ADDR_VAR 0 25
74129: PUSH
74130: LD_INT 0
74132: ST_TO_ADDR
// f_crawl := false ;
74133: LD_ADDR_VAR 0 26
74137: PUSH
74138: LD_INT 0
74140: ST_TO_ADDR
// end ; if f_heal then
74141: LD_VAR 0 23
74145: IFFALSE 74172
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
74147: LD_ADDR_VAR 0 31
74151: PUSH
74152: LD_VAR 0 4
74156: PPUSH
74157: LD_INT 25
74159: PUSH
74160: LD_INT 4
74162: PUSH
74163: EMPTY
74164: LIST
74165: LIST
74166: PPUSH
74167: CALL_OW 72
74171: ST_TO_ADDR
// if f_repair then
74172: LD_VAR 0 22
74176: IFFALSE 74203
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
74178: LD_ADDR_VAR 0 33
74182: PUSH
74183: LD_VAR 0 4
74187: PPUSH
74188: LD_INT 25
74190: PUSH
74191: LD_INT 3
74193: PUSH
74194: EMPTY
74195: LIST
74196: LIST
74197: PPUSH
74198: CALL_OW 72
74202: ST_TO_ADDR
// units_path := [ ] ;
74203: LD_ADDR_VAR 0 16
74207: PUSH
74208: EMPTY
74209: ST_TO_ADDR
// for i = 1 to group do
74210: LD_ADDR_VAR 0 7
74214: PUSH
74215: DOUBLE
74216: LD_INT 1
74218: DEC
74219: ST_TO_ADDR
74220: LD_VAR 0 4
74224: PUSH
74225: FOR_TO
74226: IFFALSE 74255
// units_path := Replace ( units_path , i , path ) ;
74228: LD_ADDR_VAR 0 16
74232: PUSH
74233: LD_VAR 0 16
74237: PPUSH
74238: LD_VAR 0 7
74242: PPUSH
74243: LD_VAR 0 5
74247: PPUSH
74248: CALL_OW 1
74252: ST_TO_ADDR
74253: GO 74225
74255: POP
74256: POP
// repeat for i = group downto 1 do
74257: LD_ADDR_VAR 0 7
74261: PUSH
74262: DOUBLE
74263: LD_VAR 0 4
74267: INC
74268: ST_TO_ADDR
74269: LD_INT 1
74271: PUSH
74272: FOR_DOWNTO
74273: IFFALSE 78395
// begin wait ( 5 ) ;
74275: LD_INT 5
74277: PPUSH
74278: CALL_OW 67
// tmp := [ ] ;
74282: LD_ADDR_VAR 0 14
74286: PUSH
74287: EMPTY
74288: ST_TO_ADDR
// attacking := false ;
74289: LD_ADDR_VAR 0 29
74293: PUSH
74294: LD_INT 0
74296: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
74297: LD_VAR 0 4
74301: PUSH
74302: LD_VAR 0 7
74306: ARRAY
74307: PPUSH
74308: CALL_OW 301
74312: PUSH
74313: LD_VAR 0 4
74317: PUSH
74318: LD_VAR 0 7
74322: ARRAY
74323: NOT
74324: OR
74325: IFFALSE 74434
// begin if GetType ( group [ i ] ) = unit_human then
74327: LD_VAR 0 4
74331: PUSH
74332: LD_VAR 0 7
74336: ARRAY
74337: PPUSH
74338: CALL_OW 247
74342: PUSH
74343: LD_INT 1
74345: EQUAL
74346: IFFALSE 74392
// begin to_heal := to_heal diff group [ i ] ;
74348: LD_ADDR_VAR 0 30
74352: PUSH
74353: LD_VAR 0 30
74357: PUSH
74358: LD_VAR 0 4
74362: PUSH
74363: LD_VAR 0 7
74367: ARRAY
74368: DIFF
74369: ST_TO_ADDR
// healers := healers diff group [ i ] ;
74370: LD_ADDR_VAR 0 31
74374: PUSH
74375: LD_VAR 0 31
74379: PUSH
74380: LD_VAR 0 4
74384: PUSH
74385: LD_VAR 0 7
74389: ARRAY
74390: DIFF
74391: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
74392: LD_ADDR_VAR 0 4
74396: PUSH
74397: LD_VAR 0 4
74401: PPUSH
74402: LD_VAR 0 7
74406: PPUSH
74407: CALL_OW 3
74411: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
74412: LD_ADDR_VAR 0 16
74416: PUSH
74417: LD_VAR 0 16
74421: PPUSH
74422: LD_VAR 0 7
74426: PPUSH
74427: CALL_OW 3
74431: ST_TO_ADDR
// continue ;
74432: GO 74272
// end ; if f_repair then
74434: LD_VAR 0 22
74438: IFFALSE 74927
// begin if GetType ( group [ i ] ) = unit_vehicle then
74440: LD_VAR 0 4
74444: PUSH
74445: LD_VAR 0 7
74449: ARRAY
74450: PPUSH
74451: CALL_OW 247
74455: PUSH
74456: LD_INT 2
74458: EQUAL
74459: IFFALSE 74649
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
74461: LD_VAR 0 4
74465: PUSH
74466: LD_VAR 0 7
74470: ARRAY
74471: PPUSH
74472: CALL_OW 256
74476: PUSH
74477: LD_INT 700
74479: LESS
74480: PUSH
74481: LD_VAR 0 4
74485: PUSH
74486: LD_VAR 0 7
74490: ARRAY
74491: PUSH
74492: LD_VAR 0 32
74496: IN
74497: NOT
74498: AND
74499: IFFALSE 74523
// to_repair := to_repair union group [ i ] ;
74501: LD_ADDR_VAR 0 32
74505: PUSH
74506: LD_VAR 0 32
74510: PUSH
74511: LD_VAR 0 4
74515: PUSH
74516: LD_VAR 0 7
74520: ARRAY
74521: UNION
74522: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
74523: LD_VAR 0 4
74527: PUSH
74528: LD_VAR 0 7
74532: ARRAY
74533: PPUSH
74534: CALL_OW 256
74538: PUSH
74539: LD_INT 1000
74541: EQUAL
74542: PUSH
74543: LD_VAR 0 4
74547: PUSH
74548: LD_VAR 0 7
74552: ARRAY
74553: PUSH
74554: LD_VAR 0 32
74558: IN
74559: AND
74560: IFFALSE 74584
// to_repair := to_repair diff group [ i ] ;
74562: LD_ADDR_VAR 0 32
74566: PUSH
74567: LD_VAR 0 32
74571: PUSH
74572: LD_VAR 0 4
74576: PUSH
74577: LD_VAR 0 7
74581: ARRAY
74582: DIFF
74583: ST_TO_ADDR
// if group [ i ] in to_repair then
74584: LD_VAR 0 4
74588: PUSH
74589: LD_VAR 0 7
74593: ARRAY
74594: PUSH
74595: LD_VAR 0 32
74599: IN
74600: IFFALSE 74647
// begin if not IsInArea ( group [ i ] , f_repair ) then
74602: LD_VAR 0 4
74606: PUSH
74607: LD_VAR 0 7
74611: ARRAY
74612: PPUSH
74613: LD_VAR 0 22
74617: PPUSH
74618: CALL_OW 308
74622: NOT
74623: IFFALSE 74645
// ComMoveToArea ( group [ i ] , f_repair ) ;
74625: LD_VAR 0 4
74629: PUSH
74630: LD_VAR 0 7
74634: ARRAY
74635: PPUSH
74636: LD_VAR 0 22
74640: PPUSH
74641: CALL_OW 113
// continue ;
74645: GO 74272
// end ; end else
74647: GO 74927
// if group [ i ] in repairs then
74649: LD_VAR 0 4
74653: PUSH
74654: LD_VAR 0 7
74658: ARRAY
74659: PUSH
74660: LD_VAR 0 33
74664: IN
74665: IFFALSE 74927
// begin if IsInUnit ( group [ i ] ) then
74667: LD_VAR 0 4
74671: PUSH
74672: LD_VAR 0 7
74676: ARRAY
74677: PPUSH
74678: CALL_OW 310
74682: IFFALSE 74750
// begin z := IsInUnit ( group [ i ] ) ;
74684: LD_ADDR_VAR 0 13
74688: PUSH
74689: LD_VAR 0 4
74693: PUSH
74694: LD_VAR 0 7
74698: ARRAY
74699: PPUSH
74700: CALL_OW 310
74704: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
74705: LD_VAR 0 13
74709: PUSH
74710: LD_VAR 0 32
74714: IN
74715: PUSH
74716: LD_VAR 0 13
74720: PPUSH
74721: LD_VAR 0 22
74725: PPUSH
74726: CALL_OW 308
74730: AND
74731: IFFALSE 74748
// ComExitVehicle ( group [ i ] ) ;
74733: LD_VAR 0 4
74737: PUSH
74738: LD_VAR 0 7
74742: ARRAY
74743: PPUSH
74744: CALL_OW 121
// end else
74748: GO 74927
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
74750: LD_ADDR_VAR 0 13
74754: PUSH
74755: LD_VAR 0 4
74759: PPUSH
74760: LD_INT 95
74762: PUSH
74763: LD_VAR 0 22
74767: PUSH
74768: EMPTY
74769: LIST
74770: LIST
74771: PUSH
74772: LD_INT 58
74774: PUSH
74775: EMPTY
74776: LIST
74777: PUSH
74778: EMPTY
74779: LIST
74780: LIST
74781: PPUSH
74782: CALL_OW 72
74786: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
74787: LD_VAR 0 4
74791: PUSH
74792: LD_VAR 0 7
74796: ARRAY
74797: PPUSH
74798: CALL_OW 314
74802: NOT
74803: IFFALSE 74925
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
74805: LD_ADDR_VAR 0 10
74809: PUSH
74810: LD_VAR 0 13
74814: PPUSH
74815: LD_VAR 0 4
74819: PUSH
74820: LD_VAR 0 7
74824: ARRAY
74825: PPUSH
74826: CALL_OW 74
74830: ST_TO_ADDR
// if not x then
74831: LD_VAR 0 10
74835: NOT
74836: IFFALSE 74840
// continue ;
74838: GO 74272
// if GetLives ( x ) < 1000 then
74840: LD_VAR 0 10
74844: PPUSH
74845: CALL_OW 256
74849: PUSH
74850: LD_INT 1000
74852: LESS
74853: IFFALSE 74877
// ComRepairVehicle ( group [ i ] , x ) else
74855: LD_VAR 0 4
74859: PUSH
74860: LD_VAR 0 7
74864: ARRAY
74865: PPUSH
74866: LD_VAR 0 10
74870: PPUSH
74871: CALL_OW 129
74875: GO 74925
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
74877: LD_VAR 0 23
74881: PUSH
74882: LD_VAR 0 4
74886: PUSH
74887: LD_VAR 0 7
74891: ARRAY
74892: PPUSH
74893: CALL_OW 256
74897: PUSH
74898: LD_INT 1000
74900: LESS
74901: AND
74902: NOT
74903: IFFALSE 74925
// ComEnterUnit ( group [ i ] , x ) ;
74905: LD_VAR 0 4
74909: PUSH
74910: LD_VAR 0 7
74914: ARRAY
74915: PPUSH
74916: LD_VAR 0 10
74920: PPUSH
74921: CALL_OW 120
// end ; continue ;
74925: GO 74272
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
74927: LD_VAR 0 23
74931: PUSH
74932: LD_VAR 0 4
74936: PUSH
74937: LD_VAR 0 7
74941: ARRAY
74942: PPUSH
74943: CALL_OW 247
74947: PUSH
74948: LD_INT 1
74950: EQUAL
74951: AND
74952: IFFALSE 75430
// begin if group [ i ] in healers then
74954: LD_VAR 0 4
74958: PUSH
74959: LD_VAR 0 7
74963: ARRAY
74964: PUSH
74965: LD_VAR 0 31
74969: IN
74970: IFFALSE 75243
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
74972: LD_VAR 0 4
74976: PUSH
74977: LD_VAR 0 7
74981: ARRAY
74982: PPUSH
74983: LD_VAR 0 23
74987: PPUSH
74988: CALL_OW 308
74992: NOT
74993: PUSH
74994: LD_VAR 0 4
74998: PUSH
74999: LD_VAR 0 7
75003: ARRAY
75004: PPUSH
75005: CALL_OW 314
75009: NOT
75010: AND
75011: IFFALSE 75035
// ComMoveToArea ( group [ i ] , f_heal ) else
75013: LD_VAR 0 4
75017: PUSH
75018: LD_VAR 0 7
75022: ARRAY
75023: PPUSH
75024: LD_VAR 0 23
75028: PPUSH
75029: CALL_OW 113
75033: GO 75241
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
75035: LD_VAR 0 4
75039: PUSH
75040: LD_VAR 0 7
75044: ARRAY
75045: PPUSH
75046: CALL 52468 0 1
75050: PPUSH
75051: CALL_OW 256
75055: PUSH
75056: LD_INT 1000
75058: EQUAL
75059: IFFALSE 75078
// ComStop ( group [ i ] ) else
75061: LD_VAR 0 4
75065: PUSH
75066: LD_VAR 0 7
75070: ARRAY
75071: PPUSH
75072: CALL_OW 141
75076: GO 75241
// if not HasTask ( group [ i ] ) and to_heal then
75078: LD_VAR 0 4
75082: PUSH
75083: LD_VAR 0 7
75087: ARRAY
75088: PPUSH
75089: CALL_OW 314
75093: NOT
75094: PUSH
75095: LD_VAR 0 30
75099: AND
75100: IFFALSE 75241
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
75102: LD_ADDR_VAR 0 13
75106: PUSH
75107: LD_VAR 0 30
75111: PPUSH
75112: LD_INT 3
75114: PUSH
75115: LD_INT 54
75117: PUSH
75118: EMPTY
75119: LIST
75120: PUSH
75121: EMPTY
75122: LIST
75123: LIST
75124: PPUSH
75125: CALL_OW 72
75129: PPUSH
75130: LD_VAR 0 4
75134: PUSH
75135: LD_VAR 0 7
75139: ARRAY
75140: PPUSH
75141: CALL_OW 74
75145: ST_TO_ADDR
// if z then
75146: LD_VAR 0 13
75150: IFFALSE 75241
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
75152: LD_INT 91
75154: PUSH
75155: LD_VAR 0 13
75159: PUSH
75160: LD_INT 10
75162: PUSH
75163: EMPTY
75164: LIST
75165: LIST
75166: LIST
75167: PUSH
75168: LD_INT 81
75170: PUSH
75171: LD_VAR 0 13
75175: PPUSH
75176: CALL_OW 255
75180: PUSH
75181: EMPTY
75182: LIST
75183: LIST
75184: PUSH
75185: EMPTY
75186: LIST
75187: LIST
75188: PPUSH
75189: CALL_OW 69
75193: PUSH
75194: LD_INT 0
75196: EQUAL
75197: IFFALSE 75221
// ComHeal ( group [ i ] , z ) else
75199: LD_VAR 0 4
75203: PUSH
75204: LD_VAR 0 7
75208: ARRAY
75209: PPUSH
75210: LD_VAR 0 13
75214: PPUSH
75215: CALL_OW 128
75219: GO 75241
// ComMoveToArea ( group [ i ] , f_heal ) ;
75221: LD_VAR 0 4
75225: PUSH
75226: LD_VAR 0 7
75230: ARRAY
75231: PPUSH
75232: LD_VAR 0 23
75236: PPUSH
75237: CALL_OW 113
// end ; continue ;
75241: GO 74272
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
75243: LD_VAR 0 4
75247: PUSH
75248: LD_VAR 0 7
75252: ARRAY
75253: PPUSH
75254: CALL_OW 256
75258: PUSH
75259: LD_INT 700
75261: LESS
75262: PUSH
75263: LD_VAR 0 4
75267: PUSH
75268: LD_VAR 0 7
75272: ARRAY
75273: PUSH
75274: LD_VAR 0 30
75278: IN
75279: NOT
75280: AND
75281: IFFALSE 75305
// to_heal := to_heal union group [ i ] ;
75283: LD_ADDR_VAR 0 30
75287: PUSH
75288: LD_VAR 0 30
75292: PUSH
75293: LD_VAR 0 4
75297: PUSH
75298: LD_VAR 0 7
75302: ARRAY
75303: UNION
75304: ST_TO_ADDR
// if group [ i ] in to_heal then
75305: LD_VAR 0 4
75309: PUSH
75310: LD_VAR 0 7
75314: ARRAY
75315: PUSH
75316: LD_VAR 0 30
75320: IN
75321: IFFALSE 75430
// begin if GetLives ( group [ i ] ) = 1000 then
75323: LD_VAR 0 4
75327: PUSH
75328: LD_VAR 0 7
75332: ARRAY
75333: PPUSH
75334: CALL_OW 256
75338: PUSH
75339: LD_INT 1000
75341: EQUAL
75342: IFFALSE 75368
// to_heal := to_heal diff group [ i ] else
75344: LD_ADDR_VAR 0 30
75348: PUSH
75349: LD_VAR 0 30
75353: PUSH
75354: LD_VAR 0 4
75358: PUSH
75359: LD_VAR 0 7
75363: ARRAY
75364: DIFF
75365: ST_TO_ADDR
75366: GO 75430
// begin if not IsInArea ( group [ i ] , to_heal ) then
75368: LD_VAR 0 4
75372: PUSH
75373: LD_VAR 0 7
75377: ARRAY
75378: PPUSH
75379: LD_VAR 0 30
75383: PPUSH
75384: CALL_OW 308
75388: NOT
75389: IFFALSE 75413
// ComMoveToArea ( group [ i ] , f_heal ) else
75391: LD_VAR 0 4
75395: PUSH
75396: LD_VAR 0 7
75400: ARRAY
75401: PPUSH
75402: LD_VAR 0 23
75406: PPUSH
75407: CALL_OW 113
75411: GO 75428
// ComHold ( group [ i ] ) ;
75413: LD_VAR 0 4
75417: PUSH
75418: LD_VAR 0 7
75422: ARRAY
75423: PPUSH
75424: CALL_OW 140
// continue ;
75428: GO 74272
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
75430: LD_VAR 0 4
75434: PUSH
75435: LD_VAR 0 7
75439: ARRAY
75440: PPUSH
75441: LD_INT 10
75443: PPUSH
75444: CALL 50888 0 2
75448: NOT
75449: PUSH
75450: LD_VAR 0 16
75454: PUSH
75455: LD_VAR 0 7
75459: ARRAY
75460: PUSH
75461: EMPTY
75462: EQUAL
75463: NOT
75464: AND
75465: IFFALSE 75731
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
75467: LD_VAR 0 4
75471: PUSH
75472: LD_VAR 0 7
75476: ARRAY
75477: PPUSH
75478: CALL_OW 262
75482: PUSH
75483: LD_INT 1
75485: PUSH
75486: LD_INT 2
75488: PUSH
75489: EMPTY
75490: LIST
75491: LIST
75492: IN
75493: IFFALSE 75534
// if GetFuel ( group [ i ] ) < 10 then
75495: LD_VAR 0 4
75499: PUSH
75500: LD_VAR 0 7
75504: ARRAY
75505: PPUSH
75506: CALL_OW 261
75510: PUSH
75511: LD_INT 10
75513: LESS
75514: IFFALSE 75534
// SetFuel ( group [ i ] , 12 ) ;
75516: LD_VAR 0 4
75520: PUSH
75521: LD_VAR 0 7
75525: ARRAY
75526: PPUSH
75527: LD_INT 12
75529: PPUSH
75530: CALL_OW 240
// if units_path [ i ] then
75534: LD_VAR 0 16
75538: PUSH
75539: LD_VAR 0 7
75543: ARRAY
75544: IFFALSE 75729
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
75546: LD_VAR 0 4
75550: PUSH
75551: LD_VAR 0 7
75555: ARRAY
75556: PPUSH
75557: LD_VAR 0 16
75561: PUSH
75562: LD_VAR 0 7
75566: ARRAY
75567: PUSH
75568: LD_INT 1
75570: ARRAY
75571: PUSH
75572: LD_INT 1
75574: ARRAY
75575: PPUSH
75576: LD_VAR 0 16
75580: PUSH
75581: LD_VAR 0 7
75585: ARRAY
75586: PUSH
75587: LD_INT 1
75589: ARRAY
75590: PUSH
75591: LD_INT 2
75593: ARRAY
75594: PPUSH
75595: CALL_OW 297
75599: PUSH
75600: LD_INT 6
75602: GREATER
75603: IFFALSE 75678
// begin if not HasTask ( group [ i ] ) then
75605: LD_VAR 0 4
75609: PUSH
75610: LD_VAR 0 7
75614: ARRAY
75615: PPUSH
75616: CALL_OW 314
75620: NOT
75621: IFFALSE 75676
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
75623: LD_VAR 0 4
75627: PUSH
75628: LD_VAR 0 7
75632: ARRAY
75633: PPUSH
75634: LD_VAR 0 16
75638: PUSH
75639: LD_VAR 0 7
75643: ARRAY
75644: PUSH
75645: LD_INT 1
75647: ARRAY
75648: PUSH
75649: LD_INT 1
75651: ARRAY
75652: PPUSH
75653: LD_VAR 0 16
75657: PUSH
75658: LD_VAR 0 7
75662: ARRAY
75663: PUSH
75664: LD_INT 1
75666: ARRAY
75667: PUSH
75668: LD_INT 2
75670: ARRAY
75671: PPUSH
75672: CALL_OW 114
// end else
75676: GO 75729
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
75678: LD_ADDR_VAR 0 15
75682: PUSH
75683: LD_VAR 0 16
75687: PUSH
75688: LD_VAR 0 7
75692: ARRAY
75693: PPUSH
75694: LD_INT 1
75696: PPUSH
75697: CALL_OW 3
75701: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
75702: LD_ADDR_VAR 0 16
75706: PUSH
75707: LD_VAR 0 16
75711: PPUSH
75712: LD_VAR 0 7
75716: PPUSH
75717: LD_VAR 0 15
75721: PPUSH
75722: CALL_OW 1
75726: ST_TO_ADDR
// continue ;
75727: GO 74272
// end ; end ; end else
75729: GO 78393
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
75731: LD_ADDR_VAR 0 14
75735: PUSH
75736: LD_INT 81
75738: PUSH
75739: LD_VAR 0 4
75743: PUSH
75744: LD_VAR 0 7
75748: ARRAY
75749: PPUSH
75750: CALL_OW 255
75754: PUSH
75755: EMPTY
75756: LIST
75757: LIST
75758: PPUSH
75759: CALL_OW 69
75763: ST_TO_ADDR
// if not tmp then
75764: LD_VAR 0 14
75768: NOT
75769: IFFALSE 75773
// continue ;
75771: GO 74272
// if f_ignore_area then
75773: LD_VAR 0 17
75777: IFFALSE 75865
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
75779: LD_ADDR_VAR 0 15
75783: PUSH
75784: LD_VAR 0 14
75788: PPUSH
75789: LD_INT 3
75791: PUSH
75792: LD_INT 92
75794: PUSH
75795: LD_VAR 0 17
75799: PUSH
75800: LD_INT 1
75802: ARRAY
75803: PUSH
75804: LD_VAR 0 17
75808: PUSH
75809: LD_INT 2
75811: ARRAY
75812: PUSH
75813: LD_VAR 0 17
75817: PUSH
75818: LD_INT 3
75820: ARRAY
75821: PUSH
75822: EMPTY
75823: LIST
75824: LIST
75825: LIST
75826: LIST
75827: PUSH
75828: EMPTY
75829: LIST
75830: LIST
75831: PPUSH
75832: CALL_OW 72
75836: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
75837: LD_VAR 0 14
75841: PUSH
75842: LD_VAR 0 15
75846: DIFF
75847: IFFALSE 75865
// tmp := tmp diff tmp2 ;
75849: LD_ADDR_VAR 0 14
75853: PUSH
75854: LD_VAR 0 14
75858: PUSH
75859: LD_VAR 0 15
75863: DIFF
75864: ST_TO_ADDR
// end ; if not f_murder then
75865: LD_VAR 0 20
75869: NOT
75870: IFFALSE 75928
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
75872: LD_ADDR_VAR 0 15
75876: PUSH
75877: LD_VAR 0 14
75881: PPUSH
75882: LD_INT 3
75884: PUSH
75885: LD_INT 50
75887: PUSH
75888: EMPTY
75889: LIST
75890: PUSH
75891: EMPTY
75892: LIST
75893: LIST
75894: PPUSH
75895: CALL_OW 72
75899: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
75900: LD_VAR 0 14
75904: PUSH
75905: LD_VAR 0 15
75909: DIFF
75910: IFFALSE 75928
// tmp := tmp diff tmp2 ;
75912: LD_ADDR_VAR 0 14
75916: PUSH
75917: LD_VAR 0 14
75921: PUSH
75922: LD_VAR 0 15
75926: DIFF
75927: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
75928: LD_ADDR_VAR 0 14
75932: PUSH
75933: LD_VAR 0 4
75937: PUSH
75938: LD_VAR 0 7
75942: ARRAY
75943: PPUSH
75944: LD_VAR 0 14
75948: PPUSH
75949: LD_INT 1
75951: PPUSH
75952: LD_INT 1
75954: PPUSH
75955: CALL 24531 0 4
75959: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
75960: LD_VAR 0 4
75964: PUSH
75965: LD_VAR 0 7
75969: ARRAY
75970: PPUSH
75971: CALL_OW 257
75975: PUSH
75976: LD_INT 1
75978: EQUAL
75979: IFFALSE 76427
// begin if WantPlant ( group [ i ] ) then
75981: LD_VAR 0 4
75985: PUSH
75986: LD_VAR 0 7
75990: ARRAY
75991: PPUSH
75992: CALL 24032 0 1
75996: IFFALSE 76000
// continue ;
75998: GO 74272
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
76000: LD_VAR 0 18
76004: PUSH
76005: LD_VAR 0 4
76009: PUSH
76010: LD_VAR 0 7
76014: ARRAY
76015: PPUSH
76016: CALL_OW 310
76020: NOT
76021: AND
76022: PUSH
76023: LD_VAR 0 14
76027: PUSH
76028: LD_INT 1
76030: ARRAY
76031: PUSH
76032: LD_VAR 0 14
76036: PPUSH
76037: LD_INT 21
76039: PUSH
76040: LD_INT 2
76042: PUSH
76043: EMPTY
76044: LIST
76045: LIST
76046: PUSH
76047: LD_INT 58
76049: PUSH
76050: EMPTY
76051: LIST
76052: PUSH
76053: EMPTY
76054: LIST
76055: LIST
76056: PPUSH
76057: CALL_OW 72
76061: IN
76062: AND
76063: IFFALSE 76099
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
76065: LD_VAR 0 4
76069: PUSH
76070: LD_VAR 0 7
76074: ARRAY
76075: PPUSH
76076: LD_VAR 0 14
76080: PUSH
76081: LD_INT 1
76083: ARRAY
76084: PPUSH
76085: CALL_OW 120
// attacking := true ;
76089: LD_ADDR_VAR 0 29
76093: PUSH
76094: LD_INT 1
76096: ST_TO_ADDR
// continue ;
76097: GO 74272
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
76099: LD_VAR 0 26
76103: PUSH
76104: LD_VAR 0 4
76108: PUSH
76109: LD_VAR 0 7
76113: ARRAY
76114: PPUSH
76115: CALL_OW 257
76119: PUSH
76120: LD_INT 1
76122: EQUAL
76123: AND
76124: PUSH
76125: LD_VAR 0 4
76129: PUSH
76130: LD_VAR 0 7
76134: ARRAY
76135: PPUSH
76136: CALL_OW 256
76140: PUSH
76141: LD_INT 800
76143: LESS
76144: AND
76145: PUSH
76146: LD_VAR 0 4
76150: PUSH
76151: LD_VAR 0 7
76155: ARRAY
76156: PPUSH
76157: CALL_OW 318
76161: NOT
76162: AND
76163: IFFALSE 76180
// ComCrawl ( group [ i ] ) ;
76165: LD_VAR 0 4
76169: PUSH
76170: LD_VAR 0 7
76174: ARRAY
76175: PPUSH
76176: CALL_OW 137
// if f_mines then
76180: LD_VAR 0 21
76184: IFFALSE 76427
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
76186: LD_VAR 0 14
76190: PUSH
76191: LD_INT 1
76193: ARRAY
76194: PPUSH
76195: CALL_OW 247
76199: PUSH
76200: LD_INT 3
76202: EQUAL
76203: PUSH
76204: LD_VAR 0 14
76208: PUSH
76209: LD_INT 1
76211: ARRAY
76212: PUSH
76213: LD_VAR 0 27
76217: IN
76218: NOT
76219: AND
76220: IFFALSE 76427
// begin x := GetX ( tmp [ 1 ] ) ;
76222: LD_ADDR_VAR 0 10
76226: PUSH
76227: LD_VAR 0 14
76231: PUSH
76232: LD_INT 1
76234: ARRAY
76235: PPUSH
76236: CALL_OW 250
76240: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
76241: LD_ADDR_VAR 0 11
76245: PUSH
76246: LD_VAR 0 14
76250: PUSH
76251: LD_INT 1
76253: ARRAY
76254: PPUSH
76255: CALL_OW 251
76259: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
76260: LD_ADDR_VAR 0 12
76264: PUSH
76265: LD_VAR 0 4
76269: PUSH
76270: LD_VAR 0 7
76274: ARRAY
76275: PPUSH
76276: CALL 50973 0 1
76280: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
76281: LD_VAR 0 4
76285: PUSH
76286: LD_VAR 0 7
76290: ARRAY
76291: PPUSH
76292: LD_VAR 0 10
76296: PPUSH
76297: LD_VAR 0 11
76301: PPUSH
76302: LD_VAR 0 14
76306: PUSH
76307: LD_INT 1
76309: ARRAY
76310: PPUSH
76311: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
76315: LD_VAR 0 4
76319: PUSH
76320: LD_VAR 0 7
76324: ARRAY
76325: PPUSH
76326: LD_VAR 0 10
76330: PPUSH
76331: LD_VAR 0 12
76335: PPUSH
76336: LD_INT 7
76338: PPUSH
76339: CALL_OW 272
76343: PPUSH
76344: LD_VAR 0 11
76348: PPUSH
76349: LD_VAR 0 12
76353: PPUSH
76354: LD_INT 7
76356: PPUSH
76357: CALL_OW 273
76361: PPUSH
76362: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
76366: LD_VAR 0 4
76370: PUSH
76371: LD_VAR 0 7
76375: ARRAY
76376: PPUSH
76377: LD_INT 71
76379: PPUSH
76380: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
76384: LD_ADDR_VAR 0 27
76388: PUSH
76389: LD_VAR 0 27
76393: PPUSH
76394: LD_VAR 0 27
76398: PUSH
76399: LD_INT 1
76401: PLUS
76402: PPUSH
76403: LD_VAR 0 14
76407: PUSH
76408: LD_INT 1
76410: ARRAY
76411: PPUSH
76412: CALL_OW 1
76416: ST_TO_ADDR
// attacking := true ;
76417: LD_ADDR_VAR 0 29
76421: PUSH
76422: LD_INT 1
76424: ST_TO_ADDR
// continue ;
76425: GO 74272
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
76427: LD_VAR 0 4
76431: PUSH
76432: LD_VAR 0 7
76436: ARRAY
76437: PPUSH
76438: CALL_OW 257
76442: PUSH
76443: LD_INT 17
76445: EQUAL
76446: PUSH
76447: LD_VAR 0 4
76451: PUSH
76452: LD_VAR 0 7
76456: ARRAY
76457: PPUSH
76458: CALL_OW 110
76462: PUSH
76463: LD_INT 71
76465: EQUAL
76466: NOT
76467: AND
76468: IFFALSE 76614
// begin attacking := false ;
76470: LD_ADDR_VAR 0 29
76474: PUSH
76475: LD_INT 0
76477: ST_TO_ADDR
// k := 5 ;
76478: LD_ADDR_VAR 0 9
76482: PUSH
76483: LD_INT 5
76485: ST_TO_ADDR
// if tmp < k then
76486: LD_VAR 0 14
76490: PUSH
76491: LD_VAR 0 9
76495: LESS
76496: IFFALSE 76508
// k := tmp ;
76498: LD_ADDR_VAR 0 9
76502: PUSH
76503: LD_VAR 0 14
76507: ST_TO_ADDR
// for j = 1 to k do
76508: LD_ADDR_VAR 0 8
76512: PUSH
76513: DOUBLE
76514: LD_INT 1
76516: DEC
76517: ST_TO_ADDR
76518: LD_VAR 0 9
76522: PUSH
76523: FOR_TO
76524: IFFALSE 76612
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
76526: LD_VAR 0 14
76530: PUSH
76531: LD_VAR 0 8
76535: ARRAY
76536: PUSH
76537: LD_VAR 0 14
76541: PPUSH
76542: LD_INT 58
76544: PUSH
76545: EMPTY
76546: LIST
76547: PPUSH
76548: CALL_OW 72
76552: IN
76553: NOT
76554: IFFALSE 76610
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
76556: LD_VAR 0 4
76560: PUSH
76561: LD_VAR 0 7
76565: ARRAY
76566: PPUSH
76567: LD_VAR 0 14
76571: PUSH
76572: LD_VAR 0 8
76576: ARRAY
76577: PPUSH
76578: CALL_OW 115
// attacking := true ;
76582: LD_ADDR_VAR 0 29
76586: PUSH
76587: LD_INT 1
76589: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
76590: LD_VAR 0 4
76594: PUSH
76595: LD_VAR 0 7
76599: ARRAY
76600: PPUSH
76601: LD_INT 71
76603: PPUSH
76604: CALL_OW 109
// continue ;
76608: GO 76523
// end ; end ;
76610: GO 76523
76612: POP
76613: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
76614: LD_VAR 0 4
76618: PUSH
76619: LD_VAR 0 7
76623: ARRAY
76624: PPUSH
76625: CALL_OW 257
76629: PUSH
76630: LD_INT 8
76632: EQUAL
76633: PUSH
76634: LD_VAR 0 4
76638: PUSH
76639: LD_VAR 0 7
76643: ARRAY
76644: PPUSH
76645: CALL_OW 264
76649: PUSH
76650: LD_INT 28
76652: PUSH
76653: LD_INT 45
76655: PUSH
76656: LD_INT 7
76658: PUSH
76659: LD_INT 47
76661: PUSH
76662: EMPTY
76663: LIST
76664: LIST
76665: LIST
76666: LIST
76667: IN
76668: OR
76669: IFFALSE 76925
// begin attacking := false ;
76671: LD_ADDR_VAR 0 29
76675: PUSH
76676: LD_INT 0
76678: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
76679: LD_VAR 0 14
76683: PUSH
76684: LD_INT 1
76686: ARRAY
76687: PPUSH
76688: CALL_OW 266
76692: PUSH
76693: LD_INT 32
76695: PUSH
76696: LD_INT 31
76698: PUSH
76699: LD_INT 33
76701: PUSH
76702: LD_INT 4
76704: PUSH
76705: LD_INT 5
76707: PUSH
76708: EMPTY
76709: LIST
76710: LIST
76711: LIST
76712: LIST
76713: LIST
76714: IN
76715: IFFALSE 76901
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
76717: LD_ADDR_VAR 0 9
76721: PUSH
76722: LD_VAR 0 14
76726: PUSH
76727: LD_INT 1
76729: ARRAY
76730: PPUSH
76731: CALL_OW 266
76735: PPUSH
76736: LD_VAR 0 14
76740: PUSH
76741: LD_INT 1
76743: ARRAY
76744: PPUSH
76745: CALL_OW 250
76749: PPUSH
76750: LD_VAR 0 14
76754: PUSH
76755: LD_INT 1
76757: ARRAY
76758: PPUSH
76759: CALL_OW 251
76763: PPUSH
76764: LD_VAR 0 14
76768: PUSH
76769: LD_INT 1
76771: ARRAY
76772: PPUSH
76773: CALL_OW 254
76777: PPUSH
76778: LD_VAR 0 14
76782: PUSH
76783: LD_INT 1
76785: ARRAY
76786: PPUSH
76787: CALL_OW 248
76791: PPUSH
76792: LD_INT 0
76794: PPUSH
76795: CALL 32343 0 6
76799: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
76800: LD_ADDR_VAR 0 8
76804: PUSH
76805: LD_VAR 0 4
76809: PUSH
76810: LD_VAR 0 7
76814: ARRAY
76815: PPUSH
76816: LD_VAR 0 9
76820: PPUSH
76821: CALL 51013 0 2
76825: ST_TO_ADDR
// if j then
76826: LD_VAR 0 8
76830: IFFALSE 76899
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
76832: LD_VAR 0 8
76836: PUSH
76837: LD_INT 1
76839: ARRAY
76840: PPUSH
76841: LD_VAR 0 8
76845: PUSH
76846: LD_INT 2
76848: ARRAY
76849: PPUSH
76850: CALL_OW 488
76854: IFFALSE 76899
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
76856: LD_VAR 0 4
76860: PUSH
76861: LD_VAR 0 7
76865: ARRAY
76866: PPUSH
76867: LD_VAR 0 8
76871: PUSH
76872: LD_INT 1
76874: ARRAY
76875: PPUSH
76876: LD_VAR 0 8
76880: PUSH
76881: LD_INT 2
76883: ARRAY
76884: PPUSH
76885: CALL_OW 116
// attacking := true ;
76889: LD_ADDR_VAR 0 29
76893: PUSH
76894: LD_INT 1
76896: ST_TO_ADDR
// continue ;
76897: GO 74272
// end ; end else
76899: GO 76925
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
76901: LD_VAR 0 4
76905: PUSH
76906: LD_VAR 0 7
76910: ARRAY
76911: PPUSH
76912: LD_VAR 0 14
76916: PUSH
76917: LD_INT 1
76919: ARRAY
76920: PPUSH
76921: CALL_OW 115
// end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
76925: LD_VAR 0 4
76929: PUSH
76930: LD_VAR 0 7
76934: ARRAY
76935: PPUSH
76936: CALL_OW 265
76940: PUSH
76941: LD_INT 11
76943: EQUAL
76944: IFFALSE 77222
// begin k := 10 ;
76946: LD_ADDR_VAR 0 9
76950: PUSH
76951: LD_INT 10
76953: ST_TO_ADDR
// x := 0 ;
76954: LD_ADDR_VAR 0 10
76958: PUSH
76959: LD_INT 0
76961: ST_TO_ADDR
// if tmp < k then
76962: LD_VAR 0 14
76966: PUSH
76967: LD_VAR 0 9
76971: LESS
76972: IFFALSE 76984
// k := tmp ;
76974: LD_ADDR_VAR 0 9
76978: PUSH
76979: LD_VAR 0 14
76983: ST_TO_ADDR
// for j = k downto 1 do
76984: LD_ADDR_VAR 0 8
76988: PUSH
76989: DOUBLE
76990: LD_VAR 0 9
76994: INC
76995: ST_TO_ADDR
76996: LD_INT 1
76998: PUSH
76999: FOR_DOWNTO
77000: IFFALSE 77075
// begin if GetType ( tmp [ j ] ) = unit_human then
77002: LD_VAR 0 14
77006: PUSH
77007: LD_VAR 0 8
77011: ARRAY
77012: PPUSH
77013: CALL_OW 247
77017: PUSH
77018: LD_INT 1
77020: EQUAL
77021: IFFALSE 77073
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
77023: LD_VAR 0 4
77027: PUSH
77028: LD_VAR 0 7
77032: ARRAY
77033: PPUSH
77034: LD_VAR 0 14
77038: PUSH
77039: LD_VAR 0 8
77043: ARRAY
77044: PPUSH
77045: CALL 51284 0 2
// x := tmp [ j ] ;
77049: LD_ADDR_VAR 0 10
77053: PUSH
77054: LD_VAR 0 14
77058: PUSH
77059: LD_VAR 0 8
77063: ARRAY
77064: ST_TO_ADDR
// attacking := true ;
77065: LD_ADDR_VAR 0 29
77069: PUSH
77070: LD_INT 1
77072: ST_TO_ADDR
// end ; end ;
77073: GO 76999
77075: POP
77076: POP
// if not x then
77077: LD_VAR 0 10
77081: NOT
77082: IFFALSE 77222
// begin attacking := true ;
77084: LD_ADDR_VAR 0 29
77088: PUSH
77089: LD_INT 1
77091: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
77092: LD_VAR 0 4
77096: PUSH
77097: LD_VAR 0 7
77101: ARRAY
77102: PPUSH
77103: CALL_OW 250
77107: PPUSH
77108: LD_VAR 0 4
77112: PUSH
77113: LD_VAR 0 7
77117: ARRAY
77118: PPUSH
77119: CALL_OW 251
77123: PPUSH
77124: CALL_OW 546
77128: PUSH
77129: LD_INT 2
77131: ARRAY
77132: PUSH
77133: LD_VAR 0 14
77137: PUSH
77138: LD_INT 1
77140: ARRAY
77141: PPUSH
77142: CALL_OW 250
77146: PPUSH
77147: LD_VAR 0 14
77151: PUSH
77152: LD_INT 1
77154: ARRAY
77155: PPUSH
77156: CALL_OW 251
77160: PPUSH
77161: CALL_OW 546
77165: PUSH
77166: LD_INT 2
77168: ARRAY
77169: EQUAL
77170: IFFALSE 77198
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
77172: LD_VAR 0 4
77176: PUSH
77177: LD_VAR 0 7
77181: ARRAY
77182: PPUSH
77183: LD_VAR 0 14
77187: PUSH
77188: LD_INT 1
77190: ARRAY
77191: PPUSH
77192: CALL 51284 0 2
77196: GO 77222
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
77198: LD_VAR 0 4
77202: PUSH
77203: LD_VAR 0 7
77207: ARRAY
77208: PPUSH
77209: LD_VAR 0 14
77213: PUSH
77214: LD_INT 1
77216: ARRAY
77217: PPUSH
77218: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
77222: LD_VAR 0 4
77226: PUSH
77227: LD_VAR 0 7
77231: ARRAY
77232: PPUSH
77233: CALL_OW 264
77237: PUSH
77238: LD_INT 29
77240: EQUAL
77241: IFFALSE 77607
// begin if WantsToAttack ( group [ i ] ) in bombed then
77243: LD_VAR 0 4
77247: PUSH
77248: LD_VAR 0 7
77252: ARRAY
77253: PPUSH
77254: CALL_OW 319
77258: PUSH
77259: LD_VAR 0 28
77263: IN
77264: IFFALSE 77268
// continue ;
77266: GO 74272
// k := 8 ;
77268: LD_ADDR_VAR 0 9
77272: PUSH
77273: LD_INT 8
77275: ST_TO_ADDR
// x := 0 ;
77276: LD_ADDR_VAR 0 10
77280: PUSH
77281: LD_INT 0
77283: ST_TO_ADDR
// if tmp < k then
77284: LD_VAR 0 14
77288: PUSH
77289: LD_VAR 0 9
77293: LESS
77294: IFFALSE 77306
// k := tmp ;
77296: LD_ADDR_VAR 0 9
77300: PUSH
77301: LD_VAR 0 14
77305: ST_TO_ADDR
// for j = 1 to k do
77306: LD_ADDR_VAR 0 8
77310: PUSH
77311: DOUBLE
77312: LD_INT 1
77314: DEC
77315: ST_TO_ADDR
77316: LD_VAR 0 9
77320: PUSH
77321: FOR_TO
77322: IFFALSE 77454
// begin if GetType ( tmp [ j ] ) = unit_building then
77324: LD_VAR 0 14
77328: PUSH
77329: LD_VAR 0 8
77333: ARRAY
77334: PPUSH
77335: CALL_OW 247
77339: PUSH
77340: LD_INT 3
77342: EQUAL
77343: IFFALSE 77452
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
77345: LD_VAR 0 14
77349: PUSH
77350: LD_VAR 0 8
77354: ARRAY
77355: PUSH
77356: LD_VAR 0 28
77360: IN
77361: NOT
77362: PUSH
77363: LD_VAR 0 14
77367: PUSH
77368: LD_VAR 0 8
77372: ARRAY
77373: PPUSH
77374: CALL_OW 313
77378: AND
77379: IFFALSE 77452
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
77381: LD_VAR 0 4
77385: PUSH
77386: LD_VAR 0 7
77390: ARRAY
77391: PPUSH
77392: LD_VAR 0 14
77396: PUSH
77397: LD_VAR 0 8
77401: ARRAY
77402: PPUSH
77403: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
77407: LD_ADDR_VAR 0 28
77411: PUSH
77412: LD_VAR 0 28
77416: PPUSH
77417: LD_VAR 0 28
77421: PUSH
77422: LD_INT 1
77424: PLUS
77425: PPUSH
77426: LD_VAR 0 14
77430: PUSH
77431: LD_VAR 0 8
77435: ARRAY
77436: PPUSH
77437: CALL_OW 1
77441: ST_TO_ADDR
// attacking := true ;
77442: LD_ADDR_VAR 0 29
77446: PUSH
77447: LD_INT 1
77449: ST_TO_ADDR
// break ;
77450: GO 77454
// end ; end ;
77452: GO 77321
77454: POP
77455: POP
// if not attacking and f_attack_depot then
77456: LD_VAR 0 29
77460: NOT
77461: PUSH
77462: LD_VAR 0 25
77466: AND
77467: IFFALSE 77562
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
77469: LD_ADDR_VAR 0 13
77473: PUSH
77474: LD_VAR 0 14
77478: PPUSH
77479: LD_INT 2
77481: PUSH
77482: LD_INT 30
77484: PUSH
77485: LD_INT 0
77487: PUSH
77488: EMPTY
77489: LIST
77490: LIST
77491: PUSH
77492: LD_INT 30
77494: PUSH
77495: LD_INT 1
77497: PUSH
77498: EMPTY
77499: LIST
77500: LIST
77501: PUSH
77502: EMPTY
77503: LIST
77504: LIST
77505: LIST
77506: PPUSH
77507: CALL_OW 72
77511: ST_TO_ADDR
// if z then
77512: LD_VAR 0 13
77516: IFFALSE 77562
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
77518: LD_VAR 0 4
77522: PUSH
77523: LD_VAR 0 7
77527: ARRAY
77528: PPUSH
77529: LD_VAR 0 13
77533: PPUSH
77534: LD_VAR 0 4
77538: PUSH
77539: LD_VAR 0 7
77543: ARRAY
77544: PPUSH
77545: CALL_OW 74
77549: PPUSH
77550: CALL_OW 115
// attacking := true ;
77554: LD_ADDR_VAR 0 29
77558: PUSH
77559: LD_INT 1
77561: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
77562: LD_VAR 0 4
77566: PUSH
77567: LD_VAR 0 7
77571: ARRAY
77572: PPUSH
77573: CALL_OW 256
77577: PUSH
77578: LD_INT 500
77580: LESS
77581: IFFALSE 77607
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
77583: LD_VAR 0 4
77587: PUSH
77588: LD_VAR 0 7
77592: ARRAY
77593: PPUSH
77594: LD_VAR 0 14
77598: PUSH
77599: LD_INT 1
77601: ARRAY
77602: PPUSH
77603: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
77607: LD_VAR 0 4
77611: PUSH
77612: LD_VAR 0 7
77616: ARRAY
77617: PPUSH
77618: CALL_OW 264
77622: PUSH
77623: LD_INT 49
77625: EQUAL
77626: IFFALSE 77747
// begin if not HasTask ( group [ i ] ) then
77628: LD_VAR 0 4
77632: PUSH
77633: LD_VAR 0 7
77637: ARRAY
77638: PPUSH
77639: CALL_OW 314
77643: NOT
77644: IFFALSE 77747
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
77646: LD_ADDR_VAR 0 9
77650: PUSH
77651: LD_INT 81
77653: PUSH
77654: LD_VAR 0 4
77658: PUSH
77659: LD_VAR 0 7
77663: ARRAY
77664: PPUSH
77665: CALL_OW 255
77669: PUSH
77670: EMPTY
77671: LIST
77672: LIST
77673: PPUSH
77674: CALL_OW 69
77678: PPUSH
77679: LD_VAR 0 4
77683: PUSH
77684: LD_VAR 0 7
77688: ARRAY
77689: PPUSH
77690: CALL_OW 74
77694: ST_TO_ADDR
// if k then
77695: LD_VAR 0 9
77699: IFFALSE 77747
// if GetDistUnits ( group [ i ] , k ) > 10 then
77701: LD_VAR 0 4
77705: PUSH
77706: LD_VAR 0 7
77710: ARRAY
77711: PPUSH
77712: LD_VAR 0 9
77716: PPUSH
77717: CALL_OW 296
77721: PUSH
77722: LD_INT 10
77724: GREATER
77725: IFFALSE 77747
// ComMoveUnit ( group [ i ] , k ) ;
77727: LD_VAR 0 4
77731: PUSH
77732: LD_VAR 0 7
77736: ARRAY
77737: PPUSH
77738: LD_VAR 0 9
77742: PPUSH
77743: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
77747: LD_VAR 0 4
77751: PUSH
77752: LD_VAR 0 7
77756: ARRAY
77757: PPUSH
77758: CALL_OW 256
77762: PUSH
77763: LD_INT 250
77765: LESS
77766: PUSH
77767: LD_VAR 0 4
77771: PUSH
77772: LD_VAR 0 7
77776: ARRAY
77777: PUSH
77778: LD_INT 21
77780: PUSH
77781: LD_INT 2
77783: PUSH
77784: EMPTY
77785: LIST
77786: LIST
77787: PUSH
77788: LD_INT 23
77790: PUSH
77791: LD_INT 2
77793: PUSH
77794: EMPTY
77795: LIST
77796: LIST
77797: PUSH
77798: EMPTY
77799: LIST
77800: LIST
77801: PPUSH
77802: CALL_OW 69
77806: IN
77807: AND
77808: IFFALSE 77933
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
77810: LD_ADDR_VAR 0 9
77814: PUSH
77815: LD_OWVAR 3
77819: PUSH
77820: LD_VAR 0 4
77824: PUSH
77825: LD_VAR 0 7
77829: ARRAY
77830: DIFF
77831: PPUSH
77832: LD_VAR 0 4
77836: PUSH
77837: LD_VAR 0 7
77841: ARRAY
77842: PPUSH
77843: CALL_OW 74
77847: ST_TO_ADDR
// if not k then
77848: LD_VAR 0 9
77852: NOT
77853: IFFALSE 77857
// continue ;
77855: GO 74272
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
77857: LD_VAR 0 9
77861: PUSH
77862: LD_INT 81
77864: PUSH
77865: LD_VAR 0 4
77869: PUSH
77870: LD_VAR 0 7
77874: ARRAY
77875: PPUSH
77876: CALL_OW 255
77880: PUSH
77881: EMPTY
77882: LIST
77883: LIST
77884: PPUSH
77885: CALL_OW 69
77889: IN
77890: PUSH
77891: LD_VAR 0 9
77895: PPUSH
77896: LD_VAR 0 4
77900: PUSH
77901: LD_VAR 0 7
77905: ARRAY
77906: PPUSH
77907: CALL_OW 296
77911: PUSH
77912: LD_INT 5
77914: LESS
77915: AND
77916: IFFALSE 77933
// ComAutodestruct ( group [ i ] ) ;
77918: LD_VAR 0 4
77922: PUSH
77923: LD_VAR 0 7
77927: ARRAY
77928: PPUSH
77929: CALL 51182 0 1
// end ; if f_attack_depot then
77933: LD_VAR 0 25
77937: IFFALSE 78049
// begin k := 6 ;
77939: LD_ADDR_VAR 0 9
77943: PUSH
77944: LD_INT 6
77946: ST_TO_ADDR
// if tmp < k then
77947: LD_VAR 0 14
77951: PUSH
77952: LD_VAR 0 9
77956: LESS
77957: IFFALSE 77969
// k := tmp ;
77959: LD_ADDR_VAR 0 9
77963: PUSH
77964: LD_VAR 0 14
77968: ST_TO_ADDR
// for j = 1 to k do
77969: LD_ADDR_VAR 0 8
77973: PUSH
77974: DOUBLE
77975: LD_INT 1
77977: DEC
77978: ST_TO_ADDR
77979: LD_VAR 0 9
77983: PUSH
77984: FOR_TO
77985: IFFALSE 78047
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
77987: LD_VAR 0 8
77991: PPUSH
77992: CALL_OW 266
77996: PUSH
77997: LD_INT 0
77999: PUSH
78000: LD_INT 1
78002: PUSH
78003: EMPTY
78004: LIST
78005: LIST
78006: IN
78007: IFFALSE 78045
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
78009: LD_VAR 0 4
78013: PUSH
78014: LD_VAR 0 7
78018: ARRAY
78019: PPUSH
78020: LD_VAR 0 14
78024: PUSH
78025: LD_VAR 0 8
78029: ARRAY
78030: PPUSH
78031: CALL_OW 115
// attacking := true ;
78035: LD_ADDR_VAR 0 29
78039: PUSH
78040: LD_INT 1
78042: ST_TO_ADDR
// break ;
78043: GO 78047
// end ;
78045: GO 77984
78047: POP
78048: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
78049: LD_VAR 0 4
78053: PUSH
78054: LD_VAR 0 7
78058: ARRAY
78059: PPUSH
78060: CALL_OW 302
78064: PUSH
78065: LD_VAR 0 29
78069: NOT
78070: AND
78071: IFFALSE 78393
// begin if GetTag ( group [ i ] ) = 71 then
78073: LD_VAR 0 4
78077: PUSH
78078: LD_VAR 0 7
78082: ARRAY
78083: PPUSH
78084: CALL_OW 110
78088: PUSH
78089: LD_INT 71
78091: EQUAL
78092: IFFALSE 78133
// begin if HasTask ( group [ i ] ) then
78094: LD_VAR 0 4
78098: PUSH
78099: LD_VAR 0 7
78103: ARRAY
78104: PPUSH
78105: CALL_OW 314
78109: IFFALSE 78115
// continue else
78111: GO 74272
78113: GO 78133
// SetTag ( group [ i ] , 0 ) ;
78115: LD_VAR 0 4
78119: PUSH
78120: LD_VAR 0 7
78124: ARRAY
78125: PPUSH
78126: LD_INT 0
78128: PPUSH
78129: CALL_OW 109
// end ; k := 8 ;
78133: LD_ADDR_VAR 0 9
78137: PUSH
78138: LD_INT 8
78140: ST_TO_ADDR
// x := 0 ;
78141: LD_ADDR_VAR 0 10
78145: PUSH
78146: LD_INT 0
78148: ST_TO_ADDR
// if tmp < k then
78149: LD_VAR 0 14
78153: PUSH
78154: LD_VAR 0 9
78158: LESS
78159: IFFALSE 78171
// k := tmp ;
78161: LD_ADDR_VAR 0 9
78165: PUSH
78166: LD_VAR 0 14
78170: ST_TO_ADDR
// for j = 1 to k do
78171: LD_ADDR_VAR 0 8
78175: PUSH
78176: DOUBLE
78177: LD_INT 1
78179: DEC
78180: ST_TO_ADDR
78181: LD_VAR 0 9
78185: PUSH
78186: FOR_TO
78187: IFFALSE 78285
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
78189: LD_VAR 0 14
78193: PUSH
78194: LD_VAR 0 8
78198: ARRAY
78199: PPUSH
78200: CALL_OW 247
78204: PUSH
78205: LD_INT 1
78207: EQUAL
78208: PUSH
78209: LD_VAR 0 14
78213: PUSH
78214: LD_VAR 0 8
78218: ARRAY
78219: PPUSH
78220: CALL_OW 256
78224: PUSH
78225: LD_INT 250
78227: LESS
78228: PUSH
78229: LD_VAR 0 20
78233: AND
78234: PUSH
78235: LD_VAR 0 20
78239: NOT
78240: PUSH
78241: LD_VAR 0 14
78245: PUSH
78246: LD_VAR 0 8
78250: ARRAY
78251: PPUSH
78252: CALL_OW 256
78256: PUSH
78257: LD_INT 250
78259: GREATEREQUAL
78260: AND
78261: OR
78262: AND
78263: IFFALSE 78283
// begin x := tmp [ j ] ;
78265: LD_ADDR_VAR 0 10
78269: PUSH
78270: LD_VAR 0 14
78274: PUSH
78275: LD_VAR 0 8
78279: ARRAY
78280: ST_TO_ADDR
// break ;
78281: GO 78285
// end ;
78283: GO 78186
78285: POP
78286: POP
// if x then
78287: LD_VAR 0 10
78291: IFFALSE 78315
// ComAttackUnit ( group [ i ] , x ) else
78293: LD_VAR 0 4
78297: PUSH
78298: LD_VAR 0 7
78302: ARRAY
78303: PPUSH
78304: LD_VAR 0 10
78308: PPUSH
78309: CALL_OW 115
78313: GO 78339
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
78315: LD_VAR 0 4
78319: PUSH
78320: LD_VAR 0 7
78324: ARRAY
78325: PPUSH
78326: LD_VAR 0 14
78330: PUSH
78331: LD_INT 1
78333: ARRAY
78334: PPUSH
78335: CALL_OW 115
// if not HasTask ( group [ i ] ) then
78339: LD_VAR 0 4
78343: PUSH
78344: LD_VAR 0 7
78348: ARRAY
78349: PPUSH
78350: CALL_OW 314
78354: NOT
78355: IFFALSE 78393
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
78357: LD_VAR 0 4
78361: PUSH
78362: LD_VAR 0 7
78366: ARRAY
78367: PPUSH
78368: LD_VAR 0 14
78372: PPUSH
78373: LD_VAR 0 4
78377: PUSH
78378: LD_VAR 0 7
78382: ARRAY
78383: PPUSH
78384: CALL_OW 74
78388: PPUSH
78389: CALL_OW 115
// end ; end ; end ;
78393: GO 74272
78395: POP
78396: POP
// wait ( 0 0$2 ) ;
78397: LD_INT 70
78399: PPUSH
78400: CALL_OW 67
// until not group or group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
78404: LD_VAR 0 4
78408: NOT
78409: PUSH
78410: LD_VAR 0 4
78414: PUSH
78415: EMPTY
78416: EQUAL
78417: OR
78418: PUSH
78419: LD_INT 81
78421: PUSH
78422: LD_VAR 0 35
78426: PUSH
78427: EMPTY
78428: LIST
78429: LIST
78430: PPUSH
78431: CALL_OW 69
78435: NOT
78436: OR
78437: IFFALSE 74257
// end ;
78439: LD_VAR 0 2
78443: RET
// export function BasicDefend ( base , solds , area ) ; var enemy , side , i , hex ; begin
78444: LD_INT 0
78446: PPUSH
78447: PPUSH
78448: PPUSH
78449: PPUSH
78450: PPUSH
// if not base or not mc_bases [ base ] or not solds or not area then
78451: LD_VAR 0 1
78455: NOT
78456: PUSH
78457: LD_EXP 172
78461: PUSH
78462: LD_VAR 0 1
78466: ARRAY
78467: NOT
78468: OR
78469: PUSH
78470: LD_VAR 0 2
78474: NOT
78475: OR
78476: PUSH
78477: LD_VAR 0 3
78481: NOT
78482: OR
78483: IFFALSE 78487
// exit ;
78485: GO 79000
// side := mc_sides [ base ] ;
78487: LD_ADDR_VAR 0 6
78491: PUSH
78492: LD_EXP 198
78496: PUSH
78497: LD_VAR 0 1
78501: ARRAY
78502: ST_TO_ADDR
// if not side then
78503: LD_VAR 0 6
78507: NOT
78508: IFFALSE 78512
// exit ;
78510: GO 79000
// for i in solds do
78512: LD_ADDR_VAR 0 7
78516: PUSH
78517: LD_VAR 0 2
78521: PUSH
78522: FOR_IN
78523: IFFALSE 78584
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
78525: LD_VAR 0 7
78529: PPUSH
78530: CALL_OW 310
78534: PPUSH
78535: CALL_OW 266
78539: PUSH
78540: LD_INT 32
78542: PUSH
78543: LD_INT 31
78545: PUSH
78546: EMPTY
78547: LIST
78548: LIST
78549: IN
78550: IFFALSE 78570
// solds := solds diff i else
78552: LD_ADDR_VAR 0 2
78556: PUSH
78557: LD_VAR 0 2
78561: PUSH
78562: LD_VAR 0 7
78566: DIFF
78567: ST_TO_ADDR
78568: GO 78582
// SetTag ( i , 18 ) ;
78570: LD_VAR 0 7
78574: PPUSH
78575: LD_INT 18
78577: PPUSH
78578: CALL_OW 109
78582: GO 78522
78584: POP
78585: POP
// if not solds then
78586: LD_VAR 0 2
78590: NOT
78591: IFFALSE 78595
// exit ;
78593: GO 79000
// repeat wait ( 0 0$2 ) ;
78595: LD_INT 70
78597: PPUSH
78598: CALL_OW 67
// enemy := ScanBase ( side , area ) ;
78602: LD_ADDR_VAR 0 5
78606: PUSH
78607: LD_VAR 0 6
78611: PPUSH
78612: LD_VAR 0 3
78616: PPUSH
78617: CALL 20897 0 2
78621: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
78622: LD_EXP 172
78626: PUSH
78627: LD_VAR 0 1
78631: ARRAY
78632: NOT
78633: PUSH
78634: LD_EXP 172
78638: PUSH
78639: LD_VAR 0 1
78643: ARRAY
78644: PUSH
78645: EMPTY
78646: EQUAL
78647: OR
78648: IFFALSE 78685
// begin for i in solds do
78650: LD_ADDR_VAR 0 7
78654: PUSH
78655: LD_VAR 0 2
78659: PUSH
78660: FOR_IN
78661: IFFALSE 78674
// ComStop ( i ) ;
78663: LD_VAR 0 7
78667: PPUSH
78668: CALL_OW 141
78672: GO 78660
78674: POP
78675: POP
// solds := [ ] ;
78676: LD_ADDR_VAR 0 2
78680: PUSH
78681: EMPTY
78682: ST_TO_ADDR
// exit ;
78683: GO 79000
// end ; if not enemy or enemy > 3 or mc_defender [ base ] then
78685: LD_VAR 0 5
78689: NOT
78690: PUSH
78691: LD_VAR 0 5
78695: PUSH
78696: LD_INT 3
78698: GREATER
78699: OR
78700: PUSH
78701: LD_EXP 194
78705: PUSH
78706: LD_VAR 0 1
78710: ARRAY
78711: OR
78712: IFFALSE 78753
// begin for i in solds do
78714: LD_ADDR_VAR 0 7
78718: PUSH
78719: LD_VAR 0 2
78723: PUSH
78724: FOR_IN
78725: IFFALSE 78749
// if HasTask ( i ) then
78727: LD_VAR 0 7
78731: PPUSH
78732: CALL_OW 314
78736: IFFALSE 78747
// ComStop ( i ) ;
78738: LD_VAR 0 7
78742: PPUSH
78743: CALL_OW 141
78747: GO 78724
78749: POP
78750: POP
// break ;
78751: GO 78988
// end ; for i in solds do
78753: LD_ADDR_VAR 0 7
78757: PUSH
78758: LD_VAR 0 2
78762: PUSH
78763: FOR_IN
78764: IFFALSE 78980
// begin if IsInUnit ( i ) then
78766: LD_VAR 0 7
78770: PPUSH
78771: CALL_OW 310
78775: IFFALSE 78786
// ComExitBuilding ( i ) ;
78777: LD_VAR 0 7
78781: PPUSH
78782: CALL_OW 122
// if GetLives ( i ) > 333 then
78786: LD_VAR 0 7
78790: PPUSH
78791: CALL_OW 256
78795: PUSH
78796: LD_INT 333
78798: GREATER
78799: IFFALSE 78827
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
78801: LD_VAR 0 7
78805: PPUSH
78806: LD_VAR 0 5
78810: PPUSH
78811: LD_VAR 0 7
78815: PPUSH
78816: CALL_OW 74
78820: PPUSH
78821: CALL_OW 115
78825: GO 78978
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
78827: LD_ADDR_VAR 0 8
78831: PUSH
78832: LD_EXP 172
78836: PUSH
78837: LD_VAR 0 1
78841: ARRAY
78842: PPUSH
78843: LD_INT 2
78845: PUSH
78846: LD_INT 30
78848: PUSH
78849: LD_INT 0
78851: PUSH
78852: EMPTY
78853: LIST
78854: LIST
78855: PUSH
78856: LD_INT 30
78858: PUSH
78859: LD_INT 1
78861: PUSH
78862: EMPTY
78863: LIST
78864: LIST
78865: PUSH
78866: LD_INT 30
78868: PUSH
78869: LD_INT 6
78871: PUSH
78872: EMPTY
78873: LIST
78874: LIST
78875: PUSH
78876: EMPTY
78877: LIST
78878: LIST
78879: LIST
78880: LIST
78881: PPUSH
78882: CALL_OW 72
78886: PPUSH
78887: LD_VAR 0 7
78891: PPUSH
78892: CALL_OW 74
78896: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
78897: LD_VAR 0 7
78901: PPUSH
78902: LD_VAR 0 8
78906: PPUSH
78907: CALL_OW 250
78911: PPUSH
78912: LD_INT 3
78914: PPUSH
78915: LD_INT 5
78917: PPUSH
78918: CALL_OW 272
78922: PPUSH
78923: LD_VAR 0 8
78927: PPUSH
78928: CALL_OW 251
78932: PPUSH
78933: LD_INT 3
78935: PPUSH
78936: LD_INT 5
78938: PPUSH
78939: CALL_OW 273
78943: PPUSH
78944: CALL_OW 111
// SetTag ( i , 0 ) ;
78948: LD_VAR 0 7
78952: PPUSH
78953: LD_INT 0
78955: PPUSH
78956: CALL_OW 109
// solds := solds diff i ;
78960: LD_ADDR_VAR 0 2
78964: PUSH
78965: LD_VAR 0 2
78969: PUSH
78970: LD_VAR 0 7
78974: DIFF
78975: ST_TO_ADDR
// continue ;
78976: GO 78763
// end ; end ;
78978: GO 78763
78980: POP
78981: POP
// until solds ;
78982: LD_VAR 0 2
78986: IFFALSE 78595
// MC_Reset ( base , 18 ) ;
78988: LD_VAR 0 1
78992: PPUSH
78993: LD_INT 18
78995: PPUSH
78996: CALL 84997 0 2
// end ;
79000: LD_VAR 0 4
79004: RET
// export function Defend ( base , defenders , enemy ) ; var i , j , x , depot , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend ; begin
79005: LD_INT 0
79007: PPUSH
79008: PPUSH
79009: PPUSH
79010: PPUSH
79011: PPUSH
79012: PPUSH
79013: PPUSH
79014: PPUSH
79015: PPUSH
79016: PPUSH
79017: PPUSH
79018: PPUSH
79019: PPUSH
79020: PPUSH
79021: PPUSH
79022: PPUSH
79023: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
79024: LD_ADDR_VAR 0 13
79028: PUSH
79029: LD_EXP 172
79033: PUSH
79034: LD_VAR 0 1
79038: ARRAY
79039: PPUSH
79040: LD_INT 25
79042: PUSH
79043: LD_INT 3
79045: PUSH
79046: EMPTY
79047: LIST
79048: LIST
79049: PPUSH
79050: CALL_OW 72
79054: ST_TO_ADDR
// if mc_remote_driver [ base ] then
79055: LD_EXP 212
79059: PUSH
79060: LD_VAR 0 1
79064: ARRAY
79065: IFFALSE 79089
// mechs := mechs diff mc_remote_driver [ base ] ;
79067: LD_ADDR_VAR 0 13
79071: PUSH
79072: LD_VAR 0 13
79076: PUSH
79077: LD_EXP 212
79081: PUSH
79082: LD_VAR 0 1
79086: ARRAY
79087: DIFF
79088: ST_TO_ADDR
// for i in mechs do
79089: LD_ADDR_VAR 0 5
79093: PUSH
79094: LD_VAR 0 13
79098: PUSH
79099: FOR_IN
79100: IFFALSE 79135
// if GetTag ( i ) > 0 then
79102: LD_VAR 0 5
79106: PPUSH
79107: CALL_OW 110
79111: PUSH
79112: LD_INT 0
79114: GREATER
79115: IFFALSE 79133
// mechs := mechs diff i ;
79117: LD_ADDR_VAR 0 13
79121: PUSH
79122: LD_VAR 0 13
79126: PUSH
79127: LD_VAR 0 5
79131: DIFF
79132: ST_TO_ADDR
79133: GO 79099
79135: POP
79136: POP
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
79137: LD_ADDR_VAR 0 9
79141: PUSH
79142: LD_EXP 172
79146: PUSH
79147: LD_VAR 0 1
79151: ARRAY
79152: PPUSH
79153: LD_INT 2
79155: PUSH
79156: LD_INT 25
79158: PUSH
79159: LD_INT 1
79161: PUSH
79162: EMPTY
79163: LIST
79164: LIST
79165: PUSH
79166: LD_INT 25
79168: PUSH
79169: LD_INT 5
79171: PUSH
79172: EMPTY
79173: LIST
79174: LIST
79175: PUSH
79176: LD_INT 25
79178: PUSH
79179: LD_INT 8
79181: PUSH
79182: EMPTY
79183: LIST
79184: LIST
79185: PUSH
79186: LD_INT 25
79188: PUSH
79189: LD_INT 9
79191: PUSH
79192: EMPTY
79193: LIST
79194: LIST
79195: PUSH
79196: EMPTY
79197: LIST
79198: LIST
79199: LIST
79200: LIST
79201: LIST
79202: PPUSH
79203: CALL_OW 72
79207: ST_TO_ADDR
// if not defenders and not solds then
79208: LD_VAR 0 2
79212: NOT
79213: PUSH
79214: LD_VAR 0 9
79218: NOT
79219: AND
79220: IFFALSE 79224
// exit ;
79222: GO 80914
// depot_under_attack := false ;
79224: LD_ADDR_VAR 0 17
79228: PUSH
79229: LD_INT 0
79231: ST_TO_ADDR
// sold_defenders := [ ] ;
79232: LD_ADDR_VAR 0 18
79236: PUSH
79237: EMPTY
79238: ST_TO_ADDR
// if mechs then
79239: LD_VAR 0 13
79243: IFFALSE 79396
// for i in UnitFilter ( defenders , [ f_type , unit_vehicle ] ) do
79245: LD_ADDR_VAR 0 5
79249: PUSH
79250: LD_VAR 0 2
79254: PPUSH
79255: LD_INT 21
79257: PUSH
79258: LD_INT 2
79260: PUSH
79261: EMPTY
79262: LIST
79263: LIST
79264: PPUSH
79265: CALL_OW 72
79269: PUSH
79270: FOR_IN
79271: IFFALSE 79394
// begin if GetTag ( i ) <> 20 then
79273: LD_VAR 0 5
79277: PPUSH
79278: CALL_OW 110
79282: PUSH
79283: LD_INT 20
79285: NONEQUAL
79286: IFFALSE 79300
// SetTag ( i , 20 ) ;
79288: LD_VAR 0 5
79292: PPUSH
79293: LD_INT 20
79295: PPUSH
79296: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) then
79300: LD_VAR 0 5
79304: PPUSH
79305: CALL_OW 263
79309: PUSH
79310: LD_INT 1
79312: EQUAL
79313: PUSH
79314: LD_VAR 0 5
79318: PPUSH
79319: CALL_OW 311
79323: NOT
79324: AND
79325: IFFALSE 79392
// begin un := mechs [ 1 ] ;
79327: LD_ADDR_VAR 0 11
79331: PUSH
79332: LD_VAR 0 13
79336: PUSH
79337: LD_INT 1
79339: ARRAY
79340: ST_TO_ADDR
// ComExit ( un ) ;
79341: LD_VAR 0 11
79345: PPUSH
79346: CALL 55527 0 1
// AddComEnterUnit ( un , i ) ;
79350: LD_VAR 0 11
79354: PPUSH
79355: LD_VAR 0 5
79359: PPUSH
79360: CALL_OW 180
// SetTag ( un , 19 ) ;
79364: LD_VAR 0 11
79368: PPUSH
79369: LD_INT 19
79371: PPUSH
79372: CALL_OW 109
// mechs := mechs diff un ;
79376: LD_ADDR_VAR 0 13
79380: PUSH
79381: LD_VAR 0 13
79385: PUSH
79386: LD_VAR 0 11
79390: DIFF
79391: ST_TO_ADDR
// end ; end ;
79392: GO 79270
79394: POP
79395: POP
// if solds then
79396: LD_VAR 0 9
79400: IFFALSE 79459
// for i in solds do
79402: LD_ADDR_VAR 0 5
79406: PUSH
79407: LD_VAR 0 9
79411: PUSH
79412: FOR_IN
79413: IFFALSE 79457
// if not GetTag ( i ) then
79415: LD_VAR 0 5
79419: PPUSH
79420: CALL_OW 110
79424: NOT
79425: IFFALSE 79455
// begin defenders := defenders union i ;
79427: LD_ADDR_VAR 0 2
79431: PUSH
79432: LD_VAR 0 2
79436: PUSH
79437: LD_VAR 0 5
79441: UNION
79442: ST_TO_ADDR
// SetTag ( i , 18 ) ;
79443: LD_VAR 0 5
79447: PPUSH
79448: LD_INT 18
79450: PPUSH
79451: CALL_OW 109
// end ;
79455: GO 79412
79457: POP
79458: POP
// repeat wait ( 0 0$2 ) ;
79459: LD_INT 70
79461: PPUSH
79462: CALL_OW 67
// enemy := mc_scan [ base ] ;
79466: LD_ADDR_VAR 0 3
79470: PUSH
79471: LD_EXP 195
79475: PUSH
79476: LD_VAR 0 1
79480: ARRAY
79481: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
79482: LD_EXP 172
79486: PUSH
79487: LD_VAR 0 1
79491: ARRAY
79492: NOT
79493: PUSH
79494: LD_EXP 172
79498: PUSH
79499: LD_VAR 0 1
79503: ARRAY
79504: PUSH
79505: EMPTY
79506: EQUAL
79507: OR
79508: IFFALSE 79545
// begin for i in defenders do
79510: LD_ADDR_VAR 0 5
79514: PUSH
79515: LD_VAR 0 2
79519: PUSH
79520: FOR_IN
79521: IFFALSE 79534
// ComStop ( i ) ;
79523: LD_VAR 0 5
79527: PPUSH
79528: CALL_OW 141
79532: GO 79520
79534: POP
79535: POP
// defenders := [ ] ;
79536: LD_ADDR_VAR 0 2
79540: PUSH
79541: EMPTY
79542: ST_TO_ADDR
// exit ;
79543: GO 80914
// end ; for i in defenders do
79545: LD_ADDR_VAR 0 5
79549: PUSH
79550: LD_VAR 0 2
79554: PUSH
79555: FOR_IN
79556: IFFALSE 80374
// begin e := NearestUnitToUnit ( enemy , i ) ;
79558: LD_ADDR_VAR 0 14
79562: PUSH
79563: LD_VAR 0 3
79567: PPUSH
79568: LD_VAR 0 5
79572: PPUSH
79573: CALL_OW 74
79577: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
79578: LD_ADDR_VAR 0 8
79582: PUSH
79583: LD_EXP 172
79587: PUSH
79588: LD_VAR 0 1
79592: ARRAY
79593: PPUSH
79594: LD_INT 2
79596: PUSH
79597: LD_INT 30
79599: PUSH
79600: LD_INT 0
79602: PUSH
79603: EMPTY
79604: LIST
79605: LIST
79606: PUSH
79607: LD_INT 30
79609: PUSH
79610: LD_INT 1
79612: PUSH
79613: EMPTY
79614: LIST
79615: LIST
79616: PUSH
79617: EMPTY
79618: LIST
79619: LIST
79620: LIST
79621: PPUSH
79622: CALL_OW 72
79626: ST_TO_ADDR
// depot_under_attack := ( not depot or UnitFilter ( depot , [ f_not , [ f_lives , 600 ] ] ) ) ;
79627: LD_ADDR_VAR 0 17
79631: PUSH
79632: LD_VAR 0 8
79636: NOT
79637: PUSH
79638: LD_VAR 0 8
79642: PPUSH
79643: LD_INT 3
79645: PUSH
79646: LD_INT 24
79648: PUSH
79649: LD_INT 600
79651: PUSH
79652: EMPTY
79653: LIST
79654: LIST
79655: PUSH
79656: EMPTY
79657: LIST
79658: LIST
79659: PPUSH
79660: CALL_OW 72
79664: OR
79665: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
79666: LD_VAR 0 5
79670: PPUSH
79671: CALL_OW 247
79675: PUSH
79676: LD_INT 2
79678: DOUBLE
79679: EQUAL
79680: IFTRUE 79684
79682: GO 80080
79684: POP
// begin if GetLives ( i ) > 650 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
79685: LD_VAR 0 5
79689: PPUSH
79690: CALL_OW 256
79694: PUSH
79695: LD_INT 650
79697: GREATER
79698: PUSH
79699: LD_VAR 0 5
79703: PPUSH
79704: LD_VAR 0 14
79708: PPUSH
79709: CALL_OW 296
79713: PUSH
79714: LD_INT 40
79716: LESS
79717: PUSH
79718: LD_VAR 0 14
79722: PPUSH
79723: LD_EXP 197
79727: PUSH
79728: LD_VAR 0 1
79732: ARRAY
79733: PPUSH
79734: CALL_OW 308
79738: OR
79739: AND
79740: IFFALSE 79862
// begin if GetEngine ( i ) = engine_combustion and GetFuel ( i ) < 30 and depot then
79742: LD_VAR 0 5
79746: PPUSH
79747: CALL_OW 262
79751: PUSH
79752: LD_INT 1
79754: EQUAL
79755: PUSH
79756: LD_VAR 0 5
79760: PPUSH
79761: CALL_OW 261
79765: PUSH
79766: LD_INT 30
79768: LESS
79769: AND
79770: PUSH
79771: LD_VAR 0 8
79775: AND
79776: IFFALSE 79846
// begin ComMoveUnit ( i , NearestUnitToUnit ( depot , i ) ) ;
79778: LD_VAR 0 5
79782: PPUSH
79783: LD_VAR 0 8
79787: PPUSH
79788: LD_VAR 0 5
79792: PPUSH
79793: CALL_OW 74
79797: PPUSH
79798: CALL_OW 112
// if GetDistUnits ( i , NearestUnitToUnit ( depot , i ) ) < 6 then
79802: LD_VAR 0 5
79806: PPUSH
79807: LD_VAR 0 8
79811: PPUSH
79812: LD_VAR 0 5
79816: PPUSH
79817: CALL_OW 74
79821: PPUSH
79822: CALL_OW 296
79826: PUSH
79827: LD_INT 6
79829: LESS
79830: IFFALSE 79844
// SetFuel ( i , 100 ) ;
79832: LD_VAR 0 5
79836: PPUSH
79837: LD_INT 100
79839: PPUSH
79840: CALL_OW 240
// end else
79844: GO 79860
// ComAttackUnit ( i , e ) ;
79846: LD_VAR 0 5
79850: PPUSH
79851: LD_VAR 0 14
79855: PPUSH
79856: CALL_OW 115
// end else
79860: GO 79963
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
79862: LD_VAR 0 14
79866: PPUSH
79867: LD_EXP 197
79871: PUSH
79872: LD_VAR 0 1
79876: ARRAY
79877: PPUSH
79878: CALL_OW 308
79882: NOT
79883: PUSH
79884: LD_VAR 0 5
79888: PPUSH
79889: LD_VAR 0 14
79893: PPUSH
79894: CALL_OW 296
79898: PUSH
79899: LD_INT 40
79901: GREATEREQUAL
79902: AND
79903: PUSH
79904: LD_VAR 0 5
79908: PPUSH
79909: CALL_OW 256
79913: PUSH
79914: LD_INT 650
79916: LESSEQUAL
79917: OR
79918: PUSH
79919: LD_VAR 0 5
79923: PPUSH
79924: LD_EXP 196
79928: PUSH
79929: LD_VAR 0 1
79933: ARRAY
79934: PPUSH
79935: CALL_OW 308
79939: NOT
79940: AND
79941: IFFALSE 79963
// ComMoveToArea ( i , mc_parking [ base ] ) ;
79943: LD_VAR 0 5
79947: PPUSH
79948: LD_EXP 196
79952: PUSH
79953: LD_VAR 0 1
79957: ARRAY
79958: PPUSH
79959: CALL_OW 113
// if GetLives ( i ) < 998 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
79963: LD_VAR 0 5
79967: PPUSH
79968: CALL_OW 256
79972: PUSH
79973: LD_INT 998
79975: LESS
79976: PUSH
79977: LD_VAR 0 5
79981: PPUSH
79982: CALL_OW 263
79986: PUSH
79987: LD_INT 1
79989: EQUAL
79990: AND
79991: PUSH
79992: LD_VAR 0 5
79996: PPUSH
79997: CALL_OW 311
80001: AND
80002: PUSH
80003: LD_VAR 0 5
80007: PPUSH
80008: LD_EXP 196
80012: PUSH
80013: LD_VAR 0 1
80017: ARRAY
80018: PPUSH
80019: CALL_OW 308
80023: AND
80024: IFFALSE 80078
// begin mech := IsDrivenBy ( i ) ;
80026: LD_ADDR_VAR 0 10
80030: PUSH
80031: LD_VAR 0 5
80035: PPUSH
80036: CALL_OW 311
80040: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
80041: LD_VAR 0 10
80045: PPUSH
80046: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
80050: LD_VAR 0 10
80054: PPUSH
80055: LD_VAR 0 5
80059: PPUSH
80060: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
80064: LD_VAR 0 10
80068: PPUSH
80069: LD_VAR 0 5
80073: PPUSH
80074: CALL_OW 180
// end ; end ; unit_human :
80078: GO 80345
80080: LD_INT 1
80082: DOUBLE
80083: EQUAL
80084: IFTRUE 80088
80086: GO 80344
80088: POP
// begin b := IsInUnit ( i ) ;
80089: LD_ADDR_VAR 0 19
80093: PUSH
80094: LD_VAR 0 5
80098: PPUSH
80099: CALL_OW 310
80103: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
80104: LD_ADDR_VAR 0 20
80108: PUSH
80109: LD_VAR 0 19
80113: NOT
80114: PUSH
80115: LD_VAR 0 19
80119: PPUSH
80120: CALL_OW 266
80124: PUSH
80125: LD_INT 32
80127: PUSH
80128: LD_INT 31
80130: PUSH
80131: EMPTY
80132: LIST
80133: LIST
80134: IN
80135: OR
80136: ST_TO_ADDR
// if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
80137: LD_VAR 0 17
80141: PUSH
80142: LD_VAR 0 2
80146: PPUSH
80147: LD_INT 21
80149: PUSH
80150: LD_INT 2
80152: PUSH
80153: EMPTY
80154: LIST
80155: LIST
80156: PPUSH
80157: CALL_OW 72
80161: PUSH
80162: LD_INT 1
80164: LESSEQUAL
80165: OR
80166: PUSH
80167: LD_VAR 0 20
80171: AND
80172: PUSH
80173: LD_VAR 0 5
80177: PUSH
80178: LD_VAR 0 18
80182: IN
80183: NOT
80184: AND
80185: IFFALSE 80278
// begin if b then
80187: LD_VAR 0 19
80191: IFFALSE 80240
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
80193: LD_VAR 0 19
80197: PPUSH
80198: LD_VAR 0 3
80202: PPUSH
80203: LD_VAR 0 19
80207: PPUSH
80208: CALL_OW 74
80212: PPUSH
80213: CALL_OW 296
80217: PUSH
80218: LD_INT 10
80220: LESS
80221: PUSH
80222: LD_VAR 0 19
80226: PPUSH
80227: CALL_OW 461
80231: PUSH
80232: LD_INT 7
80234: NONEQUAL
80235: AND
80236: IFFALSE 80240
// continue ;
80238: GO 79555
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
80240: LD_ADDR_VAR 0 18
80244: PUSH
80245: LD_VAR 0 18
80249: PPUSH
80250: LD_VAR 0 18
80254: PUSH
80255: LD_INT 1
80257: PLUS
80258: PPUSH
80259: LD_VAR 0 5
80263: PPUSH
80264: CALL_OW 1
80268: ST_TO_ADDR
// ComExitBuilding ( i ) ;
80269: LD_VAR 0 5
80273: PPUSH
80274: CALL_OW 122
// end ; if sold_defenders then
80278: LD_VAR 0 18
80282: IFFALSE 80342
// if i in sold_defenders then
80284: LD_VAR 0 5
80288: PUSH
80289: LD_VAR 0 18
80293: IN
80294: IFFALSE 80342
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
80296: LD_VAR 0 5
80300: PPUSH
80301: CALL_OW 314
80305: NOT
80306: PUSH
80307: LD_VAR 0 5
80311: PPUSH
80312: LD_VAR 0 14
80316: PPUSH
80317: CALL_OW 296
80321: PUSH
80322: LD_INT 30
80324: LESS
80325: AND
80326: IFFALSE 80342
// ComAttackUnit ( i , e ) ;
80328: LD_VAR 0 5
80332: PPUSH
80333: LD_VAR 0 14
80337: PPUSH
80338: CALL_OW 115
// end ; end ; end ;
80342: GO 80345
80344: POP
// if IsDead ( i ) then
80345: LD_VAR 0 5
80349: PPUSH
80350: CALL_OW 301
80354: IFFALSE 80372
// defenders := defenders diff i ;
80356: LD_ADDR_VAR 0 2
80360: PUSH
80361: LD_VAR 0 2
80365: PUSH
80366: LD_VAR 0 5
80370: DIFF
80371: ST_TO_ADDR
// end ;
80372: GO 79555
80374: POP
80375: POP
// until not enemy or not defenders or not mc_bases [ base ] ;
80376: LD_VAR 0 3
80380: NOT
80381: PUSH
80382: LD_VAR 0 2
80386: NOT
80387: OR
80388: PUSH
80389: LD_EXP 172
80393: PUSH
80394: LD_VAR 0 1
80398: ARRAY
80399: NOT
80400: OR
80401: IFFALSE 79459
// MC_Reset ( base , 18 ) ;
80403: LD_VAR 0 1
80407: PPUSH
80408: LD_INT 18
80410: PPUSH
80411: CALL 84997 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
80415: LD_ADDR_VAR 0 2
80419: PUSH
80420: LD_VAR 0 2
80424: PUSH
80425: LD_VAR 0 2
80429: PPUSH
80430: LD_INT 2
80432: PUSH
80433: LD_INT 25
80435: PUSH
80436: LD_INT 1
80438: PUSH
80439: EMPTY
80440: LIST
80441: LIST
80442: PUSH
80443: LD_INT 25
80445: PUSH
80446: LD_INT 5
80448: PUSH
80449: EMPTY
80450: LIST
80451: LIST
80452: PUSH
80453: LD_INT 25
80455: PUSH
80456: LD_INT 8
80458: PUSH
80459: EMPTY
80460: LIST
80461: LIST
80462: PUSH
80463: LD_INT 25
80465: PUSH
80466: LD_INT 9
80468: PUSH
80469: EMPTY
80470: LIST
80471: LIST
80472: PUSH
80473: EMPTY
80474: LIST
80475: LIST
80476: LIST
80477: LIST
80478: LIST
80479: PPUSH
80480: CALL_OW 72
80484: DIFF
80485: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
80486: LD_VAR 0 3
80490: NOT
80491: PUSH
80492: LD_VAR 0 2
80496: PPUSH
80497: LD_INT 21
80499: PUSH
80500: LD_INT 2
80502: PUSH
80503: EMPTY
80504: LIST
80505: LIST
80506: PPUSH
80507: CALL_OW 72
80511: AND
80512: IFFALSE 80850
// begin tmp := FilterByTag ( defenders , 19 ) ;
80514: LD_ADDR_VAR 0 12
80518: PUSH
80519: LD_VAR 0 2
80523: PPUSH
80524: LD_INT 19
80526: PPUSH
80527: CALL 52657 0 2
80531: ST_TO_ADDR
// if tmp then
80532: LD_VAR 0 12
80536: IFFALSE 80606
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
80538: LD_ADDR_VAR 0 12
80542: PUSH
80543: LD_VAR 0 12
80547: PPUSH
80548: LD_INT 25
80550: PUSH
80551: LD_INT 3
80553: PUSH
80554: EMPTY
80555: LIST
80556: LIST
80557: PPUSH
80558: CALL_OW 72
80562: ST_TO_ADDR
// if tmp then
80563: LD_VAR 0 12
80567: IFFALSE 80606
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
80569: LD_ADDR_EXP 184
80573: PUSH
80574: LD_EXP 184
80578: PPUSH
80579: LD_VAR 0 1
80583: PPUSH
80584: LD_EXP 184
80588: PUSH
80589: LD_VAR 0 1
80593: ARRAY
80594: PUSH
80595: LD_VAR 0 12
80599: UNION
80600: PPUSH
80601: CALL_OW 1
80605: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
80606: LD_VAR 0 1
80610: PPUSH
80611: LD_INT 19
80613: PPUSH
80614: CALL 84997 0 2
// repeat wait ( 0 0$1 ) ;
80618: LD_INT 35
80620: PPUSH
80621: CALL_OW 67
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
80625: LD_EXP 172
80629: PUSH
80630: LD_VAR 0 1
80634: ARRAY
80635: NOT
80636: PUSH
80637: LD_EXP 172
80641: PUSH
80642: LD_VAR 0 1
80646: ARRAY
80647: PUSH
80648: EMPTY
80649: EQUAL
80650: OR
80651: IFFALSE 80688
// begin for i in defenders do
80653: LD_ADDR_VAR 0 5
80657: PUSH
80658: LD_VAR 0 2
80662: PUSH
80663: FOR_IN
80664: IFFALSE 80677
// ComStop ( i ) ;
80666: LD_VAR 0 5
80670: PPUSH
80671: CALL_OW 141
80675: GO 80663
80677: POP
80678: POP
// defenders := [ ] ;
80679: LD_ADDR_VAR 0 2
80683: PUSH
80684: EMPTY
80685: ST_TO_ADDR
// exit ;
80686: GO 80914
// end ; for i in defenders do
80688: LD_ADDR_VAR 0 5
80692: PUSH
80693: LD_VAR 0 2
80697: PUSH
80698: FOR_IN
80699: IFFALSE 80788
// begin if not IsInArea ( i , mc_parking [ base ] ) then
80701: LD_VAR 0 5
80705: PPUSH
80706: LD_EXP 196
80710: PUSH
80711: LD_VAR 0 1
80715: ARRAY
80716: PPUSH
80717: CALL_OW 308
80721: NOT
80722: IFFALSE 80746
// ComMoveToArea ( i , mc_parking [ base ] ) else
80724: LD_VAR 0 5
80728: PPUSH
80729: LD_EXP 196
80733: PUSH
80734: LD_VAR 0 1
80738: ARRAY
80739: PPUSH
80740: CALL_OW 113
80744: GO 80786
// if GetControl ( i ) = control_manual then
80746: LD_VAR 0 5
80750: PPUSH
80751: CALL_OW 263
80755: PUSH
80756: LD_INT 1
80758: EQUAL
80759: IFFALSE 80786
// if IsDrivenBy ( i ) then
80761: LD_VAR 0 5
80765: PPUSH
80766: CALL_OW 311
80770: IFFALSE 80786
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
80772: LD_VAR 0 5
80776: PPUSH
80777: CALL_OW 311
80781: PPUSH
80782: CALL_OW 121
// end ;
80786: GO 80698
80788: POP
80789: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] or not mc_bases [ base ] ;
80790: LD_VAR 0 2
80794: PPUSH
80795: LD_INT 95
80797: PUSH
80798: LD_EXP 196
80802: PUSH
80803: LD_VAR 0 1
80807: ARRAY
80808: PUSH
80809: EMPTY
80810: LIST
80811: LIST
80812: PPUSH
80813: CALL_OW 72
80817: PUSH
80818: LD_VAR 0 2
80822: EQUAL
80823: PUSH
80824: LD_EXP 195
80828: PUSH
80829: LD_VAR 0 1
80833: ARRAY
80834: OR
80835: PUSH
80836: LD_EXP 172
80840: PUSH
80841: LD_VAR 0 1
80845: ARRAY
80846: NOT
80847: OR
80848: IFFALSE 80618
// end ; mc_defender := Replace ( mc_defender , base , UnitFilter ( defenders , [ f_type , unit_vehicle ] ) ) ;
80850: LD_ADDR_EXP 194
80854: PUSH
80855: LD_EXP 194
80859: PPUSH
80860: LD_VAR 0 1
80864: PPUSH
80865: LD_VAR 0 2
80869: PPUSH
80870: LD_INT 21
80872: PUSH
80873: LD_INT 2
80875: PUSH
80876: EMPTY
80877: LIST
80878: LIST
80879: PPUSH
80880: CALL_OW 72
80884: PPUSH
80885: CALL_OW 1
80889: ST_TO_ADDR
// MC_Reset ( base , 19 ) ;
80890: LD_VAR 0 1
80894: PPUSH
80895: LD_INT 19
80897: PPUSH
80898: CALL 84997 0 2
// MC_Reset ( base , 20 ) ;
80902: LD_VAR 0 1
80906: PPUSH
80907: LD_INT 20
80909: PPUSH
80910: CALL 84997 0 2
// end ; end_of_file
80914: LD_VAR 0 4
80918: RET
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use ; export function InitMacro ; var i ; begin
80919: LD_INT 0
80921: PPUSH
80922: PPUSH
// skirmish := false ;
80923: LD_ADDR_EXP 170
80927: PUSH
80928: LD_INT 0
80930: ST_TO_ADDR
// debug_mc := false ;
80931: LD_ADDR_EXP 171
80935: PUSH
80936: LD_INT 0
80938: ST_TO_ADDR
// mc_bases := [ ] ;
80939: LD_ADDR_EXP 172
80943: PUSH
80944: EMPTY
80945: ST_TO_ADDR
// mc_sides := [ ] ;
80946: LD_ADDR_EXP 198
80950: PUSH
80951: EMPTY
80952: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
80953: LD_ADDR_EXP 173
80957: PUSH
80958: EMPTY
80959: ST_TO_ADDR
// mc_building_repairs := [ ] ;
80960: LD_ADDR_EXP 174
80964: PUSH
80965: EMPTY
80966: ST_TO_ADDR
// mc_need_heal := [ ] ;
80967: LD_ADDR_EXP 175
80971: PUSH
80972: EMPTY
80973: ST_TO_ADDR
// mc_healers := [ ] ;
80974: LD_ADDR_EXP 176
80978: PUSH
80979: EMPTY
80980: ST_TO_ADDR
// mc_build_list := [ ] ;
80981: LD_ADDR_EXP 177
80985: PUSH
80986: EMPTY
80987: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
80988: LD_ADDR_EXP 204
80992: PUSH
80993: EMPTY
80994: ST_TO_ADDR
// mc_builders := [ ] ;
80995: LD_ADDR_EXP 178
80999: PUSH
81000: EMPTY
81001: ST_TO_ADDR
// mc_construct_list := [ ] ;
81002: LD_ADDR_EXP 179
81006: PUSH
81007: EMPTY
81008: ST_TO_ADDR
// mc_turret_list := [ ] ;
81009: LD_ADDR_EXP 180
81013: PUSH
81014: EMPTY
81015: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
81016: LD_ADDR_EXP 181
81020: PUSH
81021: EMPTY
81022: ST_TO_ADDR
// mc_miners := [ ] ;
81023: LD_ADDR_EXP 186
81027: PUSH
81028: EMPTY
81029: ST_TO_ADDR
// mc_mines := [ ] ;
81030: LD_ADDR_EXP 185
81034: PUSH
81035: EMPTY
81036: ST_TO_ADDR
// mc_minefields := [ ] ;
81037: LD_ADDR_EXP 187
81041: PUSH
81042: EMPTY
81043: ST_TO_ADDR
// mc_crates := [ ] ;
81044: LD_ADDR_EXP 188
81048: PUSH
81049: EMPTY
81050: ST_TO_ADDR
// mc_crates_collector := [ ] ;
81051: LD_ADDR_EXP 189
81055: PUSH
81056: EMPTY
81057: ST_TO_ADDR
// mc_crates_area := [ ] ;
81058: LD_ADDR_EXP 190
81062: PUSH
81063: EMPTY
81064: ST_TO_ADDR
// mc_vehicles := [ ] ;
81065: LD_ADDR_EXP 191
81069: PUSH
81070: EMPTY
81071: ST_TO_ADDR
// mc_attack := [ ] ;
81072: LD_ADDR_EXP 192
81076: PUSH
81077: EMPTY
81078: ST_TO_ADDR
// mc_produce := [ ] ;
81079: LD_ADDR_EXP 193
81083: PUSH
81084: EMPTY
81085: ST_TO_ADDR
// mc_defender := [ ] ;
81086: LD_ADDR_EXP 194
81090: PUSH
81091: EMPTY
81092: ST_TO_ADDR
// mc_parking := [ ] ;
81093: LD_ADDR_EXP 196
81097: PUSH
81098: EMPTY
81099: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
81100: LD_ADDR_EXP 182
81104: PUSH
81105: EMPTY
81106: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
81107: LD_ADDR_EXP 184
81111: PUSH
81112: EMPTY
81113: ST_TO_ADDR
// mc_scan := [ ] ;
81114: LD_ADDR_EXP 195
81118: PUSH
81119: EMPTY
81120: ST_TO_ADDR
// mc_scan_area := [ ] ;
81121: LD_ADDR_EXP 197
81125: PUSH
81126: EMPTY
81127: ST_TO_ADDR
// mc_tech := [ ] ;
81128: LD_ADDR_EXP 199
81132: PUSH
81133: EMPTY
81134: ST_TO_ADDR
// mc_class := [ ] ;
81135: LD_ADDR_EXP 213
81139: PUSH
81140: EMPTY
81141: ST_TO_ADDR
// mc_class_case_use := [ ] ;
81142: LD_ADDR_EXP 214
81146: PUSH
81147: EMPTY
81148: ST_TO_ADDR
// end ;
81149: LD_VAR 0 1
81153: RET
// export function MC_Kill ( base ) ; begin
81154: LD_INT 0
81156: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
81157: LD_ADDR_EXP 172
81161: PUSH
81162: LD_EXP 172
81166: PPUSH
81167: LD_VAR 0 1
81171: PPUSH
81172: EMPTY
81173: PPUSH
81174: CALL_OW 1
81178: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
81179: LD_ADDR_EXP 173
81183: PUSH
81184: LD_EXP 173
81188: PPUSH
81189: LD_VAR 0 1
81193: PPUSH
81194: EMPTY
81195: PPUSH
81196: CALL_OW 1
81200: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
81201: LD_ADDR_EXP 174
81205: PUSH
81206: LD_EXP 174
81210: PPUSH
81211: LD_VAR 0 1
81215: PPUSH
81216: EMPTY
81217: PPUSH
81218: CALL_OW 1
81222: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
81223: LD_ADDR_EXP 175
81227: PUSH
81228: LD_EXP 175
81232: PPUSH
81233: LD_VAR 0 1
81237: PPUSH
81238: EMPTY
81239: PPUSH
81240: CALL_OW 1
81244: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
81245: LD_ADDR_EXP 176
81249: PUSH
81250: LD_EXP 176
81254: PPUSH
81255: LD_VAR 0 1
81259: PPUSH
81260: EMPTY
81261: PPUSH
81262: CALL_OW 1
81266: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
81267: LD_ADDR_EXP 177
81271: PUSH
81272: LD_EXP 177
81276: PPUSH
81277: LD_VAR 0 1
81281: PPUSH
81282: EMPTY
81283: PPUSH
81284: CALL_OW 1
81288: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
81289: LD_ADDR_EXP 178
81293: PUSH
81294: LD_EXP 178
81298: PPUSH
81299: LD_VAR 0 1
81303: PPUSH
81304: EMPTY
81305: PPUSH
81306: CALL_OW 1
81310: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
81311: LD_ADDR_EXP 179
81315: PUSH
81316: LD_EXP 179
81320: PPUSH
81321: LD_VAR 0 1
81325: PPUSH
81326: EMPTY
81327: PPUSH
81328: CALL_OW 1
81332: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
81333: LD_ADDR_EXP 180
81337: PUSH
81338: LD_EXP 180
81342: PPUSH
81343: LD_VAR 0 1
81347: PPUSH
81348: EMPTY
81349: PPUSH
81350: CALL_OW 1
81354: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
81355: LD_ADDR_EXP 181
81359: PUSH
81360: LD_EXP 181
81364: PPUSH
81365: LD_VAR 0 1
81369: PPUSH
81370: EMPTY
81371: PPUSH
81372: CALL_OW 1
81376: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
81377: LD_ADDR_EXP 182
81381: PUSH
81382: LD_EXP 182
81386: PPUSH
81387: LD_VAR 0 1
81391: PPUSH
81392: EMPTY
81393: PPUSH
81394: CALL_OW 1
81398: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
81399: LD_ADDR_EXP 183
81403: PUSH
81404: LD_EXP 183
81408: PPUSH
81409: LD_VAR 0 1
81413: PPUSH
81414: LD_INT 0
81416: PPUSH
81417: CALL_OW 1
81421: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
81422: LD_ADDR_EXP 184
81426: PUSH
81427: LD_EXP 184
81431: PPUSH
81432: LD_VAR 0 1
81436: PPUSH
81437: EMPTY
81438: PPUSH
81439: CALL_OW 1
81443: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
81444: LD_ADDR_EXP 185
81448: PUSH
81449: LD_EXP 185
81453: PPUSH
81454: LD_VAR 0 1
81458: PPUSH
81459: EMPTY
81460: PPUSH
81461: CALL_OW 1
81465: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
81466: LD_ADDR_EXP 186
81470: PUSH
81471: LD_EXP 186
81475: PPUSH
81476: LD_VAR 0 1
81480: PPUSH
81481: EMPTY
81482: PPUSH
81483: CALL_OW 1
81487: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
81488: LD_ADDR_EXP 187
81492: PUSH
81493: LD_EXP 187
81497: PPUSH
81498: LD_VAR 0 1
81502: PPUSH
81503: EMPTY
81504: PPUSH
81505: CALL_OW 1
81509: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
81510: LD_ADDR_EXP 188
81514: PUSH
81515: LD_EXP 188
81519: PPUSH
81520: LD_VAR 0 1
81524: PPUSH
81525: EMPTY
81526: PPUSH
81527: CALL_OW 1
81531: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
81532: LD_ADDR_EXP 189
81536: PUSH
81537: LD_EXP 189
81541: PPUSH
81542: LD_VAR 0 1
81546: PPUSH
81547: EMPTY
81548: PPUSH
81549: CALL_OW 1
81553: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
81554: LD_ADDR_EXP 190
81558: PUSH
81559: LD_EXP 190
81563: PPUSH
81564: LD_VAR 0 1
81568: PPUSH
81569: EMPTY
81570: PPUSH
81571: CALL_OW 1
81575: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
81576: LD_ADDR_EXP 191
81580: PUSH
81581: LD_EXP 191
81585: PPUSH
81586: LD_VAR 0 1
81590: PPUSH
81591: EMPTY
81592: PPUSH
81593: CALL_OW 1
81597: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
81598: LD_ADDR_EXP 192
81602: PUSH
81603: LD_EXP 192
81607: PPUSH
81608: LD_VAR 0 1
81612: PPUSH
81613: EMPTY
81614: PPUSH
81615: CALL_OW 1
81619: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
81620: LD_ADDR_EXP 193
81624: PUSH
81625: LD_EXP 193
81629: PPUSH
81630: LD_VAR 0 1
81634: PPUSH
81635: EMPTY
81636: PPUSH
81637: CALL_OW 1
81641: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
81642: LD_ADDR_EXP 194
81646: PUSH
81647: LD_EXP 194
81651: PPUSH
81652: LD_VAR 0 1
81656: PPUSH
81657: EMPTY
81658: PPUSH
81659: CALL_OW 1
81663: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
81664: LD_ADDR_EXP 195
81668: PUSH
81669: LD_EXP 195
81673: PPUSH
81674: LD_VAR 0 1
81678: PPUSH
81679: EMPTY
81680: PPUSH
81681: CALL_OW 1
81685: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
81686: LD_ADDR_EXP 196
81690: PUSH
81691: LD_EXP 196
81695: PPUSH
81696: LD_VAR 0 1
81700: PPUSH
81701: EMPTY
81702: PPUSH
81703: CALL_OW 1
81707: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
81708: LD_ADDR_EXP 197
81712: PUSH
81713: LD_EXP 197
81717: PPUSH
81718: LD_VAR 0 1
81722: PPUSH
81723: EMPTY
81724: PPUSH
81725: CALL_OW 1
81729: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
81730: LD_ADDR_EXP 199
81734: PUSH
81735: LD_EXP 199
81739: PPUSH
81740: LD_VAR 0 1
81744: PPUSH
81745: EMPTY
81746: PPUSH
81747: CALL_OW 1
81751: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
81752: LD_ADDR_EXP 201
81756: PUSH
81757: LD_EXP 201
81761: PPUSH
81762: LD_VAR 0 1
81766: PPUSH
81767: EMPTY
81768: PPUSH
81769: CALL_OW 1
81773: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
81774: LD_ADDR_EXP 202
81778: PUSH
81779: LD_EXP 202
81783: PPUSH
81784: LD_VAR 0 1
81788: PPUSH
81789: EMPTY
81790: PPUSH
81791: CALL_OW 1
81795: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
81796: LD_ADDR_EXP 203
81800: PUSH
81801: LD_EXP 203
81805: PPUSH
81806: LD_VAR 0 1
81810: PPUSH
81811: EMPTY
81812: PPUSH
81813: CALL_OW 1
81817: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
81818: LD_ADDR_EXP 204
81822: PUSH
81823: LD_EXP 204
81827: PPUSH
81828: LD_VAR 0 1
81832: PPUSH
81833: EMPTY
81834: PPUSH
81835: CALL_OW 1
81839: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
81840: LD_ADDR_EXP 205
81844: PUSH
81845: LD_EXP 205
81849: PPUSH
81850: LD_VAR 0 1
81854: PPUSH
81855: EMPTY
81856: PPUSH
81857: CALL_OW 1
81861: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
81862: LD_ADDR_EXP 206
81866: PUSH
81867: LD_EXP 206
81871: PPUSH
81872: LD_VAR 0 1
81876: PPUSH
81877: EMPTY
81878: PPUSH
81879: CALL_OW 1
81883: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
81884: LD_ADDR_EXP 207
81888: PUSH
81889: LD_EXP 207
81893: PPUSH
81894: LD_VAR 0 1
81898: PPUSH
81899: EMPTY
81900: PPUSH
81901: CALL_OW 1
81905: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
81906: LD_ADDR_EXP 208
81910: PUSH
81911: LD_EXP 208
81915: PPUSH
81916: LD_VAR 0 1
81920: PPUSH
81921: EMPTY
81922: PPUSH
81923: CALL_OW 1
81927: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
81928: LD_ADDR_EXP 209
81932: PUSH
81933: LD_EXP 209
81937: PPUSH
81938: LD_VAR 0 1
81942: PPUSH
81943: EMPTY
81944: PPUSH
81945: CALL_OW 1
81949: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
81950: LD_ADDR_EXP 210
81954: PUSH
81955: LD_EXP 210
81959: PPUSH
81960: LD_VAR 0 1
81964: PPUSH
81965: EMPTY
81966: PPUSH
81967: CALL_OW 1
81971: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
81972: LD_ADDR_EXP 211
81976: PUSH
81977: LD_EXP 211
81981: PPUSH
81982: LD_VAR 0 1
81986: PPUSH
81987: EMPTY
81988: PPUSH
81989: CALL_OW 1
81993: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
81994: LD_ADDR_EXP 212
81998: PUSH
81999: LD_EXP 212
82003: PPUSH
82004: LD_VAR 0 1
82008: PPUSH
82009: EMPTY
82010: PPUSH
82011: CALL_OW 1
82015: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
82016: LD_ADDR_EXP 213
82020: PUSH
82021: LD_EXP 213
82025: PPUSH
82026: LD_VAR 0 1
82030: PPUSH
82031: EMPTY
82032: PPUSH
82033: CALL_OW 1
82037: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
82038: LD_ADDR_EXP 214
82042: PUSH
82043: LD_EXP 214
82047: PPUSH
82048: LD_VAR 0 1
82052: PPUSH
82053: LD_INT 0
82055: PPUSH
82056: CALL_OW 1
82060: ST_TO_ADDR
// end ;
82061: LD_VAR 0 2
82065: RET
// export function MC_Add ( side , units ) ; var base ; begin
82066: LD_INT 0
82068: PPUSH
82069: PPUSH
// base := mc_bases + 1 ;
82070: LD_ADDR_VAR 0 4
82074: PUSH
82075: LD_EXP 172
82079: PUSH
82080: LD_INT 1
82082: PLUS
82083: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
82084: LD_ADDR_EXP 198
82088: PUSH
82089: LD_EXP 198
82093: PPUSH
82094: LD_VAR 0 4
82098: PPUSH
82099: LD_VAR 0 1
82103: PPUSH
82104: CALL_OW 1
82108: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
82109: LD_ADDR_EXP 172
82113: PUSH
82114: LD_EXP 172
82118: PPUSH
82119: LD_VAR 0 4
82123: PPUSH
82124: LD_VAR 0 2
82128: PPUSH
82129: CALL_OW 1
82133: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
82134: LD_ADDR_EXP 173
82138: PUSH
82139: LD_EXP 173
82143: PPUSH
82144: LD_VAR 0 4
82148: PPUSH
82149: EMPTY
82150: PPUSH
82151: CALL_OW 1
82155: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
82156: LD_ADDR_EXP 174
82160: PUSH
82161: LD_EXP 174
82165: PPUSH
82166: LD_VAR 0 4
82170: PPUSH
82171: EMPTY
82172: PPUSH
82173: CALL_OW 1
82177: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
82178: LD_ADDR_EXP 175
82182: PUSH
82183: LD_EXP 175
82187: PPUSH
82188: LD_VAR 0 4
82192: PPUSH
82193: EMPTY
82194: PPUSH
82195: CALL_OW 1
82199: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
82200: LD_ADDR_EXP 176
82204: PUSH
82205: LD_EXP 176
82209: PPUSH
82210: LD_VAR 0 4
82214: PPUSH
82215: EMPTY
82216: PPUSH
82217: CALL_OW 1
82221: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
82222: LD_ADDR_EXP 177
82226: PUSH
82227: LD_EXP 177
82231: PPUSH
82232: LD_VAR 0 4
82236: PPUSH
82237: EMPTY
82238: PPUSH
82239: CALL_OW 1
82243: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
82244: LD_ADDR_EXP 178
82248: PUSH
82249: LD_EXP 178
82253: PPUSH
82254: LD_VAR 0 4
82258: PPUSH
82259: EMPTY
82260: PPUSH
82261: CALL_OW 1
82265: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
82266: LD_ADDR_EXP 179
82270: PUSH
82271: LD_EXP 179
82275: PPUSH
82276: LD_VAR 0 4
82280: PPUSH
82281: EMPTY
82282: PPUSH
82283: CALL_OW 1
82287: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
82288: LD_ADDR_EXP 180
82292: PUSH
82293: LD_EXP 180
82297: PPUSH
82298: LD_VAR 0 4
82302: PPUSH
82303: EMPTY
82304: PPUSH
82305: CALL_OW 1
82309: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
82310: LD_ADDR_EXP 181
82314: PUSH
82315: LD_EXP 181
82319: PPUSH
82320: LD_VAR 0 4
82324: PPUSH
82325: EMPTY
82326: PPUSH
82327: CALL_OW 1
82331: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
82332: LD_ADDR_EXP 182
82336: PUSH
82337: LD_EXP 182
82341: PPUSH
82342: LD_VAR 0 4
82346: PPUSH
82347: EMPTY
82348: PPUSH
82349: CALL_OW 1
82353: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
82354: LD_ADDR_EXP 183
82358: PUSH
82359: LD_EXP 183
82363: PPUSH
82364: LD_VAR 0 4
82368: PPUSH
82369: LD_INT 0
82371: PPUSH
82372: CALL_OW 1
82376: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
82377: LD_ADDR_EXP 184
82381: PUSH
82382: LD_EXP 184
82386: PPUSH
82387: LD_VAR 0 4
82391: PPUSH
82392: EMPTY
82393: PPUSH
82394: CALL_OW 1
82398: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
82399: LD_ADDR_EXP 185
82403: PUSH
82404: LD_EXP 185
82408: PPUSH
82409: LD_VAR 0 4
82413: PPUSH
82414: EMPTY
82415: PPUSH
82416: CALL_OW 1
82420: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
82421: LD_ADDR_EXP 186
82425: PUSH
82426: LD_EXP 186
82430: PPUSH
82431: LD_VAR 0 4
82435: PPUSH
82436: EMPTY
82437: PPUSH
82438: CALL_OW 1
82442: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
82443: LD_ADDR_EXP 187
82447: PUSH
82448: LD_EXP 187
82452: PPUSH
82453: LD_VAR 0 4
82457: PPUSH
82458: EMPTY
82459: PPUSH
82460: CALL_OW 1
82464: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
82465: LD_ADDR_EXP 188
82469: PUSH
82470: LD_EXP 188
82474: PPUSH
82475: LD_VAR 0 4
82479: PPUSH
82480: EMPTY
82481: PPUSH
82482: CALL_OW 1
82486: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
82487: LD_ADDR_EXP 189
82491: PUSH
82492: LD_EXP 189
82496: PPUSH
82497: LD_VAR 0 4
82501: PPUSH
82502: EMPTY
82503: PPUSH
82504: CALL_OW 1
82508: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
82509: LD_ADDR_EXP 190
82513: PUSH
82514: LD_EXP 190
82518: PPUSH
82519: LD_VAR 0 4
82523: PPUSH
82524: EMPTY
82525: PPUSH
82526: CALL_OW 1
82530: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
82531: LD_ADDR_EXP 191
82535: PUSH
82536: LD_EXP 191
82540: PPUSH
82541: LD_VAR 0 4
82545: PPUSH
82546: EMPTY
82547: PPUSH
82548: CALL_OW 1
82552: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
82553: LD_ADDR_EXP 192
82557: PUSH
82558: LD_EXP 192
82562: PPUSH
82563: LD_VAR 0 4
82567: PPUSH
82568: EMPTY
82569: PPUSH
82570: CALL_OW 1
82574: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
82575: LD_ADDR_EXP 193
82579: PUSH
82580: LD_EXP 193
82584: PPUSH
82585: LD_VAR 0 4
82589: PPUSH
82590: EMPTY
82591: PPUSH
82592: CALL_OW 1
82596: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
82597: LD_ADDR_EXP 194
82601: PUSH
82602: LD_EXP 194
82606: PPUSH
82607: LD_VAR 0 4
82611: PPUSH
82612: EMPTY
82613: PPUSH
82614: CALL_OW 1
82618: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
82619: LD_ADDR_EXP 195
82623: PUSH
82624: LD_EXP 195
82628: PPUSH
82629: LD_VAR 0 4
82633: PPUSH
82634: EMPTY
82635: PPUSH
82636: CALL_OW 1
82640: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
82641: LD_ADDR_EXP 196
82645: PUSH
82646: LD_EXP 196
82650: PPUSH
82651: LD_VAR 0 4
82655: PPUSH
82656: EMPTY
82657: PPUSH
82658: CALL_OW 1
82662: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
82663: LD_ADDR_EXP 197
82667: PUSH
82668: LD_EXP 197
82672: PPUSH
82673: LD_VAR 0 4
82677: PPUSH
82678: EMPTY
82679: PPUSH
82680: CALL_OW 1
82684: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
82685: LD_ADDR_EXP 199
82689: PUSH
82690: LD_EXP 199
82694: PPUSH
82695: LD_VAR 0 4
82699: PPUSH
82700: EMPTY
82701: PPUSH
82702: CALL_OW 1
82706: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
82707: LD_ADDR_EXP 201
82711: PUSH
82712: LD_EXP 201
82716: PPUSH
82717: LD_VAR 0 4
82721: PPUSH
82722: EMPTY
82723: PPUSH
82724: CALL_OW 1
82728: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
82729: LD_ADDR_EXP 202
82733: PUSH
82734: LD_EXP 202
82738: PPUSH
82739: LD_VAR 0 4
82743: PPUSH
82744: EMPTY
82745: PPUSH
82746: CALL_OW 1
82750: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
82751: LD_ADDR_EXP 203
82755: PUSH
82756: LD_EXP 203
82760: PPUSH
82761: LD_VAR 0 4
82765: PPUSH
82766: EMPTY
82767: PPUSH
82768: CALL_OW 1
82772: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
82773: LD_ADDR_EXP 204
82777: PUSH
82778: LD_EXP 204
82782: PPUSH
82783: LD_VAR 0 4
82787: PPUSH
82788: EMPTY
82789: PPUSH
82790: CALL_OW 1
82794: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
82795: LD_ADDR_EXP 205
82799: PUSH
82800: LD_EXP 205
82804: PPUSH
82805: LD_VAR 0 4
82809: PPUSH
82810: EMPTY
82811: PPUSH
82812: CALL_OW 1
82816: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
82817: LD_ADDR_EXP 206
82821: PUSH
82822: LD_EXP 206
82826: PPUSH
82827: LD_VAR 0 4
82831: PPUSH
82832: EMPTY
82833: PPUSH
82834: CALL_OW 1
82838: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
82839: LD_ADDR_EXP 207
82843: PUSH
82844: LD_EXP 207
82848: PPUSH
82849: LD_VAR 0 4
82853: PPUSH
82854: EMPTY
82855: PPUSH
82856: CALL_OW 1
82860: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
82861: LD_ADDR_EXP 208
82865: PUSH
82866: LD_EXP 208
82870: PPUSH
82871: LD_VAR 0 4
82875: PPUSH
82876: EMPTY
82877: PPUSH
82878: CALL_OW 1
82882: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
82883: LD_ADDR_EXP 209
82887: PUSH
82888: LD_EXP 209
82892: PPUSH
82893: LD_VAR 0 4
82897: PPUSH
82898: EMPTY
82899: PPUSH
82900: CALL_OW 1
82904: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
82905: LD_ADDR_EXP 210
82909: PUSH
82910: LD_EXP 210
82914: PPUSH
82915: LD_VAR 0 4
82919: PPUSH
82920: EMPTY
82921: PPUSH
82922: CALL_OW 1
82926: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
82927: LD_ADDR_EXP 211
82931: PUSH
82932: LD_EXP 211
82936: PPUSH
82937: LD_VAR 0 4
82941: PPUSH
82942: EMPTY
82943: PPUSH
82944: CALL_OW 1
82948: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
82949: LD_ADDR_EXP 212
82953: PUSH
82954: LD_EXP 212
82958: PPUSH
82959: LD_VAR 0 4
82963: PPUSH
82964: EMPTY
82965: PPUSH
82966: CALL_OW 1
82970: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
82971: LD_ADDR_EXP 213
82975: PUSH
82976: LD_EXP 213
82980: PPUSH
82981: LD_VAR 0 4
82985: PPUSH
82986: EMPTY
82987: PPUSH
82988: CALL_OW 1
82992: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
82993: LD_ADDR_EXP 214
82997: PUSH
82998: LD_EXP 214
83002: PPUSH
83003: LD_VAR 0 4
83007: PPUSH
83008: LD_INT 0
83010: PPUSH
83011: CALL_OW 1
83015: ST_TO_ADDR
// result := base ;
83016: LD_ADDR_VAR 0 3
83020: PUSH
83021: LD_VAR 0 4
83025: ST_TO_ADDR
// end ;
83026: LD_VAR 0 3
83030: RET
// export function MC_Start ( ) ; var i ; begin
83031: LD_INT 0
83033: PPUSH
83034: PPUSH
// for i = 1 to mc_bases do
83035: LD_ADDR_VAR 0 2
83039: PUSH
83040: DOUBLE
83041: LD_INT 1
83043: DEC
83044: ST_TO_ADDR
83045: LD_EXP 172
83049: PUSH
83050: FOR_TO
83051: IFFALSE 84128
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
83053: LD_ADDR_EXP 172
83057: PUSH
83058: LD_EXP 172
83062: PPUSH
83063: LD_VAR 0 2
83067: PPUSH
83068: LD_EXP 172
83072: PUSH
83073: LD_VAR 0 2
83077: ARRAY
83078: PUSH
83079: LD_INT 0
83081: DIFF
83082: PPUSH
83083: CALL_OW 1
83087: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
83088: LD_ADDR_EXP 173
83092: PUSH
83093: LD_EXP 173
83097: PPUSH
83098: LD_VAR 0 2
83102: PPUSH
83103: EMPTY
83104: PPUSH
83105: CALL_OW 1
83109: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
83110: LD_ADDR_EXP 174
83114: PUSH
83115: LD_EXP 174
83119: PPUSH
83120: LD_VAR 0 2
83124: PPUSH
83125: EMPTY
83126: PPUSH
83127: CALL_OW 1
83131: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
83132: LD_ADDR_EXP 175
83136: PUSH
83137: LD_EXP 175
83141: PPUSH
83142: LD_VAR 0 2
83146: PPUSH
83147: EMPTY
83148: PPUSH
83149: CALL_OW 1
83153: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
83154: LD_ADDR_EXP 176
83158: PUSH
83159: LD_EXP 176
83163: PPUSH
83164: LD_VAR 0 2
83168: PPUSH
83169: EMPTY
83170: PUSH
83171: EMPTY
83172: PUSH
83173: EMPTY
83174: LIST
83175: LIST
83176: PPUSH
83177: CALL_OW 1
83181: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
83182: LD_ADDR_EXP 177
83186: PUSH
83187: LD_EXP 177
83191: PPUSH
83192: LD_VAR 0 2
83196: PPUSH
83197: EMPTY
83198: PPUSH
83199: CALL_OW 1
83203: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
83204: LD_ADDR_EXP 204
83208: PUSH
83209: LD_EXP 204
83213: PPUSH
83214: LD_VAR 0 2
83218: PPUSH
83219: EMPTY
83220: PPUSH
83221: CALL_OW 1
83225: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
83226: LD_ADDR_EXP 178
83230: PUSH
83231: LD_EXP 178
83235: PPUSH
83236: LD_VAR 0 2
83240: PPUSH
83241: EMPTY
83242: PPUSH
83243: CALL_OW 1
83247: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
83248: LD_ADDR_EXP 179
83252: PUSH
83253: LD_EXP 179
83257: PPUSH
83258: LD_VAR 0 2
83262: PPUSH
83263: EMPTY
83264: PPUSH
83265: CALL_OW 1
83269: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
83270: LD_ADDR_EXP 180
83274: PUSH
83275: LD_EXP 180
83279: PPUSH
83280: LD_VAR 0 2
83284: PPUSH
83285: LD_EXP 172
83289: PUSH
83290: LD_VAR 0 2
83294: ARRAY
83295: PPUSH
83296: LD_INT 2
83298: PUSH
83299: LD_INT 30
83301: PUSH
83302: LD_INT 32
83304: PUSH
83305: EMPTY
83306: LIST
83307: LIST
83308: PUSH
83309: LD_INT 30
83311: PUSH
83312: LD_INT 33
83314: PUSH
83315: EMPTY
83316: LIST
83317: LIST
83318: PUSH
83319: EMPTY
83320: LIST
83321: LIST
83322: LIST
83323: PPUSH
83324: CALL_OW 72
83328: PPUSH
83329: CALL_OW 1
83333: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
83334: LD_ADDR_EXP 181
83338: PUSH
83339: LD_EXP 181
83343: PPUSH
83344: LD_VAR 0 2
83348: PPUSH
83349: LD_EXP 172
83353: PUSH
83354: LD_VAR 0 2
83358: ARRAY
83359: PPUSH
83360: LD_INT 2
83362: PUSH
83363: LD_INT 30
83365: PUSH
83366: LD_INT 32
83368: PUSH
83369: EMPTY
83370: LIST
83371: LIST
83372: PUSH
83373: LD_INT 30
83375: PUSH
83376: LD_INT 31
83378: PUSH
83379: EMPTY
83380: LIST
83381: LIST
83382: PUSH
83383: EMPTY
83384: LIST
83385: LIST
83386: LIST
83387: PUSH
83388: LD_INT 58
83390: PUSH
83391: EMPTY
83392: LIST
83393: PUSH
83394: EMPTY
83395: LIST
83396: LIST
83397: PPUSH
83398: CALL_OW 72
83402: PPUSH
83403: CALL_OW 1
83407: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
83408: LD_ADDR_EXP 182
83412: PUSH
83413: LD_EXP 182
83417: PPUSH
83418: LD_VAR 0 2
83422: PPUSH
83423: EMPTY
83424: PPUSH
83425: CALL_OW 1
83429: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
83430: LD_ADDR_EXP 186
83434: PUSH
83435: LD_EXP 186
83439: PPUSH
83440: LD_VAR 0 2
83444: PPUSH
83445: EMPTY
83446: PPUSH
83447: CALL_OW 1
83451: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
83452: LD_ADDR_EXP 185
83456: PUSH
83457: LD_EXP 185
83461: PPUSH
83462: LD_VAR 0 2
83466: PPUSH
83467: EMPTY
83468: PPUSH
83469: CALL_OW 1
83473: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
83474: LD_ADDR_EXP 187
83478: PUSH
83479: LD_EXP 187
83483: PPUSH
83484: LD_VAR 0 2
83488: PPUSH
83489: EMPTY
83490: PPUSH
83491: CALL_OW 1
83495: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
83496: LD_ADDR_EXP 188
83500: PUSH
83501: LD_EXP 188
83505: PPUSH
83506: LD_VAR 0 2
83510: PPUSH
83511: EMPTY
83512: PPUSH
83513: CALL_OW 1
83517: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
83518: LD_ADDR_EXP 189
83522: PUSH
83523: LD_EXP 189
83527: PPUSH
83528: LD_VAR 0 2
83532: PPUSH
83533: EMPTY
83534: PPUSH
83535: CALL_OW 1
83539: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
83540: LD_ADDR_EXP 190
83544: PUSH
83545: LD_EXP 190
83549: PPUSH
83550: LD_VAR 0 2
83554: PPUSH
83555: EMPTY
83556: PPUSH
83557: CALL_OW 1
83561: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
83562: LD_ADDR_EXP 191
83566: PUSH
83567: LD_EXP 191
83571: PPUSH
83572: LD_VAR 0 2
83576: PPUSH
83577: EMPTY
83578: PPUSH
83579: CALL_OW 1
83583: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
83584: LD_ADDR_EXP 192
83588: PUSH
83589: LD_EXP 192
83593: PPUSH
83594: LD_VAR 0 2
83598: PPUSH
83599: EMPTY
83600: PPUSH
83601: CALL_OW 1
83605: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
83606: LD_ADDR_EXP 193
83610: PUSH
83611: LD_EXP 193
83615: PPUSH
83616: LD_VAR 0 2
83620: PPUSH
83621: EMPTY
83622: PPUSH
83623: CALL_OW 1
83627: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
83628: LD_ADDR_EXP 194
83632: PUSH
83633: LD_EXP 194
83637: PPUSH
83638: LD_VAR 0 2
83642: PPUSH
83643: EMPTY
83644: PPUSH
83645: CALL_OW 1
83649: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
83650: LD_ADDR_EXP 183
83654: PUSH
83655: LD_EXP 183
83659: PPUSH
83660: LD_VAR 0 2
83664: PPUSH
83665: LD_INT 0
83667: PPUSH
83668: CALL_OW 1
83672: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
83673: LD_ADDR_EXP 196
83677: PUSH
83678: LD_EXP 196
83682: PPUSH
83683: LD_VAR 0 2
83687: PPUSH
83688: LD_INT 0
83690: PPUSH
83691: CALL_OW 1
83695: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
83696: LD_ADDR_EXP 184
83700: PUSH
83701: LD_EXP 184
83705: PPUSH
83706: LD_VAR 0 2
83710: PPUSH
83711: EMPTY
83712: PPUSH
83713: CALL_OW 1
83717: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
83718: LD_ADDR_EXP 195
83722: PUSH
83723: LD_EXP 195
83727: PPUSH
83728: LD_VAR 0 2
83732: PPUSH
83733: LD_INT 0
83735: PPUSH
83736: CALL_OW 1
83740: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
83741: LD_ADDR_EXP 197
83745: PUSH
83746: LD_EXP 197
83750: PPUSH
83751: LD_VAR 0 2
83755: PPUSH
83756: EMPTY
83757: PPUSH
83758: CALL_OW 1
83762: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
83763: LD_ADDR_EXP 200
83767: PUSH
83768: LD_EXP 200
83772: PPUSH
83773: LD_VAR 0 2
83777: PPUSH
83778: LD_INT 0
83780: PPUSH
83781: CALL_OW 1
83785: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
83786: LD_ADDR_EXP 201
83790: PUSH
83791: LD_EXP 201
83795: PPUSH
83796: LD_VAR 0 2
83800: PPUSH
83801: EMPTY
83802: PPUSH
83803: CALL_OW 1
83807: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
83808: LD_ADDR_EXP 202
83812: PUSH
83813: LD_EXP 202
83817: PPUSH
83818: LD_VAR 0 2
83822: PPUSH
83823: EMPTY
83824: PPUSH
83825: CALL_OW 1
83829: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
83830: LD_ADDR_EXP 203
83834: PUSH
83835: LD_EXP 203
83839: PPUSH
83840: LD_VAR 0 2
83844: PPUSH
83845: EMPTY
83846: PPUSH
83847: CALL_OW 1
83851: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
83852: LD_ADDR_EXP 205
83856: PUSH
83857: LD_EXP 205
83861: PPUSH
83862: LD_VAR 0 2
83866: PPUSH
83867: LD_EXP 172
83871: PUSH
83872: LD_VAR 0 2
83876: ARRAY
83877: PPUSH
83878: LD_INT 2
83880: PUSH
83881: LD_INT 30
83883: PUSH
83884: LD_INT 6
83886: PUSH
83887: EMPTY
83888: LIST
83889: LIST
83890: PUSH
83891: LD_INT 30
83893: PUSH
83894: LD_INT 7
83896: PUSH
83897: EMPTY
83898: LIST
83899: LIST
83900: PUSH
83901: LD_INT 30
83903: PUSH
83904: LD_INT 8
83906: PUSH
83907: EMPTY
83908: LIST
83909: LIST
83910: PUSH
83911: EMPTY
83912: LIST
83913: LIST
83914: LIST
83915: LIST
83916: PPUSH
83917: CALL_OW 72
83921: PPUSH
83922: CALL_OW 1
83926: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
83927: LD_ADDR_EXP 206
83931: PUSH
83932: LD_EXP 206
83936: PPUSH
83937: LD_VAR 0 2
83941: PPUSH
83942: EMPTY
83943: PPUSH
83944: CALL_OW 1
83948: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
83949: LD_ADDR_EXP 207
83953: PUSH
83954: LD_EXP 207
83958: PPUSH
83959: LD_VAR 0 2
83963: PPUSH
83964: EMPTY
83965: PPUSH
83966: CALL_OW 1
83970: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
83971: LD_ADDR_EXP 208
83975: PUSH
83976: LD_EXP 208
83980: PPUSH
83981: LD_VAR 0 2
83985: PPUSH
83986: EMPTY
83987: PPUSH
83988: CALL_OW 1
83992: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
83993: LD_ADDR_EXP 209
83997: PUSH
83998: LD_EXP 209
84002: PPUSH
84003: LD_VAR 0 2
84007: PPUSH
84008: EMPTY
84009: PPUSH
84010: CALL_OW 1
84014: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
84015: LD_ADDR_EXP 210
84019: PUSH
84020: LD_EXP 210
84024: PPUSH
84025: LD_VAR 0 2
84029: PPUSH
84030: EMPTY
84031: PPUSH
84032: CALL_OW 1
84036: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
84037: LD_ADDR_EXP 211
84041: PUSH
84042: LD_EXP 211
84046: PPUSH
84047: LD_VAR 0 2
84051: PPUSH
84052: EMPTY
84053: PPUSH
84054: CALL_OW 1
84058: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
84059: LD_ADDR_EXP 212
84063: PUSH
84064: LD_EXP 212
84068: PPUSH
84069: LD_VAR 0 2
84073: PPUSH
84074: EMPTY
84075: PPUSH
84076: CALL_OW 1
84080: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
84081: LD_ADDR_EXP 213
84085: PUSH
84086: LD_EXP 213
84090: PPUSH
84091: LD_VAR 0 2
84095: PPUSH
84096: EMPTY
84097: PPUSH
84098: CALL_OW 1
84102: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
84103: LD_ADDR_EXP 214
84107: PUSH
84108: LD_EXP 214
84112: PPUSH
84113: LD_VAR 0 2
84117: PPUSH
84118: LD_INT 0
84120: PPUSH
84121: CALL_OW 1
84125: ST_TO_ADDR
// end ;
84126: GO 83050
84128: POP
84129: POP
// MC_InitSides ( ) ;
84130: CALL 84416 0 0
// MC_InitResearch ( ) ;
84134: CALL 84155 0 0
// CustomInitMacro ( ) ;
84138: CALL 350 0 0
// skirmish := true ;
84142: LD_ADDR_EXP 170
84146: PUSH
84147: LD_INT 1
84149: ST_TO_ADDR
// end ;
84150: LD_VAR 0 1
84154: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
84155: LD_INT 0
84157: PPUSH
84158: PPUSH
84159: PPUSH
84160: PPUSH
84161: PPUSH
84162: PPUSH
// if not mc_bases then
84163: LD_EXP 172
84167: NOT
84168: IFFALSE 84172
// exit ;
84170: GO 84411
// for i = 1 to 8 do
84172: LD_ADDR_VAR 0 2
84176: PUSH
84177: DOUBLE
84178: LD_INT 1
84180: DEC
84181: ST_TO_ADDR
84182: LD_INT 8
84184: PUSH
84185: FOR_TO
84186: IFFALSE 84212
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
84188: LD_ADDR_EXP 199
84192: PUSH
84193: LD_EXP 199
84197: PPUSH
84198: LD_VAR 0 2
84202: PPUSH
84203: EMPTY
84204: PPUSH
84205: CALL_OW 1
84209: ST_TO_ADDR
84210: GO 84185
84212: POP
84213: POP
// tmp := [ ] ;
84214: LD_ADDR_VAR 0 5
84218: PUSH
84219: EMPTY
84220: ST_TO_ADDR
// for i = 1 to mc_sides do
84221: LD_ADDR_VAR 0 2
84225: PUSH
84226: DOUBLE
84227: LD_INT 1
84229: DEC
84230: ST_TO_ADDR
84231: LD_EXP 198
84235: PUSH
84236: FOR_TO
84237: IFFALSE 84295
// if not mc_sides [ i ] in tmp then
84239: LD_EXP 198
84243: PUSH
84244: LD_VAR 0 2
84248: ARRAY
84249: PUSH
84250: LD_VAR 0 5
84254: IN
84255: NOT
84256: IFFALSE 84293
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
84258: LD_ADDR_VAR 0 5
84262: PUSH
84263: LD_VAR 0 5
84267: PPUSH
84268: LD_VAR 0 5
84272: PUSH
84273: LD_INT 1
84275: PLUS
84276: PPUSH
84277: LD_EXP 198
84281: PUSH
84282: LD_VAR 0 2
84286: ARRAY
84287: PPUSH
84288: CALL_OW 2
84292: ST_TO_ADDR
84293: GO 84236
84295: POP
84296: POP
// if not tmp then
84297: LD_VAR 0 5
84301: NOT
84302: IFFALSE 84306
// exit ;
84304: GO 84411
// for j in tmp do
84306: LD_ADDR_VAR 0 3
84310: PUSH
84311: LD_VAR 0 5
84315: PUSH
84316: FOR_IN
84317: IFFALSE 84409
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
84319: LD_ADDR_VAR 0 6
84323: PUSH
84324: LD_INT 22
84326: PUSH
84327: LD_VAR 0 3
84331: PUSH
84332: EMPTY
84333: LIST
84334: LIST
84335: PPUSH
84336: CALL_OW 69
84340: ST_TO_ADDR
// if not un then
84341: LD_VAR 0 6
84345: NOT
84346: IFFALSE 84350
// continue ;
84348: GO 84316
// nation := GetNation ( un [ 1 ] ) ;
84350: LD_ADDR_VAR 0 4
84354: PUSH
84355: LD_VAR 0 6
84359: PUSH
84360: LD_INT 1
84362: ARRAY
84363: PPUSH
84364: CALL_OW 248
84368: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
84369: LD_ADDR_EXP 199
84373: PUSH
84374: LD_EXP 199
84378: PPUSH
84379: LD_VAR 0 3
84383: PPUSH
84384: LD_VAR 0 3
84388: PPUSH
84389: LD_VAR 0 4
84393: PPUSH
84394: LD_INT 1
84396: PPUSH
84397: CALL 19213 0 3
84401: PPUSH
84402: CALL_OW 1
84406: ST_TO_ADDR
// end ;
84407: GO 84316
84409: POP
84410: POP
// end ;
84411: LD_VAR 0 1
84415: RET
// export function MC_InitSides ( ) ; var i ; begin
84416: LD_INT 0
84418: PPUSH
84419: PPUSH
// if not mc_bases then
84420: LD_EXP 172
84424: NOT
84425: IFFALSE 84429
// exit ;
84427: GO 84503
// for i = 1 to mc_bases do
84429: LD_ADDR_VAR 0 2
84433: PUSH
84434: DOUBLE
84435: LD_INT 1
84437: DEC
84438: ST_TO_ADDR
84439: LD_EXP 172
84443: PUSH
84444: FOR_TO
84445: IFFALSE 84501
// if mc_bases [ i ] then
84447: LD_EXP 172
84451: PUSH
84452: LD_VAR 0 2
84456: ARRAY
84457: IFFALSE 84499
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
84459: LD_ADDR_EXP 198
84463: PUSH
84464: LD_EXP 198
84468: PPUSH
84469: LD_VAR 0 2
84473: PPUSH
84474: LD_EXP 172
84478: PUSH
84479: LD_VAR 0 2
84483: ARRAY
84484: PUSH
84485: LD_INT 1
84487: ARRAY
84488: PPUSH
84489: CALL_OW 255
84493: PPUSH
84494: CALL_OW 1
84498: ST_TO_ADDR
84499: GO 84444
84501: POP
84502: POP
// end ;
84503: LD_VAR 0 1
84507: RET
// every 0 0$01 trigger skirmish do
84508: LD_EXP 170
84512: IFFALSE 84666
84514: GO 84516
84516: DISABLE
// begin enable ;
84517: ENABLE
// MC_CheckBuildings ( ) ;
84518: CALL 89164 0 0
// MC_CheckPeopleLife ( ) ;
84522: CALL 89289 0 0
// RaiseSailEvent ( 100 ) ;
84526: LD_INT 100
84528: PPUSH
84529: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
84533: LD_INT 103
84535: PPUSH
84536: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
84540: LD_INT 104
84542: PPUSH
84543: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
84547: LD_INT 105
84549: PPUSH
84550: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
84554: LD_INT 106
84556: PPUSH
84557: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
84561: LD_INT 107
84563: PPUSH
84564: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
84568: LD_INT 108
84570: PPUSH
84571: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
84575: LD_INT 109
84577: PPUSH
84578: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
84582: LD_INT 110
84584: PPUSH
84585: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
84589: LD_INT 111
84591: PPUSH
84592: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
84596: LD_INT 112
84598: PPUSH
84599: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
84603: LD_INT 113
84605: PPUSH
84606: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
84610: LD_INT 120
84612: PPUSH
84613: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
84617: LD_INT 121
84619: PPUSH
84620: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
84624: LD_INT 122
84626: PPUSH
84627: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
84631: LD_INT 123
84633: PPUSH
84634: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
84638: LD_INT 124
84640: PPUSH
84641: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
84645: LD_INT 125
84647: PPUSH
84648: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
84652: LD_INT 126
84654: PPUSH
84655: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
84659: LD_INT 200
84661: PPUSH
84662: CALL_OW 427
// end ;
84666: END
// on SailEvent ( event ) do begin if event < 100 then
84667: LD_VAR 0 1
84671: PUSH
84672: LD_INT 100
84674: LESS
84675: IFFALSE 84686
// CustomEvent ( event ) ;
84677: LD_VAR 0 1
84681: PPUSH
84682: CALL 16084 0 1
// if event = 100 then
84686: LD_VAR 0 1
84690: PUSH
84691: LD_INT 100
84693: EQUAL
84694: IFFALSE 84700
// MC_ClassManager ( ) ;
84696: CALL 85092 0 0
// if event = 101 then
84700: LD_VAR 0 1
84704: PUSH
84705: LD_INT 101
84707: EQUAL
84708: IFFALSE 84714
// MC_RepairBuildings ( ) ;
84710: CALL 89874 0 0
// if event = 102 then
84714: LD_VAR 0 1
84718: PUSH
84719: LD_INT 102
84721: EQUAL
84722: IFFALSE 84728
// MC_Heal ( ) ;
84724: CALL 90759 0 0
// if event = 103 then
84728: LD_VAR 0 1
84732: PUSH
84733: LD_INT 103
84735: EQUAL
84736: IFFALSE 84742
// MC_Build ( ) ;
84738: CALL 91181 0 0
// if event = 104 then
84742: LD_VAR 0 1
84746: PUSH
84747: LD_INT 104
84749: EQUAL
84750: IFFALSE 84756
// MC_TurretWeapon ( ) ;
84752: CALL 92794 0 0
// if event = 105 then
84756: LD_VAR 0 1
84760: PUSH
84761: LD_INT 105
84763: EQUAL
84764: IFFALSE 84770
// MC_BuildUpgrade ( ) ;
84766: CALL 92345 0 0
// if event = 106 then
84770: LD_VAR 0 1
84774: PUSH
84775: LD_INT 106
84777: EQUAL
84778: IFFALSE 84784
// MC_PlantMines ( ) ;
84780: CALL 93224 0 0
// if event = 107 then
84784: LD_VAR 0 1
84788: PUSH
84789: LD_INT 107
84791: EQUAL
84792: IFFALSE 84798
// MC_CollectCrates ( ) ;
84794: CALL 94015 0 0
// if event = 108 then
84798: LD_VAR 0 1
84802: PUSH
84803: LD_INT 108
84805: EQUAL
84806: IFFALSE 84812
// MC_LinkRemoteControl ( ) ;
84808: CALL 95791 0 0
// if event = 109 then
84812: LD_VAR 0 1
84816: PUSH
84817: LD_INT 109
84819: EQUAL
84820: IFFALSE 84826
// MC_ProduceVehicle ( ) ;
84822: CALL 95972 0 0
// if event = 110 then
84826: LD_VAR 0 1
84830: PUSH
84831: LD_INT 110
84833: EQUAL
84834: IFFALSE 84840
// MC_SendAttack ( ) ;
84836: CALL 96438 0 0
// if event = 111 then
84840: LD_VAR 0 1
84844: PUSH
84845: LD_INT 111
84847: EQUAL
84848: IFFALSE 84854
// MC_Defend ( ) ;
84850: CALL 96546 0 0
// if event = 112 then
84854: LD_VAR 0 1
84858: PUSH
84859: LD_INT 112
84861: EQUAL
84862: IFFALSE 84868
// MC_Research ( ) ;
84864: CALL 97173 0 0
// if event = 113 then
84868: LD_VAR 0 1
84872: PUSH
84873: LD_INT 113
84875: EQUAL
84876: IFFALSE 84882
// MC_MinesTrigger ( ) ;
84878: CALL 98287 0 0
// if event = 120 then
84882: LD_VAR 0 1
84886: PUSH
84887: LD_INT 120
84889: EQUAL
84890: IFFALSE 84896
// MC_RepairVehicle ( ) ;
84892: CALL 98386 0 0
// if event = 121 then
84896: LD_VAR 0 1
84900: PUSH
84901: LD_INT 121
84903: EQUAL
84904: IFFALSE 84910
// MC_TameApe ( ) ;
84906: CALL 99116 0 0
// if event = 122 then
84910: LD_VAR 0 1
84914: PUSH
84915: LD_INT 122
84917: EQUAL
84918: IFFALSE 84924
// MC_ChangeApeClass ( ) ;
84920: CALL 99945 0 0
// if event = 123 then
84924: LD_VAR 0 1
84928: PUSH
84929: LD_INT 123
84931: EQUAL
84932: IFFALSE 84938
// MC_Bazooka ( ) ;
84934: CALL 100595 0 0
// if event = 124 then
84938: LD_VAR 0 1
84942: PUSH
84943: LD_INT 124
84945: EQUAL
84946: IFFALSE 84952
// MC_TeleportExit ( ) ;
84948: CALL 100793 0 0
// if event = 125 then
84952: LD_VAR 0 1
84956: PUSH
84957: LD_INT 125
84959: EQUAL
84960: IFFALSE 84966
// MC_Deposits ( ) ;
84962: CALL 101440 0 0
// if event = 126 then
84966: LD_VAR 0 1
84970: PUSH
84971: LD_INT 126
84973: EQUAL
84974: IFFALSE 84980
// MC_RemoteDriver ( ) ;
84976: CALL 102065 0 0
// if event = 200 then
84980: LD_VAR 0 1
84984: PUSH
84985: LD_INT 200
84987: EQUAL
84988: IFFALSE 84994
// MC_Idle ( ) ;
84990: CALL 104014 0 0
// end ;
84994: PPOPN 1
84996: END
// export function MC_Reset ( base , tag ) ; var i ; begin
84997: LD_INT 0
84999: PPUSH
85000: PPUSH
// if not mc_bases [ base ] or not tag then
85001: LD_EXP 172
85005: PUSH
85006: LD_VAR 0 1
85010: ARRAY
85011: NOT
85012: PUSH
85013: LD_VAR 0 2
85017: NOT
85018: OR
85019: IFFALSE 85023
// exit ;
85021: GO 85087
// for i in mc_bases [ base ] union mc_ape [ base ] do
85023: LD_ADDR_VAR 0 4
85027: PUSH
85028: LD_EXP 172
85032: PUSH
85033: LD_VAR 0 1
85037: ARRAY
85038: PUSH
85039: LD_EXP 201
85043: PUSH
85044: LD_VAR 0 1
85048: ARRAY
85049: UNION
85050: PUSH
85051: FOR_IN
85052: IFFALSE 85085
// if GetTag ( i ) = tag then
85054: LD_VAR 0 4
85058: PPUSH
85059: CALL_OW 110
85063: PUSH
85064: LD_VAR 0 2
85068: EQUAL
85069: IFFALSE 85083
// SetTag ( i , 0 ) ;
85071: LD_VAR 0 4
85075: PPUSH
85076: LD_INT 0
85078: PPUSH
85079: CALL_OW 109
85083: GO 85051
85085: POP
85086: POP
// end ;
85087: LD_VAR 0 3
85091: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
85092: LD_INT 0
85094: PPUSH
85095: PPUSH
85096: PPUSH
85097: PPUSH
85098: PPUSH
85099: PPUSH
85100: PPUSH
85101: PPUSH
// if not mc_bases then
85102: LD_EXP 172
85106: NOT
85107: IFFALSE 85111
// exit ;
85109: GO 85569
// for i = 1 to mc_bases do
85111: LD_ADDR_VAR 0 2
85115: PUSH
85116: DOUBLE
85117: LD_INT 1
85119: DEC
85120: ST_TO_ADDR
85121: LD_EXP 172
85125: PUSH
85126: FOR_TO
85127: IFFALSE 85567
// begin tmp := MC_ClassCheckReq ( i ) ;
85129: LD_ADDR_VAR 0 4
85133: PUSH
85134: LD_VAR 0 2
85138: PPUSH
85139: CALL 85574 0 1
85143: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
85144: LD_ADDR_EXP 213
85148: PUSH
85149: LD_EXP 213
85153: PPUSH
85154: LD_VAR 0 2
85158: PPUSH
85159: LD_VAR 0 4
85163: PPUSH
85164: CALL_OW 1
85168: ST_TO_ADDR
// if not tmp then
85169: LD_VAR 0 4
85173: NOT
85174: IFFALSE 85178
// continue ;
85176: GO 85126
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
85178: LD_ADDR_VAR 0 6
85182: PUSH
85183: LD_EXP 172
85187: PUSH
85188: LD_VAR 0 2
85192: ARRAY
85193: PPUSH
85194: LD_INT 2
85196: PUSH
85197: LD_INT 30
85199: PUSH
85200: LD_INT 4
85202: PUSH
85203: EMPTY
85204: LIST
85205: LIST
85206: PUSH
85207: LD_INT 30
85209: PUSH
85210: LD_INT 5
85212: PUSH
85213: EMPTY
85214: LIST
85215: LIST
85216: PUSH
85217: EMPTY
85218: LIST
85219: LIST
85220: LIST
85221: PPUSH
85222: CALL_OW 72
85226: PUSH
85227: LD_EXP 172
85231: PUSH
85232: LD_VAR 0 2
85236: ARRAY
85237: PPUSH
85238: LD_INT 2
85240: PUSH
85241: LD_INT 30
85243: PUSH
85244: LD_INT 0
85246: PUSH
85247: EMPTY
85248: LIST
85249: LIST
85250: PUSH
85251: LD_INT 30
85253: PUSH
85254: LD_INT 1
85256: PUSH
85257: EMPTY
85258: LIST
85259: LIST
85260: PUSH
85261: EMPTY
85262: LIST
85263: LIST
85264: LIST
85265: PPUSH
85266: CALL_OW 72
85270: PUSH
85271: LD_EXP 172
85275: PUSH
85276: LD_VAR 0 2
85280: ARRAY
85281: PPUSH
85282: LD_INT 30
85284: PUSH
85285: LD_INT 3
85287: PUSH
85288: EMPTY
85289: LIST
85290: LIST
85291: PPUSH
85292: CALL_OW 72
85296: PUSH
85297: LD_EXP 172
85301: PUSH
85302: LD_VAR 0 2
85306: ARRAY
85307: PPUSH
85308: LD_INT 2
85310: PUSH
85311: LD_INT 30
85313: PUSH
85314: LD_INT 6
85316: PUSH
85317: EMPTY
85318: LIST
85319: LIST
85320: PUSH
85321: LD_INT 30
85323: PUSH
85324: LD_INT 7
85326: PUSH
85327: EMPTY
85328: LIST
85329: LIST
85330: PUSH
85331: LD_INT 30
85333: PUSH
85334: LD_INT 8
85336: PUSH
85337: EMPTY
85338: LIST
85339: LIST
85340: PUSH
85341: EMPTY
85342: LIST
85343: LIST
85344: LIST
85345: LIST
85346: PPUSH
85347: CALL_OW 72
85351: PUSH
85352: EMPTY
85353: LIST
85354: LIST
85355: LIST
85356: LIST
85357: ST_TO_ADDR
// for j = 1 to 4 do
85358: LD_ADDR_VAR 0 3
85362: PUSH
85363: DOUBLE
85364: LD_INT 1
85366: DEC
85367: ST_TO_ADDR
85368: LD_INT 4
85370: PUSH
85371: FOR_TO
85372: IFFALSE 85563
// begin if not tmp [ j ] then
85374: LD_VAR 0 4
85378: PUSH
85379: LD_VAR 0 3
85383: ARRAY
85384: NOT
85385: IFFALSE 85389
// continue ;
85387: GO 85371
// for p in tmp [ j ] do
85389: LD_ADDR_VAR 0 5
85393: PUSH
85394: LD_VAR 0 4
85398: PUSH
85399: LD_VAR 0 3
85403: ARRAY
85404: PUSH
85405: FOR_IN
85406: IFFALSE 85559
// begin if not b [ j ] then
85408: LD_VAR 0 6
85412: PUSH
85413: LD_VAR 0 3
85417: ARRAY
85418: NOT
85419: IFFALSE 85423
// break ;
85421: GO 85559
// e := 0 ;
85423: LD_ADDR_VAR 0 7
85427: PUSH
85428: LD_INT 0
85430: ST_TO_ADDR
// for k in b [ j ] do
85431: LD_ADDR_VAR 0 8
85435: PUSH
85436: LD_VAR 0 6
85440: PUSH
85441: LD_VAR 0 3
85445: ARRAY
85446: PUSH
85447: FOR_IN
85448: IFFALSE 85475
// if IsNotFull ( k ) then
85450: LD_VAR 0 8
85454: PPUSH
85455: CALL 21362 0 1
85459: IFFALSE 85473
// begin e := k ;
85461: LD_ADDR_VAR 0 7
85465: PUSH
85466: LD_VAR 0 8
85470: ST_TO_ADDR
// break ;
85471: GO 85475
// end ;
85473: GO 85447
85475: POP
85476: POP
// if e and not UnitGoingToBuilding ( p , e ) then
85477: LD_VAR 0 7
85481: PUSH
85482: LD_VAR 0 5
85486: PPUSH
85487: LD_VAR 0 7
85491: PPUSH
85492: CALL 53782 0 2
85496: NOT
85497: AND
85498: IFFALSE 85557
// begin if IsInUnit ( p ) then
85500: LD_VAR 0 5
85504: PPUSH
85505: CALL_OW 310
85509: IFFALSE 85520
// ComExitBuilding ( p ) ;
85511: LD_VAR 0 5
85515: PPUSH
85516: CALL_OW 122
// ComEnterUnit ( p , e ) ;
85520: LD_VAR 0 5
85524: PPUSH
85525: LD_VAR 0 7
85529: PPUSH
85530: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
85534: LD_VAR 0 5
85538: PPUSH
85539: LD_VAR 0 3
85543: PPUSH
85544: CALL_OW 183
// AddComExitBuilding ( p ) ;
85548: LD_VAR 0 5
85552: PPUSH
85553: CALL_OW 182
// end ; end ;
85557: GO 85405
85559: POP
85560: POP
// end ;
85561: GO 85371
85563: POP
85564: POP
// end ;
85565: GO 85126
85567: POP
85568: POP
// end ;
85569: LD_VAR 0 1
85573: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
85574: LD_INT 0
85576: PPUSH
85577: PPUSH
85578: PPUSH
85579: PPUSH
85580: PPUSH
85581: PPUSH
85582: PPUSH
85583: PPUSH
85584: PPUSH
85585: PPUSH
85586: PPUSH
85587: PPUSH
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
85588: LD_VAR 0 1
85592: NOT
85593: PUSH
85594: LD_EXP 172
85598: PUSH
85599: LD_VAR 0 1
85603: ARRAY
85604: NOT
85605: OR
85606: PUSH
85607: LD_EXP 172
85611: PUSH
85612: LD_VAR 0 1
85616: ARRAY
85617: PPUSH
85618: LD_INT 2
85620: PUSH
85621: LD_INT 30
85623: PUSH
85624: LD_INT 0
85626: PUSH
85627: EMPTY
85628: LIST
85629: LIST
85630: PUSH
85631: LD_INT 30
85633: PUSH
85634: LD_INT 1
85636: PUSH
85637: EMPTY
85638: LIST
85639: LIST
85640: PUSH
85641: EMPTY
85642: LIST
85643: LIST
85644: LIST
85645: PPUSH
85646: CALL_OW 72
85650: NOT
85651: OR
85652: IFFALSE 85656
// exit ;
85654: GO 89159
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
85656: LD_ADDR_VAR 0 4
85660: PUSH
85661: LD_EXP 172
85665: PUSH
85666: LD_VAR 0 1
85670: ARRAY
85671: PPUSH
85672: LD_INT 2
85674: PUSH
85675: LD_INT 25
85677: PUSH
85678: LD_INT 1
85680: PUSH
85681: EMPTY
85682: LIST
85683: LIST
85684: PUSH
85685: LD_INT 25
85687: PUSH
85688: LD_INT 2
85690: PUSH
85691: EMPTY
85692: LIST
85693: LIST
85694: PUSH
85695: LD_INT 25
85697: PUSH
85698: LD_INT 3
85700: PUSH
85701: EMPTY
85702: LIST
85703: LIST
85704: PUSH
85705: LD_INT 25
85707: PUSH
85708: LD_INT 4
85710: PUSH
85711: EMPTY
85712: LIST
85713: LIST
85714: PUSH
85715: LD_INT 25
85717: PUSH
85718: LD_INT 5
85720: PUSH
85721: EMPTY
85722: LIST
85723: LIST
85724: PUSH
85725: LD_INT 25
85727: PUSH
85728: LD_INT 8
85730: PUSH
85731: EMPTY
85732: LIST
85733: LIST
85734: PUSH
85735: LD_INT 25
85737: PUSH
85738: LD_INT 9
85740: PUSH
85741: EMPTY
85742: LIST
85743: LIST
85744: PUSH
85745: EMPTY
85746: LIST
85747: LIST
85748: LIST
85749: LIST
85750: LIST
85751: LIST
85752: LIST
85753: LIST
85754: PPUSH
85755: CALL_OW 72
85759: ST_TO_ADDR
// if not tmp then
85760: LD_VAR 0 4
85764: NOT
85765: IFFALSE 85769
// exit ;
85767: GO 89159
// for i in tmp do
85769: LD_ADDR_VAR 0 3
85773: PUSH
85774: LD_VAR 0 4
85778: PUSH
85779: FOR_IN
85780: IFFALSE 85811
// if GetTag ( i ) then
85782: LD_VAR 0 3
85786: PPUSH
85787: CALL_OW 110
85791: IFFALSE 85809
// tmp := tmp diff i ;
85793: LD_ADDR_VAR 0 4
85797: PUSH
85798: LD_VAR 0 4
85802: PUSH
85803: LD_VAR 0 3
85807: DIFF
85808: ST_TO_ADDR
85809: GO 85779
85811: POP
85812: POP
// if not tmp then
85813: LD_VAR 0 4
85817: NOT
85818: IFFALSE 85822
// exit ;
85820: GO 89159
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
85822: LD_ADDR_VAR 0 5
85826: PUSH
85827: LD_EXP 172
85831: PUSH
85832: LD_VAR 0 1
85836: ARRAY
85837: PPUSH
85838: LD_INT 2
85840: PUSH
85841: LD_INT 25
85843: PUSH
85844: LD_INT 1
85846: PUSH
85847: EMPTY
85848: LIST
85849: LIST
85850: PUSH
85851: LD_INT 25
85853: PUSH
85854: LD_INT 5
85856: PUSH
85857: EMPTY
85858: LIST
85859: LIST
85860: PUSH
85861: LD_INT 25
85863: PUSH
85864: LD_INT 8
85866: PUSH
85867: EMPTY
85868: LIST
85869: LIST
85870: PUSH
85871: LD_INT 25
85873: PUSH
85874: LD_INT 9
85876: PUSH
85877: EMPTY
85878: LIST
85879: LIST
85880: PUSH
85881: EMPTY
85882: LIST
85883: LIST
85884: LIST
85885: LIST
85886: LIST
85887: PPUSH
85888: CALL_OW 72
85892: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
85893: LD_ADDR_VAR 0 6
85897: PUSH
85898: LD_EXP 172
85902: PUSH
85903: LD_VAR 0 1
85907: ARRAY
85908: PPUSH
85909: LD_INT 25
85911: PUSH
85912: LD_INT 2
85914: PUSH
85915: EMPTY
85916: LIST
85917: LIST
85918: PPUSH
85919: CALL_OW 72
85923: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
85924: LD_ADDR_VAR 0 7
85928: PUSH
85929: LD_EXP 172
85933: PUSH
85934: LD_VAR 0 1
85938: ARRAY
85939: PPUSH
85940: LD_INT 25
85942: PUSH
85943: LD_INT 3
85945: PUSH
85946: EMPTY
85947: LIST
85948: LIST
85949: PPUSH
85950: CALL_OW 72
85954: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
85955: LD_ADDR_VAR 0 8
85959: PUSH
85960: LD_EXP 172
85964: PUSH
85965: LD_VAR 0 1
85969: ARRAY
85970: PPUSH
85971: LD_INT 25
85973: PUSH
85974: LD_INT 4
85976: PUSH
85977: EMPTY
85978: LIST
85979: LIST
85980: PUSH
85981: LD_INT 24
85983: PUSH
85984: LD_INT 251
85986: PUSH
85987: EMPTY
85988: LIST
85989: LIST
85990: PUSH
85991: EMPTY
85992: LIST
85993: LIST
85994: PPUSH
85995: CALL_OW 72
85999: ST_TO_ADDR
// if mc_scan [ base ] then
86000: LD_EXP 195
86004: PUSH
86005: LD_VAR 0 1
86009: ARRAY
86010: IFFALSE 86471
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
86012: LD_ADDR_EXP 214
86016: PUSH
86017: LD_EXP 214
86021: PPUSH
86022: LD_VAR 0 1
86026: PPUSH
86027: LD_INT 4
86029: PPUSH
86030: CALL_OW 1
86034: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
86035: LD_ADDR_VAR 0 12
86039: PUSH
86040: LD_EXP 172
86044: PUSH
86045: LD_VAR 0 1
86049: ARRAY
86050: PPUSH
86051: LD_INT 2
86053: PUSH
86054: LD_INT 30
86056: PUSH
86057: LD_INT 4
86059: PUSH
86060: EMPTY
86061: LIST
86062: LIST
86063: PUSH
86064: LD_INT 30
86066: PUSH
86067: LD_INT 5
86069: PUSH
86070: EMPTY
86071: LIST
86072: LIST
86073: PUSH
86074: EMPTY
86075: LIST
86076: LIST
86077: LIST
86078: PPUSH
86079: CALL_OW 72
86083: ST_TO_ADDR
// if not b then
86084: LD_VAR 0 12
86088: NOT
86089: IFFALSE 86093
// exit ;
86091: GO 89159
// p := [ ] ;
86093: LD_ADDR_VAR 0 11
86097: PUSH
86098: EMPTY
86099: ST_TO_ADDR
// if sci >= 2 then
86100: LD_VAR 0 8
86104: PUSH
86105: LD_INT 2
86107: GREATEREQUAL
86108: IFFALSE 86139
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
86110: LD_ADDR_VAR 0 8
86114: PUSH
86115: LD_VAR 0 8
86119: PUSH
86120: LD_INT 1
86122: ARRAY
86123: PUSH
86124: LD_VAR 0 8
86128: PUSH
86129: LD_INT 2
86131: ARRAY
86132: PUSH
86133: EMPTY
86134: LIST
86135: LIST
86136: ST_TO_ADDR
86137: GO 86200
// if sci = 1 then
86139: LD_VAR 0 8
86143: PUSH
86144: LD_INT 1
86146: EQUAL
86147: IFFALSE 86168
// sci := [ sci [ 1 ] ] else
86149: LD_ADDR_VAR 0 8
86153: PUSH
86154: LD_VAR 0 8
86158: PUSH
86159: LD_INT 1
86161: ARRAY
86162: PUSH
86163: EMPTY
86164: LIST
86165: ST_TO_ADDR
86166: GO 86200
// if sci = 0 then
86168: LD_VAR 0 8
86172: PUSH
86173: LD_INT 0
86175: EQUAL
86176: IFFALSE 86200
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
86178: LD_ADDR_VAR 0 11
86182: PUSH
86183: LD_VAR 0 4
86187: PPUSH
86188: LD_INT 4
86190: PPUSH
86191: CALL 53645 0 2
86195: PUSH
86196: LD_INT 1
86198: ARRAY
86199: ST_TO_ADDR
// if eng > 4 then
86200: LD_VAR 0 6
86204: PUSH
86205: LD_INT 4
86207: GREATER
86208: IFFALSE 86254
// for i = eng downto 4 do
86210: LD_ADDR_VAR 0 3
86214: PUSH
86215: DOUBLE
86216: LD_VAR 0 6
86220: INC
86221: ST_TO_ADDR
86222: LD_INT 4
86224: PUSH
86225: FOR_DOWNTO
86226: IFFALSE 86252
// eng := eng diff eng [ i ] ;
86228: LD_ADDR_VAR 0 6
86232: PUSH
86233: LD_VAR 0 6
86237: PUSH
86238: LD_VAR 0 6
86242: PUSH
86243: LD_VAR 0 3
86247: ARRAY
86248: DIFF
86249: ST_TO_ADDR
86250: GO 86225
86252: POP
86253: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
86254: LD_ADDR_VAR 0 4
86258: PUSH
86259: LD_VAR 0 4
86263: PUSH
86264: LD_VAR 0 5
86268: PUSH
86269: LD_VAR 0 6
86273: UNION
86274: PUSH
86275: LD_VAR 0 7
86279: UNION
86280: PUSH
86281: LD_VAR 0 8
86285: UNION
86286: DIFF
86287: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
86288: LD_ADDR_VAR 0 13
86292: PUSH
86293: LD_EXP 172
86297: PUSH
86298: LD_VAR 0 1
86302: ARRAY
86303: PPUSH
86304: LD_INT 2
86306: PUSH
86307: LD_INT 30
86309: PUSH
86310: LD_INT 32
86312: PUSH
86313: EMPTY
86314: LIST
86315: LIST
86316: PUSH
86317: LD_INT 30
86319: PUSH
86320: LD_INT 31
86322: PUSH
86323: EMPTY
86324: LIST
86325: LIST
86326: PUSH
86327: EMPTY
86328: LIST
86329: LIST
86330: LIST
86331: PPUSH
86332: CALL_OW 72
86336: PUSH
86337: LD_EXP 172
86341: PUSH
86342: LD_VAR 0 1
86346: ARRAY
86347: PPUSH
86348: LD_INT 2
86350: PUSH
86351: LD_INT 30
86353: PUSH
86354: LD_INT 4
86356: PUSH
86357: EMPTY
86358: LIST
86359: LIST
86360: PUSH
86361: LD_INT 30
86363: PUSH
86364: LD_INT 5
86366: PUSH
86367: EMPTY
86368: LIST
86369: LIST
86370: PUSH
86371: EMPTY
86372: LIST
86373: LIST
86374: LIST
86375: PPUSH
86376: CALL_OW 72
86380: PUSH
86381: LD_INT 6
86383: MUL
86384: PLUS
86385: ST_TO_ADDR
// if bcount < tmp then
86386: LD_VAR 0 13
86390: PUSH
86391: LD_VAR 0 4
86395: LESS
86396: IFFALSE 86442
// for i = tmp downto bcount do
86398: LD_ADDR_VAR 0 3
86402: PUSH
86403: DOUBLE
86404: LD_VAR 0 4
86408: INC
86409: ST_TO_ADDR
86410: LD_VAR 0 13
86414: PUSH
86415: FOR_DOWNTO
86416: IFFALSE 86440
// tmp := Delete ( tmp , tmp ) ;
86418: LD_ADDR_VAR 0 4
86422: PUSH
86423: LD_VAR 0 4
86427: PPUSH
86428: LD_VAR 0 4
86432: PPUSH
86433: CALL_OW 3
86437: ST_TO_ADDR
86438: GO 86415
86440: POP
86441: POP
// result := [ tmp , 0 , 0 , p ] ;
86442: LD_ADDR_VAR 0 2
86446: PUSH
86447: LD_VAR 0 4
86451: PUSH
86452: LD_INT 0
86454: PUSH
86455: LD_INT 0
86457: PUSH
86458: LD_VAR 0 11
86462: PUSH
86463: EMPTY
86464: LIST
86465: LIST
86466: LIST
86467: LIST
86468: ST_TO_ADDR
// exit ;
86469: GO 89159
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
86471: LD_EXP 172
86475: PUSH
86476: LD_VAR 0 1
86480: ARRAY
86481: PPUSH
86482: LD_INT 2
86484: PUSH
86485: LD_INT 30
86487: PUSH
86488: LD_INT 6
86490: PUSH
86491: EMPTY
86492: LIST
86493: LIST
86494: PUSH
86495: LD_INT 30
86497: PUSH
86498: LD_INT 7
86500: PUSH
86501: EMPTY
86502: LIST
86503: LIST
86504: PUSH
86505: LD_INT 30
86507: PUSH
86508: LD_INT 8
86510: PUSH
86511: EMPTY
86512: LIST
86513: LIST
86514: PUSH
86515: EMPTY
86516: LIST
86517: LIST
86518: LIST
86519: LIST
86520: PPUSH
86521: CALL_OW 72
86525: NOT
86526: PUSH
86527: LD_EXP 172
86531: PUSH
86532: LD_VAR 0 1
86536: ARRAY
86537: PPUSH
86538: LD_INT 30
86540: PUSH
86541: LD_INT 3
86543: PUSH
86544: EMPTY
86545: LIST
86546: LIST
86547: PPUSH
86548: CALL_OW 72
86552: NOT
86553: AND
86554: IFFALSE 86626
// begin if eng = tmp then
86556: LD_VAR 0 6
86560: PUSH
86561: LD_VAR 0 4
86565: EQUAL
86566: IFFALSE 86570
// exit ;
86568: GO 89159
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
86570: LD_ADDR_EXP 214
86574: PUSH
86575: LD_EXP 214
86579: PPUSH
86580: LD_VAR 0 1
86584: PPUSH
86585: LD_INT 1
86587: PPUSH
86588: CALL_OW 1
86592: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
86593: LD_ADDR_VAR 0 2
86597: PUSH
86598: LD_INT 0
86600: PUSH
86601: LD_VAR 0 4
86605: PUSH
86606: LD_VAR 0 6
86610: DIFF
86611: PUSH
86612: LD_INT 0
86614: PUSH
86615: LD_INT 0
86617: PUSH
86618: EMPTY
86619: LIST
86620: LIST
86621: LIST
86622: LIST
86623: ST_TO_ADDR
// exit ;
86624: GO 89159
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
86626: LD_EXP 199
86630: PUSH
86631: LD_EXP 198
86635: PUSH
86636: LD_VAR 0 1
86640: ARRAY
86641: ARRAY
86642: PUSH
86643: LD_EXP 172
86647: PUSH
86648: LD_VAR 0 1
86652: ARRAY
86653: PPUSH
86654: LD_INT 2
86656: PUSH
86657: LD_INT 30
86659: PUSH
86660: LD_INT 6
86662: PUSH
86663: EMPTY
86664: LIST
86665: LIST
86666: PUSH
86667: LD_INT 30
86669: PUSH
86670: LD_INT 7
86672: PUSH
86673: EMPTY
86674: LIST
86675: LIST
86676: PUSH
86677: LD_INT 30
86679: PUSH
86680: LD_INT 8
86682: PUSH
86683: EMPTY
86684: LIST
86685: LIST
86686: PUSH
86687: EMPTY
86688: LIST
86689: LIST
86690: LIST
86691: LIST
86692: PPUSH
86693: CALL_OW 72
86697: AND
86698: PUSH
86699: LD_EXP 172
86703: PUSH
86704: LD_VAR 0 1
86708: ARRAY
86709: PPUSH
86710: LD_INT 30
86712: PUSH
86713: LD_INT 3
86715: PUSH
86716: EMPTY
86717: LIST
86718: LIST
86719: PPUSH
86720: CALL_OW 72
86724: NOT
86725: AND
86726: IFFALSE 86940
// begin if sci >= 6 then
86728: LD_VAR 0 8
86732: PUSH
86733: LD_INT 6
86735: GREATEREQUAL
86736: IFFALSE 86740
// exit ;
86738: GO 89159
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
86740: LD_ADDR_EXP 214
86744: PUSH
86745: LD_EXP 214
86749: PPUSH
86750: LD_VAR 0 1
86754: PPUSH
86755: LD_INT 2
86757: PPUSH
86758: CALL_OW 1
86762: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
86763: LD_ADDR_VAR 0 9
86767: PUSH
86768: LD_VAR 0 4
86772: PUSH
86773: LD_VAR 0 8
86777: DIFF
86778: PPUSH
86779: LD_INT 4
86781: PPUSH
86782: CALL 53645 0 2
86786: ST_TO_ADDR
// p := [ ] ;
86787: LD_ADDR_VAR 0 11
86791: PUSH
86792: EMPTY
86793: ST_TO_ADDR
// if sci < 6 and sort > 6 then
86794: LD_VAR 0 8
86798: PUSH
86799: LD_INT 6
86801: LESS
86802: PUSH
86803: LD_VAR 0 9
86807: PUSH
86808: LD_INT 6
86810: GREATER
86811: AND
86812: IFFALSE 86893
// begin for i = 1 to 6 - sci do
86814: LD_ADDR_VAR 0 3
86818: PUSH
86819: DOUBLE
86820: LD_INT 1
86822: DEC
86823: ST_TO_ADDR
86824: LD_INT 6
86826: PUSH
86827: LD_VAR 0 8
86831: MINUS
86832: PUSH
86833: FOR_TO
86834: IFFALSE 86889
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
86836: LD_ADDR_VAR 0 11
86840: PUSH
86841: LD_VAR 0 11
86845: PPUSH
86846: LD_VAR 0 11
86850: PUSH
86851: LD_INT 1
86853: PLUS
86854: PPUSH
86855: LD_VAR 0 9
86859: PUSH
86860: LD_INT 1
86862: ARRAY
86863: PPUSH
86864: CALL_OW 2
86868: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
86869: LD_ADDR_VAR 0 9
86873: PUSH
86874: LD_VAR 0 9
86878: PPUSH
86879: LD_INT 1
86881: PPUSH
86882: CALL_OW 3
86886: ST_TO_ADDR
// end ;
86887: GO 86833
86889: POP
86890: POP
// end else
86891: GO 86913
// if sort then
86893: LD_VAR 0 9
86897: IFFALSE 86913
// p := sort [ 1 ] ;
86899: LD_ADDR_VAR 0 11
86903: PUSH
86904: LD_VAR 0 9
86908: PUSH
86909: LD_INT 1
86911: ARRAY
86912: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
86913: LD_ADDR_VAR 0 2
86917: PUSH
86918: LD_INT 0
86920: PUSH
86921: LD_INT 0
86923: PUSH
86924: LD_INT 0
86926: PUSH
86927: LD_VAR 0 11
86931: PUSH
86932: EMPTY
86933: LIST
86934: LIST
86935: LIST
86936: LIST
86937: ST_TO_ADDR
// exit ;
86938: GO 89159
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
86940: LD_EXP 199
86944: PUSH
86945: LD_EXP 198
86949: PUSH
86950: LD_VAR 0 1
86954: ARRAY
86955: ARRAY
86956: PUSH
86957: LD_EXP 172
86961: PUSH
86962: LD_VAR 0 1
86966: ARRAY
86967: PPUSH
86968: LD_INT 2
86970: PUSH
86971: LD_INT 30
86973: PUSH
86974: LD_INT 6
86976: PUSH
86977: EMPTY
86978: LIST
86979: LIST
86980: PUSH
86981: LD_INT 30
86983: PUSH
86984: LD_INT 7
86986: PUSH
86987: EMPTY
86988: LIST
86989: LIST
86990: PUSH
86991: LD_INT 30
86993: PUSH
86994: LD_INT 8
86996: PUSH
86997: EMPTY
86998: LIST
86999: LIST
87000: PUSH
87001: EMPTY
87002: LIST
87003: LIST
87004: LIST
87005: LIST
87006: PPUSH
87007: CALL_OW 72
87011: AND
87012: PUSH
87013: LD_EXP 172
87017: PUSH
87018: LD_VAR 0 1
87022: ARRAY
87023: PPUSH
87024: LD_INT 30
87026: PUSH
87027: LD_INT 3
87029: PUSH
87030: EMPTY
87031: LIST
87032: LIST
87033: PPUSH
87034: CALL_OW 72
87038: AND
87039: IFFALSE 87773
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
87041: LD_ADDR_EXP 214
87045: PUSH
87046: LD_EXP 214
87050: PPUSH
87051: LD_VAR 0 1
87055: PPUSH
87056: LD_INT 3
87058: PPUSH
87059: CALL_OW 1
87063: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
87064: LD_ADDR_VAR 0 2
87068: PUSH
87069: LD_INT 0
87071: PUSH
87072: LD_INT 0
87074: PUSH
87075: LD_INT 0
87077: PUSH
87078: LD_INT 0
87080: PUSH
87081: EMPTY
87082: LIST
87083: LIST
87084: LIST
87085: LIST
87086: ST_TO_ADDR
// if not eng then
87087: LD_VAR 0 6
87091: NOT
87092: IFFALSE 87155
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
87094: LD_ADDR_VAR 0 11
87098: PUSH
87099: LD_VAR 0 4
87103: PPUSH
87104: LD_INT 2
87106: PPUSH
87107: CALL 53645 0 2
87111: PUSH
87112: LD_INT 1
87114: ARRAY
87115: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
87116: LD_ADDR_VAR 0 2
87120: PUSH
87121: LD_VAR 0 2
87125: PPUSH
87126: LD_INT 2
87128: PPUSH
87129: LD_VAR 0 11
87133: PPUSH
87134: CALL_OW 1
87138: ST_TO_ADDR
// tmp := tmp diff p ;
87139: LD_ADDR_VAR 0 4
87143: PUSH
87144: LD_VAR 0 4
87148: PUSH
87149: LD_VAR 0 11
87153: DIFF
87154: ST_TO_ADDR
// end ; if tmp and sci < 6 then
87155: LD_VAR 0 4
87159: PUSH
87160: LD_VAR 0 8
87164: PUSH
87165: LD_INT 6
87167: LESS
87168: AND
87169: IFFALSE 87357
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
87171: LD_ADDR_VAR 0 9
87175: PUSH
87176: LD_VAR 0 4
87180: PUSH
87181: LD_VAR 0 8
87185: PUSH
87186: LD_VAR 0 7
87190: UNION
87191: DIFF
87192: PPUSH
87193: LD_INT 4
87195: PPUSH
87196: CALL 53645 0 2
87200: ST_TO_ADDR
// p := [ ] ;
87201: LD_ADDR_VAR 0 11
87205: PUSH
87206: EMPTY
87207: ST_TO_ADDR
// if sort then
87208: LD_VAR 0 9
87212: IFFALSE 87328
// for i = 1 to 6 - sci do
87214: LD_ADDR_VAR 0 3
87218: PUSH
87219: DOUBLE
87220: LD_INT 1
87222: DEC
87223: ST_TO_ADDR
87224: LD_INT 6
87226: PUSH
87227: LD_VAR 0 8
87231: MINUS
87232: PUSH
87233: FOR_TO
87234: IFFALSE 87326
// begin if i = sort then
87236: LD_VAR 0 3
87240: PUSH
87241: LD_VAR 0 9
87245: EQUAL
87246: IFFALSE 87250
// break ;
87248: GO 87326
// if GetClass ( i ) = 4 then
87250: LD_VAR 0 3
87254: PPUSH
87255: CALL_OW 257
87259: PUSH
87260: LD_INT 4
87262: EQUAL
87263: IFFALSE 87267
// continue ;
87265: GO 87233
// p := Insert ( p , p + 1 , sort [ i ] ) ;
87267: LD_ADDR_VAR 0 11
87271: PUSH
87272: LD_VAR 0 11
87276: PPUSH
87277: LD_VAR 0 11
87281: PUSH
87282: LD_INT 1
87284: PLUS
87285: PPUSH
87286: LD_VAR 0 9
87290: PUSH
87291: LD_VAR 0 3
87295: ARRAY
87296: PPUSH
87297: CALL_OW 2
87301: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
87302: LD_ADDR_VAR 0 4
87306: PUSH
87307: LD_VAR 0 4
87311: PUSH
87312: LD_VAR 0 9
87316: PUSH
87317: LD_VAR 0 3
87321: ARRAY
87322: DIFF
87323: ST_TO_ADDR
// end ;
87324: GO 87233
87326: POP
87327: POP
// if p then
87328: LD_VAR 0 11
87332: IFFALSE 87357
// result := Replace ( result , 4 , p ) ;
87334: LD_ADDR_VAR 0 2
87338: PUSH
87339: LD_VAR 0 2
87343: PPUSH
87344: LD_INT 4
87346: PPUSH
87347: LD_VAR 0 11
87351: PPUSH
87352: CALL_OW 1
87356: ST_TO_ADDR
// end ; if tmp and mech < 6 then
87357: LD_VAR 0 4
87361: PUSH
87362: LD_VAR 0 7
87366: PUSH
87367: LD_INT 6
87369: LESS
87370: AND
87371: IFFALSE 87559
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
87373: LD_ADDR_VAR 0 9
87377: PUSH
87378: LD_VAR 0 4
87382: PUSH
87383: LD_VAR 0 8
87387: PUSH
87388: LD_VAR 0 7
87392: UNION
87393: DIFF
87394: PPUSH
87395: LD_INT 3
87397: PPUSH
87398: CALL 53645 0 2
87402: ST_TO_ADDR
// p := [ ] ;
87403: LD_ADDR_VAR 0 11
87407: PUSH
87408: EMPTY
87409: ST_TO_ADDR
// if sort then
87410: LD_VAR 0 9
87414: IFFALSE 87530
// for i = 1 to 6 - mech do
87416: LD_ADDR_VAR 0 3
87420: PUSH
87421: DOUBLE
87422: LD_INT 1
87424: DEC
87425: ST_TO_ADDR
87426: LD_INT 6
87428: PUSH
87429: LD_VAR 0 7
87433: MINUS
87434: PUSH
87435: FOR_TO
87436: IFFALSE 87528
// begin if i = sort then
87438: LD_VAR 0 3
87442: PUSH
87443: LD_VAR 0 9
87447: EQUAL
87448: IFFALSE 87452
// break ;
87450: GO 87528
// if GetClass ( i ) = 3 then
87452: LD_VAR 0 3
87456: PPUSH
87457: CALL_OW 257
87461: PUSH
87462: LD_INT 3
87464: EQUAL
87465: IFFALSE 87469
// continue ;
87467: GO 87435
// p := Insert ( p , p + 1 , sort [ i ] ) ;
87469: LD_ADDR_VAR 0 11
87473: PUSH
87474: LD_VAR 0 11
87478: PPUSH
87479: LD_VAR 0 11
87483: PUSH
87484: LD_INT 1
87486: PLUS
87487: PPUSH
87488: LD_VAR 0 9
87492: PUSH
87493: LD_VAR 0 3
87497: ARRAY
87498: PPUSH
87499: CALL_OW 2
87503: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
87504: LD_ADDR_VAR 0 4
87508: PUSH
87509: LD_VAR 0 4
87513: PUSH
87514: LD_VAR 0 9
87518: PUSH
87519: LD_VAR 0 3
87523: ARRAY
87524: DIFF
87525: ST_TO_ADDR
// end ;
87526: GO 87435
87528: POP
87529: POP
// if p then
87530: LD_VAR 0 11
87534: IFFALSE 87559
// result := Replace ( result , 3 , p ) ;
87536: LD_ADDR_VAR 0 2
87540: PUSH
87541: LD_VAR 0 2
87545: PPUSH
87546: LD_INT 3
87548: PPUSH
87549: LD_VAR 0 11
87553: PPUSH
87554: CALL_OW 1
87558: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
87559: LD_VAR 0 4
87563: PUSH
87564: LD_INT 6
87566: GREATER
87567: PUSH
87568: LD_VAR 0 6
87572: PUSH
87573: LD_INT 6
87575: LESS
87576: AND
87577: IFFALSE 87771
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
87579: LD_ADDR_VAR 0 9
87583: PUSH
87584: LD_VAR 0 4
87588: PUSH
87589: LD_VAR 0 8
87593: PUSH
87594: LD_VAR 0 7
87598: UNION
87599: PUSH
87600: LD_VAR 0 6
87604: UNION
87605: DIFF
87606: PPUSH
87607: LD_INT 2
87609: PPUSH
87610: CALL 53645 0 2
87614: ST_TO_ADDR
// p := [ ] ;
87615: LD_ADDR_VAR 0 11
87619: PUSH
87620: EMPTY
87621: ST_TO_ADDR
// if sort then
87622: LD_VAR 0 9
87626: IFFALSE 87742
// for i = 1 to 6 - eng do
87628: LD_ADDR_VAR 0 3
87632: PUSH
87633: DOUBLE
87634: LD_INT 1
87636: DEC
87637: ST_TO_ADDR
87638: LD_INT 6
87640: PUSH
87641: LD_VAR 0 6
87645: MINUS
87646: PUSH
87647: FOR_TO
87648: IFFALSE 87740
// begin if i = sort then
87650: LD_VAR 0 3
87654: PUSH
87655: LD_VAR 0 9
87659: EQUAL
87660: IFFALSE 87664
// break ;
87662: GO 87740
// if GetClass ( i ) = 2 then
87664: LD_VAR 0 3
87668: PPUSH
87669: CALL_OW 257
87673: PUSH
87674: LD_INT 2
87676: EQUAL
87677: IFFALSE 87681
// continue ;
87679: GO 87647
// p := Insert ( p , p + 1 , sort [ i ] ) ;
87681: LD_ADDR_VAR 0 11
87685: PUSH
87686: LD_VAR 0 11
87690: PPUSH
87691: LD_VAR 0 11
87695: PUSH
87696: LD_INT 1
87698: PLUS
87699: PPUSH
87700: LD_VAR 0 9
87704: PUSH
87705: LD_VAR 0 3
87709: ARRAY
87710: PPUSH
87711: CALL_OW 2
87715: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
87716: LD_ADDR_VAR 0 4
87720: PUSH
87721: LD_VAR 0 4
87725: PUSH
87726: LD_VAR 0 9
87730: PUSH
87731: LD_VAR 0 3
87735: ARRAY
87736: DIFF
87737: ST_TO_ADDR
// end ;
87738: GO 87647
87740: POP
87741: POP
// if p then
87742: LD_VAR 0 11
87746: IFFALSE 87771
// result := Replace ( result , 2 , p ) ;
87748: LD_ADDR_VAR 0 2
87752: PUSH
87753: LD_VAR 0 2
87757: PPUSH
87758: LD_INT 2
87760: PPUSH
87761: LD_VAR 0 11
87765: PPUSH
87766: CALL_OW 1
87770: ST_TO_ADDR
// end ; exit ;
87771: GO 89159
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
87773: LD_EXP 199
87777: PUSH
87778: LD_EXP 198
87782: PUSH
87783: LD_VAR 0 1
87787: ARRAY
87788: ARRAY
87789: NOT
87790: PUSH
87791: LD_EXP 172
87795: PUSH
87796: LD_VAR 0 1
87800: ARRAY
87801: PPUSH
87802: LD_INT 30
87804: PUSH
87805: LD_INT 3
87807: PUSH
87808: EMPTY
87809: LIST
87810: LIST
87811: PPUSH
87812: CALL_OW 72
87816: AND
87817: PUSH
87818: LD_EXP 177
87822: PUSH
87823: LD_VAR 0 1
87827: ARRAY
87828: AND
87829: IFFALSE 88437
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
87831: LD_ADDR_EXP 214
87835: PUSH
87836: LD_EXP 214
87840: PPUSH
87841: LD_VAR 0 1
87845: PPUSH
87846: LD_INT 5
87848: PPUSH
87849: CALL_OW 1
87853: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
87854: LD_ADDR_VAR 0 2
87858: PUSH
87859: LD_INT 0
87861: PUSH
87862: LD_INT 0
87864: PUSH
87865: LD_INT 0
87867: PUSH
87868: LD_INT 0
87870: PUSH
87871: EMPTY
87872: LIST
87873: LIST
87874: LIST
87875: LIST
87876: ST_TO_ADDR
// if sci > 1 then
87877: LD_VAR 0 8
87881: PUSH
87882: LD_INT 1
87884: GREATER
87885: IFFALSE 87913
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
87887: LD_ADDR_VAR 0 4
87891: PUSH
87892: LD_VAR 0 4
87896: PUSH
87897: LD_VAR 0 8
87901: PUSH
87902: LD_VAR 0 8
87906: PUSH
87907: LD_INT 1
87909: ARRAY
87910: DIFF
87911: DIFF
87912: ST_TO_ADDR
// if tmp and not sci then
87913: LD_VAR 0 4
87917: PUSH
87918: LD_VAR 0 8
87922: NOT
87923: AND
87924: IFFALSE 87993
// begin sort := SortBySkill ( tmp , 4 ) ;
87926: LD_ADDR_VAR 0 9
87930: PUSH
87931: LD_VAR 0 4
87935: PPUSH
87936: LD_INT 4
87938: PPUSH
87939: CALL 53645 0 2
87943: ST_TO_ADDR
// if sort then
87944: LD_VAR 0 9
87948: IFFALSE 87964
// p := sort [ 1 ] ;
87950: LD_ADDR_VAR 0 11
87954: PUSH
87955: LD_VAR 0 9
87959: PUSH
87960: LD_INT 1
87962: ARRAY
87963: ST_TO_ADDR
// if p then
87964: LD_VAR 0 11
87968: IFFALSE 87993
// result := Replace ( result , 4 , p ) ;
87970: LD_ADDR_VAR 0 2
87974: PUSH
87975: LD_VAR 0 2
87979: PPUSH
87980: LD_INT 4
87982: PPUSH
87983: LD_VAR 0 11
87987: PPUSH
87988: CALL_OW 1
87992: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
87993: LD_ADDR_VAR 0 4
87997: PUSH
87998: LD_VAR 0 4
88002: PUSH
88003: LD_VAR 0 7
88007: DIFF
88008: ST_TO_ADDR
// if tmp and mech < 6 then
88009: LD_VAR 0 4
88013: PUSH
88014: LD_VAR 0 7
88018: PUSH
88019: LD_INT 6
88021: LESS
88022: AND
88023: IFFALSE 88211
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
88025: LD_ADDR_VAR 0 9
88029: PUSH
88030: LD_VAR 0 4
88034: PUSH
88035: LD_VAR 0 8
88039: PUSH
88040: LD_VAR 0 7
88044: UNION
88045: DIFF
88046: PPUSH
88047: LD_INT 3
88049: PPUSH
88050: CALL 53645 0 2
88054: ST_TO_ADDR
// p := [ ] ;
88055: LD_ADDR_VAR 0 11
88059: PUSH
88060: EMPTY
88061: ST_TO_ADDR
// if sort then
88062: LD_VAR 0 9
88066: IFFALSE 88182
// for i = 1 to 6 - mech do
88068: LD_ADDR_VAR 0 3
88072: PUSH
88073: DOUBLE
88074: LD_INT 1
88076: DEC
88077: ST_TO_ADDR
88078: LD_INT 6
88080: PUSH
88081: LD_VAR 0 7
88085: MINUS
88086: PUSH
88087: FOR_TO
88088: IFFALSE 88180
// begin if i = sort then
88090: LD_VAR 0 3
88094: PUSH
88095: LD_VAR 0 9
88099: EQUAL
88100: IFFALSE 88104
// break ;
88102: GO 88180
// if GetClass ( i ) = 3 then
88104: LD_VAR 0 3
88108: PPUSH
88109: CALL_OW 257
88113: PUSH
88114: LD_INT 3
88116: EQUAL
88117: IFFALSE 88121
// continue ;
88119: GO 88087
// p := Insert ( p , p + 1 , sort [ i ] ) ;
88121: LD_ADDR_VAR 0 11
88125: PUSH
88126: LD_VAR 0 11
88130: PPUSH
88131: LD_VAR 0 11
88135: PUSH
88136: LD_INT 1
88138: PLUS
88139: PPUSH
88140: LD_VAR 0 9
88144: PUSH
88145: LD_VAR 0 3
88149: ARRAY
88150: PPUSH
88151: CALL_OW 2
88155: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
88156: LD_ADDR_VAR 0 4
88160: PUSH
88161: LD_VAR 0 4
88165: PUSH
88166: LD_VAR 0 9
88170: PUSH
88171: LD_VAR 0 3
88175: ARRAY
88176: DIFF
88177: ST_TO_ADDR
// end ;
88178: GO 88087
88180: POP
88181: POP
// if p then
88182: LD_VAR 0 11
88186: IFFALSE 88211
// result := Replace ( result , 3 , p ) ;
88188: LD_ADDR_VAR 0 2
88192: PUSH
88193: LD_VAR 0 2
88197: PPUSH
88198: LD_INT 3
88200: PPUSH
88201: LD_VAR 0 11
88205: PPUSH
88206: CALL_OW 1
88210: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
88211: LD_ADDR_VAR 0 4
88215: PUSH
88216: LD_VAR 0 4
88220: PUSH
88221: LD_VAR 0 6
88225: DIFF
88226: ST_TO_ADDR
// if tmp and eng < 6 then
88227: LD_VAR 0 4
88231: PUSH
88232: LD_VAR 0 6
88236: PUSH
88237: LD_INT 6
88239: LESS
88240: AND
88241: IFFALSE 88435
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
88243: LD_ADDR_VAR 0 9
88247: PUSH
88248: LD_VAR 0 4
88252: PUSH
88253: LD_VAR 0 8
88257: PUSH
88258: LD_VAR 0 7
88262: UNION
88263: PUSH
88264: LD_VAR 0 6
88268: UNION
88269: DIFF
88270: PPUSH
88271: LD_INT 2
88273: PPUSH
88274: CALL 53645 0 2
88278: ST_TO_ADDR
// p := [ ] ;
88279: LD_ADDR_VAR 0 11
88283: PUSH
88284: EMPTY
88285: ST_TO_ADDR
// if sort then
88286: LD_VAR 0 9
88290: IFFALSE 88406
// for i = 1 to 6 - eng do
88292: LD_ADDR_VAR 0 3
88296: PUSH
88297: DOUBLE
88298: LD_INT 1
88300: DEC
88301: ST_TO_ADDR
88302: LD_INT 6
88304: PUSH
88305: LD_VAR 0 6
88309: MINUS
88310: PUSH
88311: FOR_TO
88312: IFFALSE 88404
// begin if i = sort then
88314: LD_VAR 0 3
88318: PUSH
88319: LD_VAR 0 9
88323: EQUAL
88324: IFFALSE 88328
// break ;
88326: GO 88404
// if GetClass ( i ) = 2 then
88328: LD_VAR 0 3
88332: PPUSH
88333: CALL_OW 257
88337: PUSH
88338: LD_INT 2
88340: EQUAL
88341: IFFALSE 88345
// continue ;
88343: GO 88311
// p := Insert ( p , p + 1 , sort [ i ] ) ;
88345: LD_ADDR_VAR 0 11
88349: PUSH
88350: LD_VAR 0 11
88354: PPUSH
88355: LD_VAR 0 11
88359: PUSH
88360: LD_INT 1
88362: PLUS
88363: PPUSH
88364: LD_VAR 0 9
88368: PUSH
88369: LD_VAR 0 3
88373: ARRAY
88374: PPUSH
88375: CALL_OW 2
88379: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
88380: LD_ADDR_VAR 0 4
88384: PUSH
88385: LD_VAR 0 4
88389: PUSH
88390: LD_VAR 0 9
88394: PUSH
88395: LD_VAR 0 3
88399: ARRAY
88400: DIFF
88401: ST_TO_ADDR
// end ;
88402: GO 88311
88404: POP
88405: POP
// if p then
88406: LD_VAR 0 11
88410: IFFALSE 88435
// result := Replace ( result , 2 , p ) ;
88412: LD_ADDR_VAR 0 2
88416: PUSH
88417: LD_VAR 0 2
88421: PPUSH
88422: LD_INT 2
88424: PPUSH
88425: LD_VAR 0 11
88429: PPUSH
88430: CALL_OW 1
88434: ST_TO_ADDR
// end ; exit ;
88435: GO 89159
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
88437: LD_EXP 199
88441: PUSH
88442: LD_EXP 198
88446: PUSH
88447: LD_VAR 0 1
88451: ARRAY
88452: ARRAY
88453: NOT
88454: PUSH
88455: LD_EXP 172
88459: PUSH
88460: LD_VAR 0 1
88464: ARRAY
88465: PPUSH
88466: LD_INT 30
88468: PUSH
88469: LD_INT 3
88471: PUSH
88472: EMPTY
88473: LIST
88474: LIST
88475: PPUSH
88476: CALL_OW 72
88480: AND
88481: PUSH
88482: LD_EXP 177
88486: PUSH
88487: LD_VAR 0 1
88491: ARRAY
88492: NOT
88493: AND
88494: IFFALSE 89159
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
88496: LD_ADDR_EXP 214
88500: PUSH
88501: LD_EXP 214
88505: PPUSH
88506: LD_VAR 0 1
88510: PPUSH
88511: LD_INT 6
88513: PPUSH
88514: CALL_OW 1
88518: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
88519: LD_ADDR_VAR 0 2
88523: PUSH
88524: LD_INT 0
88526: PUSH
88527: LD_INT 0
88529: PUSH
88530: LD_INT 0
88532: PUSH
88533: LD_INT 0
88535: PUSH
88536: EMPTY
88537: LIST
88538: LIST
88539: LIST
88540: LIST
88541: ST_TO_ADDR
// if sci >= 1 then
88542: LD_VAR 0 8
88546: PUSH
88547: LD_INT 1
88549: GREATEREQUAL
88550: IFFALSE 88572
// tmp := tmp diff sci [ 1 ] ;
88552: LD_ADDR_VAR 0 4
88556: PUSH
88557: LD_VAR 0 4
88561: PUSH
88562: LD_VAR 0 8
88566: PUSH
88567: LD_INT 1
88569: ARRAY
88570: DIFF
88571: ST_TO_ADDR
// if tmp and not sci then
88572: LD_VAR 0 4
88576: PUSH
88577: LD_VAR 0 8
88581: NOT
88582: AND
88583: IFFALSE 88652
// begin sort := SortBySkill ( tmp , 4 ) ;
88585: LD_ADDR_VAR 0 9
88589: PUSH
88590: LD_VAR 0 4
88594: PPUSH
88595: LD_INT 4
88597: PPUSH
88598: CALL 53645 0 2
88602: ST_TO_ADDR
// if sort then
88603: LD_VAR 0 9
88607: IFFALSE 88623
// p := sort [ 1 ] ;
88609: LD_ADDR_VAR 0 11
88613: PUSH
88614: LD_VAR 0 9
88618: PUSH
88619: LD_INT 1
88621: ARRAY
88622: ST_TO_ADDR
// if p then
88623: LD_VAR 0 11
88627: IFFALSE 88652
// result := Replace ( result , 4 , p ) ;
88629: LD_ADDR_VAR 0 2
88633: PUSH
88634: LD_VAR 0 2
88638: PPUSH
88639: LD_INT 4
88641: PPUSH
88642: LD_VAR 0 11
88646: PPUSH
88647: CALL_OW 1
88651: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
88652: LD_ADDR_VAR 0 4
88656: PUSH
88657: LD_VAR 0 4
88661: PUSH
88662: LD_VAR 0 7
88666: DIFF
88667: ST_TO_ADDR
// if tmp and mech < 6 then
88668: LD_VAR 0 4
88672: PUSH
88673: LD_VAR 0 7
88677: PUSH
88678: LD_INT 6
88680: LESS
88681: AND
88682: IFFALSE 88864
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
88684: LD_ADDR_VAR 0 9
88688: PUSH
88689: LD_VAR 0 4
88693: PUSH
88694: LD_VAR 0 7
88698: DIFF
88699: PPUSH
88700: LD_INT 3
88702: PPUSH
88703: CALL 53645 0 2
88707: ST_TO_ADDR
// p := [ ] ;
88708: LD_ADDR_VAR 0 11
88712: PUSH
88713: EMPTY
88714: ST_TO_ADDR
// if sort then
88715: LD_VAR 0 9
88719: IFFALSE 88835
// for i = 1 to 6 - mech do
88721: LD_ADDR_VAR 0 3
88725: PUSH
88726: DOUBLE
88727: LD_INT 1
88729: DEC
88730: ST_TO_ADDR
88731: LD_INT 6
88733: PUSH
88734: LD_VAR 0 7
88738: MINUS
88739: PUSH
88740: FOR_TO
88741: IFFALSE 88833
// begin if i = sort then
88743: LD_VAR 0 3
88747: PUSH
88748: LD_VAR 0 9
88752: EQUAL
88753: IFFALSE 88757
// break ;
88755: GO 88833
// if GetClass ( i ) = 3 then
88757: LD_VAR 0 3
88761: PPUSH
88762: CALL_OW 257
88766: PUSH
88767: LD_INT 3
88769: EQUAL
88770: IFFALSE 88774
// continue ;
88772: GO 88740
// p := Insert ( p , p + 1 , sort [ i ] ) ;
88774: LD_ADDR_VAR 0 11
88778: PUSH
88779: LD_VAR 0 11
88783: PPUSH
88784: LD_VAR 0 11
88788: PUSH
88789: LD_INT 1
88791: PLUS
88792: PPUSH
88793: LD_VAR 0 9
88797: PUSH
88798: LD_VAR 0 3
88802: ARRAY
88803: PPUSH
88804: CALL_OW 2
88808: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
88809: LD_ADDR_VAR 0 4
88813: PUSH
88814: LD_VAR 0 4
88818: PUSH
88819: LD_VAR 0 9
88823: PUSH
88824: LD_VAR 0 3
88828: ARRAY
88829: DIFF
88830: ST_TO_ADDR
// end ;
88831: GO 88740
88833: POP
88834: POP
// if p then
88835: LD_VAR 0 11
88839: IFFALSE 88864
// result := Replace ( result , 3 , p ) ;
88841: LD_ADDR_VAR 0 2
88845: PUSH
88846: LD_VAR 0 2
88850: PPUSH
88851: LD_INT 3
88853: PPUSH
88854: LD_VAR 0 11
88858: PPUSH
88859: CALL_OW 1
88863: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
88864: LD_ADDR_VAR 0 4
88868: PUSH
88869: LD_VAR 0 4
88873: PUSH
88874: LD_VAR 0 6
88878: DIFF
88879: ST_TO_ADDR
// if tmp and eng < 4 then
88880: LD_VAR 0 4
88884: PUSH
88885: LD_VAR 0 6
88889: PUSH
88890: LD_INT 4
88892: LESS
88893: AND
88894: IFFALSE 89084
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
88896: LD_ADDR_VAR 0 9
88900: PUSH
88901: LD_VAR 0 4
88905: PUSH
88906: LD_VAR 0 7
88910: PUSH
88911: LD_VAR 0 6
88915: UNION
88916: DIFF
88917: PPUSH
88918: LD_INT 2
88920: PPUSH
88921: CALL 53645 0 2
88925: ST_TO_ADDR
// p := [ ] ;
88926: LD_ADDR_VAR 0 11
88930: PUSH
88931: EMPTY
88932: ST_TO_ADDR
// if sort then
88933: LD_VAR 0 9
88937: IFFALSE 89053
// for i = 1 to 4 - eng do
88939: LD_ADDR_VAR 0 3
88943: PUSH
88944: DOUBLE
88945: LD_INT 1
88947: DEC
88948: ST_TO_ADDR
88949: LD_INT 4
88951: PUSH
88952: LD_VAR 0 6
88956: MINUS
88957: PUSH
88958: FOR_TO
88959: IFFALSE 89051
// begin if i = sort then
88961: LD_VAR 0 3
88965: PUSH
88966: LD_VAR 0 9
88970: EQUAL
88971: IFFALSE 88975
// break ;
88973: GO 89051
// if GetClass ( i ) = 2 then
88975: LD_VAR 0 3
88979: PPUSH
88980: CALL_OW 257
88984: PUSH
88985: LD_INT 2
88987: EQUAL
88988: IFFALSE 88992
// continue ;
88990: GO 88958
// p := Insert ( p , p + 1 , sort [ i ] ) ;
88992: LD_ADDR_VAR 0 11
88996: PUSH
88997: LD_VAR 0 11
89001: PPUSH
89002: LD_VAR 0 11
89006: PUSH
89007: LD_INT 1
89009: PLUS
89010: PPUSH
89011: LD_VAR 0 9
89015: PUSH
89016: LD_VAR 0 3
89020: ARRAY
89021: PPUSH
89022: CALL_OW 2
89026: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
89027: LD_ADDR_VAR 0 4
89031: PUSH
89032: LD_VAR 0 4
89036: PUSH
89037: LD_VAR 0 9
89041: PUSH
89042: LD_VAR 0 3
89046: ARRAY
89047: DIFF
89048: ST_TO_ADDR
// end ;
89049: GO 88958
89051: POP
89052: POP
// if p then
89053: LD_VAR 0 11
89057: IFFALSE 89082
// result := Replace ( result , 2 , p ) ;
89059: LD_ADDR_VAR 0 2
89063: PUSH
89064: LD_VAR 0 2
89068: PPUSH
89069: LD_INT 2
89071: PPUSH
89072: LD_VAR 0 11
89076: PPUSH
89077: CALL_OW 1
89081: ST_TO_ADDR
// end else
89082: GO 89128
// for i = eng downto 5 do
89084: LD_ADDR_VAR 0 3
89088: PUSH
89089: DOUBLE
89090: LD_VAR 0 6
89094: INC
89095: ST_TO_ADDR
89096: LD_INT 5
89098: PUSH
89099: FOR_DOWNTO
89100: IFFALSE 89126
// tmp := tmp union eng [ i ] ;
89102: LD_ADDR_VAR 0 4
89106: PUSH
89107: LD_VAR 0 4
89111: PUSH
89112: LD_VAR 0 6
89116: PUSH
89117: LD_VAR 0 3
89121: ARRAY
89122: UNION
89123: ST_TO_ADDR
89124: GO 89099
89126: POP
89127: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
89128: LD_ADDR_VAR 0 2
89132: PUSH
89133: LD_VAR 0 2
89137: PPUSH
89138: LD_INT 1
89140: PPUSH
89141: LD_VAR 0 4
89145: PUSH
89146: LD_VAR 0 5
89150: DIFF
89151: PPUSH
89152: CALL_OW 1
89156: ST_TO_ADDR
// exit ;
89157: GO 89159
// end ; end ;
89159: LD_VAR 0 2
89163: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
89164: LD_INT 0
89166: PPUSH
89167: PPUSH
89168: PPUSH
// if not mc_bases then
89169: LD_EXP 172
89173: NOT
89174: IFFALSE 89178
// exit ;
89176: GO 89284
// for i = 1 to mc_bases do
89178: LD_ADDR_VAR 0 2
89182: PUSH
89183: DOUBLE
89184: LD_INT 1
89186: DEC
89187: ST_TO_ADDR
89188: LD_EXP 172
89192: PUSH
89193: FOR_TO
89194: IFFALSE 89275
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
89196: LD_ADDR_VAR 0 3
89200: PUSH
89201: LD_EXP 172
89205: PUSH
89206: LD_VAR 0 2
89210: ARRAY
89211: PPUSH
89212: LD_INT 21
89214: PUSH
89215: LD_INT 3
89217: PUSH
89218: EMPTY
89219: LIST
89220: LIST
89221: PUSH
89222: LD_INT 3
89224: PUSH
89225: LD_INT 24
89227: PUSH
89228: LD_INT 1000
89230: PUSH
89231: EMPTY
89232: LIST
89233: LIST
89234: PUSH
89235: EMPTY
89236: LIST
89237: LIST
89238: PUSH
89239: EMPTY
89240: LIST
89241: LIST
89242: PPUSH
89243: CALL_OW 72
89247: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
89248: LD_ADDR_EXP 173
89252: PUSH
89253: LD_EXP 173
89257: PPUSH
89258: LD_VAR 0 2
89262: PPUSH
89263: LD_VAR 0 3
89267: PPUSH
89268: CALL_OW 1
89272: ST_TO_ADDR
// end ;
89273: GO 89193
89275: POP
89276: POP
// RaiseSailEvent ( 101 ) ;
89277: LD_INT 101
89279: PPUSH
89280: CALL_OW 427
// end ;
89284: LD_VAR 0 1
89288: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
89289: LD_INT 0
89291: PPUSH
89292: PPUSH
89293: PPUSH
89294: PPUSH
89295: PPUSH
89296: PPUSH
89297: PPUSH
// if not mc_bases then
89298: LD_EXP 172
89302: NOT
89303: IFFALSE 89307
// exit ;
89305: GO 89869
// for i = 1 to mc_bases do
89307: LD_ADDR_VAR 0 2
89311: PUSH
89312: DOUBLE
89313: LD_INT 1
89315: DEC
89316: ST_TO_ADDR
89317: LD_EXP 172
89321: PUSH
89322: FOR_TO
89323: IFFALSE 89860
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 800 ] ] ] ] ) ;
89325: LD_ADDR_VAR 0 5
89329: PUSH
89330: LD_EXP 172
89334: PUSH
89335: LD_VAR 0 2
89339: ARRAY
89340: PUSH
89341: LD_EXP 201
89345: PUSH
89346: LD_VAR 0 2
89350: ARRAY
89351: UNION
89352: PPUSH
89353: LD_INT 21
89355: PUSH
89356: LD_INT 1
89358: PUSH
89359: EMPTY
89360: LIST
89361: LIST
89362: PUSH
89363: LD_INT 1
89365: PUSH
89366: LD_INT 3
89368: PUSH
89369: LD_INT 54
89371: PUSH
89372: EMPTY
89373: LIST
89374: PUSH
89375: EMPTY
89376: LIST
89377: LIST
89378: PUSH
89379: LD_INT 3
89381: PUSH
89382: LD_INT 24
89384: PUSH
89385: LD_INT 800
89387: PUSH
89388: EMPTY
89389: LIST
89390: LIST
89391: PUSH
89392: EMPTY
89393: LIST
89394: LIST
89395: PUSH
89396: EMPTY
89397: LIST
89398: LIST
89399: LIST
89400: PUSH
89401: EMPTY
89402: LIST
89403: LIST
89404: PPUSH
89405: CALL_OW 72
89409: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
89410: LD_ADDR_VAR 0 6
89414: PUSH
89415: LD_EXP 172
89419: PUSH
89420: LD_VAR 0 2
89424: ARRAY
89425: PPUSH
89426: LD_INT 21
89428: PUSH
89429: LD_INT 1
89431: PUSH
89432: EMPTY
89433: LIST
89434: LIST
89435: PUSH
89436: LD_INT 1
89438: PUSH
89439: LD_INT 3
89441: PUSH
89442: LD_INT 54
89444: PUSH
89445: EMPTY
89446: LIST
89447: PUSH
89448: EMPTY
89449: LIST
89450: LIST
89451: PUSH
89452: LD_INT 3
89454: PUSH
89455: LD_INT 24
89457: PUSH
89458: LD_INT 250
89460: PUSH
89461: EMPTY
89462: LIST
89463: LIST
89464: PUSH
89465: EMPTY
89466: LIST
89467: LIST
89468: PUSH
89469: EMPTY
89470: LIST
89471: LIST
89472: LIST
89473: PUSH
89474: EMPTY
89475: LIST
89476: LIST
89477: PPUSH
89478: CALL_OW 72
89482: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
89483: LD_ADDR_VAR 0 7
89487: PUSH
89488: LD_VAR 0 5
89492: PUSH
89493: LD_VAR 0 6
89497: DIFF
89498: ST_TO_ADDR
// if not need_heal_1 then
89499: LD_VAR 0 6
89503: NOT
89504: IFFALSE 89537
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
89506: LD_ADDR_EXP 175
89510: PUSH
89511: LD_EXP 175
89515: PPUSH
89516: LD_VAR 0 2
89520: PUSH
89521: LD_INT 1
89523: PUSH
89524: EMPTY
89525: LIST
89526: LIST
89527: PPUSH
89528: EMPTY
89529: PPUSH
89530: CALL 24096 0 3
89534: ST_TO_ADDR
89535: GO 89607
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
89537: LD_ADDR_EXP 175
89541: PUSH
89542: LD_EXP 175
89546: PPUSH
89547: LD_VAR 0 2
89551: PUSH
89552: LD_INT 1
89554: PUSH
89555: EMPTY
89556: LIST
89557: LIST
89558: PPUSH
89559: LD_EXP 175
89563: PUSH
89564: LD_VAR 0 2
89568: ARRAY
89569: PUSH
89570: LD_INT 1
89572: ARRAY
89573: PPUSH
89574: LD_INT 3
89576: PUSH
89577: LD_INT 24
89579: PUSH
89580: LD_INT 1000
89582: PUSH
89583: EMPTY
89584: LIST
89585: LIST
89586: PUSH
89587: EMPTY
89588: LIST
89589: LIST
89590: PPUSH
89591: CALL_OW 72
89595: PUSH
89596: LD_VAR 0 6
89600: UNION
89601: PPUSH
89602: CALL 24096 0 3
89606: ST_TO_ADDR
// if not need_heal_2 then
89607: LD_VAR 0 7
89611: NOT
89612: IFFALSE 89645
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
89614: LD_ADDR_EXP 175
89618: PUSH
89619: LD_EXP 175
89623: PPUSH
89624: LD_VAR 0 2
89628: PUSH
89629: LD_INT 2
89631: PUSH
89632: EMPTY
89633: LIST
89634: LIST
89635: PPUSH
89636: EMPTY
89637: PPUSH
89638: CALL 24096 0 3
89642: ST_TO_ADDR
89643: GO 89677
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
89645: LD_ADDR_EXP 175
89649: PUSH
89650: LD_EXP 175
89654: PPUSH
89655: LD_VAR 0 2
89659: PUSH
89660: LD_INT 2
89662: PUSH
89663: EMPTY
89664: LIST
89665: LIST
89666: PPUSH
89667: LD_VAR 0 7
89671: PPUSH
89672: CALL 24096 0 3
89676: ST_TO_ADDR
// if need_heal_2 then
89677: LD_VAR 0 7
89681: IFFALSE 89842
// for j in need_heal_2 do
89683: LD_ADDR_VAR 0 3
89687: PUSH
89688: LD_VAR 0 7
89692: PUSH
89693: FOR_IN
89694: IFFALSE 89840
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
89696: LD_ADDR_VAR 0 5
89700: PUSH
89701: LD_EXP 172
89705: PUSH
89706: LD_VAR 0 2
89710: ARRAY
89711: PPUSH
89712: LD_INT 2
89714: PUSH
89715: LD_INT 30
89717: PUSH
89718: LD_INT 6
89720: PUSH
89721: EMPTY
89722: LIST
89723: LIST
89724: PUSH
89725: LD_INT 30
89727: PUSH
89728: LD_INT 7
89730: PUSH
89731: EMPTY
89732: LIST
89733: LIST
89734: PUSH
89735: LD_INT 30
89737: PUSH
89738: LD_INT 8
89740: PUSH
89741: EMPTY
89742: LIST
89743: LIST
89744: PUSH
89745: LD_INT 30
89747: PUSH
89748: LD_INT 0
89750: PUSH
89751: EMPTY
89752: LIST
89753: LIST
89754: PUSH
89755: LD_INT 30
89757: PUSH
89758: LD_INT 1
89760: PUSH
89761: EMPTY
89762: LIST
89763: LIST
89764: PUSH
89765: EMPTY
89766: LIST
89767: LIST
89768: LIST
89769: LIST
89770: LIST
89771: LIST
89772: PPUSH
89773: CALL_OW 72
89777: ST_TO_ADDR
// if tmp then
89778: LD_VAR 0 5
89782: IFFALSE 89838
// begin k := NearestUnitToUnit ( tmp , j ) ;
89784: LD_ADDR_VAR 0 4
89788: PUSH
89789: LD_VAR 0 5
89793: PPUSH
89794: LD_VAR 0 3
89798: PPUSH
89799: CALL_OW 74
89803: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 5 then
89804: LD_VAR 0 3
89808: PPUSH
89809: LD_VAR 0 4
89813: PPUSH
89814: CALL_OW 296
89818: PUSH
89819: LD_INT 5
89821: GREATER
89822: IFFALSE 89838
// ComMoveToNearbyEntrance ( j , k ) ;
89824: LD_VAR 0 3
89828: PPUSH
89829: LD_VAR 0 4
89833: PPUSH
89834: CALL 55962 0 2
// end ; end ;
89838: GO 89693
89840: POP
89841: POP
// if not need_heal_1 and not need_heal_2 then
89842: LD_VAR 0 6
89846: NOT
89847: PUSH
89848: LD_VAR 0 7
89852: NOT
89853: AND
89854: IFFALSE 89858
// continue ;
89856: GO 89322
// end ;
89858: GO 89322
89860: POP
89861: POP
// RaiseSailEvent ( 102 ) ;
89862: LD_INT 102
89864: PPUSH
89865: CALL_OW 427
// end ;
89869: LD_VAR 0 1
89873: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes , to_repair_tmp , to_repair ; begin
89874: LD_INT 0
89876: PPUSH
89877: PPUSH
89878: PPUSH
89879: PPUSH
89880: PPUSH
89881: PPUSH
89882: PPUSH
89883: PPUSH
// if not mc_bases then
89884: LD_EXP 172
89888: NOT
89889: IFFALSE 89893
// exit ;
89891: GO 90754
// for i = 1 to mc_bases do
89893: LD_ADDR_VAR 0 2
89897: PUSH
89898: DOUBLE
89899: LD_INT 1
89901: DEC
89902: ST_TO_ADDR
89903: LD_EXP 172
89907: PUSH
89908: FOR_TO
89909: IFFALSE 90752
// begin if not mc_building_need_repair [ i ] then
89911: LD_EXP 173
89915: PUSH
89916: LD_VAR 0 2
89920: ARRAY
89921: NOT
89922: IFFALSE 90109
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ] ) ;
89924: LD_ADDR_VAR 0 6
89928: PUSH
89929: LD_EXP 191
89933: PUSH
89934: LD_VAR 0 2
89938: ARRAY
89939: PPUSH
89940: LD_INT 3
89942: PUSH
89943: LD_INT 24
89945: PUSH
89946: LD_INT 1000
89948: PUSH
89949: EMPTY
89950: LIST
89951: LIST
89952: PUSH
89953: EMPTY
89954: LIST
89955: LIST
89956: PUSH
89957: LD_INT 2
89959: PUSH
89960: LD_INT 34
89962: PUSH
89963: LD_INT 13
89965: PUSH
89966: EMPTY
89967: LIST
89968: LIST
89969: PUSH
89970: LD_INT 34
89972: PUSH
89973: LD_INT 52
89975: PUSH
89976: EMPTY
89977: LIST
89978: LIST
89979: PUSH
89980: LD_INT 34
89982: PUSH
89983: LD_EXP 160
89987: PUSH
89988: EMPTY
89989: LIST
89990: LIST
89991: PUSH
89992: EMPTY
89993: LIST
89994: LIST
89995: LIST
89996: LIST
89997: PUSH
89998: EMPTY
89999: LIST
90000: LIST
90001: PPUSH
90002: CALL_OW 72
90006: ST_TO_ADDR
// if cranes then
90007: LD_VAR 0 6
90011: IFFALSE 90073
// for j in cranes do
90013: LD_ADDR_VAR 0 3
90017: PUSH
90018: LD_VAR 0 6
90022: PUSH
90023: FOR_IN
90024: IFFALSE 90071
// if not IsInArea ( j , mc_parking [ i ] ) then
90026: LD_VAR 0 3
90030: PPUSH
90031: LD_EXP 196
90035: PUSH
90036: LD_VAR 0 2
90040: ARRAY
90041: PPUSH
90042: CALL_OW 308
90046: NOT
90047: IFFALSE 90069
// ComMoveToArea ( j , mc_parking [ i ] ) ;
90049: LD_VAR 0 3
90053: PPUSH
90054: LD_EXP 196
90058: PUSH
90059: LD_VAR 0 2
90063: ARRAY
90064: PPUSH
90065: CALL_OW 113
90069: GO 90023
90071: POP
90072: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
90073: LD_ADDR_EXP 174
90077: PUSH
90078: LD_EXP 174
90082: PPUSH
90083: LD_VAR 0 2
90087: PPUSH
90088: EMPTY
90089: PPUSH
90090: CALL_OW 1
90094: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
90095: LD_VAR 0 2
90099: PPUSH
90100: LD_INT 101
90102: PPUSH
90103: CALL 84997 0 2
// continue ;
90107: GO 89908
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
90109: LD_ADDR_EXP 178
90113: PUSH
90114: LD_EXP 178
90118: PPUSH
90119: LD_VAR 0 2
90123: PPUSH
90124: EMPTY
90125: PPUSH
90126: CALL_OW 1
90130: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
90131: LD_VAR 0 2
90135: PPUSH
90136: LD_INT 103
90138: PPUSH
90139: CALL 84997 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) diff ( mc_need_heal [ i ] [ 1 ] union mc_need_heal [ i ] [ 2 ] ) ;
90143: LD_ADDR_VAR 0 5
90147: PUSH
90148: LD_EXP 172
90152: PUSH
90153: LD_VAR 0 2
90157: ARRAY
90158: PUSH
90159: LD_EXP 201
90163: PUSH
90164: LD_VAR 0 2
90168: ARRAY
90169: UNION
90170: PPUSH
90171: LD_INT 2
90173: PUSH
90174: LD_INT 25
90176: PUSH
90177: LD_INT 2
90179: PUSH
90180: EMPTY
90181: LIST
90182: LIST
90183: PUSH
90184: LD_INT 25
90186: PUSH
90187: LD_INT 16
90189: PUSH
90190: EMPTY
90191: LIST
90192: LIST
90193: PUSH
90194: EMPTY
90195: LIST
90196: LIST
90197: LIST
90198: PUSH
90199: EMPTY
90200: LIST
90201: PPUSH
90202: CALL_OW 72
90206: PUSH
90207: LD_EXP 175
90211: PUSH
90212: LD_VAR 0 2
90216: ARRAY
90217: PUSH
90218: LD_INT 1
90220: ARRAY
90221: PUSH
90222: LD_EXP 175
90226: PUSH
90227: LD_VAR 0 2
90231: ARRAY
90232: PUSH
90233: LD_INT 2
90235: ARRAY
90236: UNION
90237: DIFF
90238: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ) ;
90239: LD_ADDR_VAR 0 6
90243: PUSH
90244: LD_EXP 191
90248: PUSH
90249: LD_VAR 0 2
90253: ARRAY
90254: PPUSH
90255: LD_INT 2
90257: PUSH
90258: LD_INT 34
90260: PUSH
90261: LD_INT 13
90263: PUSH
90264: EMPTY
90265: LIST
90266: LIST
90267: PUSH
90268: LD_INT 34
90270: PUSH
90271: LD_INT 52
90273: PUSH
90274: EMPTY
90275: LIST
90276: LIST
90277: PUSH
90278: LD_INT 34
90280: PUSH
90281: LD_EXP 160
90285: PUSH
90286: EMPTY
90287: LIST
90288: LIST
90289: PUSH
90290: EMPTY
90291: LIST
90292: LIST
90293: LIST
90294: LIST
90295: PPUSH
90296: CALL_OW 72
90300: ST_TO_ADDR
// if cranes then
90301: LD_VAR 0 6
90305: IFFALSE 90441
// begin for j in cranes do
90307: LD_ADDR_VAR 0 3
90311: PUSH
90312: LD_VAR 0 6
90316: PUSH
90317: FOR_IN
90318: IFFALSE 90439
// begin if GetLives ( j ) = 1000 and not HasTask ( j ) then
90320: LD_VAR 0 3
90324: PPUSH
90325: CALL_OW 256
90329: PUSH
90330: LD_INT 1000
90332: EQUAL
90333: PUSH
90334: LD_VAR 0 3
90338: PPUSH
90339: CALL_OW 314
90343: NOT
90344: AND
90345: IFFALSE 90379
// ComRepairBuilding ( j , NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ) else
90347: LD_VAR 0 3
90351: PPUSH
90352: LD_EXP 173
90356: PUSH
90357: LD_VAR 0 2
90361: ARRAY
90362: PPUSH
90363: LD_VAR 0 3
90367: PPUSH
90368: CALL_OW 74
90372: PPUSH
90373: CALL_OW 130
90377: GO 90437
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
90379: LD_VAR 0 3
90383: PPUSH
90384: CALL_OW 256
90388: PUSH
90389: LD_INT 500
90391: LESS
90392: PUSH
90393: LD_VAR 0 3
90397: PPUSH
90398: LD_EXP 196
90402: PUSH
90403: LD_VAR 0 2
90407: ARRAY
90408: PPUSH
90409: CALL_OW 308
90413: NOT
90414: AND
90415: IFFALSE 90437
// ComMoveToArea ( j , mc_parking [ i ] ) ;
90417: LD_VAR 0 3
90421: PPUSH
90422: LD_EXP 196
90426: PUSH
90427: LD_VAR 0 2
90431: ARRAY
90432: PPUSH
90433: CALL_OW 113
// end ;
90437: GO 90317
90439: POP
90440: POP
// end ; if tmp > 3 then
90441: LD_VAR 0 5
90445: PUSH
90446: LD_INT 3
90448: GREATER
90449: IFFALSE 90469
// tmp := ShrinkArray ( tmp , 4 ) ;
90451: LD_ADDR_VAR 0 5
90455: PUSH
90456: LD_VAR 0 5
90460: PPUSH
90461: LD_INT 4
90463: PPUSH
90464: CALL 55454 0 2
90468: ST_TO_ADDR
// if not tmp then
90469: LD_VAR 0 5
90473: NOT
90474: IFFALSE 90478
// continue ;
90476: GO 89908
// for j in tmp do
90478: LD_ADDR_VAR 0 3
90482: PUSH
90483: LD_VAR 0 5
90487: PUSH
90488: FOR_IN
90489: IFFALSE 90748
// begin if IsInUnit ( j ) then
90491: LD_VAR 0 3
90495: PPUSH
90496: CALL_OW 310
90500: IFFALSE 90511
// ComExitBuilding ( j ) ;
90502: LD_VAR 0 3
90506: PPUSH
90507: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
90511: LD_VAR 0 3
90515: PUSH
90516: LD_EXP 174
90520: PUSH
90521: LD_VAR 0 2
90525: ARRAY
90526: IN
90527: NOT
90528: IFFALSE 90586
// begin SetTag ( j , 101 ) ;
90530: LD_VAR 0 3
90534: PPUSH
90535: LD_INT 101
90537: PPUSH
90538: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
90542: LD_ADDR_EXP 174
90546: PUSH
90547: LD_EXP 174
90551: PPUSH
90552: LD_VAR 0 2
90556: PUSH
90557: LD_EXP 174
90561: PUSH
90562: LD_VAR 0 2
90566: ARRAY
90567: PUSH
90568: LD_INT 1
90570: PLUS
90571: PUSH
90572: EMPTY
90573: LIST
90574: LIST
90575: PPUSH
90576: LD_VAR 0 3
90580: PPUSH
90581: CALL 24096 0 3
90585: ST_TO_ADDR
// end ; wait ( 1 ) ;
90586: LD_INT 1
90588: PPUSH
90589: CALL_OW 67
// to_repair_tmp := mc_building_need_repair [ i ] ;
90593: LD_ADDR_VAR 0 7
90597: PUSH
90598: LD_EXP 173
90602: PUSH
90603: LD_VAR 0 2
90607: ARRAY
90608: ST_TO_ADDR
// if mc_scan [ i ] then
90609: LD_EXP 195
90613: PUSH
90614: LD_VAR 0 2
90618: ARRAY
90619: IFFALSE 90681
// to_repair_tmp := UnitFilter ( mc_building_need_repair [ i ] , [ f_not , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_breastwork ] ] ) ;
90621: LD_ADDR_VAR 0 7
90625: PUSH
90626: LD_EXP 173
90630: PUSH
90631: LD_VAR 0 2
90635: ARRAY
90636: PPUSH
90637: LD_INT 3
90639: PUSH
90640: LD_INT 30
90642: PUSH
90643: LD_INT 32
90645: PUSH
90646: EMPTY
90647: LIST
90648: LIST
90649: PUSH
90650: LD_INT 30
90652: PUSH
90653: LD_INT 33
90655: PUSH
90656: EMPTY
90657: LIST
90658: LIST
90659: PUSH
90660: LD_INT 30
90662: PUSH
90663: LD_INT 31
90665: PUSH
90666: EMPTY
90667: LIST
90668: LIST
90669: PUSH
90670: EMPTY
90671: LIST
90672: LIST
90673: LIST
90674: LIST
90675: PPUSH
90676: CALL_OW 72
90680: ST_TO_ADDR
// if not to_repair_tmp then
90681: LD_VAR 0 7
90685: NOT
90686: IFFALSE 90690
// continue ;
90688: GO 90488
// to_repair := NearestUnitToUnit ( to_repair_tmp , j ) ;
90690: LD_ADDR_VAR 0 8
90694: PUSH
90695: LD_VAR 0 7
90699: PPUSH
90700: LD_VAR 0 3
90704: PPUSH
90705: CALL_OW 74
90709: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 10 then
90710: LD_VAR 0 8
90714: PPUSH
90715: LD_INT 16
90717: PPUSH
90718: CALL 26689 0 2
90722: PUSH
90723: LD_INT 4
90725: ARRAY
90726: PUSH
90727: LD_INT 10
90729: LESS
90730: IFFALSE 90746
// ComRepairBuilding ( j , to_repair ) ;
90732: LD_VAR 0 3
90736: PPUSH
90737: LD_VAR 0 8
90741: PPUSH
90742: CALL_OW 130
// end ;
90746: GO 90488
90748: POP
90749: POP
// end ;
90750: GO 89908
90752: POP
90753: POP
// end ;
90754: LD_VAR 0 1
90758: RET
// export function MC_Heal ; var i , j , tmp ; begin
90759: LD_INT 0
90761: PPUSH
90762: PPUSH
90763: PPUSH
90764: PPUSH
// if not mc_bases then
90765: LD_EXP 172
90769: NOT
90770: IFFALSE 90774
// exit ;
90772: GO 91176
// for i = 1 to mc_bases do
90774: LD_ADDR_VAR 0 2
90778: PUSH
90779: DOUBLE
90780: LD_INT 1
90782: DEC
90783: ST_TO_ADDR
90784: LD_EXP 172
90788: PUSH
90789: FOR_TO
90790: IFFALSE 91174
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
90792: LD_EXP 175
90796: PUSH
90797: LD_VAR 0 2
90801: ARRAY
90802: PUSH
90803: LD_INT 1
90805: ARRAY
90806: NOT
90807: PUSH
90808: LD_EXP 175
90812: PUSH
90813: LD_VAR 0 2
90817: ARRAY
90818: PUSH
90819: LD_INT 2
90821: ARRAY
90822: NOT
90823: AND
90824: IFFALSE 90862
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
90826: LD_ADDR_EXP 176
90830: PUSH
90831: LD_EXP 176
90835: PPUSH
90836: LD_VAR 0 2
90840: PPUSH
90841: EMPTY
90842: PPUSH
90843: CALL_OW 1
90847: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
90848: LD_VAR 0 2
90852: PPUSH
90853: LD_INT 102
90855: PPUSH
90856: CALL 84997 0 2
// continue ;
90860: GO 90789
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
90862: LD_ADDR_VAR 0 4
90866: PUSH
90867: LD_EXP 172
90871: PUSH
90872: LD_VAR 0 2
90876: ARRAY
90877: PPUSH
90878: LD_INT 25
90880: PUSH
90881: LD_INT 4
90883: PUSH
90884: EMPTY
90885: LIST
90886: LIST
90887: PPUSH
90888: CALL_OW 72
90892: ST_TO_ADDR
// if not tmp then
90893: LD_VAR 0 4
90897: NOT
90898: IFFALSE 90902
// continue ;
90900: GO 90789
// if mc_taming [ i ] then
90902: LD_EXP 203
90906: PUSH
90907: LD_VAR 0 2
90911: ARRAY
90912: IFFALSE 90936
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
90914: LD_ADDR_EXP 203
90918: PUSH
90919: LD_EXP 203
90923: PPUSH
90924: LD_VAR 0 2
90928: PPUSH
90929: EMPTY
90930: PPUSH
90931: CALL_OW 1
90935: ST_TO_ADDR
// for j in tmp do
90936: LD_ADDR_VAR 0 3
90940: PUSH
90941: LD_VAR 0 4
90945: PUSH
90946: FOR_IN
90947: IFFALSE 91170
// begin if IsInUnit ( j ) then
90949: LD_VAR 0 3
90953: PPUSH
90954: CALL_OW 310
90958: IFFALSE 90969
// ComExitBuilding ( j ) ;
90960: LD_VAR 0 3
90964: PPUSH
90965: CALL_OW 122
// if not j in mc_healers [ i ] then
90969: LD_VAR 0 3
90973: PUSH
90974: LD_EXP 176
90978: PUSH
90979: LD_VAR 0 2
90983: ARRAY
90984: IN
90985: NOT
90986: IFFALSE 91032
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
90988: LD_ADDR_EXP 176
90992: PUSH
90993: LD_EXP 176
90997: PPUSH
90998: LD_VAR 0 2
91002: PUSH
91003: LD_EXP 176
91007: PUSH
91008: LD_VAR 0 2
91012: ARRAY
91013: PUSH
91014: LD_INT 1
91016: PLUS
91017: PUSH
91018: EMPTY
91019: LIST
91020: LIST
91021: PPUSH
91022: LD_VAR 0 3
91026: PPUSH
91027: CALL 24096 0 3
91031: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
91032: LD_VAR 0 3
91036: PPUSH
91037: CALL_OW 110
91041: PUSH
91042: LD_INT 102
91044: NONEQUAL
91045: IFFALSE 91059
// SetTag ( j , 102 ) ;
91047: LD_VAR 0 3
91051: PPUSH
91052: LD_INT 102
91054: PPUSH
91055: CALL_OW 109
// Wait ( 3 ) ;
91059: LD_INT 3
91061: PPUSH
91062: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
91066: LD_EXP 175
91070: PUSH
91071: LD_VAR 0 2
91075: ARRAY
91076: PUSH
91077: LD_INT 1
91079: ARRAY
91080: IFFALSE 91112
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
91082: LD_VAR 0 3
91086: PPUSH
91087: LD_EXP 175
91091: PUSH
91092: LD_VAR 0 2
91096: ARRAY
91097: PUSH
91098: LD_INT 1
91100: ARRAY
91101: PUSH
91102: LD_INT 1
91104: ARRAY
91105: PPUSH
91106: CALL_OW 128
91110: GO 91168
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
91112: LD_VAR 0 3
91116: PPUSH
91117: CALL_OW 314
91121: NOT
91122: PUSH
91123: LD_EXP 175
91127: PUSH
91128: LD_VAR 0 2
91132: ARRAY
91133: PUSH
91134: LD_INT 2
91136: ARRAY
91137: AND
91138: IFFALSE 91168
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
91140: LD_VAR 0 3
91144: PPUSH
91145: LD_EXP 175
91149: PUSH
91150: LD_VAR 0 2
91154: ARRAY
91155: PUSH
91156: LD_INT 2
91158: ARRAY
91159: PUSH
91160: LD_INT 1
91162: ARRAY
91163: PPUSH
91164: CALL_OW 128
// end ;
91168: GO 90946
91170: POP
91171: POP
// end ;
91172: GO 90789
91174: POP
91175: POP
// end ;
91176: LD_VAR 0 1
91180: RET
// export function MC_Build ( ) ; var i , j , tmp , depot ; begin
91181: LD_INT 0
91183: PPUSH
91184: PPUSH
91185: PPUSH
91186: PPUSH
91187: PPUSH
// if not mc_bases then
91188: LD_EXP 172
91192: NOT
91193: IFFALSE 91197
// exit ;
91195: GO 92340
// for i = 1 to mc_bases do
91197: LD_ADDR_VAR 0 2
91201: PUSH
91202: DOUBLE
91203: LD_INT 1
91205: DEC
91206: ST_TO_ADDR
91207: LD_EXP 172
91211: PUSH
91212: FOR_TO
91213: IFFALSE 92338
// begin if mc_scan [ i ] then
91215: LD_EXP 195
91219: PUSH
91220: LD_VAR 0 2
91224: ARRAY
91225: IFFALSE 91229
// continue ;
91227: GO 91212
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
91229: LD_EXP 177
91233: PUSH
91234: LD_VAR 0 2
91238: ARRAY
91239: NOT
91240: PUSH
91241: LD_EXP 179
91245: PUSH
91246: LD_VAR 0 2
91250: ARRAY
91251: NOT
91252: AND
91253: PUSH
91254: LD_EXP 178
91258: PUSH
91259: LD_VAR 0 2
91263: ARRAY
91264: AND
91265: IFFALSE 91303
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
91267: LD_ADDR_EXP 178
91271: PUSH
91272: LD_EXP 178
91276: PPUSH
91277: LD_VAR 0 2
91281: PPUSH
91282: EMPTY
91283: PPUSH
91284: CALL_OW 1
91288: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
91289: LD_VAR 0 2
91293: PPUSH
91294: LD_INT 103
91296: PPUSH
91297: CALL 84997 0 2
// continue ;
91301: GO 91212
// end ; if mc_construct_list [ i ] then
91303: LD_EXP 179
91307: PUSH
91308: LD_VAR 0 2
91312: ARRAY
91313: IFFALSE 91533
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
91315: LD_ADDR_VAR 0 4
91319: PUSH
91320: LD_EXP 172
91324: PUSH
91325: LD_VAR 0 2
91329: ARRAY
91330: PPUSH
91331: LD_INT 25
91333: PUSH
91334: LD_INT 2
91336: PUSH
91337: EMPTY
91338: LIST
91339: LIST
91340: PPUSH
91341: CALL_OW 72
91345: PUSH
91346: LD_EXP 174
91350: PUSH
91351: LD_VAR 0 2
91355: ARRAY
91356: DIFF
91357: ST_TO_ADDR
// if not tmp then
91358: LD_VAR 0 4
91362: NOT
91363: IFFALSE 91367
// continue ;
91365: GO 91212
// for j in tmp do
91367: LD_ADDR_VAR 0 3
91371: PUSH
91372: LD_VAR 0 4
91376: PUSH
91377: FOR_IN
91378: IFFALSE 91529
// begin if not mc_builders [ i ] then
91380: LD_EXP 178
91384: PUSH
91385: LD_VAR 0 2
91389: ARRAY
91390: NOT
91391: IFFALSE 91449
// begin SetTag ( j , 103 ) ;
91393: LD_VAR 0 3
91397: PPUSH
91398: LD_INT 103
91400: PPUSH
91401: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
91405: LD_ADDR_EXP 178
91409: PUSH
91410: LD_EXP 178
91414: PPUSH
91415: LD_VAR 0 2
91419: PUSH
91420: LD_EXP 178
91424: PUSH
91425: LD_VAR 0 2
91429: ARRAY
91430: PUSH
91431: LD_INT 1
91433: PLUS
91434: PUSH
91435: EMPTY
91436: LIST
91437: LIST
91438: PPUSH
91439: LD_VAR 0 3
91443: PPUSH
91444: CALL 24096 0 3
91448: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
91449: LD_VAR 0 3
91453: PPUSH
91454: CALL_OW 310
91458: IFFALSE 91469
// ComExitBuilding ( j ) ;
91460: LD_VAR 0 3
91464: PPUSH
91465: CALL_OW 122
// wait ( 3 ) ;
91469: LD_INT 3
91471: PPUSH
91472: CALL_OW 67
// if not mc_construct_list [ i ] then
91476: LD_EXP 179
91480: PUSH
91481: LD_VAR 0 2
91485: ARRAY
91486: NOT
91487: IFFALSE 91491
// break ;
91489: GO 91529
// if not HasTask ( j ) then
91491: LD_VAR 0 3
91495: PPUSH
91496: CALL_OW 314
91500: NOT
91501: IFFALSE 91527
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
91503: LD_VAR 0 3
91507: PPUSH
91508: LD_EXP 179
91512: PUSH
91513: LD_VAR 0 2
91517: ARRAY
91518: PUSH
91519: LD_INT 1
91521: ARRAY
91522: PPUSH
91523: CALL 26947 0 2
// end ;
91527: GO 91377
91529: POP
91530: POP
// end else
91531: GO 92336
// if mc_build_list [ i ] then
91533: LD_EXP 177
91537: PUSH
91538: LD_VAR 0 2
91542: ARRAY
91543: IFFALSE 92336
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
91545: LD_ADDR_VAR 0 5
91549: PUSH
91550: LD_EXP 172
91554: PUSH
91555: LD_VAR 0 2
91559: ARRAY
91560: PPUSH
91561: LD_INT 2
91563: PUSH
91564: LD_INT 30
91566: PUSH
91567: LD_INT 0
91569: PUSH
91570: EMPTY
91571: LIST
91572: LIST
91573: PUSH
91574: LD_INT 30
91576: PUSH
91577: LD_INT 1
91579: PUSH
91580: EMPTY
91581: LIST
91582: LIST
91583: PUSH
91584: EMPTY
91585: LIST
91586: LIST
91587: LIST
91588: PPUSH
91589: CALL_OW 72
91593: ST_TO_ADDR
// if depot then
91594: LD_VAR 0 5
91598: IFFALSE 91616
// depot := depot [ 1 ] else
91600: LD_ADDR_VAR 0 5
91604: PUSH
91605: LD_VAR 0 5
91609: PUSH
91610: LD_INT 1
91612: ARRAY
91613: ST_TO_ADDR
91614: GO 91624
// depot := 0 ;
91616: LD_ADDR_VAR 0 5
91620: PUSH
91621: LD_INT 0
91623: ST_TO_ADDR
// if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
91624: LD_EXP 177
91628: PUSH
91629: LD_VAR 0 2
91633: ARRAY
91634: PUSH
91635: LD_INT 1
91637: ARRAY
91638: PUSH
91639: LD_INT 1
91641: ARRAY
91642: PPUSH
91643: CALL 26777 0 1
91647: PUSH
91648: LD_EXP 172
91652: PUSH
91653: LD_VAR 0 2
91657: ARRAY
91658: PPUSH
91659: LD_INT 2
91661: PUSH
91662: LD_INT 30
91664: PUSH
91665: LD_INT 2
91667: PUSH
91668: EMPTY
91669: LIST
91670: LIST
91671: PUSH
91672: LD_INT 30
91674: PUSH
91675: LD_INT 3
91677: PUSH
91678: EMPTY
91679: LIST
91680: LIST
91681: PUSH
91682: EMPTY
91683: LIST
91684: LIST
91685: LIST
91686: PPUSH
91687: CALL_OW 72
91691: NOT
91692: AND
91693: IFFALSE 91798
// begin for j = 1 to mc_build_list [ i ] do
91695: LD_ADDR_VAR 0 3
91699: PUSH
91700: DOUBLE
91701: LD_INT 1
91703: DEC
91704: ST_TO_ADDR
91705: LD_EXP 177
91709: PUSH
91710: LD_VAR 0 2
91714: ARRAY
91715: PUSH
91716: FOR_TO
91717: IFFALSE 91796
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
91719: LD_EXP 177
91723: PUSH
91724: LD_VAR 0 2
91728: ARRAY
91729: PUSH
91730: LD_VAR 0 3
91734: ARRAY
91735: PUSH
91736: LD_INT 1
91738: ARRAY
91739: PUSH
91740: LD_INT 2
91742: EQUAL
91743: IFFALSE 91794
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
91745: LD_ADDR_EXP 177
91749: PUSH
91750: LD_EXP 177
91754: PPUSH
91755: LD_VAR 0 2
91759: PPUSH
91760: LD_EXP 177
91764: PUSH
91765: LD_VAR 0 2
91769: ARRAY
91770: PPUSH
91771: LD_VAR 0 3
91775: PPUSH
91776: LD_INT 1
91778: PPUSH
91779: LD_INT 0
91781: PPUSH
91782: CALL 23514 0 4
91786: PPUSH
91787: CALL_OW 1
91791: ST_TO_ADDR
// break ;
91792: GO 91796
// end ;
91794: GO 91716
91796: POP
91797: POP
// end ; if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or ( depot and CanBeBuilt ( depot , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ) then
91798: LD_EXP 177
91802: PUSH
91803: LD_VAR 0 2
91807: ARRAY
91808: PUSH
91809: LD_INT 1
91811: ARRAY
91812: PUSH
91813: LD_INT 1
91815: ARRAY
91816: PUSH
91817: LD_INT 0
91819: EQUAL
91820: PUSH
91821: LD_VAR 0 5
91825: PUSH
91826: LD_VAR 0 5
91830: PPUSH
91831: LD_EXP 177
91835: PUSH
91836: LD_VAR 0 2
91840: ARRAY
91841: PUSH
91842: LD_INT 1
91844: ARRAY
91845: PUSH
91846: LD_INT 1
91848: ARRAY
91849: PPUSH
91850: LD_EXP 177
91854: PUSH
91855: LD_VAR 0 2
91859: ARRAY
91860: PUSH
91861: LD_INT 1
91863: ARRAY
91864: PUSH
91865: LD_INT 2
91867: ARRAY
91868: PPUSH
91869: LD_EXP 177
91873: PUSH
91874: LD_VAR 0 2
91878: ARRAY
91879: PUSH
91880: LD_INT 1
91882: ARRAY
91883: PUSH
91884: LD_INT 3
91886: ARRAY
91887: PPUSH
91888: LD_EXP 177
91892: PUSH
91893: LD_VAR 0 2
91897: ARRAY
91898: PUSH
91899: LD_INT 1
91901: ARRAY
91902: PUSH
91903: LD_INT 4
91905: ARRAY
91906: PPUSH
91907: CALL 31511 0 5
91911: AND
91912: OR
91913: IFFALSE 92194
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
91915: LD_ADDR_VAR 0 4
91919: PUSH
91920: LD_EXP 172
91924: PUSH
91925: LD_VAR 0 2
91929: ARRAY
91930: PPUSH
91931: LD_INT 25
91933: PUSH
91934: LD_INT 2
91936: PUSH
91937: EMPTY
91938: LIST
91939: LIST
91940: PPUSH
91941: CALL_OW 72
91945: PUSH
91946: LD_EXP 174
91950: PUSH
91951: LD_VAR 0 2
91955: ARRAY
91956: DIFF
91957: ST_TO_ADDR
// if not tmp then
91958: LD_VAR 0 4
91962: NOT
91963: IFFALSE 91967
// continue ;
91965: GO 91212
// for j in tmp do
91967: LD_ADDR_VAR 0 3
91971: PUSH
91972: LD_VAR 0 4
91976: PUSH
91977: FOR_IN
91978: IFFALSE 92190
// begin if not mc_builders [ i ] then
91980: LD_EXP 178
91984: PUSH
91985: LD_VAR 0 2
91989: ARRAY
91990: NOT
91991: IFFALSE 92049
// begin SetTag ( j , 103 ) ;
91993: LD_VAR 0 3
91997: PPUSH
91998: LD_INT 103
92000: PPUSH
92001: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
92005: LD_ADDR_EXP 178
92009: PUSH
92010: LD_EXP 178
92014: PPUSH
92015: LD_VAR 0 2
92019: PUSH
92020: LD_EXP 178
92024: PUSH
92025: LD_VAR 0 2
92029: ARRAY
92030: PUSH
92031: LD_INT 1
92033: PLUS
92034: PUSH
92035: EMPTY
92036: LIST
92037: LIST
92038: PPUSH
92039: LD_VAR 0 3
92043: PPUSH
92044: CALL 24096 0 3
92048: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
92049: LD_VAR 0 3
92053: PPUSH
92054: CALL_OW 310
92058: IFFALSE 92069
// ComExitBuilding ( j ) ;
92060: LD_VAR 0 3
92064: PPUSH
92065: CALL_OW 122
// wait ( 3 ) ;
92069: LD_INT 3
92071: PPUSH
92072: CALL_OW 67
// if not mc_build_list [ i ] then
92076: LD_EXP 177
92080: PUSH
92081: LD_VAR 0 2
92085: ARRAY
92086: NOT
92087: IFFALSE 92091
// break ;
92089: GO 92190
// if not HasTask ( j ) then
92091: LD_VAR 0 3
92095: PPUSH
92096: CALL_OW 314
92100: NOT
92101: IFFALSE 92188
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
92103: LD_VAR 0 3
92107: PPUSH
92108: LD_EXP 177
92112: PUSH
92113: LD_VAR 0 2
92117: ARRAY
92118: PUSH
92119: LD_INT 1
92121: ARRAY
92122: PUSH
92123: LD_INT 1
92125: ARRAY
92126: PPUSH
92127: LD_EXP 177
92131: PUSH
92132: LD_VAR 0 2
92136: ARRAY
92137: PUSH
92138: LD_INT 1
92140: ARRAY
92141: PUSH
92142: LD_INT 2
92144: ARRAY
92145: PPUSH
92146: LD_EXP 177
92150: PUSH
92151: LD_VAR 0 2
92155: ARRAY
92156: PUSH
92157: LD_INT 1
92159: ARRAY
92160: PUSH
92161: LD_INT 3
92163: ARRAY
92164: PPUSH
92165: LD_EXP 177
92169: PUSH
92170: LD_VAR 0 2
92174: ARRAY
92175: PUSH
92176: LD_INT 1
92178: ARRAY
92179: PUSH
92180: LD_INT 4
92182: ARRAY
92183: PPUSH
92184: CALL_OW 145
// end ;
92188: GO 91977
92190: POP
92191: POP
// end else
92192: GO 92336
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) then
92194: LD_EXP 172
92198: PUSH
92199: LD_VAR 0 2
92203: ARRAY
92204: PPUSH
92205: LD_EXP 177
92209: PUSH
92210: LD_VAR 0 2
92214: ARRAY
92215: PUSH
92216: LD_INT 1
92218: ARRAY
92219: PUSH
92220: LD_INT 1
92222: ARRAY
92223: PPUSH
92224: LD_EXP 177
92228: PUSH
92229: LD_VAR 0 2
92233: ARRAY
92234: PUSH
92235: LD_INT 1
92237: ARRAY
92238: PUSH
92239: LD_INT 2
92241: ARRAY
92242: PPUSH
92243: LD_EXP 177
92247: PUSH
92248: LD_VAR 0 2
92252: ARRAY
92253: PUSH
92254: LD_INT 1
92256: ARRAY
92257: PUSH
92258: LD_INT 3
92260: ARRAY
92261: PPUSH
92262: LD_EXP 177
92266: PUSH
92267: LD_VAR 0 2
92271: ARRAY
92272: PUSH
92273: LD_INT 1
92275: ARRAY
92276: PUSH
92277: LD_INT 4
92279: ARRAY
92280: PPUSH
92281: CALL 30847 0 5
92285: NOT
92286: IFFALSE 92336
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
92288: LD_ADDR_EXP 177
92292: PUSH
92293: LD_EXP 177
92297: PPUSH
92298: LD_VAR 0 2
92302: PPUSH
92303: LD_EXP 177
92307: PUSH
92308: LD_VAR 0 2
92312: ARRAY
92313: PPUSH
92314: LD_INT 1
92316: PPUSH
92317: LD_INT 1
92319: NEG
92320: PPUSH
92321: LD_INT 0
92323: PPUSH
92324: CALL 23514 0 4
92328: PPUSH
92329: CALL_OW 1
92333: ST_TO_ADDR
// continue ;
92334: GO 91212
// end ; end ; end ;
92336: GO 91212
92338: POP
92339: POP
// end ;
92340: LD_VAR 0 1
92344: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
92345: LD_INT 0
92347: PPUSH
92348: PPUSH
92349: PPUSH
92350: PPUSH
92351: PPUSH
92352: PPUSH
// if not mc_bases then
92353: LD_EXP 172
92357: NOT
92358: IFFALSE 92362
// exit ;
92360: GO 92789
// for i = 1 to mc_bases do
92362: LD_ADDR_VAR 0 2
92366: PUSH
92367: DOUBLE
92368: LD_INT 1
92370: DEC
92371: ST_TO_ADDR
92372: LD_EXP 172
92376: PUSH
92377: FOR_TO
92378: IFFALSE 92787
// begin tmp := mc_build_upgrade [ i ] ;
92380: LD_ADDR_VAR 0 4
92384: PUSH
92385: LD_EXP 204
92389: PUSH
92390: LD_VAR 0 2
92394: ARRAY
92395: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
92396: LD_ADDR_VAR 0 6
92400: PUSH
92401: LD_EXP 205
92405: PUSH
92406: LD_VAR 0 2
92410: ARRAY
92411: PPUSH
92412: LD_INT 2
92414: PUSH
92415: LD_INT 30
92417: PUSH
92418: LD_INT 6
92420: PUSH
92421: EMPTY
92422: LIST
92423: LIST
92424: PUSH
92425: LD_INT 30
92427: PUSH
92428: LD_INT 7
92430: PUSH
92431: EMPTY
92432: LIST
92433: LIST
92434: PUSH
92435: EMPTY
92436: LIST
92437: LIST
92438: LIST
92439: PPUSH
92440: CALL_OW 72
92444: ST_TO_ADDR
// if not tmp and not lab then
92445: LD_VAR 0 4
92449: NOT
92450: PUSH
92451: LD_VAR 0 6
92455: NOT
92456: AND
92457: IFFALSE 92461
// continue ;
92459: GO 92377
// if tmp then
92461: LD_VAR 0 4
92465: IFFALSE 92585
// for j in tmp do
92467: LD_ADDR_VAR 0 3
92471: PUSH
92472: LD_VAR 0 4
92476: PUSH
92477: FOR_IN
92478: IFFALSE 92583
// begin if UpgradeCost ( j ) then
92480: LD_VAR 0 3
92484: PPUSH
92485: CALL 30507 0 1
92489: IFFALSE 92581
// begin ComUpgrade ( j ) ;
92491: LD_VAR 0 3
92495: PPUSH
92496: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
92500: LD_ADDR_EXP 204
92504: PUSH
92505: LD_EXP 204
92509: PPUSH
92510: LD_VAR 0 2
92514: PPUSH
92515: LD_EXP 204
92519: PUSH
92520: LD_VAR 0 2
92524: ARRAY
92525: PUSH
92526: LD_VAR 0 3
92530: DIFF
92531: PPUSH
92532: CALL_OW 1
92536: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
92537: LD_ADDR_EXP 179
92541: PUSH
92542: LD_EXP 179
92546: PPUSH
92547: LD_VAR 0 2
92551: PUSH
92552: LD_EXP 179
92556: PUSH
92557: LD_VAR 0 2
92561: ARRAY
92562: PUSH
92563: LD_INT 1
92565: PLUS
92566: PUSH
92567: EMPTY
92568: LIST
92569: LIST
92570: PPUSH
92571: LD_VAR 0 3
92575: PPUSH
92576: CALL 24096 0 3
92580: ST_TO_ADDR
// end ; end ;
92581: GO 92477
92583: POP
92584: POP
// if not lab or not mc_lab_upgrade [ i ] then
92585: LD_VAR 0 6
92589: NOT
92590: PUSH
92591: LD_EXP 206
92595: PUSH
92596: LD_VAR 0 2
92600: ARRAY
92601: NOT
92602: OR
92603: IFFALSE 92607
// continue ;
92605: GO 92377
// for j in lab do
92607: LD_ADDR_VAR 0 3
92611: PUSH
92612: LD_VAR 0 6
92616: PUSH
92617: FOR_IN
92618: IFFALSE 92783
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
92620: LD_VAR 0 3
92624: PPUSH
92625: CALL_OW 266
92629: PUSH
92630: LD_INT 6
92632: PUSH
92633: LD_INT 7
92635: PUSH
92636: EMPTY
92637: LIST
92638: LIST
92639: IN
92640: PUSH
92641: LD_VAR 0 3
92645: PPUSH
92646: CALL_OW 461
92650: PUSH
92651: LD_INT 1
92653: NONEQUAL
92654: AND
92655: IFFALSE 92781
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
92657: LD_VAR 0 3
92661: PPUSH
92662: LD_EXP 206
92666: PUSH
92667: LD_VAR 0 2
92671: ARRAY
92672: PUSH
92673: LD_INT 1
92675: ARRAY
92676: PPUSH
92677: CALL 30712 0 2
92681: IFFALSE 92781
// begin ComCancel ( j ) ;
92683: LD_VAR 0 3
92687: PPUSH
92688: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
92692: LD_VAR 0 3
92696: PPUSH
92697: LD_EXP 206
92701: PUSH
92702: LD_VAR 0 2
92706: ARRAY
92707: PUSH
92708: LD_INT 1
92710: ARRAY
92711: PPUSH
92712: CALL_OW 207
// if not j in mc_construct_list [ i ] then
92716: LD_VAR 0 3
92720: PUSH
92721: LD_EXP 179
92725: PUSH
92726: LD_VAR 0 2
92730: ARRAY
92731: IN
92732: NOT
92733: IFFALSE 92779
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
92735: LD_ADDR_EXP 179
92739: PUSH
92740: LD_EXP 179
92744: PPUSH
92745: LD_VAR 0 2
92749: PUSH
92750: LD_EXP 179
92754: PUSH
92755: LD_VAR 0 2
92759: ARRAY
92760: PUSH
92761: LD_INT 1
92763: PLUS
92764: PUSH
92765: EMPTY
92766: LIST
92767: LIST
92768: PPUSH
92769: LD_VAR 0 3
92773: PPUSH
92774: CALL 24096 0 3
92778: ST_TO_ADDR
// break ;
92779: GO 92783
// end ; end ; end ;
92781: GO 92617
92783: POP
92784: POP
// end ;
92785: GO 92377
92787: POP
92788: POP
// end ;
92789: LD_VAR 0 1
92793: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
92794: LD_INT 0
92796: PPUSH
92797: PPUSH
92798: PPUSH
92799: PPUSH
92800: PPUSH
92801: PPUSH
92802: PPUSH
92803: PPUSH
92804: PPUSH
// if not mc_bases then
92805: LD_EXP 172
92809: NOT
92810: IFFALSE 92814
// exit ;
92812: GO 93219
// for i = 1 to mc_bases do
92814: LD_ADDR_VAR 0 2
92818: PUSH
92819: DOUBLE
92820: LD_INT 1
92822: DEC
92823: ST_TO_ADDR
92824: LD_EXP 172
92828: PUSH
92829: FOR_TO
92830: IFFALSE 93217
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
92832: LD_EXP 180
92836: PUSH
92837: LD_VAR 0 2
92841: ARRAY
92842: NOT
92843: PUSH
92844: LD_EXP 172
92848: PUSH
92849: LD_VAR 0 2
92853: ARRAY
92854: PPUSH
92855: LD_INT 30
92857: PUSH
92858: LD_INT 3
92860: PUSH
92861: EMPTY
92862: LIST
92863: LIST
92864: PPUSH
92865: CALL_OW 72
92869: NOT
92870: OR
92871: IFFALSE 92875
// continue ;
92873: GO 92829
// busy := false ;
92875: LD_ADDR_VAR 0 8
92879: PUSH
92880: LD_INT 0
92882: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
92883: LD_ADDR_VAR 0 4
92887: PUSH
92888: LD_EXP 172
92892: PUSH
92893: LD_VAR 0 2
92897: ARRAY
92898: PPUSH
92899: LD_INT 30
92901: PUSH
92902: LD_INT 3
92904: PUSH
92905: EMPTY
92906: LIST
92907: LIST
92908: PPUSH
92909: CALL_OW 72
92913: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
92914: LD_ADDR_VAR 0 6
92918: PUSH
92919: LD_EXP 180
92923: PUSH
92924: LD_VAR 0 2
92928: ARRAY
92929: PPUSH
92930: LD_INT 2
92932: PUSH
92933: LD_INT 30
92935: PUSH
92936: LD_INT 32
92938: PUSH
92939: EMPTY
92940: LIST
92941: LIST
92942: PUSH
92943: LD_INT 30
92945: PUSH
92946: LD_INT 33
92948: PUSH
92949: EMPTY
92950: LIST
92951: LIST
92952: PUSH
92953: EMPTY
92954: LIST
92955: LIST
92956: LIST
92957: PPUSH
92958: CALL_OW 72
92962: ST_TO_ADDR
// if not t then
92963: LD_VAR 0 6
92967: NOT
92968: IFFALSE 92972
// continue ;
92970: GO 92829
// for j in tmp do
92972: LD_ADDR_VAR 0 3
92976: PUSH
92977: LD_VAR 0 4
92981: PUSH
92982: FOR_IN
92983: IFFALSE 93013
// if not BuildingStatus ( j ) = bs_idle then
92985: LD_VAR 0 3
92989: PPUSH
92990: CALL_OW 461
92994: PUSH
92995: LD_INT 2
92997: EQUAL
92998: NOT
92999: IFFALSE 93011
// begin busy := true ;
93001: LD_ADDR_VAR 0 8
93005: PUSH
93006: LD_INT 1
93008: ST_TO_ADDR
// break ;
93009: GO 93013
// end ;
93011: GO 92982
93013: POP
93014: POP
// if busy then
93015: LD_VAR 0 8
93019: IFFALSE 93023
// continue ;
93021: GO 92829
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
93023: LD_ADDR_VAR 0 7
93027: PUSH
93028: LD_VAR 0 6
93032: PPUSH
93033: LD_INT 35
93035: PUSH
93036: LD_INT 0
93038: PUSH
93039: EMPTY
93040: LIST
93041: LIST
93042: PPUSH
93043: CALL_OW 72
93047: ST_TO_ADDR
// if tw then
93048: LD_VAR 0 7
93052: IFFALSE 93129
// begin tw := tw [ 1 ] ;
93054: LD_ADDR_VAR 0 7
93058: PUSH
93059: LD_VAR 0 7
93063: PUSH
93064: LD_INT 1
93066: ARRAY
93067: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
93068: LD_ADDR_VAR 0 9
93072: PUSH
93073: LD_VAR 0 7
93077: PPUSH
93078: LD_EXP 197
93082: PUSH
93083: LD_VAR 0 2
93087: ARRAY
93088: PPUSH
93089: CALL 29066 0 2
93093: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
93094: LD_EXP 211
93098: PUSH
93099: LD_VAR 0 2
93103: ARRAY
93104: IFFALSE 93127
// if not weapon in mc_allowed_tower_weapons [ i ] then
93106: LD_VAR 0 9
93110: PUSH
93111: LD_EXP 211
93115: PUSH
93116: LD_VAR 0 2
93120: ARRAY
93121: IN
93122: NOT
93123: IFFALSE 93127
// continue ;
93125: GO 92829
// end else
93127: GO 93192
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
93129: LD_ADDR_VAR 0 5
93133: PUSH
93134: LD_EXP 180
93138: PUSH
93139: LD_VAR 0 2
93143: ARRAY
93144: PPUSH
93145: LD_VAR 0 4
93149: PPUSH
93150: CALL 54687 0 2
93154: ST_TO_ADDR
// if not tmp2 then
93155: LD_VAR 0 5
93159: NOT
93160: IFFALSE 93164
// continue ;
93162: GO 92829
// tw := tmp2 [ 1 ] ;
93164: LD_ADDR_VAR 0 7
93168: PUSH
93169: LD_VAR 0 5
93173: PUSH
93174: LD_INT 1
93176: ARRAY
93177: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
93178: LD_ADDR_VAR 0 9
93182: PUSH
93183: LD_VAR 0 5
93187: PUSH
93188: LD_INT 2
93190: ARRAY
93191: ST_TO_ADDR
// end ; if not weapon then
93192: LD_VAR 0 9
93196: NOT
93197: IFFALSE 93201
// continue ;
93199: GO 92829
// ComPlaceWeapon ( tw , weapon ) ;
93201: LD_VAR 0 7
93205: PPUSH
93206: LD_VAR 0 9
93210: PPUSH
93211: CALL_OW 148
// end ;
93215: GO 92829
93217: POP
93218: POP
// end ;
93219: LD_VAR 0 1
93223: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list , r ; begin
93224: LD_INT 0
93226: PPUSH
93227: PPUSH
93228: PPUSH
93229: PPUSH
93230: PPUSH
93231: PPUSH
93232: PPUSH
// if not mc_bases then
93233: LD_EXP 172
93237: NOT
93238: IFFALSE 93242
// exit ;
93240: GO 94010
// for i = 1 to mc_bases do
93242: LD_ADDR_VAR 0 2
93246: PUSH
93247: DOUBLE
93248: LD_INT 1
93250: DEC
93251: ST_TO_ADDR
93252: LD_EXP 172
93256: PUSH
93257: FOR_TO
93258: IFFALSE 94008
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] or mc_scan [ i ] then
93260: LD_EXP 185
93264: PUSH
93265: LD_VAR 0 2
93269: ARRAY
93270: NOT
93271: PUSH
93272: LD_EXP 185
93276: PUSH
93277: LD_VAR 0 2
93281: ARRAY
93282: PUSH
93283: LD_EXP 186
93287: PUSH
93288: LD_VAR 0 2
93292: ARRAY
93293: EQUAL
93294: OR
93295: PUSH
93296: LD_EXP 195
93300: PUSH
93301: LD_VAR 0 2
93305: ARRAY
93306: OR
93307: IFFALSE 93311
// continue ;
93309: GO 93257
// if mc_miners [ i ] then
93311: LD_EXP 186
93315: PUSH
93316: LD_VAR 0 2
93320: ARRAY
93321: IFFALSE 93695
// begin for j = mc_miners [ i ] downto 1 do
93323: LD_ADDR_VAR 0 3
93327: PUSH
93328: DOUBLE
93329: LD_EXP 186
93333: PUSH
93334: LD_VAR 0 2
93338: ARRAY
93339: INC
93340: ST_TO_ADDR
93341: LD_INT 1
93343: PUSH
93344: FOR_DOWNTO
93345: IFFALSE 93693
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
93347: LD_EXP 186
93351: PUSH
93352: LD_VAR 0 2
93356: ARRAY
93357: PUSH
93358: LD_VAR 0 3
93362: ARRAY
93363: PPUSH
93364: CALL_OW 301
93368: PUSH
93369: LD_EXP 186
93373: PUSH
93374: LD_VAR 0 2
93378: ARRAY
93379: PUSH
93380: LD_VAR 0 3
93384: ARRAY
93385: PPUSH
93386: CALL_OW 257
93390: PUSH
93391: LD_INT 1
93393: NONEQUAL
93394: OR
93395: IFFALSE 93458
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
93397: LD_ADDR_VAR 0 5
93401: PUSH
93402: LD_EXP 186
93406: PUSH
93407: LD_VAR 0 2
93411: ARRAY
93412: PUSH
93413: LD_EXP 186
93417: PUSH
93418: LD_VAR 0 2
93422: ARRAY
93423: PUSH
93424: LD_VAR 0 3
93428: ARRAY
93429: DIFF
93430: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
93431: LD_ADDR_EXP 186
93435: PUSH
93436: LD_EXP 186
93440: PPUSH
93441: LD_VAR 0 2
93445: PPUSH
93446: LD_VAR 0 5
93450: PPUSH
93451: CALL_OW 1
93455: ST_TO_ADDR
// continue ;
93456: GO 93344
// end ; if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and not HasTask ( mc_miners [ i ] [ j ] ) then
93458: LD_EXP 186
93462: PUSH
93463: LD_VAR 0 2
93467: ARRAY
93468: PUSH
93469: LD_VAR 0 3
93473: ARRAY
93474: PPUSH
93475: CALL_OW 257
93479: PUSH
93480: LD_INT 1
93482: EQUAL
93483: PUSH
93484: LD_EXP 186
93488: PUSH
93489: LD_VAR 0 2
93493: ARRAY
93494: PUSH
93495: LD_VAR 0 3
93499: ARRAY
93500: PPUSH
93501: CALL_OW 459
93505: NOT
93506: AND
93507: PUSH
93508: LD_EXP 186
93512: PUSH
93513: LD_VAR 0 2
93517: ARRAY
93518: PUSH
93519: LD_VAR 0 3
93523: ARRAY
93524: PPUSH
93525: CALL_OW 314
93529: NOT
93530: AND
93531: IFFALSE 93691
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
93533: LD_EXP 186
93537: PUSH
93538: LD_VAR 0 2
93542: ARRAY
93543: PUSH
93544: LD_VAR 0 3
93548: ARRAY
93549: PPUSH
93550: CALL_OW 310
93554: IFFALSE 93577
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
93556: LD_EXP 186
93560: PUSH
93561: LD_VAR 0 2
93565: ARRAY
93566: PUSH
93567: LD_VAR 0 3
93571: ARRAY
93572: PPUSH
93573: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
93577: LD_EXP 186
93581: PUSH
93582: LD_VAR 0 2
93586: ARRAY
93587: PUSH
93588: LD_VAR 0 3
93592: ARRAY
93593: PPUSH
93594: CALL_OW 314
93598: NOT
93599: IFFALSE 93691
// begin r := rand ( 1 , mc_mines [ i ] ) ;
93601: LD_ADDR_VAR 0 7
93605: PUSH
93606: LD_INT 1
93608: PPUSH
93609: LD_EXP 185
93613: PUSH
93614: LD_VAR 0 2
93618: ARRAY
93619: PPUSH
93620: CALL_OW 12
93624: ST_TO_ADDR
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ r ] [ 1 ] , mc_mines [ i ] [ r ] [ 2 ] , 0 ) ;
93625: LD_EXP 186
93629: PUSH
93630: LD_VAR 0 2
93634: ARRAY
93635: PUSH
93636: LD_VAR 0 3
93640: ARRAY
93641: PPUSH
93642: LD_EXP 185
93646: PUSH
93647: LD_VAR 0 2
93651: ARRAY
93652: PUSH
93653: LD_VAR 0 7
93657: ARRAY
93658: PUSH
93659: LD_INT 1
93661: ARRAY
93662: PPUSH
93663: LD_EXP 185
93667: PUSH
93668: LD_VAR 0 2
93672: ARRAY
93673: PUSH
93674: LD_VAR 0 7
93678: ARRAY
93679: PUSH
93680: LD_INT 2
93682: ARRAY
93683: PPUSH
93684: LD_INT 0
93686: PPUSH
93687: CALL_OW 193
// end ; end ; end ;
93691: GO 93344
93693: POP
93694: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
93695: LD_ADDR_VAR 0 5
93699: PUSH
93700: LD_EXP 172
93704: PUSH
93705: LD_VAR 0 2
93709: ARRAY
93710: PPUSH
93711: LD_INT 2
93713: PUSH
93714: LD_INT 30
93716: PUSH
93717: LD_INT 4
93719: PUSH
93720: EMPTY
93721: LIST
93722: LIST
93723: PUSH
93724: LD_INT 30
93726: PUSH
93727: LD_INT 5
93729: PUSH
93730: EMPTY
93731: LIST
93732: LIST
93733: PUSH
93734: LD_INT 30
93736: PUSH
93737: LD_INT 32
93739: PUSH
93740: EMPTY
93741: LIST
93742: LIST
93743: PUSH
93744: EMPTY
93745: LIST
93746: LIST
93747: LIST
93748: LIST
93749: PPUSH
93750: CALL_OW 72
93754: ST_TO_ADDR
// if not tmp then
93755: LD_VAR 0 5
93759: NOT
93760: IFFALSE 93764
// continue ;
93762: GO 93257
// list := [ ] ;
93764: LD_ADDR_VAR 0 6
93768: PUSH
93769: EMPTY
93770: ST_TO_ADDR
// for j in tmp do
93771: LD_ADDR_VAR 0 3
93775: PUSH
93776: LD_VAR 0 5
93780: PUSH
93781: FOR_IN
93782: IFFALSE 93851
// begin for k in UnitsInside ( j ) do
93784: LD_ADDR_VAR 0 4
93788: PUSH
93789: LD_VAR 0 3
93793: PPUSH
93794: CALL_OW 313
93798: PUSH
93799: FOR_IN
93800: IFFALSE 93847
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
93802: LD_VAR 0 4
93806: PPUSH
93807: CALL_OW 257
93811: PUSH
93812: LD_INT 1
93814: EQUAL
93815: PUSH
93816: LD_VAR 0 4
93820: PPUSH
93821: CALL_OW 459
93825: NOT
93826: AND
93827: IFFALSE 93845
// list := list ^ k ;
93829: LD_ADDR_VAR 0 6
93833: PUSH
93834: LD_VAR 0 6
93838: PUSH
93839: LD_VAR 0 4
93843: ADD
93844: ST_TO_ADDR
93845: GO 93799
93847: POP
93848: POP
// end ;
93849: GO 93781
93851: POP
93852: POP
// list := list diff mc_miners [ i ] ;
93853: LD_ADDR_VAR 0 6
93857: PUSH
93858: LD_VAR 0 6
93862: PUSH
93863: LD_EXP 186
93867: PUSH
93868: LD_VAR 0 2
93872: ARRAY
93873: DIFF
93874: ST_TO_ADDR
// if not list then
93875: LD_VAR 0 6
93879: NOT
93880: IFFALSE 93884
// continue ;
93882: GO 93257
// k := mc_mines [ i ] - mc_miners [ i ] ;
93884: LD_ADDR_VAR 0 4
93888: PUSH
93889: LD_EXP 185
93893: PUSH
93894: LD_VAR 0 2
93898: ARRAY
93899: PUSH
93900: LD_EXP 186
93904: PUSH
93905: LD_VAR 0 2
93909: ARRAY
93910: MINUS
93911: ST_TO_ADDR
// if k > list then
93912: LD_VAR 0 4
93916: PUSH
93917: LD_VAR 0 6
93921: GREATER
93922: IFFALSE 93934
// k := list ;
93924: LD_ADDR_VAR 0 4
93928: PUSH
93929: LD_VAR 0 6
93933: ST_TO_ADDR
// for j = 1 to k do
93934: LD_ADDR_VAR 0 3
93938: PUSH
93939: DOUBLE
93940: LD_INT 1
93942: DEC
93943: ST_TO_ADDR
93944: LD_VAR 0 4
93948: PUSH
93949: FOR_TO
93950: IFFALSE 94004
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
93952: LD_ADDR_EXP 186
93956: PUSH
93957: LD_EXP 186
93961: PPUSH
93962: LD_VAR 0 2
93966: PUSH
93967: LD_EXP 186
93971: PUSH
93972: LD_VAR 0 2
93976: ARRAY
93977: PUSH
93978: LD_INT 1
93980: PLUS
93981: PUSH
93982: EMPTY
93983: LIST
93984: LIST
93985: PPUSH
93986: LD_VAR 0 6
93990: PUSH
93991: LD_VAR 0 3
93995: ARRAY
93996: PPUSH
93997: CALL 24096 0 3
94001: ST_TO_ADDR
94002: GO 93949
94004: POP
94005: POP
// end ;
94006: GO 93257
94008: POP
94009: POP
// end ;
94010: LD_VAR 0 1
94014: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , target , cargo , depot , fac , components ; begin
94015: LD_INT 0
94017: PPUSH
94018: PPUSH
94019: PPUSH
94020: PPUSH
94021: PPUSH
94022: PPUSH
94023: PPUSH
94024: PPUSH
94025: PPUSH
94026: PPUSH
// if not mc_bases then
94027: LD_EXP 172
94031: NOT
94032: IFFALSE 94036
// exit ;
94034: GO 95786
// for i = 1 to mc_bases do
94036: LD_ADDR_VAR 0 2
94040: PUSH
94041: DOUBLE
94042: LD_INT 1
94044: DEC
94045: ST_TO_ADDR
94046: LD_EXP 172
94050: PUSH
94051: FOR_TO
94052: IFFALSE 95784
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
94054: LD_EXP 172
94058: PUSH
94059: LD_VAR 0 2
94063: ARRAY
94064: NOT
94065: PUSH
94066: LD_EXP 179
94070: PUSH
94071: LD_VAR 0 2
94075: ARRAY
94076: OR
94077: IFFALSE 94081
// continue ;
94079: GO 94051
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
94081: LD_EXP 188
94085: PUSH
94086: LD_VAR 0 2
94090: ARRAY
94091: NOT
94092: PUSH
94093: LD_EXP 189
94097: PUSH
94098: LD_VAR 0 2
94102: ARRAY
94103: AND
94104: IFFALSE 94142
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
94106: LD_ADDR_EXP 189
94110: PUSH
94111: LD_EXP 189
94115: PPUSH
94116: LD_VAR 0 2
94120: PPUSH
94121: EMPTY
94122: PPUSH
94123: CALL_OW 1
94127: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
94128: LD_VAR 0 2
94132: PPUSH
94133: LD_INT 107
94135: PPUSH
94136: CALL 84997 0 2
// continue ;
94140: GO 94051
// end ; target := [ ] ;
94142: LD_ADDR_VAR 0 6
94146: PUSH
94147: EMPTY
94148: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
94149: LD_ADDR_VAR 0 3
94153: PUSH
94154: DOUBLE
94155: LD_EXP 188
94159: PUSH
94160: LD_VAR 0 2
94164: ARRAY
94165: INC
94166: ST_TO_ADDR
94167: LD_INT 1
94169: PUSH
94170: FOR_DOWNTO
94171: IFFALSE 94431
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
94173: LD_EXP 188
94177: PUSH
94178: LD_VAR 0 2
94182: ARRAY
94183: PUSH
94184: LD_VAR 0 3
94188: ARRAY
94189: PUSH
94190: LD_INT 2
94192: ARRAY
94193: PPUSH
94194: LD_EXP 188
94198: PUSH
94199: LD_VAR 0 2
94203: ARRAY
94204: PUSH
94205: LD_VAR 0 3
94209: ARRAY
94210: PUSH
94211: LD_INT 3
94213: ARRAY
94214: PPUSH
94215: CALL_OW 488
94219: PUSH
94220: LD_EXP 188
94224: PUSH
94225: LD_VAR 0 2
94229: ARRAY
94230: PUSH
94231: LD_VAR 0 3
94235: ARRAY
94236: PUSH
94237: LD_INT 2
94239: ARRAY
94240: PPUSH
94241: LD_EXP 188
94245: PUSH
94246: LD_VAR 0 2
94250: ARRAY
94251: PUSH
94252: LD_VAR 0 3
94256: ARRAY
94257: PUSH
94258: LD_INT 3
94260: ARRAY
94261: PPUSH
94262: CALL_OW 284
94266: PUSH
94267: LD_INT 0
94269: EQUAL
94270: AND
94271: IFFALSE 94326
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
94273: LD_ADDR_VAR 0 5
94277: PUSH
94278: LD_EXP 188
94282: PUSH
94283: LD_VAR 0 2
94287: ARRAY
94288: PPUSH
94289: LD_VAR 0 3
94293: PPUSH
94294: CALL_OW 3
94298: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
94299: LD_ADDR_EXP 188
94303: PUSH
94304: LD_EXP 188
94308: PPUSH
94309: LD_VAR 0 2
94313: PPUSH
94314: LD_VAR 0 5
94318: PPUSH
94319: CALL_OW 1
94323: ST_TO_ADDR
// continue ;
94324: GO 94170
// end ; if DangerAtRangeXY ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
94326: LD_EXP 172
94330: PUSH
94331: LD_VAR 0 2
94335: ARRAY
94336: PUSH
94337: LD_INT 1
94339: ARRAY
94340: PPUSH
94341: CALL_OW 255
94345: PPUSH
94346: LD_EXP 188
94350: PUSH
94351: LD_VAR 0 2
94355: ARRAY
94356: PUSH
94357: LD_VAR 0 3
94361: ARRAY
94362: PUSH
94363: LD_INT 2
94365: ARRAY
94366: PPUSH
94367: LD_EXP 188
94371: PUSH
94372: LD_VAR 0 2
94376: ARRAY
94377: PUSH
94378: LD_VAR 0 3
94382: ARRAY
94383: PUSH
94384: LD_INT 3
94386: ARRAY
94387: PPUSH
94388: LD_INT 30
94390: PPUSH
94391: CALL 24992 0 4
94395: PUSH
94396: LD_INT 4
94398: ARRAY
94399: PUSH
94400: LD_INT 0
94402: EQUAL
94403: IFFALSE 94429
// begin target := mc_crates [ i ] [ j ] ;
94405: LD_ADDR_VAR 0 6
94409: PUSH
94410: LD_EXP 188
94414: PUSH
94415: LD_VAR 0 2
94419: ARRAY
94420: PUSH
94421: LD_VAR 0 3
94425: ARRAY
94426: ST_TO_ADDR
// break ;
94427: GO 94431
// end ; end ;
94429: GO 94170
94431: POP
94432: POP
// if not target then
94433: LD_VAR 0 6
94437: NOT
94438: IFFALSE 94442
// continue ;
94440: GO 94051
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
94442: LD_ADDR_VAR 0 7
94446: PUSH
94447: LD_EXP 191
94451: PUSH
94452: LD_VAR 0 2
94456: ARRAY
94457: PPUSH
94458: LD_INT 2
94460: PUSH
94461: LD_INT 3
94463: PUSH
94464: LD_INT 58
94466: PUSH
94467: EMPTY
94468: LIST
94469: PUSH
94470: EMPTY
94471: LIST
94472: LIST
94473: PUSH
94474: LD_INT 61
94476: PUSH
94477: EMPTY
94478: LIST
94479: PUSH
94480: LD_INT 33
94482: PUSH
94483: LD_INT 5
94485: PUSH
94486: EMPTY
94487: LIST
94488: LIST
94489: PUSH
94490: LD_INT 33
94492: PUSH
94493: LD_INT 3
94495: PUSH
94496: EMPTY
94497: LIST
94498: LIST
94499: PUSH
94500: EMPTY
94501: LIST
94502: LIST
94503: LIST
94504: LIST
94505: LIST
94506: PUSH
94507: LD_INT 2
94509: PUSH
94510: LD_INT 34
94512: PUSH
94513: LD_INT 32
94515: PUSH
94516: EMPTY
94517: LIST
94518: LIST
94519: PUSH
94520: LD_INT 34
94522: PUSH
94523: LD_INT 51
94525: PUSH
94526: EMPTY
94527: LIST
94528: LIST
94529: PUSH
94530: LD_INT 34
94532: PUSH
94533: LD_INT 12
94535: PUSH
94536: EMPTY
94537: LIST
94538: LIST
94539: PUSH
94540: EMPTY
94541: LIST
94542: LIST
94543: LIST
94544: LIST
94545: PUSH
94546: EMPTY
94547: LIST
94548: LIST
94549: PPUSH
94550: CALL_OW 72
94554: ST_TO_ADDR
// if not cargo then
94555: LD_VAR 0 7
94559: NOT
94560: IFFALSE 95203
// begin if mc_crates_collector [ i ] < 5 then
94562: LD_EXP 189
94566: PUSH
94567: LD_VAR 0 2
94571: ARRAY
94572: PUSH
94573: LD_INT 5
94575: LESS
94576: IFFALSE 94942
// begin if mc_ape [ i ] then
94578: LD_EXP 201
94582: PUSH
94583: LD_VAR 0 2
94587: ARRAY
94588: IFFALSE 94635
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
94590: LD_ADDR_VAR 0 5
94594: PUSH
94595: LD_EXP 201
94599: PUSH
94600: LD_VAR 0 2
94604: ARRAY
94605: PPUSH
94606: LD_INT 25
94608: PUSH
94609: LD_INT 16
94611: PUSH
94612: EMPTY
94613: LIST
94614: LIST
94615: PUSH
94616: LD_INT 24
94618: PUSH
94619: LD_INT 750
94621: PUSH
94622: EMPTY
94623: LIST
94624: LIST
94625: PUSH
94626: EMPTY
94627: LIST
94628: LIST
94629: PPUSH
94630: CALL_OW 72
94634: ST_TO_ADDR
// if not tmp then
94635: LD_VAR 0 5
94639: NOT
94640: IFFALSE 94687
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
94642: LD_ADDR_VAR 0 5
94646: PUSH
94647: LD_EXP 172
94651: PUSH
94652: LD_VAR 0 2
94656: ARRAY
94657: PPUSH
94658: LD_INT 25
94660: PUSH
94661: LD_INT 2
94663: PUSH
94664: EMPTY
94665: LIST
94666: LIST
94667: PUSH
94668: LD_INT 24
94670: PUSH
94671: LD_INT 750
94673: PUSH
94674: EMPTY
94675: LIST
94676: LIST
94677: PUSH
94678: EMPTY
94679: LIST
94680: LIST
94681: PPUSH
94682: CALL_OW 72
94686: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
94687: LD_EXP 201
94691: PUSH
94692: LD_VAR 0 2
94696: ARRAY
94697: PUSH
94698: LD_EXP 172
94702: PUSH
94703: LD_VAR 0 2
94707: ARRAY
94708: PPUSH
94709: LD_INT 25
94711: PUSH
94712: LD_INT 2
94714: PUSH
94715: EMPTY
94716: LIST
94717: LIST
94718: PUSH
94719: LD_INT 24
94721: PUSH
94722: LD_INT 750
94724: PUSH
94725: EMPTY
94726: LIST
94727: LIST
94728: PUSH
94729: EMPTY
94730: LIST
94731: LIST
94732: PPUSH
94733: CALL_OW 72
94737: AND
94738: PUSH
94739: LD_VAR 0 5
94743: PUSH
94744: LD_INT 5
94746: LESS
94747: AND
94748: IFFALSE 94830
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
94750: LD_ADDR_VAR 0 3
94754: PUSH
94755: LD_EXP 172
94759: PUSH
94760: LD_VAR 0 2
94764: ARRAY
94765: PPUSH
94766: LD_INT 25
94768: PUSH
94769: LD_INT 2
94771: PUSH
94772: EMPTY
94773: LIST
94774: LIST
94775: PUSH
94776: LD_INT 24
94778: PUSH
94779: LD_INT 750
94781: PUSH
94782: EMPTY
94783: LIST
94784: LIST
94785: PUSH
94786: EMPTY
94787: LIST
94788: LIST
94789: PPUSH
94790: CALL_OW 72
94794: PUSH
94795: FOR_IN
94796: IFFALSE 94828
// begin tmp := tmp union j ;
94798: LD_ADDR_VAR 0 5
94802: PUSH
94803: LD_VAR 0 5
94807: PUSH
94808: LD_VAR 0 3
94812: UNION
94813: ST_TO_ADDR
// if tmp >= 5 then
94814: LD_VAR 0 5
94818: PUSH
94819: LD_INT 5
94821: GREATEREQUAL
94822: IFFALSE 94826
// break ;
94824: GO 94828
// end ;
94826: GO 94795
94828: POP
94829: POP
// end ; if not tmp then
94830: LD_VAR 0 5
94834: NOT
94835: IFFALSE 94839
// continue ;
94837: GO 94051
// for j in tmp do
94839: LD_ADDR_VAR 0 3
94843: PUSH
94844: LD_VAR 0 5
94848: PUSH
94849: FOR_IN
94850: IFFALSE 94940
// if not GetTag ( j ) then
94852: LD_VAR 0 3
94856: PPUSH
94857: CALL_OW 110
94861: NOT
94862: IFFALSE 94938
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
94864: LD_ADDR_EXP 189
94868: PUSH
94869: LD_EXP 189
94873: PPUSH
94874: LD_VAR 0 2
94878: PUSH
94879: LD_EXP 189
94883: PUSH
94884: LD_VAR 0 2
94888: ARRAY
94889: PUSH
94890: LD_INT 1
94892: PLUS
94893: PUSH
94894: EMPTY
94895: LIST
94896: LIST
94897: PPUSH
94898: LD_VAR 0 3
94902: PPUSH
94903: CALL 24096 0 3
94907: ST_TO_ADDR
// SetTag ( j , 107 ) ;
94908: LD_VAR 0 3
94912: PPUSH
94913: LD_INT 107
94915: PPUSH
94916: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
94920: LD_EXP 189
94924: PUSH
94925: LD_VAR 0 2
94929: ARRAY
94930: PUSH
94931: LD_INT 5
94933: GREATEREQUAL
94934: IFFALSE 94938
// break ;
94936: GO 94940
// end ;
94938: GO 94849
94940: POP
94941: POP
// end ; if mc_crates_collector [ i ] and target then
94942: LD_EXP 189
94946: PUSH
94947: LD_VAR 0 2
94951: ARRAY
94952: PUSH
94953: LD_VAR 0 6
94957: AND
94958: IFFALSE 95201
// begin if mc_crates_collector [ i ] < target [ 1 ] then
94960: LD_EXP 189
94964: PUSH
94965: LD_VAR 0 2
94969: ARRAY
94970: PUSH
94971: LD_VAR 0 6
94975: PUSH
94976: LD_INT 1
94978: ARRAY
94979: LESS
94980: IFFALSE 95000
// tmp := mc_crates_collector [ i ] else
94982: LD_ADDR_VAR 0 5
94986: PUSH
94987: LD_EXP 189
94991: PUSH
94992: LD_VAR 0 2
94996: ARRAY
94997: ST_TO_ADDR
94998: GO 95014
// tmp := target [ 1 ] ;
95000: LD_ADDR_VAR 0 5
95004: PUSH
95005: LD_VAR 0 6
95009: PUSH
95010: LD_INT 1
95012: ARRAY
95013: ST_TO_ADDR
// k := 0 ;
95014: LD_ADDR_VAR 0 4
95018: PUSH
95019: LD_INT 0
95021: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
95022: LD_ADDR_VAR 0 3
95026: PUSH
95027: LD_EXP 189
95031: PUSH
95032: LD_VAR 0 2
95036: ARRAY
95037: PUSH
95038: FOR_IN
95039: IFFALSE 95199
// begin k := k + 1 ;
95041: LD_ADDR_VAR 0 4
95045: PUSH
95046: LD_VAR 0 4
95050: PUSH
95051: LD_INT 1
95053: PLUS
95054: ST_TO_ADDR
// if k > tmp then
95055: LD_VAR 0 4
95059: PUSH
95060: LD_VAR 0 5
95064: GREATER
95065: IFFALSE 95069
// break ;
95067: GO 95199
// if not GetClass ( j ) in [ 2 , 16 ] then
95069: LD_VAR 0 3
95073: PPUSH
95074: CALL_OW 257
95078: PUSH
95079: LD_INT 2
95081: PUSH
95082: LD_INT 16
95084: PUSH
95085: EMPTY
95086: LIST
95087: LIST
95088: IN
95089: NOT
95090: IFFALSE 95143
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
95092: LD_ADDR_EXP 189
95096: PUSH
95097: LD_EXP 189
95101: PPUSH
95102: LD_VAR 0 2
95106: PPUSH
95107: LD_EXP 189
95111: PUSH
95112: LD_VAR 0 2
95116: ARRAY
95117: PUSH
95118: LD_VAR 0 3
95122: DIFF
95123: PPUSH
95124: CALL_OW 1
95128: ST_TO_ADDR
// SetTag ( j , 0 ) ;
95129: LD_VAR 0 3
95133: PPUSH
95134: LD_INT 0
95136: PPUSH
95137: CALL_OW 109
// continue ;
95141: GO 95038
// end ; if IsInUnit ( j ) then
95143: LD_VAR 0 3
95147: PPUSH
95148: CALL_OW 310
95152: IFFALSE 95163
// ComExitBuilding ( j ) ;
95154: LD_VAR 0 3
95158: PPUSH
95159: CALL_OW 122
// wait ( 3 ) ;
95163: LD_INT 3
95165: PPUSH
95166: CALL_OW 67
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
95170: LD_VAR 0 3
95174: PPUSH
95175: LD_VAR 0 6
95179: PUSH
95180: LD_INT 2
95182: ARRAY
95183: PPUSH
95184: LD_VAR 0 6
95188: PUSH
95189: LD_INT 3
95191: ARRAY
95192: PPUSH
95193: CALL_OW 117
// end ;
95197: GO 95038
95199: POP
95200: POP
// end ; end else
95201: GO 95782
// begin for j in cargo do
95203: LD_ADDR_VAR 0 3
95207: PUSH
95208: LD_VAR 0 7
95212: PUSH
95213: FOR_IN
95214: IFFALSE 95780
// begin if GetTag ( j ) <> 0 then
95216: LD_VAR 0 3
95220: PPUSH
95221: CALL_OW 110
95225: PUSH
95226: LD_INT 0
95228: NONEQUAL
95229: IFFALSE 95233
// continue ;
95231: GO 95213
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
95233: LD_VAR 0 3
95237: PPUSH
95238: CALL_OW 256
95242: PUSH
95243: LD_INT 1000
95245: LESS
95246: PUSH
95247: LD_VAR 0 3
95251: PPUSH
95252: LD_EXP 196
95256: PUSH
95257: LD_VAR 0 2
95261: ARRAY
95262: PPUSH
95263: CALL_OW 308
95267: NOT
95268: AND
95269: IFFALSE 95291
// ComMoveToArea ( j , mc_parking [ i ] ) ;
95271: LD_VAR 0 3
95275: PPUSH
95276: LD_EXP 196
95280: PUSH
95281: LD_VAR 0 2
95285: ARRAY
95286: PPUSH
95287: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
95291: LD_VAR 0 3
95295: PPUSH
95296: CALL_OW 256
95300: PUSH
95301: LD_INT 1000
95303: LESS
95304: PUSH
95305: LD_VAR 0 3
95309: PPUSH
95310: LD_EXP 196
95314: PUSH
95315: LD_VAR 0 2
95319: ARRAY
95320: PPUSH
95321: CALL_OW 308
95325: AND
95326: IFFALSE 95330
// continue ;
95328: GO 95213
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
95330: LD_VAR 0 3
95334: PPUSH
95335: CALL_OW 262
95339: PUSH
95340: LD_INT 2
95342: EQUAL
95343: PUSH
95344: LD_VAR 0 3
95348: PPUSH
95349: CALL_OW 261
95353: PUSH
95354: LD_INT 15
95356: LESS
95357: AND
95358: IFFALSE 95362
// continue ;
95360: GO 95213
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
95362: LD_VAR 0 3
95366: PPUSH
95367: CALL_OW 262
95371: PUSH
95372: LD_INT 1
95374: EQUAL
95375: PUSH
95376: LD_VAR 0 3
95380: PPUSH
95381: CALL_OW 261
95385: PUSH
95386: LD_INT 10
95388: LESS
95389: AND
95390: IFFALSE 95719
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
95392: LD_ADDR_VAR 0 8
95396: PUSH
95397: LD_EXP 172
95401: PUSH
95402: LD_VAR 0 2
95406: ARRAY
95407: PPUSH
95408: LD_INT 2
95410: PUSH
95411: LD_INT 30
95413: PUSH
95414: LD_INT 0
95416: PUSH
95417: EMPTY
95418: LIST
95419: LIST
95420: PUSH
95421: LD_INT 30
95423: PUSH
95424: LD_INT 1
95426: PUSH
95427: EMPTY
95428: LIST
95429: LIST
95430: PUSH
95431: EMPTY
95432: LIST
95433: LIST
95434: LIST
95435: PPUSH
95436: CALL_OW 72
95440: ST_TO_ADDR
// if not depot then
95441: LD_VAR 0 8
95445: NOT
95446: IFFALSE 95450
// continue ;
95448: GO 95213
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
95450: LD_VAR 0 3
95454: PPUSH
95455: LD_VAR 0 8
95459: PPUSH
95460: LD_VAR 0 3
95464: PPUSH
95465: CALL_OW 74
95469: PPUSH
95470: CALL_OW 296
95474: PUSH
95475: LD_INT 6
95477: LESS
95478: IFFALSE 95494
// SetFuel ( j , 100 ) else
95480: LD_VAR 0 3
95484: PPUSH
95485: LD_INT 100
95487: PPUSH
95488: CALL_OW 240
95492: GO 95719
// if GetFuel ( j ) = 0 then
95494: LD_VAR 0 3
95498: PPUSH
95499: CALL_OW 261
95503: PUSH
95504: LD_INT 0
95506: EQUAL
95507: IFFALSE 95719
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
95509: LD_ADDR_EXP 191
95513: PUSH
95514: LD_EXP 191
95518: PPUSH
95519: LD_VAR 0 2
95523: PPUSH
95524: LD_EXP 191
95528: PUSH
95529: LD_VAR 0 2
95533: ARRAY
95534: PUSH
95535: LD_VAR 0 3
95539: DIFF
95540: PPUSH
95541: CALL_OW 1
95545: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
95546: LD_VAR 0 3
95550: PPUSH
95551: CALL_OW 263
95555: PUSH
95556: LD_INT 1
95558: EQUAL
95559: IFFALSE 95575
// ComExitVehicle ( IsInUnit ( j ) ) ;
95561: LD_VAR 0 3
95565: PPUSH
95566: CALL_OW 310
95570: PPUSH
95571: CALL_OW 121
// if GetControl ( j ) = control_remote then
95575: LD_VAR 0 3
95579: PPUSH
95580: CALL_OW 263
95584: PUSH
95585: LD_INT 2
95587: EQUAL
95588: IFFALSE 95599
// ComUnlink ( j ) ;
95590: LD_VAR 0 3
95594: PPUSH
95595: CALL_OW 136
// fac := MC_GetBuildings ( i , b_factory ) ;
95599: LD_ADDR_VAR 0 9
95603: PUSH
95604: LD_VAR 0 2
95608: PPUSH
95609: LD_INT 3
95611: PPUSH
95612: CALL 105094 0 2
95616: ST_TO_ADDR
// if fac then
95617: LD_VAR 0 9
95621: IFFALSE 95717
// begin for k in fac do
95623: LD_ADDR_VAR 0 4
95627: PUSH
95628: LD_VAR 0 9
95632: PUSH
95633: FOR_IN
95634: IFFALSE 95715
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
95636: LD_ADDR_VAR 0 10
95640: PUSH
95641: LD_VAR 0 9
95645: PPUSH
95646: LD_VAR 0 3
95650: PPUSH
95651: CALL_OW 265
95655: PPUSH
95656: LD_VAR 0 3
95660: PPUSH
95661: CALL_OW 262
95665: PPUSH
95666: LD_VAR 0 3
95670: PPUSH
95671: CALL_OW 263
95675: PPUSH
95676: LD_VAR 0 3
95680: PPUSH
95681: CALL_OW 264
95685: PPUSH
95686: CALL 21628 0 5
95690: ST_TO_ADDR
// if components then
95691: LD_VAR 0 10
95695: IFFALSE 95713
// begin MC_InsertProduceList ( i , components ) ;
95697: LD_VAR 0 2
95701: PPUSH
95702: LD_VAR 0 10
95706: PPUSH
95707: CALL 104639 0 2
// break ;
95711: GO 95715
// end ; end ;
95713: GO 95633
95715: POP
95716: POP
// end ; continue ;
95717: GO 95213
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
95719: LD_VAR 0 3
95723: PPUSH
95724: LD_INT 1
95726: PPUSH
95727: CALL_OW 289
95731: PUSH
95732: LD_INT 100
95734: LESS
95735: PUSH
95736: LD_VAR 0 3
95740: PPUSH
95741: CALL_OW 314
95745: NOT
95746: AND
95747: IFFALSE 95776
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
95749: LD_VAR 0 3
95753: PPUSH
95754: LD_VAR 0 6
95758: PUSH
95759: LD_INT 2
95761: ARRAY
95762: PPUSH
95763: LD_VAR 0 6
95767: PUSH
95768: LD_INT 3
95770: ARRAY
95771: PPUSH
95772: CALL_OW 117
// break ;
95776: GO 95780
// end ;
95778: GO 95213
95780: POP
95781: POP
// end ; end ;
95782: GO 94051
95784: POP
95785: POP
// end ;
95786: LD_VAR 0 1
95790: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
95791: LD_INT 0
95793: PPUSH
95794: PPUSH
95795: PPUSH
95796: PPUSH
// if not mc_bases then
95797: LD_EXP 172
95801: NOT
95802: IFFALSE 95806
// exit ;
95804: GO 95967
// for i = 1 to mc_bases do
95806: LD_ADDR_VAR 0 2
95810: PUSH
95811: DOUBLE
95812: LD_INT 1
95814: DEC
95815: ST_TO_ADDR
95816: LD_EXP 172
95820: PUSH
95821: FOR_TO
95822: IFFALSE 95965
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
95824: LD_ADDR_VAR 0 4
95828: PUSH
95829: LD_EXP 191
95833: PUSH
95834: LD_VAR 0 2
95838: ARRAY
95839: PUSH
95840: LD_EXP 194
95844: PUSH
95845: LD_VAR 0 2
95849: ARRAY
95850: UNION
95851: PPUSH
95852: LD_INT 33
95854: PUSH
95855: LD_INT 2
95857: PUSH
95858: EMPTY
95859: LIST
95860: LIST
95861: PPUSH
95862: CALL_OW 72
95866: ST_TO_ADDR
// if tmp then
95867: LD_VAR 0 4
95871: IFFALSE 95963
// for j in tmp do
95873: LD_ADDR_VAR 0 3
95877: PUSH
95878: LD_VAR 0 4
95882: PUSH
95883: FOR_IN
95884: IFFALSE 95961
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
95886: LD_VAR 0 3
95890: PPUSH
95891: CALL_OW 312
95895: NOT
95896: PUSH
95897: LD_VAR 0 3
95901: PPUSH
95902: CALL_OW 256
95906: PUSH
95907: LD_INT 250
95909: GREATEREQUAL
95910: AND
95911: IFFALSE 95924
// Connect ( j ) else
95913: LD_VAR 0 3
95917: PPUSH
95918: CALL 27029 0 1
95922: GO 95959
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
95924: LD_VAR 0 3
95928: PPUSH
95929: CALL_OW 256
95933: PUSH
95934: LD_INT 250
95936: LESS
95937: PUSH
95938: LD_VAR 0 3
95942: PPUSH
95943: CALL_OW 312
95947: AND
95948: IFFALSE 95959
// ComUnlink ( j ) ;
95950: LD_VAR 0 3
95954: PPUSH
95955: CALL_OW 136
95959: GO 95883
95961: POP
95962: POP
// end ;
95963: GO 95821
95965: POP
95966: POP
// end ;
95967: LD_VAR 0 1
95971: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
95972: LD_INT 0
95974: PPUSH
95975: PPUSH
95976: PPUSH
95977: PPUSH
95978: PPUSH
// if not mc_bases then
95979: LD_EXP 172
95983: NOT
95984: IFFALSE 95988
// exit ;
95986: GO 96433
// for i = 1 to mc_bases do
95988: LD_ADDR_VAR 0 2
95992: PUSH
95993: DOUBLE
95994: LD_INT 1
95996: DEC
95997: ST_TO_ADDR
95998: LD_EXP 172
96002: PUSH
96003: FOR_TO
96004: IFFALSE 96431
// begin if not mc_produce [ i ] then
96006: LD_EXP 193
96010: PUSH
96011: LD_VAR 0 2
96015: ARRAY
96016: NOT
96017: IFFALSE 96021
// continue ;
96019: GO 96003
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
96021: LD_ADDR_VAR 0 5
96025: PUSH
96026: LD_EXP 172
96030: PUSH
96031: LD_VAR 0 2
96035: ARRAY
96036: PPUSH
96037: LD_INT 30
96039: PUSH
96040: LD_INT 3
96042: PUSH
96043: EMPTY
96044: LIST
96045: LIST
96046: PPUSH
96047: CALL_OW 72
96051: ST_TO_ADDR
// if not fac then
96052: LD_VAR 0 5
96056: NOT
96057: IFFALSE 96061
// continue ;
96059: GO 96003
// for j in fac do
96061: LD_ADDR_VAR 0 3
96065: PUSH
96066: LD_VAR 0 5
96070: PUSH
96071: FOR_IN
96072: IFFALSE 96427
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
96074: LD_VAR 0 3
96078: PPUSH
96079: CALL_OW 461
96083: PUSH
96084: LD_INT 2
96086: NONEQUAL
96087: PUSH
96088: LD_VAR 0 3
96092: PPUSH
96093: LD_INT 15
96095: PPUSH
96096: CALL 26689 0 2
96100: PUSH
96101: LD_INT 4
96103: ARRAY
96104: OR
96105: IFFALSE 96109
// continue ;
96107: GO 96071
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
96109: LD_VAR 0 3
96113: PPUSH
96114: LD_EXP 193
96118: PUSH
96119: LD_VAR 0 2
96123: ARRAY
96124: PUSH
96125: LD_INT 1
96127: ARRAY
96128: PUSH
96129: LD_INT 1
96131: ARRAY
96132: PPUSH
96133: LD_EXP 193
96137: PUSH
96138: LD_VAR 0 2
96142: ARRAY
96143: PUSH
96144: LD_INT 1
96146: ARRAY
96147: PUSH
96148: LD_INT 2
96150: ARRAY
96151: PPUSH
96152: LD_EXP 193
96156: PUSH
96157: LD_VAR 0 2
96161: ARRAY
96162: PUSH
96163: LD_INT 1
96165: ARRAY
96166: PUSH
96167: LD_INT 3
96169: ARRAY
96170: PPUSH
96171: LD_EXP 193
96175: PUSH
96176: LD_VAR 0 2
96180: ARRAY
96181: PUSH
96182: LD_INT 1
96184: ARRAY
96185: PUSH
96186: LD_INT 4
96188: ARRAY
96189: PPUSH
96190: CALL_OW 448
96194: PUSH
96195: LD_VAR 0 3
96199: PPUSH
96200: LD_EXP 193
96204: PUSH
96205: LD_VAR 0 2
96209: ARRAY
96210: PUSH
96211: LD_INT 1
96213: ARRAY
96214: PUSH
96215: LD_INT 1
96217: ARRAY
96218: PUSH
96219: LD_EXP 193
96223: PUSH
96224: LD_VAR 0 2
96228: ARRAY
96229: PUSH
96230: LD_INT 1
96232: ARRAY
96233: PUSH
96234: LD_INT 2
96236: ARRAY
96237: PUSH
96238: LD_EXP 193
96242: PUSH
96243: LD_VAR 0 2
96247: ARRAY
96248: PUSH
96249: LD_INT 1
96251: ARRAY
96252: PUSH
96253: LD_INT 3
96255: ARRAY
96256: PUSH
96257: LD_EXP 193
96261: PUSH
96262: LD_VAR 0 2
96266: ARRAY
96267: PUSH
96268: LD_INT 1
96270: ARRAY
96271: PUSH
96272: LD_INT 4
96274: ARRAY
96275: PUSH
96276: EMPTY
96277: LIST
96278: LIST
96279: LIST
96280: LIST
96281: PPUSH
96282: CALL 30360 0 2
96286: AND
96287: IFFALSE 96425
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
96289: LD_VAR 0 3
96293: PPUSH
96294: LD_EXP 193
96298: PUSH
96299: LD_VAR 0 2
96303: ARRAY
96304: PUSH
96305: LD_INT 1
96307: ARRAY
96308: PUSH
96309: LD_INT 1
96311: ARRAY
96312: PPUSH
96313: LD_EXP 193
96317: PUSH
96318: LD_VAR 0 2
96322: ARRAY
96323: PUSH
96324: LD_INT 1
96326: ARRAY
96327: PUSH
96328: LD_INT 2
96330: ARRAY
96331: PPUSH
96332: LD_EXP 193
96336: PUSH
96337: LD_VAR 0 2
96341: ARRAY
96342: PUSH
96343: LD_INT 1
96345: ARRAY
96346: PUSH
96347: LD_INT 3
96349: ARRAY
96350: PPUSH
96351: LD_EXP 193
96355: PUSH
96356: LD_VAR 0 2
96360: ARRAY
96361: PUSH
96362: LD_INT 1
96364: ARRAY
96365: PUSH
96366: LD_INT 4
96368: ARRAY
96369: PPUSH
96370: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
96374: LD_ADDR_VAR 0 4
96378: PUSH
96379: LD_EXP 193
96383: PUSH
96384: LD_VAR 0 2
96388: ARRAY
96389: PPUSH
96390: LD_INT 1
96392: PPUSH
96393: CALL_OW 3
96397: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
96398: LD_ADDR_EXP 193
96402: PUSH
96403: LD_EXP 193
96407: PPUSH
96408: LD_VAR 0 2
96412: PPUSH
96413: LD_VAR 0 4
96417: PPUSH
96418: CALL_OW 1
96422: ST_TO_ADDR
// break ;
96423: GO 96427
// end ; end ;
96425: GO 96071
96427: POP
96428: POP
// end ;
96429: GO 96003
96431: POP
96432: POP
// end ;
96433: LD_VAR 0 1
96437: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
96438: LD_INT 0
96440: PPUSH
96441: PPUSH
96442: PPUSH
// if not mc_bases then
96443: LD_EXP 172
96447: NOT
96448: IFFALSE 96452
// exit ;
96450: GO 96541
// for i = 1 to mc_bases do
96452: LD_ADDR_VAR 0 2
96456: PUSH
96457: DOUBLE
96458: LD_INT 1
96460: DEC
96461: ST_TO_ADDR
96462: LD_EXP 172
96466: PUSH
96467: FOR_TO
96468: IFFALSE 96539
// begin if mc_attack [ i ] then
96470: LD_EXP 192
96474: PUSH
96475: LD_VAR 0 2
96479: ARRAY
96480: IFFALSE 96537
// begin tmp := mc_attack [ i ] [ 1 ] ;
96482: LD_ADDR_VAR 0 3
96486: PUSH
96487: LD_EXP 192
96491: PUSH
96492: LD_VAR 0 2
96496: ARRAY
96497: PUSH
96498: LD_INT 1
96500: ARRAY
96501: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
96502: LD_ADDR_EXP 192
96506: PUSH
96507: LD_EXP 192
96511: PPUSH
96512: LD_VAR 0 2
96516: PPUSH
96517: EMPTY
96518: PPUSH
96519: CALL_OW 1
96523: ST_TO_ADDR
// Attack ( tmp ) ;
96524: LD_VAR 0 3
96528: PPUSH
96529: CALL 73735 0 1
// exit ;
96533: POP
96534: POP
96535: GO 96541
// end ; end ;
96537: GO 96467
96539: POP
96540: POP
// end ;
96541: LD_VAR 0 1
96545: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
96546: LD_INT 0
96548: PPUSH
96549: PPUSH
96550: PPUSH
96551: PPUSH
96552: PPUSH
96553: PPUSH
96554: PPUSH
// if not mc_bases then
96555: LD_EXP 172
96559: NOT
96560: IFFALSE 96564
// exit ;
96562: GO 97168
// for i = 1 to mc_bases do
96564: LD_ADDR_VAR 0 2
96568: PUSH
96569: DOUBLE
96570: LD_INT 1
96572: DEC
96573: ST_TO_ADDR
96574: LD_EXP 172
96578: PUSH
96579: FOR_TO
96580: IFFALSE 97166
// begin if not mc_bases [ i ] then
96582: LD_EXP 172
96586: PUSH
96587: LD_VAR 0 2
96591: ARRAY
96592: NOT
96593: IFFALSE 96597
// continue ;
96595: GO 96579
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
96597: LD_ADDR_VAR 0 7
96601: PUSH
96602: LD_EXP 172
96606: PUSH
96607: LD_VAR 0 2
96611: ARRAY
96612: PUSH
96613: LD_INT 1
96615: ARRAY
96616: PPUSH
96617: CALL 20932 0 1
96621: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
96622: LD_ADDR_EXP 195
96626: PUSH
96627: LD_EXP 195
96631: PPUSH
96632: LD_VAR 0 2
96636: PPUSH
96637: LD_EXP 172
96641: PUSH
96642: LD_VAR 0 2
96646: ARRAY
96647: PUSH
96648: LD_INT 1
96650: ARRAY
96651: PPUSH
96652: CALL_OW 255
96656: PPUSH
96657: LD_EXP 197
96661: PUSH
96662: LD_VAR 0 2
96666: ARRAY
96667: PPUSH
96668: CALL 20897 0 2
96672: PPUSH
96673: CALL_OW 1
96677: ST_TO_ADDR
// if not mc_scan [ i ] then
96678: LD_EXP 195
96682: PUSH
96683: LD_VAR 0 2
96687: ARRAY
96688: NOT
96689: IFFALSE 96844
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
96691: LD_ADDR_VAR 0 4
96695: PUSH
96696: LD_EXP 172
96700: PUSH
96701: LD_VAR 0 2
96705: ARRAY
96706: PPUSH
96707: LD_INT 2
96709: PUSH
96710: LD_INT 25
96712: PUSH
96713: LD_INT 5
96715: PUSH
96716: EMPTY
96717: LIST
96718: LIST
96719: PUSH
96720: LD_INT 25
96722: PUSH
96723: LD_INT 8
96725: PUSH
96726: EMPTY
96727: LIST
96728: LIST
96729: PUSH
96730: LD_INT 25
96732: PUSH
96733: LD_INT 9
96735: PUSH
96736: EMPTY
96737: LIST
96738: LIST
96739: PUSH
96740: EMPTY
96741: LIST
96742: LIST
96743: LIST
96744: LIST
96745: PPUSH
96746: CALL_OW 72
96750: ST_TO_ADDR
// if not tmp then
96751: LD_VAR 0 4
96755: NOT
96756: IFFALSE 96760
// continue ;
96758: GO 96579
// for j in tmp do
96760: LD_ADDR_VAR 0 3
96764: PUSH
96765: LD_VAR 0 4
96769: PUSH
96770: FOR_IN
96771: IFFALSE 96842
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
96773: LD_VAR 0 3
96777: PPUSH
96778: CALL_OW 310
96782: PPUSH
96783: CALL_OW 266
96787: PUSH
96788: LD_INT 5
96790: EQUAL
96791: PUSH
96792: LD_VAR 0 3
96796: PPUSH
96797: CALL_OW 257
96801: PUSH
96802: LD_INT 1
96804: EQUAL
96805: AND
96806: PUSH
96807: LD_VAR 0 3
96811: PPUSH
96812: CALL_OW 459
96816: NOT
96817: AND
96818: PUSH
96819: LD_VAR 0 7
96823: AND
96824: IFFALSE 96840
// ComChangeProfession ( j , class ) ;
96826: LD_VAR 0 3
96830: PPUSH
96831: LD_VAR 0 7
96835: PPUSH
96836: CALL_OW 123
96840: GO 96770
96842: POP
96843: POP
// end ; if mc_scan [ i ] and not mc_defender [ i ] and not UnitFilter ( mc_bases [ i ] , [ f_btype , b_bunker ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
96844: LD_EXP 195
96848: PUSH
96849: LD_VAR 0 2
96853: ARRAY
96854: PUSH
96855: LD_EXP 194
96859: PUSH
96860: LD_VAR 0 2
96864: ARRAY
96865: NOT
96866: AND
96867: PUSH
96868: LD_EXP 172
96872: PUSH
96873: LD_VAR 0 2
96877: ARRAY
96878: PPUSH
96879: LD_INT 30
96881: PUSH
96882: LD_INT 32
96884: PUSH
96885: EMPTY
96886: LIST
96887: LIST
96888: PPUSH
96889: CALL_OW 72
96893: NOT
96894: AND
96895: PUSH
96896: LD_EXP 172
96900: PUSH
96901: LD_VAR 0 2
96905: ARRAY
96906: PPUSH
96907: LD_INT 2
96909: PUSH
96910: LD_INT 30
96912: PUSH
96913: LD_INT 4
96915: PUSH
96916: EMPTY
96917: LIST
96918: LIST
96919: PUSH
96920: LD_INT 30
96922: PUSH
96923: LD_INT 5
96925: PUSH
96926: EMPTY
96927: LIST
96928: LIST
96929: PUSH
96930: EMPTY
96931: LIST
96932: LIST
96933: LIST
96934: PPUSH
96935: CALL_OW 72
96939: NOT
96940: AND
96941: IFFALSE 97073
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
96943: LD_ADDR_VAR 0 4
96947: PUSH
96948: LD_EXP 172
96952: PUSH
96953: LD_VAR 0 2
96957: ARRAY
96958: PPUSH
96959: LD_INT 2
96961: PUSH
96962: LD_INT 25
96964: PUSH
96965: LD_INT 1
96967: PUSH
96968: EMPTY
96969: LIST
96970: LIST
96971: PUSH
96972: LD_INT 25
96974: PUSH
96975: LD_INT 5
96977: PUSH
96978: EMPTY
96979: LIST
96980: LIST
96981: PUSH
96982: LD_INT 25
96984: PUSH
96985: LD_INT 8
96987: PUSH
96988: EMPTY
96989: LIST
96990: LIST
96991: PUSH
96992: LD_INT 25
96994: PUSH
96995: LD_INT 9
96997: PUSH
96998: EMPTY
96999: LIST
97000: LIST
97001: PUSH
97002: EMPTY
97003: LIST
97004: LIST
97005: LIST
97006: LIST
97007: LIST
97008: PPUSH
97009: CALL_OW 72
97013: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
97014: LD_ADDR_VAR 0 4
97018: PUSH
97019: LD_VAR 0 4
97023: PUSH
97024: LD_VAR 0 4
97028: PPUSH
97029: LD_INT 18
97031: PPUSH
97032: CALL 52657 0 2
97036: DIFF
97037: ST_TO_ADDR
// if tmp then
97038: LD_VAR 0 4
97042: IFFALSE 97073
// begin BasicDefend ( i , tmp , mc_scan_area [ i ] ) ;
97044: LD_VAR 0 2
97048: PPUSH
97049: LD_VAR 0 4
97053: PPUSH
97054: LD_EXP 197
97058: PUSH
97059: LD_VAR 0 2
97063: ARRAY
97064: PPUSH
97065: CALL 78444 0 3
// exit ;
97069: POP
97070: POP
97071: GO 97168
// end ; end ; if mc_scan [ i ] and mc_defender [ i ] then
97073: LD_EXP 195
97077: PUSH
97078: LD_VAR 0 2
97082: ARRAY
97083: PUSH
97084: LD_EXP 194
97088: PUSH
97089: LD_VAR 0 2
97093: ARRAY
97094: AND
97095: IFFALSE 97164
// begin tmp := mc_defender [ i ] ;
97097: LD_ADDR_VAR 0 4
97101: PUSH
97102: LD_EXP 194
97106: PUSH
97107: LD_VAR 0 2
97111: ARRAY
97112: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
97113: LD_ADDR_EXP 194
97117: PUSH
97118: LD_EXP 194
97122: PPUSH
97123: LD_VAR 0 2
97127: PPUSH
97128: EMPTY
97129: PPUSH
97130: CALL_OW 1
97134: ST_TO_ADDR
// Defend ( i , tmp , mc_scan [ i ] ) ;
97135: LD_VAR 0 2
97139: PPUSH
97140: LD_VAR 0 4
97144: PPUSH
97145: LD_EXP 195
97149: PUSH
97150: LD_VAR 0 2
97154: ARRAY
97155: PPUSH
97156: CALL 79005 0 3
// exit ;
97160: POP
97161: POP
97162: GO 97168
// end ; end ;
97164: GO 96579
97166: POP
97167: POP
// end ;
97168: LD_VAR 0 1
97172: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
97173: LD_INT 0
97175: PPUSH
97176: PPUSH
97177: PPUSH
97178: PPUSH
97179: PPUSH
97180: PPUSH
97181: PPUSH
97182: PPUSH
97183: PPUSH
97184: PPUSH
97185: PPUSH
// if not mc_bases then
97186: LD_EXP 172
97190: NOT
97191: IFFALSE 97195
// exit ;
97193: GO 98282
// for i = 1 to mc_bases do
97195: LD_ADDR_VAR 0 2
97199: PUSH
97200: DOUBLE
97201: LD_INT 1
97203: DEC
97204: ST_TO_ADDR
97205: LD_EXP 172
97209: PUSH
97210: FOR_TO
97211: IFFALSE 98280
// begin tmp := mc_lab [ i ] ;
97213: LD_ADDR_VAR 0 6
97217: PUSH
97218: LD_EXP 205
97222: PUSH
97223: LD_VAR 0 2
97227: ARRAY
97228: ST_TO_ADDR
// if not tmp then
97229: LD_VAR 0 6
97233: NOT
97234: IFFALSE 97238
// continue ;
97236: GO 97210
// idle_lab := 0 ;
97238: LD_ADDR_VAR 0 11
97242: PUSH
97243: LD_INT 0
97245: ST_TO_ADDR
// for j in tmp do
97246: LD_ADDR_VAR 0 3
97250: PUSH
97251: LD_VAR 0 6
97255: PUSH
97256: FOR_IN
97257: IFFALSE 98276
// begin researching := false ;
97259: LD_ADDR_VAR 0 10
97263: PUSH
97264: LD_INT 0
97266: ST_TO_ADDR
// side := GetSide ( j ) ;
97267: LD_ADDR_VAR 0 4
97271: PUSH
97272: LD_VAR 0 3
97276: PPUSH
97277: CALL_OW 255
97281: ST_TO_ADDR
// if not mc_tech [ side ] then
97282: LD_EXP 199
97286: PUSH
97287: LD_VAR 0 4
97291: ARRAY
97292: NOT
97293: IFFALSE 97297
// continue ;
97295: GO 97256
// if BuildingStatus ( j ) = bs_idle then
97297: LD_VAR 0 3
97301: PPUSH
97302: CALL_OW 461
97306: PUSH
97307: LD_INT 2
97309: EQUAL
97310: IFFALSE 97498
// begin if idle_lab and UnitsInside ( j ) < 6 then
97312: LD_VAR 0 11
97316: PUSH
97317: LD_VAR 0 3
97321: PPUSH
97322: CALL_OW 313
97326: PUSH
97327: LD_INT 6
97329: LESS
97330: AND
97331: IFFALSE 97402
// begin tmp2 := UnitsInside ( idle_lab ) ;
97333: LD_ADDR_VAR 0 9
97337: PUSH
97338: LD_VAR 0 11
97342: PPUSH
97343: CALL_OW 313
97347: ST_TO_ADDR
// if tmp2 then
97348: LD_VAR 0 9
97352: IFFALSE 97394
// for x in tmp2 do
97354: LD_ADDR_VAR 0 7
97358: PUSH
97359: LD_VAR 0 9
97363: PUSH
97364: FOR_IN
97365: IFFALSE 97392
// begin ComExitBuilding ( x ) ;
97367: LD_VAR 0 7
97371: PPUSH
97372: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
97376: LD_VAR 0 7
97380: PPUSH
97381: LD_VAR 0 3
97385: PPUSH
97386: CALL_OW 180
// end ;
97390: GO 97364
97392: POP
97393: POP
// idle_lab := 0 ;
97394: LD_ADDR_VAR 0 11
97398: PUSH
97399: LD_INT 0
97401: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
97402: LD_ADDR_VAR 0 5
97406: PUSH
97407: LD_EXP 199
97411: PUSH
97412: LD_VAR 0 4
97416: ARRAY
97417: PUSH
97418: FOR_IN
97419: IFFALSE 97479
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
97421: LD_VAR 0 3
97425: PPUSH
97426: LD_VAR 0 5
97430: PPUSH
97431: CALL_OW 430
97435: PUSH
97436: LD_VAR 0 4
97440: PPUSH
97441: LD_VAR 0 5
97445: PPUSH
97446: CALL 20002 0 2
97450: AND
97451: IFFALSE 97477
// begin researching := true ;
97453: LD_ADDR_VAR 0 10
97457: PUSH
97458: LD_INT 1
97460: ST_TO_ADDR
// ComResearch ( j , t ) ;
97461: LD_VAR 0 3
97465: PPUSH
97466: LD_VAR 0 5
97470: PPUSH
97471: CALL_OW 124
// break ;
97475: GO 97479
// end ;
97477: GO 97418
97479: POP
97480: POP
// if not researching then
97481: LD_VAR 0 10
97485: NOT
97486: IFFALSE 97498
// idle_lab := j ;
97488: LD_ADDR_VAR 0 11
97492: PUSH
97493: LD_VAR 0 3
97497: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
97498: LD_VAR 0 3
97502: PPUSH
97503: CALL_OW 461
97507: PUSH
97508: LD_INT 10
97510: EQUAL
97511: IFFALSE 98099
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
97513: LD_EXP 201
97517: PUSH
97518: LD_VAR 0 2
97522: ARRAY
97523: NOT
97524: PUSH
97525: LD_EXP 202
97529: PUSH
97530: LD_VAR 0 2
97534: ARRAY
97535: NOT
97536: AND
97537: PUSH
97538: LD_EXP 199
97542: PUSH
97543: LD_VAR 0 4
97547: ARRAY
97548: PUSH
97549: LD_INT 1
97551: GREATER
97552: AND
97553: IFFALSE 97684
// begin ComCancel ( j ) ;
97555: LD_VAR 0 3
97559: PPUSH
97560: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
97564: LD_ADDR_EXP 199
97568: PUSH
97569: LD_EXP 199
97573: PPUSH
97574: LD_VAR 0 4
97578: PPUSH
97579: LD_EXP 199
97583: PUSH
97584: LD_VAR 0 4
97588: ARRAY
97589: PPUSH
97590: LD_EXP 199
97594: PUSH
97595: LD_VAR 0 4
97599: ARRAY
97600: PUSH
97601: LD_INT 1
97603: MINUS
97604: PPUSH
97605: LD_EXP 199
97609: PUSH
97610: LD_VAR 0 4
97614: ARRAY
97615: PPUSH
97616: LD_INT 0
97618: PPUSH
97619: CALL 23514 0 4
97623: PPUSH
97624: CALL_OW 1
97628: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
97629: LD_ADDR_EXP 199
97633: PUSH
97634: LD_EXP 199
97638: PPUSH
97639: LD_VAR 0 4
97643: PPUSH
97644: LD_EXP 199
97648: PUSH
97649: LD_VAR 0 4
97653: ARRAY
97654: PPUSH
97655: LD_EXP 199
97659: PUSH
97660: LD_VAR 0 4
97664: ARRAY
97665: PPUSH
97666: LD_INT 1
97668: PPUSH
97669: LD_INT 0
97671: PPUSH
97672: CALL 23514 0 4
97676: PPUSH
97677: CALL_OW 1
97681: ST_TO_ADDR
// continue ;
97682: GO 97256
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
97684: LD_EXP 201
97688: PUSH
97689: LD_VAR 0 2
97693: ARRAY
97694: PUSH
97695: LD_EXP 202
97699: PUSH
97700: LD_VAR 0 2
97704: ARRAY
97705: NOT
97706: AND
97707: IFFALSE 97834
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
97709: LD_ADDR_EXP 202
97713: PUSH
97714: LD_EXP 202
97718: PPUSH
97719: LD_VAR 0 2
97723: PUSH
97724: LD_EXP 202
97728: PUSH
97729: LD_VAR 0 2
97733: ARRAY
97734: PUSH
97735: LD_INT 1
97737: PLUS
97738: PUSH
97739: EMPTY
97740: LIST
97741: LIST
97742: PPUSH
97743: LD_EXP 201
97747: PUSH
97748: LD_VAR 0 2
97752: ARRAY
97753: PUSH
97754: LD_INT 1
97756: ARRAY
97757: PPUSH
97758: CALL 24096 0 3
97762: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
97763: LD_EXP 201
97767: PUSH
97768: LD_VAR 0 2
97772: ARRAY
97773: PUSH
97774: LD_INT 1
97776: ARRAY
97777: PPUSH
97778: LD_INT 112
97780: PPUSH
97781: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
97785: LD_ADDR_VAR 0 9
97789: PUSH
97790: LD_EXP 201
97794: PUSH
97795: LD_VAR 0 2
97799: ARRAY
97800: PPUSH
97801: LD_INT 1
97803: PPUSH
97804: CALL_OW 3
97808: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
97809: LD_ADDR_EXP 201
97813: PUSH
97814: LD_EXP 201
97818: PPUSH
97819: LD_VAR 0 2
97823: PPUSH
97824: LD_VAR 0 9
97828: PPUSH
97829: CALL_OW 1
97833: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
97834: LD_EXP 201
97838: PUSH
97839: LD_VAR 0 2
97843: ARRAY
97844: PUSH
97845: LD_EXP 202
97849: PUSH
97850: LD_VAR 0 2
97854: ARRAY
97855: AND
97856: PUSH
97857: LD_EXP 202
97861: PUSH
97862: LD_VAR 0 2
97866: ARRAY
97867: PUSH
97868: LD_INT 1
97870: ARRAY
97871: PPUSH
97872: CALL_OW 310
97876: NOT
97877: AND
97878: PUSH
97879: LD_VAR 0 3
97883: PPUSH
97884: CALL_OW 313
97888: PUSH
97889: LD_INT 6
97891: EQUAL
97892: AND
97893: IFFALSE 97949
// begin tmp2 := UnitsInside ( j ) ;
97895: LD_ADDR_VAR 0 9
97899: PUSH
97900: LD_VAR 0 3
97904: PPUSH
97905: CALL_OW 313
97909: ST_TO_ADDR
// if tmp2 = 6 then
97910: LD_VAR 0 9
97914: PUSH
97915: LD_INT 6
97917: EQUAL
97918: IFFALSE 97949
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
97920: LD_VAR 0 9
97924: PUSH
97925: LD_INT 1
97927: ARRAY
97928: PPUSH
97929: LD_INT 112
97931: PPUSH
97932: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
97936: LD_VAR 0 9
97940: PUSH
97941: LD_INT 1
97943: ARRAY
97944: PPUSH
97945: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
97949: LD_EXP 202
97953: PUSH
97954: LD_VAR 0 2
97958: ARRAY
97959: PUSH
97960: LD_EXP 202
97964: PUSH
97965: LD_VAR 0 2
97969: ARRAY
97970: PUSH
97971: LD_INT 1
97973: ARRAY
97974: PPUSH
97975: CALL_OW 314
97979: NOT
97980: AND
97981: PUSH
97982: LD_EXP 202
97986: PUSH
97987: LD_VAR 0 2
97991: ARRAY
97992: PUSH
97993: LD_INT 1
97995: ARRAY
97996: PPUSH
97997: CALL_OW 310
98001: NOT
98002: AND
98003: IFFALSE 98029
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
98005: LD_EXP 202
98009: PUSH
98010: LD_VAR 0 2
98014: ARRAY
98015: PUSH
98016: LD_INT 1
98018: ARRAY
98019: PPUSH
98020: LD_VAR 0 3
98024: PPUSH
98025: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
98029: LD_EXP 202
98033: PUSH
98034: LD_VAR 0 2
98038: ARRAY
98039: PUSH
98040: LD_INT 1
98042: ARRAY
98043: PPUSH
98044: CALL_OW 310
98048: PUSH
98049: LD_EXP 202
98053: PUSH
98054: LD_VAR 0 2
98058: ARRAY
98059: PUSH
98060: LD_INT 1
98062: ARRAY
98063: PPUSH
98064: CALL_OW 310
98068: PPUSH
98069: CALL_OW 461
98073: PUSH
98074: LD_INT 3
98076: NONEQUAL
98077: AND
98078: IFFALSE 98099
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
98080: LD_EXP 202
98084: PUSH
98085: LD_VAR 0 2
98089: ARRAY
98090: PUSH
98091: LD_INT 1
98093: ARRAY
98094: PPUSH
98095: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
98099: LD_VAR 0 3
98103: PPUSH
98104: CALL_OW 461
98108: PUSH
98109: LD_INT 6
98111: EQUAL
98112: PUSH
98113: LD_VAR 0 6
98117: PUSH
98118: LD_INT 1
98120: GREATER
98121: AND
98122: IFFALSE 98274
// begin sci := [ ] ;
98124: LD_ADDR_VAR 0 8
98128: PUSH
98129: EMPTY
98130: ST_TO_ADDR
// for x in ( tmp diff j ) do
98131: LD_ADDR_VAR 0 7
98135: PUSH
98136: LD_VAR 0 6
98140: PUSH
98141: LD_VAR 0 3
98145: DIFF
98146: PUSH
98147: FOR_IN
98148: IFFALSE 98200
// begin if sci = 6 then
98150: LD_VAR 0 8
98154: PUSH
98155: LD_INT 6
98157: EQUAL
98158: IFFALSE 98162
// break ;
98160: GO 98200
// if BuildingStatus ( x ) = bs_idle then
98162: LD_VAR 0 7
98166: PPUSH
98167: CALL_OW 461
98171: PUSH
98172: LD_INT 2
98174: EQUAL
98175: IFFALSE 98198
// sci := sci ^ UnitsInside ( x ) ;
98177: LD_ADDR_VAR 0 8
98181: PUSH
98182: LD_VAR 0 8
98186: PUSH
98187: LD_VAR 0 7
98191: PPUSH
98192: CALL_OW 313
98196: ADD
98197: ST_TO_ADDR
// end ;
98198: GO 98147
98200: POP
98201: POP
// if not sci then
98202: LD_VAR 0 8
98206: NOT
98207: IFFALSE 98211
// continue ;
98209: GO 97256
// for x in sci do
98211: LD_ADDR_VAR 0 7
98215: PUSH
98216: LD_VAR 0 8
98220: PUSH
98221: FOR_IN
98222: IFFALSE 98272
// if IsInUnit ( x ) and not HasTask ( x ) then
98224: LD_VAR 0 7
98228: PPUSH
98229: CALL_OW 310
98233: PUSH
98234: LD_VAR 0 7
98238: PPUSH
98239: CALL_OW 314
98243: NOT
98244: AND
98245: IFFALSE 98270
// begin ComExitBuilding ( x ) ;
98247: LD_VAR 0 7
98251: PPUSH
98252: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
98256: LD_VAR 0 7
98260: PPUSH
98261: LD_VAR 0 3
98265: PPUSH
98266: CALL_OW 180
// end ;
98270: GO 98221
98272: POP
98273: POP
// end ; end ;
98274: GO 97256
98276: POP
98277: POP
// end ;
98278: GO 97210
98280: POP
98281: POP
// end ;
98282: LD_VAR 0 1
98286: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
98287: LD_INT 0
98289: PPUSH
98290: PPUSH
// if not mc_bases then
98291: LD_EXP 172
98295: NOT
98296: IFFALSE 98300
// exit ;
98298: GO 98381
// for i = 1 to mc_bases do
98300: LD_ADDR_VAR 0 2
98304: PUSH
98305: DOUBLE
98306: LD_INT 1
98308: DEC
98309: ST_TO_ADDR
98310: LD_EXP 172
98314: PUSH
98315: FOR_TO
98316: IFFALSE 98379
// if mc_mines [ i ] and mc_miners [ i ] then
98318: LD_EXP 185
98322: PUSH
98323: LD_VAR 0 2
98327: ARRAY
98328: PUSH
98329: LD_EXP 186
98333: PUSH
98334: LD_VAR 0 2
98338: ARRAY
98339: AND
98340: IFFALSE 98377
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
98342: LD_EXP 186
98346: PUSH
98347: LD_VAR 0 2
98351: ARRAY
98352: PUSH
98353: LD_INT 1
98355: ARRAY
98356: PPUSH
98357: CALL_OW 255
98361: PPUSH
98362: LD_EXP 185
98366: PUSH
98367: LD_VAR 0 2
98371: ARRAY
98372: PPUSH
98373: CALL 21085 0 2
98377: GO 98315
98379: POP
98380: POP
// end ;
98381: LD_VAR 0 1
98385: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
98386: LD_INT 0
98388: PPUSH
98389: PPUSH
98390: PPUSH
98391: PPUSH
98392: PPUSH
98393: PPUSH
98394: PPUSH
98395: PPUSH
// if not mc_bases or not mc_parking then
98396: LD_EXP 172
98400: NOT
98401: PUSH
98402: LD_EXP 196
98406: NOT
98407: OR
98408: IFFALSE 98412
// exit ;
98410: GO 99111
// for i = 1 to mc_bases do
98412: LD_ADDR_VAR 0 2
98416: PUSH
98417: DOUBLE
98418: LD_INT 1
98420: DEC
98421: ST_TO_ADDR
98422: LD_EXP 172
98426: PUSH
98427: FOR_TO
98428: IFFALSE 99109
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
98430: LD_EXP 172
98434: PUSH
98435: LD_VAR 0 2
98439: ARRAY
98440: NOT
98441: PUSH
98442: LD_EXP 196
98446: PUSH
98447: LD_VAR 0 2
98451: ARRAY
98452: NOT
98453: OR
98454: IFFALSE 98458
// continue ;
98456: GO 98427
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
98458: LD_ADDR_VAR 0 5
98462: PUSH
98463: LD_EXP 172
98467: PUSH
98468: LD_VAR 0 2
98472: ARRAY
98473: PUSH
98474: LD_INT 1
98476: ARRAY
98477: PPUSH
98478: CALL_OW 255
98482: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
98483: LD_ADDR_VAR 0 6
98487: PUSH
98488: LD_EXP 172
98492: PUSH
98493: LD_VAR 0 2
98497: ARRAY
98498: PPUSH
98499: LD_INT 30
98501: PUSH
98502: LD_INT 3
98504: PUSH
98505: EMPTY
98506: LIST
98507: LIST
98508: PPUSH
98509: CALL_OW 72
98513: ST_TO_ADDR
// if not fac then
98514: LD_VAR 0 6
98518: NOT
98519: IFFALSE 98570
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
98521: LD_ADDR_VAR 0 6
98525: PUSH
98526: LD_EXP 172
98530: PUSH
98531: LD_VAR 0 2
98535: ARRAY
98536: PPUSH
98537: LD_INT 2
98539: PUSH
98540: LD_INT 30
98542: PUSH
98543: LD_INT 0
98545: PUSH
98546: EMPTY
98547: LIST
98548: LIST
98549: PUSH
98550: LD_INT 30
98552: PUSH
98553: LD_INT 1
98555: PUSH
98556: EMPTY
98557: LIST
98558: LIST
98559: PUSH
98560: EMPTY
98561: LIST
98562: LIST
98563: LIST
98564: PPUSH
98565: CALL_OW 72
98569: ST_TO_ADDR
// if not fac then
98570: LD_VAR 0 6
98574: NOT
98575: IFFALSE 98579
// continue ;
98577: GO 98427
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
98579: LD_ADDR_VAR 0 7
98583: PUSH
98584: LD_EXP 196
98588: PUSH
98589: LD_VAR 0 2
98593: ARRAY
98594: PPUSH
98595: LD_INT 22
98597: PUSH
98598: LD_VAR 0 5
98602: PUSH
98603: EMPTY
98604: LIST
98605: LIST
98606: PUSH
98607: LD_INT 21
98609: PUSH
98610: LD_INT 2
98612: PUSH
98613: EMPTY
98614: LIST
98615: LIST
98616: PUSH
98617: LD_INT 3
98619: PUSH
98620: LD_INT 24
98622: PUSH
98623: LD_INT 1000
98625: PUSH
98626: EMPTY
98627: LIST
98628: LIST
98629: PUSH
98630: EMPTY
98631: LIST
98632: LIST
98633: PUSH
98634: EMPTY
98635: LIST
98636: LIST
98637: LIST
98638: PPUSH
98639: CALL_OW 70
98643: ST_TO_ADDR
// for j in fac do
98644: LD_ADDR_VAR 0 3
98648: PUSH
98649: LD_VAR 0 6
98653: PUSH
98654: FOR_IN
98655: IFFALSE 98736
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
98657: LD_ADDR_VAR 0 7
98661: PUSH
98662: LD_VAR 0 7
98666: PUSH
98667: LD_INT 22
98669: PUSH
98670: LD_VAR 0 5
98674: PUSH
98675: EMPTY
98676: LIST
98677: LIST
98678: PUSH
98679: LD_INT 91
98681: PUSH
98682: LD_VAR 0 3
98686: PUSH
98687: LD_INT 15
98689: PUSH
98690: EMPTY
98691: LIST
98692: LIST
98693: LIST
98694: PUSH
98695: LD_INT 21
98697: PUSH
98698: LD_INT 2
98700: PUSH
98701: EMPTY
98702: LIST
98703: LIST
98704: PUSH
98705: LD_INT 3
98707: PUSH
98708: LD_INT 24
98710: PUSH
98711: LD_INT 1000
98713: PUSH
98714: EMPTY
98715: LIST
98716: LIST
98717: PUSH
98718: EMPTY
98719: LIST
98720: LIST
98721: PUSH
98722: EMPTY
98723: LIST
98724: LIST
98725: LIST
98726: LIST
98727: PPUSH
98728: CALL_OW 69
98732: UNION
98733: ST_TO_ADDR
98734: GO 98654
98736: POP
98737: POP
// if not vehs then
98738: LD_VAR 0 7
98742: NOT
98743: IFFALSE 98769
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
98745: LD_ADDR_EXP 184
98749: PUSH
98750: LD_EXP 184
98754: PPUSH
98755: LD_VAR 0 2
98759: PPUSH
98760: EMPTY
98761: PPUSH
98762: CALL_OW 1
98766: ST_TO_ADDR
// continue ;
98767: GO 98427
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
98769: LD_ADDR_VAR 0 8
98773: PUSH
98774: LD_EXP 172
98778: PUSH
98779: LD_VAR 0 2
98783: ARRAY
98784: PPUSH
98785: LD_INT 30
98787: PUSH
98788: LD_INT 3
98790: PUSH
98791: EMPTY
98792: LIST
98793: LIST
98794: PPUSH
98795: CALL_OW 72
98799: ST_TO_ADDR
// if tmp then
98800: LD_VAR 0 8
98804: IFFALSE 98907
// begin for j in tmp do
98806: LD_ADDR_VAR 0 3
98810: PUSH
98811: LD_VAR 0 8
98815: PUSH
98816: FOR_IN
98817: IFFALSE 98905
// for k in UnitsInside ( j ) do
98819: LD_ADDR_VAR 0 4
98823: PUSH
98824: LD_VAR 0 3
98828: PPUSH
98829: CALL_OW 313
98833: PUSH
98834: FOR_IN
98835: IFFALSE 98901
// if k then
98837: LD_VAR 0 4
98841: IFFALSE 98899
// if not k in mc_repair_vehicle [ i ] then
98843: LD_VAR 0 4
98847: PUSH
98848: LD_EXP 184
98852: PUSH
98853: LD_VAR 0 2
98857: ARRAY
98858: IN
98859: NOT
98860: IFFALSE 98899
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
98862: LD_ADDR_EXP 184
98866: PUSH
98867: LD_EXP 184
98871: PPUSH
98872: LD_VAR 0 2
98876: PPUSH
98877: LD_EXP 184
98881: PUSH
98882: LD_VAR 0 2
98886: ARRAY
98887: PUSH
98888: LD_VAR 0 4
98892: UNION
98893: PPUSH
98894: CALL_OW 1
98898: ST_TO_ADDR
98899: GO 98834
98901: POP
98902: POP
98903: GO 98816
98905: POP
98906: POP
// end ; if not mc_repair_vehicle [ i ] then
98907: LD_EXP 184
98911: PUSH
98912: LD_VAR 0 2
98916: ARRAY
98917: NOT
98918: IFFALSE 98922
// continue ;
98920: GO 98427
// for j in mc_repair_vehicle [ i ] do
98922: LD_ADDR_VAR 0 3
98926: PUSH
98927: LD_EXP 184
98931: PUSH
98932: LD_VAR 0 2
98936: ARRAY
98937: PUSH
98938: FOR_IN
98939: IFFALSE 99105
// begin if GetClass ( j ) <> 3 then
98941: LD_VAR 0 3
98945: PPUSH
98946: CALL_OW 257
98950: PUSH
98951: LD_INT 3
98953: NONEQUAL
98954: IFFALSE 98995
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
98956: LD_ADDR_EXP 184
98960: PUSH
98961: LD_EXP 184
98965: PPUSH
98966: LD_VAR 0 2
98970: PPUSH
98971: LD_EXP 184
98975: PUSH
98976: LD_VAR 0 2
98980: ARRAY
98981: PUSH
98982: LD_VAR 0 3
98986: DIFF
98987: PPUSH
98988: CALL_OW 1
98992: ST_TO_ADDR
// continue ;
98993: GO 98938
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
98995: LD_VAR 0 3
98999: PPUSH
99000: CALL_OW 311
99004: NOT
99005: PUSH
99006: LD_VAR 0 3
99010: PUSH
99011: LD_EXP 175
99015: PUSH
99016: LD_VAR 0 2
99020: ARRAY
99021: PUSH
99022: LD_INT 1
99024: ARRAY
99025: IN
99026: NOT
99027: AND
99028: PUSH
99029: LD_VAR 0 3
99033: PUSH
99034: LD_EXP 175
99038: PUSH
99039: LD_VAR 0 2
99043: ARRAY
99044: PUSH
99045: LD_INT 2
99047: ARRAY
99048: IN
99049: NOT
99050: AND
99051: IFFALSE 99103
// begin if IsInUnit ( j ) then
99053: LD_VAR 0 3
99057: PPUSH
99058: CALL_OW 310
99062: IFFALSE 99073
// ComExitBuilding ( j ) ;
99064: LD_VAR 0 3
99068: PPUSH
99069: CALL_OW 122
// if not HasTask ( j ) then
99073: LD_VAR 0 3
99077: PPUSH
99078: CALL_OW 314
99082: NOT
99083: IFFALSE 99103
// AddComRepairVehicle ( j , vehs [ 1 ] ) ;
99085: LD_VAR 0 3
99089: PPUSH
99090: LD_VAR 0 7
99094: PUSH
99095: LD_INT 1
99097: ARRAY
99098: PPUSH
99099: CALL_OW 189
// end ; end ;
99103: GO 98938
99105: POP
99106: POP
// end ;
99107: GO 98427
99109: POP
99110: POP
// end ;
99111: LD_VAR 0 1
99115: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
99116: LD_INT 0
99118: PPUSH
99119: PPUSH
99120: PPUSH
99121: PPUSH
99122: PPUSH
99123: PPUSH
99124: PPUSH
99125: PPUSH
99126: PPUSH
99127: PPUSH
99128: PPUSH
// if not mc_bases then
99129: LD_EXP 172
99133: NOT
99134: IFFALSE 99138
// exit ;
99136: GO 99940
// for i = 1 to mc_bases do
99138: LD_ADDR_VAR 0 2
99142: PUSH
99143: DOUBLE
99144: LD_INT 1
99146: DEC
99147: ST_TO_ADDR
99148: LD_EXP 172
99152: PUSH
99153: FOR_TO
99154: IFFALSE 99938
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
99156: LD_EXP 200
99160: PUSH
99161: LD_VAR 0 2
99165: ARRAY
99166: NOT
99167: PUSH
99168: LD_EXP 175
99172: PUSH
99173: LD_VAR 0 2
99177: ARRAY
99178: PUSH
99179: LD_INT 1
99181: ARRAY
99182: OR
99183: PUSH
99184: LD_EXP 175
99188: PUSH
99189: LD_VAR 0 2
99193: ARRAY
99194: PUSH
99195: LD_INT 2
99197: ARRAY
99198: OR
99199: PUSH
99200: LD_EXP 198
99204: PUSH
99205: LD_VAR 0 2
99209: ARRAY
99210: PPUSH
99211: LD_INT 1
99213: PPUSH
99214: CALL_OW 325
99218: NOT
99219: OR
99220: PUSH
99221: LD_EXP 195
99225: PUSH
99226: LD_VAR 0 2
99230: ARRAY
99231: OR
99232: IFFALSE 99236
// continue ;
99234: GO 99153
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
99236: LD_ADDR_VAR 0 8
99240: PUSH
99241: LD_EXP 172
99245: PUSH
99246: LD_VAR 0 2
99250: ARRAY
99251: PPUSH
99252: LD_INT 25
99254: PUSH
99255: LD_INT 4
99257: PUSH
99258: EMPTY
99259: LIST
99260: LIST
99261: PUSH
99262: LD_INT 50
99264: PUSH
99265: EMPTY
99266: LIST
99267: PUSH
99268: LD_INT 3
99270: PUSH
99271: LD_INT 60
99273: PUSH
99274: EMPTY
99275: LIST
99276: PUSH
99277: EMPTY
99278: LIST
99279: LIST
99280: PUSH
99281: EMPTY
99282: LIST
99283: LIST
99284: LIST
99285: PPUSH
99286: CALL_OW 72
99290: PUSH
99291: LD_EXP 176
99295: PUSH
99296: LD_VAR 0 2
99300: ARRAY
99301: DIFF
99302: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
99303: LD_ADDR_VAR 0 9
99307: PUSH
99308: LD_EXP 172
99312: PUSH
99313: LD_VAR 0 2
99317: ARRAY
99318: PPUSH
99319: LD_INT 2
99321: PUSH
99322: LD_INT 30
99324: PUSH
99325: LD_INT 0
99327: PUSH
99328: EMPTY
99329: LIST
99330: LIST
99331: PUSH
99332: LD_INT 30
99334: PUSH
99335: LD_INT 1
99337: PUSH
99338: EMPTY
99339: LIST
99340: LIST
99341: PUSH
99342: EMPTY
99343: LIST
99344: LIST
99345: LIST
99346: PPUSH
99347: CALL_OW 72
99351: ST_TO_ADDR
// if not tmp or not dep then
99352: LD_VAR 0 8
99356: NOT
99357: PUSH
99358: LD_VAR 0 9
99362: NOT
99363: OR
99364: IFFALSE 99368
// continue ;
99366: GO 99153
// side := GetSide ( tmp [ 1 ] ) ;
99368: LD_ADDR_VAR 0 11
99372: PUSH
99373: LD_VAR 0 8
99377: PUSH
99378: LD_INT 1
99380: ARRAY
99381: PPUSH
99382: CALL_OW 255
99386: ST_TO_ADDR
// dep := dep [ 1 ] ;
99387: LD_ADDR_VAR 0 9
99391: PUSH
99392: LD_VAR 0 9
99396: PUSH
99397: LD_INT 1
99399: ARRAY
99400: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
99401: LD_ADDR_VAR 0 7
99405: PUSH
99406: LD_EXP 200
99410: PUSH
99411: LD_VAR 0 2
99415: ARRAY
99416: PPUSH
99417: LD_INT 22
99419: PUSH
99420: LD_INT 0
99422: PUSH
99423: EMPTY
99424: LIST
99425: LIST
99426: PUSH
99427: LD_INT 25
99429: PUSH
99430: LD_INT 12
99432: PUSH
99433: EMPTY
99434: LIST
99435: LIST
99436: PUSH
99437: EMPTY
99438: LIST
99439: LIST
99440: PPUSH
99441: CALL_OW 70
99445: PUSH
99446: LD_INT 22
99448: PUSH
99449: LD_INT 0
99451: PUSH
99452: EMPTY
99453: LIST
99454: LIST
99455: PUSH
99456: LD_INT 25
99458: PUSH
99459: LD_INT 12
99461: PUSH
99462: EMPTY
99463: LIST
99464: LIST
99465: PUSH
99466: LD_INT 91
99468: PUSH
99469: LD_VAR 0 9
99473: PUSH
99474: LD_INT 20
99476: PUSH
99477: EMPTY
99478: LIST
99479: LIST
99480: LIST
99481: PUSH
99482: EMPTY
99483: LIST
99484: LIST
99485: LIST
99486: PPUSH
99487: CALL_OW 69
99491: UNION
99492: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
99493: LD_ADDR_VAR 0 10
99497: PUSH
99498: LD_EXP 200
99502: PUSH
99503: LD_VAR 0 2
99507: ARRAY
99508: PPUSH
99509: LD_INT 81
99511: PUSH
99512: LD_VAR 0 11
99516: PUSH
99517: EMPTY
99518: LIST
99519: LIST
99520: PPUSH
99521: CALL_OW 70
99525: ST_TO_ADDR
// if not apes or danger_at_area then
99526: LD_VAR 0 7
99530: NOT
99531: PUSH
99532: LD_VAR 0 10
99536: OR
99537: IFFALSE 99587
// begin if mc_taming [ i ] then
99539: LD_EXP 203
99543: PUSH
99544: LD_VAR 0 2
99548: ARRAY
99549: IFFALSE 99585
// begin MC_Reset ( i , 121 ) ;
99551: LD_VAR 0 2
99555: PPUSH
99556: LD_INT 121
99558: PPUSH
99559: CALL 84997 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
99563: LD_ADDR_EXP 203
99567: PUSH
99568: LD_EXP 203
99572: PPUSH
99573: LD_VAR 0 2
99577: PPUSH
99578: EMPTY
99579: PPUSH
99580: CALL_OW 1
99584: ST_TO_ADDR
// end ; continue ;
99585: GO 99153
// end ; for j in tmp do
99587: LD_ADDR_VAR 0 3
99591: PUSH
99592: LD_VAR 0 8
99596: PUSH
99597: FOR_IN
99598: IFFALSE 99934
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
99600: LD_VAR 0 3
99604: PUSH
99605: LD_EXP 203
99609: PUSH
99610: LD_VAR 0 2
99614: ARRAY
99615: IN
99616: NOT
99617: PUSH
99618: LD_EXP 203
99622: PUSH
99623: LD_VAR 0 2
99627: ARRAY
99628: PUSH
99629: LD_INT 3
99631: LESS
99632: AND
99633: IFFALSE 99691
// begin SetTag ( j , 121 ) ;
99635: LD_VAR 0 3
99639: PPUSH
99640: LD_INT 121
99642: PPUSH
99643: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
99647: LD_ADDR_EXP 203
99651: PUSH
99652: LD_EXP 203
99656: PPUSH
99657: LD_VAR 0 2
99661: PUSH
99662: LD_EXP 203
99666: PUSH
99667: LD_VAR 0 2
99671: ARRAY
99672: PUSH
99673: LD_INT 1
99675: PLUS
99676: PUSH
99677: EMPTY
99678: LIST
99679: LIST
99680: PPUSH
99681: LD_VAR 0 3
99685: PPUSH
99686: CALL 24096 0 3
99690: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
99691: LD_VAR 0 3
99695: PUSH
99696: LD_EXP 203
99700: PUSH
99701: LD_VAR 0 2
99705: ARRAY
99706: IN
99707: IFFALSE 99932
// begin if GetClass ( j ) <> 4 then
99709: LD_VAR 0 3
99713: PPUSH
99714: CALL_OW 257
99718: PUSH
99719: LD_INT 4
99721: NONEQUAL
99722: IFFALSE 99775
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
99724: LD_ADDR_EXP 203
99728: PUSH
99729: LD_EXP 203
99733: PPUSH
99734: LD_VAR 0 2
99738: PPUSH
99739: LD_EXP 203
99743: PUSH
99744: LD_VAR 0 2
99748: ARRAY
99749: PUSH
99750: LD_VAR 0 3
99754: DIFF
99755: PPUSH
99756: CALL_OW 1
99760: ST_TO_ADDR
// SetTag ( j , 0 ) ;
99761: LD_VAR 0 3
99765: PPUSH
99766: LD_INT 0
99768: PPUSH
99769: CALL_OW 109
// continue ;
99773: GO 99597
// end ; if IsInUnit ( j ) then
99775: LD_VAR 0 3
99779: PPUSH
99780: CALL_OW 310
99784: IFFALSE 99795
// ComExitBuilding ( j ) ;
99786: LD_VAR 0 3
99790: PPUSH
99791: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
99795: LD_ADDR_VAR 0 6
99799: PUSH
99800: LD_VAR 0 7
99804: PPUSH
99805: LD_VAR 0 3
99809: PPUSH
99810: CALL_OW 74
99814: ST_TO_ADDR
// if not ape then
99815: LD_VAR 0 6
99819: NOT
99820: IFFALSE 99824
// break ;
99822: GO 99934
// x := GetX ( ape ) ;
99824: LD_ADDR_VAR 0 4
99828: PUSH
99829: LD_VAR 0 6
99833: PPUSH
99834: CALL_OW 250
99838: ST_TO_ADDR
// y := GetY ( ape ) ;
99839: LD_ADDR_VAR 0 5
99843: PUSH
99844: LD_VAR 0 6
99848: PPUSH
99849: CALL_OW 251
99853: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
99854: LD_VAR 0 4
99858: PPUSH
99859: LD_VAR 0 5
99863: PPUSH
99864: CALL_OW 488
99868: NOT
99869: PUSH
99870: LD_VAR 0 11
99874: PPUSH
99875: LD_VAR 0 4
99879: PPUSH
99880: LD_VAR 0 5
99884: PPUSH
99885: LD_INT 20
99887: PPUSH
99888: CALL 24992 0 4
99892: PUSH
99893: LD_INT 4
99895: ARRAY
99896: OR
99897: IFFALSE 99901
// break ;
99899: GO 99934
// if not HasTask ( j ) then
99901: LD_VAR 0 3
99905: PPUSH
99906: CALL_OW 314
99910: NOT
99911: IFFALSE 99932
// ComTameXY ( j , x , y ) ;
99913: LD_VAR 0 3
99917: PPUSH
99918: LD_VAR 0 4
99922: PPUSH
99923: LD_VAR 0 5
99927: PPUSH
99928: CALL_OW 131
// end ; end ;
99932: GO 99597
99934: POP
99935: POP
// end ;
99936: GO 99153
99938: POP
99939: POP
// end ;
99940: LD_VAR 0 1
99944: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
99945: LD_INT 0
99947: PPUSH
99948: PPUSH
99949: PPUSH
99950: PPUSH
99951: PPUSH
99952: PPUSH
99953: PPUSH
99954: PPUSH
// if not mc_bases then
99955: LD_EXP 172
99959: NOT
99960: IFFALSE 99964
// exit ;
99962: GO 100590
// for i = 1 to mc_bases do
99964: LD_ADDR_VAR 0 2
99968: PUSH
99969: DOUBLE
99970: LD_INT 1
99972: DEC
99973: ST_TO_ADDR
99974: LD_EXP 172
99978: PUSH
99979: FOR_TO
99980: IFFALSE 100588
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
99982: LD_EXP 201
99986: PUSH
99987: LD_VAR 0 2
99991: ARRAY
99992: NOT
99993: PUSH
99994: LD_EXP 201
99998: PUSH
99999: LD_VAR 0 2
100003: ARRAY
100004: PPUSH
100005: LD_INT 25
100007: PUSH
100008: LD_INT 12
100010: PUSH
100011: EMPTY
100012: LIST
100013: LIST
100014: PPUSH
100015: CALL_OW 72
100019: NOT
100020: OR
100021: IFFALSE 100025
// continue ;
100023: GO 99979
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
100025: LD_ADDR_VAR 0 5
100029: PUSH
100030: LD_EXP 201
100034: PUSH
100035: LD_VAR 0 2
100039: ARRAY
100040: PUSH
100041: LD_INT 1
100043: ARRAY
100044: PPUSH
100045: CALL_OW 255
100049: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
100050: LD_VAR 0 5
100054: PPUSH
100055: LD_INT 2
100057: PPUSH
100058: CALL_OW 325
100062: IFFALSE 100315
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
100064: LD_ADDR_VAR 0 4
100068: PUSH
100069: LD_EXP 201
100073: PUSH
100074: LD_VAR 0 2
100078: ARRAY
100079: PPUSH
100080: LD_INT 25
100082: PUSH
100083: LD_INT 16
100085: PUSH
100086: EMPTY
100087: LIST
100088: LIST
100089: PPUSH
100090: CALL_OW 72
100094: ST_TO_ADDR
// if tmp < 6 then
100095: LD_VAR 0 4
100099: PUSH
100100: LD_INT 6
100102: LESS
100103: IFFALSE 100315
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
100105: LD_ADDR_VAR 0 6
100109: PUSH
100110: LD_EXP 172
100114: PUSH
100115: LD_VAR 0 2
100119: ARRAY
100120: PPUSH
100121: LD_INT 2
100123: PUSH
100124: LD_INT 30
100126: PUSH
100127: LD_INT 0
100129: PUSH
100130: EMPTY
100131: LIST
100132: LIST
100133: PUSH
100134: LD_INT 30
100136: PUSH
100137: LD_INT 1
100139: PUSH
100140: EMPTY
100141: LIST
100142: LIST
100143: PUSH
100144: EMPTY
100145: LIST
100146: LIST
100147: LIST
100148: PPUSH
100149: CALL_OW 72
100153: ST_TO_ADDR
// if depot then
100154: LD_VAR 0 6
100158: IFFALSE 100315
// begin selected := 0 ;
100160: LD_ADDR_VAR 0 7
100164: PUSH
100165: LD_INT 0
100167: ST_TO_ADDR
// for j in depot do
100168: LD_ADDR_VAR 0 3
100172: PUSH
100173: LD_VAR 0 6
100177: PUSH
100178: FOR_IN
100179: IFFALSE 100210
// begin if UnitsInside ( j ) < 6 then
100181: LD_VAR 0 3
100185: PPUSH
100186: CALL_OW 313
100190: PUSH
100191: LD_INT 6
100193: LESS
100194: IFFALSE 100208
// begin selected := j ;
100196: LD_ADDR_VAR 0 7
100200: PUSH
100201: LD_VAR 0 3
100205: ST_TO_ADDR
// break ;
100206: GO 100210
// end ; end ;
100208: GO 100178
100210: POP
100211: POP
// if selected then
100212: LD_VAR 0 7
100216: IFFALSE 100315
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
100218: LD_ADDR_VAR 0 3
100222: PUSH
100223: LD_EXP 201
100227: PUSH
100228: LD_VAR 0 2
100232: ARRAY
100233: PPUSH
100234: LD_INT 25
100236: PUSH
100237: LD_INT 12
100239: PUSH
100240: EMPTY
100241: LIST
100242: LIST
100243: PPUSH
100244: CALL_OW 72
100248: PUSH
100249: FOR_IN
100250: IFFALSE 100313
// if not HasTask ( j ) then
100252: LD_VAR 0 3
100256: PPUSH
100257: CALL_OW 314
100261: NOT
100262: IFFALSE 100311
// begin if not IsInUnit ( j ) then
100264: LD_VAR 0 3
100268: PPUSH
100269: CALL_OW 310
100273: NOT
100274: IFFALSE 100290
// ComEnterUnit ( j , selected ) ;
100276: LD_VAR 0 3
100280: PPUSH
100281: LD_VAR 0 7
100285: PPUSH
100286: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
100290: LD_VAR 0 3
100294: PPUSH
100295: LD_INT 16
100297: PPUSH
100298: CALL_OW 183
// AddComExitBuilding ( j ) ;
100302: LD_VAR 0 3
100306: PPUSH
100307: CALL_OW 182
// end ;
100311: GO 100249
100313: POP
100314: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
100315: LD_VAR 0 5
100319: PPUSH
100320: LD_INT 11
100322: PPUSH
100323: CALL_OW 325
100327: IFFALSE 100586
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
100329: LD_ADDR_VAR 0 4
100333: PUSH
100334: LD_EXP 201
100338: PUSH
100339: LD_VAR 0 2
100343: ARRAY
100344: PPUSH
100345: LD_INT 25
100347: PUSH
100348: LD_INT 16
100350: PUSH
100351: EMPTY
100352: LIST
100353: LIST
100354: PPUSH
100355: CALL_OW 72
100359: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
100360: LD_VAR 0 4
100364: PUSH
100365: LD_INT 6
100367: GREATEREQUAL
100368: PUSH
100369: LD_VAR 0 5
100373: PPUSH
100374: LD_INT 2
100376: PPUSH
100377: CALL_OW 325
100381: NOT
100382: OR
100383: IFFALSE 100586
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
100385: LD_ADDR_VAR 0 8
100389: PUSH
100390: LD_EXP 172
100394: PUSH
100395: LD_VAR 0 2
100399: ARRAY
100400: PPUSH
100401: LD_INT 2
100403: PUSH
100404: LD_INT 30
100406: PUSH
100407: LD_INT 4
100409: PUSH
100410: EMPTY
100411: LIST
100412: LIST
100413: PUSH
100414: LD_INT 30
100416: PUSH
100417: LD_INT 5
100419: PUSH
100420: EMPTY
100421: LIST
100422: LIST
100423: PUSH
100424: EMPTY
100425: LIST
100426: LIST
100427: LIST
100428: PPUSH
100429: CALL_OW 72
100433: ST_TO_ADDR
// if barracks then
100434: LD_VAR 0 8
100438: IFFALSE 100586
// begin selected := 0 ;
100440: LD_ADDR_VAR 0 7
100444: PUSH
100445: LD_INT 0
100447: ST_TO_ADDR
// for j in barracks do
100448: LD_ADDR_VAR 0 3
100452: PUSH
100453: LD_VAR 0 8
100457: PUSH
100458: FOR_IN
100459: IFFALSE 100490
// begin if UnitsInside ( j ) < 6 then
100461: LD_VAR 0 3
100465: PPUSH
100466: CALL_OW 313
100470: PUSH
100471: LD_INT 6
100473: LESS
100474: IFFALSE 100488
// begin selected := j ;
100476: LD_ADDR_VAR 0 7
100480: PUSH
100481: LD_VAR 0 3
100485: ST_TO_ADDR
// break ;
100486: GO 100490
// end ; end ;
100488: GO 100458
100490: POP
100491: POP
// if selected then
100492: LD_VAR 0 7
100496: IFFALSE 100586
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
100498: LD_ADDR_VAR 0 3
100502: PUSH
100503: LD_EXP 201
100507: PUSH
100508: LD_VAR 0 2
100512: ARRAY
100513: PPUSH
100514: LD_INT 25
100516: PUSH
100517: LD_INT 12
100519: PUSH
100520: EMPTY
100521: LIST
100522: LIST
100523: PPUSH
100524: CALL_OW 72
100528: PUSH
100529: FOR_IN
100530: IFFALSE 100584
// if not IsInUnit ( j ) and not HasTask ( j ) then
100532: LD_VAR 0 3
100536: PPUSH
100537: CALL_OW 310
100541: NOT
100542: PUSH
100543: LD_VAR 0 3
100547: PPUSH
100548: CALL_OW 314
100552: NOT
100553: AND
100554: IFFALSE 100582
// begin ComEnterUnit ( j , selected ) ;
100556: LD_VAR 0 3
100560: PPUSH
100561: LD_VAR 0 7
100565: PPUSH
100566: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
100570: LD_VAR 0 3
100574: PPUSH
100575: LD_INT 15
100577: PPUSH
100578: CALL_OW 183
// end ;
100582: GO 100529
100584: POP
100585: POP
// end ; end ; end ; end ; end ;
100586: GO 99979
100588: POP
100589: POP
// end ;
100590: LD_VAR 0 1
100594: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
100595: LD_INT 0
100597: PPUSH
100598: PPUSH
100599: PPUSH
100600: PPUSH
// if not mc_bases then
100601: LD_EXP 172
100605: NOT
100606: IFFALSE 100610
// exit ;
100608: GO 100788
// for i = 1 to mc_bases do
100610: LD_ADDR_VAR 0 2
100614: PUSH
100615: DOUBLE
100616: LD_INT 1
100618: DEC
100619: ST_TO_ADDR
100620: LD_EXP 172
100624: PUSH
100625: FOR_TO
100626: IFFALSE 100786
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
100628: LD_ADDR_VAR 0 4
100632: PUSH
100633: LD_EXP 172
100637: PUSH
100638: LD_VAR 0 2
100642: ARRAY
100643: PPUSH
100644: LD_INT 25
100646: PUSH
100647: LD_INT 9
100649: PUSH
100650: EMPTY
100651: LIST
100652: LIST
100653: PPUSH
100654: CALL_OW 72
100658: ST_TO_ADDR
// if not tmp then
100659: LD_VAR 0 4
100663: NOT
100664: IFFALSE 100668
// continue ;
100666: GO 100625
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
100668: LD_EXP 198
100672: PUSH
100673: LD_VAR 0 2
100677: ARRAY
100678: PPUSH
100679: LD_INT 29
100681: PPUSH
100682: CALL_OW 325
100686: NOT
100687: PUSH
100688: LD_EXP 198
100692: PUSH
100693: LD_VAR 0 2
100697: ARRAY
100698: PPUSH
100699: LD_INT 28
100701: PPUSH
100702: CALL_OW 325
100706: NOT
100707: AND
100708: IFFALSE 100712
// continue ;
100710: GO 100625
// for j in tmp do
100712: LD_ADDR_VAR 0 3
100716: PUSH
100717: LD_VAR 0 4
100721: PUSH
100722: FOR_IN
100723: IFFALSE 100782
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
100725: LD_VAR 0 3
100729: PUSH
100730: LD_EXP 175
100734: PUSH
100735: LD_VAR 0 2
100739: ARRAY
100740: PUSH
100741: LD_INT 1
100743: ARRAY
100744: IN
100745: NOT
100746: PUSH
100747: LD_VAR 0 3
100751: PUSH
100752: LD_EXP 175
100756: PUSH
100757: LD_VAR 0 2
100761: ARRAY
100762: PUSH
100763: LD_INT 2
100765: ARRAY
100766: IN
100767: NOT
100768: AND
100769: IFFALSE 100780
// ComSpaceTimeShoot ( j ) ;
100771: LD_VAR 0 3
100775: PPUSH
100776: CALL 20093 0 1
100780: GO 100722
100782: POP
100783: POP
// end ;
100784: GO 100625
100786: POP
100787: POP
// end ;
100788: LD_VAR 0 1
100792: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
100793: LD_INT 0
100795: PPUSH
100796: PPUSH
100797: PPUSH
100798: PPUSH
100799: PPUSH
100800: PPUSH
100801: PPUSH
100802: PPUSH
100803: PPUSH
// if not mc_bases then
100804: LD_EXP 172
100808: NOT
100809: IFFALSE 100813
// exit ;
100811: GO 101435
// for i = 1 to mc_bases do
100813: LD_ADDR_VAR 0 2
100817: PUSH
100818: DOUBLE
100819: LD_INT 1
100821: DEC
100822: ST_TO_ADDR
100823: LD_EXP 172
100827: PUSH
100828: FOR_TO
100829: IFFALSE 101433
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
100831: LD_EXP 207
100835: PUSH
100836: LD_VAR 0 2
100840: ARRAY
100841: NOT
100842: PUSH
100843: LD_INT 38
100845: PPUSH
100846: LD_EXP 198
100850: PUSH
100851: LD_VAR 0 2
100855: ARRAY
100856: PPUSH
100857: CALL_OW 321
100861: PUSH
100862: LD_INT 2
100864: NONEQUAL
100865: OR
100866: IFFALSE 100870
// continue ;
100868: GO 100828
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
100870: LD_ADDR_VAR 0 8
100874: PUSH
100875: LD_EXP 172
100879: PUSH
100880: LD_VAR 0 2
100884: ARRAY
100885: PPUSH
100886: LD_INT 30
100888: PUSH
100889: LD_INT 34
100891: PUSH
100892: EMPTY
100893: LIST
100894: LIST
100895: PPUSH
100896: CALL_OW 72
100900: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
100901: LD_ADDR_VAR 0 9
100905: PUSH
100906: LD_EXP 172
100910: PUSH
100911: LD_VAR 0 2
100915: ARRAY
100916: PPUSH
100917: LD_INT 25
100919: PUSH
100920: LD_INT 4
100922: PUSH
100923: EMPTY
100924: LIST
100925: LIST
100926: PPUSH
100927: CALL_OW 72
100931: PPUSH
100932: LD_INT 0
100934: PPUSH
100935: CALL 52657 0 2
100939: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
100940: LD_VAR 0 9
100944: NOT
100945: PUSH
100946: LD_VAR 0 8
100950: NOT
100951: OR
100952: PUSH
100953: LD_EXP 172
100957: PUSH
100958: LD_VAR 0 2
100962: ARRAY
100963: PPUSH
100964: LD_INT 124
100966: PPUSH
100967: CALL 52657 0 2
100971: OR
100972: IFFALSE 100976
// continue ;
100974: GO 100828
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
100976: LD_EXP 208
100980: PUSH
100981: LD_VAR 0 2
100985: ARRAY
100986: PUSH
100987: LD_EXP 207
100991: PUSH
100992: LD_VAR 0 2
100996: ARRAY
100997: LESS
100998: PUSH
100999: LD_EXP 208
101003: PUSH
101004: LD_VAR 0 2
101008: ARRAY
101009: PUSH
101010: LD_VAR 0 8
101014: LESS
101015: AND
101016: IFFALSE 101431
// begin tmp := sci [ 1 ] ;
101018: LD_ADDR_VAR 0 7
101022: PUSH
101023: LD_VAR 0 9
101027: PUSH
101028: LD_INT 1
101030: ARRAY
101031: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
101032: LD_VAR 0 7
101036: PPUSH
101037: LD_INT 124
101039: PPUSH
101040: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
101044: LD_ADDR_VAR 0 3
101048: PUSH
101049: DOUBLE
101050: LD_EXP 207
101054: PUSH
101055: LD_VAR 0 2
101059: ARRAY
101060: INC
101061: ST_TO_ADDR
101062: LD_EXP 207
101066: PUSH
101067: LD_VAR 0 2
101071: ARRAY
101072: PUSH
101073: FOR_DOWNTO
101074: IFFALSE 101417
// begin if IsInUnit ( tmp ) then
101076: LD_VAR 0 7
101080: PPUSH
101081: CALL_OW 310
101085: IFFALSE 101096
// ComExitBuilding ( tmp ) ;
101087: LD_VAR 0 7
101091: PPUSH
101092: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
101096: LD_INT 35
101098: PPUSH
101099: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
101103: LD_VAR 0 7
101107: PPUSH
101108: CALL_OW 310
101112: NOT
101113: PUSH
101114: LD_VAR 0 7
101118: PPUSH
101119: CALL_OW 314
101123: NOT
101124: AND
101125: IFFALSE 101096
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
101127: LD_ADDR_VAR 0 6
101131: PUSH
101132: LD_VAR 0 7
101136: PPUSH
101137: CALL_OW 250
101141: PUSH
101142: LD_VAR 0 7
101146: PPUSH
101147: CALL_OW 251
101151: PUSH
101152: EMPTY
101153: LIST
101154: LIST
101155: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
101156: LD_INT 35
101158: PPUSH
101159: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
101163: LD_ADDR_VAR 0 4
101167: PUSH
101168: LD_EXP 207
101172: PUSH
101173: LD_VAR 0 2
101177: ARRAY
101178: PUSH
101179: LD_VAR 0 3
101183: ARRAY
101184: PUSH
101185: LD_INT 1
101187: ARRAY
101188: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
101189: LD_ADDR_VAR 0 5
101193: PUSH
101194: LD_EXP 207
101198: PUSH
101199: LD_VAR 0 2
101203: ARRAY
101204: PUSH
101205: LD_VAR 0 3
101209: ARRAY
101210: PUSH
101211: LD_INT 2
101213: ARRAY
101214: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
101215: LD_VAR 0 7
101219: PPUSH
101220: LD_INT 10
101222: PPUSH
101223: CALL 26689 0 2
101227: PUSH
101228: LD_INT 4
101230: ARRAY
101231: IFFALSE 101269
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
101233: LD_VAR 0 7
101237: PPUSH
101238: LD_VAR 0 6
101242: PUSH
101243: LD_INT 1
101245: ARRAY
101246: PPUSH
101247: LD_VAR 0 6
101251: PUSH
101252: LD_INT 2
101254: ARRAY
101255: PPUSH
101256: CALL_OW 111
// wait ( 0 0$10 ) ;
101260: LD_INT 350
101262: PPUSH
101263: CALL_OW 67
// end else
101267: GO 101295
// begin ComMoveXY ( tmp , x , y ) ;
101269: LD_VAR 0 7
101273: PPUSH
101274: LD_VAR 0 4
101278: PPUSH
101279: LD_VAR 0 5
101283: PPUSH
101284: CALL_OW 111
// wait ( 0 0$3 ) ;
101288: LD_INT 105
101290: PPUSH
101291: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
101295: LD_VAR 0 7
101299: PPUSH
101300: LD_VAR 0 4
101304: PPUSH
101305: LD_VAR 0 5
101309: PPUSH
101310: CALL_OW 307
101314: IFFALSE 101156
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
101316: LD_VAR 0 7
101320: PPUSH
101321: LD_VAR 0 4
101325: PPUSH
101326: LD_VAR 0 5
101330: PPUSH
101331: LD_VAR 0 8
101335: PUSH
101336: LD_VAR 0 3
101340: ARRAY
101341: PPUSH
101342: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
101346: LD_INT 35
101348: PPUSH
101349: CALL_OW 67
// until not HasTask ( tmp ) ;
101353: LD_VAR 0 7
101357: PPUSH
101358: CALL_OW 314
101362: NOT
101363: IFFALSE 101346
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
101365: LD_ADDR_EXP 208
101369: PUSH
101370: LD_EXP 208
101374: PPUSH
101375: LD_VAR 0 2
101379: PUSH
101380: LD_EXP 208
101384: PUSH
101385: LD_VAR 0 2
101389: ARRAY
101390: PUSH
101391: LD_INT 1
101393: PLUS
101394: PUSH
101395: EMPTY
101396: LIST
101397: LIST
101398: PPUSH
101399: LD_VAR 0 8
101403: PUSH
101404: LD_VAR 0 3
101408: ARRAY
101409: PPUSH
101410: CALL 24096 0 3
101414: ST_TO_ADDR
// end ;
101415: GO 101073
101417: POP
101418: POP
// MC_Reset ( i , 124 ) ;
101419: LD_VAR 0 2
101423: PPUSH
101424: LD_INT 124
101426: PPUSH
101427: CALL 84997 0 2
// end ; end ;
101431: GO 100828
101433: POP
101434: POP
// end ;
101435: LD_VAR 0 1
101439: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
101440: LD_INT 0
101442: PPUSH
101443: PPUSH
101444: PPUSH
// if not mc_bases then
101445: LD_EXP 172
101449: NOT
101450: IFFALSE 101454
// exit ;
101452: GO 102060
// for i = 1 to mc_bases do
101454: LD_ADDR_VAR 0 2
101458: PUSH
101459: DOUBLE
101460: LD_INT 1
101462: DEC
101463: ST_TO_ADDR
101464: LD_EXP 172
101468: PUSH
101469: FOR_TO
101470: IFFALSE 102058
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
101472: LD_ADDR_VAR 0 3
101476: PUSH
101477: LD_EXP 172
101481: PUSH
101482: LD_VAR 0 2
101486: ARRAY
101487: PPUSH
101488: LD_INT 25
101490: PUSH
101491: LD_INT 4
101493: PUSH
101494: EMPTY
101495: LIST
101496: LIST
101497: PPUSH
101498: CALL_OW 72
101502: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
101503: LD_VAR 0 3
101507: NOT
101508: PUSH
101509: LD_EXP 209
101513: PUSH
101514: LD_VAR 0 2
101518: ARRAY
101519: NOT
101520: OR
101521: PUSH
101522: LD_EXP 172
101526: PUSH
101527: LD_VAR 0 2
101531: ARRAY
101532: PPUSH
101533: LD_INT 2
101535: PUSH
101536: LD_INT 30
101538: PUSH
101539: LD_INT 0
101541: PUSH
101542: EMPTY
101543: LIST
101544: LIST
101545: PUSH
101546: LD_INT 30
101548: PUSH
101549: LD_INT 1
101551: PUSH
101552: EMPTY
101553: LIST
101554: LIST
101555: PUSH
101556: EMPTY
101557: LIST
101558: LIST
101559: LIST
101560: PPUSH
101561: CALL_OW 72
101565: NOT
101566: OR
101567: IFFALSE 101617
// begin if mc_deposits_finder [ i ] then
101569: LD_EXP 210
101573: PUSH
101574: LD_VAR 0 2
101578: ARRAY
101579: IFFALSE 101615
// begin MC_Reset ( i , 125 ) ;
101581: LD_VAR 0 2
101585: PPUSH
101586: LD_INT 125
101588: PPUSH
101589: CALL 84997 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
101593: LD_ADDR_EXP 210
101597: PUSH
101598: LD_EXP 210
101602: PPUSH
101603: LD_VAR 0 2
101607: PPUSH
101608: EMPTY
101609: PPUSH
101610: CALL_OW 1
101614: ST_TO_ADDR
// end ; continue ;
101615: GO 101469
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
101617: LD_EXP 209
101621: PUSH
101622: LD_VAR 0 2
101626: ARRAY
101627: PUSH
101628: LD_INT 1
101630: ARRAY
101631: PUSH
101632: LD_INT 3
101634: ARRAY
101635: PUSH
101636: LD_INT 1
101638: EQUAL
101639: PUSH
101640: LD_INT 20
101642: PPUSH
101643: LD_EXP 198
101647: PUSH
101648: LD_VAR 0 2
101652: ARRAY
101653: PPUSH
101654: CALL_OW 321
101658: PUSH
101659: LD_INT 2
101661: NONEQUAL
101662: AND
101663: IFFALSE 101713
// begin if mc_deposits_finder [ i ] then
101665: LD_EXP 210
101669: PUSH
101670: LD_VAR 0 2
101674: ARRAY
101675: IFFALSE 101711
// begin MC_Reset ( i , 125 ) ;
101677: LD_VAR 0 2
101681: PPUSH
101682: LD_INT 125
101684: PPUSH
101685: CALL 84997 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
101689: LD_ADDR_EXP 210
101693: PUSH
101694: LD_EXP 210
101698: PPUSH
101699: LD_VAR 0 2
101703: PPUSH
101704: EMPTY
101705: PPUSH
101706: CALL_OW 1
101710: ST_TO_ADDR
// end ; continue ;
101711: GO 101469
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
101713: LD_EXP 209
101717: PUSH
101718: LD_VAR 0 2
101722: ARRAY
101723: PUSH
101724: LD_INT 1
101726: ARRAY
101727: PUSH
101728: LD_INT 1
101730: ARRAY
101731: PPUSH
101732: LD_EXP 209
101736: PUSH
101737: LD_VAR 0 2
101741: ARRAY
101742: PUSH
101743: LD_INT 1
101745: ARRAY
101746: PUSH
101747: LD_INT 2
101749: ARRAY
101750: PPUSH
101751: LD_EXP 198
101755: PUSH
101756: LD_VAR 0 2
101760: ARRAY
101761: PPUSH
101762: CALL_OW 440
101766: IFFALSE 101809
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
101768: LD_ADDR_EXP 209
101772: PUSH
101773: LD_EXP 209
101777: PPUSH
101778: LD_VAR 0 2
101782: PPUSH
101783: LD_EXP 209
101787: PUSH
101788: LD_VAR 0 2
101792: ARRAY
101793: PPUSH
101794: LD_INT 1
101796: PPUSH
101797: CALL_OW 3
101801: PPUSH
101802: CALL_OW 1
101806: ST_TO_ADDR
101807: GO 102056
// begin if not mc_deposits_finder [ i ] then
101809: LD_EXP 210
101813: PUSH
101814: LD_VAR 0 2
101818: ARRAY
101819: NOT
101820: IFFALSE 101872
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
101822: LD_ADDR_EXP 210
101826: PUSH
101827: LD_EXP 210
101831: PPUSH
101832: LD_VAR 0 2
101836: PPUSH
101837: LD_VAR 0 3
101841: PUSH
101842: LD_INT 1
101844: ARRAY
101845: PUSH
101846: EMPTY
101847: LIST
101848: PPUSH
101849: CALL_OW 1
101853: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
101854: LD_VAR 0 3
101858: PUSH
101859: LD_INT 1
101861: ARRAY
101862: PPUSH
101863: LD_INT 125
101865: PPUSH
101866: CALL_OW 109
// end else
101870: GO 102056
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
101872: LD_EXP 210
101876: PUSH
101877: LD_VAR 0 2
101881: ARRAY
101882: PUSH
101883: LD_INT 1
101885: ARRAY
101886: PPUSH
101887: CALL_OW 310
101891: IFFALSE 101914
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
101893: LD_EXP 210
101897: PUSH
101898: LD_VAR 0 2
101902: ARRAY
101903: PUSH
101904: LD_INT 1
101906: ARRAY
101907: PPUSH
101908: CALL_OW 122
101912: GO 102056
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
101914: LD_EXP 210
101918: PUSH
101919: LD_VAR 0 2
101923: ARRAY
101924: PUSH
101925: LD_INT 1
101927: ARRAY
101928: PPUSH
101929: CALL_OW 314
101933: NOT
101934: PUSH
101935: LD_EXP 210
101939: PUSH
101940: LD_VAR 0 2
101944: ARRAY
101945: PUSH
101946: LD_INT 1
101948: ARRAY
101949: PPUSH
101950: LD_EXP 209
101954: PUSH
101955: LD_VAR 0 2
101959: ARRAY
101960: PUSH
101961: LD_INT 1
101963: ARRAY
101964: PUSH
101965: LD_INT 1
101967: ARRAY
101968: PPUSH
101969: LD_EXP 209
101973: PUSH
101974: LD_VAR 0 2
101978: ARRAY
101979: PUSH
101980: LD_INT 1
101982: ARRAY
101983: PUSH
101984: LD_INT 2
101986: ARRAY
101987: PPUSH
101988: CALL_OW 297
101992: PUSH
101993: LD_INT 6
101995: GREATER
101996: AND
101997: IFFALSE 102056
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
101999: LD_EXP 210
102003: PUSH
102004: LD_VAR 0 2
102008: ARRAY
102009: PUSH
102010: LD_INT 1
102012: ARRAY
102013: PPUSH
102014: LD_EXP 209
102018: PUSH
102019: LD_VAR 0 2
102023: ARRAY
102024: PUSH
102025: LD_INT 1
102027: ARRAY
102028: PUSH
102029: LD_INT 1
102031: ARRAY
102032: PPUSH
102033: LD_EXP 209
102037: PUSH
102038: LD_VAR 0 2
102042: ARRAY
102043: PUSH
102044: LD_INT 1
102046: ARRAY
102047: PUSH
102048: LD_INT 2
102050: ARRAY
102051: PPUSH
102052: CALL_OW 111
// end ; end ; end ;
102056: GO 101469
102058: POP
102059: POP
// end ;
102060: LD_VAR 0 1
102064: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
102065: LD_INT 0
102067: PPUSH
102068: PPUSH
102069: PPUSH
102070: PPUSH
102071: PPUSH
102072: PPUSH
102073: PPUSH
102074: PPUSH
102075: PPUSH
102076: PPUSH
102077: PPUSH
// if not mc_bases then
102078: LD_EXP 172
102082: NOT
102083: IFFALSE 102087
// exit ;
102085: GO 103027
// for i = 1 to mc_bases do
102087: LD_ADDR_VAR 0 2
102091: PUSH
102092: DOUBLE
102093: LD_INT 1
102095: DEC
102096: ST_TO_ADDR
102097: LD_EXP 172
102101: PUSH
102102: FOR_TO
102103: IFFALSE 103025
// begin if not mc_bases [ i ] or mc_scan [ i ] then
102105: LD_EXP 172
102109: PUSH
102110: LD_VAR 0 2
102114: ARRAY
102115: NOT
102116: PUSH
102117: LD_EXP 195
102121: PUSH
102122: LD_VAR 0 2
102126: ARRAY
102127: OR
102128: IFFALSE 102132
// continue ;
102130: GO 102102
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
102132: LD_ADDR_VAR 0 7
102136: PUSH
102137: LD_EXP 172
102141: PUSH
102142: LD_VAR 0 2
102146: ARRAY
102147: PUSH
102148: LD_INT 1
102150: ARRAY
102151: PPUSH
102152: CALL_OW 248
102156: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
102157: LD_VAR 0 7
102161: PUSH
102162: LD_INT 3
102164: EQUAL
102165: PUSH
102166: LD_EXP 191
102170: PUSH
102171: LD_VAR 0 2
102175: ARRAY
102176: PUSH
102177: LD_EXP 194
102181: PUSH
102182: LD_VAR 0 2
102186: ARRAY
102187: UNION
102188: PPUSH
102189: LD_INT 33
102191: PUSH
102192: LD_INT 2
102194: PUSH
102195: EMPTY
102196: LIST
102197: LIST
102198: PPUSH
102199: CALL_OW 72
102203: NOT
102204: OR
102205: IFFALSE 102209
// continue ;
102207: GO 102102
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
102209: LD_ADDR_VAR 0 9
102213: PUSH
102214: LD_EXP 172
102218: PUSH
102219: LD_VAR 0 2
102223: ARRAY
102224: PPUSH
102225: LD_INT 30
102227: PUSH
102228: LD_INT 36
102230: PUSH
102231: EMPTY
102232: LIST
102233: LIST
102234: PPUSH
102235: CALL_OW 72
102239: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
102240: LD_ADDR_VAR 0 10
102244: PUSH
102245: LD_EXP 191
102249: PUSH
102250: LD_VAR 0 2
102254: ARRAY
102255: PPUSH
102256: LD_INT 34
102258: PUSH
102259: LD_INT 31
102261: PUSH
102262: EMPTY
102263: LIST
102264: LIST
102265: PPUSH
102266: CALL_OW 72
102270: ST_TO_ADDR
// if not cts and not mcts then
102271: LD_VAR 0 9
102275: NOT
102276: PUSH
102277: LD_VAR 0 10
102281: NOT
102282: AND
102283: IFFALSE 102287
// continue ;
102285: GO 102102
// x := cts ;
102287: LD_ADDR_VAR 0 11
102291: PUSH
102292: LD_VAR 0 9
102296: ST_TO_ADDR
// if not x then
102297: LD_VAR 0 11
102301: NOT
102302: IFFALSE 102314
// x := mcts ;
102304: LD_ADDR_VAR 0 11
102308: PUSH
102309: LD_VAR 0 10
102313: ST_TO_ADDR
// if not x then
102314: LD_VAR 0 11
102318: NOT
102319: IFFALSE 102323
// continue ;
102321: GO 102102
// if mc_remote_driver [ i ] then
102323: LD_EXP 212
102327: PUSH
102328: LD_VAR 0 2
102332: ARRAY
102333: IFFALSE 102720
// for j in mc_remote_driver [ i ] do
102335: LD_ADDR_VAR 0 3
102339: PUSH
102340: LD_EXP 212
102344: PUSH
102345: LD_VAR 0 2
102349: ARRAY
102350: PUSH
102351: FOR_IN
102352: IFFALSE 102718
// begin if GetClass ( j ) <> 3 then
102354: LD_VAR 0 3
102358: PPUSH
102359: CALL_OW 257
102363: PUSH
102364: LD_INT 3
102366: NONEQUAL
102367: IFFALSE 102420
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
102369: LD_ADDR_EXP 212
102373: PUSH
102374: LD_EXP 212
102378: PPUSH
102379: LD_VAR 0 2
102383: PPUSH
102384: LD_EXP 212
102388: PUSH
102389: LD_VAR 0 2
102393: ARRAY
102394: PUSH
102395: LD_VAR 0 3
102399: DIFF
102400: PPUSH
102401: CALL_OW 1
102405: ST_TO_ADDR
// SetTag ( j , 0 ) ;
102406: LD_VAR 0 3
102410: PPUSH
102411: LD_INT 0
102413: PPUSH
102414: CALL_OW 109
// continue ;
102418: GO 102351
// end ; if UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) and not IsDriver ( j ) then
102420: LD_EXP 191
102424: PUSH
102425: LD_VAR 0 2
102429: ARRAY
102430: PPUSH
102431: LD_INT 34
102433: PUSH
102434: LD_INT 31
102436: PUSH
102437: EMPTY
102438: LIST
102439: LIST
102440: PUSH
102441: LD_INT 58
102443: PUSH
102444: EMPTY
102445: LIST
102446: PUSH
102447: EMPTY
102448: LIST
102449: LIST
102450: PPUSH
102451: CALL_OW 72
102455: PUSH
102456: LD_VAR 0 3
102460: PPUSH
102461: CALL 52745 0 1
102465: NOT
102466: AND
102467: IFFALSE 102538
// begin if IsInUnit ( j ) then
102469: LD_VAR 0 3
102473: PPUSH
102474: CALL_OW 310
102478: IFFALSE 102489
// ComExitBuilding ( j ) ;
102480: LD_VAR 0 3
102484: PPUSH
102485: CALL_OW 122
// AddComEnterUnit ( j , UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) [ 1 ] ) ;
102489: LD_VAR 0 3
102493: PPUSH
102494: LD_EXP 191
102498: PUSH
102499: LD_VAR 0 2
102503: ARRAY
102504: PPUSH
102505: LD_INT 34
102507: PUSH
102508: LD_INT 31
102510: PUSH
102511: EMPTY
102512: LIST
102513: LIST
102514: PUSH
102515: LD_INT 58
102517: PUSH
102518: EMPTY
102519: LIST
102520: PUSH
102521: EMPTY
102522: LIST
102523: LIST
102524: PPUSH
102525: CALL_OW 72
102529: PUSH
102530: LD_INT 1
102532: ARRAY
102533: PPUSH
102534: CALL_OW 180
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
102538: LD_VAR 0 3
102542: PPUSH
102543: CALL_OW 310
102547: NOT
102548: PUSH
102549: LD_VAR 0 3
102553: PPUSH
102554: CALL_OW 310
102558: PPUSH
102559: CALL_OW 266
102563: PUSH
102564: LD_INT 36
102566: NONEQUAL
102567: PUSH
102568: LD_VAR 0 3
102572: PPUSH
102573: CALL 52745 0 1
102577: NOT
102578: AND
102579: OR
102580: IFFALSE 102716
// begin if IsInUnit ( j ) then
102582: LD_VAR 0 3
102586: PPUSH
102587: CALL_OW 310
102591: IFFALSE 102602
// ComExitBuilding ( j ) ;
102593: LD_VAR 0 3
102597: PPUSH
102598: CALL_OW 122
// ct := 0 ;
102602: LD_ADDR_VAR 0 8
102606: PUSH
102607: LD_INT 0
102609: ST_TO_ADDR
// for k in x do
102610: LD_ADDR_VAR 0 4
102614: PUSH
102615: LD_VAR 0 11
102619: PUSH
102620: FOR_IN
102621: IFFALSE 102694
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
102623: LD_VAR 0 4
102627: PPUSH
102628: CALL_OW 264
102632: PUSH
102633: LD_INT 31
102635: EQUAL
102636: PUSH
102637: LD_VAR 0 4
102641: PPUSH
102642: CALL_OW 311
102646: NOT
102647: AND
102648: PUSH
102649: LD_VAR 0 4
102653: PPUSH
102654: CALL_OW 266
102658: PUSH
102659: LD_INT 36
102661: EQUAL
102662: PUSH
102663: LD_VAR 0 4
102667: PPUSH
102668: CALL_OW 313
102672: PUSH
102673: LD_INT 3
102675: LESS
102676: AND
102677: OR
102678: IFFALSE 102692
// begin ct := k ;
102680: LD_ADDR_VAR 0 8
102684: PUSH
102685: LD_VAR 0 4
102689: ST_TO_ADDR
// break ;
102690: GO 102694
// end ;
102692: GO 102620
102694: POP
102695: POP
// if ct then
102696: LD_VAR 0 8
102700: IFFALSE 102716
// ComEnterUnit ( j , ct ) ;
102702: LD_VAR 0 3
102706: PPUSH
102707: LD_VAR 0 8
102711: PPUSH
102712: CALL_OW 120
// end ; end ;
102716: GO 102351
102718: POP
102719: POP
// places := 0 ;
102720: LD_ADDR_VAR 0 5
102724: PUSH
102725: LD_INT 0
102727: ST_TO_ADDR
// for j = 1 to x do
102728: LD_ADDR_VAR 0 3
102732: PUSH
102733: DOUBLE
102734: LD_INT 1
102736: DEC
102737: ST_TO_ADDR
102738: LD_VAR 0 11
102742: PUSH
102743: FOR_TO
102744: IFFALSE 102820
// if GetWeapon ( x [ j ] ) = ar_control_tower then
102746: LD_VAR 0 11
102750: PUSH
102751: LD_VAR 0 3
102755: ARRAY
102756: PPUSH
102757: CALL_OW 264
102761: PUSH
102762: LD_INT 31
102764: EQUAL
102765: IFFALSE 102783
// places := places + 1 else
102767: LD_ADDR_VAR 0 5
102771: PUSH
102772: LD_VAR 0 5
102776: PUSH
102777: LD_INT 1
102779: PLUS
102780: ST_TO_ADDR
102781: GO 102818
// if GetBType ( x [ j ] ) = b_control_tower then
102783: LD_VAR 0 11
102787: PUSH
102788: LD_VAR 0 3
102792: ARRAY
102793: PPUSH
102794: CALL_OW 266
102798: PUSH
102799: LD_INT 36
102801: EQUAL
102802: IFFALSE 102818
// places := places + 3 ;
102804: LD_ADDR_VAR 0 5
102808: PUSH
102809: LD_VAR 0 5
102813: PUSH
102814: LD_INT 3
102816: PLUS
102817: ST_TO_ADDR
102818: GO 102743
102820: POP
102821: POP
// if places = 0 or places <= mc_remote_driver [ i ] then
102822: LD_VAR 0 5
102826: PUSH
102827: LD_INT 0
102829: EQUAL
102830: PUSH
102831: LD_VAR 0 5
102835: PUSH
102836: LD_EXP 212
102840: PUSH
102841: LD_VAR 0 2
102845: ARRAY
102846: LESSEQUAL
102847: OR
102848: IFFALSE 102852
// continue ;
102850: GO 102102
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
102852: LD_ADDR_VAR 0 6
102856: PUSH
102857: LD_EXP 172
102861: PUSH
102862: LD_VAR 0 2
102866: ARRAY
102867: PPUSH
102868: LD_INT 25
102870: PUSH
102871: LD_INT 3
102873: PUSH
102874: EMPTY
102875: LIST
102876: LIST
102877: PPUSH
102878: CALL_OW 72
102882: PUSH
102883: LD_EXP 212
102887: PUSH
102888: LD_VAR 0 2
102892: ARRAY
102893: DIFF
102894: PPUSH
102895: LD_INT 3
102897: PPUSH
102898: CALL 53645 0 2
102902: ST_TO_ADDR
// for j in tmp do
102903: LD_ADDR_VAR 0 3
102907: PUSH
102908: LD_VAR 0 6
102912: PUSH
102913: FOR_IN
102914: IFFALSE 102949
// if GetTag ( j ) > 0 then
102916: LD_VAR 0 3
102920: PPUSH
102921: CALL_OW 110
102925: PUSH
102926: LD_INT 0
102928: GREATER
102929: IFFALSE 102947
// tmp := tmp diff j ;
102931: LD_ADDR_VAR 0 6
102935: PUSH
102936: LD_VAR 0 6
102940: PUSH
102941: LD_VAR 0 3
102945: DIFF
102946: ST_TO_ADDR
102947: GO 102913
102949: POP
102950: POP
// if not tmp then
102951: LD_VAR 0 6
102955: NOT
102956: IFFALSE 102960
// continue ;
102958: GO 102102
// if places then
102960: LD_VAR 0 5
102964: IFFALSE 103023
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
102966: LD_ADDR_EXP 212
102970: PUSH
102971: LD_EXP 212
102975: PPUSH
102976: LD_VAR 0 2
102980: PPUSH
102981: LD_EXP 212
102985: PUSH
102986: LD_VAR 0 2
102990: ARRAY
102991: PUSH
102992: LD_VAR 0 6
102996: PUSH
102997: LD_INT 1
102999: ARRAY
103000: UNION
103001: PPUSH
103002: CALL_OW 1
103006: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
103007: LD_VAR 0 6
103011: PUSH
103012: LD_INT 1
103014: ARRAY
103015: PPUSH
103016: LD_INT 126
103018: PPUSH
103019: CALL_OW 109
// end ; end ;
103023: GO 102102
103025: POP
103026: POP
// end ;
103027: LD_VAR 0 1
103031: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
103032: LD_INT 0
103034: PPUSH
103035: PPUSH
103036: PPUSH
103037: PPUSH
103038: PPUSH
103039: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
103040: LD_VAR 0 1
103044: NOT
103045: PUSH
103046: LD_VAR 0 2
103050: NOT
103051: OR
103052: PUSH
103053: LD_VAR 0 3
103057: NOT
103058: OR
103059: PUSH
103060: LD_VAR 0 4
103064: PUSH
103065: LD_INT 1
103067: PUSH
103068: LD_INT 2
103070: PUSH
103071: LD_INT 3
103073: PUSH
103074: LD_INT 4
103076: PUSH
103077: LD_INT 5
103079: PUSH
103080: LD_INT 8
103082: PUSH
103083: LD_INT 9
103085: PUSH
103086: LD_INT 15
103088: PUSH
103089: LD_INT 16
103091: PUSH
103092: EMPTY
103093: LIST
103094: LIST
103095: LIST
103096: LIST
103097: LIST
103098: LIST
103099: LIST
103100: LIST
103101: LIST
103102: IN
103103: NOT
103104: OR
103105: IFFALSE 103109
// exit ;
103107: GO 104009
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
103109: LD_ADDR_VAR 0 2
103113: PUSH
103114: LD_VAR 0 2
103118: PPUSH
103119: LD_INT 21
103121: PUSH
103122: LD_INT 3
103124: PUSH
103125: EMPTY
103126: LIST
103127: LIST
103128: PUSH
103129: LD_INT 24
103131: PUSH
103132: LD_INT 250
103134: PUSH
103135: EMPTY
103136: LIST
103137: LIST
103138: PUSH
103139: EMPTY
103140: LIST
103141: LIST
103142: PPUSH
103143: CALL_OW 72
103147: ST_TO_ADDR
// case class of 1 , 15 :
103148: LD_VAR 0 4
103152: PUSH
103153: LD_INT 1
103155: DOUBLE
103156: EQUAL
103157: IFTRUE 103167
103159: LD_INT 15
103161: DOUBLE
103162: EQUAL
103163: IFTRUE 103167
103165: GO 103252
103167: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
103168: LD_ADDR_VAR 0 8
103172: PUSH
103173: LD_VAR 0 2
103177: PPUSH
103178: LD_INT 2
103180: PUSH
103181: LD_INT 30
103183: PUSH
103184: LD_INT 32
103186: PUSH
103187: EMPTY
103188: LIST
103189: LIST
103190: PUSH
103191: LD_INT 30
103193: PUSH
103194: LD_INT 31
103196: PUSH
103197: EMPTY
103198: LIST
103199: LIST
103200: PUSH
103201: EMPTY
103202: LIST
103203: LIST
103204: LIST
103205: PPUSH
103206: CALL_OW 72
103210: PUSH
103211: LD_VAR 0 2
103215: PPUSH
103216: LD_INT 2
103218: PUSH
103219: LD_INT 30
103221: PUSH
103222: LD_INT 4
103224: PUSH
103225: EMPTY
103226: LIST
103227: LIST
103228: PUSH
103229: LD_INT 30
103231: PUSH
103232: LD_INT 5
103234: PUSH
103235: EMPTY
103236: LIST
103237: LIST
103238: PUSH
103239: EMPTY
103240: LIST
103241: LIST
103242: LIST
103243: PPUSH
103244: CALL_OW 72
103248: ADD
103249: ST_TO_ADDR
103250: GO 103498
103252: LD_INT 2
103254: DOUBLE
103255: EQUAL
103256: IFTRUE 103266
103258: LD_INT 16
103260: DOUBLE
103261: EQUAL
103262: IFTRUE 103266
103264: GO 103312
103266: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
103267: LD_ADDR_VAR 0 8
103271: PUSH
103272: LD_VAR 0 2
103276: PPUSH
103277: LD_INT 2
103279: PUSH
103280: LD_INT 30
103282: PUSH
103283: LD_INT 0
103285: PUSH
103286: EMPTY
103287: LIST
103288: LIST
103289: PUSH
103290: LD_INT 30
103292: PUSH
103293: LD_INT 1
103295: PUSH
103296: EMPTY
103297: LIST
103298: LIST
103299: PUSH
103300: EMPTY
103301: LIST
103302: LIST
103303: LIST
103304: PPUSH
103305: CALL_OW 72
103309: ST_TO_ADDR
103310: GO 103498
103312: LD_INT 3
103314: DOUBLE
103315: EQUAL
103316: IFTRUE 103320
103318: GO 103366
103320: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
103321: LD_ADDR_VAR 0 8
103325: PUSH
103326: LD_VAR 0 2
103330: PPUSH
103331: LD_INT 2
103333: PUSH
103334: LD_INT 30
103336: PUSH
103337: LD_INT 2
103339: PUSH
103340: EMPTY
103341: LIST
103342: LIST
103343: PUSH
103344: LD_INT 30
103346: PUSH
103347: LD_INT 3
103349: PUSH
103350: EMPTY
103351: LIST
103352: LIST
103353: PUSH
103354: EMPTY
103355: LIST
103356: LIST
103357: LIST
103358: PPUSH
103359: CALL_OW 72
103363: ST_TO_ADDR
103364: GO 103498
103366: LD_INT 4
103368: DOUBLE
103369: EQUAL
103370: IFTRUE 103374
103372: GO 103431
103374: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
103375: LD_ADDR_VAR 0 8
103379: PUSH
103380: LD_VAR 0 2
103384: PPUSH
103385: LD_INT 2
103387: PUSH
103388: LD_INT 30
103390: PUSH
103391: LD_INT 6
103393: PUSH
103394: EMPTY
103395: LIST
103396: LIST
103397: PUSH
103398: LD_INT 30
103400: PUSH
103401: LD_INT 7
103403: PUSH
103404: EMPTY
103405: LIST
103406: LIST
103407: PUSH
103408: LD_INT 30
103410: PUSH
103411: LD_INT 8
103413: PUSH
103414: EMPTY
103415: LIST
103416: LIST
103417: PUSH
103418: EMPTY
103419: LIST
103420: LIST
103421: LIST
103422: LIST
103423: PPUSH
103424: CALL_OW 72
103428: ST_TO_ADDR
103429: GO 103498
103431: LD_INT 5
103433: DOUBLE
103434: EQUAL
103435: IFTRUE 103451
103437: LD_INT 8
103439: DOUBLE
103440: EQUAL
103441: IFTRUE 103451
103443: LD_INT 9
103445: DOUBLE
103446: EQUAL
103447: IFTRUE 103451
103449: GO 103497
103451: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
103452: LD_ADDR_VAR 0 8
103456: PUSH
103457: LD_VAR 0 2
103461: PPUSH
103462: LD_INT 2
103464: PUSH
103465: LD_INT 30
103467: PUSH
103468: LD_INT 4
103470: PUSH
103471: EMPTY
103472: LIST
103473: LIST
103474: PUSH
103475: LD_INT 30
103477: PUSH
103478: LD_INT 5
103480: PUSH
103481: EMPTY
103482: LIST
103483: LIST
103484: PUSH
103485: EMPTY
103486: LIST
103487: LIST
103488: LIST
103489: PPUSH
103490: CALL_OW 72
103494: ST_TO_ADDR
103495: GO 103498
103497: POP
// if not tmp then
103498: LD_VAR 0 8
103502: NOT
103503: IFFALSE 103507
// exit ;
103505: GO 104009
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
103507: LD_VAR 0 4
103511: PUSH
103512: LD_INT 1
103514: PUSH
103515: LD_INT 15
103517: PUSH
103518: EMPTY
103519: LIST
103520: LIST
103521: IN
103522: PUSH
103523: LD_EXP 181
103527: PUSH
103528: LD_VAR 0 1
103532: ARRAY
103533: AND
103534: IFFALSE 103690
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
103536: LD_ADDR_VAR 0 9
103540: PUSH
103541: LD_EXP 181
103545: PUSH
103546: LD_VAR 0 1
103550: ARRAY
103551: PUSH
103552: LD_INT 1
103554: ARRAY
103555: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
103556: LD_VAR 0 9
103560: PUSH
103561: LD_EXP 182
103565: PUSH
103566: LD_VAR 0 1
103570: ARRAY
103571: IN
103572: NOT
103573: IFFALSE 103688
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
103575: LD_ADDR_EXP 182
103579: PUSH
103580: LD_EXP 182
103584: PPUSH
103585: LD_VAR 0 1
103589: PUSH
103590: LD_EXP 182
103594: PUSH
103595: LD_VAR 0 1
103599: ARRAY
103600: PUSH
103601: LD_INT 1
103603: PLUS
103604: PUSH
103605: EMPTY
103606: LIST
103607: LIST
103608: PPUSH
103609: LD_VAR 0 9
103613: PPUSH
103614: CALL 24096 0 3
103618: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
103619: LD_ADDR_EXP 181
103623: PUSH
103624: LD_EXP 181
103628: PPUSH
103629: LD_VAR 0 1
103633: PPUSH
103634: LD_EXP 181
103638: PUSH
103639: LD_VAR 0 1
103643: ARRAY
103644: PUSH
103645: LD_VAR 0 9
103649: DIFF
103650: PPUSH
103651: CALL_OW 1
103655: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
103656: LD_VAR 0 3
103660: PPUSH
103661: LD_EXP 182
103665: PUSH
103666: LD_VAR 0 1
103670: ARRAY
103671: PUSH
103672: LD_EXP 182
103676: PUSH
103677: LD_VAR 0 1
103681: ARRAY
103682: ARRAY
103683: PPUSH
103684: CALL_OW 120
// end ; exit ;
103688: GO 104009
// end ; if tmp > 1 then
103690: LD_VAR 0 8
103694: PUSH
103695: LD_INT 1
103697: GREATER
103698: IFFALSE 103802
// for i = 2 to tmp do
103700: LD_ADDR_VAR 0 6
103704: PUSH
103705: DOUBLE
103706: LD_INT 2
103708: DEC
103709: ST_TO_ADDR
103710: LD_VAR 0 8
103714: PUSH
103715: FOR_TO
103716: IFFALSE 103800
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
103718: LD_VAR 0 8
103722: PUSH
103723: LD_VAR 0 6
103727: ARRAY
103728: PPUSH
103729: CALL_OW 461
103733: PUSH
103734: LD_INT 6
103736: EQUAL
103737: IFFALSE 103798
// begin x := tmp [ i ] ;
103739: LD_ADDR_VAR 0 9
103743: PUSH
103744: LD_VAR 0 8
103748: PUSH
103749: LD_VAR 0 6
103753: ARRAY
103754: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
103755: LD_ADDR_VAR 0 8
103759: PUSH
103760: LD_VAR 0 8
103764: PPUSH
103765: LD_VAR 0 6
103769: PPUSH
103770: CALL_OW 3
103774: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
103775: LD_ADDR_VAR 0 8
103779: PUSH
103780: LD_VAR 0 8
103784: PPUSH
103785: LD_INT 1
103787: PPUSH
103788: LD_VAR 0 9
103792: PPUSH
103793: CALL_OW 2
103797: ST_TO_ADDR
// end ;
103798: GO 103715
103800: POP
103801: POP
// for i in tmp do
103802: LD_ADDR_VAR 0 6
103806: PUSH
103807: LD_VAR 0 8
103811: PUSH
103812: FOR_IN
103813: IFFALSE 103882
// begin if ( UnitsInside ( i ) < 6 and not GetBType ( i ) in [ b_breastwork , b_bunker ] ) or UnitsInside ( i ) = 0 then
103815: LD_VAR 0 6
103819: PPUSH
103820: CALL_OW 313
103824: PUSH
103825: LD_INT 6
103827: LESS
103828: PUSH
103829: LD_VAR 0 6
103833: PPUSH
103834: CALL_OW 266
103838: PUSH
103839: LD_INT 31
103841: PUSH
103842: LD_INT 32
103844: PUSH
103845: EMPTY
103846: LIST
103847: LIST
103848: IN
103849: NOT
103850: AND
103851: PUSH
103852: LD_VAR 0 6
103856: PPUSH
103857: CALL_OW 313
103861: PUSH
103862: LD_INT 0
103864: EQUAL
103865: OR
103866: IFFALSE 103880
// begin j := i ;
103868: LD_ADDR_VAR 0 7
103872: PUSH
103873: LD_VAR 0 6
103877: ST_TO_ADDR
// break ;
103878: GO 103882
// end ; end ;
103880: GO 103812
103882: POP
103883: POP
// if j then
103884: LD_VAR 0 7
103888: IFFALSE 103906
// ComEnterUnit ( unit , j ) else
103890: LD_VAR 0 3
103894: PPUSH
103895: LD_VAR 0 7
103899: PPUSH
103900: CALL_OW 120
103904: GO 104009
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
103906: LD_ADDR_VAR 0 10
103910: PUSH
103911: LD_VAR 0 2
103915: PPUSH
103916: LD_INT 2
103918: PUSH
103919: LD_INT 30
103921: PUSH
103922: LD_INT 0
103924: PUSH
103925: EMPTY
103926: LIST
103927: LIST
103928: PUSH
103929: LD_INT 30
103931: PUSH
103932: LD_INT 1
103934: PUSH
103935: EMPTY
103936: LIST
103937: LIST
103938: PUSH
103939: EMPTY
103940: LIST
103941: LIST
103942: LIST
103943: PPUSH
103944: CALL_OW 72
103948: ST_TO_ADDR
// if depot then
103949: LD_VAR 0 10
103953: IFFALSE 104009
// begin depot := NearestUnitToUnit ( depot , unit ) ;
103955: LD_ADDR_VAR 0 10
103959: PUSH
103960: LD_VAR 0 10
103964: PPUSH
103965: LD_VAR 0 3
103969: PPUSH
103970: CALL_OW 74
103974: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
103975: LD_VAR 0 3
103979: PPUSH
103980: LD_VAR 0 10
103984: PPUSH
103985: CALL_OW 296
103989: PUSH
103990: LD_INT 10
103992: GREATER
103993: IFFALSE 104009
// ComStandNearbyBuilding ( unit , depot ) ;
103995: LD_VAR 0 3
103999: PPUSH
104000: LD_VAR 0 10
104004: PPUSH
104005: CALL 20710 0 2
// end ; end ; end ;
104009: LD_VAR 0 5
104013: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
104014: LD_INT 0
104016: PPUSH
104017: PPUSH
104018: PPUSH
104019: PPUSH
// if not mc_bases then
104020: LD_EXP 172
104024: NOT
104025: IFFALSE 104029
// exit ;
104027: GO 104268
// for i = 1 to mc_bases do
104029: LD_ADDR_VAR 0 2
104033: PUSH
104034: DOUBLE
104035: LD_INT 1
104037: DEC
104038: ST_TO_ADDR
104039: LD_EXP 172
104043: PUSH
104044: FOR_TO
104045: IFFALSE 104266
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
104047: LD_ADDR_VAR 0 4
104051: PUSH
104052: LD_EXP 172
104056: PUSH
104057: LD_VAR 0 2
104061: ARRAY
104062: PPUSH
104063: LD_INT 21
104065: PUSH
104066: LD_INT 1
104068: PUSH
104069: EMPTY
104070: LIST
104071: LIST
104072: PPUSH
104073: CALL_OW 72
104077: PUSH
104078: LD_EXP 201
104082: PUSH
104083: LD_VAR 0 2
104087: ARRAY
104088: UNION
104089: ST_TO_ADDR
// if not tmp then
104090: LD_VAR 0 4
104094: NOT
104095: IFFALSE 104099
// continue ;
104097: GO 104044
// for j in tmp do
104099: LD_ADDR_VAR 0 3
104103: PUSH
104104: LD_VAR 0 4
104108: PUSH
104109: FOR_IN
104110: IFFALSE 104262
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
104112: LD_VAR 0 3
104116: PPUSH
104117: CALL_OW 110
104121: NOT
104122: PUSH
104123: LD_VAR 0 3
104127: PPUSH
104128: CALL_OW 314
104132: NOT
104133: AND
104134: PUSH
104135: LD_VAR 0 3
104139: PPUSH
104140: CALL_OW 311
104144: NOT
104145: AND
104146: PUSH
104147: LD_VAR 0 3
104151: PPUSH
104152: CALL_OW 310
104156: NOT
104157: AND
104158: PUSH
104159: LD_VAR 0 3
104163: PUSH
104164: LD_EXP 175
104168: PUSH
104169: LD_VAR 0 2
104173: ARRAY
104174: PUSH
104175: LD_INT 1
104177: ARRAY
104178: IN
104179: NOT
104180: AND
104181: PUSH
104182: LD_VAR 0 3
104186: PUSH
104187: LD_EXP 175
104191: PUSH
104192: LD_VAR 0 2
104196: ARRAY
104197: PUSH
104198: LD_INT 2
104200: ARRAY
104201: IN
104202: NOT
104203: AND
104204: PUSH
104205: LD_VAR 0 3
104209: PUSH
104210: LD_EXP 184
104214: PUSH
104215: LD_VAR 0 2
104219: ARRAY
104220: IN
104221: NOT
104222: AND
104223: IFFALSE 104260
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
104225: LD_VAR 0 2
104229: PPUSH
104230: LD_EXP 172
104234: PUSH
104235: LD_VAR 0 2
104239: ARRAY
104240: PPUSH
104241: LD_VAR 0 3
104245: PPUSH
104246: LD_VAR 0 3
104250: PPUSH
104251: CALL_OW 257
104255: PPUSH
104256: CALL 103032 0 4
// end ;
104260: GO 104109
104262: POP
104263: POP
// end ;
104264: GO 104044
104266: POP
104267: POP
// end ;
104268: LD_VAR 0 1
104272: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , x , j ; begin
104273: LD_INT 0
104275: PPUSH
104276: PPUSH
104277: PPUSH
104278: PPUSH
104279: PPUSH
104280: PPUSH
// if not mc_bases [ base ] then
104281: LD_EXP 172
104285: PUSH
104286: LD_VAR 0 1
104290: ARRAY
104291: NOT
104292: IFFALSE 104296
// exit ;
104294: GO 104478
// tmp := [ ] ;
104296: LD_ADDR_VAR 0 6
104300: PUSH
104301: EMPTY
104302: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
104303: LD_ADDR_VAR 0 7
104307: PUSH
104308: LD_VAR 0 3
104312: PPUSH
104313: LD_INT 0
104315: PPUSH
104316: CALL_OW 517
104320: ST_TO_ADDR
// if not list then
104321: LD_VAR 0 7
104325: NOT
104326: IFFALSE 104330
// exit ;
104328: GO 104478
// for i = 1 to amount do
104330: LD_ADDR_VAR 0 5
104334: PUSH
104335: DOUBLE
104336: LD_INT 1
104338: DEC
104339: ST_TO_ADDR
104340: LD_VAR 0 2
104344: PUSH
104345: FOR_TO
104346: IFFALSE 104426
// begin x := rand ( 1 , list [ 1 ] ) ;
104348: LD_ADDR_VAR 0 8
104352: PUSH
104353: LD_INT 1
104355: PPUSH
104356: LD_VAR 0 7
104360: PUSH
104361: LD_INT 1
104363: ARRAY
104364: PPUSH
104365: CALL_OW 12
104369: ST_TO_ADDR
// tmp := Replace ( tmp , i , [ list [ 1 ] [ x ] , list [ 2 ] [ x ] ] ) ;
104370: LD_ADDR_VAR 0 6
104374: PUSH
104375: LD_VAR 0 6
104379: PPUSH
104380: LD_VAR 0 5
104384: PPUSH
104385: LD_VAR 0 7
104389: PUSH
104390: LD_INT 1
104392: ARRAY
104393: PUSH
104394: LD_VAR 0 8
104398: ARRAY
104399: PUSH
104400: LD_VAR 0 7
104404: PUSH
104405: LD_INT 2
104407: ARRAY
104408: PUSH
104409: LD_VAR 0 8
104413: ARRAY
104414: PUSH
104415: EMPTY
104416: LIST
104417: LIST
104418: PPUSH
104419: CALL_OW 1
104423: ST_TO_ADDR
// end ;
104424: GO 104345
104426: POP
104427: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
104428: LD_ADDR_EXP 185
104432: PUSH
104433: LD_EXP 185
104437: PPUSH
104438: LD_VAR 0 1
104442: PPUSH
104443: LD_VAR 0 6
104447: PPUSH
104448: CALL_OW 1
104452: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
104453: LD_ADDR_EXP 187
104457: PUSH
104458: LD_EXP 187
104462: PPUSH
104463: LD_VAR 0 1
104467: PPUSH
104468: LD_VAR 0 3
104472: PPUSH
104473: CALL_OW 1
104477: ST_TO_ADDR
// end ;
104478: LD_VAR 0 4
104482: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
104483: LD_INT 0
104485: PPUSH
// if not mc_bases [ base ] then
104486: LD_EXP 172
104490: PUSH
104491: LD_VAR 0 1
104495: ARRAY
104496: NOT
104497: IFFALSE 104501
// exit ;
104499: GO 104526
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
104501: LD_ADDR_EXP 177
104505: PUSH
104506: LD_EXP 177
104510: PPUSH
104511: LD_VAR 0 1
104515: PPUSH
104516: LD_VAR 0 2
104520: PPUSH
104521: CALL_OW 1
104525: ST_TO_ADDR
// end ;
104526: LD_VAR 0 3
104530: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
104531: LD_INT 0
104533: PPUSH
// if not mc_bases [ base ] then
104534: LD_EXP 172
104538: PUSH
104539: LD_VAR 0 1
104543: ARRAY
104544: NOT
104545: IFFALSE 104549
// exit ;
104547: GO 104586
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
104549: LD_ADDR_EXP 177
104553: PUSH
104554: LD_EXP 177
104558: PPUSH
104559: LD_VAR 0 1
104563: PPUSH
104564: LD_EXP 177
104568: PUSH
104569: LD_VAR 0 1
104573: ARRAY
104574: PUSH
104575: LD_VAR 0 2
104579: UNION
104580: PPUSH
104581: CALL_OW 1
104585: ST_TO_ADDR
// end ;
104586: LD_VAR 0 3
104590: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
104591: LD_INT 0
104593: PPUSH
// if not mc_bases [ base ] then
104594: LD_EXP 172
104598: PUSH
104599: LD_VAR 0 1
104603: ARRAY
104604: NOT
104605: IFFALSE 104609
// exit ;
104607: GO 104634
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
104609: LD_ADDR_EXP 193
104613: PUSH
104614: LD_EXP 193
104618: PPUSH
104619: LD_VAR 0 1
104623: PPUSH
104624: LD_VAR 0 2
104628: PPUSH
104629: CALL_OW 1
104633: ST_TO_ADDR
// end ;
104634: LD_VAR 0 3
104638: RET
// export function MC_InsertProduceList ( base , components ) ; begin
104639: LD_INT 0
104641: PPUSH
// if not mc_bases [ base ] then
104642: LD_EXP 172
104646: PUSH
104647: LD_VAR 0 1
104651: ARRAY
104652: NOT
104653: IFFALSE 104657
// exit ;
104655: GO 104694
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
104657: LD_ADDR_EXP 193
104661: PUSH
104662: LD_EXP 193
104666: PPUSH
104667: LD_VAR 0 1
104671: PPUSH
104672: LD_EXP 193
104676: PUSH
104677: LD_VAR 0 1
104681: ARRAY
104682: PUSH
104683: LD_VAR 0 2
104687: ADD
104688: PPUSH
104689: CALL_OW 1
104693: ST_TO_ADDR
// end ;
104694: LD_VAR 0 3
104698: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
104699: LD_INT 0
104701: PPUSH
// if not mc_bases [ base ] then
104702: LD_EXP 172
104706: PUSH
104707: LD_VAR 0 1
104711: ARRAY
104712: NOT
104713: IFFALSE 104717
// exit ;
104715: GO 104771
// mc_defender := Replace ( mc_defender , base , deflist ) ;
104717: LD_ADDR_EXP 194
104721: PUSH
104722: LD_EXP 194
104726: PPUSH
104727: LD_VAR 0 1
104731: PPUSH
104732: LD_VAR 0 2
104736: PPUSH
104737: CALL_OW 1
104741: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
104742: LD_ADDR_EXP 183
104746: PUSH
104747: LD_EXP 183
104751: PPUSH
104752: LD_VAR 0 1
104756: PPUSH
104757: LD_VAR 0 2
104761: PUSH
104762: LD_INT 0
104764: PLUS
104765: PPUSH
104766: CALL_OW 1
104770: ST_TO_ADDR
// end ;
104771: LD_VAR 0 3
104775: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
104776: LD_INT 0
104778: PPUSH
// if not mc_bases [ base ] then
104779: LD_EXP 172
104783: PUSH
104784: LD_VAR 0 1
104788: ARRAY
104789: NOT
104790: IFFALSE 104794
// exit ;
104792: GO 104819
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
104794: LD_ADDR_EXP 183
104798: PUSH
104799: LD_EXP 183
104803: PPUSH
104804: LD_VAR 0 1
104808: PPUSH
104809: LD_VAR 0 2
104813: PPUSH
104814: CALL_OW 1
104818: ST_TO_ADDR
// end ;
104819: LD_VAR 0 3
104823: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
104824: LD_INT 0
104826: PPUSH
104827: PPUSH
104828: PPUSH
104829: PPUSH
// if not mc_bases [ base ] then
104830: LD_EXP 172
104834: PUSH
104835: LD_VAR 0 1
104839: ARRAY
104840: NOT
104841: IFFALSE 104845
// exit ;
104843: GO 104910
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
104845: LD_ADDR_EXP 192
104849: PUSH
104850: LD_EXP 192
104854: PPUSH
104855: LD_VAR 0 1
104859: PUSH
104860: LD_EXP 192
104864: PUSH
104865: LD_VAR 0 1
104869: ARRAY
104870: PUSH
104871: LD_INT 1
104873: PLUS
104874: PUSH
104875: EMPTY
104876: LIST
104877: LIST
104878: PPUSH
104879: LD_VAR 0 1
104883: PUSH
104884: LD_VAR 0 2
104888: PUSH
104889: LD_VAR 0 3
104893: PUSH
104894: LD_VAR 0 4
104898: PUSH
104899: EMPTY
104900: LIST
104901: LIST
104902: LIST
104903: LIST
104904: PPUSH
104905: CALL 24096 0 3
104909: ST_TO_ADDR
// end ;
104910: LD_VAR 0 5
104914: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
104915: LD_INT 0
104917: PPUSH
// if not mc_bases [ base ] then
104918: LD_EXP 172
104922: PUSH
104923: LD_VAR 0 1
104927: ARRAY
104928: NOT
104929: IFFALSE 104933
// exit ;
104931: GO 104958
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
104933: LD_ADDR_EXP 209
104937: PUSH
104938: LD_EXP 209
104942: PPUSH
104943: LD_VAR 0 1
104947: PPUSH
104948: LD_VAR 0 2
104952: PPUSH
104953: CALL_OW 1
104957: ST_TO_ADDR
// end ;
104958: LD_VAR 0 3
104962: RET
// export function MC_GetMinesField ( base ) ; begin
104963: LD_INT 0
104965: PPUSH
// result := mc_mines [ base ] ;
104966: LD_ADDR_VAR 0 2
104970: PUSH
104971: LD_EXP 185
104975: PUSH
104976: LD_VAR 0 1
104980: ARRAY
104981: ST_TO_ADDR
// end ;
104982: LD_VAR 0 2
104986: RET
// export function MC_GetProduceList ( base ) ; begin
104987: LD_INT 0
104989: PPUSH
// result := mc_produce [ base ] ;
104990: LD_ADDR_VAR 0 2
104994: PUSH
104995: LD_EXP 193
104999: PUSH
105000: LD_VAR 0 1
105004: ARRAY
105005: ST_TO_ADDR
// end ;
105006: LD_VAR 0 2
105010: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
105011: LD_INT 0
105013: PPUSH
105014: PPUSH
// if not mc_bases then
105015: LD_EXP 172
105019: NOT
105020: IFFALSE 105024
// exit ;
105022: GO 105089
// if mc_bases [ base ] then
105024: LD_EXP 172
105028: PUSH
105029: LD_VAR 0 1
105033: ARRAY
105034: IFFALSE 105089
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
105036: LD_ADDR_VAR 0 3
105040: PUSH
105041: LD_EXP 172
105045: PUSH
105046: LD_VAR 0 1
105050: ARRAY
105051: PPUSH
105052: LD_INT 30
105054: PUSH
105055: LD_VAR 0 2
105059: PUSH
105060: EMPTY
105061: LIST
105062: LIST
105063: PPUSH
105064: CALL_OW 72
105068: ST_TO_ADDR
// if result then
105069: LD_VAR 0 3
105073: IFFALSE 105089
// result := result [ 1 ] ;
105075: LD_ADDR_VAR 0 3
105079: PUSH
105080: LD_VAR 0 3
105084: PUSH
105085: LD_INT 1
105087: ARRAY
105088: ST_TO_ADDR
// end ; end ;
105089: LD_VAR 0 3
105093: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
105094: LD_INT 0
105096: PPUSH
105097: PPUSH
// if not mc_bases then
105098: LD_EXP 172
105102: NOT
105103: IFFALSE 105107
// exit ;
105105: GO 105152
// if mc_bases [ base ] then
105107: LD_EXP 172
105111: PUSH
105112: LD_VAR 0 1
105116: ARRAY
105117: IFFALSE 105152
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
105119: LD_ADDR_VAR 0 3
105123: PUSH
105124: LD_EXP 172
105128: PUSH
105129: LD_VAR 0 1
105133: ARRAY
105134: PPUSH
105135: LD_INT 30
105137: PUSH
105138: LD_VAR 0 2
105142: PUSH
105143: EMPTY
105144: LIST
105145: LIST
105146: PPUSH
105147: CALL_OW 72
105151: ST_TO_ADDR
// end ;
105152: LD_VAR 0 3
105156: RET
// export function MC_SetTame ( base , area ) ; begin
105157: LD_INT 0
105159: PPUSH
// if not mc_bases or not base then
105160: LD_EXP 172
105164: NOT
105165: PUSH
105166: LD_VAR 0 1
105170: NOT
105171: OR
105172: IFFALSE 105176
// exit ;
105174: GO 105201
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
105176: LD_ADDR_EXP 200
105180: PUSH
105181: LD_EXP 200
105185: PPUSH
105186: LD_VAR 0 1
105190: PPUSH
105191: LD_VAR 0 2
105195: PPUSH
105196: CALL_OW 1
105200: ST_TO_ADDR
// end ;
105201: LD_VAR 0 3
105205: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
105206: LD_INT 0
105208: PPUSH
105209: PPUSH
// if not mc_bases or not base then
105210: LD_EXP 172
105214: NOT
105215: PUSH
105216: LD_VAR 0 1
105220: NOT
105221: OR
105222: IFFALSE 105226
// exit ;
105224: GO 105328
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
105226: LD_ADDR_VAR 0 4
105230: PUSH
105231: LD_EXP 172
105235: PUSH
105236: LD_VAR 0 1
105240: ARRAY
105241: PPUSH
105242: LD_INT 30
105244: PUSH
105245: LD_VAR 0 2
105249: PUSH
105250: EMPTY
105251: LIST
105252: LIST
105253: PPUSH
105254: CALL_OW 72
105258: ST_TO_ADDR
// if not tmp then
105259: LD_VAR 0 4
105263: NOT
105264: IFFALSE 105268
// exit ;
105266: GO 105328
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
105268: LD_ADDR_EXP 204
105272: PUSH
105273: LD_EXP 204
105277: PPUSH
105278: LD_VAR 0 1
105282: PPUSH
105283: LD_EXP 204
105287: PUSH
105288: LD_VAR 0 1
105292: ARRAY
105293: PPUSH
105294: LD_EXP 204
105298: PUSH
105299: LD_VAR 0 1
105303: ARRAY
105304: PUSH
105305: LD_INT 1
105307: PLUS
105308: PPUSH
105309: LD_VAR 0 4
105313: PUSH
105314: LD_INT 1
105316: ARRAY
105317: PPUSH
105318: CALL_OW 2
105322: PPUSH
105323: CALL_OW 1
105327: ST_TO_ADDR
// end ;
105328: LD_VAR 0 3
105332: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
105333: LD_INT 0
105335: PPUSH
105336: PPUSH
// if not mc_bases or not base or not kinds then
105337: LD_EXP 172
105341: NOT
105342: PUSH
105343: LD_VAR 0 1
105347: NOT
105348: OR
105349: PUSH
105350: LD_VAR 0 2
105354: NOT
105355: OR
105356: IFFALSE 105360
// exit ;
105358: GO 105421
// for i in kinds do
105360: LD_ADDR_VAR 0 4
105364: PUSH
105365: LD_VAR 0 2
105369: PUSH
105370: FOR_IN
105371: IFFALSE 105419
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
105373: LD_ADDR_EXP 206
105377: PUSH
105378: LD_EXP 206
105382: PPUSH
105383: LD_VAR 0 1
105387: PUSH
105388: LD_EXP 206
105392: PUSH
105393: LD_VAR 0 1
105397: ARRAY
105398: PUSH
105399: LD_INT 1
105401: PLUS
105402: PUSH
105403: EMPTY
105404: LIST
105405: LIST
105406: PPUSH
105407: LD_VAR 0 4
105411: PPUSH
105412: CALL 24096 0 3
105416: ST_TO_ADDR
105417: GO 105370
105419: POP
105420: POP
// end ;
105421: LD_VAR 0 3
105425: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
105426: LD_INT 0
105428: PPUSH
// if not mc_bases or not base or not areas then
105429: LD_EXP 172
105433: NOT
105434: PUSH
105435: LD_VAR 0 1
105439: NOT
105440: OR
105441: PUSH
105442: LD_VAR 0 2
105446: NOT
105447: OR
105448: IFFALSE 105452
// exit ;
105450: GO 105477
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
105452: LD_ADDR_EXP 190
105456: PUSH
105457: LD_EXP 190
105461: PPUSH
105462: LD_VAR 0 1
105466: PPUSH
105467: LD_VAR 0 2
105471: PPUSH
105472: CALL_OW 1
105476: ST_TO_ADDR
// end ;
105477: LD_VAR 0 3
105481: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
105482: LD_INT 0
105484: PPUSH
// if not mc_bases or not base or not teleports_exit then
105485: LD_EXP 172
105489: NOT
105490: PUSH
105491: LD_VAR 0 1
105495: NOT
105496: OR
105497: PUSH
105498: LD_VAR 0 2
105502: NOT
105503: OR
105504: IFFALSE 105508
// exit ;
105506: GO 105533
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
105508: LD_ADDR_EXP 207
105512: PUSH
105513: LD_EXP 207
105517: PPUSH
105518: LD_VAR 0 1
105522: PPUSH
105523: LD_VAR 0 2
105527: PPUSH
105528: CALL_OW 1
105532: ST_TO_ADDR
// end ;
105533: LD_VAR 0 3
105537: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
105538: LD_INT 0
105540: PPUSH
105541: PPUSH
105542: PPUSH
// if not mc_bases or not base or not ext_list then
105543: LD_EXP 172
105547: NOT
105548: PUSH
105549: LD_VAR 0 1
105553: NOT
105554: OR
105555: PUSH
105556: LD_VAR 0 5
105560: NOT
105561: OR
105562: IFFALSE 105566
// exit ;
105564: GO 105739
// tmp := GetFacExtXYD ( x , y , d ) ;
105566: LD_ADDR_VAR 0 8
105570: PUSH
105571: LD_VAR 0 2
105575: PPUSH
105576: LD_VAR 0 3
105580: PPUSH
105581: LD_VAR 0 4
105585: PPUSH
105586: CALL 52775 0 3
105590: ST_TO_ADDR
// if not tmp then
105591: LD_VAR 0 8
105595: NOT
105596: IFFALSE 105600
// exit ;
105598: GO 105739
// for i in tmp do
105600: LD_ADDR_VAR 0 7
105604: PUSH
105605: LD_VAR 0 8
105609: PUSH
105610: FOR_IN
105611: IFFALSE 105737
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
105613: LD_ADDR_EXP 177
105617: PUSH
105618: LD_EXP 177
105622: PPUSH
105623: LD_VAR 0 1
105627: PPUSH
105628: LD_EXP 177
105632: PUSH
105633: LD_VAR 0 1
105637: ARRAY
105638: PPUSH
105639: LD_EXP 177
105643: PUSH
105644: LD_VAR 0 1
105648: ARRAY
105649: PUSH
105650: LD_INT 1
105652: PLUS
105653: PPUSH
105654: LD_VAR 0 5
105658: PUSH
105659: LD_INT 1
105661: ARRAY
105662: PUSH
105663: LD_VAR 0 7
105667: PUSH
105668: LD_INT 1
105670: ARRAY
105671: PUSH
105672: LD_VAR 0 7
105676: PUSH
105677: LD_INT 2
105679: ARRAY
105680: PUSH
105681: LD_VAR 0 7
105685: PUSH
105686: LD_INT 3
105688: ARRAY
105689: PUSH
105690: EMPTY
105691: LIST
105692: LIST
105693: LIST
105694: LIST
105695: PPUSH
105696: CALL_OW 2
105700: PPUSH
105701: CALL_OW 1
105705: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
105706: LD_ADDR_VAR 0 5
105710: PUSH
105711: LD_VAR 0 5
105715: PPUSH
105716: LD_INT 1
105718: PPUSH
105719: CALL_OW 3
105723: ST_TO_ADDR
// if not ext_list then
105724: LD_VAR 0 5
105728: NOT
105729: IFFALSE 105735
// exit ;
105731: POP
105732: POP
105733: GO 105739
// end ;
105735: GO 105610
105737: POP
105738: POP
// end ;
105739: LD_VAR 0 6
105743: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
105744: LD_INT 0
105746: PPUSH
// if not mc_bases or not base or not weapon_list then
105747: LD_EXP 172
105751: NOT
105752: PUSH
105753: LD_VAR 0 1
105757: NOT
105758: OR
105759: PUSH
105760: LD_VAR 0 2
105764: NOT
105765: OR
105766: IFFALSE 105770
// exit ;
105768: GO 105795
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
105770: LD_ADDR_EXP 211
105774: PUSH
105775: LD_EXP 211
105779: PPUSH
105780: LD_VAR 0 1
105784: PPUSH
105785: LD_VAR 0 2
105789: PPUSH
105790: CALL_OW 1
105794: ST_TO_ADDR
// end ;
105795: LD_VAR 0 3
105799: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
105800: LD_INT 0
105802: PPUSH
// if not mc_bases or not base or not tech_list then
105803: LD_EXP 172
105807: NOT
105808: PUSH
105809: LD_VAR 0 1
105813: NOT
105814: OR
105815: PUSH
105816: LD_VAR 0 2
105820: NOT
105821: OR
105822: IFFALSE 105826
// exit ;
105824: GO 105851
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
105826: LD_ADDR_EXP 199
105830: PUSH
105831: LD_EXP 199
105835: PPUSH
105836: LD_VAR 0 1
105840: PPUSH
105841: LD_VAR 0 2
105845: PPUSH
105846: CALL_OW 1
105850: ST_TO_ADDR
// end ;
105851: LD_VAR 0 3
105855: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
105856: LD_INT 0
105858: PPUSH
// if not mc_bases or not parking_area or not base then
105859: LD_EXP 172
105863: NOT
105864: PUSH
105865: LD_VAR 0 2
105869: NOT
105870: OR
105871: PUSH
105872: LD_VAR 0 1
105876: NOT
105877: OR
105878: IFFALSE 105882
// exit ;
105880: GO 105907
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
105882: LD_ADDR_EXP 196
105886: PUSH
105887: LD_EXP 196
105891: PPUSH
105892: LD_VAR 0 1
105896: PPUSH
105897: LD_VAR 0 2
105901: PPUSH
105902: CALL_OW 1
105906: ST_TO_ADDR
// end ;
105907: LD_VAR 0 3
105911: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
105912: LD_INT 0
105914: PPUSH
// if not mc_bases or not base or not scan_area then
105915: LD_EXP 172
105919: NOT
105920: PUSH
105921: LD_VAR 0 1
105925: NOT
105926: OR
105927: PUSH
105928: LD_VAR 0 2
105932: NOT
105933: OR
105934: IFFALSE 105938
// exit ;
105936: GO 105963
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
105938: LD_ADDR_EXP 197
105942: PUSH
105943: LD_EXP 197
105947: PPUSH
105948: LD_VAR 0 1
105952: PPUSH
105953: LD_VAR 0 2
105957: PPUSH
105958: CALL_OW 1
105962: ST_TO_ADDR
// end ;
105963: LD_VAR 0 3
105967: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
105968: LD_INT 0
105970: PPUSH
105971: PPUSH
// if not mc_bases or not base then
105972: LD_EXP 172
105976: NOT
105977: PUSH
105978: LD_VAR 0 1
105982: NOT
105983: OR
105984: IFFALSE 105988
// exit ;
105986: GO 106052
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
105988: LD_ADDR_VAR 0 3
105992: PUSH
105993: LD_INT 1
105995: PUSH
105996: LD_INT 2
105998: PUSH
105999: LD_INT 3
106001: PUSH
106002: LD_INT 4
106004: PUSH
106005: LD_INT 11
106007: PUSH
106008: EMPTY
106009: LIST
106010: LIST
106011: LIST
106012: LIST
106013: LIST
106014: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
106015: LD_ADDR_EXP 199
106019: PUSH
106020: LD_EXP 199
106024: PPUSH
106025: LD_VAR 0 1
106029: PPUSH
106030: LD_EXP 199
106034: PUSH
106035: LD_VAR 0 1
106039: ARRAY
106040: PUSH
106041: LD_VAR 0 3
106045: DIFF
106046: PPUSH
106047: CALL_OW 1
106051: ST_TO_ADDR
// end ;
106052: LD_VAR 0 2
106056: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
106057: LD_INT 0
106059: PPUSH
// result := mc_vehicles [ base ] ;
106060: LD_ADDR_VAR 0 3
106064: PUSH
106065: LD_EXP 191
106069: PUSH
106070: LD_VAR 0 1
106074: ARRAY
106075: ST_TO_ADDR
// if onlyCombat then
106076: LD_VAR 0 2
106080: IFFALSE 106258
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
106082: LD_ADDR_VAR 0 3
106086: PUSH
106087: LD_VAR 0 3
106091: PUSH
106092: LD_VAR 0 3
106096: PPUSH
106097: LD_INT 2
106099: PUSH
106100: LD_INT 34
106102: PUSH
106103: LD_INT 12
106105: PUSH
106106: EMPTY
106107: LIST
106108: LIST
106109: PUSH
106110: LD_INT 34
106112: PUSH
106113: LD_INT 51
106115: PUSH
106116: EMPTY
106117: LIST
106118: LIST
106119: PUSH
106120: LD_INT 34
106122: PUSH
106123: LD_EXP 155
106127: PUSH
106128: EMPTY
106129: LIST
106130: LIST
106131: PUSH
106132: LD_INT 34
106134: PUSH
106135: LD_INT 32
106137: PUSH
106138: EMPTY
106139: LIST
106140: LIST
106141: PUSH
106142: LD_INT 34
106144: PUSH
106145: LD_INT 13
106147: PUSH
106148: EMPTY
106149: LIST
106150: LIST
106151: PUSH
106152: LD_INT 34
106154: PUSH
106155: LD_INT 52
106157: PUSH
106158: EMPTY
106159: LIST
106160: LIST
106161: PUSH
106162: LD_INT 34
106164: PUSH
106165: LD_EXP 160
106169: PUSH
106170: EMPTY
106171: LIST
106172: LIST
106173: PUSH
106174: LD_INT 34
106176: PUSH
106177: LD_INT 14
106179: PUSH
106180: EMPTY
106181: LIST
106182: LIST
106183: PUSH
106184: LD_INT 34
106186: PUSH
106187: LD_INT 53
106189: PUSH
106190: EMPTY
106191: LIST
106192: LIST
106193: PUSH
106194: LD_INT 34
106196: PUSH
106197: LD_EXP 154
106201: PUSH
106202: EMPTY
106203: LIST
106204: LIST
106205: PUSH
106206: LD_INT 34
106208: PUSH
106209: LD_INT 31
106211: PUSH
106212: EMPTY
106213: LIST
106214: LIST
106215: PUSH
106216: LD_INT 34
106218: PUSH
106219: LD_INT 48
106221: PUSH
106222: EMPTY
106223: LIST
106224: LIST
106225: PUSH
106226: LD_INT 34
106228: PUSH
106229: LD_INT 8
106231: PUSH
106232: EMPTY
106233: LIST
106234: LIST
106235: PUSH
106236: EMPTY
106237: LIST
106238: LIST
106239: LIST
106240: LIST
106241: LIST
106242: LIST
106243: LIST
106244: LIST
106245: LIST
106246: LIST
106247: LIST
106248: LIST
106249: LIST
106250: LIST
106251: PPUSH
106252: CALL_OW 72
106256: DIFF
106257: ST_TO_ADDR
// end ; end_of_file
106258: LD_VAR 0 3
106262: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
106263: LD_INT 0
106265: PPUSH
106266: PPUSH
106267: PPUSH
// if not mc_bases or not skirmish then
106268: LD_EXP 172
106272: NOT
106273: PUSH
106274: LD_EXP 170
106278: NOT
106279: OR
106280: IFFALSE 106284
// exit ;
106282: GO 106449
// for i = 1 to mc_bases do
106284: LD_ADDR_VAR 0 4
106288: PUSH
106289: DOUBLE
106290: LD_INT 1
106292: DEC
106293: ST_TO_ADDR
106294: LD_EXP 172
106298: PUSH
106299: FOR_TO
106300: IFFALSE 106447
// begin if sci in mc_bases [ i ] then
106302: LD_VAR 0 2
106306: PUSH
106307: LD_EXP 172
106311: PUSH
106312: LD_VAR 0 4
106316: ARRAY
106317: IN
106318: IFFALSE 106445
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
106320: LD_ADDR_EXP 201
106324: PUSH
106325: LD_EXP 201
106329: PPUSH
106330: LD_VAR 0 4
106334: PUSH
106335: LD_EXP 201
106339: PUSH
106340: LD_VAR 0 4
106344: ARRAY
106345: PUSH
106346: LD_INT 1
106348: PLUS
106349: PUSH
106350: EMPTY
106351: LIST
106352: LIST
106353: PPUSH
106354: LD_VAR 0 1
106358: PPUSH
106359: CALL 24096 0 3
106363: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
106364: LD_ADDR_VAR 0 5
106368: PUSH
106369: LD_EXP 172
106373: PUSH
106374: LD_VAR 0 4
106378: ARRAY
106379: PPUSH
106380: LD_INT 2
106382: PUSH
106383: LD_INT 30
106385: PUSH
106386: LD_INT 0
106388: PUSH
106389: EMPTY
106390: LIST
106391: LIST
106392: PUSH
106393: LD_INT 30
106395: PUSH
106396: LD_INT 1
106398: PUSH
106399: EMPTY
106400: LIST
106401: LIST
106402: PUSH
106403: EMPTY
106404: LIST
106405: LIST
106406: LIST
106407: PPUSH
106408: CALL_OW 72
106412: PPUSH
106413: LD_VAR 0 1
106417: PPUSH
106418: CALL_OW 74
106422: ST_TO_ADDR
// if tmp then
106423: LD_VAR 0 5
106427: IFFALSE 106443
// ComStandNearbyBuilding ( ape , tmp ) ;
106429: LD_VAR 0 1
106433: PPUSH
106434: LD_VAR 0 5
106438: PPUSH
106439: CALL 20710 0 2
// break ;
106443: GO 106447
// end ; end ;
106445: GO 106299
106447: POP
106448: POP
// end ;
106449: LD_VAR 0 3
106453: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
106454: LD_INT 0
106456: PPUSH
106457: PPUSH
106458: PPUSH
// if not mc_bases or not skirmish then
106459: LD_EXP 172
106463: NOT
106464: PUSH
106465: LD_EXP 170
106469: NOT
106470: OR
106471: IFFALSE 106475
// exit ;
106473: GO 106564
// for i = 1 to mc_bases do
106475: LD_ADDR_VAR 0 4
106479: PUSH
106480: DOUBLE
106481: LD_INT 1
106483: DEC
106484: ST_TO_ADDR
106485: LD_EXP 172
106489: PUSH
106490: FOR_TO
106491: IFFALSE 106562
// begin if building in mc_busy_turret_list [ i ] then
106493: LD_VAR 0 1
106497: PUSH
106498: LD_EXP 182
106502: PUSH
106503: LD_VAR 0 4
106507: ARRAY
106508: IN
106509: IFFALSE 106560
// begin tmp := mc_busy_turret_list [ i ] diff building ;
106511: LD_ADDR_VAR 0 5
106515: PUSH
106516: LD_EXP 182
106520: PUSH
106521: LD_VAR 0 4
106525: ARRAY
106526: PUSH
106527: LD_VAR 0 1
106531: DIFF
106532: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
106533: LD_ADDR_EXP 182
106537: PUSH
106538: LD_EXP 182
106542: PPUSH
106543: LD_VAR 0 4
106547: PPUSH
106548: LD_VAR 0 5
106552: PPUSH
106553: CALL_OW 1
106557: ST_TO_ADDR
// break ;
106558: GO 106562
// end ; end ;
106560: GO 106490
106562: POP
106563: POP
// end ;
106564: LD_VAR 0 3
106568: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
106569: LD_INT 0
106571: PPUSH
106572: PPUSH
106573: PPUSH
// if not mc_bases or not skirmish then
106574: LD_EXP 172
106578: NOT
106579: PUSH
106580: LD_EXP 170
106584: NOT
106585: OR
106586: IFFALSE 106590
// exit ;
106588: GO 106789
// for i = 1 to mc_bases do
106590: LD_ADDR_VAR 0 5
106594: PUSH
106595: DOUBLE
106596: LD_INT 1
106598: DEC
106599: ST_TO_ADDR
106600: LD_EXP 172
106604: PUSH
106605: FOR_TO
106606: IFFALSE 106787
// if building in mc_bases [ i ] then
106608: LD_VAR 0 1
106612: PUSH
106613: LD_EXP 172
106617: PUSH
106618: LD_VAR 0 5
106622: ARRAY
106623: IN
106624: IFFALSE 106785
// begin tmp := mc_bases [ i ] diff building ;
106626: LD_ADDR_VAR 0 6
106630: PUSH
106631: LD_EXP 172
106635: PUSH
106636: LD_VAR 0 5
106640: ARRAY
106641: PUSH
106642: LD_VAR 0 1
106646: DIFF
106647: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
106648: LD_ADDR_EXP 172
106652: PUSH
106653: LD_EXP 172
106657: PPUSH
106658: LD_VAR 0 5
106662: PPUSH
106663: LD_VAR 0 6
106667: PPUSH
106668: CALL_OW 1
106672: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
106673: LD_VAR 0 1
106677: PUSH
106678: LD_EXP 180
106682: PUSH
106683: LD_VAR 0 5
106687: ARRAY
106688: IN
106689: IFFALSE 106728
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
106691: LD_ADDR_EXP 180
106695: PUSH
106696: LD_EXP 180
106700: PPUSH
106701: LD_VAR 0 5
106705: PPUSH
106706: LD_EXP 180
106710: PUSH
106711: LD_VAR 0 5
106715: ARRAY
106716: PUSH
106717: LD_VAR 0 1
106721: DIFF
106722: PPUSH
106723: CALL_OW 1
106727: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
106728: LD_VAR 0 1
106732: PUSH
106733: LD_EXP 181
106737: PUSH
106738: LD_VAR 0 5
106742: ARRAY
106743: IN
106744: IFFALSE 106783
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
106746: LD_ADDR_EXP 181
106750: PUSH
106751: LD_EXP 181
106755: PPUSH
106756: LD_VAR 0 5
106760: PPUSH
106761: LD_EXP 181
106765: PUSH
106766: LD_VAR 0 5
106770: ARRAY
106771: PUSH
106772: LD_VAR 0 1
106776: DIFF
106777: PPUSH
106778: CALL_OW 1
106782: ST_TO_ADDR
// break ;
106783: GO 106787
// end ;
106785: GO 106605
106787: POP
106788: POP
// end ;
106789: LD_VAR 0 4
106793: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
106794: LD_INT 0
106796: PPUSH
106797: PPUSH
106798: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
106799: LD_EXP 172
106803: NOT
106804: PUSH
106805: LD_EXP 170
106809: NOT
106810: OR
106811: PUSH
106812: LD_VAR 0 3
106816: PUSH
106817: LD_EXP 198
106821: IN
106822: NOT
106823: OR
106824: IFFALSE 106828
// exit ;
106826: GO 106951
// for i = 1 to mc_vehicles do
106828: LD_ADDR_VAR 0 6
106832: PUSH
106833: DOUBLE
106834: LD_INT 1
106836: DEC
106837: ST_TO_ADDR
106838: LD_EXP 191
106842: PUSH
106843: FOR_TO
106844: IFFALSE 106949
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
106846: LD_VAR 0 2
106850: PUSH
106851: LD_EXP 191
106855: PUSH
106856: LD_VAR 0 6
106860: ARRAY
106861: IN
106862: PUSH
106863: LD_VAR 0 1
106867: PUSH
106868: LD_EXP 191
106872: PUSH
106873: LD_VAR 0 6
106877: ARRAY
106878: IN
106879: OR
106880: IFFALSE 106947
// begin tmp := mc_vehicles [ i ] diff old ;
106882: LD_ADDR_VAR 0 7
106886: PUSH
106887: LD_EXP 191
106891: PUSH
106892: LD_VAR 0 6
106896: ARRAY
106897: PUSH
106898: LD_VAR 0 2
106902: DIFF
106903: ST_TO_ADDR
// tmp := tmp diff new ;
106904: LD_ADDR_VAR 0 7
106908: PUSH
106909: LD_VAR 0 7
106913: PUSH
106914: LD_VAR 0 1
106918: DIFF
106919: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
106920: LD_ADDR_EXP 191
106924: PUSH
106925: LD_EXP 191
106929: PPUSH
106930: LD_VAR 0 6
106934: PPUSH
106935: LD_VAR 0 7
106939: PPUSH
106940: CALL_OW 1
106944: ST_TO_ADDR
// break ;
106945: GO 106949
// end ;
106947: GO 106843
106949: POP
106950: POP
// end ;
106951: LD_VAR 0 5
106955: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
106956: LD_INT 0
106958: PPUSH
106959: PPUSH
106960: PPUSH
106961: PPUSH
// if not mc_bases or not skirmish then
106962: LD_EXP 172
106966: NOT
106967: PUSH
106968: LD_EXP 170
106972: NOT
106973: OR
106974: IFFALSE 106978
// exit ;
106976: GO 107361
// side := GetSide ( vehicle ) ;
106978: LD_ADDR_VAR 0 5
106982: PUSH
106983: LD_VAR 0 1
106987: PPUSH
106988: CALL_OW 255
106992: ST_TO_ADDR
// for i = 1 to mc_bases do
106993: LD_ADDR_VAR 0 4
106997: PUSH
106998: DOUBLE
106999: LD_INT 1
107001: DEC
107002: ST_TO_ADDR
107003: LD_EXP 172
107007: PUSH
107008: FOR_TO
107009: IFFALSE 107359
// begin if factory in mc_bases [ i ] then
107011: LD_VAR 0 2
107015: PUSH
107016: LD_EXP 172
107020: PUSH
107021: LD_VAR 0 4
107025: ARRAY
107026: IN
107027: IFFALSE 107357
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ar_crane , ru_siberium_rocket , us_siberium_rocket ] then
107029: LD_EXP 194
107033: PUSH
107034: LD_VAR 0 4
107038: ARRAY
107039: PUSH
107040: LD_EXP 183
107044: PUSH
107045: LD_VAR 0 4
107049: ARRAY
107050: LESS
107051: PUSH
107052: LD_VAR 0 1
107056: PPUSH
107057: CALL_OW 264
107061: PUSH
107062: LD_INT 31
107064: PUSH
107065: LD_INT 32
107067: PUSH
107068: LD_INT 51
107070: PUSH
107071: LD_EXP 155
107075: PUSH
107076: LD_INT 12
107078: PUSH
107079: LD_INT 30
107081: PUSH
107082: LD_EXP 154
107086: PUSH
107087: LD_INT 11
107089: PUSH
107090: LD_INT 53
107092: PUSH
107093: LD_INT 14
107095: PUSH
107096: LD_EXP 158
107100: PUSH
107101: LD_INT 29
107103: PUSH
107104: LD_EXP 156
107108: PUSH
107109: LD_INT 13
107111: PUSH
107112: LD_INT 52
107114: PUSH
107115: LD_EXP 160
107119: PUSH
107120: LD_INT 48
107122: PUSH
107123: LD_INT 8
107125: PUSH
107126: EMPTY
107127: LIST
107128: LIST
107129: LIST
107130: LIST
107131: LIST
107132: LIST
107133: LIST
107134: LIST
107135: LIST
107136: LIST
107137: LIST
107138: LIST
107139: LIST
107140: LIST
107141: LIST
107142: LIST
107143: LIST
107144: LIST
107145: IN
107146: NOT
107147: AND
107148: IFFALSE 107196
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
107150: LD_ADDR_EXP 194
107154: PUSH
107155: LD_EXP 194
107159: PPUSH
107160: LD_VAR 0 4
107164: PUSH
107165: LD_EXP 194
107169: PUSH
107170: LD_VAR 0 4
107174: ARRAY
107175: PUSH
107176: LD_INT 1
107178: PLUS
107179: PUSH
107180: EMPTY
107181: LIST
107182: LIST
107183: PPUSH
107184: LD_VAR 0 1
107188: PPUSH
107189: CALL 24096 0 3
107193: ST_TO_ADDR
107194: GO 107240
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
107196: LD_ADDR_EXP 191
107200: PUSH
107201: LD_EXP 191
107205: PPUSH
107206: LD_VAR 0 4
107210: PUSH
107211: LD_EXP 191
107215: PUSH
107216: LD_VAR 0 4
107220: ARRAY
107221: PUSH
107222: LD_INT 1
107224: PLUS
107225: PUSH
107226: EMPTY
107227: LIST
107228: LIST
107229: PPUSH
107230: LD_VAR 0 1
107234: PPUSH
107235: CALL 24096 0 3
107239: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
107240: LD_VAR 0 1
107244: PPUSH
107245: CALL_OW 263
107249: PUSH
107250: LD_INT 2
107252: EQUAL
107253: IFFALSE 107273
// begin repeat wait ( 0 0$1 ) ;
107255: LD_INT 35
107257: PPUSH
107258: CALL_OW 67
// until IsControledBy ( vehicle ) ;
107262: LD_VAR 0 1
107266: PPUSH
107267: CALL_OW 312
107271: IFFALSE 107255
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
107273: LD_VAR 0 1
107277: PPUSH
107278: LD_EXP 196
107282: PUSH
107283: LD_VAR 0 4
107287: ARRAY
107288: PPUSH
107289: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
107293: LD_VAR 0 1
107297: PPUSH
107298: CALL_OW 263
107302: PUSH
107303: LD_INT 1
107305: NONEQUAL
107306: IFFALSE 107310
// break ;
107308: GO 107359
// repeat wait ( 0 0$1 ) ;
107310: LD_INT 35
107312: PPUSH
107313: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
107317: LD_VAR 0 1
107321: PPUSH
107322: LD_EXP 196
107326: PUSH
107327: LD_VAR 0 4
107331: ARRAY
107332: PPUSH
107333: CALL_OW 308
107337: IFFALSE 107310
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
107339: LD_VAR 0 1
107343: PPUSH
107344: CALL_OW 311
107348: PPUSH
107349: CALL_OW 121
// exit ;
107353: POP
107354: POP
107355: GO 107361
// end ; end ;
107357: GO 107008
107359: POP
107360: POP
// end ;
107361: LD_VAR 0 3
107365: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
107366: LD_INT 0
107368: PPUSH
107369: PPUSH
107370: PPUSH
107371: PPUSH
// if not mc_bases or not skirmish then
107372: LD_EXP 172
107376: NOT
107377: PUSH
107378: LD_EXP 170
107382: NOT
107383: OR
107384: IFFALSE 107388
// exit ;
107386: GO 107741
// repeat wait ( 0 0$1 ) ;
107388: LD_INT 35
107390: PPUSH
107391: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
107395: LD_VAR 0 2
107399: PPUSH
107400: LD_VAR 0 3
107404: PPUSH
107405: CALL_OW 284
107409: IFFALSE 107388
// if GetResourceTypeXY ( x , y ) = mat_artefact then
107411: LD_VAR 0 2
107415: PPUSH
107416: LD_VAR 0 3
107420: PPUSH
107421: CALL_OW 283
107425: PUSH
107426: LD_INT 4
107428: EQUAL
107429: IFFALSE 107433
// exit ;
107431: GO 107741
// for i = 1 to mc_bases do
107433: LD_ADDR_VAR 0 7
107437: PUSH
107438: DOUBLE
107439: LD_INT 1
107441: DEC
107442: ST_TO_ADDR
107443: LD_EXP 172
107447: PUSH
107448: FOR_TO
107449: IFFALSE 107739
// begin if mc_crates_area [ i ] then
107451: LD_EXP 190
107455: PUSH
107456: LD_VAR 0 7
107460: ARRAY
107461: IFFALSE 107572
// for j in mc_crates_area [ i ] do
107463: LD_ADDR_VAR 0 8
107467: PUSH
107468: LD_EXP 190
107472: PUSH
107473: LD_VAR 0 7
107477: ARRAY
107478: PUSH
107479: FOR_IN
107480: IFFALSE 107570
// if InArea ( x , y , j ) then
107482: LD_VAR 0 2
107486: PPUSH
107487: LD_VAR 0 3
107491: PPUSH
107492: LD_VAR 0 8
107496: PPUSH
107497: CALL_OW 309
107501: IFFALSE 107568
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
107503: LD_ADDR_EXP 188
107507: PUSH
107508: LD_EXP 188
107512: PPUSH
107513: LD_VAR 0 7
107517: PUSH
107518: LD_EXP 188
107522: PUSH
107523: LD_VAR 0 7
107527: ARRAY
107528: PUSH
107529: LD_INT 1
107531: PLUS
107532: PUSH
107533: EMPTY
107534: LIST
107535: LIST
107536: PPUSH
107537: LD_VAR 0 4
107541: PUSH
107542: LD_VAR 0 2
107546: PUSH
107547: LD_VAR 0 3
107551: PUSH
107552: EMPTY
107553: LIST
107554: LIST
107555: LIST
107556: PPUSH
107557: CALL 24096 0 3
107561: ST_TO_ADDR
// exit ;
107562: POP
107563: POP
107564: POP
107565: POP
107566: GO 107741
// end ;
107568: GO 107479
107570: POP
107571: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
107572: LD_ADDR_VAR 0 9
107576: PUSH
107577: LD_EXP 172
107581: PUSH
107582: LD_VAR 0 7
107586: ARRAY
107587: PPUSH
107588: LD_INT 2
107590: PUSH
107591: LD_INT 30
107593: PUSH
107594: LD_INT 0
107596: PUSH
107597: EMPTY
107598: LIST
107599: LIST
107600: PUSH
107601: LD_INT 30
107603: PUSH
107604: LD_INT 1
107606: PUSH
107607: EMPTY
107608: LIST
107609: LIST
107610: PUSH
107611: EMPTY
107612: LIST
107613: LIST
107614: LIST
107615: PPUSH
107616: CALL_OW 72
107620: ST_TO_ADDR
// if not depot then
107621: LD_VAR 0 9
107625: NOT
107626: IFFALSE 107630
// continue ;
107628: GO 107448
// for j in depot do
107630: LD_ADDR_VAR 0 8
107634: PUSH
107635: LD_VAR 0 9
107639: PUSH
107640: FOR_IN
107641: IFFALSE 107735
// if GetDistUnitXY ( j , x , y ) < 30 then
107643: LD_VAR 0 8
107647: PPUSH
107648: LD_VAR 0 2
107652: PPUSH
107653: LD_VAR 0 3
107657: PPUSH
107658: CALL_OW 297
107662: PUSH
107663: LD_INT 30
107665: LESS
107666: IFFALSE 107733
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
107668: LD_ADDR_EXP 188
107672: PUSH
107673: LD_EXP 188
107677: PPUSH
107678: LD_VAR 0 7
107682: PUSH
107683: LD_EXP 188
107687: PUSH
107688: LD_VAR 0 7
107692: ARRAY
107693: PUSH
107694: LD_INT 1
107696: PLUS
107697: PUSH
107698: EMPTY
107699: LIST
107700: LIST
107701: PPUSH
107702: LD_VAR 0 4
107706: PUSH
107707: LD_VAR 0 2
107711: PUSH
107712: LD_VAR 0 3
107716: PUSH
107717: EMPTY
107718: LIST
107719: LIST
107720: LIST
107721: PPUSH
107722: CALL 24096 0 3
107726: ST_TO_ADDR
// exit ;
107727: POP
107728: POP
107729: POP
107730: POP
107731: GO 107741
// end ;
107733: GO 107640
107735: POP
107736: POP
// end ;
107737: GO 107448
107739: POP
107740: POP
// end ;
107741: LD_VAR 0 6
107745: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
107746: LD_INT 0
107748: PPUSH
107749: PPUSH
107750: PPUSH
107751: PPUSH
// if not mc_bases or not skirmish then
107752: LD_EXP 172
107756: NOT
107757: PUSH
107758: LD_EXP 170
107762: NOT
107763: OR
107764: IFFALSE 107768
// exit ;
107766: GO 108045
// side := GetSide ( lab ) ;
107768: LD_ADDR_VAR 0 4
107772: PUSH
107773: LD_VAR 0 2
107777: PPUSH
107778: CALL_OW 255
107782: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
107783: LD_VAR 0 4
107787: PUSH
107788: LD_EXP 198
107792: IN
107793: NOT
107794: PUSH
107795: LD_EXP 199
107799: NOT
107800: OR
107801: PUSH
107802: LD_EXP 172
107806: NOT
107807: OR
107808: IFFALSE 107812
// exit ;
107810: GO 108045
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
107812: LD_ADDR_EXP 199
107816: PUSH
107817: LD_EXP 199
107821: PPUSH
107822: LD_VAR 0 4
107826: PPUSH
107827: LD_EXP 199
107831: PUSH
107832: LD_VAR 0 4
107836: ARRAY
107837: PUSH
107838: LD_VAR 0 1
107842: DIFF
107843: PPUSH
107844: CALL_OW 1
107848: ST_TO_ADDR
// for i = 1 to mc_bases do
107849: LD_ADDR_VAR 0 5
107853: PUSH
107854: DOUBLE
107855: LD_INT 1
107857: DEC
107858: ST_TO_ADDR
107859: LD_EXP 172
107863: PUSH
107864: FOR_TO
107865: IFFALSE 108043
// begin if lab in mc_bases [ i ] then
107867: LD_VAR 0 2
107871: PUSH
107872: LD_EXP 172
107876: PUSH
107877: LD_VAR 0 5
107881: ARRAY
107882: IN
107883: IFFALSE 108041
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
107885: LD_VAR 0 1
107889: PUSH
107890: LD_INT 11
107892: PUSH
107893: LD_INT 4
107895: PUSH
107896: LD_INT 3
107898: PUSH
107899: LD_INT 2
107901: PUSH
107902: EMPTY
107903: LIST
107904: LIST
107905: LIST
107906: LIST
107907: IN
107908: PUSH
107909: LD_EXP 202
107913: PUSH
107914: LD_VAR 0 5
107918: ARRAY
107919: AND
107920: IFFALSE 108041
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
107922: LD_ADDR_VAR 0 6
107926: PUSH
107927: LD_EXP 202
107931: PUSH
107932: LD_VAR 0 5
107936: ARRAY
107937: PUSH
107938: LD_INT 1
107940: ARRAY
107941: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
107942: LD_ADDR_EXP 202
107946: PUSH
107947: LD_EXP 202
107951: PPUSH
107952: LD_VAR 0 5
107956: PPUSH
107957: EMPTY
107958: PPUSH
107959: CALL_OW 1
107963: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
107964: LD_VAR 0 6
107968: PPUSH
107969: LD_INT 0
107971: PPUSH
107972: CALL_OW 109
// ComExitBuilding ( tmp ) ;
107976: LD_VAR 0 6
107980: PPUSH
107981: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
107985: LD_ADDR_EXP 201
107989: PUSH
107990: LD_EXP 201
107994: PPUSH
107995: LD_VAR 0 5
107999: PPUSH
108000: LD_EXP 201
108004: PUSH
108005: LD_VAR 0 5
108009: ARRAY
108010: PPUSH
108011: LD_INT 1
108013: PPUSH
108014: LD_VAR 0 6
108018: PPUSH
108019: CALL_OW 2
108023: PPUSH
108024: CALL_OW 1
108028: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
108029: LD_VAR 0 5
108033: PPUSH
108034: LD_INT 112
108036: PPUSH
108037: CALL 84997 0 2
// end ; end ; end ;
108041: GO 107864
108043: POP
108044: POP
// end ;
108045: LD_VAR 0 3
108049: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
108050: LD_INT 0
108052: PPUSH
108053: PPUSH
108054: PPUSH
108055: PPUSH
108056: PPUSH
108057: PPUSH
108058: PPUSH
108059: PPUSH
// if not mc_bases or not skirmish then
108060: LD_EXP 172
108064: NOT
108065: PUSH
108066: LD_EXP 170
108070: NOT
108071: OR
108072: IFFALSE 108076
// exit ;
108074: GO 109447
// for i = 1 to mc_bases do
108076: LD_ADDR_VAR 0 3
108080: PUSH
108081: DOUBLE
108082: LD_INT 1
108084: DEC
108085: ST_TO_ADDR
108086: LD_EXP 172
108090: PUSH
108091: FOR_TO
108092: IFFALSE 109445
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
108094: LD_VAR 0 1
108098: PUSH
108099: LD_EXP 172
108103: PUSH
108104: LD_VAR 0 3
108108: ARRAY
108109: IN
108110: PUSH
108111: LD_VAR 0 1
108115: PUSH
108116: LD_EXP 179
108120: PUSH
108121: LD_VAR 0 3
108125: ARRAY
108126: IN
108127: OR
108128: PUSH
108129: LD_VAR 0 1
108133: PUSH
108134: LD_EXP 194
108138: PUSH
108139: LD_VAR 0 3
108143: ARRAY
108144: IN
108145: OR
108146: PUSH
108147: LD_VAR 0 1
108151: PUSH
108152: LD_EXP 191
108156: PUSH
108157: LD_VAR 0 3
108161: ARRAY
108162: IN
108163: OR
108164: PUSH
108165: LD_VAR 0 1
108169: PUSH
108170: LD_EXP 201
108174: PUSH
108175: LD_VAR 0 3
108179: ARRAY
108180: IN
108181: OR
108182: PUSH
108183: LD_VAR 0 1
108187: PUSH
108188: LD_EXP 202
108192: PUSH
108193: LD_VAR 0 3
108197: ARRAY
108198: IN
108199: OR
108200: IFFALSE 109443
// begin if un in mc_ape [ i ] then
108202: LD_VAR 0 1
108206: PUSH
108207: LD_EXP 201
108211: PUSH
108212: LD_VAR 0 3
108216: ARRAY
108217: IN
108218: IFFALSE 108257
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
108220: LD_ADDR_EXP 201
108224: PUSH
108225: LD_EXP 201
108229: PPUSH
108230: LD_VAR 0 3
108234: PPUSH
108235: LD_EXP 201
108239: PUSH
108240: LD_VAR 0 3
108244: ARRAY
108245: PUSH
108246: LD_VAR 0 1
108250: DIFF
108251: PPUSH
108252: CALL_OW 1
108256: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
108257: LD_VAR 0 1
108261: PUSH
108262: LD_EXP 202
108266: PUSH
108267: LD_VAR 0 3
108271: ARRAY
108272: IN
108273: IFFALSE 108297
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
108275: LD_ADDR_EXP 202
108279: PUSH
108280: LD_EXP 202
108284: PPUSH
108285: LD_VAR 0 3
108289: PPUSH
108290: EMPTY
108291: PPUSH
108292: CALL_OW 1
108296: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane , ar_control_tower ] ) then
108297: LD_VAR 0 1
108301: PPUSH
108302: CALL_OW 247
108306: PUSH
108307: LD_INT 2
108309: EQUAL
108310: PUSH
108311: LD_VAR 0 1
108315: PPUSH
108316: CALL_OW 110
108320: PUSH
108321: LD_INT 20
108323: EQUAL
108324: PUSH
108325: LD_VAR 0 1
108329: PUSH
108330: LD_EXP 194
108334: PUSH
108335: LD_VAR 0 3
108339: ARRAY
108340: IN
108341: OR
108342: PUSH
108343: LD_VAR 0 1
108347: PPUSH
108348: CALL_OW 264
108352: PUSH
108353: LD_INT 12
108355: PUSH
108356: LD_INT 51
108358: PUSH
108359: LD_EXP 155
108363: PUSH
108364: LD_INT 32
108366: PUSH
108367: LD_INT 13
108369: PUSH
108370: LD_INT 52
108372: PUSH
108373: LD_INT 31
108375: PUSH
108376: EMPTY
108377: LIST
108378: LIST
108379: LIST
108380: LIST
108381: LIST
108382: LIST
108383: LIST
108384: IN
108385: OR
108386: AND
108387: IFFALSE 108695
// begin if un in mc_defender [ i ] then
108389: LD_VAR 0 1
108393: PUSH
108394: LD_EXP 194
108398: PUSH
108399: LD_VAR 0 3
108403: ARRAY
108404: IN
108405: IFFALSE 108444
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
108407: LD_ADDR_EXP 194
108411: PUSH
108412: LD_EXP 194
108416: PPUSH
108417: LD_VAR 0 3
108421: PPUSH
108422: LD_EXP 194
108426: PUSH
108427: LD_VAR 0 3
108431: ARRAY
108432: PUSH
108433: LD_VAR 0 1
108437: DIFF
108438: PPUSH
108439: CALL_OW 1
108443: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
108444: LD_ADDR_VAR 0 8
108448: PUSH
108449: LD_VAR 0 3
108453: PPUSH
108454: LD_INT 3
108456: PPUSH
108457: CALL 105094 0 2
108461: ST_TO_ADDR
// if fac then
108462: LD_VAR 0 8
108466: IFFALSE 108695
// begin for j in fac do
108468: LD_ADDR_VAR 0 4
108472: PUSH
108473: LD_VAR 0 8
108477: PUSH
108478: FOR_IN
108479: IFFALSE 108693
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
108481: LD_ADDR_VAR 0 9
108485: PUSH
108486: LD_VAR 0 8
108490: PPUSH
108491: LD_VAR 0 1
108495: PPUSH
108496: CALL_OW 265
108500: PPUSH
108501: LD_VAR 0 1
108505: PPUSH
108506: CALL_OW 262
108510: PPUSH
108511: LD_VAR 0 1
108515: PPUSH
108516: CALL_OW 263
108520: PPUSH
108521: LD_VAR 0 1
108525: PPUSH
108526: CALL_OW 264
108530: PPUSH
108531: CALL 21628 0 5
108535: ST_TO_ADDR
// if components then
108536: LD_VAR 0 9
108540: IFFALSE 108691
// begin if GetWeapon ( un ) = ar_control_tower then
108542: LD_VAR 0 1
108546: PPUSH
108547: CALL_OW 264
108551: PUSH
108552: LD_INT 31
108554: EQUAL
108555: IFFALSE 108672
// begin SetTag ( IsDrivenBy ( un ) , 0 ) ;
108557: LD_VAR 0 1
108561: PPUSH
108562: CALL_OW 311
108566: PPUSH
108567: LD_INT 0
108569: PPUSH
108570: CALL_OW 109
// mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff IsDrivenBy ( un ) ) ;
108574: LD_ADDR_EXP 212
108578: PUSH
108579: LD_EXP 212
108583: PPUSH
108584: LD_VAR 0 3
108588: PPUSH
108589: LD_EXP 212
108593: PUSH
108594: LD_VAR 0 3
108598: ARRAY
108599: PUSH
108600: LD_VAR 0 1
108604: PPUSH
108605: CALL_OW 311
108609: DIFF
108610: PPUSH
108611: CALL_OW 1
108615: ST_TO_ADDR
// tmp := Insert ( mc_produce [ i ] , 1 , components ) ;
108616: LD_ADDR_VAR 0 7
108620: PUSH
108621: LD_EXP 193
108625: PUSH
108626: LD_VAR 0 3
108630: ARRAY
108631: PPUSH
108632: LD_INT 1
108634: PPUSH
108635: LD_VAR 0 9
108639: PPUSH
108640: CALL_OW 2
108644: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
108645: LD_ADDR_EXP 193
108649: PUSH
108650: LD_EXP 193
108654: PPUSH
108655: LD_VAR 0 3
108659: PPUSH
108660: LD_VAR 0 7
108664: PPUSH
108665: CALL_OW 1
108669: ST_TO_ADDR
// end else
108670: GO 108689
// MC_InsertProduceList ( i , [ components ] ) ;
108672: LD_VAR 0 3
108676: PPUSH
108677: LD_VAR 0 9
108681: PUSH
108682: EMPTY
108683: LIST
108684: PPUSH
108685: CALL 104639 0 2
// break ;
108689: GO 108693
// end ; end ;
108691: GO 108478
108693: POP
108694: POP
// end ; end ; if GetType ( un ) = unit_building then
108695: LD_VAR 0 1
108699: PPUSH
108700: CALL_OW 247
108704: PUSH
108705: LD_INT 3
108707: EQUAL
108708: IFFALSE 109111
// begin btype := GetBType ( un ) ;
108710: LD_ADDR_VAR 0 5
108714: PUSH
108715: LD_VAR 0 1
108719: PPUSH
108720: CALL_OW 266
108724: ST_TO_ADDR
// if btype in [ b_oil_mine , b_siberite_mine ] then
108725: LD_VAR 0 5
108729: PUSH
108730: LD_INT 29
108732: PUSH
108733: LD_INT 30
108735: PUSH
108736: EMPTY
108737: LIST
108738: LIST
108739: IN
108740: IFFALSE 108813
// begin if not GetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) then
108742: LD_VAR 0 1
108746: PPUSH
108747: CALL_OW 250
108751: PPUSH
108752: LD_VAR 0 1
108756: PPUSH
108757: CALL_OW 251
108761: PPUSH
108762: LD_VAR 0 1
108766: PPUSH
108767: CALL_OW 255
108771: PPUSH
108772: CALL_OW 440
108776: NOT
108777: IFFALSE 108813
// SetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) ;
108779: LD_VAR 0 1
108783: PPUSH
108784: CALL_OW 250
108788: PPUSH
108789: LD_VAR 0 1
108793: PPUSH
108794: CALL_OW 251
108798: PPUSH
108799: LD_VAR 0 1
108803: PPUSH
108804: CALL_OW 255
108808: PPUSH
108809: CALL_OW 441
// end ; if btype = b_warehouse then
108813: LD_VAR 0 5
108817: PUSH
108818: LD_INT 1
108820: EQUAL
108821: IFFALSE 108839
// begin btype := b_depot ;
108823: LD_ADDR_VAR 0 5
108827: PUSH
108828: LD_INT 0
108830: ST_TO_ADDR
// pos := 1 ;
108831: LD_ADDR_VAR 0 6
108835: PUSH
108836: LD_INT 1
108838: ST_TO_ADDR
// end ; if btype = b_factory then
108839: LD_VAR 0 5
108843: PUSH
108844: LD_INT 3
108846: EQUAL
108847: IFFALSE 108865
// begin btype := b_workshop ;
108849: LD_ADDR_VAR 0 5
108853: PUSH
108854: LD_INT 2
108856: ST_TO_ADDR
// pos := 1 ;
108857: LD_ADDR_VAR 0 6
108861: PUSH
108862: LD_INT 1
108864: ST_TO_ADDR
// end ; if btype = b_barracks then
108865: LD_VAR 0 5
108869: PUSH
108870: LD_INT 5
108872: EQUAL
108873: IFFALSE 108883
// btype := b_armoury ;
108875: LD_ADDR_VAR 0 5
108879: PUSH
108880: LD_INT 4
108882: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
108883: LD_VAR 0 5
108887: PUSH
108888: LD_INT 7
108890: PUSH
108891: LD_INT 8
108893: PUSH
108894: EMPTY
108895: LIST
108896: LIST
108897: IN
108898: IFFALSE 108908
// btype := b_lab ;
108900: LD_ADDR_VAR 0 5
108904: PUSH
108905: LD_INT 6
108907: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
108908: LD_ADDR_EXP 177
108912: PUSH
108913: LD_EXP 177
108917: PPUSH
108918: LD_VAR 0 3
108922: PUSH
108923: LD_EXP 177
108927: PUSH
108928: LD_VAR 0 3
108932: ARRAY
108933: PUSH
108934: LD_INT 1
108936: PLUS
108937: PUSH
108938: EMPTY
108939: LIST
108940: LIST
108941: PPUSH
108942: LD_VAR 0 5
108946: PUSH
108947: LD_VAR 0 1
108951: PPUSH
108952: CALL_OW 250
108956: PUSH
108957: LD_VAR 0 1
108961: PPUSH
108962: CALL_OW 251
108966: PUSH
108967: LD_VAR 0 1
108971: PPUSH
108972: CALL_OW 254
108976: PUSH
108977: EMPTY
108978: LIST
108979: LIST
108980: LIST
108981: LIST
108982: PPUSH
108983: CALL 24096 0 3
108987: ST_TO_ADDR
// if pos = 1 then
108988: LD_VAR 0 6
108992: PUSH
108993: LD_INT 1
108995: EQUAL
108996: IFFALSE 109111
// begin tmp := mc_build_list [ i ] ;
108998: LD_ADDR_VAR 0 7
109002: PUSH
109003: LD_EXP 177
109007: PUSH
109008: LD_VAR 0 3
109012: ARRAY
109013: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
109014: LD_VAR 0 7
109018: PPUSH
109019: LD_INT 2
109021: PUSH
109022: LD_INT 30
109024: PUSH
109025: LD_INT 0
109027: PUSH
109028: EMPTY
109029: LIST
109030: LIST
109031: PUSH
109032: LD_INT 30
109034: PUSH
109035: LD_INT 1
109037: PUSH
109038: EMPTY
109039: LIST
109040: LIST
109041: PUSH
109042: EMPTY
109043: LIST
109044: LIST
109045: LIST
109046: PPUSH
109047: CALL_OW 72
109051: IFFALSE 109061
// pos := 2 ;
109053: LD_ADDR_VAR 0 6
109057: PUSH
109058: LD_INT 2
109060: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
109061: LD_ADDR_VAR 0 7
109065: PUSH
109066: LD_VAR 0 7
109070: PPUSH
109071: LD_VAR 0 6
109075: PPUSH
109076: LD_VAR 0 7
109080: PPUSH
109081: CALL 24422 0 3
109085: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
109086: LD_ADDR_EXP 177
109090: PUSH
109091: LD_EXP 177
109095: PPUSH
109096: LD_VAR 0 3
109100: PPUSH
109101: LD_VAR 0 7
109105: PPUSH
109106: CALL_OW 1
109110: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
109111: LD_VAR 0 1
109115: PUSH
109116: LD_EXP 172
109120: PUSH
109121: LD_VAR 0 3
109125: ARRAY
109126: IN
109127: IFFALSE 109166
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
109129: LD_ADDR_EXP 172
109133: PUSH
109134: LD_EXP 172
109138: PPUSH
109139: LD_VAR 0 3
109143: PPUSH
109144: LD_EXP 172
109148: PUSH
109149: LD_VAR 0 3
109153: ARRAY
109154: PUSH
109155: LD_VAR 0 1
109159: DIFF
109160: PPUSH
109161: CALL_OW 1
109165: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
109166: LD_VAR 0 1
109170: PUSH
109171: LD_EXP 179
109175: PUSH
109176: LD_VAR 0 3
109180: ARRAY
109181: IN
109182: IFFALSE 109221
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
109184: LD_ADDR_EXP 179
109188: PUSH
109189: LD_EXP 179
109193: PPUSH
109194: LD_VAR 0 3
109198: PPUSH
109199: LD_EXP 179
109203: PUSH
109204: LD_VAR 0 3
109208: ARRAY
109209: PUSH
109210: LD_VAR 0 1
109214: DIFF
109215: PPUSH
109216: CALL_OW 1
109220: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
109221: LD_VAR 0 1
109225: PUSH
109226: LD_EXP 191
109230: PUSH
109231: LD_VAR 0 3
109235: ARRAY
109236: IN
109237: IFFALSE 109276
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
109239: LD_ADDR_EXP 191
109243: PUSH
109244: LD_EXP 191
109248: PPUSH
109249: LD_VAR 0 3
109253: PPUSH
109254: LD_EXP 191
109258: PUSH
109259: LD_VAR 0 3
109263: ARRAY
109264: PUSH
109265: LD_VAR 0 1
109269: DIFF
109270: PPUSH
109271: CALL_OW 1
109275: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
109276: LD_VAR 0 1
109280: PUSH
109281: LD_EXP 194
109285: PUSH
109286: LD_VAR 0 3
109290: ARRAY
109291: IN
109292: IFFALSE 109331
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
109294: LD_ADDR_EXP 194
109298: PUSH
109299: LD_EXP 194
109303: PPUSH
109304: LD_VAR 0 3
109308: PPUSH
109309: LD_EXP 194
109313: PUSH
109314: LD_VAR 0 3
109318: ARRAY
109319: PUSH
109320: LD_VAR 0 1
109324: DIFF
109325: PPUSH
109326: CALL_OW 1
109330: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
109331: LD_VAR 0 1
109335: PUSH
109336: LD_EXP 181
109340: PUSH
109341: LD_VAR 0 3
109345: ARRAY
109346: IN
109347: IFFALSE 109386
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
109349: LD_ADDR_EXP 181
109353: PUSH
109354: LD_EXP 181
109358: PPUSH
109359: LD_VAR 0 3
109363: PPUSH
109364: LD_EXP 181
109368: PUSH
109369: LD_VAR 0 3
109373: ARRAY
109374: PUSH
109375: LD_VAR 0 1
109379: DIFF
109380: PPUSH
109381: CALL_OW 1
109385: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
109386: LD_VAR 0 1
109390: PUSH
109391: LD_EXP 180
109395: PUSH
109396: LD_VAR 0 3
109400: ARRAY
109401: IN
109402: IFFALSE 109441
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
109404: LD_ADDR_EXP 180
109408: PUSH
109409: LD_EXP 180
109413: PPUSH
109414: LD_VAR 0 3
109418: PPUSH
109419: LD_EXP 180
109423: PUSH
109424: LD_VAR 0 3
109428: ARRAY
109429: PUSH
109430: LD_VAR 0 1
109434: DIFF
109435: PPUSH
109436: CALL_OW 1
109440: ST_TO_ADDR
// end ; break ;
109441: GO 109445
// end ;
109443: GO 108091
109445: POP
109446: POP
// end ;
109447: LD_VAR 0 2
109451: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
109452: LD_INT 0
109454: PPUSH
109455: PPUSH
109456: PPUSH
// if not mc_bases or not skirmish then
109457: LD_EXP 172
109461: NOT
109462: PUSH
109463: LD_EXP 170
109467: NOT
109468: OR
109469: IFFALSE 109473
// exit ;
109471: GO 109688
// for i = 1 to mc_bases do
109473: LD_ADDR_VAR 0 3
109477: PUSH
109478: DOUBLE
109479: LD_INT 1
109481: DEC
109482: ST_TO_ADDR
109483: LD_EXP 172
109487: PUSH
109488: FOR_TO
109489: IFFALSE 109686
// begin if building in mc_construct_list [ i ] then
109491: LD_VAR 0 1
109495: PUSH
109496: LD_EXP 179
109500: PUSH
109501: LD_VAR 0 3
109505: ARRAY
109506: IN
109507: IFFALSE 109684
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
109509: LD_ADDR_EXP 179
109513: PUSH
109514: LD_EXP 179
109518: PPUSH
109519: LD_VAR 0 3
109523: PPUSH
109524: LD_EXP 179
109528: PUSH
109529: LD_VAR 0 3
109533: ARRAY
109534: PUSH
109535: LD_VAR 0 1
109539: DIFF
109540: PPUSH
109541: CALL_OW 1
109545: ST_TO_ADDR
// if building in mc_lab [ i ] then
109546: LD_VAR 0 1
109550: PUSH
109551: LD_EXP 205
109555: PUSH
109556: LD_VAR 0 3
109560: ARRAY
109561: IN
109562: IFFALSE 109617
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
109564: LD_ADDR_EXP 206
109568: PUSH
109569: LD_EXP 206
109573: PPUSH
109574: LD_VAR 0 3
109578: PPUSH
109579: LD_EXP 206
109583: PUSH
109584: LD_VAR 0 3
109588: ARRAY
109589: PPUSH
109590: LD_INT 1
109592: PPUSH
109593: LD_EXP 206
109597: PUSH
109598: LD_VAR 0 3
109602: ARRAY
109603: PPUSH
109604: LD_INT 0
109606: PPUSH
109607: CALL 23514 0 4
109611: PPUSH
109612: CALL_OW 1
109616: ST_TO_ADDR
// if not building in mc_bases [ i ] then
109617: LD_VAR 0 1
109621: PUSH
109622: LD_EXP 172
109626: PUSH
109627: LD_VAR 0 3
109631: ARRAY
109632: IN
109633: NOT
109634: IFFALSE 109680
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
109636: LD_ADDR_EXP 172
109640: PUSH
109641: LD_EXP 172
109645: PPUSH
109646: LD_VAR 0 3
109650: PUSH
109651: LD_EXP 172
109655: PUSH
109656: LD_VAR 0 3
109660: ARRAY
109661: PUSH
109662: LD_INT 1
109664: PLUS
109665: PUSH
109666: EMPTY
109667: LIST
109668: LIST
109669: PPUSH
109670: LD_VAR 0 1
109674: PPUSH
109675: CALL 24096 0 3
109679: ST_TO_ADDR
// exit ;
109680: POP
109681: POP
109682: GO 109688
// end ; end ;
109684: GO 109488
109686: POP
109687: POP
// end ;
109688: LD_VAR 0 2
109692: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
109693: LD_INT 0
109695: PPUSH
109696: PPUSH
109697: PPUSH
109698: PPUSH
109699: PPUSH
109700: PPUSH
109701: PPUSH
// if not mc_bases or not skirmish then
109702: LD_EXP 172
109706: NOT
109707: PUSH
109708: LD_EXP 170
109712: NOT
109713: OR
109714: IFFALSE 109718
// exit ;
109716: GO 110379
// for i = 1 to mc_bases do
109718: LD_ADDR_VAR 0 3
109722: PUSH
109723: DOUBLE
109724: LD_INT 1
109726: DEC
109727: ST_TO_ADDR
109728: LD_EXP 172
109732: PUSH
109733: FOR_TO
109734: IFFALSE 110377
// begin if building in mc_construct_list [ i ] then
109736: LD_VAR 0 1
109740: PUSH
109741: LD_EXP 179
109745: PUSH
109746: LD_VAR 0 3
109750: ARRAY
109751: IN
109752: IFFALSE 110375
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
109754: LD_ADDR_EXP 179
109758: PUSH
109759: LD_EXP 179
109763: PPUSH
109764: LD_VAR 0 3
109768: PPUSH
109769: LD_EXP 179
109773: PUSH
109774: LD_VAR 0 3
109778: ARRAY
109779: PUSH
109780: LD_VAR 0 1
109784: DIFF
109785: PPUSH
109786: CALL_OW 1
109790: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
109791: LD_ADDR_EXP 172
109795: PUSH
109796: LD_EXP 172
109800: PPUSH
109801: LD_VAR 0 3
109805: PUSH
109806: LD_EXP 172
109810: PUSH
109811: LD_VAR 0 3
109815: ARRAY
109816: PUSH
109817: LD_INT 1
109819: PLUS
109820: PUSH
109821: EMPTY
109822: LIST
109823: LIST
109824: PPUSH
109825: LD_VAR 0 1
109829: PPUSH
109830: CALL 24096 0 3
109834: ST_TO_ADDR
// btype := GetBType ( building ) ;
109835: LD_ADDR_VAR 0 5
109839: PUSH
109840: LD_VAR 0 1
109844: PPUSH
109845: CALL_OW 266
109849: ST_TO_ADDR
// side := GetSide ( building ) ;
109850: LD_ADDR_VAR 0 8
109854: PUSH
109855: LD_VAR 0 1
109859: PPUSH
109860: CALL_OW 255
109864: ST_TO_ADDR
// if btype = b_lab then
109865: LD_VAR 0 5
109869: PUSH
109870: LD_INT 6
109872: EQUAL
109873: IFFALSE 109923
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
109875: LD_ADDR_EXP 205
109879: PUSH
109880: LD_EXP 205
109884: PPUSH
109885: LD_VAR 0 3
109889: PUSH
109890: LD_EXP 205
109894: PUSH
109895: LD_VAR 0 3
109899: ARRAY
109900: PUSH
109901: LD_INT 1
109903: PLUS
109904: PUSH
109905: EMPTY
109906: LIST
109907: LIST
109908: PPUSH
109909: LD_VAR 0 1
109913: PPUSH
109914: CALL 24096 0 3
109918: ST_TO_ADDR
// exit ;
109919: POP
109920: POP
109921: GO 110379
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
109923: LD_VAR 0 5
109927: PUSH
109928: LD_INT 0
109930: PUSH
109931: LD_INT 2
109933: PUSH
109934: LD_INT 4
109936: PUSH
109937: EMPTY
109938: LIST
109939: LIST
109940: LIST
109941: IN
109942: IFFALSE 110066
// begin if btype = b_armoury then
109944: LD_VAR 0 5
109948: PUSH
109949: LD_INT 4
109951: EQUAL
109952: IFFALSE 109962
// btype := b_barracks ;
109954: LD_ADDR_VAR 0 5
109958: PUSH
109959: LD_INT 5
109961: ST_TO_ADDR
// if btype = b_depot then
109962: LD_VAR 0 5
109966: PUSH
109967: LD_INT 0
109969: EQUAL
109970: IFFALSE 109980
// btype := b_warehouse ;
109972: LD_ADDR_VAR 0 5
109976: PUSH
109977: LD_INT 1
109979: ST_TO_ADDR
// if btype = b_workshop then
109980: LD_VAR 0 5
109984: PUSH
109985: LD_INT 2
109987: EQUAL
109988: IFFALSE 109998
// btype := b_factory ;
109990: LD_ADDR_VAR 0 5
109994: PUSH
109995: LD_INT 3
109997: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
109998: LD_VAR 0 5
110002: PPUSH
110003: LD_VAR 0 8
110007: PPUSH
110008: CALL_OW 323
110012: PUSH
110013: LD_INT 1
110015: EQUAL
110016: IFFALSE 110062
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
110018: LD_ADDR_EXP 204
110022: PUSH
110023: LD_EXP 204
110027: PPUSH
110028: LD_VAR 0 3
110032: PUSH
110033: LD_EXP 204
110037: PUSH
110038: LD_VAR 0 3
110042: ARRAY
110043: PUSH
110044: LD_INT 1
110046: PLUS
110047: PUSH
110048: EMPTY
110049: LIST
110050: LIST
110051: PPUSH
110052: LD_VAR 0 1
110056: PPUSH
110057: CALL 24096 0 3
110061: ST_TO_ADDR
// exit ;
110062: POP
110063: POP
110064: GO 110379
// end ; if btype in [ b_bunker , b_turret ] then
110066: LD_VAR 0 5
110070: PUSH
110071: LD_INT 32
110073: PUSH
110074: LD_INT 33
110076: PUSH
110077: EMPTY
110078: LIST
110079: LIST
110080: IN
110081: IFFALSE 110371
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
110083: LD_ADDR_EXP 180
110087: PUSH
110088: LD_EXP 180
110092: PPUSH
110093: LD_VAR 0 3
110097: PUSH
110098: LD_EXP 180
110102: PUSH
110103: LD_VAR 0 3
110107: ARRAY
110108: PUSH
110109: LD_INT 1
110111: PLUS
110112: PUSH
110113: EMPTY
110114: LIST
110115: LIST
110116: PPUSH
110117: LD_VAR 0 1
110121: PPUSH
110122: CALL 24096 0 3
110126: ST_TO_ADDR
// if btype = b_bunker then
110127: LD_VAR 0 5
110131: PUSH
110132: LD_INT 32
110134: EQUAL
110135: IFFALSE 110371
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
110137: LD_ADDR_EXP 181
110141: PUSH
110142: LD_EXP 181
110146: PPUSH
110147: LD_VAR 0 3
110151: PUSH
110152: LD_EXP 181
110156: PUSH
110157: LD_VAR 0 3
110161: ARRAY
110162: PUSH
110163: LD_INT 1
110165: PLUS
110166: PUSH
110167: EMPTY
110168: LIST
110169: LIST
110170: PPUSH
110171: LD_VAR 0 1
110175: PPUSH
110176: CALL 24096 0 3
110180: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
110181: LD_ADDR_VAR 0 6
110185: PUSH
110186: LD_EXP 172
110190: PUSH
110191: LD_VAR 0 3
110195: ARRAY
110196: PPUSH
110197: LD_INT 25
110199: PUSH
110200: LD_INT 1
110202: PUSH
110203: EMPTY
110204: LIST
110205: LIST
110206: PUSH
110207: LD_INT 3
110209: PUSH
110210: LD_INT 54
110212: PUSH
110213: EMPTY
110214: LIST
110215: PUSH
110216: EMPTY
110217: LIST
110218: LIST
110219: PUSH
110220: EMPTY
110221: LIST
110222: LIST
110223: PPUSH
110224: CALL_OW 72
110228: ST_TO_ADDR
// if tmp then
110229: LD_VAR 0 6
110233: IFFALSE 110239
// exit ;
110235: POP
110236: POP
110237: GO 110379
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
110239: LD_ADDR_VAR 0 6
110243: PUSH
110244: LD_EXP 172
110248: PUSH
110249: LD_VAR 0 3
110253: ARRAY
110254: PPUSH
110255: LD_INT 2
110257: PUSH
110258: LD_INT 30
110260: PUSH
110261: LD_INT 4
110263: PUSH
110264: EMPTY
110265: LIST
110266: LIST
110267: PUSH
110268: LD_INT 30
110270: PUSH
110271: LD_INT 5
110273: PUSH
110274: EMPTY
110275: LIST
110276: LIST
110277: PUSH
110278: EMPTY
110279: LIST
110280: LIST
110281: LIST
110282: PPUSH
110283: CALL_OW 72
110287: ST_TO_ADDR
// if not tmp then
110288: LD_VAR 0 6
110292: NOT
110293: IFFALSE 110299
// exit ;
110295: POP
110296: POP
110297: GO 110379
// for j in tmp do
110299: LD_ADDR_VAR 0 4
110303: PUSH
110304: LD_VAR 0 6
110308: PUSH
110309: FOR_IN
110310: IFFALSE 110369
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
110312: LD_ADDR_VAR 0 7
110316: PUSH
110317: LD_VAR 0 4
110321: PPUSH
110322: CALL_OW 313
110326: PPUSH
110327: LD_INT 25
110329: PUSH
110330: LD_INT 1
110332: PUSH
110333: EMPTY
110334: LIST
110335: LIST
110336: PPUSH
110337: CALL_OW 72
110341: ST_TO_ADDR
// if units then
110342: LD_VAR 0 7
110346: IFFALSE 110367
// begin ComExitBuilding ( units [ 1 ] ) ;
110348: LD_VAR 0 7
110352: PUSH
110353: LD_INT 1
110355: ARRAY
110356: PPUSH
110357: CALL_OW 122
// exit ;
110361: POP
110362: POP
110363: POP
110364: POP
110365: GO 110379
// end ; end ;
110367: GO 110309
110369: POP
110370: POP
// end ; end ; exit ;
110371: POP
110372: POP
110373: GO 110379
// end ; end ;
110375: GO 109733
110377: POP
110378: POP
// end ;
110379: LD_VAR 0 2
110383: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
110384: LD_INT 0
110386: PPUSH
110387: PPUSH
110388: PPUSH
110389: PPUSH
110390: PPUSH
110391: PPUSH
110392: PPUSH
// if not mc_bases or not skirmish then
110393: LD_EXP 172
110397: NOT
110398: PUSH
110399: LD_EXP 170
110403: NOT
110404: OR
110405: IFFALSE 110409
// exit ;
110407: GO 110640
// btype := GetBType ( building ) ;
110409: LD_ADDR_VAR 0 6
110413: PUSH
110414: LD_VAR 0 1
110418: PPUSH
110419: CALL_OW 266
110423: ST_TO_ADDR
// x := GetX ( building ) ;
110424: LD_ADDR_VAR 0 7
110428: PUSH
110429: LD_VAR 0 1
110433: PPUSH
110434: CALL_OW 250
110438: ST_TO_ADDR
// y := GetY ( building ) ;
110439: LD_ADDR_VAR 0 8
110443: PUSH
110444: LD_VAR 0 1
110448: PPUSH
110449: CALL_OW 251
110453: ST_TO_ADDR
// d := GetDir ( building ) ;
110454: LD_ADDR_VAR 0 9
110458: PUSH
110459: LD_VAR 0 1
110463: PPUSH
110464: CALL_OW 254
110468: ST_TO_ADDR
// for i = 1 to mc_bases do
110469: LD_ADDR_VAR 0 4
110473: PUSH
110474: DOUBLE
110475: LD_INT 1
110477: DEC
110478: ST_TO_ADDR
110479: LD_EXP 172
110483: PUSH
110484: FOR_TO
110485: IFFALSE 110638
// begin if not mc_build_list [ i ] then
110487: LD_EXP 177
110491: PUSH
110492: LD_VAR 0 4
110496: ARRAY
110497: NOT
110498: IFFALSE 110502
// continue ;
110500: GO 110484
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ 1 ] ) then
110502: LD_VAR 0 6
110506: PUSH
110507: LD_VAR 0 7
110511: PUSH
110512: LD_VAR 0 8
110516: PUSH
110517: LD_VAR 0 9
110521: PUSH
110522: EMPTY
110523: LIST
110524: LIST
110525: LIST
110526: LIST
110527: PPUSH
110528: LD_EXP 177
110532: PUSH
110533: LD_VAR 0 4
110537: ARRAY
110538: PUSH
110539: LD_INT 1
110541: ARRAY
110542: PPUSH
110543: CALL 30265 0 2
110547: IFFALSE 110636
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , 1 ) ) ;
110549: LD_ADDR_EXP 177
110553: PUSH
110554: LD_EXP 177
110558: PPUSH
110559: LD_VAR 0 4
110563: PPUSH
110564: LD_EXP 177
110568: PUSH
110569: LD_VAR 0 4
110573: ARRAY
110574: PPUSH
110575: LD_INT 1
110577: PPUSH
110578: CALL_OW 3
110582: PPUSH
110583: CALL_OW 1
110587: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
110588: LD_ADDR_EXP 179
110592: PUSH
110593: LD_EXP 179
110597: PPUSH
110598: LD_VAR 0 4
110602: PUSH
110603: LD_EXP 179
110607: PUSH
110608: LD_VAR 0 4
110612: ARRAY
110613: PUSH
110614: LD_INT 1
110616: PLUS
110617: PUSH
110618: EMPTY
110619: LIST
110620: LIST
110621: PPUSH
110622: LD_VAR 0 1
110626: PPUSH
110627: CALL 24096 0 3
110631: ST_TO_ADDR
// exit ;
110632: POP
110633: POP
110634: GO 110640
// end ; end ;
110636: GO 110484
110638: POP
110639: POP
// end ;
110640: LD_VAR 0 3
110644: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
110645: LD_INT 0
110647: PPUSH
110648: PPUSH
110649: PPUSH
// if not mc_bases or not skirmish then
110650: LD_EXP 172
110654: NOT
110655: PUSH
110656: LD_EXP 170
110660: NOT
110661: OR
110662: IFFALSE 110666
// exit ;
110664: GO 110856
// for i = 1 to mc_bases do
110666: LD_ADDR_VAR 0 4
110670: PUSH
110671: DOUBLE
110672: LD_INT 1
110674: DEC
110675: ST_TO_ADDR
110676: LD_EXP 172
110680: PUSH
110681: FOR_TO
110682: IFFALSE 110769
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
110684: LD_VAR 0 1
110688: PUSH
110689: LD_EXP 180
110693: PUSH
110694: LD_VAR 0 4
110698: ARRAY
110699: IN
110700: PUSH
110701: LD_VAR 0 1
110705: PUSH
110706: LD_EXP 181
110710: PUSH
110711: LD_VAR 0 4
110715: ARRAY
110716: IN
110717: NOT
110718: AND
110719: IFFALSE 110767
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
110721: LD_ADDR_EXP 181
110725: PUSH
110726: LD_EXP 181
110730: PPUSH
110731: LD_VAR 0 4
110735: PUSH
110736: LD_EXP 181
110740: PUSH
110741: LD_VAR 0 4
110745: ARRAY
110746: PUSH
110747: LD_INT 1
110749: PLUS
110750: PUSH
110751: EMPTY
110752: LIST
110753: LIST
110754: PPUSH
110755: LD_VAR 0 1
110759: PPUSH
110760: CALL 24096 0 3
110764: ST_TO_ADDR
// break ;
110765: GO 110769
// end ; end ;
110767: GO 110681
110769: POP
110770: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
110771: LD_VAR 0 1
110775: PPUSH
110776: CALL_OW 257
110780: PUSH
110781: LD_EXP 198
110785: IN
110786: PUSH
110787: LD_VAR 0 1
110791: PPUSH
110792: CALL_OW 266
110796: PUSH
110797: LD_INT 5
110799: EQUAL
110800: AND
110801: PUSH
110802: LD_VAR 0 2
110806: PPUSH
110807: CALL_OW 110
110811: PUSH
110812: LD_INT 18
110814: NONEQUAL
110815: AND
110816: IFFALSE 110856
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
110818: LD_VAR 0 2
110822: PPUSH
110823: CALL_OW 257
110827: PUSH
110828: LD_INT 5
110830: PUSH
110831: LD_INT 8
110833: PUSH
110834: LD_INT 9
110836: PUSH
110837: EMPTY
110838: LIST
110839: LIST
110840: LIST
110841: IN
110842: IFFALSE 110856
// SetClass ( unit , 1 ) ;
110844: LD_VAR 0 2
110848: PPUSH
110849: LD_INT 1
110851: PPUSH
110852: CALL_OW 336
// end ;
110856: LD_VAR 0 3
110860: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
110861: LD_INT 0
110863: PPUSH
110864: PPUSH
// if not mc_bases or not skirmish then
110865: LD_EXP 172
110869: NOT
110870: PUSH
110871: LD_EXP 170
110875: NOT
110876: OR
110877: IFFALSE 110881
// exit ;
110879: GO 110997
// if GetLives ( abandoned_vehicle ) > 250 then
110881: LD_VAR 0 2
110885: PPUSH
110886: CALL_OW 256
110890: PUSH
110891: LD_INT 250
110893: GREATER
110894: IFFALSE 110898
// exit ;
110896: GO 110997
// for i = 1 to mc_bases do
110898: LD_ADDR_VAR 0 6
110902: PUSH
110903: DOUBLE
110904: LD_INT 1
110906: DEC
110907: ST_TO_ADDR
110908: LD_EXP 172
110912: PUSH
110913: FOR_TO
110914: IFFALSE 110995
// begin if driver in mc_bases [ i ] then
110916: LD_VAR 0 1
110920: PUSH
110921: LD_EXP 172
110925: PUSH
110926: LD_VAR 0 6
110930: ARRAY
110931: IN
110932: IFFALSE 110993
// begin ComMoveToNearbyEntrance ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
110934: LD_VAR 0 1
110938: PPUSH
110939: LD_EXP 172
110943: PUSH
110944: LD_VAR 0 6
110948: ARRAY
110949: PPUSH
110950: LD_INT 2
110952: PUSH
110953: LD_INT 30
110955: PUSH
110956: LD_INT 0
110958: PUSH
110959: EMPTY
110960: LIST
110961: LIST
110962: PUSH
110963: LD_INT 30
110965: PUSH
110966: LD_INT 1
110968: PUSH
110969: EMPTY
110970: LIST
110971: LIST
110972: PUSH
110973: EMPTY
110974: LIST
110975: LIST
110976: LIST
110977: PPUSH
110978: CALL_OW 72
110982: PUSH
110983: LD_INT 1
110985: ARRAY
110986: PPUSH
110987: CALL 55962 0 2
// break ;
110991: GO 110995
// end ; end ;
110993: GO 110913
110995: POP
110996: POP
// end ;
110997: LD_VAR 0 5
111001: RET
