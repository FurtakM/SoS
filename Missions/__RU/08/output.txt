// starting begin InitMission ;
   0: CALL 5 0 0
// end ;
   4: END
// export HeikeCaptured ; export coopWithGensher ; export HeikeStatus ; export Masha ; export dial_BuildDepotBlocker , dial_BuildArBarrackBlocker , dial_ArriveGensherUnitsBlocker ; export buildingsToBuild , techsToResearch , vehWeaponsToConstruct , availableWeapons , weaponsData , allBuildings ; export HeikeTargetX , HeikeTargetY , GensherTargetX , GensherTargetY ; export allowExitFromMap ; export acceptKurtOffert , askCommanders ; export KurtCanEscape , KurtStatus , KurtWaitingForFreeHeike , KurtWaitingForBuildBarrack ; export KurtAttack , americansAttack , forceStopKurtAttack ; export canSendHeike , canShootTrening ; export BurlakRespect ; export acceptLegionOffert , paidLegionOffert , legionOffertCountdown , legionOffertTime ; export firstMashaQuery , canChooseMashaVehicle ; export buildCompVehicle , buildArabBarrack , testedTeleport ; export lostUnits ; function InitMission ; begin
   5: LD_INT 0
   7: PPUSH
// ResetFog ;
   8: CALL_OW 335
// RandomizeAll ;
  12: CALL_OW 11
// InGameOn ;
  16: CALL_OW 8
// InitMapConfig ;
  20: CALL 358 0 0
// HeikeCaptured = LoadVariable ( 07_HeikeCaptured_1 , 0 ) ;
  24: LD_ADDR_EXP 1
  28: PUSH
  29: LD_STRING 07_HeikeCaptured_1
  31: PPUSH
  32: LD_INT 0
  34: PPUSH
  35: CALL_OW 30
  39: ST_TO_ADDR
// coopWithGensher = 0 ;
  40: LD_ADDR_EXP 2
  44: PUSH
  45: LD_INT 0
  47: ST_TO_ADDR
// HeikeStatus = 0 ;
  48: LD_ADDR_EXP 3
  52: PUSH
  53: LD_INT 0
  55: ST_TO_ADDR
// Masha = [ ] ;
  56: LD_ADDR_EXP 4
  60: PUSH
  61: EMPTY
  62: ST_TO_ADDR
// buildingsToBuild = [ ] ;
  63: LD_ADDR_EXP 8
  67: PUSH
  68: EMPTY
  69: ST_TO_ADDR
// techsToResearch = [ ] ;
  70: LD_ADDR_EXP 9
  74: PUSH
  75: EMPTY
  76: ST_TO_ADDR
// vehWeaponsToConstruct = [ ] ;
  77: LD_ADDR_EXP 10
  81: PUSH
  82: EMPTY
  83: ST_TO_ADDR
// availableWeapons = [ ] ;
  84: LD_ADDR_EXP 11
  88: PUSH
  89: EMPTY
  90: ST_TO_ADDR
// weaponsData = [ ] ;
  91: LD_ADDR_EXP 12
  95: PUSH
  96: EMPTY
  97: ST_TO_ADDR
// allBuildings = [ ] ;
  98: LD_ADDR_EXP 13
 102: PUSH
 103: EMPTY
 104: ST_TO_ADDR
// HeikeTargetX = 0 ;
 105: LD_ADDR_EXP 14
 109: PUSH
 110: LD_INT 0
 112: ST_TO_ADDR
// HeikeTargetY = 0 ;
 113: LD_ADDR_EXP 15
 117: PUSH
 118: LD_INT 0
 120: ST_TO_ADDR
// GensherTargetX = 0 ;
 121: LD_ADDR_EXP 16
 125: PUSH
 126: LD_INT 0
 128: ST_TO_ADDR
// GensherTargetY = 0 ;
 129: LD_ADDR_EXP 17
 133: PUSH
 134: LD_INT 0
 136: ST_TO_ADDR
// allowExitFromMap = 0 ;
 137: LD_ADDR_EXP 18
 141: PUSH
 142: LD_INT 0
 144: ST_TO_ADDR
// acceptKurtOffert = 0 ;
 145: LD_ADDR_EXP 19
 149: PUSH
 150: LD_INT 0
 152: ST_TO_ADDR
// askCommanders = 0 ;
 153: LD_ADDR_EXP 20
 157: PUSH
 158: LD_INT 0
 160: ST_TO_ADDR
// KurtCanEscape = true ;
 161: LD_ADDR_EXP 21
 165: PUSH
 166: LD_INT 1
 168: ST_TO_ADDR
// KurtAttack = false ;
 169: LD_ADDR_EXP 25
 173: PUSH
 174: LD_INT 0
 176: ST_TO_ADDR
// KurtWaitingForFreeHeike = false ;
 177: LD_ADDR_EXP 23
 181: PUSH
 182: LD_INT 0
 184: ST_TO_ADDR
// KurtWaitingForBuildBarrack = false ;
 185: LD_ADDR_EXP 24
 189: PUSH
 190: LD_INT 0
 192: ST_TO_ADDR
// KurtStatus = 0 ;
 193: LD_ADDR_EXP 22
 197: PUSH
 198: LD_INT 0
 200: ST_TO_ADDR
// americansAttack = false ;
 201: LD_ADDR_EXP 26
 205: PUSH
 206: LD_INT 0
 208: ST_TO_ADDR
// forceStopKurtAttack = false ;
 209: LD_ADDR_EXP 27
 213: PUSH
 214: LD_INT 0
 216: ST_TO_ADDR
// canSendHeike = false ;
 217: LD_ADDR_EXP 28
 221: PUSH
 222: LD_INT 0
 224: ST_TO_ADDR
// canShootTrening = false ;
 225: LD_ADDR_EXP 29
 229: PUSH
 230: LD_INT 0
 232: ST_TO_ADDR
// BurlakRespect = 0 ;
 233: LD_ADDR_EXP 30
 237: PUSH
 238: LD_INT 0
 240: ST_TO_ADDR
// acceptLegionOffert = false ;
 241: LD_ADDR_EXP 31
 245: PUSH
 246: LD_INT 0
 248: ST_TO_ADDR
// paidLegionOffert = false ;
 249: LD_ADDR_EXP 32
 253: PUSH
 254: LD_INT 0
 256: ST_TO_ADDR
// legionOffertCountdown = false ;
 257: LD_ADDR_EXP 33
 261: PUSH
 262: LD_INT 0
 264: ST_TO_ADDR
// legionOffertTime = 0 0$60 ;
 265: LD_ADDR_EXP 34
 269: PUSH
 270: LD_INT 2100
 272: ST_TO_ADDR
// canChooseMashaVehicle = false ;
 273: LD_ADDR_EXP 36
 277: PUSH
 278: LD_INT 0
 280: ST_TO_ADDR
// firstMashaQuery = true ;
 281: LD_ADDR_EXP 35
 285: PUSH
 286: LD_INT 1
 288: ST_TO_ADDR
// buildArabBarrack = false ;
 289: LD_ADDR_EXP 38
 293: PUSH
 294: LD_INT 0
 296: ST_TO_ADDR
// buildCompVehicle = false ;
 297: LD_ADDR_EXP 37
 301: PUSH
 302: LD_INT 0
 304: ST_TO_ADDR
// testedTeleport = false ;
 305: LD_ADDR_EXP 39
 309: PUSH
 310: LD_INT 0
 312: ST_TO_ADDR
// lostUnits = 0 ;
 313: LD_ADDR_EXP 40
 317: PUSH
 318: LD_INT 0
 320: ST_TO_ADDR
// PrepareRussians ;
 321: CALL 1292 0 0
// PrepareArabians ;
 325: CALL 3847 0 0
// PrepareAmericans ;
 329: CALL 2975 0 0
// Nef_PrepareNature ;
 333: CALL 4831 0 0
// SpawnTrees ;
 337: CALL 5452 0 0
// MissionIntro ;
 341: CALL 9085 0 0
// end ;
 345: LD_VAR 0 1
 349: RET
// export function CustomInitMacro ; begin
 350: LD_INT 0
 352: PPUSH
// end ; end_of_file
 353: LD_VAR 0 1
 357: RET
// export function InitMapConfig ; begin
 358: LD_INT 0
 360: PPUSH
// BaseMapConfig ;
 361: CALL 374 0 0
// MissionMapConfig ;
 365: CALL 464 0 0
// end ;
 369: LD_VAR 0 1
 373: RET
// export animalsAmount , animalsStats , animalsAgression , missionPrefix , previousMissionPrefix , debugMode ; function BaseMapConfig ; begin
 374: LD_INT 0
 376: PPUSH
// animalsAmount = [ 6 , 3 , 4 , 4 , 1 ] ;
 377: LD_ADDR_EXP 41
 381: PUSH
 382: LD_INT 6
 384: PUSH
 385: LD_INT 3
 387: PUSH
 388: LD_INT 4
 390: PUSH
 391: LD_INT 4
 393: PUSH
 394: LD_INT 1
 396: PUSH
 397: EMPTY
 398: LIST
 399: LIST
 400: LIST
 401: LIST
 402: LIST
 403: ST_TO_ADDR
// animalsStats = [ 2 , 2 , 2 , 2 ] ;
 404: LD_ADDR_EXP 42
 408: PUSH
 409: LD_INT 2
 411: PUSH
 412: LD_INT 2
 414: PUSH
 415: LD_INT 2
 417: PUSH
 418: LD_INT 2
 420: PUSH
 421: EMPTY
 422: LIST
 423: LIST
 424: LIST
 425: LIST
 426: ST_TO_ADDR
// animalsAgression = 3 ;
 427: LD_ADDR_EXP 43
 431: PUSH
 432: LD_INT 3
 434: ST_TO_ADDR
// debugMode = 0 ;
 435: LD_ADDR_EXP 46
 439: PUSH
 440: LD_INT 0
 442: ST_TO_ADDR
// missionPrefix = 08_ ;
 443: LD_ADDR_EXP 44
 447: PUSH
 448: LD_STRING 08_
 450: ST_TO_ADDR
// previousMissionPrefix = 07_ ;
 451: LD_ADDR_EXP 45
 455: PUSH
 456: LD_STRING 07_
 458: ST_TO_ADDR
// end ;
 459: LD_VAR 0 1
 463: RET
// export KurtAttackWaves , americansAttackWaves ; export firstAttackDelay ; export waveCooldown ; export legionReduceAmericansUnits ; export speedMedalTime ; export enemyAttackUnitsData ; export timeToFreeHeike , timeToBuildArBarrack ; export enemySkillLevel ; function MissionMapConfig ; begin
 464: LD_INT 0
 466: PPUSH
// KurtAttackWaves = [ 3 , 4 , 5 , 6 ] [ Difficulty ] ;
 467: LD_ADDR_EXP 47
 471: PUSH
 472: LD_INT 3
 474: PUSH
 475: LD_INT 4
 477: PUSH
 478: LD_INT 5
 480: PUSH
 481: LD_INT 6
 483: PUSH
 484: EMPTY
 485: LIST
 486: LIST
 487: LIST
 488: LIST
 489: PUSH
 490: LD_OWVAR 67
 494: ARRAY
 495: ST_TO_ADDR
// americansAttackWaves = [ 1 , 2 , 3 , 4 ] [ Difficulty ] ;
 496: LD_ADDR_EXP 48
 500: PUSH
 501: LD_INT 1
 503: PUSH
 504: LD_INT 2
 506: PUSH
 507: LD_INT 3
 509: PUSH
 510: LD_INT 4
 512: PUSH
 513: EMPTY
 514: LIST
 515: LIST
 516: LIST
 517: LIST
 518: PUSH
 519: LD_OWVAR 67
 523: ARRAY
 524: ST_TO_ADDR
// enemySkillLevel = [ 3 , 4 , 5 , 6 ] [ Difficulty ] ;
 525: LD_ADDR_EXP 56
 529: PUSH
 530: LD_INT 3
 532: PUSH
 533: LD_INT 4
 535: PUSH
 536: LD_INT 5
 538: PUSH
 539: LD_INT 6
 541: PUSH
 542: EMPTY
 543: LIST
 544: LIST
 545: LIST
 546: LIST
 547: PUSH
 548: LD_OWVAR 67
 552: ARRAY
 553: ST_TO_ADDR
// waveCooldown = 1 1$30 ;
 554: LD_ADDR_EXP 50
 558: PUSH
 559: LD_INT 3150
 561: ST_TO_ADDR
// firstAttackDelay = 1 1$00 ;
 562: LD_ADDR_EXP 49
 566: PUSH
 567: LD_INT 2100
 569: ST_TO_ADDR
// timeToFreeHeike = 2 2$00 ;
 570: LD_ADDR_EXP 54
 574: PUSH
 575: LD_INT 4200
 577: ST_TO_ADDR
// timeToBuildArBarrack = 5 5$00 ;
 578: LD_ADDR_EXP 55
 582: PUSH
 583: LD_INT 10500
 585: ST_TO_ADDR
// legionReduceAmericansUnits = [ 5 , 5 , 6 , 6 ] [ Difficulty ] ;
 586: LD_ADDR_EXP 51
 590: PUSH
 591: LD_INT 5
 593: PUSH
 594: LD_INT 5
 596: PUSH
 597: LD_INT 6
 599: PUSH
 600: LD_INT 6
 602: PUSH
 603: EMPTY
 604: LIST
 605: LIST
 606: LIST
 607: LIST
 608: PUSH
 609: LD_OWVAR 67
 613: ARRAY
 614: ST_TO_ADDR
// speedMedalTime = [ 80 80$0 , 70 70$0 , 60 60$0 , 50 50$0 ] [ Difficulty ] ;
 615: LD_ADDR_EXP 52
 619: PUSH
 620: LD_INT 168000
 622: PUSH
 623: LD_INT 147000
 625: PUSH
 626: LD_INT 126000
 628: PUSH
 629: LD_INT 105000
 631: PUSH
 632: EMPTY
 633: LIST
 634: LIST
 635: LIST
 636: LIST
 637: PUSH
 638: LD_OWVAR 67
 642: ARRAY
 643: ST_TO_ADDR
// enemyAttackUnitsData = [ [ 1 , [ 4 , 5 , 6 , 6 ] [ Difficulty ] , [ 7 , 8 , 9 , 9 ] [ Difficulty ] , [ 1 , 2 , 2 , 3 ] [ Difficulty ] , [ 3 , 3 , 4 , 4 ] [ Difficulty ] , [ 6 , 7 , 8 , 8 ] [ Difficulty ] , [ 10 , 12 , 15 , 15 ] [ Difficulty ] ] , [ 8 , [ 2 , 3 , 4 , 4 ] [ Difficulty ] , [ 6 , 6 , 7 , 7 ] [ Difficulty ] , [ 0 , 1 , 1 , 2 ] [ Difficulty ] , [ 1 , 2 , 3 , 3 ] [ Difficulty ] , [ 1 , 2 , 2 , 2 ] [ Difficulty ] , [ 2 , 3 , 5 , 5 ] [ Difficulty ] ] ] ;
 644: LD_ADDR_EXP 53
 648: PUSH
 649: LD_INT 1
 651: PUSH
 652: LD_INT 4
 654: PUSH
 655: LD_INT 5
 657: PUSH
 658: LD_INT 6
 660: PUSH
 661: LD_INT 6
 663: PUSH
 664: EMPTY
 665: LIST
 666: LIST
 667: LIST
 668: LIST
 669: PUSH
 670: LD_OWVAR 67
 674: ARRAY
 675: PUSH
 676: LD_INT 7
 678: PUSH
 679: LD_INT 8
 681: PUSH
 682: LD_INT 9
 684: PUSH
 685: LD_INT 9
 687: PUSH
 688: EMPTY
 689: LIST
 690: LIST
 691: LIST
 692: LIST
 693: PUSH
 694: LD_OWVAR 67
 698: ARRAY
 699: PUSH
 700: LD_INT 1
 702: PUSH
 703: LD_INT 2
 705: PUSH
 706: LD_INT 2
 708: PUSH
 709: LD_INT 3
 711: PUSH
 712: EMPTY
 713: LIST
 714: LIST
 715: LIST
 716: LIST
 717: PUSH
 718: LD_OWVAR 67
 722: ARRAY
 723: PUSH
 724: LD_INT 3
 726: PUSH
 727: LD_INT 3
 729: PUSH
 730: LD_INT 4
 732: PUSH
 733: LD_INT 4
 735: PUSH
 736: EMPTY
 737: LIST
 738: LIST
 739: LIST
 740: LIST
 741: PUSH
 742: LD_OWVAR 67
 746: ARRAY
 747: PUSH
 748: LD_INT 6
 750: PUSH
 751: LD_INT 7
 753: PUSH
 754: LD_INT 8
 756: PUSH
 757: LD_INT 8
 759: PUSH
 760: EMPTY
 761: LIST
 762: LIST
 763: LIST
 764: LIST
 765: PUSH
 766: LD_OWVAR 67
 770: ARRAY
 771: PUSH
 772: LD_INT 10
 774: PUSH
 775: LD_INT 12
 777: PUSH
 778: LD_INT 15
 780: PUSH
 781: LD_INT 15
 783: PUSH
 784: EMPTY
 785: LIST
 786: LIST
 787: LIST
 788: LIST
 789: PUSH
 790: LD_OWVAR 67
 794: ARRAY
 795: PUSH
 796: EMPTY
 797: LIST
 798: LIST
 799: LIST
 800: LIST
 801: LIST
 802: LIST
 803: LIST
 804: PUSH
 805: LD_INT 8
 807: PUSH
 808: LD_INT 2
 810: PUSH
 811: LD_INT 3
 813: PUSH
 814: LD_INT 4
 816: PUSH
 817: LD_INT 4
 819: PUSH
 820: EMPTY
 821: LIST
 822: LIST
 823: LIST
 824: LIST
 825: PUSH
 826: LD_OWVAR 67
 830: ARRAY
 831: PUSH
 832: LD_INT 6
 834: PUSH
 835: LD_INT 6
 837: PUSH
 838: LD_INT 7
 840: PUSH
 841: LD_INT 7
 843: PUSH
 844: EMPTY
 845: LIST
 846: LIST
 847: LIST
 848: LIST
 849: PUSH
 850: LD_OWVAR 67
 854: ARRAY
 855: PUSH
 856: LD_INT 0
 858: PUSH
 859: LD_INT 1
 861: PUSH
 862: LD_INT 1
 864: PUSH
 865: LD_INT 2
 867: PUSH
 868: EMPTY
 869: LIST
 870: LIST
 871: LIST
 872: LIST
 873: PUSH
 874: LD_OWVAR 67
 878: ARRAY
 879: PUSH
 880: LD_INT 1
 882: PUSH
 883: LD_INT 2
 885: PUSH
 886: LD_INT 3
 888: PUSH
 889: LD_INT 3
 891: PUSH
 892: EMPTY
 893: LIST
 894: LIST
 895: LIST
 896: LIST
 897: PUSH
 898: LD_OWVAR 67
 902: ARRAY
 903: PUSH
 904: LD_INT 1
 906: PUSH
 907: LD_INT 2
 909: PUSH
 910: LD_INT 2
 912: PUSH
 913: LD_INT 2
 915: PUSH
 916: EMPTY
 917: LIST
 918: LIST
 919: LIST
 920: LIST
 921: PUSH
 922: LD_OWVAR 67
 926: ARRAY
 927: PUSH
 928: LD_INT 2
 930: PUSH
 931: LD_INT 3
 933: PUSH
 934: LD_INT 5
 936: PUSH
 937: LD_INT 5
 939: PUSH
 940: EMPTY
 941: LIST
 942: LIST
 943: LIST
 944: LIST
 945: PUSH
 946: LD_OWVAR 67
 950: ARRAY
 951: PUSH
 952: EMPTY
 953: LIST
 954: LIST
 955: LIST
 956: LIST
 957: LIST
 958: LIST
 959: LIST
 960: PUSH
 961: EMPTY
 962: LIST
 963: LIST
 964: ST_TO_ADDR
// end ;
 965: LD_VAR 0 1
 969: RET
// every 0 0$1 trigger debugMode do var i ;
 970: LD_EXP 46
 974: IFFALSE 1289
 976: GO 978
 978: DISABLE
 979: LD_INT 0
 981: PPUSH
// begin enable ;
 982: ENABLE
// FogOff ( your_side ) ;
 983: LD_OWVAR 2
 987: PPUSH
 988: CALL_OW 344
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) do
 992: LD_ADDR_VAR 0 1
 996: PUSH
 997: LD_INT 22
 999: PUSH
1000: LD_OWVAR 2
1004: PUSH
1005: EMPTY
1006: LIST
1007: LIST
1008: PUSH
1009: LD_INT 2
1011: PUSH
1012: LD_INT 21
1014: PUSH
1015: LD_INT 1
1017: PUSH
1018: EMPTY
1019: LIST
1020: LIST
1021: PUSH
1022: LD_INT 21
1024: PUSH
1025: LD_INT 2
1027: PUSH
1028: EMPTY
1029: LIST
1030: LIST
1031: PUSH
1032: EMPTY
1033: LIST
1034: LIST
1035: LIST
1036: PUSH
1037: EMPTY
1038: LIST
1039: LIST
1040: PPUSH
1041: CALL_OW 69
1045: PUSH
1046: FOR_IN
1047: IFFALSE 1063
// SetLives ( i , 1000 ) ;
1049: LD_VAR 0 1
1053: PPUSH
1054: LD_INT 1000
1056: PPUSH
1057: CALL_OW 234
1061: GO 1046
1063: POP
1064: POP
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) do
1065: LD_ADDR_VAR 0 1
1069: PUSH
1070: LD_INT 22
1072: PUSH
1073: LD_OWVAR 2
1077: PUSH
1078: EMPTY
1079: LIST
1080: LIST
1081: PUSH
1082: LD_INT 21
1084: PUSH
1085: LD_INT 1
1087: PUSH
1088: EMPTY
1089: LIST
1090: LIST
1091: PUSH
1092: EMPTY
1093: LIST
1094: LIST
1095: PPUSH
1096: CALL_OW 69
1100: PUSH
1101: FOR_IN
1102: IFFALSE 1166
// begin SetSkill ( i , skill_combat , 10 ) ;
1104: LD_VAR 0 1
1108: PPUSH
1109: LD_INT 1
1111: PPUSH
1112: LD_INT 10
1114: PPUSH
1115: CALL_OW 237
// SetSkill ( i , skill_engineering , 10 ) ;
1119: LD_VAR 0 1
1123: PPUSH
1124: LD_INT 2
1126: PPUSH
1127: LD_INT 10
1129: PPUSH
1130: CALL_OW 237
// SetSkill ( i , skill_mechanical , 10 ) ;
1134: LD_VAR 0 1
1138: PPUSH
1139: LD_INT 3
1141: PPUSH
1142: LD_INT 10
1144: PPUSH
1145: CALL_OW 237
// SetSkill ( i , skill_scientistic , 10 ) ;
1149: LD_VAR 0 1
1153: PPUSH
1154: LD_INT 4
1156: PPUSH
1157: LD_INT 10
1159: PPUSH
1160: CALL_OW 237
// end ;
1164: GO 1101
1166: POP
1167: POP
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) do
1168: LD_ADDR_VAR 0 1
1172: PUSH
1173: LD_INT 22
1175: PUSH
1176: LD_OWVAR 2
1180: PUSH
1181: EMPTY
1182: LIST
1183: LIST
1184: PUSH
1185: LD_INT 2
1187: PUSH
1188: LD_INT 30
1190: PUSH
1191: LD_INT 0
1193: PUSH
1194: EMPTY
1195: LIST
1196: LIST
1197: PUSH
1198: LD_INT 30
1200: PUSH
1201: LD_INT 1
1203: PUSH
1204: EMPTY
1205: LIST
1206: LIST
1207: PUSH
1208: EMPTY
1209: LIST
1210: LIST
1211: LIST
1212: PUSH
1213: EMPTY
1214: LIST
1215: LIST
1216: PPUSH
1217: CALL_OW 69
1221: PUSH
1222: FOR_IN
1223: IFFALSE 1287
// begin SetResourceType ( GetBase ( i ) , mat_cans , 9999 ) ;
1225: LD_VAR 0 1
1229: PPUSH
1230: CALL_OW 274
1234: PPUSH
1235: LD_INT 1
1237: PPUSH
1238: LD_INT 9999
1240: PPUSH
1241: CALL_OW 277
// SetResourceType ( GetBase ( i ) , mat_oil , 9999 ) ;
1245: LD_VAR 0 1
1249: PPUSH
1250: CALL_OW 274
1254: PPUSH
1255: LD_INT 2
1257: PPUSH
1258: LD_INT 9999
1260: PPUSH
1261: CALL_OW 277
// SetResourceType ( GetBase ( i ) , mat_siberit , 9999 ) ;
1265: LD_VAR 0 1
1269: PPUSH
1270: CALL_OW 274
1274: PPUSH
1275: LD_INT 3
1277: PPUSH
1278: LD_INT 9999
1280: PPUSH
1281: CALL_OW 277
// end ;
1285: GO 1222
1287: POP
1288: POP
// end ; end_of_file
1289: PPOPN 1
1291: END
// export Burlak , Karamazov , Petrovova , Gleb , Petrosyan , Titov , Dolgov , Lipshchin , Kirilenkova , Belkov , Belkov2 , Xavier ; export Gnyevko , Kovalyuk , Scholtze , Kuzmov ; export Kozlov , Oblukov , Kapitsova ; export Popov ; export russianEscort ; export function PrepareRussians ; begin
1292: LD_INT 0
1294: PPUSH
// russianEscort = [ ] ;
1295: LD_ADDR_EXP 77
1299: PUSH
1300: EMPTY
1301: ST_TO_ADDR
// Masha = [ ] ;
1302: LD_ADDR_EXP 4
1306: PUSH
1307: EMPTY
1308: ST_TO_ADDR
// PrepareHeroes ;
1309: CALL 1322 0 0
// InitRussianRequiments ;
1313: CALL 2717 0 0
// end ;
1317: LD_VAR 0 1
1321: RET
// function PrepareHeroes ; var i , un , other_survivors , yourUnits , emptyVeh ; begin
1322: LD_INT 0
1324: PPUSH
1325: PPUSH
1326: PPUSH
1327: PPUSH
1328: PPUSH
1329: PPUSH
// uc_side = 3 ;
1330: LD_ADDR_OWVAR 20
1334: PUSH
1335: LD_INT 3
1337: ST_TO_ADDR
// uc_nation = 3 ;
1338: LD_ADDR_OWVAR 21
1342: PUSH
1343: LD_INT 3
1345: ST_TO_ADDR
// Burlak := PrepareUnitExt ( Burlak , true , class_mechanic ) ;
1346: LD_ADDR_EXP 57
1350: PUSH
1351: LD_STRING Burlak
1353: PPUSH
1354: LD_INT 1
1356: PPUSH
1357: LD_INT 3
1359: PPUSH
1360: CALL 5930 0 3
1364: ST_TO_ADDR
// Titov := PrepareUnitExt ( Titov , true , class_soldier ) ;
1365: LD_ADDR_EXP 62
1369: PUSH
1370: LD_STRING Titov
1372: PPUSH
1373: LD_INT 1
1375: PPUSH
1376: LD_INT 1
1378: PPUSH
1379: CALL 5930 0 3
1383: ST_TO_ADDR
// Dolgov := PrepareUnitExt ( Dolgov , true , class_scientistic ) ;
1384: LD_ADDR_EXP 63
1388: PUSH
1389: LD_STRING Dolgov
1391: PPUSH
1392: LD_INT 1
1394: PPUSH
1395: LD_INT 4
1397: PPUSH
1398: CALL 5930 0 3
1402: ST_TO_ADDR
// Lipshchin := PrepareUnitExt ( Lipshchin , true , class_soldier ) ;
1403: LD_ADDR_EXP 64
1407: PUSH
1408: LD_STRING Lipshchin
1410: PPUSH
1411: LD_INT 1
1413: PPUSH
1414: LD_INT 1
1416: PPUSH
1417: CALL 5930 0 3
1421: ST_TO_ADDR
// Karamazov := PrepareUnitExt ( Karamazov , true , class_engineer ) ;
1422: LD_ADDR_EXP 58
1426: PUSH
1427: LD_STRING Karamazov
1429: PPUSH
1430: LD_INT 1
1432: PPUSH
1433: LD_INT 2
1435: PPUSH
1436: CALL 5930 0 3
1440: ST_TO_ADDR
// Petrovova := PrepareUnitExt ( Petrovova , true , class_soldier ) ;
1441: LD_ADDR_EXP 59
1445: PUSH
1446: LD_STRING Petrovova
1448: PPUSH
1449: LD_INT 1
1451: PPUSH
1452: LD_INT 1
1454: PPUSH
1455: CALL 5930 0 3
1459: ST_TO_ADDR
// Gleb := PrepareUnitExt ( Gleb , true , class_soldier ) ;
1460: LD_ADDR_EXP 60
1464: PUSH
1465: LD_STRING Gleb
1467: PPUSH
1468: LD_INT 1
1470: PPUSH
1471: LD_INT 1
1473: PPUSH
1474: CALL 5930 0 3
1478: ST_TO_ADDR
// Petrosyan := PrepareUnitExt ( Petrosyan , true , class_scientistic ) ;
1479: LD_ADDR_EXP 61
1483: PUSH
1484: LD_STRING Petrosyan
1486: PPUSH
1487: LD_INT 1
1489: PPUSH
1490: LD_INT 4
1492: PPUSH
1493: CALL 5930 0 3
1497: ST_TO_ADDR
// Kirilenkova := PrepareUnitExt ( Kirilenkova , true , class_scientistic ) ;
1498: LD_ADDR_EXP 65
1502: PUSH
1503: LD_STRING Kirilenkova
1505: PPUSH
1506: LD_INT 1
1508: PPUSH
1509: LD_INT 4
1511: PPUSH
1512: CALL 5930 0 3
1516: ST_TO_ADDR
// Belkov := PrepareUnitExt ( Belkov , true , class_soldier ) ;
1517: LD_ADDR_EXP 66
1521: PUSH
1522: LD_STRING Belkov
1524: PPUSH
1525: LD_INT 1
1527: PPUSH
1528: LD_INT 1
1530: PPUSH
1531: CALL 5930 0 3
1535: ST_TO_ADDR
// Belkov2 := PrepareUnitExt ( Belkov2 , true , class_soldier ) ;
1536: LD_ADDR_EXP 67
1540: PUSH
1541: LD_STRING Belkov2
1543: PPUSH
1544: LD_INT 1
1546: PPUSH
1547: LD_INT 1
1549: PPUSH
1550: CALL 5930 0 3
1554: ST_TO_ADDR
// Xavier := PrepareUnitExt ( Xavier , true , class_soldier ) ;
1555: LD_ADDR_EXP 68
1559: PUSH
1560: LD_STRING Xavier
1562: PPUSH
1563: LD_INT 1
1565: PPUSH
1566: LD_INT 1
1568: PPUSH
1569: CALL 5930 0 3
1573: ST_TO_ADDR
// Gnyevko := CreateCharacter ( 04_Gnyevko ) ;
1574: LD_ADDR_EXP 69
1578: PUSH
1579: LD_STRING 04_Gnyevko
1581: PPUSH
1582: CALL_OW 34
1586: ST_TO_ADDR
// SetClass ( Gnyevko , class_soldier ) ;
1587: LD_EXP 69
1591: PPUSH
1592: LD_INT 1
1594: PPUSH
1595: CALL_OW 336
// Kovalyuk := CreateCharacter ( 04_Kovalyuk ) ;
1599: LD_ADDR_EXP 70
1603: PUSH
1604: LD_STRING 04_Kovalyuk
1606: PPUSH
1607: CALL_OW 34
1611: ST_TO_ADDR
// SetClass ( Kovalyuk , class_mechanic ) ;
1612: LD_EXP 70
1616: PPUSH
1617: LD_INT 3
1619: PPUSH
1620: CALL_OW 336
// Scholtze := CreateCharacter ( 04_Scholtze ) ;
1624: LD_ADDR_EXP 71
1628: PUSH
1629: LD_STRING 04_Scholtze
1631: PPUSH
1632: CALL_OW 34
1636: ST_TO_ADDR
// SetClass ( Scholtze , class_scientistic ) ;
1637: LD_EXP 71
1641: PPUSH
1642: LD_INT 4
1644: PPUSH
1645: CALL_OW 336
// Kuzmov := CreateCharacter ( 04_Kuzmov ) ;
1649: LD_ADDR_EXP 72
1653: PUSH
1654: LD_STRING 04_Kuzmov
1656: PPUSH
1657: CALL_OW 34
1661: ST_TO_ADDR
// SetClass ( Kuzmov , class_soldier ) ;
1662: LD_EXP 72
1666: PPUSH
1667: LD_INT 1
1669: PPUSH
1670: CALL_OW 336
// Kozlov := PrepareUnitExt ( Kozlov , false , class_engineer ) ;
1674: LD_ADDR_EXP 73
1678: PUSH
1679: LD_STRING Kozlov
1681: PPUSH
1682: LD_INT 0
1684: PPUSH
1685: LD_INT 2
1687: PPUSH
1688: CALL 5930 0 3
1692: ST_TO_ADDR
// Oblukov := PrepareUnitExt ( Oblukov , false , class_soldier ) ;
1693: LD_ADDR_EXP 74
1697: PUSH
1698: LD_STRING Oblukov
1700: PPUSH
1701: LD_INT 0
1703: PPUSH
1704: LD_INT 1
1706: PPUSH
1707: CALL 5930 0 3
1711: ST_TO_ADDR
// Kapitsova := PrepareUnitExt ( Kapitsova , false , class_scientistic ) ;
1712: LD_ADDR_EXP 75
1716: PUSH
1717: LD_STRING Kapitsova
1719: PPUSH
1720: LD_INT 0
1722: PPUSH
1723: LD_INT 4
1725: PPUSH
1726: CALL 5930 0 3
1730: ST_TO_ADDR
// Popov := PrepareUnitExt ( Popov , false , 0 ) ;
1731: LD_ADDR_EXP 76
1735: PUSH
1736: LD_STRING Popov
1738: PPUSH
1739: LD_INT 0
1741: PPUSH
1742: LD_INT 0
1744: PPUSH
1745: CALL 5930 0 3
1749: ST_TO_ADDR
// PlaceUnitsArea ( [ Burlak , Karamazov , Petrovova , Gleb , Petrosyan , Titov , Dolgov , Lipshchin , Kirilenkova , Belkov , Belkov2 , Xavier , Gnyevko , Kovalyuk , Scholtze , Kuzmov , Kozlov , Oblukov , Kapitsova ] , RussianSpawnArea , false ) ;
1750: LD_EXP 57
1754: PUSH
1755: LD_EXP 58
1759: PUSH
1760: LD_EXP 59
1764: PUSH
1765: LD_EXP 60
1769: PUSH
1770: LD_EXP 61
1774: PUSH
1775: LD_EXP 62
1779: PUSH
1780: LD_EXP 63
1784: PUSH
1785: LD_EXP 64
1789: PUSH
1790: LD_EXP 65
1794: PUSH
1795: LD_EXP 66
1799: PUSH
1800: LD_EXP 67
1804: PUSH
1805: LD_EXP 68
1809: PUSH
1810: LD_EXP 69
1814: PUSH
1815: LD_EXP 70
1819: PUSH
1820: LD_EXP 71
1824: PUSH
1825: LD_EXP 72
1829: PUSH
1830: LD_EXP 73
1834: PUSH
1835: LD_EXP 74
1839: PUSH
1840: LD_EXP 75
1844: PUSH
1845: EMPTY
1846: LIST
1847: LIST
1848: LIST
1849: LIST
1850: LIST
1851: LIST
1852: LIST
1853: LIST
1854: LIST
1855: LIST
1856: LIST
1857: LIST
1858: LIST
1859: LIST
1860: LIST
1861: LIST
1862: LIST
1863: LIST
1864: LIST
1865: PPUSH
1866: LD_INT 2
1868: PPUSH
1869: LD_INT 0
1871: PPUSH
1872: CALL 6204 0 3
// PrepareVehicles ;
1876: CALL 2417 0 0
// other_survivors = CreateCharacterSet ( 07_other_survivors ) ;
1880: LD_ADDR_VAR 0 4
1884: PUSH
1885: LD_STRING 07_other_survivors
1887: PPUSH
1888: CALL_OW 31
1892: ST_TO_ADDR
// other_survivors = other_survivors ^ CreateCharacterSet ( 04_other_survivors ) ;
1893: LD_ADDR_VAR 0 4
1897: PUSH
1898: LD_VAR 0 4
1902: PUSH
1903: LD_STRING 04_other_survivors
1905: PPUSH
1906: CALL_OW 31
1910: ADD
1911: ST_TO_ADDR
// other_survivors = other_survivors ^ CreateCharacterSet ( 04_other_survivors_with_popov ) ;
1912: LD_ADDR_VAR 0 4
1916: PUSH
1917: LD_VAR 0 4
1921: PUSH
1922: LD_STRING 04_other_survivors_with_popov
1924: PPUSH
1925: CALL_OW 31
1929: ADD
1930: ST_TO_ADDR
// for un in other_survivors do
1931: LD_ADDR_VAR 0 3
1935: PUSH
1936: LD_VAR 0 4
1940: PUSH
1941: FOR_IN
1942: IFFALSE 2028
// begin emptyVeh = FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_vehicle ] , [ f_empty ] ] ) ;
1944: LD_ADDR_VAR 0 6
1948: PUSH
1949: LD_INT 22
1951: PUSH
1952: LD_INT 3
1954: PUSH
1955: EMPTY
1956: LIST
1957: LIST
1958: PUSH
1959: LD_INT 21
1961: PUSH
1962: LD_INT 2
1964: PUSH
1965: EMPTY
1966: LIST
1967: LIST
1968: PUSH
1969: LD_INT 58
1971: PUSH
1972: EMPTY
1973: LIST
1974: PUSH
1975: EMPTY
1976: LIST
1977: LIST
1978: LIST
1979: PPUSH
1980: CALL_OW 69
1984: ST_TO_ADDR
// if emptyVeh then
1985: LD_VAR 0 6
1989: IFFALSE 2011
// PlaceHumanInUnit ( un , emptyVeh [ 1 ] ) else
1991: LD_VAR 0 3
1995: PPUSH
1996: LD_VAR 0 6
2000: PUSH
2001: LD_INT 1
2003: ARRAY
2004: PPUSH
2005: CALL_OW 52
2009: GO 2026
// PlaceUnitArea ( un , RussianSpawnArea , false ) ;
2011: LD_VAR 0 3
2015: PPUSH
2016: LD_INT 2
2018: PPUSH
2019: LD_INT 0
2021: PPUSH
2022: CALL_OW 49
// end ;
2026: GO 1941
2028: POP
2029: POP
// yourUnits = FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_nation , nation_russian ] ] ) ;
2030: LD_ADDR_VAR 0 5
2034: PUSH
2035: LD_INT 22
2037: PUSH
2038: LD_INT 3
2040: PUSH
2041: EMPTY
2042: LIST
2043: LIST
2044: PUSH
2045: LD_INT 21
2047: PUSH
2048: LD_INT 1
2050: PUSH
2051: EMPTY
2052: LIST
2053: LIST
2054: PUSH
2055: LD_INT 23
2057: PUSH
2058: LD_INT 3
2060: PUSH
2061: EMPTY
2062: LIST
2063: LIST
2064: PUSH
2065: EMPTY
2066: LIST
2067: LIST
2068: LIST
2069: PPUSH
2070: CALL_OW 69
2074: ST_TO_ADDR
// if yourUnits < 15 then
2075: LD_VAR 0 5
2079: PUSH
2080: LD_INT 15
2082: LESS
2083: IFFALSE 2232
// for i := 1 to 15 - yourUnits do
2085: LD_ADDR_VAR 0 2
2089: PUSH
2090: DOUBLE
2091: LD_INT 1
2093: DEC
2094: ST_TO_ADDR
2095: LD_INT 15
2097: PUSH
2098: LD_VAR 0 5
2102: MINUS
2103: PUSH
2104: FOR_TO
2105: IFFALSE 2230
// begin PrepareHuman ( false , rand ( 1 , 4 ) , rand ( 2 , 4 ) ) ;
2107: LD_INT 0
2109: PPUSH
2110: LD_INT 1
2112: PPUSH
2113: LD_INT 4
2115: PPUSH
2116: CALL_OW 12
2120: PPUSH
2121: LD_INT 2
2123: PPUSH
2124: LD_INT 4
2126: PPUSH
2127: CALL_OW 12
2131: PPUSH
2132: CALL_OW 380
// un = CreateHuman ;
2136: LD_ADDR_VAR 0 3
2140: PUSH
2141: CALL_OW 44
2145: ST_TO_ADDR
// emptyVeh = FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_vehicle ] , [ f_empty ] ] ) ;
2146: LD_ADDR_VAR 0 6
2150: PUSH
2151: LD_INT 22
2153: PUSH
2154: LD_INT 3
2156: PUSH
2157: EMPTY
2158: LIST
2159: LIST
2160: PUSH
2161: LD_INT 21
2163: PUSH
2164: LD_INT 2
2166: PUSH
2167: EMPTY
2168: LIST
2169: LIST
2170: PUSH
2171: LD_INT 58
2173: PUSH
2174: EMPTY
2175: LIST
2176: PUSH
2177: EMPTY
2178: LIST
2179: LIST
2180: LIST
2181: PPUSH
2182: CALL_OW 69
2186: ST_TO_ADDR
// if emptyVeh then
2187: LD_VAR 0 6
2191: IFFALSE 2213
// PlaceHumanInUnit ( un , emptyVeh [ 1 ] ) else
2193: LD_VAR 0 3
2197: PPUSH
2198: LD_VAR 0 6
2202: PUSH
2203: LD_INT 1
2205: ARRAY
2206: PPUSH
2207: CALL_OW 52
2211: GO 2228
// PlaceUnitArea ( un , RussianSpawnArea , false ) ;
2213: LD_VAR 0 3
2217: PPUSH
2218: LD_INT 2
2220: PPUSH
2221: LD_INT 0
2223: PPUSH
2224: CALL_OW 49
// end ;
2228: GO 2104
2230: POP
2231: POP
// yourUnits = FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_nation , nation_russian ] ] ) ;
2232: LD_ADDR_VAR 0 5
2236: PUSH
2237: LD_INT 22
2239: PUSH
2240: LD_INT 3
2242: PUSH
2243: EMPTY
2244: LIST
2245: LIST
2246: PUSH
2247: LD_INT 21
2249: PUSH
2250: LD_INT 1
2252: PUSH
2253: EMPTY
2254: LIST
2255: LIST
2256: PUSH
2257: LD_INT 23
2259: PUSH
2260: LD_INT 3
2262: PUSH
2263: EMPTY
2264: LIST
2265: LIST
2266: PUSH
2267: EMPTY
2268: LIST
2269: LIST
2270: LIST
2271: PPUSH
2272: CALL_OW 69
2276: ST_TO_ADDR
// if not UnitFilter ( yourUnits , [ f_class , class_engineer ] ) then
2277: LD_VAR 0 5
2281: PPUSH
2282: LD_INT 25
2284: PUSH
2285: LD_INT 2
2287: PUSH
2288: EMPTY
2289: LIST
2290: LIST
2291: PPUSH
2292: CALL_OW 72
2296: NOT
2297: IFFALSE 2315
// SetClass ( yourUnits [ 1 ] , 2 ) ;
2299: LD_VAR 0 5
2303: PUSH
2304: LD_INT 1
2306: ARRAY
2307: PPUSH
2308: LD_INT 2
2310: PPUSH
2311: CALL_OW 336
// end ;
2315: LD_VAR 0 1
2319: RET
// export function PrepareRussianEscort ; var i , unit ; begin
2320: LD_INT 0
2322: PPUSH
2323: PPUSH
2324: PPUSH
// uc_side = 6 ;
2325: LD_ADDR_OWVAR 20
2329: PUSH
2330: LD_INT 6
2332: ST_TO_ADDR
// uc_nation = 3 ;
2333: LD_ADDR_OWVAR 21
2337: PUSH
2338: LD_INT 3
2340: ST_TO_ADDR
// for i := 1 to 2 do
2341: LD_ADDR_VAR 0 2
2345: PUSH
2346: DOUBLE
2347: LD_INT 1
2349: DEC
2350: ST_TO_ADDR
2351: LD_INT 2
2353: PUSH
2354: FOR_TO
2355: IFFALSE 2410
// begin PrepareSoldier ( false , 4 ) ;
2357: LD_INT 0
2359: PPUSH
2360: LD_INT 4
2362: PPUSH
2363: CALL_OW 381
// unit = CreateHuman ;
2367: LD_ADDR_VAR 0 3
2371: PUSH
2372: CALL_OW 44
2376: ST_TO_ADDR
// russianEscort = russianEscort ^ unit ;
2377: LD_ADDR_EXP 77
2381: PUSH
2382: LD_EXP 77
2386: PUSH
2387: LD_VAR 0 3
2391: ADD
2392: ST_TO_ADDR
// PlaceUnitArea ( unit , RussianSpawn2Area , false ) ;
2393: LD_VAR 0 3
2397: PPUSH
2398: LD_INT 7
2400: PPUSH
2401: LD_INT 0
2403: PPUSH
2404: CALL_OW 49
// end ;
2408: GO 2354
2410: POP
2411: POP
// end ;
2412: LD_VAR 0 1
2416: RET
// function PrepareVehicles ; var i , veh ; begin
2417: LD_INT 0
2419: PPUSH
2420: PPUSH
2421: PPUSH
// uc_side = 3 ;
2422: LD_ADDR_OWVAR 20
2426: PUSH
2427: LD_INT 3
2429: ST_TO_ADDR
// uc_nation = 3 ;
2430: LD_ADDR_OWVAR 21
2434: PUSH
2435: LD_INT 3
2437: ST_TO_ADDR
// for i := 1 to 5 do
2438: LD_ADDR_VAR 0 2
2442: PUSH
2443: DOUBLE
2444: LD_INT 1
2446: DEC
2447: ST_TO_ADDR
2448: LD_INT 5
2450: PUSH
2451: FOR_TO
2452: IFFALSE 2562
// begin PrepareVehicle ( ru_medium_wheeled , engine_combustion , control_manual , ru_cargo_bay , rand ( 60 , 80 ) ) ;
2454: LD_INT 21
2456: PPUSH
2457: LD_INT 1
2459: PPUSH
2460: LD_INT 1
2462: PPUSH
2463: LD_INT 51
2465: PPUSH
2466: LD_INT 60
2468: PPUSH
2469: LD_INT 80
2471: PPUSH
2472: CALL_OW 12
2476: PPUSH
2477: CALL 24088 0 5
// veh = CreateVehicle ;
2481: LD_ADDR_VAR 0 3
2485: PUSH
2486: CALL_OW 45
2490: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
2491: LD_VAR 0 3
2495: PPUSH
2496: LD_INT 4
2498: PPUSH
2499: CALL_OW 233
// PlaceUnitArea ( veh , RussianSpawnArea , false ) ;
2503: LD_VAR 0 3
2507: PPUSH
2508: LD_INT 2
2510: PPUSH
2511: LD_INT 0
2513: PPUSH
2514: CALL_OW 49
// if ( i <> 5 ) then
2518: LD_VAR 0 2
2522: PUSH
2523: LD_INT 5
2525: NONEQUAL
2526: IFFALSE 2545
// AddCargo ( veh , mat_cans , 100 ) else
2528: LD_VAR 0 3
2532: PPUSH
2533: LD_INT 1
2535: PPUSH
2536: LD_INT 100
2538: PPUSH
2539: CALL_OW 291
2543: GO 2560
// AddCargo ( veh , mat_oil , 100 ) ;
2545: LD_VAR 0 3
2549: PPUSH
2550: LD_INT 2
2552: PPUSH
2553: LD_INT 100
2555: PPUSH
2556: CALL_OW 291
// end ;
2560: GO 2451
2562: POP
2563: POP
// PrepareVehicle ( ru_medium_wheeled , engine_combustion , control_manual , ru_crane , rand ( 60 , 80 ) ) ;
2564: LD_INT 21
2566: PPUSH
2567: LD_INT 1
2569: PPUSH
2570: LD_INT 1
2572: PPUSH
2573: LD_INT 52
2575: PPUSH
2576: LD_INT 60
2578: PPUSH
2579: LD_INT 80
2581: PPUSH
2582: CALL_OW 12
2586: PPUSH
2587: CALL 24088 0 5
// veh = CreateVehicle ;
2591: LD_ADDR_VAR 0 3
2595: PUSH
2596: CALL_OW 45
2600: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
2601: LD_VAR 0 3
2605: PPUSH
2606: LD_INT 4
2608: PPUSH
2609: CALL_OW 233
// PlaceUnitArea ( veh , RussianSpawnArea , false ) ;
2613: LD_VAR 0 3
2617: PPUSH
2618: LD_INT 2
2620: PPUSH
2621: LD_INT 0
2623: PPUSH
2624: CALL_OW 49
// for i := 1 to 3 do
2628: LD_ADDR_VAR 0 2
2632: PUSH
2633: DOUBLE
2634: LD_INT 1
2636: DEC
2637: ST_TO_ADDR
2638: LD_INT 3
2640: PUSH
2641: FOR_TO
2642: IFFALSE 2710
// begin PrepareVehicle ( ru_heavy_tracked , engine_combustion , control_manual , ru_bulldozer , rand ( 60 , 80 ) ) ;
2644: LD_INT 24
2646: PPUSH
2647: LD_INT 1
2649: PPUSH
2650: LD_INT 1
2652: PPUSH
2653: LD_INT 53
2655: PPUSH
2656: LD_INT 60
2658: PPUSH
2659: LD_INT 80
2661: PPUSH
2662: CALL_OW 12
2666: PPUSH
2667: CALL 24088 0 5
// veh = CreateVehicle ;
2671: LD_ADDR_VAR 0 3
2675: PUSH
2676: CALL_OW 45
2680: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
2681: LD_VAR 0 3
2685: PPUSH
2686: LD_INT 4
2688: PPUSH
2689: CALL_OW 233
// PlaceUnitArea ( veh , RussianSpawnArea , false ) ;
2693: LD_VAR 0 3
2697: PPUSH
2698: LD_INT 2
2700: PPUSH
2701: LD_INT 0
2703: PPUSH
2704: CALL_OW 49
// end ;
2708: GO 2641
2710: POP
2711: POP
// end ;
2712: LD_VAR 0 1
2716: RET
// function InitRussianRequiments ; var i ; begin
2717: LD_INT 0
2719: PPUSH
2720: PPUSH
// availableWeapons = [ ru_heavy_machine_gun , ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher ] ;
2721: LD_ADDR_EXP 11
2725: PUSH
2726: LD_INT 42
2728: PUSH
2729: LD_INT 43
2731: PUSH
2732: LD_INT 44
2734: PUSH
2735: LD_INT 46
2737: PUSH
2738: LD_INT 45
2740: PUSH
2741: EMPTY
2742: LIST
2743: LIST
2744: LIST
2745: LIST
2746: LIST
2747: ST_TO_ADDR
// for i := 1 to availableWeapons do
2748: LD_ADDR_VAR 0 2
2752: PUSH
2753: DOUBLE
2754: LD_INT 1
2756: DEC
2757: ST_TO_ADDR
2758: LD_EXP 11
2762: PUSH
2763: FOR_TO
2764: IFFALSE 2804
// weaponsData = weaponsData ^ [ [ availableWeapons [ i ] , false , false ] ] ;
2766: LD_ADDR_EXP 12
2770: PUSH
2771: LD_EXP 12
2775: PUSH
2776: LD_EXP 11
2780: PUSH
2781: LD_VAR 0 2
2785: ARRAY
2786: PUSH
2787: LD_INT 0
2789: PUSH
2790: LD_INT 0
2792: PUSH
2793: EMPTY
2794: LIST
2795: LIST
2796: LIST
2797: PUSH
2798: EMPTY
2799: LIST
2800: ADD
2801: ST_TO_ADDR
2802: GO 2763
2804: POP
2805: POP
// for i := 0 to 50 do
2806: LD_ADDR_VAR 0 2
2810: PUSH
2811: DOUBLE
2812: LD_INT 0
2814: DEC
2815: ST_TO_ADDR
2816: LD_INT 50
2818: PUSH
2819: FOR_TO
2820: IFFALSE 2858
// if GetRestrict ( i , 3 ) = state_enabled then
2822: LD_VAR 0 2
2826: PPUSH
2827: LD_INT 3
2829: PPUSH
2830: CALL_OW 323
2834: PUSH
2835: LD_INT 1
2837: EQUAL
2838: IFFALSE 2856
// buildingsToBuild = buildingsToBuild ^ i ;
2840: LD_ADDR_EXP 8
2844: PUSH
2845: LD_EXP 8
2849: PUSH
2850: LD_VAR 0 2
2854: ADD
2855: ST_TO_ADDR
2856: GO 2819
2858: POP
2859: POP
// buildingsToBuild = buildingsToBuild diff [ 0 , 2 , 4 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 14 , 22 , 31 , 32 , 33 , 39 , 40 ] ;
2860: LD_ADDR_EXP 8
2864: PUSH
2865: LD_EXP 8
2869: PUSH
2870: LD_INT 0
2872: PUSH
2873: LD_INT 2
2875: PUSH
2876: LD_INT 4
2878: PUSH
2879: LD_INT 6
2881: PUSH
2882: LD_INT 7
2884: PUSH
2885: LD_INT 8
2887: PUSH
2888: LD_INT 9
2890: PUSH
2891: LD_INT 10
2893: PUSH
2894: LD_INT 11
2896: PUSH
2897: LD_INT 12
2899: PUSH
2900: LD_INT 14
2902: PUSH
2903: LD_INT 22
2905: PUSH
2906: LD_INT 31
2908: PUSH
2909: LD_INT 32
2911: PUSH
2912: LD_INT 33
2914: PUSH
2915: LD_INT 39
2917: PUSH
2918: LD_INT 40
2920: PUSH
2921: EMPTY
2922: LIST
2923: LIST
2924: LIST
2925: LIST
2926: LIST
2927: LIST
2928: LIST
2929: LIST
2930: LIST
2931: LIST
2932: LIST
2933: LIST
2934: LIST
2935: LIST
2936: LIST
2937: LIST
2938: LIST
2939: DIFF
2940: ST_TO_ADDR
// allBuildings = buildingsToBuild ;
2941: LD_ADDR_EXP 13
2945: PUSH
2946: LD_EXP 8
2950: ST_TO_ADDR
// techsToResearch = GetTechNation ( 3 , nation_russian , state_enabled ) ;
2951: LD_ADDR_EXP 9
2955: PUSH
2956: LD_INT 3
2958: PPUSH
2959: LD_INT 3
2961: PPUSH
2962: LD_INT 1
2964: PPUSH
2965: CALL 19287 0 3
2969: ST_TO_ADDR
// end ; end_of_file
2970: LD_VAR 0 1
2974: RET
// export amAttackTeam ; export function PrepareAmericans ; begin
2975: LD_INT 0
2977: PPUSH
// amAttackTeam = [ ] ;
2978: LD_ADDR_EXP 78
2982: PUSH
2983: EMPTY
2984: ST_TO_ADDR
// SpawnAmericansSnipers ;
2985: CALL 3119 0 0
// case Difficulty of 2 :
2989: LD_OWVAR 67
2993: PUSH
2994: LD_INT 2
2996: DOUBLE
2997: EQUAL
2998: IFTRUE 3002
3000: GO 3031
3002: POP
// begin SetTech ( tech_comp1 , 1 , state_researched ) ;
3003: LD_INT 57
3005: PPUSH
3006: LD_INT 1
3008: PPUSH
3009: LD_INT 2
3011: PPUSH
3012: CALL_OW 322
// SetTech ( tech_opto1 , 1 , state_researched ) ;
3016: LD_INT 60
3018: PPUSH
3019: LD_INT 1
3021: PPUSH
3022: LD_INT 2
3024: PPUSH
3025: CALL_OW 322
// end ; 3 .. 4 :
3029: GO 3114
3031: LD_INT 3
3033: DOUBLE
3034: GREATEREQUAL
3035: IFFALSE 3043
3037: LD_INT 4
3039: DOUBLE
3040: LESSEQUAL
3041: IFTRUE 3045
3043: GO 3113
3045: POP
// begin SetTech ( tech_comp1 , 1 , state_researched ) ;
3046: LD_INT 57
3048: PPUSH
3049: LD_INT 1
3051: PPUSH
3052: LD_INT 2
3054: PPUSH
3055: CALL_OW 322
// SetTech ( tech_comp2 , 1 , state_researched ) ;
3059: LD_INT 58
3061: PPUSH
3062: LD_INT 1
3064: PPUSH
3065: LD_INT 2
3067: PPUSH
3068: CALL_OW 322
// SetTech ( tech_weap3 , 1 , state_researched ) ;
3072: LD_INT 53
3074: PPUSH
3075: LD_INT 1
3077: PPUSH
3078: LD_INT 2
3080: PPUSH
3081: CALL_OW 322
// SetTech ( tech_opto1 , 1 , state_researched ) ;
3085: LD_INT 60
3087: PPUSH
3088: LD_INT 1
3090: PPUSH
3091: LD_INT 2
3093: PPUSH
3094: CALL_OW 322
// SetTech ( tech_opto2 , 1 , state_researched ) ;
3098: LD_INT 61
3100: PPUSH
3101: LD_INT 1
3103: PPUSH
3104: LD_INT 2
3106: PPUSH
3107: CALL_OW 322
// end ; end ;
3111: GO 3114
3113: POP
// end ;
3114: LD_VAR 0 1
3118: RET
// export function SpawnAmericansSnipers ; var i , un ; begin
3119: LD_INT 0
3121: PPUSH
3122: PPUSH
3123: PPUSH
// uc_side = 1 ;
3124: LD_ADDR_OWVAR 20
3128: PUSH
3129: LD_INT 1
3131: ST_TO_ADDR
// uc_nation = 1 ;
3132: LD_ADDR_OWVAR 21
3136: PUSH
3137: LD_INT 1
3139: ST_TO_ADDR
// for i := 1 to 8 do
3140: LD_ADDR_VAR 0 2
3144: PUSH
3145: DOUBLE
3146: LD_INT 1
3148: DEC
3149: ST_TO_ADDR
3150: LD_INT 8
3152: PUSH
3153: FOR_TO
3154: IFFALSE 3207
// begin PrepareHuman ( false , class_sniper , enemySkillLevel ) ;
3156: LD_INT 0
3158: PPUSH
3159: LD_INT 5
3161: PPUSH
3162: LD_EXP 56
3166: PPUSH
3167: CALL_OW 380
// un = CreateHuman ;
3171: LD_ADDR_VAR 0 3
3175: PUSH
3176: CALL_OW 44
3180: ST_TO_ADDR
// PlaceUnitArea ( un , AmericansSnipersSpawnArea , false ) ;
3181: LD_VAR 0 3
3185: PPUSH
3186: LD_INT 14
3188: PPUSH
3189: LD_INT 0
3191: PPUSH
3192: CALL_OW 49
// ComHold ( un ) ;
3196: LD_VAR 0 3
3200: PPUSH
3201: CALL_OW 140
// end ;
3205: GO 3153
3207: POP
3208: POP
// end ;
3209: LD_VAR 0 1
3213: RET
// export function SpawnAmAttackTeam ; var i , unit , veh , randVehType , weapon , chassis , amSolds , amSnipers , amVehs ; begin
3214: LD_INT 0
3216: PPUSH
3217: PPUSH
3218: PPUSH
3219: PPUSH
3220: PPUSH
3221: PPUSH
3222: PPUSH
3223: PPUSH
3224: PPUSH
3225: PPUSH
// uc_side = 1 ;
3226: LD_ADDR_OWVAR 20
3230: PUSH
3231: LD_INT 1
3233: ST_TO_ADDR
// uc_nation = 1 ;
3234: LD_ADDR_OWVAR 21
3238: PUSH
3239: LD_INT 1
3241: ST_TO_ADDR
// amSolds = Rand ( enemyAttackUnitsData [ 1 ] [ 2 ] , enemyAttackUnitsData [ 1 ] [ 3 ] ) ;
3242: LD_ADDR_VAR 0 8
3246: PUSH
3247: LD_EXP 53
3251: PUSH
3252: LD_INT 1
3254: ARRAY
3255: PUSH
3256: LD_INT 2
3258: ARRAY
3259: PPUSH
3260: LD_EXP 53
3264: PUSH
3265: LD_INT 1
3267: ARRAY
3268: PUSH
3269: LD_INT 3
3271: ARRAY
3272: PPUSH
3273: CALL_OW 12
3277: ST_TO_ADDR
// amSnipers = Rand ( enemyAttackUnitsData [ 1 ] [ 4 ] , enemyAttackUnitsData [ 1 ] [ 5 ] ) ;
3278: LD_ADDR_VAR 0 9
3282: PUSH
3283: LD_EXP 53
3287: PUSH
3288: LD_INT 1
3290: ARRAY
3291: PUSH
3292: LD_INT 4
3294: ARRAY
3295: PPUSH
3296: LD_EXP 53
3300: PUSH
3301: LD_INT 1
3303: ARRAY
3304: PUSH
3305: LD_INT 5
3307: ARRAY
3308: PPUSH
3309: CALL_OW 12
3313: ST_TO_ADDR
// amVehs = Rand ( enemyAttackUnitsData [ 1 ] [ 6 ] , enemyAttackUnitsData [ 1 ] [ 7 ] ) ;
3314: LD_ADDR_VAR 0 10
3318: PUSH
3319: LD_EXP 53
3323: PUSH
3324: LD_INT 1
3326: ARRAY
3327: PUSH
3328: LD_INT 6
3330: ARRAY
3331: PPUSH
3332: LD_EXP 53
3336: PUSH
3337: LD_INT 1
3339: ARRAY
3340: PUSH
3341: LD_INT 7
3343: ARRAY
3344: PPUSH
3345: CALL_OW 12
3349: ST_TO_ADDR
// if paidLegionOffert then
3350: LD_EXP 32
3354: IFFALSE 3388
// begin amSolds = amSolds - legionReduceAmericansUnits ;
3356: LD_ADDR_VAR 0 8
3360: PUSH
3361: LD_VAR 0 8
3365: PUSH
3366: LD_EXP 51
3370: MINUS
3371: ST_TO_ADDR
// amVehs = amVehs - legionReduceAmericansUnits ;
3372: LD_ADDR_VAR 0 10
3376: PUSH
3377: LD_VAR 0 10
3381: PUSH
3382: LD_EXP 51
3386: MINUS
3387: ST_TO_ADDR
// end ; for i := 1 to amSolds do
3388: LD_ADDR_VAR 0 2
3392: PUSH
3393: DOUBLE
3394: LD_INT 1
3396: DEC
3397: ST_TO_ADDR
3398: LD_VAR 0 8
3402: PUSH
3403: FOR_TO
3404: IFFALSE 3461
// begin PrepareSoldier ( false , enemySkillLevel ) ;
3406: LD_INT 0
3408: PPUSH
3409: LD_EXP 56
3413: PPUSH
3414: CALL_OW 381
// unit = CreateHuman ;
3418: LD_ADDR_VAR 0 3
3422: PUSH
3423: CALL_OW 44
3427: ST_TO_ADDR
// PlaceUnitArea ( unit , AmericanSpawnArea , false ) ;
3428: LD_VAR 0 3
3432: PPUSH
3433: LD_INT 3
3435: PPUSH
3436: LD_INT 0
3438: PPUSH
3439: CALL_OW 49
// amAttackTeam = amAttackTeam ^ unit ;
3443: LD_ADDR_EXP 78
3447: PUSH
3448: LD_EXP 78
3452: PUSH
3453: LD_VAR 0 3
3457: ADD
3458: ST_TO_ADDR
// end ;
3459: GO 3403
3461: POP
3462: POP
// for i := 1 to amSnipers do
3463: LD_ADDR_VAR 0 2
3467: PUSH
3468: DOUBLE
3469: LD_INT 1
3471: DEC
3472: ST_TO_ADDR
3473: LD_VAR 0 9
3477: PUSH
3478: FOR_TO
3479: IFFALSE 3539
// begin PrepareHuman ( false , class_sniper , enemySkillLevel ) ;
3481: LD_INT 0
3483: PPUSH
3484: LD_INT 5
3486: PPUSH
3487: LD_EXP 56
3491: PPUSH
3492: CALL_OW 380
// unit = CreateHuman ;
3496: LD_ADDR_VAR 0 3
3500: PUSH
3501: CALL_OW 44
3505: ST_TO_ADDR
// PlaceUnitArea ( unit , AmericanSpawnArea , false ) ;
3506: LD_VAR 0 3
3510: PPUSH
3511: LD_INT 3
3513: PPUSH
3514: LD_INT 0
3516: PPUSH
3517: CALL_OW 49
// amAttackTeam = amAttackTeam ^ unit ;
3521: LD_ADDR_EXP 78
3525: PUSH
3526: LD_EXP 78
3530: PUSH
3531: LD_VAR 0 3
3535: ADD
3536: ST_TO_ADDR
// end ;
3537: GO 3478
3539: POP
3540: POP
// for i := 1 to amVehs do
3541: LD_ADDR_VAR 0 2
3545: PUSH
3546: DOUBLE
3547: LD_INT 1
3549: DEC
3550: ST_TO_ADDR
3551: LD_VAR 0 10
3555: PUSH
3556: FOR_TO
3557: IFFALSE 3840
// begin randVehType = Rand ( 1 , 4 ) ;
3559: LD_ADDR_VAR 0 5
3563: PUSH
3564: LD_INT 1
3566: PPUSH
3567: LD_INT 4
3569: PPUSH
3570: CALL_OW 12
3574: ST_TO_ADDR
// weapon = [ us_gatling_gun , us_double_gun , us_light_gun , us_rocket_launcher , us_heavy_gun ] [ Rand ( 1 , 5 ) ] ;
3575: LD_ADDR_VAR 0 6
3579: PUSH
3580: LD_INT 4
3582: PUSH
3583: LD_INT 5
3585: PUSH
3586: LD_INT 3
3588: PUSH
3589: LD_INT 7
3591: PUSH
3592: LD_INT 6
3594: PUSH
3595: EMPTY
3596: LIST
3597: LIST
3598: LIST
3599: LIST
3600: LIST
3601: PUSH
3602: LD_INT 1
3604: PPUSH
3605: LD_INT 5
3607: PPUSH
3608: CALL_OW 12
3612: ARRAY
3613: ST_TO_ADDR
// if weapon = us_heavy_gun then
3614: LD_VAR 0 6
3618: PUSH
3619: LD_INT 6
3621: EQUAL
3622: IFFALSE 3634
// chassis = us_heavy_tracked else
3624: LD_ADDR_VAR 0 7
3628: PUSH
3629: LD_INT 4
3631: ST_TO_ADDR
3632: GO 3661
// chassis = [ us_medium_tracked , us_heavy_tracked ] [ Rand ( 1 , 2 ) ] ;
3634: LD_ADDR_VAR 0 7
3638: PUSH
3639: LD_INT 3
3641: PUSH
3642: LD_INT 4
3644: PUSH
3645: EMPTY
3646: LIST
3647: LIST
3648: PUSH
3649: LD_INT 1
3651: PPUSH
3652: LD_INT 2
3654: PPUSH
3655: CALL_OW 12
3659: ARRAY
3660: ST_TO_ADDR
// if randVehType = 1 then
3661: LD_VAR 0 5
3665: PUSH
3666: LD_INT 1
3668: EQUAL
3669: IFFALSE 3704
// PrepareVehicle ( chassis , engine_combustion , control_manual , weapon , Rand ( 70 , 90 ) ) else
3671: LD_VAR 0 7
3675: PPUSH
3676: LD_INT 1
3678: PPUSH
3679: LD_INT 1
3681: PPUSH
3682: LD_VAR 0 6
3686: PPUSH
3687: LD_INT 70
3689: PPUSH
3690: LD_INT 90
3692: PPUSH
3693: CALL_OW 12
3697: PPUSH
3698: CALL 24088 0 5
3702: GO 3735
// PrepareVehicle ( chassis , engine_combustion , control_computer , weapon , Rand ( 70 , 90 ) ) ;
3704: LD_VAR 0 7
3708: PPUSH
3709: LD_INT 1
3711: PPUSH
3712: LD_INT 3
3714: PPUSH
3715: LD_VAR 0 6
3719: PPUSH
3720: LD_INT 70
3722: PPUSH
3723: LD_INT 90
3725: PPUSH
3726: CALL_OW 12
3730: PPUSH
3731: CALL 24088 0 5
// veh = CreateVehicle ;
3735: LD_ADDR_VAR 0 4
3739: PUSH
3740: CALL_OW 45
3744: ST_TO_ADDR
// PlaceUnitArea ( veh , AmericanSpawnArea , false ) ;
3745: LD_VAR 0 4
3749: PPUSH
3750: LD_INT 3
3752: PPUSH
3753: LD_INT 0
3755: PPUSH
3756: CALL_OW 49
// amAttackTeam = amAttackTeam ^ veh ;
3760: LD_ADDR_EXP 78
3764: PUSH
3765: LD_EXP 78
3769: PUSH
3770: LD_VAR 0 4
3774: ADD
3775: ST_TO_ADDR
// if randVehType = 1 then
3776: LD_VAR 0 5
3780: PUSH
3781: LD_INT 1
3783: EQUAL
3784: IFFALSE 3838
// begin PrepareMechanic ( false , enemySkillLevel ) ;
3786: LD_INT 0
3788: PPUSH
3789: LD_EXP 56
3793: PPUSH
3794: CALL_OW 383
// unit = CreateHuman ;
3798: LD_ADDR_VAR 0 3
3802: PUSH
3803: CALL_OW 44
3807: ST_TO_ADDR
// PlaceHumanInUnit ( unit , veh ) ;
3808: LD_VAR 0 3
3812: PPUSH
3813: LD_VAR 0 4
3817: PPUSH
3818: CALL_OW 52
// amAttackTeam = amAttackTeam ^ unit ;
3822: LD_ADDR_EXP 78
3826: PUSH
3827: LD_EXP 78
3831: PUSH
3832: LD_VAR 0 3
3836: ADD
3837: ST_TO_ADDR
// end ; end ;
3838: GO 3556
3840: POP
3841: POP
// end ; end_of_file
3842: LD_VAR 0 1
3846: RET
// export Heike , Kurt , Dietrich ; export KurtEng ; export GensherTeam ; export arAttackTeam ; export function PrepareArabians ; begin
3847: LD_INT 0
3849: PPUSH
// arAttackTeam = [ ] ;
3850: LD_ADDR_EXP 84
3854: PUSH
3855: EMPTY
3856: ST_TO_ADDR
// PrepareHeroes ;
3857: CALL 4262 0 0
// case Difficulty of 2 :
3861: LD_OWVAR 67
3865: PUSH
3866: LD_INT 2
3868: DOUBLE
3869: EQUAL
3870: IFTRUE 3874
3872: GO 3890
3874: POP
// begin SetTech ( tech_stimDrugs , 8 , state_researched ) ;
3875: LD_INT 5
3877: PPUSH
3878: LD_INT 8
3880: PPUSH
3881: LD_INT 2
3883: PPUSH
3884: CALL_OW 322
// end ; 3 :
3888: GO 3941
3890: LD_INT 3
3892: DOUBLE
3893: EQUAL
3894: IFTRUE 3898
3896: GO 3940
3898: POP
// begin SetTech ( tech_stimDrugs , 8 , state_researched ) ;
3899: LD_INT 5
3901: PPUSH
3902: LD_INT 8
3904: PPUSH
3905: LD_INT 2
3907: PPUSH
3908: CALL_OW 322
// SetTech ( tech_bio1 , 8 , state_researched ) ;
3912: LD_INT 66
3914: PPUSH
3915: LD_INT 8
3917: PPUSH
3918: LD_INT 2
3920: PPUSH
3921: CALL_OW 322
// SetTech ( tech_weap3 , 8 , state_researched ) ;
3925: LD_INT 53
3927: PPUSH
3928: LD_INT 8
3930: PPUSH
3931: LD_INT 2
3933: PPUSH
3934: CALL_OW 322
// end ; end ;
3938: GO 3941
3940: POP
// end ;
3941: LD_VAR 0 1
3945: RET
// export function SpawnGensherTeam ; var i , driver , veh ; begin
3946: LD_INT 0
3948: PPUSH
3949: PPUSH
3950: PPUSH
3951: PPUSH
// GensherTeam = [ ] ;
3952: LD_ADDR_EXP 83
3956: PUSH
3957: EMPTY
3958: ST_TO_ADDR
// uc_side = 2 ;
3959: LD_ADDR_OWVAR 20
3963: PUSH
3964: LD_INT 2
3966: ST_TO_ADDR
// uc_nation = 2 ;
3967: LD_ADDR_OWVAR 21
3971: PUSH
3972: LD_INT 2
3974: ST_TO_ADDR
// for i := 1 to 3 do
3975: LD_ADDR_VAR 0 2
3979: PUSH
3980: DOUBLE
3981: LD_INT 1
3983: DEC
3984: ST_TO_ADDR
3985: LD_INT 3
3987: PUSH
3988: FOR_TO
3989: IFFALSE 4148
// begin PrepareSoldier ( sex_male , rand ( 3 , 5 ) ) ;
3991: LD_INT 1
3993: PPUSH
3994: LD_INT 3
3996: PPUSH
3997: LD_INT 5
3999: PPUSH
4000: CALL_OW 12
4004: PPUSH
4005: CALL_OW 381
// driver = CreateHuman ;
4009: LD_ADDR_VAR 0 3
4013: PUSH
4014: CALL_OW 44
4018: ST_TO_ADDR
// PrepareVehicle ( ar_medium_trike , engine_combustion , control_manual , ar_cargo_bay , rand ( 50 , 70 ) ) ;
4019: LD_INT 13
4021: PPUSH
4022: LD_INT 1
4024: PPUSH
4025: LD_INT 1
4027: PPUSH
4028: LD_INT 32
4030: PPUSH
4031: LD_INT 50
4033: PPUSH
4034: LD_INT 70
4036: PPUSH
4037: CALL_OW 12
4041: PPUSH
4042: CALL 24088 0 5
// veh = CreateVehicle ;
4046: LD_ADDR_VAR 0 4
4050: PUSH
4051: CALL_OW 45
4055: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
4056: LD_VAR 0 4
4060: PPUSH
4061: LD_INT 4
4063: PPUSH
4064: CALL_OW 233
// PlaceUnitArea ( veh , GensherSpawnArea , false ) ;
4068: LD_VAR 0 4
4072: PPUSH
4073: LD_INT 4
4075: PPUSH
4076: LD_INT 0
4078: PPUSH
4079: CALL_OW 49
// PlaceHumanInUnit ( driver , veh ) ;
4083: LD_VAR 0 3
4087: PPUSH
4088: LD_VAR 0 4
4092: PPUSH
4093: CALL_OW 52
// AddCargo ( veh , i , 100 ) ;
4097: LD_VAR 0 4
4101: PPUSH
4102: LD_VAR 0 2
4106: PPUSH
4107: LD_INT 100
4109: PPUSH
4110: CALL_OW 291
// GensherTeam = GensherTeam ^ driver ;
4114: LD_ADDR_EXP 83
4118: PUSH
4119: LD_EXP 83
4123: PUSH
4124: LD_VAR 0 3
4128: ADD
4129: ST_TO_ADDR
// GensherTeam = GensherTeam ^ veh ;
4130: LD_ADDR_EXP 83
4134: PUSH
4135: LD_EXP 83
4139: PUSH
4140: LD_VAR 0 4
4144: ADD
4145: ST_TO_ADDR
// end ;
4146: GO 3988
4148: POP
4149: POP
// if IsOK ( KurtEng ) and GetSide ( KurtEng ) = 3 then
4150: LD_EXP 82
4154: PPUSH
4155: CALL_OW 302
4159: PUSH
4160: LD_EXP 82
4164: PPUSH
4165: CALL_OW 255
4169: PUSH
4170: LD_INT 3
4172: EQUAL
4173: AND
4174: IFFALSE 4208
// begin GensherTargetX = GetX ( Kurt ) ;
4176: LD_ADDR_EXP 16
4180: PUSH
4181: LD_EXP 80
4185: PPUSH
4186: CALL_OW 250
4190: ST_TO_ADDR
// GensherTargetY = GetY ( Kurt ) ;
4191: LD_ADDR_EXP 17
4195: PUSH
4196: LD_EXP 80
4200: PPUSH
4201: CALL_OW 251
4205: ST_TO_ADDR
// end else
4206: GO 4238
// begin GensherTargetX = GetX ( Burlak ) ;
4208: LD_ADDR_EXP 16
4212: PUSH
4213: LD_EXP 57
4217: PPUSH
4218: CALL_OW 250
4222: ST_TO_ADDR
// GensherTargetY = GetY ( Burlak ) ;
4223: LD_ADDR_EXP 17
4227: PUSH
4228: LD_EXP 57
4232: PPUSH
4233: CALL_OW 251
4237: ST_TO_ADDR
// end ; ComMoveXY ( GensherTeam , GensherTargetX , GensherTargetY ) ;
4238: LD_EXP 83
4242: PPUSH
4243: LD_EXP 16
4247: PPUSH
4248: LD_EXP 17
4252: PPUSH
4253: CALL_OW 111
// end ;
4257: LD_VAR 0 1
4261: RET
// function PrepareHeroes ; begin
4262: LD_INT 0
4264: PPUSH
// uc_side = 5 ;
4265: LD_ADDR_OWVAR 20
4269: PUSH
4270: LD_INT 5
4272: ST_TO_ADDR
// uc_nation = 2 ;
4273: LD_ADDR_OWVAR 21
4277: PUSH
4278: LD_INT 2
4280: ST_TO_ADDR
// Heike = PrepareUnitExt ( Heike , true , class_engineer ) ;
4281: LD_ADDR_EXP 79
4285: PUSH
4286: LD_STRING Heike
4288: PPUSH
4289: LD_INT 1
4291: PPUSH
4292: LD_INT 2
4294: PPUSH
4295: CALL 5930 0 3
4299: ST_TO_ADDR
// uc_side = 8 ;
4300: LD_ADDR_OWVAR 20
4304: PUSH
4305: LD_INT 8
4307: ST_TO_ADDR
// Kurt = PrepareUnitExt ( Kurt , false , 0 ) ;
4308: LD_ADDR_EXP 80
4312: PUSH
4313: LD_STRING Kurt
4315: PPUSH
4316: LD_INT 0
4318: PPUSH
4319: LD_INT 0
4321: PPUSH
4322: CALL 5930 0 3
4326: ST_TO_ADDR
// uc_side = 2 ;
4327: LD_ADDR_OWVAR 20
4331: PUSH
4332: LD_INT 2
4334: ST_TO_ADDR
// Dietrich = PrepareUnitExt ( Dietrich , false , 0 ) ;
4335: LD_ADDR_EXP 81
4339: PUSH
4340: LD_STRING Dietrich
4342: PPUSH
4343: LD_INT 0
4345: PPUSH
4346: LD_INT 0
4348: PPUSH
4349: CALL 5930 0 3
4353: ST_TO_ADDR
// end ;
4354: LD_VAR 0 1
4358: RET
// export function SpawnArAttackTeam ; var i , unit , veh , weapon , chassis ; begin
4359: LD_INT 0
4361: PPUSH
4362: PPUSH
4363: PPUSH
4364: PPUSH
4365: PPUSH
4366: PPUSH
// uc_side = 8 ;
4367: LD_ADDR_OWVAR 20
4371: PUSH
4372: LD_INT 8
4374: ST_TO_ADDR
// uc_nation = 2 ;
4375: LD_ADDR_OWVAR 21
4379: PUSH
4380: LD_INT 2
4382: ST_TO_ADDR
// for i := 1 to Rand ( enemyAttackUnitsData [ 1 ] [ 2 ] , enemyAttackUnitsData [ 1 ] [ 3 ] ) do
4383: LD_ADDR_VAR 0 2
4387: PUSH
4388: DOUBLE
4389: LD_INT 1
4391: DEC
4392: ST_TO_ADDR
4393: LD_EXP 53
4397: PUSH
4398: LD_INT 1
4400: ARRAY
4401: PUSH
4402: LD_INT 2
4404: ARRAY
4405: PPUSH
4406: LD_EXP 53
4410: PUSH
4411: LD_INT 1
4413: ARRAY
4414: PUSH
4415: LD_INT 3
4417: ARRAY
4418: PPUSH
4419: CALL_OW 12
4423: PUSH
4424: FOR_TO
4425: IFFALSE 4482
// begin PrepareSoldier ( false , enemySkillLevel ) ;
4427: LD_INT 0
4429: PPUSH
4430: LD_EXP 56
4434: PPUSH
4435: CALL_OW 381
// unit = CreateHuman ;
4439: LD_ADDR_VAR 0 3
4443: PUSH
4444: CALL_OW 44
4448: ST_TO_ADDR
// PlaceUnitArea ( unit , KurtUnitsSpawnArea , false ) ;
4449: LD_VAR 0 3
4453: PPUSH
4454: LD_INT 10
4456: PPUSH
4457: LD_INT 0
4459: PPUSH
4460: CALL_OW 49
// arAttackTeam = arAttackTeam ^ unit ;
4464: LD_ADDR_EXP 84
4468: PUSH
4469: LD_EXP 84
4473: PUSH
4474: LD_VAR 0 3
4478: ADD
4479: ST_TO_ADDR
// end ;
4480: GO 4424
4482: POP
4483: POP
// for i := 1 to Rand ( enemyAttackUnitsData [ 1 ] [ 4 ] , enemyAttackUnitsData [ 1 ] [ 5 ] ) do
4484: LD_ADDR_VAR 0 2
4488: PUSH
4489: DOUBLE
4490: LD_INT 1
4492: DEC
4493: ST_TO_ADDR
4494: LD_EXP 53
4498: PUSH
4499: LD_INT 1
4501: ARRAY
4502: PUSH
4503: LD_INT 4
4505: ARRAY
4506: PPUSH
4507: LD_EXP 53
4511: PUSH
4512: LD_INT 1
4514: ARRAY
4515: PUSH
4516: LD_INT 5
4518: ARRAY
4519: PPUSH
4520: CALL_OW 12
4524: PUSH
4525: FOR_TO
4526: IFFALSE 4586
// begin PrepareHuman ( false , class_mortar , enemySkillLevel ) ;
4528: LD_INT 0
4530: PPUSH
4531: LD_INT 8
4533: PPUSH
4534: LD_EXP 56
4538: PPUSH
4539: CALL_OW 380
// unit = CreateHuman ;
4543: LD_ADDR_VAR 0 3
4547: PUSH
4548: CALL_OW 44
4552: ST_TO_ADDR
// PlaceUnitArea ( unit , KurtUnitsSpawnArea , false ) ;
4553: LD_VAR 0 3
4557: PPUSH
4558: LD_INT 10
4560: PPUSH
4561: LD_INT 0
4563: PPUSH
4564: CALL_OW 49
// arAttackTeam = arAttackTeam ^ unit ;
4568: LD_ADDR_EXP 84
4572: PUSH
4573: LD_EXP 84
4577: PUSH
4578: LD_VAR 0 3
4582: ADD
4583: ST_TO_ADDR
// end ;
4584: GO 4525
4586: POP
4587: POP
// for i := 1 to Rand ( enemyAttackUnitsData [ 1 ] [ 6 ] , enemyAttackUnitsData [ 1 ] [ 7 ] ) do
4588: LD_ADDR_VAR 0 2
4592: PUSH
4593: DOUBLE
4594: LD_INT 1
4596: DEC
4597: ST_TO_ADDR
4598: LD_EXP 53
4602: PUSH
4603: LD_INT 1
4605: ARRAY
4606: PUSH
4607: LD_INT 6
4609: ARRAY
4610: PPUSH
4611: LD_EXP 53
4615: PUSH
4616: LD_INT 1
4618: ARRAY
4619: PUSH
4620: LD_INT 7
4622: ARRAY
4623: PPUSH
4624: CALL_OW 12
4628: PUSH
4629: FOR_TO
4630: IFFALSE 4824
// begin weapon = [ ar_gun , ar_flame_thrower , ar_rocket_launcher , ar_light_gun , ar_gatling_gun ] [ Rand ( 1 , 5 ) ] ;
4632: LD_ADDR_VAR 0 5
4636: PUSH
4637: LD_INT 27
4639: PUSH
4640: LD_INT 26
4642: PUSH
4643: LD_INT 28
4645: PUSH
4646: LD_INT 23
4648: PUSH
4649: LD_INT 25
4651: PUSH
4652: EMPTY
4653: LIST
4654: LIST
4655: LIST
4656: LIST
4657: LIST
4658: PUSH
4659: LD_INT 1
4661: PPUSH
4662: LD_INT 5
4664: PPUSH
4665: CALL_OW 12
4669: ARRAY
4670: ST_TO_ADDR
// chassis = [ ar_medium_trike , ar_half_tracked ] [ Rand ( 1 , 2 ) ] ;
4671: LD_ADDR_VAR 0 6
4675: PUSH
4676: LD_INT 13
4678: PUSH
4679: LD_INT 14
4681: PUSH
4682: EMPTY
4683: LIST
4684: LIST
4685: PUSH
4686: LD_INT 1
4688: PPUSH
4689: LD_INT 2
4691: PPUSH
4692: CALL_OW 12
4696: ARRAY
4697: ST_TO_ADDR
// PrepareVehicle ( chassis , engine_combustion , control_manual , weapon , Rand ( 70 , 90 ) ) ;
4698: LD_VAR 0 6
4702: PPUSH
4703: LD_INT 1
4705: PPUSH
4706: LD_INT 1
4708: PPUSH
4709: LD_VAR 0 5
4713: PPUSH
4714: LD_INT 70
4716: PPUSH
4717: LD_INT 90
4719: PPUSH
4720: CALL_OW 12
4724: PPUSH
4725: CALL 24088 0 5
// veh = CreateVehicle ;
4729: LD_ADDR_VAR 0 4
4733: PUSH
4734: CALL_OW 45
4738: ST_TO_ADDR
// PlaceUnitArea ( veh , KurtUnitsSpawnArea , false ) ;
4739: LD_VAR 0 4
4743: PPUSH
4744: LD_INT 10
4746: PPUSH
4747: LD_INT 0
4749: PPUSH
4750: CALL_OW 49
// arAttackTeam = arAttackTeam ^ veh ;
4754: LD_ADDR_EXP 84
4758: PUSH
4759: LD_EXP 84
4763: PUSH
4764: LD_VAR 0 4
4768: ADD
4769: ST_TO_ADDR
// PrepareMechanic ( false , enemySkillLevel ) ;
4770: LD_INT 0
4772: PPUSH
4773: LD_EXP 56
4777: PPUSH
4778: CALL_OW 383
// unit = CreateHuman ;
4782: LD_ADDR_VAR 0 3
4786: PUSH
4787: CALL_OW 44
4791: ST_TO_ADDR
// PlaceHumanInUnit ( unit , veh ) ;
4792: LD_VAR 0 3
4796: PPUSH
4797: LD_VAR 0 4
4801: PPUSH
4802: CALL_OW 52
// arAttackTeam = arAttackTeam ^ unit ;
4806: LD_ADDR_EXP 84
4810: PUSH
4811: LD_EXP 84
4815: PUSH
4816: LD_VAR 0 3
4820: ADD
4821: ST_TO_ADDR
// end ;
4822: GO 4629
4824: POP
4825: POP
// end ; end_of_file
4826: LD_VAR 0 1
4830: RET
// export function Nef_PrepareNature ; var i , un ; begin
4831: LD_INT 0
4833: PPUSH
4834: PPUSH
4835: PPUSH
// for i := 1 to animalsAmount [ 1 ] do
4836: LD_ADDR_VAR 0 2
4840: PUSH
4841: DOUBLE
4842: LD_INT 1
4844: DEC
4845: ST_TO_ADDR
4846: LD_EXP 41
4850: PUSH
4851: LD_INT 1
4853: ARRAY
4854: PUSH
4855: FOR_TO
4856: IFFALSE 4966
// begin uc_side = 0 ;
4858: LD_ADDR_OWVAR 20
4862: PUSH
4863: LD_INT 0
4865: ST_TO_ADDR
// uc_nation = nation_nature ;
4866: LD_ADDR_OWVAR 21
4870: PUSH
4871: LD_INT 0
4873: ST_TO_ADDR
// hc_class = class_apeman ;
4874: LD_ADDR_OWVAR 28
4878: PUSH
4879: LD_INT 12
4881: ST_TO_ADDR
// hc_skills = [ animalsStats [ 1 ] , animalsStats [ 2 ] , animalsStats [ 3 ] , animalsStats [ 4 ] ] ;
4882: LD_ADDR_OWVAR 31
4886: PUSH
4887: LD_EXP 42
4891: PUSH
4892: LD_INT 1
4894: ARRAY
4895: PUSH
4896: LD_EXP 42
4900: PUSH
4901: LD_INT 2
4903: ARRAY
4904: PUSH
4905: LD_EXP 42
4909: PUSH
4910: LD_INT 3
4912: ARRAY
4913: PUSH
4914: LD_EXP 42
4918: PUSH
4919: LD_INT 4
4921: ARRAY
4922: PUSH
4923: EMPTY
4924: LIST
4925: LIST
4926: LIST
4927: LIST
4928: ST_TO_ADDR
// hc_agressivity = animalsAgression ;
4929: LD_ADDR_OWVAR 35
4933: PUSH
4934: LD_EXP 43
4938: ST_TO_ADDR
// un = CreateHuman ;
4939: LD_ADDR_VAR 0 3
4943: PUSH
4944: CALL_OW 44
4948: ST_TO_ADDR
// PlaceUnitArea ( un , NatureArea , false ) ;
4949: LD_VAR 0 3
4953: PPUSH
4954: LD_INT 5
4956: PPUSH
4957: LD_INT 0
4959: PPUSH
4960: CALL_OW 49
// end ;
4964: GO 4855
4966: POP
4967: POP
// for i := 1 to animalsAmount [ 2 ] do
4968: LD_ADDR_VAR 0 2
4972: PUSH
4973: DOUBLE
4974: LD_INT 1
4976: DEC
4977: ST_TO_ADDR
4978: LD_EXP 41
4982: PUSH
4983: LD_INT 2
4985: ARRAY
4986: PUSH
4987: FOR_TO
4988: IFFALSE 5098
// begin uc_side = 0 ;
4990: LD_ADDR_OWVAR 20
4994: PUSH
4995: LD_INT 0
4997: ST_TO_ADDR
// uc_nation = nation_nature ;
4998: LD_ADDR_OWVAR 21
5002: PUSH
5003: LD_INT 0
5005: ST_TO_ADDR
// hc_class = class_phororhacos ;
5006: LD_ADDR_OWVAR 28
5010: PUSH
5011: LD_INT 18
5013: ST_TO_ADDR
// hc_skills = [ animalsStats [ 1 ] , animalsStats [ 2 ] , animalsStats [ 3 ] , animalsStats [ 4 ] ] ;
5014: LD_ADDR_OWVAR 31
5018: PUSH
5019: LD_EXP 42
5023: PUSH
5024: LD_INT 1
5026: ARRAY
5027: PUSH
5028: LD_EXP 42
5032: PUSH
5033: LD_INT 2
5035: ARRAY
5036: PUSH
5037: LD_EXP 42
5041: PUSH
5042: LD_INT 3
5044: ARRAY
5045: PUSH
5046: LD_EXP 42
5050: PUSH
5051: LD_INT 4
5053: ARRAY
5054: PUSH
5055: EMPTY
5056: LIST
5057: LIST
5058: LIST
5059: LIST
5060: ST_TO_ADDR
// hc_agressivity = animalsAgression ;
5061: LD_ADDR_OWVAR 35
5065: PUSH
5066: LD_EXP 43
5070: ST_TO_ADDR
// un = CreateHuman ;
5071: LD_ADDR_VAR 0 3
5075: PUSH
5076: CALL_OW 44
5080: ST_TO_ADDR
// PlaceUnitArea ( un , NatureArea , false ) ;
5081: LD_VAR 0 3
5085: PPUSH
5086: LD_INT 5
5088: PPUSH
5089: LD_INT 0
5091: PPUSH
5092: CALL_OW 49
// end ;
5096: GO 4987
5098: POP
5099: POP
// for i := 1 to animalsAmount [ 3 ] do
5100: LD_ADDR_VAR 0 2
5104: PUSH
5105: DOUBLE
5106: LD_INT 1
5108: DEC
5109: ST_TO_ADDR
5110: LD_EXP 41
5114: PUSH
5115: LD_INT 3
5117: ARRAY
5118: PUSH
5119: FOR_TO
5120: IFFALSE 5230
// begin uc_side = 0 ;
5122: LD_ADDR_OWVAR 20
5126: PUSH
5127: LD_INT 0
5129: ST_TO_ADDR
// uc_nation = nation_nature ;
5130: LD_ADDR_OWVAR 21
5134: PUSH
5135: LD_INT 0
5137: ST_TO_ADDR
// hc_class = class_tiger ;
5138: LD_ADDR_OWVAR 28
5142: PUSH
5143: LD_INT 14
5145: ST_TO_ADDR
// hc_skills = [ animalsStats [ 1 ] , animalsStats [ 2 ] , animalsStats [ 3 ] , animalsStats [ 4 ] ] ;
5146: LD_ADDR_OWVAR 31
5150: PUSH
5151: LD_EXP 42
5155: PUSH
5156: LD_INT 1
5158: ARRAY
5159: PUSH
5160: LD_EXP 42
5164: PUSH
5165: LD_INT 2
5167: ARRAY
5168: PUSH
5169: LD_EXP 42
5173: PUSH
5174: LD_INT 3
5176: ARRAY
5177: PUSH
5178: LD_EXP 42
5182: PUSH
5183: LD_INT 4
5185: ARRAY
5186: PUSH
5187: EMPTY
5188: LIST
5189: LIST
5190: LIST
5191: LIST
5192: ST_TO_ADDR
// hc_agressivity = animalsAgression ;
5193: LD_ADDR_OWVAR 35
5197: PUSH
5198: LD_EXP 43
5202: ST_TO_ADDR
// un = CreateHuman ;
5203: LD_ADDR_VAR 0 3
5207: PUSH
5208: CALL_OW 44
5212: ST_TO_ADDR
// PlaceUnitArea ( un , NatureArea , false ) ;
5213: LD_VAR 0 3
5217: PPUSH
5218: LD_INT 5
5220: PPUSH
5221: LD_INT 0
5223: PPUSH
5224: CALL_OW 49
// end ;
5228: GO 5119
5230: POP
5231: POP
// for i := 1 to animalsAmount [ 4 ] do
5232: LD_ADDR_VAR 0 2
5236: PUSH
5237: DOUBLE
5238: LD_INT 1
5240: DEC
5241: ST_TO_ADDR
5242: LD_EXP 41
5246: PUSH
5247: LD_INT 4
5249: ARRAY
5250: PUSH
5251: FOR_TO
5252: IFFALSE 5362
// begin uc_side = 0 ;
5254: LD_ADDR_OWVAR 20
5258: PUSH
5259: LD_INT 0
5261: ST_TO_ADDR
// uc_nation = nation_nature ;
5262: LD_ADDR_OWVAR 21
5266: PUSH
5267: LD_INT 0
5269: ST_TO_ADDR
// hc_class = 21 ;
5270: LD_ADDR_OWVAR 28
5274: PUSH
5275: LD_INT 21
5277: ST_TO_ADDR
// hc_skills = [ animalsStats [ 1 ] , animalsStats [ 2 ] , animalsStats [ 3 ] , animalsStats [ 4 ] ] ;
5278: LD_ADDR_OWVAR 31
5282: PUSH
5283: LD_EXP 42
5287: PUSH
5288: LD_INT 1
5290: ARRAY
5291: PUSH
5292: LD_EXP 42
5296: PUSH
5297: LD_INT 2
5299: ARRAY
5300: PUSH
5301: LD_EXP 42
5305: PUSH
5306: LD_INT 3
5308: ARRAY
5309: PUSH
5310: LD_EXP 42
5314: PUSH
5315: LD_INT 4
5317: ARRAY
5318: PUSH
5319: EMPTY
5320: LIST
5321: LIST
5322: LIST
5323: LIST
5324: ST_TO_ADDR
// hc_agressivity = animalsAgression ;
5325: LD_ADDR_OWVAR 35
5329: PUSH
5330: LD_EXP 43
5334: ST_TO_ADDR
// un = CreateHuman ;
5335: LD_ADDR_VAR 0 3
5339: PUSH
5340: CALL_OW 44
5344: ST_TO_ADDR
// PlaceUnitArea ( un , NatureArea , false ) ;
5345: LD_VAR 0 3
5349: PPUSH
5350: LD_INT 5
5352: PPUSH
5353: LD_INT 0
5355: PPUSH
5356: CALL_OW 49
// end ;
5360: GO 5251
5362: POP
5363: POP
// for i := 1 to animalsAmount [ 5 ] do
5364: LD_ADDR_VAR 0 2
5368: PUSH
5369: DOUBLE
5370: LD_INT 1
5372: DEC
5373: ST_TO_ADDR
5374: LD_EXP 41
5378: PUSH
5379: LD_INT 5
5381: ARRAY
5382: PUSH
5383: FOR_TO
5384: IFFALSE 5445
// begin uc_side = 0 ;
5386: LD_ADDR_OWVAR 20
5390: PUSH
5391: LD_INT 0
5393: ST_TO_ADDR
// uc_nation = nation_nature ;
5394: LD_ADDR_OWVAR 21
5398: PUSH
5399: LD_INT 0
5401: ST_TO_ADDR
// vc_chassis := 31 ;
5402: LD_ADDR_OWVAR 37
5406: PUSH
5407: LD_INT 31
5409: ST_TO_ADDR
// vc_control := control_rider ;
5410: LD_ADDR_OWVAR 38
5414: PUSH
5415: LD_INT 4
5417: ST_TO_ADDR
// un := CreateVehicle ;
5418: LD_ADDR_VAR 0 3
5422: PUSH
5423: CALL_OW 45
5427: ST_TO_ADDR
// PlaceUnitArea ( un , NatureArea , false ) ;
5428: LD_VAR 0 3
5432: PPUSH
5433: LD_INT 5
5435: PPUSH
5436: LD_INT 0
5438: PPUSH
5439: CALL_OW 49
// end ;
5443: GO 5383
5445: POP
5446: POP
// end ;
5447: LD_VAR 0 1
5451: RET
// export function SpawnTrees ; begin
5452: LD_INT 0
5454: PPUSH
// PlaceTreesToArea ( TreeArea , [ 2 , 10 , 11 , 27 , 35 ] , 40 , 10 , 4 ) ;
5455: LD_INT 1
5457: PPUSH
5458: LD_INT 2
5460: PUSH
5461: LD_INT 10
5463: PUSH
5464: LD_INT 11
5466: PUSH
5467: LD_INT 27
5469: PUSH
5470: LD_INT 35
5472: PUSH
5473: EMPTY
5474: LIST
5475: LIST
5476: LIST
5477: LIST
5478: LIST
5479: PPUSH
5480: LD_INT 40
5482: PPUSH
5483: LD_INT 10
5485: PPUSH
5486: LD_INT 4
5488: PPUSH
5489: CALL_OW 352
// PlaceTreesToArea ( TreeArea , [ 9 , 10 , 27 , 35 , 48 ] , 30 , 10 , 4 ) ;
5493: LD_INT 1
5495: PPUSH
5496: LD_INT 9
5498: PUSH
5499: LD_INT 10
5501: PUSH
5502: LD_INT 27
5504: PUSH
5505: LD_INT 35
5507: PUSH
5508: LD_INT 48
5510: PUSH
5511: EMPTY
5512: LIST
5513: LIST
5514: LIST
5515: LIST
5516: LIST
5517: PPUSH
5518: LD_INT 30
5520: PPUSH
5521: LD_INT 10
5523: PPUSH
5524: LD_INT 4
5526: PPUSH
5527: CALL_OW 352
// PlaceTreesToArea ( TreeArea , [ 2 , 9 , 10 , 11 , 27 ] , 60 , 10 , 4 ) ;
5531: LD_INT 1
5533: PPUSH
5534: LD_INT 2
5536: PUSH
5537: LD_INT 9
5539: PUSH
5540: LD_INT 10
5542: PUSH
5543: LD_INT 11
5545: PUSH
5546: LD_INT 27
5548: PUSH
5549: EMPTY
5550: LIST
5551: LIST
5552: LIST
5553: LIST
5554: LIST
5555: PPUSH
5556: LD_INT 60
5558: PPUSH
5559: LD_INT 10
5561: PPUSH
5562: LD_INT 4
5564: PPUSH
5565: CALL_OW 352
// PlaceTreesToArea ( TreeArea , [ 9 , 10 , 27 , 35 , 48 ] , 90 , 10 , 4 ) ;
5569: LD_INT 1
5571: PPUSH
5572: LD_INT 9
5574: PUSH
5575: LD_INT 10
5577: PUSH
5578: LD_INT 27
5580: PUSH
5581: LD_INT 35
5583: PUSH
5584: LD_INT 48
5586: PUSH
5587: EMPTY
5588: LIST
5589: LIST
5590: LIST
5591: LIST
5592: LIST
5593: PPUSH
5594: LD_INT 90
5596: PPUSH
5597: LD_INT 10
5599: PPUSH
5600: LD_INT 4
5602: PPUSH
5603: CALL_OW 352
// PlaceTreesToArea ( TreeArea , [ 2 , 9 , 10 , 11 , 48 ] , 120 , 10 , 4 ) ;
5607: LD_INT 1
5609: PPUSH
5610: LD_INT 2
5612: PUSH
5613: LD_INT 9
5615: PUSH
5616: LD_INT 10
5618: PUSH
5619: LD_INT 11
5621: PUSH
5622: LD_INT 48
5624: PUSH
5625: EMPTY
5626: LIST
5627: LIST
5628: LIST
5629: LIST
5630: LIST
5631: PPUSH
5632: LD_INT 120
5634: PPUSH
5635: LD_INT 10
5637: PPUSH
5638: LD_INT 4
5640: PPUSH
5641: CALL_OW 352
// PlaceTreesToArea ( TreeArea , [ 2 , 11 , 27 , 35 , 48 ] , 45 , 10 , 4 ) ;
5645: LD_INT 1
5647: PPUSH
5648: LD_INT 2
5650: PUSH
5651: LD_INT 11
5653: PUSH
5654: LD_INT 27
5656: PUSH
5657: LD_INT 35
5659: PUSH
5660: LD_INT 48
5662: PUSH
5663: EMPTY
5664: LIST
5665: LIST
5666: LIST
5667: LIST
5668: LIST
5669: PPUSH
5670: LD_INT 45
5672: PPUSH
5673: LD_INT 10
5675: PPUSH
5676: LD_INT 4
5678: PPUSH
5679: CALL_OW 352
// end ;
5683: LD_VAR 0 1
5687: RET
// every 0 0$1 do var i , un ;
5688: GO 5690
5690: DISABLE
5691: LD_INT 0
5693: PPUSH
5694: PPUSH
// begin if ( GetTech ( tech_apelang , 3 ) = state_enabled or GetTech ( tech_apepsych , 3 ) = state_enabled or GetTech ( tech_apeagres , 3 ) = state_enabled ) and not FilterAllUnits ( [ [ f_or , [ f_class , class_apeman ] , [ f_class , class_apeman_engineer ] , [ f_class , class_apeman_soldier ] ] ] ) then
5695: LD_INT 1
5697: PPUSH
5698: LD_INT 3
5700: PPUSH
5701: CALL_OW 321
5705: PUSH
5706: LD_INT 1
5708: EQUAL
5709: PUSH
5710: LD_INT 2
5712: PPUSH
5713: LD_INT 3
5715: PPUSH
5716: CALL_OW 321
5720: PUSH
5721: LD_INT 1
5723: EQUAL
5724: OR
5725: PUSH
5726: LD_INT 11
5728: PPUSH
5729: LD_INT 3
5731: PPUSH
5732: CALL_OW 321
5736: PUSH
5737: LD_INT 1
5739: EQUAL
5740: OR
5741: PUSH
5742: LD_INT 2
5744: PUSH
5745: LD_INT 25
5747: PUSH
5748: LD_INT 12
5750: PUSH
5751: EMPTY
5752: LIST
5753: LIST
5754: PUSH
5755: LD_INT 25
5757: PUSH
5758: LD_INT 16
5760: PUSH
5761: EMPTY
5762: LIST
5763: LIST
5764: PUSH
5765: LD_INT 25
5767: PUSH
5768: LD_INT 15
5770: PUSH
5771: EMPTY
5772: LIST
5773: LIST
5774: PUSH
5775: EMPTY
5776: LIST
5777: LIST
5778: LIST
5779: LIST
5780: PUSH
5781: EMPTY
5782: LIST
5783: PPUSH
5784: CALL_OW 69
5788: NOT
5789: AND
5790: IFFALSE 5926
// begin for i := 1 to Rand ( 2 , 4 ) do
5792: LD_ADDR_VAR 0 1
5796: PUSH
5797: DOUBLE
5798: LD_INT 1
5800: DEC
5801: ST_TO_ADDR
5802: LD_INT 2
5804: PPUSH
5805: LD_INT 4
5807: PPUSH
5808: CALL_OW 12
5812: PUSH
5813: FOR_TO
5814: IFFALSE 5924
// begin uc_side = 0 ;
5816: LD_ADDR_OWVAR 20
5820: PUSH
5821: LD_INT 0
5823: ST_TO_ADDR
// uc_nation = nation_nature ;
5824: LD_ADDR_OWVAR 21
5828: PUSH
5829: LD_INT 0
5831: ST_TO_ADDR
// hc_class = class_apeman ;
5832: LD_ADDR_OWVAR 28
5836: PUSH
5837: LD_INT 12
5839: ST_TO_ADDR
// hc_skills = [ animalsStats [ 1 ] , animalsStats [ 2 ] , animalsStats [ 3 ] , animalsStats [ 4 ] ] ;
5840: LD_ADDR_OWVAR 31
5844: PUSH
5845: LD_EXP 42
5849: PUSH
5850: LD_INT 1
5852: ARRAY
5853: PUSH
5854: LD_EXP 42
5858: PUSH
5859: LD_INT 2
5861: ARRAY
5862: PUSH
5863: LD_EXP 42
5867: PUSH
5868: LD_INT 3
5870: ARRAY
5871: PUSH
5872: LD_EXP 42
5876: PUSH
5877: LD_INT 4
5879: ARRAY
5880: PUSH
5881: EMPTY
5882: LIST
5883: LIST
5884: LIST
5885: LIST
5886: ST_TO_ADDR
// hc_agressivity = animalsAgression ;
5887: LD_ADDR_OWVAR 35
5891: PUSH
5892: LD_EXP 43
5896: ST_TO_ADDR
// un = CreateHuman ;
5897: LD_ADDR_VAR 0 2
5901: PUSH
5902: CALL_OW 44
5906: ST_TO_ADDR
// PlaceUnitArea ( un , NatureArea , false ) ;
5907: LD_VAR 0 2
5911: PPUSH
5912: LD_INT 5
5914: PPUSH
5915: LD_INT 0
5917: PPUSH
5918: CALL_OW 49
// end ;
5922: GO 5813
5924: POP
5925: POP
// end ; enable ;
5926: ENABLE
// end ; end_of_file
5927: PPOPN 2
5929: END
// export function PrepareUnitExt ( ident , exist_mode , class ) ; var unit ; begin
5930: LD_INT 0
5932: PPUSH
5933: PPUSH
// if debugMode then
5934: LD_EXP 46
5938: IFFALSE 5955
// unit := NewCharacter ( ident ) ;
5940: LD_ADDR_VAR 0 5
5944: PUSH
5945: LD_VAR 0 1
5949: PPUSH
5950: CALL_OW 25
5954: ST_TO_ADDR
// if exist_mode and not debugMode then
5955: LD_VAR 0 2
5959: PUSH
5960: LD_EXP 46
5964: NOT
5965: AND
5966: IFFALSE 5991
// unit := CreateCharacter ( previousMissionPrefix & ident ) else
5968: LD_ADDR_VAR 0 5
5972: PUSH
5973: LD_EXP 45
5977: PUSH
5978: LD_VAR 0 1
5982: STR
5983: PPUSH
5984: CALL_OW 34
5988: ST_TO_ADDR
5989: GO 6013
// if not debugMode then
5991: LD_EXP 46
5995: NOT
5996: IFFALSE 6013
// unit := NewCharacter ( ident ) ;
5998: LD_ADDR_VAR 0 5
6002: PUSH
6003: LD_VAR 0 1
6007: PPUSH
6008: CALL_OW 25
6012: ST_TO_ADDR
// if class then
6013: LD_VAR 0 3
6017: IFFALSE 6033
// SetClass ( unit , class ) ;
6019: LD_VAR 0 5
6023: PPUSH
6024: LD_VAR 0 3
6028: PPUSH
6029: CALL_OW 336
// result := unit ;
6033: LD_ADDR_VAR 0 4
6037: PUSH
6038: LD_VAR 0 5
6042: ST_TO_ADDR
// end ;
6043: LD_VAR 0 4
6047: RET
// export function ExtSaveCharacter ( character , characterStringID , side ) ; begin
6048: LD_INT 0
6050: PPUSH
// if GetSide ( character ) = side and not IsDead ( character ) then
6051: LD_VAR 0 1
6055: PPUSH
6056: CALL_OW 255
6060: PUSH
6061: LD_VAR 0 3
6065: EQUAL
6066: PUSH
6067: LD_VAR 0 1
6071: PPUSH
6072: CALL_OW 301
6076: NOT
6077: AND
6078: IFFALSE 6100
// SaveCharacters ( character , missionPrefix & characterStringID ) ;
6080: LD_VAR 0 1
6084: PPUSH
6085: LD_EXP 44
6089: PUSH
6090: LD_VAR 0 2
6094: STR
6095: PPUSH
6096: CALL_OW 38
// end ;
6100: LD_VAR 0 4
6104: RET
// export function ExtSaveCharacters ( characters , charactersStringID , side ) ; var unit , resultCharactersToSave ; begin
6105: LD_INT 0
6107: PPUSH
6108: PPUSH
6109: PPUSH
// resultCharactersToSave = [ ] ;
6110: LD_ADDR_VAR 0 6
6114: PUSH
6115: EMPTY
6116: ST_TO_ADDR
// for unit in characters do
6117: LD_ADDR_VAR 0 5
6121: PUSH
6122: LD_VAR 0 1
6126: PUSH
6127: FOR_IN
6128: IFFALSE 6177
// if GetSide ( unit ) = side and not IsDead ( unit ) then
6130: LD_VAR 0 5
6134: PPUSH
6135: CALL_OW 255
6139: PUSH
6140: LD_VAR 0 3
6144: EQUAL
6145: PUSH
6146: LD_VAR 0 5
6150: PPUSH
6151: CALL_OW 301
6155: NOT
6156: AND
6157: IFFALSE 6175
// resultCharactersToSave = resultCharactersToSave ^ unit ;
6159: LD_ADDR_VAR 0 6
6163: PUSH
6164: LD_VAR 0 6
6168: PUSH
6169: LD_VAR 0 5
6173: ADD
6174: ST_TO_ADDR
6175: GO 6127
6177: POP
6178: POP
// SaveCharacters ( resultCharactersToSave , missionPrefix & charactersStringID ) ;
6179: LD_VAR 0 6
6183: PPUSH
6184: LD_EXP 44
6188: PUSH
6189: LD_VAR 0 2
6193: STR
6194: PPUSH
6195: CALL_OW 38
// end ;
6199: LD_VAR 0 4
6203: RET
// export function PlaceUnitsArea ( units , area , spawnMode ) ; var unit ; begin
6204: LD_INT 0
6206: PPUSH
6207: PPUSH
// for unit in units do
6208: LD_ADDR_VAR 0 5
6212: PUSH
6213: LD_VAR 0 1
6217: PUSH
6218: FOR_IN
6219: IFFALSE 6242
// PlaceUnitArea ( unit , area , spawnMode ) ;
6221: LD_VAR 0 5
6225: PPUSH
6226: LD_VAR 0 2
6230: PPUSH
6231: LD_VAR 0 3
6235: PPUSH
6236: CALL_OW 49
6240: GO 6218
6242: POP
6243: POP
// end ;
6244: LD_VAR 0 4
6248: RET
// export function DialogRandom ( characters , dialogMID , dialogFID , radio , canTalkHero ) ; var i , speaker , units ; begin
6249: LD_INT 0
6251: PPUSH
6252: PPUSH
6253: PPUSH
6254: PPUSH
// units = characters ;
6255: LD_ADDR_VAR 0 9
6259: PUSH
6260: LD_VAR 0 1
6264: ST_TO_ADDR
// units := units diff [ Burlak , Karamazov , Petrovova , Gleb , Petrosyan , Titov , Dolgov , Lipshchin , Kirilenkova ] ;
6265: LD_ADDR_VAR 0 9
6269: PUSH
6270: LD_VAR 0 9
6274: PUSH
6275: LD_EXP 57
6279: PUSH
6280: LD_EXP 58
6284: PUSH
6285: LD_EXP 59
6289: PUSH
6290: LD_EXP 60
6294: PUSH
6295: LD_EXP 61
6299: PUSH
6300: LD_EXP 62
6304: PUSH
6305: LD_EXP 63
6309: PUSH
6310: LD_EXP 64
6314: PUSH
6315: LD_EXP 65
6319: PUSH
6320: EMPTY
6321: LIST
6322: LIST
6323: LIST
6324: LIST
6325: LIST
6326: LIST
6327: LIST
6328: LIST
6329: LIST
6330: DIFF
6331: ST_TO_ADDR
// if not units and not canTalkHero then
6332: LD_VAR 0 9
6336: NOT
6337: PUSH
6338: LD_VAR 0 5
6342: NOT
6343: AND
6344: IFFALSE 6348
// exit ;
6346: GO 6521
// if not units then
6348: LD_VAR 0 9
6352: NOT
6353: IFFALSE 6374
// units = characters diff [ Burlak ] ;
6355: LD_ADDR_VAR 0 9
6359: PUSH
6360: LD_VAR 0 1
6364: PUSH
6365: LD_EXP 57
6369: PUSH
6370: EMPTY
6371: LIST
6372: DIFF
6373: ST_TO_ADDR
// if not units and canTalkHero then
6374: LD_VAR 0 9
6378: NOT
6379: PUSH
6380: LD_VAR 0 5
6384: AND
6385: IFFALSE 6389
// exit ;
6387: GO 6521
// speaker := units [ rand ( 1 , units ) ] ;
6389: LD_ADDR_VAR 0 8
6393: PUSH
6394: LD_VAR 0 9
6398: PUSH
6399: LD_INT 1
6401: PPUSH
6402: LD_VAR 0 9
6406: PPUSH
6407: CALL_OW 12
6411: ARRAY
6412: ST_TO_ADDR
// if radio then
6413: LD_VAR 0 4
6417: IFFALSE 6466
// begin if GetSex ( speaker ) = sex_male then
6419: LD_VAR 0 8
6423: PPUSH
6424: CALL_OW 258
6428: PUSH
6429: LD_INT 1
6431: EQUAL
6432: IFFALSE 6450
// SayRadio ( speaker , dialogMID ) else
6434: LD_VAR 0 8
6438: PPUSH
6439: LD_VAR 0 2
6443: PPUSH
6444: CALL_OW 94
6448: GO 6464
// SayRadio ( speaker , dialogFID ) ;
6450: LD_VAR 0 8
6454: PPUSH
6455: LD_VAR 0 3
6459: PPUSH
6460: CALL_OW 94
// end else
6464: GO 6511
// begin if GetSex ( speaker ) = sex_male then
6466: LD_VAR 0 8
6470: PPUSH
6471: CALL_OW 258
6475: PUSH
6476: LD_INT 1
6478: EQUAL
6479: IFFALSE 6497
// Say ( speaker , dialogMID ) else
6481: LD_VAR 0 8
6485: PPUSH
6486: LD_VAR 0 2
6490: PPUSH
6491: CALL_OW 88
6495: GO 6511
// Say ( speaker , dialogFID ) ;
6497: LD_VAR 0 8
6501: PPUSH
6502: LD_VAR 0 3
6506: PPUSH
6507: CALL_OW 88
// end ; result := speaker ;
6511: LD_ADDR_VAR 0 6
6515: PUSH
6516: LD_VAR 0 8
6520: ST_TO_ADDR
// end ;
6521: LD_VAR 0 6
6525: RET
// export function RemoveUnits ( units ) ; var unit ; begin
6526: LD_INT 0
6528: PPUSH
6529: PPUSH
// if not units then
6530: LD_VAR 0 1
6534: NOT
6535: IFFALSE 6539
// exit ;
6537: GO 6685
// if Heike in units then
6539: LD_EXP 79
6543: PUSH
6544: LD_VAR 0 1
6548: IN
6549: IFFALSE 6605
// begin if GetAttitude ( 3 , 8 ) = att_neutral then
6551: LD_INT 3
6553: PPUSH
6554: LD_INT 8
6556: PPUSH
6557: CALL_OW 81
6561: PUSH
6562: LD_INT 0
6564: EQUAL
6565: IFFALSE 6577
// HeikeStatus = 1 else
6567: LD_ADDR_EXP 3
6571: PUSH
6572: LD_INT 1
6574: ST_TO_ADDR
6575: GO 6585
// HeikeStatus = 2 ;
6577: LD_ADDR_EXP 3
6581: PUSH
6582: LD_INT 2
6584: ST_TO_ADDR
// forceStopKurtAttack = true ;
6585: LD_ADDR_EXP 27
6589: PUSH
6590: LD_INT 1
6592: ST_TO_ADDR
// SetClass ( Heike , 1 ) ;
6593: LD_EXP 79
6597: PPUSH
6598: LD_INT 1
6600: PPUSH
6601: CALL_OW 336
// end ; if Kurt in units then
6605: LD_EXP 80
6609: PUSH
6610: LD_VAR 0 1
6614: IN
6615: IFFALSE 6659
// begin if GetAttitude ( 3 , 8 ) = att_neutral then
6617: LD_INT 3
6619: PPUSH
6620: LD_INT 8
6622: PPUSH
6623: CALL_OW 81
6627: PUSH
6628: LD_INT 0
6630: EQUAL
6631: IFFALSE 6643
// KurtStatus = 1 else
6633: LD_ADDR_EXP 22
6637: PUSH
6638: LD_INT 1
6640: ST_TO_ADDR
6641: GO 6659
// begin KurtStatus = 2 ;
6643: LD_ADDR_EXP 22
6647: PUSH
6648: LD_INT 2
6650: ST_TO_ADDR
// KurtAttack = 1 ;
6651: LD_ADDR_EXP 25
6655: PUSH
6656: LD_INT 1
6658: ST_TO_ADDR
// end ; end ; for unit in units do
6659: LD_ADDR_VAR 0 3
6663: PUSH
6664: LD_VAR 0 1
6668: PUSH
6669: FOR_IN
6670: IFFALSE 6683
// RemoveUnit ( unit ) ;
6672: LD_VAR 0 3
6676: PPUSH
6677: CALL_OW 64
6681: GO 6669
6683: POP
6684: POP
// end ;
6685: LD_VAR 0 2
6689: RET
// export function GetAmountWeaponsDataBuildOnTurret ( isBuild ) ; var i , amount ; begin
6690: LD_INT 0
6692: PPUSH
6693: PPUSH
6694: PPUSH
// amount = 0 ;
6695: LD_ADDR_VAR 0 4
6699: PUSH
6700: LD_INT 0
6702: ST_TO_ADDR
// for i := 1 to weaponsData do
6703: LD_ADDR_VAR 0 3
6707: PUSH
6708: DOUBLE
6709: LD_INT 1
6711: DEC
6712: ST_TO_ADDR
6713: LD_EXP 12
6717: PUSH
6718: FOR_TO
6719: IFFALSE 6759
// if weaponsData [ i ] [ 2 ] = isBuild then
6721: LD_EXP 12
6725: PUSH
6726: LD_VAR 0 3
6730: ARRAY
6731: PUSH
6732: LD_INT 2
6734: ARRAY
6735: PUSH
6736: LD_VAR 0 1
6740: EQUAL
6741: IFFALSE 6757
// amount = amount + 1 ;
6743: LD_ADDR_VAR 0 4
6747: PUSH
6748: LD_VAR 0 4
6752: PUSH
6753: LD_INT 1
6755: PLUS
6756: ST_TO_ADDR
6757: GO 6718
6759: POP
6760: POP
// if isBuild then
6761: LD_VAR 0 1
6765: IFFALSE 6785
// if amount >= 3 then
6767: LD_VAR 0 4
6771: PUSH
6772: LD_INT 3
6774: GREATEREQUAL
6775: IFFALSE 6785
// amount = 3 ;
6777: LD_ADDR_VAR 0 4
6781: PUSH
6782: LD_INT 3
6784: ST_TO_ADDR
// result = amount ;
6785: LD_ADDR_VAR 0 2
6789: PUSH
6790: LD_VAR 0 4
6794: ST_TO_ADDR
// end ;
6795: LD_VAR 0 2
6799: RET
// export function GetAmountWeaponsDataBuildOnVehicle ( isBuild ) ; var i , amount ; begin
6800: LD_INT 0
6802: PPUSH
6803: PPUSH
6804: PPUSH
// amount = 0 ;
6805: LD_ADDR_VAR 0 4
6809: PUSH
6810: LD_INT 0
6812: ST_TO_ADDR
// for i := 1 to weaponsData do
6813: LD_ADDR_VAR 0 3
6817: PUSH
6818: DOUBLE
6819: LD_INT 1
6821: DEC
6822: ST_TO_ADDR
6823: LD_EXP 12
6827: PUSH
6828: FOR_TO
6829: IFFALSE 6869
// if weaponsData [ i ] [ 3 ] = isBuild then
6831: LD_EXP 12
6835: PUSH
6836: LD_VAR 0 3
6840: ARRAY
6841: PUSH
6842: LD_INT 3
6844: ARRAY
6845: PUSH
6846: LD_VAR 0 1
6850: EQUAL
6851: IFFALSE 6867
// amount = amount + 1 ;
6853: LD_ADDR_VAR 0 4
6857: PUSH
6858: LD_VAR 0 4
6862: PUSH
6863: LD_INT 1
6865: PLUS
6866: ST_TO_ADDR
6867: GO 6828
6869: POP
6870: POP
// result = amount ;
6871: LD_ADDR_VAR 0 2
6875: PUSH
6876: LD_VAR 0 4
6880: ST_TO_ADDR
// end ;
6881: LD_VAR 0 2
6885: RET
// export function SetWeaponDataBuild ( weapon , turret ) ; var i ; begin
6886: LD_INT 0
6888: PPUSH
6889: PPUSH
// if turret then
6890: LD_VAR 0 2
6894: IFFALSE 6992
// begin for i := 1 to weaponsData do
6896: LD_ADDR_VAR 0 4
6900: PUSH
6901: DOUBLE
6902: LD_INT 1
6904: DEC
6905: ST_TO_ADDR
6906: LD_EXP 12
6910: PUSH
6911: FOR_TO
6912: IFFALSE 6988
// if weaponsData [ i ] [ 1 ] = weapon and weaponsData [ i ] [ 2 ] = false then
6914: LD_EXP 12
6918: PUSH
6919: LD_VAR 0 4
6923: ARRAY
6924: PUSH
6925: LD_INT 1
6927: ARRAY
6928: PUSH
6929: LD_VAR 0 1
6933: EQUAL
6934: PUSH
6935: LD_EXP 12
6939: PUSH
6940: LD_VAR 0 4
6944: ARRAY
6945: PUSH
6946: LD_INT 2
6948: ARRAY
6949: PUSH
6950: LD_INT 0
6952: EQUAL
6953: AND
6954: IFFALSE 6986
// weaponsData = ReplaceIn ( weaponsData , [ i , 2 ] , true ) ;
6956: LD_ADDR_EXP 12
6960: PUSH
6961: LD_EXP 12
6965: PPUSH
6966: LD_VAR 0 4
6970: PUSH
6971: LD_INT 2
6973: PUSH
6974: EMPTY
6975: LIST
6976: LIST
6977: PPUSH
6978: LD_INT 1
6980: PPUSH
6981: CALL 24210 0 3
6985: ST_TO_ADDR
6986: GO 6911
6988: POP
6989: POP
// end else
6990: GO 7086
// begin for i := 1 to weaponsData do
6992: LD_ADDR_VAR 0 4
6996: PUSH
6997: DOUBLE
6998: LD_INT 1
7000: DEC
7001: ST_TO_ADDR
7002: LD_EXP 12
7006: PUSH
7007: FOR_TO
7008: IFFALSE 7084
// if weaponsData [ i ] [ 1 ] = weapon and weaponsData [ i ] [ 3 ] = false then
7010: LD_EXP 12
7014: PUSH
7015: LD_VAR 0 4
7019: ARRAY
7020: PUSH
7021: LD_INT 1
7023: ARRAY
7024: PUSH
7025: LD_VAR 0 1
7029: EQUAL
7030: PUSH
7031: LD_EXP 12
7035: PUSH
7036: LD_VAR 0 4
7040: ARRAY
7041: PUSH
7042: LD_INT 3
7044: ARRAY
7045: PUSH
7046: LD_INT 0
7048: EQUAL
7049: AND
7050: IFFALSE 7082
// weaponsData = ReplaceIn ( weaponsData , [ i , 3 ] , true ) ;
7052: LD_ADDR_EXP 12
7056: PUSH
7057: LD_EXP 12
7061: PPUSH
7062: LD_VAR 0 4
7066: PUSH
7067: LD_INT 3
7069: PUSH
7070: EMPTY
7071: LIST
7072: LIST
7073: PPUSH
7074: LD_INT 1
7076: PPUSH
7077: CALL 24210 0 3
7081: ST_TO_ADDR
7082: GO 7007
7084: POP
7085: POP
// end ; end ;
7086: LD_VAR 0 3
7090: RET
// export function ShootTreningController ; var i , unitsInArea , unit , depots , depot , barrelsAreaList , randIndex , randPosX , randPosY , barrelsInArea ; begin
7091: LD_INT 0
7093: PPUSH
7094: PPUSH
7095: PPUSH
7096: PPUSH
7097: PPUSH
7098: PPUSH
7099: PPUSH
7100: PPUSH
7101: PPUSH
7102: PPUSH
7103: PPUSH
// unitsInArea = FilterUnitsInArea ( ShootArea , [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) ;
7104: LD_ADDR_VAR 0 3
7108: PUSH
7109: LD_INT 12
7111: PPUSH
7112: LD_INT 22
7114: PUSH
7115: LD_INT 3
7117: PUSH
7118: EMPTY
7119: LIST
7120: LIST
7121: PUSH
7122: LD_INT 21
7124: PUSH
7125: LD_INT 1
7127: PUSH
7128: EMPTY
7129: LIST
7130: LIST
7131: PUSH
7132: LD_INT 50
7134: PUSH
7135: EMPTY
7136: LIST
7137: PUSH
7138: LD_INT 3
7140: PUSH
7141: LD_INT 60
7143: PUSH
7144: EMPTY
7145: LIST
7146: PUSH
7147: EMPTY
7148: LIST
7149: LIST
7150: PUSH
7151: EMPTY
7152: LIST
7153: LIST
7154: LIST
7155: LIST
7156: PPUSH
7157: CALL_OW 70
7161: ST_TO_ADDR
// depots = FilterAllUnits ( [ [ f_side , 3 ] , [ f_ok ] , [ f_type , unit_building ] , [ f_not , [ f_constructed ] ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
7162: LD_ADDR_VAR 0 5
7166: PUSH
7167: LD_INT 22
7169: PUSH
7170: LD_INT 3
7172: PUSH
7173: EMPTY
7174: LIST
7175: LIST
7176: PUSH
7177: LD_INT 50
7179: PUSH
7180: EMPTY
7181: LIST
7182: PUSH
7183: LD_INT 21
7185: PUSH
7186: LD_INT 3
7188: PUSH
7189: EMPTY
7190: LIST
7191: LIST
7192: PUSH
7193: LD_INT 3
7195: PUSH
7196: LD_INT 57
7198: PUSH
7199: EMPTY
7200: LIST
7201: PUSH
7202: EMPTY
7203: LIST
7204: LIST
7205: PUSH
7206: LD_INT 2
7208: PUSH
7209: LD_INT 30
7211: PUSH
7212: LD_INT 0
7214: PUSH
7215: EMPTY
7216: LIST
7217: LIST
7218: PUSH
7219: LD_INT 30
7221: PUSH
7222: LD_INT 1
7224: PUSH
7225: EMPTY
7226: LIST
7227: LIST
7228: PUSH
7229: EMPTY
7230: LIST
7231: LIST
7232: LIST
7233: PUSH
7234: EMPTY
7235: LIST
7236: LIST
7237: LIST
7238: LIST
7239: LIST
7240: PPUSH
7241: CALL_OW 69
7245: ST_TO_ADDR
// barrelsAreaList = AreaToList ( BarrelsArea , 0 ) ;
7246: LD_ADDR_VAR 0 7
7250: PUSH
7251: LD_INT 13
7253: PPUSH
7254: LD_INT 0
7256: PPUSH
7257: CALL_OW 517
7261: ST_TO_ADDR
// if not depots or not unitsInArea then
7262: LD_VAR 0 5
7266: NOT
7267: PUSH
7268: LD_VAR 0 3
7272: NOT
7273: OR
7274: IFFALSE 7278
// exit ;
7276: GO 7714
// depot = depots [ 1 ] ;
7278: LD_ADDR_VAR 0 6
7282: PUSH
7283: LD_VAR 0 5
7287: PUSH
7288: LD_INT 1
7290: ARRAY
7291: ST_TO_ADDR
// for unit in unitsInArea do
7292: LD_ADDR_VAR 0 4
7296: PUSH
7297: LD_VAR 0 3
7301: PUSH
7302: FOR_IN
7303: IFFALSE 7712
// begin if not GetClass ( unit ) = class_engineer then
7305: LD_VAR 0 4
7309: PPUSH
7310: CALL_OW 257
7314: PUSH
7315: LD_INT 2
7317: EQUAL
7318: NOT
7319: IFFALSE 7356
// begin ComEnterUnit ( unit , depot ) ;
7321: LD_VAR 0 4
7325: PPUSH
7326: LD_VAR 0 6
7330: PPUSH
7331: CALL_OW 120
// AddComChangeProfession ( unit , class_engineer ) ;
7335: LD_VAR 0 4
7339: PPUSH
7340: LD_INT 2
7342: PPUSH
7343: CALL_OW 183
// AddComExitBuilding ( unit ) ;
7347: LD_VAR 0 4
7351: PPUSH
7352: CALL_OW 182
// end ; if GetCargo ( unit , mat_oil ) = 0 then
7356: LD_VAR 0 4
7360: PPUSH
7361: LD_INT 2
7363: PPUSH
7364: CALL_OW 289
7368: PUSH
7369: LD_INT 0
7371: EQUAL
7372: IFFALSE 7391
// AddComTransport ( unit , depot , mat_oil ) ;
7374: LD_VAR 0 4
7378: PPUSH
7379: LD_VAR 0 6
7383: PPUSH
7384: LD_INT 2
7386: PPUSH
7387: CALL_OW 211
// repeat wait ( 0 0$1 ) ;
7391: LD_INT 35
7393: PPUSH
7394: CALL_OW 67
// until not HasTask ( unit ) ;
7398: LD_VAR 0 4
7402: PPUSH
7403: CALL_OW 314
7407: NOT
7408: IFFALSE 7391
// if GetCargo ( unit , mat_oil ) > 0 then
7410: LD_VAR 0 4
7414: PPUSH
7415: LD_INT 2
7417: PPUSH
7418: CALL_OW 289
7422: PUSH
7423: LD_INT 0
7425: GREATER
7426: IFFALSE 7710
// begin randIndex = Rand ( 1 , barrelsAreaList [ 1 ] ) ;
7428: LD_ADDR_VAR 0 8
7432: PUSH
7433: LD_INT 1
7435: PPUSH
7436: LD_VAR 0 7
7440: PUSH
7441: LD_INT 1
7443: ARRAY
7444: PPUSH
7445: CALL_OW 12
7449: ST_TO_ADDR
// randPosX = barrelsAreaList [ 1 ] [ randIndex ] ;
7450: LD_ADDR_VAR 0 9
7454: PUSH
7455: LD_VAR 0 7
7459: PUSH
7460: LD_INT 1
7462: ARRAY
7463: PUSH
7464: LD_VAR 0 8
7468: ARRAY
7469: ST_TO_ADDR
// randPosY = barrelsAreaList [ 2 ] [ RandIndex ] ;
7470: LD_ADDR_VAR 0 10
7474: PUSH
7475: LD_VAR 0 7
7479: PUSH
7480: LD_INT 2
7482: ARRAY
7483: PUSH
7484: LD_VAR 0 8
7488: ARRAY
7489: ST_TO_ADDR
// AddComMoveXY ( unit , randPosX , randPosY ) ;
7490: LD_VAR 0 4
7494: PPUSH
7495: LD_VAR 0 9
7499: PPUSH
7500: LD_VAR 0 10
7504: PPUSH
7505: CALL_OW 171
// AddComUnload ( unit ) ;
7509: LD_VAR 0 4
7513: PPUSH
7514: CALL_OW 219
// AddComMoveXY ( unit , randPosX + 2 , randPosY + 2 ) ;
7518: LD_VAR 0 4
7522: PPUSH
7523: LD_VAR 0 9
7527: PUSH
7528: LD_INT 2
7530: PLUS
7531: PPUSH
7532: LD_VAR 0 10
7536: PUSH
7537: LD_INT 2
7539: PLUS
7540: PPUSH
7541: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
7545: LD_INT 35
7547: PPUSH
7548: CALL_OW 67
// until not HasTask ( unit ) ;
7552: LD_VAR 0 4
7556: PPUSH
7557: CALL_OW 314
7561: NOT
7562: IFFALSE 7545
// barrelsInArea = GetListOfCratesInArea ( ShootArea ) ;
7564: LD_ADDR_VAR 0 11
7568: PUSH
7569: LD_INT 12
7571: PPUSH
7572: CALL_OW 435
7576: ST_TO_ADDR
// for i := 1 to barrelsInArea / 2 do
7577: LD_ADDR_VAR 0 2
7581: PUSH
7582: DOUBLE
7583: LD_INT 1
7585: DEC
7586: ST_TO_ADDR
7587: LD_VAR 0 11
7591: PUSH
7592: LD_INT 2
7594: DIVREAL
7595: PUSH
7596: FOR_TO
7597: IFFALSE 7708
// begin if GetDistUnitXY ( unit , barrelsInArea [ i ] , barrelsInArea [ i + 1 ] ) <= 6 then
7599: LD_VAR 0 4
7603: PPUSH
7604: LD_VAR 0 11
7608: PUSH
7609: LD_VAR 0 2
7613: ARRAY
7614: PPUSH
7615: LD_VAR 0 11
7619: PUSH
7620: LD_VAR 0 2
7624: PUSH
7625: LD_INT 1
7627: PLUS
7628: ARRAY
7629: PPUSH
7630: CALL_OW 297
7634: PUSH
7635: LD_INT 6
7637: LESSEQUAL
7638: IFFALSE 7692
// begin AddComAttackPlace ( unit , barrelsInArea [ i ] , barrelsInArea [ i + 1 ] ) ;
7640: LD_VAR 0 4
7644: PPUSH
7645: LD_VAR 0 11
7649: PUSH
7650: LD_VAR 0 2
7654: ARRAY
7655: PPUSH
7656: LD_VAR 0 11
7660: PUSH
7661: LD_VAR 0 2
7665: PUSH
7666: LD_INT 1
7668: PLUS
7669: ARRAY
7670: PPUSH
7671: CALL_OW 176
// AddExperience ( unit , skill_combat , 5 ) ;
7675: LD_VAR 0 4
7679: PPUSH
7680: LD_INT 1
7682: PPUSH
7683: LD_INT 5
7685: PPUSH
7686: CALL_OW 492
// break ;
7690: GO 7708
// end ; i = i + 2 ;
7692: LD_ADDR_VAR 0 2
7696: PUSH
7697: LD_VAR 0 2
7701: PUSH
7702: LD_INT 2
7704: PLUS
7705: ST_TO_ADDR
// end ;
7706: GO 7596
7708: POP
7709: POP
// end ; end ;
7710: GO 7302
7712: POP
7713: POP
// end ;
7714: LD_VAR 0 1
7718: RET
// export function GoToHunt ( hunter ) ; var i , barracks , barrackTarget , barrackTargetCurrentHP , animals , animal ; begin
7719: LD_INT 0
7721: PPUSH
7722: PPUSH
7723: PPUSH
7724: PPUSH
7725: PPUSH
7726: PPUSH
7727: PPUSH
// animals = [ ] ;
7728: LD_ADDR_VAR 0 7
7732: PUSH
7733: EMPTY
7734: ST_TO_ADDR
// barracks = FilterAllUnits ( [ [ f_ok ] , [ f_not , [ f_constructed ] ] , [ f_or , [ f_btype , b_barracks ] , [ f_btype , b_armoury ] ] ] ) ;
7735: LD_ADDR_VAR 0 4
7739: PUSH
7740: LD_INT 50
7742: PUSH
7743: EMPTY
7744: LIST
7745: PUSH
7746: LD_INT 3
7748: PUSH
7749: LD_INT 57
7751: PUSH
7752: EMPTY
7753: LIST
7754: PUSH
7755: EMPTY
7756: LIST
7757: LIST
7758: PUSH
7759: LD_INT 2
7761: PUSH
7762: LD_INT 30
7764: PUSH
7765: LD_INT 5
7767: PUSH
7768: EMPTY
7769: LIST
7770: LIST
7771: PUSH
7772: LD_INT 30
7774: PUSH
7775: LD_INT 4
7777: PUSH
7778: EMPTY
7779: LIST
7780: LIST
7781: PUSH
7782: EMPTY
7783: LIST
7784: LIST
7785: LIST
7786: PUSH
7787: EMPTY
7788: LIST
7789: LIST
7790: LIST
7791: PPUSH
7792: CALL_OW 69
7796: ST_TO_ADDR
// SetSide ( hunter , 6 ) ;
7797: LD_VAR 0 1
7801: PPUSH
7802: LD_INT 6
7804: PPUSH
7805: CALL_OW 235
// if IsInUnit ( hunter ) then
7809: LD_VAR 0 1
7813: PPUSH
7814: CALL_OW 310
7818: IFFALSE 7860
// begin if GetBType ( IsInUnit ( hunter ) = unit_vehicle ) then
7820: LD_VAR 0 1
7824: PPUSH
7825: CALL_OW 310
7829: PUSH
7830: LD_INT 2
7832: EQUAL
7833: PPUSH
7834: CALL_OW 266
7838: IFFALSE 7851
// ComExitVehicle ( hunter ) else
7840: LD_VAR 0 1
7844: PPUSH
7845: CALL_OW 121
7849: GO 7860
// ComExitBuilding ( hunter ) ;
7851: LD_VAR 0 1
7855: PPUSH
7856: CALL_OW 122
// end ; ComWalk ( hunter ) ;
7860: LD_VAR 0 1
7864: PPUSH
7865: CALL_OW 138
// wait ( 0 0$1 ) ;
7869: LD_INT 35
7871: PPUSH
7872: CALL_OW 67
// if not GetClass ( hunter ) = class_soldier and barracks then
7876: LD_VAR 0 1
7880: PPUSH
7881: CALL_OW 257
7885: PUSH
7886: LD_INT 1
7888: EQUAL
7889: NOT
7890: PUSH
7891: LD_VAR 0 4
7895: AND
7896: IFFALSE 8039
// begin barrackTarget = barracks [ 1 ] ;
7898: LD_ADDR_VAR 0 5
7902: PUSH
7903: LD_VAR 0 4
7907: PUSH
7908: LD_INT 1
7910: ARRAY
7911: ST_TO_ADDR
// barrackTargetCurrentHP = GetLives ( barrackTarget ) ;
7912: LD_ADDR_VAR 0 6
7916: PUSH
7917: LD_VAR 0 5
7921: PPUSH
7922: CALL_OW 256
7926: ST_TO_ADDR
// SetSide ( barrackTarget , 6 ) ;
7927: LD_VAR 0 5
7931: PPUSH
7932: LD_INT 6
7934: PPUSH
7935: CALL_OW 235
// ComEnterUnit ( hunter , barrackTarget ) ;
7939: LD_VAR 0 1
7943: PPUSH
7944: LD_VAR 0 5
7948: PPUSH
7949: CALL_OW 120
// repeat wait ( 0 0$1 ) ;
7953: LD_INT 35
7955: PPUSH
7956: CALL_OW 67
// ComEnterUnit ( hunter , barrackTarget ) ;
7960: LD_VAR 0 1
7964: PPUSH
7965: LD_VAR 0 5
7969: PPUSH
7970: CALL_OW 120
// SetLives ( barrackTarget , barrackTargetCurrentHP ) ;
7974: LD_VAR 0 5
7978: PPUSH
7979: LD_VAR 0 6
7983: PPUSH
7984: CALL_OW 234
// until IsInUnit ( hunter ) ;
7988: LD_VAR 0 1
7992: PPUSH
7993: CALL_OW 310
7997: IFFALSE 7953
// SetClass ( hunter , class_soldier ) ;
7999: LD_VAR 0 1
8003: PPUSH
8004: LD_INT 1
8006: PPUSH
8007: CALL_OW 336
// ComExitBuilding ( hunter ) ;
8011: LD_VAR 0 1
8015: PPUSH
8016: CALL_OW 122
// SetSide ( barrackTarget , 3 ) ;
8020: LD_VAR 0 5
8024: PPUSH
8025: LD_INT 3
8027: PPUSH
8028: CALL_OW 235
// wait ( 0 0$1 ) ;
8032: LD_INT 35
8034: PPUSH
8035: CALL_OW 67
// end ; for i := 1 to 3 do
8039: LD_ADDR_VAR 0 3
8043: PUSH
8044: DOUBLE
8045: LD_INT 1
8047: DEC
8048: ST_TO_ADDR
8049: LD_INT 3
8051: PUSH
8052: FOR_TO
8053: IFFALSE 8158
// begin uc_side = 0 ;
8055: LD_ADDR_OWVAR 20
8059: PUSH
8060: LD_INT 0
8062: ST_TO_ADDR
// uc_nation = nation_nature ;
8063: LD_ADDR_OWVAR 21
8067: PUSH
8068: LD_INT 0
8070: ST_TO_ADDR
// PrepareHuman ( false , [ class_phororhacos , class_tiger , 21 ] [ Rand ( 1 , 3 ) ] , 0 ) ;
8071: LD_INT 0
8073: PPUSH
8074: LD_INT 18
8076: PUSH
8077: LD_INT 14
8079: PUSH
8080: LD_INT 21
8082: PUSH
8083: EMPTY
8084: LIST
8085: LIST
8086: LIST
8087: PUSH
8088: LD_INT 1
8090: PPUSH
8091: LD_INT 3
8093: PPUSH
8094: CALL_OW 12
8098: ARRAY
8099: PPUSH
8100: LD_INT 0
8102: PPUSH
8103: CALL_OW 380
// hc_agressivity = 0 ;
8107: LD_ADDR_OWVAR 35
8111: PUSH
8112: LD_INT 0
8114: ST_TO_ADDR
// animal = CreateHuman ;
8115: LD_ADDR_VAR 0 8
8119: PUSH
8120: CALL_OW 44
8124: ST_TO_ADDR
// PlaceUnitArea ( animal , NatureArea , false ) ;
8125: LD_VAR 0 8
8129: PPUSH
8130: LD_INT 5
8132: PPUSH
8133: LD_INT 0
8135: PPUSH
8136: CALL_OW 49
// animals = animals ^ animal ;
8140: LD_ADDR_VAR 0 7
8144: PUSH
8145: LD_VAR 0 7
8149: PUSH
8150: LD_VAR 0 8
8154: ADD
8155: ST_TO_ADDR
// end ;
8156: GO 8052
8158: POP
8159: POP
// for i := 1 to animals do
8160: LD_ADDR_VAR 0 3
8164: PUSH
8165: DOUBLE
8166: LD_INT 1
8168: DEC
8169: ST_TO_ADDR
8170: LD_VAR 0 7
8174: PUSH
8175: FOR_TO
8176: IFFALSE 8200
// AddComAttackUnit ( hunter , animals [ i ] ) ;
8178: LD_VAR 0 1
8182: PPUSH
8183: LD_VAR 0 7
8187: PUSH
8188: LD_VAR 0 3
8192: ARRAY
8193: PPUSH
8194: CALL_OW 175
8198: GO 8175
8200: POP
8201: POP
// repeat wait ( 0 0$1 ) ;
8202: LD_INT 35
8204: PPUSH
8205: CALL_OW 67
// if GetClass ( hunter ) = class_soldier then
8209: LD_VAR 0 1
8213: PPUSH
8214: CALL_OW 257
8218: PUSH
8219: LD_INT 1
8221: EQUAL
8222: IFFALSE 8269
// begin if GetDistUnits ( hunter , WantsToAttack ( hunter ) ) < 13 then
8224: LD_VAR 0 1
8228: PPUSH
8229: LD_VAR 0 1
8233: PPUSH
8234: CALL_OW 319
8238: PPUSH
8239: CALL_OW 296
8243: PUSH
8244: LD_INT 13
8246: LESS
8247: IFFALSE 8260
// ComCrawl ( hunter ) else
8249: LD_VAR 0 1
8253: PPUSH
8254: CALL_OW 137
8258: GO 8269
// ComWalk ( hunter ) ;
8260: LD_VAR 0 1
8264: PPUSH
8265: CALL_OW 138
// end ; until not HasTask ( hunter ) ;
8269: LD_VAR 0 1
8273: PPUSH
8274: CALL_OW 314
8278: NOT
8279: IFFALSE 8202
// repeat wait ( 0 0$1 ) ;
8281: LD_INT 35
8283: PPUSH
8284: CALL_OW 67
// ComMoveXY ( hunter , GetX ( Burlak ) , GetY ( Burlak ) ) ;
8288: LD_VAR 0 1
8292: PPUSH
8293: LD_EXP 57
8297: PPUSH
8298: CALL_OW 250
8302: PPUSH
8303: LD_EXP 57
8307: PPUSH
8308: CALL_OW 251
8312: PPUSH
8313: CALL_OW 111
// until GetDistUnits ( hunter , Burlak ) <= 9 ;
8317: LD_VAR 0 1
8321: PPUSH
8322: LD_EXP 57
8326: PPUSH
8327: CALL_OW 296
8331: PUSH
8332: LD_INT 9
8334: LESSEQUAL
8335: IFFALSE 8281
// SetSide ( hunter , 3 ) ;
8337: LD_VAR 0 1
8341: PPUSH
8342: LD_INT 3
8344: PPUSH
8345: CALL_OW 235
// CenterOnUnits ( hunter ) ;
8349: LD_VAR 0 1
8353: PPUSH
8354: CALL_OW 85
// AddExperience ( hunter , skill_combat , 3000 ) ;
8358: LD_VAR 0 1
8362: PPUSH
8363: LD_INT 1
8365: PPUSH
8366: LD_INT 3000
8368: PPUSH
8369: CALL_OW 492
// end ;
8373: LD_VAR 0 2
8377: RET
// export function SetMashaData ( vehicle ) ; begin
8378: LD_INT 0
8380: PPUSH
// if Masha then
8381: LD_EXP 4
8385: IFFALSE 8403
// SetMark ( Masha [ 1 ] , 0 ) ;
8387: LD_EXP 4
8391: PUSH
8392: LD_INT 1
8394: ARRAY
8395: PPUSH
8396: LD_INT 0
8398: PPUSH
8399: CALL_OW 242
// Masha = [ vehicle , GetChassis ( vehicle ) , GetEngine ( vehicle ) , GetControl ( vehicle ) , GetWeapon ( vehicle ) ] ;
8403: LD_ADDR_EXP 4
8407: PUSH
8408: LD_VAR 0 1
8412: PUSH
8413: LD_VAR 0 1
8417: PPUSH
8418: CALL_OW 265
8422: PUSH
8423: LD_VAR 0 1
8427: PPUSH
8428: CALL_OW 262
8432: PUSH
8433: LD_VAR 0 1
8437: PPUSH
8438: CALL_OW 263
8442: PUSH
8443: LD_VAR 0 1
8447: PPUSH
8448: CALL_OW 264
8452: PUSH
8453: EMPTY
8454: LIST
8455: LIST
8456: LIST
8457: LIST
8458: LIST
8459: ST_TO_ADDR
// ChangeMissionObjectives ( MMashaDone ) ;
8460: LD_STRING MMashaDone
8462: PPUSH
8463: CALL_OW 337
// SetMark ( vehicle , 1 ) ;
8467: LD_VAR 0 1
8471: PPUSH
8472: LD_INT 1
8474: PPUSH
8475: CALL_OW 242
// end ;
8479: LD_VAR 0 2
8483: RET
// export function SaveBase ( buildings , ident ) ; var i , buildingsToSave ; begin
8484: LD_INT 0
8486: PPUSH
8487: PPUSH
8488: PPUSH
// buildingsToSave = [ ] ;
8489: LD_ADDR_VAR 0 5
8493: PUSH
8494: EMPTY
8495: ST_TO_ADDR
// if not buildings then
8496: LD_VAR 0 1
8500: NOT
8501: IFFALSE 8505
// exit ;
8503: GO 9080
// for i in buildings do
8505: LD_ADDR_VAR 0 4
8509: PUSH
8510: LD_VAR 0 1
8514: PUSH
8515: FOR_IN
8516: IFFALSE 9064
// begin if GetBType ( i ) in [ b_lab , b_lab_half , b_lab_full ] then
8518: LD_VAR 0 4
8522: PPUSH
8523: CALL_OW 266
8527: PUSH
8528: LD_INT 6
8530: PUSH
8531: LD_INT 7
8533: PUSH
8534: LD_INT 8
8536: PUSH
8537: EMPTY
8538: LIST
8539: LIST
8540: LIST
8541: IN
8542: IFFALSE 8667
// buildingsToSave = buildingsToSave ^ [ [ GetBType ( i ) , GetX ( i ) , GetY ( i ) , GetDir ( i ) , GetBLevel ( i ) , GetNation ( i ) , GetLives ( i ) , GetLabKind ( i , 1 ) , GetLabKind ( i , 2 ) ] ] else
8544: LD_ADDR_VAR 0 5
8548: PUSH
8549: LD_VAR 0 5
8553: PUSH
8554: LD_VAR 0 4
8558: PPUSH
8559: CALL_OW 266
8563: PUSH
8564: LD_VAR 0 4
8568: PPUSH
8569: CALL_OW 250
8573: PUSH
8574: LD_VAR 0 4
8578: PPUSH
8579: CALL_OW 251
8583: PUSH
8584: LD_VAR 0 4
8588: PPUSH
8589: CALL_OW 254
8593: PUSH
8594: LD_VAR 0 4
8598: PPUSH
8599: CALL_OW 267
8603: PUSH
8604: LD_VAR 0 4
8608: PPUSH
8609: CALL_OW 248
8613: PUSH
8614: LD_VAR 0 4
8618: PPUSH
8619: CALL_OW 256
8623: PUSH
8624: LD_VAR 0 4
8628: PPUSH
8629: LD_INT 1
8631: PPUSH
8632: CALL_OW 268
8636: PUSH
8637: LD_VAR 0 4
8641: PPUSH
8642: LD_INT 2
8644: PPUSH
8645: CALL_OW 268
8649: PUSH
8650: EMPTY
8651: LIST
8652: LIST
8653: LIST
8654: LIST
8655: LIST
8656: LIST
8657: LIST
8658: LIST
8659: LIST
8660: PUSH
8661: EMPTY
8662: LIST
8663: ADD
8664: ST_TO_ADDR
8665: GO 9062
// if GetBType ( i ) in [ b_bunker , b_turret ] then
8667: LD_VAR 0 4
8671: PPUSH
8672: CALL_OW 266
8676: PUSH
8677: LD_INT 32
8679: PUSH
8680: LD_INT 33
8682: PUSH
8683: EMPTY
8684: LIST
8685: LIST
8686: IN
8687: IFFALSE 8795
// buildingsToSave = buildingsToSave ^ [ [ GetBType ( i ) , GetX ( i ) , GetY ( i ) , GetDir ( i ) , GetBLevel ( i ) , GetNation ( i ) , GetLives ( i ) , GetBWeapon ( i ) ] ] else
8689: LD_ADDR_VAR 0 5
8693: PUSH
8694: LD_VAR 0 5
8698: PUSH
8699: LD_VAR 0 4
8703: PPUSH
8704: CALL_OW 266
8708: PUSH
8709: LD_VAR 0 4
8713: PPUSH
8714: CALL_OW 250
8718: PUSH
8719: LD_VAR 0 4
8723: PPUSH
8724: CALL_OW 251
8728: PUSH
8729: LD_VAR 0 4
8733: PPUSH
8734: CALL_OW 254
8738: PUSH
8739: LD_VAR 0 4
8743: PPUSH
8744: CALL_OW 267
8748: PUSH
8749: LD_VAR 0 4
8753: PPUSH
8754: CALL_OW 248
8758: PUSH
8759: LD_VAR 0 4
8763: PPUSH
8764: CALL_OW 256
8768: PUSH
8769: LD_VAR 0 4
8773: PPUSH
8774: CALL_OW 269
8778: PUSH
8779: EMPTY
8780: LIST
8781: LIST
8782: LIST
8783: LIST
8784: LIST
8785: LIST
8786: LIST
8787: LIST
8788: PUSH
8789: EMPTY
8790: LIST
8791: ADD
8792: ST_TO_ADDR
8793: GO 9062
// if GetBType ( i ) in [ b_depot , b_warehouse ] then
8795: LD_VAR 0 4
8799: PPUSH
8800: CALL_OW 266
8804: PUSH
8805: LD_INT 0
8807: PUSH
8808: LD_INT 1
8810: PUSH
8811: EMPTY
8812: LIST
8813: LIST
8814: IN
8815: IFFALSE 8969
// buildingsToSave = buildingsToSave ^ [ [ GetBType ( i ) , GetX ( i ) , GetY ( i ) , GetDir ( i ) , GetBLevel ( i ) , GetNation ( i ) , GetLives ( i ) , GetResourceType ( GetBase ( i ) , mat_cans ) , GetResourceType ( GetBase ( i ) , mat_oil ) , GetResourceType ( GetBase ( i ) , mat_siberit ) ] ] else
8817: LD_ADDR_VAR 0 5
8821: PUSH
8822: LD_VAR 0 5
8826: PUSH
8827: LD_VAR 0 4
8831: PPUSH
8832: CALL_OW 266
8836: PUSH
8837: LD_VAR 0 4
8841: PPUSH
8842: CALL_OW 250
8846: PUSH
8847: LD_VAR 0 4
8851: PPUSH
8852: CALL_OW 251
8856: PUSH
8857: LD_VAR 0 4
8861: PPUSH
8862: CALL_OW 254
8866: PUSH
8867: LD_VAR 0 4
8871: PPUSH
8872: CALL_OW 267
8876: PUSH
8877: LD_VAR 0 4
8881: PPUSH
8882: CALL_OW 248
8886: PUSH
8887: LD_VAR 0 4
8891: PPUSH
8892: CALL_OW 256
8896: PUSH
8897: LD_VAR 0 4
8901: PPUSH
8902: CALL_OW 274
8906: PPUSH
8907: LD_INT 1
8909: PPUSH
8910: CALL_OW 275
8914: PUSH
8915: LD_VAR 0 4
8919: PPUSH
8920: CALL_OW 274
8924: PPUSH
8925: LD_INT 2
8927: PPUSH
8928: CALL_OW 275
8932: PUSH
8933: LD_VAR 0 4
8937: PPUSH
8938: CALL_OW 274
8942: PPUSH
8943: LD_INT 3
8945: PPUSH
8946: CALL_OW 275
8950: PUSH
8951: EMPTY
8952: LIST
8953: LIST
8954: LIST
8955: LIST
8956: LIST
8957: LIST
8958: LIST
8959: LIST
8960: LIST
8961: LIST
8962: PUSH
8963: EMPTY
8964: LIST
8965: ADD
8966: ST_TO_ADDR
8967: GO 9062
// buildingsToSave = buildingsToSave ^ [ [ GetBType ( i ) , GetX ( i ) , GetY ( i ) , GetDir ( i ) , GetBLevel ( i ) , GetNation ( i ) , GetLives ( i ) ] ] ;
8969: LD_ADDR_VAR 0 5
8973: PUSH
8974: LD_VAR 0 5
8978: PUSH
8979: LD_VAR 0 4
8983: PPUSH
8984: CALL_OW 266
8988: PUSH
8989: LD_VAR 0 4
8993: PPUSH
8994: CALL_OW 250
8998: PUSH
8999: LD_VAR 0 4
9003: PPUSH
9004: CALL_OW 251
9008: PUSH
9009: LD_VAR 0 4
9013: PPUSH
9014: CALL_OW 254
9018: PUSH
9019: LD_VAR 0 4
9023: PPUSH
9024: CALL_OW 267
9028: PUSH
9029: LD_VAR 0 4
9033: PPUSH
9034: CALL_OW 248
9038: PUSH
9039: LD_VAR 0 4
9043: PPUSH
9044: CALL_OW 256
9048: PUSH
9049: EMPTY
9050: LIST
9051: LIST
9052: LIST
9053: LIST
9054: LIST
9055: LIST
9056: LIST
9057: PUSH
9058: EMPTY
9059: LIST
9060: ADD
9061: ST_TO_ADDR
// end ;
9062: GO 8515
9064: POP
9065: POP
// SaveVariable ( buildingsToSave , ident ) ;
9066: LD_VAR 0 5
9070: PPUSH
9071: LD_VAR 0 2
9075: PPUSH
9076: CALL_OW 39
// end ; end_of_file
9080: LD_VAR 0 3
9084: RET
// export function MissionIntro ; begin
9085: LD_INT 0
9087: PPUSH
// CenterNowOnUnits ( Burlak ) ;
9088: LD_EXP 57
9092: PPUSH
9093: CALL_OW 87
// DialogueOn ;
9097: CALL_OW 6
// SayRadio ( Popov , DStart-Pop-1 ) ;
9101: LD_EXP 76
9105: PPUSH
9106: LD_STRING DStart-Pop-1
9108: PPUSH
9109: CALL_OW 94
// Say ( Burlak , DStart-Bur-1 ) ;
9113: LD_EXP 57
9117: PPUSH
9118: LD_STRING DStart-Bur-1
9120: PPUSH
9121: CALL_OW 88
// DialogueOff ;
9125: CALL_OW 7
// IngameOff ;
9129: CALL_OW 9
// ChangeMissionObjectives ( MStart ) ;
9133: LD_STRING MStart
9135: PPUSH
9136: CALL_OW 337
// SaveForQuickRestart ;
9140: CALL_OW 22
// end ;
9144: LD_VAR 0 1
9148: RET
// export function Dial_EscortHeike ( x , y ) ; begin
9149: LD_INT 0
9151: PPUSH
// dial_BuildDepotBlocker = true ;
9152: LD_ADDR_EXP 5
9156: PUSH
9157: LD_INT 1
9159: ST_TO_ADDR
// HeikeTargetX = x ;
9160: LD_ADDR_EXP 14
9164: PUSH
9165: LD_VAR 0 1
9169: ST_TO_ADDR
// HeikeTargetY = y ;
9170: LD_ADDR_EXP 15
9174: PUSH
9175: LD_VAR 0 2
9179: ST_TO_ADDR
// SayRadio ( Popov , DHeike-Pop-1 ) ;
9180: LD_EXP 76
9184: PPUSH
9185: LD_STRING DHeike-Pop-1
9187: PPUSH
9188: CALL_OW 94
// wait ( 0 0$10 ) ;
9192: LD_INT 350
9194: PPUSH
9195: CALL_OW 67
// PrepareRussianEscort ;
9199: CALL 2320 0 0
// PlaceUnitArea ( Heike , RussianSpawn2Area , false ) ;
9203: LD_EXP 79
9207: PPUSH
9208: LD_INT 7
9210: PPUSH
9211: LD_INT 0
9213: PPUSH
9214: CALL_OW 49
// ComMoveXY ( russianEscort , HeikeTargetX , HeikeTargetY ) ;
9218: LD_EXP 77
9222: PPUSH
9223: LD_EXP 14
9227: PPUSH
9228: LD_EXP 15
9232: PPUSH
9233: CALL_OW 111
// AddComMoveToArea ( russianEscort , RussianSpawn2Area ) ;
9237: LD_EXP 77
9241: PPUSH
9242: LD_INT 7
9244: PPUSH
9245: CALL_OW 173
// ComMoveXY ( Heike , HeikeTargetX , HeikeTargetY ) ;
9249: LD_EXP 79
9253: PPUSH
9254: LD_EXP 14
9258: PPUSH
9259: LD_EXP 15
9263: PPUSH
9264: CALL_OW 111
// AddComHold ( Heike ) ;
9268: LD_EXP 79
9272: PPUSH
9273: CALL_OW 200
// end ;
9277: LD_VAR 0 3
9281: RET
// every 1 trigger GetDistUnitXY ( Heike , HeikeTargetX , HeikeTargetY ) <= 5 do
9282: LD_EXP 79
9286: PPUSH
9287: LD_EXP 14
9291: PPUSH
9292: LD_EXP 15
9296: PPUSH
9297: CALL_OW 297
9301: PUSH
9302: LD_INT 5
9304: LESSEQUAL
9305: IFFALSE 9318
9307: GO 9309
9309: DISABLE
// allowExitFromMap = 1 ;
9310: LD_ADDR_EXP 18
9314: PUSH
9315: LD_INT 1
9317: ST_TO_ADDR
9318: END
// every 7 7$0 trigger IsPlaced ( Heike ) and IsOk ( Heike ) and GetAttitude ( 3 , 5 ) = att_friend and HeikeCaptured do
9319: LD_EXP 79
9323: PPUSH
9324: CALL_OW 305
9328: PUSH
9329: LD_EXP 79
9333: PPUSH
9334: CALL_OW 302
9338: AND
9339: PUSH
9340: LD_INT 3
9342: PPUSH
9343: LD_INT 5
9345: PPUSH
9346: CALL_OW 81
9350: PUSH
9351: LD_INT 1
9353: EQUAL
9354: AND
9355: PUSH
9356: LD_EXP 1
9360: AND
9361: IFFALSE 9580
9363: GO 9365
9365: DISABLE
// begin DialogueOn ;
9366: CALL_OW 6
// SayRadio ( Kurt , DMercHelp-Kurt-1 ) ;
9370: LD_EXP 80
9374: PPUSH
9375: LD_STRING DMercHelp-Kurt-1
9377: PPUSH
9378: CALL_OW 94
// Say ( Burlak , DMercHelp-Bur-1 ) ;
9382: LD_EXP 57
9386: PPUSH
9387: LD_STRING DMercHelp-Bur-1
9389: PPUSH
9390: CALL_OW 88
// SayRadio ( Kurt , DMercHelp-Kurt-2 ) ;
9394: LD_EXP 80
9398: PPUSH
9399: LD_STRING DMercHelp-Kurt-2
9401: PPUSH
9402: CALL_OW 94
// Say ( Burlak , DMercHelp-Bur-2 ) ;
9406: LD_EXP 57
9410: PPUSH
9411: LD_STRING DMercHelp-Bur-2
9413: PPUSH
9414: CALL_OW 88
// SayRadio ( Kurt , DMercHelp-Kurt-3 ) ;
9418: LD_EXP 80
9422: PPUSH
9423: LD_STRING DMercHelp-Kurt-3
9425: PPUSH
9426: CALL_OW 94
// case Query ( QMerc ) of 1 :
9430: LD_STRING QMerc
9432: PPUSH
9433: CALL_OW 97
9437: PUSH
9438: LD_INT 1
9440: DOUBLE
9441: EQUAL
9442: IFTRUE 9446
9444: GO 9481
9446: POP
// begin Say ( Burlak , DQrMerc#1-Bur-1 ) ;
9447: LD_EXP 57
9451: PPUSH
9452: LD_STRING DQrMerc#1-Bur-1
9454: PPUSH
9455: CALL_OW 88
// SayRadio ( Kurt , DQrMerc#1-Kurt-1 ) ;
9459: LD_EXP 80
9463: PPUSH
9464: LD_STRING DQrMerc#1-Kurt-1
9466: PPUSH
9467: CALL_OW 94
// acceptKurtOffert = true ;
9471: LD_ADDR_EXP 19
9475: PUSH
9476: LD_INT 1
9478: ST_TO_ADDR
// end ; 2 :
9479: GO 9576
9481: LD_INT 2
9483: DOUBLE
9484: EQUAL
9485: IFTRUE 9489
9487: GO 9544
9489: POP
// begin askCommanders = true ;
9490: LD_ADDR_EXP 20
9494: PUSH
9495: LD_INT 1
9497: ST_TO_ADDR
// Say ( Burlak , DQrMerc#2-Bur-1 ) ;
9498: LD_EXP 57
9502: PPUSH
9503: LD_STRING DQrMerc#2-Bur-1
9505: PPUSH
9506: CALL_OW 88
// SayRadio ( Popov , DQrMerc#2-Pop-1 ) ;
9510: LD_EXP 76
9514: PPUSH
9515: LD_STRING DQrMerc#2-Pop-1
9517: PPUSH
9518: CALL_OW 94
// Say ( Burlak , DQrMerc#2-Bur-2 ) ;
9522: LD_EXP 57
9526: PPUSH
9527: LD_STRING DQrMerc#2-Bur-2
9529: PPUSH
9530: CALL_OW 88
// acceptKurtOffert = true ;
9534: LD_ADDR_EXP 19
9538: PUSH
9539: LD_INT 1
9541: ST_TO_ADDR
// end ; 3 :
9542: GO 9576
9544: LD_INT 3
9546: DOUBLE
9547: EQUAL
9548: IFTRUE 9552
9550: GO 9575
9552: POP
// begin Say ( Burlak , DQrMerc#3-Bur-1 ) ;
9553: LD_EXP 57
9557: PPUSH
9558: LD_STRING DQrMerc#3-Bur-1
9560: PPUSH
9561: CALL_OW 88
// KurtAttack = true ;
9565: LD_ADDR_EXP 25
9569: PUSH
9570: LD_INT 1
9572: ST_TO_ADDR
// end ; end ;
9573: GO 9576
9575: POP
// DialogueOff ;
9576: CALL_OW 7
// end ;
9580: END
// every 0 0$1 trigger acceptKurtOffert do
9581: LD_EXP 19
9585: IFFALSE 9741
9587: GO 9589
9589: DISABLE
// begin PlaceUnitArea ( Kurt , KurtSpawnArea , false ) ;
9590: LD_EXP 80
9594: PPUSH
9595: LD_INT 9
9597: PPUSH
9598: LD_INT 0
9600: PPUSH
9601: CALL_OW 49
// uc_side = 8 ;
9605: LD_ADDR_OWVAR 20
9609: PUSH
9610: LD_INT 8
9612: ST_TO_ADDR
// uc_nation = 2 ;
9613: LD_ADDR_OWVAR 21
9617: PUSH
9618: LD_INT 2
9620: ST_TO_ADDR
// PrepareEngineer ( false , 3 ) ;
9621: LD_INT 0
9623: PPUSH
9624: LD_INT 3
9626: PPUSH
9627: CALL_OW 382
// KurtEng = CreateHuman ;
9631: LD_ADDR_EXP 82
9635: PUSH
9636: CALL_OW 44
9640: ST_TO_ADDR
// PlaceUnitArea ( KurtEng , KurtSpawnArea , false ) ;
9641: LD_EXP 82
9645: PPUSH
9646: LD_INT 9
9648: PPUSH
9649: LD_INT 0
9651: PPUSH
9652: CALL_OW 49
// repeat wait ( 0 0$1 ) ;
9656: LD_INT 35
9658: PPUSH
9659: CALL_OW 67
// ComMoveXY ( [ Kurt , KurtEng ] , GetX ( Burlak ) , GetY ( Burlak ) ) ;
9663: LD_EXP 80
9667: PUSH
9668: LD_EXP 82
9672: PUSH
9673: EMPTY
9674: LIST
9675: LIST
9676: PPUSH
9677: LD_EXP 57
9681: PPUSH
9682: CALL_OW 250
9686: PPUSH
9687: LD_EXP 57
9691: PPUSH
9692: CALL_OW 251
9696: PPUSH
9697: CALL_OW 111
// until GetDistUnits ( Kurt , Burlak ) <= 5 or GetDistUnits ( KurtEng , Burlak ) <= 5 ;
9701: LD_EXP 80
9705: PPUSH
9706: LD_EXP 57
9710: PPUSH
9711: CALL_OW 296
9715: PUSH
9716: LD_INT 5
9718: LESSEQUAL
9719: PUSH
9720: LD_EXP 82
9724: PPUSH
9725: LD_EXP 57
9729: PPUSH
9730: CALL_OW 296
9734: PUSH
9735: LD_INT 5
9737: LESSEQUAL
9738: OR
9739: IFFALSE 9656
// end ;
9741: END
// every 0 0$1 trigger GetDistUnits ( Kurt , Burlak ) <= 5 or GetDistUnits ( KurtEng , Burlak ) <= 5 do
9742: LD_EXP 80
9746: PPUSH
9747: LD_EXP 57
9751: PPUSH
9752: CALL_OW 296
9756: PUSH
9757: LD_INT 5
9759: LESSEQUAL
9760: PUSH
9761: LD_EXP 82
9765: PPUSH
9766: LD_EXP 57
9770: PPUSH
9771: CALL_OW 296
9775: PUSH
9776: LD_INT 5
9778: LESSEQUAL
9779: OR
9780: IFFALSE 9959
9782: GO 9784
9784: DISABLE
// begin KurtWaitingForBuildBarrack = true ;
9785: LD_ADDR_EXP 24
9789: PUSH
9790: LD_INT 1
9792: ST_TO_ADDR
// SetSide ( KurtEng , 3 ) ;
9793: LD_EXP 82
9797: PPUSH
9798: LD_INT 3
9800: PPUSH
9801: CALL_OW 235
// wait ( 1 1$30 ) ;
9805: LD_INT 3150
9807: PPUSH
9808: CALL_OW 67
// DialogueOn ;
9812: CALL_OW 6
// SayRadio ( Dietrich , DArabianRequest-Diet-1 ) ;
9816: LD_EXP 81
9820: PPUSH
9821: LD_STRING DArabianRequest-Diet-1
9823: PPUSH
9824: CALL_OW 94
// Say ( Burlak , DArabianRequest-Bur-1 ) ;
9828: LD_EXP 57
9832: PPUSH
9833: LD_STRING DArabianRequest-Bur-1
9835: PPUSH
9836: CALL_OW 88
// SayRadio ( Dietrich , DArabianRequest-Diet-2 ) ;
9840: LD_EXP 81
9844: PPUSH
9845: LD_STRING DArabianRequest-Diet-2
9847: PPUSH
9848: CALL_OW 94
// DialogueOff ;
9852: CALL_OW 7
// case Query ( QHandOver ) of 1 :
9856: LD_STRING QHandOver
9858: PPUSH
9859: CALL_OW 97
9863: PUSH
9864: LD_INT 1
9866: DOUBLE
9867: EQUAL
9868: IFTRUE 9872
9870: GO 9911
9872: POP
// begin Say ( Burlak , DQrHandOver#1-Bur-1 ) ;
9873: LD_EXP 57
9877: PPUSH
9878: LD_STRING DQrHandOver#1-Bur-1
9880: PPUSH
9881: CALL_OW 88
// SayRadio ( Dietrich , DQrHandOver#1-Diet-1 ) ;
9885: LD_EXP 81
9889: PPUSH
9890: LD_STRING DQrHandOver#1-Diet-1
9892: PPUSH
9893: CALL_OW 94
// coopWithGensher = true ;
9897: LD_ADDR_EXP 2
9901: PUSH
9902: LD_INT 1
9904: ST_TO_ADDR
// SpawnGensherTeam ;
9905: CALL 3946 0 0
// end ; 2 :
9909: GO 9959
9911: LD_INT 2
9913: DOUBLE
9914: EQUAL
9915: IFTRUE 9919
9917: GO 9958
9919: POP
// begin Say ( Burlak , DQrHandOver#2-Bur-1 ) ;
9920: LD_EXP 57
9924: PPUSH
9925: LD_STRING DQrHandOver#2-Bur-1
9927: PPUSH
9928: CALL_OW 88
// SayRadio ( Dietrich , DQrHandOver#2-Diet-1 ) ;
9932: LD_EXP 81
9936: PPUSH
9937: LD_STRING DQrHandOver#2-Diet-1
9939: PPUSH
9940: CALL_OW 94
// Say ( Burlak , DQrHandOver#2-Bur-2 ) ;
9944: LD_EXP 57
9948: PPUSH
9949: LD_STRING DQrHandOver#2-Bur-2
9951: PPUSH
9952: CALL_OW 88
// end ; end ;
9956: GO 9959
9958: POP
// end ;
9959: END
// export function Dial_UpgradeArmoury ; begin
9960: LD_INT 0
9962: PPUSH
// dial_BuildArBarrackBlocker = true ;
9963: LD_ADDR_EXP 6
9967: PUSH
9968: LD_INT 1
9970: ST_TO_ADDR
// buildArabBarrack = true ;
9971: LD_ADDR_EXP 38
9975: PUSH
9976: LD_INT 1
9978: ST_TO_ADDR
// if GetSide ( Kurt ) = 2 or GetSide ( KurtEng ) = 8 then
9979: LD_EXP 80
9983: PPUSH
9984: CALL_OW 255
9988: PUSH
9989: LD_INT 2
9991: EQUAL
9992: PUSH
9993: LD_EXP 82
9997: PPUSH
9998: CALL_OW 255
10002: PUSH
10003: LD_INT 8
10005: EQUAL
10006: OR
10007: IFFALSE 10011
// exit ;
10009: GO 10111
// SetSide ( KurtEng , 8 ) ;
10011: LD_EXP 82
10015: PPUSH
10016: LD_INT 8
10018: PPUSH
10019: CALL_OW 235
// ComStop ( KurtEng ) ;
10023: LD_EXP 82
10027: PPUSH
10028: CALL_OW 141
// DialogueOn ;
10032: CALL_OW 6
// Say ( Kurt , DMercCompleted-Kurt-1 ) ;
10036: LD_EXP 80
10040: PPUSH
10041: LD_STRING DMercCompleted-Kurt-1
10043: PPUSH
10044: CALL_OW 88
// DialogueOff ;
10048: CALL_OW 7
// canSendHeike = true ;
10052: LD_ADDR_EXP 28
10056: PUSH
10057: LD_INT 1
10059: ST_TO_ADDR
// KurtWaitingForFreeHeike = true ;
10060: LD_ADDR_EXP 23
10064: PUSH
10065: LD_INT 1
10067: ST_TO_ADDR
// KurtWaitingForBuildBarrack = false ;
10068: LD_ADDR_EXP 24
10072: PUSH
10073: LD_INT 0
10075: ST_TO_ADDR
// allowExitFromMap = 3 ;
10076: LD_ADDR_EXP 18
10080: PUSH
10081: LD_INT 3
10083: ST_TO_ADDR
// if KurtCanEscape then
10084: LD_EXP 21
10088: IFFALSE 10111
// ComMoveToArea ( [ Kurt , KurtEng ] , KurtExitMapArea ) ;
10090: LD_EXP 80
10094: PUSH
10095: LD_EXP 82
10099: PUSH
10100: EMPTY
10101: LIST
10102: LIST
10103: PPUSH
10104: LD_INT 11
10106: PPUSH
10107: CALL_OW 113
// end ;
10111: LD_VAR 0 1
10115: RET
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 2 ] ] ) and not dial_ArriveGensherUnitsBlocker do var veh , nearGensherUnit , maleSold , waitForKurt ;
10116: LD_INT 22
10118: PUSH
10119: LD_INT 2
10121: PUSH
10122: EMPTY
10123: LIST
10124: LIST
10125: PUSH
10126: EMPTY
10127: LIST
10128: PPUSH
10129: CALL_OW 69
10133: PUSH
10134: LD_EXP 7
10138: NOT
10139: AND
10140: IFFALSE 10913
10142: GO 10144
10144: DISABLE
10145: LD_INT 0
10147: PPUSH
10148: PPUSH
10149: PPUSH
10150: PPUSH
// begin nearGensherUnit = NearestUnitToXY ( UnitFilter ( GensherTeam , [ [ f_type , unit_vehicle ] ] ) , GensherTargetX , GensherTargetY ) ;
10151: LD_ADDR_VAR 0 2
10155: PUSH
10156: LD_EXP 83
10160: PPUSH
10161: LD_INT 21
10163: PUSH
10164: LD_INT 2
10166: PUSH
10167: EMPTY
10168: LIST
10169: LIST
10170: PUSH
10171: EMPTY
10172: LIST
10173: PPUSH
10174: CALL_OW 72
10178: PPUSH
10179: LD_EXP 16
10183: PPUSH
10184: LD_EXP 17
10188: PPUSH
10189: CALL_OW 73
10193: ST_TO_ADDR
// maleSold = UnitsInside ( nearGensherUnit [ 1 ] ) ;
10194: LD_ADDR_VAR 0 3
10198: PUSH
10199: LD_VAR 0 2
10203: PUSH
10204: LD_INT 1
10206: ARRAY
10207: PPUSH
10208: CALL_OW 313
10212: ST_TO_ADDR
// if GetDistUnitXY ( nearGensherUnit , GensherTargetX , GensherTargetY ) <= 5 then
10213: LD_VAR 0 2
10217: PPUSH
10218: LD_EXP 16
10222: PPUSH
10223: LD_EXP 17
10227: PPUSH
10228: CALL_OW 297
10232: PUSH
10233: LD_INT 5
10235: LESSEQUAL
10236: IFFALSE 10912
// begin dial_ArriveGensherUnitsBlocker = true ;
10238: LD_ADDR_EXP 7
10242: PUSH
10243: LD_INT 1
10245: ST_TO_ADDR
// for veh in UnitFilter ( GensherTeam , [ [ f_type , unit_vehicle ] ] ) do
10246: LD_ADDR_VAR 0 1
10250: PUSH
10251: LD_EXP 83
10255: PPUSH
10256: LD_INT 21
10258: PUSH
10259: LD_INT 2
10261: PUSH
10262: EMPTY
10263: LIST
10264: LIST
10265: PUSH
10266: EMPTY
10267: LIST
10268: PPUSH
10269: CALL_OW 72
10273: PUSH
10274: FOR_IN
10275: IFFALSE 10297
// ComExitVehicle ( UnitsInside ( veh ) [ 1 ] ) ;
10277: LD_VAR 0 1
10281: PPUSH
10282: CALL_OW 313
10286: PUSH
10287: LD_INT 1
10289: ARRAY
10290: PPUSH
10291: CALL_OW 121
10295: GO 10274
10297: POP
10298: POP
// wait ( 0 0$1 ) ;
10299: LD_INT 35
10301: PPUSH
10302: CALL_OW 67
// SetSide ( UnitFilter ( GensherTeam , [ [ f_type , unit_vehicle ] ] ) , 3 ) ;
10306: LD_EXP 83
10310: PPUSH
10311: LD_INT 21
10313: PUSH
10314: LD_INT 2
10316: PUSH
10317: EMPTY
10318: LIST
10319: LIST
10320: PUSH
10321: EMPTY
10322: LIST
10323: PPUSH
10324: CALL_OW 72
10328: PPUSH
10329: LD_INT 3
10331: PPUSH
10332: CALL_OW 235
// CenterOnUnits ( maleSold ) ;
10336: LD_VAR 0 3
10340: PPUSH
10341: CALL_OW 85
// DialogueOn ;
10345: CALL_OW 6
// Say ( maleSold , DHandOverCome-ASol1-1 ) ;
10349: LD_VAR 0 3
10353: PPUSH
10354: LD_STRING DHandOverCome-ASol1-1
10356: PPUSH
10357: CALL_OW 88
// Say ( Kurt , DHandOverCome-Kurt-1 ) ;
10361: LD_EXP 80
10365: PPUSH
10366: LD_STRING DHandOverCome-Kurt-1
10368: PPUSH
10369: CALL_OW 88
// DialogueOff ;
10373: CALL_OW 7
// KurtWaitingForBuildBarrack = false ;
10377: LD_ADDR_EXP 24
10381: PUSH
10382: LD_INT 0
10384: ST_TO_ADDR
// if GetDistUnits ( Kurt , UnitFilter ( GensherTeam , [ f_type , unit_vehicle ] ) [ 1 ] ) <= 8 or GetSide ( KurtEng ) = 3 then
10385: LD_EXP 80
10389: PPUSH
10390: LD_EXP 83
10394: PPUSH
10395: LD_INT 21
10397: PUSH
10398: LD_INT 2
10400: PUSH
10401: EMPTY
10402: LIST
10403: LIST
10404: PPUSH
10405: CALL_OW 72
10409: PUSH
10410: LD_INT 1
10412: ARRAY
10413: PPUSH
10414: CALL_OW 296
10418: PUSH
10419: LD_INT 8
10421: LESSEQUAL
10422: PUSH
10423: LD_EXP 82
10427: PPUSH
10428: CALL_OW 255
10432: PUSH
10433: LD_INT 3
10435: EQUAL
10436: OR
10437: IFFALSE 10542
// begin KurtCanEscape = false ;
10439: LD_ADDR_EXP 21
10443: PUSH
10444: LD_INT 0
10446: ST_TO_ADDR
// SetSide ( [ Kurt , KurtEng ] , 2 ) ;
10447: LD_EXP 80
10451: PUSH
10452: LD_EXP 82
10456: PUSH
10457: EMPTY
10458: LIST
10459: LIST
10460: PPUSH
10461: LD_INT 2
10463: PPUSH
10464: CALL_OW 235
// ComStop ( [ Kurt , KurtEng ] ) ;
10468: LD_EXP 80
10472: PUSH
10473: LD_EXP 82
10477: PUSH
10478: EMPTY
10479: LIST
10480: LIST
10481: PPUSH
10482: CALL_OW 141
// ComMoveXY ( [ Kurt , KurtEng ] , GetX ( maleSold ) , GetY ( maleSold ) ) ;
10486: LD_EXP 80
10490: PUSH
10491: LD_EXP 82
10495: PUSH
10496: EMPTY
10497: LIST
10498: LIST
10499: PPUSH
10500: LD_VAR 0 3
10504: PPUSH
10505: CALL_OW 250
10509: PPUSH
10510: LD_VAR 0 3
10514: PPUSH
10515: CALL_OW 251
10519: PPUSH
10520: CALL_OW 111
// waitForKurt = true ;
10524: LD_ADDR_VAR 0 4
10528: PUSH
10529: LD_INT 1
10531: ST_TO_ADDR
// KurtStatus = 3 ;
10532: LD_ADDR_EXP 22
10536: PUSH
10537: LD_INT 3
10539: ST_TO_ADDR
// end else
10540: GO 10780
// if GetDistUnits ( Kurt , UnitFilter ( GensherTeam , [ f_type , unit_vehicle ] ) [ 1 ] ) > 8 then
10542: LD_EXP 80
10546: PPUSH
10547: LD_EXP 83
10551: PPUSH
10552: LD_INT 21
10554: PUSH
10555: LD_INT 2
10557: PUSH
10558: EMPTY
10559: LIST
10560: LIST
10561: PPUSH
10562: CALL_OW 72
10566: PUSH
10567: LD_INT 1
10569: ARRAY
10570: PPUSH
10571: CALL_OW 296
10575: PUSH
10576: LD_INT 8
10578: GREATER
10579: IFFALSE 10780
// begin allowExitFromMap = 4 ;
10581: LD_ADDR_EXP 18
10585: PUSH
10586: LD_INT 4
10588: ST_TO_ADDR
// KurtStatus = 2 ;
10589: LD_ADDR_EXP 22
10593: PUSH
10594: LD_INT 2
10596: ST_TO_ADDR
// ComMoveToArea ( [ Kurt , KurtEng ] , KurtExitMapArea ) ;
10597: LD_EXP 80
10601: PUSH
10602: LD_EXP 82
10606: PUSH
10607: EMPTY
10608: LIST
10609: LIST
10610: PPUSH
10611: LD_INT 11
10613: PPUSH
10614: CALL_OW 113
// repeat ComAttackUnit ( UnitFilter ( GensherTeam , [ [ f_type , unit_human ] ] ) , Kurt ) ;
10618: LD_EXP 83
10622: PPUSH
10623: LD_INT 21
10625: PUSH
10626: LD_INT 1
10628: PUSH
10629: EMPTY
10630: LIST
10631: LIST
10632: PUSH
10633: EMPTY
10634: LIST
10635: PPUSH
10636: CALL_OW 72
10640: PPUSH
10641: LD_EXP 80
10645: PPUSH
10646: CALL_OW 115
// wait ( 0 0$1 ) ;
10650: LD_INT 35
10652: PPUSH
10653: CALL_OW 67
// until GetDistUnits ( NearestUnitToUnit ( UnitFilter ( GensherTeam , [ [ f_type , unit_human ] ] ) , Kurt ) , Kurt ) <= 9 or ( not IsPlaced ( Kurt ) and not IsPlaced ( KurtEng ) ) ;
10657: LD_EXP 83
10661: PPUSH
10662: LD_INT 21
10664: PUSH
10665: LD_INT 1
10667: PUSH
10668: EMPTY
10669: LIST
10670: LIST
10671: PUSH
10672: EMPTY
10673: LIST
10674: PPUSH
10675: CALL_OW 72
10679: PPUSH
10680: LD_EXP 80
10684: PPUSH
10685: CALL_OW 74
10689: PPUSH
10690: LD_EXP 80
10694: PPUSH
10695: CALL_OW 296
10699: PUSH
10700: LD_INT 9
10702: LESSEQUAL
10703: PUSH
10704: LD_EXP 80
10708: PPUSH
10709: CALL_OW 305
10713: NOT
10714: PUSH
10715: LD_EXP 82
10719: PPUSH
10720: CALL_OW 305
10724: NOT
10725: AND
10726: OR
10727: IFFALSE 10618
// ComMoveToArea ( [ Kurt , KurtEng ] , ExitMapArea ) ;
10729: LD_EXP 80
10733: PUSH
10734: LD_EXP 82
10738: PUSH
10739: EMPTY
10740: LIST
10741: LIST
10742: PPUSH
10743: LD_INT 8
10745: PPUSH
10746: CALL_OW 113
// ComMoveToArea ( UnitFilter ( GensherTeam , [ [ f_type , unit_human ] ] ) , ExitMapArea ) ;
10750: LD_EXP 83
10754: PPUSH
10755: LD_INT 21
10757: PUSH
10758: LD_INT 1
10760: PUSH
10761: EMPTY
10762: LIST
10763: LIST
10764: PUSH
10765: EMPTY
10766: LIST
10767: PPUSH
10768: CALL_OW 72
10772: PPUSH
10773: LD_INT 8
10775: PPUSH
10776: CALL_OW 113
// end ; if waitForKurt then
10780: LD_VAR 0 4
10784: IFFALSE 10910
// begin repeat wait ( 0 0$1 ) ;
10786: LD_INT 35
10788: PPUSH
10789: CALL_OW 67
// ComMoveXY ( [ Kurt , KurtEng ] , GetX ( maleSold ) , GetY ( maleSold ) ) ;
10793: LD_EXP 80
10797: PUSH
10798: LD_EXP 82
10802: PUSH
10803: EMPTY
10804: LIST
10805: LIST
10806: PPUSH
10807: LD_VAR 0 3
10811: PPUSH
10812: CALL_OW 250
10816: PPUSH
10817: LD_VAR 0 3
10821: PPUSH
10822: CALL_OW 251
10826: PPUSH
10827: CALL_OW 111
// until GetDistUnits ( Kurt , maleSold ) <= 2 ;
10831: LD_EXP 80
10835: PPUSH
10836: LD_VAR 0 3
10840: PPUSH
10841: CALL_OW 296
10845: PUSH
10846: LD_INT 2
10848: LESSEQUAL
10849: IFFALSE 10786
// allowExitFromMap = 4 ;
10851: LD_ADDR_EXP 18
10855: PUSH
10856: LD_INT 4
10858: ST_TO_ADDR
// ComMoveToArea ( [ Kurt , KurtEng ] , ExitMapArea ) ;
10859: LD_EXP 80
10863: PUSH
10864: LD_EXP 82
10868: PUSH
10869: EMPTY
10870: LIST
10871: LIST
10872: PPUSH
10873: LD_INT 8
10875: PPUSH
10876: CALL_OW 113
// ComMoveToArea ( UnitFilter ( GensherTeam , [ [ f_type , unit_human ] ] ) , ExitMapArea ) ;
10880: LD_EXP 83
10884: PPUSH
10885: LD_INT 21
10887: PUSH
10888: LD_INT 1
10890: PUSH
10891: EMPTY
10892: LIST
10893: LIST
10894: PUSH
10895: EMPTY
10896: LIST
10897: PPUSH
10898: CALL_OW 72
10902: PPUSH
10903: LD_INT 8
10905: PPUSH
10906: CALL_OW 113
// end ; exit ;
10910: GO 10913
// end ; enable ;
10912: ENABLE
// end ;
10913: PPOPN 4
10915: END
// export function Dial_AttackGensher ; var unit ; begin
10916: LD_INT 0
10918: PPUSH
10919: PPUSH
// DialogueOn ;
10920: CALL_OW 6
// SayRadio ( Dietrich , DHandOverSpoiled-Diet-1 ) ;
10924: LD_EXP 81
10928: PPUSH
10929: LD_STRING DHandOverSpoiled-Diet-1
10931: PPUSH
10932: CALL_OW 94
// DialogueOff ;
10936: CALL_OW 7
// SetAttitude ( 3 , 2 , att_enemy , true ) ;
10940: LD_INT 3
10942: PPUSH
10943: LD_INT 2
10945: PPUSH
10946: LD_INT 2
10948: PPUSH
10949: LD_INT 1
10951: PPUSH
10952: CALL_OW 80
// for unit in UnitFilter ( GensherTeam , [ [ f_type , unit_human ] ] ) do
10956: LD_ADDR_VAR 0 2
10960: PUSH
10961: LD_EXP 83
10965: PPUSH
10966: LD_INT 21
10968: PUSH
10969: LD_INT 1
10971: PUSH
10972: EMPTY
10973: LIST
10974: LIST
10975: PUSH
10976: EMPTY
10977: LIST
10978: PPUSH
10979: CALL_OW 72
10983: PUSH
10984: FOR_IN
10985: IFFALSE 11045
// begin if IsInUnit ( unit ) then
10987: LD_VAR 0 2
10991: PPUSH
10992: CALL_OW 310
10996: IFFALSE 11007
// ComExitVehicle ( unit ) ;
10998: LD_VAR 0 2
11002: PPUSH
11003: CALL_OW 121
// wait ( 0 0$01 ) ;
11007: LD_INT 35
11009: PPUSH
11010: CALL_OW 67
// AddComAgressiveMove ( unit , GetX ( Burlak ) , GetY ( Burlak ) ) ;
11014: LD_VAR 0 2
11018: PPUSH
11019: LD_EXP 57
11023: PPUSH
11024: CALL_OW 250
11028: PPUSH
11029: LD_EXP 57
11033: PPUSH
11034: CALL_OW 251
11038: PPUSH
11039: CALL_OW 174
// end ;
11043: GO 10984
11045: POP
11046: POP
// coopWithGensher = 2 ;
11047: LD_ADDR_EXP 2
11051: PUSH
11052: LD_INT 2
11054: ST_TO_ADDR
// end ;
11055: LD_VAR 0 1
11059: RET
// every 0 0$1 trigger canSendHeike and IsOK ( Heike ) and GetSide ( Heike ) = 5 do var legionSold ;
11060: LD_EXP 28
11064: PUSH
11065: LD_EXP 79
11069: PPUSH
11070: CALL_OW 302
11074: AND
11075: PUSH
11076: LD_EXP 79
11080: PPUSH
11081: CALL_OW 255
11085: PUSH
11086: LD_INT 5
11088: EQUAL
11089: AND
11090: IFFALSE 11410
11092: GO 11094
11094: DISABLE
11095: LD_INT 0
11097: PPUSH
// begin if IsSelected ( Heike ) then
11098: LD_EXP 79
11102: PPUSH
11103: CALL_OW 306
11107: IFFALSE 11402
// begin if Query ( QSendHeike ) = 1 then
11109: LD_STRING QSendHeike
11111: PPUSH
11112: CALL_OW 97
11116: PUSH
11117: LD_INT 1
11119: EQUAL
11120: IFFALSE 11402
// begin KurtWaitingForFreeHeike = false ;
11122: LD_ADDR_EXP 23
11126: PUSH
11127: LD_INT 0
11129: ST_TO_ADDR
// ComMoveXY ( Heike , 82 , 46 ) ;
11130: LD_EXP 79
11134: PPUSH
11135: LD_INT 82
11137: PPUSH
11138: LD_INT 46
11140: PPUSH
11141: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
11145: LD_INT 35
11147: PPUSH
11148: CALL_OW 67
// until GetDistUnitXY ( Heike , 82 , 46 ) <= 5 or IsDead ( Heike ) ;
11152: LD_EXP 79
11156: PPUSH
11157: LD_INT 82
11159: PPUSH
11160: LD_INT 46
11162: PPUSH
11163: CALL_OW 297
11167: PUSH
11168: LD_INT 5
11170: LESSEQUAL
11171: PUSH
11172: LD_EXP 79
11176: PPUSH
11177: CALL_OW 301
11181: OR
11182: IFFALSE 11145
// if not askCommanders then
11184: LD_EXP 20
11188: NOT
11189: IFFALSE 11235
// begin DialogueOn ;
11191: CALL_OW 6
// SayRadio ( Popov , DMercPopov-Pop-1 ) ;
11195: LD_EXP 76
11199: PPUSH
11200: LD_STRING DMercPopov-Pop-1
11202: PPUSH
11203: CALL_OW 94
// Say ( Burlak , DMercPopov-Bur-1 ) ;
11207: LD_EXP 57
11211: PPUSH
11212: LD_STRING DMercPopov-Bur-1
11214: PPUSH
11215: CALL_OW 88
// SayRadio ( Popov , DMercPopov-Pop-2 ) ;
11219: LD_EXP 76
11223: PPUSH
11224: LD_STRING DMercPopov-Pop-2
11226: PPUSH
11227: CALL_OW 94
// DialogueOff ;
11231: CALL_OW 7
// end ; uc_side = 8 ;
11235: LD_ADDR_OWVAR 20
11239: PUSH
11240: LD_INT 8
11242: ST_TO_ADDR
// uc_nation = 2 ;
11243: LD_ADDR_OWVAR 21
11247: PUSH
11248: LD_INT 2
11250: ST_TO_ADDR
// PrepareSoldier ( false , 6 ) ;
11251: LD_INT 0
11253: PPUSH
11254: LD_INT 6
11256: PPUSH
11257: CALL_OW 381
// legionSold = CreateHuman ;
11261: LD_ADDR_VAR 0 1
11265: PUSH
11266: CALL_OW 44
11270: ST_TO_ADDR
// PlaceUnitXYR ( legionSold , 26 , 48 , 4 , false ) ;
11271: LD_VAR 0 1
11275: PPUSH
11276: LD_INT 26
11278: PPUSH
11279: LD_INT 48
11281: PPUSH
11282: LD_INT 4
11284: PPUSH
11285: LD_INT 0
11287: PPUSH
11288: CALL_OW 50
// repeat wait ( 0 0$1 ) ;
11292: LD_INT 35
11294: PPUSH
11295: CALL_OW 67
// ComMoveXY ( legionSold , GetX ( Heike ) , GetY ( Heike ) ) ;
11299: LD_VAR 0 1
11303: PPUSH
11304: LD_EXP 79
11308: PPUSH
11309: CALL_OW 250
11313: PPUSH
11314: LD_EXP 79
11318: PPUSH
11319: CALL_OW 251
11323: PPUSH
11324: CALL_OW 111
// until GetDistUnits ( legionSold , Heike ) <= 5 or IsDead ( Heike ) ;
11328: LD_VAR 0 1
11332: PPUSH
11333: LD_EXP 79
11337: PPUSH
11338: CALL_OW 296
11342: PUSH
11343: LD_INT 5
11345: LESSEQUAL
11346: PUSH
11347: LD_EXP 79
11351: PPUSH
11352: CALL_OW 301
11356: OR
11357: IFFALSE 11292
// SetSide ( Heike , 8 ) ;
11359: LD_EXP 79
11363: PPUSH
11364: LD_INT 8
11366: PPUSH
11367: CALL_OW 235
// allowExitFromMap = 3 ;
11371: LD_ADDR_EXP 18
11375: PUSH
11376: LD_INT 3
11378: ST_TO_ADDR
// ComMoveToArea ( [ legionSold , Heike ] , KurtExitMapArea ) ;
11379: LD_VAR 0 1
11383: PUSH
11384: LD_EXP 79
11388: PUSH
11389: EMPTY
11390: LIST
11391: LIST
11392: PPUSH
11393: LD_INT 11
11395: PPUSH
11396: CALL_OW 113
// exit ;
11400: GO 11410
// end ; end ; wait ( 0 0$3 ) ;
11402: LD_INT 105
11404: PPUSH
11405: CALL_OW 67
// enable ;
11409: ENABLE
// end ;
11410: PPOPN 1
11412: END
// export function Dial_PlayerDontSendHeike ; begin
11413: LD_INT 0
11415: PPUSH
// DialogueOn ;
11416: CALL_OW 6
// SayRadio ( Kurt , DMercDeceived-Kurt-1 ) ;
11420: LD_EXP 80
11424: PPUSH
11425: LD_STRING DMercDeceived-Kurt-1
11427: PPUSH
11428: CALL_OW 94
// DialogueOff ;
11432: CALL_OW 7
// SetAttitude ( 3 , 8 , att_enemy , true ) ;
11436: LD_INT 3
11438: PPUSH
11439: LD_INT 8
11441: PPUSH
11442: LD_INT 2
11444: PPUSH
11445: LD_INT 1
11447: PPUSH
11448: CALL_OW 80
// KurtAttack = true ;
11452: LD_ADDR_EXP 25
11456: PUSH
11457: LD_INT 1
11459: ST_TO_ADDR
// end ;
11460: LD_VAR 0 1
11464: RET
// export function Dial_BetrayedKurt1 ; begin
11465: LD_INT 0
11467: PPUSH
// DialogueOn ;
11468: CALL_OW 6
// Say ( Kurt , DMercDeceived-Kurt-1 ) ;
11472: LD_EXP 80
11476: PPUSH
11477: LD_STRING DMercDeceived-Kurt-1
11479: PPUSH
11480: CALL_OW 88
// DialogueOff ;
11484: CALL_OW 7
// if IsPlaced ( Kurt ) then
11488: LD_EXP 80
11492: PPUSH
11493: CALL_OW 305
11497: IFFALSE 11546
// begin SetSide ( KurtEng , 8 ) ;
11499: LD_EXP 82
11503: PPUSH
11504: LD_INT 8
11506: PPUSH
11507: CALL_OW 235
// allowExitFromMap = 3 ;
11511: LD_ADDR_EXP 18
11515: PUSH
11516: LD_INT 3
11518: ST_TO_ADDR
// if KurtCanEscape then
11519: LD_EXP 21
11523: IFFALSE 11546
// ComMoveToArea ( [ Kurt , KurtEng ] , KurtExitMapArea ) ;
11525: LD_EXP 80
11529: PUSH
11530: LD_EXP 82
11534: PUSH
11535: EMPTY
11536: LIST
11537: LIST
11538: PPUSH
11539: LD_INT 11
11541: PPUSH
11542: CALL_OW 113
// end ; end ;
11546: LD_VAR 0 1
11550: RET
// export function Dial_BetrayedKurt2 ; begin
11551: LD_INT 0
11553: PPUSH
// DialogueOn ;
11554: CALL_OW 6
// Say ( Kurt , DMercAmbush-Kurt-1 ) ;
11558: LD_EXP 80
11562: PPUSH
11563: LD_STRING DMercAmbush-Kurt-1
11565: PPUSH
11566: CALL_OW 88
// DialogueOff ;
11570: CALL_OW 7
// if IsPlaced ( Kurt ) then
11574: LD_EXP 80
11578: PPUSH
11579: CALL_OW 305
11583: IFFALSE 11632
// begin SetSide ( KurtEng , 8 ) ;
11585: LD_EXP 82
11589: PPUSH
11590: LD_INT 8
11592: PPUSH
11593: CALL_OW 235
// allowExitFromMap = 3 ;
11597: LD_ADDR_EXP 18
11601: PUSH
11602: LD_INT 3
11604: ST_TO_ADDR
// if KurtCanEscape then
11605: LD_EXP 21
11609: IFFALSE 11632
// ComMoveToArea ( [ Kurt , KurtEng ] , KurtExitMapArea ) ;
11611: LD_EXP 80
11615: PUSH
11616: LD_EXP 82
11620: PUSH
11621: EMPTY
11622: LIST
11623: LIST
11624: PPUSH
11625: LD_INT 11
11627: PPUSH
11628: CALL_OW 113
// end ; end ;
11632: LD_VAR 0 1
11636: RET
// every 0 0$1 trigger GetSide ( KurtEng ) = 3 do var playerUnits , unit ;
11637: LD_EXP 82
11641: PPUSH
11642: CALL_OW 255
11646: PUSH
11647: LD_INT 3
11649: EQUAL
11650: IFFALSE 11797
11652: GO 11654
11654: DISABLE
11655: LD_INT 0
11657: PPUSH
11658: PPUSH
// begin playerUnits = FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
11659: LD_ADDR_VAR 0 1
11663: PUSH
11664: LD_INT 22
11666: PUSH
11667: LD_INT 3
11669: PUSH
11670: EMPTY
11671: LIST
11672: LIST
11673: PUSH
11674: LD_INT 2
11676: PUSH
11677: LD_INT 21
11679: PUSH
11680: LD_INT 1
11682: PUSH
11683: EMPTY
11684: LIST
11685: LIST
11686: PUSH
11687: LD_INT 21
11689: PUSH
11690: LD_INT 2
11692: PUSH
11693: EMPTY
11694: LIST
11695: LIST
11696: PUSH
11697: EMPTY
11698: LIST
11699: LIST
11700: LIST
11701: PUSH
11702: EMPTY
11703: LIST
11704: LIST
11705: PPUSH
11706: CALL_OW 69
11710: ST_TO_ADDR
// for unit in playerUnits do
11711: LD_ADDR_VAR 0 2
11715: PUSH
11716: LD_VAR 0 1
11720: PUSH
11721: FOR_IN
11722: IFFALSE 11751
// begin if WantsToAttack ( unit ) = KurtEng then
11724: LD_VAR 0 2
11728: PPUSH
11729: CALL_OW 319
11733: PUSH
11734: LD_EXP 82
11738: EQUAL
11739: IFFALSE 11749
// begin Dial_BetrayedKurt2 ;
11741: CALL 11551 0 0
// exit ;
11745: POP
11746: POP
11747: GO 11797
// end ; end ;
11749: GO 11721
11751: POP
11752: POP
// if ( IsDying ( KurtEng ) or IsDead ( KurtEng ) ) and GetSide ( KurtEng ) = 3 then
11753: LD_EXP 82
11757: PPUSH
11758: CALL_OW 303
11762: PUSH
11763: LD_EXP 82
11767: PPUSH
11768: CALL_OW 301
11772: OR
11773: PUSH
11774: LD_EXP 82
11778: PPUSH
11779: CALL_OW 255
11783: PUSH
11784: LD_INT 3
11786: EQUAL
11787: AND
11788: IFFALSE 11796
// begin Dial_BetrayedKurt2 ;
11790: CALL 11551 0 0
// exit ;
11794: GO 11797
// end ; enable ;
11796: ENABLE
// end ;
11797: PPOPN 2
11799: END
// every 0 0$1 trigger GetAttitude ( 3 , 8 ) = att_neutral and GetLives ( Kurt ) <= 999 do
11800: LD_INT 3
11802: PPUSH
11803: LD_INT 8
11805: PPUSH
11806: CALL_OW 81
11810: PUSH
11811: LD_INT 0
11813: EQUAL
11814: PUSH
11815: LD_EXP 80
11819: PPUSH
11820: CALL_OW 256
11824: PUSH
11825: LD_INT 999
11827: LESSEQUAL
11828: AND
11829: IFFALSE 11854
11831: GO 11833
11833: DISABLE
// begin Dial_BetrayedKurt1 ;
11834: CALL 11465 0 0
// SetAttitude ( 3 , 8 , att_enemy , true ) ;
11838: LD_INT 3
11840: PPUSH
11841: LD_INT 8
11843: PPUSH
11844: LD_INT 2
11846: PPUSH
11847: LD_INT 1
11849: PPUSH
11850: CALL_OW 80
// end ;
11854: END
// every 0 0$1 trigger buildingsToBuild <= 11 do
11855: LD_EXP 8
11859: PUSH
11860: LD_INT 11
11862: LESSEQUAL
11863: IFFALSE 12112
11865: GO 11867
11867: DISABLE
// begin if not IsOK ( Kuzmov ) and not IsOK ( Oblukov ) then
11868: LD_EXP 72
11872: PPUSH
11873: CALL_OW 302
11877: NOT
11878: PUSH
11879: LD_EXP 74
11883: PPUSH
11884: CALL_OW 302
11888: NOT
11889: AND
11890: IFFALSE 11894
// exit ;
11892: GO 12112
// DialogueOn ;
11894: CALL_OW 6
// if IsOK ( Kuzmov ) then
11898: LD_EXP 72
11902: PPUSH
11903: CALL_OW 302
11907: IFFALSE 11923
// Say ( Kuzmov , DFiringRange-Kuz-1 ) else
11909: LD_EXP 72
11913: PPUSH
11914: LD_STRING DFiringRange-Kuz-1
11916: PPUSH
11917: CALL_OW 88
11921: GO 11935
// Say ( Oblukov , DFiringRange-Obl-1 ) ;
11923: LD_EXP 74
11927: PPUSH
11928: LD_STRING DFiringRange-Obl-1
11930: PPUSH
11931: CALL_OW 88
// Say ( Burlak , DFiringRange-Bur-1 ) ;
11935: LD_EXP 57
11939: PPUSH
11940: LD_STRING DFiringRange-Bur-1
11942: PPUSH
11943: CALL_OW 88
// CenterOnXY ( 99 , 30 ) ;
11947: LD_INT 99
11949: PPUSH
11950: LD_INT 30
11952: PPUSH
11953: CALL_OW 84
// Wait ( 0 0$0.5 ) ;
11957: LD_INT 18
11959: PPUSH
11960: CALL_OW 67
// RevealFogArea ( 3 , ShootArea ) ;
11964: LD_INT 3
11966: PPUSH
11967: LD_INT 12
11969: PPUSH
11970: CALL_OW 332
// SetAreaMapShow ( ShootArea , 1 ) ;
11974: LD_INT 12
11976: PPUSH
11977: LD_INT 1
11979: PPUSH
11980: CALL_OW 424
// if IsOK ( Kuzmov ) then
11984: LD_EXP 72
11988: PPUSH
11989: CALL_OW 302
11993: IFFALSE 12009
// Say ( Kuzmov , DFiringRange-Kuz-2 ) else
11995: LD_EXP 72
11999: PPUSH
12000: LD_STRING DFiringRange-Kuz-2
12002: PPUSH
12003: CALL_OW 88
12007: GO 12021
// Say ( Oblukov , DFiringRange-Obl-2 ) ;
12009: LD_EXP 74
12013: PPUSH
12014: LD_STRING DFiringRange-Obl-2
12016: PPUSH
12017: CALL_OW 88
// case Query ( QShootingGallery ) of 1 :
12021: LD_STRING QShootingGallery
12023: PPUSH
12024: CALL_OW 97
12028: PUSH
12029: LD_INT 1
12031: DOUBLE
12032: EQUAL
12033: IFTRUE 12037
12035: GO 12074
12037: POP
// begin Say ( Burlak , DQrShootingGallery#1-Bur-1 ) ;
12038: LD_EXP 57
12042: PPUSH
12043: LD_STRING DQrShootingGallery#1-Bur-1
12045: PPUSH
12046: CALL_OW 88
// BurlakRespect = BurlakRespect + 1 ;
12050: LD_ADDR_EXP 30
12054: PUSH
12055: LD_EXP 30
12059: PUSH
12060: LD_INT 1
12062: PLUS
12063: ST_TO_ADDR
// canShootTrening = true ;
12064: LD_ADDR_EXP 29
12068: PUSH
12069: LD_INT 1
12071: ST_TO_ADDR
// end ; 2 :
12072: GO 12108
12074: LD_INT 2
12076: DOUBLE
12077: EQUAL
12078: IFTRUE 12082
12080: GO 12107
12082: POP
// begin Say ( Burlak , DQrShootingGallery#2-Bur-1 ) ;
12083: LD_EXP 57
12087: PPUSH
12088: LD_STRING DQrShootingGallery#2-Bur-1
12090: PPUSH
12091: CALL_OW 88
// SetAreaMapShow ( ShootArea , 0 ) ;
12095: LD_INT 12
12097: PPUSH
12098: LD_INT 0
12100: PPUSH
12101: CALL_OW 424
// end ; end ;
12105: GO 12108
12107: POP
// DialogueOff ;
12108: CALL_OW 7
// end ;
12112: END
// every 0 0$1 trigger canShootTrening do
12113: LD_EXP 29
12117: IFFALSE 12127
12119: GO 12121
12121: DISABLE
// begin enable ;
12122: ENABLE
// ShootTreningController ;
12123: CALL 7091 0 0
// end ;
12127: END
// every 0 0$1 trigger buildingsToBuild <= 7 do var hunters , hunter ;
12128: LD_EXP 8
12132: PUSH
12133: LD_INT 7
12135: LESSEQUAL
12136: IFFALSE 12526
12138: GO 12140
12140: DISABLE
12141: LD_INT 0
12143: PPUSH
12144: PPUSH
// begin hunters = [ ] ;
12145: LD_ADDR_VAR 0 1
12149: PUSH
12150: EMPTY
12151: ST_TO_ADDR
// if IsOK ( Belkov ) then
12152: LD_EXP 66
12156: PPUSH
12157: CALL_OW 302
12161: IFFALSE 12179
// hunters = hunters ^ Belkov ;
12163: LD_ADDR_VAR 0 1
12167: PUSH
12168: LD_VAR 0 1
12172: PUSH
12173: LD_EXP 66
12177: ADD
12178: ST_TO_ADDR
// if IsOK ( Karamazov ) then
12179: LD_EXP 58
12183: PPUSH
12184: CALL_OW 302
12188: IFFALSE 12206
// hunters = hunters ^ Karamazov ;
12190: LD_ADDR_VAR 0 1
12194: PUSH
12195: LD_VAR 0 1
12199: PUSH
12200: LD_EXP 58
12204: ADD
12205: ST_TO_ADDR
// if IsOK ( Kozlov ) then
12206: LD_EXP 73
12210: PPUSH
12211: CALL_OW 302
12215: IFFALSE 12233
// hunters = hunters ^ Kozlov ;
12217: LD_ADDR_VAR 0 1
12221: PUSH
12222: LD_VAR 0 1
12226: PUSH
12227: LD_EXP 73
12231: ADD
12232: ST_TO_ADDR
// if not hunters then
12233: LD_VAR 0 1
12237: NOT
12238: IFFALSE 12242
// exit ;
12240: GO 12526
// hunter = hunters [ Rand ( 1 , hunters ) ] ;
12242: LD_ADDR_VAR 0 2
12246: PUSH
12247: LD_VAR 0 1
12251: PUSH
12252: LD_INT 1
12254: PPUSH
12255: LD_VAR 0 1
12259: PPUSH
12260: CALL_OW 12
12264: ARRAY
12265: ST_TO_ADDR
// DialogueOn ;
12266: CALL_OW 6
// case hunter of Belkov :
12270: LD_VAR 0 2
12274: PUSH
12275: LD_EXP 66
12279: DOUBLE
12280: EQUAL
12281: IFTRUE 12285
12283: GO 12300
12285: POP
// Say ( Belkov , DHunting-Bel-1 ) ; Karamazov :
12286: LD_EXP 66
12290: PPUSH
12291: LD_STRING DHunting-Bel-1
12293: PPUSH
12294: CALL_OW 88
12298: GO 12351
12300: LD_EXP 58
12304: DOUBLE
12305: EQUAL
12306: IFTRUE 12310
12308: GO 12325
12310: POP
// Say ( Karamazov , DHunting-Kar-1 ) ; Kozlov :
12311: LD_EXP 58
12315: PPUSH
12316: LD_STRING DHunting-Kar-1
12318: PPUSH
12319: CALL_OW 88
12323: GO 12351
12325: LD_EXP 73
12329: DOUBLE
12330: EQUAL
12331: IFTRUE 12335
12333: GO 12350
12335: POP
// Say ( Kozlov , DHunting-Koz-1 ) ; end ;
12336: LD_EXP 73
12340: PPUSH
12341: LD_STRING DHunting-Koz-1
12343: PPUSH
12344: CALL_OW 88
12348: GO 12351
12350: POP
// Say ( Burlak , DHunting-Bur-1 ) ;
12351: LD_EXP 57
12355: PPUSH
12356: LD_STRING DHunting-Bur-1
12358: PPUSH
12359: CALL_OW 88
// case hunter of Belkov :
12363: LD_VAR 0 2
12367: PUSH
12368: LD_EXP 66
12372: DOUBLE
12373: EQUAL
12374: IFTRUE 12378
12376: GO 12393
12378: POP
// Say ( Belkov , DHunting-Bel-2 ) ; Karamazov :
12379: LD_EXP 66
12383: PPUSH
12384: LD_STRING DHunting-Bel-2
12386: PPUSH
12387: CALL_OW 88
12391: GO 12444
12393: LD_EXP 58
12397: DOUBLE
12398: EQUAL
12399: IFTRUE 12403
12401: GO 12418
12403: POP
// Say ( Karamazov , DHunting-Kar-2 ) ; Kozlov :
12404: LD_EXP 58
12408: PPUSH
12409: LD_STRING DHunting-Kar-2
12411: PPUSH
12412: CALL_OW 88
12416: GO 12444
12418: LD_EXP 73
12422: DOUBLE
12423: EQUAL
12424: IFTRUE 12428
12426: GO 12443
12428: POP
// Say ( Kozlov , DHunting-Koz-2 ) ; end ;
12429: LD_EXP 73
12433: PPUSH
12434: LD_STRING DHunting-Koz-2
12436: PPUSH
12437: CALL_OW 88
12441: GO 12444
12443: POP
// DialogueOff ;
12444: CALL_OW 7
// case Query ( QHunting ) of 1 :
12448: LD_STRING QHunting
12450: PPUSH
12451: CALL_OW 97
12455: PUSH
12456: LD_INT 1
12458: DOUBLE
12459: EQUAL
12460: IFTRUE 12464
12462: GO 12502
12464: POP
// begin Say ( Burlak , DQrHunting#1-Bur-1 ) ;
12465: LD_EXP 57
12469: PPUSH
12470: LD_STRING DQrHunting#1-Bur-1
12472: PPUSH
12473: CALL_OW 88
// BurlakRespect = BurlakRespect + 1 ;
12477: LD_ADDR_EXP 30
12481: PUSH
12482: LD_EXP 30
12486: PUSH
12487: LD_INT 1
12489: PLUS
12490: ST_TO_ADDR
// GoToHunt ( hunter ) ;
12491: LD_VAR 0 2
12495: PPUSH
12496: CALL 7719 0 1
// end ; 2 :
12500: GO 12526
12502: LD_INT 2
12504: DOUBLE
12505: EQUAL
12506: IFTRUE 12510
12508: GO 12525
12510: POP
// Say ( Burlak , DQrHunting#2-Bur-1 ) ; end ;
12511: LD_EXP 57
12515: PPUSH
12516: LD_STRING DQrHunting#2-Bur-1
12518: PPUSH
12519: CALL_OW 88
12523: GO 12526
12525: POP
// end ;
12526: PPOPN 2
12528: END
// every 0 0$1 trigger buildingsToBuild <= 3 do var unit , womans , men , woman , man , depots ;
12529: LD_EXP 8
12533: PUSH
12534: LD_INT 3
12536: LESSEQUAL
12537: IFFALSE 13524
12539: GO 12541
12541: DISABLE
12542: LD_INT 0
12544: PPUSH
12545: PPUSH
12546: PPUSH
12547: PPUSH
12548: PPUSH
12549: PPUSH
// begin womans = [ ] ;
12550: LD_ADDR_VAR 0 2
12554: PUSH
12555: EMPTY
12556: ST_TO_ADDR
// men = [ ] ;
12557: LD_ADDR_VAR 0 3
12561: PUSH
12562: EMPTY
12563: ST_TO_ADDR
// if IsOK ( Petrovova ) then
12564: LD_EXP 59
12568: PPUSH
12569: CALL_OW 302
12573: IFFALSE 12591
// womans = womans ^ Petrovova ;
12575: LD_ADDR_VAR 0 2
12579: PUSH
12580: LD_VAR 0 2
12584: PUSH
12585: LD_EXP 59
12589: ADD
12590: ST_TO_ADDR
// if IsOK ( Kirilenkova ) then
12591: LD_EXP 65
12595: PPUSH
12596: CALL_OW 302
12600: IFFALSE 12618
// womans = womans ^ Kirilenkova ;
12602: LD_ADDR_VAR 0 2
12606: PUSH
12607: LD_VAR 0 2
12611: PUSH
12612: LD_EXP 65
12616: ADD
12617: ST_TO_ADDR
// if IsOK ( Kapitsova ) then
12618: LD_EXP 75
12622: PPUSH
12623: CALL_OW 302
12627: IFFALSE 12645
// womans = womans ^ Kapitsova ;
12629: LD_ADDR_VAR 0 2
12633: PUSH
12634: LD_VAR 0 2
12638: PUSH
12639: LD_EXP 75
12643: ADD
12644: ST_TO_ADDR
// DialogueOn ;
12645: CALL_OW 6
// if womans then
12649: LD_VAR 0 2
12653: IFFALSE 12780
// begin case womans [ Rand ( 1 , womans ) ] of Petrovova :
12655: LD_VAR 0 2
12659: PUSH
12660: LD_INT 1
12662: PPUSH
12663: LD_VAR 0 2
12667: PPUSH
12668: CALL_OW 12
12672: ARRAY
12673: PUSH
12674: LD_EXP 59
12678: DOUBLE
12679: EQUAL
12680: IFTRUE 12684
12682: GO 12709
12684: POP
// begin Say ( Petrovova , DFreeTime-Ptr-1 ) ;
12685: LD_EXP 59
12689: PPUSH
12690: LD_STRING DFreeTime-Ptr-1
12692: PPUSH
12693: CALL_OW 88
// woman = Petrovova ;
12697: LD_ADDR_VAR 0 4
12701: PUSH
12702: LD_EXP 59
12706: ST_TO_ADDR
// end ; Kirilenkova :
12707: GO 12780
12709: LD_EXP 65
12713: DOUBLE
12714: EQUAL
12715: IFTRUE 12719
12717: GO 12744
12719: POP
// begin Say ( Kirilenkova , DFreeTime-Kir-1 ) ;
12720: LD_EXP 65
12724: PPUSH
12725: LD_STRING DFreeTime-Kir-1
12727: PPUSH
12728: CALL_OW 88
// woman = Kirilenkova ;
12732: LD_ADDR_VAR 0 4
12736: PUSH
12737: LD_EXP 65
12741: ST_TO_ADDR
// end ; Kapitsova :
12742: GO 12780
12744: LD_EXP 75
12748: DOUBLE
12749: EQUAL
12750: IFTRUE 12754
12752: GO 12779
12754: POP
// begin Say ( Kapitsova , DFreeTime-Kap-1 ) ;
12755: LD_EXP 75
12759: PPUSH
12760: LD_STRING DFreeTime-Kap-1
12762: PPUSH
12763: CALL_OW 88
// woman = Kapitsova ;
12767: LD_ADDR_VAR 0 4
12771: PUSH
12772: LD_EXP 75
12776: ST_TO_ADDR
// end ; end ;
12777: GO 12780
12779: POP
// end ; if IsOK ( Kuzmov ) then
12780: LD_EXP 72
12784: PPUSH
12785: CALL_OW 302
12789: IFFALSE 12807
// men = men ^ Kuzmov ;
12791: LD_ADDR_VAR 0 3
12795: PUSH
12796: LD_VAR 0 3
12800: PUSH
12801: LD_EXP 72
12805: ADD
12806: ST_TO_ADDR
// if IsOK ( Titov ) then
12807: LD_EXP 62
12811: PPUSH
12812: CALL_OW 302
12816: IFFALSE 12834
// men = men ^ Titov ;
12818: LD_ADDR_VAR 0 3
12822: PUSH
12823: LD_VAR 0 3
12827: PUSH
12828: LD_EXP 62
12832: ADD
12833: ST_TO_ADDR
// if IsOK ( Gnyevko ) then
12834: LD_EXP 69
12838: PPUSH
12839: CALL_OW 302
12843: IFFALSE 12861
// men = men ^ Gnyevko ;
12845: LD_ADDR_VAR 0 3
12849: PUSH
12850: LD_VAR 0 3
12854: PUSH
12855: LD_EXP 69
12859: ADD
12860: ST_TO_ADDR
// if IsOK ( Oblukov ) then
12861: LD_EXP 74
12865: PPUSH
12866: CALL_OW 302
12870: IFFALSE 12888
// men = men ^ Oblukov ;
12872: LD_ADDR_VAR 0 3
12876: PUSH
12877: LD_VAR 0 3
12881: PUSH
12882: LD_EXP 74
12886: ADD
12887: ST_TO_ADDR
// if men then
12888: LD_VAR 0 3
12892: IFFALSE 13054
// begin case men [ Rand ( 1 , men ) ] of Kuzmov :
12894: LD_VAR 0 3
12898: PUSH
12899: LD_INT 1
12901: PPUSH
12902: LD_VAR 0 3
12906: PPUSH
12907: CALL_OW 12
12911: ARRAY
12912: PUSH
12913: LD_EXP 72
12917: DOUBLE
12918: EQUAL
12919: IFTRUE 12923
12921: GO 12948
12923: POP
// begin Say ( Kuzmov , DFreeTime-Kuz-1 ) ;
12924: LD_EXP 72
12928: PPUSH
12929: LD_STRING DFreeTime-Kuz-1
12931: PPUSH
12932: CALL_OW 88
// man = Kuzmov ;
12936: LD_ADDR_VAR 0 5
12940: PUSH
12941: LD_EXP 72
12945: ST_TO_ADDR
// end ; Titov :
12946: GO 13054
12948: LD_EXP 62
12952: DOUBLE
12953: EQUAL
12954: IFTRUE 12958
12956: GO 12983
12958: POP
// begin Say ( Titov , DFreeTime-Tit-1 ) ;
12959: LD_EXP 62
12963: PPUSH
12964: LD_STRING DFreeTime-Tit-1
12966: PPUSH
12967: CALL_OW 88
// man = Titov ;
12971: LD_ADDR_VAR 0 5
12975: PUSH
12976: LD_EXP 62
12980: ST_TO_ADDR
// end ; Gnyevko :
12981: GO 13054
12983: LD_EXP 69
12987: DOUBLE
12988: EQUAL
12989: IFTRUE 12993
12991: GO 13018
12993: POP
// begin Say ( Gnyevko , DFreeTime-Gny-1 ) ;
12994: LD_EXP 69
12998: PPUSH
12999: LD_STRING DFreeTime-Gny-1
13001: PPUSH
13002: CALL_OW 88
// man = Gnyevko ;
13006: LD_ADDR_VAR 0 5
13010: PUSH
13011: LD_EXP 69
13015: ST_TO_ADDR
// end ; Oblukov :
13016: GO 13054
13018: LD_EXP 74
13022: DOUBLE
13023: EQUAL
13024: IFTRUE 13028
13026: GO 13053
13028: POP
// begin Say ( Oblukov , DFreeTime-Obl-1 ) ;
13029: LD_EXP 74
13033: PPUSH
13034: LD_STRING DFreeTime-Obl-1
13036: PPUSH
13037: CALL_OW 88
// man = Oblukov ;
13041: LD_ADDR_VAR 0 5
13045: PUSH
13046: LD_EXP 74
13050: ST_TO_ADDR
// end ; end ;
13051: GO 13054
13053: POP
// end ; DialogueOff ;
13054: CALL_OW 7
// if not woman and not man then
13058: LD_VAR 0 4
13062: NOT
13063: PUSH
13064: LD_VAR 0 5
13068: NOT
13069: AND
13070: IFFALSE 13078
// begin DialogueOff ;
13072: CALL_OW 7
// exit ;
13076: GO 13524
// end ; case Query ( QFreeTime ) of 1 :
13078: LD_STRING QFreeTime
13080: PPUSH
13081: CALL_OW 97
13085: PUSH
13086: LD_INT 1
13088: DOUBLE
13089: EQUAL
13090: IFTRUE 13094
13092: GO 13496
13094: POP
// begin Say ( Burlak , DQrFreeTime#1-Bur-1 ) ;
13095: LD_EXP 57
13099: PPUSH
13100: LD_STRING DQrFreeTime#1-Bur-1
13102: PPUSH
13103: CALL_OW 88
// DialogueOff ;
13107: CALL_OW 7
// BurlakRespect = BurlakRespect + 1 ;
13111: LD_ADDR_EXP 30
13115: PUSH
13116: LD_EXP 30
13120: PUSH
13121: LD_INT 1
13123: PLUS
13124: ST_TO_ADDR
// SetSide ( [ woman , man ] , 6 ) ;
13125: LD_VAR 0 4
13129: PUSH
13130: LD_VAR 0 5
13134: PUSH
13135: EMPTY
13136: LIST
13137: LIST
13138: PPUSH
13139: LD_INT 6
13141: PPUSH
13142: CALL_OW 235
// for unit in [ woman , man ] do
13146: LD_ADDR_VAR 0 1
13150: PUSH
13151: LD_VAR 0 4
13155: PUSH
13156: LD_VAR 0 5
13160: PUSH
13161: EMPTY
13162: LIST
13163: LIST
13164: PUSH
13165: FOR_IN
13166: IFFALSE 13221
// if IsInUnit ( unit ) then
13168: LD_VAR 0 1
13172: PPUSH
13173: CALL_OW 310
13177: IFFALSE 13219
// begin if GetType ( IsInUnit ( unit ) ) = unit_vehicle then
13179: LD_VAR 0 1
13183: PPUSH
13184: CALL_OW 310
13188: PPUSH
13189: CALL_OW 247
13193: PUSH
13194: LD_INT 2
13196: EQUAL
13197: IFFALSE 13210
// ComExitVehicle ( unit ) else
13199: LD_VAR 0 1
13203: PPUSH
13204: CALL_OW 121
13208: GO 13219
// ComExitBuilding ( unit ) ;
13210: LD_VAR 0 1
13214: PPUSH
13215: CALL_OW 122
// end ;
13219: GO 13165
13221: POP
13222: POP
// wait ( 0 0$1 ) ;
13223: LD_INT 35
13225: PPUSH
13226: CALL_OW 67
// ComMoveToArea ( [ woman , man ] , ExitMapArea ) ;
13230: LD_VAR 0 4
13234: PUSH
13235: LD_VAR 0 5
13239: PUSH
13240: EMPTY
13241: LIST
13242: LIST
13243: PPUSH
13244: LD_INT 8
13246: PPUSH
13247: CALL_OW 113
// allowExitFromMap = 1 ;
13251: LD_ADDR_EXP 18
13255: PUSH
13256: LD_INT 1
13258: ST_TO_ADDR
// wait ( 3 3$0 ) ;
13259: LD_INT 6300
13261: PPUSH
13262: CALL_OW 67
// PlaceUnitXYR ( woman , 157 , 29 , 3 , false ) ;
13266: LD_VAR 0 4
13270: PPUSH
13271: LD_INT 157
13273: PPUSH
13274: LD_INT 29
13276: PPUSH
13277: LD_INT 3
13279: PPUSH
13280: LD_INT 0
13282: PPUSH
13283: CALL_OW 50
// PlaceUnitXYR ( man , 157 , 29 , 3 , false ) ;
13287: LD_VAR 0 5
13291: PPUSH
13292: LD_INT 157
13294: PPUSH
13295: LD_INT 29
13297: PPUSH
13298: LD_INT 3
13300: PPUSH
13301: LD_INT 0
13303: PPUSH
13304: CALL_OW 50
// SetSide ( [ woman , man ] , 3 ) ;
13308: LD_VAR 0 4
13312: PUSH
13313: LD_VAR 0 5
13317: PUSH
13318: EMPTY
13319: LIST
13320: LIST
13321: PPUSH
13322: LD_INT 3
13324: PPUSH
13325: CALL_OW 235
// depots = FilterAllUnits ( [ [ f_side , 3 ] , [ [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ] ) ;
13329: LD_ADDR_VAR 0 6
13333: PUSH
13334: LD_INT 22
13336: PUSH
13337: LD_INT 3
13339: PUSH
13340: EMPTY
13341: LIST
13342: LIST
13343: PUSH
13344: LD_INT 2
13346: PUSH
13347: LD_INT 30
13349: PUSH
13350: LD_INT 0
13352: PUSH
13353: EMPTY
13354: LIST
13355: LIST
13356: PUSH
13357: LD_INT 30
13359: PUSH
13360: LD_INT 1
13362: PUSH
13363: EMPTY
13364: LIST
13365: LIST
13366: PUSH
13367: EMPTY
13368: LIST
13369: LIST
13370: LIST
13371: PUSH
13372: EMPTY
13373: LIST
13374: PUSH
13375: EMPTY
13376: LIST
13377: LIST
13378: PPUSH
13379: CALL_OW 69
13383: ST_TO_ADDR
// if depots then
13384: LD_VAR 0 6
13388: IFFALSE 13438
// ComMoveXY ( [ woman , man ] , GetX ( depots [ 1 ] ) , GetY ( depots [ 1 ] ) ) else
13390: LD_VAR 0 4
13394: PUSH
13395: LD_VAR 0 5
13399: PUSH
13400: EMPTY
13401: LIST
13402: LIST
13403: PPUSH
13404: LD_VAR 0 6
13408: PUSH
13409: LD_INT 1
13411: ARRAY
13412: PPUSH
13413: CALL_OW 250
13417: PPUSH
13418: LD_VAR 0 6
13422: PUSH
13423: LD_INT 1
13425: ARRAY
13426: PPUSH
13427: CALL_OW 251
13431: PPUSH
13432: CALL_OW 111
13436: GO 13476
// ComMoveXY ( [ woman , man ] , GetX ( Burlak ) , GetY ( Burlak ) ) ;
13438: LD_VAR 0 4
13442: PUSH
13443: LD_VAR 0 5
13447: PUSH
13448: EMPTY
13449: LIST
13450: LIST
13451: PPUSH
13452: LD_EXP 57
13456: PPUSH
13457: CALL_OW 250
13461: PPUSH
13462: LD_EXP 57
13466: PPUSH
13467: CALL_OW 251
13471: PPUSH
13472: CALL_OW 111
// CenterOnUnits ( [ woman , man ] ) ;
13476: LD_VAR 0 4
13480: PUSH
13481: LD_VAR 0 5
13485: PUSH
13486: EMPTY
13487: LIST
13488: LIST
13489: PPUSH
13490: CALL_OW 85
// end ; 2 :
13494: GO 13520
13496: LD_INT 2
13498: DOUBLE
13499: EQUAL
13500: IFTRUE 13504
13502: GO 13519
13504: POP
// Say ( Burlak , DQrFreeTime#2-Bur-1 ) ; end ;
13505: LD_EXP 57
13509: PPUSH
13510: LD_STRING DQrFreeTime#2-Bur-1
13512: PPUSH
13513: CALL_OW 88
13517: GO 13520
13519: POP
// DialogueOff ;
13520: CALL_OW 7
// end ;
13524: PPOPN 6
13526: END
// every 0 0$1 trigger GetAmountWeaponsDataBuildOnVehicle ( false ) <= 2 do
13527: LD_INT 0
13529: PPUSH
13530: CALL 6800 0 1
13534: PUSH
13535: LD_INT 2
13537: LESSEQUAL
13538: IFFALSE 13673
13540: GO 13542
13542: DISABLE
// begin DialogueOn ;
13543: CALL_OW 6
// if IsOK ( Kozlov ) then
13547: LD_EXP 73
13551: PPUSH
13552: CALL_OW 302
13556: IFFALSE 13572
// Say ( Kozlov , DMasha-Koz-1 ) else
13558: LD_EXP 73
13562: PPUSH
13563: LD_STRING DMasha-Koz-1
13565: PPUSH
13566: CALL_OW 88
13570: GO 13635
// DialogRandom ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_ok ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) , DMasha-Koz-1 ,  , false , false ) ;
13572: LD_INT 22
13574: PUSH
13575: LD_INT 3
13577: PUSH
13578: EMPTY
13579: LIST
13580: LIST
13581: PUSH
13582: LD_INT 50
13584: PUSH
13585: EMPTY
13586: LIST
13587: PUSH
13588: LD_INT 21
13590: PUSH
13591: LD_INT 1
13593: PUSH
13594: EMPTY
13595: LIST
13596: LIST
13597: PUSH
13598: LD_INT 26
13600: PUSH
13601: LD_INT 1
13603: PUSH
13604: EMPTY
13605: LIST
13606: LIST
13607: PUSH
13608: EMPTY
13609: LIST
13610: LIST
13611: LIST
13612: LIST
13613: PPUSH
13614: CALL_OW 69
13618: PPUSH
13619: LD_STRING DMasha-Koz-1
13621: PPUSH
13622: LD_STRING 
13624: PPUSH
13625: LD_INT 0
13627: PPUSH
13628: LD_INT 0
13630: PPUSH
13631: CALL 6249 0 5
// Say ( Burlak , DMasha2-Bur-1 ) ;
13635: LD_EXP 57
13639: PPUSH
13640: LD_STRING DMasha2-Bur-1
13642: PPUSH
13643: CALL_OW 88
// DialogueOff ;
13647: CALL_OW 7
// Query ( QMasha ) ;
13651: LD_STRING QMasha
13653: PPUSH
13654: CALL_OW 97
// ChangeMissionObjectives ( MMasha ) ;
13658: LD_STRING MMasha
13660: PPUSH
13661: CALL_OW 337
// canChooseMashaVehicle = true ;
13665: LD_ADDR_EXP 36
13669: PUSH
13670: LD_INT 1
13672: ST_TO_ADDR
// end ;
13673: END
// export function Dial_ComputerTechResearched ; begin
13674: LD_INT 0
13676: PPUSH
// if IsOk ( Scholtze ) or IsOK ( Kapitsova ) then
13677: LD_EXP 71
13681: PPUSH
13682: CALL_OW 302
13686: PUSH
13687: LD_EXP 75
13691: PPUSH
13692: CALL_OW 302
13696: OR
13697: IFFALSE 13793
// begin DialogueOn ;
13699: CALL_OW 6
// if IsOK ( Scholtze ) then
13703: LD_EXP 71
13707: PPUSH
13708: CALL_OW 302
13712: IFFALSE 13728
// Say ( Scholtze , DAI-Sch-1 ) else
13714: LD_EXP 71
13718: PPUSH
13719: LD_STRING DAI-Sch-1
13721: PPUSH
13722: CALL_OW 88
13726: GO 13740
// Say ( Kapitsova , DAI-Kap-1 ) ;
13728: LD_EXP 75
13732: PPUSH
13733: LD_STRING DAI-Kap-1
13735: PPUSH
13736: CALL_OW 88
// Say ( Burlak , DAI-Bur-1 ) ;
13740: LD_EXP 57
13744: PPUSH
13745: LD_STRING DAI-Bur-1
13747: PPUSH
13748: CALL_OW 88
// if IsOK ( Scholtze ) then
13752: LD_EXP 71
13756: PPUSH
13757: CALL_OW 302
13761: IFFALSE 13777
// Say ( Scholtze , DAI-Sch-2 ) else
13763: LD_EXP 71
13767: PPUSH
13768: LD_STRING DAI-Sch-2
13770: PPUSH
13771: CALL_OW 88
13775: GO 13789
// Say ( Kapitsova , DAI-Kap-2 ) ;
13777: LD_EXP 75
13781: PPUSH
13782: LD_STRING DAI-Kap-2
13784: PPUSH
13785: CALL_OW 88
// DialogueOff ;
13789: CALL_OW 7
// end ; ChangeMissionObjectives ( MAI ) ;
13793: LD_STRING MAI
13795: PPUSH
13796: CALL_OW 337
// end ;
13800: LD_VAR 0 1
13804: RET
// export function Dial_TeleportTechResearched ; begin
13805: LD_INT 0
13807: PPUSH
// if IsOk ( Scholtze ) or IsOK ( Kapitsova ) then
13808: LD_EXP 71
13812: PPUSH
13813: CALL_OW 302
13817: PUSH
13818: LD_EXP 75
13822: PPUSH
13823: CALL_OW 302
13827: OR
13828: IFFALSE 13936
// begin DialogueOn ;
13830: CALL_OW 6
// if IsOK ( Scholtze ) then
13834: LD_EXP 71
13838: PPUSH
13839: CALL_OW 302
13843: IFFALSE 13859
// Say ( Scholtze , DSpontTelep-Sch-1 ) else
13845: LD_EXP 71
13849: PPUSH
13850: LD_STRING DSpontTelep-Sch-1
13852: PPUSH
13853: CALL_OW 88
13857: GO 13871
// Say ( Kapitsova , DSpontTelep-Kap-1 ) ;
13859: LD_EXP 75
13863: PPUSH
13864: LD_STRING DSpontTelep-Kap-1
13866: PPUSH
13867: CALL_OW 88
// Say ( Burlak , DSpontTelep-Bur-1 ) ;
13871: LD_EXP 57
13875: PPUSH
13876: LD_STRING DSpontTelep-Bur-1
13878: PPUSH
13879: CALL_OW 88
// if IsOK ( Scholtze ) then
13883: LD_EXP 71
13887: PPUSH
13888: CALL_OW 302
13892: IFFALSE 13908
// Say ( Scholtze , DSpontTelep-Sch-2 ) else
13894: LD_EXP 71
13898: PPUSH
13899: LD_STRING DSpontTelep-Sch-2
13901: PPUSH
13902: CALL_OW 88
13906: GO 13920
// Say ( Kapitsova , DSpontTelep-Kap-2 ) ;
13908: LD_EXP 75
13912: PPUSH
13913: LD_STRING DSpontTelep-Kap-2
13915: PPUSH
13916: CALL_OW 88
// Say ( Burlak , DSpontTelep-Bur-2 ) ;
13920: LD_EXP 57
13924: PPUSH
13925: LD_STRING DSpontTelep-Bur-2
13927: PPUSH
13928: CALL_OW 88
// DialogueOff ;
13932: CALL_OW 7
// end ; ChangeMissionObjectives ( MTele ) ;
13936: LD_STRING MTele
13938: PPUSH
13939: CALL_OW 337
// end ;
13943: LD_VAR 0 1
13947: RET
// every 0 0$1 trigger buildingsToBuild <= 3 and GetAmountWeaponsDataBuildOnVehicle ( false ) <= 1 and techsToResearch <= 4 do
13948: LD_EXP 8
13952: PUSH
13953: LD_INT 3
13955: LESSEQUAL
13956: PUSH
13957: LD_INT 0
13959: PPUSH
13960: CALL 6800 0 1
13964: PUSH
13965: LD_INT 1
13967: LESSEQUAL
13968: AND
13969: PUSH
13970: LD_EXP 9
13974: PUSH
13975: LD_INT 4
13977: LESSEQUAL
13978: AND
13979: IFFALSE 14180
13981: GO 13983
13983: DISABLE
// begin SayRadio ( Popov , DAmAttackStart-Pop-1 ) ;
13984: LD_EXP 76
13988: PPUSH
13989: LD_STRING DAmAttackStart-Pop-1
13991: PPUSH
13992: CALL_OW 94
// if KurtStatus = 1 and HeikeStatus = 1 then
13996: LD_EXP 22
14000: PUSH
14001: LD_INT 1
14003: EQUAL
14004: PUSH
14005: LD_EXP 3
14009: PUSH
14010: LD_INT 1
14012: EQUAL
14013: AND
14014: IFFALSE 14172
// begin wait ( 0 0$10 ) ;
14016: LD_INT 350
14018: PPUSH
14019: CALL_OW 67
// DialogueOn ;
14023: CALL_OW 6
// SayRadio ( Heike , DLegionFormed-Hke-1 ) ;
14027: LD_EXP 79
14031: PPUSH
14032: LD_STRING DLegionFormed-Hke-1
14034: PPUSH
14035: CALL_OW 94
// Say ( Burlak , DLegionFormed-Bur-1 ) ;
14039: LD_EXP 57
14043: PPUSH
14044: LD_STRING DLegionFormed-Bur-1
14046: PPUSH
14047: CALL_OW 88
// SayRadio ( Heike , DLegionFormed-Hke-2 ) ;
14051: LD_EXP 79
14055: PPUSH
14056: LD_STRING DLegionFormed-Hke-2
14058: PPUSH
14059: CALL_OW 94
// Say ( Burlak , DLegionFormed-Bur-2 ) ;
14063: LD_EXP 57
14067: PPUSH
14068: LD_STRING DLegionFormed-Bur-2
14070: PPUSH
14071: CALL_OW 88
// SayRadio ( Heike , DLegionFormed-Hke-3 ) ;
14075: LD_EXP 79
14079: PPUSH
14080: LD_STRING DLegionFormed-Hke-3
14082: PPUSH
14083: CALL_OW 94
// case Query ( QLegion ) of 1 :
14087: LD_STRING QLegion
14089: PPUSH
14090: CALL_OW 97
14094: PUSH
14095: LD_INT 1
14097: DOUBLE
14098: EQUAL
14099: IFTRUE 14103
14101: GO 14134
14103: POP
// begin acceptLegionOffert = true ;
14104: LD_ADDR_EXP 31
14108: PUSH
14109: LD_INT 1
14111: ST_TO_ADDR
// legionOffertCountdown = true ;
14112: LD_ADDR_EXP 33
14116: PUSH
14117: LD_INT 1
14119: ST_TO_ADDR
// Say ( Burlak , DQrLegion#1-Bur-1 ) ;
14120: LD_EXP 57
14124: PPUSH
14125: LD_STRING DQrLegion#1-Bur-1
14127: PPUSH
14128: CALL_OW 88
// end ; 2 :
14132: GO 14166
14134: LD_INT 2
14136: DOUBLE
14137: EQUAL
14138: IFTRUE 14142
14140: GO 14165
14142: POP
// begin Say ( Burlak , DQrLegion#2-Bur-1 ) ;
14143: LD_EXP 57
14147: PPUSH
14148: LD_STRING DQrLegion#2-Bur-1
14150: PPUSH
14151: CALL_OW 88
// americansAttack = true ;
14155: LD_ADDR_EXP 26
14159: PUSH
14160: LD_INT 1
14162: ST_TO_ADDR
// end ; end ;
14163: GO 14166
14165: POP
// DialogueOff ;
14166: CALL_OW 7
// end else
14170: GO 14180
// begin americansAttack = true ;
14172: LD_ADDR_EXP 26
14176: PUSH
14177: LD_INT 1
14179: ST_TO_ADDR
// end ; end ;
14180: END
// every 0 0$1 trigger legionOffertTime <= 0 0$00 do
14181: LD_EXP 34
14185: PUSH
14186: LD_INT 0
14188: LESSEQUAL
14189: IFFALSE 14210
14191: GO 14193
14193: DISABLE
// begin legionOffertCountdown = false ;
14194: LD_ADDR_EXP 33
14198: PUSH
14199: LD_INT 0
14201: ST_TO_ADDR
// americansAttack = true ;
14202: LD_ADDR_EXP 26
14206: PUSH
14207: LD_INT 1
14209: ST_TO_ADDR
// end ;
14210: END
// every 0 0$1 trigger legionOffertCountdown do var needCrates , depots , depot , crates ;
14211: LD_EXP 33
14215: IFFALSE 14401
14217: GO 14219
14219: DISABLE
14220: LD_INT 0
14222: PPUSH
14223: PPUSH
14224: PPUSH
14225: PPUSH
// begin needCrates = 50 ;
14226: LD_ADDR_VAR 0 1
14230: PUSH
14231: LD_INT 50
14233: ST_TO_ADDR
// crates = 0 ;
14234: LD_ADDR_VAR 0 4
14238: PUSH
14239: LD_INT 0
14241: ST_TO_ADDR
// depots = FilterAllUnits ( [ [ f_side , 3 ] , [ [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ] ) ;
14242: LD_ADDR_VAR 0 2
14246: PUSH
14247: LD_INT 22
14249: PUSH
14250: LD_INT 3
14252: PUSH
14253: EMPTY
14254: LIST
14255: LIST
14256: PUSH
14257: LD_INT 2
14259: PUSH
14260: LD_INT 30
14262: PUSH
14263: LD_INT 0
14265: PUSH
14266: EMPTY
14267: LIST
14268: LIST
14269: PUSH
14270: LD_INT 30
14272: PUSH
14273: LD_INT 1
14275: PUSH
14276: EMPTY
14277: LIST
14278: LIST
14279: PUSH
14280: EMPTY
14281: LIST
14282: LIST
14283: LIST
14284: PUSH
14285: EMPTY
14286: LIST
14287: PUSH
14288: EMPTY
14289: LIST
14290: LIST
14291: PPUSH
14292: CALL_OW 69
14296: ST_TO_ADDR
// for depot in depots do
14297: LD_ADDR_VAR 0 3
14301: PUSH
14302: LD_VAR 0 2
14306: PUSH
14307: FOR_IN
14308: IFFALSE 14399
// begin crates = GetResourceType ( GetBase ( depot ) , mat_cans ) ;
14310: LD_ADDR_VAR 0 4
14314: PUSH
14315: LD_VAR 0 3
14319: PPUSH
14320: CALL_OW 274
14324: PPUSH
14325: LD_INT 1
14327: PPUSH
14328: CALL_OW 275
14332: ST_TO_ADDR
// if crates >= needCrates then
14333: LD_VAR 0 4
14337: PUSH
14338: LD_VAR 0 1
14342: GREATEREQUAL
14343: IFFALSE 14397
// begin SetResourceType ( GetBase ( depot ) , mat_cans , crates - needCrates ) ;
14345: LD_VAR 0 3
14349: PPUSH
14350: CALL_OW 274
14354: PPUSH
14355: LD_INT 1
14357: PPUSH
14358: LD_VAR 0 4
14362: PUSH
14363: LD_VAR 0 1
14367: MINUS
14368: PPUSH
14369: CALL_OW 277
// legionOffertCountdown = false ;
14373: LD_ADDR_EXP 33
14377: PUSH
14378: LD_INT 0
14380: ST_TO_ADDR
// paidLegionOffert = true ;
14381: LD_ADDR_EXP 32
14385: PUSH
14386: LD_INT 1
14388: ST_TO_ADDR
// americansAttack = true ;
14389: LD_ADDR_EXP 26
14393: PUSH
14394: LD_INT 1
14396: ST_TO_ADDR
// end ; end ;
14397: GO 14307
14399: POP
14400: POP
// end ;
14401: PPOPN 4
14403: END
// every 0 0$1 trigger currentAmWave >= americansAttackWaves and FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_type , unit_human ] , [ f_and , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ] ] ) = 0 do
14404: LD_EXP 85
14408: PUSH
14409: LD_EXP 48
14413: GREATEREQUAL
14414: PUSH
14415: LD_INT 22
14417: PUSH
14418: LD_INT 1
14420: PUSH
14421: EMPTY
14422: LIST
14423: LIST
14424: PUSH
14425: LD_INT 2
14427: PUSH
14428: LD_INT 21
14430: PUSH
14431: LD_INT 1
14433: PUSH
14434: EMPTY
14435: LIST
14436: LIST
14437: PUSH
14438: LD_INT 1
14440: PUSH
14441: LD_INT 21
14443: PUSH
14444: LD_INT 2
14446: PUSH
14447: EMPTY
14448: LIST
14449: LIST
14450: PUSH
14451: LD_INT 33
14453: PUSH
14454: LD_INT 3
14456: PUSH
14457: EMPTY
14458: LIST
14459: LIST
14460: PUSH
14461: EMPTY
14462: LIST
14463: LIST
14464: LIST
14465: PUSH
14466: EMPTY
14467: LIST
14468: LIST
14469: LIST
14470: PUSH
14471: EMPTY
14472: LIST
14473: LIST
14474: PPUSH
14475: CALL_OW 69
14479: PUSH
14480: LD_INT 0
14482: EQUAL
14483: AND
14484: IFFALSE 14684
14486: GO 14488
14488: DISABLE
// begin DialogueOn ;
14489: CALL_OW 6
// if IsOK ( Belkov ) then
14493: LD_EXP 66
14497: PPUSH
14498: CALL_OW 302
14502: IFFALSE 14518
// Say ( Belkov , DAmAttackFin-Bel-1 ) else
14504: LD_EXP 66
14508: PPUSH
14509: LD_STRING DAmAttackFin-Bel-1
14511: PPUSH
14512: CALL_OW 88
14516: GO 14541
// if IsOK ( Belkov2 ) then
14518: LD_EXP 67
14522: PPUSH
14523: CALL_OW 302
14527: IFFALSE 14541
// Say ( Belkov2 , DAmAttackFin-Bel-1 ) ;
14529: LD_EXP 67
14533: PPUSH
14534: LD_STRING DAmAttackFin-Bel-1
14536: PPUSH
14537: CALL_OW 88
// if IsOK ( Gnyevko ) then
14541: LD_EXP 69
14545: PPUSH
14546: CALL_OW 302
14550: IFFALSE 14564
// Say ( Gnyevko , DAmAttackFin-Gny-1 ) ;
14552: LD_EXP 69
14556: PPUSH
14557: LD_STRING DAmAttackFin-Gny-1
14559: PPUSH
14560: CALL_OW 88
// if IsOK ( Titov ) then
14564: LD_EXP 62
14568: PPUSH
14569: CALL_OW 302
14573: IFFALSE 14587
// Say ( Titov , DAmAttackFin-Tit-1 ) ;
14575: LD_EXP 62
14579: PPUSH
14580: LD_STRING DAmAttackFin-Tit-1
14582: PPUSH
14583: CALL_OW 88
// if IsOK ( Lipshchin ) then
14587: LD_EXP 64
14591: PPUSH
14592: CALL_OW 302
14596: IFFALSE 14610
// Say ( Lipshchin , DAmAttackFin-Lip-1 ) ;
14598: LD_EXP 64
14602: PPUSH
14603: LD_STRING DAmAttackFin-Lip-1
14605: PPUSH
14606: CALL_OW 88
// if IsOK ( Karamazov ) then
14610: LD_EXP 58
14614: PPUSH
14615: CALL_OW 302
14619: IFFALSE 14633
// Say ( Karamazov , DAmAttackFin-Kar-1 ) ;
14621: LD_EXP 58
14625: PPUSH
14626: LD_STRING DAmAttackFin-Kar-1
14628: PPUSH
14629: CALL_OW 88
// if IsOK ( Oblukov ) then
14633: LD_EXP 74
14637: PPUSH
14638: CALL_OW 302
14642: IFFALSE 14656
// Say ( Oblukov , DAmAttackFin-Obl-1 ) ;
14644: LD_EXP 74
14648: PPUSH
14649: LD_STRING DAmAttackFin-Obl-1
14651: PPUSH
14652: CALL_OW 88
// Say ( Burlak , AmAttackFin-Bur-1 ) ;
14656: LD_EXP 57
14660: PPUSH
14661: LD_STRING AmAttackFin-Bur-1
14663: PPUSH
14664: CALL_OW 88
// SayRadio ( Popov , DAmAttackFin-Pop-1 ) ;
14668: LD_EXP 76
14672: PPUSH
14673: LD_STRING DAmAttackFin-Pop-1
14675: PPUSH
14676: CALL_OW 94
// DialogueOff ;
14680: CALL_OW 7
// end ;
14684: END
// every 0 0$1 trigger buildingsToBuild + ( 3 - GetAmountWeaponsDataBuildOnTurret ( true ) ) = 0 do
14685: LD_EXP 8
14689: PUSH
14690: LD_INT 3
14692: PUSH
14693: LD_INT 1
14695: PPUSH
14696: CALL 6690 0 1
14700: MINUS
14701: PLUS
14702: PUSH
14703: LD_INT 0
14705: EQUAL
14706: IFFALSE 14718
14708: GO 14710
14710: DISABLE
// ChangeMissionObjectives ( MBuildingsDone ) ;
14711: LD_STRING MBuildingsDone
14713: PPUSH
14714: CALL_OW 337
14718: END
// every 0 0$1 trigger GetAmountWeaponsDataBuildOnVehicle ( false ) = 0 do
14719: LD_INT 0
14721: PPUSH
14722: CALL 6800 0 1
14726: PUSH
14727: LD_INT 0
14729: EQUAL
14730: IFFALSE 14742
14732: GO 14734
14734: DISABLE
// ChangeMissionObjectives ( MWeaponsDone ) ;
14735: LD_STRING MWeaponsDone
14737: PPUSH
14738: CALL_OW 337
14742: END
// every 0 0$1 trigger techsToResearch = 0 do
14743: LD_EXP 9
14747: PUSH
14748: LD_INT 0
14750: EQUAL
14751: IFFALSE 14763
14753: GO 14755
14755: DISABLE
// ChangeMissionObjectives ( MTechnoDone ) ;
14756: LD_STRING MTechnoDone
14758: PPUSH
14759: CALL_OW 337
14763: END
// every 0 0$1 trigger americansAttack and not FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_type , unit_human ] , [ f_and , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ] ] ) do
14764: LD_EXP 26
14768: PUSH
14769: LD_INT 22
14771: PUSH
14772: LD_INT 1
14774: PUSH
14775: EMPTY
14776: LIST
14777: LIST
14778: PUSH
14779: LD_INT 2
14781: PUSH
14782: LD_INT 21
14784: PUSH
14785: LD_INT 1
14787: PUSH
14788: EMPTY
14789: LIST
14790: LIST
14791: PUSH
14792: LD_INT 1
14794: PUSH
14795: LD_INT 21
14797: PUSH
14798: LD_INT 2
14800: PUSH
14801: EMPTY
14802: LIST
14803: LIST
14804: PUSH
14805: LD_INT 33
14807: PUSH
14808: LD_INT 3
14810: PUSH
14811: EMPTY
14812: LIST
14813: LIST
14814: PUSH
14815: EMPTY
14816: LIST
14817: LIST
14818: LIST
14819: PUSH
14820: EMPTY
14821: LIST
14822: LIST
14823: LIST
14824: PUSH
14825: EMPTY
14826: LIST
14827: LIST
14828: PPUSH
14829: CALL_OW 69
14833: NOT
14834: AND
14835: IFFALSE 14847
14837: GO 14839
14839: DISABLE
// ChangeMissionObjectives ( MEnemyDone ) ;
14840: LD_STRING MEnemyDone
14842: PPUSH
14843: CALL_OW 337
14847: END
// every 0 0$1 trigger ( buildingsToBuild + ( 3 - GetAmountWeaponsDataBuildOnTurret ( true ) ) ) = 0 and GetAmountWeaponsDataBuildOnVehicle ( false ) = 0 and techsToResearch = 0 and FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] ] ) = 0 and FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_type , unit_human ] , [ f_and , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ] ] ) = 0 and Masha and IsOK ( Masha [ 1 ] ) and buildCompVehicle and testedTeleport do
14848: LD_EXP 8
14852: PUSH
14853: LD_INT 3
14855: PUSH
14856: LD_INT 1
14858: PPUSH
14859: CALL 6690 0 1
14863: MINUS
14864: PLUS
14865: PUSH
14866: LD_INT 0
14868: EQUAL
14869: PUSH
14870: LD_INT 0
14872: PPUSH
14873: CALL 6800 0 1
14877: PUSH
14878: LD_INT 0
14880: EQUAL
14881: AND
14882: PUSH
14883: LD_EXP 9
14887: PUSH
14888: LD_INT 0
14890: EQUAL
14891: AND
14892: PUSH
14893: LD_INT 22
14895: PUSH
14896: LD_INT 8
14898: PUSH
14899: EMPTY
14900: LIST
14901: LIST
14902: PUSH
14903: LD_INT 21
14905: PUSH
14906: LD_INT 1
14908: PUSH
14909: EMPTY
14910: LIST
14911: LIST
14912: PUSH
14913: EMPTY
14914: LIST
14915: LIST
14916: PPUSH
14917: CALL_OW 69
14921: PUSH
14922: LD_INT 0
14924: EQUAL
14925: AND
14926: PUSH
14927: LD_INT 22
14929: PUSH
14930: LD_INT 1
14932: PUSH
14933: EMPTY
14934: LIST
14935: LIST
14936: PUSH
14937: LD_INT 2
14939: PUSH
14940: LD_INT 21
14942: PUSH
14943: LD_INT 1
14945: PUSH
14946: EMPTY
14947: LIST
14948: LIST
14949: PUSH
14950: LD_INT 1
14952: PUSH
14953: LD_INT 21
14955: PUSH
14956: LD_INT 2
14958: PUSH
14959: EMPTY
14960: LIST
14961: LIST
14962: PUSH
14963: LD_INT 33
14965: PUSH
14966: LD_INT 3
14968: PUSH
14969: EMPTY
14970: LIST
14971: LIST
14972: PUSH
14973: EMPTY
14974: LIST
14975: LIST
14976: LIST
14977: PUSH
14978: EMPTY
14979: LIST
14980: LIST
14981: LIST
14982: PUSH
14983: EMPTY
14984: LIST
14985: LIST
14986: PPUSH
14987: CALL_OW 69
14991: PUSH
14992: LD_INT 0
14994: EQUAL
14995: AND
14996: PUSH
14997: LD_EXP 4
15001: AND
15002: PUSH
15003: LD_EXP 4
15007: PUSH
15008: LD_INT 1
15010: ARRAY
15011: PPUSH
15012: CALL_OW 302
15016: AND
15017: PUSH
15018: LD_EXP 37
15022: AND
15023: PUSH
15024: LD_EXP 39
15028: AND
15029: IFFALSE 15038
15031: GO 15033
15033: DISABLE
// begin FinishMission ;
15034: CALL 15243 0 0
// end ;
15038: END
// every 0 0$1 do var unit ;
15039: GO 15041
15041: DISABLE
15042: LD_INT 0
15044: PPUSH
// begin case allowExitFromMap of 1 :
15045: LD_EXP 18
15049: PUSH
15050: LD_INT 1
15052: DOUBLE
15053: EQUAL
15054: IFTRUE 15058
15056: GO 15086
15058: POP
// RemoveUnits ( FilterUnitsInArea ( ExitMapArea , [ [ f_side , 6 ] ] ) ) ; 3 :
15059: LD_INT 8
15061: PPUSH
15062: LD_INT 22
15064: PUSH
15065: LD_INT 6
15067: PUSH
15068: EMPTY
15069: LIST
15070: LIST
15071: PUSH
15072: EMPTY
15073: LIST
15074: PPUSH
15075: CALL_OW 70
15079: PPUSH
15080: CALL 6526 0 1
15084: GO 15209
15086: LD_INT 3
15088: DOUBLE
15089: EQUAL
15090: IFTRUE 15094
15092: GO 15122
15094: POP
// RemoveUnits ( FilterUnitsInArea ( KurtExitMapArea , [ [ f_side , 8 ] ] ) ) ; 4 :
15095: LD_INT 11
15097: PPUSH
15098: LD_INT 22
15100: PUSH
15101: LD_INT 8
15103: PUSH
15104: EMPTY
15105: LIST
15106: LIST
15107: PUSH
15108: EMPTY
15109: LIST
15110: PPUSH
15111: CALL_OW 70
15115: PPUSH
15116: CALL 6526 0 1
15120: GO 15209
15122: LD_INT 4
15124: DOUBLE
15125: EQUAL
15126: IFTRUE 15130
15128: GO 15208
15130: POP
// begin RemoveUnits ( FilterUnitsInArea ( ExitMapArea , [ [ f_side , 8 ] ] ) ) ;
15131: LD_INT 8
15133: PPUSH
15134: LD_INT 22
15136: PUSH
15137: LD_INT 8
15139: PUSH
15140: EMPTY
15141: LIST
15142: LIST
15143: PUSH
15144: EMPTY
15145: LIST
15146: PPUSH
15147: CALL_OW 70
15151: PPUSH
15152: CALL 6526 0 1
// RemoveUnits ( FilterUnitsInArea ( KurtExitMapArea , [ [ f_side , 8 ] ] ) ) ;
15156: LD_INT 11
15158: PPUSH
15159: LD_INT 22
15161: PUSH
15162: LD_INT 8
15164: PUSH
15165: EMPTY
15166: LIST
15167: LIST
15168: PUSH
15169: EMPTY
15170: LIST
15171: PPUSH
15172: CALL_OW 70
15176: PPUSH
15177: CALL 6526 0 1
// RemoveUnits ( FilterUnitsInArea ( ExitMapArea , [ [ f_side , 2 ] ] ) ) ;
15181: LD_INT 8
15183: PPUSH
15184: LD_INT 22
15186: PUSH
15187: LD_INT 2
15189: PUSH
15190: EMPTY
15191: LIST
15192: LIST
15193: PUSH
15194: EMPTY
15195: LIST
15196: PPUSH
15197: CALL_OW 70
15201: PPUSH
15202: CALL 6526 0 1
// end ; end ;
15206: GO 15209
15208: POP
// enable ;
15209: ENABLE
// end ; end_of_file
15210: PPOPN 1
15212: END
// export function Lose_Burlak ; begin
15213: LD_INT 0
15215: PPUSH
// YouLost ( Burlak ) ;
15216: LD_STRING Burlak
15218: PPUSH
15219: CALL_OW 104
// end ;
15223: LD_VAR 0 1
15227: RET
// export function Lost_AttackAlly ; begin
15228: LD_INT 0
15230: PPUSH
// YouLost ( SelfAttack ) ;
15231: LD_STRING SelfAttack
15233: PPUSH
15234: CALL_OW 104
// end ; end_of_file
15238: LD_VAR 0 1
15242: RET
// export function FinishMission ; begin
15243: LD_INT 0
15245: PPUSH
// SetRewards ;
15246: CALL 15267 0 0
// SavePlayerCharacters ;
15250: CALL 15528 0 0
// SaveGlobalVariables ;
15254: CALL 16078 0 0
// YouWin ;
15258: CALL_OW 103
// end ;
15262: LD_VAR 0 1
15266: RET
// function SetRewards ; begin
15267: LD_INT 0
15269: PPUSH
// AddMedal ( ArtisticImpression , 1 ) ;
15270: LD_STRING ArtisticImpression
15272: PPUSH
15273: LD_INT 1
15275: PPUSH
15276: CALL_OW 101
// if not HeikeCaptured then
15280: LD_EXP 1
15284: NOT
15285: IFFALSE 15319
// begin if speedMedalTime >= 0 0$00 then
15287: LD_EXP 52
15291: PUSH
15292: LD_INT 0
15294: GREATEREQUAL
15295: IFFALSE 15309
// AddMedal ( Speed , 1 ) else
15297: LD_STRING Speed
15299: PPUSH
15300: LD_INT 1
15302: PPUSH
15303: CALL_OW 101
15307: GO 15319
// AddMedal ( Speed , 1 ) ;
15309: LD_STRING Speed
15311: PPUSH
15312: LD_INT 1
15314: PPUSH
15315: CALL_OW 101
// end ; if lostUnits then
15319: LD_EXP 40
15323: IFFALSE 15338
// begin AddMedal ( FavouriteCommander , - 1 ) ;
15325: LD_STRING FavouriteCommander
15327: PPUSH
15328: LD_INT 1
15330: NEG
15331: PPUSH
15332: CALL_OW 101
// end else
15336: GO 15430
// begin case BurlakRespect of 0 :
15338: LD_EXP 30
15342: PUSH
15343: LD_INT 0
15345: DOUBLE
15346: EQUAL
15347: IFTRUE 15351
15349: GO 15365
15351: POP
// AddMedal ( FavouriteCommander , - 2 ) ; 1 :
15352: LD_STRING FavouriteCommander
15354: PPUSH
15355: LD_INT 2
15357: NEG
15358: PPUSH
15359: CALL_OW 101
15363: GO 15430
15365: LD_INT 1
15367: DOUBLE
15368: EQUAL
15369: IFTRUE 15373
15371: GO 15387
15373: POP
// AddMedal ( FavouriteCommander , - 3 ) ; 2 :
15374: LD_STRING FavouriteCommander
15376: PPUSH
15377: LD_INT 3
15379: NEG
15380: PPUSH
15381: CALL_OW 101
15385: GO 15430
15387: LD_INT 2
15389: DOUBLE
15390: EQUAL
15391: IFTRUE 15395
15393: GO 15408
15395: POP
// AddMedal ( FavouriteCommander , 1 ) ; 3 :
15396: LD_STRING FavouriteCommander
15398: PPUSH
15399: LD_INT 1
15401: PPUSH
15402: CALL_OW 101
15406: GO 15430
15408: LD_INT 3
15410: DOUBLE
15411: EQUAL
15412: IFTRUE 15416
15414: GO 15429
15416: POP
// AddMedal ( FavouriteCommander , 1 ) ; end ;
15417: LD_STRING FavouriteCommander
15419: PPUSH
15420: LD_INT 1
15422: PPUSH
15423: CALL_OW 101
15427: GO 15430
15429: POP
// end ; if HeikeCaptured then
15430: LD_EXP 1
15434: IFFALSE 15465
// begin if buildArabBarrack then
15436: LD_EXP 38
15440: IFFALSE 15454
// AddMedal ( ArabBarracks , 1 ) else
15442: LD_STRING ArabBarracks
15444: PPUSH
15445: LD_INT 1
15447: PPUSH
15448: CALL_OW 101
15452: GO 15465
// AddMedal ( ArabBarracks , - 1 ) ;
15454: LD_STRING ArabBarracks
15456: PPUSH
15457: LD_INT 1
15459: NEG
15460: PPUSH
15461: CALL_OW 101
// end ; GiveMedals ( Main1 ) ;
15465: LD_STRING Main1
15467: PPUSH
15468: CALL_OW 102
// RewardPeople ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_nation , nation_russian ] , [ f_ok ] ] ) ) ;
15472: LD_INT 22
15474: PUSH
15475: LD_INT 3
15477: PUSH
15478: EMPTY
15479: LIST
15480: LIST
15481: PUSH
15482: LD_INT 21
15484: PUSH
15485: LD_INT 1
15487: PUSH
15488: EMPTY
15489: LIST
15490: LIST
15491: PUSH
15492: LD_INT 23
15494: PUSH
15495: LD_INT 3
15497: PUSH
15498: EMPTY
15499: LIST
15500: LIST
15501: PUSH
15502: LD_INT 50
15504: PUSH
15505: EMPTY
15506: LIST
15507: PUSH
15508: EMPTY
15509: LIST
15510: LIST
15511: LIST
15512: LIST
15513: PPUSH
15514: CALL_OW 69
15518: PPUSH
15519: CALL_OW 43
// end ;
15523: LD_VAR 0 1
15527: RET
// function SavePlayerCharacters ; var randomsToSave ; begin
15528: LD_INT 0
15530: PPUSH
15531: PPUSH
// ExtSaveCharacter ( Burlak , Burlak , 3 ) ;
15532: LD_EXP 57
15536: PPUSH
15537: LD_STRING Burlak
15539: PPUSH
15540: LD_INT 3
15542: PPUSH
15543: CALL 6048 0 3
// ExtSaveCharacter ( Karamazov , Karamazov , 3 ) ;
15547: LD_EXP 58
15551: PPUSH
15552: LD_STRING Karamazov
15554: PPUSH
15555: LD_INT 3
15557: PPUSH
15558: CALL 6048 0 3
// ExtSaveCharacter ( Petrovova , Petrovova , 3 ) ;
15562: LD_EXP 59
15566: PPUSH
15567: LD_STRING Petrovova
15569: PPUSH
15570: LD_INT 3
15572: PPUSH
15573: CALL 6048 0 3
// ExtSaveCharacter ( Gleb , Gleb , 3 ) ;
15577: LD_EXP 60
15581: PPUSH
15582: LD_STRING Gleb
15584: PPUSH
15585: LD_INT 3
15587: PPUSH
15588: CALL 6048 0 3
// ExtSaveCharacter ( Petrosyan , Petrosyan , 3 ) ;
15592: LD_EXP 61
15596: PPUSH
15597: LD_STRING Petrosyan
15599: PPUSH
15600: LD_INT 3
15602: PPUSH
15603: CALL 6048 0 3
// ExtSaveCharacter ( Dolgov , Dolgov , 3 ) ;
15607: LD_EXP 63
15611: PPUSH
15612: LD_STRING Dolgov
15614: PPUSH
15615: LD_INT 3
15617: PPUSH
15618: CALL 6048 0 3
// ExtSaveCharacter ( Lipshchin , Lipshchin , 3 ) ;
15622: LD_EXP 64
15626: PPUSH
15627: LD_STRING Lipshchin
15629: PPUSH
15630: LD_INT 3
15632: PPUSH
15633: CALL 6048 0 3
// ExtSaveCharacter ( Titov , Titov , 3 ) ;
15637: LD_EXP 62
15641: PPUSH
15642: LD_STRING Titov
15644: PPUSH
15645: LD_INT 3
15647: PPUSH
15648: CALL 6048 0 3
// ExtSaveCharacter ( Kirilenkova , Kirilenkova , 3 ) ;
15652: LD_EXP 65
15656: PPUSH
15657: LD_STRING Kirilenkova
15659: PPUSH
15660: LD_INT 3
15662: PPUSH
15663: CALL 6048 0 3
// ExtSaveCharacter ( Belkov , Belkov , 3 ) ;
15667: LD_EXP 66
15671: PPUSH
15672: LD_STRING Belkov
15674: PPUSH
15675: LD_INT 3
15677: PPUSH
15678: CALL 6048 0 3
// ExtSaveCharacter ( Belkov2 , Belkov2 , 3 ) ;
15682: LD_EXP 67
15686: PPUSH
15687: LD_STRING Belkov2
15689: PPUSH
15690: LD_INT 3
15692: PPUSH
15693: CALL 6048 0 3
// ExtSaveCharacter ( Xavier , Xavier , 3 ) ;
15697: LD_EXP 68
15701: PPUSH
15702: LD_STRING Xavier
15704: PPUSH
15705: LD_INT 3
15707: PPUSH
15708: CALL 6048 0 3
// ExtSaveCharacter ( Kozlov , Kozlov , 3 ) ;
15712: LD_EXP 73
15716: PPUSH
15717: LD_STRING Kozlov
15719: PPUSH
15720: LD_INT 3
15722: PPUSH
15723: CALL 6048 0 3
// ExtSaveCharacter ( Oblukov , Oblukov , 3 ) ;
15727: LD_EXP 74
15731: PPUSH
15732: LD_STRING Oblukov
15734: PPUSH
15735: LD_INT 3
15737: PPUSH
15738: CALL 6048 0 3
// ExtSaveCharacter ( Kapitsova , Kapitsova , 3 ) ;
15742: LD_EXP 75
15746: PPUSH
15747: LD_STRING Kapitsova
15749: PPUSH
15750: LD_INT 3
15752: PPUSH
15753: CALL 6048 0 3
// ExtSaveCharacter ( Gnyevko , Gnyevko , 3 ) ;
15757: LD_EXP 69
15761: PPUSH
15762: LD_STRING Gnyevko
15764: PPUSH
15765: LD_INT 3
15767: PPUSH
15768: CALL 6048 0 3
// ExtSaveCharacter ( Kovalyuk , Kovalyuk , 3 ) ;
15772: LD_EXP 70
15776: PPUSH
15777: LD_STRING Kovalyuk
15779: PPUSH
15780: LD_INT 3
15782: PPUSH
15783: CALL 6048 0 3
// ExtSaveCharacter ( Scholtze , Scholtze , 3 ) ;
15787: LD_EXP 71
15791: PPUSH
15792: LD_STRING Scholtze
15794: PPUSH
15795: LD_INT 3
15797: PPUSH
15798: CALL 6048 0 3
// ExtSaveCharacter ( Kuzmov , Kuzmov , 3 ) ;
15802: LD_EXP 72
15806: PPUSH
15807: LD_STRING Kuzmov
15809: PPUSH
15810: LD_INT 3
15812: PPUSH
15813: CALL 6048 0 3
// ExtSaveCharacters ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_or , [ f_class , class_apeman ] , [ f_class , class_apeman_engineer ] , [ f_class , class_apeman_soldier ] ] ] ) , other_apemans , 3 ) ;
15817: LD_INT 22
15819: PUSH
15820: LD_INT 3
15822: PUSH
15823: EMPTY
15824: LIST
15825: LIST
15826: PUSH
15827: LD_INT 21
15829: PUSH
15830: LD_INT 1
15832: PUSH
15833: EMPTY
15834: LIST
15835: LIST
15836: PUSH
15837: LD_INT 2
15839: PUSH
15840: LD_INT 25
15842: PUSH
15843: LD_INT 12
15845: PUSH
15846: EMPTY
15847: LIST
15848: LIST
15849: PUSH
15850: LD_INT 25
15852: PUSH
15853: LD_INT 16
15855: PUSH
15856: EMPTY
15857: LIST
15858: LIST
15859: PUSH
15860: LD_INT 25
15862: PUSH
15863: LD_INT 15
15865: PUSH
15866: EMPTY
15867: LIST
15868: LIST
15869: PUSH
15870: EMPTY
15871: LIST
15872: LIST
15873: LIST
15874: LIST
15875: PUSH
15876: EMPTY
15877: LIST
15878: LIST
15879: LIST
15880: PPUSH
15881: CALL_OW 69
15885: PPUSH
15886: LD_STRING other_apemans
15888: PPUSH
15889: LD_INT 3
15891: PPUSH
15892: CALL 6105 0 3
// randomsToSave = FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_nation , nation_russian ] ] ) diff [ Burlak , Karamazov , Petrovova , Gleb , Petrosyan , Titov , Dolgov , Lipshchin , Kirilenkova , Belkov , Belkov2 , Xavier , Gnyevko , Kovalyuk , Scholtze , Kuzmov , Kozlov , Oblukov , Kapitsova ] ;
15896: LD_ADDR_VAR 0 2
15900: PUSH
15901: LD_INT 22
15903: PUSH
15904: LD_INT 3
15906: PUSH
15907: EMPTY
15908: LIST
15909: LIST
15910: PUSH
15911: LD_INT 21
15913: PUSH
15914: LD_INT 1
15916: PUSH
15917: EMPTY
15918: LIST
15919: LIST
15920: PUSH
15921: LD_INT 23
15923: PUSH
15924: LD_INT 3
15926: PUSH
15927: EMPTY
15928: LIST
15929: LIST
15930: PUSH
15931: EMPTY
15932: LIST
15933: LIST
15934: LIST
15935: PPUSH
15936: CALL_OW 69
15940: PUSH
15941: LD_EXP 57
15945: PUSH
15946: LD_EXP 58
15950: PUSH
15951: LD_EXP 59
15955: PUSH
15956: LD_EXP 60
15960: PUSH
15961: LD_EXP 61
15965: PUSH
15966: LD_EXP 62
15970: PUSH
15971: LD_EXP 63
15975: PUSH
15976: LD_EXP 64
15980: PUSH
15981: LD_EXP 65
15985: PUSH
15986: LD_EXP 66
15990: PUSH
15991: LD_EXP 67
15995: PUSH
15996: LD_EXP 68
16000: PUSH
16001: LD_EXP 69
16005: PUSH
16006: LD_EXP 70
16010: PUSH
16011: LD_EXP 71
16015: PUSH
16016: LD_EXP 72
16020: PUSH
16021: LD_EXP 73
16025: PUSH
16026: LD_EXP 74
16030: PUSH
16031: LD_EXP 75
16035: PUSH
16036: EMPTY
16037: LIST
16038: LIST
16039: LIST
16040: LIST
16041: LIST
16042: LIST
16043: LIST
16044: LIST
16045: LIST
16046: LIST
16047: LIST
16048: LIST
16049: LIST
16050: LIST
16051: LIST
16052: LIST
16053: LIST
16054: LIST
16055: LIST
16056: DIFF
16057: ST_TO_ADDR
// ExtSaveCharacters ( randomsToSave , other_survivors , 3 ) ;
16058: LD_VAR 0 2
16062: PPUSH
16063: LD_STRING other_survivors
16065: PPUSH
16066: LD_INT 3
16068: PPUSH
16069: CALL 6105 0 3
// end ;
16073: LD_VAR 0 1
16077: RET
// function SaveGlobalVariables ; begin
16078: LD_INT 0
16080: PPUSH
// SaveBase ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_building ] ] ) , 08_TrockyBase_1 ) ;
16081: LD_INT 22
16083: PUSH
16084: LD_INT 3
16086: PUSH
16087: EMPTY
16088: LIST
16089: LIST
16090: PUSH
16091: LD_INT 21
16093: PUSH
16094: LD_INT 3
16096: PUSH
16097: EMPTY
16098: LIST
16099: LIST
16100: PUSH
16101: EMPTY
16102: LIST
16103: LIST
16104: PPUSH
16105: CALL_OW 69
16109: PPUSH
16110: LD_STRING 08_TrockyBase_1
16112: PPUSH
16113: CALL 8484 0 2
// SaveVariable ( coopWithGensher , 08_CoopWithGensher_2 ) ;
16117: LD_EXP 2
16121: PPUSH
16122: LD_STRING 08_CoopWithGensher_2
16124: PPUSH
16125: CALL_OW 39
// SaveVariable ( HeikeStatus , 08_HeikeStatus_3 ) ;
16129: LD_EXP 3
16133: PPUSH
16134: LD_STRING 08_HeikeStatus_3
16136: PPUSH
16137: CALL_OW 39
// SaveVariable ( Masha , 08_Masha_4 ) ;
16141: LD_EXP 4
16145: PPUSH
16146: LD_STRING 08_Masha_4
16148: PPUSH
16149: CALL_OW 39
// end ; end_of_file
16153: LD_VAR 0 1
16157: RET
// export function CustomEvent ( event ) ; begin
16158: LD_INT 0
16160: PPUSH
// end ;
16161: LD_VAR 0 2
16165: RET
// on BuildingComplete ( building ) do begin if GetBType ( building ) in buildingsToBuild and GetNation ( building ) = nation_russian then
16166: LD_VAR 0 1
16170: PPUSH
16171: CALL_OW 266
16175: PUSH
16176: LD_EXP 8
16180: IN
16181: PUSH
16182: LD_VAR 0 1
16186: PPUSH
16187: CALL_OW 248
16191: PUSH
16192: LD_INT 3
16194: EQUAL
16195: AND
16196: IFFALSE 16219
// buildingsToBuild = buildingsToBuild diff GetBType ( building ) ;
16198: LD_ADDR_EXP 8
16202: PUSH
16203: LD_EXP 8
16207: PUSH
16208: LD_VAR 0 1
16212: PPUSH
16213: CALL_OW 266
16217: DIFF
16218: ST_TO_ADDR
// if GetBType ( building ) = b_depot then
16219: LD_VAR 0 1
16223: PPUSH
16224: CALL_OW 266
16228: PUSH
16229: LD_INT 0
16231: EQUAL
16232: IFFALSE 16283
// begin SetBName ( building , trockij ) ;
16234: LD_VAR 0 1
16238: PPUSH
16239: LD_STRING trockij
16241: PPUSH
16242: CALL_OW 500
// if not dial_BuildDepotBlocker and HeikeCaptured then
16246: LD_EXP 5
16250: NOT
16251: PUSH
16252: LD_EXP 1
16256: AND
16257: IFFALSE 16283
// Dial_EscortHeike ( GetX ( building ) , GetY ( building ) ) ;
16259: LD_VAR 0 1
16263: PPUSH
16264: CALL_OW 250
16268: PPUSH
16269: LD_VAR 0 1
16273: PPUSH
16274: CALL_OW 251
16278: PPUSH
16279: CALL 9149 0 2
// end ; end ;
16283: PPOPN 1
16285: END
// on UpgradeComplete ( building ) do begin if GetBType ( building ) in buildingsToBuild and GetNation ( building ) = nation_russian then
16286: LD_VAR 0 1
16290: PPUSH
16291: CALL_OW 266
16295: PUSH
16296: LD_EXP 8
16300: IN
16301: PUSH
16302: LD_VAR 0 1
16306: PPUSH
16307: CALL_OW 248
16311: PUSH
16312: LD_INT 3
16314: EQUAL
16315: AND
16316: IFFALSE 16339
// buildingsToBuild = buildingsToBuild diff GetBType ( building ) ;
16318: LD_ADDR_EXP 8
16322: PUSH
16323: LD_EXP 8
16327: PUSH
16328: LD_VAR 0 1
16332: PPUSH
16333: CALL_OW 266
16337: DIFF
16338: ST_TO_ADDR
// if GetBType ( building ) = b_barracks and GetNation ( building ) = 2 and not dial_BuildArBarrackBlocker then
16339: LD_VAR 0 1
16343: PPUSH
16344: CALL_OW 266
16348: PUSH
16349: LD_INT 5
16351: EQUAL
16352: PUSH
16353: LD_VAR 0 1
16357: PPUSH
16358: CALL_OW 248
16362: PUSH
16363: LD_INT 2
16365: EQUAL
16366: AND
16367: PUSH
16368: LD_EXP 6
16372: NOT
16373: AND
16374: IFFALSE 16380
// Dial_UpgradeArmoury ;
16376: CALL 9960 0 0
// end ;
16380: PPOPN 1
16382: END
// on ResearchComplete ( research , building ) do begin if research in techsToResearch then
16383: LD_VAR 0 1
16387: PUSH
16388: LD_EXP 9
16392: IN
16393: IFFALSE 16411
// techsToResearch = techsToResearch diff research ;
16395: LD_ADDR_EXP 9
16399: PUSH
16400: LD_EXP 9
16404: PUSH
16405: LD_VAR 0 1
16409: DIFF
16410: ST_TO_ADDR
// if research = tech_LimTeleport then
16411: LD_VAR 0 1
16415: PUSH
16416: LD_INT 37
16418: EQUAL
16419: IFFALSE 16425
// Dial_TeleportTechResearched ;
16421: CALL 13805 0 0
// if research = tech_AdvAI then
16425: LD_VAR 0 1
16429: PUSH
16430: LD_INT 27
16432: EQUAL
16433: IFFALSE 16439
// Dial_ComputerTechResearched ;
16435: CALL 13674 0 0
// end ;
16439: PPOPN 2
16441: END
// on EnterVehicle ( vehicle , human ) do begin if not canChooseMashaVehicle then
16442: LD_EXP 36
16446: NOT
16447: IFFALSE 16451
// exit ;
16449: GO 16618
// wait ( 0 0$1 ) ;
16451: LD_INT 35
16453: PPUSH
16454: CALL_OW 67
// if GetSide ( vehicle ) = 3 and human = Burlak and GetNation ( vehicle ) = nation_russian and GetWeapon ( vehicle ) in [ ru_heavy_machine_gun , ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher ] then
16458: LD_VAR 0 1
16462: PPUSH
16463: CALL_OW 255
16467: PUSH
16468: LD_INT 3
16470: EQUAL
16471: PUSH
16472: LD_VAR 0 2
16476: PUSH
16477: LD_EXP 57
16481: EQUAL
16482: AND
16483: PUSH
16484: LD_VAR 0 1
16488: PPUSH
16489: CALL_OW 248
16493: PUSH
16494: LD_INT 3
16496: EQUAL
16497: AND
16498: PUSH
16499: LD_VAR 0 1
16503: PPUSH
16504: CALL_OW 264
16508: PUSH
16509: LD_INT 42
16511: PUSH
16512: LD_INT 43
16514: PUSH
16515: LD_INT 44
16517: PUSH
16518: LD_INT 46
16520: PUSH
16521: LD_INT 45
16523: PUSH
16524: EMPTY
16525: LIST
16526: LIST
16527: LIST
16528: LIST
16529: LIST
16530: IN
16531: AND
16532: IFFALSE 16618
// begin if Masha then
16534: LD_EXP 4
16538: IFFALSE 16558
// if Masha [ 1 ] = vehicle then
16540: LD_EXP 4
16544: PUSH
16545: LD_INT 1
16547: ARRAY
16548: PUSH
16549: LD_VAR 0 1
16553: EQUAL
16554: IFFALSE 16558
// exit ;
16556: GO 16618
// if firstMashaQuery then
16558: LD_EXP 35
16562: IFFALSE 16596
// begin firstMashaQuery = false ;
16564: LD_ADDR_EXP 35
16568: PUSH
16569: LD_INT 0
16571: ST_TO_ADDR
// if Query ( QMashaQuery ) = 1 then
16572: LD_STRING QMashaQuery
16574: PPUSH
16575: CALL_OW 97
16579: PUSH
16580: LD_INT 1
16582: EQUAL
16583: IFFALSE 16594
// SetMashaData ( vehicle ) ;
16585: LD_VAR 0 1
16589: PPUSH
16590: CALL 8378 0 1
// end else
16594: GO 16618
// begin if Query ( QMashaQuery2 ) = 1 then
16596: LD_STRING QMashaQuery2
16598: PPUSH
16599: CALL_OW 97
16603: PUSH
16604: LD_INT 1
16606: EQUAL
16607: IFFALSE 16618
// SetMashaData ( vehicle ) ;
16609: LD_VAR 0 1
16613: PPUSH
16614: CALL 8378 0 1
// end ; end ; end ;
16618: PPOPN 2
16620: END
// on UnitDestroyed ( unit ) do begin if Masha then
16621: LD_EXP 4
16625: IFFALSE 16650
// if unit = Masha [ 1 ] then
16627: LD_VAR 0 1
16631: PUSH
16632: LD_EXP 4
16636: PUSH
16637: LD_INT 1
16639: ARRAY
16640: EQUAL
16641: IFFALSE 16650
// Masha = [ ] ;
16643: LD_ADDR_EXP 4
16647: PUSH
16648: EMPTY
16649: ST_TO_ADDR
// if unit = Burlak then
16650: LD_VAR 0 1
16654: PUSH
16655: LD_EXP 57
16659: EQUAL
16660: IFFALSE 16666
// Lose_Burlak ;
16662: CALL 15213 0 0
// if GetType ( unit ) = unit_human and GetNation ( unit ) = nation_russian then
16666: LD_VAR 0 1
16670: PPUSH
16671: CALL_OW 247
16675: PUSH
16676: LD_INT 1
16678: EQUAL
16679: PUSH
16680: LD_VAR 0 1
16684: PPUSH
16685: CALL_OW 248
16689: PUSH
16690: LD_INT 3
16692: EQUAL
16693: AND
16694: IFFALSE 16710
// lostUnits = lostUnits + 1 ;
16696: LD_ADDR_EXP 40
16700: PUSH
16701: LD_EXP 40
16705: PUSH
16706: LD_INT 1
16708: PLUS
16709: ST_TO_ADDR
// end ;
16710: PPOPN 1
16712: END
// on UnitGoesToRed ( unit ) do begin if GetType ( unit ) = unit_vehicle and GetNation ( unit ) = nation_russian and GetTech ( tech_LimTeleport , 3 ) = state_researched and not testedTeleport then
16713: LD_VAR 0 1
16717: PPUSH
16718: CALL_OW 247
16722: PUSH
16723: LD_INT 2
16725: EQUAL
16726: PUSH
16727: LD_VAR 0 1
16731: PPUSH
16732: CALL_OW 248
16736: PUSH
16737: LD_INT 3
16739: EQUAL
16740: AND
16741: PUSH
16742: LD_INT 37
16744: PPUSH
16745: LD_INT 3
16747: PPUSH
16748: CALL_OW 321
16752: PUSH
16753: LD_INT 2
16755: EQUAL
16756: AND
16757: PUSH
16758: LD_EXP 39
16762: NOT
16763: AND
16764: IFFALSE 16781
// begin testedTeleport = true ;
16766: LD_ADDR_EXP 39
16770: PUSH
16771: LD_INT 1
16773: ST_TO_ADDR
// ChangeMissionObjectives ( MTeleDone ) ;
16774: LD_STRING MTeleDone
16776: PPUSH
16777: CALL_OW 337
// end ; if unit = Heike then
16781: LD_VAR 0 1
16785: PUSH
16786: LD_EXP 79
16790: EQUAL
16791: IFFALSE 16834
// begin DialogueOn ;
16793: CALL_OW 6
// CenterNowOnUnits ( Heike ) ;
16797: LD_EXP 79
16801: PPUSH
16802: CALL_OW 87
// ForceSay ( Heike , DHeikeKilled-Hke-1 ) ;
16806: LD_EXP 79
16810: PPUSH
16811: LD_STRING DHeikeKilled-Hke-1
16813: PPUSH
16814: CALL_OW 91
// DialogueOff ;
16818: CALL_OW 7
// SetLives ( Heike , 0 ) ;
16822: LD_EXP 79
16826: PPUSH
16827: LD_INT 0
16829: PPUSH
16830: CALL_OW 234
// end ; end ;
16834: PPOPN 1
16836: END
// on Contact ( side1 , side2 ) do begin if side1 = 3 and side2 = 6 then
16837: LD_VAR 0 1
16841: PUSH
16842: LD_INT 3
16844: EQUAL
16845: PUSH
16846: LD_VAR 0 2
16850: PUSH
16851: LD_INT 6
16853: EQUAL
16854: AND
16855: IFFALSE 16861
// Lost_AttackAlly ;
16857: CALL 15228 0 0
// if side1 = 3 and side2 = 2 then
16861: LD_VAR 0 1
16865: PUSH
16866: LD_INT 3
16868: EQUAL
16869: PUSH
16870: LD_VAR 0 2
16874: PUSH
16875: LD_INT 2
16877: EQUAL
16878: AND
16879: IFFALSE 16885
// Dial_AttackGensher ;
16881: CALL 10916 0 0
// if side1 = 3 and side2 = 5 then
16885: LD_VAR 0 1
16889: PUSH
16890: LD_INT 3
16892: EQUAL
16893: PUSH
16894: LD_VAR 0 2
16898: PUSH
16899: LD_INT 5
16901: EQUAL
16902: AND
16903: IFFALSE 16947
// begin SetAttitude ( 3 , 5 , att_enemy , true ) ;
16905: LD_INT 3
16907: PPUSH
16908: LD_INT 5
16910: PPUSH
16911: LD_INT 2
16913: PPUSH
16914: LD_INT 1
16916: PPUSH
16917: CALL_OW 80
// if acceptKurtOffert and not GetSide ( Kurt ) = 2 then
16921: LD_EXP 19
16925: PUSH
16926: LD_EXP 80
16930: PPUSH
16931: CALL_OW 255
16935: PUSH
16936: LD_INT 2
16938: EQUAL
16939: NOT
16940: AND
16941: IFFALSE 16947
// Dial_BetrayedKurt1 ;
16943: CALL 11465 0 0
// end ; if side1 = 3 and side2 = 8 and GetAttitude ( 3 , 8 ) = att_neutral then
16947: LD_VAR 0 1
16951: PUSH
16952: LD_INT 3
16954: EQUAL
16955: PUSH
16956: LD_VAR 0 2
16960: PUSH
16961: LD_INT 8
16963: EQUAL
16964: AND
16965: PUSH
16966: LD_INT 3
16968: PPUSH
16969: LD_INT 8
16971: PPUSH
16972: CALL_OW 81
16976: PUSH
16977: LD_INT 0
16979: EQUAL
16980: AND
16981: IFFALSE 16993
// begin if acceptKurtOffert then
16983: LD_EXP 19
16987: IFFALSE 16993
// Dial_BetrayedKurt2 ;
16989: CALL 11551 0 0
// end ; end ;
16993: PPOPN 2
16995: END
// on VehicleConstructed ( vehicle , building ) do begin SetWeaponDataBuild ( GetWeapon ( vehicle ) , false ) ;
16996: LD_VAR 0 1
17000: PPUSH
17001: CALL_OW 264
17005: PPUSH
17006: LD_INT 0
17008: PPUSH
17009: CALL 6886 0 2
// if GetControl ( vehicle ) = control_computer and not buildCompVehicle then
17013: LD_VAR 0 1
17017: PPUSH
17018: CALL_OW 263
17022: PUSH
17023: LD_INT 3
17025: EQUAL
17026: PUSH
17027: LD_EXP 37
17031: NOT
17032: AND
17033: IFFALSE 17050
// begin buildCompVehicle = true ;
17035: LD_ADDR_EXP 37
17039: PUSH
17040: LD_INT 1
17042: ST_TO_ADDR
// ChangeMissionObjectives ( MAIDone ) ;
17043: LD_STRING MAIDone
17045: PPUSH
17046: CALL_OW 337
// end ; end ;
17050: PPOPN 2
17052: END
// on WeaponPlaced ( building , factory ) do begin SetWeaponDataBuild ( GetBWeapon ( building ) , true ) ;
17053: LD_VAR 0 1
17057: PPUSH
17058: CALL_OW 269
17062: PPUSH
17063: LD_INT 1
17065: PPUSH
17066: CALL 6886 0 2
// end ;
17070: PPOPN 2
17072: END
// on Command ( comandid ) do var i ;
17073: LD_INT 0
17075: PPUSH
// begin if IsOK ( KurtEng ) and GetSide ( KurtEng ) = 3 then
17076: LD_EXP 82
17080: PPUSH
17081: CALL_OW 302
17085: PUSH
17086: LD_EXP 82
17090: PPUSH
17091: CALL_OW 255
17095: PUSH
17096: LD_INT 3
17098: EQUAL
17099: AND
17100: IFFALSE 17309
// if GetTaskList ( KurtEng ) then
17102: LD_EXP 82
17106: PPUSH
17107: CALL_OW 437
17111: IFFALSE 17309
// begin for i := 1 to ( GetTaskList ( KurtEng ) ) do
17113: LD_ADDR_VAR 0 2
17117: PUSH
17118: DOUBLE
17119: LD_INT 1
17121: DEC
17122: ST_TO_ADDR
17123: LD_EXP 82
17127: PPUSH
17128: CALL_OW 437
17132: PUSH
17133: FOR_TO
17134: IFFALSE 17307
// begin if ( GetTaskList ( KurtEng ) [ i ] [ 1 ] in [ F , H , M , U , V , a , h , u , v , ~ , ^ , > , + , ; , 4 , { ] ) or ( GetTaskList ( KurtEng ) [ i ] [ 1 ] = B and GetTaskList ( KurtEng ) [ i ] [ 5 ] = 36 ) then
17136: LD_EXP 82
17140: PPUSH
17141: CALL_OW 437
17145: PUSH
17146: LD_VAR 0 2
17150: ARRAY
17151: PUSH
17152: LD_INT 1
17154: ARRAY
17155: PUSH
17156: LD_STRING F
17158: PUSH
17159: LD_STRING H
17161: PUSH
17162: LD_STRING M
17164: PUSH
17165: LD_STRING U
17167: PUSH
17168: LD_STRING V
17170: PUSH
17171: LD_STRING a
17173: PUSH
17174: LD_STRING h
17176: PUSH
17177: LD_STRING u
17179: PUSH
17180: LD_STRING v
17182: PUSH
17183: LD_STRING ~
17185: PUSH
17186: LD_STRING ^
17188: PUSH
17189: LD_STRING >
17191: PUSH
17192: LD_STRING +
17194: PUSH
17195: LD_STRING ;
17197: PUSH
17198: LD_STRING 4
17200: PUSH
17201: LD_STRING {
17203: PUSH
17204: EMPTY
17205: LIST
17206: LIST
17207: LIST
17208: LIST
17209: LIST
17210: LIST
17211: LIST
17212: LIST
17213: LIST
17214: LIST
17215: LIST
17216: LIST
17217: LIST
17218: LIST
17219: LIST
17220: LIST
17221: IN
17222: PUSH
17223: LD_EXP 82
17227: PPUSH
17228: CALL_OW 437
17232: PUSH
17233: LD_VAR 0 2
17237: ARRAY
17238: PUSH
17239: LD_INT 1
17241: ARRAY
17242: PUSH
17243: LD_STRING B
17245: EQUAL
17246: PUSH
17247: LD_EXP 82
17251: PPUSH
17252: CALL_OW 437
17256: PUSH
17257: LD_VAR 0 2
17261: ARRAY
17262: PUSH
17263: LD_INT 5
17265: ARRAY
17266: PUSH
17267: LD_INT 36
17269: EQUAL
17270: AND
17271: OR
17272: IFFALSE 17276
// else
17274: GO 17305
// begin RemoveTasks ( KurtEng ) ;
17276: LD_EXP 82
17280: PPUSH
17281: CALL_OW 493
// DialogueOn ;
17285: CALL_OW 6
// Say ( Kurt , DMercRefuseBuild-Kurt-1 ) ;
17289: LD_EXP 80
17293: PPUSH
17294: LD_STRING DMercRefuseBuild-Kurt-1
17296: PPUSH
17297: CALL_OW 88
// DialogueOff ;
17301: CALL_OW 7
// end ; end ;
17305: GO 17133
17307: POP
17308: POP
// end ; end ; end_of_file
17309: PPOPN 2
17311: END
// every 0 0$01 do var timer , cratesSpawned ;
17312: GO 17314
17314: DISABLE
17315: LD_INT 0
17317: PPUSH
17318: PPUSH
// begin timer := 1 1$30 ;
17319: LD_ADDR_VAR 0 1
17323: PUSH
17324: LD_INT 3150
17326: ST_TO_ADDR
// repeat wait ( timer ) ;
17327: LD_VAR 0 1
17331: PPUSH
17332: CALL_OW 67
// if cratesSpawned >= 6 and cratesSpawned < 18 then
17336: LD_VAR 0 2
17340: PUSH
17341: LD_INT 6
17343: GREATEREQUAL
17344: PUSH
17345: LD_VAR 0 2
17349: PUSH
17350: LD_INT 18
17352: LESS
17353: AND
17354: IFFALSE 17370
// timer := timer + 0 0$3 ;
17356: LD_ADDR_VAR 0 1
17360: PUSH
17361: LD_VAR 0 1
17365: PUSH
17366: LD_INT 105
17368: PLUS
17369: ST_TO_ADDR
// if cratesSpawned >= 18 then
17370: LD_VAR 0 2
17374: PUSH
17375: LD_INT 18
17377: GREATEREQUAL
17378: IFFALSE 17394
// timer := timer + 0 0$9 ;
17380: LD_ADDR_VAR 0 1
17384: PUSH
17385: LD_VAR 0 1
17389: PUSH
17390: LD_INT 315
17392: PLUS
17393: ST_TO_ADDR
// if timer > 3 3$00 then
17394: LD_VAR 0 1
17398: PUSH
17399: LD_INT 6300
17401: GREATER
17402: IFFALSE 17412
// timer := 0 0$50 ;
17404: LD_ADDR_VAR 0 1
17408: PUSH
17409: LD_INT 1750
17411: ST_TO_ADDR
// CreateCratesArea ( rand ( 3 , 5 ) , CratesSpawnArea , true ) ;
17412: LD_INT 3
17414: PPUSH
17415: LD_INT 5
17417: PPUSH
17418: CALL_OW 12
17422: PPUSH
17423: LD_INT 15
17425: PPUSH
17426: LD_INT 1
17428: PPUSH
17429: CALL_OW 55
// cratesSpawned = cratesSpawned + 1 ;
17433: LD_ADDR_VAR 0 2
17437: PUSH
17438: LD_VAR 0 2
17442: PUSH
17443: LD_INT 1
17445: PLUS
17446: ST_TO_ADDR
// until false ;
17447: LD_INT 0
17449: IFFALSE 17327
// end ; end_of_file
17451: PPOPN 2
17453: END
// every 0 0$1 do
17454: GO 17456
17456: DISABLE
// begin enable ;
17457: ENABLE
// end ;
17458: END
// every 0 0$1 do var building , playerBuildings , playerBuildingsBType ;
17459: GO 17461
17461: DISABLE
17462: LD_INT 0
17464: PPUSH
17465: PPUSH
17466: PPUSH
// begin playerBuildings = FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_building ] , [ f_nation , nation_russian ] ] ) ;
17467: LD_ADDR_VAR 0 2
17471: PUSH
17472: LD_INT 22
17474: PUSH
17475: LD_INT 3
17477: PUSH
17478: EMPTY
17479: LIST
17480: LIST
17481: PUSH
17482: LD_INT 21
17484: PUSH
17485: LD_INT 3
17487: PUSH
17488: EMPTY
17489: LIST
17490: LIST
17491: PUSH
17492: LD_INT 23
17494: PUSH
17495: LD_INT 3
17497: PUSH
17498: EMPTY
17499: LIST
17500: LIST
17501: PUSH
17502: EMPTY
17503: LIST
17504: LIST
17505: LIST
17506: PPUSH
17507: CALL_OW 69
17511: ST_TO_ADDR
// playerBuildingsBType = [ ] ;
17512: LD_ADDR_VAR 0 3
17516: PUSH
17517: EMPTY
17518: ST_TO_ADDR
// for building in playerBuildings do
17519: LD_ADDR_VAR 0 1
17523: PUSH
17524: LD_VAR 0 2
17528: PUSH
17529: FOR_IN
17530: IFFALSE 17555
// playerBuildingsBType = playerBuildingsBType ^ GetBType ( building ) ;
17532: LD_ADDR_VAR 0 3
17536: PUSH
17537: LD_VAR 0 3
17541: PUSH
17542: LD_VAR 0 1
17546: PPUSH
17547: CALL_OW 266
17551: ADD
17552: ST_TO_ADDR
17553: GO 17529
17555: POP
17556: POP
// for building in allBuildings do
17557: LD_ADDR_VAR 0 1
17561: PUSH
17562: LD_EXP 13
17566: PUSH
17567: FOR_IN
17568: IFFALSE 17614
// if not building in playerBuildingsBType and not building in buildingsToBuild then
17570: LD_VAR 0 1
17574: PUSH
17575: LD_VAR 0 3
17579: IN
17580: NOT
17581: PUSH
17582: LD_VAR 0 1
17586: PUSH
17587: LD_EXP 8
17591: IN
17592: NOT
17593: AND
17594: IFFALSE 17612
// buildingsToBuild = buildingsToBuild ^ building ;
17596: LD_ADDR_EXP 8
17600: PUSH
17601: LD_EXP 8
17605: PUSH
17606: LD_VAR 0 1
17610: ADD
17611: ST_TO_ADDR
17612: GO 17567
17614: POP
17615: POP
// enable ;
17616: ENABLE
// end ;
17617: PPOPN 3
17619: END
// every 0 0$1 trigger legionOffertCountdown do
17620: LD_EXP 33
17624: IFFALSE 17644
17626: GO 17628
17628: DISABLE
// begin legionOffertTime = legionOffertTime - 0 0$01 ;
17629: LD_ADDR_EXP 34
17633: PUSH
17634: LD_EXP 34
17638: PUSH
17639: LD_INT 35
17641: MINUS
17642: ST_TO_ADDR
// enable ;
17643: ENABLE
// end ;
17644: END
// every 0 0$1 trigger KurtWaitingForFreeHeike do
17645: LD_EXP 23
17649: IFFALSE 17683
17651: GO 17653
17653: DISABLE
// begin timeToFreeHeike = timeToFreeHeike - 0 0$01 ;
17654: LD_ADDR_EXP 54
17658: PUSH
17659: LD_EXP 54
17663: PUSH
17664: LD_INT 35
17666: MINUS
17667: ST_TO_ADDR
// if timeToFreeHeike <= 0 0$00 then
17668: LD_EXP 54
17672: PUSH
17673: LD_INT 0
17675: LESSEQUAL
17676: IFFALSE 17682
// Dial_PlayerDontSendHeike ;
17678: CALL 11413 0 0
// enable ;
17682: ENABLE
// end ;
17683: END
// every 0 0$1 trigger KurtWaitingForBuildBarrack and GetSide ( KurtEng ) = 3 do
17684: LD_EXP 24
17688: PUSH
17689: LD_EXP 82
17693: PPUSH
17694: CALL_OW 255
17698: PUSH
17699: LD_INT 3
17701: EQUAL
17702: AND
17703: IFFALSE 17776
17705: GO 17707
17707: DISABLE
// begin timeToBuildArBarrack = timeToBuildArBarrack - 0 0$01 ;
17708: LD_ADDR_EXP 55
17712: PUSH
17713: LD_EXP 55
17717: PUSH
17718: LD_INT 35
17720: MINUS
17721: ST_TO_ADDR
// if timeToBuildArBarrack <= 0 0$00 then
17722: LD_EXP 55
17726: PUSH
17727: LD_INT 0
17729: LESSEQUAL
17730: IFFALSE 17775
// begin Dial_BetrayedKurt1 ;
17732: CALL 11465 0 0
// wait ( 2 2$0 ) ;
17736: LD_INT 4200
17738: PPUSH
17739: CALL_OW 67
// SetAttitude ( 3 , 8 , att_enemy , true ) ;
17743: LD_INT 3
17745: PPUSH
17746: LD_INT 8
17748: PPUSH
17749: LD_INT 2
17751: PPUSH
17752: LD_INT 1
17754: PPUSH
17755: CALL_OW 80
// KurtAttack = true ;
17759: LD_ADDR_EXP 25
17763: PUSH
17764: LD_INT 1
17766: ST_TO_ADDR
// KurtWaitingForBuildBarrack = false ;
17767: LD_ADDR_EXP 24
17771: PUSH
17772: LD_INT 0
17774: ST_TO_ADDR
// end ; enable ;
17775: ENABLE
// end ; end_of_file
17776: END
// export currentAmWave , currentArWave ; every 0 0$1 trigger americansAttack do var i ;
17777: LD_EXP 26
17781: IFFALSE 17927
17783: GO 17785
17785: DISABLE
17786: LD_INT 0
17788: PPUSH
// begin currentAmWave = 0 ;
17789: LD_ADDR_EXP 85
17793: PUSH
17794: LD_INT 0
17796: ST_TO_ADDR
// wait ( firstAttackDelay ) ;
17797: LD_EXP 49
17801: PPUSH
17802: CALL_OW 67
// for i := 1 to americansAttackWaves do
17806: LD_ADDR_VAR 0 1
17810: PUSH
17811: DOUBLE
17812: LD_INT 1
17814: DEC
17815: ST_TO_ADDR
17816: LD_EXP 48
17820: PUSH
17821: FOR_TO
17822: IFFALSE 17925
// begin SpawnAmAttackTeam ;
17824: CALL 3214 0 0
// currentAmWave = currentAmWave + 1 ;
17828: LD_ADDR_EXP 85
17832: PUSH
17833: LD_EXP 85
17837: PUSH
17838: LD_INT 1
17840: PLUS
17841: ST_TO_ADDR
// if currentAmWave = 1 then
17842: LD_EXP 85
17846: PUSH
17847: LD_INT 1
17849: EQUAL
17850: IFFALSE 17914
// begin if paidLegionOffert then
17852: LD_EXP 32
17856: IFFALSE 17895
// begin Say ( Burlak , DAmAttackStart-Bur-1 ) ;
17858: LD_EXP 57
17862: PPUSH
17863: LD_STRING DAmAttackStart-Bur-1
17865: PPUSH
17866: CALL_OW 88
// if IsOK ( Gleb ) then
17870: LD_EXP 60
17874: PPUSH
17875: CALL_OW 302
17879: IFFALSE 17893
// Say ( Gleb , DAmAttackStart-Glb-1 ) ;
17881: LD_EXP 60
17885: PPUSH
17886: LD_STRING DAmAttackStart-Glb-1
17888: PPUSH
17889: CALL_OW 88
// end else
17893: GO 17907
// Say ( Burlak , DAmAttackStart-Bur-2 ) ;
17895: LD_EXP 57
17899: PPUSH
17900: LD_STRING DAmAttackStart-Bur-2
17902: PPUSH
17903: CALL_OW 88
// ChangeMissionObjectives ( MEnemy ) ;
17907: LD_STRING MEnemy
17909: PPUSH
17910: CALL_OW 337
// end ; wait ( waveCooldown ) ;
17914: LD_EXP 50
17918: PPUSH
17919: CALL_OW 67
// end ;
17923: GO 17821
17925: POP
17926: POP
// end ;
17927: PPOPN 1
17929: END
// every 0 0$1 trigger currentAmWave = 1 do
17930: LD_EXP 85
17934: PUSH
17935: LD_INT 1
17937: EQUAL
17938: IFFALSE 18027
17940: GO 17942
17942: DISABLE
// Attack ( [ 0 , amAttackTeam , [ [ 115 , 42 ] , [ 51 , 67 ] ] , [ 0 , 0 , 0 , 1 , 1 , 1 , 0 , 0 , 1 , 0 ] ] ) ;
17943: LD_INT 0
17945: PUSH
17946: LD_EXP 78
17950: PUSH
17951: LD_INT 115
17953: PUSH
17954: LD_INT 42
17956: PUSH
17957: EMPTY
17958: LIST
17959: LIST
17960: PUSH
17961: LD_INT 51
17963: PUSH
17964: LD_INT 67
17966: PUSH
17967: EMPTY
17968: LIST
17969: LIST
17970: PUSH
17971: EMPTY
17972: LIST
17973: LIST
17974: PUSH
17975: LD_INT 0
17977: PUSH
17978: LD_INT 0
17980: PUSH
17981: LD_INT 0
17983: PUSH
17984: LD_INT 1
17986: PUSH
17987: LD_INT 1
17989: PUSH
17990: LD_INT 1
17992: PUSH
17993: LD_INT 0
17995: PUSH
17996: LD_INT 0
17998: PUSH
17999: LD_INT 1
18001: PUSH
18002: LD_INT 0
18004: PUSH
18005: EMPTY
18006: LIST
18007: LIST
18008: LIST
18009: LIST
18010: LIST
18011: LIST
18012: LIST
18013: LIST
18014: LIST
18015: LIST
18016: PUSH
18017: EMPTY
18018: LIST
18019: LIST
18020: LIST
18021: LIST
18022: PPUSH
18023: CALL 76900 0 1
18027: END
// every 0 0$1 trigger currentAmWave = 2 do
18028: LD_EXP 85
18032: PUSH
18033: LD_INT 2
18035: EQUAL
18036: IFFALSE 18125
18038: GO 18040
18040: DISABLE
// Attack ( [ 0 , amAttackTeam , [ [ 115 , 42 ] , [ 51 , 67 ] ] , [ 0 , 0 , 0 , 1 , 1 , 1 , 0 , 0 , 1 , 0 ] ] ) ;
18041: LD_INT 0
18043: PUSH
18044: LD_EXP 78
18048: PUSH
18049: LD_INT 115
18051: PUSH
18052: LD_INT 42
18054: PUSH
18055: EMPTY
18056: LIST
18057: LIST
18058: PUSH
18059: LD_INT 51
18061: PUSH
18062: LD_INT 67
18064: PUSH
18065: EMPTY
18066: LIST
18067: LIST
18068: PUSH
18069: EMPTY
18070: LIST
18071: LIST
18072: PUSH
18073: LD_INT 0
18075: PUSH
18076: LD_INT 0
18078: PUSH
18079: LD_INT 0
18081: PUSH
18082: LD_INT 1
18084: PUSH
18085: LD_INT 1
18087: PUSH
18088: LD_INT 1
18090: PUSH
18091: LD_INT 0
18093: PUSH
18094: LD_INT 0
18096: PUSH
18097: LD_INT 1
18099: PUSH
18100: LD_INT 0
18102: PUSH
18103: EMPTY
18104: LIST
18105: LIST
18106: LIST
18107: LIST
18108: LIST
18109: LIST
18110: LIST
18111: LIST
18112: LIST
18113: LIST
18114: PUSH
18115: EMPTY
18116: LIST
18117: LIST
18118: LIST
18119: LIST
18120: PPUSH
18121: CALL 76900 0 1
18125: END
// every 0 0$1 trigger currentAmWave = 3 do
18126: LD_EXP 85
18130: PUSH
18131: LD_INT 3
18133: EQUAL
18134: IFFALSE 18223
18136: GO 18138
18138: DISABLE
// Attack ( [ 0 , amAttackTeam , [ [ 115 , 42 ] , [ 51 , 67 ] ] , [ 0 , 0 , 0 , 1 , 1 , 1 , 0 , 0 , 1 , 0 ] ] ) ;
18139: LD_INT 0
18141: PUSH
18142: LD_EXP 78
18146: PUSH
18147: LD_INT 115
18149: PUSH
18150: LD_INT 42
18152: PUSH
18153: EMPTY
18154: LIST
18155: LIST
18156: PUSH
18157: LD_INT 51
18159: PUSH
18160: LD_INT 67
18162: PUSH
18163: EMPTY
18164: LIST
18165: LIST
18166: PUSH
18167: EMPTY
18168: LIST
18169: LIST
18170: PUSH
18171: LD_INT 0
18173: PUSH
18174: LD_INT 0
18176: PUSH
18177: LD_INT 0
18179: PUSH
18180: LD_INT 1
18182: PUSH
18183: LD_INT 1
18185: PUSH
18186: LD_INT 1
18188: PUSH
18189: LD_INT 0
18191: PUSH
18192: LD_INT 0
18194: PUSH
18195: LD_INT 1
18197: PUSH
18198: LD_INT 0
18200: PUSH
18201: EMPTY
18202: LIST
18203: LIST
18204: LIST
18205: LIST
18206: LIST
18207: LIST
18208: LIST
18209: LIST
18210: LIST
18211: LIST
18212: PUSH
18213: EMPTY
18214: LIST
18215: LIST
18216: LIST
18217: LIST
18218: PPUSH
18219: CALL 76900 0 1
18223: END
// every 0 0$1 trigger KurtAttack do var i ;
18224: LD_EXP 25
18228: IFFALSE 18349
18230: GO 18232
18232: DISABLE
18233: LD_INT 0
18235: PPUSH
// begin currentArWave = 0 ;
18236: LD_ADDR_EXP 86
18240: PUSH
18241: LD_INT 0
18243: ST_TO_ADDR
// wait ( firstAttackDelay ) ;
18244: LD_EXP 49
18248: PPUSH
18249: CALL_OW 67
// for i := 1 to KurtAttackWaves do
18253: LD_ADDR_VAR 0 1
18257: PUSH
18258: DOUBLE
18259: LD_INT 1
18261: DEC
18262: ST_TO_ADDR
18263: LD_EXP 47
18267: PUSH
18268: FOR_TO
18269: IFFALSE 18347
// begin if KurtAttack and IsOK ( Heike ) then
18271: LD_EXP 25
18275: PUSH
18276: LD_EXP 79
18280: PPUSH
18281: CALL_OW 302
18285: AND
18286: IFFALSE 18345
// begin SpawnArAttackTeam ;
18288: CALL 4359 0 0
// currentArWave = currentArWave + 1 ;
18292: LD_ADDR_EXP 86
18296: PUSH
18297: LD_EXP 86
18301: PUSH
18302: LD_INT 1
18304: PLUS
18305: ST_TO_ADDR
// if currentArWave = 2 then
18306: LD_EXP 86
18310: PUSH
18311: LD_INT 2
18313: EQUAL
18314: IFFALSE 18336
// begin SayRadio ( Kurt , DMercAttack-Kurt-1 ) ;
18316: LD_EXP 80
18320: PPUSH
18321: LD_STRING DMercAttack-Kurt-1
18323: PPUSH
18324: CALL_OW 94
// canSendHeike = true ;
18328: LD_ADDR_EXP 28
18332: PUSH
18333: LD_INT 1
18335: ST_TO_ADDR
// end ; wait ( waveCooldown ) ;
18336: LD_EXP 50
18340: PPUSH
18341: CALL_OW 67
// end ; end ;
18345: GO 18268
18347: POP
18348: POP
// end ;
18349: PPOPN 1
18351: END
// every 0 0$1 trigger currentArWave = 1 do
18352: LD_EXP 86
18356: PUSH
18357: LD_INT 1
18359: EQUAL
18360: IFFALSE 18449
18362: GO 18364
18364: DISABLE
// Attack ( [ 0 , arAttackTeam , [ [ 115 , 42 ] , [ 51 , 67 ] ] , [ 0 , 0 , 0 , 1 , 1 , 1 , 0 , 0 , 1 , 0 ] ] ) ;
18365: LD_INT 0
18367: PUSH
18368: LD_EXP 84
18372: PUSH
18373: LD_INT 115
18375: PUSH
18376: LD_INT 42
18378: PUSH
18379: EMPTY
18380: LIST
18381: LIST
18382: PUSH
18383: LD_INT 51
18385: PUSH
18386: LD_INT 67
18388: PUSH
18389: EMPTY
18390: LIST
18391: LIST
18392: PUSH
18393: EMPTY
18394: LIST
18395: LIST
18396: PUSH
18397: LD_INT 0
18399: PUSH
18400: LD_INT 0
18402: PUSH
18403: LD_INT 0
18405: PUSH
18406: LD_INT 1
18408: PUSH
18409: LD_INT 1
18411: PUSH
18412: LD_INT 1
18414: PUSH
18415: LD_INT 0
18417: PUSH
18418: LD_INT 0
18420: PUSH
18421: LD_INT 1
18423: PUSH
18424: LD_INT 0
18426: PUSH
18427: EMPTY
18428: LIST
18429: LIST
18430: LIST
18431: LIST
18432: LIST
18433: LIST
18434: LIST
18435: LIST
18436: LIST
18437: LIST
18438: PUSH
18439: EMPTY
18440: LIST
18441: LIST
18442: LIST
18443: LIST
18444: PPUSH
18445: CALL 76900 0 1
18449: END
// every 0 0$1 trigger currentArWave = 2 do
18450: LD_EXP 86
18454: PUSH
18455: LD_INT 2
18457: EQUAL
18458: IFFALSE 18547
18460: GO 18462
18462: DISABLE
// Attack ( [ 0 , arAttackTeam , [ [ 115 , 42 ] , [ 51 , 67 ] ] , [ 0 , 0 , 0 , 1 , 1 , 1 , 0 , 0 , 1 , 0 ] ] ) ;
18463: LD_INT 0
18465: PUSH
18466: LD_EXP 84
18470: PUSH
18471: LD_INT 115
18473: PUSH
18474: LD_INT 42
18476: PUSH
18477: EMPTY
18478: LIST
18479: LIST
18480: PUSH
18481: LD_INT 51
18483: PUSH
18484: LD_INT 67
18486: PUSH
18487: EMPTY
18488: LIST
18489: LIST
18490: PUSH
18491: EMPTY
18492: LIST
18493: LIST
18494: PUSH
18495: LD_INT 0
18497: PUSH
18498: LD_INT 0
18500: PUSH
18501: LD_INT 0
18503: PUSH
18504: LD_INT 1
18506: PUSH
18507: LD_INT 1
18509: PUSH
18510: LD_INT 1
18512: PUSH
18513: LD_INT 0
18515: PUSH
18516: LD_INT 0
18518: PUSH
18519: LD_INT 1
18521: PUSH
18522: LD_INT 0
18524: PUSH
18525: EMPTY
18526: LIST
18527: LIST
18528: LIST
18529: LIST
18530: LIST
18531: LIST
18532: LIST
18533: LIST
18534: LIST
18535: LIST
18536: PUSH
18537: EMPTY
18538: LIST
18539: LIST
18540: LIST
18541: LIST
18542: PPUSH
18543: CALL 76900 0 1
18547: END
// every 0 0$1 trigger currentArWave = 3 do
18548: LD_EXP 86
18552: PUSH
18553: LD_INT 3
18555: EQUAL
18556: IFFALSE 18645
18558: GO 18560
18560: DISABLE
// Attack ( [ 0 , arAttackTeam , [ [ 115 , 42 ] , [ 51 , 67 ] ] , [ 0 , 0 , 0 , 1 , 1 , 1 , 0 , 0 , 1 , 0 ] ] ) ;
18561: LD_INT 0
18563: PUSH
18564: LD_EXP 84
18568: PUSH
18569: LD_INT 115
18571: PUSH
18572: LD_INT 42
18574: PUSH
18575: EMPTY
18576: LIST
18577: LIST
18578: PUSH
18579: LD_INT 51
18581: PUSH
18582: LD_INT 67
18584: PUSH
18585: EMPTY
18586: LIST
18587: LIST
18588: PUSH
18589: EMPTY
18590: LIST
18591: LIST
18592: PUSH
18593: LD_INT 0
18595: PUSH
18596: LD_INT 0
18598: PUSH
18599: LD_INT 0
18601: PUSH
18602: LD_INT 1
18604: PUSH
18605: LD_INT 1
18607: PUSH
18608: LD_INT 1
18610: PUSH
18611: LD_INT 0
18613: PUSH
18614: LD_INT 0
18616: PUSH
18617: LD_INT 1
18619: PUSH
18620: LD_INT 0
18622: PUSH
18623: EMPTY
18624: LIST
18625: LIST
18626: LIST
18627: LIST
18628: LIST
18629: LIST
18630: LIST
18631: LIST
18632: LIST
18633: LIST
18634: PUSH
18635: EMPTY
18636: LIST
18637: LIST
18638: LIST
18639: LIST
18640: PPUSH
18641: CALL 76900 0 1
18645: END
// every 0 0$1 trigger currentArWave = 4 do
18646: LD_EXP 86
18650: PUSH
18651: LD_INT 4
18653: EQUAL
18654: IFFALSE 18743
18656: GO 18658
18658: DISABLE
// Attack ( [ 0 , arAttackTeam , [ [ 115 , 42 ] , [ 51 , 67 ] ] , [ 0 , 0 , 0 , 1 , 1 , 1 , 0 , 0 , 1 , 0 ] ] ) ;
18659: LD_INT 0
18661: PUSH
18662: LD_EXP 84
18666: PUSH
18667: LD_INT 115
18669: PUSH
18670: LD_INT 42
18672: PUSH
18673: EMPTY
18674: LIST
18675: LIST
18676: PUSH
18677: LD_INT 51
18679: PUSH
18680: LD_INT 67
18682: PUSH
18683: EMPTY
18684: LIST
18685: LIST
18686: PUSH
18687: EMPTY
18688: LIST
18689: LIST
18690: PUSH
18691: LD_INT 0
18693: PUSH
18694: LD_INT 0
18696: PUSH
18697: LD_INT 0
18699: PUSH
18700: LD_INT 1
18702: PUSH
18703: LD_INT 1
18705: PUSH
18706: LD_INT 1
18708: PUSH
18709: LD_INT 0
18711: PUSH
18712: LD_INT 0
18714: PUSH
18715: LD_INT 1
18717: PUSH
18718: LD_INT 0
18720: PUSH
18721: EMPTY
18722: LIST
18723: LIST
18724: LIST
18725: LIST
18726: LIST
18727: LIST
18728: LIST
18729: LIST
18730: LIST
18731: LIST
18732: PUSH
18733: EMPTY
18734: LIST
18735: LIST
18736: LIST
18737: LIST
18738: PPUSH
18739: CALL 76900 0 1
18743: END
// every 0 0$1 trigger currentArWave = 5 do
18744: LD_EXP 86
18748: PUSH
18749: LD_INT 5
18751: EQUAL
18752: IFFALSE 18841
18754: GO 18756
18756: DISABLE
// Attack ( [ 0 , arAttackTeam , [ [ 115 , 42 ] , [ 51 , 67 ] ] , [ 0 , 0 , 0 , 1 , 1 , 1 , 0 , 0 , 1 , 0 ] ] ) ; end_of_file
18757: LD_INT 0
18759: PUSH
18760: LD_EXP 84
18764: PUSH
18765: LD_INT 115
18767: PUSH
18768: LD_INT 42
18770: PUSH
18771: EMPTY
18772: LIST
18773: LIST
18774: PUSH
18775: LD_INT 51
18777: PUSH
18778: LD_INT 67
18780: PUSH
18781: EMPTY
18782: LIST
18783: LIST
18784: PUSH
18785: EMPTY
18786: LIST
18787: LIST
18788: PUSH
18789: LD_INT 0
18791: PUSH
18792: LD_INT 0
18794: PUSH
18795: LD_INT 0
18797: PUSH
18798: LD_INT 1
18800: PUSH
18801: LD_INT 1
18803: PUSH
18804: LD_INT 1
18806: PUSH
18807: LD_INT 0
18809: PUSH
18810: LD_INT 0
18812: PUSH
18813: LD_INT 1
18815: PUSH
18816: LD_INT 0
18818: PUSH
18819: EMPTY
18820: LIST
18821: LIST
18822: LIST
18823: LIST
18824: LIST
18825: LIST
18826: LIST
18827: LIST
18828: LIST
18829: LIST
18830: PUSH
18831: EMPTY
18832: LIST
18833: LIST
18834: LIST
18835: LIST
18836: PPUSH
18837: CALL 76900 0 1
18841: END
// every 0 0$1 do var arVehs , arVeh , nearPlayerUnit ;
18842: GO 18844
18844: DISABLE
18845: LD_INT 0
18847: PPUSH
18848: PPUSH
18849: PPUSH
// begin enable ;
18850: ENABLE
// arVehs = FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_vehicle ] , [ f_empty ] ] ) ;
18851: LD_ADDR_VAR 0 1
18855: PUSH
18856: LD_INT 22
18858: PUSH
18859: LD_INT 8
18861: PUSH
18862: EMPTY
18863: LIST
18864: LIST
18865: PUSH
18866: LD_INT 21
18868: PUSH
18869: LD_INT 2
18871: PUSH
18872: EMPTY
18873: LIST
18874: LIST
18875: PUSH
18876: LD_INT 58
18878: PUSH
18879: EMPTY
18880: LIST
18881: PUSH
18882: EMPTY
18883: LIST
18884: LIST
18885: LIST
18886: PPUSH
18887: CALL_OW 69
18891: ST_TO_ADDR
// if not arVehs or not GetAttitude ( 3 , 8 ) = att_enemy then
18892: LD_VAR 0 1
18896: NOT
18897: PUSH
18898: LD_INT 3
18900: PPUSH
18901: LD_INT 8
18903: PPUSH
18904: CALL_OW 81
18908: PUSH
18909: LD_INT 2
18911: EQUAL
18912: NOT
18913: OR
18914: IFFALSE 18918
// exit ;
18916: GO 19008
// for arVeh in arVehs do
18918: LD_ADDR_VAR 0 2
18922: PUSH
18923: LD_VAR 0 1
18927: PUSH
18928: FOR_IN
18929: IFFALSE 19006
// begin nearPlayerUnit = NearestUnitToUnit ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) , arVeh ) ;
18931: LD_ADDR_VAR 0 3
18935: PUSH
18936: LD_INT 22
18938: PUSH
18939: LD_INT 3
18941: PUSH
18942: EMPTY
18943: LIST
18944: LIST
18945: PUSH
18946: LD_INT 21
18948: PUSH
18949: LD_INT 1
18951: PUSH
18952: EMPTY
18953: LIST
18954: LIST
18955: PUSH
18956: EMPTY
18957: LIST
18958: LIST
18959: PPUSH
18960: CALL_OW 69
18964: PPUSH
18965: LD_VAR 0 2
18969: PPUSH
18970: CALL_OW 74
18974: ST_TO_ADDR
// if GetDistUnits ( nearPlayerUnit , arVeh ) <= 2 then
18975: LD_VAR 0 3
18979: PPUSH
18980: LD_VAR 0 2
18984: PPUSH
18985: CALL_OW 296
18989: PUSH
18990: LD_INT 2
18992: LESSEQUAL
18993: IFFALSE 19004
// ComSelfDestruction ( arVeh ) ;
18995: LD_VAR 0 2
18999: PPUSH
19000: CALL_OW 577
// end ;
19004: GO 18928
19006: POP
19007: POP
// end ;
19008: PPOPN 3
19010: END
// every 0 0$1 trigger forceStopKurtAttack do
19011: LD_EXP 27
19015: IFFALSE 19081
19017: GO 19019
19019: DISABLE
// begin KurtAttack = false ;
19020: LD_ADDR_EXP 25
19024: PUSH
19025: LD_INT 0
19027: ST_TO_ADDR
// allowExitFromMap = 4 ;
19028: LD_ADDR_EXP 18
19032: PUSH
19033: LD_INT 4
19035: ST_TO_ADDR
// SetAttitude ( 3 , 8 , att_friend , true ) ;
19036: LD_INT 3
19038: PPUSH
19039: LD_INT 8
19041: PPUSH
19042: LD_INT 1
19044: PPUSH
19045: LD_INT 1
19047: PPUSH
19048: CALL_OW 80
// arAttackTeam = [ ] ;
19052: LD_ADDR_EXP 84
19056: PUSH
19057: EMPTY
19058: ST_TO_ADDR
// ComMoveToArea ( FilterAllUnits ( [ f_side , 8 ] ) , KurtExitMapArea ) ;
19059: LD_INT 22
19061: PUSH
19062: LD_INT 8
19064: PUSH
19065: EMPTY
19066: LIST
19067: LIST
19068: PPUSH
19069: CALL_OW 69
19073: PPUSH
19074: LD_INT 11
19076: PPUSH
19077: CALL_OW 113
// end ; end_of_file end_of_file
19081: END
// every 0 0$01 do var timer , cratesSpawned ;
19082: GO 19084
19084: DISABLE
19085: LD_INT 0
19087: PPUSH
19088: PPUSH
// begin timer := 1 1$30 ;
19089: LD_ADDR_VAR 0 1
19093: PUSH
19094: LD_INT 3150
19096: ST_TO_ADDR
// repeat wait ( timer ) ;
19097: LD_VAR 0 1
19101: PPUSH
19102: CALL_OW 67
// if cratesSpawned >= 6 and cratesSpawned < 18 then
19106: LD_VAR 0 2
19110: PUSH
19111: LD_INT 6
19113: GREATEREQUAL
19114: PUSH
19115: LD_VAR 0 2
19119: PUSH
19120: LD_INT 18
19122: LESS
19123: AND
19124: IFFALSE 19140
// timer := timer + 0 0$3 ;
19126: LD_ADDR_VAR 0 1
19130: PUSH
19131: LD_VAR 0 1
19135: PUSH
19136: LD_INT 105
19138: PLUS
19139: ST_TO_ADDR
// if cratesSpawned >= 18 then
19140: LD_VAR 0 2
19144: PUSH
19145: LD_INT 18
19147: GREATEREQUAL
19148: IFFALSE 19164
// timer := timer + 0 0$9 ;
19150: LD_ADDR_VAR 0 1
19154: PUSH
19155: LD_VAR 0 1
19159: PUSH
19160: LD_INT 315
19162: PLUS
19163: ST_TO_ADDR
// if timer > 3 3$00 then
19164: LD_VAR 0 1
19168: PUSH
19169: LD_INT 6300
19171: GREATER
19172: IFFALSE 19182
// timer := 0 0$50 ;
19174: LD_ADDR_VAR 0 1
19178: PUSH
19179: LD_INT 1750
19181: ST_TO_ADDR
// CreateCratesArea ( rand ( 3 , 5 ) , CratesSpawnArea , true ) ;
19182: LD_INT 3
19184: PPUSH
19185: LD_INT 5
19187: PPUSH
19188: CALL_OW 12
19192: PPUSH
19193: LD_INT 15
19195: PPUSH
19196: LD_INT 1
19198: PPUSH
19199: CALL_OW 55
// cratesSpawned = cratesSpawned + 1 ;
19203: LD_ADDR_VAR 0 2
19207: PUSH
19208: LD_VAR 0 2
19212: PUSH
19213: LD_INT 1
19215: PLUS
19216: ST_TO_ADDR
// until false ;
19217: LD_INT 0
19219: IFFALSE 19097
// end ; end_of_file
19221: PPOPN 2
19223: END
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
19224: LD_INT 0
19226: PPUSH
19227: PPUSH
// if exist_mode then
19228: LD_VAR 0 2
19232: IFFALSE 19257
// unit := CreateCharacter ( prefix & ident ) else
19234: LD_ADDR_VAR 0 5
19238: PUSH
19239: LD_VAR 0 3
19243: PUSH
19244: LD_VAR 0 1
19248: STR
19249: PPUSH
19250: CALL_OW 34
19254: ST_TO_ADDR
19255: GO 19272
// unit := NewCharacter ( ident ) ;
19257: LD_ADDR_VAR 0 5
19261: PUSH
19262: LD_VAR 0 1
19266: PPUSH
19267: CALL_OW 25
19271: ST_TO_ADDR
// result := unit ;
19272: LD_ADDR_VAR 0 4
19276: PUSH
19277: LD_VAR 0 5
19281: ST_TO_ADDR
// end ;
19282: LD_VAR 0 4
19286: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
19287: LD_INT 0
19289: PPUSH
19290: PPUSH
// if not side or not nation then
19291: LD_VAR 0 1
19295: NOT
19296: PUSH
19297: LD_VAR 0 2
19301: NOT
19302: OR
19303: IFFALSE 19307
// exit ;
19305: GO 20075
// case nation of nation_american :
19307: LD_VAR 0 2
19311: PUSH
19312: LD_INT 1
19314: DOUBLE
19315: EQUAL
19316: IFTRUE 19320
19318: GO 19534
19320: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 86 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 , 82 , 83 , 84 , 85 , 86 ] ; nation_arabian :
19321: LD_ADDR_VAR 0 4
19325: PUSH
19326: LD_INT 35
19328: PUSH
19329: LD_INT 45
19331: PUSH
19332: LD_INT 46
19334: PUSH
19335: LD_INT 47
19337: PUSH
19338: LD_INT 82
19340: PUSH
19341: LD_INT 83
19343: PUSH
19344: LD_INT 84
19346: PUSH
19347: LD_INT 85
19349: PUSH
19350: LD_INT 86
19352: PUSH
19353: LD_INT 1
19355: PUSH
19356: LD_INT 2
19358: PUSH
19359: LD_INT 6
19361: PUSH
19362: LD_INT 15
19364: PUSH
19365: LD_INT 16
19367: PUSH
19368: LD_INT 7
19370: PUSH
19371: LD_INT 12
19373: PUSH
19374: LD_INT 13
19376: PUSH
19377: LD_INT 10
19379: PUSH
19380: LD_INT 14
19382: PUSH
19383: LD_INT 20
19385: PUSH
19386: LD_INT 21
19388: PUSH
19389: LD_INT 22
19391: PUSH
19392: LD_INT 25
19394: PUSH
19395: LD_INT 32
19397: PUSH
19398: LD_INT 27
19400: PUSH
19401: LD_INT 36
19403: PUSH
19404: LD_INT 69
19406: PUSH
19407: LD_INT 39
19409: PUSH
19410: LD_INT 34
19412: PUSH
19413: LD_INT 40
19415: PUSH
19416: LD_INT 48
19418: PUSH
19419: LD_INT 49
19421: PUSH
19422: LD_INT 50
19424: PUSH
19425: LD_INT 51
19427: PUSH
19428: LD_INT 52
19430: PUSH
19431: LD_INT 53
19433: PUSH
19434: LD_INT 54
19436: PUSH
19437: LD_INT 55
19439: PUSH
19440: LD_INT 56
19442: PUSH
19443: LD_INT 57
19445: PUSH
19446: LD_INT 58
19448: PUSH
19449: LD_INT 59
19451: PUSH
19452: LD_INT 60
19454: PUSH
19455: LD_INT 61
19457: PUSH
19458: LD_INT 62
19460: PUSH
19461: LD_INT 80
19463: PUSH
19464: LD_INT 82
19466: PUSH
19467: LD_INT 83
19469: PUSH
19470: LD_INT 84
19472: PUSH
19473: LD_INT 85
19475: PUSH
19476: LD_INT 86
19478: PUSH
19479: EMPTY
19480: LIST
19481: LIST
19482: LIST
19483: LIST
19484: LIST
19485: LIST
19486: LIST
19487: LIST
19488: LIST
19489: LIST
19490: LIST
19491: LIST
19492: LIST
19493: LIST
19494: LIST
19495: LIST
19496: LIST
19497: LIST
19498: LIST
19499: LIST
19500: LIST
19501: LIST
19502: LIST
19503: LIST
19504: LIST
19505: LIST
19506: LIST
19507: LIST
19508: LIST
19509: LIST
19510: LIST
19511: LIST
19512: LIST
19513: LIST
19514: LIST
19515: LIST
19516: LIST
19517: LIST
19518: LIST
19519: LIST
19520: LIST
19521: LIST
19522: LIST
19523: LIST
19524: LIST
19525: LIST
19526: LIST
19527: LIST
19528: LIST
19529: LIST
19530: LIST
19531: ST_TO_ADDR
19532: GO 19999
19534: LD_INT 2
19536: DOUBLE
19537: EQUAL
19538: IFTRUE 19542
19540: GO 19768
19542: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 87 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 , 82 , 83 , 84 , 85 , 87 , 88 ] ; nation_russian :
19543: LD_ADDR_VAR 0 4
19547: PUSH
19548: LD_INT 35
19550: PUSH
19551: LD_INT 45
19553: PUSH
19554: LD_INT 46
19556: PUSH
19557: LD_INT 47
19559: PUSH
19560: LD_INT 82
19562: PUSH
19563: LD_INT 83
19565: PUSH
19566: LD_INT 84
19568: PUSH
19569: LD_INT 85
19571: PUSH
19572: LD_INT 87
19574: PUSH
19575: LD_INT 70
19577: PUSH
19578: LD_INT 1
19580: PUSH
19581: LD_INT 11
19583: PUSH
19584: LD_INT 3
19586: PUSH
19587: LD_INT 4
19589: PUSH
19590: LD_INT 5
19592: PUSH
19593: LD_INT 6
19595: PUSH
19596: LD_INT 15
19598: PUSH
19599: LD_INT 18
19601: PUSH
19602: LD_INT 7
19604: PUSH
19605: LD_INT 17
19607: PUSH
19608: LD_INT 8
19610: PUSH
19611: LD_INT 20
19613: PUSH
19614: LD_INT 21
19616: PUSH
19617: LD_INT 22
19619: PUSH
19620: LD_INT 72
19622: PUSH
19623: LD_INT 26
19625: PUSH
19626: LD_INT 69
19628: PUSH
19629: LD_INT 39
19631: PUSH
19632: LD_INT 40
19634: PUSH
19635: LD_INT 41
19637: PUSH
19638: LD_INT 42
19640: PUSH
19641: LD_INT 43
19643: PUSH
19644: LD_INT 48
19646: PUSH
19647: LD_INT 49
19649: PUSH
19650: LD_INT 50
19652: PUSH
19653: LD_INT 51
19655: PUSH
19656: LD_INT 52
19658: PUSH
19659: LD_INT 53
19661: PUSH
19662: LD_INT 54
19664: PUSH
19665: LD_INT 55
19667: PUSH
19668: LD_INT 56
19670: PUSH
19671: LD_INT 60
19673: PUSH
19674: LD_INT 61
19676: PUSH
19677: LD_INT 62
19679: PUSH
19680: LD_INT 66
19682: PUSH
19683: LD_INT 67
19685: PUSH
19686: LD_INT 68
19688: PUSH
19689: LD_INT 81
19691: PUSH
19692: LD_INT 82
19694: PUSH
19695: LD_INT 83
19697: PUSH
19698: LD_INT 84
19700: PUSH
19701: LD_INT 85
19703: PUSH
19704: LD_INT 87
19706: PUSH
19707: LD_INT 88
19709: PUSH
19710: EMPTY
19711: LIST
19712: LIST
19713: LIST
19714: LIST
19715: LIST
19716: LIST
19717: LIST
19718: LIST
19719: LIST
19720: LIST
19721: LIST
19722: LIST
19723: LIST
19724: LIST
19725: LIST
19726: LIST
19727: LIST
19728: LIST
19729: LIST
19730: LIST
19731: LIST
19732: LIST
19733: LIST
19734: LIST
19735: LIST
19736: LIST
19737: LIST
19738: LIST
19739: LIST
19740: LIST
19741: LIST
19742: LIST
19743: LIST
19744: LIST
19745: LIST
19746: LIST
19747: LIST
19748: LIST
19749: LIST
19750: LIST
19751: LIST
19752: LIST
19753: LIST
19754: LIST
19755: LIST
19756: LIST
19757: LIST
19758: LIST
19759: LIST
19760: LIST
19761: LIST
19762: LIST
19763: LIST
19764: LIST
19765: ST_TO_ADDR
19766: GO 19999
19768: LD_INT 3
19770: DOUBLE
19771: EQUAL
19772: IFTRUE 19776
19774: GO 19998
19776: POP
// result := [ 46 , 47 , 1 , 2 , 82 , 83 , 84 , 85 , 86 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 , 82 , 83 , 84 , 85 , 86 ] ; end ;
19777: LD_ADDR_VAR 0 4
19781: PUSH
19782: LD_INT 46
19784: PUSH
19785: LD_INT 47
19787: PUSH
19788: LD_INT 1
19790: PUSH
19791: LD_INT 2
19793: PUSH
19794: LD_INT 82
19796: PUSH
19797: LD_INT 83
19799: PUSH
19800: LD_INT 84
19802: PUSH
19803: LD_INT 85
19805: PUSH
19806: LD_INT 86
19808: PUSH
19809: LD_INT 11
19811: PUSH
19812: LD_INT 9
19814: PUSH
19815: LD_INT 20
19817: PUSH
19818: LD_INT 19
19820: PUSH
19821: LD_INT 21
19823: PUSH
19824: LD_INT 24
19826: PUSH
19827: LD_INT 22
19829: PUSH
19830: LD_INT 25
19832: PUSH
19833: LD_INT 28
19835: PUSH
19836: LD_INT 29
19838: PUSH
19839: LD_INT 30
19841: PUSH
19842: LD_INT 31
19844: PUSH
19845: LD_INT 37
19847: PUSH
19848: LD_INT 38
19850: PUSH
19851: LD_INT 32
19853: PUSH
19854: LD_INT 27
19856: PUSH
19857: LD_INT 33
19859: PUSH
19860: LD_INT 69
19862: PUSH
19863: LD_INT 39
19865: PUSH
19866: LD_INT 34
19868: PUSH
19869: LD_INT 40
19871: PUSH
19872: LD_INT 71
19874: PUSH
19875: LD_INT 23
19877: PUSH
19878: LD_INT 44
19880: PUSH
19881: LD_INT 48
19883: PUSH
19884: LD_INT 49
19886: PUSH
19887: LD_INT 50
19889: PUSH
19890: LD_INT 51
19892: PUSH
19893: LD_INT 52
19895: PUSH
19896: LD_INT 53
19898: PUSH
19899: LD_INT 54
19901: PUSH
19902: LD_INT 55
19904: PUSH
19905: LD_INT 56
19907: PUSH
19908: LD_INT 57
19910: PUSH
19911: LD_INT 58
19913: PUSH
19914: LD_INT 59
19916: PUSH
19917: LD_INT 63
19919: PUSH
19920: LD_INT 64
19922: PUSH
19923: LD_INT 65
19925: PUSH
19926: LD_INT 82
19928: PUSH
19929: LD_INT 83
19931: PUSH
19932: LD_INT 84
19934: PUSH
19935: LD_INT 85
19937: PUSH
19938: LD_INT 86
19940: PUSH
19941: EMPTY
19942: LIST
19943: LIST
19944: LIST
19945: LIST
19946: LIST
19947: LIST
19948: LIST
19949: LIST
19950: LIST
19951: LIST
19952: LIST
19953: LIST
19954: LIST
19955: LIST
19956: LIST
19957: LIST
19958: LIST
19959: LIST
19960: LIST
19961: LIST
19962: LIST
19963: LIST
19964: LIST
19965: LIST
19966: LIST
19967: LIST
19968: LIST
19969: LIST
19970: LIST
19971: LIST
19972: LIST
19973: LIST
19974: LIST
19975: LIST
19976: LIST
19977: LIST
19978: LIST
19979: LIST
19980: LIST
19981: LIST
19982: LIST
19983: LIST
19984: LIST
19985: LIST
19986: LIST
19987: LIST
19988: LIST
19989: LIST
19990: LIST
19991: LIST
19992: LIST
19993: LIST
19994: LIST
19995: ST_TO_ADDR
19996: GO 19999
19998: POP
// if state > - 1 and state < 3 then
19999: LD_VAR 0 3
20003: PUSH
20004: LD_INT 1
20006: NEG
20007: GREATER
20008: PUSH
20009: LD_VAR 0 3
20013: PUSH
20014: LD_INT 3
20016: LESS
20017: AND
20018: IFFALSE 20075
// for i in result do
20020: LD_ADDR_VAR 0 5
20024: PUSH
20025: LD_VAR 0 4
20029: PUSH
20030: FOR_IN
20031: IFFALSE 20073
// if GetTech ( i , side ) <> state then
20033: LD_VAR 0 5
20037: PPUSH
20038: LD_VAR 0 1
20042: PPUSH
20043: CALL_OW 321
20047: PUSH
20048: LD_VAR 0 3
20052: NONEQUAL
20053: IFFALSE 20071
// result := result diff i ;
20055: LD_ADDR_VAR 0 4
20059: PUSH
20060: LD_VAR 0 4
20064: PUSH
20065: LD_VAR 0 5
20069: DIFF
20070: ST_TO_ADDR
20071: GO 20030
20073: POP
20074: POP
// end ;
20075: LD_VAR 0 4
20079: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
20080: LD_INT 0
20082: PPUSH
20083: PPUSH
20084: PPUSH
// result := true ;
20085: LD_ADDR_VAR 0 3
20089: PUSH
20090: LD_INT 1
20092: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
20093: LD_ADDR_VAR 0 5
20097: PUSH
20098: LD_VAR 0 2
20102: PPUSH
20103: CALL_OW 480
20107: ST_TO_ADDR
// if not tmp then
20108: LD_VAR 0 5
20112: NOT
20113: IFFALSE 20117
// exit ;
20115: GO 20166
// for i in tmp do
20117: LD_ADDR_VAR 0 4
20121: PUSH
20122: LD_VAR 0 5
20126: PUSH
20127: FOR_IN
20128: IFFALSE 20164
// if GetTech ( i , side ) <> state_researched then
20130: LD_VAR 0 4
20134: PPUSH
20135: LD_VAR 0 1
20139: PPUSH
20140: CALL_OW 321
20144: PUSH
20145: LD_INT 2
20147: NONEQUAL
20148: IFFALSE 20162
// begin result := false ;
20150: LD_ADDR_VAR 0 3
20154: PUSH
20155: LD_INT 0
20157: ST_TO_ADDR
// exit ;
20158: POP
20159: POP
20160: GO 20166
// end ;
20162: GO 20127
20164: POP
20165: POP
// end ;
20166: LD_VAR 0 3
20170: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
20171: LD_INT 0
20173: PPUSH
20174: PPUSH
20175: PPUSH
20176: PPUSH
20177: PPUSH
20178: PPUSH
20179: PPUSH
20180: PPUSH
20181: PPUSH
20182: PPUSH
20183: PPUSH
20184: PPUSH
20185: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
20186: LD_VAR 0 1
20190: NOT
20191: PUSH
20192: LD_VAR 0 1
20196: PPUSH
20197: CALL_OW 257
20201: PUSH
20202: LD_INT 9
20204: NONEQUAL
20205: OR
20206: IFFALSE 20210
// exit ;
20208: GO 20783
// side := GetSide ( unit ) ;
20210: LD_ADDR_VAR 0 9
20214: PUSH
20215: LD_VAR 0 1
20219: PPUSH
20220: CALL_OW 255
20224: ST_TO_ADDR
// tech_space := tech_spacanom ;
20225: LD_ADDR_VAR 0 12
20229: PUSH
20230: LD_INT 29
20232: ST_TO_ADDR
// tech_time := tech_taurad ;
20233: LD_ADDR_VAR 0 13
20237: PUSH
20238: LD_INT 28
20240: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
20241: LD_ADDR_VAR 0 11
20245: PUSH
20246: LD_VAR 0 1
20250: PPUSH
20251: CALL_OW 310
20255: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
20256: LD_VAR 0 11
20260: PPUSH
20261: CALL_OW 247
20265: PUSH
20266: LD_INT 2
20268: EQUAL
20269: IFFALSE 20273
// exit ;
20271: GO 20783
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
20273: LD_ADDR_VAR 0 8
20277: PUSH
20278: LD_INT 81
20280: PUSH
20281: LD_VAR 0 9
20285: PUSH
20286: EMPTY
20287: LIST
20288: LIST
20289: PUSH
20290: LD_INT 3
20292: PUSH
20293: LD_INT 21
20295: PUSH
20296: LD_INT 3
20298: PUSH
20299: EMPTY
20300: LIST
20301: LIST
20302: PUSH
20303: EMPTY
20304: LIST
20305: LIST
20306: PUSH
20307: EMPTY
20308: LIST
20309: LIST
20310: PPUSH
20311: CALL_OW 69
20315: ST_TO_ADDR
// if not tmp then
20316: LD_VAR 0 8
20320: NOT
20321: IFFALSE 20325
// exit ;
20323: GO 20783
// if in_unit then
20325: LD_VAR 0 11
20329: IFFALSE 20353
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
20331: LD_ADDR_VAR 0 10
20335: PUSH
20336: LD_VAR 0 8
20340: PPUSH
20341: LD_VAR 0 11
20345: PPUSH
20346: CALL_OW 74
20350: ST_TO_ADDR
20351: GO 20373
// enemy := NearestUnitToUnit ( tmp , unit ) ;
20353: LD_ADDR_VAR 0 10
20357: PUSH
20358: LD_VAR 0 8
20362: PPUSH
20363: LD_VAR 0 1
20367: PPUSH
20368: CALL_OW 74
20372: ST_TO_ADDR
// if not enemy then
20373: LD_VAR 0 10
20377: NOT
20378: IFFALSE 20382
// exit ;
20380: GO 20783
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
20382: LD_VAR 0 11
20386: PUSH
20387: LD_VAR 0 11
20391: PPUSH
20392: LD_VAR 0 10
20396: PPUSH
20397: CALL_OW 296
20401: PUSH
20402: LD_INT 13
20404: GREATER
20405: AND
20406: PUSH
20407: LD_VAR 0 1
20411: PPUSH
20412: LD_VAR 0 10
20416: PPUSH
20417: CALL_OW 296
20421: PUSH
20422: LD_INT 12
20424: GREATER
20425: OR
20426: IFFALSE 20430
// exit ;
20428: GO 20783
// missile := [ 1 ] ;
20430: LD_ADDR_VAR 0 14
20434: PUSH
20435: LD_INT 1
20437: PUSH
20438: EMPTY
20439: LIST
20440: ST_TO_ADDR
// if Researched ( side , tech_space ) then
20441: LD_VAR 0 9
20445: PPUSH
20446: LD_VAR 0 12
20450: PPUSH
20451: CALL_OW 325
20455: IFFALSE 20484
// missile := Insert ( missile , missile + 1 , 2 ) ;
20457: LD_ADDR_VAR 0 14
20461: PUSH
20462: LD_VAR 0 14
20466: PPUSH
20467: LD_VAR 0 14
20471: PUSH
20472: LD_INT 1
20474: PLUS
20475: PPUSH
20476: LD_INT 2
20478: PPUSH
20479: CALL_OW 2
20483: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
20484: LD_VAR 0 9
20488: PPUSH
20489: LD_VAR 0 13
20493: PPUSH
20494: CALL_OW 325
20498: PUSH
20499: LD_VAR 0 10
20503: PPUSH
20504: CALL_OW 255
20508: PPUSH
20509: LD_VAR 0 13
20513: PPUSH
20514: CALL_OW 325
20518: NOT
20519: AND
20520: IFFALSE 20549
// missile := Insert ( missile , missile + 1 , 3 ) ;
20522: LD_ADDR_VAR 0 14
20526: PUSH
20527: LD_VAR 0 14
20531: PPUSH
20532: LD_VAR 0 14
20536: PUSH
20537: LD_INT 1
20539: PLUS
20540: PPUSH
20541: LD_INT 3
20543: PPUSH
20544: CALL_OW 2
20548: ST_TO_ADDR
// if missile < 2 then
20549: LD_VAR 0 14
20553: PUSH
20554: LD_INT 2
20556: LESS
20557: IFFALSE 20561
// exit ;
20559: GO 20783
// x := GetX ( enemy ) ;
20561: LD_ADDR_VAR 0 4
20565: PUSH
20566: LD_VAR 0 10
20570: PPUSH
20571: CALL_OW 250
20575: ST_TO_ADDR
// y := GetY ( enemy ) ;
20576: LD_ADDR_VAR 0 5
20580: PUSH
20581: LD_VAR 0 10
20585: PPUSH
20586: CALL_OW 251
20590: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
20591: LD_ADDR_VAR 0 6
20595: PUSH
20596: LD_VAR 0 4
20600: PUSH
20601: LD_INT 1
20603: NEG
20604: PPUSH
20605: LD_INT 1
20607: PPUSH
20608: CALL_OW 12
20612: PLUS
20613: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
20614: LD_ADDR_VAR 0 7
20618: PUSH
20619: LD_VAR 0 5
20623: PUSH
20624: LD_INT 1
20626: NEG
20627: PPUSH
20628: LD_INT 1
20630: PPUSH
20631: CALL_OW 12
20635: PLUS
20636: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
20637: LD_VAR 0 6
20641: PPUSH
20642: LD_VAR 0 7
20646: PPUSH
20647: CALL_OW 488
20651: NOT
20652: IFFALSE 20674
// begin _x := x ;
20654: LD_ADDR_VAR 0 6
20658: PUSH
20659: LD_VAR 0 4
20663: ST_TO_ADDR
// _y := y ;
20664: LD_ADDR_VAR 0 7
20668: PUSH
20669: LD_VAR 0 5
20673: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
20674: LD_ADDR_VAR 0 3
20678: PUSH
20679: LD_INT 1
20681: PPUSH
20682: LD_VAR 0 14
20686: PPUSH
20687: CALL_OW 12
20691: ST_TO_ADDR
// case i of 1 :
20692: LD_VAR 0 3
20696: PUSH
20697: LD_INT 1
20699: DOUBLE
20700: EQUAL
20701: IFTRUE 20705
20703: GO 20722
20705: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
20706: LD_VAR 0 1
20710: PPUSH
20711: LD_VAR 0 10
20715: PPUSH
20716: CALL_OW 115
20720: GO 20783
20722: LD_INT 2
20724: DOUBLE
20725: EQUAL
20726: IFTRUE 20730
20728: GO 20752
20730: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
20731: LD_VAR 0 1
20735: PPUSH
20736: LD_VAR 0 6
20740: PPUSH
20741: LD_VAR 0 7
20745: PPUSH
20746: CALL_OW 153
20750: GO 20783
20752: LD_INT 3
20754: DOUBLE
20755: EQUAL
20756: IFTRUE 20760
20758: GO 20782
20760: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
20761: LD_VAR 0 1
20765: PPUSH
20766: LD_VAR 0 6
20770: PPUSH
20771: LD_VAR 0 7
20775: PPUSH
20776: CALL_OW 154
20780: GO 20783
20782: POP
// end ;
20783: LD_VAR 0 2
20787: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
20788: LD_INT 0
20790: PPUSH
20791: PPUSH
20792: PPUSH
20793: PPUSH
20794: PPUSH
20795: PPUSH
// if not unit or not building then
20796: LD_VAR 0 1
20800: NOT
20801: PUSH
20802: LD_VAR 0 2
20806: NOT
20807: OR
20808: IFFALSE 20812
// exit ;
20810: GO 20970
// x := GetX ( building ) ;
20812: LD_ADDR_VAR 0 5
20816: PUSH
20817: LD_VAR 0 2
20821: PPUSH
20822: CALL_OW 250
20826: ST_TO_ADDR
// y := GetY ( building ) ;
20827: LD_ADDR_VAR 0 6
20831: PUSH
20832: LD_VAR 0 2
20836: PPUSH
20837: CALL_OW 251
20841: ST_TO_ADDR
// for i = 0 to 5 do
20842: LD_ADDR_VAR 0 4
20846: PUSH
20847: DOUBLE
20848: LD_INT 0
20850: DEC
20851: ST_TO_ADDR
20852: LD_INT 5
20854: PUSH
20855: FOR_TO
20856: IFFALSE 20968
// begin _x := ShiftX ( x , i , 3 ) ;
20858: LD_ADDR_VAR 0 7
20862: PUSH
20863: LD_VAR 0 5
20867: PPUSH
20868: LD_VAR 0 4
20872: PPUSH
20873: LD_INT 3
20875: PPUSH
20876: CALL_OW 272
20880: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
20881: LD_ADDR_VAR 0 8
20885: PUSH
20886: LD_VAR 0 6
20890: PPUSH
20891: LD_VAR 0 4
20895: PPUSH
20896: LD_INT 3
20898: PPUSH
20899: CALL_OW 273
20903: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
20904: LD_VAR 0 7
20908: PPUSH
20909: LD_VAR 0 8
20913: PPUSH
20914: CALL_OW 488
20918: NOT
20919: IFFALSE 20923
// continue ;
20921: GO 20855
// if HexInfo ( _x , _y ) = 0 then
20923: LD_VAR 0 7
20927: PPUSH
20928: LD_VAR 0 8
20932: PPUSH
20933: CALL_OW 428
20937: PUSH
20938: LD_INT 0
20940: EQUAL
20941: IFFALSE 20966
// begin ComMoveXY ( unit , _x , _y ) ;
20943: LD_VAR 0 1
20947: PPUSH
20948: LD_VAR 0 7
20952: PPUSH
20953: LD_VAR 0 8
20957: PPUSH
20958: CALL_OW 111
// exit ;
20962: POP
20963: POP
20964: GO 20970
// end ; end ;
20966: GO 20855
20968: POP
20969: POP
// end ;
20970: LD_VAR 0 3
20974: RET
// export function ScanBase ( side , base_area ) ; begin
20975: LD_INT 0
20977: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
20978: LD_ADDR_VAR 0 3
20982: PUSH
20983: LD_VAR 0 2
20987: PPUSH
20988: LD_INT 81
20990: PUSH
20991: LD_VAR 0 1
20995: PUSH
20996: EMPTY
20997: LIST
20998: LIST
20999: PPUSH
21000: CALL_OW 70
21004: ST_TO_ADDR
// end ;
21005: LD_VAR 0 3
21009: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
21010: LD_INT 0
21012: PPUSH
21013: PPUSH
21014: PPUSH
21015: PPUSH
// result := false ;
21016: LD_ADDR_VAR 0 2
21020: PUSH
21021: LD_INT 0
21023: ST_TO_ADDR
// side := GetSide ( unit ) ;
21024: LD_ADDR_VAR 0 3
21028: PUSH
21029: LD_VAR 0 1
21033: PPUSH
21034: CALL_OW 255
21038: ST_TO_ADDR
// nat := GetNation ( unit ) ;
21039: LD_ADDR_VAR 0 4
21043: PUSH
21044: LD_VAR 0 1
21048: PPUSH
21049: CALL_OW 248
21053: ST_TO_ADDR
// case nat of 1 :
21054: LD_VAR 0 4
21058: PUSH
21059: LD_INT 1
21061: DOUBLE
21062: EQUAL
21063: IFTRUE 21067
21065: GO 21078
21067: POP
// tech := tech_lassight ; 2 :
21068: LD_ADDR_VAR 0 5
21072: PUSH
21073: LD_INT 12
21075: ST_TO_ADDR
21076: GO 21117
21078: LD_INT 2
21080: DOUBLE
21081: EQUAL
21082: IFTRUE 21086
21084: GO 21097
21086: POP
// tech := tech_mortar ; 3 :
21087: LD_ADDR_VAR 0 5
21091: PUSH
21092: LD_INT 41
21094: ST_TO_ADDR
21095: GO 21117
21097: LD_INT 3
21099: DOUBLE
21100: EQUAL
21101: IFTRUE 21105
21103: GO 21116
21105: POP
// tech := tech_bazooka ; end ;
21106: LD_ADDR_VAR 0 5
21110: PUSH
21111: LD_INT 44
21113: ST_TO_ADDR
21114: GO 21117
21116: POP
// if Researched ( side , tech ) then
21117: LD_VAR 0 3
21121: PPUSH
21122: LD_VAR 0 5
21126: PPUSH
21127: CALL_OW 325
21131: IFFALSE 21158
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
21133: LD_ADDR_VAR 0 2
21137: PUSH
21138: LD_INT 5
21140: PUSH
21141: LD_INT 8
21143: PUSH
21144: LD_INT 9
21146: PUSH
21147: EMPTY
21148: LIST
21149: LIST
21150: LIST
21151: PUSH
21152: LD_VAR 0 4
21156: ARRAY
21157: ST_TO_ADDR
// end ;
21158: LD_VAR 0 2
21162: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
21163: LD_INT 0
21165: PPUSH
21166: PPUSH
21167: PPUSH
// if not mines then
21168: LD_VAR 0 2
21172: NOT
21173: IFFALSE 21177
// exit ;
21175: GO 21321
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
21177: LD_ADDR_VAR 0 5
21181: PUSH
21182: LD_INT 81
21184: PUSH
21185: LD_VAR 0 1
21189: PUSH
21190: EMPTY
21191: LIST
21192: LIST
21193: PUSH
21194: LD_INT 3
21196: PUSH
21197: LD_INT 21
21199: PUSH
21200: LD_INT 3
21202: PUSH
21203: EMPTY
21204: LIST
21205: LIST
21206: PUSH
21207: EMPTY
21208: LIST
21209: LIST
21210: PUSH
21211: EMPTY
21212: LIST
21213: LIST
21214: PPUSH
21215: CALL_OW 69
21219: ST_TO_ADDR
// for i in mines do
21220: LD_ADDR_VAR 0 4
21224: PUSH
21225: LD_VAR 0 2
21229: PUSH
21230: FOR_IN
21231: IFFALSE 21319
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
21233: LD_VAR 0 4
21237: PUSH
21238: LD_INT 1
21240: ARRAY
21241: PPUSH
21242: LD_VAR 0 4
21246: PUSH
21247: LD_INT 2
21249: ARRAY
21250: PPUSH
21251: CALL_OW 458
21255: NOT
21256: IFFALSE 21260
// continue ;
21258: GO 21230
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
21260: LD_VAR 0 4
21264: PUSH
21265: LD_INT 1
21267: ARRAY
21268: PPUSH
21269: LD_VAR 0 4
21273: PUSH
21274: LD_INT 2
21276: ARRAY
21277: PPUSH
21278: CALL_OW 428
21282: PUSH
21283: LD_VAR 0 5
21287: IN
21288: IFFALSE 21317
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
21290: LD_VAR 0 4
21294: PUSH
21295: LD_INT 1
21297: ARRAY
21298: PPUSH
21299: LD_VAR 0 4
21303: PUSH
21304: LD_INT 2
21306: ARRAY
21307: PPUSH
21308: LD_VAR 0 1
21312: PPUSH
21313: CALL_OW 456
// end ;
21317: GO 21230
21319: POP
21320: POP
// end ;
21321: LD_VAR 0 3
21325: RET
// export function Count ( array ) ; var i ; begin
21326: LD_INT 0
21328: PPUSH
21329: PPUSH
// result := 0 ;
21330: LD_ADDR_VAR 0 2
21334: PUSH
21335: LD_INT 0
21337: ST_TO_ADDR
// for i in array do
21338: LD_ADDR_VAR 0 3
21342: PUSH
21343: LD_VAR 0 1
21347: PUSH
21348: FOR_IN
21349: IFFALSE 21373
// if i then
21351: LD_VAR 0 3
21355: IFFALSE 21371
// result := result + 1 ;
21357: LD_ADDR_VAR 0 2
21361: PUSH
21362: LD_VAR 0 2
21366: PUSH
21367: LD_INT 1
21369: PLUS
21370: ST_TO_ADDR
21371: GO 21348
21373: POP
21374: POP
// end ;
21375: LD_VAR 0 2
21379: RET
// export function IsEmpty ( building ) ; begin
21380: LD_INT 0
21382: PPUSH
// if not building then
21383: LD_VAR 0 1
21387: NOT
21388: IFFALSE 21392
// exit ;
21390: GO 21435
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
21392: LD_ADDR_VAR 0 2
21396: PUSH
21397: LD_VAR 0 1
21401: PUSH
21402: LD_INT 22
21404: PUSH
21405: LD_VAR 0 1
21409: PPUSH
21410: CALL_OW 255
21414: PUSH
21415: EMPTY
21416: LIST
21417: LIST
21418: PUSH
21419: LD_INT 58
21421: PUSH
21422: EMPTY
21423: LIST
21424: PUSH
21425: EMPTY
21426: LIST
21427: LIST
21428: PPUSH
21429: CALL_OW 69
21433: IN
21434: ST_TO_ADDR
// end ;
21435: LD_VAR 0 2
21439: RET
// export function IsNotFull ( building ) ; begin
21440: LD_INT 0
21442: PPUSH
// if not building then
21443: LD_VAR 0 1
21447: NOT
21448: IFFALSE 21452
// exit ;
21450: GO 21471
// result := UnitsInside ( building ) < 6 ;
21452: LD_ADDR_VAR 0 2
21456: PUSH
21457: LD_VAR 0 1
21461: PPUSH
21462: CALL_OW 313
21466: PUSH
21467: LD_INT 6
21469: LESS
21470: ST_TO_ADDR
// end ;
21471: LD_VAR 0 2
21475: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
21476: LD_INT 0
21478: PPUSH
21479: PPUSH
21480: PPUSH
21481: PPUSH
// tmp := [ ] ;
21482: LD_ADDR_VAR 0 3
21486: PUSH
21487: EMPTY
21488: ST_TO_ADDR
// list := [ ] ;
21489: LD_ADDR_VAR 0 5
21493: PUSH
21494: EMPTY
21495: ST_TO_ADDR
// for i = 16 to 25 do
21496: LD_ADDR_VAR 0 4
21500: PUSH
21501: DOUBLE
21502: LD_INT 16
21504: DEC
21505: ST_TO_ADDR
21506: LD_INT 25
21508: PUSH
21509: FOR_TO
21510: IFFALSE 21583
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
21512: LD_ADDR_VAR 0 3
21516: PUSH
21517: LD_VAR 0 3
21521: PUSH
21522: LD_INT 22
21524: PUSH
21525: LD_VAR 0 1
21529: PPUSH
21530: CALL_OW 255
21534: PUSH
21535: EMPTY
21536: LIST
21537: LIST
21538: PUSH
21539: LD_INT 91
21541: PUSH
21542: LD_VAR 0 1
21546: PUSH
21547: LD_INT 6
21549: PUSH
21550: EMPTY
21551: LIST
21552: LIST
21553: LIST
21554: PUSH
21555: LD_INT 30
21557: PUSH
21558: LD_VAR 0 4
21562: PUSH
21563: EMPTY
21564: LIST
21565: LIST
21566: PUSH
21567: EMPTY
21568: LIST
21569: LIST
21570: LIST
21571: PUSH
21572: EMPTY
21573: LIST
21574: PPUSH
21575: CALL_OW 69
21579: ADD
21580: ST_TO_ADDR
21581: GO 21509
21583: POP
21584: POP
// for i = 1 to tmp do
21585: LD_ADDR_VAR 0 4
21589: PUSH
21590: DOUBLE
21591: LD_INT 1
21593: DEC
21594: ST_TO_ADDR
21595: LD_VAR 0 3
21599: PUSH
21600: FOR_TO
21601: IFFALSE 21689
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
21603: LD_ADDR_VAR 0 5
21607: PUSH
21608: LD_VAR 0 5
21612: PUSH
21613: LD_VAR 0 3
21617: PUSH
21618: LD_VAR 0 4
21622: ARRAY
21623: PPUSH
21624: CALL_OW 266
21628: PUSH
21629: LD_VAR 0 3
21633: PUSH
21634: LD_VAR 0 4
21638: ARRAY
21639: PPUSH
21640: CALL_OW 250
21644: PUSH
21645: LD_VAR 0 3
21649: PUSH
21650: LD_VAR 0 4
21654: ARRAY
21655: PPUSH
21656: CALL_OW 251
21660: PUSH
21661: LD_VAR 0 3
21665: PUSH
21666: LD_VAR 0 4
21670: ARRAY
21671: PPUSH
21672: CALL_OW 254
21676: PUSH
21677: EMPTY
21678: LIST
21679: LIST
21680: LIST
21681: LIST
21682: PUSH
21683: EMPTY
21684: LIST
21685: ADD
21686: ST_TO_ADDR
21687: GO 21600
21689: POP
21690: POP
// result := list ;
21691: LD_ADDR_VAR 0 2
21695: PUSH
21696: LD_VAR 0 5
21700: ST_TO_ADDR
// end ;
21701: LD_VAR 0 2
21705: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
21706: LD_INT 0
21708: PPUSH
21709: PPUSH
21710: PPUSH
21711: PPUSH
21712: PPUSH
21713: PPUSH
21714: PPUSH
// if not factory then
21715: LD_VAR 0 1
21719: NOT
21720: IFFALSE 21724
// exit ;
21722: GO 22317
// if control = control_apeman then
21724: LD_VAR 0 4
21728: PUSH
21729: LD_INT 5
21731: EQUAL
21732: IFFALSE 21841
// begin tmp := UnitsInside ( factory ) ;
21734: LD_ADDR_VAR 0 8
21738: PUSH
21739: LD_VAR 0 1
21743: PPUSH
21744: CALL_OW 313
21748: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
21749: LD_VAR 0 8
21753: PPUSH
21754: LD_INT 25
21756: PUSH
21757: LD_INT 12
21759: PUSH
21760: EMPTY
21761: LIST
21762: LIST
21763: PPUSH
21764: CALL_OW 72
21768: NOT
21769: IFFALSE 21779
// control := control_manual ;
21771: LD_ADDR_VAR 0 4
21775: PUSH
21776: LD_INT 1
21778: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
21779: LD_ADDR_VAR 0 8
21783: PUSH
21784: LD_VAR 0 1
21788: PPUSH
21789: CALL 21476 0 1
21793: ST_TO_ADDR
// if tmp then
21794: LD_VAR 0 8
21798: IFFALSE 21841
// begin for i in tmp do
21800: LD_ADDR_VAR 0 7
21804: PUSH
21805: LD_VAR 0 8
21809: PUSH
21810: FOR_IN
21811: IFFALSE 21839
// if i [ 1 ] = b_ext_radio then
21813: LD_VAR 0 7
21817: PUSH
21818: LD_INT 1
21820: ARRAY
21821: PUSH
21822: LD_INT 22
21824: EQUAL
21825: IFFALSE 21837
// begin control := control_remote ;
21827: LD_ADDR_VAR 0 4
21831: PUSH
21832: LD_INT 2
21834: ST_TO_ADDR
// break ;
21835: GO 21839
// end ;
21837: GO 21810
21839: POP
21840: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
21841: LD_VAR 0 1
21845: PPUSH
21846: LD_VAR 0 2
21850: PPUSH
21851: LD_VAR 0 3
21855: PPUSH
21856: LD_VAR 0 4
21860: PPUSH
21861: LD_VAR 0 5
21865: PPUSH
21866: CALL_OW 448
21870: IFFALSE 21905
// begin result := [ chassis , engine , control , weapon ] ;
21872: LD_ADDR_VAR 0 6
21876: PUSH
21877: LD_VAR 0 2
21881: PUSH
21882: LD_VAR 0 3
21886: PUSH
21887: LD_VAR 0 4
21891: PUSH
21892: LD_VAR 0 5
21896: PUSH
21897: EMPTY
21898: LIST
21899: LIST
21900: LIST
21901: LIST
21902: ST_TO_ADDR
// exit ;
21903: GO 22317
// end ; _chassis := AvailableChassisList ( factory ) ;
21905: LD_ADDR_VAR 0 9
21909: PUSH
21910: LD_VAR 0 1
21914: PPUSH
21915: CALL_OW 475
21919: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
21920: LD_ADDR_VAR 0 11
21924: PUSH
21925: LD_VAR 0 1
21929: PPUSH
21930: CALL_OW 476
21934: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
21935: LD_ADDR_VAR 0 12
21939: PUSH
21940: LD_VAR 0 1
21944: PPUSH
21945: CALL_OW 477
21949: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
21950: LD_ADDR_VAR 0 10
21954: PUSH
21955: LD_VAR 0 1
21959: PPUSH
21960: CALL_OW 478
21964: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
21965: LD_VAR 0 9
21969: NOT
21970: PUSH
21971: LD_VAR 0 11
21975: NOT
21976: OR
21977: PUSH
21978: LD_VAR 0 12
21982: NOT
21983: OR
21984: PUSH
21985: LD_VAR 0 10
21989: NOT
21990: OR
21991: IFFALSE 22026
// begin result := [ chassis , engine , control , weapon ] ;
21993: LD_ADDR_VAR 0 6
21997: PUSH
21998: LD_VAR 0 2
22002: PUSH
22003: LD_VAR 0 3
22007: PUSH
22008: LD_VAR 0 4
22012: PUSH
22013: LD_VAR 0 5
22017: PUSH
22018: EMPTY
22019: LIST
22020: LIST
22021: LIST
22022: LIST
22023: ST_TO_ADDR
// exit ;
22024: GO 22317
// end ; if not chassis in _chassis then
22026: LD_VAR 0 2
22030: PUSH
22031: LD_VAR 0 9
22035: IN
22036: NOT
22037: IFFALSE 22063
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
22039: LD_ADDR_VAR 0 2
22043: PUSH
22044: LD_VAR 0 9
22048: PUSH
22049: LD_INT 1
22051: PPUSH
22052: LD_VAR 0 9
22056: PPUSH
22057: CALL_OW 12
22061: ARRAY
22062: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
22063: LD_VAR 0 2
22067: PPUSH
22068: LD_VAR 0 3
22072: PPUSH
22073: CALL 22322 0 2
22077: NOT
22078: IFFALSE 22137
// repeat engine := _engine [ 1 ] ;
22080: LD_ADDR_VAR 0 3
22084: PUSH
22085: LD_VAR 0 11
22089: PUSH
22090: LD_INT 1
22092: ARRAY
22093: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
22094: LD_ADDR_VAR 0 11
22098: PUSH
22099: LD_VAR 0 11
22103: PPUSH
22104: LD_INT 1
22106: PPUSH
22107: CALL_OW 3
22111: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
22112: LD_VAR 0 2
22116: PPUSH
22117: LD_VAR 0 3
22121: PPUSH
22122: CALL 22322 0 2
22126: PUSH
22127: LD_VAR 0 11
22131: PUSH
22132: EMPTY
22133: EQUAL
22134: OR
22135: IFFALSE 22080
// if not control in _control then
22137: LD_VAR 0 4
22141: PUSH
22142: LD_VAR 0 12
22146: IN
22147: NOT
22148: IFFALSE 22174
// control := _control [ rand ( 1 , _control ) ] ;
22150: LD_ADDR_VAR 0 4
22154: PUSH
22155: LD_VAR 0 12
22159: PUSH
22160: LD_INT 1
22162: PPUSH
22163: LD_VAR 0 12
22167: PPUSH
22168: CALL_OW 12
22172: ARRAY
22173: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
22174: LD_VAR 0 2
22178: PPUSH
22179: LD_VAR 0 5
22183: PPUSH
22184: CALL 22542 0 2
22188: NOT
22189: IFFALSE 22248
// repeat weapon := _weapon [ 1 ] ;
22191: LD_ADDR_VAR 0 5
22195: PUSH
22196: LD_VAR 0 10
22200: PUSH
22201: LD_INT 1
22203: ARRAY
22204: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
22205: LD_ADDR_VAR 0 10
22209: PUSH
22210: LD_VAR 0 10
22214: PPUSH
22215: LD_INT 1
22217: PPUSH
22218: CALL_OW 3
22222: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
22223: LD_VAR 0 2
22227: PPUSH
22228: LD_VAR 0 5
22232: PPUSH
22233: CALL 22542 0 2
22237: PUSH
22238: LD_VAR 0 10
22242: PUSH
22243: EMPTY
22244: EQUAL
22245: OR
22246: IFFALSE 22191
// result := [ ] ;
22248: LD_ADDR_VAR 0 6
22252: PUSH
22253: EMPTY
22254: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
22255: LD_VAR 0 1
22259: PPUSH
22260: LD_VAR 0 2
22264: PPUSH
22265: LD_VAR 0 3
22269: PPUSH
22270: LD_VAR 0 4
22274: PPUSH
22275: LD_VAR 0 5
22279: PPUSH
22280: CALL_OW 448
22284: IFFALSE 22317
// result := [ chassis , engine , control , weapon ] ;
22286: LD_ADDR_VAR 0 6
22290: PUSH
22291: LD_VAR 0 2
22295: PUSH
22296: LD_VAR 0 3
22300: PUSH
22301: LD_VAR 0 4
22305: PUSH
22306: LD_VAR 0 5
22310: PUSH
22311: EMPTY
22312: LIST
22313: LIST
22314: LIST
22315: LIST
22316: ST_TO_ADDR
// end ;
22317: LD_VAR 0 6
22321: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
22322: LD_INT 0
22324: PPUSH
// if not chassis or not engine then
22325: LD_VAR 0 1
22329: NOT
22330: PUSH
22331: LD_VAR 0 2
22335: NOT
22336: OR
22337: IFFALSE 22341
// exit ;
22339: GO 22537
// case engine of engine_solar :
22341: LD_VAR 0 2
22345: PUSH
22346: LD_INT 2
22348: DOUBLE
22349: EQUAL
22350: IFTRUE 22354
22352: GO 22392
22354: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
22355: LD_ADDR_VAR 0 3
22359: PUSH
22360: LD_INT 11
22362: PUSH
22363: LD_INT 12
22365: PUSH
22366: LD_INT 13
22368: PUSH
22369: LD_INT 14
22371: PUSH
22372: LD_INT 1
22374: PUSH
22375: LD_INT 2
22377: PUSH
22378: LD_INT 3
22380: PUSH
22381: EMPTY
22382: LIST
22383: LIST
22384: LIST
22385: LIST
22386: LIST
22387: LIST
22388: LIST
22389: ST_TO_ADDR
22390: GO 22521
22392: LD_INT 1
22394: DOUBLE
22395: EQUAL
22396: IFTRUE 22400
22398: GO 22462
22400: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
22401: LD_ADDR_VAR 0 3
22405: PUSH
22406: LD_INT 11
22408: PUSH
22409: LD_INT 12
22411: PUSH
22412: LD_INT 13
22414: PUSH
22415: LD_INT 14
22417: PUSH
22418: LD_INT 1
22420: PUSH
22421: LD_INT 2
22423: PUSH
22424: LD_INT 3
22426: PUSH
22427: LD_INT 4
22429: PUSH
22430: LD_INT 5
22432: PUSH
22433: LD_INT 21
22435: PUSH
22436: LD_INT 23
22438: PUSH
22439: LD_INT 22
22441: PUSH
22442: LD_INT 24
22444: PUSH
22445: EMPTY
22446: LIST
22447: LIST
22448: LIST
22449: LIST
22450: LIST
22451: LIST
22452: LIST
22453: LIST
22454: LIST
22455: LIST
22456: LIST
22457: LIST
22458: LIST
22459: ST_TO_ADDR
22460: GO 22521
22462: LD_INT 3
22464: DOUBLE
22465: EQUAL
22466: IFTRUE 22470
22468: GO 22520
22470: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
22471: LD_ADDR_VAR 0 3
22475: PUSH
22476: LD_INT 13
22478: PUSH
22479: LD_INT 14
22481: PUSH
22482: LD_INT 2
22484: PUSH
22485: LD_INT 3
22487: PUSH
22488: LD_INT 4
22490: PUSH
22491: LD_INT 5
22493: PUSH
22494: LD_INT 21
22496: PUSH
22497: LD_INT 22
22499: PUSH
22500: LD_INT 23
22502: PUSH
22503: LD_INT 24
22505: PUSH
22506: EMPTY
22507: LIST
22508: LIST
22509: LIST
22510: LIST
22511: LIST
22512: LIST
22513: LIST
22514: LIST
22515: LIST
22516: LIST
22517: ST_TO_ADDR
22518: GO 22521
22520: POP
// result := ( chassis in result ) ;
22521: LD_ADDR_VAR 0 3
22525: PUSH
22526: LD_VAR 0 1
22530: PUSH
22531: LD_VAR 0 3
22535: IN
22536: ST_TO_ADDR
// end ;
22537: LD_VAR 0 3
22541: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
22542: LD_INT 0
22544: PPUSH
// if not chassis or not weapon then
22545: LD_VAR 0 1
22549: NOT
22550: PUSH
22551: LD_VAR 0 2
22555: NOT
22556: OR
22557: IFFALSE 22561
// exit ;
22559: GO 23623
// case weapon of us_machine_gun :
22561: LD_VAR 0 2
22565: PUSH
22566: LD_INT 2
22568: DOUBLE
22569: EQUAL
22570: IFTRUE 22574
22572: GO 22604
22574: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
22575: LD_ADDR_VAR 0 3
22579: PUSH
22580: LD_INT 1
22582: PUSH
22583: LD_INT 2
22585: PUSH
22586: LD_INT 3
22588: PUSH
22589: LD_INT 4
22591: PUSH
22592: LD_INT 5
22594: PUSH
22595: EMPTY
22596: LIST
22597: LIST
22598: LIST
22599: LIST
22600: LIST
22601: ST_TO_ADDR
22602: GO 23607
22604: LD_INT 3
22606: DOUBLE
22607: EQUAL
22608: IFTRUE 22612
22610: GO 22642
22612: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
22613: LD_ADDR_VAR 0 3
22617: PUSH
22618: LD_INT 1
22620: PUSH
22621: LD_INT 2
22623: PUSH
22624: LD_INT 3
22626: PUSH
22627: LD_INT 4
22629: PUSH
22630: LD_INT 5
22632: PUSH
22633: EMPTY
22634: LIST
22635: LIST
22636: LIST
22637: LIST
22638: LIST
22639: ST_TO_ADDR
22640: GO 23607
22642: LD_INT 11
22644: DOUBLE
22645: EQUAL
22646: IFTRUE 22650
22648: GO 22680
22650: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
22651: LD_ADDR_VAR 0 3
22655: PUSH
22656: LD_INT 1
22658: PUSH
22659: LD_INT 2
22661: PUSH
22662: LD_INT 3
22664: PUSH
22665: LD_INT 4
22667: PUSH
22668: LD_INT 5
22670: PUSH
22671: EMPTY
22672: LIST
22673: LIST
22674: LIST
22675: LIST
22676: LIST
22677: ST_TO_ADDR
22678: GO 23607
22680: LD_INT 4
22682: DOUBLE
22683: EQUAL
22684: IFTRUE 22688
22686: GO 22714
22688: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
22689: LD_ADDR_VAR 0 3
22693: PUSH
22694: LD_INT 2
22696: PUSH
22697: LD_INT 3
22699: PUSH
22700: LD_INT 4
22702: PUSH
22703: LD_INT 5
22705: PUSH
22706: EMPTY
22707: LIST
22708: LIST
22709: LIST
22710: LIST
22711: ST_TO_ADDR
22712: GO 23607
22714: LD_INT 5
22716: DOUBLE
22717: EQUAL
22718: IFTRUE 22722
22720: GO 22748
22722: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
22723: LD_ADDR_VAR 0 3
22727: PUSH
22728: LD_INT 2
22730: PUSH
22731: LD_INT 3
22733: PUSH
22734: LD_INT 4
22736: PUSH
22737: LD_INT 5
22739: PUSH
22740: EMPTY
22741: LIST
22742: LIST
22743: LIST
22744: LIST
22745: ST_TO_ADDR
22746: GO 23607
22748: LD_INT 9
22750: DOUBLE
22751: EQUAL
22752: IFTRUE 22756
22754: GO 22782
22756: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
22757: LD_ADDR_VAR 0 3
22761: PUSH
22762: LD_INT 2
22764: PUSH
22765: LD_INT 3
22767: PUSH
22768: LD_INT 4
22770: PUSH
22771: LD_INT 5
22773: PUSH
22774: EMPTY
22775: LIST
22776: LIST
22777: LIST
22778: LIST
22779: ST_TO_ADDR
22780: GO 23607
22782: LD_INT 7
22784: DOUBLE
22785: EQUAL
22786: IFTRUE 22790
22788: GO 22816
22790: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
22791: LD_ADDR_VAR 0 3
22795: PUSH
22796: LD_INT 2
22798: PUSH
22799: LD_INT 3
22801: PUSH
22802: LD_INT 4
22804: PUSH
22805: LD_INT 5
22807: PUSH
22808: EMPTY
22809: LIST
22810: LIST
22811: LIST
22812: LIST
22813: ST_TO_ADDR
22814: GO 23607
22816: LD_INT 12
22818: DOUBLE
22819: EQUAL
22820: IFTRUE 22824
22822: GO 22850
22824: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
22825: LD_ADDR_VAR 0 3
22829: PUSH
22830: LD_INT 2
22832: PUSH
22833: LD_INT 3
22835: PUSH
22836: LD_INT 4
22838: PUSH
22839: LD_INT 5
22841: PUSH
22842: EMPTY
22843: LIST
22844: LIST
22845: LIST
22846: LIST
22847: ST_TO_ADDR
22848: GO 23607
22850: LD_INT 13
22852: DOUBLE
22853: EQUAL
22854: IFTRUE 22858
22856: GO 22884
22858: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
22859: LD_ADDR_VAR 0 3
22863: PUSH
22864: LD_INT 2
22866: PUSH
22867: LD_INT 3
22869: PUSH
22870: LD_INT 4
22872: PUSH
22873: LD_INT 5
22875: PUSH
22876: EMPTY
22877: LIST
22878: LIST
22879: LIST
22880: LIST
22881: ST_TO_ADDR
22882: GO 23607
22884: LD_INT 14
22886: DOUBLE
22887: EQUAL
22888: IFTRUE 22892
22890: GO 22910
22892: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
22893: LD_ADDR_VAR 0 3
22897: PUSH
22898: LD_INT 4
22900: PUSH
22901: LD_INT 5
22903: PUSH
22904: EMPTY
22905: LIST
22906: LIST
22907: ST_TO_ADDR
22908: GO 23607
22910: LD_INT 6
22912: DOUBLE
22913: EQUAL
22914: IFTRUE 22918
22916: GO 22936
22918: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
22919: LD_ADDR_VAR 0 3
22923: PUSH
22924: LD_INT 4
22926: PUSH
22927: LD_INT 5
22929: PUSH
22930: EMPTY
22931: LIST
22932: LIST
22933: ST_TO_ADDR
22934: GO 23607
22936: LD_INT 10
22938: DOUBLE
22939: EQUAL
22940: IFTRUE 22944
22942: GO 22962
22944: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
22945: LD_ADDR_VAR 0 3
22949: PUSH
22950: LD_INT 4
22952: PUSH
22953: LD_INT 5
22955: PUSH
22956: EMPTY
22957: LIST
22958: LIST
22959: ST_TO_ADDR
22960: GO 23607
22962: LD_INT 22
22964: DOUBLE
22965: EQUAL
22966: IFTRUE 22970
22968: GO 22996
22970: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
22971: LD_ADDR_VAR 0 3
22975: PUSH
22976: LD_INT 11
22978: PUSH
22979: LD_INT 12
22981: PUSH
22982: LD_INT 13
22984: PUSH
22985: LD_INT 14
22987: PUSH
22988: EMPTY
22989: LIST
22990: LIST
22991: LIST
22992: LIST
22993: ST_TO_ADDR
22994: GO 23607
22996: LD_INT 23
22998: DOUBLE
22999: EQUAL
23000: IFTRUE 23004
23002: GO 23030
23004: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
23005: LD_ADDR_VAR 0 3
23009: PUSH
23010: LD_INT 11
23012: PUSH
23013: LD_INT 12
23015: PUSH
23016: LD_INT 13
23018: PUSH
23019: LD_INT 14
23021: PUSH
23022: EMPTY
23023: LIST
23024: LIST
23025: LIST
23026: LIST
23027: ST_TO_ADDR
23028: GO 23607
23030: LD_INT 24
23032: DOUBLE
23033: EQUAL
23034: IFTRUE 23038
23036: GO 23064
23038: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
23039: LD_ADDR_VAR 0 3
23043: PUSH
23044: LD_INT 11
23046: PUSH
23047: LD_INT 12
23049: PUSH
23050: LD_INT 13
23052: PUSH
23053: LD_INT 14
23055: PUSH
23056: EMPTY
23057: LIST
23058: LIST
23059: LIST
23060: LIST
23061: ST_TO_ADDR
23062: GO 23607
23064: LD_INT 30
23066: DOUBLE
23067: EQUAL
23068: IFTRUE 23072
23070: GO 23098
23072: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
23073: LD_ADDR_VAR 0 3
23077: PUSH
23078: LD_INT 11
23080: PUSH
23081: LD_INT 12
23083: PUSH
23084: LD_INT 13
23086: PUSH
23087: LD_INT 14
23089: PUSH
23090: EMPTY
23091: LIST
23092: LIST
23093: LIST
23094: LIST
23095: ST_TO_ADDR
23096: GO 23607
23098: LD_INT 25
23100: DOUBLE
23101: EQUAL
23102: IFTRUE 23106
23104: GO 23124
23106: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
23107: LD_ADDR_VAR 0 3
23111: PUSH
23112: LD_INT 13
23114: PUSH
23115: LD_INT 14
23117: PUSH
23118: EMPTY
23119: LIST
23120: LIST
23121: ST_TO_ADDR
23122: GO 23607
23124: LD_INT 27
23126: DOUBLE
23127: EQUAL
23128: IFTRUE 23132
23130: GO 23150
23132: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_mortar :
23133: LD_ADDR_VAR 0 3
23137: PUSH
23138: LD_INT 13
23140: PUSH
23141: LD_INT 14
23143: PUSH
23144: EMPTY
23145: LIST
23146: LIST
23147: ST_TO_ADDR
23148: GO 23607
23150: LD_EXP 162
23154: DOUBLE
23155: EQUAL
23156: IFTRUE 23160
23158: GO 23186
23160: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
23161: LD_ADDR_VAR 0 3
23165: PUSH
23166: LD_INT 11
23168: PUSH
23169: LD_INT 12
23171: PUSH
23172: LD_INT 13
23174: PUSH
23175: LD_INT 14
23177: PUSH
23178: EMPTY
23179: LIST
23180: LIST
23181: LIST
23182: LIST
23183: ST_TO_ADDR
23184: GO 23607
23186: LD_INT 28
23188: DOUBLE
23189: EQUAL
23190: IFTRUE 23194
23192: GO 23212
23194: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
23195: LD_ADDR_VAR 0 3
23199: PUSH
23200: LD_INT 13
23202: PUSH
23203: LD_INT 14
23205: PUSH
23206: EMPTY
23207: LIST
23208: LIST
23209: ST_TO_ADDR
23210: GO 23607
23212: LD_INT 29
23214: DOUBLE
23215: EQUAL
23216: IFTRUE 23220
23218: GO 23238
23220: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
23221: LD_ADDR_VAR 0 3
23225: PUSH
23226: LD_INT 13
23228: PUSH
23229: LD_INT 14
23231: PUSH
23232: EMPTY
23233: LIST
23234: LIST
23235: ST_TO_ADDR
23236: GO 23607
23238: LD_INT 31
23240: DOUBLE
23241: EQUAL
23242: IFTRUE 23246
23244: GO 23264
23246: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
23247: LD_ADDR_VAR 0 3
23251: PUSH
23252: LD_INT 13
23254: PUSH
23255: LD_INT 14
23257: PUSH
23258: EMPTY
23259: LIST
23260: LIST
23261: ST_TO_ADDR
23262: GO 23607
23264: LD_INT 26
23266: DOUBLE
23267: EQUAL
23268: IFTRUE 23272
23270: GO 23290
23272: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
23273: LD_ADDR_VAR 0 3
23277: PUSH
23278: LD_INT 13
23280: PUSH
23281: LD_INT 14
23283: PUSH
23284: EMPTY
23285: LIST
23286: LIST
23287: ST_TO_ADDR
23288: GO 23607
23290: LD_INT 42
23292: DOUBLE
23293: EQUAL
23294: IFTRUE 23298
23296: GO 23324
23298: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
23299: LD_ADDR_VAR 0 3
23303: PUSH
23304: LD_INT 21
23306: PUSH
23307: LD_INT 22
23309: PUSH
23310: LD_INT 23
23312: PUSH
23313: LD_INT 24
23315: PUSH
23316: EMPTY
23317: LIST
23318: LIST
23319: LIST
23320: LIST
23321: ST_TO_ADDR
23322: GO 23607
23324: LD_INT 43
23326: DOUBLE
23327: EQUAL
23328: IFTRUE 23332
23330: GO 23358
23332: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
23333: LD_ADDR_VAR 0 3
23337: PUSH
23338: LD_INT 21
23340: PUSH
23341: LD_INT 22
23343: PUSH
23344: LD_INT 23
23346: PUSH
23347: LD_INT 24
23349: PUSH
23350: EMPTY
23351: LIST
23352: LIST
23353: LIST
23354: LIST
23355: ST_TO_ADDR
23356: GO 23607
23358: LD_INT 44
23360: DOUBLE
23361: EQUAL
23362: IFTRUE 23366
23364: GO 23392
23366: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
23367: LD_ADDR_VAR 0 3
23371: PUSH
23372: LD_INT 21
23374: PUSH
23375: LD_INT 22
23377: PUSH
23378: LD_INT 23
23380: PUSH
23381: LD_INT 24
23383: PUSH
23384: EMPTY
23385: LIST
23386: LIST
23387: LIST
23388: LIST
23389: ST_TO_ADDR
23390: GO 23607
23392: LD_INT 45
23394: DOUBLE
23395: EQUAL
23396: IFTRUE 23400
23398: GO 23426
23400: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
23401: LD_ADDR_VAR 0 3
23405: PUSH
23406: LD_INT 21
23408: PUSH
23409: LD_INT 22
23411: PUSH
23412: LD_INT 23
23414: PUSH
23415: LD_INT 24
23417: PUSH
23418: EMPTY
23419: LIST
23420: LIST
23421: LIST
23422: LIST
23423: ST_TO_ADDR
23424: GO 23607
23426: LD_INT 49
23428: DOUBLE
23429: EQUAL
23430: IFTRUE 23434
23432: GO 23460
23434: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
23435: LD_ADDR_VAR 0 3
23439: PUSH
23440: LD_INT 21
23442: PUSH
23443: LD_INT 22
23445: PUSH
23446: LD_INT 23
23448: PUSH
23449: LD_INT 24
23451: PUSH
23452: EMPTY
23453: LIST
23454: LIST
23455: LIST
23456: LIST
23457: ST_TO_ADDR
23458: GO 23607
23460: LD_INT 51
23462: DOUBLE
23463: EQUAL
23464: IFTRUE 23468
23466: GO 23494
23468: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
23469: LD_ADDR_VAR 0 3
23473: PUSH
23474: LD_INT 21
23476: PUSH
23477: LD_INT 22
23479: PUSH
23480: LD_INT 23
23482: PUSH
23483: LD_INT 24
23485: PUSH
23486: EMPTY
23487: LIST
23488: LIST
23489: LIST
23490: LIST
23491: ST_TO_ADDR
23492: GO 23607
23494: LD_INT 52
23496: DOUBLE
23497: EQUAL
23498: IFTRUE 23502
23500: GO 23528
23502: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
23503: LD_ADDR_VAR 0 3
23507: PUSH
23508: LD_INT 21
23510: PUSH
23511: LD_INT 22
23513: PUSH
23514: LD_INT 23
23516: PUSH
23517: LD_INT 24
23519: PUSH
23520: EMPTY
23521: LIST
23522: LIST
23523: LIST
23524: LIST
23525: ST_TO_ADDR
23526: GO 23607
23528: LD_INT 53
23530: DOUBLE
23531: EQUAL
23532: IFTRUE 23536
23534: GO 23554
23536: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
23537: LD_ADDR_VAR 0 3
23541: PUSH
23542: LD_INT 23
23544: PUSH
23545: LD_INT 24
23547: PUSH
23548: EMPTY
23549: LIST
23550: LIST
23551: ST_TO_ADDR
23552: GO 23607
23554: LD_INT 46
23556: DOUBLE
23557: EQUAL
23558: IFTRUE 23562
23560: GO 23580
23562: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
23563: LD_ADDR_VAR 0 3
23567: PUSH
23568: LD_INT 23
23570: PUSH
23571: LD_INT 24
23573: PUSH
23574: EMPTY
23575: LIST
23576: LIST
23577: ST_TO_ADDR
23578: GO 23607
23580: LD_INT 47
23582: DOUBLE
23583: EQUAL
23584: IFTRUE 23588
23586: GO 23606
23588: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
23589: LD_ADDR_VAR 0 3
23593: PUSH
23594: LD_INT 23
23596: PUSH
23597: LD_INT 24
23599: PUSH
23600: EMPTY
23601: LIST
23602: LIST
23603: ST_TO_ADDR
23604: GO 23607
23606: POP
// result := ( chassis in result ) ;
23607: LD_ADDR_VAR 0 3
23611: PUSH
23612: LD_VAR 0 1
23616: PUSH
23617: LD_VAR 0 3
23621: IN
23622: ST_TO_ADDR
// end ;
23623: LD_VAR 0 3
23627: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
23628: LD_INT 0
23630: PPUSH
23631: PPUSH
23632: PPUSH
23633: PPUSH
23634: PPUSH
23635: PPUSH
23636: PPUSH
// result := array ;
23637: LD_ADDR_VAR 0 5
23641: PUSH
23642: LD_VAR 0 1
23646: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
23647: LD_VAR 0 1
23651: NOT
23652: PUSH
23653: LD_VAR 0 2
23657: NOT
23658: OR
23659: PUSH
23660: LD_VAR 0 3
23664: NOT
23665: OR
23666: PUSH
23667: LD_VAR 0 2
23671: PUSH
23672: LD_VAR 0 1
23676: GREATER
23677: OR
23678: PUSH
23679: LD_VAR 0 3
23683: PUSH
23684: LD_VAR 0 1
23688: GREATER
23689: OR
23690: IFFALSE 23694
// exit ;
23692: GO 23990
// if direction then
23694: LD_VAR 0 4
23698: IFFALSE 23762
// begin d := 1 ;
23700: LD_ADDR_VAR 0 9
23704: PUSH
23705: LD_INT 1
23707: ST_TO_ADDR
// if i_from > i_to then
23708: LD_VAR 0 2
23712: PUSH
23713: LD_VAR 0 3
23717: GREATER
23718: IFFALSE 23744
// length := ( array - i_from ) + i_to else
23720: LD_ADDR_VAR 0 11
23724: PUSH
23725: LD_VAR 0 1
23729: PUSH
23730: LD_VAR 0 2
23734: MINUS
23735: PUSH
23736: LD_VAR 0 3
23740: PLUS
23741: ST_TO_ADDR
23742: GO 23760
// length := i_to - i_from ;
23744: LD_ADDR_VAR 0 11
23748: PUSH
23749: LD_VAR 0 3
23753: PUSH
23754: LD_VAR 0 2
23758: MINUS
23759: ST_TO_ADDR
// end else
23760: GO 23823
// begin d := - 1 ;
23762: LD_ADDR_VAR 0 9
23766: PUSH
23767: LD_INT 1
23769: NEG
23770: ST_TO_ADDR
// if i_from > i_to then
23771: LD_VAR 0 2
23775: PUSH
23776: LD_VAR 0 3
23780: GREATER
23781: IFFALSE 23801
// length := i_from - i_to else
23783: LD_ADDR_VAR 0 11
23787: PUSH
23788: LD_VAR 0 2
23792: PUSH
23793: LD_VAR 0 3
23797: MINUS
23798: ST_TO_ADDR
23799: GO 23823
// length := ( array - i_to ) + i_from ;
23801: LD_ADDR_VAR 0 11
23805: PUSH
23806: LD_VAR 0 1
23810: PUSH
23811: LD_VAR 0 3
23815: MINUS
23816: PUSH
23817: LD_VAR 0 2
23821: PLUS
23822: ST_TO_ADDR
// end ; if not length then
23823: LD_VAR 0 11
23827: NOT
23828: IFFALSE 23832
// exit ;
23830: GO 23990
// tmp := array ;
23832: LD_ADDR_VAR 0 10
23836: PUSH
23837: LD_VAR 0 1
23841: ST_TO_ADDR
// for i = 1 to length do
23842: LD_ADDR_VAR 0 6
23846: PUSH
23847: DOUBLE
23848: LD_INT 1
23850: DEC
23851: ST_TO_ADDR
23852: LD_VAR 0 11
23856: PUSH
23857: FOR_TO
23858: IFFALSE 23978
// begin for j = 1 to array do
23860: LD_ADDR_VAR 0 7
23864: PUSH
23865: DOUBLE
23866: LD_INT 1
23868: DEC
23869: ST_TO_ADDR
23870: LD_VAR 0 1
23874: PUSH
23875: FOR_TO
23876: IFFALSE 23964
// begin k := j + d ;
23878: LD_ADDR_VAR 0 8
23882: PUSH
23883: LD_VAR 0 7
23887: PUSH
23888: LD_VAR 0 9
23892: PLUS
23893: ST_TO_ADDR
// if k > array then
23894: LD_VAR 0 8
23898: PUSH
23899: LD_VAR 0 1
23903: GREATER
23904: IFFALSE 23914
// k := 1 ;
23906: LD_ADDR_VAR 0 8
23910: PUSH
23911: LD_INT 1
23913: ST_TO_ADDR
// if not k then
23914: LD_VAR 0 8
23918: NOT
23919: IFFALSE 23931
// k := array ;
23921: LD_ADDR_VAR 0 8
23925: PUSH
23926: LD_VAR 0 1
23930: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
23931: LD_ADDR_VAR 0 10
23935: PUSH
23936: LD_VAR 0 10
23940: PPUSH
23941: LD_VAR 0 8
23945: PPUSH
23946: LD_VAR 0 1
23950: PUSH
23951: LD_VAR 0 7
23955: ARRAY
23956: PPUSH
23957: CALL_OW 1
23961: ST_TO_ADDR
// end ;
23962: GO 23875
23964: POP
23965: POP
// array := tmp ;
23966: LD_ADDR_VAR 0 1
23970: PUSH
23971: LD_VAR 0 10
23975: ST_TO_ADDR
// end ;
23976: GO 23857
23978: POP
23979: POP
// result := array ;
23980: LD_ADDR_VAR 0 5
23984: PUSH
23985: LD_VAR 0 1
23989: ST_TO_ADDR
// end ;
23990: LD_VAR 0 5
23994: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
23995: LD_INT 0
23997: PPUSH
23998: PPUSH
// result := 0 ;
23999: LD_ADDR_VAR 0 3
24003: PUSH
24004: LD_INT 0
24006: ST_TO_ADDR
// if not array or not value in array then
24007: LD_VAR 0 1
24011: NOT
24012: PUSH
24013: LD_VAR 0 2
24017: PUSH
24018: LD_VAR 0 1
24022: IN
24023: NOT
24024: OR
24025: IFFALSE 24029
// exit ;
24027: GO 24083
// for i = 1 to array do
24029: LD_ADDR_VAR 0 4
24033: PUSH
24034: DOUBLE
24035: LD_INT 1
24037: DEC
24038: ST_TO_ADDR
24039: LD_VAR 0 1
24043: PUSH
24044: FOR_TO
24045: IFFALSE 24081
// if value = array [ i ] then
24047: LD_VAR 0 2
24051: PUSH
24052: LD_VAR 0 1
24056: PUSH
24057: LD_VAR 0 4
24061: ARRAY
24062: EQUAL
24063: IFFALSE 24079
// begin result := i ;
24065: LD_ADDR_VAR 0 3
24069: PUSH
24070: LD_VAR 0 4
24074: ST_TO_ADDR
// exit ;
24075: POP
24076: POP
24077: GO 24083
// end ;
24079: GO 24044
24081: POP
24082: POP
// end ;
24083: LD_VAR 0 3
24087: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
24088: LD_INT 0
24090: PPUSH
// vc_chassis := chassis ;
24091: LD_ADDR_OWVAR 37
24095: PUSH
24096: LD_VAR 0 1
24100: ST_TO_ADDR
// vc_engine := engine ;
24101: LD_ADDR_OWVAR 39
24105: PUSH
24106: LD_VAR 0 2
24110: ST_TO_ADDR
// vc_control := control ;
24111: LD_ADDR_OWVAR 38
24115: PUSH
24116: LD_VAR 0 3
24120: ST_TO_ADDR
// vc_weapon := weapon ;
24121: LD_ADDR_OWVAR 40
24125: PUSH
24126: LD_VAR 0 4
24130: ST_TO_ADDR
// vc_fuel_battery := fuel ;
24131: LD_ADDR_OWVAR 41
24135: PUSH
24136: LD_VAR 0 5
24140: ST_TO_ADDR
// end ;
24141: LD_VAR 0 6
24145: RET
// export function WantPlant ( unit ) ; var task ; begin
24146: LD_INT 0
24148: PPUSH
24149: PPUSH
// result := false ;
24150: LD_ADDR_VAR 0 2
24154: PUSH
24155: LD_INT 0
24157: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
24158: LD_ADDR_VAR 0 3
24162: PUSH
24163: LD_VAR 0 1
24167: PPUSH
24168: CALL_OW 437
24172: ST_TO_ADDR
// if task then
24173: LD_VAR 0 3
24177: IFFALSE 24205
// if task [ 1 ] [ 1 ] = p then
24179: LD_VAR 0 3
24183: PUSH
24184: LD_INT 1
24186: ARRAY
24187: PUSH
24188: LD_INT 1
24190: ARRAY
24191: PUSH
24192: LD_STRING p
24194: EQUAL
24195: IFFALSE 24205
// result := true ;
24197: LD_ADDR_VAR 0 2
24201: PUSH
24202: LD_INT 1
24204: ST_TO_ADDR
// end ;
24205: LD_VAR 0 2
24209: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
24210: LD_INT 0
24212: PPUSH
24213: PPUSH
24214: PPUSH
24215: PPUSH
// if pos < 1 then
24216: LD_VAR 0 2
24220: PUSH
24221: LD_INT 1
24223: LESS
24224: IFFALSE 24228
// exit ;
24226: GO 24531
// if pos = 1 then
24228: LD_VAR 0 2
24232: PUSH
24233: LD_INT 1
24235: EQUAL
24236: IFFALSE 24269
// result := Replace ( arr , pos [ 1 ] , value ) else
24238: LD_ADDR_VAR 0 4
24242: PUSH
24243: LD_VAR 0 1
24247: PPUSH
24248: LD_VAR 0 2
24252: PUSH
24253: LD_INT 1
24255: ARRAY
24256: PPUSH
24257: LD_VAR 0 3
24261: PPUSH
24262: CALL_OW 1
24266: ST_TO_ADDR
24267: GO 24531
// begin tmp := arr ;
24269: LD_ADDR_VAR 0 6
24273: PUSH
24274: LD_VAR 0 1
24278: ST_TO_ADDR
// s_arr := [ tmp ] ;
24279: LD_ADDR_VAR 0 7
24283: PUSH
24284: LD_VAR 0 6
24288: PUSH
24289: EMPTY
24290: LIST
24291: ST_TO_ADDR
// for i = 1 to pos - 1 do
24292: LD_ADDR_VAR 0 5
24296: PUSH
24297: DOUBLE
24298: LD_INT 1
24300: DEC
24301: ST_TO_ADDR
24302: LD_VAR 0 2
24306: PUSH
24307: LD_INT 1
24309: MINUS
24310: PUSH
24311: FOR_TO
24312: IFFALSE 24357
// begin tmp := tmp [ pos [ i ] ] ;
24314: LD_ADDR_VAR 0 6
24318: PUSH
24319: LD_VAR 0 6
24323: PUSH
24324: LD_VAR 0 2
24328: PUSH
24329: LD_VAR 0 5
24333: ARRAY
24334: ARRAY
24335: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
24336: LD_ADDR_VAR 0 7
24340: PUSH
24341: LD_VAR 0 7
24345: PUSH
24346: LD_VAR 0 6
24350: PUSH
24351: EMPTY
24352: LIST
24353: ADD
24354: ST_TO_ADDR
// end ;
24355: GO 24311
24357: POP
24358: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
24359: LD_ADDR_VAR 0 6
24363: PUSH
24364: LD_VAR 0 6
24368: PPUSH
24369: LD_VAR 0 2
24373: PUSH
24374: LD_VAR 0 2
24378: ARRAY
24379: PPUSH
24380: LD_VAR 0 3
24384: PPUSH
24385: CALL_OW 1
24389: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
24390: LD_ADDR_VAR 0 7
24394: PUSH
24395: LD_VAR 0 7
24399: PPUSH
24400: LD_VAR 0 7
24404: PPUSH
24405: LD_VAR 0 6
24409: PPUSH
24410: CALL_OW 1
24414: ST_TO_ADDR
// for i = s_arr downto 2 do
24415: LD_ADDR_VAR 0 5
24419: PUSH
24420: DOUBLE
24421: LD_VAR 0 7
24425: INC
24426: ST_TO_ADDR
24427: LD_INT 2
24429: PUSH
24430: FOR_DOWNTO
24431: IFFALSE 24515
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
24433: LD_ADDR_VAR 0 6
24437: PUSH
24438: LD_VAR 0 7
24442: PUSH
24443: LD_VAR 0 5
24447: PUSH
24448: LD_INT 1
24450: MINUS
24451: ARRAY
24452: PPUSH
24453: LD_VAR 0 2
24457: PUSH
24458: LD_VAR 0 5
24462: PUSH
24463: LD_INT 1
24465: MINUS
24466: ARRAY
24467: PPUSH
24468: LD_VAR 0 7
24472: PUSH
24473: LD_VAR 0 5
24477: ARRAY
24478: PPUSH
24479: CALL_OW 1
24483: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
24484: LD_ADDR_VAR 0 7
24488: PUSH
24489: LD_VAR 0 7
24493: PPUSH
24494: LD_VAR 0 5
24498: PUSH
24499: LD_INT 1
24501: MINUS
24502: PPUSH
24503: LD_VAR 0 6
24507: PPUSH
24508: CALL_OW 1
24512: ST_TO_ADDR
// end ;
24513: GO 24430
24515: POP
24516: POP
// result := s_arr [ 1 ] ;
24517: LD_ADDR_VAR 0 4
24521: PUSH
24522: LD_VAR 0 7
24526: PUSH
24527: LD_INT 1
24529: ARRAY
24530: ST_TO_ADDR
// end ; end ;
24531: LD_VAR 0 4
24535: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
24536: LD_INT 0
24538: PPUSH
24539: PPUSH
// if not list then
24540: LD_VAR 0 1
24544: NOT
24545: IFFALSE 24549
// exit ;
24547: GO 24640
// i := list [ pos1 ] ;
24549: LD_ADDR_VAR 0 5
24553: PUSH
24554: LD_VAR 0 1
24558: PUSH
24559: LD_VAR 0 2
24563: ARRAY
24564: ST_TO_ADDR
// if not i then
24565: LD_VAR 0 5
24569: NOT
24570: IFFALSE 24574
// exit ;
24572: GO 24640
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
24574: LD_ADDR_VAR 0 1
24578: PUSH
24579: LD_VAR 0 1
24583: PPUSH
24584: LD_VAR 0 2
24588: PPUSH
24589: LD_VAR 0 1
24593: PUSH
24594: LD_VAR 0 3
24598: ARRAY
24599: PPUSH
24600: CALL_OW 1
24604: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
24605: LD_ADDR_VAR 0 1
24609: PUSH
24610: LD_VAR 0 1
24614: PPUSH
24615: LD_VAR 0 3
24619: PPUSH
24620: LD_VAR 0 5
24624: PPUSH
24625: CALL_OW 1
24629: ST_TO_ADDR
// result := list ;
24630: LD_ADDR_VAR 0 4
24634: PUSH
24635: LD_VAR 0 1
24639: ST_TO_ADDR
// end ;
24640: LD_VAR 0 4
24644: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
24645: LD_INT 0
24647: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
24648: LD_ADDR_VAR 0 5
24652: PUSH
24653: LD_VAR 0 1
24657: PPUSH
24658: CALL_OW 250
24662: PPUSH
24663: LD_VAR 0 1
24667: PPUSH
24668: CALL_OW 251
24672: PPUSH
24673: LD_VAR 0 2
24677: PPUSH
24678: LD_VAR 0 3
24682: PPUSH
24683: LD_VAR 0 4
24687: PPUSH
24688: CALL 24698 0 5
24692: ST_TO_ADDR
// end ;
24693: LD_VAR 0 5
24697: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
24698: LD_INT 0
24700: PPUSH
24701: PPUSH
24702: PPUSH
24703: PPUSH
// if not list then
24704: LD_VAR 0 3
24708: NOT
24709: IFFALSE 24713
// exit ;
24711: GO 25101
// result := [ ] ;
24713: LD_ADDR_VAR 0 6
24717: PUSH
24718: EMPTY
24719: ST_TO_ADDR
// for i in list do
24720: LD_ADDR_VAR 0 7
24724: PUSH
24725: LD_VAR 0 3
24729: PUSH
24730: FOR_IN
24731: IFFALSE 24933
// begin tmp := GetDistUnitXY ( i , x , y ) ;
24733: LD_ADDR_VAR 0 9
24737: PUSH
24738: LD_VAR 0 7
24742: PPUSH
24743: LD_VAR 0 1
24747: PPUSH
24748: LD_VAR 0 2
24752: PPUSH
24753: CALL_OW 297
24757: ST_TO_ADDR
// if not result then
24758: LD_VAR 0 6
24762: NOT
24763: IFFALSE 24789
// result := [ [ i , tmp ] ] else
24765: LD_ADDR_VAR 0 6
24769: PUSH
24770: LD_VAR 0 7
24774: PUSH
24775: LD_VAR 0 9
24779: PUSH
24780: EMPTY
24781: LIST
24782: LIST
24783: PUSH
24784: EMPTY
24785: LIST
24786: ST_TO_ADDR
24787: GO 24931
// begin if result [ result ] [ 2 ] < tmp then
24789: LD_VAR 0 6
24793: PUSH
24794: LD_VAR 0 6
24798: ARRAY
24799: PUSH
24800: LD_INT 2
24802: ARRAY
24803: PUSH
24804: LD_VAR 0 9
24808: LESS
24809: IFFALSE 24851
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
24811: LD_ADDR_VAR 0 6
24815: PUSH
24816: LD_VAR 0 6
24820: PPUSH
24821: LD_VAR 0 6
24825: PUSH
24826: LD_INT 1
24828: PLUS
24829: PPUSH
24830: LD_VAR 0 7
24834: PUSH
24835: LD_VAR 0 9
24839: PUSH
24840: EMPTY
24841: LIST
24842: LIST
24843: PPUSH
24844: CALL_OW 2
24848: ST_TO_ADDR
24849: GO 24931
// for j = 1 to result do
24851: LD_ADDR_VAR 0 8
24855: PUSH
24856: DOUBLE
24857: LD_INT 1
24859: DEC
24860: ST_TO_ADDR
24861: LD_VAR 0 6
24865: PUSH
24866: FOR_TO
24867: IFFALSE 24929
// begin if tmp < result [ j ] [ 2 ] then
24869: LD_VAR 0 9
24873: PUSH
24874: LD_VAR 0 6
24878: PUSH
24879: LD_VAR 0 8
24883: ARRAY
24884: PUSH
24885: LD_INT 2
24887: ARRAY
24888: LESS
24889: IFFALSE 24927
// begin result := Insert ( result , j , [ i , tmp ] ) ;
24891: LD_ADDR_VAR 0 6
24895: PUSH
24896: LD_VAR 0 6
24900: PPUSH
24901: LD_VAR 0 8
24905: PPUSH
24906: LD_VAR 0 7
24910: PUSH
24911: LD_VAR 0 9
24915: PUSH
24916: EMPTY
24917: LIST
24918: LIST
24919: PPUSH
24920: CALL_OW 2
24924: ST_TO_ADDR
// break ;
24925: GO 24929
// end ; end ;
24927: GO 24866
24929: POP
24930: POP
// end ; end ;
24931: GO 24730
24933: POP
24934: POP
// if result and not asc then
24935: LD_VAR 0 6
24939: PUSH
24940: LD_VAR 0 4
24944: NOT
24945: AND
24946: IFFALSE 25021
// begin tmp := result ;
24948: LD_ADDR_VAR 0 9
24952: PUSH
24953: LD_VAR 0 6
24957: ST_TO_ADDR
// for i = tmp downto 1 do
24958: LD_ADDR_VAR 0 7
24962: PUSH
24963: DOUBLE
24964: LD_VAR 0 9
24968: INC
24969: ST_TO_ADDR
24970: LD_INT 1
24972: PUSH
24973: FOR_DOWNTO
24974: IFFALSE 25019
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
24976: LD_ADDR_VAR 0 6
24980: PUSH
24981: LD_VAR 0 6
24985: PPUSH
24986: LD_VAR 0 9
24990: PUSH
24991: LD_VAR 0 7
24995: MINUS
24996: PUSH
24997: LD_INT 1
24999: PLUS
25000: PPUSH
25001: LD_VAR 0 9
25005: PUSH
25006: LD_VAR 0 7
25010: ARRAY
25011: PPUSH
25012: CALL_OW 1
25016: ST_TO_ADDR
25017: GO 24973
25019: POP
25020: POP
// end ; tmp := [ ] ;
25021: LD_ADDR_VAR 0 9
25025: PUSH
25026: EMPTY
25027: ST_TO_ADDR
// if mode then
25028: LD_VAR 0 5
25032: IFFALSE 25101
// begin for i = 1 to result do
25034: LD_ADDR_VAR 0 7
25038: PUSH
25039: DOUBLE
25040: LD_INT 1
25042: DEC
25043: ST_TO_ADDR
25044: LD_VAR 0 6
25048: PUSH
25049: FOR_TO
25050: IFFALSE 25089
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
25052: LD_ADDR_VAR 0 9
25056: PUSH
25057: LD_VAR 0 9
25061: PPUSH
25062: LD_VAR 0 7
25066: PPUSH
25067: LD_VAR 0 6
25071: PUSH
25072: LD_VAR 0 7
25076: ARRAY
25077: PUSH
25078: LD_INT 1
25080: ARRAY
25081: PPUSH
25082: CALL_OW 1
25086: ST_TO_ADDR
25087: GO 25049
25089: POP
25090: POP
// result := tmp ;
25091: LD_ADDR_VAR 0 6
25095: PUSH
25096: LD_VAR 0 9
25100: ST_TO_ADDR
// end ; end ;
25101: LD_VAR 0 6
25105: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
25106: LD_INT 0
25108: PPUSH
25109: PPUSH
25110: PPUSH
25111: PPUSH
25112: PPUSH
25113: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
25114: LD_ADDR_VAR 0 5
25118: PUSH
25119: LD_INT 0
25121: PUSH
25122: LD_INT 0
25124: PUSH
25125: LD_INT 0
25127: PUSH
25128: EMPTY
25129: PUSH
25130: EMPTY
25131: LIST
25132: LIST
25133: LIST
25134: LIST
25135: ST_TO_ADDR
// if not x or not y then
25136: LD_VAR 0 2
25140: NOT
25141: PUSH
25142: LD_VAR 0 3
25146: NOT
25147: OR
25148: IFFALSE 25152
// exit ;
25150: GO 26804
// if not range then
25152: LD_VAR 0 4
25156: NOT
25157: IFFALSE 25167
// range := 10 ;
25159: LD_ADDR_VAR 0 4
25163: PUSH
25164: LD_INT 10
25166: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
25167: LD_ADDR_VAR 0 8
25171: PUSH
25172: LD_INT 81
25174: PUSH
25175: LD_VAR 0 1
25179: PUSH
25180: EMPTY
25181: LIST
25182: LIST
25183: PUSH
25184: LD_INT 92
25186: PUSH
25187: LD_VAR 0 2
25191: PUSH
25192: LD_VAR 0 3
25196: PUSH
25197: LD_VAR 0 4
25201: PUSH
25202: EMPTY
25203: LIST
25204: LIST
25205: LIST
25206: LIST
25207: PUSH
25208: LD_INT 3
25210: PUSH
25211: LD_INT 21
25213: PUSH
25214: LD_INT 3
25216: PUSH
25217: EMPTY
25218: LIST
25219: LIST
25220: PUSH
25221: EMPTY
25222: LIST
25223: LIST
25224: PUSH
25225: EMPTY
25226: LIST
25227: LIST
25228: LIST
25229: PPUSH
25230: CALL_OW 69
25234: ST_TO_ADDR
// if not tmp then
25235: LD_VAR 0 8
25239: NOT
25240: IFFALSE 25244
// exit ;
25242: GO 26804
// for i in tmp do
25244: LD_ADDR_VAR 0 6
25248: PUSH
25249: LD_VAR 0 8
25253: PUSH
25254: FOR_IN
25255: IFFALSE 26779
// begin points := [ 0 , 0 , 0 ] ;
25257: LD_ADDR_VAR 0 9
25261: PUSH
25262: LD_INT 0
25264: PUSH
25265: LD_INT 0
25267: PUSH
25268: LD_INT 0
25270: PUSH
25271: EMPTY
25272: LIST
25273: LIST
25274: LIST
25275: ST_TO_ADDR
// bpoints := 1 ;
25276: LD_ADDR_VAR 0 10
25280: PUSH
25281: LD_INT 1
25283: ST_TO_ADDR
// case GetType ( i ) of unit_human :
25284: LD_VAR 0 6
25288: PPUSH
25289: CALL_OW 247
25293: PUSH
25294: LD_INT 1
25296: DOUBLE
25297: EQUAL
25298: IFTRUE 25302
25300: GO 25880
25302: POP
// begin if GetClass ( i ) = 1 then
25303: LD_VAR 0 6
25307: PPUSH
25308: CALL_OW 257
25312: PUSH
25313: LD_INT 1
25315: EQUAL
25316: IFFALSE 25337
// points := [ 10 , 5 , 3 ] ;
25318: LD_ADDR_VAR 0 9
25322: PUSH
25323: LD_INT 10
25325: PUSH
25326: LD_INT 5
25328: PUSH
25329: LD_INT 3
25331: PUSH
25332: EMPTY
25333: LIST
25334: LIST
25335: LIST
25336: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
25337: LD_VAR 0 6
25341: PPUSH
25342: CALL_OW 257
25346: PUSH
25347: LD_INT 2
25349: PUSH
25350: LD_INT 3
25352: PUSH
25353: LD_INT 4
25355: PUSH
25356: EMPTY
25357: LIST
25358: LIST
25359: LIST
25360: IN
25361: IFFALSE 25382
// points := [ 3 , 2 , 1 ] ;
25363: LD_ADDR_VAR 0 9
25367: PUSH
25368: LD_INT 3
25370: PUSH
25371: LD_INT 2
25373: PUSH
25374: LD_INT 1
25376: PUSH
25377: EMPTY
25378: LIST
25379: LIST
25380: LIST
25381: ST_TO_ADDR
// if GetClass ( i ) = 5 then
25382: LD_VAR 0 6
25386: PPUSH
25387: CALL_OW 257
25391: PUSH
25392: LD_INT 5
25394: EQUAL
25395: IFFALSE 25416
// points := [ 130 , 5 , 2 ] ;
25397: LD_ADDR_VAR 0 9
25401: PUSH
25402: LD_INT 130
25404: PUSH
25405: LD_INT 5
25407: PUSH
25408: LD_INT 2
25410: PUSH
25411: EMPTY
25412: LIST
25413: LIST
25414: LIST
25415: ST_TO_ADDR
// if GetClass ( i ) = 8 then
25416: LD_VAR 0 6
25420: PPUSH
25421: CALL_OW 257
25425: PUSH
25426: LD_INT 8
25428: EQUAL
25429: IFFALSE 25450
// points := [ 35 , 35 , 30 ] ;
25431: LD_ADDR_VAR 0 9
25435: PUSH
25436: LD_INT 35
25438: PUSH
25439: LD_INT 35
25441: PUSH
25442: LD_INT 30
25444: PUSH
25445: EMPTY
25446: LIST
25447: LIST
25448: LIST
25449: ST_TO_ADDR
// if GetClass ( i ) = 9 then
25450: LD_VAR 0 6
25454: PPUSH
25455: CALL_OW 257
25459: PUSH
25460: LD_INT 9
25462: EQUAL
25463: IFFALSE 25484
// points := [ 20 , 55 , 40 ] ;
25465: LD_ADDR_VAR 0 9
25469: PUSH
25470: LD_INT 20
25472: PUSH
25473: LD_INT 55
25475: PUSH
25476: LD_INT 40
25478: PUSH
25479: EMPTY
25480: LIST
25481: LIST
25482: LIST
25483: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
25484: LD_VAR 0 6
25488: PPUSH
25489: CALL_OW 257
25493: PUSH
25494: LD_INT 12
25496: PUSH
25497: LD_INT 16
25499: PUSH
25500: EMPTY
25501: LIST
25502: LIST
25503: IN
25504: IFFALSE 25525
// points := [ 5 , 3 , 2 ] ;
25506: LD_ADDR_VAR 0 9
25510: PUSH
25511: LD_INT 5
25513: PUSH
25514: LD_INT 3
25516: PUSH
25517: LD_INT 2
25519: PUSH
25520: EMPTY
25521: LIST
25522: LIST
25523: LIST
25524: ST_TO_ADDR
// if GetClass ( i ) = 17 then
25525: LD_VAR 0 6
25529: PPUSH
25530: CALL_OW 257
25534: PUSH
25535: LD_INT 17
25537: EQUAL
25538: IFFALSE 25559
// points := [ 100 , 50 , 75 ] ;
25540: LD_ADDR_VAR 0 9
25544: PUSH
25545: LD_INT 100
25547: PUSH
25548: LD_INT 50
25550: PUSH
25551: LD_INT 75
25553: PUSH
25554: EMPTY
25555: LIST
25556: LIST
25557: LIST
25558: ST_TO_ADDR
// if GetClass ( i ) = 15 then
25559: LD_VAR 0 6
25563: PPUSH
25564: CALL_OW 257
25568: PUSH
25569: LD_INT 15
25571: EQUAL
25572: IFFALSE 25593
// points := [ 10 , 5 , 3 ] ;
25574: LD_ADDR_VAR 0 9
25578: PUSH
25579: LD_INT 10
25581: PUSH
25582: LD_INT 5
25584: PUSH
25585: LD_INT 3
25587: PUSH
25588: EMPTY
25589: LIST
25590: LIST
25591: LIST
25592: ST_TO_ADDR
// if GetClass ( i ) = 14 then
25593: LD_VAR 0 6
25597: PPUSH
25598: CALL_OW 257
25602: PUSH
25603: LD_INT 14
25605: EQUAL
25606: IFFALSE 25627
// points := [ 10 , 0 , 0 ] ;
25608: LD_ADDR_VAR 0 9
25612: PUSH
25613: LD_INT 10
25615: PUSH
25616: LD_INT 0
25618: PUSH
25619: LD_INT 0
25621: PUSH
25622: EMPTY
25623: LIST
25624: LIST
25625: LIST
25626: ST_TO_ADDR
// if GetClass ( i ) = 11 then
25627: LD_VAR 0 6
25631: PPUSH
25632: CALL_OW 257
25636: PUSH
25637: LD_INT 11
25639: EQUAL
25640: IFFALSE 25661
// points := [ 30 , 10 , 5 ] ;
25642: LD_ADDR_VAR 0 9
25646: PUSH
25647: LD_INT 30
25649: PUSH
25650: LD_INT 10
25652: PUSH
25653: LD_INT 5
25655: PUSH
25656: EMPTY
25657: LIST
25658: LIST
25659: LIST
25660: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
25661: LD_VAR 0 1
25665: PPUSH
25666: LD_INT 5
25668: PPUSH
25669: CALL_OW 321
25673: PUSH
25674: LD_INT 2
25676: EQUAL
25677: IFFALSE 25694
// bpoints := bpoints * 1.8 ;
25679: LD_ADDR_VAR 0 10
25683: PUSH
25684: LD_VAR 0 10
25688: PUSH
25689: LD_REAL  1.80000000000000E+0000
25692: MUL
25693: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
25694: LD_VAR 0 6
25698: PPUSH
25699: CALL_OW 257
25703: PUSH
25704: LD_INT 1
25706: PUSH
25707: LD_INT 2
25709: PUSH
25710: LD_INT 3
25712: PUSH
25713: LD_INT 4
25715: PUSH
25716: EMPTY
25717: LIST
25718: LIST
25719: LIST
25720: LIST
25721: IN
25722: PUSH
25723: LD_VAR 0 1
25727: PPUSH
25728: LD_INT 51
25730: PPUSH
25731: CALL_OW 321
25735: PUSH
25736: LD_INT 2
25738: EQUAL
25739: AND
25740: IFFALSE 25757
// bpoints := bpoints * 1.2 ;
25742: LD_ADDR_VAR 0 10
25746: PUSH
25747: LD_VAR 0 10
25751: PUSH
25752: LD_REAL  1.20000000000000E+0000
25755: MUL
25756: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
25757: LD_VAR 0 6
25761: PPUSH
25762: CALL_OW 257
25766: PUSH
25767: LD_INT 5
25769: PUSH
25770: LD_INT 7
25772: PUSH
25773: LD_INT 9
25775: PUSH
25776: EMPTY
25777: LIST
25778: LIST
25779: LIST
25780: IN
25781: PUSH
25782: LD_VAR 0 1
25786: PPUSH
25787: LD_INT 52
25789: PPUSH
25790: CALL_OW 321
25794: PUSH
25795: LD_INT 2
25797: EQUAL
25798: AND
25799: IFFALSE 25816
// bpoints := bpoints * 1.5 ;
25801: LD_ADDR_VAR 0 10
25805: PUSH
25806: LD_VAR 0 10
25810: PUSH
25811: LD_REAL  1.50000000000000E+0000
25814: MUL
25815: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
25816: LD_VAR 0 1
25820: PPUSH
25821: LD_INT 66
25823: PPUSH
25824: CALL_OW 321
25828: PUSH
25829: LD_INT 2
25831: EQUAL
25832: IFFALSE 25849
// bpoints := bpoints * 1.1 ;
25834: LD_ADDR_VAR 0 10
25838: PUSH
25839: LD_VAR 0 10
25843: PUSH
25844: LD_REAL  1.10000000000000E+0000
25847: MUL
25848: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
25849: LD_ADDR_VAR 0 10
25853: PUSH
25854: LD_VAR 0 10
25858: PUSH
25859: LD_VAR 0 6
25863: PPUSH
25864: LD_INT 1
25866: PPUSH
25867: CALL_OW 259
25871: PUSH
25872: LD_REAL  1.15000000000000E+0000
25875: MUL
25876: MUL
25877: ST_TO_ADDR
// end ; unit_vehicle :
25878: GO 26708
25880: LD_INT 2
25882: DOUBLE
25883: EQUAL
25884: IFTRUE 25888
25886: GO 26696
25888: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
25889: LD_VAR 0 6
25893: PPUSH
25894: CALL_OW 264
25898: PUSH
25899: LD_INT 2
25901: PUSH
25902: LD_INT 42
25904: PUSH
25905: LD_INT 24
25907: PUSH
25908: EMPTY
25909: LIST
25910: LIST
25911: LIST
25912: IN
25913: IFFALSE 25934
// points := [ 25 , 5 , 3 ] ;
25915: LD_ADDR_VAR 0 9
25919: PUSH
25920: LD_INT 25
25922: PUSH
25923: LD_INT 5
25925: PUSH
25926: LD_INT 3
25928: PUSH
25929: EMPTY
25930: LIST
25931: LIST
25932: LIST
25933: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
25934: LD_VAR 0 6
25938: PPUSH
25939: CALL_OW 264
25943: PUSH
25944: LD_INT 4
25946: PUSH
25947: LD_INT 43
25949: PUSH
25950: LD_INT 25
25952: PUSH
25953: EMPTY
25954: LIST
25955: LIST
25956: LIST
25957: IN
25958: IFFALSE 25979
// points := [ 40 , 15 , 5 ] ;
25960: LD_ADDR_VAR 0 9
25964: PUSH
25965: LD_INT 40
25967: PUSH
25968: LD_INT 15
25970: PUSH
25971: LD_INT 5
25973: PUSH
25974: EMPTY
25975: LIST
25976: LIST
25977: LIST
25978: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
25979: LD_VAR 0 6
25983: PPUSH
25984: CALL_OW 264
25988: PUSH
25989: LD_INT 3
25991: PUSH
25992: LD_INT 23
25994: PUSH
25995: EMPTY
25996: LIST
25997: LIST
25998: IN
25999: IFFALSE 26020
// points := [ 7 , 25 , 8 ] ;
26001: LD_ADDR_VAR 0 9
26005: PUSH
26006: LD_INT 7
26008: PUSH
26009: LD_INT 25
26011: PUSH
26012: LD_INT 8
26014: PUSH
26015: EMPTY
26016: LIST
26017: LIST
26018: LIST
26019: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
26020: LD_VAR 0 6
26024: PPUSH
26025: CALL_OW 264
26029: PUSH
26030: LD_INT 5
26032: PUSH
26033: LD_INT 27
26035: PUSH
26036: LD_INT 44
26038: PUSH
26039: EMPTY
26040: LIST
26041: LIST
26042: LIST
26043: IN
26044: IFFALSE 26065
// points := [ 14 , 50 , 16 ] ;
26046: LD_ADDR_VAR 0 9
26050: PUSH
26051: LD_INT 14
26053: PUSH
26054: LD_INT 50
26056: PUSH
26057: LD_INT 16
26059: PUSH
26060: EMPTY
26061: LIST
26062: LIST
26063: LIST
26064: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
26065: LD_VAR 0 6
26069: PPUSH
26070: CALL_OW 264
26074: PUSH
26075: LD_INT 6
26077: PUSH
26078: LD_INT 46
26080: PUSH
26081: EMPTY
26082: LIST
26083: LIST
26084: IN
26085: IFFALSE 26106
// points := [ 32 , 120 , 70 ] ;
26087: LD_ADDR_VAR 0 9
26091: PUSH
26092: LD_INT 32
26094: PUSH
26095: LD_INT 120
26097: PUSH
26098: LD_INT 70
26100: PUSH
26101: EMPTY
26102: LIST
26103: LIST
26104: LIST
26105: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher , ar_mortar ] then
26106: LD_VAR 0 6
26110: PPUSH
26111: CALL_OW 264
26115: PUSH
26116: LD_INT 7
26118: PUSH
26119: LD_INT 28
26121: PUSH
26122: LD_INT 45
26124: PUSH
26125: LD_EXP 162
26129: PUSH
26130: EMPTY
26131: LIST
26132: LIST
26133: LIST
26134: LIST
26135: IN
26136: IFFALSE 26157
// points := [ 35 , 20 , 45 ] ;
26138: LD_ADDR_VAR 0 9
26142: PUSH
26143: LD_INT 35
26145: PUSH
26146: LD_INT 20
26148: PUSH
26149: LD_INT 45
26151: PUSH
26152: EMPTY
26153: LIST
26154: LIST
26155: LIST
26156: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
26157: LD_VAR 0 6
26161: PPUSH
26162: CALL_OW 264
26166: PUSH
26167: LD_INT 47
26169: PUSH
26170: EMPTY
26171: LIST
26172: IN
26173: IFFALSE 26194
// points := [ 67 , 45 , 75 ] ;
26175: LD_ADDR_VAR 0 9
26179: PUSH
26180: LD_INT 67
26182: PUSH
26183: LD_INT 45
26185: PUSH
26186: LD_INT 75
26188: PUSH
26189: EMPTY
26190: LIST
26191: LIST
26192: LIST
26193: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
26194: LD_VAR 0 6
26198: PPUSH
26199: CALL_OW 264
26203: PUSH
26204: LD_INT 26
26206: PUSH
26207: EMPTY
26208: LIST
26209: IN
26210: IFFALSE 26231
// points := [ 120 , 30 , 80 ] ;
26212: LD_ADDR_VAR 0 9
26216: PUSH
26217: LD_INT 120
26219: PUSH
26220: LD_INT 30
26222: PUSH
26223: LD_INT 80
26225: PUSH
26226: EMPTY
26227: LIST
26228: LIST
26229: LIST
26230: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
26231: LD_VAR 0 6
26235: PPUSH
26236: CALL_OW 264
26240: PUSH
26241: LD_INT 22
26243: PUSH
26244: EMPTY
26245: LIST
26246: IN
26247: IFFALSE 26268
// points := [ 40 , 1 , 1 ] ;
26249: LD_ADDR_VAR 0 9
26253: PUSH
26254: LD_INT 40
26256: PUSH
26257: LD_INT 1
26259: PUSH
26260: LD_INT 1
26262: PUSH
26263: EMPTY
26264: LIST
26265: LIST
26266: LIST
26267: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
26268: LD_VAR 0 6
26272: PPUSH
26273: CALL_OW 264
26277: PUSH
26278: LD_INT 29
26280: PUSH
26281: EMPTY
26282: LIST
26283: IN
26284: IFFALSE 26305
// points := [ 70 , 200 , 400 ] ;
26286: LD_ADDR_VAR 0 9
26290: PUSH
26291: LD_INT 70
26293: PUSH
26294: LD_INT 200
26296: PUSH
26297: LD_INT 400
26299: PUSH
26300: EMPTY
26301: LIST
26302: LIST
26303: LIST
26304: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
26305: LD_VAR 0 6
26309: PPUSH
26310: CALL_OW 264
26314: PUSH
26315: LD_INT 14
26317: PUSH
26318: LD_INT 53
26320: PUSH
26321: EMPTY
26322: LIST
26323: LIST
26324: IN
26325: IFFALSE 26346
// points := [ 40 , 10 , 20 ] ;
26327: LD_ADDR_VAR 0 9
26331: PUSH
26332: LD_INT 40
26334: PUSH
26335: LD_INT 10
26337: PUSH
26338: LD_INT 20
26340: PUSH
26341: EMPTY
26342: LIST
26343: LIST
26344: LIST
26345: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
26346: LD_VAR 0 6
26350: PPUSH
26351: CALL_OW 264
26355: PUSH
26356: LD_INT 9
26358: PUSH
26359: EMPTY
26360: LIST
26361: IN
26362: IFFALSE 26383
// points := [ 5 , 70 , 20 ] ;
26364: LD_ADDR_VAR 0 9
26368: PUSH
26369: LD_INT 5
26371: PUSH
26372: LD_INT 70
26374: PUSH
26375: LD_INT 20
26377: PUSH
26378: EMPTY
26379: LIST
26380: LIST
26381: LIST
26382: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
26383: LD_VAR 0 6
26387: PPUSH
26388: CALL_OW 264
26392: PUSH
26393: LD_INT 10
26395: PUSH
26396: EMPTY
26397: LIST
26398: IN
26399: IFFALSE 26420
// points := [ 35 , 110 , 70 ] ;
26401: LD_ADDR_VAR 0 9
26405: PUSH
26406: LD_INT 35
26408: PUSH
26409: LD_INT 110
26411: PUSH
26412: LD_INT 70
26414: PUSH
26415: EMPTY
26416: LIST
26417: LIST
26418: LIST
26419: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
26420: LD_VAR 0 6
26424: PPUSH
26425: CALL_OW 265
26429: PUSH
26430: LD_INT 25
26432: EQUAL
26433: IFFALSE 26454
// points := [ 80 , 65 , 100 ] ;
26435: LD_ADDR_VAR 0 9
26439: PUSH
26440: LD_INT 80
26442: PUSH
26443: LD_INT 65
26445: PUSH
26446: LD_INT 100
26448: PUSH
26449: EMPTY
26450: LIST
26451: LIST
26452: LIST
26453: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
26454: LD_VAR 0 6
26458: PPUSH
26459: CALL_OW 263
26463: PUSH
26464: LD_INT 1
26466: EQUAL
26467: IFFALSE 26502
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
26469: LD_ADDR_VAR 0 10
26473: PUSH
26474: LD_VAR 0 10
26478: PUSH
26479: LD_VAR 0 6
26483: PPUSH
26484: CALL_OW 311
26488: PPUSH
26489: LD_INT 3
26491: PPUSH
26492: CALL_OW 259
26496: PUSH
26497: LD_INT 4
26499: MUL
26500: MUL
26501: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
26502: LD_VAR 0 6
26506: PPUSH
26507: CALL_OW 263
26511: PUSH
26512: LD_INT 2
26514: EQUAL
26515: IFFALSE 26566
// begin j := IsControledBy ( i ) ;
26517: LD_ADDR_VAR 0 7
26521: PUSH
26522: LD_VAR 0 6
26526: PPUSH
26527: CALL_OW 312
26531: ST_TO_ADDR
// if j then
26532: LD_VAR 0 7
26536: IFFALSE 26566
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
26538: LD_ADDR_VAR 0 10
26542: PUSH
26543: LD_VAR 0 10
26547: PUSH
26548: LD_VAR 0 7
26552: PPUSH
26553: LD_INT 3
26555: PPUSH
26556: CALL_OW 259
26560: PUSH
26561: LD_INT 3
26563: MUL
26564: MUL
26565: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
26566: LD_VAR 0 6
26570: PPUSH
26571: CALL_OW 264
26575: PUSH
26576: LD_INT 5
26578: PUSH
26579: LD_INT 6
26581: PUSH
26582: LD_INT 46
26584: PUSH
26585: LD_INT 44
26587: PUSH
26588: LD_INT 47
26590: PUSH
26591: LD_INT 45
26593: PUSH
26594: LD_INT 28
26596: PUSH
26597: LD_INT 7
26599: PUSH
26600: LD_INT 27
26602: PUSH
26603: LD_INT 29
26605: PUSH
26606: EMPTY
26607: LIST
26608: LIST
26609: LIST
26610: LIST
26611: LIST
26612: LIST
26613: LIST
26614: LIST
26615: LIST
26616: LIST
26617: IN
26618: PUSH
26619: LD_VAR 0 1
26623: PPUSH
26624: LD_INT 52
26626: PPUSH
26627: CALL_OW 321
26631: PUSH
26632: LD_INT 2
26634: EQUAL
26635: AND
26636: IFFALSE 26653
// bpoints := bpoints * 1.2 ;
26638: LD_ADDR_VAR 0 10
26642: PUSH
26643: LD_VAR 0 10
26647: PUSH
26648: LD_REAL  1.20000000000000E+0000
26651: MUL
26652: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
26653: LD_VAR 0 6
26657: PPUSH
26658: CALL_OW 264
26662: PUSH
26663: LD_INT 6
26665: PUSH
26666: LD_INT 46
26668: PUSH
26669: LD_INT 47
26671: PUSH
26672: EMPTY
26673: LIST
26674: LIST
26675: LIST
26676: IN
26677: IFFALSE 26694
// bpoints := bpoints * 1.2 ;
26679: LD_ADDR_VAR 0 10
26683: PUSH
26684: LD_VAR 0 10
26688: PUSH
26689: LD_REAL  1.20000000000000E+0000
26692: MUL
26693: ST_TO_ADDR
// end ; unit_building :
26694: GO 26708
26696: LD_INT 3
26698: DOUBLE
26699: EQUAL
26700: IFTRUE 26704
26702: GO 26707
26704: POP
// ; end ;
26705: GO 26708
26707: POP
// for j = 1 to 3 do
26708: LD_ADDR_VAR 0 7
26712: PUSH
26713: DOUBLE
26714: LD_INT 1
26716: DEC
26717: ST_TO_ADDR
26718: LD_INT 3
26720: PUSH
26721: FOR_TO
26722: IFFALSE 26775
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
26724: LD_ADDR_VAR 0 5
26728: PUSH
26729: LD_VAR 0 5
26733: PPUSH
26734: LD_VAR 0 7
26738: PPUSH
26739: LD_VAR 0 5
26743: PUSH
26744: LD_VAR 0 7
26748: ARRAY
26749: PUSH
26750: LD_VAR 0 9
26754: PUSH
26755: LD_VAR 0 7
26759: ARRAY
26760: PUSH
26761: LD_VAR 0 10
26765: MUL
26766: PLUS
26767: PPUSH
26768: CALL_OW 1
26772: ST_TO_ADDR
26773: GO 26721
26775: POP
26776: POP
// end ;
26777: GO 25254
26779: POP
26780: POP
// result := Replace ( result , 4 , tmp ) ;
26781: LD_ADDR_VAR 0 5
26785: PUSH
26786: LD_VAR 0 5
26790: PPUSH
26791: LD_INT 4
26793: PPUSH
26794: LD_VAR 0 8
26798: PPUSH
26799: CALL_OW 1
26803: ST_TO_ADDR
// end ;
26804: LD_VAR 0 5
26808: RET
// export function DangerAtRange ( unit , range ) ; begin
26809: LD_INT 0
26811: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
26812: LD_ADDR_VAR 0 3
26816: PUSH
26817: LD_VAR 0 1
26821: PPUSH
26822: CALL_OW 255
26826: PPUSH
26827: LD_VAR 0 1
26831: PPUSH
26832: CALL_OW 250
26836: PPUSH
26837: LD_VAR 0 1
26841: PPUSH
26842: CALL_OW 251
26846: PPUSH
26847: LD_VAR 0 2
26851: PPUSH
26852: CALL 25106 0 4
26856: ST_TO_ADDR
// end ;
26857: LD_VAR 0 3
26861: RET
// export function DangerInArea ( side , area ) ; begin
26862: LD_INT 0
26864: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
26865: LD_ADDR_VAR 0 3
26869: PUSH
26870: LD_VAR 0 2
26874: PPUSH
26875: LD_INT 81
26877: PUSH
26878: LD_VAR 0 1
26882: PUSH
26883: EMPTY
26884: LIST
26885: LIST
26886: PPUSH
26887: CALL_OW 70
26891: ST_TO_ADDR
// end ;
26892: LD_VAR 0 3
26896: RET
// export function IsExtension ( b ) ; begin
26897: LD_INT 0
26899: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
26900: LD_ADDR_VAR 0 2
26904: PUSH
26905: LD_VAR 0 1
26909: PUSH
26910: LD_INT 23
26912: PUSH
26913: LD_INT 20
26915: PUSH
26916: LD_INT 22
26918: PUSH
26919: LD_INT 17
26921: PUSH
26922: LD_INT 24
26924: PUSH
26925: LD_INT 21
26927: PUSH
26928: LD_INT 19
26930: PUSH
26931: LD_INT 16
26933: PUSH
26934: LD_INT 25
26936: PUSH
26937: LD_INT 18
26939: PUSH
26940: EMPTY
26941: LIST
26942: LIST
26943: LIST
26944: LIST
26945: LIST
26946: LIST
26947: LIST
26948: LIST
26949: LIST
26950: LIST
26951: IN
26952: ST_TO_ADDR
// end ;
26953: LD_VAR 0 2
26957: RET
// export function GetBaseBuildings ( base , area , checkLink ) ; var tmp , i ; begin
26958: LD_INT 0
26960: PPUSH
26961: PPUSH
26962: PPUSH
// result := [ ] ;
26963: LD_ADDR_VAR 0 4
26967: PUSH
26968: EMPTY
26969: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
26970: LD_ADDR_VAR 0 5
26974: PUSH
26975: LD_VAR 0 2
26979: PPUSH
26980: LD_INT 21
26982: PUSH
26983: LD_INT 3
26985: PUSH
26986: EMPTY
26987: LIST
26988: LIST
26989: PPUSH
26990: CALL_OW 70
26994: ST_TO_ADDR
// if not tmp then
26995: LD_VAR 0 5
26999: NOT
27000: IFFALSE 27004
// exit ;
27002: GO 27068
// if checkLink then
27004: LD_VAR 0 3
27008: IFFALSE 27058
// begin for i in tmp do
27010: LD_ADDR_VAR 0 6
27014: PUSH
27015: LD_VAR 0 5
27019: PUSH
27020: FOR_IN
27021: IFFALSE 27056
// if GetBase ( i ) <> base then
27023: LD_VAR 0 6
27027: PPUSH
27028: CALL_OW 274
27032: PUSH
27033: LD_VAR 0 1
27037: NONEQUAL
27038: IFFALSE 27054
// ComLinkToBase ( base , i ) ;
27040: LD_VAR 0 1
27044: PPUSH
27045: LD_VAR 0 6
27049: PPUSH
27050: CALL_OW 169
27054: GO 27020
27056: POP
27057: POP
// end ; result := tmp ;
27058: LD_ADDR_VAR 0 4
27062: PUSH
27063: LD_VAR 0 5
27067: ST_TO_ADDR
// end ;
27068: LD_VAR 0 4
27072: RET
// export function ComComplete ( units , b ) ; var i ; begin
27073: LD_INT 0
27075: PPUSH
27076: PPUSH
// if not units then
27077: LD_VAR 0 1
27081: NOT
27082: IFFALSE 27086
// exit ;
27084: GO 27176
// for i in units do
27086: LD_ADDR_VAR 0 4
27090: PUSH
27091: LD_VAR 0 1
27095: PUSH
27096: FOR_IN
27097: IFFALSE 27174
// if BuildingStatus ( b ) = bs_build then
27099: LD_VAR 0 2
27103: PPUSH
27104: CALL_OW 461
27108: PUSH
27109: LD_INT 1
27111: EQUAL
27112: IFFALSE 27172
// SetTaskList ( i , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
27114: LD_VAR 0 4
27118: PPUSH
27119: LD_STRING h
27121: PUSH
27122: LD_VAR 0 2
27126: PPUSH
27127: CALL_OW 250
27131: PUSH
27132: LD_VAR 0 2
27136: PPUSH
27137: CALL_OW 251
27141: PUSH
27142: LD_VAR 0 2
27146: PUSH
27147: LD_INT 0
27149: PUSH
27150: LD_INT 0
27152: PUSH
27153: LD_INT 0
27155: PUSH
27156: EMPTY
27157: LIST
27158: LIST
27159: LIST
27160: LIST
27161: LIST
27162: LIST
27163: LIST
27164: PUSH
27165: EMPTY
27166: LIST
27167: PPUSH
27168: CALL_OW 446
27172: GO 27096
27174: POP
27175: POP
// end ;
27176: LD_VAR 0 3
27180: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
27181: LD_INT 0
27183: PPUSH
27184: PPUSH
27185: PPUSH
27186: PPUSH
27187: PPUSH
27188: PPUSH
// if not vehicle or GetControl ( vehicle ) <> control_remote then
27189: LD_VAR 0 1
27193: NOT
27194: PUSH
27195: LD_VAR 0 1
27199: PPUSH
27200: CALL_OW 263
27204: PUSH
27205: LD_INT 2
27207: NONEQUAL
27208: OR
27209: IFFALSE 27213
// exit ;
27211: GO 27529
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
27213: LD_ADDR_VAR 0 6
27217: PUSH
27218: LD_INT 22
27220: PUSH
27221: LD_VAR 0 1
27225: PPUSH
27226: CALL_OW 255
27230: PUSH
27231: EMPTY
27232: LIST
27233: LIST
27234: PUSH
27235: LD_INT 2
27237: PUSH
27238: LD_INT 30
27240: PUSH
27241: LD_INT 36
27243: PUSH
27244: EMPTY
27245: LIST
27246: LIST
27247: PUSH
27248: LD_INT 34
27250: PUSH
27251: LD_INT 31
27253: PUSH
27254: EMPTY
27255: LIST
27256: LIST
27257: PUSH
27258: EMPTY
27259: LIST
27260: LIST
27261: LIST
27262: PUSH
27263: EMPTY
27264: LIST
27265: LIST
27266: PPUSH
27267: CALL_OW 69
27271: ST_TO_ADDR
// if not tmp then
27272: LD_VAR 0 6
27276: NOT
27277: IFFALSE 27281
// exit ;
27279: GO 27529
// result := [ ] ;
27281: LD_ADDR_VAR 0 2
27285: PUSH
27286: EMPTY
27287: ST_TO_ADDR
// for i in tmp do
27288: LD_ADDR_VAR 0 3
27292: PUSH
27293: LD_VAR 0 6
27297: PUSH
27298: FOR_IN
27299: IFFALSE 27370
// begin t := UnitsInside ( i ) ;
27301: LD_ADDR_VAR 0 4
27305: PUSH
27306: LD_VAR 0 3
27310: PPUSH
27311: CALL_OW 313
27315: ST_TO_ADDR
// if t then
27316: LD_VAR 0 4
27320: IFFALSE 27368
// for j in t do
27322: LD_ADDR_VAR 0 7
27326: PUSH
27327: LD_VAR 0 4
27331: PUSH
27332: FOR_IN
27333: IFFALSE 27366
// result := Replace ( result , result + 1 , j ) ;
27335: LD_ADDR_VAR 0 2
27339: PUSH
27340: LD_VAR 0 2
27344: PPUSH
27345: LD_VAR 0 2
27349: PUSH
27350: LD_INT 1
27352: PLUS
27353: PPUSH
27354: LD_VAR 0 7
27358: PPUSH
27359: CALL_OW 1
27363: ST_TO_ADDR
27364: GO 27332
27366: POP
27367: POP
// end ;
27368: GO 27298
27370: POP
27371: POP
// if not result then
27372: LD_VAR 0 2
27376: NOT
27377: IFFALSE 27381
// exit ;
27379: GO 27529
// mech := result [ 1 ] ;
27381: LD_ADDR_VAR 0 5
27385: PUSH
27386: LD_VAR 0 2
27390: PUSH
27391: LD_INT 1
27393: ARRAY
27394: ST_TO_ADDR
// if result > 1 then
27395: LD_VAR 0 2
27399: PUSH
27400: LD_INT 1
27402: GREATER
27403: IFFALSE 27515
// begin for i = 2 to result do
27405: LD_ADDR_VAR 0 3
27409: PUSH
27410: DOUBLE
27411: LD_INT 2
27413: DEC
27414: ST_TO_ADDR
27415: LD_VAR 0 2
27419: PUSH
27420: FOR_TO
27421: IFFALSE 27513
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
27423: LD_ADDR_VAR 0 4
27427: PUSH
27428: LD_VAR 0 2
27432: PUSH
27433: LD_VAR 0 3
27437: ARRAY
27438: PPUSH
27439: LD_INT 3
27441: PPUSH
27442: CALL_OW 259
27446: PUSH
27447: LD_VAR 0 2
27451: PUSH
27452: LD_VAR 0 3
27456: ARRAY
27457: PPUSH
27458: CALL_OW 432
27462: MINUS
27463: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
27464: LD_VAR 0 4
27468: PUSH
27469: LD_VAR 0 5
27473: PPUSH
27474: LD_INT 3
27476: PPUSH
27477: CALL_OW 259
27481: PUSH
27482: LD_VAR 0 5
27486: PPUSH
27487: CALL_OW 432
27491: MINUS
27492: GREATEREQUAL
27493: IFFALSE 27511
// mech := result [ i ] ;
27495: LD_ADDR_VAR 0 5
27499: PUSH
27500: LD_VAR 0 2
27504: PUSH
27505: LD_VAR 0 3
27509: ARRAY
27510: ST_TO_ADDR
// end ;
27511: GO 27420
27513: POP
27514: POP
// end ; ComLinkTo ( vehicle , mech ) ;
27515: LD_VAR 0 1
27519: PPUSH
27520: LD_VAR 0 5
27524: PPUSH
27525: CALL_OW 135
// end ;
27529: LD_VAR 0 2
27533: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
27534: LD_INT 0
27536: PPUSH
27537: PPUSH
27538: PPUSH
27539: PPUSH
27540: PPUSH
27541: PPUSH
27542: PPUSH
27543: PPUSH
27544: PPUSH
27545: PPUSH
27546: PPUSH
27547: PPUSH
27548: PPUSH
// result := [ ] ;
27549: LD_ADDR_VAR 0 7
27553: PUSH
27554: EMPTY
27555: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
27556: LD_VAR 0 1
27560: PPUSH
27561: CALL_OW 266
27565: PUSH
27566: LD_INT 0
27568: PUSH
27569: LD_INT 1
27571: PUSH
27572: EMPTY
27573: LIST
27574: LIST
27575: IN
27576: NOT
27577: IFFALSE 27581
// exit ;
27579: GO 29215
// if name then
27581: LD_VAR 0 3
27585: IFFALSE 27601
// SetBName ( base_dep , name ) ;
27587: LD_VAR 0 1
27591: PPUSH
27592: LD_VAR 0 3
27596: PPUSH
27597: CALL_OW 500
// base := GetBase ( base_dep ) ;
27601: LD_ADDR_VAR 0 15
27605: PUSH
27606: LD_VAR 0 1
27610: PPUSH
27611: CALL_OW 274
27615: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
27616: LD_ADDR_VAR 0 16
27620: PUSH
27621: LD_VAR 0 1
27625: PPUSH
27626: CALL_OW 255
27630: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
27631: LD_ADDR_VAR 0 17
27635: PUSH
27636: LD_VAR 0 1
27640: PPUSH
27641: CALL_OW 248
27645: ST_TO_ADDR
// if sources then
27646: LD_VAR 0 5
27650: IFFALSE 27697
// for i = 1 to 3 do
27652: LD_ADDR_VAR 0 8
27656: PUSH
27657: DOUBLE
27658: LD_INT 1
27660: DEC
27661: ST_TO_ADDR
27662: LD_INT 3
27664: PUSH
27665: FOR_TO
27666: IFFALSE 27695
// AddResourceType ( base , i , sources [ i ] ) ;
27668: LD_VAR 0 15
27672: PPUSH
27673: LD_VAR 0 8
27677: PPUSH
27678: LD_VAR 0 5
27682: PUSH
27683: LD_VAR 0 8
27687: ARRAY
27688: PPUSH
27689: CALL_OW 276
27693: GO 27665
27695: POP
27696: POP
// buildings := GetBaseBuildings ( base , area , true ) ;
27697: LD_ADDR_VAR 0 18
27701: PUSH
27702: LD_VAR 0 15
27706: PPUSH
27707: LD_VAR 0 2
27711: PPUSH
27712: LD_INT 1
27714: PPUSH
27715: CALL 26958 0 3
27719: ST_TO_ADDR
// InitHc ;
27720: CALL_OW 19
// InitUc ;
27724: CALL_OW 18
// uc_side := side ;
27728: LD_ADDR_OWVAR 20
27732: PUSH
27733: LD_VAR 0 16
27737: ST_TO_ADDR
// uc_nation := nation ;
27738: LD_ADDR_OWVAR 21
27742: PUSH
27743: LD_VAR 0 17
27747: ST_TO_ADDR
// if buildings then
27748: LD_VAR 0 18
27752: IFFALSE 29074
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
27754: LD_ADDR_VAR 0 19
27758: PUSH
27759: LD_VAR 0 18
27763: PPUSH
27764: LD_INT 2
27766: PUSH
27767: LD_INT 30
27769: PUSH
27770: LD_INT 29
27772: PUSH
27773: EMPTY
27774: LIST
27775: LIST
27776: PUSH
27777: LD_INT 30
27779: PUSH
27780: LD_INT 30
27782: PUSH
27783: EMPTY
27784: LIST
27785: LIST
27786: PUSH
27787: EMPTY
27788: LIST
27789: LIST
27790: LIST
27791: PPUSH
27792: CALL_OW 72
27796: ST_TO_ADDR
// if tmp then
27797: LD_VAR 0 19
27801: IFFALSE 27849
// for i in tmp do
27803: LD_ADDR_VAR 0 8
27807: PUSH
27808: LD_VAR 0 19
27812: PUSH
27813: FOR_IN
27814: IFFALSE 27847
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
27816: LD_VAR 0 8
27820: PPUSH
27821: CALL_OW 250
27825: PPUSH
27826: LD_VAR 0 8
27830: PPUSH
27831: CALL_OW 251
27835: PPUSH
27836: LD_VAR 0 16
27840: PPUSH
27841: CALL_OW 441
27845: GO 27813
27847: POP
27848: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
27849: LD_VAR 0 18
27853: PPUSH
27854: LD_INT 2
27856: PUSH
27857: LD_INT 30
27859: PUSH
27860: LD_INT 32
27862: PUSH
27863: EMPTY
27864: LIST
27865: LIST
27866: PUSH
27867: LD_INT 30
27869: PUSH
27870: LD_INT 33
27872: PUSH
27873: EMPTY
27874: LIST
27875: LIST
27876: PUSH
27877: EMPTY
27878: LIST
27879: LIST
27880: LIST
27881: PPUSH
27882: CALL_OW 72
27886: IFFALSE 27974
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
27888: LD_ADDR_VAR 0 8
27892: PUSH
27893: LD_VAR 0 18
27897: PPUSH
27898: LD_INT 2
27900: PUSH
27901: LD_INT 30
27903: PUSH
27904: LD_INT 32
27906: PUSH
27907: EMPTY
27908: LIST
27909: LIST
27910: PUSH
27911: LD_INT 30
27913: PUSH
27914: LD_INT 33
27916: PUSH
27917: EMPTY
27918: LIST
27919: LIST
27920: PUSH
27921: EMPTY
27922: LIST
27923: LIST
27924: LIST
27925: PPUSH
27926: CALL_OW 72
27930: PUSH
27931: FOR_IN
27932: IFFALSE 27972
// begin if not GetBWeapon ( i ) then
27934: LD_VAR 0 8
27938: PPUSH
27939: CALL_OW 269
27943: NOT
27944: IFFALSE 27970
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
27946: LD_VAR 0 8
27950: PPUSH
27951: LD_VAR 0 8
27955: PPUSH
27956: LD_VAR 0 2
27960: PPUSH
27961: CALL 29220 0 2
27965: PPUSH
27966: CALL_OW 431
// end ;
27970: GO 27931
27972: POP
27973: POP
// end ; for i = 1 to personel do
27974: LD_ADDR_VAR 0 8
27978: PUSH
27979: DOUBLE
27980: LD_INT 1
27982: DEC
27983: ST_TO_ADDR
27984: LD_VAR 0 6
27988: PUSH
27989: FOR_TO
27990: IFFALSE 29054
// begin if i > 4 then
27992: LD_VAR 0 8
27996: PUSH
27997: LD_INT 4
27999: GREATER
28000: IFFALSE 28004
// break ;
28002: GO 29054
// case i of 1 :
28004: LD_VAR 0 8
28008: PUSH
28009: LD_INT 1
28011: DOUBLE
28012: EQUAL
28013: IFTRUE 28017
28015: GO 28097
28017: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
28018: LD_ADDR_VAR 0 12
28022: PUSH
28023: LD_VAR 0 18
28027: PPUSH
28028: LD_INT 22
28030: PUSH
28031: LD_VAR 0 16
28035: PUSH
28036: EMPTY
28037: LIST
28038: LIST
28039: PUSH
28040: LD_INT 58
28042: PUSH
28043: EMPTY
28044: LIST
28045: PUSH
28046: LD_INT 2
28048: PUSH
28049: LD_INT 30
28051: PUSH
28052: LD_INT 32
28054: PUSH
28055: EMPTY
28056: LIST
28057: LIST
28058: PUSH
28059: LD_INT 30
28061: PUSH
28062: LD_INT 4
28064: PUSH
28065: EMPTY
28066: LIST
28067: LIST
28068: PUSH
28069: LD_INT 30
28071: PUSH
28072: LD_INT 5
28074: PUSH
28075: EMPTY
28076: LIST
28077: LIST
28078: PUSH
28079: EMPTY
28080: LIST
28081: LIST
28082: LIST
28083: LIST
28084: PUSH
28085: EMPTY
28086: LIST
28087: LIST
28088: LIST
28089: PPUSH
28090: CALL_OW 72
28094: ST_TO_ADDR
28095: GO 28319
28097: LD_INT 2
28099: DOUBLE
28100: EQUAL
28101: IFTRUE 28105
28103: GO 28167
28105: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
28106: LD_ADDR_VAR 0 12
28110: PUSH
28111: LD_VAR 0 18
28115: PPUSH
28116: LD_INT 22
28118: PUSH
28119: LD_VAR 0 16
28123: PUSH
28124: EMPTY
28125: LIST
28126: LIST
28127: PUSH
28128: LD_INT 2
28130: PUSH
28131: LD_INT 30
28133: PUSH
28134: LD_INT 0
28136: PUSH
28137: EMPTY
28138: LIST
28139: LIST
28140: PUSH
28141: LD_INT 30
28143: PUSH
28144: LD_INT 1
28146: PUSH
28147: EMPTY
28148: LIST
28149: LIST
28150: PUSH
28151: EMPTY
28152: LIST
28153: LIST
28154: LIST
28155: PUSH
28156: EMPTY
28157: LIST
28158: LIST
28159: PPUSH
28160: CALL_OW 72
28164: ST_TO_ADDR
28165: GO 28319
28167: LD_INT 3
28169: DOUBLE
28170: EQUAL
28171: IFTRUE 28175
28173: GO 28237
28175: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
28176: LD_ADDR_VAR 0 12
28180: PUSH
28181: LD_VAR 0 18
28185: PPUSH
28186: LD_INT 22
28188: PUSH
28189: LD_VAR 0 16
28193: PUSH
28194: EMPTY
28195: LIST
28196: LIST
28197: PUSH
28198: LD_INT 2
28200: PUSH
28201: LD_INT 30
28203: PUSH
28204: LD_INT 2
28206: PUSH
28207: EMPTY
28208: LIST
28209: LIST
28210: PUSH
28211: LD_INT 30
28213: PUSH
28214: LD_INT 3
28216: PUSH
28217: EMPTY
28218: LIST
28219: LIST
28220: PUSH
28221: EMPTY
28222: LIST
28223: LIST
28224: LIST
28225: PUSH
28226: EMPTY
28227: LIST
28228: LIST
28229: PPUSH
28230: CALL_OW 72
28234: ST_TO_ADDR
28235: GO 28319
28237: LD_INT 4
28239: DOUBLE
28240: EQUAL
28241: IFTRUE 28245
28243: GO 28318
28245: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
28246: LD_ADDR_VAR 0 12
28250: PUSH
28251: LD_VAR 0 18
28255: PPUSH
28256: LD_INT 22
28258: PUSH
28259: LD_VAR 0 16
28263: PUSH
28264: EMPTY
28265: LIST
28266: LIST
28267: PUSH
28268: LD_INT 2
28270: PUSH
28271: LD_INT 30
28273: PUSH
28274: LD_INT 6
28276: PUSH
28277: EMPTY
28278: LIST
28279: LIST
28280: PUSH
28281: LD_INT 30
28283: PUSH
28284: LD_INT 7
28286: PUSH
28287: EMPTY
28288: LIST
28289: LIST
28290: PUSH
28291: LD_INT 30
28293: PUSH
28294: LD_INT 8
28296: PUSH
28297: EMPTY
28298: LIST
28299: LIST
28300: PUSH
28301: EMPTY
28302: LIST
28303: LIST
28304: LIST
28305: LIST
28306: PUSH
28307: EMPTY
28308: LIST
28309: LIST
28310: PPUSH
28311: CALL_OW 72
28315: ST_TO_ADDR
28316: GO 28319
28318: POP
// if i = 1 then
28319: LD_VAR 0 8
28323: PUSH
28324: LD_INT 1
28326: EQUAL
28327: IFFALSE 28438
// begin tmp := [ ] ;
28329: LD_ADDR_VAR 0 19
28333: PUSH
28334: EMPTY
28335: ST_TO_ADDR
// for j in f do
28336: LD_ADDR_VAR 0 9
28340: PUSH
28341: LD_VAR 0 12
28345: PUSH
28346: FOR_IN
28347: IFFALSE 28420
// if GetBType ( j ) = b_bunker then
28349: LD_VAR 0 9
28353: PPUSH
28354: CALL_OW 266
28358: PUSH
28359: LD_INT 32
28361: EQUAL
28362: IFFALSE 28389
// tmp := Insert ( tmp , 1 , j ) else
28364: LD_ADDR_VAR 0 19
28368: PUSH
28369: LD_VAR 0 19
28373: PPUSH
28374: LD_INT 1
28376: PPUSH
28377: LD_VAR 0 9
28381: PPUSH
28382: CALL_OW 2
28386: ST_TO_ADDR
28387: GO 28418
// tmp := Insert ( tmp , tmp + 1 , j ) ;
28389: LD_ADDR_VAR 0 19
28393: PUSH
28394: LD_VAR 0 19
28398: PPUSH
28399: LD_VAR 0 19
28403: PUSH
28404: LD_INT 1
28406: PLUS
28407: PPUSH
28408: LD_VAR 0 9
28412: PPUSH
28413: CALL_OW 2
28417: ST_TO_ADDR
28418: GO 28346
28420: POP
28421: POP
// if tmp then
28422: LD_VAR 0 19
28426: IFFALSE 28438
// f := tmp ;
28428: LD_ADDR_VAR 0 12
28432: PUSH
28433: LD_VAR 0 19
28437: ST_TO_ADDR
// end ; x := personel [ i ] ;
28438: LD_ADDR_VAR 0 13
28442: PUSH
28443: LD_VAR 0 6
28447: PUSH
28448: LD_VAR 0 8
28452: ARRAY
28453: ST_TO_ADDR
// if x = - 1 then
28454: LD_VAR 0 13
28458: PUSH
28459: LD_INT 1
28461: NEG
28462: EQUAL
28463: IFFALSE 28672
// begin for j in f do
28465: LD_ADDR_VAR 0 9
28469: PUSH
28470: LD_VAR 0 12
28474: PUSH
28475: FOR_IN
28476: IFFALSE 28668
// repeat InitHc ;
28478: CALL_OW 19
// if GetBType ( j ) = b_barracks then
28482: LD_VAR 0 9
28486: PPUSH
28487: CALL_OW 266
28491: PUSH
28492: LD_INT 5
28494: EQUAL
28495: IFFALSE 28565
// begin if UnitsInside ( j ) < 3 then
28497: LD_VAR 0 9
28501: PPUSH
28502: CALL_OW 313
28506: PUSH
28507: LD_INT 3
28509: LESS
28510: IFFALSE 28546
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
28512: LD_INT 0
28514: PPUSH
28515: LD_INT 5
28517: PUSH
28518: LD_INT 8
28520: PUSH
28521: LD_INT 9
28523: PUSH
28524: EMPTY
28525: LIST
28526: LIST
28527: LIST
28528: PUSH
28529: LD_VAR 0 17
28533: ARRAY
28534: PPUSH
28535: LD_VAR 0 4
28539: PPUSH
28540: CALL_OW 380
28544: GO 28563
// PrepareHuman ( false , i , skill ) ;
28546: LD_INT 0
28548: PPUSH
28549: LD_VAR 0 8
28553: PPUSH
28554: LD_VAR 0 4
28558: PPUSH
28559: CALL_OW 380
// end else
28563: GO 28582
// PrepareHuman ( false , i , skill ) ;
28565: LD_INT 0
28567: PPUSH
28568: LD_VAR 0 8
28572: PPUSH
28573: LD_VAR 0 4
28577: PPUSH
28578: CALL_OW 380
// un := CreateHuman ;
28582: LD_ADDR_VAR 0 14
28586: PUSH
28587: CALL_OW 44
28591: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
28592: LD_ADDR_VAR 0 7
28596: PUSH
28597: LD_VAR 0 7
28601: PPUSH
28602: LD_INT 1
28604: PPUSH
28605: LD_VAR 0 14
28609: PPUSH
28610: CALL_OW 2
28614: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
28615: LD_VAR 0 14
28619: PPUSH
28620: LD_VAR 0 9
28624: PPUSH
28625: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
28629: LD_VAR 0 9
28633: PPUSH
28634: CALL_OW 313
28638: PUSH
28639: LD_INT 6
28641: EQUAL
28642: PUSH
28643: LD_VAR 0 9
28647: PPUSH
28648: CALL_OW 266
28652: PUSH
28653: LD_INT 32
28655: PUSH
28656: LD_INT 31
28658: PUSH
28659: EMPTY
28660: LIST
28661: LIST
28662: IN
28663: OR
28664: IFFALSE 28478
28666: GO 28475
28668: POP
28669: POP
// end else
28670: GO 29052
// for j = 1 to x do
28672: LD_ADDR_VAR 0 9
28676: PUSH
28677: DOUBLE
28678: LD_INT 1
28680: DEC
28681: ST_TO_ADDR
28682: LD_VAR 0 13
28686: PUSH
28687: FOR_TO
28688: IFFALSE 29050
// begin InitHc ;
28690: CALL_OW 19
// if not f then
28694: LD_VAR 0 12
28698: NOT
28699: IFFALSE 28788
// begin PrepareHuman ( false , i , skill ) ;
28701: LD_INT 0
28703: PPUSH
28704: LD_VAR 0 8
28708: PPUSH
28709: LD_VAR 0 4
28713: PPUSH
28714: CALL_OW 380
// un := CreateHuman ;
28718: LD_ADDR_VAR 0 14
28722: PUSH
28723: CALL_OW 44
28727: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
28728: LD_ADDR_VAR 0 7
28732: PUSH
28733: LD_VAR 0 7
28737: PPUSH
28738: LD_INT 1
28740: PPUSH
28741: LD_VAR 0 14
28745: PPUSH
28746: CALL_OW 2
28750: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
28751: LD_VAR 0 14
28755: PPUSH
28756: LD_VAR 0 1
28760: PPUSH
28761: CALL_OW 250
28765: PPUSH
28766: LD_VAR 0 1
28770: PPUSH
28771: CALL_OW 251
28775: PPUSH
28776: LD_INT 10
28778: PPUSH
28779: LD_INT 0
28781: PPUSH
28782: CALL_OW 50
// continue ;
28786: GO 28687
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
28788: LD_VAR 0 12
28792: PUSH
28793: LD_INT 1
28795: ARRAY
28796: PPUSH
28797: CALL_OW 313
28801: PUSH
28802: LD_VAR 0 12
28806: PUSH
28807: LD_INT 1
28809: ARRAY
28810: PPUSH
28811: CALL_OW 266
28815: PUSH
28816: LD_INT 32
28818: PUSH
28819: LD_INT 31
28821: PUSH
28822: EMPTY
28823: LIST
28824: LIST
28825: IN
28826: AND
28827: PUSH
28828: LD_VAR 0 12
28832: PUSH
28833: LD_INT 1
28835: ARRAY
28836: PPUSH
28837: CALL_OW 313
28841: PUSH
28842: LD_INT 6
28844: EQUAL
28845: OR
28846: IFFALSE 28866
// f := Delete ( f , 1 ) ;
28848: LD_ADDR_VAR 0 12
28852: PUSH
28853: LD_VAR 0 12
28857: PPUSH
28858: LD_INT 1
28860: PPUSH
28861: CALL_OW 3
28865: ST_TO_ADDR
// if not f then
28866: LD_VAR 0 12
28870: NOT
28871: IFFALSE 28889
// begin x := x + 2 ;
28873: LD_ADDR_VAR 0 13
28877: PUSH
28878: LD_VAR 0 13
28882: PUSH
28883: LD_INT 2
28885: PLUS
28886: ST_TO_ADDR
// continue ;
28887: GO 28687
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
28889: LD_VAR 0 12
28893: PUSH
28894: LD_INT 1
28896: ARRAY
28897: PPUSH
28898: CALL_OW 266
28902: PUSH
28903: LD_INT 5
28905: EQUAL
28906: IFFALSE 28980
// begin if UnitsInside ( f [ 1 ] ) < 3 then
28908: LD_VAR 0 12
28912: PUSH
28913: LD_INT 1
28915: ARRAY
28916: PPUSH
28917: CALL_OW 313
28921: PUSH
28922: LD_INT 3
28924: LESS
28925: IFFALSE 28961
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
28927: LD_INT 0
28929: PPUSH
28930: LD_INT 5
28932: PUSH
28933: LD_INT 8
28935: PUSH
28936: LD_INT 9
28938: PUSH
28939: EMPTY
28940: LIST
28941: LIST
28942: LIST
28943: PUSH
28944: LD_VAR 0 17
28948: ARRAY
28949: PPUSH
28950: LD_VAR 0 4
28954: PPUSH
28955: CALL_OW 380
28959: GO 28978
// PrepareHuman ( false , i , skill ) ;
28961: LD_INT 0
28963: PPUSH
28964: LD_VAR 0 8
28968: PPUSH
28969: LD_VAR 0 4
28973: PPUSH
28974: CALL_OW 380
// end else
28978: GO 28997
// PrepareHuman ( false , i , skill ) ;
28980: LD_INT 0
28982: PPUSH
28983: LD_VAR 0 8
28987: PPUSH
28988: LD_VAR 0 4
28992: PPUSH
28993: CALL_OW 380
// un := CreateHuman ;
28997: LD_ADDR_VAR 0 14
29001: PUSH
29002: CALL_OW 44
29006: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
29007: LD_ADDR_VAR 0 7
29011: PUSH
29012: LD_VAR 0 7
29016: PPUSH
29017: LD_INT 1
29019: PPUSH
29020: LD_VAR 0 14
29024: PPUSH
29025: CALL_OW 2
29029: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
29030: LD_VAR 0 14
29034: PPUSH
29035: LD_VAR 0 12
29039: PUSH
29040: LD_INT 1
29042: ARRAY
29043: PPUSH
29044: CALL_OW 52
// end ;
29048: GO 28687
29050: POP
29051: POP
// end ;
29052: GO 27989
29054: POP
29055: POP
// result := result ^ buildings ;
29056: LD_ADDR_VAR 0 7
29060: PUSH
29061: LD_VAR 0 7
29065: PUSH
29066: LD_VAR 0 18
29070: ADD
29071: ST_TO_ADDR
// end else
29072: GO 29215
// begin for i = 1 to personel do
29074: LD_ADDR_VAR 0 8
29078: PUSH
29079: DOUBLE
29080: LD_INT 1
29082: DEC
29083: ST_TO_ADDR
29084: LD_VAR 0 6
29088: PUSH
29089: FOR_TO
29090: IFFALSE 29213
// begin if i > 4 then
29092: LD_VAR 0 8
29096: PUSH
29097: LD_INT 4
29099: GREATER
29100: IFFALSE 29104
// break ;
29102: GO 29213
// x := personel [ i ] ;
29104: LD_ADDR_VAR 0 13
29108: PUSH
29109: LD_VAR 0 6
29113: PUSH
29114: LD_VAR 0 8
29118: ARRAY
29119: ST_TO_ADDR
// if x = - 1 then
29120: LD_VAR 0 13
29124: PUSH
29125: LD_INT 1
29127: NEG
29128: EQUAL
29129: IFFALSE 29133
// continue ;
29131: GO 29089
// PrepareHuman ( false , i , skill ) ;
29133: LD_INT 0
29135: PPUSH
29136: LD_VAR 0 8
29140: PPUSH
29141: LD_VAR 0 4
29145: PPUSH
29146: CALL_OW 380
// un := CreateHuman ;
29150: LD_ADDR_VAR 0 14
29154: PUSH
29155: CALL_OW 44
29159: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
29160: LD_VAR 0 14
29164: PPUSH
29165: LD_VAR 0 1
29169: PPUSH
29170: CALL_OW 250
29174: PPUSH
29175: LD_VAR 0 1
29179: PPUSH
29180: CALL_OW 251
29184: PPUSH
29185: LD_INT 10
29187: PPUSH
29188: LD_INT 0
29190: PPUSH
29191: CALL_OW 50
// result := result ^ un ;
29195: LD_ADDR_VAR 0 7
29199: PUSH
29200: LD_VAR 0 7
29204: PUSH
29205: LD_VAR 0 14
29209: ADD
29210: ST_TO_ADDR
// end ;
29211: GO 29089
29213: POP
29214: POP
// end ; end ;
29215: LD_VAR 0 7
29219: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
29220: LD_INT 0
29222: PPUSH
29223: PPUSH
29224: PPUSH
29225: PPUSH
29226: PPUSH
29227: PPUSH
29228: PPUSH
29229: PPUSH
29230: PPUSH
29231: PPUSH
29232: PPUSH
29233: PPUSH
29234: PPUSH
29235: PPUSH
29236: PPUSH
29237: PPUSH
// result := false ;
29238: LD_ADDR_VAR 0 3
29242: PUSH
29243: LD_INT 0
29245: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
29246: LD_VAR 0 1
29250: NOT
29251: PUSH
29252: LD_VAR 0 1
29256: PPUSH
29257: CALL_OW 266
29261: PUSH
29262: LD_INT 32
29264: PUSH
29265: LD_INT 33
29267: PUSH
29268: EMPTY
29269: LIST
29270: LIST
29271: IN
29272: NOT
29273: OR
29274: IFFALSE 29278
// exit ;
29276: GO 30387
// nat := GetNation ( tower ) ;
29278: LD_ADDR_VAR 0 12
29282: PUSH
29283: LD_VAR 0 1
29287: PPUSH
29288: CALL_OW 248
29292: ST_TO_ADDR
// side := GetSide ( tower ) ;
29293: LD_ADDR_VAR 0 16
29297: PUSH
29298: LD_VAR 0 1
29302: PPUSH
29303: CALL_OW 255
29307: ST_TO_ADDR
// x := GetX ( tower ) ;
29308: LD_ADDR_VAR 0 10
29312: PUSH
29313: LD_VAR 0 1
29317: PPUSH
29318: CALL_OW 250
29322: ST_TO_ADDR
// y := GetY ( tower ) ;
29323: LD_ADDR_VAR 0 11
29327: PUSH
29328: LD_VAR 0 1
29332: PPUSH
29333: CALL_OW 251
29337: ST_TO_ADDR
// if not x or not y then
29338: LD_VAR 0 10
29342: NOT
29343: PUSH
29344: LD_VAR 0 11
29348: NOT
29349: OR
29350: IFFALSE 29354
// exit ;
29352: GO 30387
// weapon := 0 ;
29354: LD_ADDR_VAR 0 18
29358: PUSH
29359: LD_INT 0
29361: ST_TO_ADDR
// fac_list := [ ] ;
29362: LD_ADDR_VAR 0 17
29366: PUSH
29367: EMPTY
29368: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area , false ) , [ f_btype , b_factory ] ) ;
29369: LD_ADDR_VAR 0 6
29373: PUSH
29374: LD_VAR 0 1
29378: PPUSH
29379: CALL_OW 274
29383: PPUSH
29384: LD_VAR 0 2
29388: PPUSH
29389: LD_INT 0
29391: PPUSH
29392: CALL 26958 0 3
29396: PPUSH
29397: LD_INT 30
29399: PUSH
29400: LD_INT 3
29402: PUSH
29403: EMPTY
29404: LIST
29405: LIST
29406: PPUSH
29407: CALL_OW 72
29411: ST_TO_ADDR
// if not factories then
29412: LD_VAR 0 6
29416: NOT
29417: IFFALSE 29421
// exit ;
29419: GO 30387
// for i in factories do
29421: LD_ADDR_VAR 0 8
29425: PUSH
29426: LD_VAR 0 6
29430: PUSH
29431: FOR_IN
29432: IFFALSE 29457
// fac_list := fac_list union AvailableWeaponList ( i ) ;
29434: LD_ADDR_VAR 0 17
29438: PUSH
29439: LD_VAR 0 17
29443: PUSH
29444: LD_VAR 0 8
29448: PPUSH
29449: CALL_OW 478
29453: UNION
29454: ST_TO_ADDR
29455: GO 29431
29457: POP
29458: POP
// if not fac_list then
29459: LD_VAR 0 17
29463: NOT
29464: IFFALSE 29468
// exit ;
29466: GO 30387
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
29468: LD_ADDR_VAR 0 5
29472: PUSH
29473: LD_INT 4
29475: PUSH
29476: LD_INT 5
29478: PUSH
29479: LD_INT 9
29481: PUSH
29482: LD_INT 10
29484: PUSH
29485: LD_INT 6
29487: PUSH
29488: LD_INT 7
29490: PUSH
29491: LD_INT 11
29493: PUSH
29494: EMPTY
29495: LIST
29496: LIST
29497: LIST
29498: LIST
29499: LIST
29500: LIST
29501: LIST
29502: PUSH
29503: LD_INT 27
29505: PUSH
29506: LD_INT 28
29508: PUSH
29509: LD_INT 26
29511: PUSH
29512: LD_INT 30
29514: PUSH
29515: EMPTY
29516: LIST
29517: LIST
29518: LIST
29519: LIST
29520: PUSH
29521: LD_INT 43
29523: PUSH
29524: LD_INT 44
29526: PUSH
29527: LD_INT 46
29529: PUSH
29530: LD_INT 45
29532: PUSH
29533: LD_INT 47
29535: PUSH
29536: LD_INT 49
29538: PUSH
29539: EMPTY
29540: LIST
29541: LIST
29542: LIST
29543: LIST
29544: LIST
29545: LIST
29546: PUSH
29547: EMPTY
29548: LIST
29549: LIST
29550: LIST
29551: PUSH
29552: LD_VAR 0 12
29556: ARRAY
29557: ST_TO_ADDR
// list := list isect fac_list ;
29558: LD_ADDR_VAR 0 5
29562: PUSH
29563: LD_VAR 0 5
29567: PUSH
29568: LD_VAR 0 17
29572: ISECT
29573: ST_TO_ADDR
// if not list then
29574: LD_VAR 0 5
29578: NOT
29579: IFFALSE 29583
// exit ;
29581: GO 30387
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
29583: LD_VAR 0 12
29587: PUSH
29588: LD_INT 3
29590: EQUAL
29591: PUSH
29592: LD_INT 49
29594: PUSH
29595: LD_VAR 0 5
29599: IN
29600: AND
29601: PUSH
29602: LD_INT 31
29604: PPUSH
29605: LD_VAR 0 16
29609: PPUSH
29610: CALL_OW 321
29614: PUSH
29615: LD_INT 2
29617: EQUAL
29618: AND
29619: IFFALSE 29679
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
29621: LD_INT 22
29623: PUSH
29624: LD_VAR 0 16
29628: PUSH
29629: EMPTY
29630: LIST
29631: LIST
29632: PUSH
29633: LD_INT 35
29635: PUSH
29636: LD_INT 49
29638: PUSH
29639: EMPTY
29640: LIST
29641: LIST
29642: PUSH
29643: LD_INT 91
29645: PUSH
29646: LD_VAR 0 1
29650: PUSH
29651: LD_INT 10
29653: PUSH
29654: EMPTY
29655: LIST
29656: LIST
29657: LIST
29658: PUSH
29659: EMPTY
29660: LIST
29661: LIST
29662: LIST
29663: PPUSH
29664: CALL_OW 69
29668: NOT
29669: IFFALSE 29679
// weapon := ru_time_lapser ;
29671: LD_ADDR_VAR 0 18
29675: PUSH
29676: LD_INT 49
29678: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
29679: LD_VAR 0 12
29683: PUSH
29684: LD_INT 1
29686: PUSH
29687: LD_INT 2
29689: PUSH
29690: EMPTY
29691: LIST
29692: LIST
29693: IN
29694: PUSH
29695: LD_INT 11
29697: PUSH
29698: LD_VAR 0 5
29702: IN
29703: PUSH
29704: LD_INT 30
29706: PUSH
29707: LD_VAR 0 5
29711: IN
29712: OR
29713: AND
29714: PUSH
29715: LD_INT 6
29717: PPUSH
29718: LD_VAR 0 16
29722: PPUSH
29723: CALL_OW 321
29727: PUSH
29728: LD_INT 2
29730: EQUAL
29731: AND
29732: IFFALSE 29897
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
29734: LD_INT 22
29736: PUSH
29737: LD_VAR 0 16
29741: PUSH
29742: EMPTY
29743: LIST
29744: LIST
29745: PUSH
29746: LD_INT 2
29748: PUSH
29749: LD_INT 35
29751: PUSH
29752: LD_INT 11
29754: PUSH
29755: EMPTY
29756: LIST
29757: LIST
29758: PUSH
29759: LD_INT 35
29761: PUSH
29762: LD_INT 30
29764: PUSH
29765: EMPTY
29766: LIST
29767: LIST
29768: PUSH
29769: EMPTY
29770: LIST
29771: LIST
29772: LIST
29773: PUSH
29774: LD_INT 91
29776: PUSH
29777: LD_VAR 0 1
29781: PUSH
29782: LD_INT 18
29784: PUSH
29785: EMPTY
29786: LIST
29787: LIST
29788: LIST
29789: PUSH
29790: EMPTY
29791: LIST
29792: LIST
29793: LIST
29794: PPUSH
29795: CALL_OW 69
29799: NOT
29800: PUSH
29801: LD_INT 22
29803: PUSH
29804: LD_VAR 0 16
29808: PUSH
29809: EMPTY
29810: LIST
29811: LIST
29812: PUSH
29813: LD_INT 2
29815: PUSH
29816: LD_INT 30
29818: PUSH
29819: LD_INT 32
29821: PUSH
29822: EMPTY
29823: LIST
29824: LIST
29825: PUSH
29826: LD_INT 30
29828: PUSH
29829: LD_INT 33
29831: PUSH
29832: EMPTY
29833: LIST
29834: LIST
29835: PUSH
29836: EMPTY
29837: LIST
29838: LIST
29839: LIST
29840: PUSH
29841: LD_INT 91
29843: PUSH
29844: LD_VAR 0 1
29848: PUSH
29849: LD_INT 12
29851: PUSH
29852: EMPTY
29853: LIST
29854: LIST
29855: LIST
29856: PUSH
29857: EMPTY
29858: LIST
29859: LIST
29860: LIST
29861: PUSH
29862: EMPTY
29863: LIST
29864: PPUSH
29865: CALL_OW 69
29869: PUSH
29870: LD_INT 2
29872: GREATER
29873: AND
29874: IFFALSE 29897
// weapon := [ us_radar , ar_radar ] [ nat ] ;
29876: LD_ADDR_VAR 0 18
29880: PUSH
29881: LD_INT 11
29883: PUSH
29884: LD_INT 30
29886: PUSH
29887: EMPTY
29888: LIST
29889: LIST
29890: PUSH
29891: LD_VAR 0 12
29895: ARRAY
29896: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
29897: LD_VAR 0 18
29901: NOT
29902: PUSH
29903: LD_INT 40
29905: PPUSH
29906: LD_VAR 0 16
29910: PPUSH
29911: CALL_OW 321
29915: PUSH
29916: LD_INT 2
29918: EQUAL
29919: AND
29920: PUSH
29921: LD_INT 7
29923: PUSH
29924: LD_VAR 0 5
29928: IN
29929: PUSH
29930: LD_INT 28
29932: PUSH
29933: LD_VAR 0 5
29937: IN
29938: OR
29939: PUSH
29940: LD_INT 45
29942: PUSH
29943: LD_VAR 0 5
29947: IN
29948: OR
29949: AND
29950: IFFALSE 30204
// begin hex := GetHexInfo ( x , y ) ;
29952: LD_ADDR_VAR 0 4
29956: PUSH
29957: LD_VAR 0 10
29961: PPUSH
29962: LD_VAR 0 11
29966: PPUSH
29967: CALL_OW 546
29971: ST_TO_ADDR
// if hex [ 1 ] then
29972: LD_VAR 0 4
29976: PUSH
29977: LD_INT 1
29979: ARRAY
29980: IFFALSE 29984
// exit ;
29982: GO 30387
// height := hex [ 2 ] ;
29984: LD_ADDR_VAR 0 15
29988: PUSH
29989: LD_VAR 0 4
29993: PUSH
29994: LD_INT 2
29996: ARRAY
29997: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
29998: LD_ADDR_VAR 0 14
30002: PUSH
30003: LD_INT 0
30005: PUSH
30006: LD_INT 2
30008: PUSH
30009: LD_INT 3
30011: PUSH
30012: LD_INT 5
30014: PUSH
30015: EMPTY
30016: LIST
30017: LIST
30018: LIST
30019: LIST
30020: ST_TO_ADDR
// for i in tmp do
30021: LD_ADDR_VAR 0 8
30025: PUSH
30026: LD_VAR 0 14
30030: PUSH
30031: FOR_IN
30032: IFFALSE 30202
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
30034: LD_ADDR_VAR 0 9
30038: PUSH
30039: LD_VAR 0 10
30043: PPUSH
30044: LD_VAR 0 8
30048: PPUSH
30049: LD_INT 5
30051: PPUSH
30052: CALL_OW 272
30056: PUSH
30057: LD_VAR 0 11
30061: PPUSH
30062: LD_VAR 0 8
30066: PPUSH
30067: LD_INT 5
30069: PPUSH
30070: CALL_OW 273
30074: PUSH
30075: EMPTY
30076: LIST
30077: LIST
30078: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
30079: LD_VAR 0 9
30083: PUSH
30084: LD_INT 1
30086: ARRAY
30087: PPUSH
30088: LD_VAR 0 9
30092: PUSH
30093: LD_INT 2
30095: ARRAY
30096: PPUSH
30097: CALL_OW 488
30101: IFFALSE 30200
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
30103: LD_ADDR_VAR 0 4
30107: PUSH
30108: LD_VAR 0 9
30112: PUSH
30113: LD_INT 1
30115: ARRAY
30116: PPUSH
30117: LD_VAR 0 9
30121: PUSH
30122: LD_INT 2
30124: ARRAY
30125: PPUSH
30126: CALL_OW 546
30130: ST_TO_ADDR
// if hex [ 1 ] then
30131: LD_VAR 0 4
30135: PUSH
30136: LD_INT 1
30138: ARRAY
30139: IFFALSE 30143
// continue ;
30141: GO 30031
// h := hex [ 2 ] ;
30143: LD_ADDR_VAR 0 13
30147: PUSH
30148: LD_VAR 0 4
30152: PUSH
30153: LD_INT 2
30155: ARRAY
30156: ST_TO_ADDR
// if h + 7 < height then
30157: LD_VAR 0 13
30161: PUSH
30162: LD_INT 7
30164: PLUS
30165: PUSH
30166: LD_VAR 0 15
30170: LESS
30171: IFFALSE 30200
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
30173: LD_ADDR_VAR 0 18
30177: PUSH
30178: LD_INT 7
30180: PUSH
30181: LD_INT 28
30183: PUSH
30184: LD_INT 45
30186: PUSH
30187: EMPTY
30188: LIST
30189: LIST
30190: LIST
30191: PUSH
30192: LD_VAR 0 12
30196: ARRAY
30197: ST_TO_ADDR
// break ;
30198: GO 30202
// end ; end ; end ;
30200: GO 30031
30202: POP
30203: POP
// end ; if not weapon then
30204: LD_VAR 0 18
30208: NOT
30209: IFFALSE 30269
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
30211: LD_ADDR_VAR 0 5
30215: PUSH
30216: LD_VAR 0 5
30220: PUSH
30221: LD_INT 11
30223: PUSH
30224: LD_INT 30
30226: PUSH
30227: LD_INT 49
30229: PUSH
30230: EMPTY
30231: LIST
30232: LIST
30233: LIST
30234: DIFF
30235: ST_TO_ADDR
// if not list then
30236: LD_VAR 0 5
30240: NOT
30241: IFFALSE 30245
// exit ;
30243: GO 30387
// weapon := list [ rand ( 1 , list ) ] ;
30245: LD_ADDR_VAR 0 18
30249: PUSH
30250: LD_VAR 0 5
30254: PUSH
30255: LD_INT 1
30257: PPUSH
30258: LD_VAR 0 5
30262: PPUSH
30263: CALL_OW 12
30267: ARRAY
30268: ST_TO_ADDR
// end ; if weapon then
30269: LD_VAR 0 18
30273: IFFALSE 30387
// begin tmp := CostOfWeapon ( weapon ) ;
30275: LD_ADDR_VAR 0 14
30279: PUSH
30280: LD_VAR 0 18
30284: PPUSH
30285: CALL_OW 451
30289: ST_TO_ADDR
// j := GetBase ( tower ) ;
30290: LD_ADDR_VAR 0 9
30294: PUSH
30295: LD_VAR 0 1
30299: PPUSH
30300: CALL_OW 274
30304: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
30305: LD_VAR 0 9
30309: PPUSH
30310: LD_INT 1
30312: PPUSH
30313: CALL_OW 275
30317: PUSH
30318: LD_VAR 0 14
30322: PUSH
30323: LD_INT 1
30325: ARRAY
30326: GREATEREQUAL
30327: PUSH
30328: LD_VAR 0 9
30332: PPUSH
30333: LD_INT 2
30335: PPUSH
30336: CALL_OW 275
30340: PUSH
30341: LD_VAR 0 14
30345: PUSH
30346: LD_INT 2
30348: ARRAY
30349: GREATEREQUAL
30350: AND
30351: PUSH
30352: LD_VAR 0 9
30356: PPUSH
30357: LD_INT 3
30359: PPUSH
30360: CALL_OW 275
30364: PUSH
30365: LD_VAR 0 14
30369: PUSH
30370: LD_INT 3
30372: ARRAY
30373: GREATEREQUAL
30374: AND
30375: IFFALSE 30387
// result := weapon ;
30377: LD_ADDR_VAR 0 3
30381: PUSH
30382: LD_VAR 0 18
30386: ST_TO_ADDR
// end ; end ;
30387: LD_VAR 0 3
30391: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
30392: LD_INT 0
30394: PPUSH
30395: PPUSH
// result := true ;
30396: LD_ADDR_VAR 0 3
30400: PUSH
30401: LD_INT 1
30403: ST_TO_ADDR
// if array1 = array2 then
30404: LD_VAR 0 1
30408: PUSH
30409: LD_VAR 0 2
30413: EQUAL
30414: IFFALSE 30474
// begin for i = 1 to array1 do
30416: LD_ADDR_VAR 0 4
30420: PUSH
30421: DOUBLE
30422: LD_INT 1
30424: DEC
30425: ST_TO_ADDR
30426: LD_VAR 0 1
30430: PUSH
30431: FOR_TO
30432: IFFALSE 30470
// if array1 [ i ] <> array2 [ i ] then
30434: LD_VAR 0 1
30438: PUSH
30439: LD_VAR 0 4
30443: ARRAY
30444: PUSH
30445: LD_VAR 0 2
30449: PUSH
30450: LD_VAR 0 4
30454: ARRAY
30455: NONEQUAL
30456: IFFALSE 30468
// begin result := false ;
30458: LD_ADDR_VAR 0 3
30462: PUSH
30463: LD_INT 0
30465: ST_TO_ADDR
// break ;
30466: GO 30470
// end ;
30468: GO 30431
30470: POP
30471: POP
// end else
30472: GO 30482
// result := false ;
30474: LD_ADDR_VAR 0 3
30478: PUSH
30479: LD_INT 0
30481: ST_TO_ADDR
// end ;
30482: LD_VAR 0 3
30486: RET
// export function CompareArrayValues ( array1 , array2 ) ; var i ; begin
30487: LD_INT 0
30489: PPUSH
30490: PPUSH
// if not array1 or not array2 then
30491: LD_VAR 0 1
30495: NOT
30496: PUSH
30497: LD_VAR 0 2
30501: NOT
30502: OR
30503: IFFALSE 30507
// exit ;
30505: GO 30571
// result := true ;
30507: LD_ADDR_VAR 0 3
30511: PUSH
30512: LD_INT 1
30514: ST_TO_ADDR
// for i = 1 to array1 do
30515: LD_ADDR_VAR 0 4
30519: PUSH
30520: DOUBLE
30521: LD_INT 1
30523: DEC
30524: ST_TO_ADDR
30525: LD_VAR 0 1
30529: PUSH
30530: FOR_TO
30531: IFFALSE 30569
// if array1 [ i ] <> array2 [ i ] then
30533: LD_VAR 0 1
30537: PUSH
30538: LD_VAR 0 4
30542: ARRAY
30543: PUSH
30544: LD_VAR 0 2
30548: PUSH
30549: LD_VAR 0 4
30553: ARRAY
30554: NONEQUAL
30555: IFFALSE 30567
// begin result := false ;
30557: LD_ADDR_VAR 0 3
30561: PUSH
30562: LD_INT 0
30564: ST_TO_ADDR
// break ;
30565: GO 30569
// end ;
30567: GO 30530
30569: POP
30570: POP
// end ;
30571: LD_VAR 0 3
30575: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
30576: LD_INT 0
30578: PPUSH
30579: PPUSH
30580: PPUSH
// pom := GetBase ( fac ) ;
30581: LD_ADDR_VAR 0 5
30585: PUSH
30586: LD_VAR 0 1
30590: PPUSH
30591: CALL_OW 274
30595: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
30596: LD_ADDR_VAR 0 4
30600: PUSH
30601: LD_VAR 0 2
30605: PUSH
30606: LD_INT 1
30608: ARRAY
30609: PPUSH
30610: LD_VAR 0 2
30614: PUSH
30615: LD_INT 2
30617: ARRAY
30618: PPUSH
30619: LD_VAR 0 2
30623: PUSH
30624: LD_INT 3
30626: ARRAY
30627: PPUSH
30628: LD_VAR 0 2
30632: PUSH
30633: LD_INT 4
30635: ARRAY
30636: PPUSH
30637: CALL_OW 449
30641: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
30642: LD_ADDR_VAR 0 3
30646: PUSH
30647: LD_VAR 0 5
30651: PPUSH
30652: LD_INT 1
30654: PPUSH
30655: CALL_OW 275
30659: PUSH
30660: LD_VAR 0 4
30664: PUSH
30665: LD_INT 1
30667: ARRAY
30668: GREATEREQUAL
30669: PUSH
30670: LD_VAR 0 5
30674: PPUSH
30675: LD_INT 2
30677: PPUSH
30678: CALL_OW 275
30682: PUSH
30683: LD_VAR 0 4
30687: PUSH
30688: LD_INT 2
30690: ARRAY
30691: GREATEREQUAL
30692: AND
30693: PUSH
30694: LD_VAR 0 5
30698: PPUSH
30699: LD_INT 3
30701: PPUSH
30702: CALL_OW 275
30706: PUSH
30707: LD_VAR 0 4
30711: PUSH
30712: LD_INT 3
30714: ARRAY
30715: GREATEREQUAL
30716: AND
30717: ST_TO_ADDR
// end ;
30718: LD_VAR 0 3
30722: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
30723: LD_INT 0
30725: PPUSH
30726: PPUSH
30727: PPUSH
30728: PPUSH
// pom := GetBase ( building ) ;
30729: LD_ADDR_VAR 0 3
30733: PUSH
30734: LD_VAR 0 1
30738: PPUSH
30739: CALL_OW 274
30743: ST_TO_ADDR
// if not pom then
30744: LD_VAR 0 3
30748: NOT
30749: IFFALSE 30753
// exit ;
30751: GO 30923
// btype := GetBType ( building ) ;
30753: LD_ADDR_VAR 0 5
30757: PUSH
30758: LD_VAR 0 1
30762: PPUSH
30763: CALL_OW 266
30767: ST_TO_ADDR
// if btype = b_armoury then
30768: LD_VAR 0 5
30772: PUSH
30773: LD_INT 4
30775: EQUAL
30776: IFFALSE 30786
// btype := b_barracks ;
30778: LD_ADDR_VAR 0 5
30782: PUSH
30783: LD_INT 5
30785: ST_TO_ADDR
// if btype = b_depot then
30786: LD_VAR 0 5
30790: PUSH
30791: LD_INT 0
30793: EQUAL
30794: IFFALSE 30804
// btype := b_warehouse ;
30796: LD_ADDR_VAR 0 5
30800: PUSH
30801: LD_INT 1
30803: ST_TO_ADDR
// if btype = b_workshop then
30804: LD_VAR 0 5
30808: PUSH
30809: LD_INT 2
30811: EQUAL
30812: IFFALSE 30822
// btype := b_factory ;
30814: LD_ADDR_VAR 0 5
30818: PUSH
30819: LD_INT 3
30821: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
30822: LD_ADDR_VAR 0 4
30826: PUSH
30827: LD_VAR 0 5
30831: PPUSH
30832: LD_VAR 0 1
30836: PPUSH
30837: CALL_OW 248
30841: PPUSH
30842: CALL_OW 450
30846: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
30847: LD_ADDR_VAR 0 2
30851: PUSH
30852: LD_VAR 0 3
30856: PPUSH
30857: LD_INT 1
30859: PPUSH
30860: CALL_OW 275
30864: PUSH
30865: LD_VAR 0 4
30869: PUSH
30870: LD_INT 1
30872: ARRAY
30873: GREATEREQUAL
30874: PUSH
30875: LD_VAR 0 3
30879: PPUSH
30880: LD_INT 2
30882: PPUSH
30883: CALL_OW 275
30887: PUSH
30888: LD_VAR 0 4
30892: PUSH
30893: LD_INT 2
30895: ARRAY
30896: GREATEREQUAL
30897: AND
30898: PUSH
30899: LD_VAR 0 3
30903: PPUSH
30904: LD_INT 3
30906: PPUSH
30907: CALL_OW 275
30911: PUSH
30912: LD_VAR 0 4
30916: PUSH
30917: LD_INT 3
30919: ARRAY
30920: GREATEREQUAL
30921: AND
30922: ST_TO_ADDR
// end ;
30923: LD_VAR 0 2
30927: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
30928: LD_INT 0
30930: PPUSH
30931: PPUSH
30932: PPUSH
// pom := GetBase ( building ) ;
30933: LD_ADDR_VAR 0 4
30937: PUSH
30938: LD_VAR 0 1
30942: PPUSH
30943: CALL_OW 274
30947: ST_TO_ADDR
// if not pom then
30948: LD_VAR 0 4
30952: NOT
30953: IFFALSE 30957
// exit ;
30955: GO 31058
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
30957: LD_ADDR_VAR 0 5
30961: PUSH
30962: LD_VAR 0 2
30966: PPUSH
30967: LD_VAR 0 1
30971: PPUSH
30972: CALL_OW 248
30976: PPUSH
30977: CALL_OW 450
30981: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
30982: LD_ADDR_VAR 0 3
30986: PUSH
30987: LD_VAR 0 4
30991: PPUSH
30992: LD_INT 1
30994: PPUSH
30995: CALL_OW 275
30999: PUSH
31000: LD_VAR 0 5
31004: PUSH
31005: LD_INT 1
31007: ARRAY
31008: GREATEREQUAL
31009: PUSH
31010: LD_VAR 0 4
31014: PPUSH
31015: LD_INT 2
31017: PPUSH
31018: CALL_OW 275
31022: PUSH
31023: LD_VAR 0 5
31027: PUSH
31028: LD_INT 2
31030: ARRAY
31031: GREATEREQUAL
31032: AND
31033: PUSH
31034: LD_VAR 0 4
31038: PPUSH
31039: LD_INT 3
31041: PPUSH
31042: CALL_OW 275
31046: PUSH
31047: LD_VAR 0 5
31051: PUSH
31052: LD_INT 3
31054: ARRAY
31055: GREATEREQUAL
31056: AND
31057: ST_TO_ADDR
// end ;
31058: LD_VAR 0 3
31062: RET
// export function TryClearPlaceForBuilding ( btype , x , y , d , buildings , cleaners , parking ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep , driver ; begin
31063: LD_INT 0
31065: PPUSH
31066: PPUSH
31067: PPUSH
31068: PPUSH
31069: PPUSH
31070: PPUSH
31071: PPUSH
31072: PPUSH
31073: PPUSH
31074: PPUSH
31075: PPUSH
// result := false ;
31076: LD_ADDR_VAR 0 8
31080: PUSH
31081: LD_INT 0
31083: ST_TO_ADDR
// if not buildings or not btype or not x or not y then
31084: LD_VAR 0 5
31088: NOT
31089: PUSH
31090: LD_VAR 0 1
31094: NOT
31095: OR
31096: PUSH
31097: LD_VAR 0 2
31101: NOT
31102: OR
31103: PUSH
31104: LD_VAR 0 3
31108: NOT
31109: OR
31110: IFFALSE 31114
// exit ;
31112: GO 31928
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( buildings [ 1 ] ) , 0 ) ;
31114: LD_ADDR_VAR 0 14
31118: PUSH
31119: LD_VAR 0 1
31123: PPUSH
31124: LD_VAR 0 2
31128: PPUSH
31129: LD_VAR 0 3
31133: PPUSH
31134: LD_VAR 0 4
31138: PPUSH
31139: LD_VAR 0 5
31143: PUSH
31144: LD_INT 1
31146: ARRAY
31147: PPUSH
31148: CALL_OW 248
31152: PPUSH
31153: LD_INT 0
31155: PPUSH
31156: CALL 33165 0 6
31160: ST_TO_ADDR
// if not hexes then
31161: LD_VAR 0 14
31165: NOT
31166: IFFALSE 31170
// exit ;
31168: GO 31928
// dep := UnitFilter ( buildings , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
31170: LD_ADDR_VAR 0 17
31174: PUSH
31175: LD_VAR 0 5
31179: PPUSH
31180: LD_INT 22
31182: PUSH
31183: LD_VAR 0 13
31187: PPUSH
31188: CALL_OW 255
31192: PUSH
31193: EMPTY
31194: LIST
31195: LIST
31196: PUSH
31197: LD_INT 2
31199: PUSH
31200: LD_INT 30
31202: PUSH
31203: LD_INT 0
31205: PUSH
31206: EMPTY
31207: LIST
31208: LIST
31209: PUSH
31210: LD_INT 30
31212: PUSH
31213: LD_INT 1
31215: PUSH
31216: EMPTY
31217: LIST
31218: LIST
31219: PUSH
31220: EMPTY
31221: LIST
31222: LIST
31223: LIST
31224: PUSH
31225: EMPTY
31226: LIST
31227: LIST
31228: PPUSH
31229: CALL_OW 72
31233: ST_TO_ADDR
// for i = 1 to hexes do
31234: LD_ADDR_VAR 0 9
31238: PUSH
31239: DOUBLE
31240: LD_INT 1
31242: DEC
31243: ST_TO_ADDR
31244: LD_VAR 0 14
31248: PUSH
31249: FOR_TO
31250: IFFALSE 31926
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
31252: LD_ADDR_VAR 0 13
31256: PUSH
31257: LD_VAR 0 14
31261: PUSH
31262: LD_VAR 0 9
31266: ARRAY
31267: PUSH
31268: LD_INT 1
31270: ARRAY
31271: PPUSH
31272: LD_VAR 0 14
31276: PUSH
31277: LD_VAR 0 9
31281: ARRAY
31282: PUSH
31283: LD_INT 2
31285: ARRAY
31286: PPUSH
31287: CALL_OW 428
31291: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
31292: LD_VAR 0 14
31296: PUSH
31297: LD_VAR 0 9
31301: ARRAY
31302: PUSH
31303: LD_INT 1
31305: ARRAY
31306: PPUSH
31307: LD_VAR 0 14
31311: PUSH
31312: LD_VAR 0 9
31316: ARRAY
31317: PUSH
31318: LD_INT 2
31320: ARRAY
31321: PPUSH
31322: CALL_OW 351
31326: PUSH
31327: LD_VAR 0 14
31331: PUSH
31332: LD_VAR 0 9
31336: ARRAY
31337: PUSH
31338: LD_INT 1
31340: ARRAY
31341: PPUSH
31342: LD_VAR 0 14
31346: PUSH
31347: LD_VAR 0 9
31351: ARRAY
31352: PUSH
31353: LD_INT 2
31355: ARRAY
31356: PPUSH
31357: CALL_OW 488
31361: NOT
31362: OR
31363: PUSH
31364: LD_VAR 0 13
31368: PPUSH
31369: CALL_OW 247
31373: PUSH
31374: LD_INT 3
31376: EQUAL
31377: OR
31378: IFFALSE 31384
// exit ;
31380: POP
31381: POP
31382: GO 31928
// if not tmp then
31384: LD_VAR 0 13
31388: NOT
31389: IFFALSE 31393
// continue ;
31391: GO 31249
// result := true ;
31393: LD_ADDR_VAR 0 8
31397: PUSH
31398: LD_INT 1
31400: ST_TO_ADDR
// if cleaners and GetType ( tmp ) = unit_vehicle and GetControl ( tmp ) = control_manual then
31401: LD_VAR 0 6
31405: PUSH
31406: LD_VAR 0 13
31410: PPUSH
31411: CALL_OW 247
31415: PUSH
31416: LD_INT 2
31418: EQUAL
31419: AND
31420: PUSH
31421: LD_VAR 0 13
31425: PPUSH
31426: CALL_OW 263
31430: PUSH
31431: LD_INT 1
31433: EQUAL
31434: AND
31435: IFFALSE 31599
// begin if IsDrivenBy ( tmp ) then
31437: LD_VAR 0 13
31441: PPUSH
31442: CALL_OW 311
31446: IFFALSE 31450
// continue ;
31448: GO 31249
// if UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) then
31450: LD_VAR 0 6
31454: PPUSH
31455: LD_INT 3
31457: PUSH
31458: LD_INT 60
31460: PUSH
31461: EMPTY
31462: LIST
31463: PUSH
31464: EMPTY
31465: LIST
31466: LIST
31467: PUSH
31468: LD_INT 3
31470: PUSH
31471: LD_INT 55
31473: PUSH
31474: EMPTY
31475: LIST
31476: PUSH
31477: EMPTY
31478: LIST
31479: LIST
31480: PUSH
31481: EMPTY
31482: LIST
31483: LIST
31484: PPUSH
31485: CALL_OW 72
31489: IFFALSE 31597
// begin driver := UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) [ 1 ] ;
31491: LD_ADDR_VAR 0 18
31495: PUSH
31496: LD_VAR 0 6
31500: PPUSH
31501: LD_INT 3
31503: PUSH
31504: LD_INT 60
31506: PUSH
31507: EMPTY
31508: LIST
31509: PUSH
31510: EMPTY
31511: LIST
31512: LIST
31513: PUSH
31514: LD_INT 3
31516: PUSH
31517: LD_INT 55
31519: PUSH
31520: EMPTY
31521: LIST
31522: PUSH
31523: EMPTY
31524: LIST
31525: LIST
31526: PUSH
31527: EMPTY
31528: LIST
31529: LIST
31530: PPUSH
31531: CALL_OW 72
31535: PUSH
31536: LD_INT 1
31538: ARRAY
31539: ST_TO_ADDR
// if IsInUnit ( driver ) then
31540: LD_VAR 0 18
31544: PPUSH
31545: CALL_OW 310
31549: IFFALSE 31560
// ComExit ( driver ) ;
31551: LD_VAR 0 18
31555: PPUSH
31556: CALL 56349 0 1
// AddComEnterUnit ( driver , tmp ) ;
31560: LD_VAR 0 18
31564: PPUSH
31565: LD_VAR 0 13
31569: PPUSH
31570: CALL_OW 180
// AddComMoveToArea ( driver , parking ) ;
31574: LD_VAR 0 18
31578: PPUSH
31579: LD_VAR 0 7
31583: PPUSH
31584: CALL_OW 173
// AddComExitVehicle ( driver ) ;
31588: LD_VAR 0 18
31592: PPUSH
31593: CALL_OW 181
// end ; continue ;
31597: GO 31249
// end ; if not cleaners or not tmp in cleaners then
31599: LD_VAR 0 6
31603: NOT
31604: PUSH
31605: LD_VAR 0 13
31609: PUSH
31610: LD_VAR 0 6
31614: IN
31615: NOT
31616: OR
31617: IFFALSE 31924
// begin if dep then
31619: LD_VAR 0 17
31623: IFFALSE 31759
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
31625: LD_ADDR_VAR 0 16
31629: PUSH
31630: LD_VAR 0 17
31634: PUSH
31635: LD_INT 1
31637: ARRAY
31638: PPUSH
31639: CALL_OW 250
31643: PPUSH
31644: LD_VAR 0 17
31648: PUSH
31649: LD_INT 1
31651: ARRAY
31652: PPUSH
31653: CALL_OW 254
31657: PPUSH
31658: LD_INT 5
31660: PPUSH
31661: CALL_OW 272
31665: PUSH
31666: LD_VAR 0 17
31670: PUSH
31671: LD_INT 1
31673: ARRAY
31674: PPUSH
31675: CALL_OW 251
31679: PPUSH
31680: LD_VAR 0 17
31684: PUSH
31685: LD_INT 1
31687: ARRAY
31688: PPUSH
31689: CALL_OW 254
31693: PPUSH
31694: LD_INT 5
31696: PPUSH
31697: CALL_OW 273
31701: PUSH
31702: EMPTY
31703: LIST
31704: LIST
31705: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
31706: LD_VAR 0 16
31710: PUSH
31711: LD_INT 1
31713: ARRAY
31714: PPUSH
31715: LD_VAR 0 16
31719: PUSH
31720: LD_INT 2
31722: ARRAY
31723: PPUSH
31724: CALL_OW 488
31728: IFFALSE 31759
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
31730: LD_VAR 0 13
31734: PPUSH
31735: LD_VAR 0 16
31739: PUSH
31740: LD_INT 1
31742: ARRAY
31743: PPUSH
31744: LD_VAR 0 16
31748: PUSH
31749: LD_INT 2
31751: ARRAY
31752: PPUSH
31753: CALL_OW 111
// continue ;
31757: GO 31249
// end ; end ; r := GetDir ( tmp ) ;
31759: LD_ADDR_VAR 0 15
31763: PUSH
31764: LD_VAR 0 13
31768: PPUSH
31769: CALL_OW 254
31773: ST_TO_ADDR
// if r = 5 then
31774: LD_VAR 0 15
31778: PUSH
31779: LD_INT 5
31781: EQUAL
31782: IFFALSE 31792
// r := 0 ;
31784: LD_ADDR_VAR 0 15
31788: PUSH
31789: LD_INT 0
31791: ST_TO_ADDR
// for j = r to 5 do
31792: LD_ADDR_VAR 0 10
31796: PUSH
31797: DOUBLE
31798: LD_VAR 0 15
31802: DEC
31803: ST_TO_ADDR
31804: LD_INT 5
31806: PUSH
31807: FOR_TO
31808: IFFALSE 31922
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
31810: LD_ADDR_VAR 0 11
31814: PUSH
31815: LD_VAR 0 13
31819: PPUSH
31820: CALL_OW 250
31824: PPUSH
31825: LD_VAR 0 10
31829: PPUSH
31830: LD_INT 2
31832: PPUSH
31833: CALL_OW 272
31837: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
31838: LD_ADDR_VAR 0 12
31842: PUSH
31843: LD_VAR 0 13
31847: PPUSH
31848: CALL_OW 251
31852: PPUSH
31853: LD_VAR 0 10
31857: PPUSH
31858: LD_INT 2
31860: PPUSH
31861: CALL_OW 273
31865: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
31866: LD_VAR 0 11
31870: PPUSH
31871: LD_VAR 0 12
31875: PPUSH
31876: CALL_OW 488
31880: PUSH
31881: LD_VAR 0 11
31885: PPUSH
31886: LD_VAR 0 12
31890: PPUSH
31891: CALL_OW 428
31895: NOT
31896: AND
31897: IFFALSE 31920
// begin ComMoveXY ( tmp , _x , _y ) ;
31899: LD_VAR 0 13
31903: PPUSH
31904: LD_VAR 0 11
31908: PPUSH
31909: LD_VAR 0 12
31913: PPUSH
31914: CALL_OW 111
// break ;
31918: GO 31922
// end ; end ;
31920: GO 31807
31922: POP
31923: POP
// end ; end ;
31924: GO 31249
31926: POP
31927: POP
// end ;
31928: LD_VAR 0 8
31932: RET
// export function BuildingTechInvented ( side , btype ) ; begin
31933: LD_INT 0
31935: PPUSH
// result := true ;
31936: LD_ADDR_VAR 0 3
31940: PUSH
31941: LD_INT 1
31943: ST_TO_ADDR
// case btype of b_ext_computer , b_turret :
31944: LD_VAR 0 2
31948: PUSH
31949: LD_INT 24
31951: DOUBLE
31952: EQUAL
31953: IFTRUE 31963
31955: LD_INT 33
31957: DOUBLE
31958: EQUAL
31959: IFTRUE 31963
31961: GO 31988
31963: POP
// result := ( GetTech ( tech_ai , side ) = state_researched ) ; b_ext_radar :
31964: LD_ADDR_VAR 0 3
31968: PUSH
31969: LD_INT 32
31971: PPUSH
31972: LD_VAR 0 1
31976: PPUSH
31977: CALL_OW 321
31981: PUSH
31982: LD_INT 2
31984: EQUAL
31985: ST_TO_ADDR
31986: GO 32308
31988: LD_INT 20
31990: DOUBLE
31991: EQUAL
31992: IFTRUE 31996
31994: GO 32021
31996: POP
// result := ( GetTech ( tech_radar , side ) = state_researched ) ; b_ext_radio , b_control_tower :
31997: LD_ADDR_VAR 0 3
32001: PUSH
32002: LD_INT 6
32004: PPUSH
32005: LD_VAR 0 1
32009: PPUSH
32010: CALL_OW 321
32014: PUSH
32015: LD_INT 2
32017: EQUAL
32018: ST_TO_ADDR
32019: GO 32308
32021: LD_INT 22
32023: DOUBLE
32024: EQUAL
32025: IFTRUE 32035
32027: LD_INT 36
32029: DOUBLE
32030: EQUAL
32031: IFTRUE 32035
32033: GO 32060
32035: POP
// result := ( GetTech ( tech_remcont , side ) = state_researched ) ; b_siberite_mine :
32036: LD_ADDR_VAR 0 3
32040: PUSH
32041: LD_INT 15
32043: PPUSH
32044: LD_VAR 0 1
32048: PPUSH
32049: CALL_OW 321
32053: PUSH
32054: LD_INT 2
32056: EQUAL
32057: ST_TO_ADDR
32058: GO 32308
32060: LD_INT 30
32062: DOUBLE
32063: EQUAL
32064: IFTRUE 32068
32066: GO 32093
32068: POP
// result := ( GetTech ( tech_sibdet , side ) = state_researched ) ; b_siberite_power , b_ext_siberium :
32069: LD_ADDR_VAR 0 3
32073: PUSH
32074: LD_INT 20
32076: PPUSH
32077: LD_VAR 0 1
32081: PPUSH
32082: CALL_OW 321
32086: PUSH
32087: LD_INT 2
32089: EQUAL
32090: ST_TO_ADDR
32091: GO 32308
32093: LD_INT 28
32095: DOUBLE
32096: EQUAL
32097: IFTRUE 32107
32099: LD_INT 21
32101: DOUBLE
32102: EQUAL
32103: IFTRUE 32107
32105: GO 32132
32107: POP
// result := ( GetTech ( tech_sibpow , side ) = state_researched ) ; b_ext_track :
32108: LD_ADDR_VAR 0 3
32112: PUSH
32113: LD_INT 21
32115: PPUSH
32116: LD_VAR 0 1
32120: PPUSH
32121: CALL_OW 321
32125: PUSH
32126: LD_INT 2
32128: EQUAL
32129: ST_TO_ADDR
32130: GO 32308
32132: LD_INT 16
32134: DOUBLE
32135: EQUAL
32136: IFTRUE 32140
32138: GO 32167
32140: POP
// result := ( GetTech ( tech_track , side ) = state_researched ) ; b_ext_noncombat , b_ext_stitch :
32141: LD_ADDR_VAR 0 3
32145: PUSH
32146: LD_EXP 169
32150: PPUSH
32151: LD_VAR 0 1
32155: PPUSH
32156: CALL_OW 321
32160: PUSH
32161: LD_INT 2
32163: EQUAL
32164: ST_TO_ADDR
32165: GO 32308
32167: LD_INT 19
32169: DOUBLE
32170: EQUAL
32171: IFTRUE 32181
32173: LD_INT 23
32175: DOUBLE
32176: EQUAL
32177: IFTRUE 32181
32179: GO 32208
32181: POP
// result := ( GetTech ( tech_cargo , side ) = state_researched ) ; b_ext_gun :
32182: LD_ADDR_VAR 0 3
32186: PUSH
32187: LD_EXP 168
32191: PPUSH
32192: LD_VAR 0 1
32196: PPUSH
32197: CALL_OW 321
32201: PUSH
32202: LD_INT 2
32204: EQUAL
32205: ST_TO_ADDR
32206: GO 32308
32208: LD_INT 17
32210: DOUBLE
32211: EQUAL
32212: IFTRUE 32216
32214: GO 32241
32216: POP
// result := ( GetTech ( tech_gun , side ) = state_researched ) ; b_ext_rocket :
32217: LD_ADDR_VAR 0 3
32221: PUSH
32222: LD_INT 39
32224: PPUSH
32225: LD_VAR 0 1
32229: PPUSH
32230: CALL_OW 321
32234: PUSH
32235: LD_INT 2
32237: EQUAL
32238: ST_TO_ADDR
32239: GO 32308
32241: LD_INT 18
32243: DOUBLE
32244: EQUAL
32245: IFTRUE 32249
32247: GO 32274
32249: POP
// result := ( GetTech ( tech_rocket , side ) = state_researched ) ; b_solar_power :
32250: LD_ADDR_VAR 0 3
32254: PUSH
32255: LD_INT 40
32257: PPUSH
32258: LD_VAR 0 1
32262: PPUSH
32263: CALL_OW 321
32267: PUSH
32268: LD_INT 2
32270: EQUAL
32271: ST_TO_ADDR
32272: GO 32308
32274: LD_INT 27
32276: DOUBLE
32277: EQUAL
32278: IFTRUE 32282
32280: GO 32307
32282: POP
// result := ( GetTech ( tech_solpow , side ) = state_researched ) ; end ;
32283: LD_ADDR_VAR 0 3
32287: PUSH
32288: LD_INT 35
32290: PPUSH
32291: LD_VAR 0 1
32295: PPUSH
32296: CALL_OW 321
32300: PUSH
32301: LD_INT 2
32303: EQUAL
32304: ST_TO_ADDR
32305: GO 32308
32307: POP
// end ;
32308: LD_VAR 0 3
32312: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex , tech ; begin
32313: LD_INT 0
32315: PPUSH
32316: PPUSH
32317: PPUSH
32318: PPUSH
32319: PPUSH
32320: PPUSH
32321: PPUSH
32322: PPUSH
32323: PPUSH
32324: PPUSH
32325: PPUSH
// result := false ;
32326: LD_ADDR_VAR 0 6
32330: PUSH
32331: LD_INT 0
32333: ST_TO_ADDR
// if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
32334: LD_VAR 0 1
32338: NOT
32339: PUSH
32340: LD_VAR 0 1
32344: PPUSH
32345: CALL_OW 266
32349: PUSH
32350: LD_INT 0
32352: PUSH
32353: LD_INT 1
32355: PUSH
32356: EMPTY
32357: LIST
32358: LIST
32359: IN
32360: NOT
32361: OR
32362: PUSH
32363: LD_VAR 0 2
32367: NOT
32368: OR
32369: PUSH
32370: LD_VAR 0 5
32374: PUSH
32375: LD_INT 0
32377: PUSH
32378: LD_INT 1
32380: PUSH
32381: LD_INT 2
32383: PUSH
32384: LD_INT 3
32386: PUSH
32387: LD_INT 4
32389: PUSH
32390: LD_INT 5
32392: PUSH
32393: EMPTY
32394: LIST
32395: LIST
32396: LIST
32397: LIST
32398: LIST
32399: LIST
32400: IN
32401: NOT
32402: OR
32403: PUSH
32404: LD_VAR 0 3
32408: PPUSH
32409: LD_VAR 0 4
32413: PPUSH
32414: CALL_OW 488
32418: NOT
32419: OR
32420: IFFALSE 32424
// exit ;
32422: GO 33160
// side := GetSide ( depot ) ;
32424: LD_ADDR_VAR 0 9
32428: PUSH
32429: LD_VAR 0 1
32433: PPUSH
32434: CALL_OW 255
32438: ST_TO_ADDR
// if not BuildingTechInvented ( side , btype ) then
32439: LD_VAR 0 9
32443: PPUSH
32444: LD_VAR 0 2
32448: PPUSH
32449: CALL 31933 0 2
32453: NOT
32454: IFFALSE 32458
// exit ;
32456: GO 33160
// pom := GetBase ( depot ) ;
32458: LD_ADDR_VAR 0 10
32462: PUSH
32463: LD_VAR 0 1
32467: PPUSH
32468: CALL_OW 274
32472: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
32473: LD_ADDR_VAR 0 11
32477: PUSH
32478: LD_VAR 0 2
32482: PPUSH
32483: LD_VAR 0 1
32487: PPUSH
32488: CALL_OW 248
32492: PPUSH
32493: CALL_OW 450
32497: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
32498: LD_VAR 0 10
32502: PPUSH
32503: LD_INT 1
32505: PPUSH
32506: CALL_OW 275
32510: PUSH
32511: LD_VAR 0 11
32515: PUSH
32516: LD_INT 1
32518: ARRAY
32519: GREATEREQUAL
32520: PUSH
32521: LD_VAR 0 10
32525: PPUSH
32526: LD_INT 2
32528: PPUSH
32529: CALL_OW 275
32533: PUSH
32534: LD_VAR 0 11
32538: PUSH
32539: LD_INT 2
32541: ARRAY
32542: GREATEREQUAL
32543: AND
32544: PUSH
32545: LD_VAR 0 10
32549: PPUSH
32550: LD_INT 3
32552: PPUSH
32553: CALL_OW 275
32557: PUSH
32558: LD_VAR 0 11
32562: PUSH
32563: LD_INT 3
32565: ARRAY
32566: GREATEREQUAL
32567: AND
32568: NOT
32569: IFFALSE 32573
// exit ;
32571: GO 33160
// if GetBType ( depot ) = b_depot then
32573: LD_VAR 0 1
32577: PPUSH
32578: CALL_OW 266
32582: PUSH
32583: LD_INT 0
32585: EQUAL
32586: IFFALSE 32598
// dist := 28 else
32588: LD_ADDR_VAR 0 14
32592: PUSH
32593: LD_INT 28
32595: ST_TO_ADDR
32596: GO 32606
// dist := 36 ;
32598: LD_ADDR_VAR 0 14
32602: PUSH
32603: LD_INT 36
32605: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
32606: LD_VAR 0 1
32610: PPUSH
32611: LD_VAR 0 3
32615: PPUSH
32616: LD_VAR 0 4
32620: PPUSH
32621: CALL_OW 297
32625: PUSH
32626: LD_VAR 0 14
32630: GREATER
32631: IFFALSE 32635
// exit ;
32633: GO 33160
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
32635: LD_ADDR_VAR 0 12
32639: PUSH
32640: LD_VAR 0 2
32644: PPUSH
32645: LD_VAR 0 3
32649: PPUSH
32650: LD_VAR 0 4
32654: PPUSH
32655: LD_VAR 0 5
32659: PPUSH
32660: LD_VAR 0 1
32664: PPUSH
32665: CALL_OW 248
32669: PPUSH
32670: LD_INT 0
32672: PPUSH
32673: CALL 33165 0 6
32677: ST_TO_ADDR
// if not hexes then
32678: LD_VAR 0 12
32682: NOT
32683: IFFALSE 32687
// exit ;
32685: GO 33160
// hex := GetHexInfo ( x , y ) ;
32687: LD_ADDR_VAR 0 15
32691: PUSH
32692: LD_VAR 0 3
32696: PPUSH
32697: LD_VAR 0 4
32701: PPUSH
32702: CALL_OW 546
32706: ST_TO_ADDR
// if hex [ 1 ] then
32707: LD_VAR 0 15
32711: PUSH
32712: LD_INT 1
32714: ARRAY
32715: IFFALSE 32719
// exit ;
32717: GO 33160
// height := hex [ 2 ] ;
32719: LD_ADDR_VAR 0 13
32723: PUSH
32724: LD_VAR 0 15
32728: PUSH
32729: LD_INT 2
32731: ARRAY
32732: ST_TO_ADDR
// for i = 1 to hexes do
32733: LD_ADDR_VAR 0 7
32737: PUSH
32738: DOUBLE
32739: LD_INT 1
32741: DEC
32742: ST_TO_ADDR
32743: LD_VAR 0 12
32747: PUSH
32748: FOR_TO
32749: IFFALSE 33079
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
32751: LD_VAR 0 12
32755: PUSH
32756: LD_VAR 0 7
32760: ARRAY
32761: PUSH
32762: LD_INT 1
32764: ARRAY
32765: PPUSH
32766: LD_VAR 0 12
32770: PUSH
32771: LD_VAR 0 7
32775: ARRAY
32776: PUSH
32777: LD_INT 2
32779: ARRAY
32780: PPUSH
32781: CALL_OW 488
32785: NOT
32786: PUSH
32787: LD_VAR 0 12
32791: PUSH
32792: LD_VAR 0 7
32796: ARRAY
32797: PUSH
32798: LD_INT 1
32800: ARRAY
32801: PPUSH
32802: LD_VAR 0 12
32806: PUSH
32807: LD_VAR 0 7
32811: ARRAY
32812: PUSH
32813: LD_INT 2
32815: ARRAY
32816: PPUSH
32817: CALL_OW 428
32821: PUSH
32822: LD_INT 0
32824: GREATER
32825: OR
32826: PUSH
32827: LD_VAR 0 12
32831: PUSH
32832: LD_VAR 0 7
32836: ARRAY
32837: PUSH
32838: LD_INT 1
32840: ARRAY
32841: PPUSH
32842: LD_VAR 0 12
32846: PUSH
32847: LD_VAR 0 7
32851: ARRAY
32852: PUSH
32853: LD_INT 2
32855: ARRAY
32856: PPUSH
32857: CALL_OW 351
32861: OR
32862: IFFALSE 32868
// exit ;
32864: POP
32865: POP
32866: GO 33160
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
32868: LD_ADDR_VAR 0 8
32872: PUSH
32873: LD_VAR 0 12
32877: PUSH
32878: LD_VAR 0 7
32882: ARRAY
32883: PUSH
32884: LD_INT 1
32886: ARRAY
32887: PPUSH
32888: LD_VAR 0 12
32892: PUSH
32893: LD_VAR 0 7
32897: ARRAY
32898: PUSH
32899: LD_INT 2
32901: ARRAY
32902: PPUSH
32903: CALL_OW 546
32907: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
32908: LD_VAR 0 8
32912: PUSH
32913: LD_INT 1
32915: ARRAY
32916: PUSH
32917: LD_VAR 0 8
32921: PUSH
32922: LD_INT 2
32924: ARRAY
32925: PUSH
32926: LD_VAR 0 13
32930: PUSH
32931: LD_INT 2
32933: PLUS
32934: GREATER
32935: OR
32936: PUSH
32937: LD_VAR 0 8
32941: PUSH
32942: LD_INT 2
32944: ARRAY
32945: PUSH
32946: LD_VAR 0 13
32950: PUSH
32951: LD_INT 2
32953: MINUS
32954: LESS
32955: OR
32956: PUSH
32957: LD_VAR 0 8
32961: PUSH
32962: LD_INT 3
32964: ARRAY
32965: PUSH
32966: LD_INT 0
32968: PUSH
32969: LD_INT 8
32971: PUSH
32972: LD_INT 9
32974: PUSH
32975: LD_INT 10
32977: PUSH
32978: LD_INT 11
32980: PUSH
32981: LD_INT 12
32983: PUSH
32984: LD_INT 13
32986: PUSH
32987: LD_INT 16
32989: PUSH
32990: LD_INT 17
32992: PUSH
32993: LD_INT 18
32995: PUSH
32996: LD_INT 19
32998: PUSH
32999: LD_INT 20
33001: PUSH
33002: LD_INT 21
33004: PUSH
33005: EMPTY
33006: LIST
33007: LIST
33008: LIST
33009: LIST
33010: LIST
33011: LIST
33012: LIST
33013: LIST
33014: LIST
33015: LIST
33016: LIST
33017: LIST
33018: LIST
33019: IN
33020: NOT
33021: OR
33022: PUSH
33023: LD_VAR 0 8
33027: PUSH
33028: LD_INT 5
33030: ARRAY
33031: NOT
33032: OR
33033: PUSH
33034: LD_VAR 0 8
33038: PUSH
33039: LD_INT 6
33041: ARRAY
33042: PUSH
33043: LD_INT 1
33045: PUSH
33046: LD_INT 2
33048: PUSH
33049: LD_INT 7
33051: PUSH
33052: LD_INT 9
33054: PUSH
33055: LD_INT 10
33057: PUSH
33058: LD_INT 11
33060: PUSH
33061: EMPTY
33062: LIST
33063: LIST
33064: LIST
33065: LIST
33066: LIST
33067: LIST
33068: IN
33069: NOT
33070: OR
33071: IFFALSE 33077
// exit ;
33073: POP
33074: POP
33075: GO 33160
// end ;
33077: GO 32748
33079: POP
33080: POP
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
33081: LD_VAR 0 9
33085: PPUSH
33086: LD_VAR 0 3
33090: PPUSH
33091: LD_VAR 0 4
33095: PPUSH
33096: LD_INT 20
33098: PPUSH
33099: CALL 25106 0 4
33103: PUSH
33104: LD_INT 4
33106: ARRAY
33107: IFFALSE 33111
// exit ;
33109: GO 33160
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
33111: LD_VAR 0 2
33115: PUSH
33116: LD_INT 29
33118: PUSH
33119: LD_INT 30
33121: PUSH
33122: EMPTY
33123: LIST
33124: LIST
33125: IN
33126: PUSH
33127: LD_VAR 0 3
33131: PPUSH
33132: LD_VAR 0 4
33136: PPUSH
33137: LD_VAR 0 9
33141: PPUSH
33142: CALL_OW 440
33146: NOT
33147: AND
33148: IFFALSE 33152
// exit ;
33150: GO 33160
// result := true ;
33152: LD_ADDR_VAR 0 6
33156: PUSH
33157: LD_INT 1
33159: ST_TO_ADDR
// end ;
33160: LD_VAR 0 6
33164: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 , fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 , fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ; var fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 , fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ; var fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 , fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ; var fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 , fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ; begin
33165: LD_INT 0
33167: PPUSH
33168: PPUSH
33169: PPUSH
33170: PPUSH
33171: PPUSH
33172: PPUSH
33173: PPUSH
33174: PPUSH
33175: PPUSH
33176: PPUSH
33177: PPUSH
33178: PPUSH
33179: PPUSH
33180: PPUSH
33181: PPUSH
33182: PPUSH
33183: PPUSH
33184: PPUSH
33185: PPUSH
33186: PPUSH
33187: PPUSH
33188: PPUSH
33189: PPUSH
33190: PPUSH
33191: PPUSH
33192: PPUSH
33193: PPUSH
33194: PPUSH
33195: PPUSH
33196: PPUSH
33197: PPUSH
33198: PPUSH
33199: PPUSH
33200: PPUSH
33201: PPUSH
33202: PPUSH
33203: PPUSH
33204: PPUSH
33205: PPUSH
33206: PPUSH
33207: PPUSH
33208: PPUSH
33209: PPUSH
33210: PPUSH
33211: PPUSH
33212: PPUSH
33213: PPUSH
33214: PPUSH
33215: PPUSH
33216: PPUSH
33217: PPUSH
33218: PPUSH
33219: PPUSH
33220: PPUSH
33221: PPUSH
33222: PPUSH
33223: PPUSH
33224: PPUSH
// result = [ ] ;
33225: LD_ADDR_VAR 0 7
33229: PUSH
33230: EMPTY
33231: ST_TO_ADDR
// temp_list = [ ] ;
33232: LD_ADDR_VAR 0 9
33236: PUSH
33237: EMPTY
33238: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
33239: LD_VAR 0 4
33243: PUSH
33244: LD_INT 0
33246: PUSH
33247: LD_INT 1
33249: PUSH
33250: LD_INT 2
33252: PUSH
33253: LD_INT 3
33255: PUSH
33256: LD_INT 4
33258: PUSH
33259: LD_INT 5
33261: PUSH
33262: EMPTY
33263: LIST
33264: LIST
33265: LIST
33266: LIST
33267: LIST
33268: LIST
33269: IN
33270: NOT
33271: PUSH
33272: LD_VAR 0 1
33276: PUSH
33277: LD_INT 0
33279: PUSH
33280: LD_INT 1
33282: PUSH
33283: EMPTY
33284: LIST
33285: LIST
33286: IN
33287: PUSH
33288: LD_VAR 0 5
33292: PUSH
33293: LD_INT 1
33295: PUSH
33296: LD_INT 2
33298: PUSH
33299: LD_INT 3
33301: PUSH
33302: EMPTY
33303: LIST
33304: LIST
33305: LIST
33306: IN
33307: NOT
33308: AND
33309: OR
33310: IFFALSE 33314
// exit ;
33312: GO 51705
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
33314: LD_VAR 0 1
33318: PUSH
33319: LD_INT 6
33321: PUSH
33322: LD_INT 7
33324: PUSH
33325: LD_INT 8
33327: PUSH
33328: LD_INT 13
33330: PUSH
33331: LD_INT 12
33333: PUSH
33334: LD_INT 15
33336: PUSH
33337: LD_INT 11
33339: PUSH
33340: LD_INT 14
33342: PUSH
33343: LD_INT 10
33345: PUSH
33346: EMPTY
33347: LIST
33348: LIST
33349: LIST
33350: LIST
33351: LIST
33352: LIST
33353: LIST
33354: LIST
33355: LIST
33356: IN
33357: IFFALSE 33367
// btype = b_lab ;
33359: LD_ADDR_VAR 0 1
33363: PUSH
33364: LD_INT 6
33366: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
33367: LD_VAR 0 6
33371: PUSH
33372: LD_INT 0
33374: PUSH
33375: LD_INT 1
33377: PUSH
33378: LD_INT 2
33380: PUSH
33381: EMPTY
33382: LIST
33383: LIST
33384: LIST
33385: IN
33386: NOT
33387: PUSH
33388: LD_VAR 0 1
33392: PUSH
33393: LD_INT 0
33395: PUSH
33396: LD_INT 1
33398: PUSH
33399: LD_INT 2
33401: PUSH
33402: LD_INT 3
33404: PUSH
33405: LD_INT 6
33407: PUSH
33408: LD_INT 36
33410: PUSH
33411: LD_INT 4
33413: PUSH
33414: LD_INT 5
33416: PUSH
33417: LD_INT 31
33419: PUSH
33420: LD_INT 32
33422: PUSH
33423: LD_INT 33
33425: PUSH
33426: EMPTY
33427: LIST
33428: LIST
33429: LIST
33430: LIST
33431: LIST
33432: LIST
33433: LIST
33434: LIST
33435: LIST
33436: LIST
33437: LIST
33438: IN
33439: NOT
33440: PUSH
33441: LD_VAR 0 6
33445: PUSH
33446: LD_INT 1
33448: EQUAL
33449: AND
33450: OR
33451: PUSH
33452: LD_VAR 0 1
33456: PUSH
33457: LD_INT 2
33459: PUSH
33460: LD_INT 3
33462: PUSH
33463: EMPTY
33464: LIST
33465: LIST
33466: IN
33467: NOT
33468: PUSH
33469: LD_VAR 0 6
33473: PUSH
33474: LD_INT 2
33476: EQUAL
33477: AND
33478: OR
33479: IFFALSE 33489
// mode = 0 ;
33481: LD_ADDR_VAR 0 6
33485: PUSH
33486: LD_INT 0
33488: ST_TO_ADDR
// case mode of 0 :
33489: LD_VAR 0 6
33493: PUSH
33494: LD_INT 0
33496: DOUBLE
33497: EQUAL
33498: IFTRUE 33502
33500: GO 44955
33502: POP
// begin fDepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
33503: LD_ADDR_VAR 0 11
33507: PUSH
33508: LD_INT 0
33510: PUSH
33511: LD_INT 0
33513: PUSH
33514: EMPTY
33515: LIST
33516: LIST
33517: PUSH
33518: LD_INT 0
33520: PUSH
33521: LD_INT 1
33523: NEG
33524: PUSH
33525: EMPTY
33526: LIST
33527: LIST
33528: PUSH
33529: LD_INT 1
33531: PUSH
33532: LD_INT 0
33534: PUSH
33535: EMPTY
33536: LIST
33537: LIST
33538: PUSH
33539: LD_INT 1
33541: PUSH
33542: LD_INT 1
33544: PUSH
33545: EMPTY
33546: LIST
33547: LIST
33548: PUSH
33549: LD_INT 0
33551: PUSH
33552: LD_INT 1
33554: PUSH
33555: EMPTY
33556: LIST
33557: LIST
33558: PUSH
33559: LD_INT 1
33561: NEG
33562: PUSH
33563: LD_INT 0
33565: PUSH
33566: EMPTY
33567: LIST
33568: LIST
33569: PUSH
33570: LD_INT 1
33572: NEG
33573: PUSH
33574: LD_INT 1
33576: NEG
33577: PUSH
33578: EMPTY
33579: LIST
33580: LIST
33581: PUSH
33582: LD_INT 1
33584: NEG
33585: PUSH
33586: LD_INT 2
33588: NEG
33589: PUSH
33590: EMPTY
33591: LIST
33592: LIST
33593: PUSH
33594: LD_INT 0
33596: PUSH
33597: LD_INT 2
33599: NEG
33600: PUSH
33601: EMPTY
33602: LIST
33603: LIST
33604: PUSH
33605: LD_INT 1
33607: PUSH
33608: LD_INT 1
33610: NEG
33611: PUSH
33612: EMPTY
33613: LIST
33614: LIST
33615: PUSH
33616: LD_INT 1
33618: PUSH
33619: LD_INT 2
33621: PUSH
33622: EMPTY
33623: LIST
33624: LIST
33625: PUSH
33626: LD_INT 0
33628: PUSH
33629: LD_INT 2
33631: PUSH
33632: EMPTY
33633: LIST
33634: LIST
33635: PUSH
33636: LD_INT 1
33638: NEG
33639: PUSH
33640: LD_INT 1
33642: PUSH
33643: EMPTY
33644: LIST
33645: LIST
33646: PUSH
33647: LD_INT 1
33649: PUSH
33650: LD_INT 3
33652: PUSH
33653: EMPTY
33654: LIST
33655: LIST
33656: PUSH
33657: LD_INT 0
33659: PUSH
33660: LD_INT 3
33662: PUSH
33663: EMPTY
33664: LIST
33665: LIST
33666: PUSH
33667: LD_INT 1
33669: NEG
33670: PUSH
33671: LD_INT 2
33673: PUSH
33674: EMPTY
33675: LIST
33676: LIST
33677: PUSH
33678: EMPTY
33679: LIST
33680: LIST
33681: LIST
33682: LIST
33683: LIST
33684: LIST
33685: LIST
33686: LIST
33687: LIST
33688: LIST
33689: LIST
33690: LIST
33691: LIST
33692: LIST
33693: LIST
33694: LIST
33695: ST_TO_ADDR
// fDepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
33696: LD_ADDR_VAR 0 12
33700: PUSH
33701: LD_INT 0
33703: PUSH
33704: LD_INT 0
33706: PUSH
33707: EMPTY
33708: LIST
33709: LIST
33710: PUSH
33711: LD_INT 0
33713: PUSH
33714: LD_INT 1
33716: NEG
33717: PUSH
33718: EMPTY
33719: LIST
33720: LIST
33721: PUSH
33722: LD_INT 1
33724: PUSH
33725: LD_INT 0
33727: PUSH
33728: EMPTY
33729: LIST
33730: LIST
33731: PUSH
33732: LD_INT 1
33734: PUSH
33735: LD_INT 1
33737: PUSH
33738: EMPTY
33739: LIST
33740: LIST
33741: PUSH
33742: LD_INT 0
33744: PUSH
33745: LD_INT 1
33747: PUSH
33748: EMPTY
33749: LIST
33750: LIST
33751: PUSH
33752: LD_INT 1
33754: NEG
33755: PUSH
33756: LD_INT 0
33758: PUSH
33759: EMPTY
33760: LIST
33761: LIST
33762: PUSH
33763: LD_INT 1
33765: NEG
33766: PUSH
33767: LD_INT 1
33769: NEG
33770: PUSH
33771: EMPTY
33772: LIST
33773: LIST
33774: PUSH
33775: LD_INT 1
33777: PUSH
33778: LD_INT 1
33780: NEG
33781: PUSH
33782: EMPTY
33783: LIST
33784: LIST
33785: PUSH
33786: LD_INT 2
33788: PUSH
33789: LD_INT 0
33791: PUSH
33792: EMPTY
33793: LIST
33794: LIST
33795: PUSH
33796: LD_INT 2
33798: PUSH
33799: LD_INT 1
33801: PUSH
33802: EMPTY
33803: LIST
33804: LIST
33805: PUSH
33806: LD_INT 1
33808: NEG
33809: PUSH
33810: LD_INT 1
33812: PUSH
33813: EMPTY
33814: LIST
33815: LIST
33816: PUSH
33817: LD_INT 2
33819: NEG
33820: PUSH
33821: LD_INT 0
33823: PUSH
33824: EMPTY
33825: LIST
33826: LIST
33827: PUSH
33828: LD_INT 2
33830: NEG
33831: PUSH
33832: LD_INT 1
33834: NEG
33835: PUSH
33836: EMPTY
33837: LIST
33838: LIST
33839: PUSH
33840: LD_INT 2
33842: NEG
33843: PUSH
33844: LD_INT 1
33846: PUSH
33847: EMPTY
33848: LIST
33849: LIST
33850: PUSH
33851: LD_INT 3
33853: NEG
33854: PUSH
33855: LD_INT 0
33857: PUSH
33858: EMPTY
33859: LIST
33860: LIST
33861: PUSH
33862: LD_INT 3
33864: NEG
33865: PUSH
33866: LD_INT 1
33868: NEG
33869: PUSH
33870: EMPTY
33871: LIST
33872: LIST
33873: PUSH
33874: EMPTY
33875: LIST
33876: LIST
33877: LIST
33878: LIST
33879: LIST
33880: LIST
33881: LIST
33882: LIST
33883: LIST
33884: LIST
33885: LIST
33886: LIST
33887: LIST
33888: LIST
33889: LIST
33890: LIST
33891: ST_TO_ADDR
// fDepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
33892: LD_ADDR_VAR 0 13
33896: PUSH
33897: LD_INT 0
33899: PUSH
33900: LD_INT 0
33902: PUSH
33903: EMPTY
33904: LIST
33905: LIST
33906: PUSH
33907: LD_INT 0
33909: PUSH
33910: LD_INT 1
33912: NEG
33913: PUSH
33914: EMPTY
33915: LIST
33916: LIST
33917: PUSH
33918: LD_INT 1
33920: PUSH
33921: LD_INT 0
33923: PUSH
33924: EMPTY
33925: LIST
33926: LIST
33927: PUSH
33928: LD_INT 1
33930: PUSH
33931: LD_INT 1
33933: PUSH
33934: EMPTY
33935: LIST
33936: LIST
33937: PUSH
33938: LD_INT 0
33940: PUSH
33941: LD_INT 1
33943: PUSH
33944: EMPTY
33945: LIST
33946: LIST
33947: PUSH
33948: LD_INT 1
33950: NEG
33951: PUSH
33952: LD_INT 0
33954: PUSH
33955: EMPTY
33956: LIST
33957: LIST
33958: PUSH
33959: LD_INT 1
33961: NEG
33962: PUSH
33963: LD_INT 1
33965: NEG
33966: PUSH
33967: EMPTY
33968: LIST
33969: LIST
33970: PUSH
33971: LD_INT 1
33973: NEG
33974: PUSH
33975: LD_INT 2
33977: NEG
33978: PUSH
33979: EMPTY
33980: LIST
33981: LIST
33982: PUSH
33983: LD_INT 2
33985: PUSH
33986: LD_INT 1
33988: PUSH
33989: EMPTY
33990: LIST
33991: LIST
33992: PUSH
33993: LD_INT 2
33995: PUSH
33996: LD_INT 2
33998: PUSH
33999: EMPTY
34000: LIST
34001: LIST
34002: PUSH
34003: LD_INT 1
34005: PUSH
34006: LD_INT 2
34008: PUSH
34009: EMPTY
34010: LIST
34011: LIST
34012: PUSH
34013: LD_INT 2
34015: NEG
34016: PUSH
34017: LD_INT 1
34019: NEG
34020: PUSH
34021: EMPTY
34022: LIST
34023: LIST
34024: PUSH
34025: LD_INT 2
34027: NEG
34028: PUSH
34029: LD_INT 2
34031: NEG
34032: PUSH
34033: EMPTY
34034: LIST
34035: LIST
34036: PUSH
34037: LD_INT 2
34039: NEG
34040: PUSH
34041: LD_INT 3
34043: NEG
34044: PUSH
34045: EMPTY
34046: LIST
34047: LIST
34048: PUSH
34049: LD_INT 3
34051: NEG
34052: PUSH
34053: LD_INT 2
34055: NEG
34056: PUSH
34057: EMPTY
34058: LIST
34059: LIST
34060: PUSH
34061: LD_INT 3
34063: NEG
34064: PUSH
34065: LD_INT 3
34067: NEG
34068: PUSH
34069: EMPTY
34070: LIST
34071: LIST
34072: PUSH
34073: EMPTY
34074: LIST
34075: LIST
34076: LIST
34077: LIST
34078: LIST
34079: LIST
34080: LIST
34081: LIST
34082: LIST
34083: LIST
34084: LIST
34085: LIST
34086: LIST
34087: LIST
34088: LIST
34089: LIST
34090: ST_TO_ADDR
// fDepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
34091: LD_ADDR_VAR 0 14
34095: PUSH
34096: LD_INT 0
34098: PUSH
34099: LD_INT 0
34101: PUSH
34102: EMPTY
34103: LIST
34104: LIST
34105: PUSH
34106: LD_INT 0
34108: PUSH
34109: LD_INT 1
34111: NEG
34112: PUSH
34113: EMPTY
34114: LIST
34115: LIST
34116: PUSH
34117: LD_INT 1
34119: PUSH
34120: LD_INT 0
34122: PUSH
34123: EMPTY
34124: LIST
34125: LIST
34126: PUSH
34127: LD_INT 1
34129: PUSH
34130: LD_INT 1
34132: PUSH
34133: EMPTY
34134: LIST
34135: LIST
34136: PUSH
34137: LD_INT 0
34139: PUSH
34140: LD_INT 1
34142: PUSH
34143: EMPTY
34144: LIST
34145: LIST
34146: PUSH
34147: LD_INT 1
34149: NEG
34150: PUSH
34151: LD_INT 0
34153: PUSH
34154: EMPTY
34155: LIST
34156: LIST
34157: PUSH
34158: LD_INT 1
34160: NEG
34161: PUSH
34162: LD_INT 1
34164: NEG
34165: PUSH
34166: EMPTY
34167: LIST
34168: LIST
34169: PUSH
34170: LD_INT 1
34172: NEG
34173: PUSH
34174: LD_INT 2
34176: NEG
34177: PUSH
34178: EMPTY
34179: LIST
34180: LIST
34181: PUSH
34182: LD_INT 0
34184: PUSH
34185: LD_INT 2
34187: NEG
34188: PUSH
34189: EMPTY
34190: LIST
34191: LIST
34192: PUSH
34193: LD_INT 1
34195: PUSH
34196: LD_INT 1
34198: NEG
34199: PUSH
34200: EMPTY
34201: LIST
34202: LIST
34203: PUSH
34204: LD_INT 1
34206: PUSH
34207: LD_INT 2
34209: PUSH
34210: EMPTY
34211: LIST
34212: LIST
34213: PUSH
34214: LD_INT 0
34216: PUSH
34217: LD_INT 2
34219: PUSH
34220: EMPTY
34221: LIST
34222: LIST
34223: PUSH
34224: LD_INT 1
34226: NEG
34227: PUSH
34228: LD_INT 1
34230: PUSH
34231: EMPTY
34232: LIST
34233: LIST
34234: PUSH
34235: LD_INT 1
34237: NEG
34238: PUSH
34239: LD_INT 3
34241: NEG
34242: PUSH
34243: EMPTY
34244: LIST
34245: LIST
34246: PUSH
34247: LD_INT 0
34249: PUSH
34250: LD_INT 3
34252: NEG
34253: PUSH
34254: EMPTY
34255: LIST
34256: LIST
34257: PUSH
34258: LD_INT 1
34260: PUSH
34261: LD_INT 2
34263: NEG
34264: PUSH
34265: EMPTY
34266: LIST
34267: LIST
34268: PUSH
34269: EMPTY
34270: LIST
34271: LIST
34272: LIST
34273: LIST
34274: LIST
34275: LIST
34276: LIST
34277: LIST
34278: LIST
34279: LIST
34280: LIST
34281: LIST
34282: LIST
34283: LIST
34284: LIST
34285: LIST
34286: ST_TO_ADDR
// fDepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
34287: LD_ADDR_VAR 0 15
34291: PUSH
34292: LD_INT 0
34294: PUSH
34295: LD_INT 0
34297: PUSH
34298: EMPTY
34299: LIST
34300: LIST
34301: PUSH
34302: LD_INT 0
34304: PUSH
34305: LD_INT 1
34307: NEG
34308: PUSH
34309: EMPTY
34310: LIST
34311: LIST
34312: PUSH
34313: LD_INT 1
34315: PUSH
34316: LD_INT 0
34318: PUSH
34319: EMPTY
34320: LIST
34321: LIST
34322: PUSH
34323: LD_INT 1
34325: PUSH
34326: LD_INT 1
34328: PUSH
34329: EMPTY
34330: LIST
34331: LIST
34332: PUSH
34333: LD_INT 0
34335: PUSH
34336: LD_INT 1
34338: PUSH
34339: EMPTY
34340: LIST
34341: LIST
34342: PUSH
34343: LD_INT 1
34345: NEG
34346: PUSH
34347: LD_INT 0
34349: PUSH
34350: EMPTY
34351: LIST
34352: LIST
34353: PUSH
34354: LD_INT 1
34356: NEG
34357: PUSH
34358: LD_INT 1
34360: NEG
34361: PUSH
34362: EMPTY
34363: LIST
34364: LIST
34365: PUSH
34366: LD_INT 1
34368: PUSH
34369: LD_INT 1
34371: NEG
34372: PUSH
34373: EMPTY
34374: LIST
34375: LIST
34376: PUSH
34377: LD_INT 2
34379: PUSH
34380: LD_INT 0
34382: PUSH
34383: EMPTY
34384: LIST
34385: LIST
34386: PUSH
34387: LD_INT 2
34389: PUSH
34390: LD_INT 1
34392: PUSH
34393: EMPTY
34394: LIST
34395: LIST
34396: PUSH
34397: LD_INT 1
34399: NEG
34400: PUSH
34401: LD_INT 1
34403: PUSH
34404: EMPTY
34405: LIST
34406: LIST
34407: PUSH
34408: LD_INT 2
34410: NEG
34411: PUSH
34412: LD_INT 0
34414: PUSH
34415: EMPTY
34416: LIST
34417: LIST
34418: PUSH
34419: LD_INT 2
34421: NEG
34422: PUSH
34423: LD_INT 1
34425: NEG
34426: PUSH
34427: EMPTY
34428: LIST
34429: LIST
34430: PUSH
34431: LD_INT 2
34433: PUSH
34434: LD_INT 1
34436: NEG
34437: PUSH
34438: EMPTY
34439: LIST
34440: LIST
34441: PUSH
34442: LD_INT 3
34444: PUSH
34445: LD_INT 0
34447: PUSH
34448: EMPTY
34449: LIST
34450: LIST
34451: PUSH
34452: LD_INT 3
34454: PUSH
34455: LD_INT 1
34457: PUSH
34458: EMPTY
34459: LIST
34460: LIST
34461: PUSH
34462: EMPTY
34463: LIST
34464: LIST
34465: LIST
34466: LIST
34467: LIST
34468: LIST
34469: LIST
34470: LIST
34471: LIST
34472: LIST
34473: LIST
34474: LIST
34475: LIST
34476: LIST
34477: LIST
34478: LIST
34479: ST_TO_ADDR
// fDepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
34480: LD_ADDR_VAR 0 16
34484: PUSH
34485: LD_INT 0
34487: PUSH
34488: LD_INT 0
34490: PUSH
34491: EMPTY
34492: LIST
34493: LIST
34494: PUSH
34495: LD_INT 0
34497: PUSH
34498: LD_INT 1
34500: NEG
34501: PUSH
34502: EMPTY
34503: LIST
34504: LIST
34505: PUSH
34506: LD_INT 1
34508: PUSH
34509: LD_INT 0
34511: PUSH
34512: EMPTY
34513: LIST
34514: LIST
34515: PUSH
34516: LD_INT 1
34518: PUSH
34519: LD_INT 1
34521: PUSH
34522: EMPTY
34523: LIST
34524: LIST
34525: PUSH
34526: LD_INT 0
34528: PUSH
34529: LD_INT 1
34531: PUSH
34532: EMPTY
34533: LIST
34534: LIST
34535: PUSH
34536: LD_INT 1
34538: NEG
34539: PUSH
34540: LD_INT 0
34542: PUSH
34543: EMPTY
34544: LIST
34545: LIST
34546: PUSH
34547: LD_INT 1
34549: NEG
34550: PUSH
34551: LD_INT 1
34553: NEG
34554: PUSH
34555: EMPTY
34556: LIST
34557: LIST
34558: PUSH
34559: LD_INT 1
34561: NEG
34562: PUSH
34563: LD_INT 2
34565: NEG
34566: PUSH
34567: EMPTY
34568: LIST
34569: LIST
34570: PUSH
34571: LD_INT 2
34573: PUSH
34574: LD_INT 1
34576: PUSH
34577: EMPTY
34578: LIST
34579: LIST
34580: PUSH
34581: LD_INT 2
34583: PUSH
34584: LD_INT 2
34586: PUSH
34587: EMPTY
34588: LIST
34589: LIST
34590: PUSH
34591: LD_INT 1
34593: PUSH
34594: LD_INT 2
34596: PUSH
34597: EMPTY
34598: LIST
34599: LIST
34600: PUSH
34601: LD_INT 2
34603: NEG
34604: PUSH
34605: LD_INT 1
34607: NEG
34608: PUSH
34609: EMPTY
34610: LIST
34611: LIST
34612: PUSH
34613: LD_INT 2
34615: NEG
34616: PUSH
34617: LD_INT 2
34619: NEG
34620: PUSH
34621: EMPTY
34622: LIST
34623: LIST
34624: PUSH
34625: LD_INT 3
34627: PUSH
34628: LD_INT 2
34630: PUSH
34631: EMPTY
34632: LIST
34633: LIST
34634: PUSH
34635: LD_INT 3
34637: PUSH
34638: LD_INT 3
34640: PUSH
34641: EMPTY
34642: LIST
34643: LIST
34644: PUSH
34645: LD_INT 2
34647: PUSH
34648: LD_INT 3
34650: PUSH
34651: EMPTY
34652: LIST
34653: LIST
34654: PUSH
34655: EMPTY
34656: LIST
34657: LIST
34658: LIST
34659: LIST
34660: LIST
34661: LIST
34662: LIST
34663: LIST
34664: LIST
34665: LIST
34666: LIST
34667: LIST
34668: LIST
34669: LIST
34670: LIST
34671: LIST
34672: ST_TO_ADDR
// fDepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
34673: LD_ADDR_VAR 0 17
34677: PUSH
34678: LD_INT 0
34680: PUSH
34681: LD_INT 0
34683: PUSH
34684: EMPTY
34685: LIST
34686: LIST
34687: PUSH
34688: LD_INT 0
34690: PUSH
34691: LD_INT 1
34693: NEG
34694: PUSH
34695: EMPTY
34696: LIST
34697: LIST
34698: PUSH
34699: LD_INT 1
34701: PUSH
34702: LD_INT 0
34704: PUSH
34705: EMPTY
34706: LIST
34707: LIST
34708: PUSH
34709: LD_INT 1
34711: PUSH
34712: LD_INT 1
34714: PUSH
34715: EMPTY
34716: LIST
34717: LIST
34718: PUSH
34719: LD_INT 0
34721: PUSH
34722: LD_INT 1
34724: PUSH
34725: EMPTY
34726: LIST
34727: LIST
34728: PUSH
34729: LD_INT 1
34731: NEG
34732: PUSH
34733: LD_INT 0
34735: PUSH
34736: EMPTY
34737: LIST
34738: LIST
34739: PUSH
34740: LD_INT 1
34742: NEG
34743: PUSH
34744: LD_INT 1
34746: NEG
34747: PUSH
34748: EMPTY
34749: LIST
34750: LIST
34751: PUSH
34752: LD_INT 1
34754: NEG
34755: PUSH
34756: LD_INT 2
34758: NEG
34759: PUSH
34760: EMPTY
34761: LIST
34762: LIST
34763: PUSH
34764: LD_INT 0
34766: PUSH
34767: LD_INT 2
34769: NEG
34770: PUSH
34771: EMPTY
34772: LIST
34773: LIST
34774: PUSH
34775: LD_INT 1
34777: PUSH
34778: LD_INT 1
34780: NEG
34781: PUSH
34782: EMPTY
34783: LIST
34784: LIST
34785: PUSH
34786: LD_INT 2
34788: PUSH
34789: LD_INT 0
34791: PUSH
34792: EMPTY
34793: LIST
34794: LIST
34795: PUSH
34796: LD_INT 2
34798: PUSH
34799: LD_INT 1
34801: PUSH
34802: EMPTY
34803: LIST
34804: LIST
34805: PUSH
34806: LD_INT 2
34808: PUSH
34809: LD_INT 2
34811: PUSH
34812: EMPTY
34813: LIST
34814: LIST
34815: PUSH
34816: LD_INT 1
34818: PUSH
34819: LD_INT 2
34821: PUSH
34822: EMPTY
34823: LIST
34824: LIST
34825: PUSH
34826: LD_INT 0
34828: PUSH
34829: LD_INT 2
34831: PUSH
34832: EMPTY
34833: LIST
34834: LIST
34835: PUSH
34836: LD_INT 1
34838: NEG
34839: PUSH
34840: LD_INT 1
34842: PUSH
34843: EMPTY
34844: LIST
34845: LIST
34846: PUSH
34847: LD_INT 2
34849: NEG
34850: PUSH
34851: LD_INT 0
34853: PUSH
34854: EMPTY
34855: LIST
34856: LIST
34857: PUSH
34858: LD_INT 2
34860: NEG
34861: PUSH
34862: LD_INT 1
34864: NEG
34865: PUSH
34866: EMPTY
34867: LIST
34868: LIST
34869: PUSH
34870: LD_INT 2
34872: NEG
34873: PUSH
34874: LD_INT 2
34876: NEG
34877: PUSH
34878: EMPTY
34879: LIST
34880: LIST
34881: PUSH
34882: EMPTY
34883: LIST
34884: LIST
34885: LIST
34886: LIST
34887: LIST
34888: LIST
34889: LIST
34890: LIST
34891: LIST
34892: LIST
34893: LIST
34894: LIST
34895: LIST
34896: LIST
34897: LIST
34898: LIST
34899: LIST
34900: LIST
34901: LIST
34902: ST_TO_ADDR
// fDepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
34903: LD_ADDR_VAR 0 18
34907: PUSH
34908: LD_INT 0
34910: PUSH
34911: LD_INT 0
34913: PUSH
34914: EMPTY
34915: LIST
34916: LIST
34917: PUSH
34918: LD_INT 0
34920: PUSH
34921: LD_INT 1
34923: NEG
34924: PUSH
34925: EMPTY
34926: LIST
34927: LIST
34928: PUSH
34929: LD_INT 1
34931: PUSH
34932: LD_INT 0
34934: PUSH
34935: EMPTY
34936: LIST
34937: LIST
34938: PUSH
34939: LD_INT 1
34941: PUSH
34942: LD_INT 1
34944: PUSH
34945: EMPTY
34946: LIST
34947: LIST
34948: PUSH
34949: LD_INT 0
34951: PUSH
34952: LD_INT 1
34954: PUSH
34955: EMPTY
34956: LIST
34957: LIST
34958: PUSH
34959: LD_INT 1
34961: NEG
34962: PUSH
34963: LD_INT 0
34965: PUSH
34966: EMPTY
34967: LIST
34968: LIST
34969: PUSH
34970: LD_INT 1
34972: NEG
34973: PUSH
34974: LD_INT 1
34976: NEG
34977: PUSH
34978: EMPTY
34979: LIST
34980: LIST
34981: PUSH
34982: LD_INT 1
34984: NEG
34985: PUSH
34986: LD_INT 2
34988: NEG
34989: PUSH
34990: EMPTY
34991: LIST
34992: LIST
34993: PUSH
34994: LD_INT 0
34996: PUSH
34997: LD_INT 2
34999: NEG
35000: PUSH
35001: EMPTY
35002: LIST
35003: LIST
35004: PUSH
35005: LD_INT 1
35007: PUSH
35008: LD_INT 1
35010: NEG
35011: PUSH
35012: EMPTY
35013: LIST
35014: LIST
35015: PUSH
35016: LD_INT 2
35018: PUSH
35019: LD_INT 0
35021: PUSH
35022: EMPTY
35023: LIST
35024: LIST
35025: PUSH
35026: LD_INT 2
35028: PUSH
35029: LD_INT 1
35031: PUSH
35032: EMPTY
35033: LIST
35034: LIST
35035: PUSH
35036: LD_INT 2
35038: PUSH
35039: LD_INT 2
35041: PUSH
35042: EMPTY
35043: LIST
35044: LIST
35045: PUSH
35046: LD_INT 1
35048: PUSH
35049: LD_INT 2
35051: PUSH
35052: EMPTY
35053: LIST
35054: LIST
35055: PUSH
35056: LD_INT 0
35058: PUSH
35059: LD_INT 2
35061: PUSH
35062: EMPTY
35063: LIST
35064: LIST
35065: PUSH
35066: LD_INT 1
35068: NEG
35069: PUSH
35070: LD_INT 1
35072: PUSH
35073: EMPTY
35074: LIST
35075: LIST
35076: PUSH
35077: LD_INT 2
35079: NEG
35080: PUSH
35081: LD_INT 0
35083: PUSH
35084: EMPTY
35085: LIST
35086: LIST
35087: PUSH
35088: LD_INT 2
35090: NEG
35091: PUSH
35092: LD_INT 1
35094: NEG
35095: PUSH
35096: EMPTY
35097: LIST
35098: LIST
35099: PUSH
35100: LD_INT 2
35102: NEG
35103: PUSH
35104: LD_INT 2
35106: NEG
35107: PUSH
35108: EMPTY
35109: LIST
35110: LIST
35111: PUSH
35112: EMPTY
35113: LIST
35114: LIST
35115: LIST
35116: LIST
35117: LIST
35118: LIST
35119: LIST
35120: LIST
35121: LIST
35122: LIST
35123: LIST
35124: LIST
35125: LIST
35126: LIST
35127: LIST
35128: LIST
35129: LIST
35130: LIST
35131: LIST
35132: ST_TO_ADDR
// fDepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
35133: LD_ADDR_VAR 0 19
35137: PUSH
35138: LD_INT 0
35140: PUSH
35141: LD_INT 0
35143: PUSH
35144: EMPTY
35145: LIST
35146: LIST
35147: PUSH
35148: LD_INT 0
35150: PUSH
35151: LD_INT 1
35153: NEG
35154: PUSH
35155: EMPTY
35156: LIST
35157: LIST
35158: PUSH
35159: LD_INT 1
35161: PUSH
35162: LD_INT 0
35164: PUSH
35165: EMPTY
35166: LIST
35167: LIST
35168: PUSH
35169: LD_INT 1
35171: PUSH
35172: LD_INT 1
35174: PUSH
35175: EMPTY
35176: LIST
35177: LIST
35178: PUSH
35179: LD_INT 0
35181: PUSH
35182: LD_INT 1
35184: PUSH
35185: EMPTY
35186: LIST
35187: LIST
35188: PUSH
35189: LD_INT 1
35191: NEG
35192: PUSH
35193: LD_INT 0
35195: PUSH
35196: EMPTY
35197: LIST
35198: LIST
35199: PUSH
35200: LD_INT 1
35202: NEG
35203: PUSH
35204: LD_INT 1
35206: NEG
35207: PUSH
35208: EMPTY
35209: LIST
35210: LIST
35211: PUSH
35212: LD_INT 1
35214: NEG
35215: PUSH
35216: LD_INT 2
35218: NEG
35219: PUSH
35220: EMPTY
35221: LIST
35222: LIST
35223: PUSH
35224: LD_INT 0
35226: PUSH
35227: LD_INT 2
35229: NEG
35230: PUSH
35231: EMPTY
35232: LIST
35233: LIST
35234: PUSH
35235: LD_INT 1
35237: PUSH
35238: LD_INT 1
35240: NEG
35241: PUSH
35242: EMPTY
35243: LIST
35244: LIST
35245: PUSH
35246: LD_INT 2
35248: PUSH
35249: LD_INT 0
35251: PUSH
35252: EMPTY
35253: LIST
35254: LIST
35255: PUSH
35256: LD_INT 2
35258: PUSH
35259: LD_INT 1
35261: PUSH
35262: EMPTY
35263: LIST
35264: LIST
35265: PUSH
35266: LD_INT 2
35268: PUSH
35269: LD_INT 2
35271: PUSH
35272: EMPTY
35273: LIST
35274: LIST
35275: PUSH
35276: LD_INT 1
35278: PUSH
35279: LD_INT 2
35281: PUSH
35282: EMPTY
35283: LIST
35284: LIST
35285: PUSH
35286: LD_INT 0
35288: PUSH
35289: LD_INT 2
35291: PUSH
35292: EMPTY
35293: LIST
35294: LIST
35295: PUSH
35296: LD_INT 1
35298: NEG
35299: PUSH
35300: LD_INT 1
35302: PUSH
35303: EMPTY
35304: LIST
35305: LIST
35306: PUSH
35307: LD_INT 2
35309: NEG
35310: PUSH
35311: LD_INT 0
35313: PUSH
35314: EMPTY
35315: LIST
35316: LIST
35317: PUSH
35318: LD_INT 2
35320: NEG
35321: PUSH
35322: LD_INT 1
35324: NEG
35325: PUSH
35326: EMPTY
35327: LIST
35328: LIST
35329: PUSH
35330: LD_INT 2
35332: NEG
35333: PUSH
35334: LD_INT 2
35336: NEG
35337: PUSH
35338: EMPTY
35339: LIST
35340: LIST
35341: PUSH
35342: EMPTY
35343: LIST
35344: LIST
35345: LIST
35346: LIST
35347: LIST
35348: LIST
35349: LIST
35350: LIST
35351: LIST
35352: LIST
35353: LIST
35354: LIST
35355: LIST
35356: LIST
35357: LIST
35358: LIST
35359: LIST
35360: LIST
35361: LIST
35362: ST_TO_ADDR
// fDepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
35363: LD_ADDR_VAR 0 20
35367: PUSH
35368: LD_INT 0
35370: PUSH
35371: LD_INT 0
35373: PUSH
35374: EMPTY
35375: LIST
35376: LIST
35377: PUSH
35378: LD_INT 0
35380: PUSH
35381: LD_INT 1
35383: NEG
35384: PUSH
35385: EMPTY
35386: LIST
35387: LIST
35388: PUSH
35389: LD_INT 1
35391: PUSH
35392: LD_INT 0
35394: PUSH
35395: EMPTY
35396: LIST
35397: LIST
35398: PUSH
35399: LD_INT 1
35401: PUSH
35402: LD_INT 1
35404: PUSH
35405: EMPTY
35406: LIST
35407: LIST
35408: PUSH
35409: LD_INT 0
35411: PUSH
35412: LD_INT 1
35414: PUSH
35415: EMPTY
35416: LIST
35417: LIST
35418: PUSH
35419: LD_INT 1
35421: NEG
35422: PUSH
35423: LD_INT 0
35425: PUSH
35426: EMPTY
35427: LIST
35428: LIST
35429: PUSH
35430: LD_INT 1
35432: NEG
35433: PUSH
35434: LD_INT 1
35436: NEG
35437: PUSH
35438: EMPTY
35439: LIST
35440: LIST
35441: PUSH
35442: LD_INT 1
35444: NEG
35445: PUSH
35446: LD_INT 2
35448: NEG
35449: PUSH
35450: EMPTY
35451: LIST
35452: LIST
35453: PUSH
35454: LD_INT 0
35456: PUSH
35457: LD_INT 2
35459: NEG
35460: PUSH
35461: EMPTY
35462: LIST
35463: LIST
35464: PUSH
35465: LD_INT 1
35467: PUSH
35468: LD_INT 1
35470: NEG
35471: PUSH
35472: EMPTY
35473: LIST
35474: LIST
35475: PUSH
35476: LD_INT 2
35478: PUSH
35479: LD_INT 0
35481: PUSH
35482: EMPTY
35483: LIST
35484: LIST
35485: PUSH
35486: LD_INT 2
35488: PUSH
35489: LD_INT 1
35491: PUSH
35492: EMPTY
35493: LIST
35494: LIST
35495: PUSH
35496: LD_INT 2
35498: PUSH
35499: LD_INT 2
35501: PUSH
35502: EMPTY
35503: LIST
35504: LIST
35505: PUSH
35506: LD_INT 1
35508: PUSH
35509: LD_INT 2
35511: PUSH
35512: EMPTY
35513: LIST
35514: LIST
35515: PUSH
35516: LD_INT 0
35518: PUSH
35519: LD_INT 2
35521: PUSH
35522: EMPTY
35523: LIST
35524: LIST
35525: PUSH
35526: LD_INT 1
35528: NEG
35529: PUSH
35530: LD_INT 1
35532: PUSH
35533: EMPTY
35534: LIST
35535: LIST
35536: PUSH
35537: LD_INT 2
35539: NEG
35540: PUSH
35541: LD_INT 0
35543: PUSH
35544: EMPTY
35545: LIST
35546: LIST
35547: PUSH
35548: LD_INT 2
35550: NEG
35551: PUSH
35552: LD_INT 1
35554: NEG
35555: PUSH
35556: EMPTY
35557: LIST
35558: LIST
35559: PUSH
35560: LD_INT 2
35562: NEG
35563: PUSH
35564: LD_INT 2
35566: NEG
35567: PUSH
35568: EMPTY
35569: LIST
35570: LIST
35571: PUSH
35572: EMPTY
35573: LIST
35574: LIST
35575: LIST
35576: LIST
35577: LIST
35578: LIST
35579: LIST
35580: LIST
35581: LIST
35582: LIST
35583: LIST
35584: LIST
35585: LIST
35586: LIST
35587: LIST
35588: LIST
35589: LIST
35590: LIST
35591: LIST
35592: ST_TO_ADDR
// fDepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
35593: LD_ADDR_VAR 0 21
35597: PUSH
35598: LD_INT 0
35600: PUSH
35601: LD_INT 0
35603: PUSH
35604: EMPTY
35605: LIST
35606: LIST
35607: PUSH
35608: LD_INT 0
35610: PUSH
35611: LD_INT 1
35613: NEG
35614: PUSH
35615: EMPTY
35616: LIST
35617: LIST
35618: PUSH
35619: LD_INT 1
35621: PUSH
35622: LD_INT 0
35624: PUSH
35625: EMPTY
35626: LIST
35627: LIST
35628: PUSH
35629: LD_INT 1
35631: PUSH
35632: LD_INT 1
35634: PUSH
35635: EMPTY
35636: LIST
35637: LIST
35638: PUSH
35639: LD_INT 0
35641: PUSH
35642: LD_INT 1
35644: PUSH
35645: EMPTY
35646: LIST
35647: LIST
35648: PUSH
35649: LD_INT 1
35651: NEG
35652: PUSH
35653: LD_INT 0
35655: PUSH
35656: EMPTY
35657: LIST
35658: LIST
35659: PUSH
35660: LD_INT 1
35662: NEG
35663: PUSH
35664: LD_INT 1
35666: NEG
35667: PUSH
35668: EMPTY
35669: LIST
35670: LIST
35671: PUSH
35672: LD_INT 1
35674: NEG
35675: PUSH
35676: LD_INT 2
35678: NEG
35679: PUSH
35680: EMPTY
35681: LIST
35682: LIST
35683: PUSH
35684: LD_INT 0
35686: PUSH
35687: LD_INT 2
35689: NEG
35690: PUSH
35691: EMPTY
35692: LIST
35693: LIST
35694: PUSH
35695: LD_INT 1
35697: PUSH
35698: LD_INT 1
35700: NEG
35701: PUSH
35702: EMPTY
35703: LIST
35704: LIST
35705: PUSH
35706: LD_INT 2
35708: PUSH
35709: LD_INT 0
35711: PUSH
35712: EMPTY
35713: LIST
35714: LIST
35715: PUSH
35716: LD_INT 2
35718: PUSH
35719: LD_INT 1
35721: PUSH
35722: EMPTY
35723: LIST
35724: LIST
35725: PUSH
35726: LD_INT 2
35728: PUSH
35729: LD_INT 2
35731: PUSH
35732: EMPTY
35733: LIST
35734: LIST
35735: PUSH
35736: LD_INT 1
35738: PUSH
35739: LD_INT 2
35741: PUSH
35742: EMPTY
35743: LIST
35744: LIST
35745: PUSH
35746: LD_INT 0
35748: PUSH
35749: LD_INT 2
35751: PUSH
35752: EMPTY
35753: LIST
35754: LIST
35755: PUSH
35756: LD_INT 1
35758: NEG
35759: PUSH
35760: LD_INT 1
35762: PUSH
35763: EMPTY
35764: LIST
35765: LIST
35766: PUSH
35767: LD_INT 2
35769: NEG
35770: PUSH
35771: LD_INT 0
35773: PUSH
35774: EMPTY
35775: LIST
35776: LIST
35777: PUSH
35778: LD_INT 2
35780: NEG
35781: PUSH
35782: LD_INT 1
35784: NEG
35785: PUSH
35786: EMPTY
35787: LIST
35788: LIST
35789: PUSH
35790: LD_INT 2
35792: NEG
35793: PUSH
35794: LD_INT 2
35796: NEG
35797: PUSH
35798: EMPTY
35799: LIST
35800: LIST
35801: PUSH
35802: EMPTY
35803: LIST
35804: LIST
35805: LIST
35806: LIST
35807: LIST
35808: LIST
35809: LIST
35810: LIST
35811: LIST
35812: LIST
35813: LIST
35814: LIST
35815: LIST
35816: LIST
35817: LIST
35818: LIST
35819: LIST
35820: LIST
35821: LIST
35822: ST_TO_ADDR
// fDepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
35823: LD_ADDR_VAR 0 22
35827: PUSH
35828: LD_INT 0
35830: PUSH
35831: LD_INT 0
35833: PUSH
35834: EMPTY
35835: LIST
35836: LIST
35837: PUSH
35838: LD_INT 0
35840: PUSH
35841: LD_INT 1
35843: NEG
35844: PUSH
35845: EMPTY
35846: LIST
35847: LIST
35848: PUSH
35849: LD_INT 1
35851: PUSH
35852: LD_INT 0
35854: PUSH
35855: EMPTY
35856: LIST
35857: LIST
35858: PUSH
35859: LD_INT 1
35861: PUSH
35862: LD_INT 1
35864: PUSH
35865: EMPTY
35866: LIST
35867: LIST
35868: PUSH
35869: LD_INT 0
35871: PUSH
35872: LD_INT 1
35874: PUSH
35875: EMPTY
35876: LIST
35877: LIST
35878: PUSH
35879: LD_INT 1
35881: NEG
35882: PUSH
35883: LD_INT 0
35885: PUSH
35886: EMPTY
35887: LIST
35888: LIST
35889: PUSH
35890: LD_INT 1
35892: NEG
35893: PUSH
35894: LD_INT 1
35896: NEG
35897: PUSH
35898: EMPTY
35899: LIST
35900: LIST
35901: PUSH
35902: LD_INT 1
35904: NEG
35905: PUSH
35906: LD_INT 2
35908: NEG
35909: PUSH
35910: EMPTY
35911: LIST
35912: LIST
35913: PUSH
35914: LD_INT 0
35916: PUSH
35917: LD_INT 2
35919: NEG
35920: PUSH
35921: EMPTY
35922: LIST
35923: LIST
35924: PUSH
35925: LD_INT 1
35927: PUSH
35928: LD_INT 1
35930: NEG
35931: PUSH
35932: EMPTY
35933: LIST
35934: LIST
35935: PUSH
35936: LD_INT 2
35938: PUSH
35939: LD_INT 0
35941: PUSH
35942: EMPTY
35943: LIST
35944: LIST
35945: PUSH
35946: LD_INT 2
35948: PUSH
35949: LD_INT 1
35951: PUSH
35952: EMPTY
35953: LIST
35954: LIST
35955: PUSH
35956: LD_INT 2
35958: PUSH
35959: LD_INT 2
35961: PUSH
35962: EMPTY
35963: LIST
35964: LIST
35965: PUSH
35966: LD_INT 1
35968: PUSH
35969: LD_INT 2
35971: PUSH
35972: EMPTY
35973: LIST
35974: LIST
35975: PUSH
35976: LD_INT 0
35978: PUSH
35979: LD_INT 2
35981: PUSH
35982: EMPTY
35983: LIST
35984: LIST
35985: PUSH
35986: LD_INT 1
35988: NEG
35989: PUSH
35990: LD_INT 1
35992: PUSH
35993: EMPTY
35994: LIST
35995: LIST
35996: PUSH
35997: LD_INT 2
35999: NEG
36000: PUSH
36001: LD_INT 0
36003: PUSH
36004: EMPTY
36005: LIST
36006: LIST
36007: PUSH
36008: LD_INT 2
36010: NEG
36011: PUSH
36012: LD_INT 1
36014: NEG
36015: PUSH
36016: EMPTY
36017: LIST
36018: LIST
36019: PUSH
36020: LD_INT 2
36022: NEG
36023: PUSH
36024: LD_INT 2
36026: NEG
36027: PUSH
36028: EMPTY
36029: LIST
36030: LIST
36031: PUSH
36032: EMPTY
36033: LIST
36034: LIST
36035: LIST
36036: LIST
36037: LIST
36038: LIST
36039: LIST
36040: LIST
36041: LIST
36042: LIST
36043: LIST
36044: LIST
36045: LIST
36046: LIST
36047: LIST
36048: LIST
36049: LIST
36050: LIST
36051: LIST
36052: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
36053: LD_ADDR_VAR 0 23
36057: PUSH
36058: LD_INT 0
36060: PUSH
36061: LD_INT 0
36063: PUSH
36064: EMPTY
36065: LIST
36066: LIST
36067: PUSH
36068: LD_INT 0
36070: PUSH
36071: LD_INT 1
36073: NEG
36074: PUSH
36075: EMPTY
36076: LIST
36077: LIST
36078: PUSH
36079: LD_INT 1
36081: PUSH
36082: LD_INT 0
36084: PUSH
36085: EMPTY
36086: LIST
36087: LIST
36088: PUSH
36089: LD_INT 1
36091: PUSH
36092: LD_INT 1
36094: PUSH
36095: EMPTY
36096: LIST
36097: LIST
36098: PUSH
36099: LD_INT 0
36101: PUSH
36102: LD_INT 1
36104: PUSH
36105: EMPTY
36106: LIST
36107: LIST
36108: PUSH
36109: LD_INT 1
36111: NEG
36112: PUSH
36113: LD_INT 0
36115: PUSH
36116: EMPTY
36117: LIST
36118: LIST
36119: PUSH
36120: LD_INT 1
36122: NEG
36123: PUSH
36124: LD_INT 1
36126: NEG
36127: PUSH
36128: EMPTY
36129: LIST
36130: LIST
36131: PUSH
36132: LD_INT 1
36134: NEG
36135: PUSH
36136: LD_INT 2
36138: NEG
36139: PUSH
36140: EMPTY
36141: LIST
36142: LIST
36143: PUSH
36144: LD_INT 0
36146: PUSH
36147: LD_INT 2
36149: NEG
36150: PUSH
36151: EMPTY
36152: LIST
36153: LIST
36154: PUSH
36155: LD_INT 1
36157: PUSH
36158: LD_INT 1
36160: NEG
36161: PUSH
36162: EMPTY
36163: LIST
36164: LIST
36165: PUSH
36166: LD_INT 2
36168: PUSH
36169: LD_INT 0
36171: PUSH
36172: EMPTY
36173: LIST
36174: LIST
36175: PUSH
36176: LD_INT 2
36178: PUSH
36179: LD_INT 1
36181: PUSH
36182: EMPTY
36183: LIST
36184: LIST
36185: PUSH
36186: LD_INT 2
36188: PUSH
36189: LD_INT 2
36191: PUSH
36192: EMPTY
36193: LIST
36194: LIST
36195: PUSH
36196: LD_INT 1
36198: PUSH
36199: LD_INT 2
36201: PUSH
36202: EMPTY
36203: LIST
36204: LIST
36205: PUSH
36206: LD_INT 0
36208: PUSH
36209: LD_INT 2
36211: PUSH
36212: EMPTY
36213: LIST
36214: LIST
36215: PUSH
36216: LD_INT 1
36218: NEG
36219: PUSH
36220: LD_INT 1
36222: PUSH
36223: EMPTY
36224: LIST
36225: LIST
36226: PUSH
36227: LD_INT 2
36229: NEG
36230: PUSH
36231: LD_INT 0
36233: PUSH
36234: EMPTY
36235: LIST
36236: LIST
36237: PUSH
36238: LD_INT 2
36240: NEG
36241: PUSH
36242: LD_INT 1
36244: NEG
36245: PUSH
36246: EMPTY
36247: LIST
36248: LIST
36249: PUSH
36250: LD_INT 2
36252: NEG
36253: PUSH
36254: LD_INT 2
36256: NEG
36257: PUSH
36258: EMPTY
36259: LIST
36260: LIST
36261: PUSH
36262: LD_INT 2
36264: NEG
36265: PUSH
36266: LD_INT 3
36268: NEG
36269: PUSH
36270: EMPTY
36271: LIST
36272: LIST
36273: PUSH
36274: LD_INT 1
36276: NEG
36277: PUSH
36278: LD_INT 3
36280: NEG
36281: PUSH
36282: EMPTY
36283: LIST
36284: LIST
36285: PUSH
36286: LD_INT 1
36288: PUSH
36289: LD_INT 2
36291: NEG
36292: PUSH
36293: EMPTY
36294: LIST
36295: LIST
36296: PUSH
36297: LD_INT 2
36299: PUSH
36300: LD_INT 1
36302: NEG
36303: PUSH
36304: EMPTY
36305: LIST
36306: LIST
36307: PUSH
36308: EMPTY
36309: LIST
36310: LIST
36311: LIST
36312: LIST
36313: LIST
36314: LIST
36315: LIST
36316: LIST
36317: LIST
36318: LIST
36319: LIST
36320: LIST
36321: LIST
36322: LIST
36323: LIST
36324: LIST
36325: LIST
36326: LIST
36327: LIST
36328: LIST
36329: LIST
36330: LIST
36331: LIST
36332: ST_TO_ADDR
// fDepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
36333: LD_ADDR_VAR 0 24
36337: PUSH
36338: LD_INT 0
36340: PUSH
36341: LD_INT 0
36343: PUSH
36344: EMPTY
36345: LIST
36346: LIST
36347: PUSH
36348: LD_INT 0
36350: PUSH
36351: LD_INT 1
36353: NEG
36354: PUSH
36355: EMPTY
36356: LIST
36357: LIST
36358: PUSH
36359: LD_INT 1
36361: PUSH
36362: LD_INT 0
36364: PUSH
36365: EMPTY
36366: LIST
36367: LIST
36368: PUSH
36369: LD_INT 1
36371: PUSH
36372: LD_INT 1
36374: PUSH
36375: EMPTY
36376: LIST
36377: LIST
36378: PUSH
36379: LD_INT 0
36381: PUSH
36382: LD_INT 1
36384: PUSH
36385: EMPTY
36386: LIST
36387: LIST
36388: PUSH
36389: LD_INT 1
36391: NEG
36392: PUSH
36393: LD_INT 0
36395: PUSH
36396: EMPTY
36397: LIST
36398: LIST
36399: PUSH
36400: LD_INT 1
36402: NEG
36403: PUSH
36404: LD_INT 1
36406: NEG
36407: PUSH
36408: EMPTY
36409: LIST
36410: LIST
36411: PUSH
36412: LD_INT 1
36414: NEG
36415: PUSH
36416: LD_INT 2
36418: NEG
36419: PUSH
36420: EMPTY
36421: LIST
36422: LIST
36423: PUSH
36424: LD_INT 0
36426: PUSH
36427: LD_INT 2
36429: NEG
36430: PUSH
36431: EMPTY
36432: LIST
36433: LIST
36434: PUSH
36435: LD_INT 1
36437: PUSH
36438: LD_INT 1
36440: NEG
36441: PUSH
36442: EMPTY
36443: LIST
36444: LIST
36445: PUSH
36446: LD_INT 2
36448: PUSH
36449: LD_INT 0
36451: PUSH
36452: EMPTY
36453: LIST
36454: LIST
36455: PUSH
36456: LD_INT 2
36458: PUSH
36459: LD_INT 1
36461: PUSH
36462: EMPTY
36463: LIST
36464: LIST
36465: PUSH
36466: LD_INT 2
36468: PUSH
36469: LD_INT 2
36471: PUSH
36472: EMPTY
36473: LIST
36474: LIST
36475: PUSH
36476: LD_INT 1
36478: PUSH
36479: LD_INT 2
36481: PUSH
36482: EMPTY
36483: LIST
36484: LIST
36485: PUSH
36486: LD_INT 0
36488: PUSH
36489: LD_INT 2
36491: PUSH
36492: EMPTY
36493: LIST
36494: LIST
36495: PUSH
36496: LD_INT 1
36498: NEG
36499: PUSH
36500: LD_INT 1
36502: PUSH
36503: EMPTY
36504: LIST
36505: LIST
36506: PUSH
36507: LD_INT 2
36509: NEG
36510: PUSH
36511: LD_INT 0
36513: PUSH
36514: EMPTY
36515: LIST
36516: LIST
36517: PUSH
36518: LD_INT 2
36520: NEG
36521: PUSH
36522: LD_INT 1
36524: NEG
36525: PUSH
36526: EMPTY
36527: LIST
36528: LIST
36529: PUSH
36530: LD_INT 2
36532: NEG
36533: PUSH
36534: LD_INT 2
36536: NEG
36537: PUSH
36538: EMPTY
36539: LIST
36540: LIST
36541: PUSH
36542: LD_INT 1
36544: PUSH
36545: LD_INT 2
36547: NEG
36548: PUSH
36549: EMPTY
36550: LIST
36551: LIST
36552: PUSH
36553: LD_INT 2
36555: PUSH
36556: LD_INT 1
36558: NEG
36559: PUSH
36560: EMPTY
36561: LIST
36562: LIST
36563: PUSH
36564: LD_INT 3
36566: PUSH
36567: LD_INT 1
36569: PUSH
36570: EMPTY
36571: LIST
36572: LIST
36573: PUSH
36574: LD_INT 3
36576: PUSH
36577: LD_INT 2
36579: PUSH
36580: EMPTY
36581: LIST
36582: LIST
36583: PUSH
36584: EMPTY
36585: LIST
36586: LIST
36587: LIST
36588: LIST
36589: LIST
36590: LIST
36591: LIST
36592: LIST
36593: LIST
36594: LIST
36595: LIST
36596: LIST
36597: LIST
36598: LIST
36599: LIST
36600: LIST
36601: LIST
36602: LIST
36603: LIST
36604: LIST
36605: LIST
36606: LIST
36607: LIST
36608: ST_TO_ADDR
// fDepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
36609: LD_ADDR_VAR 0 25
36613: PUSH
36614: LD_INT 0
36616: PUSH
36617: LD_INT 0
36619: PUSH
36620: EMPTY
36621: LIST
36622: LIST
36623: PUSH
36624: LD_INT 0
36626: PUSH
36627: LD_INT 1
36629: NEG
36630: PUSH
36631: EMPTY
36632: LIST
36633: LIST
36634: PUSH
36635: LD_INT 1
36637: PUSH
36638: LD_INT 0
36640: PUSH
36641: EMPTY
36642: LIST
36643: LIST
36644: PUSH
36645: LD_INT 1
36647: PUSH
36648: LD_INT 1
36650: PUSH
36651: EMPTY
36652: LIST
36653: LIST
36654: PUSH
36655: LD_INT 0
36657: PUSH
36658: LD_INT 1
36660: PUSH
36661: EMPTY
36662: LIST
36663: LIST
36664: PUSH
36665: LD_INT 1
36667: NEG
36668: PUSH
36669: LD_INT 0
36671: PUSH
36672: EMPTY
36673: LIST
36674: LIST
36675: PUSH
36676: LD_INT 1
36678: NEG
36679: PUSH
36680: LD_INT 1
36682: NEG
36683: PUSH
36684: EMPTY
36685: LIST
36686: LIST
36687: PUSH
36688: LD_INT 1
36690: NEG
36691: PUSH
36692: LD_INT 2
36694: NEG
36695: PUSH
36696: EMPTY
36697: LIST
36698: LIST
36699: PUSH
36700: LD_INT 0
36702: PUSH
36703: LD_INT 2
36705: NEG
36706: PUSH
36707: EMPTY
36708: LIST
36709: LIST
36710: PUSH
36711: LD_INT 1
36713: PUSH
36714: LD_INT 1
36716: NEG
36717: PUSH
36718: EMPTY
36719: LIST
36720: LIST
36721: PUSH
36722: LD_INT 2
36724: PUSH
36725: LD_INT 0
36727: PUSH
36728: EMPTY
36729: LIST
36730: LIST
36731: PUSH
36732: LD_INT 2
36734: PUSH
36735: LD_INT 1
36737: PUSH
36738: EMPTY
36739: LIST
36740: LIST
36741: PUSH
36742: LD_INT 2
36744: PUSH
36745: LD_INT 2
36747: PUSH
36748: EMPTY
36749: LIST
36750: LIST
36751: PUSH
36752: LD_INT 1
36754: PUSH
36755: LD_INT 2
36757: PUSH
36758: EMPTY
36759: LIST
36760: LIST
36761: PUSH
36762: LD_INT 0
36764: PUSH
36765: LD_INT 2
36767: PUSH
36768: EMPTY
36769: LIST
36770: LIST
36771: PUSH
36772: LD_INT 1
36774: NEG
36775: PUSH
36776: LD_INT 1
36778: PUSH
36779: EMPTY
36780: LIST
36781: LIST
36782: PUSH
36783: LD_INT 2
36785: NEG
36786: PUSH
36787: LD_INT 0
36789: PUSH
36790: EMPTY
36791: LIST
36792: LIST
36793: PUSH
36794: LD_INT 2
36796: NEG
36797: PUSH
36798: LD_INT 1
36800: NEG
36801: PUSH
36802: EMPTY
36803: LIST
36804: LIST
36805: PUSH
36806: LD_INT 2
36808: NEG
36809: PUSH
36810: LD_INT 2
36812: NEG
36813: PUSH
36814: EMPTY
36815: LIST
36816: LIST
36817: PUSH
36818: LD_INT 3
36820: PUSH
36821: LD_INT 1
36823: PUSH
36824: EMPTY
36825: LIST
36826: LIST
36827: PUSH
36828: LD_INT 3
36830: PUSH
36831: LD_INT 2
36833: PUSH
36834: EMPTY
36835: LIST
36836: LIST
36837: PUSH
36838: LD_INT 2
36840: PUSH
36841: LD_INT 3
36843: PUSH
36844: EMPTY
36845: LIST
36846: LIST
36847: PUSH
36848: LD_INT 1
36850: PUSH
36851: LD_INT 3
36853: PUSH
36854: EMPTY
36855: LIST
36856: LIST
36857: PUSH
36858: EMPTY
36859: LIST
36860: LIST
36861: LIST
36862: LIST
36863: LIST
36864: LIST
36865: LIST
36866: LIST
36867: LIST
36868: LIST
36869: LIST
36870: LIST
36871: LIST
36872: LIST
36873: LIST
36874: LIST
36875: LIST
36876: LIST
36877: LIST
36878: LIST
36879: LIST
36880: LIST
36881: LIST
36882: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
36883: LD_ADDR_VAR 0 26
36887: PUSH
36888: LD_INT 0
36890: PUSH
36891: LD_INT 0
36893: PUSH
36894: EMPTY
36895: LIST
36896: LIST
36897: PUSH
36898: LD_INT 0
36900: PUSH
36901: LD_INT 1
36903: NEG
36904: PUSH
36905: EMPTY
36906: LIST
36907: LIST
36908: PUSH
36909: LD_INT 1
36911: PUSH
36912: LD_INT 0
36914: PUSH
36915: EMPTY
36916: LIST
36917: LIST
36918: PUSH
36919: LD_INT 1
36921: PUSH
36922: LD_INT 1
36924: PUSH
36925: EMPTY
36926: LIST
36927: LIST
36928: PUSH
36929: LD_INT 0
36931: PUSH
36932: LD_INT 1
36934: PUSH
36935: EMPTY
36936: LIST
36937: LIST
36938: PUSH
36939: LD_INT 1
36941: NEG
36942: PUSH
36943: LD_INT 0
36945: PUSH
36946: EMPTY
36947: LIST
36948: LIST
36949: PUSH
36950: LD_INT 1
36952: NEG
36953: PUSH
36954: LD_INT 1
36956: NEG
36957: PUSH
36958: EMPTY
36959: LIST
36960: LIST
36961: PUSH
36962: LD_INT 1
36964: NEG
36965: PUSH
36966: LD_INT 2
36968: NEG
36969: PUSH
36970: EMPTY
36971: LIST
36972: LIST
36973: PUSH
36974: LD_INT 0
36976: PUSH
36977: LD_INT 2
36979: NEG
36980: PUSH
36981: EMPTY
36982: LIST
36983: LIST
36984: PUSH
36985: LD_INT 1
36987: PUSH
36988: LD_INT 1
36990: NEG
36991: PUSH
36992: EMPTY
36993: LIST
36994: LIST
36995: PUSH
36996: LD_INT 2
36998: PUSH
36999: LD_INT 0
37001: PUSH
37002: EMPTY
37003: LIST
37004: LIST
37005: PUSH
37006: LD_INT 2
37008: PUSH
37009: LD_INT 1
37011: PUSH
37012: EMPTY
37013: LIST
37014: LIST
37015: PUSH
37016: LD_INT 2
37018: PUSH
37019: LD_INT 2
37021: PUSH
37022: EMPTY
37023: LIST
37024: LIST
37025: PUSH
37026: LD_INT 1
37028: PUSH
37029: LD_INT 2
37031: PUSH
37032: EMPTY
37033: LIST
37034: LIST
37035: PUSH
37036: LD_INT 0
37038: PUSH
37039: LD_INT 2
37041: PUSH
37042: EMPTY
37043: LIST
37044: LIST
37045: PUSH
37046: LD_INT 1
37048: NEG
37049: PUSH
37050: LD_INT 1
37052: PUSH
37053: EMPTY
37054: LIST
37055: LIST
37056: PUSH
37057: LD_INT 2
37059: NEG
37060: PUSH
37061: LD_INT 0
37063: PUSH
37064: EMPTY
37065: LIST
37066: LIST
37067: PUSH
37068: LD_INT 2
37070: NEG
37071: PUSH
37072: LD_INT 1
37074: NEG
37075: PUSH
37076: EMPTY
37077: LIST
37078: LIST
37079: PUSH
37080: LD_INT 2
37082: NEG
37083: PUSH
37084: LD_INT 2
37086: NEG
37087: PUSH
37088: EMPTY
37089: LIST
37090: LIST
37091: PUSH
37092: LD_INT 2
37094: PUSH
37095: LD_INT 3
37097: PUSH
37098: EMPTY
37099: LIST
37100: LIST
37101: PUSH
37102: LD_INT 1
37104: PUSH
37105: LD_INT 3
37107: PUSH
37108: EMPTY
37109: LIST
37110: LIST
37111: PUSH
37112: LD_INT 1
37114: NEG
37115: PUSH
37116: LD_INT 2
37118: PUSH
37119: EMPTY
37120: LIST
37121: LIST
37122: PUSH
37123: LD_INT 2
37125: NEG
37126: PUSH
37127: LD_INT 1
37129: PUSH
37130: EMPTY
37131: LIST
37132: LIST
37133: PUSH
37134: EMPTY
37135: LIST
37136: LIST
37137: LIST
37138: LIST
37139: LIST
37140: LIST
37141: LIST
37142: LIST
37143: LIST
37144: LIST
37145: LIST
37146: LIST
37147: LIST
37148: LIST
37149: LIST
37150: LIST
37151: LIST
37152: LIST
37153: LIST
37154: LIST
37155: LIST
37156: LIST
37157: LIST
37158: ST_TO_ADDR
// fDepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
37159: LD_ADDR_VAR 0 27
37163: PUSH
37164: LD_INT 0
37166: PUSH
37167: LD_INT 0
37169: PUSH
37170: EMPTY
37171: LIST
37172: LIST
37173: PUSH
37174: LD_INT 0
37176: PUSH
37177: LD_INT 1
37179: NEG
37180: PUSH
37181: EMPTY
37182: LIST
37183: LIST
37184: PUSH
37185: LD_INT 1
37187: PUSH
37188: LD_INT 0
37190: PUSH
37191: EMPTY
37192: LIST
37193: LIST
37194: PUSH
37195: LD_INT 1
37197: PUSH
37198: LD_INT 1
37200: PUSH
37201: EMPTY
37202: LIST
37203: LIST
37204: PUSH
37205: LD_INT 0
37207: PUSH
37208: LD_INT 1
37210: PUSH
37211: EMPTY
37212: LIST
37213: LIST
37214: PUSH
37215: LD_INT 1
37217: NEG
37218: PUSH
37219: LD_INT 0
37221: PUSH
37222: EMPTY
37223: LIST
37224: LIST
37225: PUSH
37226: LD_INT 1
37228: NEG
37229: PUSH
37230: LD_INT 1
37232: NEG
37233: PUSH
37234: EMPTY
37235: LIST
37236: LIST
37237: PUSH
37238: LD_INT 1
37240: NEG
37241: PUSH
37242: LD_INT 2
37244: NEG
37245: PUSH
37246: EMPTY
37247: LIST
37248: LIST
37249: PUSH
37250: LD_INT 0
37252: PUSH
37253: LD_INT 2
37255: NEG
37256: PUSH
37257: EMPTY
37258: LIST
37259: LIST
37260: PUSH
37261: LD_INT 1
37263: PUSH
37264: LD_INT 1
37266: NEG
37267: PUSH
37268: EMPTY
37269: LIST
37270: LIST
37271: PUSH
37272: LD_INT 2
37274: PUSH
37275: LD_INT 0
37277: PUSH
37278: EMPTY
37279: LIST
37280: LIST
37281: PUSH
37282: LD_INT 2
37284: PUSH
37285: LD_INT 1
37287: PUSH
37288: EMPTY
37289: LIST
37290: LIST
37291: PUSH
37292: LD_INT 2
37294: PUSH
37295: LD_INT 2
37297: PUSH
37298: EMPTY
37299: LIST
37300: LIST
37301: PUSH
37302: LD_INT 1
37304: PUSH
37305: LD_INT 2
37307: PUSH
37308: EMPTY
37309: LIST
37310: LIST
37311: PUSH
37312: LD_INT 0
37314: PUSH
37315: LD_INT 2
37317: PUSH
37318: EMPTY
37319: LIST
37320: LIST
37321: PUSH
37322: LD_INT 1
37324: NEG
37325: PUSH
37326: LD_INT 1
37328: PUSH
37329: EMPTY
37330: LIST
37331: LIST
37332: PUSH
37333: LD_INT 2
37335: NEG
37336: PUSH
37337: LD_INT 0
37339: PUSH
37340: EMPTY
37341: LIST
37342: LIST
37343: PUSH
37344: LD_INT 2
37346: NEG
37347: PUSH
37348: LD_INT 1
37350: NEG
37351: PUSH
37352: EMPTY
37353: LIST
37354: LIST
37355: PUSH
37356: LD_INT 2
37358: NEG
37359: PUSH
37360: LD_INT 2
37362: NEG
37363: PUSH
37364: EMPTY
37365: LIST
37366: LIST
37367: PUSH
37368: LD_INT 1
37370: NEG
37371: PUSH
37372: LD_INT 2
37374: PUSH
37375: EMPTY
37376: LIST
37377: LIST
37378: PUSH
37379: LD_INT 2
37381: NEG
37382: PUSH
37383: LD_INT 1
37385: PUSH
37386: EMPTY
37387: LIST
37388: LIST
37389: PUSH
37390: LD_INT 3
37392: NEG
37393: PUSH
37394: LD_INT 1
37396: NEG
37397: PUSH
37398: EMPTY
37399: LIST
37400: LIST
37401: PUSH
37402: LD_INT 3
37404: NEG
37405: PUSH
37406: LD_INT 2
37408: NEG
37409: PUSH
37410: EMPTY
37411: LIST
37412: LIST
37413: PUSH
37414: EMPTY
37415: LIST
37416: LIST
37417: LIST
37418: LIST
37419: LIST
37420: LIST
37421: LIST
37422: LIST
37423: LIST
37424: LIST
37425: LIST
37426: LIST
37427: LIST
37428: LIST
37429: LIST
37430: LIST
37431: LIST
37432: LIST
37433: LIST
37434: LIST
37435: LIST
37436: LIST
37437: LIST
37438: ST_TO_ADDR
// fDepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
37439: LD_ADDR_VAR 0 28
37443: PUSH
37444: LD_INT 0
37446: PUSH
37447: LD_INT 0
37449: PUSH
37450: EMPTY
37451: LIST
37452: LIST
37453: PUSH
37454: LD_INT 0
37456: PUSH
37457: LD_INT 1
37459: NEG
37460: PUSH
37461: EMPTY
37462: LIST
37463: LIST
37464: PUSH
37465: LD_INT 1
37467: PUSH
37468: LD_INT 0
37470: PUSH
37471: EMPTY
37472: LIST
37473: LIST
37474: PUSH
37475: LD_INT 1
37477: PUSH
37478: LD_INT 1
37480: PUSH
37481: EMPTY
37482: LIST
37483: LIST
37484: PUSH
37485: LD_INT 0
37487: PUSH
37488: LD_INT 1
37490: PUSH
37491: EMPTY
37492: LIST
37493: LIST
37494: PUSH
37495: LD_INT 1
37497: NEG
37498: PUSH
37499: LD_INT 0
37501: PUSH
37502: EMPTY
37503: LIST
37504: LIST
37505: PUSH
37506: LD_INT 1
37508: NEG
37509: PUSH
37510: LD_INT 1
37512: NEG
37513: PUSH
37514: EMPTY
37515: LIST
37516: LIST
37517: PUSH
37518: LD_INT 1
37520: NEG
37521: PUSH
37522: LD_INT 2
37524: NEG
37525: PUSH
37526: EMPTY
37527: LIST
37528: LIST
37529: PUSH
37530: LD_INT 0
37532: PUSH
37533: LD_INT 2
37535: NEG
37536: PUSH
37537: EMPTY
37538: LIST
37539: LIST
37540: PUSH
37541: LD_INT 1
37543: PUSH
37544: LD_INT 1
37546: NEG
37547: PUSH
37548: EMPTY
37549: LIST
37550: LIST
37551: PUSH
37552: LD_INT 2
37554: PUSH
37555: LD_INT 0
37557: PUSH
37558: EMPTY
37559: LIST
37560: LIST
37561: PUSH
37562: LD_INT 2
37564: PUSH
37565: LD_INT 1
37567: PUSH
37568: EMPTY
37569: LIST
37570: LIST
37571: PUSH
37572: LD_INT 2
37574: PUSH
37575: LD_INT 2
37577: PUSH
37578: EMPTY
37579: LIST
37580: LIST
37581: PUSH
37582: LD_INT 1
37584: PUSH
37585: LD_INT 2
37587: PUSH
37588: EMPTY
37589: LIST
37590: LIST
37591: PUSH
37592: LD_INT 0
37594: PUSH
37595: LD_INT 2
37597: PUSH
37598: EMPTY
37599: LIST
37600: LIST
37601: PUSH
37602: LD_INT 1
37604: NEG
37605: PUSH
37606: LD_INT 1
37608: PUSH
37609: EMPTY
37610: LIST
37611: LIST
37612: PUSH
37613: LD_INT 2
37615: NEG
37616: PUSH
37617: LD_INT 0
37619: PUSH
37620: EMPTY
37621: LIST
37622: LIST
37623: PUSH
37624: LD_INT 2
37626: NEG
37627: PUSH
37628: LD_INT 1
37630: NEG
37631: PUSH
37632: EMPTY
37633: LIST
37634: LIST
37635: PUSH
37636: LD_INT 2
37638: NEG
37639: PUSH
37640: LD_INT 2
37642: NEG
37643: PUSH
37644: EMPTY
37645: LIST
37646: LIST
37647: PUSH
37648: LD_INT 2
37650: NEG
37651: PUSH
37652: LD_INT 3
37654: NEG
37655: PUSH
37656: EMPTY
37657: LIST
37658: LIST
37659: PUSH
37660: LD_INT 1
37662: NEG
37663: PUSH
37664: LD_INT 3
37666: NEG
37667: PUSH
37668: EMPTY
37669: LIST
37670: LIST
37671: PUSH
37672: LD_INT 3
37674: NEG
37675: PUSH
37676: LD_INT 1
37678: NEG
37679: PUSH
37680: EMPTY
37681: LIST
37682: LIST
37683: PUSH
37684: LD_INT 3
37686: NEG
37687: PUSH
37688: LD_INT 2
37690: NEG
37691: PUSH
37692: EMPTY
37693: LIST
37694: LIST
37695: PUSH
37696: EMPTY
37697: LIST
37698: LIST
37699: LIST
37700: LIST
37701: LIST
37702: LIST
37703: LIST
37704: LIST
37705: LIST
37706: LIST
37707: LIST
37708: LIST
37709: LIST
37710: LIST
37711: LIST
37712: LIST
37713: LIST
37714: LIST
37715: LIST
37716: LIST
37717: LIST
37718: LIST
37719: LIST
37720: ST_TO_ADDR
// fFactory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
37721: LD_ADDR_VAR 0 29
37725: PUSH
37726: LD_INT 0
37728: PUSH
37729: LD_INT 0
37731: PUSH
37732: EMPTY
37733: LIST
37734: LIST
37735: PUSH
37736: LD_INT 0
37738: PUSH
37739: LD_INT 1
37741: NEG
37742: PUSH
37743: EMPTY
37744: LIST
37745: LIST
37746: PUSH
37747: LD_INT 1
37749: PUSH
37750: LD_INT 0
37752: PUSH
37753: EMPTY
37754: LIST
37755: LIST
37756: PUSH
37757: LD_INT 1
37759: PUSH
37760: LD_INT 1
37762: PUSH
37763: EMPTY
37764: LIST
37765: LIST
37766: PUSH
37767: LD_INT 0
37769: PUSH
37770: LD_INT 1
37772: PUSH
37773: EMPTY
37774: LIST
37775: LIST
37776: PUSH
37777: LD_INT 1
37779: NEG
37780: PUSH
37781: LD_INT 0
37783: PUSH
37784: EMPTY
37785: LIST
37786: LIST
37787: PUSH
37788: LD_INT 1
37790: NEG
37791: PUSH
37792: LD_INT 1
37794: NEG
37795: PUSH
37796: EMPTY
37797: LIST
37798: LIST
37799: PUSH
37800: LD_INT 1
37802: NEG
37803: PUSH
37804: LD_INT 2
37806: NEG
37807: PUSH
37808: EMPTY
37809: LIST
37810: LIST
37811: PUSH
37812: LD_INT 0
37814: PUSH
37815: LD_INT 2
37817: NEG
37818: PUSH
37819: EMPTY
37820: LIST
37821: LIST
37822: PUSH
37823: LD_INT 1
37825: PUSH
37826: LD_INT 1
37828: NEG
37829: PUSH
37830: EMPTY
37831: LIST
37832: LIST
37833: PUSH
37834: LD_INT 2
37836: PUSH
37837: LD_INT 0
37839: PUSH
37840: EMPTY
37841: LIST
37842: LIST
37843: PUSH
37844: LD_INT 2
37846: PUSH
37847: LD_INT 1
37849: PUSH
37850: EMPTY
37851: LIST
37852: LIST
37853: PUSH
37854: LD_INT 1
37856: PUSH
37857: LD_INT 2
37859: PUSH
37860: EMPTY
37861: LIST
37862: LIST
37863: PUSH
37864: LD_INT 0
37866: PUSH
37867: LD_INT 2
37869: PUSH
37870: EMPTY
37871: LIST
37872: LIST
37873: PUSH
37874: LD_INT 1
37876: NEG
37877: PUSH
37878: LD_INT 1
37880: PUSH
37881: EMPTY
37882: LIST
37883: LIST
37884: PUSH
37885: LD_INT 2
37887: NEG
37888: PUSH
37889: LD_INT 1
37891: NEG
37892: PUSH
37893: EMPTY
37894: LIST
37895: LIST
37896: PUSH
37897: LD_INT 2
37899: NEG
37900: PUSH
37901: LD_INT 2
37903: NEG
37904: PUSH
37905: EMPTY
37906: LIST
37907: LIST
37908: PUSH
37909: LD_INT 2
37911: NEG
37912: PUSH
37913: LD_INT 3
37915: NEG
37916: PUSH
37917: EMPTY
37918: LIST
37919: LIST
37920: PUSH
37921: LD_INT 2
37923: PUSH
37924: LD_INT 1
37926: NEG
37927: PUSH
37928: EMPTY
37929: LIST
37930: LIST
37931: PUSH
37932: LD_INT 3
37934: PUSH
37935: LD_INT 1
37937: PUSH
37938: EMPTY
37939: LIST
37940: LIST
37941: PUSH
37942: LD_INT 1
37944: PUSH
37945: LD_INT 3
37947: PUSH
37948: EMPTY
37949: LIST
37950: LIST
37951: PUSH
37952: LD_INT 1
37954: NEG
37955: PUSH
37956: LD_INT 2
37958: PUSH
37959: EMPTY
37960: LIST
37961: LIST
37962: PUSH
37963: LD_INT 3
37965: NEG
37966: PUSH
37967: LD_INT 2
37969: NEG
37970: PUSH
37971: EMPTY
37972: LIST
37973: LIST
37974: PUSH
37975: EMPTY
37976: LIST
37977: LIST
37978: LIST
37979: LIST
37980: LIST
37981: LIST
37982: LIST
37983: LIST
37984: LIST
37985: LIST
37986: LIST
37987: LIST
37988: LIST
37989: LIST
37990: LIST
37991: LIST
37992: LIST
37993: LIST
37994: LIST
37995: LIST
37996: LIST
37997: LIST
37998: LIST
37999: ST_TO_ADDR
// fFactory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
38000: LD_ADDR_VAR 0 30
38004: PUSH
38005: LD_INT 0
38007: PUSH
38008: LD_INT 0
38010: PUSH
38011: EMPTY
38012: LIST
38013: LIST
38014: PUSH
38015: LD_INT 0
38017: PUSH
38018: LD_INT 1
38020: NEG
38021: PUSH
38022: EMPTY
38023: LIST
38024: LIST
38025: PUSH
38026: LD_INT 1
38028: PUSH
38029: LD_INT 0
38031: PUSH
38032: EMPTY
38033: LIST
38034: LIST
38035: PUSH
38036: LD_INT 1
38038: PUSH
38039: LD_INT 1
38041: PUSH
38042: EMPTY
38043: LIST
38044: LIST
38045: PUSH
38046: LD_INT 0
38048: PUSH
38049: LD_INT 1
38051: PUSH
38052: EMPTY
38053: LIST
38054: LIST
38055: PUSH
38056: LD_INT 1
38058: NEG
38059: PUSH
38060: LD_INT 0
38062: PUSH
38063: EMPTY
38064: LIST
38065: LIST
38066: PUSH
38067: LD_INT 1
38069: NEG
38070: PUSH
38071: LD_INT 1
38073: NEG
38074: PUSH
38075: EMPTY
38076: LIST
38077: LIST
38078: PUSH
38079: LD_INT 1
38081: NEG
38082: PUSH
38083: LD_INT 2
38085: NEG
38086: PUSH
38087: EMPTY
38088: LIST
38089: LIST
38090: PUSH
38091: LD_INT 0
38093: PUSH
38094: LD_INT 2
38096: NEG
38097: PUSH
38098: EMPTY
38099: LIST
38100: LIST
38101: PUSH
38102: LD_INT 1
38104: PUSH
38105: LD_INT 1
38107: NEG
38108: PUSH
38109: EMPTY
38110: LIST
38111: LIST
38112: PUSH
38113: LD_INT 2
38115: PUSH
38116: LD_INT 0
38118: PUSH
38119: EMPTY
38120: LIST
38121: LIST
38122: PUSH
38123: LD_INT 2
38125: PUSH
38126: LD_INT 1
38128: PUSH
38129: EMPTY
38130: LIST
38131: LIST
38132: PUSH
38133: LD_INT 2
38135: PUSH
38136: LD_INT 2
38138: PUSH
38139: EMPTY
38140: LIST
38141: LIST
38142: PUSH
38143: LD_INT 1
38145: PUSH
38146: LD_INT 2
38148: PUSH
38149: EMPTY
38150: LIST
38151: LIST
38152: PUSH
38153: LD_INT 1
38155: NEG
38156: PUSH
38157: LD_INT 1
38159: PUSH
38160: EMPTY
38161: LIST
38162: LIST
38163: PUSH
38164: LD_INT 2
38166: NEG
38167: PUSH
38168: LD_INT 0
38170: PUSH
38171: EMPTY
38172: LIST
38173: LIST
38174: PUSH
38175: LD_INT 2
38177: NEG
38178: PUSH
38179: LD_INT 1
38181: NEG
38182: PUSH
38183: EMPTY
38184: LIST
38185: LIST
38186: PUSH
38187: LD_INT 1
38189: NEG
38190: PUSH
38191: LD_INT 3
38193: NEG
38194: PUSH
38195: EMPTY
38196: LIST
38197: LIST
38198: PUSH
38199: LD_INT 1
38201: PUSH
38202: LD_INT 2
38204: NEG
38205: PUSH
38206: EMPTY
38207: LIST
38208: LIST
38209: PUSH
38210: LD_INT 3
38212: PUSH
38213: LD_INT 2
38215: PUSH
38216: EMPTY
38217: LIST
38218: LIST
38219: PUSH
38220: LD_INT 2
38222: PUSH
38223: LD_INT 3
38225: PUSH
38226: EMPTY
38227: LIST
38228: LIST
38229: PUSH
38230: LD_INT 2
38232: NEG
38233: PUSH
38234: LD_INT 1
38236: PUSH
38237: EMPTY
38238: LIST
38239: LIST
38240: PUSH
38241: LD_INT 3
38243: NEG
38244: PUSH
38245: LD_INT 1
38247: NEG
38248: PUSH
38249: EMPTY
38250: LIST
38251: LIST
38252: PUSH
38253: EMPTY
38254: LIST
38255: LIST
38256: LIST
38257: LIST
38258: LIST
38259: LIST
38260: LIST
38261: LIST
38262: LIST
38263: LIST
38264: LIST
38265: LIST
38266: LIST
38267: LIST
38268: LIST
38269: LIST
38270: LIST
38271: LIST
38272: LIST
38273: LIST
38274: LIST
38275: LIST
38276: LIST
38277: ST_TO_ADDR
// fFactory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
38278: LD_ADDR_VAR 0 31
38282: PUSH
38283: LD_INT 0
38285: PUSH
38286: LD_INT 0
38288: PUSH
38289: EMPTY
38290: LIST
38291: LIST
38292: PUSH
38293: LD_INT 0
38295: PUSH
38296: LD_INT 1
38298: NEG
38299: PUSH
38300: EMPTY
38301: LIST
38302: LIST
38303: PUSH
38304: LD_INT 1
38306: PUSH
38307: LD_INT 0
38309: PUSH
38310: EMPTY
38311: LIST
38312: LIST
38313: PUSH
38314: LD_INT 1
38316: PUSH
38317: LD_INT 1
38319: PUSH
38320: EMPTY
38321: LIST
38322: LIST
38323: PUSH
38324: LD_INT 0
38326: PUSH
38327: LD_INT 1
38329: PUSH
38330: EMPTY
38331: LIST
38332: LIST
38333: PUSH
38334: LD_INT 1
38336: NEG
38337: PUSH
38338: LD_INT 0
38340: PUSH
38341: EMPTY
38342: LIST
38343: LIST
38344: PUSH
38345: LD_INT 1
38347: NEG
38348: PUSH
38349: LD_INT 1
38351: NEG
38352: PUSH
38353: EMPTY
38354: LIST
38355: LIST
38356: PUSH
38357: LD_INT 1
38359: NEG
38360: PUSH
38361: LD_INT 2
38363: NEG
38364: PUSH
38365: EMPTY
38366: LIST
38367: LIST
38368: PUSH
38369: LD_INT 1
38371: PUSH
38372: LD_INT 1
38374: NEG
38375: PUSH
38376: EMPTY
38377: LIST
38378: LIST
38379: PUSH
38380: LD_INT 2
38382: PUSH
38383: LD_INT 0
38385: PUSH
38386: EMPTY
38387: LIST
38388: LIST
38389: PUSH
38390: LD_INT 2
38392: PUSH
38393: LD_INT 1
38395: PUSH
38396: EMPTY
38397: LIST
38398: LIST
38399: PUSH
38400: LD_INT 2
38402: PUSH
38403: LD_INT 2
38405: PUSH
38406: EMPTY
38407: LIST
38408: LIST
38409: PUSH
38410: LD_INT 1
38412: PUSH
38413: LD_INT 2
38415: PUSH
38416: EMPTY
38417: LIST
38418: LIST
38419: PUSH
38420: LD_INT 0
38422: PUSH
38423: LD_INT 2
38425: PUSH
38426: EMPTY
38427: LIST
38428: LIST
38429: PUSH
38430: LD_INT 1
38432: NEG
38433: PUSH
38434: LD_INT 1
38436: PUSH
38437: EMPTY
38438: LIST
38439: LIST
38440: PUSH
38441: LD_INT 2
38443: NEG
38444: PUSH
38445: LD_INT 1
38447: NEG
38448: PUSH
38449: EMPTY
38450: LIST
38451: LIST
38452: PUSH
38453: LD_INT 2
38455: NEG
38456: PUSH
38457: LD_INT 2
38459: NEG
38460: PUSH
38461: EMPTY
38462: LIST
38463: LIST
38464: PUSH
38465: LD_INT 2
38467: NEG
38468: PUSH
38469: LD_INT 3
38471: NEG
38472: PUSH
38473: EMPTY
38474: LIST
38475: LIST
38476: PUSH
38477: LD_INT 2
38479: PUSH
38480: LD_INT 1
38482: NEG
38483: PUSH
38484: EMPTY
38485: LIST
38486: LIST
38487: PUSH
38488: LD_INT 3
38490: PUSH
38491: LD_INT 1
38493: PUSH
38494: EMPTY
38495: LIST
38496: LIST
38497: PUSH
38498: LD_INT 1
38500: PUSH
38501: LD_INT 3
38503: PUSH
38504: EMPTY
38505: LIST
38506: LIST
38507: PUSH
38508: LD_INT 1
38510: NEG
38511: PUSH
38512: LD_INT 2
38514: PUSH
38515: EMPTY
38516: LIST
38517: LIST
38518: PUSH
38519: LD_INT 3
38521: NEG
38522: PUSH
38523: LD_INT 2
38525: NEG
38526: PUSH
38527: EMPTY
38528: LIST
38529: LIST
38530: PUSH
38531: EMPTY
38532: LIST
38533: LIST
38534: LIST
38535: LIST
38536: LIST
38537: LIST
38538: LIST
38539: LIST
38540: LIST
38541: LIST
38542: LIST
38543: LIST
38544: LIST
38545: LIST
38546: LIST
38547: LIST
38548: LIST
38549: LIST
38550: LIST
38551: LIST
38552: LIST
38553: LIST
38554: LIST
38555: ST_TO_ADDR
// fFactory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
38556: LD_ADDR_VAR 0 32
38560: PUSH
38561: LD_INT 0
38563: PUSH
38564: LD_INT 0
38566: PUSH
38567: EMPTY
38568: LIST
38569: LIST
38570: PUSH
38571: LD_INT 0
38573: PUSH
38574: LD_INT 1
38576: NEG
38577: PUSH
38578: EMPTY
38579: LIST
38580: LIST
38581: PUSH
38582: LD_INT 1
38584: PUSH
38585: LD_INT 0
38587: PUSH
38588: EMPTY
38589: LIST
38590: LIST
38591: PUSH
38592: LD_INT 1
38594: PUSH
38595: LD_INT 1
38597: PUSH
38598: EMPTY
38599: LIST
38600: LIST
38601: PUSH
38602: LD_INT 0
38604: PUSH
38605: LD_INT 1
38607: PUSH
38608: EMPTY
38609: LIST
38610: LIST
38611: PUSH
38612: LD_INT 1
38614: NEG
38615: PUSH
38616: LD_INT 0
38618: PUSH
38619: EMPTY
38620: LIST
38621: LIST
38622: PUSH
38623: LD_INT 1
38625: NEG
38626: PUSH
38627: LD_INT 1
38629: NEG
38630: PUSH
38631: EMPTY
38632: LIST
38633: LIST
38634: PUSH
38635: LD_INT 1
38637: NEG
38638: PUSH
38639: LD_INT 2
38641: NEG
38642: PUSH
38643: EMPTY
38644: LIST
38645: LIST
38646: PUSH
38647: LD_INT 0
38649: PUSH
38650: LD_INT 2
38652: NEG
38653: PUSH
38654: EMPTY
38655: LIST
38656: LIST
38657: PUSH
38658: LD_INT 1
38660: PUSH
38661: LD_INT 1
38663: NEG
38664: PUSH
38665: EMPTY
38666: LIST
38667: LIST
38668: PUSH
38669: LD_INT 2
38671: PUSH
38672: LD_INT 1
38674: PUSH
38675: EMPTY
38676: LIST
38677: LIST
38678: PUSH
38679: LD_INT 2
38681: PUSH
38682: LD_INT 2
38684: PUSH
38685: EMPTY
38686: LIST
38687: LIST
38688: PUSH
38689: LD_INT 1
38691: PUSH
38692: LD_INT 2
38694: PUSH
38695: EMPTY
38696: LIST
38697: LIST
38698: PUSH
38699: LD_INT 0
38701: PUSH
38702: LD_INT 2
38704: PUSH
38705: EMPTY
38706: LIST
38707: LIST
38708: PUSH
38709: LD_INT 1
38711: NEG
38712: PUSH
38713: LD_INT 1
38715: PUSH
38716: EMPTY
38717: LIST
38718: LIST
38719: PUSH
38720: LD_INT 2
38722: NEG
38723: PUSH
38724: LD_INT 0
38726: PUSH
38727: EMPTY
38728: LIST
38729: LIST
38730: PUSH
38731: LD_INT 2
38733: NEG
38734: PUSH
38735: LD_INT 1
38737: NEG
38738: PUSH
38739: EMPTY
38740: LIST
38741: LIST
38742: PUSH
38743: LD_INT 1
38745: NEG
38746: PUSH
38747: LD_INT 3
38749: NEG
38750: PUSH
38751: EMPTY
38752: LIST
38753: LIST
38754: PUSH
38755: LD_INT 1
38757: PUSH
38758: LD_INT 2
38760: NEG
38761: PUSH
38762: EMPTY
38763: LIST
38764: LIST
38765: PUSH
38766: LD_INT 3
38768: PUSH
38769: LD_INT 2
38771: PUSH
38772: EMPTY
38773: LIST
38774: LIST
38775: PUSH
38776: LD_INT 2
38778: PUSH
38779: LD_INT 3
38781: PUSH
38782: EMPTY
38783: LIST
38784: LIST
38785: PUSH
38786: LD_INT 2
38788: NEG
38789: PUSH
38790: LD_INT 1
38792: PUSH
38793: EMPTY
38794: LIST
38795: LIST
38796: PUSH
38797: LD_INT 3
38799: NEG
38800: PUSH
38801: LD_INT 1
38803: NEG
38804: PUSH
38805: EMPTY
38806: LIST
38807: LIST
38808: PUSH
38809: EMPTY
38810: LIST
38811: LIST
38812: LIST
38813: LIST
38814: LIST
38815: LIST
38816: LIST
38817: LIST
38818: LIST
38819: LIST
38820: LIST
38821: LIST
38822: LIST
38823: LIST
38824: LIST
38825: LIST
38826: LIST
38827: LIST
38828: LIST
38829: LIST
38830: LIST
38831: LIST
38832: LIST
38833: ST_TO_ADDR
// fFactory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
38834: LD_ADDR_VAR 0 33
38838: PUSH
38839: LD_INT 0
38841: PUSH
38842: LD_INT 0
38844: PUSH
38845: EMPTY
38846: LIST
38847: LIST
38848: PUSH
38849: LD_INT 0
38851: PUSH
38852: LD_INT 1
38854: NEG
38855: PUSH
38856: EMPTY
38857: LIST
38858: LIST
38859: PUSH
38860: LD_INT 1
38862: PUSH
38863: LD_INT 0
38865: PUSH
38866: EMPTY
38867: LIST
38868: LIST
38869: PUSH
38870: LD_INT 1
38872: PUSH
38873: LD_INT 1
38875: PUSH
38876: EMPTY
38877: LIST
38878: LIST
38879: PUSH
38880: LD_INT 0
38882: PUSH
38883: LD_INT 1
38885: PUSH
38886: EMPTY
38887: LIST
38888: LIST
38889: PUSH
38890: LD_INT 1
38892: NEG
38893: PUSH
38894: LD_INT 0
38896: PUSH
38897: EMPTY
38898: LIST
38899: LIST
38900: PUSH
38901: LD_INT 1
38903: NEG
38904: PUSH
38905: LD_INT 1
38907: NEG
38908: PUSH
38909: EMPTY
38910: LIST
38911: LIST
38912: PUSH
38913: LD_INT 1
38915: NEG
38916: PUSH
38917: LD_INT 2
38919: NEG
38920: PUSH
38921: EMPTY
38922: LIST
38923: LIST
38924: PUSH
38925: LD_INT 1
38927: PUSH
38928: LD_INT 1
38930: NEG
38931: PUSH
38932: EMPTY
38933: LIST
38934: LIST
38935: PUSH
38936: LD_INT 2
38938: PUSH
38939: LD_INT 0
38941: PUSH
38942: EMPTY
38943: LIST
38944: LIST
38945: PUSH
38946: LD_INT 2
38948: PUSH
38949: LD_INT 1
38951: PUSH
38952: EMPTY
38953: LIST
38954: LIST
38955: PUSH
38956: LD_INT 1
38958: PUSH
38959: LD_INT 2
38961: PUSH
38962: EMPTY
38963: LIST
38964: LIST
38965: PUSH
38966: LD_INT 0
38968: PUSH
38969: LD_INT 2
38971: PUSH
38972: EMPTY
38973: LIST
38974: LIST
38975: PUSH
38976: LD_INT 1
38978: NEG
38979: PUSH
38980: LD_INT 1
38982: PUSH
38983: EMPTY
38984: LIST
38985: LIST
38986: PUSH
38987: LD_INT 2
38989: NEG
38990: PUSH
38991: LD_INT 0
38993: PUSH
38994: EMPTY
38995: LIST
38996: LIST
38997: PUSH
38998: LD_INT 2
39000: NEG
39001: PUSH
39002: LD_INT 1
39004: NEG
39005: PUSH
39006: EMPTY
39007: LIST
39008: LIST
39009: PUSH
39010: LD_INT 2
39012: NEG
39013: PUSH
39014: LD_INT 2
39016: NEG
39017: PUSH
39018: EMPTY
39019: LIST
39020: LIST
39021: PUSH
39022: LD_INT 2
39024: NEG
39025: PUSH
39026: LD_INT 3
39028: NEG
39029: PUSH
39030: EMPTY
39031: LIST
39032: LIST
39033: PUSH
39034: LD_INT 2
39036: PUSH
39037: LD_INT 1
39039: NEG
39040: PUSH
39041: EMPTY
39042: LIST
39043: LIST
39044: PUSH
39045: LD_INT 3
39047: PUSH
39048: LD_INT 1
39050: PUSH
39051: EMPTY
39052: LIST
39053: LIST
39054: PUSH
39055: LD_INT 1
39057: PUSH
39058: LD_INT 3
39060: PUSH
39061: EMPTY
39062: LIST
39063: LIST
39064: PUSH
39065: LD_INT 1
39067: NEG
39068: PUSH
39069: LD_INT 2
39071: PUSH
39072: EMPTY
39073: LIST
39074: LIST
39075: PUSH
39076: LD_INT 3
39078: NEG
39079: PUSH
39080: LD_INT 2
39082: NEG
39083: PUSH
39084: EMPTY
39085: LIST
39086: LIST
39087: PUSH
39088: EMPTY
39089: LIST
39090: LIST
39091: LIST
39092: LIST
39093: LIST
39094: LIST
39095: LIST
39096: LIST
39097: LIST
39098: LIST
39099: LIST
39100: LIST
39101: LIST
39102: LIST
39103: LIST
39104: LIST
39105: LIST
39106: LIST
39107: LIST
39108: LIST
39109: LIST
39110: LIST
39111: LIST
39112: ST_TO_ADDR
// fFactory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
39113: LD_ADDR_VAR 0 34
39117: PUSH
39118: LD_INT 0
39120: PUSH
39121: LD_INT 0
39123: PUSH
39124: EMPTY
39125: LIST
39126: LIST
39127: PUSH
39128: LD_INT 0
39130: PUSH
39131: LD_INT 1
39133: NEG
39134: PUSH
39135: EMPTY
39136: LIST
39137: LIST
39138: PUSH
39139: LD_INT 1
39141: PUSH
39142: LD_INT 0
39144: PUSH
39145: EMPTY
39146: LIST
39147: LIST
39148: PUSH
39149: LD_INT 1
39151: PUSH
39152: LD_INT 1
39154: PUSH
39155: EMPTY
39156: LIST
39157: LIST
39158: PUSH
39159: LD_INT 0
39161: PUSH
39162: LD_INT 1
39164: PUSH
39165: EMPTY
39166: LIST
39167: LIST
39168: PUSH
39169: LD_INT 1
39171: NEG
39172: PUSH
39173: LD_INT 0
39175: PUSH
39176: EMPTY
39177: LIST
39178: LIST
39179: PUSH
39180: LD_INT 1
39182: NEG
39183: PUSH
39184: LD_INT 1
39186: NEG
39187: PUSH
39188: EMPTY
39189: LIST
39190: LIST
39191: PUSH
39192: LD_INT 1
39194: NEG
39195: PUSH
39196: LD_INT 2
39198: NEG
39199: PUSH
39200: EMPTY
39201: LIST
39202: LIST
39203: PUSH
39204: LD_INT 0
39206: PUSH
39207: LD_INT 2
39209: NEG
39210: PUSH
39211: EMPTY
39212: LIST
39213: LIST
39214: PUSH
39215: LD_INT 1
39217: PUSH
39218: LD_INT 1
39220: NEG
39221: PUSH
39222: EMPTY
39223: LIST
39224: LIST
39225: PUSH
39226: LD_INT 2
39228: PUSH
39229: LD_INT 1
39231: PUSH
39232: EMPTY
39233: LIST
39234: LIST
39235: PUSH
39236: LD_INT 2
39238: PUSH
39239: LD_INT 2
39241: PUSH
39242: EMPTY
39243: LIST
39244: LIST
39245: PUSH
39246: LD_INT 1
39248: PUSH
39249: LD_INT 2
39251: PUSH
39252: EMPTY
39253: LIST
39254: LIST
39255: PUSH
39256: LD_INT 1
39258: NEG
39259: PUSH
39260: LD_INT 1
39262: PUSH
39263: EMPTY
39264: LIST
39265: LIST
39266: PUSH
39267: LD_INT 2
39269: NEG
39270: PUSH
39271: LD_INT 0
39273: PUSH
39274: EMPTY
39275: LIST
39276: LIST
39277: PUSH
39278: LD_INT 2
39280: NEG
39281: PUSH
39282: LD_INT 1
39284: NEG
39285: PUSH
39286: EMPTY
39287: LIST
39288: LIST
39289: PUSH
39290: LD_INT 2
39292: NEG
39293: PUSH
39294: LD_INT 2
39296: NEG
39297: PUSH
39298: EMPTY
39299: LIST
39300: LIST
39301: PUSH
39302: LD_INT 1
39304: NEG
39305: PUSH
39306: LD_INT 3
39308: NEG
39309: PUSH
39310: EMPTY
39311: LIST
39312: LIST
39313: PUSH
39314: LD_INT 1
39316: PUSH
39317: LD_INT 2
39319: NEG
39320: PUSH
39321: EMPTY
39322: LIST
39323: LIST
39324: PUSH
39325: LD_INT 3
39327: PUSH
39328: LD_INT 2
39330: PUSH
39331: EMPTY
39332: LIST
39333: LIST
39334: PUSH
39335: LD_INT 2
39337: PUSH
39338: LD_INT 3
39340: PUSH
39341: EMPTY
39342: LIST
39343: LIST
39344: PUSH
39345: LD_INT 2
39347: NEG
39348: PUSH
39349: LD_INT 1
39351: PUSH
39352: EMPTY
39353: LIST
39354: LIST
39355: PUSH
39356: LD_INT 3
39358: NEG
39359: PUSH
39360: LD_INT 1
39362: NEG
39363: PUSH
39364: EMPTY
39365: LIST
39366: LIST
39367: PUSH
39368: EMPTY
39369: LIST
39370: LIST
39371: LIST
39372: LIST
39373: LIST
39374: LIST
39375: LIST
39376: LIST
39377: LIST
39378: LIST
39379: LIST
39380: LIST
39381: LIST
39382: LIST
39383: LIST
39384: LIST
39385: LIST
39386: LIST
39387: LIST
39388: LIST
39389: LIST
39390: LIST
39391: LIST
39392: ST_TO_ADDR
// fExt0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
39393: LD_ADDR_VAR 0 35
39397: PUSH
39398: LD_INT 0
39400: PUSH
39401: LD_INT 0
39403: PUSH
39404: EMPTY
39405: LIST
39406: LIST
39407: PUSH
39408: LD_INT 0
39410: PUSH
39411: LD_INT 1
39413: NEG
39414: PUSH
39415: EMPTY
39416: LIST
39417: LIST
39418: PUSH
39419: LD_INT 1
39421: PUSH
39422: LD_INT 0
39424: PUSH
39425: EMPTY
39426: LIST
39427: LIST
39428: PUSH
39429: LD_INT 1
39431: PUSH
39432: LD_INT 1
39434: PUSH
39435: EMPTY
39436: LIST
39437: LIST
39438: PUSH
39439: LD_INT 0
39441: PUSH
39442: LD_INT 1
39444: PUSH
39445: EMPTY
39446: LIST
39447: LIST
39448: PUSH
39449: LD_INT 1
39451: NEG
39452: PUSH
39453: LD_INT 0
39455: PUSH
39456: EMPTY
39457: LIST
39458: LIST
39459: PUSH
39460: LD_INT 1
39462: NEG
39463: PUSH
39464: LD_INT 1
39466: NEG
39467: PUSH
39468: EMPTY
39469: LIST
39470: LIST
39471: PUSH
39472: LD_INT 2
39474: PUSH
39475: LD_INT 1
39477: PUSH
39478: EMPTY
39479: LIST
39480: LIST
39481: PUSH
39482: LD_INT 2
39484: NEG
39485: PUSH
39486: LD_INT 1
39488: NEG
39489: PUSH
39490: EMPTY
39491: LIST
39492: LIST
39493: PUSH
39494: EMPTY
39495: LIST
39496: LIST
39497: LIST
39498: LIST
39499: LIST
39500: LIST
39501: LIST
39502: LIST
39503: LIST
39504: ST_TO_ADDR
// fExt1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
39505: LD_ADDR_VAR 0 36
39509: PUSH
39510: LD_INT 0
39512: PUSH
39513: LD_INT 0
39515: PUSH
39516: EMPTY
39517: LIST
39518: LIST
39519: PUSH
39520: LD_INT 0
39522: PUSH
39523: LD_INT 1
39525: NEG
39526: PUSH
39527: EMPTY
39528: LIST
39529: LIST
39530: PUSH
39531: LD_INT 1
39533: PUSH
39534: LD_INT 0
39536: PUSH
39537: EMPTY
39538: LIST
39539: LIST
39540: PUSH
39541: LD_INT 1
39543: PUSH
39544: LD_INT 1
39546: PUSH
39547: EMPTY
39548: LIST
39549: LIST
39550: PUSH
39551: LD_INT 0
39553: PUSH
39554: LD_INT 1
39556: PUSH
39557: EMPTY
39558: LIST
39559: LIST
39560: PUSH
39561: LD_INT 1
39563: NEG
39564: PUSH
39565: LD_INT 0
39567: PUSH
39568: EMPTY
39569: LIST
39570: LIST
39571: PUSH
39572: LD_INT 1
39574: NEG
39575: PUSH
39576: LD_INT 1
39578: NEG
39579: PUSH
39580: EMPTY
39581: LIST
39582: LIST
39583: PUSH
39584: LD_INT 1
39586: NEG
39587: PUSH
39588: LD_INT 2
39590: NEG
39591: PUSH
39592: EMPTY
39593: LIST
39594: LIST
39595: PUSH
39596: LD_INT 1
39598: PUSH
39599: LD_INT 2
39601: PUSH
39602: EMPTY
39603: LIST
39604: LIST
39605: PUSH
39606: EMPTY
39607: LIST
39608: LIST
39609: LIST
39610: LIST
39611: LIST
39612: LIST
39613: LIST
39614: LIST
39615: LIST
39616: ST_TO_ADDR
// fExt2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
39617: LD_ADDR_VAR 0 37
39621: PUSH
39622: LD_INT 0
39624: PUSH
39625: LD_INT 0
39627: PUSH
39628: EMPTY
39629: LIST
39630: LIST
39631: PUSH
39632: LD_INT 0
39634: PUSH
39635: LD_INT 1
39637: NEG
39638: PUSH
39639: EMPTY
39640: LIST
39641: LIST
39642: PUSH
39643: LD_INT 1
39645: PUSH
39646: LD_INT 0
39648: PUSH
39649: EMPTY
39650: LIST
39651: LIST
39652: PUSH
39653: LD_INT 1
39655: PUSH
39656: LD_INT 1
39658: PUSH
39659: EMPTY
39660: LIST
39661: LIST
39662: PUSH
39663: LD_INT 0
39665: PUSH
39666: LD_INT 1
39668: PUSH
39669: EMPTY
39670: LIST
39671: LIST
39672: PUSH
39673: LD_INT 1
39675: NEG
39676: PUSH
39677: LD_INT 0
39679: PUSH
39680: EMPTY
39681: LIST
39682: LIST
39683: PUSH
39684: LD_INT 1
39686: NEG
39687: PUSH
39688: LD_INT 1
39690: NEG
39691: PUSH
39692: EMPTY
39693: LIST
39694: LIST
39695: PUSH
39696: LD_INT 1
39698: PUSH
39699: LD_INT 1
39701: NEG
39702: PUSH
39703: EMPTY
39704: LIST
39705: LIST
39706: PUSH
39707: LD_INT 1
39709: NEG
39710: PUSH
39711: LD_INT 1
39713: PUSH
39714: EMPTY
39715: LIST
39716: LIST
39717: PUSH
39718: EMPTY
39719: LIST
39720: LIST
39721: LIST
39722: LIST
39723: LIST
39724: LIST
39725: LIST
39726: LIST
39727: LIST
39728: ST_TO_ADDR
// fExt3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
39729: LD_ADDR_VAR 0 38
39733: PUSH
39734: LD_INT 0
39736: PUSH
39737: LD_INT 0
39739: PUSH
39740: EMPTY
39741: LIST
39742: LIST
39743: PUSH
39744: LD_INT 0
39746: PUSH
39747: LD_INT 1
39749: NEG
39750: PUSH
39751: EMPTY
39752: LIST
39753: LIST
39754: PUSH
39755: LD_INT 1
39757: PUSH
39758: LD_INT 0
39760: PUSH
39761: EMPTY
39762: LIST
39763: LIST
39764: PUSH
39765: LD_INT 1
39767: PUSH
39768: LD_INT 1
39770: PUSH
39771: EMPTY
39772: LIST
39773: LIST
39774: PUSH
39775: LD_INT 0
39777: PUSH
39778: LD_INT 1
39780: PUSH
39781: EMPTY
39782: LIST
39783: LIST
39784: PUSH
39785: LD_INT 1
39787: NEG
39788: PUSH
39789: LD_INT 0
39791: PUSH
39792: EMPTY
39793: LIST
39794: LIST
39795: PUSH
39796: LD_INT 1
39798: NEG
39799: PUSH
39800: LD_INT 1
39802: NEG
39803: PUSH
39804: EMPTY
39805: LIST
39806: LIST
39807: PUSH
39808: LD_INT 2
39810: PUSH
39811: LD_INT 1
39813: PUSH
39814: EMPTY
39815: LIST
39816: LIST
39817: PUSH
39818: LD_INT 2
39820: NEG
39821: PUSH
39822: LD_INT 1
39824: NEG
39825: PUSH
39826: EMPTY
39827: LIST
39828: LIST
39829: PUSH
39830: EMPTY
39831: LIST
39832: LIST
39833: LIST
39834: LIST
39835: LIST
39836: LIST
39837: LIST
39838: LIST
39839: LIST
39840: ST_TO_ADDR
// fExt4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
39841: LD_ADDR_VAR 0 39
39845: PUSH
39846: LD_INT 0
39848: PUSH
39849: LD_INT 0
39851: PUSH
39852: EMPTY
39853: LIST
39854: LIST
39855: PUSH
39856: LD_INT 0
39858: PUSH
39859: LD_INT 1
39861: NEG
39862: PUSH
39863: EMPTY
39864: LIST
39865: LIST
39866: PUSH
39867: LD_INT 1
39869: PUSH
39870: LD_INT 0
39872: PUSH
39873: EMPTY
39874: LIST
39875: LIST
39876: PUSH
39877: LD_INT 1
39879: PUSH
39880: LD_INT 1
39882: PUSH
39883: EMPTY
39884: LIST
39885: LIST
39886: PUSH
39887: LD_INT 0
39889: PUSH
39890: LD_INT 1
39892: PUSH
39893: EMPTY
39894: LIST
39895: LIST
39896: PUSH
39897: LD_INT 1
39899: NEG
39900: PUSH
39901: LD_INT 0
39903: PUSH
39904: EMPTY
39905: LIST
39906: LIST
39907: PUSH
39908: LD_INT 1
39910: NEG
39911: PUSH
39912: LD_INT 1
39914: NEG
39915: PUSH
39916: EMPTY
39917: LIST
39918: LIST
39919: PUSH
39920: LD_INT 1
39922: NEG
39923: PUSH
39924: LD_INT 2
39926: NEG
39927: PUSH
39928: EMPTY
39929: LIST
39930: LIST
39931: PUSH
39932: LD_INT 1
39934: PUSH
39935: LD_INT 2
39937: PUSH
39938: EMPTY
39939: LIST
39940: LIST
39941: PUSH
39942: EMPTY
39943: LIST
39944: LIST
39945: LIST
39946: LIST
39947: LIST
39948: LIST
39949: LIST
39950: LIST
39951: LIST
39952: ST_TO_ADDR
// fExt5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
39953: LD_ADDR_VAR 0 40
39957: PUSH
39958: LD_INT 0
39960: PUSH
39961: LD_INT 0
39963: PUSH
39964: EMPTY
39965: LIST
39966: LIST
39967: PUSH
39968: LD_INT 0
39970: PUSH
39971: LD_INT 1
39973: NEG
39974: PUSH
39975: EMPTY
39976: LIST
39977: LIST
39978: PUSH
39979: LD_INT 1
39981: PUSH
39982: LD_INT 0
39984: PUSH
39985: EMPTY
39986: LIST
39987: LIST
39988: PUSH
39989: LD_INT 1
39991: PUSH
39992: LD_INT 1
39994: PUSH
39995: EMPTY
39996: LIST
39997: LIST
39998: PUSH
39999: LD_INT 0
40001: PUSH
40002: LD_INT 1
40004: PUSH
40005: EMPTY
40006: LIST
40007: LIST
40008: PUSH
40009: LD_INT 1
40011: NEG
40012: PUSH
40013: LD_INT 0
40015: PUSH
40016: EMPTY
40017: LIST
40018: LIST
40019: PUSH
40020: LD_INT 1
40022: NEG
40023: PUSH
40024: LD_INT 1
40026: NEG
40027: PUSH
40028: EMPTY
40029: LIST
40030: LIST
40031: PUSH
40032: LD_INT 1
40034: PUSH
40035: LD_INT 1
40037: NEG
40038: PUSH
40039: EMPTY
40040: LIST
40041: LIST
40042: PUSH
40043: LD_INT 1
40045: NEG
40046: PUSH
40047: LD_INT 1
40049: PUSH
40050: EMPTY
40051: LIST
40052: LIST
40053: PUSH
40054: EMPTY
40055: LIST
40056: LIST
40057: LIST
40058: LIST
40059: LIST
40060: LIST
40061: LIST
40062: LIST
40063: LIST
40064: ST_TO_ADDR
// fLab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
40065: LD_ADDR_VAR 0 41
40069: PUSH
40070: LD_INT 0
40072: PUSH
40073: LD_INT 0
40075: PUSH
40076: EMPTY
40077: LIST
40078: LIST
40079: PUSH
40080: LD_INT 0
40082: PUSH
40083: LD_INT 1
40085: NEG
40086: PUSH
40087: EMPTY
40088: LIST
40089: LIST
40090: PUSH
40091: LD_INT 1
40093: PUSH
40094: LD_INT 0
40096: PUSH
40097: EMPTY
40098: LIST
40099: LIST
40100: PUSH
40101: LD_INT 1
40103: PUSH
40104: LD_INT 1
40106: PUSH
40107: EMPTY
40108: LIST
40109: LIST
40110: PUSH
40111: LD_INT 0
40113: PUSH
40114: LD_INT 1
40116: PUSH
40117: EMPTY
40118: LIST
40119: LIST
40120: PUSH
40121: LD_INT 1
40123: NEG
40124: PUSH
40125: LD_INT 0
40127: PUSH
40128: EMPTY
40129: LIST
40130: LIST
40131: PUSH
40132: LD_INT 1
40134: NEG
40135: PUSH
40136: LD_INT 1
40138: NEG
40139: PUSH
40140: EMPTY
40141: LIST
40142: LIST
40143: PUSH
40144: LD_INT 1
40146: NEG
40147: PUSH
40148: LD_INT 2
40150: NEG
40151: PUSH
40152: EMPTY
40153: LIST
40154: LIST
40155: PUSH
40156: LD_INT 1
40158: PUSH
40159: LD_INT 1
40161: NEG
40162: PUSH
40163: EMPTY
40164: LIST
40165: LIST
40166: PUSH
40167: LD_INT 2
40169: PUSH
40170: LD_INT 0
40172: PUSH
40173: EMPTY
40174: LIST
40175: LIST
40176: PUSH
40177: LD_INT 2
40179: PUSH
40180: LD_INT 1
40182: PUSH
40183: EMPTY
40184: LIST
40185: LIST
40186: PUSH
40187: LD_INT 2
40189: PUSH
40190: LD_INT 2
40192: PUSH
40193: EMPTY
40194: LIST
40195: LIST
40196: PUSH
40197: LD_INT 1
40199: PUSH
40200: LD_INT 2
40202: PUSH
40203: EMPTY
40204: LIST
40205: LIST
40206: PUSH
40207: LD_INT 1
40209: NEG
40210: PUSH
40211: LD_INT 1
40213: PUSH
40214: EMPTY
40215: LIST
40216: LIST
40217: PUSH
40218: LD_INT 2
40220: NEG
40221: PUSH
40222: LD_INT 0
40224: PUSH
40225: EMPTY
40226: LIST
40227: LIST
40228: PUSH
40229: LD_INT 2
40231: NEG
40232: PUSH
40233: LD_INT 1
40235: NEG
40236: PUSH
40237: EMPTY
40238: LIST
40239: LIST
40240: PUSH
40241: LD_INT 2
40243: NEG
40244: PUSH
40245: LD_INT 2
40247: NEG
40248: PUSH
40249: EMPTY
40250: LIST
40251: LIST
40252: PUSH
40253: LD_INT 2
40255: NEG
40256: PUSH
40257: LD_INT 3
40259: NEG
40260: PUSH
40261: EMPTY
40262: LIST
40263: LIST
40264: PUSH
40265: LD_INT 2
40267: PUSH
40268: LD_INT 1
40270: NEG
40271: PUSH
40272: EMPTY
40273: LIST
40274: LIST
40275: PUSH
40276: LD_INT 3
40278: PUSH
40279: LD_INT 0
40281: PUSH
40282: EMPTY
40283: LIST
40284: LIST
40285: PUSH
40286: LD_INT 3
40288: PUSH
40289: LD_INT 1
40291: PUSH
40292: EMPTY
40293: LIST
40294: LIST
40295: PUSH
40296: LD_INT 3
40298: PUSH
40299: LD_INT 2
40301: PUSH
40302: EMPTY
40303: LIST
40304: LIST
40305: PUSH
40306: LD_INT 3
40308: PUSH
40309: LD_INT 3
40311: PUSH
40312: EMPTY
40313: LIST
40314: LIST
40315: PUSH
40316: LD_INT 2
40318: PUSH
40319: LD_INT 3
40321: PUSH
40322: EMPTY
40323: LIST
40324: LIST
40325: PUSH
40326: LD_INT 2
40328: NEG
40329: PUSH
40330: LD_INT 1
40332: PUSH
40333: EMPTY
40334: LIST
40335: LIST
40336: PUSH
40337: LD_INT 3
40339: NEG
40340: PUSH
40341: LD_INT 0
40343: PUSH
40344: EMPTY
40345: LIST
40346: LIST
40347: PUSH
40348: LD_INT 3
40350: NEG
40351: PUSH
40352: LD_INT 1
40354: NEG
40355: PUSH
40356: EMPTY
40357: LIST
40358: LIST
40359: PUSH
40360: LD_INT 3
40362: NEG
40363: PUSH
40364: LD_INT 2
40366: NEG
40367: PUSH
40368: EMPTY
40369: LIST
40370: LIST
40371: PUSH
40372: LD_INT 3
40374: NEG
40375: PUSH
40376: LD_INT 3
40378: NEG
40379: PUSH
40380: EMPTY
40381: LIST
40382: LIST
40383: PUSH
40384: EMPTY
40385: LIST
40386: LIST
40387: LIST
40388: LIST
40389: LIST
40390: LIST
40391: LIST
40392: LIST
40393: LIST
40394: LIST
40395: LIST
40396: LIST
40397: LIST
40398: LIST
40399: LIST
40400: LIST
40401: LIST
40402: LIST
40403: LIST
40404: LIST
40405: LIST
40406: LIST
40407: LIST
40408: LIST
40409: LIST
40410: LIST
40411: LIST
40412: LIST
40413: LIST
40414: ST_TO_ADDR
// fLab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
40415: LD_ADDR_VAR 0 42
40419: PUSH
40420: LD_INT 0
40422: PUSH
40423: LD_INT 0
40425: PUSH
40426: EMPTY
40427: LIST
40428: LIST
40429: PUSH
40430: LD_INT 0
40432: PUSH
40433: LD_INT 1
40435: NEG
40436: PUSH
40437: EMPTY
40438: LIST
40439: LIST
40440: PUSH
40441: LD_INT 1
40443: PUSH
40444: LD_INT 0
40446: PUSH
40447: EMPTY
40448: LIST
40449: LIST
40450: PUSH
40451: LD_INT 1
40453: PUSH
40454: LD_INT 1
40456: PUSH
40457: EMPTY
40458: LIST
40459: LIST
40460: PUSH
40461: LD_INT 0
40463: PUSH
40464: LD_INT 1
40466: PUSH
40467: EMPTY
40468: LIST
40469: LIST
40470: PUSH
40471: LD_INT 1
40473: NEG
40474: PUSH
40475: LD_INT 0
40477: PUSH
40478: EMPTY
40479: LIST
40480: LIST
40481: PUSH
40482: LD_INT 1
40484: NEG
40485: PUSH
40486: LD_INT 1
40488: NEG
40489: PUSH
40490: EMPTY
40491: LIST
40492: LIST
40493: PUSH
40494: LD_INT 1
40496: NEG
40497: PUSH
40498: LD_INT 2
40500: NEG
40501: PUSH
40502: EMPTY
40503: LIST
40504: LIST
40505: PUSH
40506: LD_INT 0
40508: PUSH
40509: LD_INT 2
40511: NEG
40512: PUSH
40513: EMPTY
40514: LIST
40515: LIST
40516: PUSH
40517: LD_INT 1
40519: PUSH
40520: LD_INT 1
40522: NEG
40523: PUSH
40524: EMPTY
40525: LIST
40526: LIST
40527: PUSH
40528: LD_INT 2
40530: PUSH
40531: LD_INT 1
40533: PUSH
40534: EMPTY
40535: LIST
40536: LIST
40537: PUSH
40538: LD_INT 2
40540: PUSH
40541: LD_INT 2
40543: PUSH
40544: EMPTY
40545: LIST
40546: LIST
40547: PUSH
40548: LD_INT 1
40550: PUSH
40551: LD_INT 2
40553: PUSH
40554: EMPTY
40555: LIST
40556: LIST
40557: PUSH
40558: LD_INT 0
40560: PUSH
40561: LD_INT 2
40563: PUSH
40564: EMPTY
40565: LIST
40566: LIST
40567: PUSH
40568: LD_INT 1
40570: NEG
40571: PUSH
40572: LD_INT 1
40574: PUSH
40575: EMPTY
40576: LIST
40577: LIST
40578: PUSH
40579: LD_INT 2
40581: NEG
40582: PUSH
40583: LD_INT 1
40585: NEG
40586: PUSH
40587: EMPTY
40588: LIST
40589: LIST
40590: PUSH
40591: LD_INT 2
40593: NEG
40594: PUSH
40595: LD_INT 2
40597: NEG
40598: PUSH
40599: EMPTY
40600: LIST
40601: LIST
40602: PUSH
40603: LD_INT 2
40605: NEG
40606: PUSH
40607: LD_INT 3
40609: NEG
40610: PUSH
40611: EMPTY
40612: LIST
40613: LIST
40614: PUSH
40615: LD_INT 1
40617: NEG
40618: PUSH
40619: LD_INT 3
40621: NEG
40622: PUSH
40623: EMPTY
40624: LIST
40625: LIST
40626: PUSH
40627: LD_INT 0
40629: PUSH
40630: LD_INT 3
40632: NEG
40633: PUSH
40634: EMPTY
40635: LIST
40636: LIST
40637: PUSH
40638: LD_INT 1
40640: PUSH
40641: LD_INT 2
40643: NEG
40644: PUSH
40645: EMPTY
40646: LIST
40647: LIST
40648: PUSH
40649: LD_INT 3
40651: PUSH
40652: LD_INT 2
40654: PUSH
40655: EMPTY
40656: LIST
40657: LIST
40658: PUSH
40659: LD_INT 3
40661: PUSH
40662: LD_INT 3
40664: PUSH
40665: EMPTY
40666: LIST
40667: LIST
40668: PUSH
40669: LD_INT 2
40671: PUSH
40672: LD_INT 3
40674: PUSH
40675: EMPTY
40676: LIST
40677: LIST
40678: PUSH
40679: LD_INT 1
40681: PUSH
40682: LD_INT 3
40684: PUSH
40685: EMPTY
40686: LIST
40687: LIST
40688: PUSH
40689: LD_INT 0
40691: PUSH
40692: LD_INT 3
40694: PUSH
40695: EMPTY
40696: LIST
40697: LIST
40698: PUSH
40699: LD_INT 1
40701: NEG
40702: PUSH
40703: LD_INT 2
40705: PUSH
40706: EMPTY
40707: LIST
40708: LIST
40709: PUSH
40710: LD_INT 3
40712: NEG
40713: PUSH
40714: LD_INT 2
40716: NEG
40717: PUSH
40718: EMPTY
40719: LIST
40720: LIST
40721: PUSH
40722: LD_INT 3
40724: NEG
40725: PUSH
40726: LD_INT 3
40728: NEG
40729: PUSH
40730: EMPTY
40731: LIST
40732: LIST
40733: PUSH
40734: EMPTY
40735: LIST
40736: LIST
40737: LIST
40738: LIST
40739: LIST
40740: LIST
40741: LIST
40742: LIST
40743: LIST
40744: LIST
40745: LIST
40746: LIST
40747: LIST
40748: LIST
40749: LIST
40750: LIST
40751: LIST
40752: LIST
40753: LIST
40754: LIST
40755: LIST
40756: LIST
40757: LIST
40758: LIST
40759: LIST
40760: LIST
40761: LIST
40762: LIST
40763: LIST
40764: ST_TO_ADDR
// fLab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
40765: LD_ADDR_VAR 0 43
40769: PUSH
40770: LD_INT 0
40772: PUSH
40773: LD_INT 0
40775: PUSH
40776: EMPTY
40777: LIST
40778: LIST
40779: PUSH
40780: LD_INT 0
40782: PUSH
40783: LD_INT 1
40785: NEG
40786: PUSH
40787: EMPTY
40788: LIST
40789: LIST
40790: PUSH
40791: LD_INT 1
40793: PUSH
40794: LD_INT 0
40796: PUSH
40797: EMPTY
40798: LIST
40799: LIST
40800: PUSH
40801: LD_INT 1
40803: PUSH
40804: LD_INT 1
40806: PUSH
40807: EMPTY
40808: LIST
40809: LIST
40810: PUSH
40811: LD_INT 0
40813: PUSH
40814: LD_INT 1
40816: PUSH
40817: EMPTY
40818: LIST
40819: LIST
40820: PUSH
40821: LD_INT 1
40823: NEG
40824: PUSH
40825: LD_INT 0
40827: PUSH
40828: EMPTY
40829: LIST
40830: LIST
40831: PUSH
40832: LD_INT 1
40834: NEG
40835: PUSH
40836: LD_INT 1
40838: NEG
40839: PUSH
40840: EMPTY
40841: LIST
40842: LIST
40843: PUSH
40844: LD_INT 1
40846: NEG
40847: PUSH
40848: LD_INT 2
40850: NEG
40851: PUSH
40852: EMPTY
40853: LIST
40854: LIST
40855: PUSH
40856: LD_INT 0
40858: PUSH
40859: LD_INT 2
40861: NEG
40862: PUSH
40863: EMPTY
40864: LIST
40865: LIST
40866: PUSH
40867: LD_INT 1
40869: PUSH
40870: LD_INT 1
40872: NEG
40873: PUSH
40874: EMPTY
40875: LIST
40876: LIST
40877: PUSH
40878: LD_INT 2
40880: PUSH
40881: LD_INT 0
40883: PUSH
40884: EMPTY
40885: LIST
40886: LIST
40887: PUSH
40888: LD_INT 2
40890: PUSH
40891: LD_INT 1
40893: PUSH
40894: EMPTY
40895: LIST
40896: LIST
40897: PUSH
40898: LD_INT 1
40900: PUSH
40901: LD_INT 2
40903: PUSH
40904: EMPTY
40905: LIST
40906: LIST
40907: PUSH
40908: LD_INT 0
40910: PUSH
40911: LD_INT 2
40913: PUSH
40914: EMPTY
40915: LIST
40916: LIST
40917: PUSH
40918: LD_INT 1
40920: NEG
40921: PUSH
40922: LD_INT 1
40924: PUSH
40925: EMPTY
40926: LIST
40927: LIST
40928: PUSH
40929: LD_INT 2
40931: NEG
40932: PUSH
40933: LD_INT 0
40935: PUSH
40936: EMPTY
40937: LIST
40938: LIST
40939: PUSH
40940: LD_INT 2
40942: NEG
40943: PUSH
40944: LD_INT 1
40946: NEG
40947: PUSH
40948: EMPTY
40949: LIST
40950: LIST
40951: PUSH
40952: LD_INT 1
40954: NEG
40955: PUSH
40956: LD_INT 3
40958: NEG
40959: PUSH
40960: EMPTY
40961: LIST
40962: LIST
40963: PUSH
40964: LD_INT 0
40966: PUSH
40967: LD_INT 3
40969: NEG
40970: PUSH
40971: EMPTY
40972: LIST
40973: LIST
40974: PUSH
40975: LD_INT 1
40977: PUSH
40978: LD_INT 2
40980: NEG
40981: PUSH
40982: EMPTY
40983: LIST
40984: LIST
40985: PUSH
40986: LD_INT 2
40988: PUSH
40989: LD_INT 1
40991: NEG
40992: PUSH
40993: EMPTY
40994: LIST
40995: LIST
40996: PUSH
40997: LD_INT 3
40999: PUSH
41000: LD_INT 0
41002: PUSH
41003: EMPTY
41004: LIST
41005: LIST
41006: PUSH
41007: LD_INT 3
41009: PUSH
41010: LD_INT 1
41012: PUSH
41013: EMPTY
41014: LIST
41015: LIST
41016: PUSH
41017: LD_INT 1
41019: PUSH
41020: LD_INT 3
41022: PUSH
41023: EMPTY
41024: LIST
41025: LIST
41026: PUSH
41027: LD_INT 0
41029: PUSH
41030: LD_INT 3
41032: PUSH
41033: EMPTY
41034: LIST
41035: LIST
41036: PUSH
41037: LD_INT 1
41039: NEG
41040: PUSH
41041: LD_INT 2
41043: PUSH
41044: EMPTY
41045: LIST
41046: LIST
41047: PUSH
41048: LD_INT 2
41050: NEG
41051: PUSH
41052: LD_INT 1
41054: PUSH
41055: EMPTY
41056: LIST
41057: LIST
41058: PUSH
41059: LD_INT 3
41061: NEG
41062: PUSH
41063: LD_INT 0
41065: PUSH
41066: EMPTY
41067: LIST
41068: LIST
41069: PUSH
41070: LD_INT 3
41072: NEG
41073: PUSH
41074: LD_INT 1
41076: NEG
41077: PUSH
41078: EMPTY
41079: LIST
41080: LIST
41081: PUSH
41082: EMPTY
41083: LIST
41084: LIST
41085: LIST
41086: LIST
41087: LIST
41088: LIST
41089: LIST
41090: LIST
41091: LIST
41092: LIST
41093: LIST
41094: LIST
41095: LIST
41096: LIST
41097: LIST
41098: LIST
41099: LIST
41100: LIST
41101: LIST
41102: LIST
41103: LIST
41104: LIST
41105: LIST
41106: LIST
41107: LIST
41108: LIST
41109: LIST
41110: LIST
41111: LIST
41112: ST_TO_ADDR
// fLab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
41113: LD_ADDR_VAR 0 44
41117: PUSH
41118: LD_INT 0
41120: PUSH
41121: LD_INT 0
41123: PUSH
41124: EMPTY
41125: LIST
41126: LIST
41127: PUSH
41128: LD_INT 0
41130: PUSH
41131: LD_INT 1
41133: NEG
41134: PUSH
41135: EMPTY
41136: LIST
41137: LIST
41138: PUSH
41139: LD_INT 1
41141: PUSH
41142: LD_INT 0
41144: PUSH
41145: EMPTY
41146: LIST
41147: LIST
41148: PUSH
41149: LD_INT 1
41151: PUSH
41152: LD_INT 1
41154: PUSH
41155: EMPTY
41156: LIST
41157: LIST
41158: PUSH
41159: LD_INT 0
41161: PUSH
41162: LD_INT 1
41164: PUSH
41165: EMPTY
41166: LIST
41167: LIST
41168: PUSH
41169: LD_INT 1
41171: NEG
41172: PUSH
41173: LD_INT 0
41175: PUSH
41176: EMPTY
41177: LIST
41178: LIST
41179: PUSH
41180: LD_INT 1
41182: NEG
41183: PUSH
41184: LD_INT 1
41186: NEG
41187: PUSH
41188: EMPTY
41189: LIST
41190: LIST
41191: PUSH
41192: LD_INT 1
41194: NEG
41195: PUSH
41196: LD_INT 2
41198: NEG
41199: PUSH
41200: EMPTY
41201: LIST
41202: LIST
41203: PUSH
41204: LD_INT 1
41206: PUSH
41207: LD_INT 1
41209: NEG
41210: PUSH
41211: EMPTY
41212: LIST
41213: LIST
41214: PUSH
41215: LD_INT 2
41217: PUSH
41218: LD_INT 0
41220: PUSH
41221: EMPTY
41222: LIST
41223: LIST
41224: PUSH
41225: LD_INT 2
41227: PUSH
41228: LD_INT 1
41230: PUSH
41231: EMPTY
41232: LIST
41233: LIST
41234: PUSH
41235: LD_INT 2
41237: PUSH
41238: LD_INT 2
41240: PUSH
41241: EMPTY
41242: LIST
41243: LIST
41244: PUSH
41245: LD_INT 1
41247: PUSH
41248: LD_INT 2
41250: PUSH
41251: EMPTY
41252: LIST
41253: LIST
41254: PUSH
41255: LD_INT 1
41257: NEG
41258: PUSH
41259: LD_INT 1
41261: PUSH
41262: EMPTY
41263: LIST
41264: LIST
41265: PUSH
41266: LD_INT 2
41268: NEG
41269: PUSH
41270: LD_INT 0
41272: PUSH
41273: EMPTY
41274: LIST
41275: LIST
41276: PUSH
41277: LD_INT 2
41279: NEG
41280: PUSH
41281: LD_INT 1
41283: NEG
41284: PUSH
41285: EMPTY
41286: LIST
41287: LIST
41288: PUSH
41289: LD_INT 2
41291: NEG
41292: PUSH
41293: LD_INT 2
41295: NEG
41296: PUSH
41297: EMPTY
41298: LIST
41299: LIST
41300: PUSH
41301: LD_INT 2
41303: NEG
41304: PUSH
41305: LD_INT 3
41307: NEG
41308: PUSH
41309: EMPTY
41310: LIST
41311: LIST
41312: PUSH
41313: LD_INT 2
41315: PUSH
41316: LD_INT 1
41318: NEG
41319: PUSH
41320: EMPTY
41321: LIST
41322: LIST
41323: PUSH
41324: LD_INT 3
41326: PUSH
41327: LD_INT 0
41329: PUSH
41330: EMPTY
41331: LIST
41332: LIST
41333: PUSH
41334: LD_INT 3
41336: PUSH
41337: LD_INT 1
41339: PUSH
41340: EMPTY
41341: LIST
41342: LIST
41343: PUSH
41344: LD_INT 3
41346: PUSH
41347: LD_INT 2
41349: PUSH
41350: EMPTY
41351: LIST
41352: LIST
41353: PUSH
41354: LD_INT 3
41356: PUSH
41357: LD_INT 3
41359: PUSH
41360: EMPTY
41361: LIST
41362: LIST
41363: PUSH
41364: LD_INT 2
41366: PUSH
41367: LD_INT 3
41369: PUSH
41370: EMPTY
41371: LIST
41372: LIST
41373: PUSH
41374: LD_INT 2
41376: NEG
41377: PUSH
41378: LD_INT 1
41380: PUSH
41381: EMPTY
41382: LIST
41383: LIST
41384: PUSH
41385: LD_INT 3
41387: NEG
41388: PUSH
41389: LD_INT 0
41391: PUSH
41392: EMPTY
41393: LIST
41394: LIST
41395: PUSH
41396: LD_INT 3
41398: NEG
41399: PUSH
41400: LD_INT 1
41402: NEG
41403: PUSH
41404: EMPTY
41405: LIST
41406: LIST
41407: PUSH
41408: LD_INT 3
41410: NEG
41411: PUSH
41412: LD_INT 2
41414: NEG
41415: PUSH
41416: EMPTY
41417: LIST
41418: LIST
41419: PUSH
41420: LD_INT 3
41422: NEG
41423: PUSH
41424: LD_INT 3
41426: NEG
41427: PUSH
41428: EMPTY
41429: LIST
41430: LIST
41431: PUSH
41432: EMPTY
41433: LIST
41434: LIST
41435: LIST
41436: LIST
41437: LIST
41438: LIST
41439: LIST
41440: LIST
41441: LIST
41442: LIST
41443: LIST
41444: LIST
41445: LIST
41446: LIST
41447: LIST
41448: LIST
41449: LIST
41450: LIST
41451: LIST
41452: LIST
41453: LIST
41454: LIST
41455: LIST
41456: LIST
41457: LIST
41458: LIST
41459: LIST
41460: LIST
41461: LIST
41462: ST_TO_ADDR
// fLab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
41463: LD_ADDR_VAR 0 45
41467: PUSH
41468: LD_INT 0
41470: PUSH
41471: LD_INT 0
41473: PUSH
41474: EMPTY
41475: LIST
41476: LIST
41477: PUSH
41478: LD_INT 0
41480: PUSH
41481: LD_INT 1
41483: NEG
41484: PUSH
41485: EMPTY
41486: LIST
41487: LIST
41488: PUSH
41489: LD_INT 1
41491: PUSH
41492: LD_INT 0
41494: PUSH
41495: EMPTY
41496: LIST
41497: LIST
41498: PUSH
41499: LD_INT 1
41501: PUSH
41502: LD_INT 1
41504: PUSH
41505: EMPTY
41506: LIST
41507: LIST
41508: PUSH
41509: LD_INT 0
41511: PUSH
41512: LD_INT 1
41514: PUSH
41515: EMPTY
41516: LIST
41517: LIST
41518: PUSH
41519: LD_INT 1
41521: NEG
41522: PUSH
41523: LD_INT 0
41525: PUSH
41526: EMPTY
41527: LIST
41528: LIST
41529: PUSH
41530: LD_INT 1
41532: NEG
41533: PUSH
41534: LD_INT 1
41536: NEG
41537: PUSH
41538: EMPTY
41539: LIST
41540: LIST
41541: PUSH
41542: LD_INT 1
41544: NEG
41545: PUSH
41546: LD_INT 2
41548: NEG
41549: PUSH
41550: EMPTY
41551: LIST
41552: LIST
41553: PUSH
41554: LD_INT 0
41556: PUSH
41557: LD_INT 2
41559: NEG
41560: PUSH
41561: EMPTY
41562: LIST
41563: LIST
41564: PUSH
41565: LD_INT 1
41567: PUSH
41568: LD_INT 1
41570: NEG
41571: PUSH
41572: EMPTY
41573: LIST
41574: LIST
41575: PUSH
41576: LD_INT 2
41578: PUSH
41579: LD_INT 1
41581: PUSH
41582: EMPTY
41583: LIST
41584: LIST
41585: PUSH
41586: LD_INT 2
41588: PUSH
41589: LD_INT 2
41591: PUSH
41592: EMPTY
41593: LIST
41594: LIST
41595: PUSH
41596: LD_INT 1
41598: PUSH
41599: LD_INT 2
41601: PUSH
41602: EMPTY
41603: LIST
41604: LIST
41605: PUSH
41606: LD_INT 0
41608: PUSH
41609: LD_INT 2
41611: PUSH
41612: EMPTY
41613: LIST
41614: LIST
41615: PUSH
41616: LD_INT 1
41618: NEG
41619: PUSH
41620: LD_INT 1
41622: PUSH
41623: EMPTY
41624: LIST
41625: LIST
41626: PUSH
41627: LD_INT 2
41629: NEG
41630: PUSH
41631: LD_INT 1
41633: NEG
41634: PUSH
41635: EMPTY
41636: LIST
41637: LIST
41638: PUSH
41639: LD_INT 2
41641: NEG
41642: PUSH
41643: LD_INT 2
41645: NEG
41646: PUSH
41647: EMPTY
41648: LIST
41649: LIST
41650: PUSH
41651: LD_INT 2
41653: NEG
41654: PUSH
41655: LD_INT 3
41657: NEG
41658: PUSH
41659: EMPTY
41660: LIST
41661: LIST
41662: PUSH
41663: LD_INT 1
41665: NEG
41666: PUSH
41667: LD_INT 3
41669: NEG
41670: PUSH
41671: EMPTY
41672: LIST
41673: LIST
41674: PUSH
41675: LD_INT 0
41677: PUSH
41678: LD_INT 3
41680: NEG
41681: PUSH
41682: EMPTY
41683: LIST
41684: LIST
41685: PUSH
41686: LD_INT 1
41688: PUSH
41689: LD_INT 2
41691: NEG
41692: PUSH
41693: EMPTY
41694: LIST
41695: LIST
41696: PUSH
41697: LD_INT 3
41699: PUSH
41700: LD_INT 2
41702: PUSH
41703: EMPTY
41704: LIST
41705: LIST
41706: PUSH
41707: LD_INT 3
41709: PUSH
41710: LD_INT 3
41712: PUSH
41713: EMPTY
41714: LIST
41715: LIST
41716: PUSH
41717: LD_INT 2
41719: PUSH
41720: LD_INT 3
41722: PUSH
41723: EMPTY
41724: LIST
41725: LIST
41726: PUSH
41727: LD_INT 1
41729: PUSH
41730: LD_INT 3
41732: PUSH
41733: EMPTY
41734: LIST
41735: LIST
41736: PUSH
41737: LD_INT 0
41739: PUSH
41740: LD_INT 3
41742: PUSH
41743: EMPTY
41744: LIST
41745: LIST
41746: PUSH
41747: LD_INT 1
41749: NEG
41750: PUSH
41751: LD_INT 2
41753: PUSH
41754: EMPTY
41755: LIST
41756: LIST
41757: PUSH
41758: LD_INT 3
41760: NEG
41761: PUSH
41762: LD_INT 2
41764: NEG
41765: PUSH
41766: EMPTY
41767: LIST
41768: LIST
41769: PUSH
41770: LD_INT 3
41772: NEG
41773: PUSH
41774: LD_INT 3
41776: NEG
41777: PUSH
41778: EMPTY
41779: LIST
41780: LIST
41781: PUSH
41782: EMPTY
41783: LIST
41784: LIST
41785: LIST
41786: LIST
41787: LIST
41788: LIST
41789: LIST
41790: LIST
41791: LIST
41792: LIST
41793: LIST
41794: LIST
41795: LIST
41796: LIST
41797: LIST
41798: LIST
41799: LIST
41800: LIST
41801: LIST
41802: LIST
41803: LIST
41804: LIST
41805: LIST
41806: LIST
41807: LIST
41808: LIST
41809: LIST
41810: LIST
41811: LIST
41812: ST_TO_ADDR
// fLab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
41813: LD_ADDR_VAR 0 46
41817: PUSH
41818: LD_INT 0
41820: PUSH
41821: LD_INT 0
41823: PUSH
41824: EMPTY
41825: LIST
41826: LIST
41827: PUSH
41828: LD_INT 0
41830: PUSH
41831: LD_INT 1
41833: NEG
41834: PUSH
41835: EMPTY
41836: LIST
41837: LIST
41838: PUSH
41839: LD_INT 1
41841: PUSH
41842: LD_INT 0
41844: PUSH
41845: EMPTY
41846: LIST
41847: LIST
41848: PUSH
41849: LD_INT 1
41851: PUSH
41852: LD_INT 1
41854: PUSH
41855: EMPTY
41856: LIST
41857: LIST
41858: PUSH
41859: LD_INT 0
41861: PUSH
41862: LD_INT 1
41864: PUSH
41865: EMPTY
41866: LIST
41867: LIST
41868: PUSH
41869: LD_INT 1
41871: NEG
41872: PUSH
41873: LD_INT 0
41875: PUSH
41876: EMPTY
41877: LIST
41878: LIST
41879: PUSH
41880: LD_INT 1
41882: NEG
41883: PUSH
41884: LD_INT 1
41886: NEG
41887: PUSH
41888: EMPTY
41889: LIST
41890: LIST
41891: PUSH
41892: LD_INT 1
41894: NEG
41895: PUSH
41896: LD_INT 2
41898: NEG
41899: PUSH
41900: EMPTY
41901: LIST
41902: LIST
41903: PUSH
41904: LD_INT 0
41906: PUSH
41907: LD_INT 2
41909: NEG
41910: PUSH
41911: EMPTY
41912: LIST
41913: LIST
41914: PUSH
41915: LD_INT 1
41917: PUSH
41918: LD_INT 1
41920: NEG
41921: PUSH
41922: EMPTY
41923: LIST
41924: LIST
41925: PUSH
41926: LD_INT 2
41928: PUSH
41929: LD_INT 0
41931: PUSH
41932: EMPTY
41933: LIST
41934: LIST
41935: PUSH
41936: LD_INT 2
41938: PUSH
41939: LD_INT 1
41941: PUSH
41942: EMPTY
41943: LIST
41944: LIST
41945: PUSH
41946: LD_INT 1
41948: PUSH
41949: LD_INT 2
41951: PUSH
41952: EMPTY
41953: LIST
41954: LIST
41955: PUSH
41956: LD_INT 0
41958: PUSH
41959: LD_INT 2
41961: PUSH
41962: EMPTY
41963: LIST
41964: LIST
41965: PUSH
41966: LD_INT 1
41968: NEG
41969: PUSH
41970: LD_INT 1
41972: PUSH
41973: EMPTY
41974: LIST
41975: LIST
41976: PUSH
41977: LD_INT 2
41979: NEG
41980: PUSH
41981: LD_INT 0
41983: PUSH
41984: EMPTY
41985: LIST
41986: LIST
41987: PUSH
41988: LD_INT 2
41990: NEG
41991: PUSH
41992: LD_INT 1
41994: NEG
41995: PUSH
41996: EMPTY
41997: LIST
41998: LIST
41999: PUSH
42000: LD_INT 1
42002: NEG
42003: PUSH
42004: LD_INT 3
42006: NEG
42007: PUSH
42008: EMPTY
42009: LIST
42010: LIST
42011: PUSH
42012: LD_INT 0
42014: PUSH
42015: LD_INT 3
42017: NEG
42018: PUSH
42019: EMPTY
42020: LIST
42021: LIST
42022: PUSH
42023: LD_INT 1
42025: PUSH
42026: LD_INT 2
42028: NEG
42029: PUSH
42030: EMPTY
42031: LIST
42032: LIST
42033: PUSH
42034: LD_INT 2
42036: PUSH
42037: LD_INT 1
42039: NEG
42040: PUSH
42041: EMPTY
42042: LIST
42043: LIST
42044: PUSH
42045: LD_INT 3
42047: PUSH
42048: LD_INT 0
42050: PUSH
42051: EMPTY
42052: LIST
42053: LIST
42054: PUSH
42055: LD_INT 3
42057: PUSH
42058: LD_INT 1
42060: PUSH
42061: EMPTY
42062: LIST
42063: LIST
42064: PUSH
42065: LD_INT 1
42067: PUSH
42068: LD_INT 3
42070: PUSH
42071: EMPTY
42072: LIST
42073: LIST
42074: PUSH
42075: LD_INT 0
42077: PUSH
42078: LD_INT 3
42080: PUSH
42081: EMPTY
42082: LIST
42083: LIST
42084: PUSH
42085: LD_INT 1
42087: NEG
42088: PUSH
42089: LD_INT 2
42091: PUSH
42092: EMPTY
42093: LIST
42094: LIST
42095: PUSH
42096: LD_INT 2
42098: NEG
42099: PUSH
42100: LD_INT 1
42102: PUSH
42103: EMPTY
42104: LIST
42105: LIST
42106: PUSH
42107: LD_INT 3
42109: NEG
42110: PUSH
42111: LD_INT 0
42113: PUSH
42114: EMPTY
42115: LIST
42116: LIST
42117: PUSH
42118: LD_INT 3
42120: NEG
42121: PUSH
42122: LD_INT 1
42124: NEG
42125: PUSH
42126: EMPTY
42127: LIST
42128: LIST
42129: PUSH
42130: EMPTY
42131: LIST
42132: LIST
42133: LIST
42134: LIST
42135: LIST
42136: LIST
42137: LIST
42138: LIST
42139: LIST
42140: LIST
42141: LIST
42142: LIST
42143: LIST
42144: LIST
42145: LIST
42146: LIST
42147: LIST
42148: LIST
42149: LIST
42150: LIST
42151: LIST
42152: LIST
42153: LIST
42154: LIST
42155: LIST
42156: LIST
42157: LIST
42158: LIST
42159: LIST
42160: ST_TO_ADDR
// fControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
42161: LD_ADDR_VAR 0 47
42165: PUSH
42166: LD_INT 0
42168: PUSH
42169: LD_INT 0
42171: PUSH
42172: EMPTY
42173: LIST
42174: LIST
42175: PUSH
42176: LD_INT 0
42178: PUSH
42179: LD_INT 1
42181: NEG
42182: PUSH
42183: EMPTY
42184: LIST
42185: LIST
42186: PUSH
42187: LD_INT 1
42189: PUSH
42190: LD_INT 0
42192: PUSH
42193: EMPTY
42194: LIST
42195: LIST
42196: PUSH
42197: LD_INT 1
42199: PUSH
42200: LD_INT 1
42202: PUSH
42203: EMPTY
42204: LIST
42205: LIST
42206: PUSH
42207: LD_INT 0
42209: PUSH
42210: LD_INT 1
42212: PUSH
42213: EMPTY
42214: LIST
42215: LIST
42216: PUSH
42217: LD_INT 1
42219: NEG
42220: PUSH
42221: LD_INT 0
42223: PUSH
42224: EMPTY
42225: LIST
42226: LIST
42227: PUSH
42228: LD_INT 1
42230: NEG
42231: PUSH
42232: LD_INT 1
42234: NEG
42235: PUSH
42236: EMPTY
42237: LIST
42238: LIST
42239: PUSH
42240: LD_INT 1
42242: NEG
42243: PUSH
42244: LD_INT 2
42246: NEG
42247: PUSH
42248: EMPTY
42249: LIST
42250: LIST
42251: PUSH
42252: LD_INT 0
42254: PUSH
42255: LD_INT 2
42257: NEG
42258: PUSH
42259: EMPTY
42260: LIST
42261: LIST
42262: PUSH
42263: LD_INT 1
42265: PUSH
42266: LD_INT 1
42268: NEG
42269: PUSH
42270: EMPTY
42271: LIST
42272: LIST
42273: PUSH
42274: LD_INT 2
42276: NEG
42277: PUSH
42278: LD_INT 1
42280: NEG
42281: PUSH
42282: EMPTY
42283: LIST
42284: LIST
42285: PUSH
42286: LD_INT 2
42288: NEG
42289: PUSH
42290: LD_INT 2
42292: NEG
42293: PUSH
42294: EMPTY
42295: LIST
42296: LIST
42297: PUSH
42298: EMPTY
42299: LIST
42300: LIST
42301: LIST
42302: LIST
42303: LIST
42304: LIST
42305: LIST
42306: LIST
42307: LIST
42308: LIST
42309: LIST
42310: LIST
42311: ST_TO_ADDR
// fControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
42312: LD_ADDR_VAR 0 48
42316: PUSH
42317: LD_INT 0
42319: PUSH
42320: LD_INT 0
42322: PUSH
42323: EMPTY
42324: LIST
42325: LIST
42326: PUSH
42327: LD_INT 0
42329: PUSH
42330: LD_INT 1
42332: NEG
42333: PUSH
42334: EMPTY
42335: LIST
42336: LIST
42337: PUSH
42338: LD_INT 1
42340: PUSH
42341: LD_INT 0
42343: PUSH
42344: EMPTY
42345: LIST
42346: LIST
42347: PUSH
42348: LD_INT 1
42350: PUSH
42351: LD_INT 1
42353: PUSH
42354: EMPTY
42355: LIST
42356: LIST
42357: PUSH
42358: LD_INT 0
42360: PUSH
42361: LD_INT 1
42363: PUSH
42364: EMPTY
42365: LIST
42366: LIST
42367: PUSH
42368: LD_INT 1
42370: NEG
42371: PUSH
42372: LD_INT 0
42374: PUSH
42375: EMPTY
42376: LIST
42377: LIST
42378: PUSH
42379: LD_INT 1
42381: NEG
42382: PUSH
42383: LD_INT 1
42385: NEG
42386: PUSH
42387: EMPTY
42388: LIST
42389: LIST
42390: PUSH
42391: LD_INT 1
42393: NEG
42394: PUSH
42395: LD_INT 2
42397: NEG
42398: PUSH
42399: EMPTY
42400: LIST
42401: LIST
42402: PUSH
42403: LD_INT 0
42405: PUSH
42406: LD_INT 2
42408: NEG
42409: PUSH
42410: EMPTY
42411: LIST
42412: LIST
42413: PUSH
42414: LD_INT 1
42416: PUSH
42417: LD_INT 1
42419: NEG
42420: PUSH
42421: EMPTY
42422: LIST
42423: LIST
42424: PUSH
42425: LD_INT 2
42427: PUSH
42428: LD_INT 0
42430: PUSH
42431: EMPTY
42432: LIST
42433: LIST
42434: PUSH
42435: LD_INT 2
42437: PUSH
42438: LD_INT 1
42440: PUSH
42441: EMPTY
42442: LIST
42443: LIST
42444: PUSH
42445: EMPTY
42446: LIST
42447: LIST
42448: LIST
42449: LIST
42450: LIST
42451: LIST
42452: LIST
42453: LIST
42454: LIST
42455: LIST
42456: LIST
42457: LIST
42458: ST_TO_ADDR
// fControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
42459: LD_ADDR_VAR 0 49
42463: PUSH
42464: LD_INT 0
42466: PUSH
42467: LD_INT 0
42469: PUSH
42470: EMPTY
42471: LIST
42472: LIST
42473: PUSH
42474: LD_INT 0
42476: PUSH
42477: LD_INT 1
42479: NEG
42480: PUSH
42481: EMPTY
42482: LIST
42483: LIST
42484: PUSH
42485: LD_INT 1
42487: PUSH
42488: LD_INT 0
42490: PUSH
42491: EMPTY
42492: LIST
42493: LIST
42494: PUSH
42495: LD_INT 1
42497: PUSH
42498: LD_INT 1
42500: PUSH
42501: EMPTY
42502: LIST
42503: LIST
42504: PUSH
42505: LD_INT 0
42507: PUSH
42508: LD_INT 1
42510: PUSH
42511: EMPTY
42512: LIST
42513: LIST
42514: PUSH
42515: LD_INT 1
42517: NEG
42518: PUSH
42519: LD_INT 0
42521: PUSH
42522: EMPTY
42523: LIST
42524: LIST
42525: PUSH
42526: LD_INT 1
42528: NEG
42529: PUSH
42530: LD_INT 1
42532: NEG
42533: PUSH
42534: EMPTY
42535: LIST
42536: LIST
42537: PUSH
42538: LD_INT 1
42540: PUSH
42541: LD_INT 1
42543: NEG
42544: PUSH
42545: EMPTY
42546: LIST
42547: LIST
42548: PUSH
42549: LD_INT 2
42551: PUSH
42552: LD_INT 0
42554: PUSH
42555: EMPTY
42556: LIST
42557: LIST
42558: PUSH
42559: LD_INT 2
42561: PUSH
42562: LD_INT 1
42564: PUSH
42565: EMPTY
42566: LIST
42567: LIST
42568: PUSH
42569: LD_INT 2
42571: PUSH
42572: LD_INT 2
42574: PUSH
42575: EMPTY
42576: LIST
42577: LIST
42578: PUSH
42579: LD_INT 1
42581: PUSH
42582: LD_INT 2
42584: PUSH
42585: EMPTY
42586: LIST
42587: LIST
42588: PUSH
42589: EMPTY
42590: LIST
42591: LIST
42592: LIST
42593: LIST
42594: LIST
42595: LIST
42596: LIST
42597: LIST
42598: LIST
42599: LIST
42600: LIST
42601: LIST
42602: ST_TO_ADDR
// fControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
42603: LD_ADDR_VAR 0 50
42607: PUSH
42608: LD_INT 0
42610: PUSH
42611: LD_INT 0
42613: PUSH
42614: EMPTY
42615: LIST
42616: LIST
42617: PUSH
42618: LD_INT 0
42620: PUSH
42621: LD_INT 1
42623: NEG
42624: PUSH
42625: EMPTY
42626: LIST
42627: LIST
42628: PUSH
42629: LD_INT 1
42631: PUSH
42632: LD_INT 0
42634: PUSH
42635: EMPTY
42636: LIST
42637: LIST
42638: PUSH
42639: LD_INT 1
42641: PUSH
42642: LD_INT 1
42644: PUSH
42645: EMPTY
42646: LIST
42647: LIST
42648: PUSH
42649: LD_INT 0
42651: PUSH
42652: LD_INT 1
42654: PUSH
42655: EMPTY
42656: LIST
42657: LIST
42658: PUSH
42659: LD_INT 1
42661: NEG
42662: PUSH
42663: LD_INT 0
42665: PUSH
42666: EMPTY
42667: LIST
42668: LIST
42669: PUSH
42670: LD_INT 1
42672: NEG
42673: PUSH
42674: LD_INT 1
42676: NEG
42677: PUSH
42678: EMPTY
42679: LIST
42680: LIST
42681: PUSH
42682: LD_INT 2
42684: PUSH
42685: LD_INT 1
42687: PUSH
42688: EMPTY
42689: LIST
42690: LIST
42691: PUSH
42692: LD_INT 2
42694: PUSH
42695: LD_INT 2
42697: PUSH
42698: EMPTY
42699: LIST
42700: LIST
42701: PUSH
42702: LD_INT 1
42704: PUSH
42705: LD_INT 2
42707: PUSH
42708: EMPTY
42709: LIST
42710: LIST
42711: PUSH
42712: LD_INT 0
42714: PUSH
42715: LD_INT 2
42717: PUSH
42718: EMPTY
42719: LIST
42720: LIST
42721: PUSH
42722: LD_INT 1
42724: NEG
42725: PUSH
42726: LD_INT 1
42728: PUSH
42729: EMPTY
42730: LIST
42731: LIST
42732: PUSH
42733: EMPTY
42734: LIST
42735: LIST
42736: LIST
42737: LIST
42738: LIST
42739: LIST
42740: LIST
42741: LIST
42742: LIST
42743: LIST
42744: LIST
42745: LIST
42746: ST_TO_ADDR
// fControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
42747: LD_ADDR_VAR 0 51
42751: PUSH
42752: LD_INT 0
42754: PUSH
42755: LD_INT 0
42757: PUSH
42758: EMPTY
42759: LIST
42760: LIST
42761: PUSH
42762: LD_INT 0
42764: PUSH
42765: LD_INT 1
42767: NEG
42768: PUSH
42769: EMPTY
42770: LIST
42771: LIST
42772: PUSH
42773: LD_INT 1
42775: PUSH
42776: LD_INT 0
42778: PUSH
42779: EMPTY
42780: LIST
42781: LIST
42782: PUSH
42783: LD_INT 1
42785: PUSH
42786: LD_INT 1
42788: PUSH
42789: EMPTY
42790: LIST
42791: LIST
42792: PUSH
42793: LD_INT 0
42795: PUSH
42796: LD_INT 1
42798: PUSH
42799: EMPTY
42800: LIST
42801: LIST
42802: PUSH
42803: LD_INT 1
42805: NEG
42806: PUSH
42807: LD_INT 0
42809: PUSH
42810: EMPTY
42811: LIST
42812: LIST
42813: PUSH
42814: LD_INT 1
42816: NEG
42817: PUSH
42818: LD_INT 1
42820: NEG
42821: PUSH
42822: EMPTY
42823: LIST
42824: LIST
42825: PUSH
42826: LD_INT 1
42828: PUSH
42829: LD_INT 2
42831: PUSH
42832: EMPTY
42833: LIST
42834: LIST
42835: PUSH
42836: LD_INT 0
42838: PUSH
42839: LD_INT 2
42841: PUSH
42842: EMPTY
42843: LIST
42844: LIST
42845: PUSH
42846: LD_INT 1
42848: NEG
42849: PUSH
42850: LD_INT 1
42852: PUSH
42853: EMPTY
42854: LIST
42855: LIST
42856: PUSH
42857: LD_INT 2
42859: NEG
42860: PUSH
42861: LD_INT 0
42863: PUSH
42864: EMPTY
42865: LIST
42866: LIST
42867: PUSH
42868: LD_INT 2
42870: NEG
42871: PUSH
42872: LD_INT 1
42874: NEG
42875: PUSH
42876: EMPTY
42877: LIST
42878: LIST
42879: PUSH
42880: EMPTY
42881: LIST
42882: LIST
42883: LIST
42884: LIST
42885: LIST
42886: LIST
42887: LIST
42888: LIST
42889: LIST
42890: LIST
42891: LIST
42892: LIST
42893: ST_TO_ADDR
// fControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
42894: LD_ADDR_VAR 0 52
42898: PUSH
42899: LD_INT 0
42901: PUSH
42902: LD_INT 0
42904: PUSH
42905: EMPTY
42906: LIST
42907: LIST
42908: PUSH
42909: LD_INT 0
42911: PUSH
42912: LD_INT 1
42914: NEG
42915: PUSH
42916: EMPTY
42917: LIST
42918: LIST
42919: PUSH
42920: LD_INT 1
42922: PUSH
42923: LD_INT 0
42925: PUSH
42926: EMPTY
42927: LIST
42928: LIST
42929: PUSH
42930: LD_INT 1
42932: PUSH
42933: LD_INT 1
42935: PUSH
42936: EMPTY
42937: LIST
42938: LIST
42939: PUSH
42940: LD_INT 0
42942: PUSH
42943: LD_INT 1
42945: PUSH
42946: EMPTY
42947: LIST
42948: LIST
42949: PUSH
42950: LD_INT 1
42952: NEG
42953: PUSH
42954: LD_INT 0
42956: PUSH
42957: EMPTY
42958: LIST
42959: LIST
42960: PUSH
42961: LD_INT 1
42963: NEG
42964: PUSH
42965: LD_INT 1
42967: NEG
42968: PUSH
42969: EMPTY
42970: LIST
42971: LIST
42972: PUSH
42973: LD_INT 1
42975: NEG
42976: PUSH
42977: LD_INT 2
42979: NEG
42980: PUSH
42981: EMPTY
42982: LIST
42983: LIST
42984: PUSH
42985: LD_INT 1
42987: NEG
42988: PUSH
42989: LD_INT 1
42991: PUSH
42992: EMPTY
42993: LIST
42994: LIST
42995: PUSH
42996: LD_INT 2
42998: NEG
42999: PUSH
43000: LD_INT 0
43002: PUSH
43003: EMPTY
43004: LIST
43005: LIST
43006: PUSH
43007: LD_INT 2
43009: NEG
43010: PUSH
43011: LD_INT 1
43013: NEG
43014: PUSH
43015: EMPTY
43016: LIST
43017: LIST
43018: PUSH
43019: LD_INT 2
43021: NEG
43022: PUSH
43023: LD_INT 2
43025: NEG
43026: PUSH
43027: EMPTY
43028: LIST
43029: LIST
43030: PUSH
43031: EMPTY
43032: LIST
43033: LIST
43034: LIST
43035: LIST
43036: LIST
43037: LIST
43038: LIST
43039: LIST
43040: LIST
43041: LIST
43042: LIST
43043: LIST
43044: ST_TO_ADDR
// fBarracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
43045: LD_ADDR_VAR 0 53
43049: PUSH
43050: LD_INT 0
43052: PUSH
43053: LD_INT 0
43055: PUSH
43056: EMPTY
43057: LIST
43058: LIST
43059: PUSH
43060: LD_INT 0
43062: PUSH
43063: LD_INT 1
43065: NEG
43066: PUSH
43067: EMPTY
43068: LIST
43069: LIST
43070: PUSH
43071: LD_INT 1
43073: PUSH
43074: LD_INT 0
43076: PUSH
43077: EMPTY
43078: LIST
43079: LIST
43080: PUSH
43081: LD_INT 1
43083: PUSH
43084: LD_INT 1
43086: PUSH
43087: EMPTY
43088: LIST
43089: LIST
43090: PUSH
43091: LD_INT 0
43093: PUSH
43094: LD_INT 1
43096: PUSH
43097: EMPTY
43098: LIST
43099: LIST
43100: PUSH
43101: LD_INT 1
43103: NEG
43104: PUSH
43105: LD_INT 0
43107: PUSH
43108: EMPTY
43109: LIST
43110: LIST
43111: PUSH
43112: LD_INT 1
43114: NEG
43115: PUSH
43116: LD_INT 1
43118: NEG
43119: PUSH
43120: EMPTY
43121: LIST
43122: LIST
43123: PUSH
43124: LD_INT 1
43126: NEG
43127: PUSH
43128: LD_INT 2
43130: NEG
43131: PUSH
43132: EMPTY
43133: LIST
43134: LIST
43135: PUSH
43136: LD_INT 0
43138: PUSH
43139: LD_INT 2
43141: NEG
43142: PUSH
43143: EMPTY
43144: LIST
43145: LIST
43146: PUSH
43147: LD_INT 1
43149: PUSH
43150: LD_INT 1
43152: NEG
43153: PUSH
43154: EMPTY
43155: LIST
43156: LIST
43157: PUSH
43158: LD_INT 2
43160: PUSH
43161: LD_INT 0
43163: PUSH
43164: EMPTY
43165: LIST
43166: LIST
43167: PUSH
43168: LD_INT 2
43170: PUSH
43171: LD_INT 1
43173: PUSH
43174: EMPTY
43175: LIST
43176: LIST
43177: PUSH
43178: LD_INT 2
43180: PUSH
43181: LD_INT 2
43183: PUSH
43184: EMPTY
43185: LIST
43186: LIST
43187: PUSH
43188: LD_INT 1
43190: PUSH
43191: LD_INT 2
43193: PUSH
43194: EMPTY
43195: LIST
43196: LIST
43197: PUSH
43198: LD_INT 0
43200: PUSH
43201: LD_INT 2
43203: PUSH
43204: EMPTY
43205: LIST
43206: LIST
43207: PUSH
43208: LD_INT 1
43210: NEG
43211: PUSH
43212: LD_INT 1
43214: PUSH
43215: EMPTY
43216: LIST
43217: LIST
43218: PUSH
43219: LD_INT 2
43221: NEG
43222: PUSH
43223: LD_INT 0
43225: PUSH
43226: EMPTY
43227: LIST
43228: LIST
43229: PUSH
43230: LD_INT 2
43232: NEG
43233: PUSH
43234: LD_INT 1
43236: NEG
43237: PUSH
43238: EMPTY
43239: LIST
43240: LIST
43241: PUSH
43242: LD_INT 2
43244: NEG
43245: PUSH
43246: LD_INT 2
43248: NEG
43249: PUSH
43250: EMPTY
43251: LIST
43252: LIST
43253: PUSH
43254: EMPTY
43255: LIST
43256: LIST
43257: LIST
43258: LIST
43259: LIST
43260: LIST
43261: LIST
43262: LIST
43263: LIST
43264: LIST
43265: LIST
43266: LIST
43267: LIST
43268: LIST
43269: LIST
43270: LIST
43271: LIST
43272: LIST
43273: LIST
43274: ST_TO_ADDR
// fBarracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
43275: LD_ADDR_VAR 0 54
43279: PUSH
43280: LD_INT 0
43282: PUSH
43283: LD_INT 0
43285: PUSH
43286: EMPTY
43287: LIST
43288: LIST
43289: PUSH
43290: LD_INT 0
43292: PUSH
43293: LD_INT 1
43295: NEG
43296: PUSH
43297: EMPTY
43298: LIST
43299: LIST
43300: PUSH
43301: LD_INT 1
43303: PUSH
43304: LD_INT 0
43306: PUSH
43307: EMPTY
43308: LIST
43309: LIST
43310: PUSH
43311: LD_INT 1
43313: PUSH
43314: LD_INT 1
43316: PUSH
43317: EMPTY
43318: LIST
43319: LIST
43320: PUSH
43321: LD_INT 0
43323: PUSH
43324: LD_INT 1
43326: PUSH
43327: EMPTY
43328: LIST
43329: LIST
43330: PUSH
43331: LD_INT 1
43333: NEG
43334: PUSH
43335: LD_INT 0
43337: PUSH
43338: EMPTY
43339: LIST
43340: LIST
43341: PUSH
43342: LD_INT 1
43344: NEG
43345: PUSH
43346: LD_INT 1
43348: NEG
43349: PUSH
43350: EMPTY
43351: LIST
43352: LIST
43353: PUSH
43354: LD_INT 1
43356: NEG
43357: PUSH
43358: LD_INT 2
43360: NEG
43361: PUSH
43362: EMPTY
43363: LIST
43364: LIST
43365: PUSH
43366: LD_INT 0
43368: PUSH
43369: LD_INT 2
43371: NEG
43372: PUSH
43373: EMPTY
43374: LIST
43375: LIST
43376: PUSH
43377: LD_INT 1
43379: PUSH
43380: LD_INT 1
43382: NEG
43383: PUSH
43384: EMPTY
43385: LIST
43386: LIST
43387: PUSH
43388: LD_INT 2
43390: PUSH
43391: LD_INT 0
43393: PUSH
43394: EMPTY
43395: LIST
43396: LIST
43397: PUSH
43398: LD_INT 2
43400: PUSH
43401: LD_INT 1
43403: PUSH
43404: EMPTY
43405: LIST
43406: LIST
43407: PUSH
43408: LD_INT 2
43410: PUSH
43411: LD_INT 2
43413: PUSH
43414: EMPTY
43415: LIST
43416: LIST
43417: PUSH
43418: LD_INT 1
43420: PUSH
43421: LD_INT 2
43423: PUSH
43424: EMPTY
43425: LIST
43426: LIST
43427: PUSH
43428: LD_INT 0
43430: PUSH
43431: LD_INT 2
43433: PUSH
43434: EMPTY
43435: LIST
43436: LIST
43437: PUSH
43438: LD_INT 1
43440: NEG
43441: PUSH
43442: LD_INT 1
43444: PUSH
43445: EMPTY
43446: LIST
43447: LIST
43448: PUSH
43449: LD_INT 2
43451: NEG
43452: PUSH
43453: LD_INT 0
43455: PUSH
43456: EMPTY
43457: LIST
43458: LIST
43459: PUSH
43460: LD_INT 2
43462: NEG
43463: PUSH
43464: LD_INT 1
43466: NEG
43467: PUSH
43468: EMPTY
43469: LIST
43470: LIST
43471: PUSH
43472: LD_INT 2
43474: NEG
43475: PUSH
43476: LD_INT 2
43478: NEG
43479: PUSH
43480: EMPTY
43481: LIST
43482: LIST
43483: PUSH
43484: EMPTY
43485: LIST
43486: LIST
43487: LIST
43488: LIST
43489: LIST
43490: LIST
43491: LIST
43492: LIST
43493: LIST
43494: LIST
43495: LIST
43496: LIST
43497: LIST
43498: LIST
43499: LIST
43500: LIST
43501: LIST
43502: LIST
43503: LIST
43504: ST_TO_ADDR
// fBarracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
43505: LD_ADDR_VAR 0 55
43509: PUSH
43510: LD_INT 0
43512: PUSH
43513: LD_INT 0
43515: PUSH
43516: EMPTY
43517: LIST
43518: LIST
43519: PUSH
43520: LD_INT 0
43522: PUSH
43523: LD_INT 1
43525: NEG
43526: PUSH
43527: EMPTY
43528: LIST
43529: LIST
43530: PUSH
43531: LD_INT 1
43533: PUSH
43534: LD_INT 0
43536: PUSH
43537: EMPTY
43538: LIST
43539: LIST
43540: PUSH
43541: LD_INT 1
43543: PUSH
43544: LD_INT 1
43546: PUSH
43547: EMPTY
43548: LIST
43549: LIST
43550: PUSH
43551: LD_INT 0
43553: PUSH
43554: LD_INT 1
43556: PUSH
43557: EMPTY
43558: LIST
43559: LIST
43560: PUSH
43561: LD_INT 1
43563: NEG
43564: PUSH
43565: LD_INT 0
43567: PUSH
43568: EMPTY
43569: LIST
43570: LIST
43571: PUSH
43572: LD_INT 1
43574: NEG
43575: PUSH
43576: LD_INT 1
43578: NEG
43579: PUSH
43580: EMPTY
43581: LIST
43582: LIST
43583: PUSH
43584: LD_INT 1
43586: NEG
43587: PUSH
43588: LD_INT 2
43590: NEG
43591: PUSH
43592: EMPTY
43593: LIST
43594: LIST
43595: PUSH
43596: LD_INT 0
43598: PUSH
43599: LD_INT 2
43601: NEG
43602: PUSH
43603: EMPTY
43604: LIST
43605: LIST
43606: PUSH
43607: LD_INT 1
43609: PUSH
43610: LD_INT 1
43612: NEG
43613: PUSH
43614: EMPTY
43615: LIST
43616: LIST
43617: PUSH
43618: LD_INT 2
43620: PUSH
43621: LD_INT 0
43623: PUSH
43624: EMPTY
43625: LIST
43626: LIST
43627: PUSH
43628: LD_INT 2
43630: PUSH
43631: LD_INT 1
43633: PUSH
43634: EMPTY
43635: LIST
43636: LIST
43637: PUSH
43638: LD_INT 2
43640: PUSH
43641: LD_INT 2
43643: PUSH
43644: EMPTY
43645: LIST
43646: LIST
43647: PUSH
43648: LD_INT 1
43650: PUSH
43651: LD_INT 2
43653: PUSH
43654: EMPTY
43655: LIST
43656: LIST
43657: PUSH
43658: LD_INT 0
43660: PUSH
43661: LD_INT 2
43663: PUSH
43664: EMPTY
43665: LIST
43666: LIST
43667: PUSH
43668: LD_INT 1
43670: NEG
43671: PUSH
43672: LD_INT 1
43674: PUSH
43675: EMPTY
43676: LIST
43677: LIST
43678: PUSH
43679: LD_INT 2
43681: NEG
43682: PUSH
43683: LD_INT 0
43685: PUSH
43686: EMPTY
43687: LIST
43688: LIST
43689: PUSH
43690: LD_INT 2
43692: NEG
43693: PUSH
43694: LD_INT 1
43696: NEG
43697: PUSH
43698: EMPTY
43699: LIST
43700: LIST
43701: PUSH
43702: LD_INT 2
43704: NEG
43705: PUSH
43706: LD_INT 2
43708: NEG
43709: PUSH
43710: EMPTY
43711: LIST
43712: LIST
43713: PUSH
43714: EMPTY
43715: LIST
43716: LIST
43717: LIST
43718: LIST
43719: LIST
43720: LIST
43721: LIST
43722: LIST
43723: LIST
43724: LIST
43725: LIST
43726: LIST
43727: LIST
43728: LIST
43729: LIST
43730: LIST
43731: LIST
43732: LIST
43733: LIST
43734: ST_TO_ADDR
// fBarracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
43735: LD_ADDR_VAR 0 56
43739: PUSH
43740: LD_INT 0
43742: PUSH
43743: LD_INT 0
43745: PUSH
43746: EMPTY
43747: LIST
43748: LIST
43749: PUSH
43750: LD_INT 0
43752: PUSH
43753: LD_INT 1
43755: NEG
43756: PUSH
43757: EMPTY
43758: LIST
43759: LIST
43760: PUSH
43761: LD_INT 1
43763: PUSH
43764: LD_INT 0
43766: PUSH
43767: EMPTY
43768: LIST
43769: LIST
43770: PUSH
43771: LD_INT 1
43773: PUSH
43774: LD_INT 1
43776: PUSH
43777: EMPTY
43778: LIST
43779: LIST
43780: PUSH
43781: LD_INT 0
43783: PUSH
43784: LD_INT 1
43786: PUSH
43787: EMPTY
43788: LIST
43789: LIST
43790: PUSH
43791: LD_INT 1
43793: NEG
43794: PUSH
43795: LD_INT 0
43797: PUSH
43798: EMPTY
43799: LIST
43800: LIST
43801: PUSH
43802: LD_INT 1
43804: NEG
43805: PUSH
43806: LD_INT 1
43808: NEG
43809: PUSH
43810: EMPTY
43811: LIST
43812: LIST
43813: PUSH
43814: LD_INT 1
43816: NEG
43817: PUSH
43818: LD_INT 2
43820: NEG
43821: PUSH
43822: EMPTY
43823: LIST
43824: LIST
43825: PUSH
43826: LD_INT 0
43828: PUSH
43829: LD_INT 2
43831: NEG
43832: PUSH
43833: EMPTY
43834: LIST
43835: LIST
43836: PUSH
43837: LD_INT 1
43839: PUSH
43840: LD_INT 1
43842: NEG
43843: PUSH
43844: EMPTY
43845: LIST
43846: LIST
43847: PUSH
43848: LD_INT 2
43850: PUSH
43851: LD_INT 0
43853: PUSH
43854: EMPTY
43855: LIST
43856: LIST
43857: PUSH
43858: LD_INT 2
43860: PUSH
43861: LD_INT 1
43863: PUSH
43864: EMPTY
43865: LIST
43866: LIST
43867: PUSH
43868: LD_INT 2
43870: PUSH
43871: LD_INT 2
43873: PUSH
43874: EMPTY
43875: LIST
43876: LIST
43877: PUSH
43878: LD_INT 1
43880: PUSH
43881: LD_INT 2
43883: PUSH
43884: EMPTY
43885: LIST
43886: LIST
43887: PUSH
43888: LD_INT 0
43890: PUSH
43891: LD_INT 2
43893: PUSH
43894: EMPTY
43895: LIST
43896: LIST
43897: PUSH
43898: LD_INT 1
43900: NEG
43901: PUSH
43902: LD_INT 1
43904: PUSH
43905: EMPTY
43906: LIST
43907: LIST
43908: PUSH
43909: LD_INT 2
43911: NEG
43912: PUSH
43913: LD_INT 0
43915: PUSH
43916: EMPTY
43917: LIST
43918: LIST
43919: PUSH
43920: LD_INT 2
43922: NEG
43923: PUSH
43924: LD_INT 1
43926: NEG
43927: PUSH
43928: EMPTY
43929: LIST
43930: LIST
43931: PUSH
43932: LD_INT 2
43934: NEG
43935: PUSH
43936: LD_INT 2
43938: NEG
43939: PUSH
43940: EMPTY
43941: LIST
43942: LIST
43943: PUSH
43944: EMPTY
43945: LIST
43946: LIST
43947: LIST
43948: LIST
43949: LIST
43950: LIST
43951: LIST
43952: LIST
43953: LIST
43954: LIST
43955: LIST
43956: LIST
43957: LIST
43958: LIST
43959: LIST
43960: LIST
43961: LIST
43962: LIST
43963: LIST
43964: ST_TO_ADDR
// fBarracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
43965: LD_ADDR_VAR 0 57
43969: PUSH
43970: LD_INT 0
43972: PUSH
43973: LD_INT 0
43975: PUSH
43976: EMPTY
43977: LIST
43978: LIST
43979: PUSH
43980: LD_INT 0
43982: PUSH
43983: LD_INT 1
43985: NEG
43986: PUSH
43987: EMPTY
43988: LIST
43989: LIST
43990: PUSH
43991: LD_INT 1
43993: PUSH
43994: LD_INT 0
43996: PUSH
43997: EMPTY
43998: LIST
43999: LIST
44000: PUSH
44001: LD_INT 1
44003: PUSH
44004: LD_INT 1
44006: PUSH
44007: EMPTY
44008: LIST
44009: LIST
44010: PUSH
44011: LD_INT 0
44013: PUSH
44014: LD_INT 1
44016: PUSH
44017: EMPTY
44018: LIST
44019: LIST
44020: PUSH
44021: LD_INT 1
44023: NEG
44024: PUSH
44025: LD_INT 0
44027: PUSH
44028: EMPTY
44029: LIST
44030: LIST
44031: PUSH
44032: LD_INT 1
44034: NEG
44035: PUSH
44036: LD_INT 1
44038: NEG
44039: PUSH
44040: EMPTY
44041: LIST
44042: LIST
44043: PUSH
44044: LD_INT 1
44046: NEG
44047: PUSH
44048: LD_INT 2
44050: NEG
44051: PUSH
44052: EMPTY
44053: LIST
44054: LIST
44055: PUSH
44056: LD_INT 0
44058: PUSH
44059: LD_INT 2
44061: NEG
44062: PUSH
44063: EMPTY
44064: LIST
44065: LIST
44066: PUSH
44067: LD_INT 1
44069: PUSH
44070: LD_INT 1
44072: NEG
44073: PUSH
44074: EMPTY
44075: LIST
44076: LIST
44077: PUSH
44078: LD_INT 2
44080: PUSH
44081: LD_INT 0
44083: PUSH
44084: EMPTY
44085: LIST
44086: LIST
44087: PUSH
44088: LD_INT 2
44090: PUSH
44091: LD_INT 1
44093: PUSH
44094: EMPTY
44095: LIST
44096: LIST
44097: PUSH
44098: LD_INT 2
44100: PUSH
44101: LD_INT 2
44103: PUSH
44104: EMPTY
44105: LIST
44106: LIST
44107: PUSH
44108: LD_INT 1
44110: PUSH
44111: LD_INT 2
44113: PUSH
44114: EMPTY
44115: LIST
44116: LIST
44117: PUSH
44118: LD_INT 0
44120: PUSH
44121: LD_INT 2
44123: PUSH
44124: EMPTY
44125: LIST
44126: LIST
44127: PUSH
44128: LD_INT 1
44130: NEG
44131: PUSH
44132: LD_INT 1
44134: PUSH
44135: EMPTY
44136: LIST
44137: LIST
44138: PUSH
44139: LD_INT 2
44141: NEG
44142: PUSH
44143: LD_INT 0
44145: PUSH
44146: EMPTY
44147: LIST
44148: LIST
44149: PUSH
44150: LD_INT 2
44152: NEG
44153: PUSH
44154: LD_INT 1
44156: NEG
44157: PUSH
44158: EMPTY
44159: LIST
44160: LIST
44161: PUSH
44162: LD_INT 2
44164: NEG
44165: PUSH
44166: LD_INT 2
44168: NEG
44169: PUSH
44170: EMPTY
44171: LIST
44172: LIST
44173: PUSH
44174: EMPTY
44175: LIST
44176: LIST
44177: LIST
44178: LIST
44179: LIST
44180: LIST
44181: LIST
44182: LIST
44183: LIST
44184: LIST
44185: LIST
44186: LIST
44187: LIST
44188: LIST
44189: LIST
44190: LIST
44191: LIST
44192: LIST
44193: LIST
44194: ST_TO_ADDR
// fBarracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
44195: LD_ADDR_VAR 0 58
44199: PUSH
44200: LD_INT 0
44202: PUSH
44203: LD_INT 0
44205: PUSH
44206: EMPTY
44207: LIST
44208: LIST
44209: PUSH
44210: LD_INT 0
44212: PUSH
44213: LD_INT 1
44215: NEG
44216: PUSH
44217: EMPTY
44218: LIST
44219: LIST
44220: PUSH
44221: LD_INT 1
44223: PUSH
44224: LD_INT 0
44226: PUSH
44227: EMPTY
44228: LIST
44229: LIST
44230: PUSH
44231: LD_INT 1
44233: PUSH
44234: LD_INT 1
44236: PUSH
44237: EMPTY
44238: LIST
44239: LIST
44240: PUSH
44241: LD_INT 0
44243: PUSH
44244: LD_INT 1
44246: PUSH
44247: EMPTY
44248: LIST
44249: LIST
44250: PUSH
44251: LD_INT 1
44253: NEG
44254: PUSH
44255: LD_INT 0
44257: PUSH
44258: EMPTY
44259: LIST
44260: LIST
44261: PUSH
44262: LD_INT 1
44264: NEG
44265: PUSH
44266: LD_INT 1
44268: NEG
44269: PUSH
44270: EMPTY
44271: LIST
44272: LIST
44273: PUSH
44274: LD_INT 1
44276: NEG
44277: PUSH
44278: LD_INT 2
44280: NEG
44281: PUSH
44282: EMPTY
44283: LIST
44284: LIST
44285: PUSH
44286: LD_INT 0
44288: PUSH
44289: LD_INT 2
44291: NEG
44292: PUSH
44293: EMPTY
44294: LIST
44295: LIST
44296: PUSH
44297: LD_INT 1
44299: PUSH
44300: LD_INT 1
44302: NEG
44303: PUSH
44304: EMPTY
44305: LIST
44306: LIST
44307: PUSH
44308: LD_INT 2
44310: PUSH
44311: LD_INT 0
44313: PUSH
44314: EMPTY
44315: LIST
44316: LIST
44317: PUSH
44318: LD_INT 2
44320: PUSH
44321: LD_INT 1
44323: PUSH
44324: EMPTY
44325: LIST
44326: LIST
44327: PUSH
44328: LD_INT 2
44330: PUSH
44331: LD_INT 2
44333: PUSH
44334: EMPTY
44335: LIST
44336: LIST
44337: PUSH
44338: LD_INT 1
44340: PUSH
44341: LD_INT 2
44343: PUSH
44344: EMPTY
44345: LIST
44346: LIST
44347: PUSH
44348: LD_INT 0
44350: PUSH
44351: LD_INT 2
44353: PUSH
44354: EMPTY
44355: LIST
44356: LIST
44357: PUSH
44358: LD_INT 1
44360: NEG
44361: PUSH
44362: LD_INT 1
44364: PUSH
44365: EMPTY
44366: LIST
44367: LIST
44368: PUSH
44369: LD_INT 2
44371: NEG
44372: PUSH
44373: LD_INT 0
44375: PUSH
44376: EMPTY
44377: LIST
44378: LIST
44379: PUSH
44380: LD_INT 2
44382: NEG
44383: PUSH
44384: LD_INT 1
44386: NEG
44387: PUSH
44388: EMPTY
44389: LIST
44390: LIST
44391: PUSH
44392: LD_INT 2
44394: NEG
44395: PUSH
44396: LD_INT 2
44398: NEG
44399: PUSH
44400: EMPTY
44401: LIST
44402: LIST
44403: PUSH
44404: EMPTY
44405: LIST
44406: LIST
44407: LIST
44408: LIST
44409: LIST
44410: LIST
44411: LIST
44412: LIST
44413: LIST
44414: LIST
44415: LIST
44416: LIST
44417: LIST
44418: LIST
44419: LIST
44420: LIST
44421: LIST
44422: LIST
44423: LIST
44424: ST_TO_ADDR
// fBunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
44425: LD_ADDR_VAR 0 59
44429: PUSH
44430: LD_INT 0
44432: PUSH
44433: LD_INT 0
44435: PUSH
44436: EMPTY
44437: LIST
44438: LIST
44439: PUSH
44440: LD_INT 0
44442: PUSH
44443: LD_INT 1
44445: NEG
44446: PUSH
44447: EMPTY
44448: LIST
44449: LIST
44450: PUSH
44451: LD_INT 1
44453: PUSH
44454: LD_INT 0
44456: PUSH
44457: EMPTY
44458: LIST
44459: LIST
44460: PUSH
44461: LD_INT 1
44463: PUSH
44464: LD_INT 1
44466: PUSH
44467: EMPTY
44468: LIST
44469: LIST
44470: PUSH
44471: LD_INT 0
44473: PUSH
44474: LD_INT 1
44476: PUSH
44477: EMPTY
44478: LIST
44479: LIST
44480: PUSH
44481: LD_INT 1
44483: NEG
44484: PUSH
44485: LD_INT 0
44487: PUSH
44488: EMPTY
44489: LIST
44490: LIST
44491: PUSH
44492: LD_INT 1
44494: NEG
44495: PUSH
44496: LD_INT 1
44498: NEG
44499: PUSH
44500: EMPTY
44501: LIST
44502: LIST
44503: PUSH
44504: EMPTY
44505: LIST
44506: LIST
44507: LIST
44508: LIST
44509: LIST
44510: LIST
44511: LIST
44512: ST_TO_ADDR
// fBunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
44513: LD_ADDR_VAR 0 60
44517: PUSH
44518: LD_INT 0
44520: PUSH
44521: LD_INT 0
44523: PUSH
44524: EMPTY
44525: LIST
44526: LIST
44527: PUSH
44528: LD_INT 0
44530: PUSH
44531: LD_INT 1
44533: NEG
44534: PUSH
44535: EMPTY
44536: LIST
44537: LIST
44538: PUSH
44539: LD_INT 1
44541: PUSH
44542: LD_INT 0
44544: PUSH
44545: EMPTY
44546: LIST
44547: LIST
44548: PUSH
44549: LD_INT 1
44551: PUSH
44552: LD_INT 1
44554: PUSH
44555: EMPTY
44556: LIST
44557: LIST
44558: PUSH
44559: LD_INT 0
44561: PUSH
44562: LD_INT 1
44564: PUSH
44565: EMPTY
44566: LIST
44567: LIST
44568: PUSH
44569: LD_INT 1
44571: NEG
44572: PUSH
44573: LD_INT 0
44575: PUSH
44576: EMPTY
44577: LIST
44578: LIST
44579: PUSH
44580: LD_INT 1
44582: NEG
44583: PUSH
44584: LD_INT 1
44586: NEG
44587: PUSH
44588: EMPTY
44589: LIST
44590: LIST
44591: PUSH
44592: EMPTY
44593: LIST
44594: LIST
44595: LIST
44596: LIST
44597: LIST
44598: LIST
44599: LIST
44600: ST_TO_ADDR
// fBunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
44601: LD_ADDR_VAR 0 61
44605: PUSH
44606: LD_INT 0
44608: PUSH
44609: LD_INT 0
44611: PUSH
44612: EMPTY
44613: LIST
44614: LIST
44615: PUSH
44616: LD_INT 0
44618: PUSH
44619: LD_INT 1
44621: NEG
44622: PUSH
44623: EMPTY
44624: LIST
44625: LIST
44626: PUSH
44627: LD_INT 1
44629: PUSH
44630: LD_INT 0
44632: PUSH
44633: EMPTY
44634: LIST
44635: LIST
44636: PUSH
44637: LD_INT 1
44639: PUSH
44640: LD_INT 1
44642: PUSH
44643: EMPTY
44644: LIST
44645: LIST
44646: PUSH
44647: LD_INT 0
44649: PUSH
44650: LD_INT 1
44652: PUSH
44653: EMPTY
44654: LIST
44655: LIST
44656: PUSH
44657: LD_INT 1
44659: NEG
44660: PUSH
44661: LD_INT 0
44663: PUSH
44664: EMPTY
44665: LIST
44666: LIST
44667: PUSH
44668: LD_INT 1
44670: NEG
44671: PUSH
44672: LD_INT 1
44674: NEG
44675: PUSH
44676: EMPTY
44677: LIST
44678: LIST
44679: PUSH
44680: EMPTY
44681: LIST
44682: LIST
44683: LIST
44684: LIST
44685: LIST
44686: LIST
44687: LIST
44688: ST_TO_ADDR
// fBunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
44689: LD_ADDR_VAR 0 62
44693: PUSH
44694: LD_INT 0
44696: PUSH
44697: LD_INT 0
44699: PUSH
44700: EMPTY
44701: LIST
44702: LIST
44703: PUSH
44704: LD_INT 0
44706: PUSH
44707: LD_INT 1
44709: NEG
44710: PUSH
44711: EMPTY
44712: LIST
44713: LIST
44714: PUSH
44715: LD_INT 1
44717: PUSH
44718: LD_INT 0
44720: PUSH
44721: EMPTY
44722: LIST
44723: LIST
44724: PUSH
44725: LD_INT 1
44727: PUSH
44728: LD_INT 1
44730: PUSH
44731: EMPTY
44732: LIST
44733: LIST
44734: PUSH
44735: LD_INT 0
44737: PUSH
44738: LD_INT 1
44740: PUSH
44741: EMPTY
44742: LIST
44743: LIST
44744: PUSH
44745: LD_INT 1
44747: NEG
44748: PUSH
44749: LD_INT 0
44751: PUSH
44752: EMPTY
44753: LIST
44754: LIST
44755: PUSH
44756: LD_INT 1
44758: NEG
44759: PUSH
44760: LD_INT 1
44762: NEG
44763: PUSH
44764: EMPTY
44765: LIST
44766: LIST
44767: PUSH
44768: EMPTY
44769: LIST
44770: LIST
44771: LIST
44772: LIST
44773: LIST
44774: LIST
44775: LIST
44776: ST_TO_ADDR
// fBunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
44777: LD_ADDR_VAR 0 63
44781: PUSH
44782: LD_INT 0
44784: PUSH
44785: LD_INT 0
44787: PUSH
44788: EMPTY
44789: LIST
44790: LIST
44791: PUSH
44792: LD_INT 0
44794: PUSH
44795: LD_INT 1
44797: NEG
44798: PUSH
44799: EMPTY
44800: LIST
44801: LIST
44802: PUSH
44803: LD_INT 1
44805: PUSH
44806: LD_INT 0
44808: PUSH
44809: EMPTY
44810: LIST
44811: LIST
44812: PUSH
44813: LD_INT 1
44815: PUSH
44816: LD_INT 1
44818: PUSH
44819: EMPTY
44820: LIST
44821: LIST
44822: PUSH
44823: LD_INT 0
44825: PUSH
44826: LD_INT 1
44828: PUSH
44829: EMPTY
44830: LIST
44831: LIST
44832: PUSH
44833: LD_INT 1
44835: NEG
44836: PUSH
44837: LD_INT 0
44839: PUSH
44840: EMPTY
44841: LIST
44842: LIST
44843: PUSH
44844: LD_INT 1
44846: NEG
44847: PUSH
44848: LD_INT 1
44850: NEG
44851: PUSH
44852: EMPTY
44853: LIST
44854: LIST
44855: PUSH
44856: EMPTY
44857: LIST
44858: LIST
44859: LIST
44860: LIST
44861: LIST
44862: LIST
44863: LIST
44864: ST_TO_ADDR
// fBunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
44865: LD_ADDR_VAR 0 64
44869: PUSH
44870: LD_INT 0
44872: PUSH
44873: LD_INT 0
44875: PUSH
44876: EMPTY
44877: LIST
44878: LIST
44879: PUSH
44880: LD_INT 0
44882: PUSH
44883: LD_INT 1
44885: NEG
44886: PUSH
44887: EMPTY
44888: LIST
44889: LIST
44890: PUSH
44891: LD_INT 1
44893: PUSH
44894: LD_INT 0
44896: PUSH
44897: EMPTY
44898: LIST
44899: LIST
44900: PUSH
44901: LD_INT 1
44903: PUSH
44904: LD_INT 1
44906: PUSH
44907: EMPTY
44908: LIST
44909: LIST
44910: PUSH
44911: LD_INT 0
44913: PUSH
44914: LD_INT 1
44916: PUSH
44917: EMPTY
44918: LIST
44919: LIST
44920: PUSH
44921: LD_INT 1
44923: NEG
44924: PUSH
44925: LD_INT 0
44927: PUSH
44928: EMPTY
44929: LIST
44930: LIST
44931: PUSH
44932: LD_INT 1
44934: NEG
44935: PUSH
44936: LD_INT 1
44938: NEG
44939: PUSH
44940: EMPTY
44941: LIST
44942: LIST
44943: PUSH
44944: EMPTY
44945: LIST
44946: LIST
44947: LIST
44948: LIST
44949: LIST
44950: LIST
44951: LIST
44952: ST_TO_ADDR
// end ; 1 :
44953: GO 50850
44955: LD_INT 1
44957: DOUBLE
44958: EQUAL
44959: IFTRUE 44963
44961: GO 47586
44963: POP
// begin fDepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
44964: LD_ADDR_VAR 0 11
44968: PUSH
44969: LD_INT 1
44971: NEG
44972: PUSH
44973: LD_INT 3
44975: NEG
44976: PUSH
44977: EMPTY
44978: LIST
44979: LIST
44980: PUSH
44981: LD_INT 0
44983: PUSH
44984: LD_INT 3
44986: NEG
44987: PUSH
44988: EMPTY
44989: LIST
44990: LIST
44991: PUSH
44992: LD_INT 1
44994: PUSH
44995: LD_INT 2
44997: NEG
44998: PUSH
44999: EMPTY
45000: LIST
45001: LIST
45002: PUSH
45003: EMPTY
45004: LIST
45005: LIST
45006: LIST
45007: ST_TO_ADDR
// fDepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
45008: LD_ADDR_VAR 0 12
45012: PUSH
45013: LD_INT 2
45015: PUSH
45016: LD_INT 1
45018: NEG
45019: PUSH
45020: EMPTY
45021: LIST
45022: LIST
45023: PUSH
45024: LD_INT 3
45026: PUSH
45027: LD_INT 0
45029: PUSH
45030: EMPTY
45031: LIST
45032: LIST
45033: PUSH
45034: LD_INT 3
45036: PUSH
45037: LD_INT 1
45039: PUSH
45040: EMPTY
45041: LIST
45042: LIST
45043: PUSH
45044: EMPTY
45045: LIST
45046: LIST
45047: LIST
45048: ST_TO_ADDR
// fDepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
45049: LD_ADDR_VAR 0 13
45053: PUSH
45054: LD_INT 3
45056: PUSH
45057: LD_INT 2
45059: PUSH
45060: EMPTY
45061: LIST
45062: LIST
45063: PUSH
45064: LD_INT 3
45066: PUSH
45067: LD_INT 3
45069: PUSH
45070: EMPTY
45071: LIST
45072: LIST
45073: PUSH
45074: LD_INT 2
45076: PUSH
45077: LD_INT 3
45079: PUSH
45080: EMPTY
45081: LIST
45082: LIST
45083: PUSH
45084: EMPTY
45085: LIST
45086: LIST
45087: LIST
45088: ST_TO_ADDR
// fDepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
45089: LD_ADDR_VAR 0 14
45093: PUSH
45094: LD_INT 1
45096: PUSH
45097: LD_INT 3
45099: PUSH
45100: EMPTY
45101: LIST
45102: LIST
45103: PUSH
45104: LD_INT 0
45106: PUSH
45107: LD_INT 3
45109: PUSH
45110: EMPTY
45111: LIST
45112: LIST
45113: PUSH
45114: LD_INT 1
45116: NEG
45117: PUSH
45118: LD_INT 2
45120: PUSH
45121: EMPTY
45122: LIST
45123: LIST
45124: PUSH
45125: EMPTY
45126: LIST
45127: LIST
45128: LIST
45129: ST_TO_ADDR
// fDepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
45130: LD_ADDR_VAR 0 15
45134: PUSH
45135: LD_INT 2
45137: NEG
45138: PUSH
45139: LD_INT 1
45141: PUSH
45142: EMPTY
45143: LIST
45144: LIST
45145: PUSH
45146: LD_INT 3
45148: NEG
45149: PUSH
45150: LD_INT 0
45152: PUSH
45153: EMPTY
45154: LIST
45155: LIST
45156: PUSH
45157: LD_INT 3
45159: NEG
45160: PUSH
45161: LD_INT 1
45163: NEG
45164: PUSH
45165: EMPTY
45166: LIST
45167: LIST
45168: PUSH
45169: EMPTY
45170: LIST
45171: LIST
45172: LIST
45173: ST_TO_ADDR
// fDepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
45174: LD_ADDR_VAR 0 16
45178: PUSH
45179: LD_INT 2
45181: NEG
45182: PUSH
45183: LD_INT 3
45185: NEG
45186: PUSH
45187: EMPTY
45188: LIST
45189: LIST
45190: PUSH
45191: LD_INT 3
45193: NEG
45194: PUSH
45195: LD_INT 2
45197: NEG
45198: PUSH
45199: EMPTY
45200: LIST
45201: LIST
45202: PUSH
45203: LD_INT 3
45205: NEG
45206: PUSH
45207: LD_INT 3
45209: NEG
45210: PUSH
45211: EMPTY
45212: LIST
45213: LIST
45214: PUSH
45215: EMPTY
45216: LIST
45217: LIST
45218: LIST
45219: ST_TO_ADDR
// fDepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
45220: LD_ADDR_VAR 0 17
45224: PUSH
45225: LD_INT 1
45227: NEG
45228: PUSH
45229: LD_INT 3
45231: NEG
45232: PUSH
45233: EMPTY
45234: LIST
45235: LIST
45236: PUSH
45237: LD_INT 0
45239: PUSH
45240: LD_INT 3
45242: NEG
45243: PUSH
45244: EMPTY
45245: LIST
45246: LIST
45247: PUSH
45248: LD_INT 1
45250: PUSH
45251: LD_INT 2
45253: NEG
45254: PUSH
45255: EMPTY
45256: LIST
45257: LIST
45258: PUSH
45259: EMPTY
45260: LIST
45261: LIST
45262: LIST
45263: ST_TO_ADDR
// fDepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
45264: LD_ADDR_VAR 0 18
45268: PUSH
45269: LD_INT 2
45271: PUSH
45272: LD_INT 1
45274: NEG
45275: PUSH
45276: EMPTY
45277: LIST
45278: LIST
45279: PUSH
45280: LD_INT 3
45282: PUSH
45283: LD_INT 0
45285: PUSH
45286: EMPTY
45287: LIST
45288: LIST
45289: PUSH
45290: LD_INT 3
45292: PUSH
45293: LD_INT 1
45295: PUSH
45296: EMPTY
45297: LIST
45298: LIST
45299: PUSH
45300: EMPTY
45301: LIST
45302: LIST
45303: LIST
45304: ST_TO_ADDR
// fDepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
45305: LD_ADDR_VAR 0 19
45309: PUSH
45310: LD_INT 3
45312: PUSH
45313: LD_INT 2
45315: PUSH
45316: EMPTY
45317: LIST
45318: LIST
45319: PUSH
45320: LD_INT 3
45322: PUSH
45323: LD_INT 3
45325: PUSH
45326: EMPTY
45327: LIST
45328: LIST
45329: PUSH
45330: LD_INT 2
45332: PUSH
45333: LD_INT 3
45335: PUSH
45336: EMPTY
45337: LIST
45338: LIST
45339: PUSH
45340: EMPTY
45341: LIST
45342: LIST
45343: LIST
45344: ST_TO_ADDR
// fDepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
45345: LD_ADDR_VAR 0 20
45349: PUSH
45350: LD_INT 1
45352: PUSH
45353: LD_INT 3
45355: PUSH
45356: EMPTY
45357: LIST
45358: LIST
45359: PUSH
45360: LD_INT 0
45362: PUSH
45363: LD_INT 3
45365: PUSH
45366: EMPTY
45367: LIST
45368: LIST
45369: PUSH
45370: LD_INT 1
45372: NEG
45373: PUSH
45374: LD_INT 2
45376: PUSH
45377: EMPTY
45378: LIST
45379: LIST
45380: PUSH
45381: EMPTY
45382: LIST
45383: LIST
45384: LIST
45385: ST_TO_ADDR
// fDepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
45386: LD_ADDR_VAR 0 21
45390: PUSH
45391: LD_INT 2
45393: NEG
45394: PUSH
45395: LD_INT 1
45397: PUSH
45398: EMPTY
45399: LIST
45400: LIST
45401: PUSH
45402: LD_INT 3
45404: NEG
45405: PUSH
45406: LD_INT 0
45408: PUSH
45409: EMPTY
45410: LIST
45411: LIST
45412: PUSH
45413: LD_INT 3
45415: NEG
45416: PUSH
45417: LD_INT 1
45419: NEG
45420: PUSH
45421: EMPTY
45422: LIST
45423: LIST
45424: PUSH
45425: EMPTY
45426: LIST
45427: LIST
45428: LIST
45429: ST_TO_ADDR
// fDepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
45430: LD_ADDR_VAR 0 22
45434: PUSH
45435: LD_INT 2
45437: NEG
45438: PUSH
45439: LD_INT 3
45441: NEG
45442: PUSH
45443: EMPTY
45444: LIST
45445: LIST
45446: PUSH
45447: LD_INT 3
45449: NEG
45450: PUSH
45451: LD_INT 2
45453: NEG
45454: PUSH
45455: EMPTY
45456: LIST
45457: LIST
45458: PUSH
45459: LD_INT 3
45461: NEG
45462: PUSH
45463: LD_INT 3
45465: NEG
45466: PUSH
45467: EMPTY
45468: LIST
45469: LIST
45470: PUSH
45471: EMPTY
45472: LIST
45473: LIST
45474: LIST
45475: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
45476: LD_ADDR_VAR 0 23
45480: PUSH
45481: LD_INT 0
45483: PUSH
45484: LD_INT 3
45486: NEG
45487: PUSH
45488: EMPTY
45489: LIST
45490: LIST
45491: PUSH
45492: LD_INT 1
45494: NEG
45495: PUSH
45496: LD_INT 4
45498: NEG
45499: PUSH
45500: EMPTY
45501: LIST
45502: LIST
45503: PUSH
45504: LD_INT 1
45506: PUSH
45507: LD_INT 3
45509: NEG
45510: PUSH
45511: EMPTY
45512: LIST
45513: LIST
45514: PUSH
45515: EMPTY
45516: LIST
45517: LIST
45518: LIST
45519: ST_TO_ADDR
// fDepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
45520: LD_ADDR_VAR 0 24
45524: PUSH
45525: LD_INT 3
45527: PUSH
45528: LD_INT 0
45530: PUSH
45531: EMPTY
45532: LIST
45533: LIST
45534: PUSH
45535: LD_INT 3
45537: PUSH
45538: LD_INT 1
45540: NEG
45541: PUSH
45542: EMPTY
45543: LIST
45544: LIST
45545: PUSH
45546: LD_INT 4
45548: PUSH
45549: LD_INT 1
45551: PUSH
45552: EMPTY
45553: LIST
45554: LIST
45555: PUSH
45556: EMPTY
45557: LIST
45558: LIST
45559: LIST
45560: ST_TO_ADDR
// fDepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
45561: LD_ADDR_VAR 0 25
45565: PUSH
45566: LD_INT 3
45568: PUSH
45569: LD_INT 3
45571: PUSH
45572: EMPTY
45573: LIST
45574: LIST
45575: PUSH
45576: LD_INT 4
45578: PUSH
45579: LD_INT 3
45581: PUSH
45582: EMPTY
45583: LIST
45584: LIST
45585: PUSH
45586: LD_INT 3
45588: PUSH
45589: LD_INT 4
45591: PUSH
45592: EMPTY
45593: LIST
45594: LIST
45595: PUSH
45596: EMPTY
45597: LIST
45598: LIST
45599: LIST
45600: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
45601: LD_ADDR_VAR 0 26
45605: PUSH
45606: LD_INT 0
45608: PUSH
45609: LD_INT 3
45611: PUSH
45612: EMPTY
45613: LIST
45614: LIST
45615: PUSH
45616: LD_INT 1
45618: PUSH
45619: LD_INT 4
45621: PUSH
45622: EMPTY
45623: LIST
45624: LIST
45625: PUSH
45626: LD_INT 1
45628: NEG
45629: PUSH
45630: LD_INT 3
45632: PUSH
45633: EMPTY
45634: LIST
45635: LIST
45636: PUSH
45637: EMPTY
45638: LIST
45639: LIST
45640: LIST
45641: ST_TO_ADDR
// fDepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
45642: LD_ADDR_VAR 0 27
45646: PUSH
45647: LD_INT 3
45649: NEG
45650: PUSH
45651: LD_INT 0
45653: PUSH
45654: EMPTY
45655: LIST
45656: LIST
45657: PUSH
45658: LD_INT 3
45660: NEG
45661: PUSH
45662: LD_INT 1
45664: PUSH
45665: EMPTY
45666: LIST
45667: LIST
45668: PUSH
45669: LD_INT 4
45671: NEG
45672: PUSH
45673: LD_INT 1
45675: NEG
45676: PUSH
45677: EMPTY
45678: LIST
45679: LIST
45680: PUSH
45681: EMPTY
45682: LIST
45683: LIST
45684: LIST
45685: ST_TO_ADDR
// fDepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
45686: LD_ADDR_VAR 0 28
45690: PUSH
45691: LD_INT 3
45693: NEG
45694: PUSH
45695: LD_INT 3
45697: NEG
45698: PUSH
45699: EMPTY
45700: LIST
45701: LIST
45702: PUSH
45703: LD_INT 3
45705: NEG
45706: PUSH
45707: LD_INT 4
45709: NEG
45710: PUSH
45711: EMPTY
45712: LIST
45713: LIST
45714: PUSH
45715: LD_INT 4
45717: NEG
45718: PUSH
45719: LD_INT 3
45721: NEG
45722: PUSH
45723: EMPTY
45724: LIST
45725: LIST
45726: PUSH
45727: EMPTY
45728: LIST
45729: LIST
45730: LIST
45731: ST_TO_ADDR
// fFactory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
45732: LD_ADDR_VAR 0 29
45736: PUSH
45737: LD_INT 1
45739: NEG
45740: PUSH
45741: LD_INT 3
45743: NEG
45744: PUSH
45745: EMPTY
45746: LIST
45747: LIST
45748: PUSH
45749: LD_INT 0
45751: PUSH
45752: LD_INT 3
45754: NEG
45755: PUSH
45756: EMPTY
45757: LIST
45758: LIST
45759: PUSH
45760: LD_INT 1
45762: PUSH
45763: LD_INT 2
45765: NEG
45766: PUSH
45767: EMPTY
45768: LIST
45769: LIST
45770: PUSH
45771: LD_INT 1
45773: NEG
45774: PUSH
45775: LD_INT 4
45777: NEG
45778: PUSH
45779: EMPTY
45780: LIST
45781: LIST
45782: PUSH
45783: LD_INT 0
45785: PUSH
45786: LD_INT 4
45788: NEG
45789: PUSH
45790: EMPTY
45791: LIST
45792: LIST
45793: PUSH
45794: LD_INT 1
45796: PUSH
45797: LD_INT 3
45799: NEG
45800: PUSH
45801: EMPTY
45802: LIST
45803: LIST
45804: PUSH
45805: LD_INT 1
45807: NEG
45808: PUSH
45809: LD_INT 5
45811: NEG
45812: PUSH
45813: EMPTY
45814: LIST
45815: LIST
45816: PUSH
45817: LD_INT 0
45819: PUSH
45820: LD_INT 5
45822: NEG
45823: PUSH
45824: EMPTY
45825: LIST
45826: LIST
45827: PUSH
45828: LD_INT 1
45830: PUSH
45831: LD_INT 4
45833: NEG
45834: PUSH
45835: EMPTY
45836: LIST
45837: LIST
45838: PUSH
45839: LD_INT 1
45841: NEG
45842: PUSH
45843: LD_INT 6
45845: NEG
45846: PUSH
45847: EMPTY
45848: LIST
45849: LIST
45850: PUSH
45851: LD_INT 0
45853: PUSH
45854: LD_INT 6
45856: NEG
45857: PUSH
45858: EMPTY
45859: LIST
45860: LIST
45861: PUSH
45862: LD_INT 1
45864: PUSH
45865: LD_INT 5
45867: NEG
45868: PUSH
45869: EMPTY
45870: LIST
45871: LIST
45872: PUSH
45873: EMPTY
45874: LIST
45875: LIST
45876: LIST
45877: LIST
45878: LIST
45879: LIST
45880: LIST
45881: LIST
45882: LIST
45883: LIST
45884: LIST
45885: LIST
45886: ST_TO_ADDR
// fFactory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
45887: LD_ADDR_VAR 0 30
45891: PUSH
45892: LD_INT 2
45894: PUSH
45895: LD_INT 1
45897: NEG
45898: PUSH
45899: EMPTY
45900: LIST
45901: LIST
45902: PUSH
45903: LD_INT 3
45905: PUSH
45906: LD_INT 0
45908: PUSH
45909: EMPTY
45910: LIST
45911: LIST
45912: PUSH
45913: LD_INT 3
45915: PUSH
45916: LD_INT 1
45918: PUSH
45919: EMPTY
45920: LIST
45921: LIST
45922: PUSH
45923: LD_INT 3
45925: PUSH
45926: LD_INT 1
45928: NEG
45929: PUSH
45930: EMPTY
45931: LIST
45932: LIST
45933: PUSH
45934: LD_INT 4
45936: PUSH
45937: LD_INT 0
45939: PUSH
45940: EMPTY
45941: LIST
45942: LIST
45943: PUSH
45944: LD_INT 4
45946: PUSH
45947: LD_INT 1
45949: PUSH
45950: EMPTY
45951: LIST
45952: LIST
45953: PUSH
45954: LD_INT 4
45956: PUSH
45957: LD_INT 1
45959: NEG
45960: PUSH
45961: EMPTY
45962: LIST
45963: LIST
45964: PUSH
45965: LD_INT 5
45967: PUSH
45968: LD_INT 0
45970: PUSH
45971: EMPTY
45972: LIST
45973: LIST
45974: PUSH
45975: LD_INT 5
45977: PUSH
45978: LD_INT 1
45980: PUSH
45981: EMPTY
45982: LIST
45983: LIST
45984: PUSH
45985: LD_INT 5
45987: PUSH
45988: LD_INT 1
45990: NEG
45991: PUSH
45992: EMPTY
45993: LIST
45994: LIST
45995: PUSH
45996: LD_INT 6
45998: PUSH
45999: LD_INT 0
46001: PUSH
46002: EMPTY
46003: LIST
46004: LIST
46005: PUSH
46006: LD_INT 6
46008: PUSH
46009: LD_INT 1
46011: PUSH
46012: EMPTY
46013: LIST
46014: LIST
46015: PUSH
46016: EMPTY
46017: LIST
46018: LIST
46019: LIST
46020: LIST
46021: LIST
46022: LIST
46023: LIST
46024: LIST
46025: LIST
46026: LIST
46027: LIST
46028: LIST
46029: ST_TO_ADDR
// fFactory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
46030: LD_ADDR_VAR 0 31
46034: PUSH
46035: LD_INT 3
46037: PUSH
46038: LD_INT 2
46040: PUSH
46041: EMPTY
46042: LIST
46043: LIST
46044: PUSH
46045: LD_INT 3
46047: PUSH
46048: LD_INT 3
46050: PUSH
46051: EMPTY
46052: LIST
46053: LIST
46054: PUSH
46055: LD_INT 2
46057: PUSH
46058: LD_INT 3
46060: PUSH
46061: EMPTY
46062: LIST
46063: LIST
46064: PUSH
46065: LD_INT 4
46067: PUSH
46068: LD_INT 3
46070: PUSH
46071: EMPTY
46072: LIST
46073: LIST
46074: PUSH
46075: LD_INT 4
46077: PUSH
46078: LD_INT 4
46080: PUSH
46081: EMPTY
46082: LIST
46083: LIST
46084: PUSH
46085: LD_INT 3
46087: PUSH
46088: LD_INT 4
46090: PUSH
46091: EMPTY
46092: LIST
46093: LIST
46094: PUSH
46095: LD_INT 5
46097: PUSH
46098: LD_INT 4
46100: PUSH
46101: EMPTY
46102: LIST
46103: LIST
46104: PUSH
46105: LD_INT 5
46107: PUSH
46108: LD_INT 5
46110: PUSH
46111: EMPTY
46112: LIST
46113: LIST
46114: PUSH
46115: LD_INT 4
46117: PUSH
46118: LD_INT 5
46120: PUSH
46121: EMPTY
46122: LIST
46123: LIST
46124: PUSH
46125: LD_INT 6
46127: PUSH
46128: LD_INT 5
46130: PUSH
46131: EMPTY
46132: LIST
46133: LIST
46134: PUSH
46135: LD_INT 6
46137: PUSH
46138: LD_INT 6
46140: PUSH
46141: EMPTY
46142: LIST
46143: LIST
46144: PUSH
46145: LD_INT 5
46147: PUSH
46148: LD_INT 6
46150: PUSH
46151: EMPTY
46152: LIST
46153: LIST
46154: PUSH
46155: EMPTY
46156: LIST
46157: LIST
46158: LIST
46159: LIST
46160: LIST
46161: LIST
46162: LIST
46163: LIST
46164: LIST
46165: LIST
46166: LIST
46167: LIST
46168: ST_TO_ADDR
// fFactory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
46169: LD_ADDR_VAR 0 32
46173: PUSH
46174: LD_INT 1
46176: PUSH
46177: LD_INT 3
46179: PUSH
46180: EMPTY
46181: LIST
46182: LIST
46183: PUSH
46184: LD_INT 0
46186: PUSH
46187: LD_INT 3
46189: PUSH
46190: EMPTY
46191: LIST
46192: LIST
46193: PUSH
46194: LD_INT 1
46196: NEG
46197: PUSH
46198: LD_INT 2
46200: PUSH
46201: EMPTY
46202: LIST
46203: LIST
46204: PUSH
46205: LD_INT 1
46207: PUSH
46208: LD_INT 4
46210: PUSH
46211: EMPTY
46212: LIST
46213: LIST
46214: PUSH
46215: LD_INT 0
46217: PUSH
46218: LD_INT 4
46220: PUSH
46221: EMPTY
46222: LIST
46223: LIST
46224: PUSH
46225: LD_INT 1
46227: NEG
46228: PUSH
46229: LD_INT 3
46231: PUSH
46232: EMPTY
46233: LIST
46234: LIST
46235: PUSH
46236: LD_INT 1
46238: PUSH
46239: LD_INT 5
46241: PUSH
46242: EMPTY
46243: LIST
46244: LIST
46245: PUSH
46246: LD_INT 0
46248: PUSH
46249: LD_INT 5
46251: PUSH
46252: EMPTY
46253: LIST
46254: LIST
46255: PUSH
46256: LD_INT 1
46258: NEG
46259: PUSH
46260: LD_INT 4
46262: PUSH
46263: EMPTY
46264: LIST
46265: LIST
46266: PUSH
46267: LD_INT 1
46269: PUSH
46270: LD_INT 6
46272: PUSH
46273: EMPTY
46274: LIST
46275: LIST
46276: PUSH
46277: LD_INT 0
46279: PUSH
46280: LD_INT 6
46282: PUSH
46283: EMPTY
46284: LIST
46285: LIST
46286: PUSH
46287: LD_INT 1
46289: NEG
46290: PUSH
46291: LD_INT 5
46293: PUSH
46294: EMPTY
46295: LIST
46296: LIST
46297: PUSH
46298: EMPTY
46299: LIST
46300: LIST
46301: LIST
46302: LIST
46303: LIST
46304: LIST
46305: LIST
46306: LIST
46307: LIST
46308: LIST
46309: LIST
46310: LIST
46311: ST_TO_ADDR
// fFactory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
46312: LD_ADDR_VAR 0 33
46316: PUSH
46317: LD_INT 2
46319: NEG
46320: PUSH
46321: LD_INT 1
46323: PUSH
46324: EMPTY
46325: LIST
46326: LIST
46327: PUSH
46328: LD_INT 3
46330: NEG
46331: PUSH
46332: LD_INT 0
46334: PUSH
46335: EMPTY
46336: LIST
46337: LIST
46338: PUSH
46339: LD_INT 3
46341: NEG
46342: PUSH
46343: LD_INT 1
46345: NEG
46346: PUSH
46347: EMPTY
46348: LIST
46349: LIST
46350: PUSH
46351: LD_INT 3
46353: NEG
46354: PUSH
46355: LD_INT 1
46357: PUSH
46358: EMPTY
46359: LIST
46360: LIST
46361: PUSH
46362: LD_INT 4
46364: NEG
46365: PUSH
46366: LD_INT 0
46368: PUSH
46369: EMPTY
46370: LIST
46371: LIST
46372: PUSH
46373: LD_INT 4
46375: NEG
46376: PUSH
46377: LD_INT 1
46379: NEG
46380: PUSH
46381: EMPTY
46382: LIST
46383: LIST
46384: PUSH
46385: LD_INT 4
46387: NEG
46388: PUSH
46389: LD_INT 1
46391: PUSH
46392: EMPTY
46393: LIST
46394: LIST
46395: PUSH
46396: LD_INT 5
46398: NEG
46399: PUSH
46400: LD_INT 0
46402: PUSH
46403: EMPTY
46404: LIST
46405: LIST
46406: PUSH
46407: LD_INT 5
46409: NEG
46410: PUSH
46411: LD_INT 1
46413: NEG
46414: PUSH
46415: EMPTY
46416: LIST
46417: LIST
46418: PUSH
46419: LD_INT 5
46421: NEG
46422: PUSH
46423: LD_INT 1
46425: PUSH
46426: EMPTY
46427: LIST
46428: LIST
46429: PUSH
46430: LD_INT 6
46432: NEG
46433: PUSH
46434: LD_INT 0
46436: PUSH
46437: EMPTY
46438: LIST
46439: LIST
46440: PUSH
46441: LD_INT 6
46443: NEG
46444: PUSH
46445: LD_INT 1
46447: NEG
46448: PUSH
46449: EMPTY
46450: LIST
46451: LIST
46452: PUSH
46453: EMPTY
46454: LIST
46455: LIST
46456: LIST
46457: LIST
46458: LIST
46459: LIST
46460: LIST
46461: LIST
46462: LIST
46463: LIST
46464: LIST
46465: LIST
46466: ST_TO_ADDR
// fFactory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
46467: LD_ADDR_VAR 0 34
46471: PUSH
46472: LD_INT 2
46474: NEG
46475: PUSH
46476: LD_INT 3
46478: NEG
46479: PUSH
46480: EMPTY
46481: LIST
46482: LIST
46483: PUSH
46484: LD_INT 3
46486: NEG
46487: PUSH
46488: LD_INT 2
46490: NEG
46491: PUSH
46492: EMPTY
46493: LIST
46494: LIST
46495: PUSH
46496: LD_INT 3
46498: NEG
46499: PUSH
46500: LD_INT 3
46502: NEG
46503: PUSH
46504: EMPTY
46505: LIST
46506: LIST
46507: PUSH
46508: LD_INT 3
46510: NEG
46511: PUSH
46512: LD_INT 4
46514: NEG
46515: PUSH
46516: EMPTY
46517: LIST
46518: LIST
46519: PUSH
46520: LD_INT 4
46522: NEG
46523: PUSH
46524: LD_INT 3
46526: NEG
46527: PUSH
46528: EMPTY
46529: LIST
46530: LIST
46531: PUSH
46532: LD_INT 4
46534: NEG
46535: PUSH
46536: LD_INT 4
46538: NEG
46539: PUSH
46540: EMPTY
46541: LIST
46542: LIST
46543: PUSH
46544: LD_INT 4
46546: NEG
46547: PUSH
46548: LD_INT 5
46550: NEG
46551: PUSH
46552: EMPTY
46553: LIST
46554: LIST
46555: PUSH
46556: LD_INT 5
46558: NEG
46559: PUSH
46560: LD_INT 4
46562: NEG
46563: PUSH
46564: EMPTY
46565: LIST
46566: LIST
46567: PUSH
46568: LD_INT 5
46570: NEG
46571: PUSH
46572: LD_INT 5
46574: NEG
46575: PUSH
46576: EMPTY
46577: LIST
46578: LIST
46579: PUSH
46580: LD_INT 5
46582: NEG
46583: PUSH
46584: LD_INT 6
46586: NEG
46587: PUSH
46588: EMPTY
46589: LIST
46590: LIST
46591: PUSH
46592: LD_INT 6
46594: NEG
46595: PUSH
46596: LD_INT 5
46598: NEG
46599: PUSH
46600: EMPTY
46601: LIST
46602: LIST
46603: PUSH
46604: LD_INT 6
46606: NEG
46607: PUSH
46608: LD_INT 6
46610: NEG
46611: PUSH
46612: EMPTY
46613: LIST
46614: LIST
46615: PUSH
46616: EMPTY
46617: LIST
46618: LIST
46619: LIST
46620: LIST
46621: LIST
46622: LIST
46623: LIST
46624: LIST
46625: LIST
46626: LIST
46627: LIST
46628: LIST
46629: ST_TO_ADDR
// fLab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
46630: LD_ADDR_VAR 0 41
46634: PUSH
46635: LD_INT 0
46637: PUSH
46638: LD_INT 2
46640: NEG
46641: PUSH
46642: EMPTY
46643: LIST
46644: LIST
46645: PUSH
46646: LD_INT 1
46648: NEG
46649: PUSH
46650: LD_INT 3
46652: NEG
46653: PUSH
46654: EMPTY
46655: LIST
46656: LIST
46657: PUSH
46658: LD_INT 1
46660: PUSH
46661: LD_INT 2
46663: NEG
46664: PUSH
46665: EMPTY
46666: LIST
46667: LIST
46668: PUSH
46669: EMPTY
46670: LIST
46671: LIST
46672: LIST
46673: ST_TO_ADDR
// fLab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
46674: LD_ADDR_VAR 0 42
46678: PUSH
46679: LD_INT 2
46681: PUSH
46682: LD_INT 0
46684: PUSH
46685: EMPTY
46686: LIST
46687: LIST
46688: PUSH
46689: LD_INT 2
46691: PUSH
46692: LD_INT 1
46694: NEG
46695: PUSH
46696: EMPTY
46697: LIST
46698: LIST
46699: PUSH
46700: LD_INT 3
46702: PUSH
46703: LD_INT 1
46705: PUSH
46706: EMPTY
46707: LIST
46708: LIST
46709: PUSH
46710: EMPTY
46711: LIST
46712: LIST
46713: LIST
46714: ST_TO_ADDR
// fLab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
46715: LD_ADDR_VAR 0 43
46719: PUSH
46720: LD_INT 2
46722: PUSH
46723: LD_INT 2
46725: PUSH
46726: EMPTY
46727: LIST
46728: LIST
46729: PUSH
46730: LD_INT 3
46732: PUSH
46733: LD_INT 2
46735: PUSH
46736: EMPTY
46737: LIST
46738: LIST
46739: PUSH
46740: LD_INT 2
46742: PUSH
46743: LD_INT 3
46745: PUSH
46746: EMPTY
46747: LIST
46748: LIST
46749: PUSH
46750: EMPTY
46751: LIST
46752: LIST
46753: LIST
46754: ST_TO_ADDR
// fLab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
46755: LD_ADDR_VAR 0 44
46759: PUSH
46760: LD_INT 0
46762: PUSH
46763: LD_INT 2
46765: PUSH
46766: EMPTY
46767: LIST
46768: LIST
46769: PUSH
46770: LD_INT 1
46772: PUSH
46773: LD_INT 3
46775: PUSH
46776: EMPTY
46777: LIST
46778: LIST
46779: PUSH
46780: LD_INT 1
46782: NEG
46783: PUSH
46784: LD_INT 2
46786: PUSH
46787: EMPTY
46788: LIST
46789: LIST
46790: PUSH
46791: EMPTY
46792: LIST
46793: LIST
46794: LIST
46795: ST_TO_ADDR
// fLab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
46796: LD_ADDR_VAR 0 45
46800: PUSH
46801: LD_INT 2
46803: NEG
46804: PUSH
46805: LD_INT 0
46807: PUSH
46808: EMPTY
46809: LIST
46810: LIST
46811: PUSH
46812: LD_INT 2
46814: NEG
46815: PUSH
46816: LD_INT 1
46818: PUSH
46819: EMPTY
46820: LIST
46821: LIST
46822: PUSH
46823: LD_INT 3
46825: NEG
46826: PUSH
46827: LD_INT 1
46829: NEG
46830: PUSH
46831: EMPTY
46832: LIST
46833: LIST
46834: PUSH
46835: EMPTY
46836: LIST
46837: LIST
46838: LIST
46839: ST_TO_ADDR
// fLab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
46840: LD_ADDR_VAR 0 46
46844: PUSH
46845: LD_INT 2
46847: NEG
46848: PUSH
46849: LD_INT 2
46851: NEG
46852: PUSH
46853: EMPTY
46854: LIST
46855: LIST
46856: PUSH
46857: LD_INT 2
46859: NEG
46860: PUSH
46861: LD_INT 3
46863: NEG
46864: PUSH
46865: EMPTY
46866: LIST
46867: LIST
46868: PUSH
46869: LD_INT 3
46871: NEG
46872: PUSH
46873: LD_INT 2
46875: NEG
46876: PUSH
46877: EMPTY
46878: LIST
46879: LIST
46880: PUSH
46881: EMPTY
46882: LIST
46883: LIST
46884: LIST
46885: ST_TO_ADDR
// fControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
46886: LD_ADDR_VAR 0 47
46890: PUSH
46891: LD_INT 2
46893: NEG
46894: PUSH
46895: LD_INT 3
46897: NEG
46898: PUSH
46899: EMPTY
46900: LIST
46901: LIST
46902: PUSH
46903: LD_INT 1
46905: NEG
46906: PUSH
46907: LD_INT 3
46909: NEG
46910: PUSH
46911: EMPTY
46912: LIST
46913: LIST
46914: PUSH
46915: EMPTY
46916: LIST
46917: LIST
46918: ST_TO_ADDR
// fControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
46919: LD_ADDR_VAR 0 48
46923: PUSH
46924: LD_INT 1
46926: PUSH
46927: LD_INT 2
46929: NEG
46930: PUSH
46931: EMPTY
46932: LIST
46933: LIST
46934: PUSH
46935: LD_INT 2
46937: PUSH
46938: LD_INT 1
46940: NEG
46941: PUSH
46942: EMPTY
46943: LIST
46944: LIST
46945: PUSH
46946: EMPTY
46947: LIST
46948: LIST
46949: ST_TO_ADDR
// fControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
46950: LD_ADDR_VAR 0 49
46954: PUSH
46955: LD_INT 3
46957: PUSH
46958: LD_INT 1
46960: PUSH
46961: EMPTY
46962: LIST
46963: LIST
46964: PUSH
46965: LD_INT 3
46967: PUSH
46968: LD_INT 2
46970: PUSH
46971: EMPTY
46972: LIST
46973: LIST
46974: PUSH
46975: EMPTY
46976: LIST
46977: LIST
46978: ST_TO_ADDR
// fControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
46979: LD_ADDR_VAR 0 50
46983: PUSH
46984: LD_INT 2
46986: PUSH
46987: LD_INT 3
46989: PUSH
46990: EMPTY
46991: LIST
46992: LIST
46993: PUSH
46994: LD_INT 1
46996: PUSH
46997: LD_INT 3
46999: PUSH
47000: EMPTY
47001: LIST
47002: LIST
47003: PUSH
47004: EMPTY
47005: LIST
47006: LIST
47007: ST_TO_ADDR
// fControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
47008: LD_ADDR_VAR 0 51
47012: PUSH
47013: LD_INT 1
47015: NEG
47016: PUSH
47017: LD_INT 2
47019: PUSH
47020: EMPTY
47021: LIST
47022: LIST
47023: PUSH
47024: LD_INT 2
47026: NEG
47027: PUSH
47028: LD_INT 1
47030: PUSH
47031: EMPTY
47032: LIST
47033: LIST
47034: PUSH
47035: EMPTY
47036: LIST
47037: LIST
47038: ST_TO_ADDR
// fControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
47039: LD_ADDR_VAR 0 52
47043: PUSH
47044: LD_INT 3
47046: NEG
47047: PUSH
47048: LD_INT 1
47050: NEG
47051: PUSH
47052: EMPTY
47053: LIST
47054: LIST
47055: PUSH
47056: LD_INT 3
47058: NEG
47059: PUSH
47060: LD_INT 2
47062: NEG
47063: PUSH
47064: EMPTY
47065: LIST
47066: LIST
47067: PUSH
47068: EMPTY
47069: LIST
47070: LIST
47071: ST_TO_ADDR
// fBarracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
47072: LD_ADDR_VAR 0 53
47076: PUSH
47077: LD_INT 1
47079: NEG
47080: PUSH
47081: LD_INT 3
47083: NEG
47084: PUSH
47085: EMPTY
47086: LIST
47087: LIST
47088: PUSH
47089: LD_INT 0
47091: PUSH
47092: LD_INT 3
47094: NEG
47095: PUSH
47096: EMPTY
47097: LIST
47098: LIST
47099: PUSH
47100: LD_INT 1
47102: PUSH
47103: LD_INT 2
47105: NEG
47106: PUSH
47107: EMPTY
47108: LIST
47109: LIST
47110: PUSH
47111: EMPTY
47112: LIST
47113: LIST
47114: LIST
47115: ST_TO_ADDR
// fBarracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
47116: LD_ADDR_VAR 0 54
47120: PUSH
47121: LD_INT 2
47123: PUSH
47124: LD_INT 1
47126: NEG
47127: PUSH
47128: EMPTY
47129: LIST
47130: LIST
47131: PUSH
47132: LD_INT 3
47134: PUSH
47135: LD_INT 0
47137: PUSH
47138: EMPTY
47139: LIST
47140: LIST
47141: PUSH
47142: LD_INT 3
47144: PUSH
47145: LD_INT 1
47147: PUSH
47148: EMPTY
47149: LIST
47150: LIST
47151: PUSH
47152: EMPTY
47153: LIST
47154: LIST
47155: LIST
47156: ST_TO_ADDR
// fBarracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
47157: LD_ADDR_VAR 0 55
47161: PUSH
47162: LD_INT 3
47164: PUSH
47165: LD_INT 2
47167: PUSH
47168: EMPTY
47169: LIST
47170: LIST
47171: PUSH
47172: LD_INT 3
47174: PUSH
47175: LD_INT 3
47177: PUSH
47178: EMPTY
47179: LIST
47180: LIST
47181: PUSH
47182: LD_INT 2
47184: PUSH
47185: LD_INT 3
47187: PUSH
47188: EMPTY
47189: LIST
47190: LIST
47191: PUSH
47192: EMPTY
47193: LIST
47194: LIST
47195: LIST
47196: ST_TO_ADDR
// fBarracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
47197: LD_ADDR_VAR 0 56
47201: PUSH
47202: LD_INT 1
47204: PUSH
47205: LD_INT 3
47207: PUSH
47208: EMPTY
47209: LIST
47210: LIST
47211: PUSH
47212: LD_INT 0
47214: PUSH
47215: LD_INT 3
47217: PUSH
47218: EMPTY
47219: LIST
47220: LIST
47221: PUSH
47222: LD_INT 1
47224: NEG
47225: PUSH
47226: LD_INT 2
47228: PUSH
47229: EMPTY
47230: LIST
47231: LIST
47232: PUSH
47233: EMPTY
47234: LIST
47235: LIST
47236: LIST
47237: ST_TO_ADDR
// fBarracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
47238: LD_ADDR_VAR 0 57
47242: PUSH
47243: LD_INT 2
47245: NEG
47246: PUSH
47247: LD_INT 1
47249: PUSH
47250: EMPTY
47251: LIST
47252: LIST
47253: PUSH
47254: LD_INT 3
47256: NEG
47257: PUSH
47258: LD_INT 0
47260: PUSH
47261: EMPTY
47262: LIST
47263: LIST
47264: PUSH
47265: LD_INT 3
47267: NEG
47268: PUSH
47269: LD_INT 1
47271: NEG
47272: PUSH
47273: EMPTY
47274: LIST
47275: LIST
47276: PUSH
47277: EMPTY
47278: LIST
47279: LIST
47280: LIST
47281: ST_TO_ADDR
// fBarracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
47282: LD_ADDR_VAR 0 58
47286: PUSH
47287: LD_INT 2
47289: NEG
47290: PUSH
47291: LD_INT 3
47293: NEG
47294: PUSH
47295: EMPTY
47296: LIST
47297: LIST
47298: PUSH
47299: LD_INT 3
47301: NEG
47302: PUSH
47303: LD_INT 2
47305: NEG
47306: PUSH
47307: EMPTY
47308: LIST
47309: LIST
47310: PUSH
47311: LD_INT 3
47313: NEG
47314: PUSH
47315: LD_INT 3
47317: NEG
47318: PUSH
47319: EMPTY
47320: LIST
47321: LIST
47322: PUSH
47323: EMPTY
47324: LIST
47325: LIST
47326: LIST
47327: ST_TO_ADDR
// fBunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
47328: LD_ADDR_VAR 0 59
47332: PUSH
47333: LD_INT 1
47335: NEG
47336: PUSH
47337: LD_INT 2
47339: NEG
47340: PUSH
47341: EMPTY
47342: LIST
47343: LIST
47344: PUSH
47345: LD_INT 0
47347: PUSH
47348: LD_INT 2
47350: NEG
47351: PUSH
47352: EMPTY
47353: LIST
47354: LIST
47355: PUSH
47356: LD_INT 1
47358: PUSH
47359: LD_INT 1
47361: NEG
47362: PUSH
47363: EMPTY
47364: LIST
47365: LIST
47366: PUSH
47367: EMPTY
47368: LIST
47369: LIST
47370: LIST
47371: ST_TO_ADDR
// fBunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
47372: LD_ADDR_VAR 0 60
47376: PUSH
47377: LD_INT 1
47379: PUSH
47380: LD_INT 1
47382: NEG
47383: PUSH
47384: EMPTY
47385: LIST
47386: LIST
47387: PUSH
47388: LD_INT 2
47390: PUSH
47391: LD_INT 0
47393: PUSH
47394: EMPTY
47395: LIST
47396: LIST
47397: PUSH
47398: LD_INT 2
47400: PUSH
47401: LD_INT 1
47403: PUSH
47404: EMPTY
47405: LIST
47406: LIST
47407: PUSH
47408: EMPTY
47409: LIST
47410: LIST
47411: LIST
47412: ST_TO_ADDR
// fBunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
47413: LD_ADDR_VAR 0 61
47417: PUSH
47418: LD_INT 2
47420: PUSH
47421: LD_INT 1
47423: PUSH
47424: EMPTY
47425: LIST
47426: LIST
47427: PUSH
47428: LD_INT 2
47430: PUSH
47431: LD_INT 2
47433: PUSH
47434: EMPTY
47435: LIST
47436: LIST
47437: PUSH
47438: LD_INT 1
47440: PUSH
47441: LD_INT 2
47443: PUSH
47444: EMPTY
47445: LIST
47446: LIST
47447: PUSH
47448: EMPTY
47449: LIST
47450: LIST
47451: LIST
47452: ST_TO_ADDR
// fBunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
47453: LD_ADDR_VAR 0 62
47457: PUSH
47458: LD_INT 1
47460: PUSH
47461: LD_INT 2
47463: PUSH
47464: EMPTY
47465: LIST
47466: LIST
47467: PUSH
47468: LD_INT 0
47470: PUSH
47471: LD_INT 2
47473: PUSH
47474: EMPTY
47475: LIST
47476: LIST
47477: PUSH
47478: LD_INT 1
47480: NEG
47481: PUSH
47482: LD_INT 1
47484: PUSH
47485: EMPTY
47486: LIST
47487: LIST
47488: PUSH
47489: EMPTY
47490: LIST
47491: LIST
47492: LIST
47493: ST_TO_ADDR
// fBunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
47494: LD_ADDR_VAR 0 63
47498: PUSH
47499: LD_INT 1
47501: NEG
47502: PUSH
47503: LD_INT 1
47505: PUSH
47506: EMPTY
47507: LIST
47508: LIST
47509: PUSH
47510: LD_INT 2
47512: NEG
47513: PUSH
47514: LD_INT 0
47516: PUSH
47517: EMPTY
47518: LIST
47519: LIST
47520: PUSH
47521: LD_INT 2
47523: NEG
47524: PUSH
47525: LD_INT 1
47527: NEG
47528: PUSH
47529: EMPTY
47530: LIST
47531: LIST
47532: PUSH
47533: EMPTY
47534: LIST
47535: LIST
47536: LIST
47537: ST_TO_ADDR
// fBunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
47538: LD_ADDR_VAR 0 64
47542: PUSH
47543: LD_INT 1
47545: NEG
47546: PUSH
47547: LD_INT 2
47549: NEG
47550: PUSH
47551: EMPTY
47552: LIST
47553: LIST
47554: PUSH
47555: LD_INT 2
47557: NEG
47558: PUSH
47559: LD_INT 1
47561: NEG
47562: PUSH
47563: EMPTY
47564: LIST
47565: LIST
47566: PUSH
47567: LD_INT 2
47569: NEG
47570: PUSH
47571: LD_INT 2
47573: NEG
47574: PUSH
47575: EMPTY
47576: LIST
47577: LIST
47578: PUSH
47579: EMPTY
47580: LIST
47581: LIST
47582: LIST
47583: ST_TO_ADDR
// end ; 2 :
47584: GO 50850
47586: LD_INT 2
47588: DOUBLE
47589: EQUAL
47590: IFTRUE 47594
47592: GO 50849
47594: POP
// begin fFactory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
47595: LD_ADDR_VAR 0 29
47599: PUSH
47600: LD_INT 4
47602: PUSH
47603: LD_INT 0
47605: PUSH
47606: EMPTY
47607: LIST
47608: LIST
47609: PUSH
47610: LD_INT 4
47612: PUSH
47613: LD_INT 1
47615: NEG
47616: PUSH
47617: EMPTY
47618: LIST
47619: LIST
47620: PUSH
47621: LD_INT 5
47623: PUSH
47624: LD_INT 0
47626: PUSH
47627: EMPTY
47628: LIST
47629: LIST
47630: PUSH
47631: LD_INT 5
47633: PUSH
47634: LD_INT 1
47636: PUSH
47637: EMPTY
47638: LIST
47639: LIST
47640: PUSH
47641: LD_INT 4
47643: PUSH
47644: LD_INT 1
47646: PUSH
47647: EMPTY
47648: LIST
47649: LIST
47650: PUSH
47651: LD_INT 3
47653: PUSH
47654: LD_INT 0
47656: PUSH
47657: EMPTY
47658: LIST
47659: LIST
47660: PUSH
47661: LD_INT 3
47663: PUSH
47664: LD_INT 1
47666: NEG
47667: PUSH
47668: EMPTY
47669: LIST
47670: LIST
47671: PUSH
47672: LD_INT 3
47674: PUSH
47675: LD_INT 2
47677: NEG
47678: PUSH
47679: EMPTY
47680: LIST
47681: LIST
47682: PUSH
47683: LD_INT 5
47685: PUSH
47686: LD_INT 2
47688: PUSH
47689: EMPTY
47690: LIST
47691: LIST
47692: PUSH
47693: LD_INT 3
47695: PUSH
47696: LD_INT 3
47698: PUSH
47699: EMPTY
47700: LIST
47701: LIST
47702: PUSH
47703: LD_INT 3
47705: PUSH
47706: LD_INT 2
47708: PUSH
47709: EMPTY
47710: LIST
47711: LIST
47712: PUSH
47713: LD_INT 4
47715: PUSH
47716: LD_INT 3
47718: PUSH
47719: EMPTY
47720: LIST
47721: LIST
47722: PUSH
47723: LD_INT 4
47725: PUSH
47726: LD_INT 4
47728: PUSH
47729: EMPTY
47730: LIST
47731: LIST
47732: PUSH
47733: LD_INT 3
47735: PUSH
47736: LD_INT 4
47738: PUSH
47739: EMPTY
47740: LIST
47741: LIST
47742: PUSH
47743: LD_INT 2
47745: PUSH
47746: LD_INT 3
47748: PUSH
47749: EMPTY
47750: LIST
47751: LIST
47752: PUSH
47753: LD_INT 2
47755: PUSH
47756: LD_INT 2
47758: PUSH
47759: EMPTY
47760: LIST
47761: LIST
47762: PUSH
47763: LD_INT 4
47765: PUSH
47766: LD_INT 2
47768: PUSH
47769: EMPTY
47770: LIST
47771: LIST
47772: PUSH
47773: LD_INT 2
47775: PUSH
47776: LD_INT 4
47778: PUSH
47779: EMPTY
47780: LIST
47781: LIST
47782: PUSH
47783: LD_INT 0
47785: PUSH
47786: LD_INT 4
47788: PUSH
47789: EMPTY
47790: LIST
47791: LIST
47792: PUSH
47793: LD_INT 0
47795: PUSH
47796: LD_INT 3
47798: PUSH
47799: EMPTY
47800: LIST
47801: LIST
47802: PUSH
47803: LD_INT 1
47805: PUSH
47806: LD_INT 4
47808: PUSH
47809: EMPTY
47810: LIST
47811: LIST
47812: PUSH
47813: LD_INT 1
47815: PUSH
47816: LD_INT 5
47818: PUSH
47819: EMPTY
47820: LIST
47821: LIST
47822: PUSH
47823: LD_INT 0
47825: PUSH
47826: LD_INT 5
47828: PUSH
47829: EMPTY
47830: LIST
47831: LIST
47832: PUSH
47833: LD_INT 1
47835: NEG
47836: PUSH
47837: LD_INT 4
47839: PUSH
47840: EMPTY
47841: LIST
47842: LIST
47843: PUSH
47844: LD_INT 1
47846: NEG
47847: PUSH
47848: LD_INT 3
47850: PUSH
47851: EMPTY
47852: LIST
47853: LIST
47854: PUSH
47855: LD_INT 2
47857: PUSH
47858: LD_INT 5
47860: PUSH
47861: EMPTY
47862: LIST
47863: LIST
47864: PUSH
47865: LD_INT 2
47867: NEG
47868: PUSH
47869: LD_INT 3
47871: PUSH
47872: EMPTY
47873: LIST
47874: LIST
47875: PUSH
47876: LD_INT 3
47878: NEG
47879: PUSH
47880: LD_INT 0
47882: PUSH
47883: EMPTY
47884: LIST
47885: LIST
47886: PUSH
47887: LD_INT 3
47889: NEG
47890: PUSH
47891: LD_INT 1
47893: NEG
47894: PUSH
47895: EMPTY
47896: LIST
47897: LIST
47898: PUSH
47899: LD_INT 2
47901: NEG
47902: PUSH
47903: LD_INT 0
47905: PUSH
47906: EMPTY
47907: LIST
47908: LIST
47909: PUSH
47910: LD_INT 2
47912: NEG
47913: PUSH
47914: LD_INT 1
47916: PUSH
47917: EMPTY
47918: LIST
47919: LIST
47920: PUSH
47921: LD_INT 3
47923: NEG
47924: PUSH
47925: LD_INT 1
47927: PUSH
47928: EMPTY
47929: LIST
47930: LIST
47931: PUSH
47932: LD_INT 4
47934: NEG
47935: PUSH
47936: LD_INT 0
47938: PUSH
47939: EMPTY
47940: LIST
47941: LIST
47942: PUSH
47943: LD_INT 4
47945: NEG
47946: PUSH
47947: LD_INT 1
47949: NEG
47950: PUSH
47951: EMPTY
47952: LIST
47953: LIST
47954: PUSH
47955: LD_INT 4
47957: NEG
47958: PUSH
47959: LD_INT 2
47961: NEG
47962: PUSH
47963: EMPTY
47964: LIST
47965: LIST
47966: PUSH
47967: LD_INT 2
47969: NEG
47970: PUSH
47971: LD_INT 2
47973: PUSH
47974: EMPTY
47975: LIST
47976: LIST
47977: PUSH
47978: LD_INT 4
47980: NEG
47981: PUSH
47982: LD_INT 4
47984: NEG
47985: PUSH
47986: EMPTY
47987: LIST
47988: LIST
47989: PUSH
47990: LD_INT 4
47992: NEG
47993: PUSH
47994: LD_INT 5
47996: NEG
47997: PUSH
47998: EMPTY
47999: LIST
48000: LIST
48001: PUSH
48002: LD_INT 3
48004: NEG
48005: PUSH
48006: LD_INT 4
48008: NEG
48009: PUSH
48010: EMPTY
48011: LIST
48012: LIST
48013: PUSH
48014: LD_INT 3
48016: NEG
48017: PUSH
48018: LD_INT 3
48020: NEG
48021: PUSH
48022: EMPTY
48023: LIST
48024: LIST
48025: PUSH
48026: LD_INT 4
48028: NEG
48029: PUSH
48030: LD_INT 3
48032: NEG
48033: PUSH
48034: EMPTY
48035: LIST
48036: LIST
48037: PUSH
48038: LD_INT 5
48040: NEG
48041: PUSH
48042: LD_INT 4
48044: NEG
48045: PUSH
48046: EMPTY
48047: LIST
48048: LIST
48049: PUSH
48050: LD_INT 5
48052: NEG
48053: PUSH
48054: LD_INT 5
48056: NEG
48057: PUSH
48058: EMPTY
48059: LIST
48060: LIST
48061: PUSH
48062: LD_INT 3
48064: NEG
48065: PUSH
48066: LD_INT 5
48068: NEG
48069: PUSH
48070: EMPTY
48071: LIST
48072: LIST
48073: PUSH
48074: LD_INT 5
48076: NEG
48077: PUSH
48078: LD_INT 3
48080: NEG
48081: PUSH
48082: EMPTY
48083: LIST
48084: LIST
48085: PUSH
48086: EMPTY
48087: LIST
48088: LIST
48089: LIST
48090: LIST
48091: LIST
48092: LIST
48093: LIST
48094: LIST
48095: LIST
48096: LIST
48097: LIST
48098: LIST
48099: LIST
48100: LIST
48101: LIST
48102: LIST
48103: LIST
48104: LIST
48105: LIST
48106: LIST
48107: LIST
48108: LIST
48109: LIST
48110: LIST
48111: LIST
48112: LIST
48113: LIST
48114: LIST
48115: LIST
48116: LIST
48117: LIST
48118: LIST
48119: LIST
48120: LIST
48121: LIST
48122: LIST
48123: LIST
48124: LIST
48125: LIST
48126: LIST
48127: LIST
48128: LIST
48129: LIST
48130: LIST
48131: LIST
48132: ST_TO_ADDR
// fFactory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
48133: LD_ADDR_VAR 0 30
48137: PUSH
48138: LD_INT 4
48140: PUSH
48141: LD_INT 4
48143: PUSH
48144: EMPTY
48145: LIST
48146: LIST
48147: PUSH
48148: LD_INT 4
48150: PUSH
48151: LD_INT 3
48153: PUSH
48154: EMPTY
48155: LIST
48156: LIST
48157: PUSH
48158: LD_INT 5
48160: PUSH
48161: LD_INT 4
48163: PUSH
48164: EMPTY
48165: LIST
48166: LIST
48167: PUSH
48168: LD_INT 5
48170: PUSH
48171: LD_INT 5
48173: PUSH
48174: EMPTY
48175: LIST
48176: LIST
48177: PUSH
48178: LD_INT 4
48180: PUSH
48181: LD_INT 5
48183: PUSH
48184: EMPTY
48185: LIST
48186: LIST
48187: PUSH
48188: LD_INT 3
48190: PUSH
48191: LD_INT 4
48193: PUSH
48194: EMPTY
48195: LIST
48196: LIST
48197: PUSH
48198: LD_INT 3
48200: PUSH
48201: LD_INT 3
48203: PUSH
48204: EMPTY
48205: LIST
48206: LIST
48207: PUSH
48208: LD_INT 5
48210: PUSH
48211: LD_INT 3
48213: PUSH
48214: EMPTY
48215: LIST
48216: LIST
48217: PUSH
48218: LD_INT 3
48220: PUSH
48221: LD_INT 5
48223: PUSH
48224: EMPTY
48225: LIST
48226: LIST
48227: PUSH
48228: LD_INT 0
48230: PUSH
48231: LD_INT 3
48233: PUSH
48234: EMPTY
48235: LIST
48236: LIST
48237: PUSH
48238: LD_INT 0
48240: PUSH
48241: LD_INT 2
48243: PUSH
48244: EMPTY
48245: LIST
48246: LIST
48247: PUSH
48248: LD_INT 1
48250: PUSH
48251: LD_INT 3
48253: PUSH
48254: EMPTY
48255: LIST
48256: LIST
48257: PUSH
48258: LD_INT 1
48260: PUSH
48261: LD_INT 4
48263: PUSH
48264: EMPTY
48265: LIST
48266: LIST
48267: PUSH
48268: LD_INT 0
48270: PUSH
48271: LD_INT 4
48273: PUSH
48274: EMPTY
48275: LIST
48276: LIST
48277: PUSH
48278: LD_INT 1
48280: NEG
48281: PUSH
48282: LD_INT 3
48284: PUSH
48285: EMPTY
48286: LIST
48287: LIST
48288: PUSH
48289: LD_INT 1
48291: NEG
48292: PUSH
48293: LD_INT 2
48295: PUSH
48296: EMPTY
48297: LIST
48298: LIST
48299: PUSH
48300: LD_INT 2
48302: PUSH
48303: LD_INT 4
48305: PUSH
48306: EMPTY
48307: LIST
48308: LIST
48309: PUSH
48310: LD_INT 2
48312: NEG
48313: PUSH
48314: LD_INT 2
48316: PUSH
48317: EMPTY
48318: LIST
48319: LIST
48320: PUSH
48321: LD_INT 4
48323: NEG
48324: PUSH
48325: LD_INT 0
48327: PUSH
48328: EMPTY
48329: LIST
48330: LIST
48331: PUSH
48332: LD_INT 4
48334: NEG
48335: PUSH
48336: LD_INT 1
48338: NEG
48339: PUSH
48340: EMPTY
48341: LIST
48342: LIST
48343: PUSH
48344: LD_INT 3
48346: NEG
48347: PUSH
48348: LD_INT 0
48350: PUSH
48351: EMPTY
48352: LIST
48353: LIST
48354: PUSH
48355: LD_INT 3
48357: NEG
48358: PUSH
48359: LD_INT 1
48361: PUSH
48362: EMPTY
48363: LIST
48364: LIST
48365: PUSH
48366: LD_INT 4
48368: NEG
48369: PUSH
48370: LD_INT 1
48372: PUSH
48373: EMPTY
48374: LIST
48375: LIST
48376: PUSH
48377: LD_INT 5
48379: NEG
48380: PUSH
48381: LD_INT 0
48383: PUSH
48384: EMPTY
48385: LIST
48386: LIST
48387: PUSH
48388: LD_INT 5
48390: NEG
48391: PUSH
48392: LD_INT 1
48394: NEG
48395: PUSH
48396: EMPTY
48397: LIST
48398: LIST
48399: PUSH
48400: LD_INT 5
48402: NEG
48403: PUSH
48404: LD_INT 2
48406: NEG
48407: PUSH
48408: EMPTY
48409: LIST
48410: LIST
48411: PUSH
48412: LD_INT 3
48414: NEG
48415: PUSH
48416: LD_INT 2
48418: PUSH
48419: EMPTY
48420: LIST
48421: LIST
48422: PUSH
48423: LD_INT 3
48425: NEG
48426: PUSH
48427: LD_INT 3
48429: NEG
48430: PUSH
48431: EMPTY
48432: LIST
48433: LIST
48434: PUSH
48435: LD_INT 3
48437: NEG
48438: PUSH
48439: LD_INT 4
48441: NEG
48442: PUSH
48443: EMPTY
48444: LIST
48445: LIST
48446: PUSH
48447: LD_INT 2
48449: NEG
48450: PUSH
48451: LD_INT 3
48453: NEG
48454: PUSH
48455: EMPTY
48456: LIST
48457: LIST
48458: PUSH
48459: LD_INT 2
48461: NEG
48462: PUSH
48463: LD_INT 2
48465: NEG
48466: PUSH
48467: EMPTY
48468: LIST
48469: LIST
48470: PUSH
48471: LD_INT 3
48473: NEG
48474: PUSH
48475: LD_INT 2
48477: NEG
48478: PUSH
48479: EMPTY
48480: LIST
48481: LIST
48482: PUSH
48483: LD_INT 4
48485: NEG
48486: PUSH
48487: LD_INT 3
48489: NEG
48490: PUSH
48491: EMPTY
48492: LIST
48493: LIST
48494: PUSH
48495: LD_INT 4
48497: NEG
48498: PUSH
48499: LD_INT 4
48501: NEG
48502: PUSH
48503: EMPTY
48504: LIST
48505: LIST
48506: PUSH
48507: LD_INT 2
48509: NEG
48510: PUSH
48511: LD_INT 4
48513: NEG
48514: PUSH
48515: EMPTY
48516: LIST
48517: LIST
48518: PUSH
48519: LD_INT 4
48521: NEG
48522: PUSH
48523: LD_INT 2
48525: NEG
48526: PUSH
48527: EMPTY
48528: LIST
48529: LIST
48530: PUSH
48531: LD_INT 0
48533: PUSH
48534: LD_INT 4
48536: NEG
48537: PUSH
48538: EMPTY
48539: LIST
48540: LIST
48541: PUSH
48542: LD_INT 0
48544: PUSH
48545: LD_INT 5
48547: NEG
48548: PUSH
48549: EMPTY
48550: LIST
48551: LIST
48552: PUSH
48553: LD_INT 1
48555: PUSH
48556: LD_INT 4
48558: NEG
48559: PUSH
48560: EMPTY
48561: LIST
48562: LIST
48563: PUSH
48564: LD_INT 1
48566: PUSH
48567: LD_INT 3
48569: NEG
48570: PUSH
48571: EMPTY
48572: LIST
48573: LIST
48574: PUSH
48575: LD_INT 0
48577: PUSH
48578: LD_INT 3
48580: NEG
48581: PUSH
48582: EMPTY
48583: LIST
48584: LIST
48585: PUSH
48586: LD_INT 1
48588: NEG
48589: PUSH
48590: LD_INT 4
48592: NEG
48593: PUSH
48594: EMPTY
48595: LIST
48596: LIST
48597: PUSH
48598: LD_INT 1
48600: NEG
48601: PUSH
48602: LD_INT 5
48604: NEG
48605: PUSH
48606: EMPTY
48607: LIST
48608: LIST
48609: PUSH
48610: LD_INT 2
48612: PUSH
48613: LD_INT 3
48615: NEG
48616: PUSH
48617: EMPTY
48618: LIST
48619: LIST
48620: PUSH
48621: LD_INT 2
48623: NEG
48624: PUSH
48625: LD_INT 5
48627: NEG
48628: PUSH
48629: EMPTY
48630: LIST
48631: LIST
48632: PUSH
48633: EMPTY
48634: LIST
48635: LIST
48636: LIST
48637: LIST
48638: LIST
48639: LIST
48640: LIST
48641: LIST
48642: LIST
48643: LIST
48644: LIST
48645: LIST
48646: LIST
48647: LIST
48648: LIST
48649: LIST
48650: LIST
48651: LIST
48652: LIST
48653: LIST
48654: LIST
48655: LIST
48656: LIST
48657: LIST
48658: LIST
48659: LIST
48660: LIST
48661: LIST
48662: LIST
48663: LIST
48664: LIST
48665: LIST
48666: LIST
48667: LIST
48668: LIST
48669: LIST
48670: LIST
48671: LIST
48672: LIST
48673: LIST
48674: LIST
48675: LIST
48676: LIST
48677: LIST
48678: LIST
48679: ST_TO_ADDR
// fFactory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
48680: LD_ADDR_VAR 0 31
48684: PUSH
48685: LD_INT 0
48687: PUSH
48688: LD_INT 4
48690: PUSH
48691: EMPTY
48692: LIST
48693: LIST
48694: PUSH
48695: LD_INT 0
48697: PUSH
48698: LD_INT 3
48700: PUSH
48701: EMPTY
48702: LIST
48703: LIST
48704: PUSH
48705: LD_INT 1
48707: PUSH
48708: LD_INT 4
48710: PUSH
48711: EMPTY
48712: LIST
48713: LIST
48714: PUSH
48715: LD_INT 1
48717: PUSH
48718: LD_INT 5
48720: PUSH
48721: EMPTY
48722: LIST
48723: LIST
48724: PUSH
48725: LD_INT 0
48727: PUSH
48728: LD_INT 5
48730: PUSH
48731: EMPTY
48732: LIST
48733: LIST
48734: PUSH
48735: LD_INT 1
48737: NEG
48738: PUSH
48739: LD_INT 4
48741: PUSH
48742: EMPTY
48743: LIST
48744: LIST
48745: PUSH
48746: LD_INT 1
48748: NEG
48749: PUSH
48750: LD_INT 3
48752: PUSH
48753: EMPTY
48754: LIST
48755: LIST
48756: PUSH
48757: LD_INT 2
48759: PUSH
48760: LD_INT 5
48762: PUSH
48763: EMPTY
48764: LIST
48765: LIST
48766: PUSH
48767: LD_INT 2
48769: NEG
48770: PUSH
48771: LD_INT 3
48773: PUSH
48774: EMPTY
48775: LIST
48776: LIST
48777: PUSH
48778: LD_INT 3
48780: NEG
48781: PUSH
48782: LD_INT 0
48784: PUSH
48785: EMPTY
48786: LIST
48787: LIST
48788: PUSH
48789: LD_INT 3
48791: NEG
48792: PUSH
48793: LD_INT 1
48795: NEG
48796: PUSH
48797: EMPTY
48798: LIST
48799: LIST
48800: PUSH
48801: LD_INT 2
48803: NEG
48804: PUSH
48805: LD_INT 0
48807: PUSH
48808: EMPTY
48809: LIST
48810: LIST
48811: PUSH
48812: LD_INT 2
48814: NEG
48815: PUSH
48816: LD_INT 1
48818: PUSH
48819: EMPTY
48820: LIST
48821: LIST
48822: PUSH
48823: LD_INT 3
48825: NEG
48826: PUSH
48827: LD_INT 1
48829: PUSH
48830: EMPTY
48831: LIST
48832: LIST
48833: PUSH
48834: LD_INT 4
48836: NEG
48837: PUSH
48838: LD_INT 0
48840: PUSH
48841: EMPTY
48842: LIST
48843: LIST
48844: PUSH
48845: LD_INT 4
48847: NEG
48848: PUSH
48849: LD_INT 1
48851: NEG
48852: PUSH
48853: EMPTY
48854: LIST
48855: LIST
48856: PUSH
48857: LD_INT 4
48859: NEG
48860: PUSH
48861: LD_INT 2
48863: NEG
48864: PUSH
48865: EMPTY
48866: LIST
48867: LIST
48868: PUSH
48869: LD_INT 2
48871: NEG
48872: PUSH
48873: LD_INT 2
48875: PUSH
48876: EMPTY
48877: LIST
48878: LIST
48879: PUSH
48880: LD_INT 4
48882: NEG
48883: PUSH
48884: LD_INT 4
48886: NEG
48887: PUSH
48888: EMPTY
48889: LIST
48890: LIST
48891: PUSH
48892: LD_INT 4
48894: NEG
48895: PUSH
48896: LD_INT 5
48898: NEG
48899: PUSH
48900: EMPTY
48901: LIST
48902: LIST
48903: PUSH
48904: LD_INT 3
48906: NEG
48907: PUSH
48908: LD_INT 4
48910: NEG
48911: PUSH
48912: EMPTY
48913: LIST
48914: LIST
48915: PUSH
48916: LD_INT 3
48918: NEG
48919: PUSH
48920: LD_INT 3
48922: NEG
48923: PUSH
48924: EMPTY
48925: LIST
48926: LIST
48927: PUSH
48928: LD_INT 4
48930: NEG
48931: PUSH
48932: LD_INT 3
48934: NEG
48935: PUSH
48936: EMPTY
48937: LIST
48938: LIST
48939: PUSH
48940: LD_INT 5
48942: NEG
48943: PUSH
48944: LD_INT 4
48946: NEG
48947: PUSH
48948: EMPTY
48949: LIST
48950: LIST
48951: PUSH
48952: LD_INT 5
48954: NEG
48955: PUSH
48956: LD_INT 5
48958: NEG
48959: PUSH
48960: EMPTY
48961: LIST
48962: LIST
48963: PUSH
48964: LD_INT 3
48966: NEG
48967: PUSH
48968: LD_INT 5
48970: NEG
48971: PUSH
48972: EMPTY
48973: LIST
48974: LIST
48975: PUSH
48976: LD_INT 5
48978: NEG
48979: PUSH
48980: LD_INT 3
48982: NEG
48983: PUSH
48984: EMPTY
48985: LIST
48986: LIST
48987: PUSH
48988: LD_INT 0
48990: PUSH
48991: LD_INT 3
48993: NEG
48994: PUSH
48995: EMPTY
48996: LIST
48997: LIST
48998: PUSH
48999: LD_INT 0
49001: PUSH
49002: LD_INT 4
49004: NEG
49005: PUSH
49006: EMPTY
49007: LIST
49008: LIST
49009: PUSH
49010: LD_INT 1
49012: PUSH
49013: LD_INT 3
49015: NEG
49016: PUSH
49017: EMPTY
49018: LIST
49019: LIST
49020: PUSH
49021: LD_INT 1
49023: PUSH
49024: LD_INT 2
49026: NEG
49027: PUSH
49028: EMPTY
49029: LIST
49030: LIST
49031: PUSH
49032: LD_INT 0
49034: PUSH
49035: LD_INT 2
49037: NEG
49038: PUSH
49039: EMPTY
49040: LIST
49041: LIST
49042: PUSH
49043: LD_INT 1
49045: NEG
49046: PUSH
49047: LD_INT 3
49049: NEG
49050: PUSH
49051: EMPTY
49052: LIST
49053: LIST
49054: PUSH
49055: LD_INT 1
49057: NEG
49058: PUSH
49059: LD_INT 4
49061: NEG
49062: PUSH
49063: EMPTY
49064: LIST
49065: LIST
49066: PUSH
49067: LD_INT 2
49069: PUSH
49070: LD_INT 2
49072: NEG
49073: PUSH
49074: EMPTY
49075: LIST
49076: LIST
49077: PUSH
49078: LD_INT 2
49080: NEG
49081: PUSH
49082: LD_INT 4
49084: NEG
49085: PUSH
49086: EMPTY
49087: LIST
49088: LIST
49089: PUSH
49090: LD_INT 4
49092: PUSH
49093: LD_INT 0
49095: PUSH
49096: EMPTY
49097: LIST
49098: LIST
49099: PUSH
49100: LD_INT 4
49102: PUSH
49103: LD_INT 1
49105: NEG
49106: PUSH
49107: EMPTY
49108: LIST
49109: LIST
49110: PUSH
49111: LD_INT 5
49113: PUSH
49114: LD_INT 0
49116: PUSH
49117: EMPTY
49118: LIST
49119: LIST
49120: PUSH
49121: LD_INT 5
49123: PUSH
49124: LD_INT 1
49126: PUSH
49127: EMPTY
49128: LIST
49129: LIST
49130: PUSH
49131: LD_INT 4
49133: PUSH
49134: LD_INT 1
49136: PUSH
49137: EMPTY
49138: LIST
49139: LIST
49140: PUSH
49141: LD_INT 3
49143: PUSH
49144: LD_INT 0
49146: PUSH
49147: EMPTY
49148: LIST
49149: LIST
49150: PUSH
49151: LD_INT 3
49153: PUSH
49154: LD_INT 1
49156: NEG
49157: PUSH
49158: EMPTY
49159: LIST
49160: LIST
49161: PUSH
49162: LD_INT 3
49164: PUSH
49165: LD_INT 2
49167: NEG
49168: PUSH
49169: EMPTY
49170: LIST
49171: LIST
49172: PUSH
49173: LD_INT 5
49175: PUSH
49176: LD_INT 2
49178: PUSH
49179: EMPTY
49180: LIST
49181: LIST
49182: PUSH
49183: EMPTY
49184: LIST
49185: LIST
49186: LIST
49187: LIST
49188: LIST
49189: LIST
49190: LIST
49191: LIST
49192: LIST
49193: LIST
49194: LIST
49195: LIST
49196: LIST
49197: LIST
49198: LIST
49199: LIST
49200: LIST
49201: LIST
49202: LIST
49203: LIST
49204: LIST
49205: LIST
49206: LIST
49207: LIST
49208: LIST
49209: LIST
49210: LIST
49211: LIST
49212: LIST
49213: LIST
49214: LIST
49215: LIST
49216: LIST
49217: LIST
49218: LIST
49219: LIST
49220: LIST
49221: LIST
49222: LIST
49223: LIST
49224: LIST
49225: LIST
49226: LIST
49227: LIST
49228: LIST
49229: ST_TO_ADDR
// fFactory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
49230: LD_ADDR_VAR 0 32
49234: PUSH
49235: LD_INT 4
49237: NEG
49238: PUSH
49239: LD_INT 0
49241: PUSH
49242: EMPTY
49243: LIST
49244: LIST
49245: PUSH
49246: LD_INT 4
49248: NEG
49249: PUSH
49250: LD_INT 1
49252: NEG
49253: PUSH
49254: EMPTY
49255: LIST
49256: LIST
49257: PUSH
49258: LD_INT 3
49260: NEG
49261: PUSH
49262: LD_INT 0
49264: PUSH
49265: EMPTY
49266: LIST
49267: LIST
49268: PUSH
49269: LD_INT 3
49271: NEG
49272: PUSH
49273: LD_INT 1
49275: PUSH
49276: EMPTY
49277: LIST
49278: LIST
49279: PUSH
49280: LD_INT 4
49282: NEG
49283: PUSH
49284: LD_INT 1
49286: PUSH
49287: EMPTY
49288: LIST
49289: LIST
49290: PUSH
49291: LD_INT 5
49293: NEG
49294: PUSH
49295: LD_INT 0
49297: PUSH
49298: EMPTY
49299: LIST
49300: LIST
49301: PUSH
49302: LD_INT 5
49304: NEG
49305: PUSH
49306: LD_INT 1
49308: NEG
49309: PUSH
49310: EMPTY
49311: LIST
49312: LIST
49313: PUSH
49314: LD_INT 5
49316: NEG
49317: PUSH
49318: LD_INT 2
49320: NEG
49321: PUSH
49322: EMPTY
49323: LIST
49324: LIST
49325: PUSH
49326: LD_INT 3
49328: NEG
49329: PUSH
49330: LD_INT 2
49332: PUSH
49333: EMPTY
49334: LIST
49335: LIST
49336: PUSH
49337: LD_INT 3
49339: NEG
49340: PUSH
49341: LD_INT 3
49343: NEG
49344: PUSH
49345: EMPTY
49346: LIST
49347: LIST
49348: PUSH
49349: LD_INT 3
49351: NEG
49352: PUSH
49353: LD_INT 4
49355: NEG
49356: PUSH
49357: EMPTY
49358: LIST
49359: LIST
49360: PUSH
49361: LD_INT 2
49363: NEG
49364: PUSH
49365: LD_INT 3
49367: NEG
49368: PUSH
49369: EMPTY
49370: LIST
49371: LIST
49372: PUSH
49373: LD_INT 2
49375: NEG
49376: PUSH
49377: LD_INT 2
49379: NEG
49380: PUSH
49381: EMPTY
49382: LIST
49383: LIST
49384: PUSH
49385: LD_INT 3
49387: NEG
49388: PUSH
49389: LD_INT 2
49391: NEG
49392: PUSH
49393: EMPTY
49394: LIST
49395: LIST
49396: PUSH
49397: LD_INT 4
49399: NEG
49400: PUSH
49401: LD_INT 3
49403: NEG
49404: PUSH
49405: EMPTY
49406: LIST
49407: LIST
49408: PUSH
49409: LD_INT 4
49411: NEG
49412: PUSH
49413: LD_INT 4
49415: NEG
49416: PUSH
49417: EMPTY
49418: LIST
49419: LIST
49420: PUSH
49421: LD_INT 2
49423: NEG
49424: PUSH
49425: LD_INT 4
49427: NEG
49428: PUSH
49429: EMPTY
49430: LIST
49431: LIST
49432: PUSH
49433: LD_INT 4
49435: NEG
49436: PUSH
49437: LD_INT 2
49439: NEG
49440: PUSH
49441: EMPTY
49442: LIST
49443: LIST
49444: PUSH
49445: LD_INT 0
49447: PUSH
49448: LD_INT 4
49450: NEG
49451: PUSH
49452: EMPTY
49453: LIST
49454: LIST
49455: PUSH
49456: LD_INT 0
49458: PUSH
49459: LD_INT 5
49461: NEG
49462: PUSH
49463: EMPTY
49464: LIST
49465: LIST
49466: PUSH
49467: LD_INT 1
49469: PUSH
49470: LD_INT 4
49472: NEG
49473: PUSH
49474: EMPTY
49475: LIST
49476: LIST
49477: PUSH
49478: LD_INT 1
49480: PUSH
49481: LD_INT 3
49483: NEG
49484: PUSH
49485: EMPTY
49486: LIST
49487: LIST
49488: PUSH
49489: LD_INT 0
49491: PUSH
49492: LD_INT 3
49494: NEG
49495: PUSH
49496: EMPTY
49497: LIST
49498: LIST
49499: PUSH
49500: LD_INT 1
49502: NEG
49503: PUSH
49504: LD_INT 4
49506: NEG
49507: PUSH
49508: EMPTY
49509: LIST
49510: LIST
49511: PUSH
49512: LD_INT 1
49514: NEG
49515: PUSH
49516: LD_INT 5
49518: NEG
49519: PUSH
49520: EMPTY
49521: LIST
49522: LIST
49523: PUSH
49524: LD_INT 2
49526: PUSH
49527: LD_INT 3
49529: NEG
49530: PUSH
49531: EMPTY
49532: LIST
49533: LIST
49534: PUSH
49535: LD_INT 2
49537: NEG
49538: PUSH
49539: LD_INT 5
49541: NEG
49542: PUSH
49543: EMPTY
49544: LIST
49545: LIST
49546: PUSH
49547: LD_INT 3
49549: PUSH
49550: LD_INT 0
49552: PUSH
49553: EMPTY
49554: LIST
49555: LIST
49556: PUSH
49557: LD_INT 3
49559: PUSH
49560: LD_INT 1
49562: NEG
49563: PUSH
49564: EMPTY
49565: LIST
49566: LIST
49567: PUSH
49568: LD_INT 4
49570: PUSH
49571: LD_INT 0
49573: PUSH
49574: EMPTY
49575: LIST
49576: LIST
49577: PUSH
49578: LD_INT 4
49580: PUSH
49581: LD_INT 1
49583: PUSH
49584: EMPTY
49585: LIST
49586: LIST
49587: PUSH
49588: LD_INT 3
49590: PUSH
49591: LD_INT 1
49593: PUSH
49594: EMPTY
49595: LIST
49596: LIST
49597: PUSH
49598: LD_INT 2
49600: PUSH
49601: LD_INT 0
49603: PUSH
49604: EMPTY
49605: LIST
49606: LIST
49607: PUSH
49608: LD_INT 2
49610: PUSH
49611: LD_INT 1
49613: NEG
49614: PUSH
49615: EMPTY
49616: LIST
49617: LIST
49618: PUSH
49619: LD_INT 2
49621: PUSH
49622: LD_INT 2
49624: NEG
49625: PUSH
49626: EMPTY
49627: LIST
49628: LIST
49629: PUSH
49630: LD_INT 4
49632: PUSH
49633: LD_INT 2
49635: PUSH
49636: EMPTY
49637: LIST
49638: LIST
49639: PUSH
49640: LD_INT 4
49642: PUSH
49643: LD_INT 4
49645: PUSH
49646: EMPTY
49647: LIST
49648: LIST
49649: PUSH
49650: LD_INT 4
49652: PUSH
49653: LD_INT 3
49655: PUSH
49656: EMPTY
49657: LIST
49658: LIST
49659: PUSH
49660: LD_INT 5
49662: PUSH
49663: LD_INT 4
49665: PUSH
49666: EMPTY
49667: LIST
49668: LIST
49669: PUSH
49670: LD_INT 5
49672: PUSH
49673: LD_INT 5
49675: PUSH
49676: EMPTY
49677: LIST
49678: LIST
49679: PUSH
49680: LD_INT 4
49682: PUSH
49683: LD_INT 5
49685: PUSH
49686: EMPTY
49687: LIST
49688: LIST
49689: PUSH
49690: LD_INT 3
49692: PUSH
49693: LD_INT 4
49695: PUSH
49696: EMPTY
49697: LIST
49698: LIST
49699: PUSH
49700: LD_INT 3
49702: PUSH
49703: LD_INT 3
49705: PUSH
49706: EMPTY
49707: LIST
49708: LIST
49709: PUSH
49710: LD_INT 5
49712: PUSH
49713: LD_INT 3
49715: PUSH
49716: EMPTY
49717: LIST
49718: LIST
49719: PUSH
49720: LD_INT 3
49722: PUSH
49723: LD_INT 5
49725: PUSH
49726: EMPTY
49727: LIST
49728: LIST
49729: PUSH
49730: EMPTY
49731: LIST
49732: LIST
49733: LIST
49734: LIST
49735: LIST
49736: LIST
49737: LIST
49738: LIST
49739: LIST
49740: LIST
49741: LIST
49742: LIST
49743: LIST
49744: LIST
49745: LIST
49746: LIST
49747: LIST
49748: LIST
49749: LIST
49750: LIST
49751: LIST
49752: LIST
49753: LIST
49754: LIST
49755: LIST
49756: LIST
49757: LIST
49758: LIST
49759: LIST
49760: LIST
49761: LIST
49762: LIST
49763: LIST
49764: LIST
49765: LIST
49766: LIST
49767: LIST
49768: LIST
49769: LIST
49770: LIST
49771: LIST
49772: LIST
49773: LIST
49774: LIST
49775: LIST
49776: ST_TO_ADDR
// fFactory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
49777: LD_ADDR_VAR 0 33
49781: PUSH
49782: LD_INT 4
49784: NEG
49785: PUSH
49786: LD_INT 4
49788: NEG
49789: PUSH
49790: EMPTY
49791: LIST
49792: LIST
49793: PUSH
49794: LD_INT 4
49796: NEG
49797: PUSH
49798: LD_INT 5
49800: NEG
49801: PUSH
49802: EMPTY
49803: LIST
49804: LIST
49805: PUSH
49806: LD_INT 3
49808: NEG
49809: PUSH
49810: LD_INT 4
49812: NEG
49813: PUSH
49814: EMPTY
49815: LIST
49816: LIST
49817: PUSH
49818: LD_INT 3
49820: NEG
49821: PUSH
49822: LD_INT 3
49824: NEG
49825: PUSH
49826: EMPTY
49827: LIST
49828: LIST
49829: PUSH
49830: LD_INT 4
49832: NEG
49833: PUSH
49834: LD_INT 3
49836: NEG
49837: PUSH
49838: EMPTY
49839: LIST
49840: LIST
49841: PUSH
49842: LD_INT 5
49844: NEG
49845: PUSH
49846: LD_INT 4
49848: NEG
49849: PUSH
49850: EMPTY
49851: LIST
49852: LIST
49853: PUSH
49854: LD_INT 5
49856: NEG
49857: PUSH
49858: LD_INT 5
49860: NEG
49861: PUSH
49862: EMPTY
49863: LIST
49864: LIST
49865: PUSH
49866: LD_INT 3
49868: NEG
49869: PUSH
49870: LD_INT 5
49872: NEG
49873: PUSH
49874: EMPTY
49875: LIST
49876: LIST
49877: PUSH
49878: LD_INT 5
49880: NEG
49881: PUSH
49882: LD_INT 3
49884: NEG
49885: PUSH
49886: EMPTY
49887: LIST
49888: LIST
49889: PUSH
49890: LD_INT 0
49892: PUSH
49893: LD_INT 3
49895: NEG
49896: PUSH
49897: EMPTY
49898: LIST
49899: LIST
49900: PUSH
49901: LD_INT 0
49903: PUSH
49904: LD_INT 4
49906: NEG
49907: PUSH
49908: EMPTY
49909: LIST
49910: LIST
49911: PUSH
49912: LD_INT 1
49914: PUSH
49915: LD_INT 3
49917: NEG
49918: PUSH
49919: EMPTY
49920: LIST
49921: LIST
49922: PUSH
49923: LD_INT 1
49925: PUSH
49926: LD_INT 2
49928: NEG
49929: PUSH
49930: EMPTY
49931: LIST
49932: LIST
49933: PUSH
49934: LD_INT 0
49936: PUSH
49937: LD_INT 2
49939: NEG
49940: PUSH
49941: EMPTY
49942: LIST
49943: LIST
49944: PUSH
49945: LD_INT 1
49947: NEG
49948: PUSH
49949: LD_INT 3
49951: NEG
49952: PUSH
49953: EMPTY
49954: LIST
49955: LIST
49956: PUSH
49957: LD_INT 1
49959: NEG
49960: PUSH
49961: LD_INT 4
49963: NEG
49964: PUSH
49965: EMPTY
49966: LIST
49967: LIST
49968: PUSH
49969: LD_INT 2
49971: PUSH
49972: LD_INT 2
49974: NEG
49975: PUSH
49976: EMPTY
49977: LIST
49978: LIST
49979: PUSH
49980: LD_INT 2
49982: NEG
49983: PUSH
49984: LD_INT 4
49986: NEG
49987: PUSH
49988: EMPTY
49989: LIST
49990: LIST
49991: PUSH
49992: LD_INT 4
49994: PUSH
49995: LD_INT 0
49997: PUSH
49998: EMPTY
49999: LIST
50000: LIST
50001: PUSH
50002: LD_INT 4
50004: PUSH
50005: LD_INT 1
50007: NEG
50008: PUSH
50009: EMPTY
50010: LIST
50011: LIST
50012: PUSH
50013: LD_INT 5
50015: PUSH
50016: LD_INT 0
50018: PUSH
50019: EMPTY
50020: LIST
50021: LIST
50022: PUSH
50023: LD_INT 5
50025: PUSH
50026: LD_INT 1
50028: PUSH
50029: EMPTY
50030: LIST
50031: LIST
50032: PUSH
50033: LD_INT 4
50035: PUSH
50036: LD_INT 1
50038: PUSH
50039: EMPTY
50040: LIST
50041: LIST
50042: PUSH
50043: LD_INT 3
50045: PUSH
50046: LD_INT 0
50048: PUSH
50049: EMPTY
50050: LIST
50051: LIST
50052: PUSH
50053: LD_INT 3
50055: PUSH
50056: LD_INT 1
50058: NEG
50059: PUSH
50060: EMPTY
50061: LIST
50062: LIST
50063: PUSH
50064: LD_INT 3
50066: PUSH
50067: LD_INT 2
50069: NEG
50070: PUSH
50071: EMPTY
50072: LIST
50073: LIST
50074: PUSH
50075: LD_INT 5
50077: PUSH
50078: LD_INT 2
50080: PUSH
50081: EMPTY
50082: LIST
50083: LIST
50084: PUSH
50085: LD_INT 3
50087: PUSH
50088: LD_INT 3
50090: PUSH
50091: EMPTY
50092: LIST
50093: LIST
50094: PUSH
50095: LD_INT 3
50097: PUSH
50098: LD_INT 2
50100: PUSH
50101: EMPTY
50102: LIST
50103: LIST
50104: PUSH
50105: LD_INT 4
50107: PUSH
50108: LD_INT 3
50110: PUSH
50111: EMPTY
50112: LIST
50113: LIST
50114: PUSH
50115: LD_INT 4
50117: PUSH
50118: LD_INT 4
50120: PUSH
50121: EMPTY
50122: LIST
50123: LIST
50124: PUSH
50125: LD_INT 3
50127: PUSH
50128: LD_INT 4
50130: PUSH
50131: EMPTY
50132: LIST
50133: LIST
50134: PUSH
50135: LD_INT 2
50137: PUSH
50138: LD_INT 3
50140: PUSH
50141: EMPTY
50142: LIST
50143: LIST
50144: PUSH
50145: LD_INT 2
50147: PUSH
50148: LD_INT 2
50150: PUSH
50151: EMPTY
50152: LIST
50153: LIST
50154: PUSH
50155: LD_INT 4
50157: PUSH
50158: LD_INT 2
50160: PUSH
50161: EMPTY
50162: LIST
50163: LIST
50164: PUSH
50165: LD_INT 2
50167: PUSH
50168: LD_INT 4
50170: PUSH
50171: EMPTY
50172: LIST
50173: LIST
50174: PUSH
50175: LD_INT 0
50177: PUSH
50178: LD_INT 4
50180: PUSH
50181: EMPTY
50182: LIST
50183: LIST
50184: PUSH
50185: LD_INT 0
50187: PUSH
50188: LD_INT 3
50190: PUSH
50191: EMPTY
50192: LIST
50193: LIST
50194: PUSH
50195: LD_INT 1
50197: PUSH
50198: LD_INT 4
50200: PUSH
50201: EMPTY
50202: LIST
50203: LIST
50204: PUSH
50205: LD_INT 1
50207: PUSH
50208: LD_INT 5
50210: PUSH
50211: EMPTY
50212: LIST
50213: LIST
50214: PUSH
50215: LD_INT 0
50217: PUSH
50218: LD_INT 5
50220: PUSH
50221: EMPTY
50222: LIST
50223: LIST
50224: PUSH
50225: LD_INT 1
50227: NEG
50228: PUSH
50229: LD_INT 4
50231: PUSH
50232: EMPTY
50233: LIST
50234: LIST
50235: PUSH
50236: LD_INT 1
50238: NEG
50239: PUSH
50240: LD_INT 3
50242: PUSH
50243: EMPTY
50244: LIST
50245: LIST
50246: PUSH
50247: LD_INT 2
50249: PUSH
50250: LD_INT 5
50252: PUSH
50253: EMPTY
50254: LIST
50255: LIST
50256: PUSH
50257: LD_INT 2
50259: NEG
50260: PUSH
50261: LD_INT 3
50263: PUSH
50264: EMPTY
50265: LIST
50266: LIST
50267: PUSH
50268: EMPTY
50269: LIST
50270: LIST
50271: LIST
50272: LIST
50273: LIST
50274: LIST
50275: LIST
50276: LIST
50277: LIST
50278: LIST
50279: LIST
50280: LIST
50281: LIST
50282: LIST
50283: LIST
50284: LIST
50285: LIST
50286: LIST
50287: LIST
50288: LIST
50289: LIST
50290: LIST
50291: LIST
50292: LIST
50293: LIST
50294: LIST
50295: LIST
50296: LIST
50297: LIST
50298: LIST
50299: LIST
50300: LIST
50301: LIST
50302: LIST
50303: LIST
50304: LIST
50305: LIST
50306: LIST
50307: LIST
50308: LIST
50309: LIST
50310: LIST
50311: LIST
50312: LIST
50313: LIST
50314: ST_TO_ADDR
// fFactory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
50315: LD_ADDR_VAR 0 34
50319: PUSH
50320: LD_INT 0
50322: PUSH
50323: LD_INT 4
50325: NEG
50326: PUSH
50327: EMPTY
50328: LIST
50329: LIST
50330: PUSH
50331: LD_INT 0
50333: PUSH
50334: LD_INT 5
50336: NEG
50337: PUSH
50338: EMPTY
50339: LIST
50340: LIST
50341: PUSH
50342: LD_INT 1
50344: PUSH
50345: LD_INT 4
50347: NEG
50348: PUSH
50349: EMPTY
50350: LIST
50351: LIST
50352: PUSH
50353: LD_INT 1
50355: PUSH
50356: LD_INT 3
50358: NEG
50359: PUSH
50360: EMPTY
50361: LIST
50362: LIST
50363: PUSH
50364: LD_INT 0
50366: PUSH
50367: LD_INT 3
50369: NEG
50370: PUSH
50371: EMPTY
50372: LIST
50373: LIST
50374: PUSH
50375: LD_INT 1
50377: NEG
50378: PUSH
50379: LD_INT 4
50381: NEG
50382: PUSH
50383: EMPTY
50384: LIST
50385: LIST
50386: PUSH
50387: LD_INT 1
50389: NEG
50390: PUSH
50391: LD_INT 5
50393: NEG
50394: PUSH
50395: EMPTY
50396: LIST
50397: LIST
50398: PUSH
50399: LD_INT 2
50401: PUSH
50402: LD_INT 3
50404: NEG
50405: PUSH
50406: EMPTY
50407: LIST
50408: LIST
50409: PUSH
50410: LD_INT 2
50412: NEG
50413: PUSH
50414: LD_INT 5
50416: NEG
50417: PUSH
50418: EMPTY
50419: LIST
50420: LIST
50421: PUSH
50422: LD_INT 3
50424: PUSH
50425: LD_INT 0
50427: PUSH
50428: EMPTY
50429: LIST
50430: LIST
50431: PUSH
50432: LD_INT 3
50434: PUSH
50435: LD_INT 1
50437: NEG
50438: PUSH
50439: EMPTY
50440: LIST
50441: LIST
50442: PUSH
50443: LD_INT 4
50445: PUSH
50446: LD_INT 0
50448: PUSH
50449: EMPTY
50450: LIST
50451: LIST
50452: PUSH
50453: LD_INT 4
50455: PUSH
50456: LD_INT 1
50458: PUSH
50459: EMPTY
50460: LIST
50461: LIST
50462: PUSH
50463: LD_INT 3
50465: PUSH
50466: LD_INT 1
50468: PUSH
50469: EMPTY
50470: LIST
50471: LIST
50472: PUSH
50473: LD_INT 2
50475: PUSH
50476: LD_INT 0
50478: PUSH
50479: EMPTY
50480: LIST
50481: LIST
50482: PUSH
50483: LD_INT 2
50485: PUSH
50486: LD_INT 1
50488: NEG
50489: PUSH
50490: EMPTY
50491: LIST
50492: LIST
50493: PUSH
50494: LD_INT 2
50496: PUSH
50497: LD_INT 2
50499: NEG
50500: PUSH
50501: EMPTY
50502: LIST
50503: LIST
50504: PUSH
50505: LD_INT 4
50507: PUSH
50508: LD_INT 2
50510: PUSH
50511: EMPTY
50512: LIST
50513: LIST
50514: PUSH
50515: LD_INT 4
50517: PUSH
50518: LD_INT 4
50520: PUSH
50521: EMPTY
50522: LIST
50523: LIST
50524: PUSH
50525: LD_INT 4
50527: PUSH
50528: LD_INT 3
50530: PUSH
50531: EMPTY
50532: LIST
50533: LIST
50534: PUSH
50535: LD_INT 5
50537: PUSH
50538: LD_INT 4
50540: PUSH
50541: EMPTY
50542: LIST
50543: LIST
50544: PUSH
50545: LD_INT 5
50547: PUSH
50548: LD_INT 5
50550: PUSH
50551: EMPTY
50552: LIST
50553: LIST
50554: PUSH
50555: LD_INT 4
50557: PUSH
50558: LD_INT 5
50560: PUSH
50561: EMPTY
50562: LIST
50563: LIST
50564: PUSH
50565: LD_INT 3
50567: PUSH
50568: LD_INT 4
50570: PUSH
50571: EMPTY
50572: LIST
50573: LIST
50574: PUSH
50575: LD_INT 3
50577: PUSH
50578: LD_INT 3
50580: PUSH
50581: EMPTY
50582: LIST
50583: LIST
50584: PUSH
50585: LD_INT 5
50587: PUSH
50588: LD_INT 3
50590: PUSH
50591: EMPTY
50592: LIST
50593: LIST
50594: PUSH
50595: LD_INT 3
50597: PUSH
50598: LD_INT 5
50600: PUSH
50601: EMPTY
50602: LIST
50603: LIST
50604: PUSH
50605: LD_INT 0
50607: PUSH
50608: LD_INT 3
50610: PUSH
50611: EMPTY
50612: LIST
50613: LIST
50614: PUSH
50615: LD_INT 0
50617: PUSH
50618: LD_INT 2
50620: PUSH
50621: EMPTY
50622: LIST
50623: LIST
50624: PUSH
50625: LD_INT 1
50627: PUSH
50628: LD_INT 3
50630: PUSH
50631: EMPTY
50632: LIST
50633: LIST
50634: PUSH
50635: LD_INT 1
50637: PUSH
50638: LD_INT 4
50640: PUSH
50641: EMPTY
50642: LIST
50643: LIST
50644: PUSH
50645: LD_INT 0
50647: PUSH
50648: LD_INT 4
50650: PUSH
50651: EMPTY
50652: LIST
50653: LIST
50654: PUSH
50655: LD_INT 1
50657: NEG
50658: PUSH
50659: LD_INT 3
50661: PUSH
50662: EMPTY
50663: LIST
50664: LIST
50665: PUSH
50666: LD_INT 1
50668: NEG
50669: PUSH
50670: LD_INT 2
50672: PUSH
50673: EMPTY
50674: LIST
50675: LIST
50676: PUSH
50677: LD_INT 2
50679: PUSH
50680: LD_INT 4
50682: PUSH
50683: EMPTY
50684: LIST
50685: LIST
50686: PUSH
50687: LD_INT 2
50689: NEG
50690: PUSH
50691: LD_INT 2
50693: PUSH
50694: EMPTY
50695: LIST
50696: LIST
50697: PUSH
50698: LD_INT 4
50700: NEG
50701: PUSH
50702: LD_INT 0
50704: PUSH
50705: EMPTY
50706: LIST
50707: LIST
50708: PUSH
50709: LD_INT 4
50711: NEG
50712: PUSH
50713: LD_INT 1
50715: NEG
50716: PUSH
50717: EMPTY
50718: LIST
50719: LIST
50720: PUSH
50721: LD_INT 3
50723: NEG
50724: PUSH
50725: LD_INT 0
50727: PUSH
50728: EMPTY
50729: LIST
50730: LIST
50731: PUSH
50732: LD_INT 3
50734: NEG
50735: PUSH
50736: LD_INT 1
50738: PUSH
50739: EMPTY
50740: LIST
50741: LIST
50742: PUSH
50743: LD_INT 4
50745: NEG
50746: PUSH
50747: LD_INT 1
50749: PUSH
50750: EMPTY
50751: LIST
50752: LIST
50753: PUSH
50754: LD_INT 5
50756: NEG
50757: PUSH
50758: LD_INT 0
50760: PUSH
50761: EMPTY
50762: LIST
50763: LIST
50764: PUSH
50765: LD_INT 5
50767: NEG
50768: PUSH
50769: LD_INT 1
50771: NEG
50772: PUSH
50773: EMPTY
50774: LIST
50775: LIST
50776: PUSH
50777: LD_INT 5
50779: NEG
50780: PUSH
50781: LD_INT 2
50783: NEG
50784: PUSH
50785: EMPTY
50786: LIST
50787: LIST
50788: PUSH
50789: LD_INT 3
50791: NEG
50792: PUSH
50793: LD_INT 2
50795: PUSH
50796: EMPTY
50797: LIST
50798: LIST
50799: PUSH
50800: EMPTY
50801: LIST
50802: LIST
50803: LIST
50804: LIST
50805: LIST
50806: LIST
50807: LIST
50808: LIST
50809: LIST
50810: LIST
50811: LIST
50812: LIST
50813: LIST
50814: LIST
50815: LIST
50816: LIST
50817: LIST
50818: LIST
50819: LIST
50820: LIST
50821: LIST
50822: LIST
50823: LIST
50824: LIST
50825: LIST
50826: LIST
50827: LIST
50828: LIST
50829: LIST
50830: LIST
50831: LIST
50832: LIST
50833: LIST
50834: LIST
50835: LIST
50836: LIST
50837: LIST
50838: LIST
50839: LIST
50840: LIST
50841: LIST
50842: LIST
50843: LIST
50844: LIST
50845: LIST
50846: ST_TO_ADDR
// end ; end ;
50847: GO 50850
50849: POP
// case btype of b_depot , b_warehouse :
50850: LD_VAR 0 1
50854: PUSH
50855: LD_INT 0
50857: DOUBLE
50858: EQUAL
50859: IFTRUE 50869
50861: LD_INT 1
50863: DOUBLE
50864: EQUAL
50865: IFTRUE 50869
50867: GO 51070
50869: POP
// case nation of nation_american :
50870: LD_VAR 0 5
50874: PUSH
50875: LD_INT 1
50877: DOUBLE
50878: EQUAL
50879: IFTRUE 50883
50881: GO 50939
50883: POP
// temp_list = [ fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 ] [ dir + 1 ] ; nation_arabian :
50884: LD_ADDR_VAR 0 9
50888: PUSH
50889: LD_VAR 0 11
50893: PUSH
50894: LD_VAR 0 12
50898: PUSH
50899: LD_VAR 0 13
50903: PUSH
50904: LD_VAR 0 14
50908: PUSH
50909: LD_VAR 0 15
50913: PUSH
50914: LD_VAR 0 16
50918: PUSH
50919: EMPTY
50920: LIST
50921: LIST
50922: LIST
50923: LIST
50924: LIST
50925: LIST
50926: PUSH
50927: LD_VAR 0 4
50931: PUSH
50932: LD_INT 1
50934: PLUS
50935: ARRAY
50936: ST_TO_ADDR
50937: GO 51068
50939: LD_INT 2
50941: DOUBLE
50942: EQUAL
50943: IFTRUE 50947
50945: GO 51003
50947: POP
// temp_list = [ fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 ] [ dir + 1 ] ; nation_russian :
50948: LD_ADDR_VAR 0 9
50952: PUSH
50953: LD_VAR 0 17
50957: PUSH
50958: LD_VAR 0 18
50962: PUSH
50963: LD_VAR 0 19
50967: PUSH
50968: LD_VAR 0 20
50972: PUSH
50973: LD_VAR 0 21
50977: PUSH
50978: LD_VAR 0 22
50982: PUSH
50983: EMPTY
50984: LIST
50985: LIST
50986: LIST
50987: LIST
50988: LIST
50989: LIST
50990: PUSH
50991: LD_VAR 0 4
50995: PUSH
50996: LD_INT 1
50998: PLUS
50999: ARRAY
51000: ST_TO_ADDR
51001: GO 51068
51003: LD_INT 3
51005: DOUBLE
51006: EQUAL
51007: IFTRUE 51011
51009: GO 51067
51011: POP
// temp_list = [ fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
51012: LD_ADDR_VAR 0 9
51016: PUSH
51017: LD_VAR 0 23
51021: PUSH
51022: LD_VAR 0 24
51026: PUSH
51027: LD_VAR 0 25
51031: PUSH
51032: LD_VAR 0 26
51036: PUSH
51037: LD_VAR 0 27
51041: PUSH
51042: LD_VAR 0 28
51046: PUSH
51047: EMPTY
51048: LIST
51049: LIST
51050: LIST
51051: LIST
51052: LIST
51053: LIST
51054: PUSH
51055: LD_VAR 0 4
51059: PUSH
51060: LD_INT 1
51062: PLUS
51063: ARRAY
51064: ST_TO_ADDR
51065: GO 51068
51067: POP
51068: GO 51623
51070: LD_INT 2
51072: DOUBLE
51073: EQUAL
51074: IFTRUE 51084
51076: LD_INT 3
51078: DOUBLE
51079: EQUAL
51080: IFTRUE 51084
51082: GO 51140
51084: POP
// temp_list = [ fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
51085: LD_ADDR_VAR 0 9
51089: PUSH
51090: LD_VAR 0 29
51094: PUSH
51095: LD_VAR 0 30
51099: PUSH
51100: LD_VAR 0 31
51104: PUSH
51105: LD_VAR 0 32
51109: PUSH
51110: LD_VAR 0 33
51114: PUSH
51115: LD_VAR 0 34
51119: PUSH
51120: EMPTY
51121: LIST
51122: LIST
51123: LIST
51124: LIST
51125: LIST
51126: LIST
51127: PUSH
51128: LD_VAR 0 4
51132: PUSH
51133: LD_INT 1
51135: PLUS
51136: ARRAY
51137: ST_TO_ADDR
51138: GO 51623
51140: LD_INT 16
51142: DOUBLE
51143: EQUAL
51144: IFTRUE 51202
51146: LD_INT 17
51148: DOUBLE
51149: EQUAL
51150: IFTRUE 51202
51152: LD_INT 18
51154: DOUBLE
51155: EQUAL
51156: IFTRUE 51202
51158: LD_INT 19
51160: DOUBLE
51161: EQUAL
51162: IFTRUE 51202
51164: LD_INT 22
51166: DOUBLE
51167: EQUAL
51168: IFTRUE 51202
51170: LD_INT 20
51172: DOUBLE
51173: EQUAL
51174: IFTRUE 51202
51176: LD_INT 21
51178: DOUBLE
51179: EQUAL
51180: IFTRUE 51202
51182: LD_INT 23
51184: DOUBLE
51185: EQUAL
51186: IFTRUE 51202
51188: LD_INT 24
51190: DOUBLE
51191: EQUAL
51192: IFTRUE 51202
51194: LD_INT 25
51196: DOUBLE
51197: EQUAL
51198: IFTRUE 51202
51200: GO 51258
51202: POP
// temp_list = [ fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
51203: LD_ADDR_VAR 0 9
51207: PUSH
51208: LD_VAR 0 35
51212: PUSH
51213: LD_VAR 0 36
51217: PUSH
51218: LD_VAR 0 37
51222: PUSH
51223: LD_VAR 0 38
51227: PUSH
51228: LD_VAR 0 39
51232: PUSH
51233: LD_VAR 0 40
51237: PUSH
51238: EMPTY
51239: LIST
51240: LIST
51241: LIST
51242: LIST
51243: LIST
51244: LIST
51245: PUSH
51246: LD_VAR 0 4
51250: PUSH
51251: LD_INT 1
51253: PLUS
51254: ARRAY
51255: ST_TO_ADDR
51256: GO 51623
51258: LD_INT 6
51260: DOUBLE
51261: EQUAL
51262: IFTRUE 51314
51264: LD_INT 7
51266: DOUBLE
51267: EQUAL
51268: IFTRUE 51314
51270: LD_INT 8
51272: DOUBLE
51273: EQUAL
51274: IFTRUE 51314
51276: LD_INT 13
51278: DOUBLE
51279: EQUAL
51280: IFTRUE 51314
51282: LD_INT 12
51284: DOUBLE
51285: EQUAL
51286: IFTRUE 51314
51288: LD_INT 15
51290: DOUBLE
51291: EQUAL
51292: IFTRUE 51314
51294: LD_INT 11
51296: DOUBLE
51297: EQUAL
51298: IFTRUE 51314
51300: LD_INT 14
51302: DOUBLE
51303: EQUAL
51304: IFTRUE 51314
51306: LD_INT 10
51308: DOUBLE
51309: EQUAL
51310: IFTRUE 51314
51312: GO 51370
51314: POP
// temp_list = [ fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 ] [ dir + 1 ] ; b_control_tower :
51315: LD_ADDR_VAR 0 9
51319: PUSH
51320: LD_VAR 0 41
51324: PUSH
51325: LD_VAR 0 42
51329: PUSH
51330: LD_VAR 0 43
51334: PUSH
51335: LD_VAR 0 44
51339: PUSH
51340: LD_VAR 0 45
51344: PUSH
51345: LD_VAR 0 46
51349: PUSH
51350: EMPTY
51351: LIST
51352: LIST
51353: LIST
51354: LIST
51355: LIST
51356: LIST
51357: PUSH
51358: LD_VAR 0 4
51362: PUSH
51363: LD_INT 1
51365: PLUS
51366: ARRAY
51367: ST_TO_ADDR
51368: GO 51623
51370: LD_INT 36
51372: DOUBLE
51373: EQUAL
51374: IFTRUE 51378
51376: GO 51434
51378: POP
// temp_list = [ fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
51379: LD_ADDR_VAR 0 9
51383: PUSH
51384: LD_VAR 0 47
51388: PUSH
51389: LD_VAR 0 48
51393: PUSH
51394: LD_VAR 0 49
51398: PUSH
51399: LD_VAR 0 50
51403: PUSH
51404: LD_VAR 0 51
51408: PUSH
51409: LD_VAR 0 52
51413: PUSH
51414: EMPTY
51415: LIST
51416: LIST
51417: LIST
51418: LIST
51419: LIST
51420: LIST
51421: PUSH
51422: LD_VAR 0 4
51426: PUSH
51427: LD_INT 1
51429: PLUS
51430: ARRAY
51431: ST_TO_ADDR
51432: GO 51623
51434: LD_INT 4
51436: DOUBLE
51437: EQUAL
51438: IFTRUE 51460
51440: LD_INT 5
51442: DOUBLE
51443: EQUAL
51444: IFTRUE 51460
51446: LD_INT 34
51448: DOUBLE
51449: EQUAL
51450: IFTRUE 51460
51452: LD_INT 37
51454: DOUBLE
51455: EQUAL
51456: IFTRUE 51460
51458: GO 51516
51460: POP
// temp_list = [ fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
51461: LD_ADDR_VAR 0 9
51465: PUSH
51466: LD_VAR 0 53
51470: PUSH
51471: LD_VAR 0 54
51475: PUSH
51476: LD_VAR 0 55
51480: PUSH
51481: LD_VAR 0 56
51485: PUSH
51486: LD_VAR 0 57
51490: PUSH
51491: LD_VAR 0 58
51495: PUSH
51496: EMPTY
51497: LIST
51498: LIST
51499: LIST
51500: LIST
51501: LIST
51502: LIST
51503: PUSH
51504: LD_VAR 0 4
51508: PUSH
51509: LD_INT 1
51511: PLUS
51512: ARRAY
51513: ST_TO_ADDR
51514: GO 51623
51516: LD_INT 31
51518: DOUBLE
51519: EQUAL
51520: IFTRUE 51566
51522: LD_INT 32
51524: DOUBLE
51525: EQUAL
51526: IFTRUE 51566
51528: LD_INT 33
51530: DOUBLE
51531: EQUAL
51532: IFTRUE 51566
51534: LD_INT 27
51536: DOUBLE
51537: EQUAL
51538: IFTRUE 51566
51540: LD_INT 26
51542: DOUBLE
51543: EQUAL
51544: IFTRUE 51566
51546: LD_INT 28
51548: DOUBLE
51549: EQUAL
51550: IFTRUE 51566
51552: LD_INT 29
51554: DOUBLE
51555: EQUAL
51556: IFTRUE 51566
51558: LD_INT 30
51560: DOUBLE
51561: EQUAL
51562: IFTRUE 51566
51564: GO 51622
51566: POP
// temp_list = [ fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ] [ dir + 1 ] ; end ;
51567: LD_ADDR_VAR 0 9
51571: PUSH
51572: LD_VAR 0 59
51576: PUSH
51577: LD_VAR 0 60
51581: PUSH
51582: LD_VAR 0 61
51586: PUSH
51587: LD_VAR 0 62
51591: PUSH
51592: LD_VAR 0 63
51596: PUSH
51597: LD_VAR 0 64
51601: PUSH
51602: EMPTY
51603: LIST
51604: LIST
51605: LIST
51606: LIST
51607: LIST
51608: LIST
51609: PUSH
51610: LD_VAR 0 4
51614: PUSH
51615: LD_INT 1
51617: PLUS
51618: ARRAY
51619: ST_TO_ADDR
51620: GO 51623
51622: POP
// temp_list2 = [ ] ;
51623: LD_ADDR_VAR 0 10
51627: PUSH
51628: EMPTY
51629: ST_TO_ADDR
// for i in temp_list do
51630: LD_ADDR_VAR 0 8
51634: PUSH
51635: LD_VAR 0 9
51639: PUSH
51640: FOR_IN
51641: IFFALSE 51693
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
51643: LD_ADDR_VAR 0 10
51647: PUSH
51648: LD_VAR 0 10
51652: PUSH
51653: LD_VAR 0 8
51657: PUSH
51658: LD_INT 1
51660: ARRAY
51661: PUSH
51662: LD_VAR 0 2
51666: PLUS
51667: PUSH
51668: LD_VAR 0 8
51672: PUSH
51673: LD_INT 2
51675: ARRAY
51676: PUSH
51677: LD_VAR 0 3
51681: PLUS
51682: PUSH
51683: EMPTY
51684: LIST
51685: LIST
51686: PUSH
51687: EMPTY
51688: LIST
51689: ADD
51690: ST_TO_ADDR
51691: GO 51640
51693: POP
51694: POP
// result = temp_list2 ;
51695: LD_ADDR_VAR 0 7
51699: PUSH
51700: LD_VAR 0 10
51704: ST_TO_ADDR
// end ;
51705: LD_VAR 0 7
51709: RET
// export function EnemyInRange ( unit , dist ) ; begin
51710: LD_INT 0
51712: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
51713: LD_ADDR_VAR 0 3
51717: PUSH
51718: LD_VAR 0 1
51722: PPUSH
51723: CALL_OW 255
51727: PPUSH
51728: LD_VAR 0 1
51732: PPUSH
51733: CALL_OW 250
51737: PPUSH
51738: LD_VAR 0 1
51742: PPUSH
51743: CALL_OW 251
51747: PPUSH
51748: LD_VAR 0 2
51752: PPUSH
51753: CALL 25106 0 4
51757: PUSH
51758: LD_INT 4
51760: ARRAY
51761: ST_TO_ADDR
// end ;
51762: LD_VAR 0 3
51766: RET
// export function PlayerSeeMe ( unit ) ; begin
51767: LD_INT 0
51769: PPUSH
// result := See ( your_side , unit ) ;
51770: LD_ADDR_VAR 0 2
51774: PUSH
51775: LD_OWVAR 2
51779: PPUSH
51780: LD_VAR 0 1
51784: PPUSH
51785: CALL_OW 292
51789: ST_TO_ADDR
// end ;
51790: LD_VAR 0 2
51794: RET
// export function ReverseDir ( unit ) ; begin
51795: LD_INT 0
51797: PPUSH
// if not unit then
51798: LD_VAR 0 1
51802: NOT
51803: IFFALSE 51807
// exit ;
51805: GO 51830
// result := ( GetDir ( unit ) + 3 ) mod 6 ;
51807: LD_ADDR_VAR 0 2
51811: PUSH
51812: LD_VAR 0 1
51816: PPUSH
51817: CALL_OW 254
51821: PUSH
51822: LD_INT 3
51824: PLUS
51825: PUSH
51826: LD_INT 6
51828: MOD
51829: ST_TO_ADDR
// end ;
51830: LD_VAR 0 2
51834: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tmp , hex ; begin
51835: LD_INT 0
51837: PPUSH
51838: PPUSH
51839: PPUSH
51840: PPUSH
51841: PPUSH
// if not hexes then
51842: LD_VAR 0 2
51846: NOT
51847: IFFALSE 51851
// exit ;
51849: GO 51999
// dist := 9999 ;
51851: LD_ADDR_VAR 0 5
51855: PUSH
51856: LD_INT 9999
51858: ST_TO_ADDR
// for i = 1 to hexes do
51859: LD_ADDR_VAR 0 4
51863: PUSH
51864: DOUBLE
51865: LD_INT 1
51867: DEC
51868: ST_TO_ADDR
51869: LD_VAR 0 2
51873: PUSH
51874: FOR_TO
51875: IFFALSE 51987
// begin if GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) < dist then
51877: LD_VAR 0 1
51881: PPUSH
51882: LD_VAR 0 2
51886: PUSH
51887: LD_VAR 0 4
51891: ARRAY
51892: PUSH
51893: LD_INT 1
51895: ARRAY
51896: PPUSH
51897: LD_VAR 0 2
51901: PUSH
51902: LD_VAR 0 4
51906: ARRAY
51907: PUSH
51908: LD_INT 2
51910: ARRAY
51911: PPUSH
51912: CALL_OW 297
51916: PUSH
51917: LD_VAR 0 5
51921: LESS
51922: IFFALSE 51985
// begin hex := hexes [ i ] ;
51924: LD_ADDR_VAR 0 7
51928: PUSH
51929: LD_VAR 0 2
51933: PUSH
51934: LD_VAR 0 4
51938: ARRAY
51939: ST_TO_ADDR
// dist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
51940: LD_ADDR_VAR 0 5
51944: PUSH
51945: LD_VAR 0 1
51949: PPUSH
51950: LD_VAR 0 2
51954: PUSH
51955: LD_VAR 0 4
51959: ARRAY
51960: PUSH
51961: LD_INT 1
51963: ARRAY
51964: PPUSH
51965: LD_VAR 0 2
51969: PUSH
51970: LD_VAR 0 4
51974: ARRAY
51975: PUSH
51976: LD_INT 2
51978: ARRAY
51979: PPUSH
51980: CALL_OW 297
51984: ST_TO_ADDR
// end ; end ;
51985: GO 51874
51987: POP
51988: POP
// result := hex ;
51989: LD_ADDR_VAR 0 3
51993: PUSH
51994: LD_VAR 0 7
51998: ST_TO_ADDR
// end ;
51999: LD_VAR 0 3
52003: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
52004: LD_INT 0
52006: PPUSH
52007: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
52008: LD_VAR 0 1
52012: NOT
52013: PUSH
52014: LD_VAR 0 1
52018: PUSH
52019: LD_INT 21
52021: PUSH
52022: LD_INT 2
52024: PUSH
52025: EMPTY
52026: LIST
52027: LIST
52028: PUSH
52029: LD_INT 23
52031: PUSH
52032: LD_INT 2
52034: PUSH
52035: EMPTY
52036: LIST
52037: LIST
52038: PUSH
52039: EMPTY
52040: LIST
52041: LIST
52042: PPUSH
52043: CALL_OW 69
52047: IN
52048: NOT
52049: OR
52050: IFFALSE 52054
// exit ;
52052: GO 52101
// for i = 1 to 3 do
52054: LD_ADDR_VAR 0 3
52058: PUSH
52059: DOUBLE
52060: LD_INT 1
52062: DEC
52063: ST_TO_ADDR
52064: LD_INT 3
52066: PUSH
52067: FOR_TO
52068: IFFALSE 52099
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
52070: LD_VAR 0 1
52074: PPUSH
52075: CALL_OW 250
52079: PPUSH
52080: LD_VAR 0 1
52084: PPUSH
52085: CALL_OW 251
52089: PPUSH
52090: LD_INT 1
52092: PPUSH
52093: CALL_OW 453
52097: GO 52067
52099: POP
52100: POP
// end ;
52101: LD_VAR 0 2
52105: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
52106: LD_INT 0
52108: PPUSH
52109: PPUSH
52110: PPUSH
52111: PPUSH
52112: PPUSH
52113: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
52114: LD_VAR 0 1
52118: NOT
52119: PUSH
52120: LD_VAR 0 2
52124: NOT
52125: OR
52126: PUSH
52127: LD_VAR 0 1
52131: PPUSH
52132: CALL_OW 314
52136: OR
52137: IFFALSE 52141
// exit ;
52139: GO 52582
// x := GetX ( enemy_unit ) ;
52141: LD_ADDR_VAR 0 7
52145: PUSH
52146: LD_VAR 0 2
52150: PPUSH
52151: CALL_OW 250
52155: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
52156: LD_ADDR_VAR 0 8
52160: PUSH
52161: LD_VAR 0 2
52165: PPUSH
52166: CALL_OW 251
52170: ST_TO_ADDR
// if not x or not y then
52171: LD_VAR 0 7
52175: NOT
52176: PUSH
52177: LD_VAR 0 8
52181: NOT
52182: OR
52183: IFFALSE 52187
// exit ;
52185: GO 52582
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
52187: LD_ADDR_VAR 0 6
52191: PUSH
52192: LD_VAR 0 7
52196: PPUSH
52197: LD_INT 0
52199: PPUSH
52200: LD_INT 4
52202: PPUSH
52203: CALL_OW 272
52207: PUSH
52208: LD_VAR 0 8
52212: PPUSH
52213: LD_INT 0
52215: PPUSH
52216: LD_INT 4
52218: PPUSH
52219: CALL_OW 273
52223: PUSH
52224: EMPTY
52225: LIST
52226: LIST
52227: PUSH
52228: LD_VAR 0 7
52232: PPUSH
52233: LD_INT 1
52235: PPUSH
52236: LD_INT 4
52238: PPUSH
52239: CALL_OW 272
52243: PUSH
52244: LD_VAR 0 8
52248: PPUSH
52249: LD_INT 1
52251: PPUSH
52252: LD_INT 4
52254: PPUSH
52255: CALL_OW 273
52259: PUSH
52260: EMPTY
52261: LIST
52262: LIST
52263: PUSH
52264: LD_VAR 0 7
52268: PPUSH
52269: LD_INT 2
52271: PPUSH
52272: LD_INT 4
52274: PPUSH
52275: CALL_OW 272
52279: PUSH
52280: LD_VAR 0 8
52284: PPUSH
52285: LD_INT 2
52287: PPUSH
52288: LD_INT 4
52290: PPUSH
52291: CALL_OW 273
52295: PUSH
52296: EMPTY
52297: LIST
52298: LIST
52299: PUSH
52300: LD_VAR 0 7
52304: PPUSH
52305: LD_INT 3
52307: PPUSH
52308: LD_INT 4
52310: PPUSH
52311: CALL_OW 272
52315: PUSH
52316: LD_VAR 0 8
52320: PPUSH
52321: LD_INT 3
52323: PPUSH
52324: LD_INT 4
52326: PPUSH
52327: CALL_OW 273
52331: PUSH
52332: EMPTY
52333: LIST
52334: LIST
52335: PUSH
52336: LD_VAR 0 7
52340: PPUSH
52341: LD_INT 4
52343: PPUSH
52344: LD_INT 4
52346: PPUSH
52347: CALL_OW 272
52351: PUSH
52352: LD_VAR 0 8
52356: PPUSH
52357: LD_INT 4
52359: PPUSH
52360: LD_INT 4
52362: PPUSH
52363: CALL_OW 273
52367: PUSH
52368: EMPTY
52369: LIST
52370: LIST
52371: PUSH
52372: LD_VAR 0 7
52376: PPUSH
52377: LD_INT 5
52379: PPUSH
52380: LD_INT 4
52382: PPUSH
52383: CALL_OW 272
52387: PUSH
52388: LD_VAR 0 8
52392: PPUSH
52393: LD_INT 5
52395: PPUSH
52396: LD_INT 4
52398: PPUSH
52399: CALL_OW 273
52403: PUSH
52404: EMPTY
52405: LIST
52406: LIST
52407: PUSH
52408: EMPTY
52409: LIST
52410: LIST
52411: LIST
52412: LIST
52413: LIST
52414: LIST
52415: ST_TO_ADDR
// for i = tmp downto 1 do
52416: LD_ADDR_VAR 0 4
52420: PUSH
52421: DOUBLE
52422: LD_VAR 0 6
52426: INC
52427: ST_TO_ADDR
52428: LD_INT 1
52430: PUSH
52431: FOR_DOWNTO
52432: IFFALSE 52533
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
52434: LD_VAR 0 6
52438: PUSH
52439: LD_VAR 0 4
52443: ARRAY
52444: PUSH
52445: LD_INT 1
52447: ARRAY
52448: PPUSH
52449: LD_VAR 0 6
52453: PUSH
52454: LD_VAR 0 4
52458: ARRAY
52459: PUSH
52460: LD_INT 2
52462: ARRAY
52463: PPUSH
52464: CALL_OW 488
52468: NOT
52469: PUSH
52470: LD_VAR 0 6
52474: PUSH
52475: LD_VAR 0 4
52479: ARRAY
52480: PUSH
52481: LD_INT 1
52483: ARRAY
52484: PPUSH
52485: LD_VAR 0 6
52489: PUSH
52490: LD_VAR 0 4
52494: ARRAY
52495: PUSH
52496: LD_INT 2
52498: ARRAY
52499: PPUSH
52500: CALL_OW 428
52504: PUSH
52505: LD_INT 0
52507: NONEQUAL
52508: OR
52509: IFFALSE 52531
// tmp := Delete ( tmp , i ) ;
52511: LD_ADDR_VAR 0 6
52515: PUSH
52516: LD_VAR 0 6
52520: PPUSH
52521: LD_VAR 0 4
52525: PPUSH
52526: CALL_OW 3
52530: ST_TO_ADDR
52531: GO 52431
52533: POP
52534: POP
// j := GetClosestHex ( unit , tmp ) ;
52535: LD_ADDR_VAR 0 5
52539: PUSH
52540: LD_VAR 0 1
52544: PPUSH
52545: LD_VAR 0 6
52549: PPUSH
52550: CALL 51835 0 2
52554: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
52555: LD_VAR 0 1
52559: PPUSH
52560: LD_VAR 0 5
52564: PUSH
52565: LD_INT 1
52567: ARRAY
52568: PPUSH
52569: LD_VAR 0 5
52573: PUSH
52574: LD_INT 2
52576: ARRAY
52577: PPUSH
52578: CALL_OW 111
// end ;
52582: LD_VAR 0 3
52586: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
52587: LD_INT 0
52589: PPUSH
52590: PPUSH
52591: PPUSH
// uc_side = 0 ;
52592: LD_ADDR_OWVAR 20
52596: PUSH
52597: LD_INT 0
52599: ST_TO_ADDR
// uc_nation = 0 ;
52600: LD_ADDR_OWVAR 21
52604: PUSH
52605: LD_INT 0
52607: ST_TO_ADDR
// InitHc_All ( ) ;
52608: CALL_OW 584
// InitVc ;
52612: CALL_OW 20
// if mastodonts then
52616: LD_VAR 0 6
52620: IFFALSE 52687
// for i = 1 to mastodonts do
52622: LD_ADDR_VAR 0 11
52626: PUSH
52627: DOUBLE
52628: LD_INT 1
52630: DEC
52631: ST_TO_ADDR
52632: LD_VAR 0 6
52636: PUSH
52637: FOR_TO
52638: IFFALSE 52685
// begin vc_chassis := 31 ;
52640: LD_ADDR_OWVAR 37
52644: PUSH
52645: LD_INT 31
52647: ST_TO_ADDR
// vc_control := control_rider ;
52648: LD_ADDR_OWVAR 38
52652: PUSH
52653: LD_INT 4
52655: ST_TO_ADDR
// animal := CreateVehicle ;
52656: LD_ADDR_VAR 0 12
52660: PUSH
52661: CALL_OW 45
52665: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
52666: LD_VAR 0 12
52670: PPUSH
52671: LD_VAR 0 8
52675: PPUSH
52676: LD_INT 0
52678: PPUSH
52679: CALL 54875 0 3
// end ;
52683: GO 52637
52685: POP
52686: POP
// if horses then
52687: LD_VAR 0 5
52691: IFFALSE 52758
// for i = 1 to horses do
52693: LD_ADDR_VAR 0 11
52697: PUSH
52698: DOUBLE
52699: LD_INT 1
52701: DEC
52702: ST_TO_ADDR
52703: LD_VAR 0 5
52707: PUSH
52708: FOR_TO
52709: IFFALSE 52756
// begin hc_class := 21 ;
52711: LD_ADDR_OWVAR 28
52715: PUSH
52716: LD_INT 21
52718: ST_TO_ADDR
// hc_gallery :=  ;
52719: LD_ADDR_OWVAR 33
52723: PUSH
52724: LD_STRING 
52726: ST_TO_ADDR
// animal := CreateHuman ;
52727: LD_ADDR_VAR 0 12
52731: PUSH
52732: CALL_OW 44
52736: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
52737: LD_VAR 0 12
52741: PPUSH
52742: LD_VAR 0 8
52746: PPUSH
52747: LD_INT 0
52749: PPUSH
52750: CALL 54875 0 3
// end ;
52754: GO 52708
52756: POP
52757: POP
// if birds then
52758: LD_VAR 0 1
52762: IFFALSE 52829
// for i = 1 to birds do
52764: LD_ADDR_VAR 0 11
52768: PUSH
52769: DOUBLE
52770: LD_INT 1
52772: DEC
52773: ST_TO_ADDR
52774: LD_VAR 0 1
52778: PUSH
52779: FOR_TO
52780: IFFALSE 52827
// begin hc_class = 18 ;
52782: LD_ADDR_OWVAR 28
52786: PUSH
52787: LD_INT 18
52789: ST_TO_ADDR
// hc_gallery =  ;
52790: LD_ADDR_OWVAR 33
52794: PUSH
52795: LD_STRING 
52797: ST_TO_ADDR
// animal := CreateHuman ;
52798: LD_ADDR_VAR 0 12
52802: PUSH
52803: CALL_OW 44
52807: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
52808: LD_VAR 0 12
52812: PPUSH
52813: LD_VAR 0 8
52817: PPUSH
52818: LD_INT 0
52820: PPUSH
52821: CALL 54875 0 3
// end ;
52825: GO 52779
52827: POP
52828: POP
// if tigers then
52829: LD_VAR 0 2
52833: IFFALSE 52917
// for i = 1 to tigers do
52835: LD_ADDR_VAR 0 11
52839: PUSH
52840: DOUBLE
52841: LD_INT 1
52843: DEC
52844: ST_TO_ADDR
52845: LD_VAR 0 2
52849: PUSH
52850: FOR_TO
52851: IFFALSE 52915
// begin hc_class = class_tiger ;
52853: LD_ADDR_OWVAR 28
52857: PUSH
52858: LD_INT 14
52860: ST_TO_ADDR
// hc_gallery =  ;
52861: LD_ADDR_OWVAR 33
52865: PUSH
52866: LD_STRING 
52868: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
52869: LD_ADDR_OWVAR 35
52873: PUSH
52874: LD_INT 7
52876: NEG
52877: PPUSH
52878: LD_INT 7
52880: PPUSH
52881: CALL_OW 12
52885: ST_TO_ADDR
// animal := CreateHuman ;
52886: LD_ADDR_VAR 0 12
52890: PUSH
52891: CALL_OW 44
52895: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
52896: LD_VAR 0 12
52900: PPUSH
52901: LD_VAR 0 8
52905: PPUSH
52906: LD_INT 0
52908: PPUSH
52909: CALL 54875 0 3
// end ;
52913: GO 52850
52915: POP
52916: POP
// if apemans then
52917: LD_VAR 0 3
52921: IFFALSE 53044
// for i = 1 to apemans do
52923: LD_ADDR_VAR 0 11
52927: PUSH
52928: DOUBLE
52929: LD_INT 1
52931: DEC
52932: ST_TO_ADDR
52933: LD_VAR 0 3
52937: PUSH
52938: FOR_TO
52939: IFFALSE 53042
// begin hc_class = class_apeman ;
52941: LD_ADDR_OWVAR 28
52945: PUSH
52946: LD_INT 12
52948: ST_TO_ADDR
// hc_gallery =  ;
52949: LD_ADDR_OWVAR 33
52953: PUSH
52954: LD_STRING 
52956: ST_TO_ADDR
// hc_agressivity = rand ( - 2 , 2 ) ;
52957: LD_ADDR_OWVAR 35
52961: PUSH
52962: LD_INT 2
52964: NEG
52965: PPUSH
52966: LD_INT 2
52968: PPUSH
52969: CALL_OW 12
52973: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
52974: LD_ADDR_OWVAR 31
52978: PUSH
52979: LD_INT 1
52981: PPUSH
52982: LD_INT 3
52984: PPUSH
52985: CALL_OW 12
52989: PUSH
52990: LD_INT 1
52992: PPUSH
52993: LD_INT 3
52995: PPUSH
52996: CALL_OW 12
53000: PUSH
53001: LD_INT 0
53003: PUSH
53004: LD_INT 0
53006: PUSH
53007: EMPTY
53008: LIST
53009: LIST
53010: LIST
53011: LIST
53012: ST_TO_ADDR
// animal := CreateHuman ;
53013: LD_ADDR_VAR 0 12
53017: PUSH
53018: CALL_OW 44
53022: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
53023: LD_VAR 0 12
53027: PPUSH
53028: LD_VAR 0 8
53032: PPUSH
53033: LD_INT 0
53035: PPUSH
53036: CALL 54875 0 3
// end ;
53040: GO 52938
53042: POP
53043: POP
// if enchidnas then
53044: LD_VAR 0 4
53048: IFFALSE 53115
// for i = 1 to enchidnas do
53050: LD_ADDR_VAR 0 11
53054: PUSH
53055: DOUBLE
53056: LD_INT 1
53058: DEC
53059: ST_TO_ADDR
53060: LD_VAR 0 4
53064: PUSH
53065: FOR_TO
53066: IFFALSE 53113
// begin hc_class = 13 ;
53068: LD_ADDR_OWVAR 28
53072: PUSH
53073: LD_INT 13
53075: ST_TO_ADDR
// hc_gallery =  ;
53076: LD_ADDR_OWVAR 33
53080: PUSH
53081: LD_STRING 
53083: ST_TO_ADDR
// animal := CreateHuman ;
53084: LD_ADDR_VAR 0 12
53088: PUSH
53089: CALL_OW 44
53093: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
53094: LD_VAR 0 12
53098: PPUSH
53099: LD_VAR 0 8
53103: PPUSH
53104: LD_INT 0
53106: PPUSH
53107: CALL 54875 0 3
// end ;
53111: GO 53065
53113: POP
53114: POP
// if fishes then
53115: LD_VAR 0 7
53119: IFFALSE 53186
// for i = 1 to fishes do
53121: LD_ADDR_VAR 0 11
53125: PUSH
53126: DOUBLE
53127: LD_INT 1
53129: DEC
53130: ST_TO_ADDR
53131: LD_VAR 0 7
53135: PUSH
53136: FOR_TO
53137: IFFALSE 53184
// begin hc_class = 20 ;
53139: LD_ADDR_OWVAR 28
53143: PUSH
53144: LD_INT 20
53146: ST_TO_ADDR
// hc_gallery =  ;
53147: LD_ADDR_OWVAR 33
53151: PUSH
53152: LD_STRING 
53154: ST_TO_ADDR
// animal := CreateHuman ;
53155: LD_ADDR_VAR 0 12
53159: PUSH
53160: CALL_OW 44
53164: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
53165: LD_VAR 0 12
53169: PPUSH
53170: LD_VAR 0 9
53174: PPUSH
53175: LD_INT 0
53177: PPUSH
53178: CALL 54875 0 3
// end ;
53182: GO 53136
53184: POP
53185: POP
// end ;
53186: LD_VAR 0 10
53190: RET
// export function WantHeal ( sci , unit ) ; begin
53191: LD_INT 0
53193: PPUSH
// if GetTaskList ( sci ) > 0 then
53194: LD_VAR 0 1
53198: PPUSH
53199: CALL_OW 437
53203: PUSH
53204: LD_INT 0
53206: GREATER
53207: IFFALSE 53277
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
53209: LD_VAR 0 1
53213: PPUSH
53214: CALL_OW 437
53218: PUSH
53219: LD_INT 1
53221: ARRAY
53222: PUSH
53223: LD_INT 1
53225: ARRAY
53226: PUSH
53227: LD_STRING l
53229: EQUAL
53230: PUSH
53231: LD_VAR 0 1
53235: PPUSH
53236: CALL_OW 437
53240: PUSH
53241: LD_INT 1
53243: ARRAY
53244: PUSH
53245: LD_INT 4
53247: ARRAY
53248: PUSH
53249: LD_VAR 0 2
53253: EQUAL
53254: AND
53255: IFFALSE 53267
// result := true else
53257: LD_ADDR_VAR 0 3
53261: PUSH
53262: LD_INT 1
53264: ST_TO_ADDR
53265: GO 53275
// result := false ;
53267: LD_ADDR_VAR 0 3
53271: PUSH
53272: LD_INT 0
53274: ST_TO_ADDR
// end else
53275: GO 53285
// result := false ;
53277: LD_ADDR_VAR 0 3
53281: PUSH
53282: LD_INT 0
53284: ST_TO_ADDR
// end ;
53285: LD_VAR 0 3
53289: RET
// export function HealTarget ( sci ) ; begin
53290: LD_INT 0
53292: PPUSH
// if not sci then
53293: LD_VAR 0 1
53297: NOT
53298: IFFALSE 53302
// exit ;
53300: GO 53367
// result := 0 ;
53302: LD_ADDR_VAR 0 2
53306: PUSH
53307: LD_INT 0
53309: ST_TO_ADDR
// if GetTaskList ( sci ) then
53310: LD_VAR 0 1
53314: PPUSH
53315: CALL_OW 437
53319: IFFALSE 53367
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
53321: LD_VAR 0 1
53325: PPUSH
53326: CALL_OW 437
53330: PUSH
53331: LD_INT 1
53333: ARRAY
53334: PUSH
53335: LD_INT 1
53337: ARRAY
53338: PUSH
53339: LD_STRING l
53341: EQUAL
53342: IFFALSE 53367
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
53344: LD_ADDR_VAR 0 2
53348: PUSH
53349: LD_VAR 0 1
53353: PPUSH
53354: CALL_OW 437
53358: PUSH
53359: LD_INT 1
53361: ARRAY
53362: PUSH
53363: LD_INT 4
53365: ARRAY
53366: ST_TO_ADDR
// end ;
53367: LD_VAR 0 2
53371: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
53372: LD_INT 0
53374: PPUSH
53375: PPUSH
53376: PPUSH
53377: PPUSH
// if not base_units then
53378: LD_VAR 0 1
53382: NOT
53383: IFFALSE 53387
// exit ;
53385: GO 53474
// result := false ;
53387: LD_ADDR_VAR 0 2
53391: PUSH
53392: LD_INT 0
53394: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
53395: LD_ADDR_VAR 0 5
53399: PUSH
53400: LD_VAR 0 1
53404: PPUSH
53405: LD_INT 21
53407: PUSH
53408: LD_INT 3
53410: PUSH
53411: EMPTY
53412: LIST
53413: LIST
53414: PPUSH
53415: CALL_OW 72
53419: ST_TO_ADDR
// if not tmp then
53420: LD_VAR 0 5
53424: NOT
53425: IFFALSE 53429
// exit ;
53427: GO 53474
// for i in tmp do
53429: LD_ADDR_VAR 0 3
53433: PUSH
53434: LD_VAR 0 5
53438: PUSH
53439: FOR_IN
53440: IFFALSE 53472
// begin result := EnemyInRange ( i , 22 ) ;
53442: LD_ADDR_VAR 0 2
53446: PUSH
53447: LD_VAR 0 3
53451: PPUSH
53452: LD_INT 22
53454: PPUSH
53455: CALL 51710 0 2
53459: ST_TO_ADDR
// if result then
53460: LD_VAR 0 2
53464: IFFALSE 53470
// exit ;
53466: POP
53467: POP
53468: GO 53474
// end ;
53470: GO 53439
53472: POP
53473: POP
// end ;
53474: LD_VAR 0 2
53478: RET
// export function FilterByTag ( units , tag ) ; var i ; begin
53479: LD_INT 0
53481: PPUSH
53482: PPUSH
// if not units then
53483: LD_VAR 0 1
53487: NOT
53488: IFFALSE 53492
// exit ;
53490: GO 53562
// result := [ ] ;
53492: LD_ADDR_VAR 0 3
53496: PUSH
53497: EMPTY
53498: ST_TO_ADDR
// for i in units do
53499: LD_ADDR_VAR 0 4
53503: PUSH
53504: LD_VAR 0 1
53508: PUSH
53509: FOR_IN
53510: IFFALSE 53560
// if GetTag ( i ) = tag then
53512: LD_VAR 0 4
53516: PPUSH
53517: CALL_OW 110
53521: PUSH
53522: LD_VAR 0 2
53526: EQUAL
53527: IFFALSE 53558
// result := Replace ( result , result + 1 , i ) ;
53529: LD_ADDR_VAR 0 3
53533: PUSH
53534: LD_VAR 0 3
53538: PPUSH
53539: LD_VAR 0 3
53543: PUSH
53544: LD_INT 1
53546: PLUS
53547: PPUSH
53548: LD_VAR 0 4
53552: PPUSH
53553: CALL_OW 1
53557: ST_TO_ADDR
53558: GO 53509
53560: POP
53561: POP
// end ;
53562: LD_VAR 0 3
53566: RET
// export function IsDriver ( un ) ; begin
53567: LD_INT 0
53569: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
53570: LD_ADDR_VAR 0 2
53574: PUSH
53575: LD_VAR 0 1
53579: PUSH
53580: LD_INT 55
53582: PUSH
53583: EMPTY
53584: LIST
53585: PPUSH
53586: CALL_OW 69
53590: IN
53591: ST_TO_ADDR
// end ;
53592: LD_VAR 0 2
53596: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
53597: LD_INT 0
53599: PPUSH
53600: PPUSH
// list := [ ] ;
53601: LD_ADDR_VAR 0 5
53605: PUSH
53606: EMPTY
53607: ST_TO_ADDR
// case d of 0 :
53608: LD_VAR 0 3
53612: PUSH
53613: LD_INT 0
53615: DOUBLE
53616: EQUAL
53617: IFTRUE 53621
53619: GO 53754
53621: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
53622: LD_ADDR_VAR 0 5
53626: PUSH
53627: LD_VAR 0 1
53631: PUSH
53632: LD_INT 4
53634: MINUS
53635: PUSH
53636: LD_VAR 0 2
53640: PUSH
53641: LD_INT 4
53643: MINUS
53644: PUSH
53645: LD_INT 2
53647: PUSH
53648: EMPTY
53649: LIST
53650: LIST
53651: LIST
53652: PUSH
53653: LD_VAR 0 1
53657: PUSH
53658: LD_INT 3
53660: MINUS
53661: PUSH
53662: LD_VAR 0 2
53666: PUSH
53667: LD_INT 1
53669: PUSH
53670: EMPTY
53671: LIST
53672: LIST
53673: LIST
53674: PUSH
53675: LD_VAR 0 1
53679: PUSH
53680: LD_INT 4
53682: PLUS
53683: PUSH
53684: LD_VAR 0 2
53688: PUSH
53689: LD_INT 4
53691: PUSH
53692: EMPTY
53693: LIST
53694: LIST
53695: LIST
53696: PUSH
53697: LD_VAR 0 1
53701: PUSH
53702: LD_INT 3
53704: PLUS
53705: PUSH
53706: LD_VAR 0 2
53710: PUSH
53711: LD_INT 3
53713: PLUS
53714: PUSH
53715: LD_INT 5
53717: PUSH
53718: EMPTY
53719: LIST
53720: LIST
53721: LIST
53722: PUSH
53723: LD_VAR 0 1
53727: PUSH
53728: LD_VAR 0 2
53732: PUSH
53733: LD_INT 4
53735: PLUS
53736: PUSH
53737: LD_INT 0
53739: PUSH
53740: EMPTY
53741: LIST
53742: LIST
53743: LIST
53744: PUSH
53745: EMPTY
53746: LIST
53747: LIST
53748: LIST
53749: LIST
53750: LIST
53751: ST_TO_ADDR
// end ; 1 :
53752: GO 54452
53754: LD_INT 1
53756: DOUBLE
53757: EQUAL
53758: IFTRUE 53762
53760: GO 53895
53762: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
53763: LD_ADDR_VAR 0 5
53767: PUSH
53768: LD_VAR 0 1
53772: PUSH
53773: LD_VAR 0 2
53777: PUSH
53778: LD_INT 4
53780: MINUS
53781: PUSH
53782: LD_INT 3
53784: PUSH
53785: EMPTY
53786: LIST
53787: LIST
53788: LIST
53789: PUSH
53790: LD_VAR 0 1
53794: PUSH
53795: LD_INT 3
53797: MINUS
53798: PUSH
53799: LD_VAR 0 2
53803: PUSH
53804: LD_INT 3
53806: MINUS
53807: PUSH
53808: LD_INT 2
53810: PUSH
53811: EMPTY
53812: LIST
53813: LIST
53814: LIST
53815: PUSH
53816: LD_VAR 0 1
53820: PUSH
53821: LD_INT 4
53823: MINUS
53824: PUSH
53825: LD_VAR 0 2
53829: PUSH
53830: LD_INT 1
53832: PUSH
53833: EMPTY
53834: LIST
53835: LIST
53836: LIST
53837: PUSH
53838: LD_VAR 0 1
53842: PUSH
53843: LD_VAR 0 2
53847: PUSH
53848: LD_INT 3
53850: PLUS
53851: PUSH
53852: LD_INT 0
53854: PUSH
53855: EMPTY
53856: LIST
53857: LIST
53858: LIST
53859: PUSH
53860: LD_VAR 0 1
53864: PUSH
53865: LD_INT 4
53867: PLUS
53868: PUSH
53869: LD_VAR 0 2
53873: PUSH
53874: LD_INT 4
53876: PLUS
53877: PUSH
53878: LD_INT 5
53880: PUSH
53881: EMPTY
53882: LIST
53883: LIST
53884: LIST
53885: PUSH
53886: EMPTY
53887: LIST
53888: LIST
53889: LIST
53890: LIST
53891: LIST
53892: ST_TO_ADDR
// end ; 2 :
53893: GO 54452
53895: LD_INT 2
53897: DOUBLE
53898: EQUAL
53899: IFTRUE 53903
53901: GO 54032
53903: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
53904: LD_ADDR_VAR 0 5
53908: PUSH
53909: LD_VAR 0 1
53913: PUSH
53914: LD_VAR 0 2
53918: PUSH
53919: LD_INT 3
53921: MINUS
53922: PUSH
53923: LD_INT 3
53925: PUSH
53926: EMPTY
53927: LIST
53928: LIST
53929: LIST
53930: PUSH
53931: LD_VAR 0 1
53935: PUSH
53936: LD_INT 4
53938: PLUS
53939: PUSH
53940: LD_VAR 0 2
53944: PUSH
53945: LD_INT 4
53947: PUSH
53948: EMPTY
53949: LIST
53950: LIST
53951: LIST
53952: PUSH
53953: LD_VAR 0 1
53957: PUSH
53958: LD_VAR 0 2
53962: PUSH
53963: LD_INT 4
53965: PLUS
53966: PUSH
53967: LD_INT 0
53969: PUSH
53970: EMPTY
53971: LIST
53972: LIST
53973: LIST
53974: PUSH
53975: LD_VAR 0 1
53979: PUSH
53980: LD_INT 3
53982: MINUS
53983: PUSH
53984: LD_VAR 0 2
53988: PUSH
53989: LD_INT 1
53991: PUSH
53992: EMPTY
53993: LIST
53994: LIST
53995: LIST
53996: PUSH
53997: LD_VAR 0 1
54001: PUSH
54002: LD_INT 4
54004: MINUS
54005: PUSH
54006: LD_VAR 0 2
54010: PUSH
54011: LD_INT 4
54013: MINUS
54014: PUSH
54015: LD_INT 2
54017: PUSH
54018: EMPTY
54019: LIST
54020: LIST
54021: LIST
54022: PUSH
54023: EMPTY
54024: LIST
54025: LIST
54026: LIST
54027: LIST
54028: LIST
54029: ST_TO_ADDR
// end ; 3 :
54030: GO 54452
54032: LD_INT 3
54034: DOUBLE
54035: EQUAL
54036: IFTRUE 54040
54038: GO 54173
54040: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
54041: LD_ADDR_VAR 0 5
54045: PUSH
54046: LD_VAR 0 1
54050: PUSH
54051: LD_INT 3
54053: PLUS
54054: PUSH
54055: LD_VAR 0 2
54059: PUSH
54060: LD_INT 4
54062: PUSH
54063: EMPTY
54064: LIST
54065: LIST
54066: LIST
54067: PUSH
54068: LD_VAR 0 1
54072: PUSH
54073: LD_INT 4
54075: PLUS
54076: PUSH
54077: LD_VAR 0 2
54081: PUSH
54082: LD_INT 4
54084: PLUS
54085: PUSH
54086: LD_INT 5
54088: PUSH
54089: EMPTY
54090: LIST
54091: LIST
54092: LIST
54093: PUSH
54094: LD_VAR 0 1
54098: PUSH
54099: LD_INT 4
54101: MINUS
54102: PUSH
54103: LD_VAR 0 2
54107: PUSH
54108: LD_INT 1
54110: PUSH
54111: EMPTY
54112: LIST
54113: LIST
54114: LIST
54115: PUSH
54116: LD_VAR 0 1
54120: PUSH
54121: LD_VAR 0 2
54125: PUSH
54126: LD_INT 4
54128: MINUS
54129: PUSH
54130: LD_INT 3
54132: PUSH
54133: EMPTY
54134: LIST
54135: LIST
54136: LIST
54137: PUSH
54138: LD_VAR 0 1
54142: PUSH
54143: LD_INT 3
54145: MINUS
54146: PUSH
54147: LD_VAR 0 2
54151: PUSH
54152: LD_INT 3
54154: MINUS
54155: PUSH
54156: LD_INT 2
54158: PUSH
54159: EMPTY
54160: LIST
54161: LIST
54162: LIST
54163: PUSH
54164: EMPTY
54165: LIST
54166: LIST
54167: LIST
54168: LIST
54169: LIST
54170: ST_TO_ADDR
// end ; 4 :
54171: GO 54452
54173: LD_INT 4
54175: DOUBLE
54176: EQUAL
54177: IFTRUE 54181
54179: GO 54314
54181: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
54182: LD_ADDR_VAR 0 5
54186: PUSH
54187: LD_VAR 0 1
54191: PUSH
54192: LD_VAR 0 2
54196: PUSH
54197: LD_INT 4
54199: PLUS
54200: PUSH
54201: LD_INT 0
54203: PUSH
54204: EMPTY
54205: LIST
54206: LIST
54207: LIST
54208: PUSH
54209: LD_VAR 0 1
54213: PUSH
54214: LD_INT 3
54216: PLUS
54217: PUSH
54218: LD_VAR 0 2
54222: PUSH
54223: LD_INT 3
54225: PLUS
54226: PUSH
54227: LD_INT 5
54229: PUSH
54230: EMPTY
54231: LIST
54232: LIST
54233: LIST
54234: PUSH
54235: LD_VAR 0 1
54239: PUSH
54240: LD_INT 4
54242: PLUS
54243: PUSH
54244: LD_VAR 0 2
54248: PUSH
54249: LD_INT 4
54251: PUSH
54252: EMPTY
54253: LIST
54254: LIST
54255: LIST
54256: PUSH
54257: LD_VAR 0 1
54261: PUSH
54262: LD_VAR 0 2
54266: PUSH
54267: LD_INT 3
54269: MINUS
54270: PUSH
54271: LD_INT 3
54273: PUSH
54274: EMPTY
54275: LIST
54276: LIST
54277: LIST
54278: PUSH
54279: LD_VAR 0 1
54283: PUSH
54284: LD_INT 4
54286: MINUS
54287: PUSH
54288: LD_VAR 0 2
54292: PUSH
54293: LD_INT 4
54295: MINUS
54296: PUSH
54297: LD_INT 2
54299: PUSH
54300: EMPTY
54301: LIST
54302: LIST
54303: LIST
54304: PUSH
54305: EMPTY
54306: LIST
54307: LIST
54308: LIST
54309: LIST
54310: LIST
54311: ST_TO_ADDR
// end ; 5 :
54312: GO 54452
54314: LD_INT 5
54316: DOUBLE
54317: EQUAL
54318: IFTRUE 54322
54320: GO 54451
54322: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
54323: LD_ADDR_VAR 0 5
54327: PUSH
54328: LD_VAR 0 1
54332: PUSH
54333: LD_INT 4
54335: MINUS
54336: PUSH
54337: LD_VAR 0 2
54341: PUSH
54342: LD_INT 1
54344: PUSH
54345: EMPTY
54346: LIST
54347: LIST
54348: LIST
54349: PUSH
54350: LD_VAR 0 1
54354: PUSH
54355: LD_VAR 0 2
54359: PUSH
54360: LD_INT 4
54362: MINUS
54363: PUSH
54364: LD_INT 3
54366: PUSH
54367: EMPTY
54368: LIST
54369: LIST
54370: LIST
54371: PUSH
54372: LD_VAR 0 1
54376: PUSH
54377: LD_INT 4
54379: PLUS
54380: PUSH
54381: LD_VAR 0 2
54385: PUSH
54386: LD_INT 4
54388: PLUS
54389: PUSH
54390: LD_INT 5
54392: PUSH
54393: EMPTY
54394: LIST
54395: LIST
54396: LIST
54397: PUSH
54398: LD_VAR 0 1
54402: PUSH
54403: LD_INT 3
54405: PLUS
54406: PUSH
54407: LD_VAR 0 2
54411: PUSH
54412: LD_INT 4
54414: PUSH
54415: EMPTY
54416: LIST
54417: LIST
54418: LIST
54419: PUSH
54420: LD_VAR 0 1
54424: PUSH
54425: LD_VAR 0 2
54429: PUSH
54430: LD_INT 3
54432: PLUS
54433: PUSH
54434: LD_INT 0
54436: PUSH
54437: EMPTY
54438: LIST
54439: LIST
54440: LIST
54441: PUSH
54442: EMPTY
54443: LIST
54444: LIST
54445: LIST
54446: LIST
54447: LIST
54448: ST_TO_ADDR
// end ; end ;
54449: GO 54452
54451: POP
// result := list ;
54452: LD_ADDR_VAR 0 4
54456: PUSH
54457: LD_VAR 0 5
54461: ST_TO_ADDR
// end ;
54462: LD_VAR 0 4
54466: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
54467: LD_INT 0
54469: PPUSH
54470: PPUSH
54471: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
54472: LD_VAR 0 1
54476: NOT
54477: PUSH
54478: LD_VAR 0 2
54482: PUSH
54483: LD_INT 1
54485: PUSH
54486: LD_INT 2
54488: PUSH
54489: LD_INT 3
54491: PUSH
54492: LD_INT 4
54494: PUSH
54495: EMPTY
54496: LIST
54497: LIST
54498: LIST
54499: LIST
54500: IN
54501: NOT
54502: OR
54503: IFFALSE 54507
// exit ;
54505: GO 54599
// tmp := [ ] ;
54507: LD_ADDR_VAR 0 5
54511: PUSH
54512: EMPTY
54513: ST_TO_ADDR
// for i in units do
54514: LD_ADDR_VAR 0 4
54518: PUSH
54519: LD_VAR 0 1
54523: PUSH
54524: FOR_IN
54525: IFFALSE 54568
// tmp := Insert ( tmp , tmp + 1 , GetSkill ( i , class ) ) ;
54527: LD_ADDR_VAR 0 5
54531: PUSH
54532: LD_VAR 0 5
54536: PPUSH
54537: LD_VAR 0 5
54541: PUSH
54542: LD_INT 1
54544: PLUS
54545: PPUSH
54546: LD_VAR 0 4
54550: PPUSH
54551: LD_VAR 0 2
54555: PPUSH
54556: CALL_OW 259
54560: PPUSH
54561: CALL_OW 2
54565: ST_TO_ADDR
54566: GO 54524
54568: POP
54569: POP
// if not tmp then
54570: LD_VAR 0 5
54574: NOT
54575: IFFALSE 54579
// exit ;
54577: GO 54599
// result := SortListByListDesc ( units , tmp ) ;
54579: LD_ADDR_VAR 0 3
54583: PUSH
54584: LD_VAR 0 1
54588: PPUSH
54589: LD_VAR 0 5
54593: PPUSH
54594: CALL_OW 77
54598: ST_TO_ADDR
// end ;
54599: LD_VAR 0 3
54603: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
54604: LD_INT 0
54606: PPUSH
54607: PPUSH
54608: PPUSH
// result := false ;
54609: LD_ADDR_VAR 0 3
54613: PUSH
54614: LD_INT 0
54616: ST_TO_ADDR
// x := GetX ( building ) ;
54617: LD_ADDR_VAR 0 4
54621: PUSH
54622: LD_VAR 0 2
54626: PPUSH
54627: CALL_OW 250
54631: ST_TO_ADDR
// y := GetY ( building ) ;
54632: LD_ADDR_VAR 0 5
54636: PUSH
54637: LD_VAR 0 2
54641: PPUSH
54642: CALL_OW 251
54646: ST_TO_ADDR
// if not building or not x or not y then
54647: LD_VAR 0 2
54651: NOT
54652: PUSH
54653: LD_VAR 0 4
54657: NOT
54658: OR
54659: PUSH
54660: LD_VAR 0 5
54664: NOT
54665: OR
54666: IFFALSE 54670
// exit ;
54668: GO 54762
// if GetTaskList ( unit ) then
54670: LD_VAR 0 1
54674: PPUSH
54675: CALL_OW 437
54679: IFFALSE 54762
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
54681: LD_STRING e
54683: PUSH
54684: LD_VAR 0 1
54688: PPUSH
54689: CALL_OW 437
54693: PUSH
54694: LD_INT 1
54696: ARRAY
54697: PUSH
54698: LD_INT 1
54700: ARRAY
54701: EQUAL
54702: PUSH
54703: LD_VAR 0 4
54707: PUSH
54708: LD_VAR 0 1
54712: PPUSH
54713: CALL_OW 437
54717: PUSH
54718: LD_INT 1
54720: ARRAY
54721: PUSH
54722: LD_INT 2
54724: ARRAY
54725: EQUAL
54726: AND
54727: PUSH
54728: LD_VAR 0 5
54732: PUSH
54733: LD_VAR 0 1
54737: PPUSH
54738: CALL_OW 437
54742: PUSH
54743: LD_INT 1
54745: ARRAY
54746: PUSH
54747: LD_INT 3
54749: ARRAY
54750: EQUAL
54751: AND
54752: IFFALSE 54762
// result := true end ;
54754: LD_ADDR_VAR 0 3
54758: PUSH
54759: LD_INT 1
54761: ST_TO_ADDR
// end ;
54762: LD_VAR 0 3
54766: RET
// export function UnitGoingToXY ( unit , x , y ) ; begin
54767: LD_INT 0
54769: PPUSH
// result := false ;
54770: LD_ADDR_VAR 0 4
54774: PUSH
54775: LD_INT 0
54777: ST_TO_ADDR
// if GetTaskList ( unit ) then
54778: LD_VAR 0 1
54782: PPUSH
54783: CALL_OW 437
54787: IFFALSE 54870
// begin if M = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
54789: LD_STRING M
54791: PUSH
54792: LD_VAR 0 1
54796: PPUSH
54797: CALL_OW 437
54801: PUSH
54802: LD_INT 1
54804: ARRAY
54805: PUSH
54806: LD_INT 1
54808: ARRAY
54809: EQUAL
54810: PUSH
54811: LD_VAR 0 2
54815: PUSH
54816: LD_VAR 0 1
54820: PPUSH
54821: CALL_OW 437
54825: PUSH
54826: LD_INT 1
54828: ARRAY
54829: PUSH
54830: LD_INT 2
54832: ARRAY
54833: EQUAL
54834: AND
54835: PUSH
54836: LD_VAR 0 3
54840: PUSH
54841: LD_VAR 0 1
54845: PPUSH
54846: CALL_OW 437
54850: PUSH
54851: LD_INT 1
54853: ARRAY
54854: PUSH
54855: LD_INT 3
54857: ARRAY
54858: EQUAL
54859: AND
54860: IFFALSE 54870
// result := true ;
54862: LD_ADDR_VAR 0 4
54866: PUSH
54867: LD_INT 1
54869: ST_TO_ADDR
// end ; end ;
54870: LD_VAR 0 4
54874: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
54875: LD_INT 0
54877: PPUSH
54878: PPUSH
54879: PPUSH
54880: PPUSH
// if not unit or not area then
54881: LD_VAR 0 1
54885: NOT
54886: PUSH
54887: LD_VAR 0 2
54891: NOT
54892: OR
54893: IFFALSE 54897
// exit ;
54895: GO 55061
// tmp := AreaToList ( area , i ) ;
54897: LD_ADDR_VAR 0 6
54901: PUSH
54902: LD_VAR 0 2
54906: PPUSH
54907: LD_VAR 0 5
54911: PPUSH
54912: CALL_OW 517
54916: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
54917: LD_ADDR_VAR 0 5
54921: PUSH
54922: DOUBLE
54923: LD_INT 1
54925: DEC
54926: ST_TO_ADDR
54927: LD_VAR 0 6
54931: PUSH
54932: LD_INT 1
54934: ARRAY
54935: PUSH
54936: FOR_TO
54937: IFFALSE 55059
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
54939: LD_ADDR_VAR 0 7
54943: PUSH
54944: LD_VAR 0 6
54948: PUSH
54949: LD_INT 1
54951: ARRAY
54952: PUSH
54953: LD_VAR 0 5
54957: ARRAY
54958: PUSH
54959: LD_VAR 0 6
54963: PUSH
54964: LD_INT 2
54966: ARRAY
54967: PUSH
54968: LD_VAR 0 5
54972: ARRAY
54973: PUSH
54974: EMPTY
54975: LIST
54976: LIST
54977: ST_TO_ADDR
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
54978: LD_VAR 0 7
54982: PUSH
54983: LD_INT 1
54985: ARRAY
54986: PPUSH
54987: LD_VAR 0 7
54991: PUSH
54992: LD_INT 2
54994: ARRAY
54995: PPUSH
54996: CALL_OW 428
55000: PUSH
55001: LD_INT 0
55003: EQUAL
55004: IFFALSE 55057
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
55006: LD_VAR 0 1
55010: PPUSH
55011: LD_VAR 0 7
55015: PUSH
55016: LD_INT 1
55018: ARRAY
55019: PPUSH
55020: LD_VAR 0 7
55024: PUSH
55025: LD_INT 2
55027: ARRAY
55028: PPUSH
55029: LD_VAR 0 3
55033: PPUSH
55034: CALL_OW 48
// result := IsPlaced ( unit ) ;
55038: LD_ADDR_VAR 0 4
55042: PUSH
55043: LD_VAR 0 1
55047: PPUSH
55048: CALL_OW 305
55052: ST_TO_ADDR
// exit ;
55053: POP
55054: POP
55055: GO 55061
// end ; end ;
55057: GO 54936
55059: POP
55060: POP
// end ;
55061: LD_VAR 0 4
55065: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
55066: LD_INT 0
55068: PPUSH
55069: PPUSH
55070: PPUSH
// if not side or side > 8 then
55071: LD_VAR 0 1
55075: NOT
55076: PUSH
55077: LD_VAR 0 1
55081: PUSH
55082: LD_INT 8
55084: GREATER
55085: OR
55086: IFFALSE 55090
// exit ;
55088: GO 55277
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
55090: LD_ADDR_VAR 0 4
55094: PUSH
55095: LD_INT 22
55097: PUSH
55098: LD_VAR 0 1
55102: PUSH
55103: EMPTY
55104: LIST
55105: LIST
55106: PUSH
55107: LD_INT 21
55109: PUSH
55110: LD_INT 3
55112: PUSH
55113: EMPTY
55114: LIST
55115: LIST
55116: PUSH
55117: EMPTY
55118: LIST
55119: LIST
55120: PPUSH
55121: CALL_OW 69
55125: ST_TO_ADDR
// if not tmp then
55126: LD_VAR 0 4
55130: NOT
55131: IFFALSE 55135
// exit ;
55133: GO 55277
// enable_addtolog := true ;
55135: LD_ADDR_OWVAR 81
55139: PUSH
55140: LD_INT 1
55142: ST_TO_ADDR
// AddToLog ( [ ) ;
55143: LD_STRING [
55145: PPUSH
55146: CALL_OW 561
// for i in tmp do
55150: LD_ADDR_VAR 0 3
55154: PUSH
55155: LD_VAR 0 4
55159: PUSH
55160: FOR_IN
55161: IFFALSE 55268
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
55163: LD_STRING [
55165: PUSH
55166: LD_VAR 0 3
55170: PPUSH
55171: CALL_OW 266
55175: STR
55176: PUSH
55177: LD_STRING , 
55179: STR
55180: PUSH
55181: LD_VAR 0 3
55185: PPUSH
55186: CALL_OW 250
55190: STR
55191: PUSH
55192: LD_STRING , 
55194: STR
55195: PUSH
55196: LD_VAR 0 3
55200: PPUSH
55201: CALL_OW 251
55205: STR
55206: PUSH
55207: LD_STRING , 
55209: STR
55210: PUSH
55211: LD_VAR 0 3
55215: PPUSH
55216: CALL_OW 254
55220: STR
55221: PUSH
55222: LD_STRING , 
55224: STR
55225: PUSH
55226: LD_VAR 0 3
55230: PPUSH
55231: LD_INT 1
55233: PPUSH
55234: CALL_OW 268
55238: STR
55239: PUSH
55240: LD_STRING , 
55242: STR
55243: PUSH
55244: LD_VAR 0 3
55248: PPUSH
55249: LD_INT 2
55251: PPUSH
55252: CALL_OW 268
55256: STR
55257: PUSH
55258: LD_STRING ],
55260: STR
55261: PPUSH
55262: CALL_OW 561
// end ;
55266: GO 55160
55268: POP
55269: POP
// AddToLog ( ]; ) ;
55270: LD_STRING ];
55272: PPUSH
55273: CALL_OW 561
// end ;
55277: LD_VAR 0 2
55281: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
55282: LD_INT 0
55284: PPUSH
55285: PPUSH
55286: PPUSH
55287: PPUSH
55288: PPUSH
// if not area or not rate or not max then
55289: LD_VAR 0 1
55293: NOT
55294: PUSH
55295: LD_VAR 0 2
55299: NOT
55300: OR
55301: PUSH
55302: LD_VAR 0 4
55306: NOT
55307: OR
55308: IFFALSE 55312
// exit ;
55310: GO 55504
// while 1 do
55312: LD_INT 1
55314: IFFALSE 55504
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
55316: LD_ADDR_VAR 0 9
55320: PUSH
55321: LD_VAR 0 1
55325: PPUSH
55326: LD_INT 1
55328: PPUSH
55329: CALL_OW 287
55333: PUSH
55334: LD_INT 10
55336: MUL
55337: ST_TO_ADDR
// r := rate / 10 ;
55338: LD_ADDR_VAR 0 7
55342: PUSH
55343: LD_VAR 0 2
55347: PUSH
55348: LD_INT 10
55350: DIVREAL
55351: ST_TO_ADDR
// time := 1 1$00 ;
55352: LD_ADDR_VAR 0 8
55356: PUSH
55357: LD_INT 2100
55359: ST_TO_ADDR
// if amount < min then
55360: LD_VAR 0 9
55364: PUSH
55365: LD_VAR 0 3
55369: LESS
55370: IFFALSE 55388
// r := r * 2 else
55372: LD_ADDR_VAR 0 7
55376: PUSH
55377: LD_VAR 0 7
55381: PUSH
55382: LD_INT 2
55384: MUL
55385: ST_TO_ADDR
55386: GO 55414
// if amount > max then
55388: LD_VAR 0 9
55392: PUSH
55393: LD_VAR 0 4
55397: GREATER
55398: IFFALSE 55414
// r := r / 2 ;
55400: LD_ADDR_VAR 0 7
55404: PUSH
55405: LD_VAR 0 7
55409: PUSH
55410: LD_INT 2
55412: DIVREAL
55413: ST_TO_ADDR
// time := time / r ;
55414: LD_ADDR_VAR 0 8
55418: PUSH
55419: LD_VAR 0 8
55423: PUSH
55424: LD_VAR 0 7
55428: DIVREAL
55429: ST_TO_ADDR
// if time < 0 then
55430: LD_VAR 0 8
55434: PUSH
55435: LD_INT 0
55437: LESS
55438: IFFALSE 55455
// time := time * - 1 ;
55440: LD_ADDR_VAR 0 8
55444: PUSH
55445: LD_VAR 0 8
55449: PUSH
55450: LD_INT 1
55452: NEG
55453: MUL
55454: ST_TO_ADDR
// wait ( time ) ;
55455: LD_VAR 0 8
55459: PPUSH
55460: CALL_OW 67
// wait ( rand ( 0 0$01 , 0 0$25 ) ) ;
55464: LD_INT 35
55466: PPUSH
55467: LD_INT 875
55469: PPUSH
55470: CALL_OW 12
55474: PPUSH
55475: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
55479: LD_INT 1
55481: PPUSH
55482: LD_INT 5
55484: PPUSH
55485: CALL_OW 12
55489: PPUSH
55490: LD_VAR 0 1
55494: PPUSH
55495: LD_INT 1
55497: PPUSH
55498: CALL_OW 55
// end ;
55502: GO 55312
// end ;
55504: LD_VAR 0 5
55508: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
55509: LD_INT 0
55511: PPUSH
55512: PPUSH
55513: PPUSH
55514: PPUSH
55515: PPUSH
55516: PPUSH
55517: PPUSH
55518: PPUSH
// if not turrets or not factories then
55519: LD_VAR 0 1
55523: NOT
55524: PUSH
55525: LD_VAR 0 2
55529: NOT
55530: OR
55531: IFFALSE 55535
// exit ;
55533: GO 55842
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
55535: LD_ADDR_VAR 0 10
55539: PUSH
55540: LD_INT 5
55542: PUSH
55543: LD_INT 6
55545: PUSH
55546: EMPTY
55547: LIST
55548: LIST
55549: PUSH
55550: LD_INT 2
55552: PUSH
55553: LD_INT 4
55555: PUSH
55556: EMPTY
55557: LIST
55558: LIST
55559: PUSH
55560: LD_INT 3
55562: PUSH
55563: LD_INT 5
55565: PUSH
55566: EMPTY
55567: LIST
55568: LIST
55569: PUSH
55570: EMPTY
55571: LIST
55572: LIST
55573: LIST
55574: PUSH
55575: LD_INT 24
55577: PUSH
55578: LD_INT 25
55580: PUSH
55581: EMPTY
55582: LIST
55583: LIST
55584: PUSH
55585: LD_INT 23
55587: PUSH
55588: LD_INT 27
55590: PUSH
55591: EMPTY
55592: LIST
55593: LIST
55594: PUSH
55595: EMPTY
55596: LIST
55597: LIST
55598: PUSH
55599: LD_INT 42
55601: PUSH
55602: LD_INT 43
55604: PUSH
55605: EMPTY
55606: LIST
55607: LIST
55608: PUSH
55609: LD_INT 44
55611: PUSH
55612: LD_INT 46
55614: PUSH
55615: EMPTY
55616: LIST
55617: LIST
55618: PUSH
55619: LD_INT 45
55621: PUSH
55622: LD_INT 47
55624: PUSH
55625: EMPTY
55626: LIST
55627: LIST
55628: PUSH
55629: EMPTY
55630: LIST
55631: LIST
55632: LIST
55633: PUSH
55634: EMPTY
55635: LIST
55636: LIST
55637: LIST
55638: ST_TO_ADDR
// result := [ ] ;
55639: LD_ADDR_VAR 0 3
55643: PUSH
55644: EMPTY
55645: ST_TO_ADDR
// for i in turrets do
55646: LD_ADDR_VAR 0 4
55650: PUSH
55651: LD_VAR 0 1
55655: PUSH
55656: FOR_IN
55657: IFFALSE 55840
// begin nat := GetNation ( i ) ;
55659: LD_ADDR_VAR 0 7
55663: PUSH
55664: LD_VAR 0 4
55668: PPUSH
55669: CALL_OW 248
55673: ST_TO_ADDR
// weapon := 0 ;
55674: LD_ADDR_VAR 0 8
55678: PUSH
55679: LD_INT 0
55681: ST_TO_ADDR
// if not nat then
55682: LD_VAR 0 7
55686: NOT
55687: IFFALSE 55691
// continue ;
55689: GO 55656
// for j in list [ nat ] do
55691: LD_ADDR_VAR 0 5
55695: PUSH
55696: LD_VAR 0 10
55700: PUSH
55701: LD_VAR 0 7
55705: ARRAY
55706: PUSH
55707: FOR_IN
55708: IFFALSE 55749
// if GetBWeapon ( i ) = j [ 1 ] then
55710: LD_VAR 0 4
55714: PPUSH
55715: CALL_OW 269
55719: PUSH
55720: LD_VAR 0 5
55724: PUSH
55725: LD_INT 1
55727: ARRAY
55728: EQUAL
55729: IFFALSE 55747
// begin weapon := j [ 2 ] ;
55731: LD_ADDR_VAR 0 8
55735: PUSH
55736: LD_VAR 0 5
55740: PUSH
55741: LD_INT 2
55743: ARRAY
55744: ST_TO_ADDR
// break ;
55745: GO 55749
// end ;
55747: GO 55707
55749: POP
55750: POP
// if not weapon then
55751: LD_VAR 0 8
55755: NOT
55756: IFFALSE 55760
// continue ;
55758: GO 55656
// for k in factories do
55760: LD_ADDR_VAR 0 6
55764: PUSH
55765: LD_VAR 0 2
55769: PUSH
55770: FOR_IN
55771: IFFALSE 55836
// begin weapons := AvailableWeaponList ( k ) ;
55773: LD_ADDR_VAR 0 9
55777: PUSH
55778: LD_VAR 0 6
55782: PPUSH
55783: CALL_OW 478
55787: ST_TO_ADDR
// if not weapons then
55788: LD_VAR 0 9
55792: NOT
55793: IFFALSE 55797
// continue ;
55795: GO 55770
// if weapon in weapons then
55797: LD_VAR 0 8
55801: PUSH
55802: LD_VAR 0 9
55806: IN
55807: IFFALSE 55834
// begin result := [ i , weapon ] ;
55809: LD_ADDR_VAR 0 3
55813: PUSH
55814: LD_VAR 0 4
55818: PUSH
55819: LD_VAR 0 8
55823: PUSH
55824: EMPTY
55825: LIST
55826: LIST
55827: ST_TO_ADDR
// exit ;
55828: POP
55829: POP
55830: POP
55831: POP
55832: GO 55842
// end ; end ;
55834: GO 55770
55836: POP
55837: POP
// end ;
55838: GO 55656
55840: POP
55841: POP
// end ;
55842: LD_VAR 0 3
55846: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
55847: LD_INT 0
55849: PPUSH
// if not side or side > 8 then
55850: LD_VAR 0 3
55854: NOT
55855: PUSH
55856: LD_VAR 0 3
55860: PUSH
55861: LD_INT 8
55863: GREATER
55864: OR
55865: IFFALSE 55869
// exit ;
55867: GO 55928
// if not range then
55869: LD_VAR 0 4
55873: NOT
55874: IFFALSE 55885
// range := - 12 ;
55876: LD_ADDR_VAR 0 4
55880: PUSH
55881: LD_INT 12
55883: NEG
55884: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
55885: LD_VAR 0 1
55889: PPUSH
55890: LD_VAR 0 2
55894: PPUSH
55895: LD_VAR 0 3
55899: PPUSH
55900: LD_VAR 0 4
55904: PPUSH
55905: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
55909: LD_VAR 0 1
55913: PPUSH
55914: LD_VAR 0 2
55918: PPUSH
55919: LD_VAR 0 3
55923: PPUSH
55924: CALL_OW 331
// end ;
55928: LD_VAR 0 5
55932: RET
// export function Video ( mode ) ; begin
55933: LD_INT 0
55935: PPUSH
// ingame_video = mode ;
55936: LD_ADDR_OWVAR 52
55940: PUSH
55941: LD_VAR 0 1
55945: ST_TO_ADDR
// interface_hidden = mode ;
55946: LD_ADDR_OWVAR 54
55950: PUSH
55951: LD_VAR 0 1
55955: ST_TO_ADDR
// end ;
55956: LD_VAR 0 2
55960: RET
// export function Join ( array , element ) ; begin
55961: LD_INT 0
55963: PPUSH
// result := Replace ( array , array + 1 , element ) ;
55964: LD_ADDR_VAR 0 3
55968: PUSH
55969: LD_VAR 0 1
55973: PPUSH
55974: LD_VAR 0 1
55978: PUSH
55979: LD_INT 1
55981: PLUS
55982: PPUSH
55983: LD_VAR 0 2
55987: PPUSH
55988: CALL_OW 1
55992: ST_TO_ADDR
// end ;
55993: LD_VAR 0 3
55997: RET
// export function JoinUnion ( array , element ) ; begin
55998: LD_INT 0
56000: PPUSH
// result := array union element ;
56001: LD_ADDR_VAR 0 3
56005: PUSH
56006: LD_VAR 0 1
56010: PUSH
56011: LD_VAR 0 2
56015: UNION
56016: ST_TO_ADDR
// end ;
56017: LD_VAR 0 3
56021: RET
// export function GetBehemoths ( side ) ; begin
56022: LD_INT 0
56024: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , 25 ] ] ) ;
56025: LD_ADDR_VAR 0 2
56029: PUSH
56030: LD_INT 22
56032: PUSH
56033: LD_VAR 0 1
56037: PUSH
56038: EMPTY
56039: LIST
56040: LIST
56041: PUSH
56042: LD_INT 31
56044: PUSH
56045: LD_INT 25
56047: PUSH
56048: EMPTY
56049: LIST
56050: LIST
56051: PUSH
56052: EMPTY
56053: LIST
56054: LIST
56055: PPUSH
56056: CALL_OW 69
56060: ST_TO_ADDR
// end ;
56061: LD_VAR 0 2
56065: RET
// export function Shuffle ( array ) ; var i , index ; begin
56066: LD_INT 0
56068: PPUSH
56069: PPUSH
56070: PPUSH
// result := [ ] ;
56071: LD_ADDR_VAR 0 2
56075: PUSH
56076: EMPTY
56077: ST_TO_ADDR
// if not array then
56078: LD_VAR 0 1
56082: NOT
56083: IFFALSE 56087
// exit ;
56085: GO 56186
// Randomize ;
56087: CALL_OW 10
// for i = array downto 1 do
56091: LD_ADDR_VAR 0 3
56095: PUSH
56096: DOUBLE
56097: LD_VAR 0 1
56101: INC
56102: ST_TO_ADDR
56103: LD_INT 1
56105: PUSH
56106: FOR_DOWNTO
56107: IFFALSE 56184
// begin index := rand ( 1 , array ) ;
56109: LD_ADDR_VAR 0 4
56113: PUSH
56114: LD_INT 1
56116: PPUSH
56117: LD_VAR 0 1
56121: PPUSH
56122: CALL_OW 12
56126: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
56127: LD_ADDR_VAR 0 2
56131: PUSH
56132: LD_VAR 0 2
56136: PPUSH
56137: LD_VAR 0 2
56141: PUSH
56142: LD_INT 1
56144: PLUS
56145: PPUSH
56146: LD_VAR 0 1
56150: PUSH
56151: LD_VAR 0 4
56155: ARRAY
56156: PPUSH
56157: CALL_OW 2
56161: ST_TO_ADDR
// array := Delete ( array , index ) ;
56162: LD_ADDR_VAR 0 1
56166: PUSH
56167: LD_VAR 0 1
56171: PPUSH
56172: LD_VAR 0 4
56176: PPUSH
56177: CALL_OW 3
56181: ST_TO_ADDR
// end ;
56182: GO 56106
56184: POP
56185: POP
// end ;
56186: LD_VAR 0 2
56190: RET
// export function GetBaseMaterials ( base ) ; begin
56191: LD_INT 0
56193: PPUSH
// result := [ 0 , 0 , 0 ] ;
56194: LD_ADDR_VAR 0 2
56198: PUSH
56199: LD_INT 0
56201: PUSH
56202: LD_INT 0
56204: PUSH
56205: LD_INT 0
56207: PUSH
56208: EMPTY
56209: LIST
56210: LIST
56211: LIST
56212: ST_TO_ADDR
// if not base then
56213: LD_VAR 0 1
56217: NOT
56218: IFFALSE 56222
// exit ;
56220: GO 56271
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
56222: LD_ADDR_VAR 0 2
56226: PUSH
56227: LD_VAR 0 1
56231: PPUSH
56232: LD_INT 1
56234: PPUSH
56235: CALL_OW 275
56239: PUSH
56240: LD_VAR 0 1
56244: PPUSH
56245: LD_INT 2
56247: PPUSH
56248: CALL_OW 275
56252: PUSH
56253: LD_VAR 0 1
56257: PPUSH
56258: LD_INT 3
56260: PPUSH
56261: CALL_OW 275
56265: PUSH
56266: EMPTY
56267: LIST
56268: LIST
56269: LIST
56270: ST_TO_ADDR
// end ;
56271: LD_VAR 0 2
56275: RET
// export function ShrinkArray ( array , size ) ; var i ; begin
56276: LD_INT 0
56278: PPUSH
56279: PPUSH
// result := array ;
56280: LD_ADDR_VAR 0 3
56284: PUSH
56285: LD_VAR 0 1
56289: ST_TO_ADDR
// if size > 0 then
56290: LD_VAR 0 2
56294: PUSH
56295: LD_INT 0
56297: GREATER
56298: IFFALSE 56344
// for i := array downto size do
56300: LD_ADDR_VAR 0 4
56304: PUSH
56305: DOUBLE
56306: LD_VAR 0 1
56310: INC
56311: ST_TO_ADDR
56312: LD_VAR 0 2
56316: PUSH
56317: FOR_DOWNTO
56318: IFFALSE 56342
// result := Delete ( result , result ) ;
56320: LD_ADDR_VAR 0 3
56324: PUSH
56325: LD_VAR 0 3
56329: PPUSH
56330: LD_VAR 0 3
56334: PPUSH
56335: CALL_OW 3
56339: ST_TO_ADDR
56340: GO 56317
56342: POP
56343: POP
// end ;
56344: LD_VAR 0 3
56348: RET
// export function ComExit ( unit ) ; var tmp ; begin
56349: LD_INT 0
56351: PPUSH
56352: PPUSH
// if not IsInUnit ( unit ) then
56353: LD_VAR 0 1
56357: PPUSH
56358: CALL_OW 310
56362: NOT
56363: IFFALSE 56367
// exit ;
56365: GO 56427
// tmp := IsInUnit ( unit ) ;
56367: LD_ADDR_VAR 0 3
56371: PUSH
56372: LD_VAR 0 1
56376: PPUSH
56377: CALL_OW 310
56381: ST_TO_ADDR
// if GetType ( tmp ) = unit_vehicle then
56382: LD_VAR 0 3
56386: PPUSH
56387: CALL_OW 247
56391: PUSH
56392: LD_INT 2
56394: EQUAL
56395: IFFALSE 56408
// ComExitVehicle ( unit ) else
56397: LD_VAR 0 1
56401: PPUSH
56402: CALL_OW 121
56406: GO 56417
// ComExitBuilding ( unit ) ;
56408: LD_VAR 0 1
56412: PPUSH
56413: CALL_OW 122
// result := tmp ;
56417: LD_ADDR_VAR 0 2
56421: PUSH
56422: LD_VAR 0 3
56426: ST_TO_ADDR
// end ;
56427: LD_VAR 0 2
56431: RET
// export function ComExitAll ( units ) ; var i ; begin
56432: LD_INT 0
56434: PPUSH
56435: PPUSH
// if not units then
56436: LD_VAR 0 1
56440: NOT
56441: IFFALSE 56445
// exit ;
56443: GO 56471
// for i in units do
56445: LD_ADDR_VAR 0 3
56449: PUSH
56450: LD_VAR 0 1
56454: PUSH
56455: FOR_IN
56456: IFFALSE 56469
// ComExit ( i ) ;
56458: LD_VAR 0 3
56462: PPUSH
56463: CALL 56349 0 1
56467: GO 56455
56469: POP
56470: POP
// end ;
56471: LD_VAR 0 2
56475: RET
// export function ResetHc ; begin
56476: LD_INT 0
56478: PPUSH
// InitHc ;
56479: CALL_OW 19
// hc_importance := 0 ;
56483: LD_ADDR_OWVAR 32
56487: PUSH
56488: LD_INT 0
56490: ST_TO_ADDR
// end ;
56491: LD_VAR 0 1
56495: RET
// export function PointBetweenXY ( x1 , y1 , x2 , y2 ) ; var _x , _y ; begin
56496: LD_INT 0
56498: PPUSH
56499: PPUSH
56500: PPUSH
// _x := ( x1 + x2 ) div 2 ;
56501: LD_ADDR_VAR 0 6
56505: PUSH
56506: LD_VAR 0 1
56510: PUSH
56511: LD_VAR 0 3
56515: PLUS
56516: PUSH
56517: LD_INT 2
56519: DIV
56520: ST_TO_ADDR
// if _x < 0 then
56521: LD_VAR 0 6
56525: PUSH
56526: LD_INT 0
56528: LESS
56529: IFFALSE 56546
// _x := _x * - 1 ;
56531: LD_ADDR_VAR 0 6
56535: PUSH
56536: LD_VAR 0 6
56540: PUSH
56541: LD_INT 1
56543: NEG
56544: MUL
56545: ST_TO_ADDR
// _y := ( y1 + y2 ) div 2 ;
56546: LD_ADDR_VAR 0 7
56550: PUSH
56551: LD_VAR 0 2
56555: PUSH
56556: LD_VAR 0 4
56560: PLUS
56561: PUSH
56562: LD_INT 2
56564: DIV
56565: ST_TO_ADDR
// if _y < 0 then
56566: LD_VAR 0 7
56570: PUSH
56571: LD_INT 0
56573: LESS
56574: IFFALSE 56591
// _y := _y * - 1 ;
56576: LD_ADDR_VAR 0 7
56580: PUSH
56581: LD_VAR 0 7
56585: PUSH
56586: LD_INT 1
56588: NEG
56589: MUL
56590: ST_TO_ADDR
// result := [ _x , _y ] ;
56591: LD_ADDR_VAR 0 5
56595: PUSH
56596: LD_VAR 0 6
56600: PUSH
56601: LD_VAR 0 7
56605: PUSH
56606: EMPTY
56607: LIST
56608: LIST
56609: ST_TO_ADDR
// end ;
56610: LD_VAR 0 5
56614: RET
// export function NotGoToAreaUnit ( unit , area , goAway ) ; var x , y , task ; begin
56615: LD_INT 0
56617: PPUSH
56618: PPUSH
56619: PPUSH
56620: PPUSH
// task := GetTaskList ( unit ) ;
56621: LD_ADDR_VAR 0 7
56625: PUSH
56626: LD_VAR 0 1
56630: PPUSH
56631: CALL_OW 437
56635: ST_TO_ADDR
// if not task and not IsInArea ( unit , area ) then
56636: LD_VAR 0 7
56640: NOT
56641: PUSH
56642: LD_VAR 0 1
56646: PPUSH
56647: LD_VAR 0 2
56651: PPUSH
56652: CALL_OW 308
56656: NOT
56657: AND
56658: IFFALSE 56662
// exit ;
56660: GO 56780
// if IsInArea ( unit , area ) then
56662: LD_VAR 0 1
56666: PPUSH
56667: LD_VAR 0 2
56671: PPUSH
56672: CALL_OW 308
56676: IFFALSE 56694
// begin ComMoveToArea ( unit , goAway ) ;
56678: LD_VAR 0 1
56682: PPUSH
56683: LD_VAR 0 3
56687: PPUSH
56688: CALL_OW 113
// exit ;
56692: GO 56780
// end ; if task [ 1 ] [ 1 ] <> M then
56694: LD_VAR 0 7
56698: PUSH
56699: LD_INT 1
56701: ARRAY
56702: PUSH
56703: LD_INT 1
56705: ARRAY
56706: PUSH
56707: LD_STRING M
56709: NONEQUAL
56710: IFFALSE 56714
// exit ;
56712: GO 56780
// x := task [ 1 ] [ 2 ] ;
56714: LD_ADDR_VAR 0 5
56718: PUSH
56719: LD_VAR 0 7
56723: PUSH
56724: LD_INT 1
56726: ARRAY
56727: PUSH
56728: LD_INT 2
56730: ARRAY
56731: ST_TO_ADDR
// y := task [ 1 ] [ 3 ] ;
56732: LD_ADDR_VAR 0 6
56736: PUSH
56737: LD_VAR 0 7
56741: PUSH
56742: LD_INT 1
56744: ARRAY
56745: PUSH
56746: LD_INT 3
56748: ARRAY
56749: ST_TO_ADDR
// if InArea ( x , y , area ) then
56750: LD_VAR 0 5
56754: PPUSH
56755: LD_VAR 0 6
56759: PPUSH
56760: LD_VAR 0 2
56764: PPUSH
56765: CALL_OW 309
56769: IFFALSE 56780
// ComStop ( unit ) ;
56771: LD_VAR 0 1
56775: PPUSH
56776: CALL_OW 141
// end ;
56780: LD_VAR 0 4
56784: RET
// export function Abs ( value ) ; begin
56785: LD_INT 0
56787: PPUSH
// result := value ;
56788: LD_ADDR_VAR 0 2
56792: PUSH
56793: LD_VAR 0 1
56797: ST_TO_ADDR
// if value < 0 then
56798: LD_VAR 0 1
56802: PUSH
56803: LD_INT 0
56805: LESS
56806: IFFALSE 56823
// result := value * - 1 ;
56808: LD_ADDR_VAR 0 2
56812: PUSH
56813: LD_VAR 0 1
56817: PUSH
56818: LD_INT 1
56820: NEG
56821: MUL
56822: ST_TO_ADDR
// end ;
56823: LD_VAR 0 2
56827: RET
// export function ComMoveToNearbyEntrance ( unit , building ) ; var x , _x , y , _y , d , r , i ; begin
56828: LD_INT 0
56830: PPUSH
56831: PPUSH
56832: PPUSH
56833: PPUSH
56834: PPUSH
56835: PPUSH
56836: PPUSH
56837: PPUSH
// if not unit or not building then
56838: LD_VAR 0 1
56842: NOT
56843: PUSH
56844: LD_VAR 0 2
56848: NOT
56849: OR
56850: IFFALSE 56854
// exit ;
56852: GO 57080
// x := GetX ( building ) ;
56854: LD_ADDR_VAR 0 4
56858: PUSH
56859: LD_VAR 0 2
56863: PPUSH
56864: CALL_OW 250
56868: ST_TO_ADDR
// y := GetY ( building ) ;
56869: LD_ADDR_VAR 0 6
56873: PUSH
56874: LD_VAR 0 2
56878: PPUSH
56879: CALL_OW 251
56883: ST_TO_ADDR
// d := GetDir ( building ) ;
56884: LD_ADDR_VAR 0 8
56888: PUSH
56889: LD_VAR 0 2
56893: PPUSH
56894: CALL_OW 254
56898: ST_TO_ADDR
// r := 4 ;
56899: LD_ADDR_VAR 0 9
56903: PUSH
56904: LD_INT 4
56906: ST_TO_ADDR
// for i := 1 to 5 do
56907: LD_ADDR_VAR 0 10
56911: PUSH
56912: DOUBLE
56913: LD_INT 1
56915: DEC
56916: ST_TO_ADDR
56917: LD_INT 5
56919: PUSH
56920: FOR_TO
56921: IFFALSE 57078
// begin _x := ShiftX ( x , d , r + i ) ;
56923: LD_ADDR_VAR 0 5
56927: PUSH
56928: LD_VAR 0 4
56932: PPUSH
56933: LD_VAR 0 8
56937: PPUSH
56938: LD_VAR 0 9
56942: PUSH
56943: LD_VAR 0 10
56947: PLUS
56948: PPUSH
56949: CALL_OW 272
56953: ST_TO_ADDR
// _y := ShiftY ( y , d , r + i ) ;
56954: LD_ADDR_VAR 0 7
56958: PUSH
56959: LD_VAR 0 6
56963: PPUSH
56964: LD_VAR 0 8
56968: PPUSH
56969: LD_VAR 0 9
56973: PUSH
56974: LD_VAR 0 10
56978: PLUS
56979: PPUSH
56980: CALL_OW 273
56984: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not GetType ( HexInfo ( _x , _y ) ) in [ unit_building , unit_vehicle ] then
56985: LD_VAR 0 5
56989: PPUSH
56990: LD_VAR 0 7
56994: PPUSH
56995: CALL_OW 488
56999: PUSH
57000: LD_VAR 0 5
57004: PPUSH
57005: LD_VAR 0 7
57009: PPUSH
57010: CALL_OW 428
57014: PPUSH
57015: CALL_OW 247
57019: PUSH
57020: LD_INT 3
57022: PUSH
57023: LD_INT 2
57025: PUSH
57026: EMPTY
57027: LIST
57028: LIST
57029: IN
57030: NOT
57031: AND
57032: IFFALSE 57076
// begin ComMoveXY ( unit , _x , _y ) ;
57034: LD_VAR 0 1
57038: PPUSH
57039: LD_VAR 0 5
57043: PPUSH
57044: LD_VAR 0 7
57048: PPUSH
57049: CALL_OW 111
// result := [ _x , _y ] ;
57053: LD_ADDR_VAR 0 3
57057: PUSH
57058: LD_VAR 0 5
57062: PUSH
57063: LD_VAR 0 7
57067: PUSH
57068: EMPTY
57069: LIST
57070: LIST
57071: ST_TO_ADDR
// exit ;
57072: POP
57073: POP
57074: GO 57080
// end ; end ;
57076: GO 56920
57078: POP
57079: POP
// end ;
57080: LD_VAR 0 3
57084: RET
// export function SideAttackedSide ( side1 , side2 ) ; var i , un ; begin
57085: LD_INT 0
57087: PPUSH
57088: PPUSH
57089: PPUSH
// result := 0 ;
57090: LD_ADDR_VAR 0 3
57094: PUSH
57095: LD_INT 0
57097: ST_TO_ADDR
// if side1 < 0 or side1 > 8 or side2 < 0 or side2 > 8 then
57098: LD_VAR 0 1
57102: PUSH
57103: LD_INT 0
57105: LESS
57106: PUSH
57107: LD_VAR 0 1
57111: PUSH
57112: LD_INT 8
57114: GREATER
57115: OR
57116: PUSH
57117: LD_VAR 0 2
57121: PUSH
57122: LD_INT 0
57124: LESS
57125: OR
57126: PUSH
57127: LD_VAR 0 2
57131: PUSH
57132: LD_INT 8
57134: GREATER
57135: OR
57136: IFFALSE 57140
// exit ;
57138: GO 57215
// for i in FilterAllUnits ( [ f_side , side2 ] ) do
57140: LD_ADDR_VAR 0 4
57144: PUSH
57145: LD_INT 22
57147: PUSH
57148: LD_VAR 0 2
57152: PUSH
57153: EMPTY
57154: LIST
57155: LIST
57156: PPUSH
57157: CALL_OW 69
57161: PUSH
57162: FOR_IN
57163: IFFALSE 57213
// begin un := UnitShoot ( i ) ;
57165: LD_ADDR_VAR 0 5
57169: PUSH
57170: LD_VAR 0 4
57174: PPUSH
57175: CALL_OW 504
57179: ST_TO_ADDR
// if GetSide ( un ) = side1 then
57180: LD_VAR 0 5
57184: PPUSH
57185: CALL_OW 255
57189: PUSH
57190: LD_VAR 0 1
57194: EQUAL
57195: IFFALSE 57211
// begin result := un ;
57197: LD_ADDR_VAR 0 3
57201: PUSH
57202: LD_VAR 0 5
57206: ST_TO_ADDR
// exit ;
57207: POP
57208: POP
57209: GO 57215
// end ; end ;
57211: GO 57162
57213: POP
57214: POP
// end ;
57215: LD_VAR 0 3
57219: RET
// export function GetCargoBay ( units ) ; begin
57220: LD_INT 0
57222: PPUSH
// result := UnitFilter ( units , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ) ;
57223: LD_ADDR_VAR 0 2
57227: PUSH
57228: LD_VAR 0 1
57232: PPUSH
57233: LD_INT 2
57235: PUSH
57236: LD_INT 34
57238: PUSH
57239: LD_INT 12
57241: PUSH
57242: EMPTY
57243: LIST
57244: LIST
57245: PUSH
57246: LD_INT 34
57248: PUSH
57249: LD_INT 51
57251: PUSH
57252: EMPTY
57253: LIST
57254: LIST
57255: PUSH
57256: LD_INT 34
57258: PUSH
57259: LD_INT 32
57261: PUSH
57262: EMPTY
57263: LIST
57264: LIST
57265: PUSH
57266: LD_INT 34
57268: PUSH
57269: LD_EXP 158
57273: PUSH
57274: EMPTY
57275: LIST
57276: LIST
57277: PUSH
57278: EMPTY
57279: LIST
57280: LIST
57281: LIST
57282: LIST
57283: LIST
57284: PPUSH
57285: CALL_OW 72
57289: ST_TO_ADDR
// end ;
57290: LD_VAR 0 2
57294: RET
// export function Negate ( value ) ; begin
57295: LD_INT 0
57297: PPUSH
// result := not value ;
57298: LD_ADDR_VAR 0 2
57302: PUSH
57303: LD_VAR 0 1
57307: NOT
57308: ST_TO_ADDR
// end ;
57309: LD_VAR 0 2
57313: RET
// export function GetDirFromHex ( x1 , y1 , x2 , y2 ) ; begin
57314: LD_INT 0
57316: PPUSH
// if x1 = x2 then
57317: LD_VAR 0 1
57321: PUSH
57322: LD_VAR 0 3
57326: EQUAL
57327: IFFALSE 57361
// begin if y1 > y2 then
57329: LD_VAR 0 2
57333: PUSH
57334: LD_VAR 0 4
57338: GREATER
57339: IFFALSE 57351
// result := 0 else
57341: LD_ADDR_VAR 0 5
57345: PUSH
57346: LD_INT 0
57348: ST_TO_ADDR
57349: GO 57359
// result := 3 ;
57351: LD_ADDR_VAR 0 5
57355: PUSH
57356: LD_INT 3
57358: ST_TO_ADDR
// exit ;
57359: GO 57447
// end ; if y1 = y2 then
57361: LD_VAR 0 2
57365: PUSH
57366: LD_VAR 0 4
57370: EQUAL
57371: IFFALSE 57405
// begin if x1 > x2 then
57373: LD_VAR 0 1
57377: PUSH
57378: LD_VAR 0 3
57382: GREATER
57383: IFFALSE 57395
// result := 1 else
57385: LD_ADDR_VAR 0 5
57389: PUSH
57390: LD_INT 1
57392: ST_TO_ADDR
57393: GO 57403
// result := 4 ;
57395: LD_ADDR_VAR 0 5
57399: PUSH
57400: LD_INT 4
57402: ST_TO_ADDR
// exit ;
57403: GO 57447
// end ; if x1 > x2 and y1 > y2 then
57405: LD_VAR 0 1
57409: PUSH
57410: LD_VAR 0 3
57414: GREATER
57415: PUSH
57416: LD_VAR 0 2
57420: PUSH
57421: LD_VAR 0 4
57425: GREATER
57426: AND
57427: IFFALSE 57439
// result := 2 else
57429: LD_ADDR_VAR 0 5
57433: PUSH
57434: LD_INT 2
57436: ST_TO_ADDR
57437: GO 57447
// result := 5 ;
57439: LD_ADDR_VAR 0 5
57443: PUSH
57444: LD_INT 5
57446: ST_TO_ADDR
// end ;
57447: LD_VAR 0 5
57451: RET
// export function ComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
57452: LD_INT 0
57454: PPUSH
57455: PPUSH
// if not driver or not IsInUnit ( driver ) then
57456: LD_VAR 0 1
57460: NOT
57461: PUSH
57462: LD_VAR 0 1
57466: PPUSH
57467: CALL_OW 310
57471: NOT
57472: OR
57473: IFFALSE 57477
// exit ;
57475: GO 57567
// vehicle := IsInUnit ( driver ) ;
57477: LD_ADDR_VAR 0 3
57481: PUSH
57482: LD_VAR 0 1
57486: PPUSH
57487: CALL_OW 310
57491: ST_TO_ADDR
// SetTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
57492: LD_VAR 0 1
57496: PPUSH
57497: LD_STRING \
57499: PUSH
57500: LD_INT 0
57502: PUSH
57503: LD_INT 0
57505: PUSH
57506: LD_INT 0
57508: PUSH
57509: LD_INT 0
57511: PUSH
57512: LD_INT 0
57514: PUSH
57515: LD_INT 0
57517: PUSH
57518: EMPTY
57519: LIST
57520: LIST
57521: LIST
57522: LIST
57523: LIST
57524: LIST
57525: LIST
57526: PUSH
57527: LD_STRING E
57529: PUSH
57530: LD_INT 0
57532: PUSH
57533: LD_INT 0
57535: PUSH
57536: LD_VAR 0 3
57540: PUSH
57541: LD_INT 0
57543: PUSH
57544: LD_INT 0
57546: PUSH
57547: LD_INT 0
57549: PUSH
57550: EMPTY
57551: LIST
57552: LIST
57553: LIST
57554: LIST
57555: LIST
57556: LIST
57557: LIST
57558: PUSH
57559: EMPTY
57560: LIST
57561: LIST
57562: PPUSH
57563: CALL_OW 446
// end ;
57567: LD_VAR 0 2
57571: RET
// export function AddComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
57572: LD_INT 0
57574: PPUSH
57575: PPUSH
// if not driver or not IsInUnit ( driver ) then
57576: LD_VAR 0 1
57580: NOT
57581: PUSH
57582: LD_VAR 0 1
57586: PPUSH
57587: CALL_OW 310
57591: NOT
57592: OR
57593: IFFALSE 57597
// exit ;
57595: GO 57687
// vehicle := IsInUnit ( driver ) ;
57597: LD_ADDR_VAR 0 3
57601: PUSH
57602: LD_VAR 0 1
57606: PPUSH
57607: CALL_OW 310
57611: ST_TO_ADDR
// AddTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
57612: LD_VAR 0 1
57616: PPUSH
57617: LD_STRING \
57619: PUSH
57620: LD_INT 0
57622: PUSH
57623: LD_INT 0
57625: PUSH
57626: LD_INT 0
57628: PUSH
57629: LD_INT 0
57631: PUSH
57632: LD_INT 0
57634: PUSH
57635: LD_INT 0
57637: PUSH
57638: EMPTY
57639: LIST
57640: LIST
57641: LIST
57642: LIST
57643: LIST
57644: LIST
57645: LIST
57646: PUSH
57647: LD_STRING E
57649: PUSH
57650: LD_INT 0
57652: PUSH
57653: LD_INT 0
57655: PUSH
57656: LD_VAR 0 3
57660: PUSH
57661: LD_INT 0
57663: PUSH
57664: LD_INT 0
57666: PUSH
57667: LD_INT 0
57669: PUSH
57670: EMPTY
57671: LIST
57672: LIST
57673: LIST
57674: LIST
57675: LIST
57676: LIST
57677: LIST
57678: PUSH
57679: EMPTY
57680: LIST
57681: LIST
57682: PPUSH
57683: CALL_OW 447
// end ;
57687: LD_VAR 0 2
57691: RET
// export function SortByHealth ( units , asc ) ; var i , tmp ; begin
57692: LD_INT 0
57694: PPUSH
57695: PPUSH
57696: PPUSH
// tmp := [ ] ;
57697: LD_ADDR_VAR 0 5
57701: PUSH
57702: EMPTY
57703: ST_TO_ADDR
// for i in units do
57704: LD_ADDR_VAR 0 4
57708: PUSH
57709: LD_VAR 0 1
57713: PUSH
57714: FOR_IN
57715: IFFALSE 57753
// tmp := Insert ( tmp , tmp + 1 , GetLives ( i ) ) ;
57717: LD_ADDR_VAR 0 5
57721: PUSH
57722: LD_VAR 0 5
57726: PPUSH
57727: LD_VAR 0 5
57731: PUSH
57732: LD_INT 1
57734: PLUS
57735: PPUSH
57736: LD_VAR 0 4
57740: PPUSH
57741: CALL_OW 256
57745: PPUSH
57746: CALL_OW 2
57750: ST_TO_ADDR
57751: GO 57714
57753: POP
57754: POP
// if not tmp then
57755: LD_VAR 0 5
57759: NOT
57760: IFFALSE 57764
// exit ;
57762: GO 57812
// if asc then
57764: LD_VAR 0 2
57768: IFFALSE 57792
// result := SortListByListAsc ( units , tmp ) else
57770: LD_ADDR_VAR 0 3
57774: PUSH
57775: LD_VAR 0 1
57779: PPUSH
57780: LD_VAR 0 5
57784: PPUSH
57785: CALL_OW 76
57789: ST_TO_ADDR
57790: GO 57812
// result := SortListByListDesc ( units , tmp ) ;
57792: LD_ADDR_VAR 0 3
57796: PUSH
57797: LD_VAR 0 1
57801: PPUSH
57802: LD_VAR 0 5
57806: PPUSH
57807: CALL_OW 77
57811: ST_TO_ADDR
// end ;
57812: LD_VAR 0 3
57816: RET
// export function WantToRepairVehicle ( mech , vehicle ) ; var task ; begin
57817: LD_INT 0
57819: PPUSH
57820: PPUSH
// task := GetTaskList ( mech ) ;
57821: LD_ADDR_VAR 0 4
57825: PUSH
57826: LD_VAR 0 1
57830: PPUSH
57831: CALL_OW 437
57835: ST_TO_ADDR
// if not task then
57836: LD_VAR 0 4
57840: NOT
57841: IFFALSE 57845
// exit ;
57843: GO 57887
// result := task [ 1 ] [ 1 ] = r and task [ 1 ] [ 4 ] = vehicle ;
57845: LD_ADDR_VAR 0 3
57849: PUSH
57850: LD_VAR 0 4
57854: PUSH
57855: LD_INT 1
57857: ARRAY
57858: PUSH
57859: LD_INT 1
57861: ARRAY
57862: PUSH
57863: LD_STRING r
57865: EQUAL
57866: PUSH
57867: LD_VAR 0 4
57871: PUSH
57872: LD_INT 1
57874: ARRAY
57875: PUSH
57876: LD_INT 4
57878: ARRAY
57879: PUSH
57880: LD_VAR 0 2
57884: EQUAL
57885: AND
57886: ST_TO_ADDR
// end ;
57887: LD_VAR 0 3
57891: RET
// export function PlaceUnitXYD ( unit , x , y , d , mode ) ; begin
57892: LD_INT 0
57894: PPUSH
// SetDir ( unit , d ) ;
57895: LD_VAR 0 1
57899: PPUSH
57900: LD_VAR 0 4
57904: PPUSH
57905: CALL_OW 233
// PlaceUnitXY ( unit , x , y , mode ) ;
57909: LD_VAR 0 1
57913: PPUSH
57914: LD_VAR 0 2
57918: PPUSH
57919: LD_VAR 0 3
57923: PPUSH
57924: LD_VAR 0 5
57928: PPUSH
57929: CALL_OW 48
// end ;
57933: LD_VAR 0 6
57937: RET
// export function ToNaturalNumber ( number ) ; begin
57938: LD_INT 0
57940: PPUSH
// result := number div 1 ;
57941: LD_ADDR_VAR 0 2
57945: PUSH
57946: LD_VAR 0 1
57950: PUSH
57951: LD_INT 1
57953: DIV
57954: ST_TO_ADDR
// if number < 0 then
57955: LD_VAR 0 1
57959: PUSH
57960: LD_INT 0
57962: LESS
57963: IFFALSE 57973
// result := 0 ;
57965: LD_ADDR_VAR 0 2
57969: PUSH
57970: LD_INT 0
57972: ST_TO_ADDR
// end ;
57973: LD_VAR 0 2
57977: RET
// export function SortByClass ( units , class ) ; var un ; begin
57978: LD_INT 0
57980: PPUSH
57981: PPUSH
// if not units or not class then
57982: LD_VAR 0 1
57986: NOT
57987: PUSH
57988: LD_VAR 0 2
57992: NOT
57993: OR
57994: IFFALSE 57998
// exit ;
57996: GO 58093
// result := [ ] ;
57998: LD_ADDR_VAR 0 3
58002: PUSH
58003: EMPTY
58004: ST_TO_ADDR
// for un in units do
58005: LD_ADDR_VAR 0 4
58009: PUSH
58010: LD_VAR 0 1
58014: PUSH
58015: FOR_IN
58016: IFFALSE 58091
// if GetClass ( un ) = class then
58018: LD_VAR 0 4
58022: PPUSH
58023: CALL_OW 257
58027: PUSH
58028: LD_VAR 0 2
58032: EQUAL
58033: IFFALSE 58060
// result := Insert ( result , 1 , un ) else
58035: LD_ADDR_VAR 0 3
58039: PUSH
58040: LD_VAR 0 3
58044: PPUSH
58045: LD_INT 1
58047: PPUSH
58048: LD_VAR 0 4
58052: PPUSH
58053: CALL_OW 2
58057: ST_TO_ADDR
58058: GO 58089
// result := Replace ( result , result + 1 , un ) ;
58060: LD_ADDR_VAR 0 3
58064: PUSH
58065: LD_VAR 0 3
58069: PPUSH
58070: LD_VAR 0 3
58074: PUSH
58075: LD_INT 1
58077: PLUS
58078: PPUSH
58079: LD_VAR 0 4
58083: PPUSH
58084: CALL_OW 1
58088: ST_TO_ADDR
58089: GO 58015
58091: POP
58092: POP
// end ;
58093: LD_VAR 0 3
58097: RET
// export function GetCratesNearbyXY ( x , y , r ) ; var _x , _y , min_y , min_x , max_x , max_y ; begin
58098: LD_INT 0
58100: PPUSH
58101: PPUSH
58102: PPUSH
58103: PPUSH
58104: PPUSH
58105: PPUSH
58106: PPUSH
// result := [ ] ;
58107: LD_ADDR_VAR 0 4
58111: PUSH
58112: EMPTY
58113: ST_TO_ADDR
// if x - r < 0 then
58114: LD_VAR 0 1
58118: PUSH
58119: LD_VAR 0 3
58123: MINUS
58124: PUSH
58125: LD_INT 0
58127: LESS
58128: IFFALSE 58140
// min_x := 0 else
58130: LD_ADDR_VAR 0 8
58134: PUSH
58135: LD_INT 0
58137: ST_TO_ADDR
58138: GO 58156
// min_x := x - r ;
58140: LD_ADDR_VAR 0 8
58144: PUSH
58145: LD_VAR 0 1
58149: PUSH
58150: LD_VAR 0 3
58154: MINUS
58155: ST_TO_ADDR
// if y - r < 0 then
58156: LD_VAR 0 2
58160: PUSH
58161: LD_VAR 0 3
58165: MINUS
58166: PUSH
58167: LD_INT 0
58169: LESS
58170: IFFALSE 58182
// min_y := 0 else
58172: LD_ADDR_VAR 0 7
58176: PUSH
58177: LD_INT 0
58179: ST_TO_ADDR
58180: GO 58198
// min_y := y - r ;
58182: LD_ADDR_VAR 0 7
58186: PUSH
58187: LD_VAR 0 2
58191: PUSH
58192: LD_VAR 0 3
58196: MINUS
58197: ST_TO_ADDR
// max_x := x + r ;
58198: LD_ADDR_VAR 0 9
58202: PUSH
58203: LD_VAR 0 1
58207: PUSH
58208: LD_VAR 0 3
58212: PLUS
58213: ST_TO_ADDR
// max_y := y + r ;
58214: LD_ADDR_VAR 0 10
58218: PUSH
58219: LD_VAR 0 2
58223: PUSH
58224: LD_VAR 0 3
58228: PLUS
58229: ST_TO_ADDR
// for _x = min_x to max_x do
58230: LD_ADDR_VAR 0 5
58234: PUSH
58235: DOUBLE
58236: LD_VAR 0 8
58240: DEC
58241: ST_TO_ADDR
58242: LD_VAR 0 9
58246: PUSH
58247: FOR_TO
58248: IFFALSE 58349
// for _y = min_y to max_y do
58250: LD_ADDR_VAR 0 6
58254: PUSH
58255: DOUBLE
58256: LD_VAR 0 7
58260: DEC
58261: ST_TO_ADDR
58262: LD_VAR 0 10
58266: PUSH
58267: FOR_TO
58268: IFFALSE 58345
// begin if not ValidHex ( _x , _y ) then
58270: LD_VAR 0 5
58274: PPUSH
58275: LD_VAR 0 6
58279: PPUSH
58280: CALL_OW 488
58284: NOT
58285: IFFALSE 58289
// continue ;
58287: GO 58267
// if GetResourceTypeXY ( _x , _y ) then
58289: LD_VAR 0 5
58293: PPUSH
58294: LD_VAR 0 6
58298: PPUSH
58299: CALL_OW 283
58303: IFFALSE 58343
// result := Replace ( result , result + 1 , [ _x , _y ] ) ;
58305: LD_ADDR_VAR 0 4
58309: PUSH
58310: LD_VAR 0 4
58314: PPUSH
58315: LD_VAR 0 4
58319: PUSH
58320: LD_INT 1
58322: PLUS
58323: PPUSH
58324: LD_VAR 0 5
58328: PUSH
58329: LD_VAR 0 6
58333: PUSH
58334: EMPTY
58335: LIST
58336: LIST
58337: PPUSH
58338: CALL_OW 1
58342: ST_TO_ADDR
// end ;
58343: GO 58267
58345: POP
58346: POP
58347: GO 58247
58349: POP
58350: POP
// end ;
58351: LD_VAR 0 4
58355: RET
// export function AgressiveMove ( units , path ) ; var i , enemy , cr , side , tag ; begin
58356: LD_INT 0
58358: PPUSH
58359: PPUSH
58360: PPUSH
58361: PPUSH
58362: PPUSH
58363: PPUSH
// if not units then
58364: LD_VAR 0 1
58368: NOT
58369: IFFALSE 58373
// exit ;
58371: GO 58774
// result := UnitFilter ( units , [ f_ok ] ) ;
58373: LD_ADDR_VAR 0 3
58377: PUSH
58378: LD_VAR 0 1
58382: PPUSH
58383: LD_INT 50
58385: PUSH
58386: EMPTY
58387: LIST
58388: PPUSH
58389: CALL_OW 72
58393: ST_TO_ADDR
// side := GetSide ( units [ 1 ] ) ;
58394: LD_ADDR_VAR 0 7
58398: PUSH
58399: LD_VAR 0 1
58403: PUSH
58404: LD_INT 1
58406: ARRAY
58407: PPUSH
58408: CALL_OW 255
58412: ST_TO_ADDR
// if not result then
58413: LD_VAR 0 3
58417: NOT
58418: IFFALSE 58422
// exit ;
58420: GO 58774
// for i in result do
58422: LD_ADDR_VAR 0 4
58426: PUSH
58427: LD_VAR 0 3
58431: PUSH
58432: FOR_IN
58433: IFFALSE 58772
// begin tag := GetTag ( i ) + 1 ;
58435: LD_ADDR_VAR 0 8
58439: PUSH
58440: LD_VAR 0 4
58444: PPUSH
58445: CALL_OW 110
58449: PUSH
58450: LD_INT 1
58452: PLUS
58453: ST_TO_ADDR
// cr := GetCratesNearbyXY ( GetX ( i ) , GetY ( i ) , 6 ) ;
58454: LD_ADDR_VAR 0 6
58458: PUSH
58459: LD_VAR 0 4
58463: PPUSH
58464: CALL_OW 250
58468: PPUSH
58469: LD_VAR 0 4
58473: PPUSH
58474: CALL_OW 251
58478: PPUSH
58479: LD_INT 6
58481: PPUSH
58482: CALL 58098 0 3
58486: ST_TO_ADDR
// if cr then
58487: LD_VAR 0 6
58491: IFFALSE 58530
// ComAttackPlace ( i , cr [ 1 ] [ 1 ] , cr [ 1 ] [ 2 ] ) else
58493: LD_VAR 0 4
58497: PPUSH
58498: LD_VAR 0 6
58502: PUSH
58503: LD_INT 1
58505: ARRAY
58506: PUSH
58507: LD_INT 1
58509: ARRAY
58510: PPUSH
58511: LD_VAR 0 6
58515: PUSH
58516: LD_INT 1
58518: ARRAY
58519: PUSH
58520: LD_INT 2
58522: ARRAY
58523: PPUSH
58524: CALL_OW 116
58528: GO 58770
// if path > tag then
58530: LD_VAR 0 2
58534: PUSH
58535: LD_VAR 0 8
58539: GREATER
58540: IFFALSE 58718
// begin enemy := FilterAllUnits ( [ [ f_enemy , side ] , [ f_dist , i , 12 ] ] ) ;
58542: LD_ADDR_VAR 0 5
58546: PUSH
58547: LD_INT 81
58549: PUSH
58550: LD_VAR 0 7
58554: PUSH
58555: EMPTY
58556: LIST
58557: LIST
58558: PUSH
58559: LD_INT 91
58561: PUSH
58562: LD_VAR 0 4
58566: PUSH
58567: LD_INT 12
58569: PUSH
58570: EMPTY
58571: LIST
58572: LIST
58573: LIST
58574: PUSH
58575: EMPTY
58576: LIST
58577: LIST
58578: PPUSH
58579: CALL_OW 69
58583: ST_TO_ADDR
// if enemy then
58584: LD_VAR 0 5
58588: IFFALSE 58616
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
58590: LD_VAR 0 4
58594: PPUSH
58595: LD_VAR 0 5
58599: PPUSH
58600: LD_VAR 0 4
58604: PPUSH
58605: CALL_OW 74
58609: PPUSH
58610: CALL_OW 115
58614: GO 58716
// if GetDistUnitXY ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) > 6 then
58616: LD_VAR 0 4
58620: PPUSH
58621: LD_VAR 0 2
58625: PUSH
58626: LD_VAR 0 8
58630: ARRAY
58631: PUSH
58632: LD_INT 1
58634: ARRAY
58635: PPUSH
58636: LD_VAR 0 2
58640: PUSH
58641: LD_VAR 0 8
58645: ARRAY
58646: PUSH
58647: LD_INT 2
58649: ARRAY
58650: PPUSH
58651: CALL_OW 297
58655: PUSH
58656: LD_INT 6
58658: GREATER
58659: IFFALSE 58702
// ComAgressiveMove ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) else
58661: LD_VAR 0 4
58665: PPUSH
58666: LD_VAR 0 2
58670: PUSH
58671: LD_VAR 0 8
58675: ARRAY
58676: PUSH
58677: LD_INT 1
58679: ARRAY
58680: PPUSH
58681: LD_VAR 0 2
58685: PUSH
58686: LD_VAR 0 8
58690: ARRAY
58691: PUSH
58692: LD_INT 2
58694: ARRAY
58695: PPUSH
58696: CALL_OW 114
58700: GO 58716
// SetTag ( i , tag ) ;
58702: LD_VAR 0 4
58706: PPUSH
58707: LD_VAR 0 8
58711: PPUSH
58712: CALL_OW 109
// end else
58716: GO 58770
// begin enemy := FilterAllUnits ( [ f_enemy , side ] ) ;
58718: LD_ADDR_VAR 0 5
58722: PUSH
58723: LD_INT 81
58725: PUSH
58726: LD_VAR 0 7
58730: PUSH
58731: EMPTY
58732: LIST
58733: LIST
58734: PPUSH
58735: CALL_OW 69
58739: ST_TO_ADDR
// if enemy then
58740: LD_VAR 0 5
58744: IFFALSE 58770
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
58746: LD_VAR 0 4
58750: PPUSH
58751: LD_VAR 0 5
58755: PPUSH
58756: LD_VAR 0 4
58760: PPUSH
58761: CALL_OW 74
58765: PPUSH
58766: CALL_OW 115
// end ; end ;
58770: GO 58432
58772: POP
58773: POP
// end ; end_of_file
58774: LD_VAR 0 3
58778: RET
// export function SOS_UnitDestroyed ( un ) ; var i , eff , side ; begin
58779: LD_INT 0
58781: PPUSH
58782: PPUSH
58783: PPUSH
58784: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
58785: LD_VAR 0 1
58789: PPUSH
58790: CALL_OW 264
58794: PUSH
58795: LD_EXP 161
58799: EQUAL
58800: IFFALSE 58872
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
58802: LD_INT 68
58804: PPUSH
58805: LD_VAR 0 1
58809: PPUSH
58810: CALL_OW 255
58814: PPUSH
58815: CALL_OW 321
58819: PUSH
58820: LD_INT 2
58822: EQUAL
58823: IFFALSE 58835
// eff := 70 else
58825: LD_ADDR_VAR 0 4
58829: PUSH
58830: LD_INT 70
58832: ST_TO_ADDR
58833: GO 58843
// eff := 30 ;
58835: LD_ADDR_VAR 0 4
58839: PUSH
58840: LD_INT 30
58842: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
58843: LD_VAR 0 1
58847: PPUSH
58848: CALL_OW 250
58852: PPUSH
58853: LD_VAR 0 1
58857: PPUSH
58858: CALL_OW 251
58862: PPUSH
58863: LD_VAR 0 4
58867: PPUSH
58868: CALL_OW 495
// end ; end ;
58872: LD_VAR 0 2
58876: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
58877: LD_INT 0
58879: PPUSH
// end ;
58880: LD_VAR 0 4
58884: RET
// export function SOS_Command ( cmd ) ; begin
58885: LD_INT 0
58887: PPUSH
// end ;
58888: LD_VAR 0 2
58892: RET
// export function SOS_CommandUnitXY ( cmd , un , target , x , y ) ; begin
58893: LD_INT 0
58895: PPUSH
// end ;
58896: LD_VAR 0 6
58900: RET
// export function SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; begin
58901: LD_INT 0
58903: PPUSH
// if cmd = 250 and GetWeapon ( unit ) = ar_miner then
58904: LD_VAR 0 1
58908: PUSH
58909: LD_INT 250
58911: EQUAL
58912: PUSH
58913: LD_VAR 0 2
58917: PPUSH
58918: CALL_OW 264
58922: PUSH
58923: LD_EXP 164
58927: EQUAL
58928: AND
58929: IFFALSE 58950
// MinerPlaceMine ( unit , x , y ) ;
58931: LD_VAR 0 2
58935: PPUSH
58936: LD_VAR 0 4
58940: PPUSH
58941: LD_VAR 0 5
58945: PPUSH
58946: CALL 61299 0 3
// if cmd = 251 and GetWeapon ( unit ) = ar_miner then
58950: LD_VAR 0 1
58954: PUSH
58955: LD_INT 251
58957: EQUAL
58958: PUSH
58959: LD_VAR 0 2
58963: PPUSH
58964: CALL_OW 264
58968: PUSH
58969: LD_EXP 164
58973: EQUAL
58974: AND
58975: IFFALSE 58996
// MinerDetonateMine ( unit , x , y ) ;
58977: LD_VAR 0 2
58981: PPUSH
58982: LD_VAR 0 4
58986: PPUSH
58987: LD_VAR 0 5
58991: PPUSH
58992: CALL 61576 0 3
// if cmd = 252 and GetWeapon ( unit ) = ar_miner then
58996: LD_VAR 0 1
59000: PUSH
59001: LD_INT 252
59003: EQUAL
59004: PUSH
59005: LD_VAR 0 2
59009: PPUSH
59010: CALL_OW 264
59014: PUSH
59015: LD_EXP 164
59019: EQUAL
59020: AND
59021: IFFALSE 59042
// MinerCreateMinefield ( unit , x , y ) ;
59023: LD_VAR 0 2
59027: PPUSH
59028: LD_VAR 0 4
59032: PPUSH
59033: LD_VAR 0 5
59037: PPUSH
59038: CALL 61993 0 3
// if cmd = 253 and GetClass ( unit ) = class_sniper then
59042: LD_VAR 0 1
59046: PUSH
59047: LD_INT 253
59049: EQUAL
59050: PUSH
59051: LD_VAR 0 2
59055: PPUSH
59056: CALL_OW 257
59060: PUSH
59061: LD_INT 5
59063: EQUAL
59064: AND
59065: IFFALSE 59086
// ComBinocular ( unit , x , y ) ;
59067: LD_VAR 0 2
59071: PPUSH
59072: LD_VAR 0 4
59076: PPUSH
59077: LD_VAR 0 5
59081: PPUSH
59082: CALL 62364 0 3
// if cmd = 254 and GetWeapon ( unit ) = us_hack and GetControl ( selectedUnit ) = control_computer then
59086: LD_VAR 0 1
59090: PUSH
59091: LD_INT 254
59093: EQUAL
59094: PUSH
59095: LD_VAR 0 2
59099: PPUSH
59100: CALL_OW 264
59104: PUSH
59105: LD_EXP 159
59109: EQUAL
59110: AND
59111: PUSH
59112: LD_VAR 0 3
59116: PPUSH
59117: CALL_OW 263
59121: PUSH
59122: LD_INT 3
59124: EQUAL
59125: AND
59126: IFFALSE 59142
// HackDestroyVehicle ( unit , selectedUnit ) ;
59128: LD_VAR 0 2
59132: PPUSH
59133: LD_VAR 0 3
59137: PPUSH
59138: CALL 60659 0 2
// if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
59142: LD_VAR 0 1
59146: PUSH
59147: LD_INT 255
59149: EQUAL
59150: PUSH
59151: LD_VAR 0 2
59155: PPUSH
59156: CALL_OW 264
59160: PUSH
59161: LD_INT 14
59163: PUSH
59164: LD_INT 53
59166: PUSH
59167: EMPTY
59168: LIST
59169: LIST
59170: IN
59171: AND
59172: PUSH
59173: LD_VAR 0 4
59177: PPUSH
59178: LD_VAR 0 5
59182: PPUSH
59183: CALL_OW 488
59187: AND
59188: IFFALSE 59212
// CutTreeXYR ( unit , x , y , 12 ) ;
59190: LD_VAR 0 2
59194: PPUSH
59195: LD_VAR 0 4
59199: PPUSH
59200: LD_VAR 0 5
59204: PPUSH
59205: LD_INT 12
59207: PPUSH
59208: CALL 59225 0 4
// end ;
59212: LD_VAR 0 6
59216: RET
// export initPlantMineScript , plantMineList ; export function ComGroupPlantMineXY ( units , x , y ) ; begin
59217: LD_INT 0
59219: PPUSH
// end ;
59220: LD_VAR 0 4
59224: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
59225: LD_INT 0
59227: PPUSH
59228: PPUSH
59229: PPUSH
59230: PPUSH
59231: PPUSH
59232: PPUSH
59233: PPUSH
59234: PPUSH
59235: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
59236: LD_VAR 0 1
59240: NOT
59241: PUSH
59242: LD_VAR 0 2
59246: PPUSH
59247: LD_VAR 0 3
59251: PPUSH
59252: CALL_OW 488
59256: NOT
59257: OR
59258: PUSH
59259: LD_VAR 0 4
59263: NOT
59264: OR
59265: IFFALSE 59269
// exit ;
59267: GO 59609
// list := [ ] ;
59269: LD_ADDR_VAR 0 13
59273: PUSH
59274: EMPTY
59275: ST_TO_ADDR
// if x - r < 0 then
59276: LD_VAR 0 2
59280: PUSH
59281: LD_VAR 0 4
59285: MINUS
59286: PUSH
59287: LD_INT 0
59289: LESS
59290: IFFALSE 59302
// min_x := 0 else
59292: LD_ADDR_VAR 0 7
59296: PUSH
59297: LD_INT 0
59299: ST_TO_ADDR
59300: GO 59318
// min_x := x - r ;
59302: LD_ADDR_VAR 0 7
59306: PUSH
59307: LD_VAR 0 2
59311: PUSH
59312: LD_VAR 0 4
59316: MINUS
59317: ST_TO_ADDR
// if y - r < 0 then
59318: LD_VAR 0 3
59322: PUSH
59323: LD_VAR 0 4
59327: MINUS
59328: PUSH
59329: LD_INT 0
59331: LESS
59332: IFFALSE 59344
// min_y := 0 else
59334: LD_ADDR_VAR 0 8
59338: PUSH
59339: LD_INT 0
59341: ST_TO_ADDR
59342: GO 59360
// min_y := y - r ;
59344: LD_ADDR_VAR 0 8
59348: PUSH
59349: LD_VAR 0 3
59353: PUSH
59354: LD_VAR 0 4
59358: MINUS
59359: ST_TO_ADDR
// max_x := x + r ;
59360: LD_ADDR_VAR 0 9
59364: PUSH
59365: LD_VAR 0 2
59369: PUSH
59370: LD_VAR 0 4
59374: PLUS
59375: ST_TO_ADDR
// max_y := y + r ;
59376: LD_ADDR_VAR 0 10
59380: PUSH
59381: LD_VAR 0 3
59385: PUSH
59386: LD_VAR 0 4
59390: PLUS
59391: ST_TO_ADDR
// for _x = min_x to max_x do
59392: LD_ADDR_VAR 0 11
59396: PUSH
59397: DOUBLE
59398: LD_VAR 0 7
59402: DEC
59403: ST_TO_ADDR
59404: LD_VAR 0 9
59408: PUSH
59409: FOR_TO
59410: IFFALSE 59527
// for _y = min_y to max_y do
59412: LD_ADDR_VAR 0 12
59416: PUSH
59417: DOUBLE
59418: LD_VAR 0 8
59422: DEC
59423: ST_TO_ADDR
59424: LD_VAR 0 10
59428: PUSH
59429: FOR_TO
59430: IFFALSE 59523
// begin if not ValidHex ( _x , _y ) then
59432: LD_VAR 0 11
59436: PPUSH
59437: LD_VAR 0 12
59441: PPUSH
59442: CALL_OW 488
59446: NOT
59447: IFFALSE 59451
// continue ;
59449: GO 59429
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
59451: LD_VAR 0 11
59455: PPUSH
59456: LD_VAR 0 12
59460: PPUSH
59461: CALL_OW 351
59465: PUSH
59466: LD_VAR 0 11
59470: PPUSH
59471: LD_VAR 0 12
59475: PPUSH
59476: CALL_OW 554
59480: AND
59481: IFFALSE 59521
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
59483: LD_ADDR_VAR 0 13
59487: PUSH
59488: LD_VAR 0 13
59492: PPUSH
59493: LD_VAR 0 13
59497: PUSH
59498: LD_INT 1
59500: PLUS
59501: PPUSH
59502: LD_VAR 0 11
59506: PUSH
59507: LD_VAR 0 12
59511: PUSH
59512: EMPTY
59513: LIST
59514: LIST
59515: PPUSH
59516: CALL_OW 2
59520: ST_TO_ADDR
// end ;
59521: GO 59429
59523: POP
59524: POP
59525: GO 59409
59527: POP
59528: POP
// if not list then
59529: LD_VAR 0 13
59533: NOT
59534: IFFALSE 59538
// exit ;
59536: GO 59609
// for i in list do
59538: LD_ADDR_VAR 0 6
59542: PUSH
59543: LD_VAR 0 13
59547: PUSH
59548: FOR_IN
59549: IFFALSE 59607
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
59551: LD_VAR 0 1
59555: PPUSH
59556: LD_STRING M
59558: PUSH
59559: LD_VAR 0 6
59563: PUSH
59564: LD_INT 1
59566: ARRAY
59567: PUSH
59568: LD_VAR 0 6
59572: PUSH
59573: LD_INT 2
59575: ARRAY
59576: PUSH
59577: LD_INT 0
59579: PUSH
59580: LD_INT 0
59582: PUSH
59583: LD_INT 0
59585: PUSH
59586: LD_INT 0
59588: PUSH
59589: EMPTY
59590: LIST
59591: LIST
59592: LIST
59593: LIST
59594: LIST
59595: LIST
59596: LIST
59597: PUSH
59598: EMPTY
59599: LIST
59600: PPUSH
59601: CALL_OW 447
59605: GO 59548
59607: POP
59608: POP
// end ;
59609: LD_VAR 0 5
59613: RET
// export initHack , hackTanks , hackTanksCaptured , hackLimit , hackDist , hackCounter ; every 0 0$1 trigger not initHack do
59614: LD_EXP 89
59618: NOT
59619: IFFALSE 59669
59621: GO 59623
59623: DISABLE
// begin initHack := true ;
59624: LD_ADDR_EXP 89
59628: PUSH
59629: LD_INT 1
59631: ST_TO_ADDR
// hackTanks := [ ] ;
59632: LD_ADDR_EXP 90
59636: PUSH
59637: EMPTY
59638: ST_TO_ADDR
// hackTanksCaptured := [ ] ;
59639: LD_ADDR_EXP 91
59643: PUSH
59644: EMPTY
59645: ST_TO_ADDR
// hackLimit := 3 ;
59646: LD_ADDR_EXP 92
59650: PUSH
59651: LD_INT 3
59653: ST_TO_ADDR
// hackDist := 12 ;
59654: LD_ADDR_EXP 93
59658: PUSH
59659: LD_INT 12
59661: ST_TO_ADDR
// hackCounter := [ ] ;
59662: LD_ADDR_EXP 94
59666: PUSH
59667: EMPTY
59668: ST_TO_ADDR
// end ;
59669: END
// every 0 0$1 trigger initHack and FilterAllUnits ( [ f_weapon , us_hack ] ) do var i , tmp ;
59670: LD_EXP 89
59674: PUSH
59675: LD_INT 34
59677: PUSH
59678: LD_EXP 159
59682: PUSH
59683: EMPTY
59684: LIST
59685: LIST
59686: PPUSH
59687: CALL_OW 69
59691: AND
59692: IFFALSE 59947
59694: GO 59696
59696: DISABLE
59697: LD_INT 0
59699: PPUSH
59700: PPUSH
// begin enable ;
59701: ENABLE
// for i in FilterAllUnits ( [ f_weapon , us_hack ] ) do
59702: LD_ADDR_VAR 0 1
59706: PUSH
59707: LD_INT 34
59709: PUSH
59710: LD_EXP 159
59714: PUSH
59715: EMPTY
59716: LIST
59717: LIST
59718: PPUSH
59719: CALL_OW 69
59723: PUSH
59724: FOR_IN
59725: IFFALSE 59945
// begin if not i in hackTanks then
59727: LD_VAR 0 1
59731: PUSH
59732: LD_EXP 90
59736: IN
59737: NOT
59738: IFFALSE 59821
// begin hackTanks := Replace ( hackTanks , hackTanks + 1 , i ) ;
59740: LD_ADDR_EXP 90
59744: PUSH
59745: LD_EXP 90
59749: PPUSH
59750: LD_EXP 90
59754: PUSH
59755: LD_INT 1
59757: PLUS
59758: PPUSH
59759: LD_VAR 0 1
59763: PPUSH
59764: CALL_OW 1
59768: ST_TO_ADDR
// hackTanksCaptured := Replace ( hackTanksCaptured , hackTanksCaptured + 1 , [ ] ) ;
59769: LD_ADDR_EXP 91
59773: PUSH
59774: LD_EXP 91
59778: PPUSH
59779: LD_EXP 91
59783: PUSH
59784: LD_INT 1
59786: PLUS
59787: PPUSH
59788: EMPTY
59789: PPUSH
59790: CALL_OW 1
59794: ST_TO_ADDR
// hackCounter := Replace ( hackCounter , hackCounter + 1 , [ ] ) ;
59795: LD_ADDR_EXP 94
59799: PUSH
59800: LD_EXP 94
59804: PPUSH
59805: LD_EXP 94
59809: PUSH
59810: LD_INT 1
59812: PLUS
59813: PPUSH
59814: EMPTY
59815: PPUSH
59816: CALL_OW 1
59820: ST_TO_ADDR
// end ; if not IsOk ( i ) then
59821: LD_VAR 0 1
59825: PPUSH
59826: CALL_OW 302
59830: NOT
59831: IFFALSE 59844
// begin HackUnlinkAll ( i ) ;
59833: LD_VAR 0 1
59837: PPUSH
59838: CALL 59950 0 1
// continue ;
59842: GO 59724
// end ; HackCheckCapturedStatus ( i ) ;
59844: LD_VAR 0 1
59848: PPUSH
59849: CALL 60393 0 1
// tmp := FilterAllUnits ( [ [ f_enemy , GetSide ( i ) ] , [ f_control , control_computer ] , [ f_dist , i , hackDist ] , [ f_ok ] ] ) ;
59853: LD_ADDR_VAR 0 2
59857: PUSH
59858: LD_INT 81
59860: PUSH
59861: LD_VAR 0 1
59865: PPUSH
59866: CALL_OW 255
59870: PUSH
59871: EMPTY
59872: LIST
59873: LIST
59874: PUSH
59875: LD_INT 33
59877: PUSH
59878: LD_INT 3
59880: PUSH
59881: EMPTY
59882: LIST
59883: LIST
59884: PUSH
59885: LD_INT 91
59887: PUSH
59888: LD_VAR 0 1
59892: PUSH
59893: LD_EXP 93
59897: PUSH
59898: EMPTY
59899: LIST
59900: LIST
59901: LIST
59902: PUSH
59903: LD_INT 50
59905: PUSH
59906: EMPTY
59907: LIST
59908: PUSH
59909: EMPTY
59910: LIST
59911: LIST
59912: LIST
59913: LIST
59914: PPUSH
59915: CALL_OW 69
59919: ST_TO_ADDR
// if not tmp then
59920: LD_VAR 0 2
59924: NOT
59925: IFFALSE 59929
// continue ;
59927: GO 59724
// HackLink ( i , tmp ) ;
59929: LD_VAR 0 1
59933: PPUSH
59934: LD_VAR 0 2
59938: PPUSH
59939: CALL 60086 0 2
// end ;
59943: GO 59724
59945: POP
59946: POP
// end ;
59947: PPOPN 2
59949: END
// function HackUnlinkAll ( hack ) ; var i , index ; begin
59950: LD_INT 0
59952: PPUSH
59953: PPUSH
59954: PPUSH
// if not hack in hackTanks then
59955: LD_VAR 0 1
59959: PUSH
59960: LD_EXP 90
59964: IN
59965: NOT
59966: IFFALSE 59970
// exit ;
59968: GO 60081
// index := GetElementIndex ( hackTanks , hack ) ;
59970: LD_ADDR_VAR 0 4
59974: PUSH
59975: LD_EXP 90
59979: PPUSH
59980: LD_VAR 0 1
59984: PPUSH
59985: CALL 23995 0 2
59989: ST_TO_ADDR
// if hackTanksCaptured [ index ] then
59990: LD_EXP 91
59994: PUSH
59995: LD_VAR 0 4
59999: ARRAY
60000: IFFALSE 60081
// begin for i in hackTanksCaptured [ index ] do
60002: LD_ADDR_VAR 0 3
60006: PUSH
60007: LD_EXP 91
60011: PUSH
60012: LD_VAR 0 4
60016: ARRAY
60017: PUSH
60018: FOR_IN
60019: IFFALSE 60045
// SetSide ( i [ 1 ] , i [ 2 ] ) ;
60021: LD_VAR 0 3
60025: PUSH
60026: LD_INT 1
60028: ARRAY
60029: PPUSH
60030: LD_VAR 0 3
60034: PUSH
60035: LD_INT 2
60037: ARRAY
60038: PPUSH
60039: CALL_OW 235
60043: GO 60018
60045: POP
60046: POP
// hackTanksCaptured := Replace ( hackTanksCaptured , index , [ ] ) ;
60047: LD_ADDR_EXP 91
60051: PUSH
60052: LD_EXP 91
60056: PPUSH
60057: LD_VAR 0 4
60061: PPUSH
60062: EMPTY
60063: PPUSH
60064: CALL_OW 1
60068: ST_TO_ADDR
// SetUnitDisplayNumber ( hack , 0 ) ;
60069: LD_VAR 0 1
60073: PPUSH
60074: LD_INT 0
60076: PPUSH
60077: CALL_OW 505
// end ; end ;
60081: LD_VAR 0 2
60085: RET
// function HackLink ( hack , vehicles ) ; var i , index ; begin
60086: LD_INT 0
60088: PPUSH
60089: PPUSH
60090: PPUSH
// if not hack in hackTanks or not vehicles then
60091: LD_VAR 0 1
60095: PUSH
60096: LD_EXP 90
60100: IN
60101: NOT
60102: PUSH
60103: LD_VAR 0 2
60107: NOT
60108: OR
60109: IFFALSE 60113
// exit ;
60111: GO 60388
// vehicles := SortByDistanceUnit ( hack , vehicles , true , true ) ;
60113: LD_ADDR_VAR 0 2
60117: PUSH
60118: LD_VAR 0 1
60122: PPUSH
60123: LD_VAR 0 2
60127: PPUSH
60128: LD_INT 1
60130: PPUSH
60131: LD_INT 1
60133: PPUSH
60134: CALL 24645 0 4
60138: ST_TO_ADDR
// index := GetElementIndex ( hackTanks , hack ) ;
60139: LD_ADDR_VAR 0 5
60143: PUSH
60144: LD_EXP 90
60148: PPUSH
60149: LD_VAR 0 1
60153: PPUSH
60154: CALL 23995 0 2
60158: ST_TO_ADDR
// if hackTanksCaptured [ index ] < hackLimit then
60159: LD_EXP 91
60163: PUSH
60164: LD_VAR 0 5
60168: ARRAY
60169: PUSH
60170: LD_EXP 92
60174: LESS
60175: IFFALSE 60364
// begin for i := 1 to vehicles do
60177: LD_ADDR_VAR 0 4
60181: PUSH
60182: DOUBLE
60183: LD_INT 1
60185: DEC
60186: ST_TO_ADDR
60187: LD_VAR 0 2
60191: PUSH
60192: FOR_TO
60193: IFFALSE 60362
// begin if hackTanksCaptured [ index ] = hackLimit then
60195: LD_EXP 91
60199: PUSH
60200: LD_VAR 0 5
60204: ARRAY
60205: PUSH
60206: LD_EXP 92
60210: EQUAL
60211: IFFALSE 60215
// break ;
60213: GO 60362
// hackCounter := Replace ( hackCounter , index , hackCounter [ index ] + 1 ) ;
60215: LD_ADDR_EXP 94
60219: PUSH
60220: LD_EXP 94
60224: PPUSH
60225: LD_VAR 0 5
60229: PPUSH
60230: LD_EXP 94
60234: PUSH
60235: LD_VAR 0 5
60239: ARRAY
60240: PUSH
60241: LD_INT 1
60243: PLUS
60244: PPUSH
60245: CALL_OW 1
60249: ST_TO_ADDR
// hackTanksCaptured := ReplaceIn ( hackTanksCaptured , [ index , hackTanksCaptured [ index ] + 1 ] , [ vehicles [ i ] , GetSide ( vehicles [ i ] ) ] ) ;
60250: LD_ADDR_EXP 91
60254: PUSH
60255: LD_EXP 91
60259: PPUSH
60260: LD_VAR 0 5
60264: PUSH
60265: LD_EXP 91
60269: PUSH
60270: LD_VAR 0 5
60274: ARRAY
60275: PUSH
60276: LD_INT 1
60278: PLUS
60279: PUSH
60280: EMPTY
60281: LIST
60282: LIST
60283: PPUSH
60284: LD_VAR 0 2
60288: PUSH
60289: LD_VAR 0 4
60293: ARRAY
60294: PUSH
60295: LD_VAR 0 2
60299: PUSH
60300: LD_VAR 0 4
60304: ARRAY
60305: PPUSH
60306: CALL_OW 255
60310: PUSH
60311: EMPTY
60312: LIST
60313: LIST
60314: PPUSH
60315: CALL 24210 0 3
60319: ST_TO_ADDR
// SetSide ( vehicles [ i ] , GetSide ( hack ) ) ;
60320: LD_VAR 0 2
60324: PUSH
60325: LD_VAR 0 4
60329: ARRAY
60330: PPUSH
60331: LD_VAR 0 1
60335: PPUSH
60336: CALL_OW 255
60340: PPUSH
60341: CALL_OW 235
// ComStop ( vehicles [ i ] ) ;
60345: LD_VAR 0 2
60349: PUSH
60350: LD_VAR 0 4
60354: ARRAY
60355: PPUSH
60356: CALL_OW 141
// end ;
60360: GO 60192
60362: POP
60363: POP
// end ; SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
60364: LD_VAR 0 1
60368: PPUSH
60369: LD_EXP 91
60373: PUSH
60374: LD_VAR 0 5
60378: ARRAY
60379: PUSH
60380: LD_INT 0
60382: PLUS
60383: PPUSH
60384: CALL_OW 505
// end ;
60388: LD_VAR 0 3
60392: RET
// function HackCheckCapturedStatus ( hack ) ; var i , index , tmp ; begin
60393: LD_INT 0
60395: PPUSH
60396: PPUSH
60397: PPUSH
60398: PPUSH
// if not hack in hackTanks then
60399: LD_VAR 0 1
60403: PUSH
60404: LD_EXP 90
60408: IN
60409: NOT
60410: IFFALSE 60414
// exit ;
60412: GO 60654
// index := GetElementIndex ( hackTanks , hack ) ;
60414: LD_ADDR_VAR 0 4
60418: PUSH
60419: LD_EXP 90
60423: PPUSH
60424: LD_VAR 0 1
60428: PPUSH
60429: CALL 23995 0 2
60433: ST_TO_ADDR
// for i := hackTanksCaptured [ index ] downto 1 do
60434: LD_ADDR_VAR 0 3
60438: PUSH
60439: DOUBLE
60440: LD_EXP 91
60444: PUSH
60445: LD_VAR 0 4
60449: ARRAY
60450: INC
60451: ST_TO_ADDR
60452: LD_INT 1
60454: PUSH
60455: FOR_DOWNTO
60456: IFFALSE 60628
// begin tmp := hackTanksCaptured [ index ] [ i ] ;
60458: LD_ADDR_VAR 0 5
60462: PUSH
60463: LD_EXP 91
60467: PUSH
60468: LD_VAR 0 4
60472: ARRAY
60473: PUSH
60474: LD_VAR 0 3
60478: ARRAY
60479: ST_TO_ADDR
// if not IsOk ( tmp [ 1 ] ) or GetSide ( tmp [ 1 ] ) <> GetSide ( hack ) then
60480: LD_VAR 0 5
60484: PUSH
60485: LD_INT 1
60487: ARRAY
60488: PPUSH
60489: CALL_OW 302
60493: NOT
60494: PUSH
60495: LD_VAR 0 5
60499: PUSH
60500: LD_INT 1
60502: ARRAY
60503: PPUSH
60504: CALL_OW 255
60508: PUSH
60509: LD_VAR 0 1
60513: PPUSH
60514: CALL_OW 255
60518: NONEQUAL
60519: OR
60520: IFFALSE 60626
// begin if IsPlaced ( tmp [ 1 ] ) and GetSide ( tmp [ 1 ] ) = GetSide ( hack ) then
60522: LD_VAR 0 5
60526: PUSH
60527: LD_INT 1
60529: ARRAY
60530: PPUSH
60531: CALL_OW 305
60535: PUSH
60536: LD_VAR 0 5
60540: PUSH
60541: LD_INT 1
60543: ARRAY
60544: PPUSH
60545: CALL_OW 255
60549: PUSH
60550: LD_VAR 0 1
60554: PPUSH
60555: CALL_OW 255
60559: EQUAL
60560: AND
60561: IFFALSE 60585
// SetSide ( tmp [ 1 ] , tmp [ 2 ] ) ;
60563: LD_VAR 0 5
60567: PUSH
60568: LD_INT 1
60570: ARRAY
60571: PPUSH
60572: LD_VAR 0 5
60576: PUSH
60577: LD_INT 2
60579: ARRAY
60580: PPUSH
60581: CALL_OW 235
// hackTanksCaptured := Replace ( hackTanksCaptured , index , Delete ( hackTanksCaptured [ index ] , i ) ) ;
60585: LD_ADDR_EXP 91
60589: PUSH
60590: LD_EXP 91
60594: PPUSH
60595: LD_VAR 0 4
60599: PPUSH
60600: LD_EXP 91
60604: PUSH
60605: LD_VAR 0 4
60609: ARRAY
60610: PPUSH
60611: LD_VAR 0 3
60615: PPUSH
60616: CALL_OW 3
60620: PPUSH
60621: CALL_OW 1
60625: ST_TO_ADDR
// end ; end ;
60626: GO 60455
60628: POP
60629: POP
// SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
60630: LD_VAR 0 1
60634: PPUSH
60635: LD_EXP 91
60639: PUSH
60640: LD_VAR 0 4
60644: ARRAY
60645: PUSH
60646: LD_INT 0
60648: PLUS
60649: PPUSH
60650: CALL_OW 505
// end ;
60654: LD_VAR 0 2
60658: RET
// export function HackDestroyVehicle ( hack , vehicle ) ; var i , index , tmp ; begin
60659: LD_INT 0
60661: PPUSH
60662: PPUSH
60663: PPUSH
60664: PPUSH
// if not hack in hackTanks then
60665: LD_VAR 0 1
60669: PUSH
60670: LD_EXP 90
60674: IN
60675: NOT
60676: IFFALSE 60680
// exit ;
60678: GO 60765
// index := GetElementIndex ( hackTanks , hack ) ;
60680: LD_ADDR_VAR 0 5
60684: PUSH
60685: LD_EXP 90
60689: PPUSH
60690: LD_VAR 0 1
60694: PPUSH
60695: CALL 23995 0 2
60699: ST_TO_ADDR
// for i := 1 to hackTanksCaptured [ index ] do
60700: LD_ADDR_VAR 0 4
60704: PUSH
60705: DOUBLE
60706: LD_INT 1
60708: DEC
60709: ST_TO_ADDR
60710: LD_EXP 91
60714: PUSH
60715: LD_VAR 0 5
60719: ARRAY
60720: PUSH
60721: FOR_TO
60722: IFFALSE 60763
// if hackTanksCaptured [ index ] [ i ] [ 1 ] = vehicle then
60724: LD_EXP 91
60728: PUSH
60729: LD_VAR 0 5
60733: ARRAY
60734: PUSH
60735: LD_VAR 0 4
60739: ARRAY
60740: PUSH
60741: LD_INT 1
60743: ARRAY
60744: PUSH
60745: LD_VAR 0 2
60749: EQUAL
60750: IFFALSE 60761
// KillUnit ( vehicle ) ;
60752: LD_VAR 0 2
60756: PPUSH
60757: CALL_OW 66
60761: GO 60721
60763: POP
60764: POP
// end ;
60765: LD_VAR 0 3
60769: RET
// export initMiner , minersList , minerMinesList , minesLimitPerVehicle ; every 0 0$1 trigger not initMiner do
60770: LD_EXP 95
60774: NOT
60775: IFFALSE 60810
60777: GO 60779
60779: DISABLE
// begin initMiner := true ;
60780: LD_ADDR_EXP 95
60784: PUSH
60785: LD_INT 1
60787: ST_TO_ADDR
// minersList := [ ] ;
60788: LD_ADDR_EXP 96
60792: PUSH
60793: EMPTY
60794: ST_TO_ADDR
// minerMinesList := [ ] ;
60795: LD_ADDR_EXP 97
60799: PUSH
60800: EMPTY
60801: ST_TO_ADDR
// minesLimitPerVehicle := 5 ;
60802: LD_ADDR_EXP 98
60806: PUSH
60807: LD_INT 5
60809: ST_TO_ADDR
// end ;
60810: END
// every 0 0$1 trigger initMiner and FilterAllUnits ( [ f_weapon , ar_miner ] ) do var i , j , side , tmp ;
60811: LD_EXP 95
60815: PUSH
60816: LD_INT 34
60818: PUSH
60819: LD_EXP 164
60823: PUSH
60824: EMPTY
60825: LIST
60826: LIST
60827: PPUSH
60828: CALL_OW 69
60832: AND
60833: IFFALSE 61296
60835: GO 60837
60837: DISABLE
60838: LD_INT 0
60840: PPUSH
60841: PPUSH
60842: PPUSH
60843: PPUSH
// begin enable ;
60844: ENABLE
// for i in FilterAllUnits ( [ f_weapon , ar_miner ] ) do
60845: LD_ADDR_VAR 0 1
60849: PUSH
60850: LD_INT 34
60852: PUSH
60853: LD_EXP 164
60857: PUSH
60858: EMPTY
60859: LIST
60860: LIST
60861: PPUSH
60862: CALL_OW 69
60866: PUSH
60867: FOR_IN
60868: IFFALSE 60940
// begin if not i in minersList then
60870: LD_VAR 0 1
60874: PUSH
60875: LD_EXP 96
60879: IN
60880: NOT
60881: IFFALSE 60938
// begin minersList := Replace ( minersList , minersList + 1 , i ) ;
60883: LD_ADDR_EXP 96
60887: PUSH
60888: LD_EXP 96
60892: PPUSH
60893: LD_EXP 96
60897: PUSH
60898: LD_INT 1
60900: PLUS
60901: PPUSH
60902: LD_VAR 0 1
60906: PPUSH
60907: CALL_OW 1
60911: ST_TO_ADDR
// minerMinesList := Replace ( minerMinesList , minerMinesList + 1 , [ ] ) ;
60912: LD_ADDR_EXP 97
60916: PUSH
60917: LD_EXP 97
60921: PPUSH
60922: LD_EXP 97
60926: PUSH
60927: LD_INT 1
60929: PLUS
60930: PPUSH
60931: EMPTY
60932: PPUSH
60933: CALL_OW 1
60937: ST_TO_ADDR
// end end ;
60938: GO 60867
60940: POP
60941: POP
// for i := minerMinesList downto 1 do
60942: LD_ADDR_VAR 0 1
60946: PUSH
60947: DOUBLE
60948: LD_EXP 97
60952: INC
60953: ST_TO_ADDR
60954: LD_INT 1
60956: PUSH
60957: FOR_DOWNTO
60958: IFFALSE 61294
// begin if IsLive ( minersList [ i ] ) then
60960: LD_EXP 96
60964: PUSH
60965: LD_VAR 0 1
60969: ARRAY
60970: PPUSH
60971: CALL_OW 300
60975: IFFALSE 61003
// SetUnitDisplayNumber ( minersList [ i ] , minerMinesList [ i ] ) ;
60977: LD_EXP 96
60981: PUSH
60982: LD_VAR 0 1
60986: ARRAY
60987: PPUSH
60988: LD_EXP 97
60992: PUSH
60993: LD_VAR 0 1
60997: ARRAY
60998: PPUSH
60999: CALL_OW 505
// if not minerMinesList [ i ] then
61003: LD_EXP 97
61007: PUSH
61008: LD_VAR 0 1
61012: ARRAY
61013: NOT
61014: IFFALSE 61018
// continue ;
61016: GO 60957
// for j := minerMinesList [ i ] downto 1 do
61018: LD_ADDR_VAR 0 2
61022: PUSH
61023: DOUBLE
61024: LD_EXP 97
61028: PUSH
61029: LD_VAR 0 1
61033: ARRAY
61034: INC
61035: ST_TO_ADDR
61036: LD_INT 1
61038: PUSH
61039: FOR_DOWNTO
61040: IFFALSE 61290
// begin side := GetSide ( minersList [ i ] ) ;
61042: LD_ADDR_VAR 0 3
61046: PUSH
61047: LD_EXP 96
61051: PUSH
61052: LD_VAR 0 1
61056: ARRAY
61057: PPUSH
61058: CALL_OW 255
61062: ST_TO_ADDR
// tmp := HexInfo ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) ;
61063: LD_ADDR_VAR 0 4
61067: PUSH
61068: LD_EXP 97
61072: PUSH
61073: LD_VAR 0 1
61077: ARRAY
61078: PUSH
61079: LD_VAR 0 2
61083: ARRAY
61084: PUSH
61085: LD_INT 1
61087: ARRAY
61088: PPUSH
61089: LD_EXP 97
61093: PUSH
61094: LD_VAR 0 1
61098: ARRAY
61099: PUSH
61100: LD_VAR 0 2
61104: ARRAY
61105: PUSH
61106: LD_INT 2
61108: ARRAY
61109: PPUSH
61110: CALL_OW 428
61114: ST_TO_ADDR
// if not tmp then
61115: LD_VAR 0 4
61119: NOT
61120: IFFALSE 61124
// continue ;
61122: GO 61039
// if tmp in FilterAllUnits ( [ f_enemy , side ] ) and MineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) then
61124: LD_VAR 0 4
61128: PUSH
61129: LD_INT 81
61131: PUSH
61132: LD_VAR 0 3
61136: PUSH
61137: EMPTY
61138: LIST
61139: LIST
61140: PPUSH
61141: CALL_OW 69
61145: IN
61146: PUSH
61147: LD_EXP 97
61151: PUSH
61152: LD_VAR 0 1
61156: ARRAY
61157: PUSH
61158: LD_VAR 0 2
61162: ARRAY
61163: PUSH
61164: LD_INT 1
61166: ARRAY
61167: PPUSH
61168: LD_EXP 97
61172: PUSH
61173: LD_VAR 0 1
61177: ARRAY
61178: PUSH
61179: LD_VAR 0 2
61183: ARRAY
61184: PUSH
61185: LD_INT 2
61187: ARRAY
61188: PPUSH
61189: CALL_OW 458
61193: AND
61194: IFFALSE 61288
// begin LaunchMineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] , side ) ;
61196: LD_EXP 97
61200: PUSH
61201: LD_VAR 0 1
61205: ARRAY
61206: PUSH
61207: LD_VAR 0 2
61211: ARRAY
61212: PUSH
61213: LD_INT 1
61215: ARRAY
61216: PPUSH
61217: LD_EXP 97
61221: PUSH
61222: LD_VAR 0 1
61226: ARRAY
61227: PUSH
61228: LD_VAR 0 2
61232: ARRAY
61233: PUSH
61234: LD_INT 2
61236: ARRAY
61237: PPUSH
61238: LD_VAR 0 3
61242: PPUSH
61243: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , i , Delete ( minerMinesList [ i ] , j ) ) ;
61247: LD_ADDR_EXP 97
61251: PUSH
61252: LD_EXP 97
61256: PPUSH
61257: LD_VAR 0 1
61261: PPUSH
61262: LD_EXP 97
61266: PUSH
61267: LD_VAR 0 1
61271: ARRAY
61272: PPUSH
61273: LD_VAR 0 2
61277: PPUSH
61278: CALL_OW 3
61282: PPUSH
61283: CALL_OW 1
61287: ST_TO_ADDR
// end ; end ;
61288: GO 61039
61290: POP
61291: POP
// end ;
61292: GO 60957
61294: POP
61295: POP
// end ;
61296: PPOPN 4
61298: END
// export function MinerPlaceMine ( unit , x , y ) ; var index ; begin
61299: LD_INT 0
61301: PPUSH
61302: PPUSH
// result := false ;
61303: LD_ADDR_VAR 0 4
61307: PUSH
61308: LD_INT 0
61310: ST_TO_ADDR
// if not GetWeapon ( unit ) = ar_miner then
61311: LD_VAR 0 1
61315: PPUSH
61316: CALL_OW 264
61320: PUSH
61321: LD_EXP 164
61325: EQUAL
61326: NOT
61327: IFFALSE 61331
// exit ;
61329: GO 61571
// index := GetElementIndex ( minersList , unit ) ;
61331: LD_ADDR_VAR 0 5
61335: PUSH
61336: LD_EXP 96
61340: PPUSH
61341: LD_VAR 0 1
61345: PPUSH
61346: CALL 23995 0 2
61350: ST_TO_ADDR
// if minerMinesList [ index ] >= minesLimitPerVehicle then
61351: LD_EXP 97
61355: PUSH
61356: LD_VAR 0 5
61360: ARRAY
61361: PUSH
61362: LD_EXP 98
61366: GREATEREQUAL
61367: IFFALSE 61371
// exit ;
61369: GO 61571
// ComMoveXY ( unit , x , y ) ;
61371: LD_VAR 0 1
61375: PPUSH
61376: LD_VAR 0 2
61380: PPUSH
61381: LD_VAR 0 3
61385: PPUSH
61386: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
61390: LD_INT 35
61392: PPUSH
61393: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) and HasTask ( unit ) then
61397: LD_VAR 0 1
61401: PPUSH
61402: LD_VAR 0 2
61406: PPUSH
61407: LD_VAR 0 3
61411: PPUSH
61412: CALL 54767 0 3
61416: NOT
61417: PUSH
61418: LD_VAR 0 1
61422: PPUSH
61423: CALL_OW 314
61427: AND
61428: IFFALSE 61432
// exit ;
61430: GO 61571
// until HexInfo ( x , y ) = unit and not HasTask ( unit ) ;
61432: LD_VAR 0 2
61436: PPUSH
61437: LD_VAR 0 3
61441: PPUSH
61442: CALL_OW 428
61446: PUSH
61447: LD_VAR 0 1
61451: EQUAL
61452: PUSH
61453: LD_VAR 0 1
61457: PPUSH
61458: CALL_OW 314
61462: NOT
61463: AND
61464: IFFALSE 61390
// PlaySoundXY ( x , y , PlantMine ) ;
61466: LD_VAR 0 2
61470: PPUSH
61471: LD_VAR 0 3
61475: PPUSH
61476: LD_STRING PlantMine
61478: PPUSH
61479: CALL_OW 366
// PlaceMine ( x , y , GetSide ( unit ) , 0 ) ;
61483: LD_VAR 0 2
61487: PPUSH
61488: LD_VAR 0 3
61492: PPUSH
61493: LD_VAR 0 1
61497: PPUSH
61498: CALL_OW 255
61502: PPUSH
61503: LD_INT 0
61505: PPUSH
61506: CALL_OW 454
// minerMinesList := ReplaceIn ( minerMinesList , [ index , minerMinesList [ index ] + 1 ] , [ x , y ] ) ;
61510: LD_ADDR_EXP 97
61514: PUSH
61515: LD_EXP 97
61519: PPUSH
61520: LD_VAR 0 5
61524: PUSH
61525: LD_EXP 97
61529: PUSH
61530: LD_VAR 0 5
61534: ARRAY
61535: PUSH
61536: LD_INT 1
61538: PLUS
61539: PUSH
61540: EMPTY
61541: LIST
61542: LIST
61543: PPUSH
61544: LD_VAR 0 2
61548: PUSH
61549: LD_VAR 0 3
61553: PUSH
61554: EMPTY
61555: LIST
61556: LIST
61557: PPUSH
61558: CALL 24210 0 3
61562: ST_TO_ADDR
// result := true ;
61563: LD_ADDR_VAR 0 4
61567: PUSH
61568: LD_INT 1
61570: ST_TO_ADDR
// end ;
61571: LD_VAR 0 4
61575: RET
// export function MinerDetonateMine ( unit , x , y ) ; var i , index ; begin
61576: LD_INT 0
61578: PPUSH
61579: PPUSH
61580: PPUSH
// if not unit in minersList then
61581: LD_VAR 0 1
61585: PUSH
61586: LD_EXP 96
61590: IN
61591: NOT
61592: IFFALSE 61596
// exit ;
61594: GO 61988
// index := GetElementIndex ( minersList , unit ) ;
61596: LD_ADDR_VAR 0 6
61600: PUSH
61601: LD_EXP 96
61605: PPUSH
61606: LD_VAR 0 1
61610: PPUSH
61611: CALL 23995 0 2
61615: ST_TO_ADDR
// for i := minerMinesList [ index ] downto 1 do
61616: LD_ADDR_VAR 0 5
61620: PUSH
61621: DOUBLE
61622: LD_EXP 97
61626: PUSH
61627: LD_VAR 0 6
61631: ARRAY
61632: INC
61633: ST_TO_ADDR
61634: LD_INT 1
61636: PUSH
61637: FOR_DOWNTO
61638: IFFALSE 61799
// begin if minerMinesList [ index ] [ i ] [ 1 ] = x and minerMinesList [ index ] [ i ] [ 2 ] = y then
61640: LD_EXP 97
61644: PUSH
61645: LD_VAR 0 6
61649: ARRAY
61650: PUSH
61651: LD_VAR 0 5
61655: ARRAY
61656: PUSH
61657: LD_INT 1
61659: ARRAY
61660: PUSH
61661: LD_VAR 0 2
61665: EQUAL
61666: PUSH
61667: LD_EXP 97
61671: PUSH
61672: LD_VAR 0 6
61676: ARRAY
61677: PUSH
61678: LD_VAR 0 5
61682: ARRAY
61683: PUSH
61684: LD_INT 2
61686: ARRAY
61687: PUSH
61688: LD_VAR 0 3
61692: EQUAL
61693: AND
61694: IFFALSE 61797
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
61696: LD_EXP 97
61700: PUSH
61701: LD_VAR 0 6
61705: ARRAY
61706: PUSH
61707: LD_VAR 0 5
61711: ARRAY
61712: PUSH
61713: LD_INT 1
61715: ARRAY
61716: PPUSH
61717: LD_EXP 97
61721: PUSH
61722: LD_VAR 0 6
61726: ARRAY
61727: PUSH
61728: LD_VAR 0 5
61732: ARRAY
61733: PUSH
61734: LD_INT 2
61736: ARRAY
61737: PPUSH
61738: LD_VAR 0 1
61742: PPUSH
61743: CALL_OW 255
61747: PPUSH
61748: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
61752: LD_ADDR_EXP 97
61756: PUSH
61757: LD_EXP 97
61761: PPUSH
61762: LD_VAR 0 6
61766: PPUSH
61767: LD_EXP 97
61771: PUSH
61772: LD_VAR 0 6
61776: ARRAY
61777: PPUSH
61778: LD_VAR 0 5
61782: PPUSH
61783: CALL_OW 3
61787: PPUSH
61788: CALL_OW 1
61792: ST_TO_ADDR
// exit ;
61793: POP
61794: POP
61795: GO 61988
// end ; end ;
61797: GO 61637
61799: POP
61800: POP
// for i := minerMinesList [ index ] downto 1 do
61801: LD_ADDR_VAR 0 5
61805: PUSH
61806: DOUBLE
61807: LD_EXP 97
61811: PUSH
61812: LD_VAR 0 6
61816: ARRAY
61817: INC
61818: ST_TO_ADDR
61819: LD_INT 1
61821: PUSH
61822: FOR_DOWNTO
61823: IFFALSE 61986
// begin if GetDistXY ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , x , y ) < 6 then
61825: LD_EXP 97
61829: PUSH
61830: LD_VAR 0 6
61834: ARRAY
61835: PUSH
61836: LD_VAR 0 5
61840: ARRAY
61841: PUSH
61842: LD_INT 1
61844: ARRAY
61845: PPUSH
61846: LD_EXP 97
61850: PUSH
61851: LD_VAR 0 6
61855: ARRAY
61856: PUSH
61857: LD_VAR 0 5
61861: ARRAY
61862: PUSH
61863: LD_INT 2
61865: ARRAY
61866: PPUSH
61867: LD_VAR 0 2
61871: PPUSH
61872: LD_VAR 0 3
61876: PPUSH
61877: CALL_OW 298
61881: PUSH
61882: LD_INT 6
61884: LESS
61885: IFFALSE 61984
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
61887: LD_EXP 97
61891: PUSH
61892: LD_VAR 0 6
61896: ARRAY
61897: PUSH
61898: LD_VAR 0 5
61902: ARRAY
61903: PUSH
61904: LD_INT 1
61906: ARRAY
61907: PPUSH
61908: LD_EXP 97
61912: PUSH
61913: LD_VAR 0 6
61917: ARRAY
61918: PUSH
61919: LD_VAR 0 5
61923: ARRAY
61924: PUSH
61925: LD_INT 2
61927: ARRAY
61928: PPUSH
61929: LD_VAR 0 1
61933: PPUSH
61934: CALL_OW 255
61938: PPUSH
61939: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
61943: LD_ADDR_EXP 97
61947: PUSH
61948: LD_EXP 97
61952: PPUSH
61953: LD_VAR 0 6
61957: PPUSH
61958: LD_EXP 97
61962: PUSH
61963: LD_VAR 0 6
61967: ARRAY
61968: PPUSH
61969: LD_VAR 0 5
61973: PPUSH
61974: CALL_OW 3
61978: PPUSH
61979: CALL_OW 1
61983: ST_TO_ADDR
// end ; end ;
61984: GO 61822
61986: POP
61987: POP
// end ;
61988: LD_VAR 0 4
61992: RET
// export function MinerCreateMinefield ( unit , x , y ) ; var i , index , tmp , minesFreeAmount , _x , _y , _d , _r ; begin
61993: LD_INT 0
61995: PPUSH
61996: PPUSH
61997: PPUSH
61998: PPUSH
61999: PPUSH
62000: PPUSH
62001: PPUSH
62002: PPUSH
62003: PPUSH
// if not GetWeapon ( unit ) = ar_miner or not unit in minersList then
62004: LD_VAR 0 1
62008: PPUSH
62009: CALL_OW 264
62013: PUSH
62014: LD_EXP 164
62018: EQUAL
62019: NOT
62020: PUSH
62021: LD_VAR 0 1
62025: PUSH
62026: LD_EXP 96
62030: IN
62031: NOT
62032: OR
62033: IFFALSE 62037
// exit ;
62035: GO 62359
// index := GetElementIndex ( minersList , unit ) ;
62037: LD_ADDR_VAR 0 6
62041: PUSH
62042: LD_EXP 96
62046: PPUSH
62047: LD_VAR 0 1
62051: PPUSH
62052: CALL 23995 0 2
62056: ST_TO_ADDR
// minesFreeAmount := minesLimitPerVehicle - minerMinesList [ index ] ;
62057: LD_ADDR_VAR 0 8
62061: PUSH
62062: LD_EXP 98
62066: PUSH
62067: LD_EXP 97
62071: PUSH
62072: LD_VAR 0 6
62076: ARRAY
62077: MINUS
62078: ST_TO_ADDR
// if not minesFreeAmount then
62079: LD_VAR 0 8
62083: NOT
62084: IFFALSE 62088
// exit ;
62086: GO 62359
// tmp := [ ] ;
62088: LD_ADDR_VAR 0 7
62092: PUSH
62093: EMPTY
62094: ST_TO_ADDR
// for i := 1 to minesFreeAmount do
62095: LD_ADDR_VAR 0 5
62099: PUSH
62100: DOUBLE
62101: LD_INT 1
62103: DEC
62104: ST_TO_ADDR
62105: LD_VAR 0 8
62109: PUSH
62110: FOR_TO
62111: IFFALSE 62306
// begin _d := rand ( 0 , 5 ) ;
62113: LD_ADDR_VAR 0 11
62117: PUSH
62118: LD_INT 0
62120: PPUSH
62121: LD_INT 5
62123: PPUSH
62124: CALL_OW 12
62128: ST_TO_ADDR
// _r := rand ( 2 , 6 ) ;
62129: LD_ADDR_VAR 0 12
62133: PUSH
62134: LD_INT 2
62136: PPUSH
62137: LD_INT 6
62139: PPUSH
62140: CALL_OW 12
62144: ST_TO_ADDR
// _x := ShiftX ( x , _d , _r ) ;
62145: LD_ADDR_VAR 0 9
62149: PUSH
62150: LD_VAR 0 2
62154: PPUSH
62155: LD_VAR 0 11
62159: PPUSH
62160: LD_VAR 0 12
62164: PPUSH
62165: CALL_OW 272
62169: ST_TO_ADDR
// _y := ShiftY ( y , _d , _r ) ;
62170: LD_ADDR_VAR 0 10
62174: PUSH
62175: LD_VAR 0 3
62179: PPUSH
62180: LD_VAR 0 11
62184: PPUSH
62185: LD_VAR 0 12
62189: PPUSH
62190: CALL_OW 273
62194: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not [ _x , _y ] in tmp and not MineAtPos ( _x , _y ) then
62195: LD_VAR 0 9
62199: PPUSH
62200: LD_VAR 0 10
62204: PPUSH
62205: CALL_OW 488
62209: PUSH
62210: LD_VAR 0 9
62214: PUSH
62215: LD_VAR 0 10
62219: PUSH
62220: EMPTY
62221: LIST
62222: LIST
62223: PUSH
62224: LD_VAR 0 7
62228: IN
62229: NOT
62230: AND
62231: PUSH
62232: LD_VAR 0 9
62236: PPUSH
62237: LD_VAR 0 10
62241: PPUSH
62242: CALL_OW 458
62246: NOT
62247: AND
62248: IFFALSE 62290
// tmp := Replace ( tmp , tmp + 1 , [ _x , _y ] ) else
62250: LD_ADDR_VAR 0 7
62254: PUSH
62255: LD_VAR 0 7
62259: PPUSH
62260: LD_VAR 0 7
62264: PUSH
62265: LD_INT 1
62267: PLUS
62268: PPUSH
62269: LD_VAR 0 9
62273: PUSH
62274: LD_VAR 0 10
62278: PUSH
62279: EMPTY
62280: LIST
62281: LIST
62282: PPUSH
62283: CALL_OW 1
62287: ST_TO_ADDR
62288: GO 62304
// i := i - 1 ;
62290: LD_ADDR_VAR 0 5
62294: PUSH
62295: LD_VAR 0 5
62299: PUSH
62300: LD_INT 1
62302: MINUS
62303: ST_TO_ADDR
// end ;
62304: GO 62110
62306: POP
62307: POP
// for i in tmp do
62308: LD_ADDR_VAR 0 5
62312: PUSH
62313: LD_VAR 0 7
62317: PUSH
62318: FOR_IN
62319: IFFALSE 62357
// if not MinerPlaceMine ( unit , i [ 1 ] , i [ 2 ] ) then
62321: LD_VAR 0 1
62325: PPUSH
62326: LD_VAR 0 5
62330: PUSH
62331: LD_INT 1
62333: ARRAY
62334: PPUSH
62335: LD_VAR 0 5
62339: PUSH
62340: LD_INT 2
62342: ARRAY
62343: PPUSH
62344: CALL 61299 0 3
62348: NOT
62349: IFFALSE 62355
// exit ;
62351: POP
62352: POP
62353: GO 62359
62355: GO 62318
62357: POP
62358: POP
// end ;
62359: LD_VAR 0 4
62363: RET
// export function ComBinocular ( unit , x , y ) ; var dist , side , viewRange , _x , _y , _d ; begin
62364: LD_INT 0
62366: PPUSH
62367: PPUSH
62368: PPUSH
62369: PPUSH
62370: PPUSH
62371: PPUSH
62372: PPUSH
// if not GetClass ( unit ) = class_sniper then
62373: LD_VAR 0 1
62377: PPUSH
62378: CALL_OW 257
62382: PUSH
62383: LD_INT 5
62385: EQUAL
62386: NOT
62387: IFFALSE 62391
// exit ;
62389: GO 62779
// dist := 8 ;
62391: LD_ADDR_VAR 0 5
62395: PUSH
62396: LD_INT 8
62398: ST_TO_ADDR
// viewRange := 12 ;
62399: LD_ADDR_VAR 0 7
62403: PUSH
62404: LD_INT 12
62406: ST_TO_ADDR
// side := GetSide ( unit ) ;
62407: LD_ADDR_VAR 0 6
62411: PUSH
62412: LD_VAR 0 1
62416: PPUSH
62417: CALL_OW 255
62421: ST_TO_ADDR
// if GetTech ( tech_opto2 , side ) = state_researched then
62422: LD_INT 61
62424: PPUSH
62425: LD_VAR 0 6
62429: PPUSH
62430: CALL_OW 321
62434: PUSH
62435: LD_INT 2
62437: EQUAL
62438: IFFALSE 62448
// viewRange := 16 ;
62440: LD_ADDR_VAR 0 7
62444: PUSH
62445: LD_INT 16
62447: ST_TO_ADDR
// if GetDistUnitXY ( unit , x , y ) > dist then
62448: LD_VAR 0 1
62452: PPUSH
62453: LD_VAR 0 2
62457: PPUSH
62458: LD_VAR 0 3
62462: PPUSH
62463: CALL_OW 297
62467: PUSH
62468: LD_VAR 0 5
62472: GREATER
62473: IFFALSE 62552
// begin ComMoveXY ( unit , x , y ) ;
62475: LD_VAR 0 1
62479: PPUSH
62480: LD_VAR 0 2
62484: PPUSH
62485: LD_VAR 0 3
62489: PPUSH
62490: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
62494: LD_INT 35
62496: PPUSH
62497: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) then
62501: LD_VAR 0 1
62505: PPUSH
62506: LD_VAR 0 2
62510: PPUSH
62511: LD_VAR 0 3
62515: PPUSH
62516: CALL 54767 0 3
62520: NOT
62521: IFFALSE 62525
// exit ;
62523: GO 62779
// until GetDistUnitXY ( unit , x , y ) < dist ;
62525: LD_VAR 0 1
62529: PPUSH
62530: LD_VAR 0 2
62534: PPUSH
62535: LD_VAR 0 3
62539: PPUSH
62540: CALL_OW 297
62544: PUSH
62545: LD_VAR 0 5
62549: LESS
62550: IFFALSE 62494
// end ; ComTurnXY ( unit , x , y ) ;
62552: LD_VAR 0 1
62556: PPUSH
62557: LD_VAR 0 2
62561: PPUSH
62562: LD_VAR 0 3
62566: PPUSH
62567: CALL_OW 118
// wait ( 5 ) ;
62571: LD_INT 5
62573: PPUSH
62574: CALL_OW 67
// _d := GetDir ( unit ) ;
62578: LD_ADDR_VAR 0 10
62582: PUSH
62583: LD_VAR 0 1
62587: PPUSH
62588: CALL_OW 254
62592: ST_TO_ADDR
// _x := ShiftX ( GetX ( unit ) , _d , dist ) ;
62593: LD_ADDR_VAR 0 8
62597: PUSH
62598: LD_VAR 0 1
62602: PPUSH
62603: CALL_OW 250
62607: PPUSH
62608: LD_VAR 0 10
62612: PPUSH
62613: LD_VAR 0 5
62617: PPUSH
62618: CALL_OW 272
62622: ST_TO_ADDR
// _y := ShiftY ( GetY ( unit ) , _d , dist ) ;
62623: LD_ADDR_VAR 0 9
62627: PUSH
62628: LD_VAR 0 1
62632: PPUSH
62633: CALL_OW 251
62637: PPUSH
62638: LD_VAR 0 10
62642: PPUSH
62643: LD_VAR 0 5
62647: PPUSH
62648: CALL_OW 273
62652: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
62653: LD_VAR 0 8
62657: PPUSH
62658: LD_VAR 0 9
62662: PPUSH
62663: CALL_OW 488
62667: NOT
62668: IFFALSE 62672
// exit ;
62670: GO 62779
// ComAnimCustom ( unit , 1 ) ;
62672: LD_VAR 0 1
62676: PPUSH
62677: LD_INT 1
62679: PPUSH
62680: CALL_OW 592
// PlaceSeeing ( _x , _y , side , viewRange ) ;
62684: LD_VAR 0 8
62688: PPUSH
62689: LD_VAR 0 9
62693: PPUSH
62694: LD_VAR 0 6
62698: PPUSH
62699: LD_VAR 0 7
62703: PPUSH
62704: CALL_OW 330
// repeat wait ( 1 ) ;
62708: LD_INT 1
62710: PPUSH
62711: CALL_OW 67
// until IsIdle ( unit ) or HasTask ( unit ) or not IsOk ( unit ) or IsDead ( unit ) ;
62715: LD_VAR 0 1
62719: PPUSH
62720: CALL_OW 316
62724: PUSH
62725: LD_VAR 0 1
62729: PPUSH
62730: CALL_OW 314
62734: OR
62735: PUSH
62736: LD_VAR 0 1
62740: PPUSH
62741: CALL_OW 302
62745: NOT
62746: OR
62747: PUSH
62748: LD_VAR 0 1
62752: PPUSH
62753: CALL_OW 301
62757: OR
62758: IFFALSE 62708
// RemoveSeeing ( _x , _y , side ) ;
62760: LD_VAR 0 8
62764: PPUSH
62765: LD_VAR 0 9
62769: PPUSH
62770: LD_VAR 0 6
62774: PPUSH
62775: CALL_OW 331
// end ; end_of_file
62779: LD_VAR 0 4
62783: RET
// export function SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
62784: LD_INT 0
62786: PPUSH
// if p2 = 100 then
62787: LD_VAR 0 2
62791: PUSH
62792: LD_INT 100
62794: EQUAL
62795: IFFALSE 63798
// begin if not StreamModeActive then
62797: LD_EXP 99
62801: NOT
62802: IFFALSE 62812
// StreamModeActive := true ;
62804: LD_ADDR_EXP 99
62808: PUSH
62809: LD_INT 1
62811: ST_TO_ADDR
// if p3 = 0 then
62812: LD_VAR 0 3
62816: PUSH
62817: LD_INT 0
62819: EQUAL
62820: IFFALSE 62826
// InitStreamMode ;
62822: CALL 63958 0 0
// if p3 = 1 then
62826: LD_VAR 0 3
62830: PUSH
62831: LD_INT 1
62833: EQUAL
62834: IFFALSE 62844
// sRocket := true ;
62836: LD_ADDR_EXP 104
62840: PUSH
62841: LD_INT 1
62843: ST_TO_ADDR
// if p3 = 2 then
62844: LD_VAR 0 3
62848: PUSH
62849: LD_INT 2
62851: EQUAL
62852: IFFALSE 62862
// sSpeed := true ;
62854: LD_ADDR_EXP 103
62858: PUSH
62859: LD_INT 1
62861: ST_TO_ADDR
// if p3 = 3 then
62862: LD_VAR 0 3
62866: PUSH
62867: LD_INT 3
62869: EQUAL
62870: IFFALSE 62880
// sEngine := true ;
62872: LD_ADDR_EXP 105
62876: PUSH
62877: LD_INT 1
62879: ST_TO_ADDR
// if p3 = 4 then
62880: LD_VAR 0 3
62884: PUSH
62885: LD_INT 4
62887: EQUAL
62888: IFFALSE 62898
// sSpec := true ;
62890: LD_ADDR_EXP 102
62894: PUSH
62895: LD_INT 1
62897: ST_TO_ADDR
// if p3 = 5 then
62898: LD_VAR 0 3
62902: PUSH
62903: LD_INT 5
62905: EQUAL
62906: IFFALSE 62916
// sLevel := true ;
62908: LD_ADDR_EXP 106
62912: PUSH
62913: LD_INT 1
62915: ST_TO_ADDR
// if p3 = 6 then
62916: LD_VAR 0 3
62920: PUSH
62921: LD_INT 6
62923: EQUAL
62924: IFFALSE 62934
// sArmoury := true ;
62926: LD_ADDR_EXP 107
62930: PUSH
62931: LD_INT 1
62933: ST_TO_ADDR
// if p3 = 7 then
62934: LD_VAR 0 3
62938: PUSH
62939: LD_INT 7
62941: EQUAL
62942: IFFALSE 62952
// sRadar := true ;
62944: LD_ADDR_EXP 108
62948: PUSH
62949: LD_INT 1
62951: ST_TO_ADDR
// if p3 = 8 then
62952: LD_VAR 0 3
62956: PUSH
62957: LD_INT 8
62959: EQUAL
62960: IFFALSE 62970
// sBunker := true ;
62962: LD_ADDR_EXP 109
62966: PUSH
62967: LD_INT 1
62969: ST_TO_ADDR
// if p3 = 9 then
62970: LD_VAR 0 3
62974: PUSH
62975: LD_INT 9
62977: EQUAL
62978: IFFALSE 62988
// sHack := true ;
62980: LD_ADDR_EXP 110
62984: PUSH
62985: LD_INT 1
62987: ST_TO_ADDR
// if p3 = 10 then
62988: LD_VAR 0 3
62992: PUSH
62993: LD_INT 10
62995: EQUAL
62996: IFFALSE 63006
// sFire := true ;
62998: LD_ADDR_EXP 111
63002: PUSH
63003: LD_INT 1
63005: ST_TO_ADDR
// if p3 = 11 then
63006: LD_VAR 0 3
63010: PUSH
63011: LD_INT 11
63013: EQUAL
63014: IFFALSE 63024
// sRefresh := true ;
63016: LD_ADDR_EXP 112
63020: PUSH
63021: LD_INT 1
63023: ST_TO_ADDR
// if p3 = 12 then
63024: LD_VAR 0 3
63028: PUSH
63029: LD_INT 12
63031: EQUAL
63032: IFFALSE 63042
// sExp := true ;
63034: LD_ADDR_EXP 113
63038: PUSH
63039: LD_INT 1
63041: ST_TO_ADDR
// if p3 = 13 then
63042: LD_VAR 0 3
63046: PUSH
63047: LD_INT 13
63049: EQUAL
63050: IFFALSE 63060
// sDepot := true ;
63052: LD_ADDR_EXP 114
63056: PUSH
63057: LD_INT 1
63059: ST_TO_ADDR
// if p3 = 14 then
63060: LD_VAR 0 3
63064: PUSH
63065: LD_INT 14
63067: EQUAL
63068: IFFALSE 63078
// sFlag := true ;
63070: LD_ADDR_EXP 115
63074: PUSH
63075: LD_INT 1
63077: ST_TO_ADDR
// if p3 = 15 then
63078: LD_VAR 0 3
63082: PUSH
63083: LD_INT 15
63085: EQUAL
63086: IFFALSE 63096
// sKamikadze := true ;
63088: LD_ADDR_EXP 123
63092: PUSH
63093: LD_INT 1
63095: ST_TO_ADDR
// if p3 = 16 then
63096: LD_VAR 0 3
63100: PUSH
63101: LD_INT 16
63103: EQUAL
63104: IFFALSE 63114
// sTroll := true ;
63106: LD_ADDR_EXP 124
63110: PUSH
63111: LD_INT 1
63113: ST_TO_ADDR
// if p3 = 17 then
63114: LD_VAR 0 3
63118: PUSH
63119: LD_INT 17
63121: EQUAL
63122: IFFALSE 63132
// sSlow := true ;
63124: LD_ADDR_EXP 125
63128: PUSH
63129: LD_INT 1
63131: ST_TO_ADDR
// if p3 = 18 then
63132: LD_VAR 0 3
63136: PUSH
63137: LD_INT 18
63139: EQUAL
63140: IFFALSE 63150
// sLack := true ;
63142: LD_ADDR_EXP 126
63146: PUSH
63147: LD_INT 1
63149: ST_TO_ADDR
// if p3 = 19 then
63150: LD_VAR 0 3
63154: PUSH
63155: LD_INT 19
63157: EQUAL
63158: IFFALSE 63168
// sTank := true ;
63160: LD_ADDR_EXP 128
63164: PUSH
63165: LD_INT 1
63167: ST_TO_ADDR
// if p3 = 20 then
63168: LD_VAR 0 3
63172: PUSH
63173: LD_INT 20
63175: EQUAL
63176: IFFALSE 63186
// sRemote := true ;
63178: LD_ADDR_EXP 129
63182: PUSH
63183: LD_INT 1
63185: ST_TO_ADDR
// if p3 = 21 then
63186: LD_VAR 0 3
63190: PUSH
63191: LD_INT 21
63193: EQUAL
63194: IFFALSE 63204
// sPowell := true ;
63196: LD_ADDR_EXP 130
63200: PUSH
63201: LD_INT 1
63203: ST_TO_ADDR
// if p3 = 22 then
63204: LD_VAR 0 3
63208: PUSH
63209: LD_INT 22
63211: EQUAL
63212: IFFALSE 63222
// sTeleport := true ;
63214: LD_ADDR_EXP 133
63218: PUSH
63219: LD_INT 1
63221: ST_TO_ADDR
// if p3 = 23 then
63222: LD_VAR 0 3
63226: PUSH
63227: LD_INT 23
63229: EQUAL
63230: IFFALSE 63240
// sOilTower := true ;
63232: LD_ADDR_EXP 135
63236: PUSH
63237: LD_INT 1
63239: ST_TO_ADDR
// if p3 = 24 then
63240: LD_VAR 0 3
63244: PUSH
63245: LD_INT 24
63247: EQUAL
63248: IFFALSE 63258
// sShovel := true ;
63250: LD_ADDR_EXP 136
63254: PUSH
63255: LD_INT 1
63257: ST_TO_ADDR
// if p3 = 25 then
63258: LD_VAR 0 3
63262: PUSH
63263: LD_INT 25
63265: EQUAL
63266: IFFALSE 63276
// sSheik := true ;
63268: LD_ADDR_EXP 137
63272: PUSH
63273: LD_INT 1
63275: ST_TO_ADDR
// if p3 = 26 then
63276: LD_VAR 0 3
63280: PUSH
63281: LD_INT 26
63283: EQUAL
63284: IFFALSE 63294
// sEarthquake := true ;
63286: LD_ADDR_EXP 139
63290: PUSH
63291: LD_INT 1
63293: ST_TO_ADDR
// if p3 = 27 then
63294: LD_VAR 0 3
63298: PUSH
63299: LD_INT 27
63301: EQUAL
63302: IFFALSE 63312
// sAI := true ;
63304: LD_ADDR_EXP 140
63308: PUSH
63309: LD_INT 1
63311: ST_TO_ADDR
// if p3 = 28 then
63312: LD_VAR 0 3
63316: PUSH
63317: LD_INT 28
63319: EQUAL
63320: IFFALSE 63330
// sCargo := true ;
63322: LD_ADDR_EXP 143
63326: PUSH
63327: LD_INT 1
63329: ST_TO_ADDR
// if p3 = 29 then
63330: LD_VAR 0 3
63334: PUSH
63335: LD_INT 29
63337: EQUAL
63338: IFFALSE 63348
// sDLaser := true ;
63340: LD_ADDR_EXP 144
63344: PUSH
63345: LD_INT 1
63347: ST_TO_ADDR
// if p3 = 30 then
63348: LD_VAR 0 3
63352: PUSH
63353: LD_INT 30
63355: EQUAL
63356: IFFALSE 63366
// sExchange := true ;
63358: LD_ADDR_EXP 145
63362: PUSH
63363: LD_INT 1
63365: ST_TO_ADDR
// if p3 = 31 then
63366: LD_VAR 0 3
63370: PUSH
63371: LD_INT 31
63373: EQUAL
63374: IFFALSE 63384
// sFac := true ;
63376: LD_ADDR_EXP 146
63380: PUSH
63381: LD_INT 1
63383: ST_TO_ADDR
// if p3 = 32 then
63384: LD_VAR 0 3
63388: PUSH
63389: LD_INT 32
63391: EQUAL
63392: IFFALSE 63402
// sPower := true ;
63394: LD_ADDR_EXP 147
63398: PUSH
63399: LD_INT 1
63401: ST_TO_ADDR
// if p3 = 33 then
63402: LD_VAR 0 3
63406: PUSH
63407: LD_INT 33
63409: EQUAL
63410: IFFALSE 63420
// sRandom := true ;
63412: LD_ADDR_EXP 148
63416: PUSH
63417: LD_INT 1
63419: ST_TO_ADDR
// if p3 = 34 then
63420: LD_VAR 0 3
63424: PUSH
63425: LD_INT 34
63427: EQUAL
63428: IFFALSE 63438
// sShield := true ;
63430: LD_ADDR_EXP 149
63434: PUSH
63435: LD_INT 1
63437: ST_TO_ADDR
// if p3 = 35 then
63438: LD_VAR 0 3
63442: PUSH
63443: LD_INT 35
63445: EQUAL
63446: IFFALSE 63456
// sTime := true ;
63448: LD_ADDR_EXP 150
63452: PUSH
63453: LD_INT 1
63455: ST_TO_ADDR
// if p3 = 36 then
63456: LD_VAR 0 3
63460: PUSH
63461: LD_INT 36
63463: EQUAL
63464: IFFALSE 63474
// sTools := true ;
63466: LD_ADDR_EXP 151
63470: PUSH
63471: LD_INT 1
63473: ST_TO_ADDR
// if p3 = 101 then
63474: LD_VAR 0 3
63478: PUSH
63479: LD_INT 101
63481: EQUAL
63482: IFFALSE 63492
// sSold := true ;
63484: LD_ADDR_EXP 116
63488: PUSH
63489: LD_INT 1
63491: ST_TO_ADDR
// if p3 = 102 then
63492: LD_VAR 0 3
63496: PUSH
63497: LD_INT 102
63499: EQUAL
63500: IFFALSE 63510
// sDiff := true ;
63502: LD_ADDR_EXP 117
63506: PUSH
63507: LD_INT 1
63509: ST_TO_ADDR
// if p3 = 103 then
63510: LD_VAR 0 3
63514: PUSH
63515: LD_INT 103
63517: EQUAL
63518: IFFALSE 63528
// sFog := true ;
63520: LD_ADDR_EXP 120
63524: PUSH
63525: LD_INT 1
63527: ST_TO_ADDR
// if p3 = 104 then
63528: LD_VAR 0 3
63532: PUSH
63533: LD_INT 104
63535: EQUAL
63536: IFFALSE 63546
// sReset := true ;
63538: LD_ADDR_EXP 121
63542: PUSH
63543: LD_INT 1
63545: ST_TO_ADDR
// if p3 = 105 then
63546: LD_VAR 0 3
63550: PUSH
63551: LD_INT 105
63553: EQUAL
63554: IFFALSE 63564
// sSun := true ;
63556: LD_ADDR_EXP 122
63560: PUSH
63561: LD_INT 1
63563: ST_TO_ADDR
// if p3 = 106 then
63564: LD_VAR 0 3
63568: PUSH
63569: LD_INT 106
63571: EQUAL
63572: IFFALSE 63582
// sTiger := true ;
63574: LD_ADDR_EXP 118
63578: PUSH
63579: LD_INT 1
63581: ST_TO_ADDR
// if p3 = 107 then
63582: LD_VAR 0 3
63586: PUSH
63587: LD_INT 107
63589: EQUAL
63590: IFFALSE 63600
// sBomb := true ;
63592: LD_ADDR_EXP 119
63596: PUSH
63597: LD_INT 1
63599: ST_TO_ADDR
// if p3 = 108 then
63600: LD_VAR 0 3
63604: PUSH
63605: LD_INT 108
63607: EQUAL
63608: IFFALSE 63618
// sWound := true ;
63610: LD_ADDR_EXP 127
63614: PUSH
63615: LD_INT 1
63617: ST_TO_ADDR
// if p3 = 109 then
63618: LD_VAR 0 3
63622: PUSH
63623: LD_INT 109
63625: EQUAL
63626: IFFALSE 63636
// sBetray := true ;
63628: LD_ADDR_EXP 131
63632: PUSH
63633: LD_INT 1
63635: ST_TO_ADDR
// if p3 = 110 then
63636: LD_VAR 0 3
63640: PUSH
63641: LD_INT 110
63643: EQUAL
63644: IFFALSE 63654
// sContamin := true ;
63646: LD_ADDR_EXP 132
63650: PUSH
63651: LD_INT 1
63653: ST_TO_ADDR
// if p3 = 111 then
63654: LD_VAR 0 3
63658: PUSH
63659: LD_INT 111
63661: EQUAL
63662: IFFALSE 63672
// sOil := true ;
63664: LD_ADDR_EXP 134
63668: PUSH
63669: LD_INT 1
63671: ST_TO_ADDR
// if p3 = 112 then
63672: LD_VAR 0 3
63676: PUSH
63677: LD_INT 112
63679: EQUAL
63680: IFFALSE 63690
// sStu := true ;
63682: LD_ADDR_EXP 138
63686: PUSH
63687: LD_INT 1
63689: ST_TO_ADDR
// if p3 = 113 then
63690: LD_VAR 0 3
63694: PUSH
63695: LD_INT 113
63697: EQUAL
63698: IFFALSE 63708
// sBazooka := true ;
63700: LD_ADDR_EXP 141
63704: PUSH
63705: LD_INT 1
63707: ST_TO_ADDR
// if p3 = 114 then
63708: LD_VAR 0 3
63712: PUSH
63713: LD_INT 114
63715: EQUAL
63716: IFFALSE 63726
// sMortar := true ;
63718: LD_ADDR_EXP 142
63722: PUSH
63723: LD_INT 1
63725: ST_TO_ADDR
// if p3 = 115 then
63726: LD_VAR 0 3
63730: PUSH
63731: LD_INT 115
63733: EQUAL
63734: IFFALSE 63744
// sRanger := true ;
63736: LD_ADDR_EXP 152
63740: PUSH
63741: LD_INT 1
63743: ST_TO_ADDR
// if p3 = 116 then
63744: LD_VAR 0 3
63748: PUSH
63749: LD_INT 116
63751: EQUAL
63752: IFFALSE 63762
// sComputer := true ;
63754: LD_ADDR_EXP 153
63758: PUSH
63759: LD_INT 1
63761: ST_TO_ADDR
// if p3 = 117 then
63762: LD_VAR 0 3
63766: PUSH
63767: LD_INT 117
63769: EQUAL
63770: IFFALSE 63780
// s30 := true ;
63772: LD_ADDR_EXP 154
63776: PUSH
63777: LD_INT 1
63779: ST_TO_ADDR
// if p3 = 118 then
63780: LD_VAR 0 3
63784: PUSH
63785: LD_INT 118
63787: EQUAL
63788: IFFALSE 63798
// s60 := true ;
63790: LD_ADDR_EXP 155
63794: PUSH
63795: LD_INT 1
63797: ST_TO_ADDR
// end ; if p2 = 101 then
63798: LD_VAR 0 2
63802: PUSH
63803: LD_INT 101
63805: EQUAL
63806: IFFALSE 63934
// begin case p3 of 1 :
63808: LD_VAR 0 3
63812: PUSH
63813: LD_INT 1
63815: DOUBLE
63816: EQUAL
63817: IFTRUE 63821
63819: GO 63828
63821: POP
// hHackUnlimitedResources ; 2 :
63822: CALL 75530 0 0
63826: GO 63934
63828: LD_INT 2
63830: DOUBLE
63831: EQUAL
63832: IFTRUE 63836
63834: GO 63843
63836: POP
// hHackSetLevel10 ; 3 :
63837: CALL 75663 0 0
63841: GO 63934
63843: LD_INT 3
63845: DOUBLE
63846: EQUAL
63847: IFTRUE 63851
63849: GO 63858
63851: POP
// hHackSetLevel10YourUnits ; 4 :
63852: CALL 75748 0 0
63856: GO 63934
63858: LD_INT 4
63860: DOUBLE
63861: EQUAL
63862: IFTRUE 63866
63864: GO 63873
63866: POP
// hHackInvincible ; 5 :
63867: CALL 76196 0 0
63871: GO 63934
63873: LD_INT 5
63875: DOUBLE
63876: EQUAL
63877: IFTRUE 63881
63879: GO 63888
63881: POP
// hHackInvisible ; 6 :
63882: CALL 76307 0 0
63886: GO 63934
63888: LD_INT 6
63890: DOUBLE
63891: EQUAL
63892: IFTRUE 63896
63894: GO 63903
63896: POP
// hHackChangeYourSide ; 7 :
63897: CALL 76364 0 0
63901: GO 63934
63903: LD_INT 7
63905: DOUBLE
63906: EQUAL
63907: IFTRUE 63911
63909: GO 63918
63911: POP
// hHackChangeUnitSide ; 8 :
63912: CALL 76406 0 0
63916: GO 63934
63918: LD_INT 8
63920: DOUBLE
63921: EQUAL
63922: IFTRUE 63926
63924: GO 63933
63926: POP
// hHackFog ; end ;
63927: CALL 76507 0 0
63931: GO 63934
63933: POP
// end ; end ;
63934: LD_VAR 0 7
63938: RET
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger , sComputer , s30 , s60 ; every 0 0$1 do
63939: GO 63941
63941: DISABLE
// begin ToLua ( initStreamRollete(); ) ;
63942: LD_STRING initStreamRollete();
63944: PPUSH
63945: CALL_OW 559
// InitStreamMode ;
63949: CALL 63958 0 0
// DefineStreamItems ( ) ;
63953: CALL 64422 0 0
// end ;
63957: END
// function InitStreamMode ; begin
63958: LD_INT 0
63960: PPUSH
// streamModeActive := false ;
63961: LD_ADDR_EXP 99
63965: PUSH
63966: LD_INT 0
63968: ST_TO_ADDR
// normalCounter := 36 ;
63969: LD_ADDR_EXP 100
63973: PUSH
63974: LD_INT 36
63976: ST_TO_ADDR
// hardcoreCounter := 16 ;
63977: LD_ADDR_EXP 101
63981: PUSH
63982: LD_INT 16
63984: ST_TO_ADDR
// sRocket := false ;
63985: LD_ADDR_EXP 104
63989: PUSH
63990: LD_INT 0
63992: ST_TO_ADDR
// sSpeed := false ;
63993: LD_ADDR_EXP 103
63997: PUSH
63998: LD_INT 0
64000: ST_TO_ADDR
// sEngine := false ;
64001: LD_ADDR_EXP 105
64005: PUSH
64006: LD_INT 0
64008: ST_TO_ADDR
// sSpec := false ;
64009: LD_ADDR_EXP 102
64013: PUSH
64014: LD_INT 0
64016: ST_TO_ADDR
// sLevel := false ;
64017: LD_ADDR_EXP 106
64021: PUSH
64022: LD_INT 0
64024: ST_TO_ADDR
// sArmoury := false ;
64025: LD_ADDR_EXP 107
64029: PUSH
64030: LD_INT 0
64032: ST_TO_ADDR
// sRadar := false ;
64033: LD_ADDR_EXP 108
64037: PUSH
64038: LD_INT 0
64040: ST_TO_ADDR
// sBunker := false ;
64041: LD_ADDR_EXP 109
64045: PUSH
64046: LD_INT 0
64048: ST_TO_ADDR
// sHack := false ;
64049: LD_ADDR_EXP 110
64053: PUSH
64054: LD_INT 0
64056: ST_TO_ADDR
// sFire := false ;
64057: LD_ADDR_EXP 111
64061: PUSH
64062: LD_INT 0
64064: ST_TO_ADDR
// sRefresh := false ;
64065: LD_ADDR_EXP 112
64069: PUSH
64070: LD_INT 0
64072: ST_TO_ADDR
// sExp := false ;
64073: LD_ADDR_EXP 113
64077: PUSH
64078: LD_INT 0
64080: ST_TO_ADDR
// sDepot := false ;
64081: LD_ADDR_EXP 114
64085: PUSH
64086: LD_INT 0
64088: ST_TO_ADDR
// sFlag := false ;
64089: LD_ADDR_EXP 115
64093: PUSH
64094: LD_INT 0
64096: ST_TO_ADDR
// sKamikadze := false ;
64097: LD_ADDR_EXP 123
64101: PUSH
64102: LD_INT 0
64104: ST_TO_ADDR
// sTroll := false ;
64105: LD_ADDR_EXP 124
64109: PUSH
64110: LD_INT 0
64112: ST_TO_ADDR
// sSlow := false ;
64113: LD_ADDR_EXP 125
64117: PUSH
64118: LD_INT 0
64120: ST_TO_ADDR
// sLack := false ;
64121: LD_ADDR_EXP 126
64125: PUSH
64126: LD_INT 0
64128: ST_TO_ADDR
// sTank := false ;
64129: LD_ADDR_EXP 128
64133: PUSH
64134: LD_INT 0
64136: ST_TO_ADDR
// sRemote := false ;
64137: LD_ADDR_EXP 129
64141: PUSH
64142: LD_INT 0
64144: ST_TO_ADDR
// sPowell := false ;
64145: LD_ADDR_EXP 130
64149: PUSH
64150: LD_INT 0
64152: ST_TO_ADDR
// sTeleport := false ;
64153: LD_ADDR_EXP 133
64157: PUSH
64158: LD_INT 0
64160: ST_TO_ADDR
// sOilTower := false ;
64161: LD_ADDR_EXP 135
64165: PUSH
64166: LD_INT 0
64168: ST_TO_ADDR
// sShovel := false ;
64169: LD_ADDR_EXP 136
64173: PUSH
64174: LD_INT 0
64176: ST_TO_ADDR
// sSheik := false ;
64177: LD_ADDR_EXP 137
64181: PUSH
64182: LD_INT 0
64184: ST_TO_ADDR
// sEarthquake := false ;
64185: LD_ADDR_EXP 139
64189: PUSH
64190: LD_INT 0
64192: ST_TO_ADDR
// sAI := false ;
64193: LD_ADDR_EXP 140
64197: PUSH
64198: LD_INT 0
64200: ST_TO_ADDR
// sCargo := false ;
64201: LD_ADDR_EXP 143
64205: PUSH
64206: LD_INT 0
64208: ST_TO_ADDR
// sDLaser := false ;
64209: LD_ADDR_EXP 144
64213: PUSH
64214: LD_INT 0
64216: ST_TO_ADDR
// sExchange := false ;
64217: LD_ADDR_EXP 145
64221: PUSH
64222: LD_INT 0
64224: ST_TO_ADDR
// sFac := false ;
64225: LD_ADDR_EXP 146
64229: PUSH
64230: LD_INT 0
64232: ST_TO_ADDR
// sPower := false ;
64233: LD_ADDR_EXP 147
64237: PUSH
64238: LD_INT 0
64240: ST_TO_ADDR
// sRandom := false ;
64241: LD_ADDR_EXP 148
64245: PUSH
64246: LD_INT 0
64248: ST_TO_ADDR
// sShield := false ;
64249: LD_ADDR_EXP 149
64253: PUSH
64254: LD_INT 0
64256: ST_TO_ADDR
// sTime := false ;
64257: LD_ADDR_EXP 150
64261: PUSH
64262: LD_INT 0
64264: ST_TO_ADDR
// sTools := false ;
64265: LD_ADDR_EXP 151
64269: PUSH
64270: LD_INT 0
64272: ST_TO_ADDR
// sSold := false ;
64273: LD_ADDR_EXP 116
64277: PUSH
64278: LD_INT 0
64280: ST_TO_ADDR
// sDiff := false ;
64281: LD_ADDR_EXP 117
64285: PUSH
64286: LD_INT 0
64288: ST_TO_ADDR
// sFog := false ;
64289: LD_ADDR_EXP 120
64293: PUSH
64294: LD_INT 0
64296: ST_TO_ADDR
// sReset := false ;
64297: LD_ADDR_EXP 121
64301: PUSH
64302: LD_INT 0
64304: ST_TO_ADDR
// sSun := false ;
64305: LD_ADDR_EXP 122
64309: PUSH
64310: LD_INT 0
64312: ST_TO_ADDR
// sTiger := false ;
64313: LD_ADDR_EXP 118
64317: PUSH
64318: LD_INT 0
64320: ST_TO_ADDR
// sBomb := false ;
64321: LD_ADDR_EXP 119
64325: PUSH
64326: LD_INT 0
64328: ST_TO_ADDR
// sWound := false ;
64329: LD_ADDR_EXP 127
64333: PUSH
64334: LD_INT 0
64336: ST_TO_ADDR
// sBetray := false ;
64337: LD_ADDR_EXP 131
64341: PUSH
64342: LD_INT 0
64344: ST_TO_ADDR
// sContamin := false ;
64345: LD_ADDR_EXP 132
64349: PUSH
64350: LD_INT 0
64352: ST_TO_ADDR
// sOil := false ;
64353: LD_ADDR_EXP 134
64357: PUSH
64358: LD_INT 0
64360: ST_TO_ADDR
// sStu := false ;
64361: LD_ADDR_EXP 138
64365: PUSH
64366: LD_INT 0
64368: ST_TO_ADDR
// sBazooka := false ;
64369: LD_ADDR_EXP 141
64373: PUSH
64374: LD_INT 0
64376: ST_TO_ADDR
// sMortar := false ;
64377: LD_ADDR_EXP 142
64381: PUSH
64382: LD_INT 0
64384: ST_TO_ADDR
// sRanger := false ;
64385: LD_ADDR_EXP 152
64389: PUSH
64390: LD_INT 0
64392: ST_TO_ADDR
// sComputer := false ;
64393: LD_ADDR_EXP 153
64397: PUSH
64398: LD_INT 0
64400: ST_TO_ADDR
// s30 := false ;
64401: LD_ADDR_EXP 154
64405: PUSH
64406: LD_INT 0
64408: ST_TO_ADDR
// s60 := false ;
64409: LD_ADDR_EXP 155
64413: PUSH
64414: LD_INT 0
64416: ST_TO_ADDR
// end ;
64417: LD_VAR 0 1
64421: RET
// function DefineStreamItems ( ) ; var tmp , normal , hardcore , i ; begin
64422: LD_INT 0
64424: PPUSH
64425: PPUSH
64426: PPUSH
64427: PPUSH
64428: PPUSH
// result := [ ] ;
64429: LD_ADDR_VAR 0 1
64433: PUSH
64434: EMPTY
64435: ST_TO_ADDR
// if campaign_id = 1 then
64436: LD_OWVAR 69
64440: PUSH
64441: LD_INT 1
64443: EQUAL
64444: IFFALSE 67610
// begin case mission_number of 1 :
64446: LD_OWVAR 70
64450: PUSH
64451: LD_INT 1
64453: DOUBLE
64454: EQUAL
64455: IFTRUE 64459
64457: GO 64535
64459: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 , 116 , 117 , 118 ] ] ; 2 :
64460: LD_ADDR_VAR 0 1
64464: PUSH
64465: LD_INT 2
64467: PUSH
64468: LD_INT 4
64470: PUSH
64471: LD_INT 11
64473: PUSH
64474: LD_INT 12
64476: PUSH
64477: LD_INT 15
64479: PUSH
64480: LD_INT 16
64482: PUSH
64483: LD_INT 22
64485: PUSH
64486: LD_INT 23
64488: PUSH
64489: LD_INT 26
64491: PUSH
64492: EMPTY
64493: LIST
64494: LIST
64495: LIST
64496: LIST
64497: LIST
64498: LIST
64499: LIST
64500: LIST
64501: LIST
64502: PUSH
64503: LD_INT 101
64505: PUSH
64506: LD_INT 102
64508: PUSH
64509: LD_INT 106
64511: PUSH
64512: LD_INT 116
64514: PUSH
64515: LD_INT 117
64517: PUSH
64518: LD_INT 118
64520: PUSH
64521: EMPTY
64522: LIST
64523: LIST
64524: LIST
64525: LIST
64526: LIST
64527: LIST
64528: PUSH
64529: EMPTY
64530: LIST
64531: LIST
64532: ST_TO_ADDR
64533: GO 67608
64535: LD_INT 2
64537: DOUBLE
64538: EQUAL
64539: IFTRUE 64543
64541: GO 64627
64543: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 3 :
64544: LD_ADDR_VAR 0 1
64548: PUSH
64549: LD_INT 2
64551: PUSH
64552: LD_INT 4
64554: PUSH
64555: LD_INT 11
64557: PUSH
64558: LD_INT 12
64560: PUSH
64561: LD_INT 15
64563: PUSH
64564: LD_INT 16
64566: PUSH
64567: LD_INT 22
64569: PUSH
64570: LD_INT 23
64572: PUSH
64573: LD_INT 26
64575: PUSH
64576: EMPTY
64577: LIST
64578: LIST
64579: LIST
64580: LIST
64581: LIST
64582: LIST
64583: LIST
64584: LIST
64585: LIST
64586: PUSH
64587: LD_INT 101
64589: PUSH
64590: LD_INT 102
64592: PUSH
64593: LD_INT 105
64595: PUSH
64596: LD_INT 106
64598: PUSH
64599: LD_INT 108
64601: PUSH
64602: LD_INT 116
64604: PUSH
64605: LD_INT 117
64607: PUSH
64608: LD_INT 118
64610: PUSH
64611: EMPTY
64612: LIST
64613: LIST
64614: LIST
64615: LIST
64616: LIST
64617: LIST
64618: LIST
64619: LIST
64620: PUSH
64621: EMPTY
64622: LIST
64623: LIST
64624: ST_TO_ADDR
64625: GO 67608
64627: LD_INT 3
64629: DOUBLE
64630: EQUAL
64631: IFTRUE 64635
64633: GO 64723
64635: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 4 :
64636: LD_ADDR_VAR 0 1
64640: PUSH
64641: LD_INT 2
64643: PUSH
64644: LD_INT 4
64646: PUSH
64647: LD_INT 5
64649: PUSH
64650: LD_INT 11
64652: PUSH
64653: LD_INT 12
64655: PUSH
64656: LD_INT 15
64658: PUSH
64659: LD_INT 16
64661: PUSH
64662: LD_INT 22
64664: PUSH
64665: LD_INT 26
64667: PUSH
64668: LD_INT 36
64670: PUSH
64671: EMPTY
64672: LIST
64673: LIST
64674: LIST
64675: LIST
64676: LIST
64677: LIST
64678: LIST
64679: LIST
64680: LIST
64681: LIST
64682: PUSH
64683: LD_INT 101
64685: PUSH
64686: LD_INT 102
64688: PUSH
64689: LD_INT 105
64691: PUSH
64692: LD_INT 106
64694: PUSH
64695: LD_INT 108
64697: PUSH
64698: LD_INT 116
64700: PUSH
64701: LD_INT 117
64703: PUSH
64704: LD_INT 118
64706: PUSH
64707: EMPTY
64708: LIST
64709: LIST
64710: LIST
64711: LIST
64712: LIST
64713: LIST
64714: LIST
64715: LIST
64716: PUSH
64717: EMPTY
64718: LIST
64719: LIST
64720: ST_TO_ADDR
64721: GO 67608
64723: LD_INT 4
64725: DOUBLE
64726: EQUAL
64727: IFTRUE 64731
64729: GO 64827
64731: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 5 :
64732: LD_ADDR_VAR 0 1
64736: PUSH
64737: LD_INT 2
64739: PUSH
64740: LD_INT 4
64742: PUSH
64743: LD_INT 5
64745: PUSH
64746: LD_INT 8
64748: PUSH
64749: LD_INT 11
64751: PUSH
64752: LD_INT 12
64754: PUSH
64755: LD_INT 15
64757: PUSH
64758: LD_INT 16
64760: PUSH
64761: LD_INT 22
64763: PUSH
64764: LD_INT 23
64766: PUSH
64767: LD_INT 26
64769: PUSH
64770: LD_INT 36
64772: PUSH
64773: EMPTY
64774: LIST
64775: LIST
64776: LIST
64777: LIST
64778: LIST
64779: LIST
64780: LIST
64781: LIST
64782: LIST
64783: LIST
64784: LIST
64785: LIST
64786: PUSH
64787: LD_INT 101
64789: PUSH
64790: LD_INT 102
64792: PUSH
64793: LD_INT 105
64795: PUSH
64796: LD_INT 106
64798: PUSH
64799: LD_INT 108
64801: PUSH
64802: LD_INT 116
64804: PUSH
64805: LD_INT 117
64807: PUSH
64808: LD_INT 118
64810: PUSH
64811: EMPTY
64812: LIST
64813: LIST
64814: LIST
64815: LIST
64816: LIST
64817: LIST
64818: LIST
64819: LIST
64820: PUSH
64821: EMPTY
64822: LIST
64823: LIST
64824: ST_TO_ADDR
64825: GO 67608
64827: LD_INT 5
64829: DOUBLE
64830: EQUAL
64831: IFTRUE 64835
64833: GO 64947
64835: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 6 :
64836: LD_ADDR_VAR 0 1
64840: PUSH
64841: LD_INT 2
64843: PUSH
64844: LD_INT 4
64846: PUSH
64847: LD_INT 5
64849: PUSH
64850: LD_INT 6
64852: PUSH
64853: LD_INT 8
64855: PUSH
64856: LD_INT 11
64858: PUSH
64859: LD_INT 12
64861: PUSH
64862: LD_INT 15
64864: PUSH
64865: LD_INT 16
64867: PUSH
64868: LD_INT 22
64870: PUSH
64871: LD_INT 23
64873: PUSH
64874: LD_INT 25
64876: PUSH
64877: LD_INT 26
64879: PUSH
64880: LD_INT 36
64882: PUSH
64883: EMPTY
64884: LIST
64885: LIST
64886: LIST
64887: LIST
64888: LIST
64889: LIST
64890: LIST
64891: LIST
64892: LIST
64893: LIST
64894: LIST
64895: LIST
64896: LIST
64897: LIST
64898: PUSH
64899: LD_INT 101
64901: PUSH
64902: LD_INT 102
64904: PUSH
64905: LD_INT 105
64907: PUSH
64908: LD_INT 106
64910: PUSH
64911: LD_INT 108
64913: PUSH
64914: LD_INT 109
64916: PUSH
64917: LD_INT 112
64919: PUSH
64920: LD_INT 116
64922: PUSH
64923: LD_INT 117
64925: PUSH
64926: LD_INT 118
64928: PUSH
64929: EMPTY
64930: LIST
64931: LIST
64932: LIST
64933: LIST
64934: LIST
64935: LIST
64936: LIST
64937: LIST
64938: LIST
64939: LIST
64940: PUSH
64941: EMPTY
64942: LIST
64943: LIST
64944: ST_TO_ADDR
64945: GO 67608
64947: LD_INT 6
64949: DOUBLE
64950: EQUAL
64951: IFTRUE 64955
64953: GO 65087
64955: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 7 :
64956: LD_ADDR_VAR 0 1
64960: PUSH
64961: LD_INT 2
64963: PUSH
64964: LD_INT 4
64966: PUSH
64967: LD_INT 5
64969: PUSH
64970: LD_INT 6
64972: PUSH
64973: LD_INT 8
64975: PUSH
64976: LD_INT 11
64978: PUSH
64979: LD_INT 12
64981: PUSH
64982: LD_INT 15
64984: PUSH
64985: LD_INT 16
64987: PUSH
64988: LD_INT 20
64990: PUSH
64991: LD_INT 21
64993: PUSH
64994: LD_INT 22
64996: PUSH
64997: LD_INT 23
64999: PUSH
65000: LD_INT 25
65002: PUSH
65003: LD_INT 26
65005: PUSH
65006: LD_INT 30
65008: PUSH
65009: LD_INT 31
65011: PUSH
65012: LD_INT 32
65014: PUSH
65015: LD_INT 36
65017: PUSH
65018: EMPTY
65019: LIST
65020: LIST
65021: LIST
65022: LIST
65023: LIST
65024: LIST
65025: LIST
65026: LIST
65027: LIST
65028: LIST
65029: LIST
65030: LIST
65031: LIST
65032: LIST
65033: LIST
65034: LIST
65035: LIST
65036: LIST
65037: LIST
65038: PUSH
65039: LD_INT 101
65041: PUSH
65042: LD_INT 102
65044: PUSH
65045: LD_INT 105
65047: PUSH
65048: LD_INT 106
65050: PUSH
65051: LD_INT 108
65053: PUSH
65054: LD_INT 109
65056: PUSH
65057: LD_INT 112
65059: PUSH
65060: LD_INT 116
65062: PUSH
65063: LD_INT 117
65065: PUSH
65066: LD_INT 118
65068: PUSH
65069: EMPTY
65070: LIST
65071: LIST
65072: LIST
65073: LIST
65074: LIST
65075: LIST
65076: LIST
65077: LIST
65078: LIST
65079: LIST
65080: PUSH
65081: EMPTY
65082: LIST
65083: LIST
65084: ST_TO_ADDR
65085: GO 67608
65087: LD_INT 7
65089: DOUBLE
65090: EQUAL
65091: IFTRUE 65095
65093: GO 65207
65095: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 , 116 , 117 , 118 ] ] ; 8 :
65096: LD_ADDR_VAR 0 1
65100: PUSH
65101: LD_INT 2
65103: PUSH
65104: LD_INT 4
65106: PUSH
65107: LD_INT 5
65109: PUSH
65110: LD_INT 7
65112: PUSH
65113: LD_INT 11
65115: PUSH
65116: LD_INT 12
65118: PUSH
65119: LD_INT 15
65121: PUSH
65122: LD_INT 16
65124: PUSH
65125: LD_INT 20
65127: PUSH
65128: LD_INT 21
65130: PUSH
65131: LD_INT 22
65133: PUSH
65134: LD_INT 23
65136: PUSH
65137: LD_INT 25
65139: PUSH
65140: LD_INT 26
65142: PUSH
65143: EMPTY
65144: LIST
65145: LIST
65146: LIST
65147: LIST
65148: LIST
65149: LIST
65150: LIST
65151: LIST
65152: LIST
65153: LIST
65154: LIST
65155: LIST
65156: LIST
65157: LIST
65158: PUSH
65159: LD_INT 101
65161: PUSH
65162: LD_INT 102
65164: PUSH
65165: LD_INT 103
65167: PUSH
65168: LD_INT 105
65170: PUSH
65171: LD_INT 106
65173: PUSH
65174: LD_INT 108
65176: PUSH
65177: LD_INT 112
65179: PUSH
65180: LD_INT 116
65182: PUSH
65183: LD_INT 117
65185: PUSH
65186: LD_INT 118
65188: PUSH
65189: EMPTY
65190: LIST
65191: LIST
65192: LIST
65193: LIST
65194: LIST
65195: LIST
65196: LIST
65197: LIST
65198: LIST
65199: LIST
65200: PUSH
65201: EMPTY
65202: LIST
65203: LIST
65204: ST_TO_ADDR
65205: GO 67608
65207: LD_INT 8
65209: DOUBLE
65210: EQUAL
65211: IFTRUE 65215
65213: GO 65355
65215: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 9 :
65216: LD_ADDR_VAR 0 1
65220: PUSH
65221: LD_INT 2
65223: PUSH
65224: LD_INT 4
65226: PUSH
65227: LD_INT 5
65229: PUSH
65230: LD_INT 6
65232: PUSH
65233: LD_INT 7
65235: PUSH
65236: LD_INT 8
65238: PUSH
65239: LD_INT 11
65241: PUSH
65242: LD_INT 12
65244: PUSH
65245: LD_INT 15
65247: PUSH
65248: LD_INT 16
65250: PUSH
65251: LD_INT 20
65253: PUSH
65254: LD_INT 21
65256: PUSH
65257: LD_INT 22
65259: PUSH
65260: LD_INT 23
65262: PUSH
65263: LD_INT 25
65265: PUSH
65266: LD_INT 26
65268: PUSH
65269: LD_INT 30
65271: PUSH
65272: LD_INT 31
65274: PUSH
65275: LD_INT 32
65277: PUSH
65278: LD_INT 36
65280: PUSH
65281: EMPTY
65282: LIST
65283: LIST
65284: LIST
65285: LIST
65286: LIST
65287: LIST
65288: LIST
65289: LIST
65290: LIST
65291: LIST
65292: LIST
65293: LIST
65294: LIST
65295: LIST
65296: LIST
65297: LIST
65298: LIST
65299: LIST
65300: LIST
65301: LIST
65302: PUSH
65303: LD_INT 101
65305: PUSH
65306: LD_INT 102
65308: PUSH
65309: LD_INT 103
65311: PUSH
65312: LD_INT 105
65314: PUSH
65315: LD_INT 106
65317: PUSH
65318: LD_INT 108
65320: PUSH
65321: LD_INT 109
65323: PUSH
65324: LD_INT 112
65326: PUSH
65327: LD_INT 116
65329: PUSH
65330: LD_INT 117
65332: PUSH
65333: LD_INT 118
65335: PUSH
65336: EMPTY
65337: LIST
65338: LIST
65339: LIST
65340: LIST
65341: LIST
65342: LIST
65343: LIST
65344: LIST
65345: LIST
65346: LIST
65347: LIST
65348: PUSH
65349: EMPTY
65350: LIST
65351: LIST
65352: ST_TO_ADDR
65353: GO 67608
65355: LD_INT 9
65357: DOUBLE
65358: EQUAL
65359: IFTRUE 65363
65361: GO 65511
65363: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 , 116 , 117 , 118 ] ] ; 10 :
65364: LD_ADDR_VAR 0 1
65368: PUSH
65369: LD_INT 2
65371: PUSH
65372: LD_INT 4
65374: PUSH
65375: LD_INT 5
65377: PUSH
65378: LD_INT 6
65380: PUSH
65381: LD_INT 7
65383: PUSH
65384: LD_INT 8
65386: PUSH
65387: LD_INT 11
65389: PUSH
65390: LD_INT 12
65392: PUSH
65393: LD_INT 15
65395: PUSH
65396: LD_INT 16
65398: PUSH
65399: LD_INT 20
65401: PUSH
65402: LD_INT 21
65404: PUSH
65405: LD_INT 22
65407: PUSH
65408: LD_INT 23
65410: PUSH
65411: LD_INT 25
65413: PUSH
65414: LD_INT 26
65416: PUSH
65417: LD_INT 28
65419: PUSH
65420: LD_INT 30
65422: PUSH
65423: LD_INT 31
65425: PUSH
65426: LD_INT 32
65428: PUSH
65429: LD_INT 36
65431: PUSH
65432: EMPTY
65433: LIST
65434: LIST
65435: LIST
65436: LIST
65437: LIST
65438: LIST
65439: LIST
65440: LIST
65441: LIST
65442: LIST
65443: LIST
65444: LIST
65445: LIST
65446: LIST
65447: LIST
65448: LIST
65449: LIST
65450: LIST
65451: LIST
65452: LIST
65453: LIST
65454: PUSH
65455: LD_INT 101
65457: PUSH
65458: LD_INT 102
65460: PUSH
65461: LD_INT 103
65463: PUSH
65464: LD_INT 105
65466: PUSH
65467: LD_INT 106
65469: PUSH
65470: LD_INT 108
65472: PUSH
65473: LD_INT 109
65475: PUSH
65476: LD_INT 112
65478: PUSH
65479: LD_INT 114
65481: PUSH
65482: LD_INT 116
65484: PUSH
65485: LD_INT 117
65487: PUSH
65488: LD_INT 118
65490: PUSH
65491: EMPTY
65492: LIST
65493: LIST
65494: LIST
65495: LIST
65496: LIST
65497: LIST
65498: LIST
65499: LIST
65500: LIST
65501: LIST
65502: LIST
65503: LIST
65504: PUSH
65505: EMPTY
65506: LIST
65507: LIST
65508: ST_TO_ADDR
65509: GO 67608
65511: LD_INT 10
65513: DOUBLE
65514: EQUAL
65515: IFTRUE 65519
65517: GO 65715
65519: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 11 :
65520: LD_ADDR_VAR 0 1
65524: PUSH
65525: LD_INT 2
65527: PUSH
65528: LD_INT 4
65530: PUSH
65531: LD_INT 5
65533: PUSH
65534: LD_INT 6
65536: PUSH
65537: LD_INT 7
65539: PUSH
65540: LD_INT 8
65542: PUSH
65543: LD_INT 9
65545: PUSH
65546: LD_INT 10
65548: PUSH
65549: LD_INT 11
65551: PUSH
65552: LD_INT 12
65554: PUSH
65555: LD_INT 13
65557: PUSH
65558: LD_INT 14
65560: PUSH
65561: LD_INT 15
65563: PUSH
65564: LD_INT 16
65566: PUSH
65567: LD_INT 17
65569: PUSH
65570: LD_INT 18
65572: PUSH
65573: LD_INT 19
65575: PUSH
65576: LD_INT 20
65578: PUSH
65579: LD_INT 21
65581: PUSH
65582: LD_INT 22
65584: PUSH
65585: LD_INT 23
65587: PUSH
65588: LD_INT 24
65590: PUSH
65591: LD_INT 25
65593: PUSH
65594: LD_INT 26
65596: PUSH
65597: LD_INT 28
65599: PUSH
65600: LD_INT 30
65602: PUSH
65603: LD_INT 31
65605: PUSH
65606: LD_INT 32
65608: PUSH
65609: LD_INT 36
65611: PUSH
65612: EMPTY
65613: LIST
65614: LIST
65615: LIST
65616: LIST
65617: LIST
65618: LIST
65619: LIST
65620: LIST
65621: LIST
65622: LIST
65623: LIST
65624: LIST
65625: LIST
65626: LIST
65627: LIST
65628: LIST
65629: LIST
65630: LIST
65631: LIST
65632: LIST
65633: LIST
65634: LIST
65635: LIST
65636: LIST
65637: LIST
65638: LIST
65639: LIST
65640: LIST
65641: LIST
65642: PUSH
65643: LD_INT 101
65645: PUSH
65646: LD_INT 102
65648: PUSH
65649: LD_INT 103
65651: PUSH
65652: LD_INT 104
65654: PUSH
65655: LD_INT 105
65657: PUSH
65658: LD_INT 106
65660: PUSH
65661: LD_INT 107
65663: PUSH
65664: LD_INT 108
65666: PUSH
65667: LD_INT 109
65669: PUSH
65670: LD_INT 110
65672: PUSH
65673: LD_INT 111
65675: PUSH
65676: LD_INT 112
65678: PUSH
65679: LD_INT 114
65681: PUSH
65682: LD_INT 116
65684: PUSH
65685: LD_INT 117
65687: PUSH
65688: LD_INT 118
65690: PUSH
65691: EMPTY
65692: LIST
65693: LIST
65694: LIST
65695: LIST
65696: LIST
65697: LIST
65698: LIST
65699: LIST
65700: LIST
65701: LIST
65702: LIST
65703: LIST
65704: LIST
65705: LIST
65706: LIST
65707: LIST
65708: PUSH
65709: EMPTY
65710: LIST
65711: LIST
65712: ST_TO_ADDR
65713: GO 67608
65715: LD_INT 11
65717: DOUBLE
65718: EQUAL
65719: IFTRUE 65723
65721: GO 65927
65723: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 12 :
65724: LD_ADDR_VAR 0 1
65728: PUSH
65729: LD_INT 2
65731: PUSH
65732: LD_INT 3
65734: PUSH
65735: LD_INT 4
65737: PUSH
65738: LD_INT 5
65740: PUSH
65741: LD_INT 6
65743: PUSH
65744: LD_INT 7
65746: PUSH
65747: LD_INT 8
65749: PUSH
65750: LD_INT 9
65752: PUSH
65753: LD_INT 10
65755: PUSH
65756: LD_INT 11
65758: PUSH
65759: LD_INT 12
65761: PUSH
65762: LD_INT 13
65764: PUSH
65765: LD_INT 14
65767: PUSH
65768: LD_INT 15
65770: PUSH
65771: LD_INT 16
65773: PUSH
65774: LD_INT 17
65776: PUSH
65777: LD_INT 18
65779: PUSH
65780: LD_INT 19
65782: PUSH
65783: LD_INT 20
65785: PUSH
65786: LD_INT 21
65788: PUSH
65789: LD_INT 22
65791: PUSH
65792: LD_INT 23
65794: PUSH
65795: LD_INT 24
65797: PUSH
65798: LD_INT 25
65800: PUSH
65801: LD_INT 26
65803: PUSH
65804: LD_INT 28
65806: PUSH
65807: LD_INT 30
65809: PUSH
65810: LD_INT 31
65812: PUSH
65813: LD_INT 32
65815: PUSH
65816: LD_INT 34
65818: PUSH
65819: LD_INT 36
65821: PUSH
65822: EMPTY
65823: LIST
65824: LIST
65825: LIST
65826: LIST
65827: LIST
65828: LIST
65829: LIST
65830: LIST
65831: LIST
65832: LIST
65833: LIST
65834: LIST
65835: LIST
65836: LIST
65837: LIST
65838: LIST
65839: LIST
65840: LIST
65841: LIST
65842: LIST
65843: LIST
65844: LIST
65845: LIST
65846: LIST
65847: LIST
65848: LIST
65849: LIST
65850: LIST
65851: LIST
65852: LIST
65853: LIST
65854: PUSH
65855: LD_INT 101
65857: PUSH
65858: LD_INT 102
65860: PUSH
65861: LD_INT 103
65863: PUSH
65864: LD_INT 104
65866: PUSH
65867: LD_INT 105
65869: PUSH
65870: LD_INT 106
65872: PUSH
65873: LD_INT 107
65875: PUSH
65876: LD_INT 108
65878: PUSH
65879: LD_INT 109
65881: PUSH
65882: LD_INT 110
65884: PUSH
65885: LD_INT 111
65887: PUSH
65888: LD_INT 112
65890: PUSH
65891: LD_INT 114
65893: PUSH
65894: LD_INT 116
65896: PUSH
65897: LD_INT 117
65899: PUSH
65900: LD_INT 118
65902: PUSH
65903: EMPTY
65904: LIST
65905: LIST
65906: LIST
65907: LIST
65908: LIST
65909: LIST
65910: LIST
65911: LIST
65912: LIST
65913: LIST
65914: LIST
65915: LIST
65916: LIST
65917: LIST
65918: LIST
65919: LIST
65920: PUSH
65921: EMPTY
65922: LIST
65923: LIST
65924: ST_TO_ADDR
65925: GO 67608
65927: LD_INT 12
65929: DOUBLE
65930: EQUAL
65931: IFTRUE 65935
65933: GO 66155
65935: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 13 :
65936: LD_ADDR_VAR 0 1
65940: PUSH
65941: LD_INT 1
65943: PUSH
65944: LD_INT 2
65946: PUSH
65947: LD_INT 3
65949: PUSH
65950: LD_INT 4
65952: PUSH
65953: LD_INT 5
65955: PUSH
65956: LD_INT 6
65958: PUSH
65959: LD_INT 7
65961: PUSH
65962: LD_INT 8
65964: PUSH
65965: LD_INT 9
65967: PUSH
65968: LD_INT 10
65970: PUSH
65971: LD_INT 11
65973: PUSH
65974: LD_INT 12
65976: PUSH
65977: LD_INT 13
65979: PUSH
65980: LD_INT 14
65982: PUSH
65983: LD_INT 15
65985: PUSH
65986: LD_INT 16
65988: PUSH
65989: LD_INT 17
65991: PUSH
65992: LD_INT 18
65994: PUSH
65995: LD_INT 19
65997: PUSH
65998: LD_INT 20
66000: PUSH
66001: LD_INT 21
66003: PUSH
66004: LD_INT 22
66006: PUSH
66007: LD_INT 23
66009: PUSH
66010: LD_INT 24
66012: PUSH
66013: LD_INT 25
66015: PUSH
66016: LD_INT 26
66018: PUSH
66019: LD_INT 27
66021: PUSH
66022: LD_INT 28
66024: PUSH
66025: LD_INT 30
66027: PUSH
66028: LD_INT 31
66030: PUSH
66031: LD_INT 32
66033: PUSH
66034: LD_INT 33
66036: PUSH
66037: LD_INT 34
66039: PUSH
66040: LD_INT 36
66042: PUSH
66043: EMPTY
66044: LIST
66045: LIST
66046: LIST
66047: LIST
66048: LIST
66049: LIST
66050: LIST
66051: LIST
66052: LIST
66053: LIST
66054: LIST
66055: LIST
66056: LIST
66057: LIST
66058: LIST
66059: LIST
66060: LIST
66061: LIST
66062: LIST
66063: LIST
66064: LIST
66065: LIST
66066: LIST
66067: LIST
66068: LIST
66069: LIST
66070: LIST
66071: LIST
66072: LIST
66073: LIST
66074: LIST
66075: LIST
66076: LIST
66077: LIST
66078: PUSH
66079: LD_INT 101
66081: PUSH
66082: LD_INT 102
66084: PUSH
66085: LD_INT 103
66087: PUSH
66088: LD_INT 104
66090: PUSH
66091: LD_INT 105
66093: PUSH
66094: LD_INT 106
66096: PUSH
66097: LD_INT 107
66099: PUSH
66100: LD_INT 108
66102: PUSH
66103: LD_INT 109
66105: PUSH
66106: LD_INT 110
66108: PUSH
66109: LD_INT 111
66111: PUSH
66112: LD_INT 112
66114: PUSH
66115: LD_INT 113
66117: PUSH
66118: LD_INT 114
66120: PUSH
66121: LD_INT 116
66123: PUSH
66124: LD_INT 117
66126: PUSH
66127: LD_INT 118
66129: PUSH
66130: EMPTY
66131: LIST
66132: LIST
66133: LIST
66134: LIST
66135: LIST
66136: LIST
66137: LIST
66138: LIST
66139: LIST
66140: LIST
66141: LIST
66142: LIST
66143: LIST
66144: LIST
66145: LIST
66146: LIST
66147: LIST
66148: PUSH
66149: EMPTY
66150: LIST
66151: LIST
66152: ST_TO_ADDR
66153: GO 67608
66155: LD_INT 13
66157: DOUBLE
66158: EQUAL
66159: IFTRUE 66163
66161: GO 66371
66163: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 14 :
66164: LD_ADDR_VAR 0 1
66168: PUSH
66169: LD_INT 1
66171: PUSH
66172: LD_INT 2
66174: PUSH
66175: LD_INT 3
66177: PUSH
66178: LD_INT 4
66180: PUSH
66181: LD_INT 5
66183: PUSH
66184: LD_INT 8
66186: PUSH
66187: LD_INT 9
66189: PUSH
66190: LD_INT 10
66192: PUSH
66193: LD_INT 11
66195: PUSH
66196: LD_INT 12
66198: PUSH
66199: LD_INT 14
66201: PUSH
66202: LD_INT 15
66204: PUSH
66205: LD_INT 16
66207: PUSH
66208: LD_INT 17
66210: PUSH
66211: LD_INT 18
66213: PUSH
66214: LD_INT 19
66216: PUSH
66217: LD_INT 20
66219: PUSH
66220: LD_INT 21
66222: PUSH
66223: LD_INT 22
66225: PUSH
66226: LD_INT 23
66228: PUSH
66229: LD_INT 24
66231: PUSH
66232: LD_INT 25
66234: PUSH
66235: LD_INT 26
66237: PUSH
66238: LD_INT 27
66240: PUSH
66241: LD_INT 28
66243: PUSH
66244: LD_INT 30
66246: PUSH
66247: LD_INT 31
66249: PUSH
66250: LD_INT 32
66252: PUSH
66253: LD_INT 33
66255: PUSH
66256: LD_INT 34
66258: PUSH
66259: LD_INT 36
66261: PUSH
66262: EMPTY
66263: LIST
66264: LIST
66265: LIST
66266: LIST
66267: LIST
66268: LIST
66269: LIST
66270: LIST
66271: LIST
66272: LIST
66273: LIST
66274: LIST
66275: LIST
66276: LIST
66277: LIST
66278: LIST
66279: LIST
66280: LIST
66281: LIST
66282: LIST
66283: LIST
66284: LIST
66285: LIST
66286: LIST
66287: LIST
66288: LIST
66289: LIST
66290: LIST
66291: LIST
66292: LIST
66293: LIST
66294: PUSH
66295: LD_INT 101
66297: PUSH
66298: LD_INT 102
66300: PUSH
66301: LD_INT 103
66303: PUSH
66304: LD_INT 104
66306: PUSH
66307: LD_INT 105
66309: PUSH
66310: LD_INT 106
66312: PUSH
66313: LD_INT 107
66315: PUSH
66316: LD_INT 108
66318: PUSH
66319: LD_INT 109
66321: PUSH
66322: LD_INT 110
66324: PUSH
66325: LD_INT 111
66327: PUSH
66328: LD_INT 112
66330: PUSH
66331: LD_INT 113
66333: PUSH
66334: LD_INT 114
66336: PUSH
66337: LD_INT 116
66339: PUSH
66340: LD_INT 117
66342: PUSH
66343: LD_INT 118
66345: PUSH
66346: EMPTY
66347: LIST
66348: LIST
66349: LIST
66350: LIST
66351: LIST
66352: LIST
66353: LIST
66354: LIST
66355: LIST
66356: LIST
66357: LIST
66358: LIST
66359: LIST
66360: LIST
66361: LIST
66362: LIST
66363: LIST
66364: PUSH
66365: EMPTY
66366: LIST
66367: LIST
66368: ST_TO_ADDR
66369: GO 67608
66371: LD_INT 14
66373: DOUBLE
66374: EQUAL
66375: IFTRUE 66379
66377: GO 66603
66379: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 15 :
66380: LD_ADDR_VAR 0 1
66384: PUSH
66385: LD_INT 1
66387: PUSH
66388: LD_INT 2
66390: PUSH
66391: LD_INT 3
66393: PUSH
66394: LD_INT 4
66396: PUSH
66397: LD_INT 5
66399: PUSH
66400: LD_INT 6
66402: PUSH
66403: LD_INT 7
66405: PUSH
66406: LD_INT 8
66408: PUSH
66409: LD_INT 9
66411: PUSH
66412: LD_INT 10
66414: PUSH
66415: LD_INT 11
66417: PUSH
66418: LD_INT 12
66420: PUSH
66421: LD_INT 13
66423: PUSH
66424: LD_INT 14
66426: PUSH
66427: LD_INT 15
66429: PUSH
66430: LD_INT 16
66432: PUSH
66433: LD_INT 17
66435: PUSH
66436: LD_INT 18
66438: PUSH
66439: LD_INT 19
66441: PUSH
66442: LD_INT 20
66444: PUSH
66445: LD_INT 21
66447: PUSH
66448: LD_INT 22
66450: PUSH
66451: LD_INT 23
66453: PUSH
66454: LD_INT 24
66456: PUSH
66457: LD_INT 25
66459: PUSH
66460: LD_INT 26
66462: PUSH
66463: LD_INT 27
66465: PUSH
66466: LD_INT 28
66468: PUSH
66469: LD_INT 29
66471: PUSH
66472: LD_INT 30
66474: PUSH
66475: LD_INT 31
66477: PUSH
66478: LD_INT 32
66480: PUSH
66481: LD_INT 33
66483: PUSH
66484: LD_INT 34
66486: PUSH
66487: LD_INT 36
66489: PUSH
66490: EMPTY
66491: LIST
66492: LIST
66493: LIST
66494: LIST
66495: LIST
66496: LIST
66497: LIST
66498: LIST
66499: LIST
66500: LIST
66501: LIST
66502: LIST
66503: LIST
66504: LIST
66505: LIST
66506: LIST
66507: LIST
66508: LIST
66509: LIST
66510: LIST
66511: LIST
66512: LIST
66513: LIST
66514: LIST
66515: LIST
66516: LIST
66517: LIST
66518: LIST
66519: LIST
66520: LIST
66521: LIST
66522: LIST
66523: LIST
66524: LIST
66525: LIST
66526: PUSH
66527: LD_INT 101
66529: PUSH
66530: LD_INT 102
66532: PUSH
66533: LD_INT 103
66535: PUSH
66536: LD_INT 104
66538: PUSH
66539: LD_INT 105
66541: PUSH
66542: LD_INT 106
66544: PUSH
66545: LD_INT 107
66547: PUSH
66548: LD_INT 108
66550: PUSH
66551: LD_INT 109
66553: PUSH
66554: LD_INT 110
66556: PUSH
66557: LD_INT 111
66559: PUSH
66560: LD_INT 112
66562: PUSH
66563: LD_INT 113
66565: PUSH
66566: LD_INT 114
66568: PUSH
66569: LD_INT 116
66571: PUSH
66572: LD_INT 117
66574: PUSH
66575: LD_INT 118
66577: PUSH
66578: EMPTY
66579: LIST
66580: LIST
66581: LIST
66582: LIST
66583: LIST
66584: LIST
66585: LIST
66586: LIST
66587: LIST
66588: LIST
66589: LIST
66590: LIST
66591: LIST
66592: LIST
66593: LIST
66594: LIST
66595: LIST
66596: PUSH
66597: EMPTY
66598: LIST
66599: LIST
66600: ST_TO_ADDR
66601: GO 67608
66603: LD_INT 15
66605: DOUBLE
66606: EQUAL
66607: IFTRUE 66611
66609: GO 66835
66611: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 16 :
66612: LD_ADDR_VAR 0 1
66616: PUSH
66617: LD_INT 1
66619: PUSH
66620: LD_INT 2
66622: PUSH
66623: LD_INT 3
66625: PUSH
66626: LD_INT 4
66628: PUSH
66629: LD_INT 5
66631: PUSH
66632: LD_INT 6
66634: PUSH
66635: LD_INT 7
66637: PUSH
66638: LD_INT 8
66640: PUSH
66641: LD_INT 9
66643: PUSH
66644: LD_INT 10
66646: PUSH
66647: LD_INT 11
66649: PUSH
66650: LD_INT 12
66652: PUSH
66653: LD_INT 13
66655: PUSH
66656: LD_INT 14
66658: PUSH
66659: LD_INT 15
66661: PUSH
66662: LD_INT 16
66664: PUSH
66665: LD_INT 17
66667: PUSH
66668: LD_INT 18
66670: PUSH
66671: LD_INT 19
66673: PUSH
66674: LD_INT 20
66676: PUSH
66677: LD_INT 21
66679: PUSH
66680: LD_INT 22
66682: PUSH
66683: LD_INT 23
66685: PUSH
66686: LD_INT 24
66688: PUSH
66689: LD_INT 25
66691: PUSH
66692: LD_INT 26
66694: PUSH
66695: LD_INT 27
66697: PUSH
66698: LD_INT 28
66700: PUSH
66701: LD_INT 29
66703: PUSH
66704: LD_INT 30
66706: PUSH
66707: LD_INT 31
66709: PUSH
66710: LD_INT 32
66712: PUSH
66713: LD_INT 33
66715: PUSH
66716: LD_INT 34
66718: PUSH
66719: LD_INT 36
66721: PUSH
66722: EMPTY
66723: LIST
66724: LIST
66725: LIST
66726: LIST
66727: LIST
66728: LIST
66729: LIST
66730: LIST
66731: LIST
66732: LIST
66733: LIST
66734: LIST
66735: LIST
66736: LIST
66737: LIST
66738: LIST
66739: LIST
66740: LIST
66741: LIST
66742: LIST
66743: LIST
66744: LIST
66745: LIST
66746: LIST
66747: LIST
66748: LIST
66749: LIST
66750: LIST
66751: LIST
66752: LIST
66753: LIST
66754: LIST
66755: LIST
66756: LIST
66757: LIST
66758: PUSH
66759: LD_INT 101
66761: PUSH
66762: LD_INT 102
66764: PUSH
66765: LD_INT 103
66767: PUSH
66768: LD_INT 104
66770: PUSH
66771: LD_INT 105
66773: PUSH
66774: LD_INT 106
66776: PUSH
66777: LD_INT 107
66779: PUSH
66780: LD_INT 108
66782: PUSH
66783: LD_INT 109
66785: PUSH
66786: LD_INT 110
66788: PUSH
66789: LD_INT 111
66791: PUSH
66792: LD_INT 112
66794: PUSH
66795: LD_INT 113
66797: PUSH
66798: LD_INT 114
66800: PUSH
66801: LD_INT 116
66803: PUSH
66804: LD_INT 117
66806: PUSH
66807: LD_INT 118
66809: PUSH
66810: EMPTY
66811: LIST
66812: LIST
66813: LIST
66814: LIST
66815: LIST
66816: LIST
66817: LIST
66818: LIST
66819: LIST
66820: LIST
66821: LIST
66822: LIST
66823: LIST
66824: LIST
66825: LIST
66826: LIST
66827: LIST
66828: PUSH
66829: EMPTY
66830: LIST
66831: LIST
66832: ST_TO_ADDR
66833: GO 67608
66835: LD_INT 16
66837: DOUBLE
66838: EQUAL
66839: IFTRUE 66843
66841: GO 66979
66843: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 17 :
66844: LD_ADDR_VAR 0 1
66848: PUSH
66849: LD_INT 2
66851: PUSH
66852: LD_INT 4
66854: PUSH
66855: LD_INT 5
66857: PUSH
66858: LD_INT 7
66860: PUSH
66861: LD_INT 11
66863: PUSH
66864: LD_INT 12
66866: PUSH
66867: LD_INT 15
66869: PUSH
66870: LD_INT 16
66872: PUSH
66873: LD_INT 20
66875: PUSH
66876: LD_INT 21
66878: PUSH
66879: LD_INT 22
66881: PUSH
66882: LD_INT 23
66884: PUSH
66885: LD_INT 25
66887: PUSH
66888: LD_INT 26
66890: PUSH
66891: LD_INT 30
66893: PUSH
66894: LD_INT 31
66896: PUSH
66897: LD_INT 32
66899: PUSH
66900: LD_INT 33
66902: PUSH
66903: LD_INT 34
66905: PUSH
66906: EMPTY
66907: LIST
66908: LIST
66909: LIST
66910: LIST
66911: LIST
66912: LIST
66913: LIST
66914: LIST
66915: LIST
66916: LIST
66917: LIST
66918: LIST
66919: LIST
66920: LIST
66921: LIST
66922: LIST
66923: LIST
66924: LIST
66925: LIST
66926: PUSH
66927: LD_INT 101
66929: PUSH
66930: LD_INT 102
66932: PUSH
66933: LD_INT 103
66935: PUSH
66936: LD_INT 106
66938: PUSH
66939: LD_INT 108
66941: PUSH
66942: LD_INT 112
66944: PUSH
66945: LD_INT 113
66947: PUSH
66948: LD_INT 114
66950: PUSH
66951: LD_INT 116
66953: PUSH
66954: LD_INT 117
66956: PUSH
66957: LD_INT 118
66959: PUSH
66960: EMPTY
66961: LIST
66962: LIST
66963: LIST
66964: LIST
66965: LIST
66966: LIST
66967: LIST
66968: LIST
66969: LIST
66970: LIST
66971: LIST
66972: PUSH
66973: EMPTY
66974: LIST
66975: LIST
66976: ST_TO_ADDR
66977: GO 67608
66979: LD_INT 17
66981: DOUBLE
66982: EQUAL
66983: IFTRUE 66987
66985: GO 67211
66987: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 18 :
66988: LD_ADDR_VAR 0 1
66992: PUSH
66993: LD_INT 1
66995: PUSH
66996: LD_INT 2
66998: PUSH
66999: LD_INT 3
67001: PUSH
67002: LD_INT 4
67004: PUSH
67005: LD_INT 5
67007: PUSH
67008: LD_INT 6
67010: PUSH
67011: LD_INT 7
67013: PUSH
67014: LD_INT 8
67016: PUSH
67017: LD_INT 9
67019: PUSH
67020: LD_INT 10
67022: PUSH
67023: LD_INT 11
67025: PUSH
67026: LD_INT 12
67028: PUSH
67029: LD_INT 13
67031: PUSH
67032: LD_INT 14
67034: PUSH
67035: LD_INT 15
67037: PUSH
67038: LD_INT 16
67040: PUSH
67041: LD_INT 17
67043: PUSH
67044: LD_INT 18
67046: PUSH
67047: LD_INT 19
67049: PUSH
67050: LD_INT 20
67052: PUSH
67053: LD_INT 21
67055: PUSH
67056: LD_INT 22
67058: PUSH
67059: LD_INT 23
67061: PUSH
67062: LD_INT 24
67064: PUSH
67065: LD_INT 25
67067: PUSH
67068: LD_INT 26
67070: PUSH
67071: LD_INT 27
67073: PUSH
67074: LD_INT 28
67076: PUSH
67077: LD_INT 29
67079: PUSH
67080: LD_INT 30
67082: PUSH
67083: LD_INT 31
67085: PUSH
67086: LD_INT 32
67088: PUSH
67089: LD_INT 33
67091: PUSH
67092: LD_INT 34
67094: PUSH
67095: LD_INT 36
67097: PUSH
67098: EMPTY
67099: LIST
67100: LIST
67101: LIST
67102: LIST
67103: LIST
67104: LIST
67105: LIST
67106: LIST
67107: LIST
67108: LIST
67109: LIST
67110: LIST
67111: LIST
67112: LIST
67113: LIST
67114: LIST
67115: LIST
67116: LIST
67117: LIST
67118: LIST
67119: LIST
67120: LIST
67121: LIST
67122: LIST
67123: LIST
67124: LIST
67125: LIST
67126: LIST
67127: LIST
67128: LIST
67129: LIST
67130: LIST
67131: LIST
67132: LIST
67133: LIST
67134: PUSH
67135: LD_INT 101
67137: PUSH
67138: LD_INT 102
67140: PUSH
67141: LD_INT 103
67143: PUSH
67144: LD_INT 104
67146: PUSH
67147: LD_INT 105
67149: PUSH
67150: LD_INT 106
67152: PUSH
67153: LD_INT 107
67155: PUSH
67156: LD_INT 108
67158: PUSH
67159: LD_INT 109
67161: PUSH
67162: LD_INT 110
67164: PUSH
67165: LD_INT 111
67167: PUSH
67168: LD_INT 112
67170: PUSH
67171: LD_INT 113
67173: PUSH
67174: LD_INT 114
67176: PUSH
67177: LD_INT 116
67179: PUSH
67180: LD_INT 117
67182: PUSH
67183: LD_INT 118
67185: PUSH
67186: EMPTY
67187: LIST
67188: LIST
67189: LIST
67190: LIST
67191: LIST
67192: LIST
67193: LIST
67194: LIST
67195: LIST
67196: LIST
67197: LIST
67198: LIST
67199: LIST
67200: LIST
67201: LIST
67202: LIST
67203: LIST
67204: PUSH
67205: EMPTY
67206: LIST
67207: LIST
67208: ST_TO_ADDR
67209: GO 67608
67211: LD_INT 18
67213: DOUBLE
67214: EQUAL
67215: IFTRUE 67219
67217: GO 67367
67219: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; 19 :
67220: LD_ADDR_VAR 0 1
67224: PUSH
67225: LD_INT 2
67227: PUSH
67228: LD_INT 4
67230: PUSH
67231: LD_INT 5
67233: PUSH
67234: LD_INT 7
67236: PUSH
67237: LD_INT 11
67239: PUSH
67240: LD_INT 12
67242: PUSH
67243: LD_INT 15
67245: PUSH
67246: LD_INT 16
67248: PUSH
67249: LD_INT 20
67251: PUSH
67252: LD_INT 21
67254: PUSH
67255: LD_INT 22
67257: PUSH
67258: LD_INT 23
67260: PUSH
67261: LD_INT 25
67263: PUSH
67264: LD_INT 26
67266: PUSH
67267: LD_INT 30
67269: PUSH
67270: LD_INT 31
67272: PUSH
67273: LD_INT 32
67275: PUSH
67276: LD_INT 33
67278: PUSH
67279: LD_INT 34
67281: PUSH
67282: LD_INT 35
67284: PUSH
67285: LD_INT 36
67287: PUSH
67288: EMPTY
67289: LIST
67290: LIST
67291: LIST
67292: LIST
67293: LIST
67294: LIST
67295: LIST
67296: LIST
67297: LIST
67298: LIST
67299: LIST
67300: LIST
67301: LIST
67302: LIST
67303: LIST
67304: LIST
67305: LIST
67306: LIST
67307: LIST
67308: LIST
67309: LIST
67310: PUSH
67311: LD_INT 101
67313: PUSH
67314: LD_INT 102
67316: PUSH
67317: LD_INT 103
67319: PUSH
67320: LD_INT 106
67322: PUSH
67323: LD_INT 108
67325: PUSH
67326: LD_INT 112
67328: PUSH
67329: LD_INT 113
67331: PUSH
67332: LD_INT 114
67334: PUSH
67335: LD_INT 115
67337: PUSH
67338: LD_INT 116
67340: PUSH
67341: LD_INT 117
67343: PUSH
67344: LD_INT 118
67346: PUSH
67347: EMPTY
67348: LIST
67349: LIST
67350: LIST
67351: LIST
67352: LIST
67353: LIST
67354: LIST
67355: LIST
67356: LIST
67357: LIST
67358: LIST
67359: LIST
67360: PUSH
67361: EMPTY
67362: LIST
67363: LIST
67364: ST_TO_ADDR
67365: GO 67608
67367: LD_INT 19
67369: DOUBLE
67370: EQUAL
67371: IFTRUE 67375
67373: GO 67607
67375: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; end ;
67376: LD_ADDR_VAR 0 1
67380: PUSH
67381: LD_INT 1
67383: PUSH
67384: LD_INT 2
67386: PUSH
67387: LD_INT 3
67389: PUSH
67390: LD_INT 4
67392: PUSH
67393: LD_INT 5
67395: PUSH
67396: LD_INT 6
67398: PUSH
67399: LD_INT 7
67401: PUSH
67402: LD_INT 8
67404: PUSH
67405: LD_INT 9
67407: PUSH
67408: LD_INT 10
67410: PUSH
67411: LD_INT 11
67413: PUSH
67414: LD_INT 12
67416: PUSH
67417: LD_INT 13
67419: PUSH
67420: LD_INT 14
67422: PUSH
67423: LD_INT 15
67425: PUSH
67426: LD_INT 16
67428: PUSH
67429: LD_INT 17
67431: PUSH
67432: LD_INT 18
67434: PUSH
67435: LD_INT 19
67437: PUSH
67438: LD_INT 20
67440: PUSH
67441: LD_INT 21
67443: PUSH
67444: LD_INT 22
67446: PUSH
67447: LD_INT 23
67449: PUSH
67450: LD_INT 24
67452: PUSH
67453: LD_INT 25
67455: PUSH
67456: LD_INT 26
67458: PUSH
67459: LD_INT 27
67461: PUSH
67462: LD_INT 28
67464: PUSH
67465: LD_INT 29
67467: PUSH
67468: LD_INT 30
67470: PUSH
67471: LD_INT 31
67473: PUSH
67474: LD_INT 32
67476: PUSH
67477: LD_INT 33
67479: PUSH
67480: LD_INT 34
67482: PUSH
67483: LD_INT 35
67485: PUSH
67486: LD_INT 36
67488: PUSH
67489: EMPTY
67490: LIST
67491: LIST
67492: LIST
67493: LIST
67494: LIST
67495: LIST
67496: LIST
67497: LIST
67498: LIST
67499: LIST
67500: LIST
67501: LIST
67502: LIST
67503: LIST
67504: LIST
67505: LIST
67506: LIST
67507: LIST
67508: LIST
67509: LIST
67510: LIST
67511: LIST
67512: LIST
67513: LIST
67514: LIST
67515: LIST
67516: LIST
67517: LIST
67518: LIST
67519: LIST
67520: LIST
67521: LIST
67522: LIST
67523: LIST
67524: LIST
67525: LIST
67526: PUSH
67527: LD_INT 101
67529: PUSH
67530: LD_INT 102
67532: PUSH
67533: LD_INT 103
67535: PUSH
67536: LD_INT 104
67538: PUSH
67539: LD_INT 105
67541: PUSH
67542: LD_INT 106
67544: PUSH
67545: LD_INT 107
67547: PUSH
67548: LD_INT 108
67550: PUSH
67551: LD_INT 109
67553: PUSH
67554: LD_INT 110
67556: PUSH
67557: LD_INT 111
67559: PUSH
67560: LD_INT 112
67562: PUSH
67563: LD_INT 113
67565: PUSH
67566: LD_INT 114
67568: PUSH
67569: LD_INT 115
67571: PUSH
67572: LD_INT 116
67574: PUSH
67575: LD_INT 117
67577: PUSH
67578: LD_INT 118
67580: PUSH
67581: EMPTY
67582: LIST
67583: LIST
67584: LIST
67585: LIST
67586: LIST
67587: LIST
67588: LIST
67589: LIST
67590: LIST
67591: LIST
67592: LIST
67593: LIST
67594: LIST
67595: LIST
67596: LIST
67597: LIST
67598: LIST
67599: LIST
67600: PUSH
67601: EMPTY
67602: LIST
67603: LIST
67604: ST_TO_ADDR
67605: GO 67608
67607: POP
// end else
67608: GO 67839
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ;
67610: LD_ADDR_VAR 0 1
67614: PUSH
67615: LD_INT 1
67617: PUSH
67618: LD_INT 2
67620: PUSH
67621: LD_INT 3
67623: PUSH
67624: LD_INT 4
67626: PUSH
67627: LD_INT 5
67629: PUSH
67630: LD_INT 6
67632: PUSH
67633: LD_INT 7
67635: PUSH
67636: LD_INT 8
67638: PUSH
67639: LD_INT 9
67641: PUSH
67642: LD_INT 10
67644: PUSH
67645: LD_INT 11
67647: PUSH
67648: LD_INT 12
67650: PUSH
67651: LD_INT 13
67653: PUSH
67654: LD_INT 14
67656: PUSH
67657: LD_INT 15
67659: PUSH
67660: LD_INT 16
67662: PUSH
67663: LD_INT 17
67665: PUSH
67666: LD_INT 18
67668: PUSH
67669: LD_INT 19
67671: PUSH
67672: LD_INT 20
67674: PUSH
67675: LD_INT 21
67677: PUSH
67678: LD_INT 22
67680: PUSH
67681: LD_INT 23
67683: PUSH
67684: LD_INT 24
67686: PUSH
67687: LD_INT 25
67689: PUSH
67690: LD_INT 26
67692: PUSH
67693: LD_INT 27
67695: PUSH
67696: LD_INT 28
67698: PUSH
67699: LD_INT 29
67701: PUSH
67702: LD_INT 30
67704: PUSH
67705: LD_INT 31
67707: PUSH
67708: LD_INT 32
67710: PUSH
67711: LD_INT 33
67713: PUSH
67714: LD_INT 34
67716: PUSH
67717: LD_INT 35
67719: PUSH
67720: LD_INT 36
67722: PUSH
67723: EMPTY
67724: LIST
67725: LIST
67726: LIST
67727: LIST
67728: LIST
67729: LIST
67730: LIST
67731: LIST
67732: LIST
67733: LIST
67734: LIST
67735: LIST
67736: LIST
67737: LIST
67738: LIST
67739: LIST
67740: LIST
67741: LIST
67742: LIST
67743: LIST
67744: LIST
67745: LIST
67746: LIST
67747: LIST
67748: LIST
67749: LIST
67750: LIST
67751: LIST
67752: LIST
67753: LIST
67754: LIST
67755: LIST
67756: LIST
67757: LIST
67758: LIST
67759: LIST
67760: PUSH
67761: LD_INT 101
67763: PUSH
67764: LD_INT 102
67766: PUSH
67767: LD_INT 103
67769: PUSH
67770: LD_INT 104
67772: PUSH
67773: LD_INT 105
67775: PUSH
67776: LD_INT 106
67778: PUSH
67779: LD_INT 107
67781: PUSH
67782: LD_INT 108
67784: PUSH
67785: LD_INT 109
67787: PUSH
67788: LD_INT 110
67790: PUSH
67791: LD_INT 111
67793: PUSH
67794: LD_INT 112
67796: PUSH
67797: LD_INT 113
67799: PUSH
67800: LD_INT 114
67802: PUSH
67803: LD_INT 115
67805: PUSH
67806: LD_INT 116
67808: PUSH
67809: LD_INT 117
67811: PUSH
67812: LD_INT 118
67814: PUSH
67815: EMPTY
67816: LIST
67817: LIST
67818: LIST
67819: LIST
67820: LIST
67821: LIST
67822: LIST
67823: LIST
67824: LIST
67825: LIST
67826: LIST
67827: LIST
67828: LIST
67829: LIST
67830: LIST
67831: LIST
67832: LIST
67833: LIST
67834: PUSH
67835: EMPTY
67836: LIST
67837: LIST
67838: ST_TO_ADDR
// if result then
67839: LD_VAR 0 1
67843: IFFALSE 68132
// begin normal :=  ;
67845: LD_ADDR_VAR 0 3
67849: PUSH
67850: LD_STRING 
67852: ST_TO_ADDR
// hardcore :=  ;
67853: LD_ADDR_VAR 0 4
67857: PUSH
67858: LD_STRING 
67860: ST_TO_ADDR
// for i = 1 to normalCounter do
67861: LD_ADDR_VAR 0 5
67865: PUSH
67866: DOUBLE
67867: LD_INT 1
67869: DEC
67870: ST_TO_ADDR
67871: LD_EXP 100
67875: PUSH
67876: FOR_TO
67877: IFFALSE 67978
// begin tmp := 0 ;
67879: LD_ADDR_VAR 0 2
67883: PUSH
67884: LD_STRING 0
67886: ST_TO_ADDR
// if result [ 1 ] then
67887: LD_VAR 0 1
67891: PUSH
67892: LD_INT 1
67894: ARRAY
67895: IFFALSE 67960
// if result [ 1 ] [ 1 ] = i then
67897: LD_VAR 0 1
67901: PUSH
67902: LD_INT 1
67904: ARRAY
67905: PUSH
67906: LD_INT 1
67908: ARRAY
67909: PUSH
67910: LD_VAR 0 5
67914: EQUAL
67915: IFFALSE 67960
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
67917: LD_ADDR_VAR 0 1
67921: PUSH
67922: LD_VAR 0 1
67926: PPUSH
67927: LD_INT 1
67929: PPUSH
67930: LD_VAR 0 1
67934: PUSH
67935: LD_INT 1
67937: ARRAY
67938: PPUSH
67939: LD_INT 1
67941: PPUSH
67942: CALL_OW 3
67946: PPUSH
67947: CALL_OW 1
67951: ST_TO_ADDR
// tmp := 1 ;
67952: LD_ADDR_VAR 0 2
67956: PUSH
67957: LD_STRING 1
67959: ST_TO_ADDR
// end ; normal := normal & tmp ;
67960: LD_ADDR_VAR 0 3
67964: PUSH
67965: LD_VAR 0 3
67969: PUSH
67970: LD_VAR 0 2
67974: STR
67975: ST_TO_ADDR
// end ;
67976: GO 67876
67978: POP
67979: POP
// for i = 1 to hardcoreCounter do
67980: LD_ADDR_VAR 0 5
67984: PUSH
67985: DOUBLE
67986: LD_INT 1
67988: DEC
67989: ST_TO_ADDR
67990: LD_EXP 101
67994: PUSH
67995: FOR_TO
67996: IFFALSE 68101
// begin tmp := 0 ;
67998: LD_ADDR_VAR 0 2
68002: PUSH
68003: LD_STRING 0
68005: ST_TO_ADDR
// if result [ 2 ] then
68006: LD_VAR 0 1
68010: PUSH
68011: LD_INT 2
68013: ARRAY
68014: IFFALSE 68083
// if result [ 2 ] [ 1 ] = 100 + i then
68016: LD_VAR 0 1
68020: PUSH
68021: LD_INT 2
68023: ARRAY
68024: PUSH
68025: LD_INT 1
68027: ARRAY
68028: PUSH
68029: LD_INT 100
68031: PUSH
68032: LD_VAR 0 5
68036: PLUS
68037: EQUAL
68038: IFFALSE 68083
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
68040: LD_ADDR_VAR 0 1
68044: PUSH
68045: LD_VAR 0 1
68049: PPUSH
68050: LD_INT 2
68052: PPUSH
68053: LD_VAR 0 1
68057: PUSH
68058: LD_INT 2
68060: ARRAY
68061: PPUSH
68062: LD_INT 1
68064: PPUSH
68065: CALL_OW 3
68069: PPUSH
68070: CALL_OW 1
68074: ST_TO_ADDR
// tmp := 1 ;
68075: LD_ADDR_VAR 0 2
68079: PUSH
68080: LD_STRING 1
68082: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
68083: LD_ADDR_VAR 0 4
68087: PUSH
68088: LD_VAR 0 4
68092: PUSH
68093: LD_VAR 0 2
68097: STR
68098: ST_TO_ADDR
// end ;
68099: GO 67995
68101: POP
68102: POP
// ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & ") ) ;
68103: LD_STRING getStreamItemsFromMission("
68105: PUSH
68106: LD_VAR 0 3
68110: STR
68111: PUSH
68112: LD_STRING ","
68114: STR
68115: PUSH
68116: LD_VAR 0 4
68120: STR
68121: PUSH
68122: LD_STRING ")
68124: STR
68125: PPUSH
68126: CALL_OW 559
// end else
68130: GO 68139
// ToLua ( getStreamItemsFromMission("","") ) ;
68132: LD_STRING getStreamItemsFromMission("","")
68134: PPUSH
68135: CALL_OW 559
// end ;
68139: LD_VAR 0 1
68143: RET
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
68144: LD_EXP 99
68148: PUSH
68149: LD_EXP 104
68153: AND
68154: IFFALSE 68278
68156: GO 68158
68158: DISABLE
68159: LD_INT 0
68161: PPUSH
68162: PPUSH
// begin enable ;
68163: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
68164: LD_ADDR_VAR 0 2
68168: PUSH
68169: LD_INT 22
68171: PUSH
68172: LD_OWVAR 2
68176: PUSH
68177: EMPTY
68178: LIST
68179: LIST
68180: PUSH
68181: LD_INT 2
68183: PUSH
68184: LD_INT 34
68186: PUSH
68187: LD_INT 7
68189: PUSH
68190: EMPTY
68191: LIST
68192: LIST
68193: PUSH
68194: LD_INT 34
68196: PUSH
68197: LD_INT 45
68199: PUSH
68200: EMPTY
68201: LIST
68202: LIST
68203: PUSH
68204: LD_INT 34
68206: PUSH
68207: LD_INT 28
68209: PUSH
68210: EMPTY
68211: LIST
68212: LIST
68213: PUSH
68214: LD_INT 34
68216: PUSH
68217: LD_INT 47
68219: PUSH
68220: EMPTY
68221: LIST
68222: LIST
68223: PUSH
68224: EMPTY
68225: LIST
68226: LIST
68227: LIST
68228: LIST
68229: LIST
68230: PUSH
68231: EMPTY
68232: LIST
68233: LIST
68234: PPUSH
68235: CALL_OW 69
68239: ST_TO_ADDR
// if not tmp then
68240: LD_VAR 0 2
68244: NOT
68245: IFFALSE 68249
// exit ;
68247: GO 68278
// for i in tmp do
68249: LD_ADDR_VAR 0 1
68253: PUSH
68254: LD_VAR 0 2
68258: PUSH
68259: FOR_IN
68260: IFFALSE 68276
// begin SetLives ( i , 0 ) ;
68262: LD_VAR 0 1
68266: PPUSH
68267: LD_INT 0
68269: PPUSH
68270: CALL_OW 234
// end ;
68274: GO 68259
68276: POP
68277: POP
// end ;
68278: PPOPN 2
68280: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
68281: LD_EXP 99
68285: PUSH
68286: LD_EXP 105
68290: AND
68291: IFFALSE 68375
68293: GO 68295
68295: DISABLE
68296: LD_INT 0
68298: PPUSH
68299: PPUSH
// begin enable ;
68300: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
68301: LD_ADDR_VAR 0 2
68305: PUSH
68306: LD_INT 22
68308: PUSH
68309: LD_OWVAR 2
68313: PUSH
68314: EMPTY
68315: LIST
68316: LIST
68317: PUSH
68318: LD_INT 32
68320: PUSH
68321: LD_INT 3
68323: PUSH
68324: EMPTY
68325: LIST
68326: LIST
68327: PUSH
68328: EMPTY
68329: LIST
68330: LIST
68331: PPUSH
68332: CALL_OW 69
68336: ST_TO_ADDR
// if not tmp then
68337: LD_VAR 0 2
68341: NOT
68342: IFFALSE 68346
// exit ;
68344: GO 68375
// for i in tmp do
68346: LD_ADDR_VAR 0 1
68350: PUSH
68351: LD_VAR 0 2
68355: PUSH
68356: FOR_IN
68357: IFFALSE 68373
// begin SetLives ( i , 0 ) ;
68359: LD_VAR 0 1
68363: PPUSH
68364: LD_INT 0
68366: PPUSH
68367: CALL_OW 234
// end ;
68371: GO 68356
68373: POP
68374: POP
// end ;
68375: PPOPN 2
68377: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
68378: LD_EXP 99
68382: PUSH
68383: LD_EXP 102
68387: AND
68388: IFFALSE 68481
68390: GO 68392
68392: DISABLE
68393: LD_INT 0
68395: PPUSH
// begin enable ;
68396: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
68397: LD_ADDR_VAR 0 1
68401: PUSH
68402: LD_INT 22
68404: PUSH
68405: LD_OWVAR 2
68409: PUSH
68410: EMPTY
68411: LIST
68412: LIST
68413: PUSH
68414: LD_INT 2
68416: PUSH
68417: LD_INT 25
68419: PUSH
68420: LD_INT 5
68422: PUSH
68423: EMPTY
68424: LIST
68425: LIST
68426: PUSH
68427: LD_INT 25
68429: PUSH
68430: LD_INT 9
68432: PUSH
68433: EMPTY
68434: LIST
68435: LIST
68436: PUSH
68437: LD_INT 25
68439: PUSH
68440: LD_INT 8
68442: PUSH
68443: EMPTY
68444: LIST
68445: LIST
68446: PUSH
68447: EMPTY
68448: LIST
68449: LIST
68450: LIST
68451: LIST
68452: PUSH
68453: EMPTY
68454: LIST
68455: LIST
68456: PPUSH
68457: CALL_OW 69
68461: PUSH
68462: FOR_IN
68463: IFFALSE 68479
// begin SetClass ( i , 1 ) ;
68465: LD_VAR 0 1
68469: PPUSH
68470: LD_INT 1
68472: PPUSH
68473: CALL_OW 336
// end ;
68477: GO 68462
68479: POP
68480: POP
// end ;
68481: PPOPN 1
68483: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
68484: LD_EXP 99
68488: PUSH
68489: LD_EXP 103
68493: AND
68494: PUSH
68495: LD_OWVAR 65
68499: PUSH
68500: LD_INT 7
68502: LESS
68503: AND
68504: IFFALSE 68518
68506: GO 68508
68508: DISABLE
// begin enable ;
68509: ENABLE
// game_speed := 7 ;
68510: LD_ADDR_OWVAR 65
68514: PUSH
68515: LD_INT 7
68517: ST_TO_ADDR
// end ;
68518: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
68519: LD_EXP 99
68523: PUSH
68524: LD_EXP 106
68528: AND
68529: IFFALSE 68731
68531: GO 68533
68533: DISABLE
68534: LD_INT 0
68536: PPUSH
68537: PPUSH
68538: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
68539: LD_ADDR_VAR 0 3
68543: PUSH
68544: LD_INT 81
68546: PUSH
68547: LD_OWVAR 2
68551: PUSH
68552: EMPTY
68553: LIST
68554: LIST
68555: PUSH
68556: LD_INT 21
68558: PUSH
68559: LD_INT 1
68561: PUSH
68562: EMPTY
68563: LIST
68564: LIST
68565: PUSH
68566: EMPTY
68567: LIST
68568: LIST
68569: PPUSH
68570: CALL_OW 69
68574: ST_TO_ADDR
// if not tmp then
68575: LD_VAR 0 3
68579: NOT
68580: IFFALSE 68584
// exit ;
68582: GO 68731
// if tmp > 5 then
68584: LD_VAR 0 3
68588: PUSH
68589: LD_INT 5
68591: GREATER
68592: IFFALSE 68604
// k := 5 else
68594: LD_ADDR_VAR 0 2
68598: PUSH
68599: LD_INT 5
68601: ST_TO_ADDR
68602: GO 68614
// k := tmp ;
68604: LD_ADDR_VAR 0 2
68608: PUSH
68609: LD_VAR 0 3
68613: ST_TO_ADDR
// for i := 1 to k do
68614: LD_ADDR_VAR 0 1
68618: PUSH
68619: DOUBLE
68620: LD_INT 1
68622: DEC
68623: ST_TO_ADDR
68624: LD_VAR 0 2
68628: PUSH
68629: FOR_TO
68630: IFFALSE 68729
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
68632: LD_VAR 0 3
68636: PUSH
68637: LD_VAR 0 1
68641: ARRAY
68642: PPUSH
68643: LD_VAR 0 1
68647: PUSH
68648: LD_INT 4
68650: MOD
68651: PUSH
68652: LD_INT 1
68654: PLUS
68655: PPUSH
68656: CALL_OW 259
68660: PUSH
68661: LD_INT 10
68663: LESS
68664: IFFALSE 68727
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
68666: LD_VAR 0 3
68670: PUSH
68671: LD_VAR 0 1
68675: ARRAY
68676: PPUSH
68677: LD_VAR 0 1
68681: PUSH
68682: LD_INT 4
68684: MOD
68685: PUSH
68686: LD_INT 1
68688: PLUS
68689: PPUSH
68690: LD_VAR 0 3
68694: PUSH
68695: LD_VAR 0 1
68699: ARRAY
68700: PPUSH
68701: LD_VAR 0 1
68705: PUSH
68706: LD_INT 4
68708: MOD
68709: PUSH
68710: LD_INT 1
68712: PLUS
68713: PPUSH
68714: CALL_OW 259
68718: PUSH
68719: LD_INT 1
68721: PLUS
68722: PPUSH
68723: CALL_OW 237
68727: GO 68629
68729: POP
68730: POP
// end ;
68731: PPOPN 3
68733: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
68734: LD_EXP 99
68738: PUSH
68739: LD_EXP 107
68743: AND
68744: IFFALSE 68764
68746: GO 68748
68748: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
68749: LD_INT 4
68751: PPUSH
68752: LD_OWVAR 2
68756: PPUSH
68757: LD_INT 0
68759: PPUSH
68760: CALL_OW 324
68764: END
// every 0 0$1 trigger StreamModeActive and sShovel do
68765: LD_EXP 99
68769: PUSH
68770: LD_EXP 136
68774: AND
68775: IFFALSE 68795
68777: GO 68779
68779: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
68780: LD_INT 19
68782: PPUSH
68783: LD_OWVAR 2
68787: PPUSH
68788: LD_INT 0
68790: PPUSH
68791: CALL_OW 324
68795: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
68796: LD_EXP 99
68800: PUSH
68801: LD_EXP 108
68805: AND
68806: IFFALSE 68908
68808: GO 68810
68810: DISABLE
68811: LD_INT 0
68813: PPUSH
68814: PPUSH
// begin enable ;
68815: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
68816: LD_ADDR_VAR 0 2
68820: PUSH
68821: LD_INT 22
68823: PUSH
68824: LD_OWVAR 2
68828: PUSH
68829: EMPTY
68830: LIST
68831: LIST
68832: PUSH
68833: LD_INT 2
68835: PUSH
68836: LD_INT 34
68838: PUSH
68839: LD_INT 11
68841: PUSH
68842: EMPTY
68843: LIST
68844: LIST
68845: PUSH
68846: LD_INT 34
68848: PUSH
68849: LD_INT 30
68851: PUSH
68852: EMPTY
68853: LIST
68854: LIST
68855: PUSH
68856: EMPTY
68857: LIST
68858: LIST
68859: LIST
68860: PUSH
68861: EMPTY
68862: LIST
68863: LIST
68864: PPUSH
68865: CALL_OW 69
68869: ST_TO_ADDR
// if not tmp then
68870: LD_VAR 0 2
68874: NOT
68875: IFFALSE 68879
// exit ;
68877: GO 68908
// for i in tmp do
68879: LD_ADDR_VAR 0 1
68883: PUSH
68884: LD_VAR 0 2
68888: PUSH
68889: FOR_IN
68890: IFFALSE 68906
// begin SetLives ( i , 0 ) ;
68892: LD_VAR 0 1
68896: PPUSH
68897: LD_INT 0
68899: PPUSH
68900: CALL_OW 234
// end ;
68904: GO 68889
68906: POP
68907: POP
// end ;
68908: PPOPN 2
68910: END
// every 0 0$1 trigger StreamModeActive and sBunker do
68911: LD_EXP 99
68915: PUSH
68916: LD_EXP 109
68920: AND
68921: IFFALSE 68941
68923: GO 68925
68925: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
68926: LD_INT 32
68928: PPUSH
68929: LD_OWVAR 2
68933: PPUSH
68934: LD_INT 0
68936: PPUSH
68937: CALL_OW 324
68941: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
68942: LD_EXP 99
68946: PUSH
68947: LD_EXP 110
68951: AND
68952: IFFALSE 69133
68954: GO 68956
68956: DISABLE
68957: LD_INT 0
68959: PPUSH
68960: PPUSH
68961: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
68962: LD_ADDR_VAR 0 2
68966: PUSH
68967: LD_INT 22
68969: PUSH
68970: LD_OWVAR 2
68974: PUSH
68975: EMPTY
68976: LIST
68977: LIST
68978: PUSH
68979: LD_INT 33
68981: PUSH
68982: LD_INT 3
68984: PUSH
68985: EMPTY
68986: LIST
68987: LIST
68988: PUSH
68989: EMPTY
68990: LIST
68991: LIST
68992: PPUSH
68993: CALL_OW 69
68997: ST_TO_ADDR
// if not tmp then
68998: LD_VAR 0 2
69002: NOT
69003: IFFALSE 69007
// exit ;
69005: GO 69133
// side := 0 ;
69007: LD_ADDR_VAR 0 3
69011: PUSH
69012: LD_INT 0
69014: ST_TO_ADDR
// for i := 1 to 8 do
69015: LD_ADDR_VAR 0 1
69019: PUSH
69020: DOUBLE
69021: LD_INT 1
69023: DEC
69024: ST_TO_ADDR
69025: LD_INT 8
69027: PUSH
69028: FOR_TO
69029: IFFALSE 69077
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
69031: LD_OWVAR 2
69035: PUSH
69036: LD_VAR 0 1
69040: NONEQUAL
69041: PUSH
69042: LD_OWVAR 2
69046: PPUSH
69047: LD_VAR 0 1
69051: PPUSH
69052: CALL_OW 81
69056: PUSH
69057: LD_INT 2
69059: EQUAL
69060: AND
69061: IFFALSE 69075
// begin side := i ;
69063: LD_ADDR_VAR 0 3
69067: PUSH
69068: LD_VAR 0 1
69072: ST_TO_ADDR
// break ;
69073: GO 69077
// end ;
69075: GO 69028
69077: POP
69078: POP
// if not side then
69079: LD_VAR 0 3
69083: NOT
69084: IFFALSE 69088
// exit ;
69086: GO 69133
// for i := 1 to tmp do
69088: LD_ADDR_VAR 0 1
69092: PUSH
69093: DOUBLE
69094: LD_INT 1
69096: DEC
69097: ST_TO_ADDR
69098: LD_VAR 0 2
69102: PUSH
69103: FOR_TO
69104: IFFALSE 69131
// if Prob ( 60 ) then
69106: LD_INT 60
69108: PPUSH
69109: CALL_OW 13
69113: IFFALSE 69129
// SetSide ( i , side ) ;
69115: LD_VAR 0 1
69119: PPUSH
69120: LD_VAR 0 3
69124: PPUSH
69125: CALL_OW 235
69129: GO 69103
69131: POP
69132: POP
// end ;
69133: PPOPN 3
69135: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
69136: LD_EXP 99
69140: PUSH
69141: LD_EXP 112
69145: AND
69146: IFFALSE 69265
69148: GO 69150
69150: DISABLE
69151: LD_INT 0
69153: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
69154: LD_ADDR_VAR 0 1
69158: PUSH
69159: LD_INT 22
69161: PUSH
69162: LD_OWVAR 2
69166: PUSH
69167: EMPTY
69168: LIST
69169: LIST
69170: PUSH
69171: LD_INT 21
69173: PUSH
69174: LD_INT 1
69176: PUSH
69177: EMPTY
69178: LIST
69179: LIST
69180: PUSH
69181: LD_INT 3
69183: PUSH
69184: LD_INT 23
69186: PUSH
69187: LD_INT 0
69189: PUSH
69190: EMPTY
69191: LIST
69192: LIST
69193: PUSH
69194: EMPTY
69195: LIST
69196: LIST
69197: PUSH
69198: EMPTY
69199: LIST
69200: LIST
69201: LIST
69202: PPUSH
69203: CALL_OW 69
69207: PUSH
69208: FOR_IN
69209: IFFALSE 69263
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
69211: LD_VAR 0 1
69215: PPUSH
69216: CALL_OW 257
69220: PUSH
69221: LD_INT 1
69223: PUSH
69224: LD_INT 2
69226: PUSH
69227: LD_INT 3
69229: PUSH
69230: LD_INT 4
69232: PUSH
69233: EMPTY
69234: LIST
69235: LIST
69236: LIST
69237: LIST
69238: IN
69239: IFFALSE 69261
// SetClass ( un , rand ( 1 , 4 ) ) ;
69241: LD_VAR 0 1
69245: PPUSH
69246: LD_INT 1
69248: PPUSH
69249: LD_INT 4
69251: PPUSH
69252: CALL_OW 12
69256: PPUSH
69257: CALL_OW 336
69261: GO 69208
69263: POP
69264: POP
// end ;
69265: PPOPN 1
69267: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
69268: LD_EXP 99
69272: PUSH
69273: LD_EXP 111
69277: AND
69278: IFFALSE 69357
69280: GO 69282
69282: DISABLE
69283: LD_INT 0
69285: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
69286: LD_ADDR_VAR 0 1
69290: PUSH
69291: LD_INT 22
69293: PUSH
69294: LD_OWVAR 2
69298: PUSH
69299: EMPTY
69300: LIST
69301: LIST
69302: PUSH
69303: LD_INT 21
69305: PUSH
69306: LD_INT 3
69308: PUSH
69309: EMPTY
69310: LIST
69311: LIST
69312: PUSH
69313: EMPTY
69314: LIST
69315: LIST
69316: PPUSH
69317: CALL_OW 69
69321: ST_TO_ADDR
// if not tmp then
69322: LD_VAR 0 1
69326: NOT
69327: IFFALSE 69331
// exit ;
69329: GO 69357
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
69331: LD_VAR 0 1
69335: PUSH
69336: LD_INT 1
69338: PPUSH
69339: LD_VAR 0 1
69343: PPUSH
69344: CALL_OW 12
69348: ARRAY
69349: PPUSH
69350: LD_INT 100
69352: PPUSH
69353: CALL_OW 234
// end ;
69357: PPOPN 1
69359: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
69360: LD_EXP 99
69364: PUSH
69365: LD_EXP 113
69369: AND
69370: IFFALSE 69468
69372: GO 69374
69374: DISABLE
69375: LD_INT 0
69377: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
69378: LD_ADDR_VAR 0 1
69382: PUSH
69383: LD_INT 22
69385: PUSH
69386: LD_OWVAR 2
69390: PUSH
69391: EMPTY
69392: LIST
69393: LIST
69394: PUSH
69395: LD_INT 21
69397: PUSH
69398: LD_INT 1
69400: PUSH
69401: EMPTY
69402: LIST
69403: LIST
69404: PUSH
69405: EMPTY
69406: LIST
69407: LIST
69408: PPUSH
69409: CALL_OW 69
69413: ST_TO_ADDR
// if not tmp then
69414: LD_VAR 0 1
69418: NOT
69419: IFFALSE 69423
// exit ;
69421: GO 69468
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
69423: LD_VAR 0 1
69427: PUSH
69428: LD_INT 1
69430: PPUSH
69431: LD_VAR 0 1
69435: PPUSH
69436: CALL_OW 12
69440: ARRAY
69441: PPUSH
69442: LD_INT 1
69444: PPUSH
69445: LD_INT 4
69447: PPUSH
69448: CALL_OW 12
69452: PPUSH
69453: LD_INT 3000
69455: PPUSH
69456: LD_INT 9000
69458: PPUSH
69459: CALL_OW 12
69463: PPUSH
69464: CALL_OW 492
// end ;
69468: PPOPN 1
69470: END
// every 0 0$1 trigger StreamModeActive and sDepot do
69471: LD_EXP 99
69475: PUSH
69476: LD_EXP 114
69480: AND
69481: IFFALSE 69501
69483: GO 69485
69485: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
69486: LD_INT 1
69488: PPUSH
69489: LD_OWVAR 2
69493: PPUSH
69494: LD_INT 0
69496: PPUSH
69497: CALL_OW 324
69501: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
69502: LD_EXP 99
69506: PUSH
69507: LD_EXP 115
69511: AND
69512: IFFALSE 69595
69514: GO 69516
69516: DISABLE
69517: LD_INT 0
69519: PPUSH
69520: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
69521: LD_ADDR_VAR 0 2
69525: PUSH
69526: LD_INT 22
69528: PUSH
69529: LD_OWVAR 2
69533: PUSH
69534: EMPTY
69535: LIST
69536: LIST
69537: PUSH
69538: LD_INT 21
69540: PUSH
69541: LD_INT 3
69543: PUSH
69544: EMPTY
69545: LIST
69546: LIST
69547: PUSH
69548: EMPTY
69549: LIST
69550: LIST
69551: PPUSH
69552: CALL_OW 69
69556: ST_TO_ADDR
// if not tmp then
69557: LD_VAR 0 2
69561: NOT
69562: IFFALSE 69566
// exit ;
69564: GO 69595
// for i in tmp do
69566: LD_ADDR_VAR 0 1
69570: PUSH
69571: LD_VAR 0 2
69575: PUSH
69576: FOR_IN
69577: IFFALSE 69593
// SetBLevel ( i , 10 ) ;
69579: LD_VAR 0 1
69583: PPUSH
69584: LD_INT 10
69586: PPUSH
69587: CALL_OW 241
69591: GO 69576
69593: POP
69594: POP
// end ;
69595: PPOPN 2
69597: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
69598: LD_EXP 99
69602: PUSH
69603: LD_EXP 116
69607: AND
69608: IFFALSE 69719
69610: GO 69612
69612: DISABLE
69613: LD_INT 0
69615: PPUSH
69616: PPUSH
69617: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
69618: LD_ADDR_VAR 0 3
69622: PUSH
69623: LD_INT 22
69625: PUSH
69626: LD_OWVAR 2
69630: PUSH
69631: EMPTY
69632: LIST
69633: LIST
69634: PUSH
69635: LD_INT 25
69637: PUSH
69638: LD_INT 1
69640: PUSH
69641: EMPTY
69642: LIST
69643: LIST
69644: PUSH
69645: EMPTY
69646: LIST
69647: LIST
69648: PPUSH
69649: CALL_OW 69
69653: ST_TO_ADDR
// if not tmp then
69654: LD_VAR 0 3
69658: NOT
69659: IFFALSE 69663
// exit ;
69661: GO 69719
// un := tmp [ rand ( 1 , tmp ) ] ;
69663: LD_ADDR_VAR 0 2
69667: PUSH
69668: LD_VAR 0 3
69672: PUSH
69673: LD_INT 1
69675: PPUSH
69676: LD_VAR 0 3
69680: PPUSH
69681: CALL_OW 12
69685: ARRAY
69686: ST_TO_ADDR
// if Crawls ( un ) then
69687: LD_VAR 0 2
69691: PPUSH
69692: CALL_OW 318
69696: IFFALSE 69707
// ComWalk ( un ) ;
69698: LD_VAR 0 2
69702: PPUSH
69703: CALL_OW 138
// SetClass ( un , class_sniper ) ;
69707: LD_VAR 0 2
69711: PPUSH
69712: LD_INT 5
69714: PPUSH
69715: CALL_OW 336
// end ;
69719: PPOPN 3
69721: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 4 do
69722: LD_EXP 99
69726: PUSH
69727: LD_EXP 117
69731: AND
69732: PUSH
69733: LD_OWVAR 67
69737: PUSH
69738: LD_INT 4
69740: LESS
69741: AND
69742: IFFALSE 69761
69744: GO 69746
69746: DISABLE
// begin Difficulty := Difficulty + 1 ;
69747: LD_ADDR_OWVAR 67
69751: PUSH
69752: LD_OWVAR 67
69756: PUSH
69757: LD_INT 1
69759: PLUS
69760: ST_TO_ADDR
// end ;
69761: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
69762: LD_EXP 99
69766: PUSH
69767: LD_EXP 118
69771: AND
69772: IFFALSE 69875
69774: GO 69776
69776: DISABLE
69777: LD_INT 0
69779: PPUSH
// begin for i := 1 to 5 do
69780: LD_ADDR_VAR 0 1
69784: PUSH
69785: DOUBLE
69786: LD_INT 1
69788: DEC
69789: ST_TO_ADDR
69790: LD_INT 5
69792: PUSH
69793: FOR_TO
69794: IFFALSE 69873
// begin uc_nation := nation_nature ;
69796: LD_ADDR_OWVAR 21
69800: PUSH
69801: LD_INT 0
69803: ST_TO_ADDR
// uc_side := 0 ;
69804: LD_ADDR_OWVAR 20
69808: PUSH
69809: LD_INT 0
69811: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
69812: LD_ADDR_OWVAR 29
69816: PUSH
69817: LD_INT 12
69819: PUSH
69820: LD_INT 12
69822: PUSH
69823: EMPTY
69824: LIST
69825: LIST
69826: ST_TO_ADDR
// hc_agressivity := 20 ;
69827: LD_ADDR_OWVAR 35
69831: PUSH
69832: LD_INT 20
69834: ST_TO_ADDR
// hc_class := class_tiger ;
69835: LD_ADDR_OWVAR 28
69839: PUSH
69840: LD_INT 14
69842: ST_TO_ADDR
// hc_gallery :=  ;
69843: LD_ADDR_OWVAR 33
69847: PUSH
69848: LD_STRING 
69850: ST_TO_ADDR
// hc_name :=  ;
69851: LD_ADDR_OWVAR 26
69855: PUSH
69856: LD_STRING 
69858: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
69859: CALL_OW 44
69863: PPUSH
69864: LD_INT 0
69866: PPUSH
69867: CALL_OW 51
// end ;
69871: GO 69793
69873: POP
69874: POP
// end ;
69875: PPOPN 1
69877: END
// every 0 0$1 trigger StreamModeActive and sBomb do
69878: LD_EXP 99
69882: PUSH
69883: LD_EXP 119
69887: AND
69888: IFFALSE 69897
69890: GO 69892
69892: DISABLE
// StreamSibBomb ;
69893: CALL 69898 0 0
69897: END
// export function StreamSibBomb ; var i , x , y ; begin
69898: LD_INT 0
69900: PPUSH
69901: PPUSH
69902: PPUSH
69903: PPUSH
// result := false ;
69904: LD_ADDR_VAR 0 1
69908: PUSH
69909: LD_INT 0
69911: ST_TO_ADDR
// for i := 1 to 16 do
69912: LD_ADDR_VAR 0 2
69916: PUSH
69917: DOUBLE
69918: LD_INT 1
69920: DEC
69921: ST_TO_ADDR
69922: LD_INT 16
69924: PUSH
69925: FOR_TO
69926: IFFALSE 70125
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
69928: LD_ADDR_VAR 0 3
69932: PUSH
69933: LD_INT 10
69935: PUSH
69936: LD_INT 20
69938: PUSH
69939: LD_INT 30
69941: PUSH
69942: LD_INT 40
69944: PUSH
69945: LD_INT 50
69947: PUSH
69948: LD_INT 60
69950: PUSH
69951: LD_INT 70
69953: PUSH
69954: LD_INT 80
69956: PUSH
69957: LD_INT 90
69959: PUSH
69960: LD_INT 100
69962: PUSH
69963: LD_INT 110
69965: PUSH
69966: LD_INT 120
69968: PUSH
69969: LD_INT 130
69971: PUSH
69972: LD_INT 140
69974: PUSH
69975: LD_INT 150
69977: PUSH
69978: EMPTY
69979: LIST
69980: LIST
69981: LIST
69982: LIST
69983: LIST
69984: LIST
69985: LIST
69986: LIST
69987: LIST
69988: LIST
69989: LIST
69990: LIST
69991: LIST
69992: LIST
69993: LIST
69994: PUSH
69995: LD_INT 1
69997: PPUSH
69998: LD_INT 15
70000: PPUSH
70001: CALL_OW 12
70005: ARRAY
70006: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
70007: LD_ADDR_VAR 0 4
70011: PUSH
70012: LD_INT 10
70014: PUSH
70015: LD_INT 20
70017: PUSH
70018: LD_INT 30
70020: PUSH
70021: LD_INT 40
70023: PUSH
70024: LD_INT 50
70026: PUSH
70027: LD_INT 60
70029: PUSH
70030: LD_INT 70
70032: PUSH
70033: LD_INT 80
70035: PUSH
70036: LD_INT 90
70038: PUSH
70039: LD_INT 100
70041: PUSH
70042: LD_INT 110
70044: PUSH
70045: LD_INT 120
70047: PUSH
70048: LD_INT 130
70050: PUSH
70051: LD_INT 140
70053: PUSH
70054: LD_INT 150
70056: PUSH
70057: EMPTY
70058: LIST
70059: LIST
70060: LIST
70061: LIST
70062: LIST
70063: LIST
70064: LIST
70065: LIST
70066: LIST
70067: LIST
70068: LIST
70069: LIST
70070: LIST
70071: LIST
70072: LIST
70073: PUSH
70074: LD_INT 1
70076: PPUSH
70077: LD_INT 15
70079: PPUSH
70080: CALL_OW 12
70084: ARRAY
70085: ST_TO_ADDR
// if ValidHex ( x , y ) then
70086: LD_VAR 0 3
70090: PPUSH
70091: LD_VAR 0 4
70095: PPUSH
70096: CALL_OW 488
70100: IFFALSE 70123
// begin result := [ x , y ] ;
70102: LD_ADDR_VAR 0 1
70106: PUSH
70107: LD_VAR 0 3
70111: PUSH
70112: LD_VAR 0 4
70116: PUSH
70117: EMPTY
70118: LIST
70119: LIST
70120: ST_TO_ADDR
// break ;
70121: GO 70125
// end ; end ;
70123: GO 69925
70125: POP
70126: POP
// if result then
70127: LD_VAR 0 1
70131: IFFALSE 70191
// begin ToLua ( playSibBomb() ) ;
70133: LD_STRING playSibBomb()
70135: PPUSH
70136: CALL_OW 559
// wait ( 0 0$14 ) ;
70140: LD_INT 490
70142: PPUSH
70143: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
70147: LD_VAR 0 1
70151: PUSH
70152: LD_INT 1
70154: ARRAY
70155: PPUSH
70156: LD_VAR 0 1
70160: PUSH
70161: LD_INT 2
70163: ARRAY
70164: PPUSH
70165: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
70169: LD_VAR 0 1
70173: PUSH
70174: LD_INT 1
70176: ARRAY
70177: PPUSH
70178: LD_VAR 0 1
70182: PUSH
70183: LD_INT 2
70185: ARRAY
70186: PPUSH
70187: CALL_OW 429
// end ; end ;
70191: LD_VAR 0 1
70195: RET
// every 0 0$1 trigger StreamModeActive and sReset do
70196: LD_EXP 99
70200: PUSH
70201: LD_EXP 121
70205: AND
70206: IFFALSE 70218
70208: GO 70210
70210: DISABLE
// YouLost (  ) ;
70211: LD_STRING 
70213: PPUSH
70214: CALL_OW 104
70218: END
// every 0 0$1 trigger StreamModeActive and sFog do
70219: LD_EXP 99
70223: PUSH
70224: LD_EXP 120
70228: AND
70229: IFFALSE 70243
70231: GO 70233
70233: DISABLE
// FogOff ( your_side ) ;
70234: LD_OWVAR 2
70238: PPUSH
70239: CALL_OW 344
70243: END
// every 0 0$1 trigger StreamModeActive and sSun do
70244: LD_EXP 99
70248: PUSH
70249: LD_EXP 122
70253: AND
70254: IFFALSE 70282
70256: GO 70258
70258: DISABLE
// begin solar_recharge_percent := 0 ;
70259: LD_ADDR_OWVAR 79
70263: PUSH
70264: LD_INT 0
70266: ST_TO_ADDR
// wait ( 5 5$00 ) ;
70267: LD_INT 10500
70269: PPUSH
70270: CALL_OW 67
// solar_recharge_percent := 100 ;
70274: LD_ADDR_OWVAR 79
70278: PUSH
70279: LD_INT 100
70281: ST_TO_ADDR
// end ;
70282: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
70283: LD_EXP 99
70287: PUSH
70288: LD_EXP 123
70292: AND
70293: IFFALSE 70532
70295: GO 70297
70297: DISABLE
70298: LD_INT 0
70300: PPUSH
70301: PPUSH
70302: PPUSH
// begin tmp := [ ] ;
70303: LD_ADDR_VAR 0 3
70307: PUSH
70308: EMPTY
70309: ST_TO_ADDR
// for i := 1 to 6 do
70310: LD_ADDR_VAR 0 1
70314: PUSH
70315: DOUBLE
70316: LD_INT 1
70318: DEC
70319: ST_TO_ADDR
70320: LD_INT 6
70322: PUSH
70323: FOR_TO
70324: IFFALSE 70429
// begin uc_nation := nation_nature ;
70326: LD_ADDR_OWVAR 21
70330: PUSH
70331: LD_INT 0
70333: ST_TO_ADDR
// uc_side := 0 ;
70334: LD_ADDR_OWVAR 20
70338: PUSH
70339: LD_INT 0
70341: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
70342: LD_ADDR_OWVAR 29
70346: PUSH
70347: LD_INT 12
70349: PUSH
70350: LD_INT 12
70352: PUSH
70353: EMPTY
70354: LIST
70355: LIST
70356: ST_TO_ADDR
// hc_agressivity := 20 ;
70357: LD_ADDR_OWVAR 35
70361: PUSH
70362: LD_INT 20
70364: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
70365: LD_ADDR_OWVAR 28
70369: PUSH
70370: LD_INT 17
70372: ST_TO_ADDR
// hc_gallery :=  ;
70373: LD_ADDR_OWVAR 33
70377: PUSH
70378: LD_STRING 
70380: ST_TO_ADDR
// hc_name :=  ;
70381: LD_ADDR_OWVAR 26
70385: PUSH
70386: LD_STRING 
70388: ST_TO_ADDR
// un := CreateHuman ;
70389: LD_ADDR_VAR 0 2
70393: PUSH
70394: CALL_OW 44
70398: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
70399: LD_VAR 0 2
70403: PPUSH
70404: LD_INT 1
70406: PPUSH
70407: CALL_OW 51
// tmp := tmp ^ un ;
70411: LD_ADDR_VAR 0 3
70415: PUSH
70416: LD_VAR 0 3
70420: PUSH
70421: LD_VAR 0 2
70425: ADD
70426: ST_TO_ADDR
// end ;
70427: GO 70323
70429: POP
70430: POP
// repeat wait ( 0 0$1 ) ;
70431: LD_INT 35
70433: PPUSH
70434: CALL_OW 67
// for un in tmp do
70438: LD_ADDR_VAR 0 2
70442: PUSH
70443: LD_VAR 0 3
70447: PUSH
70448: FOR_IN
70449: IFFALSE 70523
// begin if IsDead ( un ) then
70451: LD_VAR 0 2
70455: PPUSH
70456: CALL_OW 301
70460: IFFALSE 70480
// begin tmp := tmp diff un ;
70462: LD_ADDR_VAR 0 3
70466: PUSH
70467: LD_VAR 0 3
70471: PUSH
70472: LD_VAR 0 2
70476: DIFF
70477: ST_TO_ADDR
// continue ;
70478: GO 70448
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
70480: LD_VAR 0 2
70484: PPUSH
70485: LD_INT 3
70487: PUSH
70488: LD_INT 22
70490: PUSH
70491: LD_INT 0
70493: PUSH
70494: EMPTY
70495: LIST
70496: LIST
70497: PUSH
70498: EMPTY
70499: LIST
70500: LIST
70501: PPUSH
70502: CALL_OW 69
70506: PPUSH
70507: LD_VAR 0 2
70511: PPUSH
70512: CALL_OW 74
70516: PPUSH
70517: CALL_OW 115
// end ;
70521: GO 70448
70523: POP
70524: POP
// until not tmp ;
70525: LD_VAR 0 3
70529: NOT
70530: IFFALSE 70431
// end ;
70532: PPOPN 3
70534: END
// every 0 0$1 trigger StreamModeActive and sTroll do
70535: LD_EXP 99
70539: PUSH
70540: LD_EXP 124
70544: AND
70545: IFFALSE 70599
70547: GO 70549
70549: DISABLE
// begin ToLua ( displayTroll(); ) ;
70550: LD_STRING displayTroll();
70552: PPUSH
70553: CALL_OW 559
// wait ( 3 3$00 ) ;
70557: LD_INT 6300
70559: PPUSH
70560: CALL_OW 67
// ToLua ( hideTroll(); ) ;
70564: LD_STRING hideTroll();
70566: PPUSH
70567: CALL_OW 559
// wait ( 1 1$00 ) ;
70571: LD_INT 2100
70573: PPUSH
70574: CALL_OW 67
// ToLua ( displayTroll(); ) ;
70578: LD_STRING displayTroll();
70580: PPUSH
70581: CALL_OW 559
// wait ( 1 1$00 ) ;
70585: LD_INT 2100
70587: PPUSH
70588: CALL_OW 67
// ToLua ( hideTroll(); ) ;
70592: LD_STRING hideTroll();
70594: PPUSH
70595: CALL_OW 559
// end ;
70599: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
70600: LD_EXP 99
70604: PUSH
70605: LD_EXP 125
70609: AND
70610: IFFALSE 70673
70612: GO 70614
70614: DISABLE
70615: LD_INT 0
70617: PPUSH
// begin p := 0 ;
70618: LD_ADDR_VAR 0 1
70622: PUSH
70623: LD_INT 0
70625: ST_TO_ADDR
// repeat game_speed := 1 ;
70626: LD_ADDR_OWVAR 65
70630: PUSH
70631: LD_INT 1
70633: ST_TO_ADDR
// wait ( 0 0$1 ) ;
70634: LD_INT 35
70636: PPUSH
70637: CALL_OW 67
// p := p + 1 ;
70641: LD_ADDR_VAR 0 1
70645: PUSH
70646: LD_VAR 0 1
70650: PUSH
70651: LD_INT 1
70653: PLUS
70654: ST_TO_ADDR
// until p >= 60 ;
70655: LD_VAR 0 1
70659: PUSH
70660: LD_INT 60
70662: GREATEREQUAL
70663: IFFALSE 70626
// game_speed := 4 ;
70665: LD_ADDR_OWVAR 65
70669: PUSH
70670: LD_INT 4
70672: ST_TO_ADDR
// end ;
70673: PPOPN 1
70675: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
70676: LD_EXP 99
70680: PUSH
70681: LD_EXP 126
70685: AND
70686: IFFALSE 70832
70688: GO 70690
70690: DISABLE
70691: LD_INT 0
70693: PPUSH
70694: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
70695: LD_ADDR_VAR 0 1
70699: PUSH
70700: LD_INT 22
70702: PUSH
70703: LD_OWVAR 2
70707: PUSH
70708: EMPTY
70709: LIST
70710: LIST
70711: PUSH
70712: LD_INT 2
70714: PUSH
70715: LD_INT 30
70717: PUSH
70718: LD_INT 0
70720: PUSH
70721: EMPTY
70722: LIST
70723: LIST
70724: PUSH
70725: LD_INT 30
70727: PUSH
70728: LD_INT 1
70730: PUSH
70731: EMPTY
70732: LIST
70733: LIST
70734: PUSH
70735: EMPTY
70736: LIST
70737: LIST
70738: LIST
70739: PUSH
70740: EMPTY
70741: LIST
70742: LIST
70743: PPUSH
70744: CALL_OW 69
70748: ST_TO_ADDR
// if not depot then
70749: LD_VAR 0 1
70753: NOT
70754: IFFALSE 70758
// exit ;
70756: GO 70832
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
70758: LD_ADDR_VAR 0 2
70762: PUSH
70763: LD_VAR 0 1
70767: PUSH
70768: LD_INT 1
70770: PPUSH
70771: LD_VAR 0 1
70775: PPUSH
70776: CALL_OW 12
70780: ARRAY
70781: PPUSH
70782: CALL_OW 274
70786: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
70787: LD_VAR 0 2
70791: PPUSH
70792: LD_INT 1
70794: PPUSH
70795: LD_INT 0
70797: PPUSH
70798: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
70802: LD_VAR 0 2
70806: PPUSH
70807: LD_INT 2
70809: PPUSH
70810: LD_INT 0
70812: PPUSH
70813: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
70817: LD_VAR 0 2
70821: PPUSH
70822: LD_INT 3
70824: PPUSH
70825: LD_INT 0
70827: PPUSH
70828: CALL_OW 277
// end ;
70832: PPOPN 2
70834: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
70835: LD_EXP 99
70839: PUSH
70840: LD_EXP 127
70844: AND
70845: IFFALSE 70942
70847: GO 70849
70849: DISABLE
70850: LD_INT 0
70852: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
70853: LD_ADDR_VAR 0 1
70857: PUSH
70858: LD_INT 22
70860: PUSH
70861: LD_OWVAR 2
70865: PUSH
70866: EMPTY
70867: LIST
70868: LIST
70869: PUSH
70870: LD_INT 21
70872: PUSH
70873: LD_INT 1
70875: PUSH
70876: EMPTY
70877: LIST
70878: LIST
70879: PUSH
70880: LD_INT 3
70882: PUSH
70883: LD_INT 23
70885: PUSH
70886: LD_INT 0
70888: PUSH
70889: EMPTY
70890: LIST
70891: LIST
70892: PUSH
70893: EMPTY
70894: LIST
70895: LIST
70896: PUSH
70897: EMPTY
70898: LIST
70899: LIST
70900: LIST
70901: PPUSH
70902: CALL_OW 69
70906: ST_TO_ADDR
// if not tmp then
70907: LD_VAR 0 1
70911: NOT
70912: IFFALSE 70916
// exit ;
70914: GO 70942
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
70916: LD_VAR 0 1
70920: PUSH
70921: LD_INT 1
70923: PPUSH
70924: LD_VAR 0 1
70928: PPUSH
70929: CALL_OW 12
70933: ARRAY
70934: PPUSH
70935: LD_INT 200
70937: PPUSH
70938: CALL_OW 234
// end ;
70942: PPOPN 1
70944: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
70945: LD_EXP 99
70949: PUSH
70950: LD_EXP 128
70954: AND
70955: IFFALSE 71034
70957: GO 70959
70959: DISABLE
70960: LD_INT 0
70962: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
70963: LD_ADDR_VAR 0 1
70967: PUSH
70968: LD_INT 22
70970: PUSH
70971: LD_OWVAR 2
70975: PUSH
70976: EMPTY
70977: LIST
70978: LIST
70979: PUSH
70980: LD_INT 21
70982: PUSH
70983: LD_INT 2
70985: PUSH
70986: EMPTY
70987: LIST
70988: LIST
70989: PUSH
70990: EMPTY
70991: LIST
70992: LIST
70993: PPUSH
70994: CALL_OW 69
70998: ST_TO_ADDR
// if not tmp then
70999: LD_VAR 0 1
71003: NOT
71004: IFFALSE 71008
// exit ;
71006: GO 71034
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
71008: LD_VAR 0 1
71012: PUSH
71013: LD_INT 1
71015: PPUSH
71016: LD_VAR 0 1
71020: PPUSH
71021: CALL_OW 12
71025: ARRAY
71026: PPUSH
71027: LD_INT 60
71029: PPUSH
71030: CALL_OW 234
// end ;
71034: PPOPN 1
71036: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
71037: LD_EXP 99
71041: PUSH
71042: LD_EXP 129
71046: AND
71047: IFFALSE 71146
71049: GO 71051
71051: DISABLE
71052: LD_INT 0
71054: PPUSH
71055: PPUSH
// begin enable ;
71056: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
71057: LD_ADDR_VAR 0 1
71061: PUSH
71062: LD_INT 22
71064: PUSH
71065: LD_OWVAR 2
71069: PUSH
71070: EMPTY
71071: LIST
71072: LIST
71073: PUSH
71074: LD_INT 61
71076: PUSH
71077: EMPTY
71078: LIST
71079: PUSH
71080: LD_INT 33
71082: PUSH
71083: LD_INT 2
71085: PUSH
71086: EMPTY
71087: LIST
71088: LIST
71089: PUSH
71090: EMPTY
71091: LIST
71092: LIST
71093: LIST
71094: PPUSH
71095: CALL_OW 69
71099: ST_TO_ADDR
// if not tmp then
71100: LD_VAR 0 1
71104: NOT
71105: IFFALSE 71109
// exit ;
71107: GO 71146
// for i in tmp do
71109: LD_ADDR_VAR 0 2
71113: PUSH
71114: LD_VAR 0 1
71118: PUSH
71119: FOR_IN
71120: IFFALSE 71144
// if IsControledBy ( i ) then
71122: LD_VAR 0 2
71126: PPUSH
71127: CALL_OW 312
71131: IFFALSE 71142
// ComUnlink ( i ) ;
71133: LD_VAR 0 2
71137: PPUSH
71138: CALL_OW 136
71142: GO 71119
71144: POP
71145: POP
// end ;
71146: PPOPN 2
71148: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
71149: LD_EXP 99
71153: PUSH
71154: LD_EXP 130
71158: AND
71159: IFFALSE 71299
71161: GO 71163
71163: DISABLE
71164: LD_INT 0
71166: PPUSH
71167: PPUSH
// begin ToLua ( displayPowell(); ) ;
71168: LD_STRING displayPowell();
71170: PPUSH
71171: CALL_OW 559
// uc_side := 0 ;
71175: LD_ADDR_OWVAR 20
71179: PUSH
71180: LD_INT 0
71182: ST_TO_ADDR
// uc_nation := 2 ;
71183: LD_ADDR_OWVAR 21
71187: PUSH
71188: LD_INT 2
71190: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
71191: LD_ADDR_OWVAR 37
71195: PUSH
71196: LD_INT 14
71198: ST_TO_ADDR
// vc_engine := engine_siberite ;
71199: LD_ADDR_OWVAR 39
71203: PUSH
71204: LD_INT 3
71206: ST_TO_ADDR
// vc_control := control_apeman ;
71207: LD_ADDR_OWVAR 38
71211: PUSH
71212: LD_INT 5
71214: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
71215: LD_ADDR_OWVAR 40
71219: PUSH
71220: LD_INT 29
71222: ST_TO_ADDR
// un := CreateVehicle ;
71223: LD_ADDR_VAR 0 2
71227: PUSH
71228: CALL_OW 45
71232: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
71233: LD_VAR 0 2
71237: PPUSH
71238: LD_INT 1
71240: PPUSH
71241: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
71245: LD_INT 35
71247: PPUSH
71248: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
71252: LD_VAR 0 2
71256: PPUSH
71257: LD_INT 22
71259: PUSH
71260: LD_OWVAR 2
71264: PUSH
71265: EMPTY
71266: LIST
71267: LIST
71268: PPUSH
71269: CALL_OW 69
71273: PPUSH
71274: LD_VAR 0 2
71278: PPUSH
71279: CALL_OW 74
71283: PPUSH
71284: CALL_OW 115
// until IsDead ( un ) ;
71288: LD_VAR 0 2
71292: PPUSH
71293: CALL_OW 301
71297: IFFALSE 71245
// end ;
71299: PPOPN 2
71301: END
// every 0 0$1 trigger StreamModeActive and sStu do
71302: LD_EXP 99
71306: PUSH
71307: LD_EXP 138
71311: AND
71312: IFFALSE 71328
71314: GO 71316
71316: DISABLE
// begin ToLua ( displayStucuk(); ) ;
71317: LD_STRING displayStucuk();
71319: PPUSH
71320: CALL_OW 559
// ResetFog ;
71324: CALL_OW 335
// end ;
71328: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
71329: LD_EXP 99
71333: PUSH
71334: LD_EXP 131
71338: AND
71339: IFFALSE 71480
71341: GO 71343
71343: DISABLE
71344: LD_INT 0
71346: PPUSH
71347: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
71348: LD_ADDR_VAR 0 2
71352: PUSH
71353: LD_INT 22
71355: PUSH
71356: LD_OWVAR 2
71360: PUSH
71361: EMPTY
71362: LIST
71363: LIST
71364: PUSH
71365: LD_INT 21
71367: PUSH
71368: LD_INT 1
71370: PUSH
71371: EMPTY
71372: LIST
71373: LIST
71374: PUSH
71375: EMPTY
71376: LIST
71377: LIST
71378: PPUSH
71379: CALL_OW 69
71383: ST_TO_ADDR
// if not tmp then
71384: LD_VAR 0 2
71388: NOT
71389: IFFALSE 71393
// exit ;
71391: GO 71480
// un := tmp [ rand ( 1 , tmp ) ] ;
71393: LD_ADDR_VAR 0 1
71397: PUSH
71398: LD_VAR 0 2
71402: PUSH
71403: LD_INT 1
71405: PPUSH
71406: LD_VAR 0 2
71410: PPUSH
71411: CALL_OW 12
71415: ARRAY
71416: ST_TO_ADDR
// SetSide ( un , 0 ) ;
71417: LD_VAR 0 1
71421: PPUSH
71422: LD_INT 0
71424: PPUSH
71425: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
71429: LD_VAR 0 1
71433: PPUSH
71434: LD_OWVAR 3
71438: PUSH
71439: LD_VAR 0 1
71443: DIFF
71444: PPUSH
71445: LD_VAR 0 1
71449: PPUSH
71450: CALL_OW 74
71454: PPUSH
71455: CALL_OW 115
// wait ( 0 0$20 ) ;
71459: LD_INT 700
71461: PPUSH
71462: CALL_OW 67
// SetSide ( un , your_side ) ;
71466: LD_VAR 0 1
71470: PPUSH
71471: LD_OWVAR 2
71475: PPUSH
71476: CALL_OW 235
// end ;
71480: PPOPN 2
71482: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
71483: LD_EXP 99
71487: PUSH
71488: LD_EXP 132
71492: AND
71493: IFFALSE 71599
71495: GO 71497
71497: DISABLE
71498: LD_INT 0
71500: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
71501: LD_ADDR_VAR 0 1
71505: PUSH
71506: LD_INT 22
71508: PUSH
71509: LD_OWVAR 2
71513: PUSH
71514: EMPTY
71515: LIST
71516: LIST
71517: PUSH
71518: LD_INT 2
71520: PUSH
71521: LD_INT 30
71523: PUSH
71524: LD_INT 0
71526: PUSH
71527: EMPTY
71528: LIST
71529: LIST
71530: PUSH
71531: LD_INT 30
71533: PUSH
71534: LD_INT 1
71536: PUSH
71537: EMPTY
71538: LIST
71539: LIST
71540: PUSH
71541: EMPTY
71542: LIST
71543: LIST
71544: LIST
71545: PUSH
71546: EMPTY
71547: LIST
71548: LIST
71549: PPUSH
71550: CALL_OW 69
71554: ST_TO_ADDR
// if not depot then
71555: LD_VAR 0 1
71559: NOT
71560: IFFALSE 71564
// exit ;
71562: GO 71599
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
71564: LD_VAR 0 1
71568: PUSH
71569: LD_INT 1
71571: ARRAY
71572: PPUSH
71573: CALL_OW 250
71577: PPUSH
71578: LD_VAR 0 1
71582: PUSH
71583: LD_INT 1
71585: ARRAY
71586: PPUSH
71587: CALL_OW 251
71591: PPUSH
71592: LD_INT 70
71594: PPUSH
71595: CALL_OW 495
// end ;
71599: PPOPN 1
71601: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
71602: LD_EXP 99
71606: PUSH
71607: LD_EXP 133
71611: AND
71612: IFFALSE 71823
71614: GO 71616
71616: DISABLE
71617: LD_INT 0
71619: PPUSH
71620: PPUSH
71621: PPUSH
71622: PPUSH
71623: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
71624: LD_ADDR_VAR 0 5
71628: PUSH
71629: LD_INT 22
71631: PUSH
71632: LD_OWVAR 2
71636: PUSH
71637: EMPTY
71638: LIST
71639: LIST
71640: PUSH
71641: LD_INT 21
71643: PUSH
71644: LD_INT 1
71646: PUSH
71647: EMPTY
71648: LIST
71649: LIST
71650: PUSH
71651: EMPTY
71652: LIST
71653: LIST
71654: PPUSH
71655: CALL_OW 69
71659: ST_TO_ADDR
// if not tmp then
71660: LD_VAR 0 5
71664: NOT
71665: IFFALSE 71669
// exit ;
71667: GO 71823
// for i in tmp do
71669: LD_ADDR_VAR 0 1
71673: PUSH
71674: LD_VAR 0 5
71678: PUSH
71679: FOR_IN
71680: IFFALSE 71821
// begin d := rand ( 0 , 5 ) ;
71682: LD_ADDR_VAR 0 4
71686: PUSH
71687: LD_INT 0
71689: PPUSH
71690: LD_INT 5
71692: PPUSH
71693: CALL_OW 12
71697: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
71698: LD_ADDR_VAR 0 2
71702: PUSH
71703: LD_VAR 0 1
71707: PPUSH
71708: CALL_OW 250
71712: PPUSH
71713: LD_VAR 0 4
71717: PPUSH
71718: LD_INT 3
71720: PPUSH
71721: LD_INT 12
71723: PPUSH
71724: CALL_OW 12
71728: PPUSH
71729: CALL_OW 272
71733: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
71734: LD_ADDR_VAR 0 3
71738: PUSH
71739: LD_VAR 0 1
71743: PPUSH
71744: CALL_OW 251
71748: PPUSH
71749: LD_VAR 0 4
71753: PPUSH
71754: LD_INT 3
71756: PPUSH
71757: LD_INT 12
71759: PPUSH
71760: CALL_OW 12
71764: PPUSH
71765: CALL_OW 273
71769: ST_TO_ADDR
// if ValidHex ( x , y ) then
71770: LD_VAR 0 2
71774: PPUSH
71775: LD_VAR 0 3
71779: PPUSH
71780: CALL_OW 488
71784: IFFALSE 71819
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
71786: LD_VAR 0 1
71790: PPUSH
71791: LD_VAR 0 2
71795: PPUSH
71796: LD_VAR 0 3
71800: PPUSH
71801: LD_INT 3
71803: PPUSH
71804: LD_INT 6
71806: PPUSH
71807: CALL_OW 12
71811: PPUSH
71812: LD_INT 1
71814: PPUSH
71815: CALL_OW 483
// end ;
71819: GO 71679
71821: POP
71822: POP
// end ;
71823: PPOPN 5
71825: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
71826: LD_EXP 99
71830: PUSH
71831: LD_EXP 134
71835: AND
71836: IFFALSE 71930
71838: GO 71840
71840: DISABLE
71841: LD_INT 0
71843: PPUSH
71844: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
71845: LD_ADDR_VAR 0 2
71849: PUSH
71850: LD_INT 22
71852: PUSH
71853: LD_OWVAR 2
71857: PUSH
71858: EMPTY
71859: LIST
71860: LIST
71861: PUSH
71862: LD_INT 32
71864: PUSH
71865: LD_INT 1
71867: PUSH
71868: EMPTY
71869: LIST
71870: LIST
71871: PUSH
71872: LD_INT 21
71874: PUSH
71875: LD_INT 2
71877: PUSH
71878: EMPTY
71879: LIST
71880: LIST
71881: PUSH
71882: EMPTY
71883: LIST
71884: LIST
71885: LIST
71886: PPUSH
71887: CALL_OW 69
71891: ST_TO_ADDR
// if not tmp then
71892: LD_VAR 0 2
71896: NOT
71897: IFFALSE 71901
// exit ;
71899: GO 71930
// for i in tmp do
71901: LD_ADDR_VAR 0 1
71905: PUSH
71906: LD_VAR 0 2
71910: PUSH
71911: FOR_IN
71912: IFFALSE 71928
// SetFuel ( i , 0 ) ;
71914: LD_VAR 0 1
71918: PPUSH
71919: LD_INT 0
71921: PPUSH
71922: CALL_OW 240
71926: GO 71911
71928: POP
71929: POP
// end ;
71930: PPOPN 2
71932: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
71933: LD_EXP 99
71937: PUSH
71938: LD_EXP 135
71942: AND
71943: IFFALSE 72009
71945: GO 71947
71947: DISABLE
71948: LD_INT 0
71950: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
71951: LD_ADDR_VAR 0 1
71955: PUSH
71956: LD_INT 22
71958: PUSH
71959: LD_OWVAR 2
71963: PUSH
71964: EMPTY
71965: LIST
71966: LIST
71967: PUSH
71968: LD_INT 30
71970: PUSH
71971: LD_INT 29
71973: PUSH
71974: EMPTY
71975: LIST
71976: LIST
71977: PUSH
71978: EMPTY
71979: LIST
71980: LIST
71981: PPUSH
71982: CALL_OW 69
71986: ST_TO_ADDR
// if not tmp then
71987: LD_VAR 0 1
71991: NOT
71992: IFFALSE 71996
// exit ;
71994: GO 72009
// DestroyUnit ( tmp [ 1 ] ) ;
71996: LD_VAR 0 1
72000: PUSH
72001: LD_INT 1
72003: ARRAY
72004: PPUSH
72005: CALL_OW 65
// end ;
72009: PPOPN 1
72011: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
72012: LD_EXP 99
72016: PUSH
72017: LD_EXP 137
72021: AND
72022: IFFALSE 72151
72024: GO 72026
72026: DISABLE
72027: LD_INT 0
72029: PPUSH
// begin uc_side := 0 ;
72030: LD_ADDR_OWVAR 20
72034: PUSH
72035: LD_INT 0
72037: ST_TO_ADDR
// uc_nation := nation_arabian ;
72038: LD_ADDR_OWVAR 21
72042: PUSH
72043: LD_INT 2
72045: ST_TO_ADDR
// hc_gallery :=  ;
72046: LD_ADDR_OWVAR 33
72050: PUSH
72051: LD_STRING 
72053: ST_TO_ADDR
// hc_name :=  ;
72054: LD_ADDR_OWVAR 26
72058: PUSH
72059: LD_STRING 
72061: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
72062: LD_INT 1
72064: PPUSH
72065: LD_INT 11
72067: PPUSH
72068: LD_INT 10
72070: PPUSH
72071: CALL_OW 380
// un := CreateHuman ;
72075: LD_ADDR_VAR 0 1
72079: PUSH
72080: CALL_OW 44
72084: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
72085: LD_VAR 0 1
72089: PPUSH
72090: LD_INT 1
72092: PPUSH
72093: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
72097: LD_INT 35
72099: PPUSH
72100: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
72104: LD_VAR 0 1
72108: PPUSH
72109: LD_INT 22
72111: PUSH
72112: LD_OWVAR 2
72116: PUSH
72117: EMPTY
72118: LIST
72119: LIST
72120: PPUSH
72121: CALL_OW 69
72125: PPUSH
72126: LD_VAR 0 1
72130: PPUSH
72131: CALL_OW 74
72135: PPUSH
72136: CALL_OW 115
// until IsDead ( un ) ;
72140: LD_VAR 0 1
72144: PPUSH
72145: CALL_OW 301
72149: IFFALSE 72097
// end ;
72151: PPOPN 1
72153: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
72154: LD_EXP 99
72158: PUSH
72159: LD_EXP 139
72163: AND
72164: IFFALSE 72176
72166: GO 72168
72168: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
72169: LD_STRING earthquake(getX(game), 0, 32)
72171: PPUSH
72172: CALL_OW 559
72176: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
72177: LD_EXP 99
72181: PUSH
72182: LD_EXP 140
72186: AND
72187: IFFALSE 72278
72189: GO 72191
72191: DISABLE
72192: LD_INT 0
72194: PPUSH
// begin enable ;
72195: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
72196: LD_ADDR_VAR 0 1
72200: PUSH
72201: LD_INT 22
72203: PUSH
72204: LD_OWVAR 2
72208: PUSH
72209: EMPTY
72210: LIST
72211: LIST
72212: PUSH
72213: LD_INT 21
72215: PUSH
72216: LD_INT 2
72218: PUSH
72219: EMPTY
72220: LIST
72221: LIST
72222: PUSH
72223: LD_INT 33
72225: PUSH
72226: LD_INT 3
72228: PUSH
72229: EMPTY
72230: LIST
72231: LIST
72232: PUSH
72233: EMPTY
72234: LIST
72235: LIST
72236: LIST
72237: PPUSH
72238: CALL_OW 69
72242: ST_TO_ADDR
// if not tmp then
72243: LD_VAR 0 1
72247: NOT
72248: IFFALSE 72252
// exit ;
72250: GO 72278
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
72252: LD_VAR 0 1
72256: PUSH
72257: LD_INT 1
72259: PPUSH
72260: LD_VAR 0 1
72264: PPUSH
72265: CALL_OW 12
72269: ARRAY
72270: PPUSH
72271: LD_INT 1
72273: PPUSH
72274: CALL_OW 234
// end ;
72278: PPOPN 1
72280: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
72281: LD_EXP 99
72285: PUSH
72286: LD_EXP 141
72290: AND
72291: IFFALSE 72432
72293: GO 72295
72295: DISABLE
72296: LD_INT 0
72298: PPUSH
72299: PPUSH
72300: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
72301: LD_ADDR_VAR 0 3
72305: PUSH
72306: LD_INT 22
72308: PUSH
72309: LD_OWVAR 2
72313: PUSH
72314: EMPTY
72315: LIST
72316: LIST
72317: PUSH
72318: LD_INT 25
72320: PUSH
72321: LD_INT 1
72323: PUSH
72324: EMPTY
72325: LIST
72326: LIST
72327: PUSH
72328: EMPTY
72329: LIST
72330: LIST
72331: PPUSH
72332: CALL_OW 69
72336: ST_TO_ADDR
// if not tmp then
72337: LD_VAR 0 3
72341: NOT
72342: IFFALSE 72346
// exit ;
72344: GO 72432
// un := tmp [ rand ( 1 , tmp ) ] ;
72346: LD_ADDR_VAR 0 2
72350: PUSH
72351: LD_VAR 0 3
72355: PUSH
72356: LD_INT 1
72358: PPUSH
72359: LD_VAR 0 3
72363: PPUSH
72364: CALL_OW 12
72368: ARRAY
72369: ST_TO_ADDR
// if Crawls ( un ) then
72370: LD_VAR 0 2
72374: PPUSH
72375: CALL_OW 318
72379: IFFALSE 72390
// ComWalk ( un ) ;
72381: LD_VAR 0 2
72385: PPUSH
72386: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
72390: LD_VAR 0 2
72394: PPUSH
72395: LD_INT 9
72397: PPUSH
72398: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
72402: LD_INT 28
72404: PPUSH
72405: LD_OWVAR 2
72409: PPUSH
72410: LD_INT 2
72412: PPUSH
72413: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
72417: LD_INT 29
72419: PPUSH
72420: LD_OWVAR 2
72424: PPUSH
72425: LD_INT 2
72427: PPUSH
72428: CALL_OW 322
// end ;
72432: PPOPN 3
72434: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
72435: LD_EXP 99
72439: PUSH
72440: LD_EXP 142
72444: AND
72445: IFFALSE 72556
72447: GO 72449
72449: DISABLE
72450: LD_INT 0
72452: PPUSH
72453: PPUSH
72454: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
72455: LD_ADDR_VAR 0 3
72459: PUSH
72460: LD_INT 22
72462: PUSH
72463: LD_OWVAR 2
72467: PUSH
72468: EMPTY
72469: LIST
72470: LIST
72471: PUSH
72472: LD_INT 25
72474: PUSH
72475: LD_INT 1
72477: PUSH
72478: EMPTY
72479: LIST
72480: LIST
72481: PUSH
72482: EMPTY
72483: LIST
72484: LIST
72485: PPUSH
72486: CALL_OW 69
72490: ST_TO_ADDR
// if not tmp then
72491: LD_VAR 0 3
72495: NOT
72496: IFFALSE 72500
// exit ;
72498: GO 72556
// un := tmp [ rand ( 1 , tmp ) ] ;
72500: LD_ADDR_VAR 0 2
72504: PUSH
72505: LD_VAR 0 3
72509: PUSH
72510: LD_INT 1
72512: PPUSH
72513: LD_VAR 0 3
72517: PPUSH
72518: CALL_OW 12
72522: ARRAY
72523: ST_TO_ADDR
// if Crawls ( un ) then
72524: LD_VAR 0 2
72528: PPUSH
72529: CALL_OW 318
72533: IFFALSE 72544
// ComWalk ( un ) ;
72535: LD_VAR 0 2
72539: PPUSH
72540: CALL_OW 138
// SetClass ( un , class_mortar ) ;
72544: LD_VAR 0 2
72548: PPUSH
72549: LD_INT 8
72551: PPUSH
72552: CALL_OW 336
// end ;
72556: PPOPN 3
72558: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
72559: LD_EXP 99
72563: PUSH
72564: LD_EXP 143
72568: AND
72569: IFFALSE 72713
72571: GO 72573
72573: DISABLE
72574: LD_INT 0
72576: PPUSH
72577: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
72578: LD_ADDR_VAR 0 2
72582: PUSH
72583: LD_INT 22
72585: PUSH
72586: LD_OWVAR 2
72590: PUSH
72591: EMPTY
72592: LIST
72593: LIST
72594: PUSH
72595: LD_INT 21
72597: PUSH
72598: LD_INT 2
72600: PUSH
72601: EMPTY
72602: LIST
72603: LIST
72604: PUSH
72605: LD_INT 2
72607: PUSH
72608: LD_INT 34
72610: PUSH
72611: LD_INT 12
72613: PUSH
72614: EMPTY
72615: LIST
72616: LIST
72617: PUSH
72618: LD_INT 34
72620: PUSH
72621: LD_INT 51
72623: PUSH
72624: EMPTY
72625: LIST
72626: LIST
72627: PUSH
72628: LD_INT 34
72630: PUSH
72631: LD_INT 32
72633: PUSH
72634: EMPTY
72635: LIST
72636: LIST
72637: PUSH
72638: EMPTY
72639: LIST
72640: LIST
72641: LIST
72642: LIST
72643: PUSH
72644: EMPTY
72645: LIST
72646: LIST
72647: LIST
72648: PPUSH
72649: CALL_OW 69
72653: ST_TO_ADDR
// if not tmp then
72654: LD_VAR 0 2
72658: NOT
72659: IFFALSE 72663
// exit ;
72661: GO 72713
// for i in tmp do
72663: LD_ADDR_VAR 0 1
72667: PUSH
72668: LD_VAR 0 2
72672: PUSH
72673: FOR_IN
72674: IFFALSE 72711
// if GetCargo ( i , mat_artifact ) = 0 then
72676: LD_VAR 0 1
72680: PPUSH
72681: LD_INT 4
72683: PPUSH
72684: CALL_OW 289
72688: PUSH
72689: LD_INT 0
72691: EQUAL
72692: IFFALSE 72709
// SetCargo ( i , mat_siberit , 100 ) ;
72694: LD_VAR 0 1
72698: PPUSH
72699: LD_INT 3
72701: PPUSH
72702: LD_INT 100
72704: PPUSH
72705: CALL_OW 290
72709: GO 72673
72711: POP
72712: POP
// end ;
72713: PPOPN 2
72715: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
72716: LD_EXP 99
72720: PUSH
72721: LD_EXP 144
72725: AND
72726: IFFALSE 72909
72728: GO 72730
72730: DISABLE
72731: LD_INT 0
72733: PPUSH
72734: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
72735: LD_ADDR_VAR 0 2
72739: PUSH
72740: LD_INT 22
72742: PUSH
72743: LD_OWVAR 2
72747: PUSH
72748: EMPTY
72749: LIST
72750: LIST
72751: PPUSH
72752: CALL_OW 69
72756: ST_TO_ADDR
// if not tmp then
72757: LD_VAR 0 2
72761: NOT
72762: IFFALSE 72766
// exit ;
72764: GO 72909
// for i := 1 to 2 do
72766: LD_ADDR_VAR 0 1
72770: PUSH
72771: DOUBLE
72772: LD_INT 1
72774: DEC
72775: ST_TO_ADDR
72776: LD_INT 2
72778: PUSH
72779: FOR_TO
72780: IFFALSE 72907
// begin uc_side := your_side ;
72782: LD_ADDR_OWVAR 20
72786: PUSH
72787: LD_OWVAR 2
72791: ST_TO_ADDR
// uc_nation := nation_american ;
72792: LD_ADDR_OWVAR 21
72796: PUSH
72797: LD_INT 1
72799: ST_TO_ADDR
// vc_chassis := us_morphling ;
72800: LD_ADDR_OWVAR 37
72804: PUSH
72805: LD_INT 5
72807: ST_TO_ADDR
// vc_engine := engine_siberite ;
72808: LD_ADDR_OWVAR 39
72812: PUSH
72813: LD_INT 3
72815: ST_TO_ADDR
// vc_control := control_computer ;
72816: LD_ADDR_OWVAR 38
72820: PUSH
72821: LD_INT 3
72823: ST_TO_ADDR
// vc_weapon := us_double_laser ;
72824: LD_ADDR_OWVAR 40
72828: PUSH
72829: LD_INT 10
72831: ST_TO_ADDR
// if not IsInUnit ( tmp [ 1 ] ) then
72832: LD_VAR 0 2
72836: PUSH
72837: LD_INT 1
72839: ARRAY
72840: PPUSH
72841: CALL_OW 310
72845: NOT
72846: IFFALSE 72893
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) else
72848: CALL_OW 45
72852: PPUSH
72853: LD_VAR 0 2
72857: PUSH
72858: LD_INT 1
72860: ARRAY
72861: PPUSH
72862: CALL_OW 250
72866: PPUSH
72867: LD_VAR 0 2
72871: PUSH
72872: LD_INT 1
72874: ARRAY
72875: PPUSH
72876: CALL_OW 251
72880: PPUSH
72881: LD_INT 12
72883: PPUSH
72884: LD_INT 1
72886: PPUSH
72887: CALL_OW 50
72891: GO 72905
// PlaceUnitAnywhere ( CreateVehicle , true ) ;
72893: CALL_OW 45
72897: PPUSH
72898: LD_INT 1
72900: PPUSH
72901: CALL_OW 51
// end ;
72905: GO 72779
72907: POP
72908: POP
// end ;
72909: PPOPN 2
72911: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
72912: LD_EXP 99
72916: PUSH
72917: LD_EXP 145
72921: AND
72922: IFFALSE 73144
72924: GO 72926
72926: DISABLE
72927: LD_INT 0
72929: PPUSH
72930: PPUSH
72931: PPUSH
72932: PPUSH
72933: PPUSH
72934: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
72935: LD_ADDR_VAR 0 6
72939: PUSH
72940: LD_INT 22
72942: PUSH
72943: LD_OWVAR 2
72947: PUSH
72948: EMPTY
72949: LIST
72950: LIST
72951: PUSH
72952: LD_INT 21
72954: PUSH
72955: LD_INT 1
72957: PUSH
72958: EMPTY
72959: LIST
72960: LIST
72961: PUSH
72962: LD_INT 3
72964: PUSH
72965: LD_INT 23
72967: PUSH
72968: LD_INT 0
72970: PUSH
72971: EMPTY
72972: LIST
72973: LIST
72974: PUSH
72975: EMPTY
72976: LIST
72977: LIST
72978: PUSH
72979: EMPTY
72980: LIST
72981: LIST
72982: LIST
72983: PPUSH
72984: CALL_OW 69
72988: ST_TO_ADDR
// if not tmp then
72989: LD_VAR 0 6
72993: NOT
72994: IFFALSE 72998
// exit ;
72996: GO 73144
// s1 := rand ( 1 , 4 ) ;
72998: LD_ADDR_VAR 0 2
73002: PUSH
73003: LD_INT 1
73005: PPUSH
73006: LD_INT 4
73008: PPUSH
73009: CALL_OW 12
73013: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
73014: LD_ADDR_VAR 0 4
73018: PUSH
73019: LD_VAR 0 6
73023: PUSH
73024: LD_INT 1
73026: ARRAY
73027: PPUSH
73028: LD_VAR 0 2
73032: PPUSH
73033: CALL_OW 259
73037: ST_TO_ADDR
// if s1 = 1 then
73038: LD_VAR 0 2
73042: PUSH
73043: LD_INT 1
73045: EQUAL
73046: IFFALSE 73066
// s2 := rand ( 2 , 4 ) else
73048: LD_ADDR_VAR 0 3
73052: PUSH
73053: LD_INT 2
73055: PPUSH
73056: LD_INT 4
73058: PPUSH
73059: CALL_OW 12
73063: ST_TO_ADDR
73064: GO 73074
// s2 := 1 ;
73066: LD_ADDR_VAR 0 3
73070: PUSH
73071: LD_INT 1
73073: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
73074: LD_ADDR_VAR 0 5
73078: PUSH
73079: LD_VAR 0 6
73083: PUSH
73084: LD_INT 1
73086: ARRAY
73087: PPUSH
73088: LD_VAR 0 3
73092: PPUSH
73093: CALL_OW 259
73097: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
73098: LD_VAR 0 6
73102: PUSH
73103: LD_INT 1
73105: ARRAY
73106: PPUSH
73107: LD_VAR 0 2
73111: PPUSH
73112: LD_VAR 0 5
73116: PPUSH
73117: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
73121: LD_VAR 0 6
73125: PUSH
73126: LD_INT 1
73128: ARRAY
73129: PPUSH
73130: LD_VAR 0 3
73134: PPUSH
73135: LD_VAR 0 4
73139: PPUSH
73140: CALL_OW 237
// end ;
73144: PPOPN 6
73146: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
73147: LD_EXP 99
73151: PUSH
73152: LD_EXP 146
73156: AND
73157: IFFALSE 73236
73159: GO 73161
73161: DISABLE
73162: LD_INT 0
73164: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
73165: LD_ADDR_VAR 0 1
73169: PUSH
73170: LD_INT 22
73172: PUSH
73173: LD_OWVAR 2
73177: PUSH
73178: EMPTY
73179: LIST
73180: LIST
73181: PUSH
73182: LD_INT 30
73184: PUSH
73185: LD_INT 3
73187: PUSH
73188: EMPTY
73189: LIST
73190: LIST
73191: PUSH
73192: EMPTY
73193: LIST
73194: LIST
73195: PPUSH
73196: CALL_OW 69
73200: ST_TO_ADDR
// if not tmp then
73201: LD_VAR 0 1
73205: NOT
73206: IFFALSE 73210
// exit ;
73208: GO 73236
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
73210: LD_VAR 0 1
73214: PUSH
73215: LD_INT 1
73217: PPUSH
73218: LD_VAR 0 1
73222: PPUSH
73223: CALL_OW 12
73227: ARRAY
73228: PPUSH
73229: LD_INT 1
73231: PPUSH
73232: CALL_OW 234
// end ;
73236: PPOPN 1
73238: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
73239: LD_EXP 99
73243: PUSH
73244: LD_EXP 147
73248: AND
73249: IFFALSE 73361
73251: GO 73253
73253: DISABLE
73254: LD_INT 0
73256: PPUSH
73257: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
73258: LD_ADDR_VAR 0 2
73262: PUSH
73263: LD_INT 22
73265: PUSH
73266: LD_OWVAR 2
73270: PUSH
73271: EMPTY
73272: LIST
73273: LIST
73274: PUSH
73275: LD_INT 2
73277: PUSH
73278: LD_INT 30
73280: PUSH
73281: LD_INT 27
73283: PUSH
73284: EMPTY
73285: LIST
73286: LIST
73287: PUSH
73288: LD_INT 30
73290: PUSH
73291: LD_INT 26
73293: PUSH
73294: EMPTY
73295: LIST
73296: LIST
73297: PUSH
73298: LD_INT 30
73300: PUSH
73301: LD_INT 28
73303: PUSH
73304: EMPTY
73305: LIST
73306: LIST
73307: PUSH
73308: EMPTY
73309: LIST
73310: LIST
73311: LIST
73312: LIST
73313: PUSH
73314: EMPTY
73315: LIST
73316: LIST
73317: PPUSH
73318: CALL_OW 69
73322: ST_TO_ADDR
// if not tmp then
73323: LD_VAR 0 2
73327: NOT
73328: IFFALSE 73332
// exit ;
73330: GO 73361
// for i in tmp do
73332: LD_ADDR_VAR 0 1
73336: PUSH
73337: LD_VAR 0 2
73341: PUSH
73342: FOR_IN
73343: IFFALSE 73359
// SetLives ( i , 1 ) ;
73345: LD_VAR 0 1
73349: PPUSH
73350: LD_INT 1
73352: PPUSH
73353: CALL_OW 234
73357: GO 73342
73359: POP
73360: POP
// end ;
73361: PPOPN 2
73363: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
73364: LD_EXP 99
73368: PUSH
73369: LD_EXP 148
73373: AND
73374: IFFALSE 73661
73376: GO 73378
73378: DISABLE
73379: LD_INT 0
73381: PPUSH
73382: PPUSH
73383: PPUSH
// begin i := rand ( 1 , 7 ) ;
73384: LD_ADDR_VAR 0 1
73388: PUSH
73389: LD_INT 1
73391: PPUSH
73392: LD_INT 7
73394: PPUSH
73395: CALL_OW 12
73399: ST_TO_ADDR
// case i of 1 :
73400: LD_VAR 0 1
73404: PUSH
73405: LD_INT 1
73407: DOUBLE
73408: EQUAL
73409: IFTRUE 73413
73411: GO 73423
73413: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
73414: LD_STRING earthquake(getX(game), 0, 32)
73416: PPUSH
73417: CALL_OW 559
73421: GO 73661
73423: LD_INT 2
73425: DOUBLE
73426: EQUAL
73427: IFTRUE 73431
73429: GO 73445
73431: POP
// begin ToLua ( displayStucuk(); ) ;
73432: LD_STRING displayStucuk();
73434: PPUSH
73435: CALL_OW 559
// ResetFog ;
73439: CALL_OW 335
// end ; 3 :
73443: GO 73661
73445: LD_INT 3
73447: DOUBLE
73448: EQUAL
73449: IFTRUE 73453
73451: GO 73557
73453: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
73454: LD_ADDR_VAR 0 2
73458: PUSH
73459: LD_INT 22
73461: PUSH
73462: LD_OWVAR 2
73466: PUSH
73467: EMPTY
73468: LIST
73469: LIST
73470: PUSH
73471: LD_INT 25
73473: PUSH
73474: LD_INT 1
73476: PUSH
73477: EMPTY
73478: LIST
73479: LIST
73480: PUSH
73481: EMPTY
73482: LIST
73483: LIST
73484: PPUSH
73485: CALL_OW 69
73489: ST_TO_ADDR
// if not tmp then
73490: LD_VAR 0 2
73494: NOT
73495: IFFALSE 73499
// exit ;
73497: GO 73661
// un := tmp [ rand ( 1 , tmp ) ] ;
73499: LD_ADDR_VAR 0 3
73503: PUSH
73504: LD_VAR 0 2
73508: PUSH
73509: LD_INT 1
73511: PPUSH
73512: LD_VAR 0 2
73516: PPUSH
73517: CALL_OW 12
73521: ARRAY
73522: ST_TO_ADDR
// if Crawls ( un ) then
73523: LD_VAR 0 3
73527: PPUSH
73528: CALL_OW 318
73532: IFFALSE 73543
// ComWalk ( un ) ;
73534: LD_VAR 0 3
73538: PPUSH
73539: CALL_OW 138
// SetClass ( un , class_mortar ) ;
73543: LD_VAR 0 3
73547: PPUSH
73548: LD_INT 8
73550: PPUSH
73551: CALL_OW 336
// end ; 4 :
73555: GO 73661
73557: LD_INT 4
73559: DOUBLE
73560: EQUAL
73561: IFTRUE 73565
73563: GO 73639
73565: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
73566: LD_ADDR_VAR 0 2
73570: PUSH
73571: LD_INT 22
73573: PUSH
73574: LD_OWVAR 2
73578: PUSH
73579: EMPTY
73580: LIST
73581: LIST
73582: PUSH
73583: LD_INT 30
73585: PUSH
73586: LD_INT 29
73588: PUSH
73589: EMPTY
73590: LIST
73591: LIST
73592: PUSH
73593: EMPTY
73594: LIST
73595: LIST
73596: PPUSH
73597: CALL_OW 69
73601: ST_TO_ADDR
// if not tmp then
73602: LD_VAR 0 2
73606: NOT
73607: IFFALSE 73611
// exit ;
73609: GO 73661
// CenterNowOnUnits ( tmp [ 1 ] ) ;
73611: LD_VAR 0 2
73615: PUSH
73616: LD_INT 1
73618: ARRAY
73619: PPUSH
73620: CALL_OW 87
// DestroyUnit ( tmp [ 1 ] ) ;
73624: LD_VAR 0 2
73628: PUSH
73629: LD_INT 1
73631: ARRAY
73632: PPUSH
73633: CALL_OW 65
// end ; 5 .. 7 :
73637: GO 73661
73639: LD_INT 5
73641: DOUBLE
73642: GREATEREQUAL
73643: IFFALSE 73651
73645: LD_INT 7
73647: DOUBLE
73648: LESSEQUAL
73649: IFTRUE 73653
73651: GO 73660
73653: POP
// StreamSibBomb ; end ;
73654: CALL 69898 0 0
73658: GO 73661
73660: POP
// end ;
73661: PPOPN 3
73663: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
73664: LD_EXP 99
73668: PUSH
73669: LD_EXP 149
73673: AND
73674: IFFALSE 73830
73676: GO 73678
73678: DISABLE
73679: LD_INT 0
73681: PPUSH
73682: PPUSH
73683: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
73684: LD_ADDR_VAR 0 2
73688: PUSH
73689: LD_INT 81
73691: PUSH
73692: LD_OWVAR 2
73696: PUSH
73697: EMPTY
73698: LIST
73699: LIST
73700: PUSH
73701: LD_INT 2
73703: PUSH
73704: LD_INT 21
73706: PUSH
73707: LD_INT 1
73709: PUSH
73710: EMPTY
73711: LIST
73712: LIST
73713: PUSH
73714: LD_INT 21
73716: PUSH
73717: LD_INT 2
73719: PUSH
73720: EMPTY
73721: LIST
73722: LIST
73723: PUSH
73724: EMPTY
73725: LIST
73726: LIST
73727: LIST
73728: PUSH
73729: EMPTY
73730: LIST
73731: LIST
73732: PPUSH
73733: CALL_OW 69
73737: ST_TO_ADDR
// if not tmp then
73738: LD_VAR 0 2
73742: NOT
73743: IFFALSE 73747
// exit ;
73745: GO 73830
// p := 0 ;
73747: LD_ADDR_VAR 0 3
73751: PUSH
73752: LD_INT 0
73754: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
73755: LD_INT 35
73757: PPUSH
73758: CALL_OW 67
// p := p + 1 ;
73762: LD_ADDR_VAR 0 3
73766: PUSH
73767: LD_VAR 0 3
73771: PUSH
73772: LD_INT 1
73774: PLUS
73775: ST_TO_ADDR
// for i in tmp do
73776: LD_ADDR_VAR 0 1
73780: PUSH
73781: LD_VAR 0 2
73785: PUSH
73786: FOR_IN
73787: IFFALSE 73818
// if GetLives ( i ) < 1000 then
73789: LD_VAR 0 1
73793: PPUSH
73794: CALL_OW 256
73798: PUSH
73799: LD_INT 1000
73801: LESS
73802: IFFALSE 73816
// SetLives ( i , 1000 ) ;
73804: LD_VAR 0 1
73808: PPUSH
73809: LD_INT 1000
73811: PPUSH
73812: CALL_OW 234
73816: GO 73786
73818: POP
73819: POP
// until p > 20 ;
73820: LD_VAR 0 3
73824: PUSH
73825: LD_INT 20
73827: GREATER
73828: IFFALSE 73755
// end ;
73830: PPOPN 3
73832: END
// every 0 0$1 trigger StreamModeActive and sTime do
73833: LD_EXP 99
73837: PUSH
73838: LD_EXP 150
73842: AND
73843: IFFALSE 73878
73845: GO 73847
73847: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
73848: LD_INT 28
73850: PPUSH
73851: LD_OWVAR 2
73855: PPUSH
73856: LD_INT 2
73858: PPUSH
73859: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
73863: LD_INT 30
73865: PPUSH
73866: LD_OWVAR 2
73870: PPUSH
73871: LD_INT 2
73873: PPUSH
73874: CALL_OW 322
// end ;
73878: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
73879: LD_EXP 99
73883: PUSH
73884: LD_EXP 151
73888: AND
73889: IFFALSE 74010
73891: GO 73893
73893: DISABLE
73894: LD_INT 0
73896: PPUSH
73897: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
73898: LD_ADDR_VAR 0 2
73902: PUSH
73903: LD_INT 22
73905: PUSH
73906: LD_OWVAR 2
73910: PUSH
73911: EMPTY
73912: LIST
73913: LIST
73914: PUSH
73915: LD_INT 21
73917: PUSH
73918: LD_INT 1
73920: PUSH
73921: EMPTY
73922: LIST
73923: LIST
73924: PUSH
73925: LD_INT 3
73927: PUSH
73928: LD_INT 23
73930: PUSH
73931: LD_INT 0
73933: PUSH
73934: EMPTY
73935: LIST
73936: LIST
73937: PUSH
73938: EMPTY
73939: LIST
73940: LIST
73941: PUSH
73942: EMPTY
73943: LIST
73944: LIST
73945: LIST
73946: PPUSH
73947: CALL_OW 69
73951: ST_TO_ADDR
// if not tmp then
73952: LD_VAR 0 2
73956: NOT
73957: IFFALSE 73961
// exit ;
73959: GO 74010
// for i in tmp do
73961: LD_ADDR_VAR 0 1
73965: PUSH
73966: LD_VAR 0 2
73970: PUSH
73971: FOR_IN
73972: IFFALSE 74008
// begin if Crawls ( i ) then
73974: LD_VAR 0 1
73978: PPUSH
73979: CALL_OW 318
73983: IFFALSE 73994
// ComWalk ( i ) ;
73985: LD_VAR 0 1
73989: PPUSH
73990: CALL_OW 138
// SetClass ( i , 2 ) ;
73994: LD_VAR 0 1
73998: PPUSH
73999: LD_INT 2
74001: PPUSH
74002: CALL_OW 336
// end ;
74006: GO 73971
74008: POP
74009: POP
// end ;
74010: PPOPN 2
74012: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
74013: LD_EXP 99
74017: PUSH
74018: LD_EXP 152
74022: AND
74023: IFFALSE 74311
74025: GO 74027
74027: DISABLE
74028: LD_INT 0
74030: PPUSH
74031: PPUSH
74032: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
74033: LD_OWVAR 2
74037: PPUSH
74038: LD_INT 9
74040: PPUSH
74041: LD_INT 1
74043: PPUSH
74044: LD_INT 1
74046: PPUSH
74047: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
74051: LD_INT 9
74053: PPUSH
74054: LD_OWVAR 2
74058: PPUSH
74059: CALL_OW 343
// uc_side := 9 ;
74063: LD_ADDR_OWVAR 20
74067: PUSH
74068: LD_INT 9
74070: ST_TO_ADDR
// uc_nation := 2 ;
74071: LD_ADDR_OWVAR 21
74075: PUSH
74076: LD_INT 2
74078: ST_TO_ADDR
// hc_name := Dark Warrior ;
74079: LD_ADDR_OWVAR 26
74083: PUSH
74084: LD_STRING Dark Warrior
74086: ST_TO_ADDR
// hc_gallery :=  ;
74087: LD_ADDR_OWVAR 33
74091: PUSH
74092: LD_STRING 
74094: ST_TO_ADDR
// hc_noskilllimit := true ;
74095: LD_ADDR_OWVAR 76
74099: PUSH
74100: LD_INT 1
74102: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
74103: LD_ADDR_OWVAR 31
74107: PUSH
74108: LD_INT 30
74110: PUSH
74111: LD_INT 30
74113: PUSH
74114: LD_INT 30
74116: PUSH
74117: LD_INT 30
74119: PUSH
74120: EMPTY
74121: LIST
74122: LIST
74123: LIST
74124: LIST
74125: ST_TO_ADDR
// un := CreateHuman ;
74126: LD_ADDR_VAR 0 3
74130: PUSH
74131: CALL_OW 44
74135: ST_TO_ADDR
// hc_noskilllimit := false ;
74136: LD_ADDR_OWVAR 76
74140: PUSH
74141: LD_INT 0
74143: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
74144: LD_VAR 0 3
74148: PPUSH
74149: LD_INT 1
74151: PPUSH
74152: CALL_OW 51
// ToLua ( playRanger() ) ;
74156: LD_STRING playRanger()
74158: PPUSH
74159: CALL_OW 559
// p := 0 ;
74163: LD_ADDR_VAR 0 2
74167: PUSH
74168: LD_INT 0
74170: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
74171: LD_INT 35
74173: PPUSH
74174: CALL_OW 67
// p := p + 1 ;
74178: LD_ADDR_VAR 0 2
74182: PUSH
74183: LD_VAR 0 2
74187: PUSH
74188: LD_INT 1
74190: PLUS
74191: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
74192: LD_VAR 0 3
74196: PPUSH
74197: CALL_OW 256
74201: PUSH
74202: LD_INT 1000
74204: LESS
74205: IFFALSE 74219
// SetLives ( un , 1000 ) ;
74207: LD_VAR 0 3
74211: PPUSH
74212: LD_INT 1000
74214: PPUSH
74215: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
74219: LD_VAR 0 3
74223: PPUSH
74224: LD_INT 81
74226: PUSH
74227: LD_OWVAR 2
74231: PUSH
74232: EMPTY
74233: LIST
74234: LIST
74235: PUSH
74236: LD_INT 91
74238: PUSH
74239: LD_VAR 0 3
74243: PUSH
74244: LD_INT 30
74246: PUSH
74247: EMPTY
74248: LIST
74249: LIST
74250: LIST
74251: PUSH
74252: EMPTY
74253: LIST
74254: LIST
74255: PPUSH
74256: CALL_OW 69
74260: PPUSH
74261: LD_VAR 0 3
74265: PPUSH
74266: CALL_OW 74
74270: PPUSH
74271: CALL_OW 115
// until p > 80 or IsDead ( un ) ;
74275: LD_VAR 0 2
74279: PUSH
74280: LD_INT 80
74282: GREATER
74283: PUSH
74284: LD_VAR 0 3
74288: PPUSH
74289: CALL_OW 301
74293: OR
74294: IFFALSE 74171
// if un then
74296: LD_VAR 0 3
74300: IFFALSE 74311
// RemoveUnit ( un ) ;
74302: LD_VAR 0 3
74306: PPUSH
74307: CALL_OW 64
// end ;
74311: PPOPN 3
74313: END
// every 0 0$1 trigger sComputer do var i , tmp , j ;
74314: LD_EXP 153
74318: IFFALSE 74434
74320: GO 74322
74322: DISABLE
74323: LD_INT 0
74325: PPUSH
74326: PPUSH
74327: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
74328: LD_ADDR_VAR 0 2
74332: PUSH
74333: LD_INT 81
74335: PUSH
74336: LD_OWVAR 2
74340: PUSH
74341: EMPTY
74342: LIST
74343: LIST
74344: PUSH
74345: LD_INT 21
74347: PUSH
74348: LD_INT 1
74350: PUSH
74351: EMPTY
74352: LIST
74353: LIST
74354: PUSH
74355: EMPTY
74356: LIST
74357: LIST
74358: PPUSH
74359: CALL_OW 69
74363: ST_TO_ADDR
// ToLua ( playComputer() ) ;
74364: LD_STRING playComputer()
74366: PPUSH
74367: CALL_OW 559
// if not tmp then
74371: LD_VAR 0 2
74375: NOT
74376: IFFALSE 74380
// exit ;
74378: GO 74434
// for i in tmp do
74380: LD_ADDR_VAR 0 1
74384: PUSH
74385: LD_VAR 0 2
74389: PUSH
74390: FOR_IN
74391: IFFALSE 74432
// for j := 1 to 4 do
74393: LD_ADDR_VAR 0 3
74397: PUSH
74398: DOUBLE
74399: LD_INT 1
74401: DEC
74402: ST_TO_ADDR
74403: LD_INT 4
74405: PUSH
74406: FOR_TO
74407: IFFALSE 74428
// SetSkill ( i , j , 10 ) ;
74409: LD_VAR 0 1
74413: PPUSH
74414: LD_VAR 0 3
74418: PPUSH
74419: LD_INT 10
74421: PPUSH
74422: CALL_OW 237
74426: GO 74406
74428: POP
74429: POP
74430: GO 74390
74432: POP
74433: POP
// end ;
74434: PPOPN 3
74436: END
// every 0 0$1 trigger s30 do var i , tmp ;
74437: LD_EXP 154
74441: IFFALSE 74510
74443: GO 74445
74445: DISABLE
74446: LD_INT 0
74448: PPUSH
74449: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
74450: LD_ADDR_VAR 0 2
74454: PUSH
74455: LD_INT 22
74457: PUSH
74458: LD_OWVAR 2
74462: PUSH
74463: EMPTY
74464: LIST
74465: LIST
74466: PPUSH
74467: CALL_OW 69
74471: ST_TO_ADDR
// if not tmp then
74472: LD_VAR 0 2
74476: NOT
74477: IFFALSE 74481
// exit ;
74479: GO 74510
// for i in tmp do
74481: LD_ADDR_VAR 0 1
74485: PUSH
74486: LD_VAR 0 2
74490: PUSH
74491: FOR_IN
74492: IFFALSE 74508
// SetLives ( i , 300 ) ;
74494: LD_VAR 0 1
74498: PPUSH
74499: LD_INT 300
74501: PPUSH
74502: CALL_OW 234
74506: GO 74491
74508: POP
74509: POP
// end ;
74510: PPOPN 2
74512: END
// every 0 0$1 trigger s60 do var i , tmp ;
74513: LD_EXP 155
74517: IFFALSE 74586
74519: GO 74521
74521: DISABLE
74522: LD_INT 0
74524: PPUSH
74525: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
74526: LD_ADDR_VAR 0 2
74530: PUSH
74531: LD_INT 22
74533: PUSH
74534: LD_OWVAR 2
74538: PUSH
74539: EMPTY
74540: LIST
74541: LIST
74542: PPUSH
74543: CALL_OW 69
74547: ST_TO_ADDR
// if not tmp then
74548: LD_VAR 0 2
74552: NOT
74553: IFFALSE 74557
// exit ;
74555: GO 74586
// for i in tmp do
74557: LD_ADDR_VAR 0 1
74561: PUSH
74562: LD_VAR 0 2
74566: PUSH
74567: FOR_IN
74568: IFFALSE 74584
// SetLives ( i , 600 ) ;
74570: LD_VAR 0 1
74574: PPUSH
74575: LD_INT 600
74577: PPUSH
74578: CALL_OW 234
74582: GO 74567
74584: POP
74585: POP
// end ;
74586: PPOPN 2
74588: END
// export function SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
74589: LD_INT 0
74591: PPUSH
// case cmd of 301 :
74592: LD_VAR 0 1
74596: PUSH
74597: LD_INT 301
74599: DOUBLE
74600: EQUAL
74601: IFTRUE 74605
74603: GO 74637
74605: POP
// hHackSpawnHuman ( p1 , p2 , p3 , x , y ) ; 302 :
74606: LD_VAR 0 6
74610: PPUSH
74611: LD_VAR 0 7
74615: PPUSH
74616: LD_VAR 0 8
74620: PPUSH
74621: LD_VAR 0 4
74625: PPUSH
74626: LD_VAR 0 5
74630: PPUSH
74631: CALL 75838 0 5
74635: GO 74758
74637: LD_INT 302
74639: DOUBLE
74640: EQUAL
74641: IFTRUE 74645
74643: GO 74682
74645: POP
// hHackSpawnVehicle ( p1 , p2 , p3 , p4 , x , y ) ; 303 :
74646: LD_VAR 0 6
74650: PPUSH
74651: LD_VAR 0 7
74655: PPUSH
74656: LD_VAR 0 8
74660: PPUSH
74661: LD_VAR 0 9
74665: PPUSH
74666: LD_VAR 0 4
74670: PPUSH
74671: LD_VAR 0 5
74675: PPUSH
74676: CALL 75929 0 6
74680: GO 74758
74682: LD_INT 303
74684: DOUBLE
74685: EQUAL
74686: IFTRUE 74690
74688: GO 74727
74690: POP
// hHackSpawnBuilding ( p1 , p2 , p3 , p4 , x , y ) ; 304 :
74691: LD_VAR 0 6
74695: PPUSH
74696: LD_VAR 0 7
74700: PPUSH
74701: LD_VAR 0 8
74705: PPUSH
74706: LD_VAR 0 9
74710: PPUSH
74711: LD_VAR 0 4
74715: PPUSH
74716: LD_VAR 0 5
74720: PPUSH
74721: CALL 74763 0 6
74725: GO 74758
74727: LD_INT 304
74729: DOUBLE
74730: EQUAL
74731: IFTRUE 74735
74733: GO 74757
74735: POP
// hHackTeleport ( unit , x , y ) ; end ;
74736: LD_VAR 0 2
74740: PPUSH
74741: LD_VAR 0 4
74745: PPUSH
74746: LD_VAR 0 5
74750: PPUSH
74751: CALL 76522 0 3
74755: GO 74758
74757: POP
// end ;
74758: LD_VAR 0 12
74762: RET
// export function hHackSpawnBuilding ( nation , btype , dir , weapon , x , y ) ; var b ; begin
74763: LD_INT 0
74765: PPUSH
74766: PPUSH
// if nation < 1 or nation > 3 or HexInfo ( x , y ) then
74767: LD_VAR 0 1
74771: PUSH
74772: LD_INT 1
74774: LESS
74775: PUSH
74776: LD_VAR 0 1
74780: PUSH
74781: LD_INT 3
74783: GREATER
74784: OR
74785: PUSH
74786: LD_VAR 0 5
74790: PPUSH
74791: LD_VAR 0 6
74795: PPUSH
74796: CALL_OW 428
74800: OR
74801: IFFALSE 74805
// exit ;
74803: GO 75525
// uc_side := your_side ;
74805: LD_ADDR_OWVAR 20
74809: PUSH
74810: LD_OWVAR 2
74814: ST_TO_ADDR
// uc_nation := nation ;
74815: LD_ADDR_OWVAR 21
74819: PUSH
74820: LD_VAR 0 1
74824: ST_TO_ADDR
// bc_level = 1 ;
74825: LD_ADDR_OWVAR 43
74829: PUSH
74830: LD_INT 1
74832: ST_TO_ADDR
// case btype of 1 :
74833: LD_VAR 0 2
74837: PUSH
74838: LD_INT 1
74840: DOUBLE
74841: EQUAL
74842: IFTRUE 74846
74844: GO 74857
74846: POP
// bc_type := b_depot ; 2 :
74847: LD_ADDR_OWVAR 42
74851: PUSH
74852: LD_INT 0
74854: ST_TO_ADDR
74855: GO 75469
74857: LD_INT 2
74859: DOUBLE
74860: EQUAL
74861: IFTRUE 74865
74863: GO 74876
74865: POP
// bc_type := b_warehouse ; 3 :
74866: LD_ADDR_OWVAR 42
74870: PUSH
74871: LD_INT 1
74873: ST_TO_ADDR
74874: GO 75469
74876: LD_INT 3
74878: DOUBLE
74879: EQUAL
74880: IFTRUE 74884
74882: GO 74895
74884: POP
// bc_type := b_lab ; 4 .. 9 :
74885: LD_ADDR_OWVAR 42
74889: PUSH
74890: LD_INT 6
74892: ST_TO_ADDR
74893: GO 75469
74895: LD_INT 4
74897: DOUBLE
74898: GREATEREQUAL
74899: IFFALSE 74907
74901: LD_INT 9
74903: DOUBLE
74904: LESSEQUAL
74905: IFTRUE 74909
74907: GO 74961
74909: POP
// begin bc_type := b_lab_half ;
74910: LD_ADDR_OWVAR 42
74914: PUSH
74915: LD_INT 7
74917: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_opto , b_lab_spacetime , b_lab_biological ] [ btype - 3 ] ;
74918: LD_ADDR_OWVAR 44
74922: PUSH
74923: LD_INT 10
74925: PUSH
74926: LD_INT 11
74928: PUSH
74929: LD_INT 12
74931: PUSH
74932: LD_INT 15
74934: PUSH
74935: LD_INT 14
74937: PUSH
74938: LD_INT 13
74940: PUSH
74941: EMPTY
74942: LIST
74943: LIST
74944: LIST
74945: LIST
74946: LIST
74947: LIST
74948: PUSH
74949: LD_VAR 0 2
74953: PUSH
74954: LD_INT 3
74956: MINUS
74957: ARRAY
74958: ST_TO_ADDR
// end ; 10 .. 13 :
74959: GO 75469
74961: LD_INT 10
74963: DOUBLE
74964: GREATEREQUAL
74965: IFFALSE 74973
74967: LD_INT 13
74969: DOUBLE
74970: LESSEQUAL
74971: IFTRUE 74975
74973: GO 75052
74975: POP
// begin bc_type := b_lab_full ;
74976: LD_ADDR_OWVAR 42
74980: PUSH
74981: LD_INT 8
74983: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_computer , b_lab_spacetime , b_lab_biological ] [ btype - 9 ] ;
74984: LD_ADDR_OWVAR 44
74988: PUSH
74989: LD_INT 10
74991: PUSH
74992: LD_INT 12
74994: PUSH
74995: LD_INT 14
74997: PUSH
74998: LD_INT 13
75000: PUSH
75001: EMPTY
75002: LIST
75003: LIST
75004: LIST
75005: LIST
75006: PUSH
75007: LD_VAR 0 2
75011: PUSH
75012: LD_INT 9
75014: MINUS
75015: ARRAY
75016: ST_TO_ADDR
// bc_kind2 := [ b_lab_siberium , b_lab_opto , b_lab_computer , b_lab_opto ] [ btype - 9 ] ;
75017: LD_ADDR_OWVAR 45
75021: PUSH
75022: LD_INT 11
75024: PUSH
75025: LD_INT 15
75027: PUSH
75028: LD_INT 12
75030: PUSH
75031: LD_INT 15
75033: PUSH
75034: EMPTY
75035: LIST
75036: LIST
75037: LIST
75038: LIST
75039: PUSH
75040: LD_VAR 0 2
75044: PUSH
75045: LD_INT 9
75047: MINUS
75048: ARRAY
75049: ST_TO_ADDR
// end ; 14 :
75050: GO 75469
75052: LD_INT 14
75054: DOUBLE
75055: EQUAL
75056: IFTRUE 75060
75058: GO 75071
75060: POP
// bc_type := b_workshop ; 15 :
75061: LD_ADDR_OWVAR 42
75065: PUSH
75066: LD_INT 2
75068: ST_TO_ADDR
75069: GO 75469
75071: LD_INT 15
75073: DOUBLE
75074: EQUAL
75075: IFTRUE 75079
75077: GO 75090
75079: POP
// bc_type := b_factory ; 16 :
75080: LD_ADDR_OWVAR 42
75084: PUSH
75085: LD_INT 3
75087: ST_TO_ADDR
75088: GO 75469
75090: LD_INT 16
75092: DOUBLE
75093: EQUAL
75094: IFTRUE 75098
75096: GO 75109
75098: POP
// bc_type := b_ext_gun ; 17 :
75099: LD_ADDR_OWVAR 42
75103: PUSH
75104: LD_INT 17
75106: ST_TO_ADDR
75107: GO 75469
75109: LD_INT 17
75111: DOUBLE
75112: EQUAL
75113: IFTRUE 75117
75115: GO 75145
75117: POP
// bc_type := [ b_ext_noncombat , b_ext_stitch , b_ext_noncombat ] [ nation ] ; 18 :
75118: LD_ADDR_OWVAR 42
75122: PUSH
75123: LD_INT 19
75125: PUSH
75126: LD_INT 23
75128: PUSH
75129: LD_INT 19
75131: PUSH
75132: EMPTY
75133: LIST
75134: LIST
75135: LIST
75136: PUSH
75137: LD_VAR 0 1
75141: ARRAY
75142: ST_TO_ADDR
75143: GO 75469
75145: LD_INT 18
75147: DOUBLE
75148: EQUAL
75149: IFTRUE 75153
75151: GO 75164
75153: POP
// bc_type := b_ext_radar ; 19 :
75154: LD_ADDR_OWVAR 42
75158: PUSH
75159: LD_INT 20
75161: ST_TO_ADDR
75162: GO 75469
75164: LD_INT 19
75166: DOUBLE
75167: EQUAL
75168: IFTRUE 75172
75170: GO 75183
75172: POP
// bc_type := b_ext_radio ; 20 :
75173: LD_ADDR_OWVAR 42
75177: PUSH
75178: LD_INT 22
75180: ST_TO_ADDR
75181: GO 75469
75183: LD_INT 20
75185: DOUBLE
75186: EQUAL
75187: IFTRUE 75191
75189: GO 75202
75191: POP
// bc_type := b_ext_siberium ; 21 :
75192: LD_ADDR_OWVAR 42
75196: PUSH
75197: LD_INT 21
75199: ST_TO_ADDR
75200: GO 75469
75202: LD_INT 21
75204: DOUBLE
75205: EQUAL
75206: IFTRUE 75210
75208: GO 75221
75210: POP
// bc_type := b_ext_computer ; 22 :
75211: LD_ADDR_OWVAR 42
75215: PUSH
75216: LD_INT 24
75218: ST_TO_ADDR
75219: GO 75469
75221: LD_INT 22
75223: DOUBLE
75224: EQUAL
75225: IFTRUE 75229
75227: GO 75240
75229: POP
// bc_type := b_ext_track ; 23 :
75230: LD_ADDR_OWVAR 42
75234: PUSH
75235: LD_INT 16
75237: ST_TO_ADDR
75238: GO 75469
75240: LD_INT 23
75242: DOUBLE
75243: EQUAL
75244: IFTRUE 75248
75246: GO 75259
75248: POP
// bc_type := b_ext_laser ; 24 :
75249: LD_ADDR_OWVAR 42
75253: PUSH
75254: LD_INT 25
75256: ST_TO_ADDR
75257: GO 75469
75259: LD_INT 24
75261: DOUBLE
75262: EQUAL
75263: IFTRUE 75267
75265: GO 75278
75267: POP
// bc_type := b_control_tower ; 25 :
75268: LD_ADDR_OWVAR 42
75272: PUSH
75273: LD_INT 36
75275: ST_TO_ADDR
75276: GO 75469
75278: LD_INT 25
75280: DOUBLE
75281: EQUAL
75282: IFTRUE 75286
75284: GO 75297
75286: POP
// bc_type := b_breastwork ; 26 :
75287: LD_ADDR_OWVAR 42
75291: PUSH
75292: LD_INT 31
75294: ST_TO_ADDR
75295: GO 75469
75297: LD_INT 26
75299: DOUBLE
75300: EQUAL
75301: IFTRUE 75305
75303: GO 75316
75305: POP
// bc_type := b_bunker ; 27 :
75306: LD_ADDR_OWVAR 42
75310: PUSH
75311: LD_INT 32
75313: ST_TO_ADDR
75314: GO 75469
75316: LD_INT 27
75318: DOUBLE
75319: EQUAL
75320: IFTRUE 75324
75322: GO 75335
75324: POP
// bc_type := b_turret ; 28 :
75325: LD_ADDR_OWVAR 42
75329: PUSH
75330: LD_INT 33
75332: ST_TO_ADDR
75333: GO 75469
75335: LD_INT 28
75337: DOUBLE
75338: EQUAL
75339: IFTRUE 75343
75341: GO 75354
75343: POP
// bc_type := b_armoury ; 29 :
75344: LD_ADDR_OWVAR 42
75348: PUSH
75349: LD_INT 4
75351: ST_TO_ADDR
75352: GO 75469
75354: LD_INT 29
75356: DOUBLE
75357: EQUAL
75358: IFTRUE 75362
75360: GO 75373
75362: POP
// bc_type := b_barracks ; 30 :
75363: LD_ADDR_OWVAR 42
75367: PUSH
75368: LD_INT 5
75370: ST_TO_ADDR
75371: GO 75469
75373: LD_INT 30
75375: DOUBLE
75376: EQUAL
75377: IFTRUE 75381
75379: GO 75392
75381: POP
// bc_type := b_solar_power ; 31 :
75382: LD_ADDR_OWVAR 42
75386: PUSH
75387: LD_INT 27
75389: ST_TO_ADDR
75390: GO 75469
75392: LD_INT 31
75394: DOUBLE
75395: EQUAL
75396: IFTRUE 75400
75398: GO 75411
75400: POP
// bc_type := b_oil_power ; 32 :
75401: LD_ADDR_OWVAR 42
75405: PUSH
75406: LD_INT 26
75408: ST_TO_ADDR
75409: GO 75469
75411: LD_INT 32
75413: DOUBLE
75414: EQUAL
75415: IFTRUE 75419
75417: GO 75430
75419: POP
// bc_type := b_siberite_power ; 33 :
75420: LD_ADDR_OWVAR 42
75424: PUSH
75425: LD_INT 28
75427: ST_TO_ADDR
75428: GO 75469
75430: LD_INT 33
75432: DOUBLE
75433: EQUAL
75434: IFTRUE 75438
75436: GO 75449
75438: POP
// bc_type := b_oil_mine ; 34 :
75439: LD_ADDR_OWVAR 42
75443: PUSH
75444: LD_INT 29
75446: ST_TO_ADDR
75447: GO 75469
75449: LD_INT 34
75451: DOUBLE
75452: EQUAL
75453: IFTRUE 75457
75455: GO 75468
75457: POP
// bc_type := b_siberite_mine ; end ;
75458: LD_ADDR_OWVAR 42
75462: PUSH
75463: LD_INT 30
75465: ST_TO_ADDR
75466: GO 75469
75468: POP
// b := CreateAndPlaceBuildingXYD ( x , y , dir ) ;
75469: LD_ADDR_VAR 0 8
75473: PUSH
75474: LD_VAR 0 5
75478: PPUSH
75479: LD_VAR 0 6
75483: PPUSH
75484: LD_VAR 0 3
75488: PPUSH
75489: CALL_OW 47
75493: ST_TO_ADDR
// if bc_type in [ b_bunker , b_turret ] then
75494: LD_OWVAR 42
75498: PUSH
75499: LD_INT 32
75501: PUSH
75502: LD_INT 33
75504: PUSH
75505: EMPTY
75506: LIST
75507: LIST
75508: IN
75509: IFFALSE 75525
// PlaceWeaponTurret ( b , weapon ) ;
75511: LD_VAR 0 8
75515: PPUSH
75516: LD_VAR 0 4
75520: PPUSH
75521: CALL_OW 431
// end ;
75525: LD_VAR 0 7
75529: RET
// export function hHackUnlimitedResources ; var i , j , tmp ; begin
75530: LD_INT 0
75532: PPUSH
75533: PPUSH
75534: PPUSH
75535: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
75536: LD_ADDR_VAR 0 4
75540: PUSH
75541: LD_INT 22
75543: PUSH
75544: LD_OWVAR 2
75548: PUSH
75549: EMPTY
75550: LIST
75551: LIST
75552: PUSH
75553: LD_INT 2
75555: PUSH
75556: LD_INT 30
75558: PUSH
75559: LD_INT 0
75561: PUSH
75562: EMPTY
75563: LIST
75564: LIST
75565: PUSH
75566: LD_INT 30
75568: PUSH
75569: LD_INT 1
75571: PUSH
75572: EMPTY
75573: LIST
75574: LIST
75575: PUSH
75576: EMPTY
75577: LIST
75578: LIST
75579: LIST
75580: PUSH
75581: EMPTY
75582: LIST
75583: LIST
75584: PPUSH
75585: CALL_OW 69
75589: ST_TO_ADDR
// if not tmp then
75590: LD_VAR 0 4
75594: NOT
75595: IFFALSE 75599
// exit ;
75597: GO 75658
// for i in tmp do
75599: LD_ADDR_VAR 0 2
75603: PUSH
75604: LD_VAR 0 4
75608: PUSH
75609: FOR_IN
75610: IFFALSE 75656
// for j = 1 to 3 do
75612: LD_ADDR_VAR 0 3
75616: PUSH
75617: DOUBLE
75618: LD_INT 1
75620: DEC
75621: ST_TO_ADDR
75622: LD_INT 3
75624: PUSH
75625: FOR_TO
75626: IFFALSE 75652
// SetResourceType ( GetBase ( i ) , j , 99999 ) ;
75628: LD_VAR 0 2
75632: PPUSH
75633: CALL_OW 274
75637: PPUSH
75638: LD_VAR 0 3
75642: PPUSH
75643: LD_INT 99999
75645: PPUSH
75646: CALL_OW 277
75650: GO 75625
75652: POP
75653: POP
75654: GO 75609
75656: POP
75657: POP
// end ;
75658: LD_VAR 0 1
75662: RET
// export function hHackSetLevel10 ; var i , j ; begin
75663: LD_INT 0
75665: PPUSH
75666: PPUSH
75667: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
75668: LD_ADDR_VAR 0 2
75672: PUSH
75673: LD_INT 21
75675: PUSH
75676: LD_INT 1
75678: PUSH
75679: EMPTY
75680: LIST
75681: LIST
75682: PPUSH
75683: CALL_OW 69
75687: PUSH
75688: FOR_IN
75689: IFFALSE 75741
// if IsSelected ( i ) then
75691: LD_VAR 0 2
75695: PPUSH
75696: CALL_OW 306
75700: IFFALSE 75739
// begin for j := 1 to 4 do
75702: LD_ADDR_VAR 0 3
75706: PUSH
75707: DOUBLE
75708: LD_INT 1
75710: DEC
75711: ST_TO_ADDR
75712: LD_INT 4
75714: PUSH
75715: FOR_TO
75716: IFFALSE 75737
// SetSkill ( i , j , 10 ) ;
75718: LD_VAR 0 2
75722: PPUSH
75723: LD_VAR 0 3
75727: PPUSH
75728: LD_INT 10
75730: PPUSH
75731: CALL_OW 237
75735: GO 75715
75737: POP
75738: POP
// end ;
75739: GO 75688
75741: POP
75742: POP
// end ;
75743: LD_VAR 0 1
75747: RET
// export function hHackSetLevel10YourUnits ; var i , j ; begin
75748: LD_INT 0
75750: PPUSH
75751: PPUSH
75752: PPUSH
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) do
75753: LD_ADDR_VAR 0 2
75757: PUSH
75758: LD_INT 22
75760: PUSH
75761: LD_OWVAR 2
75765: PUSH
75766: EMPTY
75767: LIST
75768: LIST
75769: PUSH
75770: LD_INT 21
75772: PUSH
75773: LD_INT 1
75775: PUSH
75776: EMPTY
75777: LIST
75778: LIST
75779: PUSH
75780: EMPTY
75781: LIST
75782: LIST
75783: PPUSH
75784: CALL_OW 69
75788: PUSH
75789: FOR_IN
75790: IFFALSE 75831
// begin for j := 1 to 4 do
75792: LD_ADDR_VAR 0 3
75796: PUSH
75797: DOUBLE
75798: LD_INT 1
75800: DEC
75801: ST_TO_ADDR
75802: LD_INT 4
75804: PUSH
75805: FOR_TO
75806: IFFALSE 75827
// SetSkill ( i , j , 10 ) ;
75808: LD_VAR 0 2
75812: PPUSH
75813: LD_VAR 0 3
75817: PPUSH
75818: LD_INT 10
75820: PPUSH
75821: CALL_OW 237
75825: GO 75805
75827: POP
75828: POP
// end ;
75829: GO 75789
75831: POP
75832: POP
// end ;
75833: LD_VAR 0 1
75837: RET
// export function hHackSpawnHuman ( nation , class , skill , x , y ) ; begin
75838: LD_INT 0
75840: PPUSH
// uc_side := your_side ;
75841: LD_ADDR_OWVAR 20
75845: PUSH
75846: LD_OWVAR 2
75850: ST_TO_ADDR
// uc_nation := nation ;
75851: LD_ADDR_OWVAR 21
75855: PUSH
75856: LD_VAR 0 1
75860: ST_TO_ADDR
// InitHc ;
75861: CALL_OW 19
// PrepareHuman ( false , class , skill ) ;
75865: LD_INT 0
75867: PPUSH
75868: LD_VAR 0 2
75872: PPUSH
75873: LD_VAR 0 3
75877: PPUSH
75878: CALL_OW 380
// if HexInfo ( x , y ) = 0 then
75882: LD_VAR 0 4
75886: PPUSH
75887: LD_VAR 0 5
75891: PPUSH
75892: CALL_OW 428
75896: PUSH
75897: LD_INT 0
75899: EQUAL
75900: IFFALSE 75924
// PlaceUnitXY ( CreateHuman , x , y , true ) ;
75902: CALL_OW 44
75906: PPUSH
75907: LD_VAR 0 4
75911: PPUSH
75912: LD_VAR 0 5
75916: PPUSH
75917: LD_INT 1
75919: PPUSH
75920: CALL_OW 48
// end ;
75924: LD_VAR 0 6
75928: RET
// export function hHackSpawnVehicle ( chassis , engine , control , weapon , x , y ) ; var un ; begin
75929: LD_INT 0
75931: PPUSH
75932: PPUSH
// uc_side := your_side ;
75933: LD_ADDR_OWVAR 20
75937: PUSH
75938: LD_OWVAR 2
75942: ST_TO_ADDR
// if chassis in [ 1 , 2 , 3 , 4 , 5 ] then
75943: LD_VAR 0 1
75947: PUSH
75948: LD_INT 1
75950: PUSH
75951: LD_INT 2
75953: PUSH
75954: LD_INT 3
75956: PUSH
75957: LD_INT 4
75959: PUSH
75960: LD_INT 5
75962: PUSH
75963: EMPTY
75964: LIST
75965: LIST
75966: LIST
75967: LIST
75968: LIST
75969: IN
75970: IFFALSE 75982
// uc_nation := nation_american else
75972: LD_ADDR_OWVAR 21
75976: PUSH
75977: LD_INT 1
75979: ST_TO_ADDR
75980: GO 76025
// if chassis in [ 11 , 12 , 13 , 14 ] then
75982: LD_VAR 0 1
75986: PUSH
75987: LD_INT 11
75989: PUSH
75990: LD_INT 12
75992: PUSH
75993: LD_INT 13
75995: PUSH
75996: LD_INT 14
75998: PUSH
75999: EMPTY
76000: LIST
76001: LIST
76002: LIST
76003: LIST
76004: IN
76005: IFFALSE 76017
// uc_nation := nation_arabian else
76007: LD_ADDR_OWVAR 21
76011: PUSH
76012: LD_INT 2
76014: ST_TO_ADDR
76015: GO 76025
// uc_nation := nation_russian ;
76017: LD_ADDR_OWVAR 21
76021: PUSH
76022: LD_INT 3
76024: ST_TO_ADDR
// vc_chassis := chassis ;
76025: LD_ADDR_OWVAR 37
76029: PUSH
76030: LD_VAR 0 1
76034: ST_TO_ADDR
// vc_engine := engine ;
76035: LD_ADDR_OWVAR 39
76039: PUSH
76040: LD_VAR 0 2
76044: ST_TO_ADDR
// vc_control := control ;
76045: LD_ADDR_OWVAR 38
76049: PUSH
76050: LD_VAR 0 3
76054: ST_TO_ADDR
// vc_weapon := weapon ;
76055: LD_ADDR_OWVAR 40
76059: PUSH
76060: LD_VAR 0 4
76064: ST_TO_ADDR
// un := CreateVehicle ;
76065: LD_ADDR_VAR 0 8
76069: PUSH
76070: CALL_OW 45
76074: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
76075: LD_VAR 0 8
76079: PPUSH
76080: LD_INT 0
76082: PPUSH
76083: LD_INT 5
76085: PPUSH
76086: CALL_OW 12
76090: PPUSH
76091: CALL_OW 233
// PlaceUnitXY ( un , x , y , true ) ;
76095: LD_VAR 0 8
76099: PPUSH
76100: LD_VAR 0 5
76104: PPUSH
76105: LD_VAR 0 6
76109: PPUSH
76110: LD_INT 1
76112: PPUSH
76113: CALL_OW 48
// end ;
76117: LD_VAR 0 7
76121: RET
// export hInvincible ; every 1 do
76122: GO 76124
76124: DISABLE
// hInvincible := [ ] ;
76125: LD_ADDR_EXP 156
76129: PUSH
76130: EMPTY
76131: ST_TO_ADDR
76132: END
// every 10 do var i ;
76133: GO 76135
76135: DISABLE
76136: LD_INT 0
76138: PPUSH
// begin enable ;
76139: ENABLE
// if not hInvincible then
76140: LD_EXP 156
76144: NOT
76145: IFFALSE 76149
// exit ;
76147: GO 76193
// for i in hInvincible do
76149: LD_ADDR_VAR 0 1
76153: PUSH
76154: LD_EXP 156
76158: PUSH
76159: FOR_IN
76160: IFFALSE 76191
// if GetLives ( i ) < 1000 then
76162: LD_VAR 0 1
76166: PPUSH
76167: CALL_OW 256
76171: PUSH
76172: LD_INT 1000
76174: LESS
76175: IFFALSE 76189
// SetLives ( i , 1000 ) ;
76177: LD_VAR 0 1
76181: PPUSH
76182: LD_INT 1000
76184: PPUSH
76185: CALL_OW 234
76189: GO 76159
76191: POP
76192: POP
// end ;
76193: PPOPN 1
76195: END
// export function hHackInvincible ; var i ; begin
76196: LD_INT 0
76198: PPUSH
76199: PPUSH
// for i in FilterAllUnits ( [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ) do
76200: LD_ADDR_VAR 0 2
76204: PUSH
76205: LD_INT 2
76207: PUSH
76208: LD_INT 21
76210: PUSH
76211: LD_INT 1
76213: PUSH
76214: EMPTY
76215: LIST
76216: LIST
76217: PUSH
76218: LD_INT 21
76220: PUSH
76221: LD_INT 2
76223: PUSH
76224: EMPTY
76225: LIST
76226: LIST
76227: PUSH
76228: EMPTY
76229: LIST
76230: LIST
76231: LIST
76232: PPUSH
76233: CALL_OW 69
76237: PUSH
76238: FOR_IN
76239: IFFALSE 76300
// if IsSelected ( i ) then
76241: LD_VAR 0 2
76245: PPUSH
76246: CALL_OW 306
76250: IFFALSE 76298
// begin if i in hInvincible then
76252: LD_VAR 0 2
76256: PUSH
76257: LD_EXP 156
76261: IN
76262: IFFALSE 76282
// hInvincible := hInvincible diff i else
76264: LD_ADDR_EXP 156
76268: PUSH
76269: LD_EXP 156
76273: PUSH
76274: LD_VAR 0 2
76278: DIFF
76279: ST_TO_ADDR
76280: GO 76298
// hInvincible := hInvincible union i ;
76282: LD_ADDR_EXP 156
76286: PUSH
76287: LD_EXP 156
76291: PUSH
76292: LD_VAR 0 2
76296: UNION
76297: ST_TO_ADDR
// end ;
76298: GO 76238
76300: POP
76301: POP
// end ;
76302: LD_VAR 0 1
76306: RET
// export function hHackInvisible ; var i , j ; begin
76307: LD_INT 0
76309: PPUSH
76310: PPUSH
76311: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
76312: LD_ADDR_VAR 0 2
76316: PUSH
76317: LD_INT 21
76319: PUSH
76320: LD_INT 1
76322: PUSH
76323: EMPTY
76324: LIST
76325: LIST
76326: PPUSH
76327: CALL_OW 69
76331: PUSH
76332: FOR_IN
76333: IFFALSE 76357
// if IsSelected ( i ) then
76335: LD_VAR 0 2
76339: PPUSH
76340: CALL_OW 306
76344: IFFALSE 76355
// ComForceInvisible ( i ) ;
76346: LD_VAR 0 2
76350: PPUSH
76351: CALL_OW 496
76355: GO 76332
76357: POP
76358: POP
// end ;
76359: LD_VAR 0 1
76363: RET
// export function hHackChangeYourSide ; begin
76364: LD_INT 0
76366: PPUSH
// if your_side = 8 then
76367: LD_OWVAR 2
76371: PUSH
76372: LD_INT 8
76374: EQUAL
76375: IFFALSE 76387
// your_side := 0 else
76377: LD_ADDR_OWVAR 2
76381: PUSH
76382: LD_INT 0
76384: ST_TO_ADDR
76385: GO 76401
// your_side := your_side + 1 ;
76387: LD_ADDR_OWVAR 2
76391: PUSH
76392: LD_OWVAR 2
76396: PUSH
76397: LD_INT 1
76399: PLUS
76400: ST_TO_ADDR
// end ;
76401: LD_VAR 0 1
76405: RET
// export function hHackChangeUnitSide ; var i , j ; begin
76406: LD_INT 0
76408: PPUSH
76409: PPUSH
76410: PPUSH
// for i in all_units do
76411: LD_ADDR_VAR 0 2
76415: PUSH
76416: LD_OWVAR 3
76420: PUSH
76421: FOR_IN
76422: IFFALSE 76500
// if IsSelected ( i ) then
76424: LD_VAR 0 2
76428: PPUSH
76429: CALL_OW 306
76433: IFFALSE 76498
// begin j := GetSide ( i ) ;
76435: LD_ADDR_VAR 0 3
76439: PUSH
76440: LD_VAR 0 2
76444: PPUSH
76445: CALL_OW 255
76449: ST_TO_ADDR
// if j = 8 then
76450: LD_VAR 0 3
76454: PUSH
76455: LD_INT 8
76457: EQUAL
76458: IFFALSE 76470
// j := 0 else
76460: LD_ADDR_VAR 0 3
76464: PUSH
76465: LD_INT 0
76467: ST_TO_ADDR
76468: GO 76484
// j := j + 1 ;
76470: LD_ADDR_VAR 0 3
76474: PUSH
76475: LD_VAR 0 3
76479: PUSH
76480: LD_INT 1
76482: PLUS
76483: ST_TO_ADDR
// SetSide ( i , j ) ;
76484: LD_VAR 0 2
76488: PPUSH
76489: LD_VAR 0 3
76493: PPUSH
76494: CALL_OW 235
// end ;
76498: GO 76421
76500: POP
76501: POP
// end ;
76502: LD_VAR 0 1
76506: RET
// export function hHackFog ; begin
76507: LD_INT 0
76509: PPUSH
// FogOff ( true ) ;
76510: LD_INT 1
76512: PPUSH
76513: CALL_OW 344
// end ;
76517: LD_VAR 0 1
76521: RET
// export function hHackTeleport ( unit , x , y ) ; begin
76522: LD_INT 0
76524: PPUSH
// TeleportUnit ( unit , x , y , 1 , true ) ;
76525: LD_VAR 0 1
76529: PPUSH
76530: LD_VAR 0 2
76534: PPUSH
76535: LD_VAR 0 3
76539: PPUSH
76540: LD_INT 1
76542: PPUSH
76543: LD_INT 1
76545: PPUSH
76546: CALL_OW 483
// CenterOnXY ( x , y ) ;
76550: LD_VAR 0 2
76554: PPUSH
76555: LD_VAR 0 3
76559: PPUSH
76560: CALL_OW 84
// end ; end_of_file
76564: LD_VAR 0 4
76568: RET
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb , ar_mortar , ar_crane , ar_miner ; export tech_Artillery , tech_RadMat , tech_BasicTools , tech_Cargo , tech_Track , tech_Crane , tech_Bulldozer , tech_Hovercraft , tech_MultiBarrels ; export class_mastodont , class_horse ; export function InitGlobalVariables ; begin
76569: LD_INT 0
76571: PPUSH
// ar_miner := 81 ;
76572: LD_ADDR_EXP 164
76576: PUSH
76577: LD_INT 81
76579: ST_TO_ADDR
// ar_crane := 88 ;
76580: LD_ADDR_EXP 163
76584: PUSH
76585: LD_INT 88
76587: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
76588: LD_ADDR_EXP 158
76592: PUSH
76593: LD_INT 89
76595: ST_TO_ADDR
// us_hack := 99 ;
76596: LD_ADDR_EXP 159
76600: PUSH
76601: LD_INT 99
76603: ST_TO_ADDR
// us_artillery := 97 ;
76604: LD_ADDR_EXP 160
76608: PUSH
76609: LD_INT 97
76611: ST_TO_ADDR
// ar_bio_bomb := 91 ;
76612: LD_ADDR_EXP 161
76616: PUSH
76617: LD_INT 91
76619: ST_TO_ADDR
// ar_mortar := 92 ;
76620: LD_ADDR_EXP 162
76624: PUSH
76625: LD_INT 92
76627: ST_TO_ADDR
// ru_radar := 98 ;
76628: LD_ADDR_EXP 157
76632: PUSH
76633: LD_INT 98
76635: ST_TO_ADDR
// tech_Artillery := 80 ;
76636: LD_ADDR_EXP 165
76640: PUSH
76641: LD_INT 80
76643: ST_TO_ADDR
// tech_RadMat := 81 ;
76644: LD_ADDR_EXP 166
76648: PUSH
76649: LD_INT 81
76651: ST_TO_ADDR
// tech_BasicTools := 82 ;
76652: LD_ADDR_EXP 167
76656: PUSH
76657: LD_INT 82
76659: ST_TO_ADDR
// tech_Cargo := 83 ;
76660: LD_ADDR_EXP 168
76664: PUSH
76665: LD_INT 83
76667: ST_TO_ADDR
// tech_Track := 84 ;
76668: LD_ADDR_EXP 169
76672: PUSH
76673: LD_INT 84
76675: ST_TO_ADDR
// tech_Crane := 85 ;
76676: LD_ADDR_EXP 170
76680: PUSH
76681: LD_INT 85
76683: ST_TO_ADDR
// tech_Bulldozer := 86 ;
76684: LD_ADDR_EXP 171
76688: PUSH
76689: LD_INT 86
76691: ST_TO_ADDR
// tech_Hovercraft := 87 ;
76692: LD_ADDR_EXP 172
76696: PUSH
76697: LD_INT 87
76699: ST_TO_ADDR
// tech_MultiBarrels := 88 ;
76700: LD_ADDR_EXP 173
76704: PUSH
76705: LD_INT 88
76707: ST_TO_ADDR
// class_mastodont := 31 ;
76708: LD_ADDR_EXP 174
76712: PUSH
76713: LD_INT 31
76715: ST_TO_ADDR
// class_horse := 21 ;
76716: LD_ADDR_EXP 175
76720: PUSH
76721: LD_INT 21
76723: ST_TO_ADDR
// end ;
76724: LD_VAR 0 1
76728: RET
// every 1 do
76729: GO 76731
76731: DISABLE
// InitGlobalVariables ; end_of_file
76732: CALL 76569 0 0
76736: END
// on TargetableSAIL ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) do begin case cmd of 200 .. 299 :
76737: LD_VAR 0 1
76741: PUSH
76742: LD_INT 200
76744: DOUBLE
76745: GREATEREQUAL
76746: IFFALSE 76754
76748: LD_INT 299
76750: DOUBLE
76751: LESSEQUAL
76752: IFTRUE 76756
76754: GO 76788
76756: POP
// SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; 300 .. 399 :
76757: LD_VAR 0 1
76761: PPUSH
76762: LD_VAR 0 2
76766: PPUSH
76767: LD_VAR 0 3
76771: PPUSH
76772: LD_VAR 0 4
76776: PPUSH
76777: LD_VAR 0 5
76781: PPUSH
76782: CALL 58901 0 5
76786: GO 76865
76788: LD_INT 300
76790: DOUBLE
76791: GREATEREQUAL
76792: IFFALSE 76800
76794: LD_INT 399
76796: DOUBLE
76797: LESSEQUAL
76798: IFTRUE 76802
76800: GO 76864
76802: POP
// SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; end ;
76803: LD_VAR 0 1
76807: PPUSH
76808: LD_VAR 0 2
76812: PPUSH
76813: LD_VAR 0 3
76817: PPUSH
76818: LD_VAR 0 4
76822: PPUSH
76823: LD_VAR 0 5
76827: PPUSH
76828: LD_VAR 0 6
76832: PPUSH
76833: LD_VAR 0 7
76837: PPUSH
76838: LD_VAR 0 8
76842: PPUSH
76843: LD_VAR 0 9
76847: PPUSH
76848: LD_VAR 0 10
76852: PPUSH
76853: LD_VAR 0 11
76857: PPUSH
76858: CALL 74589 0 11
76862: GO 76865
76864: POP
// end ;
76865: PPOPN 11
76867: END
// on CommandUnitXY ( cmd , un , target , x , y ) do begin SOS_CommandUnitXY ( cmd , un , target , x , y ) ;
76868: LD_VAR 0 1
76872: PPUSH
76873: LD_VAR 0 2
76877: PPUSH
76878: LD_VAR 0 3
76882: PPUSH
76883: LD_VAR 0 4
76887: PPUSH
76888: LD_VAR 0 5
76892: PPUSH
76893: CALL 58893 0 5
// end ; end_of_file
76897: PPOPN 5
76899: END
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
76900: LD_INT 0
76902: PPUSH
76903: PPUSH
76904: PPUSH
76905: PPUSH
76906: PPUSH
76907: PPUSH
76908: PPUSH
76909: PPUSH
76910: PPUSH
76911: PPUSH
76912: PPUSH
76913: PPUSH
76914: PPUSH
76915: PPUSH
76916: PPUSH
76917: PPUSH
76918: PPUSH
76919: PPUSH
76920: PPUSH
76921: PPUSH
76922: PPUSH
76923: PPUSH
76924: PPUSH
76925: PPUSH
76926: PPUSH
76927: PPUSH
76928: PPUSH
76929: PPUSH
76930: PPUSH
76931: PPUSH
76932: PPUSH
76933: PPUSH
76934: PPUSH
76935: PPUSH
// if not list then
76936: LD_VAR 0 1
76940: NOT
76941: IFFALSE 76945
// exit ;
76943: GO 81604
// base := list [ 1 ] ;
76945: LD_ADDR_VAR 0 3
76949: PUSH
76950: LD_VAR 0 1
76954: PUSH
76955: LD_INT 1
76957: ARRAY
76958: ST_TO_ADDR
// group := list [ 2 ] ;
76959: LD_ADDR_VAR 0 4
76963: PUSH
76964: LD_VAR 0 1
76968: PUSH
76969: LD_INT 2
76971: ARRAY
76972: ST_TO_ADDR
// path := list [ 3 ] ;
76973: LD_ADDR_VAR 0 5
76977: PUSH
76978: LD_VAR 0 1
76982: PUSH
76983: LD_INT 3
76985: ARRAY
76986: ST_TO_ADDR
// flags := list [ 4 ] ;
76987: LD_ADDR_VAR 0 6
76991: PUSH
76992: LD_VAR 0 1
76996: PUSH
76997: LD_INT 4
76999: ARRAY
77000: ST_TO_ADDR
// mined := [ ] ;
77001: LD_ADDR_VAR 0 27
77005: PUSH
77006: EMPTY
77007: ST_TO_ADDR
// bombed := [ ] ;
77008: LD_ADDR_VAR 0 28
77012: PUSH
77013: EMPTY
77014: ST_TO_ADDR
// healers := [ ] ;
77015: LD_ADDR_VAR 0 31
77019: PUSH
77020: EMPTY
77021: ST_TO_ADDR
// to_heal := [ ] ;
77022: LD_ADDR_VAR 0 30
77026: PUSH
77027: EMPTY
77028: ST_TO_ADDR
// repairs := [ ] ;
77029: LD_ADDR_VAR 0 33
77033: PUSH
77034: EMPTY
77035: ST_TO_ADDR
// to_repair := [ ] ;
77036: LD_ADDR_VAR 0 32
77040: PUSH
77041: EMPTY
77042: ST_TO_ADDR
// if not group or not path then
77043: LD_VAR 0 4
77047: NOT
77048: PUSH
77049: LD_VAR 0 5
77053: NOT
77054: OR
77055: IFFALSE 77059
// exit ;
77057: GO 81604
// side := GetSide ( group [ 1 ] ) ;
77059: LD_ADDR_VAR 0 35
77063: PUSH
77064: LD_VAR 0 4
77068: PUSH
77069: LD_INT 1
77071: ARRAY
77072: PPUSH
77073: CALL_OW 255
77077: ST_TO_ADDR
// if flags then
77078: LD_VAR 0 6
77082: IFFALSE 77226
// begin f_ignore_area := flags [ 1 ] ;
77084: LD_ADDR_VAR 0 17
77088: PUSH
77089: LD_VAR 0 6
77093: PUSH
77094: LD_INT 1
77096: ARRAY
77097: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
77098: LD_ADDR_VAR 0 18
77102: PUSH
77103: LD_VAR 0 6
77107: PUSH
77108: LD_INT 2
77110: ARRAY
77111: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
77112: LD_ADDR_VAR 0 19
77116: PUSH
77117: LD_VAR 0 6
77121: PUSH
77122: LD_INT 3
77124: ARRAY
77125: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
77126: LD_ADDR_VAR 0 20
77130: PUSH
77131: LD_VAR 0 6
77135: PUSH
77136: LD_INT 4
77138: ARRAY
77139: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
77140: LD_ADDR_VAR 0 21
77144: PUSH
77145: LD_VAR 0 6
77149: PUSH
77150: LD_INT 5
77152: ARRAY
77153: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
77154: LD_ADDR_VAR 0 22
77158: PUSH
77159: LD_VAR 0 6
77163: PUSH
77164: LD_INT 6
77166: ARRAY
77167: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
77168: LD_ADDR_VAR 0 23
77172: PUSH
77173: LD_VAR 0 6
77177: PUSH
77178: LD_INT 7
77180: ARRAY
77181: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
77182: LD_ADDR_VAR 0 24
77186: PUSH
77187: LD_VAR 0 6
77191: PUSH
77192: LD_INT 8
77194: ARRAY
77195: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
77196: LD_ADDR_VAR 0 25
77200: PUSH
77201: LD_VAR 0 6
77205: PUSH
77206: LD_INT 9
77208: ARRAY
77209: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
77210: LD_ADDR_VAR 0 26
77214: PUSH
77215: LD_VAR 0 6
77219: PUSH
77220: LD_INT 10
77222: ARRAY
77223: ST_TO_ADDR
// end else
77224: GO 77306
// begin f_ignore_area := false ;
77226: LD_ADDR_VAR 0 17
77230: PUSH
77231: LD_INT 0
77233: ST_TO_ADDR
// f_capture := false ;
77234: LD_ADDR_VAR 0 18
77238: PUSH
77239: LD_INT 0
77241: ST_TO_ADDR
// f_ignore_civ := false ;
77242: LD_ADDR_VAR 0 19
77246: PUSH
77247: LD_INT 0
77249: ST_TO_ADDR
// f_murder := false ;
77250: LD_ADDR_VAR 0 20
77254: PUSH
77255: LD_INT 0
77257: ST_TO_ADDR
// f_mines := false ;
77258: LD_ADDR_VAR 0 21
77262: PUSH
77263: LD_INT 0
77265: ST_TO_ADDR
// f_repair := false ;
77266: LD_ADDR_VAR 0 22
77270: PUSH
77271: LD_INT 0
77273: ST_TO_ADDR
// f_heal := false ;
77274: LD_ADDR_VAR 0 23
77278: PUSH
77279: LD_INT 0
77281: ST_TO_ADDR
// f_spacetime := false ;
77282: LD_ADDR_VAR 0 24
77286: PUSH
77287: LD_INT 0
77289: ST_TO_ADDR
// f_attack_depot := false ;
77290: LD_ADDR_VAR 0 25
77294: PUSH
77295: LD_INT 0
77297: ST_TO_ADDR
// f_crawl := false ;
77298: LD_ADDR_VAR 0 26
77302: PUSH
77303: LD_INT 0
77305: ST_TO_ADDR
// end ; if f_heal then
77306: LD_VAR 0 23
77310: IFFALSE 77337
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
77312: LD_ADDR_VAR 0 31
77316: PUSH
77317: LD_VAR 0 4
77321: PPUSH
77322: LD_INT 25
77324: PUSH
77325: LD_INT 4
77327: PUSH
77328: EMPTY
77329: LIST
77330: LIST
77331: PPUSH
77332: CALL_OW 72
77336: ST_TO_ADDR
// if f_repair then
77337: LD_VAR 0 22
77341: IFFALSE 77368
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
77343: LD_ADDR_VAR 0 33
77347: PUSH
77348: LD_VAR 0 4
77352: PPUSH
77353: LD_INT 25
77355: PUSH
77356: LD_INT 3
77358: PUSH
77359: EMPTY
77360: LIST
77361: LIST
77362: PPUSH
77363: CALL_OW 72
77367: ST_TO_ADDR
// units_path := [ ] ;
77368: LD_ADDR_VAR 0 16
77372: PUSH
77373: EMPTY
77374: ST_TO_ADDR
// for i = 1 to group do
77375: LD_ADDR_VAR 0 7
77379: PUSH
77380: DOUBLE
77381: LD_INT 1
77383: DEC
77384: ST_TO_ADDR
77385: LD_VAR 0 4
77389: PUSH
77390: FOR_TO
77391: IFFALSE 77420
// units_path := Replace ( units_path , i , path ) ;
77393: LD_ADDR_VAR 0 16
77397: PUSH
77398: LD_VAR 0 16
77402: PPUSH
77403: LD_VAR 0 7
77407: PPUSH
77408: LD_VAR 0 5
77412: PPUSH
77413: CALL_OW 1
77417: ST_TO_ADDR
77418: GO 77390
77420: POP
77421: POP
// repeat for i = group downto 1 do
77422: LD_ADDR_VAR 0 7
77426: PUSH
77427: DOUBLE
77428: LD_VAR 0 4
77432: INC
77433: ST_TO_ADDR
77434: LD_INT 1
77436: PUSH
77437: FOR_DOWNTO
77438: IFFALSE 81560
// begin wait ( 5 ) ;
77440: LD_INT 5
77442: PPUSH
77443: CALL_OW 67
// tmp := [ ] ;
77447: LD_ADDR_VAR 0 14
77451: PUSH
77452: EMPTY
77453: ST_TO_ADDR
// attacking := false ;
77454: LD_ADDR_VAR 0 29
77458: PUSH
77459: LD_INT 0
77461: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
77462: LD_VAR 0 4
77466: PUSH
77467: LD_VAR 0 7
77471: ARRAY
77472: PPUSH
77473: CALL_OW 301
77477: PUSH
77478: LD_VAR 0 4
77482: PUSH
77483: LD_VAR 0 7
77487: ARRAY
77488: NOT
77489: OR
77490: IFFALSE 77599
// begin if GetType ( group [ i ] ) = unit_human then
77492: LD_VAR 0 4
77496: PUSH
77497: LD_VAR 0 7
77501: ARRAY
77502: PPUSH
77503: CALL_OW 247
77507: PUSH
77508: LD_INT 1
77510: EQUAL
77511: IFFALSE 77557
// begin to_heal := to_heal diff group [ i ] ;
77513: LD_ADDR_VAR 0 30
77517: PUSH
77518: LD_VAR 0 30
77522: PUSH
77523: LD_VAR 0 4
77527: PUSH
77528: LD_VAR 0 7
77532: ARRAY
77533: DIFF
77534: ST_TO_ADDR
// healers := healers diff group [ i ] ;
77535: LD_ADDR_VAR 0 31
77539: PUSH
77540: LD_VAR 0 31
77544: PUSH
77545: LD_VAR 0 4
77549: PUSH
77550: LD_VAR 0 7
77554: ARRAY
77555: DIFF
77556: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
77557: LD_ADDR_VAR 0 4
77561: PUSH
77562: LD_VAR 0 4
77566: PPUSH
77567: LD_VAR 0 7
77571: PPUSH
77572: CALL_OW 3
77576: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
77577: LD_ADDR_VAR 0 16
77581: PUSH
77582: LD_VAR 0 16
77586: PPUSH
77587: LD_VAR 0 7
77591: PPUSH
77592: CALL_OW 3
77596: ST_TO_ADDR
// continue ;
77597: GO 77437
// end ; if f_repair then
77599: LD_VAR 0 22
77603: IFFALSE 78092
// begin if GetType ( group [ i ] ) = unit_vehicle then
77605: LD_VAR 0 4
77609: PUSH
77610: LD_VAR 0 7
77614: ARRAY
77615: PPUSH
77616: CALL_OW 247
77620: PUSH
77621: LD_INT 2
77623: EQUAL
77624: IFFALSE 77814
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
77626: LD_VAR 0 4
77630: PUSH
77631: LD_VAR 0 7
77635: ARRAY
77636: PPUSH
77637: CALL_OW 256
77641: PUSH
77642: LD_INT 700
77644: LESS
77645: PUSH
77646: LD_VAR 0 4
77650: PUSH
77651: LD_VAR 0 7
77655: ARRAY
77656: PUSH
77657: LD_VAR 0 32
77661: IN
77662: NOT
77663: AND
77664: IFFALSE 77688
// to_repair := to_repair union group [ i ] ;
77666: LD_ADDR_VAR 0 32
77670: PUSH
77671: LD_VAR 0 32
77675: PUSH
77676: LD_VAR 0 4
77680: PUSH
77681: LD_VAR 0 7
77685: ARRAY
77686: UNION
77687: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
77688: LD_VAR 0 4
77692: PUSH
77693: LD_VAR 0 7
77697: ARRAY
77698: PPUSH
77699: CALL_OW 256
77703: PUSH
77704: LD_INT 1000
77706: EQUAL
77707: PUSH
77708: LD_VAR 0 4
77712: PUSH
77713: LD_VAR 0 7
77717: ARRAY
77718: PUSH
77719: LD_VAR 0 32
77723: IN
77724: AND
77725: IFFALSE 77749
// to_repair := to_repair diff group [ i ] ;
77727: LD_ADDR_VAR 0 32
77731: PUSH
77732: LD_VAR 0 32
77736: PUSH
77737: LD_VAR 0 4
77741: PUSH
77742: LD_VAR 0 7
77746: ARRAY
77747: DIFF
77748: ST_TO_ADDR
// if group [ i ] in to_repair then
77749: LD_VAR 0 4
77753: PUSH
77754: LD_VAR 0 7
77758: ARRAY
77759: PUSH
77760: LD_VAR 0 32
77764: IN
77765: IFFALSE 77812
// begin if not IsInArea ( group [ i ] , f_repair ) then
77767: LD_VAR 0 4
77771: PUSH
77772: LD_VAR 0 7
77776: ARRAY
77777: PPUSH
77778: LD_VAR 0 22
77782: PPUSH
77783: CALL_OW 308
77787: NOT
77788: IFFALSE 77810
// ComMoveToArea ( group [ i ] , f_repair ) ;
77790: LD_VAR 0 4
77794: PUSH
77795: LD_VAR 0 7
77799: ARRAY
77800: PPUSH
77801: LD_VAR 0 22
77805: PPUSH
77806: CALL_OW 113
// continue ;
77810: GO 77437
// end ; end else
77812: GO 78092
// if group [ i ] in repairs then
77814: LD_VAR 0 4
77818: PUSH
77819: LD_VAR 0 7
77823: ARRAY
77824: PUSH
77825: LD_VAR 0 33
77829: IN
77830: IFFALSE 78092
// begin if IsInUnit ( group [ i ] ) then
77832: LD_VAR 0 4
77836: PUSH
77837: LD_VAR 0 7
77841: ARRAY
77842: PPUSH
77843: CALL_OW 310
77847: IFFALSE 77915
// begin z := IsInUnit ( group [ i ] ) ;
77849: LD_ADDR_VAR 0 13
77853: PUSH
77854: LD_VAR 0 4
77858: PUSH
77859: LD_VAR 0 7
77863: ARRAY
77864: PPUSH
77865: CALL_OW 310
77869: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
77870: LD_VAR 0 13
77874: PUSH
77875: LD_VAR 0 32
77879: IN
77880: PUSH
77881: LD_VAR 0 13
77885: PPUSH
77886: LD_VAR 0 22
77890: PPUSH
77891: CALL_OW 308
77895: AND
77896: IFFALSE 77913
// ComExitVehicle ( group [ i ] ) ;
77898: LD_VAR 0 4
77902: PUSH
77903: LD_VAR 0 7
77907: ARRAY
77908: PPUSH
77909: CALL_OW 121
// end else
77913: GO 78092
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
77915: LD_ADDR_VAR 0 13
77919: PUSH
77920: LD_VAR 0 4
77924: PPUSH
77925: LD_INT 95
77927: PUSH
77928: LD_VAR 0 22
77932: PUSH
77933: EMPTY
77934: LIST
77935: LIST
77936: PUSH
77937: LD_INT 58
77939: PUSH
77940: EMPTY
77941: LIST
77942: PUSH
77943: EMPTY
77944: LIST
77945: LIST
77946: PPUSH
77947: CALL_OW 72
77951: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
77952: LD_VAR 0 4
77956: PUSH
77957: LD_VAR 0 7
77961: ARRAY
77962: PPUSH
77963: CALL_OW 314
77967: NOT
77968: IFFALSE 78090
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
77970: LD_ADDR_VAR 0 10
77974: PUSH
77975: LD_VAR 0 13
77979: PPUSH
77980: LD_VAR 0 4
77984: PUSH
77985: LD_VAR 0 7
77989: ARRAY
77990: PPUSH
77991: CALL_OW 74
77995: ST_TO_ADDR
// if not x then
77996: LD_VAR 0 10
78000: NOT
78001: IFFALSE 78005
// continue ;
78003: GO 77437
// if GetLives ( x ) < 1000 then
78005: LD_VAR 0 10
78009: PPUSH
78010: CALL_OW 256
78014: PUSH
78015: LD_INT 1000
78017: LESS
78018: IFFALSE 78042
// ComRepairVehicle ( group [ i ] , x ) else
78020: LD_VAR 0 4
78024: PUSH
78025: LD_VAR 0 7
78029: ARRAY
78030: PPUSH
78031: LD_VAR 0 10
78035: PPUSH
78036: CALL_OW 129
78040: GO 78090
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
78042: LD_VAR 0 23
78046: PUSH
78047: LD_VAR 0 4
78051: PUSH
78052: LD_VAR 0 7
78056: ARRAY
78057: PPUSH
78058: CALL_OW 256
78062: PUSH
78063: LD_INT 1000
78065: LESS
78066: AND
78067: NOT
78068: IFFALSE 78090
// ComEnterUnit ( group [ i ] , x ) ;
78070: LD_VAR 0 4
78074: PUSH
78075: LD_VAR 0 7
78079: ARRAY
78080: PPUSH
78081: LD_VAR 0 10
78085: PPUSH
78086: CALL_OW 120
// end ; continue ;
78090: GO 77437
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
78092: LD_VAR 0 23
78096: PUSH
78097: LD_VAR 0 4
78101: PUSH
78102: LD_VAR 0 7
78106: ARRAY
78107: PPUSH
78108: CALL_OW 247
78112: PUSH
78113: LD_INT 1
78115: EQUAL
78116: AND
78117: IFFALSE 78595
// begin if group [ i ] in healers then
78119: LD_VAR 0 4
78123: PUSH
78124: LD_VAR 0 7
78128: ARRAY
78129: PUSH
78130: LD_VAR 0 31
78134: IN
78135: IFFALSE 78408
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
78137: LD_VAR 0 4
78141: PUSH
78142: LD_VAR 0 7
78146: ARRAY
78147: PPUSH
78148: LD_VAR 0 23
78152: PPUSH
78153: CALL_OW 308
78157: NOT
78158: PUSH
78159: LD_VAR 0 4
78163: PUSH
78164: LD_VAR 0 7
78168: ARRAY
78169: PPUSH
78170: CALL_OW 314
78174: NOT
78175: AND
78176: IFFALSE 78200
// ComMoveToArea ( group [ i ] , f_heal ) else
78178: LD_VAR 0 4
78182: PUSH
78183: LD_VAR 0 7
78187: ARRAY
78188: PPUSH
78189: LD_VAR 0 23
78193: PPUSH
78194: CALL_OW 113
78198: GO 78406
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
78200: LD_VAR 0 4
78204: PUSH
78205: LD_VAR 0 7
78209: ARRAY
78210: PPUSH
78211: CALL 53290 0 1
78215: PPUSH
78216: CALL_OW 256
78220: PUSH
78221: LD_INT 1000
78223: EQUAL
78224: IFFALSE 78243
// ComStop ( group [ i ] ) else
78226: LD_VAR 0 4
78230: PUSH
78231: LD_VAR 0 7
78235: ARRAY
78236: PPUSH
78237: CALL_OW 141
78241: GO 78406
// if not HasTask ( group [ i ] ) and to_heal then
78243: LD_VAR 0 4
78247: PUSH
78248: LD_VAR 0 7
78252: ARRAY
78253: PPUSH
78254: CALL_OW 314
78258: NOT
78259: PUSH
78260: LD_VAR 0 30
78264: AND
78265: IFFALSE 78406
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
78267: LD_ADDR_VAR 0 13
78271: PUSH
78272: LD_VAR 0 30
78276: PPUSH
78277: LD_INT 3
78279: PUSH
78280: LD_INT 54
78282: PUSH
78283: EMPTY
78284: LIST
78285: PUSH
78286: EMPTY
78287: LIST
78288: LIST
78289: PPUSH
78290: CALL_OW 72
78294: PPUSH
78295: LD_VAR 0 4
78299: PUSH
78300: LD_VAR 0 7
78304: ARRAY
78305: PPUSH
78306: CALL_OW 74
78310: ST_TO_ADDR
// if z then
78311: LD_VAR 0 13
78315: IFFALSE 78406
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
78317: LD_INT 91
78319: PUSH
78320: LD_VAR 0 13
78324: PUSH
78325: LD_INT 10
78327: PUSH
78328: EMPTY
78329: LIST
78330: LIST
78331: LIST
78332: PUSH
78333: LD_INT 81
78335: PUSH
78336: LD_VAR 0 13
78340: PPUSH
78341: CALL_OW 255
78345: PUSH
78346: EMPTY
78347: LIST
78348: LIST
78349: PUSH
78350: EMPTY
78351: LIST
78352: LIST
78353: PPUSH
78354: CALL_OW 69
78358: PUSH
78359: LD_INT 0
78361: EQUAL
78362: IFFALSE 78386
// ComHeal ( group [ i ] , z ) else
78364: LD_VAR 0 4
78368: PUSH
78369: LD_VAR 0 7
78373: ARRAY
78374: PPUSH
78375: LD_VAR 0 13
78379: PPUSH
78380: CALL_OW 128
78384: GO 78406
// ComMoveToArea ( group [ i ] , f_heal ) ;
78386: LD_VAR 0 4
78390: PUSH
78391: LD_VAR 0 7
78395: ARRAY
78396: PPUSH
78397: LD_VAR 0 23
78401: PPUSH
78402: CALL_OW 113
// end ; continue ;
78406: GO 77437
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
78408: LD_VAR 0 4
78412: PUSH
78413: LD_VAR 0 7
78417: ARRAY
78418: PPUSH
78419: CALL_OW 256
78423: PUSH
78424: LD_INT 700
78426: LESS
78427: PUSH
78428: LD_VAR 0 4
78432: PUSH
78433: LD_VAR 0 7
78437: ARRAY
78438: PUSH
78439: LD_VAR 0 30
78443: IN
78444: NOT
78445: AND
78446: IFFALSE 78470
// to_heal := to_heal union group [ i ] ;
78448: LD_ADDR_VAR 0 30
78452: PUSH
78453: LD_VAR 0 30
78457: PUSH
78458: LD_VAR 0 4
78462: PUSH
78463: LD_VAR 0 7
78467: ARRAY
78468: UNION
78469: ST_TO_ADDR
// if group [ i ] in to_heal then
78470: LD_VAR 0 4
78474: PUSH
78475: LD_VAR 0 7
78479: ARRAY
78480: PUSH
78481: LD_VAR 0 30
78485: IN
78486: IFFALSE 78595
// begin if GetLives ( group [ i ] ) = 1000 then
78488: LD_VAR 0 4
78492: PUSH
78493: LD_VAR 0 7
78497: ARRAY
78498: PPUSH
78499: CALL_OW 256
78503: PUSH
78504: LD_INT 1000
78506: EQUAL
78507: IFFALSE 78533
// to_heal := to_heal diff group [ i ] else
78509: LD_ADDR_VAR 0 30
78513: PUSH
78514: LD_VAR 0 30
78518: PUSH
78519: LD_VAR 0 4
78523: PUSH
78524: LD_VAR 0 7
78528: ARRAY
78529: DIFF
78530: ST_TO_ADDR
78531: GO 78595
// begin if not IsInArea ( group [ i ] , to_heal ) then
78533: LD_VAR 0 4
78537: PUSH
78538: LD_VAR 0 7
78542: ARRAY
78543: PPUSH
78544: LD_VAR 0 30
78548: PPUSH
78549: CALL_OW 308
78553: NOT
78554: IFFALSE 78578
// ComMoveToArea ( group [ i ] , f_heal ) else
78556: LD_VAR 0 4
78560: PUSH
78561: LD_VAR 0 7
78565: ARRAY
78566: PPUSH
78567: LD_VAR 0 23
78571: PPUSH
78572: CALL_OW 113
78576: GO 78593
// ComHold ( group [ i ] ) ;
78578: LD_VAR 0 4
78582: PUSH
78583: LD_VAR 0 7
78587: ARRAY
78588: PPUSH
78589: CALL_OW 140
// continue ;
78593: GO 77437
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
78595: LD_VAR 0 4
78599: PUSH
78600: LD_VAR 0 7
78604: ARRAY
78605: PPUSH
78606: LD_INT 10
78608: PPUSH
78609: CALL 51710 0 2
78613: NOT
78614: PUSH
78615: LD_VAR 0 16
78619: PUSH
78620: LD_VAR 0 7
78624: ARRAY
78625: PUSH
78626: EMPTY
78627: EQUAL
78628: NOT
78629: AND
78630: IFFALSE 78896
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
78632: LD_VAR 0 4
78636: PUSH
78637: LD_VAR 0 7
78641: ARRAY
78642: PPUSH
78643: CALL_OW 262
78647: PUSH
78648: LD_INT 1
78650: PUSH
78651: LD_INT 2
78653: PUSH
78654: EMPTY
78655: LIST
78656: LIST
78657: IN
78658: IFFALSE 78699
// if GetFuel ( group [ i ] ) < 10 then
78660: LD_VAR 0 4
78664: PUSH
78665: LD_VAR 0 7
78669: ARRAY
78670: PPUSH
78671: CALL_OW 261
78675: PUSH
78676: LD_INT 10
78678: LESS
78679: IFFALSE 78699
// SetFuel ( group [ i ] , 12 ) ;
78681: LD_VAR 0 4
78685: PUSH
78686: LD_VAR 0 7
78690: ARRAY
78691: PPUSH
78692: LD_INT 12
78694: PPUSH
78695: CALL_OW 240
// if units_path [ i ] then
78699: LD_VAR 0 16
78703: PUSH
78704: LD_VAR 0 7
78708: ARRAY
78709: IFFALSE 78894
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
78711: LD_VAR 0 4
78715: PUSH
78716: LD_VAR 0 7
78720: ARRAY
78721: PPUSH
78722: LD_VAR 0 16
78726: PUSH
78727: LD_VAR 0 7
78731: ARRAY
78732: PUSH
78733: LD_INT 1
78735: ARRAY
78736: PUSH
78737: LD_INT 1
78739: ARRAY
78740: PPUSH
78741: LD_VAR 0 16
78745: PUSH
78746: LD_VAR 0 7
78750: ARRAY
78751: PUSH
78752: LD_INT 1
78754: ARRAY
78755: PUSH
78756: LD_INT 2
78758: ARRAY
78759: PPUSH
78760: CALL_OW 297
78764: PUSH
78765: LD_INT 6
78767: GREATER
78768: IFFALSE 78843
// begin if not HasTask ( group [ i ] ) then
78770: LD_VAR 0 4
78774: PUSH
78775: LD_VAR 0 7
78779: ARRAY
78780: PPUSH
78781: CALL_OW 314
78785: NOT
78786: IFFALSE 78841
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
78788: LD_VAR 0 4
78792: PUSH
78793: LD_VAR 0 7
78797: ARRAY
78798: PPUSH
78799: LD_VAR 0 16
78803: PUSH
78804: LD_VAR 0 7
78808: ARRAY
78809: PUSH
78810: LD_INT 1
78812: ARRAY
78813: PUSH
78814: LD_INT 1
78816: ARRAY
78817: PPUSH
78818: LD_VAR 0 16
78822: PUSH
78823: LD_VAR 0 7
78827: ARRAY
78828: PUSH
78829: LD_INT 1
78831: ARRAY
78832: PUSH
78833: LD_INT 2
78835: ARRAY
78836: PPUSH
78837: CALL_OW 114
// end else
78841: GO 78894
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
78843: LD_ADDR_VAR 0 15
78847: PUSH
78848: LD_VAR 0 16
78852: PUSH
78853: LD_VAR 0 7
78857: ARRAY
78858: PPUSH
78859: LD_INT 1
78861: PPUSH
78862: CALL_OW 3
78866: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
78867: LD_ADDR_VAR 0 16
78871: PUSH
78872: LD_VAR 0 16
78876: PPUSH
78877: LD_VAR 0 7
78881: PPUSH
78882: LD_VAR 0 15
78886: PPUSH
78887: CALL_OW 1
78891: ST_TO_ADDR
// continue ;
78892: GO 77437
// end ; end ; end else
78894: GO 81558
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
78896: LD_ADDR_VAR 0 14
78900: PUSH
78901: LD_INT 81
78903: PUSH
78904: LD_VAR 0 4
78908: PUSH
78909: LD_VAR 0 7
78913: ARRAY
78914: PPUSH
78915: CALL_OW 255
78919: PUSH
78920: EMPTY
78921: LIST
78922: LIST
78923: PPUSH
78924: CALL_OW 69
78928: ST_TO_ADDR
// if not tmp then
78929: LD_VAR 0 14
78933: NOT
78934: IFFALSE 78938
// continue ;
78936: GO 77437
// if f_ignore_area then
78938: LD_VAR 0 17
78942: IFFALSE 79030
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
78944: LD_ADDR_VAR 0 15
78948: PUSH
78949: LD_VAR 0 14
78953: PPUSH
78954: LD_INT 3
78956: PUSH
78957: LD_INT 92
78959: PUSH
78960: LD_VAR 0 17
78964: PUSH
78965: LD_INT 1
78967: ARRAY
78968: PUSH
78969: LD_VAR 0 17
78973: PUSH
78974: LD_INT 2
78976: ARRAY
78977: PUSH
78978: LD_VAR 0 17
78982: PUSH
78983: LD_INT 3
78985: ARRAY
78986: PUSH
78987: EMPTY
78988: LIST
78989: LIST
78990: LIST
78991: LIST
78992: PUSH
78993: EMPTY
78994: LIST
78995: LIST
78996: PPUSH
78997: CALL_OW 72
79001: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
79002: LD_VAR 0 14
79006: PUSH
79007: LD_VAR 0 15
79011: DIFF
79012: IFFALSE 79030
// tmp := tmp diff tmp2 ;
79014: LD_ADDR_VAR 0 14
79018: PUSH
79019: LD_VAR 0 14
79023: PUSH
79024: LD_VAR 0 15
79028: DIFF
79029: ST_TO_ADDR
// end ; if not f_murder then
79030: LD_VAR 0 20
79034: NOT
79035: IFFALSE 79093
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
79037: LD_ADDR_VAR 0 15
79041: PUSH
79042: LD_VAR 0 14
79046: PPUSH
79047: LD_INT 3
79049: PUSH
79050: LD_INT 50
79052: PUSH
79053: EMPTY
79054: LIST
79055: PUSH
79056: EMPTY
79057: LIST
79058: LIST
79059: PPUSH
79060: CALL_OW 72
79064: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
79065: LD_VAR 0 14
79069: PUSH
79070: LD_VAR 0 15
79074: DIFF
79075: IFFALSE 79093
// tmp := tmp diff tmp2 ;
79077: LD_ADDR_VAR 0 14
79081: PUSH
79082: LD_VAR 0 14
79086: PUSH
79087: LD_VAR 0 15
79091: DIFF
79092: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
79093: LD_ADDR_VAR 0 14
79097: PUSH
79098: LD_VAR 0 4
79102: PUSH
79103: LD_VAR 0 7
79107: ARRAY
79108: PPUSH
79109: LD_VAR 0 14
79113: PPUSH
79114: LD_INT 1
79116: PPUSH
79117: LD_INT 1
79119: PPUSH
79120: CALL 24645 0 4
79124: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
79125: LD_VAR 0 4
79129: PUSH
79130: LD_VAR 0 7
79134: ARRAY
79135: PPUSH
79136: CALL_OW 257
79140: PUSH
79141: LD_INT 1
79143: EQUAL
79144: IFFALSE 79592
// begin if WantPlant ( group [ i ] ) then
79146: LD_VAR 0 4
79150: PUSH
79151: LD_VAR 0 7
79155: ARRAY
79156: PPUSH
79157: CALL 24146 0 1
79161: IFFALSE 79165
// continue ;
79163: GO 77437
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
79165: LD_VAR 0 18
79169: PUSH
79170: LD_VAR 0 4
79174: PUSH
79175: LD_VAR 0 7
79179: ARRAY
79180: PPUSH
79181: CALL_OW 310
79185: NOT
79186: AND
79187: PUSH
79188: LD_VAR 0 14
79192: PUSH
79193: LD_INT 1
79195: ARRAY
79196: PUSH
79197: LD_VAR 0 14
79201: PPUSH
79202: LD_INT 21
79204: PUSH
79205: LD_INT 2
79207: PUSH
79208: EMPTY
79209: LIST
79210: LIST
79211: PUSH
79212: LD_INT 58
79214: PUSH
79215: EMPTY
79216: LIST
79217: PUSH
79218: EMPTY
79219: LIST
79220: LIST
79221: PPUSH
79222: CALL_OW 72
79226: IN
79227: AND
79228: IFFALSE 79264
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
79230: LD_VAR 0 4
79234: PUSH
79235: LD_VAR 0 7
79239: ARRAY
79240: PPUSH
79241: LD_VAR 0 14
79245: PUSH
79246: LD_INT 1
79248: ARRAY
79249: PPUSH
79250: CALL_OW 120
// attacking := true ;
79254: LD_ADDR_VAR 0 29
79258: PUSH
79259: LD_INT 1
79261: ST_TO_ADDR
// continue ;
79262: GO 77437
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
79264: LD_VAR 0 26
79268: PUSH
79269: LD_VAR 0 4
79273: PUSH
79274: LD_VAR 0 7
79278: ARRAY
79279: PPUSH
79280: CALL_OW 257
79284: PUSH
79285: LD_INT 1
79287: EQUAL
79288: AND
79289: PUSH
79290: LD_VAR 0 4
79294: PUSH
79295: LD_VAR 0 7
79299: ARRAY
79300: PPUSH
79301: CALL_OW 256
79305: PUSH
79306: LD_INT 800
79308: LESS
79309: AND
79310: PUSH
79311: LD_VAR 0 4
79315: PUSH
79316: LD_VAR 0 7
79320: ARRAY
79321: PPUSH
79322: CALL_OW 318
79326: NOT
79327: AND
79328: IFFALSE 79345
// ComCrawl ( group [ i ] ) ;
79330: LD_VAR 0 4
79334: PUSH
79335: LD_VAR 0 7
79339: ARRAY
79340: PPUSH
79341: CALL_OW 137
// if f_mines then
79345: LD_VAR 0 21
79349: IFFALSE 79592
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
79351: LD_VAR 0 14
79355: PUSH
79356: LD_INT 1
79358: ARRAY
79359: PPUSH
79360: CALL_OW 247
79364: PUSH
79365: LD_INT 3
79367: EQUAL
79368: PUSH
79369: LD_VAR 0 14
79373: PUSH
79374: LD_INT 1
79376: ARRAY
79377: PUSH
79378: LD_VAR 0 27
79382: IN
79383: NOT
79384: AND
79385: IFFALSE 79592
// begin x := GetX ( tmp [ 1 ] ) ;
79387: LD_ADDR_VAR 0 10
79391: PUSH
79392: LD_VAR 0 14
79396: PUSH
79397: LD_INT 1
79399: ARRAY
79400: PPUSH
79401: CALL_OW 250
79405: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
79406: LD_ADDR_VAR 0 11
79410: PUSH
79411: LD_VAR 0 14
79415: PUSH
79416: LD_INT 1
79418: ARRAY
79419: PPUSH
79420: CALL_OW 251
79424: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
79425: LD_ADDR_VAR 0 12
79429: PUSH
79430: LD_VAR 0 4
79434: PUSH
79435: LD_VAR 0 7
79439: ARRAY
79440: PPUSH
79441: CALL 51795 0 1
79445: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
79446: LD_VAR 0 4
79450: PUSH
79451: LD_VAR 0 7
79455: ARRAY
79456: PPUSH
79457: LD_VAR 0 10
79461: PPUSH
79462: LD_VAR 0 11
79466: PPUSH
79467: LD_VAR 0 14
79471: PUSH
79472: LD_INT 1
79474: ARRAY
79475: PPUSH
79476: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
79480: LD_VAR 0 4
79484: PUSH
79485: LD_VAR 0 7
79489: ARRAY
79490: PPUSH
79491: LD_VAR 0 10
79495: PPUSH
79496: LD_VAR 0 12
79500: PPUSH
79501: LD_INT 7
79503: PPUSH
79504: CALL_OW 272
79508: PPUSH
79509: LD_VAR 0 11
79513: PPUSH
79514: LD_VAR 0 12
79518: PPUSH
79519: LD_INT 7
79521: PPUSH
79522: CALL_OW 273
79526: PPUSH
79527: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
79531: LD_VAR 0 4
79535: PUSH
79536: LD_VAR 0 7
79540: ARRAY
79541: PPUSH
79542: LD_INT 71
79544: PPUSH
79545: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
79549: LD_ADDR_VAR 0 27
79553: PUSH
79554: LD_VAR 0 27
79558: PPUSH
79559: LD_VAR 0 27
79563: PUSH
79564: LD_INT 1
79566: PLUS
79567: PPUSH
79568: LD_VAR 0 14
79572: PUSH
79573: LD_INT 1
79575: ARRAY
79576: PPUSH
79577: CALL_OW 1
79581: ST_TO_ADDR
// attacking := true ;
79582: LD_ADDR_VAR 0 29
79586: PUSH
79587: LD_INT 1
79589: ST_TO_ADDR
// continue ;
79590: GO 77437
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
79592: LD_VAR 0 4
79596: PUSH
79597: LD_VAR 0 7
79601: ARRAY
79602: PPUSH
79603: CALL_OW 257
79607: PUSH
79608: LD_INT 17
79610: EQUAL
79611: PUSH
79612: LD_VAR 0 4
79616: PUSH
79617: LD_VAR 0 7
79621: ARRAY
79622: PPUSH
79623: CALL_OW 110
79627: PUSH
79628: LD_INT 71
79630: EQUAL
79631: NOT
79632: AND
79633: IFFALSE 79779
// begin attacking := false ;
79635: LD_ADDR_VAR 0 29
79639: PUSH
79640: LD_INT 0
79642: ST_TO_ADDR
// k := 5 ;
79643: LD_ADDR_VAR 0 9
79647: PUSH
79648: LD_INT 5
79650: ST_TO_ADDR
// if tmp < k then
79651: LD_VAR 0 14
79655: PUSH
79656: LD_VAR 0 9
79660: LESS
79661: IFFALSE 79673
// k := tmp ;
79663: LD_ADDR_VAR 0 9
79667: PUSH
79668: LD_VAR 0 14
79672: ST_TO_ADDR
// for j = 1 to k do
79673: LD_ADDR_VAR 0 8
79677: PUSH
79678: DOUBLE
79679: LD_INT 1
79681: DEC
79682: ST_TO_ADDR
79683: LD_VAR 0 9
79687: PUSH
79688: FOR_TO
79689: IFFALSE 79777
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
79691: LD_VAR 0 14
79695: PUSH
79696: LD_VAR 0 8
79700: ARRAY
79701: PUSH
79702: LD_VAR 0 14
79706: PPUSH
79707: LD_INT 58
79709: PUSH
79710: EMPTY
79711: LIST
79712: PPUSH
79713: CALL_OW 72
79717: IN
79718: NOT
79719: IFFALSE 79775
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
79721: LD_VAR 0 4
79725: PUSH
79726: LD_VAR 0 7
79730: ARRAY
79731: PPUSH
79732: LD_VAR 0 14
79736: PUSH
79737: LD_VAR 0 8
79741: ARRAY
79742: PPUSH
79743: CALL_OW 115
// attacking := true ;
79747: LD_ADDR_VAR 0 29
79751: PUSH
79752: LD_INT 1
79754: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
79755: LD_VAR 0 4
79759: PUSH
79760: LD_VAR 0 7
79764: ARRAY
79765: PPUSH
79766: LD_INT 71
79768: PPUSH
79769: CALL_OW 109
// continue ;
79773: GO 79688
// end ; end ;
79775: GO 79688
79777: POP
79778: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
79779: LD_VAR 0 4
79783: PUSH
79784: LD_VAR 0 7
79788: ARRAY
79789: PPUSH
79790: CALL_OW 257
79794: PUSH
79795: LD_INT 8
79797: EQUAL
79798: PUSH
79799: LD_VAR 0 4
79803: PUSH
79804: LD_VAR 0 7
79808: ARRAY
79809: PPUSH
79810: CALL_OW 264
79814: PUSH
79815: LD_INT 28
79817: PUSH
79818: LD_INT 45
79820: PUSH
79821: LD_INT 7
79823: PUSH
79824: LD_INT 47
79826: PUSH
79827: EMPTY
79828: LIST
79829: LIST
79830: LIST
79831: LIST
79832: IN
79833: OR
79834: IFFALSE 80090
// begin attacking := false ;
79836: LD_ADDR_VAR 0 29
79840: PUSH
79841: LD_INT 0
79843: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
79844: LD_VAR 0 14
79848: PUSH
79849: LD_INT 1
79851: ARRAY
79852: PPUSH
79853: CALL_OW 266
79857: PUSH
79858: LD_INT 32
79860: PUSH
79861: LD_INT 31
79863: PUSH
79864: LD_INT 33
79866: PUSH
79867: LD_INT 4
79869: PUSH
79870: LD_INT 5
79872: PUSH
79873: EMPTY
79874: LIST
79875: LIST
79876: LIST
79877: LIST
79878: LIST
79879: IN
79880: IFFALSE 80066
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
79882: LD_ADDR_VAR 0 9
79886: PUSH
79887: LD_VAR 0 14
79891: PUSH
79892: LD_INT 1
79894: ARRAY
79895: PPUSH
79896: CALL_OW 266
79900: PPUSH
79901: LD_VAR 0 14
79905: PUSH
79906: LD_INT 1
79908: ARRAY
79909: PPUSH
79910: CALL_OW 250
79914: PPUSH
79915: LD_VAR 0 14
79919: PUSH
79920: LD_INT 1
79922: ARRAY
79923: PPUSH
79924: CALL_OW 251
79928: PPUSH
79929: LD_VAR 0 14
79933: PUSH
79934: LD_INT 1
79936: ARRAY
79937: PPUSH
79938: CALL_OW 254
79942: PPUSH
79943: LD_VAR 0 14
79947: PUSH
79948: LD_INT 1
79950: ARRAY
79951: PPUSH
79952: CALL_OW 248
79956: PPUSH
79957: LD_INT 0
79959: PPUSH
79960: CALL 33165 0 6
79964: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
79965: LD_ADDR_VAR 0 8
79969: PUSH
79970: LD_VAR 0 4
79974: PUSH
79975: LD_VAR 0 7
79979: ARRAY
79980: PPUSH
79981: LD_VAR 0 9
79985: PPUSH
79986: CALL 51835 0 2
79990: ST_TO_ADDR
// if j then
79991: LD_VAR 0 8
79995: IFFALSE 80064
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
79997: LD_VAR 0 8
80001: PUSH
80002: LD_INT 1
80004: ARRAY
80005: PPUSH
80006: LD_VAR 0 8
80010: PUSH
80011: LD_INT 2
80013: ARRAY
80014: PPUSH
80015: CALL_OW 488
80019: IFFALSE 80064
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
80021: LD_VAR 0 4
80025: PUSH
80026: LD_VAR 0 7
80030: ARRAY
80031: PPUSH
80032: LD_VAR 0 8
80036: PUSH
80037: LD_INT 1
80039: ARRAY
80040: PPUSH
80041: LD_VAR 0 8
80045: PUSH
80046: LD_INT 2
80048: ARRAY
80049: PPUSH
80050: CALL_OW 116
// attacking := true ;
80054: LD_ADDR_VAR 0 29
80058: PUSH
80059: LD_INT 1
80061: ST_TO_ADDR
// continue ;
80062: GO 77437
// end ; end else
80064: GO 80090
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
80066: LD_VAR 0 4
80070: PUSH
80071: LD_VAR 0 7
80075: ARRAY
80076: PPUSH
80077: LD_VAR 0 14
80081: PUSH
80082: LD_INT 1
80084: ARRAY
80085: PPUSH
80086: CALL_OW 115
// end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
80090: LD_VAR 0 4
80094: PUSH
80095: LD_VAR 0 7
80099: ARRAY
80100: PPUSH
80101: CALL_OW 265
80105: PUSH
80106: LD_INT 11
80108: EQUAL
80109: IFFALSE 80387
// begin k := 10 ;
80111: LD_ADDR_VAR 0 9
80115: PUSH
80116: LD_INT 10
80118: ST_TO_ADDR
// x := 0 ;
80119: LD_ADDR_VAR 0 10
80123: PUSH
80124: LD_INT 0
80126: ST_TO_ADDR
// if tmp < k then
80127: LD_VAR 0 14
80131: PUSH
80132: LD_VAR 0 9
80136: LESS
80137: IFFALSE 80149
// k := tmp ;
80139: LD_ADDR_VAR 0 9
80143: PUSH
80144: LD_VAR 0 14
80148: ST_TO_ADDR
// for j = k downto 1 do
80149: LD_ADDR_VAR 0 8
80153: PUSH
80154: DOUBLE
80155: LD_VAR 0 9
80159: INC
80160: ST_TO_ADDR
80161: LD_INT 1
80163: PUSH
80164: FOR_DOWNTO
80165: IFFALSE 80240
// begin if GetType ( tmp [ j ] ) = unit_human then
80167: LD_VAR 0 14
80171: PUSH
80172: LD_VAR 0 8
80176: ARRAY
80177: PPUSH
80178: CALL_OW 247
80182: PUSH
80183: LD_INT 1
80185: EQUAL
80186: IFFALSE 80238
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
80188: LD_VAR 0 4
80192: PUSH
80193: LD_VAR 0 7
80197: ARRAY
80198: PPUSH
80199: LD_VAR 0 14
80203: PUSH
80204: LD_VAR 0 8
80208: ARRAY
80209: PPUSH
80210: CALL 52106 0 2
// x := tmp [ j ] ;
80214: LD_ADDR_VAR 0 10
80218: PUSH
80219: LD_VAR 0 14
80223: PUSH
80224: LD_VAR 0 8
80228: ARRAY
80229: ST_TO_ADDR
// attacking := true ;
80230: LD_ADDR_VAR 0 29
80234: PUSH
80235: LD_INT 1
80237: ST_TO_ADDR
// end ; end ;
80238: GO 80164
80240: POP
80241: POP
// if not x then
80242: LD_VAR 0 10
80246: NOT
80247: IFFALSE 80387
// begin attacking := true ;
80249: LD_ADDR_VAR 0 29
80253: PUSH
80254: LD_INT 1
80256: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
80257: LD_VAR 0 4
80261: PUSH
80262: LD_VAR 0 7
80266: ARRAY
80267: PPUSH
80268: CALL_OW 250
80272: PPUSH
80273: LD_VAR 0 4
80277: PUSH
80278: LD_VAR 0 7
80282: ARRAY
80283: PPUSH
80284: CALL_OW 251
80288: PPUSH
80289: CALL_OW 546
80293: PUSH
80294: LD_INT 2
80296: ARRAY
80297: PUSH
80298: LD_VAR 0 14
80302: PUSH
80303: LD_INT 1
80305: ARRAY
80306: PPUSH
80307: CALL_OW 250
80311: PPUSH
80312: LD_VAR 0 14
80316: PUSH
80317: LD_INT 1
80319: ARRAY
80320: PPUSH
80321: CALL_OW 251
80325: PPUSH
80326: CALL_OW 546
80330: PUSH
80331: LD_INT 2
80333: ARRAY
80334: EQUAL
80335: IFFALSE 80363
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
80337: LD_VAR 0 4
80341: PUSH
80342: LD_VAR 0 7
80346: ARRAY
80347: PPUSH
80348: LD_VAR 0 14
80352: PUSH
80353: LD_INT 1
80355: ARRAY
80356: PPUSH
80357: CALL 52106 0 2
80361: GO 80387
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
80363: LD_VAR 0 4
80367: PUSH
80368: LD_VAR 0 7
80372: ARRAY
80373: PPUSH
80374: LD_VAR 0 14
80378: PUSH
80379: LD_INT 1
80381: ARRAY
80382: PPUSH
80383: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
80387: LD_VAR 0 4
80391: PUSH
80392: LD_VAR 0 7
80396: ARRAY
80397: PPUSH
80398: CALL_OW 264
80402: PUSH
80403: LD_INT 29
80405: EQUAL
80406: IFFALSE 80772
// begin if WantsToAttack ( group [ i ] ) in bombed then
80408: LD_VAR 0 4
80412: PUSH
80413: LD_VAR 0 7
80417: ARRAY
80418: PPUSH
80419: CALL_OW 319
80423: PUSH
80424: LD_VAR 0 28
80428: IN
80429: IFFALSE 80433
// continue ;
80431: GO 77437
// k := 8 ;
80433: LD_ADDR_VAR 0 9
80437: PUSH
80438: LD_INT 8
80440: ST_TO_ADDR
// x := 0 ;
80441: LD_ADDR_VAR 0 10
80445: PUSH
80446: LD_INT 0
80448: ST_TO_ADDR
// if tmp < k then
80449: LD_VAR 0 14
80453: PUSH
80454: LD_VAR 0 9
80458: LESS
80459: IFFALSE 80471
// k := tmp ;
80461: LD_ADDR_VAR 0 9
80465: PUSH
80466: LD_VAR 0 14
80470: ST_TO_ADDR
// for j = 1 to k do
80471: LD_ADDR_VAR 0 8
80475: PUSH
80476: DOUBLE
80477: LD_INT 1
80479: DEC
80480: ST_TO_ADDR
80481: LD_VAR 0 9
80485: PUSH
80486: FOR_TO
80487: IFFALSE 80619
// begin if GetType ( tmp [ j ] ) = unit_building then
80489: LD_VAR 0 14
80493: PUSH
80494: LD_VAR 0 8
80498: ARRAY
80499: PPUSH
80500: CALL_OW 247
80504: PUSH
80505: LD_INT 3
80507: EQUAL
80508: IFFALSE 80617
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
80510: LD_VAR 0 14
80514: PUSH
80515: LD_VAR 0 8
80519: ARRAY
80520: PUSH
80521: LD_VAR 0 28
80525: IN
80526: NOT
80527: PUSH
80528: LD_VAR 0 14
80532: PUSH
80533: LD_VAR 0 8
80537: ARRAY
80538: PPUSH
80539: CALL_OW 313
80543: AND
80544: IFFALSE 80617
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
80546: LD_VAR 0 4
80550: PUSH
80551: LD_VAR 0 7
80555: ARRAY
80556: PPUSH
80557: LD_VAR 0 14
80561: PUSH
80562: LD_VAR 0 8
80566: ARRAY
80567: PPUSH
80568: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
80572: LD_ADDR_VAR 0 28
80576: PUSH
80577: LD_VAR 0 28
80581: PPUSH
80582: LD_VAR 0 28
80586: PUSH
80587: LD_INT 1
80589: PLUS
80590: PPUSH
80591: LD_VAR 0 14
80595: PUSH
80596: LD_VAR 0 8
80600: ARRAY
80601: PPUSH
80602: CALL_OW 1
80606: ST_TO_ADDR
// attacking := true ;
80607: LD_ADDR_VAR 0 29
80611: PUSH
80612: LD_INT 1
80614: ST_TO_ADDR
// break ;
80615: GO 80619
// end ; end ;
80617: GO 80486
80619: POP
80620: POP
// if not attacking and f_attack_depot then
80621: LD_VAR 0 29
80625: NOT
80626: PUSH
80627: LD_VAR 0 25
80631: AND
80632: IFFALSE 80727
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
80634: LD_ADDR_VAR 0 13
80638: PUSH
80639: LD_VAR 0 14
80643: PPUSH
80644: LD_INT 2
80646: PUSH
80647: LD_INT 30
80649: PUSH
80650: LD_INT 0
80652: PUSH
80653: EMPTY
80654: LIST
80655: LIST
80656: PUSH
80657: LD_INT 30
80659: PUSH
80660: LD_INT 1
80662: PUSH
80663: EMPTY
80664: LIST
80665: LIST
80666: PUSH
80667: EMPTY
80668: LIST
80669: LIST
80670: LIST
80671: PPUSH
80672: CALL_OW 72
80676: ST_TO_ADDR
// if z then
80677: LD_VAR 0 13
80681: IFFALSE 80727
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
80683: LD_VAR 0 4
80687: PUSH
80688: LD_VAR 0 7
80692: ARRAY
80693: PPUSH
80694: LD_VAR 0 13
80698: PPUSH
80699: LD_VAR 0 4
80703: PUSH
80704: LD_VAR 0 7
80708: ARRAY
80709: PPUSH
80710: CALL_OW 74
80714: PPUSH
80715: CALL_OW 115
// attacking := true ;
80719: LD_ADDR_VAR 0 29
80723: PUSH
80724: LD_INT 1
80726: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
80727: LD_VAR 0 4
80731: PUSH
80732: LD_VAR 0 7
80736: ARRAY
80737: PPUSH
80738: CALL_OW 256
80742: PUSH
80743: LD_INT 500
80745: LESS
80746: IFFALSE 80772
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
80748: LD_VAR 0 4
80752: PUSH
80753: LD_VAR 0 7
80757: ARRAY
80758: PPUSH
80759: LD_VAR 0 14
80763: PUSH
80764: LD_INT 1
80766: ARRAY
80767: PPUSH
80768: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
80772: LD_VAR 0 4
80776: PUSH
80777: LD_VAR 0 7
80781: ARRAY
80782: PPUSH
80783: CALL_OW 264
80787: PUSH
80788: LD_INT 49
80790: EQUAL
80791: IFFALSE 80912
// begin if not HasTask ( group [ i ] ) then
80793: LD_VAR 0 4
80797: PUSH
80798: LD_VAR 0 7
80802: ARRAY
80803: PPUSH
80804: CALL_OW 314
80808: NOT
80809: IFFALSE 80912
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
80811: LD_ADDR_VAR 0 9
80815: PUSH
80816: LD_INT 81
80818: PUSH
80819: LD_VAR 0 4
80823: PUSH
80824: LD_VAR 0 7
80828: ARRAY
80829: PPUSH
80830: CALL_OW 255
80834: PUSH
80835: EMPTY
80836: LIST
80837: LIST
80838: PPUSH
80839: CALL_OW 69
80843: PPUSH
80844: LD_VAR 0 4
80848: PUSH
80849: LD_VAR 0 7
80853: ARRAY
80854: PPUSH
80855: CALL_OW 74
80859: ST_TO_ADDR
// if k then
80860: LD_VAR 0 9
80864: IFFALSE 80912
// if GetDistUnits ( group [ i ] , k ) > 10 then
80866: LD_VAR 0 4
80870: PUSH
80871: LD_VAR 0 7
80875: ARRAY
80876: PPUSH
80877: LD_VAR 0 9
80881: PPUSH
80882: CALL_OW 296
80886: PUSH
80887: LD_INT 10
80889: GREATER
80890: IFFALSE 80912
// ComMoveUnit ( group [ i ] , k ) ;
80892: LD_VAR 0 4
80896: PUSH
80897: LD_VAR 0 7
80901: ARRAY
80902: PPUSH
80903: LD_VAR 0 9
80907: PPUSH
80908: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
80912: LD_VAR 0 4
80916: PUSH
80917: LD_VAR 0 7
80921: ARRAY
80922: PPUSH
80923: CALL_OW 256
80927: PUSH
80928: LD_INT 250
80930: LESS
80931: PUSH
80932: LD_VAR 0 4
80936: PUSH
80937: LD_VAR 0 7
80941: ARRAY
80942: PUSH
80943: LD_INT 21
80945: PUSH
80946: LD_INT 2
80948: PUSH
80949: EMPTY
80950: LIST
80951: LIST
80952: PUSH
80953: LD_INT 23
80955: PUSH
80956: LD_INT 2
80958: PUSH
80959: EMPTY
80960: LIST
80961: LIST
80962: PUSH
80963: EMPTY
80964: LIST
80965: LIST
80966: PPUSH
80967: CALL_OW 69
80971: IN
80972: AND
80973: IFFALSE 81098
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
80975: LD_ADDR_VAR 0 9
80979: PUSH
80980: LD_OWVAR 3
80984: PUSH
80985: LD_VAR 0 4
80989: PUSH
80990: LD_VAR 0 7
80994: ARRAY
80995: DIFF
80996: PPUSH
80997: LD_VAR 0 4
81001: PUSH
81002: LD_VAR 0 7
81006: ARRAY
81007: PPUSH
81008: CALL_OW 74
81012: ST_TO_ADDR
// if not k then
81013: LD_VAR 0 9
81017: NOT
81018: IFFALSE 81022
// continue ;
81020: GO 77437
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
81022: LD_VAR 0 9
81026: PUSH
81027: LD_INT 81
81029: PUSH
81030: LD_VAR 0 4
81034: PUSH
81035: LD_VAR 0 7
81039: ARRAY
81040: PPUSH
81041: CALL_OW 255
81045: PUSH
81046: EMPTY
81047: LIST
81048: LIST
81049: PPUSH
81050: CALL_OW 69
81054: IN
81055: PUSH
81056: LD_VAR 0 9
81060: PPUSH
81061: LD_VAR 0 4
81065: PUSH
81066: LD_VAR 0 7
81070: ARRAY
81071: PPUSH
81072: CALL_OW 296
81076: PUSH
81077: LD_INT 5
81079: LESS
81080: AND
81081: IFFALSE 81098
// ComAutodestruct ( group [ i ] ) ;
81083: LD_VAR 0 4
81087: PUSH
81088: LD_VAR 0 7
81092: ARRAY
81093: PPUSH
81094: CALL 52004 0 1
// end ; if f_attack_depot then
81098: LD_VAR 0 25
81102: IFFALSE 81214
// begin k := 6 ;
81104: LD_ADDR_VAR 0 9
81108: PUSH
81109: LD_INT 6
81111: ST_TO_ADDR
// if tmp < k then
81112: LD_VAR 0 14
81116: PUSH
81117: LD_VAR 0 9
81121: LESS
81122: IFFALSE 81134
// k := tmp ;
81124: LD_ADDR_VAR 0 9
81128: PUSH
81129: LD_VAR 0 14
81133: ST_TO_ADDR
// for j = 1 to k do
81134: LD_ADDR_VAR 0 8
81138: PUSH
81139: DOUBLE
81140: LD_INT 1
81142: DEC
81143: ST_TO_ADDR
81144: LD_VAR 0 9
81148: PUSH
81149: FOR_TO
81150: IFFALSE 81212
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
81152: LD_VAR 0 8
81156: PPUSH
81157: CALL_OW 266
81161: PUSH
81162: LD_INT 0
81164: PUSH
81165: LD_INT 1
81167: PUSH
81168: EMPTY
81169: LIST
81170: LIST
81171: IN
81172: IFFALSE 81210
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
81174: LD_VAR 0 4
81178: PUSH
81179: LD_VAR 0 7
81183: ARRAY
81184: PPUSH
81185: LD_VAR 0 14
81189: PUSH
81190: LD_VAR 0 8
81194: ARRAY
81195: PPUSH
81196: CALL_OW 115
// attacking := true ;
81200: LD_ADDR_VAR 0 29
81204: PUSH
81205: LD_INT 1
81207: ST_TO_ADDR
// break ;
81208: GO 81212
// end ;
81210: GO 81149
81212: POP
81213: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
81214: LD_VAR 0 4
81218: PUSH
81219: LD_VAR 0 7
81223: ARRAY
81224: PPUSH
81225: CALL_OW 302
81229: PUSH
81230: LD_VAR 0 29
81234: NOT
81235: AND
81236: IFFALSE 81558
// begin if GetTag ( group [ i ] ) = 71 then
81238: LD_VAR 0 4
81242: PUSH
81243: LD_VAR 0 7
81247: ARRAY
81248: PPUSH
81249: CALL_OW 110
81253: PUSH
81254: LD_INT 71
81256: EQUAL
81257: IFFALSE 81298
// begin if HasTask ( group [ i ] ) then
81259: LD_VAR 0 4
81263: PUSH
81264: LD_VAR 0 7
81268: ARRAY
81269: PPUSH
81270: CALL_OW 314
81274: IFFALSE 81280
// continue else
81276: GO 77437
81278: GO 81298
// SetTag ( group [ i ] , 0 ) ;
81280: LD_VAR 0 4
81284: PUSH
81285: LD_VAR 0 7
81289: ARRAY
81290: PPUSH
81291: LD_INT 0
81293: PPUSH
81294: CALL_OW 109
// end ; k := 8 ;
81298: LD_ADDR_VAR 0 9
81302: PUSH
81303: LD_INT 8
81305: ST_TO_ADDR
// x := 0 ;
81306: LD_ADDR_VAR 0 10
81310: PUSH
81311: LD_INT 0
81313: ST_TO_ADDR
// if tmp < k then
81314: LD_VAR 0 14
81318: PUSH
81319: LD_VAR 0 9
81323: LESS
81324: IFFALSE 81336
// k := tmp ;
81326: LD_ADDR_VAR 0 9
81330: PUSH
81331: LD_VAR 0 14
81335: ST_TO_ADDR
// for j = 1 to k do
81336: LD_ADDR_VAR 0 8
81340: PUSH
81341: DOUBLE
81342: LD_INT 1
81344: DEC
81345: ST_TO_ADDR
81346: LD_VAR 0 9
81350: PUSH
81351: FOR_TO
81352: IFFALSE 81450
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
81354: LD_VAR 0 14
81358: PUSH
81359: LD_VAR 0 8
81363: ARRAY
81364: PPUSH
81365: CALL_OW 247
81369: PUSH
81370: LD_INT 1
81372: EQUAL
81373: PUSH
81374: LD_VAR 0 14
81378: PUSH
81379: LD_VAR 0 8
81383: ARRAY
81384: PPUSH
81385: CALL_OW 256
81389: PUSH
81390: LD_INT 250
81392: LESS
81393: PUSH
81394: LD_VAR 0 20
81398: AND
81399: PUSH
81400: LD_VAR 0 20
81404: NOT
81405: PUSH
81406: LD_VAR 0 14
81410: PUSH
81411: LD_VAR 0 8
81415: ARRAY
81416: PPUSH
81417: CALL_OW 256
81421: PUSH
81422: LD_INT 250
81424: GREATEREQUAL
81425: AND
81426: OR
81427: AND
81428: IFFALSE 81448
// begin x := tmp [ j ] ;
81430: LD_ADDR_VAR 0 10
81434: PUSH
81435: LD_VAR 0 14
81439: PUSH
81440: LD_VAR 0 8
81444: ARRAY
81445: ST_TO_ADDR
// break ;
81446: GO 81450
// end ;
81448: GO 81351
81450: POP
81451: POP
// if x then
81452: LD_VAR 0 10
81456: IFFALSE 81480
// ComAttackUnit ( group [ i ] , x ) else
81458: LD_VAR 0 4
81462: PUSH
81463: LD_VAR 0 7
81467: ARRAY
81468: PPUSH
81469: LD_VAR 0 10
81473: PPUSH
81474: CALL_OW 115
81478: GO 81504
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
81480: LD_VAR 0 4
81484: PUSH
81485: LD_VAR 0 7
81489: ARRAY
81490: PPUSH
81491: LD_VAR 0 14
81495: PUSH
81496: LD_INT 1
81498: ARRAY
81499: PPUSH
81500: CALL_OW 115
// if not HasTask ( group [ i ] ) then
81504: LD_VAR 0 4
81508: PUSH
81509: LD_VAR 0 7
81513: ARRAY
81514: PPUSH
81515: CALL_OW 314
81519: NOT
81520: IFFALSE 81558
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
81522: LD_VAR 0 4
81526: PUSH
81527: LD_VAR 0 7
81531: ARRAY
81532: PPUSH
81533: LD_VAR 0 14
81537: PPUSH
81538: LD_VAR 0 4
81542: PUSH
81543: LD_VAR 0 7
81547: ARRAY
81548: PPUSH
81549: CALL_OW 74
81553: PPUSH
81554: CALL_OW 115
// end ; end ; end ;
81558: GO 77437
81560: POP
81561: POP
// wait ( 0 0$2 ) ;
81562: LD_INT 70
81564: PPUSH
81565: CALL_OW 67
// until not group or group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
81569: LD_VAR 0 4
81573: NOT
81574: PUSH
81575: LD_VAR 0 4
81579: PUSH
81580: EMPTY
81581: EQUAL
81582: OR
81583: PUSH
81584: LD_INT 81
81586: PUSH
81587: LD_VAR 0 35
81591: PUSH
81592: EMPTY
81593: LIST
81594: LIST
81595: PPUSH
81596: CALL_OW 69
81600: NOT
81601: OR
81602: IFFALSE 77422
// end ;
81604: LD_VAR 0 2
81608: RET
// export function BasicDefend ( base , solds ) ; var enemy , e , side , i , hex ; begin
81609: LD_INT 0
81611: PPUSH
81612: PPUSH
81613: PPUSH
81614: PPUSH
81615: PPUSH
81616: PPUSH
// if not base or not mc_bases [ base ] or not solds then
81617: LD_VAR 0 1
81621: NOT
81622: PUSH
81623: LD_EXP 178
81627: PUSH
81628: LD_VAR 0 1
81632: ARRAY
81633: NOT
81634: OR
81635: PUSH
81636: LD_VAR 0 2
81640: NOT
81641: OR
81642: IFFALSE 81646
// exit ;
81644: GO 82200
// side := mc_sides [ base ] ;
81646: LD_ADDR_VAR 0 6
81650: PUSH
81651: LD_EXP 204
81655: PUSH
81656: LD_VAR 0 1
81660: ARRAY
81661: ST_TO_ADDR
// if not side then
81662: LD_VAR 0 6
81666: NOT
81667: IFFALSE 81671
// exit ;
81669: GO 82200
// for i in solds do
81671: LD_ADDR_VAR 0 7
81675: PUSH
81676: LD_VAR 0 2
81680: PUSH
81681: FOR_IN
81682: IFFALSE 81743
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
81684: LD_VAR 0 7
81688: PPUSH
81689: CALL_OW 310
81693: PPUSH
81694: CALL_OW 266
81698: PUSH
81699: LD_INT 32
81701: PUSH
81702: LD_INT 31
81704: PUSH
81705: EMPTY
81706: LIST
81707: LIST
81708: IN
81709: IFFALSE 81729
// solds := solds diff i else
81711: LD_ADDR_VAR 0 2
81715: PUSH
81716: LD_VAR 0 2
81720: PUSH
81721: LD_VAR 0 7
81725: DIFF
81726: ST_TO_ADDR
81727: GO 81741
// SetTag ( i , 18 ) ;
81729: LD_VAR 0 7
81733: PPUSH
81734: LD_INT 18
81736: PPUSH
81737: CALL_OW 109
81741: GO 81681
81743: POP
81744: POP
// if not solds then
81745: LD_VAR 0 2
81749: NOT
81750: IFFALSE 81754
// exit ;
81752: GO 82200
// repeat wait ( 0 0$2 ) ;
81754: LD_INT 70
81756: PPUSH
81757: CALL_OW 67
// enemy := mc_scan [ base ] ;
81761: LD_ADDR_VAR 0 4
81765: PUSH
81766: LD_EXP 201
81770: PUSH
81771: LD_VAR 0 1
81775: ARRAY
81776: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
81777: LD_EXP 178
81781: PUSH
81782: LD_VAR 0 1
81786: ARRAY
81787: NOT
81788: PUSH
81789: LD_EXP 178
81793: PUSH
81794: LD_VAR 0 1
81798: ARRAY
81799: PUSH
81800: EMPTY
81801: EQUAL
81802: OR
81803: IFFALSE 81840
// begin for i in solds do
81805: LD_ADDR_VAR 0 7
81809: PUSH
81810: LD_VAR 0 2
81814: PUSH
81815: FOR_IN
81816: IFFALSE 81829
// ComStop ( i ) ;
81818: LD_VAR 0 7
81822: PPUSH
81823: CALL_OW 141
81827: GO 81815
81829: POP
81830: POP
// solds := [ ] ;
81831: LD_ADDR_VAR 0 2
81835: PUSH
81836: EMPTY
81837: ST_TO_ADDR
// exit ;
81838: GO 82200
// end ; for i in solds do
81840: LD_ADDR_VAR 0 7
81844: PUSH
81845: LD_VAR 0 2
81849: PUSH
81850: FOR_IN
81851: IFFALSE 82172
// begin if IsInUnit ( i ) then
81853: LD_VAR 0 7
81857: PPUSH
81858: CALL_OW 310
81862: IFFALSE 81873
// ComExitBuilding ( i ) ;
81864: LD_VAR 0 7
81868: PPUSH
81869: CALL_OW 122
// if GetLives ( i ) > 500 then
81873: LD_VAR 0 7
81877: PPUSH
81878: CALL_OW 256
81882: PUSH
81883: LD_INT 500
81885: GREATER
81886: IFFALSE 81939
// begin e := NearestUnitToUnit ( enemy , i ) ;
81888: LD_ADDR_VAR 0 5
81892: PUSH
81893: LD_VAR 0 4
81897: PPUSH
81898: LD_VAR 0 7
81902: PPUSH
81903: CALL_OW 74
81907: ST_TO_ADDR
// ComAgressiveMove ( i , GetX ( e ) , GetY ( e ) ) ;
81908: LD_VAR 0 7
81912: PPUSH
81913: LD_VAR 0 5
81917: PPUSH
81918: CALL_OW 250
81922: PPUSH
81923: LD_VAR 0 5
81927: PPUSH
81928: CALL_OW 251
81932: PPUSH
81933: CALL_OW 114
// end else
81937: GO 82170
// if GetDistUnits ( i , NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ) > 10 then
81939: LD_VAR 0 7
81943: PPUSH
81944: LD_EXP 178
81948: PUSH
81949: LD_VAR 0 1
81953: ARRAY
81954: PPUSH
81955: LD_INT 2
81957: PUSH
81958: LD_INT 30
81960: PUSH
81961: LD_INT 0
81963: PUSH
81964: EMPTY
81965: LIST
81966: LIST
81967: PUSH
81968: LD_INT 30
81970: PUSH
81971: LD_INT 1
81973: PUSH
81974: EMPTY
81975: LIST
81976: LIST
81977: PUSH
81978: LD_INT 30
81980: PUSH
81981: LD_INT 6
81983: PUSH
81984: EMPTY
81985: LIST
81986: LIST
81987: PUSH
81988: EMPTY
81989: LIST
81990: LIST
81991: LIST
81992: LIST
81993: PPUSH
81994: CALL_OW 72
81998: PPUSH
81999: LD_VAR 0 7
82003: PPUSH
82004: CALL_OW 74
82008: PPUSH
82009: CALL_OW 296
82013: PUSH
82014: LD_INT 10
82016: GREATER
82017: IFFALSE 82170
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
82019: LD_ADDR_VAR 0 8
82023: PUSH
82024: LD_EXP 178
82028: PUSH
82029: LD_VAR 0 1
82033: ARRAY
82034: PPUSH
82035: LD_INT 2
82037: PUSH
82038: LD_INT 30
82040: PUSH
82041: LD_INT 0
82043: PUSH
82044: EMPTY
82045: LIST
82046: LIST
82047: PUSH
82048: LD_INT 30
82050: PUSH
82051: LD_INT 1
82053: PUSH
82054: EMPTY
82055: LIST
82056: LIST
82057: PUSH
82058: LD_INT 30
82060: PUSH
82061: LD_INT 6
82063: PUSH
82064: EMPTY
82065: LIST
82066: LIST
82067: PUSH
82068: EMPTY
82069: LIST
82070: LIST
82071: LIST
82072: LIST
82073: PPUSH
82074: CALL_OW 72
82078: PPUSH
82079: LD_VAR 0 7
82083: PPUSH
82084: CALL_OW 74
82088: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
82089: LD_VAR 0 7
82093: PPUSH
82094: LD_VAR 0 8
82098: PPUSH
82099: CALL_OW 250
82103: PPUSH
82104: LD_INT 3
82106: PPUSH
82107: LD_INT 5
82109: PPUSH
82110: CALL_OW 272
82114: PPUSH
82115: LD_VAR 0 8
82119: PPUSH
82120: CALL_OW 251
82124: PPUSH
82125: LD_INT 3
82127: PPUSH
82128: LD_INT 5
82130: PPUSH
82131: CALL_OW 273
82135: PPUSH
82136: CALL_OW 111
// SetTag ( i , 0 ) ;
82140: LD_VAR 0 7
82144: PPUSH
82145: LD_INT 0
82147: PPUSH
82148: CALL_OW 109
// solds := solds diff i ;
82152: LD_ADDR_VAR 0 2
82156: PUSH
82157: LD_VAR 0 2
82161: PUSH
82162: LD_VAR 0 7
82166: DIFF
82167: ST_TO_ADDR
// continue ;
82168: GO 81850
// end ; end ;
82170: GO 81850
82172: POP
82173: POP
// until not solds or not enemy ;
82174: LD_VAR 0 2
82178: NOT
82179: PUSH
82180: LD_VAR 0 4
82184: NOT
82185: OR
82186: IFFALSE 81754
// MC_Reset ( base , 18 ) ;
82188: LD_VAR 0 1
82192: PPUSH
82193: LD_INT 18
82195: PPUSH
82196: CALL 88355 0 2
// end ;
82200: LD_VAR 0 3
82204: RET
// export function Defend ( base , defenders ) ; var i , j , x , depot , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend , class , enemy ; begin
82205: LD_INT 0
82207: PPUSH
82208: PPUSH
82209: PPUSH
82210: PPUSH
82211: PPUSH
82212: PPUSH
82213: PPUSH
82214: PPUSH
82215: PPUSH
82216: PPUSH
82217: PPUSH
82218: PPUSH
82219: PPUSH
82220: PPUSH
82221: PPUSH
82222: PPUSH
82223: PPUSH
82224: PPUSH
82225: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
82226: LD_ADDR_VAR 0 12
82230: PUSH
82231: LD_EXP 178
82235: PUSH
82236: LD_VAR 0 1
82240: ARRAY
82241: PPUSH
82242: LD_INT 25
82244: PUSH
82245: LD_INT 3
82247: PUSH
82248: EMPTY
82249: LIST
82250: LIST
82251: PPUSH
82252: CALL_OW 72
82256: ST_TO_ADDR
// if mc_remote_driver [ base ] then
82257: LD_EXP 218
82261: PUSH
82262: LD_VAR 0 1
82266: ARRAY
82267: IFFALSE 82291
// mechs := mechs diff mc_remote_driver [ base ] ;
82269: LD_ADDR_VAR 0 12
82273: PUSH
82274: LD_VAR 0 12
82278: PUSH
82279: LD_EXP 218
82283: PUSH
82284: LD_VAR 0 1
82288: ARRAY
82289: DIFF
82290: ST_TO_ADDR
// for i in mechs do
82291: LD_ADDR_VAR 0 4
82295: PUSH
82296: LD_VAR 0 12
82300: PUSH
82301: FOR_IN
82302: IFFALSE 82337
// if GetTag ( i ) > 0 then
82304: LD_VAR 0 4
82308: PPUSH
82309: CALL_OW 110
82313: PUSH
82314: LD_INT 0
82316: GREATER
82317: IFFALSE 82335
// mechs := mechs diff i ;
82319: LD_ADDR_VAR 0 12
82323: PUSH
82324: LD_VAR 0 12
82328: PUSH
82329: LD_VAR 0 4
82333: DIFF
82334: ST_TO_ADDR
82335: GO 82301
82337: POP
82338: POP
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
82339: LD_ADDR_VAR 0 8
82343: PUSH
82344: LD_EXP 178
82348: PUSH
82349: LD_VAR 0 1
82353: ARRAY
82354: PPUSH
82355: LD_INT 2
82357: PUSH
82358: LD_INT 25
82360: PUSH
82361: LD_INT 1
82363: PUSH
82364: EMPTY
82365: LIST
82366: LIST
82367: PUSH
82368: LD_INT 25
82370: PUSH
82371: LD_INT 5
82373: PUSH
82374: EMPTY
82375: LIST
82376: LIST
82377: PUSH
82378: LD_INT 25
82380: PUSH
82381: LD_INT 8
82383: PUSH
82384: EMPTY
82385: LIST
82386: LIST
82387: PUSH
82388: LD_INT 25
82390: PUSH
82391: LD_INT 9
82393: PUSH
82394: EMPTY
82395: LIST
82396: LIST
82397: PUSH
82398: EMPTY
82399: LIST
82400: LIST
82401: LIST
82402: LIST
82403: LIST
82404: PPUSH
82405: CALL_OW 72
82409: ST_TO_ADDR
// if not defenders and not solds then
82410: LD_VAR 0 2
82414: NOT
82415: PUSH
82416: LD_VAR 0 8
82420: NOT
82421: AND
82422: IFFALSE 82426
// exit ;
82424: GO 84196
// depot_under_attack := false ;
82426: LD_ADDR_VAR 0 16
82430: PUSH
82431: LD_INT 0
82433: ST_TO_ADDR
// sold_defenders := [ ] ;
82434: LD_ADDR_VAR 0 17
82438: PUSH
82439: EMPTY
82440: ST_TO_ADDR
// if mechs then
82441: LD_VAR 0 12
82445: IFFALSE 82598
// for i in UnitFilter ( defenders , [ f_type , unit_vehicle ] ) do
82447: LD_ADDR_VAR 0 4
82451: PUSH
82452: LD_VAR 0 2
82456: PPUSH
82457: LD_INT 21
82459: PUSH
82460: LD_INT 2
82462: PUSH
82463: EMPTY
82464: LIST
82465: LIST
82466: PPUSH
82467: CALL_OW 72
82471: PUSH
82472: FOR_IN
82473: IFFALSE 82596
// begin if GetTag ( i ) <> 20 then
82475: LD_VAR 0 4
82479: PPUSH
82480: CALL_OW 110
82484: PUSH
82485: LD_INT 20
82487: NONEQUAL
82488: IFFALSE 82502
// SetTag ( i , 20 ) ;
82490: LD_VAR 0 4
82494: PPUSH
82495: LD_INT 20
82497: PPUSH
82498: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) then
82502: LD_VAR 0 4
82506: PPUSH
82507: CALL_OW 263
82511: PUSH
82512: LD_INT 1
82514: EQUAL
82515: PUSH
82516: LD_VAR 0 4
82520: PPUSH
82521: CALL_OW 311
82525: NOT
82526: AND
82527: IFFALSE 82594
// begin un := mechs [ 1 ] ;
82529: LD_ADDR_VAR 0 10
82533: PUSH
82534: LD_VAR 0 12
82538: PUSH
82539: LD_INT 1
82541: ARRAY
82542: ST_TO_ADDR
// ComExit ( un ) ;
82543: LD_VAR 0 10
82547: PPUSH
82548: CALL 56349 0 1
// AddComEnterUnit ( un , i ) ;
82552: LD_VAR 0 10
82556: PPUSH
82557: LD_VAR 0 4
82561: PPUSH
82562: CALL_OW 180
// SetTag ( un , 19 ) ;
82566: LD_VAR 0 10
82570: PPUSH
82571: LD_INT 19
82573: PPUSH
82574: CALL_OW 109
// mechs := mechs diff un ;
82578: LD_ADDR_VAR 0 12
82582: PUSH
82583: LD_VAR 0 12
82587: PUSH
82588: LD_VAR 0 10
82592: DIFF
82593: ST_TO_ADDR
// end ; end ;
82594: GO 82472
82596: POP
82597: POP
// if solds then
82598: LD_VAR 0 8
82602: IFFALSE 82661
// for i in solds do
82604: LD_ADDR_VAR 0 4
82608: PUSH
82609: LD_VAR 0 8
82613: PUSH
82614: FOR_IN
82615: IFFALSE 82659
// if not GetTag ( i ) then
82617: LD_VAR 0 4
82621: PPUSH
82622: CALL_OW 110
82626: NOT
82627: IFFALSE 82657
// begin defenders := defenders union i ;
82629: LD_ADDR_VAR 0 2
82633: PUSH
82634: LD_VAR 0 2
82638: PUSH
82639: LD_VAR 0 4
82643: UNION
82644: ST_TO_ADDR
// SetTag ( i , 18 ) ;
82645: LD_VAR 0 4
82649: PPUSH
82650: LD_INT 18
82652: PPUSH
82653: CALL_OW 109
// end ;
82657: GO 82614
82659: POP
82660: POP
// repeat wait ( 0 0$2 ) ;
82661: LD_INT 70
82663: PPUSH
82664: CALL_OW 67
// enemy := mc_scan [ base ] ;
82668: LD_ADDR_VAR 0 21
82672: PUSH
82673: LD_EXP 201
82677: PUSH
82678: LD_VAR 0 1
82682: ARRAY
82683: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
82684: LD_EXP 178
82688: PUSH
82689: LD_VAR 0 1
82693: ARRAY
82694: NOT
82695: PUSH
82696: LD_EXP 178
82700: PUSH
82701: LD_VAR 0 1
82705: ARRAY
82706: PUSH
82707: EMPTY
82708: EQUAL
82709: OR
82710: IFFALSE 82747
// begin for i in defenders do
82712: LD_ADDR_VAR 0 4
82716: PUSH
82717: LD_VAR 0 2
82721: PUSH
82722: FOR_IN
82723: IFFALSE 82736
// ComStop ( i ) ;
82725: LD_VAR 0 4
82729: PPUSH
82730: CALL_OW 141
82734: GO 82722
82736: POP
82737: POP
// defenders := [ ] ;
82738: LD_ADDR_VAR 0 2
82742: PUSH
82743: EMPTY
82744: ST_TO_ADDR
// exit ;
82745: GO 84196
// end ; for i in defenders do
82747: LD_ADDR_VAR 0 4
82751: PUSH
82752: LD_VAR 0 2
82756: PUSH
82757: FOR_IN
82758: IFFALSE 83656
// begin e := NearestUnitToUnit ( enemy , i ) ;
82760: LD_ADDR_VAR 0 13
82764: PUSH
82765: LD_VAR 0 21
82769: PPUSH
82770: LD_VAR 0 4
82774: PPUSH
82775: CALL_OW 74
82779: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
82780: LD_ADDR_VAR 0 7
82784: PUSH
82785: LD_EXP 178
82789: PUSH
82790: LD_VAR 0 1
82794: ARRAY
82795: PPUSH
82796: LD_INT 2
82798: PUSH
82799: LD_INT 30
82801: PUSH
82802: LD_INT 0
82804: PUSH
82805: EMPTY
82806: LIST
82807: LIST
82808: PUSH
82809: LD_INT 30
82811: PUSH
82812: LD_INT 1
82814: PUSH
82815: EMPTY
82816: LIST
82817: LIST
82818: PUSH
82819: EMPTY
82820: LIST
82821: LIST
82822: LIST
82823: PPUSH
82824: CALL_OW 72
82828: ST_TO_ADDR
// depot_under_attack := ( not depot or UnitFilter ( depot , [ f_not , [ f_lives , 600 ] ] ) ) ;
82829: LD_ADDR_VAR 0 16
82833: PUSH
82834: LD_VAR 0 7
82838: NOT
82839: PUSH
82840: LD_VAR 0 7
82844: PPUSH
82845: LD_INT 3
82847: PUSH
82848: LD_INT 24
82850: PUSH
82851: LD_INT 600
82853: PUSH
82854: EMPTY
82855: LIST
82856: LIST
82857: PUSH
82858: EMPTY
82859: LIST
82860: LIST
82861: PPUSH
82862: CALL_OW 72
82866: OR
82867: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
82868: LD_VAR 0 4
82872: PPUSH
82873: CALL_OW 247
82877: PUSH
82878: LD_INT 2
82880: DOUBLE
82881: EQUAL
82882: IFTRUE 82886
82884: GO 83282
82886: POP
// begin if GetLives ( i ) = 1000 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
82887: LD_VAR 0 4
82891: PPUSH
82892: CALL_OW 256
82896: PUSH
82897: LD_INT 1000
82899: EQUAL
82900: PUSH
82901: LD_VAR 0 4
82905: PPUSH
82906: LD_VAR 0 13
82910: PPUSH
82911: CALL_OW 296
82915: PUSH
82916: LD_INT 40
82918: LESS
82919: PUSH
82920: LD_VAR 0 13
82924: PPUSH
82925: LD_EXP 203
82929: PUSH
82930: LD_VAR 0 1
82934: ARRAY
82935: PPUSH
82936: CALL_OW 308
82940: OR
82941: AND
82942: IFFALSE 83064
// begin if GetEngine ( i ) = engine_combustion and GetFuel ( i ) < 30 and depot then
82944: LD_VAR 0 4
82948: PPUSH
82949: CALL_OW 262
82953: PUSH
82954: LD_INT 1
82956: EQUAL
82957: PUSH
82958: LD_VAR 0 4
82962: PPUSH
82963: CALL_OW 261
82967: PUSH
82968: LD_INT 30
82970: LESS
82971: AND
82972: PUSH
82973: LD_VAR 0 7
82977: AND
82978: IFFALSE 83048
// begin ComMoveUnit ( i , NearestUnitToUnit ( depot , i ) ) ;
82980: LD_VAR 0 4
82984: PPUSH
82985: LD_VAR 0 7
82989: PPUSH
82990: LD_VAR 0 4
82994: PPUSH
82995: CALL_OW 74
82999: PPUSH
83000: CALL_OW 112
// if GetDistUnits ( i , NearestUnitToUnit ( depot , i ) ) < 6 then
83004: LD_VAR 0 4
83008: PPUSH
83009: LD_VAR 0 7
83013: PPUSH
83014: LD_VAR 0 4
83018: PPUSH
83019: CALL_OW 74
83023: PPUSH
83024: CALL_OW 296
83028: PUSH
83029: LD_INT 6
83031: LESS
83032: IFFALSE 83046
// SetFuel ( i , 100 ) ;
83034: LD_VAR 0 4
83038: PPUSH
83039: LD_INT 100
83041: PPUSH
83042: CALL_OW 240
// end else
83046: GO 83062
// ComAttackUnit ( i , e ) ;
83048: LD_VAR 0 4
83052: PPUSH
83053: LD_VAR 0 13
83057: PPUSH
83058: CALL_OW 115
// end else
83062: GO 83165
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
83064: LD_VAR 0 13
83068: PPUSH
83069: LD_EXP 203
83073: PUSH
83074: LD_VAR 0 1
83078: ARRAY
83079: PPUSH
83080: CALL_OW 308
83084: NOT
83085: PUSH
83086: LD_VAR 0 4
83090: PPUSH
83091: LD_VAR 0 13
83095: PPUSH
83096: CALL_OW 296
83100: PUSH
83101: LD_INT 40
83103: GREATEREQUAL
83104: AND
83105: PUSH
83106: LD_VAR 0 4
83110: PPUSH
83111: CALL_OW 256
83115: PUSH
83116: LD_INT 650
83118: LESSEQUAL
83119: OR
83120: PUSH
83121: LD_VAR 0 4
83125: PPUSH
83126: LD_EXP 202
83130: PUSH
83131: LD_VAR 0 1
83135: ARRAY
83136: PPUSH
83137: CALL_OW 308
83141: NOT
83142: AND
83143: IFFALSE 83165
// ComMoveToArea ( i , mc_parking [ base ] ) ;
83145: LD_VAR 0 4
83149: PPUSH
83150: LD_EXP 202
83154: PUSH
83155: LD_VAR 0 1
83159: ARRAY
83160: PPUSH
83161: CALL_OW 113
// if GetLives ( i ) < 1000 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
83165: LD_VAR 0 4
83169: PPUSH
83170: CALL_OW 256
83174: PUSH
83175: LD_INT 1000
83177: LESS
83178: PUSH
83179: LD_VAR 0 4
83183: PPUSH
83184: CALL_OW 263
83188: PUSH
83189: LD_INT 1
83191: EQUAL
83192: AND
83193: PUSH
83194: LD_VAR 0 4
83198: PPUSH
83199: CALL_OW 311
83203: AND
83204: PUSH
83205: LD_VAR 0 4
83209: PPUSH
83210: LD_EXP 202
83214: PUSH
83215: LD_VAR 0 1
83219: ARRAY
83220: PPUSH
83221: CALL_OW 308
83225: AND
83226: IFFALSE 83280
// begin mech := IsDrivenBy ( i ) ;
83228: LD_ADDR_VAR 0 9
83232: PUSH
83233: LD_VAR 0 4
83237: PPUSH
83238: CALL_OW 311
83242: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
83243: LD_VAR 0 9
83247: PPUSH
83248: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
83252: LD_VAR 0 9
83256: PPUSH
83257: LD_VAR 0 4
83261: PPUSH
83262: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
83266: LD_VAR 0 9
83270: PPUSH
83271: LD_VAR 0 4
83275: PPUSH
83276: CALL_OW 180
// end ; end ; unit_human :
83280: GO 83627
83282: LD_INT 1
83284: DOUBLE
83285: EQUAL
83286: IFTRUE 83290
83288: GO 83626
83290: POP
// begin b := IsInUnit ( i ) ;
83291: LD_ADDR_VAR 0 18
83295: PUSH
83296: LD_VAR 0 4
83300: PPUSH
83301: CALL_OW 310
83305: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
83306: LD_ADDR_VAR 0 19
83310: PUSH
83311: LD_VAR 0 18
83315: NOT
83316: PUSH
83317: LD_VAR 0 18
83321: PPUSH
83322: CALL_OW 266
83326: PUSH
83327: LD_INT 32
83329: PUSH
83330: LD_INT 31
83332: PUSH
83333: EMPTY
83334: LIST
83335: LIST
83336: IN
83337: OR
83338: ST_TO_ADDR
// if GetBType ( b ) = b_barracks and GetClass ( i ) in [ 1 , 2 , 3 , 4 ] then
83339: LD_VAR 0 18
83343: PPUSH
83344: CALL_OW 266
83348: PUSH
83349: LD_INT 5
83351: EQUAL
83352: PUSH
83353: LD_VAR 0 4
83357: PPUSH
83358: CALL_OW 257
83362: PUSH
83363: LD_INT 1
83365: PUSH
83366: LD_INT 2
83368: PUSH
83369: LD_INT 3
83371: PUSH
83372: LD_INT 4
83374: PUSH
83375: EMPTY
83376: LIST
83377: LIST
83378: LIST
83379: LIST
83380: IN
83381: AND
83382: IFFALSE 83419
// begin class := AllowSpecClass ( i ) ;
83384: LD_ADDR_VAR 0 20
83388: PUSH
83389: LD_VAR 0 4
83393: PPUSH
83394: CALL 21010 0 1
83398: ST_TO_ADDR
// if class then
83399: LD_VAR 0 20
83403: IFFALSE 83419
// ComChangeProfession ( i , class ) ;
83405: LD_VAR 0 4
83409: PPUSH
83410: LD_VAR 0 20
83414: PPUSH
83415: CALL_OW 123
// end ; if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
83419: LD_VAR 0 16
83423: PUSH
83424: LD_VAR 0 2
83428: PPUSH
83429: LD_INT 21
83431: PUSH
83432: LD_INT 2
83434: PUSH
83435: EMPTY
83436: LIST
83437: LIST
83438: PPUSH
83439: CALL_OW 72
83443: PUSH
83444: LD_INT 1
83446: LESSEQUAL
83447: OR
83448: PUSH
83449: LD_VAR 0 19
83453: AND
83454: PUSH
83455: LD_VAR 0 4
83459: PUSH
83460: LD_VAR 0 17
83464: IN
83465: NOT
83466: AND
83467: IFFALSE 83560
// begin if b then
83469: LD_VAR 0 18
83473: IFFALSE 83522
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
83475: LD_VAR 0 18
83479: PPUSH
83480: LD_VAR 0 21
83484: PPUSH
83485: LD_VAR 0 18
83489: PPUSH
83490: CALL_OW 74
83494: PPUSH
83495: CALL_OW 296
83499: PUSH
83500: LD_INT 10
83502: LESS
83503: PUSH
83504: LD_VAR 0 18
83508: PPUSH
83509: CALL_OW 461
83513: PUSH
83514: LD_INT 7
83516: NONEQUAL
83517: AND
83518: IFFALSE 83522
// continue ;
83520: GO 82757
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
83522: LD_ADDR_VAR 0 17
83526: PUSH
83527: LD_VAR 0 17
83531: PPUSH
83532: LD_VAR 0 17
83536: PUSH
83537: LD_INT 1
83539: PLUS
83540: PPUSH
83541: LD_VAR 0 4
83545: PPUSH
83546: CALL_OW 1
83550: ST_TO_ADDR
// ComExitBuilding ( i ) ;
83551: LD_VAR 0 4
83555: PPUSH
83556: CALL_OW 122
// end ; if sold_defenders then
83560: LD_VAR 0 17
83564: IFFALSE 83624
// if i in sold_defenders then
83566: LD_VAR 0 4
83570: PUSH
83571: LD_VAR 0 17
83575: IN
83576: IFFALSE 83624
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
83578: LD_VAR 0 4
83582: PPUSH
83583: CALL_OW 314
83587: NOT
83588: PUSH
83589: LD_VAR 0 4
83593: PPUSH
83594: LD_VAR 0 13
83598: PPUSH
83599: CALL_OW 296
83603: PUSH
83604: LD_INT 30
83606: LESS
83607: AND
83608: IFFALSE 83624
// ComAttackUnit ( i , e ) ;
83610: LD_VAR 0 4
83614: PPUSH
83615: LD_VAR 0 13
83619: PPUSH
83620: CALL_OW 115
// end ; end ; end ;
83624: GO 83627
83626: POP
// if IsDead ( i ) then
83627: LD_VAR 0 4
83631: PPUSH
83632: CALL_OW 301
83636: IFFALSE 83654
// defenders := defenders diff i ;
83638: LD_ADDR_VAR 0 2
83642: PUSH
83643: LD_VAR 0 2
83647: PUSH
83648: LD_VAR 0 4
83652: DIFF
83653: ST_TO_ADDR
// end ;
83654: GO 82757
83656: POP
83657: POP
// until not enemy or not defenders or not mc_bases [ base ] ;
83658: LD_VAR 0 21
83662: NOT
83663: PUSH
83664: LD_VAR 0 2
83668: NOT
83669: OR
83670: PUSH
83671: LD_EXP 178
83675: PUSH
83676: LD_VAR 0 1
83680: ARRAY
83681: NOT
83682: OR
83683: IFFALSE 82661
// MC_Reset ( base , 18 ) ;
83685: LD_VAR 0 1
83689: PPUSH
83690: LD_INT 18
83692: PPUSH
83693: CALL 88355 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
83697: LD_ADDR_VAR 0 2
83701: PUSH
83702: LD_VAR 0 2
83706: PUSH
83707: LD_VAR 0 2
83711: PPUSH
83712: LD_INT 2
83714: PUSH
83715: LD_INT 25
83717: PUSH
83718: LD_INT 1
83720: PUSH
83721: EMPTY
83722: LIST
83723: LIST
83724: PUSH
83725: LD_INT 25
83727: PUSH
83728: LD_INT 5
83730: PUSH
83731: EMPTY
83732: LIST
83733: LIST
83734: PUSH
83735: LD_INT 25
83737: PUSH
83738: LD_INT 8
83740: PUSH
83741: EMPTY
83742: LIST
83743: LIST
83744: PUSH
83745: LD_INT 25
83747: PUSH
83748: LD_INT 9
83750: PUSH
83751: EMPTY
83752: LIST
83753: LIST
83754: PUSH
83755: EMPTY
83756: LIST
83757: LIST
83758: LIST
83759: LIST
83760: LIST
83761: PPUSH
83762: CALL_OW 72
83766: DIFF
83767: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
83768: LD_VAR 0 21
83772: NOT
83773: PUSH
83774: LD_VAR 0 2
83778: PPUSH
83779: LD_INT 21
83781: PUSH
83782: LD_INT 2
83784: PUSH
83785: EMPTY
83786: LIST
83787: LIST
83788: PPUSH
83789: CALL_OW 72
83793: AND
83794: IFFALSE 84132
// begin tmp := FilterByTag ( defenders , 19 ) ;
83796: LD_ADDR_VAR 0 11
83800: PUSH
83801: LD_VAR 0 2
83805: PPUSH
83806: LD_INT 19
83808: PPUSH
83809: CALL 53479 0 2
83813: ST_TO_ADDR
// if tmp then
83814: LD_VAR 0 11
83818: IFFALSE 83888
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
83820: LD_ADDR_VAR 0 11
83824: PUSH
83825: LD_VAR 0 11
83829: PPUSH
83830: LD_INT 25
83832: PUSH
83833: LD_INT 3
83835: PUSH
83836: EMPTY
83837: LIST
83838: LIST
83839: PPUSH
83840: CALL_OW 72
83844: ST_TO_ADDR
// if tmp then
83845: LD_VAR 0 11
83849: IFFALSE 83888
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
83851: LD_ADDR_EXP 190
83855: PUSH
83856: LD_EXP 190
83860: PPUSH
83861: LD_VAR 0 1
83865: PPUSH
83866: LD_EXP 190
83870: PUSH
83871: LD_VAR 0 1
83875: ARRAY
83876: PUSH
83877: LD_VAR 0 11
83881: UNION
83882: PPUSH
83883: CALL_OW 1
83887: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
83888: LD_VAR 0 1
83892: PPUSH
83893: LD_INT 19
83895: PPUSH
83896: CALL 88355 0 2
// repeat wait ( 0 0$1 ) ;
83900: LD_INT 35
83902: PPUSH
83903: CALL_OW 67
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
83907: LD_EXP 178
83911: PUSH
83912: LD_VAR 0 1
83916: ARRAY
83917: NOT
83918: PUSH
83919: LD_EXP 178
83923: PUSH
83924: LD_VAR 0 1
83928: ARRAY
83929: PUSH
83930: EMPTY
83931: EQUAL
83932: OR
83933: IFFALSE 83970
// begin for i in defenders do
83935: LD_ADDR_VAR 0 4
83939: PUSH
83940: LD_VAR 0 2
83944: PUSH
83945: FOR_IN
83946: IFFALSE 83959
// ComStop ( i ) ;
83948: LD_VAR 0 4
83952: PPUSH
83953: CALL_OW 141
83957: GO 83945
83959: POP
83960: POP
// defenders := [ ] ;
83961: LD_ADDR_VAR 0 2
83965: PUSH
83966: EMPTY
83967: ST_TO_ADDR
// exit ;
83968: GO 84196
// end ; for i in defenders do
83970: LD_ADDR_VAR 0 4
83974: PUSH
83975: LD_VAR 0 2
83979: PUSH
83980: FOR_IN
83981: IFFALSE 84070
// begin if not IsInArea ( i , mc_parking [ base ] ) then
83983: LD_VAR 0 4
83987: PPUSH
83988: LD_EXP 202
83992: PUSH
83993: LD_VAR 0 1
83997: ARRAY
83998: PPUSH
83999: CALL_OW 308
84003: NOT
84004: IFFALSE 84028
// ComMoveToArea ( i , mc_parking [ base ] ) else
84006: LD_VAR 0 4
84010: PPUSH
84011: LD_EXP 202
84015: PUSH
84016: LD_VAR 0 1
84020: ARRAY
84021: PPUSH
84022: CALL_OW 113
84026: GO 84068
// if GetControl ( i ) = control_manual then
84028: LD_VAR 0 4
84032: PPUSH
84033: CALL_OW 263
84037: PUSH
84038: LD_INT 1
84040: EQUAL
84041: IFFALSE 84068
// if IsDrivenBy ( i ) then
84043: LD_VAR 0 4
84047: PPUSH
84048: CALL_OW 311
84052: IFFALSE 84068
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
84054: LD_VAR 0 4
84058: PPUSH
84059: CALL_OW 311
84063: PPUSH
84064: CALL_OW 121
// end ;
84068: GO 83980
84070: POP
84071: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] or not mc_bases [ base ] ;
84072: LD_VAR 0 2
84076: PPUSH
84077: LD_INT 95
84079: PUSH
84080: LD_EXP 202
84084: PUSH
84085: LD_VAR 0 1
84089: ARRAY
84090: PUSH
84091: EMPTY
84092: LIST
84093: LIST
84094: PPUSH
84095: CALL_OW 72
84099: PUSH
84100: LD_VAR 0 2
84104: EQUAL
84105: PUSH
84106: LD_EXP 201
84110: PUSH
84111: LD_VAR 0 1
84115: ARRAY
84116: OR
84117: PUSH
84118: LD_EXP 178
84122: PUSH
84123: LD_VAR 0 1
84127: ARRAY
84128: NOT
84129: OR
84130: IFFALSE 83900
// end ; mc_defender := Replace ( mc_defender , base , UnitFilter ( defenders , [ f_type , unit_vehicle ] ) ) ;
84132: LD_ADDR_EXP 200
84136: PUSH
84137: LD_EXP 200
84141: PPUSH
84142: LD_VAR 0 1
84146: PPUSH
84147: LD_VAR 0 2
84151: PPUSH
84152: LD_INT 21
84154: PUSH
84155: LD_INT 2
84157: PUSH
84158: EMPTY
84159: LIST
84160: LIST
84161: PPUSH
84162: CALL_OW 72
84166: PPUSH
84167: CALL_OW 1
84171: ST_TO_ADDR
// MC_Reset ( base , 19 ) ;
84172: LD_VAR 0 1
84176: PPUSH
84177: LD_INT 19
84179: PPUSH
84180: CALL 88355 0 2
// MC_Reset ( base , 20 ) ;
84184: LD_VAR 0 1
84188: PPUSH
84189: LD_INT 20
84191: PPUSH
84192: CALL 88355 0 2
// end ; end_of_file
84196: LD_VAR 0 3
84200: RET
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use , mc_is_defending ; export function InitMacro ; var i ; begin
84201: LD_INT 0
84203: PPUSH
84204: PPUSH
// skirmish := false ;
84205: LD_ADDR_EXP 176
84209: PUSH
84210: LD_INT 0
84212: ST_TO_ADDR
// debug_mc := false ;
84213: LD_ADDR_EXP 177
84217: PUSH
84218: LD_INT 0
84220: ST_TO_ADDR
// mc_bases := [ ] ;
84221: LD_ADDR_EXP 178
84225: PUSH
84226: EMPTY
84227: ST_TO_ADDR
// mc_sides := [ ] ;
84228: LD_ADDR_EXP 204
84232: PUSH
84233: EMPTY
84234: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
84235: LD_ADDR_EXP 179
84239: PUSH
84240: EMPTY
84241: ST_TO_ADDR
// mc_building_repairs := [ ] ;
84242: LD_ADDR_EXP 180
84246: PUSH
84247: EMPTY
84248: ST_TO_ADDR
// mc_need_heal := [ ] ;
84249: LD_ADDR_EXP 181
84253: PUSH
84254: EMPTY
84255: ST_TO_ADDR
// mc_healers := [ ] ;
84256: LD_ADDR_EXP 182
84260: PUSH
84261: EMPTY
84262: ST_TO_ADDR
// mc_build_list := [ ] ;
84263: LD_ADDR_EXP 183
84267: PUSH
84268: EMPTY
84269: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
84270: LD_ADDR_EXP 210
84274: PUSH
84275: EMPTY
84276: ST_TO_ADDR
// mc_builders := [ ] ;
84277: LD_ADDR_EXP 184
84281: PUSH
84282: EMPTY
84283: ST_TO_ADDR
// mc_construct_list := [ ] ;
84284: LD_ADDR_EXP 185
84288: PUSH
84289: EMPTY
84290: ST_TO_ADDR
// mc_turret_list := [ ] ;
84291: LD_ADDR_EXP 186
84295: PUSH
84296: EMPTY
84297: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
84298: LD_ADDR_EXP 187
84302: PUSH
84303: EMPTY
84304: ST_TO_ADDR
// mc_miners := [ ] ;
84305: LD_ADDR_EXP 192
84309: PUSH
84310: EMPTY
84311: ST_TO_ADDR
// mc_mines := [ ] ;
84312: LD_ADDR_EXP 191
84316: PUSH
84317: EMPTY
84318: ST_TO_ADDR
// mc_minefields := [ ] ;
84319: LD_ADDR_EXP 193
84323: PUSH
84324: EMPTY
84325: ST_TO_ADDR
// mc_crates := [ ] ;
84326: LD_ADDR_EXP 194
84330: PUSH
84331: EMPTY
84332: ST_TO_ADDR
// mc_crates_collector := [ ] ;
84333: LD_ADDR_EXP 195
84337: PUSH
84338: EMPTY
84339: ST_TO_ADDR
// mc_crates_area := [ ] ;
84340: LD_ADDR_EXP 196
84344: PUSH
84345: EMPTY
84346: ST_TO_ADDR
// mc_vehicles := [ ] ;
84347: LD_ADDR_EXP 197
84351: PUSH
84352: EMPTY
84353: ST_TO_ADDR
// mc_attack := [ ] ;
84354: LD_ADDR_EXP 198
84358: PUSH
84359: EMPTY
84360: ST_TO_ADDR
// mc_produce := [ ] ;
84361: LD_ADDR_EXP 199
84365: PUSH
84366: EMPTY
84367: ST_TO_ADDR
// mc_defender := [ ] ;
84368: LD_ADDR_EXP 200
84372: PUSH
84373: EMPTY
84374: ST_TO_ADDR
// mc_parking := [ ] ;
84375: LD_ADDR_EXP 202
84379: PUSH
84380: EMPTY
84381: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
84382: LD_ADDR_EXP 188
84386: PUSH
84387: EMPTY
84388: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
84389: LD_ADDR_EXP 190
84393: PUSH
84394: EMPTY
84395: ST_TO_ADDR
// mc_scan := [ ] ;
84396: LD_ADDR_EXP 201
84400: PUSH
84401: EMPTY
84402: ST_TO_ADDR
// mc_scan_area := [ ] ;
84403: LD_ADDR_EXP 203
84407: PUSH
84408: EMPTY
84409: ST_TO_ADDR
// mc_tech := [ ] ;
84410: LD_ADDR_EXP 205
84414: PUSH
84415: EMPTY
84416: ST_TO_ADDR
// mc_class := [ ] ;
84417: LD_ADDR_EXP 219
84421: PUSH
84422: EMPTY
84423: ST_TO_ADDR
// mc_class_case_use := [ ] ;
84424: LD_ADDR_EXP 220
84428: PUSH
84429: EMPTY
84430: ST_TO_ADDR
// mc_is_defending := [ ] ;
84431: LD_ADDR_EXP 221
84435: PUSH
84436: EMPTY
84437: ST_TO_ADDR
// end ;
84438: LD_VAR 0 1
84442: RET
// export function MC_Kill ( base ) ; begin
84443: LD_INT 0
84445: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
84446: LD_ADDR_EXP 178
84450: PUSH
84451: LD_EXP 178
84455: PPUSH
84456: LD_VAR 0 1
84460: PPUSH
84461: EMPTY
84462: PPUSH
84463: CALL_OW 1
84467: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
84468: LD_ADDR_EXP 179
84472: PUSH
84473: LD_EXP 179
84477: PPUSH
84478: LD_VAR 0 1
84482: PPUSH
84483: EMPTY
84484: PPUSH
84485: CALL_OW 1
84489: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
84490: LD_ADDR_EXP 180
84494: PUSH
84495: LD_EXP 180
84499: PPUSH
84500: LD_VAR 0 1
84504: PPUSH
84505: EMPTY
84506: PPUSH
84507: CALL_OW 1
84511: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
84512: LD_ADDR_EXP 181
84516: PUSH
84517: LD_EXP 181
84521: PPUSH
84522: LD_VAR 0 1
84526: PPUSH
84527: EMPTY
84528: PPUSH
84529: CALL_OW 1
84533: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
84534: LD_ADDR_EXP 182
84538: PUSH
84539: LD_EXP 182
84543: PPUSH
84544: LD_VAR 0 1
84548: PPUSH
84549: EMPTY
84550: PPUSH
84551: CALL_OW 1
84555: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
84556: LD_ADDR_EXP 183
84560: PUSH
84561: LD_EXP 183
84565: PPUSH
84566: LD_VAR 0 1
84570: PPUSH
84571: EMPTY
84572: PPUSH
84573: CALL_OW 1
84577: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
84578: LD_ADDR_EXP 184
84582: PUSH
84583: LD_EXP 184
84587: PPUSH
84588: LD_VAR 0 1
84592: PPUSH
84593: EMPTY
84594: PPUSH
84595: CALL_OW 1
84599: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
84600: LD_ADDR_EXP 185
84604: PUSH
84605: LD_EXP 185
84609: PPUSH
84610: LD_VAR 0 1
84614: PPUSH
84615: EMPTY
84616: PPUSH
84617: CALL_OW 1
84621: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
84622: LD_ADDR_EXP 186
84626: PUSH
84627: LD_EXP 186
84631: PPUSH
84632: LD_VAR 0 1
84636: PPUSH
84637: EMPTY
84638: PPUSH
84639: CALL_OW 1
84643: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
84644: LD_ADDR_EXP 187
84648: PUSH
84649: LD_EXP 187
84653: PPUSH
84654: LD_VAR 0 1
84658: PPUSH
84659: EMPTY
84660: PPUSH
84661: CALL_OW 1
84665: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
84666: LD_ADDR_EXP 188
84670: PUSH
84671: LD_EXP 188
84675: PPUSH
84676: LD_VAR 0 1
84680: PPUSH
84681: EMPTY
84682: PPUSH
84683: CALL_OW 1
84687: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
84688: LD_ADDR_EXP 189
84692: PUSH
84693: LD_EXP 189
84697: PPUSH
84698: LD_VAR 0 1
84702: PPUSH
84703: LD_INT 0
84705: PPUSH
84706: CALL_OW 1
84710: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
84711: LD_ADDR_EXP 190
84715: PUSH
84716: LD_EXP 190
84720: PPUSH
84721: LD_VAR 0 1
84725: PPUSH
84726: EMPTY
84727: PPUSH
84728: CALL_OW 1
84732: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
84733: LD_ADDR_EXP 191
84737: PUSH
84738: LD_EXP 191
84742: PPUSH
84743: LD_VAR 0 1
84747: PPUSH
84748: EMPTY
84749: PPUSH
84750: CALL_OW 1
84754: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
84755: LD_ADDR_EXP 192
84759: PUSH
84760: LD_EXP 192
84764: PPUSH
84765: LD_VAR 0 1
84769: PPUSH
84770: EMPTY
84771: PPUSH
84772: CALL_OW 1
84776: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
84777: LD_ADDR_EXP 193
84781: PUSH
84782: LD_EXP 193
84786: PPUSH
84787: LD_VAR 0 1
84791: PPUSH
84792: EMPTY
84793: PPUSH
84794: CALL_OW 1
84798: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
84799: LD_ADDR_EXP 194
84803: PUSH
84804: LD_EXP 194
84808: PPUSH
84809: LD_VAR 0 1
84813: PPUSH
84814: EMPTY
84815: PPUSH
84816: CALL_OW 1
84820: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
84821: LD_ADDR_EXP 195
84825: PUSH
84826: LD_EXP 195
84830: PPUSH
84831: LD_VAR 0 1
84835: PPUSH
84836: EMPTY
84837: PPUSH
84838: CALL_OW 1
84842: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
84843: LD_ADDR_EXP 196
84847: PUSH
84848: LD_EXP 196
84852: PPUSH
84853: LD_VAR 0 1
84857: PPUSH
84858: EMPTY
84859: PPUSH
84860: CALL_OW 1
84864: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
84865: LD_ADDR_EXP 197
84869: PUSH
84870: LD_EXP 197
84874: PPUSH
84875: LD_VAR 0 1
84879: PPUSH
84880: EMPTY
84881: PPUSH
84882: CALL_OW 1
84886: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
84887: LD_ADDR_EXP 198
84891: PUSH
84892: LD_EXP 198
84896: PPUSH
84897: LD_VAR 0 1
84901: PPUSH
84902: EMPTY
84903: PPUSH
84904: CALL_OW 1
84908: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
84909: LD_ADDR_EXP 199
84913: PUSH
84914: LD_EXP 199
84918: PPUSH
84919: LD_VAR 0 1
84923: PPUSH
84924: EMPTY
84925: PPUSH
84926: CALL_OW 1
84930: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
84931: LD_ADDR_EXP 200
84935: PUSH
84936: LD_EXP 200
84940: PPUSH
84941: LD_VAR 0 1
84945: PPUSH
84946: EMPTY
84947: PPUSH
84948: CALL_OW 1
84952: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
84953: LD_ADDR_EXP 201
84957: PUSH
84958: LD_EXP 201
84962: PPUSH
84963: LD_VAR 0 1
84967: PPUSH
84968: EMPTY
84969: PPUSH
84970: CALL_OW 1
84974: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
84975: LD_ADDR_EXP 202
84979: PUSH
84980: LD_EXP 202
84984: PPUSH
84985: LD_VAR 0 1
84989: PPUSH
84990: EMPTY
84991: PPUSH
84992: CALL_OW 1
84996: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
84997: LD_ADDR_EXP 203
85001: PUSH
85002: LD_EXP 203
85006: PPUSH
85007: LD_VAR 0 1
85011: PPUSH
85012: EMPTY
85013: PPUSH
85014: CALL_OW 1
85018: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
85019: LD_ADDR_EXP 205
85023: PUSH
85024: LD_EXP 205
85028: PPUSH
85029: LD_VAR 0 1
85033: PPUSH
85034: EMPTY
85035: PPUSH
85036: CALL_OW 1
85040: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
85041: LD_ADDR_EXP 207
85045: PUSH
85046: LD_EXP 207
85050: PPUSH
85051: LD_VAR 0 1
85055: PPUSH
85056: EMPTY
85057: PPUSH
85058: CALL_OW 1
85062: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
85063: LD_ADDR_EXP 208
85067: PUSH
85068: LD_EXP 208
85072: PPUSH
85073: LD_VAR 0 1
85077: PPUSH
85078: EMPTY
85079: PPUSH
85080: CALL_OW 1
85084: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
85085: LD_ADDR_EXP 209
85089: PUSH
85090: LD_EXP 209
85094: PPUSH
85095: LD_VAR 0 1
85099: PPUSH
85100: EMPTY
85101: PPUSH
85102: CALL_OW 1
85106: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
85107: LD_ADDR_EXP 210
85111: PUSH
85112: LD_EXP 210
85116: PPUSH
85117: LD_VAR 0 1
85121: PPUSH
85122: EMPTY
85123: PPUSH
85124: CALL_OW 1
85128: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
85129: LD_ADDR_EXP 211
85133: PUSH
85134: LD_EXP 211
85138: PPUSH
85139: LD_VAR 0 1
85143: PPUSH
85144: EMPTY
85145: PPUSH
85146: CALL_OW 1
85150: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
85151: LD_ADDR_EXP 212
85155: PUSH
85156: LD_EXP 212
85160: PPUSH
85161: LD_VAR 0 1
85165: PPUSH
85166: EMPTY
85167: PPUSH
85168: CALL_OW 1
85172: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
85173: LD_ADDR_EXP 213
85177: PUSH
85178: LD_EXP 213
85182: PPUSH
85183: LD_VAR 0 1
85187: PPUSH
85188: EMPTY
85189: PPUSH
85190: CALL_OW 1
85194: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
85195: LD_ADDR_EXP 214
85199: PUSH
85200: LD_EXP 214
85204: PPUSH
85205: LD_VAR 0 1
85209: PPUSH
85210: EMPTY
85211: PPUSH
85212: CALL_OW 1
85216: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
85217: LD_ADDR_EXP 215
85221: PUSH
85222: LD_EXP 215
85226: PPUSH
85227: LD_VAR 0 1
85231: PPUSH
85232: EMPTY
85233: PPUSH
85234: CALL_OW 1
85238: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
85239: LD_ADDR_EXP 216
85243: PUSH
85244: LD_EXP 216
85248: PPUSH
85249: LD_VAR 0 1
85253: PPUSH
85254: EMPTY
85255: PPUSH
85256: CALL_OW 1
85260: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
85261: LD_ADDR_EXP 217
85265: PUSH
85266: LD_EXP 217
85270: PPUSH
85271: LD_VAR 0 1
85275: PPUSH
85276: EMPTY
85277: PPUSH
85278: CALL_OW 1
85282: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
85283: LD_ADDR_EXP 218
85287: PUSH
85288: LD_EXP 218
85292: PPUSH
85293: LD_VAR 0 1
85297: PPUSH
85298: EMPTY
85299: PPUSH
85300: CALL_OW 1
85304: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
85305: LD_ADDR_EXP 219
85309: PUSH
85310: LD_EXP 219
85314: PPUSH
85315: LD_VAR 0 1
85319: PPUSH
85320: EMPTY
85321: PPUSH
85322: CALL_OW 1
85326: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
85327: LD_ADDR_EXP 220
85331: PUSH
85332: LD_EXP 220
85336: PPUSH
85337: LD_VAR 0 1
85341: PPUSH
85342: LD_INT 0
85344: PPUSH
85345: CALL_OW 1
85349: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
85350: LD_ADDR_EXP 221
85354: PUSH
85355: LD_EXP 221
85359: PPUSH
85360: LD_VAR 0 1
85364: PPUSH
85365: LD_INT 0
85367: PPUSH
85368: CALL_OW 1
85372: ST_TO_ADDR
// end ;
85373: LD_VAR 0 2
85377: RET
// export function MC_Add ( side , units ) ; var base ; begin
85378: LD_INT 0
85380: PPUSH
85381: PPUSH
// base := mc_bases + 1 ;
85382: LD_ADDR_VAR 0 4
85386: PUSH
85387: LD_EXP 178
85391: PUSH
85392: LD_INT 1
85394: PLUS
85395: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
85396: LD_ADDR_EXP 204
85400: PUSH
85401: LD_EXP 204
85405: PPUSH
85406: LD_VAR 0 4
85410: PPUSH
85411: LD_VAR 0 1
85415: PPUSH
85416: CALL_OW 1
85420: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
85421: LD_ADDR_EXP 178
85425: PUSH
85426: LD_EXP 178
85430: PPUSH
85431: LD_VAR 0 4
85435: PPUSH
85436: LD_VAR 0 2
85440: PPUSH
85441: CALL_OW 1
85445: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
85446: LD_ADDR_EXP 179
85450: PUSH
85451: LD_EXP 179
85455: PPUSH
85456: LD_VAR 0 4
85460: PPUSH
85461: EMPTY
85462: PPUSH
85463: CALL_OW 1
85467: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
85468: LD_ADDR_EXP 180
85472: PUSH
85473: LD_EXP 180
85477: PPUSH
85478: LD_VAR 0 4
85482: PPUSH
85483: EMPTY
85484: PPUSH
85485: CALL_OW 1
85489: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
85490: LD_ADDR_EXP 181
85494: PUSH
85495: LD_EXP 181
85499: PPUSH
85500: LD_VAR 0 4
85504: PPUSH
85505: EMPTY
85506: PPUSH
85507: CALL_OW 1
85511: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
85512: LD_ADDR_EXP 182
85516: PUSH
85517: LD_EXP 182
85521: PPUSH
85522: LD_VAR 0 4
85526: PPUSH
85527: EMPTY
85528: PPUSH
85529: CALL_OW 1
85533: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
85534: LD_ADDR_EXP 183
85538: PUSH
85539: LD_EXP 183
85543: PPUSH
85544: LD_VAR 0 4
85548: PPUSH
85549: EMPTY
85550: PPUSH
85551: CALL_OW 1
85555: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
85556: LD_ADDR_EXP 184
85560: PUSH
85561: LD_EXP 184
85565: PPUSH
85566: LD_VAR 0 4
85570: PPUSH
85571: EMPTY
85572: PPUSH
85573: CALL_OW 1
85577: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
85578: LD_ADDR_EXP 185
85582: PUSH
85583: LD_EXP 185
85587: PPUSH
85588: LD_VAR 0 4
85592: PPUSH
85593: EMPTY
85594: PPUSH
85595: CALL_OW 1
85599: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
85600: LD_ADDR_EXP 186
85604: PUSH
85605: LD_EXP 186
85609: PPUSH
85610: LD_VAR 0 4
85614: PPUSH
85615: EMPTY
85616: PPUSH
85617: CALL_OW 1
85621: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
85622: LD_ADDR_EXP 187
85626: PUSH
85627: LD_EXP 187
85631: PPUSH
85632: LD_VAR 0 4
85636: PPUSH
85637: EMPTY
85638: PPUSH
85639: CALL_OW 1
85643: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
85644: LD_ADDR_EXP 188
85648: PUSH
85649: LD_EXP 188
85653: PPUSH
85654: LD_VAR 0 4
85658: PPUSH
85659: EMPTY
85660: PPUSH
85661: CALL_OW 1
85665: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
85666: LD_ADDR_EXP 189
85670: PUSH
85671: LD_EXP 189
85675: PPUSH
85676: LD_VAR 0 4
85680: PPUSH
85681: LD_INT 0
85683: PPUSH
85684: CALL_OW 1
85688: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
85689: LD_ADDR_EXP 190
85693: PUSH
85694: LD_EXP 190
85698: PPUSH
85699: LD_VAR 0 4
85703: PPUSH
85704: EMPTY
85705: PPUSH
85706: CALL_OW 1
85710: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
85711: LD_ADDR_EXP 191
85715: PUSH
85716: LD_EXP 191
85720: PPUSH
85721: LD_VAR 0 4
85725: PPUSH
85726: EMPTY
85727: PPUSH
85728: CALL_OW 1
85732: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
85733: LD_ADDR_EXP 192
85737: PUSH
85738: LD_EXP 192
85742: PPUSH
85743: LD_VAR 0 4
85747: PPUSH
85748: EMPTY
85749: PPUSH
85750: CALL_OW 1
85754: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
85755: LD_ADDR_EXP 193
85759: PUSH
85760: LD_EXP 193
85764: PPUSH
85765: LD_VAR 0 4
85769: PPUSH
85770: EMPTY
85771: PPUSH
85772: CALL_OW 1
85776: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
85777: LD_ADDR_EXP 194
85781: PUSH
85782: LD_EXP 194
85786: PPUSH
85787: LD_VAR 0 4
85791: PPUSH
85792: EMPTY
85793: PPUSH
85794: CALL_OW 1
85798: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
85799: LD_ADDR_EXP 195
85803: PUSH
85804: LD_EXP 195
85808: PPUSH
85809: LD_VAR 0 4
85813: PPUSH
85814: EMPTY
85815: PPUSH
85816: CALL_OW 1
85820: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
85821: LD_ADDR_EXP 196
85825: PUSH
85826: LD_EXP 196
85830: PPUSH
85831: LD_VAR 0 4
85835: PPUSH
85836: EMPTY
85837: PPUSH
85838: CALL_OW 1
85842: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
85843: LD_ADDR_EXP 197
85847: PUSH
85848: LD_EXP 197
85852: PPUSH
85853: LD_VAR 0 4
85857: PPUSH
85858: EMPTY
85859: PPUSH
85860: CALL_OW 1
85864: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
85865: LD_ADDR_EXP 198
85869: PUSH
85870: LD_EXP 198
85874: PPUSH
85875: LD_VAR 0 4
85879: PPUSH
85880: EMPTY
85881: PPUSH
85882: CALL_OW 1
85886: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
85887: LD_ADDR_EXP 199
85891: PUSH
85892: LD_EXP 199
85896: PPUSH
85897: LD_VAR 0 4
85901: PPUSH
85902: EMPTY
85903: PPUSH
85904: CALL_OW 1
85908: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
85909: LD_ADDR_EXP 200
85913: PUSH
85914: LD_EXP 200
85918: PPUSH
85919: LD_VAR 0 4
85923: PPUSH
85924: EMPTY
85925: PPUSH
85926: CALL_OW 1
85930: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
85931: LD_ADDR_EXP 201
85935: PUSH
85936: LD_EXP 201
85940: PPUSH
85941: LD_VAR 0 4
85945: PPUSH
85946: EMPTY
85947: PPUSH
85948: CALL_OW 1
85952: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
85953: LD_ADDR_EXP 202
85957: PUSH
85958: LD_EXP 202
85962: PPUSH
85963: LD_VAR 0 4
85967: PPUSH
85968: EMPTY
85969: PPUSH
85970: CALL_OW 1
85974: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
85975: LD_ADDR_EXP 203
85979: PUSH
85980: LD_EXP 203
85984: PPUSH
85985: LD_VAR 0 4
85989: PPUSH
85990: EMPTY
85991: PPUSH
85992: CALL_OW 1
85996: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
85997: LD_ADDR_EXP 205
86001: PUSH
86002: LD_EXP 205
86006: PPUSH
86007: LD_VAR 0 4
86011: PPUSH
86012: EMPTY
86013: PPUSH
86014: CALL_OW 1
86018: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
86019: LD_ADDR_EXP 207
86023: PUSH
86024: LD_EXP 207
86028: PPUSH
86029: LD_VAR 0 4
86033: PPUSH
86034: EMPTY
86035: PPUSH
86036: CALL_OW 1
86040: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
86041: LD_ADDR_EXP 208
86045: PUSH
86046: LD_EXP 208
86050: PPUSH
86051: LD_VAR 0 4
86055: PPUSH
86056: EMPTY
86057: PPUSH
86058: CALL_OW 1
86062: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
86063: LD_ADDR_EXP 209
86067: PUSH
86068: LD_EXP 209
86072: PPUSH
86073: LD_VAR 0 4
86077: PPUSH
86078: EMPTY
86079: PPUSH
86080: CALL_OW 1
86084: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
86085: LD_ADDR_EXP 210
86089: PUSH
86090: LD_EXP 210
86094: PPUSH
86095: LD_VAR 0 4
86099: PPUSH
86100: EMPTY
86101: PPUSH
86102: CALL_OW 1
86106: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
86107: LD_ADDR_EXP 211
86111: PUSH
86112: LD_EXP 211
86116: PPUSH
86117: LD_VAR 0 4
86121: PPUSH
86122: EMPTY
86123: PPUSH
86124: CALL_OW 1
86128: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
86129: LD_ADDR_EXP 212
86133: PUSH
86134: LD_EXP 212
86138: PPUSH
86139: LD_VAR 0 4
86143: PPUSH
86144: EMPTY
86145: PPUSH
86146: CALL_OW 1
86150: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
86151: LD_ADDR_EXP 213
86155: PUSH
86156: LD_EXP 213
86160: PPUSH
86161: LD_VAR 0 4
86165: PPUSH
86166: EMPTY
86167: PPUSH
86168: CALL_OW 1
86172: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
86173: LD_ADDR_EXP 214
86177: PUSH
86178: LD_EXP 214
86182: PPUSH
86183: LD_VAR 0 4
86187: PPUSH
86188: EMPTY
86189: PPUSH
86190: CALL_OW 1
86194: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
86195: LD_ADDR_EXP 215
86199: PUSH
86200: LD_EXP 215
86204: PPUSH
86205: LD_VAR 0 4
86209: PPUSH
86210: EMPTY
86211: PPUSH
86212: CALL_OW 1
86216: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
86217: LD_ADDR_EXP 216
86221: PUSH
86222: LD_EXP 216
86226: PPUSH
86227: LD_VAR 0 4
86231: PPUSH
86232: EMPTY
86233: PPUSH
86234: CALL_OW 1
86238: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
86239: LD_ADDR_EXP 217
86243: PUSH
86244: LD_EXP 217
86248: PPUSH
86249: LD_VAR 0 4
86253: PPUSH
86254: EMPTY
86255: PPUSH
86256: CALL_OW 1
86260: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
86261: LD_ADDR_EXP 218
86265: PUSH
86266: LD_EXP 218
86270: PPUSH
86271: LD_VAR 0 4
86275: PPUSH
86276: EMPTY
86277: PPUSH
86278: CALL_OW 1
86282: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
86283: LD_ADDR_EXP 219
86287: PUSH
86288: LD_EXP 219
86292: PPUSH
86293: LD_VAR 0 4
86297: PPUSH
86298: EMPTY
86299: PPUSH
86300: CALL_OW 1
86304: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
86305: LD_ADDR_EXP 220
86309: PUSH
86310: LD_EXP 220
86314: PPUSH
86315: LD_VAR 0 4
86319: PPUSH
86320: LD_INT 0
86322: PPUSH
86323: CALL_OW 1
86327: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
86328: LD_ADDR_EXP 221
86332: PUSH
86333: LD_EXP 221
86337: PPUSH
86338: LD_VAR 0 4
86342: PPUSH
86343: LD_INT 0
86345: PPUSH
86346: CALL_OW 1
86350: ST_TO_ADDR
// result := base ;
86351: LD_ADDR_VAR 0 3
86355: PUSH
86356: LD_VAR 0 4
86360: ST_TO_ADDR
// end ;
86361: LD_VAR 0 3
86365: RET
// export function MC_Start ( ) ; var i ; begin
86366: LD_INT 0
86368: PPUSH
86369: PPUSH
// for i = 1 to mc_bases do
86370: LD_ADDR_VAR 0 2
86374: PUSH
86375: DOUBLE
86376: LD_INT 1
86378: DEC
86379: ST_TO_ADDR
86380: LD_EXP 178
86384: PUSH
86385: FOR_TO
86386: IFFALSE 87486
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
86388: LD_ADDR_EXP 178
86392: PUSH
86393: LD_EXP 178
86397: PPUSH
86398: LD_VAR 0 2
86402: PPUSH
86403: LD_EXP 178
86407: PUSH
86408: LD_VAR 0 2
86412: ARRAY
86413: PUSH
86414: LD_INT 0
86416: DIFF
86417: PPUSH
86418: CALL_OW 1
86422: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
86423: LD_ADDR_EXP 179
86427: PUSH
86428: LD_EXP 179
86432: PPUSH
86433: LD_VAR 0 2
86437: PPUSH
86438: EMPTY
86439: PPUSH
86440: CALL_OW 1
86444: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
86445: LD_ADDR_EXP 180
86449: PUSH
86450: LD_EXP 180
86454: PPUSH
86455: LD_VAR 0 2
86459: PPUSH
86460: EMPTY
86461: PPUSH
86462: CALL_OW 1
86466: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
86467: LD_ADDR_EXP 181
86471: PUSH
86472: LD_EXP 181
86476: PPUSH
86477: LD_VAR 0 2
86481: PPUSH
86482: EMPTY
86483: PPUSH
86484: CALL_OW 1
86488: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
86489: LD_ADDR_EXP 182
86493: PUSH
86494: LD_EXP 182
86498: PPUSH
86499: LD_VAR 0 2
86503: PPUSH
86504: EMPTY
86505: PUSH
86506: EMPTY
86507: PUSH
86508: EMPTY
86509: LIST
86510: LIST
86511: PPUSH
86512: CALL_OW 1
86516: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
86517: LD_ADDR_EXP 183
86521: PUSH
86522: LD_EXP 183
86526: PPUSH
86527: LD_VAR 0 2
86531: PPUSH
86532: EMPTY
86533: PPUSH
86534: CALL_OW 1
86538: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
86539: LD_ADDR_EXP 210
86543: PUSH
86544: LD_EXP 210
86548: PPUSH
86549: LD_VAR 0 2
86553: PPUSH
86554: EMPTY
86555: PPUSH
86556: CALL_OW 1
86560: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
86561: LD_ADDR_EXP 184
86565: PUSH
86566: LD_EXP 184
86570: PPUSH
86571: LD_VAR 0 2
86575: PPUSH
86576: EMPTY
86577: PPUSH
86578: CALL_OW 1
86582: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
86583: LD_ADDR_EXP 185
86587: PUSH
86588: LD_EXP 185
86592: PPUSH
86593: LD_VAR 0 2
86597: PPUSH
86598: EMPTY
86599: PPUSH
86600: CALL_OW 1
86604: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
86605: LD_ADDR_EXP 186
86609: PUSH
86610: LD_EXP 186
86614: PPUSH
86615: LD_VAR 0 2
86619: PPUSH
86620: LD_EXP 178
86624: PUSH
86625: LD_VAR 0 2
86629: ARRAY
86630: PPUSH
86631: LD_INT 2
86633: PUSH
86634: LD_INT 30
86636: PUSH
86637: LD_INT 32
86639: PUSH
86640: EMPTY
86641: LIST
86642: LIST
86643: PUSH
86644: LD_INT 30
86646: PUSH
86647: LD_INT 33
86649: PUSH
86650: EMPTY
86651: LIST
86652: LIST
86653: PUSH
86654: EMPTY
86655: LIST
86656: LIST
86657: LIST
86658: PPUSH
86659: CALL_OW 72
86663: PPUSH
86664: CALL_OW 1
86668: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
86669: LD_ADDR_EXP 187
86673: PUSH
86674: LD_EXP 187
86678: PPUSH
86679: LD_VAR 0 2
86683: PPUSH
86684: LD_EXP 178
86688: PUSH
86689: LD_VAR 0 2
86693: ARRAY
86694: PPUSH
86695: LD_INT 2
86697: PUSH
86698: LD_INT 30
86700: PUSH
86701: LD_INT 32
86703: PUSH
86704: EMPTY
86705: LIST
86706: LIST
86707: PUSH
86708: LD_INT 30
86710: PUSH
86711: LD_INT 31
86713: PUSH
86714: EMPTY
86715: LIST
86716: LIST
86717: PUSH
86718: EMPTY
86719: LIST
86720: LIST
86721: LIST
86722: PUSH
86723: LD_INT 58
86725: PUSH
86726: EMPTY
86727: LIST
86728: PUSH
86729: EMPTY
86730: LIST
86731: LIST
86732: PPUSH
86733: CALL_OW 72
86737: PPUSH
86738: CALL_OW 1
86742: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
86743: LD_ADDR_EXP 188
86747: PUSH
86748: LD_EXP 188
86752: PPUSH
86753: LD_VAR 0 2
86757: PPUSH
86758: EMPTY
86759: PPUSH
86760: CALL_OW 1
86764: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
86765: LD_ADDR_EXP 192
86769: PUSH
86770: LD_EXP 192
86774: PPUSH
86775: LD_VAR 0 2
86779: PPUSH
86780: EMPTY
86781: PPUSH
86782: CALL_OW 1
86786: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
86787: LD_ADDR_EXP 191
86791: PUSH
86792: LD_EXP 191
86796: PPUSH
86797: LD_VAR 0 2
86801: PPUSH
86802: EMPTY
86803: PPUSH
86804: CALL_OW 1
86808: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
86809: LD_ADDR_EXP 193
86813: PUSH
86814: LD_EXP 193
86818: PPUSH
86819: LD_VAR 0 2
86823: PPUSH
86824: EMPTY
86825: PPUSH
86826: CALL_OW 1
86830: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
86831: LD_ADDR_EXP 194
86835: PUSH
86836: LD_EXP 194
86840: PPUSH
86841: LD_VAR 0 2
86845: PPUSH
86846: EMPTY
86847: PPUSH
86848: CALL_OW 1
86852: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
86853: LD_ADDR_EXP 195
86857: PUSH
86858: LD_EXP 195
86862: PPUSH
86863: LD_VAR 0 2
86867: PPUSH
86868: EMPTY
86869: PPUSH
86870: CALL_OW 1
86874: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
86875: LD_ADDR_EXP 196
86879: PUSH
86880: LD_EXP 196
86884: PPUSH
86885: LD_VAR 0 2
86889: PPUSH
86890: EMPTY
86891: PPUSH
86892: CALL_OW 1
86896: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
86897: LD_ADDR_EXP 197
86901: PUSH
86902: LD_EXP 197
86906: PPUSH
86907: LD_VAR 0 2
86911: PPUSH
86912: EMPTY
86913: PPUSH
86914: CALL_OW 1
86918: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
86919: LD_ADDR_EXP 198
86923: PUSH
86924: LD_EXP 198
86928: PPUSH
86929: LD_VAR 0 2
86933: PPUSH
86934: EMPTY
86935: PPUSH
86936: CALL_OW 1
86940: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
86941: LD_ADDR_EXP 199
86945: PUSH
86946: LD_EXP 199
86950: PPUSH
86951: LD_VAR 0 2
86955: PPUSH
86956: EMPTY
86957: PPUSH
86958: CALL_OW 1
86962: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
86963: LD_ADDR_EXP 200
86967: PUSH
86968: LD_EXP 200
86972: PPUSH
86973: LD_VAR 0 2
86977: PPUSH
86978: EMPTY
86979: PPUSH
86980: CALL_OW 1
86984: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
86985: LD_ADDR_EXP 189
86989: PUSH
86990: LD_EXP 189
86994: PPUSH
86995: LD_VAR 0 2
86999: PPUSH
87000: LD_INT 0
87002: PPUSH
87003: CALL_OW 1
87007: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
87008: LD_ADDR_EXP 202
87012: PUSH
87013: LD_EXP 202
87017: PPUSH
87018: LD_VAR 0 2
87022: PPUSH
87023: LD_INT 0
87025: PPUSH
87026: CALL_OW 1
87030: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
87031: LD_ADDR_EXP 190
87035: PUSH
87036: LD_EXP 190
87040: PPUSH
87041: LD_VAR 0 2
87045: PPUSH
87046: EMPTY
87047: PPUSH
87048: CALL_OW 1
87052: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
87053: LD_ADDR_EXP 201
87057: PUSH
87058: LD_EXP 201
87062: PPUSH
87063: LD_VAR 0 2
87067: PPUSH
87068: LD_INT 0
87070: PPUSH
87071: CALL_OW 1
87075: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
87076: LD_ADDR_EXP 203
87080: PUSH
87081: LD_EXP 203
87085: PPUSH
87086: LD_VAR 0 2
87090: PPUSH
87091: EMPTY
87092: PPUSH
87093: CALL_OW 1
87097: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
87098: LD_ADDR_EXP 206
87102: PUSH
87103: LD_EXP 206
87107: PPUSH
87108: LD_VAR 0 2
87112: PPUSH
87113: LD_INT 0
87115: PPUSH
87116: CALL_OW 1
87120: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
87121: LD_ADDR_EXP 207
87125: PUSH
87126: LD_EXP 207
87130: PPUSH
87131: LD_VAR 0 2
87135: PPUSH
87136: EMPTY
87137: PPUSH
87138: CALL_OW 1
87142: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
87143: LD_ADDR_EXP 208
87147: PUSH
87148: LD_EXP 208
87152: PPUSH
87153: LD_VAR 0 2
87157: PPUSH
87158: EMPTY
87159: PPUSH
87160: CALL_OW 1
87164: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
87165: LD_ADDR_EXP 209
87169: PUSH
87170: LD_EXP 209
87174: PPUSH
87175: LD_VAR 0 2
87179: PPUSH
87180: EMPTY
87181: PPUSH
87182: CALL_OW 1
87186: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
87187: LD_ADDR_EXP 211
87191: PUSH
87192: LD_EXP 211
87196: PPUSH
87197: LD_VAR 0 2
87201: PPUSH
87202: LD_EXP 178
87206: PUSH
87207: LD_VAR 0 2
87211: ARRAY
87212: PPUSH
87213: LD_INT 2
87215: PUSH
87216: LD_INT 30
87218: PUSH
87219: LD_INT 6
87221: PUSH
87222: EMPTY
87223: LIST
87224: LIST
87225: PUSH
87226: LD_INT 30
87228: PUSH
87229: LD_INT 7
87231: PUSH
87232: EMPTY
87233: LIST
87234: LIST
87235: PUSH
87236: LD_INT 30
87238: PUSH
87239: LD_INT 8
87241: PUSH
87242: EMPTY
87243: LIST
87244: LIST
87245: PUSH
87246: EMPTY
87247: LIST
87248: LIST
87249: LIST
87250: LIST
87251: PPUSH
87252: CALL_OW 72
87256: PPUSH
87257: CALL_OW 1
87261: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
87262: LD_ADDR_EXP 212
87266: PUSH
87267: LD_EXP 212
87271: PPUSH
87272: LD_VAR 0 2
87276: PPUSH
87277: EMPTY
87278: PPUSH
87279: CALL_OW 1
87283: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
87284: LD_ADDR_EXP 213
87288: PUSH
87289: LD_EXP 213
87293: PPUSH
87294: LD_VAR 0 2
87298: PPUSH
87299: EMPTY
87300: PPUSH
87301: CALL_OW 1
87305: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
87306: LD_ADDR_EXP 214
87310: PUSH
87311: LD_EXP 214
87315: PPUSH
87316: LD_VAR 0 2
87320: PPUSH
87321: EMPTY
87322: PPUSH
87323: CALL_OW 1
87327: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
87328: LD_ADDR_EXP 215
87332: PUSH
87333: LD_EXP 215
87337: PPUSH
87338: LD_VAR 0 2
87342: PPUSH
87343: EMPTY
87344: PPUSH
87345: CALL_OW 1
87349: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
87350: LD_ADDR_EXP 216
87354: PUSH
87355: LD_EXP 216
87359: PPUSH
87360: LD_VAR 0 2
87364: PPUSH
87365: EMPTY
87366: PPUSH
87367: CALL_OW 1
87371: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
87372: LD_ADDR_EXP 217
87376: PUSH
87377: LD_EXP 217
87381: PPUSH
87382: LD_VAR 0 2
87386: PPUSH
87387: EMPTY
87388: PPUSH
87389: CALL_OW 1
87393: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
87394: LD_ADDR_EXP 218
87398: PUSH
87399: LD_EXP 218
87403: PPUSH
87404: LD_VAR 0 2
87408: PPUSH
87409: EMPTY
87410: PPUSH
87411: CALL_OW 1
87415: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
87416: LD_ADDR_EXP 219
87420: PUSH
87421: LD_EXP 219
87425: PPUSH
87426: LD_VAR 0 2
87430: PPUSH
87431: EMPTY
87432: PPUSH
87433: CALL_OW 1
87437: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
87438: LD_ADDR_EXP 220
87442: PUSH
87443: LD_EXP 220
87447: PPUSH
87448: LD_VAR 0 2
87452: PPUSH
87453: LD_INT 0
87455: PPUSH
87456: CALL_OW 1
87460: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , i , false ) ;
87461: LD_ADDR_EXP 221
87465: PUSH
87466: LD_EXP 221
87470: PPUSH
87471: LD_VAR 0 2
87475: PPUSH
87476: LD_INT 0
87478: PPUSH
87479: CALL_OW 1
87483: ST_TO_ADDR
// end ;
87484: GO 86385
87486: POP
87487: POP
// MC_InitSides ( ) ;
87488: CALL 87774 0 0
// MC_InitResearch ( ) ;
87492: CALL 87513 0 0
// CustomInitMacro ( ) ;
87496: CALL 350 0 0
// skirmish := true ;
87500: LD_ADDR_EXP 176
87504: PUSH
87505: LD_INT 1
87507: ST_TO_ADDR
// end ;
87508: LD_VAR 0 1
87512: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
87513: LD_INT 0
87515: PPUSH
87516: PPUSH
87517: PPUSH
87518: PPUSH
87519: PPUSH
87520: PPUSH
// if not mc_bases then
87521: LD_EXP 178
87525: NOT
87526: IFFALSE 87530
// exit ;
87528: GO 87769
// for i = 1 to 8 do
87530: LD_ADDR_VAR 0 2
87534: PUSH
87535: DOUBLE
87536: LD_INT 1
87538: DEC
87539: ST_TO_ADDR
87540: LD_INT 8
87542: PUSH
87543: FOR_TO
87544: IFFALSE 87570
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
87546: LD_ADDR_EXP 205
87550: PUSH
87551: LD_EXP 205
87555: PPUSH
87556: LD_VAR 0 2
87560: PPUSH
87561: EMPTY
87562: PPUSH
87563: CALL_OW 1
87567: ST_TO_ADDR
87568: GO 87543
87570: POP
87571: POP
// tmp := [ ] ;
87572: LD_ADDR_VAR 0 5
87576: PUSH
87577: EMPTY
87578: ST_TO_ADDR
// for i = 1 to mc_sides do
87579: LD_ADDR_VAR 0 2
87583: PUSH
87584: DOUBLE
87585: LD_INT 1
87587: DEC
87588: ST_TO_ADDR
87589: LD_EXP 204
87593: PUSH
87594: FOR_TO
87595: IFFALSE 87653
// if not mc_sides [ i ] in tmp then
87597: LD_EXP 204
87601: PUSH
87602: LD_VAR 0 2
87606: ARRAY
87607: PUSH
87608: LD_VAR 0 5
87612: IN
87613: NOT
87614: IFFALSE 87651
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
87616: LD_ADDR_VAR 0 5
87620: PUSH
87621: LD_VAR 0 5
87625: PPUSH
87626: LD_VAR 0 5
87630: PUSH
87631: LD_INT 1
87633: PLUS
87634: PPUSH
87635: LD_EXP 204
87639: PUSH
87640: LD_VAR 0 2
87644: ARRAY
87645: PPUSH
87646: CALL_OW 2
87650: ST_TO_ADDR
87651: GO 87594
87653: POP
87654: POP
// if not tmp then
87655: LD_VAR 0 5
87659: NOT
87660: IFFALSE 87664
// exit ;
87662: GO 87769
// for j in tmp do
87664: LD_ADDR_VAR 0 3
87668: PUSH
87669: LD_VAR 0 5
87673: PUSH
87674: FOR_IN
87675: IFFALSE 87767
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
87677: LD_ADDR_VAR 0 6
87681: PUSH
87682: LD_INT 22
87684: PUSH
87685: LD_VAR 0 3
87689: PUSH
87690: EMPTY
87691: LIST
87692: LIST
87693: PPUSH
87694: CALL_OW 69
87698: ST_TO_ADDR
// if not un then
87699: LD_VAR 0 6
87703: NOT
87704: IFFALSE 87708
// continue ;
87706: GO 87674
// nation := GetNation ( un [ 1 ] ) ;
87708: LD_ADDR_VAR 0 4
87712: PUSH
87713: LD_VAR 0 6
87717: PUSH
87718: LD_INT 1
87720: ARRAY
87721: PPUSH
87722: CALL_OW 248
87726: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
87727: LD_ADDR_EXP 205
87731: PUSH
87732: LD_EXP 205
87736: PPUSH
87737: LD_VAR 0 3
87741: PPUSH
87742: LD_VAR 0 3
87746: PPUSH
87747: LD_VAR 0 4
87751: PPUSH
87752: LD_INT 1
87754: PPUSH
87755: CALL 19287 0 3
87759: PPUSH
87760: CALL_OW 1
87764: ST_TO_ADDR
// end ;
87765: GO 87674
87767: POP
87768: POP
// end ;
87769: LD_VAR 0 1
87773: RET
// export function MC_InitSides ( ) ; var i ; begin
87774: LD_INT 0
87776: PPUSH
87777: PPUSH
// if not mc_bases then
87778: LD_EXP 178
87782: NOT
87783: IFFALSE 87787
// exit ;
87785: GO 87861
// for i = 1 to mc_bases do
87787: LD_ADDR_VAR 0 2
87791: PUSH
87792: DOUBLE
87793: LD_INT 1
87795: DEC
87796: ST_TO_ADDR
87797: LD_EXP 178
87801: PUSH
87802: FOR_TO
87803: IFFALSE 87859
// if mc_bases [ i ] then
87805: LD_EXP 178
87809: PUSH
87810: LD_VAR 0 2
87814: ARRAY
87815: IFFALSE 87857
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
87817: LD_ADDR_EXP 204
87821: PUSH
87822: LD_EXP 204
87826: PPUSH
87827: LD_VAR 0 2
87831: PPUSH
87832: LD_EXP 178
87836: PUSH
87837: LD_VAR 0 2
87841: ARRAY
87842: PUSH
87843: LD_INT 1
87845: ARRAY
87846: PPUSH
87847: CALL_OW 255
87851: PPUSH
87852: CALL_OW 1
87856: ST_TO_ADDR
87857: GO 87802
87859: POP
87860: POP
// end ;
87861: LD_VAR 0 1
87865: RET
// every 0 0$03 trigger skirmish do
87866: LD_EXP 176
87870: IFFALSE 88024
87872: GO 87874
87874: DISABLE
// begin enable ;
87875: ENABLE
// MC_CheckBuildings ( ) ;
87876: CALL 92522 0 0
// MC_CheckPeopleLife ( ) ;
87880: CALL 92683 0 0
// RaiseSailEvent ( 100 ) ;
87884: LD_INT 100
87886: PPUSH
87887: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
87891: LD_INT 103
87893: PPUSH
87894: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
87898: LD_INT 104
87900: PPUSH
87901: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
87905: LD_INT 105
87907: PPUSH
87908: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
87912: LD_INT 106
87914: PPUSH
87915: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
87919: LD_INT 107
87921: PPUSH
87922: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
87926: LD_INT 108
87928: PPUSH
87929: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
87933: LD_INT 109
87935: PPUSH
87936: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
87940: LD_INT 110
87942: PPUSH
87943: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
87947: LD_INT 111
87949: PPUSH
87950: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
87954: LD_INT 112
87956: PPUSH
87957: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
87961: LD_INT 113
87963: PPUSH
87964: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
87968: LD_INT 120
87970: PPUSH
87971: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
87975: LD_INT 121
87977: PPUSH
87978: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
87982: LD_INT 122
87984: PPUSH
87985: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
87989: LD_INT 123
87991: PPUSH
87992: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
87996: LD_INT 124
87998: PPUSH
87999: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
88003: LD_INT 125
88005: PPUSH
88006: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
88010: LD_INT 126
88012: PPUSH
88013: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
88017: LD_INT 200
88019: PPUSH
88020: CALL_OW 427
// end ;
88024: END
// on SailEvent ( event ) do begin if event < 100 then
88025: LD_VAR 0 1
88029: PUSH
88030: LD_INT 100
88032: LESS
88033: IFFALSE 88044
// CustomEvent ( event ) ;
88035: LD_VAR 0 1
88039: PPUSH
88040: CALL 16158 0 1
// if event = 100 then
88044: LD_VAR 0 1
88048: PUSH
88049: LD_INT 100
88051: EQUAL
88052: IFFALSE 88058
// MC_ClassManager ( ) ;
88054: CALL 88450 0 0
// if event = 101 then
88058: LD_VAR 0 1
88062: PUSH
88063: LD_INT 101
88065: EQUAL
88066: IFFALSE 88072
// MC_RepairBuildings ( ) ;
88068: CALL 93268 0 0
// if event = 102 then
88072: LD_VAR 0 1
88076: PUSH
88077: LD_INT 102
88079: EQUAL
88080: IFFALSE 88086
// MC_Heal ( ) ;
88082: CALL 94175 0 0
// if event = 103 then
88086: LD_VAR 0 1
88090: PUSH
88091: LD_INT 103
88093: EQUAL
88094: IFFALSE 88100
// MC_Build ( ) ;
88096: CALL 94597 0 0
// if event = 104 then
88100: LD_VAR 0 1
88104: PUSH
88105: LD_INT 104
88107: EQUAL
88108: IFFALSE 88114
// MC_TurretWeapon ( ) ;
88110: CALL 96238 0 0
// if event = 105 then
88114: LD_VAR 0 1
88118: PUSH
88119: LD_INT 105
88121: EQUAL
88122: IFFALSE 88128
// MC_BuildUpgrade ( ) ;
88124: CALL 95789 0 0
// if event = 106 then
88128: LD_VAR 0 1
88132: PUSH
88133: LD_INT 106
88135: EQUAL
88136: IFFALSE 88142
// MC_PlantMines ( ) ;
88138: CALL 96668 0 0
// if event = 107 then
88142: LD_VAR 0 1
88146: PUSH
88147: LD_INT 107
88149: EQUAL
88150: IFFALSE 88156
// MC_CollectCrates ( ) ;
88152: CALL 97459 0 0
// if event = 108 then
88156: LD_VAR 0 1
88160: PUSH
88161: LD_INT 108
88163: EQUAL
88164: IFFALSE 88170
// MC_LinkRemoteControl ( ) ;
88166: CALL 99309 0 0
// if event = 109 then
88170: LD_VAR 0 1
88174: PUSH
88175: LD_INT 109
88177: EQUAL
88178: IFFALSE 88184
// MC_ProduceVehicle ( ) ;
88180: CALL 99490 0 0
// if event = 110 then
88184: LD_VAR 0 1
88188: PUSH
88189: LD_INT 110
88191: EQUAL
88192: IFFALSE 88198
// MC_SendAttack ( ) ;
88194: CALL 99956 0 0
// if event = 111 then
88198: LD_VAR 0 1
88202: PUSH
88203: LD_INT 111
88205: EQUAL
88206: IFFALSE 88212
// MC_Defend ( ) ;
88208: CALL 100064 0 0
// if event = 112 then
88212: LD_VAR 0 1
88216: PUSH
88217: LD_INT 112
88219: EQUAL
88220: IFFALSE 88226
// MC_Research ( ) ;
88222: CALL 100944 0 0
// if event = 113 then
88226: LD_VAR 0 1
88230: PUSH
88231: LD_INT 113
88233: EQUAL
88234: IFFALSE 88240
// MC_MinesTrigger ( ) ;
88236: CALL 102058 0 0
// if event = 120 then
88240: LD_VAR 0 1
88244: PUSH
88245: LD_INT 120
88247: EQUAL
88248: IFFALSE 88254
// MC_RepairVehicle ( ) ;
88250: CALL 102157 0 0
// if event = 121 then
88254: LD_VAR 0 1
88258: PUSH
88259: LD_INT 121
88261: EQUAL
88262: IFFALSE 88268
// MC_TameApe ( ) ;
88264: CALL 102898 0 0
// if event = 122 then
88268: LD_VAR 0 1
88272: PUSH
88273: LD_INT 122
88275: EQUAL
88276: IFFALSE 88282
// MC_ChangeApeClass ( ) ;
88278: CALL 103727 0 0
// if event = 123 then
88282: LD_VAR 0 1
88286: PUSH
88287: LD_INT 123
88289: EQUAL
88290: IFFALSE 88296
// MC_Bazooka ( ) ;
88292: CALL 104377 0 0
// if event = 124 then
88296: LD_VAR 0 1
88300: PUSH
88301: LD_INT 124
88303: EQUAL
88304: IFFALSE 88310
// MC_TeleportExit ( ) ;
88306: CALL 104575 0 0
// if event = 125 then
88310: LD_VAR 0 1
88314: PUSH
88315: LD_INT 125
88317: EQUAL
88318: IFFALSE 88324
// MC_Deposits ( ) ;
88320: CALL 105222 0 0
// if event = 126 then
88324: LD_VAR 0 1
88328: PUSH
88329: LD_INT 126
88331: EQUAL
88332: IFFALSE 88338
// MC_RemoteDriver ( ) ;
88334: CALL 105847 0 0
// if event = 200 then
88338: LD_VAR 0 1
88342: PUSH
88343: LD_INT 200
88345: EQUAL
88346: IFFALSE 88352
// MC_Idle ( ) ;
88348: CALL 107796 0 0
// end ;
88352: PPOPN 1
88354: END
// export function MC_Reset ( base , tag ) ; var i ; begin
88355: LD_INT 0
88357: PPUSH
88358: PPUSH
// if not mc_bases [ base ] or not tag then
88359: LD_EXP 178
88363: PUSH
88364: LD_VAR 0 1
88368: ARRAY
88369: NOT
88370: PUSH
88371: LD_VAR 0 2
88375: NOT
88376: OR
88377: IFFALSE 88381
// exit ;
88379: GO 88445
// for i in mc_bases [ base ] union mc_ape [ base ] do
88381: LD_ADDR_VAR 0 4
88385: PUSH
88386: LD_EXP 178
88390: PUSH
88391: LD_VAR 0 1
88395: ARRAY
88396: PUSH
88397: LD_EXP 207
88401: PUSH
88402: LD_VAR 0 1
88406: ARRAY
88407: UNION
88408: PUSH
88409: FOR_IN
88410: IFFALSE 88443
// if GetTag ( i ) = tag then
88412: LD_VAR 0 4
88416: PPUSH
88417: CALL_OW 110
88421: PUSH
88422: LD_VAR 0 2
88426: EQUAL
88427: IFFALSE 88441
// SetTag ( i , 0 ) ;
88429: LD_VAR 0 4
88433: PPUSH
88434: LD_INT 0
88436: PPUSH
88437: CALL_OW 109
88441: GO 88409
88443: POP
88444: POP
// end ;
88445: LD_VAR 0 3
88449: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
88450: LD_INT 0
88452: PPUSH
88453: PPUSH
88454: PPUSH
88455: PPUSH
88456: PPUSH
88457: PPUSH
88458: PPUSH
88459: PPUSH
// if not mc_bases then
88460: LD_EXP 178
88464: NOT
88465: IFFALSE 88469
// exit ;
88467: GO 88927
// for i = 1 to mc_bases do
88469: LD_ADDR_VAR 0 2
88473: PUSH
88474: DOUBLE
88475: LD_INT 1
88477: DEC
88478: ST_TO_ADDR
88479: LD_EXP 178
88483: PUSH
88484: FOR_TO
88485: IFFALSE 88925
// begin tmp := MC_ClassCheckReq ( i ) ;
88487: LD_ADDR_VAR 0 4
88491: PUSH
88492: LD_VAR 0 2
88496: PPUSH
88497: CALL 88932 0 1
88501: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
88502: LD_ADDR_EXP 219
88506: PUSH
88507: LD_EXP 219
88511: PPUSH
88512: LD_VAR 0 2
88516: PPUSH
88517: LD_VAR 0 4
88521: PPUSH
88522: CALL_OW 1
88526: ST_TO_ADDR
// if not tmp then
88527: LD_VAR 0 4
88531: NOT
88532: IFFALSE 88536
// continue ;
88534: GO 88484
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
88536: LD_ADDR_VAR 0 6
88540: PUSH
88541: LD_EXP 178
88545: PUSH
88546: LD_VAR 0 2
88550: ARRAY
88551: PPUSH
88552: LD_INT 2
88554: PUSH
88555: LD_INT 30
88557: PUSH
88558: LD_INT 4
88560: PUSH
88561: EMPTY
88562: LIST
88563: LIST
88564: PUSH
88565: LD_INT 30
88567: PUSH
88568: LD_INT 5
88570: PUSH
88571: EMPTY
88572: LIST
88573: LIST
88574: PUSH
88575: EMPTY
88576: LIST
88577: LIST
88578: LIST
88579: PPUSH
88580: CALL_OW 72
88584: PUSH
88585: LD_EXP 178
88589: PUSH
88590: LD_VAR 0 2
88594: ARRAY
88595: PPUSH
88596: LD_INT 2
88598: PUSH
88599: LD_INT 30
88601: PUSH
88602: LD_INT 0
88604: PUSH
88605: EMPTY
88606: LIST
88607: LIST
88608: PUSH
88609: LD_INT 30
88611: PUSH
88612: LD_INT 1
88614: PUSH
88615: EMPTY
88616: LIST
88617: LIST
88618: PUSH
88619: EMPTY
88620: LIST
88621: LIST
88622: LIST
88623: PPUSH
88624: CALL_OW 72
88628: PUSH
88629: LD_EXP 178
88633: PUSH
88634: LD_VAR 0 2
88638: ARRAY
88639: PPUSH
88640: LD_INT 30
88642: PUSH
88643: LD_INT 3
88645: PUSH
88646: EMPTY
88647: LIST
88648: LIST
88649: PPUSH
88650: CALL_OW 72
88654: PUSH
88655: LD_EXP 178
88659: PUSH
88660: LD_VAR 0 2
88664: ARRAY
88665: PPUSH
88666: LD_INT 2
88668: PUSH
88669: LD_INT 30
88671: PUSH
88672: LD_INT 6
88674: PUSH
88675: EMPTY
88676: LIST
88677: LIST
88678: PUSH
88679: LD_INT 30
88681: PUSH
88682: LD_INT 7
88684: PUSH
88685: EMPTY
88686: LIST
88687: LIST
88688: PUSH
88689: LD_INT 30
88691: PUSH
88692: LD_INT 8
88694: PUSH
88695: EMPTY
88696: LIST
88697: LIST
88698: PUSH
88699: EMPTY
88700: LIST
88701: LIST
88702: LIST
88703: LIST
88704: PPUSH
88705: CALL_OW 72
88709: PUSH
88710: EMPTY
88711: LIST
88712: LIST
88713: LIST
88714: LIST
88715: ST_TO_ADDR
// for j = 1 to 4 do
88716: LD_ADDR_VAR 0 3
88720: PUSH
88721: DOUBLE
88722: LD_INT 1
88724: DEC
88725: ST_TO_ADDR
88726: LD_INT 4
88728: PUSH
88729: FOR_TO
88730: IFFALSE 88921
// begin if not tmp [ j ] then
88732: LD_VAR 0 4
88736: PUSH
88737: LD_VAR 0 3
88741: ARRAY
88742: NOT
88743: IFFALSE 88747
// continue ;
88745: GO 88729
// for p in tmp [ j ] do
88747: LD_ADDR_VAR 0 5
88751: PUSH
88752: LD_VAR 0 4
88756: PUSH
88757: LD_VAR 0 3
88761: ARRAY
88762: PUSH
88763: FOR_IN
88764: IFFALSE 88917
// begin if not b [ j ] then
88766: LD_VAR 0 6
88770: PUSH
88771: LD_VAR 0 3
88775: ARRAY
88776: NOT
88777: IFFALSE 88781
// break ;
88779: GO 88917
// e := 0 ;
88781: LD_ADDR_VAR 0 7
88785: PUSH
88786: LD_INT 0
88788: ST_TO_ADDR
// for k in b [ j ] do
88789: LD_ADDR_VAR 0 8
88793: PUSH
88794: LD_VAR 0 6
88798: PUSH
88799: LD_VAR 0 3
88803: ARRAY
88804: PUSH
88805: FOR_IN
88806: IFFALSE 88833
// if IsNotFull ( k ) then
88808: LD_VAR 0 8
88812: PPUSH
88813: CALL 21440 0 1
88817: IFFALSE 88831
// begin e := k ;
88819: LD_ADDR_VAR 0 7
88823: PUSH
88824: LD_VAR 0 8
88828: ST_TO_ADDR
// break ;
88829: GO 88833
// end ;
88831: GO 88805
88833: POP
88834: POP
// if e and not UnitGoingToBuilding ( p , e ) then
88835: LD_VAR 0 7
88839: PUSH
88840: LD_VAR 0 5
88844: PPUSH
88845: LD_VAR 0 7
88849: PPUSH
88850: CALL 54604 0 2
88854: NOT
88855: AND
88856: IFFALSE 88915
// begin if IsInUnit ( p ) then
88858: LD_VAR 0 5
88862: PPUSH
88863: CALL_OW 310
88867: IFFALSE 88878
// ComExitBuilding ( p ) ;
88869: LD_VAR 0 5
88873: PPUSH
88874: CALL_OW 122
// ComEnterUnit ( p , e ) ;
88878: LD_VAR 0 5
88882: PPUSH
88883: LD_VAR 0 7
88887: PPUSH
88888: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
88892: LD_VAR 0 5
88896: PPUSH
88897: LD_VAR 0 3
88901: PPUSH
88902: CALL_OW 183
// AddComExitBuilding ( p ) ;
88906: LD_VAR 0 5
88910: PPUSH
88911: CALL_OW 182
// end ; end ;
88915: GO 88763
88917: POP
88918: POP
// end ;
88919: GO 88729
88921: POP
88922: POP
// end ;
88923: GO 88484
88925: POP
88926: POP
// end ;
88927: LD_VAR 0 1
88931: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
88932: LD_INT 0
88934: PPUSH
88935: PPUSH
88936: PPUSH
88937: PPUSH
88938: PPUSH
88939: PPUSH
88940: PPUSH
88941: PPUSH
88942: PPUSH
88943: PPUSH
88944: PPUSH
88945: PPUSH
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
88946: LD_VAR 0 1
88950: NOT
88951: PUSH
88952: LD_EXP 178
88956: PUSH
88957: LD_VAR 0 1
88961: ARRAY
88962: NOT
88963: OR
88964: PUSH
88965: LD_EXP 178
88969: PUSH
88970: LD_VAR 0 1
88974: ARRAY
88975: PPUSH
88976: LD_INT 2
88978: PUSH
88979: LD_INT 30
88981: PUSH
88982: LD_INT 0
88984: PUSH
88985: EMPTY
88986: LIST
88987: LIST
88988: PUSH
88989: LD_INT 30
88991: PUSH
88992: LD_INT 1
88994: PUSH
88995: EMPTY
88996: LIST
88997: LIST
88998: PUSH
88999: EMPTY
89000: LIST
89001: LIST
89002: LIST
89003: PPUSH
89004: CALL_OW 72
89008: NOT
89009: OR
89010: IFFALSE 89014
// exit ;
89012: GO 92517
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
89014: LD_ADDR_VAR 0 4
89018: PUSH
89019: LD_EXP 178
89023: PUSH
89024: LD_VAR 0 1
89028: ARRAY
89029: PPUSH
89030: LD_INT 2
89032: PUSH
89033: LD_INT 25
89035: PUSH
89036: LD_INT 1
89038: PUSH
89039: EMPTY
89040: LIST
89041: LIST
89042: PUSH
89043: LD_INT 25
89045: PUSH
89046: LD_INT 2
89048: PUSH
89049: EMPTY
89050: LIST
89051: LIST
89052: PUSH
89053: LD_INT 25
89055: PUSH
89056: LD_INT 3
89058: PUSH
89059: EMPTY
89060: LIST
89061: LIST
89062: PUSH
89063: LD_INT 25
89065: PUSH
89066: LD_INT 4
89068: PUSH
89069: EMPTY
89070: LIST
89071: LIST
89072: PUSH
89073: LD_INT 25
89075: PUSH
89076: LD_INT 5
89078: PUSH
89079: EMPTY
89080: LIST
89081: LIST
89082: PUSH
89083: LD_INT 25
89085: PUSH
89086: LD_INT 8
89088: PUSH
89089: EMPTY
89090: LIST
89091: LIST
89092: PUSH
89093: LD_INT 25
89095: PUSH
89096: LD_INT 9
89098: PUSH
89099: EMPTY
89100: LIST
89101: LIST
89102: PUSH
89103: EMPTY
89104: LIST
89105: LIST
89106: LIST
89107: LIST
89108: LIST
89109: LIST
89110: LIST
89111: LIST
89112: PPUSH
89113: CALL_OW 72
89117: ST_TO_ADDR
// if not tmp then
89118: LD_VAR 0 4
89122: NOT
89123: IFFALSE 89127
// exit ;
89125: GO 92517
// for i in tmp do
89127: LD_ADDR_VAR 0 3
89131: PUSH
89132: LD_VAR 0 4
89136: PUSH
89137: FOR_IN
89138: IFFALSE 89169
// if GetTag ( i ) then
89140: LD_VAR 0 3
89144: PPUSH
89145: CALL_OW 110
89149: IFFALSE 89167
// tmp := tmp diff i ;
89151: LD_ADDR_VAR 0 4
89155: PUSH
89156: LD_VAR 0 4
89160: PUSH
89161: LD_VAR 0 3
89165: DIFF
89166: ST_TO_ADDR
89167: GO 89137
89169: POP
89170: POP
// if not tmp then
89171: LD_VAR 0 4
89175: NOT
89176: IFFALSE 89180
// exit ;
89178: GO 92517
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
89180: LD_ADDR_VAR 0 5
89184: PUSH
89185: LD_EXP 178
89189: PUSH
89190: LD_VAR 0 1
89194: ARRAY
89195: PPUSH
89196: LD_INT 2
89198: PUSH
89199: LD_INT 25
89201: PUSH
89202: LD_INT 1
89204: PUSH
89205: EMPTY
89206: LIST
89207: LIST
89208: PUSH
89209: LD_INT 25
89211: PUSH
89212: LD_INT 5
89214: PUSH
89215: EMPTY
89216: LIST
89217: LIST
89218: PUSH
89219: LD_INT 25
89221: PUSH
89222: LD_INT 8
89224: PUSH
89225: EMPTY
89226: LIST
89227: LIST
89228: PUSH
89229: LD_INT 25
89231: PUSH
89232: LD_INT 9
89234: PUSH
89235: EMPTY
89236: LIST
89237: LIST
89238: PUSH
89239: EMPTY
89240: LIST
89241: LIST
89242: LIST
89243: LIST
89244: LIST
89245: PPUSH
89246: CALL_OW 72
89250: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
89251: LD_ADDR_VAR 0 6
89255: PUSH
89256: LD_EXP 178
89260: PUSH
89261: LD_VAR 0 1
89265: ARRAY
89266: PPUSH
89267: LD_INT 25
89269: PUSH
89270: LD_INT 2
89272: PUSH
89273: EMPTY
89274: LIST
89275: LIST
89276: PPUSH
89277: CALL_OW 72
89281: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
89282: LD_ADDR_VAR 0 7
89286: PUSH
89287: LD_EXP 178
89291: PUSH
89292: LD_VAR 0 1
89296: ARRAY
89297: PPUSH
89298: LD_INT 25
89300: PUSH
89301: LD_INT 3
89303: PUSH
89304: EMPTY
89305: LIST
89306: LIST
89307: PPUSH
89308: CALL_OW 72
89312: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
89313: LD_ADDR_VAR 0 8
89317: PUSH
89318: LD_EXP 178
89322: PUSH
89323: LD_VAR 0 1
89327: ARRAY
89328: PPUSH
89329: LD_INT 25
89331: PUSH
89332: LD_INT 4
89334: PUSH
89335: EMPTY
89336: LIST
89337: LIST
89338: PUSH
89339: LD_INT 24
89341: PUSH
89342: LD_INT 251
89344: PUSH
89345: EMPTY
89346: LIST
89347: LIST
89348: PUSH
89349: EMPTY
89350: LIST
89351: LIST
89352: PPUSH
89353: CALL_OW 72
89357: ST_TO_ADDR
// if mc_is_defending [ base ] then
89358: LD_EXP 221
89362: PUSH
89363: LD_VAR 0 1
89367: ARRAY
89368: IFFALSE 89829
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
89370: LD_ADDR_EXP 220
89374: PUSH
89375: LD_EXP 220
89379: PPUSH
89380: LD_VAR 0 1
89384: PPUSH
89385: LD_INT 4
89387: PPUSH
89388: CALL_OW 1
89392: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
89393: LD_ADDR_VAR 0 12
89397: PUSH
89398: LD_EXP 178
89402: PUSH
89403: LD_VAR 0 1
89407: ARRAY
89408: PPUSH
89409: LD_INT 2
89411: PUSH
89412: LD_INT 30
89414: PUSH
89415: LD_INT 4
89417: PUSH
89418: EMPTY
89419: LIST
89420: LIST
89421: PUSH
89422: LD_INT 30
89424: PUSH
89425: LD_INT 5
89427: PUSH
89428: EMPTY
89429: LIST
89430: LIST
89431: PUSH
89432: EMPTY
89433: LIST
89434: LIST
89435: LIST
89436: PPUSH
89437: CALL_OW 72
89441: ST_TO_ADDR
// if not b then
89442: LD_VAR 0 12
89446: NOT
89447: IFFALSE 89451
// exit ;
89449: GO 92517
// p := [ ] ;
89451: LD_ADDR_VAR 0 11
89455: PUSH
89456: EMPTY
89457: ST_TO_ADDR
// if sci >= 2 then
89458: LD_VAR 0 8
89462: PUSH
89463: LD_INT 2
89465: GREATEREQUAL
89466: IFFALSE 89497
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
89468: LD_ADDR_VAR 0 8
89472: PUSH
89473: LD_VAR 0 8
89477: PUSH
89478: LD_INT 1
89480: ARRAY
89481: PUSH
89482: LD_VAR 0 8
89486: PUSH
89487: LD_INT 2
89489: ARRAY
89490: PUSH
89491: EMPTY
89492: LIST
89493: LIST
89494: ST_TO_ADDR
89495: GO 89558
// if sci = 1 then
89497: LD_VAR 0 8
89501: PUSH
89502: LD_INT 1
89504: EQUAL
89505: IFFALSE 89526
// sci := [ sci [ 1 ] ] else
89507: LD_ADDR_VAR 0 8
89511: PUSH
89512: LD_VAR 0 8
89516: PUSH
89517: LD_INT 1
89519: ARRAY
89520: PUSH
89521: EMPTY
89522: LIST
89523: ST_TO_ADDR
89524: GO 89558
// if sci = 0 then
89526: LD_VAR 0 8
89530: PUSH
89531: LD_INT 0
89533: EQUAL
89534: IFFALSE 89558
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
89536: LD_ADDR_VAR 0 11
89540: PUSH
89541: LD_VAR 0 4
89545: PPUSH
89546: LD_INT 4
89548: PPUSH
89549: CALL 54467 0 2
89553: PUSH
89554: LD_INT 1
89556: ARRAY
89557: ST_TO_ADDR
// if eng > 4 then
89558: LD_VAR 0 6
89562: PUSH
89563: LD_INT 4
89565: GREATER
89566: IFFALSE 89612
// for i = eng downto 4 do
89568: LD_ADDR_VAR 0 3
89572: PUSH
89573: DOUBLE
89574: LD_VAR 0 6
89578: INC
89579: ST_TO_ADDR
89580: LD_INT 4
89582: PUSH
89583: FOR_DOWNTO
89584: IFFALSE 89610
// eng := eng diff eng [ i ] ;
89586: LD_ADDR_VAR 0 6
89590: PUSH
89591: LD_VAR 0 6
89595: PUSH
89596: LD_VAR 0 6
89600: PUSH
89601: LD_VAR 0 3
89605: ARRAY
89606: DIFF
89607: ST_TO_ADDR
89608: GO 89583
89610: POP
89611: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
89612: LD_ADDR_VAR 0 4
89616: PUSH
89617: LD_VAR 0 4
89621: PUSH
89622: LD_VAR 0 5
89626: PUSH
89627: LD_VAR 0 6
89631: UNION
89632: PUSH
89633: LD_VAR 0 7
89637: UNION
89638: PUSH
89639: LD_VAR 0 8
89643: UNION
89644: DIFF
89645: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
89646: LD_ADDR_VAR 0 13
89650: PUSH
89651: LD_EXP 178
89655: PUSH
89656: LD_VAR 0 1
89660: ARRAY
89661: PPUSH
89662: LD_INT 2
89664: PUSH
89665: LD_INT 30
89667: PUSH
89668: LD_INT 32
89670: PUSH
89671: EMPTY
89672: LIST
89673: LIST
89674: PUSH
89675: LD_INT 30
89677: PUSH
89678: LD_INT 31
89680: PUSH
89681: EMPTY
89682: LIST
89683: LIST
89684: PUSH
89685: EMPTY
89686: LIST
89687: LIST
89688: LIST
89689: PPUSH
89690: CALL_OW 72
89694: PUSH
89695: LD_EXP 178
89699: PUSH
89700: LD_VAR 0 1
89704: ARRAY
89705: PPUSH
89706: LD_INT 2
89708: PUSH
89709: LD_INT 30
89711: PUSH
89712: LD_INT 4
89714: PUSH
89715: EMPTY
89716: LIST
89717: LIST
89718: PUSH
89719: LD_INT 30
89721: PUSH
89722: LD_INT 5
89724: PUSH
89725: EMPTY
89726: LIST
89727: LIST
89728: PUSH
89729: EMPTY
89730: LIST
89731: LIST
89732: LIST
89733: PPUSH
89734: CALL_OW 72
89738: PUSH
89739: LD_INT 6
89741: MUL
89742: PLUS
89743: ST_TO_ADDR
// if bcount < tmp then
89744: LD_VAR 0 13
89748: PUSH
89749: LD_VAR 0 4
89753: LESS
89754: IFFALSE 89800
// for i = tmp downto bcount do
89756: LD_ADDR_VAR 0 3
89760: PUSH
89761: DOUBLE
89762: LD_VAR 0 4
89766: INC
89767: ST_TO_ADDR
89768: LD_VAR 0 13
89772: PUSH
89773: FOR_DOWNTO
89774: IFFALSE 89798
// tmp := Delete ( tmp , tmp ) ;
89776: LD_ADDR_VAR 0 4
89780: PUSH
89781: LD_VAR 0 4
89785: PPUSH
89786: LD_VAR 0 4
89790: PPUSH
89791: CALL_OW 3
89795: ST_TO_ADDR
89796: GO 89773
89798: POP
89799: POP
// result := [ tmp , 0 , 0 , p ] ;
89800: LD_ADDR_VAR 0 2
89804: PUSH
89805: LD_VAR 0 4
89809: PUSH
89810: LD_INT 0
89812: PUSH
89813: LD_INT 0
89815: PUSH
89816: LD_VAR 0 11
89820: PUSH
89821: EMPTY
89822: LIST
89823: LIST
89824: LIST
89825: LIST
89826: ST_TO_ADDR
// exit ;
89827: GO 92517
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
89829: LD_EXP 178
89833: PUSH
89834: LD_VAR 0 1
89838: ARRAY
89839: PPUSH
89840: LD_INT 2
89842: PUSH
89843: LD_INT 30
89845: PUSH
89846: LD_INT 6
89848: PUSH
89849: EMPTY
89850: LIST
89851: LIST
89852: PUSH
89853: LD_INT 30
89855: PUSH
89856: LD_INT 7
89858: PUSH
89859: EMPTY
89860: LIST
89861: LIST
89862: PUSH
89863: LD_INT 30
89865: PUSH
89866: LD_INT 8
89868: PUSH
89869: EMPTY
89870: LIST
89871: LIST
89872: PUSH
89873: EMPTY
89874: LIST
89875: LIST
89876: LIST
89877: LIST
89878: PPUSH
89879: CALL_OW 72
89883: NOT
89884: PUSH
89885: LD_EXP 178
89889: PUSH
89890: LD_VAR 0 1
89894: ARRAY
89895: PPUSH
89896: LD_INT 30
89898: PUSH
89899: LD_INT 3
89901: PUSH
89902: EMPTY
89903: LIST
89904: LIST
89905: PPUSH
89906: CALL_OW 72
89910: NOT
89911: AND
89912: IFFALSE 89984
// begin if eng = tmp then
89914: LD_VAR 0 6
89918: PUSH
89919: LD_VAR 0 4
89923: EQUAL
89924: IFFALSE 89928
// exit ;
89926: GO 92517
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
89928: LD_ADDR_EXP 220
89932: PUSH
89933: LD_EXP 220
89937: PPUSH
89938: LD_VAR 0 1
89942: PPUSH
89943: LD_INT 1
89945: PPUSH
89946: CALL_OW 1
89950: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
89951: LD_ADDR_VAR 0 2
89955: PUSH
89956: LD_INT 0
89958: PUSH
89959: LD_VAR 0 4
89963: PUSH
89964: LD_VAR 0 6
89968: DIFF
89969: PUSH
89970: LD_INT 0
89972: PUSH
89973: LD_INT 0
89975: PUSH
89976: EMPTY
89977: LIST
89978: LIST
89979: LIST
89980: LIST
89981: ST_TO_ADDR
// exit ;
89982: GO 92517
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
89984: LD_EXP 205
89988: PUSH
89989: LD_EXP 204
89993: PUSH
89994: LD_VAR 0 1
89998: ARRAY
89999: ARRAY
90000: PUSH
90001: LD_EXP 178
90005: PUSH
90006: LD_VAR 0 1
90010: ARRAY
90011: PPUSH
90012: LD_INT 2
90014: PUSH
90015: LD_INT 30
90017: PUSH
90018: LD_INT 6
90020: PUSH
90021: EMPTY
90022: LIST
90023: LIST
90024: PUSH
90025: LD_INT 30
90027: PUSH
90028: LD_INT 7
90030: PUSH
90031: EMPTY
90032: LIST
90033: LIST
90034: PUSH
90035: LD_INT 30
90037: PUSH
90038: LD_INT 8
90040: PUSH
90041: EMPTY
90042: LIST
90043: LIST
90044: PUSH
90045: EMPTY
90046: LIST
90047: LIST
90048: LIST
90049: LIST
90050: PPUSH
90051: CALL_OW 72
90055: AND
90056: PUSH
90057: LD_EXP 178
90061: PUSH
90062: LD_VAR 0 1
90066: ARRAY
90067: PPUSH
90068: LD_INT 30
90070: PUSH
90071: LD_INT 3
90073: PUSH
90074: EMPTY
90075: LIST
90076: LIST
90077: PPUSH
90078: CALL_OW 72
90082: NOT
90083: AND
90084: IFFALSE 90298
// begin if sci >= 6 then
90086: LD_VAR 0 8
90090: PUSH
90091: LD_INT 6
90093: GREATEREQUAL
90094: IFFALSE 90098
// exit ;
90096: GO 92517
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
90098: LD_ADDR_EXP 220
90102: PUSH
90103: LD_EXP 220
90107: PPUSH
90108: LD_VAR 0 1
90112: PPUSH
90113: LD_INT 2
90115: PPUSH
90116: CALL_OW 1
90120: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
90121: LD_ADDR_VAR 0 9
90125: PUSH
90126: LD_VAR 0 4
90130: PUSH
90131: LD_VAR 0 8
90135: DIFF
90136: PPUSH
90137: LD_INT 4
90139: PPUSH
90140: CALL 54467 0 2
90144: ST_TO_ADDR
// p := [ ] ;
90145: LD_ADDR_VAR 0 11
90149: PUSH
90150: EMPTY
90151: ST_TO_ADDR
// if sci < 6 and sort > 6 then
90152: LD_VAR 0 8
90156: PUSH
90157: LD_INT 6
90159: LESS
90160: PUSH
90161: LD_VAR 0 9
90165: PUSH
90166: LD_INT 6
90168: GREATER
90169: AND
90170: IFFALSE 90251
// begin for i = 1 to 6 - sci do
90172: LD_ADDR_VAR 0 3
90176: PUSH
90177: DOUBLE
90178: LD_INT 1
90180: DEC
90181: ST_TO_ADDR
90182: LD_INT 6
90184: PUSH
90185: LD_VAR 0 8
90189: MINUS
90190: PUSH
90191: FOR_TO
90192: IFFALSE 90247
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
90194: LD_ADDR_VAR 0 11
90198: PUSH
90199: LD_VAR 0 11
90203: PPUSH
90204: LD_VAR 0 11
90208: PUSH
90209: LD_INT 1
90211: PLUS
90212: PPUSH
90213: LD_VAR 0 9
90217: PUSH
90218: LD_INT 1
90220: ARRAY
90221: PPUSH
90222: CALL_OW 2
90226: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
90227: LD_ADDR_VAR 0 9
90231: PUSH
90232: LD_VAR 0 9
90236: PPUSH
90237: LD_INT 1
90239: PPUSH
90240: CALL_OW 3
90244: ST_TO_ADDR
// end ;
90245: GO 90191
90247: POP
90248: POP
// end else
90249: GO 90271
// if sort then
90251: LD_VAR 0 9
90255: IFFALSE 90271
// p := sort [ 1 ] ;
90257: LD_ADDR_VAR 0 11
90261: PUSH
90262: LD_VAR 0 9
90266: PUSH
90267: LD_INT 1
90269: ARRAY
90270: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
90271: LD_ADDR_VAR 0 2
90275: PUSH
90276: LD_INT 0
90278: PUSH
90279: LD_INT 0
90281: PUSH
90282: LD_INT 0
90284: PUSH
90285: LD_VAR 0 11
90289: PUSH
90290: EMPTY
90291: LIST
90292: LIST
90293: LIST
90294: LIST
90295: ST_TO_ADDR
// exit ;
90296: GO 92517
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
90298: LD_EXP 205
90302: PUSH
90303: LD_EXP 204
90307: PUSH
90308: LD_VAR 0 1
90312: ARRAY
90313: ARRAY
90314: PUSH
90315: LD_EXP 178
90319: PUSH
90320: LD_VAR 0 1
90324: ARRAY
90325: PPUSH
90326: LD_INT 2
90328: PUSH
90329: LD_INT 30
90331: PUSH
90332: LD_INT 6
90334: PUSH
90335: EMPTY
90336: LIST
90337: LIST
90338: PUSH
90339: LD_INT 30
90341: PUSH
90342: LD_INT 7
90344: PUSH
90345: EMPTY
90346: LIST
90347: LIST
90348: PUSH
90349: LD_INT 30
90351: PUSH
90352: LD_INT 8
90354: PUSH
90355: EMPTY
90356: LIST
90357: LIST
90358: PUSH
90359: EMPTY
90360: LIST
90361: LIST
90362: LIST
90363: LIST
90364: PPUSH
90365: CALL_OW 72
90369: AND
90370: PUSH
90371: LD_EXP 178
90375: PUSH
90376: LD_VAR 0 1
90380: ARRAY
90381: PPUSH
90382: LD_INT 30
90384: PUSH
90385: LD_INT 3
90387: PUSH
90388: EMPTY
90389: LIST
90390: LIST
90391: PPUSH
90392: CALL_OW 72
90396: AND
90397: IFFALSE 91131
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
90399: LD_ADDR_EXP 220
90403: PUSH
90404: LD_EXP 220
90408: PPUSH
90409: LD_VAR 0 1
90413: PPUSH
90414: LD_INT 3
90416: PPUSH
90417: CALL_OW 1
90421: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
90422: LD_ADDR_VAR 0 2
90426: PUSH
90427: LD_INT 0
90429: PUSH
90430: LD_INT 0
90432: PUSH
90433: LD_INT 0
90435: PUSH
90436: LD_INT 0
90438: PUSH
90439: EMPTY
90440: LIST
90441: LIST
90442: LIST
90443: LIST
90444: ST_TO_ADDR
// if not eng then
90445: LD_VAR 0 6
90449: NOT
90450: IFFALSE 90513
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
90452: LD_ADDR_VAR 0 11
90456: PUSH
90457: LD_VAR 0 4
90461: PPUSH
90462: LD_INT 2
90464: PPUSH
90465: CALL 54467 0 2
90469: PUSH
90470: LD_INT 1
90472: ARRAY
90473: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
90474: LD_ADDR_VAR 0 2
90478: PUSH
90479: LD_VAR 0 2
90483: PPUSH
90484: LD_INT 2
90486: PPUSH
90487: LD_VAR 0 11
90491: PPUSH
90492: CALL_OW 1
90496: ST_TO_ADDR
// tmp := tmp diff p ;
90497: LD_ADDR_VAR 0 4
90501: PUSH
90502: LD_VAR 0 4
90506: PUSH
90507: LD_VAR 0 11
90511: DIFF
90512: ST_TO_ADDR
// end ; if tmp and sci < 6 then
90513: LD_VAR 0 4
90517: PUSH
90518: LD_VAR 0 8
90522: PUSH
90523: LD_INT 6
90525: LESS
90526: AND
90527: IFFALSE 90715
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
90529: LD_ADDR_VAR 0 9
90533: PUSH
90534: LD_VAR 0 4
90538: PUSH
90539: LD_VAR 0 8
90543: PUSH
90544: LD_VAR 0 7
90548: UNION
90549: DIFF
90550: PPUSH
90551: LD_INT 4
90553: PPUSH
90554: CALL 54467 0 2
90558: ST_TO_ADDR
// p := [ ] ;
90559: LD_ADDR_VAR 0 11
90563: PUSH
90564: EMPTY
90565: ST_TO_ADDR
// if sort then
90566: LD_VAR 0 9
90570: IFFALSE 90686
// for i = 1 to 6 - sci do
90572: LD_ADDR_VAR 0 3
90576: PUSH
90577: DOUBLE
90578: LD_INT 1
90580: DEC
90581: ST_TO_ADDR
90582: LD_INT 6
90584: PUSH
90585: LD_VAR 0 8
90589: MINUS
90590: PUSH
90591: FOR_TO
90592: IFFALSE 90684
// begin if i = sort then
90594: LD_VAR 0 3
90598: PUSH
90599: LD_VAR 0 9
90603: EQUAL
90604: IFFALSE 90608
// break ;
90606: GO 90684
// if GetClass ( i ) = 4 then
90608: LD_VAR 0 3
90612: PPUSH
90613: CALL_OW 257
90617: PUSH
90618: LD_INT 4
90620: EQUAL
90621: IFFALSE 90625
// continue ;
90623: GO 90591
// p := Insert ( p , p + 1 , sort [ i ] ) ;
90625: LD_ADDR_VAR 0 11
90629: PUSH
90630: LD_VAR 0 11
90634: PPUSH
90635: LD_VAR 0 11
90639: PUSH
90640: LD_INT 1
90642: PLUS
90643: PPUSH
90644: LD_VAR 0 9
90648: PUSH
90649: LD_VAR 0 3
90653: ARRAY
90654: PPUSH
90655: CALL_OW 2
90659: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
90660: LD_ADDR_VAR 0 4
90664: PUSH
90665: LD_VAR 0 4
90669: PUSH
90670: LD_VAR 0 9
90674: PUSH
90675: LD_VAR 0 3
90679: ARRAY
90680: DIFF
90681: ST_TO_ADDR
// end ;
90682: GO 90591
90684: POP
90685: POP
// if p then
90686: LD_VAR 0 11
90690: IFFALSE 90715
// result := Replace ( result , 4 , p ) ;
90692: LD_ADDR_VAR 0 2
90696: PUSH
90697: LD_VAR 0 2
90701: PPUSH
90702: LD_INT 4
90704: PPUSH
90705: LD_VAR 0 11
90709: PPUSH
90710: CALL_OW 1
90714: ST_TO_ADDR
// end ; if tmp and mech < 6 then
90715: LD_VAR 0 4
90719: PUSH
90720: LD_VAR 0 7
90724: PUSH
90725: LD_INT 6
90727: LESS
90728: AND
90729: IFFALSE 90917
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
90731: LD_ADDR_VAR 0 9
90735: PUSH
90736: LD_VAR 0 4
90740: PUSH
90741: LD_VAR 0 8
90745: PUSH
90746: LD_VAR 0 7
90750: UNION
90751: DIFF
90752: PPUSH
90753: LD_INT 3
90755: PPUSH
90756: CALL 54467 0 2
90760: ST_TO_ADDR
// p := [ ] ;
90761: LD_ADDR_VAR 0 11
90765: PUSH
90766: EMPTY
90767: ST_TO_ADDR
// if sort then
90768: LD_VAR 0 9
90772: IFFALSE 90888
// for i = 1 to 6 - mech do
90774: LD_ADDR_VAR 0 3
90778: PUSH
90779: DOUBLE
90780: LD_INT 1
90782: DEC
90783: ST_TO_ADDR
90784: LD_INT 6
90786: PUSH
90787: LD_VAR 0 7
90791: MINUS
90792: PUSH
90793: FOR_TO
90794: IFFALSE 90886
// begin if i = sort then
90796: LD_VAR 0 3
90800: PUSH
90801: LD_VAR 0 9
90805: EQUAL
90806: IFFALSE 90810
// break ;
90808: GO 90886
// if GetClass ( i ) = 3 then
90810: LD_VAR 0 3
90814: PPUSH
90815: CALL_OW 257
90819: PUSH
90820: LD_INT 3
90822: EQUAL
90823: IFFALSE 90827
// continue ;
90825: GO 90793
// p := Insert ( p , p + 1 , sort [ i ] ) ;
90827: LD_ADDR_VAR 0 11
90831: PUSH
90832: LD_VAR 0 11
90836: PPUSH
90837: LD_VAR 0 11
90841: PUSH
90842: LD_INT 1
90844: PLUS
90845: PPUSH
90846: LD_VAR 0 9
90850: PUSH
90851: LD_VAR 0 3
90855: ARRAY
90856: PPUSH
90857: CALL_OW 2
90861: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
90862: LD_ADDR_VAR 0 4
90866: PUSH
90867: LD_VAR 0 4
90871: PUSH
90872: LD_VAR 0 9
90876: PUSH
90877: LD_VAR 0 3
90881: ARRAY
90882: DIFF
90883: ST_TO_ADDR
// end ;
90884: GO 90793
90886: POP
90887: POP
// if p then
90888: LD_VAR 0 11
90892: IFFALSE 90917
// result := Replace ( result , 3 , p ) ;
90894: LD_ADDR_VAR 0 2
90898: PUSH
90899: LD_VAR 0 2
90903: PPUSH
90904: LD_INT 3
90906: PPUSH
90907: LD_VAR 0 11
90911: PPUSH
90912: CALL_OW 1
90916: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
90917: LD_VAR 0 4
90921: PUSH
90922: LD_INT 6
90924: GREATER
90925: PUSH
90926: LD_VAR 0 6
90930: PUSH
90931: LD_INT 6
90933: LESS
90934: AND
90935: IFFALSE 91129
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
90937: LD_ADDR_VAR 0 9
90941: PUSH
90942: LD_VAR 0 4
90946: PUSH
90947: LD_VAR 0 8
90951: PUSH
90952: LD_VAR 0 7
90956: UNION
90957: PUSH
90958: LD_VAR 0 6
90962: UNION
90963: DIFF
90964: PPUSH
90965: LD_INT 2
90967: PPUSH
90968: CALL 54467 0 2
90972: ST_TO_ADDR
// p := [ ] ;
90973: LD_ADDR_VAR 0 11
90977: PUSH
90978: EMPTY
90979: ST_TO_ADDR
// if sort then
90980: LD_VAR 0 9
90984: IFFALSE 91100
// for i = 1 to 6 - eng do
90986: LD_ADDR_VAR 0 3
90990: PUSH
90991: DOUBLE
90992: LD_INT 1
90994: DEC
90995: ST_TO_ADDR
90996: LD_INT 6
90998: PUSH
90999: LD_VAR 0 6
91003: MINUS
91004: PUSH
91005: FOR_TO
91006: IFFALSE 91098
// begin if i = sort then
91008: LD_VAR 0 3
91012: PUSH
91013: LD_VAR 0 9
91017: EQUAL
91018: IFFALSE 91022
// break ;
91020: GO 91098
// if GetClass ( i ) = 2 then
91022: LD_VAR 0 3
91026: PPUSH
91027: CALL_OW 257
91031: PUSH
91032: LD_INT 2
91034: EQUAL
91035: IFFALSE 91039
// continue ;
91037: GO 91005
// p := Insert ( p , p + 1 , sort [ i ] ) ;
91039: LD_ADDR_VAR 0 11
91043: PUSH
91044: LD_VAR 0 11
91048: PPUSH
91049: LD_VAR 0 11
91053: PUSH
91054: LD_INT 1
91056: PLUS
91057: PPUSH
91058: LD_VAR 0 9
91062: PUSH
91063: LD_VAR 0 3
91067: ARRAY
91068: PPUSH
91069: CALL_OW 2
91073: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
91074: LD_ADDR_VAR 0 4
91078: PUSH
91079: LD_VAR 0 4
91083: PUSH
91084: LD_VAR 0 9
91088: PUSH
91089: LD_VAR 0 3
91093: ARRAY
91094: DIFF
91095: ST_TO_ADDR
// end ;
91096: GO 91005
91098: POP
91099: POP
// if p then
91100: LD_VAR 0 11
91104: IFFALSE 91129
// result := Replace ( result , 2 , p ) ;
91106: LD_ADDR_VAR 0 2
91110: PUSH
91111: LD_VAR 0 2
91115: PPUSH
91116: LD_INT 2
91118: PPUSH
91119: LD_VAR 0 11
91123: PPUSH
91124: CALL_OW 1
91128: ST_TO_ADDR
// end ; exit ;
91129: GO 92517
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
91131: LD_EXP 205
91135: PUSH
91136: LD_EXP 204
91140: PUSH
91141: LD_VAR 0 1
91145: ARRAY
91146: ARRAY
91147: NOT
91148: PUSH
91149: LD_EXP 178
91153: PUSH
91154: LD_VAR 0 1
91158: ARRAY
91159: PPUSH
91160: LD_INT 30
91162: PUSH
91163: LD_INT 3
91165: PUSH
91166: EMPTY
91167: LIST
91168: LIST
91169: PPUSH
91170: CALL_OW 72
91174: AND
91175: PUSH
91176: LD_EXP 183
91180: PUSH
91181: LD_VAR 0 1
91185: ARRAY
91186: AND
91187: IFFALSE 91795
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
91189: LD_ADDR_EXP 220
91193: PUSH
91194: LD_EXP 220
91198: PPUSH
91199: LD_VAR 0 1
91203: PPUSH
91204: LD_INT 5
91206: PPUSH
91207: CALL_OW 1
91211: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
91212: LD_ADDR_VAR 0 2
91216: PUSH
91217: LD_INT 0
91219: PUSH
91220: LD_INT 0
91222: PUSH
91223: LD_INT 0
91225: PUSH
91226: LD_INT 0
91228: PUSH
91229: EMPTY
91230: LIST
91231: LIST
91232: LIST
91233: LIST
91234: ST_TO_ADDR
// if sci > 1 then
91235: LD_VAR 0 8
91239: PUSH
91240: LD_INT 1
91242: GREATER
91243: IFFALSE 91271
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
91245: LD_ADDR_VAR 0 4
91249: PUSH
91250: LD_VAR 0 4
91254: PUSH
91255: LD_VAR 0 8
91259: PUSH
91260: LD_VAR 0 8
91264: PUSH
91265: LD_INT 1
91267: ARRAY
91268: DIFF
91269: DIFF
91270: ST_TO_ADDR
// if tmp and not sci then
91271: LD_VAR 0 4
91275: PUSH
91276: LD_VAR 0 8
91280: NOT
91281: AND
91282: IFFALSE 91351
// begin sort := SortBySkill ( tmp , 4 ) ;
91284: LD_ADDR_VAR 0 9
91288: PUSH
91289: LD_VAR 0 4
91293: PPUSH
91294: LD_INT 4
91296: PPUSH
91297: CALL 54467 0 2
91301: ST_TO_ADDR
// if sort then
91302: LD_VAR 0 9
91306: IFFALSE 91322
// p := sort [ 1 ] ;
91308: LD_ADDR_VAR 0 11
91312: PUSH
91313: LD_VAR 0 9
91317: PUSH
91318: LD_INT 1
91320: ARRAY
91321: ST_TO_ADDR
// if p then
91322: LD_VAR 0 11
91326: IFFALSE 91351
// result := Replace ( result , 4 , p ) ;
91328: LD_ADDR_VAR 0 2
91332: PUSH
91333: LD_VAR 0 2
91337: PPUSH
91338: LD_INT 4
91340: PPUSH
91341: LD_VAR 0 11
91345: PPUSH
91346: CALL_OW 1
91350: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
91351: LD_ADDR_VAR 0 4
91355: PUSH
91356: LD_VAR 0 4
91360: PUSH
91361: LD_VAR 0 7
91365: DIFF
91366: ST_TO_ADDR
// if tmp and mech < 6 then
91367: LD_VAR 0 4
91371: PUSH
91372: LD_VAR 0 7
91376: PUSH
91377: LD_INT 6
91379: LESS
91380: AND
91381: IFFALSE 91569
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
91383: LD_ADDR_VAR 0 9
91387: PUSH
91388: LD_VAR 0 4
91392: PUSH
91393: LD_VAR 0 8
91397: PUSH
91398: LD_VAR 0 7
91402: UNION
91403: DIFF
91404: PPUSH
91405: LD_INT 3
91407: PPUSH
91408: CALL 54467 0 2
91412: ST_TO_ADDR
// p := [ ] ;
91413: LD_ADDR_VAR 0 11
91417: PUSH
91418: EMPTY
91419: ST_TO_ADDR
// if sort then
91420: LD_VAR 0 9
91424: IFFALSE 91540
// for i = 1 to 6 - mech do
91426: LD_ADDR_VAR 0 3
91430: PUSH
91431: DOUBLE
91432: LD_INT 1
91434: DEC
91435: ST_TO_ADDR
91436: LD_INT 6
91438: PUSH
91439: LD_VAR 0 7
91443: MINUS
91444: PUSH
91445: FOR_TO
91446: IFFALSE 91538
// begin if i = sort then
91448: LD_VAR 0 3
91452: PUSH
91453: LD_VAR 0 9
91457: EQUAL
91458: IFFALSE 91462
// break ;
91460: GO 91538
// if GetClass ( i ) = 3 then
91462: LD_VAR 0 3
91466: PPUSH
91467: CALL_OW 257
91471: PUSH
91472: LD_INT 3
91474: EQUAL
91475: IFFALSE 91479
// continue ;
91477: GO 91445
// p := Insert ( p , p + 1 , sort [ i ] ) ;
91479: LD_ADDR_VAR 0 11
91483: PUSH
91484: LD_VAR 0 11
91488: PPUSH
91489: LD_VAR 0 11
91493: PUSH
91494: LD_INT 1
91496: PLUS
91497: PPUSH
91498: LD_VAR 0 9
91502: PUSH
91503: LD_VAR 0 3
91507: ARRAY
91508: PPUSH
91509: CALL_OW 2
91513: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
91514: LD_ADDR_VAR 0 4
91518: PUSH
91519: LD_VAR 0 4
91523: PUSH
91524: LD_VAR 0 9
91528: PUSH
91529: LD_VAR 0 3
91533: ARRAY
91534: DIFF
91535: ST_TO_ADDR
// end ;
91536: GO 91445
91538: POP
91539: POP
// if p then
91540: LD_VAR 0 11
91544: IFFALSE 91569
// result := Replace ( result , 3 , p ) ;
91546: LD_ADDR_VAR 0 2
91550: PUSH
91551: LD_VAR 0 2
91555: PPUSH
91556: LD_INT 3
91558: PPUSH
91559: LD_VAR 0 11
91563: PPUSH
91564: CALL_OW 1
91568: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
91569: LD_ADDR_VAR 0 4
91573: PUSH
91574: LD_VAR 0 4
91578: PUSH
91579: LD_VAR 0 6
91583: DIFF
91584: ST_TO_ADDR
// if tmp and eng < 6 then
91585: LD_VAR 0 4
91589: PUSH
91590: LD_VAR 0 6
91594: PUSH
91595: LD_INT 6
91597: LESS
91598: AND
91599: IFFALSE 91793
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
91601: LD_ADDR_VAR 0 9
91605: PUSH
91606: LD_VAR 0 4
91610: PUSH
91611: LD_VAR 0 8
91615: PUSH
91616: LD_VAR 0 7
91620: UNION
91621: PUSH
91622: LD_VAR 0 6
91626: UNION
91627: DIFF
91628: PPUSH
91629: LD_INT 2
91631: PPUSH
91632: CALL 54467 0 2
91636: ST_TO_ADDR
// p := [ ] ;
91637: LD_ADDR_VAR 0 11
91641: PUSH
91642: EMPTY
91643: ST_TO_ADDR
// if sort then
91644: LD_VAR 0 9
91648: IFFALSE 91764
// for i = 1 to 6 - eng do
91650: LD_ADDR_VAR 0 3
91654: PUSH
91655: DOUBLE
91656: LD_INT 1
91658: DEC
91659: ST_TO_ADDR
91660: LD_INT 6
91662: PUSH
91663: LD_VAR 0 6
91667: MINUS
91668: PUSH
91669: FOR_TO
91670: IFFALSE 91762
// begin if i = sort then
91672: LD_VAR 0 3
91676: PUSH
91677: LD_VAR 0 9
91681: EQUAL
91682: IFFALSE 91686
// break ;
91684: GO 91762
// if GetClass ( i ) = 2 then
91686: LD_VAR 0 3
91690: PPUSH
91691: CALL_OW 257
91695: PUSH
91696: LD_INT 2
91698: EQUAL
91699: IFFALSE 91703
// continue ;
91701: GO 91669
// p := Insert ( p , p + 1 , sort [ i ] ) ;
91703: LD_ADDR_VAR 0 11
91707: PUSH
91708: LD_VAR 0 11
91712: PPUSH
91713: LD_VAR 0 11
91717: PUSH
91718: LD_INT 1
91720: PLUS
91721: PPUSH
91722: LD_VAR 0 9
91726: PUSH
91727: LD_VAR 0 3
91731: ARRAY
91732: PPUSH
91733: CALL_OW 2
91737: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
91738: LD_ADDR_VAR 0 4
91742: PUSH
91743: LD_VAR 0 4
91747: PUSH
91748: LD_VAR 0 9
91752: PUSH
91753: LD_VAR 0 3
91757: ARRAY
91758: DIFF
91759: ST_TO_ADDR
// end ;
91760: GO 91669
91762: POP
91763: POP
// if p then
91764: LD_VAR 0 11
91768: IFFALSE 91793
// result := Replace ( result , 2 , p ) ;
91770: LD_ADDR_VAR 0 2
91774: PUSH
91775: LD_VAR 0 2
91779: PPUSH
91780: LD_INT 2
91782: PPUSH
91783: LD_VAR 0 11
91787: PPUSH
91788: CALL_OW 1
91792: ST_TO_ADDR
// end ; exit ;
91793: GO 92517
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
91795: LD_EXP 205
91799: PUSH
91800: LD_EXP 204
91804: PUSH
91805: LD_VAR 0 1
91809: ARRAY
91810: ARRAY
91811: NOT
91812: PUSH
91813: LD_EXP 178
91817: PUSH
91818: LD_VAR 0 1
91822: ARRAY
91823: PPUSH
91824: LD_INT 30
91826: PUSH
91827: LD_INT 3
91829: PUSH
91830: EMPTY
91831: LIST
91832: LIST
91833: PPUSH
91834: CALL_OW 72
91838: AND
91839: PUSH
91840: LD_EXP 183
91844: PUSH
91845: LD_VAR 0 1
91849: ARRAY
91850: NOT
91851: AND
91852: IFFALSE 92517
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
91854: LD_ADDR_EXP 220
91858: PUSH
91859: LD_EXP 220
91863: PPUSH
91864: LD_VAR 0 1
91868: PPUSH
91869: LD_INT 6
91871: PPUSH
91872: CALL_OW 1
91876: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
91877: LD_ADDR_VAR 0 2
91881: PUSH
91882: LD_INT 0
91884: PUSH
91885: LD_INT 0
91887: PUSH
91888: LD_INT 0
91890: PUSH
91891: LD_INT 0
91893: PUSH
91894: EMPTY
91895: LIST
91896: LIST
91897: LIST
91898: LIST
91899: ST_TO_ADDR
// if sci >= 1 then
91900: LD_VAR 0 8
91904: PUSH
91905: LD_INT 1
91907: GREATEREQUAL
91908: IFFALSE 91930
// tmp := tmp diff sci [ 1 ] ;
91910: LD_ADDR_VAR 0 4
91914: PUSH
91915: LD_VAR 0 4
91919: PUSH
91920: LD_VAR 0 8
91924: PUSH
91925: LD_INT 1
91927: ARRAY
91928: DIFF
91929: ST_TO_ADDR
// if tmp and not sci then
91930: LD_VAR 0 4
91934: PUSH
91935: LD_VAR 0 8
91939: NOT
91940: AND
91941: IFFALSE 92010
// begin sort := SortBySkill ( tmp , 4 ) ;
91943: LD_ADDR_VAR 0 9
91947: PUSH
91948: LD_VAR 0 4
91952: PPUSH
91953: LD_INT 4
91955: PPUSH
91956: CALL 54467 0 2
91960: ST_TO_ADDR
// if sort then
91961: LD_VAR 0 9
91965: IFFALSE 91981
// p := sort [ 1 ] ;
91967: LD_ADDR_VAR 0 11
91971: PUSH
91972: LD_VAR 0 9
91976: PUSH
91977: LD_INT 1
91979: ARRAY
91980: ST_TO_ADDR
// if p then
91981: LD_VAR 0 11
91985: IFFALSE 92010
// result := Replace ( result , 4 , p ) ;
91987: LD_ADDR_VAR 0 2
91991: PUSH
91992: LD_VAR 0 2
91996: PPUSH
91997: LD_INT 4
91999: PPUSH
92000: LD_VAR 0 11
92004: PPUSH
92005: CALL_OW 1
92009: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
92010: LD_ADDR_VAR 0 4
92014: PUSH
92015: LD_VAR 0 4
92019: PUSH
92020: LD_VAR 0 7
92024: DIFF
92025: ST_TO_ADDR
// if tmp and mech < 6 then
92026: LD_VAR 0 4
92030: PUSH
92031: LD_VAR 0 7
92035: PUSH
92036: LD_INT 6
92038: LESS
92039: AND
92040: IFFALSE 92222
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
92042: LD_ADDR_VAR 0 9
92046: PUSH
92047: LD_VAR 0 4
92051: PUSH
92052: LD_VAR 0 7
92056: DIFF
92057: PPUSH
92058: LD_INT 3
92060: PPUSH
92061: CALL 54467 0 2
92065: ST_TO_ADDR
// p := [ ] ;
92066: LD_ADDR_VAR 0 11
92070: PUSH
92071: EMPTY
92072: ST_TO_ADDR
// if sort then
92073: LD_VAR 0 9
92077: IFFALSE 92193
// for i = 1 to 6 - mech do
92079: LD_ADDR_VAR 0 3
92083: PUSH
92084: DOUBLE
92085: LD_INT 1
92087: DEC
92088: ST_TO_ADDR
92089: LD_INT 6
92091: PUSH
92092: LD_VAR 0 7
92096: MINUS
92097: PUSH
92098: FOR_TO
92099: IFFALSE 92191
// begin if i = sort then
92101: LD_VAR 0 3
92105: PUSH
92106: LD_VAR 0 9
92110: EQUAL
92111: IFFALSE 92115
// break ;
92113: GO 92191
// if GetClass ( i ) = 3 then
92115: LD_VAR 0 3
92119: PPUSH
92120: CALL_OW 257
92124: PUSH
92125: LD_INT 3
92127: EQUAL
92128: IFFALSE 92132
// continue ;
92130: GO 92098
// p := Insert ( p , p + 1 , sort [ i ] ) ;
92132: LD_ADDR_VAR 0 11
92136: PUSH
92137: LD_VAR 0 11
92141: PPUSH
92142: LD_VAR 0 11
92146: PUSH
92147: LD_INT 1
92149: PLUS
92150: PPUSH
92151: LD_VAR 0 9
92155: PUSH
92156: LD_VAR 0 3
92160: ARRAY
92161: PPUSH
92162: CALL_OW 2
92166: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
92167: LD_ADDR_VAR 0 4
92171: PUSH
92172: LD_VAR 0 4
92176: PUSH
92177: LD_VAR 0 9
92181: PUSH
92182: LD_VAR 0 3
92186: ARRAY
92187: DIFF
92188: ST_TO_ADDR
// end ;
92189: GO 92098
92191: POP
92192: POP
// if p then
92193: LD_VAR 0 11
92197: IFFALSE 92222
// result := Replace ( result , 3 , p ) ;
92199: LD_ADDR_VAR 0 2
92203: PUSH
92204: LD_VAR 0 2
92208: PPUSH
92209: LD_INT 3
92211: PPUSH
92212: LD_VAR 0 11
92216: PPUSH
92217: CALL_OW 1
92221: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
92222: LD_ADDR_VAR 0 4
92226: PUSH
92227: LD_VAR 0 4
92231: PUSH
92232: LD_VAR 0 6
92236: DIFF
92237: ST_TO_ADDR
// if tmp and eng < 4 then
92238: LD_VAR 0 4
92242: PUSH
92243: LD_VAR 0 6
92247: PUSH
92248: LD_INT 4
92250: LESS
92251: AND
92252: IFFALSE 92442
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
92254: LD_ADDR_VAR 0 9
92258: PUSH
92259: LD_VAR 0 4
92263: PUSH
92264: LD_VAR 0 7
92268: PUSH
92269: LD_VAR 0 6
92273: UNION
92274: DIFF
92275: PPUSH
92276: LD_INT 2
92278: PPUSH
92279: CALL 54467 0 2
92283: ST_TO_ADDR
// p := [ ] ;
92284: LD_ADDR_VAR 0 11
92288: PUSH
92289: EMPTY
92290: ST_TO_ADDR
// if sort then
92291: LD_VAR 0 9
92295: IFFALSE 92411
// for i = 1 to 4 - eng do
92297: LD_ADDR_VAR 0 3
92301: PUSH
92302: DOUBLE
92303: LD_INT 1
92305: DEC
92306: ST_TO_ADDR
92307: LD_INT 4
92309: PUSH
92310: LD_VAR 0 6
92314: MINUS
92315: PUSH
92316: FOR_TO
92317: IFFALSE 92409
// begin if i = sort then
92319: LD_VAR 0 3
92323: PUSH
92324: LD_VAR 0 9
92328: EQUAL
92329: IFFALSE 92333
// break ;
92331: GO 92409
// if GetClass ( i ) = 2 then
92333: LD_VAR 0 3
92337: PPUSH
92338: CALL_OW 257
92342: PUSH
92343: LD_INT 2
92345: EQUAL
92346: IFFALSE 92350
// continue ;
92348: GO 92316
// p := Insert ( p , p + 1 , sort [ i ] ) ;
92350: LD_ADDR_VAR 0 11
92354: PUSH
92355: LD_VAR 0 11
92359: PPUSH
92360: LD_VAR 0 11
92364: PUSH
92365: LD_INT 1
92367: PLUS
92368: PPUSH
92369: LD_VAR 0 9
92373: PUSH
92374: LD_VAR 0 3
92378: ARRAY
92379: PPUSH
92380: CALL_OW 2
92384: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
92385: LD_ADDR_VAR 0 4
92389: PUSH
92390: LD_VAR 0 4
92394: PUSH
92395: LD_VAR 0 9
92399: PUSH
92400: LD_VAR 0 3
92404: ARRAY
92405: DIFF
92406: ST_TO_ADDR
// end ;
92407: GO 92316
92409: POP
92410: POP
// if p then
92411: LD_VAR 0 11
92415: IFFALSE 92440
// result := Replace ( result , 2 , p ) ;
92417: LD_ADDR_VAR 0 2
92421: PUSH
92422: LD_VAR 0 2
92426: PPUSH
92427: LD_INT 2
92429: PPUSH
92430: LD_VAR 0 11
92434: PPUSH
92435: CALL_OW 1
92439: ST_TO_ADDR
// end else
92440: GO 92486
// for i = eng downto 5 do
92442: LD_ADDR_VAR 0 3
92446: PUSH
92447: DOUBLE
92448: LD_VAR 0 6
92452: INC
92453: ST_TO_ADDR
92454: LD_INT 5
92456: PUSH
92457: FOR_DOWNTO
92458: IFFALSE 92484
// tmp := tmp union eng [ i ] ;
92460: LD_ADDR_VAR 0 4
92464: PUSH
92465: LD_VAR 0 4
92469: PUSH
92470: LD_VAR 0 6
92474: PUSH
92475: LD_VAR 0 3
92479: ARRAY
92480: UNION
92481: ST_TO_ADDR
92482: GO 92457
92484: POP
92485: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
92486: LD_ADDR_VAR 0 2
92490: PUSH
92491: LD_VAR 0 2
92495: PPUSH
92496: LD_INT 1
92498: PPUSH
92499: LD_VAR 0 4
92503: PUSH
92504: LD_VAR 0 5
92508: DIFF
92509: PPUSH
92510: CALL_OW 1
92514: ST_TO_ADDR
// exit ;
92515: GO 92517
// end ; end ;
92517: LD_VAR 0 2
92521: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
92522: LD_INT 0
92524: PPUSH
92525: PPUSH
92526: PPUSH
// if not mc_bases then
92527: LD_EXP 178
92531: NOT
92532: IFFALSE 92536
// exit ;
92534: GO 92678
// for i = 1 to mc_bases do
92536: LD_ADDR_VAR 0 2
92540: PUSH
92541: DOUBLE
92542: LD_INT 1
92544: DEC
92545: ST_TO_ADDR
92546: LD_EXP 178
92550: PUSH
92551: FOR_TO
92552: IFFALSE 92669
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
92554: LD_ADDR_VAR 0 3
92558: PUSH
92559: LD_EXP 178
92563: PUSH
92564: LD_VAR 0 2
92568: ARRAY
92569: PPUSH
92570: LD_INT 21
92572: PUSH
92573: LD_INT 3
92575: PUSH
92576: EMPTY
92577: LIST
92578: LIST
92579: PUSH
92580: LD_INT 3
92582: PUSH
92583: LD_INT 2
92585: PUSH
92586: LD_INT 30
92588: PUSH
92589: LD_INT 29
92591: PUSH
92592: EMPTY
92593: LIST
92594: LIST
92595: PUSH
92596: LD_INT 30
92598: PUSH
92599: LD_INT 30
92601: PUSH
92602: EMPTY
92603: LIST
92604: LIST
92605: PUSH
92606: EMPTY
92607: LIST
92608: LIST
92609: LIST
92610: PUSH
92611: EMPTY
92612: LIST
92613: LIST
92614: PUSH
92615: LD_INT 3
92617: PUSH
92618: LD_INT 24
92620: PUSH
92621: LD_INT 1000
92623: PUSH
92624: EMPTY
92625: LIST
92626: LIST
92627: PUSH
92628: EMPTY
92629: LIST
92630: LIST
92631: PUSH
92632: EMPTY
92633: LIST
92634: LIST
92635: LIST
92636: PPUSH
92637: CALL_OW 72
92641: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
92642: LD_ADDR_EXP 179
92646: PUSH
92647: LD_EXP 179
92651: PPUSH
92652: LD_VAR 0 2
92656: PPUSH
92657: LD_VAR 0 3
92661: PPUSH
92662: CALL_OW 1
92666: ST_TO_ADDR
// end ;
92667: GO 92551
92669: POP
92670: POP
// RaiseSailEvent ( 101 ) ;
92671: LD_INT 101
92673: PPUSH
92674: CALL_OW 427
// end ;
92678: LD_VAR 0 1
92682: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
92683: LD_INT 0
92685: PPUSH
92686: PPUSH
92687: PPUSH
92688: PPUSH
92689: PPUSH
92690: PPUSH
92691: PPUSH
// if not mc_bases then
92692: LD_EXP 178
92696: NOT
92697: IFFALSE 92701
// exit ;
92699: GO 93263
// for i = 1 to mc_bases do
92701: LD_ADDR_VAR 0 2
92705: PUSH
92706: DOUBLE
92707: LD_INT 1
92709: DEC
92710: ST_TO_ADDR
92711: LD_EXP 178
92715: PUSH
92716: FOR_TO
92717: IFFALSE 93254
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 1000 ] ] ] ] ) ;
92719: LD_ADDR_VAR 0 5
92723: PUSH
92724: LD_EXP 178
92728: PUSH
92729: LD_VAR 0 2
92733: ARRAY
92734: PUSH
92735: LD_EXP 207
92739: PUSH
92740: LD_VAR 0 2
92744: ARRAY
92745: UNION
92746: PPUSH
92747: LD_INT 21
92749: PUSH
92750: LD_INT 1
92752: PUSH
92753: EMPTY
92754: LIST
92755: LIST
92756: PUSH
92757: LD_INT 1
92759: PUSH
92760: LD_INT 3
92762: PUSH
92763: LD_INT 54
92765: PUSH
92766: EMPTY
92767: LIST
92768: PUSH
92769: EMPTY
92770: LIST
92771: LIST
92772: PUSH
92773: LD_INT 3
92775: PUSH
92776: LD_INT 24
92778: PUSH
92779: LD_INT 1000
92781: PUSH
92782: EMPTY
92783: LIST
92784: LIST
92785: PUSH
92786: EMPTY
92787: LIST
92788: LIST
92789: PUSH
92790: EMPTY
92791: LIST
92792: LIST
92793: LIST
92794: PUSH
92795: EMPTY
92796: LIST
92797: LIST
92798: PPUSH
92799: CALL_OW 72
92803: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
92804: LD_ADDR_VAR 0 6
92808: PUSH
92809: LD_EXP 178
92813: PUSH
92814: LD_VAR 0 2
92818: ARRAY
92819: PPUSH
92820: LD_INT 21
92822: PUSH
92823: LD_INT 1
92825: PUSH
92826: EMPTY
92827: LIST
92828: LIST
92829: PUSH
92830: LD_INT 1
92832: PUSH
92833: LD_INT 3
92835: PUSH
92836: LD_INT 54
92838: PUSH
92839: EMPTY
92840: LIST
92841: PUSH
92842: EMPTY
92843: LIST
92844: LIST
92845: PUSH
92846: LD_INT 3
92848: PUSH
92849: LD_INT 24
92851: PUSH
92852: LD_INT 250
92854: PUSH
92855: EMPTY
92856: LIST
92857: LIST
92858: PUSH
92859: EMPTY
92860: LIST
92861: LIST
92862: PUSH
92863: EMPTY
92864: LIST
92865: LIST
92866: LIST
92867: PUSH
92868: EMPTY
92869: LIST
92870: LIST
92871: PPUSH
92872: CALL_OW 72
92876: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
92877: LD_ADDR_VAR 0 7
92881: PUSH
92882: LD_VAR 0 5
92886: PUSH
92887: LD_VAR 0 6
92891: DIFF
92892: ST_TO_ADDR
// if not need_heal_1 then
92893: LD_VAR 0 6
92897: NOT
92898: IFFALSE 92931
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
92900: LD_ADDR_EXP 181
92904: PUSH
92905: LD_EXP 181
92909: PPUSH
92910: LD_VAR 0 2
92914: PUSH
92915: LD_INT 1
92917: PUSH
92918: EMPTY
92919: LIST
92920: LIST
92921: PPUSH
92922: EMPTY
92923: PPUSH
92924: CALL 24210 0 3
92928: ST_TO_ADDR
92929: GO 93001
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
92931: LD_ADDR_EXP 181
92935: PUSH
92936: LD_EXP 181
92940: PPUSH
92941: LD_VAR 0 2
92945: PUSH
92946: LD_INT 1
92948: PUSH
92949: EMPTY
92950: LIST
92951: LIST
92952: PPUSH
92953: LD_EXP 181
92957: PUSH
92958: LD_VAR 0 2
92962: ARRAY
92963: PUSH
92964: LD_INT 1
92966: ARRAY
92967: PPUSH
92968: LD_INT 3
92970: PUSH
92971: LD_INT 24
92973: PUSH
92974: LD_INT 1000
92976: PUSH
92977: EMPTY
92978: LIST
92979: LIST
92980: PUSH
92981: EMPTY
92982: LIST
92983: LIST
92984: PPUSH
92985: CALL_OW 72
92989: PUSH
92990: LD_VAR 0 6
92994: UNION
92995: PPUSH
92996: CALL 24210 0 3
93000: ST_TO_ADDR
// if not need_heal_2 then
93001: LD_VAR 0 7
93005: NOT
93006: IFFALSE 93039
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
93008: LD_ADDR_EXP 181
93012: PUSH
93013: LD_EXP 181
93017: PPUSH
93018: LD_VAR 0 2
93022: PUSH
93023: LD_INT 2
93025: PUSH
93026: EMPTY
93027: LIST
93028: LIST
93029: PPUSH
93030: EMPTY
93031: PPUSH
93032: CALL 24210 0 3
93036: ST_TO_ADDR
93037: GO 93071
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
93039: LD_ADDR_EXP 181
93043: PUSH
93044: LD_EXP 181
93048: PPUSH
93049: LD_VAR 0 2
93053: PUSH
93054: LD_INT 2
93056: PUSH
93057: EMPTY
93058: LIST
93059: LIST
93060: PPUSH
93061: LD_VAR 0 7
93065: PPUSH
93066: CALL 24210 0 3
93070: ST_TO_ADDR
// if need_heal_2 then
93071: LD_VAR 0 7
93075: IFFALSE 93236
// for j in need_heal_2 do
93077: LD_ADDR_VAR 0 3
93081: PUSH
93082: LD_VAR 0 7
93086: PUSH
93087: FOR_IN
93088: IFFALSE 93234
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
93090: LD_ADDR_VAR 0 5
93094: PUSH
93095: LD_EXP 178
93099: PUSH
93100: LD_VAR 0 2
93104: ARRAY
93105: PPUSH
93106: LD_INT 2
93108: PUSH
93109: LD_INT 30
93111: PUSH
93112: LD_INT 6
93114: PUSH
93115: EMPTY
93116: LIST
93117: LIST
93118: PUSH
93119: LD_INT 30
93121: PUSH
93122: LD_INT 7
93124: PUSH
93125: EMPTY
93126: LIST
93127: LIST
93128: PUSH
93129: LD_INT 30
93131: PUSH
93132: LD_INT 8
93134: PUSH
93135: EMPTY
93136: LIST
93137: LIST
93138: PUSH
93139: LD_INT 30
93141: PUSH
93142: LD_INT 0
93144: PUSH
93145: EMPTY
93146: LIST
93147: LIST
93148: PUSH
93149: LD_INT 30
93151: PUSH
93152: LD_INT 1
93154: PUSH
93155: EMPTY
93156: LIST
93157: LIST
93158: PUSH
93159: EMPTY
93160: LIST
93161: LIST
93162: LIST
93163: LIST
93164: LIST
93165: LIST
93166: PPUSH
93167: CALL_OW 72
93171: ST_TO_ADDR
// if tmp then
93172: LD_VAR 0 5
93176: IFFALSE 93232
// begin k := NearestUnitToUnit ( tmp , j ) ;
93178: LD_ADDR_VAR 0 4
93182: PUSH
93183: LD_VAR 0 5
93187: PPUSH
93188: LD_VAR 0 3
93192: PPUSH
93193: CALL_OW 74
93197: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 5 then
93198: LD_VAR 0 3
93202: PPUSH
93203: LD_VAR 0 4
93207: PPUSH
93208: CALL_OW 296
93212: PUSH
93213: LD_INT 5
93215: GREATER
93216: IFFALSE 93232
// ComMoveToNearbyEntrance ( j , k ) ;
93218: LD_VAR 0 3
93222: PPUSH
93223: LD_VAR 0 4
93227: PPUSH
93228: CALL 56828 0 2
// end ; end ;
93232: GO 93087
93234: POP
93235: POP
// if not need_heal_1 and not need_heal_2 then
93236: LD_VAR 0 6
93240: NOT
93241: PUSH
93242: LD_VAR 0 7
93246: NOT
93247: AND
93248: IFFALSE 93252
// continue ;
93250: GO 92716
// end ;
93252: GO 92716
93254: POP
93255: POP
// RaiseSailEvent ( 102 ) ;
93256: LD_INT 102
93258: PPUSH
93259: CALL_OW 427
// end ;
93263: LD_VAR 0 1
93267: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes , to_repair_tmp , to_repair ; begin
93268: LD_INT 0
93270: PPUSH
93271: PPUSH
93272: PPUSH
93273: PPUSH
93274: PPUSH
93275: PPUSH
93276: PPUSH
93277: PPUSH
// if not mc_bases then
93278: LD_EXP 178
93282: NOT
93283: IFFALSE 93287
// exit ;
93285: GO 94170
// for i = 1 to mc_bases do
93287: LD_ADDR_VAR 0 2
93291: PUSH
93292: DOUBLE
93293: LD_INT 1
93295: DEC
93296: ST_TO_ADDR
93297: LD_EXP 178
93301: PUSH
93302: FOR_TO
93303: IFFALSE 94168
// begin if not mc_building_need_repair [ i ] then
93305: LD_EXP 179
93309: PUSH
93310: LD_VAR 0 2
93314: ARRAY
93315: NOT
93316: IFFALSE 93503
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ] ) ;
93318: LD_ADDR_VAR 0 6
93322: PUSH
93323: LD_EXP 197
93327: PUSH
93328: LD_VAR 0 2
93332: ARRAY
93333: PPUSH
93334: LD_INT 3
93336: PUSH
93337: LD_INT 24
93339: PUSH
93340: LD_INT 1000
93342: PUSH
93343: EMPTY
93344: LIST
93345: LIST
93346: PUSH
93347: EMPTY
93348: LIST
93349: LIST
93350: PUSH
93351: LD_INT 2
93353: PUSH
93354: LD_INT 34
93356: PUSH
93357: LD_INT 13
93359: PUSH
93360: EMPTY
93361: LIST
93362: LIST
93363: PUSH
93364: LD_INT 34
93366: PUSH
93367: LD_INT 52
93369: PUSH
93370: EMPTY
93371: LIST
93372: LIST
93373: PUSH
93374: LD_INT 34
93376: PUSH
93377: LD_EXP 163
93381: PUSH
93382: EMPTY
93383: LIST
93384: LIST
93385: PUSH
93386: EMPTY
93387: LIST
93388: LIST
93389: LIST
93390: LIST
93391: PUSH
93392: EMPTY
93393: LIST
93394: LIST
93395: PPUSH
93396: CALL_OW 72
93400: ST_TO_ADDR
// if cranes then
93401: LD_VAR 0 6
93405: IFFALSE 93467
// for j in cranes do
93407: LD_ADDR_VAR 0 3
93411: PUSH
93412: LD_VAR 0 6
93416: PUSH
93417: FOR_IN
93418: IFFALSE 93465
// if not IsInArea ( j , mc_parking [ i ] ) then
93420: LD_VAR 0 3
93424: PPUSH
93425: LD_EXP 202
93429: PUSH
93430: LD_VAR 0 2
93434: ARRAY
93435: PPUSH
93436: CALL_OW 308
93440: NOT
93441: IFFALSE 93463
// ComMoveToArea ( j , mc_parking [ i ] ) ;
93443: LD_VAR 0 3
93447: PPUSH
93448: LD_EXP 202
93452: PUSH
93453: LD_VAR 0 2
93457: ARRAY
93458: PPUSH
93459: CALL_OW 113
93463: GO 93417
93465: POP
93466: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
93467: LD_ADDR_EXP 180
93471: PUSH
93472: LD_EXP 180
93476: PPUSH
93477: LD_VAR 0 2
93481: PPUSH
93482: EMPTY
93483: PPUSH
93484: CALL_OW 1
93488: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
93489: LD_VAR 0 2
93493: PPUSH
93494: LD_INT 101
93496: PPUSH
93497: CALL 88355 0 2
// continue ;
93501: GO 93302
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
93503: LD_ADDR_EXP 184
93507: PUSH
93508: LD_EXP 184
93512: PPUSH
93513: LD_VAR 0 2
93517: PPUSH
93518: EMPTY
93519: PPUSH
93520: CALL_OW 1
93524: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
93525: LD_VAR 0 2
93529: PPUSH
93530: LD_INT 103
93532: PPUSH
93533: CALL 88355 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) ;
93537: LD_ADDR_VAR 0 5
93541: PUSH
93542: LD_EXP 178
93546: PUSH
93547: LD_VAR 0 2
93551: ARRAY
93552: PUSH
93553: LD_EXP 207
93557: PUSH
93558: LD_VAR 0 2
93562: ARRAY
93563: UNION
93564: PPUSH
93565: LD_INT 2
93567: PUSH
93568: LD_INT 25
93570: PUSH
93571: LD_INT 2
93573: PUSH
93574: EMPTY
93575: LIST
93576: LIST
93577: PUSH
93578: LD_INT 25
93580: PUSH
93581: LD_INT 16
93583: PUSH
93584: EMPTY
93585: LIST
93586: LIST
93587: PUSH
93588: EMPTY
93589: LIST
93590: LIST
93591: LIST
93592: PUSH
93593: EMPTY
93594: LIST
93595: PPUSH
93596: CALL_OW 72
93600: ST_TO_ADDR
// if mc_need_heal [ i ] then
93601: LD_EXP 181
93605: PUSH
93606: LD_VAR 0 2
93610: ARRAY
93611: IFFALSE 93655
// tmp := tmp diff ( mc_need_heal [ i ] [ 1 ] union mc_need_heal [ i ] [ 2 ] ) ;
93613: LD_ADDR_VAR 0 5
93617: PUSH
93618: LD_VAR 0 5
93622: PUSH
93623: LD_EXP 181
93627: PUSH
93628: LD_VAR 0 2
93632: ARRAY
93633: PUSH
93634: LD_INT 1
93636: ARRAY
93637: PUSH
93638: LD_EXP 181
93642: PUSH
93643: LD_VAR 0 2
93647: ARRAY
93648: PUSH
93649: LD_INT 2
93651: ARRAY
93652: UNION
93653: DIFF
93654: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ) ;
93655: LD_ADDR_VAR 0 6
93659: PUSH
93660: LD_EXP 197
93664: PUSH
93665: LD_VAR 0 2
93669: ARRAY
93670: PPUSH
93671: LD_INT 2
93673: PUSH
93674: LD_INT 34
93676: PUSH
93677: LD_INT 13
93679: PUSH
93680: EMPTY
93681: LIST
93682: LIST
93683: PUSH
93684: LD_INT 34
93686: PUSH
93687: LD_INT 52
93689: PUSH
93690: EMPTY
93691: LIST
93692: LIST
93693: PUSH
93694: LD_INT 34
93696: PUSH
93697: LD_EXP 163
93701: PUSH
93702: EMPTY
93703: LIST
93704: LIST
93705: PUSH
93706: EMPTY
93707: LIST
93708: LIST
93709: LIST
93710: LIST
93711: PPUSH
93712: CALL_OW 72
93716: ST_TO_ADDR
// if cranes then
93717: LD_VAR 0 6
93721: IFFALSE 93857
// begin for j in cranes do
93723: LD_ADDR_VAR 0 3
93727: PUSH
93728: LD_VAR 0 6
93732: PUSH
93733: FOR_IN
93734: IFFALSE 93855
// begin if GetLives ( j ) = 1000 and not HasTask ( j ) then
93736: LD_VAR 0 3
93740: PPUSH
93741: CALL_OW 256
93745: PUSH
93746: LD_INT 1000
93748: EQUAL
93749: PUSH
93750: LD_VAR 0 3
93754: PPUSH
93755: CALL_OW 314
93759: NOT
93760: AND
93761: IFFALSE 93795
// ComRepairBuilding ( j , NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ) else
93763: LD_VAR 0 3
93767: PPUSH
93768: LD_EXP 179
93772: PUSH
93773: LD_VAR 0 2
93777: ARRAY
93778: PPUSH
93779: LD_VAR 0 3
93783: PPUSH
93784: CALL_OW 74
93788: PPUSH
93789: CALL_OW 130
93793: GO 93853
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
93795: LD_VAR 0 3
93799: PPUSH
93800: CALL_OW 256
93804: PUSH
93805: LD_INT 500
93807: LESS
93808: PUSH
93809: LD_VAR 0 3
93813: PPUSH
93814: LD_EXP 202
93818: PUSH
93819: LD_VAR 0 2
93823: ARRAY
93824: PPUSH
93825: CALL_OW 308
93829: NOT
93830: AND
93831: IFFALSE 93853
// ComMoveToArea ( j , mc_parking [ i ] ) ;
93833: LD_VAR 0 3
93837: PPUSH
93838: LD_EXP 202
93842: PUSH
93843: LD_VAR 0 2
93847: ARRAY
93848: PPUSH
93849: CALL_OW 113
// end ;
93853: GO 93733
93855: POP
93856: POP
// end ; if tmp > 3 then
93857: LD_VAR 0 5
93861: PUSH
93862: LD_INT 3
93864: GREATER
93865: IFFALSE 93885
// tmp := ShrinkArray ( tmp , 4 ) ;
93867: LD_ADDR_VAR 0 5
93871: PUSH
93872: LD_VAR 0 5
93876: PPUSH
93877: LD_INT 4
93879: PPUSH
93880: CALL 56276 0 2
93884: ST_TO_ADDR
// if not tmp then
93885: LD_VAR 0 5
93889: NOT
93890: IFFALSE 93894
// continue ;
93892: GO 93302
// for j in tmp do
93894: LD_ADDR_VAR 0 3
93898: PUSH
93899: LD_VAR 0 5
93903: PUSH
93904: FOR_IN
93905: IFFALSE 94164
// begin if IsInUnit ( j ) then
93907: LD_VAR 0 3
93911: PPUSH
93912: CALL_OW 310
93916: IFFALSE 93927
// ComExitBuilding ( j ) ;
93918: LD_VAR 0 3
93922: PPUSH
93923: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
93927: LD_VAR 0 3
93931: PUSH
93932: LD_EXP 180
93936: PUSH
93937: LD_VAR 0 2
93941: ARRAY
93942: IN
93943: NOT
93944: IFFALSE 94002
// begin SetTag ( j , 101 ) ;
93946: LD_VAR 0 3
93950: PPUSH
93951: LD_INT 101
93953: PPUSH
93954: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
93958: LD_ADDR_EXP 180
93962: PUSH
93963: LD_EXP 180
93967: PPUSH
93968: LD_VAR 0 2
93972: PUSH
93973: LD_EXP 180
93977: PUSH
93978: LD_VAR 0 2
93982: ARRAY
93983: PUSH
93984: LD_INT 1
93986: PLUS
93987: PUSH
93988: EMPTY
93989: LIST
93990: LIST
93991: PPUSH
93992: LD_VAR 0 3
93996: PPUSH
93997: CALL 24210 0 3
94001: ST_TO_ADDR
// end ; wait ( 1 ) ;
94002: LD_INT 1
94004: PPUSH
94005: CALL_OW 67
// to_repair_tmp := mc_building_need_repair [ i ] ;
94009: LD_ADDR_VAR 0 7
94013: PUSH
94014: LD_EXP 179
94018: PUSH
94019: LD_VAR 0 2
94023: ARRAY
94024: ST_TO_ADDR
// if mc_scan [ i ] then
94025: LD_EXP 201
94029: PUSH
94030: LD_VAR 0 2
94034: ARRAY
94035: IFFALSE 94097
// to_repair_tmp := UnitFilter ( mc_building_need_repair [ i ] , [ f_not , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_breastwork ] ] ) ;
94037: LD_ADDR_VAR 0 7
94041: PUSH
94042: LD_EXP 179
94046: PUSH
94047: LD_VAR 0 2
94051: ARRAY
94052: PPUSH
94053: LD_INT 3
94055: PUSH
94056: LD_INT 30
94058: PUSH
94059: LD_INT 32
94061: PUSH
94062: EMPTY
94063: LIST
94064: LIST
94065: PUSH
94066: LD_INT 30
94068: PUSH
94069: LD_INT 33
94071: PUSH
94072: EMPTY
94073: LIST
94074: LIST
94075: PUSH
94076: LD_INT 30
94078: PUSH
94079: LD_INT 31
94081: PUSH
94082: EMPTY
94083: LIST
94084: LIST
94085: PUSH
94086: EMPTY
94087: LIST
94088: LIST
94089: LIST
94090: LIST
94091: PPUSH
94092: CALL_OW 72
94096: ST_TO_ADDR
// if not to_repair_tmp then
94097: LD_VAR 0 7
94101: NOT
94102: IFFALSE 94106
// continue ;
94104: GO 93904
// to_repair := NearestUnitToUnit ( to_repair_tmp , j ) ;
94106: LD_ADDR_VAR 0 8
94110: PUSH
94111: LD_VAR 0 7
94115: PPUSH
94116: LD_VAR 0 3
94120: PPUSH
94121: CALL_OW 74
94125: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 10 then
94126: LD_VAR 0 8
94130: PPUSH
94131: LD_INT 16
94133: PPUSH
94134: CALL 26809 0 2
94138: PUSH
94139: LD_INT 4
94141: ARRAY
94142: PUSH
94143: LD_INT 10
94145: LESS
94146: IFFALSE 94162
// ComRepairBuilding ( j , to_repair ) ;
94148: LD_VAR 0 3
94152: PPUSH
94153: LD_VAR 0 8
94157: PPUSH
94158: CALL_OW 130
// end ;
94162: GO 93904
94164: POP
94165: POP
// end ;
94166: GO 93302
94168: POP
94169: POP
// end ;
94170: LD_VAR 0 1
94174: RET
// export function MC_Heal ; var i , j , tmp ; begin
94175: LD_INT 0
94177: PPUSH
94178: PPUSH
94179: PPUSH
94180: PPUSH
// if not mc_bases then
94181: LD_EXP 178
94185: NOT
94186: IFFALSE 94190
// exit ;
94188: GO 94592
// for i = 1 to mc_bases do
94190: LD_ADDR_VAR 0 2
94194: PUSH
94195: DOUBLE
94196: LD_INT 1
94198: DEC
94199: ST_TO_ADDR
94200: LD_EXP 178
94204: PUSH
94205: FOR_TO
94206: IFFALSE 94590
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
94208: LD_EXP 181
94212: PUSH
94213: LD_VAR 0 2
94217: ARRAY
94218: PUSH
94219: LD_INT 1
94221: ARRAY
94222: NOT
94223: PUSH
94224: LD_EXP 181
94228: PUSH
94229: LD_VAR 0 2
94233: ARRAY
94234: PUSH
94235: LD_INT 2
94237: ARRAY
94238: NOT
94239: AND
94240: IFFALSE 94278
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
94242: LD_ADDR_EXP 182
94246: PUSH
94247: LD_EXP 182
94251: PPUSH
94252: LD_VAR 0 2
94256: PPUSH
94257: EMPTY
94258: PPUSH
94259: CALL_OW 1
94263: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
94264: LD_VAR 0 2
94268: PPUSH
94269: LD_INT 102
94271: PPUSH
94272: CALL 88355 0 2
// continue ;
94276: GO 94205
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
94278: LD_ADDR_VAR 0 4
94282: PUSH
94283: LD_EXP 178
94287: PUSH
94288: LD_VAR 0 2
94292: ARRAY
94293: PPUSH
94294: LD_INT 25
94296: PUSH
94297: LD_INT 4
94299: PUSH
94300: EMPTY
94301: LIST
94302: LIST
94303: PPUSH
94304: CALL_OW 72
94308: ST_TO_ADDR
// if not tmp then
94309: LD_VAR 0 4
94313: NOT
94314: IFFALSE 94318
// continue ;
94316: GO 94205
// if mc_taming [ i ] then
94318: LD_EXP 209
94322: PUSH
94323: LD_VAR 0 2
94327: ARRAY
94328: IFFALSE 94352
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
94330: LD_ADDR_EXP 209
94334: PUSH
94335: LD_EXP 209
94339: PPUSH
94340: LD_VAR 0 2
94344: PPUSH
94345: EMPTY
94346: PPUSH
94347: CALL_OW 1
94351: ST_TO_ADDR
// for j in tmp do
94352: LD_ADDR_VAR 0 3
94356: PUSH
94357: LD_VAR 0 4
94361: PUSH
94362: FOR_IN
94363: IFFALSE 94586
// begin if IsInUnit ( j ) then
94365: LD_VAR 0 3
94369: PPUSH
94370: CALL_OW 310
94374: IFFALSE 94385
// ComExitBuilding ( j ) ;
94376: LD_VAR 0 3
94380: PPUSH
94381: CALL_OW 122
// if not j in mc_healers [ i ] then
94385: LD_VAR 0 3
94389: PUSH
94390: LD_EXP 182
94394: PUSH
94395: LD_VAR 0 2
94399: ARRAY
94400: IN
94401: NOT
94402: IFFALSE 94448
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
94404: LD_ADDR_EXP 182
94408: PUSH
94409: LD_EXP 182
94413: PPUSH
94414: LD_VAR 0 2
94418: PUSH
94419: LD_EXP 182
94423: PUSH
94424: LD_VAR 0 2
94428: ARRAY
94429: PUSH
94430: LD_INT 1
94432: PLUS
94433: PUSH
94434: EMPTY
94435: LIST
94436: LIST
94437: PPUSH
94438: LD_VAR 0 3
94442: PPUSH
94443: CALL 24210 0 3
94447: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
94448: LD_VAR 0 3
94452: PPUSH
94453: CALL_OW 110
94457: PUSH
94458: LD_INT 102
94460: NONEQUAL
94461: IFFALSE 94475
// SetTag ( j , 102 ) ;
94463: LD_VAR 0 3
94467: PPUSH
94468: LD_INT 102
94470: PPUSH
94471: CALL_OW 109
// Wait ( 3 ) ;
94475: LD_INT 3
94477: PPUSH
94478: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
94482: LD_EXP 181
94486: PUSH
94487: LD_VAR 0 2
94491: ARRAY
94492: PUSH
94493: LD_INT 1
94495: ARRAY
94496: IFFALSE 94528
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
94498: LD_VAR 0 3
94502: PPUSH
94503: LD_EXP 181
94507: PUSH
94508: LD_VAR 0 2
94512: ARRAY
94513: PUSH
94514: LD_INT 1
94516: ARRAY
94517: PUSH
94518: LD_INT 1
94520: ARRAY
94521: PPUSH
94522: CALL_OW 128
94526: GO 94584
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
94528: LD_VAR 0 3
94532: PPUSH
94533: CALL_OW 314
94537: NOT
94538: PUSH
94539: LD_EXP 181
94543: PUSH
94544: LD_VAR 0 2
94548: ARRAY
94549: PUSH
94550: LD_INT 2
94552: ARRAY
94553: AND
94554: IFFALSE 94584
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
94556: LD_VAR 0 3
94560: PPUSH
94561: LD_EXP 181
94565: PUSH
94566: LD_VAR 0 2
94570: ARRAY
94571: PUSH
94572: LD_INT 2
94574: ARRAY
94575: PUSH
94576: LD_INT 1
94578: ARRAY
94579: PPUSH
94580: CALL_OW 128
// end ;
94584: GO 94362
94586: POP
94587: POP
// end ;
94588: GO 94205
94590: POP
94591: POP
// end ;
94592: LD_VAR 0 1
94596: RET
// export function MC_Build ( ) ; var i , j , tmp , depot ; begin
94597: LD_INT 0
94599: PPUSH
94600: PPUSH
94601: PPUSH
94602: PPUSH
94603: PPUSH
// if not mc_bases then
94604: LD_EXP 178
94608: NOT
94609: IFFALSE 94613
// exit ;
94611: GO 95784
// for i = 1 to mc_bases do
94613: LD_ADDR_VAR 0 2
94617: PUSH
94618: DOUBLE
94619: LD_INT 1
94621: DEC
94622: ST_TO_ADDR
94623: LD_EXP 178
94627: PUSH
94628: FOR_TO
94629: IFFALSE 95782
// begin if mc_scan [ i ] then
94631: LD_EXP 201
94635: PUSH
94636: LD_VAR 0 2
94640: ARRAY
94641: IFFALSE 94645
// continue ;
94643: GO 94628
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
94645: LD_EXP 183
94649: PUSH
94650: LD_VAR 0 2
94654: ARRAY
94655: NOT
94656: PUSH
94657: LD_EXP 185
94661: PUSH
94662: LD_VAR 0 2
94666: ARRAY
94667: NOT
94668: AND
94669: PUSH
94670: LD_EXP 184
94674: PUSH
94675: LD_VAR 0 2
94679: ARRAY
94680: AND
94681: IFFALSE 94719
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
94683: LD_ADDR_EXP 184
94687: PUSH
94688: LD_EXP 184
94692: PPUSH
94693: LD_VAR 0 2
94697: PPUSH
94698: EMPTY
94699: PPUSH
94700: CALL_OW 1
94704: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
94705: LD_VAR 0 2
94709: PPUSH
94710: LD_INT 103
94712: PPUSH
94713: CALL 88355 0 2
// continue ;
94717: GO 94628
// end ; if mc_construct_list [ i ] then
94719: LD_EXP 185
94723: PUSH
94724: LD_VAR 0 2
94728: ARRAY
94729: IFFALSE 94949
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
94731: LD_ADDR_VAR 0 4
94735: PUSH
94736: LD_EXP 178
94740: PUSH
94741: LD_VAR 0 2
94745: ARRAY
94746: PPUSH
94747: LD_INT 25
94749: PUSH
94750: LD_INT 2
94752: PUSH
94753: EMPTY
94754: LIST
94755: LIST
94756: PPUSH
94757: CALL_OW 72
94761: PUSH
94762: LD_EXP 180
94766: PUSH
94767: LD_VAR 0 2
94771: ARRAY
94772: DIFF
94773: ST_TO_ADDR
// if not tmp then
94774: LD_VAR 0 4
94778: NOT
94779: IFFALSE 94783
// continue ;
94781: GO 94628
// for j in tmp do
94783: LD_ADDR_VAR 0 3
94787: PUSH
94788: LD_VAR 0 4
94792: PUSH
94793: FOR_IN
94794: IFFALSE 94945
// begin if not mc_builders [ i ] then
94796: LD_EXP 184
94800: PUSH
94801: LD_VAR 0 2
94805: ARRAY
94806: NOT
94807: IFFALSE 94865
// begin SetTag ( j , 103 ) ;
94809: LD_VAR 0 3
94813: PPUSH
94814: LD_INT 103
94816: PPUSH
94817: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
94821: LD_ADDR_EXP 184
94825: PUSH
94826: LD_EXP 184
94830: PPUSH
94831: LD_VAR 0 2
94835: PUSH
94836: LD_EXP 184
94840: PUSH
94841: LD_VAR 0 2
94845: ARRAY
94846: PUSH
94847: LD_INT 1
94849: PLUS
94850: PUSH
94851: EMPTY
94852: LIST
94853: LIST
94854: PPUSH
94855: LD_VAR 0 3
94859: PPUSH
94860: CALL 24210 0 3
94864: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
94865: LD_VAR 0 3
94869: PPUSH
94870: CALL_OW 310
94874: IFFALSE 94885
// ComExitBuilding ( j ) ;
94876: LD_VAR 0 3
94880: PPUSH
94881: CALL_OW 122
// wait ( 3 ) ;
94885: LD_INT 3
94887: PPUSH
94888: CALL_OW 67
// if not mc_construct_list [ i ] then
94892: LD_EXP 185
94896: PUSH
94897: LD_VAR 0 2
94901: ARRAY
94902: NOT
94903: IFFALSE 94907
// break ;
94905: GO 94945
// if not HasTask ( j ) then
94907: LD_VAR 0 3
94911: PPUSH
94912: CALL_OW 314
94916: NOT
94917: IFFALSE 94943
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
94919: LD_VAR 0 3
94923: PPUSH
94924: LD_EXP 185
94928: PUSH
94929: LD_VAR 0 2
94933: ARRAY
94934: PUSH
94935: LD_INT 1
94937: ARRAY
94938: PPUSH
94939: CALL 27073 0 2
// end ;
94943: GO 94793
94945: POP
94946: POP
// end else
94947: GO 95780
// if mc_build_list [ i ] then
94949: LD_EXP 183
94953: PUSH
94954: LD_VAR 0 2
94958: ARRAY
94959: IFFALSE 95780
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
94961: LD_ADDR_VAR 0 5
94965: PUSH
94966: LD_EXP 178
94970: PUSH
94971: LD_VAR 0 2
94975: ARRAY
94976: PPUSH
94977: LD_INT 2
94979: PUSH
94980: LD_INT 30
94982: PUSH
94983: LD_INT 0
94985: PUSH
94986: EMPTY
94987: LIST
94988: LIST
94989: PUSH
94990: LD_INT 30
94992: PUSH
94993: LD_INT 1
94995: PUSH
94996: EMPTY
94997: LIST
94998: LIST
94999: PUSH
95000: EMPTY
95001: LIST
95002: LIST
95003: LIST
95004: PPUSH
95005: CALL_OW 72
95009: ST_TO_ADDR
// if depot then
95010: LD_VAR 0 5
95014: IFFALSE 95032
// depot := depot [ 1 ] else
95016: LD_ADDR_VAR 0 5
95020: PUSH
95021: LD_VAR 0 5
95025: PUSH
95026: LD_INT 1
95028: ARRAY
95029: ST_TO_ADDR
95030: GO 95040
// depot := 0 ;
95032: LD_ADDR_VAR 0 5
95036: PUSH
95037: LD_INT 0
95039: ST_TO_ADDR
// if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
95040: LD_EXP 183
95044: PUSH
95045: LD_VAR 0 2
95049: ARRAY
95050: PUSH
95051: LD_INT 1
95053: ARRAY
95054: PUSH
95055: LD_INT 1
95057: ARRAY
95058: PPUSH
95059: CALL 26897 0 1
95063: PUSH
95064: LD_EXP 178
95068: PUSH
95069: LD_VAR 0 2
95073: ARRAY
95074: PPUSH
95075: LD_INT 2
95077: PUSH
95078: LD_INT 30
95080: PUSH
95081: LD_INT 2
95083: PUSH
95084: EMPTY
95085: LIST
95086: LIST
95087: PUSH
95088: LD_INT 30
95090: PUSH
95091: LD_INT 3
95093: PUSH
95094: EMPTY
95095: LIST
95096: LIST
95097: PUSH
95098: EMPTY
95099: LIST
95100: LIST
95101: LIST
95102: PPUSH
95103: CALL_OW 72
95107: NOT
95108: AND
95109: IFFALSE 95214
// begin for j = 1 to mc_build_list [ i ] do
95111: LD_ADDR_VAR 0 3
95115: PUSH
95116: DOUBLE
95117: LD_INT 1
95119: DEC
95120: ST_TO_ADDR
95121: LD_EXP 183
95125: PUSH
95126: LD_VAR 0 2
95130: ARRAY
95131: PUSH
95132: FOR_TO
95133: IFFALSE 95212
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
95135: LD_EXP 183
95139: PUSH
95140: LD_VAR 0 2
95144: ARRAY
95145: PUSH
95146: LD_VAR 0 3
95150: ARRAY
95151: PUSH
95152: LD_INT 1
95154: ARRAY
95155: PUSH
95156: LD_INT 2
95158: EQUAL
95159: IFFALSE 95210
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
95161: LD_ADDR_EXP 183
95165: PUSH
95166: LD_EXP 183
95170: PPUSH
95171: LD_VAR 0 2
95175: PPUSH
95176: LD_EXP 183
95180: PUSH
95181: LD_VAR 0 2
95185: ARRAY
95186: PPUSH
95187: LD_VAR 0 3
95191: PPUSH
95192: LD_INT 1
95194: PPUSH
95195: LD_INT 0
95197: PPUSH
95198: CALL 23628 0 4
95202: PPUSH
95203: CALL_OW 1
95207: ST_TO_ADDR
// break ;
95208: GO 95212
// end ;
95210: GO 95132
95212: POP
95213: POP
// end ; if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or ( depot and CanBeBuilt ( depot , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ) then
95214: LD_EXP 183
95218: PUSH
95219: LD_VAR 0 2
95223: ARRAY
95224: PUSH
95225: LD_INT 1
95227: ARRAY
95228: PUSH
95229: LD_INT 1
95231: ARRAY
95232: PUSH
95233: LD_INT 0
95235: EQUAL
95236: PUSH
95237: LD_VAR 0 5
95241: PUSH
95242: LD_VAR 0 5
95246: PPUSH
95247: LD_EXP 183
95251: PUSH
95252: LD_VAR 0 2
95256: ARRAY
95257: PUSH
95258: LD_INT 1
95260: ARRAY
95261: PUSH
95262: LD_INT 1
95264: ARRAY
95265: PPUSH
95266: LD_EXP 183
95270: PUSH
95271: LD_VAR 0 2
95275: ARRAY
95276: PUSH
95277: LD_INT 1
95279: ARRAY
95280: PUSH
95281: LD_INT 2
95283: ARRAY
95284: PPUSH
95285: LD_EXP 183
95289: PUSH
95290: LD_VAR 0 2
95294: ARRAY
95295: PUSH
95296: LD_INT 1
95298: ARRAY
95299: PUSH
95300: LD_INT 3
95302: ARRAY
95303: PPUSH
95304: LD_EXP 183
95308: PUSH
95309: LD_VAR 0 2
95313: ARRAY
95314: PUSH
95315: LD_INT 1
95317: ARRAY
95318: PUSH
95319: LD_INT 4
95321: ARRAY
95322: PPUSH
95323: CALL 32313 0 5
95327: AND
95328: OR
95329: IFFALSE 95610
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
95331: LD_ADDR_VAR 0 4
95335: PUSH
95336: LD_EXP 178
95340: PUSH
95341: LD_VAR 0 2
95345: ARRAY
95346: PPUSH
95347: LD_INT 25
95349: PUSH
95350: LD_INT 2
95352: PUSH
95353: EMPTY
95354: LIST
95355: LIST
95356: PPUSH
95357: CALL_OW 72
95361: PUSH
95362: LD_EXP 180
95366: PUSH
95367: LD_VAR 0 2
95371: ARRAY
95372: DIFF
95373: ST_TO_ADDR
// if not tmp then
95374: LD_VAR 0 4
95378: NOT
95379: IFFALSE 95383
// continue ;
95381: GO 94628
// for j in tmp do
95383: LD_ADDR_VAR 0 3
95387: PUSH
95388: LD_VAR 0 4
95392: PUSH
95393: FOR_IN
95394: IFFALSE 95606
// begin if not mc_builders [ i ] then
95396: LD_EXP 184
95400: PUSH
95401: LD_VAR 0 2
95405: ARRAY
95406: NOT
95407: IFFALSE 95465
// begin SetTag ( j , 103 ) ;
95409: LD_VAR 0 3
95413: PPUSH
95414: LD_INT 103
95416: PPUSH
95417: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
95421: LD_ADDR_EXP 184
95425: PUSH
95426: LD_EXP 184
95430: PPUSH
95431: LD_VAR 0 2
95435: PUSH
95436: LD_EXP 184
95440: PUSH
95441: LD_VAR 0 2
95445: ARRAY
95446: PUSH
95447: LD_INT 1
95449: PLUS
95450: PUSH
95451: EMPTY
95452: LIST
95453: LIST
95454: PPUSH
95455: LD_VAR 0 3
95459: PPUSH
95460: CALL 24210 0 3
95464: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
95465: LD_VAR 0 3
95469: PPUSH
95470: CALL_OW 310
95474: IFFALSE 95485
// ComExitBuilding ( j ) ;
95476: LD_VAR 0 3
95480: PPUSH
95481: CALL_OW 122
// wait ( 3 ) ;
95485: LD_INT 3
95487: PPUSH
95488: CALL_OW 67
// if not mc_build_list [ i ] then
95492: LD_EXP 183
95496: PUSH
95497: LD_VAR 0 2
95501: ARRAY
95502: NOT
95503: IFFALSE 95507
// break ;
95505: GO 95606
// if not HasTask ( j ) then
95507: LD_VAR 0 3
95511: PPUSH
95512: CALL_OW 314
95516: NOT
95517: IFFALSE 95604
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
95519: LD_VAR 0 3
95523: PPUSH
95524: LD_EXP 183
95528: PUSH
95529: LD_VAR 0 2
95533: ARRAY
95534: PUSH
95535: LD_INT 1
95537: ARRAY
95538: PUSH
95539: LD_INT 1
95541: ARRAY
95542: PPUSH
95543: LD_EXP 183
95547: PUSH
95548: LD_VAR 0 2
95552: ARRAY
95553: PUSH
95554: LD_INT 1
95556: ARRAY
95557: PUSH
95558: LD_INT 2
95560: ARRAY
95561: PPUSH
95562: LD_EXP 183
95566: PUSH
95567: LD_VAR 0 2
95571: ARRAY
95572: PUSH
95573: LD_INT 1
95575: ARRAY
95576: PUSH
95577: LD_INT 3
95579: ARRAY
95580: PPUSH
95581: LD_EXP 183
95585: PUSH
95586: LD_VAR 0 2
95590: ARRAY
95591: PUSH
95592: LD_INT 1
95594: ARRAY
95595: PUSH
95596: LD_INT 4
95598: ARRAY
95599: PPUSH
95600: CALL_OW 145
// end ;
95604: GO 95393
95606: POP
95607: POP
// end else
95608: GO 95780
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] , UnitFilter ( mc_bases [ i ] , [ f_type , unit_building ] ) , [ ] ) then
95610: LD_EXP 178
95614: PUSH
95615: LD_VAR 0 2
95619: ARRAY
95620: PPUSH
95621: LD_EXP 183
95625: PUSH
95626: LD_VAR 0 2
95630: ARRAY
95631: PUSH
95632: LD_INT 1
95634: ARRAY
95635: PUSH
95636: LD_INT 1
95638: ARRAY
95639: PPUSH
95640: LD_EXP 183
95644: PUSH
95645: LD_VAR 0 2
95649: ARRAY
95650: PUSH
95651: LD_INT 1
95653: ARRAY
95654: PUSH
95655: LD_INT 2
95657: ARRAY
95658: PPUSH
95659: LD_EXP 183
95663: PUSH
95664: LD_VAR 0 2
95668: ARRAY
95669: PUSH
95670: LD_INT 1
95672: ARRAY
95673: PUSH
95674: LD_INT 3
95676: ARRAY
95677: PPUSH
95678: LD_EXP 183
95682: PUSH
95683: LD_VAR 0 2
95687: ARRAY
95688: PUSH
95689: LD_INT 1
95691: ARRAY
95692: PUSH
95693: LD_INT 4
95695: ARRAY
95696: PPUSH
95697: LD_EXP 178
95701: PUSH
95702: LD_VAR 0 2
95706: ARRAY
95707: PPUSH
95708: LD_INT 21
95710: PUSH
95711: LD_INT 3
95713: PUSH
95714: EMPTY
95715: LIST
95716: LIST
95717: PPUSH
95718: CALL_OW 72
95722: PPUSH
95723: EMPTY
95724: PPUSH
95725: CALL 31063 0 7
95729: NOT
95730: IFFALSE 95780
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
95732: LD_ADDR_EXP 183
95736: PUSH
95737: LD_EXP 183
95741: PPUSH
95742: LD_VAR 0 2
95746: PPUSH
95747: LD_EXP 183
95751: PUSH
95752: LD_VAR 0 2
95756: ARRAY
95757: PPUSH
95758: LD_INT 1
95760: PPUSH
95761: LD_INT 1
95763: NEG
95764: PPUSH
95765: LD_INT 0
95767: PPUSH
95768: CALL 23628 0 4
95772: PPUSH
95773: CALL_OW 1
95777: ST_TO_ADDR
// continue ;
95778: GO 94628
// end ; end ; end ;
95780: GO 94628
95782: POP
95783: POP
// end ;
95784: LD_VAR 0 1
95788: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
95789: LD_INT 0
95791: PPUSH
95792: PPUSH
95793: PPUSH
95794: PPUSH
95795: PPUSH
95796: PPUSH
// if not mc_bases then
95797: LD_EXP 178
95801: NOT
95802: IFFALSE 95806
// exit ;
95804: GO 96233
// for i = 1 to mc_bases do
95806: LD_ADDR_VAR 0 2
95810: PUSH
95811: DOUBLE
95812: LD_INT 1
95814: DEC
95815: ST_TO_ADDR
95816: LD_EXP 178
95820: PUSH
95821: FOR_TO
95822: IFFALSE 96231
// begin tmp := mc_build_upgrade [ i ] ;
95824: LD_ADDR_VAR 0 4
95828: PUSH
95829: LD_EXP 210
95833: PUSH
95834: LD_VAR 0 2
95838: ARRAY
95839: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
95840: LD_ADDR_VAR 0 6
95844: PUSH
95845: LD_EXP 211
95849: PUSH
95850: LD_VAR 0 2
95854: ARRAY
95855: PPUSH
95856: LD_INT 2
95858: PUSH
95859: LD_INT 30
95861: PUSH
95862: LD_INT 6
95864: PUSH
95865: EMPTY
95866: LIST
95867: LIST
95868: PUSH
95869: LD_INT 30
95871: PUSH
95872: LD_INT 7
95874: PUSH
95875: EMPTY
95876: LIST
95877: LIST
95878: PUSH
95879: EMPTY
95880: LIST
95881: LIST
95882: LIST
95883: PPUSH
95884: CALL_OW 72
95888: ST_TO_ADDR
// if not tmp and not lab then
95889: LD_VAR 0 4
95893: NOT
95894: PUSH
95895: LD_VAR 0 6
95899: NOT
95900: AND
95901: IFFALSE 95905
// continue ;
95903: GO 95821
// if tmp then
95905: LD_VAR 0 4
95909: IFFALSE 96029
// for j in tmp do
95911: LD_ADDR_VAR 0 3
95915: PUSH
95916: LD_VAR 0 4
95920: PUSH
95921: FOR_IN
95922: IFFALSE 96027
// begin if UpgradeCost ( j ) then
95924: LD_VAR 0 3
95928: PPUSH
95929: CALL 30723 0 1
95933: IFFALSE 96025
// begin ComUpgrade ( j ) ;
95935: LD_VAR 0 3
95939: PPUSH
95940: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
95944: LD_ADDR_EXP 210
95948: PUSH
95949: LD_EXP 210
95953: PPUSH
95954: LD_VAR 0 2
95958: PPUSH
95959: LD_EXP 210
95963: PUSH
95964: LD_VAR 0 2
95968: ARRAY
95969: PUSH
95970: LD_VAR 0 3
95974: DIFF
95975: PPUSH
95976: CALL_OW 1
95980: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
95981: LD_ADDR_EXP 185
95985: PUSH
95986: LD_EXP 185
95990: PPUSH
95991: LD_VAR 0 2
95995: PUSH
95996: LD_EXP 185
96000: PUSH
96001: LD_VAR 0 2
96005: ARRAY
96006: PUSH
96007: LD_INT 1
96009: PLUS
96010: PUSH
96011: EMPTY
96012: LIST
96013: LIST
96014: PPUSH
96015: LD_VAR 0 3
96019: PPUSH
96020: CALL 24210 0 3
96024: ST_TO_ADDR
// end ; end ;
96025: GO 95921
96027: POP
96028: POP
// if not lab or not mc_lab_upgrade [ i ] then
96029: LD_VAR 0 6
96033: NOT
96034: PUSH
96035: LD_EXP 212
96039: PUSH
96040: LD_VAR 0 2
96044: ARRAY
96045: NOT
96046: OR
96047: IFFALSE 96051
// continue ;
96049: GO 95821
// for j in lab do
96051: LD_ADDR_VAR 0 3
96055: PUSH
96056: LD_VAR 0 6
96060: PUSH
96061: FOR_IN
96062: IFFALSE 96227
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
96064: LD_VAR 0 3
96068: PPUSH
96069: CALL_OW 266
96073: PUSH
96074: LD_INT 6
96076: PUSH
96077: LD_INT 7
96079: PUSH
96080: EMPTY
96081: LIST
96082: LIST
96083: IN
96084: PUSH
96085: LD_VAR 0 3
96089: PPUSH
96090: CALL_OW 461
96094: PUSH
96095: LD_INT 1
96097: NONEQUAL
96098: AND
96099: IFFALSE 96225
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
96101: LD_VAR 0 3
96105: PPUSH
96106: LD_EXP 212
96110: PUSH
96111: LD_VAR 0 2
96115: ARRAY
96116: PUSH
96117: LD_INT 1
96119: ARRAY
96120: PPUSH
96121: CALL 30928 0 2
96125: IFFALSE 96225
// begin ComCancel ( j ) ;
96127: LD_VAR 0 3
96131: PPUSH
96132: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
96136: LD_VAR 0 3
96140: PPUSH
96141: LD_EXP 212
96145: PUSH
96146: LD_VAR 0 2
96150: ARRAY
96151: PUSH
96152: LD_INT 1
96154: ARRAY
96155: PPUSH
96156: CALL_OW 207
// if not j in mc_construct_list [ i ] then
96160: LD_VAR 0 3
96164: PUSH
96165: LD_EXP 185
96169: PUSH
96170: LD_VAR 0 2
96174: ARRAY
96175: IN
96176: NOT
96177: IFFALSE 96223
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
96179: LD_ADDR_EXP 185
96183: PUSH
96184: LD_EXP 185
96188: PPUSH
96189: LD_VAR 0 2
96193: PUSH
96194: LD_EXP 185
96198: PUSH
96199: LD_VAR 0 2
96203: ARRAY
96204: PUSH
96205: LD_INT 1
96207: PLUS
96208: PUSH
96209: EMPTY
96210: LIST
96211: LIST
96212: PPUSH
96213: LD_VAR 0 3
96217: PPUSH
96218: CALL 24210 0 3
96222: ST_TO_ADDR
// break ;
96223: GO 96227
// end ; end ; end ;
96225: GO 96061
96227: POP
96228: POP
// end ;
96229: GO 95821
96231: POP
96232: POP
// end ;
96233: LD_VAR 0 1
96237: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
96238: LD_INT 0
96240: PPUSH
96241: PPUSH
96242: PPUSH
96243: PPUSH
96244: PPUSH
96245: PPUSH
96246: PPUSH
96247: PPUSH
96248: PPUSH
// if not mc_bases then
96249: LD_EXP 178
96253: NOT
96254: IFFALSE 96258
// exit ;
96256: GO 96663
// for i = 1 to mc_bases do
96258: LD_ADDR_VAR 0 2
96262: PUSH
96263: DOUBLE
96264: LD_INT 1
96266: DEC
96267: ST_TO_ADDR
96268: LD_EXP 178
96272: PUSH
96273: FOR_TO
96274: IFFALSE 96661
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
96276: LD_EXP 186
96280: PUSH
96281: LD_VAR 0 2
96285: ARRAY
96286: NOT
96287: PUSH
96288: LD_EXP 178
96292: PUSH
96293: LD_VAR 0 2
96297: ARRAY
96298: PPUSH
96299: LD_INT 30
96301: PUSH
96302: LD_INT 3
96304: PUSH
96305: EMPTY
96306: LIST
96307: LIST
96308: PPUSH
96309: CALL_OW 72
96313: NOT
96314: OR
96315: IFFALSE 96319
// continue ;
96317: GO 96273
// busy := false ;
96319: LD_ADDR_VAR 0 8
96323: PUSH
96324: LD_INT 0
96326: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
96327: LD_ADDR_VAR 0 4
96331: PUSH
96332: LD_EXP 178
96336: PUSH
96337: LD_VAR 0 2
96341: ARRAY
96342: PPUSH
96343: LD_INT 30
96345: PUSH
96346: LD_INT 3
96348: PUSH
96349: EMPTY
96350: LIST
96351: LIST
96352: PPUSH
96353: CALL_OW 72
96357: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
96358: LD_ADDR_VAR 0 6
96362: PUSH
96363: LD_EXP 186
96367: PUSH
96368: LD_VAR 0 2
96372: ARRAY
96373: PPUSH
96374: LD_INT 2
96376: PUSH
96377: LD_INT 30
96379: PUSH
96380: LD_INT 32
96382: PUSH
96383: EMPTY
96384: LIST
96385: LIST
96386: PUSH
96387: LD_INT 30
96389: PUSH
96390: LD_INT 33
96392: PUSH
96393: EMPTY
96394: LIST
96395: LIST
96396: PUSH
96397: EMPTY
96398: LIST
96399: LIST
96400: LIST
96401: PPUSH
96402: CALL_OW 72
96406: ST_TO_ADDR
// if not t then
96407: LD_VAR 0 6
96411: NOT
96412: IFFALSE 96416
// continue ;
96414: GO 96273
// for j in tmp do
96416: LD_ADDR_VAR 0 3
96420: PUSH
96421: LD_VAR 0 4
96425: PUSH
96426: FOR_IN
96427: IFFALSE 96457
// if not BuildingStatus ( j ) = bs_idle then
96429: LD_VAR 0 3
96433: PPUSH
96434: CALL_OW 461
96438: PUSH
96439: LD_INT 2
96441: EQUAL
96442: NOT
96443: IFFALSE 96455
// begin busy := true ;
96445: LD_ADDR_VAR 0 8
96449: PUSH
96450: LD_INT 1
96452: ST_TO_ADDR
// break ;
96453: GO 96457
// end ;
96455: GO 96426
96457: POP
96458: POP
// if busy then
96459: LD_VAR 0 8
96463: IFFALSE 96467
// continue ;
96465: GO 96273
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
96467: LD_ADDR_VAR 0 7
96471: PUSH
96472: LD_VAR 0 6
96476: PPUSH
96477: LD_INT 35
96479: PUSH
96480: LD_INT 0
96482: PUSH
96483: EMPTY
96484: LIST
96485: LIST
96486: PPUSH
96487: CALL_OW 72
96491: ST_TO_ADDR
// if tw then
96492: LD_VAR 0 7
96496: IFFALSE 96573
// begin tw := tw [ 1 ] ;
96498: LD_ADDR_VAR 0 7
96502: PUSH
96503: LD_VAR 0 7
96507: PUSH
96508: LD_INT 1
96510: ARRAY
96511: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
96512: LD_ADDR_VAR 0 9
96516: PUSH
96517: LD_VAR 0 7
96521: PPUSH
96522: LD_EXP 203
96526: PUSH
96527: LD_VAR 0 2
96531: ARRAY
96532: PPUSH
96533: CALL 29220 0 2
96537: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
96538: LD_EXP 217
96542: PUSH
96543: LD_VAR 0 2
96547: ARRAY
96548: IFFALSE 96571
// if not weapon in mc_allowed_tower_weapons [ i ] then
96550: LD_VAR 0 9
96554: PUSH
96555: LD_EXP 217
96559: PUSH
96560: LD_VAR 0 2
96564: ARRAY
96565: IN
96566: NOT
96567: IFFALSE 96571
// continue ;
96569: GO 96273
// end else
96571: GO 96636
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
96573: LD_ADDR_VAR 0 5
96577: PUSH
96578: LD_EXP 186
96582: PUSH
96583: LD_VAR 0 2
96587: ARRAY
96588: PPUSH
96589: LD_VAR 0 4
96593: PPUSH
96594: CALL 55509 0 2
96598: ST_TO_ADDR
// if not tmp2 then
96599: LD_VAR 0 5
96603: NOT
96604: IFFALSE 96608
// continue ;
96606: GO 96273
// tw := tmp2 [ 1 ] ;
96608: LD_ADDR_VAR 0 7
96612: PUSH
96613: LD_VAR 0 5
96617: PUSH
96618: LD_INT 1
96620: ARRAY
96621: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
96622: LD_ADDR_VAR 0 9
96626: PUSH
96627: LD_VAR 0 5
96631: PUSH
96632: LD_INT 2
96634: ARRAY
96635: ST_TO_ADDR
// end ; if not weapon then
96636: LD_VAR 0 9
96640: NOT
96641: IFFALSE 96645
// continue ;
96643: GO 96273
// ComPlaceWeapon ( tw , weapon ) ;
96645: LD_VAR 0 7
96649: PPUSH
96650: LD_VAR 0 9
96654: PPUSH
96655: CALL_OW 148
// end ;
96659: GO 96273
96661: POP
96662: POP
// end ;
96663: LD_VAR 0 1
96667: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list , r ; begin
96668: LD_INT 0
96670: PPUSH
96671: PPUSH
96672: PPUSH
96673: PPUSH
96674: PPUSH
96675: PPUSH
96676: PPUSH
// if not mc_bases then
96677: LD_EXP 178
96681: NOT
96682: IFFALSE 96686
// exit ;
96684: GO 97454
// for i = 1 to mc_bases do
96686: LD_ADDR_VAR 0 2
96690: PUSH
96691: DOUBLE
96692: LD_INT 1
96694: DEC
96695: ST_TO_ADDR
96696: LD_EXP 178
96700: PUSH
96701: FOR_TO
96702: IFFALSE 97452
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] or mc_scan [ i ] then
96704: LD_EXP 191
96708: PUSH
96709: LD_VAR 0 2
96713: ARRAY
96714: NOT
96715: PUSH
96716: LD_EXP 191
96720: PUSH
96721: LD_VAR 0 2
96725: ARRAY
96726: PUSH
96727: LD_EXP 192
96731: PUSH
96732: LD_VAR 0 2
96736: ARRAY
96737: EQUAL
96738: OR
96739: PUSH
96740: LD_EXP 201
96744: PUSH
96745: LD_VAR 0 2
96749: ARRAY
96750: OR
96751: IFFALSE 96755
// continue ;
96753: GO 96701
// if mc_miners [ i ] then
96755: LD_EXP 192
96759: PUSH
96760: LD_VAR 0 2
96764: ARRAY
96765: IFFALSE 97139
// begin for j = mc_miners [ i ] downto 1 do
96767: LD_ADDR_VAR 0 3
96771: PUSH
96772: DOUBLE
96773: LD_EXP 192
96777: PUSH
96778: LD_VAR 0 2
96782: ARRAY
96783: INC
96784: ST_TO_ADDR
96785: LD_INT 1
96787: PUSH
96788: FOR_DOWNTO
96789: IFFALSE 97137
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
96791: LD_EXP 192
96795: PUSH
96796: LD_VAR 0 2
96800: ARRAY
96801: PUSH
96802: LD_VAR 0 3
96806: ARRAY
96807: PPUSH
96808: CALL_OW 301
96812: PUSH
96813: LD_EXP 192
96817: PUSH
96818: LD_VAR 0 2
96822: ARRAY
96823: PUSH
96824: LD_VAR 0 3
96828: ARRAY
96829: PPUSH
96830: CALL_OW 257
96834: PUSH
96835: LD_INT 1
96837: NONEQUAL
96838: OR
96839: IFFALSE 96902
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
96841: LD_ADDR_VAR 0 5
96845: PUSH
96846: LD_EXP 192
96850: PUSH
96851: LD_VAR 0 2
96855: ARRAY
96856: PUSH
96857: LD_EXP 192
96861: PUSH
96862: LD_VAR 0 2
96866: ARRAY
96867: PUSH
96868: LD_VAR 0 3
96872: ARRAY
96873: DIFF
96874: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
96875: LD_ADDR_EXP 192
96879: PUSH
96880: LD_EXP 192
96884: PPUSH
96885: LD_VAR 0 2
96889: PPUSH
96890: LD_VAR 0 5
96894: PPUSH
96895: CALL_OW 1
96899: ST_TO_ADDR
// continue ;
96900: GO 96788
// end ; if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and not HasTask ( mc_miners [ i ] [ j ] ) then
96902: LD_EXP 192
96906: PUSH
96907: LD_VAR 0 2
96911: ARRAY
96912: PUSH
96913: LD_VAR 0 3
96917: ARRAY
96918: PPUSH
96919: CALL_OW 257
96923: PUSH
96924: LD_INT 1
96926: EQUAL
96927: PUSH
96928: LD_EXP 192
96932: PUSH
96933: LD_VAR 0 2
96937: ARRAY
96938: PUSH
96939: LD_VAR 0 3
96943: ARRAY
96944: PPUSH
96945: CALL_OW 459
96949: NOT
96950: AND
96951: PUSH
96952: LD_EXP 192
96956: PUSH
96957: LD_VAR 0 2
96961: ARRAY
96962: PUSH
96963: LD_VAR 0 3
96967: ARRAY
96968: PPUSH
96969: CALL_OW 314
96973: NOT
96974: AND
96975: IFFALSE 97135
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
96977: LD_EXP 192
96981: PUSH
96982: LD_VAR 0 2
96986: ARRAY
96987: PUSH
96988: LD_VAR 0 3
96992: ARRAY
96993: PPUSH
96994: CALL_OW 310
96998: IFFALSE 97021
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
97000: LD_EXP 192
97004: PUSH
97005: LD_VAR 0 2
97009: ARRAY
97010: PUSH
97011: LD_VAR 0 3
97015: ARRAY
97016: PPUSH
97017: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
97021: LD_EXP 192
97025: PUSH
97026: LD_VAR 0 2
97030: ARRAY
97031: PUSH
97032: LD_VAR 0 3
97036: ARRAY
97037: PPUSH
97038: CALL_OW 314
97042: NOT
97043: IFFALSE 97135
// begin r := rand ( 1 , mc_mines [ i ] ) ;
97045: LD_ADDR_VAR 0 7
97049: PUSH
97050: LD_INT 1
97052: PPUSH
97053: LD_EXP 191
97057: PUSH
97058: LD_VAR 0 2
97062: ARRAY
97063: PPUSH
97064: CALL_OW 12
97068: ST_TO_ADDR
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ r ] [ 1 ] , mc_mines [ i ] [ r ] [ 2 ] , 0 ) ;
97069: LD_EXP 192
97073: PUSH
97074: LD_VAR 0 2
97078: ARRAY
97079: PUSH
97080: LD_VAR 0 3
97084: ARRAY
97085: PPUSH
97086: LD_EXP 191
97090: PUSH
97091: LD_VAR 0 2
97095: ARRAY
97096: PUSH
97097: LD_VAR 0 7
97101: ARRAY
97102: PUSH
97103: LD_INT 1
97105: ARRAY
97106: PPUSH
97107: LD_EXP 191
97111: PUSH
97112: LD_VAR 0 2
97116: ARRAY
97117: PUSH
97118: LD_VAR 0 7
97122: ARRAY
97123: PUSH
97124: LD_INT 2
97126: ARRAY
97127: PPUSH
97128: LD_INT 0
97130: PPUSH
97131: CALL_OW 193
// end ; end ; end ;
97135: GO 96788
97137: POP
97138: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
97139: LD_ADDR_VAR 0 5
97143: PUSH
97144: LD_EXP 178
97148: PUSH
97149: LD_VAR 0 2
97153: ARRAY
97154: PPUSH
97155: LD_INT 2
97157: PUSH
97158: LD_INT 30
97160: PUSH
97161: LD_INT 4
97163: PUSH
97164: EMPTY
97165: LIST
97166: LIST
97167: PUSH
97168: LD_INT 30
97170: PUSH
97171: LD_INT 5
97173: PUSH
97174: EMPTY
97175: LIST
97176: LIST
97177: PUSH
97178: LD_INT 30
97180: PUSH
97181: LD_INT 32
97183: PUSH
97184: EMPTY
97185: LIST
97186: LIST
97187: PUSH
97188: EMPTY
97189: LIST
97190: LIST
97191: LIST
97192: LIST
97193: PPUSH
97194: CALL_OW 72
97198: ST_TO_ADDR
// if not tmp then
97199: LD_VAR 0 5
97203: NOT
97204: IFFALSE 97208
// continue ;
97206: GO 96701
// list := [ ] ;
97208: LD_ADDR_VAR 0 6
97212: PUSH
97213: EMPTY
97214: ST_TO_ADDR
// for j in tmp do
97215: LD_ADDR_VAR 0 3
97219: PUSH
97220: LD_VAR 0 5
97224: PUSH
97225: FOR_IN
97226: IFFALSE 97295
// begin for k in UnitsInside ( j ) do
97228: LD_ADDR_VAR 0 4
97232: PUSH
97233: LD_VAR 0 3
97237: PPUSH
97238: CALL_OW 313
97242: PUSH
97243: FOR_IN
97244: IFFALSE 97291
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
97246: LD_VAR 0 4
97250: PPUSH
97251: CALL_OW 257
97255: PUSH
97256: LD_INT 1
97258: EQUAL
97259: PUSH
97260: LD_VAR 0 4
97264: PPUSH
97265: CALL_OW 459
97269: NOT
97270: AND
97271: IFFALSE 97289
// list := list ^ k ;
97273: LD_ADDR_VAR 0 6
97277: PUSH
97278: LD_VAR 0 6
97282: PUSH
97283: LD_VAR 0 4
97287: ADD
97288: ST_TO_ADDR
97289: GO 97243
97291: POP
97292: POP
// end ;
97293: GO 97225
97295: POP
97296: POP
// list := list diff mc_miners [ i ] ;
97297: LD_ADDR_VAR 0 6
97301: PUSH
97302: LD_VAR 0 6
97306: PUSH
97307: LD_EXP 192
97311: PUSH
97312: LD_VAR 0 2
97316: ARRAY
97317: DIFF
97318: ST_TO_ADDR
// if not list then
97319: LD_VAR 0 6
97323: NOT
97324: IFFALSE 97328
// continue ;
97326: GO 96701
// k := mc_mines [ i ] - mc_miners [ i ] ;
97328: LD_ADDR_VAR 0 4
97332: PUSH
97333: LD_EXP 191
97337: PUSH
97338: LD_VAR 0 2
97342: ARRAY
97343: PUSH
97344: LD_EXP 192
97348: PUSH
97349: LD_VAR 0 2
97353: ARRAY
97354: MINUS
97355: ST_TO_ADDR
// if k > list then
97356: LD_VAR 0 4
97360: PUSH
97361: LD_VAR 0 6
97365: GREATER
97366: IFFALSE 97378
// k := list ;
97368: LD_ADDR_VAR 0 4
97372: PUSH
97373: LD_VAR 0 6
97377: ST_TO_ADDR
// for j = 1 to k do
97378: LD_ADDR_VAR 0 3
97382: PUSH
97383: DOUBLE
97384: LD_INT 1
97386: DEC
97387: ST_TO_ADDR
97388: LD_VAR 0 4
97392: PUSH
97393: FOR_TO
97394: IFFALSE 97448
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
97396: LD_ADDR_EXP 192
97400: PUSH
97401: LD_EXP 192
97405: PPUSH
97406: LD_VAR 0 2
97410: PUSH
97411: LD_EXP 192
97415: PUSH
97416: LD_VAR 0 2
97420: ARRAY
97421: PUSH
97422: LD_INT 1
97424: PLUS
97425: PUSH
97426: EMPTY
97427: LIST
97428: LIST
97429: PPUSH
97430: LD_VAR 0 6
97434: PUSH
97435: LD_VAR 0 3
97439: ARRAY
97440: PPUSH
97441: CALL 24210 0 3
97445: ST_TO_ADDR
97446: GO 97393
97448: POP
97449: POP
// end ;
97450: GO 96701
97452: POP
97453: POP
// end ;
97454: LD_VAR 0 1
97458: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , side , target , cargo , depot , fac , components ; begin
97459: LD_INT 0
97461: PPUSH
97462: PPUSH
97463: PPUSH
97464: PPUSH
97465: PPUSH
97466: PPUSH
97467: PPUSH
97468: PPUSH
97469: PPUSH
97470: PPUSH
97471: PPUSH
// if not mc_bases then
97472: LD_EXP 178
97476: NOT
97477: IFFALSE 97481
// exit ;
97479: GO 99304
// for i = 1 to mc_bases do
97481: LD_ADDR_VAR 0 2
97485: PUSH
97486: DOUBLE
97487: LD_INT 1
97489: DEC
97490: ST_TO_ADDR
97491: LD_EXP 178
97495: PUSH
97496: FOR_TO
97497: IFFALSE 99302
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
97499: LD_EXP 178
97503: PUSH
97504: LD_VAR 0 2
97508: ARRAY
97509: NOT
97510: PUSH
97511: LD_EXP 185
97515: PUSH
97516: LD_VAR 0 2
97520: ARRAY
97521: OR
97522: IFFALSE 97526
// continue ;
97524: GO 97496
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
97526: LD_EXP 194
97530: PUSH
97531: LD_VAR 0 2
97535: ARRAY
97536: NOT
97537: PUSH
97538: LD_EXP 195
97542: PUSH
97543: LD_VAR 0 2
97547: ARRAY
97548: AND
97549: IFFALSE 97587
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
97551: LD_ADDR_EXP 195
97555: PUSH
97556: LD_EXP 195
97560: PPUSH
97561: LD_VAR 0 2
97565: PPUSH
97566: EMPTY
97567: PPUSH
97568: CALL_OW 1
97572: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
97573: LD_VAR 0 2
97577: PPUSH
97578: LD_INT 107
97580: PPUSH
97581: CALL 88355 0 2
// continue ;
97585: GO 97496
// end ; target := [ ] ;
97587: LD_ADDR_VAR 0 7
97591: PUSH
97592: EMPTY
97593: ST_TO_ADDR
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
97594: LD_ADDR_VAR 0 6
97598: PUSH
97599: LD_EXP 178
97603: PUSH
97604: LD_VAR 0 2
97608: ARRAY
97609: PUSH
97610: LD_INT 1
97612: ARRAY
97613: PPUSH
97614: CALL_OW 255
97618: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
97619: LD_ADDR_VAR 0 9
97623: PUSH
97624: LD_EXP 178
97628: PUSH
97629: LD_VAR 0 2
97633: ARRAY
97634: PPUSH
97635: LD_INT 2
97637: PUSH
97638: LD_INT 30
97640: PUSH
97641: LD_INT 0
97643: PUSH
97644: EMPTY
97645: LIST
97646: LIST
97647: PUSH
97648: LD_INT 30
97650: PUSH
97651: LD_INT 1
97653: PUSH
97654: EMPTY
97655: LIST
97656: LIST
97657: PUSH
97658: EMPTY
97659: LIST
97660: LIST
97661: LIST
97662: PPUSH
97663: CALL_OW 72
97667: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
97668: LD_ADDR_VAR 0 3
97672: PUSH
97673: DOUBLE
97674: LD_EXP 194
97678: PUSH
97679: LD_VAR 0 2
97683: ARRAY
97684: INC
97685: ST_TO_ADDR
97686: LD_INT 1
97688: PUSH
97689: FOR_DOWNTO
97690: IFFALSE 97935
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
97692: LD_EXP 194
97696: PUSH
97697: LD_VAR 0 2
97701: ARRAY
97702: PUSH
97703: LD_VAR 0 3
97707: ARRAY
97708: PUSH
97709: LD_INT 2
97711: ARRAY
97712: PPUSH
97713: LD_EXP 194
97717: PUSH
97718: LD_VAR 0 2
97722: ARRAY
97723: PUSH
97724: LD_VAR 0 3
97728: ARRAY
97729: PUSH
97730: LD_INT 3
97732: ARRAY
97733: PPUSH
97734: CALL_OW 488
97738: PUSH
97739: LD_EXP 194
97743: PUSH
97744: LD_VAR 0 2
97748: ARRAY
97749: PUSH
97750: LD_VAR 0 3
97754: ARRAY
97755: PUSH
97756: LD_INT 2
97758: ARRAY
97759: PPUSH
97760: LD_EXP 194
97764: PUSH
97765: LD_VAR 0 2
97769: ARRAY
97770: PUSH
97771: LD_VAR 0 3
97775: ARRAY
97776: PUSH
97777: LD_INT 3
97779: ARRAY
97780: PPUSH
97781: CALL_OW 284
97785: PUSH
97786: LD_INT 0
97788: EQUAL
97789: AND
97790: IFFALSE 97845
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
97792: LD_ADDR_VAR 0 5
97796: PUSH
97797: LD_EXP 194
97801: PUSH
97802: LD_VAR 0 2
97806: ARRAY
97807: PPUSH
97808: LD_VAR 0 3
97812: PPUSH
97813: CALL_OW 3
97817: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
97818: LD_ADDR_EXP 194
97822: PUSH
97823: LD_EXP 194
97827: PPUSH
97828: LD_VAR 0 2
97832: PPUSH
97833: LD_VAR 0 5
97837: PPUSH
97838: CALL_OW 1
97842: ST_TO_ADDR
// continue ;
97843: GO 97689
// end ; if DangerAtRangeXY ( side , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
97845: LD_VAR 0 6
97849: PPUSH
97850: LD_EXP 194
97854: PUSH
97855: LD_VAR 0 2
97859: ARRAY
97860: PUSH
97861: LD_VAR 0 3
97865: ARRAY
97866: PUSH
97867: LD_INT 2
97869: ARRAY
97870: PPUSH
97871: LD_EXP 194
97875: PUSH
97876: LD_VAR 0 2
97880: ARRAY
97881: PUSH
97882: LD_VAR 0 3
97886: ARRAY
97887: PUSH
97888: LD_INT 3
97890: ARRAY
97891: PPUSH
97892: LD_INT 30
97894: PPUSH
97895: CALL 25106 0 4
97899: PUSH
97900: LD_INT 4
97902: ARRAY
97903: PUSH
97904: LD_INT 0
97906: EQUAL
97907: IFFALSE 97933
// begin target := mc_crates [ i ] [ j ] ;
97909: LD_ADDR_VAR 0 7
97913: PUSH
97914: LD_EXP 194
97918: PUSH
97919: LD_VAR 0 2
97923: ARRAY
97924: PUSH
97925: LD_VAR 0 3
97929: ARRAY
97930: ST_TO_ADDR
// break ;
97931: GO 97935
// end ; end ;
97933: GO 97689
97935: POP
97936: POP
// if not target then
97937: LD_VAR 0 7
97941: NOT
97942: IFFALSE 97946
// continue ;
97944: GO 97496
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
97946: LD_ADDR_VAR 0 8
97950: PUSH
97951: LD_EXP 197
97955: PUSH
97956: LD_VAR 0 2
97960: ARRAY
97961: PPUSH
97962: LD_INT 2
97964: PUSH
97965: LD_INT 3
97967: PUSH
97968: LD_INT 58
97970: PUSH
97971: EMPTY
97972: LIST
97973: PUSH
97974: EMPTY
97975: LIST
97976: LIST
97977: PUSH
97978: LD_INT 61
97980: PUSH
97981: EMPTY
97982: LIST
97983: PUSH
97984: LD_INT 33
97986: PUSH
97987: LD_INT 5
97989: PUSH
97990: EMPTY
97991: LIST
97992: LIST
97993: PUSH
97994: LD_INT 33
97996: PUSH
97997: LD_INT 3
97999: PUSH
98000: EMPTY
98001: LIST
98002: LIST
98003: PUSH
98004: EMPTY
98005: LIST
98006: LIST
98007: LIST
98008: LIST
98009: LIST
98010: PUSH
98011: LD_INT 2
98013: PUSH
98014: LD_INT 34
98016: PUSH
98017: LD_INT 32
98019: PUSH
98020: EMPTY
98021: LIST
98022: LIST
98023: PUSH
98024: LD_INT 34
98026: PUSH
98027: LD_INT 51
98029: PUSH
98030: EMPTY
98031: LIST
98032: LIST
98033: PUSH
98034: LD_INT 34
98036: PUSH
98037: LD_INT 12
98039: PUSH
98040: EMPTY
98041: LIST
98042: LIST
98043: PUSH
98044: EMPTY
98045: LIST
98046: LIST
98047: LIST
98048: LIST
98049: PUSH
98050: EMPTY
98051: LIST
98052: LIST
98053: PPUSH
98054: CALL_OW 72
98058: ST_TO_ADDR
// if not cargo then
98059: LD_VAR 0 8
98063: NOT
98064: IFFALSE 98770
// begin if mc_crates_collector [ i ] < 5 then
98066: LD_EXP 195
98070: PUSH
98071: LD_VAR 0 2
98075: ARRAY
98076: PUSH
98077: LD_INT 5
98079: LESS
98080: IFFALSE 98446
// begin if mc_ape [ i ] then
98082: LD_EXP 207
98086: PUSH
98087: LD_VAR 0 2
98091: ARRAY
98092: IFFALSE 98139
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
98094: LD_ADDR_VAR 0 5
98098: PUSH
98099: LD_EXP 207
98103: PUSH
98104: LD_VAR 0 2
98108: ARRAY
98109: PPUSH
98110: LD_INT 25
98112: PUSH
98113: LD_INT 16
98115: PUSH
98116: EMPTY
98117: LIST
98118: LIST
98119: PUSH
98120: LD_INT 24
98122: PUSH
98123: LD_INT 750
98125: PUSH
98126: EMPTY
98127: LIST
98128: LIST
98129: PUSH
98130: EMPTY
98131: LIST
98132: LIST
98133: PPUSH
98134: CALL_OW 72
98138: ST_TO_ADDR
// if not tmp then
98139: LD_VAR 0 5
98143: NOT
98144: IFFALSE 98191
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
98146: LD_ADDR_VAR 0 5
98150: PUSH
98151: LD_EXP 178
98155: PUSH
98156: LD_VAR 0 2
98160: ARRAY
98161: PPUSH
98162: LD_INT 25
98164: PUSH
98165: LD_INT 2
98167: PUSH
98168: EMPTY
98169: LIST
98170: LIST
98171: PUSH
98172: LD_INT 24
98174: PUSH
98175: LD_INT 750
98177: PUSH
98178: EMPTY
98179: LIST
98180: LIST
98181: PUSH
98182: EMPTY
98183: LIST
98184: LIST
98185: PPUSH
98186: CALL_OW 72
98190: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
98191: LD_EXP 207
98195: PUSH
98196: LD_VAR 0 2
98200: ARRAY
98201: PUSH
98202: LD_EXP 178
98206: PUSH
98207: LD_VAR 0 2
98211: ARRAY
98212: PPUSH
98213: LD_INT 25
98215: PUSH
98216: LD_INT 2
98218: PUSH
98219: EMPTY
98220: LIST
98221: LIST
98222: PUSH
98223: LD_INT 24
98225: PUSH
98226: LD_INT 750
98228: PUSH
98229: EMPTY
98230: LIST
98231: LIST
98232: PUSH
98233: EMPTY
98234: LIST
98235: LIST
98236: PPUSH
98237: CALL_OW 72
98241: AND
98242: PUSH
98243: LD_VAR 0 5
98247: PUSH
98248: LD_INT 5
98250: LESS
98251: AND
98252: IFFALSE 98334
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
98254: LD_ADDR_VAR 0 3
98258: PUSH
98259: LD_EXP 178
98263: PUSH
98264: LD_VAR 0 2
98268: ARRAY
98269: PPUSH
98270: LD_INT 25
98272: PUSH
98273: LD_INT 2
98275: PUSH
98276: EMPTY
98277: LIST
98278: LIST
98279: PUSH
98280: LD_INT 24
98282: PUSH
98283: LD_INT 750
98285: PUSH
98286: EMPTY
98287: LIST
98288: LIST
98289: PUSH
98290: EMPTY
98291: LIST
98292: LIST
98293: PPUSH
98294: CALL_OW 72
98298: PUSH
98299: FOR_IN
98300: IFFALSE 98332
// begin tmp := tmp union j ;
98302: LD_ADDR_VAR 0 5
98306: PUSH
98307: LD_VAR 0 5
98311: PUSH
98312: LD_VAR 0 3
98316: UNION
98317: ST_TO_ADDR
// if tmp >= 5 then
98318: LD_VAR 0 5
98322: PUSH
98323: LD_INT 5
98325: GREATEREQUAL
98326: IFFALSE 98330
// break ;
98328: GO 98332
// end ;
98330: GO 98299
98332: POP
98333: POP
// end ; if not tmp then
98334: LD_VAR 0 5
98338: NOT
98339: IFFALSE 98343
// continue ;
98341: GO 97496
// for j in tmp do
98343: LD_ADDR_VAR 0 3
98347: PUSH
98348: LD_VAR 0 5
98352: PUSH
98353: FOR_IN
98354: IFFALSE 98444
// if not GetTag ( j ) then
98356: LD_VAR 0 3
98360: PPUSH
98361: CALL_OW 110
98365: NOT
98366: IFFALSE 98442
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
98368: LD_ADDR_EXP 195
98372: PUSH
98373: LD_EXP 195
98377: PPUSH
98378: LD_VAR 0 2
98382: PUSH
98383: LD_EXP 195
98387: PUSH
98388: LD_VAR 0 2
98392: ARRAY
98393: PUSH
98394: LD_INT 1
98396: PLUS
98397: PUSH
98398: EMPTY
98399: LIST
98400: LIST
98401: PPUSH
98402: LD_VAR 0 3
98406: PPUSH
98407: CALL 24210 0 3
98411: ST_TO_ADDR
// SetTag ( j , 107 ) ;
98412: LD_VAR 0 3
98416: PPUSH
98417: LD_INT 107
98419: PPUSH
98420: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
98424: LD_EXP 195
98428: PUSH
98429: LD_VAR 0 2
98433: ARRAY
98434: PUSH
98435: LD_INT 5
98437: GREATEREQUAL
98438: IFFALSE 98442
// break ;
98440: GO 98444
// end ;
98442: GO 98353
98444: POP
98445: POP
// end ; if mc_crates_collector [ i ] and target then
98446: LD_EXP 195
98450: PUSH
98451: LD_VAR 0 2
98455: ARRAY
98456: PUSH
98457: LD_VAR 0 7
98461: AND
98462: IFFALSE 98768
// begin if mc_crates_collector [ i ] < target [ 1 ] then
98464: LD_EXP 195
98468: PUSH
98469: LD_VAR 0 2
98473: ARRAY
98474: PUSH
98475: LD_VAR 0 7
98479: PUSH
98480: LD_INT 1
98482: ARRAY
98483: LESS
98484: IFFALSE 98504
// tmp := mc_crates_collector [ i ] else
98486: LD_ADDR_VAR 0 5
98490: PUSH
98491: LD_EXP 195
98495: PUSH
98496: LD_VAR 0 2
98500: ARRAY
98501: ST_TO_ADDR
98502: GO 98518
// tmp := target [ 1 ] ;
98504: LD_ADDR_VAR 0 5
98508: PUSH
98509: LD_VAR 0 7
98513: PUSH
98514: LD_INT 1
98516: ARRAY
98517: ST_TO_ADDR
// k := 0 ;
98518: LD_ADDR_VAR 0 4
98522: PUSH
98523: LD_INT 0
98525: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
98526: LD_ADDR_VAR 0 3
98530: PUSH
98531: LD_EXP 195
98535: PUSH
98536: LD_VAR 0 2
98540: ARRAY
98541: PUSH
98542: FOR_IN
98543: IFFALSE 98766
// begin k := k + 1 ;
98545: LD_ADDR_VAR 0 4
98549: PUSH
98550: LD_VAR 0 4
98554: PUSH
98555: LD_INT 1
98557: PLUS
98558: ST_TO_ADDR
// if k > tmp then
98559: LD_VAR 0 4
98563: PUSH
98564: LD_VAR 0 5
98568: GREATER
98569: IFFALSE 98573
// break ;
98571: GO 98766
// if not GetClass ( j ) in [ 2 , 16 ] then
98573: LD_VAR 0 3
98577: PPUSH
98578: CALL_OW 257
98582: PUSH
98583: LD_INT 2
98585: PUSH
98586: LD_INT 16
98588: PUSH
98589: EMPTY
98590: LIST
98591: LIST
98592: IN
98593: NOT
98594: IFFALSE 98647
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
98596: LD_ADDR_EXP 195
98600: PUSH
98601: LD_EXP 195
98605: PPUSH
98606: LD_VAR 0 2
98610: PPUSH
98611: LD_EXP 195
98615: PUSH
98616: LD_VAR 0 2
98620: ARRAY
98621: PUSH
98622: LD_VAR 0 3
98626: DIFF
98627: PPUSH
98628: CALL_OW 1
98632: ST_TO_ADDR
// SetTag ( j , 0 ) ;
98633: LD_VAR 0 3
98637: PPUSH
98638: LD_INT 0
98640: PPUSH
98641: CALL_OW 109
// continue ;
98645: GO 98542
// end ; if IsInUnit ( j ) then
98647: LD_VAR 0 3
98651: PPUSH
98652: CALL_OW 310
98656: IFFALSE 98667
// ComExitBuilding ( j ) ;
98658: LD_VAR 0 3
98662: PPUSH
98663: CALL_OW 122
// wait ( 3 ) ;
98667: LD_INT 3
98669: PPUSH
98670: CALL_OW 67
// if HasTask ( j ) and DangerAtRangeXY ( side , target [ 2 ] , target [ 3 ] , 30 ) [ 4 ] then
98674: LD_VAR 0 3
98678: PPUSH
98679: CALL_OW 314
98683: PUSH
98684: LD_VAR 0 6
98688: PPUSH
98689: LD_VAR 0 7
98693: PUSH
98694: LD_INT 2
98696: ARRAY
98697: PPUSH
98698: LD_VAR 0 7
98702: PUSH
98703: LD_INT 3
98705: ARRAY
98706: PPUSH
98707: LD_INT 30
98709: PPUSH
98710: CALL 25106 0 4
98714: PUSH
98715: LD_INT 4
98717: ARRAY
98718: AND
98719: IFFALSE 98737
// ComStandNearbyBuilding ( j , depot ) else
98721: LD_VAR 0 3
98725: PPUSH
98726: LD_VAR 0 9
98730: PPUSH
98731: CALL 20788 0 2
98735: GO 98764
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
98737: LD_VAR 0 3
98741: PPUSH
98742: LD_VAR 0 7
98746: PUSH
98747: LD_INT 2
98749: ARRAY
98750: PPUSH
98751: LD_VAR 0 7
98755: PUSH
98756: LD_INT 3
98758: ARRAY
98759: PPUSH
98760: CALL_OW 117
// end ;
98764: GO 98542
98766: POP
98767: POP
// end ; end else
98768: GO 99300
// begin for j in cargo do
98770: LD_ADDR_VAR 0 3
98774: PUSH
98775: LD_VAR 0 8
98779: PUSH
98780: FOR_IN
98781: IFFALSE 99298
// begin if GetTag ( j ) <> 0 then
98783: LD_VAR 0 3
98787: PPUSH
98788: CALL_OW 110
98792: PUSH
98793: LD_INT 0
98795: NONEQUAL
98796: IFFALSE 98800
// continue ;
98798: GO 98780
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
98800: LD_VAR 0 3
98804: PPUSH
98805: CALL_OW 256
98809: PUSH
98810: LD_INT 1000
98812: LESS
98813: PUSH
98814: LD_VAR 0 3
98818: PPUSH
98819: LD_EXP 202
98823: PUSH
98824: LD_VAR 0 2
98828: ARRAY
98829: PPUSH
98830: CALL_OW 308
98834: NOT
98835: AND
98836: IFFALSE 98858
// ComMoveToArea ( j , mc_parking [ i ] ) ;
98838: LD_VAR 0 3
98842: PPUSH
98843: LD_EXP 202
98847: PUSH
98848: LD_VAR 0 2
98852: ARRAY
98853: PPUSH
98854: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
98858: LD_VAR 0 3
98862: PPUSH
98863: CALL_OW 256
98867: PUSH
98868: LD_INT 1000
98870: LESS
98871: PUSH
98872: LD_VAR 0 3
98876: PPUSH
98877: LD_EXP 202
98881: PUSH
98882: LD_VAR 0 2
98886: ARRAY
98887: PPUSH
98888: CALL_OW 308
98892: AND
98893: IFFALSE 98897
// continue ;
98895: GO 98780
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
98897: LD_VAR 0 3
98901: PPUSH
98902: CALL_OW 262
98906: PUSH
98907: LD_INT 2
98909: EQUAL
98910: PUSH
98911: LD_VAR 0 3
98915: PPUSH
98916: CALL_OW 261
98920: PUSH
98921: LD_INT 15
98923: LESS
98924: AND
98925: IFFALSE 98929
// continue ;
98927: GO 98780
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
98929: LD_VAR 0 3
98933: PPUSH
98934: CALL_OW 262
98938: PUSH
98939: LD_INT 1
98941: EQUAL
98942: PUSH
98943: LD_VAR 0 3
98947: PPUSH
98948: CALL_OW 261
98952: PUSH
98953: LD_INT 10
98955: LESS
98956: AND
98957: IFFALSE 99237
// begin if not depot then
98959: LD_VAR 0 9
98963: NOT
98964: IFFALSE 98968
// continue ;
98966: GO 98780
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
98968: LD_VAR 0 3
98972: PPUSH
98973: LD_VAR 0 9
98977: PPUSH
98978: LD_VAR 0 3
98982: PPUSH
98983: CALL_OW 74
98987: PPUSH
98988: CALL_OW 296
98992: PUSH
98993: LD_INT 6
98995: LESS
98996: IFFALSE 99012
// SetFuel ( j , 100 ) else
98998: LD_VAR 0 3
99002: PPUSH
99003: LD_INT 100
99005: PPUSH
99006: CALL_OW 240
99010: GO 99237
// if GetFuel ( j ) = 0 then
99012: LD_VAR 0 3
99016: PPUSH
99017: CALL_OW 261
99021: PUSH
99022: LD_INT 0
99024: EQUAL
99025: IFFALSE 99237
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
99027: LD_ADDR_EXP 197
99031: PUSH
99032: LD_EXP 197
99036: PPUSH
99037: LD_VAR 0 2
99041: PPUSH
99042: LD_EXP 197
99046: PUSH
99047: LD_VAR 0 2
99051: ARRAY
99052: PUSH
99053: LD_VAR 0 3
99057: DIFF
99058: PPUSH
99059: CALL_OW 1
99063: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
99064: LD_VAR 0 3
99068: PPUSH
99069: CALL_OW 263
99073: PUSH
99074: LD_INT 1
99076: EQUAL
99077: IFFALSE 99093
// ComExitVehicle ( IsInUnit ( j ) ) ;
99079: LD_VAR 0 3
99083: PPUSH
99084: CALL_OW 310
99088: PPUSH
99089: CALL_OW 121
// if GetControl ( j ) = control_remote then
99093: LD_VAR 0 3
99097: PPUSH
99098: CALL_OW 263
99102: PUSH
99103: LD_INT 2
99105: EQUAL
99106: IFFALSE 99117
// ComUnlink ( j ) ;
99108: LD_VAR 0 3
99112: PPUSH
99113: CALL_OW 136
// fac := MC_GetBuildings ( i , b_factory ) ;
99117: LD_ADDR_VAR 0 10
99121: PUSH
99122: LD_VAR 0 2
99126: PPUSH
99127: LD_INT 3
99129: PPUSH
99130: CALL 108876 0 2
99134: ST_TO_ADDR
// if fac then
99135: LD_VAR 0 10
99139: IFFALSE 99235
// begin for k in fac do
99141: LD_ADDR_VAR 0 4
99145: PUSH
99146: LD_VAR 0 10
99150: PUSH
99151: FOR_IN
99152: IFFALSE 99233
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
99154: LD_ADDR_VAR 0 11
99158: PUSH
99159: LD_VAR 0 10
99163: PPUSH
99164: LD_VAR 0 3
99168: PPUSH
99169: CALL_OW 265
99173: PPUSH
99174: LD_VAR 0 3
99178: PPUSH
99179: CALL_OW 262
99183: PPUSH
99184: LD_VAR 0 3
99188: PPUSH
99189: CALL_OW 263
99193: PPUSH
99194: LD_VAR 0 3
99198: PPUSH
99199: CALL_OW 264
99203: PPUSH
99204: CALL 21706 0 5
99208: ST_TO_ADDR
// if components then
99209: LD_VAR 0 11
99213: IFFALSE 99231
// begin MC_InsertProduceList ( i , components ) ;
99215: LD_VAR 0 2
99219: PPUSH
99220: LD_VAR 0 11
99224: PPUSH
99225: CALL 108421 0 2
// break ;
99229: GO 99233
// end ; end ;
99231: GO 99151
99233: POP
99234: POP
// end ; continue ;
99235: GO 98780
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
99237: LD_VAR 0 3
99241: PPUSH
99242: LD_INT 1
99244: PPUSH
99245: CALL_OW 289
99249: PUSH
99250: LD_INT 100
99252: LESS
99253: PUSH
99254: LD_VAR 0 3
99258: PPUSH
99259: CALL_OW 314
99263: NOT
99264: AND
99265: IFFALSE 99294
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
99267: LD_VAR 0 3
99271: PPUSH
99272: LD_VAR 0 7
99276: PUSH
99277: LD_INT 2
99279: ARRAY
99280: PPUSH
99281: LD_VAR 0 7
99285: PUSH
99286: LD_INT 3
99288: ARRAY
99289: PPUSH
99290: CALL_OW 117
// break ;
99294: GO 99298
// end ;
99296: GO 98780
99298: POP
99299: POP
// end ; end ;
99300: GO 97496
99302: POP
99303: POP
// end ;
99304: LD_VAR 0 1
99308: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
99309: LD_INT 0
99311: PPUSH
99312: PPUSH
99313: PPUSH
99314: PPUSH
// if not mc_bases then
99315: LD_EXP 178
99319: NOT
99320: IFFALSE 99324
// exit ;
99322: GO 99485
// for i = 1 to mc_bases do
99324: LD_ADDR_VAR 0 2
99328: PUSH
99329: DOUBLE
99330: LD_INT 1
99332: DEC
99333: ST_TO_ADDR
99334: LD_EXP 178
99338: PUSH
99339: FOR_TO
99340: IFFALSE 99483
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
99342: LD_ADDR_VAR 0 4
99346: PUSH
99347: LD_EXP 197
99351: PUSH
99352: LD_VAR 0 2
99356: ARRAY
99357: PUSH
99358: LD_EXP 200
99362: PUSH
99363: LD_VAR 0 2
99367: ARRAY
99368: UNION
99369: PPUSH
99370: LD_INT 33
99372: PUSH
99373: LD_INT 2
99375: PUSH
99376: EMPTY
99377: LIST
99378: LIST
99379: PPUSH
99380: CALL_OW 72
99384: ST_TO_ADDR
// if tmp then
99385: LD_VAR 0 4
99389: IFFALSE 99481
// for j in tmp do
99391: LD_ADDR_VAR 0 3
99395: PUSH
99396: LD_VAR 0 4
99400: PUSH
99401: FOR_IN
99402: IFFALSE 99479
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
99404: LD_VAR 0 3
99408: PPUSH
99409: CALL_OW 312
99413: NOT
99414: PUSH
99415: LD_VAR 0 3
99419: PPUSH
99420: CALL_OW 256
99424: PUSH
99425: LD_INT 250
99427: GREATEREQUAL
99428: AND
99429: IFFALSE 99442
// Connect ( j ) else
99431: LD_VAR 0 3
99435: PPUSH
99436: CALL 27181 0 1
99440: GO 99477
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
99442: LD_VAR 0 3
99446: PPUSH
99447: CALL_OW 256
99451: PUSH
99452: LD_INT 250
99454: LESS
99455: PUSH
99456: LD_VAR 0 3
99460: PPUSH
99461: CALL_OW 312
99465: AND
99466: IFFALSE 99477
// ComUnlink ( j ) ;
99468: LD_VAR 0 3
99472: PPUSH
99473: CALL_OW 136
99477: GO 99401
99479: POP
99480: POP
// end ;
99481: GO 99339
99483: POP
99484: POP
// end ;
99485: LD_VAR 0 1
99489: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
99490: LD_INT 0
99492: PPUSH
99493: PPUSH
99494: PPUSH
99495: PPUSH
99496: PPUSH
// if not mc_bases then
99497: LD_EXP 178
99501: NOT
99502: IFFALSE 99506
// exit ;
99504: GO 99951
// for i = 1 to mc_bases do
99506: LD_ADDR_VAR 0 2
99510: PUSH
99511: DOUBLE
99512: LD_INT 1
99514: DEC
99515: ST_TO_ADDR
99516: LD_EXP 178
99520: PUSH
99521: FOR_TO
99522: IFFALSE 99949
// begin if not mc_produce [ i ] then
99524: LD_EXP 199
99528: PUSH
99529: LD_VAR 0 2
99533: ARRAY
99534: NOT
99535: IFFALSE 99539
// continue ;
99537: GO 99521
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
99539: LD_ADDR_VAR 0 5
99543: PUSH
99544: LD_EXP 178
99548: PUSH
99549: LD_VAR 0 2
99553: ARRAY
99554: PPUSH
99555: LD_INT 30
99557: PUSH
99558: LD_INT 3
99560: PUSH
99561: EMPTY
99562: LIST
99563: LIST
99564: PPUSH
99565: CALL_OW 72
99569: ST_TO_ADDR
// if not fac then
99570: LD_VAR 0 5
99574: NOT
99575: IFFALSE 99579
// continue ;
99577: GO 99521
// for j in fac do
99579: LD_ADDR_VAR 0 3
99583: PUSH
99584: LD_VAR 0 5
99588: PUSH
99589: FOR_IN
99590: IFFALSE 99945
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
99592: LD_VAR 0 3
99596: PPUSH
99597: CALL_OW 461
99601: PUSH
99602: LD_INT 2
99604: NONEQUAL
99605: PUSH
99606: LD_VAR 0 3
99610: PPUSH
99611: LD_INT 15
99613: PPUSH
99614: CALL 26809 0 2
99618: PUSH
99619: LD_INT 4
99621: ARRAY
99622: OR
99623: IFFALSE 99627
// continue ;
99625: GO 99589
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
99627: LD_VAR 0 3
99631: PPUSH
99632: LD_EXP 199
99636: PUSH
99637: LD_VAR 0 2
99641: ARRAY
99642: PUSH
99643: LD_INT 1
99645: ARRAY
99646: PUSH
99647: LD_INT 1
99649: ARRAY
99650: PPUSH
99651: LD_EXP 199
99655: PUSH
99656: LD_VAR 0 2
99660: ARRAY
99661: PUSH
99662: LD_INT 1
99664: ARRAY
99665: PUSH
99666: LD_INT 2
99668: ARRAY
99669: PPUSH
99670: LD_EXP 199
99674: PUSH
99675: LD_VAR 0 2
99679: ARRAY
99680: PUSH
99681: LD_INT 1
99683: ARRAY
99684: PUSH
99685: LD_INT 3
99687: ARRAY
99688: PPUSH
99689: LD_EXP 199
99693: PUSH
99694: LD_VAR 0 2
99698: ARRAY
99699: PUSH
99700: LD_INT 1
99702: ARRAY
99703: PUSH
99704: LD_INT 4
99706: ARRAY
99707: PPUSH
99708: CALL_OW 448
99712: PUSH
99713: LD_VAR 0 3
99717: PPUSH
99718: LD_EXP 199
99722: PUSH
99723: LD_VAR 0 2
99727: ARRAY
99728: PUSH
99729: LD_INT 1
99731: ARRAY
99732: PUSH
99733: LD_INT 1
99735: ARRAY
99736: PUSH
99737: LD_EXP 199
99741: PUSH
99742: LD_VAR 0 2
99746: ARRAY
99747: PUSH
99748: LD_INT 1
99750: ARRAY
99751: PUSH
99752: LD_INT 2
99754: ARRAY
99755: PUSH
99756: LD_EXP 199
99760: PUSH
99761: LD_VAR 0 2
99765: ARRAY
99766: PUSH
99767: LD_INT 1
99769: ARRAY
99770: PUSH
99771: LD_INT 3
99773: ARRAY
99774: PUSH
99775: LD_EXP 199
99779: PUSH
99780: LD_VAR 0 2
99784: ARRAY
99785: PUSH
99786: LD_INT 1
99788: ARRAY
99789: PUSH
99790: LD_INT 4
99792: ARRAY
99793: PUSH
99794: EMPTY
99795: LIST
99796: LIST
99797: LIST
99798: LIST
99799: PPUSH
99800: CALL 30576 0 2
99804: AND
99805: IFFALSE 99943
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
99807: LD_VAR 0 3
99811: PPUSH
99812: LD_EXP 199
99816: PUSH
99817: LD_VAR 0 2
99821: ARRAY
99822: PUSH
99823: LD_INT 1
99825: ARRAY
99826: PUSH
99827: LD_INT 1
99829: ARRAY
99830: PPUSH
99831: LD_EXP 199
99835: PUSH
99836: LD_VAR 0 2
99840: ARRAY
99841: PUSH
99842: LD_INT 1
99844: ARRAY
99845: PUSH
99846: LD_INT 2
99848: ARRAY
99849: PPUSH
99850: LD_EXP 199
99854: PUSH
99855: LD_VAR 0 2
99859: ARRAY
99860: PUSH
99861: LD_INT 1
99863: ARRAY
99864: PUSH
99865: LD_INT 3
99867: ARRAY
99868: PPUSH
99869: LD_EXP 199
99873: PUSH
99874: LD_VAR 0 2
99878: ARRAY
99879: PUSH
99880: LD_INT 1
99882: ARRAY
99883: PUSH
99884: LD_INT 4
99886: ARRAY
99887: PPUSH
99888: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
99892: LD_ADDR_VAR 0 4
99896: PUSH
99897: LD_EXP 199
99901: PUSH
99902: LD_VAR 0 2
99906: ARRAY
99907: PPUSH
99908: LD_INT 1
99910: PPUSH
99911: CALL_OW 3
99915: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
99916: LD_ADDR_EXP 199
99920: PUSH
99921: LD_EXP 199
99925: PPUSH
99926: LD_VAR 0 2
99930: PPUSH
99931: LD_VAR 0 4
99935: PPUSH
99936: CALL_OW 1
99940: ST_TO_ADDR
// break ;
99941: GO 99945
// end ; end ;
99943: GO 99589
99945: POP
99946: POP
// end ;
99947: GO 99521
99949: POP
99950: POP
// end ;
99951: LD_VAR 0 1
99955: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
99956: LD_INT 0
99958: PPUSH
99959: PPUSH
99960: PPUSH
// if not mc_bases then
99961: LD_EXP 178
99965: NOT
99966: IFFALSE 99970
// exit ;
99968: GO 100059
// for i = 1 to mc_bases do
99970: LD_ADDR_VAR 0 2
99974: PUSH
99975: DOUBLE
99976: LD_INT 1
99978: DEC
99979: ST_TO_ADDR
99980: LD_EXP 178
99984: PUSH
99985: FOR_TO
99986: IFFALSE 100057
// begin if mc_attack [ i ] then
99988: LD_EXP 198
99992: PUSH
99993: LD_VAR 0 2
99997: ARRAY
99998: IFFALSE 100055
// begin tmp := mc_attack [ i ] [ 1 ] ;
100000: LD_ADDR_VAR 0 3
100004: PUSH
100005: LD_EXP 198
100009: PUSH
100010: LD_VAR 0 2
100014: ARRAY
100015: PUSH
100016: LD_INT 1
100018: ARRAY
100019: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
100020: LD_ADDR_EXP 198
100024: PUSH
100025: LD_EXP 198
100029: PPUSH
100030: LD_VAR 0 2
100034: PPUSH
100035: EMPTY
100036: PPUSH
100037: CALL_OW 1
100041: ST_TO_ADDR
// Attack ( tmp ) ;
100042: LD_VAR 0 3
100046: PPUSH
100047: CALL 76900 0 1
// exit ;
100051: POP
100052: POP
100053: GO 100059
// end ; end ;
100055: GO 99985
100057: POP
100058: POP
// end ;
100059: LD_VAR 0 1
100063: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
100064: LD_INT 0
100066: PPUSH
100067: PPUSH
100068: PPUSH
100069: PPUSH
100070: PPUSH
100071: PPUSH
100072: PPUSH
// if not mc_bases then
100073: LD_EXP 178
100077: NOT
100078: IFFALSE 100082
// exit ;
100080: GO 100939
// for i = 1 to mc_bases do
100082: LD_ADDR_VAR 0 2
100086: PUSH
100087: DOUBLE
100088: LD_INT 1
100090: DEC
100091: ST_TO_ADDR
100092: LD_EXP 178
100096: PUSH
100097: FOR_TO
100098: IFFALSE 100937
// begin if not mc_bases [ i ] then
100100: LD_EXP 178
100104: PUSH
100105: LD_VAR 0 2
100109: ARRAY
100110: NOT
100111: IFFALSE 100115
// continue ;
100113: GO 100097
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
100115: LD_ADDR_VAR 0 7
100119: PUSH
100120: LD_EXP 178
100124: PUSH
100125: LD_VAR 0 2
100129: ARRAY
100130: PUSH
100131: LD_INT 1
100133: ARRAY
100134: PPUSH
100135: CALL 21010 0 1
100139: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
100140: LD_ADDR_EXP 201
100144: PUSH
100145: LD_EXP 201
100149: PPUSH
100150: LD_VAR 0 2
100154: PPUSH
100155: LD_EXP 178
100159: PUSH
100160: LD_VAR 0 2
100164: ARRAY
100165: PUSH
100166: LD_INT 1
100168: ARRAY
100169: PPUSH
100170: CALL_OW 255
100174: PPUSH
100175: LD_EXP 203
100179: PUSH
100180: LD_VAR 0 2
100184: ARRAY
100185: PPUSH
100186: CALL 20975 0 2
100190: PPUSH
100191: CALL_OW 1
100195: ST_TO_ADDR
// if not mc_scan [ i ] then
100196: LD_EXP 201
100200: PUSH
100201: LD_VAR 0 2
100205: ARRAY
100206: NOT
100207: IFFALSE 100385
// begin mc_is_defending := Replace ( mc_is_defending , i , false ) ;
100209: LD_ADDR_EXP 221
100213: PUSH
100214: LD_EXP 221
100218: PPUSH
100219: LD_VAR 0 2
100223: PPUSH
100224: LD_INT 0
100226: PPUSH
100227: CALL_OW 1
100231: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
100232: LD_ADDR_VAR 0 4
100236: PUSH
100237: LD_EXP 178
100241: PUSH
100242: LD_VAR 0 2
100246: ARRAY
100247: PPUSH
100248: LD_INT 2
100250: PUSH
100251: LD_INT 25
100253: PUSH
100254: LD_INT 5
100256: PUSH
100257: EMPTY
100258: LIST
100259: LIST
100260: PUSH
100261: LD_INT 25
100263: PUSH
100264: LD_INT 8
100266: PUSH
100267: EMPTY
100268: LIST
100269: LIST
100270: PUSH
100271: LD_INT 25
100273: PUSH
100274: LD_INT 9
100276: PUSH
100277: EMPTY
100278: LIST
100279: LIST
100280: PUSH
100281: EMPTY
100282: LIST
100283: LIST
100284: LIST
100285: LIST
100286: PPUSH
100287: CALL_OW 72
100291: ST_TO_ADDR
// if not tmp then
100292: LD_VAR 0 4
100296: NOT
100297: IFFALSE 100301
// continue ;
100299: GO 100097
// for j in tmp do
100301: LD_ADDR_VAR 0 3
100305: PUSH
100306: LD_VAR 0 4
100310: PUSH
100311: FOR_IN
100312: IFFALSE 100383
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
100314: LD_VAR 0 3
100318: PPUSH
100319: CALL_OW 310
100323: PPUSH
100324: CALL_OW 266
100328: PUSH
100329: LD_INT 5
100331: EQUAL
100332: PUSH
100333: LD_VAR 0 3
100337: PPUSH
100338: CALL_OW 257
100342: PUSH
100343: LD_INT 1
100345: EQUAL
100346: AND
100347: PUSH
100348: LD_VAR 0 3
100352: PPUSH
100353: CALL_OW 459
100357: NOT
100358: AND
100359: PUSH
100360: LD_VAR 0 7
100364: AND
100365: IFFALSE 100381
// ComChangeProfession ( j , class ) ;
100367: LD_VAR 0 3
100371: PPUSH
100372: LD_VAR 0 7
100376: PPUSH
100377: CALL_OW 123
100381: GO 100311
100383: POP
100384: POP
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and not mc_defender [ i ] and ( UnitFilter ( mc_bases [ i ] , [ [ f_ok ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) < 4 or UnitFilter ( mc_bases [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ) then
100385: LD_EXP 201
100389: PUSH
100390: LD_VAR 0 2
100394: ARRAY
100395: PUSH
100396: LD_EXP 221
100400: PUSH
100401: LD_VAR 0 2
100405: ARRAY
100406: NOT
100407: AND
100408: PUSH
100409: LD_EXP 200
100413: PUSH
100414: LD_VAR 0 2
100418: ARRAY
100419: NOT
100420: AND
100421: PUSH
100422: LD_EXP 178
100426: PUSH
100427: LD_VAR 0 2
100431: ARRAY
100432: PPUSH
100433: LD_INT 50
100435: PUSH
100436: EMPTY
100437: LIST
100438: PUSH
100439: LD_INT 2
100441: PUSH
100442: LD_INT 30
100444: PUSH
100445: LD_INT 32
100447: PUSH
100448: EMPTY
100449: LIST
100450: LIST
100451: PUSH
100452: LD_INT 30
100454: PUSH
100455: LD_INT 33
100457: PUSH
100458: EMPTY
100459: LIST
100460: LIST
100461: PUSH
100462: LD_INT 30
100464: PUSH
100465: LD_INT 4
100467: PUSH
100468: EMPTY
100469: LIST
100470: LIST
100471: PUSH
100472: LD_INT 30
100474: PUSH
100475: LD_INT 5
100477: PUSH
100478: EMPTY
100479: LIST
100480: LIST
100481: PUSH
100482: EMPTY
100483: LIST
100484: LIST
100485: LIST
100486: LIST
100487: LIST
100488: PUSH
100489: EMPTY
100490: LIST
100491: LIST
100492: PPUSH
100493: CALL_OW 72
100497: PUSH
100498: LD_INT 4
100500: LESS
100501: PUSH
100502: LD_EXP 178
100506: PUSH
100507: LD_VAR 0 2
100511: ARRAY
100512: PPUSH
100513: LD_INT 3
100515: PUSH
100516: LD_INT 24
100518: PUSH
100519: LD_INT 1000
100521: PUSH
100522: EMPTY
100523: LIST
100524: LIST
100525: PUSH
100526: EMPTY
100527: LIST
100528: LIST
100529: PUSH
100530: LD_INT 2
100532: PUSH
100533: LD_INT 30
100535: PUSH
100536: LD_INT 0
100538: PUSH
100539: EMPTY
100540: LIST
100541: LIST
100542: PUSH
100543: LD_INT 30
100545: PUSH
100546: LD_INT 1
100548: PUSH
100549: EMPTY
100550: LIST
100551: LIST
100552: PUSH
100553: EMPTY
100554: LIST
100555: LIST
100556: LIST
100557: PUSH
100558: EMPTY
100559: LIST
100560: LIST
100561: PPUSH
100562: CALL_OW 72
100566: OR
100567: AND
100568: IFFALSE 100819
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
100570: LD_ADDR_EXP 221
100574: PUSH
100575: LD_EXP 221
100579: PPUSH
100580: LD_VAR 0 2
100584: PPUSH
100585: LD_INT 1
100587: PPUSH
100588: CALL_OW 1
100592: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
100593: LD_ADDR_VAR 0 4
100597: PUSH
100598: LD_EXP 178
100602: PUSH
100603: LD_VAR 0 2
100607: ARRAY
100608: PPUSH
100609: LD_INT 2
100611: PUSH
100612: LD_INT 25
100614: PUSH
100615: LD_INT 1
100617: PUSH
100618: EMPTY
100619: LIST
100620: LIST
100621: PUSH
100622: LD_INT 25
100624: PUSH
100625: LD_INT 5
100627: PUSH
100628: EMPTY
100629: LIST
100630: LIST
100631: PUSH
100632: LD_INT 25
100634: PUSH
100635: LD_INT 8
100637: PUSH
100638: EMPTY
100639: LIST
100640: LIST
100641: PUSH
100642: LD_INT 25
100644: PUSH
100645: LD_INT 9
100647: PUSH
100648: EMPTY
100649: LIST
100650: LIST
100651: PUSH
100652: EMPTY
100653: LIST
100654: LIST
100655: LIST
100656: LIST
100657: LIST
100658: PPUSH
100659: CALL_OW 72
100663: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
100664: LD_ADDR_VAR 0 4
100668: PUSH
100669: LD_VAR 0 4
100673: PUSH
100674: LD_VAR 0 4
100678: PPUSH
100679: LD_INT 18
100681: PPUSH
100682: CALL 53479 0 2
100686: DIFF
100687: ST_TO_ADDR
// if not tmp and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
100688: LD_VAR 0 4
100692: NOT
100693: PUSH
100694: LD_EXP 178
100698: PUSH
100699: LD_VAR 0 2
100703: ARRAY
100704: PPUSH
100705: LD_INT 2
100707: PUSH
100708: LD_INT 30
100710: PUSH
100711: LD_INT 4
100713: PUSH
100714: EMPTY
100715: LIST
100716: LIST
100717: PUSH
100718: LD_INT 30
100720: PUSH
100721: LD_INT 5
100723: PUSH
100724: EMPTY
100725: LIST
100726: LIST
100727: PUSH
100728: EMPTY
100729: LIST
100730: LIST
100731: LIST
100732: PPUSH
100733: CALL_OW 72
100737: NOT
100738: AND
100739: IFFALSE 100801
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ) ;
100741: LD_ADDR_VAR 0 4
100745: PUSH
100746: LD_EXP 178
100750: PUSH
100751: LD_VAR 0 2
100755: ARRAY
100756: PPUSH
100757: LD_INT 2
100759: PUSH
100760: LD_INT 25
100762: PUSH
100763: LD_INT 2
100765: PUSH
100766: EMPTY
100767: LIST
100768: LIST
100769: PUSH
100770: LD_INT 25
100772: PUSH
100773: LD_INT 3
100775: PUSH
100776: EMPTY
100777: LIST
100778: LIST
100779: PUSH
100780: LD_INT 25
100782: PUSH
100783: LD_INT 4
100785: PUSH
100786: EMPTY
100787: LIST
100788: LIST
100789: PUSH
100790: EMPTY
100791: LIST
100792: LIST
100793: LIST
100794: LIST
100795: PPUSH
100796: CALL_OW 72
100800: ST_TO_ADDR
// BasicDefend ( i , tmp ) ;
100801: LD_VAR 0 2
100805: PPUSH
100806: LD_VAR 0 4
100810: PPUSH
100811: CALL 81609 0 2
// exit ;
100815: POP
100816: POP
100817: GO 100939
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and mc_defender [ i ] then
100819: LD_EXP 201
100823: PUSH
100824: LD_VAR 0 2
100828: ARRAY
100829: PUSH
100830: LD_EXP 221
100834: PUSH
100835: LD_VAR 0 2
100839: ARRAY
100840: NOT
100841: AND
100842: PUSH
100843: LD_EXP 200
100847: PUSH
100848: LD_VAR 0 2
100852: ARRAY
100853: AND
100854: IFFALSE 100935
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
100856: LD_ADDR_EXP 221
100860: PUSH
100861: LD_EXP 221
100865: PPUSH
100866: LD_VAR 0 2
100870: PPUSH
100871: LD_INT 1
100873: PPUSH
100874: CALL_OW 1
100878: ST_TO_ADDR
// tmp := mc_defender [ i ] ;
100879: LD_ADDR_VAR 0 4
100883: PUSH
100884: LD_EXP 200
100888: PUSH
100889: LD_VAR 0 2
100893: ARRAY
100894: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
100895: LD_ADDR_EXP 200
100899: PUSH
100900: LD_EXP 200
100904: PPUSH
100905: LD_VAR 0 2
100909: PPUSH
100910: EMPTY
100911: PPUSH
100912: CALL_OW 1
100916: ST_TO_ADDR
// Defend ( i , tmp ) ;
100917: LD_VAR 0 2
100921: PPUSH
100922: LD_VAR 0 4
100926: PPUSH
100927: CALL 82205 0 2
// exit ;
100931: POP
100932: POP
100933: GO 100939
// end ; end ;
100935: GO 100097
100937: POP
100938: POP
// end ;
100939: LD_VAR 0 1
100943: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
100944: LD_INT 0
100946: PPUSH
100947: PPUSH
100948: PPUSH
100949: PPUSH
100950: PPUSH
100951: PPUSH
100952: PPUSH
100953: PPUSH
100954: PPUSH
100955: PPUSH
100956: PPUSH
// if not mc_bases then
100957: LD_EXP 178
100961: NOT
100962: IFFALSE 100966
// exit ;
100964: GO 102053
// for i = 1 to mc_bases do
100966: LD_ADDR_VAR 0 2
100970: PUSH
100971: DOUBLE
100972: LD_INT 1
100974: DEC
100975: ST_TO_ADDR
100976: LD_EXP 178
100980: PUSH
100981: FOR_TO
100982: IFFALSE 102051
// begin tmp := mc_lab [ i ] ;
100984: LD_ADDR_VAR 0 6
100988: PUSH
100989: LD_EXP 211
100993: PUSH
100994: LD_VAR 0 2
100998: ARRAY
100999: ST_TO_ADDR
// if not tmp then
101000: LD_VAR 0 6
101004: NOT
101005: IFFALSE 101009
// continue ;
101007: GO 100981
// idle_lab := 0 ;
101009: LD_ADDR_VAR 0 11
101013: PUSH
101014: LD_INT 0
101016: ST_TO_ADDR
// for j in tmp do
101017: LD_ADDR_VAR 0 3
101021: PUSH
101022: LD_VAR 0 6
101026: PUSH
101027: FOR_IN
101028: IFFALSE 102047
// begin researching := false ;
101030: LD_ADDR_VAR 0 10
101034: PUSH
101035: LD_INT 0
101037: ST_TO_ADDR
// side := GetSide ( j ) ;
101038: LD_ADDR_VAR 0 4
101042: PUSH
101043: LD_VAR 0 3
101047: PPUSH
101048: CALL_OW 255
101052: ST_TO_ADDR
// if not mc_tech [ side ] then
101053: LD_EXP 205
101057: PUSH
101058: LD_VAR 0 4
101062: ARRAY
101063: NOT
101064: IFFALSE 101068
// continue ;
101066: GO 101027
// if BuildingStatus ( j ) = bs_idle then
101068: LD_VAR 0 3
101072: PPUSH
101073: CALL_OW 461
101077: PUSH
101078: LD_INT 2
101080: EQUAL
101081: IFFALSE 101269
// begin if idle_lab and UnitsInside ( j ) < 6 then
101083: LD_VAR 0 11
101087: PUSH
101088: LD_VAR 0 3
101092: PPUSH
101093: CALL_OW 313
101097: PUSH
101098: LD_INT 6
101100: LESS
101101: AND
101102: IFFALSE 101173
// begin tmp2 := UnitsInside ( idle_lab ) ;
101104: LD_ADDR_VAR 0 9
101108: PUSH
101109: LD_VAR 0 11
101113: PPUSH
101114: CALL_OW 313
101118: ST_TO_ADDR
// if tmp2 then
101119: LD_VAR 0 9
101123: IFFALSE 101165
// for x in tmp2 do
101125: LD_ADDR_VAR 0 7
101129: PUSH
101130: LD_VAR 0 9
101134: PUSH
101135: FOR_IN
101136: IFFALSE 101163
// begin ComExitBuilding ( x ) ;
101138: LD_VAR 0 7
101142: PPUSH
101143: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
101147: LD_VAR 0 7
101151: PPUSH
101152: LD_VAR 0 3
101156: PPUSH
101157: CALL_OW 180
// end ;
101161: GO 101135
101163: POP
101164: POP
// idle_lab := 0 ;
101165: LD_ADDR_VAR 0 11
101169: PUSH
101170: LD_INT 0
101172: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
101173: LD_ADDR_VAR 0 5
101177: PUSH
101178: LD_EXP 205
101182: PUSH
101183: LD_VAR 0 4
101187: ARRAY
101188: PUSH
101189: FOR_IN
101190: IFFALSE 101250
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
101192: LD_VAR 0 3
101196: PPUSH
101197: LD_VAR 0 5
101201: PPUSH
101202: CALL_OW 430
101206: PUSH
101207: LD_VAR 0 4
101211: PPUSH
101212: LD_VAR 0 5
101216: PPUSH
101217: CALL 20080 0 2
101221: AND
101222: IFFALSE 101248
// begin researching := true ;
101224: LD_ADDR_VAR 0 10
101228: PUSH
101229: LD_INT 1
101231: ST_TO_ADDR
// ComResearch ( j , t ) ;
101232: LD_VAR 0 3
101236: PPUSH
101237: LD_VAR 0 5
101241: PPUSH
101242: CALL_OW 124
// break ;
101246: GO 101250
// end ;
101248: GO 101189
101250: POP
101251: POP
// if not researching then
101252: LD_VAR 0 10
101256: NOT
101257: IFFALSE 101269
// idle_lab := j ;
101259: LD_ADDR_VAR 0 11
101263: PUSH
101264: LD_VAR 0 3
101268: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
101269: LD_VAR 0 3
101273: PPUSH
101274: CALL_OW 461
101278: PUSH
101279: LD_INT 10
101281: EQUAL
101282: IFFALSE 101870
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
101284: LD_EXP 207
101288: PUSH
101289: LD_VAR 0 2
101293: ARRAY
101294: NOT
101295: PUSH
101296: LD_EXP 208
101300: PUSH
101301: LD_VAR 0 2
101305: ARRAY
101306: NOT
101307: AND
101308: PUSH
101309: LD_EXP 205
101313: PUSH
101314: LD_VAR 0 4
101318: ARRAY
101319: PUSH
101320: LD_INT 1
101322: GREATER
101323: AND
101324: IFFALSE 101455
// begin ComCancel ( j ) ;
101326: LD_VAR 0 3
101330: PPUSH
101331: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
101335: LD_ADDR_EXP 205
101339: PUSH
101340: LD_EXP 205
101344: PPUSH
101345: LD_VAR 0 4
101349: PPUSH
101350: LD_EXP 205
101354: PUSH
101355: LD_VAR 0 4
101359: ARRAY
101360: PPUSH
101361: LD_EXP 205
101365: PUSH
101366: LD_VAR 0 4
101370: ARRAY
101371: PUSH
101372: LD_INT 1
101374: MINUS
101375: PPUSH
101376: LD_EXP 205
101380: PUSH
101381: LD_VAR 0 4
101385: ARRAY
101386: PPUSH
101387: LD_INT 0
101389: PPUSH
101390: CALL 23628 0 4
101394: PPUSH
101395: CALL_OW 1
101399: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
101400: LD_ADDR_EXP 205
101404: PUSH
101405: LD_EXP 205
101409: PPUSH
101410: LD_VAR 0 4
101414: PPUSH
101415: LD_EXP 205
101419: PUSH
101420: LD_VAR 0 4
101424: ARRAY
101425: PPUSH
101426: LD_EXP 205
101430: PUSH
101431: LD_VAR 0 4
101435: ARRAY
101436: PPUSH
101437: LD_INT 1
101439: PPUSH
101440: LD_INT 0
101442: PPUSH
101443: CALL 23628 0 4
101447: PPUSH
101448: CALL_OW 1
101452: ST_TO_ADDR
// continue ;
101453: GO 101027
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
101455: LD_EXP 207
101459: PUSH
101460: LD_VAR 0 2
101464: ARRAY
101465: PUSH
101466: LD_EXP 208
101470: PUSH
101471: LD_VAR 0 2
101475: ARRAY
101476: NOT
101477: AND
101478: IFFALSE 101605
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
101480: LD_ADDR_EXP 208
101484: PUSH
101485: LD_EXP 208
101489: PPUSH
101490: LD_VAR 0 2
101494: PUSH
101495: LD_EXP 208
101499: PUSH
101500: LD_VAR 0 2
101504: ARRAY
101505: PUSH
101506: LD_INT 1
101508: PLUS
101509: PUSH
101510: EMPTY
101511: LIST
101512: LIST
101513: PPUSH
101514: LD_EXP 207
101518: PUSH
101519: LD_VAR 0 2
101523: ARRAY
101524: PUSH
101525: LD_INT 1
101527: ARRAY
101528: PPUSH
101529: CALL 24210 0 3
101533: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
101534: LD_EXP 207
101538: PUSH
101539: LD_VAR 0 2
101543: ARRAY
101544: PUSH
101545: LD_INT 1
101547: ARRAY
101548: PPUSH
101549: LD_INT 112
101551: PPUSH
101552: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
101556: LD_ADDR_VAR 0 9
101560: PUSH
101561: LD_EXP 207
101565: PUSH
101566: LD_VAR 0 2
101570: ARRAY
101571: PPUSH
101572: LD_INT 1
101574: PPUSH
101575: CALL_OW 3
101579: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
101580: LD_ADDR_EXP 207
101584: PUSH
101585: LD_EXP 207
101589: PPUSH
101590: LD_VAR 0 2
101594: PPUSH
101595: LD_VAR 0 9
101599: PPUSH
101600: CALL_OW 1
101604: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
101605: LD_EXP 207
101609: PUSH
101610: LD_VAR 0 2
101614: ARRAY
101615: PUSH
101616: LD_EXP 208
101620: PUSH
101621: LD_VAR 0 2
101625: ARRAY
101626: AND
101627: PUSH
101628: LD_EXP 208
101632: PUSH
101633: LD_VAR 0 2
101637: ARRAY
101638: PUSH
101639: LD_INT 1
101641: ARRAY
101642: PPUSH
101643: CALL_OW 310
101647: NOT
101648: AND
101649: PUSH
101650: LD_VAR 0 3
101654: PPUSH
101655: CALL_OW 313
101659: PUSH
101660: LD_INT 6
101662: EQUAL
101663: AND
101664: IFFALSE 101720
// begin tmp2 := UnitsInside ( j ) ;
101666: LD_ADDR_VAR 0 9
101670: PUSH
101671: LD_VAR 0 3
101675: PPUSH
101676: CALL_OW 313
101680: ST_TO_ADDR
// if tmp2 = 6 then
101681: LD_VAR 0 9
101685: PUSH
101686: LD_INT 6
101688: EQUAL
101689: IFFALSE 101720
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
101691: LD_VAR 0 9
101695: PUSH
101696: LD_INT 1
101698: ARRAY
101699: PPUSH
101700: LD_INT 112
101702: PPUSH
101703: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
101707: LD_VAR 0 9
101711: PUSH
101712: LD_INT 1
101714: ARRAY
101715: PPUSH
101716: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
101720: LD_EXP 208
101724: PUSH
101725: LD_VAR 0 2
101729: ARRAY
101730: PUSH
101731: LD_EXP 208
101735: PUSH
101736: LD_VAR 0 2
101740: ARRAY
101741: PUSH
101742: LD_INT 1
101744: ARRAY
101745: PPUSH
101746: CALL_OW 314
101750: NOT
101751: AND
101752: PUSH
101753: LD_EXP 208
101757: PUSH
101758: LD_VAR 0 2
101762: ARRAY
101763: PUSH
101764: LD_INT 1
101766: ARRAY
101767: PPUSH
101768: CALL_OW 310
101772: NOT
101773: AND
101774: IFFALSE 101800
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
101776: LD_EXP 208
101780: PUSH
101781: LD_VAR 0 2
101785: ARRAY
101786: PUSH
101787: LD_INT 1
101789: ARRAY
101790: PPUSH
101791: LD_VAR 0 3
101795: PPUSH
101796: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
101800: LD_EXP 208
101804: PUSH
101805: LD_VAR 0 2
101809: ARRAY
101810: PUSH
101811: LD_INT 1
101813: ARRAY
101814: PPUSH
101815: CALL_OW 310
101819: PUSH
101820: LD_EXP 208
101824: PUSH
101825: LD_VAR 0 2
101829: ARRAY
101830: PUSH
101831: LD_INT 1
101833: ARRAY
101834: PPUSH
101835: CALL_OW 310
101839: PPUSH
101840: CALL_OW 461
101844: PUSH
101845: LD_INT 3
101847: NONEQUAL
101848: AND
101849: IFFALSE 101870
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
101851: LD_EXP 208
101855: PUSH
101856: LD_VAR 0 2
101860: ARRAY
101861: PUSH
101862: LD_INT 1
101864: ARRAY
101865: PPUSH
101866: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
101870: LD_VAR 0 3
101874: PPUSH
101875: CALL_OW 461
101879: PUSH
101880: LD_INT 6
101882: EQUAL
101883: PUSH
101884: LD_VAR 0 6
101888: PUSH
101889: LD_INT 1
101891: GREATER
101892: AND
101893: IFFALSE 102045
// begin sci := [ ] ;
101895: LD_ADDR_VAR 0 8
101899: PUSH
101900: EMPTY
101901: ST_TO_ADDR
// for x in ( tmp diff j ) do
101902: LD_ADDR_VAR 0 7
101906: PUSH
101907: LD_VAR 0 6
101911: PUSH
101912: LD_VAR 0 3
101916: DIFF
101917: PUSH
101918: FOR_IN
101919: IFFALSE 101971
// begin if sci = 6 then
101921: LD_VAR 0 8
101925: PUSH
101926: LD_INT 6
101928: EQUAL
101929: IFFALSE 101933
// break ;
101931: GO 101971
// if BuildingStatus ( x ) = bs_idle then
101933: LD_VAR 0 7
101937: PPUSH
101938: CALL_OW 461
101942: PUSH
101943: LD_INT 2
101945: EQUAL
101946: IFFALSE 101969
// sci := sci ^ UnitsInside ( x ) ;
101948: LD_ADDR_VAR 0 8
101952: PUSH
101953: LD_VAR 0 8
101957: PUSH
101958: LD_VAR 0 7
101962: PPUSH
101963: CALL_OW 313
101967: ADD
101968: ST_TO_ADDR
// end ;
101969: GO 101918
101971: POP
101972: POP
// if not sci then
101973: LD_VAR 0 8
101977: NOT
101978: IFFALSE 101982
// continue ;
101980: GO 101027
// for x in sci do
101982: LD_ADDR_VAR 0 7
101986: PUSH
101987: LD_VAR 0 8
101991: PUSH
101992: FOR_IN
101993: IFFALSE 102043
// if IsInUnit ( x ) and not HasTask ( x ) then
101995: LD_VAR 0 7
101999: PPUSH
102000: CALL_OW 310
102004: PUSH
102005: LD_VAR 0 7
102009: PPUSH
102010: CALL_OW 314
102014: NOT
102015: AND
102016: IFFALSE 102041
// begin ComExitBuilding ( x ) ;
102018: LD_VAR 0 7
102022: PPUSH
102023: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
102027: LD_VAR 0 7
102031: PPUSH
102032: LD_VAR 0 3
102036: PPUSH
102037: CALL_OW 180
// end ;
102041: GO 101992
102043: POP
102044: POP
// end ; end ;
102045: GO 101027
102047: POP
102048: POP
// end ;
102049: GO 100981
102051: POP
102052: POP
// end ;
102053: LD_VAR 0 1
102057: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
102058: LD_INT 0
102060: PPUSH
102061: PPUSH
// if not mc_bases then
102062: LD_EXP 178
102066: NOT
102067: IFFALSE 102071
// exit ;
102069: GO 102152
// for i = 1 to mc_bases do
102071: LD_ADDR_VAR 0 2
102075: PUSH
102076: DOUBLE
102077: LD_INT 1
102079: DEC
102080: ST_TO_ADDR
102081: LD_EXP 178
102085: PUSH
102086: FOR_TO
102087: IFFALSE 102150
// if mc_mines [ i ] and mc_miners [ i ] then
102089: LD_EXP 191
102093: PUSH
102094: LD_VAR 0 2
102098: ARRAY
102099: PUSH
102100: LD_EXP 192
102104: PUSH
102105: LD_VAR 0 2
102109: ARRAY
102110: AND
102111: IFFALSE 102148
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
102113: LD_EXP 192
102117: PUSH
102118: LD_VAR 0 2
102122: ARRAY
102123: PUSH
102124: LD_INT 1
102126: ARRAY
102127: PPUSH
102128: CALL_OW 255
102132: PPUSH
102133: LD_EXP 191
102137: PUSH
102138: LD_VAR 0 2
102142: ARRAY
102143: PPUSH
102144: CALL 21163 0 2
102148: GO 102086
102150: POP
102151: POP
// end ;
102152: LD_VAR 0 1
102156: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
102157: LD_INT 0
102159: PPUSH
102160: PPUSH
102161: PPUSH
102162: PPUSH
102163: PPUSH
102164: PPUSH
102165: PPUSH
102166: PPUSH
// if not mc_bases or not mc_parking then
102167: LD_EXP 178
102171: NOT
102172: PUSH
102173: LD_EXP 202
102177: NOT
102178: OR
102179: IFFALSE 102183
// exit ;
102181: GO 102893
// for i = 1 to mc_bases do
102183: LD_ADDR_VAR 0 2
102187: PUSH
102188: DOUBLE
102189: LD_INT 1
102191: DEC
102192: ST_TO_ADDR
102193: LD_EXP 178
102197: PUSH
102198: FOR_TO
102199: IFFALSE 102891
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
102201: LD_EXP 178
102205: PUSH
102206: LD_VAR 0 2
102210: ARRAY
102211: NOT
102212: PUSH
102213: LD_EXP 202
102217: PUSH
102218: LD_VAR 0 2
102222: ARRAY
102223: NOT
102224: OR
102225: IFFALSE 102229
// continue ;
102227: GO 102198
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
102229: LD_ADDR_VAR 0 5
102233: PUSH
102234: LD_EXP 178
102238: PUSH
102239: LD_VAR 0 2
102243: ARRAY
102244: PUSH
102245: LD_INT 1
102247: ARRAY
102248: PPUSH
102249: CALL_OW 255
102253: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
102254: LD_ADDR_VAR 0 6
102258: PUSH
102259: LD_EXP 178
102263: PUSH
102264: LD_VAR 0 2
102268: ARRAY
102269: PPUSH
102270: LD_INT 30
102272: PUSH
102273: LD_INT 3
102275: PUSH
102276: EMPTY
102277: LIST
102278: LIST
102279: PPUSH
102280: CALL_OW 72
102284: ST_TO_ADDR
// if not fac then
102285: LD_VAR 0 6
102289: NOT
102290: IFFALSE 102341
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
102292: LD_ADDR_VAR 0 6
102296: PUSH
102297: LD_EXP 178
102301: PUSH
102302: LD_VAR 0 2
102306: ARRAY
102307: PPUSH
102308: LD_INT 2
102310: PUSH
102311: LD_INT 30
102313: PUSH
102314: LD_INT 0
102316: PUSH
102317: EMPTY
102318: LIST
102319: LIST
102320: PUSH
102321: LD_INT 30
102323: PUSH
102324: LD_INT 1
102326: PUSH
102327: EMPTY
102328: LIST
102329: LIST
102330: PUSH
102331: EMPTY
102332: LIST
102333: LIST
102334: LIST
102335: PPUSH
102336: CALL_OW 72
102340: ST_TO_ADDR
// if not fac then
102341: LD_VAR 0 6
102345: NOT
102346: IFFALSE 102350
// continue ;
102348: GO 102198
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
102350: LD_ADDR_VAR 0 7
102354: PUSH
102355: LD_EXP 202
102359: PUSH
102360: LD_VAR 0 2
102364: ARRAY
102365: PPUSH
102366: LD_INT 22
102368: PUSH
102369: LD_VAR 0 5
102373: PUSH
102374: EMPTY
102375: LIST
102376: LIST
102377: PUSH
102378: LD_INT 21
102380: PUSH
102381: LD_INT 2
102383: PUSH
102384: EMPTY
102385: LIST
102386: LIST
102387: PUSH
102388: LD_INT 3
102390: PUSH
102391: LD_INT 24
102393: PUSH
102394: LD_INT 1000
102396: PUSH
102397: EMPTY
102398: LIST
102399: LIST
102400: PUSH
102401: EMPTY
102402: LIST
102403: LIST
102404: PUSH
102405: EMPTY
102406: LIST
102407: LIST
102408: LIST
102409: PPUSH
102410: CALL_OW 70
102414: ST_TO_ADDR
// for j in fac do
102415: LD_ADDR_VAR 0 3
102419: PUSH
102420: LD_VAR 0 6
102424: PUSH
102425: FOR_IN
102426: IFFALSE 102507
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
102428: LD_ADDR_VAR 0 7
102432: PUSH
102433: LD_VAR 0 7
102437: PUSH
102438: LD_INT 22
102440: PUSH
102441: LD_VAR 0 5
102445: PUSH
102446: EMPTY
102447: LIST
102448: LIST
102449: PUSH
102450: LD_INT 91
102452: PUSH
102453: LD_VAR 0 3
102457: PUSH
102458: LD_INT 15
102460: PUSH
102461: EMPTY
102462: LIST
102463: LIST
102464: LIST
102465: PUSH
102466: LD_INT 21
102468: PUSH
102469: LD_INT 2
102471: PUSH
102472: EMPTY
102473: LIST
102474: LIST
102475: PUSH
102476: LD_INT 3
102478: PUSH
102479: LD_INT 24
102481: PUSH
102482: LD_INT 1000
102484: PUSH
102485: EMPTY
102486: LIST
102487: LIST
102488: PUSH
102489: EMPTY
102490: LIST
102491: LIST
102492: PUSH
102493: EMPTY
102494: LIST
102495: LIST
102496: LIST
102497: LIST
102498: PPUSH
102499: CALL_OW 69
102503: UNION
102504: ST_TO_ADDR
102505: GO 102425
102507: POP
102508: POP
// if not vehs then
102509: LD_VAR 0 7
102513: NOT
102514: IFFALSE 102540
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
102516: LD_ADDR_EXP 190
102520: PUSH
102521: LD_EXP 190
102525: PPUSH
102526: LD_VAR 0 2
102530: PPUSH
102531: EMPTY
102532: PPUSH
102533: CALL_OW 1
102537: ST_TO_ADDR
// continue ;
102538: GO 102198
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
102540: LD_ADDR_VAR 0 8
102544: PUSH
102545: LD_EXP 178
102549: PUSH
102550: LD_VAR 0 2
102554: ARRAY
102555: PPUSH
102556: LD_INT 30
102558: PUSH
102559: LD_INT 3
102561: PUSH
102562: EMPTY
102563: LIST
102564: LIST
102565: PPUSH
102566: CALL_OW 72
102570: ST_TO_ADDR
// if tmp then
102571: LD_VAR 0 8
102575: IFFALSE 102678
// begin for j in tmp do
102577: LD_ADDR_VAR 0 3
102581: PUSH
102582: LD_VAR 0 8
102586: PUSH
102587: FOR_IN
102588: IFFALSE 102676
// for k in UnitsInside ( j ) do
102590: LD_ADDR_VAR 0 4
102594: PUSH
102595: LD_VAR 0 3
102599: PPUSH
102600: CALL_OW 313
102604: PUSH
102605: FOR_IN
102606: IFFALSE 102672
// if k then
102608: LD_VAR 0 4
102612: IFFALSE 102670
// if not k in mc_repair_vehicle [ i ] then
102614: LD_VAR 0 4
102618: PUSH
102619: LD_EXP 190
102623: PUSH
102624: LD_VAR 0 2
102628: ARRAY
102629: IN
102630: NOT
102631: IFFALSE 102670
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
102633: LD_ADDR_EXP 190
102637: PUSH
102638: LD_EXP 190
102642: PPUSH
102643: LD_VAR 0 2
102647: PPUSH
102648: LD_EXP 190
102652: PUSH
102653: LD_VAR 0 2
102657: ARRAY
102658: PUSH
102659: LD_VAR 0 4
102663: UNION
102664: PPUSH
102665: CALL_OW 1
102669: ST_TO_ADDR
102670: GO 102605
102672: POP
102673: POP
102674: GO 102587
102676: POP
102677: POP
// end ; if not mc_repair_vehicle [ i ] then
102678: LD_EXP 190
102682: PUSH
102683: LD_VAR 0 2
102687: ARRAY
102688: NOT
102689: IFFALSE 102693
// continue ;
102691: GO 102198
// for j in mc_repair_vehicle [ i ] do
102693: LD_ADDR_VAR 0 3
102697: PUSH
102698: LD_EXP 190
102702: PUSH
102703: LD_VAR 0 2
102707: ARRAY
102708: PUSH
102709: FOR_IN
102710: IFFALSE 102887
// begin if GetClass ( j ) <> 3 then
102712: LD_VAR 0 3
102716: PPUSH
102717: CALL_OW 257
102721: PUSH
102722: LD_INT 3
102724: NONEQUAL
102725: IFFALSE 102766
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
102727: LD_ADDR_EXP 190
102731: PUSH
102732: LD_EXP 190
102736: PPUSH
102737: LD_VAR 0 2
102741: PPUSH
102742: LD_EXP 190
102746: PUSH
102747: LD_VAR 0 2
102751: ARRAY
102752: PUSH
102753: LD_VAR 0 3
102757: DIFF
102758: PPUSH
102759: CALL_OW 1
102763: ST_TO_ADDR
// continue ;
102764: GO 102709
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
102766: LD_VAR 0 3
102770: PPUSH
102771: CALL_OW 311
102775: NOT
102776: PUSH
102777: LD_VAR 0 3
102781: PUSH
102782: LD_EXP 181
102786: PUSH
102787: LD_VAR 0 2
102791: ARRAY
102792: PUSH
102793: LD_INT 1
102795: ARRAY
102796: IN
102797: NOT
102798: AND
102799: PUSH
102800: LD_VAR 0 3
102804: PUSH
102805: LD_EXP 181
102809: PUSH
102810: LD_VAR 0 2
102814: ARRAY
102815: PUSH
102816: LD_INT 2
102818: ARRAY
102819: IN
102820: NOT
102821: AND
102822: IFFALSE 102885
// begin if IsInUnit ( j ) then
102824: LD_VAR 0 3
102828: PPUSH
102829: CALL_OW 310
102833: IFFALSE 102846
// ComExitBuilding ( j ) else
102835: LD_VAR 0 3
102839: PPUSH
102840: CALL_OW 122
102844: GO 102885
// if not WantToRepairVehicle ( j , vehs [ 1 ] ) then
102846: LD_VAR 0 3
102850: PPUSH
102851: LD_VAR 0 7
102855: PUSH
102856: LD_INT 1
102858: ARRAY
102859: PPUSH
102860: CALL 57817 0 2
102864: NOT
102865: IFFALSE 102885
// ComRepairVehicle ( j , vehs [ 1 ] ) ;
102867: LD_VAR 0 3
102871: PPUSH
102872: LD_VAR 0 7
102876: PUSH
102877: LD_INT 1
102879: ARRAY
102880: PPUSH
102881: CALL_OW 129
// end ; end ;
102885: GO 102709
102887: POP
102888: POP
// end ;
102889: GO 102198
102891: POP
102892: POP
// end ;
102893: LD_VAR 0 1
102897: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
102898: LD_INT 0
102900: PPUSH
102901: PPUSH
102902: PPUSH
102903: PPUSH
102904: PPUSH
102905: PPUSH
102906: PPUSH
102907: PPUSH
102908: PPUSH
102909: PPUSH
102910: PPUSH
// if not mc_bases then
102911: LD_EXP 178
102915: NOT
102916: IFFALSE 102920
// exit ;
102918: GO 103722
// for i = 1 to mc_bases do
102920: LD_ADDR_VAR 0 2
102924: PUSH
102925: DOUBLE
102926: LD_INT 1
102928: DEC
102929: ST_TO_ADDR
102930: LD_EXP 178
102934: PUSH
102935: FOR_TO
102936: IFFALSE 103720
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
102938: LD_EXP 206
102942: PUSH
102943: LD_VAR 0 2
102947: ARRAY
102948: NOT
102949: PUSH
102950: LD_EXP 181
102954: PUSH
102955: LD_VAR 0 2
102959: ARRAY
102960: PUSH
102961: LD_INT 1
102963: ARRAY
102964: OR
102965: PUSH
102966: LD_EXP 181
102970: PUSH
102971: LD_VAR 0 2
102975: ARRAY
102976: PUSH
102977: LD_INT 2
102979: ARRAY
102980: OR
102981: PUSH
102982: LD_EXP 204
102986: PUSH
102987: LD_VAR 0 2
102991: ARRAY
102992: PPUSH
102993: LD_INT 1
102995: PPUSH
102996: CALL_OW 325
103000: NOT
103001: OR
103002: PUSH
103003: LD_EXP 201
103007: PUSH
103008: LD_VAR 0 2
103012: ARRAY
103013: OR
103014: IFFALSE 103018
// continue ;
103016: GO 102935
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
103018: LD_ADDR_VAR 0 8
103022: PUSH
103023: LD_EXP 178
103027: PUSH
103028: LD_VAR 0 2
103032: ARRAY
103033: PPUSH
103034: LD_INT 25
103036: PUSH
103037: LD_INT 4
103039: PUSH
103040: EMPTY
103041: LIST
103042: LIST
103043: PUSH
103044: LD_INT 50
103046: PUSH
103047: EMPTY
103048: LIST
103049: PUSH
103050: LD_INT 3
103052: PUSH
103053: LD_INT 60
103055: PUSH
103056: EMPTY
103057: LIST
103058: PUSH
103059: EMPTY
103060: LIST
103061: LIST
103062: PUSH
103063: EMPTY
103064: LIST
103065: LIST
103066: LIST
103067: PPUSH
103068: CALL_OW 72
103072: PUSH
103073: LD_EXP 182
103077: PUSH
103078: LD_VAR 0 2
103082: ARRAY
103083: DIFF
103084: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
103085: LD_ADDR_VAR 0 9
103089: PUSH
103090: LD_EXP 178
103094: PUSH
103095: LD_VAR 0 2
103099: ARRAY
103100: PPUSH
103101: LD_INT 2
103103: PUSH
103104: LD_INT 30
103106: PUSH
103107: LD_INT 0
103109: PUSH
103110: EMPTY
103111: LIST
103112: LIST
103113: PUSH
103114: LD_INT 30
103116: PUSH
103117: LD_INT 1
103119: PUSH
103120: EMPTY
103121: LIST
103122: LIST
103123: PUSH
103124: EMPTY
103125: LIST
103126: LIST
103127: LIST
103128: PPUSH
103129: CALL_OW 72
103133: ST_TO_ADDR
// if not tmp or not dep then
103134: LD_VAR 0 8
103138: NOT
103139: PUSH
103140: LD_VAR 0 9
103144: NOT
103145: OR
103146: IFFALSE 103150
// continue ;
103148: GO 102935
// side := GetSide ( tmp [ 1 ] ) ;
103150: LD_ADDR_VAR 0 11
103154: PUSH
103155: LD_VAR 0 8
103159: PUSH
103160: LD_INT 1
103162: ARRAY
103163: PPUSH
103164: CALL_OW 255
103168: ST_TO_ADDR
// dep := dep [ 1 ] ;
103169: LD_ADDR_VAR 0 9
103173: PUSH
103174: LD_VAR 0 9
103178: PUSH
103179: LD_INT 1
103181: ARRAY
103182: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
103183: LD_ADDR_VAR 0 7
103187: PUSH
103188: LD_EXP 206
103192: PUSH
103193: LD_VAR 0 2
103197: ARRAY
103198: PPUSH
103199: LD_INT 22
103201: PUSH
103202: LD_INT 0
103204: PUSH
103205: EMPTY
103206: LIST
103207: LIST
103208: PUSH
103209: LD_INT 25
103211: PUSH
103212: LD_INT 12
103214: PUSH
103215: EMPTY
103216: LIST
103217: LIST
103218: PUSH
103219: EMPTY
103220: LIST
103221: LIST
103222: PPUSH
103223: CALL_OW 70
103227: PUSH
103228: LD_INT 22
103230: PUSH
103231: LD_INT 0
103233: PUSH
103234: EMPTY
103235: LIST
103236: LIST
103237: PUSH
103238: LD_INT 25
103240: PUSH
103241: LD_INT 12
103243: PUSH
103244: EMPTY
103245: LIST
103246: LIST
103247: PUSH
103248: LD_INT 91
103250: PUSH
103251: LD_VAR 0 9
103255: PUSH
103256: LD_INT 20
103258: PUSH
103259: EMPTY
103260: LIST
103261: LIST
103262: LIST
103263: PUSH
103264: EMPTY
103265: LIST
103266: LIST
103267: LIST
103268: PPUSH
103269: CALL_OW 69
103273: UNION
103274: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
103275: LD_ADDR_VAR 0 10
103279: PUSH
103280: LD_EXP 206
103284: PUSH
103285: LD_VAR 0 2
103289: ARRAY
103290: PPUSH
103291: LD_INT 81
103293: PUSH
103294: LD_VAR 0 11
103298: PUSH
103299: EMPTY
103300: LIST
103301: LIST
103302: PPUSH
103303: CALL_OW 70
103307: ST_TO_ADDR
// if not apes or danger_at_area then
103308: LD_VAR 0 7
103312: NOT
103313: PUSH
103314: LD_VAR 0 10
103318: OR
103319: IFFALSE 103369
// begin if mc_taming [ i ] then
103321: LD_EXP 209
103325: PUSH
103326: LD_VAR 0 2
103330: ARRAY
103331: IFFALSE 103367
// begin MC_Reset ( i , 121 ) ;
103333: LD_VAR 0 2
103337: PPUSH
103338: LD_INT 121
103340: PPUSH
103341: CALL 88355 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
103345: LD_ADDR_EXP 209
103349: PUSH
103350: LD_EXP 209
103354: PPUSH
103355: LD_VAR 0 2
103359: PPUSH
103360: EMPTY
103361: PPUSH
103362: CALL_OW 1
103366: ST_TO_ADDR
// end ; continue ;
103367: GO 102935
// end ; for j in tmp do
103369: LD_ADDR_VAR 0 3
103373: PUSH
103374: LD_VAR 0 8
103378: PUSH
103379: FOR_IN
103380: IFFALSE 103716
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
103382: LD_VAR 0 3
103386: PUSH
103387: LD_EXP 209
103391: PUSH
103392: LD_VAR 0 2
103396: ARRAY
103397: IN
103398: NOT
103399: PUSH
103400: LD_EXP 209
103404: PUSH
103405: LD_VAR 0 2
103409: ARRAY
103410: PUSH
103411: LD_INT 3
103413: LESS
103414: AND
103415: IFFALSE 103473
// begin SetTag ( j , 121 ) ;
103417: LD_VAR 0 3
103421: PPUSH
103422: LD_INT 121
103424: PPUSH
103425: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
103429: LD_ADDR_EXP 209
103433: PUSH
103434: LD_EXP 209
103438: PPUSH
103439: LD_VAR 0 2
103443: PUSH
103444: LD_EXP 209
103448: PUSH
103449: LD_VAR 0 2
103453: ARRAY
103454: PUSH
103455: LD_INT 1
103457: PLUS
103458: PUSH
103459: EMPTY
103460: LIST
103461: LIST
103462: PPUSH
103463: LD_VAR 0 3
103467: PPUSH
103468: CALL 24210 0 3
103472: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
103473: LD_VAR 0 3
103477: PUSH
103478: LD_EXP 209
103482: PUSH
103483: LD_VAR 0 2
103487: ARRAY
103488: IN
103489: IFFALSE 103714
// begin if GetClass ( j ) <> 4 then
103491: LD_VAR 0 3
103495: PPUSH
103496: CALL_OW 257
103500: PUSH
103501: LD_INT 4
103503: NONEQUAL
103504: IFFALSE 103557
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
103506: LD_ADDR_EXP 209
103510: PUSH
103511: LD_EXP 209
103515: PPUSH
103516: LD_VAR 0 2
103520: PPUSH
103521: LD_EXP 209
103525: PUSH
103526: LD_VAR 0 2
103530: ARRAY
103531: PUSH
103532: LD_VAR 0 3
103536: DIFF
103537: PPUSH
103538: CALL_OW 1
103542: ST_TO_ADDR
// SetTag ( j , 0 ) ;
103543: LD_VAR 0 3
103547: PPUSH
103548: LD_INT 0
103550: PPUSH
103551: CALL_OW 109
// continue ;
103555: GO 103379
// end ; if IsInUnit ( j ) then
103557: LD_VAR 0 3
103561: PPUSH
103562: CALL_OW 310
103566: IFFALSE 103577
// ComExitBuilding ( j ) ;
103568: LD_VAR 0 3
103572: PPUSH
103573: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
103577: LD_ADDR_VAR 0 6
103581: PUSH
103582: LD_VAR 0 7
103586: PPUSH
103587: LD_VAR 0 3
103591: PPUSH
103592: CALL_OW 74
103596: ST_TO_ADDR
// if not ape then
103597: LD_VAR 0 6
103601: NOT
103602: IFFALSE 103606
// break ;
103604: GO 103716
// x := GetX ( ape ) ;
103606: LD_ADDR_VAR 0 4
103610: PUSH
103611: LD_VAR 0 6
103615: PPUSH
103616: CALL_OW 250
103620: ST_TO_ADDR
// y := GetY ( ape ) ;
103621: LD_ADDR_VAR 0 5
103625: PUSH
103626: LD_VAR 0 6
103630: PPUSH
103631: CALL_OW 251
103635: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
103636: LD_VAR 0 4
103640: PPUSH
103641: LD_VAR 0 5
103645: PPUSH
103646: CALL_OW 488
103650: NOT
103651: PUSH
103652: LD_VAR 0 11
103656: PPUSH
103657: LD_VAR 0 4
103661: PPUSH
103662: LD_VAR 0 5
103666: PPUSH
103667: LD_INT 20
103669: PPUSH
103670: CALL 25106 0 4
103674: PUSH
103675: LD_INT 4
103677: ARRAY
103678: OR
103679: IFFALSE 103683
// break ;
103681: GO 103716
// if not HasTask ( j ) then
103683: LD_VAR 0 3
103687: PPUSH
103688: CALL_OW 314
103692: NOT
103693: IFFALSE 103714
// ComTameXY ( j , x , y ) ;
103695: LD_VAR 0 3
103699: PPUSH
103700: LD_VAR 0 4
103704: PPUSH
103705: LD_VAR 0 5
103709: PPUSH
103710: CALL_OW 131
// end ; end ;
103714: GO 103379
103716: POP
103717: POP
// end ;
103718: GO 102935
103720: POP
103721: POP
// end ;
103722: LD_VAR 0 1
103726: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
103727: LD_INT 0
103729: PPUSH
103730: PPUSH
103731: PPUSH
103732: PPUSH
103733: PPUSH
103734: PPUSH
103735: PPUSH
103736: PPUSH
// if not mc_bases then
103737: LD_EXP 178
103741: NOT
103742: IFFALSE 103746
// exit ;
103744: GO 104372
// for i = 1 to mc_bases do
103746: LD_ADDR_VAR 0 2
103750: PUSH
103751: DOUBLE
103752: LD_INT 1
103754: DEC
103755: ST_TO_ADDR
103756: LD_EXP 178
103760: PUSH
103761: FOR_TO
103762: IFFALSE 104370
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
103764: LD_EXP 207
103768: PUSH
103769: LD_VAR 0 2
103773: ARRAY
103774: NOT
103775: PUSH
103776: LD_EXP 207
103780: PUSH
103781: LD_VAR 0 2
103785: ARRAY
103786: PPUSH
103787: LD_INT 25
103789: PUSH
103790: LD_INT 12
103792: PUSH
103793: EMPTY
103794: LIST
103795: LIST
103796: PPUSH
103797: CALL_OW 72
103801: NOT
103802: OR
103803: IFFALSE 103807
// continue ;
103805: GO 103761
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
103807: LD_ADDR_VAR 0 5
103811: PUSH
103812: LD_EXP 207
103816: PUSH
103817: LD_VAR 0 2
103821: ARRAY
103822: PUSH
103823: LD_INT 1
103825: ARRAY
103826: PPUSH
103827: CALL_OW 255
103831: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
103832: LD_VAR 0 5
103836: PPUSH
103837: LD_INT 2
103839: PPUSH
103840: CALL_OW 325
103844: IFFALSE 104097
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
103846: LD_ADDR_VAR 0 4
103850: PUSH
103851: LD_EXP 207
103855: PUSH
103856: LD_VAR 0 2
103860: ARRAY
103861: PPUSH
103862: LD_INT 25
103864: PUSH
103865: LD_INT 16
103867: PUSH
103868: EMPTY
103869: LIST
103870: LIST
103871: PPUSH
103872: CALL_OW 72
103876: ST_TO_ADDR
// if tmp < 6 then
103877: LD_VAR 0 4
103881: PUSH
103882: LD_INT 6
103884: LESS
103885: IFFALSE 104097
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
103887: LD_ADDR_VAR 0 6
103891: PUSH
103892: LD_EXP 178
103896: PUSH
103897: LD_VAR 0 2
103901: ARRAY
103902: PPUSH
103903: LD_INT 2
103905: PUSH
103906: LD_INT 30
103908: PUSH
103909: LD_INT 0
103911: PUSH
103912: EMPTY
103913: LIST
103914: LIST
103915: PUSH
103916: LD_INT 30
103918: PUSH
103919: LD_INT 1
103921: PUSH
103922: EMPTY
103923: LIST
103924: LIST
103925: PUSH
103926: EMPTY
103927: LIST
103928: LIST
103929: LIST
103930: PPUSH
103931: CALL_OW 72
103935: ST_TO_ADDR
// if depot then
103936: LD_VAR 0 6
103940: IFFALSE 104097
// begin selected := 0 ;
103942: LD_ADDR_VAR 0 7
103946: PUSH
103947: LD_INT 0
103949: ST_TO_ADDR
// for j in depot do
103950: LD_ADDR_VAR 0 3
103954: PUSH
103955: LD_VAR 0 6
103959: PUSH
103960: FOR_IN
103961: IFFALSE 103992
// begin if UnitsInside ( j ) < 6 then
103963: LD_VAR 0 3
103967: PPUSH
103968: CALL_OW 313
103972: PUSH
103973: LD_INT 6
103975: LESS
103976: IFFALSE 103990
// begin selected := j ;
103978: LD_ADDR_VAR 0 7
103982: PUSH
103983: LD_VAR 0 3
103987: ST_TO_ADDR
// break ;
103988: GO 103992
// end ; end ;
103990: GO 103960
103992: POP
103993: POP
// if selected then
103994: LD_VAR 0 7
103998: IFFALSE 104097
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
104000: LD_ADDR_VAR 0 3
104004: PUSH
104005: LD_EXP 207
104009: PUSH
104010: LD_VAR 0 2
104014: ARRAY
104015: PPUSH
104016: LD_INT 25
104018: PUSH
104019: LD_INT 12
104021: PUSH
104022: EMPTY
104023: LIST
104024: LIST
104025: PPUSH
104026: CALL_OW 72
104030: PUSH
104031: FOR_IN
104032: IFFALSE 104095
// if not HasTask ( j ) then
104034: LD_VAR 0 3
104038: PPUSH
104039: CALL_OW 314
104043: NOT
104044: IFFALSE 104093
// begin if not IsInUnit ( j ) then
104046: LD_VAR 0 3
104050: PPUSH
104051: CALL_OW 310
104055: NOT
104056: IFFALSE 104072
// ComEnterUnit ( j , selected ) ;
104058: LD_VAR 0 3
104062: PPUSH
104063: LD_VAR 0 7
104067: PPUSH
104068: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
104072: LD_VAR 0 3
104076: PPUSH
104077: LD_INT 16
104079: PPUSH
104080: CALL_OW 183
// AddComExitBuilding ( j ) ;
104084: LD_VAR 0 3
104088: PPUSH
104089: CALL_OW 182
// end ;
104093: GO 104031
104095: POP
104096: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
104097: LD_VAR 0 5
104101: PPUSH
104102: LD_INT 11
104104: PPUSH
104105: CALL_OW 325
104109: IFFALSE 104368
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
104111: LD_ADDR_VAR 0 4
104115: PUSH
104116: LD_EXP 207
104120: PUSH
104121: LD_VAR 0 2
104125: ARRAY
104126: PPUSH
104127: LD_INT 25
104129: PUSH
104130: LD_INT 16
104132: PUSH
104133: EMPTY
104134: LIST
104135: LIST
104136: PPUSH
104137: CALL_OW 72
104141: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
104142: LD_VAR 0 4
104146: PUSH
104147: LD_INT 6
104149: GREATEREQUAL
104150: PUSH
104151: LD_VAR 0 5
104155: PPUSH
104156: LD_INT 2
104158: PPUSH
104159: CALL_OW 325
104163: NOT
104164: OR
104165: IFFALSE 104368
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
104167: LD_ADDR_VAR 0 8
104171: PUSH
104172: LD_EXP 178
104176: PUSH
104177: LD_VAR 0 2
104181: ARRAY
104182: PPUSH
104183: LD_INT 2
104185: PUSH
104186: LD_INT 30
104188: PUSH
104189: LD_INT 4
104191: PUSH
104192: EMPTY
104193: LIST
104194: LIST
104195: PUSH
104196: LD_INT 30
104198: PUSH
104199: LD_INT 5
104201: PUSH
104202: EMPTY
104203: LIST
104204: LIST
104205: PUSH
104206: EMPTY
104207: LIST
104208: LIST
104209: LIST
104210: PPUSH
104211: CALL_OW 72
104215: ST_TO_ADDR
// if barracks then
104216: LD_VAR 0 8
104220: IFFALSE 104368
// begin selected := 0 ;
104222: LD_ADDR_VAR 0 7
104226: PUSH
104227: LD_INT 0
104229: ST_TO_ADDR
// for j in barracks do
104230: LD_ADDR_VAR 0 3
104234: PUSH
104235: LD_VAR 0 8
104239: PUSH
104240: FOR_IN
104241: IFFALSE 104272
// begin if UnitsInside ( j ) < 6 then
104243: LD_VAR 0 3
104247: PPUSH
104248: CALL_OW 313
104252: PUSH
104253: LD_INT 6
104255: LESS
104256: IFFALSE 104270
// begin selected := j ;
104258: LD_ADDR_VAR 0 7
104262: PUSH
104263: LD_VAR 0 3
104267: ST_TO_ADDR
// break ;
104268: GO 104272
// end ; end ;
104270: GO 104240
104272: POP
104273: POP
// if selected then
104274: LD_VAR 0 7
104278: IFFALSE 104368
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
104280: LD_ADDR_VAR 0 3
104284: PUSH
104285: LD_EXP 207
104289: PUSH
104290: LD_VAR 0 2
104294: ARRAY
104295: PPUSH
104296: LD_INT 25
104298: PUSH
104299: LD_INT 12
104301: PUSH
104302: EMPTY
104303: LIST
104304: LIST
104305: PPUSH
104306: CALL_OW 72
104310: PUSH
104311: FOR_IN
104312: IFFALSE 104366
// if not IsInUnit ( j ) and not HasTask ( j ) then
104314: LD_VAR 0 3
104318: PPUSH
104319: CALL_OW 310
104323: NOT
104324: PUSH
104325: LD_VAR 0 3
104329: PPUSH
104330: CALL_OW 314
104334: NOT
104335: AND
104336: IFFALSE 104364
// begin ComEnterUnit ( j , selected ) ;
104338: LD_VAR 0 3
104342: PPUSH
104343: LD_VAR 0 7
104347: PPUSH
104348: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
104352: LD_VAR 0 3
104356: PPUSH
104357: LD_INT 15
104359: PPUSH
104360: CALL_OW 183
// end ;
104364: GO 104311
104366: POP
104367: POP
// end ; end ; end ; end ; end ;
104368: GO 103761
104370: POP
104371: POP
// end ;
104372: LD_VAR 0 1
104376: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
104377: LD_INT 0
104379: PPUSH
104380: PPUSH
104381: PPUSH
104382: PPUSH
// if not mc_bases then
104383: LD_EXP 178
104387: NOT
104388: IFFALSE 104392
// exit ;
104390: GO 104570
// for i = 1 to mc_bases do
104392: LD_ADDR_VAR 0 2
104396: PUSH
104397: DOUBLE
104398: LD_INT 1
104400: DEC
104401: ST_TO_ADDR
104402: LD_EXP 178
104406: PUSH
104407: FOR_TO
104408: IFFALSE 104568
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
104410: LD_ADDR_VAR 0 4
104414: PUSH
104415: LD_EXP 178
104419: PUSH
104420: LD_VAR 0 2
104424: ARRAY
104425: PPUSH
104426: LD_INT 25
104428: PUSH
104429: LD_INT 9
104431: PUSH
104432: EMPTY
104433: LIST
104434: LIST
104435: PPUSH
104436: CALL_OW 72
104440: ST_TO_ADDR
// if not tmp then
104441: LD_VAR 0 4
104445: NOT
104446: IFFALSE 104450
// continue ;
104448: GO 104407
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
104450: LD_EXP 204
104454: PUSH
104455: LD_VAR 0 2
104459: ARRAY
104460: PPUSH
104461: LD_INT 29
104463: PPUSH
104464: CALL_OW 325
104468: NOT
104469: PUSH
104470: LD_EXP 204
104474: PUSH
104475: LD_VAR 0 2
104479: ARRAY
104480: PPUSH
104481: LD_INT 28
104483: PPUSH
104484: CALL_OW 325
104488: NOT
104489: AND
104490: IFFALSE 104494
// continue ;
104492: GO 104407
// for j in tmp do
104494: LD_ADDR_VAR 0 3
104498: PUSH
104499: LD_VAR 0 4
104503: PUSH
104504: FOR_IN
104505: IFFALSE 104564
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
104507: LD_VAR 0 3
104511: PUSH
104512: LD_EXP 181
104516: PUSH
104517: LD_VAR 0 2
104521: ARRAY
104522: PUSH
104523: LD_INT 1
104525: ARRAY
104526: IN
104527: NOT
104528: PUSH
104529: LD_VAR 0 3
104533: PUSH
104534: LD_EXP 181
104538: PUSH
104539: LD_VAR 0 2
104543: ARRAY
104544: PUSH
104545: LD_INT 2
104547: ARRAY
104548: IN
104549: NOT
104550: AND
104551: IFFALSE 104562
// ComSpaceTimeShoot ( j ) ;
104553: LD_VAR 0 3
104557: PPUSH
104558: CALL 20171 0 1
104562: GO 104504
104564: POP
104565: POP
// end ;
104566: GO 104407
104568: POP
104569: POP
// end ;
104570: LD_VAR 0 1
104574: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
104575: LD_INT 0
104577: PPUSH
104578: PPUSH
104579: PPUSH
104580: PPUSH
104581: PPUSH
104582: PPUSH
104583: PPUSH
104584: PPUSH
104585: PPUSH
// if not mc_bases then
104586: LD_EXP 178
104590: NOT
104591: IFFALSE 104595
// exit ;
104593: GO 105217
// for i = 1 to mc_bases do
104595: LD_ADDR_VAR 0 2
104599: PUSH
104600: DOUBLE
104601: LD_INT 1
104603: DEC
104604: ST_TO_ADDR
104605: LD_EXP 178
104609: PUSH
104610: FOR_TO
104611: IFFALSE 105215
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
104613: LD_EXP 213
104617: PUSH
104618: LD_VAR 0 2
104622: ARRAY
104623: NOT
104624: PUSH
104625: LD_INT 38
104627: PPUSH
104628: LD_EXP 204
104632: PUSH
104633: LD_VAR 0 2
104637: ARRAY
104638: PPUSH
104639: CALL_OW 321
104643: PUSH
104644: LD_INT 2
104646: NONEQUAL
104647: OR
104648: IFFALSE 104652
// continue ;
104650: GO 104610
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
104652: LD_ADDR_VAR 0 8
104656: PUSH
104657: LD_EXP 178
104661: PUSH
104662: LD_VAR 0 2
104666: ARRAY
104667: PPUSH
104668: LD_INT 30
104670: PUSH
104671: LD_INT 34
104673: PUSH
104674: EMPTY
104675: LIST
104676: LIST
104677: PPUSH
104678: CALL_OW 72
104682: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
104683: LD_ADDR_VAR 0 9
104687: PUSH
104688: LD_EXP 178
104692: PUSH
104693: LD_VAR 0 2
104697: ARRAY
104698: PPUSH
104699: LD_INT 25
104701: PUSH
104702: LD_INT 4
104704: PUSH
104705: EMPTY
104706: LIST
104707: LIST
104708: PPUSH
104709: CALL_OW 72
104713: PPUSH
104714: LD_INT 0
104716: PPUSH
104717: CALL 53479 0 2
104721: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
104722: LD_VAR 0 9
104726: NOT
104727: PUSH
104728: LD_VAR 0 8
104732: NOT
104733: OR
104734: PUSH
104735: LD_EXP 178
104739: PUSH
104740: LD_VAR 0 2
104744: ARRAY
104745: PPUSH
104746: LD_INT 124
104748: PPUSH
104749: CALL 53479 0 2
104753: OR
104754: IFFALSE 104758
// continue ;
104756: GO 104610
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
104758: LD_EXP 214
104762: PUSH
104763: LD_VAR 0 2
104767: ARRAY
104768: PUSH
104769: LD_EXP 213
104773: PUSH
104774: LD_VAR 0 2
104778: ARRAY
104779: LESS
104780: PUSH
104781: LD_EXP 214
104785: PUSH
104786: LD_VAR 0 2
104790: ARRAY
104791: PUSH
104792: LD_VAR 0 8
104796: LESS
104797: AND
104798: IFFALSE 105213
// begin tmp := sci [ 1 ] ;
104800: LD_ADDR_VAR 0 7
104804: PUSH
104805: LD_VAR 0 9
104809: PUSH
104810: LD_INT 1
104812: ARRAY
104813: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
104814: LD_VAR 0 7
104818: PPUSH
104819: LD_INT 124
104821: PPUSH
104822: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
104826: LD_ADDR_VAR 0 3
104830: PUSH
104831: DOUBLE
104832: LD_EXP 213
104836: PUSH
104837: LD_VAR 0 2
104841: ARRAY
104842: INC
104843: ST_TO_ADDR
104844: LD_EXP 213
104848: PUSH
104849: LD_VAR 0 2
104853: ARRAY
104854: PUSH
104855: FOR_DOWNTO
104856: IFFALSE 105199
// begin if IsInUnit ( tmp ) then
104858: LD_VAR 0 7
104862: PPUSH
104863: CALL_OW 310
104867: IFFALSE 104878
// ComExitBuilding ( tmp ) ;
104869: LD_VAR 0 7
104873: PPUSH
104874: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
104878: LD_INT 35
104880: PPUSH
104881: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
104885: LD_VAR 0 7
104889: PPUSH
104890: CALL_OW 310
104894: NOT
104895: PUSH
104896: LD_VAR 0 7
104900: PPUSH
104901: CALL_OW 314
104905: NOT
104906: AND
104907: IFFALSE 104878
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
104909: LD_ADDR_VAR 0 6
104913: PUSH
104914: LD_VAR 0 7
104918: PPUSH
104919: CALL_OW 250
104923: PUSH
104924: LD_VAR 0 7
104928: PPUSH
104929: CALL_OW 251
104933: PUSH
104934: EMPTY
104935: LIST
104936: LIST
104937: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
104938: LD_INT 35
104940: PPUSH
104941: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
104945: LD_ADDR_VAR 0 4
104949: PUSH
104950: LD_EXP 213
104954: PUSH
104955: LD_VAR 0 2
104959: ARRAY
104960: PUSH
104961: LD_VAR 0 3
104965: ARRAY
104966: PUSH
104967: LD_INT 1
104969: ARRAY
104970: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
104971: LD_ADDR_VAR 0 5
104975: PUSH
104976: LD_EXP 213
104980: PUSH
104981: LD_VAR 0 2
104985: ARRAY
104986: PUSH
104987: LD_VAR 0 3
104991: ARRAY
104992: PUSH
104993: LD_INT 2
104995: ARRAY
104996: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
104997: LD_VAR 0 7
105001: PPUSH
105002: LD_INT 10
105004: PPUSH
105005: CALL 26809 0 2
105009: PUSH
105010: LD_INT 4
105012: ARRAY
105013: IFFALSE 105051
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
105015: LD_VAR 0 7
105019: PPUSH
105020: LD_VAR 0 6
105024: PUSH
105025: LD_INT 1
105027: ARRAY
105028: PPUSH
105029: LD_VAR 0 6
105033: PUSH
105034: LD_INT 2
105036: ARRAY
105037: PPUSH
105038: CALL_OW 111
// wait ( 0 0$10 ) ;
105042: LD_INT 350
105044: PPUSH
105045: CALL_OW 67
// end else
105049: GO 105077
// begin ComMoveXY ( tmp , x , y ) ;
105051: LD_VAR 0 7
105055: PPUSH
105056: LD_VAR 0 4
105060: PPUSH
105061: LD_VAR 0 5
105065: PPUSH
105066: CALL_OW 111
// wait ( 0 0$3 ) ;
105070: LD_INT 105
105072: PPUSH
105073: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
105077: LD_VAR 0 7
105081: PPUSH
105082: LD_VAR 0 4
105086: PPUSH
105087: LD_VAR 0 5
105091: PPUSH
105092: CALL_OW 307
105096: IFFALSE 104938
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
105098: LD_VAR 0 7
105102: PPUSH
105103: LD_VAR 0 4
105107: PPUSH
105108: LD_VAR 0 5
105112: PPUSH
105113: LD_VAR 0 8
105117: PUSH
105118: LD_VAR 0 3
105122: ARRAY
105123: PPUSH
105124: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
105128: LD_INT 35
105130: PPUSH
105131: CALL_OW 67
// until not HasTask ( tmp ) ;
105135: LD_VAR 0 7
105139: PPUSH
105140: CALL_OW 314
105144: NOT
105145: IFFALSE 105128
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
105147: LD_ADDR_EXP 214
105151: PUSH
105152: LD_EXP 214
105156: PPUSH
105157: LD_VAR 0 2
105161: PUSH
105162: LD_EXP 214
105166: PUSH
105167: LD_VAR 0 2
105171: ARRAY
105172: PUSH
105173: LD_INT 1
105175: PLUS
105176: PUSH
105177: EMPTY
105178: LIST
105179: LIST
105180: PPUSH
105181: LD_VAR 0 8
105185: PUSH
105186: LD_VAR 0 3
105190: ARRAY
105191: PPUSH
105192: CALL 24210 0 3
105196: ST_TO_ADDR
// end ;
105197: GO 104855
105199: POP
105200: POP
// MC_Reset ( i , 124 ) ;
105201: LD_VAR 0 2
105205: PPUSH
105206: LD_INT 124
105208: PPUSH
105209: CALL 88355 0 2
// end ; end ;
105213: GO 104610
105215: POP
105216: POP
// end ;
105217: LD_VAR 0 1
105221: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
105222: LD_INT 0
105224: PPUSH
105225: PPUSH
105226: PPUSH
// if not mc_bases then
105227: LD_EXP 178
105231: NOT
105232: IFFALSE 105236
// exit ;
105234: GO 105842
// for i = 1 to mc_bases do
105236: LD_ADDR_VAR 0 2
105240: PUSH
105241: DOUBLE
105242: LD_INT 1
105244: DEC
105245: ST_TO_ADDR
105246: LD_EXP 178
105250: PUSH
105251: FOR_TO
105252: IFFALSE 105840
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
105254: LD_ADDR_VAR 0 3
105258: PUSH
105259: LD_EXP 178
105263: PUSH
105264: LD_VAR 0 2
105268: ARRAY
105269: PPUSH
105270: LD_INT 25
105272: PUSH
105273: LD_INT 4
105275: PUSH
105276: EMPTY
105277: LIST
105278: LIST
105279: PPUSH
105280: CALL_OW 72
105284: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
105285: LD_VAR 0 3
105289: NOT
105290: PUSH
105291: LD_EXP 215
105295: PUSH
105296: LD_VAR 0 2
105300: ARRAY
105301: NOT
105302: OR
105303: PUSH
105304: LD_EXP 178
105308: PUSH
105309: LD_VAR 0 2
105313: ARRAY
105314: PPUSH
105315: LD_INT 2
105317: PUSH
105318: LD_INT 30
105320: PUSH
105321: LD_INT 0
105323: PUSH
105324: EMPTY
105325: LIST
105326: LIST
105327: PUSH
105328: LD_INT 30
105330: PUSH
105331: LD_INT 1
105333: PUSH
105334: EMPTY
105335: LIST
105336: LIST
105337: PUSH
105338: EMPTY
105339: LIST
105340: LIST
105341: LIST
105342: PPUSH
105343: CALL_OW 72
105347: NOT
105348: OR
105349: IFFALSE 105399
// begin if mc_deposits_finder [ i ] then
105351: LD_EXP 216
105355: PUSH
105356: LD_VAR 0 2
105360: ARRAY
105361: IFFALSE 105397
// begin MC_Reset ( i , 125 ) ;
105363: LD_VAR 0 2
105367: PPUSH
105368: LD_INT 125
105370: PPUSH
105371: CALL 88355 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
105375: LD_ADDR_EXP 216
105379: PUSH
105380: LD_EXP 216
105384: PPUSH
105385: LD_VAR 0 2
105389: PPUSH
105390: EMPTY
105391: PPUSH
105392: CALL_OW 1
105396: ST_TO_ADDR
// end ; continue ;
105397: GO 105251
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
105399: LD_EXP 215
105403: PUSH
105404: LD_VAR 0 2
105408: ARRAY
105409: PUSH
105410: LD_INT 1
105412: ARRAY
105413: PUSH
105414: LD_INT 3
105416: ARRAY
105417: PUSH
105418: LD_INT 1
105420: EQUAL
105421: PUSH
105422: LD_INT 20
105424: PPUSH
105425: LD_EXP 204
105429: PUSH
105430: LD_VAR 0 2
105434: ARRAY
105435: PPUSH
105436: CALL_OW 321
105440: PUSH
105441: LD_INT 2
105443: NONEQUAL
105444: AND
105445: IFFALSE 105495
// begin if mc_deposits_finder [ i ] then
105447: LD_EXP 216
105451: PUSH
105452: LD_VAR 0 2
105456: ARRAY
105457: IFFALSE 105493
// begin MC_Reset ( i , 125 ) ;
105459: LD_VAR 0 2
105463: PPUSH
105464: LD_INT 125
105466: PPUSH
105467: CALL 88355 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
105471: LD_ADDR_EXP 216
105475: PUSH
105476: LD_EXP 216
105480: PPUSH
105481: LD_VAR 0 2
105485: PPUSH
105486: EMPTY
105487: PPUSH
105488: CALL_OW 1
105492: ST_TO_ADDR
// end ; continue ;
105493: GO 105251
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
105495: LD_EXP 215
105499: PUSH
105500: LD_VAR 0 2
105504: ARRAY
105505: PUSH
105506: LD_INT 1
105508: ARRAY
105509: PUSH
105510: LD_INT 1
105512: ARRAY
105513: PPUSH
105514: LD_EXP 215
105518: PUSH
105519: LD_VAR 0 2
105523: ARRAY
105524: PUSH
105525: LD_INT 1
105527: ARRAY
105528: PUSH
105529: LD_INT 2
105531: ARRAY
105532: PPUSH
105533: LD_EXP 204
105537: PUSH
105538: LD_VAR 0 2
105542: ARRAY
105543: PPUSH
105544: CALL_OW 440
105548: IFFALSE 105591
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
105550: LD_ADDR_EXP 215
105554: PUSH
105555: LD_EXP 215
105559: PPUSH
105560: LD_VAR 0 2
105564: PPUSH
105565: LD_EXP 215
105569: PUSH
105570: LD_VAR 0 2
105574: ARRAY
105575: PPUSH
105576: LD_INT 1
105578: PPUSH
105579: CALL_OW 3
105583: PPUSH
105584: CALL_OW 1
105588: ST_TO_ADDR
105589: GO 105838
// begin if not mc_deposits_finder [ i ] then
105591: LD_EXP 216
105595: PUSH
105596: LD_VAR 0 2
105600: ARRAY
105601: NOT
105602: IFFALSE 105654
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
105604: LD_ADDR_EXP 216
105608: PUSH
105609: LD_EXP 216
105613: PPUSH
105614: LD_VAR 0 2
105618: PPUSH
105619: LD_VAR 0 3
105623: PUSH
105624: LD_INT 1
105626: ARRAY
105627: PUSH
105628: EMPTY
105629: LIST
105630: PPUSH
105631: CALL_OW 1
105635: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
105636: LD_VAR 0 3
105640: PUSH
105641: LD_INT 1
105643: ARRAY
105644: PPUSH
105645: LD_INT 125
105647: PPUSH
105648: CALL_OW 109
// end else
105652: GO 105838
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
105654: LD_EXP 216
105658: PUSH
105659: LD_VAR 0 2
105663: ARRAY
105664: PUSH
105665: LD_INT 1
105667: ARRAY
105668: PPUSH
105669: CALL_OW 310
105673: IFFALSE 105696
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
105675: LD_EXP 216
105679: PUSH
105680: LD_VAR 0 2
105684: ARRAY
105685: PUSH
105686: LD_INT 1
105688: ARRAY
105689: PPUSH
105690: CALL_OW 122
105694: GO 105838
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
105696: LD_EXP 216
105700: PUSH
105701: LD_VAR 0 2
105705: ARRAY
105706: PUSH
105707: LD_INT 1
105709: ARRAY
105710: PPUSH
105711: CALL_OW 314
105715: NOT
105716: PUSH
105717: LD_EXP 216
105721: PUSH
105722: LD_VAR 0 2
105726: ARRAY
105727: PUSH
105728: LD_INT 1
105730: ARRAY
105731: PPUSH
105732: LD_EXP 215
105736: PUSH
105737: LD_VAR 0 2
105741: ARRAY
105742: PUSH
105743: LD_INT 1
105745: ARRAY
105746: PUSH
105747: LD_INT 1
105749: ARRAY
105750: PPUSH
105751: LD_EXP 215
105755: PUSH
105756: LD_VAR 0 2
105760: ARRAY
105761: PUSH
105762: LD_INT 1
105764: ARRAY
105765: PUSH
105766: LD_INT 2
105768: ARRAY
105769: PPUSH
105770: CALL_OW 297
105774: PUSH
105775: LD_INT 6
105777: GREATER
105778: AND
105779: IFFALSE 105838
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
105781: LD_EXP 216
105785: PUSH
105786: LD_VAR 0 2
105790: ARRAY
105791: PUSH
105792: LD_INT 1
105794: ARRAY
105795: PPUSH
105796: LD_EXP 215
105800: PUSH
105801: LD_VAR 0 2
105805: ARRAY
105806: PUSH
105807: LD_INT 1
105809: ARRAY
105810: PUSH
105811: LD_INT 1
105813: ARRAY
105814: PPUSH
105815: LD_EXP 215
105819: PUSH
105820: LD_VAR 0 2
105824: ARRAY
105825: PUSH
105826: LD_INT 1
105828: ARRAY
105829: PUSH
105830: LD_INT 2
105832: ARRAY
105833: PPUSH
105834: CALL_OW 111
// end ; end ; end ;
105838: GO 105251
105840: POP
105841: POP
// end ;
105842: LD_VAR 0 1
105846: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
105847: LD_INT 0
105849: PPUSH
105850: PPUSH
105851: PPUSH
105852: PPUSH
105853: PPUSH
105854: PPUSH
105855: PPUSH
105856: PPUSH
105857: PPUSH
105858: PPUSH
105859: PPUSH
// if not mc_bases then
105860: LD_EXP 178
105864: NOT
105865: IFFALSE 105869
// exit ;
105867: GO 106809
// for i = 1 to mc_bases do
105869: LD_ADDR_VAR 0 2
105873: PUSH
105874: DOUBLE
105875: LD_INT 1
105877: DEC
105878: ST_TO_ADDR
105879: LD_EXP 178
105883: PUSH
105884: FOR_TO
105885: IFFALSE 106807
// begin if not mc_bases [ i ] or mc_scan [ i ] then
105887: LD_EXP 178
105891: PUSH
105892: LD_VAR 0 2
105896: ARRAY
105897: NOT
105898: PUSH
105899: LD_EXP 201
105903: PUSH
105904: LD_VAR 0 2
105908: ARRAY
105909: OR
105910: IFFALSE 105914
// continue ;
105912: GO 105884
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
105914: LD_ADDR_VAR 0 7
105918: PUSH
105919: LD_EXP 178
105923: PUSH
105924: LD_VAR 0 2
105928: ARRAY
105929: PUSH
105930: LD_INT 1
105932: ARRAY
105933: PPUSH
105934: CALL_OW 248
105938: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
105939: LD_VAR 0 7
105943: PUSH
105944: LD_INT 3
105946: EQUAL
105947: PUSH
105948: LD_EXP 197
105952: PUSH
105953: LD_VAR 0 2
105957: ARRAY
105958: PUSH
105959: LD_EXP 200
105963: PUSH
105964: LD_VAR 0 2
105968: ARRAY
105969: UNION
105970: PPUSH
105971: LD_INT 33
105973: PUSH
105974: LD_INT 2
105976: PUSH
105977: EMPTY
105978: LIST
105979: LIST
105980: PPUSH
105981: CALL_OW 72
105985: NOT
105986: OR
105987: IFFALSE 105991
// continue ;
105989: GO 105884
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
105991: LD_ADDR_VAR 0 9
105995: PUSH
105996: LD_EXP 178
106000: PUSH
106001: LD_VAR 0 2
106005: ARRAY
106006: PPUSH
106007: LD_INT 30
106009: PUSH
106010: LD_INT 36
106012: PUSH
106013: EMPTY
106014: LIST
106015: LIST
106016: PPUSH
106017: CALL_OW 72
106021: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
106022: LD_ADDR_VAR 0 10
106026: PUSH
106027: LD_EXP 197
106031: PUSH
106032: LD_VAR 0 2
106036: ARRAY
106037: PPUSH
106038: LD_INT 34
106040: PUSH
106041: LD_INT 31
106043: PUSH
106044: EMPTY
106045: LIST
106046: LIST
106047: PPUSH
106048: CALL_OW 72
106052: ST_TO_ADDR
// if not cts and not mcts then
106053: LD_VAR 0 9
106057: NOT
106058: PUSH
106059: LD_VAR 0 10
106063: NOT
106064: AND
106065: IFFALSE 106069
// continue ;
106067: GO 105884
// x := cts ;
106069: LD_ADDR_VAR 0 11
106073: PUSH
106074: LD_VAR 0 9
106078: ST_TO_ADDR
// if not x then
106079: LD_VAR 0 11
106083: NOT
106084: IFFALSE 106096
// x := mcts ;
106086: LD_ADDR_VAR 0 11
106090: PUSH
106091: LD_VAR 0 10
106095: ST_TO_ADDR
// if not x then
106096: LD_VAR 0 11
106100: NOT
106101: IFFALSE 106105
// continue ;
106103: GO 105884
// if mc_remote_driver [ i ] then
106105: LD_EXP 218
106109: PUSH
106110: LD_VAR 0 2
106114: ARRAY
106115: IFFALSE 106502
// for j in mc_remote_driver [ i ] do
106117: LD_ADDR_VAR 0 3
106121: PUSH
106122: LD_EXP 218
106126: PUSH
106127: LD_VAR 0 2
106131: ARRAY
106132: PUSH
106133: FOR_IN
106134: IFFALSE 106500
// begin if GetClass ( j ) <> 3 then
106136: LD_VAR 0 3
106140: PPUSH
106141: CALL_OW 257
106145: PUSH
106146: LD_INT 3
106148: NONEQUAL
106149: IFFALSE 106202
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
106151: LD_ADDR_EXP 218
106155: PUSH
106156: LD_EXP 218
106160: PPUSH
106161: LD_VAR 0 2
106165: PPUSH
106166: LD_EXP 218
106170: PUSH
106171: LD_VAR 0 2
106175: ARRAY
106176: PUSH
106177: LD_VAR 0 3
106181: DIFF
106182: PPUSH
106183: CALL_OW 1
106187: ST_TO_ADDR
// SetTag ( j , 0 ) ;
106188: LD_VAR 0 3
106192: PPUSH
106193: LD_INT 0
106195: PPUSH
106196: CALL_OW 109
// continue ;
106200: GO 106133
// end ; if UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) and not IsDriver ( j ) then
106202: LD_EXP 197
106206: PUSH
106207: LD_VAR 0 2
106211: ARRAY
106212: PPUSH
106213: LD_INT 34
106215: PUSH
106216: LD_INT 31
106218: PUSH
106219: EMPTY
106220: LIST
106221: LIST
106222: PUSH
106223: LD_INT 58
106225: PUSH
106226: EMPTY
106227: LIST
106228: PUSH
106229: EMPTY
106230: LIST
106231: LIST
106232: PPUSH
106233: CALL_OW 72
106237: PUSH
106238: LD_VAR 0 3
106242: PPUSH
106243: CALL 53567 0 1
106247: NOT
106248: AND
106249: IFFALSE 106320
// begin if IsInUnit ( j ) then
106251: LD_VAR 0 3
106255: PPUSH
106256: CALL_OW 310
106260: IFFALSE 106271
// ComExitBuilding ( j ) ;
106262: LD_VAR 0 3
106266: PPUSH
106267: CALL_OW 122
// AddComEnterUnit ( j , UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) [ 1 ] ) ;
106271: LD_VAR 0 3
106275: PPUSH
106276: LD_EXP 197
106280: PUSH
106281: LD_VAR 0 2
106285: ARRAY
106286: PPUSH
106287: LD_INT 34
106289: PUSH
106290: LD_INT 31
106292: PUSH
106293: EMPTY
106294: LIST
106295: LIST
106296: PUSH
106297: LD_INT 58
106299: PUSH
106300: EMPTY
106301: LIST
106302: PUSH
106303: EMPTY
106304: LIST
106305: LIST
106306: PPUSH
106307: CALL_OW 72
106311: PUSH
106312: LD_INT 1
106314: ARRAY
106315: PPUSH
106316: CALL_OW 180
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
106320: LD_VAR 0 3
106324: PPUSH
106325: CALL_OW 310
106329: NOT
106330: PUSH
106331: LD_VAR 0 3
106335: PPUSH
106336: CALL_OW 310
106340: PPUSH
106341: CALL_OW 266
106345: PUSH
106346: LD_INT 36
106348: NONEQUAL
106349: PUSH
106350: LD_VAR 0 3
106354: PPUSH
106355: CALL 53567 0 1
106359: NOT
106360: AND
106361: OR
106362: IFFALSE 106498
// begin if IsInUnit ( j ) then
106364: LD_VAR 0 3
106368: PPUSH
106369: CALL_OW 310
106373: IFFALSE 106384
// ComExitBuilding ( j ) ;
106375: LD_VAR 0 3
106379: PPUSH
106380: CALL_OW 122
// ct := 0 ;
106384: LD_ADDR_VAR 0 8
106388: PUSH
106389: LD_INT 0
106391: ST_TO_ADDR
// for k in x do
106392: LD_ADDR_VAR 0 4
106396: PUSH
106397: LD_VAR 0 11
106401: PUSH
106402: FOR_IN
106403: IFFALSE 106476
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
106405: LD_VAR 0 4
106409: PPUSH
106410: CALL_OW 264
106414: PUSH
106415: LD_INT 31
106417: EQUAL
106418: PUSH
106419: LD_VAR 0 4
106423: PPUSH
106424: CALL_OW 311
106428: NOT
106429: AND
106430: PUSH
106431: LD_VAR 0 4
106435: PPUSH
106436: CALL_OW 266
106440: PUSH
106441: LD_INT 36
106443: EQUAL
106444: PUSH
106445: LD_VAR 0 4
106449: PPUSH
106450: CALL_OW 313
106454: PUSH
106455: LD_INT 3
106457: LESS
106458: AND
106459: OR
106460: IFFALSE 106474
// begin ct := k ;
106462: LD_ADDR_VAR 0 8
106466: PUSH
106467: LD_VAR 0 4
106471: ST_TO_ADDR
// break ;
106472: GO 106476
// end ;
106474: GO 106402
106476: POP
106477: POP
// if ct then
106478: LD_VAR 0 8
106482: IFFALSE 106498
// ComEnterUnit ( j , ct ) ;
106484: LD_VAR 0 3
106488: PPUSH
106489: LD_VAR 0 8
106493: PPUSH
106494: CALL_OW 120
// end ; end ;
106498: GO 106133
106500: POP
106501: POP
// places := 0 ;
106502: LD_ADDR_VAR 0 5
106506: PUSH
106507: LD_INT 0
106509: ST_TO_ADDR
// for j = 1 to x do
106510: LD_ADDR_VAR 0 3
106514: PUSH
106515: DOUBLE
106516: LD_INT 1
106518: DEC
106519: ST_TO_ADDR
106520: LD_VAR 0 11
106524: PUSH
106525: FOR_TO
106526: IFFALSE 106602
// if GetWeapon ( x [ j ] ) = ar_control_tower then
106528: LD_VAR 0 11
106532: PUSH
106533: LD_VAR 0 3
106537: ARRAY
106538: PPUSH
106539: CALL_OW 264
106543: PUSH
106544: LD_INT 31
106546: EQUAL
106547: IFFALSE 106565
// places := places + 1 else
106549: LD_ADDR_VAR 0 5
106553: PUSH
106554: LD_VAR 0 5
106558: PUSH
106559: LD_INT 1
106561: PLUS
106562: ST_TO_ADDR
106563: GO 106600
// if GetBType ( x [ j ] ) = b_control_tower then
106565: LD_VAR 0 11
106569: PUSH
106570: LD_VAR 0 3
106574: ARRAY
106575: PPUSH
106576: CALL_OW 266
106580: PUSH
106581: LD_INT 36
106583: EQUAL
106584: IFFALSE 106600
// places := places + 3 ;
106586: LD_ADDR_VAR 0 5
106590: PUSH
106591: LD_VAR 0 5
106595: PUSH
106596: LD_INT 3
106598: PLUS
106599: ST_TO_ADDR
106600: GO 106525
106602: POP
106603: POP
// if places = 0 or places <= mc_remote_driver [ i ] then
106604: LD_VAR 0 5
106608: PUSH
106609: LD_INT 0
106611: EQUAL
106612: PUSH
106613: LD_VAR 0 5
106617: PUSH
106618: LD_EXP 218
106622: PUSH
106623: LD_VAR 0 2
106627: ARRAY
106628: LESSEQUAL
106629: OR
106630: IFFALSE 106634
// continue ;
106632: GO 105884
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
106634: LD_ADDR_VAR 0 6
106638: PUSH
106639: LD_EXP 178
106643: PUSH
106644: LD_VAR 0 2
106648: ARRAY
106649: PPUSH
106650: LD_INT 25
106652: PUSH
106653: LD_INT 3
106655: PUSH
106656: EMPTY
106657: LIST
106658: LIST
106659: PPUSH
106660: CALL_OW 72
106664: PUSH
106665: LD_EXP 218
106669: PUSH
106670: LD_VAR 0 2
106674: ARRAY
106675: DIFF
106676: PPUSH
106677: LD_INT 3
106679: PPUSH
106680: CALL 54467 0 2
106684: ST_TO_ADDR
// for j in tmp do
106685: LD_ADDR_VAR 0 3
106689: PUSH
106690: LD_VAR 0 6
106694: PUSH
106695: FOR_IN
106696: IFFALSE 106731
// if GetTag ( j ) > 0 then
106698: LD_VAR 0 3
106702: PPUSH
106703: CALL_OW 110
106707: PUSH
106708: LD_INT 0
106710: GREATER
106711: IFFALSE 106729
// tmp := tmp diff j ;
106713: LD_ADDR_VAR 0 6
106717: PUSH
106718: LD_VAR 0 6
106722: PUSH
106723: LD_VAR 0 3
106727: DIFF
106728: ST_TO_ADDR
106729: GO 106695
106731: POP
106732: POP
// if not tmp then
106733: LD_VAR 0 6
106737: NOT
106738: IFFALSE 106742
// continue ;
106740: GO 105884
// if places then
106742: LD_VAR 0 5
106746: IFFALSE 106805
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
106748: LD_ADDR_EXP 218
106752: PUSH
106753: LD_EXP 218
106757: PPUSH
106758: LD_VAR 0 2
106762: PPUSH
106763: LD_EXP 218
106767: PUSH
106768: LD_VAR 0 2
106772: ARRAY
106773: PUSH
106774: LD_VAR 0 6
106778: PUSH
106779: LD_INT 1
106781: ARRAY
106782: UNION
106783: PPUSH
106784: CALL_OW 1
106788: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
106789: LD_VAR 0 6
106793: PUSH
106794: LD_INT 1
106796: ARRAY
106797: PPUSH
106798: LD_INT 126
106800: PPUSH
106801: CALL_OW 109
// end ; end ;
106805: GO 105884
106807: POP
106808: POP
// end ;
106809: LD_VAR 0 1
106813: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
106814: LD_INT 0
106816: PPUSH
106817: PPUSH
106818: PPUSH
106819: PPUSH
106820: PPUSH
106821: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
106822: LD_VAR 0 1
106826: NOT
106827: PUSH
106828: LD_VAR 0 2
106832: NOT
106833: OR
106834: PUSH
106835: LD_VAR 0 3
106839: NOT
106840: OR
106841: PUSH
106842: LD_VAR 0 4
106846: PUSH
106847: LD_INT 1
106849: PUSH
106850: LD_INT 2
106852: PUSH
106853: LD_INT 3
106855: PUSH
106856: LD_INT 4
106858: PUSH
106859: LD_INT 5
106861: PUSH
106862: LD_INT 8
106864: PUSH
106865: LD_INT 9
106867: PUSH
106868: LD_INT 15
106870: PUSH
106871: LD_INT 16
106873: PUSH
106874: EMPTY
106875: LIST
106876: LIST
106877: LIST
106878: LIST
106879: LIST
106880: LIST
106881: LIST
106882: LIST
106883: LIST
106884: IN
106885: NOT
106886: OR
106887: IFFALSE 106891
// exit ;
106889: GO 107791
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
106891: LD_ADDR_VAR 0 2
106895: PUSH
106896: LD_VAR 0 2
106900: PPUSH
106901: LD_INT 21
106903: PUSH
106904: LD_INT 3
106906: PUSH
106907: EMPTY
106908: LIST
106909: LIST
106910: PUSH
106911: LD_INT 24
106913: PUSH
106914: LD_INT 250
106916: PUSH
106917: EMPTY
106918: LIST
106919: LIST
106920: PUSH
106921: EMPTY
106922: LIST
106923: LIST
106924: PPUSH
106925: CALL_OW 72
106929: ST_TO_ADDR
// case class of 1 , 15 :
106930: LD_VAR 0 4
106934: PUSH
106935: LD_INT 1
106937: DOUBLE
106938: EQUAL
106939: IFTRUE 106949
106941: LD_INT 15
106943: DOUBLE
106944: EQUAL
106945: IFTRUE 106949
106947: GO 107034
106949: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
106950: LD_ADDR_VAR 0 8
106954: PUSH
106955: LD_VAR 0 2
106959: PPUSH
106960: LD_INT 2
106962: PUSH
106963: LD_INT 30
106965: PUSH
106966: LD_INT 32
106968: PUSH
106969: EMPTY
106970: LIST
106971: LIST
106972: PUSH
106973: LD_INT 30
106975: PUSH
106976: LD_INT 31
106978: PUSH
106979: EMPTY
106980: LIST
106981: LIST
106982: PUSH
106983: EMPTY
106984: LIST
106985: LIST
106986: LIST
106987: PPUSH
106988: CALL_OW 72
106992: PUSH
106993: LD_VAR 0 2
106997: PPUSH
106998: LD_INT 2
107000: PUSH
107001: LD_INT 30
107003: PUSH
107004: LD_INT 4
107006: PUSH
107007: EMPTY
107008: LIST
107009: LIST
107010: PUSH
107011: LD_INT 30
107013: PUSH
107014: LD_INT 5
107016: PUSH
107017: EMPTY
107018: LIST
107019: LIST
107020: PUSH
107021: EMPTY
107022: LIST
107023: LIST
107024: LIST
107025: PPUSH
107026: CALL_OW 72
107030: ADD
107031: ST_TO_ADDR
107032: GO 107280
107034: LD_INT 2
107036: DOUBLE
107037: EQUAL
107038: IFTRUE 107048
107040: LD_INT 16
107042: DOUBLE
107043: EQUAL
107044: IFTRUE 107048
107046: GO 107094
107048: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
107049: LD_ADDR_VAR 0 8
107053: PUSH
107054: LD_VAR 0 2
107058: PPUSH
107059: LD_INT 2
107061: PUSH
107062: LD_INT 30
107064: PUSH
107065: LD_INT 0
107067: PUSH
107068: EMPTY
107069: LIST
107070: LIST
107071: PUSH
107072: LD_INT 30
107074: PUSH
107075: LD_INT 1
107077: PUSH
107078: EMPTY
107079: LIST
107080: LIST
107081: PUSH
107082: EMPTY
107083: LIST
107084: LIST
107085: LIST
107086: PPUSH
107087: CALL_OW 72
107091: ST_TO_ADDR
107092: GO 107280
107094: LD_INT 3
107096: DOUBLE
107097: EQUAL
107098: IFTRUE 107102
107100: GO 107148
107102: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
107103: LD_ADDR_VAR 0 8
107107: PUSH
107108: LD_VAR 0 2
107112: PPUSH
107113: LD_INT 2
107115: PUSH
107116: LD_INT 30
107118: PUSH
107119: LD_INT 2
107121: PUSH
107122: EMPTY
107123: LIST
107124: LIST
107125: PUSH
107126: LD_INT 30
107128: PUSH
107129: LD_INT 3
107131: PUSH
107132: EMPTY
107133: LIST
107134: LIST
107135: PUSH
107136: EMPTY
107137: LIST
107138: LIST
107139: LIST
107140: PPUSH
107141: CALL_OW 72
107145: ST_TO_ADDR
107146: GO 107280
107148: LD_INT 4
107150: DOUBLE
107151: EQUAL
107152: IFTRUE 107156
107154: GO 107213
107156: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
107157: LD_ADDR_VAR 0 8
107161: PUSH
107162: LD_VAR 0 2
107166: PPUSH
107167: LD_INT 2
107169: PUSH
107170: LD_INT 30
107172: PUSH
107173: LD_INT 6
107175: PUSH
107176: EMPTY
107177: LIST
107178: LIST
107179: PUSH
107180: LD_INT 30
107182: PUSH
107183: LD_INT 7
107185: PUSH
107186: EMPTY
107187: LIST
107188: LIST
107189: PUSH
107190: LD_INT 30
107192: PUSH
107193: LD_INT 8
107195: PUSH
107196: EMPTY
107197: LIST
107198: LIST
107199: PUSH
107200: EMPTY
107201: LIST
107202: LIST
107203: LIST
107204: LIST
107205: PPUSH
107206: CALL_OW 72
107210: ST_TO_ADDR
107211: GO 107280
107213: LD_INT 5
107215: DOUBLE
107216: EQUAL
107217: IFTRUE 107233
107219: LD_INT 8
107221: DOUBLE
107222: EQUAL
107223: IFTRUE 107233
107225: LD_INT 9
107227: DOUBLE
107228: EQUAL
107229: IFTRUE 107233
107231: GO 107279
107233: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
107234: LD_ADDR_VAR 0 8
107238: PUSH
107239: LD_VAR 0 2
107243: PPUSH
107244: LD_INT 2
107246: PUSH
107247: LD_INT 30
107249: PUSH
107250: LD_INT 4
107252: PUSH
107253: EMPTY
107254: LIST
107255: LIST
107256: PUSH
107257: LD_INT 30
107259: PUSH
107260: LD_INT 5
107262: PUSH
107263: EMPTY
107264: LIST
107265: LIST
107266: PUSH
107267: EMPTY
107268: LIST
107269: LIST
107270: LIST
107271: PPUSH
107272: CALL_OW 72
107276: ST_TO_ADDR
107277: GO 107280
107279: POP
// if not tmp then
107280: LD_VAR 0 8
107284: NOT
107285: IFFALSE 107289
// exit ;
107287: GO 107791
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
107289: LD_VAR 0 4
107293: PUSH
107294: LD_INT 1
107296: PUSH
107297: LD_INT 15
107299: PUSH
107300: EMPTY
107301: LIST
107302: LIST
107303: IN
107304: PUSH
107305: LD_EXP 187
107309: PUSH
107310: LD_VAR 0 1
107314: ARRAY
107315: AND
107316: IFFALSE 107472
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
107318: LD_ADDR_VAR 0 9
107322: PUSH
107323: LD_EXP 187
107327: PUSH
107328: LD_VAR 0 1
107332: ARRAY
107333: PUSH
107334: LD_INT 1
107336: ARRAY
107337: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
107338: LD_VAR 0 9
107342: PUSH
107343: LD_EXP 188
107347: PUSH
107348: LD_VAR 0 1
107352: ARRAY
107353: IN
107354: NOT
107355: IFFALSE 107470
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
107357: LD_ADDR_EXP 188
107361: PUSH
107362: LD_EXP 188
107366: PPUSH
107367: LD_VAR 0 1
107371: PUSH
107372: LD_EXP 188
107376: PUSH
107377: LD_VAR 0 1
107381: ARRAY
107382: PUSH
107383: LD_INT 1
107385: PLUS
107386: PUSH
107387: EMPTY
107388: LIST
107389: LIST
107390: PPUSH
107391: LD_VAR 0 9
107395: PPUSH
107396: CALL 24210 0 3
107400: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
107401: LD_ADDR_EXP 187
107405: PUSH
107406: LD_EXP 187
107410: PPUSH
107411: LD_VAR 0 1
107415: PPUSH
107416: LD_EXP 187
107420: PUSH
107421: LD_VAR 0 1
107425: ARRAY
107426: PUSH
107427: LD_VAR 0 9
107431: DIFF
107432: PPUSH
107433: CALL_OW 1
107437: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
107438: LD_VAR 0 3
107442: PPUSH
107443: LD_EXP 188
107447: PUSH
107448: LD_VAR 0 1
107452: ARRAY
107453: PUSH
107454: LD_EXP 188
107458: PUSH
107459: LD_VAR 0 1
107463: ARRAY
107464: ARRAY
107465: PPUSH
107466: CALL_OW 120
// end ; exit ;
107470: GO 107791
// end ; if tmp > 1 then
107472: LD_VAR 0 8
107476: PUSH
107477: LD_INT 1
107479: GREATER
107480: IFFALSE 107584
// for i = 2 to tmp do
107482: LD_ADDR_VAR 0 6
107486: PUSH
107487: DOUBLE
107488: LD_INT 2
107490: DEC
107491: ST_TO_ADDR
107492: LD_VAR 0 8
107496: PUSH
107497: FOR_TO
107498: IFFALSE 107582
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
107500: LD_VAR 0 8
107504: PUSH
107505: LD_VAR 0 6
107509: ARRAY
107510: PPUSH
107511: CALL_OW 461
107515: PUSH
107516: LD_INT 6
107518: EQUAL
107519: IFFALSE 107580
// begin x := tmp [ i ] ;
107521: LD_ADDR_VAR 0 9
107525: PUSH
107526: LD_VAR 0 8
107530: PUSH
107531: LD_VAR 0 6
107535: ARRAY
107536: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
107537: LD_ADDR_VAR 0 8
107541: PUSH
107542: LD_VAR 0 8
107546: PPUSH
107547: LD_VAR 0 6
107551: PPUSH
107552: CALL_OW 3
107556: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
107557: LD_ADDR_VAR 0 8
107561: PUSH
107562: LD_VAR 0 8
107566: PPUSH
107567: LD_INT 1
107569: PPUSH
107570: LD_VAR 0 9
107574: PPUSH
107575: CALL_OW 2
107579: ST_TO_ADDR
// end ;
107580: GO 107497
107582: POP
107583: POP
// for i in tmp do
107584: LD_ADDR_VAR 0 6
107588: PUSH
107589: LD_VAR 0 8
107593: PUSH
107594: FOR_IN
107595: IFFALSE 107664
// begin if ( UnitsInside ( i ) < 6 and not GetBType ( i ) in [ b_breastwork , b_bunker ] ) or UnitsInside ( i ) = 0 then
107597: LD_VAR 0 6
107601: PPUSH
107602: CALL_OW 313
107606: PUSH
107607: LD_INT 6
107609: LESS
107610: PUSH
107611: LD_VAR 0 6
107615: PPUSH
107616: CALL_OW 266
107620: PUSH
107621: LD_INT 31
107623: PUSH
107624: LD_INT 32
107626: PUSH
107627: EMPTY
107628: LIST
107629: LIST
107630: IN
107631: NOT
107632: AND
107633: PUSH
107634: LD_VAR 0 6
107638: PPUSH
107639: CALL_OW 313
107643: PUSH
107644: LD_INT 0
107646: EQUAL
107647: OR
107648: IFFALSE 107662
// begin j := i ;
107650: LD_ADDR_VAR 0 7
107654: PUSH
107655: LD_VAR 0 6
107659: ST_TO_ADDR
// break ;
107660: GO 107664
// end ; end ;
107662: GO 107594
107664: POP
107665: POP
// if j then
107666: LD_VAR 0 7
107670: IFFALSE 107688
// ComEnterUnit ( unit , j ) else
107672: LD_VAR 0 3
107676: PPUSH
107677: LD_VAR 0 7
107681: PPUSH
107682: CALL_OW 120
107686: GO 107791
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
107688: LD_ADDR_VAR 0 10
107692: PUSH
107693: LD_VAR 0 2
107697: PPUSH
107698: LD_INT 2
107700: PUSH
107701: LD_INT 30
107703: PUSH
107704: LD_INT 0
107706: PUSH
107707: EMPTY
107708: LIST
107709: LIST
107710: PUSH
107711: LD_INT 30
107713: PUSH
107714: LD_INT 1
107716: PUSH
107717: EMPTY
107718: LIST
107719: LIST
107720: PUSH
107721: EMPTY
107722: LIST
107723: LIST
107724: LIST
107725: PPUSH
107726: CALL_OW 72
107730: ST_TO_ADDR
// if depot then
107731: LD_VAR 0 10
107735: IFFALSE 107791
// begin depot := NearestUnitToUnit ( depot , unit ) ;
107737: LD_ADDR_VAR 0 10
107741: PUSH
107742: LD_VAR 0 10
107746: PPUSH
107747: LD_VAR 0 3
107751: PPUSH
107752: CALL_OW 74
107756: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
107757: LD_VAR 0 3
107761: PPUSH
107762: LD_VAR 0 10
107766: PPUSH
107767: CALL_OW 296
107771: PUSH
107772: LD_INT 10
107774: GREATER
107775: IFFALSE 107791
// ComStandNearbyBuilding ( unit , depot ) ;
107777: LD_VAR 0 3
107781: PPUSH
107782: LD_VAR 0 10
107786: PPUSH
107787: CALL 20788 0 2
// end ; end ; end ;
107791: LD_VAR 0 5
107795: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
107796: LD_INT 0
107798: PPUSH
107799: PPUSH
107800: PPUSH
107801: PPUSH
// if not mc_bases then
107802: LD_EXP 178
107806: NOT
107807: IFFALSE 107811
// exit ;
107809: GO 108050
// for i = 1 to mc_bases do
107811: LD_ADDR_VAR 0 2
107815: PUSH
107816: DOUBLE
107817: LD_INT 1
107819: DEC
107820: ST_TO_ADDR
107821: LD_EXP 178
107825: PUSH
107826: FOR_TO
107827: IFFALSE 108048
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
107829: LD_ADDR_VAR 0 4
107833: PUSH
107834: LD_EXP 178
107838: PUSH
107839: LD_VAR 0 2
107843: ARRAY
107844: PPUSH
107845: LD_INT 21
107847: PUSH
107848: LD_INT 1
107850: PUSH
107851: EMPTY
107852: LIST
107853: LIST
107854: PPUSH
107855: CALL_OW 72
107859: PUSH
107860: LD_EXP 207
107864: PUSH
107865: LD_VAR 0 2
107869: ARRAY
107870: UNION
107871: ST_TO_ADDR
// if not tmp then
107872: LD_VAR 0 4
107876: NOT
107877: IFFALSE 107881
// continue ;
107879: GO 107826
// for j in tmp do
107881: LD_ADDR_VAR 0 3
107885: PUSH
107886: LD_VAR 0 4
107890: PUSH
107891: FOR_IN
107892: IFFALSE 108044
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
107894: LD_VAR 0 3
107898: PPUSH
107899: CALL_OW 110
107903: NOT
107904: PUSH
107905: LD_VAR 0 3
107909: PPUSH
107910: CALL_OW 314
107914: NOT
107915: AND
107916: PUSH
107917: LD_VAR 0 3
107921: PPUSH
107922: CALL_OW 311
107926: NOT
107927: AND
107928: PUSH
107929: LD_VAR 0 3
107933: PPUSH
107934: CALL_OW 310
107938: NOT
107939: AND
107940: PUSH
107941: LD_VAR 0 3
107945: PUSH
107946: LD_EXP 181
107950: PUSH
107951: LD_VAR 0 2
107955: ARRAY
107956: PUSH
107957: LD_INT 1
107959: ARRAY
107960: IN
107961: NOT
107962: AND
107963: PUSH
107964: LD_VAR 0 3
107968: PUSH
107969: LD_EXP 181
107973: PUSH
107974: LD_VAR 0 2
107978: ARRAY
107979: PUSH
107980: LD_INT 2
107982: ARRAY
107983: IN
107984: NOT
107985: AND
107986: PUSH
107987: LD_VAR 0 3
107991: PUSH
107992: LD_EXP 190
107996: PUSH
107997: LD_VAR 0 2
108001: ARRAY
108002: IN
108003: NOT
108004: AND
108005: IFFALSE 108042
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
108007: LD_VAR 0 2
108011: PPUSH
108012: LD_EXP 178
108016: PUSH
108017: LD_VAR 0 2
108021: ARRAY
108022: PPUSH
108023: LD_VAR 0 3
108027: PPUSH
108028: LD_VAR 0 3
108032: PPUSH
108033: CALL_OW 257
108037: PPUSH
108038: CALL 106814 0 4
// end ;
108042: GO 107891
108044: POP
108045: POP
// end ;
108046: GO 107826
108048: POP
108049: POP
// end ;
108050: LD_VAR 0 1
108054: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , x , j ; begin
108055: LD_INT 0
108057: PPUSH
108058: PPUSH
108059: PPUSH
108060: PPUSH
108061: PPUSH
108062: PPUSH
// if not mc_bases [ base ] then
108063: LD_EXP 178
108067: PUSH
108068: LD_VAR 0 1
108072: ARRAY
108073: NOT
108074: IFFALSE 108078
// exit ;
108076: GO 108260
// tmp := [ ] ;
108078: LD_ADDR_VAR 0 6
108082: PUSH
108083: EMPTY
108084: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
108085: LD_ADDR_VAR 0 7
108089: PUSH
108090: LD_VAR 0 3
108094: PPUSH
108095: LD_INT 0
108097: PPUSH
108098: CALL_OW 517
108102: ST_TO_ADDR
// if not list then
108103: LD_VAR 0 7
108107: NOT
108108: IFFALSE 108112
// exit ;
108110: GO 108260
// for i = 1 to amount do
108112: LD_ADDR_VAR 0 5
108116: PUSH
108117: DOUBLE
108118: LD_INT 1
108120: DEC
108121: ST_TO_ADDR
108122: LD_VAR 0 2
108126: PUSH
108127: FOR_TO
108128: IFFALSE 108208
// begin x := rand ( 1 , list [ 1 ] ) ;
108130: LD_ADDR_VAR 0 8
108134: PUSH
108135: LD_INT 1
108137: PPUSH
108138: LD_VAR 0 7
108142: PUSH
108143: LD_INT 1
108145: ARRAY
108146: PPUSH
108147: CALL_OW 12
108151: ST_TO_ADDR
// tmp := Replace ( tmp , i , [ list [ 1 ] [ x ] , list [ 2 ] [ x ] ] ) ;
108152: LD_ADDR_VAR 0 6
108156: PUSH
108157: LD_VAR 0 6
108161: PPUSH
108162: LD_VAR 0 5
108166: PPUSH
108167: LD_VAR 0 7
108171: PUSH
108172: LD_INT 1
108174: ARRAY
108175: PUSH
108176: LD_VAR 0 8
108180: ARRAY
108181: PUSH
108182: LD_VAR 0 7
108186: PUSH
108187: LD_INT 2
108189: ARRAY
108190: PUSH
108191: LD_VAR 0 8
108195: ARRAY
108196: PUSH
108197: EMPTY
108198: LIST
108199: LIST
108200: PPUSH
108201: CALL_OW 1
108205: ST_TO_ADDR
// end ;
108206: GO 108127
108208: POP
108209: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
108210: LD_ADDR_EXP 191
108214: PUSH
108215: LD_EXP 191
108219: PPUSH
108220: LD_VAR 0 1
108224: PPUSH
108225: LD_VAR 0 6
108229: PPUSH
108230: CALL_OW 1
108234: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
108235: LD_ADDR_EXP 193
108239: PUSH
108240: LD_EXP 193
108244: PPUSH
108245: LD_VAR 0 1
108249: PPUSH
108250: LD_VAR 0 3
108254: PPUSH
108255: CALL_OW 1
108259: ST_TO_ADDR
// end ;
108260: LD_VAR 0 4
108264: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
108265: LD_INT 0
108267: PPUSH
// if not mc_bases [ base ] then
108268: LD_EXP 178
108272: PUSH
108273: LD_VAR 0 1
108277: ARRAY
108278: NOT
108279: IFFALSE 108283
// exit ;
108281: GO 108308
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
108283: LD_ADDR_EXP 183
108287: PUSH
108288: LD_EXP 183
108292: PPUSH
108293: LD_VAR 0 1
108297: PPUSH
108298: LD_VAR 0 2
108302: PPUSH
108303: CALL_OW 1
108307: ST_TO_ADDR
// end ;
108308: LD_VAR 0 3
108312: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
108313: LD_INT 0
108315: PPUSH
// if not mc_bases [ base ] then
108316: LD_EXP 178
108320: PUSH
108321: LD_VAR 0 1
108325: ARRAY
108326: NOT
108327: IFFALSE 108331
// exit ;
108329: GO 108368
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
108331: LD_ADDR_EXP 183
108335: PUSH
108336: LD_EXP 183
108340: PPUSH
108341: LD_VAR 0 1
108345: PPUSH
108346: LD_EXP 183
108350: PUSH
108351: LD_VAR 0 1
108355: ARRAY
108356: PUSH
108357: LD_VAR 0 2
108361: UNION
108362: PPUSH
108363: CALL_OW 1
108367: ST_TO_ADDR
// end ;
108368: LD_VAR 0 3
108372: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
108373: LD_INT 0
108375: PPUSH
// if not mc_bases [ base ] then
108376: LD_EXP 178
108380: PUSH
108381: LD_VAR 0 1
108385: ARRAY
108386: NOT
108387: IFFALSE 108391
// exit ;
108389: GO 108416
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
108391: LD_ADDR_EXP 199
108395: PUSH
108396: LD_EXP 199
108400: PPUSH
108401: LD_VAR 0 1
108405: PPUSH
108406: LD_VAR 0 2
108410: PPUSH
108411: CALL_OW 1
108415: ST_TO_ADDR
// end ;
108416: LD_VAR 0 3
108420: RET
// export function MC_InsertProduceList ( base , components ) ; begin
108421: LD_INT 0
108423: PPUSH
// if not mc_bases [ base ] then
108424: LD_EXP 178
108428: PUSH
108429: LD_VAR 0 1
108433: ARRAY
108434: NOT
108435: IFFALSE 108439
// exit ;
108437: GO 108476
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
108439: LD_ADDR_EXP 199
108443: PUSH
108444: LD_EXP 199
108448: PPUSH
108449: LD_VAR 0 1
108453: PPUSH
108454: LD_EXP 199
108458: PUSH
108459: LD_VAR 0 1
108463: ARRAY
108464: PUSH
108465: LD_VAR 0 2
108469: ADD
108470: PPUSH
108471: CALL_OW 1
108475: ST_TO_ADDR
// end ;
108476: LD_VAR 0 3
108480: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
108481: LD_INT 0
108483: PPUSH
// if not mc_bases [ base ] then
108484: LD_EXP 178
108488: PUSH
108489: LD_VAR 0 1
108493: ARRAY
108494: NOT
108495: IFFALSE 108499
// exit ;
108497: GO 108553
// mc_defender := Replace ( mc_defender , base , deflist ) ;
108499: LD_ADDR_EXP 200
108503: PUSH
108504: LD_EXP 200
108508: PPUSH
108509: LD_VAR 0 1
108513: PPUSH
108514: LD_VAR 0 2
108518: PPUSH
108519: CALL_OW 1
108523: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
108524: LD_ADDR_EXP 189
108528: PUSH
108529: LD_EXP 189
108533: PPUSH
108534: LD_VAR 0 1
108538: PPUSH
108539: LD_VAR 0 2
108543: PUSH
108544: LD_INT 0
108546: PLUS
108547: PPUSH
108548: CALL_OW 1
108552: ST_TO_ADDR
// end ;
108553: LD_VAR 0 3
108557: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
108558: LD_INT 0
108560: PPUSH
// if not mc_bases [ base ] then
108561: LD_EXP 178
108565: PUSH
108566: LD_VAR 0 1
108570: ARRAY
108571: NOT
108572: IFFALSE 108576
// exit ;
108574: GO 108601
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
108576: LD_ADDR_EXP 189
108580: PUSH
108581: LD_EXP 189
108585: PPUSH
108586: LD_VAR 0 1
108590: PPUSH
108591: LD_VAR 0 2
108595: PPUSH
108596: CALL_OW 1
108600: ST_TO_ADDR
// end ;
108601: LD_VAR 0 3
108605: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
108606: LD_INT 0
108608: PPUSH
108609: PPUSH
108610: PPUSH
108611: PPUSH
// if not mc_bases [ base ] then
108612: LD_EXP 178
108616: PUSH
108617: LD_VAR 0 1
108621: ARRAY
108622: NOT
108623: IFFALSE 108627
// exit ;
108625: GO 108692
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
108627: LD_ADDR_EXP 198
108631: PUSH
108632: LD_EXP 198
108636: PPUSH
108637: LD_VAR 0 1
108641: PUSH
108642: LD_EXP 198
108646: PUSH
108647: LD_VAR 0 1
108651: ARRAY
108652: PUSH
108653: LD_INT 1
108655: PLUS
108656: PUSH
108657: EMPTY
108658: LIST
108659: LIST
108660: PPUSH
108661: LD_VAR 0 1
108665: PUSH
108666: LD_VAR 0 2
108670: PUSH
108671: LD_VAR 0 3
108675: PUSH
108676: LD_VAR 0 4
108680: PUSH
108681: EMPTY
108682: LIST
108683: LIST
108684: LIST
108685: LIST
108686: PPUSH
108687: CALL 24210 0 3
108691: ST_TO_ADDR
// end ;
108692: LD_VAR 0 5
108696: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
108697: LD_INT 0
108699: PPUSH
// if not mc_bases [ base ] then
108700: LD_EXP 178
108704: PUSH
108705: LD_VAR 0 1
108709: ARRAY
108710: NOT
108711: IFFALSE 108715
// exit ;
108713: GO 108740
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
108715: LD_ADDR_EXP 215
108719: PUSH
108720: LD_EXP 215
108724: PPUSH
108725: LD_VAR 0 1
108729: PPUSH
108730: LD_VAR 0 2
108734: PPUSH
108735: CALL_OW 1
108739: ST_TO_ADDR
// end ;
108740: LD_VAR 0 3
108744: RET
// export function MC_GetMinesField ( base ) ; begin
108745: LD_INT 0
108747: PPUSH
// result := mc_mines [ base ] ;
108748: LD_ADDR_VAR 0 2
108752: PUSH
108753: LD_EXP 191
108757: PUSH
108758: LD_VAR 0 1
108762: ARRAY
108763: ST_TO_ADDR
// end ;
108764: LD_VAR 0 2
108768: RET
// export function MC_GetProduceList ( base ) ; begin
108769: LD_INT 0
108771: PPUSH
// result := mc_produce [ base ] ;
108772: LD_ADDR_VAR 0 2
108776: PUSH
108777: LD_EXP 199
108781: PUSH
108782: LD_VAR 0 1
108786: ARRAY
108787: ST_TO_ADDR
// end ;
108788: LD_VAR 0 2
108792: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
108793: LD_INT 0
108795: PPUSH
108796: PPUSH
// if not mc_bases then
108797: LD_EXP 178
108801: NOT
108802: IFFALSE 108806
// exit ;
108804: GO 108871
// if mc_bases [ base ] then
108806: LD_EXP 178
108810: PUSH
108811: LD_VAR 0 1
108815: ARRAY
108816: IFFALSE 108871
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
108818: LD_ADDR_VAR 0 3
108822: PUSH
108823: LD_EXP 178
108827: PUSH
108828: LD_VAR 0 1
108832: ARRAY
108833: PPUSH
108834: LD_INT 30
108836: PUSH
108837: LD_VAR 0 2
108841: PUSH
108842: EMPTY
108843: LIST
108844: LIST
108845: PPUSH
108846: CALL_OW 72
108850: ST_TO_ADDR
// if result then
108851: LD_VAR 0 3
108855: IFFALSE 108871
// result := result [ 1 ] ;
108857: LD_ADDR_VAR 0 3
108861: PUSH
108862: LD_VAR 0 3
108866: PUSH
108867: LD_INT 1
108869: ARRAY
108870: ST_TO_ADDR
// end ; end ;
108871: LD_VAR 0 3
108875: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
108876: LD_INT 0
108878: PPUSH
108879: PPUSH
// if not mc_bases then
108880: LD_EXP 178
108884: NOT
108885: IFFALSE 108889
// exit ;
108887: GO 108934
// if mc_bases [ base ] then
108889: LD_EXP 178
108893: PUSH
108894: LD_VAR 0 1
108898: ARRAY
108899: IFFALSE 108934
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
108901: LD_ADDR_VAR 0 3
108905: PUSH
108906: LD_EXP 178
108910: PUSH
108911: LD_VAR 0 1
108915: ARRAY
108916: PPUSH
108917: LD_INT 30
108919: PUSH
108920: LD_VAR 0 2
108924: PUSH
108925: EMPTY
108926: LIST
108927: LIST
108928: PPUSH
108929: CALL_OW 72
108933: ST_TO_ADDR
// end ;
108934: LD_VAR 0 3
108938: RET
// export function MC_SetTame ( base , area ) ; begin
108939: LD_INT 0
108941: PPUSH
// if not mc_bases or not base then
108942: LD_EXP 178
108946: NOT
108947: PUSH
108948: LD_VAR 0 1
108952: NOT
108953: OR
108954: IFFALSE 108958
// exit ;
108956: GO 108983
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
108958: LD_ADDR_EXP 206
108962: PUSH
108963: LD_EXP 206
108967: PPUSH
108968: LD_VAR 0 1
108972: PPUSH
108973: LD_VAR 0 2
108977: PPUSH
108978: CALL_OW 1
108982: ST_TO_ADDR
// end ;
108983: LD_VAR 0 3
108987: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
108988: LD_INT 0
108990: PPUSH
108991: PPUSH
// if not mc_bases or not base then
108992: LD_EXP 178
108996: NOT
108997: PUSH
108998: LD_VAR 0 1
109002: NOT
109003: OR
109004: IFFALSE 109008
// exit ;
109006: GO 109110
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
109008: LD_ADDR_VAR 0 4
109012: PUSH
109013: LD_EXP 178
109017: PUSH
109018: LD_VAR 0 1
109022: ARRAY
109023: PPUSH
109024: LD_INT 30
109026: PUSH
109027: LD_VAR 0 2
109031: PUSH
109032: EMPTY
109033: LIST
109034: LIST
109035: PPUSH
109036: CALL_OW 72
109040: ST_TO_ADDR
// if not tmp then
109041: LD_VAR 0 4
109045: NOT
109046: IFFALSE 109050
// exit ;
109048: GO 109110
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
109050: LD_ADDR_EXP 210
109054: PUSH
109055: LD_EXP 210
109059: PPUSH
109060: LD_VAR 0 1
109064: PPUSH
109065: LD_EXP 210
109069: PUSH
109070: LD_VAR 0 1
109074: ARRAY
109075: PPUSH
109076: LD_EXP 210
109080: PUSH
109081: LD_VAR 0 1
109085: ARRAY
109086: PUSH
109087: LD_INT 1
109089: PLUS
109090: PPUSH
109091: LD_VAR 0 4
109095: PUSH
109096: LD_INT 1
109098: ARRAY
109099: PPUSH
109100: CALL_OW 2
109104: PPUSH
109105: CALL_OW 1
109109: ST_TO_ADDR
// end ;
109110: LD_VAR 0 3
109114: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
109115: LD_INT 0
109117: PPUSH
109118: PPUSH
// if not mc_bases or not base or not kinds then
109119: LD_EXP 178
109123: NOT
109124: PUSH
109125: LD_VAR 0 1
109129: NOT
109130: OR
109131: PUSH
109132: LD_VAR 0 2
109136: NOT
109137: OR
109138: IFFALSE 109142
// exit ;
109140: GO 109203
// for i in kinds do
109142: LD_ADDR_VAR 0 4
109146: PUSH
109147: LD_VAR 0 2
109151: PUSH
109152: FOR_IN
109153: IFFALSE 109201
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
109155: LD_ADDR_EXP 212
109159: PUSH
109160: LD_EXP 212
109164: PPUSH
109165: LD_VAR 0 1
109169: PUSH
109170: LD_EXP 212
109174: PUSH
109175: LD_VAR 0 1
109179: ARRAY
109180: PUSH
109181: LD_INT 1
109183: PLUS
109184: PUSH
109185: EMPTY
109186: LIST
109187: LIST
109188: PPUSH
109189: LD_VAR 0 4
109193: PPUSH
109194: CALL 24210 0 3
109198: ST_TO_ADDR
109199: GO 109152
109201: POP
109202: POP
// end ;
109203: LD_VAR 0 3
109207: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
109208: LD_INT 0
109210: PPUSH
// if not mc_bases or not base or not areas then
109211: LD_EXP 178
109215: NOT
109216: PUSH
109217: LD_VAR 0 1
109221: NOT
109222: OR
109223: PUSH
109224: LD_VAR 0 2
109228: NOT
109229: OR
109230: IFFALSE 109234
// exit ;
109232: GO 109259
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
109234: LD_ADDR_EXP 196
109238: PUSH
109239: LD_EXP 196
109243: PPUSH
109244: LD_VAR 0 1
109248: PPUSH
109249: LD_VAR 0 2
109253: PPUSH
109254: CALL_OW 1
109258: ST_TO_ADDR
// end ;
109259: LD_VAR 0 3
109263: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
109264: LD_INT 0
109266: PPUSH
// if not mc_bases or not base or not teleports_exit then
109267: LD_EXP 178
109271: NOT
109272: PUSH
109273: LD_VAR 0 1
109277: NOT
109278: OR
109279: PUSH
109280: LD_VAR 0 2
109284: NOT
109285: OR
109286: IFFALSE 109290
// exit ;
109288: GO 109315
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
109290: LD_ADDR_EXP 213
109294: PUSH
109295: LD_EXP 213
109299: PPUSH
109300: LD_VAR 0 1
109304: PPUSH
109305: LD_VAR 0 2
109309: PPUSH
109310: CALL_OW 1
109314: ST_TO_ADDR
// end ;
109315: LD_VAR 0 3
109319: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
109320: LD_INT 0
109322: PPUSH
109323: PPUSH
109324: PPUSH
// if not mc_bases or not base or not ext_list then
109325: LD_EXP 178
109329: NOT
109330: PUSH
109331: LD_VAR 0 1
109335: NOT
109336: OR
109337: PUSH
109338: LD_VAR 0 5
109342: NOT
109343: OR
109344: IFFALSE 109348
// exit ;
109346: GO 109521
// tmp := GetFacExtXYD ( x , y , d ) ;
109348: LD_ADDR_VAR 0 8
109352: PUSH
109353: LD_VAR 0 2
109357: PPUSH
109358: LD_VAR 0 3
109362: PPUSH
109363: LD_VAR 0 4
109367: PPUSH
109368: CALL 53597 0 3
109372: ST_TO_ADDR
// if not tmp then
109373: LD_VAR 0 8
109377: NOT
109378: IFFALSE 109382
// exit ;
109380: GO 109521
// for i in tmp do
109382: LD_ADDR_VAR 0 7
109386: PUSH
109387: LD_VAR 0 8
109391: PUSH
109392: FOR_IN
109393: IFFALSE 109519
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
109395: LD_ADDR_EXP 183
109399: PUSH
109400: LD_EXP 183
109404: PPUSH
109405: LD_VAR 0 1
109409: PPUSH
109410: LD_EXP 183
109414: PUSH
109415: LD_VAR 0 1
109419: ARRAY
109420: PPUSH
109421: LD_EXP 183
109425: PUSH
109426: LD_VAR 0 1
109430: ARRAY
109431: PUSH
109432: LD_INT 1
109434: PLUS
109435: PPUSH
109436: LD_VAR 0 5
109440: PUSH
109441: LD_INT 1
109443: ARRAY
109444: PUSH
109445: LD_VAR 0 7
109449: PUSH
109450: LD_INT 1
109452: ARRAY
109453: PUSH
109454: LD_VAR 0 7
109458: PUSH
109459: LD_INT 2
109461: ARRAY
109462: PUSH
109463: LD_VAR 0 7
109467: PUSH
109468: LD_INT 3
109470: ARRAY
109471: PUSH
109472: EMPTY
109473: LIST
109474: LIST
109475: LIST
109476: LIST
109477: PPUSH
109478: CALL_OW 2
109482: PPUSH
109483: CALL_OW 1
109487: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
109488: LD_ADDR_VAR 0 5
109492: PUSH
109493: LD_VAR 0 5
109497: PPUSH
109498: LD_INT 1
109500: PPUSH
109501: CALL_OW 3
109505: ST_TO_ADDR
// if not ext_list then
109506: LD_VAR 0 5
109510: NOT
109511: IFFALSE 109517
// exit ;
109513: POP
109514: POP
109515: GO 109521
// end ;
109517: GO 109392
109519: POP
109520: POP
// end ;
109521: LD_VAR 0 6
109525: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
109526: LD_INT 0
109528: PPUSH
// if not mc_bases or not base or not weapon_list then
109529: LD_EXP 178
109533: NOT
109534: PUSH
109535: LD_VAR 0 1
109539: NOT
109540: OR
109541: PUSH
109542: LD_VAR 0 2
109546: NOT
109547: OR
109548: IFFALSE 109552
// exit ;
109550: GO 109577
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
109552: LD_ADDR_EXP 217
109556: PUSH
109557: LD_EXP 217
109561: PPUSH
109562: LD_VAR 0 1
109566: PPUSH
109567: LD_VAR 0 2
109571: PPUSH
109572: CALL_OW 1
109576: ST_TO_ADDR
// end ;
109577: LD_VAR 0 3
109581: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
109582: LD_INT 0
109584: PPUSH
// if not mc_bases or not base or not tech_list then
109585: LD_EXP 178
109589: NOT
109590: PUSH
109591: LD_VAR 0 1
109595: NOT
109596: OR
109597: PUSH
109598: LD_VAR 0 2
109602: NOT
109603: OR
109604: IFFALSE 109608
// exit ;
109606: GO 109633
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
109608: LD_ADDR_EXP 205
109612: PUSH
109613: LD_EXP 205
109617: PPUSH
109618: LD_VAR 0 1
109622: PPUSH
109623: LD_VAR 0 2
109627: PPUSH
109628: CALL_OW 1
109632: ST_TO_ADDR
// end ;
109633: LD_VAR 0 3
109637: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
109638: LD_INT 0
109640: PPUSH
// if not mc_bases or not parking_area or not base then
109641: LD_EXP 178
109645: NOT
109646: PUSH
109647: LD_VAR 0 2
109651: NOT
109652: OR
109653: PUSH
109654: LD_VAR 0 1
109658: NOT
109659: OR
109660: IFFALSE 109664
// exit ;
109662: GO 109689
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
109664: LD_ADDR_EXP 202
109668: PUSH
109669: LD_EXP 202
109673: PPUSH
109674: LD_VAR 0 1
109678: PPUSH
109679: LD_VAR 0 2
109683: PPUSH
109684: CALL_OW 1
109688: ST_TO_ADDR
// end ;
109689: LD_VAR 0 3
109693: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
109694: LD_INT 0
109696: PPUSH
// if not mc_bases or not base or not scan_area then
109697: LD_EXP 178
109701: NOT
109702: PUSH
109703: LD_VAR 0 1
109707: NOT
109708: OR
109709: PUSH
109710: LD_VAR 0 2
109714: NOT
109715: OR
109716: IFFALSE 109720
// exit ;
109718: GO 109745
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
109720: LD_ADDR_EXP 203
109724: PUSH
109725: LD_EXP 203
109729: PPUSH
109730: LD_VAR 0 1
109734: PPUSH
109735: LD_VAR 0 2
109739: PPUSH
109740: CALL_OW 1
109744: ST_TO_ADDR
// end ;
109745: LD_VAR 0 3
109749: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
109750: LD_INT 0
109752: PPUSH
109753: PPUSH
// if not mc_bases or not base then
109754: LD_EXP 178
109758: NOT
109759: PUSH
109760: LD_VAR 0 1
109764: NOT
109765: OR
109766: IFFALSE 109770
// exit ;
109768: GO 109834
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
109770: LD_ADDR_VAR 0 3
109774: PUSH
109775: LD_INT 1
109777: PUSH
109778: LD_INT 2
109780: PUSH
109781: LD_INT 3
109783: PUSH
109784: LD_INT 4
109786: PUSH
109787: LD_INT 11
109789: PUSH
109790: EMPTY
109791: LIST
109792: LIST
109793: LIST
109794: LIST
109795: LIST
109796: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
109797: LD_ADDR_EXP 205
109801: PUSH
109802: LD_EXP 205
109806: PPUSH
109807: LD_VAR 0 1
109811: PPUSH
109812: LD_EXP 205
109816: PUSH
109817: LD_VAR 0 1
109821: ARRAY
109822: PUSH
109823: LD_VAR 0 3
109827: DIFF
109828: PPUSH
109829: CALL_OW 1
109833: ST_TO_ADDR
// end ;
109834: LD_VAR 0 2
109838: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
109839: LD_INT 0
109841: PPUSH
// result := mc_vehicles [ base ] ;
109842: LD_ADDR_VAR 0 3
109846: PUSH
109847: LD_EXP 197
109851: PUSH
109852: LD_VAR 0 1
109856: ARRAY
109857: ST_TO_ADDR
// if onlyCombat then
109858: LD_VAR 0 2
109862: IFFALSE 110040
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
109864: LD_ADDR_VAR 0 3
109868: PUSH
109869: LD_VAR 0 3
109873: PUSH
109874: LD_VAR 0 3
109878: PPUSH
109879: LD_INT 2
109881: PUSH
109882: LD_INT 34
109884: PUSH
109885: LD_INT 12
109887: PUSH
109888: EMPTY
109889: LIST
109890: LIST
109891: PUSH
109892: LD_INT 34
109894: PUSH
109895: LD_INT 51
109897: PUSH
109898: EMPTY
109899: LIST
109900: LIST
109901: PUSH
109902: LD_INT 34
109904: PUSH
109905: LD_EXP 158
109909: PUSH
109910: EMPTY
109911: LIST
109912: LIST
109913: PUSH
109914: LD_INT 34
109916: PUSH
109917: LD_INT 32
109919: PUSH
109920: EMPTY
109921: LIST
109922: LIST
109923: PUSH
109924: LD_INT 34
109926: PUSH
109927: LD_INT 13
109929: PUSH
109930: EMPTY
109931: LIST
109932: LIST
109933: PUSH
109934: LD_INT 34
109936: PUSH
109937: LD_INT 52
109939: PUSH
109940: EMPTY
109941: LIST
109942: LIST
109943: PUSH
109944: LD_INT 34
109946: PUSH
109947: LD_EXP 163
109951: PUSH
109952: EMPTY
109953: LIST
109954: LIST
109955: PUSH
109956: LD_INT 34
109958: PUSH
109959: LD_INT 14
109961: PUSH
109962: EMPTY
109963: LIST
109964: LIST
109965: PUSH
109966: LD_INT 34
109968: PUSH
109969: LD_INT 53
109971: PUSH
109972: EMPTY
109973: LIST
109974: LIST
109975: PUSH
109976: LD_INT 34
109978: PUSH
109979: LD_EXP 157
109983: PUSH
109984: EMPTY
109985: LIST
109986: LIST
109987: PUSH
109988: LD_INT 34
109990: PUSH
109991: LD_INT 31
109993: PUSH
109994: EMPTY
109995: LIST
109996: LIST
109997: PUSH
109998: LD_INT 34
110000: PUSH
110001: LD_INT 48
110003: PUSH
110004: EMPTY
110005: LIST
110006: LIST
110007: PUSH
110008: LD_INT 34
110010: PUSH
110011: LD_INT 8
110013: PUSH
110014: EMPTY
110015: LIST
110016: LIST
110017: PUSH
110018: EMPTY
110019: LIST
110020: LIST
110021: LIST
110022: LIST
110023: LIST
110024: LIST
110025: LIST
110026: LIST
110027: LIST
110028: LIST
110029: LIST
110030: LIST
110031: LIST
110032: LIST
110033: PPUSH
110034: CALL_OW 72
110038: DIFF
110039: ST_TO_ADDR
// end ; end_of_file
110040: LD_VAR 0 3
110044: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
110045: LD_INT 0
110047: PPUSH
110048: PPUSH
110049: PPUSH
// if not mc_bases or not skirmish then
110050: LD_EXP 178
110054: NOT
110055: PUSH
110056: LD_EXP 176
110060: NOT
110061: OR
110062: IFFALSE 110066
// exit ;
110064: GO 110231
// for i = 1 to mc_bases do
110066: LD_ADDR_VAR 0 4
110070: PUSH
110071: DOUBLE
110072: LD_INT 1
110074: DEC
110075: ST_TO_ADDR
110076: LD_EXP 178
110080: PUSH
110081: FOR_TO
110082: IFFALSE 110229
// begin if sci in mc_bases [ i ] then
110084: LD_VAR 0 2
110088: PUSH
110089: LD_EXP 178
110093: PUSH
110094: LD_VAR 0 4
110098: ARRAY
110099: IN
110100: IFFALSE 110227
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
110102: LD_ADDR_EXP 207
110106: PUSH
110107: LD_EXP 207
110111: PPUSH
110112: LD_VAR 0 4
110116: PUSH
110117: LD_EXP 207
110121: PUSH
110122: LD_VAR 0 4
110126: ARRAY
110127: PUSH
110128: LD_INT 1
110130: PLUS
110131: PUSH
110132: EMPTY
110133: LIST
110134: LIST
110135: PPUSH
110136: LD_VAR 0 1
110140: PPUSH
110141: CALL 24210 0 3
110145: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
110146: LD_ADDR_VAR 0 5
110150: PUSH
110151: LD_EXP 178
110155: PUSH
110156: LD_VAR 0 4
110160: ARRAY
110161: PPUSH
110162: LD_INT 2
110164: PUSH
110165: LD_INT 30
110167: PUSH
110168: LD_INT 0
110170: PUSH
110171: EMPTY
110172: LIST
110173: LIST
110174: PUSH
110175: LD_INT 30
110177: PUSH
110178: LD_INT 1
110180: PUSH
110181: EMPTY
110182: LIST
110183: LIST
110184: PUSH
110185: EMPTY
110186: LIST
110187: LIST
110188: LIST
110189: PPUSH
110190: CALL_OW 72
110194: PPUSH
110195: LD_VAR 0 1
110199: PPUSH
110200: CALL_OW 74
110204: ST_TO_ADDR
// if tmp then
110205: LD_VAR 0 5
110209: IFFALSE 110225
// ComStandNearbyBuilding ( ape , tmp ) ;
110211: LD_VAR 0 1
110215: PPUSH
110216: LD_VAR 0 5
110220: PPUSH
110221: CALL 20788 0 2
// break ;
110225: GO 110229
// end ; end ;
110227: GO 110081
110229: POP
110230: POP
// end ;
110231: LD_VAR 0 3
110235: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
110236: LD_INT 0
110238: PPUSH
110239: PPUSH
110240: PPUSH
// if not mc_bases or not skirmish then
110241: LD_EXP 178
110245: NOT
110246: PUSH
110247: LD_EXP 176
110251: NOT
110252: OR
110253: IFFALSE 110257
// exit ;
110255: GO 110346
// for i = 1 to mc_bases do
110257: LD_ADDR_VAR 0 4
110261: PUSH
110262: DOUBLE
110263: LD_INT 1
110265: DEC
110266: ST_TO_ADDR
110267: LD_EXP 178
110271: PUSH
110272: FOR_TO
110273: IFFALSE 110344
// begin if building in mc_busy_turret_list [ i ] then
110275: LD_VAR 0 1
110279: PUSH
110280: LD_EXP 188
110284: PUSH
110285: LD_VAR 0 4
110289: ARRAY
110290: IN
110291: IFFALSE 110342
// begin tmp := mc_busy_turret_list [ i ] diff building ;
110293: LD_ADDR_VAR 0 5
110297: PUSH
110298: LD_EXP 188
110302: PUSH
110303: LD_VAR 0 4
110307: ARRAY
110308: PUSH
110309: LD_VAR 0 1
110313: DIFF
110314: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
110315: LD_ADDR_EXP 188
110319: PUSH
110320: LD_EXP 188
110324: PPUSH
110325: LD_VAR 0 4
110329: PPUSH
110330: LD_VAR 0 5
110334: PPUSH
110335: CALL_OW 1
110339: ST_TO_ADDR
// break ;
110340: GO 110344
// end ; end ;
110342: GO 110272
110344: POP
110345: POP
// end ;
110346: LD_VAR 0 3
110350: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
110351: LD_INT 0
110353: PPUSH
110354: PPUSH
110355: PPUSH
// if not mc_bases or not skirmish then
110356: LD_EXP 178
110360: NOT
110361: PUSH
110362: LD_EXP 176
110366: NOT
110367: OR
110368: IFFALSE 110372
// exit ;
110370: GO 110571
// for i = 1 to mc_bases do
110372: LD_ADDR_VAR 0 5
110376: PUSH
110377: DOUBLE
110378: LD_INT 1
110380: DEC
110381: ST_TO_ADDR
110382: LD_EXP 178
110386: PUSH
110387: FOR_TO
110388: IFFALSE 110569
// if building in mc_bases [ i ] then
110390: LD_VAR 0 1
110394: PUSH
110395: LD_EXP 178
110399: PUSH
110400: LD_VAR 0 5
110404: ARRAY
110405: IN
110406: IFFALSE 110567
// begin tmp := mc_bases [ i ] diff building ;
110408: LD_ADDR_VAR 0 6
110412: PUSH
110413: LD_EXP 178
110417: PUSH
110418: LD_VAR 0 5
110422: ARRAY
110423: PUSH
110424: LD_VAR 0 1
110428: DIFF
110429: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
110430: LD_ADDR_EXP 178
110434: PUSH
110435: LD_EXP 178
110439: PPUSH
110440: LD_VAR 0 5
110444: PPUSH
110445: LD_VAR 0 6
110449: PPUSH
110450: CALL_OW 1
110454: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
110455: LD_VAR 0 1
110459: PUSH
110460: LD_EXP 186
110464: PUSH
110465: LD_VAR 0 5
110469: ARRAY
110470: IN
110471: IFFALSE 110510
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
110473: LD_ADDR_EXP 186
110477: PUSH
110478: LD_EXP 186
110482: PPUSH
110483: LD_VAR 0 5
110487: PPUSH
110488: LD_EXP 186
110492: PUSH
110493: LD_VAR 0 5
110497: ARRAY
110498: PUSH
110499: LD_VAR 0 1
110503: DIFF
110504: PPUSH
110505: CALL_OW 1
110509: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
110510: LD_VAR 0 1
110514: PUSH
110515: LD_EXP 187
110519: PUSH
110520: LD_VAR 0 5
110524: ARRAY
110525: IN
110526: IFFALSE 110565
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
110528: LD_ADDR_EXP 187
110532: PUSH
110533: LD_EXP 187
110537: PPUSH
110538: LD_VAR 0 5
110542: PPUSH
110543: LD_EXP 187
110547: PUSH
110548: LD_VAR 0 5
110552: ARRAY
110553: PUSH
110554: LD_VAR 0 1
110558: DIFF
110559: PPUSH
110560: CALL_OW 1
110564: ST_TO_ADDR
// break ;
110565: GO 110569
// end ;
110567: GO 110387
110569: POP
110570: POP
// end ;
110571: LD_VAR 0 4
110575: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
110576: LD_INT 0
110578: PPUSH
110579: PPUSH
110580: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
110581: LD_EXP 178
110585: NOT
110586: PUSH
110587: LD_EXP 176
110591: NOT
110592: OR
110593: PUSH
110594: LD_VAR 0 3
110598: PUSH
110599: LD_EXP 204
110603: IN
110604: NOT
110605: OR
110606: IFFALSE 110610
// exit ;
110608: GO 110733
// for i = 1 to mc_vehicles do
110610: LD_ADDR_VAR 0 6
110614: PUSH
110615: DOUBLE
110616: LD_INT 1
110618: DEC
110619: ST_TO_ADDR
110620: LD_EXP 197
110624: PUSH
110625: FOR_TO
110626: IFFALSE 110731
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
110628: LD_VAR 0 2
110632: PUSH
110633: LD_EXP 197
110637: PUSH
110638: LD_VAR 0 6
110642: ARRAY
110643: IN
110644: PUSH
110645: LD_VAR 0 1
110649: PUSH
110650: LD_EXP 197
110654: PUSH
110655: LD_VAR 0 6
110659: ARRAY
110660: IN
110661: OR
110662: IFFALSE 110729
// begin tmp := mc_vehicles [ i ] diff old ;
110664: LD_ADDR_VAR 0 7
110668: PUSH
110669: LD_EXP 197
110673: PUSH
110674: LD_VAR 0 6
110678: ARRAY
110679: PUSH
110680: LD_VAR 0 2
110684: DIFF
110685: ST_TO_ADDR
// tmp := tmp diff new ;
110686: LD_ADDR_VAR 0 7
110690: PUSH
110691: LD_VAR 0 7
110695: PUSH
110696: LD_VAR 0 1
110700: DIFF
110701: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
110702: LD_ADDR_EXP 197
110706: PUSH
110707: LD_EXP 197
110711: PPUSH
110712: LD_VAR 0 6
110716: PPUSH
110717: LD_VAR 0 7
110721: PPUSH
110722: CALL_OW 1
110726: ST_TO_ADDR
// break ;
110727: GO 110731
// end ;
110729: GO 110625
110731: POP
110732: POP
// end ;
110733: LD_VAR 0 5
110737: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
110738: LD_INT 0
110740: PPUSH
110741: PPUSH
110742: PPUSH
110743: PPUSH
// if not mc_bases or not skirmish then
110744: LD_EXP 178
110748: NOT
110749: PUSH
110750: LD_EXP 176
110754: NOT
110755: OR
110756: IFFALSE 110760
// exit ;
110758: GO 111152
// side := GetSide ( vehicle ) ;
110760: LD_ADDR_VAR 0 5
110764: PUSH
110765: LD_VAR 0 1
110769: PPUSH
110770: CALL_OW 255
110774: ST_TO_ADDR
// for i = 1 to mc_bases do
110775: LD_ADDR_VAR 0 4
110779: PUSH
110780: DOUBLE
110781: LD_INT 1
110783: DEC
110784: ST_TO_ADDR
110785: LD_EXP 178
110789: PUSH
110790: FOR_TO
110791: IFFALSE 111150
// begin if factory in mc_bases [ i ] then
110793: LD_VAR 0 2
110797: PUSH
110798: LD_EXP 178
110802: PUSH
110803: LD_VAR 0 4
110807: ARRAY
110808: IN
110809: IFFALSE 111148
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ar_crane , ru_siberium_rocket , us_siberium_rocket ] then
110811: LD_EXP 200
110815: PUSH
110816: LD_VAR 0 4
110820: ARRAY
110821: PUSH
110822: LD_EXP 189
110826: PUSH
110827: LD_VAR 0 4
110831: ARRAY
110832: LESS
110833: PUSH
110834: LD_VAR 0 1
110838: PPUSH
110839: CALL_OW 264
110843: PUSH
110844: LD_INT 31
110846: PUSH
110847: LD_INT 32
110849: PUSH
110850: LD_INT 51
110852: PUSH
110853: LD_EXP 158
110857: PUSH
110858: LD_INT 12
110860: PUSH
110861: LD_INT 30
110863: PUSH
110864: LD_EXP 157
110868: PUSH
110869: LD_INT 11
110871: PUSH
110872: LD_INT 53
110874: PUSH
110875: LD_INT 14
110877: PUSH
110878: LD_EXP 161
110882: PUSH
110883: LD_INT 29
110885: PUSH
110886: LD_EXP 159
110890: PUSH
110891: LD_INT 13
110893: PUSH
110894: LD_INT 52
110896: PUSH
110897: LD_EXP 163
110901: PUSH
110902: LD_INT 48
110904: PUSH
110905: LD_INT 8
110907: PUSH
110908: EMPTY
110909: LIST
110910: LIST
110911: LIST
110912: LIST
110913: LIST
110914: LIST
110915: LIST
110916: LIST
110917: LIST
110918: LIST
110919: LIST
110920: LIST
110921: LIST
110922: LIST
110923: LIST
110924: LIST
110925: LIST
110926: LIST
110927: IN
110928: NOT
110929: AND
110930: IFFALSE 110978
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
110932: LD_ADDR_EXP 200
110936: PUSH
110937: LD_EXP 200
110941: PPUSH
110942: LD_VAR 0 4
110946: PUSH
110947: LD_EXP 200
110951: PUSH
110952: LD_VAR 0 4
110956: ARRAY
110957: PUSH
110958: LD_INT 1
110960: PLUS
110961: PUSH
110962: EMPTY
110963: LIST
110964: LIST
110965: PPUSH
110966: LD_VAR 0 1
110970: PPUSH
110971: CALL 24210 0 3
110975: ST_TO_ADDR
110976: GO 111022
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
110978: LD_ADDR_EXP 197
110982: PUSH
110983: LD_EXP 197
110987: PPUSH
110988: LD_VAR 0 4
110992: PUSH
110993: LD_EXP 197
110997: PUSH
110998: LD_VAR 0 4
111002: ARRAY
111003: PUSH
111004: LD_INT 1
111006: PLUS
111007: PUSH
111008: EMPTY
111009: LIST
111010: LIST
111011: PPUSH
111012: LD_VAR 0 1
111016: PPUSH
111017: CALL 24210 0 3
111021: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
111022: LD_VAR 0 1
111026: PPUSH
111027: CALL_OW 263
111031: PUSH
111032: LD_INT 2
111034: EQUAL
111035: IFFALSE 111064
// begin repeat wait ( 0 0$3 ) ;
111037: LD_INT 105
111039: PPUSH
111040: CALL_OW 67
// Connect ( vehicle ) ;
111044: LD_VAR 0 1
111048: PPUSH
111049: CALL 27181 0 1
// until IsControledBy ( vehicle ) ;
111053: LD_VAR 0 1
111057: PPUSH
111058: CALL_OW 312
111062: IFFALSE 111037
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
111064: LD_VAR 0 1
111068: PPUSH
111069: LD_EXP 202
111073: PUSH
111074: LD_VAR 0 4
111078: ARRAY
111079: PPUSH
111080: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
111084: LD_VAR 0 1
111088: PPUSH
111089: CALL_OW 263
111093: PUSH
111094: LD_INT 1
111096: NONEQUAL
111097: IFFALSE 111101
// break ;
111099: GO 111150
// repeat wait ( 0 0$1 ) ;
111101: LD_INT 35
111103: PPUSH
111104: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
111108: LD_VAR 0 1
111112: PPUSH
111113: LD_EXP 202
111117: PUSH
111118: LD_VAR 0 4
111122: ARRAY
111123: PPUSH
111124: CALL_OW 308
111128: IFFALSE 111101
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
111130: LD_VAR 0 1
111134: PPUSH
111135: CALL_OW 311
111139: PPUSH
111140: CALL_OW 121
// exit ;
111144: POP
111145: POP
111146: GO 111152
// end ; end ;
111148: GO 110790
111150: POP
111151: POP
// end ;
111152: LD_VAR 0 3
111156: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
111157: LD_INT 0
111159: PPUSH
111160: PPUSH
111161: PPUSH
111162: PPUSH
// if not mc_bases or not skirmish then
111163: LD_EXP 178
111167: NOT
111168: PUSH
111169: LD_EXP 176
111173: NOT
111174: OR
111175: IFFALSE 111179
// exit ;
111177: GO 111532
// repeat wait ( 0 0$1 ) ;
111179: LD_INT 35
111181: PPUSH
111182: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
111186: LD_VAR 0 2
111190: PPUSH
111191: LD_VAR 0 3
111195: PPUSH
111196: CALL_OW 284
111200: IFFALSE 111179
// if GetResourceTypeXY ( x , y ) = mat_artefact then
111202: LD_VAR 0 2
111206: PPUSH
111207: LD_VAR 0 3
111211: PPUSH
111212: CALL_OW 283
111216: PUSH
111217: LD_INT 4
111219: EQUAL
111220: IFFALSE 111224
// exit ;
111222: GO 111532
// for i = 1 to mc_bases do
111224: LD_ADDR_VAR 0 7
111228: PUSH
111229: DOUBLE
111230: LD_INT 1
111232: DEC
111233: ST_TO_ADDR
111234: LD_EXP 178
111238: PUSH
111239: FOR_TO
111240: IFFALSE 111530
// begin if mc_crates_area [ i ] then
111242: LD_EXP 196
111246: PUSH
111247: LD_VAR 0 7
111251: ARRAY
111252: IFFALSE 111363
// for j in mc_crates_area [ i ] do
111254: LD_ADDR_VAR 0 8
111258: PUSH
111259: LD_EXP 196
111263: PUSH
111264: LD_VAR 0 7
111268: ARRAY
111269: PUSH
111270: FOR_IN
111271: IFFALSE 111361
// if InArea ( x , y , j ) then
111273: LD_VAR 0 2
111277: PPUSH
111278: LD_VAR 0 3
111282: PPUSH
111283: LD_VAR 0 8
111287: PPUSH
111288: CALL_OW 309
111292: IFFALSE 111359
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
111294: LD_ADDR_EXP 194
111298: PUSH
111299: LD_EXP 194
111303: PPUSH
111304: LD_VAR 0 7
111308: PUSH
111309: LD_EXP 194
111313: PUSH
111314: LD_VAR 0 7
111318: ARRAY
111319: PUSH
111320: LD_INT 1
111322: PLUS
111323: PUSH
111324: EMPTY
111325: LIST
111326: LIST
111327: PPUSH
111328: LD_VAR 0 4
111332: PUSH
111333: LD_VAR 0 2
111337: PUSH
111338: LD_VAR 0 3
111342: PUSH
111343: EMPTY
111344: LIST
111345: LIST
111346: LIST
111347: PPUSH
111348: CALL 24210 0 3
111352: ST_TO_ADDR
// exit ;
111353: POP
111354: POP
111355: POP
111356: POP
111357: GO 111532
// end ;
111359: GO 111270
111361: POP
111362: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
111363: LD_ADDR_VAR 0 9
111367: PUSH
111368: LD_EXP 178
111372: PUSH
111373: LD_VAR 0 7
111377: ARRAY
111378: PPUSH
111379: LD_INT 2
111381: PUSH
111382: LD_INT 30
111384: PUSH
111385: LD_INT 0
111387: PUSH
111388: EMPTY
111389: LIST
111390: LIST
111391: PUSH
111392: LD_INT 30
111394: PUSH
111395: LD_INT 1
111397: PUSH
111398: EMPTY
111399: LIST
111400: LIST
111401: PUSH
111402: EMPTY
111403: LIST
111404: LIST
111405: LIST
111406: PPUSH
111407: CALL_OW 72
111411: ST_TO_ADDR
// if not depot then
111412: LD_VAR 0 9
111416: NOT
111417: IFFALSE 111421
// continue ;
111419: GO 111239
// for j in depot do
111421: LD_ADDR_VAR 0 8
111425: PUSH
111426: LD_VAR 0 9
111430: PUSH
111431: FOR_IN
111432: IFFALSE 111526
// if GetDistUnitXY ( j , x , y ) < 30 then
111434: LD_VAR 0 8
111438: PPUSH
111439: LD_VAR 0 2
111443: PPUSH
111444: LD_VAR 0 3
111448: PPUSH
111449: CALL_OW 297
111453: PUSH
111454: LD_INT 30
111456: LESS
111457: IFFALSE 111524
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
111459: LD_ADDR_EXP 194
111463: PUSH
111464: LD_EXP 194
111468: PPUSH
111469: LD_VAR 0 7
111473: PUSH
111474: LD_EXP 194
111478: PUSH
111479: LD_VAR 0 7
111483: ARRAY
111484: PUSH
111485: LD_INT 1
111487: PLUS
111488: PUSH
111489: EMPTY
111490: LIST
111491: LIST
111492: PPUSH
111493: LD_VAR 0 4
111497: PUSH
111498: LD_VAR 0 2
111502: PUSH
111503: LD_VAR 0 3
111507: PUSH
111508: EMPTY
111509: LIST
111510: LIST
111511: LIST
111512: PPUSH
111513: CALL 24210 0 3
111517: ST_TO_ADDR
// exit ;
111518: POP
111519: POP
111520: POP
111521: POP
111522: GO 111532
// end ;
111524: GO 111431
111526: POP
111527: POP
// end ;
111528: GO 111239
111530: POP
111531: POP
// end ;
111532: LD_VAR 0 6
111536: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
111537: LD_INT 0
111539: PPUSH
111540: PPUSH
111541: PPUSH
111542: PPUSH
// if not mc_bases or not skirmish then
111543: LD_EXP 178
111547: NOT
111548: PUSH
111549: LD_EXP 176
111553: NOT
111554: OR
111555: IFFALSE 111559
// exit ;
111557: GO 111836
// side := GetSide ( lab ) ;
111559: LD_ADDR_VAR 0 4
111563: PUSH
111564: LD_VAR 0 2
111568: PPUSH
111569: CALL_OW 255
111573: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
111574: LD_VAR 0 4
111578: PUSH
111579: LD_EXP 204
111583: IN
111584: NOT
111585: PUSH
111586: LD_EXP 205
111590: NOT
111591: OR
111592: PUSH
111593: LD_EXP 178
111597: NOT
111598: OR
111599: IFFALSE 111603
// exit ;
111601: GO 111836
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
111603: LD_ADDR_EXP 205
111607: PUSH
111608: LD_EXP 205
111612: PPUSH
111613: LD_VAR 0 4
111617: PPUSH
111618: LD_EXP 205
111622: PUSH
111623: LD_VAR 0 4
111627: ARRAY
111628: PUSH
111629: LD_VAR 0 1
111633: DIFF
111634: PPUSH
111635: CALL_OW 1
111639: ST_TO_ADDR
// for i = 1 to mc_bases do
111640: LD_ADDR_VAR 0 5
111644: PUSH
111645: DOUBLE
111646: LD_INT 1
111648: DEC
111649: ST_TO_ADDR
111650: LD_EXP 178
111654: PUSH
111655: FOR_TO
111656: IFFALSE 111834
// begin if lab in mc_bases [ i ] then
111658: LD_VAR 0 2
111662: PUSH
111663: LD_EXP 178
111667: PUSH
111668: LD_VAR 0 5
111672: ARRAY
111673: IN
111674: IFFALSE 111832
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
111676: LD_VAR 0 1
111680: PUSH
111681: LD_INT 11
111683: PUSH
111684: LD_INT 4
111686: PUSH
111687: LD_INT 3
111689: PUSH
111690: LD_INT 2
111692: PUSH
111693: EMPTY
111694: LIST
111695: LIST
111696: LIST
111697: LIST
111698: IN
111699: PUSH
111700: LD_EXP 208
111704: PUSH
111705: LD_VAR 0 5
111709: ARRAY
111710: AND
111711: IFFALSE 111832
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
111713: LD_ADDR_VAR 0 6
111717: PUSH
111718: LD_EXP 208
111722: PUSH
111723: LD_VAR 0 5
111727: ARRAY
111728: PUSH
111729: LD_INT 1
111731: ARRAY
111732: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
111733: LD_ADDR_EXP 208
111737: PUSH
111738: LD_EXP 208
111742: PPUSH
111743: LD_VAR 0 5
111747: PPUSH
111748: EMPTY
111749: PPUSH
111750: CALL_OW 1
111754: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
111755: LD_VAR 0 6
111759: PPUSH
111760: LD_INT 0
111762: PPUSH
111763: CALL_OW 109
// ComExitBuilding ( tmp ) ;
111767: LD_VAR 0 6
111771: PPUSH
111772: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
111776: LD_ADDR_EXP 207
111780: PUSH
111781: LD_EXP 207
111785: PPUSH
111786: LD_VAR 0 5
111790: PPUSH
111791: LD_EXP 207
111795: PUSH
111796: LD_VAR 0 5
111800: ARRAY
111801: PPUSH
111802: LD_INT 1
111804: PPUSH
111805: LD_VAR 0 6
111809: PPUSH
111810: CALL_OW 2
111814: PPUSH
111815: CALL_OW 1
111819: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
111820: LD_VAR 0 5
111824: PPUSH
111825: LD_INT 112
111827: PPUSH
111828: CALL 88355 0 2
// end ; end ; end ;
111832: GO 111655
111834: POP
111835: POP
// end ;
111836: LD_VAR 0 3
111840: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
111841: LD_INT 0
111843: PPUSH
111844: PPUSH
111845: PPUSH
111846: PPUSH
111847: PPUSH
111848: PPUSH
111849: PPUSH
111850: PPUSH
// if not mc_bases or not skirmish then
111851: LD_EXP 178
111855: NOT
111856: PUSH
111857: LD_EXP 176
111861: NOT
111862: OR
111863: IFFALSE 111867
// exit ;
111865: GO 113238
// for i = 1 to mc_bases do
111867: LD_ADDR_VAR 0 3
111871: PUSH
111872: DOUBLE
111873: LD_INT 1
111875: DEC
111876: ST_TO_ADDR
111877: LD_EXP 178
111881: PUSH
111882: FOR_TO
111883: IFFALSE 113236
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
111885: LD_VAR 0 1
111889: PUSH
111890: LD_EXP 178
111894: PUSH
111895: LD_VAR 0 3
111899: ARRAY
111900: IN
111901: PUSH
111902: LD_VAR 0 1
111906: PUSH
111907: LD_EXP 185
111911: PUSH
111912: LD_VAR 0 3
111916: ARRAY
111917: IN
111918: OR
111919: PUSH
111920: LD_VAR 0 1
111924: PUSH
111925: LD_EXP 200
111929: PUSH
111930: LD_VAR 0 3
111934: ARRAY
111935: IN
111936: OR
111937: PUSH
111938: LD_VAR 0 1
111942: PUSH
111943: LD_EXP 197
111947: PUSH
111948: LD_VAR 0 3
111952: ARRAY
111953: IN
111954: OR
111955: PUSH
111956: LD_VAR 0 1
111960: PUSH
111961: LD_EXP 207
111965: PUSH
111966: LD_VAR 0 3
111970: ARRAY
111971: IN
111972: OR
111973: PUSH
111974: LD_VAR 0 1
111978: PUSH
111979: LD_EXP 208
111983: PUSH
111984: LD_VAR 0 3
111988: ARRAY
111989: IN
111990: OR
111991: IFFALSE 113234
// begin if un in mc_ape [ i ] then
111993: LD_VAR 0 1
111997: PUSH
111998: LD_EXP 207
112002: PUSH
112003: LD_VAR 0 3
112007: ARRAY
112008: IN
112009: IFFALSE 112048
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
112011: LD_ADDR_EXP 207
112015: PUSH
112016: LD_EXP 207
112020: PPUSH
112021: LD_VAR 0 3
112025: PPUSH
112026: LD_EXP 207
112030: PUSH
112031: LD_VAR 0 3
112035: ARRAY
112036: PUSH
112037: LD_VAR 0 1
112041: DIFF
112042: PPUSH
112043: CALL_OW 1
112047: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
112048: LD_VAR 0 1
112052: PUSH
112053: LD_EXP 208
112057: PUSH
112058: LD_VAR 0 3
112062: ARRAY
112063: IN
112064: IFFALSE 112088
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
112066: LD_ADDR_EXP 208
112070: PUSH
112071: LD_EXP 208
112075: PPUSH
112076: LD_VAR 0 3
112080: PPUSH
112081: EMPTY
112082: PPUSH
112083: CALL_OW 1
112087: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane , ar_control_tower ] ) then
112088: LD_VAR 0 1
112092: PPUSH
112093: CALL_OW 247
112097: PUSH
112098: LD_INT 2
112100: EQUAL
112101: PUSH
112102: LD_VAR 0 1
112106: PPUSH
112107: CALL_OW 110
112111: PUSH
112112: LD_INT 20
112114: EQUAL
112115: PUSH
112116: LD_VAR 0 1
112120: PUSH
112121: LD_EXP 200
112125: PUSH
112126: LD_VAR 0 3
112130: ARRAY
112131: IN
112132: OR
112133: PUSH
112134: LD_VAR 0 1
112138: PPUSH
112139: CALL_OW 264
112143: PUSH
112144: LD_INT 12
112146: PUSH
112147: LD_INT 51
112149: PUSH
112150: LD_EXP 158
112154: PUSH
112155: LD_INT 32
112157: PUSH
112158: LD_INT 13
112160: PUSH
112161: LD_INT 52
112163: PUSH
112164: LD_INT 31
112166: PUSH
112167: EMPTY
112168: LIST
112169: LIST
112170: LIST
112171: LIST
112172: LIST
112173: LIST
112174: LIST
112175: IN
112176: OR
112177: AND
112178: IFFALSE 112486
// begin if un in mc_defender [ i ] then
112180: LD_VAR 0 1
112184: PUSH
112185: LD_EXP 200
112189: PUSH
112190: LD_VAR 0 3
112194: ARRAY
112195: IN
112196: IFFALSE 112235
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
112198: LD_ADDR_EXP 200
112202: PUSH
112203: LD_EXP 200
112207: PPUSH
112208: LD_VAR 0 3
112212: PPUSH
112213: LD_EXP 200
112217: PUSH
112218: LD_VAR 0 3
112222: ARRAY
112223: PUSH
112224: LD_VAR 0 1
112228: DIFF
112229: PPUSH
112230: CALL_OW 1
112234: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
112235: LD_ADDR_VAR 0 8
112239: PUSH
112240: LD_VAR 0 3
112244: PPUSH
112245: LD_INT 3
112247: PPUSH
112248: CALL 108876 0 2
112252: ST_TO_ADDR
// if fac then
112253: LD_VAR 0 8
112257: IFFALSE 112486
// begin for j in fac do
112259: LD_ADDR_VAR 0 4
112263: PUSH
112264: LD_VAR 0 8
112268: PUSH
112269: FOR_IN
112270: IFFALSE 112484
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
112272: LD_ADDR_VAR 0 9
112276: PUSH
112277: LD_VAR 0 8
112281: PPUSH
112282: LD_VAR 0 1
112286: PPUSH
112287: CALL_OW 265
112291: PPUSH
112292: LD_VAR 0 1
112296: PPUSH
112297: CALL_OW 262
112301: PPUSH
112302: LD_VAR 0 1
112306: PPUSH
112307: CALL_OW 263
112311: PPUSH
112312: LD_VAR 0 1
112316: PPUSH
112317: CALL_OW 264
112321: PPUSH
112322: CALL 21706 0 5
112326: ST_TO_ADDR
// if components then
112327: LD_VAR 0 9
112331: IFFALSE 112482
// begin if GetWeapon ( un ) = ar_control_tower then
112333: LD_VAR 0 1
112337: PPUSH
112338: CALL_OW 264
112342: PUSH
112343: LD_INT 31
112345: EQUAL
112346: IFFALSE 112463
// begin SetTag ( IsDrivenBy ( un ) , 0 ) ;
112348: LD_VAR 0 1
112352: PPUSH
112353: CALL_OW 311
112357: PPUSH
112358: LD_INT 0
112360: PPUSH
112361: CALL_OW 109
// mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff IsDrivenBy ( un ) ) ;
112365: LD_ADDR_EXP 218
112369: PUSH
112370: LD_EXP 218
112374: PPUSH
112375: LD_VAR 0 3
112379: PPUSH
112380: LD_EXP 218
112384: PUSH
112385: LD_VAR 0 3
112389: ARRAY
112390: PUSH
112391: LD_VAR 0 1
112395: PPUSH
112396: CALL_OW 311
112400: DIFF
112401: PPUSH
112402: CALL_OW 1
112406: ST_TO_ADDR
// tmp := Insert ( mc_produce [ i ] , 1 , components ) ;
112407: LD_ADDR_VAR 0 7
112411: PUSH
112412: LD_EXP 199
112416: PUSH
112417: LD_VAR 0 3
112421: ARRAY
112422: PPUSH
112423: LD_INT 1
112425: PPUSH
112426: LD_VAR 0 9
112430: PPUSH
112431: CALL_OW 2
112435: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
112436: LD_ADDR_EXP 199
112440: PUSH
112441: LD_EXP 199
112445: PPUSH
112446: LD_VAR 0 3
112450: PPUSH
112451: LD_VAR 0 7
112455: PPUSH
112456: CALL_OW 1
112460: ST_TO_ADDR
// end else
112461: GO 112480
// MC_InsertProduceList ( i , [ components ] ) ;
112463: LD_VAR 0 3
112467: PPUSH
112468: LD_VAR 0 9
112472: PUSH
112473: EMPTY
112474: LIST
112475: PPUSH
112476: CALL 108421 0 2
// break ;
112480: GO 112484
// end ; end ;
112482: GO 112269
112484: POP
112485: POP
// end ; end ; if GetType ( un ) = unit_building then
112486: LD_VAR 0 1
112490: PPUSH
112491: CALL_OW 247
112495: PUSH
112496: LD_INT 3
112498: EQUAL
112499: IFFALSE 112902
// begin btype := GetBType ( un ) ;
112501: LD_ADDR_VAR 0 5
112505: PUSH
112506: LD_VAR 0 1
112510: PPUSH
112511: CALL_OW 266
112515: ST_TO_ADDR
// if btype in [ b_oil_mine , b_siberite_mine ] then
112516: LD_VAR 0 5
112520: PUSH
112521: LD_INT 29
112523: PUSH
112524: LD_INT 30
112526: PUSH
112527: EMPTY
112528: LIST
112529: LIST
112530: IN
112531: IFFALSE 112604
// begin if not GetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) then
112533: LD_VAR 0 1
112537: PPUSH
112538: CALL_OW 250
112542: PPUSH
112543: LD_VAR 0 1
112547: PPUSH
112548: CALL_OW 251
112552: PPUSH
112553: LD_VAR 0 1
112557: PPUSH
112558: CALL_OW 255
112562: PPUSH
112563: CALL_OW 440
112567: NOT
112568: IFFALSE 112604
// SetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) ;
112570: LD_VAR 0 1
112574: PPUSH
112575: CALL_OW 250
112579: PPUSH
112580: LD_VAR 0 1
112584: PPUSH
112585: CALL_OW 251
112589: PPUSH
112590: LD_VAR 0 1
112594: PPUSH
112595: CALL_OW 255
112599: PPUSH
112600: CALL_OW 441
// end ; if btype = b_warehouse then
112604: LD_VAR 0 5
112608: PUSH
112609: LD_INT 1
112611: EQUAL
112612: IFFALSE 112630
// begin btype := b_depot ;
112614: LD_ADDR_VAR 0 5
112618: PUSH
112619: LD_INT 0
112621: ST_TO_ADDR
// pos := 1 ;
112622: LD_ADDR_VAR 0 6
112626: PUSH
112627: LD_INT 1
112629: ST_TO_ADDR
// end ; if btype = b_factory then
112630: LD_VAR 0 5
112634: PUSH
112635: LD_INT 3
112637: EQUAL
112638: IFFALSE 112656
// begin btype := b_workshop ;
112640: LD_ADDR_VAR 0 5
112644: PUSH
112645: LD_INT 2
112647: ST_TO_ADDR
// pos := 1 ;
112648: LD_ADDR_VAR 0 6
112652: PUSH
112653: LD_INT 1
112655: ST_TO_ADDR
// end ; if btype = b_barracks then
112656: LD_VAR 0 5
112660: PUSH
112661: LD_INT 5
112663: EQUAL
112664: IFFALSE 112674
// btype := b_armoury ;
112666: LD_ADDR_VAR 0 5
112670: PUSH
112671: LD_INT 4
112673: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
112674: LD_VAR 0 5
112678: PUSH
112679: LD_INT 7
112681: PUSH
112682: LD_INT 8
112684: PUSH
112685: EMPTY
112686: LIST
112687: LIST
112688: IN
112689: IFFALSE 112699
// btype := b_lab ;
112691: LD_ADDR_VAR 0 5
112695: PUSH
112696: LD_INT 6
112698: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
112699: LD_ADDR_EXP 183
112703: PUSH
112704: LD_EXP 183
112708: PPUSH
112709: LD_VAR 0 3
112713: PUSH
112714: LD_EXP 183
112718: PUSH
112719: LD_VAR 0 3
112723: ARRAY
112724: PUSH
112725: LD_INT 1
112727: PLUS
112728: PUSH
112729: EMPTY
112730: LIST
112731: LIST
112732: PPUSH
112733: LD_VAR 0 5
112737: PUSH
112738: LD_VAR 0 1
112742: PPUSH
112743: CALL_OW 250
112747: PUSH
112748: LD_VAR 0 1
112752: PPUSH
112753: CALL_OW 251
112757: PUSH
112758: LD_VAR 0 1
112762: PPUSH
112763: CALL_OW 254
112767: PUSH
112768: EMPTY
112769: LIST
112770: LIST
112771: LIST
112772: LIST
112773: PPUSH
112774: CALL 24210 0 3
112778: ST_TO_ADDR
// if pos = 1 then
112779: LD_VAR 0 6
112783: PUSH
112784: LD_INT 1
112786: EQUAL
112787: IFFALSE 112902
// begin tmp := mc_build_list [ i ] ;
112789: LD_ADDR_VAR 0 7
112793: PUSH
112794: LD_EXP 183
112798: PUSH
112799: LD_VAR 0 3
112803: ARRAY
112804: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
112805: LD_VAR 0 7
112809: PPUSH
112810: LD_INT 2
112812: PUSH
112813: LD_INT 30
112815: PUSH
112816: LD_INT 0
112818: PUSH
112819: EMPTY
112820: LIST
112821: LIST
112822: PUSH
112823: LD_INT 30
112825: PUSH
112826: LD_INT 1
112828: PUSH
112829: EMPTY
112830: LIST
112831: LIST
112832: PUSH
112833: EMPTY
112834: LIST
112835: LIST
112836: LIST
112837: PPUSH
112838: CALL_OW 72
112842: IFFALSE 112852
// pos := 2 ;
112844: LD_ADDR_VAR 0 6
112848: PUSH
112849: LD_INT 2
112851: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
112852: LD_ADDR_VAR 0 7
112856: PUSH
112857: LD_VAR 0 7
112861: PPUSH
112862: LD_VAR 0 6
112866: PPUSH
112867: LD_VAR 0 7
112871: PPUSH
112872: CALL 24536 0 3
112876: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
112877: LD_ADDR_EXP 183
112881: PUSH
112882: LD_EXP 183
112886: PPUSH
112887: LD_VAR 0 3
112891: PPUSH
112892: LD_VAR 0 7
112896: PPUSH
112897: CALL_OW 1
112901: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
112902: LD_VAR 0 1
112906: PUSH
112907: LD_EXP 178
112911: PUSH
112912: LD_VAR 0 3
112916: ARRAY
112917: IN
112918: IFFALSE 112957
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
112920: LD_ADDR_EXP 178
112924: PUSH
112925: LD_EXP 178
112929: PPUSH
112930: LD_VAR 0 3
112934: PPUSH
112935: LD_EXP 178
112939: PUSH
112940: LD_VAR 0 3
112944: ARRAY
112945: PUSH
112946: LD_VAR 0 1
112950: DIFF
112951: PPUSH
112952: CALL_OW 1
112956: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
112957: LD_VAR 0 1
112961: PUSH
112962: LD_EXP 185
112966: PUSH
112967: LD_VAR 0 3
112971: ARRAY
112972: IN
112973: IFFALSE 113012
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
112975: LD_ADDR_EXP 185
112979: PUSH
112980: LD_EXP 185
112984: PPUSH
112985: LD_VAR 0 3
112989: PPUSH
112990: LD_EXP 185
112994: PUSH
112995: LD_VAR 0 3
112999: ARRAY
113000: PUSH
113001: LD_VAR 0 1
113005: DIFF
113006: PPUSH
113007: CALL_OW 1
113011: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
113012: LD_VAR 0 1
113016: PUSH
113017: LD_EXP 197
113021: PUSH
113022: LD_VAR 0 3
113026: ARRAY
113027: IN
113028: IFFALSE 113067
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
113030: LD_ADDR_EXP 197
113034: PUSH
113035: LD_EXP 197
113039: PPUSH
113040: LD_VAR 0 3
113044: PPUSH
113045: LD_EXP 197
113049: PUSH
113050: LD_VAR 0 3
113054: ARRAY
113055: PUSH
113056: LD_VAR 0 1
113060: DIFF
113061: PPUSH
113062: CALL_OW 1
113066: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
113067: LD_VAR 0 1
113071: PUSH
113072: LD_EXP 200
113076: PUSH
113077: LD_VAR 0 3
113081: ARRAY
113082: IN
113083: IFFALSE 113122
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
113085: LD_ADDR_EXP 200
113089: PUSH
113090: LD_EXP 200
113094: PPUSH
113095: LD_VAR 0 3
113099: PPUSH
113100: LD_EXP 200
113104: PUSH
113105: LD_VAR 0 3
113109: ARRAY
113110: PUSH
113111: LD_VAR 0 1
113115: DIFF
113116: PPUSH
113117: CALL_OW 1
113121: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
113122: LD_VAR 0 1
113126: PUSH
113127: LD_EXP 187
113131: PUSH
113132: LD_VAR 0 3
113136: ARRAY
113137: IN
113138: IFFALSE 113177
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
113140: LD_ADDR_EXP 187
113144: PUSH
113145: LD_EXP 187
113149: PPUSH
113150: LD_VAR 0 3
113154: PPUSH
113155: LD_EXP 187
113159: PUSH
113160: LD_VAR 0 3
113164: ARRAY
113165: PUSH
113166: LD_VAR 0 1
113170: DIFF
113171: PPUSH
113172: CALL_OW 1
113176: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
113177: LD_VAR 0 1
113181: PUSH
113182: LD_EXP 186
113186: PUSH
113187: LD_VAR 0 3
113191: ARRAY
113192: IN
113193: IFFALSE 113232
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
113195: LD_ADDR_EXP 186
113199: PUSH
113200: LD_EXP 186
113204: PPUSH
113205: LD_VAR 0 3
113209: PPUSH
113210: LD_EXP 186
113214: PUSH
113215: LD_VAR 0 3
113219: ARRAY
113220: PUSH
113221: LD_VAR 0 1
113225: DIFF
113226: PPUSH
113227: CALL_OW 1
113231: ST_TO_ADDR
// end ; break ;
113232: GO 113236
// end ;
113234: GO 111882
113236: POP
113237: POP
// end ;
113238: LD_VAR 0 2
113242: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
113243: LD_INT 0
113245: PPUSH
113246: PPUSH
113247: PPUSH
// if not mc_bases or not skirmish then
113248: LD_EXP 178
113252: NOT
113253: PUSH
113254: LD_EXP 176
113258: NOT
113259: OR
113260: IFFALSE 113264
// exit ;
113262: GO 113479
// for i = 1 to mc_bases do
113264: LD_ADDR_VAR 0 3
113268: PUSH
113269: DOUBLE
113270: LD_INT 1
113272: DEC
113273: ST_TO_ADDR
113274: LD_EXP 178
113278: PUSH
113279: FOR_TO
113280: IFFALSE 113477
// begin if building in mc_construct_list [ i ] then
113282: LD_VAR 0 1
113286: PUSH
113287: LD_EXP 185
113291: PUSH
113292: LD_VAR 0 3
113296: ARRAY
113297: IN
113298: IFFALSE 113475
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
113300: LD_ADDR_EXP 185
113304: PUSH
113305: LD_EXP 185
113309: PPUSH
113310: LD_VAR 0 3
113314: PPUSH
113315: LD_EXP 185
113319: PUSH
113320: LD_VAR 0 3
113324: ARRAY
113325: PUSH
113326: LD_VAR 0 1
113330: DIFF
113331: PPUSH
113332: CALL_OW 1
113336: ST_TO_ADDR
// if building in mc_lab [ i ] then
113337: LD_VAR 0 1
113341: PUSH
113342: LD_EXP 211
113346: PUSH
113347: LD_VAR 0 3
113351: ARRAY
113352: IN
113353: IFFALSE 113408
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
113355: LD_ADDR_EXP 212
113359: PUSH
113360: LD_EXP 212
113364: PPUSH
113365: LD_VAR 0 3
113369: PPUSH
113370: LD_EXP 212
113374: PUSH
113375: LD_VAR 0 3
113379: ARRAY
113380: PPUSH
113381: LD_INT 1
113383: PPUSH
113384: LD_EXP 212
113388: PUSH
113389: LD_VAR 0 3
113393: ARRAY
113394: PPUSH
113395: LD_INT 0
113397: PPUSH
113398: CALL 23628 0 4
113402: PPUSH
113403: CALL_OW 1
113407: ST_TO_ADDR
// if not building in mc_bases [ i ] then
113408: LD_VAR 0 1
113412: PUSH
113413: LD_EXP 178
113417: PUSH
113418: LD_VAR 0 3
113422: ARRAY
113423: IN
113424: NOT
113425: IFFALSE 113471
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
113427: LD_ADDR_EXP 178
113431: PUSH
113432: LD_EXP 178
113436: PPUSH
113437: LD_VAR 0 3
113441: PUSH
113442: LD_EXP 178
113446: PUSH
113447: LD_VAR 0 3
113451: ARRAY
113452: PUSH
113453: LD_INT 1
113455: PLUS
113456: PUSH
113457: EMPTY
113458: LIST
113459: LIST
113460: PPUSH
113461: LD_VAR 0 1
113465: PPUSH
113466: CALL 24210 0 3
113470: ST_TO_ADDR
// exit ;
113471: POP
113472: POP
113473: GO 113479
// end ; end ;
113475: GO 113279
113477: POP
113478: POP
// end ;
113479: LD_VAR 0 2
113483: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
113484: LD_INT 0
113486: PPUSH
113487: PPUSH
113488: PPUSH
113489: PPUSH
113490: PPUSH
113491: PPUSH
113492: PPUSH
// if not mc_bases or not skirmish then
113493: LD_EXP 178
113497: NOT
113498: PUSH
113499: LD_EXP 176
113503: NOT
113504: OR
113505: IFFALSE 113509
// exit ;
113507: GO 114170
// for i = 1 to mc_bases do
113509: LD_ADDR_VAR 0 3
113513: PUSH
113514: DOUBLE
113515: LD_INT 1
113517: DEC
113518: ST_TO_ADDR
113519: LD_EXP 178
113523: PUSH
113524: FOR_TO
113525: IFFALSE 114168
// begin if building in mc_construct_list [ i ] then
113527: LD_VAR 0 1
113531: PUSH
113532: LD_EXP 185
113536: PUSH
113537: LD_VAR 0 3
113541: ARRAY
113542: IN
113543: IFFALSE 114166
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
113545: LD_ADDR_EXP 185
113549: PUSH
113550: LD_EXP 185
113554: PPUSH
113555: LD_VAR 0 3
113559: PPUSH
113560: LD_EXP 185
113564: PUSH
113565: LD_VAR 0 3
113569: ARRAY
113570: PUSH
113571: LD_VAR 0 1
113575: DIFF
113576: PPUSH
113577: CALL_OW 1
113581: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
113582: LD_ADDR_EXP 178
113586: PUSH
113587: LD_EXP 178
113591: PPUSH
113592: LD_VAR 0 3
113596: PUSH
113597: LD_EXP 178
113601: PUSH
113602: LD_VAR 0 3
113606: ARRAY
113607: PUSH
113608: LD_INT 1
113610: PLUS
113611: PUSH
113612: EMPTY
113613: LIST
113614: LIST
113615: PPUSH
113616: LD_VAR 0 1
113620: PPUSH
113621: CALL 24210 0 3
113625: ST_TO_ADDR
// btype := GetBType ( building ) ;
113626: LD_ADDR_VAR 0 5
113630: PUSH
113631: LD_VAR 0 1
113635: PPUSH
113636: CALL_OW 266
113640: ST_TO_ADDR
// side := GetSide ( building ) ;
113641: LD_ADDR_VAR 0 8
113645: PUSH
113646: LD_VAR 0 1
113650: PPUSH
113651: CALL_OW 255
113655: ST_TO_ADDR
// if btype = b_lab then
113656: LD_VAR 0 5
113660: PUSH
113661: LD_INT 6
113663: EQUAL
113664: IFFALSE 113714
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
113666: LD_ADDR_EXP 211
113670: PUSH
113671: LD_EXP 211
113675: PPUSH
113676: LD_VAR 0 3
113680: PUSH
113681: LD_EXP 211
113685: PUSH
113686: LD_VAR 0 3
113690: ARRAY
113691: PUSH
113692: LD_INT 1
113694: PLUS
113695: PUSH
113696: EMPTY
113697: LIST
113698: LIST
113699: PPUSH
113700: LD_VAR 0 1
113704: PPUSH
113705: CALL 24210 0 3
113709: ST_TO_ADDR
// exit ;
113710: POP
113711: POP
113712: GO 114170
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
113714: LD_VAR 0 5
113718: PUSH
113719: LD_INT 0
113721: PUSH
113722: LD_INT 2
113724: PUSH
113725: LD_INT 4
113727: PUSH
113728: EMPTY
113729: LIST
113730: LIST
113731: LIST
113732: IN
113733: IFFALSE 113857
// begin if btype = b_armoury then
113735: LD_VAR 0 5
113739: PUSH
113740: LD_INT 4
113742: EQUAL
113743: IFFALSE 113753
// btype := b_barracks ;
113745: LD_ADDR_VAR 0 5
113749: PUSH
113750: LD_INT 5
113752: ST_TO_ADDR
// if btype = b_depot then
113753: LD_VAR 0 5
113757: PUSH
113758: LD_INT 0
113760: EQUAL
113761: IFFALSE 113771
// btype := b_warehouse ;
113763: LD_ADDR_VAR 0 5
113767: PUSH
113768: LD_INT 1
113770: ST_TO_ADDR
// if btype = b_workshop then
113771: LD_VAR 0 5
113775: PUSH
113776: LD_INT 2
113778: EQUAL
113779: IFFALSE 113789
// btype := b_factory ;
113781: LD_ADDR_VAR 0 5
113785: PUSH
113786: LD_INT 3
113788: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
113789: LD_VAR 0 5
113793: PPUSH
113794: LD_VAR 0 8
113798: PPUSH
113799: CALL_OW 323
113803: PUSH
113804: LD_INT 1
113806: EQUAL
113807: IFFALSE 113853
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
113809: LD_ADDR_EXP 210
113813: PUSH
113814: LD_EXP 210
113818: PPUSH
113819: LD_VAR 0 3
113823: PUSH
113824: LD_EXP 210
113828: PUSH
113829: LD_VAR 0 3
113833: ARRAY
113834: PUSH
113835: LD_INT 1
113837: PLUS
113838: PUSH
113839: EMPTY
113840: LIST
113841: LIST
113842: PPUSH
113843: LD_VAR 0 1
113847: PPUSH
113848: CALL 24210 0 3
113852: ST_TO_ADDR
// exit ;
113853: POP
113854: POP
113855: GO 114170
// end ; if btype in [ b_bunker , b_turret ] then
113857: LD_VAR 0 5
113861: PUSH
113862: LD_INT 32
113864: PUSH
113865: LD_INT 33
113867: PUSH
113868: EMPTY
113869: LIST
113870: LIST
113871: IN
113872: IFFALSE 114162
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
113874: LD_ADDR_EXP 186
113878: PUSH
113879: LD_EXP 186
113883: PPUSH
113884: LD_VAR 0 3
113888: PUSH
113889: LD_EXP 186
113893: PUSH
113894: LD_VAR 0 3
113898: ARRAY
113899: PUSH
113900: LD_INT 1
113902: PLUS
113903: PUSH
113904: EMPTY
113905: LIST
113906: LIST
113907: PPUSH
113908: LD_VAR 0 1
113912: PPUSH
113913: CALL 24210 0 3
113917: ST_TO_ADDR
// if btype = b_bunker then
113918: LD_VAR 0 5
113922: PUSH
113923: LD_INT 32
113925: EQUAL
113926: IFFALSE 114162
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
113928: LD_ADDR_EXP 187
113932: PUSH
113933: LD_EXP 187
113937: PPUSH
113938: LD_VAR 0 3
113942: PUSH
113943: LD_EXP 187
113947: PUSH
113948: LD_VAR 0 3
113952: ARRAY
113953: PUSH
113954: LD_INT 1
113956: PLUS
113957: PUSH
113958: EMPTY
113959: LIST
113960: LIST
113961: PPUSH
113962: LD_VAR 0 1
113966: PPUSH
113967: CALL 24210 0 3
113971: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
113972: LD_ADDR_VAR 0 6
113976: PUSH
113977: LD_EXP 178
113981: PUSH
113982: LD_VAR 0 3
113986: ARRAY
113987: PPUSH
113988: LD_INT 25
113990: PUSH
113991: LD_INT 1
113993: PUSH
113994: EMPTY
113995: LIST
113996: LIST
113997: PUSH
113998: LD_INT 3
114000: PUSH
114001: LD_INT 54
114003: PUSH
114004: EMPTY
114005: LIST
114006: PUSH
114007: EMPTY
114008: LIST
114009: LIST
114010: PUSH
114011: EMPTY
114012: LIST
114013: LIST
114014: PPUSH
114015: CALL_OW 72
114019: ST_TO_ADDR
// if tmp then
114020: LD_VAR 0 6
114024: IFFALSE 114030
// exit ;
114026: POP
114027: POP
114028: GO 114170
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
114030: LD_ADDR_VAR 0 6
114034: PUSH
114035: LD_EXP 178
114039: PUSH
114040: LD_VAR 0 3
114044: ARRAY
114045: PPUSH
114046: LD_INT 2
114048: PUSH
114049: LD_INT 30
114051: PUSH
114052: LD_INT 4
114054: PUSH
114055: EMPTY
114056: LIST
114057: LIST
114058: PUSH
114059: LD_INT 30
114061: PUSH
114062: LD_INT 5
114064: PUSH
114065: EMPTY
114066: LIST
114067: LIST
114068: PUSH
114069: EMPTY
114070: LIST
114071: LIST
114072: LIST
114073: PPUSH
114074: CALL_OW 72
114078: ST_TO_ADDR
// if not tmp then
114079: LD_VAR 0 6
114083: NOT
114084: IFFALSE 114090
// exit ;
114086: POP
114087: POP
114088: GO 114170
// for j in tmp do
114090: LD_ADDR_VAR 0 4
114094: PUSH
114095: LD_VAR 0 6
114099: PUSH
114100: FOR_IN
114101: IFFALSE 114160
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
114103: LD_ADDR_VAR 0 7
114107: PUSH
114108: LD_VAR 0 4
114112: PPUSH
114113: CALL_OW 313
114117: PPUSH
114118: LD_INT 25
114120: PUSH
114121: LD_INT 1
114123: PUSH
114124: EMPTY
114125: LIST
114126: LIST
114127: PPUSH
114128: CALL_OW 72
114132: ST_TO_ADDR
// if units then
114133: LD_VAR 0 7
114137: IFFALSE 114158
// begin ComExitBuilding ( units [ 1 ] ) ;
114139: LD_VAR 0 7
114143: PUSH
114144: LD_INT 1
114146: ARRAY
114147: PPUSH
114148: CALL_OW 122
// exit ;
114152: POP
114153: POP
114154: POP
114155: POP
114156: GO 114170
// end ; end ;
114158: GO 114100
114160: POP
114161: POP
// end ; end ; exit ;
114162: POP
114163: POP
114164: GO 114170
// end ; end ;
114166: GO 113524
114168: POP
114169: POP
// end ;
114170: LD_VAR 0 2
114174: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
114175: LD_INT 0
114177: PPUSH
114178: PPUSH
114179: PPUSH
114180: PPUSH
114181: PPUSH
114182: PPUSH
114183: PPUSH
// if not mc_bases or not skirmish then
114184: LD_EXP 178
114188: NOT
114189: PUSH
114190: LD_EXP 176
114194: NOT
114195: OR
114196: IFFALSE 114200
// exit ;
114198: GO 114465
// btype := GetBType ( building ) ;
114200: LD_ADDR_VAR 0 6
114204: PUSH
114205: LD_VAR 0 1
114209: PPUSH
114210: CALL_OW 266
114214: ST_TO_ADDR
// x := GetX ( building ) ;
114215: LD_ADDR_VAR 0 7
114219: PUSH
114220: LD_VAR 0 1
114224: PPUSH
114225: CALL_OW 250
114229: ST_TO_ADDR
// y := GetY ( building ) ;
114230: LD_ADDR_VAR 0 8
114234: PUSH
114235: LD_VAR 0 1
114239: PPUSH
114240: CALL_OW 251
114244: ST_TO_ADDR
// d := GetDir ( building ) ;
114245: LD_ADDR_VAR 0 9
114249: PUSH
114250: LD_VAR 0 1
114254: PPUSH
114255: CALL_OW 254
114259: ST_TO_ADDR
// for i = 1 to mc_bases do
114260: LD_ADDR_VAR 0 4
114264: PUSH
114265: DOUBLE
114266: LD_INT 1
114268: DEC
114269: ST_TO_ADDR
114270: LD_EXP 178
114274: PUSH
114275: FOR_TO
114276: IFFALSE 114463
// begin if not mc_build_list [ i ] then
114278: LD_EXP 183
114282: PUSH
114283: LD_VAR 0 4
114287: ARRAY
114288: NOT
114289: IFFALSE 114293
// continue ;
114291: GO 114275
// for j := 1 to mc_build_list [ i ] do
114293: LD_ADDR_VAR 0 5
114297: PUSH
114298: DOUBLE
114299: LD_INT 1
114301: DEC
114302: ST_TO_ADDR
114303: LD_EXP 183
114307: PUSH
114308: LD_VAR 0 4
114312: ARRAY
114313: PUSH
114314: FOR_TO
114315: IFFALSE 114459
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ j ] ) then
114317: LD_VAR 0 6
114321: PUSH
114322: LD_VAR 0 7
114326: PUSH
114327: LD_VAR 0 8
114331: PUSH
114332: LD_VAR 0 9
114336: PUSH
114337: EMPTY
114338: LIST
114339: LIST
114340: LIST
114341: LIST
114342: PPUSH
114343: LD_EXP 183
114347: PUSH
114348: LD_VAR 0 4
114352: ARRAY
114353: PUSH
114354: LD_VAR 0 5
114358: ARRAY
114359: PPUSH
114360: CALL 30392 0 2
114364: IFFALSE 114457
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , j ) ) ;
114366: LD_ADDR_EXP 183
114370: PUSH
114371: LD_EXP 183
114375: PPUSH
114376: LD_VAR 0 4
114380: PPUSH
114381: LD_EXP 183
114385: PUSH
114386: LD_VAR 0 4
114390: ARRAY
114391: PPUSH
114392: LD_VAR 0 5
114396: PPUSH
114397: CALL_OW 3
114401: PPUSH
114402: CALL_OW 1
114406: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
114407: LD_ADDR_EXP 185
114411: PUSH
114412: LD_EXP 185
114416: PPUSH
114417: LD_VAR 0 4
114421: PUSH
114422: LD_EXP 185
114426: PUSH
114427: LD_VAR 0 4
114431: ARRAY
114432: PUSH
114433: LD_INT 1
114435: PLUS
114436: PUSH
114437: EMPTY
114438: LIST
114439: LIST
114440: PPUSH
114441: LD_VAR 0 1
114445: PPUSH
114446: CALL 24210 0 3
114450: ST_TO_ADDR
// exit ;
114451: POP
114452: POP
114453: POP
114454: POP
114455: GO 114465
// end ;
114457: GO 114314
114459: POP
114460: POP
// end ;
114461: GO 114275
114463: POP
114464: POP
// end ;
114465: LD_VAR 0 3
114469: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
114470: LD_INT 0
114472: PPUSH
114473: PPUSH
114474: PPUSH
// if not mc_bases or not skirmish then
114475: LD_EXP 178
114479: NOT
114480: PUSH
114481: LD_EXP 176
114485: NOT
114486: OR
114487: IFFALSE 114491
// exit ;
114489: GO 114681
// for i = 1 to mc_bases do
114491: LD_ADDR_VAR 0 4
114495: PUSH
114496: DOUBLE
114497: LD_INT 1
114499: DEC
114500: ST_TO_ADDR
114501: LD_EXP 178
114505: PUSH
114506: FOR_TO
114507: IFFALSE 114594
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
114509: LD_VAR 0 1
114513: PUSH
114514: LD_EXP 186
114518: PUSH
114519: LD_VAR 0 4
114523: ARRAY
114524: IN
114525: PUSH
114526: LD_VAR 0 1
114530: PUSH
114531: LD_EXP 187
114535: PUSH
114536: LD_VAR 0 4
114540: ARRAY
114541: IN
114542: NOT
114543: AND
114544: IFFALSE 114592
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
114546: LD_ADDR_EXP 187
114550: PUSH
114551: LD_EXP 187
114555: PPUSH
114556: LD_VAR 0 4
114560: PUSH
114561: LD_EXP 187
114565: PUSH
114566: LD_VAR 0 4
114570: ARRAY
114571: PUSH
114572: LD_INT 1
114574: PLUS
114575: PUSH
114576: EMPTY
114577: LIST
114578: LIST
114579: PPUSH
114580: LD_VAR 0 1
114584: PPUSH
114585: CALL 24210 0 3
114589: ST_TO_ADDR
// break ;
114590: GO 114594
// end ; end ;
114592: GO 114506
114594: POP
114595: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
114596: LD_VAR 0 1
114600: PPUSH
114601: CALL_OW 257
114605: PUSH
114606: LD_EXP 204
114610: IN
114611: PUSH
114612: LD_VAR 0 1
114616: PPUSH
114617: CALL_OW 266
114621: PUSH
114622: LD_INT 5
114624: EQUAL
114625: AND
114626: PUSH
114627: LD_VAR 0 2
114631: PPUSH
114632: CALL_OW 110
114636: PUSH
114637: LD_INT 18
114639: NONEQUAL
114640: AND
114641: IFFALSE 114681
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
114643: LD_VAR 0 2
114647: PPUSH
114648: CALL_OW 257
114652: PUSH
114653: LD_INT 5
114655: PUSH
114656: LD_INT 8
114658: PUSH
114659: LD_INT 9
114661: PUSH
114662: EMPTY
114663: LIST
114664: LIST
114665: LIST
114666: IN
114667: IFFALSE 114681
// SetClass ( unit , 1 ) ;
114669: LD_VAR 0 2
114673: PPUSH
114674: LD_INT 1
114676: PPUSH
114677: CALL_OW 336
// end ;
114681: LD_VAR 0 3
114685: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
114686: LD_INT 0
114688: PPUSH
114689: PPUSH
// if not mc_bases or not skirmish then
114690: LD_EXP 178
114694: NOT
114695: PUSH
114696: LD_EXP 176
114700: NOT
114701: OR
114702: IFFALSE 114706
// exit ;
114704: GO 114822
// if GetLives ( abandoned_vehicle ) > 250 then
114706: LD_VAR 0 2
114710: PPUSH
114711: CALL_OW 256
114715: PUSH
114716: LD_INT 250
114718: GREATER
114719: IFFALSE 114723
// exit ;
114721: GO 114822
// for i = 1 to mc_bases do
114723: LD_ADDR_VAR 0 6
114727: PUSH
114728: DOUBLE
114729: LD_INT 1
114731: DEC
114732: ST_TO_ADDR
114733: LD_EXP 178
114737: PUSH
114738: FOR_TO
114739: IFFALSE 114820
// begin if driver in mc_bases [ i ] then
114741: LD_VAR 0 1
114745: PUSH
114746: LD_EXP 178
114750: PUSH
114751: LD_VAR 0 6
114755: ARRAY
114756: IN
114757: IFFALSE 114818
// begin ComMoveToNearbyEntrance ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
114759: LD_VAR 0 1
114763: PPUSH
114764: LD_EXP 178
114768: PUSH
114769: LD_VAR 0 6
114773: ARRAY
114774: PPUSH
114775: LD_INT 2
114777: PUSH
114778: LD_INT 30
114780: PUSH
114781: LD_INT 0
114783: PUSH
114784: EMPTY
114785: LIST
114786: LIST
114787: PUSH
114788: LD_INT 30
114790: PUSH
114791: LD_INT 1
114793: PUSH
114794: EMPTY
114795: LIST
114796: LIST
114797: PUSH
114798: EMPTY
114799: LIST
114800: LIST
114801: LIST
114802: PPUSH
114803: CALL_OW 72
114807: PUSH
114808: LD_INT 1
114810: ARRAY
114811: PPUSH
114812: CALL 56828 0 2
// break ;
114816: GO 114820
// end ; end ;
114818: GO 114738
114820: POP
114821: POP
// end ;
114822: LD_VAR 0 5
114826: RET
