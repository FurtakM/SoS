// starting begin InitMission ;
   0: CALL 5 0 0
// end ;
   4: END
// export HeikeCaptured ; export coopWithGensher ; export HeikeStatus ; export Masha ; export dial_BuildDepotBlocker , dial_BuildArBarrackBlocker , dial_ArriveGensherUnitsBlocker ; export buildingsToBuild , techsToResearch , vehWeaponsToConstruct , availableWeapons , weaponsData , allBuildings ; export HeikeTargetX , HeikeTargetY , GensherTargetX , GensherTargetY ; export allowExitFromMap ; export acceptKurtOffert , askCommanders ; export KurtCanEscape , KurtStatus , KurtWaitingForFreeHeike , KurtWaitingForBuildBarrack ; export KurtAttack , americansAttack , forceStopKurtAttack ; export canSendHeike , canShootTrening ; export BurlakRespect ; export acceptLegionOffert , paidLegionOffert , legionOffertCountdown , legionOffertTime ; export firstMashaQuery , canChooseMashaVehicle ; export buildCompVehicle , buildArabBarrack , testedTeleport ; export lostUnits ; function InitMission ; begin
   5: LD_INT 0
   7: PPUSH
// ResetFog ;
   8: CALL_OW 335
// RandomizeAll ;
  12: CALL_OW 11
// InGameOn ;
  16: CALL_OW 8
// InitMapConfig ;
  20: CALL 358 0 0
// HeikeCaptured = LoadVariable ( 07_HeikeCaptured_1 , 0 ) ;
  24: LD_ADDR_EXP 1
  28: PUSH
  29: LD_STRING 07_HeikeCaptured_1
  31: PPUSH
  32: LD_INT 0
  34: PPUSH
  35: CALL_OW 30
  39: ST_TO_ADDR
// coopWithGensher = 0 ;
  40: LD_ADDR_EXP 2
  44: PUSH
  45: LD_INT 0
  47: ST_TO_ADDR
// HeikeStatus = 0 ;
  48: LD_ADDR_EXP 3
  52: PUSH
  53: LD_INT 0
  55: ST_TO_ADDR
// Masha = [ ] ;
  56: LD_ADDR_EXP 4
  60: PUSH
  61: EMPTY
  62: ST_TO_ADDR
// buildingsToBuild = [ ] ;
  63: LD_ADDR_EXP 8
  67: PUSH
  68: EMPTY
  69: ST_TO_ADDR
// techsToResearch = [ ] ;
  70: LD_ADDR_EXP 9
  74: PUSH
  75: EMPTY
  76: ST_TO_ADDR
// vehWeaponsToConstruct = [ ] ;
  77: LD_ADDR_EXP 10
  81: PUSH
  82: EMPTY
  83: ST_TO_ADDR
// availableWeapons = [ ] ;
  84: LD_ADDR_EXP 11
  88: PUSH
  89: EMPTY
  90: ST_TO_ADDR
// weaponsData = [ ] ;
  91: LD_ADDR_EXP 12
  95: PUSH
  96: EMPTY
  97: ST_TO_ADDR
// allBuildings = [ ] ;
  98: LD_ADDR_EXP 13
 102: PUSH
 103: EMPTY
 104: ST_TO_ADDR
// HeikeTargetX = 0 ;
 105: LD_ADDR_EXP 14
 109: PUSH
 110: LD_INT 0
 112: ST_TO_ADDR
// HeikeTargetY = 0 ;
 113: LD_ADDR_EXP 15
 117: PUSH
 118: LD_INT 0
 120: ST_TO_ADDR
// GensherTargetX = 0 ;
 121: LD_ADDR_EXP 16
 125: PUSH
 126: LD_INT 0
 128: ST_TO_ADDR
// GensherTargetY = 0 ;
 129: LD_ADDR_EXP 17
 133: PUSH
 134: LD_INT 0
 136: ST_TO_ADDR
// allowExitFromMap = 0 ;
 137: LD_ADDR_EXP 18
 141: PUSH
 142: LD_INT 0
 144: ST_TO_ADDR
// acceptKurtOffert = 0 ;
 145: LD_ADDR_EXP 19
 149: PUSH
 150: LD_INT 0
 152: ST_TO_ADDR
// askCommanders = 0 ;
 153: LD_ADDR_EXP 20
 157: PUSH
 158: LD_INT 0
 160: ST_TO_ADDR
// KurtCanEscape = true ;
 161: LD_ADDR_EXP 21
 165: PUSH
 166: LD_INT 1
 168: ST_TO_ADDR
// KurtAttack = false ;
 169: LD_ADDR_EXP 25
 173: PUSH
 174: LD_INT 0
 176: ST_TO_ADDR
// KurtWaitingForFreeHeike = false ;
 177: LD_ADDR_EXP 23
 181: PUSH
 182: LD_INT 0
 184: ST_TO_ADDR
// KurtWaitingForBuildBarrack = false ;
 185: LD_ADDR_EXP 24
 189: PUSH
 190: LD_INT 0
 192: ST_TO_ADDR
// KurtStatus = 0 ;
 193: LD_ADDR_EXP 22
 197: PUSH
 198: LD_INT 0
 200: ST_TO_ADDR
// americansAttack = false ;
 201: LD_ADDR_EXP 26
 205: PUSH
 206: LD_INT 0
 208: ST_TO_ADDR
// forceStopKurtAttack = false ;
 209: LD_ADDR_EXP 27
 213: PUSH
 214: LD_INT 0
 216: ST_TO_ADDR
// canSendHeike = false ;
 217: LD_ADDR_EXP 28
 221: PUSH
 222: LD_INT 0
 224: ST_TO_ADDR
// canShootTrening = false ;
 225: LD_ADDR_EXP 29
 229: PUSH
 230: LD_INT 0
 232: ST_TO_ADDR
// BurlakRespect = 0 ;
 233: LD_ADDR_EXP 30
 237: PUSH
 238: LD_INT 0
 240: ST_TO_ADDR
// acceptLegionOffert = false ;
 241: LD_ADDR_EXP 31
 245: PUSH
 246: LD_INT 0
 248: ST_TO_ADDR
// paidLegionOffert = false ;
 249: LD_ADDR_EXP 32
 253: PUSH
 254: LD_INT 0
 256: ST_TO_ADDR
// legionOffertCountdown = false ;
 257: LD_ADDR_EXP 33
 261: PUSH
 262: LD_INT 0
 264: ST_TO_ADDR
// legionOffertTime = 0 0$60 ;
 265: LD_ADDR_EXP 34
 269: PUSH
 270: LD_INT 2100
 272: ST_TO_ADDR
// canChooseMashaVehicle = false ;
 273: LD_ADDR_EXP 36
 277: PUSH
 278: LD_INT 0
 280: ST_TO_ADDR
// firstMashaQuery = true ;
 281: LD_ADDR_EXP 35
 285: PUSH
 286: LD_INT 1
 288: ST_TO_ADDR
// buildArabBarrack = false ;
 289: LD_ADDR_EXP 38
 293: PUSH
 294: LD_INT 0
 296: ST_TO_ADDR
// buildCompVehicle = false ;
 297: LD_ADDR_EXP 37
 301: PUSH
 302: LD_INT 0
 304: ST_TO_ADDR
// testedTeleport = false ;
 305: LD_ADDR_EXP 39
 309: PUSH
 310: LD_INT 0
 312: ST_TO_ADDR
// lostUnits = 0 ;
 313: LD_ADDR_EXP 40
 317: PUSH
 318: LD_INT 0
 320: ST_TO_ADDR
// PrepareRussians ;
 321: CALL 1292 0 0
// PrepareArabians ;
 325: CALL 3847 0 0
// PrepareAmericans ;
 329: CALL 2975 0 0
// Nef_PrepareNature ;
 333: CALL 4831 0 0
// SpawnTrees ;
 337: CALL 5452 0 0
// MissionIntro ;
 341: CALL 9085 0 0
// end ;
 345: LD_VAR 0 1
 349: RET
// export function CustomInitMacro ; begin
 350: LD_INT 0
 352: PPUSH
// end ; end_of_file
 353: LD_VAR 0 1
 357: RET
// export function InitMapConfig ; begin
 358: LD_INT 0
 360: PPUSH
// BaseMapConfig ;
 361: CALL 374 0 0
// MissionMapConfig ;
 365: CALL 464 0 0
// end ;
 369: LD_VAR 0 1
 373: RET
// export animalsAmount , animalsStats , animalsAgression , missionPrefix , previousMissionPrefix , debugMode ; function BaseMapConfig ; begin
 374: LD_INT 0
 376: PPUSH
// animalsAmount = [ 6 , 3 , 4 , 4 , 1 ] ;
 377: LD_ADDR_EXP 41
 381: PUSH
 382: LD_INT 6
 384: PUSH
 385: LD_INT 3
 387: PUSH
 388: LD_INT 4
 390: PUSH
 391: LD_INT 4
 393: PUSH
 394: LD_INT 1
 396: PUSH
 397: EMPTY
 398: LIST
 399: LIST
 400: LIST
 401: LIST
 402: LIST
 403: ST_TO_ADDR
// animalsStats = [ 2 , 2 , 2 , 2 ] ;
 404: LD_ADDR_EXP 42
 408: PUSH
 409: LD_INT 2
 411: PUSH
 412: LD_INT 2
 414: PUSH
 415: LD_INT 2
 417: PUSH
 418: LD_INT 2
 420: PUSH
 421: EMPTY
 422: LIST
 423: LIST
 424: LIST
 425: LIST
 426: ST_TO_ADDR
// animalsAgression = 3 ;
 427: LD_ADDR_EXP 43
 431: PUSH
 432: LD_INT 3
 434: ST_TO_ADDR
// debugMode = 0 ;
 435: LD_ADDR_EXP 46
 439: PUSH
 440: LD_INT 0
 442: ST_TO_ADDR
// missionPrefix = 08_ ;
 443: LD_ADDR_EXP 44
 447: PUSH
 448: LD_STRING 08_
 450: ST_TO_ADDR
// previousMissionPrefix = 07_ ;
 451: LD_ADDR_EXP 45
 455: PUSH
 456: LD_STRING 07_
 458: ST_TO_ADDR
// end ;
 459: LD_VAR 0 1
 463: RET
// export KurtAttackWaves , americansAttackWaves ; export firstAttackDelay ; export waveCooldown ; export legionReduceAmericansUnits ; export speedMedalTime ; export enemyAttackUnitsData ; export timeToFreeHeike , timeToBuildArBarrack ; export enemySkillLevel ; function MissionMapConfig ; begin
 464: LD_INT 0
 466: PPUSH
// KurtAttackWaves = [ 3 , 4 , 5 , 6 ] [ Difficulty ] ;
 467: LD_ADDR_EXP 47
 471: PUSH
 472: LD_INT 3
 474: PUSH
 475: LD_INT 4
 477: PUSH
 478: LD_INT 5
 480: PUSH
 481: LD_INT 6
 483: PUSH
 484: EMPTY
 485: LIST
 486: LIST
 487: LIST
 488: LIST
 489: PUSH
 490: LD_OWVAR 67
 494: ARRAY
 495: ST_TO_ADDR
// americansAttackWaves = [ 1 , 2 , 3 , 4 ] [ Difficulty ] ;
 496: LD_ADDR_EXP 48
 500: PUSH
 501: LD_INT 1
 503: PUSH
 504: LD_INT 2
 506: PUSH
 507: LD_INT 3
 509: PUSH
 510: LD_INT 4
 512: PUSH
 513: EMPTY
 514: LIST
 515: LIST
 516: LIST
 517: LIST
 518: PUSH
 519: LD_OWVAR 67
 523: ARRAY
 524: ST_TO_ADDR
// enemySkillLevel = [ 3 , 4 , 5 , 6 ] [ Difficulty ] ;
 525: LD_ADDR_EXP 56
 529: PUSH
 530: LD_INT 3
 532: PUSH
 533: LD_INT 4
 535: PUSH
 536: LD_INT 5
 538: PUSH
 539: LD_INT 6
 541: PUSH
 542: EMPTY
 543: LIST
 544: LIST
 545: LIST
 546: LIST
 547: PUSH
 548: LD_OWVAR 67
 552: ARRAY
 553: ST_TO_ADDR
// waveCooldown = 1 1$30 ;
 554: LD_ADDR_EXP 50
 558: PUSH
 559: LD_INT 3150
 561: ST_TO_ADDR
// firstAttackDelay = 1 1$00 ;
 562: LD_ADDR_EXP 49
 566: PUSH
 567: LD_INT 2100
 569: ST_TO_ADDR
// timeToFreeHeike = 2 2$00 ;
 570: LD_ADDR_EXP 54
 574: PUSH
 575: LD_INT 4200
 577: ST_TO_ADDR
// timeToBuildArBarrack = 5 5$00 ;
 578: LD_ADDR_EXP 55
 582: PUSH
 583: LD_INT 10500
 585: ST_TO_ADDR
// legionReduceAmericansUnits = [ 5 , 5 , 6 , 6 ] [ Difficulty ] ;
 586: LD_ADDR_EXP 51
 590: PUSH
 591: LD_INT 5
 593: PUSH
 594: LD_INT 5
 596: PUSH
 597: LD_INT 6
 599: PUSH
 600: LD_INT 6
 602: PUSH
 603: EMPTY
 604: LIST
 605: LIST
 606: LIST
 607: LIST
 608: PUSH
 609: LD_OWVAR 67
 613: ARRAY
 614: ST_TO_ADDR
// speedMedalTime = [ 80 80$0 , 70 70$0 , 60 60$0 , 50 50$0 ] [ Difficulty ] ;
 615: LD_ADDR_EXP 52
 619: PUSH
 620: LD_INT 168000
 622: PUSH
 623: LD_INT 147000
 625: PUSH
 626: LD_INT 126000
 628: PUSH
 629: LD_INT 105000
 631: PUSH
 632: EMPTY
 633: LIST
 634: LIST
 635: LIST
 636: LIST
 637: PUSH
 638: LD_OWVAR 67
 642: ARRAY
 643: ST_TO_ADDR
// enemyAttackUnitsData = [ [ 1 , [ 4 , 5 , 6 , 6 ] [ Difficulty ] , [ 7 , 8 , 9 , 9 ] [ Difficulty ] , [ 1 , 2 , 2 , 3 ] [ Difficulty ] , [ 3 , 3 , 4 , 4 ] [ Difficulty ] , [ 6 , 7 , 8 , 8 ] [ Difficulty ] , [ 10 , 12 , 15 , 15 ] [ Difficulty ] ] , [ 8 , [ 2 , 3 , 4 , 4 ] [ Difficulty ] , [ 6 , 6 , 7 , 7 ] [ Difficulty ] , [ 0 , 1 , 1 , 2 ] [ Difficulty ] , [ 1 , 2 , 3 , 3 ] [ Difficulty ] , [ 1 , 2 , 2 , 2 ] [ Difficulty ] , [ 2 , 3 , 5 , 5 ] [ Difficulty ] ] ] ;
 644: LD_ADDR_EXP 53
 648: PUSH
 649: LD_INT 1
 651: PUSH
 652: LD_INT 4
 654: PUSH
 655: LD_INT 5
 657: PUSH
 658: LD_INT 6
 660: PUSH
 661: LD_INT 6
 663: PUSH
 664: EMPTY
 665: LIST
 666: LIST
 667: LIST
 668: LIST
 669: PUSH
 670: LD_OWVAR 67
 674: ARRAY
 675: PUSH
 676: LD_INT 7
 678: PUSH
 679: LD_INT 8
 681: PUSH
 682: LD_INT 9
 684: PUSH
 685: LD_INT 9
 687: PUSH
 688: EMPTY
 689: LIST
 690: LIST
 691: LIST
 692: LIST
 693: PUSH
 694: LD_OWVAR 67
 698: ARRAY
 699: PUSH
 700: LD_INT 1
 702: PUSH
 703: LD_INT 2
 705: PUSH
 706: LD_INT 2
 708: PUSH
 709: LD_INT 3
 711: PUSH
 712: EMPTY
 713: LIST
 714: LIST
 715: LIST
 716: LIST
 717: PUSH
 718: LD_OWVAR 67
 722: ARRAY
 723: PUSH
 724: LD_INT 3
 726: PUSH
 727: LD_INT 3
 729: PUSH
 730: LD_INT 4
 732: PUSH
 733: LD_INT 4
 735: PUSH
 736: EMPTY
 737: LIST
 738: LIST
 739: LIST
 740: LIST
 741: PUSH
 742: LD_OWVAR 67
 746: ARRAY
 747: PUSH
 748: LD_INT 6
 750: PUSH
 751: LD_INT 7
 753: PUSH
 754: LD_INT 8
 756: PUSH
 757: LD_INT 8
 759: PUSH
 760: EMPTY
 761: LIST
 762: LIST
 763: LIST
 764: LIST
 765: PUSH
 766: LD_OWVAR 67
 770: ARRAY
 771: PUSH
 772: LD_INT 10
 774: PUSH
 775: LD_INT 12
 777: PUSH
 778: LD_INT 15
 780: PUSH
 781: LD_INT 15
 783: PUSH
 784: EMPTY
 785: LIST
 786: LIST
 787: LIST
 788: LIST
 789: PUSH
 790: LD_OWVAR 67
 794: ARRAY
 795: PUSH
 796: EMPTY
 797: LIST
 798: LIST
 799: LIST
 800: LIST
 801: LIST
 802: LIST
 803: LIST
 804: PUSH
 805: LD_INT 8
 807: PUSH
 808: LD_INT 2
 810: PUSH
 811: LD_INT 3
 813: PUSH
 814: LD_INT 4
 816: PUSH
 817: LD_INT 4
 819: PUSH
 820: EMPTY
 821: LIST
 822: LIST
 823: LIST
 824: LIST
 825: PUSH
 826: LD_OWVAR 67
 830: ARRAY
 831: PUSH
 832: LD_INT 6
 834: PUSH
 835: LD_INT 6
 837: PUSH
 838: LD_INT 7
 840: PUSH
 841: LD_INT 7
 843: PUSH
 844: EMPTY
 845: LIST
 846: LIST
 847: LIST
 848: LIST
 849: PUSH
 850: LD_OWVAR 67
 854: ARRAY
 855: PUSH
 856: LD_INT 0
 858: PUSH
 859: LD_INT 1
 861: PUSH
 862: LD_INT 1
 864: PUSH
 865: LD_INT 2
 867: PUSH
 868: EMPTY
 869: LIST
 870: LIST
 871: LIST
 872: LIST
 873: PUSH
 874: LD_OWVAR 67
 878: ARRAY
 879: PUSH
 880: LD_INT 1
 882: PUSH
 883: LD_INT 2
 885: PUSH
 886: LD_INT 3
 888: PUSH
 889: LD_INT 3
 891: PUSH
 892: EMPTY
 893: LIST
 894: LIST
 895: LIST
 896: LIST
 897: PUSH
 898: LD_OWVAR 67
 902: ARRAY
 903: PUSH
 904: LD_INT 1
 906: PUSH
 907: LD_INT 2
 909: PUSH
 910: LD_INT 2
 912: PUSH
 913: LD_INT 2
 915: PUSH
 916: EMPTY
 917: LIST
 918: LIST
 919: LIST
 920: LIST
 921: PUSH
 922: LD_OWVAR 67
 926: ARRAY
 927: PUSH
 928: LD_INT 2
 930: PUSH
 931: LD_INT 3
 933: PUSH
 934: LD_INT 5
 936: PUSH
 937: LD_INT 5
 939: PUSH
 940: EMPTY
 941: LIST
 942: LIST
 943: LIST
 944: LIST
 945: PUSH
 946: LD_OWVAR 67
 950: ARRAY
 951: PUSH
 952: EMPTY
 953: LIST
 954: LIST
 955: LIST
 956: LIST
 957: LIST
 958: LIST
 959: LIST
 960: PUSH
 961: EMPTY
 962: LIST
 963: LIST
 964: ST_TO_ADDR
// end ;
 965: LD_VAR 0 1
 969: RET
// every 0 0$1 trigger debugMode do var i ;
 970: LD_EXP 46
 974: IFFALSE 1289
 976: GO 978
 978: DISABLE
 979: LD_INT 0
 981: PPUSH
// begin enable ;
 982: ENABLE
// FogOff ( your_side ) ;
 983: LD_OWVAR 2
 987: PPUSH
 988: CALL_OW 344
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) do
 992: LD_ADDR_VAR 0 1
 996: PUSH
 997: LD_INT 22
 999: PUSH
1000: LD_OWVAR 2
1004: PUSH
1005: EMPTY
1006: LIST
1007: LIST
1008: PUSH
1009: LD_INT 2
1011: PUSH
1012: LD_INT 21
1014: PUSH
1015: LD_INT 1
1017: PUSH
1018: EMPTY
1019: LIST
1020: LIST
1021: PUSH
1022: LD_INT 21
1024: PUSH
1025: LD_INT 2
1027: PUSH
1028: EMPTY
1029: LIST
1030: LIST
1031: PUSH
1032: EMPTY
1033: LIST
1034: LIST
1035: LIST
1036: PUSH
1037: EMPTY
1038: LIST
1039: LIST
1040: PPUSH
1041: CALL_OW 69
1045: PUSH
1046: FOR_IN
1047: IFFALSE 1063
// SetLives ( i , 1000 ) ;
1049: LD_VAR 0 1
1053: PPUSH
1054: LD_INT 1000
1056: PPUSH
1057: CALL_OW 234
1061: GO 1046
1063: POP
1064: POP
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) do
1065: LD_ADDR_VAR 0 1
1069: PUSH
1070: LD_INT 22
1072: PUSH
1073: LD_OWVAR 2
1077: PUSH
1078: EMPTY
1079: LIST
1080: LIST
1081: PUSH
1082: LD_INT 21
1084: PUSH
1085: LD_INT 1
1087: PUSH
1088: EMPTY
1089: LIST
1090: LIST
1091: PUSH
1092: EMPTY
1093: LIST
1094: LIST
1095: PPUSH
1096: CALL_OW 69
1100: PUSH
1101: FOR_IN
1102: IFFALSE 1166
// begin SetSkill ( i , skill_combat , 10 ) ;
1104: LD_VAR 0 1
1108: PPUSH
1109: LD_INT 1
1111: PPUSH
1112: LD_INT 10
1114: PPUSH
1115: CALL_OW 237
// SetSkill ( i , skill_engineering , 10 ) ;
1119: LD_VAR 0 1
1123: PPUSH
1124: LD_INT 2
1126: PPUSH
1127: LD_INT 10
1129: PPUSH
1130: CALL_OW 237
// SetSkill ( i , skill_mechanical , 10 ) ;
1134: LD_VAR 0 1
1138: PPUSH
1139: LD_INT 3
1141: PPUSH
1142: LD_INT 10
1144: PPUSH
1145: CALL_OW 237
// SetSkill ( i , skill_scientistic , 10 ) ;
1149: LD_VAR 0 1
1153: PPUSH
1154: LD_INT 4
1156: PPUSH
1157: LD_INT 10
1159: PPUSH
1160: CALL_OW 237
// end ;
1164: GO 1101
1166: POP
1167: POP
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) do
1168: LD_ADDR_VAR 0 1
1172: PUSH
1173: LD_INT 22
1175: PUSH
1176: LD_OWVAR 2
1180: PUSH
1181: EMPTY
1182: LIST
1183: LIST
1184: PUSH
1185: LD_INT 2
1187: PUSH
1188: LD_INT 30
1190: PUSH
1191: LD_INT 0
1193: PUSH
1194: EMPTY
1195: LIST
1196: LIST
1197: PUSH
1198: LD_INT 30
1200: PUSH
1201: LD_INT 1
1203: PUSH
1204: EMPTY
1205: LIST
1206: LIST
1207: PUSH
1208: EMPTY
1209: LIST
1210: LIST
1211: LIST
1212: PUSH
1213: EMPTY
1214: LIST
1215: LIST
1216: PPUSH
1217: CALL_OW 69
1221: PUSH
1222: FOR_IN
1223: IFFALSE 1287
// begin SetResourceType ( GetBase ( i ) , mat_cans , 9999 ) ;
1225: LD_VAR 0 1
1229: PPUSH
1230: CALL_OW 274
1234: PPUSH
1235: LD_INT 1
1237: PPUSH
1238: LD_INT 9999
1240: PPUSH
1241: CALL_OW 277
// SetResourceType ( GetBase ( i ) , mat_oil , 9999 ) ;
1245: LD_VAR 0 1
1249: PPUSH
1250: CALL_OW 274
1254: PPUSH
1255: LD_INT 2
1257: PPUSH
1258: LD_INT 9999
1260: PPUSH
1261: CALL_OW 277
// SetResourceType ( GetBase ( i ) , mat_siberit , 9999 ) ;
1265: LD_VAR 0 1
1269: PPUSH
1270: CALL_OW 274
1274: PPUSH
1275: LD_INT 3
1277: PPUSH
1278: LD_INT 9999
1280: PPUSH
1281: CALL_OW 277
// end ;
1285: GO 1222
1287: POP
1288: POP
// end ; end_of_file
1289: PPOPN 1
1291: END
// export Burlak , Karamazov , Petrovova , Gleb , Petrosyan , Titov , Dolgov , Lipshchin , Kirilenkova , Belkov , Belkov2 , Xavier ; export Gnyevko , Kovalyuk , Scholtze , Kuzmov ; export Kozlov , Oblukov , Kapitsova ; export Popov ; export russianEscort ; export function PrepareRussians ; begin
1292: LD_INT 0
1294: PPUSH
// russianEscort = [ ] ;
1295: LD_ADDR_EXP 77
1299: PUSH
1300: EMPTY
1301: ST_TO_ADDR
// Masha = [ ] ;
1302: LD_ADDR_EXP 4
1306: PUSH
1307: EMPTY
1308: ST_TO_ADDR
// PrepareHeroes ;
1309: CALL 1322 0 0
// InitRussianRequiments ;
1313: CALL 2717 0 0
// end ;
1317: LD_VAR 0 1
1321: RET
// function PrepareHeroes ; var i , un , other_survivors , yourUnits , emptyVeh ; begin
1322: LD_INT 0
1324: PPUSH
1325: PPUSH
1326: PPUSH
1327: PPUSH
1328: PPUSH
1329: PPUSH
// uc_side = 3 ;
1330: LD_ADDR_OWVAR 20
1334: PUSH
1335: LD_INT 3
1337: ST_TO_ADDR
// uc_nation = 3 ;
1338: LD_ADDR_OWVAR 21
1342: PUSH
1343: LD_INT 3
1345: ST_TO_ADDR
// Burlak := PrepareUnitExt ( Burlak , true , class_mechanic ) ;
1346: LD_ADDR_EXP 57
1350: PUSH
1351: LD_STRING Burlak
1353: PPUSH
1354: LD_INT 1
1356: PPUSH
1357: LD_INT 3
1359: PPUSH
1360: CALL 5930 0 3
1364: ST_TO_ADDR
// Titov := PrepareUnitExt ( Titov , true , class_soldier ) ;
1365: LD_ADDR_EXP 62
1369: PUSH
1370: LD_STRING Titov
1372: PPUSH
1373: LD_INT 1
1375: PPUSH
1376: LD_INT 1
1378: PPUSH
1379: CALL 5930 0 3
1383: ST_TO_ADDR
// Dolgov := PrepareUnitExt ( Dolgov , true , class_scientistic ) ;
1384: LD_ADDR_EXP 63
1388: PUSH
1389: LD_STRING Dolgov
1391: PPUSH
1392: LD_INT 1
1394: PPUSH
1395: LD_INT 4
1397: PPUSH
1398: CALL 5930 0 3
1402: ST_TO_ADDR
// Lipshchin := PrepareUnitExt ( Lipshchin , true , class_soldier ) ;
1403: LD_ADDR_EXP 64
1407: PUSH
1408: LD_STRING Lipshchin
1410: PPUSH
1411: LD_INT 1
1413: PPUSH
1414: LD_INT 1
1416: PPUSH
1417: CALL 5930 0 3
1421: ST_TO_ADDR
// Karamazov := PrepareUnitExt ( Karamazov , true , class_engineer ) ;
1422: LD_ADDR_EXP 58
1426: PUSH
1427: LD_STRING Karamazov
1429: PPUSH
1430: LD_INT 1
1432: PPUSH
1433: LD_INT 2
1435: PPUSH
1436: CALL 5930 0 3
1440: ST_TO_ADDR
// Petrovova := PrepareUnitExt ( Petrovova , true , class_soldier ) ;
1441: LD_ADDR_EXP 59
1445: PUSH
1446: LD_STRING Petrovova
1448: PPUSH
1449: LD_INT 1
1451: PPUSH
1452: LD_INT 1
1454: PPUSH
1455: CALL 5930 0 3
1459: ST_TO_ADDR
// Gleb := PrepareUnitExt ( Gleb , true , class_soldier ) ;
1460: LD_ADDR_EXP 60
1464: PUSH
1465: LD_STRING Gleb
1467: PPUSH
1468: LD_INT 1
1470: PPUSH
1471: LD_INT 1
1473: PPUSH
1474: CALL 5930 0 3
1478: ST_TO_ADDR
// Petrosyan := PrepareUnitExt ( Petrosyan , true , class_scientistic ) ;
1479: LD_ADDR_EXP 61
1483: PUSH
1484: LD_STRING Petrosyan
1486: PPUSH
1487: LD_INT 1
1489: PPUSH
1490: LD_INT 4
1492: PPUSH
1493: CALL 5930 0 3
1497: ST_TO_ADDR
// Kirilenkova := PrepareUnitExt ( Kirilenkova , true , class_scientistic ) ;
1498: LD_ADDR_EXP 65
1502: PUSH
1503: LD_STRING Kirilenkova
1505: PPUSH
1506: LD_INT 1
1508: PPUSH
1509: LD_INT 4
1511: PPUSH
1512: CALL 5930 0 3
1516: ST_TO_ADDR
// Belkov := PrepareUnitExt ( Belkov , true , class_soldier ) ;
1517: LD_ADDR_EXP 66
1521: PUSH
1522: LD_STRING Belkov
1524: PPUSH
1525: LD_INT 1
1527: PPUSH
1528: LD_INT 1
1530: PPUSH
1531: CALL 5930 0 3
1535: ST_TO_ADDR
// Belkov2 := PrepareUnitExt ( Belkov2 , true , class_soldier ) ;
1536: LD_ADDR_EXP 67
1540: PUSH
1541: LD_STRING Belkov2
1543: PPUSH
1544: LD_INT 1
1546: PPUSH
1547: LD_INT 1
1549: PPUSH
1550: CALL 5930 0 3
1554: ST_TO_ADDR
// Xavier := PrepareUnitExt ( Xavier , true , class_soldier ) ;
1555: LD_ADDR_EXP 68
1559: PUSH
1560: LD_STRING Xavier
1562: PPUSH
1563: LD_INT 1
1565: PPUSH
1566: LD_INT 1
1568: PPUSH
1569: CALL 5930 0 3
1573: ST_TO_ADDR
// Gnyevko := CreateCharacter ( 04_Gnyevko ) ;
1574: LD_ADDR_EXP 69
1578: PUSH
1579: LD_STRING 04_Gnyevko
1581: PPUSH
1582: CALL_OW 34
1586: ST_TO_ADDR
// SetClass ( Gnyevko , class_soldier ) ;
1587: LD_EXP 69
1591: PPUSH
1592: LD_INT 1
1594: PPUSH
1595: CALL_OW 336
// Kovalyuk := CreateCharacter ( 04_Kovalyuk ) ;
1599: LD_ADDR_EXP 70
1603: PUSH
1604: LD_STRING 04_Kovalyuk
1606: PPUSH
1607: CALL_OW 34
1611: ST_TO_ADDR
// SetClass ( Kovalyuk , class_mechanic ) ;
1612: LD_EXP 70
1616: PPUSH
1617: LD_INT 3
1619: PPUSH
1620: CALL_OW 336
// Scholtze := CreateCharacter ( 04_Scholtze ) ;
1624: LD_ADDR_EXP 71
1628: PUSH
1629: LD_STRING 04_Scholtze
1631: PPUSH
1632: CALL_OW 34
1636: ST_TO_ADDR
// SetClass ( Scholtze , class_scientistic ) ;
1637: LD_EXP 71
1641: PPUSH
1642: LD_INT 4
1644: PPUSH
1645: CALL_OW 336
// Kuzmov := CreateCharacter ( 04_Kuzmov ) ;
1649: LD_ADDR_EXP 72
1653: PUSH
1654: LD_STRING 04_Kuzmov
1656: PPUSH
1657: CALL_OW 34
1661: ST_TO_ADDR
// SetClass ( Kuzmov , class_soldier ) ;
1662: LD_EXP 72
1666: PPUSH
1667: LD_INT 1
1669: PPUSH
1670: CALL_OW 336
// Kozlov := PrepareUnitExt ( Kozlov , false , class_engineer ) ;
1674: LD_ADDR_EXP 73
1678: PUSH
1679: LD_STRING Kozlov
1681: PPUSH
1682: LD_INT 0
1684: PPUSH
1685: LD_INT 2
1687: PPUSH
1688: CALL 5930 0 3
1692: ST_TO_ADDR
// Oblukov := PrepareUnitExt ( Oblukov , false , class_soldier ) ;
1693: LD_ADDR_EXP 74
1697: PUSH
1698: LD_STRING Oblukov
1700: PPUSH
1701: LD_INT 0
1703: PPUSH
1704: LD_INT 1
1706: PPUSH
1707: CALL 5930 0 3
1711: ST_TO_ADDR
// Kapitsova := PrepareUnitExt ( Kapitsova , false , class_scientistic ) ;
1712: LD_ADDR_EXP 75
1716: PUSH
1717: LD_STRING Kapitsova
1719: PPUSH
1720: LD_INT 0
1722: PPUSH
1723: LD_INT 4
1725: PPUSH
1726: CALL 5930 0 3
1730: ST_TO_ADDR
// Popov := PrepareUnitExt ( Popov , false , 0 ) ;
1731: LD_ADDR_EXP 76
1735: PUSH
1736: LD_STRING Popov
1738: PPUSH
1739: LD_INT 0
1741: PPUSH
1742: LD_INT 0
1744: PPUSH
1745: CALL 5930 0 3
1749: ST_TO_ADDR
// PlaceUnitsArea ( [ Burlak , Karamazov , Petrovova , Gleb , Petrosyan , Titov , Dolgov , Lipshchin , Kirilenkova , Belkov , Belkov2 , Xavier , Gnyevko , Kovalyuk , Scholtze , Kuzmov , Kozlov , Oblukov , Kapitsova ] , RussianSpawnArea , false ) ;
1750: LD_EXP 57
1754: PUSH
1755: LD_EXP 58
1759: PUSH
1760: LD_EXP 59
1764: PUSH
1765: LD_EXP 60
1769: PUSH
1770: LD_EXP 61
1774: PUSH
1775: LD_EXP 62
1779: PUSH
1780: LD_EXP 63
1784: PUSH
1785: LD_EXP 64
1789: PUSH
1790: LD_EXP 65
1794: PUSH
1795: LD_EXP 66
1799: PUSH
1800: LD_EXP 67
1804: PUSH
1805: LD_EXP 68
1809: PUSH
1810: LD_EXP 69
1814: PUSH
1815: LD_EXP 70
1819: PUSH
1820: LD_EXP 71
1824: PUSH
1825: LD_EXP 72
1829: PUSH
1830: LD_EXP 73
1834: PUSH
1835: LD_EXP 74
1839: PUSH
1840: LD_EXP 75
1844: PUSH
1845: EMPTY
1846: LIST
1847: LIST
1848: LIST
1849: LIST
1850: LIST
1851: LIST
1852: LIST
1853: LIST
1854: LIST
1855: LIST
1856: LIST
1857: LIST
1858: LIST
1859: LIST
1860: LIST
1861: LIST
1862: LIST
1863: LIST
1864: LIST
1865: PPUSH
1866: LD_INT 2
1868: PPUSH
1869: LD_INT 0
1871: PPUSH
1872: CALL 6204 0 3
// PrepareVehicles ;
1876: CALL 2417 0 0
// other_survivors = CreateCharacterSet ( 07_other_survivors ) ;
1880: LD_ADDR_VAR 0 4
1884: PUSH
1885: LD_STRING 07_other_survivors
1887: PPUSH
1888: CALL_OW 31
1892: ST_TO_ADDR
// other_survivors = other_survivors ^ CreateCharacterSet ( 04_other_survivors ) ;
1893: LD_ADDR_VAR 0 4
1897: PUSH
1898: LD_VAR 0 4
1902: PUSH
1903: LD_STRING 04_other_survivors
1905: PPUSH
1906: CALL_OW 31
1910: ADD
1911: ST_TO_ADDR
// other_survivors = other_survivors ^ CreateCharacterSet ( 04_other_survivors_with_popov ) ;
1912: LD_ADDR_VAR 0 4
1916: PUSH
1917: LD_VAR 0 4
1921: PUSH
1922: LD_STRING 04_other_survivors_with_popov
1924: PPUSH
1925: CALL_OW 31
1929: ADD
1930: ST_TO_ADDR
// for un in other_survivors do
1931: LD_ADDR_VAR 0 3
1935: PUSH
1936: LD_VAR 0 4
1940: PUSH
1941: FOR_IN
1942: IFFALSE 2028
// begin emptyVeh = FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_vehicle ] , [ f_empty ] ] ) ;
1944: LD_ADDR_VAR 0 6
1948: PUSH
1949: LD_INT 22
1951: PUSH
1952: LD_INT 3
1954: PUSH
1955: EMPTY
1956: LIST
1957: LIST
1958: PUSH
1959: LD_INT 21
1961: PUSH
1962: LD_INT 2
1964: PUSH
1965: EMPTY
1966: LIST
1967: LIST
1968: PUSH
1969: LD_INT 58
1971: PUSH
1972: EMPTY
1973: LIST
1974: PUSH
1975: EMPTY
1976: LIST
1977: LIST
1978: LIST
1979: PPUSH
1980: CALL_OW 69
1984: ST_TO_ADDR
// if emptyVeh then
1985: LD_VAR 0 6
1989: IFFALSE 2011
// PlaceHumanInUnit ( un , emptyVeh [ 1 ] ) else
1991: LD_VAR 0 3
1995: PPUSH
1996: LD_VAR 0 6
2000: PUSH
2001: LD_INT 1
2003: ARRAY
2004: PPUSH
2005: CALL_OW 52
2009: GO 2026
// PlaceUnitArea ( un , RussianSpawnArea , false ) ;
2011: LD_VAR 0 3
2015: PPUSH
2016: LD_INT 2
2018: PPUSH
2019: LD_INT 0
2021: PPUSH
2022: CALL_OW 49
// end ;
2026: GO 1941
2028: POP
2029: POP
// yourUnits = FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_nation , nation_russian ] ] ) ;
2030: LD_ADDR_VAR 0 5
2034: PUSH
2035: LD_INT 22
2037: PUSH
2038: LD_INT 3
2040: PUSH
2041: EMPTY
2042: LIST
2043: LIST
2044: PUSH
2045: LD_INT 21
2047: PUSH
2048: LD_INT 1
2050: PUSH
2051: EMPTY
2052: LIST
2053: LIST
2054: PUSH
2055: LD_INT 23
2057: PUSH
2058: LD_INT 3
2060: PUSH
2061: EMPTY
2062: LIST
2063: LIST
2064: PUSH
2065: EMPTY
2066: LIST
2067: LIST
2068: LIST
2069: PPUSH
2070: CALL_OW 69
2074: ST_TO_ADDR
// if yourUnits < 15 then
2075: LD_VAR 0 5
2079: PUSH
2080: LD_INT 15
2082: LESS
2083: IFFALSE 2232
// for i := 1 to 15 - yourUnits do
2085: LD_ADDR_VAR 0 2
2089: PUSH
2090: DOUBLE
2091: LD_INT 1
2093: DEC
2094: ST_TO_ADDR
2095: LD_INT 15
2097: PUSH
2098: LD_VAR 0 5
2102: MINUS
2103: PUSH
2104: FOR_TO
2105: IFFALSE 2230
// begin PrepareHuman ( false , rand ( 1 , 4 ) , rand ( 2 , 4 ) ) ;
2107: LD_INT 0
2109: PPUSH
2110: LD_INT 1
2112: PPUSH
2113: LD_INT 4
2115: PPUSH
2116: CALL_OW 12
2120: PPUSH
2121: LD_INT 2
2123: PPUSH
2124: LD_INT 4
2126: PPUSH
2127: CALL_OW 12
2131: PPUSH
2132: CALL_OW 380
// un = CreateHuman ;
2136: LD_ADDR_VAR 0 3
2140: PUSH
2141: CALL_OW 44
2145: ST_TO_ADDR
// emptyVeh = FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_vehicle ] , [ f_empty ] ] ) ;
2146: LD_ADDR_VAR 0 6
2150: PUSH
2151: LD_INT 22
2153: PUSH
2154: LD_INT 3
2156: PUSH
2157: EMPTY
2158: LIST
2159: LIST
2160: PUSH
2161: LD_INT 21
2163: PUSH
2164: LD_INT 2
2166: PUSH
2167: EMPTY
2168: LIST
2169: LIST
2170: PUSH
2171: LD_INT 58
2173: PUSH
2174: EMPTY
2175: LIST
2176: PUSH
2177: EMPTY
2178: LIST
2179: LIST
2180: LIST
2181: PPUSH
2182: CALL_OW 69
2186: ST_TO_ADDR
// if emptyVeh then
2187: LD_VAR 0 6
2191: IFFALSE 2213
// PlaceHumanInUnit ( un , emptyVeh [ 1 ] ) else
2193: LD_VAR 0 3
2197: PPUSH
2198: LD_VAR 0 6
2202: PUSH
2203: LD_INT 1
2205: ARRAY
2206: PPUSH
2207: CALL_OW 52
2211: GO 2228
// PlaceUnitArea ( un , RussianSpawnArea , false ) ;
2213: LD_VAR 0 3
2217: PPUSH
2218: LD_INT 2
2220: PPUSH
2221: LD_INT 0
2223: PPUSH
2224: CALL_OW 49
// end ;
2228: GO 2104
2230: POP
2231: POP
// yourUnits = FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_nation , nation_russian ] ] ) ;
2232: LD_ADDR_VAR 0 5
2236: PUSH
2237: LD_INT 22
2239: PUSH
2240: LD_INT 3
2242: PUSH
2243: EMPTY
2244: LIST
2245: LIST
2246: PUSH
2247: LD_INT 21
2249: PUSH
2250: LD_INT 1
2252: PUSH
2253: EMPTY
2254: LIST
2255: LIST
2256: PUSH
2257: LD_INT 23
2259: PUSH
2260: LD_INT 3
2262: PUSH
2263: EMPTY
2264: LIST
2265: LIST
2266: PUSH
2267: EMPTY
2268: LIST
2269: LIST
2270: LIST
2271: PPUSH
2272: CALL_OW 69
2276: ST_TO_ADDR
// if not UnitFilter ( yourUnits , [ f_class , class_engineer ] ) then
2277: LD_VAR 0 5
2281: PPUSH
2282: LD_INT 25
2284: PUSH
2285: LD_INT 2
2287: PUSH
2288: EMPTY
2289: LIST
2290: LIST
2291: PPUSH
2292: CALL_OW 72
2296: NOT
2297: IFFALSE 2315
// SetClass ( yourUnits [ 1 ] , 2 ) ;
2299: LD_VAR 0 5
2303: PUSH
2304: LD_INT 1
2306: ARRAY
2307: PPUSH
2308: LD_INT 2
2310: PPUSH
2311: CALL_OW 336
// end ;
2315: LD_VAR 0 1
2319: RET
// export function PrepareRussianEscort ; var i , unit ; begin
2320: LD_INT 0
2322: PPUSH
2323: PPUSH
2324: PPUSH
// uc_side = 6 ;
2325: LD_ADDR_OWVAR 20
2329: PUSH
2330: LD_INT 6
2332: ST_TO_ADDR
// uc_nation = 3 ;
2333: LD_ADDR_OWVAR 21
2337: PUSH
2338: LD_INT 3
2340: ST_TO_ADDR
// for i := 1 to 2 do
2341: LD_ADDR_VAR 0 2
2345: PUSH
2346: DOUBLE
2347: LD_INT 1
2349: DEC
2350: ST_TO_ADDR
2351: LD_INT 2
2353: PUSH
2354: FOR_TO
2355: IFFALSE 2410
// begin PrepareSoldier ( false , 4 ) ;
2357: LD_INT 0
2359: PPUSH
2360: LD_INT 4
2362: PPUSH
2363: CALL_OW 381
// unit = CreateHuman ;
2367: LD_ADDR_VAR 0 3
2371: PUSH
2372: CALL_OW 44
2376: ST_TO_ADDR
// russianEscort = russianEscort ^ unit ;
2377: LD_ADDR_EXP 77
2381: PUSH
2382: LD_EXP 77
2386: PUSH
2387: LD_VAR 0 3
2391: ADD
2392: ST_TO_ADDR
// PlaceUnitArea ( unit , RussianSpawn2Area , false ) ;
2393: LD_VAR 0 3
2397: PPUSH
2398: LD_INT 7
2400: PPUSH
2401: LD_INT 0
2403: PPUSH
2404: CALL_OW 49
// end ;
2408: GO 2354
2410: POP
2411: POP
// end ;
2412: LD_VAR 0 1
2416: RET
// function PrepareVehicles ; var i , veh ; begin
2417: LD_INT 0
2419: PPUSH
2420: PPUSH
2421: PPUSH
// uc_side = 3 ;
2422: LD_ADDR_OWVAR 20
2426: PUSH
2427: LD_INT 3
2429: ST_TO_ADDR
// uc_nation = 3 ;
2430: LD_ADDR_OWVAR 21
2434: PUSH
2435: LD_INT 3
2437: ST_TO_ADDR
// for i := 1 to 5 do
2438: LD_ADDR_VAR 0 2
2442: PUSH
2443: DOUBLE
2444: LD_INT 1
2446: DEC
2447: ST_TO_ADDR
2448: LD_INT 5
2450: PUSH
2451: FOR_TO
2452: IFFALSE 2562
// begin PrepareVehicle ( ru_medium_wheeled , engine_combustion , control_manual , ru_cargo_bay , rand ( 60 , 80 ) ) ;
2454: LD_INT 21
2456: PPUSH
2457: LD_INT 1
2459: PPUSH
2460: LD_INT 1
2462: PPUSH
2463: LD_INT 51
2465: PPUSH
2466: LD_INT 60
2468: PPUSH
2469: LD_INT 80
2471: PPUSH
2472: CALL_OW 12
2476: PPUSH
2477: CALL 24241 0 5
// veh = CreateVehicle ;
2481: LD_ADDR_VAR 0 3
2485: PUSH
2486: CALL_OW 45
2490: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
2491: LD_VAR 0 3
2495: PPUSH
2496: LD_INT 4
2498: PPUSH
2499: CALL_OW 233
// PlaceUnitArea ( veh , RussianSpawnArea , false ) ;
2503: LD_VAR 0 3
2507: PPUSH
2508: LD_INT 2
2510: PPUSH
2511: LD_INT 0
2513: PPUSH
2514: CALL_OW 49
// if ( i <> 5 ) then
2518: LD_VAR 0 2
2522: PUSH
2523: LD_INT 5
2525: NONEQUAL
2526: IFFALSE 2545
// AddCargo ( veh , mat_cans , 100 ) else
2528: LD_VAR 0 3
2532: PPUSH
2533: LD_INT 1
2535: PPUSH
2536: LD_INT 100
2538: PPUSH
2539: CALL_OW 291
2543: GO 2560
// AddCargo ( veh , mat_oil , 100 ) ;
2545: LD_VAR 0 3
2549: PPUSH
2550: LD_INT 2
2552: PPUSH
2553: LD_INT 100
2555: PPUSH
2556: CALL_OW 291
// end ;
2560: GO 2451
2562: POP
2563: POP
// PrepareVehicle ( ru_medium_wheeled , engine_combustion , control_manual , ru_crane , rand ( 60 , 80 ) ) ;
2564: LD_INT 21
2566: PPUSH
2567: LD_INT 1
2569: PPUSH
2570: LD_INT 1
2572: PPUSH
2573: LD_INT 52
2575: PPUSH
2576: LD_INT 60
2578: PPUSH
2579: LD_INT 80
2581: PPUSH
2582: CALL_OW 12
2586: PPUSH
2587: CALL 24241 0 5
// veh = CreateVehicle ;
2591: LD_ADDR_VAR 0 3
2595: PUSH
2596: CALL_OW 45
2600: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
2601: LD_VAR 0 3
2605: PPUSH
2606: LD_INT 4
2608: PPUSH
2609: CALL_OW 233
// PlaceUnitArea ( veh , RussianSpawnArea , false ) ;
2613: LD_VAR 0 3
2617: PPUSH
2618: LD_INT 2
2620: PPUSH
2621: LD_INT 0
2623: PPUSH
2624: CALL_OW 49
// for i := 1 to 3 do
2628: LD_ADDR_VAR 0 2
2632: PUSH
2633: DOUBLE
2634: LD_INT 1
2636: DEC
2637: ST_TO_ADDR
2638: LD_INT 3
2640: PUSH
2641: FOR_TO
2642: IFFALSE 2710
// begin PrepareVehicle ( ru_heavy_tracked , engine_combustion , control_manual , ru_bulldozer , rand ( 60 , 80 ) ) ;
2644: LD_INT 24
2646: PPUSH
2647: LD_INT 1
2649: PPUSH
2650: LD_INT 1
2652: PPUSH
2653: LD_INT 53
2655: PPUSH
2656: LD_INT 60
2658: PPUSH
2659: LD_INT 80
2661: PPUSH
2662: CALL_OW 12
2666: PPUSH
2667: CALL 24241 0 5
// veh = CreateVehicle ;
2671: LD_ADDR_VAR 0 3
2675: PUSH
2676: CALL_OW 45
2680: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
2681: LD_VAR 0 3
2685: PPUSH
2686: LD_INT 4
2688: PPUSH
2689: CALL_OW 233
// PlaceUnitArea ( veh , RussianSpawnArea , false ) ;
2693: LD_VAR 0 3
2697: PPUSH
2698: LD_INT 2
2700: PPUSH
2701: LD_INT 0
2703: PPUSH
2704: CALL_OW 49
// end ;
2708: GO 2641
2710: POP
2711: POP
// end ;
2712: LD_VAR 0 1
2716: RET
// function InitRussianRequiments ; var i ; begin
2717: LD_INT 0
2719: PPUSH
2720: PPUSH
// availableWeapons = [ ru_heavy_machine_gun , ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher ] ;
2721: LD_ADDR_EXP 11
2725: PUSH
2726: LD_INT 42
2728: PUSH
2729: LD_INT 43
2731: PUSH
2732: LD_INT 44
2734: PUSH
2735: LD_INT 46
2737: PUSH
2738: LD_INT 45
2740: PUSH
2741: EMPTY
2742: LIST
2743: LIST
2744: LIST
2745: LIST
2746: LIST
2747: ST_TO_ADDR
// for i := 1 to availableWeapons do
2748: LD_ADDR_VAR 0 2
2752: PUSH
2753: DOUBLE
2754: LD_INT 1
2756: DEC
2757: ST_TO_ADDR
2758: LD_EXP 11
2762: PUSH
2763: FOR_TO
2764: IFFALSE 2804
// weaponsData = weaponsData ^ [ [ availableWeapons [ i ] , false , false ] ] ;
2766: LD_ADDR_EXP 12
2770: PUSH
2771: LD_EXP 12
2775: PUSH
2776: LD_EXP 11
2780: PUSH
2781: LD_VAR 0 2
2785: ARRAY
2786: PUSH
2787: LD_INT 0
2789: PUSH
2790: LD_INT 0
2792: PUSH
2793: EMPTY
2794: LIST
2795: LIST
2796: LIST
2797: PUSH
2798: EMPTY
2799: LIST
2800: ADD
2801: ST_TO_ADDR
2802: GO 2763
2804: POP
2805: POP
// for i := 0 to 50 do
2806: LD_ADDR_VAR 0 2
2810: PUSH
2811: DOUBLE
2812: LD_INT 0
2814: DEC
2815: ST_TO_ADDR
2816: LD_INT 50
2818: PUSH
2819: FOR_TO
2820: IFFALSE 2858
// if GetRestrict ( i , 3 ) = state_enabled then
2822: LD_VAR 0 2
2826: PPUSH
2827: LD_INT 3
2829: PPUSH
2830: CALL_OW 323
2834: PUSH
2835: LD_INT 1
2837: EQUAL
2838: IFFALSE 2856
// buildingsToBuild = buildingsToBuild ^ i ;
2840: LD_ADDR_EXP 8
2844: PUSH
2845: LD_EXP 8
2849: PUSH
2850: LD_VAR 0 2
2854: ADD
2855: ST_TO_ADDR
2856: GO 2819
2858: POP
2859: POP
// buildingsToBuild = buildingsToBuild diff [ 0 , 2 , 4 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 14 , 22 , 31 , 32 , 33 , 39 , 40 ] ;
2860: LD_ADDR_EXP 8
2864: PUSH
2865: LD_EXP 8
2869: PUSH
2870: LD_INT 0
2872: PUSH
2873: LD_INT 2
2875: PUSH
2876: LD_INT 4
2878: PUSH
2879: LD_INT 6
2881: PUSH
2882: LD_INT 7
2884: PUSH
2885: LD_INT 8
2887: PUSH
2888: LD_INT 9
2890: PUSH
2891: LD_INT 10
2893: PUSH
2894: LD_INT 11
2896: PUSH
2897: LD_INT 12
2899: PUSH
2900: LD_INT 14
2902: PUSH
2903: LD_INT 22
2905: PUSH
2906: LD_INT 31
2908: PUSH
2909: LD_INT 32
2911: PUSH
2912: LD_INT 33
2914: PUSH
2915: LD_INT 39
2917: PUSH
2918: LD_INT 40
2920: PUSH
2921: EMPTY
2922: LIST
2923: LIST
2924: LIST
2925: LIST
2926: LIST
2927: LIST
2928: LIST
2929: LIST
2930: LIST
2931: LIST
2932: LIST
2933: LIST
2934: LIST
2935: LIST
2936: LIST
2937: LIST
2938: LIST
2939: DIFF
2940: ST_TO_ADDR
// allBuildings = buildingsToBuild ;
2941: LD_ADDR_EXP 13
2945: PUSH
2946: LD_EXP 8
2950: ST_TO_ADDR
// techsToResearch = GetTechNation ( 3 , nation_russian , state_enabled ) ;
2951: LD_ADDR_EXP 9
2955: PUSH
2956: LD_INT 3
2958: PPUSH
2959: LD_INT 3
2961: PPUSH
2962: LD_INT 1
2964: PPUSH
2965: CALL 19287 0 3
2969: ST_TO_ADDR
// end ; end_of_file
2970: LD_VAR 0 1
2974: RET
// export amAttackTeam ; export function PrepareAmericans ; begin
2975: LD_INT 0
2977: PPUSH
// amAttackTeam = [ ] ;
2978: LD_ADDR_EXP 78
2982: PUSH
2983: EMPTY
2984: ST_TO_ADDR
// SpawnAmericansSnipers ;
2985: CALL 3119 0 0
// case Difficulty of 2 :
2989: LD_OWVAR 67
2993: PUSH
2994: LD_INT 2
2996: DOUBLE
2997: EQUAL
2998: IFTRUE 3002
3000: GO 3031
3002: POP
// begin SetTech ( tech_comp1 , 1 , state_researched ) ;
3003: LD_INT 57
3005: PPUSH
3006: LD_INT 1
3008: PPUSH
3009: LD_INT 2
3011: PPUSH
3012: CALL_OW 322
// SetTech ( tech_opto1 , 1 , state_researched ) ;
3016: LD_INT 60
3018: PPUSH
3019: LD_INT 1
3021: PPUSH
3022: LD_INT 2
3024: PPUSH
3025: CALL_OW 322
// end ; 3 .. 4 :
3029: GO 3114
3031: LD_INT 3
3033: DOUBLE
3034: GREATEREQUAL
3035: IFFALSE 3043
3037: LD_INT 4
3039: DOUBLE
3040: LESSEQUAL
3041: IFTRUE 3045
3043: GO 3113
3045: POP
// begin SetTech ( tech_comp1 , 1 , state_researched ) ;
3046: LD_INT 57
3048: PPUSH
3049: LD_INT 1
3051: PPUSH
3052: LD_INT 2
3054: PPUSH
3055: CALL_OW 322
// SetTech ( tech_comp2 , 1 , state_researched ) ;
3059: LD_INT 58
3061: PPUSH
3062: LD_INT 1
3064: PPUSH
3065: LD_INT 2
3067: PPUSH
3068: CALL_OW 322
// SetTech ( tech_weap3 , 1 , state_researched ) ;
3072: LD_INT 53
3074: PPUSH
3075: LD_INT 1
3077: PPUSH
3078: LD_INT 2
3080: PPUSH
3081: CALL_OW 322
// SetTech ( tech_opto1 , 1 , state_researched ) ;
3085: LD_INT 60
3087: PPUSH
3088: LD_INT 1
3090: PPUSH
3091: LD_INT 2
3093: PPUSH
3094: CALL_OW 322
// SetTech ( tech_opto2 , 1 , state_researched ) ;
3098: LD_INT 61
3100: PPUSH
3101: LD_INT 1
3103: PPUSH
3104: LD_INT 2
3106: PPUSH
3107: CALL_OW 322
// end ; end ;
3111: GO 3114
3113: POP
// end ;
3114: LD_VAR 0 1
3118: RET
// export function SpawnAmericansSnipers ; var i , un ; begin
3119: LD_INT 0
3121: PPUSH
3122: PPUSH
3123: PPUSH
// uc_side = 1 ;
3124: LD_ADDR_OWVAR 20
3128: PUSH
3129: LD_INT 1
3131: ST_TO_ADDR
// uc_nation = 1 ;
3132: LD_ADDR_OWVAR 21
3136: PUSH
3137: LD_INT 1
3139: ST_TO_ADDR
// for i := 1 to 8 do
3140: LD_ADDR_VAR 0 2
3144: PUSH
3145: DOUBLE
3146: LD_INT 1
3148: DEC
3149: ST_TO_ADDR
3150: LD_INT 8
3152: PUSH
3153: FOR_TO
3154: IFFALSE 3207
// begin PrepareHuman ( false , class_sniper , enemySkillLevel ) ;
3156: LD_INT 0
3158: PPUSH
3159: LD_INT 5
3161: PPUSH
3162: LD_EXP 56
3166: PPUSH
3167: CALL_OW 380
// un = CreateHuman ;
3171: LD_ADDR_VAR 0 3
3175: PUSH
3176: CALL_OW 44
3180: ST_TO_ADDR
// PlaceUnitArea ( un , AmericansSnipersSpawnArea , false ) ;
3181: LD_VAR 0 3
3185: PPUSH
3186: LD_INT 14
3188: PPUSH
3189: LD_INT 0
3191: PPUSH
3192: CALL_OW 49
// ComHold ( un ) ;
3196: LD_VAR 0 3
3200: PPUSH
3201: CALL_OW 140
// end ;
3205: GO 3153
3207: POP
3208: POP
// end ;
3209: LD_VAR 0 1
3213: RET
// export function SpawnAmAttackTeam ; var i , unit , veh , randVehType , weapon , chassis , amSolds , amSnipers , amVehs ; begin
3214: LD_INT 0
3216: PPUSH
3217: PPUSH
3218: PPUSH
3219: PPUSH
3220: PPUSH
3221: PPUSH
3222: PPUSH
3223: PPUSH
3224: PPUSH
3225: PPUSH
// uc_side = 1 ;
3226: LD_ADDR_OWVAR 20
3230: PUSH
3231: LD_INT 1
3233: ST_TO_ADDR
// uc_nation = 1 ;
3234: LD_ADDR_OWVAR 21
3238: PUSH
3239: LD_INT 1
3241: ST_TO_ADDR
// amSolds = Rand ( enemyAttackUnitsData [ 1 ] [ 2 ] , enemyAttackUnitsData [ 1 ] [ 3 ] ) ;
3242: LD_ADDR_VAR 0 8
3246: PUSH
3247: LD_EXP 53
3251: PUSH
3252: LD_INT 1
3254: ARRAY
3255: PUSH
3256: LD_INT 2
3258: ARRAY
3259: PPUSH
3260: LD_EXP 53
3264: PUSH
3265: LD_INT 1
3267: ARRAY
3268: PUSH
3269: LD_INT 3
3271: ARRAY
3272: PPUSH
3273: CALL_OW 12
3277: ST_TO_ADDR
// amSnipers = Rand ( enemyAttackUnitsData [ 1 ] [ 4 ] , enemyAttackUnitsData [ 1 ] [ 5 ] ) ;
3278: LD_ADDR_VAR 0 9
3282: PUSH
3283: LD_EXP 53
3287: PUSH
3288: LD_INT 1
3290: ARRAY
3291: PUSH
3292: LD_INT 4
3294: ARRAY
3295: PPUSH
3296: LD_EXP 53
3300: PUSH
3301: LD_INT 1
3303: ARRAY
3304: PUSH
3305: LD_INT 5
3307: ARRAY
3308: PPUSH
3309: CALL_OW 12
3313: ST_TO_ADDR
// amVehs = Rand ( enemyAttackUnitsData [ 1 ] [ 6 ] , enemyAttackUnitsData [ 1 ] [ 7 ] ) ;
3314: LD_ADDR_VAR 0 10
3318: PUSH
3319: LD_EXP 53
3323: PUSH
3324: LD_INT 1
3326: ARRAY
3327: PUSH
3328: LD_INT 6
3330: ARRAY
3331: PPUSH
3332: LD_EXP 53
3336: PUSH
3337: LD_INT 1
3339: ARRAY
3340: PUSH
3341: LD_INT 7
3343: ARRAY
3344: PPUSH
3345: CALL_OW 12
3349: ST_TO_ADDR
// if paidLegionOffert then
3350: LD_EXP 32
3354: IFFALSE 3388
// begin amSolds = amSolds - legionReduceAmericansUnits ;
3356: LD_ADDR_VAR 0 8
3360: PUSH
3361: LD_VAR 0 8
3365: PUSH
3366: LD_EXP 51
3370: MINUS
3371: ST_TO_ADDR
// amVehs = amVehs - legionReduceAmericansUnits ;
3372: LD_ADDR_VAR 0 10
3376: PUSH
3377: LD_VAR 0 10
3381: PUSH
3382: LD_EXP 51
3386: MINUS
3387: ST_TO_ADDR
// end ; for i := 1 to amSolds do
3388: LD_ADDR_VAR 0 2
3392: PUSH
3393: DOUBLE
3394: LD_INT 1
3396: DEC
3397: ST_TO_ADDR
3398: LD_VAR 0 8
3402: PUSH
3403: FOR_TO
3404: IFFALSE 3461
// begin PrepareSoldier ( false , enemySkillLevel ) ;
3406: LD_INT 0
3408: PPUSH
3409: LD_EXP 56
3413: PPUSH
3414: CALL_OW 381
// unit = CreateHuman ;
3418: LD_ADDR_VAR 0 3
3422: PUSH
3423: CALL_OW 44
3427: ST_TO_ADDR
// PlaceUnitArea ( unit , AmericanSpawnArea , false ) ;
3428: LD_VAR 0 3
3432: PPUSH
3433: LD_INT 3
3435: PPUSH
3436: LD_INT 0
3438: PPUSH
3439: CALL_OW 49
// amAttackTeam = amAttackTeam ^ unit ;
3443: LD_ADDR_EXP 78
3447: PUSH
3448: LD_EXP 78
3452: PUSH
3453: LD_VAR 0 3
3457: ADD
3458: ST_TO_ADDR
// end ;
3459: GO 3403
3461: POP
3462: POP
// for i := 1 to amSnipers do
3463: LD_ADDR_VAR 0 2
3467: PUSH
3468: DOUBLE
3469: LD_INT 1
3471: DEC
3472: ST_TO_ADDR
3473: LD_VAR 0 9
3477: PUSH
3478: FOR_TO
3479: IFFALSE 3539
// begin PrepareHuman ( false , class_sniper , enemySkillLevel ) ;
3481: LD_INT 0
3483: PPUSH
3484: LD_INT 5
3486: PPUSH
3487: LD_EXP 56
3491: PPUSH
3492: CALL_OW 380
// unit = CreateHuman ;
3496: LD_ADDR_VAR 0 3
3500: PUSH
3501: CALL_OW 44
3505: ST_TO_ADDR
// PlaceUnitArea ( unit , AmericanSpawnArea , false ) ;
3506: LD_VAR 0 3
3510: PPUSH
3511: LD_INT 3
3513: PPUSH
3514: LD_INT 0
3516: PPUSH
3517: CALL_OW 49
// amAttackTeam = amAttackTeam ^ unit ;
3521: LD_ADDR_EXP 78
3525: PUSH
3526: LD_EXP 78
3530: PUSH
3531: LD_VAR 0 3
3535: ADD
3536: ST_TO_ADDR
// end ;
3537: GO 3478
3539: POP
3540: POP
// for i := 1 to amVehs do
3541: LD_ADDR_VAR 0 2
3545: PUSH
3546: DOUBLE
3547: LD_INT 1
3549: DEC
3550: ST_TO_ADDR
3551: LD_VAR 0 10
3555: PUSH
3556: FOR_TO
3557: IFFALSE 3840
// begin randVehType = Rand ( 1 , 4 ) ;
3559: LD_ADDR_VAR 0 5
3563: PUSH
3564: LD_INT 1
3566: PPUSH
3567: LD_INT 4
3569: PPUSH
3570: CALL_OW 12
3574: ST_TO_ADDR
// weapon = [ us_gatling_gun , us_double_gun , us_light_gun , us_rocket_launcher , us_heavy_gun ] [ Rand ( 1 , 5 ) ] ;
3575: LD_ADDR_VAR 0 6
3579: PUSH
3580: LD_INT 4
3582: PUSH
3583: LD_INT 5
3585: PUSH
3586: LD_INT 3
3588: PUSH
3589: LD_INT 7
3591: PUSH
3592: LD_INT 6
3594: PUSH
3595: EMPTY
3596: LIST
3597: LIST
3598: LIST
3599: LIST
3600: LIST
3601: PUSH
3602: LD_INT 1
3604: PPUSH
3605: LD_INT 5
3607: PPUSH
3608: CALL_OW 12
3612: ARRAY
3613: ST_TO_ADDR
// if weapon = us_heavy_gun then
3614: LD_VAR 0 6
3618: PUSH
3619: LD_INT 6
3621: EQUAL
3622: IFFALSE 3634
// chassis = us_heavy_tracked else
3624: LD_ADDR_VAR 0 7
3628: PUSH
3629: LD_INT 4
3631: ST_TO_ADDR
3632: GO 3661
// chassis = [ us_medium_tracked , us_heavy_tracked ] [ Rand ( 1 , 2 ) ] ;
3634: LD_ADDR_VAR 0 7
3638: PUSH
3639: LD_INT 3
3641: PUSH
3642: LD_INT 4
3644: PUSH
3645: EMPTY
3646: LIST
3647: LIST
3648: PUSH
3649: LD_INT 1
3651: PPUSH
3652: LD_INT 2
3654: PPUSH
3655: CALL_OW 12
3659: ARRAY
3660: ST_TO_ADDR
// if randVehType = 1 then
3661: LD_VAR 0 5
3665: PUSH
3666: LD_INT 1
3668: EQUAL
3669: IFFALSE 3704
// PrepareVehicle ( chassis , engine_combustion , control_manual , weapon , Rand ( 70 , 90 ) ) else
3671: LD_VAR 0 7
3675: PPUSH
3676: LD_INT 1
3678: PPUSH
3679: LD_INT 1
3681: PPUSH
3682: LD_VAR 0 6
3686: PPUSH
3687: LD_INT 70
3689: PPUSH
3690: LD_INT 90
3692: PPUSH
3693: CALL_OW 12
3697: PPUSH
3698: CALL 24241 0 5
3702: GO 3735
// PrepareVehicle ( chassis , engine_combustion , control_computer , weapon , Rand ( 70 , 90 ) ) ;
3704: LD_VAR 0 7
3708: PPUSH
3709: LD_INT 1
3711: PPUSH
3712: LD_INT 3
3714: PPUSH
3715: LD_VAR 0 6
3719: PPUSH
3720: LD_INT 70
3722: PPUSH
3723: LD_INT 90
3725: PPUSH
3726: CALL_OW 12
3730: PPUSH
3731: CALL 24241 0 5
// veh = CreateVehicle ;
3735: LD_ADDR_VAR 0 4
3739: PUSH
3740: CALL_OW 45
3744: ST_TO_ADDR
// PlaceUnitArea ( veh , AmericanSpawnArea , false ) ;
3745: LD_VAR 0 4
3749: PPUSH
3750: LD_INT 3
3752: PPUSH
3753: LD_INT 0
3755: PPUSH
3756: CALL_OW 49
// amAttackTeam = amAttackTeam ^ veh ;
3760: LD_ADDR_EXP 78
3764: PUSH
3765: LD_EXP 78
3769: PUSH
3770: LD_VAR 0 4
3774: ADD
3775: ST_TO_ADDR
// if randVehType = 1 then
3776: LD_VAR 0 5
3780: PUSH
3781: LD_INT 1
3783: EQUAL
3784: IFFALSE 3838
// begin PrepareMechanic ( false , enemySkillLevel ) ;
3786: LD_INT 0
3788: PPUSH
3789: LD_EXP 56
3793: PPUSH
3794: CALL_OW 383
// unit = CreateHuman ;
3798: LD_ADDR_VAR 0 3
3802: PUSH
3803: CALL_OW 44
3807: ST_TO_ADDR
// PlaceHumanInUnit ( unit , veh ) ;
3808: LD_VAR 0 3
3812: PPUSH
3813: LD_VAR 0 4
3817: PPUSH
3818: CALL_OW 52
// amAttackTeam = amAttackTeam ^ unit ;
3822: LD_ADDR_EXP 78
3826: PUSH
3827: LD_EXP 78
3831: PUSH
3832: LD_VAR 0 3
3836: ADD
3837: ST_TO_ADDR
// end ; end ;
3838: GO 3556
3840: POP
3841: POP
// end ; end_of_file
3842: LD_VAR 0 1
3846: RET
// export Heike , Kurt , Dietrich ; export KurtEng ; export GensherTeam ; export arAttackTeam ; export function PrepareArabians ; begin
3847: LD_INT 0
3849: PPUSH
// arAttackTeam = [ ] ;
3850: LD_ADDR_EXP 84
3854: PUSH
3855: EMPTY
3856: ST_TO_ADDR
// PrepareHeroes ;
3857: CALL 4262 0 0
// case Difficulty of 2 :
3861: LD_OWVAR 67
3865: PUSH
3866: LD_INT 2
3868: DOUBLE
3869: EQUAL
3870: IFTRUE 3874
3872: GO 3890
3874: POP
// begin SetTech ( tech_stimDrugs , 8 , state_researched ) ;
3875: LD_INT 5
3877: PPUSH
3878: LD_INT 8
3880: PPUSH
3881: LD_INT 2
3883: PPUSH
3884: CALL_OW 322
// end ; 3 :
3888: GO 3941
3890: LD_INT 3
3892: DOUBLE
3893: EQUAL
3894: IFTRUE 3898
3896: GO 3940
3898: POP
// begin SetTech ( tech_stimDrugs , 8 , state_researched ) ;
3899: LD_INT 5
3901: PPUSH
3902: LD_INT 8
3904: PPUSH
3905: LD_INT 2
3907: PPUSH
3908: CALL_OW 322
// SetTech ( tech_bio1 , 8 , state_researched ) ;
3912: LD_INT 66
3914: PPUSH
3915: LD_INT 8
3917: PPUSH
3918: LD_INT 2
3920: PPUSH
3921: CALL_OW 322
// SetTech ( tech_weap3 , 8 , state_researched ) ;
3925: LD_INT 53
3927: PPUSH
3928: LD_INT 8
3930: PPUSH
3931: LD_INT 2
3933: PPUSH
3934: CALL_OW 322
// end ; end ;
3938: GO 3941
3940: POP
// end ;
3941: LD_VAR 0 1
3945: RET
// export function SpawnGensherTeam ; var i , driver , veh ; begin
3946: LD_INT 0
3948: PPUSH
3949: PPUSH
3950: PPUSH
3951: PPUSH
// GensherTeam = [ ] ;
3952: LD_ADDR_EXP 83
3956: PUSH
3957: EMPTY
3958: ST_TO_ADDR
// uc_side = 2 ;
3959: LD_ADDR_OWVAR 20
3963: PUSH
3964: LD_INT 2
3966: ST_TO_ADDR
// uc_nation = 2 ;
3967: LD_ADDR_OWVAR 21
3971: PUSH
3972: LD_INT 2
3974: ST_TO_ADDR
// for i := 1 to 3 do
3975: LD_ADDR_VAR 0 2
3979: PUSH
3980: DOUBLE
3981: LD_INT 1
3983: DEC
3984: ST_TO_ADDR
3985: LD_INT 3
3987: PUSH
3988: FOR_TO
3989: IFFALSE 4148
// begin PrepareSoldier ( sex_male , rand ( 3 , 5 ) ) ;
3991: LD_INT 1
3993: PPUSH
3994: LD_INT 3
3996: PPUSH
3997: LD_INT 5
3999: PPUSH
4000: CALL_OW 12
4004: PPUSH
4005: CALL_OW 381
// driver = CreateHuman ;
4009: LD_ADDR_VAR 0 3
4013: PUSH
4014: CALL_OW 44
4018: ST_TO_ADDR
// PrepareVehicle ( ar_medium_trike , engine_combustion , control_manual , ar_cargo_bay , rand ( 50 , 70 ) ) ;
4019: LD_INT 13
4021: PPUSH
4022: LD_INT 1
4024: PPUSH
4025: LD_INT 1
4027: PPUSH
4028: LD_INT 32
4030: PPUSH
4031: LD_INT 50
4033: PPUSH
4034: LD_INT 70
4036: PPUSH
4037: CALL_OW 12
4041: PPUSH
4042: CALL 24241 0 5
// veh = CreateVehicle ;
4046: LD_ADDR_VAR 0 4
4050: PUSH
4051: CALL_OW 45
4055: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
4056: LD_VAR 0 4
4060: PPUSH
4061: LD_INT 4
4063: PPUSH
4064: CALL_OW 233
// PlaceUnitArea ( veh , GensherSpawnArea , false ) ;
4068: LD_VAR 0 4
4072: PPUSH
4073: LD_INT 4
4075: PPUSH
4076: LD_INT 0
4078: PPUSH
4079: CALL_OW 49
// PlaceHumanInUnit ( driver , veh ) ;
4083: LD_VAR 0 3
4087: PPUSH
4088: LD_VAR 0 4
4092: PPUSH
4093: CALL_OW 52
// AddCargo ( veh , i , 100 ) ;
4097: LD_VAR 0 4
4101: PPUSH
4102: LD_VAR 0 2
4106: PPUSH
4107: LD_INT 100
4109: PPUSH
4110: CALL_OW 291
// GensherTeam = GensherTeam ^ driver ;
4114: LD_ADDR_EXP 83
4118: PUSH
4119: LD_EXP 83
4123: PUSH
4124: LD_VAR 0 3
4128: ADD
4129: ST_TO_ADDR
// GensherTeam = GensherTeam ^ veh ;
4130: LD_ADDR_EXP 83
4134: PUSH
4135: LD_EXP 83
4139: PUSH
4140: LD_VAR 0 4
4144: ADD
4145: ST_TO_ADDR
// end ;
4146: GO 3988
4148: POP
4149: POP
// if IsOK ( KurtEng ) and GetSide ( KurtEng ) = 3 then
4150: LD_EXP 82
4154: PPUSH
4155: CALL_OW 302
4159: PUSH
4160: LD_EXP 82
4164: PPUSH
4165: CALL_OW 255
4169: PUSH
4170: LD_INT 3
4172: EQUAL
4173: AND
4174: IFFALSE 4208
// begin GensherTargetX = GetX ( Kurt ) ;
4176: LD_ADDR_EXP 16
4180: PUSH
4181: LD_EXP 80
4185: PPUSH
4186: CALL_OW 250
4190: ST_TO_ADDR
// GensherTargetY = GetY ( Kurt ) ;
4191: LD_ADDR_EXP 17
4195: PUSH
4196: LD_EXP 80
4200: PPUSH
4201: CALL_OW 251
4205: ST_TO_ADDR
// end else
4206: GO 4238
// begin GensherTargetX = GetX ( Burlak ) ;
4208: LD_ADDR_EXP 16
4212: PUSH
4213: LD_EXP 57
4217: PPUSH
4218: CALL_OW 250
4222: ST_TO_ADDR
// GensherTargetY = GetY ( Burlak ) ;
4223: LD_ADDR_EXP 17
4227: PUSH
4228: LD_EXP 57
4232: PPUSH
4233: CALL_OW 251
4237: ST_TO_ADDR
// end ; ComMoveXY ( GensherTeam , GensherTargetX , GensherTargetY ) ;
4238: LD_EXP 83
4242: PPUSH
4243: LD_EXP 16
4247: PPUSH
4248: LD_EXP 17
4252: PPUSH
4253: CALL_OW 111
// end ;
4257: LD_VAR 0 1
4261: RET
// function PrepareHeroes ; begin
4262: LD_INT 0
4264: PPUSH
// uc_side = 5 ;
4265: LD_ADDR_OWVAR 20
4269: PUSH
4270: LD_INT 5
4272: ST_TO_ADDR
// uc_nation = 2 ;
4273: LD_ADDR_OWVAR 21
4277: PUSH
4278: LD_INT 2
4280: ST_TO_ADDR
// Heike = PrepareUnitExt ( Heike , true , class_engineer ) ;
4281: LD_ADDR_EXP 79
4285: PUSH
4286: LD_STRING Heike
4288: PPUSH
4289: LD_INT 1
4291: PPUSH
4292: LD_INT 2
4294: PPUSH
4295: CALL 5930 0 3
4299: ST_TO_ADDR
// uc_side = 8 ;
4300: LD_ADDR_OWVAR 20
4304: PUSH
4305: LD_INT 8
4307: ST_TO_ADDR
// Kurt = PrepareUnitExt ( Kurt , false , 0 ) ;
4308: LD_ADDR_EXP 80
4312: PUSH
4313: LD_STRING Kurt
4315: PPUSH
4316: LD_INT 0
4318: PPUSH
4319: LD_INT 0
4321: PPUSH
4322: CALL 5930 0 3
4326: ST_TO_ADDR
// uc_side = 2 ;
4327: LD_ADDR_OWVAR 20
4331: PUSH
4332: LD_INT 2
4334: ST_TO_ADDR
// Dietrich = PrepareUnitExt ( Dietrich , false , 0 ) ;
4335: LD_ADDR_EXP 81
4339: PUSH
4340: LD_STRING Dietrich
4342: PPUSH
4343: LD_INT 0
4345: PPUSH
4346: LD_INT 0
4348: PPUSH
4349: CALL 5930 0 3
4353: ST_TO_ADDR
// end ;
4354: LD_VAR 0 1
4358: RET
// export function SpawnArAttackTeam ; var i , unit , veh , weapon , chassis ; begin
4359: LD_INT 0
4361: PPUSH
4362: PPUSH
4363: PPUSH
4364: PPUSH
4365: PPUSH
4366: PPUSH
// uc_side = 8 ;
4367: LD_ADDR_OWVAR 20
4371: PUSH
4372: LD_INT 8
4374: ST_TO_ADDR
// uc_nation = 2 ;
4375: LD_ADDR_OWVAR 21
4379: PUSH
4380: LD_INT 2
4382: ST_TO_ADDR
// for i := 1 to Rand ( enemyAttackUnitsData [ 1 ] [ 2 ] , enemyAttackUnitsData [ 1 ] [ 3 ] ) do
4383: LD_ADDR_VAR 0 2
4387: PUSH
4388: DOUBLE
4389: LD_INT 1
4391: DEC
4392: ST_TO_ADDR
4393: LD_EXP 53
4397: PUSH
4398: LD_INT 1
4400: ARRAY
4401: PUSH
4402: LD_INT 2
4404: ARRAY
4405: PPUSH
4406: LD_EXP 53
4410: PUSH
4411: LD_INT 1
4413: ARRAY
4414: PUSH
4415: LD_INT 3
4417: ARRAY
4418: PPUSH
4419: CALL_OW 12
4423: PUSH
4424: FOR_TO
4425: IFFALSE 4482
// begin PrepareSoldier ( false , enemySkillLevel ) ;
4427: LD_INT 0
4429: PPUSH
4430: LD_EXP 56
4434: PPUSH
4435: CALL_OW 381
// unit = CreateHuman ;
4439: LD_ADDR_VAR 0 3
4443: PUSH
4444: CALL_OW 44
4448: ST_TO_ADDR
// PlaceUnitArea ( unit , KurtUnitsSpawnArea , false ) ;
4449: LD_VAR 0 3
4453: PPUSH
4454: LD_INT 10
4456: PPUSH
4457: LD_INT 0
4459: PPUSH
4460: CALL_OW 49
// arAttackTeam = arAttackTeam ^ unit ;
4464: LD_ADDR_EXP 84
4468: PUSH
4469: LD_EXP 84
4473: PUSH
4474: LD_VAR 0 3
4478: ADD
4479: ST_TO_ADDR
// end ;
4480: GO 4424
4482: POP
4483: POP
// for i := 1 to Rand ( enemyAttackUnitsData [ 1 ] [ 4 ] , enemyAttackUnitsData [ 1 ] [ 5 ] ) do
4484: LD_ADDR_VAR 0 2
4488: PUSH
4489: DOUBLE
4490: LD_INT 1
4492: DEC
4493: ST_TO_ADDR
4494: LD_EXP 53
4498: PUSH
4499: LD_INT 1
4501: ARRAY
4502: PUSH
4503: LD_INT 4
4505: ARRAY
4506: PPUSH
4507: LD_EXP 53
4511: PUSH
4512: LD_INT 1
4514: ARRAY
4515: PUSH
4516: LD_INT 5
4518: ARRAY
4519: PPUSH
4520: CALL_OW 12
4524: PUSH
4525: FOR_TO
4526: IFFALSE 4586
// begin PrepareHuman ( false , class_mortar , enemySkillLevel ) ;
4528: LD_INT 0
4530: PPUSH
4531: LD_INT 8
4533: PPUSH
4534: LD_EXP 56
4538: PPUSH
4539: CALL_OW 380
// unit = CreateHuman ;
4543: LD_ADDR_VAR 0 3
4547: PUSH
4548: CALL_OW 44
4552: ST_TO_ADDR
// PlaceUnitArea ( unit , KurtUnitsSpawnArea , false ) ;
4553: LD_VAR 0 3
4557: PPUSH
4558: LD_INT 10
4560: PPUSH
4561: LD_INT 0
4563: PPUSH
4564: CALL_OW 49
// arAttackTeam = arAttackTeam ^ unit ;
4568: LD_ADDR_EXP 84
4572: PUSH
4573: LD_EXP 84
4577: PUSH
4578: LD_VAR 0 3
4582: ADD
4583: ST_TO_ADDR
// end ;
4584: GO 4525
4586: POP
4587: POP
// for i := 1 to Rand ( enemyAttackUnitsData [ 1 ] [ 6 ] , enemyAttackUnitsData [ 1 ] [ 7 ] ) do
4588: LD_ADDR_VAR 0 2
4592: PUSH
4593: DOUBLE
4594: LD_INT 1
4596: DEC
4597: ST_TO_ADDR
4598: LD_EXP 53
4602: PUSH
4603: LD_INT 1
4605: ARRAY
4606: PUSH
4607: LD_INT 6
4609: ARRAY
4610: PPUSH
4611: LD_EXP 53
4615: PUSH
4616: LD_INT 1
4618: ARRAY
4619: PUSH
4620: LD_INT 7
4622: ARRAY
4623: PPUSH
4624: CALL_OW 12
4628: PUSH
4629: FOR_TO
4630: IFFALSE 4824
// begin weapon = [ ar_gun , ar_flame_thrower , ar_rocket_launcher , ar_light_gun , ar_gatling_gun ] [ Rand ( 1 , 5 ) ] ;
4632: LD_ADDR_VAR 0 5
4636: PUSH
4637: LD_INT 27
4639: PUSH
4640: LD_INT 26
4642: PUSH
4643: LD_INT 28
4645: PUSH
4646: LD_INT 23
4648: PUSH
4649: LD_INT 25
4651: PUSH
4652: EMPTY
4653: LIST
4654: LIST
4655: LIST
4656: LIST
4657: LIST
4658: PUSH
4659: LD_INT 1
4661: PPUSH
4662: LD_INT 5
4664: PPUSH
4665: CALL_OW 12
4669: ARRAY
4670: ST_TO_ADDR
// chassis = [ ar_medium_trike , ar_half_tracked ] [ Rand ( 1 , 2 ) ] ;
4671: LD_ADDR_VAR 0 6
4675: PUSH
4676: LD_INT 13
4678: PUSH
4679: LD_INT 14
4681: PUSH
4682: EMPTY
4683: LIST
4684: LIST
4685: PUSH
4686: LD_INT 1
4688: PPUSH
4689: LD_INT 2
4691: PPUSH
4692: CALL_OW 12
4696: ARRAY
4697: ST_TO_ADDR
// PrepareVehicle ( chassis , engine_combustion , control_manual , weapon , Rand ( 70 , 90 ) ) ;
4698: LD_VAR 0 6
4702: PPUSH
4703: LD_INT 1
4705: PPUSH
4706: LD_INT 1
4708: PPUSH
4709: LD_VAR 0 5
4713: PPUSH
4714: LD_INT 70
4716: PPUSH
4717: LD_INT 90
4719: PPUSH
4720: CALL_OW 12
4724: PPUSH
4725: CALL 24241 0 5
// veh = CreateVehicle ;
4729: LD_ADDR_VAR 0 4
4733: PUSH
4734: CALL_OW 45
4738: ST_TO_ADDR
// PlaceUnitArea ( veh , KurtUnitsSpawnArea , false ) ;
4739: LD_VAR 0 4
4743: PPUSH
4744: LD_INT 10
4746: PPUSH
4747: LD_INT 0
4749: PPUSH
4750: CALL_OW 49
// arAttackTeam = arAttackTeam ^ veh ;
4754: LD_ADDR_EXP 84
4758: PUSH
4759: LD_EXP 84
4763: PUSH
4764: LD_VAR 0 4
4768: ADD
4769: ST_TO_ADDR
// PrepareMechanic ( false , enemySkillLevel ) ;
4770: LD_INT 0
4772: PPUSH
4773: LD_EXP 56
4777: PPUSH
4778: CALL_OW 383
// unit = CreateHuman ;
4782: LD_ADDR_VAR 0 3
4786: PUSH
4787: CALL_OW 44
4791: ST_TO_ADDR
// PlaceHumanInUnit ( unit , veh ) ;
4792: LD_VAR 0 3
4796: PPUSH
4797: LD_VAR 0 4
4801: PPUSH
4802: CALL_OW 52
// arAttackTeam = arAttackTeam ^ unit ;
4806: LD_ADDR_EXP 84
4810: PUSH
4811: LD_EXP 84
4815: PUSH
4816: LD_VAR 0 3
4820: ADD
4821: ST_TO_ADDR
// end ;
4822: GO 4629
4824: POP
4825: POP
// end ; end_of_file
4826: LD_VAR 0 1
4830: RET
// export function Nef_PrepareNature ; var i , un ; begin
4831: LD_INT 0
4833: PPUSH
4834: PPUSH
4835: PPUSH
// for i := 1 to animalsAmount [ 1 ] do
4836: LD_ADDR_VAR 0 2
4840: PUSH
4841: DOUBLE
4842: LD_INT 1
4844: DEC
4845: ST_TO_ADDR
4846: LD_EXP 41
4850: PUSH
4851: LD_INT 1
4853: ARRAY
4854: PUSH
4855: FOR_TO
4856: IFFALSE 4966
// begin uc_side = 0 ;
4858: LD_ADDR_OWVAR 20
4862: PUSH
4863: LD_INT 0
4865: ST_TO_ADDR
// uc_nation = nation_nature ;
4866: LD_ADDR_OWVAR 21
4870: PUSH
4871: LD_INT 0
4873: ST_TO_ADDR
// hc_class = class_apeman ;
4874: LD_ADDR_OWVAR 28
4878: PUSH
4879: LD_INT 12
4881: ST_TO_ADDR
// hc_skills = [ animalsStats [ 1 ] , animalsStats [ 2 ] , animalsStats [ 3 ] , animalsStats [ 4 ] ] ;
4882: LD_ADDR_OWVAR 31
4886: PUSH
4887: LD_EXP 42
4891: PUSH
4892: LD_INT 1
4894: ARRAY
4895: PUSH
4896: LD_EXP 42
4900: PUSH
4901: LD_INT 2
4903: ARRAY
4904: PUSH
4905: LD_EXP 42
4909: PUSH
4910: LD_INT 3
4912: ARRAY
4913: PUSH
4914: LD_EXP 42
4918: PUSH
4919: LD_INT 4
4921: ARRAY
4922: PUSH
4923: EMPTY
4924: LIST
4925: LIST
4926: LIST
4927: LIST
4928: ST_TO_ADDR
// hc_agressivity = animalsAgression ;
4929: LD_ADDR_OWVAR 35
4933: PUSH
4934: LD_EXP 43
4938: ST_TO_ADDR
// un = CreateHuman ;
4939: LD_ADDR_VAR 0 3
4943: PUSH
4944: CALL_OW 44
4948: ST_TO_ADDR
// PlaceUnitArea ( un , NatureArea , false ) ;
4949: LD_VAR 0 3
4953: PPUSH
4954: LD_INT 5
4956: PPUSH
4957: LD_INT 0
4959: PPUSH
4960: CALL_OW 49
// end ;
4964: GO 4855
4966: POP
4967: POP
// for i := 1 to animalsAmount [ 2 ] do
4968: LD_ADDR_VAR 0 2
4972: PUSH
4973: DOUBLE
4974: LD_INT 1
4976: DEC
4977: ST_TO_ADDR
4978: LD_EXP 41
4982: PUSH
4983: LD_INT 2
4985: ARRAY
4986: PUSH
4987: FOR_TO
4988: IFFALSE 5098
// begin uc_side = 0 ;
4990: LD_ADDR_OWVAR 20
4994: PUSH
4995: LD_INT 0
4997: ST_TO_ADDR
// uc_nation = nation_nature ;
4998: LD_ADDR_OWVAR 21
5002: PUSH
5003: LD_INT 0
5005: ST_TO_ADDR
// hc_class = class_phororhacos ;
5006: LD_ADDR_OWVAR 28
5010: PUSH
5011: LD_INT 18
5013: ST_TO_ADDR
// hc_skills = [ animalsStats [ 1 ] , animalsStats [ 2 ] , animalsStats [ 3 ] , animalsStats [ 4 ] ] ;
5014: LD_ADDR_OWVAR 31
5018: PUSH
5019: LD_EXP 42
5023: PUSH
5024: LD_INT 1
5026: ARRAY
5027: PUSH
5028: LD_EXP 42
5032: PUSH
5033: LD_INT 2
5035: ARRAY
5036: PUSH
5037: LD_EXP 42
5041: PUSH
5042: LD_INT 3
5044: ARRAY
5045: PUSH
5046: LD_EXP 42
5050: PUSH
5051: LD_INT 4
5053: ARRAY
5054: PUSH
5055: EMPTY
5056: LIST
5057: LIST
5058: LIST
5059: LIST
5060: ST_TO_ADDR
// hc_agressivity = animalsAgression ;
5061: LD_ADDR_OWVAR 35
5065: PUSH
5066: LD_EXP 43
5070: ST_TO_ADDR
// un = CreateHuman ;
5071: LD_ADDR_VAR 0 3
5075: PUSH
5076: CALL_OW 44
5080: ST_TO_ADDR
// PlaceUnitArea ( un , NatureArea , false ) ;
5081: LD_VAR 0 3
5085: PPUSH
5086: LD_INT 5
5088: PPUSH
5089: LD_INT 0
5091: PPUSH
5092: CALL_OW 49
// end ;
5096: GO 4987
5098: POP
5099: POP
// for i := 1 to animalsAmount [ 3 ] do
5100: LD_ADDR_VAR 0 2
5104: PUSH
5105: DOUBLE
5106: LD_INT 1
5108: DEC
5109: ST_TO_ADDR
5110: LD_EXP 41
5114: PUSH
5115: LD_INT 3
5117: ARRAY
5118: PUSH
5119: FOR_TO
5120: IFFALSE 5230
// begin uc_side = 0 ;
5122: LD_ADDR_OWVAR 20
5126: PUSH
5127: LD_INT 0
5129: ST_TO_ADDR
// uc_nation = nation_nature ;
5130: LD_ADDR_OWVAR 21
5134: PUSH
5135: LD_INT 0
5137: ST_TO_ADDR
// hc_class = class_tiger ;
5138: LD_ADDR_OWVAR 28
5142: PUSH
5143: LD_INT 14
5145: ST_TO_ADDR
// hc_skills = [ animalsStats [ 1 ] , animalsStats [ 2 ] , animalsStats [ 3 ] , animalsStats [ 4 ] ] ;
5146: LD_ADDR_OWVAR 31
5150: PUSH
5151: LD_EXP 42
5155: PUSH
5156: LD_INT 1
5158: ARRAY
5159: PUSH
5160: LD_EXP 42
5164: PUSH
5165: LD_INT 2
5167: ARRAY
5168: PUSH
5169: LD_EXP 42
5173: PUSH
5174: LD_INT 3
5176: ARRAY
5177: PUSH
5178: LD_EXP 42
5182: PUSH
5183: LD_INT 4
5185: ARRAY
5186: PUSH
5187: EMPTY
5188: LIST
5189: LIST
5190: LIST
5191: LIST
5192: ST_TO_ADDR
// hc_agressivity = animalsAgression ;
5193: LD_ADDR_OWVAR 35
5197: PUSH
5198: LD_EXP 43
5202: ST_TO_ADDR
// un = CreateHuman ;
5203: LD_ADDR_VAR 0 3
5207: PUSH
5208: CALL_OW 44
5212: ST_TO_ADDR
// PlaceUnitArea ( un , NatureArea , false ) ;
5213: LD_VAR 0 3
5217: PPUSH
5218: LD_INT 5
5220: PPUSH
5221: LD_INT 0
5223: PPUSH
5224: CALL_OW 49
// end ;
5228: GO 5119
5230: POP
5231: POP
// for i := 1 to animalsAmount [ 4 ] do
5232: LD_ADDR_VAR 0 2
5236: PUSH
5237: DOUBLE
5238: LD_INT 1
5240: DEC
5241: ST_TO_ADDR
5242: LD_EXP 41
5246: PUSH
5247: LD_INT 4
5249: ARRAY
5250: PUSH
5251: FOR_TO
5252: IFFALSE 5362
// begin uc_side = 0 ;
5254: LD_ADDR_OWVAR 20
5258: PUSH
5259: LD_INT 0
5261: ST_TO_ADDR
// uc_nation = nation_nature ;
5262: LD_ADDR_OWVAR 21
5266: PUSH
5267: LD_INT 0
5269: ST_TO_ADDR
// hc_class = 21 ;
5270: LD_ADDR_OWVAR 28
5274: PUSH
5275: LD_INT 21
5277: ST_TO_ADDR
// hc_skills = [ animalsStats [ 1 ] , animalsStats [ 2 ] , animalsStats [ 3 ] , animalsStats [ 4 ] ] ;
5278: LD_ADDR_OWVAR 31
5282: PUSH
5283: LD_EXP 42
5287: PUSH
5288: LD_INT 1
5290: ARRAY
5291: PUSH
5292: LD_EXP 42
5296: PUSH
5297: LD_INT 2
5299: ARRAY
5300: PUSH
5301: LD_EXP 42
5305: PUSH
5306: LD_INT 3
5308: ARRAY
5309: PUSH
5310: LD_EXP 42
5314: PUSH
5315: LD_INT 4
5317: ARRAY
5318: PUSH
5319: EMPTY
5320: LIST
5321: LIST
5322: LIST
5323: LIST
5324: ST_TO_ADDR
// hc_agressivity = animalsAgression ;
5325: LD_ADDR_OWVAR 35
5329: PUSH
5330: LD_EXP 43
5334: ST_TO_ADDR
// un = CreateHuman ;
5335: LD_ADDR_VAR 0 3
5339: PUSH
5340: CALL_OW 44
5344: ST_TO_ADDR
// PlaceUnitArea ( un , NatureArea , false ) ;
5345: LD_VAR 0 3
5349: PPUSH
5350: LD_INT 5
5352: PPUSH
5353: LD_INT 0
5355: PPUSH
5356: CALL_OW 49
// end ;
5360: GO 5251
5362: POP
5363: POP
// for i := 1 to animalsAmount [ 5 ] do
5364: LD_ADDR_VAR 0 2
5368: PUSH
5369: DOUBLE
5370: LD_INT 1
5372: DEC
5373: ST_TO_ADDR
5374: LD_EXP 41
5378: PUSH
5379: LD_INT 5
5381: ARRAY
5382: PUSH
5383: FOR_TO
5384: IFFALSE 5445
// begin uc_side = 0 ;
5386: LD_ADDR_OWVAR 20
5390: PUSH
5391: LD_INT 0
5393: ST_TO_ADDR
// uc_nation = nation_nature ;
5394: LD_ADDR_OWVAR 21
5398: PUSH
5399: LD_INT 0
5401: ST_TO_ADDR
// vc_chassis := 31 ;
5402: LD_ADDR_OWVAR 37
5406: PUSH
5407: LD_INT 31
5409: ST_TO_ADDR
// vc_control := control_rider ;
5410: LD_ADDR_OWVAR 38
5414: PUSH
5415: LD_INT 4
5417: ST_TO_ADDR
// un := CreateVehicle ;
5418: LD_ADDR_VAR 0 3
5422: PUSH
5423: CALL_OW 45
5427: ST_TO_ADDR
// PlaceUnitArea ( un , NatureArea , false ) ;
5428: LD_VAR 0 3
5432: PPUSH
5433: LD_INT 5
5435: PPUSH
5436: LD_INT 0
5438: PPUSH
5439: CALL_OW 49
// end ;
5443: GO 5383
5445: POP
5446: POP
// end ;
5447: LD_VAR 0 1
5451: RET
// export function SpawnTrees ; begin
5452: LD_INT 0
5454: PPUSH
// PlaceTreesToArea ( TreeArea , [ 2 , 10 , 11 , 27 , 35 ] , 40 , 10 , 4 ) ;
5455: LD_INT 1
5457: PPUSH
5458: LD_INT 2
5460: PUSH
5461: LD_INT 10
5463: PUSH
5464: LD_INT 11
5466: PUSH
5467: LD_INT 27
5469: PUSH
5470: LD_INT 35
5472: PUSH
5473: EMPTY
5474: LIST
5475: LIST
5476: LIST
5477: LIST
5478: LIST
5479: PPUSH
5480: LD_INT 40
5482: PPUSH
5483: LD_INT 10
5485: PPUSH
5486: LD_INT 4
5488: PPUSH
5489: CALL_OW 352
// PlaceTreesToArea ( TreeArea , [ 9 , 10 , 27 , 35 , 48 ] , 30 , 10 , 4 ) ;
5493: LD_INT 1
5495: PPUSH
5496: LD_INT 9
5498: PUSH
5499: LD_INT 10
5501: PUSH
5502: LD_INT 27
5504: PUSH
5505: LD_INT 35
5507: PUSH
5508: LD_INT 48
5510: PUSH
5511: EMPTY
5512: LIST
5513: LIST
5514: LIST
5515: LIST
5516: LIST
5517: PPUSH
5518: LD_INT 30
5520: PPUSH
5521: LD_INT 10
5523: PPUSH
5524: LD_INT 4
5526: PPUSH
5527: CALL_OW 352
// PlaceTreesToArea ( TreeArea , [ 2 , 9 , 10 , 11 , 27 ] , 60 , 10 , 4 ) ;
5531: LD_INT 1
5533: PPUSH
5534: LD_INT 2
5536: PUSH
5537: LD_INT 9
5539: PUSH
5540: LD_INT 10
5542: PUSH
5543: LD_INT 11
5545: PUSH
5546: LD_INT 27
5548: PUSH
5549: EMPTY
5550: LIST
5551: LIST
5552: LIST
5553: LIST
5554: LIST
5555: PPUSH
5556: LD_INT 60
5558: PPUSH
5559: LD_INT 10
5561: PPUSH
5562: LD_INT 4
5564: PPUSH
5565: CALL_OW 352
// PlaceTreesToArea ( TreeArea , [ 9 , 10 , 27 , 35 , 48 ] , 90 , 10 , 4 ) ;
5569: LD_INT 1
5571: PPUSH
5572: LD_INT 9
5574: PUSH
5575: LD_INT 10
5577: PUSH
5578: LD_INT 27
5580: PUSH
5581: LD_INT 35
5583: PUSH
5584: LD_INT 48
5586: PUSH
5587: EMPTY
5588: LIST
5589: LIST
5590: LIST
5591: LIST
5592: LIST
5593: PPUSH
5594: LD_INT 90
5596: PPUSH
5597: LD_INT 10
5599: PPUSH
5600: LD_INT 4
5602: PPUSH
5603: CALL_OW 352
// PlaceTreesToArea ( TreeArea , [ 2 , 9 , 10 , 11 , 48 ] , 120 , 10 , 4 ) ;
5607: LD_INT 1
5609: PPUSH
5610: LD_INT 2
5612: PUSH
5613: LD_INT 9
5615: PUSH
5616: LD_INT 10
5618: PUSH
5619: LD_INT 11
5621: PUSH
5622: LD_INT 48
5624: PUSH
5625: EMPTY
5626: LIST
5627: LIST
5628: LIST
5629: LIST
5630: LIST
5631: PPUSH
5632: LD_INT 120
5634: PPUSH
5635: LD_INT 10
5637: PPUSH
5638: LD_INT 4
5640: PPUSH
5641: CALL_OW 352
// PlaceTreesToArea ( TreeArea , [ 2 , 11 , 27 , 35 , 48 ] , 45 , 10 , 4 ) ;
5645: LD_INT 1
5647: PPUSH
5648: LD_INT 2
5650: PUSH
5651: LD_INT 11
5653: PUSH
5654: LD_INT 27
5656: PUSH
5657: LD_INT 35
5659: PUSH
5660: LD_INT 48
5662: PUSH
5663: EMPTY
5664: LIST
5665: LIST
5666: LIST
5667: LIST
5668: LIST
5669: PPUSH
5670: LD_INT 45
5672: PPUSH
5673: LD_INT 10
5675: PPUSH
5676: LD_INT 4
5678: PPUSH
5679: CALL_OW 352
// end ;
5683: LD_VAR 0 1
5687: RET
// every 0 0$1 do var i , un ;
5688: GO 5690
5690: DISABLE
5691: LD_INT 0
5693: PPUSH
5694: PPUSH
// begin if ( GetTech ( tech_apelang , 3 ) = state_enabled or GetTech ( tech_apepsych , 3 ) = state_enabled or GetTech ( tech_apeagres , 3 ) = state_enabled ) and not FilterAllUnits ( [ [ f_or , [ f_class , class_apeman ] , [ f_class , class_apeman_engineer ] , [ f_class , class_apeman_soldier ] ] ] ) then
5695: LD_INT 1
5697: PPUSH
5698: LD_INT 3
5700: PPUSH
5701: CALL_OW 321
5705: PUSH
5706: LD_INT 1
5708: EQUAL
5709: PUSH
5710: LD_INT 2
5712: PPUSH
5713: LD_INT 3
5715: PPUSH
5716: CALL_OW 321
5720: PUSH
5721: LD_INT 1
5723: EQUAL
5724: OR
5725: PUSH
5726: LD_INT 11
5728: PPUSH
5729: LD_INT 3
5731: PPUSH
5732: CALL_OW 321
5736: PUSH
5737: LD_INT 1
5739: EQUAL
5740: OR
5741: PUSH
5742: LD_INT 2
5744: PUSH
5745: LD_INT 25
5747: PUSH
5748: LD_INT 12
5750: PUSH
5751: EMPTY
5752: LIST
5753: LIST
5754: PUSH
5755: LD_INT 25
5757: PUSH
5758: LD_INT 16
5760: PUSH
5761: EMPTY
5762: LIST
5763: LIST
5764: PUSH
5765: LD_INT 25
5767: PUSH
5768: LD_INT 15
5770: PUSH
5771: EMPTY
5772: LIST
5773: LIST
5774: PUSH
5775: EMPTY
5776: LIST
5777: LIST
5778: LIST
5779: LIST
5780: PUSH
5781: EMPTY
5782: LIST
5783: PPUSH
5784: CALL_OW 69
5788: NOT
5789: AND
5790: IFFALSE 5926
// begin for i := 1 to Rand ( 2 , 4 ) do
5792: LD_ADDR_VAR 0 1
5796: PUSH
5797: DOUBLE
5798: LD_INT 1
5800: DEC
5801: ST_TO_ADDR
5802: LD_INT 2
5804: PPUSH
5805: LD_INT 4
5807: PPUSH
5808: CALL_OW 12
5812: PUSH
5813: FOR_TO
5814: IFFALSE 5924
// begin uc_side = 0 ;
5816: LD_ADDR_OWVAR 20
5820: PUSH
5821: LD_INT 0
5823: ST_TO_ADDR
// uc_nation = nation_nature ;
5824: LD_ADDR_OWVAR 21
5828: PUSH
5829: LD_INT 0
5831: ST_TO_ADDR
// hc_class = class_apeman ;
5832: LD_ADDR_OWVAR 28
5836: PUSH
5837: LD_INT 12
5839: ST_TO_ADDR
// hc_skills = [ animalsStats [ 1 ] , animalsStats [ 2 ] , animalsStats [ 3 ] , animalsStats [ 4 ] ] ;
5840: LD_ADDR_OWVAR 31
5844: PUSH
5845: LD_EXP 42
5849: PUSH
5850: LD_INT 1
5852: ARRAY
5853: PUSH
5854: LD_EXP 42
5858: PUSH
5859: LD_INT 2
5861: ARRAY
5862: PUSH
5863: LD_EXP 42
5867: PUSH
5868: LD_INT 3
5870: ARRAY
5871: PUSH
5872: LD_EXP 42
5876: PUSH
5877: LD_INT 4
5879: ARRAY
5880: PUSH
5881: EMPTY
5882: LIST
5883: LIST
5884: LIST
5885: LIST
5886: ST_TO_ADDR
// hc_agressivity = animalsAgression ;
5887: LD_ADDR_OWVAR 35
5891: PUSH
5892: LD_EXP 43
5896: ST_TO_ADDR
// un = CreateHuman ;
5897: LD_ADDR_VAR 0 2
5901: PUSH
5902: CALL_OW 44
5906: ST_TO_ADDR
// PlaceUnitArea ( un , NatureArea , false ) ;
5907: LD_VAR 0 2
5911: PPUSH
5912: LD_INT 5
5914: PPUSH
5915: LD_INT 0
5917: PPUSH
5918: CALL_OW 49
// end ;
5922: GO 5813
5924: POP
5925: POP
// end ; enable ;
5926: ENABLE
// end ; end_of_file
5927: PPOPN 2
5929: END
// export function PrepareUnitExt ( ident , exist_mode , class ) ; var unit ; begin
5930: LD_INT 0
5932: PPUSH
5933: PPUSH
// if debugMode then
5934: LD_EXP 46
5938: IFFALSE 5955
// unit := NewCharacter ( ident ) ;
5940: LD_ADDR_VAR 0 5
5944: PUSH
5945: LD_VAR 0 1
5949: PPUSH
5950: CALL_OW 25
5954: ST_TO_ADDR
// if exist_mode and not debugMode then
5955: LD_VAR 0 2
5959: PUSH
5960: LD_EXP 46
5964: NOT
5965: AND
5966: IFFALSE 5991
// unit := CreateCharacter ( previousMissionPrefix & ident ) else
5968: LD_ADDR_VAR 0 5
5972: PUSH
5973: LD_EXP 45
5977: PUSH
5978: LD_VAR 0 1
5982: STR
5983: PPUSH
5984: CALL_OW 34
5988: ST_TO_ADDR
5989: GO 6013
// if not debugMode then
5991: LD_EXP 46
5995: NOT
5996: IFFALSE 6013
// unit := NewCharacter ( ident ) ;
5998: LD_ADDR_VAR 0 5
6002: PUSH
6003: LD_VAR 0 1
6007: PPUSH
6008: CALL_OW 25
6012: ST_TO_ADDR
// if class then
6013: LD_VAR 0 3
6017: IFFALSE 6033
// SetClass ( unit , class ) ;
6019: LD_VAR 0 5
6023: PPUSH
6024: LD_VAR 0 3
6028: PPUSH
6029: CALL_OW 336
// result := unit ;
6033: LD_ADDR_VAR 0 4
6037: PUSH
6038: LD_VAR 0 5
6042: ST_TO_ADDR
// end ;
6043: LD_VAR 0 4
6047: RET
// export function ExtSaveCharacter ( character , characterStringID , side ) ; begin
6048: LD_INT 0
6050: PPUSH
// if GetSide ( character ) = side and not IsDead ( character ) then
6051: LD_VAR 0 1
6055: PPUSH
6056: CALL_OW 255
6060: PUSH
6061: LD_VAR 0 3
6065: EQUAL
6066: PUSH
6067: LD_VAR 0 1
6071: PPUSH
6072: CALL_OW 301
6076: NOT
6077: AND
6078: IFFALSE 6100
// SaveCharacters ( character , missionPrefix & characterStringID ) ;
6080: LD_VAR 0 1
6084: PPUSH
6085: LD_EXP 44
6089: PUSH
6090: LD_VAR 0 2
6094: STR
6095: PPUSH
6096: CALL_OW 38
// end ;
6100: LD_VAR 0 4
6104: RET
// export function ExtSaveCharacters ( characters , charactersStringID , side ) ; var unit , resultCharactersToSave ; begin
6105: LD_INT 0
6107: PPUSH
6108: PPUSH
6109: PPUSH
// resultCharactersToSave = [ ] ;
6110: LD_ADDR_VAR 0 6
6114: PUSH
6115: EMPTY
6116: ST_TO_ADDR
// for unit in characters do
6117: LD_ADDR_VAR 0 5
6121: PUSH
6122: LD_VAR 0 1
6126: PUSH
6127: FOR_IN
6128: IFFALSE 6177
// if GetSide ( unit ) = side and not IsDead ( unit ) then
6130: LD_VAR 0 5
6134: PPUSH
6135: CALL_OW 255
6139: PUSH
6140: LD_VAR 0 3
6144: EQUAL
6145: PUSH
6146: LD_VAR 0 5
6150: PPUSH
6151: CALL_OW 301
6155: NOT
6156: AND
6157: IFFALSE 6175
// resultCharactersToSave = resultCharactersToSave ^ unit ;
6159: LD_ADDR_VAR 0 6
6163: PUSH
6164: LD_VAR 0 6
6168: PUSH
6169: LD_VAR 0 5
6173: ADD
6174: ST_TO_ADDR
6175: GO 6127
6177: POP
6178: POP
// SaveCharacters ( resultCharactersToSave , missionPrefix & charactersStringID ) ;
6179: LD_VAR 0 6
6183: PPUSH
6184: LD_EXP 44
6188: PUSH
6189: LD_VAR 0 2
6193: STR
6194: PPUSH
6195: CALL_OW 38
// end ;
6199: LD_VAR 0 4
6203: RET
// export function PlaceUnitsArea ( units , area , spawnMode ) ; var unit ; begin
6204: LD_INT 0
6206: PPUSH
6207: PPUSH
// for unit in units do
6208: LD_ADDR_VAR 0 5
6212: PUSH
6213: LD_VAR 0 1
6217: PUSH
6218: FOR_IN
6219: IFFALSE 6242
// PlaceUnitArea ( unit , area , spawnMode ) ;
6221: LD_VAR 0 5
6225: PPUSH
6226: LD_VAR 0 2
6230: PPUSH
6231: LD_VAR 0 3
6235: PPUSH
6236: CALL_OW 49
6240: GO 6218
6242: POP
6243: POP
// end ;
6244: LD_VAR 0 4
6248: RET
// export function DialogRandom ( characters , dialogMID , dialogFID , radio , canTalkHero ) ; var i , speaker , units ; begin
6249: LD_INT 0
6251: PPUSH
6252: PPUSH
6253: PPUSH
6254: PPUSH
// units = characters ;
6255: LD_ADDR_VAR 0 9
6259: PUSH
6260: LD_VAR 0 1
6264: ST_TO_ADDR
// units := units diff [ Burlak , Karamazov , Petrovova , Gleb , Petrosyan , Titov , Dolgov , Lipshchin , Kirilenkova ] ;
6265: LD_ADDR_VAR 0 9
6269: PUSH
6270: LD_VAR 0 9
6274: PUSH
6275: LD_EXP 57
6279: PUSH
6280: LD_EXP 58
6284: PUSH
6285: LD_EXP 59
6289: PUSH
6290: LD_EXP 60
6294: PUSH
6295: LD_EXP 61
6299: PUSH
6300: LD_EXP 62
6304: PUSH
6305: LD_EXP 63
6309: PUSH
6310: LD_EXP 64
6314: PUSH
6315: LD_EXP 65
6319: PUSH
6320: EMPTY
6321: LIST
6322: LIST
6323: LIST
6324: LIST
6325: LIST
6326: LIST
6327: LIST
6328: LIST
6329: LIST
6330: DIFF
6331: ST_TO_ADDR
// if not units and not canTalkHero then
6332: LD_VAR 0 9
6336: NOT
6337: PUSH
6338: LD_VAR 0 5
6342: NOT
6343: AND
6344: IFFALSE 6348
// exit ;
6346: GO 6521
// if not units then
6348: LD_VAR 0 9
6352: NOT
6353: IFFALSE 6374
// units = characters diff [ Burlak ] ;
6355: LD_ADDR_VAR 0 9
6359: PUSH
6360: LD_VAR 0 1
6364: PUSH
6365: LD_EXP 57
6369: PUSH
6370: EMPTY
6371: LIST
6372: DIFF
6373: ST_TO_ADDR
// if not units and canTalkHero then
6374: LD_VAR 0 9
6378: NOT
6379: PUSH
6380: LD_VAR 0 5
6384: AND
6385: IFFALSE 6389
// exit ;
6387: GO 6521
// speaker := units [ rand ( 1 , units ) ] ;
6389: LD_ADDR_VAR 0 8
6393: PUSH
6394: LD_VAR 0 9
6398: PUSH
6399: LD_INT 1
6401: PPUSH
6402: LD_VAR 0 9
6406: PPUSH
6407: CALL_OW 12
6411: ARRAY
6412: ST_TO_ADDR
// if radio then
6413: LD_VAR 0 4
6417: IFFALSE 6466
// begin if GetSex ( speaker ) = sex_male then
6419: LD_VAR 0 8
6423: PPUSH
6424: CALL_OW 258
6428: PUSH
6429: LD_INT 1
6431: EQUAL
6432: IFFALSE 6450
// SayRadio ( speaker , dialogMID ) else
6434: LD_VAR 0 8
6438: PPUSH
6439: LD_VAR 0 2
6443: PPUSH
6444: CALL_OW 94
6448: GO 6464
// SayRadio ( speaker , dialogFID ) ;
6450: LD_VAR 0 8
6454: PPUSH
6455: LD_VAR 0 3
6459: PPUSH
6460: CALL_OW 94
// end else
6464: GO 6511
// begin if GetSex ( speaker ) = sex_male then
6466: LD_VAR 0 8
6470: PPUSH
6471: CALL_OW 258
6475: PUSH
6476: LD_INT 1
6478: EQUAL
6479: IFFALSE 6497
// Say ( speaker , dialogMID ) else
6481: LD_VAR 0 8
6485: PPUSH
6486: LD_VAR 0 2
6490: PPUSH
6491: CALL_OW 88
6495: GO 6511
// Say ( speaker , dialogFID ) ;
6497: LD_VAR 0 8
6501: PPUSH
6502: LD_VAR 0 3
6506: PPUSH
6507: CALL_OW 88
// end ; result := speaker ;
6511: LD_ADDR_VAR 0 6
6515: PUSH
6516: LD_VAR 0 8
6520: ST_TO_ADDR
// end ;
6521: LD_VAR 0 6
6525: RET
// export function RemoveUnits ( units ) ; var unit ; begin
6526: LD_INT 0
6528: PPUSH
6529: PPUSH
// if not units then
6530: LD_VAR 0 1
6534: NOT
6535: IFFALSE 6539
// exit ;
6537: GO 6685
// if Heike in units then
6539: LD_EXP 79
6543: PUSH
6544: LD_VAR 0 1
6548: IN
6549: IFFALSE 6605
// begin if GetAttitude ( 3 , 8 ) = att_neutral then
6551: LD_INT 3
6553: PPUSH
6554: LD_INT 8
6556: PPUSH
6557: CALL_OW 81
6561: PUSH
6562: LD_INT 0
6564: EQUAL
6565: IFFALSE 6577
// HeikeStatus = 1 else
6567: LD_ADDR_EXP 3
6571: PUSH
6572: LD_INT 1
6574: ST_TO_ADDR
6575: GO 6585
// HeikeStatus = 2 ;
6577: LD_ADDR_EXP 3
6581: PUSH
6582: LD_INT 2
6584: ST_TO_ADDR
// forceStopKurtAttack = true ;
6585: LD_ADDR_EXP 27
6589: PUSH
6590: LD_INT 1
6592: ST_TO_ADDR
// SetClass ( Heike , 1 ) ;
6593: LD_EXP 79
6597: PPUSH
6598: LD_INT 1
6600: PPUSH
6601: CALL_OW 336
// end ; if Kurt in units then
6605: LD_EXP 80
6609: PUSH
6610: LD_VAR 0 1
6614: IN
6615: IFFALSE 6659
// begin if GetAttitude ( 3 , 8 ) = att_neutral then
6617: LD_INT 3
6619: PPUSH
6620: LD_INT 8
6622: PPUSH
6623: CALL_OW 81
6627: PUSH
6628: LD_INT 0
6630: EQUAL
6631: IFFALSE 6643
// KurtStatus = 1 else
6633: LD_ADDR_EXP 22
6637: PUSH
6638: LD_INT 1
6640: ST_TO_ADDR
6641: GO 6659
// begin KurtStatus = 2 ;
6643: LD_ADDR_EXP 22
6647: PUSH
6648: LD_INT 2
6650: ST_TO_ADDR
// KurtAttack = 1 ;
6651: LD_ADDR_EXP 25
6655: PUSH
6656: LD_INT 1
6658: ST_TO_ADDR
// end ; end ; for unit in units do
6659: LD_ADDR_VAR 0 3
6663: PUSH
6664: LD_VAR 0 1
6668: PUSH
6669: FOR_IN
6670: IFFALSE 6683
// RemoveUnit ( unit ) ;
6672: LD_VAR 0 3
6676: PPUSH
6677: CALL_OW 64
6681: GO 6669
6683: POP
6684: POP
// end ;
6685: LD_VAR 0 2
6689: RET
// export function GetAmountWeaponsDataBuildOnTurret ( isBuild ) ; var i , amount ; begin
6690: LD_INT 0
6692: PPUSH
6693: PPUSH
6694: PPUSH
// amount = 0 ;
6695: LD_ADDR_VAR 0 4
6699: PUSH
6700: LD_INT 0
6702: ST_TO_ADDR
// for i := 1 to weaponsData do
6703: LD_ADDR_VAR 0 3
6707: PUSH
6708: DOUBLE
6709: LD_INT 1
6711: DEC
6712: ST_TO_ADDR
6713: LD_EXP 12
6717: PUSH
6718: FOR_TO
6719: IFFALSE 6759
// if weaponsData [ i ] [ 2 ] = isBuild then
6721: LD_EXP 12
6725: PUSH
6726: LD_VAR 0 3
6730: ARRAY
6731: PUSH
6732: LD_INT 2
6734: ARRAY
6735: PUSH
6736: LD_VAR 0 1
6740: EQUAL
6741: IFFALSE 6757
// amount = amount + 1 ;
6743: LD_ADDR_VAR 0 4
6747: PUSH
6748: LD_VAR 0 4
6752: PUSH
6753: LD_INT 1
6755: PLUS
6756: ST_TO_ADDR
6757: GO 6718
6759: POP
6760: POP
// if isBuild then
6761: LD_VAR 0 1
6765: IFFALSE 6785
// if amount >= 3 then
6767: LD_VAR 0 4
6771: PUSH
6772: LD_INT 3
6774: GREATEREQUAL
6775: IFFALSE 6785
// amount = 3 ;
6777: LD_ADDR_VAR 0 4
6781: PUSH
6782: LD_INT 3
6784: ST_TO_ADDR
// result = amount ;
6785: LD_ADDR_VAR 0 2
6789: PUSH
6790: LD_VAR 0 4
6794: ST_TO_ADDR
// end ;
6795: LD_VAR 0 2
6799: RET
// export function GetAmountWeaponsDataBuildOnVehicle ( isBuild ) ; var i , amount ; begin
6800: LD_INT 0
6802: PPUSH
6803: PPUSH
6804: PPUSH
// amount = 0 ;
6805: LD_ADDR_VAR 0 4
6809: PUSH
6810: LD_INT 0
6812: ST_TO_ADDR
// for i := 1 to weaponsData do
6813: LD_ADDR_VAR 0 3
6817: PUSH
6818: DOUBLE
6819: LD_INT 1
6821: DEC
6822: ST_TO_ADDR
6823: LD_EXP 12
6827: PUSH
6828: FOR_TO
6829: IFFALSE 6869
// if weaponsData [ i ] [ 3 ] = isBuild then
6831: LD_EXP 12
6835: PUSH
6836: LD_VAR 0 3
6840: ARRAY
6841: PUSH
6842: LD_INT 3
6844: ARRAY
6845: PUSH
6846: LD_VAR 0 1
6850: EQUAL
6851: IFFALSE 6867
// amount = amount + 1 ;
6853: LD_ADDR_VAR 0 4
6857: PUSH
6858: LD_VAR 0 4
6862: PUSH
6863: LD_INT 1
6865: PLUS
6866: ST_TO_ADDR
6867: GO 6828
6869: POP
6870: POP
// result = amount ;
6871: LD_ADDR_VAR 0 2
6875: PUSH
6876: LD_VAR 0 4
6880: ST_TO_ADDR
// end ;
6881: LD_VAR 0 2
6885: RET
// export function SetWeaponDataBuild ( weapon , turret ) ; var i ; begin
6886: LD_INT 0
6888: PPUSH
6889: PPUSH
// if turret then
6890: LD_VAR 0 2
6894: IFFALSE 6992
// begin for i := 1 to weaponsData do
6896: LD_ADDR_VAR 0 4
6900: PUSH
6901: DOUBLE
6902: LD_INT 1
6904: DEC
6905: ST_TO_ADDR
6906: LD_EXP 12
6910: PUSH
6911: FOR_TO
6912: IFFALSE 6988
// if weaponsData [ i ] [ 1 ] = weapon and weaponsData [ i ] [ 2 ] = false then
6914: LD_EXP 12
6918: PUSH
6919: LD_VAR 0 4
6923: ARRAY
6924: PUSH
6925: LD_INT 1
6927: ARRAY
6928: PUSH
6929: LD_VAR 0 1
6933: EQUAL
6934: PUSH
6935: LD_EXP 12
6939: PUSH
6940: LD_VAR 0 4
6944: ARRAY
6945: PUSH
6946: LD_INT 2
6948: ARRAY
6949: PUSH
6950: LD_INT 0
6952: EQUAL
6953: AND
6954: IFFALSE 6986
// weaponsData = ReplaceIn ( weaponsData , [ i , 2 ] , true ) ;
6956: LD_ADDR_EXP 12
6960: PUSH
6961: LD_EXP 12
6965: PPUSH
6966: LD_VAR 0 4
6970: PUSH
6971: LD_INT 2
6973: PUSH
6974: EMPTY
6975: LIST
6976: LIST
6977: PPUSH
6978: LD_INT 1
6980: PPUSH
6981: CALL 24363 0 3
6985: ST_TO_ADDR
6986: GO 6911
6988: POP
6989: POP
// end else
6990: GO 7086
// begin for i := 1 to weaponsData do
6992: LD_ADDR_VAR 0 4
6996: PUSH
6997: DOUBLE
6998: LD_INT 1
7000: DEC
7001: ST_TO_ADDR
7002: LD_EXP 12
7006: PUSH
7007: FOR_TO
7008: IFFALSE 7084
// if weaponsData [ i ] [ 1 ] = weapon and weaponsData [ i ] [ 3 ] = false then
7010: LD_EXP 12
7014: PUSH
7015: LD_VAR 0 4
7019: ARRAY
7020: PUSH
7021: LD_INT 1
7023: ARRAY
7024: PUSH
7025: LD_VAR 0 1
7029: EQUAL
7030: PUSH
7031: LD_EXP 12
7035: PUSH
7036: LD_VAR 0 4
7040: ARRAY
7041: PUSH
7042: LD_INT 3
7044: ARRAY
7045: PUSH
7046: LD_INT 0
7048: EQUAL
7049: AND
7050: IFFALSE 7082
// weaponsData = ReplaceIn ( weaponsData , [ i , 3 ] , true ) ;
7052: LD_ADDR_EXP 12
7056: PUSH
7057: LD_EXP 12
7061: PPUSH
7062: LD_VAR 0 4
7066: PUSH
7067: LD_INT 3
7069: PUSH
7070: EMPTY
7071: LIST
7072: LIST
7073: PPUSH
7074: LD_INT 1
7076: PPUSH
7077: CALL 24363 0 3
7081: ST_TO_ADDR
7082: GO 7007
7084: POP
7085: POP
// end ; end ;
7086: LD_VAR 0 3
7090: RET
// export function ShootTreningController ; var i , unitsInArea , unit , depots , depot , barrelsAreaList , randIndex , randPosX , randPosY , barrelsInArea ; begin
7091: LD_INT 0
7093: PPUSH
7094: PPUSH
7095: PPUSH
7096: PPUSH
7097: PPUSH
7098: PPUSH
7099: PPUSH
7100: PPUSH
7101: PPUSH
7102: PPUSH
7103: PPUSH
// unitsInArea = FilterUnitsInArea ( ShootArea , [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) ;
7104: LD_ADDR_VAR 0 3
7108: PUSH
7109: LD_INT 12
7111: PPUSH
7112: LD_INT 22
7114: PUSH
7115: LD_INT 3
7117: PUSH
7118: EMPTY
7119: LIST
7120: LIST
7121: PUSH
7122: LD_INT 21
7124: PUSH
7125: LD_INT 1
7127: PUSH
7128: EMPTY
7129: LIST
7130: LIST
7131: PUSH
7132: LD_INT 50
7134: PUSH
7135: EMPTY
7136: LIST
7137: PUSH
7138: LD_INT 3
7140: PUSH
7141: LD_INT 60
7143: PUSH
7144: EMPTY
7145: LIST
7146: PUSH
7147: EMPTY
7148: LIST
7149: LIST
7150: PUSH
7151: EMPTY
7152: LIST
7153: LIST
7154: LIST
7155: LIST
7156: PPUSH
7157: CALL_OW 70
7161: ST_TO_ADDR
// depots = FilterAllUnits ( [ [ f_side , 3 ] , [ f_ok ] , [ f_type , unit_building ] , [ f_not , [ f_constructed ] ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
7162: LD_ADDR_VAR 0 5
7166: PUSH
7167: LD_INT 22
7169: PUSH
7170: LD_INT 3
7172: PUSH
7173: EMPTY
7174: LIST
7175: LIST
7176: PUSH
7177: LD_INT 50
7179: PUSH
7180: EMPTY
7181: LIST
7182: PUSH
7183: LD_INT 21
7185: PUSH
7186: LD_INT 3
7188: PUSH
7189: EMPTY
7190: LIST
7191: LIST
7192: PUSH
7193: LD_INT 3
7195: PUSH
7196: LD_INT 57
7198: PUSH
7199: EMPTY
7200: LIST
7201: PUSH
7202: EMPTY
7203: LIST
7204: LIST
7205: PUSH
7206: LD_INT 2
7208: PUSH
7209: LD_INT 30
7211: PUSH
7212: LD_INT 0
7214: PUSH
7215: EMPTY
7216: LIST
7217: LIST
7218: PUSH
7219: LD_INT 30
7221: PUSH
7222: LD_INT 1
7224: PUSH
7225: EMPTY
7226: LIST
7227: LIST
7228: PUSH
7229: EMPTY
7230: LIST
7231: LIST
7232: LIST
7233: PUSH
7234: EMPTY
7235: LIST
7236: LIST
7237: LIST
7238: LIST
7239: LIST
7240: PPUSH
7241: CALL_OW 69
7245: ST_TO_ADDR
// barrelsAreaList = AreaToList ( BarrelsArea , 0 ) ;
7246: LD_ADDR_VAR 0 7
7250: PUSH
7251: LD_INT 13
7253: PPUSH
7254: LD_INT 0
7256: PPUSH
7257: CALL_OW 517
7261: ST_TO_ADDR
// if not depots or not unitsInArea then
7262: LD_VAR 0 5
7266: NOT
7267: PUSH
7268: LD_VAR 0 3
7272: NOT
7273: OR
7274: IFFALSE 7278
// exit ;
7276: GO 7714
// depot = depots [ 1 ] ;
7278: LD_ADDR_VAR 0 6
7282: PUSH
7283: LD_VAR 0 5
7287: PUSH
7288: LD_INT 1
7290: ARRAY
7291: ST_TO_ADDR
// for unit in unitsInArea do
7292: LD_ADDR_VAR 0 4
7296: PUSH
7297: LD_VAR 0 3
7301: PUSH
7302: FOR_IN
7303: IFFALSE 7712
// begin if not GetClass ( unit ) = class_engineer then
7305: LD_VAR 0 4
7309: PPUSH
7310: CALL_OW 257
7314: PUSH
7315: LD_INT 2
7317: EQUAL
7318: NOT
7319: IFFALSE 7356
// begin ComEnterUnit ( unit , depot ) ;
7321: LD_VAR 0 4
7325: PPUSH
7326: LD_VAR 0 6
7330: PPUSH
7331: CALL_OW 120
// AddComChangeProfession ( unit , class_engineer ) ;
7335: LD_VAR 0 4
7339: PPUSH
7340: LD_INT 2
7342: PPUSH
7343: CALL_OW 183
// AddComExitBuilding ( unit ) ;
7347: LD_VAR 0 4
7351: PPUSH
7352: CALL_OW 182
// end ; if GetCargo ( unit , mat_oil ) = 0 then
7356: LD_VAR 0 4
7360: PPUSH
7361: LD_INT 2
7363: PPUSH
7364: CALL_OW 289
7368: PUSH
7369: LD_INT 0
7371: EQUAL
7372: IFFALSE 7391
// AddComTransport ( unit , depot , mat_oil ) ;
7374: LD_VAR 0 4
7378: PPUSH
7379: LD_VAR 0 6
7383: PPUSH
7384: LD_INT 2
7386: PPUSH
7387: CALL_OW 211
// repeat wait ( 0 0$1 ) ;
7391: LD_INT 35
7393: PPUSH
7394: CALL_OW 67
// until not HasTask ( unit ) ;
7398: LD_VAR 0 4
7402: PPUSH
7403: CALL_OW 314
7407: NOT
7408: IFFALSE 7391
// if GetCargo ( unit , mat_oil ) > 0 then
7410: LD_VAR 0 4
7414: PPUSH
7415: LD_INT 2
7417: PPUSH
7418: CALL_OW 289
7422: PUSH
7423: LD_INT 0
7425: GREATER
7426: IFFALSE 7710
// begin randIndex = Rand ( 1 , barrelsAreaList [ 1 ] ) ;
7428: LD_ADDR_VAR 0 8
7432: PUSH
7433: LD_INT 1
7435: PPUSH
7436: LD_VAR 0 7
7440: PUSH
7441: LD_INT 1
7443: ARRAY
7444: PPUSH
7445: CALL_OW 12
7449: ST_TO_ADDR
// randPosX = barrelsAreaList [ 1 ] [ randIndex ] ;
7450: LD_ADDR_VAR 0 9
7454: PUSH
7455: LD_VAR 0 7
7459: PUSH
7460: LD_INT 1
7462: ARRAY
7463: PUSH
7464: LD_VAR 0 8
7468: ARRAY
7469: ST_TO_ADDR
// randPosY = barrelsAreaList [ 2 ] [ RandIndex ] ;
7470: LD_ADDR_VAR 0 10
7474: PUSH
7475: LD_VAR 0 7
7479: PUSH
7480: LD_INT 2
7482: ARRAY
7483: PUSH
7484: LD_VAR 0 8
7488: ARRAY
7489: ST_TO_ADDR
// AddComMoveXY ( unit , randPosX , randPosY ) ;
7490: LD_VAR 0 4
7494: PPUSH
7495: LD_VAR 0 9
7499: PPUSH
7500: LD_VAR 0 10
7504: PPUSH
7505: CALL_OW 171
// AddComUnload ( unit ) ;
7509: LD_VAR 0 4
7513: PPUSH
7514: CALL_OW 219
// AddComMoveXY ( unit , randPosX + 2 , randPosY + 2 ) ;
7518: LD_VAR 0 4
7522: PPUSH
7523: LD_VAR 0 9
7527: PUSH
7528: LD_INT 2
7530: PLUS
7531: PPUSH
7532: LD_VAR 0 10
7536: PUSH
7537: LD_INT 2
7539: PLUS
7540: PPUSH
7541: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
7545: LD_INT 35
7547: PPUSH
7548: CALL_OW 67
// until not HasTask ( unit ) ;
7552: LD_VAR 0 4
7556: PPUSH
7557: CALL_OW 314
7561: NOT
7562: IFFALSE 7545
// barrelsInArea = GetListOfCratesInArea ( ShootArea ) ;
7564: LD_ADDR_VAR 0 11
7568: PUSH
7569: LD_INT 12
7571: PPUSH
7572: CALL_OW 435
7576: ST_TO_ADDR
// for i := 1 to barrelsInArea / 2 do
7577: LD_ADDR_VAR 0 2
7581: PUSH
7582: DOUBLE
7583: LD_INT 1
7585: DEC
7586: ST_TO_ADDR
7587: LD_VAR 0 11
7591: PUSH
7592: LD_INT 2
7594: DIVREAL
7595: PUSH
7596: FOR_TO
7597: IFFALSE 7708
// begin if GetDistUnitXY ( unit , barrelsInArea [ i ] , barrelsInArea [ i + 1 ] ) <= 6 then
7599: LD_VAR 0 4
7603: PPUSH
7604: LD_VAR 0 11
7608: PUSH
7609: LD_VAR 0 2
7613: ARRAY
7614: PPUSH
7615: LD_VAR 0 11
7619: PUSH
7620: LD_VAR 0 2
7624: PUSH
7625: LD_INT 1
7627: PLUS
7628: ARRAY
7629: PPUSH
7630: CALL_OW 297
7634: PUSH
7635: LD_INT 6
7637: LESSEQUAL
7638: IFFALSE 7692
// begin AddComAttackPlace ( unit , barrelsInArea [ i ] , barrelsInArea [ i + 1 ] ) ;
7640: LD_VAR 0 4
7644: PPUSH
7645: LD_VAR 0 11
7649: PUSH
7650: LD_VAR 0 2
7654: ARRAY
7655: PPUSH
7656: LD_VAR 0 11
7660: PUSH
7661: LD_VAR 0 2
7665: PUSH
7666: LD_INT 1
7668: PLUS
7669: ARRAY
7670: PPUSH
7671: CALL_OW 176
// AddExperience ( unit , skill_combat , 5 ) ;
7675: LD_VAR 0 4
7679: PPUSH
7680: LD_INT 1
7682: PPUSH
7683: LD_INT 5
7685: PPUSH
7686: CALL_OW 492
// break ;
7690: GO 7708
// end ; i = i + 2 ;
7692: LD_ADDR_VAR 0 2
7696: PUSH
7697: LD_VAR 0 2
7701: PUSH
7702: LD_INT 2
7704: PLUS
7705: ST_TO_ADDR
// end ;
7706: GO 7596
7708: POP
7709: POP
// end ; end ;
7710: GO 7302
7712: POP
7713: POP
// end ;
7714: LD_VAR 0 1
7718: RET
// export function GoToHunt ( hunter ) ; var i , barracks , barrackTarget , barrackTargetCurrentHP , animals , animal ; begin
7719: LD_INT 0
7721: PPUSH
7722: PPUSH
7723: PPUSH
7724: PPUSH
7725: PPUSH
7726: PPUSH
7727: PPUSH
// animals = [ ] ;
7728: LD_ADDR_VAR 0 7
7732: PUSH
7733: EMPTY
7734: ST_TO_ADDR
// barracks = FilterAllUnits ( [ [ f_ok ] , [ f_not , [ f_constructed ] ] , [ f_or , [ f_btype , b_barracks ] , [ f_btype , b_armoury ] ] ] ) ;
7735: LD_ADDR_VAR 0 4
7739: PUSH
7740: LD_INT 50
7742: PUSH
7743: EMPTY
7744: LIST
7745: PUSH
7746: LD_INT 3
7748: PUSH
7749: LD_INT 57
7751: PUSH
7752: EMPTY
7753: LIST
7754: PUSH
7755: EMPTY
7756: LIST
7757: LIST
7758: PUSH
7759: LD_INT 2
7761: PUSH
7762: LD_INT 30
7764: PUSH
7765: LD_INT 5
7767: PUSH
7768: EMPTY
7769: LIST
7770: LIST
7771: PUSH
7772: LD_INT 30
7774: PUSH
7775: LD_INT 4
7777: PUSH
7778: EMPTY
7779: LIST
7780: LIST
7781: PUSH
7782: EMPTY
7783: LIST
7784: LIST
7785: LIST
7786: PUSH
7787: EMPTY
7788: LIST
7789: LIST
7790: LIST
7791: PPUSH
7792: CALL_OW 69
7796: ST_TO_ADDR
// SetSide ( hunter , 6 ) ;
7797: LD_VAR 0 1
7801: PPUSH
7802: LD_INT 6
7804: PPUSH
7805: CALL_OW 235
// if IsInUnit ( hunter ) then
7809: LD_VAR 0 1
7813: PPUSH
7814: CALL_OW 310
7818: IFFALSE 7860
// begin if GetBType ( IsInUnit ( hunter ) = unit_vehicle ) then
7820: LD_VAR 0 1
7824: PPUSH
7825: CALL_OW 310
7829: PUSH
7830: LD_INT 2
7832: EQUAL
7833: PPUSH
7834: CALL_OW 266
7838: IFFALSE 7851
// ComExitVehicle ( hunter ) else
7840: LD_VAR 0 1
7844: PPUSH
7845: CALL_OW 121
7849: GO 7860
// ComExitBuilding ( hunter ) ;
7851: LD_VAR 0 1
7855: PPUSH
7856: CALL_OW 122
// end ; ComWalk ( hunter ) ;
7860: LD_VAR 0 1
7864: PPUSH
7865: CALL_OW 138
// wait ( 0 0$1 ) ;
7869: LD_INT 35
7871: PPUSH
7872: CALL_OW 67
// if not GetClass ( hunter ) = class_soldier and barracks then
7876: LD_VAR 0 1
7880: PPUSH
7881: CALL_OW 257
7885: PUSH
7886: LD_INT 1
7888: EQUAL
7889: NOT
7890: PUSH
7891: LD_VAR 0 4
7895: AND
7896: IFFALSE 8039
// begin barrackTarget = barracks [ 1 ] ;
7898: LD_ADDR_VAR 0 5
7902: PUSH
7903: LD_VAR 0 4
7907: PUSH
7908: LD_INT 1
7910: ARRAY
7911: ST_TO_ADDR
// barrackTargetCurrentHP = GetLives ( barrackTarget ) ;
7912: LD_ADDR_VAR 0 6
7916: PUSH
7917: LD_VAR 0 5
7921: PPUSH
7922: CALL_OW 256
7926: ST_TO_ADDR
// SetSide ( barrackTarget , 6 ) ;
7927: LD_VAR 0 5
7931: PPUSH
7932: LD_INT 6
7934: PPUSH
7935: CALL_OW 235
// ComEnterUnit ( hunter , barrackTarget ) ;
7939: LD_VAR 0 1
7943: PPUSH
7944: LD_VAR 0 5
7948: PPUSH
7949: CALL_OW 120
// repeat wait ( 0 0$1 ) ;
7953: LD_INT 35
7955: PPUSH
7956: CALL_OW 67
// ComEnterUnit ( hunter , barrackTarget ) ;
7960: LD_VAR 0 1
7964: PPUSH
7965: LD_VAR 0 5
7969: PPUSH
7970: CALL_OW 120
// SetLives ( barrackTarget , barrackTargetCurrentHP ) ;
7974: LD_VAR 0 5
7978: PPUSH
7979: LD_VAR 0 6
7983: PPUSH
7984: CALL_OW 234
// until IsInUnit ( hunter ) ;
7988: LD_VAR 0 1
7992: PPUSH
7993: CALL_OW 310
7997: IFFALSE 7953
// SetClass ( hunter , class_soldier ) ;
7999: LD_VAR 0 1
8003: PPUSH
8004: LD_INT 1
8006: PPUSH
8007: CALL_OW 336
// ComExitBuilding ( hunter ) ;
8011: LD_VAR 0 1
8015: PPUSH
8016: CALL_OW 122
// SetSide ( barrackTarget , 3 ) ;
8020: LD_VAR 0 5
8024: PPUSH
8025: LD_INT 3
8027: PPUSH
8028: CALL_OW 235
// wait ( 0 0$1 ) ;
8032: LD_INT 35
8034: PPUSH
8035: CALL_OW 67
// end ; for i := 1 to 3 do
8039: LD_ADDR_VAR 0 3
8043: PUSH
8044: DOUBLE
8045: LD_INT 1
8047: DEC
8048: ST_TO_ADDR
8049: LD_INT 3
8051: PUSH
8052: FOR_TO
8053: IFFALSE 8158
// begin uc_side = 0 ;
8055: LD_ADDR_OWVAR 20
8059: PUSH
8060: LD_INT 0
8062: ST_TO_ADDR
// uc_nation = nation_nature ;
8063: LD_ADDR_OWVAR 21
8067: PUSH
8068: LD_INT 0
8070: ST_TO_ADDR
// PrepareHuman ( false , [ class_phororhacos , class_tiger , 21 ] [ Rand ( 1 , 3 ) ] , 0 ) ;
8071: LD_INT 0
8073: PPUSH
8074: LD_INT 18
8076: PUSH
8077: LD_INT 14
8079: PUSH
8080: LD_INT 21
8082: PUSH
8083: EMPTY
8084: LIST
8085: LIST
8086: LIST
8087: PUSH
8088: LD_INT 1
8090: PPUSH
8091: LD_INT 3
8093: PPUSH
8094: CALL_OW 12
8098: ARRAY
8099: PPUSH
8100: LD_INT 0
8102: PPUSH
8103: CALL_OW 380
// hc_agressivity = 0 ;
8107: LD_ADDR_OWVAR 35
8111: PUSH
8112: LD_INT 0
8114: ST_TO_ADDR
// animal = CreateHuman ;
8115: LD_ADDR_VAR 0 8
8119: PUSH
8120: CALL_OW 44
8124: ST_TO_ADDR
// PlaceUnitArea ( animal , NatureArea , false ) ;
8125: LD_VAR 0 8
8129: PPUSH
8130: LD_INT 5
8132: PPUSH
8133: LD_INT 0
8135: PPUSH
8136: CALL_OW 49
// animals = animals ^ animal ;
8140: LD_ADDR_VAR 0 7
8144: PUSH
8145: LD_VAR 0 7
8149: PUSH
8150: LD_VAR 0 8
8154: ADD
8155: ST_TO_ADDR
// end ;
8156: GO 8052
8158: POP
8159: POP
// for i := 1 to animals do
8160: LD_ADDR_VAR 0 3
8164: PUSH
8165: DOUBLE
8166: LD_INT 1
8168: DEC
8169: ST_TO_ADDR
8170: LD_VAR 0 7
8174: PUSH
8175: FOR_TO
8176: IFFALSE 8200
// AddComAttackUnit ( hunter , animals [ i ] ) ;
8178: LD_VAR 0 1
8182: PPUSH
8183: LD_VAR 0 7
8187: PUSH
8188: LD_VAR 0 3
8192: ARRAY
8193: PPUSH
8194: CALL_OW 175
8198: GO 8175
8200: POP
8201: POP
// repeat wait ( 0 0$1 ) ;
8202: LD_INT 35
8204: PPUSH
8205: CALL_OW 67
// if GetClass ( hunter ) = class_soldier then
8209: LD_VAR 0 1
8213: PPUSH
8214: CALL_OW 257
8218: PUSH
8219: LD_INT 1
8221: EQUAL
8222: IFFALSE 8269
// begin if GetDistUnits ( hunter , WantsToAttack ( hunter ) ) < 13 then
8224: LD_VAR 0 1
8228: PPUSH
8229: LD_VAR 0 1
8233: PPUSH
8234: CALL_OW 319
8238: PPUSH
8239: CALL_OW 296
8243: PUSH
8244: LD_INT 13
8246: LESS
8247: IFFALSE 8260
// ComCrawl ( hunter ) else
8249: LD_VAR 0 1
8253: PPUSH
8254: CALL_OW 137
8258: GO 8269
// ComWalk ( hunter ) ;
8260: LD_VAR 0 1
8264: PPUSH
8265: CALL_OW 138
// end ; until not HasTask ( hunter ) ;
8269: LD_VAR 0 1
8273: PPUSH
8274: CALL_OW 314
8278: NOT
8279: IFFALSE 8202
// repeat wait ( 0 0$1 ) ;
8281: LD_INT 35
8283: PPUSH
8284: CALL_OW 67
// ComMoveXY ( hunter , GetX ( Burlak ) , GetY ( Burlak ) ) ;
8288: LD_VAR 0 1
8292: PPUSH
8293: LD_EXP 57
8297: PPUSH
8298: CALL_OW 250
8302: PPUSH
8303: LD_EXP 57
8307: PPUSH
8308: CALL_OW 251
8312: PPUSH
8313: CALL_OW 111
// until GetDistUnits ( hunter , Burlak ) <= 9 ;
8317: LD_VAR 0 1
8321: PPUSH
8322: LD_EXP 57
8326: PPUSH
8327: CALL_OW 296
8331: PUSH
8332: LD_INT 9
8334: LESSEQUAL
8335: IFFALSE 8281
// SetSide ( hunter , 3 ) ;
8337: LD_VAR 0 1
8341: PPUSH
8342: LD_INT 3
8344: PPUSH
8345: CALL_OW 235
// CenterOnUnits ( hunter ) ;
8349: LD_VAR 0 1
8353: PPUSH
8354: CALL_OW 85
// AddExperience ( hunter , skill_combat , 3000 ) ;
8358: LD_VAR 0 1
8362: PPUSH
8363: LD_INT 1
8365: PPUSH
8366: LD_INT 3000
8368: PPUSH
8369: CALL_OW 492
// end ;
8373: LD_VAR 0 2
8377: RET
// export function SetMashaData ( vehicle ) ; begin
8378: LD_INT 0
8380: PPUSH
// if Masha then
8381: LD_EXP 4
8385: IFFALSE 8403
// SetMark ( Masha [ 1 ] , 0 ) ;
8387: LD_EXP 4
8391: PUSH
8392: LD_INT 1
8394: ARRAY
8395: PPUSH
8396: LD_INT 0
8398: PPUSH
8399: CALL_OW 242
// Masha = [ vehicle , GetChassis ( vehicle ) , GetEngine ( vehicle ) , GetControl ( vehicle ) , GetWeapon ( vehicle ) ] ;
8403: LD_ADDR_EXP 4
8407: PUSH
8408: LD_VAR 0 1
8412: PUSH
8413: LD_VAR 0 1
8417: PPUSH
8418: CALL_OW 265
8422: PUSH
8423: LD_VAR 0 1
8427: PPUSH
8428: CALL_OW 262
8432: PUSH
8433: LD_VAR 0 1
8437: PPUSH
8438: CALL_OW 263
8442: PUSH
8443: LD_VAR 0 1
8447: PPUSH
8448: CALL_OW 264
8452: PUSH
8453: EMPTY
8454: LIST
8455: LIST
8456: LIST
8457: LIST
8458: LIST
8459: ST_TO_ADDR
// ChangeMissionObjectives ( MMashaDone ) ;
8460: LD_STRING MMashaDone
8462: PPUSH
8463: CALL_OW 337
// SetMark ( vehicle , 1 ) ;
8467: LD_VAR 0 1
8471: PPUSH
8472: LD_INT 1
8474: PPUSH
8475: CALL_OW 242
// end ;
8479: LD_VAR 0 2
8483: RET
// export function SaveBase ( buildings , ident ) ; var i , buildingsToSave ; begin
8484: LD_INT 0
8486: PPUSH
8487: PPUSH
8488: PPUSH
// buildingsToSave = [ ] ;
8489: LD_ADDR_VAR 0 5
8493: PUSH
8494: EMPTY
8495: ST_TO_ADDR
// if not buildings then
8496: LD_VAR 0 1
8500: NOT
8501: IFFALSE 8505
// exit ;
8503: GO 9080
// for i in buildings do
8505: LD_ADDR_VAR 0 4
8509: PUSH
8510: LD_VAR 0 1
8514: PUSH
8515: FOR_IN
8516: IFFALSE 9064
// begin if GetBType ( i ) in [ b_lab , b_lab_half , b_lab_full ] then
8518: LD_VAR 0 4
8522: PPUSH
8523: CALL_OW 266
8527: PUSH
8528: LD_INT 6
8530: PUSH
8531: LD_INT 7
8533: PUSH
8534: LD_INT 8
8536: PUSH
8537: EMPTY
8538: LIST
8539: LIST
8540: LIST
8541: IN
8542: IFFALSE 8667
// buildingsToSave = buildingsToSave ^ [ [ GetBType ( i ) , GetX ( i ) , GetY ( i ) , GetDir ( i ) , GetBLevel ( i ) , GetNation ( i ) , GetLives ( i ) , GetLabKind ( i , 1 ) , GetLabKind ( i , 2 ) ] ] else
8544: LD_ADDR_VAR 0 5
8548: PUSH
8549: LD_VAR 0 5
8553: PUSH
8554: LD_VAR 0 4
8558: PPUSH
8559: CALL_OW 266
8563: PUSH
8564: LD_VAR 0 4
8568: PPUSH
8569: CALL_OW 250
8573: PUSH
8574: LD_VAR 0 4
8578: PPUSH
8579: CALL_OW 251
8583: PUSH
8584: LD_VAR 0 4
8588: PPUSH
8589: CALL_OW 254
8593: PUSH
8594: LD_VAR 0 4
8598: PPUSH
8599: CALL_OW 267
8603: PUSH
8604: LD_VAR 0 4
8608: PPUSH
8609: CALL_OW 248
8613: PUSH
8614: LD_VAR 0 4
8618: PPUSH
8619: CALL_OW 256
8623: PUSH
8624: LD_VAR 0 4
8628: PPUSH
8629: LD_INT 1
8631: PPUSH
8632: CALL_OW 268
8636: PUSH
8637: LD_VAR 0 4
8641: PPUSH
8642: LD_INT 2
8644: PPUSH
8645: CALL_OW 268
8649: PUSH
8650: EMPTY
8651: LIST
8652: LIST
8653: LIST
8654: LIST
8655: LIST
8656: LIST
8657: LIST
8658: LIST
8659: LIST
8660: PUSH
8661: EMPTY
8662: LIST
8663: ADD
8664: ST_TO_ADDR
8665: GO 9062
// if GetBType ( i ) in [ b_bunker , b_turret ] then
8667: LD_VAR 0 4
8671: PPUSH
8672: CALL_OW 266
8676: PUSH
8677: LD_INT 32
8679: PUSH
8680: LD_INT 33
8682: PUSH
8683: EMPTY
8684: LIST
8685: LIST
8686: IN
8687: IFFALSE 8795
// buildingsToSave = buildingsToSave ^ [ [ GetBType ( i ) , GetX ( i ) , GetY ( i ) , GetDir ( i ) , GetBLevel ( i ) , GetNation ( i ) , GetLives ( i ) , GetBWeapon ( i ) ] ] else
8689: LD_ADDR_VAR 0 5
8693: PUSH
8694: LD_VAR 0 5
8698: PUSH
8699: LD_VAR 0 4
8703: PPUSH
8704: CALL_OW 266
8708: PUSH
8709: LD_VAR 0 4
8713: PPUSH
8714: CALL_OW 250
8718: PUSH
8719: LD_VAR 0 4
8723: PPUSH
8724: CALL_OW 251
8728: PUSH
8729: LD_VAR 0 4
8733: PPUSH
8734: CALL_OW 254
8738: PUSH
8739: LD_VAR 0 4
8743: PPUSH
8744: CALL_OW 267
8748: PUSH
8749: LD_VAR 0 4
8753: PPUSH
8754: CALL_OW 248
8758: PUSH
8759: LD_VAR 0 4
8763: PPUSH
8764: CALL_OW 256
8768: PUSH
8769: LD_VAR 0 4
8773: PPUSH
8774: CALL_OW 269
8778: PUSH
8779: EMPTY
8780: LIST
8781: LIST
8782: LIST
8783: LIST
8784: LIST
8785: LIST
8786: LIST
8787: LIST
8788: PUSH
8789: EMPTY
8790: LIST
8791: ADD
8792: ST_TO_ADDR
8793: GO 9062
// if GetBType ( i ) in [ b_depot , b_warehouse ] then
8795: LD_VAR 0 4
8799: PPUSH
8800: CALL_OW 266
8804: PUSH
8805: LD_INT 0
8807: PUSH
8808: LD_INT 1
8810: PUSH
8811: EMPTY
8812: LIST
8813: LIST
8814: IN
8815: IFFALSE 8969
// buildingsToSave = buildingsToSave ^ [ [ GetBType ( i ) , GetX ( i ) , GetY ( i ) , GetDir ( i ) , GetBLevel ( i ) , GetNation ( i ) , GetLives ( i ) , GetResourceType ( GetBase ( i ) , mat_cans ) , GetResourceType ( GetBase ( i ) , mat_oil ) , GetResourceType ( GetBase ( i ) , mat_siberit ) ] ] else
8817: LD_ADDR_VAR 0 5
8821: PUSH
8822: LD_VAR 0 5
8826: PUSH
8827: LD_VAR 0 4
8831: PPUSH
8832: CALL_OW 266
8836: PUSH
8837: LD_VAR 0 4
8841: PPUSH
8842: CALL_OW 250
8846: PUSH
8847: LD_VAR 0 4
8851: PPUSH
8852: CALL_OW 251
8856: PUSH
8857: LD_VAR 0 4
8861: PPUSH
8862: CALL_OW 254
8866: PUSH
8867: LD_VAR 0 4
8871: PPUSH
8872: CALL_OW 267
8876: PUSH
8877: LD_VAR 0 4
8881: PPUSH
8882: CALL_OW 248
8886: PUSH
8887: LD_VAR 0 4
8891: PPUSH
8892: CALL_OW 256
8896: PUSH
8897: LD_VAR 0 4
8901: PPUSH
8902: CALL_OW 274
8906: PPUSH
8907: LD_INT 1
8909: PPUSH
8910: CALL_OW 275
8914: PUSH
8915: LD_VAR 0 4
8919: PPUSH
8920: CALL_OW 274
8924: PPUSH
8925: LD_INT 2
8927: PPUSH
8928: CALL_OW 275
8932: PUSH
8933: LD_VAR 0 4
8937: PPUSH
8938: CALL_OW 274
8942: PPUSH
8943: LD_INT 3
8945: PPUSH
8946: CALL_OW 275
8950: PUSH
8951: EMPTY
8952: LIST
8953: LIST
8954: LIST
8955: LIST
8956: LIST
8957: LIST
8958: LIST
8959: LIST
8960: LIST
8961: LIST
8962: PUSH
8963: EMPTY
8964: LIST
8965: ADD
8966: ST_TO_ADDR
8967: GO 9062
// buildingsToSave = buildingsToSave ^ [ [ GetBType ( i ) , GetX ( i ) , GetY ( i ) , GetDir ( i ) , GetBLevel ( i ) , GetNation ( i ) , GetLives ( i ) ] ] ;
8969: LD_ADDR_VAR 0 5
8973: PUSH
8974: LD_VAR 0 5
8978: PUSH
8979: LD_VAR 0 4
8983: PPUSH
8984: CALL_OW 266
8988: PUSH
8989: LD_VAR 0 4
8993: PPUSH
8994: CALL_OW 250
8998: PUSH
8999: LD_VAR 0 4
9003: PPUSH
9004: CALL_OW 251
9008: PUSH
9009: LD_VAR 0 4
9013: PPUSH
9014: CALL_OW 254
9018: PUSH
9019: LD_VAR 0 4
9023: PPUSH
9024: CALL_OW 267
9028: PUSH
9029: LD_VAR 0 4
9033: PPUSH
9034: CALL_OW 248
9038: PUSH
9039: LD_VAR 0 4
9043: PPUSH
9044: CALL_OW 256
9048: PUSH
9049: EMPTY
9050: LIST
9051: LIST
9052: LIST
9053: LIST
9054: LIST
9055: LIST
9056: LIST
9057: PUSH
9058: EMPTY
9059: LIST
9060: ADD
9061: ST_TO_ADDR
// end ;
9062: GO 8515
9064: POP
9065: POP
// SaveVariable ( buildingsToSave , ident ) ;
9066: LD_VAR 0 5
9070: PPUSH
9071: LD_VAR 0 2
9075: PPUSH
9076: CALL_OW 39
// end ; end_of_file
9080: LD_VAR 0 3
9084: RET
// export function MissionIntro ; begin
9085: LD_INT 0
9087: PPUSH
// CenterNowOnUnits ( Burlak ) ;
9088: LD_EXP 57
9092: PPUSH
9093: CALL_OW 87
// DialogueOn ;
9097: CALL_OW 6
// SayRadio ( Popov , DStart-Pop-1 ) ;
9101: LD_EXP 76
9105: PPUSH
9106: LD_STRING DStart-Pop-1
9108: PPUSH
9109: CALL_OW 94
// Say ( Burlak , DStart-Bur-1 ) ;
9113: LD_EXP 57
9117: PPUSH
9118: LD_STRING DStart-Bur-1
9120: PPUSH
9121: CALL_OW 88
// DialogueOff ;
9125: CALL_OW 7
// IngameOff ;
9129: CALL_OW 9
// ChangeMissionObjectives ( MStart ) ;
9133: LD_STRING MStart
9135: PPUSH
9136: CALL_OW 337
// SaveForQuickRestart ;
9140: CALL_OW 22
// end ;
9144: LD_VAR 0 1
9148: RET
// export function Dial_EscortHeike ( x , y ) ; begin
9149: LD_INT 0
9151: PPUSH
// dial_BuildDepotBlocker = true ;
9152: LD_ADDR_EXP 5
9156: PUSH
9157: LD_INT 1
9159: ST_TO_ADDR
// HeikeTargetX = x ;
9160: LD_ADDR_EXP 14
9164: PUSH
9165: LD_VAR 0 1
9169: ST_TO_ADDR
// HeikeTargetY = y ;
9170: LD_ADDR_EXP 15
9174: PUSH
9175: LD_VAR 0 2
9179: ST_TO_ADDR
// SayRadio ( Popov , DHeike-Pop-1 ) ;
9180: LD_EXP 76
9184: PPUSH
9185: LD_STRING DHeike-Pop-1
9187: PPUSH
9188: CALL_OW 94
// wait ( 0 0$10 ) ;
9192: LD_INT 350
9194: PPUSH
9195: CALL_OW 67
// PrepareRussianEscort ;
9199: CALL 2320 0 0
// PlaceUnitArea ( Heike , RussianSpawn2Area , false ) ;
9203: LD_EXP 79
9207: PPUSH
9208: LD_INT 7
9210: PPUSH
9211: LD_INT 0
9213: PPUSH
9214: CALL_OW 49
// ComMoveXY ( russianEscort , HeikeTargetX , HeikeTargetY ) ;
9218: LD_EXP 77
9222: PPUSH
9223: LD_EXP 14
9227: PPUSH
9228: LD_EXP 15
9232: PPUSH
9233: CALL_OW 111
// AddComMoveToArea ( russianEscort , RussianSpawn2Area ) ;
9237: LD_EXP 77
9241: PPUSH
9242: LD_INT 7
9244: PPUSH
9245: CALL_OW 173
// ComMoveXY ( Heike , HeikeTargetX , HeikeTargetY ) ;
9249: LD_EXP 79
9253: PPUSH
9254: LD_EXP 14
9258: PPUSH
9259: LD_EXP 15
9263: PPUSH
9264: CALL_OW 111
// AddComHold ( Heike ) ;
9268: LD_EXP 79
9272: PPUSH
9273: CALL_OW 200
// end ;
9277: LD_VAR 0 3
9281: RET
// every 1 trigger GetDistUnitXY ( Heike , HeikeTargetX , HeikeTargetY ) <= 5 do
9282: LD_EXP 79
9286: PPUSH
9287: LD_EXP 14
9291: PPUSH
9292: LD_EXP 15
9296: PPUSH
9297: CALL_OW 297
9301: PUSH
9302: LD_INT 5
9304: LESSEQUAL
9305: IFFALSE 9318
9307: GO 9309
9309: DISABLE
// allowExitFromMap = 1 ;
9310: LD_ADDR_EXP 18
9314: PUSH
9315: LD_INT 1
9317: ST_TO_ADDR
9318: END
// every 7 7$0 trigger IsPlaced ( Heike ) and IsOk ( Heike ) and GetAttitude ( 3 , 5 ) = att_friend and HeikeCaptured do
9319: LD_EXP 79
9323: PPUSH
9324: CALL_OW 305
9328: PUSH
9329: LD_EXP 79
9333: PPUSH
9334: CALL_OW 302
9338: AND
9339: PUSH
9340: LD_INT 3
9342: PPUSH
9343: LD_INT 5
9345: PPUSH
9346: CALL_OW 81
9350: PUSH
9351: LD_INT 1
9353: EQUAL
9354: AND
9355: PUSH
9356: LD_EXP 1
9360: AND
9361: IFFALSE 9580
9363: GO 9365
9365: DISABLE
// begin DialogueOn ;
9366: CALL_OW 6
// SayRadio ( Kurt , DMercHelp-Kurt-1 ) ;
9370: LD_EXP 80
9374: PPUSH
9375: LD_STRING DMercHelp-Kurt-1
9377: PPUSH
9378: CALL_OW 94
// Say ( Burlak , DMercHelp-Bur-1 ) ;
9382: LD_EXP 57
9386: PPUSH
9387: LD_STRING DMercHelp-Bur-1
9389: PPUSH
9390: CALL_OW 88
// SayRadio ( Kurt , DMercHelp-Kurt-2 ) ;
9394: LD_EXP 80
9398: PPUSH
9399: LD_STRING DMercHelp-Kurt-2
9401: PPUSH
9402: CALL_OW 94
// Say ( Burlak , DMercHelp-Bur-2 ) ;
9406: LD_EXP 57
9410: PPUSH
9411: LD_STRING DMercHelp-Bur-2
9413: PPUSH
9414: CALL_OW 88
// SayRadio ( Kurt , DMercHelp-Kurt-3 ) ;
9418: LD_EXP 80
9422: PPUSH
9423: LD_STRING DMercHelp-Kurt-3
9425: PPUSH
9426: CALL_OW 94
// case Query ( QMerc ) of 1 :
9430: LD_STRING QMerc
9432: PPUSH
9433: CALL_OW 97
9437: PUSH
9438: LD_INT 1
9440: DOUBLE
9441: EQUAL
9442: IFTRUE 9446
9444: GO 9481
9446: POP
// begin Say ( Burlak , DQrMerc#1-Bur-1 ) ;
9447: LD_EXP 57
9451: PPUSH
9452: LD_STRING DQrMerc#1-Bur-1
9454: PPUSH
9455: CALL_OW 88
// SayRadio ( Kurt , DQrMerc#1-Kurt-1 ) ;
9459: LD_EXP 80
9463: PPUSH
9464: LD_STRING DQrMerc#1-Kurt-1
9466: PPUSH
9467: CALL_OW 94
// acceptKurtOffert = true ;
9471: LD_ADDR_EXP 19
9475: PUSH
9476: LD_INT 1
9478: ST_TO_ADDR
// end ; 2 :
9479: GO 9576
9481: LD_INT 2
9483: DOUBLE
9484: EQUAL
9485: IFTRUE 9489
9487: GO 9544
9489: POP
// begin askCommanders = true ;
9490: LD_ADDR_EXP 20
9494: PUSH
9495: LD_INT 1
9497: ST_TO_ADDR
// Say ( Burlak , DQrMerc#2-Bur-1 ) ;
9498: LD_EXP 57
9502: PPUSH
9503: LD_STRING DQrMerc#2-Bur-1
9505: PPUSH
9506: CALL_OW 88
// SayRadio ( Popov , DQrMerc#2-Pop-1 ) ;
9510: LD_EXP 76
9514: PPUSH
9515: LD_STRING DQrMerc#2-Pop-1
9517: PPUSH
9518: CALL_OW 94
// Say ( Burlak , DQrMerc#2-Bur-2 ) ;
9522: LD_EXP 57
9526: PPUSH
9527: LD_STRING DQrMerc#2-Bur-2
9529: PPUSH
9530: CALL_OW 88
// acceptKurtOffert = true ;
9534: LD_ADDR_EXP 19
9538: PUSH
9539: LD_INT 1
9541: ST_TO_ADDR
// end ; 3 :
9542: GO 9576
9544: LD_INT 3
9546: DOUBLE
9547: EQUAL
9548: IFTRUE 9552
9550: GO 9575
9552: POP
// begin Say ( Burlak , DQrMerc#3-Bur-1 ) ;
9553: LD_EXP 57
9557: PPUSH
9558: LD_STRING DQrMerc#3-Bur-1
9560: PPUSH
9561: CALL_OW 88
// KurtAttack = true ;
9565: LD_ADDR_EXP 25
9569: PUSH
9570: LD_INT 1
9572: ST_TO_ADDR
// end ; end ;
9573: GO 9576
9575: POP
// DialogueOff ;
9576: CALL_OW 7
// end ;
9580: END
// every 0 0$1 trigger acceptKurtOffert do
9581: LD_EXP 19
9585: IFFALSE 9741
9587: GO 9589
9589: DISABLE
// begin PlaceUnitArea ( Kurt , KurtSpawnArea , false ) ;
9590: LD_EXP 80
9594: PPUSH
9595: LD_INT 9
9597: PPUSH
9598: LD_INT 0
9600: PPUSH
9601: CALL_OW 49
// uc_side = 8 ;
9605: LD_ADDR_OWVAR 20
9609: PUSH
9610: LD_INT 8
9612: ST_TO_ADDR
// uc_nation = 2 ;
9613: LD_ADDR_OWVAR 21
9617: PUSH
9618: LD_INT 2
9620: ST_TO_ADDR
// PrepareEngineer ( false , 3 ) ;
9621: LD_INT 0
9623: PPUSH
9624: LD_INT 3
9626: PPUSH
9627: CALL_OW 382
// KurtEng = CreateHuman ;
9631: LD_ADDR_EXP 82
9635: PUSH
9636: CALL_OW 44
9640: ST_TO_ADDR
// PlaceUnitArea ( KurtEng , KurtSpawnArea , false ) ;
9641: LD_EXP 82
9645: PPUSH
9646: LD_INT 9
9648: PPUSH
9649: LD_INT 0
9651: PPUSH
9652: CALL_OW 49
// repeat wait ( 0 0$1 ) ;
9656: LD_INT 35
9658: PPUSH
9659: CALL_OW 67
// ComMoveXY ( [ Kurt , KurtEng ] , GetX ( Burlak ) , GetY ( Burlak ) ) ;
9663: LD_EXP 80
9667: PUSH
9668: LD_EXP 82
9672: PUSH
9673: EMPTY
9674: LIST
9675: LIST
9676: PPUSH
9677: LD_EXP 57
9681: PPUSH
9682: CALL_OW 250
9686: PPUSH
9687: LD_EXP 57
9691: PPUSH
9692: CALL_OW 251
9696: PPUSH
9697: CALL_OW 111
// until GetDistUnits ( Kurt , Burlak ) <= 5 or GetDistUnits ( KurtEng , Burlak ) <= 5 ;
9701: LD_EXP 80
9705: PPUSH
9706: LD_EXP 57
9710: PPUSH
9711: CALL_OW 296
9715: PUSH
9716: LD_INT 5
9718: LESSEQUAL
9719: PUSH
9720: LD_EXP 82
9724: PPUSH
9725: LD_EXP 57
9729: PPUSH
9730: CALL_OW 296
9734: PUSH
9735: LD_INT 5
9737: LESSEQUAL
9738: OR
9739: IFFALSE 9656
// end ;
9741: END
// every 0 0$1 trigger GetDistUnits ( Kurt , Burlak ) <= 5 or GetDistUnits ( KurtEng , Burlak ) <= 5 do
9742: LD_EXP 80
9746: PPUSH
9747: LD_EXP 57
9751: PPUSH
9752: CALL_OW 296
9756: PUSH
9757: LD_INT 5
9759: LESSEQUAL
9760: PUSH
9761: LD_EXP 82
9765: PPUSH
9766: LD_EXP 57
9770: PPUSH
9771: CALL_OW 296
9775: PUSH
9776: LD_INT 5
9778: LESSEQUAL
9779: OR
9780: IFFALSE 9959
9782: GO 9784
9784: DISABLE
// begin KurtWaitingForBuildBarrack = true ;
9785: LD_ADDR_EXP 24
9789: PUSH
9790: LD_INT 1
9792: ST_TO_ADDR
// SetSide ( KurtEng , 3 ) ;
9793: LD_EXP 82
9797: PPUSH
9798: LD_INT 3
9800: PPUSH
9801: CALL_OW 235
// wait ( 1 1$30 ) ;
9805: LD_INT 3150
9807: PPUSH
9808: CALL_OW 67
// DialogueOn ;
9812: CALL_OW 6
// SayRadio ( Dietrich , DArabianRequest-Diet-1 ) ;
9816: LD_EXP 81
9820: PPUSH
9821: LD_STRING DArabianRequest-Diet-1
9823: PPUSH
9824: CALL_OW 94
// Say ( Burlak , DArabianRequest-Bur-1 ) ;
9828: LD_EXP 57
9832: PPUSH
9833: LD_STRING DArabianRequest-Bur-1
9835: PPUSH
9836: CALL_OW 88
// SayRadio ( Dietrich , DArabianRequest-Diet-2 ) ;
9840: LD_EXP 81
9844: PPUSH
9845: LD_STRING DArabianRequest-Diet-2
9847: PPUSH
9848: CALL_OW 94
// DialogueOff ;
9852: CALL_OW 7
// case Query ( QHandOver ) of 1 :
9856: LD_STRING QHandOver
9858: PPUSH
9859: CALL_OW 97
9863: PUSH
9864: LD_INT 1
9866: DOUBLE
9867: EQUAL
9868: IFTRUE 9872
9870: GO 9911
9872: POP
// begin Say ( Burlak , DQrHandOver#1-Bur-1 ) ;
9873: LD_EXP 57
9877: PPUSH
9878: LD_STRING DQrHandOver#1-Bur-1
9880: PPUSH
9881: CALL_OW 88
// SayRadio ( Dietrich , DQrHandOver#1-Diet-1 ) ;
9885: LD_EXP 81
9889: PPUSH
9890: LD_STRING DQrHandOver#1-Diet-1
9892: PPUSH
9893: CALL_OW 94
// coopWithGensher = true ;
9897: LD_ADDR_EXP 2
9901: PUSH
9902: LD_INT 1
9904: ST_TO_ADDR
// SpawnGensherTeam ;
9905: CALL 3946 0 0
// end ; 2 :
9909: GO 9959
9911: LD_INT 2
9913: DOUBLE
9914: EQUAL
9915: IFTRUE 9919
9917: GO 9958
9919: POP
// begin Say ( Burlak , DQrHandOver#2-Bur-1 ) ;
9920: LD_EXP 57
9924: PPUSH
9925: LD_STRING DQrHandOver#2-Bur-1
9927: PPUSH
9928: CALL_OW 88
// SayRadio ( Dietrich , DQrHandOver#2-Diet-1 ) ;
9932: LD_EXP 81
9936: PPUSH
9937: LD_STRING DQrHandOver#2-Diet-1
9939: PPUSH
9940: CALL_OW 94
// Say ( Burlak , DQrHandOver#2-Bur-2 ) ;
9944: LD_EXP 57
9948: PPUSH
9949: LD_STRING DQrHandOver#2-Bur-2
9951: PPUSH
9952: CALL_OW 88
// end ; end ;
9956: GO 9959
9958: POP
// end ;
9959: END
// export function Dial_UpgradeArmoury ; begin
9960: LD_INT 0
9962: PPUSH
// dial_BuildArBarrackBlocker = true ;
9963: LD_ADDR_EXP 6
9967: PUSH
9968: LD_INT 1
9970: ST_TO_ADDR
// buildArabBarrack = true ;
9971: LD_ADDR_EXP 38
9975: PUSH
9976: LD_INT 1
9978: ST_TO_ADDR
// if GetSide ( Kurt ) = 2 or GetSide ( KurtEng ) = 8 then
9979: LD_EXP 80
9983: PPUSH
9984: CALL_OW 255
9988: PUSH
9989: LD_INT 2
9991: EQUAL
9992: PUSH
9993: LD_EXP 82
9997: PPUSH
9998: CALL_OW 255
10002: PUSH
10003: LD_INT 8
10005: EQUAL
10006: OR
10007: IFFALSE 10011
// exit ;
10009: GO 10111
// SetSide ( KurtEng , 8 ) ;
10011: LD_EXP 82
10015: PPUSH
10016: LD_INT 8
10018: PPUSH
10019: CALL_OW 235
// ComStop ( KurtEng ) ;
10023: LD_EXP 82
10027: PPUSH
10028: CALL_OW 141
// DialogueOn ;
10032: CALL_OW 6
// Say ( Kurt , DMercCompleted-Kurt-1 ) ;
10036: LD_EXP 80
10040: PPUSH
10041: LD_STRING DMercCompleted-Kurt-1
10043: PPUSH
10044: CALL_OW 88
// DialogueOff ;
10048: CALL_OW 7
// canSendHeike = true ;
10052: LD_ADDR_EXP 28
10056: PUSH
10057: LD_INT 1
10059: ST_TO_ADDR
// KurtWaitingForFreeHeike = true ;
10060: LD_ADDR_EXP 23
10064: PUSH
10065: LD_INT 1
10067: ST_TO_ADDR
// KurtWaitingForBuildBarrack = false ;
10068: LD_ADDR_EXP 24
10072: PUSH
10073: LD_INT 0
10075: ST_TO_ADDR
// allowExitFromMap = 3 ;
10076: LD_ADDR_EXP 18
10080: PUSH
10081: LD_INT 3
10083: ST_TO_ADDR
// if KurtCanEscape then
10084: LD_EXP 21
10088: IFFALSE 10111
// ComMoveToArea ( [ Kurt , KurtEng ] , KurtExitMapArea ) ;
10090: LD_EXP 80
10094: PUSH
10095: LD_EXP 82
10099: PUSH
10100: EMPTY
10101: LIST
10102: LIST
10103: PPUSH
10104: LD_INT 11
10106: PPUSH
10107: CALL_OW 113
// end ;
10111: LD_VAR 0 1
10115: RET
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 2 ] ] ) and not dial_ArriveGensherUnitsBlocker do var veh , nearGensherUnit , maleSold , waitForKurt ;
10116: LD_INT 22
10118: PUSH
10119: LD_INT 2
10121: PUSH
10122: EMPTY
10123: LIST
10124: LIST
10125: PUSH
10126: EMPTY
10127: LIST
10128: PPUSH
10129: CALL_OW 69
10133: PUSH
10134: LD_EXP 7
10138: NOT
10139: AND
10140: IFFALSE 10913
10142: GO 10144
10144: DISABLE
10145: LD_INT 0
10147: PPUSH
10148: PPUSH
10149: PPUSH
10150: PPUSH
// begin nearGensherUnit = NearestUnitToXY ( UnitFilter ( GensherTeam , [ [ f_type , unit_vehicle ] ] ) , GensherTargetX , GensherTargetY ) ;
10151: LD_ADDR_VAR 0 2
10155: PUSH
10156: LD_EXP 83
10160: PPUSH
10161: LD_INT 21
10163: PUSH
10164: LD_INT 2
10166: PUSH
10167: EMPTY
10168: LIST
10169: LIST
10170: PUSH
10171: EMPTY
10172: LIST
10173: PPUSH
10174: CALL_OW 72
10178: PPUSH
10179: LD_EXP 16
10183: PPUSH
10184: LD_EXP 17
10188: PPUSH
10189: CALL_OW 73
10193: ST_TO_ADDR
// maleSold = UnitsInside ( nearGensherUnit [ 1 ] ) ;
10194: LD_ADDR_VAR 0 3
10198: PUSH
10199: LD_VAR 0 2
10203: PUSH
10204: LD_INT 1
10206: ARRAY
10207: PPUSH
10208: CALL_OW 313
10212: ST_TO_ADDR
// if GetDistUnitXY ( nearGensherUnit , GensherTargetX , GensherTargetY ) <= 5 then
10213: LD_VAR 0 2
10217: PPUSH
10218: LD_EXP 16
10222: PPUSH
10223: LD_EXP 17
10227: PPUSH
10228: CALL_OW 297
10232: PUSH
10233: LD_INT 5
10235: LESSEQUAL
10236: IFFALSE 10912
// begin dial_ArriveGensherUnitsBlocker = true ;
10238: LD_ADDR_EXP 7
10242: PUSH
10243: LD_INT 1
10245: ST_TO_ADDR
// for veh in UnitFilter ( GensherTeam , [ [ f_type , unit_vehicle ] ] ) do
10246: LD_ADDR_VAR 0 1
10250: PUSH
10251: LD_EXP 83
10255: PPUSH
10256: LD_INT 21
10258: PUSH
10259: LD_INT 2
10261: PUSH
10262: EMPTY
10263: LIST
10264: LIST
10265: PUSH
10266: EMPTY
10267: LIST
10268: PPUSH
10269: CALL_OW 72
10273: PUSH
10274: FOR_IN
10275: IFFALSE 10297
// ComExitVehicle ( UnitsInside ( veh ) [ 1 ] ) ;
10277: LD_VAR 0 1
10281: PPUSH
10282: CALL_OW 313
10286: PUSH
10287: LD_INT 1
10289: ARRAY
10290: PPUSH
10291: CALL_OW 121
10295: GO 10274
10297: POP
10298: POP
// wait ( 0 0$1 ) ;
10299: LD_INT 35
10301: PPUSH
10302: CALL_OW 67
// SetSide ( UnitFilter ( GensherTeam , [ [ f_type , unit_vehicle ] ] ) , 3 ) ;
10306: LD_EXP 83
10310: PPUSH
10311: LD_INT 21
10313: PUSH
10314: LD_INT 2
10316: PUSH
10317: EMPTY
10318: LIST
10319: LIST
10320: PUSH
10321: EMPTY
10322: LIST
10323: PPUSH
10324: CALL_OW 72
10328: PPUSH
10329: LD_INT 3
10331: PPUSH
10332: CALL_OW 235
// CenterOnUnits ( maleSold ) ;
10336: LD_VAR 0 3
10340: PPUSH
10341: CALL_OW 85
// DialogueOn ;
10345: CALL_OW 6
// Say ( maleSold , DHandOverCome-ASol1-1 ) ;
10349: LD_VAR 0 3
10353: PPUSH
10354: LD_STRING DHandOverCome-ASol1-1
10356: PPUSH
10357: CALL_OW 88
// Say ( Kurt , DHandOverCome-Kurt-1 ) ;
10361: LD_EXP 80
10365: PPUSH
10366: LD_STRING DHandOverCome-Kurt-1
10368: PPUSH
10369: CALL_OW 88
// DialogueOff ;
10373: CALL_OW 7
// KurtWaitingForBuildBarrack = false ;
10377: LD_ADDR_EXP 24
10381: PUSH
10382: LD_INT 0
10384: ST_TO_ADDR
// if GetDistUnits ( Kurt , UnitFilter ( GensherTeam , [ f_type , unit_vehicle ] ) [ 1 ] ) <= 8 or GetSide ( KurtEng ) = 3 then
10385: LD_EXP 80
10389: PPUSH
10390: LD_EXP 83
10394: PPUSH
10395: LD_INT 21
10397: PUSH
10398: LD_INT 2
10400: PUSH
10401: EMPTY
10402: LIST
10403: LIST
10404: PPUSH
10405: CALL_OW 72
10409: PUSH
10410: LD_INT 1
10412: ARRAY
10413: PPUSH
10414: CALL_OW 296
10418: PUSH
10419: LD_INT 8
10421: LESSEQUAL
10422: PUSH
10423: LD_EXP 82
10427: PPUSH
10428: CALL_OW 255
10432: PUSH
10433: LD_INT 3
10435: EQUAL
10436: OR
10437: IFFALSE 10542
// begin KurtCanEscape = false ;
10439: LD_ADDR_EXP 21
10443: PUSH
10444: LD_INT 0
10446: ST_TO_ADDR
// SetSide ( [ Kurt , KurtEng ] , 2 ) ;
10447: LD_EXP 80
10451: PUSH
10452: LD_EXP 82
10456: PUSH
10457: EMPTY
10458: LIST
10459: LIST
10460: PPUSH
10461: LD_INT 2
10463: PPUSH
10464: CALL_OW 235
// ComStop ( [ Kurt , KurtEng ] ) ;
10468: LD_EXP 80
10472: PUSH
10473: LD_EXP 82
10477: PUSH
10478: EMPTY
10479: LIST
10480: LIST
10481: PPUSH
10482: CALL_OW 141
// ComMoveXY ( [ Kurt , KurtEng ] , GetX ( maleSold ) , GetY ( maleSold ) ) ;
10486: LD_EXP 80
10490: PUSH
10491: LD_EXP 82
10495: PUSH
10496: EMPTY
10497: LIST
10498: LIST
10499: PPUSH
10500: LD_VAR 0 3
10504: PPUSH
10505: CALL_OW 250
10509: PPUSH
10510: LD_VAR 0 3
10514: PPUSH
10515: CALL_OW 251
10519: PPUSH
10520: CALL_OW 111
// waitForKurt = true ;
10524: LD_ADDR_VAR 0 4
10528: PUSH
10529: LD_INT 1
10531: ST_TO_ADDR
// KurtStatus = 3 ;
10532: LD_ADDR_EXP 22
10536: PUSH
10537: LD_INT 3
10539: ST_TO_ADDR
// end else
10540: GO 10780
// if GetDistUnits ( Kurt , UnitFilter ( GensherTeam , [ f_type , unit_vehicle ] ) [ 1 ] ) > 8 then
10542: LD_EXP 80
10546: PPUSH
10547: LD_EXP 83
10551: PPUSH
10552: LD_INT 21
10554: PUSH
10555: LD_INT 2
10557: PUSH
10558: EMPTY
10559: LIST
10560: LIST
10561: PPUSH
10562: CALL_OW 72
10566: PUSH
10567: LD_INT 1
10569: ARRAY
10570: PPUSH
10571: CALL_OW 296
10575: PUSH
10576: LD_INT 8
10578: GREATER
10579: IFFALSE 10780
// begin allowExitFromMap = 4 ;
10581: LD_ADDR_EXP 18
10585: PUSH
10586: LD_INT 4
10588: ST_TO_ADDR
// KurtStatus = 2 ;
10589: LD_ADDR_EXP 22
10593: PUSH
10594: LD_INT 2
10596: ST_TO_ADDR
// ComMoveToArea ( [ Kurt , KurtEng ] , KurtExitMapArea ) ;
10597: LD_EXP 80
10601: PUSH
10602: LD_EXP 82
10606: PUSH
10607: EMPTY
10608: LIST
10609: LIST
10610: PPUSH
10611: LD_INT 11
10613: PPUSH
10614: CALL_OW 113
// repeat ComAttackUnit ( UnitFilter ( GensherTeam , [ [ f_type , unit_human ] ] ) , Kurt ) ;
10618: LD_EXP 83
10622: PPUSH
10623: LD_INT 21
10625: PUSH
10626: LD_INT 1
10628: PUSH
10629: EMPTY
10630: LIST
10631: LIST
10632: PUSH
10633: EMPTY
10634: LIST
10635: PPUSH
10636: CALL_OW 72
10640: PPUSH
10641: LD_EXP 80
10645: PPUSH
10646: CALL_OW 115
// wait ( 0 0$1 ) ;
10650: LD_INT 35
10652: PPUSH
10653: CALL_OW 67
// until GetDistUnits ( NearestUnitToUnit ( UnitFilter ( GensherTeam , [ [ f_type , unit_human ] ] ) , Kurt ) , Kurt ) <= 9 or ( not IsPlaced ( Kurt ) and not IsPlaced ( KurtEng ) ) ;
10657: LD_EXP 83
10661: PPUSH
10662: LD_INT 21
10664: PUSH
10665: LD_INT 1
10667: PUSH
10668: EMPTY
10669: LIST
10670: LIST
10671: PUSH
10672: EMPTY
10673: LIST
10674: PPUSH
10675: CALL_OW 72
10679: PPUSH
10680: LD_EXP 80
10684: PPUSH
10685: CALL_OW 74
10689: PPUSH
10690: LD_EXP 80
10694: PPUSH
10695: CALL_OW 296
10699: PUSH
10700: LD_INT 9
10702: LESSEQUAL
10703: PUSH
10704: LD_EXP 80
10708: PPUSH
10709: CALL_OW 305
10713: NOT
10714: PUSH
10715: LD_EXP 82
10719: PPUSH
10720: CALL_OW 305
10724: NOT
10725: AND
10726: OR
10727: IFFALSE 10618
// ComMoveToArea ( [ Kurt , KurtEng ] , ExitMapArea ) ;
10729: LD_EXP 80
10733: PUSH
10734: LD_EXP 82
10738: PUSH
10739: EMPTY
10740: LIST
10741: LIST
10742: PPUSH
10743: LD_INT 8
10745: PPUSH
10746: CALL_OW 113
// ComMoveToArea ( UnitFilter ( GensherTeam , [ [ f_type , unit_human ] ] ) , ExitMapArea ) ;
10750: LD_EXP 83
10754: PPUSH
10755: LD_INT 21
10757: PUSH
10758: LD_INT 1
10760: PUSH
10761: EMPTY
10762: LIST
10763: LIST
10764: PUSH
10765: EMPTY
10766: LIST
10767: PPUSH
10768: CALL_OW 72
10772: PPUSH
10773: LD_INT 8
10775: PPUSH
10776: CALL_OW 113
// end ; if waitForKurt then
10780: LD_VAR 0 4
10784: IFFALSE 10910
// begin repeat wait ( 0 0$1 ) ;
10786: LD_INT 35
10788: PPUSH
10789: CALL_OW 67
// ComMoveXY ( [ Kurt , KurtEng ] , GetX ( maleSold ) , GetY ( maleSold ) ) ;
10793: LD_EXP 80
10797: PUSH
10798: LD_EXP 82
10802: PUSH
10803: EMPTY
10804: LIST
10805: LIST
10806: PPUSH
10807: LD_VAR 0 3
10811: PPUSH
10812: CALL_OW 250
10816: PPUSH
10817: LD_VAR 0 3
10821: PPUSH
10822: CALL_OW 251
10826: PPUSH
10827: CALL_OW 111
// until GetDistUnits ( Kurt , maleSold ) <= 2 ;
10831: LD_EXP 80
10835: PPUSH
10836: LD_VAR 0 3
10840: PPUSH
10841: CALL_OW 296
10845: PUSH
10846: LD_INT 2
10848: LESSEQUAL
10849: IFFALSE 10786
// allowExitFromMap = 4 ;
10851: LD_ADDR_EXP 18
10855: PUSH
10856: LD_INT 4
10858: ST_TO_ADDR
// ComMoveToArea ( [ Kurt , KurtEng ] , ExitMapArea ) ;
10859: LD_EXP 80
10863: PUSH
10864: LD_EXP 82
10868: PUSH
10869: EMPTY
10870: LIST
10871: LIST
10872: PPUSH
10873: LD_INT 8
10875: PPUSH
10876: CALL_OW 113
// ComMoveToArea ( UnitFilter ( GensherTeam , [ [ f_type , unit_human ] ] ) , ExitMapArea ) ;
10880: LD_EXP 83
10884: PPUSH
10885: LD_INT 21
10887: PUSH
10888: LD_INT 1
10890: PUSH
10891: EMPTY
10892: LIST
10893: LIST
10894: PUSH
10895: EMPTY
10896: LIST
10897: PPUSH
10898: CALL_OW 72
10902: PPUSH
10903: LD_INT 8
10905: PPUSH
10906: CALL_OW 113
// end ; exit ;
10910: GO 10913
// end ; enable ;
10912: ENABLE
// end ;
10913: PPOPN 4
10915: END
// export function Dial_AttackGensher ; var unit ; begin
10916: LD_INT 0
10918: PPUSH
10919: PPUSH
// DialogueOn ;
10920: CALL_OW 6
// SayRadio ( Dietrich , DHandOverSpoiled-Diet-1 ) ;
10924: LD_EXP 81
10928: PPUSH
10929: LD_STRING DHandOverSpoiled-Diet-1
10931: PPUSH
10932: CALL_OW 94
// DialogueOff ;
10936: CALL_OW 7
// SetAttitude ( 3 , 2 , att_enemy , true ) ;
10940: LD_INT 3
10942: PPUSH
10943: LD_INT 2
10945: PPUSH
10946: LD_INT 2
10948: PPUSH
10949: LD_INT 1
10951: PPUSH
10952: CALL_OW 80
// for unit in UnitFilter ( GensherTeam , [ [ f_type , unit_human ] ] ) do
10956: LD_ADDR_VAR 0 2
10960: PUSH
10961: LD_EXP 83
10965: PPUSH
10966: LD_INT 21
10968: PUSH
10969: LD_INT 1
10971: PUSH
10972: EMPTY
10973: LIST
10974: LIST
10975: PUSH
10976: EMPTY
10977: LIST
10978: PPUSH
10979: CALL_OW 72
10983: PUSH
10984: FOR_IN
10985: IFFALSE 11045
// begin if IsInUnit ( unit ) then
10987: LD_VAR 0 2
10991: PPUSH
10992: CALL_OW 310
10996: IFFALSE 11007
// ComExitVehicle ( unit ) ;
10998: LD_VAR 0 2
11002: PPUSH
11003: CALL_OW 121
// wait ( 0 0$01 ) ;
11007: LD_INT 35
11009: PPUSH
11010: CALL_OW 67
// AddComAgressiveMove ( unit , GetX ( Burlak ) , GetY ( Burlak ) ) ;
11014: LD_VAR 0 2
11018: PPUSH
11019: LD_EXP 57
11023: PPUSH
11024: CALL_OW 250
11028: PPUSH
11029: LD_EXP 57
11033: PPUSH
11034: CALL_OW 251
11038: PPUSH
11039: CALL_OW 174
// end ;
11043: GO 10984
11045: POP
11046: POP
// coopWithGensher = 2 ;
11047: LD_ADDR_EXP 2
11051: PUSH
11052: LD_INT 2
11054: ST_TO_ADDR
// end ;
11055: LD_VAR 0 1
11059: RET
// every 0 0$1 trigger canSendHeike and IsOK ( Heike ) and GetSide ( Heike ) = 5 do var legionSold ;
11060: LD_EXP 28
11064: PUSH
11065: LD_EXP 79
11069: PPUSH
11070: CALL_OW 302
11074: AND
11075: PUSH
11076: LD_EXP 79
11080: PPUSH
11081: CALL_OW 255
11085: PUSH
11086: LD_INT 5
11088: EQUAL
11089: AND
11090: IFFALSE 11410
11092: GO 11094
11094: DISABLE
11095: LD_INT 0
11097: PPUSH
// begin if IsSelected ( Heike ) then
11098: LD_EXP 79
11102: PPUSH
11103: CALL_OW 306
11107: IFFALSE 11402
// begin if Query ( QSendHeike ) = 1 then
11109: LD_STRING QSendHeike
11111: PPUSH
11112: CALL_OW 97
11116: PUSH
11117: LD_INT 1
11119: EQUAL
11120: IFFALSE 11402
// begin KurtWaitingForFreeHeike = false ;
11122: LD_ADDR_EXP 23
11126: PUSH
11127: LD_INT 0
11129: ST_TO_ADDR
// ComMoveXY ( Heike , 82 , 46 ) ;
11130: LD_EXP 79
11134: PPUSH
11135: LD_INT 82
11137: PPUSH
11138: LD_INT 46
11140: PPUSH
11141: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
11145: LD_INT 35
11147: PPUSH
11148: CALL_OW 67
// until GetDistUnitXY ( Heike , 82 , 46 ) <= 5 or IsDead ( Heike ) ;
11152: LD_EXP 79
11156: PPUSH
11157: LD_INT 82
11159: PPUSH
11160: LD_INT 46
11162: PPUSH
11163: CALL_OW 297
11167: PUSH
11168: LD_INT 5
11170: LESSEQUAL
11171: PUSH
11172: LD_EXP 79
11176: PPUSH
11177: CALL_OW 301
11181: OR
11182: IFFALSE 11145
// if not askCommanders then
11184: LD_EXP 20
11188: NOT
11189: IFFALSE 11235
// begin DialogueOn ;
11191: CALL_OW 6
// SayRadio ( Popov , DMercPopov-Pop-1 ) ;
11195: LD_EXP 76
11199: PPUSH
11200: LD_STRING DMercPopov-Pop-1
11202: PPUSH
11203: CALL_OW 94
// Say ( Burlak , DMercPopov-Bur-1 ) ;
11207: LD_EXP 57
11211: PPUSH
11212: LD_STRING DMercPopov-Bur-1
11214: PPUSH
11215: CALL_OW 88
// SayRadio ( Popov , DMercPopov-Pop-2 ) ;
11219: LD_EXP 76
11223: PPUSH
11224: LD_STRING DMercPopov-Pop-2
11226: PPUSH
11227: CALL_OW 94
// DialogueOff ;
11231: CALL_OW 7
// end ; uc_side = 8 ;
11235: LD_ADDR_OWVAR 20
11239: PUSH
11240: LD_INT 8
11242: ST_TO_ADDR
// uc_nation = 2 ;
11243: LD_ADDR_OWVAR 21
11247: PUSH
11248: LD_INT 2
11250: ST_TO_ADDR
// PrepareSoldier ( false , 6 ) ;
11251: LD_INT 0
11253: PPUSH
11254: LD_INT 6
11256: PPUSH
11257: CALL_OW 381
// legionSold = CreateHuman ;
11261: LD_ADDR_VAR 0 1
11265: PUSH
11266: CALL_OW 44
11270: ST_TO_ADDR
// PlaceUnitXYR ( legionSold , 26 , 48 , 4 , false ) ;
11271: LD_VAR 0 1
11275: PPUSH
11276: LD_INT 26
11278: PPUSH
11279: LD_INT 48
11281: PPUSH
11282: LD_INT 4
11284: PPUSH
11285: LD_INT 0
11287: PPUSH
11288: CALL_OW 50
// repeat wait ( 0 0$1 ) ;
11292: LD_INT 35
11294: PPUSH
11295: CALL_OW 67
// ComMoveXY ( legionSold , GetX ( Heike ) , GetY ( Heike ) ) ;
11299: LD_VAR 0 1
11303: PPUSH
11304: LD_EXP 79
11308: PPUSH
11309: CALL_OW 250
11313: PPUSH
11314: LD_EXP 79
11318: PPUSH
11319: CALL_OW 251
11323: PPUSH
11324: CALL_OW 111
// until GetDistUnits ( legionSold , Heike ) <= 5 or IsDead ( Heike ) ;
11328: LD_VAR 0 1
11332: PPUSH
11333: LD_EXP 79
11337: PPUSH
11338: CALL_OW 296
11342: PUSH
11343: LD_INT 5
11345: LESSEQUAL
11346: PUSH
11347: LD_EXP 79
11351: PPUSH
11352: CALL_OW 301
11356: OR
11357: IFFALSE 11292
// SetSide ( Heike , 8 ) ;
11359: LD_EXP 79
11363: PPUSH
11364: LD_INT 8
11366: PPUSH
11367: CALL_OW 235
// allowExitFromMap = 3 ;
11371: LD_ADDR_EXP 18
11375: PUSH
11376: LD_INT 3
11378: ST_TO_ADDR
// ComMoveToArea ( [ legionSold , Heike ] , KurtExitMapArea ) ;
11379: LD_VAR 0 1
11383: PUSH
11384: LD_EXP 79
11388: PUSH
11389: EMPTY
11390: LIST
11391: LIST
11392: PPUSH
11393: LD_INT 11
11395: PPUSH
11396: CALL_OW 113
// exit ;
11400: GO 11410
// end ; end ; wait ( 0 0$3 ) ;
11402: LD_INT 105
11404: PPUSH
11405: CALL_OW 67
// enable ;
11409: ENABLE
// end ;
11410: PPOPN 1
11412: END
// export function Dial_PlayerDontSendHeike ; begin
11413: LD_INT 0
11415: PPUSH
// DialogueOn ;
11416: CALL_OW 6
// SayRadio ( Kurt , DMercDeceived-Kurt-1 ) ;
11420: LD_EXP 80
11424: PPUSH
11425: LD_STRING DMercDeceived-Kurt-1
11427: PPUSH
11428: CALL_OW 94
// DialogueOff ;
11432: CALL_OW 7
// SetAttitude ( 3 , 8 , att_enemy , true ) ;
11436: LD_INT 3
11438: PPUSH
11439: LD_INT 8
11441: PPUSH
11442: LD_INT 2
11444: PPUSH
11445: LD_INT 1
11447: PPUSH
11448: CALL_OW 80
// KurtAttack = true ;
11452: LD_ADDR_EXP 25
11456: PUSH
11457: LD_INT 1
11459: ST_TO_ADDR
// end ;
11460: LD_VAR 0 1
11464: RET
// export function Dial_BetrayedKurt1 ; begin
11465: LD_INT 0
11467: PPUSH
// DialogueOn ;
11468: CALL_OW 6
// Say ( Kurt , DMercDeceived-Kurt-1 ) ;
11472: LD_EXP 80
11476: PPUSH
11477: LD_STRING DMercDeceived-Kurt-1
11479: PPUSH
11480: CALL_OW 88
// DialogueOff ;
11484: CALL_OW 7
// if IsPlaced ( Kurt ) then
11488: LD_EXP 80
11492: PPUSH
11493: CALL_OW 305
11497: IFFALSE 11546
// begin SetSide ( KurtEng , 8 ) ;
11499: LD_EXP 82
11503: PPUSH
11504: LD_INT 8
11506: PPUSH
11507: CALL_OW 235
// allowExitFromMap = 3 ;
11511: LD_ADDR_EXP 18
11515: PUSH
11516: LD_INT 3
11518: ST_TO_ADDR
// if KurtCanEscape then
11519: LD_EXP 21
11523: IFFALSE 11546
// ComMoveToArea ( [ Kurt , KurtEng ] , KurtExitMapArea ) ;
11525: LD_EXP 80
11529: PUSH
11530: LD_EXP 82
11534: PUSH
11535: EMPTY
11536: LIST
11537: LIST
11538: PPUSH
11539: LD_INT 11
11541: PPUSH
11542: CALL_OW 113
// end ; end ;
11546: LD_VAR 0 1
11550: RET
// export function Dial_BetrayedKurt2 ; begin
11551: LD_INT 0
11553: PPUSH
// DialogueOn ;
11554: CALL_OW 6
// Say ( Kurt , DMercAmbush-Kurt-1 ) ;
11558: LD_EXP 80
11562: PPUSH
11563: LD_STRING DMercAmbush-Kurt-1
11565: PPUSH
11566: CALL_OW 88
// DialogueOff ;
11570: CALL_OW 7
// if IsPlaced ( Kurt ) then
11574: LD_EXP 80
11578: PPUSH
11579: CALL_OW 305
11583: IFFALSE 11632
// begin SetSide ( KurtEng , 8 ) ;
11585: LD_EXP 82
11589: PPUSH
11590: LD_INT 8
11592: PPUSH
11593: CALL_OW 235
// allowExitFromMap = 3 ;
11597: LD_ADDR_EXP 18
11601: PUSH
11602: LD_INT 3
11604: ST_TO_ADDR
// if KurtCanEscape then
11605: LD_EXP 21
11609: IFFALSE 11632
// ComMoveToArea ( [ Kurt , KurtEng ] , KurtExitMapArea ) ;
11611: LD_EXP 80
11615: PUSH
11616: LD_EXP 82
11620: PUSH
11621: EMPTY
11622: LIST
11623: LIST
11624: PPUSH
11625: LD_INT 11
11627: PPUSH
11628: CALL_OW 113
// end ; end ;
11632: LD_VAR 0 1
11636: RET
// every 0 0$1 trigger GetSide ( KurtEng ) = 3 do var playerUnits , unit ;
11637: LD_EXP 82
11641: PPUSH
11642: CALL_OW 255
11646: PUSH
11647: LD_INT 3
11649: EQUAL
11650: IFFALSE 11797
11652: GO 11654
11654: DISABLE
11655: LD_INT 0
11657: PPUSH
11658: PPUSH
// begin playerUnits = FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
11659: LD_ADDR_VAR 0 1
11663: PUSH
11664: LD_INT 22
11666: PUSH
11667: LD_INT 3
11669: PUSH
11670: EMPTY
11671: LIST
11672: LIST
11673: PUSH
11674: LD_INT 2
11676: PUSH
11677: LD_INT 21
11679: PUSH
11680: LD_INT 1
11682: PUSH
11683: EMPTY
11684: LIST
11685: LIST
11686: PUSH
11687: LD_INT 21
11689: PUSH
11690: LD_INT 2
11692: PUSH
11693: EMPTY
11694: LIST
11695: LIST
11696: PUSH
11697: EMPTY
11698: LIST
11699: LIST
11700: LIST
11701: PUSH
11702: EMPTY
11703: LIST
11704: LIST
11705: PPUSH
11706: CALL_OW 69
11710: ST_TO_ADDR
// for unit in playerUnits do
11711: LD_ADDR_VAR 0 2
11715: PUSH
11716: LD_VAR 0 1
11720: PUSH
11721: FOR_IN
11722: IFFALSE 11751
// begin if WantsToAttack ( unit ) = KurtEng then
11724: LD_VAR 0 2
11728: PPUSH
11729: CALL_OW 319
11733: PUSH
11734: LD_EXP 82
11738: EQUAL
11739: IFFALSE 11749
// begin Dial_BetrayedKurt2 ;
11741: CALL 11551 0 0
// exit ;
11745: POP
11746: POP
11747: GO 11797
// end ; end ;
11749: GO 11721
11751: POP
11752: POP
// if ( IsDying ( KurtEng ) or IsDead ( KurtEng ) ) and GetSide ( KurtEng ) = 3 then
11753: LD_EXP 82
11757: PPUSH
11758: CALL_OW 303
11762: PUSH
11763: LD_EXP 82
11767: PPUSH
11768: CALL_OW 301
11772: OR
11773: PUSH
11774: LD_EXP 82
11778: PPUSH
11779: CALL_OW 255
11783: PUSH
11784: LD_INT 3
11786: EQUAL
11787: AND
11788: IFFALSE 11796
// begin Dial_BetrayedKurt2 ;
11790: CALL 11551 0 0
// exit ;
11794: GO 11797
// end ; enable ;
11796: ENABLE
// end ;
11797: PPOPN 2
11799: END
// every 0 0$1 trigger GetAttitude ( 3 , 8 ) = att_neutral and GetLives ( Kurt ) <= 999 do
11800: LD_INT 3
11802: PPUSH
11803: LD_INT 8
11805: PPUSH
11806: CALL_OW 81
11810: PUSH
11811: LD_INT 0
11813: EQUAL
11814: PUSH
11815: LD_EXP 80
11819: PPUSH
11820: CALL_OW 256
11824: PUSH
11825: LD_INT 999
11827: LESSEQUAL
11828: AND
11829: IFFALSE 11854
11831: GO 11833
11833: DISABLE
// begin Dial_BetrayedKurt1 ;
11834: CALL 11465 0 0
// SetAttitude ( 3 , 8 , att_enemy , true ) ;
11838: LD_INT 3
11840: PPUSH
11841: LD_INT 8
11843: PPUSH
11844: LD_INT 2
11846: PPUSH
11847: LD_INT 1
11849: PPUSH
11850: CALL_OW 80
// end ;
11854: END
// every 0 0$1 trigger buildingsToBuild <= 11 do
11855: LD_EXP 8
11859: PUSH
11860: LD_INT 11
11862: LESSEQUAL
11863: IFFALSE 12112
11865: GO 11867
11867: DISABLE
// begin if not IsOK ( Kuzmov ) and not IsOK ( Oblukov ) then
11868: LD_EXP 72
11872: PPUSH
11873: CALL_OW 302
11877: NOT
11878: PUSH
11879: LD_EXP 74
11883: PPUSH
11884: CALL_OW 302
11888: NOT
11889: AND
11890: IFFALSE 11894
// exit ;
11892: GO 12112
// DialogueOn ;
11894: CALL_OW 6
// if IsOK ( Kuzmov ) then
11898: LD_EXP 72
11902: PPUSH
11903: CALL_OW 302
11907: IFFALSE 11923
// Say ( Kuzmov , DFiringRange-Kuz-1 ) else
11909: LD_EXP 72
11913: PPUSH
11914: LD_STRING DFiringRange-Kuz-1
11916: PPUSH
11917: CALL_OW 88
11921: GO 11935
// Say ( Oblukov , DFiringRange-Obl-1 ) ;
11923: LD_EXP 74
11927: PPUSH
11928: LD_STRING DFiringRange-Obl-1
11930: PPUSH
11931: CALL_OW 88
// Say ( Burlak , DFiringRange-Bur-1 ) ;
11935: LD_EXP 57
11939: PPUSH
11940: LD_STRING DFiringRange-Bur-1
11942: PPUSH
11943: CALL_OW 88
// CenterOnXY ( 99 , 30 ) ;
11947: LD_INT 99
11949: PPUSH
11950: LD_INT 30
11952: PPUSH
11953: CALL_OW 84
// Wait ( 0 0$0.5 ) ;
11957: LD_INT 18
11959: PPUSH
11960: CALL_OW 67
// RevealFogArea ( 3 , ShootArea ) ;
11964: LD_INT 3
11966: PPUSH
11967: LD_INT 12
11969: PPUSH
11970: CALL_OW 332
// SetAreaMapShow ( ShootArea , 1 ) ;
11974: LD_INT 12
11976: PPUSH
11977: LD_INT 1
11979: PPUSH
11980: CALL_OW 424
// if IsOK ( Kuzmov ) then
11984: LD_EXP 72
11988: PPUSH
11989: CALL_OW 302
11993: IFFALSE 12009
// Say ( Kuzmov , DFiringRange-Kuz-2 ) else
11995: LD_EXP 72
11999: PPUSH
12000: LD_STRING DFiringRange-Kuz-2
12002: PPUSH
12003: CALL_OW 88
12007: GO 12021
// Say ( Oblukov , DFiringRange-Obl-2 ) ;
12009: LD_EXP 74
12013: PPUSH
12014: LD_STRING DFiringRange-Obl-2
12016: PPUSH
12017: CALL_OW 88
// case Query ( QShootingGallery ) of 1 :
12021: LD_STRING QShootingGallery
12023: PPUSH
12024: CALL_OW 97
12028: PUSH
12029: LD_INT 1
12031: DOUBLE
12032: EQUAL
12033: IFTRUE 12037
12035: GO 12074
12037: POP
// begin Say ( Burlak , DQrShootingGallery#1-Bur-1 ) ;
12038: LD_EXP 57
12042: PPUSH
12043: LD_STRING DQrShootingGallery#1-Bur-1
12045: PPUSH
12046: CALL_OW 88
// BurlakRespect = BurlakRespect + 1 ;
12050: LD_ADDR_EXP 30
12054: PUSH
12055: LD_EXP 30
12059: PUSH
12060: LD_INT 1
12062: PLUS
12063: ST_TO_ADDR
// canShootTrening = true ;
12064: LD_ADDR_EXP 29
12068: PUSH
12069: LD_INT 1
12071: ST_TO_ADDR
// end ; 2 :
12072: GO 12108
12074: LD_INT 2
12076: DOUBLE
12077: EQUAL
12078: IFTRUE 12082
12080: GO 12107
12082: POP
// begin Say ( Burlak , DQrShootingGallery#2-Bur-1 ) ;
12083: LD_EXP 57
12087: PPUSH
12088: LD_STRING DQrShootingGallery#2-Bur-1
12090: PPUSH
12091: CALL_OW 88
// SetAreaMapShow ( ShootArea , 0 ) ;
12095: LD_INT 12
12097: PPUSH
12098: LD_INT 0
12100: PPUSH
12101: CALL_OW 424
// end ; end ;
12105: GO 12108
12107: POP
// DialogueOff ;
12108: CALL_OW 7
// end ;
12112: END
// every 0 0$1 trigger canShootTrening do
12113: LD_EXP 29
12117: IFFALSE 12127
12119: GO 12121
12121: DISABLE
// begin enable ;
12122: ENABLE
// ShootTreningController ;
12123: CALL 7091 0 0
// end ;
12127: END
// every 0 0$1 trigger buildingsToBuild <= 7 do var hunters , hunter ;
12128: LD_EXP 8
12132: PUSH
12133: LD_INT 7
12135: LESSEQUAL
12136: IFFALSE 12526
12138: GO 12140
12140: DISABLE
12141: LD_INT 0
12143: PPUSH
12144: PPUSH
// begin hunters = [ ] ;
12145: LD_ADDR_VAR 0 1
12149: PUSH
12150: EMPTY
12151: ST_TO_ADDR
// if IsOK ( Belkov ) then
12152: LD_EXP 66
12156: PPUSH
12157: CALL_OW 302
12161: IFFALSE 12179
// hunters = hunters ^ Belkov ;
12163: LD_ADDR_VAR 0 1
12167: PUSH
12168: LD_VAR 0 1
12172: PUSH
12173: LD_EXP 66
12177: ADD
12178: ST_TO_ADDR
// if IsOK ( Karamazov ) then
12179: LD_EXP 58
12183: PPUSH
12184: CALL_OW 302
12188: IFFALSE 12206
// hunters = hunters ^ Karamazov ;
12190: LD_ADDR_VAR 0 1
12194: PUSH
12195: LD_VAR 0 1
12199: PUSH
12200: LD_EXP 58
12204: ADD
12205: ST_TO_ADDR
// if IsOK ( Kozlov ) then
12206: LD_EXP 73
12210: PPUSH
12211: CALL_OW 302
12215: IFFALSE 12233
// hunters = hunters ^ Kozlov ;
12217: LD_ADDR_VAR 0 1
12221: PUSH
12222: LD_VAR 0 1
12226: PUSH
12227: LD_EXP 73
12231: ADD
12232: ST_TO_ADDR
// if not hunters then
12233: LD_VAR 0 1
12237: NOT
12238: IFFALSE 12242
// exit ;
12240: GO 12526
// hunter = hunters [ Rand ( 1 , hunters ) ] ;
12242: LD_ADDR_VAR 0 2
12246: PUSH
12247: LD_VAR 0 1
12251: PUSH
12252: LD_INT 1
12254: PPUSH
12255: LD_VAR 0 1
12259: PPUSH
12260: CALL_OW 12
12264: ARRAY
12265: ST_TO_ADDR
// DialogueOn ;
12266: CALL_OW 6
// case hunter of Belkov :
12270: LD_VAR 0 2
12274: PUSH
12275: LD_EXP 66
12279: DOUBLE
12280: EQUAL
12281: IFTRUE 12285
12283: GO 12300
12285: POP
// Say ( Belkov , DHunting-Bel-1 ) ; Karamazov :
12286: LD_EXP 66
12290: PPUSH
12291: LD_STRING DHunting-Bel-1
12293: PPUSH
12294: CALL_OW 88
12298: GO 12351
12300: LD_EXP 58
12304: DOUBLE
12305: EQUAL
12306: IFTRUE 12310
12308: GO 12325
12310: POP
// Say ( Karamazov , DHunting-Kar-1 ) ; Kozlov :
12311: LD_EXP 58
12315: PPUSH
12316: LD_STRING DHunting-Kar-1
12318: PPUSH
12319: CALL_OW 88
12323: GO 12351
12325: LD_EXP 73
12329: DOUBLE
12330: EQUAL
12331: IFTRUE 12335
12333: GO 12350
12335: POP
// Say ( Kozlov , DHunting-Koz-1 ) ; end ;
12336: LD_EXP 73
12340: PPUSH
12341: LD_STRING DHunting-Koz-1
12343: PPUSH
12344: CALL_OW 88
12348: GO 12351
12350: POP
// Say ( Burlak , DHunting-Bur-1 ) ;
12351: LD_EXP 57
12355: PPUSH
12356: LD_STRING DHunting-Bur-1
12358: PPUSH
12359: CALL_OW 88
// case hunter of Belkov :
12363: LD_VAR 0 2
12367: PUSH
12368: LD_EXP 66
12372: DOUBLE
12373: EQUAL
12374: IFTRUE 12378
12376: GO 12393
12378: POP
// Say ( Belkov , DHunting-Bel-2 ) ; Karamazov :
12379: LD_EXP 66
12383: PPUSH
12384: LD_STRING DHunting-Bel-2
12386: PPUSH
12387: CALL_OW 88
12391: GO 12444
12393: LD_EXP 58
12397: DOUBLE
12398: EQUAL
12399: IFTRUE 12403
12401: GO 12418
12403: POP
// Say ( Karamazov , DHunting-Kar-2 ) ; Kozlov :
12404: LD_EXP 58
12408: PPUSH
12409: LD_STRING DHunting-Kar-2
12411: PPUSH
12412: CALL_OW 88
12416: GO 12444
12418: LD_EXP 73
12422: DOUBLE
12423: EQUAL
12424: IFTRUE 12428
12426: GO 12443
12428: POP
// Say ( Kozlov , DHunting-Koz-2 ) ; end ;
12429: LD_EXP 73
12433: PPUSH
12434: LD_STRING DHunting-Koz-2
12436: PPUSH
12437: CALL_OW 88
12441: GO 12444
12443: POP
// DialogueOff ;
12444: CALL_OW 7
// case Query ( QHunting ) of 1 :
12448: LD_STRING QHunting
12450: PPUSH
12451: CALL_OW 97
12455: PUSH
12456: LD_INT 1
12458: DOUBLE
12459: EQUAL
12460: IFTRUE 12464
12462: GO 12502
12464: POP
// begin Say ( Burlak , DQrHunting#1-Bur-1 ) ;
12465: LD_EXP 57
12469: PPUSH
12470: LD_STRING DQrHunting#1-Bur-1
12472: PPUSH
12473: CALL_OW 88
// BurlakRespect = BurlakRespect + 1 ;
12477: LD_ADDR_EXP 30
12481: PUSH
12482: LD_EXP 30
12486: PUSH
12487: LD_INT 1
12489: PLUS
12490: ST_TO_ADDR
// GoToHunt ( hunter ) ;
12491: LD_VAR 0 2
12495: PPUSH
12496: CALL 7719 0 1
// end ; 2 :
12500: GO 12526
12502: LD_INT 2
12504: DOUBLE
12505: EQUAL
12506: IFTRUE 12510
12508: GO 12525
12510: POP
// Say ( Burlak , DQrHunting#2-Bur-1 ) ; end ;
12511: LD_EXP 57
12515: PPUSH
12516: LD_STRING DQrHunting#2-Bur-1
12518: PPUSH
12519: CALL_OW 88
12523: GO 12526
12525: POP
// end ;
12526: PPOPN 2
12528: END
// every 0 0$1 trigger buildingsToBuild <= 3 do var unit , womans , men , woman , man , depots ;
12529: LD_EXP 8
12533: PUSH
12534: LD_INT 3
12536: LESSEQUAL
12537: IFFALSE 13524
12539: GO 12541
12541: DISABLE
12542: LD_INT 0
12544: PPUSH
12545: PPUSH
12546: PPUSH
12547: PPUSH
12548: PPUSH
12549: PPUSH
// begin womans = [ ] ;
12550: LD_ADDR_VAR 0 2
12554: PUSH
12555: EMPTY
12556: ST_TO_ADDR
// men = [ ] ;
12557: LD_ADDR_VAR 0 3
12561: PUSH
12562: EMPTY
12563: ST_TO_ADDR
// if IsOK ( Petrovova ) then
12564: LD_EXP 59
12568: PPUSH
12569: CALL_OW 302
12573: IFFALSE 12591
// womans = womans ^ Petrovova ;
12575: LD_ADDR_VAR 0 2
12579: PUSH
12580: LD_VAR 0 2
12584: PUSH
12585: LD_EXP 59
12589: ADD
12590: ST_TO_ADDR
// if IsOK ( Kirilenkova ) then
12591: LD_EXP 65
12595: PPUSH
12596: CALL_OW 302
12600: IFFALSE 12618
// womans = womans ^ Kirilenkova ;
12602: LD_ADDR_VAR 0 2
12606: PUSH
12607: LD_VAR 0 2
12611: PUSH
12612: LD_EXP 65
12616: ADD
12617: ST_TO_ADDR
// if IsOK ( Kapitsova ) then
12618: LD_EXP 75
12622: PPUSH
12623: CALL_OW 302
12627: IFFALSE 12645
// womans = womans ^ Kapitsova ;
12629: LD_ADDR_VAR 0 2
12633: PUSH
12634: LD_VAR 0 2
12638: PUSH
12639: LD_EXP 75
12643: ADD
12644: ST_TO_ADDR
// DialogueOn ;
12645: CALL_OW 6
// if womans then
12649: LD_VAR 0 2
12653: IFFALSE 12780
// begin case womans [ Rand ( 1 , womans ) ] of Petrovova :
12655: LD_VAR 0 2
12659: PUSH
12660: LD_INT 1
12662: PPUSH
12663: LD_VAR 0 2
12667: PPUSH
12668: CALL_OW 12
12672: ARRAY
12673: PUSH
12674: LD_EXP 59
12678: DOUBLE
12679: EQUAL
12680: IFTRUE 12684
12682: GO 12709
12684: POP
// begin Say ( Petrovova , DFreeTime-Ptr-1 ) ;
12685: LD_EXP 59
12689: PPUSH
12690: LD_STRING DFreeTime-Ptr-1
12692: PPUSH
12693: CALL_OW 88
// woman = Petrovova ;
12697: LD_ADDR_VAR 0 4
12701: PUSH
12702: LD_EXP 59
12706: ST_TO_ADDR
// end ; Kirilenkova :
12707: GO 12780
12709: LD_EXP 65
12713: DOUBLE
12714: EQUAL
12715: IFTRUE 12719
12717: GO 12744
12719: POP
// begin Say ( Kirilenkova , DFreeTime-Kir-1 ) ;
12720: LD_EXP 65
12724: PPUSH
12725: LD_STRING DFreeTime-Kir-1
12727: PPUSH
12728: CALL_OW 88
// woman = Kirilenkova ;
12732: LD_ADDR_VAR 0 4
12736: PUSH
12737: LD_EXP 65
12741: ST_TO_ADDR
// end ; Kapitsova :
12742: GO 12780
12744: LD_EXP 75
12748: DOUBLE
12749: EQUAL
12750: IFTRUE 12754
12752: GO 12779
12754: POP
// begin Say ( Kapitsova , DFreeTime-Kap-1 ) ;
12755: LD_EXP 75
12759: PPUSH
12760: LD_STRING DFreeTime-Kap-1
12762: PPUSH
12763: CALL_OW 88
// woman = Kapitsova ;
12767: LD_ADDR_VAR 0 4
12771: PUSH
12772: LD_EXP 75
12776: ST_TO_ADDR
// end ; end ;
12777: GO 12780
12779: POP
// end ; if IsOK ( Kuzmov ) then
12780: LD_EXP 72
12784: PPUSH
12785: CALL_OW 302
12789: IFFALSE 12807
// men = men ^ Kuzmov ;
12791: LD_ADDR_VAR 0 3
12795: PUSH
12796: LD_VAR 0 3
12800: PUSH
12801: LD_EXP 72
12805: ADD
12806: ST_TO_ADDR
// if IsOK ( Titov ) then
12807: LD_EXP 62
12811: PPUSH
12812: CALL_OW 302
12816: IFFALSE 12834
// men = men ^ Titov ;
12818: LD_ADDR_VAR 0 3
12822: PUSH
12823: LD_VAR 0 3
12827: PUSH
12828: LD_EXP 62
12832: ADD
12833: ST_TO_ADDR
// if IsOK ( Gnyevko ) then
12834: LD_EXP 69
12838: PPUSH
12839: CALL_OW 302
12843: IFFALSE 12861
// men = men ^ Gnyevko ;
12845: LD_ADDR_VAR 0 3
12849: PUSH
12850: LD_VAR 0 3
12854: PUSH
12855: LD_EXP 69
12859: ADD
12860: ST_TO_ADDR
// if IsOK ( Oblukov ) then
12861: LD_EXP 74
12865: PPUSH
12866: CALL_OW 302
12870: IFFALSE 12888
// men = men ^ Oblukov ;
12872: LD_ADDR_VAR 0 3
12876: PUSH
12877: LD_VAR 0 3
12881: PUSH
12882: LD_EXP 74
12886: ADD
12887: ST_TO_ADDR
// if men then
12888: LD_VAR 0 3
12892: IFFALSE 13054
// begin case men [ Rand ( 1 , men ) ] of Kuzmov :
12894: LD_VAR 0 3
12898: PUSH
12899: LD_INT 1
12901: PPUSH
12902: LD_VAR 0 3
12906: PPUSH
12907: CALL_OW 12
12911: ARRAY
12912: PUSH
12913: LD_EXP 72
12917: DOUBLE
12918: EQUAL
12919: IFTRUE 12923
12921: GO 12948
12923: POP
// begin Say ( Kuzmov , DFreeTime-Kuz-1 ) ;
12924: LD_EXP 72
12928: PPUSH
12929: LD_STRING DFreeTime-Kuz-1
12931: PPUSH
12932: CALL_OW 88
// man = Kuzmov ;
12936: LD_ADDR_VAR 0 5
12940: PUSH
12941: LD_EXP 72
12945: ST_TO_ADDR
// end ; Titov :
12946: GO 13054
12948: LD_EXP 62
12952: DOUBLE
12953: EQUAL
12954: IFTRUE 12958
12956: GO 12983
12958: POP
// begin Say ( Titov , DFreeTime-Tit-1 ) ;
12959: LD_EXP 62
12963: PPUSH
12964: LD_STRING DFreeTime-Tit-1
12966: PPUSH
12967: CALL_OW 88
// man = Titov ;
12971: LD_ADDR_VAR 0 5
12975: PUSH
12976: LD_EXP 62
12980: ST_TO_ADDR
// end ; Gnyevko :
12981: GO 13054
12983: LD_EXP 69
12987: DOUBLE
12988: EQUAL
12989: IFTRUE 12993
12991: GO 13018
12993: POP
// begin Say ( Gnyevko , DFreeTime-Gny-1 ) ;
12994: LD_EXP 69
12998: PPUSH
12999: LD_STRING DFreeTime-Gny-1
13001: PPUSH
13002: CALL_OW 88
// man = Gnyevko ;
13006: LD_ADDR_VAR 0 5
13010: PUSH
13011: LD_EXP 69
13015: ST_TO_ADDR
// end ; Oblukov :
13016: GO 13054
13018: LD_EXP 74
13022: DOUBLE
13023: EQUAL
13024: IFTRUE 13028
13026: GO 13053
13028: POP
// begin Say ( Oblukov , DFreeTime-Obl-1 ) ;
13029: LD_EXP 74
13033: PPUSH
13034: LD_STRING DFreeTime-Obl-1
13036: PPUSH
13037: CALL_OW 88
// man = Oblukov ;
13041: LD_ADDR_VAR 0 5
13045: PUSH
13046: LD_EXP 74
13050: ST_TO_ADDR
// end ; end ;
13051: GO 13054
13053: POP
// end ; DialogueOff ;
13054: CALL_OW 7
// if not woman and not man then
13058: LD_VAR 0 4
13062: NOT
13063: PUSH
13064: LD_VAR 0 5
13068: NOT
13069: AND
13070: IFFALSE 13078
// begin DialogueOff ;
13072: CALL_OW 7
// exit ;
13076: GO 13524
// end ; case Query ( QFreeTime ) of 1 :
13078: LD_STRING QFreeTime
13080: PPUSH
13081: CALL_OW 97
13085: PUSH
13086: LD_INT 1
13088: DOUBLE
13089: EQUAL
13090: IFTRUE 13094
13092: GO 13496
13094: POP
// begin Say ( Burlak , DQrFreeTime#1-Bur-1 ) ;
13095: LD_EXP 57
13099: PPUSH
13100: LD_STRING DQrFreeTime#1-Bur-1
13102: PPUSH
13103: CALL_OW 88
// DialogueOff ;
13107: CALL_OW 7
// BurlakRespect = BurlakRespect + 1 ;
13111: LD_ADDR_EXP 30
13115: PUSH
13116: LD_EXP 30
13120: PUSH
13121: LD_INT 1
13123: PLUS
13124: ST_TO_ADDR
// SetSide ( [ woman , man ] , 6 ) ;
13125: LD_VAR 0 4
13129: PUSH
13130: LD_VAR 0 5
13134: PUSH
13135: EMPTY
13136: LIST
13137: LIST
13138: PPUSH
13139: LD_INT 6
13141: PPUSH
13142: CALL_OW 235
// for unit in [ woman , man ] do
13146: LD_ADDR_VAR 0 1
13150: PUSH
13151: LD_VAR 0 4
13155: PUSH
13156: LD_VAR 0 5
13160: PUSH
13161: EMPTY
13162: LIST
13163: LIST
13164: PUSH
13165: FOR_IN
13166: IFFALSE 13221
// if IsInUnit ( unit ) then
13168: LD_VAR 0 1
13172: PPUSH
13173: CALL_OW 310
13177: IFFALSE 13219
// begin if GetType ( IsInUnit ( unit ) ) = unit_vehicle then
13179: LD_VAR 0 1
13183: PPUSH
13184: CALL_OW 310
13188: PPUSH
13189: CALL_OW 247
13193: PUSH
13194: LD_INT 2
13196: EQUAL
13197: IFFALSE 13210
// ComExitVehicle ( unit ) else
13199: LD_VAR 0 1
13203: PPUSH
13204: CALL_OW 121
13208: GO 13219
// ComExitBuilding ( unit ) ;
13210: LD_VAR 0 1
13214: PPUSH
13215: CALL_OW 122
// end ;
13219: GO 13165
13221: POP
13222: POP
// wait ( 0 0$1 ) ;
13223: LD_INT 35
13225: PPUSH
13226: CALL_OW 67
// ComMoveToArea ( [ woman , man ] , ExitMapArea ) ;
13230: LD_VAR 0 4
13234: PUSH
13235: LD_VAR 0 5
13239: PUSH
13240: EMPTY
13241: LIST
13242: LIST
13243: PPUSH
13244: LD_INT 8
13246: PPUSH
13247: CALL_OW 113
// allowExitFromMap = 1 ;
13251: LD_ADDR_EXP 18
13255: PUSH
13256: LD_INT 1
13258: ST_TO_ADDR
// wait ( 3 3$0 ) ;
13259: LD_INT 6300
13261: PPUSH
13262: CALL_OW 67
// PlaceUnitXYR ( woman , 157 , 29 , 3 , false ) ;
13266: LD_VAR 0 4
13270: PPUSH
13271: LD_INT 157
13273: PPUSH
13274: LD_INT 29
13276: PPUSH
13277: LD_INT 3
13279: PPUSH
13280: LD_INT 0
13282: PPUSH
13283: CALL_OW 50
// PlaceUnitXYR ( man , 157 , 29 , 3 , false ) ;
13287: LD_VAR 0 5
13291: PPUSH
13292: LD_INT 157
13294: PPUSH
13295: LD_INT 29
13297: PPUSH
13298: LD_INT 3
13300: PPUSH
13301: LD_INT 0
13303: PPUSH
13304: CALL_OW 50
// SetSide ( [ woman , man ] , 3 ) ;
13308: LD_VAR 0 4
13312: PUSH
13313: LD_VAR 0 5
13317: PUSH
13318: EMPTY
13319: LIST
13320: LIST
13321: PPUSH
13322: LD_INT 3
13324: PPUSH
13325: CALL_OW 235
// depots = FilterAllUnits ( [ [ f_side , 3 ] , [ [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ] ) ;
13329: LD_ADDR_VAR 0 6
13333: PUSH
13334: LD_INT 22
13336: PUSH
13337: LD_INT 3
13339: PUSH
13340: EMPTY
13341: LIST
13342: LIST
13343: PUSH
13344: LD_INT 2
13346: PUSH
13347: LD_INT 30
13349: PUSH
13350: LD_INT 0
13352: PUSH
13353: EMPTY
13354: LIST
13355: LIST
13356: PUSH
13357: LD_INT 30
13359: PUSH
13360: LD_INT 1
13362: PUSH
13363: EMPTY
13364: LIST
13365: LIST
13366: PUSH
13367: EMPTY
13368: LIST
13369: LIST
13370: LIST
13371: PUSH
13372: EMPTY
13373: LIST
13374: PUSH
13375: EMPTY
13376: LIST
13377: LIST
13378: PPUSH
13379: CALL_OW 69
13383: ST_TO_ADDR
// if depots then
13384: LD_VAR 0 6
13388: IFFALSE 13438
// ComMoveXY ( [ woman , man ] , GetX ( depots [ 1 ] ) , GetY ( depots [ 1 ] ) ) else
13390: LD_VAR 0 4
13394: PUSH
13395: LD_VAR 0 5
13399: PUSH
13400: EMPTY
13401: LIST
13402: LIST
13403: PPUSH
13404: LD_VAR 0 6
13408: PUSH
13409: LD_INT 1
13411: ARRAY
13412: PPUSH
13413: CALL_OW 250
13417: PPUSH
13418: LD_VAR 0 6
13422: PUSH
13423: LD_INT 1
13425: ARRAY
13426: PPUSH
13427: CALL_OW 251
13431: PPUSH
13432: CALL_OW 111
13436: GO 13476
// ComMoveXY ( [ woman , man ] , GetX ( Burlak ) , GetY ( Burlak ) ) ;
13438: LD_VAR 0 4
13442: PUSH
13443: LD_VAR 0 5
13447: PUSH
13448: EMPTY
13449: LIST
13450: LIST
13451: PPUSH
13452: LD_EXP 57
13456: PPUSH
13457: CALL_OW 250
13461: PPUSH
13462: LD_EXP 57
13466: PPUSH
13467: CALL_OW 251
13471: PPUSH
13472: CALL_OW 111
// CenterOnUnits ( [ woman , man ] ) ;
13476: LD_VAR 0 4
13480: PUSH
13481: LD_VAR 0 5
13485: PUSH
13486: EMPTY
13487: LIST
13488: LIST
13489: PPUSH
13490: CALL_OW 85
// end ; 2 :
13494: GO 13520
13496: LD_INT 2
13498: DOUBLE
13499: EQUAL
13500: IFTRUE 13504
13502: GO 13519
13504: POP
// Say ( Burlak , DQrFreeTime#2-Bur-1 ) ; end ;
13505: LD_EXP 57
13509: PPUSH
13510: LD_STRING DQrFreeTime#2-Bur-1
13512: PPUSH
13513: CALL_OW 88
13517: GO 13520
13519: POP
// DialogueOff ;
13520: CALL_OW 7
// end ;
13524: PPOPN 6
13526: END
// every 0 0$1 trigger GetAmountWeaponsDataBuildOnVehicle ( false ) <= 2 do
13527: LD_INT 0
13529: PPUSH
13530: CALL 6800 0 1
13534: PUSH
13535: LD_INT 2
13537: LESSEQUAL
13538: IFFALSE 13673
13540: GO 13542
13542: DISABLE
// begin DialogueOn ;
13543: CALL_OW 6
// if IsOK ( Kozlov ) then
13547: LD_EXP 73
13551: PPUSH
13552: CALL_OW 302
13556: IFFALSE 13572
// Say ( Kozlov , DMasha-Koz-1 ) else
13558: LD_EXP 73
13562: PPUSH
13563: LD_STRING DMasha-Koz-1
13565: PPUSH
13566: CALL_OW 88
13570: GO 13635
// DialogRandom ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_ok ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) , DMasha-Koz-1 ,  , false , false ) ;
13572: LD_INT 22
13574: PUSH
13575: LD_INT 3
13577: PUSH
13578: EMPTY
13579: LIST
13580: LIST
13581: PUSH
13582: LD_INT 50
13584: PUSH
13585: EMPTY
13586: LIST
13587: PUSH
13588: LD_INT 21
13590: PUSH
13591: LD_INT 1
13593: PUSH
13594: EMPTY
13595: LIST
13596: LIST
13597: PUSH
13598: LD_INT 26
13600: PUSH
13601: LD_INT 1
13603: PUSH
13604: EMPTY
13605: LIST
13606: LIST
13607: PUSH
13608: EMPTY
13609: LIST
13610: LIST
13611: LIST
13612: LIST
13613: PPUSH
13614: CALL_OW 69
13618: PPUSH
13619: LD_STRING DMasha-Koz-1
13621: PPUSH
13622: LD_STRING 
13624: PPUSH
13625: LD_INT 0
13627: PPUSH
13628: LD_INT 0
13630: PPUSH
13631: CALL 6249 0 5
// Say ( Burlak , DMasha2-Bur-1 ) ;
13635: LD_EXP 57
13639: PPUSH
13640: LD_STRING DMasha2-Bur-1
13642: PPUSH
13643: CALL_OW 88
// DialogueOff ;
13647: CALL_OW 7
// Query ( QMasha ) ;
13651: LD_STRING QMasha
13653: PPUSH
13654: CALL_OW 97
// ChangeMissionObjectives ( MMasha ) ;
13658: LD_STRING MMasha
13660: PPUSH
13661: CALL_OW 337
// canChooseMashaVehicle = true ;
13665: LD_ADDR_EXP 36
13669: PUSH
13670: LD_INT 1
13672: ST_TO_ADDR
// end ;
13673: END
// export function Dial_ComputerTechResearched ; begin
13674: LD_INT 0
13676: PPUSH
// if IsOk ( Scholtze ) or IsOK ( Kapitsova ) then
13677: LD_EXP 71
13681: PPUSH
13682: CALL_OW 302
13686: PUSH
13687: LD_EXP 75
13691: PPUSH
13692: CALL_OW 302
13696: OR
13697: IFFALSE 13793
// begin DialogueOn ;
13699: CALL_OW 6
// if IsOK ( Scholtze ) then
13703: LD_EXP 71
13707: PPUSH
13708: CALL_OW 302
13712: IFFALSE 13728
// Say ( Scholtze , DAI-Sch-1 ) else
13714: LD_EXP 71
13718: PPUSH
13719: LD_STRING DAI-Sch-1
13721: PPUSH
13722: CALL_OW 88
13726: GO 13740
// Say ( Kapitsova , DAI-Kap-1 ) ;
13728: LD_EXP 75
13732: PPUSH
13733: LD_STRING DAI-Kap-1
13735: PPUSH
13736: CALL_OW 88
// Say ( Burlak , DAI-Bur-1 ) ;
13740: LD_EXP 57
13744: PPUSH
13745: LD_STRING DAI-Bur-1
13747: PPUSH
13748: CALL_OW 88
// if IsOK ( Scholtze ) then
13752: LD_EXP 71
13756: PPUSH
13757: CALL_OW 302
13761: IFFALSE 13777
// Say ( Scholtze , DAI-Sch-2 ) else
13763: LD_EXP 71
13767: PPUSH
13768: LD_STRING DAI-Sch-2
13770: PPUSH
13771: CALL_OW 88
13775: GO 13789
// Say ( Kapitsova , DAI-Kap-2 ) ;
13777: LD_EXP 75
13781: PPUSH
13782: LD_STRING DAI-Kap-2
13784: PPUSH
13785: CALL_OW 88
// DialogueOff ;
13789: CALL_OW 7
// end ; ChangeMissionObjectives ( MAI ) ;
13793: LD_STRING MAI
13795: PPUSH
13796: CALL_OW 337
// end ;
13800: LD_VAR 0 1
13804: RET
// export function Dial_TeleportTechResearched ; begin
13805: LD_INT 0
13807: PPUSH
// if IsOk ( Scholtze ) or IsOK ( Kapitsova ) then
13808: LD_EXP 71
13812: PPUSH
13813: CALL_OW 302
13817: PUSH
13818: LD_EXP 75
13822: PPUSH
13823: CALL_OW 302
13827: OR
13828: IFFALSE 13936
// begin DialogueOn ;
13830: CALL_OW 6
// if IsOK ( Scholtze ) then
13834: LD_EXP 71
13838: PPUSH
13839: CALL_OW 302
13843: IFFALSE 13859
// Say ( Scholtze , DSpontTelep-Sch-1 ) else
13845: LD_EXP 71
13849: PPUSH
13850: LD_STRING DSpontTelep-Sch-1
13852: PPUSH
13853: CALL_OW 88
13857: GO 13871
// Say ( Kapitsova , DSpontTelep-Kap-1 ) ;
13859: LD_EXP 75
13863: PPUSH
13864: LD_STRING DSpontTelep-Kap-1
13866: PPUSH
13867: CALL_OW 88
// Say ( Burlak , DSpontTelep-Bur-1 ) ;
13871: LD_EXP 57
13875: PPUSH
13876: LD_STRING DSpontTelep-Bur-1
13878: PPUSH
13879: CALL_OW 88
// if IsOK ( Scholtze ) then
13883: LD_EXP 71
13887: PPUSH
13888: CALL_OW 302
13892: IFFALSE 13908
// Say ( Scholtze , DSpontTelep-Sch-2 ) else
13894: LD_EXP 71
13898: PPUSH
13899: LD_STRING DSpontTelep-Sch-2
13901: PPUSH
13902: CALL_OW 88
13906: GO 13920
// Say ( Kapitsova , DSpontTelep-Kap-2 ) ;
13908: LD_EXP 75
13912: PPUSH
13913: LD_STRING DSpontTelep-Kap-2
13915: PPUSH
13916: CALL_OW 88
// Say ( Burlak , DSpontTelep-Bur-2 ) ;
13920: LD_EXP 57
13924: PPUSH
13925: LD_STRING DSpontTelep-Bur-2
13927: PPUSH
13928: CALL_OW 88
// DialogueOff ;
13932: CALL_OW 7
// end ; ChangeMissionObjectives ( MTele ) ;
13936: LD_STRING MTele
13938: PPUSH
13939: CALL_OW 337
// end ;
13943: LD_VAR 0 1
13947: RET
// every 0 0$1 trigger buildingsToBuild <= 3 and GetAmountWeaponsDataBuildOnVehicle ( false ) <= 1 and techsToResearch <= 4 do
13948: LD_EXP 8
13952: PUSH
13953: LD_INT 3
13955: LESSEQUAL
13956: PUSH
13957: LD_INT 0
13959: PPUSH
13960: CALL 6800 0 1
13964: PUSH
13965: LD_INT 1
13967: LESSEQUAL
13968: AND
13969: PUSH
13970: LD_EXP 9
13974: PUSH
13975: LD_INT 4
13977: LESSEQUAL
13978: AND
13979: IFFALSE 14180
13981: GO 13983
13983: DISABLE
// begin SayRadio ( Popov , DAmAttackStart-Pop-1 ) ;
13984: LD_EXP 76
13988: PPUSH
13989: LD_STRING DAmAttackStart-Pop-1
13991: PPUSH
13992: CALL_OW 94
// if KurtStatus = 1 and HeikeStatus = 1 then
13996: LD_EXP 22
14000: PUSH
14001: LD_INT 1
14003: EQUAL
14004: PUSH
14005: LD_EXP 3
14009: PUSH
14010: LD_INT 1
14012: EQUAL
14013: AND
14014: IFFALSE 14172
// begin wait ( 0 0$10 ) ;
14016: LD_INT 350
14018: PPUSH
14019: CALL_OW 67
// DialogueOn ;
14023: CALL_OW 6
// SayRadio ( Heike , DLegionFormed-Hke-1 ) ;
14027: LD_EXP 79
14031: PPUSH
14032: LD_STRING DLegionFormed-Hke-1
14034: PPUSH
14035: CALL_OW 94
// Say ( Burlak , DLegionFormed-Bur-1 ) ;
14039: LD_EXP 57
14043: PPUSH
14044: LD_STRING DLegionFormed-Bur-1
14046: PPUSH
14047: CALL_OW 88
// SayRadio ( Heike , DLegionFormed-Hke-2 ) ;
14051: LD_EXP 79
14055: PPUSH
14056: LD_STRING DLegionFormed-Hke-2
14058: PPUSH
14059: CALL_OW 94
// Say ( Burlak , DLegionFormed-Bur-2 ) ;
14063: LD_EXP 57
14067: PPUSH
14068: LD_STRING DLegionFormed-Bur-2
14070: PPUSH
14071: CALL_OW 88
// SayRadio ( Heike , DLegionFormed-Hke-3 ) ;
14075: LD_EXP 79
14079: PPUSH
14080: LD_STRING DLegionFormed-Hke-3
14082: PPUSH
14083: CALL_OW 94
// case Query ( QLegion ) of 1 :
14087: LD_STRING QLegion
14089: PPUSH
14090: CALL_OW 97
14094: PUSH
14095: LD_INT 1
14097: DOUBLE
14098: EQUAL
14099: IFTRUE 14103
14101: GO 14134
14103: POP
// begin acceptLegionOffert = true ;
14104: LD_ADDR_EXP 31
14108: PUSH
14109: LD_INT 1
14111: ST_TO_ADDR
// legionOffertCountdown = true ;
14112: LD_ADDR_EXP 33
14116: PUSH
14117: LD_INT 1
14119: ST_TO_ADDR
// Say ( Burlak , DQrLegion#1-Bur-1 ) ;
14120: LD_EXP 57
14124: PPUSH
14125: LD_STRING DQrLegion#1-Bur-1
14127: PPUSH
14128: CALL_OW 88
// end ; 2 :
14132: GO 14166
14134: LD_INT 2
14136: DOUBLE
14137: EQUAL
14138: IFTRUE 14142
14140: GO 14165
14142: POP
// begin Say ( Burlak , DQrLegion#2-Bur-1 ) ;
14143: LD_EXP 57
14147: PPUSH
14148: LD_STRING DQrLegion#2-Bur-1
14150: PPUSH
14151: CALL_OW 88
// americansAttack = true ;
14155: LD_ADDR_EXP 26
14159: PUSH
14160: LD_INT 1
14162: ST_TO_ADDR
// end ; end ;
14163: GO 14166
14165: POP
// DialogueOff ;
14166: CALL_OW 7
// end else
14170: GO 14180
// begin americansAttack = true ;
14172: LD_ADDR_EXP 26
14176: PUSH
14177: LD_INT 1
14179: ST_TO_ADDR
// end ; end ;
14180: END
// every 0 0$1 trigger legionOffertTime <= 0 0$00 do
14181: LD_EXP 34
14185: PUSH
14186: LD_INT 0
14188: LESSEQUAL
14189: IFFALSE 14210
14191: GO 14193
14193: DISABLE
// begin legionOffertCountdown = false ;
14194: LD_ADDR_EXP 33
14198: PUSH
14199: LD_INT 0
14201: ST_TO_ADDR
// americansAttack = true ;
14202: LD_ADDR_EXP 26
14206: PUSH
14207: LD_INT 1
14209: ST_TO_ADDR
// end ;
14210: END
// every 0 0$1 trigger legionOffertCountdown do var needCrates , depots , depot , crates ;
14211: LD_EXP 33
14215: IFFALSE 14401
14217: GO 14219
14219: DISABLE
14220: LD_INT 0
14222: PPUSH
14223: PPUSH
14224: PPUSH
14225: PPUSH
// begin needCrates = 50 ;
14226: LD_ADDR_VAR 0 1
14230: PUSH
14231: LD_INT 50
14233: ST_TO_ADDR
// crates = 0 ;
14234: LD_ADDR_VAR 0 4
14238: PUSH
14239: LD_INT 0
14241: ST_TO_ADDR
// depots = FilterAllUnits ( [ [ f_side , 3 ] , [ [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ] ) ;
14242: LD_ADDR_VAR 0 2
14246: PUSH
14247: LD_INT 22
14249: PUSH
14250: LD_INT 3
14252: PUSH
14253: EMPTY
14254: LIST
14255: LIST
14256: PUSH
14257: LD_INT 2
14259: PUSH
14260: LD_INT 30
14262: PUSH
14263: LD_INT 0
14265: PUSH
14266: EMPTY
14267: LIST
14268: LIST
14269: PUSH
14270: LD_INT 30
14272: PUSH
14273: LD_INT 1
14275: PUSH
14276: EMPTY
14277: LIST
14278: LIST
14279: PUSH
14280: EMPTY
14281: LIST
14282: LIST
14283: LIST
14284: PUSH
14285: EMPTY
14286: LIST
14287: PUSH
14288: EMPTY
14289: LIST
14290: LIST
14291: PPUSH
14292: CALL_OW 69
14296: ST_TO_ADDR
// for depot in depots do
14297: LD_ADDR_VAR 0 3
14301: PUSH
14302: LD_VAR 0 2
14306: PUSH
14307: FOR_IN
14308: IFFALSE 14399
// begin crates = GetResourceType ( GetBase ( depot ) , mat_cans ) ;
14310: LD_ADDR_VAR 0 4
14314: PUSH
14315: LD_VAR 0 3
14319: PPUSH
14320: CALL_OW 274
14324: PPUSH
14325: LD_INT 1
14327: PPUSH
14328: CALL_OW 275
14332: ST_TO_ADDR
// if crates >= needCrates then
14333: LD_VAR 0 4
14337: PUSH
14338: LD_VAR 0 1
14342: GREATEREQUAL
14343: IFFALSE 14397
// begin SetResourceType ( GetBase ( depot ) , mat_cans , crates - needCrates ) ;
14345: LD_VAR 0 3
14349: PPUSH
14350: CALL_OW 274
14354: PPUSH
14355: LD_INT 1
14357: PPUSH
14358: LD_VAR 0 4
14362: PUSH
14363: LD_VAR 0 1
14367: MINUS
14368: PPUSH
14369: CALL_OW 277
// legionOffertCountdown = false ;
14373: LD_ADDR_EXP 33
14377: PUSH
14378: LD_INT 0
14380: ST_TO_ADDR
// paidLegionOffert = true ;
14381: LD_ADDR_EXP 32
14385: PUSH
14386: LD_INT 1
14388: ST_TO_ADDR
// americansAttack = true ;
14389: LD_ADDR_EXP 26
14393: PUSH
14394: LD_INT 1
14396: ST_TO_ADDR
// end ; end ;
14397: GO 14307
14399: POP
14400: POP
// end ;
14401: PPOPN 4
14403: END
// every 0 0$1 trigger currentAmWave >= americansAttackWaves and FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_type , unit_human ] , [ f_and , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ] ] ) = 0 do
14404: LD_EXP 85
14408: PUSH
14409: LD_EXP 48
14413: GREATEREQUAL
14414: PUSH
14415: LD_INT 22
14417: PUSH
14418: LD_INT 1
14420: PUSH
14421: EMPTY
14422: LIST
14423: LIST
14424: PUSH
14425: LD_INT 2
14427: PUSH
14428: LD_INT 21
14430: PUSH
14431: LD_INT 1
14433: PUSH
14434: EMPTY
14435: LIST
14436: LIST
14437: PUSH
14438: LD_INT 1
14440: PUSH
14441: LD_INT 21
14443: PUSH
14444: LD_INT 2
14446: PUSH
14447: EMPTY
14448: LIST
14449: LIST
14450: PUSH
14451: LD_INT 33
14453: PUSH
14454: LD_INT 3
14456: PUSH
14457: EMPTY
14458: LIST
14459: LIST
14460: PUSH
14461: EMPTY
14462: LIST
14463: LIST
14464: LIST
14465: PUSH
14466: EMPTY
14467: LIST
14468: LIST
14469: LIST
14470: PUSH
14471: EMPTY
14472: LIST
14473: LIST
14474: PPUSH
14475: CALL_OW 69
14479: PUSH
14480: LD_INT 0
14482: EQUAL
14483: AND
14484: IFFALSE 14684
14486: GO 14488
14488: DISABLE
// begin DialogueOn ;
14489: CALL_OW 6
// if IsOK ( Belkov ) then
14493: LD_EXP 66
14497: PPUSH
14498: CALL_OW 302
14502: IFFALSE 14518
// Say ( Belkov , DAmAttackFin-Bel-1 ) else
14504: LD_EXP 66
14508: PPUSH
14509: LD_STRING DAmAttackFin-Bel-1
14511: PPUSH
14512: CALL_OW 88
14516: GO 14541
// if IsOK ( Belkov2 ) then
14518: LD_EXP 67
14522: PPUSH
14523: CALL_OW 302
14527: IFFALSE 14541
// Say ( Belkov2 , DAmAttackFin-Bel-1 ) ;
14529: LD_EXP 67
14533: PPUSH
14534: LD_STRING DAmAttackFin-Bel-1
14536: PPUSH
14537: CALL_OW 88
// if IsOK ( Gnyevko ) then
14541: LD_EXP 69
14545: PPUSH
14546: CALL_OW 302
14550: IFFALSE 14564
// Say ( Gnyevko , DAmAttackFin-Gny-1 ) ;
14552: LD_EXP 69
14556: PPUSH
14557: LD_STRING DAmAttackFin-Gny-1
14559: PPUSH
14560: CALL_OW 88
// if IsOK ( Titov ) then
14564: LD_EXP 62
14568: PPUSH
14569: CALL_OW 302
14573: IFFALSE 14587
// Say ( Titov , DAmAttackFin-Tit-1 ) ;
14575: LD_EXP 62
14579: PPUSH
14580: LD_STRING DAmAttackFin-Tit-1
14582: PPUSH
14583: CALL_OW 88
// if IsOK ( Lipshchin ) then
14587: LD_EXP 64
14591: PPUSH
14592: CALL_OW 302
14596: IFFALSE 14610
// Say ( Lipshchin , DAmAttackFin-Lip-1 ) ;
14598: LD_EXP 64
14602: PPUSH
14603: LD_STRING DAmAttackFin-Lip-1
14605: PPUSH
14606: CALL_OW 88
// if IsOK ( Karamazov ) then
14610: LD_EXP 58
14614: PPUSH
14615: CALL_OW 302
14619: IFFALSE 14633
// Say ( Karamazov , DAmAttackFin-Kar-1 ) ;
14621: LD_EXP 58
14625: PPUSH
14626: LD_STRING DAmAttackFin-Kar-1
14628: PPUSH
14629: CALL_OW 88
// if IsOK ( Oblukov ) then
14633: LD_EXP 74
14637: PPUSH
14638: CALL_OW 302
14642: IFFALSE 14656
// Say ( Oblukov , DAmAttackFin-Obl-1 ) ;
14644: LD_EXP 74
14648: PPUSH
14649: LD_STRING DAmAttackFin-Obl-1
14651: PPUSH
14652: CALL_OW 88
// Say ( Burlak , AmAttackFin-Bur-1 ) ;
14656: LD_EXP 57
14660: PPUSH
14661: LD_STRING AmAttackFin-Bur-1
14663: PPUSH
14664: CALL_OW 88
// SayRadio ( Popov , DAmAttackFin-Pop-1 ) ;
14668: LD_EXP 76
14672: PPUSH
14673: LD_STRING DAmAttackFin-Pop-1
14675: PPUSH
14676: CALL_OW 94
// DialogueOff ;
14680: CALL_OW 7
// end ;
14684: END
// every 0 0$1 trigger buildingsToBuild + ( 3 - GetAmountWeaponsDataBuildOnTurret ( true ) ) = 0 do
14685: LD_EXP 8
14689: PUSH
14690: LD_INT 3
14692: PUSH
14693: LD_INT 1
14695: PPUSH
14696: CALL 6690 0 1
14700: MINUS
14701: PLUS
14702: PUSH
14703: LD_INT 0
14705: EQUAL
14706: IFFALSE 14718
14708: GO 14710
14710: DISABLE
// ChangeMissionObjectives ( MBuildingsDone ) ;
14711: LD_STRING MBuildingsDone
14713: PPUSH
14714: CALL_OW 337
14718: END
// every 0 0$1 trigger GetAmountWeaponsDataBuildOnVehicle ( false ) = 0 do
14719: LD_INT 0
14721: PPUSH
14722: CALL 6800 0 1
14726: PUSH
14727: LD_INT 0
14729: EQUAL
14730: IFFALSE 14742
14732: GO 14734
14734: DISABLE
// ChangeMissionObjectives ( MWeaponsDone ) ;
14735: LD_STRING MWeaponsDone
14737: PPUSH
14738: CALL_OW 337
14742: END
// every 0 0$1 trigger techsToResearch = 0 do
14743: LD_EXP 9
14747: PUSH
14748: LD_INT 0
14750: EQUAL
14751: IFFALSE 14763
14753: GO 14755
14755: DISABLE
// ChangeMissionObjectives ( MTechnoDone ) ;
14756: LD_STRING MTechnoDone
14758: PPUSH
14759: CALL_OW 337
14763: END
// every 0 0$1 trigger americansAttack and not FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_type , unit_human ] , [ f_and , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ] ] ) do
14764: LD_EXP 26
14768: PUSH
14769: LD_INT 22
14771: PUSH
14772: LD_INT 1
14774: PUSH
14775: EMPTY
14776: LIST
14777: LIST
14778: PUSH
14779: LD_INT 2
14781: PUSH
14782: LD_INT 21
14784: PUSH
14785: LD_INT 1
14787: PUSH
14788: EMPTY
14789: LIST
14790: LIST
14791: PUSH
14792: LD_INT 1
14794: PUSH
14795: LD_INT 21
14797: PUSH
14798: LD_INT 2
14800: PUSH
14801: EMPTY
14802: LIST
14803: LIST
14804: PUSH
14805: LD_INT 33
14807: PUSH
14808: LD_INT 3
14810: PUSH
14811: EMPTY
14812: LIST
14813: LIST
14814: PUSH
14815: EMPTY
14816: LIST
14817: LIST
14818: LIST
14819: PUSH
14820: EMPTY
14821: LIST
14822: LIST
14823: LIST
14824: PUSH
14825: EMPTY
14826: LIST
14827: LIST
14828: PPUSH
14829: CALL_OW 69
14833: NOT
14834: AND
14835: IFFALSE 14847
14837: GO 14839
14839: DISABLE
// ChangeMissionObjectives ( MEnemyDone ) ;
14840: LD_STRING MEnemyDone
14842: PPUSH
14843: CALL_OW 337
14847: END
// every 0 0$1 trigger ( buildingsToBuild + ( 3 - GetAmountWeaponsDataBuildOnTurret ( true ) ) ) = 0 and GetAmountWeaponsDataBuildOnVehicle ( false ) = 0 and techsToResearch = 0 and FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] ] ) = 0 and FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_type , unit_human ] , [ f_and , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ] ] ) = 0 and Masha and IsOK ( Masha [ 1 ] ) and buildCompVehicle and testedTeleport do
14848: LD_EXP 8
14852: PUSH
14853: LD_INT 3
14855: PUSH
14856: LD_INT 1
14858: PPUSH
14859: CALL 6690 0 1
14863: MINUS
14864: PLUS
14865: PUSH
14866: LD_INT 0
14868: EQUAL
14869: PUSH
14870: LD_INT 0
14872: PPUSH
14873: CALL 6800 0 1
14877: PUSH
14878: LD_INT 0
14880: EQUAL
14881: AND
14882: PUSH
14883: LD_EXP 9
14887: PUSH
14888: LD_INT 0
14890: EQUAL
14891: AND
14892: PUSH
14893: LD_INT 22
14895: PUSH
14896: LD_INT 8
14898: PUSH
14899: EMPTY
14900: LIST
14901: LIST
14902: PUSH
14903: LD_INT 21
14905: PUSH
14906: LD_INT 1
14908: PUSH
14909: EMPTY
14910: LIST
14911: LIST
14912: PUSH
14913: EMPTY
14914: LIST
14915: LIST
14916: PPUSH
14917: CALL_OW 69
14921: PUSH
14922: LD_INT 0
14924: EQUAL
14925: AND
14926: PUSH
14927: LD_INT 22
14929: PUSH
14930: LD_INT 1
14932: PUSH
14933: EMPTY
14934: LIST
14935: LIST
14936: PUSH
14937: LD_INT 2
14939: PUSH
14940: LD_INT 21
14942: PUSH
14943: LD_INT 1
14945: PUSH
14946: EMPTY
14947: LIST
14948: LIST
14949: PUSH
14950: LD_INT 1
14952: PUSH
14953: LD_INT 21
14955: PUSH
14956: LD_INT 2
14958: PUSH
14959: EMPTY
14960: LIST
14961: LIST
14962: PUSH
14963: LD_INT 33
14965: PUSH
14966: LD_INT 3
14968: PUSH
14969: EMPTY
14970: LIST
14971: LIST
14972: PUSH
14973: EMPTY
14974: LIST
14975: LIST
14976: LIST
14977: PUSH
14978: EMPTY
14979: LIST
14980: LIST
14981: LIST
14982: PUSH
14983: EMPTY
14984: LIST
14985: LIST
14986: PPUSH
14987: CALL_OW 69
14991: PUSH
14992: LD_INT 0
14994: EQUAL
14995: AND
14996: PUSH
14997: LD_EXP 4
15001: AND
15002: PUSH
15003: LD_EXP 4
15007: PUSH
15008: LD_INT 1
15010: ARRAY
15011: PPUSH
15012: CALL_OW 302
15016: AND
15017: PUSH
15018: LD_EXP 37
15022: AND
15023: PUSH
15024: LD_EXP 39
15028: AND
15029: IFFALSE 15038
15031: GO 15033
15033: DISABLE
// begin FinishMission ;
15034: CALL 15243 0 0
// end ;
15038: END
// every 0 0$1 do var unit ;
15039: GO 15041
15041: DISABLE
15042: LD_INT 0
15044: PPUSH
// begin case allowExitFromMap of 1 :
15045: LD_EXP 18
15049: PUSH
15050: LD_INT 1
15052: DOUBLE
15053: EQUAL
15054: IFTRUE 15058
15056: GO 15086
15058: POP
// RemoveUnits ( FilterUnitsInArea ( ExitMapArea , [ [ f_side , 6 ] ] ) ) ; 3 :
15059: LD_INT 8
15061: PPUSH
15062: LD_INT 22
15064: PUSH
15065: LD_INT 6
15067: PUSH
15068: EMPTY
15069: LIST
15070: LIST
15071: PUSH
15072: EMPTY
15073: LIST
15074: PPUSH
15075: CALL_OW 70
15079: PPUSH
15080: CALL 6526 0 1
15084: GO 15209
15086: LD_INT 3
15088: DOUBLE
15089: EQUAL
15090: IFTRUE 15094
15092: GO 15122
15094: POP
// RemoveUnits ( FilterUnitsInArea ( KurtExitMapArea , [ [ f_side , 8 ] ] ) ) ; 4 :
15095: LD_INT 11
15097: PPUSH
15098: LD_INT 22
15100: PUSH
15101: LD_INT 8
15103: PUSH
15104: EMPTY
15105: LIST
15106: LIST
15107: PUSH
15108: EMPTY
15109: LIST
15110: PPUSH
15111: CALL_OW 70
15115: PPUSH
15116: CALL 6526 0 1
15120: GO 15209
15122: LD_INT 4
15124: DOUBLE
15125: EQUAL
15126: IFTRUE 15130
15128: GO 15208
15130: POP
// begin RemoveUnits ( FilterUnitsInArea ( ExitMapArea , [ [ f_side , 8 ] ] ) ) ;
15131: LD_INT 8
15133: PPUSH
15134: LD_INT 22
15136: PUSH
15137: LD_INT 8
15139: PUSH
15140: EMPTY
15141: LIST
15142: LIST
15143: PUSH
15144: EMPTY
15145: LIST
15146: PPUSH
15147: CALL_OW 70
15151: PPUSH
15152: CALL 6526 0 1
// RemoveUnits ( FilterUnitsInArea ( KurtExitMapArea , [ [ f_side , 8 ] ] ) ) ;
15156: LD_INT 11
15158: PPUSH
15159: LD_INT 22
15161: PUSH
15162: LD_INT 8
15164: PUSH
15165: EMPTY
15166: LIST
15167: LIST
15168: PUSH
15169: EMPTY
15170: LIST
15171: PPUSH
15172: CALL_OW 70
15176: PPUSH
15177: CALL 6526 0 1
// RemoveUnits ( FilterUnitsInArea ( ExitMapArea , [ [ f_side , 2 ] ] ) ) ;
15181: LD_INT 8
15183: PPUSH
15184: LD_INT 22
15186: PUSH
15187: LD_INT 2
15189: PUSH
15190: EMPTY
15191: LIST
15192: LIST
15193: PUSH
15194: EMPTY
15195: LIST
15196: PPUSH
15197: CALL_OW 70
15201: PPUSH
15202: CALL 6526 0 1
// end ; end ;
15206: GO 15209
15208: POP
// enable ;
15209: ENABLE
// end ; end_of_file
15210: PPOPN 1
15212: END
// export function Lose_Burlak ; begin
15213: LD_INT 0
15215: PPUSH
// YouLost ( Burlak ) ;
15216: LD_STRING Burlak
15218: PPUSH
15219: CALL_OW 104
// end ;
15223: LD_VAR 0 1
15227: RET
// export function Lost_AttackAlly ; begin
15228: LD_INT 0
15230: PPUSH
// YouLost ( SelfAttack ) ;
15231: LD_STRING SelfAttack
15233: PPUSH
15234: CALL_OW 104
// end ; end_of_file
15238: LD_VAR 0 1
15242: RET
// export function FinishMission ; begin
15243: LD_INT 0
15245: PPUSH
// SetRewards ;
15246: CALL 15267 0 0
// SavePlayerCharacters ;
15250: CALL 15528 0 0
// SaveGlobalVariables ;
15254: CALL 16078 0 0
// YouWin ;
15258: CALL_OW 103
// end ;
15262: LD_VAR 0 1
15266: RET
// function SetRewards ; begin
15267: LD_INT 0
15269: PPUSH
// AddMedal ( ArtisticImpression , 1 ) ;
15270: LD_STRING ArtisticImpression
15272: PPUSH
15273: LD_INT 1
15275: PPUSH
15276: CALL_OW 101
// if not HeikeCaptured then
15280: LD_EXP 1
15284: NOT
15285: IFFALSE 15319
// begin if speedMedalTime >= 0 0$00 then
15287: LD_EXP 52
15291: PUSH
15292: LD_INT 0
15294: GREATEREQUAL
15295: IFFALSE 15309
// AddMedal ( Speed , 1 ) else
15297: LD_STRING Speed
15299: PPUSH
15300: LD_INT 1
15302: PPUSH
15303: CALL_OW 101
15307: GO 15319
// AddMedal ( Speed , 1 ) ;
15309: LD_STRING Speed
15311: PPUSH
15312: LD_INT 1
15314: PPUSH
15315: CALL_OW 101
// end ; if lostUnits then
15319: LD_EXP 40
15323: IFFALSE 15338
// begin AddMedal ( FavouriteCommander , - 1 ) ;
15325: LD_STRING FavouriteCommander
15327: PPUSH
15328: LD_INT 1
15330: NEG
15331: PPUSH
15332: CALL_OW 101
// end else
15336: GO 15430
// begin case BurlakRespect of 0 :
15338: LD_EXP 30
15342: PUSH
15343: LD_INT 0
15345: DOUBLE
15346: EQUAL
15347: IFTRUE 15351
15349: GO 15365
15351: POP
// AddMedal ( FavouriteCommander , - 2 ) ; 1 :
15352: LD_STRING FavouriteCommander
15354: PPUSH
15355: LD_INT 2
15357: NEG
15358: PPUSH
15359: CALL_OW 101
15363: GO 15430
15365: LD_INT 1
15367: DOUBLE
15368: EQUAL
15369: IFTRUE 15373
15371: GO 15387
15373: POP
// AddMedal ( FavouriteCommander , - 3 ) ; 2 :
15374: LD_STRING FavouriteCommander
15376: PPUSH
15377: LD_INT 3
15379: NEG
15380: PPUSH
15381: CALL_OW 101
15385: GO 15430
15387: LD_INT 2
15389: DOUBLE
15390: EQUAL
15391: IFTRUE 15395
15393: GO 15408
15395: POP
// AddMedal ( FavouriteCommander , 1 ) ; 3 :
15396: LD_STRING FavouriteCommander
15398: PPUSH
15399: LD_INT 1
15401: PPUSH
15402: CALL_OW 101
15406: GO 15430
15408: LD_INT 3
15410: DOUBLE
15411: EQUAL
15412: IFTRUE 15416
15414: GO 15429
15416: POP
// AddMedal ( FavouriteCommander , 1 ) ; end ;
15417: LD_STRING FavouriteCommander
15419: PPUSH
15420: LD_INT 1
15422: PPUSH
15423: CALL_OW 101
15427: GO 15430
15429: POP
// end ; if HeikeCaptured then
15430: LD_EXP 1
15434: IFFALSE 15465
// begin if buildArabBarrack then
15436: LD_EXP 38
15440: IFFALSE 15454
// AddMedal ( ArabBarracks , 1 ) else
15442: LD_STRING ArabBarracks
15444: PPUSH
15445: LD_INT 1
15447: PPUSH
15448: CALL_OW 101
15452: GO 15465
// AddMedal ( ArabBarracks , - 1 ) ;
15454: LD_STRING ArabBarracks
15456: PPUSH
15457: LD_INT 1
15459: NEG
15460: PPUSH
15461: CALL_OW 101
// end ; GiveMedals ( Main1 ) ;
15465: LD_STRING Main1
15467: PPUSH
15468: CALL_OW 102
// RewardPeople ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_nation , nation_russian ] , [ f_ok ] ] ) ) ;
15472: LD_INT 22
15474: PUSH
15475: LD_INT 3
15477: PUSH
15478: EMPTY
15479: LIST
15480: LIST
15481: PUSH
15482: LD_INT 21
15484: PUSH
15485: LD_INT 1
15487: PUSH
15488: EMPTY
15489: LIST
15490: LIST
15491: PUSH
15492: LD_INT 23
15494: PUSH
15495: LD_INT 3
15497: PUSH
15498: EMPTY
15499: LIST
15500: LIST
15501: PUSH
15502: LD_INT 50
15504: PUSH
15505: EMPTY
15506: LIST
15507: PUSH
15508: EMPTY
15509: LIST
15510: LIST
15511: LIST
15512: LIST
15513: PPUSH
15514: CALL_OW 69
15518: PPUSH
15519: CALL_OW 43
// end ;
15523: LD_VAR 0 1
15527: RET
// function SavePlayerCharacters ; var randomsToSave ; begin
15528: LD_INT 0
15530: PPUSH
15531: PPUSH
// ExtSaveCharacter ( Burlak , Burlak , 3 ) ;
15532: LD_EXP 57
15536: PPUSH
15537: LD_STRING Burlak
15539: PPUSH
15540: LD_INT 3
15542: PPUSH
15543: CALL 6048 0 3
// ExtSaveCharacter ( Karamazov , Karamazov , 3 ) ;
15547: LD_EXP 58
15551: PPUSH
15552: LD_STRING Karamazov
15554: PPUSH
15555: LD_INT 3
15557: PPUSH
15558: CALL 6048 0 3
// ExtSaveCharacter ( Petrovova , Petrovova , 3 ) ;
15562: LD_EXP 59
15566: PPUSH
15567: LD_STRING Petrovova
15569: PPUSH
15570: LD_INT 3
15572: PPUSH
15573: CALL 6048 0 3
// ExtSaveCharacter ( Gleb , Gleb , 3 ) ;
15577: LD_EXP 60
15581: PPUSH
15582: LD_STRING Gleb
15584: PPUSH
15585: LD_INT 3
15587: PPUSH
15588: CALL 6048 0 3
// ExtSaveCharacter ( Petrosyan , Petrosyan , 3 ) ;
15592: LD_EXP 61
15596: PPUSH
15597: LD_STRING Petrosyan
15599: PPUSH
15600: LD_INT 3
15602: PPUSH
15603: CALL 6048 0 3
// ExtSaveCharacter ( Dolgov , Dolgov , 3 ) ;
15607: LD_EXP 63
15611: PPUSH
15612: LD_STRING Dolgov
15614: PPUSH
15615: LD_INT 3
15617: PPUSH
15618: CALL 6048 0 3
// ExtSaveCharacter ( Lipshchin , Lipshchin , 3 ) ;
15622: LD_EXP 64
15626: PPUSH
15627: LD_STRING Lipshchin
15629: PPUSH
15630: LD_INT 3
15632: PPUSH
15633: CALL 6048 0 3
// ExtSaveCharacter ( Titov , Titov , 3 ) ;
15637: LD_EXP 62
15641: PPUSH
15642: LD_STRING Titov
15644: PPUSH
15645: LD_INT 3
15647: PPUSH
15648: CALL 6048 0 3
// ExtSaveCharacter ( Kirilenkova , Kirilenkova , 3 ) ;
15652: LD_EXP 65
15656: PPUSH
15657: LD_STRING Kirilenkova
15659: PPUSH
15660: LD_INT 3
15662: PPUSH
15663: CALL 6048 0 3
// ExtSaveCharacter ( Belkov , Belkov , 3 ) ;
15667: LD_EXP 66
15671: PPUSH
15672: LD_STRING Belkov
15674: PPUSH
15675: LD_INT 3
15677: PPUSH
15678: CALL 6048 0 3
// ExtSaveCharacter ( Belkov2 , Belkov2 , 3 ) ;
15682: LD_EXP 67
15686: PPUSH
15687: LD_STRING Belkov2
15689: PPUSH
15690: LD_INT 3
15692: PPUSH
15693: CALL 6048 0 3
// ExtSaveCharacter ( Xavier , Xavier , 3 ) ;
15697: LD_EXP 68
15701: PPUSH
15702: LD_STRING Xavier
15704: PPUSH
15705: LD_INT 3
15707: PPUSH
15708: CALL 6048 0 3
// ExtSaveCharacter ( Kozlov , Kozlov , 3 ) ;
15712: LD_EXP 73
15716: PPUSH
15717: LD_STRING Kozlov
15719: PPUSH
15720: LD_INT 3
15722: PPUSH
15723: CALL 6048 0 3
// ExtSaveCharacter ( Oblukov , Oblukov , 3 ) ;
15727: LD_EXP 74
15731: PPUSH
15732: LD_STRING Oblukov
15734: PPUSH
15735: LD_INT 3
15737: PPUSH
15738: CALL 6048 0 3
// ExtSaveCharacter ( Kapitsova , Kapitsova , 3 ) ;
15742: LD_EXP 75
15746: PPUSH
15747: LD_STRING Kapitsova
15749: PPUSH
15750: LD_INT 3
15752: PPUSH
15753: CALL 6048 0 3
// ExtSaveCharacter ( Gnyevko , Gnyevko , 3 ) ;
15757: LD_EXP 69
15761: PPUSH
15762: LD_STRING Gnyevko
15764: PPUSH
15765: LD_INT 3
15767: PPUSH
15768: CALL 6048 0 3
// ExtSaveCharacter ( Kovalyuk , Kovalyuk , 3 ) ;
15772: LD_EXP 70
15776: PPUSH
15777: LD_STRING Kovalyuk
15779: PPUSH
15780: LD_INT 3
15782: PPUSH
15783: CALL 6048 0 3
// ExtSaveCharacter ( Scholtze , Scholtze , 3 ) ;
15787: LD_EXP 71
15791: PPUSH
15792: LD_STRING Scholtze
15794: PPUSH
15795: LD_INT 3
15797: PPUSH
15798: CALL 6048 0 3
// ExtSaveCharacter ( Kuzmov , Kuzmov , 3 ) ;
15802: LD_EXP 72
15806: PPUSH
15807: LD_STRING Kuzmov
15809: PPUSH
15810: LD_INT 3
15812: PPUSH
15813: CALL 6048 0 3
// ExtSaveCharacters ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_or , [ f_class , class_apeman ] , [ f_class , class_apeman_engineer ] , [ f_class , class_apeman_soldier ] ] ] ) , other_apemans , 3 ) ;
15817: LD_INT 22
15819: PUSH
15820: LD_INT 3
15822: PUSH
15823: EMPTY
15824: LIST
15825: LIST
15826: PUSH
15827: LD_INT 21
15829: PUSH
15830: LD_INT 1
15832: PUSH
15833: EMPTY
15834: LIST
15835: LIST
15836: PUSH
15837: LD_INT 2
15839: PUSH
15840: LD_INT 25
15842: PUSH
15843: LD_INT 12
15845: PUSH
15846: EMPTY
15847: LIST
15848: LIST
15849: PUSH
15850: LD_INT 25
15852: PUSH
15853: LD_INT 16
15855: PUSH
15856: EMPTY
15857: LIST
15858: LIST
15859: PUSH
15860: LD_INT 25
15862: PUSH
15863: LD_INT 15
15865: PUSH
15866: EMPTY
15867: LIST
15868: LIST
15869: PUSH
15870: EMPTY
15871: LIST
15872: LIST
15873: LIST
15874: LIST
15875: PUSH
15876: EMPTY
15877: LIST
15878: LIST
15879: LIST
15880: PPUSH
15881: CALL_OW 69
15885: PPUSH
15886: LD_STRING other_apemans
15888: PPUSH
15889: LD_INT 3
15891: PPUSH
15892: CALL 6105 0 3
// randomsToSave = FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_nation , nation_russian ] ] ) diff [ Burlak , Karamazov , Petrovova , Gleb , Petrosyan , Titov , Dolgov , Lipshchin , Kirilenkova , Belkov , Belkov2 , Xavier , Gnyevko , Kovalyuk , Scholtze , Kuzmov , Kozlov , Oblukov , Kapitsova ] ;
15896: LD_ADDR_VAR 0 2
15900: PUSH
15901: LD_INT 22
15903: PUSH
15904: LD_INT 3
15906: PUSH
15907: EMPTY
15908: LIST
15909: LIST
15910: PUSH
15911: LD_INT 21
15913: PUSH
15914: LD_INT 1
15916: PUSH
15917: EMPTY
15918: LIST
15919: LIST
15920: PUSH
15921: LD_INT 23
15923: PUSH
15924: LD_INT 3
15926: PUSH
15927: EMPTY
15928: LIST
15929: LIST
15930: PUSH
15931: EMPTY
15932: LIST
15933: LIST
15934: LIST
15935: PPUSH
15936: CALL_OW 69
15940: PUSH
15941: LD_EXP 57
15945: PUSH
15946: LD_EXP 58
15950: PUSH
15951: LD_EXP 59
15955: PUSH
15956: LD_EXP 60
15960: PUSH
15961: LD_EXP 61
15965: PUSH
15966: LD_EXP 62
15970: PUSH
15971: LD_EXP 63
15975: PUSH
15976: LD_EXP 64
15980: PUSH
15981: LD_EXP 65
15985: PUSH
15986: LD_EXP 66
15990: PUSH
15991: LD_EXP 67
15995: PUSH
15996: LD_EXP 68
16000: PUSH
16001: LD_EXP 69
16005: PUSH
16006: LD_EXP 70
16010: PUSH
16011: LD_EXP 71
16015: PUSH
16016: LD_EXP 72
16020: PUSH
16021: LD_EXP 73
16025: PUSH
16026: LD_EXP 74
16030: PUSH
16031: LD_EXP 75
16035: PUSH
16036: EMPTY
16037: LIST
16038: LIST
16039: LIST
16040: LIST
16041: LIST
16042: LIST
16043: LIST
16044: LIST
16045: LIST
16046: LIST
16047: LIST
16048: LIST
16049: LIST
16050: LIST
16051: LIST
16052: LIST
16053: LIST
16054: LIST
16055: LIST
16056: DIFF
16057: ST_TO_ADDR
// ExtSaveCharacters ( randomsToSave , other_survivors , 3 ) ;
16058: LD_VAR 0 2
16062: PPUSH
16063: LD_STRING other_survivors
16065: PPUSH
16066: LD_INT 3
16068: PPUSH
16069: CALL 6105 0 3
// end ;
16073: LD_VAR 0 1
16077: RET
// function SaveGlobalVariables ; begin
16078: LD_INT 0
16080: PPUSH
// SaveBase ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_building ] ] ) , 08_TrockyBase_1 ) ;
16081: LD_INT 22
16083: PUSH
16084: LD_INT 3
16086: PUSH
16087: EMPTY
16088: LIST
16089: LIST
16090: PUSH
16091: LD_INT 21
16093: PUSH
16094: LD_INT 3
16096: PUSH
16097: EMPTY
16098: LIST
16099: LIST
16100: PUSH
16101: EMPTY
16102: LIST
16103: LIST
16104: PPUSH
16105: CALL_OW 69
16109: PPUSH
16110: LD_STRING 08_TrockyBase_1
16112: PPUSH
16113: CALL 8484 0 2
// SaveVariable ( coopWithGensher , 08_CoopWithGensher_2 ) ;
16117: LD_EXP 2
16121: PPUSH
16122: LD_STRING 08_CoopWithGensher_2
16124: PPUSH
16125: CALL_OW 39
// SaveVariable ( HeikeStatus , 08_HeikeStatus_3 ) ;
16129: LD_EXP 3
16133: PPUSH
16134: LD_STRING 08_HeikeStatus_3
16136: PPUSH
16137: CALL_OW 39
// SaveVariable ( Masha , 08_Masha_4 ) ;
16141: LD_EXP 4
16145: PPUSH
16146: LD_STRING 08_Masha_4
16148: PPUSH
16149: CALL_OW 39
// end ; end_of_file
16153: LD_VAR 0 1
16157: RET
// export function CustomEvent ( event ) ; begin
16158: LD_INT 0
16160: PPUSH
// end ;
16161: LD_VAR 0 2
16165: RET
// on BuildingComplete ( building ) do begin if GetBType ( building ) in buildingsToBuild and GetNation ( building ) = nation_russian then
16166: LD_VAR 0 1
16170: PPUSH
16171: CALL_OW 266
16175: PUSH
16176: LD_EXP 8
16180: IN
16181: PUSH
16182: LD_VAR 0 1
16186: PPUSH
16187: CALL_OW 248
16191: PUSH
16192: LD_INT 3
16194: EQUAL
16195: AND
16196: IFFALSE 16219
// buildingsToBuild = buildingsToBuild diff GetBType ( building ) ;
16198: LD_ADDR_EXP 8
16202: PUSH
16203: LD_EXP 8
16207: PUSH
16208: LD_VAR 0 1
16212: PPUSH
16213: CALL_OW 266
16217: DIFF
16218: ST_TO_ADDR
// if GetBType ( building ) = b_depot then
16219: LD_VAR 0 1
16223: PPUSH
16224: CALL_OW 266
16228: PUSH
16229: LD_INT 0
16231: EQUAL
16232: IFFALSE 16283
// begin SetBName ( building , trockij ) ;
16234: LD_VAR 0 1
16238: PPUSH
16239: LD_STRING trockij
16241: PPUSH
16242: CALL_OW 500
// if not dial_BuildDepotBlocker and HeikeCaptured then
16246: LD_EXP 5
16250: NOT
16251: PUSH
16252: LD_EXP 1
16256: AND
16257: IFFALSE 16283
// Dial_EscortHeike ( GetX ( building ) , GetY ( building ) ) ;
16259: LD_VAR 0 1
16263: PPUSH
16264: CALL_OW 250
16268: PPUSH
16269: LD_VAR 0 1
16273: PPUSH
16274: CALL_OW 251
16278: PPUSH
16279: CALL 9149 0 2
// end ; end ;
16283: PPOPN 1
16285: END
// on UpgradeComplete ( building ) do begin if GetBType ( building ) in buildingsToBuild and GetNation ( building ) = nation_russian then
16286: LD_VAR 0 1
16290: PPUSH
16291: CALL_OW 266
16295: PUSH
16296: LD_EXP 8
16300: IN
16301: PUSH
16302: LD_VAR 0 1
16306: PPUSH
16307: CALL_OW 248
16311: PUSH
16312: LD_INT 3
16314: EQUAL
16315: AND
16316: IFFALSE 16339
// buildingsToBuild = buildingsToBuild diff GetBType ( building ) ;
16318: LD_ADDR_EXP 8
16322: PUSH
16323: LD_EXP 8
16327: PUSH
16328: LD_VAR 0 1
16332: PPUSH
16333: CALL_OW 266
16337: DIFF
16338: ST_TO_ADDR
// if GetBType ( building ) = b_barracks and GetNation ( building ) = 2 and not dial_BuildArBarrackBlocker then
16339: LD_VAR 0 1
16343: PPUSH
16344: CALL_OW 266
16348: PUSH
16349: LD_INT 5
16351: EQUAL
16352: PUSH
16353: LD_VAR 0 1
16357: PPUSH
16358: CALL_OW 248
16362: PUSH
16363: LD_INT 2
16365: EQUAL
16366: AND
16367: PUSH
16368: LD_EXP 6
16372: NOT
16373: AND
16374: IFFALSE 16380
// Dial_UpgradeArmoury ;
16376: CALL 9960 0 0
// end ;
16380: PPOPN 1
16382: END
// on ResearchComplete ( research , building ) do begin if research in techsToResearch then
16383: LD_VAR 0 1
16387: PUSH
16388: LD_EXP 9
16392: IN
16393: IFFALSE 16411
// techsToResearch = techsToResearch diff research ;
16395: LD_ADDR_EXP 9
16399: PUSH
16400: LD_EXP 9
16404: PUSH
16405: LD_VAR 0 1
16409: DIFF
16410: ST_TO_ADDR
// if research = tech_LimTeleport then
16411: LD_VAR 0 1
16415: PUSH
16416: LD_INT 37
16418: EQUAL
16419: IFFALSE 16425
// Dial_TeleportTechResearched ;
16421: CALL 13805 0 0
// if research = tech_AdvAI then
16425: LD_VAR 0 1
16429: PUSH
16430: LD_INT 27
16432: EQUAL
16433: IFFALSE 16439
// Dial_ComputerTechResearched ;
16435: CALL 13674 0 0
// end ;
16439: PPOPN 2
16441: END
// on EnterVehicle ( vehicle , human ) do begin if not canChooseMashaVehicle then
16442: LD_EXP 36
16446: NOT
16447: IFFALSE 16451
// exit ;
16449: GO 16618
// wait ( 0 0$1 ) ;
16451: LD_INT 35
16453: PPUSH
16454: CALL_OW 67
// if GetSide ( vehicle ) = 3 and human = Burlak and GetNation ( vehicle ) = nation_russian and GetWeapon ( vehicle ) in [ ru_heavy_machine_gun , ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher ] then
16458: LD_VAR 0 1
16462: PPUSH
16463: CALL_OW 255
16467: PUSH
16468: LD_INT 3
16470: EQUAL
16471: PUSH
16472: LD_VAR 0 2
16476: PUSH
16477: LD_EXP 57
16481: EQUAL
16482: AND
16483: PUSH
16484: LD_VAR 0 1
16488: PPUSH
16489: CALL_OW 248
16493: PUSH
16494: LD_INT 3
16496: EQUAL
16497: AND
16498: PUSH
16499: LD_VAR 0 1
16503: PPUSH
16504: CALL_OW 264
16508: PUSH
16509: LD_INT 42
16511: PUSH
16512: LD_INT 43
16514: PUSH
16515: LD_INT 44
16517: PUSH
16518: LD_INT 46
16520: PUSH
16521: LD_INT 45
16523: PUSH
16524: EMPTY
16525: LIST
16526: LIST
16527: LIST
16528: LIST
16529: LIST
16530: IN
16531: AND
16532: IFFALSE 16618
// begin if Masha then
16534: LD_EXP 4
16538: IFFALSE 16558
// if Masha [ 1 ] = vehicle then
16540: LD_EXP 4
16544: PUSH
16545: LD_INT 1
16547: ARRAY
16548: PUSH
16549: LD_VAR 0 1
16553: EQUAL
16554: IFFALSE 16558
// exit ;
16556: GO 16618
// if firstMashaQuery then
16558: LD_EXP 35
16562: IFFALSE 16596
// begin firstMashaQuery = false ;
16564: LD_ADDR_EXP 35
16568: PUSH
16569: LD_INT 0
16571: ST_TO_ADDR
// if Query ( QMashaQuery ) = 1 then
16572: LD_STRING QMashaQuery
16574: PPUSH
16575: CALL_OW 97
16579: PUSH
16580: LD_INT 1
16582: EQUAL
16583: IFFALSE 16594
// SetMashaData ( vehicle ) ;
16585: LD_VAR 0 1
16589: PPUSH
16590: CALL 8378 0 1
// end else
16594: GO 16618
// begin if Query ( QMashaQuery2 ) = 1 then
16596: LD_STRING QMashaQuery2
16598: PPUSH
16599: CALL_OW 97
16603: PUSH
16604: LD_INT 1
16606: EQUAL
16607: IFFALSE 16618
// SetMashaData ( vehicle ) ;
16609: LD_VAR 0 1
16613: PPUSH
16614: CALL 8378 0 1
// end ; end ; end ;
16618: PPOPN 2
16620: END
// on UnitDestroyed ( unit ) do begin if Masha then
16621: LD_EXP 4
16625: IFFALSE 16650
// if unit = Masha [ 1 ] then
16627: LD_VAR 0 1
16631: PUSH
16632: LD_EXP 4
16636: PUSH
16637: LD_INT 1
16639: ARRAY
16640: EQUAL
16641: IFFALSE 16650
// Masha = [ ] ;
16643: LD_ADDR_EXP 4
16647: PUSH
16648: EMPTY
16649: ST_TO_ADDR
// if unit = Burlak then
16650: LD_VAR 0 1
16654: PUSH
16655: LD_EXP 57
16659: EQUAL
16660: IFFALSE 16666
// Lose_Burlak ;
16662: CALL 15213 0 0
// if GetType ( unit ) = unit_human and GetNation ( unit ) = nation_russian then
16666: LD_VAR 0 1
16670: PPUSH
16671: CALL_OW 247
16675: PUSH
16676: LD_INT 1
16678: EQUAL
16679: PUSH
16680: LD_VAR 0 1
16684: PPUSH
16685: CALL_OW 248
16689: PUSH
16690: LD_INT 3
16692: EQUAL
16693: AND
16694: IFFALSE 16710
// lostUnits = lostUnits + 1 ;
16696: LD_ADDR_EXP 40
16700: PUSH
16701: LD_EXP 40
16705: PUSH
16706: LD_INT 1
16708: PLUS
16709: ST_TO_ADDR
// end ;
16710: PPOPN 1
16712: END
// on UnitGoesToRed ( unit ) do begin if GetType ( unit ) = unit_vehicle and GetNation ( unit ) = nation_russian and GetTech ( tech_LimTeleport , 3 ) = state_researched and not testedTeleport then
16713: LD_VAR 0 1
16717: PPUSH
16718: CALL_OW 247
16722: PUSH
16723: LD_INT 2
16725: EQUAL
16726: PUSH
16727: LD_VAR 0 1
16731: PPUSH
16732: CALL_OW 248
16736: PUSH
16737: LD_INT 3
16739: EQUAL
16740: AND
16741: PUSH
16742: LD_INT 37
16744: PPUSH
16745: LD_INT 3
16747: PPUSH
16748: CALL_OW 321
16752: PUSH
16753: LD_INT 2
16755: EQUAL
16756: AND
16757: PUSH
16758: LD_EXP 39
16762: NOT
16763: AND
16764: IFFALSE 16781
// begin testedTeleport = true ;
16766: LD_ADDR_EXP 39
16770: PUSH
16771: LD_INT 1
16773: ST_TO_ADDR
// ChangeMissionObjectives ( MTeleDone ) ;
16774: LD_STRING MTeleDone
16776: PPUSH
16777: CALL_OW 337
// end ; if unit = Heike then
16781: LD_VAR 0 1
16785: PUSH
16786: LD_EXP 79
16790: EQUAL
16791: IFFALSE 16834
// begin DialogueOn ;
16793: CALL_OW 6
// CenterNowOnUnits ( Heike ) ;
16797: LD_EXP 79
16801: PPUSH
16802: CALL_OW 87
// ForceSay ( Heike , DHeikeKilled-Hke-1 ) ;
16806: LD_EXP 79
16810: PPUSH
16811: LD_STRING DHeikeKilled-Hke-1
16813: PPUSH
16814: CALL_OW 91
// DialogueOff ;
16818: CALL_OW 7
// SetLives ( Heike , 0 ) ;
16822: LD_EXP 79
16826: PPUSH
16827: LD_INT 0
16829: PPUSH
16830: CALL_OW 234
// end ; end ;
16834: PPOPN 1
16836: END
// on Contact ( side1 , side2 ) do begin if side1 = 3 and side2 = 6 then
16837: LD_VAR 0 1
16841: PUSH
16842: LD_INT 3
16844: EQUAL
16845: PUSH
16846: LD_VAR 0 2
16850: PUSH
16851: LD_INT 6
16853: EQUAL
16854: AND
16855: IFFALSE 16861
// Lost_AttackAlly ;
16857: CALL 15228 0 0
// if side1 = 3 and side2 = 2 then
16861: LD_VAR 0 1
16865: PUSH
16866: LD_INT 3
16868: EQUAL
16869: PUSH
16870: LD_VAR 0 2
16874: PUSH
16875: LD_INT 2
16877: EQUAL
16878: AND
16879: IFFALSE 16885
// Dial_AttackGensher ;
16881: CALL 10916 0 0
// if side1 = 3 and side2 = 5 then
16885: LD_VAR 0 1
16889: PUSH
16890: LD_INT 3
16892: EQUAL
16893: PUSH
16894: LD_VAR 0 2
16898: PUSH
16899: LD_INT 5
16901: EQUAL
16902: AND
16903: IFFALSE 16947
// begin SetAttitude ( 3 , 5 , att_enemy , true ) ;
16905: LD_INT 3
16907: PPUSH
16908: LD_INT 5
16910: PPUSH
16911: LD_INT 2
16913: PPUSH
16914: LD_INT 1
16916: PPUSH
16917: CALL_OW 80
// if acceptKurtOffert and not GetSide ( Kurt ) = 2 then
16921: LD_EXP 19
16925: PUSH
16926: LD_EXP 80
16930: PPUSH
16931: CALL_OW 255
16935: PUSH
16936: LD_INT 2
16938: EQUAL
16939: NOT
16940: AND
16941: IFFALSE 16947
// Dial_BetrayedKurt1 ;
16943: CALL 11465 0 0
// end ; if side1 = 3 and side2 = 8 and GetAttitude ( 3 , 8 ) = att_neutral then
16947: LD_VAR 0 1
16951: PUSH
16952: LD_INT 3
16954: EQUAL
16955: PUSH
16956: LD_VAR 0 2
16960: PUSH
16961: LD_INT 8
16963: EQUAL
16964: AND
16965: PUSH
16966: LD_INT 3
16968: PPUSH
16969: LD_INT 8
16971: PPUSH
16972: CALL_OW 81
16976: PUSH
16977: LD_INT 0
16979: EQUAL
16980: AND
16981: IFFALSE 16993
// begin if acceptKurtOffert then
16983: LD_EXP 19
16987: IFFALSE 16993
// Dial_BetrayedKurt2 ;
16989: CALL 11551 0 0
// end ; end ;
16993: PPOPN 2
16995: END
// on VehicleConstructed ( vehicle , building ) do begin SetWeaponDataBuild ( GetWeapon ( vehicle ) , false ) ;
16996: LD_VAR 0 1
17000: PPUSH
17001: CALL_OW 264
17005: PPUSH
17006: LD_INT 0
17008: PPUSH
17009: CALL 6886 0 2
// if GetControl ( vehicle ) = control_computer and not buildCompVehicle then
17013: LD_VAR 0 1
17017: PPUSH
17018: CALL_OW 263
17022: PUSH
17023: LD_INT 3
17025: EQUAL
17026: PUSH
17027: LD_EXP 37
17031: NOT
17032: AND
17033: IFFALSE 17050
// begin buildCompVehicle = true ;
17035: LD_ADDR_EXP 37
17039: PUSH
17040: LD_INT 1
17042: ST_TO_ADDR
// ChangeMissionObjectives ( MAIDone ) ;
17043: LD_STRING MAIDone
17045: PPUSH
17046: CALL_OW 337
// end ; end ;
17050: PPOPN 2
17052: END
// on WeaponPlaced ( building , factory ) do begin SetWeaponDataBuild ( GetBWeapon ( building ) , true ) ;
17053: LD_VAR 0 1
17057: PPUSH
17058: CALL_OW 269
17062: PPUSH
17063: LD_INT 1
17065: PPUSH
17066: CALL 6886 0 2
// end ;
17070: PPOPN 2
17072: END
// on Command ( comandid ) do var i ;
17073: LD_INT 0
17075: PPUSH
// begin if IsOK ( KurtEng ) and GetSide ( KurtEng ) = 3 then
17076: LD_EXP 82
17080: PPUSH
17081: CALL_OW 302
17085: PUSH
17086: LD_EXP 82
17090: PPUSH
17091: CALL_OW 255
17095: PUSH
17096: LD_INT 3
17098: EQUAL
17099: AND
17100: IFFALSE 17309
// if GetTaskList ( KurtEng ) then
17102: LD_EXP 82
17106: PPUSH
17107: CALL_OW 437
17111: IFFALSE 17309
// begin for i := 1 to ( GetTaskList ( KurtEng ) ) do
17113: LD_ADDR_VAR 0 2
17117: PUSH
17118: DOUBLE
17119: LD_INT 1
17121: DEC
17122: ST_TO_ADDR
17123: LD_EXP 82
17127: PPUSH
17128: CALL_OW 437
17132: PUSH
17133: FOR_TO
17134: IFFALSE 17307
// begin if ( GetTaskList ( KurtEng ) [ i ] [ 1 ] in [ F , H , M , U , V , a , h , u , v , ~ , ^ , > , + , ; , 4 , { ] ) or ( GetTaskList ( KurtEng ) [ i ] [ 1 ] = B and GetTaskList ( KurtEng ) [ i ] [ 5 ] = 36 ) then
17136: LD_EXP 82
17140: PPUSH
17141: CALL_OW 437
17145: PUSH
17146: LD_VAR 0 2
17150: ARRAY
17151: PUSH
17152: LD_INT 1
17154: ARRAY
17155: PUSH
17156: LD_STRING F
17158: PUSH
17159: LD_STRING H
17161: PUSH
17162: LD_STRING M
17164: PUSH
17165: LD_STRING U
17167: PUSH
17168: LD_STRING V
17170: PUSH
17171: LD_STRING a
17173: PUSH
17174: LD_STRING h
17176: PUSH
17177: LD_STRING u
17179: PUSH
17180: LD_STRING v
17182: PUSH
17183: LD_STRING ~
17185: PUSH
17186: LD_STRING ^
17188: PUSH
17189: LD_STRING >
17191: PUSH
17192: LD_STRING +
17194: PUSH
17195: LD_STRING ;
17197: PUSH
17198: LD_STRING 4
17200: PUSH
17201: LD_STRING {
17203: PUSH
17204: EMPTY
17205: LIST
17206: LIST
17207: LIST
17208: LIST
17209: LIST
17210: LIST
17211: LIST
17212: LIST
17213: LIST
17214: LIST
17215: LIST
17216: LIST
17217: LIST
17218: LIST
17219: LIST
17220: LIST
17221: IN
17222: PUSH
17223: LD_EXP 82
17227: PPUSH
17228: CALL_OW 437
17232: PUSH
17233: LD_VAR 0 2
17237: ARRAY
17238: PUSH
17239: LD_INT 1
17241: ARRAY
17242: PUSH
17243: LD_STRING B
17245: EQUAL
17246: PUSH
17247: LD_EXP 82
17251: PPUSH
17252: CALL_OW 437
17256: PUSH
17257: LD_VAR 0 2
17261: ARRAY
17262: PUSH
17263: LD_INT 5
17265: ARRAY
17266: PUSH
17267: LD_INT 36
17269: EQUAL
17270: AND
17271: OR
17272: IFFALSE 17276
// else
17274: GO 17305
// begin RemoveTasks ( KurtEng ) ;
17276: LD_EXP 82
17280: PPUSH
17281: CALL_OW 493
// DialogueOn ;
17285: CALL_OW 6
// Say ( Kurt , DMercRefuseBuild-Kurt-1 ) ;
17289: LD_EXP 80
17293: PPUSH
17294: LD_STRING DMercRefuseBuild-Kurt-1
17296: PPUSH
17297: CALL_OW 88
// DialogueOff ;
17301: CALL_OW 7
// end ; end ;
17305: GO 17133
17307: POP
17308: POP
// end ; end ; end_of_file
17309: PPOPN 2
17311: END
// every 0 0$01 do var timer , cratesSpawned ;
17312: GO 17314
17314: DISABLE
17315: LD_INT 0
17317: PPUSH
17318: PPUSH
// begin timer := 1 1$30 ;
17319: LD_ADDR_VAR 0 1
17323: PUSH
17324: LD_INT 3150
17326: ST_TO_ADDR
// repeat wait ( timer ) ;
17327: LD_VAR 0 1
17331: PPUSH
17332: CALL_OW 67
// if cratesSpawned >= 6 and cratesSpawned < 18 then
17336: LD_VAR 0 2
17340: PUSH
17341: LD_INT 6
17343: GREATEREQUAL
17344: PUSH
17345: LD_VAR 0 2
17349: PUSH
17350: LD_INT 18
17352: LESS
17353: AND
17354: IFFALSE 17370
// timer := timer + 0 0$3 ;
17356: LD_ADDR_VAR 0 1
17360: PUSH
17361: LD_VAR 0 1
17365: PUSH
17366: LD_INT 105
17368: PLUS
17369: ST_TO_ADDR
// if cratesSpawned >= 18 then
17370: LD_VAR 0 2
17374: PUSH
17375: LD_INT 18
17377: GREATEREQUAL
17378: IFFALSE 17394
// timer := timer + 0 0$9 ;
17380: LD_ADDR_VAR 0 1
17384: PUSH
17385: LD_VAR 0 1
17389: PUSH
17390: LD_INT 315
17392: PLUS
17393: ST_TO_ADDR
// if timer > 3 3$00 then
17394: LD_VAR 0 1
17398: PUSH
17399: LD_INT 6300
17401: GREATER
17402: IFFALSE 17412
// timer := 0 0$50 ;
17404: LD_ADDR_VAR 0 1
17408: PUSH
17409: LD_INT 1750
17411: ST_TO_ADDR
// CreateCratesArea ( rand ( 3 , 5 ) , CratesSpawnArea , true ) ;
17412: LD_INT 3
17414: PPUSH
17415: LD_INT 5
17417: PPUSH
17418: CALL_OW 12
17422: PPUSH
17423: LD_INT 15
17425: PPUSH
17426: LD_INT 1
17428: PPUSH
17429: CALL_OW 55
// cratesSpawned = cratesSpawned + 1 ;
17433: LD_ADDR_VAR 0 2
17437: PUSH
17438: LD_VAR 0 2
17442: PUSH
17443: LD_INT 1
17445: PLUS
17446: ST_TO_ADDR
// until false ;
17447: LD_INT 0
17449: IFFALSE 17327
// end ; end_of_file
17451: PPOPN 2
17453: END
// every 0 0$1 do
17454: GO 17456
17456: DISABLE
// begin enable ;
17457: ENABLE
// end ;
17458: END
// every 0 0$1 do var building , playerBuildings , playerBuildingsBType ;
17459: GO 17461
17461: DISABLE
17462: LD_INT 0
17464: PPUSH
17465: PPUSH
17466: PPUSH
// begin playerBuildings = FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_building ] , [ f_nation , nation_russian ] ] ) ;
17467: LD_ADDR_VAR 0 2
17471: PUSH
17472: LD_INT 22
17474: PUSH
17475: LD_INT 3
17477: PUSH
17478: EMPTY
17479: LIST
17480: LIST
17481: PUSH
17482: LD_INT 21
17484: PUSH
17485: LD_INT 3
17487: PUSH
17488: EMPTY
17489: LIST
17490: LIST
17491: PUSH
17492: LD_INT 23
17494: PUSH
17495: LD_INT 3
17497: PUSH
17498: EMPTY
17499: LIST
17500: LIST
17501: PUSH
17502: EMPTY
17503: LIST
17504: LIST
17505: LIST
17506: PPUSH
17507: CALL_OW 69
17511: ST_TO_ADDR
// playerBuildingsBType = [ ] ;
17512: LD_ADDR_VAR 0 3
17516: PUSH
17517: EMPTY
17518: ST_TO_ADDR
// for building in playerBuildings do
17519: LD_ADDR_VAR 0 1
17523: PUSH
17524: LD_VAR 0 2
17528: PUSH
17529: FOR_IN
17530: IFFALSE 17555
// playerBuildingsBType = playerBuildingsBType ^ GetBType ( building ) ;
17532: LD_ADDR_VAR 0 3
17536: PUSH
17537: LD_VAR 0 3
17541: PUSH
17542: LD_VAR 0 1
17546: PPUSH
17547: CALL_OW 266
17551: ADD
17552: ST_TO_ADDR
17553: GO 17529
17555: POP
17556: POP
// for building in allBuildings do
17557: LD_ADDR_VAR 0 1
17561: PUSH
17562: LD_EXP 13
17566: PUSH
17567: FOR_IN
17568: IFFALSE 17614
// if not building in playerBuildingsBType and not building in buildingsToBuild then
17570: LD_VAR 0 1
17574: PUSH
17575: LD_VAR 0 3
17579: IN
17580: NOT
17581: PUSH
17582: LD_VAR 0 1
17586: PUSH
17587: LD_EXP 8
17591: IN
17592: NOT
17593: AND
17594: IFFALSE 17612
// buildingsToBuild = buildingsToBuild ^ building ;
17596: LD_ADDR_EXP 8
17600: PUSH
17601: LD_EXP 8
17605: PUSH
17606: LD_VAR 0 1
17610: ADD
17611: ST_TO_ADDR
17612: GO 17567
17614: POP
17615: POP
// enable ;
17616: ENABLE
// end ;
17617: PPOPN 3
17619: END
// every 0 0$1 trigger legionOffertCountdown do
17620: LD_EXP 33
17624: IFFALSE 17644
17626: GO 17628
17628: DISABLE
// begin legionOffertTime = legionOffertTime - 0 0$01 ;
17629: LD_ADDR_EXP 34
17633: PUSH
17634: LD_EXP 34
17638: PUSH
17639: LD_INT 35
17641: MINUS
17642: ST_TO_ADDR
// enable ;
17643: ENABLE
// end ;
17644: END
// every 0 0$1 trigger KurtWaitingForFreeHeike do
17645: LD_EXP 23
17649: IFFALSE 17683
17651: GO 17653
17653: DISABLE
// begin timeToFreeHeike = timeToFreeHeike - 0 0$01 ;
17654: LD_ADDR_EXP 54
17658: PUSH
17659: LD_EXP 54
17663: PUSH
17664: LD_INT 35
17666: MINUS
17667: ST_TO_ADDR
// if timeToFreeHeike <= 0 0$00 then
17668: LD_EXP 54
17672: PUSH
17673: LD_INT 0
17675: LESSEQUAL
17676: IFFALSE 17682
// Dial_PlayerDontSendHeike ;
17678: CALL 11413 0 0
// enable ;
17682: ENABLE
// end ;
17683: END
// every 0 0$1 trigger KurtWaitingForBuildBarrack and GetSide ( KurtEng ) = 3 do
17684: LD_EXP 24
17688: PUSH
17689: LD_EXP 82
17693: PPUSH
17694: CALL_OW 255
17698: PUSH
17699: LD_INT 3
17701: EQUAL
17702: AND
17703: IFFALSE 17776
17705: GO 17707
17707: DISABLE
// begin timeToBuildArBarrack = timeToBuildArBarrack - 0 0$01 ;
17708: LD_ADDR_EXP 55
17712: PUSH
17713: LD_EXP 55
17717: PUSH
17718: LD_INT 35
17720: MINUS
17721: ST_TO_ADDR
// if timeToBuildArBarrack <= 0 0$00 then
17722: LD_EXP 55
17726: PUSH
17727: LD_INT 0
17729: LESSEQUAL
17730: IFFALSE 17775
// begin Dial_BetrayedKurt1 ;
17732: CALL 11465 0 0
// wait ( 2 2$0 ) ;
17736: LD_INT 4200
17738: PPUSH
17739: CALL_OW 67
// SetAttitude ( 3 , 8 , att_enemy , true ) ;
17743: LD_INT 3
17745: PPUSH
17746: LD_INT 8
17748: PPUSH
17749: LD_INT 2
17751: PPUSH
17752: LD_INT 1
17754: PPUSH
17755: CALL_OW 80
// KurtAttack = true ;
17759: LD_ADDR_EXP 25
17763: PUSH
17764: LD_INT 1
17766: ST_TO_ADDR
// KurtWaitingForBuildBarrack = false ;
17767: LD_ADDR_EXP 24
17771: PUSH
17772: LD_INT 0
17774: ST_TO_ADDR
// end ; enable ;
17775: ENABLE
// end ; end_of_file
17776: END
// export currentAmWave , currentArWave ; every 0 0$1 trigger americansAttack do var i ;
17777: LD_EXP 26
17781: IFFALSE 17927
17783: GO 17785
17785: DISABLE
17786: LD_INT 0
17788: PPUSH
// begin currentAmWave = 0 ;
17789: LD_ADDR_EXP 85
17793: PUSH
17794: LD_INT 0
17796: ST_TO_ADDR
// wait ( firstAttackDelay ) ;
17797: LD_EXP 49
17801: PPUSH
17802: CALL_OW 67
// for i := 1 to americansAttackWaves do
17806: LD_ADDR_VAR 0 1
17810: PUSH
17811: DOUBLE
17812: LD_INT 1
17814: DEC
17815: ST_TO_ADDR
17816: LD_EXP 48
17820: PUSH
17821: FOR_TO
17822: IFFALSE 17925
// begin SpawnAmAttackTeam ;
17824: CALL 3214 0 0
// currentAmWave = currentAmWave + 1 ;
17828: LD_ADDR_EXP 85
17832: PUSH
17833: LD_EXP 85
17837: PUSH
17838: LD_INT 1
17840: PLUS
17841: ST_TO_ADDR
// if currentAmWave = 1 then
17842: LD_EXP 85
17846: PUSH
17847: LD_INT 1
17849: EQUAL
17850: IFFALSE 17914
// begin if paidLegionOffert then
17852: LD_EXP 32
17856: IFFALSE 17895
// begin Say ( Burlak , DAmAttackStart-Bur-1 ) ;
17858: LD_EXP 57
17862: PPUSH
17863: LD_STRING DAmAttackStart-Bur-1
17865: PPUSH
17866: CALL_OW 88
// if IsOK ( Gleb ) then
17870: LD_EXP 60
17874: PPUSH
17875: CALL_OW 302
17879: IFFALSE 17893
// Say ( Gleb , DAmAttackStart-Glb-1 ) ;
17881: LD_EXP 60
17885: PPUSH
17886: LD_STRING DAmAttackStart-Glb-1
17888: PPUSH
17889: CALL_OW 88
// end else
17893: GO 17907
// Say ( Burlak , DAmAttackStart-Bur-2 ) ;
17895: LD_EXP 57
17899: PPUSH
17900: LD_STRING DAmAttackStart-Bur-2
17902: PPUSH
17903: CALL_OW 88
// ChangeMissionObjectives ( MEnemy ) ;
17907: LD_STRING MEnemy
17909: PPUSH
17910: CALL_OW 337
// end ; wait ( waveCooldown ) ;
17914: LD_EXP 50
17918: PPUSH
17919: CALL_OW 67
// end ;
17923: GO 17821
17925: POP
17926: POP
// end ;
17927: PPOPN 1
17929: END
// every 0 0$1 trigger currentAmWave = 1 do
17930: LD_EXP 85
17934: PUSH
17935: LD_INT 1
17937: EQUAL
17938: IFFALSE 18027
17940: GO 17942
17942: DISABLE
// Attack ( [ 0 , amAttackTeam , [ [ 115 , 42 ] , [ 51 , 67 ] ] , [ 0 , 0 , 0 , 1 , 1 , 1 , 0 , 0 , 1 , 0 ] ] ) ;
17943: LD_INT 0
17945: PUSH
17946: LD_EXP 78
17950: PUSH
17951: LD_INT 115
17953: PUSH
17954: LD_INT 42
17956: PUSH
17957: EMPTY
17958: LIST
17959: LIST
17960: PUSH
17961: LD_INT 51
17963: PUSH
17964: LD_INT 67
17966: PUSH
17967: EMPTY
17968: LIST
17969: LIST
17970: PUSH
17971: EMPTY
17972: LIST
17973: LIST
17974: PUSH
17975: LD_INT 0
17977: PUSH
17978: LD_INT 0
17980: PUSH
17981: LD_INT 0
17983: PUSH
17984: LD_INT 1
17986: PUSH
17987: LD_INT 1
17989: PUSH
17990: LD_INT 1
17992: PUSH
17993: LD_INT 0
17995: PUSH
17996: LD_INT 0
17998: PUSH
17999: LD_INT 1
18001: PUSH
18002: LD_INT 0
18004: PUSH
18005: EMPTY
18006: LIST
18007: LIST
18008: LIST
18009: LIST
18010: LIST
18011: LIST
18012: LIST
18013: LIST
18014: LIST
18015: LIST
18016: PUSH
18017: EMPTY
18018: LIST
18019: LIST
18020: LIST
18021: LIST
18022: PPUSH
18023: CALL 80725 0 1
18027: END
// every 0 0$1 trigger currentAmWave = 2 do
18028: LD_EXP 85
18032: PUSH
18033: LD_INT 2
18035: EQUAL
18036: IFFALSE 18125
18038: GO 18040
18040: DISABLE
// Attack ( [ 0 , amAttackTeam , [ [ 115 , 42 ] , [ 51 , 67 ] ] , [ 0 , 0 , 0 , 1 , 1 , 1 , 0 , 0 , 1 , 0 ] ] ) ;
18041: LD_INT 0
18043: PUSH
18044: LD_EXP 78
18048: PUSH
18049: LD_INT 115
18051: PUSH
18052: LD_INT 42
18054: PUSH
18055: EMPTY
18056: LIST
18057: LIST
18058: PUSH
18059: LD_INT 51
18061: PUSH
18062: LD_INT 67
18064: PUSH
18065: EMPTY
18066: LIST
18067: LIST
18068: PUSH
18069: EMPTY
18070: LIST
18071: LIST
18072: PUSH
18073: LD_INT 0
18075: PUSH
18076: LD_INT 0
18078: PUSH
18079: LD_INT 0
18081: PUSH
18082: LD_INT 1
18084: PUSH
18085: LD_INT 1
18087: PUSH
18088: LD_INT 1
18090: PUSH
18091: LD_INT 0
18093: PUSH
18094: LD_INT 0
18096: PUSH
18097: LD_INT 1
18099: PUSH
18100: LD_INT 0
18102: PUSH
18103: EMPTY
18104: LIST
18105: LIST
18106: LIST
18107: LIST
18108: LIST
18109: LIST
18110: LIST
18111: LIST
18112: LIST
18113: LIST
18114: PUSH
18115: EMPTY
18116: LIST
18117: LIST
18118: LIST
18119: LIST
18120: PPUSH
18121: CALL 80725 0 1
18125: END
// every 0 0$1 trigger currentAmWave = 3 do
18126: LD_EXP 85
18130: PUSH
18131: LD_INT 3
18133: EQUAL
18134: IFFALSE 18223
18136: GO 18138
18138: DISABLE
// Attack ( [ 0 , amAttackTeam , [ [ 115 , 42 ] , [ 51 , 67 ] ] , [ 0 , 0 , 0 , 1 , 1 , 1 , 0 , 0 , 1 , 0 ] ] ) ;
18139: LD_INT 0
18141: PUSH
18142: LD_EXP 78
18146: PUSH
18147: LD_INT 115
18149: PUSH
18150: LD_INT 42
18152: PUSH
18153: EMPTY
18154: LIST
18155: LIST
18156: PUSH
18157: LD_INT 51
18159: PUSH
18160: LD_INT 67
18162: PUSH
18163: EMPTY
18164: LIST
18165: LIST
18166: PUSH
18167: EMPTY
18168: LIST
18169: LIST
18170: PUSH
18171: LD_INT 0
18173: PUSH
18174: LD_INT 0
18176: PUSH
18177: LD_INT 0
18179: PUSH
18180: LD_INT 1
18182: PUSH
18183: LD_INT 1
18185: PUSH
18186: LD_INT 1
18188: PUSH
18189: LD_INT 0
18191: PUSH
18192: LD_INT 0
18194: PUSH
18195: LD_INT 1
18197: PUSH
18198: LD_INT 0
18200: PUSH
18201: EMPTY
18202: LIST
18203: LIST
18204: LIST
18205: LIST
18206: LIST
18207: LIST
18208: LIST
18209: LIST
18210: LIST
18211: LIST
18212: PUSH
18213: EMPTY
18214: LIST
18215: LIST
18216: LIST
18217: LIST
18218: PPUSH
18219: CALL 80725 0 1
18223: END
// every 0 0$1 trigger KurtAttack do var i ;
18224: LD_EXP 25
18228: IFFALSE 18349
18230: GO 18232
18232: DISABLE
18233: LD_INT 0
18235: PPUSH
// begin currentArWave = 0 ;
18236: LD_ADDR_EXP 86
18240: PUSH
18241: LD_INT 0
18243: ST_TO_ADDR
// wait ( firstAttackDelay ) ;
18244: LD_EXP 49
18248: PPUSH
18249: CALL_OW 67
// for i := 1 to KurtAttackWaves do
18253: LD_ADDR_VAR 0 1
18257: PUSH
18258: DOUBLE
18259: LD_INT 1
18261: DEC
18262: ST_TO_ADDR
18263: LD_EXP 47
18267: PUSH
18268: FOR_TO
18269: IFFALSE 18347
// begin if KurtAttack and IsOK ( Heike ) then
18271: LD_EXP 25
18275: PUSH
18276: LD_EXP 79
18280: PPUSH
18281: CALL_OW 302
18285: AND
18286: IFFALSE 18345
// begin SpawnArAttackTeam ;
18288: CALL 4359 0 0
// currentArWave = currentArWave + 1 ;
18292: LD_ADDR_EXP 86
18296: PUSH
18297: LD_EXP 86
18301: PUSH
18302: LD_INT 1
18304: PLUS
18305: ST_TO_ADDR
// if currentArWave = 2 then
18306: LD_EXP 86
18310: PUSH
18311: LD_INT 2
18313: EQUAL
18314: IFFALSE 18336
// begin SayRadio ( Kurt , DMercAttack-Kurt-1 ) ;
18316: LD_EXP 80
18320: PPUSH
18321: LD_STRING DMercAttack-Kurt-1
18323: PPUSH
18324: CALL_OW 94
// canSendHeike = true ;
18328: LD_ADDR_EXP 28
18332: PUSH
18333: LD_INT 1
18335: ST_TO_ADDR
// end ; wait ( waveCooldown ) ;
18336: LD_EXP 50
18340: PPUSH
18341: CALL_OW 67
// end ; end ;
18345: GO 18268
18347: POP
18348: POP
// end ;
18349: PPOPN 1
18351: END
// every 0 0$1 trigger currentArWave = 1 do
18352: LD_EXP 86
18356: PUSH
18357: LD_INT 1
18359: EQUAL
18360: IFFALSE 18449
18362: GO 18364
18364: DISABLE
// Attack ( [ 0 , arAttackTeam , [ [ 115 , 42 ] , [ 51 , 67 ] ] , [ 0 , 0 , 0 , 1 , 1 , 1 , 0 , 0 , 1 , 0 ] ] ) ;
18365: LD_INT 0
18367: PUSH
18368: LD_EXP 84
18372: PUSH
18373: LD_INT 115
18375: PUSH
18376: LD_INT 42
18378: PUSH
18379: EMPTY
18380: LIST
18381: LIST
18382: PUSH
18383: LD_INT 51
18385: PUSH
18386: LD_INT 67
18388: PUSH
18389: EMPTY
18390: LIST
18391: LIST
18392: PUSH
18393: EMPTY
18394: LIST
18395: LIST
18396: PUSH
18397: LD_INT 0
18399: PUSH
18400: LD_INT 0
18402: PUSH
18403: LD_INT 0
18405: PUSH
18406: LD_INT 1
18408: PUSH
18409: LD_INT 1
18411: PUSH
18412: LD_INT 1
18414: PUSH
18415: LD_INT 0
18417: PUSH
18418: LD_INT 0
18420: PUSH
18421: LD_INT 1
18423: PUSH
18424: LD_INT 0
18426: PUSH
18427: EMPTY
18428: LIST
18429: LIST
18430: LIST
18431: LIST
18432: LIST
18433: LIST
18434: LIST
18435: LIST
18436: LIST
18437: LIST
18438: PUSH
18439: EMPTY
18440: LIST
18441: LIST
18442: LIST
18443: LIST
18444: PPUSH
18445: CALL 80725 0 1
18449: END
// every 0 0$1 trigger currentArWave = 2 do
18450: LD_EXP 86
18454: PUSH
18455: LD_INT 2
18457: EQUAL
18458: IFFALSE 18547
18460: GO 18462
18462: DISABLE
// Attack ( [ 0 , arAttackTeam , [ [ 115 , 42 ] , [ 51 , 67 ] ] , [ 0 , 0 , 0 , 1 , 1 , 1 , 0 , 0 , 1 , 0 ] ] ) ;
18463: LD_INT 0
18465: PUSH
18466: LD_EXP 84
18470: PUSH
18471: LD_INT 115
18473: PUSH
18474: LD_INT 42
18476: PUSH
18477: EMPTY
18478: LIST
18479: LIST
18480: PUSH
18481: LD_INT 51
18483: PUSH
18484: LD_INT 67
18486: PUSH
18487: EMPTY
18488: LIST
18489: LIST
18490: PUSH
18491: EMPTY
18492: LIST
18493: LIST
18494: PUSH
18495: LD_INT 0
18497: PUSH
18498: LD_INT 0
18500: PUSH
18501: LD_INT 0
18503: PUSH
18504: LD_INT 1
18506: PUSH
18507: LD_INT 1
18509: PUSH
18510: LD_INT 1
18512: PUSH
18513: LD_INT 0
18515: PUSH
18516: LD_INT 0
18518: PUSH
18519: LD_INT 1
18521: PUSH
18522: LD_INT 0
18524: PUSH
18525: EMPTY
18526: LIST
18527: LIST
18528: LIST
18529: LIST
18530: LIST
18531: LIST
18532: LIST
18533: LIST
18534: LIST
18535: LIST
18536: PUSH
18537: EMPTY
18538: LIST
18539: LIST
18540: LIST
18541: LIST
18542: PPUSH
18543: CALL 80725 0 1
18547: END
// every 0 0$1 trigger currentArWave = 3 do
18548: LD_EXP 86
18552: PUSH
18553: LD_INT 3
18555: EQUAL
18556: IFFALSE 18645
18558: GO 18560
18560: DISABLE
// Attack ( [ 0 , arAttackTeam , [ [ 115 , 42 ] , [ 51 , 67 ] ] , [ 0 , 0 , 0 , 1 , 1 , 1 , 0 , 0 , 1 , 0 ] ] ) ;
18561: LD_INT 0
18563: PUSH
18564: LD_EXP 84
18568: PUSH
18569: LD_INT 115
18571: PUSH
18572: LD_INT 42
18574: PUSH
18575: EMPTY
18576: LIST
18577: LIST
18578: PUSH
18579: LD_INT 51
18581: PUSH
18582: LD_INT 67
18584: PUSH
18585: EMPTY
18586: LIST
18587: LIST
18588: PUSH
18589: EMPTY
18590: LIST
18591: LIST
18592: PUSH
18593: LD_INT 0
18595: PUSH
18596: LD_INT 0
18598: PUSH
18599: LD_INT 0
18601: PUSH
18602: LD_INT 1
18604: PUSH
18605: LD_INT 1
18607: PUSH
18608: LD_INT 1
18610: PUSH
18611: LD_INT 0
18613: PUSH
18614: LD_INT 0
18616: PUSH
18617: LD_INT 1
18619: PUSH
18620: LD_INT 0
18622: PUSH
18623: EMPTY
18624: LIST
18625: LIST
18626: LIST
18627: LIST
18628: LIST
18629: LIST
18630: LIST
18631: LIST
18632: LIST
18633: LIST
18634: PUSH
18635: EMPTY
18636: LIST
18637: LIST
18638: LIST
18639: LIST
18640: PPUSH
18641: CALL 80725 0 1
18645: END
// every 0 0$1 trigger currentArWave = 4 do
18646: LD_EXP 86
18650: PUSH
18651: LD_INT 4
18653: EQUAL
18654: IFFALSE 18743
18656: GO 18658
18658: DISABLE
// Attack ( [ 0 , arAttackTeam , [ [ 115 , 42 ] , [ 51 , 67 ] ] , [ 0 , 0 , 0 , 1 , 1 , 1 , 0 , 0 , 1 , 0 ] ] ) ;
18659: LD_INT 0
18661: PUSH
18662: LD_EXP 84
18666: PUSH
18667: LD_INT 115
18669: PUSH
18670: LD_INT 42
18672: PUSH
18673: EMPTY
18674: LIST
18675: LIST
18676: PUSH
18677: LD_INT 51
18679: PUSH
18680: LD_INT 67
18682: PUSH
18683: EMPTY
18684: LIST
18685: LIST
18686: PUSH
18687: EMPTY
18688: LIST
18689: LIST
18690: PUSH
18691: LD_INT 0
18693: PUSH
18694: LD_INT 0
18696: PUSH
18697: LD_INT 0
18699: PUSH
18700: LD_INT 1
18702: PUSH
18703: LD_INT 1
18705: PUSH
18706: LD_INT 1
18708: PUSH
18709: LD_INT 0
18711: PUSH
18712: LD_INT 0
18714: PUSH
18715: LD_INT 1
18717: PUSH
18718: LD_INT 0
18720: PUSH
18721: EMPTY
18722: LIST
18723: LIST
18724: LIST
18725: LIST
18726: LIST
18727: LIST
18728: LIST
18729: LIST
18730: LIST
18731: LIST
18732: PUSH
18733: EMPTY
18734: LIST
18735: LIST
18736: LIST
18737: LIST
18738: PPUSH
18739: CALL 80725 0 1
18743: END
// every 0 0$1 trigger currentArWave = 5 do
18744: LD_EXP 86
18748: PUSH
18749: LD_INT 5
18751: EQUAL
18752: IFFALSE 18841
18754: GO 18756
18756: DISABLE
// Attack ( [ 0 , arAttackTeam , [ [ 115 , 42 ] , [ 51 , 67 ] ] , [ 0 , 0 , 0 , 1 , 1 , 1 , 0 , 0 , 1 , 0 ] ] ) ; end_of_file
18757: LD_INT 0
18759: PUSH
18760: LD_EXP 84
18764: PUSH
18765: LD_INT 115
18767: PUSH
18768: LD_INT 42
18770: PUSH
18771: EMPTY
18772: LIST
18773: LIST
18774: PUSH
18775: LD_INT 51
18777: PUSH
18778: LD_INT 67
18780: PUSH
18781: EMPTY
18782: LIST
18783: LIST
18784: PUSH
18785: EMPTY
18786: LIST
18787: LIST
18788: PUSH
18789: LD_INT 0
18791: PUSH
18792: LD_INT 0
18794: PUSH
18795: LD_INT 0
18797: PUSH
18798: LD_INT 1
18800: PUSH
18801: LD_INT 1
18803: PUSH
18804: LD_INT 1
18806: PUSH
18807: LD_INT 0
18809: PUSH
18810: LD_INT 0
18812: PUSH
18813: LD_INT 1
18815: PUSH
18816: LD_INT 0
18818: PUSH
18819: EMPTY
18820: LIST
18821: LIST
18822: LIST
18823: LIST
18824: LIST
18825: LIST
18826: LIST
18827: LIST
18828: LIST
18829: LIST
18830: PUSH
18831: EMPTY
18832: LIST
18833: LIST
18834: LIST
18835: LIST
18836: PPUSH
18837: CALL 80725 0 1
18841: END
// every 0 0$1 do var arVehs , arVeh , nearPlayerUnit ;
18842: GO 18844
18844: DISABLE
18845: LD_INT 0
18847: PPUSH
18848: PPUSH
18849: PPUSH
// begin enable ;
18850: ENABLE
// arVehs = FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_vehicle ] , [ f_empty ] ] ) ;
18851: LD_ADDR_VAR 0 1
18855: PUSH
18856: LD_INT 22
18858: PUSH
18859: LD_INT 8
18861: PUSH
18862: EMPTY
18863: LIST
18864: LIST
18865: PUSH
18866: LD_INT 21
18868: PUSH
18869: LD_INT 2
18871: PUSH
18872: EMPTY
18873: LIST
18874: LIST
18875: PUSH
18876: LD_INT 58
18878: PUSH
18879: EMPTY
18880: LIST
18881: PUSH
18882: EMPTY
18883: LIST
18884: LIST
18885: LIST
18886: PPUSH
18887: CALL_OW 69
18891: ST_TO_ADDR
// if not arVehs or not GetAttitude ( 3 , 8 ) = att_enemy then
18892: LD_VAR 0 1
18896: NOT
18897: PUSH
18898: LD_INT 3
18900: PPUSH
18901: LD_INT 8
18903: PPUSH
18904: CALL_OW 81
18908: PUSH
18909: LD_INT 2
18911: EQUAL
18912: NOT
18913: OR
18914: IFFALSE 18918
// exit ;
18916: GO 19008
// for arVeh in arVehs do
18918: LD_ADDR_VAR 0 2
18922: PUSH
18923: LD_VAR 0 1
18927: PUSH
18928: FOR_IN
18929: IFFALSE 19006
// begin nearPlayerUnit = NearestUnitToUnit ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) , arVeh ) ;
18931: LD_ADDR_VAR 0 3
18935: PUSH
18936: LD_INT 22
18938: PUSH
18939: LD_INT 3
18941: PUSH
18942: EMPTY
18943: LIST
18944: LIST
18945: PUSH
18946: LD_INT 21
18948: PUSH
18949: LD_INT 1
18951: PUSH
18952: EMPTY
18953: LIST
18954: LIST
18955: PUSH
18956: EMPTY
18957: LIST
18958: LIST
18959: PPUSH
18960: CALL_OW 69
18964: PPUSH
18965: LD_VAR 0 2
18969: PPUSH
18970: CALL_OW 74
18974: ST_TO_ADDR
// if GetDistUnits ( nearPlayerUnit , arVeh ) <= 2 then
18975: LD_VAR 0 3
18979: PPUSH
18980: LD_VAR 0 2
18984: PPUSH
18985: CALL_OW 296
18989: PUSH
18990: LD_INT 2
18992: LESSEQUAL
18993: IFFALSE 19004
// ComSelfDestruction ( arVeh ) ;
18995: LD_VAR 0 2
18999: PPUSH
19000: CALL_OW 577
// end ;
19004: GO 18928
19006: POP
19007: POP
// end ;
19008: PPOPN 3
19010: END
// every 0 0$1 trigger forceStopKurtAttack do
19011: LD_EXP 27
19015: IFFALSE 19081
19017: GO 19019
19019: DISABLE
// begin KurtAttack = false ;
19020: LD_ADDR_EXP 25
19024: PUSH
19025: LD_INT 0
19027: ST_TO_ADDR
// allowExitFromMap = 4 ;
19028: LD_ADDR_EXP 18
19032: PUSH
19033: LD_INT 4
19035: ST_TO_ADDR
// SetAttitude ( 3 , 8 , att_friend , true ) ;
19036: LD_INT 3
19038: PPUSH
19039: LD_INT 8
19041: PPUSH
19042: LD_INT 1
19044: PPUSH
19045: LD_INT 1
19047: PPUSH
19048: CALL_OW 80
// arAttackTeam = [ ] ;
19052: LD_ADDR_EXP 84
19056: PUSH
19057: EMPTY
19058: ST_TO_ADDR
// ComMoveToArea ( FilterAllUnits ( [ f_side , 8 ] ) , KurtExitMapArea ) ;
19059: LD_INT 22
19061: PUSH
19062: LD_INT 8
19064: PUSH
19065: EMPTY
19066: LIST
19067: LIST
19068: PPUSH
19069: CALL_OW 69
19073: PPUSH
19074: LD_INT 11
19076: PPUSH
19077: CALL_OW 113
// end ; end_of_file end_of_file
19081: END
// every 0 0$01 do var timer , cratesSpawned ;
19082: GO 19084
19084: DISABLE
19085: LD_INT 0
19087: PPUSH
19088: PPUSH
// begin timer := 1 1$30 ;
19089: LD_ADDR_VAR 0 1
19093: PUSH
19094: LD_INT 3150
19096: ST_TO_ADDR
// repeat wait ( timer ) ;
19097: LD_VAR 0 1
19101: PPUSH
19102: CALL_OW 67
// if cratesSpawned >= 6 and cratesSpawned < 18 then
19106: LD_VAR 0 2
19110: PUSH
19111: LD_INT 6
19113: GREATEREQUAL
19114: PUSH
19115: LD_VAR 0 2
19119: PUSH
19120: LD_INT 18
19122: LESS
19123: AND
19124: IFFALSE 19140
// timer := timer + 0 0$3 ;
19126: LD_ADDR_VAR 0 1
19130: PUSH
19131: LD_VAR 0 1
19135: PUSH
19136: LD_INT 105
19138: PLUS
19139: ST_TO_ADDR
// if cratesSpawned >= 18 then
19140: LD_VAR 0 2
19144: PUSH
19145: LD_INT 18
19147: GREATEREQUAL
19148: IFFALSE 19164
// timer := timer + 0 0$9 ;
19150: LD_ADDR_VAR 0 1
19154: PUSH
19155: LD_VAR 0 1
19159: PUSH
19160: LD_INT 315
19162: PLUS
19163: ST_TO_ADDR
// if timer > 3 3$00 then
19164: LD_VAR 0 1
19168: PUSH
19169: LD_INT 6300
19171: GREATER
19172: IFFALSE 19182
// timer := 0 0$50 ;
19174: LD_ADDR_VAR 0 1
19178: PUSH
19179: LD_INT 1750
19181: ST_TO_ADDR
// CreateCratesArea ( rand ( 3 , 5 ) , CratesSpawnArea , true ) ;
19182: LD_INT 3
19184: PPUSH
19185: LD_INT 5
19187: PPUSH
19188: CALL_OW 12
19192: PPUSH
19193: LD_INT 15
19195: PPUSH
19196: LD_INT 1
19198: PPUSH
19199: CALL_OW 55
// cratesSpawned = cratesSpawned + 1 ;
19203: LD_ADDR_VAR 0 2
19207: PUSH
19208: LD_VAR 0 2
19212: PUSH
19213: LD_INT 1
19215: PLUS
19216: ST_TO_ADDR
// until false ;
19217: LD_INT 0
19219: IFFALSE 19097
// end ; end_of_file
19221: PPOPN 2
19223: END
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
19224: LD_INT 0
19226: PPUSH
19227: PPUSH
// if exist_mode then
19228: LD_VAR 0 2
19232: IFFALSE 19257
// unit := CreateCharacter ( prefix & ident ) else
19234: LD_ADDR_VAR 0 5
19238: PUSH
19239: LD_VAR 0 3
19243: PUSH
19244: LD_VAR 0 1
19248: STR
19249: PPUSH
19250: CALL_OW 34
19254: ST_TO_ADDR
19255: GO 19272
// unit := NewCharacter ( ident ) ;
19257: LD_ADDR_VAR 0 5
19261: PUSH
19262: LD_VAR 0 1
19266: PPUSH
19267: CALL_OW 25
19271: ST_TO_ADDR
// result := unit ;
19272: LD_ADDR_VAR 0 4
19276: PUSH
19277: LD_VAR 0 5
19281: ST_TO_ADDR
// end ;
19282: LD_VAR 0 4
19286: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
19287: LD_INT 0
19289: PPUSH
19290: PPUSH
// if not side or not nation then
19291: LD_VAR 0 1
19295: NOT
19296: PUSH
19297: LD_VAR 0 2
19301: NOT
19302: OR
19303: IFFALSE 19307
// exit ;
19305: GO 20075
// case nation of nation_american :
19307: LD_VAR 0 2
19311: PUSH
19312: LD_INT 1
19314: DOUBLE
19315: EQUAL
19316: IFTRUE 19320
19318: GO 19534
19320: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 86 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 , 82 , 83 , 84 , 85 , 86 ] ; nation_arabian :
19321: LD_ADDR_VAR 0 4
19325: PUSH
19326: LD_INT 35
19328: PUSH
19329: LD_INT 45
19331: PUSH
19332: LD_INT 46
19334: PUSH
19335: LD_INT 47
19337: PUSH
19338: LD_INT 82
19340: PUSH
19341: LD_INT 83
19343: PUSH
19344: LD_INT 84
19346: PUSH
19347: LD_INT 85
19349: PUSH
19350: LD_INT 86
19352: PUSH
19353: LD_INT 1
19355: PUSH
19356: LD_INT 2
19358: PUSH
19359: LD_INT 6
19361: PUSH
19362: LD_INT 15
19364: PUSH
19365: LD_INT 16
19367: PUSH
19368: LD_INT 7
19370: PUSH
19371: LD_INT 12
19373: PUSH
19374: LD_INT 13
19376: PUSH
19377: LD_INT 10
19379: PUSH
19380: LD_INT 14
19382: PUSH
19383: LD_INT 20
19385: PUSH
19386: LD_INT 21
19388: PUSH
19389: LD_INT 22
19391: PUSH
19392: LD_INT 25
19394: PUSH
19395: LD_INT 32
19397: PUSH
19398: LD_INT 27
19400: PUSH
19401: LD_INT 36
19403: PUSH
19404: LD_INT 69
19406: PUSH
19407: LD_INT 39
19409: PUSH
19410: LD_INT 34
19412: PUSH
19413: LD_INT 40
19415: PUSH
19416: LD_INT 48
19418: PUSH
19419: LD_INT 49
19421: PUSH
19422: LD_INT 50
19424: PUSH
19425: LD_INT 51
19427: PUSH
19428: LD_INT 52
19430: PUSH
19431: LD_INT 53
19433: PUSH
19434: LD_INT 54
19436: PUSH
19437: LD_INT 55
19439: PUSH
19440: LD_INT 56
19442: PUSH
19443: LD_INT 57
19445: PUSH
19446: LD_INT 58
19448: PUSH
19449: LD_INT 59
19451: PUSH
19452: LD_INT 60
19454: PUSH
19455: LD_INT 61
19457: PUSH
19458: LD_INT 62
19460: PUSH
19461: LD_INT 80
19463: PUSH
19464: LD_INT 82
19466: PUSH
19467: LD_INT 83
19469: PUSH
19470: LD_INT 84
19472: PUSH
19473: LD_INT 85
19475: PUSH
19476: LD_INT 86
19478: PUSH
19479: EMPTY
19480: LIST
19481: LIST
19482: LIST
19483: LIST
19484: LIST
19485: LIST
19486: LIST
19487: LIST
19488: LIST
19489: LIST
19490: LIST
19491: LIST
19492: LIST
19493: LIST
19494: LIST
19495: LIST
19496: LIST
19497: LIST
19498: LIST
19499: LIST
19500: LIST
19501: LIST
19502: LIST
19503: LIST
19504: LIST
19505: LIST
19506: LIST
19507: LIST
19508: LIST
19509: LIST
19510: LIST
19511: LIST
19512: LIST
19513: LIST
19514: LIST
19515: LIST
19516: LIST
19517: LIST
19518: LIST
19519: LIST
19520: LIST
19521: LIST
19522: LIST
19523: LIST
19524: LIST
19525: LIST
19526: LIST
19527: LIST
19528: LIST
19529: LIST
19530: LIST
19531: ST_TO_ADDR
19532: GO 19999
19534: LD_INT 2
19536: DOUBLE
19537: EQUAL
19538: IFTRUE 19542
19540: GO 19768
19542: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 87 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 , 82 , 83 , 84 , 85 , 87 , 88 ] ; nation_russian :
19543: LD_ADDR_VAR 0 4
19547: PUSH
19548: LD_INT 35
19550: PUSH
19551: LD_INT 45
19553: PUSH
19554: LD_INT 46
19556: PUSH
19557: LD_INT 47
19559: PUSH
19560: LD_INT 82
19562: PUSH
19563: LD_INT 83
19565: PUSH
19566: LD_INT 84
19568: PUSH
19569: LD_INT 85
19571: PUSH
19572: LD_INT 87
19574: PUSH
19575: LD_INT 70
19577: PUSH
19578: LD_INT 1
19580: PUSH
19581: LD_INT 11
19583: PUSH
19584: LD_INT 3
19586: PUSH
19587: LD_INT 4
19589: PUSH
19590: LD_INT 5
19592: PUSH
19593: LD_INT 6
19595: PUSH
19596: LD_INT 15
19598: PUSH
19599: LD_INT 18
19601: PUSH
19602: LD_INT 7
19604: PUSH
19605: LD_INT 17
19607: PUSH
19608: LD_INT 8
19610: PUSH
19611: LD_INT 20
19613: PUSH
19614: LD_INT 21
19616: PUSH
19617: LD_INT 22
19619: PUSH
19620: LD_INT 72
19622: PUSH
19623: LD_INT 26
19625: PUSH
19626: LD_INT 69
19628: PUSH
19629: LD_INT 39
19631: PUSH
19632: LD_INT 40
19634: PUSH
19635: LD_INT 41
19637: PUSH
19638: LD_INT 42
19640: PUSH
19641: LD_INT 43
19643: PUSH
19644: LD_INT 48
19646: PUSH
19647: LD_INT 49
19649: PUSH
19650: LD_INT 50
19652: PUSH
19653: LD_INT 51
19655: PUSH
19656: LD_INT 52
19658: PUSH
19659: LD_INT 53
19661: PUSH
19662: LD_INT 54
19664: PUSH
19665: LD_INT 55
19667: PUSH
19668: LD_INT 56
19670: PUSH
19671: LD_INT 60
19673: PUSH
19674: LD_INT 61
19676: PUSH
19677: LD_INT 62
19679: PUSH
19680: LD_INT 66
19682: PUSH
19683: LD_INT 67
19685: PUSH
19686: LD_INT 68
19688: PUSH
19689: LD_INT 81
19691: PUSH
19692: LD_INT 82
19694: PUSH
19695: LD_INT 83
19697: PUSH
19698: LD_INT 84
19700: PUSH
19701: LD_INT 85
19703: PUSH
19704: LD_INT 87
19706: PUSH
19707: LD_INT 88
19709: PUSH
19710: EMPTY
19711: LIST
19712: LIST
19713: LIST
19714: LIST
19715: LIST
19716: LIST
19717: LIST
19718: LIST
19719: LIST
19720: LIST
19721: LIST
19722: LIST
19723: LIST
19724: LIST
19725: LIST
19726: LIST
19727: LIST
19728: LIST
19729: LIST
19730: LIST
19731: LIST
19732: LIST
19733: LIST
19734: LIST
19735: LIST
19736: LIST
19737: LIST
19738: LIST
19739: LIST
19740: LIST
19741: LIST
19742: LIST
19743: LIST
19744: LIST
19745: LIST
19746: LIST
19747: LIST
19748: LIST
19749: LIST
19750: LIST
19751: LIST
19752: LIST
19753: LIST
19754: LIST
19755: LIST
19756: LIST
19757: LIST
19758: LIST
19759: LIST
19760: LIST
19761: LIST
19762: LIST
19763: LIST
19764: LIST
19765: ST_TO_ADDR
19766: GO 19999
19768: LD_INT 3
19770: DOUBLE
19771: EQUAL
19772: IFTRUE 19776
19774: GO 19998
19776: POP
// result := [ 46 , 47 , 1 , 2 , 82 , 83 , 84 , 85 , 86 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 , 82 , 83 , 84 , 85 , 86 ] ; end ;
19777: LD_ADDR_VAR 0 4
19781: PUSH
19782: LD_INT 46
19784: PUSH
19785: LD_INT 47
19787: PUSH
19788: LD_INT 1
19790: PUSH
19791: LD_INT 2
19793: PUSH
19794: LD_INT 82
19796: PUSH
19797: LD_INT 83
19799: PUSH
19800: LD_INT 84
19802: PUSH
19803: LD_INT 85
19805: PUSH
19806: LD_INT 86
19808: PUSH
19809: LD_INT 11
19811: PUSH
19812: LD_INT 9
19814: PUSH
19815: LD_INT 20
19817: PUSH
19818: LD_INT 19
19820: PUSH
19821: LD_INT 21
19823: PUSH
19824: LD_INT 24
19826: PUSH
19827: LD_INT 22
19829: PUSH
19830: LD_INT 25
19832: PUSH
19833: LD_INT 28
19835: PUSH
19836: LD_INT 29
19838: PUSH
19839: LD_INT 30
19841: PUSH
19842: LD_INT 31
19844: PUSH
19845: LD_INT 37
19847: PUSH
19848: LD_INT 38
19850: PUSH
19851: LD_INT 32
19853: PUSH
19854: LD_INT 27
19856: PUSH
19857: LD_INT 33
19859: PUSH
19860: LD_INT 69
19862: PUSH
19863: LD_INT 39
19865: PUSH
19866: LD_INT 34
19868: PUSH
19869: LD_INT 40
19871: PUSH
19872: LD_INT 71
19874: PUSH
19875: LD_INT 23
19877: PUSH
19878: LD_INT 44
19880: PUSH
19881: LD_INT 48
19883: PUSH
19884: LD_INT 49
19886: PUSH
19887: LD_INT 50
19889: PUSH
19890: LD_INT 51
19892: PUSH
19893: LD_INT 52
19895: PUSH
19896: LD_INT 53
19898: PUSH
19899: LD_INT 54
19901: PUSH
19902: LD_INT 55
19904: PUSH
19905: LD_INT 56
19907: PUSH
19908: LD_INT 57
19910: PUSH
19911: LD_INT 58
19913: PUSH
19914: LD_INT 59
19916: PUSH
19917: LD_INT 63
19919: PUSH
19920: LD_INT 64
19922: PUSH
19923: LD_INT 65
19925: PUSH
19926: LD_INT 82
19928: PUSH
19929: LD_INT 83
19931: PUSH
19932: LD_INT 84
19934: PUSH
19935: LD_INT 85
19937: PUSH
19938: LD_INT 86
19940: PUSH
19941: EMPTY
19942: LIST
19943: LIST
19944: LIST
19945: LIST
19946: LIST
19947: LIST
19948: LIST
19949: LIST
19950: LIST
19951: LIST
19952: LIST
19953: LIST
19954: LIST
19955: LIST
19956: LIST
19957: LIST
19958: LIST
19959: LIST
19960: LIST
19961: LIST
19962: LIST
19963: LIST
19964: LIST
19965: LIST
19966: LIST
19967: LIST
19968: LIST
19969: LIST
19970: LIST
19971: LIST
19972: LIST
19973: LIST
19974: LIST
19975: LIST
19976: LIST
19977: LIST
19978: LIST
19979: LIST
19980: LIST
19981: LIST
19982: LIST
19983: LIST
19984: LIST
19985: LIST
19986: LIST
19987: LIST
19988: LIST
19989: LIST
19990: LIST
19991: LIST
19992: LIST
19993: LIST
19994: LIST
19995: ST_TO_ADDR
19996: GO 19999
19998: POP
// if state > - 1 and state < 3 then
19999: LD_VAR 0 3
20003: PUSH
20004: LD_INT 1
20006: NEG
20007: GREATER
20008: PUSH
20009: LD_VAR 0 3
20013: PUSH
20014: LD_INT 3
20016: LESS
20017: AND
20018: IFFALSE 20075
// for i in result do
20020: LD_ADDR_VAR 0 5
20024: PUSH
20025: LD_VAR 0 4
20029: PUSH
20030: FOR_IN
20031: IFFALSE 20073
// if GetTech ( i , side ) <> state then
20033: LD_VAR 0 5
20037: PPUSH
20038: LD_VAR 0 1
20042: PPUSH
20043: CALL_OW 321
20047: PUSH
20048: LD_VAR 0 3
20052: NONEQUAL
20053: IFFALSE 20071
// result := result diff i ;
20055: LD_ADDR_VAR 0 4
20059: PUSH
20060: LD_VAR 0 4
20064: PUSH
20065: LD_VAR 0 5
20069: DIFF
20070: ST_TO_ADDR
20071: GO 20030
20073: POP
20074: POP
// end ;
20075: LD_VAR 0 4
20079: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
20080: LD_INT 0
20082: PPUSH
20083: PPUSH
20084: PPUSH
// result := true ;
20085: LD_ADDR_VAR 0 3
20089: PUSH
20090: LD_INT 1
20092: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
20093: LD_ADDR_VAR 0 5
20097: PUSH
20098: LD_VAR 0 2
20102: PPUSH
20103: CALL_OW 480
20107: ST_TO_ADDR
// if not tmp then
20108: LD_VAR 0 5
20112: NOT
20113: IFFALSE 20117
// exit ;
20115: GO 20166
// for i in tmp do
20117: LD_ADDR_VAR 0 4
20121: PUSH
20122: LD_VAR 0 5
20126: PUSH
20127: FOR_IN
20128: IFFALSE 20164
// if GetTech ( i , side ) <> state_researched then
20130: LD_VAR 0 4
20134: PPUSH
20135: LD_VAR 0 1
20139: PPUSH
20140: CALL_OW 321
20144: PUSH
20145: LD_INT 2
20147: NONEQUAL
20148: IFFALSE 20162
// begin result := false ;
20150: LD_ADDR_VAR 0 3
20154: PUSH
20155: LD_INT 0
20157: ST_TO_ADDR
// exit ;
20158: POP
20159: POP
20160: GO 20166
// end ;
20162: GO 20127
20164: POP
20165: POP
// end ;
20166: LD_VAR 0 3
20170: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
20171: LD_INT 0
20173: PPUSH
20174: PPUSH
20175: PPUSH
20176: PPUSH
20177: PPUSH
20178: PPUSH
20179: PPUSH
20180: PPUSH
20181: PPUSH
20182: PPUSH
20183: PPUSH
20184: PPUSH
20185: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
20186: LD_VAR 0 1
20190: NOT
20191: PUSH
20192: LD_VAR 0 1
20196: PPUSH
20197: CALL_OW 257
20201: PUSH
20202: LD_INT 9
20204: NONEQUAL
20205: OR
20206: IFFALSE 20210
// exit ;
20208: GO 20783
// side := GetSide ( unit ) ;
20210: LD_ADDR_VAR 0 9
20214: PUSH
20215: LD_VAR 0 1
20219: PPUSH
20220: CALL_OW 255
20224: ST_TO_ADDR
// tech_space := tech_spacanom ;
20225: LD_ADDR_VAR 0 12
20229: PUSH
20230: LD_INT 29
20232: ST_TO_ADDR
// tech_time := tech_taurad ;
20233: LD_ADDR_VAR 0 13
20237: PUSH
20238: LD_INT 28
20240: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
20241: LD_ADDR_VAR 0 11
20245: PUSH
20246: LD_VAR 0 1
20250: PPUSH
20251: CALL_OW 310
20255: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
20256: LD_VAR 0 11
20260: PPUSH
20261: CALL_OW 247
20265: PUSH
20266: LD_INT 2
20268: EQUAL
20269: IFFALSE 20273
// exit ;
20271: GO 20783
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
20273: LD_ADDR_VAR 0 8
20277: PUSH
20278: LD_INT 81
20280: PUSH
20281: LD_VAR 0 9
20285: PUSH
20286: EMPTY
20287: LIST
20288: LIST
20289: PUSH
20290: LD_INT 3
20292: PUSH
20293: LD_INT 21
20295: PUSH
20296: LD_INT 3
20298: PUSH
20299: EMPTY
20300: LIST
20301: LIST
20302: PUSH
20303: EMPTY
20304: LIST
20305: LIST
20306: PUSH
20307: EMPTY
20308: LIST
20309: LIST
20310: PPUSH
20311: CALL_OW 69
20315: ST_TO_ADDR
// if not tmp then
20316: LD_VAR 0 8
20320: NOT
20321: IFFALSE 20325
// exit ;
20323: GO 20783
// if in_unit then
20325: LD_VAR 0 11
20329: IFFALSE 20353
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
20331: LD_ADDR_VAR 0 10
20335: PUSH
20336: LD_VAR 0 8
20340: PPUSH
20341: LD_VAR 0 11
20345: PPUSH
20346: CALL_OW 74
20350: ST_TO_ADDR
20351: GO 20373
// enemy := NearestUnitToUnit ( tmp , unit ) ;
20353: LD_ADDR_VAR 0 10
20357: PUSH
20358: LD_VAR 0 8
20362: PPUSH
20363: LD_VAR 0 1
20367: PPUSH
20368: CALL_OW 74
20372: ST_TO_ADDR
// if not enemy then
20373: LD_VAR 0 10
20377: NOT
20378: IFFALSE 20382
// exit ;
20380: GO 20783
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
20382: LD_VAR 0 11
20386: PUSH
20387: LD_VAR 0 11
20391: PPUSH
20392: LD_VAR 0 10
20396: PPUSH
20397: CALL_OW 296
20401: PUSH
20402: LD_INT 13
20404: GREATER
20405: AND
20406: PUSH
20407: LD_VAR 0 1
20411: PPUSH
20412: LD_VAR 0 10
20416: PPUSH
20417: CALL_OW 296
20421: PUSH
20422: LD_INT 12
20424: GREATER
20425: OR
20426: IFFALSE 20430
// exit ;
20428: GO 20783
// missile := [ 1 ] ;
20430: LD_ADDR_VAR 0 14
20434: PUSH
20435: LD_INT 1
20437: PUSH
20438: EMPTY
20439: LIST
20440: ST_TO_ADDR
// if Researched ( side , tech_space ) then
20441: LD_VAR 0 9
20445: PPUSH
20446: LD_VAR 0 12
20450: PPUSH
20451: CALL_OW 325
20455: IFFALSE 20484
// missile := Replace ( missile , missile + 1 , 2 ) ;
20457: LD_ADDR_VAR 0 14
20461: PUSH
20462: LD_VAR 0 14
20466: PPUSH
20467: LD_VAR 0 14
20471: PUSH
20472: LD_INT 1
20474: PLUS
20475: PPUSH
20476: LD_INT 2
20478: PPUSH
20479: CALL_OW 1
20483: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
20484: LD_VAR 0 9
20488: PPUSH
20489: LD_VAR 0 13
20493: PPUSH
20494: CALL_OW 325
20498: PUSH
20499: LD_VAR 0 10
20503: PPUSH
20504: CALL_OW 255
20508: PPUSH
20509: LD_VAR 0 13
20513: PPUSH
20514: CALL_OW 325
20518: NOT
20519: AND
20520: IFFALSE 20549
// missile := Replace ( missile , missile + 1 , 3 ) ;
20522: LD_ADDR_VAR 0 14
20526: PUSH
20527: LD_VAR 0 14
20531: PPUSH
20532: LD_VAR 0 14
20536: PUSH
20537: LD_INT 1
20539: PLUS
20540: PPUSH
20541: LD_INT 3
20543: PPUSH
20544: CALL_OW 1
20548: ST_TO_ADDR
// if missile < 2 then
20549: LD_VAR 0 14
20553: PUSH
20554: LD_INT 2
20556: LESS
20557: IFFALSE 20561
// exit ;
20559: GO 20783
// x := GetX ( enemy ) ;
20561: LD_ADDR_VAR 0 4
20565: PUSH
20566: LD_VAR 0 10
20570: PPUSH
20571: CALL_OW 250
20575: ST_TO_ADDR
// y := GetY ( enemy ) ;
20576: LD_ADDR_VAR 0 5
20580: PUSH
20581: LD_VAR 0 10
20585: PPUSH
20586: CALL_OW 251
20590: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
20591: LD_ADDR_VAR 0 6
20595: PUSH
20596: LD_VAR 0 4
20600: PUSH
20601: LD_INT 1
20603: NEG
20604: PPUSH
20605: LD_INT 1
20607: PPUSH
20608: CALL_OW 12
20612: PLUS
20613: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
20614: LD_ADDR_VAR 0 7
20618: PUSH
20619: LD_VAR 0 5
20623: PUSH
20624: LD_INT 1
20626: NEG
20627: PPUSH
20628: LD_INT 1
20630: PPUSH
20631: CALL_OW 12
20635: PLUS
20636: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
20637: LD_VAR 0 6
20641: PPUSH
20642: LD_VAR 0 7
20646: PPUSH
20647: CALL_OW 488
20651: NOT
20652: IFFALSE 20674
// begin _x := x ;
20654: LD_ADDR_VAR 0 6
20658: PUSH
20659: LD_VAR 0 4
20663: ST_TO_ADDR
// _y := y ;
20664: LD_ADDR_VAR 0 7
20668: PUSH
20669: LD_VAR 0 5
20673: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
20674: LD_ADDR_VAR 0 3
20678: PUSH
20679: LD_INT 1
20681: PPUSH
20682: LD_VAR 0 14
20686: PPUSH
20687: CALL_OW 12
20691: ST_TO_ADDR
// case i of 1 :
20692: LD_VAR 0 3
20696: PUSH
20697: LD_INT 1
20699: DOUBLE
20700: EQUAL
20701: IFTRUE 20705
20703: GO 20722
20705: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
20706: LD_VAR 0 1
20710: PPUSH
20711: LD_VAR 0 10
20715: PPUSH
20716: CALL_OW 115
20720: GO 20783
20722: LD_INT 2
20724: DOUBLE
20725: EQUAL
20726: IFTRUE 20730
20728: GO 20752
20730: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
20731: LD_VAR 0 1
20735: PPUSH
20736: LD_VAR 0 6
20740: PPUSH
20741: LD_VAR 0 7
20745: PPUSH
20746: CALL_OW 153
20750: GO 20783
20752: LD_INT 3
20754: DOUBLE
20755: EQUAL
20756: IFTRUE 20760
20758: GO 20782
20760: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
20761: LD_VAR 0 1
20765: PPUSH
20766: LD_VAR 0 6
20770: PPUSH
20771: LD_VAR 0 7
20775: PPUSH
20776: CALL_OW 154
20780: GO 20783
20782: POP
// end ;
20783: LD_VAR 0 2
20787: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
20788: LD_INT 0
20790: PPUSH
20791: PPUSH
20792: PPUSH
20793: PPUSH
20794: PPUSH
20795: PPUSH
// if not unit or not building then
20796: LD_VAR 0 1
20800: NOT
20801: PUSH
20802: LD_VAR 0 2
20806: NOT
20807: OR
20808: IFFALSE 20812
// exit ;
20810: GO 20970
// x := GetX ( building ) ;
20812: LD_ADDR_VAR 0 5
20816: PUSH
20817: LD_VAR 0 2
20821: PPUSH
20822: CALL_OW 250
20826: ST_TO_ADDR
// y := GetY ( building ) ;
20827: LD_ADDR_VAR 0 6
20831: PUSH
20832: LD_VAR 0 2
20836: PPUSH
20837: CALL_OW 251
20841: ST_TO_ADDR
// for i = 0 to 5 do
20842: LD_ADDR_VAR 0 4
20846: PUSH
20847: DOUBLE
20848: LD_INT 0
20850: DEC
20851: ST_TO_ADDR
20852: LD_INT 5
20854: PUSH
20855: FOR_TO
20856: IFFALSE 20968
// begin _x := ShiftX ( x , i , 3 ) ;
20858: LD_ADDR_VAR 0 7
20862: PUSH
20863: LD_VAR 0 5
20867: PPUSH
20868: LD_VAR 0 4
20872: PPUSH
20873: LD_INT 3
20875: PPUSH
20876: CALL_OW 272
20880: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
20881: LD_ADDR_VAR 0 8
20885: PUSH
20886: LD_VAR 0 6
20890: PPUSH
20891: LD_VAR 0 4
20895: PPUSH
20896: LD_INT 3
20898: PPUSH
20899: CALL_OW 273
20903: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
20904: LD_VAR 0 7
20908: PPUSH
20909: LD_VAR 0 8
20913: PPUSH
20914: CALL_OW 488
20918: NOT
20919: IFFALSE 20923
// continue ;
20921: GO 20855
// if HexInfo ( _x , _y ) = 0 then
20923: LD_VAR 0 7
20927: PPUSH
20928: LD_VAR 0 8
20932: PPUSH
20933: CALL_OW 428
20937: PUSH
20938: LD_INT 0
20940: EQUAL
20941: IFFALSE 20966
// begin ComMoveXY ( unit , _x , _y ) ;
20943: LD_VAR 0 1
20947: PPUSH
20948: LD_VAR 0 7
20952: PPUSH
20953: LD_VAR 0 8
20957: PPUSH
20958: CALL_OW 111
// exit ;
20962: POP
20963: POP
20964: GO 20970
// end ; end ;
20966: GO 20855
20968: POP
20969: POP
// end ;
20970: LD_VAR 0 3
20974: RET
// export function ScanBase ( side , base_area ) ; begin
20975: LD_INT 0
20977: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
20978: LD_ADDR_VAR 0 3
20982: PUSH
20983: LD_VAR 0 2
20987: PPUSH
20988: LD_INT 81
20990: PUSH
20991: LD_VAR 0 1
20995: PUSH
20996: EMPTY
20997: LIST
20998: LIST
20999: PPUSH
21000: CALL_OW 70
21004: ST_TO_ADDR
// end ;
21005: LD_VAR 0 3
21009: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
21010: LD_INT 0
21012: PPUSH
21013: PPUSH
21014: PPUSH
21015: PPUSH
// result := false ;
21016: LD_ADDR_VAR 0 2
21020: PUSH
21021: LD_INT 0
21023: ST_TO_ADDR
// side := GetSide ( unit ) ;
21024: LD_ADDR_VAR 0 3
21028: PUSH
21029: LD_VAR 0 1
21033: PPUSH
21034: CALL_OW 255
21038: ST_TO_ADDR
// nat := GetNation ( unit ) ;
21039: LD_ADDR_VAR 0 4
21043: PUSH
21044: LD_VAR 0 1
21048: PPUSH
21049: CALL_OW 248
21053: ST_TO_ADDR
// case nat of 1 :
21054: LD_VAR 0 4
21058: PUSH
21059: LD_INT 1
21061: DOUBLE
21062: EQUAL
21063: IFTRUE 21067
21065: GO 21078
21067: POP
// tech := tech_lassight ; 2 :
21068: LD_ADDR_VAR 0 5
21072: PUSH
21073: LD_INT 12
21075: ST_TO_ADDR
21076: GO 21117
21078: LD_INT 2
21080: DOUBLE
21081: EQUAL
21082: IFTRUE 21086
21084: GO 21097
21086: POP
// tech := tech_mortar ; 3 :
21087: LD_ADDR_VAR 0 5
21091: PUSH
21092: LD_INT 41
21094: ST_TO_ADDR
21095: GO 21117
21097: LD_INT 3
21099: DOUBLE
21100: EQUAL
21101: IFTRUE 21105
21103: GO 21116
21105: POP
// tech := tech_bazooka ; end ;
21106: LD_ADDR_VAR 0 5
21110: PUSH
21111: LD_INT 44
21113: ST_TO_ADDR
21114: GO 21117
21116: POP
// if Researched ( side , tech ) then
21117: LD_VAR 0 3
21121: PPUSH
21122: LD_VAR 0 5
21126: PPUSH
21127: CALL_OW 325
21131: IFFALSE 21158
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
21133: LD_ADDR_VAR 0 2
21137: PUSH
21138: LD_INT 5
21140: PUSH
21141: LD_INT 8
21143: PUSH
21144: LD_INT 9
21146: PUSH
21147: EMPTY
21148: LIST
21149: LIST
21150: LIST
21151: PUSH
21152: LD_VAR 0 4
21156: ARRAY
21157: ST_TO_ADDR
// end ;
21158: LD_VAR 0 2
21162: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
21163: LD_INT 0
21165: PPUSH
21166: PPUSH
21167: PPUSH
// if not mines then
21168: LD_VAR 0 2
21172: NOT
21173: IFFALSE 21177
// exit ;
21175: GO 21321
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
21177: LD_ADDR_VAR 0 5
21181: PUSH
21182: LD_INT 81
21184: PUSH
21185: LD_VAR 0 1
21189: PUSH
21190: EMPTY
21191: LIST
21192: LIST
21193: PUSH
21194: LD_INT 3
21196: PUSH
21197: LD_INT 21
21199: PUSH
21200: LD_INT 3
21202: PUSH
21203: EMPTY
21204: LIST
21205: LIST
21206: PUSH
21207: EMPTY
21208: LIST
21209: LIST
21210: PUSH
21211: EMPTY
21212: LIST
21213: LIST
21214: PPUSH
21215: CALL_OW 69
21219: ST_TO_ADDR
// for i in mines do
21220: LD_ADDR_VAR 0 4
21224: PUSH
21225: LD_VAR 0 2
21229: PUSH
21230: FOR_IN
21231: IFFALSE 21319
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
21233: LD_VAR 0 4
21237: PUSH
21238: LD_INT 1
21240: ARRAY
21241: PPUSH
21242: LD_VAR 0 4
21246: PUSH
21247: LD_INT 2
21249: ARRAY
21250: PPUSH
21251: CALL_OW 458
21255: NOT
21256: IFFALSE 21260
// continue ;
21258: GO 21230
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
21260: LD_VAR 0 4
21264: PUSH
21265: LD_INT 1
21267: ARRAY
21268: PPUSH
21269: LD_VAR 0 4
21273: PUSH
21274: LD_INT 2
21276: ARRAY
21277: PPUSH
21278: CALL_OW 428
21282: PUSH
21283: LD_VAR 0 5
21287: IN
21288: IFFALSE 21317
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
21290: LD_VAR 0 4
21294: PUSH
21295: LD_INT 1
21297: ARRAY
21298: PPUSH
21299: LD_VAR 0 4
21303: PUSH
21304: LD_INT 2
21306: ARRAY
21307: PPUSH
21308: LD_VAR 0 1
21312: PPUSH
21313: CALL_OW 456
// end ;
21317: GO 21230
21319: POP
21320: POP
// end ;
21321: LD_VAR 0 3
21325: RET
// export function Count ( array ) ; var i ; begin
21326: LD_INT 0
21328: PPUSH
21329: PPUSH
// result := 0 ;
21330: LD_ADDR_VAR 0 2
21334: PUSH
21335: LD_INT 0
21337: ST_TO_ADDR
// for i in array do
21338: LD_ADDR_VAR 0 3
21342: PUSH
21343: LD_VAR 0 1
21347: PUSH
21348: FOR_IN
21349: IFFALSE 21373
// if i then
21351: LD_VAR 0 3
21355: IFFALSE 21371
// result := result + 1 ;
21357: LD_ADDR_VAR 0 2
21361: PUSH
21362: LD_VAR 0 2
21366: PUSH
21367: LD_INT 1
21369: PLUS
21370: ST_TO_ADDR
21371: GO 21348
21373: POP
21374: POP
// end ;
21375: LD_VAR 0 2
21379: RET
// export function IsEmpty ( building ) ; begin
21380: LD_INT 0
21382: PPUSH
// if not building then
21383: LD_VAR 0 1
21387: NOT
21388: IFFALSE 21392
// exit ;
21390: GO 21435
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
21392: LD_ADDR_VAR 0 2
21396: PUSH
21397: LD_VAR 0 1
21401: PUSH
21402: LD_INT 22
21404: PUSH
21405: LD_VAR 0 1
21409: PPUSH
21410: CALL_OW 255
21414: PUSH
21415: EMPTY
21416: LIST
21417: LIST
21418: PUSH
21419: LD_INT 58
21421: PUSH
21422: EMPTY
21423: LIST
21424: PUSH
21425: EMPTY
21426: LIST
21427: LIST
21428: PPUSH
21429: CALL_OW 69
21433: IN
21434: ST_TO_ADDR
// end ;
21435: LD_VAR 0 2
21439: RET
// export function IsNotFull ( building ) ; var places ; begin
21440: LD_INT 0
21442: PPUSH
21443: PPUSH
// if not building then
21444: LD_VAR 0 1
21448: NOT
21449: IFFALSE 21453
// exit ;
21451: GO 21624
// result := false ;
21453: LD_ADDR_VAR 0 2
21457: PUSH
21458: LD_INT 0
21460: ST_TO_ADDR
// places := 0 ;
21461: LD_ADDR_VAR 0 3
21465: PUSH
21466: LD_INT 0
21468: ST_TO_ADDR
// case GetBType ( building ) of b_depot , b_warehouse , b_lab , b_lab_half , b_lab_full , b_armoury , b_barracks , b_workshop , b_factory , b_fort :
21469: LD_VAR 0 1
21473: PPUSH
21474: CALL_OW 266
21478: PUSH
21479: LD_INT 0
21481: DOUBLE
21482: EQUAL
21483: IFTRUE 21541
21485: LD_INT 1
21487: DOUBLE
21488: EQUAL
21489: IFTRUE 21541
21491: LD_INT 6
21493: DOUBLE
21494: EQUAL
21495: IFTRUE 21541
21497: LD_INT 7
21499: DOUBLE
21500: EQUAL
21501: IFTRUE 21541
21503: LD_INT 8
21505: DOUBLE
21506: EQUAL
21507: IFTRUE 21541
21509: LD_INT 4
21511: DOUBLE
21512: EQUAL
21513: IFTRUE 21541
21515: LD_INT 5
21517: DOUBLE
21518: EQUAL
21519: IFTRUE 21541
21521: LD_INT 2
21523: DOUBLE
21524: EQUAL
21525: IFTRUE 21541
21527: LD_INT 3
21529: DOUBLE
21530: EQUAL
21531: IFTRUE 21541
21533: LD_INT 35
21535: DOUBLE
21536: EQUAL
21537: IFTRUE 21541
21539: GO 21552
21541: POP
// places := 6 ; b_bunker , b_breastwork :
21542: LD_ADDR_VAR 0 3
21546: PUSH
21547: LD_INT 6
21549: ST_TO_ADDR
21550: GO 21597
21552: LD_INT 32
21554: DOUBLE
21555: EQUAL
21556: IFTRUE 21566
21558: LD_INT 31
21560: DOUBLE
21561: EQUAL
21562: IFTRUE 21566
21564: GO 21577
21566: POP
// places := 1 ; b_control_tower :
21567: LD_ADDR_VAR 0 3
21571: PUSH
21572: LD_INT 1
21574: ST_TO_ADDR
21575: GO 21597
21577: LD_INT 36
21579: DOUBLE
21580: EQUAL
21581: IFTRUE 21585
21583: GO 21596
21585: POP
// places := 3 ; end ;
21586: LD_ADDR_VAR 0 3
21590: PUSH
21591: LD_INT 3
21593: ST_TO_ADDR
21594: GO 21597
21596: POP
// if places then
21597: LD_VAR 0 3
21601: IFFALSE 21624
// result := UnitsInside ( building ) < places ;
21603: LD_ADDR_VAR 0 2
21607: PUSH
21608: LD_VAR 0 1
21612: PPUSH
21613: CALL_OW 313
21617: PUSH
21618: LD_VAR 0 3
21622: LESS
21623: ST_TO_ADDR
// end ;
21624: LD_VAR 0 2
21628: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
21629: LD_INT 0
21631: PPUSH
21632: PPUSH
21633: PPUSH
21634: PPUSH
// tmp := [ ] ;
21635: LD_ADDR_VAR 0 3
21639: PUSH
21640: EMPTY
21641: ST_TO_ADDR
// list := [ ] ;
21642: LD_ADDR_VAR 0 5
21646: PUSH
21647: EMPTY
21648: ST_TO_ADDR
// for i = 16 to 25 do
21649: LD_ADDR_VAR 0 4
21653: PUSH
21654: DOUBLE
21655: LD_INT 16
21657: DEC
21658: ST_TO_ADDR
21659: LD_INT 25
21661: PUSH
21662: FOR_TO
21663: IFFALSE 21736
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
21665: LD_ADDR_VAR 0 3
21669: PUSH
21670: LD_VAR 0 3
21674: PUSH
21675: LD_INT 22
21677: PUSH
21678: LD_VAR 0 1
21682: PPUSH
21683: CALL_OW 255
21687: PUSH
21688: EMPTY
21689: LIST
21690: LIST
21691: PUSH
21692: LD_INT 91
21694: PUSH
21695: LD_VAR 0 1
21699: PUSH
21700: LD_INT 6
21702: PUSH
21703: EMPTY
21704: LIST
21705: LIST
21706: LIST
21707: PUSH
21708: LD_INT 30
21710: PUSH
21711: LD_VAR 0 4
21715: PUSH
21716: EMPTY
21717: LIST
21718: LIST
21719: PUSH
21720: EMPTY
21721: LIST
21722: LIST
21723: LIST
21724: PUSH
21725: EMPTY
21726: LIST
21727: PPUSH
21728: CALL_OW 69
21732: ADD
21733: ST_TO_ADDR
21734: GO 21662
21736: POP
21737: POP
// for i = 1 to tmp do
21738: LD_ADDR_VAR 0 4
21742: PUSH
21743: DOUBLE
21744: LD_INT 1
21746: DEC
21747: ST_TO_ADDR
21748: LD_VAR 0 3
21752: PUSH
21753: FOR_TO
21754: IFFALSE 21842
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
21756: LD_ADDR_VAR 0 5
21760: PUSH
21761: LD_VAR 0 5
21765: PUSH
21766: LD_VAR 0 3
21770: PUSH
21771: LD_VAR 0 4
21775: ARRAY
21776: PPUSH
21777: CALL_OW 266
21781: PUSH
21782: LD_VAR 0 3
21786: PUSH
21787: LD_VAR 0 4
21791: ARRAY
21792: PPUSH
21793: CALL_OW 250
21797: PUSH
21798: LD_VAR 0 3
21802: PUSH
21803: LD_VAR 0 4
21807: ARRAY
21808: PPUSH
21809: CALL_OW 251
21813: PUSH
21814: LD_VAR 0 3
21818: PUSH
21819: LD_VAR 0 4
21823: ARRAY
21824: PPUSH
21825: CALL_OW 254
21829: PUSH
21830: EMPTY
21831: LIST
21832: LIST
21833: LIST
21834: LIST
21835: PUSH
21836: EMPTY
21837: LIST
21838: ADD
21839: ST_TO_ADDR
21840: GO 21753
21842: POP
21843: POP
// result := list ;
21844: LD_ADDR_VAR 0 2
21848: PUSH
21849: LD_VAR 0 5
21853: ST_TO_ADDR
// end ;
21854: LD_VAR 0 2
21858: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
21859: LD_INT 0
21861: PPUSH
21862: PPUSH
21863: PPUSH
21864: PPUSH
21865: PPUSH
21866: PPUSH
21867: PPUSH
// if not factory then
21868: LD_VAR 0 1
21872: NOT
21873: IFFALSE 21877
// exit ;
21875: GO 22470
// if control = control_apeman then
21877: LD_VAR 0 4
21881: PUSH
21882: LD_INT 5
21884: EQUAL
21885: IFFALSE 21994
// begin tmp := UnitsInside ( factory ) ;
21887: LD_ADDR_VAR 0 8
21891: PUSH
21892: LD_VAR 0 1
21896: PPUSH
21897: CALL_OW 313
21901: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
21902: LD_VAR 0 8
21906: PPUSH
21907: LD_INT 25
21909: PUSH
21910: LD_INT 12
21912: PUSH
21913: EMPTY
21914: LIST
21915: LIST
21916: PPUSH
21917: CALL_OW 72
21921: NOT
21922: IFFALSE 21932
// control := control_manual ;
21924: LD_ADDR_VAR 0 4
21928: PUSH
21929: LD_INT 1
21931: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
21932: LD_ADDR_VAR 0 8
21936: PUSH
21937: LD_VAR 0 1
21941: PPUSH
21942: CALL 21629 0 1
21946: ST_TO_ADDR
// if tmp then
21947: LD_VAR 0 8
21951: IFFALSE 21994
// begin for i in tmp do
21953: LD_ADDR_VAR 0 7
21957: PUSH
21958: LD_VAR 0 8
21962: PUSH
21963: FOR_IN
21964: IFFALSE 21992
// if i [ 1 ] = b_ext_radio then
21966: LD_VAR 0 7
21970: PUSH
21971: LD_INT 1
21973: ARRAY
21974: PUSH
21975: LD_INT 22
21977: EQUAL
21978: IFFALSE 21990
// begin control := control_remote ;
21980: LD_ADDR_VAR 0 4
21984: PUSH
21985: LD_INT 2
21987: ST_TO_ADDR
// break ;
21988: GO 21992
// end ;
21990: GO 21963
21992: POP
21993: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
21994: LD_VAR 0 1
21998: PPUSH
21999: LD_VAR 0 2
22003: PPUSH
22004: LD_VAR 0 3
22008: PPUSH
22009: LD_VAR 0 4
22013: PPUSH
22014: LD_VAR 0 5
22018: PPUSH
22019: CALL_OW 448
22023: IFFALSE 22058
// begin result := [ chassis , engine , control , weapon ] ;
22025: LD_ADDR_VAR 0 6
22029: PUSH
22030: LD_VAR 0 2
22034: PUSH
22035: LD_VAR 0 3
22039: PUSH
22040: LD_VAR 0 4
22044: PUSH
22045: LD_VAR 0 5
22049: PUSH
22050: EMPTY
22051: LIST
22052: LIST
22053: LIST
22054: LIST
22055: ST_TO_ADDR
// exit ;
22056: GO 22470
// end ; _chassis := AvailableChassisList ( factory ) ;
22058: LD_ADDR_VAR 0 9
22062: PUSH
22063: LD_VAR 0 1
22067: PPUSH
22068: CALL_OW 475
22072: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
22073: LD_ADDR_VAR 0 11
22077: PUSH
22078: LD_VAR 0 1
22082: PPUSH
22083: CALL_OW 476
22087: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
22088: LD_ADDR_VAR 0 12
22092: PUSH
22093: LD_VAR 0 1
22097: PPUSH
22098: CALL_OW 477
22102: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
22103: LD_ADDR_VAR 0 10
22107: PUSH
22108: LD_VAR 0 1
22112: PPUSH
22113: CALL_OW 478
22117: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
22118: LD_VAR 0 9
22122: NOT
22123: PUSH
22124: LD_VAR 0 11
22128: NOT
22129: OR
22130: PUSH
22131: LD_VAR 0 12
22135: NOT
22136: OR
22137: PUSH
22138: LD_VAR 0 10
22142: NOT
22143: OR
22144: IFFALSE 22179
// begin result := [ chassis , engine , control , weapon ] ;
22146: LD_ADDR_VAR 0 6
22150: PUSH
22151: LD_VAR 0 2
22155: PUSH
22156: LD_VAR 0 3
22160: PUSH
22161: LD_VAR 0 4
22165: PUSH
22166: LD_VAR 0 5
22170: PUSH
22171: EMPTY
22172: LIST
22173: LIST
22174: LIST
22175: LIST
22176: ST_TO_ADDR
// exit ;
22177: GO 22470
// end ; if not chassis in _chassis then
22179: LD_VAR 0 2
22183: PUSH
22184: LD_VAR 0 9
22188: IN
22189: NOT
22190: IFFALSE 22216
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
22192: LD_ADDR_VAR 0 2
22196: PUSH
22197: LD_VAR 0 9
22201: PUSH
22202: LD_INT 1
22204: PPUSH
22205: LD_VAR 0 9
22209: PPUSH
22210: CALL_OW 12
22214: ARRAY
22215: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
22216: LD_VAR 0 2
22220: PPUSH
22221: LD_VAR 0 3
22225: PPUSH
22226: CALL 22475 0 2
22230: NOT
22231: IFFALSE 22290
// repeat engine := _engine [ 1 ] ;
22233: LD_ADDR_VAR 0 3
22237: PUSH
22238: LD_VAR 0 11
22242: PUSH
22243: LD_INT 1
22245: ARRAY
22246: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
22247: LD_ADDR_VAR 0 11
22251: PUSH
22252: LD_VAR 0 11
22256: PPUSH
22257: LD_INT 1
22259: PPUSH
22260: CALL_OW 3
22264: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
22265: LD_VAR 0 2
22269: PPUSH
22270: LD_VAR 0 3
22274: PPUSH
22275: CALL 22475 0 2
22279: PUSH
22280: LD_VAR 0 11
22284: PUSH
22285: EMPTY
22286: EQUAL
22287: OR
22288: IFFALSE 22233
// if not control in _control then
22290: LD_VAR 0 4
22294: PUSH
22295: LD_VAR 0 12
22299: IN
22300: NOT
22301: IFFALSE 22327
// control := _control [ rand ( 1 , _control ) ] ;
22303: LD_ADDR_VAR 0 4
22307: PUSH
22308: LD_VAR 0 12
22312: PUSH
22313: LD_INT 1
22315: PPUSH
22316: LD_VAR 0 12
22320: PPUSH
22321: CALL_OW 12
22325: ARRAY
22326: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
22327: LD_VAR 0 2
22331: PPUSH
22332: LD_VAR 0 5
22336: PPUSH
22337: CALL 22695 0 2
22341: NOT
22342: IFFALSE 22401
// repeat weapon := _weapon [ 1 ] ;
22344: LD_ADDR_VAR 0 5
22348: PUSH
22349: LD_VAR 0 10
22353: PUSH
22354: LD_INT 1
22356: ARRAY
22357: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
22358: LD_ADDR_VAR 0 10
22362: PUSH
22363: LD_VAR 0 10
22367: PPUSH
22368: LD_INT 1
22370: PPUSH
22371: CALL_OW 3
22375: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
22376: LD_VAR 0 2
22380: PPUSH
22381: LD_VAR 0 5
22385: PPUSH
22386: CALL 22695 0 2
22390: PUSH
22391: LD_VAR 0 10
22395: PUSH
22396: EMPTY
22397: EQUAL
22398: OR
22399: IFFALSE 22344
// result := [ ] ;
22401: LD_ADDR_VAR 0 6
22405: PUSH
22406: EMPTY
22407: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
22408: LD_VAR 0 1
22412: PPUSH
22413: LD_VAR 0 2
22417: PPUSH
22418: LD_VAR 0 3
22422: PPUSH
22423: LD_VAR 0 4
22427: PPUSH
22428: LD_VAR 0 5
22432: PPUSH
22433: CALL_OW 448
22437: IFFALSE 22470
// result := [ chassis , engine , control , weapon ] ;
22439: LD_ADDR_VAR 0 6
22443: PUSH
22444: LD_VAR 0 2
22448: PUSH
22449: LD_VAR 0 3
22453: PUSH
22454: LD_VAR 0 4
22458: PUSH
22459: LD_VAR 0 5
22463: PUSH
22464: EMPTY
22465: LIST
22466: LIST
22467: LIST
22468: LIST
22469: ST_TO_ADDR
// end ;
22470: LD_VAR 0 6
22474: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
22475: LD_INT 0
22477: PPUSH
// if not chassis or not engine then
22478: LD_VAR 0 1
22482: NOT
22483: PUSH
22484: LD_VAR 0 2
22488: NOT
22489: OR
22490: IFFALSE 22494
// exit ;
22492: GO 22690
// case engine of engine_solar :
22494: LD_VAR 0 2
22498: PUSH
22499: LD_INT 2
22501: DOUBLE
22502: EQUAL
22503: IFTRUE 22507
22505: GO 22545
22507: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
22508: LD_ADDR_VAR 0 3
22512: PUSH
22513: LD_INT 11
22515: PUSH
22516: LD_INT 12
22518: PUSH
22519: LD_INT 13
22521: PUSH
22522: LD_INT 14
22524: PUSH
22525: LD_INT 1
22527: PUSH
22528: LD_INT 2
22530: PUSH
22531: LD_INT 3
22533: PUSH
22534: EMPTY
22535: LIST
22536: LIST
22537: LIST
22538: LIST
22539: LIST
22540: LIST
22541: LIST
22542: ST_TO_ADDR
22543: GO 22674
22545: LD_INT 1
22547: DOUBLE
22548: EQUAL
22549: IFTRUE 22553
22551: GO 22615
22553: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
22554: LD_ADDR_VAR 0 3
22558: PUSH
22559: LD_INT 11
22561: PUSH
22562: LD_INT 12
22564: PUSH
22565: LD_INT 13
22567: PUSH
22568: LD_INT 14
22570: PUSH
22571: LD_INT 1
22573: PUSH
22574: LD_INT 2
22576: PUSH
22577: LD_INT 3
22579: PUSH
22580: LD_INT 4
22582: PUSH
22583: LD_INT 5
22585: PUSH
22586: LD_INT 21
22588: PUSH
22589: LD_INT 23
22591: PUSH
22592: LD_INT 22
22594: PUSH
22595: LD_INT 24
22597: PUSH
22598: EMPTY
22599: LIST
22600: LIST
22601: LIST
22602: LIST
22603: LIST
22604: LIST
22605: LIST
22606: LIST
22607: LIST
22608: LIST
22609: LIST
22610: LIST
22611: LIST
22612: ST_TO_ADDR
22613: GO 22674
22615: LD_INT 3
22617: DOUBLE
22618: EQUAL
22619: IFTRUE 22623
22621: GO 22673
22623: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
22624: LD_ADDR_VAR 0 3
22628: PUSH
22629: LD_INT 13
22631: PUSH
22632: LD_INT 14
22634: PUSH
22635: LD_INT 2
22637: PUSH
22638: LD_INT 3
22640: PUSH
22641: LD_INT 4
22643: PUSH
22644: LD_INT 5
22646: PUSH
22647: LD_INT 21
22649: PUSH
22650: LD_INT 22
22652: PUSH
22653: LD_INT 23
22655: PUSH
22656: LD_INT 24
22658: PUSH
22659: EMPTY
22660: LIST
22661: LIST
22662: LIST
22663: LIST
22664: LIST
22665: LIST
22666: LIST
22667: LIST
22668: LIST
22669: LIST
22670: ST_TO_ADDR
22671: GO 22674
22673: POP
// result := ( chassis in result ) ;
22674: LD_ADDR_VAR 0 3
22678: PUSH
22679: LD_VAR 0 1
22683: PUSH
22684: LD_VAR 0 3
22688: IN
22689: ST_TO_ADDR
// end ;
22690: LD_VAR 0 3
22694: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
22695: LD_INT 0
22697: PPUSH
// if not chassis or not weapon then
22698: LD_VAR 0 1
22702: NOT
22703: PUSH
22704: LD_VAR 0 2
22708: NOT
22709: OR
22710: IFFALSE 22714
// exit ;
22712: GO 23776
// case weapon of us_machine_gun :
22714: LD_VAR 0 2
22718: PUSH
22719: LD_INT 2
22721: DOUBLE
22722: EQUAL
22723: IFTRUE 22727
22725: GO 22757
22727: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
22728: LD_ADDR_VAR 0 3
22732: PUSH
22733: LD_INT 1
22735: PUSH
22736: LD_INT 2
22738: PUSH
22739: LD_INT 3
22741: PUSH
22742: LD_INT 4
22744: PUSH
22745: LD_INT 5
22747: PUSH
22748: EMPTY
22749: LIST
22750: LIST
22751: LIST
22752: LIST
22753: LIST
22754: ST_TO_ADDR
22755: GO 23760
22757: LD_INT 3
22759: DOUBLE
22760: EQUAL
22761: IFTRUE 22765
22763: GO 22795
22765: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
22766: LD_ADDR_VAR 0 3
22770: PUSH
22771: LD_INT 1
22773: PUSH
22774: LD_INT 2
22776: PUSH
22777: LD_INT 3
22779: PUSH
22780: LD_INT 4
22782: PUSH
22783: LD_INT 5
22785: PUSH
22786: EMPTY
22787: LIST
22788: LIST
22789: LIST
22790: LIST
22791: LIST
22792: ST_TO_ADDR
22793: GO 23760
22795: LD_INT 11
22797: DOUBLE
22798: EQUAL
22799: IFTRUE 22803
22801: GO 22833
22803: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
22804: LD_ADDR_VAR 0 3
22808: PUSH
22809: LD_INT 1
22811: PUSH
22812: LD_INT 2
22814: PUSH
22815: LD_INT 3
22817: PUSH
22818: LD_INT 4
22820: PUSH
22821: LD_INT 5
22823: PUSH
22824: EMPTY
22825: LIST
22826: LIST
22827: LIST
22828: LIST
22829: LIST
22830: ST_TO_ADDR
22831: GO 23760
22833: LD_INT 4
22835: DOUBLE
22836: EQUAL
22837: IFTRUE 22841
22839: GO 22867
22841: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
22842: LD_ADDR_VAR 0 3
22846: PUSH
22847: LD_INT 2
22849: PUSH
22850: LD_INT 3
22852: PUSH
22853: LD_INT 4
22855: PUSH
22856: LD_INT 5
22858: PUSH
22859: EMPTY
22860: LIST
22861: LIST
22862: LIST
22863: LIST
22864: ST_TO_ADDR
22865: GO 23760
22867: LD_INT 5
22869: DOUBLE
22870: EQUAL
22871: IFTRUE 22875
22873: GO 22901
22875: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
22876: LD_ADDR_VAR 0 3
22880: PUSH
22881: LD_INT 2
22883: PUSH
22884: LD_INT 3
22886: PUSH
22887: LD_INT 4
22889: PUSH
22890: LD_INT 5
22892: PUSH
22893: EMPTY
22894: LIST
22895: LIST
22896: LIST
22897: LIST
22898: ST_TO_ADDR
22899: GO 23760
22901: LD_INT 9
22903: DOUBLE
22904: EQUAL
22905: IFTRUE 22909
22907: GO 22935
22909: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
22910: LD_ADDR_VAR 0 3
22914: PUSH
22915: LD_INT 2
22917: PUSH
22918: LD_INT 3
22920: PUSH
22921: LD_INT 4
22923: PUSH
22924: LD_INT 5
22926: PUSH
22927: EMPTY
22928: LIST
22929: LIST
22930: LIST
22931: LIST
22932: ST_TO_ADDR
22933: GO 23760
22935: LD_INT 7
22937: DOUBLE
22938: EQUAL
22939: IFTRUE 22943
22941: GO 22969
22943: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
22944: LD_ADDR_VAR 0 3
22948: PUSH
22949: LD_INT 2
22951: PUSH
22952: LD_INT 3
22954: PUSH
22955: LD_INT 4
22957: PUSH
22958: LD_INT 5
22960: PUSH
22961: EMPTY
22962: LIST
22963: LIST
22964: LIST
22965: LIST
22966: ST_TO_ADDR
22967: GO 23760
22969: LD_INT 12
22971: DOUBLE
22972: EQUAL
22973: IFTRUE 22977
22975: GO 23003
22977: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
22978: LD_ADDR_VAR 0 3
22982: PUSH
22983: LD_INT 2
22985: PUSH
22986: LD_INT 3
22988: PUSH
22989: LD_INT 4
22991: PUSH
22992: LD_INT 5
22994: PUSH
22995: EMPTY
22996: LIST
22997: LIST
22998: LIST
22999: LIST
23000: ST_TO_ADDR
23001: GO 23760
23003: LD_INT 13
23005: DOUBLE
23006: EQUAL
23007: IFTRUE 23011
23009: GO 23037
23011: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
23012: LD_ADDR_VAR 0 3
23016: PUSH
23017: LD_INT 2
23019: PUSH
23020: LD_INT 3
23022: PUSH
23023: LD_INT 4
23025: PUSH
23026: LD_INT 5
23028: PUSH
23029: EMPTY
23030: LIST
23031: LIST
23032: LIST
23033: LIST
23034: ST_TO_ADDR
23035: GO 23760
23037: LD_INT 14
23039: DOUBLE
23040: EQUAL
23041: IFTRUE 23045
23043: GO 23063
23045: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
23046: LD_ADDR_VAR 0 3
23050: PUSH
23051: LD_INT 4
23053: PUSH
23054: LD_INT 5
23056: PUSH
23057: EMPTY
23058: LIST
23059: LIST
23060: ST_TO_ADDR
23061: GO 23760
23063: LD_INT 6
23065: DOUBLE
23066: EQUAL
23067: IFTRUE 23071
23069: GO 23089
23071: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
23072: LD_ADDR_VAR 0 3
23076: PUSH
23077: LD_INT 4
23079: PUSH
23080: LD_INT 5
23082: PUSH
23083: EMPTY
23084: LIST
23085: LIST
23086: ST_TO_ADDR
23087: GO 23760
23089: LD_INT 10
23091: DOUBLE
23092: EQUAL
23093: IFTRUE 23097
23095: GO 23115
23097: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
23098: LD_ADDR_VAR 0 3
23102: PUSH
23103: LD_INT 4
23105: PUSH
23106: LD_INT 5
23108: PUSH
23109: EMPTY
23110: LIST
23111: LIST
23112: ST_TO_ADDR
23113: GO 23760
23115: LD_INT 22
23117: DOUBLE
23118: EQUAL
23119: IFTRUE 23123
23121: GO 23149
23123: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
23124: LD_ADDR_VAR 0 3
23128: PUSH
23129: LD_INT 11
23131: PUSH
23132: LD_INT 12
23134: PUSH
23135: LD_INT 13
23137: PUSH
23138: LD_INT 14
23140: PUSH
23141: EMPTY
23142: LIST
23143: LIST
23144: LIST
23145: LIST
23146: ST_TO_ADDR
23147: GO 23760
23149: LD_INT 23
23151: DOUBLE
23152: EQUAL
23153: IFTRUE 23157
23155: GO 23183
23157: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
23158: LD_ADDR_VAR 0 3
23162: PUSH
23163: LD_INT 11
23165: PUSH
23166: LD_INT 12
23168: PUSH
23169: LD_INT 13
23171: PUSH
23172: LD_INT 14
23174: PUSH
23175: EMPTY
23176: LIST
23177: LIST
23178: LIST
23179: LIST
23180: ST_TO_ADDR
23181: GO 23760
23183: LD_INT 24
23185: DOUBLE
23186: EQUAL
23187: IFTRUE 23191
23189: GO 23217
23191: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
23192: LD_ADDR_VAR 0 3
23196: PUSH
23197: LD_INT 11
23199: PUSH
23200: LD_INT 12
23202: PUSH
23203: LD_INT 13
23205: PUSH
23206: LD_INT 14
23208: PUSH
23209: EMPTY
23210: LIST
23211: LIST
23212: LIST
23213: LIST
23214: ST_TO_ADDR
23215: GO 23760
23217: LD_INT 30
23219: DOUBLE
23220: EQUAL
23221: IFTRUE 23225
23223: GO 23251
23225: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
23226: LD_ADDR_VAR 0 3
23230: PUSH
23231: LD_INT 11
23233: PUSH
23234: LD_INT 12
23236: PUSH
23237: LD_INT 13
23239: PUSH
23240: LD_INT 14
23242: PUSH
23243: EMPTY
23244: LIST
23245: LIST
23246: LIST
23247: LIST
23248: ST_TO_ADDR
23249: GO 23760
23251: LD_INT 25
23253: DOUBLE
23254: EQUAL
23255: IFTRUE 23259
23257: GO 23277
23259: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
23260: LD_ADDR_VAR 0 3
23264: PUSH
23265: LD_INT 13
23267: PUSH
23268: LD_INT 14
23270: PUSH
23271: EMPTY
23272: LIST
23273: LIST
23274: ST_TO_ADDR
23275: GO 23760
23277: LD_INT 27
23279: DOUBLE
23280: EQUAL
23281: IFTRUE 23285
23283: GO 23303
23285: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_mortar :
23286: LD_ADDR_VAR 0 3
23290: PUSH
23291: LD_INT 13
23293: PUSH
23294: LD_INT 14
23296: PUSH
23297: EMPTY
23298: LIST
23299: LIST
23300: ST_TO_ADDR
23301: GO 23760
23303: LD_EXP 163
23307: DOUBLE
23308: EQUAL
23309: IFTRUE 23313
23311: GO 23339
23313: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
23314: LD_ADDR_VAR 0 3
23318: PUSH
23319: LD_INT 11
23321: PUSH
23322: LD_INT 12
23324: PUSH
23325: LD_INT 13
23327: PUSH
23328: LD_INT 14
23330: PUSH
23331: EMPTY
23332: LIST
23333: LIST
23334: LIST
23335: LIST
23336: ST_TO_ADDR
23337: GO 23760
23339: LD_INT 28
23341: DOUBLE
23342: EQUAL
23343: IFTRUE 23347
23345: GO 23365
23347: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
23348: LD_ADDR_VAR 0 3
23352: PUSH
23353: LD_INT 13
23355: PUSH
23356: LD_INT 14
23358: PUSH
23359: EMPTY
23360: LIST
23361: LIST
23362: ST_TO_ADDR
23363: GO 23760
23365: LD_INT 29
23367: DOUBLE
23368: EQUAL
23369: IFTRUE 23373
23371: GO 23391
23373: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
23374: LD_ADDR_VAR 0 3
23378: PUSH
23379: LD_INT 13
23381: PUSH
23382: LD_INT 14
23384: PUSH
23385: EMPTY
23386: LIST
23387: LIST
23388: ST_TO_ADDR
23389: GO 23760
23391: LD_INT 31
23393: DOUBLE
23394: EQUAL
23395: IFTRUE 23399
23397: GO 23417
23399: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
23400: LD_ADDR_VAR 0 3
23404: PUSH
23405: LD_INT 13
23407: PUSH
23408: LD_INT 14
23410: PUSH
23411: EMPTY
23412: LIST
23413: LIST
23414: ST_TO_ADDR
23415: GO 23760
23417: LD_INT 26
23419: DOUBLE
23420: EQUAL
23421: IFTRUE 23425
23423: GO 23443
23425: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
23426: LD_ADDR_VAR 0 3
23430: PUSH
23431: LD_INT 13
23433: PUSH
23434: LD_INT 14
23436: PUSH
23437: EMPTY
23438: LIST
23439: LIST
23440: ST_TO_ADDR
23441: GO 23760
23443: LD_INT 42
23445: DOUBLE
23446: EQUAL
23447: IFTRUE 23451
23449: GO 23477
23451: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
23452: LD_ADDR_VAR 0 3
23456: PUSH
23457: LD_INT 21
23459: PUSH
23460: LD_INT 22
23462: PUSH
23463: LD_INT 23
23465: PUSH
23466: LD_INT 24
23468: PUSH
23469: EMPTY
23470: LIST
23471: LIST
23472: LIST
23473: LIST
23474: ST_TO_ADDR
23475: GO 23760
23477: LD_INT 43
23479: DOUBLE
23480: EQUAL
23481: IFTRUE 23485
23483: GO 23511
23485: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
23486: LD_ADDR_VAR 0 3
23490: PUSH
23491: LD_INT 21
23493: PUSH
23494: LD_INT 22
23496: PUSH
23497: LD_INT 23
23499: PUSH
23500: LD_INT 24
23502: PUSH
23503: EMPTY
23504: LIST
23505: LIST
23506: LIST
23507: LIST
23508: ST_TO_ADDR
23509: GO 23760
23511: LD_INT 44
23513: DOUBLE
23514: EQUAL
23515: IFTRUE 23519
23517: GO 23545
23519: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
23520: LD_ADDR_VAR 0 3
23524: PUSH
23525: LD_INT 21
23527: PUSH
23528: LD_INT 22
23530: PUSH
23531: LD_INT 23
23533: PUSH
23534: LD_INT 24
23536: PUSH
23537: EMPTY
23538: LIST
23539: LIST
23540: LIST
23541: LIST
23542: ST_TO_ADDR
23543: GO 23760
23545: LD_INT 45
23547: DOUBLE
23548: EQUAL
23549: IFTRUE 23553
23551: GO 23579
23553: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
23554: LD_ADDR_VAR 0 3
23558: PUSH
23559: LD_INT 21
23561: PUSH
23562: LD_INT 22
23564: PUSH
23565: LD_INT 23
23567: PUSH
23568: LD_INT 24
23570: PUSH
23571: EMPTY
23572: LIST
23573: LIST
23574: LIST
23575: LIST
23576: ST_TO_ADDR
23577: GO 23760
23579: LD_INT 49
23581: DOUBLE
23582: EQUAL
23583: IFTRUE 23587
23585: GO 23613
23587: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
23588: LD_ADDR_VAR 0 3
23592: PUSH
23593: LD_INT 21
23595: PUSH
23596: LD_INT 22
23598: PUSH
23599: LD_INT 23
23601: PUSH
23602: LD_INT 24
23604: PUSH
23605: EMPTY
23606: LIST
23607: LIST
23608: LIST
23609: LIST
23610: ST_TO_ADDR
23611: GO 23760
23613: LD_INT 51
23615: DOUBLE
23616: EQUAL
23617: IFTRUE 23621
23619: GO 23647
23621: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
23622: LD_ADDR_VAR 0 3
23626: PUSH
23627: LD_INT 21
23629: PUSH
23630: LD_INT 22
23632: PUSH
23633: LD_INT 23
23635: PUSH
23636: LD_INT 24
23638: PUSH
23639: EMPTY
23640: LIST
23641: LIST
23642: LIST
23643: LIST
23644: ST_TO_ADDR
23645: GO 23760
23647: LD_INT 52
23649: DOUBLE
23650: EQUAL
23651: IFTRUE 23655
23653: GO 23681
23655: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
23656: LD_ADDR_VAR 0 3
23660: PUSH
23661: LD_INT 21
23663: PUSH
23664: LD_INT 22
23666: PUSH
23667: LD_INT 23
23669: PUSH
23670: LD_INT 24
23672: PUSH
23673: EMPTY
23674: LIST
23675: LIST
23676: LIST
23677: LIST
23678: ST_TO_ADDR
23679: GO 23760
23681: LD_INT 53
23683: DOUBLE
23684: EQUAL
23685: IFTRUE 23689
23687: GO 23707
23689: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
23690: LD_ADDR_VAR 0 3
23694: PUSH
23695: LD_INT 23
23697: PUSH
23698: LD_INT 24
23700: PUSH
23701: EMPTY
23702: LIST
23703: LIST
23704: ST_TO_ADDR
23705: GO 23760
23707: LD_INT 46
23709: DOUBLE
23710: EQUAL
23711: IFTRUE 23715
23713: GO 23733
23715: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
23716: LD_ADDR_VAR 0 3
23720: PUSH
23721: LD_INT 23
23723: PUSH
23724: LD_INT 24
23726: PUSH
23727: EMPTY
23728: LIST
23729: LIST
23730: ST_TO_ADDR
23731: GO 23760
23733: LD_INT 47
23735: DOUBLE
23736: EQUAL
23737: IFTRUE 23741
23739: GO 23759
23741: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
23742: LD_ADDR_VAR 0 3
23746: PUSH
23747: LD_INT 23
23749: PUSH
23750: LD_INT 24
23752: PUSH
23753: EMPTY
23754: LIST
23755: LIST
23756: ST_TO_ADDR
23757: GO 23760
23759: POP
// result := ( chassis in result ) ;
23760: LD_ADDR_VAR 0 3
23764: PUSH
23765: LD_VAR 0 1
23769: PUSH
23770: LD_VAR 0 3
23774: IN
23775: ST_TO_ADDR
// end ;
23776: LD_VAR 0 3
23780: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
23781: LD_INT 0
23783: PPUSH
23784: PPUSH
23785: PPUSH
23786: PPUSH
23787: PPUSH
23788: PPUSH
23789: PPUSH
// result := array ;
23790: LD_ADDR_VAR 0 5
23794: PUSH
23795: LD_VAR 0 1
23799: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
23800: LD_VAR 0 1
23804: NOT
23805: PUSH
23806: LD_VAR 0 2
23810: NOT
23811: OR
23812: PUSH
23813: LD_VAR 0 3
23817: NOT
23818: OR
23819: PUSH
23820: LD_VAR 0 2
23824: PUSH
23825: LD_VAR 0 1
23829: GREATER
23830: OR
23831: PUSH
23832: LD_VAR 0 3
23836: PUSH
23837: LD_VAR 0 1
23841: GREATER
23842: OR
23843: IFFALSE 23847
// exit ;
23845: GO 24143
// if direction then
23847: LD_VAR 0 4
23851: IFFALSE 23915
// begin d := 1 ;
23853: LD_ADDR_VAR 0 9
23857: PUSH
23858: LD_INT 1
23860: ST_TO_ADDR
// if i_from > i_to then
23861: LD_VAR 0 2
23865: PUSH
23866: LD_VAR 0 3
23870: GREATER
23871: IFFALSE 23897
// length := ( array - i_from ) + i_to else
23873: LD_ADDR_VAR 0 11
23877: PUSH
23878: LD_VAR 0 1
23882: PUSH
23883: LD_VAR 0 2
23887: MINUS
23888: PUSH
23889: LD_VAR 0 3
23893: PLUS
23894: ST_TO_ADDR
23895: GO 23913
// length := i_to - i_from ;
23897: LD_ADDR_VAR 0 11
23901: PUSH
23902: LD_VAR 0 3
23906: PUSH
23907: LD_VAR 0 2
23911: MINUS
23912: ST_TO_ADDR
// end else
23913: GO 23976
// begin d := - 1 ;
23915: LD_ADDR_VAR 0 9
23919: PUSH
23920: LD_INT 1
23922: NEG
23923: ST_TO_ADDR
// if i_from > i_to then
23924: LD_VAR 0 2
23928: PUSH
23929: LD_VAR 0 3
23933: GREATER
23934: IFFALSE 23954
// length := i_from - i_to else
23936: LD_ADDR_VAR 0 11
23940: PUSH
23941: LD_VAR 0 2
23945: PUSH
23946: LD_VAR 0 3
23950: MINUS
23951: ST_TO_ADDR
23952: GO 23976
// length := ( array - i_to ) + i_from ;
23954: LD_ADDR_VAR 0 11
23958: PUSH
23959: LD_VAR 0 1
23963: PUSH
23964: LD_VAR 0 3
23968: MINUS
23969: PUSH
23970: LD_VAR 0 2
23974: PLUS
23975: ST_TO_ADDR
// end ; if not length then
23976: LD_VAR 0 11
23980: NOT
23981: IFFALSE 23985
// exit ;
23983: GO 24143
// tmp := array ;
23985: LD_ADDR_VAR 0 10
23989: PUSH
23990: LD_VAR 0 1
23994: ST_TO_ADDR
// for i = 1 to length do
23995: LD_ADDR_VAR 0 6
23999: PUSH
24000: DOUBLE
24001: LD_INT 1
24003: DEC
24004: ST_TO_ADDR
24005: LD_VAR 0 11
24009: PUSH
24010: FOR_TO
24011: IFFALSE 24131
// begin for j = 1 to array do
24013: LD_ADDR_VAR 0 7
24017: PUSH
24018: DOUBLE
24019: LD_INT 1
24021: DEC
24022: ST_TO_ADDR
24023: LD_VAR 0 1
24027: PUSH
24028: FOR_TO
24029: IFFALSE 24117
// begin k := j + d ;
24031: LD_ADDR_VAR 0 8
24035: PUSH
24036: LD_VAR 0 7
24040: PUSH
24041: LD_VAR 0 9
24045: PLUS
24046: ST_TO_ADDR
// if k > array then
24047: LD_VAR 0 8
24051: PUSH
24052: LD_VAR 0 1
24056: GREATER
24057: IFFALSE 24067
// k := 1 ;
24059: LD_ADDR_VAR 0 8
24063: PUSH
24064: LD_INT 1
24066: ST_TO_ADDR
// if not k then
24067: LD_VAR 0 8
24071: NOT
24072: IFFALSE 24084
// k := array ;
24074: LD_ADDR_VAR 0 8
24078: PUSH
24079: LD_VAR 0 1
24083: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
24084: LD_ADDR_VAR 0 10
24088: PUSH
24089: LD_VAR 0 10
24093: PPUSH
24094: LD_VAR 0 8
24098: PPUSH
24099: LD_VAR 0 1
24103: PUSH
24104: LD_VAR 0 7
24108: ARRAY
24109: PPUSH
24110: CALL_OW 1
24114: ST_TO_ADDR
// end ;
24115: GO 24028
24117: POP
24118: POP
// array := tmp ;
24119: LD_ADDR_VAR 0 1
24123: PUSH
24124: LD_VAR 0 10
24128: ST_TO_ADDR
// end ;
24129: GO 24010
24131: POP
24132: POP
// result := array ;
24133: LD_ADDR_VAR 0 5
24137: PUSH
24138: LD_VAR 0 1
24142: ST_TO_ADDR
// end ;
24143: LD_VAR 0 5
24147: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
24148: LD_INT 0
24150: PPUSH
24151: PPUSH
// result := 0 ;
24152: LD_ADDR_VAR 0 3
24156: PUSH
24157: LD_INT 0
24159: ST_TO_ADDR
// if not array or not value in array then
24160: LD_VAR 0 1
24164: NOT
24165: PUSH
24166: LD_VAR 0 2
24170: PUSH
24171: LD_VAR 0 1
24175: IN
24176: NOT
24177: OR
24178: IFFALSE 24182
// exit ;
24180: GO 24236
// for i = 1 to array do
24182: LD_ADDR_VAR 0 4
24186: PUSH
24187: DOUBLE
24188: LD_INT 1
24190: DEC
24191: ST_TO_ADDR
24192: LD_VAR 0 1
24196: PUSH
24197: FOR_TO
24198: IFFALSE 24234
// if value = array [ i ] then
24200: LD_VAR 0 2
24204: PUSH
24205: LD_VAR 0 1
24209: PUSH
24210: LD_VAR 0 4
24214: ARRAY
24215: EQUAL
24216: IFFALSE 24232
// begin result := i ;
24218: LD_ADDR_VAR 0 3
24222: PUSH
24223: LD_VAR 0 4
24227: ST_TO_ADDR
// exit ;
24228: POP
24229: POP
24230: GO 24236
// end ;
24232: GO 24197
24234: POP
24235: POP
// end ;
24236: LD_VAR 0 3
24240: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
24241: LD_INT 0
24243: PPUSH
// vc_chassis := chassis ;
24244: LD_ADDR_OWVAR 37
24248: PUSH
24249: LD_VAR 0 1
24253: ST_TO_ADDR
// vc_engine := engine ;
24254: LD_ADDR_OWVAR 39
24258: PUSH
24259: LD_VAR 0 2
24263: ST_TO_ADDR
// vc_control := control ;
24264: LD_ADDR_OWVAR 38
24268: PUSH
24269: LD_VAR 0 3
24273: ST_TO_ADDR
// vc_weapon := weapon ;
24274: LD_ADDR_OWVAR 40
24278: PUSH
24279: LD_VAR 0 4
24283: ST_TO_ADDR
// vc_fuel_battery := fuel ;
24284: LD_ADDR_OWVAR 41
24288: PUSH
24289: LD_VAR 0 5
24293: ST_TO_ADDR
// end ;
24294: LD_VAR 0 6
24298: RET
// export function WantPlant ( unit ) ; var task ; begin
24299: LD_INT 0
24301: PPUSH
24302: PPUSH
// result := false ;
24303: LD_ADDR_VAR 0 2
24307: PUSH
24308: LD_INT 0
24310: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
24311: LD_ADDR_VAR 0 3
24315: PUSH
24316: LD_VAR 0 1
24320: PPUSH
24321: CALL_OW 437
24325: ST_TO_ADDR
// if task then
24326: LD_VAR 0 3
24330: IFFALSE 24358
// if task [ 1 ] [ 1 ] = p then
24332: LD_VAR 0 3
24336: PUSH
24337: LD_INT 1
24339: ARRAY
24340: PUSH
24341: LD_INT 1
24343: ARRAY
24344: PUSH
24345: LD_STRING p
24347: EQUAL
24348: IFFALSE 24358
// result := true ;
24350: LD_ADDR_VAR 0 2
24354: PUSH
24355: LD_INT 1
24357: ST_TO_ADDR
// end ;
24358: LD_VAR 0 2
24362: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
24363: LD_INT 0
24365: PPUSH
24366: PPUSH
24367: PPUSH
24368: PPUSH
// if pos < 1 then
24369: LD_VAR 0 2
24373: PUSH
24374: LD_INT 1
24376: LESS
24377: IFFALSE 24381
// exit ;
24379: GO 24684
// if pos = 1 then
24381: LD_VAR 0 2
24385: PUSH
24386: LD_INT 1
24388: EQUAL
24389: IFFALSE 24422
// result := Replace ( arr , pos [ 1 ] , value ) else
24391: LD_ADDR_VAR 0 4
24395: PUSH
24396: LD_VAR 0 1
24400: PPUSH
24401: LD_VAR 0 2
24405: PUSH
24406: LD_INT 1
24408: ARRAY
24409: PPUSH
24410: LD_VAR 0 3
24414: PPUSH
24415: CALL_OW 1
24419: ST_TO_ADDR
24420: GO 24684
// begin tmp := arr ;
24422: LD_ADDR_VAR 0 6
24426: PUSH
24427: LD_VAR 0 1
24431: ST_TO_ADDR
// s_arr := [ tmp ] ;
24432: LD_ADDR_VAR 0 7
24436: PUSH
24437: LD_VAR 0 6
24441: PUSH
24442: EMPTY
24443: LIST
24444: ST_TO_ADDR
// for i = 1 to pos - 1 do
24445: LD_ADDR_VAR 0 5
24449: PUSH
24450: DOUBLE
24451: LD_INT 1
24453: DEC
24454: ST_TO_ADDR
24455: LD_VAR 0 2
24459: PUSH
24460: LD_INT 1
24462: MINUS
24463: PUSH
24464: FOR_TO
24465: IFFALSE 24510
// begin tmp := tmp [ pos [ i ] ] ;
24467: LD_ADDR_VAR 0 6
24471: PUSH
24472: LD_VAR 0 6
24476: PUSH
24477: LD_VAR 0 2
24481: PUSH
24482: LD_VAR 0 5
24486: ARRAY
24487: ARRAY
24488: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
24489: LD_ADDR_VAR 0 7
24493: PUSH
24494: LD_VAR 0 7
24498: PUSH
24499: LD_VAR 0 6
24503: PUSH
24504: EMPTY
24505: LIST
24506: ADD
24507: ST_TO_ADDR
// end ;
24508: GO 24464
24510: POP
24511: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
24512: LD_ADDR_VAR 0 6
24516: PUSH
24517: LD_VAR 0 6
24521: PPUSH
24522: LD_VAR 0 2
24526: PUSH
24527: LD_VAR 0 2
24531: ARRAY
24532: PPUSH
24533: LD_VAR 0 3
24537: PPUSH
24538: CALL_OW 1
24542: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
24543: LD_ADDR_VAR 0 7
24547: PUSH
24548: LD_VAR 0 7
24552: PPUSH
24553: LD_VAR 0 7
24557: PPUSH
24558: LD_VAR 0 6
24562: PPUSH
24563: CALL_OW 1
24567: ST_TO_ADDR
// for i = s_arr downto 2 do
24568: LD_ADDR_VAR 0 5
24572: PUSH
24573: DOUBLE
24574: LD_VAR 0 7
24578: INC
24579: ST_TO_ADDR
24580: LD_INT 2
24582: PUSH
24583: FOR_DOWNTO
24584: IFFALSE 24668
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
24586: LD_ADDR_VAR 0 6
24590: PUSH
24591: LD_VAR 0 7
24595: PUSH
24596: LD_VAR 0 5
24600: PUSH
24601: LD_INT 1
24603: MINUS
24604: ARRAY
24605: PPUSH
24606: LD_VAR 0 2
24610: PUSH
24611: LD_VAR 0 5
24615: PUSH
24616: LD_INT 1
24618: MINUS
24619: ARRAY
24620: PPUSH
24621: LD_VAR 0 7
24625: PUSH
24626: LD_VAR 0 5
24630: ARRAY
24631: PPUSH
24632: CALL_OW 1
24636: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
24637: LD_ADDR_VAR 0 7
24641: PUSH
24642: LD_VAR 0 7
24646: PPUSH
24647: LD_VAR 0 5
24651: PUSH
24652: LD_INT 1
24654: MINUS
24655: PPUSH
24656: LD_VAR 0 6
24660: PPUSH
24661: CALL_OW 1
24665: ST_TO_ADDR
// end ;
24666: GO 24583
24668: POP
24669: POP
// result := s_arr [ 1 ] ;
24670: LD_ADDR_VAR 0 4
24674: PUSH
24675: LD_VAR 0 7
24679: PUSH
24680: LD_INT 1
24682: ARRAY
24683: ST_TO_ADDR
// end ; end ;
24684: LD_VAR 0 4
24688: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
24689: LD_INT 0
24691: PPUSH
24692: PPUSH
// if not list then
24693: LD_VAR 0 1
24697: NOT
24698: IFFALSE 24702
// exit ;
24700: GO 24793
// i := list [ pos1 ] ;
24702: LD_ADDR_VAR 0 5
24706: PUSH
24707: LD_VAR 0 1
24711: PUSH
24712: LD_VAR 0 2
24716: ARRAY
24717: ST_TO_ADDR
// if not i then
24718: LD_VAR 0 5
24722: NOT
24723: IFFALSE 24727
// exit ;
24725: GO 24793
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
24727: LD_ADDR_VAR 0 1
24731: PUSH
24732: LD_VAR 0 1
24736: PPUSH
24737: LD_VAR 0 2
24741: PPUSH
24742: LD_VAR 0 1
24746: PUSH
24747: LD_VAR 0 3
24751: ARRAY
24752: PPUSH
24753: CALL_OW 1
24757: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
24758: LD_ADDR_VAR 0 1
24762: PUSH
24763: LD_VAR 0 1
24767: PPUSH
24768: LD_VAR 0 3
24772: PPUSH
24773: LD_VAR 0 5
24777: PPUSH
24778: CALL_OW 1
24782: ST_TO_ADDR
// result := list ;
24783: LD_ADDR_VAR 0 4
24787: PUSH
24788: LD_VAR 0 1
24792: ST_TO_ADDR
// end ;
24793: LD_VAR 0 4
24797: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
24798: LD_INT 0
24800: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
24801: LD_ADDR_VAR 0 5
24805: PUSH
24806: LD_VAR 0 1
24810: PPUSH
24811: CALL_OW 250
24815: PPUSH
24816: LD_VAR 0 1
24820: PPUSH
24821: CALL_OW 251
24825: PPUSH
24826: LD_VAR 0 2
24830: PPUSH
24831: LD_VAR 0 3
24835: PPUSH
24836: LD_VAR 0 4
24840: PPUSH
24841: CALL 24851 0 5
24845: ST_TO_ADDR
// end ;
24846: LD_VAR 0 5
24850: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
24851: LD_INT 0
24853: PPUSH
24854: PPUSH
24855: PPUSH
24856: PPUSH
// if not list then
24857: LD_VAR 0 3
24861: NOT
24862: IFFALSE 24866
// exit ;
24864: GO 25254
// result := [ ] ;
24866: LD_ADDR_VAR 0 6
24870: PUSH
24871: EMPTY
24872: ST_TO_ADDR
// for i in list do
24873: LD_ADDR_VAR 0 7
24877: PUSH
24878: LD_VAR 0 3
24882: PUSH
24883: FOR_IN
24884: IFFALSE 25086
// begin tmp := GetDistUnitXY ( i , x , y ) ;
24886: LD_ADDR_VAR 0 9
24890: PUSH
24891: LD_VAR 0 7
24895: PPUSH
24896: LD_VAR 0 1
24900: PPUSH
24901: LD_VAR 0 2
24905: PPUSH
24906: CALL_OW 297
24910: ST_TO_ADDR
// if not result then
24911: LD_VAR 0 6
24915: NOT
24916: IFFALSE 24942
// result := [ [ i , tmp ] ] else
24918: LD_ADDR_VAR 0 6
24922: PUSH
24923: LD_VAR 0 7
24927: PUSH
24928: LD_VAR 0 9
24932: PUSH
24933: EMPTY
24934: LIST
24935: LIST
24936: PUSH
24937: EMPTY
24938: LIST
24939: ST_TO_ADDR
24940: GO 25084
// begin if result [ result ] [ 2 ] < tmp then
24942: LD_VAR 0 6
24946: PUSH
24947: LD_VAR 0 6
24951: ARRAY
24952: PUSH
24953: LD_INT 2
24955: ARRAY
24956: PUSH
24957: LD_VAR 0 9
24961: LESS
24962: IFFALSE 25004
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
24964: LD_ADDR_VAR 0 6
24968: PUSH
24969: LD_VAR 0 6
24973: PPUSH
24974: LD_VAR 0 6
24978: PUSH
24979: LD_INT 1
24981: PLUS
24982: PPUSH
24983: LD_VAR 0 7
24987: PUSH
24988: LD_VAR 0 9
24992: PUSH
24993: EMPTY
24994: LIST
24995: LIST
24996: PPUSH
24997: CALL_OW 2
25001: ST_TO_ADDR
25002: GO 25084
// for j = 1 to result do
25004: LD_ADDR_VAR 0 8
25008: PUSH
25009: DOUBLE
25010: LD_INT 1
25012: DEC
25013: ST_TO_ADDR
25014: LD_VAR 0 6
25018: PUSH
25019: FOR_TO
25020: IFFALSE 25082
// begin if tmp < result [ j ] [ 2 ] then
25022: LD_VAR 0 9
25026: PUSH
25027: LD_VAR 0 6
25031: PUSH
25032: LD_VAR 0 8
25036: ARRAY
25037: PUSH
25038: LD_INT 2
25040: ARRAY
25041: LESS
25042: IFFALSE 25080
// begin result := Insert ( result , j , [ i , tmp ] ) ;
25044: LD_ADDR_VAR 0 6
25048: PUSH
25049: LD_VAR 0 6
25053: PPUSH
25054: LD_VAR 0 8
25058: PPUSH
25059: LD_VAR 0 7
25063: PUSH
25064: LD_VAR 0 9
25068: PUSH
25069: EMPTY
25070: LIST
25071: LIST
25072: PPUSH
25073: CALL_OW 2
25077: ST_TO_ADDR
// break ;
25078: GO 25082
// end ; end ;
25080: GO 25019
25082: POP
25083: POP
// end ; end ;
25084: GO 24883
25086: POP
25087: POP
// if result and not asc then
25088: LD_VAR 0 6
25092: PUSH
25093: LD_VAR 0 4
25097: NOT
25098: AND
25099: IFFALSE 25174
// begin tmp := result ;
25101: LD_ADDR_VAR 0 9
25105: PUSH
25106: LD_VAR 0 6
25110: ST_TO_ADDR
// for i = tmp downto 1 do
25111: LD_ADDR_VAR 0 7
25115: PUSH
25116: DOUBLE
25117: LD_VAR 0 9
25121: INC
25122: ST_TO_ADDR
25123: LD_INT 1
25125: PUSH
25126: FOR_DOWNTO
25127: IFFALSE 25172
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
25129: LD_ADDR_VAR 0 6
25133: PUSH
25134: LD_VAR 0 6
25138: PPUSH
25139: LD_VAR 0 9
25143: PUSH
25144: LD_VAR 0 7
25148: MINUS
25149: PUSH
25150: LD_INT 1
25152: PLUS
25153: PPUSH
25154: LD_VAR 0 9
25158: PUSH
25159: LD_VAR 0 7
25163: ARRAY
25164: PPUSH
25165: CALL_OW 1
25169: ST_TO_ADDR
25170: GO 25126
25172: POP
25173: POP
// end ; tmp := [ ] ;
25174: LD_ADDR_VAR 0 9
25178: PUSH
25179: EMPTY
25180: ST_TO_ADDR
// if mode then
25181: LD_VAR 0 5
25185: IFFALSE 25254
// begin for i = 1 to result do
25187: LD_ADDR_VAR 0 7
25191: PUSH
25192: DOUBLE
25193: LD_INT 1
25195: DEC
25196: ST_TO_ADDR
25197: LD_VAR 0 6
25201: PUSH
25202: FOR_TO
25203: IFFALSE 25242
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
25205: LD_ADDR_VAR 0 9
25209: PUSH
25210: LD_VAR 0 9
25214: PPUSH
25215: LD_VAR 0 7
25219: PPUSH
25220: LD_VAR 0 6
25224: PUSH
25225: LD_VAR 0 7
25229: ARRAY
25230: PUSH
25231: LD_INT 1
25233: ARRAY
25234: PPUSH
25235: CALL_OW 1
25239: ST_TO_ADDR
25240: GO 25202
25242: POP
25243: POP
// result := tmp ;
25244: LD_ADDR_VAR 0 6
25248: PUSH
25249: LD_VAR 0 9
25253: ST_TO_ADDR
// end ; end ;
25254: LD_VAR 0 6
25258: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
25259: LD_INT 0
25261: PPUSH
25262: PPUSH
25263: PPUSH
25264: PPUSH
25265: PPUSH
25266: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
25267: LD_ADDR_VAR 0 5
25271: PUSH
25272: LD_INT 0
25274: PUSH
25275: LD_INT 0
25277: PUSH
25278: LD_INT 0
25280: PUSH
25281: EMPTY
25282: PUSH
25283: EMPTY
25284: LIST
25285: LIST
25286: LIST
25287: LIST
25288: ST_TO_ADDR
// if not x or not y then
25289: LD_VAR 0 2
25293: NOT
25294: PUSH
25295: LD_VAR 0 3
25299: NOT
25300: OR
25301: IFFALSE 25305
// exit ;
25303: GO 26957
// if not range then
25305: LD_VAR 0 4
25309: NOT
25310: IFFALSE 25320
// range := 10 ;
25312: LD_ADDR_VAR 0 4
25316: PUSH
25317: LD_INT 10
25319: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
25320: LD_ADDR_VAR 0 8
25324: PUSH
25325: LD_INT 81
25327: PUSH
25328: LD_VAR 0 1
25332: PUSH
25333: EMPTY
25334: LIST
25335: LIST
25336: PUSH
25337: LD_INT 92
25339: PUSH
25340: LD_VAR 0 2
25344: PUSH
25345: LD_VAR 0 3
25349: PUSH
25350: LD_VAR 0 4
25354: PUSH
25355: EMPTY
25356: LIST
25357: LIST
25358: LIST
25359: LIST
25360: PUSH
25361: LD_INT 3
25363: PUSH
25364: LD_INT 21
25366: PUSH
25367: LD_INT 3
25369: PUSH
25370: EMPTY
25371: LIST
25372: LIST
25373: PUSH
25374: EMPTY
25375: LIST
25376: LIST
25377: PUSH
25378: EMPTY
25379: LIST
25380: LIST
25381: LIST
25382: PPUSH
25383: CALL_OW 69
25387: ST_TO_ADDR
// if not tmp then
25388: LD_VAR 0 8
25392: NOT
25393: IFFALSE 25397
// exit ;
25395: GO 26957
// for i in tmp do
25397: LD_ADDR_VAR 0 6
25401: PUSH
25402: LD_VAR 0 8
25406: PUSH
25407: FOR_IN
25408: IFFALSE 26932
// begin points := [ 0 , 0 , 0 ] ;
25410: LD_ADDR_VAR 0 9
25414: PUSH
25415: LD_INT 0
25417: PUSH
25418: LD_INT 0
25420: PUSH
25421: LD_INT 0
25423: PUSH
25424: EMPTY
25425: LIST
25426: LIST
25427: LIST
25428: ST_TO_ADDR
// bpoints := 1 ;
25429: LD_ADDR_VAR 0 10
25433: PUSH
25434: LD_INT 1
25436: ST_TO_ADDR
// case GetType ( i ) of unit_human :
25437: LD_VAR 0 6
25441: PPUSH
25442: CALL_OW 247
25446: PUSH
25447: LD_INT 1
25449: DOUBLE
25450: EQUAL
25451: IFTRUE 25455
25453: GO 26033
25455: POP
// begin if GetClass ( i ) = 1 then
25456: LD_VAR 0 6
25460: PPUSH
25461: CALL_OW 257
25465: PUSH
25466: LD_INT 1
25468: EQUAL
25469: IFFALSE 25490
// points := [ 10 , 5 , 3 ] ;
25471: LD_ADDR_VAR 0 9
25475: PUSH
25476: LD_INT 10
25478: PUSH
25479: LD_INT 5
25481: PUSH
25482: LD_INT 3
25484: PUSH
25485: EMPTY
25486: LIST
25487: LIST
25488: LIST
25489: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
25490: LD_VAR 0 6
25494: PPUSH
25495: CALL_OW 257
25499: PUSH
25500: LD_INT 2
25502: PUSH
25503: LD_INT 3
25505: PUSH
25506: LD_INT 4
25508: PUSH
25509: EMPTY
25510: LIST
25511: LIST
25512: LIST
25513: IN
25514: IFFALSE 25535
// points := [ 3 , 2 , 1 ] ;
25516: LD_ADDR_VAR 0 9
25520: PUSH
25521: LD_INT 3
25523: PUSH
25524: LD_INT 2
25526: PUSH
25527: LD_INT 1
25529: PUSH
25530: EMPTY
25531: LIST
25532: LIST
25533: LIST
25534: ST_TO_ADDR
// if GetClass ( i ) = 5 then
25535: LD_VAR 0 6
25539: PPUSH
25540: CALL_OW 257
25544: PUSH
25545: LD_INT 5
25547: EQUAL
25548: IFFALSE 25569
// points := [ 130 , 5 , 2 ] ;
25550: LD_ADDR_VAR 0 9
25554: PUSH
25555: LD_INT 130
25557: PUSH
25558: LD_INT 5
25560: PUSH
25561: LD_INT 2
25563: PUSH
25564: EMPTY
25565: LIST
25566: LIST
25567: LIST
25568: ST_TO_ADDR
// if GetClass ( i ) = 8 then
25569: LD_VAR 0 6
25573: PPUSH
25574: CALL_OW 257
25578: PUSH
25579: LD_INT 8
25581: EQUAL
25582: IFFALSE 25603
// points := [ 35 , 35 , 30 ] ;
25584: LD_ADDR_VAR 0 9
25588: PUSH
25589: LD_INT 35
25591: PUSH
25592: LD_INT 35
25594: PUSH
25595: LD_INT 30
25597: PUSH
25598: EMPTY
25599: LIST
25600: LIST
25601: LIST
25602: ST_TO_ADDR
// if GetClass ( i ) = 9 then
25603: LD_VAR 0 6
25607: PPUSH
25608: CALL_OW 257
25612: PUSH
25613: LD_INT 9
25615: EQUAL
25616: IFFALSE 25637
// points := [ 20 , 55 , 40 ] ;
25618: LD_ADDR_VAR 0 9
25622: PUSH
25623: LD_INT 20
25625: PUSH
25626: LD_INT 55
25628: PUSH
25629: LD_INT 40
25631: PUSH
25632: EMPTY
25633: LIST
25634: LIST
25635: LIST
25636: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
25637: LD_VAR 0 6
25641: PPUSH
25642: CALL_OW 257
25646: PUSH
25647: LD_INT 12
25649: PUSH
25650: LD_INT 16
25652: PUSH
25653: EMPTY
25654: LIST
25655: LIST
25656: IN
25657: IFFALSE 25678
// points := [ 5 , 3 , 2 ] ;
25659: LD_ADDR_VAR 0 9
25663: PUSH
25664: LD_INT 5
25666: PUSH
25667: LD_INT 3
25669: PUSH
25670: LD_INT 2
25672: PUSH
25673: EMPTY
25674: LIST
25675: LIST
25676: LIST
25677: ST_TO_ADDR
// if GetClass ( i ) = 17 then
25678: LD_VAR 0 6
25682: PPUSH
25683: CALL_OW 257
25687: PUSH
25688: LD_INT 17
25690: EQUAL
25691: IFFALSE 25712
// points := [ 100 , 50 , 75 ] ;
25693: LD_ADDR_VAR 0 9
25697: PUSH
25698: LD_INT 100
25700: PUSH
25701: LD_INT 50
25703: PUSH
25704: LD_INT 75
25706: PUSH
25707: EMPTY
25708: LIST
25709: LIST
25710: LIST
25711: ST_TO_ADDR
// if GetClass ( i ) = 15 then
25712: LD_VAR 0 6
25716: PPUSH
25717: CALL_OW 257
25721: PUSH
25722: LD_INT 15
25724: EQUAL
25725: IFFALSE 25746
// points := [ 10 , 5 , 3 ] ;
25727: LD_ADDR_VAR 0 9
25731: PUSH
25732: LD_INT 10
25734: PUSH
25735: LD_INT 5
25737: PUSH
25738: LD_INT 3
25740: PUSH
25741: EMPTY
25742: LIST
25743: LIST
25744: LIST
25745: ST_TO_ADDR
// if GetClass ( i ) = 14 then
25746: LD_VAR 0 6
25750: PPUSH
25751: CALL_OW 257
25755: PUSH
25756: LD_INT 14
25758: EQUAL
25759: IFFALSE 25780
// points := [ 10 , 0 , 0 ] ;
25761: LD_ADDR_VAR 0 9
25765: PUSH
25766: LD_INT 10
25768: PUSH
25769: LD_INT 0
25771: PUSH
25772: LD_INT 0
25774: PUSH
25775: EMPTY
25776: LIST
25777: LIST
25778: LIST
25779: ST_TO_ADDR
// if GetClass ( i ) = 11 then
25780: LD_VAR 0 6
25784: PPUSH
25785: CALL_OW 257
25789: PUSH
25790: LD_INT 11
25792: EQUAL
25793: IFFALSE 25814
// points := [ 30 , 10 , 5 ] ;
25795: LD_ADDR_VAR 0 9
25799: PUSH
25800: LD_INT 30
25802: PUSH
25803: LD_INT 10
25805: PUSH
25806: LD_INT 5
25808: PUSH
25809: EMPTY
25810: LIST
25811: LIST
25812: LIST
25813: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
25814: LD_VAR 0 1
25818: PPUSH
25819: LD_INT 5
25821: PPUSH
25822: CALL_OW 321
25826: PUSH
25827: LD_INT 2
25829: EQUAL
25830: IFFALSE 25847
// bpoints := bpoints * 1.8 ;
25832: LD_ADDR_VAR 0 10
25836: PUSH
25837: LD_VAR 0 10
25841: PUSH
25842: LD_REAL  1.80000000000000E+0000
25845: MUL
25846: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
25847: LD_VAR 0 6
25851: PPUSH
25852: CALL_OW 257
25856: PUSH
25857: LD_INT 1
25859: PUSH
25860: LD_INT 2
25862: PUSH
25863: LD_INT 3
25865: PUSH
25866: LD_INT 4
25868: PUSH
25869: EMPTY
25870: LIST
25871: LIST
25872: LIST
25873: LIST
25874: IN
25875: PUSH
25876: LD_VAR 0 1
25880: PPUSH
25881: LD_INT 51
25883: PPUSH
25884: CALL_OW 321
25888: PUSH
25889: LD_INT 2
25891: EQUAL
25892: AND
25893: IFFALSE 25910
// bpoints := bpoints * 1.2 ;
25895: LD_ADDR_VAR 0 10
25899: PUSH
25900: LD_VAR 0 10
25904: PUSH
25905: LD_REAL  1.20000000000000E+0000
25908: MUL
25909: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
25910: LD_VAR 0 6
25914: PPUSH
25915: CALL_OW 257
25919: PUSH
25920: LD_INT 5
25922: PUSH
25923: LD_INT 7
25925: PUSH
25926: LD_INT 9
25928: PUSH
25929: EMPTY
25930: LIST
25931: LIST
25932: LIST
25933: IN
25934: PUSH
25935: LD_VAR 0 1
25939: PPUSH
25940: LD_INT 52
25942: PPUSH
25943: CALL_OW 321
25947: PUSH
25948: LD_INT 2
25950: EQUAL
25951: AND
25952: IFFALSE 25969
// bpoints := bpoints * 1.5 ;
25954: LD_ADDR_VAR 0 10
25958: PUSH
25959: LD_VAR 0 10
25963: PUSH
25964: LD_REAL  1.50000000000000E+0000
25967: MUL
25968: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
25969: LD_VAR 0 1
25973: PPUSH
25974: LD_INT 66
25976: PPUSH
25977: CALL_OW 321
25981: PUSH
25982: LD_INT 2
25984: EQUAL
25985: IFFALSE 26002
// bpoints := bpoints * 1.1 ;
25987: LD_ADDR_VAR 0 10
25991: PUSH
25992: LD_VAR 0 10
25996: PUSH
25997: LD_REAL  1.10000000000000E+0000
26000: MUL
26001: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
26002: LD_ADDR_VAR 0 10
26006: PUSH
26007: LD_VAR 0 10
26011: PUSH
26012: LD_VAR 0 6
26016: PPUSH
26017: LD_INT 1
26019: PPUSH
26020: CALL_OW 259
26024: PUSH
26025: LD_REAL  1.15000000000000E+0000
26028: MUL
26029: MUL
26030: ST_TO_ADDR
// end ; unit_vehicle :
26031: GO 26861
26033: LD_INT 2
26035: DOUBLE
26036: EQUAL
26037: IFTRUE 26041
26039: GO 26849
26041: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
26042: LD_VAR 0 6
26046: PPUSH
26047: CALL_OW 264
26051: PUSH
26052: LD_INT 2
26054: PUSH
26055: LD_INT 42
26057: PUSH
26058: LD_INT 24
26060: PUSH
26061: EMPTY
26062: LIST
26063: LIST
26064: LIST
26065: IN
26066: IFFALSE 26087
// points := [ 25 , 5 , 3 ] ;
26068: LD_ADDR_VAR 0 9
26072: PUSH
26073: LD_INT 25
26075: PUSH
26076: LD_INT 5
26078: PUSH
26079: LD_INT 3
26081: PUSH
26082: EMPTY
26083: LIST
26084: LIST
26085: LIST
26086: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
26087: LD_VAR 0 6
26091: PPUSH
26092: CALL_OW 264
26096: PUSH
26097: LD_INT 4
26099: PUSH
26100: LD_INT 43
26102: PUSH
26103: LD_INT 25
26105: PUSH
26106: EMPTY
26107: LIST
26108: LIST
26109: LIST
26110: IN
26111: IFFALSE 26132
// points := [ 40 , 15 , 5 ] ;
26113: LD_ADDR_VAR 0 9
26117: PUSH
26118: LD_INT 40
26120: PUSH
26121: LD_INT 15
26123: PUSH
26124: LD_INT 5
26126: PUSH
26127: EMPTY
26128: LIST
26129: LIST
26130: LIST
26131: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
26132: LD_VAR 0 6
26136: PPUSH
26137: CALL_OW 264
26141: PUSH
26142: LD_INT 3
26144: PUSH
26145: LD_INT 23
26147: PUSH
26148: EMPTY
26149: LIST
26150: LIST
26151: IN
26152: IFFALSE 26173
// points := [ 7 , 25 , 8 ] ;
26154: LD_ADDR_VAR 0 9
26158: PUSH
26159: LD_INT 7
26161: PUSH
26162: LD_INT 25
26164: PUSH
26165: LD_INT 8
26167: PUSH
26168: EMPTY
26169: LIST
26170: LIST
26171: LIST
26172: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
26173: LD_VAR 0 6
26177: PPUSH
26178: CALL_OW 264
26182: PUSH
26183: LD_INT 5
26185: PUSH
26186: LD_INT 27
26188: PUSH
26189: LD_INT 44
26191: PUSH
26192: EMPTY
26193: LIST
26194: LIST
26195: LIST
26196: IN
26197: IFFALSE 26218
// points := [ 14 , 50 , 16 ] ;
26199: LD_ADDR_VAR 0 9
26203: PUSH
26204: LD_INT 14
26206: PUSH
26207: LD_INT 50
26209: PUSH
26210: LD_INT 16
26212: PUSH
26213: EMPTY
26214: LIST
26215: LIST
26216: LIST
26217: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
26218: LD_VAR 0 6
26222: PPUSH
26223: CALL_OW 264
26227: PUSH
26228: LD_INT 6
26230: PUSH
26231: LD_INT 46
26233: PUSH
26234: EMPTY
26235: LIST
26236: LIST
26237: IN
26238: IFFALSE 26259
// points := [ 32 , 120 , 70 ] ;
26240: LD_ADDR_VAR 0 9
26244: PUSH
26245: LD_INT 32
26247: PUSH
26248: LD_INT 120
26250: PUSH
26251: LD_INT 70
26253: PUSH
26254: EMPTY
26255: LIST
26256: LIST
26257: LIST
26258: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher , ar_mortar ] then
26259: LD_VAR 0 6
26263: PPUSH
26264: CALL_OW 264
26268: PUSH
26269: LD_INT 7
26271: PUSH
26272: LD_INT 28
26274: PUSH
26275: LD_INT 45
26277: PUSH
26278: LD_EXP 163
26282: PUSH
26283: EMPTY
26284: LIST
26285: LIST
26286: LIST
26287: LIST
26288: IN
26289: IFFALSE 26310
// points := [ 35 , 20 , 45 ] ;
26291: LD_ADDR_VAR 0 9
26295: PUSH
26296: LD_INT 35
26298: PUSH
26299: LD_INT 20
26301: PUSH
26302: LD_INT 45
26304: PUSH
26305: EMPTY
26306: LIST
26307: LIST
26308: LIST
26309: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
26310: LD_VAR 0 6
26314: PPUSH
26315: CALL_OW 264
26319: PUSH
26320: LD_INT 47
26322: PUSH
26323: EMPTY
26324: LIST
26325: IN
26326: IFFALSE 26347
// points := [ 67 , 45 , 75 ] ;
26328: LD_ADDR_VAR 0 9
26332: PUSH
26333: LD_INT 67
26335: PUSH
26336: LD_INT 45
26338: PUSH
26339: LD_INT 75
26341: PUSH
26342: EMPTY
26343: LIST
26344: LIST
26345: LIST
26346: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
26347: LD_VAR 0 6
26351: PPUSH
26352: CALL_OW 264
26356: PUSH
26357: LD_INT 26
26359: PUSH
26360: EMPTY
26361: LIST
26362: IN
26363: IFFALSE 26384
// points := [ 120 , 30 , 80 ] ;
26365: LD_ADDR_VAR 0 9
26369: PUSH
26370: LD_INT 120
26372: PUSH
26373: LD_INT 30
26375: PUSH
26376: LD_INT 80
26378: PUSH
26379: EMPTY
26380: LIST
26381: LIST
26382: LIST
26383: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
26384: LD_VAR 0 6
26388: PPUSH
26389: CALL_OW 264
26393: PUSH
26394: LD_INT 22
26396: PUSH
26397: EMPTY
26398: LIST
26399: IN
26400: IFFALSE 26421
// points := [ 40 , 1 , 1 ] ;
26402: LD_ADDR_VAR 0 9
26406: PUSH
26407: LD_INT 40
26409: PUSH
26410: LD_INT 1
26412: PUSH
26413: LD_INT 1
26415: PUSH
26416: EMPTY
26417: LIST
26418: LIST
26419: LIST
26420: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
26421: LD_VAR 0 6
26425: PPUSH
26426: CALL_OW 264
26430: PUSH
26431: LD_INT 29
26433: PUSH
26434: EMPTY
26435: LIST
26436: IN
26437: IFFALSE 26458
// points := [ 70 , 200 , 400 ] ;
26439: LD_ADDR_VAR 0 9
26443: PUSH
26444: LD_INT 70
26446: PUSH
26447: LD_INT 200
26449: PUSH
26450: LD_INT 400
26452: PUSH
26453: EMPTY
26454: LIST
26455: LIST
26456: LIST
26457: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
26458: LD_VAR 0 6
26462: PPUSH
26463: CALL_OW 264
26467: PUSH
26468: LD_INT 14
26470: PUSH
26471: LD_INT 53
26473: PUSH
26474: EMPTY
26475: LIST
26476: LIST
26477: IN
26478: IFFALSE 26499
// points := [ 40 , 10 , 20 ] ;
26480: LD_ADDR_VAR 0 9
26484: PUSH
26485: LD_INT 40
26487: PUSH
26488: LD_INT 10
26490: PUSH
26491: LD_INT 20
26493: PUSH
26494: EMPTY
26495: LIST
26496: LIST
26497: LIST
26498: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
26499: LD_VAR 0 6
26503: PPUSH
26504: CALL_OW 264
26508: PUSH
26509: LD_INT 9
26511: PUSH
26512: EMPTY
26513: LIST
26514: IN
26515: IFFALSE 26536
// points := [ 5 , 70 , 20 ] ;
26517: LD_ADDR_VAR 0 9
26521: PUSH
26522: LD_INT 5
26524: PUSH
26525: LD_INT 70
26527: PUSH
26528: LD_INT 20
26530: PUSH
26531: EMPTY
26532: LIST
26533: LIST
26534: LIST
26535: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
26536: LD_VAR 0 6
26540: PPUSH
26541: CALL_OW 264
26545: PUSH
26546: LD_INT 10
26548: PUSH
26549: EMPTY
26550: LIST
26551: IN
26552: IFFALSE 26573
// points := [ 35 , 110 , 70 ] ;
26554: LD_ADDR_VAR 0 9
26558: PUSH
26559: LD_INT 35
26561: PUSH
26562: LD_INT 110
26564: PUSH
26565: LD_INT 70
26567: PUSH
26568: EMPTY
26569: LIST
26570: LIST
26571: LIST
26572: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
26573: LD_VAR 0 6
26577: PPUSH
26578: CALL_OW 265
26582: PUSH
26583: LD_INT 25
26585: EQUAL
26586: IFFALSE 26607
// points := [ 80 , 65 , 100 ] ;
26588: LD_ADDR_VAR 0 9
26592: PUSH
26593: LD_INT 80
26595: PUSH
26596: LD_INT 65
26598: PUSH
26599: LD_INT 100
26601: PUSH
26602: EMPTY
26603: LIST
26604: LIST
26605: LIST
26606: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
26607: LD_VAR 0 6
26611: PPUSH
26612: CALL_OW 263
26616: PUSH
26617: LD_INT 1
26619: EQUAL
26620: IFFALSE 26655
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
26622: LD_ADDR_VAR 0 10
26626: PUSH
26627: LD_VAR 0 10
26631: PUSH
26632: LD_VAR 0 6
26636: PPUSH
26637: CALL_OW 311
26641: PPUSH
26642: LD_INT 3
26644: PPUSH
26645: CALL_OW 259
26649: PUSH
26650: LD_INT 4
26652: MUL
26653: MUL
26654: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
26655: LD_VAR 0 6
26659: PPUSH
26660: CALL_OW 263
26664: PUSH
26665: LD_INT 2
26667: EQUAL
26668: IFFALSE 26719
// begin j := IsControledBy ( i ) ;
26670: LD_ADDR_VAR 0 7
26674: PUSH
26675: LD_VAR 0 6
26679: PPUSH
26680: CALL_OW 312
26684: ST_TO_ADDR
// if j then
26685: LD_VAR 0 7
26689: IFFALSE 26719
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
26691: LD_ADDR_VAR 0 10
26695: PUSH
26696: LD_VAR 0 10
26700: PUSH
26701: LD_VAR 0 7
26705: PPUSH
26706: LD_INT 3
26708: PPUSH
26709: CALL_OW 259
26713: PUSH
26714: LD_INT 3
26716: MUL
26717: MUL
26718: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
26719: LD_VAR 0 6
26723: PPUSH
26724: CALL_OW 264
26728: PUSH
26729: LD_INT 5
26731: PUSH
26732: LD_INT 6
26734: PUSH
26735: LD_INT 46
26737: PUSH
26738: LD_INT 44
26740: PUSH
26741: LD_INT 47
26743: PUSH
26744: LD_INT 45
26746: PUSH
26747: LD_INT 28
26749: PUSH
26750: LD_INT 7
26752: PUSH
26753: LD_INT 27
26755: PUSH
26756: LD_INT 29
26758: PUSH
26759: EMPTY
26760: LIST
26761: LIST
26762: LIST
26763: LIST
26764: LIST
26765: LIST
26766: LIST
26767: LIST
26768: LIST
26769: LIST
26770: IN
26771: PUSH
26772: LD_VAR 0 1
26776: PPUSH
26777: LD_INT 52
26779: PPUSH
26780: CALL_OW 321
26784: PUSH
26785: LD_INT 2
26787: EQUAL
26788: AND
26789: IFFALSE 26806
// bpoints := bpoints * 1.2 ;
26791: LD_ADDR_VAR 0 10
26795: PUSH
26796: LD_VAR 0 10
26800: PUSH
26801: LD_REAL  1.20000000000000E+0000
26804: MUL
26805: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
26806: LD_VAR 0 6
26810: PPUSH
26811: CALL_OW 264
26815: PUSH
26816: LD_INT 6
26818: PUSH
26819: LD_INT 46
26821: PUSH
26822: LD_INT 47
26824: PUSH
26825: EMPTY
26826: LIST
26827: LIST
26828: LIST
26829: IN
26830: IFFALSE 26847
// bpoints := bpoints * 1.2 ;
26832: LD_ADDR_VAR 0 10
26836: PUSH
26837: LD_VAR 0 10
26841: PUSH
26842: LD_REAL  1.20000000000000E+0000
26845: MUL
26846: ST_TO_ADDR
// end ; unit_building :
26847: GO 26861
26849: LD_INT 3
26851: DOUBLE
26852: EQUAL
26853: IFTRUE 26857
26855: GO 26860
26857: POP
// ; end ;
26858: GO 26861
26860: POP
// for j = 1 to 3 do
26861: LD_ADDR_VAR 0 7
26865: PUSH
26866: DOUBLE
26867: LD_INT 1
26869: DEC
26870: ST_TO_ADDR
26871: LD_INT 3
26873: PUSH
26874: FOR_TO
26875: IFFALSE 26928
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
26877: LD_ADDR_VAR 0 5
26881: PUSH
26882: LD_VAR 0 5
26886: PPUSH
26887: LD_VAR 0 7
26891: PPUSH
26892: LD_VAR 0 5
26896: PUSH
26897: LD_VAR 0 7
26901: ARRAY
26902: PUSH
26903: LD_VAR 0 9
26907: PUSH
26908: LD_VAR 0 7
26912: ARRAY
26913: PUSH
26914: LD_VAR 0 10
26918: MUL
26919: PLUS
26920: PPUSH
26921: CALL_OW 1
26925: ST_TO_ADDR
26926: GO 26874
26928: POP
26929: POP
// end ;
26930: GO 25407
26932: POP
26933: POP
// result := Replace ( result , 4 , tmp ) ;
26934: LD_ADDR_VAR 0 5
26938: PUSH
26939: LD_VAR 0 5
26943: PPUSH
26944: LD_INT 4
26946: PPUSH
26947: LD_VAR 0 8
26951: PPUSH
26952: CALL_OW 1
26956: ST_TO_ADDR
// end ;
26957: LD_VAR 0 5
26961: RET
// export function DangerAtRange ( unit , range ) ; begin
26962: LD_INT 0
26964: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
26965: LD_ADDR_VAR 0 3
26969: PUSH
26970: LD_VAR 0 1
26974: PPUSH
26975: CALL_OW 255
26979: PPUSH
26980: LD_VAR 0 1
26984: PPUSH
26985: CALL_OW 250
26989: PPUSH
26990: LD_VAR 0 1
26994: PPUSH
26995: CALL_OW 251
26999: PPUSH
27000: LD_VAR 0 2
27004: PPUSH
27005: CALL 25259 0 4
27009: ST_TO_ADDR
// end ;
27010: LD_VAR 0 3
27014: RET
// export function DangerInArea ( side , area ) ; begin
27015: LD_INT 0
27017: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
27018: LD_ADDR_VAR 0 3
27022: PUSH
27023: LD_VAR 0 2
27027: PPUSH
27028: LD_INT 81
27030: PUSH
27031: LD_VAR 0 1
27035: PUSH
27036: EMPTY
27037: LIST
27038: LIST
27039: PPUSH
27040: CALL_OW 70
27044: ST_TO_ADDR
// end ;
27045: LD_VAR 0 3
27049: RET
// export function IsExtension ( b ) ; begin
27050: LD_INT 0
27052: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
27053: LD_ADDR_VAR 0 2
27057: PUSH
27058: LD_VAR 0 1
27062: PUSH
27063: LD_INT 23
27065: PUSH
27066: LD_INT 20
27068: PUSH
27069: LD_INT 22
27071: PUSH
27072: LD_INT 17
27074: PUSH
27075: LD_INT 24
27077: PUSH
27078: LD_INT 21
27080: PUSH
27081: LD_INT 19
27083: PUSH
27084: LD_INT 16
27086: PUSH
27087: LD_INT 25
27089: PUSH
27090: LD_INT 18
27092: PUSH
27093: EMPTY
27094: LIST
27095: LIST
27096: LIST
27097: LIST
27098: LIST
27099: LIST
27100: LIST
27101: LIST
27102: LIST
27103: LIST
27104: IN
27105: ST_TO_ADDR
// end ;
27106: LD_VAR 0 2
27110: RET
// export function GetBaseBuildings ( base , area , checkLink ) ; var tmp , i ; begin
27111: LD_INT 0
27113: PPUSH
27114: PPUSH
27115: PPUSH
// result := [ ] ;
27116: LD_ADDR_VAR 0 4
27120: PUSH
27121: EMPTY
27122: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
27123: LD_ADDR_VAR 0 5
27127: PUSH
27128: LD_VAR 0 2
27132: PPUSH
27133: LD_INT 21
27135: PUSH
27136: LD_INT 3
27138: PUSH
27139: EMPTY
27140: LIST
27141: LIST
27142: PPUSH
27143: CALL_OW 70
27147: ST_TO_ADDR
// if not tmp then
27148: LD_VAR 0 5
27152: NOT
27153: IFFALSE 27157
// exit ;
27155: GO 27221
// if checkLink then
27157: LD_VAR 0 3
27161: IFFALSE 27211
// begin for i in tmp do
27163: LD_ADDR_VAR 0 6
27167: PUSH
27168: LD_VAR 0 5
27172: PUSH
27173: FOR_IN
27174: IFFALSE 27209
// if GetBase ( i ) <> base then
27176: LD_VAR 0 6
27180: PPUSH
27181: CALL_OW 274
27185: PUSH
27186: LD_VAR 0 1
27190: NONEQUAL
27191: IFFALSE 27207
// ComLinkToBase ( base , i ) ;
27193: LD_VAR 0 1
27197: PPUSH
27198: LD_VAR 0 6
27202: PPUSH
27203: CALL_OW 169
27207: GO 27173
27209: POP
27210: POP
// end ; result := tmp ;
27211: LD_ADDR_VAR 0 4
27215: PUSH
27216: LD_VAR 0 5
27220: ST_TO_ADDR
// end ;
27221: LD_VAR 0 4
27225: RET
// export function ComComplete ( units , b ) ; var i ; begin
27226: LD_INT 0
27228: PPUSH
27229: PPUSH
// if not units then
27230: LD_VAR 0 1
27234: NOT
27235: IFFALSE 27239
// exit ;
27237: GO 27329
// for i in units do
27239: LD_ADDR_VAR 0 4
27243: PUSH
27244: LD_VAR 0 1
27248: PUSH
27249: FOR_IN
27250: IFFALSE 27327
// if BuildingStatus ( b ) = bs_build then
27252: LD_VAR 0 2
27256: PPUSH
27257: CALL_OW 461
27261: PUSH
27262: LD_INT 1
27264: EQUAL
27265: IFFALSE 27325
// SetTaskList ( i , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
27267: LD_VAR 0 4
27271: PPUSH
27272: LD_STRING h
27274: PUSH
27275: LD_VAR 0 2
27279: PPUSH
27280: CALL_OW 250
27284: PUSH
27285: LD_VAR 0 2
27289: PPUSH
27290: CALL_OW 251
27294: PUSH
27295: LD_VAR 0 2
27299: PUSH
27300: LD_INT 0
27302: PUSH
27303: LD_INT 0
27305: PUSH
27306: LD_INT 0
27308: PUSH
27309: EMPTY
27310: LIST
27311: LIST
27312: LIST
27313: LIST
27314: LIST
27315: LIST
27316: LIST
27317: PUSH
27318: EMPTY
27319: LIST
27320: PPUSH
27321: CALL_OW 446
27325: GO 27249
27327: POP
27328: POP
// end ;
27329: LD_VAR 0 3
27333: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
27334: LD_INT 0
27336: PPUSH
27337: PPUSH
27338: PPUSH
27339: PPUSH
27340: PPUSH
27341: PPUSH
// if not vehicle or GetControl ( vehicle ) <> control_remote then
27342: LD_VAR 0 1
27346: NOT
27347: PUSH
27348: LD_VAR 0 1
27352: PPUSH
27353: CALL_OW 263
27357: PUSH
27358: LD_INT 2
27360: NONEQUAL
27361: OR
27362: IFFALSE 27366
// exit ;
27364: GO 27682
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
27366: LD_ADDR_VAR 0 6
27370: PUSH
27371: LD_INT 22
27373: PUSH
27374: LD_VAR 0 1
27378: PPUSH
27379: CALL_OW 255
27383: PUSH
27384: EMPTY
27385: LIST
27386: LIST
27387: PUSH
27388: LD_INT 2
27390: PUSH
27391: LD_INT 30
27393: PUSH
27394: LD_INT 36
27396: PUSH
27397: EMPTY
27398: LIST
27399: LIST
27400: PUSH
27401: LD_INT 34
27403: PUSH
27404: LD_INT 31
27406: PUSH
27407: EMPTY
27408: LIST
27409: LIST
27410: PUSH
27411: EMPTY
27412: LIST
27413: LIST
27414: LIST
27415: PUSH
27416: EMPTY
27417: LIST
27418: LIST
27419: PPUSH
27420: CALL_OW 69
27424: ST_TO_ADDR
// if not tmp then
27425: LD_VAR 0 6
27429: NOT
27430: IFFALSE 27434
// exit ;
27432: GO 27682
// result := [ ] ;
27434: LD_ADDR_VAR 0 2
27438: PUSH
27439: EMPTY
27440: ST_TO_ADDR
// for i in tmp do
27441: LD_ADDR_VAR 0 3
27445: PUSH
27446: LD_VAR 0 6
27450: PUSH
27451: FOR_IN
27452: IFFALSE 27523
// begin t := UnitsInside ( i ) ;
27454: LD_ADDR_VAR 0 4
27458: PUSH
27459: LD_VAR 0 3
27463: PPUSH
27464: CALL_OW 313
27468: ST_TO_ADDR
// if t then
27469: LD_VAR 0 4
27473: IFFALSE 27521
// for j in t do
27475: LD_ADDR_VAR 0 7
27479: PUSH
27480: LD_VAR 0 4
27484: PUSH
27485: FOR_IN
27486: IFFALSE 27519
// result := Replace ( result , result + 1 , j ) ;
27488: LD_ADDR_VAR 0 2
27492: PUSH
27493: LD_VAR 0 2
27497: PPUSH
27498: LD_VAR 0 2
27502: PUSH
27503: LD_INT 1
27505: PLUS
27506: PPUSH
27507: LD_VAR 0 7
27511: PPUSH
27512: CALL_OW 1
27516: ST_TO_ADDR
27517: GO 27485
27519: POP
27520: POP
// end ;
27521: GO 27451
27523: POP
27524: POP
// if not result then
27525: LD_VAR 0 2
27529: NOT
27530: IFFALSE 27534
// exit ;
27532: GO 27682
// mech := result [ 1 ] ;
27534: LD_ADDR_VAR 0 5
27538: PUSH
27539: LD_VAR 0 2
27543: PUSH
27544: LD_INT 1
27546: ARRAY
27547: ST_TO_ADDR
// if result > 1 then
27548: LD_VAR 0 2
27552: PUSH
27553: LD_INT 1
27555: GREATER
27556: IFFALSE 27668
// begin for i = 2 to result do
27558: LD_ADDR_VAR 0 3
27562: PUSH
27563: DOUBLE
27564: LD_INT 2
27566: DEC
27567: ST_TO_ADDR
27568: LD_VAR 0 2
27572: PUSH
27573: FOR_TO
27574: IFFALSE 27666
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
27576: LD_ADDR_VAR 0 4
27580: PUSH
27581: LD_VAR 0 2
27585: PUSH
27586: LD_VAR 0 3
27590: ARRAY
27591: PPUSH
27592: LD_INT 3
27594: PPUSH
27595: CALL_OW 259
27599: PUSH
27600: LD_VAR 0 2
27604: PUSH
27605: LD_VAR 0 3
27609: ARRAY
27610: PPUSH
27611: CALL_OW 432
27615: MINUS
27616: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
27617: LD_VAR 0 4
27621: PUSH
27622: LD_VAR 0 5
27626: PPUSH
27627: LD_INT 3
27629: PPUSH
27630: CALL_OW 259
27634: PUSH
27635: LD_VAR 0 5
27639: PPUSH
27640: CALL_OW 432
27644: MINUS
27645: GREATEREQUAL
27646: IFFALSE 27664
// mech := result [ i ] ;
27648: LD_ADDR_VAR 0 5
27652: PUSH
27653: LD_VAR 0 2
27657: PUSH
27658: LD_VAR 0 3
27662: ARRAY
27663: ST_TO_ADDR
// end ;
27664: GO 27573
27666: POP
27667: POP
// end ; ComLinkTo ( vehicle , mech ) ;
27668: LD_VAR 0 1
27672: PPUSH
27673: LD_VAR 0 5
27677: PPUSH
27678: CALL_OW 135
// end ;
27682: LD_VAR 0 2
27686: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
27687: LD_INT 0
27689: PPUSH
27690: PPUSH
27691: PPUSH
27692: PPUSH
27693: PPUSH
27694: PPUSH
27695: PPUSH
27696: PPUSH
27697: PPUSH
27698: PPUSH
27699: PPUSH
27700: PPUSH
27701: PPUSH
// result := [ ] ;
27702: LD_ADDR_VAR 0 7
27706: PUSH
27707: EMPTY
27708: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
27709: LD_VAR 0 1
27713: PPUSH
27714: CALL_OW 266
27718: PUSH
27719: LD_INT 0
27721: PUSH
27722: LD_INT 1
27724: PUSH
27725: EMPTY
27726: LIST
27727: LIST
27728: IN
27729: NOT
27730: IFFALSE 27734
// exit ;
27732: GO 29368
// if name then
27734: LD_VAR 0 3
27738: IFFALSE 27754
// SetBName ( base_dep , name ) ;
27740: LD_VAR 0 1
27744: PPUSH
27745: LD_VAR 0 3
27749: PPUSH
27750: CALL_OW 500
// base := GetBase ( base_dep ) ;
27754: LD_ADDR_VAR 0 15
27758: PUSH
27759: LD_VAR 0 1
27763: PPUSH
27764: CALL_OW 274
27768: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
27769: LD_ADDR_VAR 0 16
27773: PUSH
27774: LD_VAR 0 1
27778: PPUSH
27779: CALL_OW 255
27783: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
27784: LD_ADDR_VAR 0 17
27788: PUSH
27789: LD_VAR 0 1
27793: PPUSH
27794: CALL_OW 248
27798: ST_TO_ADDR
// if sources then
27799: LD_VAR 0 5
27803: IFFALSE 27850
// for i = 1 to 3 do
27805: LD_ADDR_VAR 0 8
27809: PUSH
27810: DOUBLE
27811: LD_INT 1
27813: DEC
27814: ST_TO_ADDR
27815: LD_INT 3
27817: PUSH
27818: FOR_TO
27819: IFFALSE 27848
// AddResourceType ( base , i , sources [ i ] ) ;
27821: LD_VAR 0 15
27825: PPUSH
27826: LD_VAR 0 8
27830: PPUSH
27831: LD_VAR 0 5
27835: PUSH
27836: LD_VAR 0 8
27840: ARRAY
27841: PPUSH
27842: CALL_OW 276
27846: GO 27818
27848: POP
27849: POP
// buildings := GetBaseBuildings ( base , area , true ) ;
27850: LD_ADDR_VAR 0 18
27854: PUSH
27855: LD_VAR 0 15
27859: PPUSH
27860: LD_VAR 0 2
27864: PPUSH
27865: LD_INT 1
27867: PPUSH
27868: CALL 27111 0 3
27872: ST_TO_ADDR
// InitHc ;
27873: CALL_OW 19
// InitUc ;
27877: CALL_OW 18
// uc_side := side ;
27881: LD_ADDR_OWVAR 20
27885: PUSH
27886: LD_VAR 0 16
27890: ST_TO_ADDR
// uc_nation := nation ;
27891: LD_ADDR_OWVAR 21
27895: PUSH
27896: LD_VAR 0 17
27900: ST_TO_ADDR
// if buildings then
27901: LD_VAR 0 18
27905: IFFALSE 29227
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
27907: LD_ADDR_VAR 0 19
27911: PUSH
27912: LD_VAR 0 18
27916: PPUSH
27917: LD_INT 2
27919: PUSH
27920: LD_INT 30
27922: PUSH
27923: LD_INT 29
27925: PUSH
27926: EMPTY
27927: LIST
27928: LIST
27929: PUSH
27930: LD_INT 30
27932: PUSH
27933: LD_INT 30
27935: PUSH
27936: EMPTY
27937: LIST
27938: LIST
27939: PUSH
27940: EMPTY
27941: LIST
27942: LIST
27943: LIST
27944: PPUSH
27945: CALL_OW 72
27949: ST_TO_ADDR
// if tmp then
27950: LD_VAR 0 19
27954: IFFALSE 28002
// for i in tmp do
27956: LD_ADDR_VAR 0 8
27960: PUSH
27961: LD_VAR 0 19
27965: PUSH
27966: FOR_IN
27967: IFFALSE 28000
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
27969: LD_VAR 0 8
27973: PPUSH
27974: CALL_OW 250
27978: PPUSH
27979: LD_VAR 0 8
27983: PPUSH
27984: CALL_OW 251
27988: PPUSH
27989: LD_VAR 0 16
27993: PPUSH
27994: CALL_OW 441
27998: GO 27966
28000: POP
28001: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
28002: LD_VAR 0 18
28006: PPUSH
28007: LD_INT 2
28009: PUSH
28010: LD_INT 30
28012: PUSH
28013: LD_INT 32
28015: PUSH
28016: EMPTY
28017: LIST
28018: LIST
28019: PUSH
28020: LD_INT 30
28022: PUSH
28023: LD_INT 33
28025: PUSH
28026: EMPTY
28027: LIST
28028: LIST
28029: PUSH
28030: EMPTY
28031: LIST
28032: LIST
28033: LIST
28034: PPUSH
28035: CALL_OW 72
28039: IFFALSE 28127
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
28041: LD_ADDR_VAR 0 8
28045: PUSH
28046: LD_VAR 0 18
28050: PPUSH
28051: LD_INT 2
28053: PUSH
28054: LD_INT 30
28056: PUSH
28057: LD_INT 32
28059: PUSH
28060: EMPTY
28061: LIST
28062: LIST
28063: PUSH
28064: LD_INT 30
28066: PUSH
28067: LD_INT 33
28069: PUSH
28070: EMPTY
28071: LIST
28072: LIST
28073: PUSH
28074: EMPTY
28075: LIST
28076: LIST
28077: LIST
28078: PPUSH
28079: CALL_OW 72
28083: PUSH
28084: FOR_IN
28085: IFFALSE 28125
// begin if not GetBWeapon ( i ) then
28087: LD_VAR 0 8
28091: PPUSH
28092: CALL_OW 269
28096: NOT
28097: IFFALSE 28123
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
28099: LD_VAR 0 8
28103: PPUSH
28104: LD_VAR 0 8
28108: PPUSH
28109: LD_VAR 0 2
28113: PPUSH
28114: CALL 29373 0 2
28118: PPUSH
28119: CALL_OW 431
// end ;
28123: GO 28084
28125: POP
28126: POP
// end ; for i = 1 to personel do
28127: LD_ADDR_VAR 0 8
28131: PUSH
28132: DOUBLE
28133: LD_INT 1
28135: DEC
28136: ST_TO_ADDR
28137: LD_VAR 0 6
28141: PUSH
28142: FOR_TO
28143: IFFALSE 29207
// begin if i > 4 then
28145: LD_VAR 0 8
28149: PUSH
28150: LD_INT 4
28152: GREATER
28153: IFFALSE 28157
// break ;
28155: GO 29207
// case i of 1 :
28157: LD_VAR 0 8
28161: PUSH
28162: LD_INT 1
28164: DOUBLE
28165: EQUAL
28166: IFTRUE 28170
28168: GO 28250
28170: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
28171: LD_ADDR_VAR 0 12
28175: PUSH
28176: LD_VAR 0 18
28180: PPUSH
28181: LD_INT 22
28183: PUSH
28184: LD_VAR 0 16
28188: PUSH
28189: EMPTY
28190: LIST
28191: LIST
28192: PUSH
28193: LD_INT 58
28195: PUSH
28196: EMPTY
28197: LIST
28198: PUSH
28199: LD_INT 2
28201: PUSH
28202: LD_INT 30
28204: PUSH
28205: LD_INT 32
28207: PUSH
28208: EMPTY
28209: LIST
28210: LIST
28211: PUSH
28212: LD_INT 30
28214: PUSH
28215: LD_INT 4
28217: PUSH
28218: EMPTY
28219: LIST
28220: LIST
28221: PUSH
28222: LD_INT 30
28224: PUSH
28225: LD_INT 5
28227: PUSH
28228: EMPTY
28229: LIST
28230: LIST
28231: PUSH
28232: EMPTY
28233: LIST
28234: LIST
28235: LIST
28236: LIST
28237: PUSH
28238: EMPTY
28239: LIST
28240: LIST
28241: LIST
28242: PPUSH
28243: CALL_OW 72
28247: ST_TO_ADDR
28248: GO 28472
28250: LD_INT 2
28252: DOUBLE
28253: EQUAL
28254: IFTRUE 28258
28256: GO 28320
28258: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
28259: LD_ADDR_VAR 0 12
28263: PUSH
28264: LD_VAR 0 18
28268: PPUSH
28269: LD_INT 22
28271: PUSH
28272: LD_VAR 0 16
28276: PUSH
28277: EMPTY
28278: LIST
28279: LIST
28280: PUSH
28281: LD_INT 2
28283: PUSH
28284: LD_INT 30
28286: PUSH
28287: LD_INT 0
28289: PUSH
28290: EMPTY
28291: LIST
28292: LIST
28293: PUSH
28294: LD_INT 30
28296: PUSH
28297: LD_INT 1
28299: PUSH
28300: EMPTY
28301: LIST
28302: LIST
28303: PUSH
28304: EMPTY
28305: LIST
28306: LIST
28307: LIST
28308: PUSH
28309: EMPTY
28310: LIST
28311: LIST
28312: PPUSH
28313: CALL_OW 72
28317: ST_TO_ADDR
28318: GO 28472
28320: LD_INT 3
28322: DOUBLE
28323: EQUAL
28324: IFTRUE 28328
28326: GO 28390
28328: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
28329: LD_ADDR_VAR 0 12
28333: PUSH
28334: LD_VAR 0 18
28338: PPUSH
28339: LD_INT 22
28341: PUSH
28342: LD_VAR 0 16
28346: PUSH
28347: EMPTY
28348: LIST
28349: LIST
28350: PUSH
28351: LD_INT 2
28353: PUSH
28354: LD_INT 30
28356: PUSH
28357: LD_INT 2
28359: PUSH
28360: EMPTY
28361: LIST
28362: LIST
28363: PUSH
28364: LD_INT 30
28366: PUSH
28367: LD_INT 3
28369: PUSH
28370: EMPTY
28371: LIST
28372: LIST
28373: PUSH
28374: EMPTY
28375: LIST
28376: LIST
28377: LIST
28378: PUSH
28379: EMPTY
28380: LIST
28381: LIST
28382: PPUSH
28383: CALL_OW 72
28387: ST_TO_ADDR
28388: GO 28472
28390: LD_INT 4
28392: DOUBLE
28393: EQUAL
28394: IFTRUE 28398
28396: GO 28471
28398: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
28399: LD_ADDR_VAR 0 12
28403: PUSH
28404: LD_VAR 0 18
28408: PPUSH
28409: LD_INT 22
28411: PUSH
28412: LD_VAR 0 16
28416: PUSH
28417: EMPTY
28418: LIST
28419: LIST
28420: PUSH
28421: LD_INT 2
28423: PUSH
28424: LD_INT 30
28426: PUSH
28427: LD_INT 6
28429: PUSH
28430: EMPTY
28431: LIST
28432: LIST
28433: PUSH
28434: LD_INT 30
28436: PUSH
28437: LD_INT 7
28439: PUSH
28440: EMPTY
28441: LIST
28442: LIST
28443: PUSH
28444: LD_INT 30
28446: PUSH
28447: LD_INT 8
28449: PUSH
28450: EMPTY
28451: LIST
28452: LIST
28453: PUSH
28454: EMPTY
28455: LIST
28456: LIST
28457: LIST
28458: LIST
28459: PUSH
28460: EMPTY
28461: LIST
28462: LIST
28463: PPUSH
28464: CALL_OW 72
28468: ST_TO_ADDR
28469: GO 28472
28471: POP
// if i = 1 then
28472: LD_VAR 0 8
28476: PUSH
28477: LD_INT 1
28479: EQUAL
28480: IFFALSE 28591
// begin tmp := [ ] ;
28482: LD_ADDR_VAR 0 19
28486: PUSH
28487: EMPTY
28488: ST_TO_ADDR
// for j in f do
28489: LD_ADDR_VAR 0 9
28493: PUSH
28494: LD_VAR 0 12
28498: PUSH
28499: FOR_IN
28500: IFFALSE 28573
// if GetBType ( j ) = b_bunker then
28502: LD_VAR 0 9
28506: PPUSH
28507: CALL_OW 266
28511: PUSH
28512: LD_INT 32
28514: EQUAL
28515: IFFALSE 28542
// tmp := Insert ( tmp , 1 , j ) else
28517: LD_ADDR_VAR 0 19
28521: PUSH
28522: LD_VAR 0 19
28526: PPUSH
28527: LD_INT 1
28529: PPUSH
28530: LD_VAR 0 9
28534: PPUSH
28535: CALL_OW 2
28539: ST_TO_ADDR
28540: GO 28571
// tmp := Insert ( tmp , tmp + 1 , j ) ;
28542: LD_ADDR_VAR 0 19
28546: PUSH
28547: LD_VAR 0 19
28551: PPUSH
28552: LD_VAR 0 19
28556: PUSH
28557: LD_INT 1
28559: PLUS
28560: PPUSH
28561: LD_VAR 0 9
28565: PPUSH
28566: CALL_OW 2
28570: ST_TO_ADDR
28571: GO 28499
28573: POP
28574: POP
// if tmp then
28575: LD_VAR 0 19
28579: IFFALSE 28591
// f := tmp ;
28581: LD_ADDR_VAR 0 12
28585: PUSH
28586: LD_VAR 0 19
28590: ST_TO_ADDR
// end ; x := personel [ i ] ;
28591: LD_ADDR_VAR 0 13
28595: PUSH
28596: LD_VAR 0 6
28600: PUSH
28601: LD_VAR 0 8
28605: ARRAY
28606: ST_TO_ADDR
// if x = - 1 then
28607: LD_VAR 0 13
28611: PUSH
28612: LD_INT 1
28614: NEG
28615: EQUAL
28616: IFFALSE 28825
// begin for j in f do
28618: LD_ADDR_VAR 0 9
28622: PUSH
28623: LD_VAR 0 12
28627: PUSH
28628: FOR_IN
28629: IFFALSE 28821
// repeat InitHc ;
28631: CALL_OW 19
// if GetBType ( j ) = b_barracks then
28635: LD_VAR 0 9
28639: PPUSH
28640: CALL_OW 266
28644: PUSH
28645: LD_INT 5
28647: EQUAL
28648: IFFALSE 28718
// begin if UnitsInside ( j ) < 3 then
28650: LD_VAR 0 9
28654: PPUSH
28655: CALL_OW 313
28659: PUSH
28660: LD_INT 3
28662: LESS
28663: IFFALSE 28699
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
28665: LD_INT 0
28667: PPUSH
28668: LD_INT 5
28670: PUSH
28671: LD_INT 8
28673: PUSH
28674: LD_INT 9
28676: PUSH
28677: EMPTY
28678: LIST
28679: LIST
28680: LIST
28681: PUSH
28682: LD_VAR 0 17
28686: ARRAY
28687: PPUSH
28688: LD_VAR 0 4
28692: PPUSH
28693: CALL_OW 380
28697: GO 28716
// PrepareHuman ( false , i , skill ) ;
28699: LD_INT 0
28701: PPUSH
28702: LD_VAR 0 8
28706: PPUSH
28707: LD_VAR 0 4
28711: PPUSH
28712: CALL_OW 380
// end else
28716: GO 28735
// PrepareHuman ( false , i , skill ) ;
28718: LD_INT 0
28720: PPUSH
28721: LD_VAR 0 8
28725: PPUSH
28726: LD_VAR 0 4
28730: PPUSH
28731: CALL_OW 380
// un := CreateHuman ;
28735: LD_ADDR_VAR 0 14
28739: PUSH
28740: CALL_OW 44
28744: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
28745: LD_ADDR_VAR 0 7
28749: PUSH
28750: LD_VAR 0 7
28754: PPUSH
28755: LD_INT 1
28757: PPUSH
28758: LD_VAR 0 14
28762: PPUSH
28763: CALL_OW 2
28767: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
28768: LD_VAR 0 14
28772: PPUSH
28773: LD_VAR 0 9
28777: PPUSH
28778: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
28782: LD_VAR 0 9
28786: PPUSH
28787: CALL_OW 313
28791: PUSH
28792: LD_INT 6
28794: EQUAL
28795: PUSH
28796: LD_VAR 0 9
28800: PPUSH
28801: CALL_OW 266
28805: PUSH
28806: LD_INT 32
28808: PUSH
28809: LD_INT 31
28811: PUSH
28812: EMPTY
28813: LIST
28814: LIST
28815: IN
28816: OR
28817: IFFALSE 28631
28819: GO 28628
28821: POP
28822: POP
// end else
28823: GO 29205
// for j = 1 to x do
28825: LD_ADDR_VAR 0 9
28829: PUSH
28830: DOUBLE
28831: LD_INT 1
28833: DEC
28834: ST_TO_ADDR
28835: LD_VAR 0 13
28839: PUSH
28840: FOR_TO
28841: IFFALSE 29203
// begin InitHc ;
28843: CALL_OW 19
// if not f then
28847: LD_VAR 0 12
28851: NOT
28852: IFFALSE 28941
// begin PrepareHuman ( false , i , skill ) ;
28854: LD_INT 0
28856: PPUSH
28857: LD_VAR 0 8
28861: PPUSH
28862: LD_VAR 0 4
28866: PPUSH
28867: CALL_OW 380
// un := CreateHuman ;
28871: LD_ADDR_VAR 0 14
28875: PUSH
28876: CALL_OW 44
28880: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
28881: LD_ADDR_VAR 0 7
28885: PUSH
28886: LD_VAR 0 7
28890: PPUSH
28891: LD_INT 1
28893: PPUSH
28894: LD_VAR 0 14
28898: PPUSH
28899: CALL_OW 2
28903: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
28904: LD_VAR 0 14
28908: PPUSH
28909: LD_VAR 0 1
28913: PPUSH
28914: CALL_OW 250
28918: PPUSH
28919: LD_VAR 0 1
28923: PPUSH
28924: CALL_OW 251
28928: PPUSH
28929: LD_INT 10
28931: PPUSH
28932: LD_INT 0
28934: PPUSH
28935: CALL_OW 50
// continue ;
28939: GO 28840
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
28941: LD_VAR 0 12
28945: PUSH
28946: LD_INT 1
28948: ARRAY
28949: PPUSH
28950: CALL_OW 313
28954: PUSH
28955: LD_VAR 0 12
28959: PUSH
28960: LD_INT 1
28962: ARRAY
28963: PPUSH
28964: CALL_OW 266
28968: PUSH
28969: LD_INT 32
28971: PUSH
28972: LD_INT 31
28974: PUSH
28975: EMPTY
28976: LIST
28977: LIST
28978: IN
28979: AND
28980: PUSH
28981: LD_VAR 0 12
28985: PUSH
28986: LD_INT 1
28988: ARRAY
28989: PPUSH
28990: CALL_OW 313
28994: PUSH
28995: LD_INT 6
28997: EQUAL
28998: OR
28999: IFFALSE 29019
// f := Delete ( f , 1 ) ;
29001: LD_ADDR_VAR 0 12
29005: PUSH
29006: LD_VAR 0 12
29010: PPUSH
29011: LD_INT 1
29013: PPUSH
29014: CALL_OW 3
29018: ST_TO_ADDR
// if not f then
29019: LD_VAR 0 12
29023: NOT
29024: IFFALSE 29042
// begin x := x + 2 ;
29026: LD_ADDR_VAR 0 13
29030: PUSH
29031: LD_VAR 0 13
29035: PUSH
29036: LD_INT 2
29038: PLUS
29039: ST_TO_ADDR
// continue ;
29040: GO 28840
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
29042: LD_VAR 0 12
29046: PUSH
29047: LD_INT 1
29049: ARRAY
29050: PPUSH
29051: CALL_OW 266
29055: PUSH
29056: LD_INT 5
29058: EQUAL
29059: IFFALSE 29133
// begin if UnitsInside ( f [ 1 ] ) < 3 then
29061: LD_VAR 0 12
29065: PUSH
29066: LD_INT 1
29068: ARRAY
29069: PPUSH
29070: CALL_OW 313
29074: PUSH
29075: LD_INT 3
29077: LESS
29078: IFFALSE 29114
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
29080: LD_INT 0
29082: PPUSH
29083: LD_INT 5
29085: PUSH
29086: LD_INT 8
29088: PUSH
29089: LD_INT 9
29091: PUSH
29092: EMPTY
29093: LIST
29094: LIST
29095: LIST
29096: PUSH
29097: LD_VAR 0 17
29101: ARRAY
29102: PPUSH
29103: LD_VAR 0 4
29107: PPUSH
29108: CALL_OW 380
29112: GO 29131
// PrepareHuman ( false , i , skill ) ;
29114: LD_INT 0
29116: PPUSH
29117: LD_VAR 0 8
29121: PPUSH
29122: LD_VAR 0 4
29126: PPUSH
29127: CALL_OW 380
// end else
29131: GO 29150
// PrepareHuman ( false , i , skill ) ;
29133: LD_INT 0
29135: PPUSH
29136: LD_VAR 0 8
29140: PPUSH
29141: LD_VAR 0 4
29145: PPUSH
29146: CALL_OW 380
// un := CreateHuman ;
29150: LD_ADDR_VAR 0 14
29154: PUSH
29155: CALL_OW 44
29159: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
29160: LD_ADDR_VAR 0 7
29164: PUSH
29165: LD_VAR 0 7
29169: PPUSH
29170: LD_INT 1
29172: PPUSH
29173: LD_VAR 0 14
29177: PPUSH
29178: CALL_OW 2
29182: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
29183: LD_VAR 0 14
29187: PPUSH
29188: LD_VAR 0 12
29192: PUSH
29193: LD_INT 1
29195: ARRAY
29196: PPUSH
29197: CALL_OW 52
// end ;
29201: GO 28840
29203: POP
29204: POP
// end ;
29205: GO 28142
29207: POP
29208: POP
// result := result ^ buildings ;
29209: LD_ADDR_VAR 0 7
29213: PUSH
29214: LD_VAR 0 7
29218: PUSH
29219: LD_VAR 0 18
29223: ADD
29224: ST_TO_ADDR
// end else
29225: GO 29368
// begin for i = 1 to personel do
29227: LD_ADDR_VAR 0 8
29231: PUSH
29232: DOUBLE
29233: LD_INT 1
29235: DEC
29236: ST_TO_ADDR
29237: LD_VAR 0 6
29241: PUSH
29242: FOR_TO
29243: IFFALSE 29366
// begin if i > 4 then
29245: LD_VAR 0 8
29249: PUSH
29250: LD_INT 4
29252: GREATER
29253: IFFALSE 29257
// break ;
29255: GO 29366
// x := personel [ i ] ;
29257: LD_ADDR_VAR 0 13
29261: PUSH
29262: LD_VAR 0 6
29266: PUSH
29267: LD_VAR 0 8
29271: ARRAY
29272: ST_TO_ADDR
// if x = - 1 then
29273: LD_VAR 0 13
29277: PUSH
29278: LD_INT 1
29280: NEG
29281: EQUAL
29282: IFFALSE 29286
// continue ;
29284: GO 29242
// PrepareHuman ( false , i , skill ) ;
29286: LD_INT 0
29288: PPUSH
29289: LD_VAR 0 8
29293: PPUSH
29294: LD_VAR 0 4
29298: PPUSH
29299: CALL_OW 380
// un := CreateHuman ;
29303: LD_ADDR_VAR 0 14
29307: PUSH
29308: CALL_OW 44
29312: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
29313: LD_VAR 0 14
29317: PPUSH
29318: LD_VAR 0 1
29322: PPUSH
29323: CALL_OW 250
29327: PPUSH
29328: LD_VAR 0 1
29332: PPUSH
29333: CALL_OW 251
29337: PPUSH
29338: LD_INT 10
29340: PPUSH
29341: LD_INT 0
29343: PPUSH
29344: CALL_OW 50
// result := result ^ un ;
29348: LD_ADDR_VAR 0 7
29352: PUSH
29353: LD_VAR 0 7
29357: PUSH
29358: LD_VAR 0 14
29362: ADD
29363: ST_TO_ADDR
// end ;
29364: GO 29242
29366: POP
29367: POP
// end ; end ;
29368: LD_VAR 0 7
29372: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
29373: LD_INT 0
29375: PPUSH
29376: PPUSH
29377: PPUSH
29378: PPUSH
29379: PPUSH
29380: PPUSH
29381: PPUSH
29382: PPUSH
29383: PPUSH
29384: PPUSH
29385: PPUSH
29386: PPUSH
29387: PPUSH
29388: PPUSH
29389: PPUSH
29390: PPUSH
// result := false ;
29391: LD_ADDR_VAR 0 3
29395: PUSH
29396: LD_INT 0
29398: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
29399: LD_VAR 0 1
29403: NOT
29404: PUSH
29405: LD_VAR 0 1
29409: PPUSH
29410: CALL_OW 266
29414: PUSH
29415: LD_INT 32
29417: PUSH
29418: LD_INT 33
29420: PUSH
29421: EMPTY
29422: LIST
29423: LIST
29424: IN
29425: NOT
29426: OR
29427: IFFALSE 29431
// exit ;
29429: GO 30540
// nat := GetNation ( tower ) ;
29431: LD_ADDR_VAR 0 12
29435: PUSH
29436: LD_VAR 0 1
29440: PPUSH
29441: CALL_OW 248
29445: ST_TO_ADDR
// side := GetSide ( tower ) ;
29446: LD_ADDR_VAR 0 16
29450: PUSH
29451: LD_VAR 0 1
29455: PPUSH
29456: CALL_OW 255
29460: ST_TO_ADDR
// x := GetX ( tower ) ;
29461: LD_ADDR_VAR 0 10
29465: PUSH
29466: LD_VAR 0 1
29470: PPUSH
29471: CALL_OW 250
29475: ST_TO_ADDR
// y := GetY ( tower ) ;
29476: LD_ADDR_VAR 0 11
29480: PUSH
29481: LD_VAR 0 1
29485: PPUSH
29486: CALL_OW 251
29490: ST_TO_ADDR
// if not x or not y then
29491: LD_VAR 0 10
29495: NOT
29496: PUSH
29497: LD_VAR 0 11
29501: NOT
29502: OR
29503: IFFALSE 29507
// exit ;
29505: GO 30540
// weapon := 0 ;
29507: LD_ADDR_VAR 0 18
29511: PUSH
29512: LD_INT 0
29514: ST_TO_ADDR
// fac_list := [ ] ;
29515: LD_ADDR_VAR 0 17
29519: PUSH
29520: EMPTY
29521: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area , false ) , [ f_btype , b_factory ] ) ;
29522: LD_ADDR_VAR 0 6
29526: PUSH
29527: LD_VAR 0 1
29531: PPUSH
29532: CALL_OW 274
29536: PPUSH
29537: LD_VAR 0 2
29541: PPUSH
29542: LD_INT 0
29544: PPUSH
29545: CALL 27111 0 3
29549: PPUSH
29550: LD_INT 30
29552: PUSH
29553: LD_INT 3
29555: PUSH
29556: EMPTY
29557: LIST
29558: LIST
29559: PPUSH
29560: CALL_OW 72
29564: ST_TO_ADDR
// if not factories then
29565: LD_VAR 0 6
29569: NOT
29570: IFFALSE 29574
// exit ;
29572: GO 30540
// for i in factories do
29574: LD_ADDR_VAR 0 8
29578: PUSH
29579: LD_VAR 0 6
29583: PUSH
29584: FOR_IN
29585: IFFALSE 29610
// fac_list := fac_list union AvailableWeaponList ( i ) ;
29587: LD_ADDR_VAR 0 17
29591: PUSH
29592: LD_VAR 0 17
29596: PUSH
29597: LD_VAR 0 8
29601: PPUSH
29602: CALL_OW 478
29606: UNION
29607: ST_TO_ADDR
29608: GO 29584
29610: POP
29611: POP
// if not fac_list then
29612: LD_VAR 0 17
29616: NOT
29617: IFFALSE 29621
// exit ;
29619: GO 30540
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
29621: LD_ADDR_VAR 0 5
29625: PUSH
29626: LD_INT 4
29628: PUSH
29629: LD_INT 5
29631: PUSH
29632: LD_INT 9
29634: PUSH
29635: LD_INT 10
29637: PUSH
29638: LD_INT 6
29640: PUSH
29641: LD_INT 7
29643: PUSH
29644: LD_INT 11
29646: PUSH
29647: EMPTY
29648: LIST
29649: LIST
29650: LIST
29651: LIST
29652: LIST
29653: LIST
29654: LIST
29655: PUSH
29656: LD_INT 27
29658: PUSH
29659: LD_INT 28
29661: PUSH
29662: LD_INT 26
29664: PUSH
29665: LD_INT 30
29667: PUSH
29668: EMPTY
29669: LIST
29670: LIST
29671: LIST
29672: LIST
29673: PUSH
29674: LD_INT 43
29676: PUSH
29677: LD_INT 44
29679: PUSH
29680: LD_INT 46
29682: PUSH
29683: LD_INT 45
29685: PUSH
29686: LD_INT 47
29688: PUSH
29689: LD_INT 49
29691: PUSH
29692: EMPTY
29693: LIST
29694: LIST
29695: LIST
29696: LIST
29697: LIST
29698: LIST
29699: PUSH
29700: EMPTY
29701: LIST
29702: LIST
29703: LIST
29704: PUSH
29705: LD_VAR 0 12
29709: ARRAY
29710: ST_TO_ADDR
// list := list isect fac_list ;
29711: LD_ADDR_VAR 0 5
29715: PUSH
29716: LD_VAR 0 5
29720: PUSH
29721: LD_VAR 0 17
29725: ISECT
29726: ST_TO_ADDR
// if not list then
29727: LD_VAR 0 5
29731: NOT
29732: IFFALSE 29736
// exit ;
29734: GO 30540
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
29736: LD_VAR 0 12
29740: PUSH
29741: LD_INT 3
29743: EQUAL
29744: PUSH
29745: LD_INT 49
29747: PUSH
29748: LD_VAR 0 5
29752: IN
29753: AND
29754: PUSH
29755: LD_INT 31
29757: PPUSH
29758: LD_VAR 0 16
29762: PPUSH
29763: CALL_OW 321
29767: PUSH
29768: LD_INT 2
29770: EQUAL
29771: AND
29772: IFFALSE 29832
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
29774: LD_INT 22
29776: PUSH
29777: LD_VAR 0 16
29781: PUSH
29782: EMPTY
29783: LIST
29784: LIST
29785: PUSH
29786: LD_INT 35
29788: PUSH
29789: LD_INT 49
29791: PUSH
29792: EMPTY
29793: LIST
29794: LIST
29795: PUSH
29796: LD_INT 91
29798: PUSH
29799: LD_VAR 0 1
29803: PUSH
29804: LD_INT 10
29806: PUSH
29807: EMPTY
29808: LIST
29809: LIST
29810: LIST
29811: PUSH
29812: EMPTY
29813: LIST
29814: LIST
29815: LIST
29816: PPUSH
29817: CALL_OW 69
29821: NOT
29822: IFFALSE 29832
// weapon := ru_time_lapser ;
29824: LD_ADDR_VAR 0 18
29828: PUSH
29829: LD_INT 49
29831: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
29832: LD_VAR 0 12
29836: PUSH
29837: LD_INT 1
29839: PUSH
29840: LD_INT 2
29842: PUSH
29843: EMPTY
29844: LIST
29845: LIST
29846: IN
29847: PUSH
29848: LD_INT 11
29850: PUSH
29851: LD_VAR 0 5
29855: IN
29856: PUSH
29857: LD_INT 30
29859: PUSH
29860: LD_VAR 0 5
29864: IN
29865: OR
29866: AND
29867: PUSH
29868: LD_INT 6
29870: PPUSH
29871: LD_VAR 0 16
29875: PPUSH
29876: CALL_OW 321
29880: PUSH
29881: LD_INT 2
29883: EQUAL
29884: AND
29885: IFFALSE 30050
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
29887: LD_INT 22
29889: PUSH
29890: LD_VAR 0 16
29894: PUSH
29895: EMPTY
29896: LIST
29897: LIST
29898: PUSH
29899: LD_INT 2
29901: PUSH
29902: LD_INT 35
29904: PUSH
29905: LD_INT 11
29907: PUSH
29908: EMPTY
29909: LIST
29910: LIST
29911: PUSH
29912: LD_INT 35
29914: PUSH
29915: LD_INT 30
29917: PUSH
29918: EMPTY
29919: LIST
29920: LIST
29921: PUSH
29922: EMPTY
29923: LIST
29924: LIST
29925: LIST
29926: PUSH
29927: LD_INT 91
29929: PUSH
29930: LD_VAR 0 1
29934: PUSH
29935: LD_INT 18
29937: PUSH
29938: EMPTY
29939: LIST
29940: LIST
29941: LIST
29942: PUSH
29943: EMPTY
29944: LIST
29945: LIST
29946: LIST
29947: PPUSH
29948: CALL_OW 69
29952: NOT
29953: PUSH
29954: LD_INT 22
29956: PUSH
29957: LD_VAR 0 16
29961: PUSH
29962: EMPTY
29963: LIST
29964: LIST
29965: PUSH
29966: LD_INT 2
29968: PUSH
29969: LD_INT 30
29971: PUSH
29972: LD_INT 32
29974: PUSH
29975: EMPTY
29976: LIST
29977: LIST
29978: PUSH
29979: LD_INT 30
29981: PUSH
29982: LD_INT 33
29984: PUSH
29985: EMPTY
29986: LIST
29987: LIST
29988: PUSH
29989: EMPTY
29990: LIST
29991: LIST
29992: LIST
29993: PUSH
29994: LD_INT 91
29996: PUSH
29997: LD_VAR 0 1
30001: PUSH
30002: LD_INT 12
30004: PUSH
30005: EMPTY
30006: LIST
30007: LIST
30008: LIST
30009: PUSH
30010: EMPTY
30011: LIST
30012: LIST
30013: LIST
30014: PUSH
30015: EMPTY
30016: LIST
30017: PPUSH
30018: CALL_OW 69
30022: PUSH
30023: LD_INT 2
30025: GREATER
30026: AND
30027: IFFALSE 30050
// weapon := [ us_radar , ar_radar ] [ nat ] ;
30029: LD_ADDR_VAR 0 18
30033: PUSH
30034: LD_INT 11
30036: PUSH
30037: LD_INT 30
30039: PUSH
30040: EMPTY
30041: LIST
30042: LIST
30043: PUSH
30044: LD_VAR 0 12
30048: ARRAY
30049: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
30050: LD_VAR 0 18
30054: NOT
30055: PUSH
30056: LD_INT 40
30058: PPUSH
30059: LD_VAR 0 16
30063: PPUSH
30064: CALL_OW 321
30068: PUSH
30069: LD_INT 2
30071: EQUAL
30072: AND
30073: PUSH
30074: LD_INT 7
30076: PUSH
30077: LD_VAR 0 5
30081: IN
30082: PUSH
30083: LD_INT 28
30085: PUSH
30086: LD_VAR 0 5
30090: IN
30091: OR
30092: PUSH
30093: LD_INT 45
30095: PUSH
30096: LD_VAR 0 5
30100: IN
30101: OR
30102: AND
30103: IFFALSE 30357
// begin hex := GetHexInfo ( x , y ) ;
30105: LD_ADDR_VAR 0 4
30109: PUSH
30110: LD_VAR 0 10
30114: PPUSH
30115: LD_VAR 0 11
30119: PPUSH
30120: CALL_OW 546
30124: ST_TO_ADDR
// if hex [ 1 ] then
30125: LD_VAR 0 4
30129: PUSH
30130: LD_INT 1
30132: ARRAY
30133: IFFALSE 30137
// exit ;
30135: GO 30540
// height := hex [ 2 ] ;
30137: LD_ADDR_VAR 0 15
30141: PUSH
30142: LD_VAR 0 4
30146: PUSH
30147: LD_INT 2
30149: ARRAY
30150: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
30151: LD_ADDR_VAR 0 14
30155: PUSH
30156: LD_INT 0
30158: PUSH
30159: LD_INT 2
30161: PUSH
30162: LD_INT 3
30164: PUSH
30165: LD_INT 5
30167: PUSH
30168: EMPTY
30169: LIST
30170: LIST
30171: LIST
30172: LIST
30173: ST_TO_ADDR
// for i in tmp do
30174: LD_ADDR_VAR 0 8
30178: PUSH
30179: LD_VAR 0 14
30183: PUSH
30184: FOR_IN
30185: IFFALSE 30355
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
30187: LD_ADDR_VAR 0 9
30191: PUSH
30192: LD_VAR 0 10
30196: PPUSH
30197: LD_VAR 0 8
30201: PPUSH
30202: LD_INT 5
30204: PPUSH
30205: CALL_OW 272
30209: PUSH
30210: LD_VAR 0 11
30214: PPUSH
30215: LD_VAR 0 8
30219: PPUSH
30220: LD_INT 5
30222: PPUSH
30223: CALL_OW 273
30227: PUSH
30228: EMPTY
30229: LIST
30230: LIST
30231: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
30232: LD_VAR 0 9
30236: PUSH
30237: LD_INT 1
30239: ARRAY
30240: PPUSH
30241: LD_VAR 0 9
30245: PUSH
30246: LD_INT 2
30248: ARRAY
30249: PPUSH
30250: CALL_OW 488
30254: IFFALSE 30353
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
30256: LD_ADDR_VAR 0 4
30260: PUSH
30261: LD_VAR 0 9
30265: PUSH
30266: LD_INT 1
30268: ARRAY
30269: PPUSH
30270: LD_VAR 0 9
30274: PUSH
30275: LD_INT 2
30277: ARRAY
30278: PPUSH
30279: CALL_OW 546
30283: ST_TO_ADDR
// if hex [ 1 ] then
30284: LD_VAR 0 4
30288: PUSH
30289: LD_INT 1
30291: ARRAY
30292: IFFALSE 30296
// continue ;
30294: GO 30184
// h := hex [ 2 ] ;
30296: LD_ADDR_VAR 0 13
30300: PUSH
30301: LD_VAR 0 4
30305: PUSH
30306: LD_INT 2
30308: ARRAY
30309: ST_TO_ADDR
// if h + 7 < height then
30310: LD_VAR 0 13
30314: PUSH
30315: LD_INT 7
30317: PLUS
30318: PUSH
30319: LD_VAR 0 15
30323: LESS
30324: IFFALSE 30353
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
30326: LD_ADDR_VAR 0 18
30330: PUSH
30331: LD_INT 7
30333: PUSH
30334: LD_INT 28
30336: PUSH
30337: LD_INT 45
30339: PUSH
30340: EMPTY
30341: LIST
30342: LIST
30343: LIST
30344: PUSH
30345: LD_VAR 0 12
30349: ARRAY
30350: ST_TO_ADDR
// break ;
30351: GO 30355
// end ; end ; end ;
30353: GO 30184
30355: POP
30356: POP
// end ; if not weapon then
30357: LD_VAR 0 18
30361: NOT
30362: IFFALSE 30422
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
30364: LD_ADDR_VAR 0 5
30368: PUSH
30369: LD_VAR 0 5
30373: PUSH
30374: LD_INT 11
30376: PUSH
30377: LD_INT 30
30379: PUSH
30380: LD_INT 49
30382: PUSH
30383: EMPTY
30384: LIST
30385: LIST
30386: LIST
30387: DIFF
30388: ST_TO_ADDR
// if not list then
30389: LD_VAR 0 5
30393: NOT
30394: IFFALSE 30398
// exit ;
30396: GO 30540
// weapon := list [ rand ( 1 , list ) ] ;
30398: LD_ADDR_VAR 0 18
30402: PUSH
30403: LD_VAR 0 5
30407: PUSH
30408: LD_INT 1
30410: PPUSH
30411: LD_VAR 0 5
30415: PPUSH
30416: CALL_OW 12
30420: ARRAY
30421: ST_TO_ADDR
// end ; if weapon then
30422: LD_VAR 0 18
30426: IFFALSE 30540
// begin tmp := CostOfWeapon ( weapon ) ;
30428: LD_ADDR_VAR 0 14
30432: PUSH
30433: LD_VAR 0 18
30437: PPUSH
30438: CALL_OW 451
30442: ST_TO_ADDR
// j := GetBase ( tower ) ;
30443: LD_ADDR_VAR 0 9
30447: PUSH
30448: LD_VAR 0 1
30452: PPUSH
30453: CALL_OW 274
30457: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
30458: LD_VAR 0 9
30462: PPUSH
30463: LD_INT 1
30465: PPUSH
30466: CALL_OW 275
30470: PUSH
30471: LD_VAR 0 14
30475: PUSH
30476: LD_INT 1
30478: ARRAY
30479: GREATEREQUAL
30480: PUSH
30481: LD_VAR 0 9
30485: PPUSH
30486: LD_INT 2
30488: PPUSH
30489: CALL_OW 275
30493: PUSH
30494: LD_VAR 0 14
30498: PUSH
30499: LD_INT 2
30501: ARRAY
30502: GREATEREQUAL
30503: AND
30504: PUSH
30505: LD_VAR 0 9
30509: PPUSH
30510: LD_INT 3
30512: PPUSH
30513: CALL_OW 275
30517: PUSH
30518: LD_VAR 0 14
30522: PUSH
30523: LD_INT 3
30525: ARRAY
30526: GREATEREQUAL
30527: AND
30528: IFFALSE 30540
// result := weapon ;
30530: LD_ADDR_VAR 0 3
30534: PUSH
30535: LD_VAR 0 18
30539: ST_TO_ADDR
// end ; end ;
30540: LD_VAR 0 3
30544: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
30545: LD_INT 0
30547: PPUSH
30548: PPUSH
// result := true ;
30549: LD_ADDR_VAR 0 3
30553: PUSH
30554: LD_INT 1
30556: ST_TO_ADDR
// if array1 = array2 then
30557: LD_VAR 0 1
30561: PUSH
30562: LD_VAR 0 2
30566: EQUAL
30567: IFFALSE 30627
// begin for i = 1 to array1 do
30569: LD_ADDR_VAR 0 4
30573: PUSH
30574: DOUBLE
30575: LD_INT 1
30577: DEC
30578: ST_TO_ADDR
30579: LD_VAR 0 1
30583: PUSH
30584: FOR_TO
30585: IFFALSE 30623
// if array1 [ i ] <> array2 [ i ] then
30587: LD_VAR 0 1
30591: PUSH
30592: LD_VAR 0 4
30596: ARRAY
30597: PUSH
30598: LD_VAR 0 2
30602: PUSH
30603: LD_VAR 0 4
30607: ARRAY
30608: NONEQUAL
30609: IFFALSE 30621
// begin result := false ;
30611: LD_ADDR_VAR 0 3
30615: PUSH
30616: LD_INT 0
30618: ST_TO_ADDR
// break ;
30619: GO 30623
// end ;
30621: GO 30584
30623: POP
30624: POP
// end else
30625: GO 30635
// result := false ;
30627: LD_ADDR_VAR 0 3
30631: PUSH
30632: LD_INT 0
30634: ST_TO_ADDR
// end ;
30635: LD_VAR 0 3
30639: RET
// export function CompareArrayValues ( array1 , array2 ) ; var i ; begin
30640: LD_INT 0
30642: PPUSH
30643: PPUSH
// if not array1 or not array2 then
30644: LD_VAR 0 1
30648: NOT
30649: PUSH
30650: LD_VAR 0 2
30654: NOT
30655: OR
30656: IFFALSE 30660
// exit ;
30658: GO 30724
// result := true ;
30660: LD_ADDR_VAR 0 3
30664: PUSH
30665: LD_INT 1
30667: ST_TO_ADDR
// for i = 1 to array1 do
30668: LD_ADDR_VAR 0 4
30672: PUSH
30673: DOUBLE
30674: LD_INT 1
30676: DEC
30677: ST_TO_ADDR
30678: LD_VAR 0 1
30682: PUSH
30683: FOR_TO
30684: IFFALSE 30722
// if array1 [ i ] <> array2 [ i ] then
30686: LD_VAR 0 1
30690: PUSH
30691: LD_VAR 0 4
30695: ARRAY
30696: PUSH
30697: LD_VAR 0 2
30701: PUSH
30702: LD_VAR 0 4
30706: ARRAY
30707: NONEQUAL
30708: IFFALSE 30720
// begin result := false ;
30710: LD_ADDR_VAR 0 3
30714: PUSH
30715: LD_INT 0
30717: ST_TO_ADDR
// break ;
30718: GO 30722
// end ;
30720: GO 30683
30722: POP
30723: POP
// end ;
30724: LD_VAR 0 3
30728: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
30729: LD_INT 0
30731: PPUSH
30732: PPUSH
30733: PPUSH
// pom := GetBase ( fac ) ;
30734: LD_ADDR_VAR 0 5
30738: PUSH
30739: LD_VAR 0 1
30743: PPUSH
30744: CALL_OW 274
30748: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
30749: LD_ADDR_VAR 0 4
30753: PUSH
30754: LD_VAR 0 2
30758: PUSH
30759: LD_INT 1
30761: ARRAY
30762: PPUSH
30763: LD_VAR 0 2
30767: PUSH
30768: LD_INT 2
30770: ARRAY
30771: PPUSH
30772: LD_VAR 0 2
30776: PUSH
30777: LD_INT 3
30779: ARRAY
30780: PPUSH
30781: LD_VAR 0 2
30785: PUSH
30786: LD_INT 4
30788: ARRAY
30789: PPUSH
30790: CALL_OW 449
30794: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
30795: LD_ADDR_VAR 0 3
30799: PUSH
30800: LD_VAR 0 5
30804: PPUSH
30805: LD_INT 1
30807: PPUSH
30808: CALL_OW 275
30812: PUSH
30813: LD_VAR 0 4
30817: PUSH
30818: LD_INT 1
30820: ARRAY
30821: GREATEREQUAL
30822: PUSH
30823: LD_VAR 0 5
30827: PPUSH
30828: LD_INT 2
30830: PPUSH
30831: CALL_OW 275
30835: PUSH
30836: LD_VAR 0 4
30840: PUSH
30841: LD_INT 2
30843: ARRAY
30844: GREATEREQUAL
30845: AND
30846: PUSH
30847: LD_VAR 0 5
30851: PPUSH
30852: LD_INT 3
30854: PPUSH
30855: CALL_OW 275
30859: PUSH
30860: LD_VAR 0 4
30864: PUSH
30865: LD_INT 3
30867: ARRAY
30868: GREATEREQUAL
30869: AND
30870: ST_TO_ADDR
// end ;
30871: LD_VAR 0 3
30875: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
30876: LD_INT 0
30878: PPUSH
30879: PPUSH
30880: PPUSH
30881: PPUSH
// pom := GetBase ( building ) ;
30882: LD_ADDR_VAR 0 3
30886: PUSH
30887: LD_VAR 0 1
30891: PPUSH
30892: CALL_OW 274
30896: ST_TO_ADDR
// if not pom then
30897: LD_VAR 0 3
30901: NOT
30902: IFFALSE 30906
// exit ;
30904: GO 31076
// btype := GetBType ( building ) ;
30906: LD_ADDR_VAR 0 5
30910: PUSH
30911: LD_VAR 0 1
30915: PPUSH
30916: CALL_OW 266
30920: ST_TO_ADDR
// if btype = b_armoury then
30921: LD_VAR 0 5
30925: PUSH
30926: LD_INT 4
30928: EQUAL
30929: IFFALSE 30939
// btype := b_barracks ;
30931: LD_ADDR_VAR 0 5
30935: PUSH
30936: LD_INT 5
30938: ST_TO_ADDR
// if btype = b_depot then
30939: LD_VAR 0 5
30943: PUSH
30944: LD_INT 0
30946: EQUAL
30947: IFFALSE 30957
// btype := b_warehouse ;
30949: LD_ADDR_VAR 0 5
30953: PUSH
30954: LD_INT 1
30956: ST_TO_ADDR
// if btype = b_workshop then
30957: LD_VAR 0 5
30961: PUSH
30962: LD_INT 2
30964: EQUAL
30965: IFFALSE 30975
// btype := b_factory ;
30967: LD_ADDR_VAR 0 5
30971: PUSH
30972: LD_INT 3
30974: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
30975: LD_ADDR_VAR 0 4
30979: PUSH
30980: LD_VAR 0 5
30984: PPUSH
30985: LD_VAR 0 1
30989: PPUSH
30990: CALL_OW 248
30994: PPUSH
30995: CALL_OW 450
30999: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
31000: LD_ADDR_VAR 0 2
31004: PUSH
31005: LD_VAR 0 3
31009: PPUSH
31010: LD_INT 1
31012: PPUSH
31013: CALL_OW 275
31017: PUSH
31018: LD_VAR 0 4
31022: PUSH
31023: LD_INT 1
31025: ARRAY
31026: GREATEREQUAL
31027: PUSH
31028: LD_VAR 0 3
31032: PPUSH
31033: LD_INT 2
31035: PPUSH
31036: CALL_OW 275
31040: PUSH
31041: LD_VAR 0 4
31045: PUSH
31046: LD_INT 2
31048: ARRAY
31049: GREATEREQUAL
31050: AND
31051: PUSH
31052: LD_VAR 0 3
31056: PPUSH
31057: LD_INT 3
31059: PPUSH
31060: CALL_OW 275
31064: PUSH
31065: LD_VAR 0 4
31069: PUSH
31070: LD_INT 3
31072: ARRAY
31073: GREATEREQUAL
31074: AND
31075: ST_TO_ADDR
// end ;
31076: LD_VAR 0 2
31080: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
31081: LD_INT 0
31083: PPUSH
31084: PPUSH
31085: PPUSH
// pom := GetBase ( building ) ;
31086: LD_ADDR_VAR 0 4
31090: PUSH
31091: LD_VAR 0 1
31095: PPUSH
31096: CALL_OW 274
31100: ST_TO_ADDR
// if not pom then
31101: LD_VAR 0 4
31105: NOT
31106: IFFALSE 31110
// exit ;
31108: GO 31211
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
31110: LD_ADDR_VAR 0 5
31114: PUSH
31115: LD_VAR 0 2
31119: PPUSH
31120: LD_VAR 0 1
31124: PPUSH
31125: CALL_OW 248
31129: PPUSH
31130: CALL_OW 450
31134: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
31135: LD_ADDR_VAR 0 3
31139: PUSH
31140: LD_VAR 0 4
31144: PPUSH
31145: LD_INT 1
31147: PPUSH
31148: CALL_OW 275
31152: PUSH
31153: LD_VAR 0 5
31157: PUSH
31158: LD_INT 1
31160: ARRAY
31161: GREATEREQUAL
31162: PUSH
31163: LD_VAR 0 4
31167: PPUSH
31168: LD_INT 2
31170: PPUSH
31171: CALL_OW 275
31175: PUSH
31176: LD_VAR 0 5
31180: PUSH
31181: LD_INT 2
31183: ARRAY
31184: GREATEREQUAL
31185: AND
31186: PUSH
31187: LD_VAR 0 4
31191: PPUSH
31192: LD_INT 3
31194: PPUSH
31195: CALL_OW 275
31199: PUSH
31200: LD_VAR 0 5
31204: PUSH
31205: LD_INT 3
31207: ARRAY
31208: GREATEREQUAL
31209: AND
31210: ST_TO_ADDR
// end ;
31211: LD_VAR 0 3
31215: RET
// export function TryClearPlaceForBuilding ( btype , x , y , d , buildings , cleaners , parking ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep , driver ; begin
31216: LD_INT 0
31218: PPUSH
31219: PPUSH
31220: PPUSH
31221: PPUSH
31222: PPUSH
31223: PPUSH
31224: PPUSH
31225: PPUSH
31226: PPUSH
31227: PPUSH
31228: PPUSH
// result := false ;
31229: LD_ADDR_VAR 0 8
31233: PUSH
31234: LD_INT 0
31236: ST_TO_ADDR
// if not buildings or not btype or not x or not y then
31237: LD_VAR 0 5
31241: NOT
31242: PUSH
31243: LD_VAR 0 1
31247: NOT
31248: OR
31249: PUSH
31250: LD_VAR 0 2
31254: NOT
31255: OR
31256: PUSH
31257: LD_VAR 0 3
31261: NOT
31262: OR
31263: IFFALSE 31267
// exit ;
31265: GO 32081
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( buildings [ 1 ] ) , 0 ) ;
31267: LD_ADDR_VAR 0 14
31271: PUSH
31272: LD_VAR 0 1
31276: PPUSH
31277: LD_VAR 0 2
31281: PPUSH
31282: LD_VAR 0 3
31286: PPUSH
31287: LD_VAR 0 4
31291: PPUSH
31292: LD_VAR 0 5
31296: PUSH
31297: LD_INT 1
31299: ARRAY
31300: PPUSH
31301: CALL_OW 248
31305: PPUSH
31306: LD_INT 0
31308: PPUSH
31309: CALL 33318 0 6
31313: ST_TO_ADDR
// if not hexes then
31314: LD_VAR 0 14
31318: NOT
31319: IFFALSE 31323
// exit ;
31321: GO 32081
// dep := UnitFilter ( buildings , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
31323: LD_ADDR_VAR 0 17
31327: PUSH
31328: LD_VAR 0 5
31332: PPUSH
31333: LD_INT 22
31335: PUSH
31336: LD_VAR 0 13
31340: PPUSH
31341: CALL_OW 255
31345: PUSH
31346: EMPTY
31347: LIST
31348: LIST
31349: PUSH
31350: LD_INT 2
31352: PUSH
31353: LD_INT 30
31355: PUSH
31356: LD_INT 0
31358: PUSH
31359: EMPTY
31360: LIST
31361: LIST
31362: PUSH
31363: LD_INT 30
31365: PUSH
31366: LD_INT 1
31368: PUSH
31369: EMPTY
31370: LIST
31371: LIST
31372: PUSH
31373: EMPTY
31374: LIST
31375: LIST
31376: LIST
31377: PUSH
31378: EMPTY
31379: LIST
31380: LIST
31381: PPUSH
31382: CALL_OW 72
31386: ST_TO_ADDR
// for i = 1 to hexes do
31387: LD_ADDR_VAR 0 9
31391: PUSH
31392: DOUBLE
31393: LD_INT 1
31395: DEC
31396: ST_TO_ADDR
31397: LD_VAR 0 14
31401: PUSH
31402: FOR_TO
31403: IFFALSE 32079
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
31405: LD_ADDR_VAR 0 13
31409: PUSH
31410: LD_VAR 0 14
31414: PUSH
31415: LD_VAR 0 9
31419: ARRAY
31420: PUSH
31421: LD_INT 1
31423: ARRAY
31424: PPUSH
31425: LD_VAR 0 14
31429: PUSH
31430: LD_VAR 0 9
31434: ARRAY
31435: PUSH
31436: LD_INT 2
31438: ARRAY
31439: PPUSH
31440: CALL_OW 428
31444: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
31445: LD_VAR 0 14
31449: PUSH
31450: LD_VAR 0 9
31454: ARRAY
31455: PUSH
31456: LD_INT 1
31458: ARRAY
31459: PPUSH
31460: LD_VAR 0 14
31464: PUSH
31465: LD_VAR 0 9
31469: ARRAY
31470: PUSH
31471: LD_INT 2
31473: ARRAY
31474: PPUSH
31475: CALL_OW 351
31479: PUSH
31480: LD_VAR 0 14
31484: PUSH
31485: LD_VAR 0 9
31489: ARRAY
31490: PUSH
31491: LD_INT 1
31493: ARRAY
31494: PPUSH
31495: LD_VAR 0 14
31499: PUSH
31500: LD_VAR 0 9
31504: ARRAY
31505: PUSH
31506: LD_INT 2
31508: ARRAY
31509: PPUSH
31510: CALL_OW 488
31514: NOT
31515: OR
31516: PUSH
31517: LD_VAR 0 13
31521: PPUSH
31522: CALL_OW 247
31526: PUSH
31527: LD_INT 3
31529: EQUAL
31530: OR
31531: IFFALSE 31537
// exit ;
31533: POP
31534: POP
31535: GO 32081
// if not tmp then
31537: LD_VAR 0 13
31541: NOT
31542: IFFALSE 31546
// continue ;
31544: GO 31402
// result := true ;
31546: LD_ADDR_VAR 0 8
31550: PUSH
31551: LD_INT 1
31553: ST_TO_ADDR
// if cleaners and GetType ( tmp ) = unit_vehicle and GetControl ( tmp ) = control_manual then
31554: LD_VAR 0 6
31558: PUSH
31559: LD_VAR 0 13
31563: PPUSH
31564: CALL_OW 247
31568: PUSH
31569: LD_INT 2
31571: EQUAL
31572: AND
31573: PUSH
31574: LD_VAR 0 13
31578: PPUSH
31579: CALL_OW 263
31583: PUSH
31584: LD_INT 1
31586: EQUAL
31587: AND
31588: IFFALSE 31752
// begin if IsDrivenBy ( tmp ) then
31590: LD_VAR 0 13
31594: PPUSH
31595: CALL_OW 311
31599: IFFALSE 31603
// continue ;
31601: GO 31402
// if UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) then
31603: LD_VAR 0 6
31607: PPUSH
31608: LD_INT 3
31610: PUSH
31611: LD_INT 60
31613: PUSH
31614: EMPTY
31615: LIST
31616: PUSH
31617: EMPTY
31618: LIST
31619: LIST
31620: PUSH
31621: LD_INT 3
31623: PUSH
31624: LD_INT 55
31626: PUSH
31627: EMPTY
31628: LIST
31629: PUSH
31630: EMPTY
31631: LIST
31632: LIST
31633: PUSH
31634: EMPTY
31635: LIST
31636: LIST
31637: PPUSH
31638: CALL_OW 72
31642: IFFALSE 31750
// begin driver := UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) [ 1 ] ;
31644: LD_ADDR_VAR 0 18
31648: PUSH
31649: LD_VAR 0 6
31653: PPUSH
31654: LD_INT 3
31656: PUSH
31657: LD_INT 60
31659: PUSH
31660: EMPTY
31661: LIST
31662: PUSH
31663: EMPTY
31664: LIST
31665: LIST
31666: PUSH
31667: LD_INT 3
31669: PUSH
31670: LD_INT 55
31672: PUSH
31673: EMPTY
31674: LIST
31675: PUSH
31676: EMPTY
31677: LIST
31678: LIST
31679: PUSH
31680: EMPTY
31681: LIST
31682: LIST
31683: PPUSH
31684: CALL_OW 72
31688: PUSH
31689: LD_INT 1
31691: ARRAY
31692: ST_TO_ADDR
// if IsInUnit ( driver ) then
31693: LD_VAR 0 18
31697: PPUSH
31698: CALL_OW 310
31702: IFFALSE 31713
// ComExit ( driver ) ;
31704: LD_VAR 0 18
31708: PPUSH
31709: CALL 57023 0 1
// AddComEnterUnit ( driver , tmp ) ;
31713: LD_VAR 0 18
31717: PPUSH
31718: LD_VAR 0 13
31722: PPUSH
31723: CALL_OW 180
// AddComMoveToArea ( driver , parking ) ;
31727: LD_VAR 0 18
31731: PPUSH
31732: LD_VAR 0 7
31736: PPUSH
31737: CALL_OW 173
// AddComExitVehicle ( driver ) ;
31741: LD_VAR 0 18
31745: PPUSH
31746: CALL_OW 181
// end ; continue ;
31750: GO 31402
// end ; if not cleaners or not tmp in cleaners then
31752: LD_VAR 0 6
31756: NOT
31757: PUSH
31758: LD_VAR 0 13
31762: PUSH
31763: LD_VAR 0 6
31767: IN
31768: NOT
31769: OR
31770: IFFALSE 32077
// begin if dep then
31772: LD_VAR 0 17
31776: IFFALSE 31912
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
31778: LD_ADDR_VAR 0 16
31782: PUSH
31783: LD_VAR 0 17
31787: PUSH
31788: LD_INT 1
31790: ARRAY
31791: PPUSH
31792: CALL_OW 250
31796: PPUSH
31797: LD_VAR 0 17
31801: PUSH
31802: LD_INT 1
31804: ARRAY
31805: PPUSH
31806: CALL_OW 254
31810: PPUSH
31811: LD_INT 5
31813: PPUSH
31814: CALL_OW 272
31818: PUSH
31819: LD_VAR 0 17
31823: PUSH
31824: LD_INT 1
31826: ARRAY
31827: PPUSH
31828: CALL_OW 251
31832: PPUSH
31833: LD_VAR 0 17
31837: PUSH
31838: LD_INT 1
31840: ARRAY
31841: PPUSH
31842: CALL_OW 254
31846: PPUSH
31847: LD_INT 5
31849: PPUSH
31850: CALL_OW 273
31854: PUSH
31855: EMPTY
31856: LIST
31857: LIST
31858: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
31859: LD_VAR 0 16
31863: PUSH
31864: LD_INT 1
31866: ARRAY
31867: PPUSH
31868: LD_VAR 0 16
31872: PUSH
31873: LD_INT 2
31875: ARRAY
31876: PPUSH
31877: CALL_OW 488
31881: IFFALSE 31912
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
31883: LD_VAR 0 13
31887: PPUSH
31888: LD_VAR 0 16
31892: PUSH
31893: LD_INT 1
31895: ARRAY
31896: PPUSH
31897: LD_VAR 0 16
31901: PUSH
31902: LD_INT 2
31904: ARRAY
31905: PPUSH
31906: CALL_OW 111
// continue ;
31910: GO 31402
// end ; end ; r := GetDir ( tmp ) ;
31912: LD_ADDR_VAR 0 15
31916: PUSH
31917: LD_VAR 0 13
31921: PPUSH
31922: CALL_OW 254
31926: ST_TO_ADDR
// if r = 5 then
31927: LD_VAR 0 15
31931: PUSH
31932: LD_INT 5
31934: EQUAL
31935: IFFALSE 31945
// r := 0 ;
31937: LD_ADDR_VAR 0 15
31941: PUSH
31942: LD_INT 0
31944: ST_TO_ADDR
// for j = r to 5 do
31945: LD_ADDR_VAR 0 10
31949: PUSH
31950: DOUBLE
31951: LD_VAR 0 15
31955: DEC
31956: ST_TO_ADDR
31957: LD_INT 5
31959: PUSH
31960: FOR_TO
31961: IFFALSE 32075
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
31963: LD_ADDR_VAR 0 11
31967: PUSH
31968: LD_VAR 0 13
31972: PPUSH
31973: CALL_OW 250
31977: PPUSH
31978: LD_VAR 0 10
31982: PPUSH
31983: LD_INT 2
31985: PPUSH
31986: CALL_OW 272
31990: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
31991: LD_ADDR_VAR 0 12
31995: PUSH
31996: LD_VAR 0 13
32000: PPUSH
32001: CALL_OW 251
32005: PPUSH
32006: LD_VAR 0 10
32010: PPUSH
32011: LD_INT 2
32013: PPUSH
32014: CALL_OW 273
32018: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
32019: LD_VAR 0 11
32023: PPUSH
32024: LD_VAR 0 12
32028: PPUSH
32029: CALL_OW 488
32033: PUSH
32034: LD_VAR 0 11
32038: PPUSH
32039: LD_VAR 0 12
32043: PPUSH
32044: CALL_OW 428
32048: NOT
32049: AND
32050: IFFALSE 32073
// begin ComMoveXY ( tmp , _x , _y ) ;
32052: LD_VAR 0 13
32056: PPUSH
32057: LD_VAR 0 11
32061: PPUSH
32062: LD_VAR 0 12
32066: PPUSH
32067: CALL_OW 111
// break ;
32071: GO 32075
// end ; end ;
32073: GO 31960
32075: POP
32076: POP
// end ; end ;
32077: GO 31402
32079: POP
32080: POP
// end ;
32081: LD_VAR 0 8
32085: RET
// export function BuildingTechInvented ( side , btype ) ; begin
32086: LD_INT 0
32088: PPUSH
// result := true ;
32089: LD_ADDR_VAR 0 3
32093: PUSH
32094: LD_INT 1
32096: ST_TO_ADDR
// case btype of b_ext_computer , b_turret :
32097: LD_VAR 0 2
32101: PUSH
32102: LD_INT 24
32104: DOUBLE
32105: EQUAL
32106: IFTRUE 32116
32108: LD_INT 33
32110: DOUBLE
32111: EQUAL
32112: IFTRUE 32116
32114: GO 32141
32116: POP
// result := ( GetTech ( tech_ai , side ) = state_researched ) ; b_ext_radar :
32117: LD_ADDR_VAR 0 3
32121: PUSH
32122: LD_INT 32
32124: PPUSH
32125: LD_VAR 0 1
32129: PPUSH
32130: CALL_OW 321
32134: PUSH
32135: LD_INT 2
32137: EQUAL
32138: ST_TO_ADDR
32139: GO 32461
32141: LD_INT 20
32143: DOUBLE
32144: EQUAL
32145: IFTRUE 32149
32147: GO 32174
32149: POP
// result := ( GetTech ( tech_radar , side ) = state_researched ) ; b_ext_radio , b_control_tower :
32150: LD_ADDR_VAR 0 3
32154: PUSH
32155: LD_INT 6
32157: PPUSH
32158: LD_VAR 0 1
32162: PPUSH
32163: CALL_OW 321
32167: PUSH
32168: LD_INT 2
32170: EQUAL
32171: ST_TO_ADDR
32172: GO 32461
32174: LD_INT 22
32176: DOUBLE
32177: EQUAL
32178: IFTRUE 32188
32180: LD_INT 36
32182: DOUBLE
32183: EQUAL
32184: IFTRUE 32188
32186: GO 32213
32188: POP
// result := ( GetTech ( tech_remcont , side ) = state_researched ) ; b_siberite_mine :
32189: LD_ADDR_VAR 0 3
32193: PUSH
32194: LD_INT 15
32196: PPUSH
32197: LD_VAR 0 1
32201: PPUSH
32202: CALL_OW 321
32206: PUSH
32207: LD_INT 2
32209: EQUAL
32210: ST_TO_ADDR
32211: GO 32461
32213: LD_INT 30
32215: DOUBLE
32216: EQUAL
32217: IFTRUE 32221
32219: GO 32246
32221: POP
// result := ( GetTech ( tech_sibdet , side ) = state_researched ) ; b_siberite_power , b_ext_siberium :
32222: LD_ADDR_VAR 0 3
32226: PUSH
32227: LD_INT 20
32229: PPUSH
32230: LD_VAR 0 1
32234: PPUSH
32235: CALL_OW 321
32239: PUSH
32240: LD_INT 2
32242: EQUAL
32243: ST_TO_ADDR
32244: GO 32461
32246: LD_INT 28
32248: DOUBLE
32249: EQUAL
32250: IFTRUE 32260
32252: LD_INT 21
32254: DOUBLE
32255: EQUAL
32256: IFTRUE 32260
32258: GO 32285
32260: POP
// result := ( GetTech ( tech_sibpow , side ) = state_researched ) ; b_ext_track :
32261: LD_ADDR_VAR 0 3
32265: PUSH
32266: LD_INT 21
32268: PPUSH
32269: LD_VAR 0 1
32273: PPUSH
32274: CALL_OW 321
32278: PUSH
32279: LD_INT 2
32281: EQUAL
32282: ST_TO_ADDR
32283: GO 32461
32285: LD_INT 16
32287: DOUBLE
32288: EQUAL
32289: IFTRUE 32293
32291: GO 32320
32293: POP
// result := ( GetTech ( tech_track , side ) = state_researched ) ; b_ext_noncombat , b_ext_stitch :
32294: LD_ADDR_VAR 0 3
32298: PUSH
32299: LD_EXP 171
32303: PPUSH
32304: LD_VAR 0 1
32308: PPUSH
32309: CALL_OW 321
32313: PUSH
32314: LD_INT 2
32316: EQUAL
32317: ST_TO_ADDR
32318: GO 32461
32320: LD_INT 19
32322: DOUBLE
32323: EQUAL
32324: IFTRUE 32334
32326: LD_INT 23
32328: DOUBLE
32329: EQUAL
32330: IFTRUE 32334
32332: GO 32361
32334: POP
// result := ( GetTech ( tech_cargo , side ) = state_researched ) ; b_ext_gun :
32335: LD_ADDR_VAR 0 3
32339: PUSH
32340: LD_EXP 170
32344: PPUSH
32345: LD_VAR 0 1
32349: PPUSH
32350: CALL_OW 321
32354: PUSH
32355: LD_INT 2
32357: EQUAL
32358: ST_TO_ADDR
32359: GO 32461
32361: LD_INT 17
32363: DOUBLE
32364: EQUAL
32365: IFTRUE 32369
32367: GO 32394
32369: POP
// result := ( GetTech ( tech_gun , side ) = state_researched ) ; b_ext_rocket :
32370: LD_ADDR_VAR 0 3
32374: PUSH
32375: LD_INT 39
32377: PPUSH
32378: LD_VAR 0 1
32382: PPUSH
32383: CALL_OW 321
32387: PUSH
32388: LD_INT 2
32390: EQUAL
32391: ST_TO_ADDR
32392: GO 32461
32394: LD_INT 18
32396: DOUBLE
32397: EQUAL
32398: IFTRUE 32402
32400: GO 32427
32402: POP
// result := ( GetTech ( tech_rocket , side ) = state_researched ) ; b_solar_power :
32403: LD_ADDR_VAR 0 3
32407: PUSH
32408: LD_INT 40
32410: PPUSH
32411: LD_VAR 0 1
32415: PPUSH
32416: CALL_OW 321
32420: PUSH
32421: LD_INT 2
32423: EQUAL
32424: ST_TO_ADDR
32425: GO 32461
32427: LD_INT 27
32429: DOUBLE
32430: EQUAL
32431: IFTRUE 32435
32433: GO 32460
32435: POP
// result := ( GetTech ( tech_solpow , side ) = state_researched ) ; end ;
32436: LD_ADDR_VAR 0 3
32440: PUSH
32441: LD_INT 35
32443: PPUSH
32444: LD_VAR 0 1
32448: PPUSH
32449: CALL_OW 321
32453: PUSH
32454: LD_INT 2
32456: EQUAL
32457: ST_TO_ADDR
32458: GO 32461
32460: POP
// end ;
32461: LD_VAR 0 3
32465: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex , tech ; begin
32466: LD_INT 0
32468: PPUSH
32469: PPUSH
32470: PPUSH
32471: PPUSH
32472: PPUSH
32473: PPUSH
32474: PPUSH
32475: PPUSH
32476: PPUSH
32477: PPUSH
32478: PPUSH
// result := false ;
32479: LD_ADDR_VAR 0 6
32483: PUSH
32484: LD_INT 0
32486: ST_TO_ADDR
// if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
32487: LD_VAR 0 1
32491: NOT
32492: PUSH
32493: LD_VAR 0 1
32497: PPUSH
32498: CALL_OW 266
32502: PUSH
32503: LD_INT 0
32505: PUSH
32506: LD_INT 1
32508: PUSH
32509: EMPTY
32510: LIST
32511: LIST
32512: IN
32513: NOT
32514: OR
32515: PUSH
32516: LD_VAR 0 2
32520: NOT
32521: OR
32522: PUSH
32523: LD_VAR 0 5
32527: PUSH
32528: LD_INT 0
32530: PUSH
32531: LD_INT 1
32533: PUSH
32534: LD_INT 2
32536: PUSH
32537: LD_INT 3
32539: PUSH
32540: LD_INT 4
32542: PUSH
32543: LD_INT 5
32545: PUSH
32546: EMPTY
32547: LIST
32548: LIST
32549: LIST
32550: LIST
32551: LIST
32552: LIST
32553: IN
32554: NOT
32555: OR
32556: PUSH
32557: LD_VAR 0 3
32561: PPUSH
32562: LD_VAR 0 4
32566: PPUSH
32567: CALL_OW 488
32571: NOT
32572: OR
32573: IFFALSE 32577
// exit ;
32575: GO 33313
// side := GetSide ( depot ) ;
32577: LD_ADDR_VAR 0 9
32581: PUSH
32582: LD_VAR 0 1
32586: PPUSH
32587: CALL_OW 255
32591: ST_TO_ADDR
// if not BuildingTechInvented ( side , btype ) then
32592: LD_VAR 0 9
32596: PPUSH
32597: LD_VAR 0 2
32601: PPUSH
32602: CALL 32086 0 2
32606: NOT
32607: IFFALSE 32611
// exit ;
32609: GO 33313
// pom := GetBase ( depot ) ;
32611: LD_ADDR_VAR 0 10
32615: PUSH
32616: LD_VAR 0 1
32620: PPUSH
32621: CALL_OW 274
32625: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
32626: LD_ADDR_VAR 0 11
32630: PUSH
32631: LD_VAR 0 2
32635: PPUSH
32636: LD_VAR 0 1
32640: PPUSH
32641: CALL_OW 248
32645: PPUSH
32646: CALL_OW 450
32650: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
32651: LD_VAR 0 10
32655: PPUSH
32656: LD_INT 1
32658: PPUSH
32659: CALL_OW 275
32663: PUSH
32664: LD_VAR 0 11
32668: PUSH
32669: LD_INT 1
32671: ARRAY
32672: GREATEREQUAL
32673: PUSH
32674: LD_VAR 0 10
32678: PPUSH
32679: LD_INT 2
32681: PPUSH
32682: CALL_OW 275
32686: PUSH
32687: LD_VAR 0 11
32691: PUSH
32692: LD_INT 2
32694: ARRAY
32695: GREATEREQUAL
32696: AND
32697: PUSH
32698: LD_VAR 0 10
32702: PPUSH
32703: LD_INT 3
32705: PPUSH
32706: CALL_OW 275
32710: PUSH
32711: LD_VAR 0 11
32715: PUSH
32716: LD_INT 3
32718: ARRAY
32719: GREATEREQUAL
32720: AND
32721: NOT
32722: IFFALSE 32726
// exit ;
32724: GO 33313
// if GetBType ( depot ) = b_depot then
32726: LD_VAR 0 1
32730: PPUSH
32731: CALL_OW 266
32735: PUSH
32736: LD_INT 0
32738: EQUAL
32739: IFFALSE 32751
// dist := 28 else
32741: LD_ADDR_VAR 0 14
32745: PUSH
32746: LD_INT 28
32748: ST_TO_ADDR
32749: GO 32759
// dist := 36 ;
32751: LD_ADDR_VAR 0 14
32755: PUSH
32756: LD_INT 36
32758: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
32759: LD_VAR 0 1
32763: PPUSH
32764: LD_VAR 0 3
32768: PPUSH
32769: LD_VAR 0 4
32773: PPUSH
32774: CALL_OW 297
32778: PUSH
32779: LD_VAR 0 14
32783: GREATER
32784: IFFALSE 32788
// exit ;
32786: GO 33313
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
32788: LD_ADDR_VAR 0 12
32792: PUSH
32793: LD_VAR 0 2
32797: PPUSH
32798: LD_VAR 0 3
32802: PPUSH
32803: LD_VAR 0 4
32807: PPUSH
32808: LD_VAR 0 5
32812: PPUSH
32813: LD_VAR 0 1
32817: PPUSH
32818: CALL_OW 248
32822: PPUSH
32823: LD_INT 0
32825: PPUSH
32826: CALL 33318 0 6
32830: ST_TO_ADDR
// if not hexes then
32831: LD_VAR 0 12
32835: NOT
32836: IFFALSE 32840
// exit ;
32838: GO 33313
// hex := GetHexInfo ( x , y ) ;
32840: LD_ADDR_VAR 0 15
32844: PUSH
32845: LD_VAR 0 3
32849: PPUSH
32850: LD_VAR 0 4
32854: PPUSH
32855: CALL_OW 546
32859: ST_TO_ADDR
// if hex [ 1 ] then
32860: LD_VAR 0 15
32864: PUSH
32865: LD_INT 1
32867: ARRAY
32868: IFFALSE 32872
// exit ;
32870: GO 33313
// height := hex [ 2 ] ;
32872: LD_ADDR_VAR 0 13
32876: PUSH
32877: LD_VAR 0 15
32881: PUSH
32882: LD_INT 2
32884: ARRAY
32885: ST_TO_ADDR
// for i = 1 to hexes do
32886: LD_ADDR_VAR 0 7
32890: PUSH
32891: DOUBLE
32892: LD_INT 1
32894: DEC
32895: ST_TO_ADDR
32896: LD_VAR 0 12
32900: PUSH
32901: FOR_TO
32902: IFFALSE 33232
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
32904: LD_VAR 0 12
32908: PUSH
32909: LD_VAR 0 7
32913: ARRAY
32914: PUSH
32915: LD_INT 1
32917: ARRAY
32918: PPUSH
32919: LD_VAR 0 12
32923: PUSH
32924: LD_VAR 0 7
32928: ARRAY
32929: PUSH
32930: LD_INT 2
32932: ARRAY
32933: PPUSH
32934: CALL_OW 488
32938: NOT
32939: PUSH
32940: LD_VAR 0 12
32944: PUSH
32945: LD_VAR 0 7
32949: ARRAY
32950: PUSH
32951: LD_INT 1
32953: ARRAY
32954: PPUSH
32955: LD_VAR 0 12
32959: PUSH
32960: LD_VAR 0 7
32964: ARRAY
32965: PUSH
32966: LD_INT 2
32968: ARRAY
32969: PPUSH
32970: CALL_OW 428
32974: PUSH
32975: LD_INT 0
32977: GREATER
32978: OR
32979: PUSH
32980: LD_VAR 0 12
32984: PUSH
32985: LD_VAR 0 7
32989: ARRAY
32990: PUSH
32991: LD_INT 1
32993: ARRAY
32994: PPUSH
32995: LD_VAR 0 12
32999: PUSH
33000: LD_VAR 0 7
33004: ARRAY
33005: PUSH
33006: LD_INT 2
33008: ARRAY
33009: PPUSH
33010: CALL_OW 351
33014: OR
33015: IFFALSE 33021
// exit ;
33017: POP
33018: POP
33019: GO 33313
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
33021: LD_ADDR_VAR 0 8
33025: PUSH
33026: LD_VAR 0 12
33030: PUSH
33031: LD_VAR 0 7
33035: ARRAY
33036: PUSH
33037: LD_INT 1
33039: ARRAY
33040: PPUSH
33041: LD_VAR 0 12
33045: PUSH
33046: LD_VAR 0 7
33050: ARRAY
33051: PUSH
33052: LD_INT 2
33054: ARRAY
33055: PPUSH
33056: CALL_OW 546
33060: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
33061: LD_VAR 0 8
33065: PUSH
33066: LD_INT 1
33068: ARRAY
33069: PUSH
33070: LD_VAR 0 8
33074: PUSH
33075: LD_INT 2
33077: ARRAY
33078: PUSH
33079: LD_VAR 0 13
33083: PUSH
33084: LD_INT 2
33086: PLUS
33087: GREATER
33088: OR
33089: PUSH
33090: LD_VAR 0 8
33094: PUSH
33095: LD_INT 2
33097: ARRAY
33098: PUSH
33099: LD_VAR 0 13
33103: PUSH
33104: LD_INT 2
33106: MINUS
33107: LESS
33108: OR
33109: PUSH
33110: LD_VAR 0 8
33114: PUSH
33115: LD_INT 3
33117: ARRAY
33118: PUSH
33119: LD_INT 0
33121: PUSH
33122: LD_INT 8
33124: PUSH
33125: LD_INT 9
33127: PUSH
33128: LD_INT 10
33130: PUSH
33131: LD_INT 11
33133: PUSH
33134: LD_INT 12
33136: PUSH
33137: LD_INT 13
33139: PUSH
33140: LD_INT 16
33142: PUSH
33143: LD_INT 17
33145: PUSH
33146: LD_INT 18
33148: PUSH
33149: LD_INT 19
33151: PUSH
33152: LD_INT 20
33154: PUSH
33155: LD_INT 21
33157: PUSH
33158: EMPTY
33159: LIST
33160: LIST
33161: LIST
33162: LIST
33163: LIST
33164: LIST
33165: LIST
33166: LIST
33167: LIST
33168: LIST
33169: LIST
33170: LIST
33171: LIST
33172: IN
33173: NOT
33174: OR
33175: PUSH
33176: LD_VAR 0 8
33180: PUSH
33181: LD_INT 5
33183: ARRAY
33184: NOT
33185: OR
33186: PUSH
33187: LD_VAR 0 8
33191: PUSH
33192: LD_INT 6
33194: ARRAY
33195: PUSH
33196: LD_INT 1
33198: PUSH
33199: LD_INT 2
33201: PUSH
33202: LD_INT 7
33204: PUSH
33205: LD_INT 9
33207: PUSH
33208: LD_INT 10
33210: PUSH
33211: LD_INT 11
33213: PUSH
33214: EMPTY
33215: LIST
33216: LIST
33217: LIST
33218: LIST
33219: LIST
33220: LIST
33221: IN
33222: NOT
33223: OR
33224: IFFALSE 33230
// exit ;
33226: POP
33227: POP
33228: GO 33313
// end ;
33230: GO 32901
33232: POP
33233: POP
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
33234: LD_VAR 0 9
33238: PPUSH
33239: LD_VAR 0 3
33243: PPUSH
33244: LD_VAR 0 4
33248: PPUSH
33249: LD_INT 20
33251: PPUSH
33252: CALL 25259 0 4
33256: PUSH
33257: LD_INT 4
33259: ARRAY
33260: IFFALSE 33264
// exit ;
33262: GO 33313
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
33264: LD_VAR 0 2
33268: PUSH
33269: LD_INT 29
33271: PUSH
33272: LD_INT 30
33274: PUSH
33275: EMPTY
33276: LIST
33277: LIST
33278: IN
33279: PUSH
33280: LD_VAR 0 3
33284: PPUSH
33285: LD_VAR 0 4
33289: PPUSH
33290: LD_VAR 0 9
33294: PPUSH
33295: CALL_OW 440
33299: NOT
33300: AND
33301: IFFALSE 33305
// exit ;
33303: GO 33313
// result := true ;
33305: LD_ADDR_VAR 0 6
33309: PUSH
33310: LD_INT 1
33312: ST_TO_ADDR
// end ;
33313: LD_VAR 0 6
33317: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 , fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 , fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ; var fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 , fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ; var fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 , fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ; var fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 , fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ; begin
33318: LD_INT 0
33320: PPUSH
33321: PPUSH
33322: PPUSH
33323: PPUSH
33324: PPUSH
33325: PPUSH
33326: PPUSH
33327: PPUSH
33328: PPUSH
33329: PPUSH
33330: PPUSH
33331: PPUSH
33332: PPUSH
33333: PPUSH
33334: PPUSH
33335: PPUSH
33336: PPUSH
33337: PPUSH
33338: PPUSH
33339: PPUSH
33340: PPUSH
33341: PPUSH
33342: PPUSH
33343: PPUSH
33344: PPUSH
33345: PPUSH
33346: PPUSH
33347: PPUSH
33348: PPUSH
33349: PPUSH
33350: PPUSH
33351: PPUSH
33352: PPUSH
33353: PPUSH
33354: PPUSH
33355: PPUSH
33356: PPUSH
33357: PPUSH
33358: PPUSH
33359: PPUSH
33360: PPUSH
33361: PPUSH
33362: PPUSH
33363: PPUSH
33364: PPUSH
33365: PPUSH
33366: PPUSH
33367: PPUSH
33368: PPUSH
33369: PPUSH
33370: PPUSH
33371: PPUSH
33372: PPUSH
33373: PPUSH
33374: PPUSH
33375: PPUSH
33376: PPUSH
33377: PPUSH
// result = [ ] ;
33378: LD_ADDR_VAR 0 7
33382: PUSH
33383: EMPTY
33384: ST_TO_ADDR
// temp_list = [ ] ;
33385: LD_ADDR_VAR 0 9
33389: PUSH
33390: EMPTY
33391: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
33392: LD_VAR 0 4
33396: PUSH
33397: LD_INT 0
33399: PUSH
33400: LD_INT 1
33402: PUSH
33403: LD_INT 2
33405: PUSH
33406: LD_INT 3
33408: PUSH
33409: LD_INT 4
33411: PUSH
33412: LD_INT 5
33414: PUSH
33415: EMPTY
33416: LIST
33417: LIST
33418: LIST
33419: LIST
33420: LIST
33421: LIST
33422: IN
33423: NOT
33424: PUSH
33425: LD_VAR 0 1
33429: PUSH
33430: LD_INT 0
33432: PUSH
33433: LD_INT 1
33435: PUSH
33436: EMPTY
33437: LIST
33438: LIST
33439: IN
33440: PUSH
33441: LD_VAR 0 5
33445: PUSH
33446: LD_INT 1
33448: PUSH
33449: LD_INT 2
33451: PUSH
33452: LD_INT 3
33454: PUSH
33455: EMPTY
33456: LIST
33457: LIST
33458: LIST
33459: IN
33460: NOT
33461: AND
33462: OR
33463: IFFALSE 33467
// exit ;
33465: GO 51858
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
33467: LD_VAR 0 1
33471: PUSH
33472: LD_INT 6
33474: PUSH
33475: LD_INT 7
33477: PUSH
33478: LD_INT 8
33480: PUSH
33481: LD_INT 13
33483: PUSH
33484: LD_INT 12
33486: PUSH
33487: LD_INT 15
33489: PUSH
33490: LD_INT 11
33492: PUSH
33493: LD_INT 14
33495: PUSH
33496: LD_INT 10
33498: PUSH
33499: EMPTY
33500: LIST
33501: LIST
33502: LIST
33503: LIST
33504: LIST
33505: LIST
33506: LIST
33507: LIST
33508: LIST
33509: IN
33510: IFFALSE 33520
// btype = b_lab ;
33512: LD_ADDR_VAR 0 1
33516: PUSH
33517: LD_INT 6
33519: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
33520: LD_VAR 0 6
33524: PUSH
33525: LD_INT 0
33527: PUSH
33528: LD_INT 1
33530: PUSH
33531: LD_INT 2
33533: PUSH
33534: EMPTY
33535: LIST
33536: LIST
33537: LIST
33538: IN
33539: NOT
33540: PUSH
33541: LD_VAR 0 1
33545: PUSH
33546: LD_INT 0
33548: PUSH
33549: LD_INT 1
33551: PUSH
33552: LD_INT 2
33554: PUSH
33555: LD_INT 3
33557: PUSH
33558: LD_INT 6
33560: PUSH
33561: LD_INT 36
33563: PUSH
33564: LD_INT 4
33566: PUSH
33567: LD_INT 5
33569: PUSH
33570: LD_INT 31
33572: PUSH
33573: LD_INT 32
33575: PUSH
33576: LD_INT 33
33578: PUSH
33579: EMPTY
33580: LIST
33581: LIST
33582: LIST
33583: LIST
33584: LIST
33585: LIST
33586: LIST
33587: LIST
33588: LIST
33589: LIST
33590: LIST
33591: IN
33592: NOT
33593: PUSH
33594: LD_VAR 0 6
33598: PUSH
33599: LD_INT 1
33601: EQUAL
33602: AND
33603: OR
33604: PUSH
33605: LD_VAR 0 1
33609: PUSH
33610: LD_INT 2
33612: PUSH
33613: LD_INT 3
33615: PUSH
33616: EMPTY
33617: LIST
33618: LIST
33619: IN
33620: NOT
33621: PUSH
33622: LD_VAR 0 6
33626: PUSH
33627: LD_INT 2
33629: EQUAL
33630: AND
33631: OR
33632: IFFALSE 33642
// mode = 0 ;
33634: LD_ADDR_VAR 0 6
33638: PUSH
33639: LD_INT 0
33641: ST_TO_ADDR
// case mode of 0 :
33642: LD_VAR 0 6
33646: PUSH
33647: LD_INT 0
33649: DOUBLE
33650: EQUAL
33651: IFTRUE 33655
33653: GO 45108
33655: POP
// begin fDepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
33656: LD_ADDR_VAR 0 11
33660: PUSH
33661: LD_INT 0
33663: PUSH
33664: LD_INT 0
33666: PUSH
33667: EMPTY
33668: LIST
33669: LIST
33670: PUSH
33671: LD_INT 0
33673: PUSH
33674: LD_INT 1
33676: NEG
33677: PUSH
33678: EMPTY
33679: LIST
33680: LIST
33681: PUSH
33682: LD_INT 1
33684: PUSH
33685: LD_INT 0
33687: PUSH
33688: EMPTY
33689: LIST
33690: LIST
33691: PUSH
33692: LD_INT 1
33694: PUSH
33695: LD_INT 1
33697: PUSH
33698: EMPTY
33699: LIST
33700: LIST
33701: PUSH
33702: LD_INT 0
33704: PUSH
33705: LD_INT 1
33707: PUSH
33708: EMPTY
33709: LIST
33710: LIST
33711: PUSH
33712: LD_INT 1
33714: NEG
33715: PUSH
33716: LD_INT 0
33718: PUSH
33719: EMPTY
33720: LIST
33721: LIST
33722: PUSH
33723: LD_INT 1
33725: NEG
33726: PUSH
33727: LD_INT 1
33729: NEG
33730: PUSH
33731: EMPTY
33732: LIST
33733: LIST
33734: PUSH
33735: LD_INT 1
33737: NEG
33738: PUSH
33739: LD_INT 2
33741: NEG
33742: PUSH
33743: EMPTY
33744: LIST
33745: LIST
33746: PUSH
33747: LD_INT 0
33749: PUSH
33750: LD_INT 2
33752: NEG
33753: PUSH
33754: EMPTY
33755: LIST
33756: LIST
33757: PUSH
33758: LD_INT 1
33760: PUSH
33761: LD_INT 1
33763: NEG
33764: PUSH
33765: EMPTY
33766: LIST
33767: LIST
33768: PUSH
33769: LD_INT 1
33771: PUSH
33772: LD_INT 2
33774: PUSH
33775: EMPTY
33776: LIST
33777: LIST
33778: PUSH
33779: LD_INT 0
33781: PUSH
33782: LD_INT 2
33784: PUSH
33785: EMPTY
33786: LIST
33787: LIST
33788: PUSH
33789: LD_INT 1
33791: NEG
33792: PUSH
33793: LD_INT 1
33795: PUSH
33796: EMPTY
33797: LIST
33798: LIST
33799: PUSH
33800: LD_INT 1
33802: PUSH
33803: LD_INT 3
33805: PUSH
33806: EMPTY
33807: LIST
33808: LIST
33809: PUSH
33810: LD_INT 0
33812: PUSH
33813: LD_INT 3
33815: PUSH
33816: EMPTY
33817: LIST
33818: LIST
33819: PUSH
33820: LD_INT 1
33822: NEG
33823: PUSH
33824: LD_INT 2
33826: PUSH
33827: EMPTY
33828: LIST
33829: LIST
33830: PUSH
33831: EMPTY
33832: LIST
33833: LIST
33834: LIST
33835: LIST
33836: LIST
33837: LIST
33838: LIST
33839: LIST
33840: LIST
33841: LIST
33842: LIST
33843: LIST
33844: LIST
33845: LIST
33846: LIST
33847: LIST
33848: ST_TO_ADDR
// fDepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
33849: LD_ADDR_VAR 0 12
33853: PUSH
33854: LD_INT 0
33856: PUSH
33857: LD_INT 0
33859: PUSH
33860: EMPTY
33861: LIST
33862: LIST
33863: PUSH
33864: LD_INT 0
33866: PUSH
33867: LD_INT 1
33869: NEG
33870: PUSH
33871: EMPTY
33872: LIST
33873: LIST
33874: PUSH
33875: LD_INT 1
33877: PUSH
33878: LD_INT 0
33880: PUSH
33881: EMPTY
33882: LIST
33883: LIST
33884: PUSH
33885: LD_INT 1
33887: PUSH
33888: LD_INT 1
33890: PUSH
33891: EMPTY
33892: LIST
33893: LIST
33894: PUSH
33895: LD_INT 0
33897: PUSH
33898: LD_INT 1
33900: PUSH
33901: EMPTY
33902: LIST
33903: LIST
33904: PUSH
33905: LD_INT 1
33907: NEG
33908: PUSH
33909: LD_INT 0
33911: PUSH
33912: EMPTY
33913: LIST
33914: LIST
33915: PUSH
33916: LD_INT 1
33918: NEG
33919: PUSH
33920: LD_INT 1
33922: NEG
33923: PUSH
33924: EMPTY
33925: LIST
33926: LIST
33927: PUSH
33928: LD_INT 1
33930: PUSH
33931: LD_INT 1
33933: NEG
33934: PUSH
33935: EMPTY
33936: LIST
33937: LIST
33938: PUSH
33939: LD_INT 2
33941: PUSH
33942: LD_INT 0
33944: PUSH
33945: EMPTY
33946: LIST
33947: LIST
33948: PUSH
33949: LD_INT 2
33951: PUSH
33952: LD_INT 1
33954: PUSH
33955: EMPTY
33956: LIST
33957: LIST
33958: PUSH
33959: LD_INT 1
33961: NEG
33962: PUSH
33963: LD_INT 1
33965: PUSH
33966: EMPTY
33967: LIST
33968: LIST
33969: PUSH
33970: LD_INT 2
33972: NEG
33973: PUSH
33974: LD_INT 0
33976: PUSH
33977: EMPTY
33978: LIST
33979: LIST
33980: PUSH
33981: LD_INT 2
33983: NEG
33984: PUSH
33985: LD_INT 1
33987: NEG
33988: PUSH
33989: EMPTY
33990: LIST
33991: LIST
33992: PUSH
33993: LD_INT 2
33995: NEG
33996: PUSH
33997: LD_INT 1
33999: PUSH
34000: EMPTY
34001: LIST
34002: LIST
34003: PUSH
34004: LD_INT 3
34006: NEG
34007: PUSH
34008: LD_INT 0
34010: PUSH
34011: EMPTY
34012: LIST
34013: LIST
34014: PUSH
34015: LD_INT 3
34017: NEG
34018: PUSH
34019: LD_INT 1
34021: NEG
34022: PUSH
34023: EMPTY
34024: LIST
34025: LIST
34026: PUSH
34027: EMPTY
34028: LIST
34029: LIST
34030: LIST
34031: LIST
34032: LIST
34033: LIST
34034: LIST
34035: LIST
34036: LIST
34037: LIST
34038: LIST
34039: LIST
34040: LIST
34041: LIST
34042: LIST
34043: LIST
34044: ST_TO_ADDR
// fDepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
34045: LD_ADDR_VAR 0 13
34049: PUSH
34050: LD_INT 0
34052: PUSH
34053: LD_INT 0
34055: PUSH
34056: EMPTY
34057: LIST
34058: LIST
34059: PUSH
34060: LD_INT 0
34062: PUSH
34063: LD_INT 1
34065: NEG
34066: PUSH
34067: EMPTY
34068: LIST
34069: LIST
34070: PUSH
34071: LD_INT 1
34073: PUSH
34074: LD_INT 0
34076: PUSH
34077: EMPTY
34078: LIST
34079: LIST
34080: PUSH
34081: LD_INT 1
34083: PUSH
34084: LD_INT 1
34086: PUSH
34087: EMPTY
34088: LIST
34089: LIST
34090: PUSH
34091: LD_INT 0
34093: PUSH
34094: LD_INT 1
34096: PUSH
34097: EMPTY
34098: LIST
34099: LIST
34100: PUSH
34101: LD_INT 1
34103: NEG
34104: PUSH
34105: LD_INT 0
34107: PUSH
34108: EMPTY
34109: LIST
34110: LIST
34111: PUSH
34112: LD_INT 1
34114: NEG
34115: PUSH
34116: LD_INT 1
34118: NEG
34119: PUSH
34120: EMPTY
34121: LIST
34122: LIST
34123: PUSH
34124: LD_INT 1
34126: NEG
34127: PUSH
34128: LD_INT 2
34130: NEG
34131: PUSH
34132: EMPTY
34133: LIST
34134: LIST
34135: PUSH
34136: LD_INT 2
34138: PUSH
34139: LD_INT 1
34141: PUSH
34142: EMPTY
34143: LIST
34144: LIST
34145: PUSH
34146: LD_INT 2
34148: PUSH
34149: LD_INT 2
34151: PUSH
34152: EMPTY
34153: LIST
34154: LIST
34155: PUSH
34156: LD_INT 1
34158: PUSH
34159: LD_INT 2
34161: PUSH
34162: EMPTY
34163: LIST
34164: LIST
34165: PUSH
34166: LD_INT 2
34168: NEG
34169: PUSH
34170: LD_INT 1
34172: NEG
34173: PUSH
34174: EMPTY
34175: LIST
34176: LIST
34177: PUSH
34178: LD_INT 2
34180: NEG
34181: PUSH
34182: LD_INT 2
34184: NEG
34185: PUSH
34186: EMPTY
34187: LIST
34188: LIST
34189: PUSH
34190: LD_INT 2
34192: NEG
34193: PUSH
34194: LD_INT 3
34196: NEG
34197: PUSH
34198: EMPTY
34199: LIST
34200: LIST
34201: PUSH
34202: LD_INT 3
34204: NEG
34205: PUSH
34206: LD_INT 2
34208: NEG
34209: PUSH
34210: EMPTY
34211: LIST
34212: LIST
34213: PUSH
34214: LD_INT 3
34216: NEG
34217: PUSH
34218: LD_INT 3
34220: NEG
34221: PUSH
34222: EMPTY
34223: LIST
34224: LIST
34225: PUSH
34226: EMPTY
34227: LIST
34228: LIST
34229: LIST
34230: LIST
34231: LIST
34232: LIST
34233: LIST
34234: LIST
34235: LIST
34236: LIST
34237: LIST
34238: LIST
34239: LIST
34240: LIST
34241: LIST
34242: LIST
34243: ST_TO_ADDR
// fDepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
34244: LD_ADDR_VAR 0 14
34248: PUSH
34249: LD_INT 0
34251: PUSH
34252: LD_INT 0
34254: PUSH
34255: EMPTY
34256: LIST
34257: LIST
34258: PUSH
34259: LD_INT 0
34261: PUSH
34262: LD_INT 1
34264: NEG
34265: PUSH
34266: EMPTY
34267: LIST
34268: LIST
34269: PUSH
34270: LD_INT 1
34272: PUSH
34273: LD_INT 0
34275: PUSH
34276: EMPTY
34277: LIST
34278: LIST
34279: PUSH
34280: LD_INT 1
34282: PUSH
34283: LD_INT 1
34285: PUSH
34286: EMPTY
34287: LIST
34288: LIST
34289: PUSH
34290: LD_INT 0
34292: PUSH
34293: LD_INT 1
34295: PUSH
34296: EMPTY
34297: LIST
34298: LIST
34299: PUSH
34300: LD_INT 1
34302: NEG
34303: PUSH
34304: LD_INT 0
34306: PUSH
34307: EMPTY
34308: LIST
34309: LIST
34310: PUSH
34311: LD_INT 1
34313: NEG
34314: PUSH
34315: LD_INT 1
34317: NEG
34318: PUSH
34319: EMPTY
34320: LIST
34321: LIST
34322: PUSH
34323: LD_INT 1
34325: NEG
34326: PUSH
34327: LD_INT 2
34329: NEG
34330: PUSH
34331: EMPTY
34332: LIST
34333: LIST
34334: PUSH
34335: LD_INT 0
34337: PUSH
34338: LD_INT 2
34340: NEG
34341: PUSH
34342: EMPTY
34343: LIST
34344: LIST
34345: PUSH
34346: LD_INT 1
34348: PUSH
34349: LD_INT 1
34351: NEG
34352: PUSH
34353: EMPTY
34354: LIST
34355: LIST
34356: PUSH
34357: LD_INT 1
34359: PUSH
34360: LD_INT 2
34362: PUSH
34363: EMPTY
34364: LIST
34365: LIST
34366: PUSH
34367: LD_INT 0
34369: PUSH
34370: LD_INT 2
34372: PUSH
34373: EMPTY
34374: LIST
34375: LIST
34376: PUSH
34377: LD_INT 1
34379: NEG
34380: PUSH
34381: LD_INT 1
34383: PUSH
34384: EMPTY
34385: LIST
34386: LIST
34387: PUSH
34388: LD_INT 1
34390: NEG
34391: PUSH
34392: LD_INT 3
34394: NEG
34395: PUSH
34396: EMPTY
34397: LIST
34398: LIST
34399: PUSH
34400: LD_INT 0
34402: PUSH
34403: LD_INT 3
34405: NEG
34406: PUSH
34407: EMPTY
34408: LIST
34409: LIST
34410: PUSH
34411: LD_INT 1
34413: PUSH
34414: LD_INT 2
34416: NEG
34417: PUSH
34418: EMPTY
34419: LIST
34420: LIST
34421: PUSH
34422: EMPTY
34423: LIST
34424: LIST
34425: LIST
34426: LIST
34427: LIST
34428: LIST
34429: LIST
34430: LIST
34431: LIST
34432: LIST
34433: LIST
34434: LIST
34435: LIST
34436: LIST
34437: LIST
34438: LIST
34439: ST_TO_ADDR
// fDepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
34440: LD_ADDR_VAR 0 15
34444: PUSH
34445: LD_INT 0
34447: PUSH
34448: LD_INT 0
34450: PUSH
34451: EMPTY
34452: LIST
34453: LIST
34454: PUSH
34455: LD_INT 0
34457: PUSH
34458: LD_INT 1
34460: NEG
34461: PUSH
34462: EMPTY
34463: LIST
34464: LIST
34465: PUSH
34466: LD_INT 1
34468: PUSH
34469: LD_INT 0
34471: PUSH
34472: EMPTY
34473: LIST
34474: LIST
34475: PUSH
34476: LD_INT 1
34478: PUSH
34479: LD_INT 1
34481: PUSH
34482: EMPTY
34483: LIST
34484: LIST
34485: PUSH
34486: LD_INT 0
34488: PUSH
34489: LD_INT 1
34491: PUSH
34492: EMPTY
34493: LIST
34494: LIST
34495: PUSH
34496: LD_INT 1
34498: NEG
34499: PUSH
34500: LD_INT 0
34502: PUSH
34503: EMPTY
34504: LIST
34505: LIST
34506: PUSH
34507: LD_INT 1
34509: NEG
34510: PUSH
34511: LD_INT 1
34513: NEG
34514: PUSH
34515: EMPTY
34516: LIST
34517: LIST
34518: PUSH
34519: LD_INT 1
34521: PUSH
34522: LD_INT 1
34524: NEG
34525: PUSH
34526: EMPTY
34527: LIST
34528: LIST
34529: PUSH
34530: LD_INT 2
34532: PUSH
34533: LD_INT 0
34535: PUSH
34536: EMPTY
34537: LIST
34538: LIST
34539: PUSH
34540: LD_INT 2
34542: PUSH
34543: LD_INT 1
34545: PUSH
34546: EMPTY
34547: LIST
34548: LIST
34549: PUSH
34550: LD_INT 1
34552: NEG
34553: PUSH
34554: LD_INT 1
34556: PUSH
34557: EMPTY
34558: LIST
34559: LIST
34560: PUSH
34561: LD_INT 2
34563: NEG
34564: PUSH
34565: LD_INT 0
34567: PUSH
34568: EMPTY
34569: LIST
34570: LIST
34571: PUSH
34572: LD_INT 2
34574: NEG
34575: PUSH
34576: LD_INT 1
34578: NEG
34579: PUSH
34580: EMPTY
34581: LIST
34582: LIST
34583: PUSH
34584: LD_INT 2
34586: PUSH
34587: LD_INT 1
34589: NEG
34590: PUSH
34591: EMPTY
34592: LIST
34593: LIST
34594: PUSH
34595: LD_INT 3
34597: PUSH
34598: LD_INT 0
34600: PUSH
34601: EMPTY
34602: LIST
34603: LIST
34604: PUSH
34605: LD_INT 3
34607: PUSH
34608: LD_INT 1
34610: PUSH
34611: EMPTY
34612: LIST
34613: LIST
34614: PUSH
34615: EMPTY
34616: LIST
34617: LIST
34618: LIST
34619: LIST
34620: LIST
34621: LIST
34622: LIST
34623: LIST
34624: LIST
34625: LIST
34626: LIST
34627: LIST
34628: LIST
34629: LIST
34630: LIST
34631: LIST
34632: ST_TO_ADDR
// fDepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
34633: LD_ADDR_VAR 0 16
34637: PUSH
34638: LD_INT 0
34640: PUSH
34641: LD_INT 0
34643: PUSH
34644: EMPTY
34645: LIST
34646: LIST
34647: PUSH
34648: LD_INT 0
34650: PUSH
34651: LD_INT 1
34653: NEG
34654: PUSH
34655: EMPTY
34656: LIST
34657: LIST
34658: PUSH
34659: LD_INT 1
34661: PUSH
34662: LD_INT 0
34664: PUSH
34665: EMPTY
34666: LIST
34667: LIST
34668: PUSH
34669: LD_INT 1
34671: PUSH
34672: LD_INT 1
34674: PUSH
34675: EMPTY
34676: LIST
34677: LIST
34678: PUSH
34679: LD_INT 0
34681: PUSH
34682: LD_INT 1
34684: PUSH
34685: EMPTY
34686: LIST
34687: LIST
34688: PUSH
34689: LD_INT 1
34691: NEG
34692: PUSH
34693: LD_INT 0
34695: PUSH
34696: EMPTY
34697: LIST
34698: LIST
34699: PUSH
34700: LD_INT 1
34702: NEG
34703: PUSH
34704: LD_INT 1
34706: NEG
34707: PUSH
34708: EMPTY
34709: LIST
34710: LIST
34711: PUSH
34712: LD_INT 1
34714: NEG
34715: PUSH
34716: LD_INT 2
34718: NEG
34719: PUSH
34720: EMPTY
34721: LIST
34722: LIST
34723: PUSH
34724: LD_INT 2
34726: PUSH
34727: LD_INT 1
34729: PUSH
34730: EMPTY
34731: LIST
34732: LIST
34733: PUSH
34734: LD_INT 2
34736: PUSH
34737: LD_INT 2
34739: PUSH
34740: EMPTY
34741: LIST
34742: LIST
34743: PUSH
34744: LD_INT 1
34746: PUSH
34747: LD_INT 2
34749: PUSH
34750: EMPTY
34751: LIST
34752: LIST
34753: PUSH
34754: LD_INT 2
34756: NEG
34757: PUSH
34758: LD_INT 1
34760: NEG
34761: PUSH
34762: EMPTY
34763: LIST
34764: LIST
34765: PUSH
34766: LD_INT 2
34768: NEG
34769: PUSH
34770: LD_INT 2
34772: NEG
34773: PUSH
34774: EMPTY
34775: LIST
34776: LIST
34777: PUSH
34778: LD_INT 3
34780: PUSH
34781: LD_INT 2
34783: PUSH
34784: EMPTY
34785: LIST
34786: LIST
34787: PUSH
34788: LD_INT 3
34790: PUSH
34791: LD_INT 3
34793: PUSH
34794: EMPTY
34795: LIST
34796: LIST
34797: PUSH
34798: LD_INT 2
34800: PUSH
34801: LD_INT 3
34803: PUSH
34804: EMPTY
34805: LIST
34806: LIST
34807: PUSH
34808: EMPTY
34809: LIST
34810: LIST
34811: LIST
34812: LIST
34813: LIST
34814: LIST
34815: LIST
34816: LIST
34817: LIST
34818: LIST
34819: LIST
34820: LIST
34821: LIST
34822: LIST
34823: LIST
34824: LIST
34825: ST_TO_ADDR
// fDepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
34826: LD_ADDR_VAR 0 17
34830: PUSH
34831: LD_INT 0
34833: PUSH
34834: LD_INT 0
34836: PUSH
34837: EMPTY
34838: LIST
34839: LIST
34840: PUSH
34841: LD_INT 0
34843: PUSH
34844: LD_INT 1
34846: NEG
34847: PUSH
34848: EMPTY
34849: LIST
34850: LIST
34851: PUSH
34852: LD_INT 1
34854: PUSH
34855: LD_INT 0
34857: PUSH
34858: EMPTY
34859: LIST
34860: LIST
34861: PUSH
34862: LD_INT 1
34864: PUSH
34865: LD_INT 1
34867: PUSH
34868: EMPTY
34869: LIST
34870: LIST
34871: PUSH
34872: LD_INT 0
34874: PUSH
34875: LD_INT 1
34877: PUSH
34878: EMPTY
34879: LIST
34880: LIST
34881: PUSH
34882: LD_INT 1
34884: NEG
34885: PUSH
34886: LD_INT 0
34888: PUSH
34889: EMPTY
34890: LIST
34891: LIST
34892: PUSH
34893: LD_INT 1
34895: NEG
34896: PUSH
34897: LD_INT 1
34899: NEG
34900: PUSH
34901: EMPTY
34902: LIST
34903: LIST
34904: PUSH
34905: LD_INT 1
34907: NEG
34908: PUSH
34909: LD_INT 2
34911: NEG
34912: PUSH
34913: EMPTY
34914: LIST
34915: LIST
34916: PUSH
34917: LD_INT 0
34919: PUSH
34920: LD_INT 2
34922: NEG
34923: PUSH
34924: EMPTY
34925: LIST
34926: LIST
34927: PUSH
34928: LD_INT 1
34930: PUSH
34931: LD_INT 1
34933: NEG
34934: PUSH
34935: EMPTY
34936: LIST
34937: LIST
34938: PUSH
34939: LD_INT 2
34941: PUSH
34942: LD_INT 0
34944: PUSH
34945: EMPTY
34946: LIST
34947: LIST
34948: PUSH
34949: LD_INT 2
34951: PUSH
34952: LD_INT 1
34954: PUSH
34955: EMPTY
34956: LIST
34957: LIST
34958: PUSH
34959: LD_INT 2
34961: PUSH
34962: LD_INT 2
34964: PUSH
34965: EMPTY
34966: LIST
34967: LIST
34968: PUSH
34969: LD_INT 1
34971: PUSH
34972: LD_INT 2
34974: PUSH
34975: EMPTY
34976: LIST
34977: LIST
34978: PUSH
34979: LD_INT 0
34981: PUSH
34982: LD_INT 2
34984: PUSH
34985: EMPTY
34986: LIST
34987: LIST
34988: PUSH
34989: LD_INT 1
34991: NEG
34992: PUSH
34993: LD_INT 1
34995: PUSH
34996: EMPTY
34997: LIST
34998: LIST
34999: PUSH
35000: LD_INT 2
35002: NEG
35003: PUSH
35004: LD_INT 0
35006: PUSH
35007: EMPTY
35008: LIST
35009: LIST
35010: PUSH
35011: LD_INT 2
35013: NEG
35014: PUSH
35015: LD_INT 1
35017: NEG
35018: PUSH
35019: EMPTY
35020: LIST
35021: LIST
35022: PUSH
35023: LD_INT 2
35025: NEG
35026: PUSH
35027: LD_INT 2
35029: NEG
35030: PUSH
35031: EMPTY
35032: LIST
35033: LIST
35034: PUSH
35035: EMPTY
35036: LIST
35037: LIST
35038: LIST
35039: LIST
35040: LIST
35041: LIST
35042: LIST
35043: LIST
35044: LIST
35045: LIST
35046: LIST
35047: LIST
35048: LIST
35049: LIST
35050: LIST
35051: LIST
35052: LIST
35053: LIST
35054: LIST
35055: ST_TO_ADDR
// fDepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
35056: LD_ADDR_VAR 0 18
35060: PUSH
35061: LD_INT 0
35063: PUSH
35064: LD_INT 0
35066: PUSH
35067: EMPTY
35068: LIST
35069: LIST
35070: PUSH
35071: LD_INT 0
35073: PUSH
35074: LD_INT 1
35076: NEG
35077: PUSH
35078: EMPTY
35079: LIST
35080: LIST
35081: PUSH
35082: LD_INT 1
35084: PUSH
35085: LD_INT 0
35087: PUSH
35088: EMPTY
35089: LIST
35090: LIST
35091: PUSH
35092: LD_INT 1
35094: PUSH
35095: LD_INT 1
35097: PUSH
35098: EMPTY
35099: LIST
35100: LIST
35101: PUSH
35102: LD_INT 0
35104: PUSH
35105: LD_INT 1
35107: PUSH
35108: EMPTY
35109: LIST
35110: LIST
35111: PUSH
35112: LD_INT 1
35114: NEG
35115: PUSH
35116: LD_INT 0
35118: PUSH
35119: EMPTY
35120: LIST
35121: LIST
35122: PUSH
35123: LD_INT 1
35125: NEG
35126: PUSH
35127: LD_INT 1
35129: NEG
35130: PUSH
35131: EMPTY
35132: LIST
35133: LIST
35134: PUSH
35135: LD_INT 1
35137: NEG
35138: PUSH
35139: LD_INT 2
35141: NEG
35142: PUSH
35143: EMPTY
35144: LIST
35145: LIST
35146: PUSH
35147: LD_INT 0
35149: PUSH
35150: LD_INT 2
35152: NEG
35153: PUSH
35154: EMPTY
35155: LIST
35156: LIST
35157: PUSH
35158: LD_INT 1
35160: PUSH
35161: LD_INT 1
35163: NEG
35164: PUSH
35165: EMPTY
35166: LIST
35167: LIST
35168: PUSH
35169: LD_INT 2
35171: PUSH
35172: LD_INT 0
35174: PUSH
35175: EMPTY
35176: LIST
35177: LIST
35178: PUSH
35179: LD_INT 2
35181: PUSH
35182: LD_INT 1
35184: PUSH
35185: EMPTY
35186: LIST
35187: LIST
35188: PUSH
35189: LD_INT 2
35191: PUSH
35192: LD_INT 2
35194: PUSH
35195: EMPTY
35196: LIST
35197: LIST
35198: PUSH
35199: LD_INT 1
35201: PUSH
35202: LD_INT 2
35204: PUSH
35205: EMPTY
35206: LIST
35207: LIST
35208: PUSH
35209: LD_INT 0
35211: PUSH
35212: LD_INT 2
35214: PUSH
35215: EMPTY
35216: LIST
35217: LIST
35218: PUSH
35219: LD_INT 1
35221: NEG
35222: PUSH
35223: LD_INT 1
35225: PUSH
35226: EMPTY
35227: LIST
35228: LIST
35229: PUSH
35230: LD_INT 2
35232: NEG
35233: PUSH
35234: LD_INT 0
35236: PUSH
35237: EMPTY
35238: LIST
35239: LIST
35240: PUSH
35241: LD_INT 2
35243: NEG
35244: PUSH
35245: LD_INT 1
35247: NEG
35248: PUSH
35249: EMPTY
35250: LIST
35251: LIST
35252: PUSH
35253: LD_INT 2
35255: NEG
35256: PUSH
35257: LD_INT 2
35259: NEG
35260: PUSH
35261: EMPTY
35262: LIST
35263: LIST
35264: PUSH
35265: EMPTY
35266: LIST
35267: LIST
35268: LIST
35269: LIST
35270: LIST
35271: LIST
35272: LIST
35273: LIST
35274: LIST
35275: LIST
35276: LIST
35277: LIST
35278: LIST
35279: LIST
35280: LIST
35281: LIST
35282: LIST
35283: LIST
35284: LIST
35285: ST_TO_ADDR
// fDepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
35286: LD_ADDR_VAR 0 19
35290: PUSH
35291: LD_INT 0
35293: PUSH
35294: LD_INT 0
35296: PUSH
35297: EMPTY
35298: LIST
35299: LIST
35300: PUSH
35301: LD_INT 0
35303: PUSH
35304: LD_INT 1
35306: NEG
35307: PUSH
35308: EMPTY
35309: LIST
35310: LIST
35311: PUSH
35312: LD_INT 1
35314: PUSH
35315: LD_INT 0
35317: PUSH
35318: EMPTY
35319: LIST
35320: LIST
35321: PUSH
35322: LD_INT 1
35324: PUSH
35325: LD_INT 1
35327: PUSH
35328: EMPTY
35329: LIST
35330: LIST
35331: PUSH
35332: LD_INT 0
35334: PUSH
35335: LD_INT 1
35337: PUSH
35338: EMPTY
35339: LIST
35340: LIST
35341: PUSH
35342: LD_INT 1
35344: NEG
35345: PUSH
35346: LD_INT 0
35348: PUSH
35349: EMPTY
35350: LIST
35351: LIST
35352: PUSH
35353: LD_INT 1
35355: NEG
35356: PUSH
35357: LD_INT 1
35359: NEG
35360: PUSH
35361: EMPTY
35362: LIST
35363: LIST
35364: PUSH
35365: LD_INT 1
35367: NEG
35368: PUSH
35369: LD_INT 2
35371: NEG
35372: PUSH
35373: EMPTY
35374: LIST
35375: LIST
35376: PUSH
35377: LD_INT 0
35379: PUSH
35380: LD_INT 2
35382: NEG
35383: PUSH
35384: EMPTY
35385: LIST
35386: LIST
35387: PUSH
35388: LD_INT 1
35390: PUSH
35391: LD_INT 1
35393: NEG
35394: PUSH
35395: EMPTY
35396: LIST
35397: LIST
35398: PUSH
35399: LD_INT 2
35401: PUSH
35402: LD_INT 0
35404: PUSH
35405: EMPTY
35406: LIST
35407: LIST
35408: PUSH
35409: LD_INT 2
35411: PUSH
35412: LD_INT 1
35414: PUSH
35415: EMPTY
35416: LIST
35417: LIST
35418: PUSH
35419: LD_INT 2
35421: PUSH
35422: LD_INT 2
35424: PUSH
35425: EMPTY
35426: LIST
35427: LIST
35428: PUSH
35429: LD_INT 1
35431: PUSH
35432: LD_INT 2
35434: PUSH
35435: EMPTY
35436: LIST
35437: LIST
35438: PUSH
35439: LD_INT 0
35441: PUSH
35442: LD_INT 2
35444: PUSH
35445: EMPTY
35446: LIST
35447: LIST
35448: PUSH
35449: LD_INT 1
35451: NEG
35452: PUSH
35453: LD_INT 1
35455: PUSH
35456: EMPTY
35457: LIST
35458: LIST
35459: PUSH
35460: LD_INT 2
35462: NEG
35463: PUSH
35464: LD_INT 0
35466: PUSH
35467: EMPTY
35468: LIST
35469: LIST
35470: PUSH
35471: LD_INT 2
35473: NEG
35474: PUSH
35475: LD_INT 1
35477: NEG
35478: PUSH
35479: EMPTY
35480: LIST
35481: LIST
35482: PUSH
35483: LD_INT 2
35485: NEG
35486: PUSH
35487: LD_INT 2
35489: NEG
35490: PUSH
35491: EMPTY
35492: LIST
35493: LIST
35494: PUSH
35495: EMPTY
35496: LIST
35497: LIST
35498: LIST
35499: LIST
35500: LIST
35501: LIST
35502: LIST
35503: LIST
35504: LIST
35505: LIST
35506: LIST
35507: LIST
35508: LIST
35509: LIST
35510: LIST
35511: LIST
35512: LIST
35513: LIST
35514: LIST
35515: ST_TO_ADDR
// fDepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
35516: LD_ADDR_VAR 0 20
35520: PUSH
35521: LD_INT 0
35523: PUSH
35524: LD_INT 0
35526: PUSH
35527: EMPTY
35528: LIST
35529: LIST
35530: PUSH
35531: LD_INT 0
35533: PUSH
35534: LD_INT 1
35536: NEG
35537: PUSH
35538: EMPTY
35539: LIST
35540: LIST
35541: PUSH
35542: LD_INT 1
35544: PUSH
35545: LD_INT 0
35547: PUSH
35548: EMPTY
35549: LIST
35550: LIST
35551: PUSH
35552: LD_INT 1
35554: PUSH
35555: LD_INT 1
35557: PUSH
35558: EMPTY
35559: LIST
35560: LIST
35561: PUSH
35562: LD_INT 0
35564: PUSH
35565: LD_INT 1
35567: PUSH
35568: EMPTY
35569: LIST
35570: LIST
35571: PUSH
35572: LD_INT 1
35574: NEG
35575: PUSH
35576: LD_INT 0
35578: PUSH
35579: EMPTY
35580: LIST
35581: LIST
35582: PUSH
35583: LD_INT 1
35585: NEG
35586: PUSH
35587: LD_INT 1
35589: NEG
35590: PUSH
35591: EMPTY
35592: LIST
35593: LIST
35594: PUSH
35595: LD_INT 1
35597: NEG
35598: PUSH
35599: LD_INT 2
35601: NEG
35602: PUSH
35603: EMPTY
35604: LIST
35605: LIST
35606: PUSH
35607: LD_INT 0
35609: PUSH
35610: LD_INT 2
35612: NEG
35613: PUSH
35614: EMPTY
35615: LIST
35616: LIST
35617: PUSH
35618: LD_INT 1
35620: PUSH
35621: LD_INT 1
35623: NEG
35624: PUSH
35625: EMPTY
35626: LIST
35627: LIST
35628: PUSH
35629: LD_INT 2
35631: PUSH
35632: LD_INT 0
35634: PUSH
35635: EMPTY
35636: LIST
35637: LIST
35638: PUSH
35639: LD_INT 2
35641: PUSH
35642: LD_INT 1
35644: PUSH
35645: EMPTY
35646: LIST
35647: LIST
35648: PUSH
35649: LD_INT 2
35651: PUSH
35652: LD_INT 2
35654: PUSH
35655: EMPTY
35656: LIST
35657: LIST
35658: PUSH
35659: LD_INT 1
35661: PUSH
35662: LD_INT 2
35664: PUSH
35665: EMPTY
35666: LIST
35667: LIST
35668: PUSH
35669: LD_INT 0
35671: PUSH
35672: LD_INT 2
35674: PUSH
35675: EMPTY
35676: LIST
35677: LIST
35678: PUSH
35679: LD_INT 1
35681: NEG
35682: PUSH
35683: LD_INT 1
35685: PUSH
35686: EMPTY
35687: LIST
35688: LIST
35689: PUSH
35690: LD_INT 2
35692: NEG
35693: PUSH
35694: LD_INT 0
35696: PUSH
35697: EMPTY
35698: LIST
35699: LIST
35700: PUSH
35701: LD_INT 2
35703: NEG
35704: PUSH
35705: LD_INT 1
35707: NEG
35708: PUSH
35709: EMPTY
35710: LIST
35711: LIST
35712: PUSH
35713: LD_INT 2
35715: NEG
35716: PUSH
35717: LD_INT 2
35719: NEG
35720: PUSH
35721: EMPTY
35722: LIST
35723: LIST
35724: PUSH
35725: EMPTY
35726: LIST
35727: LIST
35728: LIST
35729: LIST
35730: LIST
35731: LIST
35732: LIST
35733: LIST
35734: LIST
35735: LIST
35736: LIST
35737: LIST
35738: LIST
35739: LIST
35740: LIST
35741: LIST
35742: LIST
35743: LIST
35744: LIST
35745: ST_TO_ADDR
// fDepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
35746: LD_ADDR_VAR 0 21
35750: PUSH
35751: LD_INT 0
35753: PUSH
35754: LD_INT 0
35756: PUSH
35757: EMPTY
35758: LIST
35759: LIST
35760: PUSH
35761: LD_INT 0
35763: PUSH
35764: LD_INT 1
35766: NEG
35767: PUSH
35768: EMPTY
35769: LIST
35770: LIST
35771: PUSH
35772: LD_INT 1
35774: PUSH
35775: LD_INT 0
35777: PUSH
35778: EMPTY
35779: LIST
35780: LIST
35781: PUSH
35782: LD_INT 1
35784: PUSH
35785: LD_INT 1
35787: PUSH
35788: EMPTY
35789: LIST
35790: LIST
35791: PUSH
35792: LD_INT 0
35794: PUSH
35795: LD_INT 1
35797: PUSH
35798: EMPTY
35799: LIST
35800: LIST
35801: PUSH
35802: LD_INT 1
35804: NEG
35805: PUSH
35806: LD_INT 0
35808: PUSH
35809: EMPTY
35810: LIST
35811: LIST
35812: PUSH
35813: LD_INT 1
35815: NEG
35816: PUSH
35817: LD_INT 1
35819: NEG
35820: PUSH
35821: EMPTY
35822: LIST
35823: LIST
35824: PUSH
35825: LD_INT 1
35827: NEG
35828: PUSH
35829: LD_INT 2
35831: NEG
35832: PUSH
35833: EMPTY
35834: LIST
35835: LIST
35836: PUSH
35837: LD_INT 0
35839: PUSH
35840: LD_INT 2
35842: NEG
35843: PUSH
35844: EMPTY
35845: LIST
35846: LIST
35847: PUSH
35848: LD_INT 1
35850: PUSH
35851: LD_INT 1
35853: NEG
35854: PUSH
35855: EMPTY
35856: LIST
35857: LIST
35858: PUSH
35859: LD_INT 2
35861: PUSH
35862: LD_INT 0
35864: PUSH
35865: EMPTY
35866: LIST
35867: LIST
35868: PUSH
35869: LD_INT 2
35871: PUSH
35872: LD_INT 1
35874: PUSH
35875: EMPTY
35876: LIST
35877: LIST
35878: PUSH
35879: LD_INT 2
35881: PUSH
35882: LD_INT 2
35884: PUSH
35885: EMPTY
35886: LIST
35887: LIST
35888: PUSH
35889: LD_INT 1
35891: PUSH
35892: LD_INT 2
35894: PUSH
35895: EMPTY
35896: LIST
35897: LIST
35898: PUSH
35899: LD_INT 0
35901: PUSH
35902: LD_INT 2
35904: PUSH
35905: EMPTY
35906: LIST
35907: LIST
35908: PUSH
35909: LD_INT 1
35911: NEG
35912: PUSH
35913: LD_INT 1
35915: PUSH
35916: EMPTY
35917: LIST
35918: LIST
35919: PUSH
35920: LD_INT 2
35922: NEG
35923: PUSH
35924: LD_INT 0
35926: PUSH
35927: EMPTY
35928: LIST
35929: LIST
35930: PUSH
35931: LD_INT 2
35933: NEG
35934: PUSH
35935: LD_INT 1
35937: NEG
35938: PUSH
35939: EMPTY
35940: LIST
35941: LIST
35942: PUSH
35943: LD_INT 2
35945: NEG
35946: PUSH
35947: LD_INT 2
35949: NEG
35950: PUSH
35951: EMPTY
35952: LIST
35953: LIST
35954: PUSH
35955: EMPTY
35956: LIST
35957: LIST
35958: LIST
35959: LIST
35960: LIST
35961: LIST
35962: LIST
35963: LIST
35964: LIST
35965: LIST
35966: LIST
35967: LIST
35968: LIST
35969: LIST
35970: LIST
35971: LIST
35972: LIST
35973: LIST
35974: LIST
35975: ST_TO_ADDR
// fDepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
35976: LD_ADDR_VAR 0 22
35980: PUSH
35981: LD_INT 0
35983: PUSH
35984: LD_INT 0
35986: PUSH
35987: EMPTY
35988: LIST
35989: LIST
35990: PUSH
35991: LD_INT 0
35993: PUSH
35994: LD_INT 1
35996: NEG
35997: PUSH
35998: EMPTY
35999: LIST
36000: LIST
36001: PUSH
36002: LD_INT 1
36004: PUSH
36005: LD_INT 0
36007: PUSH
36008: EMPTY
36009: LIST
36010: LIST
36011: PUSH
36012: LD_INT 1
36014: PUSH
36015: LD_INT 1
36017: PUSH
36018: EMPTY
36019: LIST
36020: LIST
36021: PUSH
36022: LD_INT 0
36024: PUSH
36025: LD_INT 1
36027: PUSH
36028: EMPTY
36029: LIST
36030: LIST
36031: PUSH
36032: LD_INT 1
36034: NEG
36035: PUSH
36036: LD_INT 0
36038: PUSH
36039: EMPTY
36040: LIST
36041: LIST
36042: PUSH
36043: LD_INT 1
36045: NEG
36046: PUSH
36047: LD_INT 1
36049: NEG
36050: PUSH
36051: EMPTY
36052: LIST
36053: LIST
36054: PUSH
36055: LD_INT 1
36057: NEG
36058: PUSH
36059: LD_INT 2
36061: NEG
36062: PUSH
36063: EMPTY
36064: LIST
36065: LIST
36066: PUSH
36067: LD_INT 0
36069: PUSH
36070: LD_INT 2
36072: NEG
36073: PUSH
36074: EMPTY
36075: LIST
36076: LIST
36077: PUSH
36078: LD_INT 1
36080: PUSH
36081: LD_INT 1
36083: NEG
36084: PUSH
36085: EMPTY
36086: LIST
36087: LIST
36088: PUSH
36089: LD_INT 2
36091: PUSH
36092: LD_INT 0
36094: PUSH
36095: EMPTY
36096: LIST
36097: LIST
36098: PUSH
36099: LD_INT 2
36101: PUSH
36102: LD_INT 1
36104: PUSH
36105: EMPTY
36106: LIST
36107: LIST
36108: PUSH
36109: LD_INT 2
36111: PUSH
36112: LD_INT 2
36114: PUSH
36115: EMPTY
36116: LIST
36117: LIST
36118: PUSH
36119: LD_INT 1
36121: PUSH
36122: LD_INT 2
36124: PUSH
36125: EMPTY
36126: LIST
36127: LIST
36128: PUSH
36129: LD_INT 0
36131: PUSH
36132: LD_INT 2
36134: PUSH
36135: EMPTY
36136: LIST
36137: LIST
36138: PUSH
36139: LD_INT 1
36141: NEG
36142: PUSH
36143: LD_INT 1
36145: PUSH
36146: EMPTY
36147: LIST
36148: LIST
36149: PUSH
36150: LD_INT 2
36152: NEG
36153: PUSH
36154: LD_INT 0
36156: PUSH
36157: EMPTY
36158: LIST
36159: LIST
36160: PUSH
36161: LD_INT 2
36163: NEG
36164: PUSH
36165: LD_INT 1
36167: NEG
36168: PUSH
36169: EMPTY
36170: LIST
36171: LIST
36172: PUSH
36173: LD_INT 2
36175: NEG
36176: PUSH
36177: LD_INT 2
36179: NEG
36180: PUSH
36181: EMPTY
36182: LIST
36183: LIST
36184: PUSH
36185: EMPTY
36186: LIST
36187: LIST
36188: LIST
36189: LIST
36190: LIST
36191: LIST
36192: LIST
36193: LIST
36194: LIST
36195: LIST
36196: LIST
36197: LIST
36198: LIST
36199: LIST
36200: LIST
36201: LIST
36202: LIST
36203: LIST
36204: LIST
36205: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
36206: LD_ADDR_VAR 0 23
36210: PUSH
36211: LD_INT 0
36213: PUSH
36214: LD_INT 0
36216: PUSH
36217: EMPTY
36218: LIST
36219: LIST
36220: PUSH
36221: LD_INT 0
36223: PUSH
36224: LD_INT 1
36226: NEG
36227: PUSH
36228: EMPTY
36229: LIST
36230: LIST
36231: PUSH
36232: LD_INT 1
36234: PUSH
36235: LD_INT 0
36237: PUSH
36238: EMPTY
36239: LIST
36240: LIST
36241: PUSH
36242: LD_INT 1
36244: PUSH
36245: LD_INT 1
36247: PUSH
36248: EMPTY
36249: LIST
36250: LIST
36251: PUSH
36252: LD_INT 0
36254: PUSH
36255: LD_INT 1
36257: PUSH
36258: EMPTY
36259: LIST
36260: LIST
36261: PUSH
36262: LD_INT 1
36264: NEG
36265: PUSH
36266: LD_INT 0
36268: PUSH
36269: EMPTY
36270: LIST
36271: LIST
36272: PUSH
36273: LD_INT 1
36275: NEG
36276: PUSH
36277: LD_INT 1
36279: NEG
36280: PUSH
36281: EMPTY
36282: LIST
36283: LIST
36284: PUSH
36285: LD_INT 1
36287: NEG
36288: PUSH
36289: LD_INT 2
36291: NEG
36292: PUSH
36293: EMPTY
36294: LIST
36295: LIST
36296: PUSH
36297: LD_INT 0
36299: PUSH
36300: LD_INT 2
36302: NEG
36303: PUSH
36304: EMPTY
36305: LIST
36306: LIST
36307: PUSH
36308: LD_INT 1
36310: PUSH
36311: LD_INT 1
36313: NEG
36314: PUSH
36315: EMPTY
36316: LIST
36317: LIST
36318: PUSH
36319: LD_INT 2
36321: PUSH
36322: LD_INT 0
36324: PUSH
36325: EMPTY
36326: LIST
36327: LIST
36328: PUSH
36329: LD_INT 2
36331: PUSH
36332: LD_INT 1
36334: PUSH
36335: EMPTY
36336: LIST
36337: LIST
36338: PUSH
36339: LD_INT 2
36341: PUSH
36342: LD_INT 2
36344: PUSH
36345: EMPTY
36346: LIST
36347: LIST
36348: PUSH
36349: LD_INT 1
36351: PUSH
36352: LD_INT 2
36354: PUSH
36355: EMPTY
36356: LIST
36357: LIST
36358: PUSH
36359: LD_INT 0
36361: PUSH
36362: LD_INT 2
36364: PUSH
36365: EMPTY
36366: LIST
36367: LIST
36368: PUSH
36369: LD_INT 1
36371: NEG
36372: PUSH
36373: LD_INT 1
36375: PUSH
36376: EMPTY
36377: LIST
36378: LIST
36379: PUSH
36380: LD_INT 2
36382: NEG
36383: PUSH
36384: LD_INT 0
36386: PUSH
36387: EMPTY
36388: LIST
36389: LIST
36390: PUSH
36391: LD_INT 2
36393: NEG
36394: PUSH
36395: LD_INT 1
36397: NEG
36398: PUSH
36399: EMPTY
36400: LIST
36401: LIST
36402: PUSH
36403: LD_INT 2
36405: NEG
36406: PUSH
36407: LD_INT 2
36409: NEG
36410: PUSH
36411: EMPTY
36412: LIST
36413: LIST
36414: PUSH
36415: LD_INT 2
36417: NEG
36418: PUSH
36419: LD_INT 3
36421: NEG
36422: PUSH
36423: EMPTY
36424: LIST
36425: LIST
36426: PUSH
36427: LD_INT 1
36429: NEG
36430: PUSH
36431: LD_INT 3
36433: NEG
36434: PUSH
36435: EMPTY
36436: LIST
36437: LIST
36438: PUSH
36439: LD_INT 1
36441: PUSH
36442: LD_INT 2
36444: NEG
36445: PUSH
36446: EMPTY
36447: LIST
36448: LIST
36449: PUSH
36450: LD_INT 2
36452: PUSH
36453: LD_INT 1
36455: NEG
36456: PUSH
36457: EMPTY
36458: LIST
36459: LIST
36460: PUSH
36461: EMPTY
36462: LIST
36463: LIST
36464: LIST
36465: LIST
36466: LIST
36467: LIST
36468: LIST
36469: LIST
36470: LIST
36471: LIST
36472: LIST
36473: LIST
36474: LIST
36475: LIST
36476: LIST
36477: LIST
36478: LIST
36479: LIST
36480: LIST
36481: LIST
36482: LIST
36483: LIST
36484: LIST
36485: ST_TO_ADDR
// fDepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
36486: LD_ADDR_VAR 0 24
36490: PUSH
36491: LD_INT 0
36493: PUSH
36494: LD_INT 0
36496: PUSH
36497: EMPTY
36498: LIST
36499: LIST
36500: PUSH
36501: LD_INT 0
36503: PUSH
36504: LD_INT 1
36506: NEG
36507: PUSH
36508: EMPTY
36509: LIST
36510: LIST
36511: PUSH
36512: LD_INT 1
36514: PUSH
36515: LD_INT 0
36517: PUSH
36518: EMPTY
36519: LIST
36520: LIST
36521: PUSH
36522: LD_INT 1
36524: PUSH
36525: LD_INT 1
36527: PUSH
36528: EMPTY
36529: LIST
36530: LIST
36531: PUSH
36532: LD_INT 0
36534: PUSH
36535: LD_INT 1
36537: PUSH
36538: EMPTY
36539: LIST
36540: LIST
36541: PUSH
36542: LD_INT 1
36544: NEG
36545: PUSH
36546: LD_INT 0
36548: PUSH
36549: EMPTY
36550: LIST
36551: LIST
36552: PUSH
36553: LD_INT 1
36555: NEG
36556: PUSH
36557: LD_INT 1
36559: NEG
36560: PUSH
36561: EMPTY
36562: LIST
36563: LIST
36564: PUSH
36565: LD_INT 1
36567: NEG
36568: PUSH
36569: LD_INT 2
36571: NEG
36572: PUSH
36573: EMPTY
36574: LIST
36575: LIST
36576: PUSH
36577: LD_INT 0
36579: PUSH
36580: LD_INT 2
36582: NEG
36583: PUSH
36584: EMPTY
36585: LIST
36586: LIST
36587: PUSH
36588: LD_INT 1
36590: PUSH
36591: LD_INT 1
36593: NEG
36594: PUSH
36595: EMPTY
36596: LIST
36597: LIST
36598: PUSH
36599: LD_INT 2
36601: PUSH
36602: LD_INT 0
36604: PUSH
36605: EMPTY
36606: LIST
36607: LIST
36608: PUSH
36609: LD_INT 2
36611: PUSH
36612: LD_INT 1
36614: PUSH
36615: EMPTY
36616: LIST
36617: LIST
36618: PUSH
36619: LD_INT 2
36621: PUSH
36622: LD_INT 2
36624: PUSH
36625: EMPTY
36626: LIST
36627: LIST
36628: PUSH
36629: LD_INT 1
36631: PUSH
36632: LD_INT 2
36634: PUSH
36635: EMPTY
36636: LIST
36637: LIST
36638: PUSH
36639: LD_INT 0
36641: PUSH
36642: LD_INT 2
36644: PUSH
36645: EMPTY
36646: LIST
36647: LIST
36648: PUSH
36649: LD_INT 1
36651: NEG
36652: PUSH
36653: LD_INT 1
36655: PUSH
36656: EMPTY
36657: LIST
36658: LIST
36659: PUSH
36660: LD_INT 2
36662: NEG
36663: PUSH
36664: LD_INT 0
36666: PUSH
36667: EMPTY
36668: LIST
36669: LIST
36670: PUSH
36671: LD_INT 2
36673: NEG
36674: PUSH
36675: LD_INT 1
36677: NEG
36678: PUSH
36679: EMPTY
36680: LIST
36681: LIST
36682: PUSH
36683: LD_INT 2
36685: NEG
36686: PUSH
36687: LD_INT 2
36689: NEG
36690: PUSH
36691: EMPTY
36692: LIST
36693: LIST
36694: PUSH
36695: LD_INT 1
36697: PUSH
36698: LD_INT 2
36700: NEG
36701: PUSH
36702: EMPTY
36703: LIST
36704: LIST
36705: PUSH
36706: LD_INT 2
36708: PUSH
36709: LD_INT 1
36711: NEG
36712: PUSH
36713: EMPTY
36714: LIST
36715: LIST
36716: PUSH
36717: LD_INT 3
36719: PUSH
36720: LD_INT 1
36722: PUSH
36723: EMPTY
36724: LIST
36725: LIST
36726: PUSH
36727: LD_INT 3
36729: PUSH
36730: LD_INT 2
36732: PUSH
36733: EMPTY
36734: LIST
36735: LIST
36736: PUSH
36737: EMPTY
36738: LIST
36739: LIST
36740: LIST
36741: LIST
36742: LIST
36743: LIST
36744: LIST
36745: LIST
36746: LIST
36747: LIST
36748: LIST
36749: LIST
36750: LIST
36751: LIST
36752: LIST
36753: LIST
36754: LIST
36755: LIST
36756: LIST
36757: LIST
36758: LIST
36759: LIST
36760: LIST
36761: ST_TO_ADDR
// fDepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
36762: LD_ADDR_VAR 0 25
36766: PUSH
36767: LD_INT 0
36769: PUSH
36770: LD_INT 0
36772: PUSH
36773: EMPTY
36774: LIST
36775: LIST
36776: PUSH
36777: LD_INT 0
36779: PUSH
36780: LD_INT 1
36782: NEG
36783: PUSH
36784: EMPTY
36785: LIST
36786: LIST
36787: PUSH
36788: LD_INT 1
36790: PUSH
36791: LD_INT 0
36793: PUSH
36794: EMPTY
36795: LIST
36796: LIST
36797: PUSH
36798: LD_INT 1
36800: PUSH
36801: LD_INT 1
36803: PUSH
36804: EMPTY
36805: LIST
36806: LIST
36807: PUSH
36808: LD_INT 0
36810: PUSH
36811: LD_INT 1
36813: PUSH
36814: EMPTY
36815: LIST
36816: LIST
36817: PUSH
36818: LD_INT 1
36820: NEG
36821: PUSH
36822: LD_INT 0
36824: PUSH
36825: EMPTY
36826: LIST
36827: LIST
36828: PUSH
36829: LD_INT 1
36831: NEG
36832: PUSH
36833: LD_INT 1
36835: NEG
36836: PUSH
36837: EMPTY
36838: LIST
36839: LIST
36840: PUSH
36841: LD_INT 1
36843: NEG
36844: PUSH
36845: LD_INT 2
36847: NEG
36848: PUSH
36849: EMPTY
36850: LIST
36851: LIST
36852: PUSH
36853: LD_INT 0
36855: PUSH
36856: LD_INT 2
36858: NEG
36859: PUSH
36860: EMPTY
36861: LIST
36862: LIST
36863: PUSH
36864: LD_INT 1
36866: PUSH
36867: LD_INT 1
36869: NEG
36870: PUSH
36871: EMPTY
36872: LIST
36873: LIST
36874: PUSH
36875: LD_INT 2
36877: PUSH
36878: LD_INT 0
36880: PUSH
36881: EMPTY
36882: LIST
36883: LIST
36884: PUSH
36885: LD_INT 2
36887: PUSH
36888: LD_INT 1
36890: PUSH
36891: EMPTY
36892: LIST
36893: LIST
36894: PUSH
36895: LD_INT 2
36897: PUSH
36898: LD_INT 2
36900: PUSH
36901: EMPTY
36902: LIST
36903: LIST
36904: PUSH
36905: LD_INT 1
36907: PUSH
36908: LD_INT 2
36910: PUSH
36911: EMPTY
36912: LIST
36913: LIST
36914: PUSH
36915: LD_INT 0
36917: PUSH
36918: LD_INT 2
36920: PUSH
36921: EMPTY
36922: LIST
36923: LIST
36924: PUSH
36925: LD_INT 1
36927: NEG
36928: PUSH
36929: LD_INT 1
36931: PUSH
36932: EMPTY
36933: LIST
36934: LIST
36935: PUSH
36936: LD_INT 2
36938: NEG
36939: PUSH
36940: LD_INT 0
36942: PUSH
36943: EMPTY
36944: LIST
36945: LIST
36946: PUSH
36947: LD_INT 2
36949: NEG
36950: PUSH
36951: LD_INT 1
36953: NEG
36954: PUSH
36955: EMPTY
36956: LIST
36957: LIST
36958: PUSH
36959: LD_INT 2
36961: NEG
36962: PUSH
36963: LD_INT 2
36965: NEG
36966: PUSH
36967: EMPTY
36968: LIST
36969: LIST
36970: PUSH
36971: LD_INT 3
36973: PUSH
36974: LD_INT 1
36976: PUSH
36977: EMPTY
36978: LIST
36979: LIST
36980: PUSH
36981: LD_INT 3
36983: PUSH
36984: LD_INT 2
36986: PUSH
36987: EMPTY
36988: LIST
36989: LIST
36990: PUSH
36991: LD_INT 2
36993: PUSH
36994: LD_INT 3
36996: PUSH
36997: EMPTY
36998: LIST
36999: LIST
37000: PUSH
37001: LD_INT 1
37003: PUSH
37004: LD_INT 3
37006: PUSH
37007: EMPTY
37008: LIST
37009: LIST
37010: PUSH
37011: EMPTY
37012: LIST
37013: LIST
37014: LIST
37015: LIST
37016: LIST
37017: LIST
37018: LIST
37019: LIST
37020: LIST
37021: LIST
37022: LIST
37023: LIST
37024: LIST
37025: LIST
37026: LIST
37027: LIST
37028: LIST
37029: LIST
37030: LIST
37031: LIST
37032: LIST
37033: LIST
37034: LIST
37035: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
37036: LD_ADDR_VAR 0 26
37040: PUSH
37041: LD_INT 0
37043: PUSH
37044: LD_INT 0
37046: PUSH
37047: EMPTY
37048: LIST
37049: LIST
37050: PUSH
37051: LD_INT 0
37053: PUSH
37054: LD_INT 1
37056: NEG
37057: PUSH
37058: EMPTY
37059: LIST
37060: LIST
37061: PUSH
37062: LD_INT 1
37064: PUSH
37065: LD_INT 0
37067: PUSH
37068: EMPTY
37069: LIST
37070: LIST
37071: PUSH
37072: LD_INT 1
37074: PUSH
37075: LD_INT 1
37077: PUSH
37078: EMPTY
37079: LIST
37080: LIST
37081: PUSH
37082: LD_INT 0
37084: PUSH
37085: LD_INT 1
37087: PUSH
37088: EMPTY
37089: LIST
37090: LIST
37091: PUSH
37092: LD_INT 1
37094: NEG
37095: PUSH
37096: LD_INT 0
37098: PUSH
37099: EMPTY
37100: LIST
37101: LIST
37102: PUSH
37103: LD_INT 1
37105: NEG
37106: PUSH
37107: LD_INT 1
37109: NEG
37110: PUSH
37111: EMPTY
37112: LIST
37113: LIST
37114: PUSH
37115: LD_INT 1
37117: NEG
37118: PUSH
37119: LD_INT 2
37121: NEG
37122: PUSH
37123: EMPTY
37124: LIST
37125: LIST
37126: PUSH
37127: LD_INT 0
37129: PUSH
37130: LD_INT 2
37132: NEG
37133: PUSH
37134: EMPTY
37135: LIST
37136: LIST
37137: PUSH
37138: LD_INT 1
37140: PUSH
37141: LD_INT 1
37143: NEG
37144: PUSH
37145: EMPTY
37146: LIST
37147: LIST
37148: PUSH
37149: LD_INT 2
37151: PUSH
37152: LD_INT 0
37154: PUSH
37155: EMPTY
37156: LIST
37157: LIST
37158: PUSH
37159: LD_INT 2
37161: PUSH
37162: LD_INT 1
37164: PUSH
37165: EMPTY
37166: LIST
37167: LIST
37168: PUSH
37169: LD_INT 2
37171: PUSH
37172: LD_INT 2
37174: PUSH
37175: EMPTY
37176: LIST
37177: LIST
37178: PUSH
37179: LD_INT 1
37181: PUSH
37182: LD_INT 2
37184: PUSH
37185: EMPTY
37186: LIST
37187: LIST
37188: PUSH
37189: LD_INT 0
37191: PUSH
37192: LD_INT 2
37194: PUSH
37195: EMPTY
37196: LIST
37197: LIST
37198: PUSH
37199: LD_INT 1
37201: NEG
37202: PUSH
37203: LD_INT 1
37205: PUSH
37206: EMPTY
37207: LIST
37208: LIST
37209: PUSH
37210: LD_INT 2
37212: NEG
37213: PUSH
37214: LD_INT 0
37216: PUSH
37217: EMPTY
37218: LIST
37219: LIST
37220: PUSH
37221: LD_INT 2
37223: NEG
37224: PUSH
37225: LD_INT 1
37227: NEG
37228: PUSH
37229: EMPTY
37230: LIST
37231: LIST
37232: PUSH
37233: LD_INT 2
37235: NEG
37236: PUSH
37237: LD_INT 2
37239: NEG
37240: PUSH
37241: EMPTY
37242: LIST
37243: LIST
37244: PUSH
37245: LD_INT 2
37247: PUSH
37248: LD_INT 3
37250: PUSH
37251: EMPTY
37252: LIST
37253: LIST
37254: PUSH
37255: LD_INT 1
37257: PUSH
37258: LD_INT 3
37260: PUSH
37261: EMPTY
37262: LIST
37263: LIST
37264: PUSH
37265: LD_INT 1
37267: NEG
37268: PUSH
37269: LD_INT 2
37271: PUSH
37272: EMPTY
37273: LIST
37274: LIST
37275: PUSH
37276: LD_INT 2
37278: NEG
37279: PUSH
37280: LD_INT 1
37282: PUSH
37283: EMPTY
37284: LIST
37285: LIST
37286: PUSH
37287: EMPTY
37288: LIST
37289: LIST
37290: LIST
37291: LIST
37292: LIST
37293: LIST
37294: LIST
37295: LIST
37296: LIST
37297: LIST
37298: LIST
37299: LIST
37300: LIST
37301: LIST
37302: LIST
37303: LIST
37304: LIST
37305: LIST
37306: LIST
37307: LIST
37308: LIST
37309: LIST
37310: LIST
37311: ST_TO_ADDR
// fDepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
37312: LD_ADDR_VAR 0 27
37316: PUSH
37317: LD_INT 0
37319: PUSH
37320: LD_INT 0
37322: PUSH
37323: EMPTY
37324: LIST
37325: LIST
37326: PUSH
37327: LD_INT 0
37329: PUSH
37330: LD_INT 1
37332: NEG
37333: PUSH
37334: EMPTY
37335: LIST
37336: LIST
37337: PUSH
37338: LD_INT 1
37340: PUSH
37341: LD_INT 0
37343: PUSH
37344: EMPTY
37345: LIST
37346: LIST
37347: PUSH
37348: LD_INT 1
37350: PUSH
37351: LD_INT 1
37353: PUSH
37354: EMPTY
37355: LIST
37356: LIST
37357: PUSH
37358: LD_INT 0
37360: PUSH
37361: LD_INT 1
37363: PUSH
37364: EMPTY
37365: LIST
37366: LIST
37367: PUSH
37368: LD_INT 1
37370: NEG
37371: PUSH
37372: LD_INT 0
37374: PUSH
37375: EMPTY
37376: LIST
37377: LIST
37378: PUSH
37379: LD_INT 1
37381: NEG
37382: PUSH
37383: LD_INT 1
37385: NEG
37386: PUSH
37387: EMPTY
37388: LIST
37389: LIST
37390: PUSH
37391: LD_INT 1
37393: NEG
37394: PUSH
37395: LD_INT 2
37397: NEG
37398: PUSH
37399: EMPTY
37400: LIST
37401: LIST
37402: PUSH
37403: LD_INT 0
37405: PUSH
37406: LD_INT 2
37408: NEG
37409: PUSH
37410: EMPTY
37411: LIST
37412: LIST
37413: PUSH
37414: LD_INT 1
37416: PUSH
37417: LD_INT 1
37419: NEG
37420: PUSH
37421: EMPTY
37422: LIST
37423: LIST
37424: PUSH
37425: LD_INT 2
37427: PUSH
37428: LD_INT 0
37430: PUSH
37431: EMPTY
37432: LIST
37433: LIST
37434: PUSH
37435: LD_INT 2
37437: PUSH
37438: LD_INT 1
37440: PUSH
37441: EMPTY
37442: LIST
37443: LIST
37444: PUSH
37445: LD_INT 2
37447: PUSH
37448: LD_INT 2
37450: PUSH
37451: EMPTY
37452: LIST
37453: LIST
37454: PUSH
37455: LD_INT 1
37457: PUSH
37458: LD_INT 2
37460: PUSH
37461: EMPTY
37462: LIST
37463: LIST
37464: PUSH
37465: LD_INT 0
37467: PUSH
37468: LD_INT 2
37470: PUSH
37471: EMPTY
37472: LIST
37473: LIST
37474: PUSH
37475: LD_INT 1
37477: NEG
37478: PUSH
37479: LD_INT 1
37481: PUSH
37482: EMPTY
37483: LIST
37484: LIST
37485: PUSH
37486: LD_INT 2
37488: NEG
37489: PUSH
37490: LD_INT 0
37492: PUSH
37493: EMPTY
37494: LIST
37495: LIST
37496: PUSH
37497: LD_INT 2
37499: NEG
37500: PUSH
37501: LD_INT 1
37503: NEG
37504: PUSH
37505: EMPTY
37506: LIST
37507: LIST
37508: PUSH
37509: LD_INT 2
37511: NEG
37512: PUSH
37513: LD_INT 2
37515: NEG
37516: PUSH
37517: EMPTY
37518: LIST
37519: LIST
37520: PUSH
37521: LD_INT 1
37523: NEG
37524: PUSH
37525: LD_INT 2
37527: PUSH
37528: EMPTY
37529: LIST
37530: LIST
37531: PUSH
37532: LD_INT 2
37534: NEG
37535: PUSH
37536: LD_INT 1
37538: PUSH
37539: EMPTY
37540: LIST
37541: LIST
37542: PUSH
37543: LD_INT 3
37545: NEG
37546: PUSH
37547: LD_INT 1
37549: NEG
37550: PUSH
37551: EMPTY
37552: LIST
37553: LIST
37554: PUSH
37555: LD_INT 3
37557: NEG
37558: PUSH
37559: LD_INT 2
37561: NEG
37562: PUSH
37563: EMPTY
37564: LIST
37565: LIST
37566: PUSH
37567: EMPTY
37568: LIST
37569: LIST
37570: LIST
37571: LIST
37572: LIST
37573: LIST
37574: LIST
37575: LIST
37576: LIST
37577: LIST
37578: LIST
37579: LIST
37580: LIST
37581: LIST
37582: LIST
37583: LIST
37584: LIST
37585: LIST
37586: LIST
37587: LIST
37588: LIST
37589: LIST
37590: LIST
37591: ST_TO_ADDR
// fDepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
37592: LD_ADDR_VAR 0 28
37596: PUSH
37597: LD_INT 0
37599: PUSH
37600: LD_INT 0
37602: PUSH
37603: EMPTY
37604: LIST
37605: LIST
37606: PUSH
37607: LD_INT 0
37609: PUSH
37610: LD_INT 1
37612: NEG
37613: PUSH
37614: EMPTY
37615: LIST
37616: LIST
37617: PUSH
37618: LD_INT 1
37620: PUSH
37621: LD_INT 0
37623: PUSH
37624: EMPTY
37625: LIST
37626: LIST
37627: PUSH
37628: LD_INT 1
37630: PUSH
37631: LD_INT 1
37633: PUSH
37634: EMPTY
37635: LIST
37636: LIST
37637: PUSH
37638: LD_INT 0
37640: PUSH
37641: LD_INT 1
37643: PUSH
37644: EMPTY
37645: LIST
37646: LIST
37647: PUSH
37648: LD_INT 1
37650: NEG
37651: PUSH
37652: LD_INT 0
37654: PUSH
37655: EMPTY
37656: LIST
37657: LIST
37658: PUSH
37659: LD_INT 1
37661: NEG
37662: PUSH
37663: LD_INT 1
37665: NEG
37666: PUSH
37667: EMPTY
37668: LIST
37669: LIST
37670: PUSH
37671: LD_INT 1
37673: NEG
37674: PUSH
37675: LD_INT 2
37677: NEG
37678: PUSH
37679: EMPTY
37680: LIST
37681: LIST
37682: PUSH
37683: LD_INT 0
37685: PUSH
37686: LD_INT 2
37688: NEG
37689: PUSH
37690: EMPTY
37691: LIST
37692: LIST
37693: PUSH
37694: LD_INT 1
37696: PUSH
37697: LD_INT 1
37699: NEG
37700: PUSH
37701: EMPTY
37702: LIST
37703: LIST
37704: PUSH
37705: LD_INT 2
37707: PUSH
37708: LD_INT 0
37710: PUSH
37711: EMPTY
37712: LIST
37713: LIST
37714: PUSH
37715: LD_INT 2
37717: PUSH
37718: LD_INT 1
37720: PUSH
37721: EMPTY
37722: LIST
37723: LIST
37724: PUSH
37725: LD_INT 2
37727: PUSH
37728: LD_INT 2
37730: PUSH
37731: EMPTY
37732: LIST
37733: LIST
37734: PUSH
37735: LD_INT 1
37737: PUSH
37738: LD_INT 2
37740: PUSH
37741: EMPTY
37742: LIST
37743: LIST
37744: PUSH
37745: LD_INT 0
37747: PUSH
37748: LD_INT 2
37750: PUSH
37751: EMPTY
37752: LIST
37753: LIST
37754: PUSH
37755: LD_INT 1
37757: NEG
37758: PUSH
37759: LD_INT 1
37761: PUSH
37762: EMPTY
37763: LIST
37764: LIST
37765: PUSH
37766: LD_INT 2
37768: NEG
37769: PUSH
37770: LD_INT 0
37772: PUSH
37773: EMPTY
37774: LIST
37775: LIST
37776: PUSH
37777: LD_INT 2
37779: NEG
37780: PUSH
37781: LD_INT 1
37783: NEG
37784: PUSH
37785: EMPTY
37786: LIST
37787: LIST
37788: PUSH
37789: LD_INT 2
37791: NEG
37792: PUSH
37793: LD_INT 2
37795: NEG
37796: PUSH
37797: EMPTY
37798: LIST
37799: LIST
37800: PUSH
37801: LD_INT 2
37803: NEG
37804: PUSH
37805: LD_INT 3
37807: NEG
37808: PUSH
37809: EMPTY
37810: LIST
37811: LIST
37812: PUSH
37813: LD_INT 1
37815: NEG
37816: PUSH
37817: LD_INT 3
37819: NEG
37820: PUSH
37821: EMPTY
37822: LIST
37823: LIST
37824: PUSH
37825: LD_INT 3
37827: NEG
37828: PUSH
37829: LD_INT 1
37831: NEG
37832: PUSH
37833: EMPTY
37834: LIST
37835: LIST
37836: PUSH
37837: LD_INT 3
37839: NEG
37840: PUSH
37841: LD_INT 2
37843: NEG
37844: PUSH
37845: EMPTY
37846: LIST
37847: LIST
37848: PUSH
37849: EMPTY
37850: LIST
37851: LIST
37852: LIST
37853: LIST
37854: LIST
37855: LIST
37856: LIST
37857: LIST
37858: LIST
37859: LIST
37860: LIST
37861: LIST
37862: LIST
37863: LIST
37864: LIST
37865: LIST
37866: LIST
37867: LIST
37868: LIST
37869: LIST
37870: LIST
37871: LIST
37872: LIST
37873: ST_TO_ADDR
// fFactory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
37874: LD_ADDR_VAR 0 29
37878: PUSH
37879: LD_INT 0
37881: PUSH
37882: LD_INT 0
37884: PUSH
37885: EMPTY
37886: LIST
37887: LIST
37888: PUSH
37889: LD_INT 0
37891: PUSH
37892: LD_INT 1
37894: NEG
37895: PUSH
37896: EMPTY
37897: LIST
37898: LIST
37899: PUSH
37900: LD_INT 1
37902: PUSH
37903: LD_INT 0
37905: PUSH
37906: EMPTY
37907: LIST
37908: LIST
37909: PUSH
37910: LD_INT 1
37912: PUSH
37913: LD_INT 1
37915: PUSH
37916: EMPTY
37917: LIST
37918: LIST
37919: PUSH
37920: LD_INT 0
37922: PUSH
37923: LD_INT 1
37925: PUSH
37926: EMPTY
37927: LIST
37928: LIST
37929: PUSH
37930: LD_INT 1
37932: NEG
37933: PUSH
37934: LD_INT 0
37936: PUSH
37937: EMPTY
37938: LIST
37939: LIST
37940: PUSH
37941: LD_INT 1
37943: NEG
37944: PUSH
37945: LD_INT 1
37947: NEG
37948: PUSH
37949: EMPTY
37950: LIST
37951: LIST
37952: PUSH
37953: LD_INT 1
37955: NEG
37956: PUSH
37957: LD_INT 2
37959: NEG
37960: PUSH
37961: EMPTY
37962: LIST
37963: LIST
37964: PUSH
37965: LD_INT 0
37967: PUSH
37968: LD_INT 2
37970: NEG
37971: PUSH
37972: EMPTY
37973: LIST
37974: LIST
37975: PUSH
37976: LD_INT 1
37978: PUSH
37979: LD_INT 1
37981: NEG
37982: PUSH
37983: EMPTY
37984: LIST
37985: LIST
37986: PUSH
37987: LD_INT 2
37989: PUSH
37990: LD_INT 0
37992: PUSH
37993: EMPTY
37994: LIST
37995: LIST
37996: PUSH
37997: LD_INT 2
37999: PUSH
38000: LD_INT 1
38002: PUSH
38003: EMPTY
38004: LIST
38005: LIST
38006: PUSH
38007: LD_INT 1
38009: PUSH
38010: LD_INT 2
38012: PUSH
38013: EMPTY
38014: LIST
38015: LIST
38016: PUSH
38017: LD_INT 0
38019: PUSH
38020: LD_INT 2
38022: PUSH
38023: EMPTY
38024: LIST
38025: LIST
38026: PUSH
38027: LD_INT 1
38029: NEG
38030: PUSH
38031: LD_INT 1
38033: PUSH
38034: EMPTY
38035: LIST
38036: LIST
38037: PUSH
38038: LD_INT 2
38040: NEG
38041: PUSH
38042: LD_INT 1
38044: NEG
38045: PUSH
38046: EMPTY
38047: LIST
38048: LIST
38049: PUSH
38050: LD_INT 2
38052: NEG
38053: PUSH
38054: LD_INT 2
38056: NEG
38057: PUSH
38058: EMPTY
38059: LIST
38060: LIST
38061: PUSH
38062: LD_INT 2
38064: NEG
38065: PUSH
38066: LD_INT 3
38068: NEG
38069: PUSH
38070: EMPTY
38071: LIST
38072: LIST
38073: PUSH
38074: LD_INT 2
38076: PUSH
38077: LD_INT 1
38079: NEG
38080: PUSH
38081: EMPTY
38082: LIST
38083: LIST
38084: PUSH
38085: LD_INT 3
38087: PUSH
38088: LD_INT 1
38090: PUSH
38091: EMPTY
38092: LIST
38093: LIST
38094: PUSH
38095: LD_INT 1
38097: PUSH
38098: LD_INT 3
38100: PUSH
38101: EMPTY
38102: LIST
38103: LIST
38104: PUSH
38105: LD_INT 1
38107: NEG
38108: PUSH
38109: LD_INT 2
38111: PUSH
38112: EMPTY
38113: LIST
38114: LIST
38115: PUSH
38116: LD_INT 3
38118: NEG
38119: PUSH
38120: LD_INT 2
38122: NEG
38123: PUSH
38124: EMPTY
38125: LIST
38126: LIST
38127: PUSH
38128: EMPTY
38129: LIST
38130: LIST
38131: LIST
38132: LIST
38133: LIST
38134: LIST
38135: LIST
38136: LIST
38137: LIST
38138: LIST
38139: LIST
38140: LIST
38141: LIST
38142: LIST
38143: LIST
38144: LIST
38145: LIST
38146: LIST
38147: LIST
38148: LIST
38149: LIST
38150: LIST
38151: LIST
38152: ST_TO_ADDR
// fFactory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
38153: LD_ADDR_VAR 0 30
38157: PUSH
38158: LD_INT 0
38160: PUSH
38161: LD_INT 0
38163: PUSH
38164: EMPTY
38165: LIST
38166: LIST
38167: PUSH
38168: LD_INT 0
38170: PUSH
38171: LD_INT 1
38173: NEG
38174: PUSH
38175: EMPTY
38176: LIST
38177: LIST
38178: PUSH
38179: LD_INT 1
38181: PUSH
38182: LD_INT 0
38184: PUSH
38185: EMPTY
38186: LIST
38187: LIST
38188: PUSH
38189: LD_INT 1
38191: PUSH
38192: LD_INT 1
38194: PUSH
38195: EMPTY
38196: LIST
38197: LIST
38198: PUSH
38199: LD_INT 0
38201: PUSH
38202: LD_INT 1
38204: PUSH
38205: EMPTY
38206: LIST
38207: LIST
38208: PUSH
38209: LD_INT 1
38211: NEG
38212: PUSH
38213: LD_INT 0
38215: PUSH
38216: EMPTY
38217: LIST
38218: LIST
38219: PUSH
38220: LD_INT 1
38222: NEG
38223: PUSH
38224: LD_INT 1
38226: NEG
38227: PUSH
38228: EMPTY
38229: LIST
38230: LIST
38231: PUSH
38232: LD_INT 1
38234: NEG
38235: PUSH
38236: LD_INT 2
38238: NEG
38239: PUSH
38240: EMPTY
38241: LIST
38242: LIST
38243: PUSH
38244: LD_INT 0
38246: PUSH
38247: LD_INT 2
38249: NEG
38250: PUSH
38251: EMPTY
38252: LIST
38253: LIST
38254: PUSH
38255: LD_INT 1
38257: PUSH
38258: LD_INT 1
38260: NEG
38261: PUSH
38262: EMPTY
38263: LIST
38264: LIST
38265: PUSH
38266: LD_INT 2
38268: PUSH
38269: LD_INT 0
38271: PUSH
38272: EMPTY
38273: LIST
38274: LIST
38275: PUSH
38276: LD_INT 2
38278: PUSH
38279: LD_INT 1
38281: PUSH
38282: EMPTY
38283: LIST
38284: LIST
38285: PUSH
38286: LD_INT 2
38288: PUSH
38289: LD_INT 2
38291: PUSH
38292: EMPTY
38293: LIST
38294: LIST
38295: PUSH
38296: LD_INT 1
38298: PUSH
38299: LD_INT 2
38301: PUSH
38302: EMPTY
38303: LIST
38304: LIST
38305: PUSH
38306: LD_INT 1
38308: NEG
38309: PUSH
38310: LD_INT 1
38312: PUSH
38313: EMPTY
38314: LIST
38315: LIST
38316: PUSH
38317: LD_INT 2
38319: NEG
38320: PUSH
38321: LD_INT 0
38323: PUSH
38324: EMPTY
38325: LIST
38326: LIST
38327: PUSH
38328: LD_INT 2
38330: NEG
38331: PUSH
38332: LD_INT 1
38334: NEG
38335: PUSH
38336: EMPTY
38337: LIST
38338: LIST
38339: PUSH
38340: LD_INT 1
38342: NEG
38343: PUSH
38344: LD_INT 3
38346: NEG
38347: PUSH
38348: EMPTY
38349: LIST
38350: LIST
38351: PUSH
38352: LD_INT 1
38354: PUSH
38355: LD_INT 2
38357: NEG
38358: PUSH
38359: EMPTY
38360: LIST
38361: LIST
38362: PUSH
38363: LD_INT 3
38365: PUSH
38366: LD_INT 2
38368: PUSH
38369: EMPTY
38370: LIST
38371: LIST
38372: PUSH
38373: LD_INT 2
38375: PUSH
38376: LD_INT 3
38378: PUSH
38379: EMPTY
38380: LIST
38381: LIST
38382: PUSH
38383: LD_INT 2
38385: NEG
38386: PUSH
38387: LD_INT 1
38389: PUSH
38390: EMPTY
38391: LIST
38392: LIST
38393: PUSH
38394: LD_INT 3
38396: NEG
38397: PUSH
38398: LD_INT 1
38400: NEG
38401: PUSH
38402: EMPTY
38403: LIST
38404: LIST
38405: PUSH
38406: EMPTY
38407: LIST
38408: LIST
38409: LIST
38410: LIST
38411: LIST
38412: LIST
38413: LIST
38414: LIST
38415: LIST
38416: LIST
38417: LIST
38418: LIST
38419: LIST
38420: LIST
38421: LIST
38422: LIST
38423: LIST
38424: LIST
38425: LIST
38426: LIST
38427: LIST
38428: LIST
38429: LIST
38430: ST_TO_ADDR
// fFactory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
38431: LD_ADDR_VAR 0 31
38435: PUSH
38436: LD_INT 0
38438: PUSH
38439: LD_INT 0
38441: PUSH
38442: EMPTY
38443: LIST
38444: LIST
38445: PUSH
38446: LD_INT 0
38448: PUSH
38449: LD_INT 1
38451: NEG
38452: PUSH
38453: EMPTY
38454: LIST
38455: LIST
38456: PUSH
38457: LD_INT 1
38459: PUSH
38460: LD_INT 0
38462: PUSH
38463: EMPTY
38464: LIST
38465: LIST
38466: PUSH
38467: LD_INT 1
38469: PUSH
38470: LD_INT 1
38472: PUSH
38473: EMPTY
38474: LIST
38475: LIST
38476: PUSH
38477: LD_INT 0
38479: PUSH
38480: LD_INT 1
38482: PUSH
38483: EMPTY
38484: LIST
38485: LIST
38486: PUSH
38487: LD_INT 1
38489: NEG
38490: PUSH
38491: LD_INT 0
38493: PUSH
38494: EMPTY
38495: LIST
38496: LIST
38497: PUSH
38498: LD_INT 1
38500: NEG
38501: PUSH
38502: LD_INT 1
38504: NEG
38505: PUSH
38506: EMPTY
38507: LIST
38508: LIST
38509: PUSH
38510: LD_INT 1
38512: NEG
38513: PUSH
38514: LD_INT 2
38516: NEG
38517: PUSH
38518: EMPTY
38519: LIST
38520: LIST
38521: PUSH
38522: LD_INT 1
38524: PUSH
38525: LD_INT 1
38527: NEG
38528: PUSH
38529: EMPTY
38530: LIST
38531: LIST
38532: PUSH
38533: LD_INT 2
38535: PUSH
38536: LD_INT 0
38538: PUSH
38539: EMPTY
38540: LIST
38541: LIST
38542: PUSH
38543: LD_INT 2
38545: PUSH
38546: LD_INT 1
38548: PUSH
38549: EMPTY
38550: LIST
38551: LIST
38552: PUSH
38553: LD_INT 2
38555: PUSH
38556: LD_INT 2
38558: PUSH
38559: EMPTY
38560: LIST
38561: LIST
38562: PUSH
38563: LD_INT 1
38565: PUSH
38566: LD_INT 2
38568: PUSH
38569: EMPTY
38570: LIST
38571: LIST
38572: PUSH
38573: LD_INT 0
38575: PUSH
38576: LD_INT 2
38578: PUSH
38579: EMPTY
38580: LIST
38581: LIST
38582: PUSH
38583: LD_INT 1
38585: NEG
38586: PUSH
38587: LD_INT 1
38589: PUSH
38590: EMPTY
38591: LIST
38592: LIST
38593: PUSH
38594: LD_INT 2
38596: NEG
38597: PUSH
38598: LD_INT 1
38600: NEG
38601: PUSH
38602: EMPTY
38603: LIST
38604: LIST
38605: PUSH
38606: LD_INT 2
38608: NEG
38609: PUSH
38610: LD_INT 2
38612: NEG
38613: PUSH
38614: EMPTY
38615: LIST
38616: LIST
38617: PUSH
38618: LD_INT 2
38620: NEG
38621: PUSH
38622: LD_INT 3
38624: NEG
38625: PUSH
38626: EMPTY
38627: LIST
38628: LIST
38629: PUSH
38630: LD_INT 2
38632: PUSH
38633: LD_INT 1
38635: NEG
38636: PUSH
38637: EMPTY
38638: LIST
38639: LIST
38640: PUSH
38641: LD_INT 3
38643: PUSH
38644: LD_INT 1
38646: PUSH
38647: EMPTY
38648: LIST
38649: LIST
38650: PUSH
38651: LD_INT 1
38653: PUSH
38654: LD_INT 3
38656: PUSH
38657: EMPTY
38658: LIST
38659: LIST
38660: PUSH
38661: LD_INT 1
38663: NEG
38664: PUSH
38665: LD_INT 2
38667: PUSH
38668: EMPTY
38669: LIST
38670: LIST
38671: PUSH
38672: LD_INT 3
38674: NEG
38675: PUSH
38676: LD_INT 2
38678: NEG
38679: PUSH
38680: EMPTY
38681: LIST
38682: LIST
38683: PUSH
38684: EMPTY
38685: LIST
38686: LIST
38687: LIST
38688: LIST
38689: LIST
38690: LIST
38691: LIST
38692: LIST
38693: LIST
38694: LIST
38695: LIST
38696: LIST
38697: LIST
38698: LIST
38699: LIST
38700: LIST
38701: LIST
38702: LIST
38703: LIST
38704: LIST
38705: LIST
38706: LIST
38707: LIST
38708: ST_TO_ADDR
// fFactory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
38709: LD_ADDR_VAR 0 32
38713: PUSH
38714: LD_INT 0
38716: PUSH
38717: LD_INT 0
38719: PUSH
38720: EMPTY
38721: LIST
38722: LIST
38723: PUSH
38724: LD_INT 0
38726: PUSH
38727: LD_INT 1
38729: NEG
38730: PUSH
38731: EMPTY
38732: LIST
38733: LIST
38734: PUSH
38735: LD_INT 1
38737: PUSH
38738: LD_INT 0
38740: PUSH
38741: EMPTY
38742: LIST
38743: LIST
38744: PUSH
38745: LD_INT 1
38747: PUSH
38748: LD_INT 1
38750: PUSH
38751: EMPTY
38752: LIST
38753: LIST
38754: PUSH
38755: LD_INT 0
38757: PUSH
38758: LD_INT 1
38760: PUSH
38761: EMPTY
38762: LIST
38763: LIST
38764: PUSH
38765: LD_INT 1
38767: NEG
38768: PUSH
38769: LD_INT 0
38771: PUSH
38772: EMPTY
38773: LIST
38774: LIST
38775: PUSH
38776: LD_INT 1
38778: NEG
38779: PUSH
38780: LD_INT 1
38782: NEG
38783: PUSH
38784: EMPTY
38785: LIST
38786: LIST
38787: PUSH
38788: LD_INT 1
38790: NEG
38791: PUSH
38792: LD_INT 2
38794: NEG
38795: PUSH
38796: EMPTY
38797: LIST
38798: LIST
38799: PUSH
38800: LD_INT 0
38802: PUSH
38803: LD_INT 2
38805: NEG
38806: PUSH
38807: EMPTY
38808: LIST
38809: LIST
38810: PUSH
38811: LD_INT 1
38813: PUSH
38814: LD_INT 1
38816: NEG
38817: PUSH
38818: EMPTY
38819: LIST
38820: LIST
38821: PUSH
38822: LD_INT 2
38824: PUSH
38825: LD_INT 1
38827: PUSH
38828: EMPTY
38829: LIST
38830: LIST
38831: PUSH
38832: LD_INT 2
38834: PUSH
38835: LD_INT 2
38837: PUSH
38838: EMPTY
38839: LIST
38840: LIST
38841: PUSH
38842: LD_INT 1
38844: PUSH
38845: LD_INT 2
38847: PUSH
38848: EMPTY
38849: LIST
38850: LIST
38851: PUSH
38852: LD_INT 0
38854: PUSH
38855: LD_INT 2
38857: PUSH
38858: EMPTY
38859: LIST
38860: LIST
38861: PUSH
38862: LD_INT 1
38864: NEG
38865: PUSH
38866: LD_INT 1
38868: PUSH
38869: EMPTY
38870: LIST
38871: LIST
38872: PUSH
38873: LD_INT 2
38875: NEG
38876: PUSH
38877: LD_INT 0
38879: PUSH
38880: EMPTY
38881: LIST
38882: LIST
38883: PUSH
38884: LD_INT 2
38886: NEG
38887: PUSH
38888: LD_INT 1
38890: NEG
38891: PUSH
38892: EMPTY
38893: LIST
38894: LIST
38895: PUSH
38896: LD_INT 1
38898: NEG
38899: PUSH
38900: LD_INT 3
38902: NEG
38903: PUSH
38904: EMPTY
38905: LIST
38906: LIST
38907: PUSH
38908: LD_INT 1
38910: PUSH
38911: LD_INT 2
38913: NEG
38914: PUSH
38915: EMPTY
38916: LIST
38917: LIST
38918: PUSH
38919: LD_INT 3
38921: PUSH
38922: LD_INT 2
38924: PUSH
38925: EMPTY
38926: LIST
38927: LIST
38928: PUSH
38929: LD_INT 2
38931: PUSH
38932: LD_INT 3
38934: PUSH
38935: EMPTY
38936: LIST
38937: LIST
38938: PUSH
38939: LD_INT 2
38941: NEG
38942: PUSH
38943: LD_INT 1
38945: PUSH
38946: EMPTY
38947: LIST
38948: LIST
38949: PUSH
38950: LD_INT 3
38952: NEG
38953: PUSH
38954: LD_INT 1
38956: NEG
38957: PUSH
38958: EMPTY
38959: LIST
38960: LIST
38961: PUSH
38962: EMPTY
38963: LIST
38964: LIST
38965: LIST
38966: LIST
38967: LIST
38968: LIST
38969: LIST
38970: LIST
38971: LIST
38972: LIST
38973: LIST
38974: LIST
38975: LIST
38976: LIST
38977: LIST
38978: LIST
38979: LIST
38980: LIST
38981: LIST
38982: LIST
38983: LIST
38984: LIST
38985: LIST
38986: ST_TO_ADDR
// fFactory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
38987: LD_ADDR_VAR 0 33
38991: PUSH
38992: LD_INT 0
38994: PUSH
38995: LD_INT 0
38997: PUSH
38998: EMPTY
38999: LIST
39000: LIST
39001: PUSH
39002: LD_INT 0
39004: PUSH
39005: LD_INT 1
39007: NEG
39008: PUSH
39009: EMPTY
39010: LIST
39011: LIST
39012: PUSH
39013: LD_INT 1
39015: PUSH
39016: LD_INT 0
39018: PUSH
39019: EMPTY
39020: LIST
39021: LIST
39022: PUSH
39023: LD_INT 1
39025: PUSH
39026: LD_INT 1
39028: PUSH
39029: EMPTY
39030: LIST
39031: LIST
39032: PUSH
39033: LD_INT 0
39035: PUSH
39036: LD_INT 1
39038: PUSH
39039: EMPTY
39040: LIST
39041: LIST
39042: PUSH
39043: LD_INT 1
39045: NEG
39046: PUSH
39047: LD_INT 0
39049: PUSH
39050: EMPTY
39051: LIST
39052: LIST
39053: PUSH
39054: LD_INT 1
39056: NEG
39057: PUSH
39058: LD_INT 1
39060: NEG
39061: PUSH
39062: EMPTY
39063: LIST
39064: LIST
39065: PUSH
39066: LD_INT 1
39068: NEG
39069: PUSH
39070: LD_INT 2
39072: NEG
39073: PUSH
39074: EMPTY
39075: LIST
39076: LIST
39077: PUSH
39078: LD_INT 1
39080: PUSH
39081: LD_INT 1
39083: NEG
39084: PUSH
39085: EMPTY
39086: LIST
39087: LIST
39088: PUSH
39089: LD_INT 2
39091: PUSH
39092: LD_INT 0
39094: PUSH
39095: EMPTY
39096: LIST
39097: LIST
39098: PUSH
39099: LD_INT 2
39101: PUSH
39102: LD_INT 1
39104: PUSH
39105: EMPTY
39106: LIST
39107: LIST
39108: PUSH
39109: LD_INT 1
39111: PUSH
39112: LD_INT 2
39114: PUSH
39115: EMPTY
39116: LIST
39117: LIST
39118: PUSH
39119: LD_INT 0
39121: PUSH
39122: LD_INT 2
39124: PUSH
39125: EMPTY
39126: LIST
39127: LIST
39128: PUSH
39129: LD_INT 1
39131: NEG
39132: PUSH
39133: LD_INT 1
39135: PUSH
39136: EMPTY
39137: LIST
39138: LIST
39139: PUSH
39140: LD_INT 2
39142: NEG
39143: PUSH
39144: LD_INT 0
39146: PUSH
39147: EMPTY
39148: LIST
39149: LIST
39150: PUSH
39151: LD_INT 2
39153: NEG
39154: PUSH
39155: LD_INT 1
39157: NEG
39158: PUSH
39159: EMPTY
39160: LIST
39161: LIST
39162: PUSH
39163: LD_INT 2
39165: NEG
39166: PUSH
39167: LD_INT 2
39169: NEG
39170: PUSH
39171: EMPTY
39172: LIST
39173: LIST
39174: PUSH
39175: LD_INT 2
39177: NEG
39178: PUSH
39179: LD_INT 3
39181: NEG
39182: PUSH
39183: EMPTY
39184: LIST
39185: LIST
39186: PUSH
39187: LD_INT 2
39189: PUSH
39190: LD_INT 1
39192: NEG
39193: PUSH
39194: EMPTY
39195: LIST
39196: LIST
39197: PUSH
39198: LD_INT 3
39200: PUSH
39201: LD_INT 1
39203: PUSH
39204: EMPTY
39205: LIST
39206: LIST
39207: PUSH
39208: LD_INT 1
39210: PUSH
39211: LD_INT 3
39213: PUSH
39214: EMPTY
39215: LIST
39216: LIST
39217: PUSH
39218: LD_INT 1
39220: NEG
39221: PUSH
39222: LD_INT 2
39224: PUSH
39225: EMPTY
39226: LIST
39227: LIST
39228: PUSH
39229: LD_INT 3
39231: NEG
39232: PUSH
39233: LD_INT 2
39235: NEG
39236: PUSH
39237: EMPTY
39238: LIST
39239: LIST
39240: PUSH
39241: EMPTY
39242: LIST
39243: LIST
39244: LIST
39245: LIST
39246: LIST
39247: LIST
39248: LIST
39249: LIST
39250: LIST
39251: LIST
39252: LIST
39253: LIST
39254: LIST
39255: LIST
39256: LIST
39257: LIST
39258: LIST
39259: LIST
39260: LIST
39261: LIST
39262: LIST
39263: LIST
39264: LIST
39265: ST_TO_ADDR
// fFactory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
39266: LD_ADDR_VAR 0 34
39270: PUSH
39271: LD_INT 0
39273: PUSH
39274: LD_INT 0
39276: PUSH
39277: EMPTY
39278: LIST
39279: LIST
39280: PUSH
39281: LD_INT 0
39283: PUSH
39284: LD_INT 1
39286: NEG
39287: PUSH
39288: EMPTY
39289: LIST
39290: LIST
39291: PUSH
39292: LD_INT 1
39294: PUSH
39295: LD_INT 0
39297: PUSH
39298: EMPTY
39299: LIST
39300: LIST
39301: PUSH
39302: LD_INT 1
39304: PUSH
39305: LD_INT 1
39307: PUSH
39308: EMPTY
39309: LIST
39310: LIST
39311: PUSH
39312: LD_INT 0
39314: PUSH
39315: LD_INT 1
39317: PUSH
39318: EMPTY
39319: LIST
39320: LIST
39321: PUSH
39322: LD_INT 1
39324: NEG
39325: PUSH
39326: LD_INT 0
39328: PUSH
39329: EMPTY
39330: LIST
39331: LIST
39332: PUSH
39333: LD_INT 1
39335: NEG
39336: PUSH
39337: LD_INT 1
39339: NEG
39340: PUSH
39341: EMPTY
39342: LIST
39343: LIST
39344: PUSH
39345: LD_INT 1
39347: NEG
39348: PUSH
39349: LD_INT 2
39351: NEG
39352: PUSH
39353: EMPTY
39354: LIST
39355: LIST
39356: PUSH
39357: LD_INT 0
39359: PUSH
39360: LD_INT 2
39362: NEG
39363: PUSH
39364: EMPTY
39365: LIST
39366: LIST
39367: PUSH
39368: LD_INT 1
39370: PUSH
39371: LD_INT 1
39373: NEG
39374: PUSH
39375: EMPTY
39376: LIST
39377: LIST
39378: PUSH
39379: LD_INT 2
39381: PUSH
39382: LD_INT 1
39384: PUSH
39385: EMPTY
39386: LIST
39387: LIST
39388: PUSH
39389: LD_INT 2
39391: PUSH
39392: LD_INT 2
39394: PUSH
39395: EMPTY
39396: LIST
39397: LIST
39398: PUSH
39399: LD_INT 1
39401: PUSH
39402: LD_INT 2
39404: PUSH
39405: EMPTY
39406: LIST
39407: LIST
39408: PUSH
39409: LD_INT 1
39411: NEG
39412: PUSH
39413: LD_INT 1
39415: PUSH
39416: EMPTY
39417: LIST
39418: LIST
39419: PUSH
39420: LD_INT 2
39422: NEG
39423: PUSH
39424: LD_INT 0
39426: PUSH
39427: EMPTY
39428: LIST
39429: LIST
39430: PUSH
39431: LD_INT 2
39433: NEG
39434: PUSH
39435: LD_INT 1
39437: NEG
39438: PUSH
39439: EMPTY
39440: LIST
39441: LIST
39442: PUSH
39443: LD_INT 2
39445: NEG
39446: PUSH
39447: LD_INT 2
39449: NEG
39450: PUSH
39451: EMPTY
39452: LIST
39453: LIST
39454: PUSH
39455: LD_INT 1
39457: NEG
39458: PUSH
39459: LD_INT 3
39461: NEG
39462: PUSH
39463: EMPTY
39464: LIST
39465: LIST
39466: PUSH
39467: LD_INT 1
39469: PUSH
39470: LD_INT 2
39472: NEG
39473: PUSH
39474: EMPTY
39475: LIST
39476: LIST
39477: PUSH
39478: LD_INT 3
39480: PUSH
39481: LD_INT 2
39483: PUSH
39484: EMPTY
39485: LIST
39486: LIST
39487: PUSH
39488: LD_INT 2
39490: PUSH
39491: LD_INT 3
39493: PUSH
39494: EMPTY
39495: LIST
39496: LIST
39497: PUSH
39498: LD_INT 2
39500: NEG
39501: PUSH
39502: LD_INT 1
39504: PUSH
39505: EMPTY
39506: LIST
39507: LIST
39508: PUSH
39509: LD_INT 3
39511: NEG
39512: PUSH
39513: LD_INT 1
39515: NEG
39516: PUSH
39517: EMPTY
39518: LIST
39519: LIST
39520: PUSH
39521: EMPTY
39522: LIST
39523: LIST
39524: LIST
39525: LIST
39526: LIST
39527: LIST
39528: LIST
39529: LIST
39530: LIST
39531: LIST
39532: LIST
39533: LIST
39534: LIST
39535: LIST
39536: LIST
39537: LIST
39538: LIST
39539: LIST
39540: LIST
39541: LIST
39542: LIST
39543: LIST
39544: LIST
39545: ST_TO_ADDR
// fExt0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
39546: LD_ADDR_VAR 0 35
39550: PUSH
39551: LD_INT 0
39553: PUSH
39554: LD_INT 0
39556: PUSH
39557: EMPTY
39558: LIST
39559: LIST
39560: PUSH
39561: LD_INT 0
39563: PUSH
39564: LD_INT 1
39566: NEG
39567: PUSH
39568: EMPTY
39569: LIST
39570: LIST
39571: PUSH
39572: LD_INT 1
39574: PUSH
39575: LD_INT 0
39577: PUSH
39578: EMPTY
39579: LIST
39580: LIST
39581: PUSH
39582: LD_INT 1
39584: PUSH
39585: LD_INT 1
39587: PUSH
39588: EMPTY
39589: LIST
39590: LIST
39591: PUSH
39592: LD_INT 0
39594: PUSH
39595: LD_INT 1
39597: PUSH
39598: EMPTY
39599: LIST
39600: LIST
39601: PUSH
39602: LD_INT 1
39604: NEG
39605: PUSH
39606: LD_INT 0
39608: PUSH
39609: EMPTY
39610: LIST
39611: LIST
39612: PUSH
39613: LD_INT 1
39615: NEG
39616: PUSH
39617: LD_INT 1
39619: NEG
39620: PUSH
39621: EMPTY
39622: LIST
39623: LIST
39624: PUSH
39625: LD_INT 2
39627: PUSH
39628: LD_INT 1
39630: PUSH
39631: EMPTY
39632: LIST
39633: LIST
39634: PUSH
39635: LD_INT 2
39637: NEG
39638: PUSH
39639: LD_INT 1
39641: NEG
39642: PUSH
39643: EMPTY
39644: LIST
39645: LIST
39646: PUSH
39647: EMPTY
39648: LIST
39649: LIST
39650: LIST
39651: LIST
39652: LIST
39653: LIST
39654: LIST
39655: LIST
39656: LIST
39657: ST_TO_ADDR
// fExt1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
39658: LD_ADDR_VAR 0 36
39662: PUSH
39663: LD_INT 0
39665: PUSH
39666: LD_INT 0
39668: PUSH
39669: EMPTY
39670: LIST
39671: LIST
39672: PUSH
39673: LD_INT 0
39675: PUSH
39676: LD_INT 1
39678: NEG
39679: PUSH
39680: EMPTY
39681: LIST
39682: LIST
39683: PUSH
39684: LD_INT 1
39686: PUSH
39687: LD_INT 0
39689: PUSH
39690: EMPTY
39691: LIST
39692: LIST
39693: PUSH
39694: LD_INT 1
39696: PUSH
39697: LD_INT 1
39699: PUSH
39700: EMPTY
39701: LIST
39702: LIST
39703: PUSH
39704: LD_INT 0
39706: PUSH
39707: LD_INT 1
39709: PUSH
39710: EMPTY
39711: LIST
39712: LIST
39713: PUSH
39714: LD_INT 1
39716: NEG
39717: PUSH
39718: LD_INT 0
39720: PUSH
39721: EMPTY
39722: LIST
39723: LIST
39724: PUSH
39725: LD_INT 1
39727: NEG
39728: PUSH
39729: LD_INT 1
39731: NEG
39732: PUSH
39733: EMPTY
39734: LIST
39735: LIST
39736: PUSH
39737: LD_INT 1
39739: NEG
39740: PUSH
39741: LD_INT 2
39743: NEG
39744: PUSH
39745: EMPTY
39746: LIST
39747: LIST
39748: PUSH
39749: LD_INT 1
39751: PUSH
39752: LD_INT 2
39754: PUSH
39755: EMPTY
39756: LIST
39757: LIST
39758: PUSH
39759: EMPTY
39760: LIST
39761: LIST
39762: LIST
39763: LIST
39764: LIST
39765: LIST
39766: LIST
39767: LIST
39768: LIST
39769: ST_TO_ADDR
// fExt2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
39770: LD_ADDR_VAR 0 37
39774: PUSH
39775: LD_INT 0
39777: PUSH
39778: LD_INT 0
39780: PUSH
39781: EMPTY
39782: LIST
39783: LIST
39784: PUSH
39785: LD_INT 0
39787: PUSH
39788: LD_INT 1
39790: NEG
39791: PUSH
39792: EMPTY
39793: LIST
39794: LIST
39795: PUSH
39796: LD_INT 1
39798: PUSH
39799: LD_INT 0
39801: PUSH
39802: EMPTY
39803: LIST
39804: LIST
39805: PUSH
39806: LD_INT 1
39808: PUSH
39809: LD_INT 1
39811: PUSH
39812: EMPTY
39813: LIST
39814: LIST
39815: PUSH
39816: LD_INT 0
39818: PUSH
39819: LD_INT 1
39821: PUSH
39822: EMPTY
39823: LIST
39824: LIST
39825: PUSH
39826: LD_INT 1
39828: NEG
39829: PUSH
39830: LD_INT 0
39832: PUSH
39833: EMPTY
39834: LIST
39835: LIST
39836: PUSH
39837: LD_INT 1
39839: NEG
39840: PUSH
39841: LD_INT 1
39843: NEG
39844: PUSH
39845: EMPTY
39846: LIST
39847: LIST
39848: PUSH
39849: LD_INT 1
39851: PUSH
39852: LD_INT 1
39854: NEG
39855: PUSH
39856: EMPTY
39857: LIST
39858: LIST
39859: PUSH
39860: LD_INT 1
39862: NEG
39863: PUSH
39864: LD_INT 1
39866: PUSH
39867: EMPTY
39868: LIST
39869: LIST
39870: PUSH
39871: EMPTY
39872: LIST
39873: LIST
39874: LIST
39875: LIST
39876: LIST
39877: LIST
39878: LIST
39879: LIST
39880: LIST
39881: ST_TO_ADDR
// fExt3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
39882: LD_ADDR_VAR 0 38
39886: PUSH
39887: LD_INT 0
39889: PUSH
39890: LD_INT 0
39892: PUSH
39893: EMPTY
39894: LIST
39895: LIST
39896: PUSH
39897: LD_INT 0
39899: PUSH
39900: LD_INT 1
39902: NEG
39903: PUSH
39904: EMPTY
39905: LIST
39906: LIST
39907: PUSH
39908: LD_INT 1
39910: PUSH
39911: LD_INT 0
39913: PUSH
39914: EMPTY
39915: LIST
39916: LIST
39917: PUSH
39918: LD_INT 1
39920: PUSH
39921: LD_INT 1
39923: PUSH
39924: EMPTY
39925: LIST
39926: LIST
39927: PUSH
39928: LD_INT 0
39930: PUSH
39931: LD_INT 1
39933: PUSH
39934: EMPTY
39935: LIST
39936: LIST
39937: PUSH
39938: LD_INT 1
39940: NEG
39941: PUSH
39942: LD_INT 0
39944: PUSH
39945: EMPTY
39946: LIST
39947: LIST
39948: PUSH
39949: LD_INT 1
39951: NEG
39952: PUSH
39953: LD_INT 1
39955: NEG
39956: PUSH
39957: EMPTY
39958: LIST
39959: LIST
39960: PUSH
39961: LD_INT 2
39963: PUSH
39964: LD_INT 1
39966: PUSH
39967: EMPTY
39968: LIST
39969: LIST
39970: PUSH
39971: LD_INT 2
39973: NEG
39974: PUSH
39975: LD_INT 1
39977: NEG
39978: PUSH
39979: EMPTY
39980: LIST
39981: LIST
39982: PUSH
39983: EMPTY
39984: LIST
39985: LIST
39986: LIST
39987: LIST
39988: LIST
39989: LIST
39990: LIST
39991: LIST
39992: LIST
39993: ST_TO_ADDR
// fExt4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
39994: LD_ADDR_VAR 0 39
39998: PUSH
39999: LD_INT 0
40001: PUSH
40002: LD_INT 0
40004: PUSH
40005: EMPTY
40006: LIST
40007: LIST
40008: PUSH
40009: LD_INT 0
40011: PUSH
40012: LD_INT 1
40014: NEG
40015: PUSH
40016: EMPTY
40017: LIST
40018: LIST
40019: PUSH
40020: LD_INT 1
40022: PUSH
40023: LD_INT 0
40025: PUSH
40026: EMPTY
40027: LIST
40028: LIST
40029: PUSH
40030: LD_INT 1
40032: PUSH
40033: LD_INT 1
40035: PUSH
40036: EMPTY
40037: LIST
40038: LIST
40039: PUSH
40040: LD_INT 0
40042: PUSH
40043: LD_INT 1
40045: PUSH
40046: EMPTY
40047: LIST
40048: LIST
40049: PUSH
40050: LD_INT 1
40052: NEG
40053: PUSH
40054: LD_INT 0
40056: PUSH
40057: EMPTY
40058: LIST
40059: LIST
40060: PUSH
40061: LD_INT 1
40063: NEG
40064: PUSH
40065: LD_INT 1
40067: NEG
40068: PUSH
40069: EMPTY
40070: LIST
40071: LIST
40072: PUSH
40073: LD_INT 1
40075: NEG
40076: PUSH
40077: LD_INT 2
40079: NEG
40080: PUSH
40081: EMPTY
40082: LIST
40083: LIST
40084: PUSH
40085: LD_INT 1
40087: PUSH
40088: LD_INT 2
40090: PUSH
40091: EMPTY
40092: LIST
40093: LIST
40094: PUSH
40095: EMPTY
40096: LIST
40097: LIST
40098: LIST
40099: LIST
40100: LIST
40101: LIST
40102: LIST
40103: LIST
40104: LIST
40105: ST_TO_ADDR
// fExt5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
40106: LD_ADDR_VAR 0 40
40110: PUSH
40111: LD_INT 0
40113: PUSH
40114: LD_INT 0
40116: PUSH
40117: EMPTY
40118: LIST
40119: LIST
40120: PUSH
40121: LD_INT 0
40123: PUSH
40124: LD_INT 1
40126: NEG
40127: PUSH
40128: EMPTY
40129: LIST
40130: LIST
40131: PUSH
40132: LD_INT 1
40134: PUSH
40135: LD_INT 0
40137: PUSH
40138: EMPTY
40139: LIST
40140: LIST
40141: PUSH
40142: LD_INT 1
40144: PUSH
40145: LD_INT 1
40147: PUSH
40148: EMPTY
40149: LIST
40150: LIST
40151: PUSH
40152: LD_INT 0
40154: PUSH
40155: LD_INT 1
40157: PUSH
40158: EMPTY
40159: LIST
40160: LIST
40161: PUSH
40162: LD_INT 1
40164: NEG
40165: PUSH
40166: LD_INT 0
40168: PUSH
40169: EMPTY
40170: LIST
40171: LIST
40172: PUSH
40173: LD_INT 1
40175: NEG
40176: PUSH
40177: LD_INT 1
40179: NEG
40180: PUSH
40181: EMPTY
40182: LIST
40183: LIST
40184: PUSH
40185: LD_INT 1
40187: PUSH
40188: LD_INT 1
40190: NEG
40191: PUSH
40192: EMPTY
40193: LIST
40194: LIST
40195: PUSH
40196: LD_INT 1
40198: NEG
40199: PUSH
40200: LD_INT 1
40202: PUSH
40203: EMPTY
40204: LIST
40205: LIST
40206: PUSH
40207: EMPTY
40208: LIST
40209: LIST
40210: LIST
40211: LIST
40212: LIST
40213: LIST
40214: LIST
40215: LIST
40216: LIST
40217: ST_TO_ADDR
// fLab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
40218: LD_ADDR_VAR 0 41
40222: PUSH
40223: LD_INT 0
40225: PUSH
40226: LD_INT 0
40228: PUSH
40229: EMPTY
40230: LIST
40231: LIST
40232: PUSH
40233: LD_INT 0
40235: PUSH
40236: LD_INT 1
40238: NEG
40239: PUSH
40240: EMPTY
40241: LIST
40242: LIST
40243: PUSH
40244: LD_INT 1
40246: PUSH
40247: LD_INT 0
40249: PUSH
40250: EMPTY
40251: LIST
40252: LIST
40253: PUSH
40254: LD_INT 1
40256: PUSH
40257: LD_INT 1
40259: PUSH
40260: EMPTY
40261: LIST
40262: LIST
40263: PUSH
40264: LD_INT 0
40266: PUSH
40267: LD_INT 1
40269: PUSH
40270: EMPTY
40271: LIST
40272: LIST
40273: PUSH
40274: LD_INT 1
40276: NEG
40277: PUSH
40278: LD_INT 0
40280: PUSH
40281: EMPTY
40282: LIST
40283: LIST
40284: PUSH
40285: LD_INT 1
40287: NEG
40288: PUSH
40289: LD_INT 1
40291: NEG
40292: PUSH
40293: EMPTY
40294: LIST
40295: LIST
40296: PUSH
40297: LD_INT 1
40299: NEG
40300: PUSH
40301: LD_INT 2
40303: NEG
40304: PUSH
40305: EMPTY
40306: LIST
40307: LIST
40308: PUSH
40309: LD_INT 1
40311: PUSH
40312: LD_INT 1
40314: NEG
40315: PUSH
40316: EMPTY
40317: LIST
40318: LIST
40319: PUSH
40320: LD_INT 2
40322: PUSH
40323: LD_INT 0
40325: PUSH
40326: EMPTY
40327: LIST
40328: LIST
40329: PUSH
40330: LD_INT 2
40332: PUSH
40333: LD_INT 1
40335: PUSH
40336: EMPTY
40337: LIST
40338: LIST
40339: PUSH
40340: LD_INT 2
40342: PUSH
40343: LD_INT 2
40345: PUSH
40346: EMPTY
40347: LIST
40348: LIST
40349: PUSH
40350: LD_INT 1
40352: PUSH
40353: LD_INT 2
40355: PUSH
40356: EMPTY
40357: LIST
40358: LIST
40359: PUSH
40360: LD_INT 1
40362: NEG
40363: PUSH
40364: LD_INT 1
40366: PUSH
40367: EMPTY
40368: LIST
40369: LIST
40370: PUSH
40371: LD_INT 2
40373: NEG
40374: PUSH
40375: LD_INT 0
40377: PUSH
40378: EMPTY
40379: LIST
40380: LIST
40381: PUSH
40382: LD_INT 2
40384: NEG
40385: PUSH
40386: LD_INT 1
40388: NEG
40389: PUSH
40390: EMPTY
40391: LIST
40392: LIST
40393: PUSH
40394: LD_INT 2
40396: NEG
40397: PUSH
40398: LD_INT 2
40400: NEG
40401: PUSH
40402: EMPTY
40403: LIST
40404: LIST
40405: PUSH
40406: LD_INT 2
40408: NEG
40409: PUSH
40410: LD_INT 3
40412: NEG
40413: PUSH
40414: EMPTY
40415: LIST
40416: LIST
40417: PUSH
40418: LD_INT 2
40420: PUSH
40421: LD_INT 1
40423: NEG
40424: PUSH
40425: EMPTY
40426: LIST
40427: LIST
40428: PUSH
40429: LD_INT 3
40431: PUSH
40432: LD_INT 0
40434: PUSH
40435: EMPTY
40436: LIST
40437: LIST
40438: PUSH
40439: LD_INT 3
40441: PUSH
40442: LD_INT 1
40444: PUSH
40445: EMPTY
40446: LIST
40447: LIST
40448: PUSH
40449: LD_INT 3
40451: PUSH
40452: LD_INT 2
40454: PUSH
40455: EMPTY
40456: LIST
40457: LIST
40458: PUSH
40459: LD_INT 3
40461: PUSH
40462: LD_INT 3
40464: PUSH
40465: EMPTY
40466: LIST
40467: LIST
40468: PUSH
40469: LD_INT 2
40471: PUSH
40472: LD_INT 3
40474: PUSH
40475: EMPTY
40476: LIST
40477: LIST
40478: PUSH
40479: LD_INT 2
40481: NEG
40482: PUSH
40483: LD_INT 1
40485: PUSH
40486: EMPTY
40487: LIST
40488: LIST
40489: PUSH
40490: LD_INT 3
40492: NEG
40493: PUSH
40494: LD_INT 0
40496: PUSH
40497: EMPTY
40498: LIST
40499: LIST
40500: PUSH
40501: LD_INT 3
40503: NEG
40504: PUSH
40505: LD_INT 1
40507: NEG
40508: PUSH
40509: EMPTY
40510: LIST
40511: LIST
40512: PUSH
40513: LD_INT 3
40515: NEG
40516: PUSH
40517: LD_INT 2
40519: NEG
40520: PUSH
40521: EMPTY
40522: LIST
40523: LIST
40524: PUSH
40525: LD_INT 3
40527: NEG
40528: PUSH
40529: LD_INT 3
40531: NEG
40532: PUSH
40533: EMPTY
40534: LIST
40535: LIST
40536: PUSH
40537: EMPTY
40538: LIST
40539: LIST
40540: LIST
40541: LIST
40542: LIST
40543: LIST
40544: LIST
40545: LIST
40546: LIST
40547: LIST
40548: LIST
40549: LIST
40550: LIST
40551: LIST
40552: LIST
40553: LIST
40554: LIST
40555: LIST
40556: LIST
40557: LIST
40558: LIST
40559: LIST
40560: LIST
40561: LIST
40562: LIST
40563: LIST
40564: LIST
40565: LIST
40566: LIST
40567: ST_TO_ADDR
// fLab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
40568: LD_ADDR_VAR 0 42
40572: PUSH
40573: LD_INT 0
40575: PUSH
40576: LD_INT 0
40578: PUSH
40579: EMPTY
40580: LIST
40581: LIST
40582: PUSH
40583: LD_INT 0
40585: PUSH
40586: LD_INT 1
40588: NEG
40589: PUSH
40590: EMPTY
40591: LIST
40592: LIST
40593: PUSH
40594: LD_INT 1
40596: PUSH
40597: LD_INT 0
40599: PUSH
40600: EMPTY
40601: LIST
40602: LIST
40603: PUSH
40604: LD_INT 1
40606: PUSH
40607: LD_INT 1
40609: PUSH
40610: EMPTY
40611: LIST
40612: LIST
40613: PUSH
40614: LD_INT 0
40616: PUSH
40617: LD_INT 1
40619: PUSH
40620: EMPTY
40621: LIST
40622: LIST
40623: PUSH
40624: LD_INT 1
40626: NEG
40627: PUSH
40628: LD_INT 0
40630: PUSH
40631: EMPTY
40632: LIST
40633: LIST
40634: PUSH
40635: LD_INT 1
40637: NEG
40638: PUSH
40639: LD_INT 1
40641: NEG
40642: PUSH
40643: EMPTY
40644: LIST
40645: LIST
40646: PUSH
40647: LD_INT 1
40649: NEG
40650: PUSH
40651: LD_INT 2
40653: NEG
40654: PUSH
40655: EMPTY
40656: LIST
40657: LIST
40658: PUSH
40659: LD_INT 0
40661: PUSH
40662: LD_INT 2
40664: NEG
40665: PUSH
40666: EMPTY
40667: LIST
40668: LIST
40669: PUSH
40670: LD_INT 1
40672: PUSH
40673: LD_INT 1
40675: NEG
40676: PUSH
40677: EMPTY
40678: LIST
40679: LIST
40680: PUSH
40681: LD_INT 2
40683: PUSH
40684: LD_INT 1
40686: PUSH
40687: EMPTY
40688: LIST
40689: LIST
40690: PUSH
40691: LD_INT 2
40693: PUSH
40694: LD_INT 2
40696: PUSH
40697: EMPTY
40698: LIST
40699: LIST
40700: PUSH
40701: LD_INT 1
40703: PUSH
40704: LD_INT 2
40706: PUSH
40707: EMPTY
40708: LIST
40709: LIST
40710: PUSH
40711: LD_INT 0
40713: PUSH
40714: LD_INT 2
40716: PUSH
40717: EMPTY
40718: LIST
40719: LIST
40720: PUSH
40721: LD_INT 1
40723: NEG
40724: PUSH
40725: LD_INT 1
40727: PUSH
40728: EMPTY
40729: LIST
40730: LIST
40731: PUSH
40732: LD_INT 2
40734: NEG
40735: PUSH
40736: LD_INT 1
40738: NEG
40739: PUSH
40740: EMPTY
40741: LIST
40742: LIST
40743: PUSH
40744: LD_INT 2
40746: NEG
40747: PUSH
40748: LD_INT 2
40750: NEG
40751: PUSH
40752: EMPTY
40753: LIST
40754: LIST
40755: PUSH
40756: LD_INT 2
40758: NEG
40759: PUSH
40760: LD_INT 3
40762: NEG
40763: PUSH
40764: EMPTY
40765: LIST
40766: LIST
40767: PUSH
40768: LD_INT 1
40770: NEG
40771: PUSH
40772: LD_INT 3
40774: NEG
40775: PUSH
40776: EMPTY
40777: LIST
40778: LIST
40779: PUSH
40780: LD_INT 0
40782: PUSH
40783: LD_INT 3
40785: NEG
40786: PUSH
40787: EMPTY
40788: LIST
40789: LIST
40790: PUSH
40791: LD_INT 1
40793: PUSH
40794: LD_INT 2
40796: NEG
40797: PUSH
40798: EMPTY
40799: LIST
40800: LIST
40801: PUSH
40802: LD_INT 3
40804: PUSH
40805: LD_INT 2
40807: PUSH
40808: EMPTY
40809: LIST
40810: LIST
40811: PUSH
40812: LD_INT 3
40814: PUSH
40815: LD_INT 3
40817: PUSH
40818: EMPTY
40819: LIST
40820: LIST
40821: PUSH
40822: LD_INT 2
40824: PUSH
40825: LD_INT 3
40827: PUSH
40828: EMPTY
40829: LIST
40830: LIST
40831: PUSH
40832: LD_INT 1
40834: PUSH
40835: LD_INT 3
40837: PUSH
40838: EMPTY
40839: LIST
40840: LIST
40841: PUSH
40842: LD_INT 0
40844: PUSH
40845: LD_INT 3
40847: PUSH
40848: EMPTY
40849: LIST
40850: LIST
40851: PUSH
40852: LD_INT 1
40854: NEG
40855: PUSH
40856: LD_INT 2
40858: PUSH
40859: EMPTY
40860: LIST
40861: LIST
40862: PUSH
40863: LD_INT 3
40865: NEG
40866: PUSH
40867: LD_INT 2
40869: NEG
40870: PUSH
40871: EMPTY
40872: LIST
40873: LIST
40874: PUSH
40875: LD_INT 3
40877: NEG
40878: PUSH
40879: LD_INT 3
40881: NEG
40882: PUSH
40883: EMPTY
40884: LIST
40885: LIST
40886: PUSH
40887: EMPTY
40888: LIST
40889: LIST
40890: LIST
40891: LIST
40892: LIST
40893: LIST
40894: LIST
40895: LIST
40896: LIST
40897: LIST
40898: LIST
40899: LIST
40900: LIST
40901: LIST
40902: LIST
40903: LIST
40904: LIST
40905: LIST
40906: LIST
40907: LIST
40908: LIST
40909: LIST
40910: LIST
40911: LIST
40912: LIST
40913: LIST
40914: LIST
40915: LIST
40916: LIST
40917: ST_TO_ADDR
// fLab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
40918: LD_ADDR_VAR 0 43
40922: PUSH
40923: LD_INT 0
40925: PUSH
40926: LD_INT 0
40928: PUSH
40929: EMPTY
40930: LIST
40931: LIST
40932: PUSH
40933: LD_INT 0
40935: PUSH
40936: LD_INT 1
40938: NEG
40939: PUSH
40940: EMPTY
40941: LIST
40942: LIST
40943: PUSH
40944: LD_INT 1
40946: PUSH
40947: LD_INT 0
40949: PUSH
40950: EMPTY
40951: LIST
40952: LIST
40953: PUSH
40954: LD_INT 1
40956: PUSH
40957: LD_INT 1
40959: PUSH
40960: EMPTY
40961: LIST
40962: LIST
40963: PUSH
40964: LD_INT 0
40966: PUSH
40967: LD_INT 1
40969: PUSH
40970: EMPTY
40971: LIST
40972: LIST
40973: PUSH
40974: LD_INT 1
40976: NEG
40977: PUSH
40978: LD_INT 0
40980: PUSH
40981: EMPTY
40982: LIST
40983: LIST
40984: PUSH
40985: LD_INT 1
40987: NEG
40988: PUSH
40989: LD_INT 1
40991: NEG
40992: PUSH
40993: EMPTY
40994: LIST
40995: LIST
40996: PUSH
40997: LD_INT 1
40999: NEG
41000: PUSH
41001: LD_INT 2
41003: NEG
41004: PUSH
41005: EMPTY
41006: LIST
41007: LIST
41008: PUSH
41009: LD_INT 0
41011: PUSH
41012: LD_INT 2
41014: NEG
41015: PUSH
41016: EMPTY
41017: LIST
41018: LIST
41019: PUSH
41020: LD_INT 1
41022: PUSH
41023: LD_INT 1
41025: NEG
41026: PUSH
41027: EMPTY
41028: LIST
41029: LIST
41030: PUSH
41031: LD_INT 2
41033: PUSH
41034: LD_INT 0
41036: PUSH
41037: EMPTY
41038: LIST
41039: LIST
41040: PUSH
41041: LD_INT 2
41043: PUSH
41044: LD_INT 1
41046: PUSH
41047: EMPTY
41048: LIST
41049: LIST
41050: PUSH
41051: LD_INT 1
41053: PUSH
41054: LD_INT 2
41056: PUSH
41057: EMPTY
41058: LIST
41059: LIST
41060: PUSH
41061: LD_INT 0
41063: PUSH
41064: LD_INT 2
41066: PUSH
41067: EMPTY
41068: LIST
41069: LIST
41070: PUSH
41071: LD_INT 1
41073: NEG
41074: PUSH
41075: LD_INT 1
41077: PUSH
41078: EMPTY
41079: LIST
41080: LIST
41081: PUSH
41082: LD_INT 2
41084: NEG
41085: PUSH
41086: LD_INT 0
41088: PUSH
41089: EMPTY
41090: LIST
41091: LIST
41092: PUSH
41093: LD_INT 2
41095: NEG
41096: PUSH
41097: LD_INT 1
41099: NEG
41100: PUSH
41101: EMPTY
41102: LIST
41103: LIST
41104: PUSH
41105: LD_INT 1
41107: NEG
41108: PUSH
41109: LD_INT 3
41111: NEG
41112: PUSH
41113: EMPTY
41114: LIST
41115: LIST
41116: PUSH
41117: LD_INT 0
41119: PUSH
41120: LD_INT 3
41122: NEG
41123: PUSH
41124: EMPTY
41125: LIST
41126: LIST
41127: PUSH
41128: LD_INT 1
41130: PUSH
41131: LD_INT 2
41133: NEG
41134: PUSH
41135: EMPTY
41136: LIST
41137: LIST
41138: PUSH
41139: LD_INT 2
41141: PUSH
41142: LD_INT 1
41144: NEG
41145: PUSH
41146: EMPTY
41147: LIST
41148: LIST
41149: PUSH
41150: LD_INT 3
41152: PUSH
41153: LD_INT 0
41155: PUSH
41156: EMPTY
41157: LIST
41158: LIST
41159: PUSH
41160: LD_INT 3
41162: PUSH
41163: LD_INT 1
41165: PUSH
41166: EMPTY
41167: LIST
41168: LIST
41169: PUSH
41170: LD_INT 1
41172: PUSH
41173: LD_INT 3
41175: PUSH
41176: EMPTY
41177: LIST
41178: LIST
41179: PUSH
41180: LD_INT 0
41182: PUSH
41183: LD_INT 3
41185: PUSH
41186: EMPTY
41187: LIST
41188: LIST
41189: PUSH
41190: LD_INT 1
41192: NEG
41193: PUSH
41194: LD_INT 2
41196: PUSH
41197: EMPTY
41198: LIST
41199: LIST
41200: PUSH
41201: LD_INT 2
41203: NEG
41204: PUSH
41205: LD_INT 1
41207: PUSH
41208: EMPTY
41209: LIST
41210: LIST
41211: PUSH
41212: LD_INT 3
41214: NEG
41215: PUSH
41216: LD_INT 0
41218: PUSH
41219: EMPTY
41220: LIST
41221: LIST
41222: PUSH
41223: LD_INT 3
41225: NEG
41226: PUSH
41227: LD_INT 1
41229: NEG
41230: PUSH
41231: EMPTY
41232: LIST
41233: LIST
41234: PUSH
41235: EMPTY
41236: LIST
41237: LIST
41238: LIST
41239: LIST
41240: LIST
41241: LIST
41242: LIST
41243: LIST
41244: LIST
41245: LIST
41246: LIST
41247: LIST
41248: LIST
41249: LIST
41250: LIST
41251: LIST
41252: LIST
41253: LIST
41254: LIST
41255: LIST
41256: LIST
41257: LIST
41258: LIST
41259: LIST
41260: LIST
41261: LIST
41262: LIST
41263: LIST
41264: LIST
41265: ST_TO_ADDR
// fLab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
41266: LD_ADDR_VAR 0 44
41270: PUSH
41271: LD_INT 0
41273: PUSH
41274: LD_INT 0
41276: PUSH
41277: EMPTY
41278: LIST
41279: LIST
41280: PUSH
41281: LD_INT 0
41283: PUSH
41284: LD_INT 1
41286: NEG
41287: PUSH
41288: EMPTY
41289: LIST
41290: LIST
41291: PUSH
41292: LD_INT 1
41294: PUSH
41295: LD_INT 0
41297: PUSH
41298: EMPTY
41299: LIST
41300: LIST
41301: PUSH
41302: LD_INT 1
41304: PUSH
41305: LD_INT 1
41307: PUSH
41308: EMPTY
41309: LIST
41310: LIST
41311: PUSH
41312: LD_INT 0
41314: PUSH
41315: LD_INT 1
41317: PUSH
41318: EMPTY
41319: LIST
41320: LIST
41321: PUSH
41322: LD_INT 1
41324: NEG
41325: PUSH
41326: LD_INT 0
41328: PUSH
41329: EMPTY
41330: LIST
41331: LIST
41332: PUSH
41333: LD_INT 1
41335: NEG
41336: PUSH
41337: LD_INT 1
41339: NEG
41340: PUSH
41341: EMPTY
41342: LIST
41343: LIST
41344: PUSH
41345: LD_INT 1
41347: NEG
41348: PUSH
41349: LD_INT 2
41351: NEG
41352: PUSH
41353: EMPTY
41354: LIST
41355: LIST
41356: PUSH
41357: LD_INT 1
41359: PUSH
41360: LD_INT 1
41362: NEG
41363: PUSH
41364: EMPTY
41365: LIST
41366: LIST
41367: PUSH
41368: LD_INT 2
41370: PUSH
41371: LD_INT 0
41373: PUSH
41374: EMPTY
41375: LIST
41376: LIST
41377: PUSH
41378: LD_INT 2
41380: PUSH
41381: LD_INT 1
41383: PUSH
41384: EMPTY
41385: LIST
41386: LIST
41387: PUSH
41388: LD_INT 2
41390: PUSH
41391: LD_INT 2
41393: PUSH
41394: EMPTY
41395: LIST
41396: LIST
41397: PUSH
41398: LD_INT 1
41400: PUSH
41401: LD_INT 2
41403: PUSH
41404: EMPTY
41405: LIST
41406: LIST
41407: PUSH
41408: LD_INT 1
41410: NEG
41411: PUSH
41412: LD_INT 1
41414: PUSH
41415: EMPTY
41416: LIST
41417: LIST
41418: PUSH
41419: LD_INT 2
41421: NEG
41422: PUSH
41423: LD_INT 0
41425: PUSH
41426: EMPTY
41427: LIST
41428: LIST
41429: PUSH
41430: LD_INT 2
41432: NEG
41433: PUSH
41434: LD_INT 1
41436: NEG
41437: PUSH
41438: EMPTY
41439: LIST
41440: LIST
41441: PUSH
41442: LD_INT 2
41444: NEG
41445: PUSH
41446: LD_INT 2
41448: NEG
41449: PUSH
41450: EMPTY
41451: LIST
41452: LIST
41453: PUSH
41454: LD_INT 2
41456: NEG
41457: PUSH
41458: LD_INT 3
41460: NEG
41461: PUSH
41462: EMPTY
41463: LIST
41464: LIST
41465: PUSH
41466: LD_INT 2
41468: PUSH
41469: LD_INT 1
41471: NEG
41472: PUSH
41473: EMPTY
41474: LIST
41475: LIST
41476: PUSH
41477: LD_INT 3
41479: PUSH
41480: LD_INT 0
41482: PUSH
41483: EMPTY
41484: LIST
41485: LIST
41486: PUSH
41487: LD_INT 3
41489: PUSH
41490: LD_INT 1
41492: PUSH
41493: EMPTY
41494: LIST
41495: LIST
41496: PUSH
41497: LD_INT 3
41499: PUSH
41500: LD_INT 2
41502: PUSH
41503: EMPTY
41504: LIST
41505: LIST
41506: PUSH
41507: LD_INT 3
41509: PUSH
41510: LD_INT 3
41512: PUSH
41513: EMPTY
41514: LIST
41515: LIST
41516: PUSH
41517: LD_INT 2
41519: PUSH
41520: LD_INT 3
41522: PUSH
41523: EMPTY
41524: LIST
41525: LIST
41526: PUSH
41527: LD_INT 2
41529: NEG
41530: PUSH
41531: LD_INT 1
41533: PUSH
41534: EMPTY
41535: LIST
41536: LIST
41537: PUSH
41538: LD_INT 3
41540: NEG
41541: PUSH
41542: LD_INT 0
41544: PUSH
41545: EMPTY
41546: LIST
41547: LIST
41548: PUSH
41549: LD_INT 3
41551: NEG
41552: PUSH
41553: LD_INT 1
41555: NEG
41556: PUSH
41557: EMPTY
41558: LIST
41559: LIST
41560: PUSH
41561: LD_INT 3
41563: NEG
41564: PUSH
41565: LD_INT 2
41567: NEG
41568: PUSH
41569: EMPTY
41570: LIST
41571: LIST
41572: PUSH
41573: LD_INT 3
41575: NEG
41576: PUSH
41577: LD_INT 3
41579: NEG
41580: PUSH
41581: EMPTY
41582: LIST
41583: LIST
41584: PUSH
41585: EMPTY
41586: LIST
41587: LIST
41588: LIST
41589: LIST
41590: LIST
41591: LIST
41592: LIST
41593: LIST
41594: LIST
41595: LIST
41596: LIST
41597: LIST
41598: LIST
41599: LIST
41600: LIST
41601: LIST
41602: LIST
41603: LIST
41604: LIST
41605: LIST
41606: LIST
41607: LIST
41608: LIST
41609: LIST
41610: LIST
41611: LIST
41612: LIST
41613: LIST
41614: LIST
41615: ST_TO_ADDR
// fLab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
41616: LD_ADDR_VAR 0 45
41620: PUSH
41621: LD_INT 0
41623: PUSH
41624: LD_INT 0
41626: PUSH
41627: EMPTY
41628: LIST
41629: LIST
41630: PUSH
41631: LD_INT 0
41633: PUSH
41634: LD_INT 1
41636: NEG
41637: PUSH
41638: EMPTY
41639: LIST
41640: LIST
41641: PUSH
41642: LD_INT 1
41644: PUSH
41645: LD_INT 0
41647: PUSH
41648: EMPTY
41649: LIST
41650: LIST
41651: PUSH
41652: LD_INT 1
41654: PUSH
41655: LD_INT 1
41657: PUSH
41658: EMPTY
41659: LIST
41660: LIST
41661: PUSH
41662: LD_INT 0
41664: PUSH
41665: LD_INT 1
41667: PUSH
41668: EMPTY
41669: LIST
41670: LIST
41671: PUSH
41672: LD_INT 1
41674: NEG
41675: PUSH
41676: LD_INT 0
41678: PUSH
41679: EMPTY
41680: LIST
41681: LIST
41682: PUSH
41683: LD_INT 1
41685: NEG
41686: PUSH
41687: LD_INT 1
41689: NEG
41690: PUSH
41691: EMPTY
41692: LIST
41693: LIST
41694: PUSH
41695: LD_INT 1
41697: NEG
41698: PUSH
41699: LD_INT 2
41701: NEG
41702: PUSH
41703: EMPTY
41704: LIST
41705: LIST
41706: PUSH
41707: LD_INT 0
41709: PUSH
41710: LD_INT 2
41712: NEG
41713: PUSH
41714: EMPTY
41715: LIST
41716: LIST
41717: PUSH
41718: LD_INT 1
41720: PUSH
41721: LD_INT 1
41723: NEG
41724: PUSH
41725: EMPTY
41726: LIST
41727: LIST
41728: PUSH
41729: LD_INT 2
41731: PUSH
41732: LD_INT 1
41734: PUSH
41735: EMPTY
41736: LIST
41737: LIST
41738: PUSH
41739: LD_INT 2
41741: PUSH
41742: LD_INT 2
41744: PUSH
41745: EMPTY
41746: LIST
41747: LIST
41748: PUSH
41749: LD_INT 1
41751: PUSH
41752: LD_INT 2
41754: PUSH
41755: EMPTY
41756: LIST
41757: LIST
41758: PUSH
41759: LD_INT 0
41761: PUSH
41762: LD_INT 2
41764: PUSH
41765: EMPTY
41766: LIST
41767: LIST
41768: PUSH
41769: LD_INT 1
41771: NEG
41772: PUSH
41773: LD_INT 1
41775: PUSH
41776: EMPTY
41777: LIST
41778: LIST
41779: PUSH
41780: LD_INT 2
41782: NEG
41783: PUSH
41784: LD_INT 1
41786: NEG
41787: PUSH
41788: EMPTY
41789: LIST
41790: LIST
41791: PUSH
41792: LD_INT 2
41794: NEG
41795: PUSH
41796: LD_INT 2
41798: NEG
41799: PUSH
41800: EMPTY
41801: LIST
41802: LIST
41803: PUSH
41804: LD_INT 2
41806: NEG
41807: PUSH
41808: LD_INT 3
41810: NEG
41811: PUSH
41812: EMPTY
41813: LIST
41814: LIST
41815: PUSH
41816: LD_INT 1
41818: NEG
41819: PUSH
41820: LD_INT 3
41822: NEG
41823: PUSH
41824: EMPTY
41825: LIST
41826: LIST
41827: PUSH
41828: LD_INT 0
41830: PUSH
41831: LD_INT 3
41833: NEG
41834: PUSH
41835: EMPTY
41836: LIST
41837: LIST
41838: PUSH
41839: LD_INT 1
41841: PUSH
41842: LD_INT 2
41844: NEG
41845: PUSH
41846: EMPTY
41847: LIST
41848: LIST
41849: PUSH
41850: LD_INT 3
41852: PUSH
41853: LD_INT 2
41855: PUSH
41856: EMPTY
41857: LIST
41858: LIST
41859: PUSH
41860: LD_INT 3
41862: PUSH
41863: LD_INT 3
41865: PUSH
41866: EMPTY
41867: LIST
41868: LIST
41869: PUSH
41870: LD_INT 2
41872: PUSH
41873: LD_INT 3
41875: PUSH
41876: EMPTY
41877: LIST
41878: LIST
41879: PUSH
41880: LD_INT 1
41882: PUSH
41883: LD_INT 3
41885: PUSH
41886: EMPTY
41887: LIST
41888: LIST
41889: PUSH
41890: LD_INT 0
41892: PUSH
41893: LD_INT 3
41895: PUSH
41896: EMPTY
41897: LIST
41898: LIST
41899: PUSH
41900: LD_INT 1
41902: NEG
41903: PUSH
41904: LD_INT 2
41906: PUSH
41907: EMPTY
41908: LIST
41909: LIST
41910: PUSH
41911: LD_INT 3
41913: NEG
41914: PUSH
41915: LD_INT 2
41917: NEG
41918: PUSH
41919: EMPTY
41920: LIST
41921: LIST
41922: PUSH
41923: LD_INT 3
41925: NEG
41926: PUSH
41927: LD_INT 3
41929: NEG
41930: PUSH
41931: EMPTY
41932: LIST
41933: LIST
41934: PUSH
41935: EMPTY
41936: LIST
41937: LIST
41938: LIST
41939: LIST
41940: LIST
41941: LIST
41942: LIST
41943: LIST
41944: LIST
41945: LIST
41946: LIST
41947: LIST
41948: LIST
41949: LIST
41950: LIST
41951: LIST
41952: LIST
41953: LIST
41954: LIST
41955: LIST
41956: LIST
41957: LIST
41958: LIST
41959: LIST
41960: LIST
41961: LIST
41962: LIST
41963: LIST
41964: LIST
41965: ST_TO_ADDR
// fLab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
41966: LD_ADDR_VAR 0 46
41970: PUSH
41971: LD_INT 0
41973: PUSH
41974: LD_INT 0
41976: PUSH
41977: EMPTY
41978: LIST
41979: LIST
41980: PUSH
41981: LD_INT 0
41983: PUSH
41984: LD_INT 1
41986: NEG
41987: PUSH
41988: EMPTY
41989: LIST
41990: LIST
41991: PUSH
41992: LD_INT 1
41994: PUSH
41995: LD_INT 0
41997: PUSH
41998: EMPTY
41999: LIST
42000: LIST
42001: PUSH
42002: LD_INT 1
42004: PUSH
42005: LD_INT 1
42007: PUSH
42008: EMPTY
42009: LIST
42010: LIST
42011: PUSH
42012: LD_INT 0
42014: PUSH
42015: LD_INT 1
42017: PUSH
42018: EMPTY
42019: LIST
42020: LIST
42021: PUSH
42022: LD_INT 1
42024: NEG
42025: PUSH
42026: LD_INT 0
42028: PUSH
42029: EMPTY
42030: LIST
42031: LIST
42032: PUSH
42033: LD_INT 1
42035: NEG
42036: PUSH
42037: LD_INT 1
42039: NEG
42040: PUSH
42041: EMPTY
42042: LIST
42043: LIST
42044: PUSH
42045: LD_INT 1
42047: NEG
42048: PUSH
42049: LD_INT 2
42051: NEG
42052: PUSH
42053: EMPTY
42054: LIST
42055: LIST
42056: PUSH
42057: LD_INT 0
42059: PUSH
42060: LD_INT 2
42062: NEG
42063: PUSH
42064: EMPTY
42065: LIST
42066: LIST
42067: PUSH
42068: LD_INT 1
42070: PUSH
42071: LD_INT 1
42073: NEG
42074: PUSH
42075: EMPTY
42076: LIST
42077: LIST
42078: PUSH
42079: LD_INT 2
42081: PUSH
42082: LD_INT 0
42084: PUSH
42085: EMPTY
42086: LIST
42087: LIST
42088: PUSH
42089: LD_INT 2
42091: PUSH
42092: LD_INT 1
42094: PUSH
42095: EMPTY
42096: LIST
42097: LIST
42098: PUSH
42099: LD_INT 1
42101: PUSH
42102: LD_INT 2
42104: PUSH
42105: EMPTY
42106: LIST
42107: LIST
42108: PUSH
42109: LD_INT 0
42111: PUSH
42112: LD_INT 2
42114: PUSH
42115: EMPTY
42116: LIST
42117: LIST
42118: PUSH
42119: LD_INT 1
42121: NEG
42122: PUSH
42123: LD_INT 1
42125: PUSH
42126: EMPTY
42127: LIST
42128: LIST
42129: PUSH
42130: LD_INT 2
42132: NEG
42133: PUSH
42134: LD_INT 0
42136: PUSH
42137: EMPTY
42138: LIST
42139: LIST
42140: PUSH
42141: LD_INT 2
42143: NEG
42144: PUSH
42145: LD_INT 1
42147: NEG
42148: PUSH
42149: EMPTY
42150: LIST
42151: LIST
42152: PUSH
42153: LD_INT 1
42155: NEG
42156: PUSH
42157: LD_INT 3
42159: NEG
42160: PUSH
42161: EMPTY
42162: LIST
42163: LIST
42164: PUSH
42165: LD_INT 0
42167: PUSH
42168: LD_INT 3
42170: NEG
42171: PUSH
42172: EMPTY
42173: LIST
42174: LIST
42175: PUSH
42176: LD_INT 1
42178: PUSH
42179: LD_INT 2
42181: NEG
42182: PUSH
42183: EMPTY
42184: LIST
42185: LIST
42186: PUSH
42187: LD_INT 2
42189: PUSH
42190: LD_INT 1
42192: NEG
42193: PUSH
42194: EMPTY
42195: LIST
42196: LIST
42197: PUSH
42198: LD_INT 3
42200: PUSH
42201: LD_INT 0
42203: PUSH
42204: EMPTY
42205: LIST
42206: LIST
42207: PUSH
42208: LD_INT 3
42210: PUSH
42211: LD_INT 1
42213: PUSH
42214: EMPTY
42215: LIST
42216: LIST
42217: PUSH
42218: LD_INT 1
42220: PUSH
42221: LD_INT 3
42223: PUSH
42224: EMPTY
42225: LIST
42226: LIST
42227: PUSH
42228: LD_INT 0
42230: PUSH
42231: LD_INT 3
42233: PUSH
42234: EMPTY
42235: LIST
42236: LIST
42237: PUSH
42238: LD_INT 1
42240: NEG
42241: PUSH
42242: LD_INT 2
42244: PUSH
42245: EMPTY
42246: LIST
42247: LIST
42248: PUSH
42249: LD_INT 2
42251: NEG
42252: PUSH
42253: LD_INT 1
42255: PUSH
42256: EMPTY
42257: LIST
42258: LIST
42259: PUSH
42260: LD_INT 3
42262: NEG
42263: PUSH
42264: LD_INT 0
42266: PUSH
42267: EMPTY
42268: LIST
42269: LIST
42270: PUSH
42271: LD_INT 3
42273: NEG
42274: PUSH
42275: LD_INT 1
42277: NEG
42278: PUSH
42279: EMPTY
42280: LIST
42281: LIST
42282: PUSH
42283: EMPTY
42284: LIST
42285: LIST
42286: LIST
42287: LIST
42288: LIST
42289: LIST
42290: LIST
42291: LIST
42292: LIST
42293: LIST
42294: LIST
42295: LIST
42296: LIST
42297: LIST
42298: LIST
42299: LIST
42300: LIST
42301: LIST
42302: LIST
42303: LIST
42304: LIST
42305: LIST
42306: LIST
42307: LIST
42308: LIST
42309: LIST
42310: LIST
42311: LIST
42312: LIST
42313: ST_TO_ADDR
// fControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
42314: LD_ADDR_VAR 0 47
42318: PUSH
42319: LD_INT 0
42321: PUSH
42322: LD_INT 0
42324: PUSH
42325: EMPTY
42326: LIST
42327: LIST
42328: PUSH
42329: LD_INT 0
42331: PUSH
42332: LD_INT 1
42334: NEG
42335: PUSH
42336: EMPTY
42337: LIST
42338: LIST
42339: PUSH
42340: LD_INT 1
42342: PUSH
42343: LD_INT 0
42345: PUSH
42346: EMPTY
42347: LIST
42348: LIST
42349: PUSH
42350: LD_INT 1
42352: PUSH
42353: LD_INT 1
42355: PUSH
42356: EMPTY
42357: LIST
42358: LIST
42359: PUSH
42360: LD_INT 0
42362: PUSH
42363: LD_INT 1
42365: PUSH
42366: EMPTY
42367: LIST
42368: LIST
42369: PUSH
42370: LD_INT 1
42372: NEG
42373: PUSH
42374: LD_INT 0
42376: PUSH
42377: EMPTY
42378: LIST
42379: LIST
42380: PUSH
42381: LD_INT 1
42383: NEG
42384: PUSH
42385: LD_INT 1
42387: NEG
42388: PUSH
42389: EMPTY
42390: LIST
42391: LIST
42392: PUSH
42393: LD_INT 1
42395: NEG
42396: PUSH
42397: LD_INT 2
42399: NEG
42400: PUSH
42401: EMPTY
42402: LIST
42403: LIST
42404: PUSH
42405: LD_INT 0
42407: PUSH
42408: LD_INT 2
42410: NEG
42411: PUSH
42412: EMPTY
42413: LIST
42414: LIST
42415: PUSH
42416: LD_INT 1
42418: PUSH
42419: LD_INT 1
42421: NEG
42422: PUSH
42423: EMPTY
42424: LIST
42425: LIST
42426: PUSH
42427: LD_INT 2
42429: NEG
42430: PUSH
42431: LD_INT 1
42433: NEG
42434: PUSH
42435: EMPTY
42436: LIST
42437: LIST
42438: PUSH
42439: LD_INT 2
42441: NEG
42442: PUSH
42443: LD_INT 2
42445: NEG
42446: PUSH
42447: EMPTY
42448: LIST
42449: LIST
42450: PUSH
42451: EMPTY
42452: LIST
42453: LIST
42454: LIST
42455: LIST
42456: LIST
42457: LIST
42458: LIST
42459: LIST
42460: LIST
42461: LIST
42462: LIST
42463: LIST
42464: ST_TO_ADDR
// fControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
42465: LD_ADDR_VAR 0 48
42469: PUSH
42470: LD_INT 0
42472: PUSH
42473: LD_INT 0
42475: PUSH
42476: EMPTY
42477: LIST
42478: LIST
42479: PUSH
42480: LD_INT 0
42482: PUSH
42483: LD_INT 1
42485: NEG
42486: PUSH
42487: EMPTY
42488: LIST
42489: LIST
42490: PUSH
42491: LD_INT 1
42493: PUSH
42494: LD_INT 0
42496: PUSH
42497: EMPTY
42498: LIST
42499: LIST
42500: PUSH
42501: LD_INT 1
42503: PUSH
42504: LD_INT 1
42506: PUSH
42507: EMPTY
42508: LIST
42509: LIST
42510: PUSH
42511: LD_INT 0
42513: PUSH
42514: LD_INT 1
42516: PUSH
42517: EMPTY
42518: LIST
42519: LIST
42520: PUSH
42521: LD_INT 1
42523: NEG
42524: PUSH
42525: LD_INT 0
42527: PUSH
42528: EMPTY
42529: LIST
42530: LIST
42531: PUSH
42532: LD_INT 1
42534: NEG
42535: PUSH
42536: LD_INT 1
42538: NEG
42539: PUSH
42540: EMPTY
42541: LIST
42542: LIST
42543: PUSH
42544: LD_INT 1
42546: NEG
42547: PUSH
42548: LD_INT 2
42550: NEG
42551: PUSH
42552: EMPTY
42553: LIST
42554: LIST
42555: PUSH
42556: LD_INT 0
42558: PUSH
42559: LD_INT 2
42561: NEG
42562: PUSH
42563: EMPTY
42564: LIST
42565: LIST
42566: PUSH
42567: LD_INT 1
42569: PUSH
42570: LD_INT 1
42572: NEG
42573: PUSH
42574: EMPTY
42575: LIST
42576: LIST
42577: PUSH
42578: LD_INT 2
42580: PUSH
42581: LD_INT 0
42583: PUSH
42584: EMPTY
42585: LIST
42586: LIST
42587: PUSH
42588: LD_INT 2
42590: PUSH
42591: LD_INT 1
42593: PUSH
42594: EMPTY
42595: LIST
42596: LIST
42597: PUSH
42598: EMPTY
42599: LIST
42600: LIST
42601: LIST
42602: LIST
42603: LIST
42604: LIST
42605: LIST
42606: LIST
42607: LIST
42608: LIST
42609: LIST
42610: LIST
42611: ST_TO_ADDR
// fControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
42612: LD_ADDR_VAR 0 49
42616: PUSH
42617: LD_INT 0
42619: PUSH
42620: LD_INT 0
42622: PUSH
42623: EMPTY
42624: LIST
42625: LIST
42626: PUSH
42627: LD_INT 0
42629: PUSH
42630: LD_INT 1
42632: NEG
42633: PUSH
42634: EMPTY
42635: LIST
42636: LIST
42637: PUSH
42638: LD_INT 1
42640: PUSH
42641: LD_INT 0
42643: PUSH
42644: EMPTY
42645: LIST
42646: LIST
42647: PUSH
42648: LD_INT 1
42650: PUSH
42651: LD_INT 1
42653: PUSH
42654: EMPTY
42655: LIST
42656: LIST
42657: PUSH
42658: LD_INT 0
42660: PUSH
42661: LD_INT 1
42663: PUSH
42664: EMPTY
42665: LIST
42666: LIST
42667: PUSH
42668: LD_INT 1
42670: NEG
42671: PUSH
42672: LD_INT 0
42674: PUSH
42675: EMPTY
42676: LIST
42677: LIST
42678: PUSH
42679: LD_INT 1
42681: NEG
42682: PUSH
42683: LD_INT 1
42685: NEG
42686: PUSH
42687: EMPTY
42688: LIST
42689: LIST
42690: PUSH
42691: LD_INT 1
42693: PUSH
42694: LD_INT 1
42696: NEG
42697: PUSH
42698: EMPTY
42699: LIST
42700: LIST
42701: PUSH
42702: LD_INT 2
42704: PUSH
42705: LD_INT 0
42707: PUSH
42708: EMPTY
42709: LIST
42710: LIST
42711: PUSH
42712: LD_INT 2
42714: PUSH
42715: LD_INT 1
42717: PUSH
42718: EMPTY
42719: LIST
42720: LIST
42721: PUSH
42722: LD_INT 2
42724: PUSH
42725: LD_INT 2
42727: PUSH
42728: EMPTY
42729: LIST
42730: LIST
42731: PUSH
42732: LD_INT 1
42734: PUSH
42735: LD_INT 2
42737: PUSH
42738: EMPTY
42739: LIST
42740: LIST
42741: PUSH
42742: EMPTY
42743: LIST
42744: LIST
42745: LIST
42746: LIST
42747: LIST
42748: LIST
42749: LIST
42750: LIST
42751: LIST
42752: LIST
42753: LIST
42754: LIST
42755: ST_TO_ADDR
// fControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
42756: LD_ADDR_VAR 0 50
42760: PUSH
42761: LD_INT 0
42763: PUSH
42764: LD_INT 0
42766: PUSH
42767: EMPTY
42768: LIST
42769: LIST
42770: PUSH
42771: LD_INT 0
42773: PUSH
42774: LD_INT 1
42776: NEG
42777: PUSH
42778: EMPTY
42779: LIST
42780: LIST
42781: PUSH
42782: LD_INT 1
42784: PUSH
42785: LD_INT 0
42787: PUSH
42788: EMPTY
42789: LIST
42790: LIST
42791: PUSH
42792: LD_INT 1
42794: PUSH
42795: LD_INT 1
42797: PUSH
42798: EMPTY
42799: LIST
42800: LIST
42801: PUSH
42802: LD_INT 0
42804: PUSH
42805: LD_INT 1
42807: PUSH
42808: EMPTY
42809: LIST
42810: LIST
42811: PUSH
42812: LD_INT 1
42814: NEG
42815: PUSH
42816: LD_INT 0
42818: PUSH
42819: EMPTY
42820: LIST
42821: LIST
42822: PUSH
42823: LD_INT 1
42825: NEG
42826: PUSH
42827: LD_INT 1
42829: NEG
42830: PUSH
42831: EMPTY
42832: LIST
42833: LIST
42834: PUSH
42835: LD_INT 2
42837: PUSH
42838: LD_INT 1
42840: PUSH
42841: EMPTY
42842: LIST
42843: LIST
42844: PUSH
42845: LD_INT 2
42847: PUSH
42848: LD_INT 2
42850: PUSH
42851: EMPTY
42852: LIST
42853: LIST
42854: PUSH
42855: LD_INT 1
42857: PUSH
42858: LD_INT 2
42860: PUSH
42861: EMPTY
42862: LIST
42863: LIST
42864: PUSH
42865: LD_INT 0
42867: PUSH
42868: LD_INT 2
42870: PUSH
42871: EMPTY
42872: LIST
42873: LIST
42874: PUSH
42875: LD_INT 1
42877: NEG
42878: PUSH
42879: LD_INT 1
42881: PUSH
42882: EMPTY
42883: LIST
42884: LIST
42885: PUSH
42886: EMPTY
42887: LIST
42888: LIST
42889: LIST
42890: LIST
42891: LIST
42892: LIST
42893: LIST
42894: LIST
42895: LIST
42896: LIST
42897: LIST
42898: LIST
42899: ST_TO_ADDR
// fControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
42900: LD_ADDR_VAR 0 51
42904: PUSH
42905: LD_INT 0
42907: PUSH
42908: LD_INT 0
42910: PUSH
42911: EMPTY
42912: LIST
42913: LIST
42914: PUSH
42915: LD_INT 0
42917: PUSH
42918: LD_INT 1
42920: NEG
42921: PUSH
42922: EMPTY
42923: LIST
42924: LIST
42925: PUSH
42926: LD_INT 1
42928: PUSH
42929: LD_INT 0
42931: PUSH
42932: EMPTY
42933: LIST
42934: LIST
42935: PUSH
42936: LD_INT 1
42938: PUSH
42939: LD_INT 1
42941: PUSH
42942: EMPTY
42943: LIST
42944: LIST
42945: PUSH
42946: LD_INT 0
42948: PUSH
42949: LD_INT 1
42951: PUSH
42952: EMPTY
42953: LIST
42954: LIST
42955: PUSH
42956: LD_INT 1
42958: NEG
42959: PUSH
42960: LD_INT 0
42962: PUSH
42963: EMPTY
42964: LIST
42965: LIST
42966: PUSH
42967: LD_INT 1
42969: NEG
42970: PUSH
42971: LD_INT 1
42973: NEG
42974: PUSH
42975: EMPTY
42976: LIST
42977: LIST
42978: PUSH
42979: LD_INT 1
42981: PUSH
42982: LD_INT 2
42984: PUSH
42985: EMPTY
42986: LIST
42987: LIST
42988: PUSH
42989: LD_INT 0
42991: PUSH
42992: LD_INT 2
42994: PUSH
42995: EMPTY
42996: LIST
42997: LIST
42998: PUSH
42999: LD_INT 1
43001: NEG
43002: PUSH
43003: LD_INT 1
43005: PUSH
43006: EMPTY
43007: LIST
43008: LIST
43009: PUSH
43010: LD_INT 2
43012: NEG
43013: PUSH
43014: LD_INT 0
43016: PUSH
43017: EMPTY
43018: LIST
43019: LIST
43020: PUSH
43021: LD_INT 2
43023: NEG
43024: PUSH
43025: LD_INT 1
43027: NEG
43028: PUSH
43029: EMPTY
43030: LIST
43031: LIST
43032: PUSH
43033: EMPTY
43034: LIST
43035: LIST
43036: LIST
43037: LIST
43038: LIST
43039: LIST
43040: LIST
43041: LIST
43042: LIST
43043: LIST
43044: LIST
43045: LIST
43046: ST_TO_ADDR
// fControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
43047: LD_ADDR_VAR 0 52
43051: PUSH
43052: LD_INT 0
43054: PUSH
43055: LD_INT 0
43057: PUSH
43058: EMPTY
43059: LIST
43060: LIST
43061: PUSH
43062: LD_INT 0
43064: PUSH
43065: LD_INT 1
43067: NEG
43068: PUSH
43069: EMPTY
43070: LIST
43071: LIST
43072: PUSH
43073: LD_INT 1
43075: PUSH
43076: LD_INT 0
43078: PUSH
43079: EMPTY
43080: LIST
43081: LIST
43082: PUSH
43083: LD_INT 1
43085: PUSH
43086: LD_INT 1
43088: PUSH
43089: EMPTY
43090: LIST
43091: LIST
43092: PUSH
43093: LD_INT 0
43095: PUSH
43096: LD_INT 1
43098: PUSH
43099: EMPTY
43100: LIST
43101: LIST
43102: PUSH
43103: LD_INT 1
43105: NEG
43106: PUSH
43107: LD_INT 0
43109: PUSH
43110: EMPTY
43111: LIST
43112: LIST
43113: PUSH
43114: LD_INT 1
43116: NEG
43117: PUSH
43118: LD_INT 1
43120: NEG
43121: PUSH
43122: EMPTY
43123: LIST
43124: LIST
43125: PUSH
43126: LD_INT 1
43128: NEG
43129: PUSH
43130: LD_INT 2
43132: NEG
43133: PUSH
43134: EMPTY
43135: LIST
43136: LIST
43137: PUSH
43138: LD_INT 1
43140: NEG
43141: PUSH
43142: LD_INT 1
43144: PUSH
43145: EMPTY
43146: LIST
43147: LIST
43148: PUSH
43149: LD_INT 2
43151: NEG
43152: PUSH
43153: LD_INT 0
43155: PUSH
43156: EMPTY
43157: LIST
43158: LIST
43159: PUSH
43160: LD_INT 2
43162: NEG
43163: PUSH
43164: LD_INT 1
43166: NEG
43167: PUSH
43168: EMPTY
43169: LIST
43170: LIST
43171: PUSH
43172: LD_INT 2
43174: NEG
43175: PUSH
43176: LD_INT 2
43178: NEG
43179: PUSH
43180: EMPTY
43181: LIST
43182: LIST
43183: PUSH
43184: EMPTY
43185: LIST
43186: LIST
43187: LIST
43188: LIST
43189: LIST
43190: LIST
43191: LIST
43192: LIST
43193: LIST
43194: LIST
43195: LIST
43196: LIST
43197: ST_TO_ADDR
// fBarracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
43198: LD_ADDR_VAR 0 53
43202: PUSH
43203: LD_INT 0
43205: PUSH
43206: LD_INT 0
43208: PUSH
43209: EMPTY
43210: LIST
43211: LIST
43212: PUSH
43213: LD_INT 0
43215: PUSH
43216: LD_INT 1
43218: NEG
43219: PUSH
43220: EMPTY
43221: LIST
43222: LIST
43223: PUSH
43224: LD_INT 1
43226: PUSH
43227: LD_INT 0
43229: PUSH
43230: EMPTY
43231: LIST
43232: LIST
43233: PUSH
43234: LD_INT 1
43236: PUSH
43237: LD_INT 1
43239: PUSH
43240: EMPTY
43241: LIST
43242: LIST
43243: PUSH
43244: LD_INT 0
43246: PUSH
43247: LD_INT 1
43249: PUSH
43250: EMPTY
43251: LIST
43252: LIST
43253: PUSH
43254: LD_INT 1
43256: NEG
43257: PUSH
43258: LD_INT 0
43260: PUSH
43261: EMPTY
43262: LIST
43263: LIST
43264: PUSH
43265: LD_INT 1
43267: NEG
43268: PUSH
43269: LD_INT 1
43271: NEG
43272: PUSH
43273: EMPTY
43274: LIST
43275: LIST
43276: PUSH
43277: LD_INT 1
43279: NEG
43280: PUSH
43281: LD_INT 2
43283: NEG
43284: PUSH
43285: EMPTY
43286: LIST
43287: LIST
43288: PUSH
43289: LD_INT 0
43291: PUSH
43292: LD_INT 2
43294: NEG
43295: PUSH
43296: EMPTY
43297: LIST
43298: LIST
43299: PUSH
43300: LD_INT 1
43302: PUSH
43303: LD_INT 1
43305: NEG
43306: PUSH
43307: EMPTY
43308: LIST
43309: LIST
43310: PUSH
43311: LD_INT 2
43313: PUSH
43314: LD_INT 0
43316: PUSH
43317: EMPTY
43318: LIST
43319: LIST
43320: PUSH
43321: LD_INT 2
43323: PUSH
43324: LD_INT 1
43326: PUSH
43327: EMPTY
43328: LIST
43329: LIST
43330: PUSH
43331: LD_INT 2
43333: PUSH
43334: LD_INT 2
43336: PUSH
43337: EMPTY
43338: LIST
43339: LIST
43340: PUSH
43341: LD_INT 1
43343: PUSH
43344: LD_INT 2
43346: PUSH
43347: EMPTY
43348: LIST
43349: LIST
43350: PUSH
43351: LD_INT 0
43353: PUSH
43354: LD_INT 2
43356: PUSH
43357: EMPTY
43358: LIST
43359: LIST
43360: PUSH
43361: LD_INT 1
43363: NEG
43364: PUSH
43365: LD_INT 1
43367: PUSH
43368: EMPTY
43369: LIST
43370: LIST
43371: PUSH
43372: LD_INT 2
43374: NEG
43375: PUSH
43376: LD_INT 0
43378: PUSH
43379: EMPTY
43380: LIST
43381: LIST
43382: PUSH
43383: LD_INT 2
43385: NEG
43386: PUSH
43387: LD_INT 1
43389: NEG
43390: PUSH
43391: EMPTY
43392: LIST
43393: LIST
43394: PUSH
43395: LD_INT 2
43397: NEG
43398: PUSH
43399: LD_INT 2
43401: NEG
43402: PUSH
43403: EMPTY
43404: LIST
43405: LIST
43406: PUSH
43407: EMPTY
43408: LIST
43409: LIST
43410: LIST
43411: LIST
43412: LIST
43413: LIST
43414: LIST
43415: LIST
43416: LIST
43417: LIST
43418: LIST
43419: LIST
43420: LIST
43421: LIST
43422: LIST
43423: LIST
43424: LIST
43425: LIST
43426: LIST
43427: ST_TO_ADDR
// fBarracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
43428: LD_ADDR_VAR 0 54
43432: PUSH
43433: LD_INT 0
43435: PUSH
43436: LD_INT 0
43438: PUSH
43439: EMPTY
43440: LIST
43441: LIST
43442: PUSH
43443: LD_INT 0
43445: PUSH
43446: LD_INT 1
43448: NEG
43449: PUSH
43450: EMPTY
43451: LIST
43452: LIST
43453: PUSH
43454: LD_INT 1
43456: PUSH
43457: LD_INT 0
43459: PUSH
43460: EMPTY
43461: LIST
43462: LIST
43463: PUSH
43464: LD_INT 1
43466: PUSH
43467: LD_INT 1
43469: PUSH
43470: EMPTY
43471: LIST
43472: LIST
43473: PUSH
43474: LD_INT 0
43476: PUSH
43477: LD_INT 1
43479: PUSH
43480: EMPTY
43481: LIST
43482: LIST
43483: PUSH
43484: LD_INT 1
43486: NEG
43487: PUSH
43488: LD_INT 0
43490: PUSH
43491: EMPTY
43492: LIST
43493: LIST
43494: PUSH
43495: LD_INT 1
43497: NEG
43498: PUSH
43499: LD_INT 1
43501: NEG
43502: PUSH
43503: EMPTY
43504: LIST
43505: LIST
43506: PUSH
43507: LD_INT 1
43509: NEG
43510: PUSH
43511: LD_INT 2
43513: NEG
43514: PUSH
43515: EMPTY
43516: LIST
43517: LIST
43518: PUSH
43519: LD_INT 0
43521: PUSH
43522: LD_INT 2
43524: NEG
43525: PUSH
43526: EMPTY
43527: LIST
43528: LIST
43529: PUSH
43530: LD_INT 1
43532: PUSH
43533: LD_INT 1
43535: NEG
43536: PUSH
43537: EMPTY
43538: LIST
43539: LIST
43540: PUSH
43541: LD_INT 2
43543: PUSH
43544: LD_INT 0
43546: PUSH
43547: EMPTY
43548: LIST
43549: LIST
43550: PUSH
43551: LD_INT 2
43553: PUSH
43554: LD_INT 1
43556: PUSH
43557: EMPTY
43558: LIST
43559: LIST
43560: PUSH
43561: LD_INT 2
43563: PUSH
43564: LD_INT 2
43566: PUSH
43567: EMPTY
43568: LIST
43569: LIST
43570: PUSH
43571: LD_INT 1
43573: PUSH
43574: LD_INT 2
43576: PUSH
43577: EMPTY
43578: LIST
43579: LIST
43580: PUSH
43581: LD_INT 0
43583: PUSH
43584: LD_INT 2
43586: PUSH
43587: EMPTY
43588: LIST
43589: LIST
43590: PUSH
43591: LD_INT 1
43593: NEG
43594: PUSH
43595: LD_INT 1
43597: PUSH
43598: EMPTY
43599: LIST
43600: LIST
43601: PUSH
43602: LD_INT 2
43604: NEG
43605: PUSH
43606: LD_INT 0
43608: PUSH
43609: EMPTY
43610: LIST
43611: LIST
43612: PUSH
43613: LD_INT 2
43615: NEG
43616: PUSH
43617: LD_INT 1
43619: NEG
43620: PUSH
43621: EMPTY
43622: LIST
43623: LIST
43624: PUSH
43625: LD_INT 2
43627: NEG
43628: PUSH
43629: LD_INT 2
43631: NEG
43632: PUSH
43633: EMPTY
43634: LIST
43635: LIST
43636: PUSH
43637: EMPTY
43638: LIST
43639: LIST
43640: LIST
43641: LIST
43642: LIST
43643: LIST
43644: LIST
43645: LIST
43646: LIST
43647: LIST
43648: LIST
43649: LIST
43650: LIST
43651: LIST
43652: LIST
43653: LIST
43654: LIST
43655: LIST
43656: LIST
43657: ST_TO_ADDR
// fBarracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
43658: LD_ADDR_VAR 0 55
43662: PUSH
43663: LD_INT 0
43665: PUSH
43666: LD_INT 0
43668: PUSH
43669: EMPTY
43670: LIST
43671: LIST
43672: PUSH
43673: LD_INT 0
43675: PUSH
43676: LD_INT 1
43678: NEG
43679: PUSH
43680: EMPTY
43681: LIST
43682: LIST
43683: PUSH
43684: LD_INT 1
43686: PUSH
43687: LD_INT 0
43689: PUSH
43690: EMPTY
43691: LIST
43692: LIST
43693: PUSH
43694: LD_INT 1
43696: PUSH
43697: LD_INT 1
43699: PUSH
43700: EMPTY
43701: LIST
43702: LIST
43703: PUSH
43704: LD_INT 0
43706: PUSH
43707: LD_INT 1
43709: PUSH
43710: EMPTY
43711: LIST
43712: LIST
43713: PUSH
43714: LD_INT 1
43716: NEG
43717: PUSH
43718: LD_INT 0
43720: PUSH
43721: EMPTY
43722: LIST
43723: LIST
43724: PUSH
43725: LD_INT 1
43727: NEG
43728: PUSH
43729: LD_INT 1
43731: NEG
43732: PUSH
43733: EMPTY
43734: LIST
43735: LIST
43736: PUSH
43737: LD_INT 1
43739: NEG
43740: PUSH
43741: LD_INT 2
43743: NEG
43744: PUSH
43745: EMPTY
43746: LIST
43747: LIST
43748: PUSH
43749: LD_INT 0
43751: PUSH
43752: LD_INT 2
43754: NEG
43755: PUSH
43756: EMPTY
43757: LIST
43758: LIST
43759: PUSH
43760: LD_INT 1
43762: PUSH
43763: LD_INT 1
43765: NEG
43766: PUSH
43767: EMPTY
43768: LIST
43769: LIST
43770: PUSH
43771: LD_INT 2
43773: PUSH
43774: LD_INT 0
43776: PUSH
43777: EMPTY
43778: LIST
43779: LIST
43780: PUSH
43781: LD_INT 2
43783: PUSH
43784: LD_INT 1
43786: PUSH
43787: EMPTY
43788: LIST
43789: LIST
43790: PUSH
43791: LD_INT 2
43793: PUSH
43794: LD_INT 2
43796: PUSH
43797: EMPTY
43798: LIST
43799: LIST
43800: PUSH
43801: LD_INT 1
43803: PUSH
43804: LD_INT 2
43806: PUSH
43807: EMPTY
43808: LIST
43809: LIST
43810: PUSH
43811: LD_INT 0
43813: PUSH
43814: LD_INT 2
43816: PUSH
43817: EMPTY
43818: LIST
43819: LIST
43820: PUSH
43821: LD_INT 1
43823: NEG
43824: PUSH
43825: LD_INT 1
43827: PUSH
43828: EMPTY
43829: LIST
43830: LIST
43831: PUSH
43832: LD_INT 2
43834: NEG
43835: PUSH
43836: LD_INT 0
43838: PUSH
43839: EMPTY
43840: LIST
43841: LIST
43842: PUSH
43843: LD_INT 2
43845: NEG
43846: PUSH
43847: LD_INT 1
43849: NEG
43850: PUSH
43851: EMPTY
43852: LIST
43853: LIST
43854: PUSH
43855: LD_INT 2
43857: NEG
43858: PUSH
43859: LD_INT 2
43861: NEG
43862: PUSH
43863: EMPTY
43864: LIST
43865: LIST
43866: PUSH
43867: EMPTY
43868: LIST
43869: LIST
43870: LIST
43871: LIST
43872: LIST
43873: LIST
43874: LIST
43875: LIST
43876: LIST
43877: LIST
43878: LIST
43879: LIST
43880: LIST
43881: LIST
43882: LIST
43883: LIST
43884: LIST
43885: LIST
43886: LIST
43887: ST_TO_ADDR
// fBarracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
43888: LD_ADDR_VAR 0 56
43892: PUSH
43893: LD_INT 0
43895: PUSH
43896: LD_INT 0
43898: PUSH
43899: EMPTY
43900: LIST
43901: LIST
43902: PUSH
43903: LD_INT 0
43905: PUSH
43906: LD_INT 1
43908: NEG
43909: PUSH
43910: EMPTY
43911: LIST
43912: LIST
43913: PUSH
43914: LD_INT 1
43916: PUSH
43917: LD_INT 0
43919: PUSH
43920: EMPTY
43921: LIST
43922: LIST
43923: PUSH
43924: LD_INT 1
43926: PUSH
43927: LD_INT 1
43929: PUSH
43930: EMPTY
43931: LIST
43932: LIST
43933: PUSH
43934: LD_INT 0
43936: PUSH
43937: LD_INT 1
43939: PUSH
43940: EMPTY
43941: LIST
43942: LIST
43943: PUSH
43944: LD_INT 1
43946: NEG
43947: PUSH
43948: LD_INT 0
43950: PUSH
43951: EMPTY
43952: LIST
43953: LIST
43954: PUSH
43955: LD_INT 1
43957: NEG
43958: PUSH
43959: LD_INT 1
43961: NEG
43962: PUSH
43963: EMPTY
43964: LIST
43965: LIST
43966: PUSH
43967: LD_INT 1
43969: NEG
43970: PUSH
43971: LD_INT 2
43973: NEG
43974: PUSH
43975: EMPTY
43976: LIST
43977: LIST
43978: PUSH
43979: LD_INT 0
43981: PUSH
43982: LD_INT 2
43984: NEG
43985: PUSH
43986: EMPTY
43987: LIST
43988: LIST
43989: PUSH
43990: LD_INT 1
43992: PUSH
43993: LD_INT 1
43995: NEG
43996: PUSH
43997: EMPTY
43998: LIST
43999: LIST
44000: PUSH
44001: LD_INT 2
44003: PUSH
44004: LD_INT 0
44006: PUSH
44007: EMPTY
44008: LIST
44009: LIST
44010: PUSH
44011: LD_INT 2
44013: PUSH
44014: LD_INT 1
44016: PUSH
44017: EMPTY
44018: LIST
44019: LIST
44020: PUSH
44021: LD_INT 2
44023: PUSH
44024: LD_INT 2
44026: PUSH
44027: EMPTY
44028: LIST
44029: LIST
44030: PUSH
44031: LD_INT 1
44033: PUSH
44034: LD_INT 2
44036: PUSH
44037: EMPTY
44038: LIST
44039: LIST
44040: PUSH
44041: LD_INT 0
44043: PUSH
44044: LD_INT 2
44046: PUSH
44047: EMPTY
44048: LIST
44049: LIST
44050: PUSH
44051: LD_INT 1
44053: NEG
44054: PUSH
44055: LD_INT 1
44057: PUSH
44058: EMPTY
44059: LIST
44060: LIST
44061: PUSH
44062: LD_INT 2
44064: NEG
44065: PUSH
44066: LD_INT 0
44068: PUSH
44069: EMPTY
44070: LIST
44071: LIST
44072: PUSH
44073: LD_INT 2
44075: NEG
44076: PUSH
44077: LD_INT 1
44079: NEG
44080: PUSH
44081: EMPTY
44082: LIST
44083: LIST
44084: PUSH
44085: LD_INT 2
44087: NEG
44088: PUSH
44089: LD_INT 2
44091: NEG
44092: PUSH
44093: EMPTY
44094: LIST
44095: LIST
44096: PUSH
44097: EMPTY
44098: LIST
44099: LIST
44100: LIST
44101: LIST
44102: LIST
44103: LIST
44104: LIST
44105: LIST
44106: LIST
44107: LIST
44108: LIST
44109: LIST
44110: LIST
44111: LIST
44112: LIST
44113: LIST
44114: LIST
44115: LIST
44116: LIST
44117: ST_TO_ADDR
// fBarracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
44118: LD_ADDR_VAR 0 57
44122: PUSH
44123: LD_INT 0
44125: PUSH
44126: LD_INT 0
44128: PUSH
44129: EMPTY
44130: LIST
44131: LIST
44132: PUSH
44133: LD_INT 0
44135: PUSH
44136: LD_INT 1
44138: NEG
44139: PUSH
44140: EMPTY
44141: LIST
44142: LIST
44143: PUSH
44144: LD_INT 1
44146: PUSH
44147: LD_INT 0
44149: PUSH
44150: EMPTY
44151: LIST
44152: LIST
44153: PUSH
44154: LD_INT 1
44156: PUSH
44157: LD_INT 1
44159: PUSH
44160: EMPTY
44161: LIST
44162: LIST
44163: PUSH
44164: LD_INT 0
44166: PUSH
44167: LD_INT 1
44169: PUSH
44170: EMPTY
44171: LIST
44172: LIST
44173: PUSH
44174: LD_INT 1
44176: NEG
44177: PUSH
44178: LD_INT 0
44180: PUSH
44181: EMPTY
44182: LIST
44183: LIST
44184: PUSH
44185: LD_INT 1
44187: NEG
44188: PUSH
44189: LD_INT 1
44191: NEG
44192: PUSH
44193: EMPTY
44194: LIST
44195: LIST
44196: PUSH
44197: LD_INT 1
44199: NEG
44200: PUSH
44201: LD_INT 2
44203: NEG
44204: PUSH
44205: EMPTY
44206: LIST
44207: LIST
44208: PUSH
44209: LD_INT 0
44211: PUSH
44212: LD_INT 2
44214: NEG
44215: PUSH
44216: EMPTY
44217: LIST
44218: LIST
44219: PUSH
44220: LD_INT 1
44222: PUSH
44223: LD_INT 1
44225: NEG
44226: PUSH
44227: EMPTY
44228: LIST
44229: LIST
44230: PUSH
44231: LD_INT 2
44233: PUSH
44234: LD_INT 0
44236: PUSH
44237: EMPTY
44238: LIST
44239: LIST
44240: PUSH
44241: LD_INT 2
44243: PUSH
44244: LD_INT 1
44246: PUSH
44247: EMPTY
44248: LIST
44249: LIST
44250: PUSH
44251: LD_INT 2
44253: PUSH
44254: LD_INT 2
44256: PUSH
44257: EMPTY
44258: LIST
44259: LIST
44260: PUSH
44261: LD_INT 1
44263: PUSH
44264: LD_INT 2
44266: PUSH
44267: EMPTY
44268: LIST
44269: LIST
44270: PUSH
44271: LD_INT 0
44273: PUSH
44274: LD_INT 2
44276: PUSH
44277: EMPTY
44278: LIST
44279: LIST
44280: PUSH
44281: LD_INT 1
44283: NEG
44284: PUSH
44285: LD_INT 1
44287: PUSH
44288: EMPTY
44289: LIST
44290: LIST
44291: PUSH
44292: LD_INT 2
44294: NEG
44295: PUSH
44296: LD_INT 0
44298: PUSH
44299: EMPTY
44300: LIST
44301: LIST
44302: PUSH
44303: LD_INT 2
44305: NEG
44306: PUSH
44307: LD_INT 1
44309: NEG
44310: PUSH
44311: EMPTY
44312: LIST
44313: LIST
44314: PUSH
44315: LD_INT 2
44317: NEG
44318: PUSH
44319: LD_INT 2
44321: NEG
44322: PUSH
44323: EMPTY
44324: LIST
44325: LIST
44326: PUSH
44327: EMPTY
44328: LIST
44329: LIST
44330: LIST
44331: LIST
44332: LIST
44333: LIST
44334: LIST
44335: LIST
44336: LIST
44337: LIST
44338: LIST
44339: LIST
44340: LIST
44341: LIST
44342: LIST
44343: LIST
44344: LIST
44345: LIST
44346: LIST
44347: ST_TO_ADDR
// fBarracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
44348: LD_ADDR_VAR 0 58
44352: PUSH
44353: LD_INT 0
44355: PUSH
44356: LD_INT 0
44358: PUSH
44359: EMPTY
44360: LIST
44361: LIST
44362: PUSH
44363: LD_INT 0
44365: PUSH
44366: LD_INT 1
44368: NEG
44369: PUSH
44370: EMPTY
44371: LIST
44372: LIST
44373: PUSH
44374: LD_INT 1
44376: PUSH
44377: LD_INT 0
44379: PUSH
44380: EMPTY
44381: LIST
44382: LIST
44383: PUSH
44384: LD_INT 1
44386: PUSH
44387: LD_INT 1
44389: PUSH
44390: EMPTY
44391: LIST
44392: LIST
44393: PUSH
44394: LD_INT 0
44396: PUSH
44397: LD_INT 1
44399: PUSH
44400: EMPTY
44401: LIST
44402: LIST
44403: PUSH
44404: LD_INT 1
44406: NEG
44407: PUSH
44408: LD_INT 0
44410: PUSH
44411: EMPTY
44412: LIST
44413: LIST
44414: PUSH
44415: LD_INT 1
44417: NEG
44418: PUSH
44419: LD_INT 1
44421: NEG
44422: PUSH
44423: EMPTY
44424: LIST
44425: LIST
44426: PUSH
44427: LD_INT 1
44429: NEG
44430: PUSH
44431: LD_INT 2
44433: NEG
44434: PUSH
44435: EMPTY
44436: LIST
44437: LIST
44438: PUSH
44439: LD_INT 0
44441: PUSH
44442: LD_INT 2
44444: NEG
44445: PUSH
44446: EMPTY
44447: LIST
44448: LIST
44449: PUSH
44450: LD_INT 1
44452: PUSH
44453: LD_INT 1
44455: NEG
44456: PUSH
44457: EMPTY
44458: LIST
44459: LIST
44460: PUSH
44461: LD_INT 2
44463: PUSH
44464: LD_INT 0
44466: PUSH
44467: EMPTY
44468: LIST
44469: LIST
44470: PUSH
44471: LD_INT 2
44473: PUSH
44474: LD_INT 1
44476: PUSH
44477: EMPTY
44478: LIST
44479: LIST
44480: PUSH
44481: LD_INT 2
44483: PUSH
44484: LD_INT 2
44486: PUSH
44487: EMPTY
44488: LIST
44489: LIST
44490: PUSH
44491: LD_INT 1
44493: PUSH
44494: LD_INT 2
44496: PUSH
44497: EMPTY
44498: LIST
44499: LIST
44500: PUSH
44501: LD_INT 0
44503: PUSH
44504: LD_INT 2
44506: PUSH
44507: EMPTY
44508: LIST
44509: LIST
44510: PUSH
44511: LD_INT 1
44513: NEG
44514: PUSH
44515: LD_INT 1
44517: PUSH
44518: EMPTY
44519: LIST
44520: LIST
44521: PUSH
44522: LD_INT 2
44524: NEG
44525: PUSH
44526: LD_INT 0
44528: PUSH
44529: EMPTY
44530: LIST
44531: LIST
44532: PUSH
44533: LD_INT 2
44535: NEG
44536: PUSH
44537: LD_INT 1
44539: NEG
44540: PUSH
44541: EMPTY
44542: LIST
44543: LIST
44544: PUSH
44545: LD_INT 2
44547: NEG
44548: PUSH
44549: LD_INT 2
44551: NEG
44552: PUSH
44553: EMPTY
44554: LIST
44555: LIST
44556: PUSH
44557: EMPTY
44558: LIST
44559: LIST
44560: LIST
44561: LIST
44562: LIST
44563: LIST
44564: LIST
44565: LIST
44566: LIST
44567: LIST
44568: LIST
44569: LIST
44570: LIST
44571: LIST
44572: LIST
44573: LIST
44574: LIST
44575: LIST
44576: LIST
44577: ST_TO_ADDR
// fBunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
44578: LD_ADDR_VAR 0 59
44582: PUSH
44583: LD_INT 0
44585: PUSH
44586: LD_INT 0
44588: PUSH
44589: EMPTY
44590: LIST
44591: LIST
44592: PUSH
44593: LD_INT 0
44595: PUSH
44596: LD_INT 1
44598: NEG
44599: PUSH
44600: EMPTY
44601: LIST
44602: LIST
44603: PUSH
44604: LD_INT 1
44606: PUSH
44607: LD_INT 0
44609: PUSH
44610: EMPTY
44611: LIST
44612: LIST
44613: PUSH
44614: LD_INT 1
44616: PUSH
44617: LD_INT 1
44619: PUSH
44620: EMPTY
44621: LIST
44622: LIST
44623: PUSH
44624: LD_INT 0
44626: PUSH
44627: LD_INT 1
44629: PUSH
44630: EMPTY
44631: LIST
44632: LIST
44633: PUSH
44634: LD_INT 1
44636: NEG
44637: PUSH
44638: LD_INT 0
44640: PUSH
44641: EMPTY
44642: LIST
44643: LIST
44644: PUSH
44645: LD_INT 1
44647: NEG
44648: PUSH
44649: LD_INT 1
44651: NEG
44652: PUSH
44653: EMPTY
44654: LIST
44655: LIST
44656: PUSH
44657: EMPTY
44658: LIST
44659: LIST
44660: LIST
44661: LIST
44662: LIST
44663: LIST
44664: LIST
44665: ST_TO_ADDR
// fBunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
44666: LD_ADDR_VAR 0 60
44670: PUSH
44671: LD_INT 0
44673: PUSH
44674: LD_INT 0
44676: PUSH
44677: EMPTY
44678: LIST
44679: LIST
44680: PUSH
44681: LD_INT 0
44683: PUSH
44684: LD_INT 1
44686: NEG
44687: PUSH
44688: EMPTY
44689: LIST
44690: LIST
44691: PUSH
44692: LD_INT 1
44694: PUSH
44695: LD_INT 0
44697: PUSH
44698: EMPTY
44699: LIST
44700: LIST
44701: PUSH
44702: LD_INT 1
44704: PUSH
44705: LD_INT 1
44707: PUSH
44708: EMPTY
44709: LIST
44710: LIST
44711: PUSH
44712: LD_INT 0
44714: PUSH
44715: LD_INT 1
44717: PUSH
44718: EMPTY
44719: LIST
44720: LIST
44721: PUSH
44722: LD_INT 1
44724: NEG
44725: PUSH
44726: LD_INT 0
44728: PUSH
44729: EMPTY
44730: LIST
44731: LIST
44732: PUSH
44733: LD_INT 1
44735: NEG
44736: PUSH
44737: LD_INT 1
44739: NEG
44740: PUSH
44741: EMPTY
44742: LIST
44743: LIST
44744: PUSH
44745: EMPTY
44746: LIST
44747: LIST
44748: LIST
44749: LIST
44750: LIST
44751: LIST
44752: LIST
44753: ST_TO_ADDR
// fBunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
44754: LD_ADDR_VAR 0 61
44758: PUSH
44759: LD_INT 0
44761: PUSH
44762: LD_INT 0
44764: PUSH
44765: EMPTY
44766: LIST
44767: LIST
44768: PUSH
44769: LD_INT 0
44771: PUSH
44772: LD_INT 1
44774: NEG
44775: PUSH
44776: EMPTY
44777: LIST
44778: LIST
44779: PUSH
44780: LD_INT 1
44782: PUSH
44783: LD_INT 0
44785: PUSH
44786: EMPTY
44787: LIST
44788: LIST
44789: PUSH
44790: LD_INT 1
44792: PUSH
44793: LD_INT 1
44795: PUSH
44796: EMPTY
44797: LIST
44798: LIST
44799: PUSH
44800: LD_INT 0
44802: PUSH
44803: LD_INT 1
44805: PUSH
44806: EMPTY
44807: LIST
44808: LIST
44809: PUSH
44810: LD_INT 1
44812: NEG
44813: PUSH
44814: LD_INT 0
44816: PUSH
44817: EMPTY
44818: LIST
44819: LIST
44820: PUSH
44821: LD_INT 1
44823: NEG
44824: PUSH
44825: LD_INT 1
44827: NEG
44828: PUSH
44829: EMPTY
44830: LIST
44831: LIST
44832: PUSH
44833: EMPTY
44834: LIST
44835: LIST
44836: LIST
44837: LIST
44838: LIST
44839: LIST
44840: LIST
44841: ST_TO_ADDR
// fBunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
44842: LD_ADDR_VAR 0 62
44846: PUSH
44847: LD_INT 0
44849: PUSH
44850: LD_INT 0
44852: PUSH
44853: EMPTY
44854: LIST
44855: LIST
44856: PUSH
44857: LD_INT 0
44859: PUSH
44860: LD_INT 1
44862: NEG
44863: PUSH
44864: EMPTY
44865: LIST
44866: LIST
44867: PUSH
44868: LD_INT 1
44870: PUSH
44871: LD_INT 0
44873: PUSH
44874: EMPTY
44875: LIST
44876: LIST
44877: PUSH
44878: LD_INT 1
44880: PUSH
44881: LD_INT 1
44883: PUSH
44884: EMPTY
44885: LIST
44886: LIST
44887: PUSH
44888: LD_INT 0
44890: PUSH
44891: LD_INT 1
44893: PUSH
44894: EMPTY
44895: LIST
44896: LIST
44897: PUSH
44898: LD_INT 1
44900: NEG
44901: PUSH
44902: LD_INT 0
44904: PUSH
44905: EMPTY
44906: LIST
44907: LIST
44908: PUSH
44909: LD_INT 1
44911: NEG
44912: PUSH
44913: LD_INT 1
44915: NEG
44916: PUSH
44917: EMPTY
44918: LIST
44919: LIST
44920: PUSH
44921: EMPTY
44922: LIST
44923: LIST
44924: LIST
44925: LIST
44926: LIST
44927: LIST
44928: LIST
44929: ST_TO_ADDR
// fBunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
44930: LD_ADDR_VAR 0 63
44934: PUSH
44935: LD_INT 0
44937: PUSH
44938: LD_INT 0
44940: PUSH
44941: EMPTY
44942: LIST
44943: LIST
44944: PUSH
44945: LD_INT 0
44947: PUSH
44948: LD_INT 1
44950: NEG
44951: PUSH
44952: EMPTY
44953: LIST
44954: LIST
44955: PUSH
44956: LD_INT 1
44958: PUSH
44959: LD_INT 0
44961: PUSH
44962: EMPTY
44963: LIST
44964: LIST
44965: PUSH
44966: LD_INT 1
44968: PUSH
44969: LD_INT 1
44971: PUSH
44972: EMPTY
44973: LIST
44974: LIST
44975: PUSH
44976: LD_INT 0
44978: PUSH
44979: LD_INT 1
44981: PUSH
44982: EMPTY
44983: LIST
44984: LIST
44985: PUSH
44986: LD_INT 1
44988: NEG
44989: PUSH
44990: LD_INT 0
44992: PUSH
44993: EMPTY
44994: LIST
44995: LIST
44996: PUSH
44997: LD_INT 1
44999: NEG
45000: PUSH
45001: LD_INT 1
45003: NEG
45004: PUSH
45005: EMPTY
45006: LIST
45007: LIST
45008: PUSH
45009: EMPTY
45010: LIST
45011: LIST
45012: LIST
45013: LIST
45014: LIST
45015: LIST
45016: LIST
45017: ST_TO_ADDR
// fBunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
45018: LD_ADDR_VAR 0 64
45022: PUSH
45023: LD_INT 0
45025: PUSH
45026: LD_INT 0
45028: PUSH
45029: EMPTY
45030: LIST
45031: LIST
45032: PUSH
45033: LD_INT 0
45035: PUSH
45036: LD_INT 1
45038: NEG
45039: PUSH
45040: EMPTY
45041: LIST
45042: LIST
45043: PUSH
45044: LD_INT 1
45046: PUSH
45047: LD_INT 0
45049: PUSH
45050: EMPTY
45051: LIST
45052: LIST
45053: PUSH
45054: LD_INT 1
45056: PUSH
45057: LD_INT 1
45059: PUSH
45060: EMPTY
45061: LIST
45062: LIST
45063: PUSH
45064: LD_INT 0
45066: PUSH
45067: LD_INT 1
45069: PUSH
45070: EMPTY
45071: LIST
45072: LIST
45073: PUSH
45074: LD_INT 1
45076: NEG
45077: PUSH
45078: LD_INT 0
45080: PUSH
45081: EMPTY
45082: LIST
45083: LIST
45084: PUSH
45085: LD_INT 1
45087: NEG
45088: PUSH
45089: LD_INT 1
45091: NEG
45092: PUSH
45093: EMPTY
45094: LIST
45095: LIST
45096: PUSH
45097: EMPTY
45098: LIST
45099: LIST
45100: LIST
45101: LIST
45102: LIST
45103: LIST
45104: LIST
45105: ST_TO_ADDR
// end ; 1 :
45106: GO 51003
45108: LD_INT 1
45110: DOUBLE
45111: EQUAL
45112: IFTRUE 45116
45114: GO 47739
45116: POP
// begin fDepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
45117: LD_ADDR_VAR 0 11
45121: PUSH
45122: LD_INT 1
45124: NEG
45125: PUSH
45126: LD_INT 3
45128: NEG
45129: PUSH
45130: EMPTY
45131: LIST
45132: LIST
45133: PUSH
45134: LD_INT 0
45136: PUSH
45137: LD_INT 3
45139: NEG
45140: PUSH
45141: EMPTY
45142: LIST
45143: LIST
45144: PUSH
45145: LD_INT 1
45147: PUSH
45148: LD_INT 2
45150: NEG
45151: PUSH
45152: EMPTY
45153: LIST
45154: LIST
45155: PUSH
45156: EMPTY
45157: LIST
45158: LIST
45159: LIST
45160: ST_TO_ADDR
// fDepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
45161: LD_ADDR_VAR 0 12
45165: PUSH
45166: LD_INT 2
45168: PUSH
45169: LD_INT 1
45171: NEG
45172: PUSH
45173: EMPTY
45174: LIST
45175: LIST
45176: PUSH
45177: LD_INT 3
45179: PUSH
45180: LD_INT 0
45182: PUSH
45183: EMPTY
45184: LIST
45185: LIST
45186: PUSH
45187: LD_INT 3
45189: PUSH
45190: LD_INT 1
45192: PUSH
45193: EMPTY
45194: LIST
45195: LIST
45196: PUSH
45197: EMPTY
45198: LIST
45199: LIST
45200: LIST
45201: ST_TO_ADDR
// fDepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
45202: LD_ADDR_VAR 0 13
45206: PUSH
45207: LD_INT 3
45209: PUSH
45210: LD_INT 2
45212: PUSH
45213: EMPTY
45214: LIST
45215: LIST
45216: PUSH
45217: LD_INT 3
45219: PUSH
45220: LD_INT 3
45222: PUSH
45223: EMPTY
45224: LIST
45225: LIST
45226: PUSH
45227: LD_INT 2
45229: PUSH
45230: LD_INT 3
45232: PUSH
45233: EMPTY
45234: LIST
45235: LIST
45236: PUSH
45237: EMPTY
45238: LIST
45239: LIST
45240: LIST
45241: ST_TO_ADDR
// fDepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
45242: LD_ADDR_VAR 0 14
45246: PUSH
45247: LD_INT 1
45249: PUSH
45250: LD_INT 3
45252: PUSH
45253: EMPTY
45254: LIST
45255: LIST
45256: PUSH
45257: LD_INT 0
45259: PUSH
45260: LD_INT 3
45262: PUSH
45263: EMPTY
45264: LIST
45265: LIST
45266: PUSH
45267: LD_INT 1
45269: NEG
45270: PUSH
45271: LD_INT 2
45273: PUSH
45274: EMPTY
45275: LIST
45276: LIST
45277: PUSH
45278: EMPTY
45279: LIST
45280: LIST
45281: LIST
45282: ST_TO_ADDR
// fDepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
45283: LD_ADDR_VAR 0 15
45287: PUSH
45288: LD_INT 2
45290: NEG
45291: PUSH
45292: LD_INT 1
45294: PUSH
45295: EMPTY
45296: LIST
45297: LIST
45298: PUSH
45299: LD_INT 3
45301: NEG
45302: PUSH
45303: LD_INT 0
45305: PUSH
45306: EMPTY
45307: LIST
45308: LIST
45309: PUSH
45310: LD_INT 3
45312: NEG
45313: PUSH
45314: LD_INT 1
45316: NEG
45317: PUSH
45318: EMPTY
45319: LIST
45320: LIST
45321: PUSH
45322: EMPTY
45323: LIST
45324: LIST
45325: LIST
45326: ST_TO_ADDR
// fDepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
45327: LD_ADDR_VAR 0 16
45331: PUSH
45332: LD_INT 2
45334: NEG
45335: PUSH
45336: LD_INT 3
45338: NEG
45339: PUSH
45340: EMPTY
45341: LIST
45342: LIST
45343: PUSH
45344: LD_INT 3
45346: NEG
45347: PUSH
45348: LD_INT 2
45350: NEG
45351: PUSH
45352: EMPTY
45353: LIST
45354: LIST
45355: PUSH
45356: LD_INT 3
45358: NEG
45359: PUSH
45360: LD_INT 3
45362: NEG
45363: PUSH
45364: EMPTY
45365: LIST
45366: LIST
45367: PUSH
45368: EMPTY
45369: LIST
45370: LIST
45371: LIST
45372: ST_TO_ADDR
// fDepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
45373: LD_ADDR_VAR 0 17
45377: PUSH
45378: LD_INT 1
45380: NEG
45381: PUSH
45382: LD_INT 3
45384: NEG
45385: PUSH
45386: EMPTY
45387: LIST
45388: LIST
45389: PUSH
45390: LD_INT 0
45392: PUSH
45393: LD_INT 3
45395: NEG
45396: PUSH
45397: EMPTY
45398: LIST
45399: LIST
45400: PUSH
45401: LD_INT 1
45403: PUSH
45404: LD_INT 2
45406: NEG
45407: PUSH
45408: EMPTY
45409: LIST
45410: LIST
45411: PUSH
45412: EMPTY
45413: LIST
45414: LIST
45415: LIST
45416: ST_TO_ADDR
// fDepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
45417: LD_ADDR_VAR 0 18
45421: PUSH
45422: LD_INT 2
45424: PUSH
45425: LD_INT 1
45427: NEG
45428: PUSH
45429: EMPTY
45430: LIST
45431: LIST
45432: PUSH
45433: LD_INT 3
45435: PUSH
45436: LD_INT 0
45438: PUSH
45439: EMPTY
45440: LIST
45441: LIST
45442: PUSH
45443: LD_INT 3
45445: PUSH
45446: LD_INT 1
45448: PUSH
45449: EMPTY
45450: LIST
45451: LIST
45452: PUSH
45453: EMPTY
45454: LIST
45455: LIST
45456: LIST
45457: ST_TO_ADDR
// fDepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
45458: LD_ADDR_VAR 0 19
45462: PUSH
45463: LD_INT 3
45465: PUSH
45466: LD_INT 2
45468: PUSH
45469: EMPTY
45470: LIST
45471: LIST
45472: PUSH
45473: LD_INT 3
45475: PUSH
45476: LD_INT 3
45478: PUSH
45479: EMPTY
45480: LIST
45481: LIST
45482: PUSH
45483: LD_INT 2
45485: PUSH
45486: LD_INT 3
45488: PUSH
45489: EMPTY
45490: LIST
45491: LIST
45492: PUSH
45493: EMPTY
45494: LIST
45495: LIST
45496: LIST
45497: ST_TO_ADDR
// fDepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
45498: LD_ADDR_VAR 0 20
45502: PUSH
45503: LD_INT 1
45505: PUSH
45506: LD_INT 3
45508: PUSH
45509: EMPTY
45510: LIST
45511: LIST
45512: PUSH
45513: LD_INT 0
45515: PUSH
45516: LD_INT 3
45518: PUSH
45519: EMPTY
45520: LIST
45521: LIST
45522: PUSH
45523: LD_INT 1
45525: NEG
45526: PUSH
45527: LD_INT 2
45529: PUSH
45530: EMPTY
45531: LIST
45532: LIST
45533: PUSH
45534: EMPTY
45535: LIST
45536: LIST
45537: LIST
45538: ST_TO_ADDR
// fDepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
45539: LD_ADDR_VAR 0 21
45543: PUSH
45544: LD_INT 2
45546: NEG
45547: PUSH
45548: LD_INT 1
45550: PUSH
45551: EMPTY
45552: LIST
45553: LIST
45554: PUSH
45555: LD_INT 3
45557: NEG
45558: PUSH
45559: LD_INT 0
45561: PUSH
45562: EMPTY
45563: LIST
45564: LIST
45565: PUSH
45566: LD_INT 3
45568: NEG
45569: PUSH
45570: LD_INT 1
45572: NEG
45573: PUSH
45574: EMPTY
45575: LIST
45576: LIST
45577: PUSH
45578: EMPTY
45579: LIST
45580: LIST
45581: LIST
45582: ST_TO_ADDR
// fDepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
45583: LD_ADDR_VAR 0 22
45587: PUSH
45588: LD_INT 2
45590: NEG
45591: PUSH
45592: LD_INT 3
45594: NEG
45595: PUSH
45596: EMPTY
45597: LIST
45598: LIST
45599: PUSH
45600: LD_INT 3
45602: NEG
45603: PUSH
45604: LD_INT 2
45606: NEG
45607: PUSH
45608: EMPTY
45609: LIST
45610: LIST
45611: PUSH
45612: LD_INT 3
45614: NEG
45615: PUSH
45616: LD_INT 3
45618: NEG
45619: PUSH
45620: EMPTY
45621: LIST
45622: LIST
45623: PUSH
45624: EMPTY
45625: LIST
45626: LIST
45627: LIST
45628: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
45629: LD_ADDR_VAR 0 23
45633: PUSH
45634: LD_INT 0
45636: PUSH
45637: LD_INT 3
45639: NEG
45640: PUSH
45641: EMPTY
45642: LIST
45643: LIST
45644: PUSH
45645: LD_INT 1
45647: NEG
45648: PUSH
45649: LD_INT 4
45651: NEG
45652: PUSH
45653: EMPTY
45654: LIST
45655: LIST
45656: PUSH
45657: LD_INT 1
45659: PUSH
45660: LD_INT 3
45662: NEG
45663: PUSH
45664: EMPTY
45665: LIST
45666: LIST
45667: PUSH
45668: EMPTY
45669: LIST
45670: LIST
45671: LIST
45672: ST_TO_ADDR
// fDepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
45673: LD_ADDR_VAR 0 24
45677: PUSH
45678: LD_INT 3
45680: PUSH
45681: LD_INT 0
45683: PUSH
45684: EMPTY
45685: LIST
45686: LIST
45687: PUSH
45688: LD_INT 3
45690: PUSH
45691: LD_INT 1
45693: NEG
45694: PUSH
45695: EMPTY
45696: LIST
45697: LIST
45698: PUSH
45699: LD_INT 4
45701: PUSH
45702: LD_INT 1
45704: PUSH
45705: EMPTY
45706: LIST
45707: LIST
45708: PUSH
45709: EMPTY
45710: LIST
45711: LIST
45712: LIST
45713: ST_TO_ADDR
// fDepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
45714: LD_ADDR_VAR 0 25
45718: PUSH
45719: LD_INT 3
45721: PUSH
45722: LD_INT 3
45724: PUSH
45725: EMPTY
45726: LIST
45727: LIST
45728: PUSH
45729: LD_INT 4
45731: PUSH
45732: LD_INT 3
45734: PUSH
45735: EMPTY
45736: LIST
45737: LIST
45738: PUSH
45739: LD_INT 3
45741: PUSH
45742: LD_INT 4
45744: PUSH
45745: EMPTY
45746: LIST
45747: LIST
45748: PUSH
45749: EMPTY
45750: LIST
45751: LIST
45752: LIST
45753: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
45754: LD_ADDR_VAR 0 26
45758: PUSH
45759: LD_INT 0
45761: PUSH
45762: LD_INT 3
45764: PUSH
45765: EMPTY
45766: LIST
45767: LIST
45768: PUSH
45769: LD_INT 1
45771: PUSH
45772: LD_INT 4
45774: PUSH
45775: EMPTY
45776: LIST
45777: LIST
45778: PUSH
45779: LD_INT 1
45781: NEG
45782: PUSH
45783: LD_INT 3
45785: PUSH
45786: EMPTY
45787: LIST
45788: LIST
45789: PUSH
45790: EMPTY
45791: LIST
45792: LIST
45793: LIST
45794: ST_TO_ADDR
// fDepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
45795: LD_ADDR_VAR 0 27
45799: PUSH
45800: LD_INT 3
45802: NEG
45803: PUSH
45804: LD_INT 0
45806: PUSH
45807: EMPTY
45808: LIST
45809: LIST
45810: PUSH
45811: LD_INT 3
45813: NEG
45814: PUSH
45815: LD_INT 1
45817: PUSH
45818: EMPTY
45819: LIST
45820: LIST
45821: PUSH
45822: LD_INT 4
45824: NEG
45825: PUSH
45826: LD_INT 1
45828: NEG
45829: PUSH
45830: EMPTY
45831: LIST
45832: LIST
45833: PUSH
45834: EMPTY
45835: LIST
45836: LIST
45837: LIST
45838: ST_TO_ADDR
// fDepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
45839: LD_ADDR_VAR 0 28
45843: PUSH
45844: LD_INT 3
45846: NEG
45847: PUSH
45848: LD_INT 3
45850: NEG
45851: PUSH
45852: EMPTY
45853: LIST
45854: LIST
45855: PUSH
45856: LD_INT 3
45858: NEG
45859: PUSH
45860: LD_INT 4
45862: NEG
45863: PUSH
45864: EMPTY
45865: LIST
45866: LIST
45867: PUSH
45868: LD_INT 4
45870: NEG
45871: PUSH
45872: LD_INT 3
45874: NEG
45875: PUSH
45876: EMPTY
45877: LIST
45878: LIST
45879: PUSH
45880: EMPTY
45881: LIST
45882: LIST
45883: LIST
45884: ST_TO_ADDR
// fFactory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
45885: LD_ADDR_VAR 0 29
45889: PUSH
45890: LD_INT 1
45892: NEG
45893: PUSH
45894: LD_INT 3
45896: NEG
45897: PUSH
45898: EMPTY
45899: LIST
45900: LIST
45901: PUSH
45902: LD_INT 0
45904: PUSH
45905: LD_INT 3
45907: NEG
45908: PUSH
45909: EMPTY
45910: LIST
45911: LIST
45912: PUSH
45913: LD_INT 1
45915: PUSH
45916: LD_INT 2
45918: NEG
45919: PUSH
45920: EMPTY
45921: LIST
45922: LIST
45923: PUSH
45924: LD_INT 1
45926: NEG
45927: PUSH
45928: LD_INT 4
45930: NEG
45931: PUSH
45932: EMPTY
45933: LIST
45934: LIST
45935: PUSH
45936: LD_INT 0
45938: PUSH
45939: LD_INT 4
45941: NEG
45942: PUSH
45943: EMPTY
45944: LIST
45945: LIST
45946: PUSH
45947: LD_INT 1
45949: PUSH
45950: LD_INT 3
45952: NEG
45953: PUSH
45954: EMPTY
45955: LIST
45956: LIST
45957: PUSH
45958: LD_INT 1
45960: NEG
45961: PUSH
45962: LD_INT 5
45964: NEG
45965: PUSH
45966: EMPTY
45967: LIST
45968: LIST
45969: PUSH
45970: LD_INT 0
45972: PUSH
45973: LD_INT 5
45975: NEG
45976: PUSH
45977: EMPTY
45978: LIST
45979: LIST
45980: PUSH
45981: LD_INT 1
45983: PUSH
45984: LD_INT 4
45986: NEG
45987: PUSH
45988: EMPTY
45989: LIST
45990: LIST
45991: PUSH
45992: LD_INT 1
45994: NEG
45995: PUSH
45996: LD_INT 6
45998: NEG
45999: PUSH
46000: EMPTY
46001: LIST
46002: LIST
46003: PUSH
46004: LD_INT 0
46006: PUSH
46007: LD_INT 6
46009: NEG
46010: PUSH
46011: EMPTY
46012: LIST
46013: LIST
46014: PUSH
46015: LD_INT 1
46017: PUSH
46018: LD_INT 5
46020: NEG
46021: PUSH
46022: EMPTY
46023: LIST
46024: LIST
46025: PUSH
46026: EMPTY
46027: LIST
46028: LIST
46029: LIST
46030: LIST
46031: LIST
46032: LIST
46033: LIST
46034: LIST
46035: LIST
46036: LIST
46037: LIST
46038: LIST
46039: ST_TO_ADDR
// fFactory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
46040: LD_ADDR_VAR 0 30
46044: PUSH
46045: LD_INT 2
46047: PUSH
46048: LD_INT 1
46050: NEG
46051: PUSH
46052: EMPTY
46053: LIST
46054: LIST
46055: PUSH
46056: LD_INT 3
46058: PUSH
46059: LD_INT 0
46061: PUSH
46062: EMPTY
46063: LIST
46064: LIST
46065: PUSH
46066: LD_INT 3
46068: PUSH
46069: LD_INT 1
46071: PUSH
46072: EMPTY
46073: LIST
46074: LIST
46075: PUSH
46076: LD_INT 3
46078: PUSH
46079: LD_INT 1
46081: NEG
46082: PUSH
46083: EMPTY
46084: LIST
46085: LIST
46086: PUSH
46087: LD_INT 4
46089: PUSH
46090: LD_INT 0
46092: PUSH
46093: EMPTY
46094: LIST
46095: LIST
46096: PUSH
46097: LD_INT 4
46099: PUSH
46100: LD_INT 1
46102: PUSH
46103: EMPTY
46104: LIST
46105: LIST
46106: PUSH
46107: LD_INT 4
46109: PUSH
46110: LD_INT 1
46112: NEG
46113: PUSH
46114: EMPTY
46115: LIST
46116: LIST
46117: PUSH
46118: LD_INT 5
46120: PUSH
46121: LD_INT 0
46123: PUSH
46124: EMPTY
46125: LIST
46126: LIST
46127: PUSH
46128: LD_INT 5
46130: PUSH
46131: LD_INT 1
46133: PUSH
46134: EMPTY
46135: LIST
46136: LIST
46137: PUSH
46138: LD_INT 5
46140: PUSH
46141: LD_INT 1
46143: NEG
46144: PUSH
46145: EMPTY
46146: LIST
46147: LIST
46148: PUSH
46149: LD_INT 6
46151: PUSH
46152: LD_INT 0
46154: PUSH
46155: EMPTY
46156: LIST
46157: LIST
46158: PUSH
46159: LD_INT 6
46161: PUSH
46162: LD_INT 1
46164: PUSH
46165: EMPTY
46166: LIST
46167: LIST
46168: PUSH
46169: EMPTY
46170: LIST
46171: LIST
46172: LIST
46173: LIST
46174: LIST
46175: LIST
46176: LIST
46177: LIST
46178: LIST
46179: LIST
46180: LIST
46181: LIST
46182: ST_TO_ADDR
// fFactory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
46183: LD_ADDR_VAR 0 31
46187: PUSH
46188: LD_INT 3
46190: PUSH
46191: LD_INT 2
46193: PUSH
46194: EMPTY
46195: LIST
46196: LIST
46197: PUSH
46198: LD_INT 3
46200: PUSH
46201: LD_INT 3
46203: PUSH
46204: EMPTY
46205: LIST
46206: LIST
46207: PUSH
46208: LD_INT 2
46210: PUSH
46211: LD_INT 3
46213: PUSH
46214: EMPTY
46215: LIST
46216: LIST
46217: PUSH
46218: LD_INT 4
46220: PUSH
46221: LD_INT 3
46223: PUSH
46224: EMPTY
46225: LIST
46226: LIST
46227: PUSH
46228: LD_INT 4
46230: PUSH
46231: LD_INT 4
46233: PUSH
46234: EMPTY
46235: LIST
46236: LIST
46237: PUSH
46238: LD_INT 3
46240: PUSH
46241: LD_INT 4
46243: PUSH
46244: EMPTY
46245: LIST
46246: LIST
46247: PUSH
46248: LD_INT 5
46250: PUSH
46251: LD_INT 4
46253: PUSH
46254: EMPTY
46255: LIST
46256: LIST
46257: PUSH
46258: LD_INT 5
46260: PUSH
46261: LD_INT 5
46263: PUSH
46264: EMPTY
46265: LIST
46266: LIST
46267: PUSH
46268: LD_INT 4
46270: PUSH
46271: LD_INT 5
46273: PUSH
46274: EMPTY
46275: LIST
46276: LIST
46277: PUSH
46278: LD_INT 6
46280: PUSH
46281: LD_INT 5
46283: PUSH
46284: EMPTY
46285: LIST
46286: LIST
46287: PUSH
46288: LD_INT 6
46290: PUSH
46291: LD_INT 6
46293: PUSH
46294: EMPTY
46295: LIST
46296: LIST
46297: PUSH
46298: LD_INT 5
46300: PUSH
46301: LD_INT 6
46303: PUSH
46304: EMPTY
46305: LIST
46306: LIST
46307: PUSH
46308: EMPTY
46309: LIST
46310: LIST
46311: LIST
46312: LIST
46313: LIST
46314: LIST
46315: LIST
46316: LIST
46317: LIST
46318: LIST
46319: LIST
46320: LIST
46321: ST_TO_ADDR
// fFactory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
46322: LD_ADDR_VAR 0 32
46326: PUSH
46327: LD_INT 1
46329: PUSH
46330: LD_INT 3
46332: PUSH
46333: EMPTY
46334: LIST
46335: LIST
46336: PUSH
46337: LD_INT 0
46339: PUSH
46340: LD_INT 3
46342: PUSH
46343: EMPTY
46344: LIST
46345: LIST
46346: PUSH
46347: LD_INT 1
46349: NEG
46350: PUSH
46351: LD_INT 2
46353: PUSH
46354: EMPTY
46355: LIST
46356: LIST
46357: PUSH
46358: LD_INT 1
46360: PUSH
46361: LD_INT 4
46363: PUSH
46364: EMPTY
46365: LIST
46366: LIST
46367: PUSH
46368: LD_INT 0
46370: PUSH
46371: LD_INT 4
46373: PUSH
46374: EMPTY
46375: LIST
46376: LIST
46377: PUSH
46378: LD_INT 1
46380: NEG
46381: PUSH
46382: LD_INT 3
46384: PUSH
46385: EMPTY
46386: LIST
46387: LIST
46388: PUSH
46389: LD_INT 1
46391: PUSH
46392: LD_INT 5
46394: PUSH
46395: EMPTY
46396: LIST
46397: LIST
46398: PUSH
46399: LD_INT 0
46401: PUSH
46402: LD_INT 5
46404: PUSH
46405: EMPTY
46406: LIST
46407: LIST
46408: PUSH
46409: LD_INT 1
46411: NEG
46412: PUSH
46413: LD_INT 4
46415: PUSH
46416: EMPTY
46417: LIST
46418: LIST
46419: PUSH
46420: LD_INT 1
46422: PUSH
46423: LD_INT 6
46425: PUSH
46426: EMPTY
46427: LIST
46428: LIST
46429: PUSH
46430: LD_INT 0
46432: PUSH
46433: LD_INT 6
46435: PUSH
46436: EMPTY
46437: LIST
46438: LIST
46439: PUSH
46440: LD_INT 1
46442: NEG
46443: PUSH
46444: LD_INT 5
46446: PUSH
46447: EMPTY
46448: LIST
46449: LIST
46450: PUSH
46451: EMPTY
46452: LIST
46453: LIST
46454: LIST
46455: LIST
46456: LIST
46457: LIST
46458: LIST
46459: LIST
46460: LIST
46461: LIST
46462: LIST
46463: LIST
46464: ST_TO_ADDR
// fFactory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
46465: LD_ADDR_VAR 0 33
46469: PUSH
46470: LD_INT 2
46472: NEG
46473: PUSH
46474: LD_INT 1
46476: PUSH
46477: EMPTY
46478: LIST
46479: LIST
46480: PUSH
46481: LD_INT 3
46483: NEG
46484: PUSH
46485: LD_INT 0
46487: PUSH
46488: EMPTY
46489: LIST
46490: LIST
46491: PUSH
46492: LD_INT 3
46494: NEG
46495: PUSH
46496: LD_INT 1
46498: NEG
46499: PUSH
46500: EMPTY
46501: LIST
46502: LIST
46503: PUSH
46504: LD_INT 3
46506: NEG
46507: PUSH
46508: LD_INT 1
46510: PUSH
46511: EMPTY
46512: LIST
46513: LIST
46514: PUSH
46515: LD_INT 4
46517: NEG
46518: PUSH
46519: LD_INT 0
46521: PUSH
46522: EMPTY
46523: LIST
46524: LIST
46525: PUSH
46526: LD_INT 4
46528: NEG
46529: PUSH
46530: LD_INT 1
46532: NEG
46533: PUSH
46534: EMPTY
46535: LIST
46536: LIST
46537: PUSH
46538: LD_INT 4
46540: NEG
46541: PUSH
46542: LD_INT 1
46544: PUSH
46545: EMPTY
46546: LIST
46547: LIST
46548: PUSH
46549: LD_INT 5
46551: NEG
46552: PUSH
46553: LD_INT 0
46555: PUSH
46556: EMPTY
46557: LIST
46558: LIST
46559: PUSH
46560: LD_INT 5
46562: NEG
46563: PUSH
46564: LD_INT 1
46566: NEG
46567: PUSH
46568: EMPTY
46569: LIST
46570: LIST
46571: PUSH
46572: LD_INT 5
46574: NEG
46575: PUSH
46576: LD_INT 1
46578: PUSH
46579: EMPTY
46580: LIST
46581: LIST
46582: PUSH
46583: LD_INT 6
46585: NEG
46586: PUSH
46587: LD_INT 0
46589: PUSH
46590: EMPTY
46591: LIST
46592: LIST
46593: PUSH
46594: LD_INT 6
46596: NEG
46597: PUSH
46598: LD_INT 1
46600: NEG
46601: PUSH
46602: EMPTY
46603: LIST
46604: LIST
46605: PUSH
46606: EMPTY
46607: LIST
46608: LIST
46609: LIST
46610: LIST
46611: LIST
46612: LIST
46613: LIST
46614: LIST
46615: LIST
46616: LIST
46617: LIST
46618: LIST
46619: ST_TO_ADDR
// fFactory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
46620: LD_ADDR_VAR 0 34
46624: PUSH
46625: LD_INT 2
46627: NEG
46628: PUSH
46629: LD_INT 3
46631: NEG
46632: PUSH
46633: EMPTY
46634: LIST
46635: LIST
46636: PUSH
46637: LD_INT 3
46639: NEG
46640: PUSH
46641: LD_INT 2
46643: NEG
46644: PUSH
46645: EMPTY
46646: LIST
46647: LIST
46648: PUSH
46649: LD_INT 3
46651: NEG
46652: PUSH
46653: LD_INT 3
46655: NEG
46656: PUSH
46657: EMPTY
46658: LIST
46659: LIST
46660: PUSH
46661: LD_INT 3
46663: NEG
46664: PUSH
46665: LD_INT 4
46667: NEG
46668: PUSH
46669: EMPTY
46670: LIST
46671: LIST
46672: PUSH
46673: LD_INT 4
46675: NEG
46676: PUSH
46677: LD_INT 3
46679: NEG
46680: PUSH
46681: EMPTY
46682: LIST
46683: LIST
46684: PUSH
46685: LD_INT 4
46687: NEG
46688: PUSH
46689: LD_INT 4
46691: NEG
46692: PUSH
46693: EMPTY
46694: LIST
46695: LIST
46696: PUSH
46697: LD_INT 4
46699: NEG
46700: PUSH
46701: LD_INT 5
46703: NEG
46704: PUSH
46705: EMPTY
46706: LIST
46707: LIST
46708: PUSH
46709: LD_INT 5
46711: NEG
46712: PUSH
46713: LD_INT 4
46715: NEG
46716: PUSH
46717: EMPTY
46718: LIST
46719: LIST
46720: PUSH
46721: LD_INT 5
46723: NEG
46724: PUSH
46725: LD_INT 5
46727: NEG
46728: PUSH
46729: EMPTY
46730: LIST
46731: LIST
46732: PUSH
46733: LD_INT 5
46735: NEG
46736: PUSH
46737: LD_INT 6
46739: NEG
46740: PUSH
46741: EMPTY
46742: LIST
46743: LIST
46744: PUSH
46745: LD_INT 6
46747: NEG
46748: PUSH
46749: LD_INT 5
46751: NEG
46752: PUSH
46753: EMPTY
46754: LIST
46755: LIST
46756: PUSH
46757: LD_INT 6
46759: NEG
46760: PUSH
46761: LD_INT 6
46763: NEG
46764: PUSH
46765: EMPTY
46766: LIST
46767: LIST
46768: PUSH
46769: EMPTY
46770: LIST
46771: LIST
46772: LIST
46773: LIST
46774: LIST
46775: LIST
46776: LIST
46777: LIST
46778: LIST
46779: LIST
46780: LIST
46781: LIST
46782: ST_TO_ADDR
// fLab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
46783: LD_ADDR_VAR 0 41
46787: PUSH
46788: LD_INT 0
46790: PUSH
46791: LD_INT 2
46793: NEG
46794: PUSH
46795: EMPTY
46796: LIST
46797: LIST
46798: PUSH
46799: LD_INT 1
46801: NEG
46802: PUSH
46803: LD_INT 3
46805: NEG
46806: PUSH
46807: EMPTY
46808: LIST
46809: LIST
46810: PUSH
46811: LD_INT 1
46813: PUSH
46814: LD_INT 2
46816: NEG
46817: PUSH
46818: EMPTY
46819: LIST
46820: LIST
46821: PUSH
46822: EMPTY
46823: LIST
46824: LIST
46825: LIST
46826: ST_TO_ADDR
// fLab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
46827: LD_ADDR_VAR 0 42
46831: PUSH
46832: LD_INT 2
46834: PUSH
46835: LD_INT 0
46837: PUSH
46838: EMPTY
46839: LIST
46840: LIST
46841: PUSH
46842: LD_INT 2
46844: PUSH
46845: LD_INT 1
46847: NEG
46848: PUSH
46849: EMPTY
46850: LIST
46851: LIST
46852: PUSH
46853: LD_INT 3
46855: PUSH
46856: LD_INT 1
46858: PUSH
46859: EMPTY
46860: LIST
46861: LIST
46862: PUSH
46863: EMPTY
46864: LIST
46865: LIST
46866: LIST
46867: ST_TO_ADDR
// fLab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
46868: LD_ADDR_VAR 0 43
46872: PUSH
46873: LD_INT 2
46875: PUSH
46876: LD_INT 2
46878: PUSH
46879: EMPTY
46880: LIST
46881: LIST
46882: PUSH
46883: LD_INT 3
46885: PUSH
46886: LD_INT 2
46888: PUSH
46889: EMPTY
46890: LIST
46891: LIST
46892: PUSH
46893: LD_INT 2
46895: PUSH
46896: LD_INT 3
46898: PUSH
46899: EMPTY
46900: LIST
46901: LIST
46902: PUSH
46903: EMPTY
46904: LIST
46905: LIST
46906: LIST
46907: ST_TO_ADDR
// fLab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
46908: LD_ADDR_VAR 0 44
46912: PUSH
46913: LD_INT 0
46915: PUSH
46916: LD_INT 2
46918: PUSH
46919: EMPTY
46920: LIST
46921: LIST
46922: PUSH
46923: LD_INT 1
46925: PUSH
46926: LD_INT 3
46928: PUSH
46929: EMPTY
46930: LIST
46931: LIST
46932: PUSH
46933: LD_INT 1
46935: NEG
46936: PUSH
46937: LD_INT 2
46939: PUSH
46940: EMPTY
46941: LIST
46942: LIST
46943: PUSH
46944: EMPTY
46945: LIST
46946: LIST
46947: LIST
46948: ST_TO_ADDR
// fLab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
46949: LD_ADDR_VAR 0 45
46953: PUSH
46954: LD_INT 2
46956: NEG
46957: PUSH
46958: LD_INT 0
46960: PUSH
46961: EMPTY
46962: LIST
46963: LIST
46964: PUSH
46965: LD_INT 2
46967: NEG
46968: PUSH
46969: LD_INT 1
46971: PUSH
46972: EMPTY
46973: LIST
46974: LIST
46975: PUSH
46976: LD_INT 3
46978: NEG
46979: PUSH
46980: LD_INT 1
46982: NEG
46983: PUSH
46984: EMPTY
46985: LIST
46986: LIST
46987: PUSH
46988: EMPTY
46989: LIST
46990: LIST
46991: LIST
46992: ST_TO_ADDR
// fLab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
46993: LD_ADDR_VAR 0 46
46997: PUSH
46998: LD_INT 2
47000: NEG
47001: PUSH
47002: LD_INT 2
47004: NEG
47005: PUSH
47006: EMPTY
47007: LIST
47008: LIST
47009: PUSH
47010: LD_INT 2
47012: NEG
47013: PUSH
47014: LD_INT 3
47016: NEG
47017: PUSH
47018: EMPTY
47019: LIST
47020: LIST
47021: PUSH
47022: LD_INT 3
47024: NEG
47025: PUSH
47026: LD_INT 2
47028: NEG
47029: PUSH
47030: EMPTY
47031: LIST
47032: LIST
47033: PUSH
47034: EMPTY
47035: LIST
47036: LIST
47037: LIST
47038: ST_TO_ADDR
// fControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
47039: LD_ADDR_VAR 0 47
47043: PUSH
47044: LD_INT 2
47046: NEG
47047: PUSH
47048: LD_INT 3
47050: NEG
47051: PUSH
47052: EMPTY
47053: LIST
47054: LIST
47055: PUSH
47056: LD_INT 1
47058: NEG
47059: PUSH
47060: LD_INT 3
47062: NEG
47063: PUSH
47064: EMPTY
47065: LIST
47066: LIST
47067: PUSH
47068: EMPTY
47069: LIST
47070: LIST
47071: ST_TO_ADDR
// fControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
47072: LD_ADDR_VAR 0 48
47076: PUSH
47077: LD_INT 1
47079: PUSH
47080: LD_INT 2
47082: NEG
47083: PUSH
47084: EMPTY
47085: LIST
47086: LIST
47087: PUSH
47088: LD_INT 2
47090: PUSH
47091: LD_INT 1
47093: NEG
47094: PUSH
47095: EMPTY
47096: LIST
47097: LIST
47098: PUSH
47099: EMPTY
47100: LIST
47101: LIST
47102: ST_TO_ADDR
// fControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
47103: LD_ADDR_VAR 0 49
47107: PUSH
47108: LD_INT 3
47110: PUSH
47111: LD_INT 1
47113: PUSH
47114: EMPTY
47115: LIST
47116: LIST
47117: PUSH
47118: LD_INT 3
47120: PUSH
47121: LD_INT 2
47123: PUSH
47124: EMPTY
47125: LIST
47126: LIST
47127: PUSH
47128: EMPTY
47129: LIST
47130: LIST
47131: ST_TO_ADDR
// fControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
47132: LD_ADDR_VAR 0 50
47136: PUSH
47137: LD_INT 2
47139: PUSH
47140: LD_INT 3
47142: PUSH
47143: EMPTY
47144: LIST
47145: LIST
47146: PUSH
47147: LD_INT 1
47149: PUSH
47150: LD_INT 3
47152: PUSH
47153: EMPTY
47154: LIST
47155: LIST
47156: PUSH
47157: EMPTY
47158: LIST
47159: LIST
47160: ST_TO_ADDR
// fControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
47161: LD_ADDR_VAR 0 51
47165: PUSH
47166: LD_INT 1
47168: NEG
47169: PUSH
47170: LD_INT 2
47172: PUSH
47173: EMPTY
47174: LIST
47175: LIST
47176: PUSH
47177: LD_INT 2
47179: NEG
47180: PUSH
47181: LD_INT 1
47183: PUSH
47184: EMPTY
47185: LIST
47186: LIST
47187: PUSH
47188: EMPTY
47189: LIST
47190: LIST
47191: ST_TO_ADDR
// fControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
47192: LD_ADDR_VAR 0 52
47196: PUSH
47197: LD_INT 3
47199: NEG
47200: PUSH
47201: LD_INT 1
47203: NEG
47204: PUSH
47205: EMPTY
47206: LIST
47207: LIST
47208: PUSH
47209: LD_INT 3
47211: NEG
47212: PUSH
47213: LD_INT 2
47215: NEG
47216: PUSH
47217: EMPTY
47218: LIST
47219: LIST
47220: PUSH
47221: EMPTY
47222: LIST
47223: LIST
47224: ST_TO_ADDR
// fBarracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
47225: LD_ADDR_VAR 0 53
47229: PUSH
47230: LD_INT 1
47232: NEG
47233: PUSH
47234: LD_INT 3
47236: NEG
47237: PUSH
47238: EMPTY
47239: LIST
47240: LIST
47241: PUSH
47242: LD_INT 0
47244: PUSH
47245: LD_INT 3
47247: NEG
47248: PUSH
47249: EMPTY
47250: LIST
47251: LIST
47252: PUSH
47253: LD_INT 1
47255: PUSH
47256: LD_INT 2
47258: NEG
47259: PUSH
47260: EMPTY
47261: LIST
47262: LIST
47263: PUSH
47264: EMPTY
47265: LIST
47266: LIST
47267: LIST
47268: ST_TO_ADDR
// fBarracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
47269: LD_ADDR_VAR 0 54
47273: PUSH
47274: LD_INT 2
47276: PUSH
47277: LD_INT 1
47279: NEG
47280: PUSH
47281: EMPTY
47282: LIST
47283: LIST
47284: PUSH
47285: LD_INT 3
47287: PUSH
47288: LD_INT 0
47290: PUSH
47291: EMPTY
47292: LIST
47293: LIST
47294: PUSH
47295: LD_INT 3
47297: PUSH
47298: LD_INT 1
47300: PUSH
47301: EMPTY
47302: LIST
47303: LIST
47304: PUSH
47305: EMPTY
47306: LIST
47307: LIST
47308: LIST
47309: ST_TO_ADDR
// fBarracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
47310: LD_ADDR_VAR 0 55
47314: PUSH
47315: LD_INT 3
47317: PUSH
47318: LD_INT 2
47320: PUSH
47321: EMPTY
47322: LIST
47323: LIST
47324: PUSH
47325: LD_INT 3
47327: PUSH
47328: LD_INT 3
47330: PUSH
47331: EMPTY
47332: LIST
47333: LIST
47334: PUSH
47335: LD_INT 2
47337: PUSH
47338: LD_INT 3
47340: PUSH
47341: EMPTY
47342: LIST
47343: LIST
47344: PUSH
47345: EMPTY
47346: LIST
47347: LIST
47348: LIST
47349: ST_TO_ADDR
// fBarracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
47350: LD_ADDR_VAR 0 56
47354: PUSH
47355: LD_INT 1
47357: PUSH
47358: LD_INT 3
47360: PUSH
47361: EMPTY
47362: LIST
47363: LIST
47364: PUSH
47365: LD_INT 0
47367: PUSH
47368: LD_INT 3
47370: PUSH
47371: EMPTY
47372: LIST
47373: LIST
47374: PUSH
47375: LD_INT 1
47377: NEG
47378: PUSH
47379: LD_INT 2
47381: PUSH
47382: EMPTY
47383: LIST
47384: LIST
47385: PUSH
47386: EMPTY
47387: LIST
47388: LIST
47389: LIST
47390: ST_TO_ADDR
// fBarracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
47391: LD_ADDR_VAR 0 57
47395: PUSH
47396: LD_INT 2
47398: NEG
47399: PUSH
47400: LD_INT 1
47402: PUSH
47403: EMPTY
47404: LIST
47405: LIST
47406: PUSH
47407: LD_INT 3
47409: NEG
47410: PUSH
47411: LD_INT 0
47413: PUSH
47414: EMPTY
47415: LIST
47416: LIST
47417: PUSH
47418: LD_INT 3
47420: NEG
47421: PUSH
47422: LD_INT 1
47424: NEG
47425: PUSH
47426: EMPTY
47427: LIST
47428: LIST
47429: PUSH
47430: EMPTY
47431: LIST
47432: LIST
47433: LIST
47434: ST_TO_ADDR
// fBarracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
47435: LD_ADDR_VAR 0 58
47439: PUSH
47440: LD_INT 2
47442: NEG
47443: PUSH
47444: LD_INT 3
47446: NEG
47447: PUSH
47448: EMPTY
47449: LIST
47450: LIST
47451: PUSH
47452: LD_INT 3
47454: NEG
47455: PUSH
47456: LD_INT 2
47458: NEG
47459: PUSH
47460: EMPTY
47461: LIST
47462: LIST
47463: PUSH
47464: LD_INT 3
47466: NEG
47467: PUSH
47468: LD_INT 3
47470: NEG
47471: PUSH
47472: EMPTY
47473: LIST
47474: LIST
47475: PUSH
47476: EMPTY
47477: LIST
47478: LIST
47479: LIST
47480: ST_TO_ADDR
// fBunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
47481: LD_ADDR_VAR 0 59
47485: PUSH
47486: LD_INT 1
47488: NEG
47489: PUSH
47490: LD_INT 2
47492: NEG
47493: PUSH
47494: EMPTY
47495: LIST
47496: LIST
47497: PUSH
47498: LD_INT 0
47500: PUSH
47501: LD_INT 2
47503: NEG
47504: PUSH
47505: EMPTY
47506: LIST
47507: LIST
47508: PUSH
47509: LD_INT 1
47511: PUSH
47512: LD_INT 1
47514: NEG
47515: PUSH
47516: EMPTY
47517: LIST
47518: LIST
47519: PUSH
47520: EMPTY
47521: LIST
47522: LIST
47523: LIST
47524: ST_TO_ADDR
// fBunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
47525: LD_ADDR_VAR 0 60
47529: PUSH
47530: LD_INT 1
47532: PUSH
47533: LD_INT 1
47535: NEG
47536: PUSH
47537: EMPTY
47538: LIST
47539: LIST
47540: PUSH
47541: LD_INT 2
47543: PUSH
47544: LD_INT 0
47546: PUSH
47547: EMPTY
47548: LIST
47549: LIST
47550: PUSH
47551: LD_INT 2
47553: PUSH
47554: LD_INT 1
47556: PUSH
47557: EMPTY
47558: LIST
47559: LIST
47560: PUSH
47561: EMPTY
47562: LIST
47563: LIST
47564: LIST
47565: ST_TO_ADDR
// fBunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
47566: LD_ADDR_VAR 0 61
47570: PUSH
47571: LD_INT 2
47573: PUSH
47574: LD_INT 1
47576: PUSH
47577: EMPTY
47578: LIST
47579: LIST
47580: PUSH
47581: LD_INT 2
47583: PUSH
47584: LD_INT 2
47586: PUSH
47587: EMPTY
47588: LIST
47589: LIST
47590: PUSH
47591: LD_INT 1
47593: PUSH
47594: LD_INT 2
47596: PUSH
47597: EMPTY
47598: LIST
47599: LIST
47600: PUSH
47601: EMPTY
47602: LIST
47603: LIST
47604: LIST
47605: ST_TO_ADDR
// fBunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
47606: LD_ADDR_VAR 0 62
47610: PUSH
47611: LD_INT 1
47613: PUSH
47614: LD_INT 2
47616: PUSH
47617: EMPTY
47618: LIST
47619: LIST
47620: PUSH
47621: LD_INT 0
47623: PUSH
47624: LD_INT 2
47626: PUSH
47627: EMPTY
47628: LIST
47629: LIST
47630: PUSH
47631: LD_INT 1
47633: NEG
47634: PUSH
47635: LD_INT 1
47637: PUSH
47638: EMPTY
47639: LIST
47640: LIST
47641: PUSH
47642: EMPTY
47643: LIST
47644: LIST
47645: LIST
47646: ST_TO_ADDR
// fBunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
47647: LD_ADDR_VAR 0 63
47651: PUSH
47652: LD_INT 1
47654: NEG
47655: PUSH
47656: LD_INT 1
47658: PUSH
47659: EMPTY
47660: LIST
47661: LIST
47662: PUSH
47663: LD_INT 2
47665: NEG
47666: PUSH
47667: LD_INT 0
47669: PUSH
47670: EMPTY
47671: LIST
47672: LIST
47673: PUSH
47674: LD_INT 2
47676: NEG
47677: PUSH
47678: LD_INT 1
47680: NEG
47681: PUSH
47682: EMPTY
47683: LIST
47684: LIST
47685: PUSH
47686: EMPTY
47687: LIST
47688: LIST
47689: LIST
47690: ST_TO_ADDR
// fBunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
47691: LD_ADDR_VAR 0 64
47695: PUSH
47696: LD_INT 1
47698: NEG
47699: PUSH
47700: LD_INT 2
47702: NEG
47703: PUSH
47704: EMPTY
47705: LIST
47706: LIST
47707: PUSH
47708: LD_INT 2
47710: NEG
47711: PUSH
47712: LD_INT 1
47714: NEG
47715: PUSH
47716: EMPTY
47717: LIST
47718: LIST
47719: PUSH
47720: LD_INT 2
47722: NEG
47723: PUSH
47724: LD_INT 2
47726: NEG
47727: PUSH
47728: EMPTY
47729: LIST
47730: LIST
47731: PUSH
47732: EMPTY
47733: LIST
47734: LIST
47735: LIST
47736: ST_TO_ADDR
// end ; 2 :
47737: GO 51003
47739: LD_INT 2
47741: DOUBLE
47742: EQUAL
47743: IFTRUE 47747
47745: GO 51002
47747: POP
// begin fFactory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
47748: LD_ADDR_VAR 0 29
47752: PUSH
47753: LD_INT 4
47755: PUSH
47756: LD_INT 0
47758: PUSH
47759: EMPTY
47760: LIST
47761: LIST
47762: PUSH
47763: LD_INT 4
47765: PUSH
47766: LD_INT 1
47768: NEG
47769: PUSH
47770: EMPTY
47771: LIST
47772: LIST
47773: PUSH
47774: LD_INT 5
47776: PUSH
47777: LD_INT 0
47779: PUSH
47780: EMPTY
47781: LIST
47782: LIST
47783: PUSH
47784: LD_INT 5
47786: PUSH
47787: LD_INT 1
47789: PUSH
47790: EMPTY
47791: LIST
47792: LIST
47793: PUSH
47794: LD_INT 4
47796: PUSH
47797: LD_INT 1
47799: PUSH
47800: EMPTY
47801: LIST
47802: LIST
47803: PUSH
47804: LD_INT 3
47806: PUSH
47807: LD_INT 0
47809: PUSH
47810: EMPTY
47811: LIST
47812: LIST
47813: PUSH
47814: LD_INT 3
47816: PUSH
47817: LD_INT 1
47819: NEG
47820: PUSH
47821: EMPTY
47822: LIST
47823: LIST
47824: PUSH
47825: LD_INT 3
47827: PUSH
47828: LD_INT 2
47830: NEG
47831: PUSH
47832: EMPTY
47833: LIST
47834: LIST
47835: PUSH
47836: LD_INT 5
47838: PUSH
47839: LD_INT 2
47841: PUSH
47842: EMPTY
47843: LIST
47844: LIST
47845: PUSH
47846: LD_INT 3
47848: PUSH
47849: LD_INT 3
47851: PUSH
47852: EMPTY
47853: LIST
47854: LIST
47855: PUSH
47856: LD_INT 3
47858: PUSH
47859: LD_INT 2
47861: PUSH
47862: EMPTY
47863: LIST
47864: LIST
47865: PUSH
47866: LD_INT 4
47868: PUSH
47869: LD_INT 3
47871: PUSH
47872: EMPTY
47873: LIST
47874: LIST
47875: PUSH
47876: LD_INT 4
47878: PUSH
47879: LD_INT 4
47881: PUSH
47882: EMPTY
47883: LIST
47884: LIST
47885: PUSH
47886: LD_INT 3
47888: PUSH
47889: LD_INT 4
47891: PUSH
47892: EMPTY
47893: LIST
47894: LIST
47895: PUSH
47896: LD_INT 2
47898: PUSH
47899: LD_INT 3
47901: PUSH
47902: EMPTY
47903: LIST
47904: LIST
47905: PUSH
47906: LD_INT 2
47908: PUSH
47909: LD_INT 2
47911: PUSH
47912: EMPTY
47913: LIST
47914: LIST
47915: PUSH
47916: LD_INT 4
47918: PUSH
47919: LD_INT 2
47921: PUSH
47922: EMPTY
47923: LIST
47924: LIST
47925: PUSH
47926: LD_INT 2
47928: PUSH
47929: LD_INT 4
47931: PUSH
47932: EMPTY
47933: LIST
47934: LIST
47935: PUSH
47936: LD_INT 0
47938: PUSH
47939: LD_INT 4
47941: PUSH
47942: EMPTY
47943: LIST
47944: LIST
47945: PUSH
47946: LD_INT 0
47948: PUSH
47949: LD_INT 3
47951: PUSH
47952: EMPTY
47953: LIST
47954: LIST
47955: PUSH
47956: LD_INT 1
47958: PUSH
47959: LD_INT 4
47961: PUSH
47962: EMPTY
47963: LIST
47964: LIST
47965: PUSH
47966: LD_INT 1
47968: PUSH
47969: LD_INT 5
47971: PUSH
47972: EMPTY
47973: LIST
47974: LIST
47975: PUSH
47976: LD_INT 0
47978: PUSH
47979: LD_INT 5
47981: PUSH
47982: EMPTY
47983: LIST
47984: LIST
47985: PUSH
47986: LD_INT 1
47988: NEG
47989: PUSH
47990: LD_INT 4
47992: PUSH
47993: EMPTY
47994: LIST
47995: LIST
47996: PUSH
47997: LD_INT 1
47999: NEG
48000: PUSH
48001: LD_INT 3
48003: PUSH
48004: EMPTY
48005: LIST
48006: LIST
48007: PUSH
48008: LD_INT 2
48010: PUSH
48011: LD_INT 5
48013: PUSH
48014: EMPTY
48015: LIST
48016: LIST
48017: PUSH
48018: LD_INT 2
48020: NEG
48021: PUSH
48022: LD_INT 3
48024: PUSH
48025: EMPTY
48026: LIST
48027: LIST
48028: PUSH
48029: LD_INT 3
48031: NEG
48032: PUSH
48033: LD_INT 0
48035: PUSH
48036: EMPTY
48037: LIST
48038: LIST
48039: PUSH
48040: LD_INT 3
48042: NEG
48043: PUSH
48044: LD_INT 1
48046: NEG
48047: PUSH
48048: EMPTY
48049: LIST
48050: LIST
48051: PUSH
48052: LD_INT 2
48054: NEG
48055: PUSH
48056: LD_INT 0
48058: PUSH
48059: EMPTY
48060: LIST
48061: LIST
48062: PUSH
48063: LD_INT 2
48065: NEG
48066: PUSH
48067: LD_INT 1
48069: PUSH
48070: EMPTY
48071: LIST
48072: LIST
48073: PUSH
48074: LD_INT 3
48076: NEG
48077: PUSH
48078: LD_INT 1
48080: PUSH
48081: EMPTY
48082: LIST
48083: LIST
48084: PUSH
48085: LD_INT 4
48087: NEG
48088: PUSH
48089: LD_INT 0
48091: PUSH
48092: EMPTY
48093: LIST
48094: LIST
48095: PUSH
48096: LD_INT 4
48098: NEG
48099: PUSH
48100: LD_INT 1
48102: NEG
48103: PUSH
48104: EMPTY
48105: LIST
48106: LIST
48107: PUSH
48108: LD_INT 4
48110: NEG
48111: PUSH
48112: LD_INT 2
48114: NEG
48115: PUSH
48116: EMPTY
48117: LIST
48118: LIST
48119: PUSH
48120: LD_INT 2
48122: NEG
48123: PUSH
48124: LD_INT 2
48126: PUSH
48127: EMPTY
48128: LIST
48129: LIST
48130: PUSH
48131: LD_INT 4
48133: NEG
48134: PUSH
48135: LD_INT 4
48137: NEG
48138: PUSH
48139: EMPTY
48140: LIST
48141: LIST
48142: PUSH
48143: LD_INT 4
48145: NEG
48146: PUSH
48147: LD_INT 5
48149: NEG
48150: PUSH
48151: EMPTY
48152: LIST
48153: LIST
48154: PUSH
48155: LD_INT 3
48157: NEG
48158: PUSH
48159: LD_INT 4
48161: NEG
48162: PUSH
48163: EMPTY
48164: LIST
48165: LIST
48166: PUSH
48167: LD_INT 3
48169: NEG
48170: PUSH
48171: LD_INT 3
48173: NEG
48174: PUSH
48175: EMPTY
48176: LIST
48177: LIST
48178: PUSH
48179: LD_INT 4
48181: NEG
48182: PUSH
48183: LD_INT 3
48185: NEG
48186: PUSH
48187: EMPTY
48188: LIST
48189: LIST
48190: PUSH
48191: LD_INT 5
48193: NEG
48194: PUSH
48195: LD_INT 4
48197: NEG
48198: PUSH
48199: EMPTY
48200: LIST
48201: LIST
48202: PUSH
48203: LD_INT 5
48205: NEG
48206: PUSH
48207: LD_INT 5
48209: NEG
48210: PUSH
48211: EMPTY
48212: LIST
48213: LIST
48214: PUSH
48215: LD_INT 3
48217: NEG
48218: PUSH
48219: LD_INT 5
48221: NEG
48222: PUSH
48223: EMPTY
48224: LIST
48225: LIST
48226: PUSH
48227: LD_INT 5
48229: NEG
48230: PUSH
48231: LD_INT 3
48233: NEG
48234: PUSH
48235: EMPTY
48236: LIST
48237: LIST
48238: PUSH
48239: EMPTY
48240: LIST
48241: LIST
48242: LIST
48243: LIST
48244: LIST
48245: LIST
48246: LIST
48247: LIST
48248: LIST
48249: LIST
48250: LIST
48251: LIST
48252: LIST
48253: LIST
48254: LIST
48255: LIST
48256: LIST
48257: LIST
48258: LIST
48259: LIST
48260: LIST
48261: LIST
48262: LIST
48263: LIST
48264: LIST
48265: LIST
48266: LIST
48267: LIST
48268: LIST
48269: LIST
48270: LIST
48271: LIST
48272: LIST
48273: LIST
48274: LIST
48275: LIST
48276: LIST
48277: LIST
48278: LIST
48279: LIST
48280: LIST
48281: LIST
48282: LIST
48283: LIST
48284: LIST
48285: ST_TO_ADDR
// fFactory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
48286: LD_ADDR_VAR 0 30
48290: PUSH
48291: LD_INT 4
48293: PUSH
48294: LD_INT 4
48296: PUSH
48297: EMPTY
48298: LIST
48299: LIST
48300: PUSH
48301: LD_INT 4
48303: PUSH
48304: LD_INT 3
48306: PUSH
48307: EMPTY
48308: LIST
48309: LIST
48310: PUSH
48311: LD_INT 5
48313: PUSH
48314: LD_INT 4
48316: PUSH
48317: EMPTY
48318: LIST
48319: LIST
48320: PUSH
48321: LD_INT 5
48323: PUSH
48324: LD_INT 5
48326: PUSH
48327: EMPTY
48328: LIST
48329: LIST
48330: PUSH
48331: LD_INT 4
48333: PUSH
48334: LD_INT 5
48336: PUSH
48337: EMPTY
48338: LIST
48339: LIST
48340: PUSH
48341: LD_INT 3
48343: PUSH
48344: LD_INT 4
48346: PUSH
48347: EMPTY
48348: LIST
48349: LIST
48350: PUSH
48351: LD_INT 3
48353: PUSH
48354: LD_INT 3
48356: PUSH
48357: EMPTY
48358: LIST
48359: LIST
48360: PUSH
48361: LD_INT 5
48363: PUSH
48364: LD_INT 3
48366: PUSH
48367: EMPTY
48368: LIST
48369: LIST
48370: PUSH
48371: LD_INT 3
48373: PUSH
48374: LD_INT 5
48376: PUSH
48377: EMPTY
48378: LIST
48379: LIST
48380: PUSH
48381: LD_INT 0
48383: PUSH
48384: LD_INT 3
48386: PUSH
48387: EMPTY
48388: LIST
48389: LIST
48390: PUSH
48391: LD_INT 0
48393: PUSH
48394: LD_INT 2
48396: PUSH
48397: EMPTY
48398: LIST
48399: LIST
48400: PUSH
48401: LD_INT 1
48403: PUSH
48404: LD_INT 3
48406: PUSH
48407: EMPTY
48408: LIST
48409: LIST
48410: PUSH
48411: LD_INT 1
48413: PUSH
48414: LD_INT 4
48416: PUSH
48417: EMPTY
48418: LIST
48419: LIST
48420: PUSH
48421: LD_INT 0
48423: PUSH
48424: LD_INT 4
48426: PUSH
48427: EMPTY
48428: LIST
48429: LIST
48430: PUSH
48431: LD_INT 1
48433: NEG
48434: PUSH
48435: LD_INT 3
48437: PUSH
48438: EMPTY
48439: LIST
48440: LIST
48441: PUSH
48442: LD_INT 1
48444: NEG
48445: PUSH
48446: LD_INT 2
48448: PUSH
48449: EMPTY
48450: LIST
48451: LIST
48452: PUSH
48453: LD_INT 2
48455: PUSH
48456: LD_INT 4
48458: PUSH
48459: EMPTY
48460: LIST
48461: LIST
48462: PUSH
48463: LD_INT 2
48465: NEG
48466: PUSH
48467: LD_INT 2
48469: PUSH
48470: EMPTY
48471: LIST
48472: LIST
48473: PUSH
48474: LD_INT 4
48476: NEG
48477: PUSH
48478: LD_INT 0
48480: PUSH
48481: EMPTY
48482: LIST
48483: LIST
48484: PUSH
48485: LD_INT 4
48487: NEG
48488: PUSH
48489: LD_INT 1
48491: NEG
48492: PUSH
48493: EMPTY
48494: LIST
48495: LIST
48496: PUSH
48497: LD_INT 3
48499: NEG
48500: PUSH
48501: LD_INT 0
48503: PUSH
48504: EMPTY
48505: LIST
48506: LIST
48507: PUSH
48508: LD_INT 3
48510: NEG
48511: PUSH
48512: LD_INT 1
48514: PUSH
48515: EMPTY
48516: LIST
48517: LIST
48518: PUSH
48519: LD_INT 4
48521: NEG
48522: PUSH
48523: LD_INT 1
48525: PUSH
48526: EMPTY
48527: LIST
48528: LIST
48529: PUSH
48530: LD_INT 5
48532: NEG
48533: PUSH
48534: LD_INT 0
48536: PUSH
48537: EMPTY
48538: LIST
48539: LIST
48540: PUSH
48541: LD_INT 5
48543: NEG
48544: PUSH
48545: LD_INT 1
48547: NEG
48548: PUSH
48549: EMPTY
48550: LIST
48551: LIST
48552: PUSH
48553: LD_INT 5
48555: NEG
48556: PUSH
48557: LD_INT 2
48559: NEG
48560: PUSH
48561: EMPTY
48562: LIST
48563: LIST
48564: PUSH
48565: LD_INT 3
48567: NEG
48568: PUSH
48569: LD_INT 2
48571: PUSH
48572: EMPTY
48573: LIST
48574: LIST
48575: PUSH
48576: LD_INT 3
48578: NEG
48579: PUSH
48580: LD_INT 3
48582: NEG
48583: PUSH
48584: EMPTY
48585: LIST
48586: LIST
48587: PUSH
48588: LD_INT 3
48590: NEG
48591: PUSH
48592: LD_INT 4
48594: NEG
48595: PUSH
48596: EMPTY
48597: LIST
48598: LIST
48599: PUSH
48600: LD_INT 2
48602: NEG
48603: PUSH
48604: LD_INT 3
48606: NEG
48607: PUSH
48608: EMPTY
48609: LIST
48610: LIST
48611: PUSH
48612: LD_INT 2
48614: NEG
48615: PUSH
48616: LD_INT 2
48618: NEG
48619: PUSH
48620: EMPTY
48621: LIST
48622: LIST
48623: PUSH
48624: LD_INT 3
48626: NEG
48627: PUSH
48628: LD_INT 2
48630: NEG
48631: PUSH
48632: EMPTY
48633: LIST
48634: LIST
48635: PUSH
48636: LD_INT 4
48638: NEG
48639: PUSH
48640: LD_INT 3
48642: NEG
48643: PUSH
48644: EMPTY
48645: LIST
48646: LIST
48647: PUSH
48648: LD_INT 4
48650: NEG
48651: PUSH
48652: LD_INT 4
48654: NEG
48655: PUSH
48656: EMPTY
48657: LIST
48658: LIST
48659: PUSH
48660: LD_INT 2
48662: NEG
48663: PUSH
48664: LD_INT 4
48666: NEG
48667: PUSH
48668: EMPTY
48669: LIST
48670: LIST
48671: PUSH
48672: LD_INT 4
48674: NEG
48675: PUSH
48676: LD_INT 2
48678: NEG
48679: PUSH
48680: EMPTY
48681: LIST
48682: LIST
48683: PUSH
48684: LD_INT 0
48686: PUSH
48687: LD_INT 4
48689: NEG
48690: PUSH
48691: EMPTY
48692: LIST
48693: LIST
48694: PUSH
48695: LD_INT 0
48697: PUSH
48698: LD_INT 5
48700: NEG
48701: PUSH
48702: EMPTY
48703: LIST
48704: LIST
48705: PUSH
48706: LD_INT 1
48708: PUSH
48709: LD_INT 4
48711: NEG
48712: PUSH
48713: EMPTY
48714: LIST
48715: LIST
48716: PUSH
48717: LD_INT 1
48719: PUSH
48720: LD_INT 3
48722: NEG
48723: PUSH
48724: EMPTY
48725: LIST
48726: LIST
48727: PUSH
48728: LD_INT 0
48730: PUSH
48731: LD_INT 3
48733: NEG
48734: PUSH
48735: EMPTY
48736: LIST
48737: LIST
48738: PUSH
48739: LD_INT 1
48741: NEG
48742: PUSH
48743: LD_INT 4
48745: NEG
48746: PUSH
48747: EMPTY
48748: LIST
48749: LIST
48750: PUSH
48751: LD_INT 1
48753: NEG
48754: PUSH
48755: LD_INT 5
48757: NEG
48758: PUSH
48759: EMPTY
48760: LIST
48761: LIST
48762: PUSH
48763: LD_INT 2
48765: PUSH
48766: LD_INT 3
48768: NEG
48769: PUSH
48770: EMPTY
48771: LIST
48772: LIST
48773: PUSH
48774: LD_INT 2
48776: NEG
48777: PUSH
48778: LD_INT 5
48780: NEG
48781: PUSH
48782: EMPTY
48783: LIST
48784: LIST
48785: PUSH
48786: EMPTY
48787: LIST
48788: LIST
48789: LIST
48790: LIST
48791: LIST
48792: LIST
48793: LIST
48794: LIST
48795: LIST
48796: LIST
48797: LIST
48798: LIST
48799: LIST
48800: LIST
48801: LIST
48802: LIST
48803: LIST
48804: LIST
48805: LIST
48806: LIST
48807: LIST
48808: LIST
48809: LIST
48810: LIST
48811: LIST
48812: LIST
48813: LIST
48814: LIST
48815: LIST
48816: LIST
48817: LIST
48818: LIST
48819: LIST
48820: LIST
48821: LIST
48822: LIST
48823: LIST
48824: LIST
48825: LIST
48826: LIST
48827: LIST
48828: LIST
48829: LIST
48830: LIST
48831: LIST
48832: ST_TO_ADDR
// fFactory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
48833: LD_ADDR_VAR 0 31
48837: PUSH
48838: LD_INT 0
48840: PUSH
48841: LD_INT 4
48843: PUSH
48844: EMPTY
48845: LIST
48846: LIST
48847: PUSH
48848: LD_INT 0
48850: PUSH
48851: LD_INT 3
48853: PUSH
48854: EMPTY
48855: LIST
48856: LIST
48857: PUSH
48858: LD_INT 1
48860: PUSH
48861: LD_INT 4
48863: PUSH
48864: EMPTY
48865: LIST
48866: LIST
48867: PUSH
48868: LD_INT 1
48870: PUSH
48871: LD_INT 5
48873: PUSH
48874: EMPTY
48875: LIST
48876: LIST
48877: PUSH
48878: LD_INT 0
48880: PUSH
48881: LD_INT 5
48883: PUSH
48884: EMPTY
48885: LIST
48886: LIST
48887: PUSH
48888: LD_INT 1
48890: NEG
48891: PUSH
48892: LD_INT 4
48894: PUSH
48895: EMPTY
48896: LIST
48897: LIST
48898: PUSH
48899: LD_INT 1
48901: NEG
48902: PUSH
48903: LD_INT 3
48905: PUSH
48906: EMPTY
48907: LIST
48908: LIST
48909: PUSH
48910: LD_INT 2
48912: PUSH
48913: LD_INT 5
48915: PUSH
48916: EMPTY
48917: LIST
48918: LIST
48919: PUSH
48920: LD_INT 2
48922: NEG
48923: PUSH
48924: LD_INT 3
48926: PUSH
48927: EMPTY
48928: LIST
48929: LIST
48930: PUSH
48931: LD_INT 3
48933: NEG
48934: PUSH
48935: LD_INT 0
48937: PUSH
48938: EMPTY
48939: LIST
48940: LIST
48941: PUSH
48942: LD_INT 3
48944: NEG
48945: PUSH
48946: LD_INT 1
48948: NEG
48949: PUSH
48950: EMPTY
48951: LIST
48952: LIST
48953: PUSH
48954: LD_INT 2
48956: NEG
48957: PUSH
48958: LD_INT 0
48960: PUSH
48961: EMPTY
48962: LIST
48963: LIST
48964: PUSH
48965: LD_INT 2
48967: NEG
48968: PUSH
48969: LD_INT 1
48971: PUSH
48972: EMPTY
48973: LIST
48974: LIST
48975: PUSH
48976: LD_INT 3
48978: NEG
48979: PUSH
48980: LD_INT 1
48982: PUSH
48983: EMPTY
48984: LIST
48985: LIST
48986: PUSH
48987: LD_INT 4
48989: NEG
48990: PUSH
48991: LD_INT 0
48993: PUSH
48994: EMPTY
48995: LIST
48996: LIST
48997: PUSH
48998: LD_INT 4
49000: NEG
49001: PUSH
49002: LD_INT 1
49004: NEG
49005: PUSH
49006: EMPTY
49007: LIST
49008: LIST
49009: PUSH
49010: LD_INT 4
49012: NEG
49013: PUSH
49014: LD_INT 2
49016: NEG
49017: PUSH
49018: EMPTY
49019: LIST
49020: LIST
49021: PUSH
49022: LD_INT 2
49024: NEG
49025: PUSH
49026: LD_INT 2
49028: PUSH
49029: EMPTY
49030: LIST
49031: LIST
49032: PUSH
49033: LD_INT 4
49035: NEG
49036: PUSH
49037: LD_INT 4
49039: NEG
49040: PUSH
49041: EMPTY
49042: LIST
49043: LIST
49044: PUSH
49045: LD_INT 4
49047: NEG
49048: PUSH
49049: LD_INT 5
49051: NEG
49052: PUSH
49053: EMPTY
49054: LIST
49055: LIST
49056: PUSH
49057: LD_INT 3
49059: NEG
49060: PUSH
49061: LD_INT 4
49063: NEG
49064: PUSH
49065: EMPTY
49066: LIST
49067: LIST
49068: PUSH
49069: LD_INT 3
49071: NEG
49072: PUSH
49073: LD_INT 3
49075: NEG
49076: PUSH
49077: EMPTY
49078: LIST
49079: LIST
49080: PUSH
49081: LD_INT 4
49083: NEG
49084: PUSH
49085: LD_INT 3
49087: NEG
49088: PUSH
49089: EMPTY
49090: LIST
49091: LIST
49092: PUSH
49093: LD_INT 5
49095: NEG
49096: PUSH
49097: LD_INT 4
49099: NEG
49100: PUSH
49101: EMPTY
49102: LIST
49103: LIST
49104: PUSH
49105: LD_INT 5
49107: NEG
49108: PUSH
49109: LD_INT 5
49111: NEG
49112: PUSH
49113: EMPTY
49114: LIST
49115: LIST
49116: PUSH
49117: LD_INT 3
49119: NEG
49120: PUSH
49121: LD_INT 5
49123: NEG
49124: PUSH
49125: EMPTY
49126: LIST
49127: LIST
49128: PUSH
49129: LD_INT 5
49131: NEG
49132: PUSH
49133: LD_INT 3
49135: NEG
49136: PUSH
49137: EMPTY
49138: LIST
49139: LIST
49140: PUSH
49141: LD_INT 0
49143: PUSH
49144: LD_INT 3
49146: NEG
49147: PUSH
49148: EMPTY
49149: LIST
49150: LIST
49151: PUSH
49152: LD_INT 0
49154: PUSH
49155: LD_INT 4
49157: NEG
49158: PUSH
49159: EMPTY
49160: LIST
49161: LIST
49162: PUSH
49163: LD_INT 1
49165: PUSH
49166: LD_INT 3
49168: NEG
49169: PUSH
49170: EMPTY
49171: LIST
49172: LIST
49173: PUSH
49174: LD_INT 1
49176: PUSH
49177: LD_INT 2
49179: NEG
49180: PUSH
49181: EMPTY
49182: LIST
49183: LIST
49184: PUSH
49185: LD_INT 0
49187: PUSH
49188: LD_INT 2
49190: NEG
49191: PUSH
49192: EMPTY
49193: LIST
49194: LIST
49195: PUSH
49196: LD_INT 1
49198: NEG
49199: PUSH
49200: LD_INT 3
49202: NEG
49203: PUSH
49204: EMPTY
49205: LIST
49206: LIST
49207: PUSH
49208: LD_INT 1
49210: NEG
49211: PUSH
49212: LD_INT 4
49214: NEG
49215: PUSH
49216: EMPTY
49217: LIST
49218: LIST
49219: PUSH
49220: LD_INT 2
49222: PUSH
49223: LD_INT 2
49225: NEG
49226: PUSH
49227: EMPTY
49228: LIST
49229: LIST
49230: PUSH
49231: LD_INT 2
49233: NEG
49234: PUSH
49235: LD_INT 4
49237: NEG
49238: PUSH
49239: EMPTY
49240: LIST
49241: LIST
49242: PUSH
49243: LD_INT 4
49245: PUSH
49246: LD_INT 0
49248: PUSH
49249: EMPTY
49250: LIST
49251: LIST
49252: PUSH
49253: LD_INT 4
49255: PUSH
49256: LD_INT 1
49258: NEG
49259: PUSH
49260: EMPTY
49261: LIST
49262: LIST
49263: PUSH
49264: LD_INT 5
49266: PUSH
49267: LD_INT 0
49269: PUSH
49270: EMPTY
49271: LIST
49272: LIST
49273: PUSH
49274: LD_INT 5
49276: PUSH
49277: LD_INT 1
49279: PUSH
49280: EMPTY
49281: LIST
49282: LIST
49283: PUSH
49284: LD_INT 4
49286: PUSH
49287: LD_INT 1
49289: PUSH
49290: EMPTY
49291: LIST
49292: LIST
49293: PUSH
49294: LD_INT 3
49296: PUSH
49297: LD_INT 0
49299: PUSH
49300: EMPTY
49301: LIST
49302: LIST
49303: PUSH
49304: LD_INT 3
49306: PUSH
49307: LD_INT 1
49309: NEG
49310: PUSH
49311: EMPTY
49312: LIST
49313: LIST
49314: PUSH
49315: LD_INT 3
49317: PUSH
49318: LD_INT 2
49320: NEG
49321: PUSH
49322: EMPTY
49323: LIST
49324: LIST
49325: PUSH
49326: LD_INT 5
49328: PUSH
49329: LD_INT 2
49331: PUSH
49332: EMPTY
49333: LIST
49334: LIST
49335: PUSH
49336: EMPTY
49337: LIST
49338: LIST
49339: LIST
49340: LIST
49341: LIST
49342: LIST
49343: LIST
49344: LIST
49345: LIST
49346: LIST
49347: LIST
49348: LIST
49349: LIST
49350: LIST
49351: LIST
49352: LIST
49353: LIST
49354: LIST
49355: LIST
49356: LIST
49357: LIST
49358: LIST
49359: LIST
49360: LIST
49361: LIST
49362: LIST
49363: LIST
49364: LIST
49365: LIST
49366: LIST
49367: LIST
49368: LIST
49369: LIST
49370: LIST
49371: LIST
49372: LIST
49373: LIST
49374: LIST
49375: LIST
49376: LIST
49377: LIST
49378: LIST
49379: LIST
49380: LIST
49381: LIST
49382: ST_TO_ADDR
// fFactory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
49383: LD_ADDR_VAR 0 32
49387: PUSH
49388: LD_INT 4
49390: NEG
49391: PUSH
49392: LD_INT 0
49394: PUSH
49395: EMPTY
49396: LIST
49397: LIST
49398: PUSH
49399: LD_INT 4
49401: NEG
49402: PUSH
49403: LD_INT 1
49405: NEG
49406: PUSH
49407: EMPTY
49408: LIST
49409: LIST
49410: PUSH
49411: LD_INT 3
49413: NEG
49414: PUSH
49415: LD_INT 0
49417: PUSH
49418: EMPTY
49419: LIST
49420: LIST
49421: PUSH
49422: LD_INT 3
49424: NEG
49425: PUSH
49426: LD_INT 1
49428: PUSH
49429: EMPTY
49430: LIST
49431: LIST
49432: PUSH
49433: LD_INT 4
49435: NEG
49436: PUSH
49437: LD_INT 1
49439: PUSH
49440: EMPTY
49441: LIST
49442: LIST
49443: PUSH
49444: LD_INT 5
49446: NEG
49447: PUSH
49448: LD_INT 0
49450: PUSH
49451: EMPTY
49452: LIST
49453: LIST
49454: PUSH
49455: LD_INT 5
49457: NEG
49458: PUSH
49459: LD_INT 1
49461: NEG
49462: PUSH
49463: EMPTY
49464: LIST
49465: LIST
49466: PUSH
49467: LD_INT 5
49469: NEG
49470: PUSH
49471: LD_INT 2
49473: NEG
49474: PUSH
49475: EMPTY
49476: LIST
49477: LIST
49478: PUSH
49479: LD_INT 3
49481: NEG
49482: PUSH
49483: LD_INT 2
49485: PUSH
49486: EMPTY
49487: LIST
49488: LIST
49489: PUSH
49490: LD_INT 3
49492: NEG
49493: PUSH
49494: LD_INT 3
49496: NEG
49497: PUSH
49498: EMPTY
49499: LIST
49500: LIST
49501: PUSH
49502: LD_INT 3
49504: NEG
49505: PUSH
49506: LD_INT 4
49508: NEG
49509: PUSH
49510: EMPTY
49511: LIST
49512: LIST
49513: PUSH
49514: LD_INT 2
49516: NEG
49517: PUSH
49518: LD_INT 3
49520: NEG
49521: PUSH
49522: EMPTY
49523: LIST
49524: LIST
49525: PUSH
49526: LD_INT 2
49528: NEG
49529: PUSH
49530: LD_INT 2
49532: NEG
49533: PUSH
49534: EMPTY
49535: LIST
49536: LIST
49537: PUSH
49538: LD_INT 3
49540: NEG
49541: PUSH
49542: LD_INT 2
49544: NEG
49545: PUSH
49546: EMPTY
49547: LIST
49548: LIST
49549: PUSH
49550: LD_INT 4
49552: NEG
49553: PUSH
49554: LD_INT 3
49556: NEG
49557: PUSH
49558: EMPTY
49559: LIST
49560: LIST
49561: PUSH
49562: LD_INT 4
49564: NEG
49565: PUSH
49566: LD_INT 4
49568: NEG
49569: PUSH
49570: EMPTY
49571: LIST
49572: LIST
49573: PUSH
49574: LD_INT 2
49576: NEG
49577: PUSH
49578: LD_INT 4
49580: NEG
49581: PUSH
49582: EMPTY
49583: LIST
49584: LIST
49585: PUSH
49586: LD_INT 4
49588: NEG
49589: PUSH
49590: LD_INT 2
49592: NEG
49593: PUSH
49594: EMPTY
49595: LIST
49596: LIST
49597: PUSH
49598: LD_INT 0
49600: PUSH
49601: LD_INT 4
49603: NEG
49604: PUSH
49605: EMPTY
49606: LIST
49607: LIST
49608: PUSH
49609: LD_INT 0
49611: PUSH
49612: LD_INT 5
49614: NEG
49615: PUSH
49616: EMPTY
49617: LIST
49618: LIST
49619: PUSH
49620: LD_INT 1
49622: PUSH
49623: LD_INT 4
49625: NEG
49626: PUSH
49627: EMPTY
49628: LIST
49629: LIST
49630: PUSH
49631: LD_INT 1
49633: PUSH
49634: LD_INT 3
49636: NEG
49637: PUSH
49638: EMPTY
49639: LIST
49640: LIST
49641: PUSH
49642: LD_INT 0
49644: PUSH
49645: LD_INT 3
49647: NEG
49648: PUSH
49649: EMPTY
49650: LIST
49651: LIST
49652: PUSH
49653: LD_INT 1
49655: NEG
49656: PUSH
49657: LD_INT 4
49659: NEG
49660: PUSH
49661: EMPTY
49662: LIST
49663: LIST
49664: PUSH
49665: LD_INT 1
49667: NEG
49668: PUSH
49669: LD_INT 5
49671: NEG
49672: PUSH
49673: EMPTY
49674: LIST
49675: LIST
49676: PUSH
49677: LD_INT 2
49679: PUSH
49680: LD_INT 3
49682: NEG
49683: PUSH
49684: EMPTY
49685: LIST
49686: LIST
49687: PUSH
49688: LD_INT 2
49690: NEG
49691: PUSH
49692: LD_INT 5
49694: NEG
49695: PUSH
49696: EMPTY
49697: LIST
49698: LIST
49699: PUSH
49700: LD_INT 3
49702: PUSH
49703: LD_INT 0
49705: PUSH
49706: EMPTY
49707: LIST
49708: LIST
49709: PUSH
49710: LD_INT 3
49712: PUSH
49713: LD_INT 1
49715: NEG
49716: PUSH
49717: EMPTY
49718: LIST
49719: LIST
49720: PUSH
49721: LD_INT 4
49723: PUSH
49724: LD_INT 0
49726: PUSH
49727: EMPTY
49728: LIST
49729: LIST
49730: PUSH
49731: LD_INT 4
49733: PUSH
49734: LD_INT 1
49736: PUSH
49737: EMPTY
49738: LIST
49739: LIST
49740: PUSH
49741: LD_INT 3
49743: PUSH
49744: LD_INT 1
49746: PUSH
49747: EMPTY
49748: LIST
49749: LIST
49750: PUSH
49751: LD_INT 2
49753: PUSH
49754: LD_INT 0
49756: PUSH
49757: EMPTY
49758: LIST
49759: LIST
49760: PUSH
49761: LD_INT 2
49763: PUSH
49764: LD_INT 1
49766: NEG
49767: PUSH
49768: EMPTY
49769: LIST
49770: LIST
49771: PUSH
49772: LD_INT 2
49774: PUSH
49775: LD_INT 2
49777: NEG
49778: PUSH
49779: EMPTY
49780: LIST
49781: LIST
49782: PUSH
49783: LD_INT 4
49785: PUSH
49786: LD_INT 2
49788: PUSH
49789: EMPTY
49790: LIST
49791: LIST
49792: PUSH
49793: LD_INT 4
49795: PUSH
49796: LD_INT 4
49798: PUSH
49799: EMPTY
49800: LIST
49801: LIST
49802: PUSH
49803: LD_INT 4
49805: PUSH
49806: LD_INT 3
49808: PUSH
49809: EMPTY
49810: LIST
49811: LIST
49812: PUSH
49813: LD_INT 5
49815: PUSH
49816: LD_INT 4
49818: PUSH
49819: EMPTY
49820: LIST
49821: LIST
49822: PUSH
49823: LD_INT 5
49825: PUSH
49826: LD_INT 5
49828: PUSH
49829: EMPTY
49830: LIST
49831: LIST
49832: PUSH
49833: LD_INT 4
49835: PUSH
49836: LD_INT 5
49838: PUSH
49839: EMPTY
49840: LIST
49841: LIST
49842: PUSH
49843: LD_INT 3
49845: PUSH
49846: LD_INT 4
49848: PUSH
49849: EMPTY
49850: LIST
49851: LIST
49852: PUSH
49853: LD_INT 3
49855: PUSH
49856: LD_INT 3
49858: PUSH
49859: EMPTY
49860: LIST
49861: LIST
49862: PUSH
49863: LD_INT 5
49865: PUSH
49866: LD_INT 3
49868: PUSH
49869: EMPTY
49870: LIST
49871: LIST
49872: PUSH
49873: LD_INT 3
49875: PUSH
49876: LD_INT 5
49878: PUSH
49879: EMPTY
49880: LIST
49881: LIST
49882: PUSH
49883: EMPTY
49884: LIST
49885: LIST
49886: LIST
49887: LIST
49888: LIST
49889: LIST
49890: LIST
49891: LIST
49892: LIST
49893: LIST
49894: LIST
49895: LIST
49896: LIST
49897: LIST
49898: LIST
49899: LIST
49900: LIST
49901: LIST
49902: LIST
49903: LIST
49904: LIST
49905: LIST
49906: LIST
49907: LIST
49908: LIST
49909: LIST
49910: LIST
49911: LIST
49912: LIST
49913: LIST
49914: LIST
49915: LIST
49916: LIST
49917: LIST
49918: LIST
49919: LIST
49920: LIST
49921: LIST
49922: LIST
49923: LIST
49924: LIST
49925: LIST
49926: LIST
49927: LIST
49928: LIST
49929: ST_TO_ADDR
// fFactory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
49930: LD_ADDR_VAR 0 33
49934: PUSH
49935: LD_INT 4
49937: NEG
49938: PUSH
49939: LD_INT 4
49941: NEG
49942: PUSH
49943: EMPTY
49944: LIST
49945: LIST
49946: PUSH
49947: LD_INT 4
49949: NEG
49950: PUSH
49951: LD_INT 5
49953: NEG
49954: PUSH
49955: EMPTY
49956: LIST
49957: LIST
49958: PUSH
49959: LD_INT 3
49961: NEG
49962: PUSH
49963: LD_INT 4
49965: NEG
49966: PUSH
49967: EMPTY
49968: LIST
49969: LIST
49970: PUSH
49971: LD_INT 3
49973: NEG
49974: PUSH
49975: LD_INT 3
49977: NEG
49978: PUSH
49979: EMPTY
49980: LIST
49981: LIST
49982: PUSH
49983: LD_INT 4
49985: NEG
49986: PUSH
49987: LD_INT 3
49989: NEG
49990: PUSH
49991: EMPTY
49992: LIST
49993: LIST
49994: PUSH
49995: LD_INT 5
49997: NEG
49998: PUSH
49999: LD_INT 4
50001: NEG
50002: PUSH
50003: EMPTY
50004: LIST
50005: LIST
50006: PUSH
50007: LD_INT 5
50009: NEG
50010: PUSH
50011: LD_INT 5
50013: NEG
50014: PUSH
50015: EMPTY
50016: LIST
50017: LIST
50018: PUSH
50019: LD_INT 3
50021: NEG
50022: PUSH
50023: LD_INT 5
50025: NEG
50026: PUSH
50027: EMPTY
50028: LIST
50029: LIST
50030: PUSH
50031: LD_INT 5
50033: NEG
50034: PUSH
50035: LD_INT 3
50037: NEG
50038: PUSH
50039: EMPTY
50040: LIST
50041: LIST
50042: PUSH
50043: LD_INT 0
50045: PUSH
50046: LD_INT 3
50048: NEG
50049: PUSH
50050: EMPTY
50051: LIST
50052: LIST
50053: PUSH
50054: LD_INT 0
50056: PUSH
50057: LD_INT 4
50059: NEG
50060: PUSH
50061: EMPTY
50062: LIST
50063: LIST
50064: PUSH
50065: LD_INT 1
50067: PUSH
50068: LD_INT 3
50070: NEG
50071: PUSH
50072: EMPTY
50073: LIST
50074: LIST
50075: PUSH
50076: LD_INT 1
50078: PUSH
50079: LD_INT 2
50081: NEG
50082: PUSH
50083: EMPTY
50084: LIST
50085: LIST
50086: PUSH
50087: LD_INT 0
50089: PUSH
50090: LD_INT 2
50092: NEG
50093: PUSH
50094: EMPTY
50095: LIST
50096: LIST
50097: PUSH
50098: LD_INT 1
50100: NEG
50101: PUSH
50102: LD_INT 3
50104: NEG
50105: PUSH
50106: EMPTY
50107: LIST
50108: LIST
50109: PUSH
50110: LD_INT 1
50112: NEG
50113: PUSH
50114: LD_INT 4
50116: NEG
50117: PUSH
50118: EMPTY
50119: LIST
50120: LIST
50121: PUSH
50122: LD_INT 2
50124: PUSH
50125: LD_INT 2
50127: NEG
50128: PUSH
50129: EMPTY
50130: LIST
50131: LIST
50132: PUSH
50133: LD_INT 2
50135: NEG
50136: PUSH
50137: LD_INT 4
50139: NEG
50140: PUSH
50141: EMPTY
50142: LIST
50143: LIST
50144: PUSH
50145: LD_INT 4
50147: PUSH
50148: LD_INT 0
50150: PUSH
50151: EMPTY
50152: LIST
50153: LIST
50154: PUSH
50155: LD_INT 4
50157: PUSH
50158: LD_INT 1
50160: NEG
50161: PUSH
50162: EMPTY
50163: LIST
50164: LIST
50165: PUSH
50166: LD_INT 5
50168: PUSH
50169: LD_INT 0
50171: PUSH
50172: EMPTY
50173: LIST
50174: LIST
50175: PUSH
50176: LD_INT 5
50178: PUSH
50179: LD_INT 1
50181: PUSH
50182: EMPTY
50183: LIST
50184: LIST
50185: PUSH
50186: LD_INT 4
50188: PUSH
50189: LD_INT 1
50191: PUSH
50192: EMPTY
50193: LIST
50194: LIST
50195: PUSH
50196: LD_INT 3
50198: PUSH
50199: LD_INT 0
50201: PUSH
50202: EMPTY
50203: LIST
50204: LIST
50205: PUSH
50206: LD_INT 3
50208: PUSH
50209: LD_INT 1
50211: NEG
50212: PUSH
50213: EMPTY
50214: LIST
50215: LIST
50216: PUSH
50217: LD_INT 3
50219: PUSH
50220: LD_INT 2
50222: NEG
50223: PUSH
50224: EMPTY
50225: LIST
50226: LIST
50227: PUSH
50228: LD_INT 5
50230: PUSH
50231: LD_INT 2
50233: PUSH
50234: EMPTY
50235: LIST
50236: LIST
50237: PUSH
50238: LD_INT 3
50240: PUSH
50241: LD_INT 3
50243: PUSH
50244: EMPTY
50245: LIST
50246: LIST
50247: PUSH
50248: LD_INT 3
50250: PUSH
50251: LD_INT 2
50253: PUSH
50254: EMPTY
50255: LIST
50256: LIST
50257: PUSH
50258: LD_INT 4
50260: PUSH
50261: LD_INT 3
50263: PUSH
50264: EMPTY
50265: LIST
50266: LIST
50267: PUSH
50268: LD_INT 4
50270: PUSH
50271: LD_INT 4
50273: PUSH
50274: EMPTY
50275: LIST
50276: LIST
50277: PUSH
50278: LD_INT 3
50280: PUSH
50281: LD_INT 4
50283: PUSH
50284: EMPTY
50285: LIST
50286: LIST
50287: PUSH
50288: LD_INT 2
50290: PUSH
50291: LD_INT 3
50293: PUSH
50294: EMPTY
50295: LIST
50296: LIST
50297: PUSH
50298: LD_INT 2
50300: PUSH
50301: LD_INT 2
50303: PUSH
50304: EMPTY
50305: LIST
50306: LIST
50307: PUSH
50308: LD_INT 4
50310: PUSH
50311: LD_INT 2
50313: PUSH
50314: EMPTY
50315: LIST
50316: LIST
50317: PUSH
50318: LD_INT 2
50320: PUSH
50321: LD_INT 4
50323: PUSH
50324: EMPTY
50325: LIST
50326: LIST
50327: PUSH
50328: LD_INT 0
50330: PUSH
50331: LD_INT 4
50333: PUSH
50334: EMPTY
50335: LIST
50336: LIST
50337: PUSH
50338: LD_INT 0
50340: PUSH
50341: LD_INT 3
50343: PUSH
50344: EMPTY
50345: LIST
50346: LIST
50347: PUSH
50348: LD_INT 1
50350: PUSH
50351: LD_INT 4
50353: PUSH
50354: EMPTY
50355: LIST
50356: LIST
50357: PUSH
50358: LD_INT 1
50360: PUSH
50361: LD_INT 5
50363: PUSH
50364: EMPTY
50365: LIST
50366: LIST
50367: PUSH
50368: LD_INT 0
50370: PUSH
50371: LD_INT 5
50373: PUSH
50374: EMPTY
50375: LIST
50376: LIST
50377: PUSH
50378: LD_INT 1
50380: NEG
50381: PUSH
50382: LD_INT 4
50384: PUSH
50385: EMPTY
50386: LIST
50387: LIST
50388: PUSH
50389: LD_INT 1
50391: NEG
50392: PUSH
50393: LD_INT 3
50395: PUSH
50396: EMPTY
50397: LIST
50398: LIST
50399: PUSH
50400: LD_INT 2
50402: PUSH
50403: LD_INT 5
50405: PUSH
50406: EMPTY
50407: LIST
50408: LIST
50409: PUSH
50410: LD_INT 2
50412: NEG
50413: PUSH
50414: LD_INT 3
50416: PUSH
50417: EMPTY
50418: LIST
50419: LIST
50420: PUSH
50421: EMPTY
50422: LIST
50423: LIST
50424: LIST
50425: LIST
50426: LIST
50427: LIST
50428: LIST
50429: LIST
50430: LIST
50431: LIST
50432: LIST
50433: LIST
50434: LIST
50435: LIST
50436: LIST
50437: LIST
50438: LIST
50439: LIST
50440: LIST
50441: LIST
50442: LIST
50443: LIST
50444: LIST
50445: LIST
50446: LIST
50447: LIST
50448: LIST
50449: LIST
50450: LIST
50451: LIST
50452: LIST
50453: LIST
50454: LIST
50455: LIST
50456: LIST
50457: LIST
50458: LIST
50459: LIST
50460: LIST
50461: LIST
50462: LIST
50463: LIST
50464: LIST
50465: LIST
50466: LIST
50467: ST_TO_ADDR
// fFactory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
50468: LD_ADDR_VAR 0 34
50472: PUSH
50473: LD_INT 0
50475: PUSH
50476: LD_INT 4
50478: NEG
50479: PUSH
50480: EMPTY
50481: LIST
50482: LIST
50483: PUSH
50484: LD_INT 0
50486: PUSH
50487: LD_INT 5
50489: NEG
50490: PUSH
50491: EMPTY
50492: LIST
50493: LIST
50494: PUSH
50495: LD_INT 1
50497: PUSH
50498: LD_INT 4
50500: NEG
50501: PUSH
50502: EMPTY
50503: LIST
50504: LIST
50505: PUSH
50506: LD_INT 1
50508: PUSH
50509: LD_INT 3
50511: NEG
50512: PUSH
50513: EMPTY
50514: LIST
50515: LIST
50516: PUSH
50517: LD_INT 0
50519: PUSH
50520: LD_INT 3
50522: NEG
50523: PUSH
50524: EMPTY
50525: LIST
50526: LIST
50527: PUSH
50528: LD_INT 1
50530: NEG
50531: PUSH
50532: LD_INT 4
50534: NEG
50535: PUSH
50536: EMPTY
50537: LIST
50538: LIST
50539: PUSH
50540: LD_INT 1
50542: NEG
50543: PUSH
50544: LD_INT 5
50546: NEG
50547: PUSH
50548: EMPTY
50549: LIST
50550: LIST
50551: PUSH
50552: LD_INT 2
50554: PUSH
50555: LD_INT 3
50557: NEG
50558: PUSH
50559: EMPTY
50560: LIST
50561: LIST
50562: PUSH
50563: LD_INT 2
50565: NEG
50566: PUSH
50567: LD_INT 5
50569: NEG
50570: PUSH
50571: EMPTY
50572: LIST
50573: LIST
50574: PUSH
50575: LD_INT 3
50577: PUSH
50578: LD_INT 0
50580: PUSH
50581: EMPTY
50582: LIST
50583: LIST
50584: PUSH
50585: LD_INT 3
50587: PUSH
50588: LD_INT 1
50590: NEG
50591: PUSH
50592: EMPTY
50593: LIST
50594: LIST
50595: PUSH
50596: LD_INT 4
50598: PUSH
50599: LD_INT 0
50601: PUSH
50602: EMPTY
50603: LIST
50604: LIST
50605: PUSH
50606: LD_INT 4
50608: PUSH
50609: LD_INT 1
50611: PUSH
50612: EMPTY
50613: LIST
50614: LIST
50615: PUSH
50616: LD_INT 3
50618: PUSH
50619: LD_INT 1
50621: PUSH
50622: EMPTY
50623: LIST
50624: LIST
50625: PUSH
50626: LD_INT 2
50628: PUSH
50629: LD_INT 0
50631: PUSH
50632: EMPTY
50633: LIST
50634: LIST
50635: PUSH
50636: LD_INT 2
50638: PUSH
50639: LD_INT 1
50641: NEG
50642: PUSH
50643: EMPTY
50644: LIST
50645: LIST
50646: PUSH
50647: LD_INT 2
50649: PUSH
50650: LD_INT 2
50652: NEG
50653: PUSH
50654: EMPTY
50655: LIST
50656: LIST
50657: PUSH
50658: LD_INT 4
50660: PUSH
50661: LD_INT 2
50663: PUSH
50664: EMPTY
50665: LIST
50666: LIST
50667: PUSH
50668: LD_INT 4
50670: PUSH
50671: LD_INT 4
50673: PUSH
50674: EMPTY
50675: LIST
50676: LIST
50677: PUSH
50678: LD_INT 4
50680: PUSH
50681: LD_INT 3
50683: PUSH
50684: EMPTY
50685: LIST
50686: LIST
50687: PUSH
50688: LD_INT 5
50690: PUSH
50691: LD_INT 4
50693: PUSH
50694: EMPTY
50695: LIST
50696: LIST
50697: PUSH
50698: LD_INT 5
50700: PUSH
50701: LD_INT 5
50703: PUSH
50704: EMPTY
50705: LIST
50706: LIST
50707: PUSH
50708: LD_INT 4
50710: PUSH
50711: LD_INT 5
50713: PUSH
50714: EMPTY
50715: LIST
50716: LIST
50717: PUSH
50718: LD_INT 3
50720: PUSH
50721: LD_INT 4
50723: PUSH
50724: EMPTY
50725: LIST
50726: LIST
50727: PUSH
50728: LD_INT 3
50730: PUSH
50731: LD_INT 3
50733: PUSH
50734: EMPTY
50735: LIST
50736: LIST
50737: PUSH
50738: LD_INT 5
50740: PUSH
50741: LD_INT 3
50743: PUSH
50744: EMPTY
50745: LIST
50746: LIST
50747: PUSH
50748: LD_INT 3
50750: PUSH
50751: LD_INT 5
50753: PUSH
50754: EMPTY
50755: LIST
50756: LIST
50757: PUSH
50758: LD_INT 0
50760: PUSH
50761: LD_INT 3
50763: PUSH
50764: EMPTY
50765: LIST
50766: LIST
50767: PUSH
50768: LD_INT 0
50770: PUSH
50771: LD_INT 2
50773: PUSH
50774: EMPTY
50775: LIST
50776: LIST
50777: PUSH
50778: LD_INT 1
50780: PUSH
50781: LD_INT 3
50783: PUSH
50784: EMPTY
50785: LIST
50786: LIST
50787: PUSH
50788: LD_INT 1
50790: PUSH
50791: LD_INT 4
50793: PUSH
50794: EMPTY
50795: LIST
50796: LIST
50797: PUSH
50798: LD_INT 0
50800: PUSH
50801: LD_INT 4
50803: PUSH
50804: EMPTY
50805: LIST
50806: LIST
50807: PUSH
50808: LD_INT 1
50810: NEG
50811: PUSH
50812: LD_INT 3
50814: PUSH
50815: EMPTY
50816: LIST
50817: LIST
50818: PUSH
50819: LD_INT 1
50821: NEG
50822: PUSH
50823: LD_INT 2
50825: PUSH
50826: EMPTY
50827: LIST
50828: LIST
50829: PUSH
50830: LD_INT 2
50832: PUSH
50833: LD_INT 4
50835: PUSH
50836: EMPTY
50837: LIST
50838: LIST
50839: PUSH
50840: LD_INT 2
50842: NEG
50843: PUSH
50844: LD_INT 2
50846: PUSH
50847: EMPTY
50848: LIST
50849: LIST
50850: PUSH
50851: LD_INT 4
50853: NEG
50854: PUSH
50855: LD_INT 0
50857: PUSH
50858: EMPTY
50859: LIST
50860: LIST
50861: PUSH
50862: LD_INT 4
50864: NEG
50865: PUSH
50866: LD_INT 1
50868: NEG
50869: PUSH
50870: EMPTY
50871: LIST
50872: LIST
50873: PUSH
50874: LD_INT 3
50876: NEG
50877: PUSH
50878: LD_INT 0
50880: PUSH
50881: EMPTY
50882: LIST
50883: LIST
50884: PUSH
50885: LD_INT 3
50887: NEG
50888: PUSH
50889: LD_INT 1
50891: PUSH
50892: EMPTY
50893: LIST
50894: LIST
50895: PUSH
50896: LD_INT 4
50898: NEG
50899: PUSH
50900: LD_INT 1
50902: PUSH
50903: EMPTY
50904: LIST
50905: LIST
50906: PUSH
50907: LD_INT 5
50909: NEG
50910: PUSH
50911: LD_INT 0
50913: PUSH
50914: EMPTY
50915: LIST
50916: LIST
50917: PUSH
50918: LD_INT 5
50920: NEG
50921: PUSH
50922: LD_INT 1
50924: NEG
50925: PUSH
50926: EMPTY
50927: LIST
50928: LIST
50929: PUSH
50930: LD_INT 5
50932: NEG
50933: PUSH
50934: LD_INT 2
50936: NEG
50937: PUSH
50938: EMPTY
50939: LIST
50940: LIST
50941: PUSH
50942: LD_INT 3
50944: NEG
50945: PUSH
50946: LD_INT 2
50948: PUSH
50949: EMPTY
50950: LIST
50951: LIST
50952: PUSH
50953: EMPTY
50954: LIST
50955: LIST
50956: LIST
50957: LIST
50958: LIST
50959: LIST
50960: LIST
50961: LIST
50962: LIST
50963: LIST
50964: LIST
50965: LIST
50966: LIST
50967: LIST
50968: LIST
50969: LIST
50970: LIST
50971: LIST
50972: LIST
50973: LIST
50974: LIST
50975: LIST
50976: LIST
50977: LIST
50978: LIST
50979: LIST
50980: LIST
50981: LIST
50982: LIST
50983: LIST
50984: LIST
50985: LIST
50986: LIST
50987: LIST
50988: LIST
50989: LIST
50990: LIST
50991: LIST
50992: LIST
50993: LIST
50994: LIST
50995: LIST
50996: LIST
50997: LIST
50998: LIST
50999: ST_TO_ADDR
// end ; end ;
51000: GO 51003
51002: POP
// case btype of b_depot , b_warehouse :
51003: LD_VAR 0 1
51007: PUSH
51008: LD_INT 0
51010: DOUBLE
51011: EQUAL
51012: IFTRUE 51022
51014: LD_INT 1
51016: DOUBLE
51017: EQUAL
51018: IFTRUE 51022
51020: GO 51223
51022: POP
// case nation of nation_american :
51023: LD_VAR 0 5
51027: PUSH
51028: LD_INT 1
51030: DOUBLE
51031: EQUAL
51032: IFTRUE 51036
51034: GO 51092
51036: POP
// temp_list = [ fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 ] [ dir + 1 ] ; nation_arabian :
51037: LD_ADDR_VAR 0 9
51041: PUSH
51042: LD_VAR 0 11
51046: PUSH
51047: LD_VAR 0 12
51051: PUSH
51052: LD_VAR 0 13
51056: PUSH
51057: LD_VAR 0 14
51061: PUSH
51062: LD_VAR 0 15
51066: PUSH
51067: LD_VAR 0 16
51071: PUSH
51072: EMPTY
51073: LIST
51074: LIST
51075: LIST
51076: LIST
51077: LIST
51078: LIST
51079: PUSH
51080: LD_VAR 0 4
51084: PUSH
51085: LD_INT 1
51087: PLUS
51088: ARRAY
51089: ST_TO_ADDR
51090: GO 51221
51092: LD_INT 2
51094: DOUBLE
51095: EQUAL
51096: IFTRUE 51100
51098: GO 51156
51100: POP
// temp_list = [ fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 ] [ dir + 1 ] ; nation_russian :
51101: LD_ADDR_VAR 0 9
51105: PUSH
51106: LD_VAR 0 17
51110: PUSH
51111: LD_VAR 0 18
51115: PUSH
51116: LD_VAR 0 19
51120: PUSH
51121: LD_VAR 0 20
51125: PUSH
51126: LD_VAR 0 21
51130: PUSH
51131: LD_VAR 0 22
51135: PUSH
51136: EMPTY
51137: LIST
51138: LIST
51139: LIST
51140: LIST
51141: LIST
51142: LIST
51143: PUSH
51144: LD_VAR 0 4
51148: PUSH
51149: LD_INT 1
51151: PLUS
51152: ARRAY
51153: ST_TO_ADDR
51154: GO 51221
51156: LD_INT 3
51158: DOUBLE
51159: EQUAL
51160: IFTRUE 51164
51162: GO 51220
51164: POP
// temp_list = [ fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
51165: LD_ADDR_VAR 0 9
51169: PUSH
51170: LD_VAR 0 23
51174: PUSH
51175: LD_VAR 0 24
51179: PUSH
51180: LD_VAR 0 25
51184: PUSH
51185: LD_VAR 0 26
51189: PUSH
51190: LD_VAR 0 27
51194: PUSH
51195: LD_VAR 0 28
51199: PUSH
51200: EMPTY
51201: LIST
51202: LIST
51203: LIST
51204: LIST
51205: LIST
51206: LIST
51207: PUSH
51208: LD_VAR 0 4
51212: PUSH
51213: LD_INT 1
51215: PLUS
51216: ARRAY
51217: ST_TO_ADDR
51218: GO 51221
51220: POP
51221: GO 51776
51223: LD_INT 2
51225: DOUBLE
51226: EQUAL
51227: IFTRUE 51237
51229: LD_INT 3
51231: DOUBLE
51232: EQUAL
51233: IFTRUE 51237
51235: GO 51293
51237: POP
// temp_list = [ fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
51238: LD_ADDR_VAR 0 9
51242: PUSH
51243: LD_VAR 0 29
51247: PUSH
51248: LD_VAR 0 30
51252: PUSH
51253: LD_VAR 0 31
51257: PUSH
51258: LD_VAR 0 32
51262: PUSH
51263: LD_VAR 0 33
51267: PUSH
51268: LD_VAR 0 34
51272: PUSH
51273: EMPTY
51274: LIST
51275: LIST
51276: LIST
51277: LIST
51278: LIST
51279: LIST
51280: PUSH
51281: LD_VAR 0 4
51285: PUSH
51286: LD_INT 1
51288: PLUS
51289: ARRAY
51290: ST_TO_ADDR
51291: GO 51776
51293: LD_INT 16
51295: DOUBLE
51296: EQUAL
51297: IFTRUE 51355
51299: LD_INT 17
51301: DOUBLE
51302: EQUAL
51303: IFTRUE 51355
51305: LD_INT 18
51307: DOUBLE
51308: EQUAL
51309: IFTRUE 51355
51311: LD_INT 19
51313: DOUBLE
51314: EQUAL
51315: IFTRUE 51355
51317: LD_INT 22
51319: DOUBLE
51320: EQUAL
51321: IFTRUE 51355
51323: LD_INT 20
51325: DOUBLE
51326: EQUAL
51327: IFTRUE 51355
51329: LD_INT 21
51331: DOUBLE
51332: EQUAL
51333: IFTRUE 51355
51335: LD_INT 23
51337: DOUBLE
51338: EQUAL
51339: IFTRUE 51355
51341: LD_INT 24
51343: DOUBLE
51344: EQUAL
51345: IFTRUE 51355
51347: LD_INT 25
51349: DOUBLE
51350: EQUAL
51351: IFTRUE 51355
51353: GO 51411
51355: POP
// temp_list = [ fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
51356: LD_ADDR_VAR 0 9
51360: PUSH
51361: LD_VAR 0 35
51365: PUSH
51366: LD_VAR 0 36
51370: PUSH
51371: LD_VAR 0 37
51375: PUSH
51376: LD_VAR 0 38
51380: PUSH
51381: LD_VAR 0 39
51385: PUSH
51386: LD_VAR 0 40
51390: PUSH
51391: EMPTY
51392: LIST
51393: LIST
51394: LIST
51395: LIST
51396: LIST
51397: LIST
51398: PUSH
51399: LD_VAR 0 4
51403: PUSH
51404: LD_INT 1
51406: PLUS
51407: ARRAY
51408: ST_TO_ADDR
51409: GO 51776
51411: LD_INT 6
51413: DOUBLE
51414: EQUAL
51415: IFTRUE 51467
51417: LD_INT 7
51419: DOUBLE
51420: EQUAL
51421: IFTRUE 51467
51423: LD_INT 8
51425: DOUBLE
51426: EQUAL
51427: IFTRUE 51467
51429: LD_INT 13
51431: DOUBLE
51432: EQUAL
51433: IFTRUE 51467
51435: LD_INT 12
51437: DOUBLE
51438: EQUAL
51439: IFTRUE 51467
51441: LD_INT 15
51443: DOUBLE
51444: EQUAL
51445: IFTRUE 51467
51447: LD_INT 11
51449: DOUBLE
51450: EQUAL
51451: IFTRUE 51467
51453: LD_INT 14
51455: DOUBLE
51456: EQUAL
51457: IFTRUE 51467
51459: LD_INT 10
51461: DOUBLE
51462: EQUAL
51463: IFTRUE 51467
51465: GO 51523
51467: POP
// temp_list = [ fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 ] [ dir + 1 ] ; b_control_tower :
51468: LD_ADDR_VAR 0 9
51472: PUSH
51473: LD_VAR 0 41
51477: PUSH
51478: LD_VAR 0 42
51482: PUSH
51483: LD_VAR 0 43
51487: PUSH
51488: LD_VAR 0 44
51492: PUSH
51493: LD_VAR 0 45
51497: PUSH
51498: LD_VAR 0 46
51502: PUSH
51503: EMPTY
51504: LIST
51505: LIST
51506: LIST
51507: LIST
51508: LIST
51509: LIST
51510: PUSH
51511: LD_VAR 0 4
51515: PUSH
51516: LD_INT 1
51518: PLUS
51519: ARRAY
51520: ST_TO_ADDR
51521: GO 51776
51523: LD_INT 36
51525: DOUBLE
51526: EQUAL
51527: IFTRUE 51531
51529: GO 51587
51531: POP
// temp_list = [ fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
51532: LD_ADDR_VAR 0 9
51536: PUSH
51537: LD_VAR 0 47
51541: PUSH
51542: LD_VAR 0 48
51546: PUSH
51547: LD_VAR 0 49
51551: PUSH
51552: LD_VAR 0 50
51556: PUSH
51557: LD_VAR 0 51
51561: PUSH
51562: LD_VAR 0 52
51566: PUSH
51567: EMPTY
51568: LIST
51569: LIST
51570: LIST
51571: LIST
51572: LIST
51573: LIST
51574: PUSH
51575: LD_VAR 0 4
51579: PUSH
51580: LD_INT 1
51582: PLUS
51583: ARRAY
51584: ST_TO_ADDR
51585: GO 51776
51587: LD_INT 4
51589: DOUBLE
51590: EQUAL
51591: IFTRUE 51613
51593: LD_INT 5
51595: DOUBLE
51596: EQUAL
51597: IFTRUE 51613
51599: LD_INT 34
51601: DOUBLE
51602: EQUAL
51603: IFTRUE 51613
51605: LD_INT 37
51607: DOUBLE
51608: EQUAL
51609: IFTRUE 51613
51611: GO 51669
51613: POP
// temp_list = [ fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
51614: LD_ADDR_VAR 0 9
51618: PUSH
51619: LD_VAR 0 53
51623: PUSH
51624: LD_VAR 0 54
51628: PUSH
51629: LD_VAR 0 55
51633: PUSH
51634: LD_VAR 0 56
51638: PUSH
51639: LD_VAR 0 57
51643: PUSH
51644: LD_VAR 0 58
51648: PUSH
51649: EMPTY
51650: LIST
51651: LIST
51652: LIST
51653: LIST
51654: LIST
51655: LIST
51656: PUSH
51657: LD_VAR 0 4
51661: PUSH
51662: LD_INT 1
51664: PLUS
51665: ARRAY
51666: ST_TO_ADDR
51667: GO 51776
51669: LD_INT 31
51671: DOUBLE
51672: EQUAL
51673: IFTRUE 51719
51675: LD_INT 32
51677: DOUBLE
51678: EQUAL
51679: IFTRUE 51719
51681: LD_INT 33
51683: DOUBLE
51684: EQUAL
51685: IFTRUE 51719
51687: LD_INT 27
51689: DOUBLE
51690: EQUAL
51691: IFTRUE 51719
51693: LD_INT 26
51695: DOUBLE
51696: EQUAL
51697: IFTRUE 51719
51699: LD_INT 28
51701: DOUBLE
51702: EQUAL
51703: IFTRUE 51719
51705: LD_INT 29
51707: DOUBLE
51708: EQUAL
51709: IFTRUE 51719
51711: LD_INT 30
51713: DOUBLE
51714: EQUAL
51715: IFTRUE 51719
51717: GO 51775
51719: POP
// temp_list = [ fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ] [ dir + 1 ] ; end ;
51720: LD_ADDR_VAR 0 9
51724: PUSH
51725: LD_VAR 0 59
51729: PUSH
51730: LD_VAR 0 60
51734: PUSH
51735: LD_VAR 0 61
51739: PUSH
51740: LD_VAR 0 62
51744: PUSH
51745: LD_VAR 0 63
51749: PUSH
51750: LD_VAR 0 64
51754: PUSH
51755: EMPTY
51756: LIST
51757: LIST
51758: LIST
51759: LIST
51760: LIST
51761: LIST
51762: PUSH
51763: LD_VAR 0 4
51767: PUSH
51768: LD_INT 1
51770: PLUS
51771: ARRAY
51772: ST_TO_ADDR
51773: GO 51776
51775: POP
// temp_list2 = [ ] ;
51776: LD_ADDR_VAR 0 10
51780: PUSH
51781: EMPTY
51782: ST_TO_ADDR
// for i in temp_list do
51783: LD_ADDR_VAR 0 8
51787: PUSH
51788: LD_VAR 0 9
51792: PUSH
51793: FOR_IN
51794: IFFALSE 51846
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
51796: LD_ADDR_VAR 0 10
51800: PUSH
51801: LD_VAR 0 10
51805: PUSH
51806: LD_VAR 0 8
51810: PUSH
51811: LD_INT 1
51813: ARRAY
51814: PUSH
51815: LD_VAR 0 2
51819: PLUS
51820: PUSH
51821: LD_VAR 0 8
51825: PUSH
51826: LD_INT 2
51828: ARRAY
51829: PUSH
51830: LD_VAR 0 3
51834: PLUS
51835: PUSH
51836: EMPTY
51837: LIST
51838: LIST
51839: PUSH
51840: EMPTY
51841: LIST
51842: ADD
51843: ST_TO_ADDR
51844: GO 51793
51846: POP
51847: POP
// result = temp_list2 ;
51848: LD_ADDR_VAR 0 7
51852: PUSH
51853: LD_VAR 0 10
51857: ST_TO_ADDR
// end ;
51858: LD_VAR 0 7
51862: RET
// export function EnemyInRange ( unit , dist ) ; begin
51863: LD_INT 0
51865: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
51866: LD_ADDR_VAR 0 3
51870: PUSH
51871: LD_VAR 0 1
51875: PPUSH
51876: CALL_OW 255
51880: PPUSH
51881: LD_VAR 0 1
51885: PPUSH
51886: CALL_OW 250
51890: PPUSH
51891: LD_VAR 0 1
51895: PPUSH
51896: CALL_OW 251
51900: PPUSH
51901: LD_VAR 0 2
51905: PPUSH
51906: CALL 25259 0 4
51910: PUSH
51911: LD_INT 4
51913: ARRAY
51914: ST_TO_ADDR
// end ;
51915: LD_VAR 0 3
51919: RET
// export function PlayerSeeMe ( unit ) ; begin
51920: LD_INT 0
51922: PPUSH
// result := See ( your_side , unit ) ;
51923: LD_ADDR_VAR 0 2
51927: PUSH
51928: LD_OWVAR 2
51932: PPUSH
51933: LD_VAR 0 1
51937: PPUSH
51938: CALL_OW 292
51942: ST_TO_ADDR
// end ;
51943: LD_VAR 0 2
51947: RET
// export function ReverseDir ( unit ) ; begin
51948: LD_INT 0
51950: PPUSH
// if not unit then
51951: LD_VAR 0 1
51955: NOT
51956: IFFALSE 51960
// exit ;
51958: GO 51983
// result := ( GetDir ( unit ) + 3 ) mod 6 ;
51960: LD_ADDR_VAR 0 2
51964: PUSH
51965: LD_VAR 0 1
51969: PPUSH
51970: CALL_OW 254
51974: PUSH
51975: LD_INT 3
51977: PLUS
51978: PUSH
51979: LD_INT 6
51981: MOD
51982: ST_TO_ADDR
// end ;
51983: LD_VAR 0 2
51987: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tmp , hex ; begin
51988: LD_INT 0
51990: PPUSH
51991: PPUSH
51992: PPUSH
51993: PPUSH
51994: PPUSH
// if not hexes then
51995: LD_VAR 0 2
51999: NOT
52000: IFFALSE 52004
// exit ;
52002: GO 52152
// dist := 9999 ;
52004: LD_ADDR_VAR 0 5
52008: PUSH
52009: LD_INT 9999
52011: ST_TO_ADDR
// for i = 1 to hexes do
52012: LD_ADDR_VAR 0 4
52016: PUSH
52017: DOUBLE
52018: LD_INT 1
52020: DEC
52021: ST_TO_ADDR
52022: LD_VAR 0 2
52026: PUSH
52027: FOR_TO
52028: IFFALSE 52140
// begin if GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) < dist then
52030: LD_VAR 0 1
52034: PPUSH
52035: LD_VAR 0 2
52039: PUSH
52040: LD_VAR 0 4
52044: ARRAY
52045: PUSH
52046: LD_INT 1
52048: ARRAY
52049: PPUSH
52050: LD_VAR 0 2
52054: PUSH
52055: LD_VAR 0 4
52059: ARRAY
52060: PUSH
52061: LD_INT 2
52063: ARRAY
52064: PPUSH
52065: CALL_OW 297
52069: PUSH
52070: LD_VAR 0 5
52074: LESS
52075: IFFALSE 52138
// begin hex := hexes [ i ] ;
52077: LD_ADDR_VAR 0 7
52081: PUSH
52082: LD_VAR 0 2
52086: PUSH
52087: LD_VAR 0 4
52091: ARRAY
52092: ST_TO_ADDR
// dist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
52093: LD_ADDR_VAR 0 5
52097: PUSH
52098: LD_VAR 0 1
52102: PPUSH
52103: LD_VAR 0 2
52107: PUSH
52108: LD_VAR 0 4
52112: ARRAY
52113: PUSH
52114: LD_INT 1
52116: ARRAY
52117: PPUSH
52118: LD_VAR 0 2
52122: PUSH
52123: LD_VAR 0 4
52127: ARRAY
52128: PUSH
52129: LD_INT 2
52131: ARRAY
52132: PPUSH
52133: CALL_OW 297
52137: ST_TO_ADDR
// end ; end ;
52138: GO 52027
52140: POP
52141: POP
// result := hex ;
52142: LD_ADDR_VAR 0 3
52146: PUSH
52147: LD_VAR 0 7
52151: ST_TO_ADDR
// end ;
52152: LD_VAR 0 3
52156: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
52157: LD_INT 0
52159: PPUSH
52160: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
52161: LD_VAR 0 1
52165: NOT
52166: PUSH
52167: LD_VAR 0 1
52171: PUSH
52172: LD_INT 21
52174: PUSH
52175: LD_INT 2
52177: PUSH
52178: EMPTY
52179: LIST
52180: LIST
52181: PUSH
52182: LD_INT 23
52184: PUSH
52185: LD_INT 2
52187: PUSH
52188: EMPTY
52189: LIST
52190: LIST
52191: PUSH
52192: EMPTY
52193: LIST
52194: LIST
52195: PPUSH
52196: CALL_OW 69
52200: IN
52201: NOT
52202: OR
52203: IFFALSE 52207
// exit ;
52205: GO 52254
// for i = 1 to 3 do
52207: LD_ADDR_VAR 0 3
52211: PUSH
52212: DOUBLE
52213: LD_INT 1
52215: DEC
52216: ST_TO_ADDR
52217: LD_INT 3
52219: PUSH
52220: FOR_TO
52221: IFFALSE 52252
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
52223: LD_VAR 0 1
52227: PPUSH
52228: CALL_OW 250
52232: PPUSH
52233: LD_VAR 0 1
52237: PPUSH
52238: CALL_OW 251
52242: PPUSH
52243: LD_INT 1
52245: PPUSH
52246: CALL_OW 453
52250: GO 52220
52252: POP
52253: POP
// end ;
52254: LD_VAR 0 2
52258: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
52259: LD_INT 0
52261: PPUSH
52262: PPUSH
52263: PPUSH
52264: PPUSH
52265: PPUSH
52266: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
52267: LD_VAR 0 1
52271: NOT
52272: PUSH
52273: LD_VAR 0 2
52277: NOT
52278: OR
52279: PUSH
52280: LD_VAR 0 1
52284: PPUSH
52285: CALL_OW 314
52289: OR
52290: IFFALSE 52294
// exit ;
52292: GO 52735
// x := GetX ( enemy_unit ) ;
52294: LD_ADDR_VAR 0 7
52298: PUSH
52299: LD_VAR 0 2
52303: PPUSH
52304: CALL_OW 250
52308: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
52309: LD_ADDR_VAR 0 8
52313: PUSH
52314: LD_VAR 0 2
52318: PPUSH
52319: CALL_OW 251
52323: ST_TO_ADDR
// if not x or not y then
52324: LD_VAR 0 7
52328: NOT
52329: PUSH
52330: LD_VAR 0 8
52334: NOT
52335: OR
52336: IFFALSE 52340
// exit ;
52338: GO 52735
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
52340: LD_ADDR_VAR 0 6
52344: PUSH
52345: LD_VAR 0 7
52349: PPUSH
52350: LD_INT 0
52352: PPUSH
52353: LD_INT 4
52355: PPUSH
52356: CALL_OW 272
52360: PUSH
52361: LD_VAR 0 8
52365: PPUSH
52366: LD_INT 0
52368: PPUSH
52369: LD_INT 4
52371: PPUSH
52372: CALL_OW 273
52376: PUSH
52377: EMPTY
52378: LIST
52379: LIST
52380: PUSH
52381: LD_VAR 0 7
52385: PPUSH
52386: LD_INT 1
52388: PPUSH
52389: LD_INT 4
52391: PPUSH
52392: CALL_OW 272
52396: PUSH
52397: LD_VAR 0 8
52401: PPUSH
52402: LD_INT 1
52404: PPUSH
52405: LD_INT 4
52407: PPUSH
52408: CALL_OW 273
52412: PUSH
52413: EMPTY
52414: LIST
52415: LIST
52416: PUSH
52417: LD_VAR 0 7
52421: PPUSH
52422: LD_INT 2
52424: PPUSH
52425: LD_INT 4
52427: PPUSH
52428: CALL_OW 272
52432: PUSH
52433: LD_VAR 0 8
52437: PPUSH
52438: LD_INT 2
52440: PPUSH
52441: LD_INT 4
52443: PPUSH
52444: CALL_OW 273
52448: PUSH
52449: EMPTY
52450: LIST
52451: LIST
52452: PUSH
52453: LD_VAR 0 7
52457: PPUSH
52458: LD_INT 3
52460: PPUSH
52461: LD_INT 4
52463: PPUSH
52464: CALL_OW 272
52468: PUSH
52469: LD_VAR 0 8
52473: PPUSH
52474: LD_INT 3
52476: PPUSH
52477: LD_INT 4
52479: PPUSH
52480: CALL_OW 273
52484: PUSH
52485: EMPTY
52486: LIST
52487: LIST
52488: PUSH
52489: LD_VAR 0 7
52493: PPUSH
52494: LD_INT 4
52496: PPUSH
52497: LD_INT 4
52499: PPUSH
52500: CALL_OW 272
52504: PUSH
52505: LD_VAR 0 8
52509: PPUSH
52510: LD_INT 4
52512: PPUSH
52513: LD_INT 4
52515: PPUSH
52516: CALL_OW 273
52520: PUSH
52521: EMPTY
52522: LIST
52523: LIST
52524: PUSH
52525: LD_VAR 0 7
52529: PPUSH
52530: LD_INT 5
52532: PPUSH
52533: LD_INT 4
52535: PPUSH
52536: CALL_OW 272
52540: PUSH
52541: LD_VAR 0 8
52545: PPUSH
52546: LD_INT 5
52548: PPUSH
52549: LD_INT 4
52551: PPUSH
52552: CALL_OW 273
52556: PUSH
52557: EMPTY
52558: LIST
52559: LIST
52560: PUSH
52561: EMPTY
52562: LIST
52563: LIST
52564: LIST
52565: LIST
52566: LIST
52567: LIST
52568: ST_TO_ADDR
// for i = tmp downto 1 do
52569: LD_ADDR_VAR 0 4
52573: PUSH
52574: DOUBLE
52575: LD_VAR 0 6
52579: INC
52580: ST_TO_ADDR
52581: LD_INT 1
52583: PUSH
52584: FOR_DOWNTO
52585: IFFALSE 52686
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
52587: LD_VAR 0 6
52591: PUSH
52592: LD_VAR 0 4
52596: ARRAY
52597: PUSH
52598: LD_INT 1
52600: ARRAY
52601: PPUSH
52602: LD_VAR 0 6
52606: PUSH
52607: LD_VAR 0 4
52611: ARRAY
52612: PUSH
52613: LD_INT 2
52615: ARRAY
52616: PPUSH
52617: CALL_OW 488
52621: NOT
52622: PUSH
52623: LD_VAR 0 6
52627: PUSH
52628: LD_VAR 0 4
52632: ARRAY
52633: PUSH
52634: LD_INT 1
52636: ARRAY
52637: PPUSH
52638: LD_VAR 0 6
52642: PUSH
52643: LD_VAR 0 4
52647: ARRAY
52648: PUSH
52649: LD_INT 2
52651: ARRAY
52652: PPUSH
52653: CALL_OW 428
52657: PUSH
52658: LD_INT 0
52660: NONEQUAL
52661: OR
52662: IFFALSE 52684
// tmp := Delete ( tmp , i ) ;
52664: LD_ADDR_VAR 0 6
52668: PUSH
52669: LD_VAR 0 6
52673: PPUSH
52674: LD_VAR 0 4
52678: PPUSH
52679: CALL_OW 3
52683: ST_TO_ADDR
52684: GO 52584
52686: POP
52687: POP
// j := GetClosestHex ( unit , tmp ) ;
52688: LD_ADDR_VAR 0 5
52692: PUSH
52693: LD_VAR 0 1
52697: PPUSH
52698: LD_VAR 0 6
52702: PPUSH
52703: CALL 51988 0 2
52707: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
52708: LD_VAR 0 1
52712: PPUSH
52713: LD_VAR 0 5
52717: PUSH
52718: LD_INT 1
52720: ARRAY
52721: PPUSH
52722: LD_VAR 0 5
52726: PUSH
52727: LD_INT 2
52729: ARRAY
52730: PPUSH
52731: CALL_OW 111
// end ;
52735: LD_VAR 0 3
52739: RET
// export function PrepareApemanSoldier ( ) ; begin
52740: LD_INT 0
52742: PPUSH
// uc_nation := 0 ;
52743: LD_ADDR_OWVAR 21
52747: PUSH
52748: LD_INT 0
52750: ST_TO_ADDR
// hc_sex := sex_male ;
52751: LD_ADDR_OWVAR 27
52755: PUSH
52756: LD_INT 1
52758: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
52759: LD_ADDR_OWVAR 28
52763: PUSH
52764: LD_INT 15
52766: ST_TO_ADDR
// hc_gallery :=  ;
52767: LD_ADDR_OWVAR 33
52771: PUSH
52772: LD_STRING 
52774: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
52775: LD_ADDR_OWVAR 31
52779: PUSH
52780: LD_INT 0
52782: PPUSH
52783: LD_INT 3
52785: PPUSH
52786: CALL_OW 12
52790: PUSH
52791: LD_INT 0
52793: PPUSH
52794: LD_INT 3
52796: PPUSH
52797: CALL_OW 12
52801: PUSH
52802: LD_INT 0
52804: PUSH
52805: LD_INT 0
52807: PUSH
52808: EMPTY
52809: LIST
52810: LIST
52811: LIST
52812: LIST
52813: ST_TO_ADDR
// end ;
52814: LD_VAR 0 1
52818: RET
// export function PrepareApemanEngineer ( ) ; begin
52819: LD_INT 0
52821: PPUSH
// uc_nation := 0 ;
52822: LD_ADDR_OWVAR 21
52826: PUSH
52827: LD_INT 0
52829: ST_TO_ADDR
// hc_sex := sex_male ;
52830: LD_ADDR_OWVAR 27
52834: PUSH
52835: LD_INT 1
52837: ST_TO_ADDR
// hc_class := class_apeman_engineer ;
52838: LD_ADDR_OWVAR 28
52842: PUSH
52843: LD_INT 16
52845: ST_TO_ADDR
// hc_gallery :=  ;
52846: LD_ADDR_OWVAR 33
52850: PUSH
52851: LD_STRING 
52853: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
52854: LD_ADDR_OWVAR 31
52858: PUSH
52859: LD_INT 0
52861: PPUSH
52862: LD_INT 3
52864: PPUSH
52865: CALL_OW 12
52869: PUSH
52870: LD_INT 0
52872: PPUSH
52873: LD_INT 3
52875: PPUSH
52876: CALL_OW 12
52880: PUSH
52881: LD_INT 0
52883: PUSH
52884: LD_INT 0
52886: PUSH
52887: EMPTY
52888: LIST
52889: LIST
52890: LIST
52891: LIST
52892: ST_TO_ADDR
// end ;
52893: LD_VAR 0 1
52897: RET
// export function PrepareApeman ( agressivity ) ; begin
52898: LD_INT 0
52900: PPUSH
// uc_side := 0 ;
52901: LD_ADDR_OWVAR 20
52905: PUSH
52906: LD_INT 0
52908: ST_TO_ADDR
// uc_nation := 0 ;
52909: LD_ADDR_OWVAR 21
52913: PUSH
52914: LD_INT 0
52916: ST_TO_ADDR
// hc_sex := sex_male ;
52917: LD_ADDR_OWVAR 27
52921: PUSH
52922: LD_INT 1
52924: ST_TO_ADDR
// hc_class := class_apeman ;
52925: LD_ADDR_OWVAR 28
52929: PUSH
52930: LD_INT 12
52932: ST_TO_ADDR
// hc_gallery :=  ;
52933: LD_ADDR_OWVAR 33
52937: PUSH
52938: LD_STRING 
52940: ST_TO_ADDR
// hc_agressivity := rand ( - agressivity , agressivity ) ;
52941: LD_ADDR_OWVAR 35
52945: PUSH
52946: LD_VAR 0 1
52950: NEG
52951: PPUSH
52952: LD_VAR 0 1
52956: PPUSH
52957: CALL_OW 12
52961: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
52962: LD_ADDR_OWVAR 31
52966: PUSH
52967: LD_INT 0
52969: PPUSH
52970: LD_INT 3
52972: PPUSH
52973: CALL_OW 12
52977: PUSH
52978: LD_INT 0
52980: PPUSH
52981: LD_INT 3
52983: PPUSH
52984: CALL_OW 12
52988: PUSH
52989: LD_INT 0
52991: PUSH
52992: LD_INT 0
52994: PUSH
52995: EMPTY
52996: LIST
52997: LIST
52998: LIST
52999: LIST
53000: ST_TO_ADDR
// end ;
53001: LD_VAR 0 2
53005: RET
// export function PrepareTiger ( agressivity ) ; begin
53006: LD_INT 0
53008: PPUSH
// uc_side := 0 ;
53009: LD_ADDR_OWVAR 20
53013: PUSH
53014: LD_INT 0
53016: ST_TO_ADDR
// uc_nation := 0 ;
53017: LD_ADDR_OWVAR 21
53021: PUSH
53022: LD_INT 0
53024: ST_TO_ADDR
// hc_class := class_tiger ;
53025: LD_ADDR_OWVAR 28
53029: PUSH
53030: LD_INT 14
53032: ST_TO_ADDR
// hc_gallery :=  ;
53033: LD_ADDR_OWVAR 33
53037: PUSH
53038: LD_STRING 
53040: ST_TO_ADDR
// hc_agressivity := rand ( - agressivity , agressivity ) ;
53041: LD_ADDR_OWVAR 35
53045: PUSH
53046: LD_VAR 0 1
53050: NEG
53051: PPUSH
53052: LD_VAR 0 1
53056: PPUSH
53057: CALL_OW 12
53061: ST_TO_ADDR
// end ;
53062: LD_VAR 0 2
53066: RET
// export function PrepareEnchidna ( ) ; begin
53067: LD_INT 0
53069: PPUSH
// uc_side := 0 ;
53070: LD_ADDR_OWVAR 20
53074: PUSH
53075: LD_INT 0
53077: ST_TO_ADDR
// uc_nation := 0 ;
53078: LD_ADDR_OWVAR 21
53082: PUSH
53083: LD_INT 0
53085: ST_TO_ADDR
// hc_class := class_baggie ;
53086: LD_ADDR_OWVAR 28
53090: PUSH
53091: LD_INT 13
53093: ST_TO_ADDR
// hc_gallery :=  ;
53094: LD_ADDR_OWVAR 33
53098: PUSH
53099: LD_STRING 
53101: ST_TO_ADDR
// end ;
53102: LD_VAR 0 1
53106: RET
// export function PrepareFrog ( ) ; begin
53107: LD_INT 0
53109: PPUSH
// uc_side := 0 ;
53110: LD_ADDR_OWVAR 20
53114: PUSH
53115: LD_INT 0
53117: ST_TO_ADDR
// uc_nation := 0 ;
53118: LD_ADDR_OWVAR 21
53122: PUSH
53123: LD_INT 0
53125: ST_TO_ADDR
// hc_class := class_frog ;
53126: LD_ADDR_OWVAR 28
53130: PUSH
53131: LD_INT 19
53133: ST_TO_ADDR
// hc_gallery :=  ;
53134: LD_ADDR_OWVAR 33
53138: PUSH
53139: LD_STRING 
53141: ST_TO_ADDR
// end ;
53142: LD_VAR 0 1
53146: RET
// export function PrepareFish ( ) ; begin
53147: LD_INT 0
53149: PPUSH
// uc_side := 0 ;
53150: LD_ADDR_OWVAR 20
53154: PUSH
53155: LD_INT 0
53157: ST_TO_ADDR
// uc_nation := 0 ;
53158: LD_ADDR_OWVAR 21
53162: PUSH
53163: LD_INT 0
53165: ST_TO_ADDR
// hc_class := class_fish ;
53166: LD_ADDR_OWVAR 28
53170: PUSH
53171: LD_INT 20
53173: ST_TO_ADDR
// hc_gallery :=  ;
53174: LD_ADDR_OWVAR 33
53178: PUSH
53179: LD_STRING 
53181: ST_TO_ADDR
// end ;
53182: LD_VAR 0 1
53186: RET
// export function PrepareBird ( ) ; begin
53187: LD_INT 0
53189: PPUSH
// uc_side := 0 ;
53190: LD_ADDR_OWVAR 20
53194: PUSH
53195: LD_INT 0
53197: ST_TO_ADDR
// uc_nation := 0 ;
53198: LD_ADDR_OWVAR 21
53202: PUSH
53203: LD_INT 0
53205: ST_TO_ADDR
// hc_class := class_phororhacos ;
53206: LD_ADDR_OWVAR 28
53210: PUSH
53211: LD_INT 18
53213: ST_TO_ADDR
// hc_gallery :=  ;
53214: LD_ADDR_OWVAR 33
53218: PUSH
53219: LD_STRING 
53221: ST_TO_ADDR
// end ;
53222: LD_VAR 0 1
53226: RET
// export function PrepareHorse ( ) ; begin
53227: LD_INT 0
53229: PPUSH
// uc_side := 0 ;
53230: LD_ADDR_OWVAR 20
53234: PUSH
53235: LD_INT 0
53237: ST_TO_ADDR
// uc_nation := 0 ;
53238: LD_ADDR_OWVAR 21
53242: PUSH
53243: LD_INT 0
53245: ST_TO_ADDR
// hc_class := class_horse ;
53246: LD_ADDR_OWVAR 28
53250: PUSH
53251: LD_INT 21
53253: ST_TO_ADDR
// hc_gallery :=  ;
53254: LD_ADDR_OWVAR 33
53258: PUSH
53259: LD_STRING 
53261: ST_TO_ADDR
// end ;
53262: LD_VAR 0 1
53266: RET
// export function PrepareMastodont ( ) ; begin
53267: LD_INT 0
53269: PPUSH
// uc_side := 0 ;
53270: LD_ADDR_OWVAR 20
53274: PUSH
53275: LD_INT 0
53277: ST_TO_ADDR
// uc_nation := 0 ;
53278: LD_ADDR_OWVAR 21
53282: PUSH
53283: LD_INT 0
53285: ST_TO_ADDR
// vc_chassis := class_mastodont ;
53286: LD_ADDR_OWVAR 37
53290: PUSH
53291: LD_INT 31
53293: ST_TO_ADDR
// vc_control := control_rider ;
53294: LD_ADDR_OWVAR 38
53298: PUSH
53299: LD_INT 4
53301: ST_TO_ADDR
// end ;
53302: LD_VAR 0 1
53306: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
53307: LD_INT 0
53309: PPUSH
53310: PPUSH
53311: PPUSH
// uc_side = 0 ;
53312: LD_ADDR_OWVAR 20
53316: PUSH
53317: LD_INT 0
53319: ST_TO_ADDR
// uc_nation = 0 ;
53320: LD_ADDR_OWVAR 21
53324: PUSH
53325: LD_INT 0
53327: ST_TO_ADDR
// InitHc_All ( ) ;
53328: CALL_OW 584
// InitVc ;
53332: CALL_OW 20
// if mastodonts then
53336: LD_VAR 0 6
53340: IFFALSE 53407
// for i = 1 to mastodonts do
53342: LD_ADDR_VAR 0 11
53346: PUSH
53347: DOUBLE
53348: LD_INT 1
53350: DEC
53351: ST_TO_ADDR
53352: LD_VAR 0 6
53356: PUSH
53357: FOR_TO
53358: IFFALSE 53405
// begin vc_chassis := 31 ;
53360: LD_ADDR_OWVAR 37
53364: PUSH
53365: LD_INT 31
53367: ST_TO_ADDR
// vc_control := control_rider ;
53368: LD_ADDR_OWVAR 38
53372: PUSH
53373: LD_INT 4
53375: ST_TO_ADDR
// animal := CreateVehicle ;
53376: LD_ADDR_VAR 0 12
53380: PUSH
53381: CALL_OW 45
53385: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
53386: LD_VAR 0 12
53390: PPUSH
53391: LD_VAR 0 8
53395: PPUSH
53396: LD_INT 0
53398: PPUSH
53399: CALL 55542 0 3
// end ;
53403: GO 53357
53405: POP
53406: POP
// if horses then
53407: LD_VAR 0 5
53411: IFFALSE 53478
// for i = 1 to horses do
53413: LD_ADDR_VAR 0 11
53417: PUSH
53418: DOUBLE
53419: LD_INT 1
53421: DEC
53422: ST_TO_ADDR
53423: LD_VAR 0 5
53427: PUSH
53428: FOR_TO
53429: IFFALSE 53476
// begin hc_class := 21 ;
53431: LD_ADDR_OWVAR 28
53435: PUSH
53436: LD_INT 21
53438: ST_TO_ADDR
// hc_gallery :=  ;
53439: LD_ADDR_OWVAR 33
53443: PUSH
53444: LD_STRING 
53446: ST_TO_ADDR
// animal := CreateHuman ;
53447: LD_ADDR_VAR 0 12
53451: PUSH
53452: CALL_OW 44
53456: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
53457: LD_VAR 0 12
53461: PPUSH
53462: LD_VAR 0 8
53466: PPUSH
53467: LD_INT 0
53469: PPUSH
53470: CALL 55542 0 3
// end ;
53474: GO 53428
53476: POP
53477: POP
// if birds then
53478: LD_VAR 0 1
53482: IFFALSE 53549
// for i = 1 to birds do
53484: LD_ADDR_VAR 0 11
53488: PUSH
53489: DOUBLE
53490: LD_INT 1
53492: DEC
53493: ST_TO_ADDR
53494: LD_VAR 0 1
53498: PUSH
53499: FOR_TO
53500: IFFALSE 53547
// begin hc_class = 18 ;
53502: LD_ADDR_OWVAR 28
53506: PUSH
53507: LD_INT 18
53509: ST_TO_ADDR
// hc_gallery =  ;
53510: LD_ADDR_OWVAR 33
53514: PUSH
53515: LD_STRING 
53517: ST_TO_ADDR
// animal := CreateHuman ;
53518: LD_ADDR_VAR 0 12
53522: PUSH
53523: CALL_OW 44
53527: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
53528: LD_VAR 0 12
53532: PPUSH
53533: LD_VAR 0 8
53537: PPUSH
53538: LD_INT 0
53540: PPUSH
53541: CALL 55542 0 3
// end ;
53545: GO 53499
53547: POP
53548: POP
// if tigers then
53549: LD_VAR 0 2
53553: IFFALSE 53637
// for i = 1 to tigers do
53555: LD_ADDR_VAR 0 11
53559: PUSH
53560: DOUBLE
53561: LD_INT 1
53563: DEC
53564: ST_TO_ADDR
53565: LD_VAR 0 2
53569: PUSH
53570: FOR_TO
53571: IFFALSE 53635
// begin hc_class = class_tiger ;
53573: LD_ADDR_OWVAR 28
53577: PUSH
53578: LD_INT 14
53580: ST_TO_ADDR
// hc_gallery =  ;
53581: LD_ADDR_OWVAR 33
53585: PUSH
53586: LD_STRING 
53588: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
53589: LD_ADDR_OWVAR 35
53593: PUSH
53594: LD_INT 7
53596: NEG
53597: PPUSH
53598: LD_INT 7
53600: PPUSH
53601: CALL_OW 12
53605: ST_TO_ADDR
// animal := CreateHuman ;
53606: LD_ADDR_VAR 0 12
53610: PUSH
53611: CALL_OW 44
53615: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
53616: LD_VAR 0 12
53620: PPUSH
53621: LD_VAR 0 8
53625: PPUSH
53626: LD_INT 0
53628: PPUSH
53629: CALL 55542 0 3
// end ;
53633: GO 53570
53635: POP
53636: POP
// if apemans then
53637: LD_VAR 0 3
53641: IFFALSE 53764
// for i = 1 to apemans do
53643: LD_ADDR_VAR 0 11
53647: PUSH
53648: DOUBLE
53649: LD_INT 1
53651: DEC
53652: ST_TO_ADDR
53653: LD_VAR 0 3
53657: PUSH
53658: FOR_TO
53659: IFFALSE 53762
// begin hc_class = class_apeman ;
53661: LD_ADDR_OWVAR 28
53665: PUSH
53666: LD_INT 12
53668: ST_TO_ADDR
// hc_gallery =  ;
53669: LD_ADDR_OWVAR 33
53673: PUSH
53674: LD_STRING 
53676: ST_TO_ADDR
// hc_agressivity = rand ( - 2 , 2 ) ;
53677: LD_ADDR_OWVAR 35
53681: PUSH
53682: LD_INT 2
53684: NEG
53685: PPUSH
53686: LD_INT 2
53688: PPUSH
53689: CALL_OW 12
53693: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
53694: LD_ADDR_OWVAR 31
53698: PUSH
53699: LD_INT 1
53701: PPUSH
53702: LD_INT 3
53704: PPUSH
53705: CALL_OW 12
53709: PUSH
53710: LD_INT 1
53712: PPUSH
53713: LD_INT 3
53715: PPUSH
53716: CALL_OW 12
53720: PUSH
53721: LD_INT 0
53723: PUSH
53724: LD_INT 0
53726: PUSH
53727: EMPTY
53728: LIST
53729: LIST
53730: LIST
53731: LIST
53732: ST_TO_ADDR
// animal := CreateHuman ;
53733: LD_ADDR_VAR 0 12
53737: PUSH
53738: CALL_OW 44
53742: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
53743: LD_VAR 0 12
53747: PPUSH
53748: LD_VAR 0 8
53752: PPUSH
53753: LD_INT 0
53755: PPUSH
53756: CALL 55542 0 3
// end ;
53760: GO 53658
53762: POP
53763: POP
// if enchidnas then
53764: LD_VAR 0 4
53768: IFFALSE 53835
// for i = 1 to enchidnas do
53770: LD_ADDR_VAR 0 11
53774: PUSH
53775: DOUBLE
53776: LD_INT 1
53778: DEC
53779: ST_TO_ADDR
53780: LD_VAR 0 4
53784: PUSH
53785: FOR_TO
53786: IFFALSE 53833
// begin hc_class = 13 ;
53788: LD_ADDR_OWVAR 28
53792: PUSH
53793: LD_INT 13
53795: ST_TO_ADDR
// hc_gallery =  ;
53796: LD_ADDR_OWVAR 33
53800: PUSH
53801: LD_STRING 
53803: ST_TO_ADDR
// animal := CreateHuman ;
53804: LD_ADDR_VAR 0 12
53808: PUSH
53809: CALL_OW 44
53813: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
53814: LD_VAR 0 12
53818: PPUSH
53819: LD_VAR 0 8
53823: PPUSH
53824: LD_INT 0
53826: PPUSH
53827: CALL 55542 0 3
// end ;
53831: GO 53785
53833: POP
53834: POP
// if fishes then
53835: LD_VAR 0 7
53839: IFFALSE 53906
// for i = 1 to fishes do
53841: LD_ADDR_VAR 0 11
53845: PUSH
53846: DOUBLE
53847: LD_INT 1
53849: DEC
53850: ST_TO_ADDR
53851: LD_VAR 0 7
53855: PUSH
53856: FOR_TO
53857: IFFALSE 53904
// begin hc_class = 20 ;
53859: LD_ADDR_OWVAR 28
53863: PUSH
53864: LD_INT 20
53866: ST_TO_ADDR
// hc_gallery =  ;
53867: LD_ADDR_OWVAR 33
53871: PUSH
53872: LD_STRING 
53874: ST_TO_ADDR
// animal := CreateHuman ;
53875: LD_ADDR_VAR 0 12
53879: PUSH
53880: CALL_OW 44
53884: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
53885: LD_VAR 0 12
53889: PPUSH
53890: LD_VAR 0 9
53894: PPUSH
53895: LD_INT 0
53897: PPUSH
53898: CALL 55542 0 3
// end ;
53902: GO 53856
53904: POP
53905: POP
// end ;
53906: LD_VAR 0 10
53910: RET
// export function WantHeal ( sci , unit ) ; begin
53911: LD_INT 0
53913: PPUSH
// if GetTaskList ( sci ) > 0 then
53914: LD_VAR 0 1
53918: PPUSH
53919: CALL_OW 437
53923: PUSH
53924: LD_INT 0
53926: GREATER
53927: IFFALSE 53997
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
53929: LD_VAR 0 1
53933: PPUSH
53934: CALL_OW 437
53938: PUSH
53939: LD_INT 1
53941: ARRAY
53942: PUSH
53943: LD_INT 1
53945: ARRAY
53946: PUSH
53947: LD_STRING l
53949: EQUAL
53950: PUSH
53951: LD_VAR 0 1
53955: PPUSH
53956: CALL_OW 437
53960: PUSH
53961: LD_INT 1
53963: ARRAY
53964: PUSH
53965: LD_INT 4
53967: ARRAY
53968: PUSH
53969: LD_VAR 0 2
53973: EQUAL
53974: AND
53975: IFFALSE 53987
// result := true else
53977: LD_ADDR_VAR 0 3
53981: PUSH
53982: LD_INT 1
53984: ST_TO_ADDR
53985: GO 53995
// result := false ;
53987: LD_ADDR_VAR 0 3
53991: PUSH
53992: LD_INT 0
53994: ST_TO_ADDR
// end else
53995: GO 54005
// result := false ;
53997: LD_ADDR_VAR 0 3
54001: PUSH
54002: LD_INT 0
54004: ST_TO_ADDR
// end ;
54005: LD_VAR 0 3
54009: RET
// export function HealTarget ( sci ) ; begin
54010: LD_INT 0
54012: PPUSH
// if not sci then
54013: LD_VAR 0 1
54017: NOT
54018: IFFALSE 54022
// exit ;
54020: GO 54087
// result := 0 ;
54022: LD_ADDR_VAR 0 2
54026: PUSH
54027: LD_INT 0
54029: ST_TO_ADDR
// if GetTaskList ( sci ) then
54030: LD_VAR 0 1
54034: PPUSH
54035: CALL_OW 437
54039: IFFALSE 54087
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
54041: LD_VAR 0 1
54045: PPUSH
54046: CALL_OW 437
54050: PUSH
54051: LD_INT 1
54053: ARRAY
54054: PUSH
54055: LD_INT 1
54057: ARRAY
54058: PUSH
54059: LD_STRING l
54061: EQUAL
54062: IFFALSE 54087
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
54064: LD_ADDR_VAR 0 2
54068: PUSH
54069: LD_VAR 0 1
54073: PPUSH
54074: CALL_OW 437
54078: PUSH
54079: LD_INT 1
54081: ARRAY
54082: PUSH
54083: LD_INT 4
54085: ARRAY
54086: ST_TO_ADDR
// end ;
54087: LD_VAR 0 2
54091: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
54092: LD_INT 0
54094: PPUSH
54095: PPUSH
54096: PPUSH
54097: PPUSH
// if not base_units then
54098: LD_VAR 0 1
54102: NOT
54103: IFFALSE 54107
// exit ;
54105: GO 54194
// result := false ;
54107: LD_ADDR_VAR 0 2
54111: PUSH
54112: LD_INT 0
54114: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
54115: LD_ADDR_VAR 0 5
54119: PUSH
54120: LD_VAR 0 1
54124: PPUSH
54125: LD_INT 21
54127: PUSH
54128: LD_INT 3
54130: PUSH
54131: EMPTY
54132: LIST
54133: LIST
54134: PPUSH
54135: CALL_OW 72
54139: ST_TO_ADDR
// if not tmp then
54140: LD_VAR 0 5
54144: NOT
54145: IFFALSE 54149
// exit ;
54147: GO 54194
// for i in tmp do
54149: LD_ADDR_VAR 0 3
54153: PUSH
54154: LD_VAR 0 5
54158: PUSH
54159: FOR_IN
54160: IFFALSE 54192
// begin result := EnemyInRange ( i , 22 ) ;
54162: LD_ADDR_VAR 0 2
54166: PUSH
54167: LD_VAR 0 3
54171: PPUSH
54172: LD_INT 22
54174: PPUSH
54175: CALL 51863 0 2
54179: ST_TO_ADDR
// if result then
54180: LD_VAR 0 2
54184: IFFALSE 54190
// exit ;
54186: POP
54187: POP
54188: GO 54194
// end ;
54190: GO 54159
54192: POP
54193: POP
// end ;
54194: LD_VAR 0 2
54198: RET
// export function FilterByTag ( units , tag ) ; begin
54199: LD_INT 0
54201: PPUSH
// result := UnitFilter ( units , [ f_tag , tag ] ) ;
54202: LD_ADDR_VAR 0 3
54206: PUSH
54207: LD_VAR 0 1
54211: PPUSH
54212: LD_INT 120
54214: PUSH
54215: LD_VAR 0 2
54219: PUSH
54220: EMPTY
54221: LIST
54222: LIST
54223: PPUSH
54224: CALL_OW 72
54228: ST_TO_ADDR
// end ;
54229: LD_VAR 0 3
54233: RET
// export function IsDriver ( un ) ; begin
54234: LD_INT 0
54236: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
54237: LD_ADDR_VAR 0 2
54241: PUSH
54242: LD_VAR 0 1
54246: PUSH
54247: LD_INT 55
54249: PUSH
54250: EMPTY
54251: LIST
54252: PPUSH
54253: CALL_OW 69
54257: IN
54258: ST_TO_ADDR
// end ;
54259: LD_VAR 0 2
54263: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
54264: LD_INT 0
54266: PPUSH
54267: PPUSH
// list := [ ] ;
54268: LD_ADDR_VAR 0 5
54272: PUSH
54273: EMPTY
54274: ST_TO_ADDR
// case d of 0 :
54275: LD_VAR 0 3
54279: PUSH
54280: LD_INT 0
54282: DOUBLE
54283: EQUAL
54284: IFTRUE 54288
54286: GO 54421
54288: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
54289: LD_ADDR_VAR 0 5
54293: PUSH
54294: LD_VAR 0 1
54298: PUSH
54299: LD_INT 4
54301: MINUS
54302: PUSH
54303: LD_VAR 0 2
54307: PUSH
54308: LD_INT 4
54310: MINUS
54311: PUSH
54312: LD_INT 2
54314: PUSH
54315: EMPTY
54316: LIST
54317: LIST
54318: LIST
54319: PUSH
54320: LD_VAR 0 1
54324: PUSH
54325: LD_INT 3
54327: MINUS
54328: PUSH
54329: LD_VAR 0 2
54333: PUSH
54334: LD_INT 1
54336: PUSH
54337: EMPTY
54338: LIST
54339: LIST
54340: LIST
54341: PUSH
54342: LD_VAR 0 1
54346: PUSH
54347: LD_INT 4
54349: PLUS
54350: PUSH
54351: LD_VAR 0 2
54355: PUSH
54356: LD_INT 4
54358: PUSH
54359: EMPTY
54360: LIST
54361: LIST
54362: LIST
54363: PUSH
54364: LD_VAR 0 1
54368: PUSH
54369: LD_INT 3
54371: PLUS
54372: PUSH
54373: LD_VAR 0 2
54377: PUSH
54378: LD_INT 3
54380: PLUS
54381: PUSH
54382: LD_INT 5
54384: PUSH
54385: EMPTY
54386: LIST
54387: LIST
54388: LIST
54389: PUSH
54390: LD_VAR 0 1
54394: PUSH
54395: LD_VAR 0 2
54399: PUSH
54400: LD_INT 4
54402: PLUS
54403: PUSH
54404: LD_INT 0
54406: PUSH
54407: EMPTY
54408: LIST
54409: LIST
54410: LIST
54411: PUSH
54412: EMPTY
54413: LIST
54414: LIST
54415: LIST
54416: LIST
54417: LIST
54418: ST_TO_ADDR
// end ; 1 :
54419: GO 55119
54421: LD_INT 1
54423: DOUBLE
54424: EQUAL
54425: IFTRUE 54429
54427: GO 54562
54429: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
54430: LD_ADDR_VAR 0 5
54434: PUSH
54435: LD_VAR 0 1
54439: PUSH
54440: LD_VAR 0 2
54444: PUSH
54445: LD_INT 4
54447: MINUS
54448: PUSH
54449: LD_INT 3
54451: PUSH
54452: EMPTY
54453: LIST
54454: LIST
54455: LIST
54456: PUSH
54457: LD_VAR 0 1
54461: PUSH
54462: LD_INT 3
54464: MINUS
54465: PUSH
54466: LD_VAR 0 2
54470: PUSH
54471: LD_INT 3
54473: MINUS
54474: PUSH
54475: LD_INT 2
54477: PUSH
54478: EMPTY
54479: LIST
54480: LIST
54481: LIST
54482: PUSH
54483: LD_VAR 0 1
54487: PUSH
54488: LD_INT 4
54490: MINUS
54491: PUSH
54492: LD_VAR 0 2
54496: PUSH
54497: LD_INT 1
54499: PUSH
54500: EMPTY
54501: LIST
54502: LIST
54503: LIST
54504: PUSH
54505: LD_VAR 0 1
54509: PUSH
54510: LD_VAR 0 2
54514: PUSH
54515: LD_INT 3
54517: PLUS
54518: PUSH
54519: LD_INT 0
54521: PUSH
54522: EMPTY
54523: LIST
54524: LIST
54525: LIST
54526: PUSH
54527: LD_VAR 0 1
54531: PUSH
54532: LD_INT 4
54534: PLUS
54535: PUSH
54536: LD_VAR 0 2
54540: PUSH
54541: LD_INT 4
54543: PLUS
54544: PUSH
54545: LD_INT 5
54547: PUSH
54548: EMPTY
54549: LIST
54550: LIST
54551: LIST
54552: PUSH
54553: EMPTY
54554: LIST
54555: LIST
54556: LIST
54557: LIST
54558: LIST
54559: ST_TO_ADDR
// end ; 2 :
54560: GO 55119
54562: LD_INT 2
54564: DOUBLE
54565: EQUAL
54566: IFTRUE 54570
54568: GO 54699
54570: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
54571: LD_ADDR_VAR 0 5
54575: PUSH
54576: LD_VAR 0 1
54580: PUSH
54581: LD_VAR 0 2
54585: PUSH
54586: LD_INT 3
54588: MINUS
54589: PUSH
54590: LD_INT 3
54592: PUSH
54593: EMPTY
54594: LIST
54595: LIST
54596: LIST
54597: PUSH
54598: LD_VAR 0 1
54602: PUSH
54603: LD_INT 4
54605: PLUS
54606: PUSH
54607: LD_VAR 0 2
54611: PUSH
54612: LD_INT 4
54614: PUSH
54615: EMPTY
54616: LIST
54617: LIST
54618: LIST
54619: PUSH
54620: LD_VAR 0 1
54624: PUSH
54625: LD_VAR 0 2
54629: PUSH
54630: LD_INT 4
54632: PLUS
54633: PUSH
54634: LD_INT 0
54636: PUSH
54637: EMPTY
54638: LIST
54639: LIST
54640: LIST
54641: PUSH
54642: LD_VAR 0 1
54646: PUSH
54647: LD_INT 3
54649: MINUS
54650: PUSH
54651: LD_VAR 0 2
54655: PUSH
54656: LD_INT 1
54658: PUSH
54659: EMPTY
54660: LIST
54661: LIST
54662: LIST
54663: PUSH
54664: LD_VAR 0 1
54668: PUSH
54669: LD_INT 4
54671: MINUS
54672: PUSH
54673: LD_VAR 0 2
54677: PUSH
54678: LD_INT 4
54680: MINUS
54681: PUSH
54682: LD_INT 2
54684: PUSH
54685: EMPTY
54686: LIST
54687: LIST
54688: LIST
54689: PUSH
54690: EMPTY
54691: LIST
54692: LIST
54693: LIST
54694: LIST
54695: LIST
54696: ST_TO_ADDR
// end ; 3 :
54697: GO 55119
54699: LD_INT 3
54701: DOUBLE
54702: EQUAL
54703: IFTRUE 54707
54705: GO 54840
54707: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
54708: LD_ADDR_VAR 0 5
54712: PUSH
54713: LD_VAR 0 1
54717: PUSH
54718: LD_INT 3
54720: PLUS
54721: PUSH
54722: LD_VAR 0 2
54726: PUSH
54727: LD_INT 4
54729: PUSH
54730: EMPTY
54731: LIST
54732: LIST
54733: LIST
54734: PUSH
54735: LD_VAR 0 1
54739: PUSH
54740: LD_INT 4
54742: PLUS
54743: PUSH
54744: LD_VAR 0 2
54748: PUSH
54749: LD_INT 4
54751: PLUS
54752: PUSH
54753: LD_INT 5
54755: PUSH
54756: EMPTY
54757: LIST
54758: LIST
54759: LIST
54760: PUSH
54761: LD_VAR 0 1
54765: PUSH
54766: LD_INT 4
54768: MINUS
54769: PUSH
54770: LD_VAR 0 2
54774: PUSH
54775: LD_INT 1
54777: PUSH
54778: EMPTY
54779: LIST
54780: LIST
54781: LIST
54782: PUSH
54783: LD_VAR 0 1
54787: PUSH
54788: LD_VAR 0 2
54792: PUSH
54793: LD_INT 4
54795: MINUS
54796: PUSH
54797: LD_INT 3
54799: PUSH
54800: EMPTY
54801: LIST
54802: LIST
54803: LIST
54804: PUSH
54805: LD_VAR 0 1
54809: PUSH
54810: LD_INT 3
54812: MINUS
54813: PUSH
54814: LD_VAR 0 2
54818: PUSH
54819: LD_INT 3
54821: MINUS
54822: PUSH
54823: LD_INT 2
54825: PUSH
54826: EMPTY
54827: LIST
54828: LIST
54829: LIST
54830: PUSH
54831: EMPTY
54832: LIST
54833: LIST
54834: LIST
54835: LIST
54836: LIST
54837: ST_TO_ADDR
// end ; 4 :
54838: GO 55119
54840: LD_INT 4
54842: DOUBLE
54843: EQUAL
54844: IFTRUE 54848
54846: GO 54981
54848: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
54849: LD_ADDR_VAR 0 5
54853: PUSH
54854: LD_VAR 0 1
54858: PUSH
54859: LD_VAR 0 2
54863: PUSH
54864: LD_INT 4
54866: PLUS
54867: PUSH
54868: LD_INT 0
54870: PUSH
54871: EMPTY
54872: LIST
54873: LIST
54874: LIST
54875: PUSH
54876: LD_VAR 0 1
54880: PUSH
54881: LD_INT 3
54883: PLUS
54884: PUSH
54885: LD_VAR 0 2
54889: PUSH
54890: LD_INT 3
54892: PLUS
54893: PUSH
54894: LD_INT 5
54896: PUSH
54897: EMPTY
54898: LIST
54899: LIST
54900: LIST
54901: PUSH
54902: LD_VAR 0 1
54906: PUSH
54907: LD_INT 4
54909: PLUS
54910: PUSH
54911: LD_VAR 0 2
54915: PUSH
54916: LD_INT 4
54918: PUSH
54919: EMPTY
54920: LIST
54921: LIST
54922: LIST
54923: PUSH
54924: LD_VAR 0 1
54928: PUSH
54929: LD_VAR 0 2
54933: PUSH
54934: LD_INT 3
54936: MINUS
54937: PUSH
54938: LD_INT 3
54940: PUSH
54941: EMPTY
54942: LIST
54943: LIST
54944: LIST
54945: PUSH
54946: LD_VAR 0 1
54950: PUSH
54951: LD_INT 4
54953: MINUS
54954: PUSH
54955: LD_VAR 0 2
54959: PUSH
54960: LD_INT 4
54962: MINUS
54963: PUSH
54964: LD_INT 2
54966: PUSH
54967: EMPTY
54968: LIST
54969: LIST
54970: LIST
54971: PUSH
54972: EMPTY
54973: LIST
54974: LIST
54975: LIST
54976: LIST
54977: LIST
54978: ST_TO_ADDR
// end ; 5 :
54979: GO 55119
54981: LD_INT 5
54983: DOUBLE
54984: EQUAL
54985: IFTRUE 54989
54987: GO 55118
54989: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
54990: LD_ADDR_VAR 0 5
54994: PUSH
54995: LD_VAR 0 1
54999: PUSH
55000: LD_INT 4
55002: MINUS
55003: PUSH
55004: LD_VAR 0 2
55008: PUSH
55009: LD_INT 1
55011: PUSH
55012: EMPTY
55013: LIST
55014: LIST
55015: LIST
55016: PUSH
55017: LD_VAR 0 1
55021: PUSH
55022: LD_VAR 0 2
55026: PUSH
55027: LD_INT 4
55029: MINUS
55030: PUSH
55031: LD_INT 3
55033: PUSH
55034: EMPTY
55035: LIST
55036: LIST
55037: LIST
55038: PUSH
55039: LD_VAR 0 1
55043: PUSH
55044: LD_INT 4
55046: PLUS
55047: PUSH
55048: LD_VAR 0 2
55052: PUSH
55053: LD_INT 4
55055: PLUS
55056: PUSH
55057: LD_INT 5
55059: PUSH
55060: EMPTY
55061: LIST
55062: LIST
55063: LIST
55064: PUSH
55065: LD_VAR 0 1
55069: PUSH
55070: LD_INT 3
55072: PLUS
55073: PUSH
55074: LD_VAR 0 2
55078: PUSH
55079: LD_INT 4
55081: PUSH
55082: EMPTY
55083: LIST
55084: LIST
55085: LIST
55086: PUSH
55087: LD_VAR 0 1
55091: PUSH
55092: LD_VAR 0 2
55096: PUSH
55097: LD_INT 3
55099: PLUS
55100: PUSH
55101: LD_INT 0
55103: PUSH
55104: EMPTY
55105: LIST
55106: LIST
55107: LIST
55108: PUSH
55109: EMPTY
55110: LIST
55111: LIST
55112: LIST
55113: LIST
55114: LIST
55115: ST_TO_ADDR
// end ; end ;
55116: GO 55119
55118: POP
// result := list ;
55119: LD_ADDR_VAR 0 4
55123: PUSH
55124: LD_VAR 0 5
55128: ST_TO_ADDR
// end ;
55129: LD_VAR 0 4
55133: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
55134: LD_INT 0
55136: PPUSH
55137: PPUSH
55138: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
55139: LD_VAR 0 1
55143: NOT
55144: PUSH
55145: LD_VAR 0 2
55149: PUSH
55150: LD_INT 1
55152: PUSH
55153: LD_INT 2
55155: PUSH
55156: LD_INT 3
55158: PUSH
55159: LD_INT 4
55161: PUSH
55162: EMPTY
55163: LIST
55164: LIST
55165: LIST
55166: LIST
55167: IN
55168: NOT
55169: OR
55170: IFFALSE 55174
// exit ;
55172: GO 55266
// tmp := [ ] ;
55174: LD_ADDR_VAR 0 5
55178: PUSH
55179: EMPTY
55180: ST_TO_ADDR
// for i in units do
55181: LD_ADDR_VAR 0 4
55185: PUSH
55186: LD_VAR 0 1
55190: PUSH
55191: FOR_IN
55192: IFFALSE 55235
// tmp := Insert ( tmp , tmp + 1 , GetSkill ( i , class ) ) ;
55194: LD_ADDR_VAR 0 5
55198: PUSH
55199: LD_VAR 0 5
55203: PPUSH
55204: LD_VAR 0 5
55208: PUSH
55209: LD_INT 1
55211: PLUS
55212: PPUSH
55213: LD_VAR 0 4
55217: PPUSH
55218: LD_VAR 0 2
55222: PPUSH
55223: CALL_OW 259
55227: PPUSH
55228: CALL_OW 2
55232: ST_TO_ADDR
55233: GO 55191
55235: POP
55236: POP
// if not tmp then
55237: LD_VAR 0 5
55241: NOT
55242: IFFALSE 55246
// exit ;
55244: GO 55266
// result := SortListByListDesc ( units , tmp ) ;
55246: LD_ADDR_VAR 0 3
55250: PUSH
55251: LD_VAR 0 1
55255: PPUSH
55256: LD_VAR 0 5
55260: PPUSH
55261: CALL_OW 77
55265: ST_TO_ADDR
// end ;
55266: LD_VAR 0 3
55270: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
55271: LD_INT 0
55273: PPUSH
55274: PPUSH
55275: PPUSH
// result := false ;
55276: LD_ADDR_VAR 0 3
55280: PUSH
55281: LD_INT 0
55283: ST_TO_ADDR
// x := GetX ( building ) ;
55284: LD_ADDR_VAR 0 4
55288: PUSH
55289: LD_VAR 0 2
55293: PPUSH
55294: CALL_OW 250
55298: ST_TO_ADDR
// y := GetY ( building ) ;
55299: LD_ADDR_VAR 0 5
55303: PUSH
55304: LD_VAR 0 2
55308: PPUSH
55309: CALL_OW 251
55313: ST_TO_ADDR
// if not building or not x or not y then
55314: LD_VAR 0 2
55318: NOT
55319: PUSH
55320: LD_VAR 0 4
55324: NOT
55325: OR
55326: PUSH
55327: LD_VAR 0 5
55331: NOT
55332: OR
55333: IFFALSE 55337
// exit ;
55335: GO 55429
// if GetTaskList ( unit ) then
55337: LD_VAR 0 1
55341: PPUSH
55342: CALL_OW 437
55346: IFFALSE 55429
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
55348: LD_STRING e
55350: PUSH
55351: LD_VAR 0 1
55355: PPUSH
55356: CALL_OW 437
55360: PUSH
55361: LD_INT 1
55363: ARRAY
55364: PUSH
55365: LD_INT 1
55367: ARRAY
55368: EQUAL
55369: PUSH
55370: LD_VAR 0 4
55374: PUSH
55375: LD_VAR 0 1
55379: PPUSH
55380: CALL_OW 437
55384: PUSH
55385: LD_INT 1
55387: ARRAY
55388: PUSH
55389: LD_INT 2
55391: ARRAY
55392: EQUAL
55393: AND
55394: PUSH
55395: LD_VAR 0 5
55399: PUSH
55400: LD_VAR 0 1
55404: PPUSH
55405: CALL_OW 437
55409: PUSH
55410: LD_INT 1
55412: ARRAY
55413: PUSH
55414: LD_INT 3
55416: ARRAY
55417: EQUAL
55418: AND
55419: IFFALSE 55429
// result := true end ;
55421: LD_ADDR_VAR 0 3
55425: PUSH
55426: LD_INT 1
55428: ST_TO_ADDR
// end ;
55429: LD_VAR 0 3
55433: RET
// export function UnitGoingToXY ( unit , x , y ) ; begin
55434: LD_INT 0
55436: PPUSH
// result := false ;
55437: LD_ADDR_VAR 0 4
55441: PUSH
55442: LD_INT 0
55444: ST_TO_ADDR
// if GetTaskList ( unit ) then
55445: LD_VAR 0 1
55449: PPUSH
55450: CALL_OW 437
55454: IFFALSE 55537
// begin if M = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
55456: LD_STRING M
55458: PUSH
55459: LD_VAR 0 1
55463: PPUSH
55464: CALL_OW 437
55468: PUSH
55469: LD_INT 1
55471: ARRAY
55472: PUSH
55473: LD_INT 1
55475: ARRAY
55476: EQUAL
55477: PUSH
55478: LD_VAR 0 2
55482: PUSH
55483: LD_VAR 0 1
55487: PPUSH
55488: CALL_OW 437
55492: PUSH
55493: LD_INT 1
55495: ARRAY
55496: PUSH
55497: LD_INT 2
55499: ARRAY
55500: EQUAL
55501: AND
55502: PUSH
55503: LD_VAR 0 3
55507: PUSH
55508: LD_VAR 0 1
55512: PPUSH
55513: CALL_OW 437
55517: PUSH
55518: LD_INT 1
55520: ARRAY
55521: PUSH
55522: LD_INT 3
55524: ARRAY
55525: EQUAL
55526: AND
55527: IFFALSE 55537
// result := true ;
55529: LD_ADDR_VAR 0 4
55533: PUSH
55534: LD_INT 1
55536: ST_TO_ADDR
// end ; end ;
55537: LD_VAR 0 4
55541: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
55542: LD_INT 0
55544: PPUSH
55545: PPUSH
55546: PPUSH
55547: PPUSH
// if not unit or not area then
55548: LD_VAR 0 1
55552: NOT
55553: PUSH
55554: LD_VAR 0 2
55558: NOT
55559: OR
55560: IFFALSE 55564
// exit ;
55562: GO 55728
// tmp := AreaToList ( area , i ) ;
55564: LD_ADDR_VAR 0 6
55568: PUSH
55569: LD_VAR 0 2
55573: PPUSH
55574: LD_VAR 0 5
55578: PPUSH
55579: CALL_OW 517
55583: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
55584: LD_ADDR_VAR 0 5
55588: PUSH
55589: DOUBLE
55590: LD_INT 1
55592: DEC
55593: ST_TO_ADDR
55594: LD_VAR 0 6
55598: PUSH
55599: LD_INT 1
55601: ARRAY
55602: PUSH
55603: FOR_TO
55604: IFFALSE 55726
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
55606: LD_ADDR_VAR 0 7
55610: PUSH
55611: LD_VAR 0 6
55615: PUSH
55616: LD_INT 1
55618: ARRAY
55619: PUSH
55620: LD_VAR 0 5
55624: ARRAY
55625: PUSH
55626: LD_VAR 0 6
55630: PUSH
55631: LD_INT 2
55633: ARRAY
55634: PUSH
55635: LD_VAR 0 5
55639: ARRAY
55640: PUSH
55641: EMPTY
55642: LIST
55643: LIST
55644: ST_TO_ADDR
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
55645: LD_VAR 0 7
55649: PUSH
55650: LD_INT 1
55652: ARRAY
55653: PPUSH
55654: LD_VAR 0 7
55658: PUSH
55659: LD_INT 2
55661: ARRAY
55662: PPUSH
55663: CALL_OW 428
55667: PUSH
55668: LD_INT 0
55670: EQUAL
55671: IFFALSE 55724
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
55673: LD_VAR 0 1
55677: PPUSH
55678: LD_VAR 0 7
55682: PUSH
55683: LD_INT 1
55685: ARRAY
55686: PPUSH
55687: LD_VAR 0 7
55691: PUSH
55692: LD_INT 2
55694: ARRAY
55695: PPUSH
55696: LD_VAR 0 3
55700: PPUSH
55701: CALL_OW 48
// result := IsPlaced ( unit ) ;
55705: LD_ADDR_VAR 0 4
55709: PUSH
55710: LD_VAR 0 1
55714: PPUSH
55715: CALL_OW 305
55719: ST_TO_ADDR
// exit ;
55720: POP
55721: POP
55722: GO 55728
// end ; end ;
55724: GO 55603
55726: POP
55727: POP
// end ;
55728: LD_VAR 0 4
55732: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
55733: LD_INT 0
55735: PPUSH
55736: PPUSH
55737: PPUSH
// if not side or side > 8 then
55738: LD_VAR 0 1
55742: NOT
55743: PUSH
55744: LD_VAR 0 1
55748: PUSH
55749: LD_INT 8
55751: GREATER
55752: OR
55753: IFFALSE 55757
// exit ;
55755: GO 55944
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
55757: LD_ADDR_VAR 0 4
55761: PUSH
55762: LD_INT 22
55764: PUSH
55765: LD_VAR 0 1
55769: PUSH
55770: EMPTY
55771: LIST
55772: LIST
55773: PUSH
55774: LD_INT 21
55776: PUSH
55777: LD_INT 3
55779: PUSH
55780: EMPTY
55781: LIST
55782: LIST
55783: PUSH
55784: EMPTY
55785: LIST
55786: LIST
55787: PPUSH
55788: CALL_OW 69
55792: ST_TO_ADDR
// if not tmp then
55793: LD_VAR 0 4
55797: NOT
55798: IFFALSE 55802
// exit ;
55800: GO 55944
// enable_addtolog := true ;
55802: LD_ADDR_OWVAR 81
55806: PUSH
55807: LD_INT 1
55809: ST_TO_ADDR
// AddToLog ( [ ) ;
55810: LD_STRING [
55812: PPUSH
55813: CALL_OW 561
// for i in tmp do
55817: LD_ADDR_VAR 0 3
55821: PUSH
55822: LD_VAR 0 4
55826: PUSH
55827: FOR_IN
55828: IFFALSE 55935
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
55830: LD_STRING [
55832: PUSH
55833: LD_VAR 0 3
55837: PPUSH
55838: CALL_OW 266
55842: STR
55843: PUSH
55844: LD_STRING , 
55846: STR
55847: PUSH
55848: LD_VAR 0 3
55852: PPUSH
55853: CALL_OW 250
55857: STR
55858: PUSH
55859: LD_STRING , 
55861: STR
55862: PUSH
55863: LD_VAR 0 3
55867: PPUSH
55868: CALL_OW 251
55872: STR
55873: PUSH
55874: LD_STRING , 
55876: STR
55877: PUSH
55878: LD_VAR 0 3
55882: PPUSH
55883: CALL_OW 254
55887: STR
55888: PUSH
55889: LD_STRING , 
55891: STR
55892: PUSH
55893: LD_VAR 0 3
55897: PPUSH
55898: LD_INT 1
55900: PPUSH
55901: CALL_OW 268
55905: STR
55906: PUSH
55907: LD_STRING , 
55909: STR
55910: PUSH
55911: LD_VAR 0 3
55915: PPUSH
55916: LD_INT 2
55918: PPUSH
55919: CALL_OW 268
55923: STR
55924: PUSH
55925: LD_STRING ],
55927: STR
55928: PPUSH
55929: CALL_OW 561
// end ;
55933: GO 55827
55935: POP
55936: POP
// AddToLog ( ]; ) ;
55937: LD_STRING ];
55939: PPUSH
55940: CALL_OW 561
// end ;
55944: LD_VAR 0 2
55948: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
55949: LD_INT 0
55951: PPUSH
55952: PPUSH
55953: PPUSH
55954: PPUSH
55955: PPUSH
// if not area or not rate or not max then
55956: LD_VAR 0 1
55960: NOT
55961: PUSH
55962: LD_VAR 0 2
55966: NOT
55967: OR
55968: PUSH
55969: LD_VAR 0 4
55973: NOT
55974: OR
55975: IFFALSE 55979
// exit ;
55977: GO 56168
// while 1 do
55979: LD_INT 1
55981: IFFALSE 56168
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
55983: LD_ADDR_VAR 0 9
55987: PUSH
55988: LD_VAR 0 1
55992: PPUSH
55993: LD_INT 1
55995: PPUSH
55996: CALL_OW 287
56000: PUSH
56001: LD_INT 10
56003: MUL
56004: ST_TO_ADDR
// r := rate / 10 ;
56005: LD_ADDR_VAR 0 7
56009: PUSH
56010: LD_VAR 0 2
56014: PUSH
56015: LD_INT 10
56017: DIVREAL
56018: ST_TO_ADDR
// time := 1 1$00 ;
56019: LD_ADDR_VAR 0 8
56023: PUSH
56024: LD_INT 2100
56026: ST_TO_ADDR
// if amount < min then
56027: LD_VAR 0 9
56031: PUSH
56032: LD_VAR 0 3
56036: LESS
56037: IFFALSE 56055
// r := r * 2 else
56039: LD_ADDR_VAR 0 7
56043: PUSH
56044: LD_VAR 0 7
56048: PUSH
56049: LD_INT 2
56051: MUL
56052: ST_TO_ADDR
56053: GO 56081
// if amount > max then
56055: LD_VAR 0 9
56059: PUSH
56060: LD_VAR 0 4
56064: GREATER
56065: IFFALSE 56081
// r := r / 2 ;
56067: LD_ADDR_VAR 0 7
56071: PUSH
56072: LD_VAR 0 7
56076: PUSH
56077: LD_INT 2
56079: DIVREAL
56080: ST_TO_ADDR
// time := time / r ;
56081: LD_ADDR_VAR 0 8
56085: PUSH
56086: LD_VAR 0 8
56090: PUSH
56091: LD_VAR 0 7
56095: DIVREAL
56096: ST_TO_ADDR
// if time < 0 then
56097: LD_VAR 0 8
56101: PUSH
56102: LD_INT 0
56104: LESS
56105: IFFALSE 56122
// time := time * - 1 ;
56107: LD_ADDR_VAR 0 8
56111: PUSH
56112: LD_VAR 0 8
56116: PUSH
56117: LD_INT 1
56119: NEG
56120: MUL
56121: ST_TO_ADDR
// wait ( time + rand ( 0 0$01 , 0 0$25 ) ) ;
56122: LD_VAR 0 8
56126: PUSH
56127: LD_INT 35
56129: PPUSH
56130: LD_INT 875
56132: PPUSH
56133: CALL_OW 12
56137: PLUS
56138: PPUSH
56139: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
56143: LD_INT 1
56145: PPUSH
56146: LD_INT 5
56148: PPUSH
56149: CALL_OW 12
56153: PPUSH
56154: LD_VAR 0 1
56158: PPUSH
56159: LD_INT 1
56161: PPUSH
56162: CALL_OW 55
// end ;
56166: GO 55979
// end ;
56168: LD_VAR 0 5
56172: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
56173: LD_INT 0
56175: PPUSH
56176: PPUSH
56177: PPUSH
56178: PPUSH
56179: PPUSH
56180: PPUSH
56181: PPUSH
56182: PPUSH
// if not turrets or not factories then
56183: LD_VAR 0 1
56187: NOT
56188: PUSH
56189: LD_VAR 0 2
56193: NOT
56194: OR
56195: IFFALSE 56199
// exit ;
56197: GO 56506
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
56199: LD_ADDR_VAR 0 10
56203: PUSH
56204: LD_INT 5
56206: PUSH
56207: LD_INT 6
56209: PUSH
56210: EMPTY
56211: LIST
56212: LIST
56213: PUSH
56214: LD_INT 2
56216: PUSH
56217: LD_INT 4
56219: PUSH
56220: EMPTY
56221: LIST
56222: LIST
56223: PUSH
56224: LD_INT 3
56226: PUSH
56227: LD_INT 5
56229: PUSH
56230: EMPTY
56231: LIST
56232: LIST
56233: PUSH
56234: EMPTY
56235: LIST
56236: LIST
56237: LIST
56238: PUSH
56239: LD_INT 24
56241: PUSH
56242: LD_INT 25
56244: PUSH
56245: EMPTY
56246: LIST
56247: LIST
56248: PUSH
56249: LD_INT 23
56251: PUSH
56252: LD_INT 27
56254: PUSH
56255: EMPTY
56256: LIST
56257: LIST
56258: PUSH
56259: EMPTY
56260: LIST
56261: LIST
56262: PUSH
56263: LD_INT 42
56265: PUSH
56266: LD_INT 43
56268: PUSH
56269: EMPTY
56270: LIST
56271: LIST
56272: PUSH
56273: LD_INT 44
56275: PUSH
56276: LD_INT 46
56278: PUSH
56279: EMPTY
56280: LIST
56281: LIST
56282: PUSH
56283: LD_INT 45
56285: PUSH
56286: LD_INT 47
56288: PUSH
56289: EMPTY
56290: LIST
56291: LIST
56292: PUSH
56293: EMPTY
56294: LIST
56295: LIST
56296: LIST
56297: PUSH
56298: EMPTY
56299: LIST
56300: LIST
56301: LIST
56302: ST_TO_ADDR
// result := [ ] ;
56303: LD_ADDR_VAR 0 3
56307: PUSH
56308: EMPTY
56309: ST_TO_ADDR
// for i in turrets do
56310: LD_ADDR_VAR 0 4
56314: PUSH
56315: LD_VAR 0 1
56319: PUSH
56320: FOR_IN
56321: IFFALSE 56504
// begin nat := GetNation ( i ) ;
56323: LD_ADDR_VAR 0 7
56327: PUSH
56328: LD_VAR 0 4
56332: PPUSH
56333: CALL_OW 248
56337: ST_TO_ADDR
// weapon := 0 ;
56338: LD_ADDR_VAR 0 8
56342: PUSH
56343: LD_INT 0
56345: ST_TO_ADDR
// if not nat then
56346: LD_VAR 0 7
56350: NOT
56351: IFFALSE 56355
// continue ;
56353: GO 56320
// for j in list [ nat ] do
56355: LD_ADDR_VAR 0 5
56359: PUSH
56360: LD_VAR 0 10
56364: PUSH
56365: LD_VAR 0 7
56369: ARRAY
56370: PUSH
56371: FOR_IN
56372: IFFALSE 56413
// if GetBWeapon ( i ) = j [ 1 ] then
56374: LD_VAR 0 4
56378: PPUSH
56379: CALL_OW 269
56383: PUSH
56384: LD_VAR 0 5
56388: PUSH
56389: LD_INT 1
56391: ARRAY
56392: EQUAL
56393: IFFALSE 56411
// begin weapon := j [ 2 ] ;
56395: LD_ADDR_VAR 0 8
56399: PUSH
56400: LD_VAR 0 5
56404: PUSH
56405: LD_INT 2
56407: ARRAY
56408: ST_TO_ADDR
// break ;
56409: GO 56413
// end ;
56411: GO 56371
56413: POP
56414: POP
// if not weapon then
56415: LD_VAR 0 8
56419: NOT
56420: IFFALSE 56424
// continue ;
56422: GO 56320
// for k in factories do
56424: LD_ADDR_VAR 0 6
56428: PUSH
56429: LD_VAR 0 2
56433: PUSH
56434: FOR_IN
56435: IFFALSE 56500
// begin weapons := AvailableWeaponList ( k ) ;
56437: LD_ADDR_VAR 0 9
56441: PUSH
56442: LD_VAR 0 6
56446: PPUSH
56447: CALL_OW 478
56451: ST_TO_ADDR
// if not weapons then
56452: LD_VAR 0 9
56456: NOT
56457: IFFALSE 56461
// continue ;
56459: GO 56434
// if weapon in weapons then
56461: LD_VAR 0 8
56465: PUSH
56466: LD_VAR 0 9
56470: IN
56471: IFFALSE 56498
// begin result := [ i , weapon ] ;
56473: LD_ADDR_VAR 0 3
56477: PUSH
56478: LD_VAR 0 4
56482: PUSH
56483: LD_VAR 0 8
56487: PUSH
56488: EMPTY
56489: LIST
56490: LIST
56491: ST_TO_ADDR
// exit ;
56492: POP
56493: POP
56494: POP
56495: POP
56496: GO 56506
// end ; end ;
56498: GO 56434
56500: POP
56501: POP
// end ;
56502: GO 56320
56504: POP
56505: POP
// end ;
56506: LD_VAR 0 3
56510: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
56511: LD_INT 0
56513: PPUSH
// if not side or side > 8 then
56514: LD_VAR 0 3
56518: NOT
56519: PUSH
56520: LD_VAR 0 3
56524: PUSH
56525: LD_INT 8
56527: GREATER
56528: OR
56529: IFFALSE 56533
// exit ;
56531: GO 56592
// if not range then
56533: LD_VAR 0 4
56537: NOT
56538: IFFALSE 56549
// range := - 12 ;
56540: LD_ADDR_VAR 0 4
56544: PUSH
56545: LD_INT 12
56547: NEG
56548: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
56549: LD_VAR 0 1
56553: PPUSH
56554: LD_VAR 0 2
56558: PPUSH
56559: LD_VAR 0 3
56563: PPUSH
56564: LD_VAR 0 4
56568: PPUSH
56569: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
56573: LD_VAR 0 1
56577: PPUSH
56578: LD_VAR 0 2
56582: PPUSH
56583: LD_VAR 0 3
56587: PPUSH
56588: CALL_OW 331
// end ;
56592: LD_VAR 0 5
56596: RET
// export function Video ( mode ) ; begin
56597: LD_INT 0
56599: PPUSH
// ingame_video = mode ;
56600: LD_ADDR_OWVAR 52
56604: PUSH
56605: LD_VAR 0 1
56609: ST_TO_ADDR
// interface_hidden = mode ;
56610: LD_ADDR_OWVAR 54
56614: PUSH
56615: LD_VAR 0 1
56619: ST_TO_ADDR
// end ;
56620: LD_VAR 0 2
56624: RET
// export function Join ( array , element ) ; begin
56625: LD_INT 0
56627: PPUSH
// result := Replace ( array , array + 1 , element ) ;
56628: LD_ADDR_VAR 0 3
56632: PUSH
56633: LD_VAR 0 1
56637: PPUSH
56638: LD_VAR 0 1
56642: PUSH
56643: LD_INT 1
56645: PLUS
56646: PPUSH
56647: LD_VAR 0 2
56651: PPUSH
56652: CALL_OW 1
56656: ST_TO_ADDR
// end ;
56657: LD_VAR 0 3
56661: RET
// export function JoinUnion ( array , element ) ; begin
56662: LD_INT 0
56664: PPUSH
// result := array union element ;
56665: LD_ADDR_VAR 0 3
56669: PUSH
56670: LD_VAR 0 1
56674: PUSH
56675: LD_VAR 0 2
56679: UNION
56680: ST_TO_ADDR
// end ;
56681: LD_VAR 0 3
56685: RET
// export function GetBehemoths ( side ) ; begin
56686: LD_INT 0
56688: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , ru_behemoth ] ] ) ;
56689: LD_ADDR_VAR 0 2
56693: PUSH
56694: LD_INT 22
56696: PUSH
56697: LD_VAR 0 1
56701: PUSH
56702: EMPTY
56703: LIST
56704: LIST
56705: PUSH
56706: LD_INT 31
56708: PUSH
56709: LD_INT 25
56711: PUSH
56712: EMPTY
56713: LIST
56714: LIST
56715: PUSH
56716: EMPTY
56717: LIST
56718: LIST
56719: PPUSH
56720: CALL_OW 69
56724: ST_TO_ADDR
// end ;
56725: LD_VAR 0 2
56729: RET
// export function Shuffle ( array ) ; var i , index ; begin
56730: LD_INT 0
56732: PPUSH
56733: PPUSH
56734: PPUSH
// result := [ ] ;
56735: LD_ADDR_VAR 0 2
56739: PUSH
56740: EMPTY
56741: ST_TO_ADDR
// if not array then
56742: LD_VAR 0 1
56746: NOT
56747: IFFALSE 56751
// exit ;
56749: GO 56850
// Randomize ;
56751: CALL_OW 10
// for i = array downto 1 do
56755: LD_ADDR_VAR 0 3
56759: PUSH
56760: DOUBLE
56761: LD_VAR 0 1
56765: INC
56766: ST_TO_ADDR
56767: LD_INT 1
56769: PUSH
56770: FOR_DOWNTO
56771: IFFALSE 56848
// begin index := rand ( 1 , array ) ;
56773: LD_ADDR_VAR 0 4
56777: PUSH
56778: LD_INT 1
56780: PPUSH
56781: LD_VAR 0 1
56785: PPUSH
56786: CALL_OW 12
56790: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
56791: LD_ADDR_VAR 0 2
56795: PUSH
56796: LD_VAR 0 2
56800: PPUSH
56801: LD_VAR 0 2
56805: PUSH
56806: LD_INT 1
56808: PLUS
56809: PPUSH
56810: LD_VAR 0 1
56814: PUSH
56815: LD_VAR 0 4
56819: ARRAY
56820: PPUSH
56821: CALL_OW 2
56825: ST_TO_ADDR
// array := Delete ( array , index ) ;
56826: LD_ADDR_VAR 0 1
56830: PUSH
56831: LD_VAR 0 1
56835: PPUSH
56836: LD_VAR 0 4
56840: PPUSH
56841: CALL_OW 3
56845: ST_TO_ADDR
// end ;
56846: GO 56770
56848: POP
56849: POP
// end ;
56850: LD_VAR 0 2
56854: RET
// export function GetBaseMaterials ( base ) ; begin
56855: LD_INT 0
56857: PPUSH
// result := [ 0 , 0 , 0 ] ;
56858: LD_ADDR_VAR 0 2
56862: PUSH
56863: LD_INT 0
56865: PUSH
56866: LD_INT 0
56868: PUSH
56869: LD_INT 0
56871: PUSH
56872: EMPTY
56873: LIST
56874: LIST
56875: LIST
56876: ST_TO_ADDR
// if not base then
56877: LD_VAR 0 1
56881: NOT
56882: IFFALSE 56886
// exit ;
56884: GO 56935
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
56886: LD_ADDR_VAR 0 2
56890: PUSH
56891: LD_VAR 0 1
56895: PPUSH
56896: LD_INT 1
56898: PPUSH
56899: CALL_OW 275
56903: PUSH
56904: LD_VAR 0 1
56908: PPUSH
56909: LD_INT 2
56911: PPUSH
56912: CALL_OW 275
56916: PUSH
56917: LD_VAR 0 1
56921: PPUSH
56922: LD_INT 3
56924: PPUSH
56925: CALL_OW 275
56929: PUSH
56930: EMPTY
56931: LIST
56932: LIST
56933: LIST
56934: ST_TO_ADDR
// end ;
56935: LD_VAR 0 2
56939: RET
// export function ShrinkArray ( array , size ) ; var i ; begin
56940: LD_INT 0
56942: PPUSH
56943: PPUSH
// result := array ;
56944: LD_ADDR_VAR 0 3
56948: PUSH
56949: LD_VAR 0 1
56953: ST_TO_ADDR
// if size >= result then
56954: LD_VAR 0 2
56958: PUSH
56959: LD_VAR 0 3
56963: GREATEREQUAL
56964: IFFALSE 56968
// exit ;
56966: GO 57018
// if size then
56968: LD_VAR 0 2
56972: IFFALSE 57018
// for i := array downto size do
56974: LD_ADDR_VAR 0 4
56978: PUSH
56979: DOUBLE
56980: LD_VAR 0 1
56984: INC
56985: ST_TO_ADDR
56986: LD_VAR 0 2
56990: PUSH
56991: FOR_DOWNTO
56992: IFFALSE 57016
// result := Delete ( result , result ) ;
56994: LD_ADDR_VAR 0 3
56998: PUSH
56999: LD_VAR 0 3
57003: PPUSH
57004: LD_VAR 0 3
57008: PPUSH
57009: CALL_OW 3
57013: ST_TO_ADDR
57014: GO 56991
57016: POP
57017: POP
// end ;
57018: LD_VAR 0 3
57022: RET
// export function ComExit ( unit ) ; var tmp ; begin
57023: LD_INT 0
57025: PPUSH
57026: PPUSH
// if not IsInUnit ( unit ) then
57027: LD_VAR 0 1
57031: PPUSH
57032: CALL_OW 310
57036: NOT
57037: IFFALSE 57041
// exit ;
57039: GO 57101
// tmp := IsInUnit ( unit ) ;
57041: LD_ADDR_VAR 0 3
57045: PUSH
57046: LD_VAR 0 1
57050: PPUSH
57051: CALL_OW 310
57055: ST_TO_ADDR
// if GetType ( tmp ) = unit_vehicle then
57056: LD_VAR 0 3
57060: PPUSH
57061: CALL_OW 247
57065: PUSH
57066: LD_INT 2
57068: EQUAL
57069: IFFALSE 57082
// ComExitVehicle ( unit ) else
57071: LD_VAR 0 1
57075: PPUSH
57076: CALL_OW 121
57080: GO 57091
// ComExitBuilding ( unit ) ;
57082: LD_VAR 0 1
57086: PPUSH
57087: CALL_OW 122
// result := tmp ;
57091: LD_ADDR_VAR 0 2
57095: PUSH
57096: LD_VAR 0 3
57100: ST_TO_ADDR
// end ;
57101: LD_VAR 0 2
57105: RET
// export function ComExitAll ( units ) ; var i ; begin
57106: LD_INT 0
57108: PPUSH
57109: PPUSH
// if not units then
57110: LD_VAR 0 1
57114: NOT
57115: IFFALSE 57119
// exit ;
57117: GO 57145
// for i in units do
57119: LD_ADDR_VAR 0 3
57123: PUSH
57124: LD_VAR 0 1
57128: PUSH
57129: FOR_IN
57130: IFFALSE 57143
// ComExit ( i ) ;
57132: LD_VAR 0 3
57136: PPUSH
57137: CALL 57023 0 1
57141: GO 57129
57143: POP
57144: POP
// end ;
57145: LD_VAR 0 2
57149: RET
// export function ResetHc ; begin
57150: LD_INT 0
57152: PPUSH
// InitHc ;
57153: CALL_OW 19
// hc_importance := 0 ;
57157: LD_ADDR_OWVAR 32
57161: PUSH
57162: LD_INT 0
57164: ST_TO_ADDR
// end ;
57165: LD_VAR 0 1
57169: RET
// export function PointBetweenXY ( x1 , y1 , x2 , y2 ) ; var _x , _y ; begin
57170: LD_INT 0
57172: PPUSH
57173: PPUSH
57174: PPUSH
// _x := ( x1 + x2 ) div 2 ;
57175: LD_ADDR_VAR 0 6
57179: PUSH
57180: LD_VAR 0 1
57184: PUSH
57185: LD_VAR 0 3
57189: PLUS
57190: PUSH
57191: LD_INT 2
57193: DIV
57194: ST_TO_ADDR
// if _x < 0 then
57195: LD_VAR 0 6
57199: PUSH
57200: LD_INT 0
57202: LESS
57203: IFFALSE 57220
// _x := _x * - 1 ;
57205: LD_ADDR_VAR 0 6
57209: PUSH
57210: LD_VAR 0 6
57214: PUSH
57215: LD_INT 1
57217: NEG
57218: MUL
57219: ST_TO_ADDR
// _y := ( y1 + y2 ) div 2 ;
57220: LD_ADDR_VAR 0 7
57224: PUSH
57225: LD_VAR 0 2
57229: PUSH
57230: LD_VAR 0 4
57234: PLUS
57235: PUSH
57236: LD_INT 2
57238: DIV
57239: ST_TO_ADDR
// if _y < 0 then
57240: LD_VAR 0 7
57244: PUSH
57245: LD_INT 0
57247: LESS
57248: IFFALSE 57265
// _y := _y * - 1 ;
57250: LD_ADDR_VAR 0 7
57254: PUSH
57255: LD_VAR 0 7
57259: PUSH
57260: LD_INT 1
57262: NEG
57263: MUL
57264: ST_TO_ADDR
// result := [ _x , _y ] ;
57265: LD_ADDR_VAR 0 5
57269: PUSH
57270: LD_VAR 0 6
57274: PUSH
57275: LD_VAR 0 7
57279: PUSH
57280: EMPTY
57281: LIST
57282: LIST
57283: ST_TO_ADDR
// end ;
57284: LD_VAR 0 5
57288: RET
// export function NotGoToAreaUnit ( unit , area , goAway ) ; var x , y , task ; begin
57289: LD_INT 0
57291: PPUSH
57292: PPUSH
57293: PPUSH
57294: PPUSH
// task := GetTaskList ( unit ) ;
57295: LD_ADDR_VAR 0 7
57299: PUSH
57300: LD_VAR 0 1
57304: PPUSH
57305: CALL_OW 437
57309: ST_TO_ADDR
// if not task and not IsInArea ( unit , area ) then
57310: LD_VAR 0 7
57314: NOT
57315: PUSH
57316: LD_VAR 0 1
57320: PPUSH
57321: LD_VAR 0 2
57325: PPUSH
57326: CALL_OW 308
57330: NOT
57331: AND
57332: IFFALSE 57336
// exit ;
57334: GO 57454
// if IsInArea ( unit , area ) then
57336: LD_VAR 0 1
57340: PPUSH
57341: LD_VAR 0 2
57345: PPUSH
57346: CALL_OW 308
57350: IFFALSE 57368
// begin ComMoveToArea ( unit , goAway ) ;
57352: LD_VAR 0 1
57356: PPUSH
57357: LD_VAR 0 3
57361: PPUSH
57362: CALL_OW 113
// exit ;
57366: GO 57454
// end ; if task [ 1 ] [ 1 ] <> M then
57368: LD_VAR 0 7
57372: PUSH
57373: LD_INT 1
57375: ARRAY
57376: PUSH
57377: LD_INT 1
57379: ARRAY
57380: PUSH
57381: LD_STRING M
57383: NONEQUAL
57384: IFFALSE 57388
// exit ;
57386: GO 57454
// x := task [ 1 ] [ 2 ] ;
57388: LD_ADDR_VAR 0 5
57392: PUSH
57393: LD_VAR 0 7
57397: PUSH
57398: LD_INT 1
57400: ARRAY
57401: PUSH
57402: LD_INT 2
57404: ARRAY
57405: ST_TO_ADDR
// y := task [ 1 ] [ 3 ] ;
57406: LD_ADDR_VAR 0 6
57410: PUSH
57411: LD_VAR 0 7
57415: PUSH
57416: LD_INT 1
57418: ARRAY
57419: PUSH
57420: LD_INT 3
57422: ARRAY
57423: ST_TO_ADDR
// if InArea ( x , y , area ) then
57424: LD_VAR 0 5
57428: PPUSH
57429: LD_VAR 0 6
57433: PPUSH
57434: LD_VAR 0 2
57438: PPUSH
57439: CALL_OW 309
57443: IFFALSE 57454
// ComStop ( unit ) ;
57445: LD_VAR 0 1
57449: PPUSH
57450: CALL_OW 141
// end ;
57454: LD_VAR 0 4
57458: RET
// export function Abs ( value ) ; begin
57459: LD_INT 0
57461: PPUSH
// result := value ;
57462: LD_ADDR_VAR 0 2
57466: PUSH
57467: LD_VAR 0 1
57471: ST_TO_ADDR
// if value < 0 then
57472: LD_VAR 0 1
57476: PUSH
57477: LD_INT 0
57479: LESS
57480: IFFALSE 57497
// result := value * - 1 ;
57482: LD_ADDR_VAR 0 2
57486: PUSH
57487: LD_VAR 0 1
57491: PUSH
57492: LD_INT 1
57494: NEG
57495: MUL
57496: ST_TO_ADDR
// end ;
57497: LD_VAR 0 2
57501: RET
// export function ComMoveToNearbyEntrance ( unit , building ) ; var x , _x , y , _y , d , r , i ; begin
57502: LD_INT 0
57504: PPUSH
57505: PPUSH
57506: PPUSH
57507: PPUSH
57508: PPUSH
57509: PPUSH
57510: PPUSH
57511: PPUSH
// if not unit or not building then
57512: LD_VAR 0 1
57516: NOT
57517: PUSH
57518: LD_VAR 0 2
57522: NOT
57523: OR
57524: IFFALSE 57528
// exit ;
57526: GO 57754
// x := GetX ( building ) ;
57528: LD_ADDR_VAR 0 4
57532: PUSH
57533: LD_VAR 0 2
57537: PPUSH
57538: CALL_OW 250
57542: ST_TO_ADDR
// y := GetY ( building ) ;
57543: LD_ADDR_VAR 0 6
57547: PUSH
57548: LD_VAR 0 2
57552: PPUSH
57553: CALL_OW 251
57557: ST_TO_ADDR
// d := GetDir ( building ) ;
57558: LD_ADDR_VAR 0 8
57562: PUSH
57563: LD_VAR 0 2
57567: PPUSH
57568: CALL_OW 254
57572: ST_TO_ADDR
// r := 4 ;
57573: LD_ADDR_VAR 0 9
57577: PUSH
57578: LD_INT 4
57580: ST_TO_ADDR
// for i := 1 to 5 do
57581: LD_ADDR_VAR 0 10
57585: PUSH
57586: DOUBLE
57587: LD_INT 1
57589: DEC
57590: ST_TO_ADDR
57591: LD_INT 5
57593: PUSH
57594: FOR_TO
57595: IFFALSE 57752
// begin _x := ShiftX ( x , d , r + i ) ;
57597: LD_ADDR_VAR 0 5
57601: PUSH
57602: LD_VAR 0 4
57606: PPUSH
57607: LD_VAR 0 8
57611: PPUSH
57612: LD_VAR 0 9
57616: PUSH
57617: LD_VAR 0 10
57621: PLUS
57622: PPUSH
57623: CALL_OW 272
57627: ST_TO_ADDR
// _y := ShiftY ( y , d , r + i ) ;
57628: LD_ADDR_VAR 0 7
57632: PUSH
57633: LD_VAR 0 6
57637: PPUSH
57638: LD_VAR 0 8
57642: PPUSH
57643: LD_VAR 0 9
57647: PUSH
57648: LD_VAR 0 10
57652: PLUS
57653: PPUSH
57654: CALL_OW 273
57658: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not GetType ( HexInfo ( _x , _y ) ) in [ unit_building , unit_vehicle ] then
57659: LD_VAR 0 5
57663: PPUSH
57664: LD_VAR 0 7
57668: PPUSH
57669: CALL_OW 488
57673: PUSH
57674: LD_VAR 0 5
57678: PPUSH
57679: LD_VAR 0 7
57683: PPUSH
57684: CALL_OW 428
57688: PPUSH
57689: CALL_OW 247
57693: PUSH
57694: LD_INT 3
57696: PUSH
57697: LD_INT 2
57699: PUSH
57700: EMPTY
57701: LIST
57702: LIST
57703: IN
57704: NOT
57705: AND
57706: IFFALSE 57750
// begin ComMoveXY ( unit , _x , _y ) ;
57708: LD_VAR 0 1
57712: PPUSH
57713: LD_VAR 0 5
57717: PPUSH
57718: LD_VAR 0 7
57722: PPUSH
57723: CALL_OW 111
// result := [ _x , _y ] ;
57727: LD_ADDR_VAR 0 3
57731: PUSH
57732: LD_VAR 0 5
57736: PUSH
57737: LD_VAR 0 7
57741: PUSH
57742: EMPTY
57743: LIST
57744: LIST
57745: ST_TO_ADDR
// exit ;
57746: POP
57747: POP
57748: GO 57754
// end ; end ;
57750: GO 57594
57752: POP
57753: POP
// end ;
57754: LD_VAR 0 3
57758: RET
// export function SideAttackedSide ( side1 , side2 ) ; var i , un ; begin
57759: LD_INT 0
57761: PPUSH
57762: PPUSH
57763: PPUSH
// result := 0 ;
57764: LD_ADDR_VAR 0 3
57768: PUSH
57769: LD_INT 0
57771: ST_TO_ADDR
// if side1 < 0 or side1 > 8 or side2 < 0 or side2 > 8 then
57772: LD_VAR 0 1
57776: PUSH
57777: LD_INT 0
57779: LESS
57780: PUSH
57781: LD_VAR 0 1
57785: PUSH
57786: LD_INT 8
57788: GREATER
57789: OR
57790: PUSH
57791: LD_VAR 0 2
57795: PUSH
57796: LD_INT 0
57798: LESS
57799: OR
57800: PUSH
57801: LD_VAR 0 2
57805: PUSH
57806: LD_INT 8
57808: GREATER
57809: OR
57810: IFFALSE 57814
// exit ;
57812: GO 57889
// for i in FilterAllUnits ( [ f_side , side2 ] ) do
57814: LD_ADDR_VAR 0 4
57818: PUSH
57819: LD_INT 22
57821: PUSH
57822: LD_VAR 0 2
57826: PUSH
57827: EMPTY
57828: LIST
57829: LIST
57830: PPUSH
57831: CALL_OW 69
57835: PUSH
57836: FOR_IN
57837: IFFALSE 57887
// begin un := UnitShoot ( i ) ;
57839: LD_ADDR_VAR 0 5
57843: PUSH
57844: LD_VAR 0 4
57848: PPUSH
57849: CALL_OW 504
57853: ST_TO_ADDR
// if GetSide ( un ) = side1 then
57854: LD_VAR 0 5
57858: PPUSH
57859: CALL_OW 255
57863: PUSH
57864: LD_VAR 0 1
57868: EQUAL
57869: IFFALSE 57885
// begin result := un ;
57871: LD_ADDR_VAR 0 3
57875: PUSH
57876: LD_VAR 0 5
57880: ST_TO_ADDR
// exit ;
57881: POP
57882: POP
57883: GO 57889
// end ; end ;
57885: GO 57836
57887: POP
57888: POP
// end ;
57889: LD_VAR 0 3
57893: RET
// export function GetCargoBay ( units ) ; begin
57894: LD_INT 0
57896: PPUSH
// result := UnitFilter ( units , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ) ;
57897: LD_ADDR_VAR 0 2
57901: PUSH
57902: LD_VAR 0 1
57906: PPUSH
57907: LD_INT 2
57909: PUSH
57910: LD_INT 34
57912: PUSH
57913: LD_INT 12
57915: PUSH
57916: EMPTY
57917: LIST
57918: LIST
57919: PUSH
57920: LD_INT 34
57922: PUSH
57923: LD_INT 51
57925: PUSH
57926: EMPTY
57927: LIST
57928: LIST
57929: PUSH
57930: LD_INT 34
57932: PUSH
57933: LD_INT 32
57935: PUSH
57936: EMPTY
57937: LIST
57938: LIST
57939: PUSH
57940: LD_INT 34
57942: PUSH
57943: LD_EXP 159
57947: PUSH
57948: EMPTY
57949: LIST
57950: LIST
57951: PUSH
57952: EMPTY
57953: LIST
57954: LIST
57955: LIST
57956: LIST
57957: LIST
57958: PPUSH
57959: CALL_OW 72
57963: ST_TO_ADDR
// end ;
57964: LD_VAR 0 2
57968: RET
// export function Negate ( value ) ; begin
57969: LD_INT 0
57971: PPUSH
// result := not value ;
57972: LD_ADDR_VAR 0 2
57976: PUSH
57977: LD_VAR 0 1
57981: NOT
57982: ST_TO_ADDR
// end ;
57983: LD_VAR 0 2
57987: RET
// export function Inc ( value ) ; begin
57988: LD_INT 0
57990: PPUSH
// result := value + 1 ;
57991: LD_ADDR_VAR 0 2
57995: PUSH
57996: LD_VAR 0 1
58000: PUSH
58001: LD_INT 1
58003: PLUS
58004: ST_TO_ADDR
// end ;
58005: LD_VAR 0 2
58009: RET
// export function Dec ( value ) ; begin
58010: LD_INT 0
58012: PPUSH
// result := value - 1 ;
58013: LD_ADDR_VAR 0 2
58017: PUSH
58018: LD_VAR 0 1
58022: PUSH
58023: LD_INT 1
58025: MINUS
58026: ST_TO_ADDR
// end ;
58027: LD_VAR 0 2
58031: RET
// export function GetDirFromHex ( x1 , y1 , x2 , y2 ) ; var i , _x , _y , tmp , distance , centerDist , centerPoint ; begin
58032: LD_INT 0
58034: PPUSH
58035: PPUSH
58036: PPUSH
58037: PPUSH
58038: PPUSH
58039: PPUSH
58040: PPUSH
58041: PPUSH
// if not ValidHex ( x1 , y1 ) or not ValidHex ( x2 , y2 ) then
58042: LD_VAR 0 1
58046: PPUSH
58047: LD_VAR 0 2
58051: PPUSH
58052: CALL_OW 488
58056: NOT
58057: PUSH
58058: LD_VAR 0 3
58062: PPUSH
58063: LD_VAR 0 4
58067: PPUSH
58068: CALL_OW 488
58072: NOT
58073: OR
58074: IFFALSE 58087
// begin result := - 1 ;
58076: LD_ADDR_VAR 0 5
58080: PUSH
58081: LD_INT 1
58083: NEG
58084: ST_TO_ADDR
// exit ;
58085: GO 58322
// end ; centerPoint := PointBetweenXY ( x1 , y1 , x2 , y2 ) ;
58087: LD_ADDR_VAR 0 12
58091: PUSH
58092: LD_VAR 0 1
58096: PPUSH
58097: LD_VAR 0 2
58101: PPUSH
58102: LD_VAR 0 3
58106: PPUSH
58107: LD_VAR 0 4
58111: PPUSH
58112: CALL 57170 0 4
58116: ST_TO_ADDR
// centerDist := GetDistXY ( x1 , y1 , centerPoint [ 1 ] , centerPoint [ 2 ] ) ;
58117: LD_ADDR_VAR 0 11
58121: PUSH
58122: LD_VAR 0 1
58126: PPUSH
58127: LD_VAR 0 2
58131: PPUSH
58132: LD_VAR 0 12
58136: PUSH
58137: LD_INT 1
58139: ARRAY
58140: PPUSH
58141: LD_VAR 0 12
58145: PUSH
58146: LD_INT 2
58148: ARRAY
58149: PPUSH
58150: CALL_OW 298
58154: ST_TO_ADDR
// distance := 9999 ;
58155: LD_ADDR_VAR 0 10
58159: PUSH
58160: LD_INT 9999
58162: ST_TO_ADDR
// for i := 0 to 5 do
58163: LD_ADDR_VAR 0 6
58167: PUSH
58168: DOUBLE
58169: LD_INT 0
58171: DEC
58172: ST_TO_ADDR
58173: LD_INT 5
58175: PUSH
58176: FOR_TO
58177: IFFALSE 58320
// begin _x := ShiftX ( x1 , i , centerDist ) ;
58179: LD_ADDR_VAR 0 7
58183: PUSH
58184: LD_VAR 0 1
58188: PPUSH
58189: LD_VAR 0 6
58193: PPUSH
58194: LD_VAR 0 11
58198: PPUSH
58199: CALL_OW 272
58203: ST_TO_ADDR
// _y := ShiftY ( y1 , i , centerDist ) ;
58204: LD_ADDR_VAR 0 8
58208: PUSH
58209: LD_VAR 0 2
58213: PPUSH
58214: LD_VAR 0 6
58218: PPUSH
58219: LD_VAR 0 11
58223: PPUSH
58224: CALL_OW 273
58228: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
58229: LD_VAR 0 7
58233: PPUSH
58234: LD_VAR 0 8
58238: PPUSH
58239: CALL_OW 488
58243: NOT
58244: IFFALSE 58248
// continue ;
58246: GO 58176
// tmp := GetDistXY ( centerPoint [ 1 ] , centerPoint [ 2 ] , _x , _y ) ;
58248: LD_ADDR_VAR 0 9
58252: PUSH
58253: LD_VAR 0 12
58257: PUSH
58258: LD_INT 1
58260: ARRAY
58261: PPUSH
58262: LD_VAR 0 12
58266: PUSH
58267: LD_INT 2
58269: ARRAY
58270: PPUSH
58271: LD_VAR 0 7
58275: PPUSH
58276: LD_VAR 0 8
58280: PPUSH
58281: CALL_OW 298
58285: ST_TO_ADDR
// if tmp < distance then
58286: LD_VAR 0 9
58290: PUSH
58291: LD_VAR 0 10
58295: LESS
58296: IFFALSE 58318
// begin result := i ;
58298: LD_ADDR_VAR 0 5
58302: PUSH
58303: LD_VAR 0 6
58307: ST_TO_ADDR
// distance := tmp ;
58308: LD_ADDR_VAR 0 10
58312: PUSH
58313: LD_VAR 0 9
58317: ST_TO_ADDR
// end ; end ;
58318: GO 58176
58320: POP
58321: POP
// end ;
58322: LD_VAR 0 5
58326: RET
// export function ComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
58327: LD_INT 0
58329: PPUSH
58330: PPUSH
// if not driver or not IsInUnit ( driver ) then
58331: LD_VAR 0 1
58335: NOT
58336: PUSH
58337: LD_VAR 0 1
58341: PPUSH
58342: CALL_OW 310
58346: NOT
58347: OR
58348: IFFALSE 58352
// exit ;
58350: GO 58442
// vehicle := IsInUnit ( driver ) ;
58352: LD_ADDR_VAR 0 3
58356: PUSH
58357: LD_VAR 0 1
58361: PPUSH
58362: CALL_OW 310
58366: ST_TO_ADDR
// SetTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
58367: LD_VAR 0 1
58371: PPUSH
58372: LD_STRING \
58374: PUSH
58375: LD_INT 0
58377: PUSH
58378: LD_INT 0
58380: PUSH
58381: LD_INT 0
58383: PUSH
58384: LD_INT 0
58386: PUSH
58387: LD_INT 0
58389: PUSH
58390: LD_INT 0
58392: PUSH
58393: EMPTY
58394: LIST
58395: LIST
58396: LIST
58397: LIST
58398: LIST
58399: LIST
58400: LIST
58401: PUSH
58402: LD_STRING E
58404: PUSH
58405: LD_INT 0
58407: PUSH
58408: LD_INT 0
58410: PUSH
58411: LD_VAR 0 3
58415: PUSH
58416: LD_INT 0
58418: PUSH
58419: LD_INT 0
58421: PUSH
58422: LD_INT 0
58424: PUSH
58425: EMPTY
58426: LIST
58427: LIST
58428: LIST
58429: LIST
58430: LIST
58431: LIST
58432: LIST
58433: PUSH
58434: EMPTY
58435: LIST
58436: LIST
58437: PPUSH
58438: CALL_OW 446
// end ;
58442: LD_VAR 0 2
58446: RET
// export function AddComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
58447: LD_INT 0
58449: PPUSH
58450: PPUSH
// if not driver or not IsInUnit ( driver ) then
58451: LD_VAR 0 1
58455: NOT
58456: PUSH
58457: LD_VAR 0 1
58461: PPUSH
58462: CALL_OW 310
58466: NOT
58467: OR
58468: IFFALSE 58472
// exit ;
58470: GO 58562
// vehicle := IsInUnit ( driver ) ;
58472: LD_ADDR_VAR 0 3
58476: PUSH
58477: LD_VAR 0 1
58481: PPUSH
58482: CALL_OW 310
58486: ST_TO_ADDR
// AddTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
58487: LD_VAR 0 1
58491: PPUSH
58492: LD_STRING \
58494: PUSH
58495: LD_INT 0
58497: PUSH
58498: LD_INT 0
58500: PUSH
58501: LD_INT 0
58503: PUSH
58504: LD_INT 0
58506: PUSH
58507: LD_INT 0
58509: PUSH
58510: LD_INT 0
58512: PUSH
58513: EMPTY
58514: LIST
58515: LIST
58516: LIST
58517: LIST
58518: LIST
58519: LIST
58520: LIST
58521: PUSH
58522: LD_STRING E
58524: PUSH
58525: LD_INT 0
58527: PUSH
58528: LD_INT 0
58530: PUSH
58531: LD_VAR 0 3
58535: PUSH
58536: LD_INT 0
58538: PUSH
58539: LD_INT 0
58541: PUSH
58542: LD_INT 0
58544: PUSH
58545: EMPTY
58546: LIST
58547: LIST
58548: LIST
58549: LIST
58550: LIST
58551: LIST
58552: LIST
58553: PUSH
58554: EMPTY
58555: LIST
58556: LIST
58557: PPUSH
58558: CALL_OW 447
// end ;
58562: LD_VAR 0 2
58566: RET
// export function SortByHealth ( units , asc ) ; var i , tmp ; begin
58567: LD_INT 0
58569: PPUSH
58570: PPUSH
58571: PPUSH
// tmp := [ ] ;
58572: LD_ADDR_VAR 0 5
58576: PUSH
58577: EMPTY
58578: ST_TO_ADDR
// for i in units do
58579: LD_ADDR_VAR 0 4
58583: PUSH
58584: LD_VAR 0 1
58588: PUSH
58589: FOR_IN
58590: IFFALSE 58628
// tmp := Insert ( tmp , tmp + 1 , GetLives ( i ) ) ;
58592: LD_ADDR_VAR 0 5
58596: PUSH
58597: LD_VAR 0 5
58601: PPUSH
58602: LD_VAR 0 5
58606: PUSH
58607: LD_INT 1
58609: PLUS
58610: PPUSH
58611: LD_VAR 0 4
58615: PPUSH
58616: CALL_OW 256
58620: PPUSH
58621: CALL_OW 2
58625: ST_TO_ADDR
58626: GO 58589
58628: POP
58629: POP
// if not tmp then
58630: LD_VAR 0 5
58634: NOT
58635: IFFALSE 58639
// exit ;
58637: GO 58687
// if asc then
58639: LD_VAR 0 2
58643: IFFALSE 58667
// result := SortListByListAsc ( units , tmp ) else
58645: LD_ADDR_VAR 0 3
58649: PUSH
58650: LD_VAR 0 1
58654: PPUSH
58655: LD_VAR 0 5
58659: PPUSH
58660: CALL_OW 76
58664: ST_TO_ADDR
58665: GO 58687
// result := SortListByListDesc ( units , tmp ) ;
58667: LD_ADDR_VAR 0 3
58671: PUSH
58672: LD_VAR 0 1
58676: PPUSH
58677: LD_VAR 0 5
58681: PPUSH
58682: CALL_OW 77
58686: ST_TO_ADDR
// end ;
58687: LD_VAR 0 3
58691: RET
// export function WantToRepairVehicle ( mech , vehicle ) ; var task ; begin
58692: LD_INT 0
58694: PPUSH
58695: PPUSH
// task := GetTaskList ( mech ) ;
58696: LD_ADDR_VAR 0 4
58700: PUSH
58701: LD_VAR 0 1
58705: PPUSH
58706: CALL_OW 437
58710: ST_TO_ADDR
// if not task then
58711: LD_VAR 0 4
58715: NOT
58716: IFFALSE 58720
// exit ;
58718: GO 58762
// result := task [ 1 ] [ 1 ] = r and task [ 1 ] [ 4 ] = vehicle ;
58720: LD_ADDR_VAR 0 3
58724: PUSH
58725: LD_VAR 0 4
58729: PUSH
58730: LD_INT 1
58732: ARRAY
58733: PUSH
58734: LD_INT 1
58736: ARRAY
58737: PUSH
58738: LD_STRING r
58740: EQUAL
58741: PUSH
58742: LD_VAR 0 4
58746: PUSH
58747: LD_INT 1
58749: ARRAY
58750: PUSH
58751: LD_INT 4
58753: ARRAY
58754: PUSH
58755: LD_VAR 0 2
58759: EQUAL
58760: AND
58761: ST_TO_ADDR
// end ;
58762: LD_VAR 0 3
58766: RET
// export function PlaceUnitXYD ( unit , x , y , d , mode ) ; begin
58767: LD_INT 0
58769: PPUSH
// SetDir ( unit , d ) ;
58770: LD_VAR 0 1
58774: PPUSH
58775: LD_VAR 0 4
58779: PPUSH
58780: CALL_OW 233
// PlaceUnitXY ( unit , x , y , mode ) ;
58784: LD_VAR 0 1
58788: PPUSH
58789: LD_VAR 0 2
58793: PPUSH
58794: LD_VAR 0 3
58798: PPUSH
58799: LD_VAR 0 5
58803: PPUSH
58804: CALL_OW 48
// end ;
58808: LD_VAR 0 6
58812: RET
// export function ToNaturalNumber ( number ) ; begin
58813: LD_INT 0
58815: PPUSH
// result := number div 1 ;
58816: LD_ADDR_VAR 0 2
58820: PUSH
58821: LD_VAR 0 1
58825: PUSH
58826: LD_INT 1
58828: DIV
58829: ST_TO_ADDR
// if number < 0 then
58830: LD_VAR 0 1
58834: PUSH
58835: LD_INT 0
58837: LESS
58838: IFFALSE 58848
// result := 0 ;
58840: LD_ADDR_VAR 0 2
58844: PUSH
58845: LD_INT 0
58847: ST_TO_ADDR
// end ;
58848: LD_VAR 0 2
58852: RET
// export function SortByClass ( units , class ) ; var un ; begin
58853: LD_INT 0
58855: PPUSH
58856: PPUSH
// if not units or not class then
58857: LD_VAR 0 1
58861: NOT
58862: PUSH
58863: LD_VAR 0 2
58867: NOT
58868: OR
58869: IFFALSE 58873
// exit ;
58871: GO 58968
// result := [ ] ;
58873: LD_ADDR_VAR 0 3
58877: PUSH
58878: EMPTY
58879: ST_TO_ADDR
// for un in units do
58880: LD_ADDR_VAR 0 4
58884: PUSH
58885: LD_VAR 0 1
58889: PUSH
58890: FOR_IN
58891: IFFALSE 58966
// if GetClass ( un ) = class then
58893: LD_VAR 0 4
58897: PPUSH
58898: CALL_OW 257
58902: PUSH
58903: LD_VAR 0 2
58907: EQUAL
58908: IFFALSE 58935
// result := Insert ( result , 1 , un ) else
58910: LD_ADDR_VAR 0 3
58914: PUSH
58915: LD_VAR 0 3
58919: PPUSH
58920: LD_INT 1
58922: PPUSH
58923: LD_VAR 0 4
58927: PPUSH
58928: CALL_OW 2
58932: ST_TO_ADDR
58933: GO 58964
// result := Replace ( result , result + 1 , un ) ;
58935: LD_ADDR_VAR 0 3
58939: PUSH
58940: LD_VAR 0 3
58944: PPUSH
58945: LD_VAR 0 3
58949: PUSH
58950: LD_INT 1
58952: PLUS
58953: PPUSH
58954: LD_VAR 0 4
58958: PPUSH
58959: CALL_OW 1
58963: ST_TO_ADDR
58964: GO 58890
58966: POP
58967: POP
// end ;
58968: LD_VAR 0 3
58972: RET
// export function GetCratesNearbyXY ( x , y , r ) ; var _x , _y , min_y , min_x , max_x , max_y ; begin
58973: LD_INT 0
58975: PPUSH
58976: PPUSH
58977: PPUSH
58978: PPUSH
58979: PPUSH
58980: PPUSH
58981: PPUSH
// result := [ ] ;
58982: LD_ADDR_VAR 0 4
58986: PUSH
58987: EMPTY
58988: ST_TO_ADDR
// if x - r < 0 then
58989: LD_VAR 0 1
58993: PUSH
58994: LD_VAR 0 3
58998: MINUS
58999: PUSH
59000: LD_INT 0
59002: LESS
59003: IFFALSE 59015
// min_x := 0 else
59005: LD_ADDR_VAR 0 8
59009: PUSH
59010: LD_INT 0
59012: ST_TO_ADDR
59013: GO 59031
// min_x := x - r ;
59015: LD_ADDR_VAR 0 8
59019: PUSH
59020: LD_VAR 0 1
59024: PUSH
59025: LD_VAR 0 3
59029: MINUS
59030: ST_TO_ADDR
// if y - r < 0 then
59031: LD_VAR 0 2
59035: PUSH
59036: LD_VAR 0 3
59040: MINUS
59041: PUSH
59042: LD_INT 0
59044: LESS
59045: IFFALSE 59057
// min_y := 0 else
59047: LD_ADDR_VAR 0 7
59051: PUSH
59052: LD_INT 0
59054: ST_TO_ADDR
59055: GO 59073
// min_y := y - r ;
59057: LD_ADDR_VAR 0 7
59061: PUSH
59062: LD_VAR 0 2
59066: PUSH
59067: LD_VAR 0 3
59071: MINUS
59072: ST_TO_ADDR
// max_x := x + r ;
59073: LD_ADDR_VAR 0 9
59077: PUSH
59078: LD_VAR 0 1
59082: PUSH
59083: LD_VAR 0 3
59087: PLUS
59088: ST_TO_ADDR
// max_y := y + r ;
59089: LD_ADDR_VAR 0 10
59093: PUSH
59094: LD_VAR 0 2
59098: PUSH
59099: LD_VAR 0 3
59103: PLUS
59104: ST_TO_ADDR
// for _x = min_x to max_x do
59105: LD_ADDR_VAR 0 5
59109: PUSH
59110: DOUBLE
59111: LD_VAR 0 8
59115: DEC
59116: ST_TO_ADDR
59117: LD_VAR 0 9
59121: PUSH
59122: FOR_TO
59123: IFFALSE 59224
// for _y = min_y to max_y do
59125: LD_ADDR_VAR 0 6
59129: PUSH
59130: DOUBLE
59131: LD_VAR 0 7
59135: DEC
59136: ST_TO_ADDR
59137: LD_VAR 0 10
59141: PUSH
59142: FOR_TO
59143: IFFALSE 59220
// begin if not ValidHex ( _x , _y ) then
59145: LD_VAR 0 5
59149: PPUSH
59150: LD_VAR 0 6
59154: PPUSH
59155: CALL_OW 488
59159: NOT
59160: IFFALSE 59164
// continue ;
59162: GO 59142
// if GetResourceTypeXY ( _x , _y ) then
59164: LD_VAR 0 5
59168: PPUSH
59169: LD_VAR 0 6
59173: PPUSH
59174: CALL_OW 283
59178: IFFALSE 59218
// result := Replace ( result , result + 1 , [ _x , _y ] ) ;
59180: LD_ADDR_VAR 0 4
59184: PUSH
59185: LD_VAR 0 4
59189: PPUSH
59190: LD_VAR 0 4
59194: PUSH
59195: LD_INT 1
59197: PLUS
59198: PPUSH
59199: LD_VAR 0 5
59203: PUSH
59204: LD_VAR 0 6
59208: PUSH
59209: EMPTY
59210: LIST
59211: LIST
59212: PPUSH
59213: CALL_OW 1
59217: ST_TO_ADDR
// end ;
59218: GO 59142
59220: POP
59221: POP
59222: GO 59122
59224: POP
59225: POP
// end ;
59226: LD_VAR 0 4
59230: RET
// export function AgressiveMove ( units , path ) ; var i , enemy , nearEnemy , cr , side , tag , ignoreCratesWeapon ; begin
59231: LD_INT 0
59233: PPUSH
59234: PPUSH
59235: PPUSH
59236: PPUSH
59237: PPUSH
59238: PPUSH
59239: PPUSH
59240: PPUSH
// if not units then
59241: LD_VAR 0 1
59245: NOT
59246: IFFALSE 59250
// exit ;
59248: GO 59776
// result := UnitFilter ( units , [ f_ok ] ) ;
59250: LD_ADDR_VAR 0 3
59254: PUSH
59255: LD_VAR 0 1
59259: PPUSH
59260: LD_INT 50
59262: PUSH
59263: EMPTY
59264: LIST
59265: PPUSH
59266: CALL_OW 72
59270: ST_TO_ADDR
// side := GetSide ( units [ 1 ] ) ;
59271: LD_ADDR_VAR 0 8
59275: PUSH
59276: LD_VAR 0 1
59280: PUSH
59281: LD_INT 1
59283: ARRAY
59284: PPUSH
59285: CALL_OW 255
59289: ST_TO_ADDR
// ignoreCratesWeapon := [ ar_selfpropelled_bomb , ar_bio_bomb , ru_time_lapser ] ;
59290: LD_ADDR_VAR 0 10
59294: PUSH
59295: LD_INT 29
59297: PUSH
59298: LD_EXP 162
59302: PUSH
59303: LD_INT 49
59305: PUSH
59306: EMPTY
59307: LIST
59308: LIST
59309: LIST
59310: ST_TO_ADDR
// if not result then
59311: LD_VAR 0 3
59315: NOT
59316: IFFALSE 59320
// exit ;
59318: GO 59776
// enemy := FilterAllUnits ( [ f_enemy , side ] ) ;
59320: LD_ADDR_VAR 0 5
59324: PUSH
59325: LD_INT 81
59327: PUSH
59328: LD_VAR 0 8
59332: PUSH
59333: EMPTY
59334: LIST
59335: LIST
59336: PPUSH
59337: CALL_OW 69
59341: ST_TO_ADDR
// for i in result do
59342: LD_ADDR_VAR 0 4
59346: PUSH
59347: LD_VAR 0 3
59351: PUSH
59352: FOR_IN
59353: IFFALSE 59774
// begin tag := GetTag ( i ) + 1 ;
59355: LD_ADDR_VAR 0 9
59359: PUSH
59360: LD_VAR 0 4
59364: PPUSH
59365: CALL_OW 110
59369: PUSH
59370: LD_INT 1
59372: PLUS
59373: ST_TO_ADDR
// cr := GetCratesNearbyXY ( GetX ( i ) , GetY ( i ) , 6 ) ;
59374: LD_ADDR_VAR 0 7
59378: PUSH
59379: LD_VAR 0 4
59383: PPUSH
59384: CALL_OW 250
59388: PPUSH
59389: LD_VAR 0 4
59393: PPUSH
59394: CALL_OW 251
59398: PPUSH
59399: LD_INT 6
59401: PPUSH
59402: CALL 58973 0 3
59406: ST_TO_ADDR
// if GetType ( i ) = unit_vehicle and cr and not GetWeapon ( i ) in ignoreCratesWeapon then
59407: LD_VAR 0 4
59411: PPUSH
59412: CALL_OW 247
59416: PUSH
59417: LD_INT 2
59419: EQUAL
59420: PUSH
59421: LD_VAR 0 7
59425: AND
59426: PUSH
59427: LD_VAR 0 4
59431: PPUSH
59432: CALL_OW 264
59436: PUSH
59437: LD_VAR 0 10
59441: IN
59442: NOT
59443: AND
59444: IFFALSE 59483
// ComAttackPlace ( i , cr [ 1 ] [ 1 ] , cr [ 1 ] [ 2 ] ) else
59446: LD_VAR 0 4
59450: PPUSH
59451: LD_VAR 0 7
59455: PUSH
59456: LD_INT 1
59458: ARRAY
59459: PUSH
59460: LD_INT 1
59462: ARRAY
59463: PPUSH
59464: LD_VAR 0 7
59468: PUSH
59469: LD_INT 1
59471: ARRAY
59472: PUSH
59473: LD_INT 2
59475: ARRAY
59476: PPUSH
59477: CALL_OW 116
59481: GO 59772
// if path > tag then
59483: LD_VAR 0 2
59487: PUSH
59488: LD_VAR 0 9
59492: GREATER
59493: IFFALSE 59701
// begin nearEnemy := UnitFilter ( enemy , [ f_dist , i , 8 ] ) ;
59495: LD_ADDR_VAR 0 6
59499: PUSH
59500: LD_VAR 0 5
59504: PPUSH
59505: LD_INT 91
59507: PUSH
59508: LD_VAR 0 4
59512: PUSH
59513: LD_INT 8
59515: PUSH
59516: EMPTY
59517: LIST
59518: LIST
59519: LIST
59520: PPUSH
59521: CALL_OW 72
59525: ST_TO_ADDR
// if nearEnemy then
59526: LD_VAR 0 6
59530: IFFALSE 59599
// begin if GetWeapon ( i ) = ru_time_lapser then
59532: LD_VAR 0 4
59536: PPUSH
59537: CALL_OW 264
59541: PUSH
59542: LD_INT 49
59544: EQUAL
59545: IFFALSE 59573
// ComMoveUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) else
59547: LD_VAR 0 4
59551: PPUSH
59552: LD_VAR 0 6
59556: PPUSH
59557: LD_VAR 0 4
59561: PPUSH
59562: CALL_OW 74
59566: PPUSH
59567: CALL_OW 112
59571: GO 59597
// ComAttackUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) ;
59573: LD_VAR 0 4
59577: PPUSH
59578: LD_VAR 0 6
59582: PPUSH
59583: LD_VAR 0 4
59587: PPUSH
59588: CALL_OW 74
59592: PPUSH
59593: CALL_OW 115
// end else
59597: GO 59699
// if GetDistUnitXY ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) > 6 then
59599: LD_VAR 0 4
59603: PPUSH
59604: LD_VAR 0 2
59608: PUSH
59609: LD_VAR 0 9
59613: ARRAY
59614: PUSH
59615: LD_INT 1
59617: ARRAY
59618: PPUSH
59619: LD_VAR 0 2
59623: PUSH
59624: LD_VAR 0 9
59628: ARRAY
59629: PUSH
59630: LD_INT 2
59632: ARRAY
59633: PPUSH
59634: CALL_OW 297
59638: PUSH
59639: LD_INT 6
59641: GREATER
59642: IFFALSE 59685
// ComAgressiveMove ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) else
59644: LD_VAR 0 4
59648: PPUSH
59649: LD_VAR 0 2
59653: PUSH
59654: LD_VAR 0 9
59658: ARRAY
59659: PUSH
59660: LD_INT 1
59662: ARRAY
59663: PPUSH
59664: LD_VAR 0 2
59668: PUSH
59669: LD_VAR 0 9
59673: ARRAY
59674: PUSH
59675: LD_INT 2
59677: ARRAY
59678: PPUSH
59679: CALL_OW 114
59683: GO 59699
// SetTag ( i , tag ) ;
59685: LD_VAR 0 4
59689: PPUSH
59690: LD_VAR 0 9
59694: PPUSH
59695: CALL_OW 109
// end else
59699: GO 59772
// if enemy then
59701: LD_VAR 0 5
59705: IFFALSE 59772
// begin if GetWeapon ( i ) = ru_time_lapser then
59707: LD_VAR 0 4
59711: PPUSH
59712: CALL_OW 264
59716: PUSH
59717: LD_INT 49
59719: EQUAL
59720: IFFALSE 59748
// ComMoveUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
59722: LD_VAR 0 4
59726: PPUSH
59727: LD_VAR 0 5
59731: PPUSH
59732: LD_VAR 0 4
59736: PPUSH
59737: CALL_OW 74
59741: PPUSH
59742: CALL_OW 112
59746: GO 59772
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
59748: LD_VAR 0 4
59752: PPUSH
59753: LD_VAR 0 5
59757: PPUSH
59758: LD_VAR 0 4
59762: PPUSH
59763: CALL_OW 74
59767: PPUSH
59768: CALL_OW 115
// end ; end ;
59772: GO 59352
59774: POP
59775: POP
// end ;
59776: LD_VAR 0 3
59780: RET
// export function ComLookAtDir ( unit , direction ) ; var x , y ; begin
59781: LD_INT 0
59783: PPUSH
59784: PPUSH
59785: PPUSH
// if not unit or IsInUnit ( unit ) then
59786: LD_VAR 0 1
59790: NOT
59791: PUSH
59792: LD_VAR 0 1
59796: PPUSH
59797: CALL_OW 310
59801: OR
59802: IFFALSE 59806
// exit ;
59804: GO 59897
// x := ShiftX ( GetX ( unit ) , direction , 1 ) ;
59806: LD_ADDR_VAR 0 4
59810: PUSH
59811: LD_VAR 0 1
59815: PPUSH
59816: CALL_OW 250
59820: PPUSH
59821: LD_VAR 0 2
59825: PPUSH
59826: LD_INT 1
59828: PPUSH
59829: CALL_OW 272
59833: ST_TO_ADDR
// y := ShiftY ( GetY ( unit ) , direction , 1 ) ;
59834: LD_ADDR_VAR 0 5
59838: PUSH
59839: LD_VAR 0 1
59843: PPUSH
59844: CALL_OW 251
59848: PPUSH
59849: LD_VAR 0 2
59853: PPUSH
59854: LD_INT 1
59856: PPUSH
59857: CALL_OW 273
59861: ST_TO_ADDR
// if ValidHex ( x , y ) then
59862: LD_VAR 0 4
59866: PPUSH
59867: LD_VAR 0 5
59871: PPUSH
59872: CALL_OW 488
59876: IFFALSE 59897
// ComTurnXY ( unit , x , y ) ;
59878: LD_VAR 0 1
59882: PPUSH
59883: LD_VAR 0 4
59887: PPUSH
59888: LD_VAR 0 5
59892: PPUSH
59893: CALL_OW 118
// end ;
59897: LD_VAR 0 3
59901: RET
// export function SeeUnits ( side , units ) ; var i ; begin
59902: LD_INT 0
59904: PPUSH
59905: PPUSH
// result := false ;
59906: LD_ADDR_VAR 0 3
59910: PUSH
59911: LD_INT 0
59913: ST_TO_ADDR
// if not units then
59914: LD_VAR 0 2
59918: NOT
59919: IFFALSE 59923
// exit ;
59921: GO 59968
// for i in units do
59923: LD_ADDR_VAR 0 4
59927: PUSH
59928: LD_VAR 0 2
59932: PUSH
59933: FOR_IN
59934: IFFALSE 59966
// if See ( side , i ) then
59936: LD_VAR 0 1
59940: PPUSH
59941: LD_VAR 0 4
59945: PPUSH
59946: CALL_OW 292
59950: IFFALSE 59964
// begin result := true ;
59952: LD_ADDR_VAR 0 3
59956: PUSH
59957: LD_INT 1
59959: ST_TO_ADDR
// exit ;
59960: POP
59961: POP
59962: GO 59968
// end ;
59964: GO 59933
59966: POP
59967: POP
// end ;
59968: LD_VAR 0 3
59972: RET
// export function GetNearestPoint ( unit , points ) ; var i , dist , tmpDist ; begin
59973: LD_INT 0
59975: PPUSH
59976: PPUSH
59977: PPUSH
59978: PPUSH
// if not unit or not points then
59979: LD_VAR 0 1
59983: NOT
59984: PUSH
59985: LD_VAR 0 2
59989: NOT
59990: OR
59991: IFFALSE 59995
// exit ;
59993: GO 60085
// dist := 99999 ;
59995: LD_ADDR_VAR 0 5
59999: PUSH
60000: LD_INT 99999
60002: ST_TO_ADDR
// for i in points do
60003: LD_ADDR_VAR 0 4
60007: PUSH
60008: LD_VAR 0 2
60012: PUSH
60013: FOR_IN
60014: IFFALSE 60083
// begin tmpDist := GetDistUnitXY ( unit , i [ 1 ] , i [ 2 ] ) ;
60016: LD_ADDR_VAR 0 6
60020: PUSH
60021: LD_VAR 0 1
60025: PPUSH
60026: LD_VAR 0 4
60030: PUSH
60031: LD_INT 1
60033: ARRAY
60034: PPUSH
60035: LD_VAR 0 4
60039: PUSH
60040: LD_INT 2
60042: ARRAY
60043: PPUSH
60044: CALL_OW 297
60048: ST_TO_ADDR
// if tmpDist < dist then
60049: LD_VAR 0 6
60053: PUSH
60054: LD_VAR 0 5
60058: LESS
60059: IFFALSE 60081
// begin result := i ;
60061: LD_ADDR_VAR 0 3
60065: PUSH
60066: LD_VAR 0 4
60070: ST_TO_ADDR
// dist := tmpDist ;
60071: LD_ADDR_VAR 0 5
60075: PUSH
60076: LD_VAR 0 6
60080: ST_TO_ADDR
// end ; end ;
60081: GO 60013
60083: POP
60084: POP
// end ;
60085: LD_VAR 0 3
60089: RET
// export function CreateBehemoth ( side , x , y , d ) ; begin
60090: LD_INT 0
60092: PPUSH
// uc_side := side ;
60093: LD_ADDR_OWVAR 20
60097: PUSH
60098: LD_VAR 0 1
60102: ST_TO_ADDR
// uc_nation := 3 ;
60103: LD_ADDR_OWVAR 21
60107: PUSH
60108: LD_INT 3
60110: ST_TO_ADDR
// vc_chassis := 25 ;
60111: LD_ADDR_OWVAR 37
60115: PUSH
60116: LD_INT 25
60118: ST_TO_ADDR
// vc_engine := engine_siberite ;
60119: LD_ADDR_OWVAR 39
60123: PUSH
60124: LD_INT 3
60126: ST_TO_ADDR
// vc_control := control_computer ;
60127: LD_ADDR_OWVAR 38
60131: PUSH
60132: LD_INT 3
60134: ST_TO_ADDR
// vc_weapon := 59 ;
60135: LD_ADDR_OWVAR 40
60139: PUSH
60140: LD_INT 59
60142: ST_TO_ADDR
// result := CreateVehicle ;
60143: LD_ADDR_VAR 0 5
60147: PUSH
60148: CALL_OW 45
60152: ST_TO_ADDR
// SetDir ( result , d ) ;
60153: LD_VAR 0 5
60157: PPUSH
60158: LD_VAR 0 4
60162: PPUSH
60163: CALL_OW 233
// PlaceUnitXY ( result , x , y , false ) ;
60167: LD_VAR 0 5
60171: PPUSH
60172: LD_VAR 0 2
60176: PPUSH
60177: LD_VAR 0 3
60181: PPUSH
60182: LD_INT 0
60184: PPUSH
60185: CALL_OW 48
// end ;
60189: LD_VAR 0 5
60193: RET
// export function GetMultiCargo ( cargo ) ; var i , tmp ; begin
60194: LD_INT 0
60196: PPUSH
60197: PPUSH
60198: PPUSH
// result := [ 0 , 0 , 0 , 0 ] ;
60199: LD_ADDR_VAR 0 2
60203: PUSH
60204: LD_INT 0
60206: PUSH
60207: LD_INT 0
60209: PUSH
60210: LD_INT 0
60212: PUSH
60213: LD_INT 0
60215: PUSH
60216: EMPTY
60217: LIST
60218: LIST
60219: LIST
60220: LIST
60221: ST_TO_ADDR
// if not cargo or not GetWeapon ( cargo ) in [ us_cargo_bay , ru_cargo_bay , ar_cargo_bay , ru_big_cargo_bay ] then
60222: LD_VAR 0 1
60226: NOT
60227: PUSH
60228: LD_VAR 0 1
60232: PPUSH
60233: CALL_OW 264
60237: PUSH
60238: LD_INT 12
60240: PUSH
60241: LD_INT 51
60243: PUSH
60244: LD_INT 32
60246: PUSH
60247: LD_EXP 159
60251: PUSH
60252: EMPTY
60253: LIST
60254: LIST
60255: LIST
60256: LIST
60257: IN
60258: NOT
60259: OR
60260: IFFALSE 60264
// exit ;
60262: GO 60362
// for i := 1 to 3 do
60264: LD_ADDR_VAR 0 3
60268: PUSH
60269: DOUBLE
60270: LD_INT 1
60272: DEC
60273: ST_TO_ADDR
60274: LD_INT 3
60276: PUSH
60277: FOR_TO
60278: IFFALSE 60360
// begin tmp := GetCargo ( cargo , i ) ;
60280: LD_ADDR_VAR 0 4
60284: PUSH
60285: LD_VAR 0 1
60289: PPUSH
60290: LD_VAR 0 3
60294: PPUSH
60295: CALL_OW 289
60299: ST_TO_ADDR
// result := Replace ( result , i , tmp ) ;
60300: LD_ADDR_VAR 0 2
60304: PUSH
60305: LD_VAR 0 2
60309: PPUSH
60310: LD_VAR 0 3
60314: PPUSH
60315: LD_VAR 0 4
60319: PPUSH
60320: CALL_OW 1
60324: ST_TO_ADDR
// result := Replace ( result , 4 , result [ 4 ] + tmp ) ;
60325: LD_ADDR_VAR 0 2
60329: PUSH
60330: LD_VAR 0 2
60334: PPUSH
60335: LD_INT 4
60337: PPUSH
60338: LD_VAR 0 2
60342: PUSH
60343: LD_INT 4
60345: ARRAY
60346: PUSH
60347: LD_VAR 0 4
60351: PLUS
60352: PPUSH
60353: CALL_OW 1
60357: ST_TO_ADDR
// end ;
60358: GO 60277
60360: POP
60361: POP
// end ;
60362: LD_VAR 0 2
60366: RET
// export function Length ( array ) ; begin
60367: LD_INT 0
60369: PPUSH
// result := array + 0 ;
60370: LD_ADDR_VAR 0 2
60374: PUSH
60375: LD_VAR 0 1
60379: PUSH
60380: LD_INT 0
60382: PLUS
60383: ST_TO_ADDR
// end ;
60384: LD_VAR 0 2
60388: RET
// export function PrepareArray ( array ) ; begin
60389: LD_INT 0
60391: PPUSH
// result := array diff 0 ;
60392: LD_ADDR_VAR 0 2
60396: PUSH
60397: LD_VAR 0 1
60401: PUSH
60402: LD_INT 0
60404: DIFF
60405: ST_TO_ADDR
// if not result [ 1 ] then
60406: LD_VAR 0 2
60410: PUSH
60411: LD_INT 1
60413: ARRAY
60414: NOT
60415: IFFALSE 60435
// result := Delete ( result , 1 ) ;
60417: LD_ADDR_VAR 0 2
60421: PUSH
60422: LD_VAR 0 2
60426: PPUSH
60427: LD_INT 1
60429: PPUSH
60430: CALL_OW 3
60434: ST_TO_ADDR
// end ; end_of_file
60435: LD_VAR 0 2
60439: RET
// export function SOS_UnitDestroyed ( un ) ; var i , eff , side ; begin
60440: LD_INT 0
60442: PPUSH
60443: PPUSH
60444: PPUSH
60445: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
60446: LD_VAR 0 1
60450: PPUSH
60451: CALL_OW 264
60455: PUSH
60456: LD_EXP 162
60460: EQUAL
60461: IFFALSE 60533
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
60463: LD_INT 68
60465: PPUSH
60466: LD_VAR 0 1
60470: PPUSH
60471: CALL_OW 255
60475: PPUSH
60476: CALL_OW 321
60480: PUSH
60481: LD_INT 2
60483: EQUAL
60484: IFFALSE 60496
// eff := 70 else
60486: LD_ADDR_VAR 0 4
60490: PUSH
60491: LD_INT 70
60493: ST_TO_ADDR
60494: GO 60504
// eff := 30 ;
60496: LD_ADDR_VAR 0 4
60500: PUSH
60501: LD_INT 30
60503: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
60504: LD_VAR 0 1
60508: PPUSH
60509: CALL_OW 250
60513: PPUSH
60514: LD_VAR 0 1
60518: PPUSH
60519: CALL_OW 251
60523: PPUSH
60524: LD_VAR 0 4
60528: PPUSH
60529: CALL_OW 495
// end ; end ;
60533: LD_VAR 0 2
60537: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
60538: LD_INT 0
60540: PPUSH
// end ;
60541: LD_VAR 0 4
60545: RET
// export function SOS_Command ( cmd ) ; begin
60546: LD_INT 0
60548: PPUSH
// end ;
60549: LD_VAR 0 2
60553: RET
// export function SOS_CommandUnitXY ( cmd , un , target , x , y ) ; begin
60554: LD_INT 0
60556: PPUSH
// end ;
60557: LD_VAR 0 6
60561: RET
// export function SOS_VehicleConstructed ( vehicle , factory ) ; var driver ; begin
60562: LD_INT 0
60564: PPUSH
60565: PPUSH
// if not vehicle or not factory then
60566: LD_VAR 0 1
60570: NOT
60571: PUSH
60572: LD_VAR 0 2
60576: NOT
60577: OR
60578: IFFALSE 60582
// exit ;
60580: GO 60813
// if factoryWaypoints >= factory then
60582: LD_EXP 155
60586: PUSH
60587: LD_VAR 0 2
60591: GREATEREQUAL
60592: IFFALSE 60813
// if factoryWaypoints [ factory ] then
60594: LD_EXP 155
60598: PUSH
60599: LD_VAR 0 2
60603: ARRAY
60604: IFFALSE 60813
// begin if GetControl ( vehicle ) = control_manual then
60606: LD_VAR 0 1
60610: PPUSH
60611: CALL_OW 263
60615: PUSH
60616: LD_INT 1
60618: EQUAL
60619: IFFALSE 60700
// begin driver := IsDrivenBy ( vehicle ) ;
60621: LD_ADDR_VAR 0 4
60625: PUSH
60626: LD_VAR 0 1
60630: PPUSH
60631: CALL_OW 311
60635: ST_TO_ADDR
// AddComMoveXY ( driver , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
60636: LD_VAR 0 4
60640: PPUSH
60641: LD_EXP 155
60645: PUSH
60646: LD_VAR 0 2
60650: ARRAY
60651: PUSH
60652: LD_INT 3
60654: ARRAY
60655: PPUSH
60656: LD_EXP 155
60660: PUSH
60661: LD_VAR 0 2
60665: ARRAY
60666: PUSH
60667: LD_INT 4
60669: ARRAY
60670: PPUSH
60671: CALL_OW 171
// AddComExitVehicle ( driver ) ;
60675: LD_VAR 0 4
60679: PPUSH
60680: CALL_OW 181
// AddComEnterUnit ( driver , factory ) ;
60684: LD_VAR 0 4
60688: PPUSH
60689: LD_VAR 0 2
60693: PPUSH
60694: CALL_OW 180
// end else
60698: GO 60813
// if GetControl ( vehicle ) = control_remote then
60700: LD_VAR 0 1
60704: PPUSH
60705: CALL_OW 263
60709: PUSH
60710: LD_INT 2
60712: EQUAL
60713: IFFALSE 60774
// begin wait ( 0 0$2 ) ;
60715: LD_INT 70
60717: PPUSH
60718: CALL_OW 67
// if Connect ( vehicle ) then
60722: LD_VAR 0 1
60726: PPUSH
60727: CALL 27334 0 1
60731: IFFALSE 60772
// AddComMoveXY ( vehicle , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
60733: LD_VAR 0 1
60737: PPUSH
60738: LD_EXP 155
60742: PUSH
60743: LD_VAR 0 2
60747: ARRAY
60748: PUSH
60749: LD_INT 3
60751: ARRAY
60752: PPUSH
60753: LD_EXP 155
60757: PUSH
60758: LD_VAR 0 2
60762: ARRAY
60763: PUSH
60764: LD_INT 4
60766: ARRAY
60767: PPUSH
60768: CALL_OW 171
// end else
60772: GO 60813
// AddComMoveXY ( vehicle , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
60774: LD_VAR 0 1
60778: PPUSH
60779: LD_EXP 155
60783: PUSH
60784: LD_VAR 0 2
60788: ARRAY
60789: PUSH
60790: LD_INT 3
60792: ARRAY
60793: PPUSH
60794: LD_EXP 155
60798: PUSH
60799: LD_VAR 0 2
60803: ARRAY
60804: PUSH
60805: LD_INT 4
60807: ARRAY
60808: PPUSH
60809: CALL_OW 171
// end ; end ;
60813: LD_VAR 0 3
60817: RET
// export function SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; begin
60818: LD_INT 0
60820: PPUSH
// if cmd = 250 and GetWeapon ( unit ) = ar_miner then
60821: LD_VAR 0 1
60825: PUSH
60826: LD_INT 250
60828: EQUAL
60829: PUSH
60830: LD_VAR 0 2
60834: PPUSH
60835: CALL_OW 264
60839: PUSH
60840: LD_EXP 165
60844: EQUAL
60845: AND
60846: IFFALSE 60867
// MinerPlaceMine ( unit , x , y ) ;
60848: LD_VAR 0 2
60852: PPUSH
60853: LD_VAR 0 4
60857: PPUSH
60858: LD_VAR 0 5
60862: PPUSH
60863: CALL 63266 0 3
// if cmd = 251 and GetWeapon ( unit ) = ar_miner then
60867: LD_VAR 0 1
60871: PUSH
60872: LD_INT 251
60874: EQUAL
60875: PUSH
60876: LD_VAR 0 2
60880: PPUSH
60881: CALL_OW 264
60885: PUSH
60886: LD_EXP 165
60890: EQUAL
60891: AND
60892: IFFALSE 60913
// MinerDetonateMine ( unit , x , y ) ;
60894: LD_VAR 0 2
60898: PPUSH
60899: LD_VAR 0 4
60903: PPUSH
60904: LD_VAR 0 5
60908: PPUSH
60909: CALL 63543 0 3
// if cmd = 252 and GetWeapon ( unit ) = ar_miner then
60913: LD_VAR 0 1
60917: PUSH
60918: LD_INT 252
60920: EQUAL
60921: PUSH
60922: LD_VAR 0 2
60926: PPUSH
60927: CALL_OW 264
60931: PUSH
60932: LD_EXP 165
60936: EQUAL
60937: AND
60938: IFFALSE 60959
// MinerCreateMinefield ( unit , x , y ) ;
60940: LD_VAR 0 2
60944: PPUSH
60945: LD_VAR 0 4
60949: PPUSH
60950: LD_VAR 0 5
60954: PPUSH
60955: CALL 63960 0 3
// if cmd = 253 and GetClass ( unit ) = class_sniper then
60959: LD_VAR 0 1
60963: PUSH
60964: LD_INT 253
60966: EQUAL
60967: PUSH
60968: LD_VAR 0 2
60972: PPUSH
60973: CALL_OW 257
60977: PUSH
60978: LD_INT 5
60980: EQUAL
60981: AND
60982: IFFALSE 61003
// ComBinocular ( unit , x , y ) ;
60984: LD_VAR 0 2
60988: PPUSH
60989: LD_VAR 0 4
60993: PPUSH
60994: LD_VAR 0 5
60998: PPUSH
60999: CALL 64331 0 3
// if cmd = 254 and GetWeapon ( unit ) = us_hack and GetControl ( selectedUnit ) = control_computer then
61003: LD_VAR 0 1
61007: PUSH
61008: LD_INT 254
61010: EQUAL
61011: PUSH
61012: LD_VAR 0 2
61016: PPUSH
61017: CALL_OW 264
61021: PUSH
61022: LD_EXP 160
61026: EQUAL
61027: AND
61028: PUSH
61029: LD_VAR 0 3
61033: PPUSH
61034: CALL_OW 263
61038: PUSH
61039: LD_INT 3
61041: EQUAL
61042: AND
61043: IFFALSE 61059
// HackDestroyVehicle ( unit , selectedUnit ) ;
61045: LD_VAR 0 2
61049: PPUSH
61050: LD_VAR 0 3
61054: PPUSH
61055: CALL 62626 0 2
// if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
61059: LD_VAR 0 1
61063: PUSH
61064: LD_INT 255
61066: EQUAL
61067: PUSH
61068: LD_VAR 0 2
61072: PPUSH
61073: CALL_OW 264
61077: PUSH
61078: LD_INT 14
61080: PUSH
61081: LD_INT 53
61083: PUSH
61084: EMPTY
61085: LIST
61086: LIST
61087: IN
61088: AND
61089: PUSH
61090: LD_VAR 0 4
61094: PPUSH
61095: LD_VAR 0 5
61099: PPUSH
61100: CALL_OW 488
61104: AND
61105: IFFALSE 61129
// CutTreeXYR ( unit , x , y , 12 ) ;
61107: LD_VAR 0 2
61111: PPUSH
61112: LD_VAR 0 4
61116: PPUSH
61117: LD_VAR 0 5
61121: PPUSH
61122: LD_INT 12
61124: PPUSH
61125: CALL 61192 0 4
// if cmd = 256 then
61129: LD_VAR 0 1
61133: PUSH
61134: LD_INT 256
61136: EQUAL
61137: IFFALSE 61158
// SetFactoryWaypoint ( unit , x , y ) ;
61139: LD_VAR 0 2
61143: PPUSH
61144: LD_VAR 0 4
61148: PPUSH
61149: LD_VAR 0 5
61153: PPUSH
61154: CALL 79089 0 3
// if cmd = 257 then
61158: LD_VAR 0 1
61162: PUSH
61163: LD_INT 257
61165: EQUAL
61166: IFFALSE 61187
// SetWarehouseGatheringPoint ( unit , x , y ) ;
61168: LD_VAR 0 2
61172: PPUSH
61173: LD_VAR 0 4
61177: PPUSH
61178: LD_VAR 0 5
61182: PPUSH
61183: CALL 79451 0 3
// end ;
61187: LD_VAR 0 6
61191: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
61192: LD_INT 0
61194: PPUSH
61195: PPUSH
61196: PPUSH
61197: PPUSH
61198: PPUSH
61199: PPUSH
61200: PPUSH
61201: PPUSH
61202: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
61203: LD_VAR 0 1
61207: NOT
61208: PUSH
61209: LD_VAR 0 2
61213: PPUSH
61214: LD_VAR 0 3
61218: PPUSH
61219: CALL_OW 488
61223: NOT
61224: OR
61225: PUSH
61226: LD_VAR 0 4
61230: NOT
61231: OR
61232: IFFALSE 61236
// exit ;
61234: GO 61576
// list := [ ] ;
61236: LD_ADDR_VAR 0 13
61240: PUSH
61241: EMPTY
61242: ST_TO_ADDR
// if x - r < 0 then
61243: LD_VAR 0 2
61247: PUSH
61248: LD_VAR 0 4
61252: MINUS
61253: PUSH
61254: LD_INT 0
61256: LESS
61257: IFFALSE 61269
// min_x := 0 else
61259: LD_ADDR_VAR 0 7
61263: PUSH
61264: LD_INT 0
61266: ST_TO_ADDR
61267: GO 61285
// min_x := x - r ;
61269: LD_ADDR_VAR 0 7
61273: PUSH
61274: LD_VAR 0 2
61278: PUSH
61279: LD_VAR 0 4
61283: MINUS
61284: ST_TO_ADDR
// if y - r < 0 then
61285: LD_VAR 0 3
61289: PUSH
61290: LD_VAR 0 4
61294: MINUS
61295: PUSH
61296: LD_INT 0
61298: LESS
61299: IFFALSE 61311
// min_y := 0 else
61301: LD_ADDR_VAR 0 8
61305: PUSH
61306: LD_INT 0
61308: ST_TO_ADDR
61309: GO 61327
// min_y := y - r ;
61311: LD_ADDR_VAR 0 8
61315: PUSH
61316: LD_VAR 0 3
61320: PUSH
61321: LD_VAR 0 4
61325: MINUS
61326: ST_TO_ADDR
// max_x := x + r ;
61327: LD_ADDR_VAR 0 9
61331: PUSH
61332: LD_VAR 0 2
61336: PUSH
61337: LD_VAR 0 4
61341: PLUS
61342: ST_TO_ADDR
// max_y := y + r ;
61343: LD_ADDR_VAR 0 10
61347: PUSH
61348: LD_VAR 0 3
61352: PUSH
61353: LD_VAR 0 4
61357: PLUS
61358: ST_TO_ADDR
// for _x = min_x to max_x do
61359: LD_ADDR_VAR 0 11
61363: PUSH
61364: DOUBLE
61365: LD_VAR 0 7
61369: DEC
61370: ST_TO_ADDR
61371: LD_VAR 0 9
61375: PUSH
61376: FOR_TO
61377: IFFALSE 61494
// for _y = min_y to max_y do
61379: LD_ADDR_VAR 0 12
61383: PUSH
61384: DOUBLE
61385: LD_VAR 0 8
61389: DEC
61390: ST_TO_ADDR
61391: LD_VAR 0 10
61395: PUSH
61396: FOR_TO
61397: IFFALSE 61490
// begin if not ValidHex ( _x , _y ) then
61399: LD_VAR 0 11
61403: PPUSH
61404: LD_VAR 0 12
61408: PPUSH
61409: CALL_OW 488
61413: NOT
61414: IFFALSE 61418
// continue ;
61416: GO 61396
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
61418: LD_VAR 0 11
61422: PPUSH
61423: LD_VAR 0 12
61427: PPUSH
61428: CALL_OW 351
61432: PUSH
61433: LD_VAR 0 11
61437: PPUSH
61438: LD_VAR 0 12
61442: PPUSH
61443: CALL_OW 554
61447: AND
61448: IFFALSE 61488
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
61450: LD_ADDR_VAR 0 13
61454: PUSH
61455: LD_VAR 0 13
61459: PPUSH
61460: LD_VAR 0 13
61464: PUSH
61465: LD_INT 1
61467: PLUS
61468: PPUSH
61469: LD_VAR 0 11
61473: PUSH
61474: LD_VAR 0 12
61478: PUSH
61479: EMPTY
61480: LIST
61481: LIST
61482: PPUSH
61483: CALL_OW 2
61487: ST_TO_ADDR
// end ;
61488: GO 61396
61490: POP
61491: POP
61492: GO 61376
61494: POP
61495: POP
// if not list then
61496: LD_VAR 0 13
61500: NOT
61501: IFFALSE 61505
// exit ;
61503: GO 61576
// for i in list do
61505: LD_ADDR_VAR 0 6
61509: PUSH
61510: LD_VAR 0 13
61514: PUSH
61515: FOR_IN
61516: IFFALSE 61574
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
61518: LD_VAR 0 1
61522: PPUSH
61523: LD_STRING M
61525: PUSH
61526: LD_VAR 0 6
61530: PUSH
61531: LD_INT 1
61533: ARRAY
61534: PUSH
61535: LD_VAR 0 6
61539: PUSH
61540: LD_INT 2
61542: ARRAY
61543: PUSH
61544: LD_INT 0
61546: PUSH
61547: LD_INT 0
61549: PUSH
61550: LD_INT 0
61552: PUSH
61553: LD_INT 0
61555: PUSH
61556: EMPTY
61557: LIST
61558: LIST
61559: LIST
61560: LIST
61561: LIST
61562: LIST
61563: LIST
61564: PUSH
61565: EMPTY
61566: LIST
61567: PPUSH
61568: CALL_OW 447
61572: GO 61515
61574: POP
61575: POP
// end ;
61576: LD_VAR 0 5
61580: RET
// export initHack , hackTanks , hackTanksCaptured , hackLimit , hackDist , hackCounter ; every 0 0$1 trigger not initHack do
61581: LD_EXP 87
61585: NOT
61586: IFFALSE 61636
61588: GO 61590
61590: DISABLE
// begin initHack := true ;
61591: LD_ADDR_EXP 87
61595: PUSH
61596: LD_INT 1
61598: ST_TO_ADDR
// hackTanks := [ ] ;
61599: LD_ADDR_EXP 88
61603: PUSH
61604: EMPTY
61605: ST_TO_ADDR
// hackTanksCaptured := [ ] ;
61606: LD_ADDR_EXP 89
61610: PUSH
61611: EMPTY
61612: ST_TO_ADDR
// hackLimit := 3 ;
61613: LD_ADDR_EXP 90
61617: PUSH
61618: LD_INT 3
61620: ST_TO_ADDR
// hackDist := 12 ;
61621: LD_ADDR_EXP 91
61625: PUSH
61626: LD_INT 12
61628: ST_TO_ADDR
// hackCounter := [ ] ;
61629: LD_ADDR_EXP 92
61633: PUSH
61634: EMPTY
61635: ST_TO_ADDR
// end ;
61636: END
// every 0 0$1 trigger initHack and FilterAllUnits ( [ f_weapon , us_hack ] ) do var i , tmp ;
61637: LD_EXP 87
61641: PUSH
61642: LD_INT 34
61644: PUSH
61645: LD_EXP 160
61649: PUSH
61650: EMPTY
61651: LIST
61652: LIST
61653: PPUSH
61654: CALL_OW 69
61658: AND
61659: IFFALSE 61914
61661: GO 61663
61663: DISABLE
61664: LD_INT 0
61666: PPUSH
61667: PPUSH
// begin enable ;
61668: ENABLE
// for i in FilterAllUnits ( [ f_weapon , us_hack ] ) do
61669: LD_ADDR_VAR 0 1
61673: PUSH
61674: LD_INT 34
61676: PUSH
61677: LD_EXP 160
61681: PUSH
61682: EMPTY
61683: LIST
61684: LIST
61685: PPUSH
61686: CALL_OW 69
61690: PUSH
61691: FOR_IN
61692: IFFALSE 61912
// begin if not i in hackTanks then
61694: LD_VAR 0 1
61698: PUSH
61699: LD_EXP 88
61703: IN
61704: NOT
61705: IFFALSE 61788
// begin hackTanks := Replace ( hackTanks , hackTanks + 1 , i ) ;
61707: LD_ADDR_EXP 88
61711: PUSH
61712: LD_EXP 88
61716: PPUSH
61717: LD_EXP 88
61721: PUSH
61722: LD_INT 1
61724: PLUS
61725: PPUSH
61726: LD_VAR 0 1
61730: PPUSH
61731: CALL_OW 1
61735: ST_TO_ADDR
// hackTanksCaptured := Replace ( hackTanksCaptured , hackTanksCaptured + 1 , [ ] ) ;
61736: LD_ADDR_EXP 89
61740: PUSH
61741: LD_EXP 89
61745: PPUSH
61746: LD_EXP 89
61750: PUSH
61751: LD_INT 1
61753: PLUS
61754: PPUSH
61755: EMPTY
61756: PPUSH
61757: CALL_OW 1
61761: ST_TO_ADDR
// hackCounter := Replace ( hackCounter , hackCounter + 1 , [ ] ) ;
61762: LD_ADDR_EXP 92
61766: PUSH
61767: LD_EXP 92
61771: PPUSH
61772: LD_EXP 92
61776: PUSH
61777: LD_INT 1
61779: PLUS
61780: PPUSH
61781: EMPTY
61782: PPUSH
61783: CALL_OW 1
61787: ST_TO_ADDR
// end ; if not IsOk ( i ) then
61788: LD_VAR 0 1
61792: PPUSH
61793: CALL_OW 302
61797: NOT
61798: IFFALSE 61811
// begin HackUnlinkAll ( i ) ;
61800: LD_VAR 0 1
61804: PPUSH
61805: CALL 61917 0 1
// continue ;
61809: GO 61691
// end ; HackCheckCapturedStatus ( i ) ;
61811: LD_VAR 0 1
61815: PPUSH
61816: CALL 62360 0 1
// tmp := FilterAllUnits ( [ [ f_enemy , GetSide ( i ) ] , [ f_control , control_computer ] , [ f_dist , i , hackDist ] , [ f_ok ] ] ) ;
61820: LD_ADDR_VAR 0 2
61824: PUSH
61825: LD_INT 81
61827: PUSH
61828: LD_VAR 0 1
61832: PPUSH
61833: CALL_OW 255
61837: PUSH
61838: EMPTY
61839: LIST
61840: LIST
61841: PUSH
61842: LD_INT 33
61844: PUSH
61845: LD_INT 3
61847: PUSH
61848: EMPTY
61849: LIST
61850: LIST
61851: PUSH
61852: LD_INT 91
61854: PUSH
61855: LD_VAR 0 1
61859: PUSH
61860: LD_EXP 91
61864: PUSH
61865: EMPTY
61866: LIST
61867: LIST
61868: LIST
61869: PUSH
61870: LD_INT 50
61872: PUSH
61873: EMPTY
61874: LIST
61875: PUSH
61876: EMPTY
61877: LIST
61878: LIST
61879: LIST
61880: LIST
61881: PPUSH
61882: CALL_OW 69
61886: ST_TO_ADDR
// if not tmp then
61887: LD_VAR 0 2
61891: NOT
61892: IFFALSE 61896
// continue ;
61894: GO 61691
// HackLink ( i , tmp ) ;
61896: LD_VAR 0 1
61900: PPUSH
61901: LD_VAR 0 2
61905: PPUSH
61906: CALL 62053 0 2
// end ;
61910: GO 61691
61912: POP
61913: POP
// end ;
61914: PPOPN 2
61916: END
// function HackUnlinkAll ( hack ) ; var i , index ; begin
61917: LD_INT 0
61919: PPUSH
61920: PPUSH
61921: PPUSH
// if not hack in hackTanks then
61922: LD_VAR 0 1
61926: PUSH
61927: LD_EXP 88
61931: IN
61932: NOT
61933: IFFALSE 61937
// exit ;
61935: GO 62048
// index := GetElementIndex ( hackTanks , hack ) ;
61937: LD_ADDR_VAR 0 4
61941: PUSH
61942: LD_EXP 88
61946: PPUSH
61947: LD_VAR 0 1
61951: PPUSH
61952: CALL 24148 0 2
61956: ST_TO_ADDR
// if hackTanksCaptured [ index ] then
61957: LD_EXP 89
61961: PUSH
61962: LD_VAR 0 4
61966: ARRAY
61967: IFFALSE 62048
// begin for i in hackTanksCaptured [ index ] do
61969: LD_ADDR_VAR 0 3
61973: PUSH
61974: LD_EXP 89
61978: PUSH
61979: LD_VAR 0 4
61983: ARRAY
61984: PUSH
61985: FOR_IN
61986: IFFALSE 62012
// SetSide ( i [ 1 ] , i [ 2 ] ) ;
61988: LD_VAR 0 3
61992: PUSH
61993: LD_INT 1
61995: ARRAY
61996: PPUSH
61997: LD_VAR 0 3
62001: PUSH
62002: LD_INT 2
62004: ARRAY
62005: PPUSH
62006: CALL_OW 235
62010: GO 61985
62012: POP
62013: POP
// hackTanksCaptured := Replace ( hackTanksCaptured , index , [ ] ) ;
62014: LD_ADDR_EXP 89
62018: PUSH
62019: LD_EXP 89
62023: PPUSH
62024: LD_VAR 0 4
62028: PPUSH
62029: EMPTY
62030: PPUSH
62031: CALL_OW 1
62035: ST_TO_ADDR
// SetUnitDisplayNumber ( hack , 0 ) ;
62036: LD_VAR 0 1
62040: PPUSH
62041: LD_INT 0
62043: PPUSH
62044: CALL_OW 505
// end ; end ;
62048: LD_VAR 0 2
62052: RET
// function HackLink ( hack , vehicles ) ; var i , index ; begin
62053: LD_INT 0
62055: PPUSH
62056: PPUSH
62057: PPUSH
// if not hack in hackTanks or not vehicles then
62058: LD_VAR 0 1
62062: PUSH
62063: LD_EXP 88
62067: IN
62068: NOT
62069: PUSH
62070: LD_VAR 0 2
62074: NOT
62075: OR
62076: IFFALSE 62080
// exit ;
62078: GO 62355
// vehicles := SortByDistanceUnit ( hack , vehicles , true , true ) ;
62080: LD_ADDR_VAR 0 2
62084: PUSH
62085: LD_VAR 0 1
62089: PPUSH
62090: LD_VAR 0 2
62094: PPUSH
62095: LD_INT 1
62097: PPUSH
62098: LD_INT 1
62100: PPUSH
62101: CALL 24798 0 4
62105: ST_TO_ADDR
// index := GetElementIndex ( hackTanks , hack ) ;
62106: LD_ADDR_VAR 0 5
62110: PUSH
62111: LD_EXP 88
62115: PPUSH
62116: LD_VAR 0 1
62120: PPUSH
62121: CALL 24148 0 2
62125: ST_TO_ADDR
// if hackTanksCaptured [ index ] < hackLimit then
62126: LD_EXP 89
62130: PUSH
62131: LD_VAR 0 5
62135: ARRAY
62136: PUSH
62137: LD_EXP 90
62141: LESS
62142: IFFALSE 62331
// begin for i := 1 to vehicles do
62144: LD_ADDR_VAR 0 4
62148: PUSH
62149: DOUBLE
62150: LD_INT 1
62152: DEC
62153: ST_TO_ADDR
62154: LD_VAR 0 2
62158: PUSH
62159: FOR_TO
62160: IFFALSE 62329
// begin if hackTanksCaptured [ index ] = hackLimit then
62162: LD_EXP 89
62166: PUSH
62167: LD_VAR 0 5
62171: ARRAY
62172: PUSH
62173: LD_EXP 90
62177: EQUAL
62178: IFFALSE 62182
// break ;
62180: GO 62329
// hackCounter := Replace ( hackCounter , index , hackCounter [ index ] + 1 ) ;
62182: LD_ADDR_EXP 92
62186: PUSH
62187: LD_EXP 92
62191: PPUSH
62192: LD_VAR 0 5
62196: PPUSH
62197: LD_EXP 92
62201: PUSH
62202: LD_VAR 0 5
62206: ARRAY
62207: PUSH
62208: LD_INT 1
62210: PLUS
62211: PPUSH
62212: CALL_OW 1
62216: ST_TO_ADDR
// hackTanksCaptured := ReplaceIn ( hackTanksCaptured , [ index , hackTanksCaptured [ index ] + 1 ] , [ vehicles [ i ] , GetSide ( vehicles [ i ] ) ] ) ;
62217: LD_ADDR_EXP 89
62221: PUSH
62222: LD_EXP 89
62226: PPUSH
62227: LD_VAR 0 5
62231: PUSH
62232: LD_EXP 89
62236: PUSH
62237: LD_VAR 0 5
62241: ARRAY
62242: PUSH
62243: LD_INT 1
62245: PLUS
62246: PUSH
62247: EMPTY
62248: LIST
62249: LIST
62250: PPUSH
62251: LD_VAR 0 2
62255: PUSH
62256: LD_VAR 0 4
62260: ARRAY
62261: PUSH
62262: LD_VAR 0 2
62266: PUSH
62267: LD_VAR 0 4
62271: ARRAY
62272: PPUSH
62273: CALL_OW 255
62277: PUSH
62278: EMPTY
62279: LIST
62280: LIST
62281: PPUSH
62282: CALL 24363 0 3
62286: ST_TO_ADDR
// SetSide ( vehicles [ i ] , GetSide ( hack ) ) ;
62287: LD_VAR 0 2
62291: PUSH
62292: LD_VAR 0 4
62296: ARRAY
62297: PPUSH
62298: LD_VAR 0 1
62302: PPUSH
62303: CALL_OW 255
62307: PPUSH
62308: CALL_OW 235
// ComStop ( vehicles [ i ] ) ;
62312: LD_VAR 0 2
62316: PUSH
62317: LD_VAR 0 4
62321: ARRAY
62322: PPUSH
62323: CALL_OW 141
// end ;
62327: GO 62159
62329: POP
62330: POP
// end ; SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
62331: LD_VAR 0 1
62335: PPUSH
62336: LD_EXP 89
62340: PUSH
62341: LD_VAR 0 5
62345: ARRAY
62346: PUSH
62347: LD_INT 0
62349: PLUS
62350: PPUSH
62351: CALL_OW 505
// end ;
62355: LD_VAR 0 3
62359: RET
// function HackCheckCapturedStatus ( hack ) ; var i , index , tmp ; begin
62360: LD_INT 0
62362: PPUSH
62363: PPUSH
62364: PPUSH
62365: PPUSH
// if not hack in hackTanks then
62366: LD_VAR 0 1
62370: PUSH
62371: LD_EXP 88
62375: IN
62376: NOT
62377: IFFALSE 62381
// exit ;
62379: GO 62621
// index := GetElementIndex ( hackTanks , hack ) ;
62381: LD_ADDR_VAR 0 4
62385: PUSH
62386: LD_EXP 88
62390: PPUSH
62391: LD_VAR 0 1
62395: PPUSH
62396: CALL 24148 0 2
62400: ST_TO_ADDR
// for i := hackTanksCaptured [ index ] downto 1 do
62401: LD_ADDR_VAR 0 3
62405: PUSH
62406: DOUBLE
62407: LD_EXP 89
62411: PUSH
62412: LD_VAR 0 4
62416: ARRAY
62417: INC
62418: ST_TO_ADDR
62419: LD_INT 1
62421: PUSH
62422: FOR_DOWNTO
62423: IFFALSE 62595
// begin tmp := hackTanksCaptured [ index ] [ i ] ;
62425: LD_ADDR_VAR 0 5
62429: PUSH
62430: LD_EXP 89
62434: PUSH
62435: LD_VAR 0 4
62439: ARRAY
62440: PUSH
62441: LD_VAR 0 3
62445: ARRAY
62446: ST_TO_ADDR
// if not IsOk ( tmp [ 1 ] ) or GetSide ( tmp [ 1 ] ) <> GetSide ( hack ) then
62447: LD_VAR 0 5
62451: PUSH
62452: LD_INT 1
62454: ARRAY
62455: PPUSH
62456: CALL_OW 302
62460: NOT
62461: PUSH
62462: LD_VAR 0 5
62466: PUSH
62467: LD_INT 1
62469: ARRAY
62470: PPUSH
62471: CALL_OW 255
62475: PUSH
62476: LD_VAR 0 1
62480: PPUSH
62481: CALL_OW 255
62485: NONEQUAL
62486: OR
62487: IFFALSE 62593
// begin if IsPlaced ( tmp [ 1 ] ) and GetSide ( tmp [ 1 ] ) = GetSide ( hack ) then
62489: LD_VAR 0 5
62493: PUSH
62494: LD_INT 1
62496: ARRAY
62497: PPUSH
62498: CALL_OW 305
62502: PUSH
62503: LD_VAR 0 5
62507: PUSH
62508: LD_INT 1
62510: ARRAY
62511: PPUSH
62512: CALL_OW 255
62516: PUSH
62517: LD_VAR 0 1
62521: PPUSH
62522: CALL_OW 255
62526: EQUAL
62527: AND
62528: IFFALSE 62552
// SetSide ( tmp [ 1 ] , tmp [ 2 ] ) ;
62530: LD_VAR 0 5
62534: PUSH
62535: LD_INT 1
62537: ARRAY
62538: PPUSH
62539: LD_VAR 0 5
62543: PUSH
62544: LD_INT 2
62546: ARRAY
62547: PPUSH
62548: CALL_OW 235
// hackTanksCaptured := Replace ( hackTanksCaptured , index , Delete ( hackTanksCaptured [ index ] , i ) ) ;
62552: LD_ADDR_EXP 89
62556: PUSH
62557: LD_EXP 89
62561: PPUSH
62562: LD_VAR 0 4
62566: PPUSH
62567: LD_EXP 89
62571: PUSH
62572: LD_VAR 0 4
62576: ARRAY
62577: PPUSH
62578: LD_VAR 0 3
62582: PPUSH
62583: CALL_OW 3
62587: PPUSH
62588: CALL_OW 1
62592: ST_TO_ADDR
// end ; end ;
62593: GO 62422
62595: POP
62596: POP
// SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
62597: LD_VAR 0 1
62601: PPUSH
62602: LD_EXP 89
62606: PUSH
62607: LD_VAR 0 4
62611: ARRAY
62612: PUSH
62613: LD_INT 0
62615: PLUS
62616: PPUSH
62617: CALL_OW 505
// end ;
62621: LD_VAR 0 2
62625: RET
// export function HackDestroyVehicle ( hack , vehicle ) ; var i , index , tmp ; begin
62626: LD_INT 0
62628: PPUSH
62629: PPUSH
62630: PPUSH
62631: PPUSH
// if not hack in hackTanks then
62632: LD_VAR 0 1
62636: PUSH
62637: LD_EXP 88
62641: IN
62642: NOT
62643: IFFALSE 62647
// exit ;
62645: GO 62732
// index := GetElementIndex ( hackTanks , hack ) ;
62647: LD_ADDR_VAR 0 5
62651: PUSH
62652: LD_EXP 88
62656: PPUSH
62657: LD_VAR 0 1
62661: PPUSH
62662: CALL 24148 0 2
62666: ST_TO_ADDR
// for i := 1 to hackTanksCaptured [ index ] do
62667: LD_ADDR_VAR 0 4
62671: PUSH
62672: DOUBLE
62673: LD_INT 1
62675: DEC
62676: ST_TO_ADDR
62677: LD_EXP 89
62681: PUSH
62682: LD_VAR 0 5
62686: ARRAY
62687: PUSH
62688: FOR_TO
62689: IFFALSE 62730
// if hackTanksCaptured [ index ] [ i ] [ 1 ] = vehicle then
62691: LD_EXP 89
62695: PUSH
62696: LD_VAR 0 5
62700: ARRAY
62701: PUSH
62702: LD_VAR 0 4
62706: ARRAY
62707: PUSH
62708: LD_INT 1
62710: ARRAY
62711: PUSH
62712: LD_VAR 0 2
62716: EQUAL
62717: IFFALSE 62728
// KillUnit ( vehicle ) ;
62719: LD_VAR 0 2
62723: PPUSH
62724: CALL_OW 66
62728: GO 62688
62730: POP
62731: POP
// end ;
62732: LD_VAR 0 3
62736: RET
// export initMiner , minersList , minerMinesList , minesLimitPerVehicle ; every 0 0$1 trigger not initMiner do
62737: LD_EXP 93
62741: NOT
62742: IFFALSE 62777
62744: GO 62746
62746: DISABLE
// begin initMiner := true ;
62747: LD_ADDR_EXP 93
62751: PUSH
62752: LD_INT 1
62754: ST_TO_ADDR
// minersList := [ ] ;
62755: LD_ADDR_EXP 94
62759: PUSH
62760: EMPTY
62761: ST_TO_ADDR
// minerMinesList := [ ] ;
62762: LD_ADDR_EXP 95
62766: PUSH
62767: EMPTY
62768: ST_TO_ADDR
// minesLimitPerVehicle := 5 ;
62769: LD_ADDR_EXP 96
62773: PUSH
62774: LD_INT 5
62776: ST_TO_ADDR
// end ;
62777: END
// every 0 0$1 trigger initMiner and FilterAllUnits ( [ f_weapon , ar_miner ] ) do var i , j , side , tmp ;
62778: LD_EXP 93
62782: PUSH
62783: LD_INT 34
62785: PUSH
62786: LD_EXP 165
62790: PUSH
62791: EMPTY
62792: LIST
62793: LIST
62794: PPUSH
62795: CALL_OW 69
62799: AND
62800: IFFALSE 63263
62802: GO 62804
62804: DISABLE
62805: LD_INT 0
62807: PPUSH
62808: PPUSH
62809: PPUSH
62810: PPUSH
// begin enable ;
62811: ENABLE
// for i in FilterAllUnits ( [ f_weapon , ar_miner ] ) do
62812: LD_ADDR_VAR 0 1
62816: PUSH
62817: LD_INT 34
62819: PUSH
62820: LD_EXP 165
62824: PUSH
62825: EMPTY
62826: LIST
62827: LIST
62828: PPUSH
62829: CALL_OW 69
62833: PUSH
62834: FOR_IN
62835: IFFALSE 62907
// begin if not i in minersList then
62837: LD_VAR 0 1
62841: PUSH
62842: LD_EXP 94
62846: IN
62847: NOT
62848: IFFALSE 62905
// begin minersList := Replace ( minersList , minersList + 1 , i ) ;
62850: LD_ADDR_EXP 94
62854: PUSH
62855: LD_EXP 94
62859: PPUSH
62860: LD_EXP 94
62864: PUSH
62865: LD_INT 1
62867: PLUS
62868: PPUSH
62869: LD_VAR 0 1
62873: PPUSH
62874: CALL_OW 1
62878: ST_TO_ADDR
// minerMinesList := Replace ( minerMinesList , minerMinesList + 1 , [ ] ) ;
62879: LD_ADDR_EXP 95
62883: PUSH
62884: LD_EXP 95
62888: PPUSH
62889: LD_EXP 95
62893: PUSH
62894: LD_INT 1
62896: PLUS
62897: PPUSH
62898: EMPTY
62899: PPUSH
62900: CALL_OW 1
62904: ST_TO_ADDR
// end end ;
62905: GO 62834
62907: POP
62908: POP
// for i := minerMinesList downto 1 do
62909: LD_ADDR_VAR 0 1
62913: PUSH
62914: DOUBLE
62915: LD_EXP 95
62919: INC
62920: ST_TO_ADDR
62921: LD_INT 1
62923: PUSH
62924: FOR_DOWNTO
62925: IFFALSE 63261
// begin if IsLive ( minersList [ i ] ) then
62927: LD_EXP 94
62931: PUSH
62932: LD_VAR 0 1
62936: ARRAY
62937: PPUSH
62938: CALL_OW 300
62942: IFFALSE 62970
// SetUnitDisplayNumber ( minersList [ i ] , minerMinesList [ i ] ) ;
62944: LD_EXP 94
62948: PUSH
62949: LD_VAR 0 1
62953: ARRAY
62954: PPUSH
62955: LD_EXP 95
62959: PUSH
62960: LD_VAR 0 1
62964: ARRAY
62965: PPUSH
62966: CALL_OW 505
// if not minerMinesList [ i ] then
62970: LD_EXP 95
62974: PUSH
62975: LD_VAR 0 1
62979: ARRAY
62980: NOT
62981: IFFALSE 62985
// continue ;
62983: GO 62924
// for j := minerMinesList [ i ] downto 1 do
62985: LD_ADDR_VAR 0 2
62989: PUSH
62990: DOUBLE
62991: LD_EXP 95
62995: PUSH
62996: LD_VAR 0 1
63000: ARRAY
63001: INC
63002: ST_TO_ADDR
63003: LD_INT 1
63005: PUSH
63006: FOR_DOWNTO
63007: IFFALSE 63257
// begin side := GetSide ( minersList [ i ] ) ;
63009: LD_ADDR_VAR 0 3
63013: PUSH
63014: LD_EXP 94
63018: PUSH
63019: LD_VAR 0 1
63023: ARRAY
63024: PPUSH
63025: CALL_OW 255
63029: ST_TO_ADDR
// tmp := HexInfo ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) ;
63030: LD_ADDR_VAR 0 4
63034: PUSH
63035: LD_EXP 95
63039: PUSH
63040: LD_VAR 0 1
63044: ARRAY
63045: PUSH
63046: LD_VAR 0 2
63050: ARRAY
63051: PUSH
63052: LD_INT 1
63054: ARRAY
63055: PPUSH
63056: LD_EXP 95
63060: PUSH
63061: LD_VAR 0 1
63065: ARRAY
63066: PUSH
63067: LD_VAR 0 2
63071: ARRAY
63072: PUSH
63073: LD_INT 2
63075: ARRAY
63076: PPUSH
63077: CALL_OW 428
63081: ST_TO_ADDR
// if not tmp then
63082: LD_VAR 0 4
63086: NOT
63087: IFFALSE 63091
// continue ;
63089: GO 63006
// if tmp in FilterAllUnits ( [ f_enemy , side ] ) and MineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) then
63091: LD_VAR 0 4
63095: PUSH
63096: LD_INT 81
63098: PUSH
63099: LD_VAR 0 3
63103: PUSH
63104: EMPTY
63105: LIST
63106: LIST
63107: PPUSH
63108: CALL_OW 69
63112: IN
63113: PUSH
63114: LD_EXP 95
63118: PUSH
63119: LD_VAR 0 1
63123: ARRAY
63124: PUSH
63125: LD_VAR 0 2
63129: ARRAY
63130: PUSH
63131: LD_INT 1
63133: ARRAY
63134: PPUSH
63135: LD_EXP 95
63139: PUSH
63140: LD_VAR 0 1
63144: ARRAY
63145: PUSH
63146: LD_VAR 0 2
63150: ARRAY
63151: PUSH
63152: LD_INT 2
63154: ARRAY
63155: PPUSH
63156: CALL_OW 458
63160: AND
63161: IFFALSE 63255
// begin LaunchMineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] , side ) ;
63163: LD_EXP 95
63167: PUSH
63168: LD_VAR 0 1
63172: ARRAY
63173: PUSH
63174: LD_VAR 0 2
63178: ARRAY
63179: PUSH
63180: LD_INT 1
63182: ARRAY
63183: PPUSH
63184: LD_EXP 95
63188: PUSH
63189: LD_VAR 0 1
63193: ARRAY
63194: PUSH
63195: LD_VAR 0 2
63199: ARRAY
63200: PUSH
63201: LD_INT 2
63203: ARRAY
63204: PPUSH
63205: LD_VAR 0 3
63209: PPUSH
63210: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , i , Delete ( minerMinesList [ i ] , j ) ) ;
63214: LD_ADDR_EXP 95
63218: PUSH
63219: LD_EXP 95
63223: PPUSH
63224: LD_VAR 0 1
63228: PPUSH
63229: LD_EXP 95
63233: PUSH
63234: LD_VAR 0 1
63238: ARRAY
63239: PPUSH
63240: LD_VAR 0 2
63244: PPUSH
63245: CALL_OW 3
63249: PPUSH
63250: CALL_OW 1
63254: ST_TO_ADDR
// end ; end ;
63255: GO 63006
63257: POP
63258: POP
// end ;
63259: GO 62924
63261: POP
63262: POP
// end ;
63263: PPOPN 4
63265: END
// export function MinerPlaceMine ( unit , x , y ) ; var index ; begin
63266: LD_INT 0
63268: PPUSH
63269: PPUSH
// result := false ;
63270: LD_ADDR_VAR 0 4
63274: PUSH
63275: LD_INT 0
63277: ST_TO_ADDR
// if not GetWeapon ( unit ) = ar_miner then
63278: LD_VAR 0 1
63282: PPUSH
63283: CALL_OW 264
63287: PUSH
63288: LD_EXP 165
63292: EQUAL
63293: NOT
63294: IFFALSE 63298
// exit ;
63296: GO 63538
// index := GetElementIndex ( minersList , unit ) ;
63298: LD_ADDR_VAR 0 5
63302: PUSH
63303: LD_EXP 94
63307: PPUSH
63308: LD_VAR 0 1
63312: PPUSH
63313: CALL 24148 0 2
63317: ST_TO_ADDR
// if minerMinesList [ index ] >= minesLimitPerVehicle then
63318: LD_EXP 95
63322: PUSH
63323: LD_VAR 0 5
63327: ARRAY
63328: PUSH
63329: LD_EXP 96
63333: GREATEREQUAL
63334: IFFALSE 63338
// exit ;
63336: GO 63538
// ComMoveXY ( unit , x , y ) ;
63338: LD_VAR 0 1
63342: PPUSH
63343: LD_VAR 0 2
63347: PPUSH
63348: LD_VAR 0 3
63352: PPUSH
63353: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
63357: LD_INT 35
63359: PPUSH
63360: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) and HasTask ( unit ) then
63364: LD_VAR 0 1
63368: PPUSH
63369: LD_VAR 0 2
63373: PPUSH
63374: LD_VAR 0 3
63378: PPUSH
63379: CALL 55434 0 3
63383: NOT
63384: PUSH
63385: LD_VAR 0 1
63389: PPUSH
63390: CALL_OW 314
63394: AND
63395: IFFALSE 63399
// exit ;
63397: GO 63538
// until HexInfo ( x , y ) = unit and not HasTask ( unit ) ;
63399: LD_VAR 0 2
63403: PPUSH
63404: LD_VAR 0 3
63408: PPUSH
63409: CALL_OW 428
63413: PUSH
63414: LD_VAR 0 1
63418: EQUAL
63419: PUSH
63420: LD_VAR 0 1
63424: PPUSH
63425: CALL_OW 314
63429: NOT
63430: AND
63431: IFFALSE 63357
// PlaySoundXY ( x , y , PlantMine ) ;
63433: LD_VAR 0 2
63437: PPUSH
63438: LD_VAR 0 3
63442: PPUSH
63443: LD_STRING PlantMine
63445: PPUSH
63446: CALL_OW 366
// PlaceMine ( x , y , GetSide ( unit ) , 0 ) ;
63450: LD_VAR 0 2
63454: PPUSH
63455: LD_VAR 0 3
63459: PPUSH
63460: LD_VAR 0 1
63464: PPUSH
63465: CALL_OW 255
63469: PPUSH
63470: LD_INT 0
63472: PPUSH
63473: CALL_OW 454
// minerMinesList := ReplaceIn ( minerMinesList , [ index , minerMinesList [ index ] + 1 ] , [ x , y ] ) ;
63477: LD_ADDR_EXP 95
63481: PUSH
63482: LD_EXP 95
63486: PPUSH
63487: LD_VAR 0 5
63491: PUSH
63492: LD_EXP 95
63496: PUSH
63497: LD_VAR 0 5
63501: ARRAY
63502: PUSH
63503: LD_INT 1
63505: PLUS
63506: PUSH
63507: EMPTY
63508: LIST
63509: LIST
63510: PPUSH
63511: LD_VAR 0 2
63515: PUSH
63516: LD_VAR 0 3
63520: PUSH
63521: EMPTY
63522: LIST
63523: LIST
63524: PPUSH
63525: CALL 24363 0 3
63529: ST_TO_ADDR
// result := true ;
63530: LD_ADDR_VAR 0 4
63534: PUSH
63535: LD_INT 1
63537: ST_TO_ADDR
// end ;
63538: LD_VAR 0 4
63542: RET
// export function MinerDetonateMine ( unit , x , y ) ; var i , index ; begin
63543: LD_INT 0
63545: PPUSH
63546: PPUSH
63547: PPUSH
// if not unit in minersList then
63548: LD_VAR 0 1
63552: PUSH
63553: LD_EXP 94
63557: IN
63558: NOT
63559: IFFALSE 63563
// exit ;
63561: GO 63955
// index := GetElementIndex ( minersList , unit ) ;
63563: LD_ADDR_VAR 0 6
63567: PUSH
63568: LD_EXP 94
63572: PPUSH
63573: LD_VAR 0 1
63577: PPUSH
63578: CALL 24148 0 2
63582: ST_TO_ADDR
// for i := minerMinesList [ index ] downto 1 do
63583: LD_ADDR_VAR 0 5
63587: PUSH
63588: DOUBLE
63589: LD_EXP 95
63593: PUSH
63594: LD_VAR 0 6
63598: ARRAY
63599: INC
63600: ST_TO_ADDR
63601: LD_INT 1
63603: PUSH
63604: FOR_DOWNTO
63605: IFFALSE 63766
// begin if minerMinesList [ index ] [ i ] [ 1 ] = x and minerMinesList [ index ] [ i ] [ 2 ] = y then
63607: LD_EXP 95
63611: PUSH
63612: LD_VAR 0 6
63616: ARRAY
63617: PUSH
63618: LD_VAR 0 5
63622: ARRAY
63623: PUSH
63624: LD_INT 1
63626: ARRAY
63627: PUSH
63628: LD_VAR 0 2
63632: EQUAL
63633: PUSH
63634: LD_EXP 95
63638: PUSH
63639: LD_VAR 0 6
63643: ARRAY
63644: PUSH
63645: LD_VAR 0 5
63649: ARRAY
63650: PUSH
63651: LD_INT 2
63653: ARRAY
63654: PUSH
63655: LD_VAR 0 3
63659: EQUAL
63660: AND
63661: IFFALSE 63764
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
63663: LD_EXP 95
63667: PUSH
63668: LD_VAR 0 6
63672: ARRAY
63673: PUSH
63674: LD_VAR 0 5
63678: ARRAY
63679: PUSH
63680: LD_INT 1
63682: ARRAY
63683: PPUSH
63684: LD_EXP 95
63688: PUSH
63689: LD_VAR 0 6
63693: ARRAY
63694: PUSH
63695: LD_VAR 0 5
63699: ARRAY
63700: PUSH
63701: LD_INT 2
63703: ARRAY
63704: PPUSH
63705: LD_VAR 0 1
63709: PPUSH
63710: CALL_OW 255
63714: PPUSH
63715: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
63719: LD_ADDR_EXP 95
63723: PUSH
63724: LD_EXP 95
63728: PPUSH
63729: LD_VAR 0 6
63733: PPUSH
63734: LD_EXP 95
63738: PUSH
63739: LD_VAR 0 6
63743: ARRAY
63744: PPUSH
63745: LD_VAR 0 5
63749: PPUSH
63750: CALL_OW 3
63754: PPUSH
63755: CALL_OW 1
63759: ST_TO_ADDR
// exit ;
63760: POP
63761: POP
63762: GO 63955
// end ; end ;
63764: GO 63604
63766: POP
63767: POP
// for i := minerMinesList [ index ] downto 1 do
63768: LD_ADDR_VAR 0 5
63772: PUSH
63773: DOUBLE
63774: LD_EXP 95
63778: PUSH
63779: LD_VAR 0 6
63783: ARRAY
63784: INC
63785: ST_TO_ADDR
63786: LD_INT 1
63788: PUSH
63789: FOR_DOWNTO
63790: IFFALSE 63953
// begin if GetDistXY ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , x , y ) < 6 then
63792: LD_EXP 95
63796: PUSH
63797: LD_VAR 0 6
63801: ARRAY
63802: PUSH
63803: LD_VAR 0 5
63807: ARRAY
63808: PUSH
63809: LD_INT 1
63811: ARRAY
63812: PPUSH
63813: LD_EXP 95
63817: PUSH
63818: LD_VAR 0 6
63822: ARRAY
63823: PUSH
63824: LD_VAR 0 5
63828: ARRAY
63829: PUSH
63830: LD_INT 2
63832: ARRAY
63833: PPUSH
63834: LD_VAR 0 2
63838: PPUSH
63839: LD_VAR 0 3
63843: PPUSH
63844: CALL_OW 298
63848: PUSH
63849: LD_INT 6
63851: LESS
63852: IFFALSE 63951
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
63854: LD_EXP 95
63858: PUSH
63859: LD_VAR 0 6
63863: ARRAY
63864: PUSH
63865: LD_VAR 0 5
63869: ARRAY
63870: PUSH
63871: LD_INT 1
63873: ARRAY
63874: PPUSH
63875: LD_EXP 95
63879: PUSH
63880: LD_VAR 0 6
63884: ARRAY
63885: PUSH
63886: LD_VAR 0 5
63890: ARRAY
63891: PUSH
63892: LD_INT 2
63894: ARRAY
63895: PPUSH
63896: LD_VAR 0 1
63900: PPUSH
63901: CALL_OW 255
63905: PPUSH
63906: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
63910: LD_ADDR_EXP 95
63914: PUSH
63915: LD_EXP 95
63919: PPUSH
63920: LD_VAR 0 6
63924: PPUSH
63925: LD_EXP 95
63929: PUSH
63930: LD_VAR 0 6
63934: ARRAY
63935: PPUSH
63936: LD_VAR 0 5
63940: PPUSH
63941: CALL_OW 3
63945: PPUSH
63946: CALL_OW 1
63950: ST_TO_ADDR
// end ; end ;
63951: GO 63789
63953: POP
63954: POP
// end ;
63955: LD_VAR 0 4
63959: RET
// export function MinerCreateMinefield ( unit , x , y ) ; var i , index , tmp , minesFreeAmount , _x , _y , _d , _r ; begin
63960: LD_INT 0
63962: PPUSH
63963: PPUSH
63964: PPUSH
63965: PPUSH
63966: PPUSH
63967: PPUSH
63968: PPUSH
63969: PPUSH
63970: PPUSH
// if not GetWeapon ( unit ) = ar_miner or not unit in minersList then
63971: LD_VAR 0 1
63975: PPUSH
63976: CALL_OW 264
63980: PUSH
63981: LD_EXP 165
63985: EQUAL
63986: NOT
63987: PUSH
63988: LD_VAR 0 1
63992: PUSH
63993: LD_EXP 94
63997: IN
63998: NOT
63999: OR
64000: IFFALSE 64004
// exit ;
64002: GO 64326
// index := GetElementIndex ( minersList , unit ) ;
64004: LD_ADDR_VAR 0 6
64008: PUSH
64009: LD_EXP 94
64013: PPUSH
64014: LD_VAR 0 1
64018: PPUSH
64019: CALL 24148 0 2
64023: ST_TO_ADDR
// minesFreeAmount := minesLimitPerVehicle - minerMinesList [ index ] ;
64024: LD_ADDR_VAR 0 8
64028: PUSH
64029: LD_EXP 96
64033: PUSH
64034: LD_EXP 95
64038: PUSH
64039: LD_VAR 0 6
64043: ARRAY
64044: MINUS
64045: ST_TO_ADDR
// if not minesFreeAmount then
64046: LD_VAR 0 8
64050: NOT
64051: IFFALSE 64055
// exit ;
64053: GO 64326
// tmp := [ ] ;
64055: LD_ADDR_VAR 0 7
64059: PUSH
64060: EMPTY
64061: ST_TO_ADDR
// for i := 1 to minesFreeAmount do
64062: LD_ADDR_VAR 0 5
64066: PUSH
64067: DOUBLE
64068: LD_INT 1
64070: DEC
64071: ST_TO_ADDR
64072: LD_VAR 0 8
64076: PUSH
64077: FOR_TO
64078: IFFALSE 64273
// begin _d := rand ( 0 , 5 ) ;
64080: LD_ADDR_VAR 0 11
64084: PUSH
64085: LD_INT 0
64087: PPUSH
64088: LD_INT 5
64090: PPUSH
64091: CALL_OW 12
64095: ST_TO_ADDR
// _r := rand ( 2 , 6 ) ;
64096: LD_ADDR_VAR 0 12
64100: PUSH
64101: LD_INT 2
64103: PPUSH
64104: LD_INT 6
64106: PPUSH
64107: CALL_OW 12
64111: ST_TO_ADDR
// _x := ShiftX ( x , _d , _r ) ;
64112: LD_ADDR_VAR 0 9
64116: PUSH
64117: LD_VAR 0 2
64121: PPUSH
64122: LD_VAR 0 11
64126: PPUSH
64127: LD_VAR 0 12
64131: PPUSH
64132: CALL_OW 272
64136: ST_TO_ADDR
// _y := ShiftY ( y , _d , _r ) ;
64137: LD_ADDR_VAR 0 10
64141: PUSH
64142: LD_VAR 0 3
64146: PPUSH
64147: LD_VAR 0 11
64151: PPUSH
64152: LD_VAR 0 12
64156: PPUSH
64157: CALL_OW 273
64161: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not [ _x , _y ] in tmp and not MineAtPos ( _x , _y ) then
64162: LD_VAR 0 9
64166: PPUSH
64167: LD_VAR 0 10
64171: PPUSH
64172: CALL_OW 488
64176: PUSH
64177: LD_VAR 0 9
64181: PUSH
64182: LD_VAR 0 10
64186: PUSH
64187: EMPTY
64188: LIST
64189: LIST
64190: PUSH
64191: LD_VAR 0 7
64195: IN
64196: NOT
64197: AND
64198: PUSH
64199: LD_VAR 0 9
64203: PPUSH
64204: LD_VAR 0 10
64208: PPUSH
64209: CALL_OW 458
64213: NOT
64214: AND
64215: IFFALSE 64257
// tmp := Replace ( tmp , tmp + 1 , [ _x , _y ] ) else
64217: LD_ADDR_VAR 0 7
64221: PUSH
64222: LD_VAR 0 7
64226: PPUSH
64227: LD_VAR 0 7
64231: PUSH
64232: LD_INT 1
64234: PLUS
64235: PPUSH
64236: LD_VAR 0 9
64240: PUSH
64241: LD_VAR 0 10
64245: PUSH
64246: EMPTY
64247: LIST
64248: LIST
64249: PPUSH
64250: CALL_OW 1
64254: ST_TO_ADDR
64255: GO 64271
// i := i - 1 ;
64257: LD_ADDR_VAR 0 5
64261: PUSH
64262: LD_VAR 0 5
64266: PUSH
64267: LD_INT 1
64269: MINUS
64270: ST_TO_ADDR
// end ;
64271: GO 64077
64273: POP
64274: POP
// for i in tmp do
64275: LD_ADDR_VAR 0 5
64279: PUSH
64280: LD_VAR 0 7
64284: PUSH
64285: FOR_IN
64286: IFFALSE 64324
// if not MinerPlaceMine ( unit , i [ 1 ] , i [ 2 ] ) then
64288: LD_VAR 0 1
64292: PPUSH
64293: LD_VAR 0 5
64297: PUSH
64298: LD_INT 1
64300: ARRAY
64301: PPUSH
64302: LD_VAR 0 5
64306: PUSH
64307: LD_INT 2
64309: ARRAY
64310: PPUSH
64311: CALL 63266 0 3
64315: NOT
64316: IFFALSE 64322
// exit ;
64318: POP
64319: POP
64320: GO 64326
64322: GO 64285
64324: POP
64325: POP
// end ;
64326: LD_VAR 0 4
64330: RET
// export function ComBinocular ( unit , x , y ) ; var dist , side , viewRange , _x , _y , _d ; begin
64331: LD_INT 0
64333: PPUSH
64334: PPUSH
64335: PPUSH
64336: PPUSH
64337: PPUSH
64338: PPUSH
64339: PPUSH
// if not GetClass ( unit ) = class_sniper then
64340: LD_VAR 0 1
64344: PPUSH
64345: CALL_OW 257
64349: PUSH
64350: LD_INT 5
64352: EQUAL
64353: NOT
64354: IFFALSE 64358
// exit ;
64356: GO 64746
// dist := 8 ;
64358: LD_ADDR_VAR 0 5
64362: PUSH
64363: LD_INT 8
64365: ST_TO_ADDR
// viewRange := 12 ;
64366: LD_ADDR_VAR 0 7
64370: PUSH
64371: LD_INT 12
64373: ST_TO_ADDR
// side := GetSide ( unit ) ;
64374: LD_ADDR_VAR 0 6
64378: PUSH
64379: LD_VAR 0 1
64383: PPUSH
64384: CALL_OW 255
64388: ST_TO_ADDR
// if GetTech ( tech_opto2 , side ) = state_researched then
64389: LD_INT 61
64391: PPUSH
64392: LD_VAR 0 6
64396: PPUSH
64397: CALL_OW 321
64401: PUSH
64402: LD_INT 2
64404: EQUAL
64405: IFFALSE 64415
// viewRange := 16 ;
64407: LD_ADDR_VAR 0 7
64411: PUSH
64412: LD_INT 16
64414: ST_TO_ADDR
// if GetDistUnitXY ( unit , x , y ) > dist then
64415: LD_VAR 0 1
64419: PPUSH
64420: LD_VAR 0 2
64424: PPUSH
64425: LD_VAR 0 3
64429: PPUSH
64430: CALL_OW 297
64434: PUSH
64435: LD_VAR 0 5
64439: GREATER
64440: IFFALSE 64519
// begin ComMoveXY ( unit , x , y ) ;
64442: LD_VAR 0 1
64446: PPUSH
64447: LD_VAR 0 2
64451: PPUSH
64452: LD_VAR 0 3
64456: PPUSH
64457: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
64461: LD_INT 35
64463: PPUSH
64464: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) then
64468: LD_VAR 0 1
64472: PPUSH
64473: LD_VAR 0 2
64477: PPUSH
64478: LD_VAR 0 3
64482: PPUSH
64483: CALL 55434 0 3
64487: NOT
64488: IFFALSE 64492
// exit ;
64490: GO 64746
// until GetDistUnitXY ( unit , x , y ) < dist ;
64492: LD_VAR 0 1
64496: PPUSH
64497: LD_VAR 0 2
64501: PPUSH
64502: LD_VAR 0 3
64506: PPUSH
64507: CALL_OW 297
64511: PUSH
64512: LD_VAR 0 5
64516: LESS
64517: IFFALSE 64461
// end ; ComTurnXY ( unit , x , y ) ;
64519: LD_VAR 0 1
64523: PPUSH
64524: LD_VAR 0 2
64528: PPUSH
64529: LD_VAR 0 3
64533: PPUSH
64534: CALL_OW 118
// wait ( 5 ) ;
64538: LD_INT 5
64540: PPUSH
64541: CALL_OW 67
// _d := GetDir ( unit ) ;
64545: LD_ADDR_VAR 0 10
64549: PUSH
64550: LD_VAR 0 1
64554: PPUSH
64555: CALL_OW 254
64559: ST_TO_ADDR
// _x := ShiftX ( GetX ( unit ) , _d , dist ) ;
64560: LD_ADDR_VAR 0 8
64564: PUSH
64565: LD_VAR 0 1
64569: PPUSH
64570: CALL_OW 250
64574: PPUSH
64575: LD_VAR 0 10
64579: PPUSH
64580: LD_VAR 0 5
64584: PPUSH
64585: CALL_OW 272
64589: ST_TO_ADDR
// _y := ShiftY ( GetY ( unit ) , _d , dist ) ;
64590: LD_ADDR_VAR 0 9
64594: PUSH
64595: LD_VAR 0 1
64599: PPUSH
64600: CALL_OW 251
64604: PPUSH
64605: LD_VAR 0 10
64609: PPUSH
64610: LD_VAR 0 5
64614: PPUSH
64615: CALL_OW 273
64619: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
64620: LD_VAR 0 8
64624: PPUSH
64625: LD_VAR 0 9
64629: PPUSH
64630: CALL_OW 488
64634: NOT
64635: IFFALSE 64639
// exit ;
64637: GO 64746
// ComAnimCustom ( unit , 1 ) ;
64639: LD_VAR 0 1
64643: PPUSH
64644: LD_INT 1
64646: PPUSH
64647: CALL_OW 592
// PlaceSeeing ( _x , _y , side , viewRange ) ;
64651: LD_VAR 0 8
64655: PPUSH
64656: LD_VAR 0 9
64660: PPUSH
64661: LD_VAR 0 6
64665: PPUSH
64666: LD_VAR 0 7
64670: PPUSH
64671: CALL_OW 330
// repeat wait ( 1 ) ;
64675: LD_INT 1
64677: PPUSH
64678: CALL_OW 67
// until IsIdle ( unit ) or HasTask ( unit ) or not IsOk ( unit ) or IsDead ( unit ) ;
64682: LD_VAR 0 1
64686: PPUSH
64687: CALL_OW 316
64691: PUSH
64692: LD_VAR 0 1
64696: PPUSH
64697: CALL_OW 314
64701: OR
64702: PUSH
64703: LD_VAR 0 1
64707: PPUSH
64708: CALL_OW 302
64712: NOT
64713: OR
64714: PUSH
64715: LD_VAR 0 1
64719: PPUSH
64720: CALL_OW 301
64724: OR
64725: IFFALSE 64675
// RemoveSeeing ( _x , _y , side ) ;
64727: LD_VAR 0 8
64731: PPUSH
64732: LD_VAR 0 9
64736: PPUSH
64737: LD_VAR 0 6
64741: PPUSH
64742: CALL_OW 331
// end ; end_of_file
64746: LD_VAR 0 4
64750: RET
// every 0 0$1 do
64751: GO 64753
64753: DISABLE
// begin enable ;
64754: ENABLE
// ToLua ( updateTimer( & tick & ); ) ;
64755: LD_STRING updateTimer(
64757: PUSH
64758: LD_OWVAR 1
64762: STR
64763: PUSH
64764: LD_STRING );
64766: STR
64767: PPUSH
64768: CALL_OW 559
// end ;
64772: END
// export function SOS_MapStart ( ) ; begin
64773: LD_INT 0
64775: PPUSH
// if streamModeActive then
64776: LD_EXP 97
64780: IFFALSE 64789
// DefineStreamItems ( true ) ;
64782: LD_INT 1
64784: PPUSH
64785: CALL 66443 0 1
// UpdateFactoryWaypoints ( ) ;
64789: CALL 79304 0 0
// UpdateWarehouseGatheringPoints ( ) ;
64793: CALL 79561 0 0
// end ;
64797: LD_VAR 0 1
64801: RET
// export function SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
64802: LD_INT 0
64804: PPUSH
// if p2 = 100 then
64805: LD_VAR 0 2
64809: PUSH
64810: LD_INT 100
64812: EQUAL
64813: IFFALSE 65816
// begin if not StreamModeActive then
64815: LD_EXP 97
64819: NOT
64820: IFFALSE 64830
// StreamModeActive := true ;
64822: LD_ADDR_EXP 97
64826: PUSH
64827: LD_INT 1
64829: ST_TO_ADDR
// if p3 = 0 then
64830: LD_VAR 0 3
64834: PUSH
64835: LD_INT 0
64837: EQUAL
64838: IFFALSE 64844
// InitStreamMode ;
64840: CALL 65979 0 0
// if p3 = 1 then
64844: LD_VAR 0 3
64848: PUSH
64849: LD_INT 1
64851: EQUAL
64852: IFFALSE 64862
// sRocket := true ;
64854: LD_ADDR_EXP 102
64858: PUSH
64859: LD_INT 1
64861: ST_TO_ADDR
// if p3 = 2 then
64862: LD_VAR 0 3
64866: PUSH
64867: LD_INT 2
64869: EQUAL
64870: IFFALSE 64880
// sSpeed := true ;
64872: LD_ADDR_EXP 101
64876: PUSH
64877: LD_INT 1
64879: ST_TO_ADDR
// if p3 = 3 then
64880: LD_VAR 0 3
64884: PUSH
64885: LD_INT 3
64887: EQUAL
64888: IFFALSE 64898
// sEngine := true ;
64890: LD_ADDR_EXP 103
64894: PUSH
64895: LD_INT 1
64897: ST_TO_ADDR
// if p3 = 4 then
64898: LD_VAR 0 3
64902: PUSH
64903: LD_INT 4
64905: EQUAL
64906: IFFALSE 64916
// sSpec := true ;
64908: LD_ADDR_EXP 100
64912: PUSH
64913: LD_INT 1
64915: ST_TO_ADDR
// if p3 = 5 then
64916: LD_VAR 0 3
64920: PUSH
64921: LD_INT 5
64923: EQUAL
64924: IFFALSE 64934
// sLevel := true ;
64926: LD_ADDR_EXP 104
64930: PUSH
64931: LD_INT 1
64933: ST_TO_ADDR
// if p3 = 6 then
64934: LD_VAR 0 3
64938: PUSH
64939: LD_INT 6
64941: EQUAL
64942: IFFALSE 64952
// sArmoury := true ;
64944: LD_ADDR_EXP 105
64948: PUSH
64949: LD_INT 1
64951: ST_TO_ADDR
// if p3 = 7 then
64952: LD_VAR 0 3
64956: PUSH
64957: LD_INT 7
64959: EQUAL
64960: IFFALSE 64970
// sRadar := true ;
64962: LD_ADDR_EXP 106
64966: PUSH
64967: LD_INT 1
64969: ST_TO_ADDR
// if p3 = 8 then
64970: LD_VAR 0 3
64974: PUSH
64975: LD_INT 8
64977: EQUAL
64978: IFFALSE 64988
// sBunker := true ;
64980: LD_ADDR_EXP 107
64984: PUSH
64985: LD_INT 1
64987: ST_TO_ADDR
// if p3 = 9 then
64988: LD_VAR 0 3
64992: PUSH
64993: LD_INT 9
64995: EQUAL
64996: IFFALSE 65006
// sHack := true ;
64998: LD_ADDR_EXP 108
65002: PUSH
65003: LD_INT 1
65005: ST_TO_ADDR
// if p3 = 10 then
65006: LD_VAR 0 3
65010: PUSH
65011: LD_INT 10
65013: EQUAL
65014: IFFALSE 65024
// sFire := true ;
65016: LD_ADDR_EXP 109
65020: PUSH
65021: LD_INT 1
65023: ST_TO_ADDR
// if p3 = 11 then
65024: LD_VAR 0 3
65028: PUSH
65029: LD_INT 11
65031: EQUAL
65032: IFFALSE 65042
// sRefresh := true ;
65034: LD_ADDR_EXP 110
65038: PUSH
65039: LD_INT 1
65041: ST_TO_ADDR
// if p3 = 12 then
65042: LD_VAR 0 3
65046: PUSH
65047: LD_INT 12
65049: EQUAL
65050: IFFALSE 65060
// sExp := true ;
65052: LD_ADDR_EXP 111
65056: PUSH
65057: LD_INT 1
65059: ST_TO_ADDR
// if p3 = 13 then
65060: LD_VAR 0 3
65064: PUSH
65065: LD_INT 13
65067: EQUAL
65068: IFFALSE 65078
// sDepot := true ;
65070: LD_ADDR_EXP 112
65074: PUSH
65075: LD_INT 1
65077: ST_TO_ADDR
// if p3 = 14 then
65078: LD_VAR 0 3
65082: PUSH
65083: LD_INT 14
65085: EQUAL
65086: IFFALSE 65096
// sFlag := true ;
65088: LD_ADDR_EXP 113
65092: PUSH
65093: LD_INT 1
65095: ST_TO_ADDR
// if p3 = 15 then
65096: LD_VAR 0 3
65100: PUSH
65101: LD_INT 15
65103: EQUAL
65104: IFFALSE 65114
// sKamikadze := true ;
65106: LD_ADDR_EXP 121
65110: PUSH
65111: LD_INT 1
65113: ST_TO_ADDR
// if p3 = 16 then
65114: LD_VAR 0 3
65118: PUSH
65119: LD_INT 16
65121: EQUAL
65122: IFFALSE 65132
// sTroll := true ;
65124: LD_ADDR_EXP 122
65128: PUSH
65129: LD_INT 1
65131: ST_TO_ADDR
// if p3 = 17 then
65132: LD_VAR 0 3
65136: PUSH
65137: LD_INT 17
65139: EQUAL
65140: IFFALSE 65150
// sSlow := true ;
65142: LD_ADDR_EXP 123
65146: PUSH
65147: LD_INT 1
65149: ST_TO_ADDR
// if p3 = 18 then
65150: LD_VAR 0 3
65154: PUSH
65155: LD_INT 18
65157: EQUAL
65158: IFFALSE 65168
// sLack := true ;
65160: LD_ADDR_EXP 124
65164: PUSH
65165: LD_INT 1
65167: ST_TO_ADDR
// if p3 = 19 then
65168: LD_VAR 0 3
65172: PUSH
65173: LD_INT 19
65175: EQUAL
65176: IFFALSE 65186
// sTank := true ;
65178: LD_ADDR_EXP 126
65182: PUSH
65183: LD_INT 1
65185: ST_TO_ADDR
// if p3 = 20 then
65186: LD_VAR 0 3
65190: PUSH
65191: LD_INT 20
65193: EQUAL
65194: IFFALSE 65204
// sRemote := true ;
65196: LD_ADDR_EXP 127
65200: PUSH
65201: LD_INT 1
65203: ST_TO_ADDR
// if p3 = 21 then
65204: LD_VAR 0 3
65208: PUSH
65209: LD_INT 21
65211: EQUAL
65212: IFFALSE 65222
// sPowell := true ;
65214: LD_ADDR_EXP 128
65218: PUSH
65219: LD_INT 1
65221: ST_TO_ADDR
// if p3 = 22 then
65222: LD_VAR 0 3
65226: PUSH
65227: LD_INT 22
65229: EQUAL
65230: IFFALSE 65240
// sTeleport := true ;
65232: LD_ADDR_EXP 131
65236: PUSH
65237: LD_INT 1
65239: ST_TO_ADDR
// if p3 = 23 then
65240: LD_VAR 0 3
65244: PUSH
65245: LD_INT 23
65247: EQUAL
65248: IFFALSE 65258
// sOilTower := true ;
65250: LD_ADDR_EXP 133
65254: PUSH
65255: LD_INT 1
65257: ST_TO_ADDR
// if p3 = 24 then
65258: LD_VAR 0 3
65262: PUSH
65263: LD_INT 24
65265: EQUAL
65266: IFFALSE 65276
// sShovel := true ;
65268: LD_ADDR_EXP 134
65272: PUSH
65273: LD_INT 1
65275: ST_TO_ADDR
// if p3 = 25 then
65276: LD_VAR 0 3
65280: PUSH
65281: LD_INT 25
65283: EQUAL
65284: IFFALSE 65294
// sSheik := true ;
65286: LD_ADDR_EXP 135
65290: PUSH
65291: LD_INT 1
65293: ST_TO_ADDR
// if p3 = 26 then
65294: LD_VAR 0 3
65298: PUSH
65299: LD_INT 26
65301: EQUAL
65302: IFFALSE 65312
// sEarthquake := true ;
65304: LD_ADDR_EXP 137
65308: PUSH
65309: LD_INT 1
65311: ST_TO_ADDR
// if p3 = 27 then
65312: LD_VAR 0 3
65316: PUSH
65317: LD_INT 27
65319: EQUAL
65320: IFFALSE 65330
// sAI := true ;
65322: LD_ADDR_EXP 138
65326: PUSH
65327: LD_INT 1
65329: ST_TO_ADDR
// if p3 = 28 then
65330: LD_VAR 0 3
65334: PUSH
65335: LD_INT 28
65337: EQUAL
65338: IFFALSE 65348
// sCargo := true ;
65340: LD_ADDR_EXP 141
65344: PUSH
65345: LD_INT 1
65347: ST_TO_ADDR
// if p3 = 29 then
65348: LD_VAR 0 3
65352: PUSH
65353: LD_INT 29
65355: EQUAL
65356: IFFALSE 65366
// sDLaser := true ;
65358: LD_ADDR_EXP 142
65362: PUSH
65363: LD_INT 1
65365: ST_TO_ADDR
// if p3 = 30 then
65366: LD_VAR 0 3
65370: PUSH
65371: LD_INT 30
65373: EQUAL
65374: IFFALSE 65384
// sExchange := true ;
65376: LD_ADDR_EXP 143
65380: PUSH
65381: LD_INT 1
65383: ST_TO_ADDR
// if p3 = 31 then
65384: LD_VAR 0 3
65388: PUSH
65389: LD_INT 31
65391: EQUAL
65392: IFFALSE 65402
// sFac := true ;
65394: LD_ADDR_EXP 144
65398: PUSH
65399: LD_INT 1
65401: ST_TO_ADDR
// if p3 = 32 then
65402: LD_VAR 0 3
65406: PUSH
65407: LD_INT 32
65409: EQUAL
65410: IFFALSE 65420
// sPower := true ;
65412: LD_ADDR_EXP 145
65416: PUSH
65417: LD_INT 1
65419: ST_TO_ADDR
// if p3 = 33 then
65420: LD_VAR 0 3
65424: PUSH
65425: LD_INT 33
65427: EQUAL
65428: IFFALSE 65438
// sRandom := true ;
65430: LD_ADDR_EXP 146
65434: PUSH
65435: LD_INT 1
65437: ST_TO_ADDR
// if p3 = 34 then
65438: LD_VAR 0 3
65442: PUSH
65443: LD_INT 34
65445: EQUAL
65446: IFFALSE 65456
// sShield := true ;
65448: LD_ADDR_EXP 147
65452: PUSH
65453: LD_INT 1
65455: ST_TO_ADDR
// if p3 = 35 then
65456: LD_VAR 0 3
65460: PUSH
65461: LD_INT 35
65463: EQUAL
65464: IFFALSE 65474
// sTime := true ;
65466: LD_ADDR_EXP 148
65470: PUSH
65471: LD_INT 1
65473: ST_TO_ADDR
// if p3 = 36 then
65474: LD_VAR 0 3
65478: PUSH
65479: LD_INT 36
65481: EQUAL
65482: IFFALSE 65492
// sTools := true ;
65484: LD_ADDR_EXP 149
65488: PUSH
65489: LD_INT 1
65491: ST_TO_ADDR
// if p3 = 101 then
65492: LD_VAR 0 3
65496: PUSH
65497: LD_INT 101
65499: EQUAL
65500: IFFALSE 65510
// sSold := true ;
65502: LD_ADDR_EXP 114
65506: PUSH
65507: LD_INT 1
65509: ST_TO_ADDR
// if p3 = 102 then
65510: LD_VAR 0 3
65514: PUSH
65515: LD_INT 102
65517: EQUAL
65518: IFFALSE 65528
// sDiff := true ;
65520: LD_ADDR_EXP 115
65524: PUSH
65525: LD_INT 1
65527: ST_TO_ADDR
// if p3 = 103 then
65528: LD_VAR 0 3
65532: PUSH
65533: LD_INT 103
65535: EQUAL
65536: IFFALSE 65546
// sFog := true ;
65538: LD_ADDR_EXP 118
65542: PUSH
65543: LD_INT 1
65545: ST_TO_ADDR
// if p3 = 104 then
65546: LD_VAR 0 3
65550: PUSH
65551: LD_INT 104
65553: EQUAL
65554: IFFALSE 65564
// sReset := true ;
65556: LD_ADDR_EXP 119
65560: PUSH
65561: LD_INT 1
65563: ST_TO_ADDR
// if p3 = 105 then
65564: LD_VAR 0 3
65568: PUSH
65569: LD_INT 105
65571: EQUAL
65572: IFFALSE 65582
// sSun := true ;
65574: LD_ADDR_EXP 120
65578: PUSH
65579: LD_INT 1
65581: ST_TO_ADDR
// if p3 = 106 then
65582: LD_VAR 0 3
65586: PUSH
65587: LD_INT 106
65589: EQUAL
65590: IFFALSE 65600
// sTiger := true ;
65592: LD_ADDR_EXP 116
65596: PUSH
65597: LD_INT 1
65599: ST_TO_ADDR
// if p3 = 107 then
65600: LD_VAR 0 3
65604: PUSH
65605: LD_INT 107
65607: EQUAL
65608: IFFALSE 65618
// sBomb := true ;
65610: LD_ADDR_EXP 117
65614: PUSH
65615: LD_INT 1
65617: ST_TO_ADDR
// if p3 = 108 then
65618: LD_VAR 0 3
65622: PUSH
65623: LD_INT 108
65625: EQUAL
65626: IFFALSE 65636
// sWound := true ;
65628: LD_ADDR_EXP 125
65632: PUSH
65633: LD_INT 1
65635: ST_TO_ADDR
// if p3 = 109 then
65636: LD_VAR 0 3
65640: PUSH
65641: LD_INT 109
65643: EQUAL
65644: IFFALSE 65654
// sBetray := true ;
65646: LD_ADDR_EXP 129
65650: PUSH
65651: LD_INT 1
65653: ST_TO_ADDR
// if p3 = 110 then
65654: LD_VAR 0 3
65658: PUSH
65659: LD_INT 110
65661: EQUAL
65662: IFFALSE 65672
// sContamin := true ;
65664: LD_ADDR_EXP 130
65668: PUSH
65669: LD_INT 1
65671: ST_TO_ADDR
// if p3 = 111 then
65672: LD_VAR 0 3
65676: PUSH
65677: LD_INT 111
65679: EQUAL
65680: IFFALSE 65690
// sOil := true ;
65682: LD_ADDR_EXP 132
65686: PUSH
65687: LD_INT 1
65689: ST_TO_ADDR
// if p3 = 112 then
65690: LD_VAR 0 3
65694: PUSH
65695: LD_INT 112
65697: EQUAL
65698: IFFALSE 65708
// sStu := true ;
65700: LD_ADDR_EXP 136
65704: PUSH
65705: LD_INT 1
65707: ST_TO_ADDR
// if p3 = 113 then
65708: LD_VAR 0 3
65712: PUSH
65713: LD_INT 113
65715: EQUAL
65716: IFFALSE 65726
// sBazooka := true ;
65718: LD_ADDR_EXP 139
65722: PUSH
65723: LD_INT 1
65725: ST_TO_ADDR
// if p3 = 114 then
65726: LD_VAR 0 3
65730: PUSH
65731: LD_INT 114
65733: EQUAL
65734: IFFALSE 65744
// sMortar := true ;
65736: LD_ADDR_EXP 140
65740: PUSH
65741: LD_INT 1
65743: ST_TO_ADDR
// if p3 = 115 then
65744: LD_VAR 0 3
65748: PUSH
65749: LD_INT 115
65751: EQUAL
65752: IFFALSE 65762
// sRanger := true ;
65754: LD_ADDR_EXP 150
65758: PUSH
65759: LD_INT 1
65761: ST_TO_ADDR
// if p3 = 116 then
65762: LD_VAR 0 3
65766: PUSH
65767: LD_INT 116
65769: EQUAL
65770: IFFALSE 65780
// sComputer := true ;
65772: LD_ADDR_EXP 151
65776: PUSH
65777: LD_INT 1
65779: ST_TO_ADDR
// if p3 = 117 then
65780: LD_VAR 0 3
65784: PUSH
65785: LD_INT 117
65787: EQUAL
65788: IFFALSE 65798
// s30 := true ;
65790: LD_ADDR_EXP 152
65794: PUSH
65795: LD_INT 1
65797: ST_TO_ADDR
// if p3 = 118 then
65798: LD_VAR 0 3
65802: PUSH
65803: LD_INT 118
65805: EQUAL
65806: IFFALSE 65816
// s60 := true ;
65808: LD_ADDR_EXP 153
65812: PUSH
65813: LD_INT 1
65815: ST_TO_ADDR
// end ; if p2 = 101 then
65816: LD_VAR 0 2
65820: PUSH
65821: LD_INT 101
65823: EQUAL
65824: IFFALSE 65952
// begin case p3 of 1 :
65826: LD_VAR 0 3
65830: PUSH
65831: LD_INT 1
65833: DOUBLE
65834: EQUAL
65835: IFTRUE 65839
65837: GO 65846
65839: POP
// hHackUnlimitedResources ; 2 :
65840: CALL 78050 0 0
65844: GO 65952
65846: LD_INT 2
65848: DOUBLE
65849: EQUAL
65850: IFTRUE 65854
65852: GO 65861
65854: POP
// hHackSetLevel10 ; 3 :
65855: CALL 78183 0 0
65859: GO 65952
65861: LD_INT 3
65863: DOUBLE
65864: EQUAL
65865: IFTRUE 65869
65867: GO 65876
65869: POP
// hHackSetLevel10YourUnits ; 4 :
65870: CALL 78268 0 0
65874: GO 65952
65876: LD_INT 4
65878: DOUBLE
65879: EQUAL
65880: IFTRUE 65884
65882: GO 65891
65884: POP
// hHackInvincible ; 5 :
65885: CALL 78716 0 0
65889: GO 65952
65891: LD_INT 5
65893: DOUBLE
65894: EQUAL
65895: IFTRUE 65899
65897: GO 65906
65899: POP
// hHackInvisible ; 6 :
65900: CALL 78827 0 0
65904: GO 65952
65906: LD_INT 6
65908: DOUBLE
65909: EQUAL
65910: IFTRUE 65914
65912: GO 65921
65914: POP
// hHackChangeYourSide ; 7 :
65915: CALL 78884 0 0
65919: GO 65952
65921: LD_INT 7
65923: DOUBLE
65924: EQUAL
65925: IFTRUE 65929
65927: GO 65936
65929: POP
// hHackChangeUnitSide ; 8 :
65930: CALL 78926 0 0
65934: GO 65952
65936: LD_INT 8
65938: DOUBLE
65939: EQUAL
65940: IFTRUE 65944
65942: GO 65951
65944: POP
// hHackFog ; end ;
65945: CALL 79027 0 0
65949: GO 65952
65951: POP
// end ; end ;
65952: LD_VAR 0 7
65956: RET
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger , sComputer , s30 , s60 ; every 0 0$1 do
65957: GO 65959
65959: DISABLE
// begin ToLua ( initStreamRollete(); ) ;
65960: LD_STRING initStreamRollete();
65962: PPUSH
65963: CALL_OW 559
// InitStreamMode ;
65967: CALL 65979 0 0
// DefineStreamItems ( false ) ;
65971: LD_INT 0
65973: PPUSH
65974: CALL 66443 0 1
// end ;
65978: END
// function InitStreamMode ; begin
65979: LD_INT 0
65981: PPUSH
// streamModeActive := false ;
65982: LD_ADDR_EXP 97
65986: PUSH
65987: LD_INT 0
65989: ST_TO_ADDR
// normalCounter := 36 ;
65990: LD_ADDR_EXP 98
65994: PUSH
65995: LD_INT 36
65997: ST_TO_ADDR
// hardcoreCounter := 18 ;
65998: LD_ADDR_EXP 99
66002: PUSH
66003: LD_INT 18
66005: ST_TO_ADDR
// sRocket := false ;
66006: LD_ADDR_EXP 102
66010: PUSH
66011: LD_INT 0
66013: ST_TO_ADDR
// sSpeed := false ;
66014: LD_ADDR_EXP 101
66018: PUSH
66019: LD_INT 0
66021: ST_TO_ADDR
// sEngine := false ;
66022: LD_ADDR_EXP 103
66026: PUSH
66027: LD_INT 0
66029: ST_TO_ADDR
// sSpec := false ;
66030: LD_ADDR_EXP 100
66034: PUSH
66035: LD_INT 0
66037: ST_TO_ADDR
// sLevel := false ;
66038: LD_ADDR_EXP 104
66042: PUSH
66043: LD_INT 0
66045: ST_TO_ADDR
// sArmoury := false ;
66046: LD_ADDR_EXP 105
66050: PUSH
66051: LD_INT 0
66053: ST_TO_ADDR
// sRadar := false ;
66054: LD_ADDR_EXP 106
66058: PUSH
66059: LD_INT 0
66061: ST_TO_ADDR
// sBunker := false ;
66062: LD_ADDR_EXP 107
66066: PUSH
66067: LD_INT 0
66069: ST_TO_ADDR
// sHack := false ;
66070: LD_ADDR_EXP 108
66074: PUSH
66075: LD_INT 0
66077: ST_TO_ADDR
// sFire := false ;
66078: LD_ADDR_EXP 109
66082: PUSH
66083: LD_INT 0
66085: ST_TO_ADDR
// sRefresh := false ;
66086: LD_ADDR_EXP 110
66090: PUSH
66091: LD_INT 0
66093: ST_TO_ADDR
// sExp := false ;
66094: LD_ADDR_EXP 111
66098: PUSH
66099: LD_INT 0
66101: ST_TO_ADDR
// sDepot := false ;
66102: LD_ADDR_EXP 112
66106: PUSH
66107: LD_INT 0
66109: ST_TO_ADDR
// sFlag := false ;
66110: LD_ADDR_EXP 113
66114: PUSH
66115: LD_INT 0
66117: ST_TO_ADDR
// sKamikadze := false ;
66118: LD_ADDR_EXP 121
66122: PUSH
66123: LD_INT 0
66125: ST_TO_ADDR
// sTroll := false ;
66126: LD_ADDR_EXP 122
66130: PUSH
66131: LD_INT 0
66133: ST_TO_ADDR
// sSlow := false ;
66134: LD_ADDR_EXP 123
66138: PUSH
66139: LD_INT 0
66141: ST_TO_ADDR
// sLack := false ;
66142: LD_ADDR_EXP 124
66146: PUSH
66147: LD_INT 0
66149: ST_TO_ADDR
// sTank := false ;
66150: LD_ADDR_EXP 126
66154: PUSH
66155: LD_INT 0
66157: ST_TO_ADDR
// sRemote := false ;
66158: LD_ADDR_EXP 127
66162: PUSH
66163: LD_INT 0
66165: ST_TO_ADDR
// sPowell := false ;
66166: LD_ADDR_EXP 128
66170: PUSH
66171: LD_INT 0
66173: ST_TO_ADDR
// sTeleport := false ;
66174: LD_ADDR_EXP 131
66178: PUSH
66179: LD_INT 0
66181: ST_TO_ADDR
// sOilTower := false ;
66182: LD_ADDR_EXP 133
66186: PUSH
66187: LD_INT 0
66189: ST_TO_ADDR
// sShovel := false ;
66190: LD_ADDR_EXP 134
66194: PUSH
66195: LD_INT 0
66197: ST_TO_ADDR
// sSheik := false ;
66198: LD_ADDR_EXP 135
66202: PUSH
66203: LD_INT 0
66205: ST_TO_ADDR
// sEarthquake := false ;
66206: LD_ADDR_EXP 137
66210: PUSH
66211: LD_INT 0
66213: ST_TO_ADDR
// sAI := false ;
66214: LD_ADDR_EXP 138
66218: PUSH
66219: LD_INT 0
66221: ST_TO_ADDR
// sCargo := false ;
66222: LD_ADDR_EXP 141
66226: PUSH
66227: LD_INT 0
66229: ST_TO_ADDR
// sDLaser := false ;
66230: LD_ADDR_EXP 142
66234: PUSH
66235: LD_INT 0
66237: ST_TO_ADDR
// sExchange := false ;
66238: LD_ADDR_EXP 143
66242: PUSH
66243: LD_INT 0
66245: ST_TO_ADDR
// sFac := false ;
66246: LD_ADDR_EXP 144
66250: PUSH
66251: LD_INT 0
66253: ST_TO_ADDR
// sPower := false ;
66254: LD_ADDR_EXP 145
66258: PUSH
66259: LD_INT 0
66261: ST_TO_ADDR
// sRandom := false ;
66262: LD_ADDR_EXP 146
66266: PUSH
66267: LD_INT 0
66269: ST_TO_ADDR
// sShield := false ;
66270: LD_ADDR_EXP 147
66274: PUSH
66275: LD_INT 0
66277: ST_TO_ADDR
// sTime := false ;
66278: LD_ADDR_EXP 148
66282: PUSH
66283: LD_INT 0
66285: ST_TO_ADDR
// sTools := false ;
66286: LD_ADDR_EXP 149
66290: PUSH
66291: LD_INT 0
66293: ST_TO_ADDR
// sSold := false ;
66294: LD_ADDR_EXP 114
66298: PUSH
66299: LD_INT 0
66301: ST_TO_ADDR
// sDiff := false ;
66302: LD_ADDR_EXP 115
66306: PUSH
66307: LD_INT 0
66309: ST_TO_ADDR
// sFog := false ;
66310: LD_ADDR_EXP 118
66314: PUSH
66315: LD_INT 0
66317: ST_TO_ADDR
// sReset := false ;
66318: LD_ADDR_EXP 119
66322: PUSH
66323: LD_INT 0
66325: ST_TO_ADDR
// sSun := false ;
66326: LD_ADDR_EXP 120
66330: PUSH
66331: LD_INT 0
66333: ST_TO_ADDR
// sTiger := false ;
66334: LD_ADDR_EXP 116
66338: PUSH
66339: LD_INT 0
66341: ST_TO_ADDR
// sBomb := false ;
66342: LD_ADDR_EXP 117
66346: PUSH
66347: LD_INT 0
66349: ST_TO_ADDR
// sWound := false ;
66350: LD_ADDR_EXP 125
66354: PUSH
66355: LD_INT 0
66357: ST_TO_ADDR
// sBetray := false ;
66358: LD_ADDR_EXP 129
66362: PUSH
66363: LD_INT 0
66365: ST_TO_ADDR
// sContamin := false ;
66366: LD_ADDR_EXP 130
66370: PUSH
66371: LD_INT 0
66373: ST_TO_ADDR
// sOil := false ;
66374: LD_ADDR_EXP 132
66378: PUSH
66379: LD_INT 0
66381: ST_TO_ADDR
// sStu := false ;
66382: LD_ADDR_EXP 136
66386: PUSH
66387: LD_INT 0
66389: ST_TO_ADDR
// sBazooka := false ;
66390: LD_ADDR_EXP 139
66394: PUSH
66395: LD_INT 0
66397: ST_TO_ADDR
// sMortar := false ;
66398: LD_ADDR_EXP 140
66402: PUSH
66403: LD_INT 0
66405: ST_TO_ADDR
// sRanger := false ;
66406: LD_ADDR_EXP 150
66410: PUSH
66411: LD_INT 0
66413: ST_TO_ADDR
// sComputer := false ;
66414: LD_ADDR_EXP 151
66418: PUSH
66419: LD_INT 0
66421: ST_TO_ADDR
// s30 := false ;
66422: LD_ADDR_EXP 152
66426: PUSH
66427: LD_INT 0
66429: ST_TO_ADDR
// s60 := false ;
66430: LD_ADDR_EXP 153
66434: PUSH
66435: LD_INT 0
66437: ST_TO_ADDR
// end ;
66438: LD_VAR 0 1
66442: RET
// function DefineStreamItems ( isGameLoad ) ; var tmp , flags , normal , hardcore , active , i ; begin
66443: LD_INT 0
66445: PPUSH
66446: PPUSH
66447: PPUSH
66448: PPUSH
66449: PPUSH
66450: PPUSH
66451: PPUSH
// result := [ ] ;
66452: LD_ADDR_VAR 0 2
66456: PUSH
66457: EMPTY
66458: ST_TO_ADDR
// if campaign_id = 1 then
66459: LD_OWVAR 69
66463: PUSH
66464: LD_INT 1
66466: EQUAL
66467: IFFALSE 69633
// begin case mission_number of 1 :
66469: LD_OWVAR 70
66473: PUSH
66474: LD_INT 1
66476: DOUBLE
66477: EQUAL
66478: IFTRUE 66482
66480: GO 66558
66482: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 , 116 , 117 , 118 ] ] ; 2 :
66483: LD_ADDR_VAR 0 2
66487: PUSH
66488: LD_INT 2
66490: PUSH
66491: LD_INT 4
66493: PUSH
66494: LD_INT 11
66496: PUSH
66497: LD_INT 12
66499: PUSH
66500: LD_INT 15
66502: PUSH
66503: LD_INT 16
66505: PUSH
66506: LD_INT 22
66508: PUSH
66509: LD_INT 23
66511: PUSH
66512: LD_INT 26
66514: PUSH
66515: EMPTY
66516: LIST
66517: LIST
66518: LIST
66519: LIST
66520: LIST
66521: LIST
66522: LIST
66523: LIST
66524: LIST
66525: PUSH
66526: LD_INT 101
66528: PUSH
66529: LD_INT 102
66531: PUSH
66532: LD_INT 106
66534: PUSH
66535: LD_INT 116
66537: PUSH
66538: LD_INT 117
66540: PUSH
66541: LD_INT 118
66543: PUSH
66544: EMPTY
66545: LIST
66546: LIST
66547: LIST
66548: LIST
66549: LIST
66550: LIST
66551: PUSH
66552: EMPTY
66553: LIST
66554: LIST
66555: ST_TO_ADDR
66556: GO 69631
66558: LD_INT 2
66560: DOUBLE
66561: EQUAL
66562: IFTRUE 66566
66564: GO 66650
66566: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 3 :
66567: LD_ADDR_VAR 0 2
66571: PUSH
66572: LD_INT 2
66574: PUSH
66575: LD_INT 4
66577: PUSH
66578: LD_INT 11
66580: PUSH
66581: LD_INT 12
66583: PUSH
66584: LD_INT 15
66586: PUSH
66587: LD_INT 16
66589: PUSH
66590: LD_INT 22
66592: PUSH
66593: LD_INT 23
66595: PUSH
66596: LD_INT 26
66598: PUSH
66599: EMPTY
66600: LIST
66601: LIST
66602: LIST
66603: LIST
66604: LIST
66605: LIST
66606: LIST
66607: LIST
66608: LIST
66609: PUSH
66610: LD_INT 101
66612: PUSH
66613: LD_INT 102
66615: PUSH
66616: LD_INT 105
66618: PUSH
66619: LD_INT 106
66621: PUSH
66622: LD_INT 108
66624: PUSH
66625: LD_INT 116
66627: PUSH
66628: LD_INT 117
66630: PUSH
66631: LD_INT 118
66633: PUSH
66634: EMPTY
66635: LIST
66636: LIST
66637: LIST
66638: LIST
66639: LIST
66640: LIST
66641: LIST
66642: LIST
66643: PUSH
66644: EMPTY
66645: LIST
66646: LIST
66647: ST_TO_ADDR
66648: GO 69631
66650: LD_INT 3
66652: DOUBLE
66653: EQUAL
66654: IFTRUE 66658
66656: GO 66746
66658: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 4 :
66659: LD_ADDR_VAR 0 2
66663: PUSH
66664: LD_INT 2
66666: PUSH
66667: LD_INT 4
66669: PUSH
66670: LD_INT 5
66672: PUSH
66673: LD_INT 11
66675: PUSH
66676: LD_INT 12
66678: PUSH
66679: LD_INT 15
66681: PUSH
66682: LD_INT 16
66684: PUSH
66685: LD_INT 22
66687: PUSH
66688: LD_INT 26
66690: PUSH
66691: LD_INT 36
66693: PUSH
66694: EMPTY
66695: LIST
66696: LIST
66697: LIST
66698: LIST
66699: LIST
66700: LIST
66701: LIST
66702: LIST
66703: LIST
66704: LIST
66705: PUSH
66706: LD_INT 101
66708: PUSH
66709: LD_INT 102
66711: PUSH
66712: LD_INT 105
66714: PUSH
66715: LD_INT 106
66717: PUSH
66718: LD_INT 108
66720: PUSH
66721: LD_INT 116
66723: PUSH
66724: LD_INT 117
66726: PUSH
66727: LD_INT 118
66729: PUSH
66730: EMPTY
66731: LIST
66732: LIST
66733: LIST
66734: LIST
66735: LIST
66736: LIST
66737: LIST
66738: LIST
66739: PUSH
66740: EMPTY
66741: LIST
66742: LIST
66743: ST_TO_ADDR
66744: GO 69631
66746: LD_INT 4
66748: DOUBLE
66749: EQUAL
66750: IFTRUE 66754
66752: GO 66850
66754: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 5 :
66755: LD_ADDR_VAR 0 2
66759: PUSH
66760: LD_INT 2
66762: PUSH
66763: LD_INT 4
66765: PUSH
66766: LD_INT 5
66768: PUSH
66769: LD_INT 8
66771: PUSH
66772: LD_INT 11
66774: PUSH
66775: LD_INT 12
66777: PUSH
66778: LD_INT 15
66780: PUSH
66781: LD_INT 16
66783: PUSH
66784: LD_INT 22
66786: PUSH
66787: LD_INT 23
66789: PUSH
66790: LD_INT 26
66792: PUSH
66793: LD_INT 36
66795: PUSH
66796: EMPTY
66797: LIST
66798: LIST
66799: LIST
66800: LIST
66801: LIST
66802: LIST
66803: LIST
66804: LIST
66805: LIST
66806: LIST
66807: LIST
66808: LIST
66809: PUSH
66810: LD_INT 101
66812: PUSH
66813: LD_INT 102
66815: PUSH
66816: LD_INT 105
66818: PUSH
66819: LD_INT 106
66821: PUSH
66822: LD_INT 108
66824: PUSH
66825: LD_INT 116
66827: PUSH
66828: LD_INT 117
66830: PUSH
66831: LD_INT 118
66833: PUSH
66834: EMPTY
66835: LIST
66836: LIST
66837: LIST
66838: LIST
66839: LIST
66840: LIST
66841: LIST
66842: LIST
66843: PUSH
66844: EMPTY
66845: LIST
66846: LIST
66847: ST_TO_ADDR
66848: GO 69631
66850: LD_INT 5
66852: DOUBLE
66853: EQUAL
66854: IFTRUE 66858
66856: GO 66970
66858: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 6 :
66859: LD_ADDR_VAR 0 2
66863: PUSH
66864: LD_INT 2
66866: PUSH
66867: LD_INT 4
66869: PUSH
66870: LD_INT 5
66872: PUSH
66873: LD_INT 6
66875: PUSH
66876: LD_INT 8
66878: PUSH
66879: LD_INT 11
66881: PUSH
66882: LD_INT 12
66884: PUSH
66885: LD_INT 15
66887: PUSH
66888: LD_INT 16
66890: PUSH
66891: LD_INT 22
66893: PUSH
66894: LD_INT 23
66896: PUSH
66897: LD_INT 25
66899: PUSH
66900: LD_INT 26
66902: PUSH
66903: LD_INT 36
66905: PUSH
66906: EMPTY
66907: LIST
66908: LIST
66909: LIST
66910: LIST
66911: LIST
66912: LIST
66913: LIST
66914: LIST
66915: LIST
66916: LIST
66917: LIST
66918: LIST
66919: LIST
66920: LIST
66921: PUSH
66922: LD_INT 101
66924: PUSH
66925: LD_INT 102
66927: PUSH
66928: LD_INT 105
66930: PUSH
66931: LD_INT 106
66933: PUSH
66934: LD_INT 108
66936: PUSH
66937: LD_INT 109
66939: PUSH
66940: LD_INT 112
66942: PUSH
66943: LD_INT 116
66945: PUSH
66946: LD_INT 117
66948: PUSH
66949: LD_INT 118
66951: PUSH
66952: EMPTY
66953: LIST
66954: LIST
66955: LIST
66956: LIST
66957: LIST
66958: LIST
66959: LIST
66960: LIST
66961: LIST
66962: LIST
66963: PUSH
66964: EMPTY
66965: LIST
66966: LIST
66967: ST_TO_ADDR
66968: GO 69631
66970: LD_INT 6
66972: DOUBLE
66973: EQUAL
66974: IFTRUE 66978
66976: GO 67110
66978: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 7 :
66979: LD_ADDR_VAR 0 2
66983: PUSH
66984: LD_INT 2
66986: PUSH
66987: LD_INT 4
66989: PUSH
66990: LD_INT 5
66992: PUSH
66993: LD_INT 6
66995: PUSH
66996: LD_INT 8
66998: PUSH
66999: LD_INT 11
67001: PUSH
67002: LD_INT 12
67004: PUSH
67005: LD_INT 15
67007: PUSH
67008: LD_INT 16
67010: PUSH
67011: LD_INT 20
67013: PUSH
67014: LD_INT 21
67016: PUSH
67017: LD_INT 22
67019: PUSH
67020: LD_INT 23
67022: PUSH
67023: LD_INT 25
67025: PUSH
67026: LD_INT 26
67028: PUSH
67029: LD_INT 30
67031: PUSH
67032: LD_INT 31
67034: PUSH
67035: LD_INT 32
67037: PUSH
67038: LD_INT 36
67040: PUSH
67041: EMPTY
67042: LIST
67043: LIST
67044: LIST
67045: LIST
67046: LIST
67047: LIST
67048: LIST
67049: LIST
67050: LIST
67051: LIST
67052: LIST
67053: LIST
67054: LIST
67055: LIST
67056: LIST
67057: LIST
67058: LIST
67059: LIST
67060: LIST
67061: PUSH
67062: LD_INT 101
67064: PUSH
67065: LD_INT 102
67067: PUSH
67068: LD_INT 105
67070: PUSH
67071: LD_INT 106
67073: PUSH
67074: LD_INT 108
67076: PUSH
67077: LD_INT 109
67079: PUSH
67080: LD_INT 112
67082: PUSH
67083: LD_INT 116
67085: PUSH
67086: LD_INT 117
67088: PUSH
67089: LD_INT 118
67091: PUSH
67092: EMPTY
67093: LIST
67094: LIST
67095: LIST
67096: LIST
67097: LIST
67098: LIST
67099: LIST
67100: LIST
67101: LIST
67102: LIST
67103: PUSH
67104: EMPTY
67105: LIST
67106: LIST
67107: ST_TO_ADDR
67108: GO 69631
67110: LD_INT 7
67112: DOUBLE
67113: EQUAL
67114: IFTRUE 67118
67116: GO 67230
67118: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 , 116 , 117 , 118 ] ] ; 8 :
67119: LD_ADDR_VAR 0 2
67123: PUSH
67124: LD_INT 2
67126: PUSH
67127: LD_INT 4
67129: PUSH
67130: LD_INT 5
67132: PUSH
67133: LD_INT 7
67135: PUSH
67136: LD_INT 11
67138: PUSH
67139: LD_INT 12
67141: PUSH
67142: LD_INT 15
67144: PUSH
67145: LD_INT 16
67147: PUSH
67148: LD_INT 20
67150: PUSH
67151: LD_INT 21
67153: PUSH
67154: LD_INT 22
67156: PUSH
67157: LD_INT 23
67159: PUSH
67160: LD_INT 25
67162: PUSH
67163: LD_INT 26
67165: PUSH
67166: EMPTY
67167: LIST
67168: LIST
67169: LIST
67170: LIST
67171: LIST
67172: LIST
67173: LIST
67174: LIST
67175: LIST
67176: LIST
67177: LIST
67178: LIST
67179: LIST
67180: LIST
67181: PUSH
67182: LD_INT 101
67184: PUSH
67185: LD_INT 102
67187: PUSH
67188: LD_INT 103
67190: PUSH
67191: LD_INT 105
67193: PUSH
67194: LD_INT 106
67196: PUSH
67197: LD_INT 108
67199: PUSH
67200: LD_INT 112
67202: PUSH
67203: LD_INT 116
67205: PUSH
67206: LD_INT 117
67208: PUSH
67209: LD_INT 118
67211: PUSH
67212: EMPTY
67213: LIST
67214: LIST
67215: LIST
67216: LIST
67217: LIST
67218: LIST
67219: LIST
67220: LIST
67221: LIST
67222: LIST
67223: PUSH
67224: EMPTY
67225: LIST
67226: LIST
67227: ST_TO_ADDR
67228: GO 69631
67230: LD_INT 8
67232: DOUBLE
67233: EQUAL
67234: IFTRUE 67238
67236: GO 67378
67238: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 9 :
67239: LD_ADDR_VAR 0 2
67243: PUSH
67244: LD_INT 2
67246: PUSH
67247: LD_INT 4
67249: PUSH
67250: LD_INT 5
67252: PUSH
67253: LD_INT 6
67255: PUSH
67256: LD_INT 7
67258: PUSH
67259: LD_INT 8
67261: PUSH
67262: LD_INT 11
67264: PUSH
67265: LD_INT 12
67267: PUSH
67268: LD_INT 15
67270: PUSH
67271: LD_INT 16
67273: PUSH
67274: LD_INT 20
67276: PUSH
67277: LD_INT 21
67279: PUSH
67280: LD_INT 22
67282: PUSH
67283: LD_INT 23
67285: PUSH
67286: LD_INT 25
67288: PUSH
67289: LD_INT 26
67291: PUSH
67292: LD_INT 30
67294: PUSH
67295: LD_INT 31
67297: PUSH
67298: LD_INT 32
67300: PUSH
67301: LD_INT 36
67303: PUSH
67304: EMPTY
67305: LIST
67306: LIST
67307: LIST
67308: LIST
67309: LIST
67310: LIST
67311: LIST
67312: LIST
67313: LIST
67314: LIST
67315: LIST
67316: LIST
67317: LIST
67318: LIST
67319: LIST
67320: LIST
67321: LIST
67322: LIST
67323: LIST
67324: LIST
67325: PUSH
67326: LD_INT 101
67328: PUSH
67329: LD_INT 102
67331: PUSH
67332: LD_INT 103
67334: PUSH
67335: LD_INT 105
67337: PUSH
67338: LD_INT 106
67340: PUSH
67341: LD_INT 108
67343: PUSH
67344: LD_INT 109
67346: PUSH
67347: LD_INT 112
67349: PUSH
67350: LD_INT 116
67352: PUSH
67353: LD_INT 117
67355: PUSH
67356: LD_INT 118
67358: PUSH
67359: EMPTY
67360: LIST
67361: LIST
67362: LIST
67363: LIST
67364: LIST
67365: LIST
67366: LIST
67367: LIST
67368: LIST
67369: LIST
67370: LIST
67371: PUSH
67372: EMPTY
67373: LIST
67374: LIST
67375: ST_TO_ADDR
67376: GO 69631
67378: LD_INT 9
67380: DOUBLE
67381: EQUAL
67382: IFTRUE 67386
67384: GO 67534
67386: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 , 116 , 117 , 118 ] ] ; 10 :
67387: LD_ADDR_VAR 0 2
67391: PUSH
67392: LD_INT 2
67394: PUSH
67395: LD_INT 4
67397: PUSH
67398: LD_INT 5
67400: PUSH
67401: LD_INT 6
67403: PUSH
67404: LD_INT 7
67406: PUSH
67407: LD_INT 8
67409: PUSH
67410: LD_INT 11
67412: PUSH
67413: LD_INT 12
67415: PUSH
67416: LD_INT 15
67418: PUSH
67419: LD_INT 16
67421: PUSH
67422: LD_INT 20
67424: PUSH
67425: LD_INT 21
67427: PUSH
67428: LD_INT 22
67430: PUSH
67431: LD_INT 23
67433: PUSH
67434: LD_INT 25
67436: PUSH
67437: LD_INT 26
67439: PUSH
67440: LD_INT 28
67442: PUSH
67443: LD_INT 30
67445: PUSH
67446: LD_INT 31
67448: PUSH
67449: LD_INT 32
67451: PUSH
67452: LD_INT 36
67454: PUSH
67455: EMPTY
67456: LIST
67457: LIST
67458: LIST
67459: LIST
67460: LIST
67461: LIST
67462: LIST
67463: LIST
67464: LIST
67465: LIST
67466: LIST
67467: LIST
67468: LIST
67469: LIST
67470: LIST
67471: LIST
67472: LIST
67473: LIST
67474: LIST
67475: LIST
67476: LIST
67477: PUSH
67478: LD_INT 101
67480: PUSH
67481: LD_INT 102
67483: PUSH
67484: LD_INT 103
67486: PUSH
67487: LD_INT 105
67489: PUSH
67490: LD_INT 106
67492: PUSH
67493: LD_INT 108
67495: PUSH
67496: LD_INT 109
67498: PUSH
67499: LD_INT 112
67501: PUSH
67502: LD_INT 114
67504: PUSH
67505: LD_INT 116
67507: PUSH
67508: LD_INT 117
67510: PUSH
67511: LD_INT 118
67513: PUSH
67514: EMPTY
67515: LIST
67516: LIST
67517: LIST
67518: LIST
67519: LIST
67520: LIST
67521: LIST
67522: LIST
67523: LIST
67524: LIST
67525: LIST
67526: LIST
67527: PUSH
67528: EMPTY
67529: LIST
67530: LIST
67531: ST_TO_ADDR
67532: GO 69631
67534: LD_INT 10
67536: DOUBLE
67537: EQUAL
67538: IFTRUE 67542
67540: GO 67738
67542: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 11 :
67543: LD_ADDR_VAR 0 2
67547: PUSH
67548: LD_INT 2
67550: PUSH
67551: LD_INT 4
67553: PUSH
67554: LD_INT 5
67556: PUSH
67557: LD_INT 6
67559: PUSH
67560: LD_INT 7
67562: PUSH
67563: LD_INT 8
67565: PUSH
67566: LD_INT 9
67568: PUSH
67569: LD_INT 10
67571: PUSH
67572: LD_INT 11
67574: PUSH
67575: LD_INT 12
67577: PUSH
67578: LD_INT 13
67580: PUSH
67581: LD_INT 14
67583: PUSH
67584: LD_INT 15
67586: PUSH
67587: LD_INT 16
67589: PUSH
67590: LD_INT 17
67592: PUSH
67593: LD_INT 18
67595: PUSH
67596: LD_INT 19
67598: PUSH
67599: LD_INT 20
67601: PUSH
67602: LD_INT 21
67604: PUSH
67605: LD_INT 22
67607: PUSH
67608: LD_INT 23
67610: PUSH
67611: LD_INT 24
67613: PUSH
67614: LD_INT 25
67616: PUSH
67617: LD_INT 26
67619: PUSH
67620: LD_INT 28
67622: PUSH
67623: LD_INT 30
67625: PUSH
67626: LD_INT 31
67628: PUSH
67629: LD_INT 32
67631: PUSH
67632: LD_INT 36
67634: PUSH
67635: EMPTY
67636: LIST
67637: LIST
67638: LIST
67639: LIST
67640: LIST
67641: LIST
67642: LIST
67643: LIST
67644: LIST
67645: LIST
67646: LIST
67647: LIST
67648: LIST
67649: LIST
67650: LIST
67651: LIST
67652: LIST
67653: LIST
67654: LIST
67655: LIST
67656: LIST
67657: LIST
67658: LIST
67659: LIST
67660: LIST
67661: LIST
67662: LIST
67663: LIST
67664: LIST
67665: PUSH
67666: LD_INT 101
67668: PUSH
67669: LD_INT 102
67671: PUSH
67672: LD_INT 103
67674: PUSH
67675: LD_INT 104
67677: PUSH
67678: LD_INT 105
67680: PUSH
67681: LD_INT 106
67683: PUSH
67684: LD_INT 107
67686: PUSH
67687: LD_INT 108
67689: PUSH
67690: LD_INT 109
67692: PUSH
67693: LD_INT 110
67695: PUSH
67696: LD_INT 111
67698: PUSH
67699: LD_INT 112
67701: PUSH
67702: LD_INT 114
67704: PUSH
67705: LD_INT 116
67707: PUSH
67708: LD_INT 117
67710: PUSH
67711: LD_INT 118
67713: PUSH
67714: EMPTY
67715: LIST
67716: LIST
67717: LIST
67718: LIST
67719: LIST
67720: LIST
67721: LIST
67722: LIST
67723: LIST
67724: LIST
67725: LIST
67726: LIST
67727: LIST
67728: LIST
67729: LIST
67730: LIST
67731: PUSH
67732: EMPTY
67733: LIST
67734: LIST
67735: ST_TO_ADDR
67736: GO 69631
67738: LD_INT 11
67740: DOUBLE
67741: EQUAL
67742: IFTRUE 67746
67744: GO 67950
67746: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 12 :
67747: LD_ADDR_VAR 0 2
67751: PUSH
67752: LD_INT 2
67754: PUSH
67755: LD_INT 3
67757: PUSH
67758: LD_INT 4
67760: PUSH
67761: LD_INT 5
67763: PUSH
67764: LD_INT 6
67766: PUSH
67767: LD_INT 7
67769: PUSH
67770: LD_INT 8
67772: PUSH
67773: LD_INT 9
67775: PUSH
67776: LD_INT 10
67778: PUSH
67779: LD_INT 11
67781: PUSH
67782: LD_INT 12
67784: PUSH
67785: LD_INT 13
67787: PUSH
67788: LD_INT 14
67790: PUSH
67791: LD_INT 15
67793: PUSH
67794: LD_INT 16
67796: PUSH
67797: LD_INT 17
67799: PUSH
67800: LD_INT 18
67802: PUSH
67803: LD_INT 19
67805: PUSH
67806: LD_INT 20
67808: PUSH
67809: LD_INT 21
67811: PUSH
67812: LD_INT 22
67814: PUSH
67815: LD_INT 23
67817: PUSH
67818: LD_INT 24
67820: PUSH
67821: LD_INT 25
67823: PUSH
67824: LD_INT 26
67826: PUSH
67827: LD_INT 28
67829: PUSH
67830: LD_INT 30
67832: PUSH
67833: LD_INT 31
67835: PUSH
67836: LD_INT 32
67838: PUSH
67839: LD_INT 34
67841: PUSH
67842: LD_INT 36
67844: PUSH
67845: EMPTY
67846: LIST
67847: LIST
67848: LIST
67849: LIST
67850: LIST
67851: LIST
67852: LIST
67853: LIST
67854: LIST
67855: LIST
67856: LIST
67857: LIST
67858: LIST
67859: LIST
67860: LIST
67861: LIST
67862: LIST
67863: LIST
67864: LIST
67865: LIST
67866: LIST
67867: LIST
67868: LIST
67869: LIST
67870: LIST
67871: LIST
67872: LIST
67873: LIST
67874: LIST
67875: LIST
67876: LIST
67877: PUSH
67878: LD_INT 101
67880: PUSH
67881: LD_INT 102
67883: PUSH
67884: LD_INT 103
67886: PUSH
67887: LD_INT 104
67889: PUSH
67890: LD_INT 105
67892: PUSH
67893: LD_INT 106
67895: PUSH
67896: LD_INT 107
67898: PUSH
67899: LD_INT 108
67901: PUSH
67902: LD_INT 109
67904: PUSH
67905: LD_INT 110
67907: PUSH
67908: LD_INT 111
67910: PUSH
67911: LD_INT 112
67913: PUSH
67914: LD_INT 114
67916: PUSH
67917: LD_INT 116
67919: PUSH
67920: LD_INT 117
67922: PUSH
67923: LD_INT 118
67925: PUSH
67926: EMPTY
67927: LIST
67928: LIST
67929: LIST
67930: LIST
67931: LIST
67932: LIST
67933: LIST
67934: LIST
67935: LIST
67936: LIST
67937: LIST
67938: LIST
67939: LIST
67940: LIST
67941: LIST
67942: LIST
67943: PUSH
67944: EMPTY
67945: LIST
67946: LIST
67947: ST_TO_ADDR
67948: GO 69631
67950: LD_INT 12
67952: DOUBLE
67953: EQUAL
67954: IFTRUE 67958
67956: GO 68178
67958: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 13 :
67959: LD_ADDR_VAR 0 2
67963: PUSH
67964: LD_INT 1
67966: PUSH
67967: LD_INT 2
67969: PUSH
67970: LD_INT 3
67972: PUSH
67973: LD_INT 4
67975: PUSH
67976: LD_INT 5
67978: PUSH
67979: LD_INT 6
67981: PUSH
67982: LD_INT 7
67984: PUSH
67985: LD_INT 8
67987: PUSH
67988: LD_INT 9
67990: PUSH
67991: LD_INT 10
67993: PUSH
67994: LD_INT 11
67996: PUSH
67997: LD_INT 12
67999: PUSH
68000: LD_INT 13
68002: PUSH
68003: LD_INT 14
68005: PUSH
68006: LD_INT 15
68008: PUSH
68009: LD_INT 16
68011: PUSH
68012: LD_INT 17
68014: PUSH
68015: LD_INT 18
68017: PUSH
68018: LD_INT 19
68020: PUSH
68021: LD_INT 20
68023: PUSH
68024: LD_INT 21
68026: PUSH
68027: LD_INT 22
68029: PUSH
68030: LD_INT 23
68032: PUSH
68033: LD_INT 24
68035: PUSH
68036: LD_INT 25
68038: PUSH
68039: LD_INT 26
68041: PUSH
68042: LD_INT 27
68044: PUSH
68045: LD_INT 28
68047: PUSH
68048: LD_INT 30
68050: PUSH
68051: LD_INT 31
68053: PUSH
68054: LD_INT 32
68056: PUSH
68057: LD_INT 33
68059: PUSH
68060: LD_INT 34
68062: PUSH
68063: LD_INT 36
68065: PUSH
68066: EMPTY
68067: LIST
68068: LIST
68069: LIST
68070: LIST
68071: LIST
68072: LIST
68073: LIST
68074: LIST
68075: LIST
68076: LIST
68077: LIST
68078: LIST
68079: LIST
68080: LIST
68081: LIST
68082: LIST
68083: LIST
68084: LIST
68085: LIST
68086: LIST
68087: LIST
68088: LIST
68089: LIST
68090: LIST
68091: LIST
68092: LIST
68093: LIST
68094: LIST
68095: LIST
68096: LIST
68097: LIST
68098: LIST
68099: LIST
68100: LIST
68101: PUSH
68102: LD_INT 101
68104: PUSH
68105: LD_INT 102
68107: PUSH
68108: LD_INT 103
68110: PUSH
68111: LD_INT 104
68113: PUSH
68114: LD_INT 105
68116: PUSH
68117: LD_INT 106
68119: PUSH
68120: LD_INT 107
68122: PUSH
68123: LD_INT 108
68125: PUSH
68126: LD_INT 109
68128: PUSH
68129: LD_INT 110
68131: PUSH
68132: LD_INT 111
68134: PUSH
68135: LD_INT 112
68137: PUSH
68138: LD_INT 113
68140: PUSH
68141: LD_INT 114
68143: PUSH
68144: LD_INT 116
68146: PUSH
68147: LD_INT 117
68149: PUSH
68150: LD_INT 118
68152: PUSH
68153: EMPTY
68154: LIST
68155: LIST
68156: LIST
68157: LIST
68158: LIST
68159: LIST
68160: LIST
68161: LIST
68162: LIST
68163: LIST
68164: LIST
68165: LIST
68166: LIST
68167: LIST
68168: LIST
68169: LIST
68170: LIST
68171: PUSH
68172: EMPTY
68173: LIST
68174: LIST
68175: ST_TO_ADDR
68176: GO 69631
68178: LD_INT 13
68180: DOUBLE
68181: EQUAL
68182: IFTRUE 68186
68184: GO 68394
68186: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 14 :
68187: LD_ADDR_VAR 0 2
68191: PUSH
68192: LD_INT 1
68194: PUSH
68195: LD_INT 2
68197: PUSH
68198: LD_INT 3
68200: PUSH
68201: LD_INT 4
68203: PUSH
68204: LD_INT 5
68206: PUSH
68207: LD_INT 8
68209: PUSH
68210: LD_INT 9
68212: PUSH
68213: LD_INT 10
68215: PUSH
68216: LD_INT 11
68218: PUSH
68219: LD_INT 12
68221: PUSH
68222: LD_INT 14
68224: PUSH
68225: LD_INT 15
68227: PUSH
68228: LD_INT 16
68230: PUSH
68231: LD_INT 17
68233: PUSH
68234: LD_INT 18
68236: PUSH
68237: LD_INT 19
68239: PUSH
68240: LD_INT 20
68242: PUSH
68243: LD_INT 21
68245: PUSH
68246: LD_INT 22
68248: PUSH
68249: LD_INT 23
68251: PUSH
68252: LD_INT 24
68254: PUSH
68255: LD_INT 25
68257: PUSH
68258: LD_INT 26
68260: PUSH
68261: LD_INT 27
68263: PUSH
68264: LD_INT 28
68266: PUSH
68267: LD_INT 30
68269: PUSH
68270: LD_INT 31
68272: PUSH
68273: LD_INT 32
68275: PUSH
68276: LD_INT 33
68278: PUSH
68279: LD_INT 34
68281: PUSH
68282: LD_INT 36
68284: PUSH
68285: EMPTY
68286: LIST
68287: LIST
68288: LIST
68289: LIST
68290: LIST
68291: LIST
68292: LIST
68293: LIST
68294: LIST
68295: LIST
68296: LIST
68297: LIST
68298: LIST
68299: LIST
68300: LIST
68301: LIST
68302: LIST
68303: LIST
68304: LIST
68305: LIST
68306: LIST
68307: LIST
68308: LIST
68309: LIST
68310: LIST
68311: LIST
68312: LIST
68313: LIST
68314: LIST
68315: LIST
68316: LIST
68317: PUSH
68318: LD_INT 101
68320: PUSH
68321: LD_INT 102
68323: PUSH
68324: LD_INT 103
68326: PUSH
68327: LD_INT 104
68329: PUSH
68330: LD_INT 105
68332: PUSH
68333: LD_INT 106
68335: PUSH
68336: LD_INT 107
68338: PUSH
68339: LD_INT 108
68341: PUSH
68342: LD_INT 109
68344: PUSH
68345: LD_INT 110
68347: PUSH
68348: LD_INT 111
68350: PUSH
68351: LD_INT 112
68353: PUSH
68354: LD_INT 113
68356: PUSH
68357: LD_INT 114
68359: PUSH
68360: LD_INT 116
68362: PUSH
68363: LD_INT 117
68365: PUSH
68366: LD_INT 118
68368: PUSH
68369: EMPTY
68370: LIST
68371: LIST
68372: LIST
68373: LIST
68374: LIST
68375: LIST
68376: LIST
68377: LIST
68378: LIST
68379: LIST
68380: LIST
68381: LIST
68382: LIST
68383: LIST
68384: LIST
68385: LIST
68386: LIST
68387: PUSH
68388: EMPTY
68389: LIST
68390: LIST
68391: ST_TO_ADDR
68392: GO 69631
68394: LD_INT 14
68396: DOUBLE
68397: EQUAL
68398: IFTRUE 68402
68400: GO 68626
68402: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 15 :
68403: LD_ADDR_VAR 0 2
68407: PUSH
68408: LD_INT 1
68410: PUSH
68411: LD_INT 2
68413: PUSH
68414: LD_INT 3
68416: PUSH
68417: LD_INT 4
68419: PUSH
68420: LD_INT 5
68422: PUSH
68423: LD_INT 6
68425: PUSH
68426: LD_INT 7
68428: PUSH
68429: LD_INT 8
68431: PUSH
68432: LD_INT 9
68434: PUSH
68435: LD_INT 10
68437: PUSH
68438: LD_INT 11
68440: PUSH
68441: LD_INT 12
68443: PUSH
68444: LD_INT 13
68446: PUSH
68447: LD_INT 14
68449: PUSH
68450: LD_INT 15
68452: PUSH
68453: LD_INT 16
68455: PUSH
68456: LD_INT 17
68458: PUSH
68459: LD_INT 18
68461: PUSH
68462: LD_INT 19
68464: PUSH
68465: LD_INT 20
68467: PUSH
68468: LD_INT 21
68470: PUSH
68471: LD_INT 22
68473: PUSH
68474: LD_INT 23
68476: PUSH
68477: LD_INT 24
68479: PUSH
68480: LD_INT 25
68482: PUSH
68483: LD_INT 26
68485: PUSH
68486: LD_INT 27
68488: PUSH
68489: LD_INT 28
68491: PUSH
68492: LD_INT 29
68494: PUSH
68495: LD_INT 30
68497: PUSH
68498: LD_INT 31
68500: PUSH
68501: LD_INT 32
68503: PUSH
68504: LD_INT 33
68506: PUSH
68507: LD_INT 34
68509: PUSH
68510: LD_INT 36
68512: PUSH
68513: EMPTY
68514: LIST
68515: LIST
68516: LIST
68517: LIST
68518: LIST
68519: LIST
68520: LIST
68521: LIST
68522: LIST
68523: LIST
68524: LIST
68525: LIST
68526: LIST
68527: LIST
68528: LIST
68529: LIST
68530: LIST
68531: LIST
68532: LIST
68533: LIST
68534: LIST
68535: LIST
68536: LIST
68537: LIST
68538: LIST
68539: LIST
68540: LIST
68541: LIST
68542: LIST
68543: LIST
68544: LIST
68545: LIST
68546: LIST
68547: LIST
68548: LIST
68549: PUSH
68550: LD_INT 101
68552: PUSH
68553: LD_INT 102
68555: PUSH
68556: LD_INT 103
68558: PUSH
68559: LD_INT 104
68561: PUSH
68562: LD_INT 105
68564: PUSH
68565: LD_INT 106
68567: PUSH
68568: LD_INT 107
68570: PUSH
68571: LD_INT 108
68573: PUSH
68574: LD_INT 109
68576: PUSH
68577: LD_INT 110
68579: PUSH
68580: LD_INT 111
68582: PUSH
68583: LD_INT 112
68585: PUSH
68586: LD_INT 113
68588: PUSH
68589: LD_INT 114
68591: PUSH
68592: LD_INT 116
68594: PUSH
68595: LD_INT 117
68597: PUSH
68598: LD_INT 118
68600: PUSH
68601: EMPTY
68602: LIST
68603: LIST
68604: LIST
68605: LIST
68606: LIST
68607: LIST
68608: LIST
68609: LIST
68610: LIST
68611: LIST
68612: LIST
68613: LIST
68614: LIST
68615: LIST
68616: LIST
68617: LIST
68618: LIST
68619: PUSH
68620: EMPTY
68621: LIST
68622: LIST
68623: ST_TO_ADDR
68624: GO 69631
68626: LD_INT 15
68628: DOUBLE
68629: EQUAL
68630: IFTRUE 68634
68632: GO 68858
68634: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 16 :
68635: LD_ADDR_VAR 0 2
68639: PUSH
68640: LD_INT 1
68642: PUSH
68643: LD_INT 2
68645: PUSH
68646: LD_INT 3
68648: PUSH
68649: LD_INT 4
68651: PUSH
68652: LD_INT 5
68654: PUSH
68655: LD_INT 6
68657: PUSH
68658: LD_INT 7
68660: PUSH
68661: LD_INT 8
68663: PUSH
68664: LD_INT 9
68666: PUSH
68667: LD_INT 10
68669: PUSH
68670: LD_INT 11
68672: PUSH
68673: LD_INT 12
68675: PUSH
68676: LD_INT 13
68678: PUSH
68679: LD_INT 14
68681: PUSH
68682: LD_INT 15
68684: PUSH
68685: LD_INT 16
68687: PUSH
68688: LD_INT 17
68690: PUSH
68691: LD_INT 18
68693: PUSH
68694: LD_INT 19
68696: PUSH
68697: LD_INT 20
68699: PUSH
68700: LD_INT 21
68702: PUSH
68703: LD_INT 22
68705: PUSH
68706: LD_INT 23
68708: PUSH
68709: LD_INT 24
68711: PUSH
68712: LD_INT 25
68714: PUSH
68715: LD_INT 26
68717: PUSH
68718: LD_INT 27
68720: PUSH
68721: LD_INT 28
68723: PUSH
68724: LD_INT 29
68726: PUSH
68727: LD_INT 30
68729: PUSH
68730: LD_INT 31
68732: PUSH
68733: LD_INT 32
68735: PUSH
68736: LD_INT 33
68738: PUSH
68739: LD_INT 34
68741: PUSH
68742: LD_INT 36
68744: PUSH
68745: EMPTY
68746: LIST
68747: LIST
68748: LIST
68749: LIST
68750: LIST
68751: LIST
68752: LIST
68753: LIST
68754: LIST
68755: LIST
68756: LIST
68757: LIST
68758: LIST
68759: LIST
68760: LIST
68761: LIST
68762: LIST
68763: LIST
68764: LIST
68765: LIST
68766: LIST
68767: LIST
68768: LIST
68769: LIST
68770: LIST
68771: LIST
68772: LIST
68773: LIST
68774: LIST
68775: LIST
68776: LIST
68777: LIST
68778: LIST
68779: LIST
68780: LIST
68781: PUSH
68782: LD_INT 101
68784: PUSH
68785: LD_INT 102
68787: PUSH
68788: LD_INT 103
68790: PUSH
68791: LD_INT 104
68793: PUSH
68794: LD_INT 105
68796: PUSH
68797: LD_INT 106
68799: PUSH
68800: LD_INT 107
68802: PUSH
68803: LD_INT 108
68805: PUSH
68806: LD_INT 109
68808: PUSH
68809: LD_INT 110
68811: PUSH
68812: LD_INT 111
68814: PUSH
68815: LD_INT 112
68817: PUSH
68818: LD_INT 113
68820: PUSH
68821: LD_INT 114
68823: PUSH
68824: LD_INT 116
68826: PUSH
68827: LD_INT 117
68829: PUSH
68830: LD_INT 118
68832: PUSH
68833: EMPTY
68834: LIST
68835: LIST
68836: LIST
68837: LIST
68838: LIST
68839: LIST
68840: LIST
68841: LIST
68842: LIST
68843: LIST
68844: LIST
68845: LIST
68846: LIST
68847: LIST
68848: LIST
68849: LIST
68850: LIST
68851: PUSH
68852: EMPTY
68853: LIST
68854: LIST
68855: ST_TO_ADDR
68856: GO 69631
68858: LD_INT 16
68860: DOUBLE
68861: EQUAL
68862: IFTRUE 68866
68864: GO 69002
68866: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 17 :
68867: LD_ADDR_VAR 0 2
68871: PUSH
68872: LD_INT 2
68874: PUSH
68875: LD_INT 4
68877: PUSH
68878: LD_INT 5
68880: PUSH
68881: LD_INT 7
68883: PUSH
68884: LD_INT 11
68886: PUSH
68887: LD_INT 12
68889: PUSH
68890: LD_INT 15
68892: PUSH
68893: LD_INT 16
68895: PUSH
68896: LD_INT 20
68898: PUSH
68899: LD_INT 21
68901: PUSH
68902: LD_INT 22
68904: PUSH
68905: LD_INT 23
68907: PUSH
68908: LD_INT 25
68910: PUSH
68911: LD_INT 26
68913: PUSH
68914: LD_INT 30
68916: PUSH
68917: LD_INT 31
68919: PUSH
68920: LD_INT 32
68922: PUSH
68923: LD_INT 33
68925: PUSH
68926: LD_INT 34
68928: PUSH
68929: EMPTY
68930: LIST
68931: LIST
68932: LIST
68933: LIST
68934: LIST
68935: LIST
68936: LIST
68937: LIST
68938: LIST
68939: LIST
68940: LIST
68941: LIST
68942: LIST
68943: LIST
68944: LIST
68945: LIST
68946: LIST
68947: LIST
68948: LIST
68949: PUSH
68950: LD_INT 101
68952: PUSH
68953: LD_INT 102
68955: PUSH
68956: LD_INT 103
68958: PUSH
68959: LD_INT 106
68961: PUSH
68962: LD_INT 108
68964: PUSH
68965: LD_INT 112
68967: PUSH
68968: LD_INT 113
68970: PUSH
68971: LD_INT 114
68973: PUSH
68974: LD_INT 116
68976: PUSH
68977: LD_INT 117
68979: PUSH
68980: LD_INT 118
68982: PUSH
68983: EMPTY
68984: LIST
68985: LIST
68986: LIST
68987: LIST
68988: LIST
68989: LIST
68990: LIST
68991: LIST
68992: LIST
68993: LIST
68994: LIST
68995: PUSH
68996: EMPTY
68997: LIST
68998: LIST
68999: ST_TO_ADDR
69000: GO 69631
69002: LD_INT 17
69004: DOUBLE
69005: EQUAL
69006: IFTRUE 69010
69008: GO 69234
69010: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 18 :
69011: LD_ADDR_VAR 0 2
69015: PUSH
69016: LD_INT 1
69018: PUSH
69019: LD_INT 2
69021: PUSH
69022: LD_INT 3
69024: PUSH
69025: LD_INT 4
69027: PUSH
69028: LD_INT 5
69030: PUSH
69031: LD_INT 6
69033: PUSH
69034: LD_INT 7
69036: PUSH
69037: LD_INT 8
69039: PUSH
69040: LD_INT 9
69042: PUSH
69043: LD_INT 10
69045: PUSH
69046: LD_INT 11
69048: PUSH
69049: LD_INT 12
69051: PUSH
69052: LD_INT 13
69054: PUSH
69055: LD_INT 14
69057: PUSH
69058: LD_INT 15
69060: PUSH
69061: LD_INT 16
69063: PUSH
69064: LD_INT 17
69066: PUSH
69067: LD_INT 18
69069: PUSH
69070: LD_INT 19
69072: PUSH
69073: LD_INT 20
69075: PUSH
69076: LD_INT 21
69078: PUSH
69079: LD_INT 22
69081: PUSH
69082: LD_INT 23
69084: PUSH
69085: LD_INT 24
69087: PUSH
69088: LD_INT 25
69090: PUSH
69091: LD_INT 26
69093: PUSH
69094: LD_INT 27
69096: PUSH
69097: LD_INT 28
69099: PUSH
69100: LD_INT 29
69102: PUSH
69103: LD_INT 30
69105: PUSH
69106: LD_INT 31
69108: PUSH
69109: LD_INT 32
69111: PUSH
69112: LD_INT 33
69114: PUSH
69115: LD_INT 34
69117: PUSH
69118: LD_INT 36
69120: PUSH
69121: EMPTY
69122: LIST
69123: LIST
69124: LIST
69125: LIST
69126: LIST
69127: LIST
69128: LIST
69129: LIST
69130: LIST
69131: LIST
69132: LIST
69133: LIST
69134: LIST
69135: LIST
69136: LIST
69137: LIST
69138: LIST
69139: LIST
69140: LIST
69141: LIST
69142: LIST
69143: LIST
69144: LIST
69145: LIST
69146: LIST
69147: LIST
69148: LIST
69149: LIST
69150: LIST
69151: LIST
69152: LIST
69153: LIST
69154: LIST
69155: LIST
69156: LIST
69157: PUSH
69158: LD_INT 101
69160: PUSH
69161: LD_INT 102
69163: PUSH
69164: LD_INT 103
69166: PUSH
69167: LD_INT 104
69169: PUSH
69170: LD_INT 105
69172: PUSH
69173: LD_INT 106
69175: PUSH
69176: LD_INT 107
69178: PUSH
69179: LD_INT 108
69181: PUSH
69182: LD_INT 109
69184: PUSH
69185: LD_INT 110
69187: PUSH
69188: LD_INT 111
69190: PUSH
69191: LD_INT 112
69193: PUSH
69194: LD_INT 113
69196: PUSH
69197: LD_INT 114
69199: PUSH
69200: LD_INT 116
69202: PUSH
69203: LD_INT 117
69205: PUSH
69206: LD_INT 118
69208: PUSH
69209: EMPTY
69210: LIST
69211: LIST
69212: LIST
69213: LIST
69214: LIST
69215: LIST
69216: LIST
69217: LIST
69218: LIST
69219: LIST
69220: LIST
69221: LIST
69222: LIST
69223: LIST
69224: LIST
69225: LIST
69226: LIST
69227: PUSH
69228: EMPTY
69229: LIST
69230: LIST
69231: ST_TO_ADDR
69232: GO 69631
69234: LD_INT 18
69236: DOUBLE
69237: EQUAL
69238: IFTRUE 69242
69240: GO 69390
69242: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; 19 :
69243: LD_ADDR_VAR 0 2
69247: PUSH
69248: LD_INT 2
69250: PUSH
69251: LD_INT 4
69253: PUSH
69254: LD_INT 5
69256: PUSH
69257: LD_INT 7
69259: PUSH
69260: LD_INT 11
69262: PUSH
69263: LD_INT 12
69265: PUSH
69266: LD_INT 15
69268: PUSH
69269: LD_INT 16
69271: PUSH
69272: LD_INT 20
69274: PUSH
69275: LD_INT 21
69277: PUSH
69278: LD_INT 22
69280: PUSH
69281: LD_INT 23
69283: PUSH
69284: LD_INT 25
69286: PUSH
69287: LD_INT 26
69289: PUSH
69290: LD_INT 30
69292: PUSH
69293: LD_INT 31
69295: PUSH
69296: LD_INT 32
69298: PUSH
69299: LD_INT 33
69301: PUSH
69302: LD_INT 34
69304: PUSH
69305: LD_INT 35
69307: PUSH
69308: LD_INT 36
69310: PUSH
69311: EMPTY
69312: LIST
69313: LIST
69314: LIST
69315: LIST
69316: LIST
69317: LIST
69318: LIST
69319: LIST
69320: LIST
69321: LIST
69322: LIST
69323: LIST
69324: LIST
69325: LIST
69326: LIST
69327: LIST
69328: LIST
69329: LIST
69330: LIST
69331: LIST
69332: LIST
69333: PUSH
69334: LD_INT 101
69336: PUSH
69337: LD_INT 102
69339: PUSH
69340: LD_INT 103
69342: PUSH
69343: LD_INT 106
69345: PUSH
69346: LD_INT 108
69348: PUSH
69349: LD_INT 112
69351: PUSH
69352: LD_INT 113
69354: PUSH
69355: LD_INT 114
69357: PUSH
69358: LD_INT 115
69360: PUSH
69361: LD_INT 116
69363: PUSH
69364: LD_INT 117
69366: PUSH
69367: LD_INT 118
69369: PUSH
69370: EMPTY
69371: LIST
69372: LIST
69373: LIST
69374: LIST
69375: LIST
69376: LIST
69377: LIST
69378: LIST
69379: LIST
69380: LIST
69381: LIST
69382: LIST
69383: PUSH
69384: EMPTY
69385: LIST
69386: LIST
69387: ST_TO_ADDR
69388: GO 69631
69390: LD_INT 19
69392: DOUBLE
69393: EQUAL
69394: IFTRUE 69398
69396: GO 69630
69398: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; end ;
69399: LD_ADDR_VAR 0 2
69403: PUSH
69404: LD_INT 1
69406: PUSH
69407: LD_INT 2
69409: PUSH
69410: LD_INT 3
69412: PUSH
69413: LD_INT 4
69415: PUSH
69416: LD_INT 5
69418: PUSH
69419: LD_INT 6
69421: PUSH
69422: LD_INT 7
69424: PUSH
69425: LD_INT 8
69427: PUSH
69428: LD_INT 9
69430: PUSH
69431: LD_INT 10
69433: PUSH
69434: LD_INT 11
69436: PUSH
69437: LD_INT 12
69439: PUSH
69440: LD_INT 13
69442: PUSH
69443: LD_INT 14
69445: PUSH
69446: LD_INT 15
69448: PUSH
69449: LD_INT 16
69451: PUSH
69452: LD_INT 17
69454: PUSH
69455: LD_INT 18
69457: PUSH
69458: LD_INT 19
69460: PUSH
69461: LD_INT 20
69463: PUSH
69464: LD_INT 21
69466: PUSH
69467: LD_INT 22
69469: PUSH
69470: LD_INT 23
69472: PUSH
69473: LD_INT 24
69475: PUSH
69476: LD_INT 25
69478: PUSH
69479: LD_INT 26
69481: PUSH
69482: LD_INT 27
69484: PUSH
69485: LD_INT 28
69487: PUSH
69488: LD_INT 29
69490: PUSH
69491: LD_INT 30
69493: PUSH
69494: LD_INT 31
69496: PUSH
69497: LD_INT 32
69499: PUSH
69500: LD_INT 33
69502: PUSH
69503: LD_INT 34
69505: PUSH
69506: LD_INT 35
69508: PUSH
69509: LD_INT 36
69511: PUSH
69512: EMPTY
69513: LIST
69514: LIST
69515: LIST
69516: LIST
69517: LIST
69518: LIST
69519: LIST
69520: LIST
69521: LIST
69522: LIST
69523: LIST
69524: LIST
69525: LIST
69526: LIST
69527: LIST
69528: LIST
69529: LIST
69530: LIST
69531: LIST
69532: LIST
69533: LIST
69534: LIST
69535: LIST
69536: LIST
69537: LIST
69538: LIST
69539: LIST
69540: LIST
69541: LIST
69542: LIST
69543: LIST
69544: LIST
69545: LIST
69546: LIST
69547: LIST
69548: LIST
69549: PUSH
69550: LD_INT 101
69552: PUSH
69553: LD_INT 102
69555: PUSH
69556: LD_INT 103
69558: PUSH
69559: LD_INT 104
69561: PUSH
69562: LD_INT 105
69564: PUSH
69565: LD_INT 106
69567: PUSH
69568: LD_INT 107
69570: PUSH
69571: LD_INT 108
69573: PUSH
69574: LD_INT 109
69576: PUSH
69577: LD_INT 110
69579: PUSH
69580: LD_INT 111
69582: PUSH
69583: LD_INT 112
69585: PUSH
69586: LD_INT 113
69588: PUSH
69589: LD_INT 114
69591: PUSH
69592: LD_INT 115
69594: PUSH
69595: LD_INT 116
69597: PUSH
69598: LD_INT 117
69600: PUSH
69601: LD_INT 118
69603: PUSH
69604: EMPTY
69605: LIST
69606: LIST
69607: LIST
69608: LIST
69609: LIST
69610: LIST
69611: LIST
69612: LIST
69613: LIST
69614: LIST
69615: LIST
69616: LIST
69617: LIST
69618: LIST
69619: LIST
69620: LIST
69621: LIST
69622: LIST
69623: PUSH
69624: EMPTY
69625: LIST
69626: LIST
69627: ST_TO_ADDR
69628: GO 69631
69630: POP
// end else
69631: GO 69862
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ;
69633: LD_ADDR_VAR 0 2
69637: PUSH
69638: LD_INT 1
69640: PUSH
69641: LD_INT 2
69643: PUSH
69644: LD_INT 3
69646: PUSH
69647: LD_INT 4
69649: PUSH
69650: LD_INT 5
69652: PUSH
69653: LD_INT 6
69655: PUSH
69656: LD_INT 7
69658: PUSH
69659: LD_INT 8
69661: PUSH
69662: LD_INT 9
69664: PUSH
69665: LD_INT 10
69667: PUSH
69668: LD_INT 11
69670: PUSH
69671: LD_INT 12
69673: PUSH
69674: LD_INT 13
69676: PUSH
69677: LD_INT 14
69679: PUSH
69680: LD_INT 15
69682: PUSH
69683: LD_INT 16
69685: PUSH
69686: LD_INT 17
69688: PUSH
69689: LD_INT 18
69691: PUSH
69692: LD_INT 19
69694: PUSH
69695: LD_INT 20
69697: PUSH
69698: LD_INT 21
69700: PUSH
69701: LD_INT 22
69703: PUSH
69704: LD_INT 23
69706: PUSH
69707: LD_INT 24
69709: PUSH
69710: LD_INT 25
69712: PUSH
69713: LD_INT 26
69715: PUSH
69716: LD_INT 27
69718: PUSH
69719: LD_INT 28
69721: PUSH
69722: LD_INT 29
69724: PUSH
69725: LD_INT 30
69727: PUSH
69728: LD_INT 31
69730: PUSH
69731: LD_INT 32
69733: PUSH
69734: LD_INT 33
69736: PUSH
69737: LD_INT 34
69739: PUSH
69740: LD_INT 35
69742: PUSH
69743: LD_INT 36
69745: PUSH
69746: EMPTY
69747: LIST
69748: LIST
69749: LIST
69750: LIST
69751: LIST
69752: LIST
69753: LIST
69754: LIST
69755: LIST
69756: LIST
69757: LIST
69758: LIST
69759: LIST
69760: LIST
69761: LIST
69762: LIST
69763: LIST
69764: LIST
69765: LIST
69766: LIST
69767: LIST
69768: LIST
69769: LIST
69770: LIST
69771: LIST
69772: LIST
69773: LIST
69774: LIST
69775: LIST
69776: LIST
69777: LIST
69778: LIST
69779: LIST
69780: LIST
69781: LIST
69782: LIST
69783: PUSH
69784: LD_INT 101
69786: PUSH
69787: LD_INT 102
69789: PUSH
69790: LD_INT 103
69792: PUSH
69793: LD_INT 104
69795: PUSH
69796: LD_INT 105
69798: PUSH
69799: LD_INT 106
69801: PUSH
69802: LD_INT 107
69804: PUSH
69805: LD_INT 108
69807: PUSH
69808: LD_INT 109
69810: PUSH
69811: LD_INT 110
69813: PUSH
69814: LD_INT 111
69816: PUSH
69817: LD_INT 112
69819: PUSH
69820: LD_INT 113
69822: PUSH
69823: LD_INT 114
69825: PUSH
69826: LD_INT 115
69828: PUSH
69829: LD_INT 116
69831: PUSH
69832: LD_INT 117
69834: PUSH
69835: LD_INT 118
69837: PUSH
69838: EMPTY
69839: LIST
69840: LIST
69841: LIST
69842: LIST
69843: LIST
69844: LIST
69845: LIST
69846: LIST
69847: LIST
69848: LIST
69849: LIST
69850: LIST
69851: LIST
69852: LIST
69853: LIST
69854: LIST
69855: LIST
69856: LIST
69857: PUSH
69858: EMPTY
69859: LIST
69860: LIST
69861: ST_TO_ADDR
// if result then
69862: LD_VAR 0 2
69866: IFFALSE 70652
// begin normal :=  ;
69868: LD_ADDR_VAR 0 5
69872: PUSH
69873: LD_STRING 
69875: ST_TO_ADDR
// hardcore :=  ;
69876: LD_ADDR_VAR 0 6
69880: PUSH
69881: LD_STRING 
69883: ST_TO_ADDR
// active :=  ;
69884: LD_ADDR_VAR 0 7
69888: PUSH
69889: LD_STRING 
69891: ST_TO_ADDR
// for i = 1 to normalCounter do
69892: LD_ADDR_VAR 0 8
69896: PUSH
69897: DOUBLE
69898: LD_INT 1
69900: DEC
69901: ST_TO_ADDR
69902: LD_EXP 98
69906: PUSH
69907: FOR_TO
69908: IFFALSE 70009
// begin tmp := 0 ;
69910: LD_ADDR_VAR 0 3
69914: PUSH
69915: LD_STRING 0
69917: ST_TO_ADDR
// if result [ 1 ] then
69918: LD_VAR 0 2
69922: PUSH
69923: LD_INT 1
69925: ARRAY
69926: IFFALSE 69991
// if result [ 1 ] [ 1 ] = i then
69928: LD_VAR 0 2
69932: PUSH
69933: LD_INT 1
69935: ARRAY
69936: PUSH
69937: LD_INT 1
69939: ARRAY
69940: PUSH
69941: LD_VAR 0 8
69945: EQUAL
69946: IFFALSE 69991
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
69948: LD_ADDR_VAR 0 2
69952: PUSH
69953: LD_VAR 0 2
69957: PPUSH
69958: LD_INT 1
69960: PPUSH
69961: LD_VAR 0 2
69965: PUSH
69966: LD_INT 1
69968: ARRAY
69969: PPUSH
69970: LD_INT 1
69972: PPUSH
69973: CALL_OW 3
69977: PPUSH
69978: CALL_OW 1
69982: ST_TO_ADDR
// tmp := 1 ;
69983: LD_ADDR_VAR 0 3
69987: PUSH
69988: LD_STRING 1
69990: ST_TO_ADDR
// end ; normal := normal & tmp ;
69991: LD_ADDR_VAR 0 5
69995: PUSH
69996: LD_VAR 0 5
70000: PUSH
70001: LD_VAR 0 3
70005: STR
70006: ST_TO_ADDR
// end ;
70007: GO 69907
70009: POP
70010: POP
// for i = 1 to hardcoreCounter do
70011: LD_ADDR_VAR 0 8
70015: PUSH
70016: DOUBLE
70017: LD_INT 1
70019: DEC
70020: ST_TO_ADDR
70021: LD_EXP 99
70025: PUSH
70026: FOR_TO
70027: IFFALSE 70132
// begin tmp := 0 ;
70029: LD_ADDR_VAR 0 3
70033: PUSH
70034: LD_STRING 0
70036: ST_TO_ADDR
// if result [ 2 ] then
70037: LD_VAR 0 2
70041: PUSH
70042: LD_INT 2
70044: ARRAY
70045: IFFALSE 70114
// if result [ 2 ] [ 1 ] = 100 + i then
70047: LD_VAR 0 2
70051: PUSH
70052: LD_INT 2
70054: ARRAY
70055: PUSH
70056: LD_INT 1
70058: ARRAY
70059: PUSH
70060: LD_INT 100
70062: PUSH
70063: LD_VAR 0 8
70067: PLUS
70068: EQUAL
70069: IFFALSE 70114
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
70071: LD_ADDR_VAR 0 2
70075: PUSH
70076: LD_VAR 0 2
70080: PPUSH
70081: LD_INT 2
70083: PPUSH
70084: LD_VAR 0 2
70088: PUSH
70089: LD_INT 2
70091: ARRAY
70092: PPUSH
70093: LD_INT 1
70095: PPUSH
70096: CALL_OW 3
70100: PPUSH
70101: CALL_OW 1
70105: ST_TO_ADDR
// tmp := 1 ;
70106: LD_ADDR_VAR 0 3
70110: PUSH
70111: LD_STRING 1
70113: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
70114: LD_ADDR_VAR 0 6
70118: PUSH
70119: LD_VAR 0 6
70123: PUSH
70124: LD_VAR 0 3
70128: STR
70129: ST_TO_ADDR
// end ;
70130: GO 70026
70132: POP
70133: POP
// if isGameLoad then
70134: LD_VAR 0 1
70138: IFFALSE 70613
// begin flags := [ sRocket , sSpeed , sEngine , sSpec , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sKamikadze , sTroll , sSlow , sLack , sTank , sRemote , sPowell , sTeleport , sOilTower , sShovel , sSheik , sEarthquake , sAI , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sSold , sDiff , sFog , sReset , sSun , sTiger , sBomb , sWound , sBetray , sContamin , sOil , sStu , sBazooka , sMortar , sRanger , sComputer , s30 , s60 ] ;
70140: LD_ADDR_VAR 0 4
70144: PUSH
70145: LD_EXP 102
70149: PUSH
70150: LD_EXP 101
70154: PUSH
70155: LD_EXP 103
70159: PUSH
70160: LD_EXP 100
70164: PUSH
70165: LD_EXP 104
70169: PUSH
70170: LD_EXP 105
70174: PUSH
70175: LD_EXP 106
70179: PUSH
70180: LD_EXP 107
70184: PUSH
70185: LD_EXP 108
70189: PUSH
70190: LD_EXP 109
70194: PUSH
70195: LD_EXP 110
70199: PUSH
70200: LD_EXP 111
70204: PUSH
70205: LD_EXP 112
70209: PUSH
70210: LD_EXP 113
70214: PUSH
70215: LD_EXP 121
70219: PUSH
70220: LD_EXP 122
70224: PUSH
70225: LD_EXP 123
70229: PUSH
70230: LD_EXP 124
70234: PUSH
70235: LD_EXP 126
70239: PUSH
70240: LD_EXP 127
70244: PUSH
70245: LD_EXP 128
70249: PUSH
70250: LD_EXP 131
70254: PUSH
70255: LD_EXP 133
70259: PUSH
70260: LD_EXP 134
70264: PUSH
70265: LD_EXP 135
70269: PUSH
70270: LD_EXP 137
70274: PUSH
70275: LD_EXP 138
70279: PUSH
70280: LD_EXP 141
70284: PUSH
70285: LD_EXP 142
70289: PUSH
70290: LD_EXP 143
70294: PUSH
70295: LD_EXP 144
70299: PUSH
70300: LD_EXP 145
70304: PUSH
70305: LD_EXP 146
70309: PUSH
70310: LD_EXP 147
70314: PUSH
70315: LD_EXP 148
70319: PUSH
70320: LD_EXP 149
70324: PUSH
70325: LD_EXP 114
70329: PUSH
70330: LD_EXP 115
70334: PUSH
70335: LD_EXP 118
70339: PUSH
70340: LD_EXP 119
70344: PUSH
70345: LD_EXP 120
70349: PUSH
70350: LD_EXP 116
70354: PUSH
70355: LD_EXP 117
70359: PUSH
70360: LD_EXP 125
70364: PUSH
70365: LD_EXP 129
70369: PUSH
70370: LD_EXP 130
70374: PUSH
70375: LD_EXP 132
70379: PUSH
70380: LD_EXP 136
70384: PUSH
70385: LD_EXP 139
70389: PUSH
70390: LD_EXP 140
70394: PUSH
70395: LD_EXP 150
70399: PUSH
70400: LD_EXP 151
70404: PUSH
70405: LD_EXP 152
70409: PUSH
70410: LD_EXP 153
70414: PUSH
70415: EMPTY
70416: LIST
70417: LIST
70418: LIST
70419: LIST
70420: LIST
70421: LIST
70422: LIST
70423: LIST
70424: LIST
70425: LIST
70426: LIST
70427: LIST
70428: LIST
70429: LIST
70430: LIST
70431: LIST
70432: LIST
70433: LIST
70434: LIST
70435: LIST
70436: LIST
70437: LIST
70438: LIST
70439: LIST
70440: LIST
70441: LIST
70442: LIST
70443: LIST
70444: LIST
70445: LIST
70446: LIST
70447: LIST
70448: LIST
70449: LIST
70450: LIST
70451: LIST
70452: LIST
70453: LIST
70454: LIST
70455: LIST
70456: LIST
70457: LIST
70458: LIST
70459: LIST
70460: LIST
70461: LIST
70462: LIST
70463: LIST
70464: LIST
70465: LIST
70466: LIST
70467: LIST
70468: LIST
70469: LIST
70470: ST_TO_ADDR
// tmp :=  ;
70471: LD_ADDR_VAR 0 3
70475: PUSH
70476: LD_STRING 
70478: ST_TO_ADDR
// for i = 1 to normalCounter do
70479: LD_ADDR_VAR 0 8
70483: PUSH
70484: DOUBLE
70485: LD_INT 1
70487: DEC
70488: ST_TO_ADDR
70489: LD_EXP 98
70493: PUSH
70494: FOR_TO
70495: IFFALSE 70531
// begin if flags [ i ] then
70497: LD_VAR 0 4
70501: PUSH
70502: LD_VAR 0 8
70506: ARRAY
70507: IFFALSE 70529
// tmp := tmp & i & ; ;
70509: LD_ADDR_VAR 0 3
70513: PUSH
70514: LD_VAR 0 3
70518: PUSH
70519: LD_VAR 0 8
70523: STR
70524: PUSH
70525: LD_STRING ;
70527: STR
70528: ST_TO_ADDR
// end ;
70529: GO 70494
70531: POP
70532: POP
// for i = 1 to hardcoreCounter do
70533: LD_ADDR_VAR 0 8
70537: PUSH
70538: DOUBLE
70539: LD_INT 1
70541: DEC
70542: ST_TO_ADDR
70543: LD_EXP 99
70547: PUSH
70548: FOR_TO
70549: IFFALSE 70595
// begin if flags [ normalCounter + i ] then
70551: LD_VAR 0 4
70555: PUSH
70556: LD_EXP 98
70560: PUSH
70561: LD_VAR 0 8
70565: PLUS
70566: ARRAY
70567: IFFALSE 70593
// tmp := tmp & ( 100 + i ) & ; ;
70569: LD_ADDR_VAR 0 3
70573: PUSH
70574: LD_VAR 0 3
70578: PUSH
70579: LD_INT 100
70581: PUSH
70582: LD_VAR 0 8
70586: PLUS
70587: STR
70588: PUSH
70589: LD_STRING ;
70591: STR
70592: ST_TO_ADDR
// end ;
70593: GO 70548
70595: POP
70596: POP
// if tmp then
70597: LD_VAR 0 3
70601: IFFALSE 70613
// active := tmp ;
70603: LD_ADDR_VAR 0 7
70607: PUSH
70608: LD_VAR 0 3
70612: ST_TO_ADDR
// end ; ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & "," & active & ") ) ;
70613: LD_STRING getStreamItemsFromMission("
70615: PUSH
70616: LD_VAR 0 5
70620: STR
70621: PUSH
70622: LD_STRING ","
70624: STR
70625: PUSH
70626: LD_VAR 0 6
70630: STR
70631: PUSH
70632: LD_STRING ","
70634: STR
70635: PUSH
70636: LD_VAR 0 7
70640: STR
70641: PUSH
70642: LD_STRING ")
70644: STR
70645: PPUSH
70646: CALL_OW 559
// end else
70650: GO 70659
// ToLua ( getStreamItemsFromMission("","","") ) ;
70652: LD_STRING getStreamItemsFromMission("","","")
70654: PPUSH
70655: CALL_OW 559
// end ;
70659: LD_VAR 0 2
70663: RET
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
70664: LD_EXP 97
70668: PUSH
70669: LD_EXP 102
70673: AND
70674: IFFALSE 70798
70676: GO 70678
70678: DISABLE
70679: LD_INT 0
70681: PPUSH
70682: PPUSH
// begin enable ;
70683: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
70684: LD_ADDR_VAR 0 2
70688: PUSH
70689: LD_INT 22
70691: PUSH
70692: LD_OWVAR 2
70696: PUSH
70697: EMPTY
70698: LIST
70699: LIST
70700: PUSH
70701: LD_INT 2
70703: PUSH
70704: LD_INT 34
70706: PUSH
70707: LD_INT 7
70709: PUSH
70710: EMPTY
70711: LIST
70712: LIST
70713: PUSH
70714: LD_INT 34
70716: PUSH
70717: LD_INT 45
70719: PUSH
70720: EMPTY
70721: LIST
70722: LIST
70723: PUSH
70724: LD_INT 34
70726: PUSH
70727: LD_INT 28
70729: PUSH
70730: EMPTY
70731: LIST
70732: LIST
70733: PUSH
70734: LD_INT 34
70736: PUSH
70737: LD_INT 47
70739: PUSH
70740: EMPTY
70741: LIST
70742: LIST
70743: PUSH
70744: EMPTY
70745: LIST
70746: LIST
70747: LIST
70748: LIST
70749: LIST
70750: PUSH
70751: EMPTY
70752: LIST
70753: LIST
70754: PPUSH
70755: CALL_OW 69
70759: ST_TO_ADDR
// if not tmp then
70760: LD_VAR 0 2
70764: NOT
70765: IFFALSE 70769
// exit ;
70767: GO 70798
// for i in tmp do
70769: LD_ADDR_VAR 0 1
70773: PUSH
70774: LD_VAR 0 2
70778: PUSH
70779: FOR_IN
70780: IFFALSE 70796
// begin SetLives ( i , 0 ) ;
70782: LD_VAR 0 1
70786: PPUSH
70787: LD_INT 0
70789: PPUSH
70790: CALL_OW 234
// end ;
70794: GO 70779
70796: POP
70797: POP
// end ;
70798: PPOPN 2
70800: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
70801: LD_EXP 97
70805: PUSH
70806: LD_EXP 103
70810: AND
70811: IFFALSE 70895
70813: GO 70815
70815: DISABLE
70816: LD_INT 0
70818: PPUSH
70819: PPUSH
// begin enable ;
70820: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
70821: LD_ADDR_VAR 0 2
70825: PUSH
70826: LD_INT 22
70828: PUSH
70829: LD_OWVAR 2
70833: PUSH
70834: EMPTY
70835: LIST
70836: LIST
70837: PUSH
70838: LD_INT 32
70840: PUSH
70841: LD_INT 3
70843: PUSH
70844: EMPTY
70845: LIST
70846: LIST
70847: PUSH
70848: EMPTY
70849: LIST
70850: LIST
70851: PPUSH
70852: CALL_OW 69
70856: ST_TO_ADDR
// if not tmp then
70857: LD_VAR 0 2
70861: NOT
70862: IFFALSE 70866
// exit ;
70864: GO 70895
// for i in tmp do
70866: LD_ADDR_VAR 0 1
70870: PUSH
70871: LD_VAR 0 2
70875: PUSH
70876: FOR_IN
70877: IFFALSE 70893
// begin SetLives ( i , 0 ) ;
70879: LD_VAR 0 1
70883: PPUSH
70884: LD_INT 0
70886: PPUSH
70887: CALL_OW 234
// end ;
70891: GO 70876
70893: POP
70894: POP
// end ;
70895: PPOPN 2
70897: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
70898: LD_EXP 97
70902: PUSH
70903: LD_EXP 100
70907: AND
70908: IFFALSE 71001
70910: GO 70912
70912: DISABLE
70913: LD_INT 0
70915: PPUSH
// begin enable ;
70916: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
70917: LD_ADDR_VAR 0 1
70921: PUSH
70922: LD_INT 22
70924: PUSH
70925: LD_OWVAR 2
70929: PUSH
70930: EMPTY
70931: LIST
70932: LIST
70933: PUSH
70934: LD_INT 2
70936: PUSH
70937: LD_INT 25
70939: PUSH
70940: LD_INT 5
70942: PUSH
70943: EMPTY
70944: LIST
70945: LIST
70946: PUSH
70947: LD_INT 25
70949: PUSH
70950: LD_INT 9
70952: PUSH
70953: EMPTY
70954: LIST
70955: LIST
70956: PUSH
70957: LD_INT 25
70959: PUSH
70960: LD_INT 8
70962: PUSH
70963: EMPTY
70964: LIST
70965: LIST
70966: PUSH
70967: EMPTY
70968: LIST
70969: LIST
70970: LIST
70971: LIST
70972: PUSH
70973: EMPTY
70974: LIST
70975: LIST
70976: PPUSH
70977: CALL_OW 69
70981: PUSH
70982: FOR_IN
70983: IFFALSE 70999
// begin SetClass ( i , 1 ) ;
70985: LD_VAR 0 1
70989: PPUSH
70990: LD_INT 1
70992: PPUSH
70993: CALL_OW 336
// end ;
70997: GO 70982
70999: POP
71000: POP
// end ;
71001: PPOPN 1
71003: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
71004: LD_EXP 97
71008: PUSH
71009: LD_EXP 101
71013: AND
71014: PUSH
71015: LD_OWVAR 65
71019: PUSH
71020: LD_INT 7
71022: LESS
71023: AND
71024: IFFALSE 71038
71026: GO 71028
71028: DISABLE
// begin enable ;
71029: ENABLE
// game_speed := 7 ;
71030: LD_ADDR_OWVAR 65
71034: PUSH
71035: LD_INT 7
71037: ST_TO_ADDR
// end ;
71038: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
71039: LD_EXP 97
71043: PUSH
71044: LD_EXP 104
71048: AND
71049: IFFALSE 71251
71051: GO 71053
71053: DISABLE
71054: LD_INT 0
71056: PPUSH
71057: PPUSH
71058: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
71059: LD_ADDR_VAR 0 3
71063: PUSH
71064: LD_INT 81
71066: PUSH
71067: LD_OWVAR 2
71071: PUSH
71072: EMPTY
71073: LIST
71074: LIST
71075: PUSH
71076: LD_INT 21
71078: PUSH
71079: LD_INT 1
71081: PUSH
71082: EMPTY
71083: LIST
71084: LIST
71085: PUSH
71086: EMPTY
71087: LIST
71088: LIST
71089: PPUSH
71090: CALL_OW 69
71094: ST_TO_ADDR
// if not tmp then
71095: LD_VAR 0 3
71099: NOT
71100: IFFALSE 71104
// exit ;
71102: GO 71251
// if tmp > 5 then
71104: LD_VAR 0 3
71108: PUSH
71109: LD_INT 5
71111: GREATER
71112: IFFALSE 71124
// k := 5 else
71114: LD_ADDR_VAR 0 2
71118: PUSH
71119: LD_INT 5
71121: ST_TO_ADDR
71122: GO 71134
// k := tmp ;
71124: LD_ADDR_VAR 0 2
71128: PUSH
71129: LD_VAR 0 3
71133: ST_TO_ADDR
// for i := 1 to k do
71134: LD_ADDR_VAR 0 1
71138: PUSH
71139: DOUBLE
71140: LD_INT 1
71142: DEC
71143: ST_TO_ADDR
71144: LD_VAR 0 2
71148: PUSH
71149: FOR_TO
71150: IFFALSE 71249
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
71152: LD_VAR 0 3
71156: PUSH
71157: LD_VAR 0 1
71161: ARRAY
71162: PPUSH
71163: LD_VAR 0 1
71167: PUSH
71168: LD_INT 4
71170: MOD
71171: PUSH
71172: LD_INT 1
71174: PLUS
71175: PPUSH
71176: CALL_OW 259
71180: PUSH
71181: LD_INT 10
71183: LESS
71184: IFFALSE 71247
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
71186: LD_VAR 0 3
71190: PUSH
71191: LD_VAR 0 1
71195: ARRAY
71196: PPUSH
71197: LD_VAR 0 1
71201: PUSH
71202: LD_INT 4
71204: MOD
71205: PUSH
71206: LD_INT 1
71208: PLUS
71209: PPUSH
71210: LD_VAR 0 3
71214: PUSH
71215: LD_VAR 0 1
71219: ARRAY
71220: PPUSH
71221: LD_VAR 0 1
71225: PUSH
71226: LD_INT 4
71228: MOD
71229: PUSH
71230: LD_INT 1
71232: PLUS
71233: PPUSH
71234: CALL_OW 259
71238: PUSH
71239: LD_INT 1
71241: PLUS
71242: PPUSH
71243: CALL_OW 237
71247: GO 71149
71249: POP
71250: POP
// end ;
71251: PPOPN 3
71253: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
71254: LD_EXP 97
71258: PUSH
71259: LD_EXP 105
71263: AND
71264: IFFALSE 71284
71266: GO 71268
71268: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
71269: LD_INT 4
71271: PPUSH
71272: LD_OWVAR 2
71276: PPUSH
71277: LD_INT 0
71279: PPUSH
71280: CALL_OW 324
71284: END
// every 0 0$1 trigger StreamModeActive and sShovel do
71285: LD_EXP 97
71289: PUSH
71290: LD_EXP 134
71294: AND
71295: IFFALSE 71315
71297: GO 71299
71299: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
71300: LD_INT 19
71302: PPUSH
71303: LD_OWVAR 2
71307: PPUSH
71308: LD_INT 0
71310: PPUSH
71311: CALL_OW 324
71315: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
71316: LD_EXP 97
71320: PUSH
71321: LD_EXP 106
71325: AND
71326: IFFALSE 71428
71328: GO 71330
71330: DISABLE
71331: LD_INT 0
71333: PPUSH
71334: PPUSH
// begin enable ;
71335: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
71336: LD_ADDR_VAR 0 2
71340: PUSH
71341: LD_INT 22
71343: PUSH
71344: LD_OWVAR 2
71348: PUSH
71349: EMPTY
71350: LIST
71351: LIST
71352: PUSH
71353: LD_INT 2
71355: PUSH
71356: LD_INT 34
71358: PUSH
71359: LD_INT 11
71361: PUSH
71362: EMPTY
71363: LIST
71364: LIST
71365: PUSH
71366: LD_INT 34
71368: PUSH
71369: LD_INT 30
71371: PUSH
71372: EMPTY
71373: LIST
71374: LIST
71375: PUSH
71376: EMPTY
71377: LIST
71378: LIST
71379: LIST
71380: PUSH
71381: EMPTY
71382: LIST
71383: LIST
71384: PPUSH
71385: CALL_OW 69
71389: ST_TO_ADDR
// if not tmp then
71390: LD_VAR 0 2
71394: NOT
71395: IFFALSE 71399
// exit ;
71397: GO 71428
// for i in tmp do
71399: LD_ADDR_VAR 0 1
71403: PUSH
71404: LD_VAR 0 2
71408: PUSH
71409: FOR_IN
71410: IFFALSE 71426
// begin SetLives ( i , 0 ) ;
71412: LD_VAR 0 1
71416: PPUSH
71417: LD_INT 0
71419: PPUSH
71420: CALL_OW 234
// end ;
71424: GO 71409
71426: POP
71427: POP
// end ;
71428: PPOPN 2
71430: END
// every 0 0$1 trigger StreamModeActive and sBunker do
71431: LD_EXP 97
71435: PUSH
71436: LD_EXP 107
71440: AND
71441: IFFALSE 71461
71443: GO 71445
71445: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
71446: LD_INT 32
71448: PPUSH
71449: LD_OWVAR 2
71453: PPUSH
71454: LD_INT 0
71456: PPUSH
71457: CALL_OW 324
71461: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
71462: LD_EXP 97
71466: PUSH
71467: LD_EXP 108
71471: AND
71472: IFFALSE 71653
71474: GO 71476
71476: DISABLE
71477: LD_INT 0
71479: PPUSH
71480: PPUSH
71481: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
71482: LD_ADDR_VAR 0 2
71486: PUSH
71487: LD_INT 22
71489: PUSH
71490: LD_OWVAR 2
71494: PUSH
71495: EMPTY
71496: LIST
71497: LIST
71498: PUSH
71499: LD_INT 33
71501: PUSH
71502: LD_INT 3
71504: PUSH
71505: EMPTY
71506: LIST
71507: LIST
71508: PUSH
71509: EMPTY
71510: LIST
71511: LIST
71512: PPUSH
71513: CALL_OW 69
71517: ST_TO_ADDR
// if not tmp then
71518: LD_VAR 0 2
71522: NOT
71523: IFFALSE 71527
// exit ;
71525: GO 71653
// side := 0 ;
71527: LD_ADDR_VAR 0 3
71531: PUSH
71532: LD_INT 0
71534: ST_TO_ADDR
// for i := 1 to 8 do
71535: LD_ADDR_VAR 0 1
71539: PUSH
71540: DOUBLE
71541: LD_INT 1
71543: DEC
71544: ST_TO_ADDR
71545: LD_INT 8
71547: PUSH
71548: FOR_TO
71549: IFFALSE 71597
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
71551: LD_OWVAR 2
71555: PUSH
71556: LD_VAR 0 1
71560: NONEQUAL
71561: PUSH
71562: LD_OWVAR 2
71566: PPUSH
71567: LD_VAR 0 1
71571: PPUSH
71572: CALL_OW 81
71576: PUSH
71577: LD_INT 2
71579: EQUAL
71580: AND
71581: IFFALSE 71595
// begin side := i ;
71583: LD_ADDR_VAR 0 3
71587: PUSH
71588: LD_VAR 0 1
71592: ST_TO_ADDR
// break ;
71593: GO 71597
// end ;
71595: GO 71548
71597: POP
71598: POP
// if not side then
71599: LD_VAR 0 3
71603: NOT
71604: IFFALSE 71608
// exit ;
71606: GO 71653
// for i := 1 to tmp do
71608: LD_ADDR_VAR 0 1
71612: PUSH
71613: DOUBLE
71614: LD_INT 1
71616: DEC
71617: ST_TO_ADDR
71618: LD_VAR 0 2
71622: PUSH
71623: FOR_TO
71624: IFFALSE 71651
// if Prob ( 60 ) then
71626: LD_INT 60
71628: PPUSH
71629: CALL_OW 13
71633: IFFALSE 71649
// SetSide ( i , side ) ;
71635: LD_VAR 0 1
71639: PPUSH
71640: LD_VAR 0 3
71644: PPUSH
71645: CALL_OW 235
71649: GO 71623
71651: POP
71652: POP
// end ;
71653: PPOPN 3
71655: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
71656: LD_EXP 97
71660: PUSH
71661: LD_EXP 110
71665: AND
71666: IFFALSE 71785
71668: GO 71670
71670: DISABLE
71671: LD_INT 0
71673: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
71674: LD_ADDR_VAR 0 1
71678: PUSH
71679: LD_INT 22
71681: PUSH
71682: LD_OWVAR 2
71686: PUSH
71687: EMPTY
71688: LIST
71689: LIST
71690: PUSH
71691: LD_INT 21
71693: PUSH
71694: LD_INT 1
71696: PUSH
71697: EMPTY
71698: LIST
71699: LIST
71700: PUSH
71701: LD_INT 3
71703: PUSH
71704: LD_INT 23
71706: PUSH
71707: LD_INT 0
71709: PUSH
71710: EMPTY
71711: LIST
71712: LIST
71713: PUSH
71714: EMPTY
71715: LIST
71716: LIST
71717: PUSH
71718: EMPTY
71719: LIST
71720: LIST
71721: LIST
71722: PPUSH
71723: CALL_OW 69
71727: PUSH
71728: FOR_IN
71729: IFFALSE 71783
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
71731: LD_VAR 0 1
71735: PPUSH
71736: CALL_OW 257
71740: PUSH
71741: LD_INT 1
71743: PUSH
71744: LD_INT 2
71746: PUSH
71747: LD_INT 3
71749: PUSH
71750: LD_INT 4
71752: PUSH
71753: EMPTY
71754: LIST
71755: LIST
71756: LIST
71757: LIST
71758: IN
71759: IFFALSE 71781
// SetClass ( un , rand ( 1 , 4 ) ) ;
71761: LD_VAR 0 1
71765: PPUSH
71766: LD_INT 1
71768: PPUSH
71769: LD_INT 4
71771: PPUSH
71772: CALL_OW 12
71776: PPUSH
71777: CALL_OW 336
71781: GO 71728
71783: POP
71784: POP
// end ;
71785: PPOPN 1
71787: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
71788: LD_EXP 97
71792: PUSH
71793: LD_EXP 109
71797: AND
71798: IFFALSE 71877
71800: GO 71802
71802: DISABLE
71803: LD_INT 0
71805: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
71806: LD_ADDR_VAR 0 1
71810: PUSH
71811: LD_INT 22
71813: PUSH
71814: LD_OWVAR 2
71818: PUSH
71819: EMPTY
71820: LIST
71821: LIST
71822: PUSH
71823: LD_INT 21
71825: PUSH
71826: LD_INT 3
71828: PUSH
71829: EMPTY
71830: LIST
71831: LIST
71832: PUSH
71833: EMPTY
71834: LIST
71835: LIST
71836: PPUSH
71837: CALL_OW 69
71841: ST_TO_ADDR
// if not tmp then
71842: LD_VAR 0 1
71846: NOT
71847: IFFALSE 71851
// exit ;
71849: GO 71877
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
71851: LD_VAR 0 1
71855: PUSH
71856: LD_INT 1
71858: PPUSH
71859: LD_VAR 0 1
71863: PPUSH
71864: CALL_OW 12
71868: ARRAY
71869: PPUSH
71870: LD_INT 100
71872: PPUSH
71873: CALL_OW 234
// end ;
71877: PPOPN 1
71879: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
71880: LD_EXP 97
71884: PUSH
71885: LD_EXP 111
71889: AND
71890: IFFALSE 71988
71892: GO 71894
71894: DISABLE
71895: LD_INT 0
71897: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
71898: LD_ADDR_VAR 0 1
71902: PUSH
71903: LD_INT 22
71905: PUSH
71906: LD_OWVAR 2
71910: PUSH
71911: EMPTY
71912: LIST
71913: LIST
71914: PUSH
71915: LD_INT 21
71917: PUSH
71918: LD_INT 1
71920: PUSH
71921: EMPTY
71922: LIST
71923: LIST
71924: PUSH
71925: EMPTY
71926: LIST
71927: LIST
71928: PPUSH
71929: CALL_OW 69
71933: ST_TO_ADDR
// if not tmp then
71934: LD_VAR 0 1
71938: NOT
71939: IFFALSE 71943
// exit ;
71941: GO 71988
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
71943: LD_VAR 0 1
71947: PUSH
71948: LD_INT 1
71950: PPUSH
71951: LD_VAR 0 1
71955: PPUSH
71956: CALL_OW 12
71960: ARRAY
71961: PPUSH
71962: LD_INT 1
71964: PPUSH
71965: LD_INT 4
71967: PPUSH
71968: CALL_OW 12
71972: PPUSH
71973: LD_INT 3000
71975: PPUSH
71976: LD_INT 9000
71978: PPUSH
71979: CALL_OW 12
71983: PPUSH
71984: CALL_OW 492
// end ;
71988: PPOPN 1
71990: END
// every 0 0$1 trigger StreamModeActive and sDepot do
71991: LD_EXP 97
71995: PUSH
71996: LD_EXP 112
72000: AND
72001: IFFALSE 72021
72003: GO 72005
72005: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
72006: LD_INT 1
72008: PPUSH
72009: LD_OWVAR 2
72013: PPUSH
72014: LD_INT 0
72016: PPUSH
72017: CALL_OW 324
72021: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
72022: LD_EXP 97
72026: PUSH
72027: LD_EXP 113
72031: AND
72032: IFFALSE 72115
72034: GO 72036
72036: DISABLE
72037: LD_INT 0
72039: PPUSH
72040: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
72041: LD_ADDR_VAR 0 2
72045: PUSH
72046: LD_INT 22
72048: PUSH
72049: LD_OWVAR 2
72053: PUSH
72054: EMPTY
72055: LIST
72056: LIST
72057: PUSH
72058: LD_INT 21
72060: PUSH
72061: LD_INT 3
72063: PUSH
72064: EMPTY
72065: LIST
72066: LIST
72067: PUSH
72068: EMPTY
72069: LIST
72070: LIST
72071: PPUSH
72072: CALL_OW 69
72076: ST_TO_ADDR
// if not tmp then
72077: LD_VAR 0 2
72081: NOT
72082: IFFALSE 72086
// exit ;
72084: GO 72115
// for i in tmp do
72086: LD_ADDR_VAR 0 1
72090: PUSH
72091: LD_VAR 0 2
72095: PUSH
72096: FOR_IN
72097: IFFALSE 72113
// SetBLevel ( i , 10 ) ;
72099: LD_VAR 0 1
72103: PPUSH
72104: LD_INT 10
72106: PPUSH
72107: CALL_OW 241
72111: GO 72096
72113: POP
72114: POP
// end ;
72115: PPOPN 2
72117: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
72118: LD_EXP 97
72122: PUSH
72123: LD_EXP 114
72127: AND
72128: IFFALSE 72239
72130: GO 72132
72132: DISABLE
72133: LD_INT 0
72135: PPUSH
72136: PPUSH
72137: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
72138: LD_ADDR_VAR 0 3
72142: PUSH
72143: LD_INT 22
72145: PUSH
72146: LD_OWVAR 2
72150: PUSH
72151: EMPTY
72152: LIST
72153: LIST
72154: PUSH
72155: LD_INT 25
72157: PUSH
72158: LD_INT 1
72160: PUSH
72161: EMPTY
72162: LIST
72163: LIST
72164: PUSH
72165: EMPTY
72166: LIST
72167: LIST
72168: PPUSH
72169: CALL_OW 69
72173: ST_TO_ADDR
// if not tmp then
72174: LD_VAR 0 3
72178: NOT
72179: IFFALSE 72183
// exit ;
72181: GO 72239
// un := tmp [ rand ( 1 , tmp ) ] ;
72183: LD_ADDR_VAR 0 2
72187: PUSH
72188: LD_VAR 0 3
72192: PUSH
72193: LD_INT 1
72195: PPUSH
72196: LD_VAR 0 3
72200: PPUSH
72201: CALL_OW 12
72205: ARRAY
72206: ST_TO_ADDR
// if Crawls ( un ) then
72207: LD_VAR 0 2
72211: PPUSH
72212: CALL_OW 318
72216: IFFALSE 72227
// ComWalk ( un ) ;
72218: LD_VAR 0 2
72222: PPUSH
72223: CALL_OW 138
// SetClass ( un , class_sniper ) ;
72227: LD_VAR 0 2
72231: PPUSH
72232: LD_INT 5
72234: PPUSH
72235: CALL_OW 336
// end ;
72239: PPOPN 3
72241: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 4 do
72242: LD_EXP 97
72246: PUSH
72247: LD_EXP 115
72251: AND
72252: PUSH
72253: LD_OWVAR 67
72257: PUSH
72258: LD_INT 4
72260: LESS
72261: AND
72262: IFFALSE 72281
72264: GO 72266
72266: DISABLE
// begin Difficulty := Difficulty + 1 ;
72267: LD_ADDR_OWVAR 67
72271: PUSH
72272: LD_OWVAR 67
72276: PUSH
72277: LD_INT 1
72279: PLUS
72280: ST_TO_ADDR
// end ;
72281: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
72282: LD_EXP 97
72286: PUSH
72287: LD_EXP 116
72291: AND
72292: IFFALSE 72395
72294: GO 72296
72296: DISABLE
72297: LD_INT 0
72299: PPUSH
// begin for i := 1 to 5 do
72300: LD_ADDR_VAR 0 1
72304: PUSH
72305: DOUBLE
72306: LD_INT 1
72308: DEC
72309: ST_TO_ADDR
72310: LD_INT 5
72312: PUSH
72313: FOR_TO
72314: IFFALSE 72393
// begin uc_nation := nation_nature ;
72316: LD_ADDR_OWVAR 21
72320: PUSH
72321: LD_INT 0
72323: ST_TO_ADDR
// uc_side := 0 ;
72324: LD_ADDR_OWVAR 20
72328: PUSH
72329: LD_INT 0
72331: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
72332: LD_ADDR_OWVAR 29
72336: PUSH
72337: LD_INT 12
72339: PUSH
72340: LD_INT 12
72342: PUSH
72343: EMPTY
72344: LIST
72345: LIST
72346: ST_TO_ADDR
// hc_agressivity := 20 ;
72347: LD_ADDR_OWVAR 35
72351: PUSH
72352: LD_INT 20
72354: ST_TO_ADDR
// hc_class := class_tiger ;
72355: LD_ADDR_OWVAR 28
72359: PUSH
72360: LD_INT 14
72362: ST_TO_ADDR
// hc_gallery :=  ;
72363: LD_ADDR_OWVAR 33
72367: PUSH
72368: LD_STRING 
72370: ST_TO_ADDR
// hc_name :=  ;
72371: LD_ADDR_OWVAR 26
72375: PUSH
72376: LD_STRING 
72378: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
72379: CALL_OW 44
72383: PPUSH
72384: LD_INT 0
72386: PPUSH
72387: CALL_OW 51
// end ;
72391: GO 72313
72393: POP
72394: POP
// end ;
72395: PPOPN 1
72397: END
// every 0 0$1 trigger StreamModeActive and sBomb do
72398: LD_EXP 97
72402: PUSH
72403: LD_EXP 117
72407: AND
72408: IFFALSE 72417
72410: GO 72412
72412: DISABLE
// StreamSibBomb ;
72413: CALL 72418 0 0
72417: END
// export function StreamSibBomb ; var i , x , y ; begin
72418: LD_INT 0
72420: PPUSH
72421: PPUSH
72422: PPUSH
72423: PPUSH
// result := false ;
72424: LD_ADDR_VAR 0 1
72428: PUSH
72429: LD_INT 0
72431: ST_TO_ADDR
// for i := 1 to 16 do
72432: LD_ADDR_VAR 0 2
72436: PUSH
72437: DOUBLE
72438: LD_INT 1
72440: DEC
72441: ST_TO_ADDR
72442: LD_INT 16
72444: PUSH
72445: FOR_TO
72446: IFFALSE 72645
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
72448: LD_ADDR_VAR 0 3
72452: PUSH
72453: LD_INT 10
72455: PUSH
72456: LD_INT 20
72458: PUSH
72459: LD_INT 30
72461: PUSH
72462: LD_INT 40
72464: PUSH
72465: LD_INT 50
72467: PUSH
72468: LD_INT 60
72470: PUSH
72471: LD_INT 70
72473: PUSH
72474: LD_INT 80
72476: PUSH
72477: LD_INT 90
72479: PUSH
72480: LD_INT 100
72482: PUSH
72483: LD_INT 110
72485: PUSH
72486: LD_INT 120
72488: PUSH
72489: LD_INT 130
72491: PUSH
72492: LD_INT 140
72494: PUSH
72495: LD_INT 150
72497: PUSH
72498: EMPTY
72499: LIST
72500: LIST
72501: LIST
72502: LIST
72503: LIST
72504: LIST
72505: LIST
72506: LIST
72507: LIST
72508: LIST
72509: LIST
72510: LIST
72511: LIST
72512: LIST
72513: LIST
72514: PUSH
72515: LD_INT 1
72517: PPUSH
72518: LD_INT 15
72520: PPUSH
72521: CALL_OW 12
72525: ARRAY
72526: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
72527: LD_ADDR_VAR 0 4
72531: PUSH
72532: LD_INT 10
72534: PUSH
72535: LD_INT 20
72537: PUSH
72538: LD_INT 30
72540: PUSH
72541: LD_INT 40
72543: PUSH
72544: LD_INT 50
72546: PUSH
72547: LD_INT 60
72549: PUSH
72550: LD_INT 70
72552: PUSH
72553: LD_INT 80
72555: PUSH
72556: LD_INT 90
72558: PUSH
72559: LD_INT 100
72561: PUSH
72562: LD_INT 110
72564: PUSH
72565: LD_INT 120
72567: PUSH
72568: LD_INT 130
72570: PUSH
72571: LD_INT 140
72573: PUSH
72574: LD_INT 150
72576: PUSH
72577: EMPTY
72578: LIST
72579: LIST
72580: LIST
72581: LIST
72582: LIST
72583: LIST
72584: LIST
72585: LIST
72586: LIST
72587: LIST
72588: LIST
72589: LIST
72590: LIST
72591: LIST
72592: LIST
72593: PUSH
72594: LD_INT 1
72596: PPUSH
72597: LD_INT 15
72599: PPUSH
72600: CALL_OW 12
72604: ARRAY
72605: ST_TO_ADDR
// if ValidHex ( x , y ) then
72606: LD_VAR 0 3
72610: PPUSH
72611: LD_VAR 0 4
72615: PPUSH
72616: CALL_OW 488
72620: IFFALSE 72643
// begin result := [ x , y ] ;
72622: LD_ADDR_VAR 0 1
72626: PUSH
72627: LD_VAR 0 3
72631: PUSH
72632: LD_VAR 0 4
72636: PUSH
72637: EMPTY
72638: LIST
72639: LIST
72640: ST_TO_ADDR
// break ;
72641: GO 72645
// end ; end ;
72643: GO 72445
72645: POP
72646: POP
// if result then
72647: LD_VAR 0 1
72651: IFFALSE 72711
// begin ToLua ( playSibBomb() ) ;
72653: LD_STRING playSibBomb()
72655: PPUSH
72656: CALL_OW 559
// wait ( 0 0$14 ) ;
72660: LD_INT 490
72662: PPUSH
72663: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
72667: LD_VAR 0 1
72671: PUSH
72672: LD_INT 1
72674: ARRAY
72675: PPUSH
72676: LD_VAR 0 1
72680: PUSH
72681: LD_INT 2
72683: ARRAY
72684: PPUSH
72685: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
72689: LD_VAR 0 1
72693: PUSH
72694: LD_INT 1
72696: ARRAY
72697: PPUSH
72698: LD_VAR 0 1
72702: PUSH
72703: LD_INT 2
72705: ARRAY
72706: PPUSH
72707: CALL_OW 429
// end ; end ;
72711: LD_VAR 0 1
72715: RET
// every 0 0$1 trigger StreamModeActive and sReset do
72716: LD_EXP 97
72720: PUSH
72721: LD_EXP 119
72725: AND
72726: IFFALSE 72738
72728: GO 72730
72730: DISABLE
// YouLost (  ) ;
72731: LD_STRING 
72733: PPUSH
72734: CALL_OW 104
72738: END
// every 0 0$1 trigger StreamModeActive and sFog do
72739: LD_EXP 97
72743: PUSH
72744: LD_EXP 118
72748: AND
72749: IFFALSE 72763
72751: GO 72753
72753: DISABLE
// FogOff ( your_side ) ;
72754: LD_OWVAR 2
72758: PPUSH
72759: CALL_OW 344
72763: END
// every 0 0$1 trigger StreamModeActive and sSun do
72764: LD_EXP 97
72768: PUSH
72769: LD_EXP 120
72773: AND
72774: IFFALSE 72802
72776: GO 72778
72778: DISABLE
// begin solar_recharge_percent := 0 ;
72779: LD_ADDR_OWVAR 79
72783: PUSH
72784: LD_INT 0
72786: ST_TO_ADDR
// wait ( 5 5$00 ) ;
72787: LD_INT 10500
72789: PPUSH
72790: CALL_OW 67
// solar_recharge_percent := 100 ;
72794: LD_ADDR_OWVAR 79
72798: PUSH
72799: LD_INT 100
72801: ST_TO_ADDR
// end ;
72802: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
72803: LD_EXP 97
72807: PUSH
72808: LD_EXP 121
72812: AND
72813: IFFALSE 73052
72815: GO 72817
72817: DISABLE
72818: LD_INT 0
72820: PPUSH
72821: PPUSH
72822: PPUSH
// begin tmp := [ ] ;
72823: LD_ADDR_VAR 0 3
72827: PUSH
72828: EMPTY
72829: ST_TO_ADDR
// for i := 1 to 6 do
72830: LD_ADDR_VAR 0 1
72834: PUSH
72835: DOUBLE
72836: LD_INT 1
72838: DEC
72839: ST_TO_ADDR
72840: LD_INT 6
72842: PUSH
72843: FOR_TO
72844: IFFALSE 72949
// begin uc_nation := nation_nature ;
72846: LD_ADDR_OWVAR 21
72850: PUSH
72851: LD_INT 0
72853: ST_TO_ADDR
// uc_side := 0 ;
72854: LD_ADDR_OWVAR 20
72858: PUSH
72859: LD_INT 0
72861: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
72862: LD_ADDR_OWVAR 29
72866: PUSH
72867: LD_INT 12
72869: PUSH
72870: LD_INT 12
72872: PUSH
72873: EMPTY
72874: LIST
72875: LIST
72876: ST_TO_ADDR
// hc_agressivity := 20 ;
72877: LD_ADDR_OWVAR 35
72881: PUSH
72882: LD_INT 20
72884: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
72885: LD_ADDR_OWVAR 28
72889: PUSH
72890: LD_INT 17
72892: ST_TO_ADDR
// hc_gallery :=  ;
72893: LD_ADDR_OWVAR 33
72897: PUSH
72898: LD_STRING 
72900: ST_TO_ADDR
// hc_name :=  ;
72901: LD_ADDR_OWVAR 26
72905: PUSH
72906: LD_STRING 
72908: ST_TO_ADDR
// un := CreateHuman ;
72909: LD_ADDR_VAR 0 2
72913: PUSH
72914: CALL_OW 44
72918: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
72919: LD_VAR 0 2
72923: PPUSH
72924: LD_INT 1
72926: PPUSH
72927: CALL_OW 51
// tmp := tmp ^ un ;
72931: LD_ADDR_VAR 0 3
72935: PUSH
72936: LD_VAR 0 3
72940: PUSH
72941: LD_VAR 0 2
72945: ADD
72946: ST_TO_ADDR
// end ;
72947: GO 72843
72949: POP
72950: POP
// repeat wait ( 0 0$1 ) ;
72951: LD_INT 35
72953: PPUSH
72954: CALL_OW 67
// for un in tmp do
72958: LD_ADDR_VAR 0 2
72962: PUSH
72963: LD_VAR 0 3
72967: PUSH
72968: FOR_IN
72969: IFFALSE 73043
// begin if IsDead ( un ) then
72971: LD_VAR 0 2
72975: PPUSH
72976: CALL_OW 301
72980: IFFALSE 73000
// begin tmp := tmp diff un ;
72982: LD_ADDR_VAR 0 3
72986: PUSH
72987: LD_VAR 0 3
72991: PUSH
72992: LD_VAR 0 2
72996: DIFF
72997: ST_TO_ADDR
// continue ;
72998: GO 72968
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
73000: LD_VAR 0 2
73004: PPUSH
73005: LD_INT 3
73007: PUSH
73008: LD_INT 22
73010: PUSH
73011: LD_INT 0
73013: PUSH
73014: EMPTY
73015: LIST
73016: LIST
73017: PUSH
73018: EMPTY
73019: LIST
73020: LIST
73021: PPUSH
73022: CALL_OW 69
73026: PPUSH
73027: LD_VAR 0 2
73031: PPUSH
73032: CALL_OW 74
73036: PPUSH
73037: CALL_OW 115
// end ;
73041: GO 72968
73043: POP
73044: POP
// until not tmp ;
73045: LD_VAR 0 3
73049: NOT
73050: IFFALSE 72951
// end ;
73052: PPOPN 3
73054: END
// every 0 0$1 trigger StreamModeActive and sTroll do
73055: LD_EXP 97
73059: PUSH
73060: LD_EXP 122
73064: AND
73065: IFFALSE 73119
73067: GO 73069
73069: DISABLE
// begin ToLua ( displayTroll(); ) ;
73070: LD_STRING displayTroll();
73072: PPUSH
73073: CALL_OW 559
// wait ( 3 3$00 ) ;
73077: LD_INT 6300
73079: PPUSH
73080: CALL_OW 67
// ToLua ( hideTroll(); ) ;
73084: LD_STRING hideTroll();
73086: PPUSH
73087: CALL_OW 559
// wait ( 1 1$00 ) ;
73091: LD_INT 2100
73093: PPUSH
73094: CALL_OW 67
// ToLua ( displayTroll(); ) ;
73098: LD_STRING displayTroll();
73100: PPUSH
73101: CALL_OW 559
// wait ( 1 1$00 ) ;
73105: LD_INT 2100
73107: PPUSH
73108: CALL_OW 67
// ToLua ( hideTroll(); ) ;
73112: LD_STRING hideTroll();
73114: PPUSH
73115: CALL_OW 559
// end ;
73119: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
73120: LD_EXP 97
73124: PUSH
73125: LD_EXP 123
73129: AND
73130: IFFALSE 73193
73132: GO 73134
73134: DISABLE
73135: LD_INT 0
73137: PPUSH
// begin p := 0 ;
73138: LD_ADDR_VAR 0 1
73142: PUSH
73143: LD_INT 0
73145: ST_TO_ADDR
// repeat game_speed := 1 ;
73146: LD_ADDR_OWVAR 65
73150: PUSH
73151: LD_INT 1
73153: ST_TO_ADDR
// wait ( 0 0$1 ) ;
73154: LD_INT 35
73156: PPUSH
73157: CALL_OW 67
// p := p + 1 ;
73161: LD_ADDR_VAR 0 1
73165: PUSH
73166: LD_VAR 0 1
73170: PUSH
73171: LD_INT 1
73173: PLUS
73174: ST_TO_ADDR
// until p >= 60 ;
73175: LD_VAR 0 1
73179: PUSH
73180: LD_INT 60
73182: GREATEREQUAL
73183: IFFALSE 73146
// game_speed := 4 ;
73185: LD_ADDR_OWVAR 65
73189: PUSH
73190: LD_INT 4
73192: ST_TO_ADDR
// end ;
73193: PPOPN 1
73195: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
73196: LD_EXP 97
73200: PUSH
73201: LD_EXP 124
73205: AND
73206: IFFALSE 73352
73208: GO 73210
73210: DISABLE
73211: LD_INT 0
73213: PPUSH
73214: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
73215: LD_ADDR_VAR 0 1
73219: PUSH
73220: LD_INT 22
73222: PUSH
73223: LD_OWVAR 2
73227: PUSH
73228: EMPTY
73229: LIST
73230: LIST
73231: PUSH
73232: LD_INT 2
73234: PUSH
73235: LD_INT 30
73237: PUSH
73238: LD_INT 0
73240: PUSH
73241: EMPTY
73242: LIST
73243: LIST
73244: PUSH
73245: LD_INT 30
73247: PUSH
73248: LD_INT 1
73250: PUSH
73251: EMPTY
73252: LIST
73253: LIST
73254: PUSH
73255: EMPTY
73256: LIST
73257: LIST
73258: LIST
73259: PUSH
73260: EMPTY
73261: LIST
73262: LIST
73263: PPUSH
73264: CALL_OW 69
73268: ST_TO_ADDR
// if not depot then
73269: LD_VAR 0 1
73273: NOT
73274: IFFALSE 73278
// exit ;
73276: GO 73352
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
73278: LD_ADDR_VAR 0 2
73282: PUSH
73283: LD_VAR 0 1
73287: PUSH
73288: LD_INT 1
73290: PPUSH
73291: LD_VAR 0 1
73295: PPUSH
73296: CALL_OW 12
73300: ARRAY
73301: PPUSH
73302: CALL_OW 274
73306: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
73307: LD_VAR 0 2
73311: PPUSH
73312: LD_INT 1
73314: PPUSH
73315: LD_INT 0
73317: PPUSH
73318: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
73322: LD_VAR 0 2
73326: PPUSH
73327: LD_INT 2
73329: PPUSH
73330: LD_INT 0
73332: PPUSH
73333: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
73337: LD_VAR 0 2
73341: PPUSH
73342: LD_INT 3
73344: PPUSH
73345: LD_INT 0
73347: PPUSH
73348: CALL_OW 277
// end ;
73352: PPOPN 2
73354: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
73355: LD_EXP 97
73359: PUSH
73360: LD_EXP 125
73364: AND
73365: IFFALSE 73462
73367: GO 73369
73369: DISABLE
73370: LD_INT 0
73372: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
73373: LD_ADDR_VAR 0 1
73377: PUSH
73378: LD_INT 22
73380: PUSH
73381: LD_OWVAR 2
73385: PUSH
73386: EMPTY
73387: LIST
73388: LIST
73389: PUSH
73390: LD_INT 21
73392: PUSH
73393: LD_INT 1
73395: PUSH
73396: EMPTY
73397: LIST
73398: LIST
73399: PUSH
73400: LD_INT 3
73402: PUSH
73403: LD_INT 23
73405: PUSH
73406: LD_INT 0
73408: PUSH
73409: EMPTY
73410: LIST
73411: LIST
73412: PUSH
73413: EMPTY
73414: LIST
73415: LIST
73416: PUSH
73417: EMPTY
73418: LIST
73419: LIST
73420: LIST
73421: PPUSH
73422: CALL_OW 69
73426: ST_TO_ADDR
// if not tmp then
73427: LD_VAR 0 1
73431: NOT
73432: IFFALSE 73436
// exit ;
73434: GO 73462
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
73436: LD_VAR 0 1
73440: PUSH
73441: LD_INT 1
73443: PPUSH
73444: LD_VAR 0 1
73448: PPUSH
73449: CALL_OW 12
73453: ARRAY
73454: PPUSH
73455: LD_INT 200
73457: PPUSH
73458: CALL_OW 234
// end ;
73462: PPOPN 1
73464: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
73465: LD_EXP 97
73469: PUSH
73470: LD_EXP 126
73474: AND
73475: IFFALSE 73554
73477: GO 73479
73479: DISABLE
73480: LD_INT 0
73482: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
73483: LD_ADDR_VAR 0 1
73487: PUSH
73488: LD_INT 22
73490: PUSH
73491: LD_OWVAR 2
73495: PUSH
73496: EMPTY
73497: LIST
73498: LIST
73499: PUSH
73500: LD_INT 21
73502: PUSH
73503: LD_INT 2
73505: PUSH
73506: EMPTY
73507: LIST
73508: LIST
73509: PUSH
73510: EMPTY
73511: LIST
73512: LIST
73513: PPUSH
73514: CALL_OW 69
73518: ST_TO_ADDR
// if not tmp then
73519: LD_VAR 0 1
73523: NOT
73524: IFFALSE 73528
// exit ;
73526: GO 73554
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
73528: LD_VAR 0 1
73532: PUSH
73533: LD_INT 1
73535: PPUSH
73536: LD_VAR 0 1
73540: PPUSH
73541: CALL_OW 12
73545: ARRAY
73546: PPUSH
73547: LD_INT 60
73549: PPUSH
73550: CALL_OW 234
// end ;
73554: PPOPN 1
73556: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
73557: LD_EXP 97
73561: PUSH
73562: LD_EXP 127
73566: AND
73567: IFFALSE 73666
73569: GO 73571
73571: DISABLE
73572: LD_INT 0
73574: PPUSH
73575: PPUSH
// begin enable ;
73576: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
73577: LD_ADDR_VAR 0 1
73581: PUSH
73582: LD_INT 22
73584: PUSH
73585: LD_OWVAR 2
73589: PUSH
73590: EMPTY
73591: LIST
73592: LIST
73593: PUSH
73594: LD_INT 61
73596: PUSH
73597: EMPTY
73598: LIST
73599: PUSH
73600: LD_INT 33
73602: PUSH
73603: LD_INT 2
73605: PUSH
73606: EMPTY
73607: LIST
73608: LIST
73609: PUSH
73610: EMPTY
73611: LIST
73612: LIST
73613: LIST
73614: PPUSH
73615: CALL_OW 69
73619: ST_TO_ADDR
// if not tmp then
73620: LD_VAR 0 1
73624: NOT
73625: IFFALSE 73629
// exit ;
73627: GO 73666
// for i in tmp do
73629: LD_ADDR_VAR 0 2
73633: PUSH
73634: LD_VAR 0 1
73638: PUSH
73639: FOR_IN
73640: IFFALSE 73664
// if IsControledBy ( i ) then
73642: LD_VAR 0 2
73646: PPUSH
73647: CALL_OW 312
73651: IFFALSE 73662
// ComUnlink ( i ) ;
73653: LD_VAR 0 2
73657: PPUSH
73658: CALL_OW 136
73662: GO 73639
73664: POP
73665: POP
// end ;
73666: PPOPN 2
73668: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
73669: LD_EXP 97
73673: PUSH
73674: LD_EXP 128
73678: AND
73679: IFFALSE 73819
73681: GO 73683
73683: DISABLE
73684: LD_INT 0
73686: PPUSH
73687: PPUSH
// begin ToLua ( displayPowell(); ) ;
73688: LD_STRING displayPowell();
73690: PPUSH
73691: CALL_OW 559
// uc_side := 0 ;
73695: LD_ADDR_OWVAR 20
73699: PUSH
73700: LD_INT 0
73702: ST_TO_ADDR
// uc_nation := 2 ;
73703: LD_ADDR_OWVAR 21
73707: PUSH
73708: LD_INT 2
73710: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
73711: LD_ADDR_OWVAR 37
73715: PUSH
73716: LD_INT 14
73718: ST_TO_ADDR
// vc_engine := engine_siberite ;
73719: LD_ADDR_OWVAR 39
73723: PUSH
73724: LD_INT 3
73726: ST_TO_ADDR
// vc_control := control_apeman ;
73727: LD_ADDR_OWVAR 38
73731: PUSH
73732: LD_INT 5
73734: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
73735: LD_ADDR_OWVAR 40
73739: PUSH
73740: LD_INT 29
73742: ST_TO_ADDR
// un := CreateVehicle ;
73743: LD_ADDR_VAR 0 2
73747: PUSH
73748: CALL_OW 45
73752: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
73753: LD_VAR 0 2
73757: PPUSH
73758: LD_INT 1
73760: PPUSH
73761: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
73765: LD_INT 35
73767: PPUSH
73768: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
73772: LD_VAR 0 2
73776: PPUSH
73777: LD_INT 22
73779: PUSH
73780: LD_OWVAR 2
73784: PUSH
73785: EMPTY
73786: LIST
73787: LIST
73788: PPUSH
73789: CALL_OW 69
73793: PPUSH
73794: LD_VAR 0 2
73798: PPUSH
73799: CALL_OW 74
73803: PPUSH
73804: CALL_OW 115
// until IsDead ( un ) ;
73808: LD_VAR 0 2
73812: PPUSH
73813: CALL_OW 301
73817: IFFALSE 73765
// end ;
73819: PPOPN 2
73821: END
// every 0 0$1 trigger StreamModeActive and sStu do
73822: LD_EXP 97
73826: PUSH
73827: LD_EXP 136
73831: AND
73832: IFFALSE 73848
73834: GO 73836
73836: DISABLE
// begin ToLua ( displayStucuk(); ) ;
73837: LD_STRING displayStucuk();
73839: PPUSH
73840: CALL_OW 559
// ResetFog ;
73844: CALL_OW 335
// end ;
73848: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
73849: LD_EXP 97
73853: PUSH
73854: LD_EXP 129
73858: AND
73859: IFFALSE 74000
73861: GO 73863
73863: DISABLE
73864: LD_INT 0
73866: PPUSH
73867: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
73868: LD_ADDR_VAR 0 2
73872: PUSH
73873: LD_INT 22
73875: PUSH
73876: LD_OWVAR 2
73880: PUSH
73881: EMPTY
73882: LIST
73883: LIST
73884: PUSH
73885: LD_INT 21
73887: PUSH
73888: LD_INT 1
73890: PUSH
73891: EMPTY
73892: LIST
73893: LIST
73894: PUSH
73895: EMPTY
73896: LIST
73897: LIST
73898: PPUSH
73899: CALL_OW 69
73903: ST_TO_ADDR
// if not tmp then
73904: LD_VAR 0 2
73908: NOT
73909: IFFALSE 73913
// exit ;
73911: GO 74000
// un := tmp [ rand ( 1 , tmp ) ] ;
73913: LD_ADDR_VAR 0 1
73917: PUSH
73918: LD_VAR 0 2
73922: PUSH
73923: LD_INT 1
73925: PPUSH
73926: LD_VAR 0 2
73930: PPUSH
73931: CALL_OW 12
73935: ARRAY
73936: ST_TO_ADDR
// SetSide ( un , 0 ) ;
73937: LD_VAR 0 1
73941: PPUSH
73942: LD_INT 0
73944: PPUSH
73945: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
73949: LD_VAR 0 1
73953: PPUSH
73954: LD_OWVAR 3
73958: PUSH
73959: LD_VAR 0 1
73963: DIFF
73964: PPUSH
73965: LD_VAR 0 1
73969: PPUSH
73970: CALL_OW 74
73974: PPUSH
73975: CALL_OW 115
// wait ( 0 0$20 ) ;
73979: LD_INT 700
73981: PPUSH
73982: CALL_OW 67
// SetSide ( un , your_side ) ;
73986: LD_VAR 0 1
73990: PPUSH
73991: LD_OWVAR 2
73995: PPUSH
73996: CALL_OW 235
// end ;
74000: PPOPN 2
74002: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
74003: LD_EXP 97
74007: PUSH
74008: LD_EXP 130
74012: AND
74013: IFFALSE 74119
74015: GO 74017
74017: DISABLE
74018: LD_INT 0
74020: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
74021: LD_ADDR_VAR 0 1
74025: PUSH
74026: LD_INT 22
74028: PUSH
74029: LD_OWVAR 2
74033: PUSH
74034: EMPTY
74035: LIST
74036: LIST
74037: PUSH
74038: LD_INT 2
74040: PUSH
74041: LD_INT 30
74043: PUSH
74044: LD_INT 0
74046: PUSH
74047: EMPTY
74048: LIST
74049: LIST
74050: PUSH
74051: LD_INT 30
74053: PUSH
74054: LD_INT 1
74056: PUSH
74057: EMPTY
74058: LIST
74059: LIST
74060: PUSH
74061: EMPTY
74062: LIST
74063: LIST
74064: LIST
74065: PUSH
74066: EMPTY
74067: LIST
74068: LIST
74069: PPUSH
74070: CALL_OW 69
74074: ST_TO_ADDR
// if not depot then
74075: LD_VAR 0 1
74079: NOT
74080: IFFALSE 74084
// exit ;
74082: GO 74119
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
74084: LD_VAR 0 1
74088: PUSH
74089: LD_INT 1
74091: ARRAY
74092: PPUSH
74093: CALL_OW 250
74097: PPUSH
74098: LD_VAR 0 1
74102: PUSH
74103: LD_INT 1
74105: ARRAY
74106: PPUSH
74107: CALL_OW 251
74111: PPUSH
74112: LD_INT 70
74114: PPUSH
74115: CALL_OW 495
// end ;
74119: PPOPN 1
74121: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
74122: LD_EXP 97
74126: PUSH
74127: LD_EXP 131
74131: AND
74132: IFFALSE 74343
74134: GO 74136
74136: DISABLE
74137: LD_INT 0
74139: PPUSH
74140: PPUSH
74141: PPUSH
74142: PPUSH
74143: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
74144: LD_ADDR_VAR 0 5
74148: PUSH
74149: LD_INT 22
74151: PUSH
74152: LD_OWVAR 2
74156: PUSH
74157: EMPTY
74158: LIST
74159: LIST
74160: PUSH
74161: LD_INT 21
74163: PUSH
74164: LD_INT 1
74166: PUSH
74167: EMPTY
74168: LIST
74169: LIST
74170: PUSH
74171: EMPTY
74172: LIST
74173: LIST
74174: PPUSH
74175: CALL_OW 69
74179: ST_TO_ADDR
// if not tmp then
74180: LD_VAR 0 5
74184: NOT
74185: IFFALSE 74189
// exit ;
74187: GO 74343
// for i in tmp do
74189: LD_ADDR_VAR 0 1
74193: PUSH
74194: LD_VAR 0 5
74198: PUSH
74199: FOR_IN
74200: IFFALSE 74341
// begin d := rand ( 0 , 5 ) ;
74202: LD_ADDR_VAR 0 4
74206: PUSH
74207: LD_INT 0
74209: PPUSH
74210: LD_INT 5
74212: PPUSH
74213: CALL_OW 12
74217: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
74218: LD_ADDR_VAR 0 2
74222: PUSH
74223: LD_VAR 0 1
74227: PPUSH
74228: CALL_OW 250
74232: PPUSH
74233: LD_VAR 0 4
74237: PPUSH
74238: LD_INT 3
74240: PPUSH
74241: LD_INT 12
74243: PPUSH
74244: CALL_OW 12
74248: PPUSH
74249: CALL_OW 272
74253: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
74254: LD_ADDR_VAR 0 3
74258: PUSH
74259: LD_VAR 0 1
74263: PPUSH
74264: CALL_OW 251
74268: PPUSH
74269: LD_VAR 0 4
74273: PPUSH
74274: LD_INT 3
74276: PPUSH
74277: LD_INT 12
74279: PPUSH
74280: CALL_OW 12
74284: PPUSH
74285: CALL_OW 273
74289: ST_TO_ADDR
// if ValidHex ( x , y ) then
74290: LD_VAR 0 2
74294: PPUSH
74295: LD_VAR 0 3
74299: PPUSH
74300: CALL_OW 488
74304: IFFALSE 74339
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
74306: LD_VAR 0 1
74310: PPUSH
74311: LD_VAR 0 2
74315: PPUSH
74316: LD_VAR 0 3
74320: PPUSH
74321: LD_INT 3
74323: PPUSH
74324: LD_INT 6
74326: PPUSH
74327: CALL_OW 12
74331: PPUSH
74332: LD_INT 1
74334: PPUSH
74335: CALL_OW 483
// end ;
74339: GO 74199
74341: POP
74342: POP
// end ;
74343: PPOPN 5
74345: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
74346: LD_EXP 97
74350: PUSH
74351: LD_EXP 132
74355: AND
74356: IFFALSE 74450
74358: GO 74360
74360: DISABLE
74361: LD_INT 0
74363: PPUSH
74364: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
74365: LD_ADDR_VAR 0 2
74369: PUSH
74370: LD_INT 22
74372: PUSH
74373: LD_OWVAR 2
74377: PUSH
74378: EMPTY
74379: LIST
74380: LIST
74381: PUSH
74382: LD_INT 32
74384: PUSH
74385: LD_INT 1
74387: PUSH
74388: EMPTY
74389: LIST
74390: LIST
74391: PUSH
74392: LD_INT 21
74394: PUSH
74395: LD_INT 2
74397: PUSH
74398: EMPTY
74399: LIST
74400: LIST
74401: PUSH
74402: EMPTY
74403: LIST
74404: LIST
74405: LIST
74406: PPUSH
74407: CALL_OW 69
74411: ST_TO_ADDR
// if not tmp then
74412: LD_VAR 0 2
74416: NOT
74417: IFFALSE 74421
// exit ;
74419: GO 74450
// for i in tmp do
74421: LD_ADDR_VAR 0 1
74425: PUSH
74426: LD_VAR 0 2
74430: PUSH
74431: FOR_IN
74432: IFFALSE 74448
// SetFuel ( i , 0 ) ;
74434: LD_VAR 0 1
74438: PPUSH
74439: LD_INT 0
74441: PPUSH
74442: CALL_OW 240
74446: GO 74431
74448: POP
74449: POP
// end ;
74450: PPOPN 2
74452: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
74453: LD_EXP 97
74457: PUSH
74458: LD_EXP 133
74462: AND
74463: IFFALSE 74529
74465: GO 74467
74467: DISABLE
74468: LD_INT 0
74470: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
74471: LD_ADDR_VAR 0 1
74475: PUSH
74476: LD_INT 22
74478: PUSH
74479: LD_OWVAR 2
74483: PUSH
74484: EMPTY
74485: LIST
74486: LIST
74487: PUSH
74488: LD_INT 30
74490: PUSH
74491: LD_INT 29
74493: PUSH
74494: EMPTY
74495: LIST
74496: LIST
74497: PUSH
74498: EMPTY
74499: LIST
74500: LIST
74501: PPUSH
74502: CALL_OW 69
74506: ST_TO_ADDR
// if not tmp then
74507: LD_VAR 0 1
74511: NOT
74512: IFFALSE 74516
// exit ;
74514: GO 74529
// DestroyUnit ( tmp [ 1 ] ) ;
74516: LD_VAR 0 1
74520: PUSH
74521: LD_INT 1
74523: ARRAY
74524: PPUSH
74525: CALL_OW 65
// end ;
74529: PPOPN 1
74531: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
74532: LD_EXP 97
74536: PUSH
74537: LD_EXP 135
74541: AND
74542: IFFALSE 74671
74544: GO 74546
74546: DISABLE
74547: LD_INT 0
74549: PPUSH
// begin uc_side := 0 ;
74550: LD_ADDR_OWVAR 20
74554: PUSH
74555: LD_INT 0
74557: ST_TO_ADDR
// uc_nation := nation_arabian ;
74558: LD_ADDR_OWVAR 21
74562: PUSH
74563: LD_INT 2
74565: ST_TO_ADDR
// hc_gallery :=  ;
74566: LD_ADDR_OWVAR 33
74570: PUSH
74571: LD_STRING 
74573: ST_TO_ADDR
// hc_name :=  ;
74574: LD_ADDR_OWVAR 26
74578: PUSH
74579: LD_STRING 
74581: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
74582: LD_INT 1
74584: PPUSH
74585: LD_INT 11
74587: PPUSH
74588: LD_INT 10
74590: PPUSH
74591: CALL_OW 380
// un := CreateHuman ;
74595: LD_ADDR_VAR 0 1
74599: PUSH
74600: CALL_OW 44
74604: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
74605: LD_VAR 0 1
74609: PPUSH
74610: LD_INT 1
74612: PPUSH
74613: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
74617: LD_INT 35
74619: PPUSH
74620: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
74624: LD_VAR 0 1
74628: PPUSH
74629: LD_INT 22
74631: PUSH
74632: LD_OWVAR 2
74636: PUSH
74637: EMPTY
74638: LIST
74639: LIST
74640: PPUSH
74641: CALL_OW 69
74645: PPUSH
74646: LD_VAR 0 1
74650: PPUSH
74651: CALL_OW 74
74655: PPUSH
74656: CALL_OW 115
// until IsDead ( un ) ;
74660: LD_VAR 0 1
74664: PPUSH
74665: CALL_OW 301
74669: IFFALSE 74617
// end ;
74671: PPOPN 1
74673: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
74674: LD_EXP 97
74678: PUSH
74679: LD_EXP 137
74683: AND
74684: IFFALSE 74696
74686: GO 74688
74688: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
74689: LD_STRING earthquake(getX(game), 0, 32)
74691: PPUSH
74692: CALL_OW 559
74696: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
74697: LD_EXP 97
74701: PUSH
74702: LD_EXP 138
74706: AND
74707: IFFALSE 74798
74709: GO 74711
74711: DISABLE
74712: LD_INT 0
74714: PPUSH
// begin enable ;
74715: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
74716: LD_ADDR_VAR 0 1
74720: PUSH
74721: LD_INT 22
74723: PUSH
74724: LD_OWVAR 2
74728: PUSH
74729: EMPTY
74730: LIST
74731: LIST
74732: PUSH
74733: LD_INT 21
74735: PUSH
74736: LD_INT 2
74738: PUSH
74739: EMPTY
74740: LIST
74741: LIST
74742: PUSH
74743: LD_INT 33
74745: PUSH
74746: LD_INT 3
74748: PUSH
74749: EMPTY
74750: LIST
74751: LIST
74752: PUSH
74753: EMPTY
74754: LIST
74755: LIST
74756: LIST
74757: PPUSH
74758: CALL_OW 69
74762: ST_TO_ADDR
// if not tmp then
74763: LD_VAR 0 1
74767: NOT
74768: IFFALSE 74772
// exit ;
74770: GO 74798
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
74772: LD_VAR 0 1
74776: PUSH
74777: LD_INT 1
74779: PPUSH
74780: LD_VAR 0 1
74784: PPUSH
74785: CALL_OW 12
74789: ARRAY
74790: PPUSH
74791: LD_INT 1
74793: PPUSH
74794: CALL_OW 234
// end ;
74798: PPOPN 1
74800: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
74801: LD_EXP 97
74805: PUSH
74806: LD_EXP 139
74810: AND
74811: IFFALSE 74952
74813: GO 74815
74815: DISABLE
74816: LD_INT 0
74818: PPUSH
74819: PPUSH
74820: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
74821: LD_ADDR_VAR 0 3
74825: PUSH
74826: LD_INT 22
74828: PUSH
74829: LD_OWVAR 2
74833: PUSH
74834: EMPTY
74835: LIST
74836: LIST
74837: PUSH
74838: LD_INT 25
74840: PUSH
74841: LD_INT 1
74843: PUSH
74844: EMPTY
74845: LIST
74846: LIST
74847: PUSH
74848: EMPTY
74849: LIST
74850: LIST
74851: PPUSH
74852: CALL_OW 69
74856: ST_TO_ADDR
// if not tmp then
74857: LD_VAR 0 3
74861: NOT
74862: IFFALSE 74866
// exit ;
74864: GO 74952
// un := tmp [ rand ( 1 , tmp ) ] ;
74866: LD_ADDR_VAR 0 2
74870: PUSH
74871: LD_VAR 0 3
74875: PUSH
74876: LD_INT 1
74878: PPUSH
74879: LD_VAR 0 3
74883: PPUSH
74884: CALL_OW 12
74888: ARRAY
74889: ST_TO_ADDR
// if Crawls ( un ) then
74890: LD_VAR 0 2
74894: PPUSH
74895: CALL_OW 318
74899: IFFALSE 74910
// ComWalk ( un ) ;
74901: LD_VAR 0 2
74905: PPUSH
74906: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
74910: LD_VAR 0 2
74914: PPUSH
74915: LD_INT 9
74917: PPUSH
74918: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
74922: LD_INT 28
74924: PPUSH
74925: LD_OWVAR 2
74929: PPUSH
74930: LD_INT 2
74932: PPUSH
74933: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
74937: LD_INT 29
74939: PPUSH
74940: LD_OWVAR 2
74944: PPUSH
74945: LD_INT 2
74947: PPUSH
74948: CALL_OW 322
// end ;
74952: PPOPN 3
74954: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
74955: LD_EXP 97
74959: PUSH
74960: LD_EXP 140
74964: AND
74965: IFFALSE 75076
74967: GO 74969
74969: DISABLE
74970: LD_INT 0
74972: PPUSH
74973: PPUSH
74974: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
74975: LD_ADDR_VAR 0 3
74979: PUSH
74980: LD_INT 22
74982: PUSH
74983: LD_OWVAR 2
74987: PUSH
74988: EMPTY
74989: LIST
74990: LIST
74991: PUSH
74992: LD_INT 25
74994: PUSH
74995: LD_INT 1
74997: PUSH
74998: EMPTY
74999: LIST
75000: LIST
75001: PUSH
75002: EMPTY
75003: LIST
75004: LIST
75005: PPUSH
75006: CALL_OW 69
75010: ST_TO_ADDR
// if not tmp then
75011: LD_VAR 0 3
75015: NOT
75016: IFFALSE 75020
// exit ;
75018: GO 75076
// un := tmp [ rand ( 1 , tmp ) ] ;
75020: LD_ADDR_VAR 0 2
75024: PUSH
75025: LD_VAR 0 3
75029: PUSH
75030: LD_INT 1
75032: PPUSH
75033: LD_VAR 0 3
75037: PPUSH
75038: CALL_OW 12
75042: ARRAY
75043: ST_TO_ADDR
// if Crawls ( un ) then
75044: LD_VAR 0 2
75048: PPUSH
75049: CALL_OW 318
75053: IFFALSE 75064
// ComWalk ( un ) ;
75055: LD_VAR 0 2
75059: PPUSH
75060: CALL_OW 138
// SetClass ( un , class_mortar ) ;
75064: LD_VAR 0 2
75068: PPUSH
75069: LD_INT 8
75071: PPUSH
75072: CALL_OW 336
// end ;
75076: PPOPN 3
75078: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
75079: LD_EXP 97
75083: PUSH
75084: LD_EXP 141
75088: AND
75089: IFFALSE 75233
75091: GO 75093
75093: DISABLE
75094: LD_INT 0
75096: PPUSH
75097: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
75098: LD_ADDR_VAR 0 2
75102: PUSH
75103: LD_INT 22
75105: PUSH
75106: LD_OWVAR 2
75110: PUSH
75111: EMPTY
75112: LIST
75113: LIST
75114: PUSH
75115: LD_INT 21
75117: PUSH
75118: LD_INT 2
75120: PUSH
75121: EMPTY
75122: LIST
75123: LIST
75124: PUSH
75125: LD_INT 2
75127: PUSH
75128: LD_INT 34
75130: PUSH
75131: LD_INT 12
75133: PUSH
75134: EMPTY
75135: LIST
75136: LIST
75137: PUSH
75138: LD_INT 34
75140: PUSH
75141: LD_INT 51
75143: PUSH
75144: EMPTY
75145: LIST
75146: LIST
75147: PUSH
75148: LD_INT 34
75150: PUSH
75151: LD_INT 32
75153: PUSH
75154: EMPTY
75155: LIST
75156: LIST
75157: PUSH
75158: EMPTY
75159: LIST
75160: LIST
75161: LIST
75162: LIST
75163: PUSH
75164: EMPTY
75165: LIST
75166: LIST
75167: LIST
75168: PPUSH
75169: CALL_OW 69
75173: ST_TO_ADDR
// if not tmp then
75174: LD_VAR 0 2
75178: NOT
75179: IFFALSE 75183
// exit ;
75181: GO 75233
// for i in tmp do
75183: LD_ADDR_VAR 0 1
75187: PUSH
75188: LD_VAR 0 2
75192: PUSH
75193: FOR_IN
75194: IFFALSE 75231
// if GetCargo ( i , mat_artifact ) = 0 then
75196: LD_VAR 0 1
75200: PPUSH
75201: LD_INT 4
75203: PPUSH
75204: CALL_OW 289
75208: PUSH
75209: LD_INT 0
75211: EQUAL
75212: IFFALSE 75229
// SetCargo ( i , mat_siberit , 100 ) ;
75214: LD_VAR 0 1
75218: PPUSH
75219: LD_INT 3
75221: PPUSH
75222: LD_INT 100
75224: PPUSH
75225: CALL_OW 290
75229: GO 75193
75231: POP
75232: POP
// end ;
75233: PPOPN 2
75235: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
75236: LD_EXP 97
75240: PUSH
75241: LD_EXP 142
75245: AND
75246: IFFALSE 75429
75248: GO 75250
75250: DISABLE
75251: LD_INT 0
75253: PPUSH
75254: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
75255: LD_ADDR_VAR 0 2
75259: PUSH
75260: LD_INT 22
75262: PUSH
75263: LD_OWVAR 2
75267: PUSH
75268: EMPTY
75269: LIST
75270: LIST
75271: PPUSH
75272: CALL_OW 69
75276: ST_TO_ADDR
// if not tmp then
75277: LD_VAR 0 2
75281: NOT
75282: IFFALSE 75286
// exit ;
75284: GO 75429
// for i := 1 to 2 do
75286: LD_ADDR_VAR 0 1
75290: PUSH
75291: DOUBLE
75292: LD_INT 1
75294: DEC
75295: ST_TO_ADDR
75296: LD_INT 2
75298: PUSH
75299: FOR_TO
75300: IFFALSE 75427
// begin uc_side := your_side ;
75302: LD_ADDR_OWVAR 20
75306: PUSH
75307: LD_OWVAR 2
75311: ST_TO_ADDR
// uc_nation := nation_american ;
75312: LD_ADDR_OWVAR 21
75316: PUSH
75317: LD_INT 1
75319: ST_TO_ADDR
// vc_chassis := us_morphling ;
75320: LD_ADDR_OWVAR 37
75324: PUSH
75325: LD_INT 5
75327: ST_TO_ADDR
// vc_engine := engine_siberite ;
75328: LD_ADDR_OWVAR 39
75332: PUSH
75333: LD_INT 3
75335: ST_TO_ADDR
// vc_control := control_computer ;
75336: LD_ADDR_OWVAR 38
75340: PUSH
75341: LD_INT 3
75343: ST_TO_ADDR
// vc_weapon := us_double_laser ;
75344: LD_ADDR_OWVAR 40
75348: PUSH
75349: LD_INT 10
75351: ST_TO_ADDR
// if not IsInUnit ( tmp [ 1 ] ) then
75352: LD_VAR 0 2
75356: PUSH
75357: LD_INT 1
75359: ARRAY
75360: PPUSH
75361: CALL_OW 310
75365: NOT
75366: IFFALSE 75413
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) else
75368: CALL_OW 45
75372: PPUSH
75373: LD_VAR 0 2
75377: PUSH
75378: LD_INT 1
75380: ARRAY
75381: PPUSH
75382: CALL_OW 250
75386: PPUSH
75387: LD_VAR 0 2
75391: PUSH
75392: LD_INT 1
75394: ARRAY
75395: PPUSH
75396: CALL_OW 251
75400: PPUSH
75401: LD_INT 12
75403: PPUSH
75404: LD_INT 1
75406: PPUSH
75407: CALL_OW 50
75411: GO 75425
// PlaceUnitAnywhere ( CreateVehicle , true ) ;
75413: CALL_OW 45
75417: PPUSH
75418: LD_INT 1
75420: PPUSH
75421: CALL_OW 51
// end ;
75425: GO 75299
75427: POP
75428: POP
// end ;
75429: PPOPN 2
75431: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
75432: LD_EXP 97
75436: PUSH
75437: LD_EXP 143
75441: AND
75442: IFFALSE 75664
75444: GO 75446
75446: DISABLE
75447: LD_INT 0
75449: PPUSH
75450: PPUSH
75451: PPUSH
75452: PPUSH
75453: PPUSH
75454: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
75455: LD_ADDR_VAR 0 6
75459: PUSH
75460: LD_INT 22
75462: PUSH
75463: LD_OWVAR 2
75467: PUSH
75468: EMPTY
75469: LIST
75470: LIST
75471: PUSH
75472: LD_INT 21
75474: PUSH
75475: LD_INT 1
75477: PUSH
75478: EMPTY
75479: LIST
75480: LIST
75481: PUSH
75482: LD_INT 3
75484: PUSH
75485: LD_INT 23
75487: PUSH
75488: LD_INT 0
75490: PUSH
75491: EMPTY
75492: LIST
75493: LIST
75494: PUSH
75495: EMPTY
75496: LIST
75497: LIST
75498: PUSH
75499: EMPTY
75500: LIST
75501: LIST
75502: LIST
75503: PPUSH
75504: CALL_OW 69
75508: ST_TO_ADDR
// if not tmp then
75509: LD_VAR 0 6
75513: NOT
75514: IFFALSE 75518
// exit ;
75516: GO 75664
// s1 := rand ( 1 , 4 ) ;
75518: LD_ADDR_VAR 0 2
75522: PUSH
75523: LD_INT 1
75525: PPUSH
75526: LD_INT 4
75528: PPUSH
75529: CALL_OW 12
75533: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
75534: LD_ADDR_VAR 0 4
75538: PUSH
75539: LD_VAR 0 6
75543: PUSH
75544: LD_INT 1
75546: ARRAY
75547: PPUSH
75548: LD_VAR 0 2
75552: PPUSH
75553: CALL_OW 259
75557: ST_TO_ADDR
// if s1 = 1 then
75558: LD_VAR 0 2
75562: PUSH
75563: LD_INT 1
75565: EQUAL
75566: IFFALSE 75586
// s2 := rand ( 2 , 4 ) else
75568: LD_ADDR_VAR 0 3
75572: PUSH
75573: LD_INT 2
75575: PPUSH
75576: LD_INT 4
75578: PPUSH
75579: CALL_OW 12
75583: ST_TO_ADDR
75584: GO 75594
// s2 := 1 ;
75586: LD_ADDR_VAR 0 3
75590: PUSH
75591: LD_INT 1
75593: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
75594: LD_ADDR_VAR 0 5
75598: PUSH
75599: LD_VAR 0 6
75603: PUSH
75604: LD_INT 1
75606: ARRAY
75607: PPUSH
75608: LD_VAR 0 3
75612: PPUSH
75613: CALL_OW 259
75617: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
75618: LD_VAR 0 6
75622: PUSH
75623: LD_INT 1
75625: ARRAY
75626: PPUSH
75627: LD_VAR 0 2
75631: PPUSH
75632: LD_VAR 0 5
75636: PPUSH
75637: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
75641: LD_VAR 0 6
75645: PUSH
75646: LD_INT 1
75648: ARRAY
75649: PPUSH
75650: LD_VAR 0 3
75654: PPUSH
75655: LD_VAR 0 4
75659: PPUSH
75660: CALL_OW 237
// end ;
75664: PPOPN 6
75666: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
75667: LD_EXP 97
75671: PUSH
75672: LD_EXP 144
75676: AND
75677: IFFALSE 75756
75679: GO 75681
75681: DISABLE
75682: LD_INT 0
75684: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
75685: LD_ADDR_VAR 0 1
75689: PUSH
75690: LD_INT 22
75692: PUSH
75693: LD_OWVAR 2
75697: PUSH
75698: EMPTY
75699: LIST
75700: LIST
75701: PUSH
75702: LD_INT 30
75704: PUSH
75705: LD_INT 3
75707: PUSH
75708: EMPTY
75709: LIST
75710: LIST
75711: PUSH
75712: EMPTY
75713: LIST
75714: LIST
75715: PPUSH
75716: CALL_OW 69
75720: ST_TO_ADDR
// if not tmp then
75721: LD_VAR 0 1
75725: NOT
75726: IFFALSE 75730
// exit ;
75728: GO 75756
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
75730: LD_VAR 0 1
75734: PUSH
75735: LD_INT 1
75737: PPUSH
75738: LD_VAR 0 1
75742: PPUSH
75743: CALL_OW 12
75747: ARRAY
75748: PPUSH
75749: LD_INT 1
75751: PPUSH
75752: CALL_OW 234
// end ;
75756: PPOPN 1
75758: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
75759: LD_EXP 97
75763: PUSH
75764: LD_EXP 145
75768: AND
75769: IFFALSE 75881
75771: GO 75773
75773: DISABLE
75774: LD_INT 0
75776: PPUSH
75777: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
75778: LD_ADDR_VAR 0 2
75782: PUSH
75783: LD_INT 22
75785: PUSH
75786: LD_OWVAR 2
75790: PUSH
75791: EMPTY
75792: LIST
75793: LIST
75794: PUSH
75795: LD_INT 2
75797: PUSH
75798: LD_INT 30
75800: PUSH
75801: LD_INT 27
75803: PUSH
75804: EMPTY
75805: LIST
75806: LIST
75807: PUSH
75808: LD_INT 30
75810: PUSH
75811: LD_INT 26
75813: PUSH
75814: EMPTY
75815: LIST
75816: LIST
75817: PUSH
75818: LD_INT 30
75820: PUSH
75821: LD_INT 28
75823: PUSH
75824: EMPTY
75825: LIST
75826: LIST
75827: PUSH
75828: EMPTY
75829: LIST
75830: LIST
75831: LIST
75832: LIST
75833: PUSH
75834: EMPTY
75835: LIST
75836: LIST
75837: PPUSH
75838: CALL_OW 69
75842: ST_TO_ADDR
// if not tmp then
75843: LD_VAR 0 2
75847: NOT
75848: IFFALSE 75852
// exit ;
75850: GO 75881
// for i in tmp do
75852: LD_ADDR_VAR 0 1
75856: PUSH
75857: LD_VAR 0 2
75861: PUSH
75862: FOR_IN
75863: IFFALSE 75879
// SetLives ( i , 1 ) ;
75865: LD_VAR 0 1
75869: PPUSH
75870: LD_INT 1
75872: PPUSH
75873: CALL_OW 234
75877: GO 75862
75879: POP
75880: POP
// end ;
75881: PPOPN 2
75883: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
75884: LD_EXP 97
75888: PUSH
75889: LD_EXP 146
75893: AND
75894: IFFALSE 76181
75896: GO 75898
75898: DISABLE
75899: LD_INT 0
75901: PPUSH
75902: PPUSH
75903: PPUSH
// begin i := rand ( 1 , 7 ) ;
75904: LD_ADDR_VAR 0 1
75908: PUSH
75909: LD_INT 1
75911: PPUSH
75912: LD_INT 7
75914: PPUSH
75915: CALL_OW 12
75919: ST_TO_ADDR
// case i of 1 :
75920: LD_VAR 0 1
75924: PUSH
75925: LD_INT 1
75927: DOUBLE
75928: EQUAL
75929: IFTRUE 75933
75931: GO 75943
75933: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
75934: LD_STRING earthquake(getX(game), 0, 32)
75936: PPUSH
75937: CALL_OW 559
75941: GO 76181
75943: LD_INT 2
75945: DOUBLE
75946: EQUAL
75947: IFTRUE 75951
75949: GO 75965
75951: POP
// begin ToLua ( displayStucuk(); ) ;
75952: LD_STRING displayStucuk();
75954: PPUSH
75955: CALL_OW 559
// ResetFog ;
75959: CALL_OW 335
// end ; 3 :
75963: GO 76181
75965: LD_INT 3
75967: DOUBLE
75968: EQUAL
75969: IFTRUE 75973
75971: GO 76077
75973: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
75974: LD_ADDR_VAR 0 2
75978: PUSH
75979: LD_INT 22
75981: PUSH
75982: LD_OWVAR 2
75986: PUSH
75987: EMPTY
75988: LIST
75989: LIST
75990: PUSH
75991: LD_INT 25
75993: PUSH
75994: LD_INT 1
75996: PUSH
75997: EMPTY
75998: LIST
75999: LIST
76000: PUSH
76001: EMPTY
76002: LIST
76003: LIST
76004: PPUSH
76005: CALL_OW 69
76009: ST_TO_ADDR
// if not tmp then
76010: LD_VAR 0 2
76014: NOT
76015: IFFALSE 76019
// exit ;
76017: GO 76181
// un := tmp [ rand ( 1 , tmp ) ] ;
76019: LD_ADDR_VAR 0 3
76023: PUSH
76024: LD_VAR 0 2
76028: PUSH
76029: LD_INT 1
76031: PPUSH
76032: LD_VAR 0 2
76036: PPUSH
76037: CALL_OW 12
76041: ARRAY
76042: ST_TO_ADDR
// if Crawls ( un ) then
76043: LD_VAR 0 3
76047: PPUSH
76048: CALL_OW 318
76052: IFFALSE 76063
// ComWalk ( un ) ;
76054: LD_VAR 0 3
76058: PPUSH
76059: CALL_OW 138
// SetClass ( un , class_mortar ) ;
76063: LD_VAR 0 3
76067: PPUSH
76068: LD_INT 8
76070: PPUSH
76071: CALL_OW 336
// end ; 4 :
76075: GO 76181
76077: LD_INT 4
76079: DOUBLE
76080: EQUAL
76081: IFTRUE 76085
76083: GO 76159
76085: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
76086: LD_ADDR_VAR 0 2
76090: PUSH
76091: LD_INT 22
76093: PUSH
76094: LD_OWVAR 2
76098: PUSH
76099: EMPTY
76100: LIST
76101: LIST
76102: PUSH
76103: LD_INT 30
76105: PUSH
76106: LD_INT 29
76108: PUSH
76109: EMPTY
76110: LIST
76111: LIST
76112: PUSH
76113: EMPTY
76114: LIST
76115: LIST
76116: PPUSH
76117: CALL_OW 69
76121: ST_TO_ADDR
// if not tmp then
76122: LD_VAR 0 2
76126: NOT
76127: IFFALSE 76131
// exit ;
76129: GO 76181
// CenterNowOnUnits ( tmp [ 1 ] ) ;
76131: LD_VAR 0 2
76135: PUSH
76136: LD_INT 1
76138: ARRAY
76139: PPUSH
76140: CALL_OW 87
// DestroyUnit ( tmp [ 1 ] ) ;
76144: LD_VAR 0 2
76148: PUSH
76149: LD_INT 1
76151: ARRAY
76152: PPUSH
76153: CALL_OW 65
// end ; 5 .. 7 :
76157: GO 76181
76159: LD_INT 5
76161: DOUBLE
76162: GREATEREQUAL
76163: IFFALSE 76171
76165: LD_INT 7
76167: DOUBLE
76168: LESSEQUAL
76169: IFTRUE 76173
76171: GO 76180
76173: POP
// StreamSibBomb ; end ;
76174: CALL 72418 0 0
76178: GO 76181
76180: POP
// end ;
76181: PPOPN 3
76183: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
76184: LD_EXP 97
76188: PUSH
76189: LD_EXP 147
76193: AND
76194: IFFALSE 76350
76196: GO 76198
76198: DISABLE
76199: LD_INT 0
76201: PPUSH
76202: PPUSH
76203: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
76204: LD_ADDR_VAR 0 2
76208: PUSH
76209: LD_INT 81
76211: PUSH
76212: LD_OWVAR 2
76216: PUSH
76217: EMPTY
76218: LIST
76219: LIST
76220: PUSH
76221: LD_INT 2
76223: PUSH
76224: LD_INT 21
76226: PUSH
76227: LD_INT 1
76229: PUSH
76230: EMPTY
76231: LIST
76232: LIST
76233: PUSH
76234: LD_INT 21
76236: PUSH
76237: LD_INT 2
76239: PUSH
76240: EMPTY
76241: LIST
76242: LIST
76243: PUSH
76244: EMPTY
76245: LIST
76246: LIST
76247: LIST
76248: PUSH
76249: EMPTY
76250: LIST
76251: LIST
76252: PPUSH
76253: CALL_OW 69
76257: ST_TO_ADDR
// if not tmp then
76258: LD_VAR 0 2
76262: NOT
76263: IFFALSE 76267
// exit ;
76265: GO 76350
// p := 0 ;
76267: LD_ADDR_VAR 0 3
76271: PUSH
76272: LD_INT 0
76274: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
76275: LD_INT 35
76277: PPUSH
76278: CALL_OW 67
// p := p + 1 ;
76282: LD_ADDR_VAR 0 3
76286: PUSH
76287: LD_VAR 0 3
76291: PUSH
76292: LD_INT 1
76294: PLUS
76295: ST_TO_ADDR
// for i in tmp do
76296: LD_ADDR_VAR 0 1
76300: PUSH
76301: LD_VAR 0 2
76305: PUSH
76306: FOR_IN
76307: IFFALSE 76338
// if GetLives ( i ) < 1000 then
76309: LD_VAR 0 1
76313: PPUSH
76314: CALL_OW 256
76318: PUSH
76319: LD_INT 1000
76321: LESS
76322: IFFALSE 76336
// SetLives ( i , 1000 ) ;
76324: LD_VAR 0 1
76328: PPUSH
76329: LD_INT 1000
76331: PPUSH
76332: CALL_OW 234
76336: GO 76306
76338: POP
76339: POP
// until p > 20 ;
76340: LD_VAR 0 3
76344: PUSH
76345: LD_INT 20
76347: GREATER
76348: IFFALSE 76275
// end ;
76350: PPOPN 3
76352: END
// every 0 0$1 trigger StreamModeActive and sTime do
76353: LD_EXP 97
76357: PUSH
76358: LD_EXP 148
76362: AND
76363: IFFALSE 76398
76365: GO 76367
76367: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
76368: LD_INT 28
76370: PPUSH
76371: LD_OWVAR 2
76375: PPUSH
76376: LD_INT 2
76378: PPUSH
76379: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
76383: LD_INT 30
76385: PPUSH
76386: LD_OWVAR 2
76390: PPUSH
76391: LD_INT 2
76393: PPUSH
76394: CALL_OW 322
// end ;
76398: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
76399: LD_EXP 97
76403: PUSH
76404: LD_EXP 149
76408: AND
76409: IFFALSE 76530
76411: GO 76413
76413: DISABLE
76414: LD_INT 0
76416: PPUSH
76417: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
76418: LD_ADDR_VAR 0 2
76422: PUSH
76423: LD_INT 22
76425: PUSH
76426: LD_OWVAR 2
76430: PUSH
76431: EMPTY
76432: LIST
76433: LIST
76434: PUSH
76435: LD_INT 21
76437: PUSH
76438: LD_INT 1
76440: PUSH
76441: EMPTY
76442: LIST
76443: LIST
76444: PUSH
76445: LD_INT 3
76447: PUSH
76448: LD_INT 23
76450: PUSH
76451: LD_INT 0
76453: PUSH
76454: EMPTY
76455: LIST
76456: LIST
76457: PUSH
76458: EMPTY
76459: LIST
76460: LIST
76461: PUSH
76462: EMPTY
76463: LIST
76464: LIST
76465: LIST
76466: PPUSH
76467: CALL_OW 69
76471: ST_TO_ADDR
// if not tmp then
76472: LD_VAR 0 2
76476: NOT
76477: IFFALSE 76481
// exit ;
76479: GO 76530
// for i in tmp do
76481: LD_ADDR_VAR 0 1
76485: PUSH
76486: LD_VAR 0 2
76490: PUSH
76491: FOR_IN
76492: IFFALSE 76528
// begin if Crawls ( i ) then
76494: LD_VAR 0 1
76498: PPUSH
76499: CALL_OW 318
76503: IFFALSE 76514
// ComWalk ( i ) ;
76505: LD_VAR 0 1
76509: PPUSH
76510: CALL_OW 138
// SetClass ( i , 2 ) ;
76514: LD_VAR 0 1
76518: PPUSH
76519: LD_INT 2
76521: PPUSH
76522: CALL_OW 336
// end ;
76526: GO 76491
76528: POP
76529: POP
// end ;
76530: PPOPN 2
76532: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
76533: LD_EXP 97
76537: PUSH
76538: LD_EXP 150
76542: AND
76543: IFFALSE 76831
76545: GO 76547
76547: DISABLE
76548: LD_INT 0
76550: PPUSH
76551: PPUSH
76552: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
76553: LD_OWVAR 2
76557: PPUSH
76558: LD_INT 9
76560: PPUSH
76561: LD_INT 1
76563: PPUSH
76564: LD_INT 1
76566: PPUSH
76567: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
76571: LD_INT 9
76573: PPUSH
76574: LD_OWVAR 2
76578: PPUSH
76579: CALL_OW 343
// uc_side := 9 ;
76583: LD_ADDR_OWVAR 20
76587: PUSH
76588: LD_INT 9
76590: ST_TO_ADDR
// uc_nation := 2 ;
76591: LD_ADDR_OWVAR 21
76595: PUSH
76596: LD_INT 2
76598: ST_TO_ADDR
// hc_name := Dark Warrior ;
76599: LD_ADDR_OWVAR 26
76603: PUSH
76604: LD_STRING Dark Warrior
76606: ST_TO_ADDR
// hc_gallery :=  ;
76607: LD_ADDR_OWVAR 33
76611: PUSH
76612: LD_STRING 
76614: ST_TO_ADDR
// hc_noskilllimit := true ;
76615: LD_ADDR_OWVAR 76
76619: PUSH
76620: LD_INT 1
76622: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
76623: LD_ADDR_OWVAR 31
76627: PUSH
76628: LD_INT 30
76630: PUSH
76631: LD_INT 30
76633: PUSH
76634: LD_INT 30
76636: PUSH
76637: LD_INT 30
76639: PUSH
76640: EMPTY
76641: LIST
76642: LIST
76643: LIST
76644: LIST
76645: ST_TO_ADDR
// un := CreateHuman ;
76646: LD_ADDR_VAR 0 3
76650: PUSH
76651: CALL_OW 44
76655: ST_TO_ADDR
// hc_noskilllimit := false ;
76656: LD_ADDR_OWVAR 76
76660: PUSH
76661: LD_INT 0
76663: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
76664: LD_VAR 0 3
76668: PPUSH
76669: LD_INT 1
76671: PPUSH
76672: CALL_OW 51
// ToLua ( playRanger() ) ;
76676: LD_STRING playRanger()
76678: PPUSH
76679: CALL_OW 559
// p := 0 ;
76683: LD_ADDR_VAR 0 2
76687: PUSH
76688: LD_INT 0
76690: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
76691: LD_INT 35
76693: PPUSH
76694: CALL_OW 67
// p := p + 1 ;
76698: LD_ADDR_VAR 0 2
76702: PUSH
76703: LD_VAR 0 2
76707: PUSH
76708: LD_INT 1
76710: PLUS
76711: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
76712: LD_VAR 0 3
76716: PPUSH
76717: CALL_OW 256
76721: PUSH
76722: LD_INT 1000
76724: LESS
76725: IFFALSE 76739
// SetLives ( un , 1000 ) ;
76727: LD_VAR 0 3
76731: PPUSH
76732: LD_INT 1000
76734: PPUSH
76735: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
76739: LD_VAR 0 3
76743: PPUSH
76744: LD_INT 81
76746: PUSH
76747: LD_OWVAR 2
76751: PUSH
76752: EMPTY
76753: LIST
76754: LIST
76755: PUSH
76756: LD_INT 91
76758: PUSH
76759: LD_VAR 0 3
76763: PUSH
76764: LD_INT 30
76766: PUSH
76767: EMPTY
76768: LIST
76769: LIST
76770: LIST
76771: PUSH
76772: EMPTY
76773: LIST
76774: LIST
76775: PPUSH
76776: CALL_OW 69
76780: PPUSH
76781: LD_VAR 0 3
76785: PPUSH
76786: CALL_OW 74
76790: PPUSH
76791: CALL_OW 115
// until p > 80 or IsDead ( un ) ;
76795: LD_VAR 0 2
76799: PUSH
76800: LD_INT 80
76802: GREATER
76803: PUSH
76804: LD_VAR 0 3
76808: PPUSH
76809: CALL_OW 301
76813: OR
76814: IFFALSE 76691
// if un then
76816: LD_VAR 0 3
76820: IFFALSE 76831
// RemoveUnit ( un ) ;
76822: LD_VAR 0 3
76826: PPUSH
76827: CALL_OW 64
// end ;
76831: PPOPN 3
76833: END
// every 0 0$1 trigger sComputer do var i , tmp , j ;
76834: LD_EXP 151
76838: IFFALSE 76954
76840: GO 76842
76842: DISABLE
76843: LD_INT 0
76845: PPUSH
76846: PPUSH
76847: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
76848: LD_ADDR_VAR 0 2
76852: PUSH
76853: LD_INT 81
76855: PUSH
76856: LD_OWVAR 2
76860: PUSH
76861: EMPTY
76862: LIST
76863: LIST
76864: PUSH
76865: LD_INT 21
76867: PUSH
76868: LD_INT 1
76870: PUSH
76871: EMPTY
76872: LIST
76873: LIST
76874: PUSH
76875: EMPTY
76876: LIST
76877: LIST
76878: PPUSH
76879: CALL_OW 69
76883: ST_TO_ADDR
// ToLua ( playComputer() ) ;
76884: LD_STRING playComputer()
76886: PPUSH
76887: CALL_OW 559
// if not tmp then
76891: LD_VAR 0 2
76895: NOT
76896: IFFALSE 76900
// exit ;
76898: GO 76954
// for i in tmp do
76900: LD_ADDR_VAR 0 1
76904: PUSH
76905: LD_VAR 0 2
76909: PUSH
76910: FOR_IN
76911: IFFALSE 76952
// for j := 1 to 4 do
76913: LD_ADDR_VAR 0 3
76917: PUSH
76918: DOUBLE
76919: LD_INT 1
76921: DEC
76922: ST_TO_ADDR
76923: LD_INT 4
76925: PUSH
76926: FOR_TO
76927: IFFALSE 76948
// SetSkill ( i , j , 10 ) ;
76929: LD_VAR 0 1
76933: PPUSH
76934: LD_VAR 0 3
76938: PPUSH
76939: LD_INT 10
76941: PPUSH
76942: CALL_OW 237
76946: GO 76926
76948: POP
76949: POP
76950: GO 76910
76952: POP
76953: POP
// end ;
76954: PPOPN 3
76956: END
// every 0 0$1 trigger s30 do var i , tmp ;
76957: LD_EXP 152
76961: IFFALSE 77030
76963: GO 76965
76965: DISABLE
76966: LD_INT 0
76968: PPUSH
76969: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
76970: LD_ADDR_VAR 0 2
76974: PUSH
76975: LD_INT 22
76977: PUSH
76978: LD_OWVAR 2
76982: PUSH
76983: EMPTY
76984: LIST
76985: LIST
76986: PPUSH
76987: CALL_OW 69
76991: ST_TO_ADDR
// if not tmp then
76992: LD_VAR 0 2
76996: NOT
76997: IFFALSE 77001
// exit ;
76999: GO 77030
// for i in tmp do
77001: LD_ADDR_VAR 0 1
77005: PUSH
77006: LD_VAR 0 2
77010: PUSH
77011: FOR_IN
77012: IFFALSE 77028
// SetLives ( i , 300 ) ;
77014: LD_VAR 0 1
77018: PPUSH
77019: LD_INT 300
77021: PPUSH
77022: CALL_OW 234
77026: GO 77011
77028: POP
77029: POP
// end ;
77030: PPOPN 2
77032: END
// every 0 0$1 trigger s60 do var i , tmp ;
77033: LD_EXP 153
77037: IFFALSE 77106
77039: GO 77041
77041: DISABLE
77042: LD_INT 0
77044: PPUSH
77045: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
77046: LD_ADDR_VAR 0 2
77050: PUSH
77051: LD_INT 22
77053: PUSH
77054: LD_OWVAR 2
77058: PUSH
77059: EMPTY
77060: LIST
77061: LIST
77062: PPUSH
77063: CALL_OW 69
77067: ST_TO_ADDR
// if not tmp then
77068: LD_VAR 0 2
77072: NOT
77073: IFFALSE 77077
// exit ;
77075: GO 77106
// for i in tmp do
77077: LD_ADDR_VAR 0 1
77081: PUSH
77082: LD_VAR 0 2
77086: PUSH
77087: FOR_IN
77088: IFFALSE 77104
// SetLives ( i , 600 ) ;
77090: LD_VAR 0 1
77094: PPUSH
77095: LD_INT 600
77097: PPUSH
77098: CALL_OW 234
77102: GO 77087
77104: POP
77105: POP
// end ;
77106: PPOPN 2
77108: END
// export function SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
77109: LD_INT 0
77111: PPUSH
// case cmd of 301 :
77112: LD_VAR 0 1
77116: PUSH
77117: LD_INT 301
77119: DOUBLE
77120: EQUAL
77121: IFTRUE 77125
77123: GO 77157
77125: POP
// hHackSpawnHuman ( p1 , p2 , p3 , x , y ) ; 302 :
77126: LD_VAR 0 6
77130: PPUSH
77131: LD_VAR 0 7
77135: PPUSH
77136: LD_VAR 0 8
77140: PPUSH
77141: LD_VAR 0 4
77145: PPUSH
77146: LD_VAR 0 5
77150: PPUSH
77151: CALL 78358 0 5
77155: GO 77278
77157: LD_INT 302
77159: DOUBLE
77160: EQUAL
77161: IFTRUE 77165
77163: GO 77202
77165: POP
// hHackSpawnVehicle ( p1 , p2 , p3 , p4 , x , y ) ; 303 :
77166: LD_VAR 0 6
77170: PPUSH
77171: LD_VAR 0 7
77175: PPUSH
77176: LD_VAR 0 8
77180: PPUSH
77181: LD_VAR 0 9
77185: PPUSH
77186: LD_VAR 0 4
77190: PPUSH
77191: LD_VAR 0 5
77195: PPUSH
77196: CALL 78449 0 6
77200: GO 77278
77202: LD_INT 303
77204: DOUBLE
77205: EQUAL
77206: IFTRUE 77210
77208: GO 77247
77210: POP
// hHackSpawnBuilding ( p1 , p2 , p3 , p4 , x , y ) ; 304 :
77211: LD_VAR 0 6
77215: PPUSH
77216: LD_VAR 0 7
77220: PPUSH
77221: LD_VAR 0 8
77225: PPUSH
77226: LD_VAR 0 9
77230: PPUSH
77231: LD_VAR 0 4
77235: PPUSH
77236: LD_VAR 0 5
77240: PPUSH
77241: CALL 77283 0 6
77245: GO 77278
77247: LD_INT 304
77249: DOUBLE
77250: EQUAL
77251: IFTRUE 77255
77253: GO 77277
77255: POP
// hHackTeleport ( unit , x , y ) ; end ;
77256: LD_VAR 0 2
77260: PPUSH
77261: LD_VAR 0 4
77265: PPUSH
77266: LD_VAR 0 5
77270: PPUSH
77271: CALL 79042 0 3
77275: GO 77278
77277: POP
// end ;
77278: LD_VAR 0 12
77282: RET
// export function hHackSpawnBuilding ( nation , btype , dir , weapon , x , y ) ; var b ; begin
77283: LD_INT 0
77285: PPUSH
77286: PPUSH
// if nation < 1 or nation > 3 or HexInfo ( x , y ) then
77287: LD_VAR 0 1
77291: PUSH
77292: LD_INT 1
77294: LESS
77295: PUSH
77296: LD_VAR 0 1
77300: PUSH
77301: LD_INT 3
77303: GREATER
77304: OR
77305: PUSH
77306: LD_VAR 0 5
77310: PPUSH
77311: LD_VAR 0 6
77315: PPUSH
77316: CALL_OW 428
77320: OR
77321: IFFALSE 77325
// exit ;
77323: GO 78045
// uc_side := your_side ;
77325: LD_ADDR_OWVAR 20
77329: PUSH
77330: LD_OWVAR 2
77334: ST_TO_ADDR
// uc_nation := nation ;
77335: LD_ADDR_OWVAR 21
77339: PUSH
77340: LD_VAR 0 1
77344: ST_TO_ADDR
// bc_level = 1 ;
77345: LD_ADDR_OWVAR 43
77349: PUSH
77350: LD_INT 1
77352: ST_TO_ADDR
// case btype of 1 :
77353: LD_VAR 0 2
77357: PUSH
77358: LD_INT 1
77360: DOUBLE
77361: EQUAL
77362: IFTRUE 77366
77364: GO 77377
77366: POP
// bc_type := b_depot ; 2 :
77367: LD_ADDR_OWVAR 42
77371: PUSH
77372: LD_INT 0
77374: ST_TO_ADDR
77375: GO 77989
77377: LD_INT 2
77379: DOUBLE
77380: EQUAL
77381: IFTRUE 77385
77383: GO 77396
77385: POP
// bc_type := b_warehouse ; 3 :
77386: LD_ADDR_OWVAR 42
77390: PUSH
77391: LD_INT 1
77393: ST_TO_ADDR
77394: GO 77989
77396: LD_INT 3
77398: DOUBLE
77399: EQUAL
77400: IFTRUE 77404
77402: GO 77415
77404: POP
// bc_type := b_lab ; 4 .. 9 :
77405: LD_ADDR_OWVAR 42
77409: PUSH
77410: LD_INT 6
77412: ST_TO_ADDR
77413: GO 77989
77415: LD_INT 4
77417: DOUBLE
77418: GREATEREQUAL
77419: IFFALSE 77427
77421: LD_INT 9
77423: DOUBLE
77424: LESSEQUAL
77425: IFTRUE 77429
77427: GO 77481
77429: POP
// begin bc_type := b_lab_half ;
77430: LD_ADDR_OWVAR 42
77434: PUSH
77435: LD_INT 7
77437: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_opto , b_lab_spacetime , b_lab_biological ] [ btype - 3 ] ;
77438: LD_ADDR_OWVAR 44
77442: PUSH
77443: LD_INT 10
77445: PUSH
77446: LD_INT 11
77448: PUSH
77449: LD_INT 12
77451: PUSH
77452: LD_INT 15
77454: PUSH
77455: LD_INT 14
77457: PUSH
77458: LD_INT 13
77460: PUSH
77461: EMPTY
77462: LIST
77463: LIST
77464: LIST
77465: LIST
77466: LIST
77467: LIST
77468: PUSH
77469: LD_VAR 0 2
77473: PUSH
77474: LD_INT 3
77476: MINUS
77477: ARRAY
77478: ST_TO_ADDR
// end ; 10 .. 13 :
77479: GO 77989
77481: LD_INT 10
77483: DOUBLE
77484: GREATEREQUAL
77485: IFFALSE 77493
77487: LD_INT 13
77489: DOUBLE
77490: LESSEQUAL
77491: IFTRUE 77495
77493: GO 77572
77495: POP
// begin bc_type := b_lab_full ;
77496: LD_ADDR_OWVAR 42
77500: PUSH
77501: LD_INT 8
77503: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_computer , b_lab_spacetime , b_lab_biological ] [ btype - 9 ] ;
77504: LD_ADDR_OWVAR 44
77508: PUSH
77509: LD_INT 10
77511: PUSH
77512: LD_INT 12
77514: PUSH
77515: LD_INT 14
77517: PUSH
77518: LD_INT 13
77520: PUSH
77521: EMPTY
77522: LIST
77523: LIST
77524: LIST
77525: LIST
77526: PUSH
77527: LD_VAR 0 2
77531: PUSH
77532: LD_INT 9
77534: MINUS
77535: ARRAY
77536: ST_TO_ADDR
// bc_kind2 := [ b_lab_siberium , b_lab_opto , b_lab_computer , b_lab_opto ] [ btype - 9 ] ;
77537: LD_ADDR_OWVAR 45
77541: PUSH
77542: LD_INT 11
77544: PUSH
77545: LD_INT 15
77547: PUSH
77548: LD_INT 12
77550: PUSH
77551: LD_INT 15
77553: PUSH
77554: EMPTY
77555: LIST
77556: LIST
77557: LIST
77558: LIST
77559: PUSH
77560: LD_VAR 0 2
77564: PUSH
77565: LD_INT 9
77567: MINUS
77568: ARRAY
77569: ST_TO_ADDR
// end ; 14 :
77570: GO 77989
77572: LD_INT 14
77574: DOUBLE
77575: EQUAL
77576: IFTRUE 77580
77578: GO 77591
77580: POP
// bc_type := b_workshop ; 15 :
77581: LD_ADDR_OWVAR 42
77585: PUSH
77586: LD_INT 2
77588: ST_TO_ADDR
77589: GO 77989
77591: LD_INT 15
77593: DOUBLE
77594: EQUAL
77595: IFTRUE 77599
77597: GO 77610
77599: POP
// bc_type := b_factory ; 16 :
77600: LD_ADDR_OWVAR 42
77604: PUSH
77605: LD_INT 3
77607: ST_TO_ADDR
77608: GO 77989
77610: LD_INT 16
77612: DOUBLE
77613: EQUAL
77614: IFTRUE 77618
77616: GO 77629
77618: POP
// bc_type := b_ext_gun ; 17 :
77619: LD_ADDR_OWVAR 42
77623: PUSH
77624: LD_INT 17
77626: ST_TO_ADDR
77627: GO 77989
77629: LD_INT 17
77631: DOUBLE
77632: EQUAL
77633: IFTRUE 77637
77635: GO 77665
77637: POP
// bc_type := [ b_ext_noncombat , b_ext_stitch , b_ext_noncombat ] [ nation ] ; 18 :
77638: LD_ADDR_OWVAR 42
77642: PUSH
77643: LD_INT 19
77645: PUSH
77646: LD_INT 23
77648: PUSH
77649: LD_INT 19
77651: PUSH
77652: EMPTY
77653: LIST
77654: LIST
77655: LIST
77656: PUSH
77657: LD_VAR 0 1
77661: ARRAY
77662: ST_TO_ADDR
77663: GO 77989
77665: LD_INT 18
77667: DOUBLE
77668: EQUAL
77669: IFTRUE 77673
77671: GO 77684
77673: POP
// bc_type := b_ext_radar ; 19 :
77674: LD_ADDR_OWVAR 42
77678: PUSH
77679: LD_INT 20
77681: ST_TO_ADDR
77682: GO 77989
77684: LD_INT 19
77686: DOUBLE
77687: EQUAL
77688: IFTRUE 77692
77690: GO 77703
77692: POP
// bc_type := b_ext_radio ; 20 :
77693: LD_ADDR_OWVAR 42
77697: PUSH
77698: LD_INT 22
77700: ST_TO_ADDR
77701: GO 77989
77703: LD_INT 20
77705: DOUBLE
77706: EQUAL
77707: IFTRUE 77711
77709: GO 77722
77711: POP
// bc_type := b_ext_siberium ; 21 :
77712: LD_ADDR_OWVAR 42
77716: PUSH
77717: LD_INT 21
77719: ST_TO_ADDR
77720: GO 77989
77722: LD_INT 21
77724: DOUBLE
77725: EQUAL
77726: IFTRUE 77730
77728: GO 77741
77730: POP
// bc_type := b_ext_computer ; 22 :
77731: LD_ADDR_OWVAR 42
77735: PUSH
77736: LD_INT 24
77738: ST_TO_ADDR
77739: GO 77989
77741: LD_INT 22
77743: DOUBLE
77744: EQUAL
77745: IFTRUE 77749
77747: GO 77760
77749: POP
// bc_type := b_ext_track ; 23 :
77750: LD_ADDR_OWVAR 42
77754: PUSH
77755: LD_INT 16
77757: ST_TO_ADDR
77758: GO 77989
77760: LD_INT 23
77762: DOUBLE
77763: EQUAL
77764: IFTRUE 77768
77766: GO 77779
77768: POP
// bc_type := b_ext_laser ; 24 :
77769: LD_ADDR_OWVAR 42
77773: PUSH
77774: LD_INT 25
77776: ST_TO_ADDR
77777: GO 77989
77779: LD_INT 24
77781: DOUBLE
77782: EQUAL
77783: IFTRUE 77787
77785: GO 77798
77787: POP
// bc_type := b_control_tower ; 25 :
77788: LD_ADDR_OWVAR 42
77792: PUSH
77793: LD_INT 36
77795: ST_TO_ADDR
77796: GO 77989
77798: LD_INT 25
77800: DOUBLE
77801: EQUAL
77802: IFTRUE 77806
77804: GO 77817
77806: POP
// bc_type := b_breastwork ; 26 :
77807: LD_ADDR_OWVAR 42
77811: PUSH
77812: LD_INT 31
77814: ST_TO_ADDR
77815: GO 77989
77817: LD_INT 26
77819: DOUBLE
77820: EQUAL
77821: IFTRUE 77825
77823: GO 77836
77825: POP
// bc_type := b_bunker ; 27 :
77826: LD_ADDR_OWVAR 42
77830: PUSH
77831: LD_INT 32
77833: ST_TO_ADDR
77834: GO 77989
77836: LD_INT 27
77838: DOUBLE
77839: EQUAL
77840: IFTRUE 77844
77842: GO 77855
77844: POP
// bc_type := b_turret ; 28 :
77845: LD_ADDR_OWVAR 42
77849: PUSH
77850: LD_INT 33
77852: ST_TO_ADDR
77853: GO 77989
77855: LD_INT 28
77857: DOUBLE
77858: EQUAL
77859: IFTRUE 77863
77861: GO 77874
77863: POP
// bc_type := b_armoury ; 29 :
77864: LD_ADDR_OWVAR 42
77868: PUSH
77869: LD_INT 4
77871: ST_TO_ADDR
77872: GO 77989
77874: LD_INT 29
77876: DOUBLE
77877: EQUAL
77878: IFTRUE 77882
77880: GO 77893
77882: POP
// bc_type := b_barracks ; 30 :
77883: LD_ADDR_OWVAR 42
77887: PUSH
77888: LD_INT 5
77890: ST_TO_ADDR
77891: GO 77989
77893: LD_INT 30
77895: DOUBLE
77896: EQUAL
77897: IFTRUE 77901
77899: GO 77912
77901: POP
// bc_type := b_solar_power ; 31 :
77902: LD_ADDR_OWVAR 42
77906: PUSH
77907: LD_INT 27
77909: ST_TO_ADDR
77910: GO 77989
77912: LD_INT 31
77914: DOUBLE
77915: EQUAL
77916: IFTRUE 77920
77918: GO 77931
77920: POP
// bc_type := b_oil_power ; 32 :
77921: LD_ADDR_OWVAR 42
77925: PUSH
77926: LD_INT 26
77928: ST_TO_ADDR
77929: GO 77989
77931: LD_INT 32
77933: DOUBLE
77934: EQUAL
77935: IFTRUE 77939
77937: GO 77950
77939: POP
// bc_type := b_siberite_power ; 33 :
77940: LD_ADDR_OWVAR 42
77944: PUSH
77945: LD_INT 28
77947: ST_TO_ADDR
77948: GO 77989
77950: LD_INT 33
77952: DOUBLE
77953: EQUAL
77954: IFTRUE 77958
77956: GO 77969
77958: POP
// bc_type := b_oil_mine ; 34 :
77959: LD_ADDR_OWVAR 42
77963: PUSH
77964: LD_INT 29
77966: ST_TO_ADDR
77967: GO 77989
77969: LD_INT 34
77971: DOUBLE
77972: EQUAL
77973: IFTRUE 77977
77975: GO 77988
77977: POP
// bc_type := b_siberite_mine ; end ;
77978: LD_ADDR_OWVAR 42
77982: PUSH
77983: LD_INT 30
77985: ST_TO_ADDR
77986: GO 77989
77988: POP
// b := CreateAndPlaceBuildingXYD ( x , y , dir ) ;
77989: LD_ADDR_VAR 0 8
77993: PUSH
77994: LD_VAR 0 5
77998: PPUSH
77999: LD_VAR 0 6
78003: PPUSH
78004: LD_VAR 0 3
78008: PPUSH
78009: CALL_OW 47
78013: ST_TO_ADDR
// if bc_type in [ b_bunker , b_turret ] then
78014: LD_OWVAR 42
78018: PUSH
78019: LD_INT 32
78021: PUSH
78022: LD_INT 33
78024: PUSH
78025: EMPTY
78026: LIST
78027: LIST
78028: IN
78029: IFFALSE 78045
// PlaceWeaponTurret ( b , weapon ) ;
78031: LD_VAR 0 8
78035: PPUSH
78036: LD_VAR 0 4
78040: PPUSH
78041: CALL_OW 431
// end ;
78045: LD_VAR 0 7
78049: RET
// export function hHackUnlimitedResources ; var i , j , tmp ; begin
78050: LD_INT 0
78052: PPUSH
78053: PPUSH
78054: PPUSH
78055: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
78056: LD_ADDR_VAR 0 4
78060: PUSH
78061: LD_INT 22
78063: PUSH
78064: LD_OWVAR 2
78068: PUSH
78069: EMPTY
78070: LIST
78071: LIST
78072: PUSH
78073: LD_INT 2
78075: PUSH
78076: LD_INT 30
78078: PUSH
78079: LD_INT 0
78081: PUSH
78082: EMPTY
78083: LIST
78084: LIST
78085: PUSH
78086: LD_INT 30
78088: PUSH
78089: LD_INT 1
78091: PUSH
78092: EMPTY
78093: LIST
78094: LIST
78095: PUSH
78096: EMPTY
78097: LIST
78098: LIST
78099: LIST
78100: PUSH
78101: EMPTY
78102: LIST
78103: LIST
78104: PPUSH
78105: CALL_OW 69
78109: ST_TO_ADDR
// if not tmp then
78110: LD_VAR 0 4
78114: NOT
78115: IFFALSE 78119
// exit ;
78117: GO 78178
// for i in tmp do
78119: LD_ADDR_VAR 0 2
78123: PUSH
78124: LD_VAR 0 4
78128: PUSH
78129: FOR_IN
78130: IFFALSE 78176
// for j = 1 to 3 do
78132: LD_ADDR_VAR 0 3
78136: PUSH
78137: DOUBLE
78138: LD_INT 1
78140: DEC
78141: ST_TO_ADDR
78142: LD_INT 3
78144: PUSH
78145: FOR_TO
78146: IFFALSE 78172
// SetResourceType ( GetBase ( i ) , j , 99999 ) ;
78148: LD_VAR 0 2
78152: PPUSH
78153: CALL_OW 274
78157: PPUSH
78158: LD_VAR 0 3
78162: PPUSH
78163: LD_INT 99999
78165: PPUSH
78166: CALL_OW 277
78170: GO 78145
78172: POP
78173: POP
78174: GO 78129
78176: POP
78177: POP
// end ;
78178: LD_VAR 0 1
78182: RET
// export function hHackSetLevel10 ; var i , j ; begin
78183: LD_INT 0
78185: PPUSH
78186: PPUSH
78187: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
78188: LD_ADDR_VAR 0 2
78192: PUSH
78193: LD_INT 21
78195: PUSH
78196: LD_INT 1
78198: PUSH
78199: EMPTY
78200: LIST
78201: LIST
78202: PPUSH
78203: CALL_OW 69
78207: PUSH
78208: FOR_IN
78209: IFFALSE 78261
// if IsSelected ( i ) then
78211: LD_VAR 0 2
78215: PPUSH
78216: CALL_OW 306
78220: IFFALSE 78259
// begin for j := 1 to 4 do
78222: LD_ADDR_VAR 0 3
78226: PUSH
78227: DOUBLE
78228: LD_INT 1
78230: DEC
78231: ST_TO_ADDR
78232: LD_INT 4
78234: PUSH
78235: FOR_TO
78236: IFFALSE 78257
// SetSkill ( i , j , 10 ) ;
78238: LD_VAR 0 2
78242: PPUSH
78243: LD_VAR 0 3
78247: PPUSH
78248: LD_INT 10
78250: PPUSH
78251: CALL_OW 237
78255: GO 78235
78257: POP
78258: POP
// end ;
78259: GO 78208
78261: POP
78262: POP
// end ;
78263: LD_VAR 0 1
78267: RET
// export function hHackSetLevel10YourUnits ; var i , j ; begin
78268: LD_INT 0
78270: PPUSH
78271: PPUSH
78272: PPUSH
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) do
78273: LD_ADDR_VAR 0 2
78277: PUSH
78278: LD_INT 22
78280: PUSH
78281: LD_OWVAR 2
78285: PUSH
78286: EMPTY
78287: LIST
78288: LIST
78289: PUSH
78290: LD_INT 21
78292: PUSH
78293: LD_INT 1
78295: PUSH
78296: EMPTY
78297: LIST
78298: LIST
78299: PUSH
78300: EMPTY
78301: LIST
78302: LIST
78303: PPUSH
78304: CALL_OW 69
78308: PUSH
78309: FOR_IN
78310: IFFALSE 78351
// begin for j := 1 to 4 do
78312: LD_ADDR_VAR 0 3
78316: PUSH
78317: DOUBLE
78318: LD_INT 1
78320: DEC
78321: ST_TO_ADDR
78322: LD_INT 4
78324: PUSH
78325: FOR_TO
78326: IFFALSE 78347
// SetSkill ( i , j , 10 ) ;
78328: LD_VAR 0 2
78332: PPUSH
78333: LD_VAR 0 3
78337: PPUSH
78338: LD_INT 10
78340: PPUSH
78341: CALL_OW 237
78345: GO 78325
78347: POP
78348: POP
// end ;
78349: GO 78309
78351: POP
78352: POP
// end ;
78353: LD_VAR 0 1
78357: RET
// export function hHackSpawnHuman ( nation , class , skill , x , y ) ; begin
78358: LD_INT 0
78360: PPUSH
// uc_side := your_side ;
78361: LD_ADDR_OWVAR 20
78365: PUSH
78366: LD_OWVAR 2
78370: ST_TO_ADDR
// uc_nation := nation ;
78371: LD_ADDR_OWVAR 21
78375: PUSH
78376: LD_VAR 0 1
78380: ST_TO_ADDR
// InitHc ;
78381: CALL_OW 19
// PrepareHuman ( false , class , skill ) ;
78385: LD_INT 0
78387: PPUSH
78388: LD_VAR 0 2
78392: PPUSH
78393: LD_VAR 0 3
78397: PPUSH
78398: CALL_OW 380
// if HexInfo ( x , y ) = 0 then
78402: LD_VAR 0 4
78406: PPUSH
78407: LD_VAR 0 5
78411: PPUSH
78412: CALL_OW 428
78416: PUSH
78417: LD_INT 0
78419: EQUAL
78420: IFFALSE 78444
// PlaceUnitXY ( CreateHuman , x , y , true ) ;
78422: CALL_OW 44
78426: PPUSH
78427: LD_VAR 0 4
78431: PPUSH
78432: LD_VAR 0 5
78436: PPUSH
78437: LD_INT 1
78439: PPUSH
78440: CALL_OW 48
// end ;
78444: LD_VAR 0 6
78448: RET
// export function hHackSpawnVehicle ( chassis , engine , control , weapon , x , y ) ; var un ; begin
78449: LD_INT 0
78451: PPUSH
78452: PPUSH
// uc_side := your_side ;
78453: LD_ADDR_OWVAR 20
78457: PUSH
78458: LD_OWVAR 2
78462: ST_TO_ADDR
// if chassis in [ 1 , 2 , 3 , 4 , 5 ] then
78463: LD_VAR 0 1
78467: PUSH
78468: LD_INT 1
78470: PUSH
78471: LD_INT 2
78473: PUSH
78474: LD_INT 3
78476: PUSH
78477: LD_INT 4
78479: PUSH
78480: LD_INT 5
78482: PUSH
78483: EMPTY
78484: LIST
78485: LIST
78486: LIST
78487: LIST
78488: LIST
78489: IN
78490: IFFALSE 78502
// uc_nation := nation_american else
78492: LD_ADDR_OWVAR 21
78496: PUSH
78497: LD_INT 1
78499: ST_TO_ADDR
78500: GO 78545
// if chassis in [ 11 , 12 , 13 , 14 ] then
78502: LD_VAR 0 1
78506: PUSH
78507: LD_INT 11
78509: PUSH
78510: LD_INT 12
78512: PUSH
78513: LD_INT 13
78515: PUSH
78516: LD_INT 14
78518: PUSH
78519: EMPTY
78520: LIST
78521: LIST
78522: LIST
78523: LIST
78524: IN
78525: IFFALSE 78537
// uc_nation := nation_arabian else
78527: LD_ADDR_OWVAR 21
78531: PUSH
78532: LD_INT 2
78534: ST_TO_ADDR
78535: GO 78545
// uc_nation := nation_russian ;
78537: LD_ADDR_OWVAR 21
78541: PUSH
78542: LD_INT 3
78544: ST_TO_ADDR
// vc_chassis := chassis ;
78545: LD_ADDR_OWVAR 37
78549: PUSH
78550: LD_VAR 0 1
78554: ST_TO_ADDR
// vc_engine := engine ;
78555: LD_ADDR_OWVAR 39
78559: PUSH
78560: LD_VAR 0 2
78564: ST_TO_ADDR
// vc_control := control ;
78565: LD_ADDR_OWVAR 38
78569: PUSH
78570: LD_VAR 0 3
78574: ST_TO_ADDR
// vc_weapon := weapon ;
78575: LD_ADDR_OWVAR 40
78579: PUSH
78580: LD_VAR 0 4
78584: ST_TO_ADDR
// un := CreateVehicle ;
78585: LD_ADDR_VAR 0 8
78589: PUSH
78590: CALL_OW 45
78594: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
78595: LD_VAR 0 8
78599: PPUSH
78600: LD_INT 0
78602: PPUSH
78603: LD_INT 5
78605: PPUSH
78606: CALL_OW 12
78610: PPUSH
78611: CALL_OW 233
// PlaceUnitXY ( un , x , y , true ) ;
78615: LD_VAR 0 8
78619: PPUSH
78620: LD_VAR 0 5
78624: PPUSH
78625: LD_VAR 0 6
78629: PPUSH
78630: LD_INT 1
78632: PPUSH
78633: CALL_OW 48
// end ;
78637: LD_VAR 0 7
78641: RET
// export hInvincible ; every 1 do
78642: GO 78644
78644: DISABLE
// hInvincible := [ ] ;
78645: LD_ADDR_EXP 154
78649: PUSH
78650: EMPTY
78651: ST_TO_ADDR
78652: END
// every 10 do var i ;
78653: GO 78655
78655: DISABLE
78656: LD_INT 0
78658: PPUSH
// begin enable ;
78659: ENABLE
// if not hInvincible then
78660: LD_EXP 154
78664: NOT
78665: IFFALSE 78669
// exit ;
78667: GO 78713
// for i in hInvincible do
78669: LD_ADDR_VAR 0 1
78673: PUSH
78674: LD_EXP 154
78678: PUSH
78679: FOR_IN
78680: IFFALSE 78711
// if GetLives ( i ) < 1000 then
78682: LD_VAR 0 1
78686: PPUSH
78687: CALL_OW 256
78691: PUSH
78692: LD_INT 1000
78694: LESS
78695: IFFALSE 78709
// SetLives ( i , 1000 ) ;
78697: LD_VAR 0 1
78701: PPUSH
78702: LD_INT 1000
78704: PPUSH
78705: CALL_OW 234
78709: GO 78679
78711: POP
78712: POP
// end ;
78713: PPOPN 1
78715: END
// export function hHackInvincible ; var i ; begin
78716: LD_INT 0
78718: PPUSH
78719: PPUSH
// for i in FilterAllUnits ( [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ) do
78720: LD_ADDR_VAR 0 2
78724: PUSH
78725: LD_INT 2
78727: PUSH
78728: LD_INT 21
78730: PUSH
78731: LD_INT 1
78733: PUSH
78734: EMPTY
78735: LIST
78736: LIST
78737: PUSH
78738: LD_INT 21
78740: PUSH
78741: LD_INT 2
78743: PUSH
78744: EMPTY
78745: LIST
78746: LIST
78747: PUSH
78748: EMPTY
78749: LIST
78750: LIST
78751: LIST
78752: PPUSH
78753: CALL_OW 69
78757: PUSH
78758: FOR_IN
78759: IFFALSE 78820
// if IsSelected ( i ) then
78761: LD_VAR 0 2
78765: PPUSH
78766: CALL_OW 306
78770: IFFALSE 78818
// begin if i in hInvincible then
78772: LD_VAR 0 2
78776: PUSH
78777: LD_EXP 154
78781: IN
78782: IFFALSE 78802
// hInvincible := hInvincible diff i else
78784: LD_ADDR_EXP 154
78788: PUSH
78789: LD_EXP 154
78793: PUSH
78794: LD_VAR 0 2
78798: DIFF
78799: ST_TO_ADDR
78800: GO 78818
// hInvincible := hInvincible union i ;
78802: LD_ADDR_EXP 154
78806: PUSH
78807: LD_EXP 154
78811: PUSH
78812: LD_VAR 0 2
78816: UNION
78817: ST_TO_ADDR
// end ;
78818: GO 78758
78820: POP
78821: POP
// end ;
78822: LD_VAR 0 1
78826: RET
// export function hHackInvisible ; var i , j ; begin
78827: LD_INT 0
78829: PPUSH
78830: PPUSH
78831: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
78832: LD_ADDR_VAR 0 2
78836: PUSH
78837: LD_INT 21
78839: PUSH
78840: LD_INT 1
78842: PUSH
78843: EMPTY
78844: LIST
78845: LIST
78846: PPUSH
78847: CALL_OW 69
78851: PUSH
78852: FOR_IN
78853: IFFALSE 78877
// if IsSelected ( i ) then
78855: LD_VAR 0 2
78859: PPUSH
78860: CALL_OW 306
78864: IFFALSE 78875
// ComForceInvisible ( i ) ;
78866: LD_VAR 0 2
78870: PPUSH
78871: CALL_OW 496
78875: GO 78852
78877: POP
78878: POP
// end ;
78879: LD_VAR 0 1
78883: RET
// export function hHackChangeYourSide ; begin
78884: LD_INT 0
78886: PPUSH
// if your_side = 8 then
78887: LD_OWVAR 2
78891: PUSH
78892: LD_INT 8
78894: EQUAL
78895: IFFALSE 78907
// your_side := 0 else
78897: LD_ADDR_OWVAR 2
78901: PUSH
78902: LD_INT 0
78904: ST_TO_ADDR
78905: GO 78921
// your_side := your_side + 1 ;
78907: LD_ADDR_OWVAR 2
78911: PUSH
78912: LD_OWVAR 2
78916: PUSH
78917: LD_INT 1
78919: PLUS
78920: ST_TO_ADDR
// end ;
78921: LD_VAR 0 1
78925: RET
// export function hHackChangeUnitSide ; var i , j ; begin
78926: LD_INT 0
78928: PPUSH
78929: PPUSH
78930: PPUSH
// for i in all_units do
78931: LD_ADDR_VAR 0 2
78935: PUSH
78936: LD_OWVAR 3
78940: PUSH
78941: FOR_IN
78942: IFFALSE 79020
// if IsSelected ( i ) then
78944: LD_VAR 0 2
78948: PPUSH
78949: CALL_OW 306
78953: IFFALSE 79018
// begin j := GetSide ( i ) ;
78955: LD_ADDR_VAR 0 3
78959: PUSH
78960: LD_VAR 0 2
78964: PPUSH
78965: CALL_OW 255
78969: ST_TO_ADDR
// if j = 8 then
78970: LD_VAR 0 3
78974: PUSH
78975: LD_INT 8
78977: EQUAL
78978: IFFALSE 78990
// j := 0 else
78980: LD_ADDR_VAR 0 3
78984: PUSH
78985: LD_INT 0
78987: ST_TO_ADDR
78988: GO 79004
// j := j + 1 ;
78990: LD_ADDR_VAR 0 3
78994: PUSH
78995: LD_VAR 0 3
78999: PUSH
79000: LD_INT 1
79002: PLUS
79003: ST_TO_ADDR
// SetSide ( i , j ) ;
79004: LD_VAR 0 2
79008: PPUSH
79009: LD_VAR 0 3
79013: PPUSH
79014: CALL_OW 235
// end ;
79018: GO 78941
79020: POP
79021: POP
// end ;
79022: LD_VAR 0 1
79026: RET
// export function hHackFog ; begin
79027: LD_INT 0
79029: PPUSH
// FogOff ( true ) ;
79030: LD_INT 1
79032: PPUSH
79033: CALL_OW 344
// end ;
79037: LD_VAR 0 1
79041: RET
// export function hHackTeleport ( unit , x , y ) ; begin
79042: LD_INT 0
79044: PPUSH
// TeleportUnit ( unit , x , y , 1 , true ) ;
79045: LD_VAR 0 1
79049: PPUSH
79050: LD_VAR 0 2
79054: PPUSH
79055: LD_VAR 0 3
79059: PPUSH
79060: LD_INT 1
79062: PPUSH
79063: LD_INT 1
79065: PPUSH
79066: CALL_OW 483
// CenterOnXY ( x , y ) ;
79070: LD_VAR 0 2
79074: PPUSH
79075: LD_VAR 0 3
79079: PPUSH
79080: CALL_OW 84
// end ;
79084: LD_VAR 0 4
79088: RET
// export factoryWaypoints ; export function SetFactoryWaypoint ( factory , x , y ) ; var i ; begin
79089: LD_INT 0
79091: PPUSH
79092: PPUSH
// if not factory or not ValidHex ( x , y ) or ( GetBType ( factory ) <> b_factory and not GetType ( factory ) = unit_human ) then
79093: LD_VAR 0 1
79097: NOT
79098: PUSH
79099: LD_VAR 0 2
79103: PPUSH
79104: LD_VAR 0 3
79108: PPUSH
79109: CALL_OW 488
79113: NOT
79114: OR
79115: PUSH
79116: LD_VAR 0 1
79120: PPUSH
79121: CALL_OW 266
79125: PUSH
79126: LD_INT 3
79128: NONEQUAL
79129: PUSH
79130: LD_VAR 0 1
79134: PPUSH
79135: CALL_OW 247
79139: PUSH
79140: LD_INT 1
79142: EQUAL
79143: NOT
79144: AND
79145: OR
79146: IFFALSE 79150
// exit ;
79148: GO 79299
// if GetType ( factory ) = unit_human then
79150: LD_VAR 0 1
79154: PPUSH
79155: CALL_OW 247
79159: PUSH
79160: LD_INT 1
79162: EQUAL
79163: IFFALSE 79180
// factory := IsInUnit ( factory ) ;
79165: LD_ADDR_VAR 0 1
79169: PUSH
79170: LD_VAR 0 1
79174: PPUSH
79175: CALL_OW 310
79179: ST_TO_ADDR
// if GetBType ( factory ) <> b_factory then
79180: LD_VAR 0 1
79184: PPUSH
79185: CALL_OW 266
79189: PUSH
79190: LD_INT 3
79192: NONEQUAL
79193: IFFALSE 79197
// exit ;
79195: GO 79299
// if HexInfo ( x , y ) = factory then
79197: LD_VAR 0 2
79201: PPUSH
79202: LD_VAR 0 3
79206: PPUSH
79207: CALL_OW 428
79211: PUSH
79212: LD_VAR 0 1
79216: EQUAL
79217: IFFALSE 79244
// factoryWaypoints := Replace ( factoryWaypoints , factory , 0 ) else
79219: LD_ADDR_EXP 155
79223: PUSH
79224: LD_EXP 155
79228: PPUSH
79229: LD_VAR 0 1
79233: PPUSH
79234: LD_INT 0
79236: PPUSH
79237: CALL_OW 1
79241: ST_TO_ADDR
79242: GO 79295
// factoryWaypoints := Replace ( factoryWaypoints , factory , [ GetSide ( factory ) , factory , x , y ] ) ;
79244: LD_ADDR_EXP 155
79248: PUSH
79249: LD_EXP 155
79253: PPUSH
79254: LD_VAR 0 1
79258: PPUSH
79259: LD_VAR 0 1
79263: PPUSH
79264: CALL_OW 255
79268: PUSH
79269: LD_VAR 0 1
79273: PUSH
79274: LD_VAR 0 2
79278: PUSH
79279: LD_VAR 0 3
79283: PUSH
79284: EMPTY
79285: LIST
79286: LIST
79287: LIST
79288: LIST
79289: PPUSH
79290: CALL_OW 1
79294: ST_TO_ADDR
// UpdateFactoryWaypoints ;
79295: CALL 79304 0 0
// end ;
79299: LD_VAR 0 4
79303: RET
// export function UpdateFactoryWaypoints ( ) ; var i , list ; begin
79304: LD_INT 0
79306: PPUSH
79307: PPUSH
79308: PPUSH
// ToLua ( resetFactoryWaypoint(); ) ;
79309: LD_STRING resetFactoryWaypoint();
79311: PPUSH
79312: CALL_OW 559
// if factoryWaypoints then
79316: LD_EXP 155
79320: IFFALSE 79446
// begin list := PrepareArray ( factoryWaypoints ) ;
79322: LD_ADDR_VAR 0 3
79326: PUSH
79327: LD_EXP 155
79331: PPUSH
79332: CALL 60389 0 1
79336: ST_TO_ADDR
// for i := 1 to list do
79337: LD_ADDR_VAR 0 2
79341: PUSH
79342: DOUBLE
79343: LD_INT 1
79345: DEC
79346: ST_TO_ADDR
79347: LD_VAR 0 3
79351: PUSH
79352: FOR_TO
79353: IFFALSE 79444
// ToLua ( setFactoryWaypointXY( & list [ i ] [ 1 ] & , & list [ i ] [ 2 ] & , & list [ i ] [ 3 ] & , & list [ i ] [ 4 ] & ) ) ;
79355: LD_STRING setFactoryWaypointXY(
79357: PUSH
79358: LD_VAR 0 3
79362: PUSH
79363: LD_VAR 0 2
79367: ARRAY
79368: PUSH
79369: LD_INT 1
79371: ARRAY
79372: STR
79373: PUSH
79374: LD_STRING ,
79376: STR
79377: PUSH
79378: LD_VAR 0 3
79382: PUSH
79383: LD_VAR 0 2
79387: ARRAY
79388: PUSH
79389: LD_INT 2
79391: ARRAY
79392: STR
79393: PUSH
79394: LD_STRING ,
79396: STR
79397: PUSH
79398: LD_VAR 0 3
79402: PUSH
79403: LD_VAR 0 2
79407: ARRAY
79408: PUSH
79409: LD_INT 3
79411: ARRAY
79412: STR
79413: PUSH
79414: LD_STRING ,
79416: STR
79417: PUSH
79418: LD_VAR 0 3
79422: PUSH
79423: LD_VAR 0 2
79427: ARRAY
79428: PUSH
79429: LD_INT 4
79431: ARRAY
79432: STR
79433: PUSH
79434: LD_STRING )
79436: STR
79437: PPUSH
79438: CALL_OW 559
79442: GO 79352
79444: POP
79445: POP
// end ; end ;
79446: LD_VAR 0 1
79450: RET
// export warehouseGatheringPoints , warehouseCratesCollectors ; export function SetWarehouseGatheringPoint ( warehouse , x , y ) ; begin
79451: LD_INT 0
79453: PPUSH
// if HexInfo ( x , y ) = warehouse then
79454: LD_VAR 0 2
79458: PPUSH
79459: LD_VAR 0 3
79463: PPUSH
79464: CALL_OW 428
79468: PUSH
79469: LD_VAR 0 1
79473: EQUAL
79474: IFFALSE 79501
// warehouseGatheringPoints := Replace ( warehouseGatheringPoints , warehouse , 0 ) else
79476: LD_ADDR_EXP 156
79480: PUSH
79481: LD_EXP 156
79485: PPUSH
79486: LD_VAR 0 1
79490: PPUSH
79491: LD_INT 0
79493: PPUSH
79494: CALL_OW 1
79498: ST_TO_ADDR
79499: GO 79552
// warehouseGatheringPoints := Replace ( warehouseGatheringPoints , warehouse , [ GetSide ( warehouse ) , warehouse , x , y ] ) ;
79501: LD_ADDR_EXP 156
79505: PUSH
79506: LD_EXP 156
79510: PPUSH
79511: LD_VAR 0 1
79515: PPUSH
79516: LD_VAR 0 1
79520: PPUSH
79521: CALL_OW 255
79525: PUSH
79526: LD_VAR 0 1
79530: PUSH
79531: LD_VAR 0 2
79535: PUSH
79536: LD_VAR 0 3
79540: PUSH
79541: EMPTY
79542: LIST
79543: LIST
79544: LIST
79545: LIST
79546: PPUSH
79547: CALL_OW 1
79551: ST_TO_ADDR
// UpdateWarehouseGatheringPoints ;
79552: CALL 79561 0 0
// end ;
79556: LD_VAR 0 4
79560: RET
// export function UpdateWarehouseGatheringPoints ( ) ; var i , list ; begin
79561: LD_INT 0
79563: PPUSH
79564: PPUSH
79565: PPUSH
// ToLua ( resetWarehouseGatheringPoints(); ) ;
79566: LD_STRING resetWarehouseGatheringPoints();
79568: PPUSH
79569: CALL_OW 559
// if warehouseGatheringPoints then
79573: LD_EXP 156
79577: IFFALSE 79703
// begin list := PrepareArray ( warehouseGatheringPoints ) ;
79579: LD_ADDR_VAR 0 3
79583: PUSH
79584: LD_EXP 156
79588: PPUSH
79589: CALL 60389 0 1
79593: ST_TO_ADDR
// for i := 1 to list do
79594: LD_ADDR_VAR 0 2
79598: PUSH
79599: DOUBLE
79600: LD_INT 1
79602: DEC
79603: ST_TO_ADDR
79604: LD_VAR 0 3
79608: PUSH
79609: FOR_TO
79610: IFFALSE 79701
// ToLua ( setWarehouseGatheringPointXY( & list [ i ] [ 1 ] & , & list [ i ] [ 2 ] & , & list [ i ] [ 3 ] & , & list [ i ] [ 4 ] & ) ) ;
79612: LD_STRING setWarehouseGatheringPointXY(
79614: PUSH
79615: LD_VAR 0 3
79619: PUSH
79620: LD_VAR 0 2
79624: ARRAY
79625: PUSH
79626: LD_INT 1
79628: ARRAY
79629: STR
79630: PUSH
79631: LD_STRING ,
79633: STR
79634: PUSH
79635: LD_VAR 0 3
79639: PUSH
79640: LD_VAR 0 2
79644: ARRAY
79645: PUSH
79646: LD_INT 2
79648: ARRAY
79649: STR
79650: PUSH
79651: LD_STRING ,
79653: STR
79654: PUSH
79655: LD_VAR 0 3
79659: PUSH
79660: LD_VAR 0 2
79664: ARRAY
79665: PUSH
79666: LD_INT 3
79668: ARRAY
79669: STR
79670: PUSH
79671: LD_STRING ,
79673: STR
79674: PUSH
79675: LD_VAR 0 3
79679: PUSH
79680: LD_VAR 0 2
79684: ARRAY
79685: PUSH
79686: LD_INT 4
79688: ARRAY
79689: STR
79690: PUSH
79691: LD_STRING )
79693: STR
79694: PPUSH
79695: CALL_OW 559
79699: GO 79609
79701: POP
79702: POP
// end ; end ;
79703: LD_VAR 0 1
79707: RET
// every 0 0$20 trigger warehouseGatheringPoints do var i , j , list , tmp , side , x , y , depot , cratesNearbyPoint ;
79708: LD_EXP 156
79712: IFFALSE 80399
79714: GO 79716
79716: DISABLE
79717: LD_INT 0
79719: PPUSH
79720: PPUSH
79721: PPUSH
79722: PPUSH
79723: PPUSH
79724: PPUSH
79725: PPUSH
79726: PPUSH
79727: PPUSH
// begin enable ;
79728: ENABLE
// list := PrepareArray ( warehouseGatheringPoints ) ;
79729: LD_ADDR_VAR 0 3
79733: PUSH
79734: LD_EXP 156
79738: PPUSH
79739: CALL 60389 0 1
79743: ST_TO_ADDR
// if not list then
79744: LD_VAR 0 3
79748: NOT
79749: IFFALSE 79753
// exit ;
79751: GO 80399
// for i := 1 to list do
79753: LD_ADDR_VAR 0 1
79757: PUSH
79758: DOUBLE
79759: LD_INT 1
79761: DEC
79762: ST_TO_ADDR
79763: LD_VAR 0 3
79767: PUSH
79768: FOR_TO
79769: IFFALSE 80397
// begin depot := list [ i ] [ 2 ] ;
79771: LD_ADDR_VAR 0 8
79775: PUSH
79776: LD_VAR 0 3
79780: PUSH
79781: LD_VAR 0 1
79785: ARRAY
79786: PUSH
79787: LD_INT 2
79789: ARRAY
79790: ST_TO_ADDR
// side := list [ i ] [ 1 ] ;
79791: LD_ADDR_VAR 0 5
79795: PUSH
79796: LD_VAR 0 3
79800: PUSH
79801: LD_VAR 0 1
79805: ARRAY
79806: PUSH
79807: LD_INT 1
79809: ARRAY
79810: ST_TO_ADDR
// if IsDead ( depot ) or side <> GetSide ( depot ) then
79811: LD_VAR 0 8
79815: PPUSH
79816: CALL_OW 301
79820: PUSH
79821: LD_VAR 0 5
79825: PUSH
79826: LD_VAR 0 8
79830: PPUSH
79831: CALL_OW 255
79835: NONEQUAL
79836: OR
79837: IFFALSE 79866
// begin warehouseGatheringPoints := Replace ( warehouseGatheringPoints , depot , 0 ) ;
79839: LD_ADDR_EXP 156
79843: PUSH
79844: LD_EXP 156
79848: PPUSH
79849: LD_VAR 0 8
79853: PPUSH
79854: LD_INT 0
79856: PPUSH
79857: CALL_OW 1
79861: ST_TO_ADDR
// exit ;
79862: POP
79863: POP
79864: GO 80399
// end ; x := list [ i ] [ 3 ] ;
79866: LD_ADDR_VAR 0 6
79870: PUSH
79871: LD_VAR 0 3
79875: PUSH
79876: LD_VAR 0 1
79880: ARRAY
79881: PUSH
79882: LD_INT 3
79884: ARRAY
79885: ST_TO_ADDR
// y := list [ i ] [ 4 ] ;
79886: LD_ADDR_VAR 0 7
79890: PUSH
79891: LD_VAR 0 3
79895: PUSH
79896: LD_VAR 0 1
79900: ARRAY
79901: PUSH
79902: LD_INT 4
79904: ARRAY
79905: ST_TO_ADDR
// cratesNearbyPoint := GetCratesNearbyXY ( x , y , 16 ) ;
79906: LD_ADDR_VAR 0 9
79910: PUSH
79911: LD_VAR 0 6
79915: PPUSH
79916: LD_VAR 0 7
79920: PPUSH
79921: LD_INT 16
79923: PPUSH
79924: CALL 58973 0 3
79928: ST_TO_ADDR
// if not cratesNearbyPoint then
79929: LD_VAR 0 9
79933: NOT
79934: IFFALSE 79940
// exit ;
79936: POP
79937: POP
79938: GO 80399
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_hastask ] ] , [ f_dist , depot , 6 ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] ] ] ) union UnitFilter ( UnitsInside ( depot ) , [ [ f_not , [ f_hastask ] ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] ] ] ) ;
79940: LD_ADDR_VAR 0 4
79944: PUSH
79945: LD_INT 22
79947: PUSH
79948: LD_VAR 0 5
79952: PUSH
79953: EMPTY
79954: LIST
79955: LIST
79956: PUSH
79957: LD_INT 3
79959: PUSH
79960: LD_INT 60
79962: PUSH
79963: EMPTY
79964: LIST
79965: PUSH
79966: EMPTY
79967: LIST
79968: LIST
79969: PUSH
79970: LD_INT 91
79972: PUSH
79973: LD_VAR 0 8
79977: PUSH
79978: LD_INT 6
79980: PUSH
79981: EMPTY
79982: LIST
79983: LIST
79984: LIST
79985: PUSH
79986: LD_INT 2
79988: PUSH
79989: LD_INT 25
79991: PUSH
79992: LD_INT 2
79994: PUSH
79995: EMPTY
79996: LIST
79997: LIST
79998: PUSH
79999: LD_INT 25
80001: PUSH
80002: LD_INT 16
80004: PUSH
80005: EMPTY
80006: LIST
80007: LIST
80008: PUSH
80009: EMPTY
80010: LIST
80011: LIST
80012: LIST
80013: PUSH
80014: EMPTY
80015: LIST
80016: LIST
80017: LIST
80018: LIST
80019: PPUSH
80020: CALL_OW 69
80024: PUSH
80025: LD_VAR 0 8
80029: PPUSH
80030: CALL_OW 313
80034: PPUSH
80035: LD_INT 3
80037: PUSH
80038: LD_INT 60
80040: PUSH
80041: EMPTY
80042: LIST
80043: PUSH
80044: EMPTY
80045: LIST
80046: LIST
80047: PUSH
80048: LD_INT 2
80050: PUSH
80051: LD_INT 25
80053: PUSH
80054: LD_INT 2
80056: PUSH
80057: EMPTY
80058: LIST
80059: LIST
80060: PUSH
80061: LD_INT 25
80063: PUSH
80064: LD_INT 16
80066: PUSH
80067: EMPTY
80068: LIST
80069: LIST
80070: PUSH
80071: EMPTY
80072: LIST
80073: LIST
80074: LIST
80075: PUSH
80076: EMPTY
80077: LIST
80078: LIST
80079: PPUSH
80080: CALL_OW 72
80084: UNION
80085: ST_TO_ADDR
// if tmp then
80086: LD_VAR 0 4
80090: IFFALSE 80170
// begin tmp := ShrinkArray ( tmp , 3 ) ;
80092: LD_ADDR_VAR 0 4
80096: PUSH
80097: LD_VAR 0 4
80101: PPUSH
80102: LD_INT 3
80104: PPUSH
80105: CALL 56940 0 2
80109: ST_TO_ADDR
// for j in tmp do
80110: LD_ADDR_VAR 0 2
80114: PUSH
80115: LD_VAR 0 4
80119: PUSH
80120: FOR_IN
80121: IFFALSE 80164
// begin if IsInUnit ( j ) then
80123: LD_VAR 0 2
80127: PPUSH
80128: CALL_OW 310
80132: IFFALSE 80143
// ComExit ( j ) ;
80134: LD_VAR 0 2
80138: PPUSH
80139: CALL 57023 0 1
// AddComCollect ( j , x , y ) ;
80143: LD_VAR 0 2
80147: PPUSH
80148: LD_VAR 0 6
80152: PPUSH
80153: LD_VAR 0 7
80157: PPUSH
80158: CALL_OW 177
// end ;
80162: GO 80120
80164: POP
80165: POP
// exit ;
80166: POP
80167: POP
80168: GO 80399
// end ; tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_dist , depot , 8 ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ] ) ;
80170: LD_ADDR_VAR 0 4
80174: PUSH
80175: LD_INT 22
80177: PUSH
80178: LD_VAR 0 5
80182: PUSH
80183: EMPTY
80184: LIST
80185: LIST
80186: PUSH
80187: LD_INT 91
80189: PUSH
80190: LD_VAR 0 8
80194: PUSH
80195: LD_INT 8
80197: PUSH
80198: EMPTY
80199: LIST
80200: LIST
80201: LIST
80202: PUSH
80203: LD_INT 2
80205: PUSH
80206: LD_INT 34
80208: PUSH
80209: LD_INT 12
80211: PUSH
80212: EMPTY
80213: LIST
80214: LIST
80215: PUSH
80216: LD_INT 34
80218: PUSH
80219: LD_INT 51
80221: PUSH
80222: EMPTY
80223: LIST
80224: LIST
80225: PUSH
80226: LD_INT 34
80228: PUSH
80229: LD_INT 32
80231: PUSH
80232: EMPTY
80233: LIST
80234: LIST
80235: PUSH
80236: LD_INT 34
80238: PUSH
80239: LD_EXP 159
80243: PUSH
80244: EMPTY
80245: LIST
80246: LIST
80247: PUSH
80248: EMPTY
80249: LIST
80250: LIST
80251: LIST
80252: LIST
80253: LIST
80254: PUSH
80255: EMPTY
80256: LIST
80257: LIST
80258: LIST
80259: PPUSH
80260: CALL_OW 69
80264: ST_TO_ADDR
// if tmp then
80265: LD_VAR 0 4
80269: IFFALSE 80395
// begin for j in tmp do
80271: LD_ADDR_VAR 0 2
80275: PUSH
80276: LD_VAR 0 4
80280: PUSH
80281: FOR_IN
80282: IFFALSE 80393
// if ( GetEngine ( j ) = engine_siberite or GetFuel ( j ) > 20 ) and not HasTask ( j ) and ( GetControl ( j ) <> control_manual or IsDrivenBy ( j ) ) then
80284: LD_VAR 0 2
80288: PPUSH
80289: CALL_OW 262
80293: PUSH
80294: LD_INT 3
80296: EQUAL
80297: PUSH
80298: LD_VAR 0 2
80302: PPUSH
80303: CALL_OW 261
80307: PUSH
80308: LD_INT 20
80310: GREATER
80311: OR
80312: PUSH
80313: LD_VAR 0 2
80317: PPUSH
80318: CALL_OW 314
80322: NOT
80323: AND
80324: PUSH
80325: LD_VAR 0 2
80329: PPUSH
80330: CALL_OW 263
80334: PUSH
80335: LD_INT 1
80337: NONEQUAL
80338: PUSH
80339: LD_VAR 0 2
80343: PPUSH
80344: CALL_OW 311
80348: OR
80349: AND
80350: IFFALSE 80391
// begin ComCollect ( j , x , y ) ;
80352: LD_VAR 0 2
80356: PPUSH
80357: LD_VAR 0 6
80361: PPUSH
80362: LD_VAR 0 7
80366: PPUSH
80367: CALL_OW 117
// AddComMoveUnit ( j , depot ) ;
80371: LD_VAR 0 2
80375: PPUSH
80376: LD_VAR 0 8
80380: PPUSH
80381: CALL_OW 172
// exit ;
80385: POP
80386: POP
80387: POP
80388: POP
80389: GO 80399
// end ;
80391: GO 80281
80393: POP
80394: POP
// end ; end ;
80395: GO 79768
80397: POP
80398: POP
// end ; end_of_file
80399: PPOPN 9
80401: END
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb , ar_mortar , ar_crane , ar_miner , ru_flamethrower ; export tech_Artillery , tech_RadMat , tech_BasicTools , tech_Cargo , tech_Track , tech_Crane , tech_Bulldozer , tech_Hovercraft , tech_MultiBarrels ; export function InitGlobalVariables ; begin
80402: LD_INT 0
80404: PPUSH
// ar_miner := 81 ;
80405: LD_ADDR_EXP 165
80409: PUSH
80410: LD_INT 81
80412: ST_TO_ADDR
// ar_crane := 88 ;
80413: LD_ADDR_EXP 164
80417: PUSH
80418: LD_INT 88
80420: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
80421: LD_ADDR_EXP 159
80425: PUSH
80426: LD_INT 89
80428: ST_TO_ADDR
// us_hack := 99 ;
80429: LD_ADDR_EXP 160
80433: PUSH
80434: LD_INT 99
80436: ST_TO_ADDR
// us_artillery := 97 ;
80437: LD_ADDR_EXP 161
80441: PUSH
80442: LD_INT 97
80444: ST_TO_ADDR
// ar_bio_bomb := 91 ;
80445: LD_ADDR_EXP 162
80449: PUSH
80450: LD_INT 91
80452: ST_TO_ADDR
// ar_mortar := 92 ;
80453: LD_ADDR_EXP 163
80457: PUSH
80458: LD_INT 92
80460: ST_TO_ADDR
// ru_flamethrower := 93 ;
80461: LD_ADDR_EXP 166
80465: PUSH
80466: LD_INT 93
80468: ST_TO_ADDR
// ru_radar := 98 ;
80469: LD_ADDR_EXP 158
80473: PUSH
80474: LD_INT 98
80476: ST_TO_ADDR
// tech_Artillery := 80 ;
80477: LD_ADDR_EXP 167
80481: PUSH
80482: LD_INT 80
80484: ST_TO_ADDR
// tech_RadMat := 81 ;
80485: LD_ADDR_EXP 168
80489: PUSH
80490: LD_INT 81
80492: ST_TO_ADDR
// tech_BasicTools := 82 ;
80493: LD_ADDR_EXP 169
80497: PUSH
80498: LD_INT 82
80500: ST_TO_ADDR
// tech_Cargo := 83 ;
80501: LD_ADDR_EXP 170
80505: PUSH
80506: LD_INT 83
80508: ST_TO_ADDR
// tech_Track := 84 ;
80509: LD_ADDR_EXP 171
80513: PUSH
80514: LD_INT 84
80516: ST_TO_ADDR
// tech_Crane := 85 ;
80517: LD_ADDR_EXP 172
80521: PUSH
80522: LD_INT 85
80524: ST_TO_ADDR
// tech_Bulldozer := 86 ;
80525: LD_ADDR_EXP 173
80529: PUSH
80530: LD_INT 86
80532: ST_TO_ADDR
// tech_Hovercraft := 87 ;
80533: LD_ADDR_EXP 174
80537: PUSH
80538: LD_INT 87
80540: ST_TO_ADDR
// tech_MultiBarrels := 88 ;
80541: LD_ADDR_EXP 175
80545: PUSH
80546: LD_INT 88
80548: ST_TO_ADDR
// end ;
80549: LD_VAR 0 1
80553: RET
// every 1 do
80554: GO 80556
80556: DISABLE
// InitGlobalVariables ; end_of_file
80557: CALL 80402 0 0
80561: END
// on TargetableSAIL ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) do begin case cmd of 200 .. 299 :
80562: LD_VAR 0 1
80566: PUSH
80567: LD_INT 200
80569: DOUBLE
80570: GREATEREQUAL
80571: IFFALSE 80579
80573: LD_INT 299
80575: DOUBLE
80576: LESSEQUAL
80577: IFTRUE 80581
80579: GO 80613
80581: POP
// SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; 300 .. 399 :
80582: LD_VAR 0 1
80586: PPUSH
80587: LD_VAR 0 2
80591: PPUSH
80592: LD_VAR 0 3
80596: PPUSH
80597: LD_VAR 0 4
80601: PPUSH
80602: LD_VAR 0 5
80606: PPUSH
80607: CALL 60818 0 5
80611: GO 80690
80613: LD_INT 300
80615: DOUBLE
80616: GREATEREQUAL
80617: IFFALSE 80625
80619: LD_INT 399
80621: DOUBLE
80622: LESSEQUAL
80623: IFTRUE 80627
80625: GO 80689
80627: POP
// SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; end ;
80628: LD_VAR 0 1
80632: PPUSH
80633: LD_VAR 0 2
80637: PPUSH
80638: LD_VAR 0 3
80642: PPUSH
80643: LD_VAR 0 4
80647: PPUSH
80648: LD_VAR 0 5
80652: PPUSH
80653: LD_VAR 0 6
80657: PPUSH
80658: LD_VAR 0 7
80662: PPUSH
80663: LD_VAR 0 8
80667: PPUSH
80668: LD_VAR 0 9
80672: PPUSH
80673: LD_VAR 0 10
80677: PPUSH
80678: LD_VAR 0 11
80682: PPUSH
80683: CALL 77109 0 11
80687: GO 80690
80689: POP
// end ;
80690: PPOPN 11
80692: END
// on CommandUnitXY ( cmd , un , target , x , y ) do begin SOS_CommandUnitXY ( cmd , un , target , x , y ) ;
80693: LD_VAR 0 1
80697: PPUSH
80698: LD_VAR 0 2
80702: PPUSH
80703: LD_VAR 0 3
80707: PPUSH
80708: LD_VAR 0 4
80712: PPUSH
80713: LD_VAR 0 5
80717: PPUSH
80718: CALL 60554 0 5
// end ; end_of_file
80722: PPOPN 5
80724: END
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
80725: LD_INT 0
80727: PPUSH
80728: PPUSH
80729: PPUSH
80730: PPUSH
80731: PPUSH
80732: PPUSH
80733: PPUSH
80734: PPUSH
80735: PPUSH
80736: PPUSH
80737: PPUSH
80738: PPUSH
80739: PPUSH
80740: PPUSH
80741: PPUSH
80742: PPUSH
80743: PPUSH
80744: PPUSH
80745: PPUSH
80746: PPUSH
80747: PPUSH
80748: PPUSH
80749: PPUSH
80750: PPUSH
80751: PPUSH
80752: PPUSH
80753: PPUSH
80754: PPUSH
80755: PPUSH
80756: PPUSH
80757: PPUSH
80758: PPUSH
80759: PPUSH
80760: PPUSH
// if not list then
80761: LD_VAR 0 1
80765: NOT
80766: IFFALSE 80770
// exit ;
80768: GO 85429
// base := list [ 1 ] ;
80770: LD_ADDR_VAR 0 3
80774: PUSH
80775: LD_VAR 0 1
80779: PUSH
80780: LD_INT 1
80782: ARRAY
80783: ST_TO_ADDR
// group := list [ 2 ] ;
80784: LD_ADDR_VAR 0 4
80788: PUSH
80789: LD_VAR 0 1
80793: PUSH
80794: LD_INT 2
80796: ARRAY
80797: ST_TO_ADDR
// path := list [ 3 ] ;
80798: LD_ADDR_VAR 0 5
80802: PUSH
80803: LD_VAR 0 1
80807: PUSH
80808: LD_INT 3
80810: ARRAY
80811: ST_TO_ADDR
// flags := list [ 4 ] ;
80812: LD_ADDR_VAR 0 6
80816: PUSH
80817: LD_VAR 0 1
80821: PUSH
80822: LD_INT 4
80824: ARRAY
80825: ST_TO_ADDR
// mined := [ ] ;
80826: LD_ADDR_VAR 0 27
80830: PUSH
80831: EMPTY
80832: ST_TO_ADDR
// bombed := [ ] ;
80833: LD_ADDR_VAR 0 28
80837: PUSH
80838: EMPTY
80839: ST_TO_ADDR
// healers := [ ] ;
80840: LD_ADDR_VAR 0 31
80844: PUSH
80845: EMPTY
80846: ST_TO_ADDR
// to_heal := [ ] ;
80847: LD_ADDR_VAR 0 30
80851: PUSH
80852: EMPTY
80853: ST_TO_ADDR
// repairs := [ ] ;
80854: LD_ADDR_VAR 0 33
80858: PUSH
80859: EMPTY
80860: ST_TO_ADDR
// to_repair := [ ] ;
80861: LD_ADDR_VAR 0 32
80865: PUSH
80866: EMPTY
80867: ST_TO_ADDR
// if not group or not path then
80868: LD_VAR 0 4
80872: NOT
80873: PUSH
80874: LD_VAR 0 5
80878: NOT
80879: OR
80880: IFFALSE 80884
// exit ;
80882: GO 85429
// side := GetSide ( group [ 1 ] ) ;
80884: LD_ADDR_VAR 0 35
80888: PUSH
80889: LD_VAR 0 4
80893: PUSH
80894: LD_INT 1
80896: ARRAY
80897: PPUSH
80898: CALL_OW 255
80902: ST_TO_ADDR
// if flags then
80903: LD_VAR 0 6
80907: IFFALSE 81051
// begin f_ignore_area := flags [ 1 ] ;
80909: LD_ADDR_VAR 0 17
80913: PUSH
80914: LD_VAR 0 6
80918: PUSH
80919: LD_INT 1
80921: ARRAY
80922: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
80923: LD_ADDR_VAR 0 18
80927: PUSH
80928: LD_VAR 0 6
80932: PUSH
80933: LD_INT 2
80935: ARRAY
80936: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
80937: LD_ADDR_VAR 0 19
80941: PUSH
80942: LD_VAR 0 6
80946: PUSH
80947: LD_INT 3
80949: ARRAY
80950: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
80951: LD_ADDR_VAR 0 20
80955: PUSH
80956: LD_VAR 0 6
80960: PUSH
80961: LD_INT 4
80963: ARRAY
80964: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
80965: LD_ADDR_VAR 0 21
80969: PUSH
80970: LD_VAR 0 6
80974: PUSH
80975: LD_INT 5
80977: ARRAY
80978: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
80979: LD_ADDR_VAR 0 22
80983: PUSH
80984: LD_VAR 0 6
80988: PUSH
80989: LD_INT 6
80991: ARRAY
80992: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
80993: LD_ADDR_VAR 0 23
80997: PUSH
80998: LD_VAR 0 6
81002: PUSH
81003: LD_INT 7
81005: ARRAY
81006: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
81007: LD_ADDR_VAR 0 24
81011: PUSH
81012: LD_VAR 0 6
81016: PUSH
81017: LD_INT 8
81019: ARRAY
81020: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
81021: LD_ADDR_VAR 0 25
81025: PUSH
81026: LD_VAR 0 6
81030: PUSH
81031: LD_INT 9
81033: ARRAY
81034: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
81035: LD_ADDR_VAR 0 26
81039: PUSH
81040: LD_VAR 0 6
81044: PUSH
81045: LD_INT 10
81047: ARRAY
81048: ST_TO_ADDR
// end else
81049: GO 81131
// begin f_ignore_area := false ;
81051: LD_ADDR_VAR 0 17
81055: PUSH
81056: LD_INT 0
81058: ST_TO_ADDR
// f_capture := false ;
81059: LD_ADDR_VAR 0 18
81063: PUSH
81064: LD_INT 0
81066: ST_TO_ADDR
// f_ignore_civ := false ;
81067: LD_ADDR_VAR 0 19
81071: PUSH
81072: LD_INT 0
81074: ST_TO_ADDR
// f_murder := false ;
81075: LD_ADDR_VAR 0 20
81079: PUSH
81080: LD_INT 0
81082: ST_TO_ADDR
// f_mines := false ;
81083: LD_ADDR_VAR 0 21
81087: PUSH
81088: LD_INT 0
81090: ST_TO_ADDR
// f_repair := false ;
81091: LD_ADDR_VAR 0 22
81095: PUSH
81096: LD_INT 0
81098: ST_TO_ADDR
// f_heal := false ;
81099: LD_ADDR_VAR 0 23
81103: PUSH
81104: LD_INT 0
81106: ST_TO_ADDR
// f_spacetime := false ;
81107: LD_ADDR_VAR 0 24
81111: PUSH
81112: LD_INT 0
81114: ST_TO_ADDR
// f_attack_depot := false ;
81115: LD_ADDR_VAR 0 25
81119: PUSH
81120: LD_INT 0
81122: ST_TO_ADDR
// f_crawl := false ;
81123: LD_ADDR_VAR 0 26
81127: PUSH
81128: LD_INT 0
81130: ST_TO_ADDR
// end ; if f_heal then
81131: LD_VAR 0 23
81135: IFFALSE 81162
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
81137: LD_ADDR_VAR 0 31
81141: PUSH
81142: LD_VAR 0 4
81146: PPUSH
81147: LD_INT 25
81149: PUSH
81150: LD_INT 4
81152: PUSH
81153: EMPTY
81154: LIST
81155: LIST
81156: PPUSH
81157: CALL_OW 72
81161: ST_TO_ADDR
// if f_repair then
81162: LD_VAR 0 22
81166: IFFALSE 81193
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
81168: LD_ADDR_VAR 0 33
81172: PUSH
81173: LD_VAR 0 4
81177: PPUSH
81178: LD_INT 25
81180: PUSH
81181: LD_INT 3
81183: PUSH
81184: EMPTY
81185: LIST
81186: LIST
81187: PPUSH
81188: CALL_OW 72
81192: ST_TO_ADDR
// units_path := [ ] ;
81193: LD_ADDR_VAR 0 16
81197: PUSH
81198: EMPTY
81199: ST_TO_ADDR
// for i = 1 to group do
81200: LD_ADDR_VAR 0 7
81204: PUSH
81205: DOUBLE
81206: LD_INT 1
81208: DEC
81209: ST_TO_ADDR
81210: LD_VAR 0 4
81214: PUSH
81215: FOR_TO
81216: IFFALSE 81245
// units_path := Replace ( units_path , i , path ) ;
81218: LD_ADDR_VAR 0 16
81222: PUSH
81223: LD_VAR 0 16
81227: PPUSH
81228: LD_VAR 0 7
81232: PPUSH
81233: LD_VAR 0 5
81237: PPUSH
81238: CALL_OW 1
81242: ST_TO_ADDR
81243: GO 81215
81245: POP
81246: POP
// repeat for i = group downto 1 do
81247: LD_ADDR_VAR 0 7
81251: PUSH
81252: DOUBLE
81253: LD_VAR 0 4
81257: INC
81258: ST_TO_ADDR
81259: LD_INT 1
81261: PUSH
81262: FOR_DOWNTO
81263: IFFALSE 85385
// begin wait ( 5 ) ;
81265: LD_INT 5
81267: PPUSH
81268: CALL_OW 67
// tmp := [ ] ;
81272: LD_ADDR_VAR 0 14
81276: PUSH
81277: EMPTY
81278: ST_TO_ADDR
// attacking := false ;
81279: LD_ADDR_VAR 0 29
81283: PUSH
81284: LD_INT 0
81286: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
81287: LD_VAR 0 4
81291: PUSH
81292: LD_VAR 0 7
81296: ARRAY
81297: PPUSH
81298: CALL_OW 301
81302: PUSH
81303: LD_VAR 0 4
81307: PUSH
81308: LD_VAR 0 7
81312: ARRAY
81313: NOT
81314: OR
81315: IFFALSE 81424
// begin if GetType ( group [ i ] ) = unit_human then
81317: LD_VAR 0 4
81321: PUSH
81322: LD_VAR 0 7
81326: ARRAY
81327: PPUSH
81328: CALL_OW 247
81332: PUSH
81333: LD_INT 1
81335: EQUAL
81336: IFFALSE 81382
// begin to_heal := to_heal diff group [ i ] ;
81338: LD_ADDR_VAR 0 30
81342: PUSH
81343: LD_VAR 0 30
81347: PUSH
81348: LD_VAR 0 4
81352: PUSH
81353: LD_VAR 0 7
81357: ARRAY
81358: DIFF
81359: ST_TO_ADDR
// healers := healers diff group [ i ] ;
81360: LD_ADDR_VAR 0 31
81364: PUSH
81365: LD_VAR 0 31
81369: PUSH
81370: LD_VAR 0 4
81374: PUSH
81375: LD_VAR 0 7
81379: ARRAY
81380: DIFF
81381: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
81382: LD_ADDR_VAR 0 4
81386: PUSH
81387: LD_VAR 0 4
81391: PPUSH
81392: LD_VAR 0 7
81396: PPUSH
81397: CALL_OW 3
81401: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
81402: LD_ADDR_VAR 0 16
81406: PUSH
81407: LD_VAR 0 16
81411: PPUSH
81412: LD_VAR 0 7
81416: PPUSH
81417: CALL_OW 3
81421: ST_TO_ADDR
// continue ;
81422: GO 81262
// end ; if f_repair then
81424: LD_VAR 0 22
81428: IFFALSE 81917
// begin if GetType ( group [ i ] ) = unit_vehicle then
81430: LD_VAR 0 4
81434: PUSH
81435: LD_VAR 0 7
81439: ARRAY
81440: PPUSH
81441: CALL_OW 247
81445: PUSH
81446: LD_INT 2
81448: EQUAL
81449: IFFALSE 81639
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
81451: LD_VAR 0 4
81455: PUSH
81456: LD_VAR 0 7
81460: ARRAY
81461: PPUSH
81462: CALL_OW 256
81466: PUSH
81467: LD_INT 700
81469: LESS
81470: PUSH
81471: LD_VAR 0 4
81475: PUSH
81476: LD_VAR 0 7
81480: ARRAY
81481: PUSH
81482: LD_VAR 0 32
81486: IN
81487: NOT
81488: AND
81489: IFFALSE 81513
// to_repair := to_repair union group [ i ] ;
81491: LD_ADDR_VAR 0 32
81495: PUSH
81496: LD_VAR 0 32
81500: PUSH
81501: LD_VAR 0 4
81505: PUSH
81506: LD_VAR 0 7
81510: ARRAY
81511: UNION
81512: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
81513: LD_VAR 0 4
81517: PUSH
81518: LD_VAR 0 7
81522: ARRAY
81523: PPUSH
81524: CALL_OW 256
81528: PUSH
81529: LD_INT 1000
81531: EQUAL
81532: PUSH
81533: LD_VAR 0 4
81537: PUSH
81538: LD_VAR 0 7
81542: ARRAY
81543: PUSH
81544: LD_VAR 0 32
81548: IN
81549: AND
81550: IFFALSE 81574
// to_repair := to_repair diff group [ i ] ;
81552: LD_ADDR_VAR 0 32
81556: PUSH
81557: LD_VAR 0 32
81561: PUSH
81562: LD_VAR 0 4
81566: PUSH
81567: LD_VAR 0 7
81571: ARRAY
81572: DIFF
81573: ST_TO_ADDR
// if group [ i ] in to_repair then
81574: LD_VAR 0 4
81578: PUSH
81579: LD_VAR 0 7
81583: ARRAY
81584: PUSH
81585: LD_VAR 0 32
81589: IN
81590: IFFALSE 81637
// begin if not IsInArea ( group [ i ] , f_repair ) then
81592: LD_VAR 0 4
81596: PUSH
81597: LD_VAR 0 7
81601: ARRAY
81602: PPUSH
81603: LD_VAR 0 22
81607: PPUSH
81608: CALL_OW 308
81612: NOT
81613: IFFALSE 81635
// ComMoveToArea ( group [ i ] , f_repair ) ;
81615: LD_VAR 0 4
81619: PUSH
81620: LD_VAR 0 7
81624: ARRAY
81625: PPUSH
81626: LD_VAR 0 22
81630: PPUSH
81631: CALL_OW 113
// continue ;
81635: GO 81262
// end ; end else
81637: GO 81917
// if group [ i ] in repairs then
81639: LD_VAR 0 4
81643: PUSH
81644: LD_VAR 0 7
81648: ARRAY
81649: PUSH
81650: LD_VAR 0 33
81654: IN
81655: IFFALSE 81917
// begin if IsInUnit ( group [ i ] ) then
81657: LD_VAR 0 4
81661: PUSH
81662: LD_VAR 0 7
81666: ARRAY
81667: PPUSH
81668: CALL_OW 310
81672: IFFALSE 81740
// begin z := IsInUnit ( group [ i ] ) ;
81674: LD_ADDR_VAR 0 13
81678: PUSH
81679: LD_VAR 0 4
81683: PUSH
81684: LD_VAR 0 7
81688: ARRAY
81689: PPUSH
81690: CALL_OW 310
81694: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
81695: LD_VAR 0 13
81699: PUSH
81700: LD_VAR 0 32
81704: IN
81705: PUSH
81706: LD_VAR 0 13
81710: PPUSH
81711: LD_VAR 0 22
81715: PPUSH
81716: CALL_OW 308
81720: AND
81721: IFFALSE 81738
// ComExitVehicle ( group [ i ] ) ;
81723: LD_VAR 0 4
81727: PUSH
81728: LD_VAR 0 7
81732: ARRAY
81733: PPUSH
81734: CALL_OW 121
// end else
81738: GO 81917
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
81740: LD_ADDR_VAR 0 13
81744: PUSH
81745: LD_VAR 0 4
81749: PPUSH
81750: LD_INT 95
81752: PUSH
81753: LD_VAR 0 22
81757: PUSH
81758: EMPTY
81759: LIST
81760: LIST
81761: PUSH
81762: LD_INT 58
81764: PUSH
81765: EMPTY
81766: LIST
81767: PUSH
81768: EMPTY
81769: LIST
81770: LIST
81771: PPUSH
81772: CALL_OW 72
81776: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
81777: LD_VAR 0 4
81781: PUSH
81782: LD_VAR 0 7
81786: ARRAY
81787: PPUSH
81788: CALL_OW 314
81792: NOT
81793: IFFALSE 81915
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
81795: LD_ADDR_VAR 0 10
81799: PUSH
81800: LD_VAR 0 13
81804: PPUSH
81805: LD_VAR 0 4
81809: PUSH
81810: LD_VAR 0 7
81814: ARRAY
81815: PPUSH
81816: CALL_OW 74
81820: ST_TO_ADDR
// if not x then
81821: LD_VAR 0 10
81825: NOT
81826: IFFALSE 81830
// continue ;
81828: GO 81262
// if GetLives ( x ) < 1000 then
81830: LD_VAR 0 10
81834: PPUSH
81835: CALL_OW 256
81839: PUSH
81840: LD_INT 1000
81842: LESS
81843: IFFALSE 81867
// ComRepairVehicle ( group [ i ] , x ) else
81845: LD_VAR 0 4
81849: PUSH
81850: LD_VAR 0 7
81854: ARRAY
81855: PPUSH
81856: LD_VAR 0 10
81860: PPUSH
81861: CALL_OW 129
81865: GO 81915
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
81867: LD_VAR 0 23
81871: PUSH
81872: LD_VAR 0 4
81876: PUSH
81877: LD_VAR 0 7
81881: ARRAY
81882: PPUSH
81883: CALL_OW 256
81887: PUSH
81888: LD_INT 1000
81890: LESS
81891: AND
81892: NOT
81893: IFFALSE 81915
// ComEnterUnit ( group [ i ] , x ) ;
81895: LD_VAR 0 4
81899: PUSH
81900: LD_VAR 0 7
81904: ARRAY
81905: PPUSH
81906: LD_VAR 0 10
81910: PPUSH
81911: CALL_OW 120
// end ; continue ;
81915: GO 81262
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
81917: LD_VAR 0 23
81921: PUSH
81922: LD_VAR 0 4
81926: PUSH
81927: LD_VAR 0 7
81931: ARRAY
81932: PPUSH
81933: CALL_OW 247
81937: PUSH
81938: LD_INT 1
81940: EQUAL
81941: AND
81942: IFFALSE 82420
// begin if group [ i ] in healers then
81944: LD_VAR 0 4
81948: PUSH
81949: LD_VAR 0 7
81953: ARRAY
81954: PUSH
81955: LD_VAR 0 31
81959: IN
81960: IFFALSE 82233
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
81962: LD_VAR 0 4
81966: PUSH
81967: LD_VAR 0 7
81971: ARRAY
81972: PPUSH
81973: LD_VAR 0 23
81977: PPUSH
81978: CALL_OW 308
81982: NOT
81983: PUSH
81984: LD_VAR 0 4
81988: PUSH
81989: LD_VAR 0 7
81993: ARRAY
81994: PPUSH
81995: CALL_OW 314
81999: NOT
82000: AND
82001: IFFALSE 82025
// ComMoveToArea ( group [ i ] , f_heal ) else
82003: LD_VAR 0 4
82007: PUSH
82008: LD_VAR 0 7
82012: ARRAY
82013: PPUSH
82014: LD_VAR 0 23
82018: PPUSH
82019: CALL_OW 113
82023: GO 82231
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
82025: LD_VAR 0 4
82029: PUSH
82030: LD_VAR 0 7
82034: ARRAY
82035: PPUSH
82036: CALL 54010 0 1
82040: PPUSH
82041: CALL_OW 256
82045: PUSH
82046: LD_INT 1000
82048: EQUAL
82049: IFFALSE 82068
// ComStop ( group [ i ] ) else
82051: LD_VAR 0 4
82055: PUSH
82056: LD_VAR 0 7
82060: ARRAY
82061: PPUSH
82062: CALL_OW 141
82066: GO 82231
// if not HasTask ( group [ i ] ) and to_heal then
82068: LD_VAR 0 4
82072: PUSH
82073: LD_VAR 0 7
82077: ARRAY
82078: PPUSH
82079: CALL_OW 314
82083: NOT
82084: PUSH
82085: LD_VAR 0 30
82089: AND
82090: IFFALSE 82231
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
82092: LD_ADDR_VAR 0 13
82096: PUSH
82097: LD_VAR 0 30
82101: PPUSH
82102: LD_INT 3
82104: PUSH
82105: LD_INT 54
82107: PUSH
82108: EMPTY
82109: LIST
82110: PUSH
82111: EMPTY
82112: LIST
82113: LIST
82114: PPUSH
82115: CALL_OW 72
82119: PPUSH
82120: LD_VAR 0 4
82124: PUSH
82125: LD_VAR 0 7
82129: ARRAY
82130: PPUSH
82131: CALL_OW 74
82135: ST_TO_ADDR
// if z then
82136: LD_VAR 0 13
82140: IFFALSE 82231
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
82142: LD_INT 91
82144: PUSH
82145: LD_VAR 0 13
82149: PUSH
82150: LD_INT 10
82152: PUSH
82153: EMPTY
82154: LIST
82155: LIST
82156: LIST
82157: PUSH
82158: LD_INT 81
82160: PUSH
82161: LD_VAR 0 13
82165: PPUSH
82166: CALL_OW 255
82170: PUSH
82171: EMPTY
82172: LIST
82173: LIST
82174: PUSH
82175: EMPTY
82176: LIST
82177: LIST
82178: PPUSH
82179: CALL_OW 69
82183: PUSH
82184: LD_INT 0
82186: EQUAL
82187: IFFALSE 82211
// ComHeal ( group [ i ] , z ) else
82189: LD_VAR 0 4
82193: PUSH
82194: LD_VAR 0 7
82198: ARRAY
82199: PPUSH
82200: LD_VAR 0 13
82204: PPUSH
82205: CALL_OW 128
82209: GO 82231
// ComMoveToArea ( group [ i ] , f_heal ) ;
82211: LD_VAR 0 4
82215: PUSH
82216: LD_VAR 0 7
82220: ARRAY
82221: PPUSH
82222: LD_VAR 0 23
82226: PPUSH
82227: CALL_OW 113
// end ; continue ;
82231: GO 81262
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
82233: LD_VAR 0 4
82237: PUSH
82238: LD_VAR 0 7
82242: ARRAY
82243: PPUSH
82244: CALL_OW 256
82248: PUSH
82249: LD_INT 700
82251: LESS
82252: PUSH
82253: LD_VAR 0 4
82257: PUSH
82258: LD_VAR 0 7
82262: ARRAY
82263: PUSH
82264: LD_VAR 0 30
82268: IN
82269: NOT
82270: AND
82271: IFFALSE 82295
// to_heal := to_heal union group [ i ] ;
82273: LD_ADDR_VAR 0 30
82277: PUSH
82278: LD_VAR 0 30
82282: PUSH
82283: LD_VAR 0 4
82287: PUSH
82288: LD_VAR 0 7
82292: ARRAY
82293: UNION
82294: ST_TO_ADDR
// if group [ i ] in to_heal then
82295: LD_VAR 0 4
82299: PUSH
82300: LD_VAR 0 7
82304: ARRAY
82305: PUSH
82306: LD_VAR 0 30
82310: IN
82311: IFFALSE 82420
// begin if GetLives ( group [ i ] ) = 1000 then
82313: LD_VAR 0 4
82317: PUSH
82318: LD_VAR 0 7
82322: ARRAY
82323: PPUSH
82324: CALL_OW 256
82328: PUSH
82329: LD_INT 1000
82331: EQUAL
82332: IFFALSE 82358
// to_heal := to_heal diff group [ i ] else
82334: LD_ADDR_VAR 0 30
82338: PUSH
82339: LD_VAR 0 30
82343: PUSH
82344: LD_VAR 0 4
82348: PUSH
82349: LD_VAR 0 7
82353: ARRAY
82354: DIFF
82355: ST_TO_ADDR
82356: GO 82420
// begin if not IsInArea ( group [ i ] , to_heal ) then
82358: LD_VAR 0 4
82362: PUSH
82363: LD_VAR 0 7
82367: ARRAY
82368: PPUSH
82369: LD_VAR 0 30
82373: PPUSH
82374: CALL_OW 308
82378: NOT
82379: IFFALSE 82403
// ComMoveToArea ( group [ i ] , f_heal ) else
82381: LD_VAR 0 4
82385: PUSH
82386: LD_VAR 0 7
82390: ARRAY
82391: PPUSH
82392: LD_VAR 0 23
82396: PPUSH
82397: CALL_OW 113
82401: GO 82418
// ComHold ( group [ i ] ) ;
82403: LD_VAR 0 4
82407: PUSH
82408: LD_VAR 0 7
82412: ARRAY
82413: PPUSH
82414: CALL_OW 140
// continue ;
82418: GO 81262
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
82420: LD_VAR 0 4
82424: PUSH
82425: LD_VAR 0 7
82429: ARRAY
82430: PPUSH
82431: LD_INT 10
82433: PPUSH
82434: CALL 51863 0 2
82438: NOT
82439: PUSH
82440: LD_VAR 0 16
82444: PUSH
82445: LD_VAR 0 7
82449: ARRAY
82450: PUSH
82451: EMPTY
82452: EQUAL
82453: NOT
82454: AND
82455: IFFALSE 82721
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
82457: LD_VAR 0 4
82461: PUSH
82462: LD_VAR 0 7
82466: ARRAY
82467: PPUSH
82468: CALL_OW 262
82472: PUSH
82473: LD_INT 1
82475: PUSH
82476: LD_INT 2
82478: PUSH
82479: EMPTY
82480: LIST
82481: LIST
82482: IN
82483: IFFALSE 82524
// if GetFuel ( group [ i ] ) < 10 then
82485: LD_VAR 0 4
82489: PUSH
82490: LD_VAR 0 7
82494: ARRAY
82495: PPUSH
82496: CALL_OW 261
82500: PUSH
82501: LD_INT 10
82503: LESS
82504: IFFALSE 82524
// SetFuel ( group [ i ] , 12 ) ;
82506: LD_VAR 0 4
82510: PUSH
82511: LD_VAR 0 7
82515: ARRAY
82516: PPUSH
82517: LD_INT 12
82519: PPUSH
82520: CALL_OW 240
// if units_path [ i ] then
82524: LD_VAR 0 16
82528: PUSH
82529: LD_VAR 0 7
82533: ARRAY
82534: IFFALSE 82719
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
82536: LD_VAR 0 4
82540: PUSH
82541: LD_VAR 0 7
82545: ARRAY
82546: PPUSH
82547: LD_VAR 0 16
82551: PUSH
82552: LD_VAR 0 7
82556: ARRAY
82557: PUSH
82558: LD_INT 1
82560: ARRAY
82561: PUSH
82562: LD_INT 1
82564: ARRAY
82565: PPUSH
82566: LD_VAR 0 16
82570: PUSH
82571: LD_VAR 0 7
82575: ARRAY
82576: PUSH
82577: LD_INT 1
82579: ARRAY
82580: PUSH
82581: LD_INT 2
82583: ARRAY
82584: PPUSH
82585: CALL_OW 297
82589: PUSH
82590: LD_INT 6
82592: GREATER
82593: IFFALSE 82668
// begin if not HasTask ( group [ i ] ) then
82595: LD_VAR 0 4
82599: PUSH
82600: LD_VAR 0 7
82604: ARRAY
82605: PPUSH
82606: CALL_OW 314
82610: NOT
82611: IFFALSE 82666
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
82613: LD_VAR 0 4
82617: PUSH
82618: LD_VAR 0 7
82622: ARRAY
82623: PPUSH
82624: LD_VAR 0 16
82628: PUSH
82629: LD_VAR 0 7
82633: ARRAY
82634: PUSH
82635: LD_INT 1
82637: ARRAY
82638: PUSH
82639: LD_INT 1
82641: ARRAY
82642: PPUSH
82643: LD_VAR 0 16
82647: PUSH
82648: LD_VAR 0 7
82652: ARRAY
82653: PUSH
82654: LD_INT 1
82656: ARRAY
82657: PUSH
82658: LD_INT 2
82660: ARRAY
82661: PPUSH
82662: CALL_OW 114
// end else
82666: GO 82719
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
82668: LD_ADDR_VAR 0 15
82672: PUSH
82673: LD_VAR 0 16
82677: PUSH
82678: LD_VAR 0 7
82682: ARRAY
82683: PPUSH
82684: LD_INT 1
82686: PPUSH
82687: CALL_OW 3
82691: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
82692: LD_ADDR_VAR 0 16
82696: PUSH
82697: LD_VAR 0 16
82701: PPUSH
82702: LD_VAR 0 7
82706: PPUSH
82707: LD_VAR 0 15
82711: PPUSH
82712: CALL_OW 1
82716: ST_TO_ADDR
// continue ;
82717: GO 81262
// end ; end ; end else
82719: GO 85383
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
82721: LD_ADDR_VAR 0 14
82725: PUSH
82726: LD_INT 81
82728: PUSH
82729: LD_VAR 0 4
82733: PUSH
82734: LD_VAR 0 7
82738: ARRAY
82739: PPUSH
82740: CALL_OW 255
82744: PUSH
82745: EMPTY
82746: LIST
82747: LIST
82748: PPUSH
82749: CALL_OW 69
82753: ST_TO_ADDR
// if not tmp then
82754: LD_VAR 0 14
82758: NOT
82759: IFFALSE 82763
// continue ;
82761: GO 81262
// if f_ignore_area then
82763: LD_VAR 0 17
82767: IFFALSE 82855
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
82769: LD_ADDR_VAR 0 15
82773: PUSH
82774: LD_VAR 0 14
82778: PPUSH
82779: LD_INT 3
82781: PUSH
82782: LD_INT 92
82784: PUSH
82785: LD_VAR 0 17
82789: PUSH
82790: LD_INT 1
82792: ARRAY
82793: PUSH
82794: LD_VAR 0 17
82798: PUSH
82799: LD_INT 2
82801: ARRAY
82802: PUSH
82803: LD_VAR 0 17
82807: PUSH
82808: LD_INT 3
82810: ARRAY
82811: PUSH
82812: EMPTY
82813: LIST
82814: LIST
82815: LIST
82816: LIST
82817: PUSH
82818: EMPTY
82819: LIST
82820: LIST
82821: PPUSH
82822: CALL_OW 72
82826: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
82827: LD_VAR 0 14
82831: PUSH
82832: LD_VAR 0 15
82836: DIFF
82837: IFFALSE 82855
// tmp := tmp diff tmp2 ;
82839: LD_ADDR_VAR 0 14
82843: PUSH
82844: LD_VAR 0 14
82848: PUSH
82849: LD_VAR 0 15
82853: DIFF
82854: ST_TO_ADDR
// end ; if not f_murder then
82855: LD_VAR 0 20
82859: NOT
82860: IFFALSE 82918
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
82862: LD_ADDR_VAR 0 15
82866: PUSH
82867: LD_VAR 0 14
82871: PPUSH
82872: LD_INT 3
82874: PUSH
82875: LD_INT 50
82877: PUSH
82878: EMPTY
82879: LIST
82880: PUSH
82881: EMPTY
82882: LIST
82883: LIST
82884: PPUSH
82885: CALL_OW 72
82889: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
82890: LD_VAR 0 14
82894: PUSH
82895: LD_VAR 0 15
82899: DIFF
82900: IFFALSE 82918
// tmp := tmp diff tmp2 ;
82902: LD_ADDR_VAR 0 14
82906: PUSH
82907: LD_VAR 0 14
82911: PUSH
82912: LD_VAR 0 15
82916: DIFF
82917: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
82918: LD_ADDR_VAR 0 14
82922: PUSH
82923: LD_VAR 0 4
82927: PUSH
82928: LD_VAR 0 7
82932: ARRAY
82933: PPUSH
82934: LD_VAR 0 14
82938: PPUSH
82939: LD_INT 1
82941: PPUSH
82942: LD_INT 1
82944: PPUSH
82945: CALL 24798 0 4
82949: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
82950: LD_VAR 0 4
82954: PUSH
82955: LD_VAR 0 7
82959: ARRAY
82960: PPUSH
82961: CALL_OW 257
82965: PUSH
82966: LD_INT 1
82968: EQUAL
82969: IFFALSE 83417
// begin if WantPlant ( group [ i ] ) then
82971: LD_VAR 0 4
82975: PUSH
82976: LD_VAR 0 7
82980: ARRAY
82981: PPUSH
82982: CALL 24299 0 1
82986: IFFALSE 82990
// continue ;
82988: GO 81262
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
82990: LD_VAR 0 18
82994: PUSH
82995: LD_VAR 0 4
82999: PUSH
83000: LD_VAR 0 7
83004: ARRAY
83005: PPUSH
83006: CALL_OW 310
83010: NOT
83011: AND
83012: PUSH
83013: LD_VAR 0 14
83017: PUSH
83018: LD_INT 1
83020: ARRAY
83021: PUSH
83022: LD_VAR 0 14
83026: PPUSH
83027: LD_INT 21
83029: PUSH
83030: LD_INT 2
83032: PUSH
83033: EMPTY
83034: LIST
83035: LIST
83036: PUSH
83037: LD_INT 58
83039: PUSH
83040: EMPTY
83041: LIST
83042: PUSH
83043: EMPTY
83044: LIST
83045: LIST
83046: PPUSH
83047: CALL_OW 72
83051: IN
83052: AND
83053: IFFALSE 83089
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
83055: LD_VAR 0 4
83059: PUSH
83060: LD_VAR 0 7
83064: ARRAY
83065: PPUSH
83066: LD_VAR 0 14
83070: PUSH
83071: LD_INT 1
83073: ARRAY
83074: PPUSH
83075: CALL_OW 120
// attacking := true ;
83079: LD_ADDR_VAR 0 29
83083: PUSH
83084: LD_INT 1
83086: ST_TO_ADDR
// continue ;
83087: GO 81262
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
83089: LD_VAR 0 26
83093: PUSH
83094: LD_VAR 0 4
83098: PUSH
83099: LD_VAR 0 7
83103: ARRAY
83104: PPUSH
83105: CALL_OW 257
83109: PUSH
83110: LD_INT 1
83112: EQUAL
83113: AND
83114: PUSH
83115: LD_VAR 0 4
83119: PUSH
83120: LD_VAR 0 7
83124: ARRAY
83125: PPUSH
83126: CALL_OW 256
83130: PUSH
83131: LD_INT 800
83133: LESS
83134: AND
83135: PUSH
83136: LD_VAR 0 4
83140: PUSH
83141: LD_VAR 0 7
83145: ARRAY
83146: PPUSH
83147: CALL_OW 318
83151: NOT
83152: AND
83153: IFFALSE 83170
// ComCrawl ( group [ i ] ) ;
83155: LD_VAR 0 4
83159: PUSH
83160: LD_VAR 0 7
83164: ARRAY
83165: PPUSH
83166: CALL_OW 137
// if f_mines then
83170: LD_VAR 0 21
83174: IFFALSE 83417
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
83176: LD_VAR 0 14
83180: PUSH
83181: LD_INT 1
83183: ARRAY
83184: PPUSH
83185: CALL_OW 247
83189: PUSH
83190: LD_INT 3
83192: EQUAL
83193: PUSH
83194: LD_VAR 0 14
83198: PUSH
83199: LD_INT 1
83201: ARRAY
83202: PUSH
83203: LD_VAR 0 27
83207: IN
83208: NOT
83209: AND
83210: IFFALSE 83417
// begin x := GetX ( tmp [ 1 ] ) ;
83212: LD_ADDR_VAR 0 10
83216: PUSH
83217: LD_VAR 0 14
83221: PUSH
83222: LD_INT 1
83224: ARRAY
83225: PPUSH
83226: CALL_OW 250
83230: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
83231: LD_ADDR_VAR 0 11
83235: PUSH
83236: LD_VAR 0 14
83240: PUSH
83241: LD_INT 1
83243: ARRAY
83244: PPUSH
83245: CALL_OW 251
83249: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
83250: LD_ADDR_VAR 0 12
83254: PUSH
83255: LD_VAR 0 4
83259: PUSH
83260: LD_VAR 0 7
83264: ARRAY
83265: PPUSH
83266: CALL 51948 0 1
83270: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
83271: LD_VAR 0 4
83275: PUSH
83276: LD_VAR 0 7
83280: ARRAY
83281: PPUSH
83282: LD_VAR 0 10
83286: PPUSH
83287: LD_VAR 0 11
83291: PPUSH
83292: LD_VAR 0 14
83296: PUSH
83297: LD_INT 1
83299: ARRAY
83300: PPUSH
83301: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
83305: LD_VAR 0 4
83309: PUSH
83310: LD_VAR 0 7
83314: ARRAY
83315: PPUSH
83316: LD_VAR 0 10
83320: PPUSH
83321: LD_VAR 0 12
83325: PPUSH
83326: LD_INT 7
83328: PPUSH
83329: CALL_OW 272
83333: PPUSH
83334: LD_VAR 0 11
83338: PPUSH
83339: LD_VAR 0 12
83343: PPUSH
83344: LD_INT 7
83346: PPUSH
83347: CALL_OW 273
83351: PPUSH
83352: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
83356: LD_VAR 0 4
83360: PUSH
83361: LD_VAR 0 7
83365: ARRAY
83366: PPUSH
83367: LD_INT 71
83369: PPUSH
83370: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
83374: LD_ADDR_VAR 0 27
83378: PUSH
83379: LD_VAR 0 27
83383: PPUSH
83384: LD_VAR 0 27
83388: PUSH
83389: LD_INT 1
83391: PLUS
83392: PPUSH
83393: LD_VAR 0 14
83397: PUSH
83398: LD_INT 1
83400: ARRAY
83401: PPUSH
83402: CALL_OW 1
83406: ST_TO_ADDR
// attacking := true ;
83407: LD_ADDR_VAR 0 29
83411: PUSH
83412: LD_INT 1
83414: ST_TO_ADDR
// continue ;
83415: GO 81262
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
83417: LD_VAR 0 4
83421: PUSH
83422: LD_VAR 0 7
83426: ARRAY
83427: PPUSH
83428: CALL_OW 257
83432: PUSH
83433: LD_INT 17
83435: EQUAL
83436: PUSH
83437: LD_VAR 0 4
83441: PUSH
83442: LD_VAR 0 7
83446: ARRAY
83447: PPUSH
83448: CALL_OW 110
83452: PUSH
83453: LD_INT 71
83455: EQUAL
83456: NOT
83457: AND
83458: IFFALSE 83604
// begin attacking := false ;
83460: LD_ADDR_VAR 0 29
83464: PUSH
83465: LD_INT 0
83467: ST_TO_ADDR
// k := 5 ;
83468: LD_ADDR_VAR 0 9
83472: PUSH
83473: LD_INT 5
83475: ST_TO_ADDR
// if tmp < k then
83476: LD_VAR 0 14
83480: PUSH
83481: LD_VAR 0 9
83485: LESS
83486: IFFALSE 83498
// k := tmp ;
83488: LD_ADDR_VAR 0 9
83492: PUSH
83493: LD_VAR 0 14
83497: ST_TO_ADDR
// for j = 1 to k do
83498: LD_ADDR_VAR 0 8
83502: PUSH
83503: DOUBLE
83504: LD_INT 1
83506: DEC
83507: ST_TO_ADDR
83508: LD_VAR 0 9
83512: PUSH
83513: FOR_TO
83514: IFFALSE 83602
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
83516: LD_VAR 0 14
83520: PUSH
83521: LD_VAR 0 8
83525: ARRAY
83526: PUSH
83527: LD_VAR 0 14
83531: PPUSH
83532: LD_INT 58
83534: PUSH
83535: EMPTY
83536: LIST
83537: PPUSH
83538: CALL_OW 72
83542: IN
83543: NOT
83544: IFFALSE 83600
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
83546: LD_VAR 0 4
83550: PUSH
83551: LD_VAR 0 7
83555: ARRAY
83556: PPUSH
83557: LD_VAR 0 14
83561: PUSH
83562: LD_VAR 0 8
83566: ARRAY
83567: PPUSH
83568: CALL_OW 115
// attacking := true ;
83572: LD_ADDR_VAR 0 29
83576: PUSH
83577: LD_INT 1
83579: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
83580: LD_VAR 0 4
83584: PUSH
83585: LD_VAR 0 7
83589: ARRAY
83590: PPUSH
83591: LD_INT 71
83593: PPUSH
83594: CALL_OW 109
// continue ;
83598: GO 83513
// end ; end ;
83600: GO 83513
83602: POP
83603: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
83604: LD_VAR 0 4
83608: PUSH
83609: LD_VAR 0 7
83613: ARRAY
83614: PPUSH
83615: CALL_OW 257
83619: PUSH
83620: LD_INT 8
83622: EQUAL
83623: PUSH
83624: LD_VAR 0 4
83628: PUSH
83629: LD_VAR 0 7
83633: ARRAY
83634: PPUSH
83635: CALL_OW 264
83639: PUSH
83640: LD_INT 28
83642: PUSH
83643: LD_INT 45
83645: PUSH
83646: LD_INT 7
83648: PUSH
83649: LD_INT 47
83651: PUSH
83652: EMPTY
83653: LIST
83654: LIST
83655: LIST
83656: LIST
83657: IN
83658: OR
83659: IFFALSE 83915
// begin attacking := false ;
83661: LD_ADDR_VAR 0 29
83665: PUSH
83666: LD_INT 0
83668: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
83669: LD_VAR 0 14
83673: PUSH
83674: LD_INT 1
83676: ARRAY
83677: PPUSH
83678: CALL_OW 266
83682: PUSH
83683: LD_INT 32
83685: PUSH
83686: LD_INT 31
83688: PUSH
83689: LD_INT 33
83691: PUSH
83692: LD_INT 4
83694: PUSH
83695: LD_INT 5
83697: PUSH
83698: EMPTY
83699: LIST
83700: LIST
83701: LIST
83702: LIST
83703: LIST
83704: IN
83705: IFFALSE 83891
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
83707: LD_ADDR_VAR 0 9
83711: PUSH
83712: LD_VAR 0 14
83716: PUSH
83717: LD_INT 1
83719: ARRAY
83720: PPUSH
83721: CALL_OW 266
83725: PPUSH
83726: LD_VAR 0 14
83730: PUSH
83731: LD_INT 1
83733: ARRAY
83734: PPUSH
83735: CALL_OW 250
83739: PPUSH
83740: LD_VAR 0 14
83744: PUSH
83745: LD_INT 1
83747: ARRAY
83748: PPUSH
83749: CALL_OW 251
83753: PPUSH
83754: LD_VAR 0 14
83758: PUSH
83759: LD_INT 1
83761: ARRAY
83762: PPUSH
83763: CALL_OW 254
83767: PPUSH
83768: LD_VAR 0 14
83772: PUSH
83773: LD_INT 1
83775: ARRAY
83776: PPUSH
83777: CALL_OW 248
83781: PPUSH
83782: LD_INT 0
83784: PPUSH
83785: CALL 33318 0 6
83789: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
83790: LD_ADDR_VAR 0 8
83794: PUSH
83795: LD_VAR 0 4
83799: PUSH
83800: LD_VAR 0 7
83804: ARRAY
83805: PPUSH
83806: LD_VAR 0 9
83810: PPUSH
83811: CALL 51988 0 2
83815: ST_TO_ADDR
// if j then
83816: LD_VAR 0 8
83820: IFFALSE 83889
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
83822: LD_VAR 0 8
83826: PUSH
83827: LD_INT 1
83829: ARRAY
83830: PPUSH
83831: LD_VAR 0 8
83835: PUSH
83836: LD_INT 2
83838: ARRAY
83839: PPUSH
83840: CALL_OW 488
83844: IFFALSE 83889
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
83846: LD_VAR 0 4
83850: PUSH
83851: LD_VAR 0 7
83855: ARRAY
83856: PPUSH
83857: LD_VAR 0 8
83861: PUSH
83862: LD_INT 1
83864: ARRAY
83865: PPUSH
83866: LD_VAR 0 8
83870: PUSH
83871: LD_INT 2
83873: ARRAY
83874: PPUSH
83875: CALL_OW 116
// attacking := true ;
83879: LD_ADDR_VAR 0 29
83883: PUSH
83884: LD_INT 1
83886: ST_TO_ADDR
// continue ;
83887: GO 81262
// end ; end else
83889: GO 83915
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
83891: LD_VAR 0 4
83895: PUSH
83896: LD_VAR 0 7
83900: ARRAY
83901: PPUSH
83902: LD_VAR 0 14
83906: PUSH
83907: LD_INT 1
83909: ARRAY
83910: PPUSH
83911: CALL_OW 115
// end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
83915: LD_VAR 0 4
83919: PUSH
83920: LD_VAR 0 7
83924: ARRAY
83925: PPUSH
83926: CALL_OW 265
83930: PUSH
83931: LD_INT 11
83933: EQUAL
83934: IFFALSE 84212
// begin k := 10 ;
83936: LD_ADDR_VAR 0 9
83940: PUSH
83941: LD_INT 10
83943: ST_TO_ADDR
// x := 0 ;
83944: LD_ADDR_VAR 0 10
83948: PUSH
83949: LD_INT 0
83951: ST_TO_ADDR
// if tmp < k then
83952: LD_VAR 0 14
83956: PUSH
83957: LD_VAR 0 9
83961: LESS
83962: IFFALSE 83974
// k := tmp ;
83964: LD_ADDR_VAR 0 9
83968: PUSH
83969: LD_VAR 0 14
83973: ST_TO_ADDR
// for j = k downto 1 do
83974: LD_ADDR_VAR 0 8
83978: PUSH
83979: DOUBLE
83980: LD_VAR 0 9
83984: INC
83985: ST_TO_ADDR
83986: LD_INT 1
83988: PUSH
83989: FOR_DOWNTO
83990: IFFALSE 84065
// begin if GetType ( tmp [ j ] ) = unit_human then
83992: LD_VAR 0 14
83996: PUSH
83997: LD_VAR 0 8
84001: ARRAY
84002: PPUSH
84003: CALL_OW 247
84007: PUSH
84008: LD_INT 1
84010: EQUAL
84011: IFFALSE 84063
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
84013: LD_VAR 0 4
84017: PUSH
84018: LD_VAR 0 7
84022: ARRAY
84023: PPUSH
84024: LD_VAR 0 14
84028: PUSH
84029: LD_VAR 0 8
84033: ARRAY
84034: PPUSH
84035: CALL 52259 0 2
// x := tmp [ j ] ;
84039: LD_ADDR_VAR 0 10
84043: PUSH
84044: LD_VAR 0 14
84048: PUSH
84049: LD_VAR 0 8
84053: ARRAY
84054: ST_TO_ADDR
// attacking := true ;
84055: LD_ADDR_VAR 0 29
84059: PUSH
84060: LD_INT 1
84062: ST_TO_ADDR
// end ; end ;
84063: GO 83989
84065: POP
84066: POP
// if not x then
84067: LD_VAR 0 10
84071: NOT
84072: IFFALSE 84212
// begin attacking := true ;
84074: LD_ADDR_VAR 0 29
84078: PUSH
84079: LD_INT 1
84081: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
84082: LD_VAR 0 4
84086: PUSH
84087: LD_VAR 0 7
84091: ARRAY
84092: PPUSH
84093: CALL_OW 250
84097: PPUSH
84098: LD_VAR 0 4
84102: PUSH
84103: LD_VAR 0 7
84107: ARRAY
84108: PPUSH
84109: CALL_OW 251
84113: PPUSH
84114: CALL_OW 546
84118: PUSH
84119: LD_INT 2
84121: ARRAY
84122: PUSH
84123: LD_VAR 0 14
84127: PUSH
84128: LD_INT 1
84130: ARRAY
84131: PPUSH
84132: CALL_OW 250
84136: PPUSH
84137: LD_VAR 0 14
84141: PUSH
84142: LD_INT 1
84144: ARRAY
84145: PPUSH
84146: CALL_OW 251
84150: PPUSH
84151: CALL_OW 546
84155: PUSH
84156: LD_INT 2
84158: ARRAY
84159: EQUAL
84160: IFFALSE 84188
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
84162: LD_VAR 0 4
84166: PUSH
84167: LD_VAR 0 7
84171: ARRAY
84172: PPUSH
84173: LD_VAR 0 14
84177: PUSH
84178: LD_INT 1
84180: ARRAY
84181: PPUSH
84182: CALL 52259 0 2
84186: GO 84212
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
84188: LD_VAR 0 4
84192: PUSH
84193: LD_VAR 0 7
84197: ARRAY
84198: PPUSH
84199: LD_VAR 0 14
84203: PUSH
84204: LD_INT 1
84206: ARRAY
84207: PPUSH
84208: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
84212: LD_VAR 0 4
84216: PUSH
84217: LD_VAR 0 7
84221: ARRAY
84222: PPUSH
84223: CALL_OW 264
84227: PUSH
84228: LD_INT 29
84230: EQUAL
84231: IFFALSE 84597
// begin if WantsToAttack ( group [ i ] ) in bombed then
84233: LD_VAR 0 4
84237: PUSH
84238: LD_VAR 0 7
84242: ARRAY
84243: PPUSH
84244: CALL_OW 319
84248: PUSH
84249: LD_VAR 0 28
84253: IN
84254: IFFALSE 84258
// continue ;
84256: GO 81262
// k := 8 ;
84258: LD_ADDR_VAR 0 9
84262: PUSH
84263: LD_INT 8
84265: ST_TO_ADDR
// x := 0 ;
84266: LD_ADDR_VAR 0 10
84270: PUSH
84271: LD_INT 0
84273: ST_TO_ADDR
// if tmp < k then
84274: LD_VAR 0 14
84278: PUSH
84279: LD_VAR 0 9
84283: LESS
84284: IFFALSE 84296
// k := tmp ;
84286: LD_ADDR_VAR 0 9
84290: PUSH
84291: LD_VAR 0 14
84295: ST_TO_ADDR
// for j = 1 to k do
84296: LD_ADDR_VAR 0 8
84300: PUSH
84301: DOUBLE
84302: LD_INT 1
84304: DEC
84305: ST_TO_ADDR
84306: LD_VAR 0 9
84310: PUSH
84311: FOR_TO
84312: IFFALSE 84444
// begin if GetType ( tmp [ j ] ) = unit_building then
84314: LD_VAR 0 14
84318: PUSH
84319: LD_VAR 0 8
84323: ARRAY
84324: PPUSH
84325: CALL_OW 247
84329: PUSH
84330: LD_INT 3
84332: EQUAL
84333: IFFALSE 84442
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
84335: LD_VAR 0 14
84339: PUSH
84340: LD_VAR 0 8
84344: ARRAY
84345: PUSH
84346: LD_VAR 0 28
84350: IN
84351: NOT
84352: PUSH
84353: LD_VAR 0 14
84357: PUSH
84358: LD_VAR 0 8
84362: ARRAY
84363: PPUSH
84364: CALL_OW 313
84368: AND
84369: IFFALSE 84442
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
84371: LD_VAR 0 4
84375: PUSH
84376: LD_VAR 0 7
84380: ARRAY
84381: PPUSH
84382: LD_VAR 0 14
84386: PUSH
84387: LD_VAR 0 8
84391: ARRAY
84392: PPUSH
84393: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
84397: LD_ADDR_VAR 0 28
84401: PUSH
84402: LD_VAR 0 28
84406: PPUSH
84407: LD_VAR 0 28
84411: PUSH
84412: LD_INT 1
84414: PLUS
84415: PPUSH
84416: LD_VAR 0 14
84420: PUSH
84421: LD_VAR 0 8
84425: ARRAY
84426: PPUSH
84427: CALL_OW 1
84431: ST_TO_ADDR
// attacking := true ;
84432: LD_ADDR_VAR 0 29
84436: PUSH
84437: LD_INT 1
84439: ST_TO_ADDR
// break ;
84440: GO 84444
// end ; end ;
84442: GO 84311
84444: POP
84445: POP
// if not attacking and f_attack_depot then
84446: LD_VAR 0 29
84450: NOT
84451: PUSH
84452: LD_VAR 0 25
84456: AND
84457: IFFALSE 84552
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
84459: LD_ADDR_VAR 0 13
84463: PUSH
84464: LD_VAR 0 14
84468: PPUSH
84469: LD_INT 2
84471: PUSH
84472: LD_INT 30
84474: PUSH
84475: LD_INT 0
84477: PUSH
84478: EMPTY
84479: LIST
84480: LIST
84481: PUSH
84482: LD_INT 30
84484: PUSH
84485: LD_INT 1
84487: PUSH
84488: EMPTY
84489: LIST
84490: LIST
84491: PUSH
84492: EMPTY
84493: LIST
84494: LIST
84495: LIST
84496: PPUSH
84497: CALL_OW 72
84501: ST_TO_ADDR
// if z then
84502: LD_VAR 0 13
84506: IFFALSE 84552
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
84508: LD_VAR 0 4
84512: PUSH
84513: LD_VAR 0 7
84517: ARRAY
84518: PPUSH
84519: LD_VAR 0 13
84523: PPUSH
84524: LD_VAR 0 4
84528: PUSH
84529: LD_VAR 0 7
84533: ARRAY
84534: PPUSH
84535: CALL_OW 74
84539: PPUSH
84540: CALL_OW 115
// attacking := true ;
84544: LD_ADDR_VAR 0 29
84548: PUSH
84549: LD_INT 1
84551: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
84552: LD_VAR 0 4
84556: PUSH
84557: LD_VAR 0 7
84561: ARRAY
84562: PPUSH
84563: CALL_OW 256
84567: PUSH
84568: LD_INT 500
84570: LESS
84571: IFFALSE 84597
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
84573: LD_VAR 0 4
84577: PUSH
84578: LD_VAR 0 7
84582: ARRAY
84583: PPUSH
84584: LD_VAR 0 14
84588: PUSH
84589: LD_INT 1
84591: ARRAY
84592: PPUSH
84593: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
84597: LD_VAR 0 4
84601: PUSH
84602: LD_VAR 0 7
84606: ARRAY
84607: PPUSH
84608: CALL_OW 264
84612: PUSH
84613: LD_INT 49
84615: EQUAL
84616: IFFALSE 84737
// begin if not HasTask ( group [ i ] ) then
84618: LD_VAR 0 4
84622: PUSH
84623: LD_VAR 0 7
84627: ARRAY
84628: PPUSH
84629: CALL_OW 314
84633: NOT
84634: IFFALSE 84737
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
84636: LD_ADDR_VAR 0 9
84640: PUSH
84641: LD_INT 81
84643: PUSH
84644: LD_VAR 0 4
84648: PUSH
84649: LD_VAR 0 7
84653: ARRAY
84654: PPUSH
84655: CALL_OW 255
84659: PUSH
84660: EMPTY
84661: LIST
84662: LIST
84663: PPUSH
84664: CALL_OW 69
84668: PPUSH
84669: LD_VAR 0 4
84673: PUSH
84674: LD_VAR 0 7
84678: ARRAY
84679: PPUSH
84680: CALL_OW 74
84684: ST_TO_ADDR
// if k then
84685: LD_VAR 0 9
84689: IFFALSE 84737
// if GetDistUnits ( group [ i ] , k ) > 10 then
84691: LD_VAR 0 4
84695: PUSH
84696: LD_VAR 0 7
84700: ARRAY
84701: PPUSH
84702: LD_VAR 0 9
84706: PPUSH
84707: CALL_OW 296
84711: PUSH
84712: LD_INT 10
84714: GREATER
84715: IFFALSE 84737
// ComMoveUnit ( group [ i ] , k ) ;
84717: LD_VAR 0 4
84721: PUSH
84722: LD_VAR 0 7
84726: ARRAY
84727: PPUSH
84728: LD_VAR 0 9
84732: PPUSH
84733: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
84737: LD_VAR 0 4
84741: PUSH
84742: LD_VAR 0 7
84746: ARRAY
84747: PPUSH
84748: CALL_OW 256
84752: PUSH
84753: LD_INT 250
84755: LESS
84756: PUSH
84757: LD_VAR 0 4
84761: PUSH
84762: LD_VAR 0 7
84766: ARRAY
84767: PUSH
84768: LD_INT 21
84770: PUSH
84771: LD_INT 2
84773: PUSH
84774: EMPTY
84775: LIST
84776: LIST
84777: PUSH
84778: LD_INT 23
84780: PUSH
84781: LD_INT 2
84783: PUSH
84784: EMPTY
84785: LIST
84786: LIST
84787: PUSH
84788: EMPTY
84789: LIST
84790: LIST
84791: PPUSH
84792: CALL_OW 69
84796: IN
84797: AND
84798: IFFALSE 84923
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
84800: LD_ADDR_VAR 0 9
84804: PUSH
84805: LD_OWVAR 3
84809: PUSH
84810: LD_VAR 0 4
84814: PUSH
84815: LD_VAR 0 7
84819: ARRAY
84820: DIFF
84821: PPUSH
84822: LD_VAR 0 4
84826: PUSH
84827: LD_VAR 0 7
84831: ARRAY
84832: PPUSH
84833: CALL_OW 74
84837: ST_TO_ADDR
// if not k then
84838: LD_VAR 0 9
84842: NOT
84843: IFFALSE 84847
// continue ;
84845: GO 81262
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
84847: LD_VAR 0 9
84851: PUSH
84852: LD_INT 81
84854: PUSH
84855: LD_VAR 0 4
84859: PUSH
84860: LD_VAR 0 7
84864: ARRAY
84865: PPUSH
84866: CALL_OW 255
84870: PUSH
84871: EMPTY
84872: LIST
84873: LIST
84874: PPUSH
84875: CALL_OW 69
84879: IN
84880: PUSH
84881: LD_VAR 0 9
84885: PPUSH
84886: LD_VAR 0 4
84890: PUSH
84891: LD_VAR 0 7
84895: ARRAY
84896: PPUSH
84897: CALL_OW 296
84901: PUSH
84902: LD_INT 5
84904: LESS
84905: AND
84906: IFFALSE 84923
// ComAutodestruct ( group [ i ] ) ;
84908: LD_VAR 0 4
84912: PUSH
84913: LD_VAR 0 7
84917: ARRAY
84918: PPUSH
84919: CALL 52157 0 1
// end ; if f_attack_depot then
84923: LD_VAR 0 25
84927: IFFALSE 85039
// begin k := 6 ;
84929: LD_ADDR_VAR 0 9
84933: PUSH
84934: LD_INT 6
84936: ST_TO_ADDR
// if tmp < k then
84937: LD_VAR 0 14
84941: PUSH
84942: LD_VAR 0 9
84946: LESS
84947: IFFALSE 84959
// k := tmp ;
84949: LD_ADDR_VAR 0 9
84953: PUSH
84954: LD_VAR 0 14
84958: ST_TO_ADDR
// for j = 1 to k do
84959: LD_ADDR_VAR 0 8
84963: PUSH
84964: DOUBLE
84965: LD_INT 1
84967: DEC
84968: ST_TO_ADDR
84969: LD_VAR 0 9
84973: PUSH
84974: FOR_TO
84975: IFFALSE 85037
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
84977: LD_VAR 0 8
84981: PPUSH
84982: CALL_OW 266
84986: PUSH
84987: LD_INT 0
84989: PUSH
84990: LD_INT 1
84992: PUSH
84993: EMPTY
84994: LIST
84995: LIST
84996: IN
84997: IFFALSE 85035
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
84999: LD_VAR 0 4
85003: PUSH
85004: LD_VAR 0 7
85008: ARRAY
85009: PPUSH
85010: LD_VAR 0 14
85014: PUSH
85015: LD_VAR 0 8
85019: ARRAY
85020: PPUSH
85021: CALL_OW 115
// attacking := true ;
85025: LD_ADDR_VAR 0 29
85029: PUSH
85030: LD_INT 1
85032: ST_TO_ADDR
// break ;
85033: GO 85037
// end ;
85035: GO 84974
85037: POP
85038: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
85039: LD_VAR 0 4
85043: PUSH
85044: LD_VAR 0 7
85048: ARRAY
85049: PPUSH
85050: CALL_OW 302
85054: PUSH
85055: LD_VAR 0 29
85059: NOT
85060: AND
85061: IFFALSE 85383
// begin if GetTag ( group [ i ] ) = 71 then
85063: LD_VAR 0 4
85067: PUSH
85068: LD_VAR 0 7
85072: ARRAY
85073: PPUSH
85074: CALL_OW 110
85078: PUSH
85079: LD_INT 71
85081: EQUAL
85082: IFFALSE 85123
// begin if HasTask ( group [ i ] ) then
85084: LD_VAR 0 4
85088: PUSH
85089: LD_VAR 0 7
85093: ARRAY
85094: PPUSH
85095: CALL_OW 314
85099: IFFALSE 85105
// continue else
85101: GO 81262
85103: GO 85123
// SetTag ( group [ i ] , 0 ) ;
85105: LD_VAR 0 4
85109: PUSH
85110: LD_VAR 0 7
85114: ARRAY
85115: PPUSH
85116: LD_INT 0
85118: PPUSH
85119: CALL_OW 109
// end ; k := 8 ;
85123: LD_ADDR_VAR 0 9
85127: PUSH
85128: LD_INT 8
85130: ST_TO_ADDR
// x := 0 ;
85131: LD_ADDR_VAR 0 10
85135: PUSH
85136: LD_INT 0
85138: ST_TO_ADDR
// if tmp < k then
85139: LD_VAR 0 14
85143: PUSH
85144: LD_VAR 0 9
85148: LESS
85149: IFFALSE 85161
// k := tmp ;
85151: LD_ADDR_VAR 0 9
85155: PUSH
85156: LD_VAR 0 14
85160: ST_TO_ADDR
// for j = 1 to k do
85161: LD_ADDR_VAR 0 8
85165: PUSH
85166: DOUBLE
85167: LD_INT 1
85169: DEC
85170: ST_TO_ADDR
85171: LD_VAR 0 9
85175: PUSH
85176: FOR_TO
85177: IFFALSE 85275
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
85179: LD_VAR 0 14
85183: PUSH
85184: LD_VAR 0 8
85188: ARRAY
85189: PPUSH
85190: CALL_OW 247
85194: PUSH
85195: LD_INT 1
85197: EQUAL
85198: PUSH
85199: LD_VAR 0 14
85203: PUSH
85204: LD_VAR 0 8
85208: ARRAY
85209: PPUSH
85210: CALL_OW 256
85214: PUSH
85215: LD_INT 250
85217: LESS
85218: PUSH
85219: LD_VAR 0 20
85223: AND
85224: PUSH
85225: LD_VAR 0 20
85229: NOT
85230: PUSH
85231: LD_VAR 0 14
85235: PUSH
85236: LD_VAR 0 8
85240: ARRAY
85241: PPUSH
85242: CALL_OW 256
85246: PUSH
85247: LD_INT 250
85249: GREATEREQUAL
85250: AND
85251: OR
85252: AND
85253: IFFALSE 85273
// begin x := tmp [ j ] ;
85255: LD_ADDR_VAR 0 10
85259: PUSH
85260: LD_VAR 0 14
85264: PUSH
85265: LD_VAR 0 8
85269: ARRAY
85270: ST_TO_ADDR
// break ;
85271: GO 85275
// end ;
85273: GO 85176
85275: POP
85276: POP
// if x then
85277: LD_VAR 0 10
85281: IFFALSE 85305
// ComAttackUnit ( group [ i ] , x ) else
85283: LD_VAR 0 4
85287: PUSH
85288: LD_VAR 0 7
85292: ARRAY
85293: PPUSH
85294: LD_VAR 0 10
85298: PPUSH
85299: CALL_OW 115
85303: GO 85329
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
85305: LD_VAR 0 4
85309: PUSH
85310: LD_VAR 0 7
85314: ARRAY
85315: PPUSH
85316: LD_VAR 0 14
85320: PUSH
85321: LD_INT 1
85323: ARRAY
85324: PPUSH
85325: CALL_OW 115
// if not HasTask ( group [ i ] ) then
85329: LD_VAR 0 4
85333: PUSH
85334: LD_VAR 0 7
85338: ARRAY
85339: PPUSH
85340: CALL_OW 314
85344: NOT
85345: IFFALSE 85383
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
85347: LD_VAR 0 4
85351: PUSH
85352: LD_VAR 0 7
85356: ARRAY
85357: PPUSH
85358: LD_VAR 0 14
85362: PPUSH
85363: LD_VAR 0 4
85367: PUSH
85368: LD_VAR 0 7
85372: ARRAY
85373: PPUSH
85374: CALL_OW 74
85378: PPUSH
85379: CALL_OW 115
// end ; end ; end ;
85383: GO 81262
85385: POP
85386: POP
// wait ( 0 0$2 ) ;
85387: LD_INT 70
85389: PPUSH
85390: CALL_OW 67
// until not group or group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
85394: LD_VAR 0 4
85398: NOT
85399: PUSH
85400: LD_VAR 0 4
85404: PUSH
85405: EMPTY
85406: EQUAL
85407: OR
85408: PUSH
85409: LD_INT 81
85411: PUSH
85412: LD_VAR 0 35
85416: PUSH
85417: EMPTY
85418: LIST
85419: LIST
85420: PPUSH
85421: CALL_OW 69
85425: NOT
85426: OR
85427: IFFALSE 81247
// end ;
85429: LD_VAR 0 2
85433: RET
// export function BasicDefend ( base , solds ) ; var enemy , e , side , i , hex ; begin
85434: LD_INT 0
85436: PPUSH
85437: PPUSH
85438: PPUSH
85439: PPUSH
85440: PPUSH
85441: PPUSH
// if not base or not mc_bases [ base ] or not solds then
85442: LD_VAR 0 1
85446: NOT
85447: PUSH
85448: LD_EXP 178
85452: PUSH
85453: LD_VAR 0 1
85457: ARRAY
85458: NOT
85459: OR
85460: PUSH
85461: LD_VAR 0 2
85465: NOT
85466: OR
85467: IFFALSE 85471
// exit ;
85469: GO 86025
// side := mc_sides [ base ] ;
85471: LD_ADDR_VAR 0 6
85475: PUSH
85476: LD_EXP 204
85480: PUSH
85481: LD_VAR 0 1
85485: ARRAY
85486: ST_TO_ADDR
// if not side then
85487: LD_VAR 0 6
85491: NOT
85492: IFFALSE 85496
// exit ;
85494: GO 86025
// for i in solds do
85496: LD_ADDR_VAR 0 7
85500: PUSH
85501: LD_VAR 0 2
85505: PUSH
85506: FOR_IN
85507: IFFALSE 85568
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
85509: LD_VAR 0 7
85513: PPUSH
85514: CALL_OW 310
85518: PPUSH
85519: CALL_OW 266
85523: PUSH
85524: LD_INT 32
85526: PUSH
85527: LD_INT 31
85529: PUSH
85530: EMPTY
85531: LIST
85532: LIST
85533: IN
85534: IFFALSE 85554
// solds := solds diff i else
85536: LD_ADDR_VAR 0 2
85540: PUSH
85541: LD_VAR 0 2
85545: PUSH
85546: LD_VAR 0 7
85550: DIFF
85551: ST_TO_ADDR
85552: GO 85566
// SetTag ( i , 18 ) ;
85554: LD_VAR 0 7
85558: PPUSH
85559: LD_INT 18
85561: PPUSH
85562: CALL_OW 109
85566: GO 85506
85568: POP
85569: POP
// if not solds then
85570: LD_VAR 0 2
85574: NOT
85575: IFFALSE 85579
// exit ;
85577: GO 86025
// repeat wait ( 0 0$2 ) ;
85579: LD_INT 70
85581: PPUSH
85582: CALL_OW 67
// enemy := mc_scan [ base ] ;
85586: LD_ADDR_VAR 0 4
85590: PUSH
85591: LD_EXP 201
85595: PUSH
85596: LD_VAR 0 1
85600: ARRAY
85601: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
85602: LD_EXP 178
85606: PUSH
85607: LD_VAR 0 1
85611: ARRAY
85612: NOT
85613: PUSH
85614: LD_EXP 178
85618: PUSH
85619: LD_VAR 0 1
85623: ARRAY
85624: PUSH
85625: EMPTY
85626: EQUAL
85627: OR
85628: IFFALSE 85665
// begin for i in solds do
85630: LD_ADDR_VAR 0 7
85634: PUSH
85635: LD_VAR 0 2
85639: PUSH
85640: FOR_IN
85641: IFFALSE 85654
// ComStop ( i ) ;
85643: LD_VAR 0 7
85647: PPUSH
85648: CALL_OW 141
85652: GO 85640
85654: POP
85655: POP
// solds := [ ] ;
85656: LD_ADDR_VAR 0 2
85660: PUSH
85661: EMPTY
85662: ST_TO_ADDR
// exit ;
85663: GO 86025
// end ; for i in solds do
85665: LD_ADDR_VAR 0 7
85669: PUSH
85670: LD_VAR 0 2
85674: PUSH
85675: FOR_IN
85676: IFFALSE 85997
// begin if IsInUnit ( i ) then
85678: LD_VAR 0 7
85682: PPUSH
85683: CALL_OW 310
85687: IFFALSE 85698
// ComExitBuilding ( i ) ;
85689: LD_VAR 0 7
85693: PPUSH
85694: CALL_OW 122
// if GetLives ( i ) > 500 then
85698: LD_VAR 0 7
85702: PPUSH
85703: CALL_OW 256
85707: PUSH
85708: LD_INT 500
85710: GREATER
85711: IFFALSE 85764
// begin e := NearestUnitToUnit ( enemy , i ) ;
85713: LD_ADDR_VAR 0 5
85717: PUSH
85718: LD_VAR 0 4
85722: PPUSH
85723: LD_VAR 0 7
85727: PPUSH
85728: CALL_OW 74
85732: ST_TO_ADDR
// ComAgressiveMove ( i , GetX ( e ) , GetY ( e ) ) ;
85733: LD_VAR 0 7
85737: PPUSH
85738: LD_VAR 0 5
85742: PPUSH
85743: CALL_OW 250
85747: PPUSH
85748: LD_VAR 0 5
85752: PPUSH
85753: CALL_OW 251
85757: PPUSH
85758: CALL_OW 114
// end else
85762: GO 85995
// if GetDistUnits ( i , NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ) > 10 then
85764: LD_VAR 0 7
85768: PPUSH
85769: LD_EXP 178
85773: PUSH
85774: LD_VAR 0 1
85778: ARRAY
85779: PPUSH
85780: LD_INT 2
85782: PUSH
85783: LD_INT 30
85785: PUSH
85786: LD_INT 0
85788: PUSH
85789: EMPTY
85790: LIST
85791: LIST
85792: PUSH
85793: LD_INT 30
85795: PUSH
85796: LD_INT 1
85798: PUSH
85799: EMPTY
85800: LIST
85801: LIST
85802: PUSH
85803: LD_INT 30
85805: PUSH
85806: LD_INT 6
85808: PUSH
85809: EMPTY
85810: LIST
85811: LIST
85812: PUSH
85813: EMPTY
85814: LIST
85815: LIST
85816: LIST
85817: LIST
85818: PPUSH
85819: CALL_OW 72
85823: PPUSH
85824: LD_VAR 0 7
85828: PPUSH
85829: CALL_OW 74
85833: PPUSH
85834: CALL_OW 296
85838: PUSH
85839: LD_INT 10
85841: GREATER
85842: IFFALSE 85995
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
85844: LD_ADDR_VAR 0 8
85848: PUSH
85849: LD_EXP 178
85853: PUSH
85854: LD_VAR 0 1
85858: ARRAY
85859: PPUSH
85860: LD_INT 2
85862: PUSH
85863: LD_INT 30
85865: PUSH
85866: LD_INT 0
85868: PUSH
85869: EMPTY
85870: LIST
85871: LIST
85872: PUSH
85873: LD_INT 30
85875: PUSH
85876: LD_INT 1
85878: PUSH
85879: EMPTY
85880: LIST
85881: LIST
85882: PUSH
85883: LD_INT 30
85885: PUSH
85886: LD_INT 6
85888: PUSH
85889: EMPTY
85890: LIST
85891: LIST
85892: PUSH
85893: EMPTY
85894: LIST
85895: LIST
85896: LIST
85897: LIST
85898: PPUSH
85899: CALL_OW 72
85903: PPUSH
85904: LD_VAR 0 7
85908: PPUSH
85909: CALL_OW 74
85913: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
85914: LD_VAR 0 7
85918: PPUSH
85919: LD_VAR 0 8
85923: PPUSH
85924: CALL_OW 250
85928: PPUSH
85929: LD_INT 3
85931: PPUSH
85932: LD_INT 5
85934: PPUSH
85935: CALL_OW 272
85939: PPUSH
85940: LD_VAR 0 8
85944: PPUSH
85945: CALL_OW 251
85949: PPUSH
85950: LD_INT 3
85952: PPUSH
85953: LD_INT 5
85955: PPUSH
85956: CALL_OW 273
85960: PPUSH
85961: CALL_OW 111
// SetTag ( i , 0 ) ;
85965: LD_VAR 0 7
85969: PPUSH
85970: LD_INT 0
85972: PPUSH
85973: CALL_OW 109
// solds := solds diff i ;
85977: LD_ADDR_VAR 0 2
85981: PUSH
85982: LD_VAR 0 2
85986: PUSH
85987: LD_VAR 0 7
85991: DIFF
85992: ST_TO_ADDR
// continue ;
85993: GO 85675
// end ; end ;
85995: GO 85675
85997: POP
85998: POP
// until not solds or not enemy ;
85999: LD_VAR 0 2
86003: NOT
86004: PUSH
86005: LD_VAR 0 4
86009: NOT
86010: OR
86011: IFFALSE 85579
// MC_Reset ( base , 18 ) ;
86013: LD_VAR 0 1
86017: PPUSH
86018: LD_INT 18
86020: PPUSH
86021: CALL 92180 0 2
// end ;
86025: LD_VAR 0 3
86029: RET
// export function Defend ( base , defenders ) ; var i , j , x , depot , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend , class , enemy ; begin
86030: LD_INT 0
86032: PPUSH
86033: PPUSH
86034: PPUSH
86035: PPUSH
86036: PPUSH
86037: PPUSH
86038: PPUSH
86039: PPUSH
86040: PPUSH
86041: PPUSH
86042: PPUSH
86043: PPUSH
86044: PPUSH
86045: PPUSH
86046: PPUSH
86047: PPUSH
86048: PPUSH
86049: PPUSH
86050: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
86051: LD_ADDR_VAR 0 12
86055: PUSH
86056: LD_EXP 178
86060: PUSH
86061: LD_VAR 0 1
86065: ARRAY
86066: PPUSH
86067: LD_INT 25
86069: PUSH
86070: LD_INT 3
86072: PUSH
86073: EMPTY
86074: LIST
86075: LIST
86076: PPUSH
86077: CALL_OW 72
86081: ST_TO_ADDR
// if mc_remote_driver [ base ] then
86082: LD_EXP 218
86086: PUSH
86087: LD_VAR 0 1
86091: ARRAY
86092: IFFALSE 86116
// mechs := mechs diff mc_remote_driver [ base ] ;
86094: LD_ADDR_VAR 0 12
86098: PUSH
86099: LD_VAR 0 12
86103: PUSH
86104: LD_EXP 218
86108: PUSH
86109: LD_VAR 0 1
86113: ARRAY
86114: DIFF
86115: ST_TO_ADDR
// for i in mechs do
86116: LD_ADDR_VAR 0 4
86120: PUSH
86121: LD_VAR 0 12
86125: PUSH
86126: FOR_IN
86127: IFFALSE 86162
// if GetTag ( i ) > 0 then
86129: LD_VAR 0 4
86133: PPUSH
86134: CALL_OW 110
86138: PUSH
86139: LD_INT 0
86141: GREATER
86142: IFFALSE 86160
// mechs := mechs diff i ;
86144: LD_ADDR_VAR 0 12
86148: PUSH
86149: LD_VAR 0 12
86153: PUSH
86154: LD_VAR 0 4
86158: DIFF
86159: ST_TO_ADDR
86160: GO 86126
86162: POP
86163: POP
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
86164: LD_ADDR_VAR 0 8
86168: PUSH
86169: LD_EXP 178
86173: PUSH
86174: LD_VAR 0 1
86178: ARRAY
86179: PPUSH
86180: LD_INT 2
86182: PUSH
86183: LD_INT 25
86185: PUSH
86186: LD_INT 1
86188: PUSH
86189: EMPTY
86190: LIST
86191: LIST
86192: PUSH
86193: LD_INT 25
86195: PUSH
86196: LD_INT 5
86198: PUSH
86199: EMPTY
86200: LIST
86201: LIST
86202: PUSH
86203: LD_INT 25
86205: PUSH
86206: LD_INT 8
86208: PUSH
86209: EMPTY
86210: LIST
86211: LIST
86212: PUSH
86213: LD_INT 25
86215: PUSH
86216: LD_INT 9
86218: PUSH
86219: EMPTY
86220: LIST
86221: LIST
86222: PUSH
86223: EMPTY
86224: LIST
86225: LIST
86226: LIST
86227: LIST
86228: LIST
86229: PPUSH
86230: CALL_OW 72
86234: ST_TO_ADDR
// if not defenders and not solds then
86235: LD_VAR 0 2
86239: NOT
86240: PUSH
86241: LD_VAR 0 8
86245: NOT
86246: AND
86247: IFFALSE 86251
// exit ;
86249: GO 88021
// depot_under_attack := false ;
86251: LD_ADDR_VAR 0 16
86255: PUSH
86256: LD_INT 0
86258: ST_TO_ADDR
// sold_defenders := [ ] ;
86259: LD_ADDR_VAR 0 17
86263: PUSH
86264: EMPTY
86265: ST_TO_ADDR
// if mechs then
86266: LD_VAR 0 12
86270: IFFALSE 86423
// for i in UnitFilter ( defenders , [ f_type , unit_vehicle ] ) do
86272: LD_ADDR_VAR 0 4
86276: PUSH
86277: LD_VAR 0 2
86281: PPUSH
86282: LD_INT 21
86284: PUSH
86285: LD_INT 2
86287: PUSH
86288: EMPTY
86289: LIST
86290: LIST
86291: PPUSH
86292: CALL_OW 72
86296: PUSH
86297: FOR_IN
86298: IFFALSE 86421
// begin if GetTag ( i ) <> 20 then
86300: LD_VAR 0 4
86304: PPUSH
86305: CALL_OW 110
86309: PUSH
86310: LD_INT 20
86312: NONEQUAL
86313: IFFALSE 86327
// SetTag ( i , 20 ) ;
86315: LD_VAR 0 4
86319: PPUSH
86320: LD_INT 20
86322: PPUSH
86323: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) then
86327: LD_VAR 0 4
86331: PPUSH
86332: CALL_OW 263
86336: PUSH
86337: LD_INT 1
86339: EQUAL
86340: PUSH
86341: LD_VAR 0 4
86345: PPUSH
86346: CALL_OW 311
86350: NOT
86351: AND
86352: IFFALSE 86419
// begin un := mechs [ 1 ] ;
86354: LD_ADDR_VAR 0 10
86358: PUSH
86359: LD_VAR 0 12
86363: PUSH
86364: LD_INT 1
86366: ARRAY
86367: ST_TO_ADDR
// ComExit ( un ) ;
86368: LD_VAR 0 10
86372: PPUSH
86373: CALL 57023 0 1
// AddComEnterUnit ( un , i ) ;
86377: LD_VAR 0 10
86381: PPUSH
86382: LD_VAR 0 4
86386: PPUSH
86387: CALL_OW 180
// SetTag ( un , 19 ) ;
86391: LD_VAR 0 10
86395: PPUSH
86396: LD_INT 19
86398: PPUSH
86399: CALL_OW 109
// mechs := mechs diff un ;
86403: LD_ADDR_VAR 0 12
86407: PUSH
86408: LD_VAR 0 12
86412: PUSH
86413: LD_VAR 0 10
86417: DIFF
86418: ST_TO_ADDR
// end ; end ;
86419: GO 86297
86421: POP
86422: POP
// if solds then
86423: LD_VAR 0 8
86427: IFFALSE 86486
// for i in solds do
86429: LD_ADDR_VAR 0 4
86433: PUSH
86434: LD_VAR 0 8
86438: PUSH
86439: FOR_IN
86440: IFFALSE 86484
// if not GetTag ( i ) then
86442: LD_VAR 0 4
86446: PPUSH
86447: CALL_OW 110
86451: NOT
86452: IFFALSE 86482
// begin defenders := defenders union i ;
86454: LD_ADDR_VAR 0 2
86458: PUSH
86459: LD_VAR 0 2
86463: PUSH
86464: LD_VAR 0 4
86468: UNION
86469: ST_TO_ADDR
// SetTag ( i , 18 ) ;
86470: LD_VAR 0 4
86474: PPUSH
86475: LD_INT 18
86477: PPUSH
86478: CALL_OW 109
// end ;
86482: GO 86439
86484: POP
86485: POP
// repeat wait ( 0 0$2 ) ;
86486: LD_INT 70
86488: PPUSH
86489: CALL_OW 67
// enemy := mc_scan [ base ] ;
86493: LD_ADDR_VAR 0 21
86497: PUSH
86498: LD_EXP 201
86502: PUSH
86503: LD_VAR 0 1
86507: ARRAY
86508: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
86509: LD_EXP 178
86513: PUSH
86514: LD_VAR 0 1
86518: ARRAY
86519: NOT
86520: PUSH
86521: LD_EXP 178
86525: PUSH
86526: LD_VAR 0 1
86530: ARRAY
86531: PUSH
86532: EMPTY
86533: EQUAL
86534: OR
86535: IFFALSE 86572
// begin for i in defenders do
86537: LD_ADDR_VAR 0 4
86541: PUSH
86542: LD_VAR 0 2
86546: PUSH
86547: FOR_IN
86548: IFFALSE 86561
// ComStop ( i ) ;
86550: LD_VAR 0 4
86554: PPUSH
86555: CALL_OW 141
86559: GO 86547
86561: POP
86562: POP
// defenders := [ ] ;
86563: LD_ADDR_VAR 0 2
86567: PUSH
86568: EMPTY
86569: ST_TO_ADDR
// exit ;
86570: GO 88021
// end ; for i in defenders do
86572: LD_ADDR_VAR 0 4
86576: PUSH
86577: LD_VAR 0 2
86581: PUSH
86582: FOR_IN
86583: IFFALSE 87481
// begin e := NearestUnitToUnit ( enemy , i ) ;
86585: LD_ADDR_VAR 0 13
86589: PUSH
86590: LD_VAR 0 21
86594: PPUSH
86595: LD_VAR 0 4
86599: PPUSH
86600: CALL_OW 74
86604: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
86605: LD_ADDR_VAR 0 7
86609: PUSH
86610: LD_EXP 178
86614: PUSH
86615: LD_VAR 0 1
86619: ARRAY
86620: PPUSH
86621: LD_INT 2
86623: PUSH
86624: LD_INT 30
86626: PUSH
86627: LD_INT 0
86629: PUSH
86630: EMPTY
86631: LIST
86632: LIST
86633: PUSH
86634: LD_INT 30
86636: PUSH
86637: LD_INT 1
86639: PUSH
86640: EMPTY
86641: LIST
86642: LIST
86643: PUSH
86644: EMPTY
86645: LIST
86646: LIST
86647: LIST
86648: PPUSH
86649: CALL_OW 72
86653: ST_TO_ADDR
// depot_under_attack := ( not depot or UnitFilter ( depot , [ f_not , [ f_lives , 600 ] ] ) ) ;
86654: LD_ADDR_VAR 0 16
86658: PUSH
86659: LD_VAR 0 7
86663: NOT
86664: PUSH
86665: LD_VAR 0 7
86669: PPUSH
86670: LD_INT 3
86672: PUSH
86673: LD_INT 24
86675: PUSH
86676: LD_INT 600
86678: PUSH
86679: EMPTY
86680: LIST
86681: LIST
86682: PUSH
86683: EMPTY
86684: LIST
86685: LIST
86686: PPUSH
86687: CALL_OW 72
86691: OR
86692: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
86693: LD_VAR 0 4
86697: PPUSH
86698: CALL_OW 247
86702: PUSH
86703: LD_INT 2
86705: DOUBLE
86706: EQUAL
86707: IFTRUE 86711
86709: GO 87107
86711: POP
// begin if GetLives ( i ) = 1000 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
86712: LD_VAR 0 4
86716: PPUSH
86717: CALL_OW 256
86721: PUSH
86722: LD_INT 1000
86724: EQUAL
86725: PUSH
86726: LD_VAR 0 4
86730: PPUSH
86731: LD_VAR 0 13
86735: PPUSH
86736: CALL_OW 296
86740: PUSH
86741: LD_INT 40
86743: LESS
86744: PUSH
86745: LD_VAR 0 13
86749: PPUSH
86750: LD_EXP 203
86754: PUSH
86755: LD_VAR 0 1
86759: ARRAY
86760: PPUSH
86761: CALL_OW 308
86765: OR
86766: AND
86767: IFFALSE 86889
// begin if GetEngine ( i ) = engine_combustion and GetFuel ( i ) < 30 and depot then
86769: LD_VAR 0 4
86773: PPUSH
86774: CALL_OW 262
86778: PUSH
86779: LD_INT 1
86781: EQUAL
86782: PUSH
86783: LD_VAR 0 4
86787: PPUSH
86788: CALL_OW 261
86792: PUSH
86793: LD_INT 30
86795: LESS
86796: AND
86797: PUSH
86798: LD_VAR 0 7
86802: AND
86803: IFFALSE 86873
// begin ComMoveUnit ( i , NearestUnitToUnit ( depot , i ) ) ;
86805: LD_VAR 0 4
86809: PPUSH
86810: LD_VAR 0 7
86814: PPUSH
86815: LD_VAR 0 4
86819: PPUSH
86820: CALL_OW 74
86824: PPUSH
86825: CALL_OW 112
// if GetDistUnits ( i , NearestUnitToUnit ( depot , i ) ) < 6 then
86829: LD_VAR 0 4
86833: PPUSH
86834: LD_VAR 0 7
86838: PPUSH
86839: LD_VAR 0 4
86843: PPUSH
86844: CALL_OW 74
86848: PPUSH
86849: CALL_OW 296
86853: PUSH
86854: LD_INT 6
86856: LESS
86857: IFFALSE 86871
// SetFuel ( i , 100 ) ;
86859: LD_VAR 0 4
86863: PPUSH
86864: LD_INT 100
86866: PPUSH
86867: CALL_OW 240
// end else
86871: GO 86887
// ComAttackUnit ( i , e ) ;
86873: LD_VAR 0 4
86877: PPUSH
86878: LD_VAR 0 13
86882: PPUSH
86883: CALL_OW 115
// end else
86887: GO 86990
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
86889: LD_VAR 0 13
86893: PPUSH
86894: LD_EXP 203
86898: PUSH
86899: LD_VAR 0 1
86903: ARRAY
86904: PPUSH
86905: CALL_OW 308
86909: NOT
86910: PUSH
86911: LD_VAR 0 4
86915: PPUSH
86916: LD_VAR 0 13
86920: PPUSH
86921: CALL_OW 296
86925: PUSH
86926: LD_INT 40
86928: GREATEREQUAL
86929: AND
86930: PUSH
86931: LD_VAR 0 4
86935: PPUSH
86936: CALL_OW 256
86940: PUSH
86941: LD_INT 650
86943: LESSEQUAL
86944: OR
86945: PUSH
86946: LD_VAR 0 4
86950: PPUSH
86951: LD_EXP 202
86955: PUSH
86956: LD_VAR 0 1
86960: ARRAY
86961: PPUSH
86962: CALL_OW 308
86966: NOT
86967: AND
86968: IFFALSE 86990
// ComMoveToArea ( i , mc_parking [ base ] ) ;
86970: LD_VAR 0 4
86974: PPUSH
86975: LD_EXP 202
86979: PUSH
86980: LD_VAR 0 1
86984: ARRAY
86985: PPUSH
86986: CALL_OW 113
// if GetLives ( i ) < 1000 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
86990: LD_VAR 0 4
86994: PPUSH
86995: CALL_OW 256
86999: PUSH
87000: LD_INT 1000
87002: LESS
87003: PUSH
87004: LD_VAR 0 4
87008: PPUSH
87009: CALL_OW 263
87013: PUSH
87014: LD_INT 1
87016: EQUAL
87017: AND
87018: PUSH
87019: LD_VAR 0 4
87023: PPUSH
87024: CALL_OW 311
87028: AND
87029: PUSH
87030: LD_VAR 0 4
87034: PPUSH
87035: LD_EXP 202
87039: PUSH
87040: LD_VAR 0 1
87044: ARRAY
87045: PPUSH
87046: CALL_OW 308
87050: AND
87051: IFFALSE 87105
// begin mech := IsDrivenBy ( i ) ;
87053: LD_ADDR_VAR 0 9
87057: PUSH
87058: LD_VAR 0 4
87062: PPUSH
87063: CALL_OW 311
87067: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
87068: LD_VAR 0 9
87072: PPUSH
87073: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
87077: LD_VAR 0 9
87081: PPUSH
87082: LD_VAR 0 4
87086: PPUSH
87087: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
87091: LD_VAR 0 9
87095: PPUSH
87096: LD_VAR 0 4
87100: PPUSH
87101: CALL_OW 180
// end ; end ; unit_human :
87105: GO 87452
87107: LD_INT 1
87109: DOUBLE
87110: EQUAL
87111: IFTRUE 87115
87113: GO 87451
87115: POP
// begin b := IsInUnit ( i ) ;
87116: LD_ADDR_VAR 0 18
87120: PUSH
87121: LD_VAR 0 4
87125: PPUSH
87126: CALL_OW 310
87130: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
87131: LD_ADDR_VAR 0 19
87135: PUSH
87136: LD_VAR 0 18
87140: NOT
87141: PUSH
87142: LD_VAR 0 18
87146: PPUSH
87147: CALL_OW 266
87151: PUSH
87152: LD_INT 32
87154: PUSH
87155: LD_INT 31
87157: PUSH
87158: EMPTY
87159: LIST
87160: LIST
87161: IN
87162: OR
87163: ST_TO_ADDR
// if GetBType ( b ) = b_barracks and GetClass ( i ) in [ 1 , 2 , 3 , 4 ] then
87164: LD_VAR 0 18
87168: PPUSH
87169: CALL_OW 266
87173: PUSH
87174: LD_INT 5
87176: EQUAL
87177: PUSH
87178: LD_VAR 0 4
87182: PPUSH
87183: CALL_OW 257
87187: PUSH
87188: LD_INT 1
87190: PUSH
87191: LD_INT 2
87193: PUSH
87194: LD_INT 3
87196: PUSH
87197: LD_INT 4
87199: PUSH
87200: EMPTY
87201: LIST
87202: LIST
87203: LIST
87204: LIST
87205: IN
87206: AND
87207: IFFALSE 87244
// begin class := AllowSpecClass ( i ) ;
87209: LD_ADDR_VAR 0 20
87213: PUSH
87214: LD_VAR 0 4
87218: PPUSH
87219: CALL 21010 0 1
87223: ST_TO_ADDR
// if class then
87224: LD_VAR 0 20
87228: IFFALSE 87244
// ComChangeProfession ( i , class ) ;
87230: LD_VAR 0 4
87234: PPUSH
87235: LD_VAR 0 20
87239: PPUSH
87240: CALL_OW 123
// end ; if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
87244: LD_VAR 0 16
87248: PUSH
87249: LD_VAR 0 2
87253: PPUSH
87254: LD_INT 21
87256: PUSH
87257: LD_INT 2
87259: PUSH
87260: EMPTY
87261: LIST
87262: LIST
87263: PPUSH
87264: CALL_OW 72
87268: PUSH
87269: LD_INT 1
87271: LESSEQUAL
87272: OR
87273: PUSH
87274: LD_VAR 0 19
87278: AND
87279: PUSH
87280: LD_VAR 0 4
87284: PUSH
87285: LD_VAR 0 17
87289: IN
87290: NOT
87291: AND
87292: IFFALSE 87385
// begin if b then
87294: LD_VAR 0 18
87298: IFFALSE 87347
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
87300: LD_VAR 0 18
87304: PPUSH
87305: LD_VAR 0 21
87309: PPUSH
87310: LD_VAR 0 18
87314: PPUSH
87315: CALL_OW 74
87319: PPUSH
87320: CALL_OW 296
87324: PUSH
87325: LD_INT 10
87327: LESS
87328: PUSH
87329: LD_VAR 0 18
87333: PPUSH
87334: CALL_OW 461
87338: PUSH
87339: LD_INT 7
87341: NONEQUAL
87342: AND
87343: IFFALSE 87347
// continue ;
87345: GO 86582
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
87347: LD_ADDR_VAR 0 17
87351: PUSH
87352: LD_VAR 0 17
87356: PPUSH
87357: LD_VAR 0 17
87361: PUSH
87362: LD_INT 1
87364: PLUS
87365: PPUSH
87366: LD_VAR 0 4
87370: PPUSH
87371: CALL_OW 1
87375: ST_TO_ADDR
// ComExitBuilding ( i ) ;
87376: LD_VAR 0 4
87380: PPUSH
87381: CALL_OW 122
// end ; if sold_defenders then
87385: LD_VAR 0 17
87389: IFFALSE 87449
// if i in sold_defenders then
87391: LD_VAR 0 4
87395: PUSH
87396: LD_VAR 0 17
87400: IN
87401: IFFALSE 87449
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
87403: LD_VAR 0 4
87407: PPUSH
87408: CALL_OW 314
87412: NOT
87413: PUSH
87414: LD_VAR 0 4
87418: PPUSH
87419: LD_VAR 0 13
87423: PPUSH
87424: CALL_OW 296
87428: PUSH
87429: LD_INT 30
87431: LESS
87432: AND
87433: IFFALSE 87449
// ComAttackUnit ( i , e ) ;
87435: LD_VAR 0 4
87439: PPUSH
87440: LD_VAR 0 13
87444: PPUSH
87445: CALL_OW 115
// end ; end ; end ;
87449: GO 87452
87451: POP
// if IsDead ( i ) then
87452: LD_VAR 0 4
87456: PPUSH
87457: CALL_OW 301
87461: IFFALSE 87479
// defenders := defenders diff i ;
87463: LD_ADDR_VAR 0 2
87467: PUSH
87468: LD_VAR 0 2
87472: PUSH
87473: LD_VAR 0 4
87477: DIFF
87478: ST_TO_ADDR
// end ;
87479: GO 86582
87481: POP
87482: POP
// until not enemy or not defenders or not mc_bases [ base ] ;
87483: LD_VAR 0 21
87487: NOT
87488: PUSH
87489: LD_VAR 0 2
87493: NOT
87494: OR
87495: PUSH
87496: LD_EXP 178
87500: PUSH
87501: LD_VAR 0 1
87505: ARRAY
87506: NOT
87507: OR
87508: IFFALSE 86486
// MC_Reset ( base , 18 ) ;
87510: LD_VAR 0 1
87514: PPUSH
87515: LD_INT 18
87517: PPUSH
87518: CALL 92180 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
87522: LD_ADDR_VAR 0 2
87526: PUSH
87527: LD_VAR 0 2
87531: PUSH
87532: LD_VAR 0 2
87536: PPUSH
87537: LD_INT 2
87539: PUSH
87540: LD_INT 25
87542: PUSH
87543: LD_INT 1
87545: PUSH
87546: EMPTY
87547: LIST
87548: LIST
87549: PUSH
87550: LD_INT 25
87552: PUSH
87553: LD_INT 5
87555: PUSH
87556: EMPTY
87557: LIST
87558: LIST
87559: PUSH
87560: LD_INT 25
87562: PUSH
87563: LD_INT 8
87565: PUSH
87566: EMPTY
87567: LIST
87568: LIST
87569: PUSH
87570: LD_INT 25
87572: PUSH
87573: LD_INT 9
87575: PUSH
87576: EMPTY
87577: LIST
87578: LIST
87579: PUSH
87580: EMPTY
87581: LIST
87582: LIST
87583: LIST
87584: LIST
87585: LIST
87586: PPUSH
87587: CALL_OW 72
87591: DIFF
87592: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
87593: LD_VAR 0 21
87597: NOT
87598: PUSH
87599: LD_VAR 0 2
87603: PPUSH
87604: LD_INT 21
87606: PUSH
87607: LD_INT 2
87609: PUSH
87610: EMPTY
87611: LIST
87612: LIST
87613: PPUSH
87614: CALL_OW 72
87618: AND
87619: IFFALSE 87957
// begin tmp := FilterByTag ( defenders , 19 ) ;
87621: LD_ADDR_VAR 0 11
87625: PUSH
87626: LD_VAR 0 2
87630: PPUSH
87631: LD_INT 19
87633: PPUSH
87634: CALL 54199 0 2
87638: ST_TO_ADDR
// if tmp then
87639: LD_VAR 0 11
87643: IFFALSE 87713
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
87645: LD_ADDR_VAR 0 11
87649: PUSH
87650: LD_VAR 0 11
87654: PPUSH
87655: LD_INT 25
87657: PUSH
87658: LD_INT 3
87660: PUSH
87661: EMPTY
87662: LIST
87663: LIST
87664: PPUSH
87665: CALL_OW 72
87669: ST_TO_ADDR
// if tmp then
87670: LD_VAR 0 11
87674: IFFALSE 87713
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
87676: LD_ADDR_EXP 190
87680: PUSH
87681: LD_EXP 190
87685: PPUSH
87686: LD_VAR 0 1
87690: PPUSH
87691: LD_EXP 190
87695: PUSH
87696: LD_VAR 0 1
87700: ARRAY
87701: PUSH
87702: LD_VAR 0 11
87706: UNION
87707: PPUSH
87708: CALL_OW 1
87712: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
87713: LD_VAR 0 1
87717: PPUSH
87718: LD_INT 19
87720: PPUSH
87721: CALL 92180 0 2
// repeat wait ( 0 0$1 ) ;
87725: LD_INT 35
87727: PPUSH
87728: CALL_OW 67
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
87732: LD_EXP 178
87736: PUSH
87737: LD_VAR 0 1
87741: ARRAY
87742: NOT
87743: PUSH
87744: LD_EXP 178
87748: PUSH
87749: LD_VAR 0 1
87753: ARRAY
87754: PUSH
87755: EMPTY
87756: EQUAL
87757: OR
87758: IFFALSE 87795
// begin for i in defenders do
87760: LD_ADDR_VAR 0 4
87764: PUSH
87765: LD_VAR 0 2
87769: PUSH
87770: FOR_IN
87771: IFFALSE 87784
// ComStop ( i ) ;
87773: LD_VAR 0 4
87777: PPUSH
87778: CALL_OW 141
87782: GO 87770
87784: POP
87785: POP
// defenders := [ ] ;
87786: LD_ADDR_VAR 0 2
87790: PUSH
87791: EMPTY
87792: ST_TO_ADDR
// exit ;
87793: GO 88021
// end ; for i in defenders do
87795: LD_ADDR_VAR 0 4
87799: PUSH
87800: LD_VAR 0 2
87804: PUSH
87805: FOR_IN
87806: IFFALSE 87895
// begin if not IsInArea ( i , mc_parking [ base ] ) then
87808: LD_VAR 0 4
87812: PPUSH
87813: LD_EXP 202
87817: PUSH
87818: LD_VAR 0 1
87822: ARRAY
87823: PPUSH
87824: CALL_OW 308
87828: NOT
87829: IFFALSE 87853
// ComMoveToArea ( i , mc_parking [ base ] ) else
87831: LD_VAR 0 4
87835: PPUSH
87836: LD_EXP 202
87840: PUSH
87841: LD_VAR 0 1
87845: ARRAY
87846: PPUSH
87847: CALL_OW 113
87851: GO 87893
// if GetControl ( i ) = control_manual then
87853: LD_VAR 0 4
87857: PPUSH
87858: CALL_OW 263
87862: PUSH
87863: LD_INT 1
87865: EQUAL
87866: IFFALSE 87893
// if IsDrivenBy ( i ) then
87868: LD_VAR 0 4
87872: PPUSH
87873: CALL_OW 311
87877: IFFALSE 87893
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
87879: LD_VAR 0 4
87883: PPUSH
87884: CALL_OW 311
87888: PPUSH
87889: CALL_OW 121
// end ;
87893: GO 87805
87895: POP
87896: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] or not mc_bases [ base ] ;
87897: LD_VAR 0 2
87901: PPUSH
87902: LD_INT 95
87904: PUSH
87905: LD_EXP 202
87909: PUSH
87910: LD_VAR 0 1
87914: ARRAY
87915: PUSH
87916: EMPTY
87917: LIST
87918: LIST
87919: PPUSH
87920: CALL_OW 72
87924: PUSH
87925: LD_VAR 0 2
87929: EQUAL
87930: PUSH
87931: LD_EXP 201
87935: PUSH
87936: LD_VAR 0 1
87940: ARRAY
87941: OR
87942: PUSH
87943: LD_EXP 178
87947: PUSH
87948: LD_VAR 0 1
87952: ARRAY
87953: NOT
87954: OR
87955: IFFALSE 87725
// end ; mc_defender := Replace ( mc_defender , base , UnitFilter ( defenders , [ f_type , unit_vehicle ] ) ) ;
87957: LD_ADDR_EXP 200
87961: PUSH
87962: LD_EXP 200
87966: PPUSH
87967: LD_VAR 0 1
87971: PPUSH
87972: LD_VAR 0 2
87976: PPUSH
87977: LD_INT 21
87979: PUSH
87980: LD_INT 2
87982: PUSH
87983: EMPTY
87984: LIST
87985: LIST
87986: PPUSH
87987: CALL_OW 72
87991: PPUSH
87992: CALL_OW 1
87996: ST_TO_ADDR
// MC_Reset ( base , 19 ) ;
87997: LD_VAR 0 1
88001: PPUSH
88002: LD_INT 19
88004: PPUSH
88005: CALL 92180 0 2
// MC_Reset ( base , 20 ) ;
88009: LD_VAR 0 1
88013: PPUSH
88014: LD_INT 20
88016: PPUSH
88017: CALL 92180 0 2
// end ; end_of_file
88021: LD_VAR 0 3
88025: RET
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use , mc_is_defending ; export function InitMacro ; var i ; begin
88026: LD_INT 0
88028: PPUSH
88029: PPUSH
// skirmish := false ;
88030: LD_ADDR_EXP 176
88034: PUSH
88035: LD_INT 0
88037: ST_TO_ADDR
// debug_mc := false ;
88038: LD_ADDR_EXP 177
88042: PUSH
88043: LD_INT 0
88045: ST_TO_ADDR
// mc_bases := [ ] ;
88046: LD_ADDR_EXP 178
88050: PUSH
88051: EMPTY
88052: ST_TO_ADDR
// mc_sides := [ ] ;
88053: LD_ADDR_EXP 204
88057: PUSH
88058: EMPTY
88059: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
88060: LD_ADDR_EXP 179
88064: PUSH
88065: EMPTY
88066: ST_TO_ADDR
// mc_building_repairs := [ ] ;
88067: LD_ADDR_EXP 180
88071: PUSH
88072: EMPTY
88073: ST_TO_ADDR
// mc_need_heal := [ ] ;
88074: LD_ADDR_EXP 181
88078: PUSH
88079: EMPTY
88080: ST_TO_ADDR
// mc_healers := [ ] ;
88081: LD_ADDR_EXP 182
88085: PUSH
88086: EMPTY
88087: ST_TO_ADDR
// mc_build_list := [ ] ;
88088: LD_ADDR_EXP 183
88092: PUSH
88093: EMPTY
88094: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
88095: LD_ADDR_EXP 210
88099: PUSH
88100: EMPTY
88101: ST_TO_ADDR
// mc_builders := [ ] ;
88102: LD_ADDR_EXP 184
88106: PUSH
88107: EMPTY
88108: ST_TO_ADDR
// mc_construct_list := [ ] ;
88109: LD_ADDR_EXP 185
88113: PUSH
88114: EMPTY
88115: ST_TO_ADDR
// mc_turret_list := [ ] ;
88116: LD_ADDR_EXP 186
88120: PUSH
88121: EMPTY
88122: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
88123: LD_ADDR_EXP 187
88127: PUSH
88128: EMPTY
88129: ST_TO_ADDR
// mc_miners := [ ] ;
88130: LD_ADDR_EXP 192
88134: PUSH
88135: EMPTY
88136: ST_TO_ADDR
// mc_mines := [ ] ;
88137: LD_ADDR_EXP 191
88141: PUSH
88142: EMPTY
88143: ST_TO_ADDR
// mc_minefields := [ ] ;
88144: LD_ADDR_EXP 193
88148: PUSH
88149: EMPTY
88150: ST_TO_ADDR
// mc_crates := [ ] ;
88151: LD_ADDR_EXP 194
88155: PUSH
88156: EMPTY
88157: ST_TO_ADDR
// mc_crates_collector := [ ] ;
88158: LD_ADDR_EXP 195
88162: PUSH
88163: EMPTY
88164: ST_TO_ADDR
// mc_crates_area := [ ] ;
88165: LD_ADDR_EXP 196
88169: PUSH
88170: EMPTY
88171: ST_TO_ADDR
// mc_vehicles := [ ] ;
88172: LD_ADDR_EXP 197
88176: PUSH
88177: EMPTY
88178: ST_TO_ADDR
// mc_attack := [ ] ;
88179: LD_ADDR_EXP 198
88183: PUSH
88184: EMPTY
88185: ST_TO_ADDR
// mc_produce := [ ] ;
88186: LD_ADDR_EXP 199
88190: PUSH
88191: EMPTY
88192: ST_TO_ADDR
// mc_defender := [ ] ;
88193: LD_ADDR_EXP 200
88197: PUSH
88198: EMPTY
88199: ST_TO_ADDR
// mc_parking := [ ] ;
88200: LD_ADDR_EXP 202
88204: PUSH
88205: EMPTY
88206: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
88207: LD_ADDR_EXP 188
88211: PUSH
88212: EMPTY
88213: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
88214: LD_ADDR_EXP 190
88218: PUSH
88219: EMPTY
88220: ST_TO_ADDR
// mc_scan := [ ] ;
88221: LD_ADDR_EXP 201
88225: PUSH
88226: EMPTY
88227: ST_TO_ADDR
// mc_scan_area := [ ] ;
88228: LD_ADDR_EXP 203
88232: PUSH
88233: EMPTY
88234: ST_TO_ADDR
// mc_tech := [ ] ;
88235: LD_ADDR_EXP 205
88239: PUSH
88240: EMPTY
88241: ST_TO_ADDR
// mc_class := [ ] ;
88242: LD_ADDR_EXP 219
88246: PUSH
88247: EMPTY
88248: ST_TO_ADDR
// mc_class_case_use := [ ] ;
88249: LD_ADDR_EXP 220
88253: PUSH
88254: EMPTY
88255: ST_TO_ADDR
// mc_is_defending := [ ] ;
88256: LD_ADDR_EXP 221
88260: PUSH
88261: EMPTY
88262: ST_TO_ADDR
// end ;
88263: LD_VAR 0 1
88267: RET
// export function MC_Kill ( base ) ; begin
88268: LD_INT 0
88270: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
88271: LD_ADDR_EXP 178
88275: PUSH
88276: LD_EXP 178
88280: PPUSH
88281: LD_VAR 0 1
88285: PPUSH
88286: EMPTY
88287: PPUSH
88288: CALL_OW 1
88292: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
88293: LD_ADDR_EXP 179
88297: PUSH
88298: LD_EXP 179
88302: PPUSH
88303: LD_VAR 0 1
88307: PPUSH
88308: EMPTY
88309: PPUSH
88310: CALL_OW 1
88314: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
88315: LD_ADDR_EXP 180
88319: PUSH
88320: LD_EXP 180
88324: PPUSH
88325: LD_VAR 0 1
88329: PPUSH
88330: EMPTY
88331: PPUSH
88332: CALL_OW 1
88336: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
88337: LD_ADDR_EXP 181
88341: PUSH
88342: LD_EXP 181
88346: PPUSH
88347: LD_VAR 0 1
88351: PPUSH
88352: EMPTY
88353: PPUSH
88354: CALL_OW 1
88358: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
88359: LD_ADDR_EXP 182
88363: PUSH
88364: LD_EXP 182
88368: PPUSH
88369: LD_VAR 0 1
88373: PPUSH
88374: EMPTY
88375: PPUSH
88376: CALL_OW 1
88380: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
88381: LD_ADDR_EXP 183
88385: PUSH
88386: LD_EXP 183
88390: PPUSH
88391: LD_VAR 0 1
88395: PPUSH
88396: EMPTY
88397: PPUSH
88398: CALL_OW 1
88402: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
88403: LD_ADDR_EXP 184
88407: PUSH
88408: LD_EXP 184
88412: PPUSH
88413: LD_VAR 0 1
88417: PPUSH
88418: EMPTY
88419: PPUSH
88420: CALL_OW 1
88424: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
88425: LD_ADDR_EXP 185
88429: PUSH
88430: LD_EXP 185
88434: PPUSH
88435: LD_VAR 0 1
88439: PPUSH
88440: EMPTY
88441: PPUSH
88442: CALL_OW 1
88446: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
88447: LD_ADDR_EXP 186
88451: PUSH
88452: LD_EXP 186
88456: PPUSH
88457: LD_VAR 0 1
88461: PPUSH
88462: EMPTY
88463: PPUSH
88464: CALL_OW 1
88468: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
88469: LD_ADDR_EXP 187
88473: PUSH
88474: LD_EXP 187
88478: PPUSH
88479: LD_VAR 0 1
88483: PPUSH
88484: EMPTY
88485: PPUSH
88486: CALL_OW 1
88490: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
88491: LD_ADDR_EXP 188
88495: PUSH
88496: LD_EXP 188
88500: PPUSH
88501: LD_VAR 0 1
88505: PPUSH
88506: EMPTY
88507: PPUSH
88508: CALL_OW 1
88512: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
88513: LD_ADDR_EXP 189
88517: PUSH
88518: LD_EXP 189
88522: PPUSH
88523: LD_VAR 0 1
88527: PPUSH
88528: LD_INT 0
88530: PPUSH
88531: CALL_OW 1
88535: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
88536: LD_ADDR_EXP 190
88540: PUSH
88541: LD_EXP 190
88545: PPUSH
88546: LD_VAR 0 1
88550: PPUSH
88551: EMPTY
88552: PPUSH
88553: CALL_OW 1
88557: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
88558: LD_ADDR_EXP 191
88562: PUSH
88563: LD_EXP 191
88567: PPUSH
88568: LD_VAR 0 1
88572: PPUSH
88573: EMPTY
88574: PPUSH
88575: CALL_OW 1
88579: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
88580: LD_ADDR_EXP 192
88584: PUSH
88585: LD_EXP 192
88589: PPUSH
88590: LD_VAR 0 1
88594: PPUSH
88595: EMPTY
88596: PPUSH
88597: CALL_OW 1
88601: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
88602: LD_ADDR_EXP 193
88606: PUSH
88607: LD_EXP 193
88611: PPUSH
88612: LD_VAR 0 1
88616: PPUSH
88617: EMPTY
88618: PPUSH
88619: CALL_OW 1
88623: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
88624: LD_ADDR_EXP 194
88628: PUSH
88629: LD_EXP 194
88633: PPUSH
88634: LD_VAR 0 1
88638: PPUSH
88639: EMPTY
88640: PPUSH
88641: CALL_OW 1
88645: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
88646: LD_ADDR_EXP 195
88650: PUSH
88651: LD_EXP 195
88655: PPUSH
88656: LD_VAR 0 1
88660: PPUSH
88661: EMPTY
88662: PPUSH
88663: CALL_OW 1
88667: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
88668: LD_ADDR_EXP 196
88672: PUSH
88673: LD_EXP 196
88677: PPUSH
88678: LD_VAR 0 1
88682: PPUSH
88683: EMPTY
88684: PPUSH
88685: CALL_OW 1
88689: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
88690: LD_ADDR_EXP 197
88694: PUSH
88695: LD_EXP 197
88699: PPUSH
88700: LD_VAR 0 1
88704: PPUSH
88705: EMPTY
88706: PPUSH
88707: CALL_OW 1
88711: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
88712: LD_ADDR_EXP 198
88716: PUSH
88717: LD_EXP 198
88721: PPUSH
88722: LD_VAR 0 1
88726: PPUSH
88727: EMPTY
88728: PPUSH
88729: CALL_OW 1
88733: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
88734: LD_ADDR_EXP 199
88738: PUSH
88739: LD_EXP 199
88743: PPUSH
88744: LD_VAR 0 1
88748: PPUSH
88749: EMPTY
88750: PPUSH
88751: CALL_OW 1
88755: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
88756: LD_ADDR_EXP 200
88760: PUSH
88761: LD_EXP 200
88765: PPUSH
88766: LD_VAR 0 1
88770: PPUSH
88771: EMPTY
88772: PPUSH
88773: CALL_OW 1
88777: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
88778: LD_ADDR_EXP 201
88782: PUSH
88783: LD_EXP 201
88787: PPUSH
88788: LD_VAR 0 1
88792: PPUSH
88793: EMPTY
88794: PPUSH
88795: CALL_OW 1
88799: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
88800: LD_ADDR_EXP 202
88804: PUSH
88805: LD_EXP 202
88809: PPUSH
88810: LD_VAR 0 1
88814: PPUSH
88815: EMPTY
88816: PPUSH
88817: CALL_OW 1
88821: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
88822: LD_ADDR_EXP 203
88826: PUSH
88827: LD_EXP 203
88831: PPUSH
88832: LD_VAR 0 1
88836: PPUSH
88837: EMPTY
88838: PPUSH
88839: CALL_OW 1
88843: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
88844: LD_ADDR_EXP 205
88848: PUSH
88849: LD_EXP 205
88853: PPUSH
88854: LD_VAR 0 1
88858: PPUSH
88859: EMPTY
88860: PPUSH
88861: CALL_OW 1
88865: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
88866: LD_ADDR_EXP 207
88870: PUSH
88871: LD_EXP 207
88875: PPUSH
88876: LD_VAR 0 1
88880: PPUSH
88881: EMPTY
88882: PPUSH
88883: CALL_OW 1
88887: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
88888: LD_ADDR_EXP 208
88892: PUSH
88893: LD_EXP 208
88897: PPUSH
88898: LD_VAR 0 1
88902: PPUSH
88903: EMPTY
88904: PPUSH
88905: CALL_OW 1
88909: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
88910: LD_ADDR_EXP 209
88914: PUSH
88915: LD_EXP 209
88919: PPUSH
88920: LD_VAR 0 1
88924: PPUSH
88925: EMPTY
88926: PPUSH
88927: CALL_OW 1
88931: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
88932: LD_ADDR_EXP 210
88936: PUSH
88937: LD_EXP 210
88941: PPUSH
88942: LD_VAR 0 1
88946: PPUSH
88947: EMPTY
88948: PPUSH
88949: CALL_OW 1
88953: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
88954: LD_ADDR_EXP 211
88958: PUSH
88959: LD_EXP 211
88963: PPUSH
88964: LD_VAR 0 1
88968: PPUSH
88969: EMPTY
88970: PPUSH
88971: CALL_OW 1
88975: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
88976: LD_ADDR_EXP 212
88980: PUSH
88981: LD_EXP 212
88985: PPUSH
88986: LD_VAR 0 1
88990: PPUSH
88991: EMPTY
88992: PPUSH
88993: CALL_OW 1
88997: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
88998: LD_ADDR_EXP 213
89002: PUSH
89003: LD_EXP 213
89007: PPUSH
89008: LD_VAR 0 1
89012: PPUSH
89013: EMPTY
89014: PPUSH
89015: CALL_OW 1
89019: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
89020: LD_ADDR_EXP 214
89024: PUSH
89025: LD_EXP 214
89029: PPUSH
89030: LD_VAR 0 1
89034: PPUSH
89035: EMPTY
89036: PPUSH
89037: CALL_OW 1
89041: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
89042: LD_ADDR_EXP 215
89046: PUSH
89047: LD_EXP 215
89051: PPUSH
89052: LD_VAR 0 1
89056: PPUSH
89057: EMPTY
89058: PPUSH
89059: CALL_OW 1
89063: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
89064: LD_ADDR_EXP 216
89068: PUSH
89069: LD_EXP 216
89073: PPUSH
89074: LD_VAR 0 1
89078: PPUSH
89079: EMPTY
89080: PPUSH
89081: CALL_OW 1
89085: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
89086: LD_ADDR_EXP 217
89090: PUSH
89091: LD_EXP 217
89095: PPUSH
89096: LD_VAR 0 1
89100: PPUSH
89101: EMPTY
89102: PPUSH
89103: CALL_OW 1
89107: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
89108: LD_ADDR_EXP 218
89112: PUSH
89113: LD_EXP 218
89117: PPUSH
89118: LD_VAR 0 1
89122: PPUSH
89123: EMPTY
89124: PPUSH
89125: CALL_OW 1
89129: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
89130: LD_ADDR_EXP 219
89134: PUSH
89135: LD_EXP 219
89139: PPUSH
89140: LD_VAR 0 1
89144: PPUSH
89145: EMPTY
89146: PPUSH
89147: CALL_OW 1
89151: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
89152: LD_ADDR_EXP 220
89156: PUSH
89157: LD_EXP 220
89161: PPUSH
89162: LD_VAR 0 1
89166: PPUSH
89167: LD_INT 0
89169: PPUSH
89170: CALL_OW 1
89174: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
89175: LD_ADDR_EXP 221
89179: PUSH
89180: LD_EXP 221
89184: PPUSH
89185: LD_VAR 0 1
89189: PPUSH
89190: LD_INT 0
89192: PPUSH
89193: CALL_OW 1
89197: ST_TO_ADDR
// end ;
89198: LD_VAR 0 2
89202: RET
// export function MC_Add ( side , units ) ; var base ; begin
89203: LD_INT 0
89205: PPUSH
89206: PPUSH
// base := mc_bases + 1 ;
89207: LD_ADDR_VAR 0 4
89211: PUSH
89212: LD_EXP 178
89216: PUSH
89217: LD_INT 1
89219: PLUS
89220: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
89221: LD_ADDR_EXP 204
89225: PUSH
89226: LD_EXP 204
89230: PPUSH
89231: LD_VAR 0 4
89235: PPUSH
89236: LD_VAR 0 1
89240: PPUSH
89241: CALL_OW 1
89245: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
89246: LD_ADDR_EXP 178
89250: PUSH
89251: LD_EXP 178
89255: PPUSH
89256: LD_VAR 0 4
89260: PPUSH
89261: LD_VAR 0 2
89265: PPUSH
89266: CALL_OW 1
89270: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
89271: LD_ADDR_EXP 179
89275: PUSH
89276: LD_EXP 179
89280: PPUSH
89281: LD_VAR 0 4
89285: PPUSH
89286: EMPTY
89287: PPUSH
89288: CALL_OW 1
89292: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
89293: LD_ADDR_EXP 180
89297: PUSH
89298: LD_EXP 180
89302: PPUSH
89303: LD_VAR 0 4
89307: PPUSH
89308: EMPTY
89309: PPUSH
89310: CALL_OW 1
89314: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
89315: LD_ADDR_EXP 181
89319: PUSH
89320: LD_EXP 181
89324: PPUSH
89325: LD_VAR 0 4
89329: PPUSH
89330: EMPTY
89331: PPUSH
89332: CALL_OW 1
89336: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
89337: LD_ADDR_EXP 182
89341: PUSH
89342: LD_EXP 182
89346: PPUSH
89347: LD_VAR 0 4
89351: PPUSH
89352: EMPTY
89353: PPUSH
89354: CALL_OW 1
89358: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
89359: LD_ADDR_EXP 183
89363: PUSH
89364: LD_EXP 183
89368: PPUSH
89369: LD_VAR 0 4
89373: PPUSH
89374: EMPTY
89375: PPUSH
89376: CALL_OW 1
89380: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
89381: LD_ADDR_EXP 184
89385: PUSH
89386: LD_EXP 184
89390: PPUSH
89391: LD_VAR 0 4
89395: PPUSH
89396: EMPTY
89397: PPUSH
89398: CALL_OW 1
89402: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
89403: LD_ADDR_EXP 185
89407: PUSH
89408: LD_EXP 185
89412: PPUSH
89413: LD_VAR 0 4
89417: PPUSH
89418: EMPTY
89419: PPUSH
89420: CALL_OW 1
89424: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
89425: LD_ADDR_EXP 186
89429: PUSH
89430: LD_EXP 186
89434: PPUSH
89435: LD_VAR 0 4
89439: PPUSH
89440: EMPTY
89441: PPUSH
89442: CALL_OW 1
89446: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
89447: LD_ADDR_EXP 187
89451: PUSH
89452: LD_EXP 187
89456: PPUSH
89457: LD_VAR 0 4
89461: PPUSH
89462: EMPTY
89463: PPUSH
89464: CALL_OW 1
89468: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
89469: LD_ADDR_EXP 188
89473: PUSH
89474: LD_EXP 188
89478: PPUSH
89479: LD_VAR 0 4
89483: PPUSH
89484: EMPTY
89485: PPUSH
89486: CALL_OW 1
89490: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
89491: LD_ADDR_EXP 189
89495: PUSH
89496: LD_EXP 189
89500: PPUSH
89501: LD_VAR 0 4
89505: PPUSH
89506: LD_INT 0
89508: PPUSH
89509: CALL_OW 1
89513: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
89514: LD_ADDR_EXP 190
89518: PUSH
89519: LD_EXP 190
89523: PPUSH
89524: LD_VAR 0 4
89528: PPUSH
89529: EMPTY
89530: PPUSH
89531: CALL_OW 1
89535: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
89536: LD_ADDR_EXP 191
89540: PUSH
89541: LD_EXP 191
89545: PPUSH
89546: LD_VAR 0 4
89550: PPUSH
89551: EMPTY
89552: PPUSH
89553: CALL_OW 1
89557: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
89558: LD_ADDR_EXP 192
89562: PUSH
89563: LD_EXP 192
89567: PPUSH
89568: LD_VAR 0 4
89572: PPUSH
89573: EMPTY
89574: PPUSH
89575: CALL_OW 1
89579: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
89580: LD_ADDR_EXP 193
89584: PUSH
89585: LD_EXP 193
89589: PPUSH
89590: LD_VAR 0 4
89594: PPUSH
89595: EMPTY
89596: PPUSH
89597: CALL_OW 1
89601: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
89602: LD_ADDR_EXP 194
89606: PUSH
89607: LD_EXP 194
89611: PPUSH
89612: LD_VAR 0 4
89616: PPUSH
89617: EMPTY
89618: PPUSH
89619: CALL_OW 1
89623: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
89624: LD_ADDR_EXP 195
89628: PUSH
89629: LD_EXP 195
89633: PPUSH
89634: LD_VAR 0 4
89638: PPUSH
89639: EMPTY
89640: PPUSH
89641: CALL_OW 1
89645: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
89646: LD_ADDR_EXP 196
89650: PUSH
89651: LD_EXP 196
89655: PPUSH
89656: LD_VAR 0 4
89660: PPUSH
89661: EMPTY
89662: PPUSH
89663: CALL_OW 1
89667: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
89668: LD_ADDR_EXP 197
89672: PUSH
89673: LD_EXP 197
89677: PPUSH
89678: LD_VAR 0 4
89682: PPUSH
89683: EMPTY
89684: PPUSH
89685: CALL_OW 1
89689: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
89690: LD_ADDR_EXP 198
89694: PUSH
89695: LD_EXP 198
89699: PPUSH
89700: LD_VAR 0 4
89704: PPUSH
89705: EMPTY
89706: PPUSH
89707: CALL_OW 1
89711: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
89712: LD_ADDR_EXP 199
89716: PUSH
89717: LD_EXP 199
89721: PPUSH
89722: LD_VAR 0 4
89726: PPUSH
89727: EMPTY
89728: PPUSH
89729: CALL_OW 1
89733: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
89734: LD_ADDR_EXP 200
89738: PUSH
89739: LD_EXP 200
89743: PPUSH
89744: LD_VAR 0 4
89748: PPUSH
89749: EMPTY
89750: PPUSH
89751: CALL_OW 1
89755: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
89756: LD_ADDR_EXP 201
89760: PUSH
89761: LD_EXP 201
89765: PPUSH
89766: LD_VAR 0 4
89770: PPUSH
89771: EMPTY
89772: PPUSH
89773: CALL_OW 1
89777: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
89778: LD_ADDR_EXP 202
89782: PUSH
89783: LD_EXP 202
89787: PPUSH
89788: LD_VAR 0 4
89792: PPUSH
89793: EMPTY
89794: PPUSH
89795: CALL_OW 1
89799: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
89800: LD_ADDR_EXP 203
89804: PUSH
89805: LD_EXP 203
89809: PPUSH
89810: LD_VAR 0 4
89814: PPUSH
89815: EMPTY
89816: PPUSH
89817: CALL_OW 1
89821: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
89822: LD_ADDR_EXP 205
89826: PUSH
89827: LD_EXP 205
89831: PPUSH
89832: LD_VAR 0 4
89836: PPUSH
89837: EMPTY
89838: PPUSH
89839: CALL_OW 1
89843: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
89844: LD_ADDR_EXP 207
89848: PUSH
89849: LD_EXP 207
89853: PPUSH
89854: LD_VAR 0 4
89858: PPUSH
89859: EMPTY
89860: PPUSH
89861: CALL_OW 1
89865: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
89866: LD_ADDR_EXP 208
89870: PUSH
89871: LD_EXP 208
89875: PPUSH
89876: LD_VAR 0 4
89880: PPUSH
89881: EMPTY
89882: PPUSH
89883: CALL_OW 1
89887: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
89888: LD_ADDR_EXP 209
89892: PUSH
89893: LD_EXP 209
89897: PPUSH
89898: LD_VAR 0 4
89902: PPUSH
89903: EMPTY
89904: PPUSH
89905: CALL_OW 1
89909: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
89910: LD_ADDR_EXP 210
89914: PUSH
89915: LD_EXP 210
89919: PPUSH
89920: LD_VAR 0 4
89924: PPUSH
89925: EMPTY
89926: PPUSH
89927: CALL_OW 1
89931: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
89932: LD_ADDR_EXP 211
89936: PUSH
89937: LD_EXP 211
89941: PPUSH
89942: LD_VAR 0 4
89946: PPUSH
89947: EMPTY
89948: PPUSH
89949: CALL_OW 1
89953: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
89954: LD_ADDR_EXP 212
89958: PUSH
89959: LD_EXP 212
89963: PPUSH
89964: LD_VAR 0 4
89968: PPUSH
89969: EMPTY
89970: PPUSH
89971: CALL_OW 1
89975: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
89976: LD_ADDR_EXP 213
89980: PUSH
89981: LD_EXP 213
89985: PPUSH
89986: LD_VAR 0 4
89990: PPUSH
89991: EMPTY
89992: PPUSH
89993: CALL_OW 1
89997: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
89998: LD_ADDR_EXP 214
90002: PUSH
90003: LD_EXP 214
90007: PPUSH
90008: LD_VAR 0 4
90012: PPUSH
90013: EMPTY
90014: PPUSH
90015: CALL_OW 1
90019: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
90020: LD_ADDR_EXP 215
90024: PUSH
90025: LD_EXP 215
90029: PPUSH
90030: LD_VAR 0 4
90034: PPUSH
90035: EMPTY
90036: PPUSH
90037: CALL_OW 1
90041: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
90042: LD_ADDR_EXP 216
90046: PUSH
90047: LD_EXP 216
90051: PPUSH
90052: LD_VAR 0 4
90056: PPUSH
90057: EMPTY
90058: PPUSH
90059: CALL_OW 1
90063: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
90064: LD_ADDR_EXP 217
90068: PUSH
90069: LD_EXP 217
90073: PPUSH
90074: LD_VAR 0 4
90078: PPUSH
90079: EMPTY
90080: PPUSH
90081: CALL_OW 1
90085: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
90086: LD_ADDR_EXP 218
90090: PUSH
90091: LD_EXP 218
90095: PPUSH
90096: LD_VAR 0 4
90100: PPUSH
90101: EMPTY
90102: PPUSH
90103: CALL_OW 1
90107: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
90108: LD_ADDR_EXP 219
90112: PUSH
90113: LD_EXP 219
90117: PPUSH
90118: LD_VAR 0 4
90122: PPUSH
90123: EMPTY
90124: PPUSH
90125: CALL_OW 1
90129: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
90130: LD_ADDR_EXP 220
90134: PUSH
90135: LD_EXP 220
90139: PPUSH
90140: LD_VAR 0 4
90144: PPUSH
90145: LD_INT 0
90147: PPUSH
90148: CALL_OW 1
90152: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
90153: LD_ADDR_EXP 221
90157: PUSH
90158: LD_EXP 221
90162: PPUSH
90163: LD_VAR 0 4
90167: PPUSH
90168: LD_INT 0
90170: PPUSH
90171: CALL_OW 1
90175: ST_TO_ADDR
// result := base ;
90176: LD_ADDR_VAR 0 3
90180: PUSH
90181: LD_VAR 0 4
90185: ST_TO_ADDR
// end ;
90186: LD_VAR 0 3
90190: RET
// export function MC_Start ( ) ; var i ; begin
90191: LD_INT 0
90193: PPUSH
90194: PPUSH
// for i = 1 to mc_bases do
90195: LD_ADDR_VAR 0 2
90199: PUSH
90200: DOUBLE
90201: LD_INT 1
90203: DEC
90204: ST_TO_ADDR
90205: LD_EXP 178
90209: PUSH
90210: FOR_TO
90211: IFFALSE 91311
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
90213: LD_ADDR_EXP 178
90217: PUSH
90218: LD_EXP 178
90222: PPUSH
90223: LD_VAR 0 2
90227: PPUSH
90228: LD_EXP 178
90232: PUSH
90233: LD_VAR 0 2
90237: ARRAY
90238: PUSH
90239: LD_INT 0
90241: DIFF
90242: PPUSH
90243: CALL_OW 1
90247: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
90248: LD_ADDR_EXP 179
90252: PUSH
90253: LD_EXP 179
90257: PPUSH
90258: LD_VAR 0 2
90262: PPUSH
90263: EMPTY
90264: PPUSH
90265: CALL_OW 1
90269: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
90270: LD_ADDR_EXP 180
90274: PUSH
90275: LD_EXP 180
90279: PPUSH
90280: LD_VAR 0 2
90284: PPUSH
90285: EMPTY
90286: PPUSH
90287: CALL_OW 1
90291: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
90292: LD_ADDR_EXP 181
90296: PUSH
90297: LD_EXP 181
90301: PPUSH
90302: LD_VAR 0 2
90306: PPUSH
90307: EMPTY
90308: PPUSH
90309: CALL_OW 1
90313: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
90314: LD_ADDR_EXP 182
90318: PUSH
90319: LD_EXP 182
90323: PPUSH
90324: LD_VAR 0 2
90328: PPUSH
90329: EMPTY
90330: PUSH
90331: EMPTY
90332: PUSH
90333: EMPTY
90334: LIST
90335: LIST
90336: PPUSH
90337: CALL_OW 1
90341: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
90342: LD_ADDR_EXP 183
90346: PUSH
90347: LD_EXP 183
90351: PPUSH
90352: LD_VAR 0 2
90356: PPUSH
90357: EMPTY
90358: PPUSH
90359: CALL_OW 1
90363: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
90364: LD_ADDR_EXP 210
90368: PUSH
90369: LD_EXP 210
90373: PPUSH
90374: LD_VAR 0 2
90378: PPUSH
90379: EMPTY
90380: PPUSH
90381: CALL_OW 1
90385: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
90386: LD_ADDR_EXP 184
90390: PUSH
90391: LD_EXP 184
90395: PPUSH
90396: LD_VAR 0 2
90400: PPUSH
90401: EMPTY
90402: PPUSH
90403: CALL_OW 1
90407: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
90408: LD_ADDR_EXP 185
90412: PUSH
90413: LD_EXP 185
90417: PPUSH
90418: LD_VAR 0 2
90422: PPUSH
90423: EMPTY
90424: PPUSH
90425: CALL_OW 1
90429: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
90430: LD_ADDR_EXP 186
90434: PUSH
90435: LD_EXP 186
90439: PPUSH
90440: LD_VAR 0 2
90444: PPUSH
90445: LD_EXP 178
90449: PUSH
90450: LD_VAR 0 2
90454: ARRAY
90455: PPUSH
90456: LD_INT 2
90458: PUSH
90459: LD_INT 30
90461: PUSH
90462: LD_INT 32
90464: PUSH
90465: EMPTY
90466: LIST
90467: LIST
90468: PUSH
90469: LD_INT 30
90471: PUSH
90472: LD_INT 33
90474: PUSH
90475: EMPTY
90476: LIST
90477: LIST
90478: PUSH
90479: EMPTY
90480: LIST
90481: LIST
90482: LIST
90483: PPUSH
90484: CALL_OW 72
90488: PPUSH
90489: CALL_OW 1
90493: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
90494: LD_ADDR_EXP 187
90498: PUSH
90499: LD_EXP 187
90503: PPUSH
90504: LD_VAR 0 2
90508: PPUSH
90509: LD_EXP 178
90513: PUSH
90514: LD_VAR 0 2
90518: ARRAY
90519: PPUSH
90520: LD_INT 2
90522: PUSH
90523: LD_INT 30
90525: PUSH
90526: LD_INT 32
90528: PUSH
90529: EMPTY
90530: LIST
90531: LIST
90532: PUSH
90533: LD_INT 30
90535: PUSH
90536: LD_INT 31
90538: PUSH
90539: EMPTY
90540: LIST
90541: LIST
90542: PUSH
90543: EMPTY
90544: LIST
90545: LIST
90546: LIST
90547: PUSH
90548: LD_INT 58
90550: PUSH
90551: EMPTY
90552: LIST
90553: PUSH
90554: EMPTY
90555: LIST
90556: LIST
90557: PPUSH
90558: CALL_OW 72
90562: PPUSH
90563: CALL_OW 1
90567: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
90568: LD_ADDR_EXP 188
90572: PUSH
90573: LD_EXP 188
90577: PPUSH
90578: LD_VAR 0 2
90582: PPUSH
90583: EMPTY
90584: PPUSH
90585: CALL_OW 1
90589: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
90590: LD_ADDR_EXP 192
90594: PUSH
90595: LD_EXP 192
90599: PPUSH
90600: LD_VAR 0 2
90604: PPUSH
90605: EMPTY
90606: PPUSH
90607: CALL_OW 1
90611: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
90612: LD_ADDR_EXP 191
90616: PUSH
90617: LD_EXP 191
90621: PPUSH
90622: LD_VAR 0 2
90626: PPUSH
90627: EMPTY
90628: PPUSH
90629: CALL_OW 1
90633: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
90634: LD_ADDR_EXP 193
90638: PUSH
90639: LD_EXP 193
90643: PPUSH
90644: LD_VAR 0 2
90648: PPUSH
90649: EMPTY
90650: PPUSH
90651: CALL_OW 1
90655: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
90656: LD_ADDR_EXP 194
90660: PUSH
90661: LD_EXP 194
90665: PPUSH
90666: LD_VAR 0 2
90670: PPUSH
90671: EMPTY
90672: PPUSH
90673: CALL_OW 1
90677: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
90678: LD_ADDR_EXP 195
90682: PUSH
90683: LD_EXP 195
90687: PPUSH
90688: LD_VAR 0 2
90692: PPUSH
90693: EMPTY
90694: PPUSH
90695: CALL_OW 1
90699: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
90700: LD_ADDR_EXP 196
90704: PUSH
90705: LD_EXP 196
90709: PPUSH
90710: LD_VAR 0 2
90714: PPUSH
90715: EMPTY
90716: PPUSH
90717: CALL_OW 1
90721: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
90722: LD_ADDR_EXP 197
90726: PUSH
90727: LD_EXP 197
90731: PPUSH
90732: LD_VAR 0 2
90736: PPUSH
90737: EMPTY
90738: PPUSH
90739: CALL_OW 1
90743: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
90744: LD_ADDR_EXP 198
90748: PUSH
90749: LD_EXP 198
90753: PPUSH
90754: LD_VAR 0 2
90758: PPUSH
90759: EMPTY
90760: PPUSH
90761: CALL_OW 1
90765: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
90766: LD_ADDR_EXP 199
90770: PUSH
90771: LD_EXP 199
90775: PPUSH
90776: LD_VAR 0 2
90780: PPUSH
90781: EMPTY
90782: PPUSH
90783: CALL_OW 1
90787: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
90788: LD_ADDR_EXP 200
90792: PUSH
90793: LD_EXP 200
90797: PPUSH
90798: LD_VAR 0 2
90802: PPUSH
90803: EMPTY
90804: PPUSH
90805: CALL_OW 1
90809: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
90810: LD_ADDR_EXP 189
90814: PUSH
90815: LD_EXP 189
90819: PPUSH
90820: LD_VAR 0 2
90824: PPUSH
90825: LD_INT 0
90827: PPUSH
90828: CALL_OW 1
90832: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
90833: LD_ADDR_EXP 202
90837: PUSH
90838: LD_EXP 202
90842: PPUSH
90843: LD_VAR 0 2
90847: PPUSH
90848: LD_INT 0
90850: PPUSH
90851: CALL_OW 1
90855: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
90856: LD_ADDR_EXP 190
90860: PUSH
90861: LD_EXP 190
90865: PPUSH
90866: LD_VAR 0 2
90870: PPUSH
90871: EMPTY
90872: PPUSH
90873: CALL_OW 1
90877: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
90878: LD_ADDR_EXP 201
90882: PUSH
90883: LD_EXP 201
90887: PPUSH
90888: LD_VAR 0 2
90892: PPUSH
90893: LD_INT 0
90895: PPUSH
90896: CALL_OW 1
90900: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
90901: LD_ADDR_EXP 203
90905: PUSH
90906: LD_EXP 203
90910: PPUSH
90911: LD_VAR 0 2
90915: PPUSH
90916: EMPTY
90917: PPUSH
90918: CALL_OW 1
90922: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
90923: LD_ADDR_EXP 206
90927: PUSH
90928: LD_EXP 206
90932: PPUSH
90933: LD_VAR 0 2
90937: PPUSH
90938: LD_INT 0
90940: PPUSH
90941: CALL_OW 1
90945: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
90946: LD_ADDR_EXP 207
90950: PUSH
90951: LD_EXP 207
90955: PPUSH
90956: LD_VAR 0 2
90960: PPUSH
90961: EMPTY
90962: PPUSH
90963: CALL_OW 1
90967: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
90968: LD_ADDR_EXP 208
90972: PUSH
90973: LD_EXP 208
90977: PPUSH
90978: LD_VAR 0 2
90982: PPUSH
90983: EMPTY
90984: PPUSH
90985: CALL_OW 1
90989: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
90990: LD_ADDR_EXP 209
90994: PUSH
90995: LD_EXP 209
90999: PPUSH
91000: LD_VAR 0 2
91004: PPUSH
91005: EMPTY
91006: PPUSH
91007: CALL_OW 1
91011: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
91012: LD_ADDR_EXP 211
91016: PUSH
91017: LD_EXP 211
91021: PPUSH
91022: LD_VAR 0 2
91026: PPUSH
91027: LD_EXP 178
91031: PUSH
91032: LD_VAR 0 2
91036: ARRAY
91037: PPUSH
91038: LD_INT 2
91040: PUSH
91041: LD_INT 30
91043: PUSH
91044: LD_INT 6
91046: PUSH
91047: EMPTY
91048: LIST
91049: LIST
91050: PUSH
91051: LD_INT 30
91053: PUSH
91054: LD_INT 7
91056: PUSH
91057: EMPTY
91058: LIST
91059: LIST
91060: PUSH
91061: LD_INT 30
91063: PUSH
91064: LD_INT 8
91066: PUSH
91067: EMPTY
91068: LIST
91069: LIST
91070: PUSH
91071: EMPTY
91072: LIST
91073: LIST
91074: LIST
91075: LIST
91076: PPUSH
91077: CALL_OW 72
91081: PPUSH
91082: CALL_OW 1
91086: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
91087: LD_ADDR_EXP 212
91091: PUSH
91092: LD_EXP 212
91096: PPUSH
91097: LD_VAR 0 2
91101: PPUSH
91102: EMPTY
91103: PPUSH
91104: CALL_OW 1
91108: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
91109: LD_ADDR_EXP 213
91113: PUSH
91114: LD_EXP 213
91118: PPUSH
91119: LD_VAR 0 2
91123: PPUSH
91124: EMPTY
91125: PPUSH
91126: CALL_OW 1
91130: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
91131: LD_ADDR_EXP 214
91135: PUSH
91136: LD_EXP 214
91140: PPUSH
91141: LD_VAR 0 2
91145: PPUSH
91146: EMPTY
91147: PPUSH
91148: CALL_OW 1
91152: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
91153: LD_ADDR_EXP 215
91157: PUSH
91158: LD_EXP 215
91162: PPUSH
91163: LD_VAR 0 2
91167: PPUSH
91168: EMPTY
91169: PPUSH
91170: CALL_OW 1
91174: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
91175: LD_ADDR_EXP 216
91179: PUSH
91180: LD_EXP 216
91184: PPUSH
91185: LD_VAR 0 2
91189: PPUSH
91190: EMPTY
91191: PPUSH
91192: CALL_OW 1
91196: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
91197: LD_ADDR_EXP 217
91201: PUSH
91202: LD_EXP 217
91206: PPUSH
91207: LD_VAR 0 2
91211: PPUSH
91212: EMPTY
91213: PPUSH
91214: CALL_OW 1
91218: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
91219: LD_ADDR_EXP 218
91223: PUSH
91224: LD_EXP 218
91228: PPUSH
91229: LD_VAR 0 2
91233: PPUSH
91234: EMPTY
91235: PPUSH
91236: CALL_OW 1
91240: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
91241: LD_ADDR_EXP 219
91245: PUSH
91246: LD_EXP 219
91250: PPUSH
91251: LD_VAR 0 2
91255: PPUSH
91256: EMPTY
91257: PPUSH
91258: CALL_OW 1
91262: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
91263: LD_ADDR_EXP 220
91267: PUSH
91268: LD_EXP 220
91272: PPUSH
91273: LD_VAR 0 2
91277: PPUSH
91278: LD_INT 0
91280: PPUSH
91281: CALL_OW 1
91285: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , i , false ) ;
91286: LD_ADDR_EXP 221
91290: PUSH
91291: LD_EXP 221
91295: PPUSH
91296: LD_VAR 0 2
91300: PPUSH
91301: LD_INT 0
91303: PPUSH
91304: CALL_OW 1
91308: ST_TO_ADDR
// end ;
91309: GO 90210
91311: POP
91312: POP
// MC_InitSides ( ) ;
91313: CALL 91599 0 0
// MC_InitResearch ( ) ;
91317: CALL 91338 0 0
// CustomInitMacro ( ) ;
91321: CALL 350 0 0
// skirmish := true ;
91325: LD_ADDR_EXP 176
91329: PUSH
91330: LD_INT 1
91332: ST_TO_ADDR
// end ;
91333: LD_VAR 0 1
91337: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
91338: LD_INT 0
91340: PPUSH
91341: PPUSH
91342: PPUSH
91343: PPUSH
91344: PPUSH
91345: PPUSH
// if not mc_bases then
91346: LD_EXP 178
91350: NOT
91351: IFFALSE 91355
// exit ;
91353: GO 91594
// for i = 1 to 8 do
91355: LD_ADDR_VAR 0 2
91359: PUSH
91360: DOUBLE
91361: LD_INT 1
91363: DEC
91364: ST_TO_ADDR
91365: LD_INT 8
91367: PUSH
91368: FOR_TO
91369: IFFALSE 91395
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
91371: LD_ADDR_EXP 205
91375: PUSH
91376: LD_EXP 205
91380: PPUSH
91381: LD_VAR 0 2
91385: PPUSH
91386: EMPTY
91387: PPUSH
91388: CALL_OW 1
91392: ST_TO_ADDR
91393: GO 91368
91395: POP
91396: POP
// tmp := [ ] ;
91397: LD_ADDR_VAR 0 5
91401: PUSH
91402: EMPTY
91403: ST_TO_ADDR
// for i = 1 to mc_sides do
91404: LD_ADDR_VAR 0 2
91408: PUSH
91409: DOUBLE
91410: LD_INT 1
91412: DEC
91413: ST_TO_ADDR
91414: LD_EXP 204
91418: PUSH
91419: FOR_TO
91420: IFFALSE 91478
// if not mc_sides [ i ] in tmp then
91422: LD_EXP 204
91426: PUSH
91427: LD_VAR 0 2
91431: ARRAY
91432: PUSH
91433: LD_VAR 0 5
91437: IN
91438: NOT
91439: IFFALSE 91476
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
91441: LD_ADDR_VAR 0 5
91445: PUSH
91446: LD_VAR 0 5
91450: PPUSH
91451: LD_VAR 0 5
91455: PUSH
91456: LD_INT 1
91458: PLUS
91459: PPUSH
91460: LD_EXP 204
91464: PUSH
91465: LD_VAR 0 2
91469: ARRAY
91470: PPUSH
91471: CALL_OW 2
91475: ST_TO_ADDR
91476: GO 91419
91478: POP
91479: POP
// if not tmp then
91480: LD_VAR 0 5
91484: NOT
91485: IFFALSE 91489
// exit ;
91487: GO 91594
// for j in tmp do
91489: LD_ADDR_VAR 0 3
91493: PUSH
91494: LD_VAR 0 5
91498: PUSH
91499: FOR_IN
91500: IFFALSE 91592
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
91502: LD_ADDR_VAR 0 6
91506: PUSH
91507: LD_INT 22
91509: PUSH
91510: LD_VAR 0 3
91514: PUSH
91515: EMPTY
91516: LIST
91517: LIST
91518: PPUSH
91519: CALL_OW 69
91523: ST_TO_ADDR
// if not un then
91524: LD_VAR 0 6
91528: NOT
91529: IFFALSE 91533
// continue ;
91531: GO 91499
// nation := GetNation ( un [ 1 ] ) ;
91533: LD_ADDR_VAR 0 4
91537: PUSH
91538: LD_VAR 0 6
91542: PUSH
91543: LD_INT 1
91545: ARRAY
91546: PPUSH
91547: CALL_OW 248
91551: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
91552: LD_ADDR_EXP 205
91556: PUSH
91557: LD_EXP 205
91561: PPUSH
91562: LD_VAR 0 3
91566: PPUSH
91567: LD_VAR 0 3
91571: PPUSH
91572: LD_VAR 0 4
91576: PPUSH
91577: LD_INT 1
91579: PPUSH
91580: CALL 19287 0 3
91584: PPUSH
91585: CALL_OW 1
91589: ST_TO_ADDR
// end ;
91590: GO 91499
91592: POP
91593: POP
// end ;
91594: LD_VAR 0 1
91598: RET
// export function MC_InitSides ( ) ; var i ; begin
91599: LD_INT 0
91601: PPUSH
91602: PPUSH
// if not mc_bases then
91603: LD_EXP 178
91607: NOT
91608: IFFALSE 91612
// exit ;
91610: GO 91686
// for i = 1 to mc_bases do
91612: LD_ADDR_VAR 0 2
91616: PUSH
91617: DOUBLE
91618: LD_INT 1
91620: DEC
91621: ST_TO_ADDR
91622: LD_EXP 178
91626: PUSH
91627: FOR_TO
91628: IFFALSE 91684
// if mc_bases [ i ] then
91630: LD_EXP 178
91634: PUSH
91635: LD_VAR 0 2
91639: ARRAY
91640: IFFALSE 91682
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
91642: LD_ADDR_EXP 204
91646: PUSH
91647: LD_EXP 204
91651: PPUSH
91652: LD_VAR 0 2
91656: PPUSH
91657: LD_EXP 178
91661: PUSH
91662: LD_VAR 0 2
91666: ARRAY
91667: PUSH
91668: LD_INT 1
91670: ARRAY
91671: PPUSH
91672: CALL_OW 255
91676: PPUSH
91677: CALL_OW 1
91681: ST_TO_ADDR
91682: GO 91627
91684: POP
91685: POP
// end ;
91686: LD_VAR 0 1
91690: RET
// every 0 0$03 trigger skirmish do
91691: LD_EXP 176
91695: IFFALSE 91849
91697: GO 91699
91699: DISABLE
// begin enable ;
91700: ENABLE
// MC_CheckBuildings ( ) ;
91701: CALL 96347 0 0
// MC_CheckPeopleLife ( ) ;
91705: CALL 96508 0 0
// RaiseSailEvent ( 100 ) ;
91709: LD_INT 100
91711: PPUSH
91712: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
91716: LD_INT 103
91718: PPUSH
91719: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
91723: LD_INT 104
91725: PPUSH
91726: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
91730: LD_INT 105
91732: PPUSH
91733: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
91737: LD_INT 106
91739: PPUSH
91740: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
91744: LD_INT 107
91746: PPUSH
91747: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
91751: LD_INT 108
91753: PPUSH
91754: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
91758: LD_INT 109
91760: PPUSH
91761: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
91765: LD_INT 110
91767: PPUSH
91768: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
91772: LD_INT 111
91774: PPUSH
91775: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
91779: LD_INT 112
91781: PPUSH
91782: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
91786: LD_INT 113
91788: PPUSH
91789: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
91793: LD_INT 120
91795: PPUSH
91796: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
91800: LD_INT 121
91802: PPUSH
91803: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
91807: LD_INT 122
91809: PPUSH
91810: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
91814: LD_INT 123
91816: PPUSH
91817: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
91821: LD_INT 124
91823: PPUSH
91824: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
91828: LD_INT 125
91830: PPUSH
91831: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
91835: LD_INT 126
91837: PPUSH
91838: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
91842: LD_INT 200
91844: PPUSH
91845: CALL_OW 427
// end ;
91849: END
// on SailEvent ( event ) do begin if event < 100 then
91850: LD_VAR 0 1
91854: PUSH
91855: LD_INT 100
91857: LESS
91858: IFFALSE 91869
// CustomEvent ( event ) ;
91860: LD_VAR 0 1
91864: PPUSH
91865: CALL 16158 0 1
// if event = 100 then
91869: LD_VAR 0 1
91873: PUSH
91874: LD_INT 100
91876: EQUAL
91877: IFFALSE 91883
// MC_ClassManager ( ) ;
91879: CALL 92275 0 0
// if event = 101 then
91883: LD_VAR 0 1
91887: PUSH
91888: LD_INT 101
91890: EQUAL
91891: IFFALSE 91897
// MC_RepairBuildings ( ) ;
91893: CALL 97093 0 0
// if event = 102 then
91897: LD_VAR 0 1
91901: PUSH
91902: LD_INT 102
91904: EQUAL
91905: IFFALSE 91911
// MC_Heal ( ) ;
91907: CALL 98000 0 0
// if event = 103 then
91911: LD_VAR 0 1
91915: PUSH
91916: LD_INT 103
91918: EQUAL
91919: IFFALSE 91925
// MC_Build ( ) ;
91921: CALL 98422 0 0
// if event = 104 then
91925: LD_VAR 0 1
91929: PUSH
91930: LD_INT 104
91932: EQUAL
91933: IFFALSE 91939
// MC_TurretWeapon ( ) ;
91935: CALL 100063 0 0
// if event = 105 then
91939: LD_VAR 0 1
91943: PUSH
91944: LD_INT 105
91946: EQUAL
91947: IFFALSE 91953
// MC_BuildUpgrade ( ) ;
91949: CALL 99614 0 0
// if event = 106 then
91953: LD_VAR 0 1
91957: PUSH
91958: LD_INT 106
91960: EQUAL
91961: IFFALSE 91967
// MC_PlantMines ( ) ;
91963: CALL 100493 0 0
// if event = 107 then
91967: LD_VAR 0 1
91971: PUSH
91972: LD_INT 107
91974: EQUAL
91975: IFFALSE 91981
// MC_CollectCrates ( ) ;
91977: CALL 101284 0 0
// if event = 108 then
91981: LD_VAR 0 1
91985: PUSH
91986: LD_INT 108
91988: EQUAL
91989: IFFALSE 91995
// MC_LinkRemoteControl ( ) ;
91991: CALL 103134 0 0
// if event = 109 then
91995: LD_VAR 0 1
91999: PUSH
92000: LD_INT 109
92002: EQUAL
92003: IFFALSE 92009
// MC_ProduceVehicle ( ) ;
92005: CALL 103315 0 0
// if event = 110 then
92009: LD_VAR 0 1
92013: PUSH
92014: LD_INT 110
92016: EQUAL
92017: IFFALSE 92023
// MC_SendAttack ( ) ;
92019: CALL 103781 0 0
// if event = 111 then
92023: LD_VAR 0 1
92027: PUSH
92028: LD_INT 111
92030: EQUAL
92031: IFFALSE 92037
// MC_Defend ( ) ;
92033: CALL 103889 0 0
// if event = 112 then
92037: LD_VAR 0 1
92041: PUSH
92042: LD_INT 112
92044: EQUAL
92045: IFFALSE 92051
// MC_Research ( ) ;
92047: CALL 104769 0 0
// if event = 113 then
92051: LD_VAR 0 1
92055: PUSH
92056: LD_INT 113
92058: EQUAL
92059: IFFALSE 92065
// MC_MinesTrigger ( ) ;
92061: CALL 105883 0 0
// if event = 120 then
92065: LD_VAR 0 1
92069: PUSH
92070: LD_INT 120
92072: EQUAL
92073: IFFALSE 92079
// MC_RepairVehicle ( ) ;
92075: CALL 105982 0 0
// if event = 121 then
92079: LD_VAR 0 1
92083: PUSH
92084: LD_INT 121
92086: EQUAL
92087: IFFALSE 92093
// MC_TameApe ( ) ;
92089: CALL 106723 0 0
// if event = 122 then
92093: LD_VAR 0 1
92097: PUSH
92098: LD_INT 122
92100: EQUAL
92101: IFFALSE 92107
// MC_ChangeApeClass ( ) ;
92103: CALL 107552 0 0
// if event = 123 then
92107: LD_VAR 0 1
92111: PUSH
92112: LD_INT 123
92114: EQUAL
92115: IFFALSE 92121
// MC_Bazooka ( ) ;
92117: CALL 108202 0 0
// if event = 124 then
92121: LD_VAR 0 1
92125: PUSH
92126: LD_INT 124
92128: EQUAL
92129: IFFALSE 92135
// MC_TeleportExit ( ) ;
92131: CALL 108400 0 0
// if event = 125 then
92135: LD_VAR 0 1
92139: PUSH
92140: LD_INT 125
92142: EQUAL
92143: IFFALSE 92149
// MC_Deposits ( ) ;
92145: CALL 109047 0 0
// if event = 126 then
92149: LD_VAR 0 1
92153: PUSH
92154: LD_INT 126
92156: EQUAL
92157: IFFALSE 92163
// MC_RemoteDriver ( ) ;
92159: CALL 109672 0 0
// if event = 200 then
92163: LD_VAR 0 1
92167: PUSH
92168: LD_INT 200
92170: EQUAL
92171: IFFALSE 92177
// MC_Idle ( ) ;
92173: CALL 111621 0 0
// end ;
92177: PPOPN 1
92179: END
// export function MC_Reset ( base , tag ) ; var i ; begin
92180: LD_INT 0
92182: PPUSH
92183: PPUSH
// if not mc_bases [ base ] or not tag then
92184: LD_EXP 178
92188: PUSH
92189: LD_VAR 0 1
92193: ARRAY
92194: NOT
92195: PUSH
92196: LD_VAR 0 2
92200: NOT
92201: OR
92202: IFFALSE 92206
// exit ;
92204: GO 92270
// for i in mc_bases [ base ] union mc_ape [ base ] do
92206: LD_ADDR_VAR 0 4
92210: PUSH
92211: LD_EXP 178
92215: PUSH
92216: LD_VAR 0 1
92220: ARRAY
92221: PUSH
92222: LD_EXP 207
92226: PUSH
92227: LD_VAR 0 1
92231: ARRAY
92232: UNION
92233: PUSH
92234: FOR_IN
92235: IFFALSE 92268
// if GetTag ( i ) = tag then
92237: LD_VAR 0 4
92241: PPUSH
92242: CALL_OW 110
92246: PUSH
92247: LD_VAR 0 2
92251: EQUAL
92252: IFFALSE 92266
// SetTag ( i , 0 ) ;
92254: LD_VAR 0 4
92258: PPUSH
92259: LD_INT 0
92261: PPUSH
92262: CALL_OW 109
92266: GO 92234
92268: POP
92269: POP
// end ;
92270: LD_VAR 0 3
92274: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
92275: LD_INT 0
92277: PPUSH
92278: PPUSH
92279: PPUSH
92280: PPUSH
92281: PPUSH
92282: PPUSH
92283: PPUSH
92284: PPUSH
// if not mc_bases then
92285: LD_EXP 178
92289: NOT
92290: IFFALSE 92294
// exit ;
92292: GO 92752
// for i = 1 to mc_bases do
92294: LD_ADDR_VAR 0 2
92298: PUSH
92299: DOUBLE
92300: LD_INT 1
92302: DEC
92303: ST_TO_ADDR
92304: LD_EXP 178
92308: PUSH
92309: FOR_TO
92310: IFFALSE 92750
// begin tmp := MC_ClassCheckReq ( i ) ;
92312: LD_ADDR_VAR 0 4
92316: PUSH
92317: LD_VAR 0 2
92321: PPUSH
92322: CALL 92757 0 1
92326: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
92327: LD_ADDR_EXP 219
92331: PUSH
92332: LD_EXP 219
92336: PPUSH
92337: LD_VAR 0 2
92341: PPUSH
92342: LD_VAR 0 4
92346: PPUSH
92347: CALL_OW 1
92351: ST_TO_ADDR
// if not tmp then
92352: LD_VAR 0 4
92356: NOT
92357: IFFALSE 92361
// continue ;
92359: GO 92309
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
92361: LD_ADDR_VAR 0 6
92365: PUSH
92366: LD_EXP 178
92370: PUSH
92371: LD_VAR 0 2
92375: ARRAY
92376: PPUSH
92377: LD_INT 2
92379: PUSH
92380: LD_INT 30
92382: PUSH
92383: LD_INT 4
92385: PUSH
92386: EMPTY
92387: LIST
92388: LIST
92389: PUSH
92390: LD_INT 30
92392: PUSH
92393: LD_INT 5
92395: PUSH
92396: EMPTY
92397: LIST
92398: LIST
92399: PUSH
92400: EMPTY
92401: LIST
92402: LIST
92403: LIST
92404: PPUSH
92405: CALL_OW 72
92409: PUSH
92410: LD_EXP 178
92414: PUSH
92415: LD_VAR 0 2
92419: ARRAY
92420: PPUSH
92421: LD_INT 2
92423: PUSH
92424: LD_INT 30
92426: PUSH
92427: LD_INT 0
92429: PUSH
92430: EMPTY
92431: LIST
92432: LIST
92433: PUSH
92434: LD_INT 30
92436: PUSH
92437: LD_INT 1
92439: PUSH
92440: EMPTY
92441: LIST
92442: LIST
92443: PUSH
92444: EMPTY
92445: LIST
92446: LIST
92447: LIST
92448: PPUSH
92449: CALL_OW 72
92453: PUSH
92454: LD_EXP 178
92458: PUSH
92459: LD_VAR 0 2
92463: ARRAY
92464: PPUSH
92465: LD_INT 30
92467: PUSH
92468: LD_INT 3
92470: PUSH
92471: EMPTY
92472: LIST
92473: LIST
92474: PPUSH
92475: CALL_OW 72
92479: PUSH
92480: LD_EXP 178
92484: PUSH
92485: LD_VAR 0 2
92489: ARRAY
92490: PPUSH
92491: LD_INT 2
92493: PUSH
92494: LD_INT 30
92496: PUSH
92497: LD_INT 6
92499: PUSH
92500: EMPTY
92501: LIST
92502: LIST
92503: PUSH
92504: LD_INT 30
92506: PUSH
92507: LD_INT 7
92509: PUSH
92510: EMPTY
92511: LIST
92512: LIST
92513: PUSH
92514: LD_INT 30
92516: PUSH
92517: LD_INT 8
92519: PUSH
92520: EMPTY
92521: LIST
92522: LIST
92523: PUSH
92524: EMPTY
92525: LIST
92526: LIST
92527: LIST
92528: LIST
92529: PPUSH
92530: CALL_OW 72
92534: PUSH
92535: EMPTY
92536: LIST
92537: LIST
92538: LIST
92539: LIST
92540: ST_TO_ADDR
// for j = 1 to 4 do
92541: LD_ADDR_VAR 0 3
92545: PUSH
92546: DOUBLE
92547: LD_INT 1
92549: DEC
92550: ST_TO_ADDR
92551: LD_INT 4
92553: PUSH
92554: FOR_TO
92555: IFFALSE 92746
// begin if not tmp [ j ] then
92557: LD_VAR 0 4
92561: PUSH
92562: LD_VAR 0 3
92566: ARRAY
92567: NOT
92568: IFFALSE 92572
// continue ;
92570: GO 92554
// for p in tmp [ j ] do
92572: LD_ADDR_VAR 0 5
92576: PUSH
92577: LD_VAR 0 4
92581: PUSH
92582: LD_VAR 0 3
92586: ARRAY
92587: PUSH
92588: FOR_IN
92589: IFFALSE 92742
// begin if not b [ j ] then
92591: LD_VAR 0 6
92595: PUSH
92596: LD_VAR 0 3
92600: ARRAY
92601: NOT
92602: IFFALSE 92606
// break ;
92604: GO 92742
// e := 0 ;
92606: LD_ADDR_VAR 0 7
92610: PUSH
92611: LD_INT 0
92613: ST_TO_ADDR
// for k in b [ j ] do
92614: LD_ADDR_VAR 0 8
92618: PUSH
92619: LD_VAR 0 6
92623: PUSH
92624: LD_VAR 0 3
92628: ARRAY
92629: PUSH
92630: FOR_IN
92631: IFFALSE 92658
// if IsNotFull ( k ) then
92633: LD_VAR 0 8
92637: PPUSH
92638: CALL 21440 0 1
92642: IFFALSE 92656
// begin e := k ;
92644: LD_ADDR_VAR 0 7
92648: PUSH
92649: LD_VAR 0 8
92653: ST_TO_ADDR
// break ;
92654: GO 92658
// end ;
92656: GO 92630
92658: POP
92659: POP
// if e and not UnitGoingToBuilding ( p , e ) then
92660: LD_VAR 0 7
92664: PUSH
92665: LD_VAR 0 5
92669: PPUSH
92670: LD_VAR 0 7
92674: PPUSH
92675: CALL 55271 0 2
92679: NOT
92680: AND
92681: IFFALSE 92740
// begin if IsInUnit ( p ) then
92683: LD_VAR 0 5
92687: PPUSH
92688: CALL_OW 310
92692: IFFALSE 92703
// ComExitBuilding ( p ) ;
92694: LD_VAR 0 5
92698: PPUSH
92699: CALL_OW 122
// ComEnterUnit ( p , e ) ;
92703: LD_VAR 0 5
92707: PPUSH
92708: LD_VAR 0 7
92712: PPUSH
92713: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
92717: LD_VAR 0 5
92721: PPUSH
92722: LD_VAR 0 3
92726: PPUSH
92727: CALL_OW 183
// AddComExitBuilding ( p ) ;
92731: LD_VAR 0 5
92735: PPUSH
92736: CALL_OW 182
// end ; end ;
92740: GO 92588
92742: POP
92743: POP
// end ;
92744: GO 92554
92746: POP
92747: POP
// end ;
92748: GO 92309
92750: POP
92751: POP
// end ;
92752: LD_VAR 0 1
92756: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
92757: LD_INT 0
92759: PPUSH
92760: PPUSH
92761: PPUSH
92762: PPUSH
92763: PPUSH
92764: PPUSH
92765: PPUSH
92766: PPUSH
92767: PPUSH
92768: PPUSH
92769: PPUSH
92770: PPUSH
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
92771: LD_VAR 0 1
92775: NOT
92776: PUSH
92777: LD_EXP 178
92781: PUSH
92782: LD_VAR 0 1
92786: ARRAY
92787: NOT
92788: OR
92789: PUSH
92790: LD_EXP 178
92794: PUSH
92795: LD_VAR 0 1
92799: ARRAY
92800: PPUSH
92801: LD_INT 2
92803: PUSH
92804: LD_INT 30
92806: PUSH
92807: LD_INT 0
92809: PUSH
92810: EMPTY
92811: LIST
92812: LIST
92813: PUSH
92814: LD_INT 30
92816: PUSH
92817: LD_INT 1
92819: PUSH
92820: EMPTY
92821: LIST
92822: LIST
92823: PUSH
92824: EMPTY
92825: LIST
92826: LIST
92827: LIST
92828: PPUSH
92829: CALL_OW 72
92833: NOT
92834: OR
92835: IFFALSE 92839
// exit ;
92837: GO 96342
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
92839: LD_ADDR_VAR 0 4
92843: PUSH
92844: LD_EXP 178
92848: PUSH
92849: LD_VAR 0 1
92853: ARRAY
92854: PPUSH
92855: LD_INT 2
92857: PUSH
92858: LD_INT 25
92860: PUSH
92861: LD_INT 1
92863: PUSH
92864: EMPTY
92865: LIST
92866: LIST
92867: PUSH
92868: LD_INT 25
92870: PUSH
92871: LD_INT 2
92873: PUSH
92874: EMPTY
92875: LIST
92876: LIST
92877: PUSH
92878: LD_INT 25
92880: PUSH
92881: LD_INT 3
92883: PUSH
92884: EMPTY
92885: LIST
92886: LIST
92887: PUSH
92888: LD_INT 25
92890: PUSH
92891: LD_INT 4
92893: PUSH
92894: EMPTY
92895: LIST
92896: LIST
92897: PUSH
92898: LD_INT 25
92900: PUSH
92901: LD_INT 5
92903: PUSH
92904: EMPTY
92905: LIST
92906: LIST
92907: PUSH
92908: LD_INT 25
92910: PUSH
92911: LD_INT 8
92913: PUSH
92914: EMPTY
92915: LIST
92916: LIST
92917: PUSH
92918: LD_INT 25
92920: PUSH
92921: LD_INT 9
92923: PUSH
92924: EMPTY
92925: LIST
92926: LIST
92927: PUSH
92928: EMPTY
92929: LIST
92930: LIST
92931: LIST
92932: LIST
92933: LIST
92934: LIST
92935: LIST
92936: LIST
92937: PPUSH
92938: CALL_OW 72
92942: ST_TO_ADDR
// if not tmp then
92943: LD_VAR 0 4
92947: NOT
92948: IFFALSE 92952
// exit ;
92950: GO 96342
// for i in tmp do
92952: LD_ADDR_VAR 0 3
92956: PUSH
92957: LD_VAR 0 4
92961: PUSH
92962: FOR_IN
92963: IFFALSE 92994
// if GetTag ( i ) then
92965: LD_VAR 0 3
92969: PPUSH
92970: CALL_OW 110
92974: IFFALSE 92992
// tmp := tmp diff i ;
92976: LD_ADDR_VAR 0 4
92980: PUSH
92981: LD_VAR 0 4
92985: PUSH
92986: LD_VAR 0 3
92990: DIFF
92991: ST_TO_ADDR
92992: GO 92962
92994: POP
92995: POP
// if not tmp then
92996: LD_VAR 0 4
93000: NOT
93001: IFFALSE 93005
// exit ;
93003: GO 96342
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
93005: LD_ADDR_VAR 0 5
93009: PUSH
93010: LD_EXP 178
93014: PUSH
93015: LD_VAR 0 1
93019: ARRAY
93020: PPUSH
93021: LD_INT 2
93023: PUSH
93024: LD_INT 25
93026: PUSH
93027: LD_INT 1
93029: PUSH
93030: EMPTY
93031: LIST
93032: LIST
93033: PUSH
93034: LD_INT 25
93036: PUSH
93037: LD_INT 5
93039: PUSH
93040: EMPTY
93041: LIST
93042: LIST
93043: PUSH
93044: LD_INT 25
93046: PUSH
93047: LD_INT 8
93049: PUSH
93050: EMPTY
93051: LIST
93052: LIST
93053: PUSH
93054: LD_INT 25
93056: PUSH
93057: LD_INT 9
93059: PUSH
93060: EMPTY
93061: LIST
93062: LIST
93063: PUSH
93064: EMPTY
93065: LIST
93066: LIST
93067: LIST
93068: LIST
93069: LIST
93070: PPUSH
93071: CALL_OW 72
93075: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
93076: LD_ADDR_VAR 0 6
93080: PUSH
93081: LD_EXP 178
93085: PUSH
93086: LD_VAR 0 1
93090: ARRAY
93091: PPUSH
93092: LD_INT 25
93094: PUSH
93095: LD_INT 2
93097: PUSH
93098: EMPTY
93099: LIST
93100: LIST
93101: PPUSH
93102: CALL_OW 72
93106: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
93107: LD_ADDR_VAR 0 7
93111: PUSH
93112: LD_EXP 178
93116: PUSH
93117: LD_VAR 0 1
93121: ARRAY
93122: PPUSH
93123: LD_INT 25
93125: PUSH
93126: LD_INT 3
93128: PUSH
93129: EMPTY
93130: LIST
93131: LIST
93132: PPUSH
93133: CALL_OW 72
93137: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
93138: LD_ADDR_VAR 0 8
93142: PUSH
93143: LD_EXP 178
93147: PUSH
93148: LD_VAR 0 1
93152: ARRAY
93153: PPUSH
93154: LD_INT 25
93156: PUSH
93157: LD_INT 4
93159: PUSH
93160: EMPTY
93161: LIST
93162: LIST
93163: PUSH
93164: LD_INT 24
93166: PUSH
93167: LD_INT 251
93169: PUSH
93170: EMPTY
93171: LIST
93172: LIST
93173: PUSH
93174: EMPTY
93175: LIST
93176: LIST
93177: PPUSH
93178: CALL_OW 72
93182: ST_TO_ADDR
// if mc_is_defending [ base ] then
93183: LD_EXP 221
93187: PUSH
93188: LD_VAR 0 1
93192: ARRAY
93193: IFFALSE 93654
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
93195: LD_ADDR_EXP 220
93199: PUSH
93200: LD_EXP 220
93204: PPUSH
93205: LD_VAR 0 1
93209: PPUSH
93210: LD_INT 4
93212: PPUSH
93213: CALL_OW 1
93217: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
93218: LD_ADDR_VAR 0 12
93222: PUSH
93223: LD_EXP 178
93227: PUSH
93228: LD_VAR 0 1
93232: ARRAY
93233: PPUSH
93234: LD_INT 2
93236: PUSH
93237: LD_INT 30
93239: PUSH
93240: LD_INT 4
93242: PUSH
93243: EMPTY
93244: LIST
93245: LIST
93246: PUSH
93247: LD_INT 30
93249: PUSH
93250: LD_INT 5
93252: PUSH
93253: EMPTY
93254: LIST
93255: LIST
93256: PUSH
93257: EMPTY
93258: LIST
93259: LIST
93260: LIST
93261: PPUSH
93262: CALL_OW 72
93266: ST_TO_ADDR
// if not b then
93267: LD_VAR 0 12
93271: NOT
93272: IFFALSE 93276
// exit ;
93274: GO 96342
// p := [ ] ;
93276: LD_ADDR_VAR 0 11
93280: PUSH
93281: EMPTY
93282: ST_TO_ADDR
// if sci >= 2 then
93283: LD_VAR 0 8
93287: PUSH
93288: LD_INT 2
93290: GREATEREQUAL
93291: IFFALSE 93322
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
93293: LD_ADDR_VAR 0 8
93297: PUSH
93298: LD_VAR 0 8
93302: PUSH
93303: LD_INT 1
93305: ARRAY
93306: PUSH
93307: LD_VAR 0 8
93311: PUSH
93312: LD_INT 2
93314: ARRAY
93315: PUSH
93316: EMPTY
93317: LIST
93318: LIST
93319: ST_TO_ADDR
93320: GO 93383
// if sci = 1 then
93322: LD_VAR 0 8
93326: PUSH
93327: LD_INT 1
93329: EQUAL
93330: IFFALSE 93351
// sci := [ sci [ 1 ] ] else
93332: LD_ADDR_VAR 0 8
93336: PUSH
93337: LD_VAR 0 8
93341: PUSH
93342: LD_INT 1
93344: ARRAY
93345: PUSH
93346: EMPTY
93347: LIST
93348: ST_TO_ADDR
93349: GO 93383
// if sci = 0 then
93351: LD_VAR 0 8
93355: PUSH
93356: LD_INT 0
93358: EQUAL
93359: IFFALSE 93383
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
93361: LD_ADDR_VAR 0 11
93365: PUSH
93366: LD_VAR 0 4
93370: PPUSH
93371: LD_INT 4
93373: PPUSH
93374: CALL 55134 0 2
93378: PUSH
93379: LD_INT 1
93381: ARRAY
93382: ST_TO_ADDR
// if eng > 4 then
93383: LD_VAR 0 6
93387: PUSH
93388: LD_INT 4
93390: GREATER
93391: IFFALSE 93437
// for i = eng downto 4 do
93393: LD_ADDR_VAR 0 3
93397: PUSH
93398: DOUBLE
93399: LD_VAR 0 6
93403: INC
93404: ST_TO_ADDR
93405: LD_INT 4
93407: PUSH
93408: FOR_DOWNTO
93409: IFFALSE 93435
// eng := eng diff eng [ i ] ;
93411: LD_ADDR_VAR 0 6
93415: PUSH
93416: LD_VAR 0 6
93420: PUSH
93421: LD_VAR 0 6
93425: PUSH
93426: LD_VAR 0 3
93430: ARRAY
93431: DIFF
93432: ST_TO_ADDR
93433: GO 93408
93435: POP
93436: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
93437: LD_ADDR_VAR 0 4
93441: PUSH
93442: LD_VAR 0 4
93446: PUSH
93447: LD_VAR 0 5
93451: PUSH
93452: LD_VAR 0 6
93456: UNION
93457: PUSH
93458: LD_VAR 0 7
93462: UNION
93463: PUSH
93464: LD_VAR 0 8
93468: UNION
93469: DIFF
93470: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
93471: LD_ADDR_VAR 0 13
93475: PUSH
93476: LD_EXP 178
93480: PUSH
93481: LD_VAR 0 1
93485: ARRAY
93486: PPUSH
93487: LD_INT 2
93489: PUSH
93490: LD_INT 30
93492: PUSH
93493: LD_INT 32
93495: PUSH
93496: EMPTY
93497: LIST
93498: LIST
93499: PUSH
93500: LD_INT 30
93502: PUSH
93503: LD_INT 31
93505: PUSH
93506: EMPTY
93507: LIST
93508: LIST
93509: PUSH
93510: EMPTY
93511: LIST
93512: LIST
93513: LIST
93514: PPUSH
93515: CALL_OW 72
93519: PUSH
93520: LD_EXP 178
93524: PUSH
93525: LD_VAR 0 1
93529: ARRAY
93530: PPUSH
93531: LD_INT 2
93533: PUSH
93534: LD_INT 30
93536: PUSH
93537: LD_INT 4
93539: PUSH
93540: EMPTY
93541: LIST
93542: LIST
93543: PUSH
93544: LD_INT 30
93546: PUSH
93547: LD_INT 5
93549: PUSH
93550: EMPTY
93551: LIST
93552: LIST
93553: PUSH
93554: EMPTY
93555: LIST
93556: LIST
93557: LIST
93558: PPUSH
93559: CALL_OW 72
93563: PUSH
93564: LD_INT 6
93566: MUL
93567: PLUS
93568: ST_TO_ADDR
// if bcount < tmp then
93569: LD_VAR 0 13
93573: PUSH
93574: LD_VAR 0 4
93578: LESS
93579: IFFALSE 93625
// for i = tmp downto bcount do
93581: LD_ADDR_VAR 0 3
93585: PUSH
93586: DOUBLE
93587: LD_VAR 0 4
93591: INC
93592: ST_TO_ADDR
93593: LD_VAR 0 13
93597: PUSH
93598: FOR_DOWNTO
93599: IFFALSE 93623
// tmp := Delete ( tmp , tmp ) ;
93601: LD_ADDR_VAR 0 4
93605: PUSH
93606: LD_VAR 0 4
93610: PPUSH
93611: LD_VAR 0 4
93615: PPUSH
93616: CALL_OW 3
93620: ST_TO_ADDR
93621: GO 93598
93623: POP
93624: POP
// result := [ tmp , 0 , 0 , p ] ;
93625: LD_ADDR_VAR 0 2
93629: PUSH
93630: LD_VAR 0 4
93634: PUSH
93635: LD_INT 0
93637: PUSH
93638: LD_INT 0
93640: PUSH
93641: LD_VAR 0 11
93645: PUSH
93646: EMPTY
93647: LIST
93648: LIST
93649: LIST
93650: LIST
93651: ST_TO_ADDR
// exit ;
93652: GO 96342
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
93654: LD_EXP 178
93658: PUSH
93659: LD_VAR 0 1
93663: ARRAY
93664: PPUSH
93665: LD_INT 2
93667: PUSH
93668: LD_INT 30
93670: PUSH
93671: LD_INT 6
93673: PUSH
93674: EMPTY
93675: LIST
93676: LIST
93677: PUSH
93678: LD_INT 30
93680: PUSH
93681: LD_INT 7
93683: PUSH
93684: EMPTY
93685: LIST
93686: LIST
93687: PUSH
93688: LD_INT 30
93690: PUSH
93691: LD_INT 8
93693: PUSH
93694: EMPTY
93695: LIST
93696: LIST
93697: PUSH
93698: EMPTY
93699: LIST
93700: LIST
93701: LIST
93702: LIST
93703: PPUSH
93704: CALL_OW 72
93708: NOT
93709: PUSH
93710: LD_EXP 178
93714: PUSH
93715: LD_VAR 0 1
93719: ARRAY
93720: PPUSH
93721: LD_INT 30
93723: PUSH
93724: LD_INT 3
93726: PUSH
93727: EMPTY
93728: LIST
93729: LIST
93730: PPUSH
93731: CALL_OW 72
93735: NOT
93736: AND
93737: IFFALSE 93809
// begin if eng = tmp then
93739: LD_VAR 0 6
93743: PUSH
93744: LD_VAR 0 4
93748: EQUAL
93749: IFFALSE 93753
// exit ;
93751: GO 96342
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
93753: LD_ADDR_EXP 220
93757: PUSH
93758: LD_EXP 220
93762: PPUSH
93763: LD_VAR 0 1
93767: PPUSH
93768: LD_INT 1
93770: PPUSH
93771: CALL_OW 1
93775: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
93776: LD_ADDR_VAR 0 2
93780: PUSH
93781: LD_INT 0
93783: PUSH
93784: LD_VAR 0 4
93788: PUSH
93789: LD_VAR 0 6
93793: DIFF
93794: PUSH
93795: LD_INT 0
93797: PUSH
93798: LD_INT 0
93800: PUSH
93801: EMPTY
93802: LIST
93803: LIST
93804: LIST
93805: LIST
93806: ST_TO_ADDR
// exit ;
93807: GO 96342
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
93809: LD_EXP 205
93813: PUSH
93814: LD_EXP 204
93818: PUSH
93819: LD_VAR 0 1
93823: ARRAY
93824: ARRAY
93825: PUSH
93826: LD_EXP 178
93830: PUSH
93831: LD_VAR 0 1
93835: ARRAY
93836: PPUSH
93837: LD_INT 2
93839: PUSH
93840: LD_INT 30
93842: PUSH
93843: LD_INT 6
93845: PUSH
93846: EMPTY
93847: LIST
93848: LIST
93849: PUSH
93850: LD_INT 30
93852: PUSH
93853: LD_INT 7
93855: PUSH
93856: EMPTY
93857: LIST
93858: LIST
93859: PUSH
93860: LD_INT 30
93862: PUSH
93863: LD_INT 8
93865: PUSH
93866: EMPTY
93867: LIST
93868: LIST
93869: PUSH
93870: EMPTY
93871: LIST
93872: LIST
93873: LIST
93874: LIST
93875: PPUSH
93876: CALL_OW 72
93880: AND
93881: PUSH
93882: LD_EXP 178
93886: PUSH
93887: LD_VAR 0 1
93891: ARRAY
93892: PPUSH
93893: LD_INT 30
93895: PUSH
93896: LD_INT 3
93898: PUSH
93899: EMPTY
93900: LIST
93901: LIST
93902: PPUSH
93903: CALL_OW 72
93907: NOT
93908: AND
93909: IFFALSE 94123
// begin if sci >= 6 then
93911: LD_VAR 0 8
93915: PUSH
93916: LD_INT 6
93918: GREATEREQUAL
93919: IFFALSE 93923
// exit ;
93921: GO 96342
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
93923: LD_ADDR_EXP 220
93927: PUSH
93928: LD_EXP 220
93932: PPUSH
93933: LD_VAR 0 1
93937: PPUSH
93938: LD_INT 2
93940: PPUSH
93941: CALL_OW 1
93945: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
93946: LD_ADDR_VAR 0 9
93950: PUSH
93951: LD_VAR 0 4
93955: PUSH
93956: LD_VAR 0 8
93960: DIFF
93961: PPUSH
93962: LD_INT 4
93964: PPUSH
93965: CALL 55134 0 2
93969: ST_TO_ADDR
// p := [ ] ;
93970: LD_ADDR_VAR 0 11
93974: PUSH
93975: EMPTY
93976: ST_TO_ADDR
// if sci < 6 and sort > 6 then
93977: LD_VAR 0 8
93981: PUSH
93982: LD_INT 6
93984: LESS
93985: PUSH
93986: LD_VAR 0 9
93990: PUSH
93991: LD_INT 6
93993: GREATER
93994: AND
93995: IFFALSE 94076
// begin for i = 1 to 6 - sci do
93997: LD_ADDR_VAR 0 3
94001: PUSH
94002: DOUBLE
94003: LD_INT 1
94005: DEC
94006: ST_TO_ADDR
94007: LD_INT 6
94009: PUSH
94010: LD_VAR 0 8
94014: MINUS
94015: PUSH
94016: FOR_TO
94017: IFFALSE 94072
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
94019: LD_ADDR_VAR 0 11
94023: PUSH
94024: LD_VAR 0 11
94028: PPUSH
94029: LD_VAR 0 11
94033: PUSH
94034: LD_INT 1
94036: PLUS
94037: PPUSH
94038: LD_VAR 0 9
94042: PUSH
94043: LD_INT 1
94045: ARRAY
94046: PPUSH
94047: CALL_OW 2
94051: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
94052: LD_ADDR_VAR 0 9
94056: PUSH
94057: LD_VAR 0 9
94061: PPUSH
94062: LD_INT 1
94064: PPUSH
94065: CALL_OW 3
94069: ST_TO_ADDR
// end ;
94070: GO 94016
94072: POP
94073: POP
// end else
94074: GO 94096
// if sort then
94076: LD_VAR 0 9
94080: IFFALSE 94096
// p := sort [ 1 ] ;
94082: LD_ADDR_VAR 0 11
94086: PUSH
94087: LD_VAR 0 9
94091: PUSH
94092: LD_INT 1
94094: ARRAY
94095: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
94096: LD_ADDR_VAR 0 2
94100: PUSH
94101: LD_INT 0
94103: PUSH
94104: LD_INT 0
94106: PUSH
94107: LD_INT 0
94109: PUSH
94110: LD_VAR 0 11
94114: PUSH
94115: EMPTY
94116: LIST
94117: LIST
94118: LIST
94119: LIST
94120: ST_TO_ADDR
// exit ;
94121: GO 96342
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
94123: LD_EXP 205
94127: PUSH
94128: LD_EXP 204
94132: PUSH
94133: LD_VAR 0 1
94137: ARRAY
94138: ARRAY
94139: PUSH
94140: LD_EXP 178
94144: PUSH
94145: LD_VAR 0 1
94149: ARRAY
94150: PPUSH
94151: LD_INT 2
94153: PUSH
94154: LD_INT 30
94156: PUSH
94157: LD_INT 6
94159: PUSH
94160: EMPTY
94161: LIST
94162: LIST
94163: PUSH
94164: LD_INT 30
94166: PUSH
94167: LD_INT 7
94169: PUSH
94170: EMPTY
94171: LIST
94172: LIST
94173: PUSH
94174: LD_INT 30
94176: PUSH
94177: LD_INT 8
94179: PUSH
94180: EMPTY
94181: LIST
94182: LIST
94183: PUSH
94184: EMPTY
94185: LIST
94186: LIST
94187: LIST
94188: LIST
94189: PPUSH
94190: CALL_OW 72
94194: AND
94195: PUSH
94196: LD_EXP 178
94200: PUSH
94201: LD_VAR 0 1
94205: ARRAY
94206: PPUSH
94207: LD_INT 30
94209: PUSH
94210: LD_INT 3
94212: PUSH
94213: EMPTY
94214: LIST
94215: LIST
94216: PPUSH
94217: CALL_OW 72
94221: AND
94222: IFFALSE 94956
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
94224: LD_ADDR_EXP 220
94228: PUSH
94229: LD_EXP 220
94233: PPUSH
94234: LD_VAR 0 1
94238: PPUSH
94239: LD_INT 3
94241: PPUSH
94242: CALL_OW 1
94246: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
94247: LD_ADDR_VAR 0 2
94251: PUSH
94252: LD_INT 0
94254: PUSH
94255: LD_INT 0
94257: PUSH
94258: LD_INT 0
94260: PUSH
94261: LD_INT 0
94263: PUSH
94264: EMPTY
94265: LIST
94266: LIST
94267: LIST
94268: LIST
94269: ST_TO_ADDR
// if not eng then
94270: LD_VAR 0 6
94274: NOT
94275: IFFALSE 94338
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
94277: LD_ADDR_VAR 0 11
94281: PUSH
94282: LD_VAR 0 4
94286: PPUSH
94287: LD_INT 2
94289: PPUSH
94290: CALL 55134 0 2
94294: PUSH
94295: LD_INT 1
94297: ARRAY
94298: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
94299: LD_ADDR_VAR 0 2
94303: PUSH
94304: LD_VAR 0 2
94308: PPUSH
94309: LD_INT 2
94311: PPUSH
94312: LD_VAR 0 11
94316: PPUSH
94317: CALL_OW 1
94321: ST_TO_ADDR
// tmp := tmp diff p ;
94322: LD_ADDR_VAR 0 4
94326: PUSH
94327: LD_VAR 0 4
94331: PUSH
94332: LD_VAR 0 11
94336: DIFF
94337: ST_TO_ADDR
// end ; if tmp and sci < 6 then
94338: LD_VAR 0 4
94342: PUSH
94343: LD_VAR 0 8
94347: PUSH
94348: LD_INT 6
94350: LESS
94351: AND
94352: IFFALSE 94540
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
94354: LD_ADDR_VAR 0 9
94358: PUSH
94359: LD_VAR 0 4
94363: PUSH
94364: LD_VAR 0 8
94368: PUSH
94369: LD_VAR 0 7
94373: UNION
94374: DIFF
94375: PPUSH
94376: LD_INT 4
94378: PPUSH
94379: CALL 55134 0 2
94383: ST_TO_ADDR
// p := [ ] ;
94384: LD_ADDR_VAR 0 11
94388: PUSH
94389: EMPTY
94390: ST_TO_ADDR
// if sort then
94391: LD_VAR 0 9
94395: IFFALSE 94511
// for i = 1 to 6 - sci do
94397: LD_ADDR_VAR 0 3
94401: PUSH
94402: DOUBLE
94403: LD_INT 1
94405: DEC
94406: ST_TO_ADDR
94407: LD_INT 6
94409: PUSH
94410: LD_VAR 0 8
94414: MINUS
94415: PUSH
94416: FOR_TO
94417: IFFALSE 94509
// begin if i = sort then
94419: LD_VAR 0 3
94423: PUSH
94424: LD_VAR 0 9
94428: EQUAL
94429: IFFALSE 94433
// break ;
94431: GO 94509
// if GetClass ( i ) = 4 then
94433: LD_VAR 0 3
94437: PPUSH
94438: CALL_OW 257
94442: PUSH
94443: LD_INT 4
94445: EQUAL
94446: IFFALSE 94450
// continue ;
94448: GO 94416
// p := Insert ( p , p + 1 , sort [ i ] ) ;
94450: LD_ADDR_VAR 0 11
94454: PUSH
94455: LD_VAR 0 11
94459: PPUSH
94460: LD_VAR 0 11
94464: PUSH
94465: LD_INT 1
94467: PLUS
94468: PPUSH
94469: LD_VAR 0 9
94473: PUSH
94474: LD_VAR 0 3
94478: ARRAY
94479: PPUSH
94480: CALL_OW 2
94484: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
94485: LD_ADDR_VAR 0 4
94489: PUSH
94490: LD_VAR 0 4
94494: PUSH
94495: LD_VAR 0 9
94499: PUSH
94500: LD_VAR 0 3
94504: ARRAY
94505: DIFF
94506: ST_TO_ADDR
// end ;
94507: GO 94416
94509: POP
94510: POP
// if p then
94511: LD_VAR 0 11
94515: IFFALSE 94540
// result := Replace ( result , 4 , p ) ;
94517: LD_ADDR_VAR 0 2
94521: PUSH
94522: LD_VAR 0 2
94526: PPUSH
94527: LD_INT 4
94529: PPUSH
94530: LD_VAR 0 11
94534: PPUSH
94535: CALL_OW 1
94539: ST_TO_ADDR
// end ; if tmp and mech < 6 then
94540: LD_VAR 0 4
94544: PUSH
94545: LD_VAR 0 7
94549: PUSH
94550: LD_INT 6
94552: LESS
94553: AND
94554: IFFALSE 94742
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
94556: LD_ADDR_VAR 0 9
94560: PUSH
94561: LD_VAR 0 4
94565: PUSH
94566: LD_VAR 0 8
94570: PUSH
94571: LD_VAR 0 7
94575: UNION
94576: DIFF
94577: PPUSH
94578: LD_INT 3
94580: PPUSH
94581: CALL 55134 0 2
94585: ST_TO_ADDR
// p := [ ] ;
94586: LD_ADDR_VAR 0 11
94590: PUSH
94591: EMPTY
94592: ST_TO_ADDR
// if sort then
94593: LD_VAR 0 9
94597: IFFALSE 94713
// for i = 1 to 6 - mech do
94599: LD_ADDR_VAR 0 3
94603: PUSH
94604: DOUBLE
94605: LD_INT 1
94607: DEC
94608: ST_TO_ADDR
94609: LD_INT 6
94611: PUSH
94612: LD_VAR 0 7
94616: MINUS
94617: PUSH
94618: FOR_TO
94619: IFFALSE 94711
// begin if i = sort then
94621: LD_VAR 0 3
94625: PUSH
94626: LD_VAR 0 9
94630: EQUAL
94631: IFFALSE 94635
// break ;
94633: GO 94711
// if GetClass ( i ) = 3 then
94635: LD_VAR 0 3
94639: PPUSH
94640: CALL_OW 257
94644: PUSH
94645: LD_INT 3
94647: EQUAL
94648: IFFALSE 94652
// continue ;
94650: GO 94618
// p := Insert ( p , p + 1 , sort [ i ] ) ;
94652: LD_ADDR_VAR 0 11
94656: PUSH
94657: LD_VAR 0 11
94661: PPUSH
94662: LD_VAR 0 11
94666: PUSH
94667: LD_INT 1
94669: PLUS
94670: PPUSH
94671: LD_VAR 0 9
94675: PUSH
94676: LD_VAR 0 3
94680: ARRAY
94681: PPUSH
94682: CALL_OW 2
94686: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
94687: LD_ADDR_VAR 0 4
94691: PUSH
94692: LD_VAR 0 4
94696: PUSH
94697: LD_VAR 0 9
94701: PUSH
94702: LD_VAR 0 3
94706: ARRAY
94707: DIFF
94708: ST_TO_ADDR
// end ;
94709: GO 94618
94711: POP
94712: POP
// if p then
94713: LD_VAR 0 11
94717: IFFALSE 94742
// result := Replace ( result , 3 , p ) ;
94719: LD_ADDR_VAR 0 2
94723: PUSH
94724: LD_VAR 0 2
94728: PPUSH
94729: LD_INT 3
94731: PPUSH
94732: LD_VAR 0 11
94736: PPUSH
94737: CALL_OW 1
94741: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
94742: LD_VAR 0 4
94746: PUSH
94747: LD_INT 6
94749: GREATER
94750: PUSH
94751: LD_VAR 0 6
94755: PUSH
94756: LD_INT 6
94758: LESS
94759: AND
94760: IFFALSE 94954
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
94762: LD_ADDR_VAR 0 9
94766: PUSH
94767: LD_VAR 0 4
94771: PUSH
94772: LD_VAR 0 8
94776: PUSH
94777: LD_VAR 0 7
94781: UNION
94782: PUSH
94783: LD_VAR 0 6
94787: UNION
94788: DIFF
94789: PPUSH
94790: LD_INT 2
94792: PPUSH
94793: CALL 55134 0 2
94797: ST_TO_ADDR
// p := [ ] ;
94798: LD_ADDR_VAR 0 11
94802: PUSH
94803: EMPTY
94804: ST_TO_ADDR
// if sort then
94805: LD_VAR 0 9
94809: IFFALSE 94925
// for i = 1 to 6 - eng do
94811: LD_ADDR_VAR 0 3
94815: PUSH
94816: DOUBLE
94817: LD_INT 1
94819: DEC
94820: ST_TO_ADDR
94821: LD_INT 6
94823: PUSH
94824: LD_VAR 0 6
94828: MINUS
94829: PUSH
94830: FOR_TO
94831: IFFALSE 94923
// begin if i = sort then
94833: LD_VAR 0 3
94837: PUSH
94838: LD_VAR 0 9
94842: EQUAL
94843: IFFALSE 94847
// break ;
94845: GO 94923
// if GetClass ( i ) = 2 then
94847: LD_VAR 0 3
94851: PPUSH
94852: CALL_OW 257
94856: PUSH
94857: LD_INT 2
94859: EQUAL
94860: IFFALSE 94864
// continue ;
94862: GO 94830
// p := Insert ( p , p + 1 , sort [ i ] ) ;
94864: LD_ADDR_VAR 0 11
94868: PUSH
94869: LD_VAR 0 11
94873: PPUSH
94874: LD_VAR 0 11
94878: PUSH
94879: LD_INT 1
94881: PLUS
94882: PPUSH
94883: LD_VAR 0 9
94887: PUSH
94888: LD_VAR 0 3
94892: ARRAY
94893: PPUSH
94894: CALL_OW 2
94898: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
94899: LD_ADDR_VAR 0 4
94903: PUSH
94904: LD_VAR 0 4
94908: PUSH
94909: LD_VAR 0 9
94913: PUSH
94914: LD_VAR 0 3
94918: ARRAY
94919: DIFF
94920: ST_TO_ADDR
// end ;
94921: GO 94830
94923: POP
94924: POP
// if p then
94925: LD_VAR 0 11
94929: IFFALSE 94954
// result := Replace ( result , 2 , p ) ;
94931: LD_ADDR_VAR 0 2
94935: PUSH
94936: LD_VAR 0 2
94940: PPUSH
94941: LD_INT 2
94943: PPUSH
94944: LD_VAR 0 11
94948: PPUSH
94949: CALL_OW 1
94953: ST_TO_ADDR
// end ; exit ;
94954: GO 96342
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
94956: LD_EXP 205
94960: PUSH
94961: LD_EXP 204
94965: PUSH
94966: LD_VAR 0 1
94970: ARRAY
94971: ARRAY
94972: NOT
94973: PUSH
94974: LD_EXP 178
94978: PUSH
94979: LD_VAR 0 1
94983: ARRAY
94984: PPUSH
94985: LD_INT 30
94987: PUSH
94988: LD_INT 3
94990: PUSH
94991: EMPTY
94992: LIST
94993: LIST
94994: PPUSH
94995: CALL_OW 72
94999: AND
95000: PUSH
95001: LD_EXP 183
95005: PUSH
95006: LD_VAR 0 1
95010: ARRAY
95011: AND
95012: IFFALSE 95620
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
95014: LD_ADDR_EXP 220
95018: PUSH
95019: LD_EXP 220
95023: PPUSH
95024: LD_VAR 0 1
95028: PPUSH
95029: LD_INT 5
95031: PPUSH
95032: CALL_OW 1
95036: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
95037: LD_ADDR_VAR 0 2
95041: PUSH
95042: LD_INT 0
95044: PUSH
95045: LD_INT 0
95047: PUSH
95048: LD_INT 0
95050: PUSH
95051: LD_INT 0
95053: PUSH
95054: EMPTY
95055: LIST
95056: LIST
95057: LIST
95058: LIST
95059: ST_TO_ADDR
// if sci > 1 then
95060: LD_VAR 0 8
95064: PUSH
95065: LD_INT 1
95067: GREATER
95068: IFFALSE 95096
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
95070: LD_ADDR_VAR 0 4
95074: PUSH
95075: LD_VAR 0 4
95079: PUSH
95080: LD_VAR 0 8
95084: PUSH
95085: LD_VAR 0 8
95089: PUSH
95090: LD_INT 1
95092: ARRAY
95093: DIFF
95094: DIFF
95095: ST_TO_ADDR
// if tmp and not sci then
95096: LD_VAR 0 4
95100: PUSH
95101: LD_VAR 0 8
95105: NOT
95106: AND
95107: IFFALSE 95176
// begin sort := SortBySkill ( tmp , 4 ) ;
95109: LD_ADDR_VAR 0 9
95113: PUSH
95114: LD_VAR 0 4
95118: PPUSH
95119: LD_INT 4
95121: PPUSH
95122: CALL 55134 0 2
95126: ST_TO_ADDR
// if sort then
95127: LD_VAR 0 9
95131: IFFALSE 95147
// p := sort [ 1 ] ;
95133: LD_ADDR_VAR 0 11
95137: PUSH
95138: LD_VAR 0 9
95142: PUSH
95143: LD_INT 1
95145: ARRAY
95146: ST_TO_ADDR
// if p then
95147: LD_VAR 0 11
95151: IFFALSE 95176
// result := Replace ( result , 4 , p ) ;
95153: LD_ADDR_VAR 0 2
95157: PUSH
95158: LD_VAR 0 2
95162: PPUSH
95163: LD_INT 4
95165: PPUSH
95166: LD_VAR 0 11
95170: PPUSH
95171: CALL_OW 1
95175: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
95176: LD_ADDR_VAR 0 4
95180: PUSH
95181: LD_VAR 0 4
95185: PUSH
95186: LD_VAR 0 7
95190: DIFF
95191: ST_TO_ADDR
// if tmp and mech < 6 then
95192: LD_VAR 0 4
95196: PUSH
95197: LD_VAR 0 7
95201: PUSH
95202: LD_INT 6
95204: LESS
95205: AND
95206: IFFALSE 95394
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
95208: LD_ADDR_VAR 0 9
95212: PUSH
95213: LD_VAR 0 4
95217: PUSH
95218: LD_VAR 0 8
95222: PUSH
95223: LD_VAR 0 7
95227: UNION
95228: DIFF
95229: PPUSH
95230: LD_INT 3
95232: PPUSH
95233: CALL 55134 0 2
95237: ST_TO_ADDR
// p := [ ] ;
95238: LD_ADDR_VAR 0 11
95242: PUSH
95243: EMPTY
95244: ST_TO_ADDR
// if sort then
95245: LD_VAR 0 9
95249: IFFALSE 95365
// for i = 1 to 6 - mech do
95251: LD_ADDR_VAR 0 3
95255: PUSH
95256: DOUBLE
95257: LD_INT 1
95259: DEC
95260: ST_TO_ADDR
95261: LD_INT 6
95263: PUSH
95264: LD_VAR 0 7
95268: MINUS
95269: PUSH
95270: FOR_TO
95271: IFFALSE 95363
// begin if i = sort then
95273: LD_VAR 0 3
95277: PUSH
95278: LD_VAR 0 9
95282: EQUAL
95283: IFFALSE 95287
// break ;
95285: GO 95363
// if GetClass ( i ) = 3 then
95287: LD_VAR 0 3
95291: PPUSH
95292: CALL_OW 257
95296: PUSH
95297: LD_INT 3
95299: EQUAL
95300: IFFALSE 95304
// continue ;
95302: GO 95270
// p := Insert ( p , p + 1 , sort [ i ] ) ;
95304: LD_ADDR_VAR 0 11
95308: PUSH
95309: LD_VAR 0 11
95313: PPUSH
95314: LD_VAR 0 11
95318: PUSH
95319: LD_INT 1
95321: PLUS
95322: PPUSH
95323: LD_VAR 0 9
95327: PUSH
95328: LD_VAR 0 3
95332: ARRAY
95333: PPUSH
95334: CALL_OW 2
95338: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
95339: LD_ADDR_VAR 0 4
95343: PUSH
95344: LD_VAR 0 4
95348: PUSH
95349: LD_VAR 0 9
95353: PUSH
95354: LD_VAR 0 3
95358: ARRAY
95359: DIFF
95360: ST_TO_ADDR
// end ;
95361: GO 95270
95363: POP
95364: POP
// if p then
95365: LD_VAR 0 11
95369: IFFALSE 95394
// result := Replace ( result , 3 , p ) ;
95371: LD_ADDR_VAR 0 2
95375: PUSH
95376: LD_VAR 0 2
95380: PPUSH
95381: LD_INT 3
95383: PPUSH
95384: LD_VAR 0 11
95388: PPUSH
95389: CALL_OW 1
95393: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
95394: LD_ADDR_VAR 0 4
95398: PUSH
95399: LD_VAR 0 4
95403: PUSH
95404: LD_VAR 0 6
95408: DIFF
95409: ST_TO_ADDR
// if tmp and eng < 6 then
95410: LD_VAR 0 4
95414: PUSH
95415: LD_VAR 0 6
95419: PUSH
95420: LD_INT 6
95422: LESS
95423: AND
95424: IFFALSE 95618
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
95426: LD_ADDR_VAR 0 9
95430: PUSH
95431: LD_VAR 0 4
95435: PUSH
95436: LD_VAR 0 8
95440: PUSH
95441: LD_VAR 0 7
95445: UNION
95446: PUSH
95447: LD_VAR 0 6
95451: UNION
95452: DIFF
95453: PPUSH
95454: LD_INT 2
95456: PPUSH
95457: CALL 55134 0 2
95461: ST_TO_ADDR
// p := [ ] ;
95462: LD_ADDR_VAR 0 11
95466: PUSH
95467: EMPTY
95468: ST_TO_ADDR
// if sort then
95469: LD_VAR 0 9
95473: IFFALSE 95589
// for i = 1 to 6 - eng do
95475: LD_ADDR_VAR 0 3
95479: PUSH
95480: DOUBLE
95481: LD_INT 1
95483: DEC
95484: ST_TO_ADDR
95485: LD_INT 6
95487: PUSH
95488: LD_VAR 0 6
95492: MINUS
95493: PUSH
95494: FOR_TO
95495: IFFALSE 95587
// begin if i = sort then
95497: LD_VAR 0 3
95501: PUSH
95502: LD_VAR 0 9
95506: EQUAL
95507: IFFALSE 95511
// break ;
95509: GO 95587
// if GetClass ( i ) = 2 then
95511: LD_VAR 0 3
95515: PPUSH
95516: CALL_OW 257
95520: PUSH
95521: LD_INT 2
95523: EQUAL
95524: IFFALSE 95528
// continue ;
95526: GO 95494
// p := Insert ( p , p + 1 , sort [ i ] ) ;
95528: LD_ADDR_VAR 0 11
95532: PUSH
95533: LD_VAR 0 11
95537: PPUSH
95538: LD_VAR 0 11
95542: PUSH
95543: LD_INT 1
95545: PLUS
95546: PPUSH
95547: LD_VAR 0 9
95551: PUSH
95552: LD_VAR 0 3
95556: ARRAY
95557: PPUSH
95558: CALL_OW 2
95562: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
95563: LD_ADDR_VAR 0 4
95567: PUSH
95568: LD_VAR 0 4
95572: PUSH
95573: LD_VAR 0 9
95577: PUSH
95578: LD_VAR 0 3
95582: ARRAY
95583: DIFF
95584: ST_TO_ADDR
// end ;
95585: GO 95494
95587: POP
95588: POP
// if p then
95589: LD_VAR 0 11
95593: IFFALSE 95618
// result := Replace ( result , 2 , p ) ;
95595: LD_ADDR_VAR 0 2
95599: PUSH
95600: LD_VAR 0 2
95604: PPUSH
95605: LD_INT 2
95607: PPUSH
95608: LD_VAR 0 11
95612: PPUSH
95613: CALL_OW 1
95617: ST_TO_ADDR
// end ; exit ;
95618: GO 96342
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
95620: LD_EXP 205
95624: PUSH
95625: LD_EXP 204
95629: PUSH
95630: LD_VAR 0 1
95634: ARRAY
95635: ARRAY
95636: NOT
95637: PUSH
95638: LD_EXP 178
95642: PUSH
95643: LD_VAR 0 1
95647: ARRAY
95648: PPUSH
95649: LD_INT 30
95651: PUSH
95652: LD_INT 3
95654: PUSH
95655: EMPTY
95656: LIST
95657: LIST
95658: PPUSH
95659: CALL_OW 72
95663: AND
95664: PUSH
95665: LD_EXP 183
95669: PUSH
95670: LD_VAR 0 1
95674: ARRAY
95675: NOT
95676: AND
95677: IFFALSE 96342
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
95679: LD_ADDR_EXP 220
95683: PUSH
95684: LD_EXP 220
95688: PPUSH
95689: LD_VAR 0 1
95693: PPUSH
95694: LD_INT 6
95696: PPUSH
95697: CALL_OW 1
95701: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
95702: LD_ADDR_VAR 0 2
95706: PUSH
95707: LD_INT 0
95709: PUSH
95710: LD_INT 0
95712: PUSH
95713: LD_INT 0
95715: PUSH
95716: LD_INT 0
95718: PUSH
95719: EMPTY
95720: LIST
95721: LIST
95722: LIST
95723: LIST
95724: ST_TO_ADDR
// if sci >= 1 then
95725: LD_VAR 0 8
95729: PUSH
95730: LD_INT 1
95732: GREATEREQUAL
95733: IFFALSE 95755
// tmp := tmp diff sci [ 1 ] ;
95735: LD_ADDR_VAR 0 4
95739: PUSH
95740: LD_VAR 0 4
95744: PUSH
95745: LD_VAR 0 8
95749: PUSH
95750: LD_INT 1
95752: ARRAY
95753: DIFF
95754: ST_TO_ADDR
// if tmp and not sci then
95755: LD_VAR 0 4
95759: PUSH
95760: LD_VAR 0 8
95764: NOT
95765: AND
95766: IFFALSE 95835
// begin sort := SortBySkill ( tmp , 4 ) ;
95768: LD_ADDR_VAR 0 9
95772: PUSH
95773: LD_VAR 0 4
95777: PPUSH
95778: LD_INT 4
95780: PPUSH
95781: CALL 55134 0 2
95785: ST_TO_ADDR
// if sort then
95786: LD_VAR 0 9
95790: IFFALSE 95806
// p := sort [ 1 ] ;
95792: LD_ADDR_VAR 0 11
95796: PUSH
95797: LD_VAR 0 9
95801: PUSH
95802: LD_INT 1
95804: ARRAY
95805: ST_TO_ADDR
// if p then
95806: LD_VAR 0 11
95810: IFFALSE 95835
// result := Replace ( result , 4 , p ) ;
95812: LD_ADDR_VAR 0 2
95816: PUSH
95817: LD_VAR 0 2
95821: PPUSH
95822: LD_INT 4
95824: PPUSH
95825: LD_VAR 0 11
95829: PPUSH
95830: CALL_OW 1
95834: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
95835: LD_ADDR_VAR 0 4
95839: PUSH
95840: LD_VAR 0 4
95844: PUSH
95845: LD_VAR 0 7
95849: DIFF
95850: ST_TO_ADDR
// if tmp and mech < 6 then
95851: LD_VAR 0 4
95855: PUSH
95856: LD_VAR 0 7
95860: PUSH
95861: LD_INT 6
95863: LESS
95864: AND
95865: IFFALSE 96047
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
95867: LD_ADDR_VAR 0 9
95871: PUSH
95872: LD_VAR 0 4
95876: PUSH
95877: LD_VAR 0 7
95881: DIFF
95882: PPUSH
95883: LD_INT 3
95885: PPUSH
95886: CALL 55134 0 2
95890: ST_TO_ADDR
// p := [ ] ;
95891: LD_ADDR_VAR 0 11
95895: PUSH
95896: EMPTY
95897: ST_TO_ADDR
// if sort then
95898: LD_VAR 0 9
95902: IFFALSE 96018
// for i = 1 to 6 - mech do
95904: LD_ADDR_VAR 0 3
95908: PUSH
95909: DOUBLE
95910: LD_INT 1
95912: DEC
95913: ST_TO_ADDR
95914: LD_INT 6
95916: PUSH
95917: LD_VAR 0 7
95921: MINUS
95922: PUSH
95923: FOR_TO
95924: IFFALSE 96016
// begin if i = sort then
95926: LD_VAR 0 3
95930: PUSH
95931: LD_VAR 0 9
95935: EQUAL
95936: IFFALSE 95940
// break ;
95938: GO 96016
// if GetClass ( i ) = 3 then
95940: LD_VAR 0 3
95944: PPUSH
95945: CALL_OW 257
95949: PUSH
95950: LD_INT 3
95952: EQUAL
95953: IFFALSE 95957
// continue ;
95955: GO 95923
// p := Insert ( p , p + 1 , sort [ i ] ) ;
95957: LD_ADDR_VAR 0 11
95961: PUSH
95962: LD_VAR 0 11
95966: PPUSH
95967: LD_VAR 0 11
95971: PUSH
95972: LD_INT 1
95974: PLUS
95975: PPUSH
95976: LD_VAR 0 9
95980: PUSH
95981: LD_VAR 0 3
95985: ARRAY
95986: PPUSH
95987: CALL_OW 2
95991: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
95992: LD_ADDR_VAR 0 4
95996: PUSH
95997: LD_VAR 0 4
96001: PUSH
96002: LD_VAR 0 9
96006: PUSH
96007: LD_VAR 0 3
96011: ARRAY
96012: DIFF
96013: ST_TO_ADDR
// end ;
96014: GO 95923
96016: POP
96017: POP
// if p then
96018: LD_VAR 0 11
96022: IFFALSE 96047
// result := Replace ( result , 3 , p ) ;
96024: LD_ADDR_VAR 0 2
96028: PUSH
96029: LD_VAR 0 2
96033: PPUSH
96034: LD_INT 3
96036: PPUSH
96037: LD_VAR 0 11
96041: PPUSH
96042: CALL_OW 1
96046: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
96047: LD_ADDR_VAR 0 4
96051: PUSH
96052: LD_VAR 0 4
96056: PUSH
96057: LD_VAR 0 6
96061: DIFF
96062: ST_TO_ADDR
// if tmp and eng < 4 then
96063: LD_VAR 0 4
96067: PUSH
96068: LD_VAR 0 6
96072: PUSH
96073: LD_INT 4
96075: LESS
96076: AND
96077: IFFALSE 96267
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
96079: LD_ADDR_VAR 0 9
96083: PUSH
96084: LD_VAR 0 4
96088: PUSH
96089: LD_VAR 0 7
96093: PUSH
96094: LD_VAR 0 6
96098: UNION
96099: DIFF
96100: PPUSH
96101: LD_INT 2
96103: PPUSH
96104: CALL 55134 0 2
96108: ST_TO_ADDR
// p := [ ] ;
96109: LD_ADDR_VAR 0 11
96113: PUSH
96114: EMPTY
96115: ST_TO_ADDR
// if sort then
96116: LD_VAR 0 9
96120: IFFALSE 96236
// for i = 1 to 4 - eng do
96122: LD_ADDR_VAR 0 3
96126: PUSH
96127: DOUBLE
96128: LD_INT 1
96130: DEC
96131: ST_TO_ADDR
96132: LD_INT 4
96134: PUSH
96135: LD_VAR 0 6
96139: MINUS
96140: PUSH
96141: FOR_TO
96142: IFFALSE 96234
// begin if i = sort then
96144: LD_VAR 0 3
96148: PUSH
96149: LD_VAR 0 9
96153: EQUAL
96154: IFFALSE 96158
// break ;
96156: GO 96234
// if GetClass ( i ) = 2 then
96158: LD_VAR 0 3
96162: PPUSH
96163: CALL_OW 257
96167: PUSH
96168: LD_INT 2
96170: EQUAL
96171: IFFALSE 96175
// continue ;
96173: GO 96141
// p := Insert ( p , p + 1 , sort [ i ] ) ;
96175: LD_ADDR_VAR 0 11
96179: PUSH
96180: LD_VAR 0 11
96184: PPUSH
96185: LD_VAR 0 11
96189: PUSH
96190: LD_INT 1
96192: PLUS
96193: PPUSH
96194: LD_VAR 0 9
96198: PUSH
96199: LD_VAR 0 3
96203: ARRAY
96204: PPUSH
96205: CALL_OW 2
96209: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
96210: LD_ADDR_VAR 0 4
96214: PUSH
96215: LD_VAR 0 4
96219: PUSH
96220: LD_VAR 0 9
96224: PUSH
96225: LD_VAR 0 3
96229: ARRAY
96230: DIFF
96231: ST_TO_ADDR
// end ;
96232: GO 96141
96234: POP
96235: POP
// if p then
96236: LD_VAR 0 11
96240: IFFALSE 96265
// result := Replace ( result , 2 , p ) ;
96242: LD_ADDR_VAR 0 2
96246: PUSH
96247: LD_VAR 0 2
96251: PPUSH
96252: LD_INT 2
96254: PPUSH
96255: LD_VAR 0 11
96259: PPUSH
96260: CALL_OW 1
96264: ST_TO_ADDR
// end else
96265: GO 96311
// for i = eng downto 5 do
96267: LD_ADDR_VAR 0 3
96271: PUSH
96272: DOUBLE
96273: LD_VAR 0 6
96277: INC
96278: ST_TO_ADDR
96279: LD_INT 5
96281: PUSH
96282: FOR_DOWNTO
96283: IFFALSE 96309
// tmp := tmp union eng [ i ] ;
96285: LD_ADDR_VAR 0 4
96289: PUSH
96290: LD_VAR 0 4
96294: PUSH
96295: LD_VAR 0 6
96299: PUSH
96300: LD_VAR 0 3
96304: ARRAY
96305: UNION
96306: ST_TO_ADDR
96307: GO 96282
96309: POP
96310: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
96311: LD_ADDR_VAR 0 2
96315: PUSH
96316: LD_VAR 0 2
96320: PPUSH
96321: LD_INT 1
96323: PPUSH
96324: LD_VAR 0 4
96328: PUSH
96329: LD_VAR 0 5
96333: DIFF
96334: PPUSH
96335: CALL_OW 1
96339: ST_TO_ADDR
// exit ;
96340: GO 96342
// end ; end ;
96342: LD_VAR 0 2
96346: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
96347: LD_INT 0
96349: PPUSH
96350: PPUSH
96351: PPUSH
// if not mc_bases then
96352: LD_EXP 178
96356: NOT
96357: IFFALSE 96361
// exit ;
96359: GO 96503
// for i = 1 to mc_bases do
96361: LD_ADDR_VAR 0 2
96365: PUSH
96366: DOUBLE
96367: LD_INT 1
96369: DEC
96370: ST_TO_ADDR
96371: LD_EXP 178
96375: PUSH
96376: FOR_TO
96377: IFFALSE 96494
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
96379: LD_ADDR_VAR 0 3
96383: PUSH
96384: LD_EXP 178
96388: PUSH
96389: LD_VAR 0 2
96393: ARRAY
96394: PPUSH
96395: LD_INT 21
96397: PUSH
96398: LD_INT 3
96400: PUSH
96401: EMPTY
96402: LIST
96403: LIST
96404: PUSH
96405: LD_INT 3
96407: PUSH
96408: LD_INT 2
96410: PUSH
96411: LD_INT 30
96413: PUSH
96414: LD_INT 29
96416: PUSH
96417: EMPTY
96418: LIST
96419: LIST
96420: PUSH
96421: LD_INT 30
96423: PUSH
96424: LD_INT 30
96426: PUSH
96427: EMPTY
96428: LIST
96429: LIST
96430: PUSH
96431: EMPTY
96432: LIST
96433: LIST
96434: LIST
96435: PUSH
96436: EMPTY
96437: LIST
96438: LIST
96439: PUSH
96440: LD_INT 3
96442: PUSH
96443: LD_INT 24
96445: PUSH
96446: LD_INT 1000
96448: PUSH
96449: EMPTY
96450: LIST
96451: LIST
96452: PUSH
96453: EMPTY
96454: LIST
96455: LIST
96456: PUSH
96457: EMPTY
96458: LIST
96459: LIST
96460: LIST
96461: PPUSH
96462: CALL_OW 72
96466: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
96467: LD_ADDR_EXP 179
96471: PUSH
96472: LD_EXP 179
96476: PPUSH
96477: LD_VAR 0 2
96481: PPUSH
96482: LD_VAR 0 3
96486: PPUSH
96487: CALL_OW 1
96491: ST_TO_ADDR
// end ;
96492: GO 96376
96494: POP
96495: POP
// RaiseSailEvent ( 101 ) ;
96496: LD_INT 101
96498: PPUSH
96499: CALL_OW 427
// end ;
96503: LD_VAR 0 1
96507: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
96508: LD_INT 0
96510: PPUSH
96511: PPUSH
96512: PPUSH
96513: PPUSH
96514: PPUSH
96515: PPUSH
96516: PPUSH
// if not mc_bases then
96517: LD_EXP 178
96521: NOT
96522: IFFALSE 96526
// exit ;
96524: GO 97088
// for i = 1 to mc_bases do
96526: LD_ADDR_VAR 0 2
96530: PUSH
96531: DOUBLE
96532: LD_INT 1
96534: DEC
96535: ST_TO_ADDR
96536: LD_EXP 178
96540: PUSH
96541: FOR_TO
96542: IFFALSE 97079
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 1000 ] ] ] ] ) ;
96544: LD_ADDR_VAR 0 5
96548: PUSH
96549: LD_EXP 178
96553: PUSH
96554: LD_VAR 0 2
96558: ARRAY
96559: PUSH
96560: LD_EXP 207
96564: PUSH
96565: LD_VAR 0 2
96569: ARRAY
96570: UNION
96571: PPUSH
96572: LD_INT 21
96574: PUSH
96575: LD_INT 1
96577: PUSH
96578: EMPTY
96579: LIST
96580: LIST
96581: PUSH
96582: LD_INT 1
96584: PUSH
96585: LD_INT 3
96587: PUSH
96588: LD_INT 54
96590: PUSH
96591: EMPTY
96592: LIST
96593: PUSH
96594: EMPTY
96595: LIST
96596: LIST
96597: PUSH
96598: LD_INT 3
96600: PUSH
96601: LD_INT 24
96603: PUSH
96604: LD_INT 1000
96606: PUSH
96607: EMPTY
96608: LIST
96609: LIST
96610: PUSH
96611: EMPTY
96612: LIST
96613: LIST
96614: PUSH
96615: EMPTY
96616: LIST
96617: LIST
96618: LIST
96619: PUSH
96620: EMPTY
96621: LIST
96622: LIST
96623: PPUSH
96624: CALL_OW 72
96628: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
96629: LD_ADDR_VAR 0 6
96633: PUSH
96634: LD_EXP 178
96638: PUSH
96639: LD_VAR 0 2
96643: ARRAY
96644: PPUSH
96645: LD_INT 21
96647: PUSH
96648: LD_INT 1
96650: PUSH
96651: EMPTY
96652: LIST
96653: LIST
96654: PUSH
96655: LD_INT 1
96657: PUSH
96658: LD_INT 3
96660: PUSH
96661: LD_INT 54
96663: PUSH
96664: EMPTY
96665: LIST
96666: PUSH
96667: EMPTY
96668: LIST
96669: LIST
96670: PUSH
96671: LD_INT 3
96673: PUSH
96674: LD_INT 24
96676: PUSH
96677: LD_INT 250
96679: PUSH
96680: EMPTY
96681: LIST
96682: LIST
96683: PUSH
96684: EMPTY
96685: LIST
96686: LIST
96687: PUSH
96688: EMPTY
96689: LIST
96690: LIST
96691: LIST
96692: PUSH
96693: EMPTY
96694: LIST
96695: LIST
96696: PPUSH
96697: CALL_OW 72
96701: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
96702: LD_ADDR_VAR 0 7
96706: PUSH
96707: LD_VAR 0 5
96711: PUSH
96712: LD_VAR 0 6
96716: DIFF
96717: ST_TO_ADDR
// if not need_heal_1 then
96718: LD_VAR 0 6
96722: NOT
96723: IFFALSE 96756
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
96725: LD_ADDR_EXP 181
96729: PUSH
96730: LD_EXP 181
96734: PPUSH
96735: LD_VAR 0 2
96739: PUSH
96740: LD_INT 1
96742: PUSH
96743: EMPTY
96744: LIST
96745: LIST
96746: PPUSH
96747: EMPTY
96748: PPUSH
96749: CALL 24363 0 3
96753: ST_TO_ADDR
96754: GO 96826
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
96756: LD_ADDR_EXP 181
96760: PUSH
96761: LD_EXP 181
96765: PPUSH
96766: LD_VAR 0 2
96770: PUSH
96771: LD_INT 1
96773: PUSH
96774: EMPTY
96775: LIST
96776: LIST
96777: PPUSH
96778: LD_EXP 181
96782: PUSH
96783: LD_VAR 0 2
96787: ARRAY
96788: PUSH
96789: LD_INT 1
96791: ARRAY
96792: PPUSH
96793: LD_INT 3
96795: PUSH
96796: LD_INT 24
96798: PUSH
96799: LD_INT 1000
96801: PUSH
96802: EMPTY
96803: LIST
96804: LIST
96805: PUSH
96806: EMPTY
96807: LIST
96808: LIST
96809: PPUSH
96810: CALL_OW 72
96814: PUSH
96815: LD_VAR 0 6
96819: UNION
96820: PPUSH
96821: CALL 24363 0 3
96825: ST_TO_ADDR
// if not need_heal_2 then
96826: LD_VAR 0 7
96830: NOT
96831: IFFALSE 96864
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
96833: LD_ADDR_EXP 181
96837: PUSH
96838: LD_EXP 181
96842: PPUSH
96843: LD_VAR 0 2
96847: PUSH
96848: LD_INT 2
96850: PUSH
96851: EMPTY
96852: LIST
96853: LIST
96854: PPUSH
96855: EMPTY
96856: PPUSH
96857: CALL 24363 0 3
96861: ST_TO_ADDR
96862: GO 96896
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
96864: LD_ADDR_EXP 181
96868: PUSH
96869: LD_EXP 181
96873: PPUSH
96874: LD_VAR 0 2
96878: PUSH
96879: LD_INT 2
96881: PUSH
96882: EMPTY
96883: LIST
96884: LIST
96885: PPUSH
96886: LD_VAR 0 7
96890: PPUSH
96891: CALL 24363 0 3
96895: ST_TO_ADDR
// if need_heal_2 then
96896: LD_VAR 0 7
96900: IFFALSE 97061
// for j in need_heal_2 do
96902: LD_ADDR_VAR 0 3
96906: PUSH
96907: LD_VAR 0 7
96911: PUSH
96912: FOR_IN
96913: IFFALSE 97059
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
96915: LD_ADDR_VAR 0 5
96919: PUSH
96920: LD_EXP 178
96924: PUSH
96925: LD_VAR 0 2
96929: ARRAY
96930: PPUSH
96931: LD_INT 2
96933: PUSH
96934: LD_INT 30
96936: PUSH
96937: LD_INT 6
96939: PUSH
96940: EMPTY
96941: LIST
96942: LIST
96943: PUSH
96944: LD_INT 30
96946: PUSH
96947: LD_INT 7
96949: PUSH
96950: EMPTY
96951: LIST
96952: LIST
96953: PUSH
96954: LD_INT 30
96956: PUSH
96957: LD_INT 8
96959: PUSH
96960: EMPTY
96961: LIST
96962: LIST
96963: PUSH
96964: LD_INT 30
96966: PUSH
96967: LD_INT 0
96969: PUSH
96970: EMPTY
96971: LIST
96972: LIST
96973: PUSH
96974: LD_INT 30
96976: PUSH
96977: LD_INT 1
96979: PUSH
96980: EMPTY
96981: LIST
96982: LIST
96983: PUSH
96984: EMPTY
96985: LIST
96986: LIST
96987: LIST
96988: LIST
96989: LIST
96990: LIST
96991: PPUSH
96992: CALL_OW 72
96996: ST_TO_ADDR
// if tmp then
96997: LD_VAR 0 5
97001: IFFALSE 97057
// begin k := NearestUnitToUnit ( tmp , j ) ;
97003: LD_ADDR_VAR 0 4
97007: PUSH
97008: LD_VAR 0 5
97012: PPUSH
97013: LD_VAR 0 3
97017: PPUSH
97018: CALL_OW 74
97022: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 5 then
97023: LD_VAR 0 3
97027: PPUSH
97028: LD_VAR 0 4
97032: PPUSH
97033: CALL_OW 296
97037: PUSH
97038: LD_INT 5
97040: GREATER
97041: IFFALSE 97057
// ComMoveToNearbyEntrance ( j , k ) ;
97043: LD_VAR 0 3
97047: PPUSH
97048: LD_VAR 0 4
97052: PPUSH
97053: CALL 57502 0 2
// end ; end ;
97057: GO 96912
97059: POP
97060: POP
// if not need_heal_1 and not need_heal_2 then
97061: LD_VAR 0 6
97065: NOT
97066: PUSH
97067: LD_VAR 0 7
97071: NOT
97072: AND
97073: IFFALSE 97077
// continue ;
97075: GO 96541
// end ;
97077: GO 96541
97079: POP
97080: POP
// RaiseSailEvent ( 102 ) ;
97081: LD_INT 102
97083: PPUSH
97084: CALL_OW 427
// end ;
97088: LD_VAR 0 1
97092: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes , to_repair_tmp , to_repair ; begin
97093: LD_INT 0
97095: PPUSH
97096: PPUSH
97097: PPUSH
97098: PPUSH
97099: PPUSH
97100: PPUSH
97101: PPUSH
97102: PPUSH
// if not mc_bases then
97103: LD_EXP 178
97107: NOT
97108: IFFALSE 97112
// exit ;
97110: GO 97995
// for i = 1 to mc_bases do
97112: LD_ADDR_VAR 0 2
97116: PUSH
97117: DOUBLE
97118: LD_INT 1
97120: DEC
97121: ST_TO_ADDR
97122: LD_EXP 178
97126: PUSH
97127: FOR_TO
97128: IFFALSE 97993
// begin if not mc_building_need_repair [ i ] then
97130: LD_EXP 179
97134: PUSH
97135: LD_VAR 0 2
97139: ARRAY
97140: NOT
97141: IFFALSE 97328
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ] ) ;
97143: LD_ADDR_VAR 0 6
97147: PUSH
97148: LD_EXP 197
97152: PUSH
97153: LD_VAR 0 2
97157: ARRAY
97158: PPUSH
97159: LD_INT 3
97161: PUSH
97162: LD_INT 24
97164: PUSH
97165: LD_INT 1000
97167: PUSH
97168: EMPTY
97169: LIST
97170: LIST
97171: PUSH
97172: EMPTY
97173: LIST
97174: LIST
97175: PUSH
97176: LD_INT 2
97178: PUSH
97179: LD_INT 34
97181: PUSH
97182: LD_INT 13
97184: PUSH
97185: EMPTY
97186: LIST
97187: LIST
97188: PUSH
97189: LD_INT 34
97191: PUSH
97192: LD_INT 52
97194: PUSH
97195: EMPTY
97196: LIST
97197: LIST
97198: PUSH
97199: LD_INT 34
97201: PUSH
97202: LD_EXP 164
97206: PUSH
97207: EMPTY
97208: LIST
97209: LIST
97210: PUSH
97211: EMPTY
97212: LIST
97213: LIST
97214: LIST
97215: LIST
97216: PUSH
97217: EMPTY
97218: LIST
97219: LIST
97220: PPUSH
97221: CALL_OW 72
97225: ST_TO_ADDR
// if cranes then
97226: LD_VAR 0 6
97230: IFFALSE 97292
// for j in cranes do
97232: LD_ADDR_VAR 0 3
97236: PUSH
97237: LD_VAR 0 6
97241: PUSH
97242: FOR_IN
97243: IFFALSE 97290
// if not IsInArea ( j , mc_parking [ i ] ) then
97245: LD_VAR 0 3
97249: PPUSH
97250: LD_EXP 202
97254: PUSH
97255: LD_VAR 0 2
97259: ARRAY
97260: PPUSH
97261: CALL_OW 308
97265: NOT
97266: IFFALSE 97288
// ComMoveToArea ( j , mc_parking [ i ] ) ;
97268: LD_VAR 0 3
97272: PPUSH
97273: LD_EXP 202
97277: PUSH
97278: LD_VAR 0 2
97282: ARRAY
97283: PPUSH
97284: CALL_OW 113
97288: GO 97242
97290: POP
97291: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
97292: LD_ADDR_EXP 180
97296: PUSH
97297: LD_EXP 180
97301: PPUSH
97302: LD_VAR 0 2
97306: PPUSH
97307: EMPTY
97308: PPUSH
97309: CALL_OW 1
97313: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
97314: LD_VAR 0 2
97318: PPUSH
97319: LD_INT 101
97321: PPUSH
97322: CALL 92180 0 2
// continue ;
97326: GO 97127
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
97328: LD_ADDR_EXP 184
97332: PUSH
97333: LD_EXP 184
97337: PPUSH
97338: LD_VAR 0 2
97342: PPUSH
97343: EMPTY
97344: PPUSH
97345: CALL_OW 1
97349: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
97350: LD_VAR 0 2
97354: PPUSH
97355: LD_INT 103
97357: PPUSH
97358: CALL 92180 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) ;
97362: LD_ADDR_VAR 0 5
97366: PUSH
97367: LD_EXP 178
97371: PUSH
97372: LD_VAR 0 2
97376: ARRAY
97377: PUSH
97378: LD_EXP 207
97382: PUSH
97383: LD_VAR 0 2
97387: ARRAY
97388: UNION
97389: PPUSH
97390: LD_INT 2
97392: PUSH
97393: LD_INT 25
97395: PUSH
97396: LD_INT 2
97398: PUSH
97399: EMPTY
97400: LIST
97401: LIST
97402: PUSH
97403: LD_INT 25
97405: PUSH
97406: LD_INT 16
97408: PUSH
97409: EMPTY
97410: LIST
97411: LIST
97412: PUSH
97413: EMPTY
97414: LIST
97415: LIST
97416: LIST
97417: PUSH
97418: EMPTY
97419: LIST
97420: PPUSH
97421: CALL_OW 72
97425: ST_TO_ADDR
// if mc_need_heal [ i ] then
97426: LD_EXP 181
97430: PUSH
97431: LD_VAR 0 2
97435: ARRAY
97436: IFFALSE 97480
// tmp := tmp diff ( mc_need_heal [ i ] [ 1 ] union mc_need_heal [ i ] [ 2 ] ) ;
97438: LD_ADDR_VAR 0 5
97442: PUSH
97443: LD_VAR 0 5
97447: PUSH
97448: LD_EXP 181
97452: PUSH
97453: LD_VAR 0 2
97457: ARRAY
97458: PUSH
97459: LD_INT 1
97461: ARRAY
97462: PUSH
97463: LD_EXP 181
97467: PUSH
97468: LD_VAR 0 2
97472: ARRAY
97473: PUSH
97474: LD_INT 2
97476: ARRAY
97477: UNION
97478: DIFF
97479: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ) ;
97480: LD_ADDR_VAR 0 6
97484: PUSH
97485: LD_EXP 197
97489: PUSH
97490: LD_VAR 0 2
97494: ARRAY
97495: PPUSH
97496: LD_INT 2
97498: PUSH
97499: LD_INT 34
97501: PUSH
97502: LD_INT 13
97504: PUSH
97505: EMPTY
97506: LIST
97507: LIST
97508: PUSH
97509: LD_INT 34
97511: PUSH
97512: LD_INT 52
97514: PUSH
97515: EMPTY
97516: LIST
97517: LIST
97518: PUSH
97519: LD_INT 34
97521: PUSH
97522: LD_EXP 164
97526: PUSH
97527: EMPTY
97528: LIST
97529: LIST
97530: PUSH
97531: EMPTY
97532: LIST
97533: LIST
97534: LIST
97535: LIST
97536: PPUSH
97537: CALL_OW 72
97541: ST_TO_ADDR
// if cranes then
97542: LD_VAR 0 6
97546: IFFALSE 97682
// begin for j in cranes do
97548: LD_ADDR_VAR 0 3
97552: PUSH
97553: LD_VAR 0 6
97557: PUSH
97558: FOR_IN
97559: IFFALSE 97680
// begin if GetLives ( j ) = 1000 and not HasTask ( j ) then
97561: LD_VAR 0 3
97565: PPUSH
97566: CALL_OW 256
97570: PUSH
97571: LD_INT 1000
97573: EQUAL
97574: PUSH
97575: LD_VAR 0 3
97579: PPUSH
97580: CALL_OW 314
97584: NOT
97585: AND
97586: IFFALSE 97620
// ComRepairBuilding ( j , NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ) else
97588: LD_VAR 0 3
97592: PPUSH
97593: LD_EXP 179
97597: PUSH
97598: LD_VAR 0 2
97602: ARRAY
97603: PPUSH
97604: LD_VAR 0 3
97608: PPUSH
97609: CALL_OW 74
97613: PPUSH
97614: CALL_OW 130
97618: GO 97678
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
97620: LD_VAR 0 3
97624: PPUSH
97625: CALL_OW 256
97629: PUSH
97630: LD_INT 500
97632: LESS
97633: PUSH
97634: LD_VAR 0 3
97638: PPUSH
97639: LD_EXP 202
97643: PUSH
97644: LD_VAR 0 2
97648: ARRAY
97649: PPUSH
97650: CALL_OW 308
97654: NOT
97655: AND
97656: IFFALSE 97678
// ComMoveToArea ( j , mc_parking [ i ] ) ;
97658: LD_VAR 0 3
97662: PPUSH
97663: LD_EXP 202
97667: PUSH
97668: LD_VAR 0 2
97672: ARRAY
97673: PPUSH
97674: CALL_OW 113
// end ;
97678: GO 97558
97680: POP
97681: POP
// end ; if tmp > 3 then
97682: LD_VAR 0 5
97686: PUSH
97687: LD_INT 3
97689: GREATER
97690: IFFALSE 97710
// tmp := ShrinkArray ( tmp , 4 ) ;
97692: LD_ADDR_VAR 0 5
97696: PUSH
97697: LD_VAR 0 5
97701: PPUSH
97702: LD_INT 4
97704: PPUSH
97705: CALL 56940 0 2
97709: ST_TO_ADDR
// if not tmp then
97710: LD_VAR 0 5
97714: NOT
97715: IFFALSE 97719
// continue ;
97717: GO 97127
// for j in tmp do
97719: LD_ADDR_VAR 0 3
97723: PUSH
97724: LD_VAR 0 5
97728: PUSH
97729: FOR_IN
97730: IFFALSE 97989
// begin if IsInUnit ( j ) then
97732: LD_VAR 0 3
97736: PPUSH
97737: CALL_OW 310
97741: IFFALSE 97752
// ComExitBuilding ( j ) ;
97743: LD_VAR 0 3
97747: PPUSH
97748: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
97752: LD_VAR 0 3
97756: PUSH
97757: LD_EXP 180
97761: PUSH
97762: LD_VAR 0 2
97766: ARRAY
97767: IN
97768: NOT
97769: IFFALSE 97827
// begin SetTag ( j , 101 ) ;
97771: LD_VAR 0 3
97775: PPUSH
97776: LD_INT 101
97778: PPUSH
97779: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
97783: LD_ADDR_EXP 180
97787: PUSH
97788: LD_EXP 180
97792: PPUSH
97793: LD_VAR 0 2
97797: PUSH
97798: LD_EXP 180
97802: PUSH
97803: LD_VAR 0 2
97807: ARRAY
97808: PUSH
97809: LD_INT 1
97811: PLUS
97812: PUSH
97813: EMPTY
97814: LIST
97815: LIST
97816: PPUSH
97817: LD_VAR 0 3
97821: PPUSH
97822: CALL 24363 0 3
97826: ST_TO_ADDR
// end ; wait ( 1 ) ;
97827: LD_INT 1
97829: PPUSH
97830: CALL_OW 67
// to_repair_tmp := mc_building_need_repair [ i ] ;
97834: LD_ADDR_VAR 0 7
97838: PUSH
97839: LD_EXP 179
97843: PUSH
97844: LD_VAR 0 2
97848: ARRAY
97849: ST_TO_ADDR
// if mc_scan [ i ] then
97850: LD_EXP 201
97854: PUSH
97855: LD_VAR 0 2
97859: ARRAY
97860: IFFALSE 97922
// to_repair_tmp := UnitFilter ( mc_building_need_repair [ i ] , [ f_not , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_breastwork ] ] ) ;
97862: LD_ADDR_VAR 0 7
97866: PUSH
97867: LD_EXP 179
97871: PUSH
97872: LD_VAR 0 2
97876: ARRAY
97877: PPUSH
97878: LD_INT 3
97880: PUSH
97881: LD_INT 30
97883: PUSH
97884: LD_INT 32
97886: PUSH
97887: EMPTY
97888: LIST
97889: LIST
97890: PUSH
97891: LD_INT 30
97893: PUSH
97894: LD_INT 33
97896: PUSH
97897: EMPTY
97898: LIST
97899: LIST
97900: PUSH
97901: LD_INT 30
97903: PUSH
97904: LD_INT 31
97906: PUSH
97907: EMPTY
97908: LIST
97909: LIST
97910: PUSH
97911: EMPTY
97912: LIST
97913: LIST
97914: LIST
97915: LIST
97916: PPUSH
97917: CALL_OW 72
97921: ST_TO_ADDR
// if not to_repair_tmp then
97922: LD_VAR 0 7
97926: NOT
97927: IFFALSE 97931
// continue ;
97929: GO 97729
// to_repair := NearestUnitToUnit ( to_repair_tmp , j ) ;
97931: LD_ADDR_VAR 0 8
97935: PUSH
97936: LD_VAR 0 7
97940: PPUSH
97941: LD_VAR 0 3
97945: PPUSH
97946: CALL_OW 74
97950: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 10 then
97951: LD_VAR 0 8
97955: PPUSH
97956: LD_INT 16
97958: PPUSH
97959: CALL 26962 0 2
97963: PUSH
97964: LD_INT 4
97966: ARRAY
97967: PUSH
97968: LD_INT 10
97970: LESS
97971: IFFALSE 97987
// ComRepairBuilding ( j , to_repair ) ;
97973: LD_VAR 0 3
97977: PPUSH
97978: LD_VAR 0 8
97982: PPUSH
97983: CALL_OW 130
// end ;
97987: GO 97729
97989: POP
97990: POP
// end ;
97991: GO 97127
97993: POP
97994: POP
// end ;
97995: LD_VAR 0 1
97999: RET
// export function MC_Heal ; var i , j , tmp ; begin
98000: LD_INT 0
98002: PPUSH
98003: PPUSH
98004: PPUSH
98005: PPUSH
// if not mc_bases then
98006: LD_EXP 178
98010: NOT
98011: IFFALSE 98015
// exit ;
98013: GO 98417
// for i = 1 to mc_bases do
98015: LD_ADDR_VAR 0 2
98019: PUSH
98020: DOUBLE
98021: LD_INT 1
98023: DEC
98024: ST_TO_ADDR
98025: LD_EXP 178
98029: PUSH
98030: FOR_TO
98031: IFFALSE 98415
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
98033: LD_EXP 181
98037: PUSH
98038: LD_VAR 0 2
98042: ARRAY
98043: PUSH
98044: LD_INT 1
98046: ARRAY
98047: NOT
98048: PUSH
98049: LD_EXP 181
98053: PUSH
98054: LD_VAR 0 2
98058: ARRAY
98059: PUSH
98060: LD_INT 2
98062: ARRAY
98063: NOT
98064: AND
98065: IFFALSE 98103
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
98067: LD_ADDR_EXP 182
98071: PUSH
98072: LD_EXP 182
98076: PPUSH
98077: LD_VAR 0 2
98081: PPUSH
98082: EMPTY
98083: PPUSH
98084: CALL_OW 1
98088: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
98089: LD_VAR 0 2
98093: PPUSH
98094: LD_INT 102
98096: PPUSH
98097: CALL 92180 0 2
// continue ;
98101: GO 98030
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
98103: LD_ADDR_VAR 0 4
98107: PUSH
98108: LD_EXP 178
98112: PUSH
98113: LD_VAR 0 2
98117: ARRAY
98118: PPUSH
98119: LD_INT 25
98121: PUSH
98122: LD_INT 4
98124: PUSH
98125: EMPTY
98126: LIST
98127: LIST
98128: PPUSH
98129: CALL_OW 72
98133: ST_TO_ADDR
// if not tmp then
98134: LD_VAR 0 4
98138: NOT
98139: IFFALSE 98143
// continue ;
98141: GO 98030
// if mc_taming [ i ] then
98143: LD_EXP 209
98147: PUSH
98148: LD_VAR 0 2
98152: ARRAY
98153: IFFALSE 98177
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
98155: LD_ADDR_EXP 209
98159: PUSH
98160: LD_EXP 209
98164: PPUSH
98165: LD_VAR 0 2
98169: PPUSH
98170: EMPTY
98171: PPUSH
98172: CALL_OW 1
98176: ST_TO_ADDR
// for j in tmp do
98177: LD_ADDR_VAR 0 3
98181: PUSH
98182: LD_VAR 0 4
98186: PUSH
98187: FOR_IN
98188: IFFALSE 98411
// begin if IsInUnit ( j ) then
98190: LD_VAR 0 3
98194: PPUSH
98195: CALL_OW 310
98199: IFFALSE 98210
// ComExitBuilding ( j ) ;
98201: LD_VAR 0 3
98205: PPUSH
98206: CALL_OW 122
// if not j in mc_healers [ i ] then
98210: LD_VAR 0 3
98214: PUSH
98215: LD_EXP 182
98219: PUSH
98220: LD_VAR 0 2
98224: ARRAY
98225: IN
98226: NOT
98227: IFFALSE 98273
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
98229: LD_ADDR_EXP 182
98233: PUSH
98234: LD_EXP 182
98238: PPUSH
98239: LD_VAR 0 2
98243: PUSH
98244: LD_EXP 182
98248: PUSH
98249: LD_VAR 0 2
98253: ARRAY
98254: PUSH
98255: LD_INT 1
98257: PLUS
98258: PUSH
98259: EMPTY
98260: LIST
98261: LIST
98262: PPUSH
98263: LD_VAR 0 3
98267: PPUSH
98268: CALL 24363 0 3
98272: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
98273: LD_VAR 0 3
98277: PPUSH
98278: CALL_OW 110
98282: PUSH
98283: LD_INT 102
98285: NONEQUAL
98286: IFFALSE 98300
// SetTag ( j , 102 ) ;
98288: LD_VAR 0 3
98292: PPUSH
98293: LD_INT 102
98295: PPUSH
98296: CALL_OW 109
// Wait ( 3 ) ;
98300: LD_INT 3
98302: PPUSH
98303: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
98307: LD_EXP 181
98311: PUSH
98312: LD_VAR 0 2
98316: ARRAY
98317: PUSH
98318: LD_INT 1
98320: ARRAY
98321: IFFALSE 98353
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
98323: LD_VAR 0 3
98327: PPUSH
98328: LD_EXP 181
98332: PUSH
98333: LD_VAR 0 2
98337: ARRAY
98338: PUSH
98339: LD_INT 1
98341: ARRAY
98342: PUSH
98343: LD_INT 1
98345: ARRAY
98346: PPUSH
98347: CALL_OW 128
98351: GO 98409
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
98353: LD_VAR 0 3
98357: PPUSH
98358: CALL_OW 314
98362: NOT
98363: PUSH
98364: LD_EXP 181
98368: PUSH
98369: LD_VAR 0 2
98373: ARRAY
98374: PUSH
98375: LD_INT 2
98377: ARRAY
98378: AND
98379: IFFALSE 98409
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
98381: LD_VAR 0 3
98385: PPUSH
98386: LD_EXP 181
98390: PUSH
98391: LD_VAR 0 2
98395: ARRAY
98396: PUSH
98397: LD_INT 2
98399: ARRAY
98400: PUSH
98401: LD_INT 1
98403: ARRAY
98404: PPUSH
98405: CALL_OW 128
// end ;
98409: GO 98187
98411: POP
98412: POP
// end ;
98413: GO 98030
98415: POP
98416: POP
// end ;
98417: LD_VAR 0 1
98421: RET
// export function MC_Build ( ) ; var i , j , tmp , depot ; begin
98422: LD_INT 0
98424: PPUSH
98425: PPUSH
98426: PPUSH
98427: PPUSH
98428: PPUSH
// if not mc_bases then
98429: LD_EXP 178
98433: NOT
98434: IFFALSE 98438
// exit ;
98436: GO 99609
// for i = 1 to mc_bases do
98438: LD_ADDR_VAR 0 2
98442: PUSH
98443: DOUBLE
98444: LD_INT 1
98446: DEC
98447: ST_TO_ADDR
98448: LD_EXP 178
98452: PUSH
98453: FOR_TO
98454: IFFALSE 99607
// begin if mc_scan [ i ] then
98456: LD_EXP 201
98460: PUSH
98461: LD_VAR 0 2
98465: ARRAY
98466: IFFALSE 98470
// continue ;
98468: GO 98453
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
98470: LD_EXP 183
98474: PUSH
98475: LD_VAR 0 2
98479: ARRAY
98480: NOT
98481: PUSH
98482: LD_EXP 185
98486: PUSH
98487: LD_VAR 0 2
98491: ARRAY
98492: NOT
98493: AND
98494: PUSH
98495: LD_EXP 184
98499: PUSH
98500: LD_VAR 0 2
98504: ARRAY
98505: AND
98506: IFFALSE 98544
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
98508: LD_ADDR_EXP 184
98512: PUSH
98513: LD_EXP 184
98517: PPUSH
98518: LD_VAR 0 2
98522: PPUSH
98523: EMPTY
98524: PPUSH
98525: CALL_OW 1
98529: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
98530: LD_VAR 0 2
98534: PPUSH
98535: LD_INT 103
98537: PPUSH
98538: CALL 92180 0 2
// continue ;
98542: GO 98453
// end ; if mc_construct_list [ i ] then
98544: LD_EXP 185
98548: PUSH
98549: LD_VAR 0 2
98553: ARRAY
98554: IFFALSE 98774
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
98556: LD_ADDR_VAR 0 4
98560: PUSH
98561: LD_EXP 178
98565: PUSH
98566: LD_VAR 0 2
98570: ARRAY
98571: PPUSH
98572: LD_INT 25
98574: PUSH
98575: LD_INT 2
98577: PUSH
98578: EMPTY
98579: LIST
98580: LIST
98581: PPUSH
98582: CALL_OW 72
98586: PUSH
98587: LD_EXP 180
98591: PUSH
98592: LD_VAR 0 2
98596: ARRAY
98597: DIFF
98598: ST_TO_ADDR
// if not tmp then
98599: LD_VAR 0 4
98603: NOT
98604: IFFALSE 98608
// continue ;
98606: GO 98453
// for j in tmp do
98608: LD_ADDR_VAR 0 3
98612: PUSH
98613: LD_VAR 0 4
98617: PUSH
98618: FOR_IN
98619: IFFALSE 98770
// begin if not mc_builders [ i ] then
98621: LD_EXP 184
98625: PUSH
98626: LD_VAR 0 2
98630: ARRAY
98631: NOT
98632: IFFALSE 98690
// begin SetTag ( j , 103 ) ;
98634: LD_VAR 0 3
98638: PPUSH
98639: LD_INT 103
98641: PPUSH
98642: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
98646: LD_ADDR_EXP 184
98650: PUSH
98651: LD_EXP 184
98655: PPUSH
98656: LD_VAR 0 2
98660: PUSH
98661: LD_EXP 184
98665: PUSH
98666: LD_VAR 0 2
98670: ARRAY
98671: PUSH
98672: LD_INT 1
98674: PLUS
98675: PUSH
98676: EMPTY
98677: LIST
98678: LIST
98679: PPUSH
98680: LD_VAR 0 3
98684: PPUSH
98685: CALL 24363 0 3
98689: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
98690: LD_VAR 0 3
98694: PPUSH
98695: CALL_OW 310
98699: IFFALSE 98710
// ComExitBuilding ( j ) ;
98701: LD_VAR 0 3
98705: PPUSH
98706: CALL_OW 122
// wait ( 3 ) ;
98710: LD_INT 3
98712: PPUSH
98713: CALL_OW 67
// if not mc_construct_list [ i ] then
98717: LD_EXP 185
98721: PUSH
98722: LD_VAR 0 2
98726: ARRAY
98727: NOT
98728: IFFALSE 98732
// break ;
98730: GO 98770
// if not HasTask ( j ) then
98732: LD_VAR 0 3
98736: PPUSH
98737: CALL_OW 314
98741: NOT
98742: IFFALSE 98768
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
98744: LD_VAR 0 3
98748: PPUSH
98749: LD_EXP 185
98753: PUSH
98754: LD_VAR 0 2
98758: ARRAY
98759: PUSH
98760: LD_INT 1
98762: ARRAY
98763: PPUSH
98764: CALL 27226 0 2
// end ;
98768: GO 98618
98770: POP
98771: POP
// end else
98772: GO 99605
// if mc_build_list [ i ] then
98774: LD_EXP 183
98778: PUSH
98779: LD_VAR 0 2
98783: ARRAY
98784: IFFALSE 99605
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
98786: LD_ADDR_VAR 0 5
98790: PUSH
98791: LD_EXP 178
98795: PUSH
98796: LD_VAR 0 2
98800: ARRAY
98801: PPUSH
98802: LD_INT 2
98804: PUSH
98805: LD_INT 30
98807: PUSH
98808: LD_INT 0
98810: PUSH
98811: EMPTY
98812: LIST
98813: LIST
98814: PUSH
98815: LD_INT 30
98817: PUSH
98818: LD_INT 1
98820: PUSH
98821: EMPTY
98822: LIST
98823: LIST
98824: PUSH
98825: EMPTY
98826: LIST
98827: LIST
98828: LIST
98829: PPUSH
98830: CALL_OW 72
98834: ST_TO_ADDR
// if depot then
98835: LD_VAR 0 5
98839: IFFALSE 98857
// depot := depot [ 1 ] else
98841: LD_ADDR_VAR 0 5
98845: PUSH
98846: LD_VAR 0 5
98850: PUSH
98851: LD_INT 1
98853: ARRAY
98854: ST_TO_ADDR
98855: GO 98865
// depot := 0 ;
98857: LD_ADDR_VAR 0 5
98861: PUSH
98862: LD_INT 0
98864: ST_TO_ADDR
// if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
98865: LD_EXP 183
98869: PUSH
98870: LD_VAR 0 2
98874: ARRAY
98875: PUSH
98876: LD_INT 1
98878: ARRAY
98879: PUSH
98880: LD_INT 1
98882: ARRAY
98883: PPUSH
98884: CALL 27050 0 1
98888: PUSH
98889: LD_EXP 178
98893: PUSH
98894: LD_VAR 0 2
98898: ARRAY
98899: PPUSH
98900: LD_INT 2
98902: PUSH
98903: LD_INT 30
98905: PUSH
98906: LD_INT 2
98908: PUSH
98909: EMPTY
98910: LIST
98911: LIST
98912: PUSH
98913: LD_INT 30
98915: PUSH
98916: LD_INT 3
98918: PUSH
98919: EMPTY
98920: LIST
98921: LIST
98922: PUSH
98923: EMPTY
98924: LIST
98925: LIST
98926: LIST
98927: PPUSH
98928: CALL_OW 72
98932: NOT
98933: AND
98934: IFFALSE 99039
// begin for j = 1 to mc_build_list [ i ] do
98936: LD_ADDR_VAR 0 3
98940: PUSH
98941: DOUBLE
98942: LD_INT 1
98944: DEC
98945: ST_TO_ADDR
98946: LD_EXP 183
98950: PUSH
98951: LD_VAR 0 2
98955: ARRAY
98956: PUSH
98957: FOR_TO
98958: IFFALSE 99037
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
98960: LD_EXP 183
98964: PUSH
98965: LD_VAR 0 2
98969: ARRAY
98970: PUSH
98971: LD_VAR 0 3
98975: ARRAY
98976: PUSH
98977: LD_INT 1
98979: ARRAY
98980: PUSH
98981: LD_INT 2
98983: EQUAL
98984: IFFALSE 99035
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
98986: LD_ADDR_EXP 183
98990: PUSH
98991: LD_EXP 183
98995: PPUSH
98996: LD_VAR 0 2
99000: PPUSH
99001: LD_EXP 183
99005: PUSH
99006: LD_VAR 0 2
99010: ARRAY
99011: PPUSH
99012: LD_VAR 0 3
99016: PPUSH
99017: LD_INT 1
99019: PPUSH
99020: LD_INT 0
99022: PPUSH
99023: CALL 23781 0 4
99027: PPUSH
99028: CALL_OW 1
99032: ST_TO_ADDR
// break ;
99033: GO 99037
// end ;
99035: GO 98957
99037: POP
99038: POP
// end ; if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or ( depot and CanBeBuilt ( depot , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ) then
99039: LD_EXP 183
99043: PUSH
99044: LD_VAR 0 2
99048: ARRAY
99049: PUSH
99050: LD_INT 1
99052: ARRAY
99053: PUSH
99054: LD_INT 1
99056: ARRAY
99057: PUSH
99058: LD_INT 0
99060: EQUAL
99061: PUSH
99062: LD_VAR 0 5
99066: PUSH
99067: LD_VAR 0 5
99071: PPUSH
99072: LD_EXP 183
99076: PUSH
99077: LD_VAR 0 2
99081: ARRAY
99082: PUSH
99083: LD_INT 1
99085: ARRAY
99086: PUSH
99087: LD_INT 1
99089: ARRAY
99090: PPUSH
99091: LD_EXP 183
99095: PUSH
99096: LD_VAR 0 2
99100: ARRAY
99101: PUSH
99102: LD_INT 1
99104: ARRAY
99105: PUSH
99106: LD_INT 2
99108: ARRAY
99109: PPUSH
99110: LD_EXP 183
99114: PUSH
99115: LD_VAR 0 2
99119: ARRAY
99120: PUSH
99121: LD_INT 1
99123: ARRAY
99124: PUSH
99125: LD_INT 3
99127: ARRAY
99128: PPUSH
99129: LD_EXP 183
99133: PUSH
99134: LD_VAR 0 2
99138: ARRAY
99139: PUSH
99140: LD_INT 1
99142: ARRAY
99143: PUSH
99144: LD_INT 4
99146: ARRAY
99147: PPUSH
99148: CALL 32466 0 5
99152: AND
99153: OR
99154: IFFALSE 99435
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
99156: LD_ADDR_VAR 0 4
99160: PUSH
99161: LD_EXP 178
99165: PUSH
99166: LD_VAR 0 2
99170: ARRAY
99171: PPUSH
99172: LD_INT 25
99174: PUSH
99175: LD_INT 2
99177: PUSH
99178: EMPTY
99179: LIST
99180: LIST
99181: PPUSH
99182: CALL_OW 72
99186: PUSH
99187: LD_EXP 180
99191: PUSH
99192: LD_VAR 0 2
99196: ARRAY
99197: DIFF
99198: ST_TO_ADDR
// if not tmp then
99199: LD_VAR 0 4
99203: NOT
99204: IFFALSE 99208
// continue ;
99206: GO 98453
// for j in tmp do
99208: LD_ADDR_VAR 0 3
99212: PUSH
99213: LD_VAR 0 4
99217: PUSH
99218: FOR_IN
99219: IFFALSE 99431
// begin if not mc_builders [ i ] then
99221: LD_EXP 184
99225: PUSH
99226: LD_VAR 0 2
99230: ARRAY
99231: NOT
99232: IFFALSE 99290
// begin SetTag ( j , 103 ) ;
99234: LD_VAR 0 3
99238: PPUSH
99239: LD_INT 103
99241: PPUSH
99242: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
99246: LD_ADDR_EXP 184
99250: PUSH
99251: LD_EXP 184
99255: PPUSH
99256: LD_VAR 0 2
99260: PUSH
99261: LD_EXP 184
99265: PUSH
99266: LD_VAR 0 2
99270: ARRAY
99271: PUSH
99272: LD_INT 1
99274: PLUS
99275: PUSH
99276: EMPTY
99277: LIST
99278: LIST
99279: PPUSH
99280: LD_VAR 0 3
99284: PPUSH
99285: CALL 24363 0 3
99289: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
99290: LD_VAR 0 3
99294: PPUSH
99295: CALL_OW 310
99299: IFFALSE 99310
// ComExitBuilding ( j ) ;
99301: LD_VAR 0 3
99305: PPUSH
99306: CALL_OW 122
// wait ( 3 ) ;
99310: LD_INT 3
99312: PPUSH
99313: CALL_OW 67
// if not mc_build_list [ i ] then
99317: LD_EXP 183
99321: PUSH
99322: LD_VAR 0 2
99326: ARRAY
99327: NOT
99328: IFFALSE 99332
// break ;
99330: GO 99431
// if not HasTask ( j ) then
99332: LD_VAR 0 3
99336: PPUSH
99337: CALL_OW 314
99341: NOT
99342: IFFALSE 99429
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
99344: LD_VAR 0 3
99348: PPUSH
99349: LD_EXP 183
99353: PUSH
99354: LD_VAR 0 2
99358: ARRAY
99359: PUSH
99360: LD_INT 1
99362: ARRAY
99363: PUSH
99364: LD_INT 1
99366: ARRAY
99367: PPUSH
99368: LD_EXP 183
99372: PUSH
99373: LD_VAR 0 2
99377: ARRAY
99378: PUSH
99379: LD_INT 1
99381: ARRAY
99382: PUSH
99383: LD_INT 2
99385: ARRAY
99386: PPUSH
99387: LD_EXP 183
99391: PUSH
99392: LD_VAR 0 2
99396: ARRAY
99397: PUSH
99398: LD_INT 1
99400: ARRAY
99401: PUSH
99402: LD_INT 3
99404: ARRAY
99405: PPUSH
99406: LD_EXP 183
99410: PUSH
99411: LD_VAR 0 2
99415: ARRAY
99416: PUSH
99417: LD_INT 1
99419: ARRAY
99420: PUSH
99421: LD_INT 4
99423: ARRAY
99424: PPUSH
99425: CALL_OW 145
// end ;
99429: GO 99218
99431: POP
99432: POP
// end else
99433: GO 99605
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] , UnitFilter ( mc_bases [ i ] , [ f_type , unit_building ] ) , [ ] ) then
99435: LD_EXP 178
99439: PUSH
99440: LD_VAR 0 2
99444: ARRAY
99445: PPUSH
99446: LD_EXP 183
99450: PUSH
99451: LD_VAR 0 2
99455: ARRAY
99456: PUSH
99457: LD_INT 1
99459: ARRAY
99460: PUSH
99461: LD_INT 1
99463: ARRAY
99464: PPUSH
99465: LD_EXP 183
99469: PUSH
99470: LD_VAR 0 2
99474: ARRAY
99475: PUSH
99476: LD_INT 1
99478: ARRAY
99479: PUSH
99480: LD_INT 2
99482: ARRAY
99483: PPUSH
99484: LD_EXP 183
99488: PUSH
99489: LD_VAR 0 2
99493: ARRAY
99494: PUSH
99495: LD_INT 1
99497: ARRAY
99498: PUSH
99499: LD_INT 3
99501: ARRAY
99502: PPUSH
99503: LD_EXP 183
99507: PUSH
99508: LD_VAR 0 2
99512: ARRAY
99513: PUSH
99514: LD_INT 1
99516: ARRAY
99517: PUSH
99518: LD_INT 4
99520: ARRAY
99521: PPUSH
99522: LD_EXP 178
99526: PUSH
99527: LD_VAR 0 2
99531: ARRAY
99532: PPUSH
99533: LD_INT 21
99535: PUSH
99536: LD_INT 3
99538: PUSH
99539: EMPTY
99540: LIST
99541: LIST
99542: PPUSH
99543: CALL_OW 72
99547: PPUSH
99548: EMPTY
99549: PPUSH
99550: CALL 31216 0 7
99554: NOT
99555: IFFALSE 99605
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
99557: LD_ADDR_EXP 183
99561: PUSH
99562: LD_EXP 183
99566: PPUSH
99567: LD_VAR 0 2
99571: PPUSH
99572: LD_EXP 183
99576: PUSH
99577: LD_VAR 0 2
99581: ARRAY
99582: PPUSH
99583: LD_INT 1
99585: PPUSH
99586: LD_INT 1
99588: NEG
99589: PPUSH
99590: LD_INT 0
99592: PPUSH
99593: CALL 23781 0 4
99597: PPUSH
99598: CALL_OW 1
99602: ST_TO_ADDR
// continue ;
99603: GO 98453
// end ; end ; end ;
99605: GO 98453
99607: POP
99608: POP
// end ;
99609: LD_VAR 0 1
99613: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
99614: LD_INT 0
99616: PPUSH
99617: PPUSH
99618: PPUSH
99619: PPUSH
99620: PPUSH
99621: PPUSH
// if not mc_bases then
99622: LD_EXP 178
99626: NOT
99627: IFFALSE 99631
// exit ;
99629: GO 100058
// for i = 1 to mc_bases do
99631: LD_ADDR_VAR 0 2
99635: PUSH
99636: DOUBLE
99637: LD_INT 1
99639: DEC
99640: ST_TO_ADDR
99641: LD_EXP 178
99645: PUSH
99646: FOR_TO
99647: IFFALSE 100056
// begin tmp := mc_build_upgrade [ i ] ;
99649: LD_ADDR_VAR 0 4
99653: PUSH
99654: LD_EXP 210
99658: PUSH
99659: LD_VAR 0 2
99663: ARRAY
99664: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
99665: LD_ADDR_VAR 0 6
99669: PUSH
99670: LD_EXP 211
99674: PUSH
99675: LD_VAR 0 2
99679: ARRAY
99680: PPUSH
99681: LD_INT 2
99683: PUSH
99684: LD_INT 30
99686: PUSH
99687: LD_INT 6
99689: PUSH
99690: EMPTY
99691: LIST
99692: LIST
99693: PUSH
99694: LD_INT 30
99696: PUSH
99697: LD_INT 7
99699: PUSH
99700: EMPTY
99701: LIST
99702: LIST
99703: PUSH
99704: EMPTY
99705: LIST
99706: LIST
99707: LIST
99708: PPUSH
99709: CALL_OW 72
99713: ST_TO_ADDR
// if not tmp and not lab then
99714: LD_VAR 0 4
99718: NOT
99719: PUSH
99720: LD_VAR 0 6
99724: NOT
99725: AND
99726: IFFALSE 99730
// continue ;
99728: GO 99646
// if tmp then
99730: LD_VAR 0 4
99734: IFFALSE 99854
// for j in tmp do
99736: LD_ADDR_VAR 0 3
99740: PUSH
99741: LD_VAR 0 4
99745: PUSH
99746: FOR_IN
99747: IFFALSE 99852
// begin if UpgradeCost ( j ) then
99749: LD_VAR 0 3
99753: PPUSH
99754: CALL 30876 0 1
99758: IFFALSE 99850
// begin ComUpgrade ( j ) ;
99760: LD_VAR 0 3
99764: PPUSH
99765: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
99769: LD_ADDR_EXP 210
99773: PUSH
99774: LD_EXP 210
99778: PPUSH
99779: LD_VAR 0 2
99783: PPUSH
99784: LD_EXP 210
99788: PUSH
99789: LD_VAR 0 2
99793: ARRAY
99794: PUSH
99795: LD_VAR 0 3
99799: DIFF
99800: PPUSH
99801: CALL_OW 1
99805: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
99806: LD_ADDR_EXP 185
99810: PUSH
99811: LD_EXP 185
99815: PPUSH
99816: LD_VAR 0 2
99820: PUSH
99821: LD_EXP 185
99825: PUSH
99826: LD_VAR 0 2
99830: ARRAY
99831: PUSH
99832: LD_INT 1
99834: PLUS
99835: PUSH
99836: EMPTY
99837: LIST
99838: LIST
99839: PPUSH
99840: LD_VAR 0 3
99844: PPUSH
99845: CALL 24363 0 3
99849: ST_TO_ADDR
// end ; end ;
99850: GO 99746
99852: POP
99853: POP
// if not lab or not mc_lab_upgrade [ i ] then
99854: LD_VAR 0 6
99858: NOT
99859: PUSH
99860: LD_EXP 212
99864: PUSH
99865: LD_VAR 0 2
99869: ARRAY
99870: NOT
99871: OR
99872: IFFALSE 99876
// continue ;
99874: GO 99646
// for j in lab do
99876: LD_ADDR_VAR 0 3
99880: PUSH
99881: LD_VAR 0 6
99885: PUSH
99886: FOR_IN
99887: IFFALSE 100052
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
99889: LD_VAR 0 3
99893: PPUSH
99894: CALL_OW 266
99898: PUSH
99899: LD_INT 6
99901: PUSH
99902: LD_INT 7
99904: PUSH
99905: EMPTY
99906: LIST
99907: LIST
99908: IN
99909: PUSH
99910: LD_VAR 0 3
99914: PPUSH
99915: CALL_OW 461
99919: PUSH
99920: LD_INT 1
99922: NONEQUAL
99923: AND
99924: IFFALSE 100050
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
99926: LD_VAR 0 3
99930: PPUSH
99931: LD_EXP 212
99935: PUSH
99936: LD_VAR 0 2
99940: ARRAY
99941: PUSH
99942: LD_INT 1
99944: ARRAY
99945: PPUSH
99946: CALL 31081 0 2
99950: IFFALSE 100050
// begin ComCancel ( j ) ;
99952: LD_VAR 0 3
99956: PPUSH
99957: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
99961: LD_VAR 0 3
99965: PPUSH
99966: LD_EXP 212
99970: PUSH
99971: LD_VAR 0 2
99975: ARRAY
99976: PUSH
99977: LD_INT 1
99979: ARRAY
99980: PPUSH
99981: CALL_OW 207
// if not j in mc_construct_list [ i ] then
99985: LD_VAR 0 3
99989: PUSH
99990: LD_EXP 185
99994: PUSH
99995: LD_VAR 0 2
99999: ARRAY
100000: IN
100001: NOT
100002: IFFALSE 100048
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
100004: LD_ADDR_EXP 185
100008: PUSH
100009: LD_EXP 185
100013: PPUSH
100014: LD_VAR 0 2
100018: PUSH
100019: LD_EXP 185
100023: PUSH
100024: LD_VAR 0 2
100028: ARRAY
100029: PUSH
100030: LD_INT 1
100032: PLUS
100033: PUSH
100034: EMPTY
100035: LIST
100036: LIST
100037: PPUSH
100038: LD_VAR 0 3
100042: PPUSH
100043: CALL 24363 0 3
100047: ST_TO_ADDR
// break ;
100048: GO 100052
// end ; end ; end ;
100050: GO 99886
100052: POP
100053: POP
// end ;
100054: GO 99646
100056: POP
100057: POP
// end ;
100058: LD_VAR 0 1
100062: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
100063: LD_INT 0
100065: PPUSH
100066: PPUSH
100067: PPUSH
100068: PPUSH
100069: PPUSH
100070: PPUSH
100071: PPUSH
100072: PPUSH
100073: PPUSH
// if not mc_bases then
100074: LD_EXP 178
100078: NOT
100079: IFFALSE 100083
// exit ;
100081: GO 100488
// for i = 1 to mc_bases do
100083: LD_ADDR_VAR 0 2
100087: PUSH
100088: DOUBLE
100089: LD_INT 1
100091: DEC
100092: ST_TO_ADDR
100093: LD_EXP 178
100097: PUSH
100098: FOR_TO
100099: IFFALSE 100486
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
100101: LD_EXP 186
100105: PUSH
100106: LD_VAR 0 2
100110: ARRAY
100111: NOT
100112: PUSH
100113: LD_EXP 178
100117: PUSH
100118: LD_VAR 0 2
100122: ARRAY
100123: PPUSH
100124: LD_INT 30
100126: PUSH
100127: LD_INT 3
100129: PUSH
100130: EMPTY
100131: LIST
100132: LIST
100133: PPUSH
100134: CALL_OW 72
100138: NOT
100139: OR
100140: IFFALSE 100144
// continue ;
100142: GO 100098
// busy := false ;
100144: LD_ADDR_VAR 0 8
100148: PUSH
100149: LD_INT 0
100151: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
100152: LD_ADDR_VAR 0 4
100156: PUSH
100157: LD_EXP 178
100161: PUSH
100162: LD_VAR 0 2
100166: ARRAY
100167: PPUSH
100168: LD_INT 30
100170: PUSH
100171: LD_INT 3
100173: PUSH
100174: EMPTY
100175: LIST
100176: LIST
100177: PPUSH
100178: CALL_OW 72
100182: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
100183: LD_ADDR_VAR 0 6
100187: PUSH
100188: LD_EXP 186
100192: PUSH
100193: LD_VAR 0 2
100197: ARRAY
100198: PPUSH
100199: LD_INT 2
100201: PUSH
100202: LD_INT 30
100204: PUSH
100205: LD_INT 32
100207: PUSH
100208: EMPTY
100209: LIST
100210: LIST
100211: PUSH
100212: LD_INT 30
100214: PUSH
100215: LD_INT 33
100217: PUSH
100218: EMPTY
100219: LIST
100220: LIST
100221: PUSH
100222: EMPTY
100223: LIST
100224: LIST
100225: LIST
100226: PPUSH
100227: CALL_OW 72
100231: ST_TO_ADDR
// if not t then
100232: LD_VAR 0 6
100236: NOT
100237: IFFALSE 100241
// continue ;
100239: GO 100098
// for j in tmp do
100241: LD_ADDR_VAR 0 3
100245: PUSH
100246: LD_VAR 0 4
100250: PUSH
100251: FOR_IN
100252: IFFALSE 100282
// if not BuildingStatus ( j ) = bs_idle then
100254: LD_VAR 0 3
100258: PPUSH
100259: CALL_OW 461
100263: PUSH
100264: LD_INT 2
100266: EQUAL
100267: NOT
100268: IFFALSE 100280
// begin busy := true ;
100270: LD_ADDR_VAR 0 8
100274: PUSH
100275: LD_INT 1
100277: ST_TO_ADDR
// break ;
100278: GO 100282
// end ;
100280: GO 100251
100282: POP
100283: POP
// if busy then
100284: LD_VAR 0 8
100288: IFFALSE 100292
// continue ;
100290: GO 100098
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
100292: LD_ADDR_VAR 0 7
100296: PUSH
100297: LD_VAR 0 6
100301: PPUSH
100302: LD_INT 35
100304: PUSH
100305: LD_INT 0
100307: PUSH
100308: EMPTY
100309: LIST
100310: LIST
100311: PPUSH
100312: CALL_OW 72
100316: ST_TO_ADDR
// if tw then
100317: LD_VAR 0 7
100321: IFFALSE 100398
// begin tw := tw [ 1 ] ;
100323: LD_ADDR_VAR 0 7
100327: PUSH
100328: LD_VAR 0 7
100332: PUSH
100333: LD_INT 1
100335: ARRAY
100336: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
100337: LD_ADDR_VAR 0 9
100341: PUSH
100342: LD_VAR 0 7
100346: PPUSH
100347: LD_EXP 203
100351: PUSH
100352: LD_VAR 0 2
100356: ARRAY
100357: PPUSH
100358: CALL 29373 0 2
100362: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
100363: LD_EXP 217
100367: PUSH
100368: LD_VAR 0 2
100372: ARRAY
100373: IFFALSE 100396
// if not weapon in mc_allowed_tower_weapons [ i ] then
100375: LD_VAR 0 9
100379: PUSH
100380: LD_EXP 217
100384: PUSH
100385: LD_VAR 0 2
100389: ARRAY
100390: IN
100391: NOT
100392: IFFALSE 100396
// continue ;
100394: GO 100098
// end else
100396: GO 100461
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
100398: LD_ADDR_VAR 0 5
100402: PUSH
100403: LD_EXP 186
100407: PUSH
100408: LD_VAR 0 2
100412: ARRAY
100413: PPUSH
100414: LD_VAR 0 4
100418: PPUSH
100419: CALL 56173 0 2
100423: ST_TO_ADDR
// if not tmp2 then
100424: LD_VAR 0 5
100428: NOT
100429: IFFALSE 100433
// continue ;
100431: GO 100098
// tw := tmp2 [ 1 ] ;
100433: LD_ADDR_VAR 0 7
100437: PUSH
100438: LD_VAR 0 5
100442: PUSH
100443: LD_INT 1
100445: ARRAY
100446: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
100447: LD_ADDR_VAR 0 9
100451: PUSH
100452: LD_VAR 0 5
100456: PUSH
100457: LD_INT 2
100459: ARRAY
100460: ST_TO_ADDR
// end ; if not weapon then
100461: LD_VAR 0 9
100465: NOT
100466: IFFALSE 100470
// continue ;
100468: GO 100098
// ComPlaceWeapon ( tw , weapon ) ;
100470: LD_VAR 0 7
100474: PPUSH
100475: LD_VAR 0 9
100479: PPUSH
100480: CALL_OW 148
// end ;
100484: GO 100098
100486: POP
100487: POP
// end ;
100488: LD_VAR 0 1
100492: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list , r ; begin
100493: LD_INT 0
100495: PPUSH
100496: PPUSH
100497: PPUSH
100498: PPUSH
100499: PPUSH
100500: PPUSH
100501: PPUSH
// if not mc_bases then
100502: LD_EXP 178
100506: NOT
100507: IFFALSE 100511
// exit ;
100509: GO 101279
// for i = 1 to mc_bases do
100511: LD_ADDR_VAR 0 2
100515: PUSH
100516: DOUBLE
100517: LD_INT 1
100519: DEC
100520: ST_TO_ADDR
100521: LD_EXP 178
100525: PUSH
100526: FOR_TO
100527: IFFALSE 101277
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] or mc_scan [ i ] then
100529: LD_EXP 191
100533: PUSH
100534: LD_VAR 0 2
100538: ARRAY
100539: NOT
100540: PUSH
100541: LD_EXP 191
100545: PUSH
100546: LD_VAR 0 2
100550: ARRAY
100551: PUSH
100552: LD_EXP 192
100556: PUSH
100557: LD_VAR 0 2
100561: ARRAY
100562: EQUAL
100563: OR
100564: PUSH
100565: LD_EXP 201
100569: PUSH
100570: LD_VAR 0 2
100574: ARRAY
100575: OR
100576: IFFALSE 100580
// continue ;
100578: GO 100526
// if mc_miners [ i ] then
100580: LD_EXP 192
100584: PUSH
100585: LD_VAR 0 2
100589: ARRAY
100590: IFFALSE 100964
// begin for j = mc_miners [ i ] downto 1 do
100592: LD_ADDR_VAR 0 3
100596: PUSH
100597: DOUBLE
100598: LD_EXP 192
100602: PUSH
100603: LD_VAR 0 2
100607: ARRAY
100608: INC
100609: ST_TO_ADDR
100610: LD_INT 1
100612: PUSH
100613: FOR_DOWNTO
100614: IFFALSE 100962
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
100616: LD_EXP 192
100620: PUSH
100621: LD_VAR 0 2
100625: ARRAY
100626: PUSH
100627: LD_VAR 0 3
100631: ARRAY
100632: PPUSH
100633: CALL_OW 301
100637: PUSH
100638: LD_EXP 192
100642: PUSH
100643: LD_VAR 0 2
100647: ARRAY
100648: PUSH
100649: LD_VAR 0 3
100653: ARRAY
100654: PPUSH
100655: CALL_OW 257
100659: PUSH
100660: LD_INT 1
100662: NONEQUAL
100663: OR
100664: IFFALSE 100727
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
100666: LD_ADDR_VAR 0 5
100670: PUSH
100671: LD_EXP 192
100675: PUSH
100676: LD_VAR 0 2
100680: ARRAY
100681: PUSH
100682: LD_EXP 192
100686: PUSH
100687: LD_VAR 0 2
100691: ARRAY
100692: PUSH
100693: LD_VAR 0 3
100697: ARRAY
100698: DIFF
100699: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
100700: LD_ADDR_EXP 192
100704: PUSH
100705: LD_EXP 192
100709: PPUSH
100710: LD_VAR 0 2
100714: PPUSH
100715: LD_VAR 0 5
100719: PPUSH
100720: CALL_OW 1
100724: ST_TO_ADDR
// continue ;
100725: GO 100613
// end ; if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and not HasTask ( mc_miners [ i ] [ j ] ) then
100727: LD_EXP 192
100731: PUSH
100732: LD_VAR 0 2
100736: ARRAY
100737: PUSH
100738: LD_VAR 0 3
100742: ARRAY
100743: PPUSH
100744: CALL_OW 257
100748: PUSH
100749: LD_INT 1
100751: EQUAL
100752: PUSH
100753: LD_EXP 192
100757: PUSH
100758: LD_VAR 0 2
100762: ARRAY
100763: PUSH
100764: LD_VAR 0 3
100768: ARRAY
100769: PPUSH
100770: CALL_OW 459
100774: NOT
100775: AND
100776: PUSH
100777: LD_EXP 192
100781: PUSH
100782: LD_VAR 0 2
100786: ARRAY
100787: PUSH
100788: LD_VAR 0 3
100792: ARRAY
100793: PPUSH
100794: CALL_OW 314
100798: NOT
100799: AND
100800: IFFALSE 100960
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
100802: LD_EXP 192
100806: PUSH
100807: LD_VAR 0 2
100811: ARRAY
100812: PUSH
100813: LD_VAR 0 3
100817: ARRAY
100818: PPUSH
100819: CALL_OW 310
100823: IFFALSE 100846
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
100825: LD_EXP 192
100829: PUSH
100830: LD_VAR 0 2
100834: ARRAY
100835: PUSH
100836: LD_VAR 0 3
100840: ARRAY
100841: PPUSH
100842: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
100846: LD_EXP 192
100850: PUSH
100851: LD_VAR 0 2
100855: ARRAY
100856: PUSH
100857: LD_VAR 0 3
100861: ARRAY
100862: PPUSH
100863: CALL_OW 314
100867: NOT
100868: IFFALSE 100960
// begin r := rand ( 1 , mc_mines [ i ] ) ;
100870: LD_ADDR_VAR 0 7
100874: PUSH
100875: LD_INT 1
100877: PPUSH
100878: LD_EXP 191
100882: PUSH
100883: LD_VAR 0 2
100887: ARRAY
100888: PPUSH
100889: CALL_OW 12
100893: ST_TO_ADDR
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ r ] [ 1 ] , mc_mines [ i ] [ r ] [ 2 ] , 0 ) ;
100894: LD_EXP 192
100898: PUSH
100899: LD_VAR 0 2
100903: ARRAY
100904: PUSH
100905: LD_VAR 0 3
100909: ARRAY
100910: PPUSH
100911: LD_EXP 191
100915: PUSH
100916: LD_VAR 0 2
100920: ARRAY
100921: PUSH
100922: LD_VAR 0 7
100926: ARRAY
100927: PUSH
100928: LD_INT 1
100930: ARRAY
100931: PPUSH
100932: LD_EXP 191
100936: PUSH
100937: LD_VAR 0 2
100941: ARRAY
100942: PUSH
100943: LD_VAR 0 7
100947: ARRAY
100948: PUSH
100949: LD_INT 2
100951: ARRAY
100952: PPUSH
100953: LD_INT 0
100955: PPUSH
100956: CALL_OW 193
// end ; end ; end ;
100960: GO 100613
100962: POP
100963: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
100964: LD_ADDR_VAR 0 5
100968: PUSH
100969: LD_EXP 178
100973: PUSH
100974: LD_VAR 0 2
100978: ARRAY
100979: PPUSH
100980: LD_INT 2
100982: PUSH
100983: LD_INT 30
100985: PUSH
100986: LD_INT 4
100988: PUSH
100989: EMPTY
100990: LIST
100991: LIST
100992: PUSH
100993: LD_INT 30
100995: PUSH
100996: LD_INT 5
100998: PUSH
100999: EMPTY
101000: LIST
101001: LIST
101002: PUSH
101003: LD_INT 30
101005: PUSH
101006: LD_INT 32
101008: PUSH
101009: EMPTY
101010: LIST
101011: LIST
101012: PUSH
101013: EMPTY
101014: LIST
101015: LIST
101016: LIST
101017: LIST
101018: PPUSH
101019: CALL_OW 72
101023: ST_TO_ADDR
// if not tmp then
101024: LD_VAR 0 5
101028: NOT
101029: IFFALSE 101033
// continue ;
101031: GO 100526
// list := [ ] ;
101033: LD_ADDR_VAR 0 6
101037: PUSH
101038: EMPTY
101039: ST_TO_ADDR
// for j in tmp do
101040: LD_ADDR_VAR 0 3
101044: PUSH
101045: LD_VAR 0 5
101049: PUSH
101050: FOR_IN
101051: IFFALSE 101120
// begin for k in UnitsInside ( j ) do
101053: LD_ADDR_VAR 0 4
101057: PUSH
101058: LD_VAR 0 3
101062: PPUSH
101063: CALL_OW 313
101067: PUSH
101068: FOR_IN
101069: IFFALSE 101116
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
101071: LD_VAR 0 4
101075: PPUSH
101076: CALL_OW 257
101080: PUSH
101081: LD_INT 1
101083: EQUAL
101084: PUSH
101085: LD_VAR 0 4
101089: PPUSH
101090: CALL_OW 459
101094: NOT
101095: AND
101096: IFFALSE 101114
// list := list ^ k ;
101098: LD_ADDR_VAR 0 6
101102: PUSH
101103: LD_VAR 0 6
101107: PUSH
101108: LD_VAR 0 4
101112: ADD
101113: ST_TO_ADDR
101114: GO 101068
101116: POP
101117: POP
// end ;
101118: GO 101050
101120: POP
101121: POP
// list := list diff mc_miners [ i ] ;
101122: LD_ADDR_VAR 0 6
101126: PUSH
101127: LD_VAR 0 6
101131: PUSH
101132: LD_EXP 192
101136: PUSH
101137: LD_VAR 0 2
101141: ARRAY
101142: DIFF
101143: ST_TO_ADDR
// if not list then
101144: LD_VAR 0 6
101148: NOT
101149: IFFALSE 101153
// continue ;
101151: GO 100526
// k := mc_mines [ i ] - mc_miners [ i ] ;
101153: LD_ADDR_VAR 0 4
101157: PUSH
101158: LD_EXP 191
101162: PUSH
101163: LD_VAR 0 2
101167: ARRAY
101168: PUSH
101169: LD_EXP 192
101173: PUSH
101174: LD_VAR 0 2
101178: ARRAY
101179: MINUS
101180: ST_TO_ADDR
// if k > list then
101181: LD_VAR 0 4
101185: PUSH
101186: LD_VAR 0 6
101190: GREATER
101191: IFFALSE 101203
// k := list ;
101193: LD_ADDR_VAR 0 4
101197: PUSH
101198: LD_VAR 0 6
101202: ST_TO_ADDR
// for j = 1 to k do
101203: LD_ADDR_VAR 0 3
101207: PUSH
101208: DOUBLE
101209: LD_INT 1
101211: DEC
101212: ST_TO_ADDR
101213: LD_VAR 0 4
101217: PUSH
101218: FOR_TO
101219: IFFALSE 101273
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
101221: LD_ADDR_EXP 192
101225: PUSH
101226: LD_EXP 192
101230: PPUSH
101231: LD_VAR 0 2
101235: PUSH
101236: LD_EXP 192
101240: PUSH
101241: LD_VAR 0 2
101245: ARRAY
101246: PUSH
101247: LD_INT 1
101249: PLUS
101250: PUSH
101251: EMPTY
101252: LIST
101253: LIST
101254: PPUSH
101255: LD_VAR 0 6
101259: PUSH
101260: LD_VAR 0 3
101264: ARRAY
101265: PPUSH
101266: CALL 24363 0 3
101270: ST_TO_ADDR
101271: GO 101218
101273: POP
101274: POP
// end ;
101275: GO 100526
101277: POP
101278: POP
// end ;
101279: LD_VAR 0 1
101283: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , side , target , cargo , depot , fac , components ; begin
101284: LD_INT 0
101286: PPUSH
101287: PPUSH
101288: PPUSH
101289: PPUSH
101290: PPUSH
101291: PPUSH
101292: PPUSH
101293: PPUSH
101294: PPUSH
101295: PPUSH
101296: PPUSH
// if not mc_bases then
101297: LD_EXP 178
101301: NOT
101302: IFFALSE 101306
// exit ;
101304: GO 103129
// for i = 1 to mc_bases do
101306: LD_ADDR_VAR 0 2
101310: PUSH
101311: DOUBLE
101312: LD_INT 1
101314: DEC
101315: ST_TO_ADDR
101316: LD_EXP 178
101320: PUSH
101321: FOR_TO
101322: IFFALSE 103127
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
101324: LD_EXP 178
101328: PUSH
101329: LD_VAR 0 2
101333: ARRAY
101334: NOT
101335: PUSH
101336: LD_EXP 185
101340: PUSH
101341: LD_VAR 0 2
101345: ARRAY
101346: OR
101347: IFFALSE 101351
// continue ;
101349: GO 101321
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
101351: LD_EXP 194
101355: PUSH
101356: LD_VAR 0 2
101360: ARRAY
101361: NOT
101362: PUSH
101363: LD_EXP 195
101367: PUSH
101368: LD_VAR 0 2
101372: ARRAY
101373: AND
101374: IFFALSE 101412
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
101376: LD_ADDR_EXP 195
101380: PUSH
101381: LD_EXP 195
101385: PPUSH
101386: LD_VAR 0 2
101390: PPUSH
101391: EMPTY
101392: PPUSH
101393: CALL_OW 1
101397: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
101398: LD_VAR 0 2
101402: PPUSH
101403: LD_INT 107
101405: PPUSH
101406: CALL 92180 0 2
// continue ;
101410: GO 101321
// end ; target := [ ] ;
101412: LD_ADDR_VAR 0 7
101416: PUSH
101417: EMPTY
101418: ST_TO_ADDR
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
101419: LD_ADDR_VAR 0 6
101423: PUSH
101424: LD_EXP 178
101428: PUSH
101429: LD_VAR 0 2
101433: ARRAY
101434: PUSH
101435: LD_INT 1
101437: ARRAY
101438: PPUSH
101439: CALL_OW 255
101443: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
101444: LD_ADDR_VAR 0 9
101448: PUSH
101449: LD_EXP 178
101453: PUSH
101454: LD_VAR 0 2
101458: ARRAY
101459: PPUSH
101460: LD_INT 2
101462: PUSH
101463: LD_INT 30
101465: PUSH
101466: LD_INT 0
101468: PUSH
101469: EMPTY
101470: LIST
101471: LIST
101472: PUSH
101473: LD_INT 30
101475: PUSH
101476: LD_INT 1
101478: PUSH
101479: EMPTY
101480: LIST
101481: LIST
101482: PUSH
101483: EMPTY
101484: LIST
101485: LIST
101486: LIST
101487: PPUSH
101488: CALL_OW 72
101492: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
101493: LD_ADDR_VAR 0 3
101497: PUSH
101498: DOUBLE
101499: LD_EXP 194
101503: PUSH
101504: LD_VAR 0 2
101508: ARRAY
101509: INC
101510: ST_TO_ADDR
101511: LD_INT 1
101513: PUSH
101514: FOR_DOWNTO
101515: IFFALSE 101760
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
101517: LD_EXP 194
101521: PUSH
101522: LD_VAR 0 2
101526: ARRAY
101527: PUSH
101528: LD_VAR 0 3
101532: ARRAY
101533: PUSH
101534: LD_INT 2
101536: ARRAY
101537: PPUSH
101538: LD_EXP 194
101542: PUSH
101543: LD_VAR 0 2
101547: ARRAY
101548: PUSH
101549: LD_VAR 0 3
101553: ARRAY
101554: PUSH
101555: LD_INT 3
101557: ARRAY
101558: PPUSH
101559: CALL_OW 488
101563: PUSH
101564: LD_EXP 194
101568: PUSH
101569: LD_VAR 0 2
101573: ARRAY
101574: PUSH
101575: LD_VAR 0 3
101579: ARRAY
101580: PUSH
101581: LD_INT 2
101583: ARRAY
101584: PPUSH
101585: LD_EXP 194
101589: PUSH
101590: LD_VAR 0 2
101594: ARRAY
101595: PUSH
101596: LD_VAR 0 3
101600: ARRAY
101601: PUSH
101602: LD_INT 3
101604: ARRAY
101605: PPUSH
101606: CALL_OW 284
101610: PUSH
101611: LD_INT 0
101613: EQUAL
101614: AND
101615: IFFALSE 101670
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
101617: LD_ADDR_VAR 0 5
101621: PUSH
101622: LD_EXP 194
101626: PUSH
101627: LD_VAR 0 2
101631: ARRAY
101632: PPUSH
101633: LD_VAR 0 3
101637: PPUSH
101638: CALL_OW 3
101642: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
101643: LD_ADDR_EXP 194
101647: PUSH
101648: LD_EXP 194
101652: PPUSH
101653: LD_VAR 0 2
101657: PPUSH
101658: LD_VAR 0 5
101662: PPUSH
101663: CALL_OW 1
101667: ST_TO_ADDR
// continue ;
101668: GO 101514
// end ; if DangerAtRangeXY ( side , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
101670: LD_VAR 0 6
101674: PPUSH
101675: LD_EXP 194
101679: PUSH
101680: LD_VAR 0 2
101684: ARRAY
101685: PUSH
101686: LD_VAR 0 3
101690: ARRAY
101691: PUSH
101692: LD_INT 2
101694: ARRAY
101695: PPUSH
101696: LD_EXP 194
101700: PUSH
101701: LD_VAR 0 2
101705: ARRAY
101706: PUSH
101707: LD_VAR 0 3
101711: ARRAY
101712: PUSH
101713: LD_INT 3
101715: ARRAY
101716: PPUSH
101717: LD_INT 30
101719: PPUSH
101720: CALL 25259 0 4
101724: PUSH
101725: LD_INT 4
101727: ARRAY
101728: PUSH
101729: LD_INT 0
101731: EQUAL
101732: IFFALSE 101758
// begin target := mc_crates [ i ] [ j ] ;
101734: LD_ADDR_VAR 0 7
101738: PUSH
101739: LD_EXP 194
101743: PUSH
101744: LD_VAR 0 2
101748: ARRAY
101749: PUSH
101750: LD_VAR 0 3
101754: ARRAY
101755: ST_TO_ADDR
// break ;
101756: GO 101760
// end ; end ;
101758: GO 101514
101760: POP
101761: POP
// if not target then
101762: LD_VAR 0 7
101766: NOT
101767: IFFALSE 101771
// continue ;
101769: GO 101321
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
101771: LD_ADDR_VAR 0 8
101775: PUSH
101776: LD_EXP 197
101780: PUSH
101781: LD_VAR 0 2
101785: ARRAY
101786: PPUSH
101787: LD_INT 2
101789: PUSH
101790: LD_INT 3
101792: PUSH
101793: LD_INT 58
101795: PUSH
101796: EMPTY
101797: LIST
101798: PUSH
101799: EMPTY
101800: LIST
101801: LIST
101802: PUSH
101803: LD_INT 61
101805: PUSH
101806: EMPTY
101807: LIST
101808: PUSH
101809: LD_INT 33
101811: PUSH
101812: LD_INT 5
101814: PUSH
101815: EMPTY
101816: LIST
101817: LIST
101818: PUSH
101819: LD_INT 33
101821: PUSH
101822: LD_INT 3
101824: PUSH
101825: EMPTY
101826: LIST
101827: LIST
101828: PUSH
101829: EMPTY
101830: LIST
101831: LIST
101832: LIST
101833: LIST
101834: LIST
101835: PUSH
101836: LD_INT 2
101838: PUSH
101839: LD_INT 34
101841: PUSH
101842: LD_INT 32
101844: PUSH
101845: EMPTY
101846: LIST
101847: LIST
101848: PUSH
101849: LD_INT 34
101851: PUSH
101852: LD_INT 51
101854: PUSH
101855: EMPTY
101856: LIST
101857: LIST
101858: PUSH
101859: LD_INT 34
101861: PUSH
101862: LD_INT 12
101864: PUSH
101865: EMPTY
101866: LIST
101867: LIST
101868: PUSH
101869: EMPTY
101870: LIST
101871: LIST
101872: LIST
101873: LIST
101874: PUSH
101875: EMPTY
101876: LIST
101877: LIST
101878: PPUSH
101879: CALL_OW 72
101883: ST_TO_ADDR
// if not cargo then
101884: LD_VAR 0 8
101888: NOT
101889: IFFALSE 102595
// begin if mc_crates_collector [ i ] < 5 then
101891: LD_EXP 195
101895: PUSH
101896: LD_VAR 0 2
101900: ARRAY
101901: PUSH
101902: LD_INT 5
101904: LESS
101905: IFFALSE 102271
// begin if mc_ape [ i ] then
101907: LD_EXP 207
101911: PUSH
101912: LD_VAR 0 2
101916: ARRAY
101917: IFFALSE 101964
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
101919: LD_ADDR_VAR 0 5
101923: PUSH
101924: LD_EXP 207
101928: PUSH
101929: LD_VAR 0 2
101933: ARRAY
101934: PPUSH
101935: LD_INT 25
101937: PUSH
101938: LD_INT 16
101940: PUSH
101941: EMPTY
101942: LIST
101943: LIST
101944: PUSH
101945: LD_INT 24
101947: PUSH
101948: LD_INT 750
101950: PUSH
101951: EMPTY
101952: LIST
101953: LIST
101954: PUSH
101955: EMPTY
101956: LIST
101957: LIST
101958: PPUSH
101959: CALL_OW 72
101963: ST_TO_ADDR
// if not tmp then
101964: LD_VAR 0 5
101968: NOT
101969: IFFALSE 102016
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
101971: LD_ADDR_VAR 0 5
101975: PUSH
101976: LD_EXP 178
101980: PUSH
101981: LD_VAR 0 2
101985: ARRAY
101986: PPUSH
101987: LD_INT 25
101989: PUSH
101990: LD_INT 2
101992: PUSH
101993: EMPTY
101994: LIST
101995: LIST
101996: PUSH
101997: LD_INT 24
101999: PUSH
102000: LD_INT 750
102002: PUSH
102003: EMPTY
102004: LIST
102005: LIST
102006: PUSH
102007: EMPTY
102008: LIST
102009: LIST
102010: PPUSH
102011: CALL_OW 72
102015: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
102016: LD_EXP 207
102020: PUSH
102021: LD_VAR 0 2
102025: ARRAY
102026: PUSH
102027: LD_EXP 178
102031: PUSH
102032: LD_VAR 0 2
102036: ARRAY
102037: PPUSH
102038: LD_INT 25
102040: PUSH
102041: LD_INT 2
102043: PUSH
102044: EMPTY
102045: LIST
102046: LIST
102047: PUSH
102048: LD_INT 24
102050: PUSH
102051: LD_INT 750
102053: PUSH
102054: EMPTY
102055: LIST
102056: LIST
102057: PUSH
102058: EMPTY
102059: LIST
102060: LIST
102061: PPUSH
102062: CALL_OW 72
102066: AND
102067: PUSH
102068: LD_VAR 0 5
102072: PUSH
102073: LD_INT 5
102075: LESS
102076: AND
102077: IFFALSE 102159
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
102079: LD_ADDR_VAR 0 3
102083: PUSH
102084: LD_EXP 178
102088: PUSH
102089: LD_VAR 0 2
102093: ARRAY
102094: PPUSH
102095: LD_INT 25
102097: PUSH
102098: LD_INT 2
102100: PUSH
102101: EMPTY
102102: LIST
102103: LIST
102104: PUSH
102105: LD_INT 24
102107: PUSH
102108: LD_INT 750
102110: PUSH
102111: EMPTY
102112: LIST
102113: LIST
102114: PUSH
102115: EMPTY
102116: LIST
102117: LIST
102118: PPUSH
102119: CALL_OW 72
102123: PUSH
102124: FOR_IN
102125: IFFALSE 102157
// begin tmp := tmp union j ;
102127: LD_ADDR_VAR 0 5
102131: PUSH
102132: LD_VAR 0 5
102136: PUSH
102137: LD_VAR 0 3
102141: UNION
102142: ST_TO_ADDR
// if tmp >= 5 then
102143: LD_VAR 0 5
102147: PUSH
102148: LD_INT 5
102150: GREATEREQUAL
102151: IFFALSE 102155
// break ;
102153: GO 102157
// end ;
102155: GO 102124
102157: POP
102158: POP
// end ; if not tmp then
102159: LD_VAR 0 5
102163: NOT
102164: IFFALSE 102168
// continue ;
102166: GO 101321
// for j in tmp do
102168: LD_ADDR_VAR 0 3
102172: PUSH
102173: LD_VAR 0 5
102177: PUSH
102178: FOR_IN
102179: IFFALSE 102269
// if not GetTag ( j ) then
102181: LD_VAR 0 3
102185: PPUSH
102186: CALL_OW 110
102190: NOT
102191: IFFALSE 102267
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
102193: LD_ADDR_EXP 195
102197: PUSH
102198: LD_EXP 195
102202: PPUSH
102203: LD_VAR 0 2
102207: PUSH
102208: LD_EXP 195
102212: PUSH
102213: LD_VAR 0 2
102217: ARRAY
102218: PUSH
102219: LD_INT 1
102221: PLUS
102222: PUSH
102223: EMPTY
102224: LIST
102225: LIST
102226: PPUSH
102227: LD_VAR 0 3
102231: PPUSH
102232: CALL 24363 0 3
102236: ST_TO_ADDR
// SetTag ( j , 107 ) ;
102237: LD_VAR 0 3
102241: PPUSH
102242: LD_INT 107
102244: PPUSH
102245: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
102249: LD_EXP 195
102253: PUSH
102254: LD_VAR 0 2
102258: ARRAY
102259: PUSH
102260: LD_INT 5
102262: GREATEREQUAL
102263: IFFALSE 102267
// break ;
102265: GO 102269
// end ;
102267: GO 102178
102269: POP
102270: POP
// end ; if mc_crates_collector [ i ] and target then
102271: LD_EXP 195
102275: PUSH
102276: LD_VAR 0 2
102280: ARRAY
102281: PUSH
102282: LD_VAR 0 7
102286: AND
102287: IFFALSE 102593
// begin if mc_crates_collector [ i ] < target [ 1 ] then
102289: LD_EXP 195
102293: PUSH
102294: LD_VAR 0 2
102298: ARRAY
102299: PUSH
102300: LD_VAR 0 7
102304: PUSH
102305: LD_INT 1
102307: ARRAY
102308: LESS
102309: IFFALSE 102329
// tmp := mc_crates_collector [ i ] else
102311: LD_ADDR_VAR 0 5
102315: PUSH
102316: LD_EXP 195
102320: PUSH
102321: LD_VAR 0 2
102325: ARRAY
102326: ST_TO_ADDR
102327: GO 102343
// tmp := target [ 1 ] ;
102329: LD_ADDR_VAR 0 5
102333: PUSH
102334: LD_VAR 0 7
102338: PUSH
102339: LD_INT 1
102341: ARRAY
102342: ST_TO_ADDR
// k := 0 ;
102343: LD_ADDR_VAR 0 4
102347: PUSH
102348: LD_INT 0
102350: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
102351: LD_ADDR_VAR 0 3
102355: PUSH
102356: LD_EXP 195
102360: PUSH
102361: LD_VAR 0 2
102365: ARRAY
102366: PUSH
102367: FOR_IN
102368: IFFALSE 102591
// begin k := k + 1 ;
102370: LD_ADDR_VAR 0 4
102374: PUSH
102375: LD_VAR 0 4
102379: PUSH
102380: LD_INT 1
102382: PLUS
102383: ST_TO_ADDR
// if k > tmp then
102384: LD_VAR 0 4
102388: PUSH
102389: LD_VAR 0 5
102393: GREATER
102394: IFFALSE 102398
// break ;
102396: GO 102591
// if not GetClass ( j ) in [ 2 , 16 ] then
102398: LD_VAR 0 3
102402: PPUSH
102403: CALL_OW 257
102407: PUSH
102408: LD_INT 2
102410: PUSH
102411: LD_INT 16
102413: PUSH
102414: EMPTY
102415: LIST
102416: LIST
102417: IN
102418: NOT
102419: IFFALSE 102472
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
102421: LD_ADDR_EXP 195
102425: PUSH
102426: LD_EXP 195
102430: PPUSH
102431: LD_VAR 0 2
102435: PPUSH
102436: LD_EXP 195
102440: PUSH
102441: LD_VAR 0 2
102445: ARRAY
102446: PUSH
102447: LD_VAR 0 3
102451: DIFF
102452: PPUSH
102453: CALL_OW 1
102457: ST_TO_ADDR
// SetTag ( j , 0 ) ;
102458: LD_VAR 0 3
102462: PPUSH
102463: LD_INT 0
102465: PPUSH
102466: CALL_OW 109
// continue ;
102470: GO 102367
// end ; if IsInUnit ( j ) then
102472: LD_VAR 0 3
102476: PPUSH
102477: CALL_OW 310
102481: IFFALSE 102492
// ComExitBuilding ( j ) ;
102483: LD_VAR 0 3
102487: PPUSH
102488: CALL_OW 122
// wait ( 3 ) ;
102492: LD_INT 3
102494: PPUSH
102495: CALL_OW 67
// if HasTask ( j ) and DangerAtRangeXY ( side , target [ 2 ] , target [ 3 ] , 30 ) [ 4 ] then
102499: LD_VAR 0 3
102503: PPUSH
102504: CALL_OW 314
102508: PUSH
102509: LD_VAR 0 6
102513: PPUSH
102514: LD_VAR 0 7
102518: PUSH
102519: LD_INT 2
102521: ARRAY
102522: PPUSH
102523: LD_VAR 0 7
102527: PUSH
102528: LD_INT 3
102530: ARRAY
102531: PPUSH
102532: LD_INT 30
102534: PPUSH
102535: CALL 25259 0 4
102539: PUSH
102540: LD_INT 4
102542: ARRAY
102543: AND
102544: IFFALSE 102562
// ComStandNearbyBuilding ( j , depot ) else
102546: LD_VAR 0 3
102550: PPUSH
102551: LD_VAR 0 9
102555: PPUSH
102556: CALL 20788 0 2
102560: GO 102589
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
102562: LD_VAR 0 3
102566: PPUSH
102567: LD_VAR 0 7
102571: PUSH
102572: LD_INT 2
102574: ARRAY
102575: PPUSH
102576: LD_VAR 0 7
102580: PUSH
102581: LD_INT 3
102583: ARRAY
102584: PPUSH
102585: CALL_OW 117
// end ;
102589: GO 102367
102591: POP
102592: POP
// end ; end else
102593: GO 103125
// begin for j in cargo do
102595: LD_ADDR_VAR 0 3
102599: PUSH
102600: LD_VAR 0 8
102604: PUSH
102605: FOR_IN
102606: IFFALSE 103123
// begin if GetTag ( j ) <> 0 then
102608: LD_VAR 0 3
102612: PPUSH
102613: CALL_OW 110
102617: PUSH
102618: LD_INT 0
102620: NONEQUAL
102621: IFFALSE 102625
// continue ;
102623: GO 102605
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
102625: LD_VAR 0 3
102629: PPUSH
102630: CALL_OW 256
102634: PUSH
102635: LD_INT 1000
102637: LESS
102638: PUSH
102639: LD_VAR 0 3
102643: PPUSH
102644: LD_EXP 202
102648: PUSH
102649: LD_VAR 0 2
102653: ARRAY
102654: PPUSH
102655: CALL_OW 308
102659: NOT
102660: AND
102661: IFFALSE 102683
// ComMoveToArea ( j , mc_parking [ i ] ) ;
102663: LD_VAR 0 3
102667: PPUSH
102668: LD_EXP 202
102672: PUSH
102673: LD_VAR 0 2
102677: ARRAY
102678: PPUSH
102679: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
102683: LD_VAR 0 3
102687: PPUSH
102688: CALL_OW 256
102692: PUSH
102693: LD_INT 1000
102695: LESS
102696: PUSH
102697: LD_VAR 0 3
102701: PPUSH
102702: LD_EXP 202
102706: PUSH
102707: LD_VAR 0 2
102711: ARRAY
102712: PPUSH
102713: CALL_OW 308
102717: AND
102718: IFFALSE 102722
// continue ;
102720: GO 102605
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
102722: LD_VAR 0 3
102726: PPUSH
102727: CALL_OW 262
102731: PUSH
102732: LD_INT 2
102734: EQUAL
102735: PUSH
102736: LD_VAR 0 3
102740: PPUSH
102741: CALL_OW 261
102745: PUSH
102746: LD_INT 15
102748: LESS
102749: AND
102750: IFFALSE 102754
// continue ;
102752: GO 102605
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
102754: LD_VAR 0 3
102758: PPUSH
102759: CALL_OW 262
102763: PUSH
102764: LD_INT 1
102766: EQUAL
102767: PUSH
102768: LD_VAR 0 3
102772: PPUSH
102773: CALL_OW 261
102777: PUSH
102778: LD_INT 10
102780: LESS
102781: AND
102782: IFFALSE 103062
// begin if not depot then
102784: LD_VAR 0 9
102788: NOT
102789: IFFALSE 102793
// continue ;
102791: GO 102605
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
102793: LD_VAR 0 3
102797: PPUSH
102798: LD_VAR 0 9
102802: PPUSH
102803: LD_VAR 0 3
102807: PPUSH
102808: CALL_OW 74
102812: PPUSH
102813: CALL_OW 296
102817: PUSH
102818: LD_INT 6
102820: LESS
102821: IFFALSE 102837
// SetFuel ( j , 100 ) else
102823: LD_VAR 0 3
102827: PPUSH
102828: LD_INT 100
102830: PPUSH
102831: CALL_OW 240
102835: GO 103062
// if GetFuel ( j ) = 0 then
102837: LD_VAR 0 3
102841: PPUSH
102842: CALL_OW 261
102846: PUSH
102847: LD_INT 0
102849: EQUAL
102850: IFFALSE 103062
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
102852: LD_ADDR_EXP 197
102856: PUSH
102857: LD_EXP 197
102861: PPUSH
102862: LD_VAR 0 2
102866: PPUSH
102867: LD_EXP 197
102871: PUSH
102872: LD_VAR 0 2
102876: ARRAY
102877: PUSH
102878: LD_VAR 0 3
102882: DIFF
102883: PPUSH
102884: CALL_OW 1
102888: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
102889: LD_VAR 0 3
102893: PPUSH
102894: CALL_OW 263
102898: PUSH
102899: LD_INT 1
102901: EQUAL
102902: IFFALSE 102918
// ComExitVehicle ( IsInUnit ( j ) ) ;
102904: LD_VAR 0 3
102908: PPUSH
102909: CALL_OW 310
102913: PPUSH
102914: CALL_OW 121
// if GetControl ( j ) = control_remote then
102918: LD_VAR 0 3
102922: PPUSH
102923: CALL_OW 263
102927: PUSH
102928: LD_INT 2
102930: EQUAL
102931: IFFALSE 102942
// ComUnlink ( j ) ;
102933: LD_VAR 0 3
102937: PPUSH
102938: CALL_OW 136
// fac := MC_GetBuildings ( i , b_factory ) ;
102942: LD_ADDR_VAR 0 10
102946: PUSH
102947: LD_VAR 0 2
102951: PPUSH
102952: LD_INT 3
102954: PPUSH
102955: CALL 112701 0 2
102959: ST_TO_ADDR
// if fac then
102960: LD_VAR 0 10
102964: IFFALSE 103060
// begin for k in fac do
102966: LD_ADDR_VAR 0 4
102970: PUSH
102971: LD_VAR 0 10
102975: PUSH
102976: FOR_IN
102977: IFFALSE 103058
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
102979: LD_ADDR_VAR 0 11
102983: PUSH
102984: LD_VAR 0 10
102988: PPUSH
102989: LD_VAR 0 3
102993: PPUSH
102994: CALL_OW 265
102998: PPUSH
102999: LD_VAR 0 3
103003: PPUSH
103004: CALL_OW 262
103008: PPUSH
103009: LD_VAR 0 3
103013: PPUSH
103014: CALL_OW 263
103018: PPUSH
103019: LD_VAR 0 3
103023: PPUSH
103024: CALL_OW 264
103028: PPUSH
103029: CALL 21859 0 5
103033: ST_TO_ADDR
// if components then
103034: LD_VAR 0 11
103038: IFFALSE 103056
// begin MC_InsertProduceList ( i , components ) ;
103040: LD_VAR 0 2
103044: PPUSH
103045: LD_VAR 0 11
103049: PPUSH
103050: CALL 112246 0 2
// break ;
103054: GO 103058
// end ; end ;
103056: GO 102976
103058: POP
103059: POP
// end ; continue ;
103060: GO 102605
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
103062: LD_VAR 0 3
103066: PPUSH
103067: LD_INT 1
103069: PPUSH
103070: CALL_OW 289
103074: PUSH
103075: LD_INT 100
103077: LESS
103078: PUSH
103079: LD_VAR 0 3
103083: PPUSH
103084: CALL_OW 314
103088: NOT
103089: AND
103090: IFFALSE 103119
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
103092: LD_VAR 0 3
103096: PPUSH
103097: LD_VAR 0 7
103101: PUSH
103102: LD_INT 2
103104: ARRAY
103105: PPUSH
103106: LD_VAR 0 7
103110: PUSH
103111: LD_INT 3
103113: ARRAY
103114: PPUSH
103115: CALL_OW 117
// break ;
103119: GO 103123
// end ;
103121: GO 102605
103123: POP
103124: POP
// end ; end ;
103125: GO 101321
103127: POP
103128: POP
// end ;
103129: LD_VAR 0 1
103133: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
103134: LD_INT 0
103136: PPUSH
103137: PPUSH
103138: PPUSH
103139: PPUSH
// if not mc_bases then
103140: LD_EXP 178
103144: NOT
103145: IFFALSE 103149
// exit ;
103147: GO 103310
// for i = 1 to mc_bases do
103149: LD_ADDR_VAR 0 2
103153: PUSH
103154: DOUBLE
103155: LD_INT 1
103157: DEC
103158: ST_TO_ADDR
103159: LD_EXP 178
103163: PUSH
103164: FOR_TO
103165: IFFALSE 103308
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
103167: LD_ADDR_VAR 0 4
103171: PUSH
103172: LD_EXP 197
103176: PUSH
103177: LD_VAR 0 2
103181: ARRAY
103182: PUSH
103183: LD_EXP 200
103187: PUSH
103188: LD_VAR 0 2
103192: ARRAY
103193: UNION
103194: PPUSH
103195: LD_INT 33
103197: PUSH
103198: LD_INT 2
103200: PUSH
103201: EMPTY
103202: LIST
103203: LIST
103204: PPUSH
103205: CALL_OW 72
103209: ST_TO_ADDR
// if tmp then
103210: LD_VAR 0 4
103214: IFFALSE 103306
// for j in tmp do
103216: LD_ADDR_VAR 0 3
103220: PUSH
103221: LD_VAR 0 4
103225: PUSH
103226: FOR_IN
103227: IFFALSE 103304
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
103229: LD_VAR 0 3
103233: PPUSH
103234: CALL_OW 312
103238: NOT
103239: PUSH
103240: LD_VAR 0 3
103244: PPUSH
103245: CALL_OW 256
103249: PUSH
103250: LD_INT 250
103252: GREATEREQUAL
103253: AND
103254: IFFALSE 103267
// Connect ( j ) else
103256: LD_VAR 0 3
103260: PPUSH
103261: CALL 27334 0 1
103265: GO 103302
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
103267: LD_VAR 0 3
103271: PPUSH
103272: CALL_OW 256
103276: PUSH
103277: LD_INT 250
103279: LESS
103280: PUSH
103281: LD_VAR 0 3
103285: PPUSH
103286: CALL_OW 312
103290: AND
103291: IFFALSE 103302
// ComUnlink ( j ) ;
103293: LD_VAR 0 3
103297: PPUSH
103298: CALL_OW 136
103302: GO 103226
103304: POP
103305: POP
// end ;
103306: GO 103164
103308: POP
103309: POP
// end ;
103310: LD_VAR 0 1
103314: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
103315: LD_INT 0
103317: PPUSH
103318: PPUSH
103319: PPUSH
103320: PPUSH
103321: PPUSH
// if not mc_bases then
103322: LD_EXP 178
103326: NOT
103327: IFFALSE 103331
// exit ;
103329: GO 103776
// for i = 1 to mc_bases do
103331: LD_ADDR_VAR 0 2
103335: PUSH
103336: DOUBLE
103337: LD_INT 1
103339: DEC
103340: ST_TO_ADDR
103341: LD_EXP 178
103345: PUSH
103346: FOR_TO
103347: IFFALSE 103774
// begin if not mc_produce [ i ] then
103349: LD_EXP 199
103353: PUSH
103354: LD_VAR 0 2
103358: ARRAY
103359: NOT
103360: IFFALSE 103364
// continue ;
103362: GO 103346
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
103364: LD_ADDR_VAR 0 5
103368: PUSH
103369: LD_EXP 178
103373: PUSH
103374: LD_VAR 0 2
103378: ARRAY
103379: PPUSH
103380: LD_INT 30
103382: PUSH
103383: LD_INT 3
103385: PUSH
103386: EMPTY
103387: LIST
103388: LIST
103389: PPUSH
103390: CALL_OW 72
103394: ST_TO_ADDR
// if not fac then
103395: LD_VAR 0 5
103399: NOT
103400: IFFALSE 103404
// continue ;
103402: GO 103346
// for j in fac do
103404: LD_ADDR_VAR 0 3
103408: PUSH
103409: LD_VAR 0 5
103413: PUSH
103414: FOR_IN
103415: IFFALSE 103770
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
103417: LD_VAR 0 3
103421: PPUSH
103422: CALL_OW 461
103426: PUSH
103427: LD_INT 2
103429: NONEQUAL
103430: PUSH
103431: LD_VAR 0 3
103435: PPUSH
103436: LD_INT 15
103438: PPUSH
103439: CALL 26962 0 2
103443: PUSH
103444: LD_INT 4
103446: ARRAY
103447: OR
103448: IFFALSE 103452
// continue ;
103450: GO 103414
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
103452: LD_VAR 0 3
103456: PPUSH
103457: LD_EXP 199
103461: PUSH
103462: LD_VAR 0 2
103466: ARRAY
103467: PUSH
103468: LD_INT 1
103470: ARRAY
103471: PUSH
103472: LD_INT 1
103474: ARRAY
103475: PPUSH
103476: LD_EXP 199
103480: PUSH
103481: LD_VAR 0 2
103485: ARRAY
103486: PUSH
103487: LD_INT 1
103489: ARRAY
103490: PUSH
103491: LD_INT 2
103493: ARRAY
103494: PPUSH
103495: LD_EXP 199
103499: PUSH
103500: LD_VAR 0 2
103504: ARRAY
103505: PUSH
103506: LD_INT 1
103508: ARRAY
103509: PUSH
103510: LD_INT 3
103512: ARRAY
103513: PPUSH
103514: LD_EXP 199
103518: PUSH
103519: LD_VAR 0 2
103523: ARRAY
103524: PUSH
103525: LD_INT 1
103527: ARRAY
103528: PUSH
103529: LD_INT 4
103531: ARRAY
103532: PPUSH
103533: CALL_OW 448
103537: PUSH
103538: LD_VAR 0 3
103542: PPUSH
103543: LD_EXP 199
103547: PUSH
103548: LD_VAR 0 2
103552: ARRAY
103553: PUSH
103554: LD_INT 1
103556: ARRAY
103557: PUSH
103558: LD_INT 1
103560: ARRAY
103561: PUSH
103562: LD_EXP 199
103566: PUSH
103567: LD_VAR 0 2
103571: ARRAY
103572: PUSH
103573: LD_INT 1
103575: ARRAY
103576: PUSH
103577: LD_INT 2
103579: ARRAY
103580: PUSH
103581: LD_EXP 199
103585: PUSH
103586: LD_VAR 0 2
103590: ARRAY
103591: PUSH
103592: LD_INT 1
103594: ARRAY
103595: PUSH
103596: LD_INT 3
103598: ARRAY
103599: PUSH
103600: LD_EXP 199
103604: PUSH
103605: LD_VAR 0 2
103609: ARRAY
103610: PUSH
103611: LD_INT 1
103613: ARRAY
103614: PUSH
103615: LD_INT 4
103617: ARRAY
103618: PUSH
103619: EMPTY
103620: LIST
103621: LIST
103622: LIST
103623: LIST
103624: PPUSH
103625: CALL 30729 0 2
103629: AND
103630: IFFALSE 103768
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
103632: LD_VAR 0 3
103636: PPUSH
103637: LD_EXP 199
103641: PUSH
103642: LD_VAR 0 2
103646: ARRAY
103647: PUSH
103648: LD_INT 1
103650: ARRAY
103651: PUSH
103652: LD_INT 1
103654: ARRAY
103655: PPUSH
103656: LD_EXP 199
103660: PUSH
103661: LD_VAR 0 2
103665: ARRAY
103666: PUSH
103667: LD_INT 1
103669: ARRAY
103670: PUSH
103671: LD_INT 2
103673: ARRAY
103674: PPUSH
103675: LD_EXP 199
103679: PUSH
103680: LD_VAR 0 2
103684: ARRAY
103685: PUSH
103686: LD_INT 1
103688: ARRAY
103689: PUSH
103690: LD_INT 3
103692: ARRAY
103693: PPUSH
103694: LD_EXP 199
103698: PUSH
103699: LD_VAR 0 2
103703: ARRAY
103704: PUSH
103705: LD_INT 1
103707: ARRAY
103708: PUSH
103709: LD_INT 4
103711: ARRAY
103712: PPUSH
103713: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
103717: LD_ADDR_VAR 0 4
103721: PUSH
103722: LD_EXP 199
103726: PUSH
103727: LD_VAR 0 2
103731: ARRAY
103732: PPUSH
103733: LD_INT 1
103735: PPUSH
103736: CALL_OW 3
103740: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
103741: LD_ADDR_EXP 199
103745: PUSH
103746: LD_EXP 199
103750: PPUSH
103751: LD_VAR 0 2
103755: PPUSH
103756: LD_VAR 0 4
103760: PPUSH
103761: CALL_OW 1
103765: ST_TO_ADDR
// break ;
103766: GO 103770
// end ; end ;
103768: GO 103414
103770: POP
103771: POP
// end ;
103772: GO 103346
103774: POP
103775: POP
// end ;
103776: LD_VAR 0 1
103780: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
103781: LD_INT 0
103783: PPUSH
103784: PPUSH
103785: PPUSH
// if not mc_bases then
103786: LD_EXP 178
103790: NOT
103791: IFFALSE 103795
// exit ;
103793: GO 103884
// for i = 1 to mc_bases do
103795: LD_ADDR_VAR 0 2
103799: PUSH
103800: DOUBLE
103801: LD_INT 1
103803: DEC
103804: ST_TO_ADDR
103805: LD_EXP 178
103809: PUSH
103810: FOR_TO
103811: IFFALSE 103882
// begin if mc_attack [ i ] then
103813: LD_EXP 198
103817: PUSH
103818: LD_VAR 0 2
103822: ARRAY
103823: IFFALSE 103880
// begin tmp := mc_attack [ i ] [ 1 ] ;
103825: LD_ADDR_VAR 0 3
103829: PUSH
103830: LD_EXP 198
103834: PUSH
103835: LD_VAR 0 2
103839: ARRAY
103840: PUSH
103841: LD_INT 1
103843: ARRAY
103844: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
103845: LD_ADDR_EXP 198
103849: PUSH
103850: LD_EXP 198
103854: PPUSH
103855: LD_VAR 0 2
103859: PPUSH
103860: EMPTY
103861: PPUSH
103862: CALL_OW 1
103866: ST_TO_ADDR
// Attack ( tmp ) ;
103867: LD_VAR 0 3
103871: PPUSH
103872: CALL 80725 0 1
// exit ;
103876: POP
103877: POP
103878: GO 103884
// end ; end ;
103880: GO 103810
103882: POP
103883: POP
// end ;
103884: LD_VAR 0 1
103888: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
103889: LD_INT 0
103891: PPUSH
103892: PPUSH
103893: PPUSH
103894: PPUSH
103895: PPUSH
103896: PPUSH
103897: PPUSH
// if not mc_bases then
103898: LD_EXP 178
103902: NOT
103903: IFFALSE 103907
// exit ;
103905: GO 104764
// for i = 1 to mc_bases do
103907: LD_ADDR_VAR 0 2
103911: PUSH
103912: DOUBLE
103913: LD_INT 1
103915: DEC
103916: ST_TO_ADDR
103917: LD_EXP 178
103921: PUSH
103922: FOR_TO
103923: IFFALSE 104762
// begin if not mc_bases [ i ] then
103925: LD_EXP 178
103929: PUSH
103930: LD_VAR 0 2
103934: ARRAY
103935: NOT
103936: IFFALSE 103940
// continue ;
103938: GO 103922
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
103940: LD_ADDR_VAR 0 7
103944: PUSH
103945: LD_EXP 178
103949: PUSH
103950: LD_VAR 0 2
103954: ARRAY
103955: PUSH
103956: LD_INT 1
103958: ARRAY
103959: PPUSH
103960: CALL 21010 0 1
103964: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
103965: LD_ADDR_EXP 201
103969: PUSH
103970: LD_EXP 201
103974: PPUSH
103975: LD_VAR 0 2
103979: PPUSH
103980: LD_EXP 178
103984: PUSH
103985: LD_VAR 0 2
103989: ARRAY
103990: PUSH
103991: LD_INT 1
103993: ARRAY
103994: PPUSH
103995: CALL_OW 255
103999: PPUSH
104000: LD_EXP 203
104004: PUSH
104005: LD_VAR 0 2
104009: ARRAY
104010: PPUSH
104011: CALL 20975 0 2
104015: PPUSH
104016: CALL_OW 1
104020: ST_TO_ADDR
// if not mc_scan [ i ] then
104021: LD_EXP 201
104025: PUSH
104026: LD_VAR 0 2
104030: ARRAY
104031: NOT
104032: IFFALSE 104210
// begin mc_is_defending := Replace ( mc_is_defending , i , false ) ;
104034: LD_ADDR_EXP 221
104038: PUSH
104039: LD_EXP 221
104043: PPUSH
104044: LD_VAR 0 2
104048: PPUSH
104049: LD_INT 0
104051: PPUSH
104052: CALL_OW 1
104056: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
104057: LD_ADDR_VAR 0 4
104061: PUSH
104062: LD_EXP 178
104066: PUSH
104067: LD_VAR 0 2
104071: ARRAY
104072: PPUSH
104073: LD_INT 2
104075: PUSH
104076: LD_INT 25
104078: PUSH
104079: LD_INT 5
104081: PUSH
104082: EMPTY
104083: LIST
104084: LIST
104085: PUSH
104086: LD_INT 25
104088: PUSH
104089: LD_INT 8
104091: PUSH
104092: EMPTY
104093: LIST
104094: LIST
104095: PUSH
104096: LD_INT 25
104098: PUSH
104099: LD_INT 9
104101: PUSH
104102: EMPTY
104103: LIST
104104: LIST
104105: PUSH
104106: EMPTY
104107: LIST
104108: LIST
104109: LIST
104110: LIST
104111: PPUSH
104112: CALL_OW 72
104116: ST_TO_ADDR
// if not tmp then
104117: LD_VAR 0 4
104121: NOT
104122: IFFALSE 104126
// continue ;
104124: GO 103922
// for j in tmp do
104126: LD_ADDR_VAR 0 3
104130: PUSH
104131: LD_VAR 0 4
104135: PUSH
104136: FOR_IN
104137: IFFALSE 104208
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
104139: LD_VAR 0 3
104143: PPUSH
104144: CALL_OW 310
104148: PPUSH
104149: CALL_OW 266
104153: PUSH
104154: LD_INT 5
104156: EQUAL
104157: PUSH
104158: LD_VAR 0 3
104162: PPUSH
104163: CALL_OW 257
104167: PUSH
104168: LD_INT 1
104170: EQUAL
104171: AND
104172: PUSH
104173: LD_VAR 0 3
104177: PPUSH
104178: CALL_OW 459
104182: NOT
104183: AND
104184: PUSH
104185: LD_VAR 0 7
104189: AND
104190: IFFALSE 104206
// ComChangeProfession ( j , class ) ;
104192: LD_VAR 0 3
104196: PPUSH
104197: LD_VAR 0 7
104201: PPUSH
104202: CALL_OW 123
104206: GO 104136
104208: POP
104209: POP
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and not mc_defender [ i ] and ( UnitFilter ( mc_bases [ i ] , [ [ f_ok ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) < 4 or UnitFilter ( mc_bases [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ) then
104210: LD_EXP 201
104214: PUSH
104215: LD_VAR 0 2
104219: ARRAY
104220: PUSH
104221: LD_EXP 221
104225: PUSH
104226: LD_VAR 0 2
104230: ARRAY
104231: NOT
104232: AND
104233: PUSH
104234: LD_EXP 200
104238: PUSH
104239: LD_VAR 0 2
104243: ARRAY
104244: NOT
104245: AND
104246: PUSH
104247: LD_EXP 178
104251: PUSH
104252: LD_VAR 0 2
104256: ARRAY
104257: PPUSH
104258: LD_INT 50
104260: PUSH
104261: EMPTY
104262: LIST
104263: PUSH
104264: LD_INT 2
104266: PUSH
104267: LD_INT 30
104269: PUSH
104270: LD_INT 32
104272: PUSH
104273: EMPTY
104274: LIST
104275: LIST
104276: PUSH
104277: LD_INT 30
104279: PUSH
104280: LD_INT 33
104282: PUSH
104283: EMPTY
104284: LIST
104285: LIST
104286: PUSH
104287: LD_INT 30
104289: PUSH
104290: LD_INT 4
104292: PUSH
104293: EMPTY
104294: LIST
104295: LIST
104296: PUSH
104297: LD_INT 30
104299: PUSH
104300: LD_INT 5
104302: PUSH
104303: EMPTY
104304: LIST
104305: LIST
104306: PUSH
104307: EMPTY
104308: LIST
104309: LIST
104310: LIST
104311: LIST
104312: LIST
104313: PUSH
104314: EMPTY
104315: LIST
104316: LIST
104317: PPUSH
104318: CALL_OW 72
104322: PUSH
104323: LD_INT 4
104325: LESS
104326: PUSH
104327: LD_EXP 178
104331: PUSH
104332: LD_VAR 0 2
104336: ARRAY
104337: PPUSH
104338: LD_INT 3
104340: PUSH
104341: LD_INT 24
104343: PUSH
104344: LD_INT 1000
104346: PUSH
104347: EMPTY
104348: LIST
104349: LIST
104350: PUSH
104351: EMPTY
104352: LIST
104353: LIST
104354: PUSH
104355: LD_INT 2
104357: PUSH
104358: LD_INT 30
104360: PUSH
104361: LD_INT 0
104363: PUSH
104364: EMPTY
104365: LIST
104366: LIST
104367: PUSH
104368: LD_INT 30
104370: PUSH
104371: LD_INT 1
104373: PUSH
104374: EMPTY
104375: LIST
104376: LIST
104377: PUSH
104378: EMPTY
104379: LIST
104380: LIST
104381: LIST
104382: PUSH
104383: EMPTY
104384: LIST
104385: LIST
104386: PPUSH
104387: CALL_OW 72
104391: OR
104392: AND
104393: IFFALSE 104644
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
104395: LD_ADDR_EXP 221
104399: PUSH
104400: LD_EXP 221
104404: PPUSH
104405: LD_VAR 0 2
104409: PPUSH
104410: LD_INT 1
104412: PPUSH
104413: CALL_OW 1
104417: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
104418: LD_ADDR_VAR 0 4
104422: PUSH
104423: LD_EXP 178
104427: PUSH
104428: LD_VAR 0 2
104432: ARRAY
104433: PPUSH
104434: LD_INT 2
104436: PUSH
104437: LD_INT 25
104439: PUSH
104440: LD_INT 1
104442: PUSH
104443: EMPTY
104444: LIST
104445: LIST
104446: PUSH
104447: LD_INT 25
104449: PUSH
104450: LD_INT 5
104452: PUSH
104453: EMPTY
104454: LIST
104455: LIST
104456: PUSH
104457: LD_INT 25
104459: PUSH
104460: LD_INT 8
104462: PUSH
104463: EMPTY
104464: LIST
104465: LIST
104466: PUSH
104467: LD_INT 25
104469: PUSH
104470: LD_INT 9
104472: PUSH
104473: EMPTY
104474: LIST
104475: LIST
104476: PUSH
104477: EMPTY
104478: LIST
104479: LIST
104480: LIST
104481: LIST
104482: LIST
104483: PPUSH
104484: CALL_OW 72
104488: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
104489: LD_ADDR_VAR 0 4
104493: PUSH
104494: LD_VAR 0 4
104498: PUSH
104499: LD_VAR 0 4
104503: PPUSH
104504: LD_INT 18
104506: PPUSH
104507: CALL 54199 0 2
104511: DIFF
104512: ST_TO_ADDR
// if not tmp and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
104513: LD_VAR 0 4
104517: NOT
104518: PUSH
104519: LD_EXP 178
104523: PUSH
104524: LD_VAR 0 2
104528: ARRAY
104529: PPUSH
104530: LD_INT 2
104532: PUSH
104533: LD_INT 30
104535: PUSH
104536: LD_INT 4
104538: PUSH
104539: EMPTY
104540: LIST
104541: LIST
104542: PUSH
104543: LD_INT 30
104545: PUSH
104546: LD_INT 5
104548: PUSH
104549: EMPTY
104550: LIST
104551: LIST
104552: PUSH
104553: EMPTY
104554: LIST
104555: LIST
104556: LIST
104557: PPUSH
104558: CALL_OW 72
104562: NOT
104563: AND
104564: IFFALSE 104626
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ) ;
104566: LD_ADDR_VAR 0 4
104570: PUSH
104571: LD_EXP 178
104575: PUSH
104576: LD_VAR 0 2
104580: ARRAY
104581: PPUSH
104582: LD_INT 2
104584: PUSH
104585: LD_INT 25
104587: PUSH
104588: LD_INT 2
104590: PUSH
104591: EMPTY
104592: LIST
104593: LIST
104594: PUSH
104595: LD_INT 25
104597: PUSH
104598: LD_INT 3
104600: PUSH
104601: EMPTY
104602: LIST
104603: LIST
104604: PUSH
104605: LD_INT 25
104607: PUSH
104608: LD_INT 4
104610: PUSH
104611: EMPTY
104612: LIST
104613: LIST
104614: PUSH
104615: EMPTY
104616: LIST
104617: LIST
104618: LIST
104619: LIST
104620: PPUSH
104621: CALL_OW 72
104625: ST_TO_ADDR
// BasicDefend ( i , tmp ) ;
104626: LD_VAR 0 2
104630: PPUSH
104631: LD_VAR 0 4
104635: PPUSH
104636: CALL 85434 0 2
// exit ;
104640: POP
104641: POP
104642: GO 104764
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and mc_defender [ i ] then
104644: LD_EXP 201
104648: PUSH
104649: LD_VAR 0 2
104653: ARRAY
104654: PUSH
104655: LD_EXP 221
104659: PUSH
104660: LD_VAR 0 2
104664: ARRAY
104665: NOT
104666: AND
104667: PUSH
104668: LD_EXP 200
104672: PUSH
104673: LD_VAR 0 2
104677: ARRAY
104678: AND
104679: IFFALSE 104760
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
104681: LD_ADDR_EXP 221
104685: PUSH
104686: LD_EXP 221
104690: PPUSH
104691: LD_VAR 0 2
104695: PPUSH
104696: LD_INT 1
104698: PPUSH
104699: CALL_OW 1
104703: ST_TO_ADDR
// tmp := mc_defender [ i ] ;
104704: LD_ADDR_VAR 0 4
104708: PUSH
104709: LD_EXP 200
104713: PUSH
104714: LD_VAR 0 2
104718: ARRAY
104719: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
104720: LD_ADDR_EXP 200
104724: PUSH
104725: LD_EXP 200
104729: PPUSH
104730: LD_VAR 0 2
104734: PPUSH
104735: EMPTY
104736: PPUSH
104737: CALL_OW 1
104741: ST_TO_ADDR
// Defend ( i , tmp ) ;
104742: LD_VAR 0 2
104746: PPUSH
104747: LD_VAR 0 4
104751: PPUSH
104752: CALL 86030 0 2
// exit ;
104756: POP
104757: POP
104758: GO 104764
// end ; end ;
104760: GO 103922
104762: POP
104763: POP
// end ;
104764: LD_VAR 0 1
104768: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
104769: LD_INT 0
104771: PPUSH
104772: PPUSH
104773: PPUSH
104774: PPUSH
104775: PPUSH
104776: PPUSH
104777: PPUSH
104778: PPUSH
104779: PPUSH
104780: PPUSH
104781: PPUSH
// if not mc_bases then
104782: LD_EXP 178
104786: NOT
104787: IFFALSE 104791
// exit ;
104789: GO 105878
// for i = 1 to mc_bases do
104791: LD_ADDR_VAR 0 2
104795: PUSH
104796: DOUBLE
104797: LD_INT 1
104799: DEC
104800: ST_TO_ADDR
104801: LD_EXP 178
104805: PUSH
104806: FOR_TO
104807: IFFALSE 105876
// begin tmp := mc_lab [ i ] ;
104809: LD_ADDR_VAR 0 6
104813: PUSH
104814: LD_EXP 211
104818: PUSH
104819: LD_VAR 0 2
104823: ARRAY
104824: ST_TO_ADDR
// if not tmp then
104825: LD_VAR 0 6
104829: NOT
104830: IFFALSE 104834
// continue ;
104832: GO 104806
// idle_lab := 0 ;
104834: LD_ADDR_VAR 0 11
104838: PUSH
104839: LD_INT 0
104841: ST_TO_ADDR
// for j in tmp do
104842: LD_ADDR_VAR 0 3
104846: PUSH
104847: LD_VAR 0 6
104851: PUSH
104852: FOR_IN
104853: IFFALSE 105872
// begin researching := false ;
104855: LD_ADDR_VAR 0 10
104859: PUSH
104860: LD_INT 0
104862: ST_TO_ADDR
// side := GetSide ( j ) ;
104863: LD_ADDR_VAR 0 4
104867: PUSH
104868: LD_VAR 0 3
104872: PPUSH
104873: CALL_OW 255
104877: ST_TO_ADDR
// if not mc_tech [ side ] then
104878: LD_EXP 205
104882: PUSH
104883: LD_VAR 0 4
104887: ARRAY
104888: NOT
104889: IFFALSE 104893
// continue ;
104891: GO 104852
// if BuildingStatus ( j ) = bs_idle then
104893: LD_VAR 0 3
104897: PPUSH
104898: CALL_OW 461
104902: PUSH
104903: LD_INT 2
104905: EQUAL
104906: IFFALSE 105094
// begin if idle_lab and UnitsInside ( j ) < 6 then
104908: LD_VAR 0 11
104912: PUSH
104913: LD_VAR 0 3
104917: PPUSH
104918: CALL_OW 313
104922: PUSH
104923: LD_INT 6
104925: LESS
104926: AND
104927: IFFALSE 104998
// begin tmp2 := UnitsInside ( idle_lab ) ;
104929: LD_ADDR_VAR 0 9
104933: PUSH
104934: LD_VAR 0 11
104938: PPUSH
104939: CALL_OW 313
104943: ST_TO_ADDR
// if tmp2 then
104944: LD_VAR 0 9
104948: IFFALSE 104990
// for x in tmp2 do
104950: LD_ADDR_VAR 0 7
104954: PUSH
104955: LD_VAR 0 9
104959: PUSH
104960: FOR_IN
104961: IFFALSE 104988
// begin ComExitBuilding ( x ) ;
104963: LD_VAR 0 7
104967: PPUSH
104968: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
104972: LD_VAR 0 7
104976: PPUSH
104977: LD_VAR 0 3
104981: PPUSH
104982: CALL_OW 180
// end ;
104986: GO 104960
104988: POP
104989: POP
// idle_lab := 0 ;
104990: LD_ADDR_VAR 0 11
104994: PUSH
104995: LD_INT 0
104997: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
104998: LD_ADDR_VAR 0 5
105002: PUSH
105003: LD_EXP 205
105007: PUSH
105008: LD_VAR 0 4
105012: ARRAY
105013: PUSH
105014: FOR_IN
105015: IFFALSE 105075
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
105017: LD_VAR 0 3
105021: PPUSH
105022: LD_VAR 0 5
105026: PPUSH
105027: CALL_OW 430
105031: PUSH
105032: LD_VAR 0 4
105036: PPUSH
105037: LD_VAR 0 5
105041: PPUSH
105042: CALL 20080 0 2
105046: AND
105047: IFFALSE 105073
// begin researching := true ;
105049: LD_ADDR_VAR 0 10
105053: PUSH
105054: LD_INT 1
105056: ST_TO_ADDR
// ComResearch ( j , t ) ;
105057: LD_VAR 0 3
105061: PPUSH
105062: LD_VAR 0 5
105066: PPUSH
105067: CALL_OW 124
// break ;
105071: GO 105075
// end ;
105073: GO 105014
105075: POP
105076: POP
// if not researching then
105077: LD_VAR 0 10
105081: NOT
105082: IFFALSE 105094
// idle_lab := j ;
105084: LD_ADDR_VAR 0 11
105088: PUSH
105089: LD_VAR 0 3
105093: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
105094: LD_VAR 0 3
105098: PPUSH
105099: CALL_OW 461
105103: PUSH
105104: LD_INT 10
105106: EQUAL
105107: IFFALSE 105695
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
105109: LD_EXP 207
105113: PUSH
105114: LD_VAR 0 2
105118: ARRAY
105119: NOT
105120: PUSH
105121: LD_EXP 208
105125: PUSH
105126: LD_VAR 0 2
105130: ARRAY
105131: NOT
105132: AND
105133: PUSH
105134: LD_EXP 205
105138: PUSH
105139: LD_VAR 0 4
105143: ARRAY
105144: PUSH
105145: LD_INT 1
105147: GREATER
105148: AND
105149: IFFALSE 105280
// begin ComCancel ( j ) ;
105151: LD_VAR 0 3
105155: PPUSH
105156: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
105160: LD_ADDR_EXP 205
105164: PUSH
105165: LD_EXP 205
105169: PPUSH
105170: LD_VAR 0 4
105174: PPUSH
105175: LD_EXP 205
105179: PUSH
105180: LD_VAR 0 4
105184: ARRAY
105185: PPUSH
105186: LD_EXP 205
105190: PUSH
105191: LD_VAR 0 4
105195: ARRAY
105196: PUSH
105197: LD_INT 1
105199: MINUS
105200: PPUSH
105201: LD_EXP 205
105205: PUSH
105206: LD_VAR 0 4
105210: ARRAY
105211: PPUSH
105212: LD_INT 0
105214: PPUSH
105215: CALL 23781 0 4
105219: PPUSH
105220: CALL_OW 1
105224: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
105225: LD_ADDR_EXP 205
105229: PUSH
105230: LD_EXP 205
105234: PPUSH
105235: LD_VAR 0 4
105239: PPUSH
105240: LD_EXP 205
105244: PUSH
105245: LD_VAR 0 4
105249: ARRAY
105250: PPUSH
105251: LD_EXP 205
105255: PUSH
105256: LD_VAR 0 4
105260: ARRAY
105261: PPUSH
105262: LD_INT 1
105264: PPUSH
105265: LD_INT 0
105267: PPUSH
105268: CALL 23781 0 4
105272: PPUSH
105273: CALL_OW 1
105277: ST_TO_ADDR
// continue ;
105278: GO 104852
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
105280: LD_EXP 207
105284: PUSH
105285: LD_VAR 0 2
105289: ARRAY
105290: PUSH
105291: LD_EXP 208
105295: PUSH
105296: LD_VAR 0 2
105300: ARRAY
105301: NOT
105302: AND
105303: IFFALSE 105430
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
105305: LD_ADDR_EXP 208
105309: PUSH
105310: LD_EXP 208
105314: PPUSH
105315: LD_VAR 0 2
105319: PUSH
105320: LD_EXP 208
105324: PUSH
105325: LD_VAR 0 2
105329: ARRAY
105330: PUSH
105331: LD_INT 1
105333: PLUS
105334: PUSH
105335: EMPTY
105336: LIST
105337: LIST
105338: PPUSH
105339: LD_EXP 207
105343: PUSH
105344: LD_VAR 0 2
105348: ARRAY
105349: PUSH
105350: LD_INT 1
105352: ARRAY
105353: PPUSH
105354: CALL 24363 0 3
105358: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
105359: LD_EXP 207
105363: PUSH
105364: LD_VAR 0 2
105368: ARRAY
105369: PUSH
105370: LD_INT 1
105372: ARRAY
105373: PPUSH
105374: LD_INT 112
105376: PPUSH
105377: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
105381: LD_ADDR_VAR 0 9
105385: PUSH
105386: LD_EXP 207
105390: PUSH
105391: LD_VAR 0 2
105395: ARRAY
105396: PPUSH
105397: LD_INT 1
105399: PPUSH
105400: CALL_OW 3
105404: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
105405: LD_ADDR_EXP 207
105409: PUSH
105410: LD_EXP 207
105414: PPUSH
105415: LD_VAR 0 2
105419: PPUSH
105420: LD_VAR 0 9
105424: PPUSH
105425: CALL_OW 1
105429: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
105430: LD_EXP 207
105434: PUSH
105435: LD_VAR 0 2
105439: ARRAY
105440: PUSH
105441: LD_EXP 208
105445: PUSH
105446: LD_VAR 0 2
105450: ARRAY
105451: AND
105452: PUSH
105453: LD_EXP 208
105457: PUSH
105458: LD_VAR 0 2
105462: ARRAY
105463: PUSH
105464: LD_INT 1
105466: ARRAY
105467: PPUSH
105468: CALL_OW 310
105472: NOT
105473: AND
105474: PUSH
105475: LD_VAR 0 3
105479: PPUSH
105480: CALL_OW 313
105484: PUSH
105485: LD_INT 6
105487: EQUAL
105488: AND
105489: IFFALSE 105545
// begin tmp2 := UnitsInside ( j ) ;
105491: LD_ADDR_VAR 0 9
105495: PUSH
105496: LD_VAR 0 3
105500: PPUSH
105501: CALL_OW 313
105505: ST_TO_ADDR
// if tmp2 = 6 then
105506: LD_VAR 0 9
105510: PUSH
105511: LD_INT 6
105513: EQUAL
105514: IFFALSE 105545
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
105516: LD_VAR 0 9
105520: PUSH
105521: LD_INT 1
105523: ARRAY
105524: PPUSH
105525: LD_INT 112
105527: PPUSH
105528: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
105532: LD_VAR 0 9
105536: PUSH
105537: LD_INT 1
105539: ARRAY
105540: PPUSH
105541: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
105545: LD_EXP 208
105549: PUSH
105550: LD_VAR 0 2
105554: ARRAY
105555: PUSH
105556: LD_EXP 208
105560: PUSH
105561: LD_VAR 0 2
105565: ARRAY
105566: PUSH
105567: LD_INT 1
105569: ARRAY
105570: PPUSH
105571: CALL_OW 314
105575: NOT
105576: AND
105577: PUSH
105578: LD_EXP 208
105582: PUSH
105583: LD_VAR 0 2
105587: ARRAY
105588: PUSH
105589: LD_INT 1
105591: ARRAY
105592: PPUSH
105593: CALL_OW 310
105597: NOT
105598: AND
105599: IFFALSE 105625
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
105601: LD_EXP 208
105605: PUSH
105606: LD_VAR 0 2
105610: ARRAY
105611: PUSH
105612: LD_INT 1
105614: ARRAY
105615: PPUSH
105616: LD_VAR 0 3
105620: PPUSH
105621: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
105625: LD_EXP 208
105629: PUSH
105630: LD_VAR 0 2
105634: ARRAY
105635: PUSH
105636: LD_INT 1
105638: ARRAY
105639: PPUSH
105640: CALL_OW 310
105644: PUSH
105645: LD_EXP 208
105649: PUSH
105650: LD_VAR 0 2
105654: ARRAY
105655: PUSH
105656: LD_INT 1
105658: ARRAY
105659: PPUSH
105660: CALL_OW 310
105664: PPUSH
105665: CALL_OW 461
105669: PUSH
105670: LD_INT 3
105672: NONEQUAL
105673: AND
105674: IFFALSE 105695
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
105676: LD_EXP 208
105680: PUSH
105681: LD_VAR 0 2
105685: ARRAY
105686: PUSH
105687: LD_INT 1
105689: ARRAY
105690: PPUSH
105691: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
105695: LD_VAR 0 3
105699: PPUSH
105700: CALL_OW 461
105704: PUSH
105705: LD_INT 6
105707: EQUAL
105708: PUSH
105709: LD_VAR 0 6
105713: PUSH
105714: LD_INT 1
105716: GREATER
105717: AND
105718: IFFALSE 105870
// begin sci := [ ] ;
105720: LD_ADDR_VAR 0 8
105724: PUSH
105725: EMPTY
105726: ST_TO_ADDR
// for x in ( tmp diff j ) do
105727: LD_ADDR_VAR 0 7
105731: PUSH
105732: LD_VAR 0 6
105736: PUSH
105737: LD_VAR 0 3
105741: DIFF
105742: PUSH
105743: FOR_IN
105744: IFFALSE 105796
// begin if sci = 6 then
105746: LD_VAR 0 8
105750: PUSH
105751: LD_INT 6
105753: EQUAL
105754: IFFALSE 105758
// break ;
105756: GO 105796
// if BuildingStatus ( x ) = bs_idle then
105758: LD_VAR 0 7
105762: PPUSH
105763: CALL_OW 461
105767: PUSH
105768: LD_INT 2
105770: EQUAL
105771: IFFALSE 105794
// sci := sci ^ UnitsInside ( x ) ;
105773: LD_ADDR_VAR 0 8
105777: PUSH
105778: LD_VAR 0 8
105782: PUSH
105783: LD_VAR 0 7
105787: PPUSH
105788: CALL_OW 313
105792: ADD
105793: ST_TO_ADDR
// end ;
105794: GO 105743
105796: POP
105797: POP
// if not sci then
105798: LD_VAR 0 8
105802: NOT
105803: IFFALSE 105807
// continue ;
105805: GO 104852
// for x in sci do
105807: LD_ADDR_VAR 0 7
105811: PUSH
105812: LD_VAR 0 8
105816: PUSH
105817: FOR_IN
105818: IFFALSE 105868
// if IsInUnit ( x ) and not HasTask ( x ) then
105820: LD_VAR 0 7
105824: PPUSH
105825: CALL_OW 310
105829: PUSH
105830: LD_VAR 0 7
105834: PPUSH
105835: CALL_OW 314
105839: NOT
105840: AND
105841: IFFALSE 105866
// begin ComExitBuilding ( x ) ;
105843: LD_VAR 0 7
105847: PPUSH
105848: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
105852: LD_VAR 0 7
105856: PPUSH
105857: LD_VAR 0 3
105861: PPUSH
105862: CALL_OW 180
// end ;
105866: GO 105817
105868: POP
105869: POP
// end ; end ;
105870: GO 104852
105872: POP
105873: POP
// end ;
105874: GO 104806
105876: POP
105877: POP
// end ;
105878: LD_VAR 0 1
105882: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
105883: LD_INT 0
105885: PPUSH
105886: PPUSH
// if not mc_bases then
105887: LD_EXP 178
105891: NOT
105892: IFFALSE 105896
// exit ;
105894: GO 105977
// for i = 1 to mc_bases do
105896: LD_ADDR_VAR 0 2
105900: PUSH
105901: DOUBLE
105902: LD_INT 1
105904: DEC
105905: ST_TO_ADDR
105906: LD_EXP 178
105910: PUSH
105911: FOR_TO
105912: IFFALSE 105975
// if mc_mines [ i ] and mc_miners [ i ] then
105914: LD_EXP 191
105918: PUSH
105919: LD_VAR 0 2
105923: ARRAY
105924: PUSH
105925: LD_EXP 192
105929: PUSH
105930: LD_VAR 0 2
105934: ARRAY
105935: AND
105936: IFFALSE 105973
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
105938: LD_EXP 192
105942: PUSH
105943: LD_VAR 0 2
105947: ARRAY
105948: PUSH
105949: LD_INT 1
105951: ARRAY
105952: PPUSH
105953: CALL_OW 255
105957: PPUSH
105958: LD_EXP 191
105962: PUSH
105963: LD_VAR 0 2
105967: ARRAY
105968: PPUSH
105969: CALL 21163 0 2
105973: GO 105911
105975: POP
105976: POP
// end ;
105977: LD_VAR 0 1
105981: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
105982: LD_INT 0
105984: PPUSH
105985: PPUSH
105986: PPUSH
105987: PPUSH
105988: PPUSH
105989: PPUSH
105990: PPUSH
105991: PPUSH
// if not mc_bases or not mc_parking then
105992: LD_EXP 178
105996: NOT
105997: PUSH
105998: LD_EXP 202
106002: NOT
106003: OR
106004: IFFALSE 106008
// exit ;
106006: GO 106718
// for i = 1 to mc_bases do
106008: LD_ADDR_VAR 0 2
106012: PUSH
106013: DOUBLE
106014: LD_INT 1
106016: DEC
106017: ST_TO_ADDR
106018: LD_EXP 178
106022: PUSH
106023: FOR_TO
106024: IFFALSE 106716
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
106026: LD_EXP 178
106030: PUSH
106031: LD_VAR 0 2
106035: ARRAY
106036: NOT
106037: PUSH
106038: LD_EXP 202
106042: PUSH
106043: LD_VAR 0 2
106047: ARRAY
106048: NOT
106049: OR
106050: IFFALSE 106054
// continue ;
106052: GO 106023
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
106054: LD_ADDR_VAR 0 5
106058: PUSH
106059: LD_EXP 178
106063: PUSH
106064: LD_VAR 0 2
106068: ARRAY
106069: PUSH
106070: LD_INT 1
106072: ARRAY
106073: PPUSH
106074: CALL_OW 255
106078: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
106079: LD_ADDR_VAR 0 6
106083: PUSH
106084: LD_EXP 178
106088: PUSH
106089: LD_VAR 0 2
106093: ARRAY
106094: PPUSH
106095: LD_INT 30
106097: PUSH
106098: LD_INT 3
106100: PUSH
106101: EMPTY
106102: LIST
106103: LIST
106104: PPUSH
106105: CALL_OW 72
106109: ST_TO_ADDR
// if not fac then
106110: LD_VAR 0 6
106114: NOT
106115: IFFALSE 106166
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
106117: LD_ADDR_VAR 0 6
106121: PUSH
106122: LD_EXP 178
106126: PUSH
106127: LD_VAR 0 2
106131: ARRAY
106132: PPUSH
106133: LD_INT 2
106135: PUSH
106136: LD_INT 30
106138: PUSH
106139: LD_INT 0
106141: PUSH
106142: EMPTY
106143: LIST
106144: LIST
106145: PUSH
106146: LD_INT 30
106148: PUSH
106149: LD_INT 1
106151: PUSH
106152: EMPTY
106153: LIST
106154: LIST
106155: PUSH
106156: EMPTY
106157: LIST
106158: LIST
106159: LIST
106160: PPUSH
106161: CALL_OW 72
106165: ST_TO_ADDR
// if not fac then
106166: LD_VAR 0 6
106170: NOT
106171: IFFALSE 106175
// continue ;
106173: GO 106023
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
106175: LD_ADDR_VAR 0 7
106179: PUSH
106180: LD_EXP 202
106184: PUSH
106185: LD_VAR 0 2
106189: ARRAY
106190: PPUSH
106191: LD_INT 22
106193: PUSH
106194: LD_VAR 0 5
106198: PUSH
106199: EMPTY
106200: LIST
106201: LIST
106202: PUSH
106203: LD_INT 21
106205: PUSH
106206: LD_INT 2
106208: PUSH
106209: EMPTY
106210: LIST
106211: LIST
106212: PUSH
106213: LD_INT 3
106215: PUSH
106216: LD_INT 24
106218: PUSH
106219: LD_INT 1000
106221: PUSH
106222: EMPTY
106223: LIST
106224: LIST
106225: PUSH
106226: EMPTY
106227: LIST
106228: LIST
106229: PUSH
106230: EMPTY
106231: LIST
106232: LIST
106233: LIST
106234: PPUSH
106235: CALL_OW 70
106239: ST_TO_ADDR
// for j in fac do
106240: LD_ADDR_VAR 0 3
106244: PUSH
106245: LD_VAR 0 6
106249: PUSH
106250: FOR_IN
106251: IFFALSE 106332
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
106253: LD_ADDR_VAR 0 7
106257: PUSH
106258: LD_VAR 0 7
106262: PUSH
106263: LD_INT 22
106265: PUSH
106266: LD_VAR 0 5
106270: PUSH
106271: EMPTY
106272: LIST
106273: LIST
106274: PUSH
106275: LD_INT 91
106277: PUSH
106278: LD_VAR 0 3
106282: PUSH
106283: LD_INT 15
106285: PUSH
106286: EMPTY
106287: LIST
106288: LIST
106289: LIST
106290: PUSH
106291: LD_INT 21
106293: PUSH
106294: LD_INT 2
106296: PUSH
106297: EMPTY
106298: LIST
106299: LIST
106300: PUSH
106301: LD_INT 3
106303: PUSH
106304: LD_INT 24
106306: PUSH
106307: LD_INT 1000
106309: PUSH
106310: EMPTY
106311: LIST
106312: LIST
106313: PUSH
106314: EMPTY
106315: LIST
106316: LIST
106317: PUSH
106318: EMPTY
106319: LIST
106320: LIST
106321: LIST
106322: LIST
106323: PPUSH
106324: CALL_OW 69
106328: UNION
106329: ST_TO_ADDR
106330: GO 106250
106332: POP
106333: POP
// if not vehs then
106334: LD_VAR 0 7
106338: NOT
106339: IFFALSE 106365
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
106341: LD_ADDR_EXP 190
106345: PUSH
106346: LD_EXP 190
106350: PPUSH
106351: LD_VAR 0 2
106355: PPUSH
106356: EMPTY
106357: PPUSH
106358: CALL_OW 1
106362: ST_TO_ADDR
// continue ;
106363: GO 106023
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
106365: LD_ADDR_VAR 0 8
106369: PUSH
106370: LD_EXP 178
106374: PUSH
106375: LD_VAR 0 2
106379: ARRAY
106380: PPUSH
106381: LD_INT 30
106383: PUSH
106384: LD_INT 3
106386: PUSH
106387: EMPTY
106388: LIST
106389: LIST
106390: PPUSH
106391: CALL_OW 72
106395: ST_TO_ADDR
// if tmp then
106396: LD_VAR 0 8
106400: IFFALSE 106503
// begin for j in tmp do
106402: LD_ADDR_VAR 0 3
106406: PUSH
106407: LD_VAR 0 8
106411: PUSH
106412: FOR_IN
106413: IFFALSE 106501
// for k in UnitsInside ( j ) do
106415: LD_ADDR_VAR 0 4
106419: PUSH
106420: LD_VAR 0 3
106424: PPUSH
106425: CALL_OW 313
106429: PUSH
106430: FOR_IN
106431: IFFALSE 106497
// if k then
106433: LD_VAR 0 4
106437: IFFALSE 106495
// if not k in mc_repair_vehicle [ i ] then
106439: LD_VAR 0 4
106443: PUSH
106444: LD_EXP 190
106448: PUSH
106449: LD_VAR 0 2
106453: ARRAY
106454: IN
106455: NOT
106456: IFFALSE 106495
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
106458: LD_ADDR_EXP 190
106462: PUSH
106463: LD_EXP 190
106467: PPUSH
106468: LD_VAR 0 2
106472: PPUSH
106473: LD_EXP 190
106477: PUSH
106478: LD_VAR 0 2
106482: ARRAY
106483: PUSH
106484: LD_VAR 0 4
106488: UNION
106489: PPUSH
106490: CALL_OW 1
106494: ST_TO_ADDR
106495: GO 106430
106497: POP
106498: POP
106499: GO 106412
106501: POP
106502: POP
// end ; if not mc_repair_vehicle [ i ] then
106503: LD_EXP 190
106507: PUSH
106508: LD_VAR 0 2
106512: ARRAY
106513: NOT
106514: IFFALSE 106518
// continue ;
106516: GO 106023
// for j in mc_repair_vehicle [ i ] do
106518: LD_ADDR_VAR 0 3
106522: PUSH
106523: LD_EXP 190
106527: PUSH
106528: LD_VAR 0 2
106532: ARRAY
106533: PUSH
106534: FOR_IN
106535: IFFALSE 106712
// begin if GetClass ( j ) <> 3 then
106537: LD_VAR 0 3
106541: PPUSH
106542: CALL_OW 257
106546: PUSH
106547: LD_INT 3
106549: NONEQUAL
106550: IFFALSE 106591
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
106552: LD_ADDR_EXP 190
106556: PUSH
106557: LD_EXP 190
106561: PPUSH
106562: LD_VAR 0 2
106566: PPUSH
106567: LD_EXP 190
106571: PUSH
106572: LD_VAR 0 2
106576: ARRAY
106577: PUSH
106578: LD_VAR 0 3
106582: DIFF
106583: PPUSH
106584: CALL_OW 1
106588: ST_TO_ADDR
// continue ;
106589: GO 106534
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
106591: LD_VAR 0 3
106595: PPUSH
106596: CALL_OW 311
106600: NOT
106601: PUSH
106602: LD_VAR 0 3
106606: PUSH
106607: LD_EXP 181
106611: PUSH
106612: LD_VAR 0 2
106616: ARRAY
106617: PUSH
106618: LD_INT 1
106620: ARRAY
106621: IN
106622: NOT
106623: AND
106624: PUSH
106625: LD_VAR 0 3
106629: PUSH
106630: LD_EXP 181
106634: PUSH
106635: LD_VAR 0 2
106639: ARRAY
106640: PUSH
106641: LD_INT 2
106643: ARRAY
106644: IN
106645: NOT
106646: AND
106647: IFFALSE 106710
// begin if IsInUnit ( j ) then
106649: LD_VAR 0 3
106653: PPUSH
106654: CALL_OW 310
106658: IFFALSE 106671
// ComExitBuilding ( j ) else
106660: LD_VAR 0 3
106664: PPUSH
106665: CALL_OW 122
106669: GO 106710
// if not WantToRepairVehicle ( j , vehs [ 1 ] ) then
106671: LD_VAR 0 3
106675: PPUSH
106676: LD_VAR 0 7
106680: PUSH
106681: LD_INT 1
106683: ARRAY
106684: PPUSH
106685: CALL 58692 0 2
106689: NOT
106690: IFFALSE 106710
// ComRepairVehicle ( j , vehs [ 1 ] ) ;
106692: LD_VAR 0 3
106696: PPUSH
106697: LD_VAR 0 7
106701: PUSH
106702: LD_INT 1
106704: ARRAY
106705: PPUSH
106706: CALL_OW 129
// end ; end ;
106710: GO 106534
106712: POP
106713: POP
// end ;
106714: GO 106023
106716: POP
106717: POP
// end ;
106718: LD_VAR 0 1
106722: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
106723: LD_INT 0
106725: PPUSH
106726: PPUSH
106727: PPUSH
106728: PPUSH
106729: PPUSH
106730: PPUSH
106731: PPUSH
106732: PPUSH
106733: PPUSH
106734: PPUSH
106735: PPUSH
// if not mc_bases then
106736: LD_EXP 178
106740: NOT
106741: IFFALSE 106745
// exit ;
106743: GO 107547
// for i = 1 to mc_bases do
106745: LD_ADDR_VAR 0 2
106749: PUSH
106750: DOUBLE
106751: LD_INT 1
106753: DEC
106754: ST_TO_ADDR
106755: LD_EXP 178
106759: PUSH
106760: FOR_TO
106761: IFFALSE 107545
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
106763: LD_EXP 206
106767: PUSH
106768: LD_VAR 0 2
106772: ARRAY
106773: NOT
106774: PUSH
106775: LD_EXP 181
106779: PUSH
106780: LD_VAR 0 2
106784: ARRAY
106785: PUSH
106786: LD_INT 1
106788: ARRAY
106789: OR
106790: PUSH
106791: LD_EXP 181
106795: PUSH
106796: LD_VAR 0 2
106800: ARRAY
106801: PUSH
106802: LD_INT 2
106804: ARRAY
106805: OR
106806: PUSH
106807: LD_EXP 204
106811: PUSH
106812: LD_VAR 0 2
106816: ARRAY
106817: PPUSH
106818: LD_INT 1
106820: PPUSH
106821: CALL_OW 325
106825: NOT
106826: OR
106827: PUSH
106828: LD_EXP 201
106832: PUSH
106833: LD_VAR 0 2
106837: ARRAY
106838: OR
106839: IFFALSE 106843
// continue ;
106841: GO 106760
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
106843: LD_ADDR_VAR 0 8
106847: PUSH
106848: LD_EXP 178
106852: PUSH
106853: LD_VAR 0 2
106857: ARRAY
106858: PPUSH
106859: LD_INT 25
106861: PUSH
106862: LD_INT 4
106864: PUSH
106865: EMPTY
106866: LIST
106867: LIST
106868: PUSH
106869: LD_INT 50
106871: PUSH
106872: EMPTY
106873: LIST
106874: PUSH
106875: LD_INT 3
106877: PUSH
106878: LD_INT 60
106880: PUSH
106881: EMPTY
106882: LIST
106883: PUSH
106884: EMPTY
106885: LIST
106886: LIST
106887: PUSH
106888: EMPTY
106889: LIST
106890: LIST
106891: LIST
106892: PPUSH
106893: CALL_OW 72
106897: PUSH
106898: LD_EXP 182
106902: PUSH
106903: LD_VAR 0 2
106907: ARRAY
106908: DIFF
106909: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
106910: LD_ADDR_VAR 0 9
106914: PUSH
106915: LD_EXP 178
106919: PUSH
106920: LD_VAR 0 2
106924: ARRAY
106925: PPUSH
106926: LD_INT 2
106928: PUSH
106929: LD_INT 30
106931: PUSH
106932: LD_INT 0
106934: PUSH
106935: EMPTY
106936: LIST
106937: LIST
106938: PUSH
106939: LD_INT 30
106941: PUSH
106942: LD_INT 1
106944: PUSH
106945: EMPTY
106946: LIST
106947: LIST
106948: PUSH
106949: EMPTY
106950: LIST
106951: LIST
106952: LIST
106953: PPUSH
106954: CALL_OW 72
106958: ST_TO_ADDR
// if not tmp or not dep then
106959: LD_VAR 0 8
106963: NOT
106964: PUSH
106965: LD_VAR 0 9
106969: NOT
106970: OR
106971: IFFALSE 106975
// continue ;
106973: GO 106760
// side := GetSide ( tmp [ 1 ] ) ;
106975: LD_ADDR_VAR 0 11
106979: PUSH
106980: LD_VAR 0 8
106984: PUSH
106985: LD_INT 1
106987: ARRAY
106988: PPUSH
106989: CALL_OW 255
106993: ST_TO_ADDR
// dep := dep [ 1 ] ;
106994: LD_ADDR_VAR 0 9
106998: PUSH
106999: LD_VAR 0 9
107003: PUSH
107004: LD_INT 1
107006: ARRAY
107007: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
107008: LD_ADDR_VAR 0 7
107012: PUSH
107013: LD_EXP 206
107017: PUSH
107018: LD_VAR 0 2
107022: ARRAY
107023: PPUSH
107024: LD_INT 22
107026: PUSH
107027: LD_INT 0
107029: PUSH
107030: EMPTY
107031: LIST
107032: LIST
107033: PUSH
107034: LD_INT 25
107036: PUSH
107037: LD_INT 12
107039: PUSH
107040: EMPTY
107041: LIST
107042: LIST
107043: PUSH
107044: EMPTY
107045: LIST
107046: LIST
107047: PPUSH
107048: CALL_OW 70
107052: PUSH
107053: LD_INT 22
107055: PUSH
107056: LD_INT 0
107058: PUSH
107059: EMPTY
107060: LIST
107061: LIST
107062: PUSH
107063: LD_INT 25
107065: PUSH
107066: LD_INT 12
107068: PUSH
107069: EMPTY
107070: LIST
107071: LIST
107072: PUSH
107073: LD_INT 91
107075: PUSH
107076: LD_VAR 0 9
107080: PUSH
107081: LD_INT 20
107083: PUSH
107084: EMPTY
107085: LIST
107086: LIST
107087: LIST
107088: PUSH
107089: EMPTY
107090: LIST
107091: LIST
107092: LIST
107093: PPUSH
107094: CALL_OW 69
107098: UNION
107099: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
107100: LD_ADDR_VAR 0 10
107104: PUSH
107105: LD_EXP 206
107109: PUSH
107110: LD_VAR 0 2
107114: ARRAY
107115: PPUSH
107116: LD_INT 81
107118: PUSH
107119: LD_VAR 0 11
107123: PUSH
107124: EMPTY
107125: LIST
107126: LIST
107127: PPUSH
107128: CALL_OW 70
107132: ST_TO_ADDR
// if not apes or danger_at_area then
107133: LD_VAR 0 7
107137: NOT
107138: PUSH
107139: LD_VAR 0 10
107143: OR
107144: IFFALSE 107194
// begin if mc_taming [ i ] then
107146: LD_EXP 209
107150: PUSH
107151: LD_VAR 0 2
107155: ARRAY
107156: IFFALSE 107192
// begin MC_Reset ( i , 121 ) ;
107158: LD_VAR 0 2
107162: PPUSH
107163: LD_INT 121
107165: PPUSH
107166: CALL 92180 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
107170: LD_ADDR_EXP 209
107174: PUSH
107175: LD_EXP 209
107179: PPUSH
107180: LD_VAR 0 2
107184: PPUSH
107185: EMPTY
107186: PPUSH
107187: CALL_OW 1
107191: ST_TO_ADDR
// end ; continue ;
107192: GO 106760
// end ; for j in tmp do
107194: LD_ADDR_VAR 0 3
107198: PUSH
107199: LD_VAR 0 8
107203: PUSH
107204: FOR_IN
107205: IFFALSE 107541
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
107207: LD_VAR 0 3
107211: PUSH
107212: LD_EXP 209
107216: PUSH
107217: LD_VAR 0 2
107221: ARRAY
107222: IN
107223: NOT
107224: PUSH
107225: LD_EXP 209
107229: PUSH
107230: LD_VAR 0 2
107234: ARRAY
107235: PUSH
107236: LD_INT 3
107238: LESS
107239: AND
107240: IFFALSE 107298
// begin SetTag ( j , 121 ) ;
107242: LD_VAR 0 3
107246: PPUSH
107247: LD_INT 121
107249: PPUSH
107250: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
107254: LD_ADDR_EXP 209
107258: PUSH
107259: LD_EXP 209
107263: PPUSH
107264: LD_VAR 0 2
107268: PUSH
107269: LD_EXP 209
107273: PUSH
107274: LD_VAR 0 2
107278: ARRAY
107279: PUSH
107280: LD_INT 1
107282: PLUS
107283: PUSH
107284: EMPTY
107285: LIST
107286: LIST
107287: PPUSH
107288: LD_VAR 0 3
107292: PPUSH
107293: CALL 24363 0 3
107297: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
107298: LD_VAR 0 3
107302: PUSH
107303: LD_EXP 209
107307: PUSH
107308: LD_VAR 0 2
107312: ARRAY
107313: IN
107314: IFFALSE 107539
// begin if GetClass ( j ) <> 4 then
107316: LD_VAR 0 3
107320: PPUSH
107321: CALL_OW 257
107325: PUSH
107326: LD_INT 4
107328: NONEQUAL
107329: IFFALSE 107382
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
107331: LD_ADDR_EXP 209
107335: PUSH
107336: LD_EXP 209
107340: PPUSH
107341: LD_VAR 0 2
107345: PPUSH
107346: LD_EXP 209
107350: PUSH
107351: LD_VAR 0 2
107355: ARRAY
107356: PUSH
107357: LD_VAR 0 3
107361: DIFF
107362: PPUSH
107363: CALL_OW 1
107367: ST_TO_ADDR
// SetTag ( j , 0 ) ;
107368: LD_VAR 0 3
107372: PPUSH
107373: LD_INT 0
107375: PPUSH
107376: CALL_OW 109
// continue ;
107380: GO 107204
// end ; if IsInUnit ( j ) then
107382: LD_VAR 0 3
107386: PPUSH
107387: CALL_OW 310
107391: IFFALSE 107402
// ComExitBuilding ( j ) ;
107393: LD_VAR 0 3
107397: PPUSH
107398: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
107402: LD_ADDR_VAR 0 6
107406: PUSH
107407: LD_VAR 0 7
107411: PPUSH
107412: LD_VAR 0 3
107416: PPUSH
107417: CALL_OW 74
107421: ST_TO_ADDR
// if not ape then
107422: LD_VAR 0 6
107426: NOT
107427: IFFALSE 107431
// break ;
107429: GO 107541
// x := GetX ( ape ) ;
107431: LD_ADDR_VAR 0 4
107435: PUSH
107436: LD_VAR 0 6
107440: PPUSH
107441: CALL_OW 250
107445: ST_TO_ADDR
// y := GetY ( ape ) ;
107446: LD_ADDR_VAR 0 5
107450: PUSH
107451: LD_VAR 0 6
107455: PPUSH
107456: CALL_OW 251
107460: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
107461: LD_VAR 0 4
107465: PPUSH
107466: LD_VAR 0 5
107470: PPUSH
107471: CALL_OW 488
107475: NOT
107476: PUSH
107477: LD_VAR 0 11
107481: PPUSH
107482: LD_VAR 0 4
107486: PPUSH
107487: LD_VAR 0 5
107491: PPUSH
107492: LD_INT 20
107494: PPUSH
107495: CALL 25259 0 4
107499: PUSH
107500: LD_INT 4
107502: ARRAY
107503: OR
107504: IFFALSE 107508
// break ;
107506: GO 107541
// if not HasTask ( j ) then
107508: LD_VAR 0 3
107512: PPUSH
107513: CALL_OW 314
107517: NOT
107518: IFFALSE 107539
// ComTameXY ( j , x , y ) ;
107520: LD_VAR 0 3
107524: PPUSH
107525: LD_VAR 0 4
107529: PPUSH
107530: LD_VAR 0 5
107534: PPUSH
107535: CALL_OW 131
// end ; end ;
107539: GO 107204
107541: POP
107542: POP
// end ;
107543: GO 106760
107545: POP
107546: POP
// end ;
107547: LD_VAR 0 1
107551: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
107552: LD_INT 0
107554: PPUSH
107555: PPUSH
107556: PPUSH
107557: PPUSH
107558: PPUSH
107559: PPUSH
107560: PPUSH
107561: PPUSH
// if not mc_bases then
107562: LD_EXP 178
107566: NOT
107567: IFFALSE 107571
// exit ;
107569: GO 108197
// for i = 1 to mc_bases do
107571: LD_ADDR_VAR 0 2
107575: PUSH
107576: DOUBLE
107577: LD_INT 1
107579: DEC
107580: ST_TO_ADDR
107581: LD_EXP 178
107585: PUSH
107586: FOR_TO
107587: IFFALSE 108195
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
107589: LD_EXP 207
107593: PUSH
107594: LD_VAR 0 2
107598: ARRAY
107599: NOT
107600: PUSH
107601: LD_EXP 207
107605: PUSH
107606: LD_VAR 0 2
107610: ARRAY
107611: PPUSH
107612: LD_INT 25
107614: PUSH
107615: LD_INT 12
107617: PUSH
107618: EMPTY
107619: LIST
107620: LIST
107621: PPUSH
107622: CALL_OW 72
107626: NOT
107627: OR
107628: IFFALSE 107632
// continue ;
107630: GO 107586
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
107632: LD_ADDR_VAR 0 5
107636: PUSH
107637: LD_EXP 207
107641: PUSH
107642: LD_VAR 0 2
107646: ARRAY
107647: PUSH
107648: LD_INT 1
107650: ARRAY
107651: PPUSH
107652: CALL_OW 255
107656: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
107657: LD_VAR 0 5
107661: PPUSH
107662: LD_INT 2
107664: PPUSH
107665: CALL_OW 325
107669: IFFALSE 107922
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
107671: LD_ADDR_VAR 0 4
107675: PUSH
107676: LD_EXP 207
107680: PUSH
107681: LD_VAR 0 2
107685: ARRAY
107686: PPUSH
107687: LD_INT 25
107689: PUSH
107690: LD_INT 16
107692: PUSH
107693: EMPTY
107694: LIST
107695: LIST
107696: PPUSH
107697: CALL_OW 72
107701: ST_TO_ADDR
// if tmp < 6 then
107702: LD_VAR 0 4
107706: PUSH
107707: LD_INT 6
107709: LESS
107710: IFFALSE 107922
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
107712: LD_ADDR_VAR 0 6
107716: PUSH
107717: LD_EXP 178
107721: PUSH
107722: LD_VAR 0 2
107726: ARRAY
107727: PPUSH
107728: LD_INT 2
107730: PUSH
107731: LD_INT 30
107733: PUSH
107734: LD_INT 0
107736: PUSH
107737: EMPTY
107738: LIST
107739: LIST
107740: PUSH
107741: LD_INT 30
107743: PUSH
107744: LD_INT 1
107746: PUSH
107747: EMPTY
107748: LIST
107749: LIST
107750: PUSH
107751: EMPTY
107752: LIST
107753: LIST
107754: LIST
107755: PPUSH
107756: CALL_OW 72
107760: ST_TO_ADDR
// if depot then
107761: LD_VAR 0 6
107765: IFFALSE 107922
// begin selected := 0 ;
107767: LD_ADDR_VAR 0 7
107771: PUSH
107772: LD_INT 0
107774: ST_TO_ADDR
// for j in depot do
107775: LD_ADDR_VAR 0 3
107779: PUSH
107780: LD_VAR 0 6
107784: PUSH
107785: FOR_IN
107786: IFFALSE 107817
// begin if UnitsInside ( j ) < 6 then
107788: LD_VAR 0 3
107792: PPUSH
107793: CALL_OW 313
107797: PUSH
107798: LD_INT 6
107800: LESS
107801: IFFALSE 107815
// begin selected := j ;
107803: LD_ADDR_VAR 0 7
107807: PUSH
107808: LD_VAR 0 3
107812: ST_TO_ADDR
// break ;
107813: GO 107817
// end ; end ;
107815: GO 107785
107817: POP
107818: POP
// if selected then
107819: LD_VAR 0 7
107823: IFFALSE 107922
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
107825: LD_ADDR_VAR 0 3
107829: PUSH
107830: LD_EXP 207
107834: PUSH
107835: LD_VAR 0 2
107839: ARRAY
107840: PPUSH
107841: LD_INT 25
107843: PUSH
107844: LD_INT 12
107846: PUSH
107847: EMPTY
107848: LIST
107849: LIST
107850: PPUSH
107851: CALL_OW 72
107855: PUSH
107856: FOR_IN
107857: IFFALSE 107920
// if not HasTask ( j ) then
107859: LD_VAR 0 3
107863: PPUSH
107864: CALL_OW 314
107868: NOT
107869: IFFALSE 107918
// begin if not IsInUnit ( j ) then
107871: LD_VAR 0 3
107875: PPUSH
107876: CALL_OW 310
107880: NOT
107881: IFFALSE 107897
// ComEnterUnit ( j , selected ) ;
107883: LD_VAR 0 3
107887: PPUSH
107888: LD_VAR 0 7
107892: PPUSH
107893: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
107897: LD_VAR 0 3
107901: PPUSH
107902: LD_INT 16
107904: PPUSH
107905: CALL_OW 183
// AddComExitBuilding ( j ) ;
107909: LD_VAR 0 3
107913: PPUSH
107914: CALL_OW 182
// end ;
107918: GO 107856
107920: POP
107921: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
107922: LD_VAR 0 5
107926: PPUSH
107927: LD_INT 11
107929: PPUSH
107930: CALL_OW 325
107934: IFFALSE 108193
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
107936: LD_ADDR_VAR 0 4
107940: PUSH
107941: LD_EXP 207
107945: PUSH
107946: LD_VAR 0 2
107950: ARRAY
107951: PPUSH
107952: LD_INT 25
107954: PUSH
107955: LD_INT 16
107957: PUSH
107958: EMPTY
107959: LIST
107960: LIST
107961: PPUSH
107962: CALL_OW 72
107966: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
107967: LD_VAR 0 4
107971: PUSH
107972: LD_INT 6
107974: GREATEREQUAL
107975: PUSH
107976: LD_VAR 0 5
107980: PPUSH
107981: LD_INT 2
107983: PPUSH
107984: CALL_OW 325
107988: NOT
107989: OR
107990: IFFALSE 108193
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
107992: LD_ADDR_VAR 0 8
107996: PUSH
107997: LD_EXP 178
108001: PUSH
108002: LD_VAR 0 2
108006: ARRAY
108007: PPUSH
108008: LD_INT 2
108010: PUSH
108011: LD_INT 30
108013: PUSH
108014: LD_INT 4
108016: PUSH
108017: EMPTY
108018: LIST
108019: LIST
108020: PUSH
108021: LD_INT 30
108023: PUSH
108024: LD_INT 5
108026: PUSH
108027: EMPTY
108028: LIST
108029: LIST
108030: PUSH
108031: EMPTY
108032: LIST
108033: LIST
108034: LIST
108035: PPUSH
108036: CALL_OW 72
108040: ST_TO_ADDR
// if barracks then
108041: LD_VAR 0 8
108045: IFFALSE 108193
// begin selected := 0 ;
108047: LD_ADDR_VAR 0 7
108051: PUSH
108052: LD_INT 0
108054: ST_TO_ADDR
// for j in barracks do
108055: LD_ADDR_VAR 0 3
108059: PUSH
108060: LD_VAR 0 8
108064: PUSH
108065: FOR_IN
108066: IFFALSE 108097
// begin if UnitsInside ( j ) < 6 then
108068: LD_VAR 0 3
108072: PPUSH
108073: CALL_OW 313
108077: PUSH
108078: LD_INT 6
108080: LESS
108081: IFFALSE 108095
// begin selected := j ;
108083: LD_ADDR_VAR 0 7
108087: PUSH
108088: LD_VAR 0 3
108092: ST_TO_ADDR
// break ;
108093: GO 108097
// end ; end ;
108095: GO 108065
108097: POP
108098: POP
// if selected then
108099: LD_VAR 0 7
108103: IFFALSE 108193
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
108105: LD_ADDR_VAR 0 3
108109: PUSH
108110: LD_EXP 207
108114: PUSH
108115: LD_VAR 0 2
108119: ARRAY
108120: PPUSH
108121: LD_INT 25
108123: PUSH
108124: LD_INT 12
108126: PUSH
108127: EMPTY
108128: LIST
108129: LIST
108130: PPUSH
108131: CALL_OW 72
108135: PUSH
108136: FOR_IN
108137: IFFALSE 108191
// if not IsInUnit ( j ) and not HasTask ( j ) then
108139: LD_VAR 0 3
108143: PPUSH
108144: CALL_OW 310
108148: NOT
108149: PUSH
108150: LD_VAR 0 3
108154: PPUSH
108155: CALL_OW 314
108159: NOT
108160: AND
108161: IFFALSE 108189
// begin ComEnterUnit ( j , selected ) ;
108163: LD_VAR 0 3
108167: PPUSH
108168: LD_VAR 0 7
108172: PPUSH
108173: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
108177: LD_VAR 0 3
108181: PPUSH
108182: LD_INT 15
108184: PPUSH
108185: CALL_OW 183
// end ;
108189: GO 108136
108191: POP
108192: POP
// end ; end ; end ; end ; end ;
108193: GO 107586
108195: POP
108196: POP
// end ;
108197: LD_VAR 0 1
108201: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
108202: LD_INT 0
108204: PPUSH
108205: PPUSH
108206: PPUSH
108207: PPUSH
// if not mc_bases then
108208: LD_EXP 178
108212: NOT
108213: IFFALSE 108217
// exit ;
108215: GO 108395
// for i = 1 to mc_bases do
108217: LD_ADDR_VAR 0 2
108221: PUSH
108222: DOUBLE
108223: LD_INT 1
108225: DEC
108226: ST_TO_ADDR
108227: LD_EXP 178
108231: PUSH
108232: FOR_TO
108233: IFFALSE 108393
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
108235: LD_ADDR_VAR 0 4
108239: PUSH
108240: LD_EXP 178
108244: PUSH
108245: LD_VAR 0 2
108249: ARRAY
108250: PPUSH
108251: LD_INT 25
108253: PUSH
108254: LD_INT 9
108256: PUSH
108257: EMPTY
108258: LIST
108259: LIST
108260: PPUSH
108261: CALL_OW 72
108265: ST_TO_ADDR
// if not tmp then
108266: LD_VAR 0 4
108270: NOT
108271: IFFALSE 108275
// continue ;
108273: GO 108232
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
108275: LD_EXP 204
108279: PUSH
108280: LD_VAR 0 2
108284: ARRAY
108285: PPUSH
108286: LD_INT 29
108288: PPUSH
108289: CALL_OW 325
108293: NOT
108294: PUSH
108295: LD_EXP 204
108299: PUSH
108300: LD_VAR 0 2
108304: ARRAY
108305: PPUSH
108306: LD_INT 28
108308: PPUSH
108309: CALL_OW 325
108313: NOT
108314: AND
108315: IFFALSE 108319
// continue ;
108317: GO 108232
// for j in tmp do
108319: LD_ADDR_VAR 0 3
108323: PUSH
108324: LD_VAR 0 4
108328: PUSH
108329: FOR_IN
108330: IFFALSE 108389
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
108332: LD_VAR 0 3
108336: PUSH
108337: LD_EXP 181
108341: PUSH
108342: LD_VAR 0 2
108346: ARRAY
108347: PUSH
108348: LD_INT 1
108350: ARRAY
108351: IN
108352: NOT
108353: PUSH
108354: LD_VAR 0 3
108358: PUSH
108359: LD_EXP 181
108363: PUSH
108364: LD_VAR 0 2
108368: ARRAY
108369: PUSH
108370: LD_INT 2
108372: ARRAY
108373: IN
108374: NOT
108375: AND
108376: IFFALSE 108387
// ComSpaceTimeShoot ( j ) ;
108378: LD_VAR 0 3
108382: PPUSH
108383: CALL 20171 0 1
108387: GO 108329
108389: POP
108390: POP
// end ;
108391: GO 108232
108393: POP
108394: POP
// end ;
108395: LD_VAR 0 1
108399: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
108400: LD_INT 0
108402: PPUSH
108403: PPUSH
108404: PPUSH
108405: PPUSH
108406: PPUSH
108407: PPUSH
108408: PPUSH
108409: PPUSH
108410: PPUSH
// if not mc_bases then
108411: LD_EXP 178
108415: NOT
108416: IFFALSE 108420
// exit ;
108418: GO 109042
// for i = 1 to mc_bases do
108420: LD_ADDR_VAR 0 2
108424: PUSH
108425: DOUBLE
108426: LD_INT 1
108428: DEC
108429: ST_TO_ADDR
108430: LD_EXP 178
108434: PUSH
108435: FOR_TO
108436: IFFALSE 109040
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
108438: LD_EXP 213
108442: PUSH
108443: LD_VAR 0 2
108447: ARRAY
108448: NOT
108449: PUSH
108450: LD_INT 38
108452: PPUSH
108453: LD_EXP 204
108457: PUSH
108458: LD_VAR 0 2
108462: ARRAY
108463: PPUSH
108464: CALL_OW 321
108468: PUSH
108469: LD_INT 2
108471: NONEQUAL
108472: OR
108473: IFFALSE 108477
// continue ;
108475: GO 108435
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
108477: LD_ADDR_VAR 0 8
108481: PUSH
108482: LD_EXP 178
108486: PUSH
108487: LD_VAR 0 2
108491: ARRAY
108492: PPUSH
108493: LD_INT 30
108495: PUSH
108496: LD_INT 34
108498: PUSH
108499: EMPTY
108500: LIST
108501: LIST
108502: PPUSH
108503: CALL_OW 72
108507: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
108508: LD_ADDR_VAR 0 9
108512: PUSH
108513: LD_EXP 178
108517: PUSH
108518: LD_VAR 0 2
108522: ARRAY
108523: PPUSH
108524: LD_INT 25
108526: PUSH
108527: LD_INT 4
108529: PUSH
108530: EMPTY
108531: LIST
108532: LIST
108533: PPUSH
108534: CALL_OW 72
108538: PPUSH
108539: LD_INT 0
108541: PPUSH
108542: CALL 54199 0 2
108546: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
108547: LD_VAR 0 9
108551: NOT
108552: PUSH
108553: LD_VAR 0 8
108557: NOT
108558: OR
108559: PUSH
108560: LD_EXP 178
108564: PUSH
108565: LD_VAR 0 2
108569: ARRAY
108570: PPUSH
108571: LD_INT 124
108573: PPUSH
108574: CALL 54199 0 2
108578: OR
108579: IFFALSE 108583
// continue ;
108581: GO 108435
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
108583: LD_EXP 214
108587: PUSH
108588: LD_VAR 0 2
108592: ARRAY
108593: PUSH
108594: LD_EXP 213
108598: PUSH
108599: LD_VAR 0 2
108603: ARRAY
108604: LESS
108605: PUSH
108606: LD_EXP 214
108610: PUSH
108611: LD_VAR 0 2
108615: ARRAY
108616: PUSH
108617: LD_VAR 0 8
108621: LESS
108622: AND
108623: IFFALSE 109038
// begin tmp := sci [ 1 ] ;
108625: LD_ADDR_VAR 0 7
108629: PUSH
108630: LD_VAR 0 9
108634: PUSH
108635: LD_INT 1
108637: ARRAY
108638: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
108639: LD_VAR 0 7
108643: PPUSH
108644: LD_INT 124
108646: PPUSH
108647: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
108651: LD_ADDR_VAR 0 3
108655: PUSH
108656: DOUBLE
108657: LD_EXP 213
108661: PUSH
108662: LD_VAR 0 2
108666: ARRAY
108667: INC
108668: ST_TO_ADDR
108669: LD_EXP 213
108673: PUSH
108674: LD_VAR 0 2
108678: ARRAY
108679: PUSH
108680: FOR_DOWNTO
108681: IFFALSE 109024
// begin if IsInUnit ( tmp ) then
108683: LD_VAR 0 7
108687: PPUSH
108688: CALL_OW 310
108692: IFFALSE 108703
// ComExitBuilding ( tmp ) ;
108694: LD_VAR 0 7
108698: PPUSH
108699: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
108703: LD_INT 35
108705: PPUSH
108706: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
108710: LD_VAR 0 7
108714: PPUSH
108715: CALL_OW 310
108719: NOT
108720: PUSH
108721: LD_VAR 0 7
108725: PPUSH
108726: CALL_OW 314
108730: NOT
108731: AND
108732: IFFALSE 108703
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
108734: LD_ADDR_VAR 0 6
108738: PUSH
108739: LD_VAR 0 7
108743: PPUSH
108744: CALL_OW 250
108748: PUSH
108749: LD_VAR 0 7
108753: PPUSH
108754: CALL_OW 251
108758: PUSH
108759: EMPTY
108760: LIST
108761: LIST
108762: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
108763: LD_INT 35
108765: PPUSH
108766: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
108770: LD_ADDR_VAR 0 4
108774: PUSH
108775: LD_EXP 213
108779: PUSH
108780: LD_VAR 0 2
108784: ARRAY
108785: PUSH
108786: LD_VAR 0 3
108790: ARRAY
108791: PUSH
108792: LD_INT 1
108794: ARRAY
108795: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
108796: LD_ADDR_VAR 0 5
108800: PUSH
108801: LD_EXP 213
108805: PUSH
108806: LD_VAR 0 2
108810: ARRAY
108811: PUSH
108812: LD_VAR 0 3
108816: ARRAY
108817: PUSH
108818: LD_INT 2
108820: ARRAY
108821: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
108822: LD_VAR 0 7
108826: PPUSH
108827: LD_INT 10
108829: PPUSH
108830: CALL 26962 0 2
108834: PUSH
108835: LD_INT 4
108837: ARRAY
108838: IFFALSE 108876
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
108840: LD_VAR 0 7
108844: PPUSH
108845: LD_VAR 0 6
108849: PUSH
108850: LD_INT 1
108852: ARRAY
108853: PPUSH
108854: LD_VAR 0 6
108858: PUSH
108859: LD_INT 2
108861: ARRAY
108862: PPUSH
108863: CALL_OW 111
// wait ( 0 0$10 ) ;
108867: LD_INT 350
108869: PPUSH
108870: CALL_OW 67
// end else
108874: GO 108902
// begin ComMoveXY ( tmp , x , y ) ;
108876: LD_VAR 0 7
108880: PPUSH
108881: LD_VAR 0 4
108885: PPUSH
108886: LD_VAR 0 5
108890: PPUSH
108891: CALL_OW 111
// wait ( 0 0$3 ) ;
108895: LD_INT 105
108897: PPUSH
108898: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
108902: LD_VAR 0 7
108906: PPUSH
108907: LD_VAR 0 4
108911: PPUSH
108912: LD_VAR 0 5
108916: PPUSH
108917: CALL_OW 307
108921: IFFALSE 108763
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
108923: LD_VAR 0 7
108927: PPUSH
108928: LD_VAR 0 4
108932: PPUSH
108933: LD_VAR 0 5
108937: PPUSH
108938: LD_VAR 0 8
108942: PUSH
108943: LD_VAR 0 3
108947: ARRAY
108948: PPUSH
108949: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
108953: LD_INT 35
108955: PPUSH
108956: CALL_OW 67
// until not HasTask ( tmp ) ;
108960: LD_VAR 0 7
108964: PPUSH
108965: CALL_OW 314
108969: NOT
108970: IFFALSE 108953
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
108972: LD_ADDR_EXP 214
108976: PUSH
108977: LD_EXP 214
108981: PPUSH
108982: LD_VAR 0 2
108986: PUSH
108987: LD_EXP 214
108991: PUSH
108992: LD_VAR 0 2
108996: ARRAY
108997: PUSH
108998: LD_INT 1
109000: PLUS
109001: PUSH
109002: EMPTY
109003: LIST
109004: LIST
109005: PPUSH
109006: LD_VAR 0 8
109010: PUSH
109011: LD_VAR 0 3
109015: ARRAY
109016: PPUSH
109017: CALL 24363 0 3
109021: ST_TO_ADDR
// end ;
109022: GO 108680
109024: POP
109025: POP
// MC_Reset ( i , 124 ) ;
109026: LD_VAR 0 2
109030: PPUSH
109031: LD_INT 124
109033: PPUSH
109034: CALL 92180 0 2
// end ; end ;
109038: GO 108435
109040: POP
109041: POP
// end ;
109042: LD_VAR 0 1
109046: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
109047: LD_INT 0
109049: PPUSH
109050: PPUSH
109051: PPUSH
// if not mc_bases then
109052: LD_EXP 178
109056: NOT
109057: IFFALSE 109061
// exit ;
109059: GO 109667
// for i = 1 to mc_bases do
109061: LD_ADDR_VAR 0 2
109065: PUSH
109066: DOUBLE
109067: LD_INT 1
109069: DEC
109070: ST_TO_ADDR
109071: LD_EXP 178
109075: PUSH
109076: FOR_TO
109077: IFFALSE 109665
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
109079: LD_ADDR_VAR 0 3
109083: PUSH
109084: LD_EXP 178
109088: PUSH
109089: LD_VAR 0 2
109093: ARRAY
109094: PPUSH
109095: LD_INT 25
109097: PUSH
109098: LD_INT 4
109100: PUSH
109101: EMPTY
109102: LIST
109103: LIST
109104: PPUSH
109105: CALL_OW 72
109109: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
109110: LD_VAR 0 3
109114: NOT
109115: PUSH
109116: LD_EXP 215
109120: PUSH
109121: LD_VAR 0 2
109125: ARRAY
109126: NOT
109127: OR
109128: PUSH
109129: LD_EXP 178
109133: PUSH
109134: LD_VAR 0 2
109138: ARRAY
109139: PPUSH
109140: LD_INT 2
109142: PUSH
109143: LD_INT 30
109145: PUSH
109146: LD_INT 0
109148: PUSH
109149: EMPTY
109150: LIST
109151: LIST
109152: PUSH
109153: LD_INT 30
109155: PUSH
109156: LD_INT 1
109158: PUSH
109159: EMPTY
109160: LIST
109161: LIST
109162: PUSH
109163: EMPTY
109164: LIST
109165: LIST
109166: LIST
109167: PPUSH
109168: CALL_OW 72
109172: NOT
109173: OR
109174: IFFALSE 109224
// begin if mc_deposits_finder [ i ] then
109176: LD_EXP 216
109180: PUSH
109181: LD_VAR 0 2
109185: ARRAY
109186: IFFALSE 109222
// begin MC_Reset ( i , 125 ) ;
109188: LD_VAR 0 2
109192: PPUSH
109193: LD_INT 125
109195: PPUSH
109196: CALL 92180 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
109200: LD_ADDR_EXP 216
109204: PUSH
109205: LD_EXP 216
109209: PPUSH
109210: LD_VAR 0 2
109214: PPUSH
109215: EMPTY
109216: PPUSH
109217: CALL_OW 1
109221: ST_TO_ADDR
// end ; continue ;
109222: GO 109076
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
109224: LD_EXP 215
109228: PUSH
109229: LD_VAR 0 2
109233: ARRAY
109234: PUSH
109235: LD_INT 1
109237: ARRAY
109238: PUSH
109239: LD_INT 3
109241: ARRAY
109242: PUSH
109243: LD_INT 1
109245: EQUAL
109246: PUSH
109247: LD_INT 20
109249: PPUSH
109250: LD_EXP 204
109254: PUSH
109255: LD_VAR 0 2
109259: ARRAY
109260: PPUSH
109261: CALL_OW 321
109265: PUSH
109266: LD_INT 2
109268: NONEQUAL
109269: AND
109270: IFFALSE 109320
// begin if mc_deposits_finder [ i ] then
109272: LD_EXP 216
109276: PUSH
109277: LD_VAR 0 2
109281: ARRAY
109282: IFFALSE 109318
// begin MC_Reset ( i , 125 ) ;
109284: LD_VAR 0 2
109288: PPUSH
109289: LD_INT 125
109291: PPUSH
109292: CALL 92180 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
109296: LD_ADDR_EXP 216
109300: PUSH
109301: LD_EXP 216
109305: PPUSH
109306: LD_VAR 0 2
109310: PPUSH
109311: EMPTY
109312: PPUSH
109313: CALL_OW 1
109317: ST_TO_ADDR
// end ; continue ;
109318: GO 109076
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
109320: LD_EXP 215
109324: PUSH
109325: LD_VAR 0 2
109329: ARRAY
109330: PUSH
109331: LD_INT 1
109333: ARRAY
109334: PUSH
109335: LD_INT 1
109337: ARRAY
109338: PPUSH
109339: LD_EXP 215
109343: PUSH
109344: LD_VAR 0 2
109348: ARRAY
109349: PUSH
109350: LD_INT 1
109352: ARRAY
109353: PUSH
109354: LD_INT 2
109356: ARRAY
109357: PPUSH
109358: LD_EXP 204
109362: PUSH
109363: LD_VAR 0 2
109367: ARRAY
109368: PPUSH
109369: CALL_OW 440
109373: IFFALSE 109416
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
109375: LD_ADDR_EXP 215
109379: PUSH
109380: LD_EXP 215
109384: PPUSH
109385: LD_VAR 0 2
109389: PPUSH
109390: LD_EXP 215
109394: PUSH
109395: LD_VAR 0 2
109399: ARRAY
109400: PPUSH
109401: LD_INT 1
109403: PPUSH
109404: CALL_OW 3
109408: PPUSH
109409: CALL_OW 1
109413: ST_TO_ADDR
109414: GO 109663
// begin if not mc_deposits_finder [ i ] then
109416: LD_EXP 216
109420: PUSH
109421: LD_VAR 0 2
109425: ARRAY
109426: NOT
109427: IFFALSE 109479
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
109429: LD_ADDR_EXP 216
109433: PUSH
109434: LD_EXP 216
109438: PPUSH
109439: LD_VAR 0 2
109443: PPUSH
109444: LD_VAR 0 3
109448: PUSH
109449: LD_INT 1
109451: ARRAY
109452: PUSH
109453: EMPTY
109454: LIST
109455: PPUSH
109456: CALL_OW 1
109460: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
109461: LD_VAR 0 3
109465: PUSH
109466: LD_INT 1
109468: ARRAY
109469: PPUSH
109470: LD_INT 125
109472: PPUSH
109473: CALL_OW 109
// end else
109477: GO 109663
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
109479: LD_EXP 216
109483: PUSH
109484: LD_VAR 0 2
109488: ARRAY
109489: PUSH
109490: LD_INT 1
109492: ARRAY
109493: PPUSH
109494: CALL_OW 310
109498: IFFALSE 109521
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
109500: LD_EXP 216
109504: PUSH
109505: LD_VAR 0 2
109509: ARRAY
109510: PUSH
109511: LD_INT 1
109513: ARRAY
109514: PPUSH
109515: CALL_OW 122
109519: GO 109663
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
109521: LD_EXP 216
109525: PUSH
109526: LD_VAR 0 2
109530: ARRAY
109531: PUSH
109532: LD_INT 1
109534: ARRAY
109535: PPUSH
109536: CALL_OW 314
109540: NOT
109541: PUSH
109542: LD_EXP 216
109546: PUSH
109547: LD_VAR 0 2
109551: ARRAY
109552: PUSH
109553: LD_INT 1
109555: ARRAY
109556: PPUSH
109557: LD_EXP 215
109561: PUSH
109562: LD_VAR 0 2
109566: ARRAY
109567: PUSH
109568: LD_INT 1
109570: ARRAY
109571: PUSH
109572: LD_INT 1
109574: ARRAY
109575: PPUSH
109576: LD_EXP 215
109580: PUSH
109581: LD_VAR 0 2
109585: ARRAY
109586: PUSH
109587: LD_INT 1
109589: ARRAY
109590: PUSH
109591: LD_INT 2
109593: ARRAY
109594: PPUSH
109595: CALL_OW 297
109599: PUSH
109600: LD_INT 6
109602: GREATER
109603: AND
109604: IFFALSE 109663
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
109606: LD_EXP 216
109610: PUSH
109611: LD_VAR 0 2
109615: ARRAY
109616: PUSH
109617: LD_INT 1
109619: ARRAY
109620: PPUSH
109621: LD_EXP 215
109625: PUSH
109626: LD_VAR 0 2
109630: ARRAY
109631: PUSH
109632: LD_INT 1
109634: ARRAY
109635: PUSH
109636: LD_INT 1
109638: ARRAY
109639: PPUSH
109640: LD_EXP 215
109644: PUSH
109645: LD_VAR 0 2
109649: ARRAY
109650: PUSH
109651: LD_INT 1
109653: ARRAY
109654: PUSH
109655: LD_INT 2
109657: ARRAY
109658: PPUSH
109659: CALL_OW 111
// end ; end ; end ;
109663: GO 109076
109665: POP
109666: POP
// end ;
109667: LD_VAR 0 1
109671: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
109672: LD_INT 0
109674: PPUSH
109675: PPUSH
109676: PPUSH
109677: PPUSH
109678: PPUSH
109679: PPUSH
109680: PPUSH
109681: PPUSH
109682: PPUSH
109683: PPUSH
109684: PPUSH
// if not mc_bases then
109685: LD_EXP 178
109689: NOT
109690: IFFALSE 109694
// exit ;
109692: GO 110634
// for i = 1 to mc_bases do
109694: LD_ADDR_VAR 0 2
109698: PUSH
109699: DOUBLE
109700: LD_INT 1
109702: DEC
109703: ST_TO_ADDR
109704: LD_EXP 178
109708: PUSH
109709: FOR_TO
109710: IFFALSE 110632
// begin if not mc_bases [ i ] or mc_scan [ i ] then
109712: LD_EXP 178
109716: PUSH
109717: LD_VAR 0 2
109721: ARRAY
109722: NOT
109723: PUSH
109724: LD_EXP 201
109728: PUSH
109729: LD_VAR 0 2
109733: ARRAY
109734: OR
109735: IFFALSE 109739
// continue ;
109737: GO 109709
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
109739: LD_ADDR_VAR 0 7
109743: PUSH
109744: LD_EXP 178
109748: PUSH
109749: LD_VAR 0 2
109753: ARRAY
109754: PUSH
109755: LD_INT 1
109757: ARRAY
109758: PPUSH
109759: CALL_OW 248
109763: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
109764: LD_VAR 0 7
109768: PUSH
109769: LD_INT 3
109771: EQUAL
109772: PUSH
109773: LD_EXP 197
109777: PUSH
109778: LD_VAR 0 2
109782: ARRAY
109783: PUSH
109784: LD_EXP 200
109788: PUSH
109789: LD_VAR 0 2
109793: ARRAY
109794: UNION
109795: PPUSH
109796: LD_INT 33
109798: PUSH
109799: LD_INT 2
109801: PUSH
109802: EMPTY
109803: LIST
109804: LIST
109805: PPUSH
109806: CALL_OW 72
109810: NOT
109811: OR
109812: IFFALSE 109816
// continue ;
109814: GO 109709
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
109816: LD_ADDR_VAR 0 9
109820: PUSH
109821: LD_EXP 178
109825: PUSH
109826: LD_VAR 0 2
109830: ARRAY
109831: PPUSH
109832: LD_INT 30
109834: PUSH
109835: LD_INT 36
109837: PUSH
109838: EMPTY
109839: LIST
109840: LIST
109841: PPUSH
109842: CALL_OW 72
109846: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
109847: LD_ADDR_VAR 0 10
109851: PUSH
109852: LD_EXP 197
109856: PUSH
109857: LD_VAR 0 2
109861: ARRAY
109862: PPUSH
109863: LD_INT 34
109865: PUSH
109866: LD_INT 31
109868: PUSH
109869: EMPTY
109870: LIST
109871: LIST
109872: PPUSH
109873: CALL_OW 72
109877: ST_TO_ADDR
// if not cts and not mcts then
109878: LD_VAR 0 9
109882: NOT
109883: PUSH
109884: LD_VAR 0 10
109888: NOT
109889: AND
109890: IFFALSE 109894
// continue ;
109892: GO 109709
// x := cts ;
109894: LD_ADDR_VAR 0 11
109898: PUSH
109899: LD_VAR 0 9
109903: ST_TO_ADDR
// if not x then
109904: LD_VAR 0 11
109908: NOT
109909: IFFALSE 109921
// x := mcts ;
109911: LD_ADDR_VAR 0 11
109915: PUSH
109916: LD_VAR 0 10
109920: ST_TO_ADDR
// if not x then
109921: LD_VAR 0 11
109925: NOT
109926: IFFALSE 109930
// continue ;
109928: GO 109709
// if mc_remote_driver [ i ] then
109930: LD_EXP 218
109934: PUSH
109935: LD_VAR 0 2
109939: ARRAY
109940: IFFALSE 110327
// for j in mc_remote_driver [ i ] do
109942: LD_ADDR_VAR 0 3
109946: PUSH
109947: LD_EXP 218
109951: PUSH
109952: LD_VAR 0 2
109956: ARRAY
109957: PUSH
109958: FOR_IN
109959: IFFALSE 110325
// begin if GetClass ( j ) <> 3 then
109961: LD_VAR 0 3
109965: PPUSH
109966: CALL_OW 257
109970: PUSH
109971: LD_INT 3
109973: NONEQUAL
109974: IFFALSE 110027
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
109976: LD_ADDR_EXP 218
109980: PUSH
109981: LD_EXP 218
109985: PPUSH
109986: LD_VAR 0 2
109990: PPUSH
109991: LD_EXP 218
109995: PUSH
109996: LD_VAR 0 2
110000: ARRAY
110001: PUSH
110002: LD_VAR 0 3
110006: DIFF
110007: PPUSH
110008: CALL_OW 1
110012: ST_TO_ADDR
// SetTag ( j , 0 ) ;
110013: LD_VAR 0 3
110017: PPUSH
110018: LD_INT 0
110020: PPUSH
110021: CALL_OW 109
// continue ;
110025: GO 109958
// end ; if UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) and not IsDriver ( j ) then
110027: LD_EXP 197
110031: PUSH
110032: LD_VAR 0 2
110036: ARRAY
110037: PPUSH
110038: LD_INT 34
110040: PUSH
110041: LD_INT 31
110043: PUSH
110044: EMPTY
110045: LIST
110046: LIST
110047: PUSH
110048: LD_INT 58
110050: PUSH
110051: EMPTY
110052: LIST
110053: PUSH
110054: EMPTY
110055: LIST
110056: LIST
110057: PPUSH
110058: CALL_OW 72
110062: PUSH
110063: LD_VAR 0 3
110067: PPUSH
110068: CALL 54234 0 1
110072: NOT
110073: AND
110074: IFFALSE 110145
// begin if IsInUnit ( j ) then
110076: LD_VAR 0 3
110080: PPUSH
110081: CALL_OW 310
110085: IFFALSE 110096
// ComExitBuilding ( j ) ;
110087: LD_VAR 0 3
110091: PPUSH
110092: CALL_OW 122
// AddComEnterUnit ( j , UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) [ 1 ] ) ;
110096: LD_VAR 0 3
110100: PPUSH
110101: LD_EXP 197
110105: PUSH
110106: LD_VAR 0 2
110110: ARRAY
110111: PPUSH
110112: LD_INT 34
110114: PUSH
110115: LD_INT 31
110117: PUSH
110118: EMPTY
110119: LIST
110120: LIST
110121: PUSH
110122: LD_INT 58
110124: PUSH
110125: EMPTY
110126: LIST
110127: PUSH
110128: EMPTY
110129: LIST
110130: LIST
110131: PPUSH
110132: CALL_OW 72
110136: PUSH
110137: LD_INT 1
110139: ARRAY
110140: PPUSH
110141: CALL_OW 180
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
110145: LD_VAR 0 3
110149: PPUSH
110150: CALL_OW 310
110154: NOT
110155: PUSH
110156: LD_VAR 0 3
110160: PPUSH
110161: CALL_OW 310
110165: PPUSH
110166: CALL_OW 266
110170: PUSH
110171: LD_INT 36
110173: NONEQUAL
110174: PUSH
110175: LD_VAR 0 3
110179: PPUSH
110180: CALL 54234 0 1
110184: NOT
110185: AND
110186: OR
110187: IFFALSE 110323
// begin if IsInUnit ( j ) then
110189: LD_VAR 0 3
110193: PPUSH
110194: CALL_OW 310
110198: IFFALSE 110209
// ComExitBuilding ( j ) ;
110200: LD_VAR 0 3
110204: PPUSH
110205: CALL_OW 122
// ct := 0 ;
110209: LD_ADDR_VAR 0 8
110213: PUSH
110214: LD_INT 0
110216: ST_TO_ADDR
// for k in x do
110217: LD_ADDR_VAR 0 4
110221: PUSH
110222: LD_VAR 0 11
110226: PUSH
110227: FOR_IN
110228: IFFALSE 110301
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
110230: LD_VAR 0 4
110234: PPUSH
110235: CALL_OW 264
110239: PUSH
110240: LD_INT 31
110242: EQUAL
110243: PUSH
110244: LD_VAR 0 4
110248: PPUSH
110249: CALL_OW 311
110253: NOT
110254: AND
110255: PUSH
110256: LD_VAR 0 4
110260: PPUSH
110261: CALL_OW 266
110265: PUSH
110266: LD_INT 36
110268: EQUAL
110269: PUSH
110270: LD_VAR 0 4
110274: PPUSH
110275: CALL_OW 313
110279: PUSH
110280: LD_INT 3
110282: LESS
110283: AND
110284: OR
110285: IFFALSE 110299
// begin ct := k ;
110287: LD_ADDR_VAR 0 8
110291: PUSH
110292: LD_VAR 0 4
110296: ST_TO_ADDR
// break ;
110297: GO 110301
// end ;
110299: GO 110227
110301: POP
110302: POP
// if ct then
110303: LD_VAR 0 8
110307: IFFALSE 110323
// ComEnterUnit ( j , ct ) ;
110309: LD_VAR 0 3
110313: PPUSH
110314: LD_VAR 0 8
110318: PPUSH
110319: CALL_OW 120
// end ; end ;
110323: GO 109958
110325: POP
110326: POP
// places := 0 ;
110327: LD_ADDR_VAR 0 5
110331: PUSH
110332: LD_INT 0
110334: ST_TO_ADDR
// for j = 1 to x do
110335: LD_ADDR_VAR 0 3
110339: PUSH
110340: DOUBLE
110341: LD_INT 1
110343: DEC
110344: ST_TO_ADDR
110345: LD_VAR 0 11
110349: PUSH
110350: FOR_TO
110351: IFFALSE 110427
// if GetWeapon ( x [ j ] ) = ar_control_tower then
110353: LD_VAR 0 11
110357: PUSH
110358: LD_VAR 0 3
110362: ARRAY
110363: PPUSH
110364: CALL_OW 264
110368: PUSH
110369: LD_INT 31
110371: EQUAL
110372: IFFALSE 110390
// places := places + 1 else
110374: LD_ADDR_VAR 0 5
110378: PUSH
110379: LD_VAR 0 5
110383: PUSH
110384: LD_INT 1
110386: PLUS
110387: ST_TO_ADDR
110388: GO 110425
// if GetBType ( x [ j ] ) = b_control_tower then
110390: LD_VAR 0 11
110394: PUSH
110395: LD_VAR 0 3
110399: ARRAY
110400: PPUSH
110401: CALL_OW 266
110405: PUSH
110406: LD_INT 36
110408: EQUAL
110409: IFFALSE 110425
// places := places + 3 ;
110411: LD_ADDR_VAR 0 5
110415: PUSH
110416: LD_VAR 0 5
110420: PUSH
110421: LD_INT 3
110423: PLUS
110424: ST_TO_ADDR
110425: GO 110350
110427: POP
110428: POP
// if places = 0 or places <= mc_remote_driver [ i ] then
110429: LD_VAR 0 5
110433: PUSH
110434: LD_INT 0
110436: EQUAL
110437: PUSH
110438: LD_VAR 0 5
110442: PUSH
110443: LD_EXP 218
110447: PUSH
110448: LD_VAR 0 2
110452: ARRAY
110453: LESSEQUAL
110454: OR
110455: IFFALSE 110459
// continue ;
110457: GO 109709
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
110459: LD_ADDR_VAR 0 6
110463: PUSH
110464: LD_EXP 178
110468: PUSH
110469: LD_VAR 0 2
110473: ARRAY
110474: PPUSH
110475: LD_INT 25
110477: PUSH
110478: LD_INT 3
110480: PUSH
110481: EMPTY
110482: LIST
110483: LIST
110484: PPUSH
110485: CALL_OW 72
110489: PUSH
110490: LD_EXP 218
110494: PUSH
110495: LD_VAR 0 2
110499: ARRAY
110500: DIFF
110501: PPUSH
110502: LD_INT 3
110504: PPUSH
110505: CALL 55134 0 2
110509: ST_TO_ADDR
// for j in tmp do
110510: LD_ADDR_VAR 0 3
110514: PUSH
110515: LD_VAR 0 6
110519: PUSH
110520: FOR_IN
110521: IFFALSE 110556
// if GetTag ( j ) > 0 then
110523: LD_VAR 0 3
110527: PPUSH
110528: CALL_OW 110
110532: PUSH
110533: LD_INT 0
110535: GREATER
110536: IFFALSE 110554
// tmp := tmp diff j ;
110538: LD_ADDR_VAR 0 6
110542: PUSH
110543: LD_VAR 0 6
110547: PUSH
110548: LD_VAR 0 3
110552: DIFF
110553: ST_TO_ADDR
110554: GO 110520
110556: POP
110557: POP
// if not tmp then
110558: LD_VAR 0 6
110562: NOT
110563: IFFALSE 110567
// continue ;
110565: GO 109709
// if places then
110567: LD_VAR 0 5
110571: IFFALSE 110630
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
110573: LD_ADDR_EXP 218
110577: PUSH
110578: LD_EXP 218
110582: PPUSH
110583: LD_VAR 0 2
110587: PPUSH
110588: LD_EXP 218
110592: PUSH
110593: LD_VAR 0 2
110597: ARRAY
110598: PUSH
110599: LD_VAR 0 6
110603: PUSH
110604: LD_INT 1
110606: ARRAY
110607: UNION
110608: PPUSH
110609: CALL_OW 1
110613: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
110614: LD_VAR 0 6
110618: PUSH
110619: LD_INT 1
110621: ARRAY
110622: PPUSH
110623: LD_INT 126
110625: PPUSH
110626: CALL_OW 109
// end ; end ;
110630: GO 109709
110632: POP
110633: POP
// end ;
110634: LD_VAR 0 1
110638: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
110639: LD_INT 0
110641: PPUSH
110642: PPUSH
110643: PPUSH
110644: PPUSH
110645: PPUSH
110646: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
110647: LD_VAR 0 1
110651: NOT
110652: PUSH
110653: LD_VAR 0 2
110657: NOT
110658: OR
110659: PUSH
110660: LD_VAR 0 3
110664: NOT
110665: OR
110666: PUSH
110667: LD_VAR 0 4
110671: PUSH
110672: LD_INT 1
110674: PUSH
110675: LD_INT 2
110677: PUSH
110678: LD_INT 3
110680: PUSH
110681: LD_INT 4
110683: PUSH
110684: LD_INT 5
110686: PUSH
110687: LD_INT 8
110689: PUSH
110690: LD_INT 9
110692: PUSH
110693: LD_INT 15
110695: PUSH
110696: LD_INT 16
110698: PUSH
110699: EMPTY
110700: LIST
110701: LIST
110702: LIST
110703: LIST
110704: LIST
110705: LIST
110706: LIST
110707: LIST
110708: LIST
110709: IN
110710: NOT
110711: OR
110712: IFFALSE 110716
// exit ;
110714: GO 111616
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
110716: LD_ADDR_VAR 0 2
110720: PUSH
110721: LD_VAR 0 2
110725: PPUSH
110726: LD_INT 21
110728: PUSH
110729: LD_INT 3
110731: PUSH
110732: EMPTY
110733: LIST
110734: LIST
110735: PUSH
110736: LD_INT 24
110738: PUSH
110739: LD_INT 250
110741: PUSH
110742: EMPTY
110743: LIST
110744: LIST
110745: PUSH
110746: EMPTY
110747: LIST
110748: LIST
110749: PPUSH
110750: CALL_OW 72
110754: ST_TO_ADDR
// case class of 1 , 15 :
110755: LD_VAR 0 4
110759: PUSH
110760: LD_INT 1
110762: DOUBLE
110763: EQUAL
110764: IFTRUE 110774
110766: LD_INT 15
110768: DOUBLE
110769: EQUAL
110770: IFTRUE 110774
110772: GO 110859
110774: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
110775: LD_ADDR_VAR 0 8
110779: PUSH
110780: LD_VAR 0 2
110784: PPUSH
110785: LD_INT 2
110787: PUSH
110788: LD_INT 30
110790: PUSH
110791: LD_INT 32
110793: PUSH
110794: EMPTY
110795: LIST
110796: LIST
110797: PUSH
110798: LD_INT 30
110800: PUSH
110801: LD_INT 31
110803: PUSH
110804: EMPTY
110805: LIST
110806: LIST
110807: PUSH
110808: EMPTY
110809: LIST
110810: LIST
110811: LIST
110812: PPUSH
110813: CALL_OW 72
110817: PUSH
110818: LD_VAR 0 2
110822: PPUSH
110823: LD_INT 2
110825: PUSH
110826: LD_INT 30
110828: PUSH
110829: LD_INT 4
110831: PUSH
110832: EMPTY
110833: LIST
110834: LIST
110835: PUSH
110836: LD_INT 30
110838: PUSH
110839: LD_INT 5
110841: PUSH
110842: EMPTY
110843: LIST
110844: LIST
110845: PUSH
110846: EMPTY
110847: LIST
110848: LIST
110849: LIST
110850: PPUSH
110851: CALL_OW 72
110855: ADD
110856: ST_TO_ADDR
110857: GO 111105
110859: LD_INT 2
110861: DOUBLE
110862: EQUAL
110863: IFTRUE 110873
110865: LD_INT 16
110867: DOUBLE
110868: EQUAL
110869: IFTRUE 110873
110871: GO 110919
110873: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
110874: LD_ADDR_VAR 0 8
110878: PUSH
110879: LD_VAR 0 2
110883: PPUSH
110884: LD_INT 2
110886: PUSH
110887: LD_INT 30
110889: PUSH
110890: LD_INT 0
110892: PUSH
110893: EMPTY
110894: LIST
110895: LIST
110896: PUSH
110897: LD_INT 30
110899: PUSH
110900: LD_INT 1
110902: PUSH
110903: EMPTY
110904: LIST
110905: LIST
110906: PUSH
110907: EMPTY
110908: LIST
110909: LIST
110910: LIST
110911: PPUSH
110912: CALL_OW 72
110916: ST_TO_ADDR
110917: GO 111105
110919: LD_INT 3
110921: DOUBLE
110922: EQUAL
110923: IFTRUE 110927
110925: GO 110973
110927: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
110928: LD_ADDR_VAR 0 8
110932: PUSH
110933: LD_VAR 0 2
110937: PPUSH
110938: LD_INT 2
110940: PUSH
110941: LD_INT 30
110943: PUSH
110944: LD_INT 2
110946: PUSH
110947: EMPTY
110948: LIST
110949: LIST
110950: PUSH
110951: LD_INT 30
110953: PUSH
110954: LD_INT 3
110956: PUSH
110957: EMPTY
110958: LIST
110959: LIST
110960: PUSH
110961: EMPTY
110962: LIST
110963: LIST
110964: LIST
110965: PPUSH
110966: CALL_OW 72
110970: ST_TO_ADDR
110971: GO 111105
110973: LD_INT 4
110975: DOUBLE
110976: EQUAL
110977: IFTRUE 110981
110979: GO 111038
110981: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
110982: LD_ADDR_VAR 0 8
110986: PUSH
110987: LD_VAR 0 2
110991: PPUSH
110992: LD_INT 2
110994: PUSH
110995: LD_INT 30
110997: PUSH
110998: LD_INT 6
111000: PUSH
111001: EMPTY
111002: LIST
111003: LIST
111004: PUSH
111005: LD_INT 30
111007: PUSH
111008: LD_INT 7
111010: PUSH
111011: EMPTY
111012: LIST
111013: LIST
111014: PUSH
111015: LD_INT 30
111017: PUSH
111018: LD_INT 8
111020: PUSH
111021: EMPTY
111022: LIST
111023: LIST
111024: PUSH
111025: EMPTY
111026: LIST
111027: LIST
111028: LIST
111029: LIST
111030: PPUSH
111031: CALL_OW 72
111035: ST_TO_ADDR
111036: GO 111105
111038: LD_INT 5
111040: DOUBLE
111041: EQUAL
111042: IFTRUE 111058
111044: LD_INT 8
111046: DOUBLE
111047: EQUAL
111048: IFTRUE 111058
111050: LD_INT 9
111052: DOUBLE
111053: EQUAL
111054: IFTRUE 111058
111056: GO 111104
111058: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
111059: LD_ADDR_VAR 0 8
111063: PUSH
111064: LD_VAR 0 2
111068: PPUSH
111069: LD_INT 2
111071: PUSH
111072: LD_INT 30
111074: PUSH
111075: LD_INT 4
111077: PUSH
111078: EMPTY
111079: LIST
111080: LIST
111081: PUSH
111082: LD_INT 30
111084: PUSH
111085: LD_INT 5
111087: PUSH
111088: EMPTY
111089: LIST
111090: LIST
111091: PUSH
111092: EMPTY
111093: LIST
111094: LIST
111095: LIST
111096: PPUSH
111097: CALL_OW 72
111101: ST_TO_ADDR
111102: GO 111105
111104: POP
// if not tmp then
111105: LD_VAR 0 8
111109: NOT
111110: IFFALSE 111114
// exit ;
111112: GO 111616
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
111114: LD_VAR 0 4
111118: PUSH
111119: LD_INT 1
111121: PUSH
111122: LD_INT 15
111124: PUSH
111125: EMPTY
111126: LIST
111127: LIST
111128: IN
111129: PUSH
111130: LD_EXP 187
111134: PUSH
111135: LD_VAR 0 1
111139: ARRAY
111140: AND
111141: IFFALSE 111297
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
111143: LD_ADDR_VAR 0 9
111147: PUSH
111148: LD_EXP 187
111152: PUSH
111153: LD_VAR 0 1
111157: ARRAY
111158: PUSH
111159: LD_INT 1
111161: ARRAY
111162: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
111163: LD_VAR 0 9
111167: PUSH
111168: LD_EXP 188
111172: PUSH
111173: LD_VAR 0 1
111177: ARRAY
111178: IN
111179: NOT
111180: IFFALSE 111295
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
111182: LD_ADDR_EXP 188
111186: PUSH
111187: LD_EXP 188
111191: PPUSH
111192: LD_VAR 0 1
111196: PUSH
111197: LD_EXP 188
111201: PUSH
111202: LD_VAR 0 1
111206: ARRAY
111207: PUSH
111208: LD_INT 1
111210: PLUS
111211: PUSH
111212: EMPTY
111213: LIST
111214: LIST
111215: PPUSH
111216: LD_VAR 0 9
111220: PPUSH
111221: CALL 24363 0 3
111225: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
111226: LD_ADDR_EXP 187
111230: PUSH
111231: LD_EXP 187
111235: PPUSH
111236: LD_VAR 0 1
111240: PPUSH
111241: LD_EXP 187
111245: PUSH
111246: LD_VAR 0 1
111250: ARRAY
111251: PUSH
111252: LD_VAR 0 9
111256: DIFF
111257: PPUSH
111258: CALL_OW 1
111262: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
111263: LD_VAR 0 3
111267: PPUSH
111268: LD_EXP 188
111272: PUSH
111273: LD_VAR 0 1
111277: ARRAY
111278: PUSH
111279: LD_EXP 188
111283: PUSH
111284: LD_VAR 0 1
111288: ARRAY
111289: ARRAY
111290: PPUSH
111291: CALL_OW 120
// end ; exit ;
111295: GO 111616
// end ; if tmp > 1 then
111297: LD_VAR 0 8
111301: PUSH
111302: LD_INT 1
111304: GREATER
111305: IFFALSE 111409
// for i = 2 to tmp do
111307: LD_ADDR_VAR 0 6
111311: PUSH
111312: DOUBLE
111313: LD_INT 2
111315: DEC
111316: ST_TO_ADDR
111317: LD_VAR 0 8
111321: PUSH
111322: FOR_TO
111323: IFFALSE 111407
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
111325: LD_VAR 0 8
111329: PUSH
111330: LD_VAR 0 6
111334: ARRAY
111335: PPUSH
111336: CALL_OW 461
111340: PUSH
111341: LD_INT 6
111343: EQUAL
111344: IFFALSE 111405
// begin x := tmp [ i ] ;
111346: LD_ADDR_VAR 0 9
111350: PUSH
111351: LD_VAR 0 8
111355: PUSH
111356: LD_VAR 0 6
111360: ARRAY
111361: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
111362: LD_ADDR_VAR 0 8
111366: PUSH
111367: LD_VAR 0 8
111371: PPUSH
111372: LD_VAR 0 6
111376: PPUSH
111377: CALL_OW 3
111381: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
111382: LD_ADDR_VAR 0 8
111386: PUSH
111387: LD_VAR 0 8
111391: PPUSH
111392: LD_INT 1
111394: PPUSH
111395: LD_VAR 0 9
111399: PPUSH
111400: CALL_OW 2
111404: ST_TO_ADDR
// end ;
111405: GO 111322
111407: POP
111408: POP
// for i in tmp do
111409: LD_ADDR_VAR 0 6
111413: PUSH
111414: LD_VAR 0 8
111418: PUSH
111419: FOR_IN
111420: IFFALSE 111489
// begin if ( UnitsInside ( i ) < 6 and not GetBType ( i ) in [ b_breastwork , b_bunker ] ) or UnitsInside ( i ) = 0 then
111422: LD_VAR 0 6
111426: PPUSH
111427: CALL_OW 313
111431: PUSH
111432: LD_INT 6
111434: LESS
111435: PUSH
111436: LD_VAR 0 6
111440: PPUSH
111441: CALL_OW 266
111445: PUSH
111446: LD_INT 31
111448: PUSH
111449: LD_INT 32
111451: PUSH
111452: EMPTY
111453: LIST
111454: LIST
111455: IN
111456: NOT
111457: AND
111458: PUSH
111459: LD_VAR 0 6
111463: PPUSH
111464: CALL_OW 313
111468: PUSH
111469: LD_INT 0
111471: EQUAL
111472: OR
111473: IFFALSE 111487
// begin j := i ;
111475: LD_ADDR_VAR 0 7
111479: PUSH
111480: LD_VAR 0 6
111484: ST_TO_ADDR
// break ;
111485: GO 111489
// end ; end ;
111487: GO 111419
111489: POP
111490: POP
// if j then
111491: LD_VAR 0 7
111495: IFFALSE 111513
// ComEnterUnit ( unit , j ) else
111497: LD_VAR 0 3
111501: PPUSH
111502: LD_VAR 0 7
111506: PPUSH
111507: CALL_OW 120
111511: GO 111616
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
111513: LD_ADDR_VAR 0 10
111517: PUSH
111518: LD_VAR 0 2
111522: PPUSH
111523: LD_INT 2
111525: PUSH
111526: LD_INT 30
111528: PUSH
111529: LD_INT 0
111531: PUSH
111532: EMPTY
111533: LIST
111534: LIST
111535: PUSH
111536: LD_INT 30
111538: PUSH
111539: LD_INT 1
111541: PUSH
111542: EMPTY
111543: LIST
111544: LIST
111545: PUSH
111546: EMPTY
111547: LIST
111548: LIST
111549: LIST
111550: PPUSH
111551: CALL_OW 72
111555: ST_TO_ADDR
// if depot then
111556: LD_VAR 0 10
111560: IFFALSE 111616
// begin depot := NearestUnitToUnit ( depot , unit ) ;
111562: LD_ADDR_VAR 0 10
111566: PUSH
111567: LD_VAR 0 10
111571: PPUSH
111572: LD_VAR 0 3
111576: PPUSH
111577: CALL_OW 74
111581: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
111582: LD_VAR 0 3
111586: PPUSH
111587: LD_VAR 0 10
111591: PPUSH
111592: CALL_OW 296
111596: PUSH
111597: LD_INT 10
111599: GREATER
111600: IFFALSE 111616
// ComStandNearbyBuilding ( unit , depot ) ;
111602: LD_VAR 0 3
111606: PPUSH
111607: LD_VAR 0 10
111611: PPUSH
111612: CALL 20788 0 2
// end ; end ; end ;
111616: LD_VAR 0 5
111620: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
111621: LD_INT 0
111623: PPUSH
111624: PPUSH
111625: PPUSH
111626: PPUSH
// if not mc_bases then
111627: LD_EXP 178
111631: NOT
111632: IFFALSE 111636
// exit ;
111634: GO 111875
// for i = 1 to mc_bases do
111636: LD_ADDR_VAR 0 2
111640: PUSH
111641: DOUBLE
111642: LD_INT 1
111644: DEC
111645: ST_TO_ADDR
111646: LD_EXP 178
111650: PUSH
111651: FOR_TO
111652: IFFALSE 111873
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
111654: LD_ADDR_VAR 0 4
111658: PUSH
111659: LD_EXP 178
111663: PUSH
111664: LD_VAR 0 2
111668: ARRAY
111669: PPUSH
111670: LD_INT 21
111672: PUSH
111673: LD_INT 1
111675: PUSH
111676: EMPTY
111677: LIST
111678: LIST
111679: PPUSH
111680: CALL_OW 72
111684: PUSH
111685: LD_EXP 207
111689: PUSH
111690: LD_VAR 0 2
111694: ARRAY
111695: UNION
111696: ST_TO_ADDR
// if not tmp then
111697: LD_VAR 0 4
111701: NOT
111702: IFFALSE 111706
// continue ;
111704: GO 111651
// for j in tmp do
111706: LD_ADDR_VAR 0 3
111710: PUSH
111711: LD_VAR 0 4
111715: PUSH
111716: FOR_IN
111717: IFFALSE 111869
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
111719: LD_VAR 0 3
111723: PPUSH
111724: CALL_OW 110
111728: NOT
111729: PUSH
111730: LD_VAR 0 3
111734: PPUSH
111735: CALL_OW 314
111739: NOT
111740: AND
111741: PUSH
111742: LD_VAR 0 3
111746: PPUSH
111747: CALL_OW 311
111751: NOT
111752: AND
111753: PUSH
111754: LD_VAR 0 3
111758: PPUSH
111759: CALL_OW 310
111763: NOT
111764: AND
111765: PUSH
111766: LD_VAR 0 3
111770: PUSH
111771: LD_EXP 181
111775: PUSH
111776: LD_VAR 0 2
111780: ARRAY
111781: PUSH
111782: LD_INT 1
111784: ARRAY
111785: IN
111786: NOT
111787: AND
111788: PUSH
111789: LD_VAR 0 3
111793: PUSH
111794: LD_EXP 181
111798: PUSH
111799: LD_VAR 0 2
111803: ARRAY
111804: PUSH
111805: LD_INT 2
111807: ARRAY
111808: IN
111809: NOT
111810: AND
111811: PUSH
111812: LD_VAR 0 3
111816: PUSH
111817: LD_EXP 190
111821: PUSH
111822: LD_VAR 0 2
111826: ARRAY
111827: IN
111828: NOT
111829: AND
111830: IFFALSE 111867
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
111832: LD_VAR 0 2
111836: PPUSH
111837: LD_EXP 178
111841: PUSH
111842: LD_VAR 0 2
111846: ARRAY
111847: PPUSH
111848: LD_VAR 0 3
111852: PPUSH
111853: LD_VAR 0 3
111857: PPUSH
111858: CALL_OW 257
111862: PPUSH
111863: CALL 110639 0 4
// end ;
111867: GO 111716
111869: POP
111870: POP
// end ;
111871: GO 111651
111873: POP
111874: POP
// end ;
111875: LD_VAR 0 1
111879: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , x , j ; begin
111880: LD_INT 0
111882: PPUSH
111883: PPUSH
111884: PPUSH
111885: PPUSH
111886: PPUSH
111887: PPUSH
// if not mc_bases [ base ] then
111888: LD_EXP 178
111892: PUSH
111893: LD_VAR 0 1
111897: ARRAY
111898: NOT
111899: IFFALSE 111903
// exit ;
111901: GO 112085
// tmp := [ ] ;
111903: LD_ADDR_VAR 0 6
111907: PUSH
111908: EMPTY
111909: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
111910: LD_ADDR_VAR 0 7
111914: PUSH
111915: LD_VAR 0 3
111919: PPUSH
111920: LD_INT 0
111922: PPUSH
111923: CALL_OW 517
111927: ST_TO_ADDR
// if not list then
111928: LD_VAR 0 7
111932: NOT
111933: IFFALSE 111937
// exit ;
111935: GO 112085
// for i = 1 to amount do
111937: LD_ADDR_VAR 0 5
111941: PUSH
111942: DOUBLE
111943: LD_INT 1
111945: DEC
111946: ST_TO_ADDR
111947: LD_VAR 0 2
111951: PUSH
111952: FOR_TO
111953: IFFALSE 112033
// begin x := rand ( 1 , list [ 1 ] ) ;
111955: LD_ADDR_VAR 0 8
111959: PUSH
111960: LD_INT 1
111962: PPUSH
111963: LD_VAR 0 7
111967: PUSH
111968: LD_INT 1
111970: ARRAY
111971: PPUSH
111972: CALL_OW 12
111976: ST_TO_ADDR
// tmp := Replace ( tmp , i , [ list [ 1 ] [ x ] , list [ 2 ] [ x ] ] ) ;
111977: LD_ADDR_VAR 0 6
111981: PUSH
111982: LD_VAR 0 6
111986: PPUSH
111987: LD_VAR 0 5
111991: PPUSH
111992: LD_VAR 0 7
111996: PUSH
111997: LD_INT 1
111999: ARRAY
112000: PUSH
112001: LD_VAR 0 8
112005: ARRAY
112006: PUSH
112007: LD_VAR 0 7
112011: PUSH
112012: LD_INT 2
112014: ARRAY
112015: PUSH
112016: LD_VAR 0 8
112020: ARRAY
112021: PUSH
112022: EMPTY
112023: LIST
112024: LIST
112025: PPUSH
112026: CALL_OW 1
112030: ST_TO_ADDR
// end ;
112031: GO 111952
112033: POP
112034: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
112035: LD_ADDR_EXP 191
112039: PUSH
112040: LD_EXP 191
112044: PPUSH
112045: LD_VAR 0 1
112049: PPUSH
112050: LD_VAR 0 6
112054: PPUSH
112055: CALL_OW 1
112059: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
112060: LD_ADDR_EXP 193
112064: PUSH
112065: LD_EXP 193
112069: PPUSH
112070: LD_VAR 0 1
112074: PPUSH
112075: LD_VAR 0 3
112079: PPUSH
112080: CALL_OW 1
112084: ST_TO_ADDR
// end ;
112085: LD_VAR 0 4
112089: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
112090: LD_INT 0
112092: PPUSH
// if not mc_bases [ base ] then
112093: LD_EXP 178
112097: PUSH
112098: LD_VAR 0 1
112102: ARRAY
112103: NOT
112104: IFFALSE 112108
// exit ;
112106: GO 112133
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
112108: LD_ADDR_EXP 183
112112: PUSH
112113: LD_EXP 183
112117: PPUSH
112118: LD_VAR 0 1
112122: PPUSH
112123: LD_VAR 0 2
112127: PPUSH
112128: CALL_OW 1
112132: ST_TO_ADDR
// end ;
112133: LD_VAR 0 3
112137: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
112138: LD_INT 0
112140: PPUSH
// if not mc_bases [ base ] then
112141: LD_EXP 178
112145: PUSH
112146: LD_VAR 0 1
112150: ARRAY
112151: NOT
112152: IFFALSE 112156
// exit ;
112154: GO 112193
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
112156: LD_ADDR_EXP 183
112160: PUSH
112161: LD_EXP 183
112165: PPUSH
112166: LD_VAR 0 1
112170: PPUSH
112171: LD_EXP 183
112175: PUSH
112176: LD_VAR 0 1
112180: ARRAY
112181: PUSH
112182: LD_VAR 0 2
112186: UNION
112187: PPUSH
112188: CALL_OW 1
112192: ST_TO_ADDR
// end ;
112193: LD_VAR 0 3
112197: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
112198: LD_INT 0
112200: PPUSH
// if not mc_bases [ base ] then
112201: LD_EXP 178
112205: PUSH
112206: LD_VAR 0 1
112210: ARRAY
112211: NOT
112212: IFFALSE 112216
// exit ;
112214: GO 112241
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
112216: LD_ADDR_EXP 199
112220: PUSH
112221: LD_EXP 199
112225: PPUSH
112226: LD_VAR 0 1
112230: PPUSH
112231: LD_VAR 0 2
112235: PPUSH
112236: CALL_OW 1
112240: ST_TO_ADDR
// end ;
112241: LD_VAR 0 3
112245: RET
// export function MC_InsertProduceList ( base , components ) ; begin
112246: LD_INT 0
112248: PPUSH
// if not mc_bases [ base ] then
112249: LD_EXP 178
112253: PUSH
112254: LD_VAR 0 1
112258: ARRAY
112259: NOT
112260: IFFALSE 112264
// exit ;
112262: GO 112301
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
112264: LD_ADDR_EXP 199
112268: PUSH
112269: LD_EXP 199
112273: PPUSH
112274: LD_VAR 0 1
112278: PPUSH
112279: LD_EXP 199
112283: PUSH
112284: LD_VAR 0 1
112288: ARRAY
112289: PUSH
112290: LD_VAR 0 2
112294: ADD
112295: PPUSH
112296: CALL_OW 1
112300: ST_TO_ADDR
// end ;
112301: LD_VAR 0 3
112305: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
112306: LD_INT 0
112308: PPUSH
// if not mc_bases [ base ] then
112309: LD_EXP 178
112313: PUSH
112314: LD_VAR 0 1
112318: ARRAY
112319: NOT
112320: IFFALSE 112324
// exit ;
112322: GO 112378
// mc_defender := Replace ( mc_defender , base , deflist ) ;
112324: LD_ADDR_EXP 200
112328: PUSH
112329: LD_EXP 200
112333: PPUSH
112334: LD_VAR 0 1
112338: PPUSH
112339: LD_VAR 0 2
112343: PPUSH
112344: CALL_OW 1
112348: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
112349: LD_ADDR_EXP 189
112353: PUSH
112354: LD_EXP 189
112358: PPUSH
112359: LD_VAR 0 1
112363: PPUSH
112364: LD_VAR 0 2
112368: PUSH
112369: LD_INT 0
112371: PLUS
112372: PPUSH
112373: CALL_OW 1
112377: ST_TO_ADDR
// end ;
112378: LD_VAR 0 3
112382: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
112383: LD_INT 0
112385: PPUSH
// if not mc_bases [ base ] then
112386: LD_EXP 178
112390: PUSH
112391: LD_VAR 0 1
112395: ARRAY
112396: NOT
112397: IFFALSE 112401
// exit ;
112399: GO 112426
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
112401: LD_ADDR_EXP 189
112405: PUSH
112406: LD_EXP 189
112410: PPUSH
112411: LD_VAR 0 1
112415: PPUSH
112416: LD_VAR 0 2
112420: PPUSH
112421: CALL_OW 1
112425: ST_TO_ADDR
// end ;
112426: LD_VAR 0 3
112430: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
112431: LD_INT 0
112433: PPUSH
112434: PPUSH
112435: PPUSH
112436: PPUSH
// if not mc_bases [ base ] then
112437: LD_EXP 178
112441: PUSH
112442: LD_VAR 0 1
112446: ARRAY
112447: NOT
112448: IFFALSE 112452
// exit ;
112450: GO 112517
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
112452: LD_ADDR_EXP 198
112456: PUSH
112457: LD_EXP 198
112461: PPUSH
112462: LD_VAR 0 1
112466: PUSH
112467: LD_EXP 198
112471: PUSH
112472: LD_VAR 0 1
112476: ARRAY
112477: PUSH
112478: LD_INT 1
112480: PLUS
112481: PUSH
112482: EMPTY
112483: LIST
112484: LIST
112485: PPUSH
112486: LD_VAR 0 1
112490: PUSH
112491: LD_VAR 0 2
112495: PUSH
112496: LD_VAR 0 3
112500: PUSH
112501: LD_VAR 0 4
112505: PUSH
112506: EMPTY
112507: LIST
112508: LIST
112509: LIST
112510: LIST
112511: PPUSH
112512: CALL 24363 0 3
112516: ST_TO_ADDR
// end ;
112517: LD_VAR 0 5
112521: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
112522: LD_INT 0
112524: PPUSH
// if not mc_bases [ base ] then
112525: LD_EXP 178
112529: PUSH
112530: LD_VAR 0 1
112534: ARRAY
112535: NOT
112536: IFFALSE 112540
// exit ;
112538: GO 112565
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
112540: LD_ADDR_EXP 215
112544: PUSH
112545: LD_EXP 215
112549: PPUSH
112550: LD_VAR 0 1
112554: PPUSH
112555: LD_VAR 0 2
112559: PPUSH
112560: CALL_OW 1
112564: ST_TO_ADDR
// end ;
112565: LD_VAR 0 3
112569: RET
// export function MC_GetMinesField ( base ) ; begin
112570: LD_INT 0
112572: PPUSH
// result := mc_mines [ base ] ;
112573: LD_ADDR_VAR 0 2
112577: PUSH
112578: LD_EXP 191
112582: PUSH
112583: LD_VAR 0 1
112587: ARRAY
112588: ST_TO_ADDR
// end ;
112589: LD_VAR 0 2
112593: RET
// export function MC_GetProduceList ( base ) ; begin
112594: LD_INT 0
112596: PPUSH
// result := mc_produce [ base ] ;
112597: LD_ADDR_VAR 0 2
112601: PUSH
112602: LD_EXP 199
112606: PUSH
112607: LD_VAR 0 1
112611: ARRAY
112612: ST_TO_ADDR
// end ;
112613: LD_VAR 0 2
112617: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
112618: LD_INT 0
112620: PPUSH
112621: PPUSH
// if not mc_bases then
112622: LD_EXP 178
112626: NOT
112627: IFFALSE 112631
// exit ;
112629: GO 112696
// if mc_bases [ base ] then
112631: LD_EXP 178
112635: PUSH
112636: LD_VAR 0 1
112640: ARRAY
112641: IFFALSE 112696
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
112643: LD_ADDR_VAR 0 3
112647: PUSH
112648: LD_EXP 178
112652: PUSH
112653: LD_VAR 0 1
112657: ARRAY
112658: PPUSH
112659: LD_INT 30
112661: PUSH
112662: LD_VAR 0 2
112666: PUSH
112667: EMPTY
112668: LIST
112669: LIST
112670: PPUSH
112671: CALL_OW 72
112675: ST_TO_ADDR
// if result then
112676: LD_VAR 0 3
112680: IFFALSE 112696
// result := result [ 1 ] ;
112682: LD_ADDR_VAR 0 3
112686: PUSH
112687: LD_VAR 0 3
112691: PUSH
112692: LD_INT 1
112694: ARRAY
112695: ST_TO_ADDR
// end ; end ;
112696: LD_VAR 0 3
112700: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
112701: LD_INT 0
112703: PPUSH
112704: PPUSH
// if not mc_bases then
112705: LD_EXP 178
112709: NOT
112710: IFFALSE 112714
// exit ;
112712: GO 112759
// if mc_bases [ base ] then
112714: LD_EXP 178
112718: PUSH
112719: LD_VAR 0 1
112723: ARRAY
112724: IFFALSE 112759
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
112726: LD_ADDR_VAR 0 3
112730: PUSH
112731: LD_EXP 178
112735: PUSH
112736: LD_VAR 0 1
112740: ARRAY
112741: PPUSH
112742: LD_INT 30
112744: PUSH
112745: LD_VAR 0 2
112749: PUSH
112750: EMPTY
112751: LIST
112752: LIST
112753: PPUSH
112754: CALL_OW 72
112758: ST_TO_ADDR
// end ;
112759: LD_VAR 0 3
112763: RET
// export function MC_SetTame ( base , area ) ; begin
112764: LD_INT 0
112766: PPUSH
// if not mc_bases or not base then
112767: LD_EXP 178
112771: NOT
112772: PUSH
112773: LD_VAR 0 1
112777: NOT
112778: OR
112779: IFFALSE 112783
// exit ;
112781: GO 112808
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
112783: LD_ADDR_EXP 206
112787: PUSH
112788: LD_EXP 206
112792: PPUSH
112793: LD_VAR 0 1
112797: PPUSH
112798: LD_VAR 0 2
112802: PPUSH
112803: CALL_OW 1
112807: ST_TO_ADDR
// end ;
112808: LD_VAR 0 3
112812: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
112813: LD_INT 0
112815: PPUSH
112816: PPUSH
// if not mc_bases or not base then
112817: LD_EXP 178
112821: NOT
112822: PUSH
112823: LD_VAR 0 1
112827: NOT
112828: OR
112829: IFFALSE 112833
// exit ;
112831: GO 112935
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
112833: LD_ADDR_VAR 0 4
112837: PUSH
112838: LD_EXP 178
112842: PUSH
112843: LD_VAR 0 1
112847: ARRAY
112848: PPUSH
112849: LD_INT 30
112851: PUSH
112852: LD_VAR 0 2
112856: PUSH
112857: EMPTY
112858: LIST
112859: LIST
112860: PPUSH
112861: CALL_OW 72
112865: ST_TO_ADDR
// if not tmp then
112866: LD_VAR 0 4
112870: NOT
112871: IFFALSE 112875
// exit ;
112873: GO 112935
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
112875: LD_ADDR_EXP 210
112879: PUSH
112880: LD_EXP 210
112884: PPUSH
112885: LD_VAR 0 1
112889: PPUSH
112890: LD_EXP 210
112894: PUSH
112895: LD_VAR 0 1
112899: ARRAY
112900: PPUSH
112901: LD_EXP 210
112905: PUSH
112906: LD_VAR 0 1
112910: ARRAY
112911: PUSH
112912: LD_INT 1
112914: PLUS
112915: PPUSH
112916: LD_VAR 0 4
112920: PUSH
112921: LD_INT 1
112923: ARRAY
112924: PPUSH
112925: CALL_OW 2
112929: PPUSH
112930: CALL_OW 1
112934: ST_TO_ADDR
// end ;
112935: LD_VAR 0 3
112939: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
112940: LD_INT 0
112942: PPUSH
112943: PPUSH
// if not mc_bases or not base or not kinds then
112944: LD_EXP 178
112948: NOT
112949: PUSH
112950: LD_VAR 0 1
112954: NOT
112955: OR
112956: PUSH
112957: LD_VAR 0 2
112961: NOT
112962: OR
112963: IFFALSE 112967
// exit ;
112965: GO 113028
// for i in kinds do
112967: LD_ADDR_VAR 0 4
112971: PUSH
112972: LD_VAR 0 2
112976: PUSH
112977: FOR_IN
112978: IFFALSE 113026
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
112980: LD_ADDR_EXP 212
112984: PUSH
112985: LD_EXP 212
112989: PPUSH
112990: LD_VAR 0 1
112994: PUSH
112995: LD_EXP 212
112999: PUSH
113000: LD_VAR 0 1
113004: ARRAY
113005: PUSH
113006: LD_INT 1
113008: PLUS
113009: PUSH
113010: EMPTY
113011: LIST
113012: LIST
113013: PPUSH
113014: LD_VAR 0 4
113018: PPUSH
113019: CALL 24363 0 3
113023: ST_TO_ADDR
113024: GO 112977
113026: POP
113027: POP
// end ;
113028: LD_VAR 0 3
113032: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
113033: LD_INT 0
113035: PPUSH
// if not mc_bases or not base or not areas then
113036: LD_EXP 178
113040: NOT
113041: PUSH
113042: LD_VAR 0 1
113046: NOT
113047: OR
113048: PUSH
113049: LD_VAR 0 2
113053: NOT
113054: OR
113055: IFFALSE 113059
// exit ;
113057: GO 113084
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
113059: LD_ADDR_EXP 196
113063: PUSH
113064: LD_EXP 196
113068: PPUSH
113069: LD_VAR 0 1
113073: PPUSH
113074: LD_VAR 0 2
113078: PPUSH
113079: CALL_OW 1
113083: ST_TO_ADDR
// end ;
113084: LD_VAR 0 3
113088: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
113089: LD_INT 0
113091: PPUSH
// if not mc_bases or not base or not teleports_exit then
113092: LD_EXP 178
113096: NOT
113097: PUSH
113098: LD_VAR 0 1
113102: NOT
113103: OR
113104: PUSH
113105: LD_VAR 0 2
113109: NOT
113110: OR
113111: IFFALSE 113115
// exit ;
113113: GO 113140
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
113115: LD_ADDR_EXP 213
113119: PUSH
113120: LD_EXP 213
113124: PPUSH
113125: LD_VAR 0 1
113129: PPUSH
113130: LD_VAR 0 2
113134: PPUSH
113135: CALL_OW 1
113139: ST_TO_ADDR
// end ;
113140: LD_VAR 0 3
113144: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
113145: LD_INT 0
113147: PPUSH
113148: PPUSH
113149: PPUSH
// if not mc_bases or not base or not ext_list then
113150: LD_EXP 178
113154: NOT
113155: PUSH
113156: LD_VAR 0 1
113160: NOT
113161: OR
113162: PUSH
113163: LD_VAR 0 5
113167: NOT
113168: OR
113169: IFFALSE 113173
// exit ;
113171: GO 113346
// tmp := GetFacExtXYD ( x , y , d ) ;
113173: LD_ADDR_VAR 0 8
113177: PUSH
113178: LD_VAR 0 2
113182: PPUSH
113183: LD_VAR 0 3
113187: PPUSH
113188: LD_VAR 0 4
113192: PPUSH
113193: CALL 54264 0 3
113197: ST_TO_ADDR
// if not tmp then
113198: LD_VAR 0 8
113202: NOT
113203: IFFALSE 113207
// exit ;
113205: GO 113346
// for i in tmp do
113207: LD_ADDR_VAR 0 7
113211: PUSH
113212: LD_VAR 0 8
113216: PUSH
113217: FOR_IN
113218: IFFALSE 113344
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
113220: LD_ADDR_EXP 183
113224: PUSH
113225: LD_EXP 183
113229: PPUSH
113230: LD_VAR 0 1
113234: PPUSH
113235: LD_EXP 183
113239: PUSH
113240: LD_VAR 0 1
113244: ARRAY
113245: PPUSH
113246: LD_EXP 183
113250: PUSH
113251: LD_VAR 0 1
113255: ARRAY
113256: PUSH
113257: LD_INT 1
113259: PLUS
113260: PPUSH
113261: LD_VAR 0 5
113265: PUSH
113266: LD_INT 1
113268: ARRAY
113269: PUSH
113270: LD_VAR 0 7
113274: PUSH
113275: LD_INT 1
113277: ARRAY
113278: PUSH
113279: LD_VAR 0 7
113283: PUSH
113284: LD_INT 2
113286: ARRAY
113287: PUSH
113288: LD_VAR 0 7
113292: PUSH
113293: LD_INT 3
113295: ARRAY
113296: PUSH
113297: EMPTY
113298: LIST
113299: LIST
113300: LIST
113301: LIST
113302: PPUSH
113303: CALL_OW 2
113307: PPUSH
113308: CALL_OW 1
113312: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
113313: LD_ADDR_VAR 0 5
113317: PUSH
113318: LD_VAR 0 5
113322: PPUSH
113323: LD_INT 1
113325: PPUSH
113326: CALL_OW 3
113330: ST_TO_ADDR
// if not ext_list then
113331: LD_VAR 0 5
113335: NOT
113336: IFFALSE 113342
// exit ;
113338: POP
113339: POP
113340: GO 113346
// end ;
113342: GO 113217
113344: POP
113345: POP
// end ;
113346: LD_VAR 0 6
113350: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
113351: LD_INT 0
113353: PPUSH
// if not mc_bases or not base or not weapon_list then
113354: LD_EXP 178
113358: NOT
113359: PUSH
113360: LD_VAR 0 1
113364: NOT
113365: OR
113366: PUSH
113367: LD_VAR 0 2
113371: NOT
113372: OR
113373: IFFALSE 113377
// exit ;
113375: GO 113402
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
113377: LD_ADDR_EXP 217
113381: PUSH
113382: LD_EXP 217
113386: PPUSH
113387: LD_VAR 0 1
113391: PPUSH
113392: LD_VAR 0 2
113396: PPUSH
113397: CALL_OW 1
113401: ST_TO_ADDR
// end ;
113402: LD_VAR 0 3
113406: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
113407: LD_INT 0
113409: PPUSH
// if not mc_bases or not base or not tech_list then
113410: LD_EXP 178
113414: NOT
113415: PUSH
113416: LD_VAR 0 1
113420: NOT
113421: OR
113422: PUSH
113423: LD_VAR 0 2
113427: NOT
113428: OR
113429: IFFALSE 113433
// exit ;
113431: GO 113458
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
113433: LD_ADDR_EXP 205
113437: PUSH
113438: LD_EXP 205
113442: PPUSH
113443: LD_VAR 0 1
113447: PPUSH
113448: LD_VAR 0 2
113452: PPUSH
113453: CALL_OW 1
113457: ST_TO_ADDR
// end ;
113458: LD_VAR 0 3
113462: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
113463: LD_INT 0
113465: PPUSH
// if not mc_bases or not parking_area or not base then
113466: LD_EXP 178
113470: NOT
113471: PUSH
113472: LD_VAR 0 2
113476: NOT
113477: OR
113478: PUSH
113479: LD_VAR 0 1
113483: NOT
113484: OR
113485: IFFALSE 113489
// exit ;
113487: GO 113514
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
113489: LD_ADDR_EXP 202
113493: PUSH
113494: LD_EXP 202
113498: PPUSH
113499: LD_VAR 0 1
113503: PPUSH
113504: LD_VAR 0 2
113508: PPUSH
113509: CALL_OW 1
113513: ST_TO_ADDR
// end ;
113514: LD_VAR 0 3
113518: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
113519: LD_INT 0
113521: PPUSH
// if not mc_bases or not base or not scan_area then
113522: LD_EXP 178
113526: NOT
113527: PUSH
113528: LD_VAR 0 1
113532: NOT
113533: OR
113534: PUSH
113535: LD_VAR 0 2
113539: NOT
113540: OR
113541: IFFALSE 113545
// exit ;
113543: GO 113570
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
113545: LD_ADDR_EXP 203
113549: PUSH
113550: LD_EXP 203
113554: PPUSH
113555: LD_VAR 0 1
113559: PPUSH
113560: LD_VAR 0 2
113564: PPUSH
113565: CALL_OW 1
113569: ST_TO_ADDR
// end ;
113570: LD_VAR 0 3
113574: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
113575: LD_INT 0
113577: PPUSH
113578: PPUSH
// if not mc_bases or not base then
113579: LD_EXP 178
113583: NOT
113584: PUSH
113585: LD_VAR 0 1
113589: NOT
113590: OR
113591: IFFALSE 113595
// exit ;
113593: GO 113659
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
113595: LD_ADDR_VAR 0 3
113599: PUSH
113600: LD_INT 1
113602: PUSH
113603: LD_INT 2
113605: PUSH
113606: LD_INT 3
113608: PUSH
113609: LD_INT 4
113611: PUSH
113612: LD_INT 11
113614: PUSH
113615: EMPTY
113616: LIST
113617: LIST
113618: LIST
113619: LIST
113620: LIST
113621: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
113622: LD_ADDR_EXP 205
113626: PUSH
113627: LD_EXP 205
113631: PPUSH
113632: LD_VAR 0 1
113636: PPUSH
113637: LD_EXP 205
113641: PUSH
113642: LD_VAR 0 1
113646: ARRAY
113647: PUSH
113648: LD_VAR 0 3
113652: DIFF
113653: PPUSH
113654: CALL_OW 1
113658: ST_TO_ADDR
// end ;
113659: LD_VAR 0 2
113663: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
113664: LD_INT 0
113666: PPUSH
// result := mc_vehicles [ base ] ;
113667: LD_ADDR_VAR 0 3
113671: PUSH
113672: LD_EXP 197
113676: PUSH
113677: LD_VAR 0 1
113681: ARRAY
113682: ST_TO_ADDR
// if onlyCombat then
113683: LD_VAR 0 2
113687: IFFALSE 113865
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
113689: LD_ADDR_VAR 0 3
113693: PUSH
113694: LD_VAR 0 3
113698: PUSH
113699: LD_VAR 0 3
113703: PPUSH
113704: LD_INT 2
113706: PUSH
113707: LD_INT 34
113709: PUSH
113710: LD_INT 12
113712: PUSH
113713: EMPTY
113714: LIST
113715: LIST
113716: PUSH
113717: LD_INT 34
113719: PUSH
113720: LD_INT 51
113722: PUSH
113723: EMPTY
113724: LIST
113725: LIST
113726: PUSH
113727: LD_INT 34
113729: PUSH
113730: LD_EXP 159
113734: PUSH
113735: EMPTY
113736: LIST
113737: LIST
113738: PUSH
113739: LD_INT 34
113741: PUSH
113742: LD_INT 32
113744: PUSH
113745: EMPTY
113746: LIST
113747: LIST
113748: PUSH
113749: LD_INT 34
113751: PUSH
113752: LD_INT 13
113754: PUSH
113755: EMPTY
113756: LIST
113757: LIST
113758: PUSH
113759: LD_INT 34
113761: PUSH
113762: LD_INT 52
113764: PUSH
113765: EMPTY
113766: LIST
113767: LIST
113768: PUSH
113769: LD_INT 34
113771: PUSH
113772: LD_EXP 164
113776: PUSH
113777: EMPTY
113778: LIST
113779: LIST
113780: PUSH
113781: LD_INT 34
113783: PUSH
113784: LD_INT 14
113786: PUSH
113787: EMPTY
113788: LIST
113789: LIST
113790: PUSH
113791: LD_INT 34
113793: PUSH
113794: LD_INT 53
113796: PUSH
113797: EMPTY
113798: LIST
113799: LIST
113800: PUSH
113801: LD_INT 34
113803: PUSH
113804: LD_EXP 158
113808: PUSH
113809: EMPTY
113810: LIST
113811: LIST
113812: PUSH
113813: LD_INT 34
113815: PUSH
113816: LD_INT 31
113818: PUSH
113819: EMPTY
113820: LIST
113821: LIST
113822: PUSH
113823: LD_INT 34
113825: PUSH
113826: LD_INT 48
113828: PUSH
113829: EMPTY
113830: LIST
113831: LIST
113832: PUSH
113833: LD_INT 34
113835: PUSH
113836: LD_INT 8
113838: PUSH
113839: EMPTY
113840: LIST
113841: LIST
113842: PUSH
113843: EMPTY
113844: LIST
113845: LIST
113846: LIST
113847: LIST
113848: LIST
113849: LIST
113850: LIST
113851: LIST
113852: LIST
113853: LIST
113854: LIST
113855: LIST
113856: LIST
113857: LIST
113858: PPUSH
113859: CALL_OW 72
113863: DIFF
113864: ST_TO_ADDR
// end ; end_of_file
113865: LD_VAR 0 3
113869: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
113870: LD_INT 0
113872: PPUSH
113873: PPUSH
113874: PPUSH
// if not mc_bases or not skirmish then
113875: LD_EXP 178
113879: NOT
113880: PUSH
113881: LD_EXP 176
113885: NOT
113886: OR
113887: IFFALSE 113891
// exit ;
113889: GO 114056
// for i = 1 to mc_bases do
113891: LD_ADDR_VAR 0 4
113895: PUSH
113896: DOUBLE
113897: LD_INT 1
113899: DEC
113900: ST_TO_ADDR
113901: LD_EXP 178
113905: PUSH
113906: FOR_TO
113907: IFFALSE 114054
// begin if sci in mc_bases [ i ] then
113909: LD_VAR 0 2
113913: PUSH
113914: LD_EXP 178
113918: PUSH
113919: LD_VAR 0 4
113923: ARRAY
113924: IN
113925: IFFALSE 114052
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
113927: LD_ADDR_EXP 207
113931: PUSH
113932: LD_EXP 207
113936: PPUSH
113937: LD_VAR 0 4
113941: PUSH
113942: LD_EXP 207
113946: PUSH
113947: LD_VAR 0 4
113951: ARRAY
113952: PUSH
113953: LD_INT 1
113955: PLUS
113956: PUSH
113957: EMPTY
113958: LIST
113959: LIST
113960: PPUSH
113961: LD_VAR 0 1
113965: PPUSH
113966: CALL 24363 0 3
113970: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
113971: LD_ADDR_VAR 0 5
113975: PUSH
113976: LD_EXP 178
113980: PUSH
113981: LD_VAR 0 4
113985: ARRAY
113986: PPUSH
113987: LD_INT 2
113989: PUSH
113990: LD_INT 30
113992: PUSH
113993: LD_INT 0
113995: PUSH
113996: EMPTY
113997: LIST
113998: LIST
113999: PUSH
114000: LD_INT 30
114002: PUSH
114003: LD_INT 1
114005: PUSH
114006: EMPTY
114007: LIST
114008: LIST
114009: PUSH
114010: EMPTY
114011: LIST
114012: LIST
114013: LIST
114014: PPUSH
114015: CALL_OW 72
114019: PPUSH
114020: LD_VAR 0 1
114024: PPUSH
114025: CALL_OW 74
114029: ST_TO_ADDR
// if tmp then
114030: LD_VAR 0 5
114034: IFFALSE 114050
// ComStandNearbyBuilding ( ape , tmp ) ;
114036: LD_VAR 0 1
114040: PPUSH
114041: LD_VAR 0 5
114045: PPUSH
114046: CALL 20788 0 2
// break ;
114050: GO 114054
// end ; end ;
114052: GO 113906
114054: POP
114055: POP
// end ;
114056: LD_VAR 0 3
114060: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
114061: LD_INT 0
114063: PPUSH
114064: PPUSH
114065: PPUSH
// if not mc_bases or not skirmish then
114066: LD_EXP 178
114070: NOT
114071: PUSH
114072: LD_EXP 176
114076: NOT
114077: OR
114078: IFFALSE 114082
// exit ;
114080: GO 114171
// for i = 1 to mc_bases do
114082: LD_ADDR_VAR 0 4
114086: PUSH
114087: DOUBLE
114088: LD_INT 1
114090: DEC
114091: ST_TO_ADDR
114092: LD_EXP 178
114096: PUSH
114097: FOR_TO
114098: IFFALSE 114169
// begin if building in mc_busy_turret_list [ i ] then
114100: LD_VAR 0 1
114104: PUSH
114105: LD_EXP 188
114109: PUSH
114110: LD_VAR 0 4
114114: ARRAY
114115: IN
114116: IFFALSE 114167
// begin tmp := mc_busy_turret_list [ i ] diff building ;
114118: LD_ADDR_VAR 0 5
114122: PUSH
114123: LD_EXP 188
114127: PUSH
114128: LD_VAR 0 4
114132: ARRAY
114133: PUSH
114134: LD_VAR 0 1
114138: DIFF
114139: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
114140: LD_ADDR_EXP 188
114144: PUSH
114145: LD_EXP 188
114149: PPUSH
114150: LD_VAR 0 4
114154: PPUSH
114155: LD_VAR 0 5
114159: PPUSH
114160: CALL_OW 1
114164: ST_TO_ADDR
// break ;
114165: GO 114169
// end ; end ;
114167: GO 114097
114169: POP
114170: POP
// end ;
114171: LD_VAR 0 3
114175: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
114176: LD_INT 0
114178: PPUSH
114179: PPUSH
114180: PPUSH
// if not mc_bases or not skirmish then
114181: LD_EXP 178
114185: NOT
114186: PUSH
114187: LD_EXP 176
114191: NOT
114192: OR
114193: IFFALSE 114197
// exit ;
114195: GO 114396
// for i = 1 to mc_bases do
114197: LD_ADDR_VAR 0 5
114201: PUSH
114202: DOUBLE
114203: LD_INT 1
114205: DEC
114206: ST_TO_ADDR
114207: LD_EXP 178
114211: PUSH
114212: FOR_TO
114213: IFFALSE 114394
// if building in mc_bases [ i ] then
114215: LD_VAR 0 1
114219: PUSH
114220: LD_EXP 178
114224: PUSH
114225: LD_VAR 0 5
114229: ARRAY
114230: IN
114231: IFFALSE 114392
// begin tmp := mc_bases [ i ] diff building ;
114233: LD_ADDR_VAR 0 6
114237: PUSH
114238: LD_EXP 178
114242: PUSH
114243: LD_VAR 0 5
114247: ARRAY
114248: PUSH
114249: LD_VAR 0 1
114253: DIFF
114254: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
114255: LD_ADDR_EXP 178
114259: PUSH
114260: LD_EXP 178
114264: PPUSH
114265: LD_VAR 0 5
114269: PPUSH
114270: LD_VAR 0 6
114274: PPUSH
114275: CALL_OW 1
114279: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
114280: LD_VAR 0 1
114284: PUSH
114285: LD_EXP 186
114289: PUSH
114290: LD_VAR 0 5
114294: ARRAY
114295: IN
114296: IFFALSE 114335
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
114298: LD_ADDR_EXP 186
114302: PUSH
114303: LD_EXP 186
114307: PPUSH
114308: LD_VAR 0 5
114312: PPUSH
114313: LD_EXP 186
114317: PUSH
114318: LD_VAR 0 5
114322: ARRAY
114323: PUSH
114324: LD_VAR 0 1
114328: DIFF
114329: PPUSH
114330: CALL_OW 1
114334: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
114335: LD_VAR 0 1
114339: PUSH
114340: LD_EXP 187
114344: PUSH
114345: LD_VAR 0 5
114349: ARRAY
114350: IN
114351: IFFALSE 114390
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
114353: LD_ADDR_EXP 187
114357: PUSH
114358: LD_EXP 187
114362: PPUSH
114363: LD_VAR 0 5
114367: PPUSH
114368: LD_EXP 187
114372: PUSH
114373: LD_VAR 0 5
114377: ARRAY
114378: PUSH
114379: LD_VAR 0 1
114383: DIFF
114384: PPUSH
114385: CALL_OW 1
114389: ST_TO_ADDR
// break ;
114390: GO 114394
// end ;
114392: GO 114212
114394: POP
114395: POP
// end ;
114396: LD_VAR 0 4
114400: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
114401: LD_INT 0
114403: PPUSH
114404: PPUSH
114405: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
114406: LD_EXP 178
114410: NOT
114411: PUSH
114412: LD_EXP 176
114416: NOT
114417: OR
114418: PUSH
114419: LD_VAR 0 3
114423: PUSH
114424: LD_EXP 204
114428: IN
114429: NOT
114430: OR
114431: IFFALSE 114435
// exit ;
114433: GO 114558
// for i = 1 to mc_vehicles do
114435: LD_ADDR_VAR 0 6
114439: PUSH
114440: DOUBLE
114441: LD_INT 1
114443: DEC
114444: ST_TO_ADDR
114445: LD_EXP 197
114449: PUSH
114450: FOR_TO
114451: IFFALSE 114556
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
114453: LD_VAR 0 2
114457: PUSH
114458: LD_EXP 197
114462: PUSH
114463: LD_VAR 0 6
114467: ARRAY
114468: IN
114469: PUSH
114470: LD_VAR 0 1
114474: PUSH
114475: LD_EXP 197
114479: PUSH
114480: LD_VAR 0 6
114484: ARRAY
114485: IN
114486: OR
114487: IFFALSE 114554
// begin tmp := mc_vehicles [ i ] diff old ;
114489: LD_ADDR_VAR 0 7
114493: PUSH
114494: LD_EXP 197
114498: PUSH
114499: LD_VAR 0 6
114503: ARRAY
114504: PUSH
114505: LD_VAR 0 2
114509: DIFF
114510: ST_TO_ADDR
// tmp := tmp diff new ;
114511: LD_ADDR_VAR 0 7
114515: PUSH
114516: LD_VAR 0 7
114520: PUSH
114521: LD_VAR 0 1
114525: DIFF
114526: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
114527: LD_ADDR_EXP 197
114531: PUSH
114532: LD_EXP 197
114536: PPUSH
114537: LD_VAR 0 6
114541: PPUSH
114542: LD_VAR 0 7
114546: PPUSH
114547: CALL_OW 1
114551: ST_TO_ADDR
// break ;
114552: GO 114556
// end ;
114554: GO 114450
114556: POP
114557: POP
// end ;
114558: LD_VAR 0 5
114562: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
114563: LD_INT 0
114565: PPUSH
114566: PPUSH
114567: PPUSH
114568: PPUSH
// if not mc_bases or not skirmish then
114569: LD_EXP 178
114573: NOT
114574: PUSH
114575: LD_EXP 176
114579: NOT
114580: OR
114581: IFFALSE 114585
// exit ;
114583: GO 114977
// side := GetSide ( vehicle ) ;
114585: LD_ADDR_VAR 0 5
114589: PUSH
114590: LD_VAR 0 1
114594: PPUSH
114595: CALL_OW 255
114599: ST_TO_ADDR
// for i = 1 to mc_bases do
114600: LD_ADDR_VAR 0 4
114604: PUSH
114605: DOUBLE
114606: LD_INT 1
114608: DEC
114609: ST_TO_ADDR
114610: LD_EXP 178
114614: PUSH
114615: FOR_TO
114616: IFFALSE 114975
// begin if factory in mc_bases [ i ] then
114618: LD_VAR 0 2
114622: PUSH
114623: LD_EXP 178
114627: PUSH
114628: LD_VAR 0 4
114632: ARRAY
114633: IN
114634: IFFALSE 114973
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ar_crane , ru_siberium_rocket , us_siberium_rocket ] then
114636: LD_EXP 200
114640: PUSH
114641: LD_VAR 0 4
114645: ARRAY
114646: PUSH
114647: LD_EXP 189
114651: PUSH
114652: LD_VAR 0 4
114656: ARRAY
114657: LESS
114658: PUSH
114659: LD_VAR 0 1
114663: PPUSH
114664: CALL_OW 264
114668: PUSH
114669: LD_INT 31
114671: PUSH
114672: LD_INT 32
114674: PUSH
114675: LD_INT 51
114677: PUSH
114678: LD_EXP 159
114682: PUSH
114683: LD_INT 12
114685: PUSH
114686: LD_INT 30
114688: PUSH
114689: LD_EXP 158
114693: PUSH
114694: LD_INT 11
114696: PUSH
114697: LD_INT 53
114699: PUSH
114700: LD_INT 14
114702: PUSH
114703: LD_EXP 162
114707: PUSH
114708: LD_INT 29
114710: PUSH
114711: LD_EXP 160
114715: PUSH
114716: LD_INT 13
114718: PUSH
114719: LD_INT 52
114721: PUSH
114722: LD_EXP 164
114726: PUSH
114727: LD_INT 48
114729: PUSH
114730: LD_INT 8
114732: PUSH
114733: EMPTY
114734: LIST
114735: LIST
114736: LIST
114737: LIST
114738: LIST
114739: LIST
114740: LIST
114741: LIST
114742: LIST
114743: LIST
114744: LIST
114745: LIST
114746: LIST
114747: LIST
114748: LIST
114749: LIST
114750: LIST
114751: LIST
114752: IN
114753: NOT
114754: AND
114755: IFFALSE 114803
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
114757: LD_ADDR_EXP 200
114761: PUSH
114762: LD_EXP 200
114766: PPUSH
114767: LD_VAR 0 4
114771: PUSH
114772: LD_EXP 200
114776: PUSH
114777: LD_VAR 0 4
114781: ARRAY
114782: PUSH
114783: LD_INT 1
114785: PLUS
114786: PUSH
114787: EMPTY
114788: LIST
114789: LIST
114790: PPUSH
114791: LD_VAR 0 1
114795: PPUSH
114796: CALL 24363 0 3
114800: ST_TO_ADDR
114801: GO 114847
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
114803: LD_ADDR_EXP 197
114807: PUSH
114808: LD_EXP 197
114812: PPUSH
114813: LD_VAR 0 4
114817: PUSH
114818: LD_EXP 197
114822: PUSH
114823: LD_VAR 0 4
114827: ARRAY
114828: PUSH
114829: LD_INT 1
114831: PLUS
114832: PUSH
114833: EMPTY
114834: LIST
114835: LIST
114836: PPUSH
114837: LD_VAR 0 1
114841: PPUSH
114842: CALL 24363 0 3
114846: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
114847: LD_VAR 0 1
114851: PPUSH
114852: CALL_OW 263
114856: PUSH
114857: LD_INT 2
114859: EQUAL
114860: IFFALSE 114889
// begin repeat wait ( 0 0$3 ) ;
114862: LD_INT 105
114864: PPUSH
114865: CALL_OW 67
// Connect ( vehicle ) ;
114869: LD_VAR 0 1
114873: PPUSH
114874: CALL 27334 0 1
// until IsControledBy ( vehicle ) ;
114878: LD_VAR 0 1
114882: PPUSH
114883: CALL_OW 312
114887: IFFALSE 114862
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
114889: LD_VAR 0 1
114893: PPUSH
114894: LD_EXP 202
114898: PUSH
114899: LD_VAR 0 4
114903: ARRAY
114904: PPUSH
114905: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
114909: LD_VAR 0 1
114913: PPUSH
114914: CALL_OW 263
114918: PUSH
114919: LD_INT 1
114921: NONEQUAL
114922: IFFALSE 114926
// break ;
114924: GO 114975
// repeat wait ( 0 0$1 ) ;
114926: LD_INT 35
114928: PPUSH
114929: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
114933: LD_VAR 0 1
114937: PPUSH
114938: LD_EXP 202
114942: PUSH
114943: LD_VAR 0 4
114947: ARRAY
114948: PPUSH
114949: CALL_OW 308
114953: IFFALSE 114926
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
114955: LD_VAR 0 1
114959: PPUSH
114960: CALL_OW 311
114964: PPUSH
114965: CALL_OW 121
// exit ;
114969: POP
114970: POP
114971: GO 114977
// end ; end ;
114973: GO 114615
114975: POP
114976: POP
// end ;
114977: LD_VAR 0 3
114981: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
114982: LD_INT 0
114984: PPUSH
114985: PPUSH
114986: PPUSH
114987: PPUSH
// if not mc_bases or not skirmish then
114988: LD_EXP 178
114992: NOT
114993: PUSH
114994: LD_EXP 176
114998: NOT
114999: OR
115000: IFFALSE 115004
// exit ;
115002: GO 115357
// repeat wait ( 0 0$1 ) ;
115004: LD_INT 35
115006: PPUSH
115007: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
115011: LD_VAR 0 2
115015: PPUSH
115016: LD_VAR 0 3
115020: PPUSH
115021: CALL_OW 284
115025: IFFALSE 115004
// if GetResourceTypeXY ( x , y ) = mat_artefact then
115027: LD_VAR 0 2
115031: PPUSH
115032: LD_VAR 0 3
115036: PPUSH
115037: CALL_OW 283
115041: PUSH
115042: LD_INT 4
115044: EQUAL
115045: IFFALSE 115049
// exit ;
115047: GO 115357
// for i = 1 to mc_bases do
115049: LD_ADDR_VAR 0 7
115053: PUSH
115054: DOUBLE
115055: LD_INT 1
115057: DEC
115058: ST_TO_ADDR
115059: LD_EXP 178
115063: PUSH
115064: FOR_TO
115065: IFFALSE 115355
// begin if mc_crates_area [ i ] then
115067: LD_EXP 196
115071: PUSH
115072: LD_VAR 0 7
115076: ARRAY
115077: IFFALSE 115188
// for j in mc_crates_area [ i ] do
115079: LD_ADDR_VAR 0 8
115083: PUSH
115084: LD_EXP 196
115088: PUSH
115089: LD_VAR 0 7
115093: ARRAY
115094: PUSH
115095: FOR_IN
115096: IFFALSE 115186
// if InArea ( x , y , j ) then
115098: LD_VAR 0 2
115102: PPUSH
115103: LD_VAR 0 3
115107: PPUSH
115108: LD_VAR 0 8
115112: PPUSH
115113: CALL_OW 309
115117: IFFALSE 115184
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
115119: LD_ADDR_EXP 194
115123: PUSH
115124: LD_EXP 194
115128: PPUSH
115129: LD_VAR 0 7
115133: PUSH
115134: LD_EXP 194
115138: PUSH
115139: LD_VAR 0 7
115143: ARRAY
115144: PUSH
115145: LD_INT 1
115147: PLUS
115148: PUSH
115149: EMPTY
115150: LIST
115151: LIST
115152: PPUSH
115153: LD_VAR 0 4
115157: PUSH
115158: LD_VAR 0 2
115162: PUSH
115163: LD_VAR 0 3
115167: PUSH
115168: EMPTY
115169: LIST
115170: LIST
115171: LIST
115172: PPUSH
115173: CALL 24363 0 3
115177: ST_TO_ADDR
// exit ;
115178: POP
115179: POP
115180: POP
115181: POP
115182: GO 115357
// end ;
115184: GO 115095
115186: POP
115187: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
115188: LD_ADDR_VAR 0 9
115192: PUSH
115193: LD_EXP 178
115197: PUSH
115198: LD_VAR 0 7
115202: ARRAY
115203: PPUSH
115204: LD_INT 2
115206: PUSH
115207: LD_INT 30
115209: PUSH
115210: LD_INT 0
115212: PUSH
115213: EMPTY
115214: LIST
115215: LIST
115216: PUSH
115217: LD_INT 30
115219: PUSH
115220: LD_INT 1
115222: PUSH
115223: EMPTY
115224: LIST
115225: LIST
115226: PUSH
115227: EMPTY
115228: LIST
115229: LIST
115230: LIST
115231: PPUSH
115232: CALL_OW 72
115236: ST_TO_ADDR
// if not depot then
115237: LD_VAR 0 9
115241: NOT
115242: IFFALSE 115246
// continue ;
115244: GO 115064
// for j in depot do
115246: LD_ADDR_VAR 0 8
115250: PUSH
115251: LD_VAR 0 9
115255: PUSH
115256: FOR_IN
115257: IFFALSE 115351
// if GetDistUnitXY ( j , x , y ) < 30 then
115259: LD_VAR 0 8
115263: PPUSH
115264: LD_VAR 0 2
115268: PPUSH
115269: LD_VAR 0 3
115273: PPUSH
115274: CALL_OW 297
115278: PUSH
115279: LD_INT 30
115281: LESS
115282: IFFALSE 115349
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
115284: LD_ADDR_EXP 194
115288: PUSH
115289: LD_EXP 194
115293: PPUSH
115294: LD_VAR 0 7
115298: PUSH
115299: LD_EXP 194
115303: PUSH
115304: LD_VAR 0 7
115308: ARRAY
115309: PUSH
115310: LD_INT 1
115312: PLUS
115313: PUSH
115314: EMPTY
115315: LIST
115316: LIST
115317: PPUSH
115318: LD_VAR 0 4
115322: PUSH
115323: LD_VAR 0 2
115327: PUSH
115328: LD_VAR 0 3
115332: PUSH
115333: EMPTY
115334: LIST
115335: LIST
115336: LIST
115337: PPUSH
115338: CALL 24363 0 3
115342: ST_TO_ADDR
// exit ;
115343: POP
115344: POP
115345: POP
115346: POP
115347: GO 115357
// end ;
115349: GO 115256
115351: POP
115352: POP
// end ;
115353: GO 115064
115355: POP
115356: POP
// end ;
115357: LD_VAR 0 6
115361: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
115362: LD_INT 0
115364: PPUSH
115365: PPUSH
115366: PPUSH
115367: PPUSH
// if not mc_bases or not skirmish then
115368: LD_EXP 178
115372: NOT
115373: PUSH
115374: LD_EXP 176
115378: NOT
115379: OR
115380: IFFALSE 115384
// exit ;
115382: GO 115661
// side := GetSide ( lab ) ;
115384: LD_ADDR_VAR 0 4
115388: PUSH
115389: LD_VAR 0 2
115393: PPUSH
115394: CALL_OW 255
115398: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
115399: LD_VAR 0 4
115403: PUSH
115404: LD_EXP 204
115408: IN
115409: NOT
115410: PUSH
115411: LD_EXP 205
115415: NOT
115416: OR
115417: PUSH
115418: LD_EXP 178
115422: NOT
115423: OR
115424: IFFALSE 115428
// exit ;
115426: GO 115661
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
115428: LD_ADDR_EXP 205
115432: PUSH
115433: LD_EXP 205
115437: PPUSH
115438: LD_VAR 0 4
115442: PPUSH
115443: LD_EXP 205
115447: PUSH
115448: LD_VAR 0 4
115452: ARRAY
115453: PUSH
115454: LD_VAR 0 1
115458: DIFF
115459: PPUSH
115460: CALL_OW 1
115464: ST_TO_ADDR
// for i = 1 to mc_bases do
115465: LD_ADDR_VAR 0 5
115469: PUSH
115470: DOUBLE
115471: LD_INT 1
115473: DEC
115474: ST_TO_ADDR
115475: LD_EXP 178
115479: PUSH
115480: FOR_TO
115481: IFFALSE 115659
// begin if lab in mc_bases [ i ] then
115483: LD_VAR 0 2
115487: PUSH
115488: LD_EXP 178
115492: PUSH
115493: LD_VAR 0 5
115497: ARRAY
115498: IN
115499: IFFALSE 115657
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
115501: LD_VAR 0 1
115505: PUSH
115506: LD_INT 11
115508: PUSH
115509: LD_INT 4
115511: PUSH
115512: LD_INT 3
115514: PUSH
115515: LD_INT 2
115517: PUSH
115518: EMPTY
115519: LIST
115520: LIST
115521: LIST
115522: LIST
115523: IN
115524: PUSH
115525: LD_EXP 208
115529: PUSH
115530: LD_VAR 0 5
115534: ARRAY
115535: AND
115536: IFFALSE 115657
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
115538: LD_ADDR_VAR 0 6
115542: PUSH
115543: LD_EXP 208
115547: PUSH
115548: LD_VAR 0 5
115552: ARRAY
115553: PUSH
115554: LD_INT 1
115556: ARRAY
115557: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
115558: LD_ADDR_EXP 208
115562: PUSH
115563: LD_EXP 208
115567: PPUSH
115568: LD_VAR 0 5
115572: PPUSH
115573: EMPTY
115574: PPUSH
115575: CALL_OW 1
115579: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
115580: LD_VAR 0 6
115584: PPUSH
115585: LD_INT 0
115587: PPUSH
115588: CALL_OW 109
// ComExitBuilding ( tmp ) ;
115592: LD_VAR 0 6
115596: PPUSH
115597: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
115601: LD_ADDR_EXP 207
115605: PUSH
115606: LD_EXP 207
115610: PPUSH
115611: LD_VAR 0 5
115615: PPUSH
115616: LD_EXP 207
115620: PUSH
115621: LD_VAR 0 5
115625: ARRAY
115626: PPUSH
115627: LD_INT 1
115629: PPUSH
115630: LD_VAR 0 6
115634: PPUSH
115635: CALL_OW 2
115639: PPUSH
115640: CALL_OW 1
115644: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
115645: LD_VAR 0 5
115649: PPUSH
115650: LD_INT 112
115652: PPUSH
115653: CALL 92180 0 2
// end ; end ; end ;
115657: GO 115480
115659: POP
115660: POP
// end ;
115661: LD_VAR 0 3
115665: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
115666: LD_INT 0
115668: PPUSH
115669: PPUSH
115670: PPUSH
115671: PPUSH
115672: PPUSH
115673: PPUSH
115674: PPUSH
115675: PPUSH
// if not mc_bases or not skirmish then
115676: LD_EXP 178
115680: NOT
115681: PUSH
115682: LD_EXP 176
115686: NOT
115687: OR
115688: IFFALSE 115692
// exit ;
115690: GO 117063
// for i = 1 to mc_bases do
115692: LD_ADDR_VAR 0 3
115696: PUSH
115697: DOUBLE
115698: LD_INT 1
115700: DEC
115701: ST_TO_ADDR
115702: LD_EXP 178
115706: PUSH
115707: FOR_TO
115708: IFFALSE 117061
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
115710: LD_VAR 0 1
115714: PUSH
115715: LD_EXP 178
115719: PUSH
115720: LD_VAR 0 3
115724: ARRAY
115725: IN
115726: PUSH
115727: LD_VAR 0 1
115731: PUSH
115732: LD_EXP 185
115736: PUSH
115737: LD_VAR 0 3
115741: ARRAY
115742: IN
115743: OR
115744: PUSH
115745: LD_VAR 0 1
115749: PUSH
115750: LD_EXP 200
115754: PUSH
115755: LD_VAR 0 3
115759: ARRAY
115760: IN
115761: OR
115762: PUSH
115763: LD_VAR 0 1
115767: PUSH
115768: LD_EXP 197
115772: PUSH
115773: LD_VAR 0 3
115777: ARRAY
115778: IN
115779: OR
115780: PUSH
115781: LD_VAR 0 1
115785: PUSH
115786: LD_EXP 207
115790: PUSH
115791: LD_VAR 0 3
115795: ARRAY
115796: IN
115797: OR
115798: PUSH
115799: LD_VAR 0 1
115803: PUSH
115804: LD_EXP 208
115808: PUSH
115809: LD_VAR 0 3
115813: ARRAY
115814: IN
115815: OR
115816: IFFALSE 117059
// begin if un in mc_ape [ i ] then
115818: LD_VAR 0 1
115822: PUSH
115823: LD_EXP 207
115827: PUSH
115828: LD_VAR 0 3
115832: ARRAY
115833: IN
115834: IFFALSE 115873
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
115836: LD_ADDR_EXP 207
115840: PUSH
115841: LD_EXP 207
115845: PPUSH
115846: LD_VAR 0 3
115850: PPUSH
115851: LD_EXP 207
115855: PUSH
115856: LD_VAR 0 3
115860: ARRAY
115861: PUSH
115862: LD_VAR 0 1
115866: DIFF
115867: PPUSH
115868: CALL_OW 1
115872: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
115873: LD_VAR 0 1
115877: PUSH
115878: LD_EXP 208
115882: PUSH
115883: LD_VAR 0 3
115887: ARRAY
115888: IN
115889: IFFALSE 115913
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
115891: LD_ADDR_EXP 208
115895: PUSH
115896: LD_EXP 208
115900: PPUSH
115901: LD_VAR 0 3
115905: PPUSH
115906: EMPTY
115907: PPUSH
115908: CALL_OW 1
115912: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane , ar_control_tower ] ) then
115913: LD_VAR 0 1
115917: PPUSH
115918: CALL_OW 247
115922: PUSH
115923: LD_INT 2
115925: EQUAL
115926: PUSH
115927: LD_VAR 0 1
115931: PPUSH
115932: CALL_OW 110
115936: PUSH
115937: LD_INT 20
115939: EQUAL
115940: PUSH
115941: LD_VAR 0 1
115945: PUSH
115946: LD_EXP 200
115950: PUSH
115951: LD_VAR 0 3
115955: ARRAY
115956: IN
115957: OR
115958: PUSH
115959: LD_VAR 0 1
115963: PPUSH
115964: CALL_OW 264
115968: PUSH
115969: LD_INT 12
115971: PUSH
115972: LD_INT 51
115974: PUSH
115975: LD_EXP 159
115979: PUSH
115980: LD_INT 32
115982: PUSH
115983: LD_INT 13
115985: PUSH
115986: LD_INT 52
115988: PUSH
115989: LD_INT 31
115991: PUSH
115992: EMPTY
115993: LIST
115994: LIST
115995: LIST
115996: LIST
115997: LIST
115998: LIST
115999: LIST
116000: IN
116001: OR
116002: AND
116003: IFFALSE 116311
// begin if un in mc_defender [ i ] then
116005: LD_VAR 0 1
116009: PUSH
116010: LD_EXP 200
116014: PUSH
116015: LD_VAR 0 3
116019: ARRAY
116020: IN
116021: IFFALSE 116060
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
116023: LD_ADDR_EXP 200
116027: PUSH
116028: LD_EXP 200
116032: PPUSH
116033: LD_VAR 0 3
116037: PPUSH
116038: LD_EXP 200
116042: PUSH
116043: LD_VAR 0 3
116047: ARRAY
116048: PUSH
116049: LD_VAR 0 1
116053: DIFF
116054: PPUSH
116055: CALL_OW 1
116059: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
116060: LD_ADDR_VAR 0 8
116064: PUSH
116065: LD_VAR 0 3
116069: PPUSH
116070: LD_INT 3
116072: PPUSH
116073: CALL 112701 0 2
116077: ST_TO_ADDR
// if fac then
116078: LD_VAR 0 8
116082: IFFALSE 116311
// begin for j in fac do
116084: LD_ADDR_VAR 0 4
116088: PUSH
116089: LD_VAR 0 8
116093: PUSH
116094: FOR_IN
116095: IFFALSE 116309
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
116097: LD_ADDR_VAR 0 9
116101: PUSH
116102: LD_VAR 0 8
116106: PPUSH
116107: LD_VAR 0 1
116111: PPUSH
116112: CALL_OW 265
116116: PPUSH
116117: LD_VAR 0 1
116121: PPUSH
116122: CALL_OW 262
116126: PPUSH
116127: LD_VAR 0 1
116131: PPUSH
116132: CALL_OW 263
116136: PPUSH
116137: LD_VAR 0 1
116141: PPUSH
116142: CALL_OW 264
116146: PPUSH
116147: CALL 21859 0 5
116151: ST_TO_ADDR
// if components then
116152: LD_VAR 0 9
116156: IFFALSE 116307
// begin if GetWeapon ( un ) = ar_control_tower then
116158: LD_VAR 0 1
116162: PPUSH
116163: CALL_OW 264
116167: PUSH
116168: LD_INT 31
116170: EQUAL
116171: IFFALSE 116288
// begin SetTag ( IsDrivenBy ( un ) , 0 ) ;
116173: LD_VAR 0 1
116177: PPUSH
116178: CALL_OW 311
116182: PPUSH
116183: LD_INT 0
116185: PPUSH
116186: CALL_OW 109
// mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff IsDrivenBy ( un ) ) ;
116190: LD_ADDR_EXP 218
116194: PUSH
116195: LD_EXP 218
116199: PPUSH
116200: LD_VAR 0 3
116204: PPUSH
116205: LD_EXP 218
116209: PUSH
116210: LD_VAR 0 3
116214: ARRAY
116215: PUSH
116216: LD_VAR 0 1
116220: PPUSH
116221: CALL_OW 311
116225: DIFF
116226: PPUSH
116227: CALL_OW 1
116231: ST_TO_ADDR
// tmp := Insert ( mc_produce [ i ] , 1 , components ) ;
116232: LD_ADDR_VAR 0 7
116236: PUSH
116237: LD_EXP 199
116241: PUSH
116242: LD_VAR 0 3
116246: ARRAY
116247: PPUSH
116248: LD_INT 1
116250: PPUSH
116251: LD_VAR 0 9
116255: PPUSH
116256: CALL_OW 2
116260: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
116261: LD_ADDR_EXP 199
116265: PUSH
116266: LD_EXP 199
116270: PPUSH
116271: LD_VAR 0 3
116275: PPUSH
116276: LD_VAR 0 7
116280: PPUSH
116281: CALL_OW 1
116285: ST_TO_ADDR
// end else
116286: GO 116305
// MC_InsertProduceList ( i , [ components ] ) ;
116288: LD_VAR 0 3
116292: PPUSH
116293: LD_VAR 0 9
116297: PUSH
116298: EMPTY
116299: LIST
116300: PPUSH
116301: CALL 112246 0 2
// break ;
116305: GO 116309
// end ; end ;
116307: GO 116094
116309: POP
116310: POP
// end ; end ; if GetType ( un ) = unit_building then
116311: LD_VAR 0 1
116315: PPUSH
116316: CALL_OW 247
116320: PUSH
116321: LD_INT 3
116323: EQUAL
116324: IFFALSE 116727
// begin btype := GetBType ( un ) ;
116326: LD_ADDR_VAR 0 5
116330: PUSH
116331: LD_VAR 0 1
116335: PPUSH
116336: CALL_OW 266
116340: ST_TO_ADDR
// if btype in [ b_oil_mine , b_siberite_mine ] then
116341: LD_VAR 0 5
116345: PUSH
116346: LD_INT 29
116348: PUSH
116349: LD_INT 30
116351: PUSH
116352: EMPTY
116353: LIST
116354: LIST
116355: IN
116356: IFFALSE 116429
// begin if not GetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) then
116358: LD_VAR 0 1
116362: PPUSH
116363: CALL_OW 250
116367: PPUSH
116368: LD_VAR 0 1
116372: PPUSH
116373: CALL_OW 251
116377: PPUSH
116378: LD_VAR 0 1
116382: PPUSH
116383: CALL_OW 255
116387: PPUSH
116388: CALL_OW 440
116392: NOT
116393: IFFALSE 116429
// SetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) ;
116395: LD_VAR 0 1
116399: PPUSH
116400: CALL_OW 250
116404: PPUSH
116405: LD_VAR 0 1
116409: PPUSH
116410: CALL_OW 251
116414: PPUSH
116415: LD_VAR 0 1
116419: PPUSH
116420: CALL_OW 255
116424: PPUSH
116425: CALL_OW 441
// end ; if btype = b_warehouse then
116429: LD_VAR 0 5
116433: PUSH
116434: LD_INT 1
116436: EQUAL
116437: IFFALSE 116455
// begin btype := b_depot ;
116439: LD_ADDR_VAR 0 5
116443: PUSH
116444: LD_INT 0
116446: ST_TO_ADDR
// pos := 1 ;
116447: LD_ADDR_VAR 0 6
116451: PUSH
116452: LD_INT 1
116454: ST_TO_ADDR
// end ; if btype = b_factory then
116455: LD_VAR 0 5
116459: PUSH
116460: LD_INT 3
116462: EQUAL
116463: IFFALSE 116481
// begin btype := b_workshop ;
116465: LD_ADDR_VAR 0 5
116469: PUSH
116470: LD_INT 2
116472: ST_TO_ADDR
// pos := 1 ;
116473: LD_ADDR_VAR 0 6
116477: PUSH
116478: LD_INT 1
116480: ST_TO_ADDR
// end ; if btype = b_barracks then
116481: LD_VAR 0 5
116485: PUSH
116486: LD_INT 5
116488: EQUAL
116489: IFFALSE 116499
// btype := b_armoury ;
116491: LD_ADDR_VAR 0 5
116495: PUSH
116496: LD_INT 4
116498: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
116499: LD_VAR 0 5
116503: PUSH
116504: LD_INT 7
116506: PUSH
116507: LD_INT 8
116509: PUSH
116510: EMPTY
116511: LIST
116512: LIST
116513: IN
116514: IFFALSE 116524
// btype := b_lab ;
116516: LD_ADDR_VAR 0 5
116520: PUSH
116521: LD_INT 6
116523: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
116524: LD_ADDR_EXP 183
116528: PUSH
116529: LD_EXP 183
116533: PPUSH
116534: LD_VAR 0 3
116538: PUSH
116539: LD_EXP 183
116543: PUSH
116544: LD_VAR 0 3
116548: ARRAY
116549: PUSH
116550: LD_INT 1
116552: PLUS
116553: PUSH
116554: EMPTY
116555: LIST
116556: LIST
116557: PPUSH
116558: LD_VAR 0 5
116562: PUSH
116563: LD_VAR 0 1
116567: PPUSH
116568: CALL_OW 250
116572: PUSH
116573: LD_VAR 0 1
116577: PPUSH
116578: CALL_OW 251
116582: PUSH
116583: LD_VAR 0 1
116587: PPUSH
116588: CALL_OW 254
116592: PUSH
116593: EMPTY
116594: LIST
116595: LIST
116596: LIST
116597: LIST
116598: PPUSH
116599: CALL 24363 0 3
116603: ST_TO_ADDR
// if pos = 1 then
116604: LD_VAR 0 6
116608: PUSH
116609: LD_INT 1
116611: EQUAL
116612: IFFALSE 116727
// begin tmp := mc_build_list [ i ] ;
116614: LD_ADDR_VAR 0 7
116618: PUSH
116619: LD_EXP 183
116623: PUSH
116624: LD_VAR 0 3
116628: ARRAY
116629: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
116630: LD_VAR 0 7
116634: PPUSH
116635: LD_INT 2
116637: PUSH
116638: LD_INT 30
116640: PUSH
116641: LD_INT 0
116643: PUSH
116644: EMPTY
116645: LIST
116646: LIST
116647: PUSH
116648: LD_INT 30
116650: PUSH
116651: LD_INT 1
116653: PUSH
116654: EMPTY
116655: LIST
116656: LIST
116657: PUSH
116658: EMPTY
116659: LIST
116660: LIST
116661: LIST
116662: PPUSH
116663: CALL_OW 72
116667: IFFALSE 116677
// pos := 2 ;
116669: LD_ADDR_VAR 0 6
116673: PUSH
116674: LD_INT 2
116676: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
116677: LD_ADDR_VAR 0 7
116681: PUSH
116682: LD_VAR 0 7
116686: PPUSH
116687: LD_VAR 0 6
116691: PPUSH
116692: LD_VAR 0 7
116696: PPUSH
116697: CALL 24689 0 3
116701: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
116702: LD_ADDR_EXP 183
116706: PUSH
116707: LD_EXP 183
116711: PPUSH
116712: LD_VAR 0 3
116716: PPUSH
116717: LD_VAR 0 7
116721: PPUSH
116722: CALL_OW 1
116726: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
116727: LD_VAR 0 1
116731: PUSH
116732: LD_EXP 178
116736: PUSH
116737: LD_VAR 0 3
116741: ARRAY
116742: IN
116743: IFFALSE 116782
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
116745: LD_ADDR_EXP 178
116749: PUSH
116750: LD_EXP 178
116754: PPUSH
116755: LD_VAR 0 3
116759: PPUSH
116760: LD_EXP 178
116764: PUSH
116765: LD_VAR 0 3
116769: ARRAY
116770: PUSH
116771: LD_VAR 0 1
116775: DIFF
116776: PPUSH
116777: CALL_OW 1
116781: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
116782: LD_VAR 0 1
116786: PUSH
116787: LD_EXP 185
116791: PUSH
116792: LD_VAR 0 3
116796: ARRAY
116797: IN
116798: IFFALSE 116837
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
116800: LD_ADDR_EXP 185
116804: PUSH
116805: LD_EXP 185
116809: PPUSH
116810: LD_VAR 0 3
116814: PPUSH
116815: LD_EXP 185
116819: PUSH
116820: LD_VAR 0 3
116824: ARRAY
116825: PUSH
116826: LD_VAR 0 1
116830: DIFF
116831: PPUSH
116832: CALL_OW 1
116836: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
116837: LD_VAR 0 1
116841: PUSH
116842: LD_EXP 197
116846: PUSH
116847: LD_VAR 0 3
116851: ARRAY
116852: IN
116853: IFFALSE 116892
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
116855: LD_ADDR_EXP 197
116859: PUSH
116860: LD_EXP 197
116864: PPUSH
116865: LD_VAR 0 3
116869: PPUSH
116870: LD_EXP 197
116874: PUSH
116875: LD_VAR 0 3
116879: ARRAY
116880: PUSH
116881: LD_VAR 0 1
116885: DIFF
116886: PPUSH
116887: CALL_OW 1
116891: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
116892: LD_VAR 0 1
116896: PUSH
116897: LD_EXP 200
116901: PUSH
116902: LD_VAR 0 3
116906: ARRAY
116907: IN
116908: IFFALSE 116947
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
116910: LD_ADDR_EXP 200
116914: PUSH
116915: LD_EXP 200
116919: PPUSH
116920: LD_VAR 0 3
116924: PPUSH
116925: LD_EXP 200
116929: PUSH
116930: LD_VAR 0 3
116934: ARRAY
116935: PUSH
116936: LD_VAR 0 1
116940: DIFF
116941: PPUSH
116942: CALL_OW 1
116946: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
116947: LD_VAR 0 1
116951: PUSH
116952: LD_EXP 187
116956: PUSH
116957: LD_VAR 0 3
116961: ARRAY
116962: IN
116963: IFFALSE 117002
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
116965: LD_ADDR_EXP 187
116969: PUSH
116970: LD_EXP 187
116974: PPUSH
116975: LD_VAR 0 3
116979: PPUSH
116980: LD_EXP 187
116984: PUSH
116985: LD_VAR 0 3
116989: ARRAY
116990: PUSH
116991: LD_VAR 0 1
116995: DIFF
116996: PPUSH
116997: CALL_OW 1
117001: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
117002: LD_VAR 0 1
117006: PUSH
117007: LD_EXP 186
117011: PUSH
117012: LD_VAR 0 3
117016: ARRAY
117017: IN
117018: IFFALSE 117057
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
117020: LD_ADDR_EXP 186
117024: PUSH
117025: LD_EXP 186
117029: PPUSH
117030: LD_VAR 0 3
117034: PPUSH
117035: LD_EXP 186
117039: PUSH
117040: LD_VAR 0 3
117044: ARRAY
117045: PUSH
117046: LD_VAR 0 1
117050: DIFF
117051: PPUSH
117052: CALL_OW 1
117056: ST_TO_ADDR
// end ; break ;
117057: GO 117061
// end ;
117059: GO 115707
117061: POP
117062: POP
// end ;
117063: LD_VAR 0 2
117067: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
117068: LD_INT 0
117070: PPUSH
117071: PPUSH
117072: PPUSH
// if not mc_bases or not skirmish then
117073: LD_EXP 178
117077: NOT
117078: PUSH
117079: LD_EXP 176
117083: NOT
117084: OR
117085: IFFALSE 117089
// exit ;
117087: GO 117304
// for i = 1 to mc_bases do
117089: LD_ADDR_VAR 0 3
117093: PUSH
117094: DOUBLE
117095: LD_INT 1
117097: DEC
117098: ST_TO_ADDR
117099: LD_EXP 178
117103: PUSH
117104: FOR_TO
117105: IFFALSE 117302
// begin if building in mc_construct_list [ i ] then
117107: LD_VAR 0 1
117111: PUSH
117112: LD_EXP 185
117116: PUSH
117117: LD_VAR 0 3
117121: ARRAY
117122: IN
117123: IFFALSE 117300
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
117125: LD_ADDR_EXP 185
117129: PUSH
117130: LD_EXP 185
117134: PPUSH
117135: LD_VAR 0 3
117139: PPUSH
117140: LD_EXP 185
117144: PUSH
117145: LD_VAR 0 3
117149: ARRAY
117150: PUSH
117151: LD_VAR 0 1
117155: DIFF
117156: PPUSH
117157: CALL_OW 1
117161: ST_TO_ADDR
// if building in mc_lab [ i ] then
117162: LD_VAR 0 1
117166: PUSH
117167: LD_EXP 211
117171: PUSH
117172: LD_VAR 0 3
117176: ARRAY
117177: IN
117178: IFFALSE 117233
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
117180: LD_ADDR_EXP 212
117184: PUSH
117185: LD_EXP 212
117189: PPUSH
117190: LD_VAR 0 3
117194: PPUSH
117195: LD_EXP 212
117199: PUSH
117200: LD_VAR 0 3
117204: ARRAY
117205: PPUSH
117206: LD_INT 1
117208: PPUSH
117209: LD_EXP 212
117213: PUSH
117214: LD_VAR 0 3
117218: ARRAY
117219: PPUSH
117220: LD_INT 0
117222: PPUSH
117223: CALL 23781 0 4
117227: PPUSH
117228: CALL_OW 1
117232: ST_TO_ADDR
// if not building in mc_bases [ i ] then
117233: LD_VAR 0 1
117237: PUSH
117238: LD_EXP 178
117242: PUSH
117243: LD_VAR 0 3
117247: ARRAY
117248: IN
117249: NOT
117250: IFFALSE 117296
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
117252: LD_ADDR_EXP 178
117256: PUSH
117257: LD_EXP 178
117261: PPUSH
117262: LD_VAR 0 3
117266: PUSH
117267: LD_EXP 178
117271: PUSH
117272: LD_VAR 0 3
117276: ARRAY
117277: PUSH
117278: LD_INT 1
117280: PLUS
117281: PUSH
117282: EMPTY
117283: LIST
117284: LIST
117285: PPUSH
117286: LD_VAR 0 1
117290: PPUSH
117291: CALL 24363 0 3
117295: ST_TO_ADDR
// exit ;
117296: POP
117297: POP
117298: GO 117304
// end ; end ;
117300: GO 117104
117302: POP
117303: POP
// end ;
117304: LD_VAR 0 2
117308: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
117309: LD_INT 0
117311: PPUSH
117312: PPUSH
117313: PPUSH
117314: PPUSH
117315: PPUSH
117316: PPUSH
117317: PPUSH
// if not mc_bases or not skirmish then
117318: LD_EXP 178
117322: NOT
117323: PUSH
117324: LD_EXP 176
117328: NOT
117329: OR
117330: IFFALSE 117334
// exit ;
117332: GO 117995
// for i = 1 to mc_bases do
117334: LD_ADDR_VAR 0 3
117338: PUSH
117339: DOUBLE
117340: LD_INT 1
117342: DEC
117343: ST_TO_ADDR
117344: LD_EXP 178
117348: PUSH
117349: FOR_TO
117350: IFFALSE 117993
// begin if building in mc_construct_list [ i ] then
117352: LD_VAR 0 1
117356: PUSH
117357: LD_EXP 185
117361: PUSH
117362: LD_VAR 0 3
117366: ARRAY
117367: IN
117368: IFFALSE 117991
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
117370: LD_ADDR_EXP 185
117374: PUSH
117375: LD_EXP 185
117379: PPUSH
117380: LD_VAR 0 3
117384: PPUSH
117385: LD_EXP 185
117389: PUSH
117390: LD_VAR 0 3
117394: ARRAY
117395: PUSH
117396: LD_VAR 0 1
117400: DIFF
117401: PPUSH
117402: CALL_OW 1
117406: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
117407: LD_ADDR_EXP 178
117411: PUSH
117412: LD_EXP 178
117416: PPUSH
117417: LD_VAR 0 3
117421: PUSH
117422: LD_EXP 178
117426: PUSH
117427: LD_VAR 0 3
117431: ARRAY
117432: PUSH
117433: LD_INT 1
117435: PLUS
117436: PUSH
117437: EMPTY
117438: LIST
117439: LIST
117440: PPUSH
117441: LD_VAR 0 1
117445: PPUSH
117446: CALL 24363 0 3
117450: ST_TO_ADDR
// btype := GetBType ( building ) ;
117451: LD_ADDR_VAR 0 5
117455: PUSH
117456: LD_VAR 0 1
117460: PPUSH
117461: CALL_OW 266
117465: ST_TO_ADDR
// side := GetSide ( building ) ;
117466: LD_ADDR_VAR 0 8
117470: PUSH
117471: LD_VAR 0 1
117475: PPUSH
117476: CALL_OW 255
117480: ST_TO_ADDR
// if btype = b_lab then
117481: LD_VAR 0 5
117485: PUSH
117486: LD_INT 6
117488: EQUAL
117489: IFFALSE 117539
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
117491: LD_ADDR_EXP 211
117495: PUSH
117496: LD_EXP 211
117500: PPUSH
117501: LD_VAR 0 3
117505: PUSH
117506: LD_EXP 211
117510: PUSH
117511: LD_VAR 0 3
117515: ARRAY
117516: PUSH
117517: LD_INT 1
117519: PLUS
117520: PUSH
117521: EMPTY
117522: LIST
117523: LIST
117524: PPUSH
117525: LD_VAR 0 1
117529: PPUSH
117530: CALL 24363 0 3
117534: ST_TO_ADDR
// exit ;
117535: POP
117536: POP
117537: GO 117995
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
117539: LD_VAR 0 5
117543: PUSH
117544: LD_INT 0
117546: PUSH
117547: LD_INT 2
117549: PUSH
117550: LD_INT 4
117552: PUSH
117553: EMPTY
117554: LIST
117555: LIST
117556: LIST
117557: IN
117558: IFFALSE 117682
// begin if btype = b_armoury then
117560: LD_VAR 0 5
117564: PUSH
117565: LD_INT 4
117567: EQUAL
117568: IFFALSE 117578
// btype := b_barracks ;
117570: LD_ADDR_VAR 0 5
117574: PUSH
117575: LD_INT 5
117577: ST_TO_ADDR
// if btype = b_depot then
117578: LD_VAR 0 5
117582: PUSH
117583: LD_INT 0
117585: EQUAL
117586: IFFALSE 117596
// btype := b_warehouse ;
117588: LD_ADDR_VAR 0 5
117592: PUSH
117593: LD_INT 1
117595: ST_TO_ADDR
// if btype = b_workshop then
117596: LD_VAR 0 5
117600: PUSH
117601: LD_INT 2
117603: EQUAL
117604: IFFALSE 117614
// btype := b_factory ;
117606: LD_ADDR_VAR 0 5
117610: PUSH
117611: LD_INT 3
117613: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
117614: LD_VAR 0 5
117618: PPUSH
117619: LD_VAR 0 8
117623: PPUSH
117624: CALL_OW 323
117628: PUSH
117629: LD_INT 1
117631: EQUAL
117632: IFFALSE 117678
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
117634: LD_ADDR_EXP 210
117638: PUSH
117639: LD_EXP 210
117643: PPUSH
117644: LD_VAR 0 3
117648: PUSH
117649: LD_EXP 210
117653: PUSH
117654: LD_VAR 0 3
117658: ARRAY
117659: PUSH
117660: LD_INT 1
117662: PLUS
117663: PUSH
117664: EMPTY
117665: LIST
117666: LIST
117667: PPUSH
117668: LD_VAR 0 1
117672: PPUSH
117673: CALL 24363 0 3
117677: ST_TO_ADDR
// exit ;
117678: POP
117679: POP
117680: GO 117995
// end ; if btype in [ b_bunker , b_turret ] then
117682: LD_VAR 0 5
117686: PUSH
117687: LD_INT 32
117689: PUSH
117690: LD_INT 33
117692: PUSH
117693: EMPTY
117694: LIST
117695: LIST
117696: IN
117697: IFFALSE 117987
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
117699: LD_ADDR_EXP 186
117703: PUSH
117704: LD_EXP 186
117708: PPUSH
117709: LD_VAR 0 3
117713: PUSH
117714: LD_EXP 186
117718: PUSH
117719: LD_VAR 0 3
117723: ARRAY
117724: PUSH
117725: LD_INT 1
117727: PLUS
117728: PUSH
117729: EMPTY
117730: LIST
117731: LIST
117732: PPUSH
117733: LD_VAR 0 1
117737: PPUSH
117738: CALL 24363 0 3
117742: ST_TO_ADDR
// if btype = b_bunker then
117743: LD_VAR 0 5
117747: PUSH
117748: LD_INT 32
117750: EQUAL
117751: IFFALSE 117987
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
117753: LD_ADDR_EXP 187
117757: PUSH
117758: LD_EXP 187
117762: PPUSH
117763: LD_VAR 0 3
117767: PUSH
117768: LD_EXP 187
117772: PUSH
117773: LD_VAR 0 3
117777: ARRAY
117778: PUSH
117779: LD_INT 1
117781: PLUS
117782: PUSH
117783: EMPTY
117784: LIST
117785: LIST
117786: PPUSH
117787: LD_VAR 0 1
117791: PPUSH
117792: CALL 24363 0 3
117796: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
117797: LD_ADDR_VAR 0 6
117801: PUSH
117802: LD_EXP 178
117806: PUSH
117807: LD_VAR 0 3
117811: ARRAY
117812: PPUSH
117813: LD_INT 25
117815: PUSH
117816: LD_INT 1
117818: PUSH
117819: EMPTY
117820: LIST
117821: LIST
117822: PUSH
117823: LD_INT 3
117825: PUSH
117826: LD_INT 54
117828: PUSH
117829: EMPTY
117830: LIST
117831: PUSH
117832: EMPTY
117833: LIST
117834: LIST
117835: PUSH
117836: EMPTY
117837: LIST
117838: LIST
117839: PPUSH
117840: CALL_OW 72
117844: ST_TO_ADDR
// if tmp then
117845: LD_VAR 0 6
117849: IFFALSE 117855
// exit ;
117851: POP
117852: POP
117853: GO 117995
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
117855: LD_ADDR_VAR 0 6
117859: PUSH
117860: LD_EXP 178
117864: PUSH
117865: LD_VAR 0 3
117869: ARRAY
117870: PPUSH
117871: LD_INT 2
117873: PUSH
117874: LD_INT 30
117876: PUSH
117877: LD_INT 4
117879: PUSH
117880: EMPTY
117881: LIST
117882: LIST
117883: PUSH
117884: LD_INT 30
117886: PUSH
117887: LD_INT 5
117889: PUSH
117890: EMPTY
117891: LIST
117892: LIST
117893: PUSH
117894: EMPTY
117895: LIST
117896: LIST
117897: LIST
117898: PPUSH
117899: CALL_OW 72
117903: ST_TO_ADDR
// if not tmp then
117904: LD_VAR 0 6
117908: NOT
117909: IFFALSE 117915
// exit ;
117911: POP
117912: POP
117913: GO 117995
// for j in tmp do
117915: LD_ADDR_VAR 0 4
117919: PUSH
117920: LD_VAR 0 6
117924: PUSH
117925: FOR_IN
117926: IFFALSE 117985
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
117928: LD_ADDR_VAR 0 7
117932: PUSH
117933: LD_VAR 0 4
117937: PPUSH
117938: CALL_OW 313
117942: PPUSH
117943: LD_INT 25
117945: PUSH
117946: LD_INT 1
117948: PUSH
117949: EMPTY
117950: LIST
117951: LIST
117952: PPUSH
117953: CALL_OW 72
117957: ST_TO_ADDR
// if units then
117958: LD_VAR 0 7
117962: IFFALSE 117983
// begin ComExitBuilding ( units [ 1 ] ) ;
117964: LD_VAR 0 7
117968: PUSH
117969: LD_INT 1
117971: ARRAY
117972: PPUSH
117973: CALL_OW 122
// exit ;
117977: POP
117978: POP
117979: POP
117980: POP
117981: GO 117995
// end ; end ;
117983: GO 117925
117985: POP
117986: POP
// end ; end ; exit ;
117987: POP
117988: POP
117989: GO 117995
// end ; end ;
117991: GO 117349
117993: POP
117994: POP
// end ;
117995: LD_VAR 0 2
117999: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
118000: LD_INT 0
118002: PPUSH
118003: PPUSH
118004: PPUSH
118005: PPUSH
118006: PPUSH
118007: PPUSH
118008: PPUSH
// if not mc_bases or not skirmish then
118009: LD_EXP 178
118013: NOT
118014: PUSH
118015: LD_EXP 176
118019: NOT
118020: OR
118021: IFFALSE 118025
// exit ;
118023: GO 118290
// btype := GetBType ( building ) ;
118025: LD_ADDR_VAR 0 6
118029: PUSH
118030: LD_VAR 0 1
118034: PPUSH
118035: CALL_OW 266
118039: ST_TO_ADDR
// x := GetX ( building ) ;
118040: LD_ADDR_VAR 0 7
118044: PUSH
118045: LD_VAR 0 1
118049: PPUSH
118050: CALL_OW 250
118054: ST_TO_ADDR
// y := GetY ( building ) ;
118055: LD_ADDR_VAR 0 8
118059: PUSH
118060: LD_VAR 0 1
118064: PPUSH
118065: CALL_OW 251
118069: ST_TO_ADDR
// d := GetDir ( building ) ;
118070: LD_ADDR_VAR 0 9
118074: PUSH
118075: LD_VAR 0 1
118079: PPUSH
118080: CALL_OW 254
118084: ST_TO_ADDR
// for i = 1 to mc_bases do
118085: LD_ADDR_VAR 0 4
118089: PUSH
118090: DOUBLE
118091: LD_INT 1
118093: DEC
118094: ST_TO_ADDR
118095: LD_EXP 178
118099: PUSH
118100: FOR_TO
118101: IFFALSE 118288
// begin if not mc_build_list [ i ] then
118103: LD_EXP 183
118107: PUSH
118108: LD_VAR 0 4
118112: ARRAY
118113: NOT
118114: IFFALSE 118118
// continue ;
118116: GO 118100
// for j := 1 to mc_build_list [ i ] do
118118: LD_ADDR_VAR 0 5
118122: PUSH
118123: DOUBLE
118124: LD_INT 1
118126: DEC
118127: ST_TO_ADDR
118128: LD_EXP 183
118132: PUSH
118133: LD_VAR 0 4
118137: ARRAY
118138: PUSH
118139: FOR_TO
118140: IFFALSE 118284
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ j ] ) then
118142: LD_VAR 0 6
118146: PUSH
118147: LD_VAR 0 7
118151: PUSH
118152: LD_VAR 0 8
118156: PUSH
118157: LD_VAR 0 9
118161: PUSH
118162: EMPTY
118163: LIST
118164: LIST
118165: LIST
118166: LIST
118167: PPUSH
118168: LD_EXP 183
118172: PUSH
118173: LD_VAR 0 4
118177: ARRAY
118178: PUSH
118179: LD_VAR 0 5
118183: ARRAY
118184: PPUSH
118185: CALL 30545 0 2
118189: IFFALSE 118282
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , j ) ) ;
118191: LD_ADDR_EXP 183
118195: PUSH
118196: LD_EXP 183
118200: PPUSH
118201: LD_VAR 0 4
118205: PPUSH
118206: LD_EXP 183
118210: PUSH
118211: LD_VAR 0 4
118215: ARRAY
118216: PPUSH
118217: LD_VAR 0 5
118221: PPUSH
118222: CALL_OW 3
118226: PPUSH
118227: CALL_OW 1
118231: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
118232: LD_ADDR_EXP 185
118236: PUSH
118237: LD_EXP 185
118241: PPUSH
118242: LD_VAR 0 4
118246: PUSH
118247: LD_EXP 185
118251: PUSH
118252: LD_VAR 0 4
118256: ARRAY
118257: PUSH
118258: LD_INT 1
118260: PLUS
118261: PUSH
118262: EMPTY
118263: LIST
118264: LIST
118265: PPUSH
118266: LD_VAR 0 1
118270: PPUSH
118271: CALL 24363 0 3
118275: ST_TO_ADDR
// exit ;
118276: POP
118277: POP
118278: POP
118279: POP
118280: GO 118290
// end ;
118282: GO 118139
118284: POP
118285: POP
// end ;
118286: GO 118100
118288: POP
118289: POP
// end ;
118290: LD_VAR 0 3
118294: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
118295: LD_INT 0
118297: PPUSH
118298: PPUSH
118299: PPUSH
// if not mc_bases or not skirmish then
118300: LD_EXP 178
118304: NOT
118305: PUSH
118306: LD_EXP 176
118310: NOT
118311: OR
118312: IFFALSE 118316
// exit ;
118314: GO 118506
// for i = 1 to mc_bases do
118316: LD_ADDR_VAR 0 4
118320: PUSH
118321: DOUBLE
118322: LD_INT 1
118324: DEC
118325: ST_TO_ADDR
118326: LD_EXP 178
118330: PUSH
118331: FOR_TO
118332: IFFALSE 118419
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
118334: LD_VAR 0 1
118338: PUSH
118339: LD_EXP 186
118343: PUSH
118344: LD_VAR 0 4
118348: ARRAY
118349: IN
118350: PUSH
118351: LD_VAR 0 1
118355: PUSH
118356: LD_EXP 187
118360: PUSH
118361: LD_VAR 0 4
118365: ARRAY
118366: IN
118367: NOT
118368: AND
118369: IFFALSE 118417
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
118371: LD_ADDR_EXP 187
118375: PUSH
118376: LD_EXP 187
118380: PPUSH
118381: LD_VAR 0 4
118385: PUSH
118386: LD_EXP 187
118390: PUSH
118391: LD_VAR 0 4
118395: ARRAY
118396: PUSH
118397: LD_INT 1
118399: PLUS
118400: PUSH
118401: EMPTY
118402: LIST
118403: LIST
118404: PPUSH
118405: LD_VAR 0 1
118409: PPUSH
118410: CALL 24363 0 3
118414: ST_TO_ADDR
// break ;
118415: GO 118419
// end ; end ;
118417: GO 118331
118419: POP
118420: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
118421: LD_VAR 0 1
118425: PPUSH
118426: CALL_OW 257
118430: PUSH
118431: LD_EXP 204
118435: IN
118436: PUSH
118437: LD_VAR 0 1
118441: PPUSH
118442: CALL_OW 266
118446: PUSH
118447: LD_INT 5
118449: EQUAL
118450: AND
118451: PUSH
118452: LD_VAR 0 2
118456: PPUSH
118457: CALL_OW 110
118461: PUSH
118462: LD_INT 18
118464: NONEQUAL
118465: AND
118466: IFFALSE 118506
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
118468: LD_VAR 0 2
118472: PPUSH
118473: CALL_OW 257
118477: PUSH
118478: LD_INT 5
118480: PUSH
118481: LD_INT 8
118483: PUSH
118484: LD_INT 9
118486: PUSH
118487: EMPTY
118488: LIST
118489: LIST
118490: LIST
118491: IN
118492: IFFALSE 118506
// SetClass ( unit , 1 ) ;
118494: LD_VAR 0 2
118498: PPUSH
118499: LD_INT 1
118501: PPUSH
118502: CALL_OW 336
// end ;
118506: LD_VAR 0 3
118510: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
118511: LD_INT 0
118513: PPUSH
118514: PPUSH
// if not mc_bases or not skirmish then
118515: LD_EXP 178
118519: NOT
118520: PUSH
118521: LD_EXP 176
118525: NOT
118526: OR
118527: IFFALSE 118531
// exit ;
118529: GO 118647
// if GetLives ( abandoned_vehicle ) > 250 then
118531: LD_VAR 0 2
118535: PPUSH
118536: CALL_OW 256
118540: PUSH
118541: LD_INT 250
118543: GREATER
118544: IFFALSE 118548
// exit ;
118546: GO 118647
// for i = 1 to mc_bases do
118548: LD_ADDR_VAR 0 6
118552: PUSH
118553: DOUBLE
118554: LD_INT 1
118556: DEC
118557: ST_TO_ADDR
118558: LD_EXP 178
118562: PUSH
118563: FOR_TO
118564: IFFALSE 118645
// begin if driver in mc_bases [ i ] then
118566: LD_VAR 0 1
118570: PUSH
118571: LD_EXP 178
118575: PUSH
118576: LD_VAR 0 6
118580: ARRAY
118581: IN
118582: IFFALSE 118643
// begin ComMoveToNearbyEntrance ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
118584: LD_VAR 0 1
118588: PPUSH
118589: LD_EXP 178
118593: PUSH
118594: LD_VAR 0 6
118598: ARRAY
118599: PPUSH
118600: LD_INT 2
118602: PUSH
118603: LD_INT 30
118605: PUSH
118606: LD_INT 0
118608: PUSH
118609: EMPTY
118610: LIST
118611: LIST
118612: PUSH
118613: LD_INT 30
118615: PUSH
118616: LD_INT 1
118618: PUSH
118619: EMPTY
118620: LIST
118621: LIST
118622: PUSH
118623: EMPTY
118624: LIST
118625: LIST
118626: LIST
118627: PPUSH
118628: CALL_OW 72
118632: PUSH
118633: LD_INT 1
118635: ARRAY
118636: PPUSH
118637: CALL 57502 0 2
// break ;
118641: GO 118645
// end ; end ;
118643: GO 118563
118645: POP
118646: POP
// end ;
118647: LD_VAR 0 5
118651: RET
