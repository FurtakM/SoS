// starting begin InitMission ;
   0: CALL 5 0 0
// end ;
   4: END
// export HeikeCaptured ; export coopWithGensher ; export HeikeStatus ; export Masha ; export dial_BuildDepotBlocker , dial_BuildArBarrackBlocker , dial_ArriveGensherUnitsBlocker ; export buildingsToBuild , techsToResearch , vehWeaponsToConstruct , availableWeapons , weaponsData , allBuildings ; export HeikeTargetX , HeikeTargetY , GensherTargetX , GensherTargetY ; export allowExitFromMap ; export acceptKurtOffert , askCommanders ; export KurtCanEscape , KurtStatus , KurtWaitingForFreeHeike , KurtWaitingForBuildBarrack ; export KurtAttack , americansAttack , forceStopKurtAttack ; export canSendHeike , canShootTrening ; export BurlakRespect ; export acceptLegionOffert , paidLegionOffert , legionOffertCountdown , legionOffertTime ; export firstMashaQuery , canChooseMashaVehicle ; export buildCompVehicle , buildArabBarrack , testedTeleport ; export lostUnits ; function InitMission ; begin
   5: LD_INT 0
   7: PPUSH
// ResetFog ;
   8: CALL_OW 335
// RandomizeAll ;
  12: CALL_OW 11
// InGameOn ;
  16: CALL_OW 8
// InitMapConfig ;
  20: CALL 358 0 0
// HeikeCaptured = LoadVariable ( 07_HeikeCaptured_1 , 0 ) ;
  24: LD_ADDR_EXP 1
  28: PUSH
  29: LD_STRING 07_HeikeCaptured_1
  31: PPUSH
  32: LD_INT 0
  34: PPUSH
  35: CALL_OW 30
  39: ST_TO_ADDR
// coopWithGensher = 0 ;
  40: LD_ADDR_EXP 2
  44: PUSH
  45: LD_INT 0
  47: ST_TO_ADDR
// HeikeStatus = 0 ;
  48: LD_ADDR_EXP 3
  52: PUSH
  53: LD_INT 0
  55: ST_TO_ADDR
// Masha = [ ] ;
  56: LD_ADDR_EXP 4
  60: PUSH
  61: EMPTY
  62: ST_TO_ADDR
// buildingsToBuild = [ ] ;
  63: LD_ADDR_EXP 8
  67: PUSH
  68: EMPTY
  69: ST_TO_ADDR
// techsToResearch = [ ] ;
  70: LD_ADDR_EXP 9
  74: PUSH
  75: EMPTY
  76: ST_TO_ADDR
// vehWeaponsToConstruct = [ ] ;
  77: LD_ADDR_EXP 10
  81: PUSH
  82: EMPTY
  83: ST_TO_ADDR
// availableWeapons = [ ] ;
  84: LD_ADDR_EXP 11
  88: PUSH
  89: EMPTY
  90: ST_TO_ADDR
// weaponsData = [ ] ;
  91: LD_ADDR_EXP 12
  95: PUSH
  96: EMPTY
  97: ST_TO_ADDR
// allBuildings = [ ] ;
  98: LD_ADDR_EXP 13
 102: PUSH
 103: EMPTY
 104: ST_TO_ADDR
// HeikeTargetX = 0 ;
 105: LD_ADDR_EXP 14
 109: PUSH
 110: LD_INT 0
 112: ST_TO_ADDR
// HeikeTargetY = 0 ;
 113: LD_ADDR_EXP 15
 117: PUSH
 118: LD_INT 0
 120: ST_TO_ADDR
// GensherTargetX = 0 ;
 121: LD_ADDR_EXP 16
 125: PUSH
 126: LD_INT 0
 128: ST_TO_ADDR
// GensherTargetY = 0 ;
 129: LD_ADDR_EXP 17
 133: PUSH
 134: LD_INT 0
 136: ST_TO_ADDR
// allowExitFromMap = 0 ;
 137: LD_ADDR_EXP 18
 141: PUSH
 142: LD_INT 0
 144: ST_TO_ADDR
// acceptKurtOffert = 0 ;
 145: LD_ADDR_EXP 19
 149: PUSH
 150: LD_INT 0
 152: ST_TO_ADDR
// askCommanders = 0 ;
 153: LD_ADDR_EXP 20
 157: PUSH
 158: LD_INT 0
 160: ST_TO_ADDR
// KurtCanEscape = true ;
 161: LD_ADDR_EXP 21
 165: PUSH
 166: LD_INT 1
 168: ST_TO_ADDR
// KurtAttack = false ;
 169: LD_ADDR_EXP 25
 173: PUSH
 174: LD_INT 0
 176: ST_TO_ADDR
// KurtWaitingForFreeHeike = false ;
 177: LD_ADDR_EXP 23
 181: PUSH
 182: LD_INT 0
 184: ST_TO_ADDR
// KurtWaitingForBuildBarrack = false ;
 185: LD_ADDR_EXP 24
 189: PUSH
 190: LD_INT 0
 192: ST_TO_ADDR
// KurtStatus = 0 ;
 193: LD_ADDR_EXP 22
 197: PUSH
 198: LD_INT 0
 200: ST_TO_ADDR
// americansAttack = false ;
 201: LD_ADDR_EXP 26
 205: PUSH
 206: LD_INT 0
 208: ST_TO_ADDR
// forceStopKurtAttack = false ;
 209: LD_ADDR_EXP 27
 213: PUSH
 214: LD_INT 0
 216: ST_TO_ADDR
// canSendHeike = false ;
 217: LD_ADDR_EXP 28
 221: PUSH
 222: LD_INT 0
 224: ST_TO_ADDR
// canShootTrening = false ;
 225: LD_ADDR_EXP 29
 229: PUSH
 230: LD_INT 0
 232: ST_TO_ADDR
// BurlakRespect = 0 ;
 233: LD_ADDR_EXP 30
 237: PUSH
 238: LD_INT 0
 240: ST_TO_ADDR
// acceptLegionOffert = false ;
 241: LD_ADDR_EXP 31
 245: PUSH
 246: LD_INT 0
 248: ST_TO_ADDR
// paidLegionOffert = false ;
 249: LD_ADDR_EXP 32
 253: PUSH
 254: LD_INT 0
 256: ST_TO_ADDR
// legionOffertCountdown = false ;
 257: LD_ADDR_EXP 33
 261: PUSH
 262: LD_INT 0
 264: ST_TO_ADDR
// legionOffertTime = 0 0$60 ;
 265: LD_ADDR_EXP 34
 269: PUSH
 270: LD_INT 2100
 272: ST_TO_ADDR
// canChooseMashaVehicle = false ;
 273: LD_ADDR_EXP 36
 277: PUSH
 278: LD_INT 0
 280: ST_TO_ADDR
// firstMashaQuery = true ;
 281: LD_ADDR_EXP 35
 285: PUSH
 286: LD_INT 1
 288: ST_TO_ADDR
// buildArabBarrack = false ;
 289: LD_ADDR_EXP 38
 293: PUSH
 294: LD_INT 0
 296: ST_TO_ADDR
// buildCompVehicle = false ;
 297: LD_ADDR_EXP 37
 301: PUSH
 302: LD_INT 0
 304: ST_TO_ADDR
// testedTeleport = false ;
 305: LD_ADDR_EXP 39
 309: PUSH
 310: LD_INT 0
 312: ST_TO_ADDR
// lostUnits = 0 ;
 313: LD_ADDR_EXP 40
 317: PUSH
 318: LD_INT 0
 320: ST_TO_ADDR
// PrepareRussians ;
 321: CALL 1292 0 0
// PrepareArabians ;
 325: CALL 3847 0 0
// PrepareAmericans ;
 329: CALL 2975 0 0
// Nef_PrepareNature ;
 333: CALL 4831 0 0
// SpawnTrees ;
 337: CALL 5452 0 0
// MissionIntro ;
 341: CALL 9085 0 0
// end ;
 345: LD_VAR 0 1
 349: RET
// export function CustomInitMacro ; begin
 350: LD_INT 0
 352: PPUSH
// end ; end_of_file
 353: LD_VAR 0 1
 357: RET
// export function InitMapConfig ; begin
 358: LD_INT 0
 360: PPUSH
// BaseMapConfig ;
 361: CALL 374 0 0
// MissionMapConfig ;
 365: CALL 464 0 0
// end ;
 369: LD_VAR 0 1
 373: RET
// export animalsAmount , animalsStats , animalsAgression , missionPrefix , previousMissionPrefix , debugMode ; function BaseMapConfig ; begin
 374: LD_INT 0
 376: PPUSH
// animalsAmount = [ 6 , 3 , 4 , 4 , 1 ] ;
 377: LD_ADDR_EXP 41
 381: PUSH
 382: LD_INT 6
 384: PUSH
 385: LD_INT 3
 387: PUSH
 388: LD_INT 4
 390: PUSH
 391: LD_INT 4
 393: PUSH
 394: LD_INT 1
 396: PUSH
 397: EMPTY
 398: LIST
 399: LIST
 400: LIST
 401: LIST
 402: LIST
 403: ST_TO_ADDR
// animalsStats = [ 2 , 2 , 2 , 2 ] ;
 404: LD_ADDR_EXP 42
 408: PUSH
 409: LD_INT 2
 411: PUSH
 412: LD_INT 2
 414: PUSH
 415: LD_INT 2
 417: PUSH
 418: LD_INT 2
 420: PUSH
 421: EMPTY
 422: LIST
 423: LIST
 424: LIST
 425: LIST
 426: ST_TO_ADDR
// animalsAgression = 3 ;
 427: LD_ADDR_EXP 43
 431: PUSH
 432: LD_INT 3
 434: ST_TO_ADDR
// debugMode = 0 ;
 435: LD_ADDR_EXP 46
 439: PUSH
 440: LD_INT 0
 442: ST_TO_ADDR
// missionPrefix = 08_ ;
 443: LD_ADDR_EXP 44
 447: PUSH
 448: LD_STRING 08_
 450: ST_TO_ADDR
// previousMissionPrefix = 07_ ;
 451: LD_ADDR_EXP 45
 455: PUSH
 456: LD_STRING 07_
 458: ST_TO_ADDR
// end ;
 459: LD_VAR 0 1
 463: RET
// export KurtAttackWaves , americansAttackWaves ; export firstAttackDelay ; export waveCooldown ; export legionReduceAmericansUnits ; export speedMedalTime ; export enemyAttackUnitsData ; export timeToFreeHeike , timeToBuildArBarrack ; export enemySkillLevel ; function MissionMapConfig ; begin
 464: LD_INT 0
 466: PPUSH
// KurtAttackWaves = [ 3 , 4 , 5 , 6 ] [ Difficulty ] ;
 467: LD_ADDR_EXP 47
 471: PUSH
 472: LD_INT 3
 474: PUSH
 475: LD_INT 4
 477: PUSH
 478: LD_INT 5
 480: PUSH
 481: LD_INT 6
 483: PUSH
 484: EMPTY
 485: LIST
 486: LIST
 487: LIST
 488: LIST
 489: PUSH
 490: LD_OWVAR 67
 494: ARRAY
 495: ST_TO_ADDR
// americansAttackWaves = [ 1 , 2 , 3 , 4 ] [ Difficulty ] ;
 496: LD_ADDR_EXP 48
 500: PUSH
 501: LD_INT 1
 503: PUSH
 504: LD_INT 2
 506: PUSH
 507: LD_INT 3
 509: PUSH
 510: LD_INT 4
 512: PUSH
 513: EMPTY
 514: LIST
 515: LIST
 516: LIST
 517: LIST
 518: PUSH
 519: LD_OWVAR 67
 523: ARRAY
 524: ST_TO_ADDR
// enemySkillLevel = [ 3 , 4 , 5 , 6 ] [ Difficulty ] ;
 525: LD_ADDR_EXP 56
 529: PUSH
 530: LD_INT 3
 532: PUSH
 533: LD_INT 4
 535: PUSH
 536: LD_INT 5
 538: PUSH
 539: LD_INT 6
 541: PUSH
 542: EMPTY
 543: LIST
 544: LIST
 545: LIST
 546: LIST
 547: PUSH
 548: LD_OWVAR 67
 552: ARRAY
 553: ST_TO_ADDR
// waveCooldown = 1 1$30 ;
 554: LD_ADDR_EXP 50
 558: PUSH
 559: LD_INT 3150
 561: ST_TO_ADDR
// firstAttackDelay = 1 1$00 ;
 562: LD_ADDR_EXP 49
 566: PUSH
 567: LD_INT 2100
 569: ST_TO_ADDR
// timeToFreeHeike = 2 2$00 ;
 570: LD_ADDR_EXP 54
 574: PUSH
 575: LD_INT 4200
 577: ST_TO_ADDR
// timeToBuildArBarrack = 5 5$00 ;
 578: LD_ADDR_EXP 55
 582: PUSH
 583: LD_INT 10500
 585: ST_TO_ADDR
// legionReduceAmericansUnits = [ 5 , 5 , 6 , 6 ] [ Difficulty ] ;
 586: LD_ADDR_EXP 51
 590: PUSH
 591: LD_INT 5
 593: PUSH
 594: LD_INT 5
 596: PUSH
 597: LD_INT 6
 599: PUSH
 600: LD_INT 6
 602: PUSH
 603: EMPTY
 604: LIST
 605: LIST
 606: LIST
 607: LIST
 608: PUSH
 609: LD_OWVAR 67
 613: ARRAY
 614: ST_TO_ADDR
// speedMedalTime = [ 80 80$0 , 70 70$0 , 60 60$0 , 50 50$0 ] [ Difficulty ] ;
 615: LD_ADDR_EXP 52
 619: PUSH
 620: LD_INT 168000
 622: PUSH
 623: LD_INT 147000
 625: PUSH
 626: LD_INT 126000
 628: PUSH
 629: LD_INT 105000
 631: PUSH
 632: EMPTY
 633: LIST
 634: LIST
 635: LIST
 636: LIST
 637: PUSH
 638: LD_OWVAR 67
 642: ARRAY
 643: ST_TO_ADDR
// enemyAttackUnitsData = [ [ 1 , [ 4 , 5 , 6 , 6 ] [ Difficulty ] , [ 7 , 8 , 9 , 9 ] [ Difficulty ] , [ 1 , 2 , 2 , 3 ] [ Difficulty ] , [ 3 , 3 , 4 , 4 ] [ Difficulty ] , [ 6 , 7 , 8 , 8 ] [ Difficulty ] , [ 10 , 12 , 15 , 15 ] [ Difficulty ] ] , [ 8 , [ 2 , 3 , 4 , 4 ] [ Difficulty ] , [ 6 , 6 , 7 , 7 ] [ Difficulty ] , [ 0 , 1 , 1 , 2 ] [ Difficulty ] , [ 1 , 2 , 3 , 3 ] [ Difficulty ] , [ 1 , 2 , 2 , 2 ] [ Difficulty ] , [ 2 , 3 , 5 , 5 ] [ Difficulty ] ] ] ;
 644: LD_ADDR_EXP 53
 648: PUSH
 649: LD_INT 1
 651: PUSH
 652: LD_INT 4
 654: PUSH
 655: LD_INT 5
 657: PUSH
 658: LD_INT 6
 660: PUSH
 661: LD_INT 6
 663: PUSH
 664: EMPTY
 665: LIST
 666: LIST
 667: LIST
 668: LIST
 669: PUSH
 670: LD_OWVAR 67
 674: ARRAY
 675: PUSH
 676: LD_INT 7
 678: PUSH
 679: LD_INT 8
 681: PUSH
 682: LD_INT 9
 684: PUSH
 685: LD_INT 9
 687: PUSH
 688: EMPTY
 689: LIST
 690: LIST
 691: LIST
 692: LIST
 693: PUSH
 694: LD_OWVAR 67
 698: ARRAY
 699: PUSH
 700: LD_INT 1
 702: PUSH
 703: LD_INT 2
 705: PUSH
 706: LD_INT 2
 708: PUSH
 709: LD_INT 3
 711: PUSH
 712: EMPTY
 713: LIST
 714: LIST
 715: LIST
 716: LIST
 717: PUSH
 718: LD_OWVAR 67
 722: ARRAY
 723: PUSH
 724: LD_INT 3
 726: PUSH
 727: LD_INT 3
 729: PUSH
 730: LD_INT 4
 732: PUSH
 733: LD_INT 4
 735: PUSH
 736: EMPTY
 737: LIST
 738: LIST
 739: LIST
 740: LIST
 741: PUSH
 742: LD_OWVAR 67
 746: ARRAY
 747: PUSH
 748: LD_INT 6
 750: PUSH
 751: LD_INT 7
 753: PUSH
 754: LD_INT 8
 756: PUSH
 757: LD_INT 8
 759: PUSH
 760: EMPTY
 761: LIST
 762: LIST
 763: LIST
 764: LIST
 765: PUSH
 766: LD_OWVAR 67
 770: ARRAY
 771: PUSH
 772: LD_INT 10
 774: PUSH
 775: LD_INT 12
 777: PUSH
 778: LD_INT 15
 780: PUSH
 781: LD_INT 15
 783: PUSH
 784: EMPTY
 785: LIST
 786: LIST
 787: LIST
 788: LIST
 789: PUSH
 790: LD_OWVAR 67
 794: ARRAY
 795: PUSH
 796: EMPTY
 797: LIST
 798: LIST
 799: LIST
 800: LIST
 801: LIST
 802: LIST
 803: LIST
 804: PUSH
 805: LD_INT 8
 807: PUSH
 808: LD_INT 2
 810: PUSH
 811: LD_INT 3
 813: PUSH
 814: LD_INT 4
 816: PUSH
 817: LD_INT 4
 819: PUSH
 820: EMPTY
 821: LIST
 822: LIST
 823: LIST
 824: LIST
 825: PUSH
 826: LD_OWVAR 67
 830: ARRAY
 831: PUSH
 832: LD_INT 6
 834: PUSH
 835: LD_INT 6
 837: PUSH
 838: LD_INT 7
 840: PUSH
 841: LD_INT 7
 843: PUSH
 844: EMPTY
 845: LIST
 846: LIST
 847: LIST
 848: LIST
 849: PUSH
 850: LD_OWVAR 67
 854: ARRAY
 855: PUSH
 856: LD_INT 0
 858: PUSH
 859: LD_INT 1
 861: PUSH
 862: LD_INT 1
 864: PUSH
 865: LD_INT 2
 867: PUSH
 868: EMPTY
 869: LIST
 870: LIST
 871: LIST
 872: LIST
 873: PUSH
 874: LD_OWVAR 67
 878: ARRAY
 879: PUSH
 880: LD_INT 1
 882: PUSH
 883: LD_INT 2
 885: PUSH
 886: LD_INT 3
 888: PUSH
 889: LD_INT 3
 891: PUSH
 892: EMPTY
 893: LIST
 894: LIST
 895: LIST
 896: LIST
 897: PUSH
 898: LD_OWVAR 67
 902: ARRAY
 903: PUSH
 904: LD_INT 1
 906: PUSH
 907: LD_INT 2
 909: PUSH
 910: LD_INT 2
 912: PUSH
 913: LD_INT 2
 915: PUSH
 916: EMPTY
 917: LIST
 918: LIST
 919: LIST
 920: LIST
 921: PUSH
 922: LD_OWVAR 67
 926: ARRAY
 927: PUSH
 928: LD_INT 2
 930: PUSH
 931: LD_INT 3
 933: PUSH
 934: LD_INT 5
 936: PUSH
 937: LD_INT 5
 939: PUSH
 940: EMPTY
 941: LIST
 942: LIST
 943: LIST
 944: LIST
 945: PUSH
 946: LD_OWVAR 67
 950: ARRAY
 951: PUSH
 952: EMPTY
 953: LIST
 954: LIST
 955: LIST
 956: LIST
 957: LIST
 958: LIST
 959: LIST
 960: PUSH
 961: EMPTY
 962: LIST
 963: LIST
 964: ST_TO_ADDR
// end ;
 965: LD_VAR 0 1
 969: RET
// every 0 0$1 trigger debugMode do var i ;
 970: LD_EXP 46
 974: IFFALSE 1289
 976: GO 978
 978: DISABLE
 979: LD_INT 0
 981: PPUSH
// begin enable ;
 982: ENABLE
// FogOff ( your_side ) ;
 983: LD_OWVAR 2
 987: PPUSH
 988: CALL_OW 344
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) do
 992: LD_ADDR_VAR 0 1
 996: PUSH
 997: LD_INT 22
 999: PUSH
1000: LD_OWVAR 2
1004: PUSH
1005: EMPTY
1006: LIST
1007: LIST
1008: PUSH
1009: LD_INT 2
1011: PUSH
1012: LD_INT 21
1014: PUSH
1015: LD_INT 1
1017: PUSH
1018: EMPTY
1019: LIST
1020: LIST
1021: PUSH
1022: LD_INT 21
1024: PUSH
1025: LD_INT 2
1027: PUSH
1028: EMPTY
1029: LIST
1030: LIST
1031: PUSH
1032: EMPTY
1033: LIST
1034: LIST
1035: LIST
1036: PUSH
1037: EMPTY
1038: LIST
1039: LIST
1040: PPUSH
1041: CALL_OW 69
1045: PUSH
1046: FOR_IN
1047: IFFALSE 1063
// SetLives ( i , 1000 ) ;
1049: LD_VAR 0 1
1053: PPUSH
1054: LD_INT 1000
1056: PPUSH
1057: CALL_OW 234
1061: GO 1046
1063: POP
1064: POP
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) do
1065: LD_ADDR_VAR 0 1
1069: PUSH
1070: LD_INT 22
1072: PUSH
1073: LD_OWVAR 2
1077: PUSH
1078: EMPTY
1079: LIST
1080: LIST
1081: PUSH
1082: LD_INT 21
1084: PUSH
1085: LD_INT 1
1087: PUSH
1088: EMPTY
1089: LIST
1090: LIST
1091: PUSH
1092: EMPTY
1093: LIST
1094: LIST
1095: PPUSH
1096: CALL_OW 69
1100: PUSH
1101: FOR_IN
1102: IFFALSE 1166
// begin SetSkill ( i , skill_combat , 10 ) ;
1104: LD_VAR 0 1
1108: PPUSH
1109: LD_INT 1
1111: PPUSH
1112: LD_INT 10
1114: PPUSH
1115: CALL_OW 237
// SetSkill ( i , skill_engineering , 10 ) ;
1119: LD_VAR 0 1
1123: PPUSH
1124: LD_INT 2
1126: PPUSH
1127: LD_INT 10
1129: PPUSH
1130: CALL_OW 237
// SetSkill ( i , skill_mechanical , 10 ) ;
1134: LD_VAR 0 1
1138: PPUSH
1139: LD_INT 3
1141: PPUSH
1142: LD_INT 10
1144: PPUSH
1145: CALL_OW 237
// SetSkill ( i , skill_scientistic , 10 ) ;
1149: LD_VAR 0 1
1153: PPUSH
1154: LD_INT 4
1156: PPUSH
1157: LD_INT 10
1159: PPUSH
1160: CALL_OW 237
// end ;
1164: GO 1101
1166: POP
1167: POP
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) do
1168: LD_ADDR_VAR 0 1
1172: PUSH
1173: LD_INT 22
1175: PUSH
1176: LD_OWVAR 2
1180: PUSH
1181: EMPTY
1182: LIST
1183: LIST
1184: PUSH
1185: LD_INT 2
1187: PUSH
1188: LD_INT 30
1190: PUSH
1191: LD_INT 0
1193: PUSH
1194: EMPTY
1195: LIST
1196: LIST
1197: PUSH
1198: LD_INT 30
1200: PUSH
1201: LD_INT 1
1203: PUSH
1204: EMPTY
1205: LIST
1206: LIST
1207: PUSH
1208: EMPTY
1209: LIST
1210: LIST
1211: LIST
1212: PUSH
1213: EMPTY
1214: LIST
1215: LIST
1216: PPUSH
1217: CALL_OW 69
1221: PUSH
1222: FOR_IN
1223: IFFALSE 1287
// begin SetResourceType ( GetBase ( i ) , mat_cans , 9999 ) ;
1225: LD_VAR 0 1
1229: PPUSH
1230: CALL_OW 274
1234: PPUSH
1235: LD_INT 1
1237: PPUSH
1238: LD_INT 9999
1240: PPUSH
1241: CALL_OW 277
// SetResourceType ( GetBase ( i ) , mat_oil , 9999 ) ;
1245: LD_VAR 0 1
1249: PPUSH
1250: CALL_OW 274
1254: PPUSH
1255: LD_INT 2
1257: PPUSH
1258: LD_INT 9999
1260: PPUSH
1261: CALL_OW 277
// SetResourceType ( GetBase ( i ) , mat_siberit , 9999 ) ;
1265: LD_VAR 0 1
1269: PPUSH
1270: CALL_OW 274
1274: PPUSH
1275: LD_INT 3
1277: PPUSH
1278: LD_INT 9999
1280: PPUSH
1281: CALL_OW 277
// end ;
1285: GO 1222
1287: POP
1288: POP
// end ; end_of_file
1289: PPOPN 1
1291: END
// export Burlak , Karamazov , Petrovova , Gleb , Petrosyan , Titov , Dolgov , Lipshchin , Kirilenkova , Belkov , Belkov2 , Xavier ; export Gnyevko , Kovalyuk , Scholtze , Kuzmov ; export Kozlov , Oblukov , Kapitsova ; export Popov ; export russianEscort ; export function PrepareRussians ; begin
1292: LD_INT 0
1294: PPUSH
// russianEscort = [ ] ;
1295: LD_ADDR_EXP 77
1299: PUSH
1300: EMPTY
1301: ST_TO_ADDR
// Masha = [ ] ;
1302: LD_ADDR_EXP 4
1306: PUSH
1307: EMPTY
1308: ST_TO_ADDR
// PrepareHeroes ;
1309: CALL 1322 0 0
// InitRussianRequiments ;
1313: CALL 2717 0 0
// end ;
1317: LD_VAR 0 1
1321: RET
// function PrepareHeroes ; var i , un , other_survivors , yourUnits , emptyVeh ; begin
1322: LD_INT 0
1324: PPUSH
1325: PPUSH
1326: PPUSH
1327: PPUSH
1328: PPUSH
1329: PPUSH
// uc_side = 3 ;
1330: LD_ADDR_OWVAR 20
1334: PUSH
1335: LD_INT 3
1337: ST_TO_ADDR
// uc_nation = 3 ;
1338: LD_ADDR_OWVAR 21
1342: PUSH
1343: LD_INT 3
1345: ST_TO_ADDR
// Burlak := PrepareUnitExt ( Burlak , true , class_mechanic ) ;
1346: LD_ADDR_EXP 57
1350: PUSH
1351: LD_STRING Burlak
1353: PPUSH
1354: LD_INT 1
1356: PPUSH
1357: LD_INT 3
1359: PPUSH
1360: CALL 5930 0 3
1364: ST_TO_ADDR
// Titov := PrepareUnitExt ( Titov , true , class_soldier ) ;
1365: LD_ADDR_EXP 62
1369: PUSH
1370: LD_STRING Titov
1372: PPUSH
1373: LD_INT 1
1375: PPUSH
1376: LD_INT 1
1378: PPUSH
1379: CALL 5930 0 3
1383: ST_TO_ADDR
// Dolgov := PrepareUnitExt ( Dolgov , true , class_scientistic ) ;
1384: LD_ADDR_EXP 63
1388: PUSH
1389: LD_STRING Dolgov
1391: PPUSH
1392: LD_INT 1
1394: PPUSH
1395: LD_INT 4
1397: PPUSH
1398: CALL 5930 0 3
1402: ST_TO_ADDR
// Lipshchin := PrepareUnitExt ( Lipshchin , true , class_soldier ) ;
1403: LD_ADDR_EXP 64
1407: PUSH
1408: LD_STRING Lipshchin
1410: PPUSH
1411: LD_INT 1
1413: PPUSH
1414: LD_INT 1
1416: PPUSH
1417: CALL 5930 0 3
1421: ST_TO_ADDR
// Karamazov := PrepareUnitExt ( Karamazov , true , class_engineer ) ;
1422: LD_ADDR_EXP 58
1426: PUSH
1427: LD_STRING Karamazov
1429: PPUSH
1430: LD_INT 1
1432: PPUSH
1433: LD_INT 2
1435: PPUSH
1436: CALL 5930 0 3
1440: ST_TO_ADDR
// Petrovova := PrepareUnitExt ( Petrovova , true , class_soldier ) ;
1441: LD_ADDR_EXP 59
1445: PUSH
1446: LD_STRING Petrovova
1448: PPUSH
1449: LD_INT 1
1451: PPUSH
1452: LD_INT 1
1454: PPUSH
1455: CALL 5930 0 3
1459: ST_TO_ADDR
// Gleb := PrepareUnitExt ( Gleb , true , class_soldier ) ;
1460: LD_ADDR_EXP 60
1464: PUSH
1465: LD_STRING Gleb
1467: PPUSH
1468: LD_INT 1
1470: PPUSH
1471: LD_INT 1
1473: PPUSH
1474: CALL 5930 0 3
1478: ST_TO_ADDR
// Petrosyan := PrepareUnitExt ( Petrosyan , true , class_scientistic ) ;
1479: LD_ADDR_EXP 61
1483: PUSH
1484: LD_STRING Petrosyan
1486: PPUSH
1487: LD_INT 1
1489: PPUSH
1490: LD_INT 4
1492: PPUSH
1493: CALL 5930 0 3
1497: ST_TO_ADDR
// Kirilenkova := PrepareUnitExt ( Kirilenkova , true , class_scientistic ) ;
1498: LD_ADDR_EXP 65
1502: PUSH
1503: LD_STRING Kirilenkova
1505: PPUSH
1506: LD_INT 1
1508: PPUSH
1509: LD_INT 4
1511: PPUSH
1512: CALL 5930 0 3
1516: ST_TO_ADDR
// Belkov := PrepareUnitExt ( Belkov , true , class_soldier ) ;
1517: LD_ADDR_EXP 66
1521: PUSH
1522: LD_STRING Belkov
1524: PPUSH
1525: LD_INT 1
1527: PPUSH
1528: LD_INT 1
1530: PPUSH
1531: CALL 5930 0 3
1535: ST_TO_ADDR
// Belkov2 := PrepareUnitExt ( Belkov2 , true , class_soldier ) ;
1536: LD_ADDR_EXP 67
1540: PUSH
1541: LD_STRING Belkov2
1543: PPUSH
1544: LD_INT 1
1546: PPUSH
1547: LD_INT 1
1549: PPUSH
1550: CALL 5930 0 3
1554: ST_TO_ADDR
// Xavier := PrepareUnitExt ( Xavier , true , class_soldier ) ;
1555: LD_ADDR_EXP 68
1559: PUSH
1560: LD_STRING Xavier
1562: PPUSH
1563: LD_INT 1
1565: PPUSH
1566: LD_INT 1
1568: PPUSH
1569: CALL 5930 0 3
1573: ST_TO_ADDR
// Gnyevko := CreateCharacter ( 04_Gnyevko ) ;
1574: LD_ADDR_EXP 69
1578: PUSH
1579: LD_STRING 04_Gnyevko
1581: PPUSH
1582: CALL_OW 34
1586: ST_TO_ADDR
// SetClass ( Gnyevko , class_soldier ) ;
1587: LD_EXP 69
1591: PPUSH
1592: LD_INT 1
1594: PPUSH
1595: CALL_OW 336
// Kovalyuk := CreateCharacter ( 04_Kovalyuk ) ;
1599: LD_ADDR_EXP 70
1603: PUSH
1604: LD_STRING 04_Kovalyuk
1606: PPUSH
1607: CALL_OW 34
1611: ST_TO_ADDR
// SetClass ( Kovalyuk , class_mechanic ) ;
1612: LD_EXP 70
1616: PPUSH
1617: LD_INT 3
1619: PPUSH
1620: CALL_OW 336
// Scholtze := CreateCharacter ( 04_Scholtze ) ;
1624: LD_ADDR_EXP 71
1628: PUSH
1629: LD_STRING 04_Scholtze
1631: PPUSH
1632: CALL_OW 34
1636: ST_TO_ADDR
// SetClass ( Scholtze , class_scientistic ) ;
1637: LD_EXP 71
1641: PPUSH
1642: LD_INT 4
1644: PPUSH
1645: CALL_OW 336
// Kuzmov := CreateCharacter ( 04_Kuzmov ) ;
1649: LD_ADDR_EXP 72
1653: PUSH
1654: LD_STRING 04_Kuzmov
1656: PPUSH
1657: CALL_OW 34
1661: ST_TO_ADDR
// SetClass ( Kuzmov , class_soldier ) ;
1662: LD_EXP 72
1666: PPUSH
1667: LD_INT 1
1669: PPUSH
1670: CALL_OW 336
// Kozlov := PrepareUnitExt ( Kozlov , false , class_engineer ) ;
1674: LD_ADDR_EXP 73
1678: PUSH
1679: LD_STRING Kozlov
1681: PPUSH
1682: LD_INT 0
1684: PPUSH
1685: LD_INT 2
1687: PPUSH
1688: CALL 5930 0 3
1692: ST_TO_ADDR
// Oblukov := PrepareUnitExt ( Oblukov , false , class_soldier ) ;
1693: LD_ADDR_EXP 74
1697: PUSH
1698: LD_STRING Oblukov
1700: PPUSH
1701: LD_INT 0
1703: PPUSH
1704: LD_INT 1
1706: PPUSH
1707: CALL 5930 0 3
1711: ST_TO_ADDR
// Kapitsova := PrepareUnitExt ( Kapitsova , false , class_scientistic ) ;
1712: LD_ADDR_EXP 75
1716: PUSH
1717: LD_STRING Kapitsova
1719: PPUSH
1720: LD_INT 0
1722: PPUSH
1723: LD_INT 4
1725: PPUSH
1726: CALL 5930 0 3
1730: ST_TO_ADDR
// Popov := PrepareUnitExt ( Popov , false , 0 ) ;
1731: LD_ADDR_EXP 76
1735: PUSH
1736: LD_STRING Popov
1738: PPUSH
1739: LD_INT 0
1741: PPUSH
1742: LD_INT 0
1744: PPUSH
1745: CALL 5930 0 3
1749: ST_TO_ADDR
// PlaceUnitsArea ( [ Burlak , Karamazov , Petrovova , Gleb , Petrosyan , Titov , Dolgov , Lipshchin , Kirilenkova , Belkov , Belkov2 , Xavier , Gnyevko , Kovalyuk , Scholtze , Kuzmov , Kozlov , Oblukov , Kapitsova ] , RussianSpawnArea , false ) ;
1750: LD_EXP 57
1754: PUSH
1755: LD_EXP 58
1759: PUSH
1760: LD_EXP 59
1764: PUSH
1765: LD_EXP 60
1769: PUSH
1770: LD_EXP 61
1774: PUSH
1775: LD_EXP 62
1779: PUSH
1780: LD_EXP 63
1784: PUSH
1785: LD_EXP 64
1789: PUSH
1790: LD_EXP 65
1794: PUSH
1795: LD_EXP 66
1799: PUSH
1800: LD_EXP 67
1804: PUSH
1805: LD_EXP 68
1809: PUSH
1810: LD_EXP 69
1814: PUSH
1815: LD_EXP 70
1819: PUSH
1820: LD_EXP 71
1824: PUSH
1825: LD_EXP 72
1829: PUSH
1830: LD_EXP 73
1834: PUSH
1835: LD_EXP 74
1839: PUSH
1840: LD_EXP 75
1844: PUSH
1845: EMPTY
1846: LIST
1847: LIST
1848: LIST
1849: LIST
1850: LIST
1851: LIST
1852: LIST
1853: LIST
1854: LIST
1855: LIST
1856: LIST
1857: LIST
1858: LIST
1859: LIST
1860: LIST
1861: LIST
1862: LIST
1863: LIST
1864: LIST
1865: PPUSH
1866: LD_INT 2
1868: PPUSH
1869: LD_INT 0
1871: PPUSH
1872: CALL 6204 0 3
// PrepareVehicles ;
1876: CALL 2417 0 0
// other_survivors = CreateCharacterSet ( 07_other_survivors ) ;
1880: LD_ADDR_VAR 0 4
1884: PUSH
1885: LD_STRING 07_other_survivors
1887: PPUSH
1888: CALL_OW 31
1892: ST_TO_ADDR
// other_survivors = other_survivors ^ CreateCharacterSet ( 04_other_survivors ) ;
1893: LD_ADDR_VAR 0 4
1897: PUSH
1898: LD_VAR 0 4
1902: PUSH
1903: LD_STRING 04_other_survivors
1905: PPUSH
1906: CALL_OW 31
1910: ADD
1911: ST_TO_ADDR
// other_survivors = other_survivors ^ CreateCharacterSet ( 04_other_survivors_with_popov ) ;
1912: LD_ADDR_VAR 0 4
1916: PUSH
1917: LD_VAR 0 4
1921: PUSH
1922: LD_STRING 04_other_survivors_with_popov
1924: PPUSH
1925: CALL_OW 31
1929: ADD
1930: ST_TO_ADDR
// for un in other_survivors do
1931: LD_ADDR_VAR 0 3
1935: PUSH
1936: LD_VAR 0 4
1940: PUSH
1941: FOR_IN
1942: IFFALSE 2028
// begin emptyVeh = FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_vehicle ] , [ f_empty ] ] ) ;
1944: LD_ADDR_VAR 0 6
1948: PUSH
1949: LD_INT 22
1951: PUSH
1952: LD_INT 3
1954: PUSH
1955: EMPTY
1956: LIST
1957: LIST
1958: PUSH
1959: LD_INT 21
1961: PUSH
1962: LD_INT 2
1964: PUSH
1965: EMPTY
1966: LIST
1967: LIST
1968: PUSH
1969: LD_INT 58
1971: PUSH
1972: EMPTY
1973: LIST
1974: PUSH
1975: EMPTY
1976: LIST
1977: LIST
1978: LIST
1979: PPUSH
1980: CALL_OW 69
1984: ST_TO_ADDR
// if emptyVeh then
1985: LD_VAR 0 6
1989: IFFALSE 2011
// PlaceHumanInUnit ( un , emptyVeh [ 1 ] ) else
1991: LD_VAR 0 3
1995: PPUSH
1996: LD_VAR 0 6
2000: PUSH
2001: LD_INT 1
2003: ARRAY
2004: PPUSH
2005: CALL_OW 52
2009: GO 2026
// PlaceUnitArea ( un , RussianSpawnArea , false ) ;
2011: LD_VAR 0 3
2015: PPUSH
2016: LD_INT 2
2018: PPUSH
2019: LD_INT 0
2021: PPUSH
2022: CALL_OW 49
// end ;
2026: GO 1941
2028: POP
2029: POP
// yourUnits = FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_nation , nation_russian ] ] ) ;
2030: LD_ADDR_VAR 0 5
2034: PUSH
2035: LD_INT 22
2037: PUSH
2038: LD_INT 3
2040: PUSH
2041: EMPTY
2042: LIST
2043: LIST
2044: PUSH
2045: LD_INT 21
2047: PUSH
2048: LD_INT 1
2050: PUSH
2051: EMPTY
2052: LIST
2053: LIST
2054: PUSH
2055: LD_INT 23
2057: PUSH
2058: LD_INT 3
2060: PUSH
2061: EMPTY
2062: LIST
2063: LIST
2064: PUSH
2065: EMPTY
2066: LIST
2067: LIST
2068: LIST
2069: PPUSH
2070: CALL_OW 69
2074: ST_TO_ADDR
// if yourUnits < 15 then
2075: LD_VAR 0 5
2079: PUSH
2080: LD_INT 15
2082: LESS
2083: IFFALSE 2232
// for i := 1 to 15 - yourUnits do
2085: LD_ADDR_VAR 0 2
2089: PUSH
2090: DOUBLE
2091: LD_INT 1
2093: DEC
2094: ST_TO_ADDR
2095: LD_INT 15
2097: PUSH
2098: LD_VAR 0 5
2102: MINUS
2103: PUSH
2104: FOR_TO
2105: IFFALSE 2230
// begin PrepareHuman ( false , rand ( 1 , 4 ) , rand ( 2 , 4 ) ) ;
2107: LD_INT 0
2109: PPUSH
2110: LD_INT 1
2112: PPUSH
2113: LD_INT 4
2115: PPUSH
2116: CALL_OW 12
2120: PPUSH
2121: LD_INT 2
2123: PPUSH
2124: LD_INT 4
2126: PPUSH
2127: CALL_OW 12
2131: PPUSH
2132: CALL_OW 380
// un = CreateHuman ;
2136: LD_ADDR_VAR 0 3
2140: PUSH
2141: CALL_OW 44
2145: ST_TO_ADDR
// emptyVeh = FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_vehicle ] , [ f_empty ] ] ) ;
2146: LD_ADDR_VAR 0 6
2150: PUSH
2151: LD_INT 22
2153: PUSH
2154: LD_INT 3
2156: PUSH
2157: EMPTY
2158: LIST
2159: LIST
2160: PUSH
2161: LD_INT 21
2163: PUSH
2164: LD_INT 2
2166: PUSH
2167: EMPTY
2168: LIST
2169: LIST
2170: PUSH
2171: LD_INT 58
2173: PUSH
2174: EMPTY
2175: LIST
2176: PUSH
2177: EMPTY
2178: LIST
2179: LIST
2180: LIST
2181: PPUSH
2182: CALL_OW 69
2186: ST_TO_ADDR
// if emptyVeh then
2187: LD_VAR 0 6
2191: IFFALSE 2213
// PlaceHumanInUnit ( un , emptyVeh [ 1 ] ) else
2193: LD_VAR 0 3
2197: PPUSH
2198: LD_VAR 0 6
2202: PUSH
2203: LD_INT 1
2205: ARRAY
2206: PPUSH
2207: CALL_OW 52
2211: GO 2228
// PlaceUnitArea ( un , RussianSpawnArea , false ) ;
2213: LD_VAR 0 3
2217: PPUSH
2218: LD_INT 2
2220: PPUSH
2221: LD_INT 0
2223: PPUSH
2224: CALL_OW 49
// end ;
2228: GO 2104
2230: POP
2231: POP
// yourUnits = FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_nation , nation_russian ] ] ) ;
2232: LD_ADDR_VAR 0 5
2236: PUSH
2237: LD_INT 22
2239: PUSH
2240: LD_INT 3
2242: PUSH
2243: EMPTY
2244: LIST
2245: LIST
2246: PUSH
2247: LD_INT 21
2249: PUSH
2250: LD_INT 1
2252: PUSH
2253: EMPTY
2254: LIST
2255: LIST
2256: PUSH
2257: LD_INT 23
2259: PUSH
2260: LD_INT 3
2262: PUSH
2263: EMPTY
2264: LIST
2265: LIST
2266: PUSH
2267: EMPTY
2268: LIST
2269: LIST
2270: LIST
2271: PPUSH
2272: CALL_OW 69
2276: ST_TO_ADDR
// if not UnitFilter ( yourUnits , [ f_class , class_engineer ] ) then
2277: LD_VAR 0 5
2281: PPUSH
2282: LD_INT 25
2284: PUSH
2285: LD_INT 2
2287: PUSH
2288: EMPTY
2289: LIST
2290: LIST
2291: PPUSH
2292: CALL_OW 72
2296: NOT
2297: IFFALSE 2315
// SetClass ( yourUnits [ 1 ] , 2 ) ;
2299: LD_VAR 0 5
2303: PUSH
2304: LD_INT 1
2306: ARRAY
2307: PPUSH
2308: LD_INT 2
2310: PPUSH
2311: CALL_OW 336
// end ;
2315: LD_VAR 0 1
2319: RET
// export function PrepareRussianEscort ; var i , unit ; begin
2320: LD_INT 0
2322: PPUSH
2323: PPUSH
2324: PPUSH
// uc_side = 6 ;
2325: LD_ADDR_OWVAR 20
2329: PUSH
2330: LD_INT 6
2332: ST_TO_ADDR
// uc_nation = 3 ;
2333: LD_ADDR_OWVAR 21
2337: PUSH
2338: LD_INT 3
2340: ST_TO_ADDR
// for i := 1 to 2 do
2341: LD_ADDR_VAR 0 2
2345: PUSH
2346: DOUBLE
2347: LD_INT 1
2349: DEC
2350: ST_TO_ADDR
2351: LD_INT 2
2353: PUSH
2354: FOR_TO
2355: IFFALSE 2410
// begin PrepareSoldier ( false , 4 ) ;
2357: LD_INT 0
2359: PPUSH
2360: LD_INT 4
2362: PPUSH
2363: CALL_OW 381
// unit = CreateHuman ;
2367: LD_ADDR_VAR 0 3
2371: PUSH
2372: CALL_OW 44
2376: ST_TO_ADDR
// russianEscort = russianEscort ^ unit ;
2377: LD_ADDR_EXP 77
2381: PUSH
2382: LD_EXP 77
2386: PUSH
2387: LD_VAR 0 3
2391: ADD
2392: ST_TO_ADDR
// PlaceUnitArea ( unit , RussianSpawn2Area , false ) ;
2393: LD_VAR 0 3
2397: PPUSH
2398: LD_INT 7
2400: PPUSH
2401: LD_INT 0
2403: PPUSH
2404: CALL_OW 49
// end ;
2408: GO 2354
2410: POP
2411: POP
// end ;
2412: LD_VAR 0 1
2416: RET
// function PrepareVehicles ; var i , veh ; begin
2417: LD_INT 0
2419: PPUSH
2420: PPUSH
2421: PPUSH
// uc_side = 3 ;
2422: LD_ADDR_OWVAR 20
2426: PUSH
2427: LD_INT 3
2429: ST_TO_ADDR
// uc_nation = 3 ;
2430: LD_ADDR_OWVAR 21
2434: PUSH
2435: LD_INT 3
2437: ST_TO_ADDR
// for i := 1 to 5 do
2438: LD_ADDR_VAR 0 2
2442: PUSH
2443: DOUBLE
2444: LD_INT 1
2446: DEC
2447: ST_TO_ADDR
2448: LD_INT 5
2450: PUSH
2451: FOR_TO
2452: IFFALSE 2562
// begin PrepareVehicle ( ru_medium_wheeled , engine_combustion , control_manual , ru_cargo_bay , rand ( 60 , 80 ) ) ;
2454: LD_INT 21
2456: PPUSH
2457: LD_INT 1
2459: PPUSH
2460: LD_INT 1
2462: PPUSH
2463: LD_INT 51
2465: PPUSH
2466: LD_INT 60
2468: PPUSH
2469: LD_INT 80
2471: PPUSH
2472: CALL_OW 12
2476: PPUSH
2477: CALL 24241 0 5
// veh = CreateVehicle ;
2481: LD_ADDR_VAR 0 3
2485: PUSH
2486: CALL_OW 45
2490: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
2491: LD_VAR 0 3
2495: PPUSH
2496: LD_INT 4
2498: PPUSH
2499: CALL_OW 233
// PlaceUnitArea ( veh , RussianSpawnArea , false ) ;
2503: LD_VAR 0 3
2507: PPUSH
2508: LD_INT 2
2510: PPUSH
2511: LD_INT 0
2513: PPUSH
2514: CALL_OW 49
// if ( i <> 5 ) then
2518: LD_VAR 0 2
2522: PUSH
2523: LD_INT 5
2525: NONEQUAL
2526: IFFALSE 2545
// AddCargo ( veh , mat_cans , 100 ) else
2528: LD_VAR 0 3
2532: PPUSH
2533: LD_INT 1
2535: PPUSH
2536: LD_INT 100
2538: PPUSH
2539: CALL_OW 291
2543: GO 2560
// AddCargo ( veh , mat_oil , 100 ) ;
2545: LD_VAR 0 3
2549: PPUSH
2550: LD_INT 2
2552: PPUSH
2553: LD_INT 100
2555: PPUSH
2556: CALL_OW 291
// end ;
2560: GO 2451
2562: POP
2563: POP
// PrepareVehicle ( ru_medium_wheeled , engine_combustion , control_manual , ru_crane , rand ( 60 , 80 ) ) ;
2564: LD_INT 21
2566: PPUSH
2567: LD_INT 1
2569: PPUSH
2570: LD_INT 1
2572: PPUSH
2573: LD_INT 52
2575: PPUSH
2576: LD_INT 60
2578: PPUSH
2579: LD_INT 80
2581: PPUSH
2582: CALL_OW 12
2586: PPUSH
2587: CALL 24241 0 5
// veh = CreateVehicle ;
2591: LD_ADDR_VAR 0 3
2595: PUSH
2596: CALL_OW 45
2600: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
2601: LD_VAR 0 3
2605: PPUSH
2606: LD_INT 4
2608: PPUSH
2609: CALL_OW 233
// PlaceUnitArea ( veh , RussianSpawnArea , false ) ;
2613: LD_VAR 0 3
2617: PPUSH
2618: LD_INT 2
2620: PPUSH
2621: LD_INT 0
2623: PPUSH
2624: CALL_OW 49
// for i := 1 to 3 do
2628: LD_ADDR_VAR 0 2
2632: PUSH
2633: DOUBLE
2634: LD_INT 1
2636: DEC
2637: ST_TO_ADDR
2638: LD_INT 3
2640: PUSH
2641: FOR_TO
2642: IFFALSE 2710
// begin PrepareVehicle ( ru_heavy_tracked , engine_combustion , control_manual , ru_bulldozer , rand ( 60 , 80 ) ) ;
2644: LD_INT 24
2646: PPUSH
2647: LD_INT 1
2649: PPUSH
2650: LD_INT 1
2652: PPUSH
2653: LD_INT 53
2655: PPUSH
2656: LD_INT 60
2658: PPUSH
2659: LD_INT 80
2661: PPUSH
2662: CALL_OW 12
2666: PPUSH
2667: CALL 24241 0 5
// veh = CreateVehicle ;
2671: LD_ADDR_VAR 0 3
2675: PUSH
2676: CALL_OW 45
2680: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
2681: LD_VAR 0 3
2685: PPUSH
2686: LD_INT 4
2688: PPUSH
2689: CALL_OW 233
// PlaceUnitArea ( veh , RussianSpawnArea , false ) ;
2693: LD_VAR 0 3
2697: PPUSH
2698: LD_INT 2
2700: PPUSH
2701: LD_INT 0
2703: PPUSH
2704: CALL_OW 49
// end ;
2708: GO 2641
2710: POP
2711: POP
// end ;
2712: LD_VAR 0 1
2716: RET
// function InitRussianRequiments ; var i ; begin
2717: LD_INT 0
2719: PPUSH
2720: PPUSH
// availableWeapons = [ ru_heavy_machine_gun , ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher ] ;
2721: LD_ADDR_EXP 11
2725: PUSH
2726: LD_INT 42
2728: PUSH
2729: LD_INT 43
2731: PUSH
2732: LD_INT 44
2734: PUSH
2735: LD_INT 46
2737: PUSH
2738: LD_INT 45
2740: PUSH
2741: EMPTY
2742: LIST
2743: LIST
2744: LIST
2745: LIST
2746: LIST
2747: ST_TO_ADDR
// for i := 1 to availableWeapons do
2748: LD_ADDR_VAR 0 2
2752: PUSH
2753: DOUBLE
2754: LD_INT 1
2756: DEC
2757: ST_TO_ADDR
2758: LD_EXP 11
2762: PUSH
2763: FOR_TO
2764: IFFALSE 2804
// weaponsData = weaponsData ^ [ [ availableWeapons [ i ] , false , false ] ] ;
2766: LD_ADDR_EXP 12
2770: PUSH
2771: LD_EXP 12
2775: PUSH
2776: LD_EXP 11
2780: PUSH
2781: LD_VAR 0 2
2785: ARRAY
2786: PUSH
2787: LD_INT 0
2789: PUSH
2790: LD_INT 0
2792: PUSH
2793: EMPTY
2794: LIST
2795: LIST
2796: LIST
2797: PUSH
2798: EMPTY
2799: LIST
2800: ADD
2801: ST_TO_ADDR
2802: GO 2763
2804: POP
2805: POP
// for i := 0 to 50 do
2806: LD_ADDR_VAR 0 2
2810: PUSH
2811: DOUBLE
2812: LD_INT 0
2814: DEC
2815: ST_TO_ADDR
2816: LD_INT 50
2818: PUSH
2819: FOR_TO
2820: IFFALSE 2858
// if GetRestrict ( i , 3 ) = state_enabled then
2822: LD_VAR 0 2
2826: PPUSH
2827: LD_INT 3
2829: PPUSH
2830: CALL_OW 323
2834: PUSH
2835: LD_INT 1
2837: EQUAL
2838: IFFALSE 2856
// buildingsToBuild = buildingsToBuild ^ i ;
2840: LD_ADDR_EXP 8
2844: PUSH
2845: LD_EXP 8
2849: PUSH
2850: LD_VAR 0 2
2854: ADD
2855: ST_TO_ADDR
2856: GO 2819
2858: POP
2859: POP
// buildingsToBuild = buildingsToBuild diff [ 0 , 2 , 4 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 14 , 22 , 31 , 32 , 33 , 39 , 40 ] ;
2860: LD_ADDR_EXP 8
2864: PUSH
2865: LD_EXP 8
2869: PUSH
2870: LD_INT 0
2872: PUSH
2873: LD_INT 2
2875: PUSH
2876: LD_INT 4
2878: PUSH
2879: LD_INT 6
2881: PUSH
2882: LD_INT 7
2884: PUSH
2885: LD_INT 8
2887: PUSH
2888: LD_INT 9
2890: PUSH
2891: LD_INT 10
2893: PUSH
2894: LD_INT 11
2896: PUSH
2897: LD_INT 12
2899: PUSH
2900: LD_INT 14
2902: PUSH
2903: LD_INT 22
2905: PUSH
2906: LD_INT 31
2908: PUSH
2909: LD_INT 32
2911: PUSH
2912: LD_INT 33
2914: PUSH
2915: LD_INT 39
2917: PUSH
2918: LD_INT 40
2920: PUSH
2921: EMPTY
2922: LIST
2923: LIST
2924: LIST
2925: LIST
2926: LIST
2927: LIST
2928: LIST
2929: LIST
2930: LIST
2931: LIST
2932: LIST
2933: LIST
2934: LIST
2935: LIST
2936: LIST
2937: LIST
2938: LIST
2939: DIFF
2940: ST_TO_ADDR
// allBuildings = buildingsToBuild ;
2941: LD_ADDR_EXP 13
2945: PUSH
2946: LD_EXP 8
2950: ST_TO_ADDR
// techsToResearch = GetTechNation ( 3 , nation_russian , state_enabled ) ;
2951: LD_ADDR_EXP 9
2955: PUSH
2956: LD_INT 3
2958: PPUSH
2959: LD_INT 3
2961: PPUSH
2962: LD_INT 1
2964: PPUSH
2965: CALL 19287 0 3
2969: ST_TO_ADDR
// end ; end_of_file
2970: LD_VAR 0 1
2974: RET
// export amAttackTeam ; export function PrepareAmericans ; begin
2975: LD_INT 0
2977: PPUSH
// amAttackTeam = [ ] ;
2978: LD_ADDR_EXP 78
2982: PUSH
2983: EMPTY
2984: ST_TO_ADDR
// SpawnAmericansSnipers ;
2985: CALL 3119 0 0
// case Difficulty of 2 :
2989: LD_OWVAR 67
2993: PUSH
2994: LD_INT 2
2996: DOUBLE
2997: EQUAL
2998: IFTRUE 3002
3000: GO 3031
3002: POP
// begin SetTech ( tech_comp1 , 1 , state_researched ) ;
3003: LD_INT 57
3005: PPUSH
3006: LD_INT 1
3008: PPUSH
3009: LD_INT 2
3011: PPUSH
3012: CALL_OW 322
// SetTech ( tech_opto1 , 1 , state_researched ) ;
3016: LD_INT 60
3018: PPUSH
3019: LD_INT 1
3021: PPUSH
3022: LD_INT 2
3024: PPUSH
3025: CALL_OW 322
// end ; 3 .. 4 :
3029: GO 3114
3031: LD_INT 3
3033: DOUBLE
3034: GREATEREQUAL
3035: IFFALSE 3043
3037: LD_INT 4
3039: DOUBLE
3040: LESSEQUAL
3041: IFTRUE 3045
3043: GO 3113
3045: POP
// begin SetTech ( tech_comp1 , 1 , state_researched ) ;
3046: LD_INT 57
3048: PPUSH
3049: LD_INT 1
3051: PPUSH
3052: LD_INT 2
3054: PPUSH
3055: CALL_OW 322
// SetTech ( tech_comp2 , 1 , state_researched ) ;
3059: LD_INT 58
3061: PPUSH
3062: LD_INT 1
3064: PPUSH
3065: LD_INT 2
3067: PPUSH
3068: CALL_OW 322
// SetTech ( tech_weap3 , 1 , state_researched ) ;
3072: LD_INT 53
3074: PPUSH
3075: LD_INT 1
3077: PPUSH
3078: LD_INT 2
3080: PPUSH
3081: CALL_OW 322
// SetTech ( tech_opto1 , 1 , state_researched ) ;
3085: LD_INT 60
3087: PPUSH
3088: LD_INT 1
3090: PPUSH
3091: LD_INT 2
3093: PPUSH
3094: CALL_OW 322
// SetTech ( tech_opto2 , 1 , state_researched ) ;
3098: LD_INT 61
3100: PPUSH
3101: LD_INT 1
3103: PPUSH
3104: LD_INT 2
3106: PPUSH
3107: CALL_OW 322
// end ; end ;
3111: GO 3114
3113: POP
// end ;
3114: LD_VAR 0 1
3118: RET
// export function SpawnAmericansSnipers ; var i , un ; begin
3119: LD_INT 0
3121: PPUSH
3122: PPUSH
3123: PPUSH
// uc_side = 1 ;
3124: LD_ADDR_OWVAR 20
3128: PUSH
3129: LD_INT 1
3131: ST_TO_ADDR
// uc_nation = 1 ;
3132: LD_ADDR_OWVAR 21
3136: PUSH
3137: LD_INT 1
3139: ST_TO_ADDR
// for i := 1 to 8 do
3140: LD_ADDR_VAR 0 2
3144: PUSH
3145: DOUBLE
3146: LD_INT 1
3148: DEC
3149: ST_TO_ADDR
3150: LD_INT 8
3152: PUSH
3153: FOR_TO
3154: IFFALSE 3207
// begin PrepareHuman ( false , class_sniper , enemySkillLevel ) ;
3156: LD_INT 0
3158: PPUSH
3159: LD_INT 5
3161: PPUSH
3162: LD_EXP 56
3166: PPUSH
3167: CALL_OW 380
// un = CreateHuman ;
3171: LD_ADDR_VAR 0 3
3175: PUSH
3176: CALL_OW 44
3180: ST_TO_ADDR
// PlaceUnitArea ( un , AmericansSnipersSpawnArea , false ) ;
3181: LD_VAR 0 3
3185: PPUSH
3186: LD_INT 14
3188: PPUSH
3189: LD_INT 0
3191: PPUSH
3192: CALL_OW 49
// ComHold ( un ) ;
3196: LD_VAR 0 3
3200: PPUSH
3201: CALL_OW 140
// end ;
3205: GO 3153
3207: POP
3208: POP
// end ;
3209: LD_VAR 0 1
3213: RET
// export function SpawnAmAttackTeam ; var i , unit , veh , randVehType , weapon , chassis , amSolds , amSnipers , amVehs ; begin
3214: LD_INT 0
3216: PPUSH
3217: PPUSH
3218: PPUSH
3219: PPUSH
3220: PPUSH
3221: PPUSH
3222: PPUSH
3223: PPUSH
3224: PPUSH
3225: PPUSH
// uc_side = 1 ;
3226: LD_ADDR_OWVAR 20
3230: PUSH
3231: LD_INT 1
3233: ST_TO_ADDR
// uc_nation = 1 ;
3234: LD_ADDR_OWVAR 21
3238: PUSH
3239: LD_INT 1
3241: ST_TO_ADDR
// amSolds = Rand ( enemyAttackUnitsData [ 1 ] [ 2 ] , enemyAttackUnitsData [ 1 ] [ 3 ] ) ;
3242: LD_ADDR_VAR 0 8
3246: PUSH
3247: LD_EXP 53
3251: PUSH
3252: LD_INT 1
3254: ARRAY
3255: PUSH
3256: LD_INT 2
3258: ARRAY
3259: PPUSH
3260: LD_EXP 53
3264: PUSH
3265: LD_INT 1
3267: ARRAY
3268: PUSH
3269: LD_INT 3
3271: ARRAY
3272: PPUSH
3273: CALL_OW 12
3277: ST_TO_ADDR
// amSnipers = Rand ( enemyAttackUnitsData [ 1 ] [ 4 ] , enemyAttackUnitsData [ 1 ] [ 5 ] ) ;
3278: LD_ADDR_VAR 0 9
3282: PUSH
3283: LD_EXP 53
3287: PUSH
3288: LD_INT 1
3290: ARRAY
3291: PUSH
3292: LD_INT 4
3294: ARRAY
3295: PPUSH
3296: LD_EXP 53
3300: PUSH
3301: LD_INT 1
3303: ARRAY
3304: PUSH
3305: LD_INT 5
3307: ARRAY
3308: PPUSH
3309: CALL_OW 12
3313: ST_TO_ADDR
// amVehs = Rand ( enemyAttackUnitsData [ 1 ] [ 6 ] , enemyAttackUnitsData [ 1 ] [ 7 ] ) ;
3314: LD_ADDR_VAR 0 10
3318: PUSH
3319: LD_EXP 53
3323: PUSH
3324: LD_INT 1
3326: ARRAY
3327: PUSH
3328: LD_INT 6
3330: ARRAY
3331: PPUSH
3332: LD_EXP 53
3336: PUSH
3337: LD_INT 1
3339: ARRAY
3340: PUSH
3341: LD_INT 7
3343: ARRAY
3344: PPUSH
3345: CALL_OW 12
3349: ST_TO_ADDR
// if paidLegionOffert then
3350: LD_EXP 32
3354: IFFALSE 3388
// begin amSolds = amSolds - legionReduceAmericansUnits ;
3356: LD_ADDR_VAR 0 8
3360: PUSH
3361: LD_VAR 0 8
3365: PUSH
3366: LD_EXP 51
3370: MINUS
3371: ST_TO_ADDR
// amVehs = amVehs - legionReduceAmericansUnits ;
3372: LD_ADDR_VAR 0 10
3376: PUSH
3377: LD_VAR 0 10
3381: PUSH
3382: LD_EXP 51
3386: MINUS
3387: ST_TO_ADDR
// end ; for i := 1 to amSolds do
3388: LD_ADDR_VAR 0 2
3392: PUSH
3393: DOUBLE
3394: LD_INT 1
3396: DEC
3397: ST_TO_ADDR
3398: LD_VAR 0 8
3402: PUSH
3403: FOR_TO
3404: IFFALSE 3461
// begin PrepareSoldier ( false , enemySkillLevel ) ;
3406: LD_INT 0
3408: PPUSH
3409: LD_EXP 56
3413: PPUSH
3414: CALL_OW 381
// unit = CreateHuman ;
3418: LD_ADDR_VAR 0 3
3422: PUSH
3423: CALL_OW 44
3427: ST_TO_ADDR
// PlaceUnitArea ( unit , AmericanSpawnArea , false ) ;
3428: LD_VAR 0 3
3432: PPUSH
3433: LD_INT 3
3435: PPUSH
3436: LD_INT 0
3438: PPUSH
3439: CALL_OW 49
// amAttackTeam = amAttackTeam ^ unit ;
3443: LD_ADDR_EXP 78
3447: PUSH
3448: LD_EXP 78
3452: PUSH
3453: LD_VAR 0 3
3457: ADD
3458: ST_TO_ADDR
// end ;
3459: GO 3403
3461: POP
3462: POP
// for i := 1 to amSnipers do
3463: LD_ADDR_VAR 0 2
3467: PUSH
3468: DOUBLE
3469: LD_INT 1
3471: DEC
3472: ST_TO_ADDR
3473: LD_VAR 0 9
3477: PUSH
3478: FOR_TO
3479: IFFALSE 3539
// begin PrepareHuman ( false , class_sniper , enemySkillLevel ) ;
3481: LD_INT 0
3483: PPUSH
3484: LD_INT 5
3486: PPUSH
3487: LD_EXP 56
3491: PPUSH
3492: CALL_OW 380
// unit = CreateHuman ;
3496: LD_ADDR_VAR 0 3
3500: PUSH
3501: CALL_OW 44
3505: ST_TO_ADDR
// PlaceUnitArea ( unit , AmericanSpawnArea , false ) ;
3506: LD_VAR 0 3
3510: PPUSH
3511: LD_INT 3
3513: PPUSH
3514: LD_INT 0
3516: PPUSH
3517: CALL_OW 49
// amAttackTeam = amAttackTeam ^ unit ;
3521: LD_ADDR_EXP 78
3525: PUSH
3526: LD_EXP 78
3530: PUSH
3531: LD_VAR 0 3
3535: ADD
3536: ST_TO_ADDR
// end ;
3537: GO 3478
3539: POP
3540: POP
// for i := 1 to amVehs do
3541: LD_ADDR_VAR 0 2
3545: PUSH
3546: DOUBLE
3547: LD_INT 1
3549: DEC
3550: ST_TO_ADDR
3551: LD_VAR 0 10
3555: PUSH
3556: FOR_TO
3557: IFFALSE 3840
// begin randVehType = Rand ( 1 , 4 ) ;
3559: LD_ADDR_VAR 0 5
3563: PUSH
3564: LD_INT 1
3566: PPUSH
3567: LD_INT 4
3569: PPUSH
3570: CALL_OW 12
3574: ST_TO_ADDR
// weapon = [ us_gatling_gun , us_double_gun , us_light_gun , us_rocket_launcher , us_heavy_gun ] [ Rand ( 1 , 5 ) ] ;
3575: LD_ADDR_VAR 0 6
3579: PUSH
3580: LD_INT 4
3582: PUSH
3583: LD_INT 5
3585: PUSH
3586: LD_INT 3
3588: PUSH
3589: LD_INT 7
3591: PUSH
3592: LD_INT 6
3594: PUSH
3595: EMPTY
3596: LIST
3597: LIST
3598: LIST
3599: LIST
3600: LIST
3601: PUSH
3602: LD_INT 1
3604: PPUSH
3605: LD_INT 5
3607: PPUSH
3608: CALL_OW 12
3612: ARRAY
3613: ST_TO_ADDR
// if weapon = us_heavy_gun then
3614: LD_VAR 0 6
3618: PUSH
3619: LD_INT 6
3621: EQUAL
3622: IFFALSE 3634
// chassis = us_heavy_tracked else
3624: LD_ADDR_VAR 0 7
3628: PUSH
3629: LD_INT 4
3631: ST_TO_ADDR
3632: GO 3661
// chassis = [ us_medium_tracked , us_heavy_tracked ] [ Rand ( 1 , 2 ) ] ;
3634: LD_ADDR_VAR 0 7
3638: PUSH
3639: LD_INT 3
3641: PUSH
3642: LD_INT 4
3644: PUSH
3645: EMPTY
3646: LIST
3647: LIST
3648: PUSH
3649: LD_INT 1
3651: PPUSH
3652: LD_INT 2
3654: PPUSH
3655: CALL_OW 12
3659: ARRAY
3660: ST_TO_ADDR
// if randVehType = 1 then
3661: LD_VAR 0 5
3665: PUSH
3666: LD_INT 1
3668: EQUAL
3669: IFFALSE 3704
// PrepareVehicle ( chassis , engine_combustion , control_manual , weapon , Rand ( 70 , 90 ) ) else
3671: LD_VAR 0 7
3675: PPUSH
3676: LD_INT 1
3678: PPUSH
3679: LD_INT 1
3681: PPUSH
3682: LD_VAR 0 6
3686: PPUSH
3687: LD_INT 70
3689: PPUSH
3690: LD_INT 90
3692: PPUSH
3693: CALL_OW 12
3697: PPUSH
3698: CALL 24241 0 5
3702: GO 3735
// PrepareVehicle ( chassis , engine_combustion , control_computer , weapon , Rand ( 70 , 90 ) ) ;
3704: LD_VAR 0 7
3708: PPUSH
3709: LD_INT 1
3711: PPUSH
3712: LD_INT 3
3714: PPUSH
3715: LD_VAR 0 6
3719: PPUSH
3720: LD_INT 70
3722: PPUSH
3723: LD_INT 90
3725: PPUSH
3726: CALL_OW 12
3730: PPUSH
3731: CALL 24241 0 5
// veh = CreateVehicle ;
3735: LD_ADDR_VAR 0 4
3739: PUSH
3740: CALL_OW 45
3744: ST_TO_ADDR
// PlaceUnitArea ( veh , AmericanSpawnArea , false ) ;
3745: LD_VAR 0 4
3749: PPUSH
3750: LD_INT 3
3752: PPUSH
3753: LD_INT 0
3755: PPUSH
3756: CALL_OW 49
// amAttackTeam = amAttackTeam ^ veh ;
3760: LD_ADDR_EXP 78
3764: PUSH
3765: LD_EXP 78
3769: PUSH
3770: LD_VAR 0 4
3774: ADD
3775: ST_TO_ADDR
// if randVehType = 1 then
3776: LD_VAR 0 5
3780: PUSH
3781: LD_INT 1
3783: EQUAL
3784: IFFALSE 3838
// begin PrepareMechanic ( false , enemySkillLevel ) ;
3786: LD_INT 0
3788: PPUSH
3789: LD_EXP 56
3793: PPUSH
3794: CALL_OW 383
// unit = CreateHuman ;
3798: LD_ADDR_VAR 0 3
3802: PUSH
3803: CALL_OW 44
3807: ST_TO_ADDR
// PlaceHumanInUnit ( unit , veh ) ;
3808: LD_VAR 0 3
3812: PPUSH
3813: LD_VAR 0 4
3817: PPUSH
3818: CALL_OW 52
// amAttackTeam = amAttackTeam ^ unit ;
3822: LD_ADDR_EXP 78
3826: PUSH
3827: LD_EXP 78
3831: PUSH
3832: LD_VAR 0 3
3836: ADD
3837: ST_TO_ADDR
// end ; end ;
3838: GO 3556
3840: POP
3841: POP
// end ; end_of_file
3842: LD_VAR 0 1
3846: RET
// export Heike , Kurt , Dietrich ; export KurtEng ; export GensherTeam ; export arAttackTeam ; export function PrepareArabians ; begin
3847: LD_INT 0
3849: PPUSH
// arAttackTeam = [ ] ;
3850: LD_ADDR_EXP 84
3854: PUSH
3855: EMPTY
3856: ST_TO_ADDR
// PrepareHeroes ;
3857: CALL 4262 0 0
// case Difficulty of 2 :
3861: LD_OWVAR 67
3865: PUSH
3866: LD_INT 2
3868: DOUBLE
3869: EQUAL
3870: IFTRUE 3874
3872: GO 3890
3874: POP
// begin SetTech ( tech_stimDrugs , 8 , state_researched ) ;
3875: LD_INT 5
3877: PPUSH
3878: LD_INT 8
3880: PPUSH
3881: LD_INT 2
3883: PPUSH
3884: CALL_OW 322
// end ; 3 :
3888: GO 3941
3890: LD_INT 3
3892: DOUBLE
3893: EQUAL
3894: IFTRUE 3898
3896: GO 3940
3898: POP
// begin SetTech ( tech_stimDrugs , 8 , state_researched ) ;
3899: LD_INT 5
3901: PPUSH
3902: LD_INT 8
3904: PPUSH
3905: LD_INT 2
3907: PPUSH
3908: CALL_OW 322
// SetTech ( tech_bio1 , 8 , state_researched ) ;
3912: LD_INT 66
3914: PPUSH
3915: LD_INT 8
3917: PPUSH
3918: LD_INT 2
3920: PPUSH
3921: CALL_OW 322
// SetTech ( tech_weap3 , 8 , state_researched ) ;
3925: LD_INT 53
3927: PPUSH
3928: LD_INT 8
3930: PPUSH
3931: LD_INT 2
3933: PPUSH
3934: CALL_OW 322
// end ; end ;
3938: GO 3941
3940: POP
// end ;
3941: LD_VAR 0 1
3945: RET
// export function SpawnGensherTeam ; var i , driver , veh ; begin
3946: LD_INT 0
3948: PPUSH
3949: PPUSH
3950: PPUSH
3951: PPUSH
// GensherTeam = [ ] ;
3952: LD_ADDR_EXP 83
3956: PUSH
3957: EMPTY
3958: ST_TO_ADDR
// uc_side = 2 ;
3959: LD_ADDR_OWVAR 20
3963: PUSH
3964: LD_INT 2
3966: ST_TO_ADDR
// uc_nation = 2 ;
3967: LD_ADDR_OWVAR 21
3971: PUSH
3972: LD_INT 2
3974: ST_TO_ADDR
// for i := 1 to 3 do
3975: LD_ADDR_VAR 0 2
3979: PUSH
3980: DOUBLE
3981: LD_INT 1
3983: DEC
3984: ST_TO_ADDR
3985: LD_INT 3
3987: PUSH
3988: FOR_TO
3989: IFFALSE 4148
// begin PrepareSoldier ( sex_male , rand ( 3 , 5 ) ) ;
3991: LD_INT 1
3993: PPUSH
3994: LD_INT 3
3996: PPUSH
3997: LD_INT 5
3999: PPUSH
4000: CALL_OW 12
4004: PPUSH
4005: CALL_OW 381
// driver = CreateHuman ;
4009: LD_ADDR_VAR 0 3
4013: PUSH
4014: CALL_OW 44
4018: ST_TO_ADDR
// PrepareVehicle ( ar_medium_trike , engine_combustion , control_manual , ar_cargo_bay , rand ( 50 , 70 ) ) ;
4019: LD_INT 13
4021: PPUSH
4022: LD_INT 1
4024: PPUSH
4025: LD_INT 1
4027: PPUSH
4028: LD_INT 32
4030: PPUSH
4031: LD_INT 50
4033: PPUSH
4034: LD_INT 70
4036: PPUSH
4037: CALL_OW 12
4041: PPUSH
4042: CALL 24241 0 5
// veh = CreateVehicle ;
4046: LD_ADDR_VAR 0 4
4050: PUSH
4051: CALL_OW 45
4055: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
4056: LD_VAR 0 4
4060: PPUSH
4061: LD_INT 4
4063: PPUSH
4064: CALL_OW 233
// PlaceUnitArea ( veh , GensherSpawnArea , false ) ;
4068: LD_VAR 0 4
4072: PPUSH
4073: LD_INT 4
4075: PPUSH
4076: LD_INT 0
4078: PPUSH
4079: CALL_OW 49
// PlaceHumanInUnit ( driver , veh ) ;
4083: LD_VAR 0 3
4087: PPUSH
4088: LD_VAR 0 4
4092: PPUSH
4093: CALL_OW 52
// AddCargo ( veh , i , 100 ) ;
4097: LD_VAR 0 4
4101: PPUSH
4102: LD_VAR 0 2
4106: PPUSH
4107: LD_INT 100
4109: PPUSH
4110: CALL_OW 291
// GensherTeam = GensherTeam ^ driver ;
4114: LD_ADDR_EXP 83
4118: PUSH
4119: LD_EXP 83
4123: PUSH
4124: LD_VAR 0 3
4128: ADD
4129: ST_TO_ADDR
// GensherTeam = GensherTeam ^ veh ;
4130: LD_ADDR_EXP 83
4134: PUSH
4135: LD_EXP 83
4139: PUSH
4140: LD_VAR 0 4
4144: ADD
4145: ST_TO_ADDR
// end ;
4146: GO 3988
4148: POP
4149: POP
// if IsOK ( KurtEng ) and GetSide ( KurtEng ) = 3 then
4150: LD_EXP 82
4154: PPUSH
4155: CALL_OW 302
4159: PUSH
4160: LD_EXP 82
4164: PPUSH
4165: CALL_OW 255
4169: PUSH
4170: LD_INT 3
4172: EQUAL
4173: AND
4174: IFFALSE 4208
// begin GensherTargetX = GetX ( Kurt ) ;
4176: LD_ADDR_EXP 16
4180: PUSH
4181: LD_EXP 80
4185: PPUSH
4186: CALL_OW 250
4190: ST_TO_ADDR
// GensherTargetY = GetY ( Kurt ) ;
4191: LD_ADDR_EXP 17
4195: PUSH
4196: LD_EXP 80
4200: PPUSH
4201: CALL_OW 251
4205: ST_TO_ADDR
// end else
4206: GO 4238
// begin GensherTargetX = GetX ( Burlak ) ;
4208: LD_ADDR_EXP 16
4212: PUSH
4213: LD_EXP 57
4217: PPUSH
4218: CALL_OW 250
4222: ST_TO_ADDR
// GensherTargetY = GetY ( Burlak ) ;
4223: LD_ADDR_EXP 17
4227: PUSH
4228: LD_EXP 57
4232: PPUSH
4233: CALL_OW 251
4237: ST_TO_ADDR
// end ; ComMoveXY ( GensherTeam , GensherTargetX , GensherTargetY ) ;
4238: LD_EXP 83
4242: PPUSH
4243: LD_EXP 16
4247: PPUSH
4248: LD_EXP 17
4252: PPUSH
4253: CALL_OW 111
// end ;
4257: LD_VAR 0 1
4261: RET
// function PrepareHeroes ; begin
4262: LD_INT 0
4264: PPUSH
// uc_side = 5 ;
4265: LD_ADDR_OWVAR 20
4269: PUSH
4270: LD_INT 5
4272: ST_TO_ADDR
// uc_nation = 2 ;
4273: LD_ADDR_OWVAR 21
4277: PUSH
4278: LD_INT 2
4280: ST_TO_ADDR
// Heike = PrepareUnitExt ( Heike , true , class_engineer ) ;
4281: LD_ADDR_EXP 79
4285: PUSH
4286: LD_STRING Heike
4288: PPUSH
4289: LD_INT 1
4291: PPUSH
4292: LD_INT 2
4294: PPUSH
4295: CALL 5930 0 3
4299: ST_TO_ADDR
// uc_side = 8 ;
4300: LD_ADDR_OWVAR 20
4304: PUSH
4305: LD_INT 8
4307: ST_TO_ADDR
// Kurt = PrepareUnitExt ( Kurt , false , 0 ) ;
4308: LD_ADDR_EXP 80
4312: PUSH
4313: LD_STRING Kurt
4315: PPUSH
4316: LD_INT 0
4318: PPUSH
4319: LD_INT 0
4321: PPUSH
4322: CALL 5930 0 3
4326: ST_TO_ADDR
// uc_side = 2 ;
4327: LD_ADDR_OWVAR 20
4331: PUSH
4332: LD_INT 2
4334: ST_TO_ADDR
// Dietrich = PrepareUnitExt ( Dietrich , false , 0 ) ;
4335: LD_ADDR_EXP 81
4339: PUSH
4340: LD_STRING Dietrich
4342: PPUSH
4343: LD_INT 0
4345: PPUSH
4346: LD_INT 0
4348: PPUSH
4349: CALL 5930 0 3
4353: ST_TO_ADDR
// end ;
4354: LD_VAR 0 1
4358: RET
// export function SpawnArAttackTeam ; var i , unit , veh , weapon , chassis ; begin
4359: LD_INT 0
4361: PPUSH
4362: PPUSH
4363: PPUSH
4364: PPUSH
4365: PPUSH
4366: PPUSH
// uc_side = 8 ;
4367: LD_ADDR_OWVAR 20
4371: PUSH
4372: LD_INT 8
4374: ST_TO_ADDR
// uc_nation = 2 ;
4375: LD_ADDR_OWVAR 21
4379: PUSH
4380: LD_INT 2
4382: ST_TO_ADDR
// for i := 1 to Rand ( enemyAttackUnitsData [ 1 ] [ 2 ] , enemyAttackUnitsData [ 1 ] [ 3 ] ) do
4383: LD_ADDR_VAR 0 2
4387: PUSH
4388: DOUBLE
4389: LD_INT 1
4391: DEC
4392: ST_TO_ADDR
4393: LD_EXP 53
4397: PUSH
4398: LD_INT 1
4400: ARRAY
4401: PUSH
4402: LD_INT 2
4404: ARRAY
4405: PPUSH
4406: LD_EXP 53
4410: PUSH
4411: LD_INT 1
4413: ARRAY
4414: PUSH
4415: LD_INT 3
4417: ARRAY
4418: PPUSH
4419: CALL_OW 12
4423: PUSH
4424: FOR_TO
4425: IFFALSE 4482
// begin PrepareSoldier ( false , enemySkillLevel ) ;
4427: LD_INT 0
4429: PPUSH
4430: LD_EXP 56
4434: PPUSH
4435: CALL_OW 381
// unit = CreateHuman ;
4439: LD_ADDR_VAR 0 3
4443: PUSH
4444: CALL_OW 44
4448: ST_TO_ADDR
// PlaceUnitArea ( unit , KurtUnitsSpawnArea , false ) ;
4449: LD_VAR 0 3
4453: PPUSH
4454: LD_INT 10
4456: PPUSH
4457: LD_INT 0
4459: PPUSH
4460: CALL_OW 49
// arAttackTeam = arAttackTeam ^ unit ;
4464: LD_ADDR_EXP 84
4468: PUSH
4469: LD_EXP 84
4473: PUSH
4474: LD_VAR 0 3
4478: ADD
4479: ST_TO_ADDR
// end ;
4480: GO 4424
4482: POP
4483: POP
// for i := 1 to Rand ( enemyAttackUnitsData [ 1 ] [ 4 ] , enemyAttackUnitsData [ 1 ] [ 5 ] ) do
4484: LD_ADDR_VAR 0 2
4488: PUSH
4489: DOUBLE
4490: LD_INT 1
4492: DEC
4493: ST_TO_ADDR
4494: LD_EXP 53
4498: PUSH
4499: LD_INT 1
4501: ARRAY
4502: PUSH
4503: LD_INT 4
4505: ARRAY
4506: PPUSH
4507: LD_EXP 53
4511: PUSH
4512: LD_INT 1
4514: ARRAY
4515: PUSH
4516: LD_INT 5
4518: ARRAY
4519: PPUSH
4520: CALL_OW 12
4524: PUSH
4525: FOR_TO
4526: IFFALSE 4586
// begin PrepareHuman ( false , class_mortar , enemySkillLevel ) ;
4528: LD_INT 0
4530: PPUSH
4531: LD_INT 8
4533: PPUSH
4534: LD_EXP 56
4538: PPUSH
4539: CALL_OW 380
// unit = CreateHuman ;
4543: LD_ADDR_VAR 0 3
4547: PUSH
4548: CALL_OW 44
4552: ST_TO_ADDR
// PlaceUnitArea ( unit , KurtUnitsSpawnArea , false ) ;
4553: LD_VAR 0 3
4557: PPUSH
4558: LD_INT 10
4560: PPUSH
4561: LD_INT 0
4563: PPUSH
4564: CALL_OW 49
// arAttackTeam = arAttackTeam ^ unit ;
4568: LD_ADDR_EXP 84
4572: PUSH
4573: LD_EXP 84
4577: PUSH
4578: LD_VAR 0 3
4582: ADD
4583: ST_TO_ADDR
// end ;
4584: GO 4525
4586: POP
4587: POP
// for i := 1 to Rand ( enemyAttackUnitsData [ 1 ] [ 6 ] , enemyAttackUnitsData [ 1 ] [ 7 ] ) do
4588: LD_ADDR_VAR 0 2
4592: PUSH
4593: DOUBLE
4594: LD_INT 1
4596: DEC
4597: ST_TO_ADDR
4598: LD_EXP 53
4602: PUSH
4603: LD_INT 1
4605: ARRAY
4606: PUSH
4607: LD_INT 6
4609: ARRAY
4610: PPUSH
4611: LD_EXP 53
4615: PUSH
4616: LD_INT 1
4618: ARRAY
4619: PUSH
4620: LD_INT 7
4622: ARRAY
4623: PPUSH
4624: CALL_OW 12
4628: PUSH
4629: FOR_TO
4630: IFFALSE 4824
// begin weapon = [ ar_gun , ar_flame_thrower , ar_rocket_launcher , ar_light_gun , ar_gatling_gun ] [ Rand ( 1 , 5 ) ] ;
4632: LD_ADDR_VAR 0 5
4636: PUSH
4637: LD_INT 27
4639: PUSH
4640: LD_INT 26
4642: PUSH
4643: LD_INT 28
4645: PUSH
4646: LD_INT 23
4648: PUSH
4649: LD_INT 25
4651: PUSH
4652: EMPTY
4653: LIST
4654: LIST
4655: LIST
4656: LIST
4657: LIST
4658: PUSH
4659: LD_INT 1
4661: PPUSH
4662: LD_INT 5
4664: PPUSH
4665: CALL_OW 12
4669: ARRAY
4670: ST_TO_ADDR
// chassis = [ ar_medium_trike , ar_half_tracked ] [ Rand ( 1 , 2 ) ] ;
4671: LD_ADDR_VAR 0 6
4675: PUSH
4676: LD_INT 13
4678: PUSH
4679: LD_INT 14
4681: PUSH
4682: EMPTY
4683: LIST
4684: LIST
4685: PUSH
4686: LD_INT 1
4688: PPUSH
4689: LD_INT 2
4691: PPUSH
4692: CALL_OW 12
4696: ARRAY
4697: ST_TO_ADDR
// PrepareVehicle ( chassis , engine_combustion , control_manual , weapon , Rand ( 70 , 90 ) ) ;
4698: LD_VAR 0 6
4702: PPUSH
4703: LD_INT 1
4705: PPUSH
4706: LD_INT 1
4708: PPUSH
4709: LD_VAR 0 5
4713: PPUSH
4714: LD_INT 70
4716: PPUSH
4717: LD_INT 90
4719: PPUSH
4720: CALL_OW 12
4724: PPUSH
4725: CALL 24241 0 5
// veh = CreateVehicle ;
4729: LD_ADDR_VAR 0 4
4733: PUSH
4734: CALL_OW 45
4738: ST_TO_ADDR
// PlaceUnitArea ( veh , KurtUnitsSpawnArea , false ) ;
4739: LD_VAR 0 4
4743: PPUSH
4744: LD_INT 10
4746: PPUSH
4747: LD_INT 0
4749: PPUSH
4750: CALL_OW 49
// arAttackTeam = arAttackTeam ^ veh ;
4754: LD_ADDR_EXP 84
4758: PUSH
4759: LD_EXP 84
4763: PUSH
4764: LD_VAR 0 4
4768: ADD
4769: ST_TO_ADDR
// PrepareMechanic ( false , enemySkillLevel ) ;
4770: LD_INT 0
4772: PPUSH
4773: LD_EXP 56
4777: PPUSH
4778: CALL_OW 383
// unit = CreateHuman ;
4782: LD_ADDR_VAR 0 3
4786: PUSH
4787: CALL_OW 44
4791: ST_TO_ADDR
// PlaceHumanInUnit ( unit , veh ) ;
4792: LD_VAR 0 3
4796: PPUSH
4797: LD_VAR 0 4
4801: PPUSH
4802: CALL_OW 52
// arAttackTeam = arAttackTeam ^ unit ;
4806: LD_ADDR_EXP 84
4810: PUSH
4811: LD_EXP 84
4815: PUSH
4816: LD_VAR 0 3
4820: ADD
4821: ST_TO_ADDR
// end ;
4822: GO 4629
4824: POP
4825: POP
// end ; end_of_file
4826: LD_VAR 0 1
4830: RET
// export function Nef_PrepareNature ; var i , un ; begin
4831: LD_INT 0
4833: PPUSH
4834: PPUSH
4835: PPUSH
// for i := 1 to animalsAmount [ 1 ] do
4836: LD_ADDR_VAR 0 2
4840: PUSH
4841: DOUBLE
4842: LD_INT 1
4844: DEC
4845: ST_TO_ADDR
4846: LD_EXP 41
4850: PUSH
4851: LD_INT 1
4853: ARRAY
4854: PUSH
4855: FOR_TO
4856: IFFALSE 4966
// begin uc_side = 0 ;
4858: LD_ADDR_OWVAR 20
4862: PUSH
4863: LD_INT 0
4865: ST_TO_ADDR
// uc_nation = nation_nature ;
4866: LD_ADDR_OWVAR 21
4870: PUSH
4871: LD_INT 0
4873: ST_TO_ADDR
// hc_class = class_apeman ;
4874: LD_ADDR_OWVAR 28
4878: PUSH
4879: LD_INT 12
4881: ST_TO_ADDR
// hc_skills = [ animalsStats [ 1 ] , animalsStats [ 2 ] , animalsStats [ 3 ] , animalsStats [ 4 ] ] ;
4882: LD_ADDR_OWVAR 31
4886: PUSH
4887: LD_EXP 42
4891: PUSH
4892: LD_INT 1
4894: ARRAY
4895: PUSH
4896: LD_EXP 42
4900: PUSH
4901: LD_INT 2
4903: ARRAY
4904: PUSH
4905: LD_EXP 42
4909: PUSH
4910: LD_INT 3
4912: ARRAY
4913: PUSH
4914: LD_EXP 42
4918: PUSH
4919: LD_INT 4
4921: ARRAY
4922: PUSH
4923: EMPTY
4924: LIST
4925: LIST
4926: LIST
4927: LIST
4928: ST_TO_ADDR
// hc_agressivity = animalsAgression ;
4929: LD_ADDR_OWVAR 35
4933: PUSH
4934: LD_EXP 43
4938: ST_TO_ADDR
// un = CreateHuman ;
4939: LD_ADDR_VAR 0 3
4943: PUSH
4944: CALL_OW 44
4948: ST_TO_ADDR
// PlaceUnitArea ( un , NatureArea , false ) ;
4949: LD_VAR 0 3
4953: PPUSH
4954: LD_INT 5
4956: PPUSH
4957: LD_INT 0
4959: PPUSH
4960: CALL_OW 49
// end ;
4964: GO 4855
4966: POP
4967: POP
// for i := 1 to animalsAmount [ 2 ] do
4968: LD_ADDR_VAR 0 2
4972: PUSH
4973: DOUBLE
4974: LD_INT 1
4976: DEC
4977: ST_TO_ADDR
4978: LD_EXP 41
4982: PUSH
4983: LD_INT 2
4985: ARRAY
4986: PUSH
4987: FOR_TO
4988: IFFALSE 5098
// begin uc_side = 0 ;
4990: LD_ADDR_OWVAR 20
4994: PUSH
4995: LD_INT 0
4997: ST_TO_ADDR
// uc_nation = nation_nature ;
4998: LD_ADDR_OWVAR 21
5002: PUSH
5003: LD_INT 0
5005: ST_TO_ADDR
// hc_class = class_phororhacos ;
5006: LD_ADDR_OWVAR 28
5010: PUSH
5011: LD_INT 18
5013: ST_TO_ADDR
// hc_skills = [ animalsStats [ 1 ] , animalsStats [ 2 ] , animalsStats [ 3 ] , animalsStats [ 4 ] ] ;
5014: LD_ADDR_OWVAR 31
5018: PUSH
5019: LD_EXP 42
5023: PUSH
5024: LD_INT 1
5026: ARRAY
5027: PUSH
5028: LD_EXP 42
5032: PUSH
5033: LD_INT 2
5035: ARRAY
5036: PUSH
5037: LD_EXP 42
5041: PUSH
5042: LD_INT 3
5044: ARRAY
5045: PUSH
5046: LD_EXP 42
5050: PUSH
5051: LD_INT 4
5053: ARRAY
5054: PUSH
5055: EMPTY
5056: LIST
5057: LIST
5058: LIST
5059: LIST
5060: ST_TO_ADDR
// hc_agressivity = animalsAgression ;
5061: LD_ADDR_OWVAR 35
5065: PUSH
5066: LD_EXP 43
5070: ST_TO_ADDR
// un = CreateHuman ;
5071: LD_ADDR_VAR 0 3
5075: PUSH
5076: CALL_OW 44
5080: ST_TO_ADDR
// PlaceUnitArea ( un , NatureArea , false ) ;
5081: LD_VAR 0 3
5085: PPUSH
5086: LD_INT 5
5088: PPUSH
5089: LD_INT 0
5091: PPUSH
5092: CALL_OW 49
// end ;
5096: GO 4987
5098: POP
5099: POP
// for i := 1 to animalsAmount [ 3 ] do
5100: LD_ADDR_VAR 0 2
5104: PUSH
5105: DOUBLE
5106: LD_INT 1
5108: DEC
5109: ST_TO_ADDR
5110: LD_EXP 41
5114: PUSH
5115: LD_INT 3
5117: ARRAY
5118: PUSH
5119: FOR_TO
5120: IFFALSE 5230
// begin uc_side = 0 ;
5122: LD_ADDR_OWVAR 20
5126: PUSH
5127: LD_INT 0
5129: ST_TO_ADDR
// uc_nation = nation_nature ;
5130: LD_ADDR_OWVAR 21
5134: PUSH
5135: LD_INT 0
5137: ST_TO_ADDR
// hc_class = class_tiger ;
5138: LD_ADDR_OWVAR 28
5142: PUSH
5143: LD_INT 14
5145: ST_TO_ADDR
// hc_skills = [ animalsStats [ 1 ] , animalsStats [ 2 ] , animalsStats [ 3 ] , animalsStats [ 4 ] ] ;
5146: LD_ADDR_OWVAR 31
5150: PUSH
5151: LD_EXP 42
5155: PUSH
5156: LD_INT 1
5158: ARRAY
5159: PUSH
5160: LD_EXP 42
5164: PUSH
5165: LD_INT 2
5167: ARRAY
5168: PUSH
5169: LD_EXP 42
5173: PUSH
5174: LD_INT 3
5176: ARRAY
5177: PUSH
5178: LD_EXP 42
5182: PUSH
5183: LD_INT 4
5185: ARRAY
5186: PUSH
5187: EMPTY
5188: LIST
5189: LIST
5190: LIST
5191: LIST
5192: ST_TO_ADDR
// hc_agressivity = animalsAgression ;
5193: LD_ADDR_OWVAR 35
5197: PUSH
5198: LD_EXP 43
5202: ST_TO_ADDR
// un = CreateHuman ;
5203: LD_ADDR_VAR 0 3
5207: PUSH
5208: CALL_OW 44
5212: ST_TO_ADDR
// PlaceUnitArea ( un , NatureArea , false ) ;
5213: LD_VAR 0 3
5217: PPUSH
5218: LD_INT 5
5220: PPUSH
5221: LD_INT 0
5223: PPUSH
5224: CALL_OW 49
// end ;
5228: GO 5119
5230: POP
5231: POP
// for i := 1 to animalsAmount [ 4 ] do
5232: LD_ADDR_VAR 0 2
5236: PUSH
5237: DOUBLE
5238: LD_INT 1
5240: DEC
5241: ST_TO_ADDR
5242: LD_EXP 41
5246: PUSH
5247: LD_INT 4
5249: ARRAY
5250: PUSH
5251: FOR_TO
5252: IFFALSE 5362
// begin uc_side = 0 ;
5254: LD_ADDR_OWVAR 20
5258: PUSH
5259: LD_INT 0
5261: ST_TO_ADDR
// uc_nation = nation_nature ;
5262: LD_ADDR_OWVAR 21
5266: PUSH
5267: LD_INT 0
5269: ST_TO_ADDR
// hc_class = 21 ;
5270: LD_ADDR_OWVAR 28
5274: PUSH
5275: LD_INT 21
5277: ST_TO_ADDR
// hc_skills = [ animalsStats [ 1 ] , animalsStats [ 2 ] , animalsStats [ 3 ] , animalsStats [ 4 ] ] ;
5278: LD_ADDR_OWVAR 31
5282: PUSH
5283: LD_EXP 42
5287: PUSH
5288: LD_INT 1
5290: ARRAY
5291: PUSH
5292: LD_EXP 42
5296: PUSH
5297: LD_INT 2
5299: ARRAY
5300: PUSH
5301: LD_EXP 42
5305: PUSH
5306: LD_INT 3
5308: ARRAY
5309: PUSH
5310: LD_EXP 42
5314: PUSH
5315: LD_INT 4
5317: ARRAY
5318: PUSH
5319: EMPTY
5320: LIST
5321: LIST
5322: LIST
5323: LIST
5324: ST_TO_ADDR
// hc_agressivity = animalsAgression ;
5325: LD_ADDR_OWVAR 35
5329: PUSH
5330: LD_EXP 43
5334: ST_TO_ADDR
// un = CreateHuman ;
5335: LD_ADDR_VAR 0 3
5339: PUSH
5340: CALL_OW 44
5344: ST_TO_ADDR
// PlaceUnitArea ( un , NatureArea , false ) ;
5345: LD_VAR 0 3
5349: PPUSH
5350: LD_INT 5
5352: PPUSH
5353: LD_INT 0
5355: PPUSH
5356: CALL_OW 49
// end ;
5360: GO 5251
5362: POP
5363: POP
// for i := 1 to animalsAmount [ 5 ] do
5364: LD_ADDR_VAR 0 2
5368: PUSH
5369: DOUBLE
5370: LD_INT 1
5372: DEC
5373: ST_TO_ADDR
5374: LD_EXP 41
5378: PUSH
5379: LD_INT 5
5381: ARRAY
5382: PUSH
5383: FOR_TO
5384: IFFALSE 5445
// begin uc_side = 0 ;
5386: LD_ADDR_OWVAR 20
5390: PUSH
5391: LD_INT 0
5393: ST_TO_ADDR
// uc_nation = nation_nature ;
5394: LD_ADDR_OWVAR 21
5398: PUSH
5399: LD_INT 0
5401: ST_TO_ADDR
// vc_chassis := 31 ;
5402: LD_ADDR_OWVAR 37
5406: PUSH
5407: LD_INT 31
5409: ST_TO_ADDR
// vc_control := control_rider ;
5410: LD_ADDR_OWVAR 38
5414: PUSH
5415: LD_INT 4
5417: ST_TO_ADDR
// un := CreateVehicle ;
5418: LD_ADDR_VAR 0 3
5422: PUSH
5423: CALL_OW 45
5427: ST_TO_ADDR
// PlaceUnitArea ( un , NatureArea , false ) ;
5428: LD_VAR 0 3
5432: PPUSH
5433: LD_INT 5
5435: PPUSH
5436: LD_INT 0
5438: PPUSH
5439: CALL_OW 49
// end ;
5443: GO 5383
5445: POP
5446: POP
// end ;
5447: LD_VAR 0 1
5451: RET
// export function SpawnTrees ; begin
5452: LD_INT 0
5454: PPUSH
// PlaceTreesToArea ( TreeArea , [ 2 , 10 , 11 , 27 , 35 ] , 40 , 10 , 4 ) ;
5455: LD_INT 1
5457: PPUSH
5458: LD_INT 2
5460: PUSH
5461: LD_INT 10
5463: PUSH
5464: LD_INT 11
5466: PUSH
5467: LD_INT 27
5469: PUSH
5470: LD_INT 35
5472: PUSH
5473: EMPTY
5474: LIST
5475: LIST
5476: LIST
5477: LIST
5478: LIST
5479: PPUSH
5480: LD_INT 40
5482: PPUSH
5483: LD_INT 10
5485: PPUSH
5486: LD_INT 4
5488: PPUSH
5489: CALL_OW 352
// PlaceTreesToArea ( TreeArea , [ 9 , 10 , 27 , 35 , 48 ] , 30 , 10 , 4 ) ;
5493: LD_INT 1
5495: PPUSH
5496: LD_INT 9
5498: PUSH
5499: LD_INT 10
5501: PUSH
5502: LD_INT 27
5504: PUSH
5505: LD_INT 35
5507: PUSH
5508: LD_INT 48
5510: PUSH
5511: EMPTY
5512: LIST
5513: LIST
5514: LIST
5515: LIST
5516: LIST
5517: PPUSH
5518: LD_INT 30
5520: PPUSH
5521: LD_INT 10
5523: PPUSH
5524: LD_INT 4
5526: PPUSH
5527: CALL_OW 352
// PlaceTreesToArea ( TreeArea , [ 2 , 9 , 10 , 11 , 27 ] , 60 , 10 , 4 ) ;
5531: LD_INT 1
5533: PPUSH
5534: LD_INT 2
5536: PUSH
5537: LD_INT 9
5539: PUSH
5540: LD_INT 10
5542: PUSH
5543: LD_INT 11
5545: PUSH
5546: LD_INT 27
5548: PUSH
5549: EMPTY
5550: LIST
5551: LIST
5552: LIST
5553: LIST
5554: LIST
5555: PPUSH
5556: LD_INT 60
5558: PPUSH
5559: LD_INT 10
5561: PPUSH
5562: LD_INT 4
5564: PPUSH
5565: CALL_OW 352
// PlaceTreesToArea ( TreeArea , [ 9 , 10 , 27 , 35 , 48 ] , 90 , 10 , 4 ) ;
5569: LD_INT 1
5571: PPUSH
5572: LD_INT 9
5574: PUSH
5575: LD_INT 10
5577: PUSH
5578: LD_INT 27
5580: PUSH
5581: LD_INT 35
5583: PUSH
5584: LD_INT 48
5586: PUSH
5587: EMPTY
5588: LIST
5589: LIST
5590: LIST
5591: LIST
5592: LIST
5593: PPUSH
5594: LD_INT 90
5596: PPUSH
5597: LD_INT 10
5599: PPUSH
5600: LD_INT 4
5602: PPUSH
5603: CALL_OW 352
// PlaceTreesToArea ( TreeArea , [ 2 , 9 , 10 , 11 , 48 ] , 120 , 10 , 4 ) ;
5607: LD_INT 1
5609: PPUSH
5610: LD_INT 2
5612: PUSH
5613: LD_INT 9
5615: PUSH
5616: LD_INT 10
5618: PUSH
5619: LD_INT 11
5621: PUSH
5622: LD_INT 48
5624: PUSH
5625: EMPTY
5626: LIST
5627: LIST
5628: LIST
5629: LIST
5630: LIST
5631: PPUSH
5632: LD_INT 120
5634: PPUSH
5635: LD_INT 10
5637: PPUSH
5638: LD_INT 4
5640: PPUSH
5641: CALL_OW 352
// PlaceTreesToArea ( TreeArea , [ 2 , 11 , 27 , 35 , 48 ] , 45 , 10 , 4 ) ;
5645: LD_INT 1
5647: PPUSH
5648: LD_INT 2
5650: PUSH
5651: LD_INT 11
5653: PUSH
5654: LD_INT 27
5656: PUSH
5657: LD_INT 35
5659: PUSH
5660: LD_INT 48
5662: PUSH
5663: EMPTY
5664: LIST
5665: LIST
5666: LIST
5667: LIST
5668: LIST
5669: PPUSH
5670: LD_INT 45
5672: PPUSH
5673: LD_INT 10
5675: PPUSH
5676: LD_INT 4
5678: PPUSH
5679: CALL_OW 352
// end ;
5683: LD_VAR 0 1
5687: RET
// every 0 0$1 do var i , un ;
5688: GO 5690
5690: DISABLE
5691: LD_INT 0
5693: PPUSH
5694: PPUSH
// begin if ( GetTech ( tech_apelang , 3 ) = state_enabled or GetTech ( tech_apepsych , 3 ) = state_enabled or GetTech ( tech_apeagres , 3 ) = state_enabled ) and not FilterAllUnits ( [ [ f_or , [ f_class , class_apeman ] , [ f_class , class_apeman_engineer ] , [ f_class , class_apeman_soldier ] ] ] ) then
5695: LD_INT 1
5697: PPUSH
5698: LD_INT 3
5700: PPUSH
5701: CALL_OW 321
5705: PUSH
5706: LD_INT 1
5708: EQUAL
5709: PUSH
5710: LD_INT 2
5712: PPUSH
5713: LD_INT 3
5715: PPUSH
5716: CALL_OW 321
5720: PUSH
5721: LD_INT 1
5723: EQUAL
5724: OR
5725: PUSH
5726: LD_INT 11
5728: PPUSH
5729: LD_INT 3
5731: PPUSH
5732: CALL_OW 321
5736: PUSH
5737: LD_INT 1
5739: EQUAL
5740: OR
5741: PUSH
5742: LD_INT 2
5744: PUSH
5745: LD_INT 25
5747: PUSH
5748: LD_INT 12
5750: PUSH
5751: EMPTY
5752: LIST
5753: LIST
5754: PUSH
5755: LD_INT 25
5757: PUSH
5758: LD_INT 16
5760: PUSH
5761: EMPTY
5762: LIST
5763: LIST
5764: PUSH
5765: LD_INT 25
5767: PUSH
5768: LD_INT 15
5770: PUSH
5771: EMPTY
5772: LIST
5773: LIST
5774: PUSH
5775: EMPTY
5776: LIST
5777: LIST
5778: LIST
5779: LIST
5780: PUSH
5781: EMPTY
5782: LIST
5783: PPUSH
5784: CALL_OW 69
5788: NOT
5789: AND
5790: IFFALSE 5926
// begin for i := 1 to Rand ( 2 , 4 ) do
5792: LD_ADDR_VAR 0 1
5796: PUSH
5797: DOUBLE
5798: LD_INT 1
5800: DEC
5801: ST_TO_ADDR
5802: LD_INT 2
5804: PPUSH
5805: LD_INT 4
5807: PPUSH
5808: CALL_OW 12
5812: PUSH
5813: FOR_TO
5814: IFFALSE 5924
// begin uc_side = 0 ;
5816: LD_ADDR_OWVAR 20
5820: PUSH
5821: LD_INT 0
5823: ST_TO_ADDR
// uc_nation = nation_nature ;
5824: LD_ADDR_OWVAR 21
5828: PUSH
5829: LD_INT 0
5831: ST_TO_ADDR
// hc_class = class_apeman ;
5832: LD_ADDR_OWVAR 28
5836: PUSH
5837: LD_INT 12
5839: ST_TO_ADDR
// hc_skills = [ animalsStats [ 1 ] , animalsStats [ 2 ] , animalsStats [ 3 ] , animalsStats [ 4 ] ] ;
5840: LD_ADDR_OWVAR 31
5844: PUSH
5845: LD_EXP 42
5849: PUSH
5850: LD_INT 1
5852: ARRAY
5853: PUSH
5854: LD_EXP 42
5858: PUSH
5859: LD_INT 2
5861: ARRAY
5862: PUSH
5863: LD_EXP 42
5867: PUSH
5868: LD_INT 3
5870: ARRAY
5871: PUSH
5872: LD_EXP 42
5876: PUSH
5877: LD_INT 4
5879: ARRAY
5880: PUSH
5881: EMPTY
5882: LIST
5883: LIST
5884: LIST
5885: LIST
5886: ST_TO_ADDR
// hc_agressivity = animalsAgression ;
5887: LD_ADDR_OWVAR 35
5891: PUSH
5892: LD_EXP 43
5896: ST_TO_ADDR
// un = CreateHuman ;
5897: LD_ADDR_VAR 0 2
5901: PUSH
5902: CALL_OW 44
5906: ST_TO_ADDR
// PlaceUnitArea ( un , NatureArea , false ) ;
5907: LD_VAR 0 2
5911: PPUSH
5912: LD_INT 5
5914: PPUSH
5915: LD_INT 0
5917: PPUSH
5918: CALL_OW 49
// end ;
5922: GO 5813
5924: POP
5925: POP
// end ; enable ;
5926: ENABLE
// end ; end_of_file
5927: PPOPN 2
5929: END
// export function PrepareUnitExt ( ident , exist_mode , class ) ; var unit ; begin
5930: LD_INT 0
5932: PPUSH
5933: PPUSH
// if debugMode then
5934: LD_EXP 46
5938: IFFALSE 5955
// unit := NewCharacter ( ident ) ;
5940: LD_ADDR_VAR 0 5
5944: PUSH
5945: LD_VAR 0 1
5949: PPUSH
5950: CALL_OW 25
5954: ST_TO_ADDR
// if exist_mode and not debugMode then
5955: LD_VAR 0 2
5959: PUSH
5960: LD_EXP 46
5964: NOT
5965: AND
5966: IFFALSE 5991
// unit := CreateCharacter ( previousMissionPrefix & ident ) else
5968: LD_ADDR_VAR 0 5
5972: PUSH
5973: LD_EXP 45
5977: PUSH
5978: LD_VAR 0 1
5982: STR
5983: PPUSH
5984: CALL_OW 34
5988: ST_TO_ADDR
5989: GO 6013
// if not debugMode then
5991: LD_EXP 46
5995: NOT
5996: IFFALSE 6013
// unit := NewCharacter ( ident ) ;
5998: LD_ADDR_VAR 0 5
6002: PUSH
6003: LD_VAR 0 1
6007: PPUSH
6008: CALL_OW 25
6012: ST_TO_ADDR
// if class then
6013: LD_VAR 0 3
6017: IFFALSE 6033
// SetClass ( unit , class ) ;
6019: LD_VAR 0 5
6023: PPUSH
6024: LD_VAR 0 3
6028: PPUSH
6029: CALL_OW 336
// result := unit ;
6033: LD_ADDR_VAR 0 4
6037: PUSH
6038: LD_VAR 0 5
6042: ST_TO_ADDR
// end ;
6043: LD_VAR 0 4
6047: RET
// export function ExtSaveCharacter ( character , characterStringID , side ) ; begin
6048: LD_INT 0
6050: PPUSH
// if GetSide ( character ) = side and not IsDead ( character ) then
6051: LD_VAR 0 1
6055: PPUSH
6056: CALL_OW 255
6060: PUSH
6061: LD_VAR 0 3
6065: EQUAL
6066: PUSH
6067: LD_VAR 0 1
6071: PPUSH
6072: CALL_OW 301
6076: NOT
6077: AND
6078: IFFALSE 6100
// SaveCharacters ( character , missionPrefix & characterStringID ) ;
6080: LD_VAR 0 1
6084: PPUSH
6085: LD_EXP 44
6089: PUSH
6090: LD_VAR 0 2
6094: STR
6095: PPUSH
6096: CALL_OW 38
// end ;
6100: LD_VAR 0 4
6104: RET
// export function ExtSaveCharacters ( characters , charactersStringID , side ) ; var unit , resultCharactersToSave ; begin
6105: LD_INT 0
6107: PPUSH
6108: PPUSH
6109: PPUSH
// resultCharactersToSave = [ ] ;
6110: LD_ADDR_VAR 0 6
6114: PUSH
6115: EMPTY
6116: ST_TO_ADDR
// for unit in characters do
6117: LD_ADDR_VAR 0 5
6121: PUSH
6122: LD_VAR 0 1
6126: PUSH
6127: FOR_IN
6128: IFFALSE 6177
// if GetSide ( unit ) = side and not IsDead ( unit ) then
6130: LD_VAR 0 5
6134: PPUSH
6135: CALL_OW 255
6139: PUSH
6140: LD_VAR 0 3
6144: EQUAL
6145: PUSH
6146: LD_VAR 0 5
6150: PPUSH
6151: CALL_OW 301
6155: NOT
6156: AND
6157: IFFALSE 6175
// resultCharactersToSave = resultCharactersToSave ^ unit ;
6159: LD_ADDR_VAR 0 6
6163: PUSH
6164: LD_VAR 0 6
6168: PUSH
6169: LD_VAR 0 5
6173: ADD
6174: ST_TO_ADDR
6175: GO 6127
6177: POP
6178: POP
// SaveCharacters ( resultCharactersToSave , missionPrefix & charactersStringID ) ;
6179: LD_VAR 0 6
6183: PPUSH
6184: LD_EXP 44
6188: PUSH
6189: LD_VAR 0 2
6193: STR
6194: PPUSH
6195: CALL_OW 38
// end ;
6199: LD_VAR 0 4
6203: RET
// export function PlaceUnitsArea ( units , area , spawnMode ) ; var unit ; begin
6204: LD_INT 0
6206: PPUSH
6207: PPUSH
// for unit in units do
6208: LD_ADDR_VAR 0 5
6212: PUSH
6213: LD_VAR 0 1
6217: PUSH
6218: FOR_IN
6219: IFFALSE 6242
// PlaceUnitArea ( unit , area , spawnMode ) ;
6221: LD_VAR 0 5
6225: PPUSH
6226: LD_VAR 0 2
6230: PPUSH
6231: LD_VAR 0 3
6235: PPUSH
6236: CALL_OW 49
6240: GO 6218
6242: POP
6243: POP
// end ;
6244: LD_VAR 0 4
6248: RET
// export function DialogRandom ( characters , dialogMID , dialogFID , radio , canTalkHero ) ; var i , speaker , units ; begin
6249: LD_INT 0
6251: PPUSH
6252: PPUSH
6253: PPUSH
6254: PPUSH
// units = characters ;
6255: LD_ADDR_VAR 0 9
6259: PUSH
6260: LD_VAR 0 1
6264: ST_TO_ADDR
// units := units diff [ Burlak , Karamazov , Petrovova , Gleb , Petrosyan , Titov , Dolgov , Lipshchin , Kirilenkova ] ;
6265: LD_ADDR_VAR 0 9
6269: PUSH
6270: LD_VAR 0 9
6274: PUSH
6275: LD_EXP 57
6279: PUSH
6280: LD_EXP 58
6284: PUSH
6285: LD_EXP 59
6289: PUSH
6290: LD_EXP 60
6294: PUSH
6295: LD_EXP 61
6299: PUSH
6300: LD_EXP 62
6304: PUSH
6305: LD_EXP 63
6309: PUSH
6310: LD_EXP 64
6314: PUSH
6315: LD_EXP 65
6319: PUSH
6320: EMPTY
6321: LIST
6322: LIST
6323: LIST
6324: LIST
6325: LIST
6326: LIST
6327: LIST
6328: LIST
6329: LIST
6330: DIFF
6331: ST_TO_ADDR
// if not units and not canTalkHero then
6332: LD_VAR 0 9
6336: NOT
6337: PUSH
6338: LD_VAR 0 5
6342: NOT
6343: AND
6344: IFFALSE 6348
// exit ;
6346: GO 6521
// if not units then
6348: LD_VAR 0 9
6352: NOT
6353: IFFALSE 6374
// units = characters diff [ Burlak ] ;
6355: LD_ADDR_VAR 0 9
6359: PUSH
6360: LD_VAR 0 1
6364: PUSH
6365: LD_EXP 57
6369: PUSH
6370: EMPTY
6371: LIST
6372: DIFF
6373: ST_TO_ADDR
// if not units and canTalkHero then
6374: LD_VAR 0 9
6378: NOT
6379: PUSH
6380: LD_VAR 0 5
6384: AND
6385: IFFALSE 6389
// exit ;
6387: GO 6521
// speaker := units [ rand ( 1 , units ) ] ;
6389: LD_ADDR_VAR 0 8
6393: PUSH
6394: LD_VAR 0 9
6398: PUSH
6399: LD_INT 1
6401: PPUSH
6402: LD_VAR 0 9
6406: PPUSH
6407: CALL_OW 12
6411: ARRAY
6412: ST_TO_ADDR
// if radio then
6413: LD_VAR 0 4
6417: IFFALSE 6466
// begin if GetSex ( speaker ) = sex_male then
6419: LD_VAR 0 8
6423: PPUSH
6424: CALL_OW 258
6428: PUSH
6429: LD_INT 1
6431: EQUAL
6432: IFFALSE 6450
// SayRadio ( speaker , dialogMID ) else
6434: LD_VAR 0 8
6438: PPUSH
6439: LD_VAR 0 2
6443: PPUSH
6444: CALL_OW 94
6448: GO 6464
// SayRadio ( speaker , dialogFID ) ;
6450: LD_VAR 0 8
6454: PPUSH
6455: LD_VAR 0 3
6459: PPUSH
6460: CALL_OW 94
// end else
6464: GO 6511
// begin if GetSex ( speaker ) = sex_male then
6466: LD_VAR 0 8
6470: PPUSH
6471: CALL_OW 258
6475: PUSH
6476: LD_INT 1
6478: EQUAL
6479: IFFALSE 6497
// Say ( speaker , dialogMID ) else
6481: LD_VAR 0 8
6485: PPUSH
6486: LD_VAR 0 2
6490: PPUSH
6491: CALL_OW 88
6495: GO 6511
// Say ( speaker , dialogFID ) ;
6497: LD_VAR 0 8
6501: PPUSH
6502: LD_VAR 0 3
6506: PPUSH
6507: CALL_OW 88
// end ; result := speaker ;
6511: LD_ADDR_VAR 0 6
6515: PUSH
6516: LD_VAR 0 8
6520: ST_TO_ADDR
// end ;
6521: LD_VAR 0 6
6525: RET
// export function RemoveUnits ( units ) ; var unit ; begin
6526: LD_INT 0
6528: PPUSH
6529: PPUSH
// if not units then
6530: LD_VAR 0 1
6534: NOT
6535: IFFALSE 6539
// exit ;
6537: GO 6685
// if Heike in units then
6539: LD_EXP 79
6543: PUSH
6544: LD_VAR 0 1
6548: IN
6549: IFFALSE 6605
// begin if GetAttitude ( 3 , 8 ) = att_neutral then
6551: LD_INT 3
6553: PPUSH
6554: LD_INT 8
6556: PPUSH
6557: CALL_OW 81
6561: PUSH
6562: LD_INT 0
6564: EQUAL
6565: IFFALSE 6577
// HeikeStatus = 1 else
6567: LD_ADDR_EXP 3
6571: PUSH
6572: LD_INT 1
6574: ST_TO_ADDR
6575: GO 6585
// HeikeStatus = 2 ;
6577: LD_ADDR_EXP 3
6581: PUSH
6582: LD_INT 2
6584: ST_TO_ADDR
// forceStopKurtAttack = true ;
6585: LD_ADDR_EXP 27
6589: PUSH
6590: LD_INT 1
6592: ST_TO_ADDR
// SetClass ( Heike , 1 ) ;
6593: LD_EXP 79
6597: PPUSH
6598: LD_INT 1
6600: PPUSH
6601: CALL_OW 336
// end ; if Kurt in units then
6605: LD_EXP 80
6609: PUSH
6610: LD_VAR 0 1
6614: IN
6615: IFFALSE 6659
// begin if GetAttitude ( 3 , 8 ) = att_neutral then
6617: LD_INT 3
6619: PPUSH
6620: LD_INT 8
6622: PPUSH
6623: CALL_OW 81
6627: PUSH
6628: LD_INT 0
6630: EQUAL
6631: IFFALSE 6643
// KurtStatus = 1 else
6633: LD_ADDR_EXP 22
6637: PUSH
6638: LD_INT 1
6640: ST_TO_ADDR
6641: GO 6659
// begin KurtStatus = 2 ;
6643: LD_ADDR_EXP 22
6647: PUSH
6648: LD_INT 2
6650: ST_TO_ADDR
// KurtAttack = 1 ;
6651: LD_ADDR_EXP 25
6655: PUSH
6656: LD_INT 1
6658: ST_TO_ADDR
// end ; end ; for unit in units do
6659: LD_ADDR_VAR 0 3
6663: PUSH
6664: LD_VAR 0 1
6668: PUSH
6669: FOR_IN
6670: IFFALSE 6683
// RemoveUnit ( unit ) ;
6672: LD_VAR 0 3
6676: PPUSH
6677: CALL_OW 64
6681: GO 6669
6683: POP
6684: POP
// end ;
6685: LD_VAR 0 2
6689: RET
// export function GetAmountWeaponsDataBuildOnTurret ( isBuild ) ; var i , amount ; begin
6690: LD_INT 0
6692: PPUSH
6693: PPUSH
6694: PPUSH
// amount = 0 ;
6695: LD_ADDR_VAR 0 4
6699: PUSH
6700: LD_INT 0
6702: ST_TO_ADDR
// for i := 1 to weaponsData do
6703: LD_ADDR_VAR 0 3
6707: PUSH
6708: DOUBLE
6709: LD_INT 1
6711: DEC
6712: ST_TO_ADDR
6713: LD_EXP 12
6717: PUSH
6718: FOR_TO
6719: IFFALSE 6759
// if weaponsData [ i ] [ 2 ] = isBuild then
6721: LD_EXP 12
6725: PUSH
6726: LD_VAR 0 3
6730: ARRAY
6731: PUSH
6732: LD_INT 2
6734: ARRAY
6735: PUSH
6736: LD_VAR 0 1
6740: EQUAL
6741: IFFALSE 6757
// amount = amount + 1 ;
6743: LD_ADDR_VAR 0 4
6747: PUSH
6748: LD_VAR 0 4
6752: PUSH
6753: LD_INT 1
6755: PLUS
6756: ST_TO_ADDR
6757: GO 6718
6759: POP
6760: POP
// if isBuild then
6761: LD_VAR 0 1
6765: IFFALSE 6785
// if amount >= 3 then
6767: LD_VAR 0 4
6771: PUSH
6772: LD_INT 3
6774: GREATEREQUAL
6775: IFFALSE 6785
// amount = 3 ;
6777: LD_ADDR_VAR 0 4
6781: PUSH
6782: LD_INT 3
6784: ST_TO_ADDR
// result = amount ;
6785: LD_ADDR_VAR 0 2
6789: PUSH
6790: LD_VAR 0 4
6794: ST_TO_ADDR
// end ;
6795: LD_VAR 0 2
6799: RET
// export function GetAmountWeaponsDataBuildOnVehicle ( isBuild ) ; var i , amount ; begin
6800: LD_INT 0
6802: PPUSH
6803: PPUSH
6804: PPUSH
// amount = 0 ;
6805: LD_ADDR_VAR 0 4
6809: PUSH
6810: LD_INT 0
6812: ST_TO_ADDR
// for i := 1 to weaponsData do
6813: LD_ADDR_VAR 0 3
6817: PUSH
6818: DOUBLE
6819: LD_INT 1
6821: DEC
6822: ST_TO_ADDR
6823: LD_EXP 12
6827: PUSH
6828: FOR_TO
6829: IFFALSE 6869
// if weaponsData [ i ] [ 3 ] = isBuild then
6831: LD_EXP 12
6835: PUSH
6836: LD_VAR 0 3
6840: ARRAY
6841: PUSH
6842: LD_INT 3
6844: ARRAY
6845: PUSH
6846: LD_VAR 0 1
6850: EQUAL
6851: IFFALSE 6867
// amount = amount + 1 ;
6853: LD_ADDR_VAR 0 4
6857: PUSH
6858: LD_VAR 0 4
6862: PUSH
6863: LD_INT 1
6865: PLUS
6866: ST_TO_ADDR
6867: GO 6828
6869: POP
6870: POP
// result = amount ;
6871: LD_ADDR_VAR 0 2
6875: PUSH
6876: LD_VAR 0 4
6880: ST_TO_ADDR
// end ;
6881: LD_VAR 0 2
6885: RET
// export function SetWeaponDataBuild ( weapon , turret ) ; var i ; begin
6886: LD_INT 0
6888: PPUSH
6889: PPUSH
// if turret then
6890: LD_VAR 0 2
6894: IFFALSE 6992
// begin for i := 1 to weaponsData do
6896: LD_ADDR_VAR 0 4
6900: PUSH
6901: DOUBLE
6902: LD_INT 1
6904: DEC
6905: ST_TO_ADDR
6906: LD_EXP 12
6910: PUSH
6911: FOR_TO
6912: IFFALSE 6988
// if weaponsData [ i ] [ 1 ] = weapon and weaponsData [ i ] [ 2 ] = false then
6914: LD_EXP 12
6918: PUSH
6919: LD_VAR 0 4
6923: ARRAY
6924: PUSH
6925: LD_INT 1
6927: ARRAY
6928: PUSH
6929: LD_VAR 0 1
6933: EQUAL
6934: PUSH
6935: LD_EXP 12
6939: PUSH
6940: LD_VAR 0 4
6944: ARRAY
6945: PUSH
6946: LD_INT 2
6948: ARRAY
6949: PUSH
6950: LD_INT 0
6952: EQUAL
6953: AND
6954: IFFALSE 6986
// weaponsData = ReplaceIn ( weaponsData , [ i , 2 ] , true ) ;
6956: LD_ADDR_EXP 12
6960: PUSH
6961: LD_EXP 12
6965: PPUSH
6966: LD_VAR 0 4
6970: PUSH
6971: LD_INT 2
6973: PUSH
6974: EMPTY
6975: LIST
6976: LIST
6977: PPUSH
6978: LD_INT 1
6980: PPUSH
6981: CALL 24363 0 3
6985: ST_TO_ADDR
6986: GO 6911
6988: POP
6989: POP
// end else
6990: GO 7086
// begin for i := 1 to weaponsData do
6992: LD_ADDR_VAR 0 4
6996: PUSH
6997: DOUBLE
6998: LD_INT 1
7000: DEC
7001: ST_TO_ADDR
7002: LD_EXP 12
7006: PUSH
7007: FOR_TO
7008: IFFALSE 7084
// if weaponsData [ i ] [ 1 ] = weapon and weaponsData [ i ] [ 3 ] = false then
7010: LD_EXP 12
7014: PUSH
7015: LD_VAR 0 4
7019: ARRAY
7020: PUSH
7021: LD_INT 1
7023: ARRAY
7024: PUSH
7025: LD_VAR 0 1
7029: EQUAL
7030: PUSH
7031: LD_EXP 12
7035: PUSH
7036: LD_VAR 0 4
7040: ARRAY
7041: PUSH
7042: LD_INT 3
7044: ARRAY
7045: PUSH
7046: LD_INT 0
7048: EQUAL
7049: AND
7050: IFFALSE 7082
// weaponsData = ReplaceIn ( weaponsData , [ i , 3 ] , true ) ;
7052: LD_ADDR_EXP 12
7056: PUSH
7057: LD_EXP 12
7061: PPUSH
7062: LD_VAR 0 4
7066: PUSH
7067: LD_INT 3
7069: PUSH
7070: EMPTY
7071: LIST
7072: LIST
7073: PPUSH
7074: LD_INT 1
7076: PPUSH
7077: CALL 24363 0 3
7081: ST_TO_ADDR
7082: GO 7007
7084: POP
7085: POP
// end ; end ;
7086: LD_VAR 0 3
7090: RET
// export function ShootTreningController ; var i , unitsInArea , unit , depots , depot , barrelsAreaList , randIndex , randPosX , randPosY , barrelsInArea ; begin
7091: LD_INT 0
7093: PPUSH
7094: PPUSH
7095: PPUSH
7096: PPUSH
7097: PPUSH
7098: PPUSH
7099: PPUSH
7100: PPUSH
7101: PPUSH
7102: PPUSH
7103: PPUSH
// unitsInArea = FilterUnitsInArea ( ShootArea , [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) ;
7104: LD_ADDR_VAR 0 3
7108: PUSH
7109: LD_INT 12
7111: PPUSH
7112: LD_INT 22
7114: PUSH
7115: LD_INT 3
7117: PUSH
7118: EMPTY
7119: LIST
7120: LIST
7121: PUSH
7122: LD_INT 21
7124: PUSH
7125: LD_INT 1
7127: PUSH
7128: EMPTY
7129: LIST
7130: LIST
7131: PUSH
7132: LD_INT 50
7134: PUSH
7135: EMPTY
7136: LIST
7137: PUSH
7138: LD_INT 3
7140: PUSH
7141: LD_INT 60
7143: PUSH
7144: EMPTY
7145: LIST
7146: PUSH
7147: EMPTY
7148: LIST
7149: LIST
7150: PUSH
7151: EMPTY
7152: LIST
7153: LIST
7154: LIST
7155: LIST
7156: PPUSH
7157: CALL_OW 70
7161: ST_TO_ADDR
// depots = FilterAllUnits ( [ [ f_side , 3 ] , [ f_ok ] , [ f_type , unit_building ] , [ f_not , [ f_constructed ] ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
7162: LD_ADDR_VAR 0 5
7166: PUSH
7167: LD_INT 22
7169: PUSH
7170: LD_INT 3
7172: PUSH
7173: EMPTY
7174: LIST
7175: LIST
7176: PUSH
7177: LD_INT 50
7179: PUSH
7180: EMPTY
7181: LIST
7182: PUSH
7183: LD_INT 21
7185: PUSH
7186: LD_INT 3
7188: PUSH
7189: EMPTY
7190: LIST
7191: LIST
7192: PUSH
7193: LD_INT 3
7195: PUSH
7196: LD_INT 57
7198: PUSH
7199: EMPTY
7200: LIST
7201: PUSH
7202: EMPTY
7203: LIST
7204: LIST
7205: PUSH
7206: LD_INT 2
7208: PUSH
7209: LD_INT 30
7211: PUSH
7212: LD_INT 0
7214: PUSH
7215: EMPTY
7216: LIST
7217: LIST
7218: PUSH
7219: LD_INT 30
7221: PUSH
7222: LD_INT 1
7224: PUSH
7225: EMPTY
7226: LIST
7227: LIST
7228: PUSH
7229: EMPTY
7230: LIST
7231: LIST
7232: LIST
7233: PUSH
7234: EMPTY
7235: LIST
7236: LIST
7237: LIST
7238: LIST
7239: LIST
7240: PPUSH
7241: CALL_OW 69
7245: ST_TO_ADDR
// barrelsAreaList = AreaToList ( BarrelsArea , 0 ) ;
7246: LD_ADDR_VAR 0 7
7250: PUSH
7251: LD_INT 13
7253: PPUSH
7254: LD_INT 0
7256: PPUSH
7257: CALL_OW 517
7261: ST_TO_ADDR
// if not depots or not unitsInArea then
7262: LD_VAR 0 5
7266: NOT
7267: PUSH
7268: LD_VAR 0 3
7272: NOT
7273: OR
7274: IFFALSE 7278
// exit ;
7276: GO 7714
// depot = depots [ 1 ] ;
7278: LD_ADDR_VAR 0 6
7282: PUSH
7283: LD_VAR 0 5
7287: PUSH
7288: LD_INT 1
7290: ARRAY
7291: ST_TO_ADDR
// for unit in unitsInArea do
7292: LD_ADDR_VAR 0 4
7296: PUSH
7297: LD_VAR 0 3
7301: PUSH
7302: FOR_IN
7303: IFFALSE 7712
// begin if not GetClass ( unit ) = class_engineer then
7305: LD_VAR 0 4
7309: PPUSH
7310: CALL_OW 257
7314: PUSH
7315: LD_INT 2
7317: EQUAL
7318: NOT
7319: IFFALSE 7356
// begin ComEnterUnit ( unit , depot ) ;
7321: LD_VAR 0 4
7325: PPUSH
7326: LD_VAR 0 6
7330: PPUSH
7331: CALL_OW 120
// AddComChangeProfession ( unit , class_engineer ) ;
7335: LD_VAR 0 4
7339: PPUSH
7340: LD_INT 2
7342: PPUSH
7343: CALL_OW 183
// AddComExitBuilding ( unit ) ;
7347: LD_VAR 0 4
7351: PPUSH
7352: CALL_OW 182
// end ; if GetCargo ( unit , mat_oil ) = 0 then
7356: LD_VAR 0 4
7360: PPUSH
7361: LD_INT 2
7363: PPUSH
7364: CALL_OW 289
7368: PUSH
7369: LD_INT 0
7371: EQUAL
7372: IFFALSE 7391
// AddComTransport ( unit , depot , mat_oil ) ;
7374: LD_VAR 0 4
7378: PPUSH
7379: LD_VAR 0 6
7383: PPUSH
7384: LD_INT 2
7386: PPUSH
7387: CALL_OW 211
// repeat wait ( 0 0$1 ) ;
7391: LD_INT 35
7393: PPUSH
7394: CALL_OW 67
// until not HasTask ( unit ) ;
7398: LD_VAR 0 4
7402: PPUSH
7403: CALL_OW 314
7407: NOT
7408: IFFALSE 7391
// if GetCargo ( unit , mat_oil ) > 0 then
7410: LD_VAR 0 4
7414: PPUSH
7415: LD_INT 2
7417: PPUSH
7418: CALL_OW 289
7422: PUSH
7423: LD_INT 0
7425: GREATER
7426: IFFALSE 7710
// begin randIndex = Rand ( 1 , barrelsAreaList [ 1 ] ) ;
7428: LD_ADDR_VAR 0 8
7432: PUSH
7433: LD_INT 1
7435: PPUSH
7436: LD_VAR 0 7
7440: PUSH
7441: LD_INT 1
7443: ARRAY
7444: PPUSH
7445: CALL_OW 12
7449: ST_TO_ADDR
// randPosX = barrelsAreaList [ 1 ] [ randIndex ] ;
7450: LD_ADDR_VAR 0 9
7454: PUSH
7455: LD_VAR 0 7
7459: PUSH
7460: LD_INT 1
7462: ARRAY
7463: PUSH
7464: LD_VAR 0 8
7468: ARRAY
7469: ST_TO_ADDR
// randPosY = barrelsAreaList [ 2 ] [ RandIndex ] ;
7470: LD_ADDR_VAR 0 10
7474: PUSH
7475: LD_VAR 0 7
7479: PUSH
7480: LD_INT 2
7482: ARRAY
7483: PUSH
7484: LD_VAR 0 8
7488: ARRAY
7489: ST_TO_ADDR
// AddComMoveXY ( unit , randPosX , randPosY ) ;
7490: LD_VAR 0 4
7494: PPUSH
7495: LD_VAR 0 9
7499: PPUSH
7500: LD_VAR 0 10
7504: PPUSH
7505: CALL_OW 171
// AddComUnload ( unit ) ;
7509: LD_VAR 0 4
7513: PPUSH
7514: CALL_OW 219
// AddComMoveXY ( unit , randPosX + 2 , randPosY + 2 ) ;
7518: LD_VAR 0 4
7522: PPUSH
7523: LD_VAR 0 9
7527: PUSH
7528: LD_INT 2
7530: PLUS
7531: PPUSH
7532: LD_VAR 0 10
7536: PUSH
7537: LD_INT 2
7539: PLUS
7540: PPUSH
7541: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
7545: LD_INT 35
7547: PPUSH
7548: CALL_OW 67
// until not HasTask ( unit ) ;
7552: LD_VAR 0 4
7556: PPUSH
7557: CALL_OW 314
7561: NOT
7562: IFFALSE 7545
// barrelsInArea = GetListOfCratesInArea ( ShootArea ) ;
7564: LD_ADDR_VAR 0 11
7568: PUSH
7569: LD_INT 12
7571: PPUSH
7572: CALL_OW 435
7576: ST_TO_ADDR
// for i := 1 to barrelsInArea / 2 do
7577: LD_ADDR_VAR 0 2
7581: PUSH
7582: DOUBLE
7583: LD_INT 1
7585: DEC
7586: ST_TO_ADDR
7587: LD_VAR 0 11
7591: PUSH
7592: LD_INT 2
7594: DIVREAL
7595: PUSH
7596: FOR_TO
7597: IFFALSE 7708
// begin if GetDistUnitXY ( unit , barrelsInArea [ i ] , barrelsInArea [ i + 1 ] ) <= 6 then
7599: LD_VAR 0 4
7603: PPUSH
7604: LD_VAR 0 11
7608: PUSH
7609: LD_VAR 0 2
7613: ARRAY
7614: PPUSH
7615: LD_VAR 0 11
7619: PUSH
7620: LD_VAR 0 2
7624: PUSH
7625: LD_INT 1
7627: PLUS
7628: ARRAY
7629: PPUSH
7630: CALL_OW 297
7634: PUSH
7635: LD_INT 6
7637: LESSEQUAL
7638: IFFALSE 7692
// begin AddComAttackPlace ( unit , barrelsInArea [ i ] , barrelsInArea [ i + 1 ] ) ;
7640: LD_VAR 0 4
7644: PPUSH
7645: LD_VAR 0 11
7649: PUSH
7650: LD_VAR 0 2
7654: ARRAY
7655: PPUSH
7656: LD_VAR 0 11
7660: PUSH
7661: LD_VAR 0 2
7665: PUSH
7666: LD_INT 1
7668: PLUS
7669: ARRAY
7670: PPUSH
7671: CALL_OW 176
// AddExperience ( unit , skill_combat , 5 ) ;
7675: LD_VAR 0 4
7679: PPUSH
7680: LD_INT 1
7682: PPUSH
7683: LD_INT 5
7685: PPUSH
7686: CALL_OW 492
// break ;
7690: GO 7708
// end ; i = i + 2 ;
7692: LD_ADDR_VAR 0 2
7696: PUSH
7697: LD_VAR 0 2
7701: PUSH
7702: LD_INT 2
7704: PLUS
7705: ST_TO_ADDR
// end ;
7706: GO 7596
7708: POP
7709: POP
// end ; end ;
7710: GO 7302
7712: POP
7713: POP
// end ;
7714: LD_VAR 0 1
7718: RET
// export function GoToHunt ( hunter ) ; var i , barracks , barrackTarget , barrackTargetCurrentHP , animals , animal ; begin
7719: LD_INT 0
7721: PPUSH
7722: PPUSH
7723: PPUSH
7724: PPUSH
7725: PPUSH
7726: PPUSH
7727: PPUSH
// animals = [ ] ;
7728: LD_ADDR_VAR 0 7
7732: PUSH
7733: EMPTY
7734: ST_TO_ADDR
// barracks = FilterAllUnits ( [ [ f_ok ] , [ f_not , [ f_constructed ] ] , [ f_or , [ f_btype , b_barracks ] , [ f_btype , b_armoury ] ] ] ) ;
7735: LD_ADDR_VAR 0 4
7739: PUSH
7740: LD_INT 50
7742: PUSH
7743: EMPTY
7744: LIST
7745: PUSH
7746: LD_INT 3
7748: PUSH
7749: LD_INT 57
7751: PUSH
7752: EMPTY
7753: LIST
7754: PUSH
7755: EMPTY
7756: LIST
7757: LIST
7758: PUSH
7759: LD_INT 2
7761: PUSH
7762: LD_INT 30
7764: PUSH
7765: LD_INT 5
7767: PUSH
7768: EMPTY
7769: LIST
7770: LIST
7771: PUSH
7772: LD_INT 30
7774: PUSH
7775: LD_INT 4
7777: PUSH
7778: EMPTY
7779: LIST
7780: LIST
7781: PUSH
7782: EMPTY
7783: LIST
7784: LIST
7785: LIST
7786: PUSH
7787: EMPTY
7788: LIST
7789: LIST
7790: LIST
7791: PPUSH
7792: CALL_OW 69
7796: ST_TO_ADDR
// SetSide ( hunter , 6 ) ;
7797: LD_VAR 0 1
7801: PPUSH
7802: LD_INT 6
7804: PPUSH
7805: CALL_OW 235
// if IsInUnit ( hunter ) then
7809: LD_VAR 0 1
7813: PPUSH
7814: CALL_OW 310
7818: IFFALSE 7860
// begin if GetBType ( IsInUnit ( hunter ) = unit_vehicle ) then
7820: LD_VAR 0 1
7824: PPUSH
7825: CALL_OW 310
7829: PUSH
7830: LD_INT 2
7832: EQUAL
7833: PPUSH
7834: CALL_OW 266
7838: IFFALSE 7851
// ComExitVehicle ( hunter ) else
7840: LD_VAR 0 1
7844: PPUSH
7845: CALL_OW 121
7849: GO 7860
// ComExitBuilding ( hunter ) ;
7851: LD_VAR 0 1
7855: PPUSH
7856: CALL_OW 122
// end ; ComWalk ( hunter ) ;
7860: LD_VAR 0 1
7864: PPUSH
7865: CALL_OW 138
// wait ( 0 0$1 ) ;
7869: LD_INT 35
7871: PPUSH
7872: CALL_OW 67
// if not GetClass ( hunter ) = class_soldier and barracks then
7876: LD_VAR 0 1
7880: PPUSH
7881: CALL_OW 257
7885: PUSH
7886: LD_INT 1
7888: EQUAL
7889: NOT
7890: PUSH
7891: LD_VAR 0 4
7895: AND
7896: IFFALSE 8039
// begin barrackTarget = barracks [ 1 ] ;
7898: LD_ADDR_VAR 0 5
7902: PUSH
7903: LD_VAR 0 4
7907: PUSH
7908: LD_INT 1
7910: ARRAY
7911: ST_TO_ADDR
// barrackTargetCurrentHP = GetLives ( barrackTarget ) ;
7912: LD_ADDR_VAR 0 6
7916: PUSH
7917: LD_VAR 0 5
7921: PPUSH
7922: CALL_OW 256
7926: ST_TO_ADDR
// SetSide ( barrackTarget , 6 ) ;
7927: LD_VAR 0 5
7931: PPUSH
7932: LD_INT 6
7934: PPUSH
7935: CALL_OW 235
// ComEnterUnit ( hunter , barrackTarget ) ;
7939: LD_VAR 0 1
7943: PPUSH
7944: LD_VAR 0 5
7948: PPUSH
7949: CALL_OW 120
// repeat wait ( 0 0$1 ) ;
7953: LD_INT 35
7955: PPUSH
7956: CALL_OW 67
// ComEnterUnit ( hunter , barrackTarget ) ;
7960: LD_VAR 0 1
7964: PPUSH
7965: LD_VAR 0 5
7969: PPUSH
7970: CALL_OW 120
// SetLives ( barrackTarget , barrackTargetCurrentHP ) ;
7974: LD_VAR 0 5
7978: PPUSH
7979: LD_VAR 0 6
7983: PPUSH
7984: CALL_OW 234
// until IsInUnit ( hunter ) ;
7988: LD_VAR 0 1
7992: PPUSH
7993: CALL_OW 310
7997: IFFALSE 7953
// SetClass ( hunter , class_soldier ) ;
7999: LD_VAR 0 1
8003: PPUSH
8004: LD_INT 1
8006: PPUSH
8007: CALL_OW 336
// ComExitBuilding ( hunter ) ;
8011: LD_VAR 0 1
8015: PPUSH
8016: CALL_OW 122
// SetSide ( barrackTarget , 3 ) ;
8020: LD_VAR 0 5
8024: PPUSH
8025: LD_INT 3
8027: PPUSH
8028: CALL_OW 235
// wait ( 0 0$1 ) ;
8032: LD_INT 35
8034: PPUSH
8035: CALL_OW 67
// end ; for i := 1 to 3 do
8039: LD_ADDR_VAR 0 3
8043: PUSH
8044: DOUBLE
8045: LD_INT 1
8047: DEC
8048: ST_TO_ADDR
8049: LD_INT 3
8051: PUSH
8052: FOR_TO
8053: IFFALSE 8158
// begin uc_side = 0 ;
8055: LD_ADDR_OWVAR 20
8059: PUSH
8060: LD_INT 0
8062: ST_TO_ADDR
// uc_nation = nation_nature ;
8063: LD_ADDR_OWVAR 21
8067: PUSH
8068: LD_INT 0
8070: ST_TO_ADDR
// PrepareHuman ( false , [ class_phororhacos , class_tiger , 21 ] [ Rand ( 1 , 3 ) ] , 0 ) ;
8071: LD_INT 0
8073: PPUSH
8074: LD_INT 18
8076: PUSH
8077: LD_INT 14
8079: PUSH
8080: LD_INT 21
8082: PUSH
8083: EMPTY
8084: LIST
8085: LIST
8086: LIST
8087: PUSH
8088: LD_INT 1
8090: PPUSH
8091: LD_INT 3
8093: PPUSH
8094: CALL_OW 12
8098: ARRAY
8099: PPUSH
8100: LD_INT 0
8102: PPUSH
8103: CALL_OW 380
// hc_agressivity = 0 ;
8107: LD_ADDR_OWVAR 35
8111: PUSH
8112: LD_INT 0
8114: ST_TO_ADDR
// animal = CreateHuman ;
8115: LD_ADDR_VAR 0 8
8119: PUSH
8120: CALL_OW 44
8124: ST_TO_ADDR
// PlaceUnitArea ( animal , NatureArea , false ) ;
8125: LD_VAR 0 8
8129: PPUSH
8130: LD_INT 5
8132: PPUSH
8133: LD_INT 0
8135: PPUSH
8136: CALL_OW 49
// animals = animals ^ animal ;
8140: LD_ADDR_VAR 0 7
8144: PUSH
8145: LD_VAR 0 7
8149: PUSH
8150: LD_VAR 0 8
8154: ADD
8155: ST_TO_ADDR
// end ;
8156: GO 8052
8158: POP
8159: POP
// for i := 1 to animals do
8160: LD_ADDR_VAR 0 3
8164: PUSH
8165: DOUBLE
8166: LD_INT 1
8168: DEC
8169: ST_TO_ADDR
8170: LD_VAR 0 7
8174: PUSH
8175: FOR_TO
8176: IFFALSE 8200
// AddComAttackUnit ( hunter , animals [ i ] ) ;
8178: LD_VAR 0 1
8182: PPUSH
8183: LD_VAR 0 7
8187: PUSH
8188: LD_VAR 0 3
8192: ARRAY
8193: PPUSH
8194: CALL_OW 175
8198: GO 8175
8200: POP
8201: POP
// repeat wait ( 0 0$1 ) ;
8202: LD_INT 35
8204: PPUSH
8205: CALL_OW 67
// if GetClass ( hunter ) = class_soldier then
8209: LD_VAR 0 1
8213: PPUSH
8214: CALL_OW 257
8218: PUSH
8219: LD_INT 1
8221: EQUAL
8222: IFFALSE 8269
// begin if GetDistUnits ( hunter , WantsToAttack ( hunter ) ) < 13 then
8224: LD_VAR 0 1
8228: PPUSH
8229: LD_VAR 0 1
8233: PPUSH
8234: CALL_OW 319
8238: PPUSH
8239: CALL_OW 296
8243: PUSH
8244: LD_INT 13
8246: LESS
8247: IFFALSE 8260
// ComCrawl ( hunter ) else
8249: LD_VAR 0 1
8253: PPUSH
8254: CALL_OW 137
8258: GO 8269
// ComWalk ( hunter ) ;
8260: LD_VAR 0 1
8264: PPUSH
8265: CALL_OW 138
// end ; until not HasTask ( hunter ) ;
8269: LD_VAR 0 1
8273: PPUSH
8274: CALL_OW 314
8278: NOT
8279: IFFALSE 8202
// repeat wait ( 0 0$1 ) ;
8281: LD_INT 35
8283: PPUSH
8284: CALL_OW 67
// ComMoveXY ( hunter , GetX ( Burlak ) , GetY ( Burlak ) ) ;
8288: LD_VAR 0 1
8292: PPUSH
8293: LD_EXP 57
8297: PPUSH
8298: CALL_OW 250
8302: PPUSH
8303: LD_EXP 57
8307: PPUSH
8308: CALL_OW 251
8312: PPUSH
8313: CALL_OW 111
// until GetDistUnits ( hunter , Burlak ) <= 9 ;
8317: LD_VAR 0 1
8321: PPUSH
8322: LD_EXP 57
8326: PPUSH
8327: CALL_OW 296
8331: PUSH
8332: LD_INT 9
8334: LESSEQUAL
8335: IFFALSE 8281
// SetSide ( hunter , 3 ) ;
8337: LD_VAR 0 1
8341: PPUSH
8342: LD_INT 3
8344: PPUSH
8345: CALL_OW 235
// CenterOnUnits ( hunter ) ;
8349: LD_VAR 0 1
8353: PPUSH
8354: CALL_OW 85
// AddExperience ( hunter , skill_combat , 3000 ) ;
8358: LD_VAR 0 1
8362: PPUSH
8363: LD_INT 1
8365: PPUSH
8366: LD_INT 3000
8368: PPUSH
8369: CALL_OW 492
// end ;
8373: LD_VAR 0 2
8377: RET
// export function SetMashaData ( vehicle ) ; begin
8378: LD_INT 0
8380: PPUSH
// if Masha then
8381: LD_EXP 4
8385: IFFALSE 8403
// SetMark ( Masha [ 1 ] , 0 ) ;
8387: LD_EXP 4
8391: PUSH
8392: LD_INT 1
8394: ARRAY
8395: PPUSH
8396: LD_INT 0
8398: PPUSH
8399: CALL_OW 242
// Masha = [ vehicle , GetChassis ( vehicle ) , GetEngine ( vehicle ) , GetControl ( vehicle ) , GetWeapon ( vehicle ) ] ;
8403: LD_ADDR_EXP 4
8407: PUSH
8408: LD_VAR 0 1
8412: PUSH
8413: LD_VAR 0 1
8417: PPUSH
8418: CALL_OW 265
8422: PUSH
8423: LD_VAR 0 1
8427: PPUSH
8428: CALL_OW 262
8432: PUSH
8433: LD_VAR 0 1
8437: PPUSH
8438: CALL_OW 263
8442: PUSH
8443: LD_VAR 0 1
8447: PPUSH
8448: CALL_OW 264
8452: PUSH
8453: EMPTY
8454: LIST
8455: LIST
8456: LIST
8457: LIST
8458: LIST
8459: ST_TO_ADDR
// ChangeMissionObjectives ( MMashaDone ) ;
8460: LD_STRING MMashaDone
8462: PPUSH
8463: CALL_OW 337
// SetMark ( vehicle , 1 ) ;
8467: LD_VAR 0 1
8471: PPUSH
8472: LD_INT 1
8474: PPUSH
8475: CALL_OW 242
// end ;
8479: LD_VAR 0 2
8483: RET
// export function SaveBase ( buildings , ident ) ; var i , buildingsToSave ; begin
8484: LD_INT 0
8486: PPUSH
8487: PPUSH
8488: PPUSH
// buildingsToSave = [ ] ;
8489: LD_ADDR_VAR 0 5
8493: PUSH
8494: EMPTY
8495: ST_TO_ADDR
// if not buildings then
8496: LD_VAR 0 1
8500: NOT
8501: IFFALSE 8505
// exit ;
8503: GO 9080
// for i in buildings do
8505: LD_ADDR_VAR 0 4
8509: PUSH
8510: LD_VAR 0 1
8514: PUSH
8515: FOR_IN
8516: IFFALSE 9064
// begin if GetBType ( i ) in [ b_lab , b_lab_half , b_lab_full ] then
8518: LD_VAR 0 4
8522: PPUSH
8523: CALL_OW 266
8527: PUSH
8528: LD_INT 6
8530: PUSH
8531: LD_INT 7
8533: PUSH
8534: LD_INT 8
8536: PUSH
8537: EMPTY
8538: LIST
8539: LIST
8540: LIST
8541: IN
8542: IFFALSE 8667
// buildingsToSave = buildingsToSave ^ [ [ GetBType ( i ) , GetX ( i ) , GetY ( i ) , GetDir ( i ) , GetBLevel ( i ) , GetNation ( i ) , GetLives ( i ) , GetLabKind ( i , 1 ) , GetLabKind ( i , 2 ) ] ] else
8544: LD_ADDR_VAR 0 5
8548: PUSH
8549: LD_VAR 0 5
8553: PUSH
8554: LD_VAR 0 4
8558: PPUSH
8559: CALL_OW 266
8563: PUSH
8564: LD_VAR 0 4
8568: PPUSH
8569: CALL_OW 250
8573: PUSH
8574: LD_VAR 0 4
8578: PPUSH
8579: CALL_OW 251
8583: PUSH
8584: LD_VAR 0 4
8588: PPUSH
8589: CALL_OW 254
8593: PUSH
8594: LD_VAR 0 4
8598: PPUSH
8599: CALL_OW 267
8603: PUSH
8604: LD_VAR 0 4
8608: PPUSH
8609: CALL_OW 248
8613: PUSH
8614: LD_VAR 0 4
8618: PPUSH
8619: CALL_OW 256
8623: PUSH
8624: LD_VAR 0 4
8628: PPUSH
8629: LD_INT 1
8631: PPUSH
8632: CALL_OW 268
8636: PUSH
8637: LD_VAR 0 4
8641: PPUSH
8642: LD_INT 2
8644: PPUSH
8645: CALL_OW 268
8649: PUSH
8650: EMPTY
8651: LIST
8652: LIST
8653: LIST
8654: LIST
8655: LIST
8656: LIST
8657: LIST
8658: LIST
8659: LIST
8660: PUSH
8661: EMPTY
8662: LIST
8663: ADD
8664: ST_TO_ADDR
8665: GO 9062
// if GetBType ( i ) in [ b_bunker , b_turret ] then
8667: LD_VAR 0 4
8671: PPUSH
8672: CALL_OW 266
8676: PUSH
8677: LD_INT 32
8679: PUSH
8680: LD_INT 33
8682: PUSH
8683: EMPTY
8684: LIST
8685: LIST
8686: IN
8687: IFFALSE 8795
// buildingsToSave = buildingsToSave ^ [ [ GetBType ( i ) , GetX ( i ) , GetY ( i ) , GetDir ( i ) , GetBLevel ( i ) , GetNation ( i ) , GetLives ( i ) , GetBWeapon ( i ) ] ] else
8689: LD_ADDR_VAR 0 5
8693: PUSH
8694: LD_VAR 0 5
8698: PUSH
8699: LD_VAR 0 4
8703: PPUSH
8704: CALL_OW 266
8708: PUSH
8709: LD_VAR 0 4
8713: PPUSH
8714: CALL_OW 250
8718: PUSH
8719: LD_VAR 0 4
8723: PPUSH
8724: CALL_OW 251
8728: PUSH
8729: LD_VAR 0 4
8733: PPUSH
8734: CALL_OW 254
8738: PUSH
8739: LD_VAR 0 4
8743: PPUSH
8744: CALL_OW 267
8748: PUSH
8749: LD_VAR 0 4
8753: PPUSH
8754: CALL_OW 248
8758: PUSH
8759: LD_VAR 0 4
8763: PPUSH
8764: CALL_OW 256
8768: PUSH
8769: LD_VAR 0 4
8773: PPUSH
8774: CALL_OW 269
8778: PUSH
8779: EMPTY
8780: LIST
8781: LIST
8782: LIST
8783: LIST
8784: LIST
8785: LIST
8786: LIST
8787: LIST
8788: PUSH
8789: EMPTY
8790: LIST
8791: ADD
8792: ST_TO_ADDR
8793: GO 9062
// if GetBType ( i ) in [ b_depot , b_warehouse ] then
8795: LD_VAR 0 4
8799: PPUSH
8800: CALL_OW 266
8804: PUSH
8805: LD_INT 0
8807: PUSH
8808: LD_INT 1
8810: PUSH
8811: EMPTY
8812: LIST
8813: LIST
8814: IN
8815: IFFALSE 8969
// buildingsToSave = buildingsToSave ^ [ [ GetBType ( i ) , GetX ( i ) , GetY ( i ) , GetDir ( i ) , GetBLevel ( i ) , GetNation ( i ) , GetLives ( i ) , GetResourceType ( GetBase ( i ) , mat_cans ) , GetResourceType ( GetBase ( i ) , mat_oil ) , GetResourceType ( GetBase ( i ) , mat_siberit ) ] ] else
8817: LD_ADDR_VAR 0 5
8821: PUSH
8822: LD_VAR 0 5
8826: PUSH
8827: LD_VAR 0 4
8831: PPUSH
8832: CALL_OW 266
8836: PUSH
8837: LD_VAR 0 4
8841: PPUSH
8842: CALL_OW 250
8846: PUSH
8847: LD_VAR 0 4
8851: PPUSH
8852: CALL_OW 251
8856: PUSH
8857: LD_VAR 0 4
8861: PPUSH
8862: CALL_OW 254
8866: PUSH
8867: LD_VAR 0 4
8871: PPUSH
8872: CALL_OW 267
8876: PUSH
8877: LD_VAR 0 4
8881: PPUSH
8882: CALL_OW 248
8886: PUSH
8887: LD_VAR 0 4
8891: PPUSH
8892: CALL_OW 256
8896: PUSH
8897: LD_VAR 0 4
8901: PPUSH
8902: CALL_OW 274
8906: PPUSH
8907: LD_INT 1
8909: PPUSH
8910: CALL_OW 275
8914: PUSH
8915: LD_VAR 0 4
8919: PPUSH
8920: CALL_OW 274
8924: PPUSH
8925: LD_INT 2
8927: PPUSH
8928: CALL_OW 275
8932: PUSH
8933: LD_VAR 0 4
8937: PPUSH
8938: CALL_OW 274
8942: PPUSH
8943: LD_INT 3
8945: PPUSH
8946: CALL_OW 275
8950: PUSH
8951: EMPTY
8952: LIST
8953: LIST
8954: LIST
8955: LIST
8956: LIST
8957: LIST
8958: LIST
8959: LIST
8960: LIST
8961: LIST
8962: PUSH
8963: EMPTY
8964: LIST
8965: ADD
8966: ST_TO_ADDR
8967: GO 9062
// buildingsToSave = buildingsToSave ^ [ [ GetBType ( i ) , GetX ( i ) , GetY ( i ) , GetDir ( i ) , GetBLevel ( i ) , GetNation ( i ) , GetLives ( i ) ] ] ;
8969: LD_ADDR_VAR 0 5
8973: PUSH
8974: LD_VAR 0 5
8978: PUSH
8979: LD_VAR 0 4
8983: PPUSH
8984: CALL_OW 266
8988: PUSH
8989: LD_VAR 0 4
8993: PPUSH
8994: CALL_OW 250
8998: PUSH
8999: LD_VAR 0 4
9003: PPUSH
9004: CALL_OW 251
9008: PUSH
9009: LD_VAR 0 4
9013: PPUSH
9014: CALL_OW 254
9018: PUSH
9019: LD_VAR 0 4
9023: PPUSH
9024: CALL_OW 267
9028: PUSH
9029: LD_VAR 0 4
9033: PPUSH
9034: CALL_OW 248
9038: PUSH
9039: LD_VAR 0 4
9043: PPUSH
9044: CALL_OW 256
9048: PUSH
9049: EMPTY
9050: LIST
9051: LIST
9052: LIST
9053: LIST
9054: LIST
9055: LIST
9056: LIST
9057: PUSH
9058: EMPTY
9059: LIST
9060: ADD
9061: ST_TO_ADDR
// end ;
9062: GO 8515
9064: POP
9065: POP
// SaveVariable ( buildingsToSave , ident ) ;
9066: LD_VAR 0 5
9070: PPUSH
9071: LD_VAR 0 2
9075: PPUSH
9076: CALL_OW 39
// end ; end_of_file
9080: LD_VAR 0 3
9084: RET
// export function MissionIntro ; begin
9085: LD_INT 0
9087: PPUSH
// CenterNowOnUnits ( Burlak ) ;
9088: LD_EXP 57
9092: PPUSH
9093: CALL_OW 87
// DialogueOn ;
9097: CALL_OW 6
// SayRadio ( Popov , DStart-Pop-1 ) ;
9101: LD_EXP 76
9105: PPUSH
9106: LD_STRING DStart-Pop-1
9108: PPUSH
9109: CALL_OW 94
// Say ( Burlak , DStart-Bur-1 ) ;
9113: LD_EXP 57
9117: PPUSH
9118: LD_STRING DStart-Bur-1
9120: PPUSH
9121: CALL_OW 88
// DialogueOff ;
9125: CALL_OW 7
// IngameOff ;
9129: CALL_OW 9
// ChangeMissionObjectives ( MStart ) ;
9133: LD_STRING MStart
9135: PPUSH
9136: CALL_OW 337
// SaveForQuickRestart ;
9140: CALL_OW 22
// end ;
9144: LD_VAR 0 1
9148: RET
// export function Dial_EscortHeike ( x , y ) ; begin
9149: LD_INT 0
9151: PPUSH
// dial_BuildDepotBlocker = true ;
9152: LD_ADDR_EXP 5
9156: PUSH
9157: LD_INT 1
9159: ST_TO_ADDR
// HeikeTargetX = x ;
9160: LD_ADDR_EXP 14
9164: PUSH
9165: LD_VAR 0 1
9169: ST_TO_ADDR
// HeikeTargetY = y ;
9170: LD_ADDR_EXP 15
9174: PUSH
9175: LD_VAR 0 2
9179: ST_TO_ADDR
// SayRadio ( Popov , DHeike-Pop-1 ) ;
9180: LD_EXP 76
9184: PPUSH
9185: LD_STRING DHeike-Pop-1
9187: PPUSH
9188: CALL_OW 94
// wait ( 0 0$10 ) ;
9192: LD_INT 350
9194: PPUSH
9195: CALL_OW 67
// PrepareRussianEscort ;
9199: CALL 2320 0 0
// PlaceUnitArea ( Heike , RussianSpawn2Area , false ) ;
9203: LD_EXP 79
9207: PPUSH
9208: LD_INT 7
9210: PPUSH
9211: LD_INT 0
9213: PPUSH
9214: CALL_OW 49
// ComMoveXY ( russianEscort , HeikeTargetX , HeikeTargetY ) ;
9218: LD_EXP 77
9222: PPUSH
9223: LD_EXP 14
9227: PPUSH
9228: LD_EXP 15
9232: PPUSH
9233: CALL_OW 111
// AddComMoveToArea ( russianEscort , RussianSpawn2Area ) ;
9237: LD_EXP 77
9241: PPUSH
9242: LD_INT 7
9244: PPUSH
9245: CALL_OW 173
// ComMoveXY ( Heike , HeikeTargetX , HeikeTargetY ) ;
9249: LD_EXP 79
9253: PPUSH
9254: LD_EXP 14
9258: PPUSH
9259: LD_EXP 15
9263: PPUSH
9264: CALL_OW 111
// AddComHold ( Heike ) ;
9268: LD_EXP 79
9272: PPUSH
9273: CALL_OW 200
// end ;
9277: LD_VAR 0 3
9281: RET
// every 1 trigger GetDistUnitXY ( Heike , HeikeTargetX , HeikeTargetY ) <= 5 do
9282: LD_EXP 79
9286: PPUSH
9287: LD_EXP 14
9291: PPUSH
9292: LD_EXP 15
9296: PPUSH
9297: CALL_OW 297
9301: PUSH
9302: LD_INT 5
9304: LESSEQUAL
9305: IFFALSE 9318
9307: GO 9309
9309: DISABLE
// allowExitFromMap = 1 ;
9310: LD_ADDR_EXP 18
9314: PUSH
9315: LD_INT 1
9317: ST_TO_ADDR
9318: END
// every 7 7$0 trigger IsPlaced ( Heike ) and IsOk ( Heike ) and GetAttitude ( 3 , 5 ) = att_friend and HeikeCaptured do
9319: LD_EXP 79
9323: PPUSH
9324: CALL_OW 305
9328: PUSH
9329: LD_EXP 79
9333: PPUSH
9334: CALL_OW 302
9338: AND
9339: PUSH
9340: LD_INT 3
9342: PPUSH
9343: LD_INT 5
9345: PPUSH
9346: CALL_OW 81
9350: PUSH
9351: LD_INT 1
9353: EQUAL
9354: AND
9355: PUSH
9356: LD_EXP 1
9360: AND
9361: IFFALSE 9580
9363: GO 9365
9365: DISABLE
// begin DialogueOn ;
9366: CALL_OW 6
// SayRadio ( Kurt , DMercHelp-Kurt-1 ) ;
9370: LD_EXP 80
9374: PPUSH
9375: LD_STRING DMercHelp-Kurt-1
9377: PPUSH
9378: CALL_OW 94
// Say ( Burlak , DMercHelp-Bur-1 ) ;
9382: LD_EXP 57
9386: PPUSH
9387: LD_STRING DMercHelp-Bur-1
9389: PPUSH
9390: CALL_OW 88
// SayRadio ( Kurt , DMercHelp-Kurt-2 ) ;
9394: LD_EXP 80
9398: PPUSH
9399: LD_STRING DMercHelp-Kurt-2
9401: PPUSH
9402: CALL_OW 94
// Say ( Burlak , DMercHelp-Bur-2 ) ;
9406: LD_EXP 57
9410: PPUSH
9411: LD_STRING DMercHelp-Bur-2
9413: PPUSH
9414: CALL_OW 88
// SayRadio ( Kurt , DMercHelp-Kurt-3 ) ;
9418: LD_EXP 80
9422: PPUSH
9423: LD_STRING DMercHelp-Kurt-3
9425: PPUSH
9426: CALL_OW 94
// case Query ( QMerc ) of 1 :
9430: LD_STRING QMerc
9432: PPUSH
9433: CALL_OW 97
9437: PUSH
9438: LD_INT 1
9440: DOUBLE
9441: EQUAL
9442: IFTRUE 9446
9444: GO 9481
9446: POP
// begin Say ( Burlak , DQrMerc#1-Bur-1 ) ;
9447: LD_EXP 57
9451: PPUSH
9452: LD_STRING DQrMerc#1-Bur-1
9454: PPUSH
9455: CALL_OW 88
// SayRadio ( Kurt , DQrMerc#1-Kurt-1 ) ;
9459: LD_EXP 80
9463: PPUSH
9464: LD_STRING DQrMerc#1-Kurt-1
9466: PPUSH
9467: CALL_OW 94
// acceptKurtOffert = true ;
9471: LD_ADDR_EXP 19
9475: PUSH
9476: LD_INT 1
9478: ST_TO_ADDR
// end ; 2 :
9479: GO 9576
9481: LD_INT 2
9483: DOUBLE
9484: EQUAL
9485: IFTRUE 9489
9487: GO 9544
9489: POP
// begin askCommanders = true ;
9490: LD_ADDR_EXP 20
9494: PUSH
9495: LD_INT 1
9497: ST_TO_ADDR
// Say ( Burlak , DQrMerc#2-Bur-1 ) ;
9498: LD_EXP 57
9502: PPUSH
9503: LD_STRING DQrMerc#2-Bur-1
9505: PPUSH
9506: CALL_OW 88
// SayRadio ( Popov , DQrMerc#2-Pop-1 ) ;
9510: LD_EXP 76
9514: PPUSH
9515: LD_STRING DQrMerc#2-Pop-1
9517: PPUSH
9518: CALL_OW 94
// Say ( Burlak , DQrMerc#2-Bur-2 ) ;
9522: LD_EXP 57
9526: PPUSH
9527: LD_STRING DQrMerc#2-Bur-2
9529: PPUSH
9530: CALL_OW 88
// acceptKurtOffert = true ;
9534: LD_ADDR_EXP 19
9538: PUSH
9539: LD_INT 1
9541: ST_TO_ADDR
// end ; 3 :
9542: GO 9576
9544: LD_INT 3
9546: DOUBLE
9547: EQUAL
9548: IFTRUE 9552
9550: GO 9575
9552: POP
// begin Say ( Burlak , DQrMerc#3-Bur-1 ) ;
9553: LD_EXP 57
9557: PPUSH
9558: LD_STRING DQrMerc#3-Bur-1
9560: PPUSH
9561: CALL_OW 88
// KurtAttack = true ;
9565: LD_ADDR_EXP 25
9569: PUSH
9570: LD_INT 1
9572: ST_TO_ADDR
// end ; end ;
9573: GO 9576
9575: POP
// DialogueOff ;
9576: CALL_OW 7
// end ;
9580: END
// every 0 0$1 trigger acceptKurtOffert do
9581: LD_EXP 19
9585: IFFALSE 9741
9587: GO 9589
9589: DISABLE
// begin PlaceUnitArea ( Kurt , KurtSpawnArea , false ) ;
9590: LD_EXP 80
9594: PPUSH
9595: LD_INT 9
9597: PPUSH
9598: LD_INT 0
9600: PPUSH
9601: CALL_OW 49
// uc_side = 8 ;
9605: LD_ADDR_OWVAR 20
9609: PUSH
9610: LD_INT 8
9612: ST_TO_ADDR
// uc_nation = 2 ;
9613: LD_ADDR_OWVAR 21
9617: PUSH
9618: LD_INT 2
9620: ST_TO_ADDR
// PrepareEngineer ( false , 3 ) ;
9621: LD_INT 0
9623: PPUSH
9624: LD_INT 3
9626: PPUSH
9627: CALL_OW 382
// KurtEng = CreateHuman ;
9631: LD_ADDR_EXP 82
9635: PUSH
9636: CALL_OW 44
9640: ST_TO_ADDR
// PlaceUnitArea ( KurtEng , KurtSpawnArea , false ) ;
9641: LD_EXP 82
9645: PPUSH
9646: LD_INT 9
9648: PPUSH
9649: LD_INT 0
9651: PPUSH
9652: CALL_OW 49
// repeat wait ( 0 0$1 ) ;
9656: LD_INT 35
9658: PPUSH
9659: CALL_OW 67
// ComMoveXY ( [ Kurt , KurtEng ] , GetX ( Burlak ) , GetY ( Burlak ) ) ;
9663: LD_EXP 80
9667: PUSH
9668: LD_EXP 82
9672: PUSH
9673: EMPTY
9674: LIST
9675: LIST
9676: PPUSH
9677: LD_EXP 57
9681: PPUSH
9682: CALL_OW 250
9686: PPUSH
9687: LD_EXP 57
9691: PPUSH
9692: CALL_OW 251
9696: PPUSH
9697: CALL_OW 111
// until GetDistUnits ( Kurt , Burlak ) <= 5 or GetDistUnits ( KurtEng , Burlak ) <= 5 ;
9701: LD_EXP 80
9705: PPUSH
9706: LD_EXP 57
9710: PPUSH
9711: CALL_OW 296
9715: PUSH
9716: LD_INT 5
9718: LESSEQUAL
9719: PUSH
9720: LD_EXP 82
9724: PPUSH
9725: LD_EXP 57
9729: PPUSH
9730: CALL_OW 296
9734: PUSH
9735: LD_INT 5
9737: LESSEQUAL
9738: OR
9739: IFFALSE 9656
// end ;
9741: END
// every 0 0$1 trigger GetDistUnits ( Kurt , Burlak ) <= 5 or GetDistUnits ( KurtEng , Burlak ) <= 5 do
9742: LD_EXP 80
9746: PPUSH
9747: LD_EXP 57
9751: PPUSH
9752: CALL_OW 296
9756: PUSH
9757: LD_INT 5
9759: LESSEQUAL
9760: PUSH
9761: LD_EXP 82
9765: PPUSH
9766: LD_EXP 57
9770: PPUSH
9771: CALL_OW 296
9775: PUSH
9776: LD_INT 5
9778: LESSEQUAL
9779: OR
9780: IFFALSE 9959
9782: GO 9784
9784: DISABLE
// begin KurtWaitingForBuildBarrack = true ;
9785: LD_ADDR_EXP 24
9789: PUSH
9790: LD_INT 1
9792: ST_TO_ADDR
// SetSide ( KurtEng , 3 ) ;
9793: LD_EXP 82
9797: PPUSH
9798: LD_INT 3
9800: PPUSH
9801: CALL_OW 235
// wait ( 1 1$30 ) ;
9805: LD_INT 3150
9807: PPUSH
9808: CALL_OW 67
// DialogueOn ;
9812: CALL_OW 6
// SayRadio ( Dietrich , DArabianRequest-Diet-1 ) ;
9816: LD_EXP 81
9820: PPUSH
9821: LD_STRING DArabianRequest-Diet-1
9823: PPUSH
9824: CALL_OW 94
// Say ( Burlak , DArabianRequest-Bur-1 ) ;
9828: LD_EXP 57
9832: PPUSH
9833: LD_STRING DArabianRequest-Bur-1
9835: PPUSH
9836: CALL_OW 88
// SayRadio ( Dietrich , DArabianRequest-Diet-2 ) ;
9840: LD_EXP 81
9844: PPUSH
9845: LD_STRING DArabianRequest-Diet-2
9847: PPUSH
9848: CALL_OW 94
// DialogueOff ;
9852: CALL_OW 7
// case Query ( QHandOver ) of 1 :
9856: LD_STRING QHandOver
9858: PPUSH
9859: CALL_OW 97
9863: PUSH
9864: LD_INT 1
9866: DOUBLE
9867: EQUAL
9868: IFTRUE 9872
9870: GO 9911
9872: POP
// begin Say ( Burlak , DQrHandOver#1-Bur-1 ) ;
9873: LD_EXP 57
9877: PPUSH
9878: LD_STRING DQrHandOver#1-Bur-1
9880: PPUSH
9881: CALL_OW 88
// SayRadio ( Dietrich , DQrHandOver#1-Diet-1 ) ;
9885: LD_EXP 81
9889: PPUSH
9890: LD_STRING DQrHandOver#1-Diet-1
9892: PPUSH
9893: CALL_OW 94
// coopWithGensher = true ;
9897: LD_ADDR_EXP 2
9901: PUSH
9902: LD_INT 1
9904: ST_TO_ADDR
// SpawnGensherTeam ;
9905: CALL 3946 0 0
// end ; 2 :
9909: GO 9959
9911: LD_INT 2
9913: DOUBLE
9914: EQUAL
9915: IFTRUE 9919
9917: GO 9958
9919: POP
// begin Say ( Burlak , DQrHandOver#2-Bur-1 ) ;
9920: LD_EXP 57
9924: PPUSH
9925: LD_STRING DQrHandOver#2-Bur-1
9927: PPUSH
9928: CALL_OW 88
// SayRadio ( Dietrich , DQrHandOver#2-Diet-1 ) ;
9932: LD_EXP 81
9936: PPUSH
9937: LD_STRING DQrHandOver#2-Diet-1
9939: PPUSH
9940: CALL_OW 94
// Say ( Burlak , DQrHandOver#2-Bur-2 ) ;
9944: LD_EXP 57
9948: PPUSH
9949: LD_STRING DQrHandOver#2-Bur-2
9951: PPUSH
9952: CALL_OW 88
// end ; end ;
9956: GO 9959
9958: POP
// end ;
9959: END
// export function Dial_UpgradeArmoury ; begin
9960: LD_INT 0
9962: PPUSH
// dial_BuildArBarrackBlocker = true ;
9963: LD_ADDR_EXP 6
9967: PUSH
9968: LD_INT 1
9970: ST_TO_ADDR
// buildArabBarrack = true ;
9971: LD_ADDR_EXP 38
9975: PUSH
9976: LD_INT 1
9978: ST_TO_ADDR
// if GetSide ( Kurt ) = 2 or GetSide ( KurtEng ) = 8 then
9979: LD_EXP 80
9983: PPUSH
9984: CALL_OW 255
9988: PUSH
9989: LD_INT 2
9991: EQUAL
9992: PUSH
9993: LD_EXP 82
9997: PPUSH
9998: CALL_OW 255
10002: PUSH
10003: LD_INT 8
10005: EQUAL
10006: OR
10007: IFFALSE 10011
// exit ;
10009: GO 10111
// SetSide ( KurtEng , 8 ) ;
10011: LD_EXP 82
10015: PPUSH
10016: LD_INT 8
10018: PPUSH
10019: CALL_OW 235
// ComStop ( KurtEng ) ;
10023: LD_EXP 82
10027: PPUSH
10028: CALL_OW 141
// DialogueOn ;
10032: CALL_OW 6
// Say ( Kurt , DMercCompleted-Kurt-1 ) ;
10036: LD_EXP 80
10040: PPUSH
10041: LD_STRING DMercCompleted-Kurt-1
10043: PPUSH
10044: CALL_OW 88
// DialogueOff ;
10048: CALL_OW 7
// canSendHeike = true ;
10052: LD_ADDR_EXP 28
10056: PUSH
10057: LD_INT 1
10059: ST_TO_ADDR
// KurtWaitingForFreeHeike = true ;
10060: LD_ADDR_EXP 23
10064: PUSH
10065: LD_INT 1
10067: ST_TO_ADDR
// KurtWaitingForBuildBarrack = false ;
10068: LD_ADDR_EXP 24
10072: PUSH
10073: LD_INT 0
10075: ST_TO_ADDR
// allowExitFromMap = 3 ;
10076: LD_ADDR_EXP 18
10080: PUSH
10081: LD_INT 3
10083: ST_TO_ADDR
// if KurtCanEscape then
10084: LD_EXP 21
10088: IFFALSE 10111
// ComMoveToArea ( [ Kurt , KurtEng ] , KurtExitMapArea ) ;
10090: LD_EXP 80
10094: PUSH
10095: LD_EXP 82
10099: PUSH
10100: EMPTY
10101: LIST
10102: LIST
10103: PPUSH
10104: LD_INT 11
10106: PPUSH
10107: CALL_OW 113
// end ;
10111: LD_VAR 0 1
10115: RET
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 2 ] ] ) and not dial_ArriveGensherUnitsBlocker do var veh , nearGensherUnit , maleSold , waitForKurt ;
10116: LD_INT 22
10118: PUSH
10119: LD_INT 2
10121: PUSH
10122: EMPTY
10123: LIST
10124: LIST
10125: PUSH
10126: EMPTY
10127: LIST
10128: PPUSH
10129: CALL_OW 69
10133: PUSH
10134: LD_EXP 7
10138: NOT
10139: AND
10140: IFFALSE 10913
10142: GO 10144
10144: DISABLE
10145: LD_INT 0
10147: PPUSH
10148: PPUSH
10149: PPUSH
10150: PPUSH
// begin nearGensherUnit = NearestUnitToXY ( UnitFilter ( GensherTeam , [ [ f_type , unit_vehicle ] ] ) , GensherTargetX , GensherTargetY ) ;
10151: LD_ADDR_VAR 0 2
10155: PUSH
10156: LD_EXP 83
10160: PPUSH
10161: LD_INT 21
10163: PUSH
10164: LD_INT 2
10166: PUSH
10167: EMPTY
10168: LIST
10169: LIST
10170: PUSH
10171: EMPTY
10172: LIST
10173: PPUSH
10174: CALL_OW 72
10178: PPUSH
10179: LD_EXP 16
10183: PPUSH
10184: LD_EXP 17
10188: PPUSH
10189: CALL_OW 73
10193: ST_TO_ADDR
// maleSold = UnitsInside ( nearGensherUnit [ 1 ] ) ;
10194: LD_ADDR_VAR 0 3
10198: PUSH
10199: LD_VAR 0 2
10203: PUSH
10204: LD_INT 1
10206: ARRAY
10207: PPUSH
10208: CALL_OW 313
10212: ST_TO_ADDR
// if GetDistUnitXY ( nearGensherUnit , GensherTargetX , GensherTargetY ) <= 5 then
10213: LD_VAR 0 2
10217: PPUSH
10218: LD_EXP 16
10222: PPUSH
10223: LD_EXP 17
10227: PPUSH
10228: CALL_OW 297
10232: PUSH
10233: LD_INT 5
10235: LESSEQUAL
10236: IFFALSE 10912
// begin dial_ArriveGensherUnitsBlocker = true ;
10238: LD_ADDR_EXP 7
10242: PUSH
10243: LD_INT 1
10245: ST_TO_ADDR
// for veh in UnitFilter ( GensherTeam , [ [ f_type , unit_vehicle ] ] ) do
10246: LD_ADDR_VAR 0 1
10250: PUSH
10251: LD_EXP 83
10255: PPUSH
10256: LD_INT 21
10258: PUSH
10259: LD_INT 2
10261: PUSH
10262: EMPTY
10263: LIST
10264: LIST
10265: PUSH
10266: EMPTY
10267: LIST
10268: PPUSH
10269: CALL_OW 72
10273: PUSH
10274: FOR_IN
10275: IFFALSE 10297
// ComExitVehicle ( UnitsInside ( veh ) [ 1 ] ) ;
10277: LD_VAR 0 1
10281: PPUSH
10282: CALL_OW 313
10286: PUSH
10287: LD_INT 1
10289: ARRAY
10290: PPUSH
10291: CALL_OW 121
10295: GO 10274
10297: POP
10298: POP
// wait ( 0 0$1 ) ;
10299: LD_INT 35
10301: PPUSH
10302: CALL_OW 67
// SetSide ( UnitFilter ( GensherTeam , [ [ f_type , unit_vehicle ] ] ) , 3 ) ;
10306: LD_EXP 83
10310: PPUSH
10311: LD_INT 21
10313: PUSH
10314: LD_INT 2
10316: PUSH
10317: EMPTY
10318: LIST
10319: LIST
10320: PUSH
10321: EMPTY
10322: LIST
10323: PPUSH
10324: CALL_OW 72
10328: PPUSH
10329: LD_INT 3
10331: PPUSH
10332: CALL_OW 235
// CenterOnUnits ( maleSold ) ;
10336: LD_VAR 0 3
10340: PPUSH
10341: CALL_OW 85
// DialogueOn ;
10345: CALL_OW 6
// Say ( maleSold , DHandOverCome-ASol1-1 ) ;
10349: LD_VAR 0 3
10353: PPUSH
10354: LD_STRING DHandOverCome-ASol1-1
10356: PPUSH
10357: CALL_OW 88
// Say ( Kurt , DHandOverCome-Kurt-1 ) ;
10361: LD_EXP 80
10365: PPUSH
10366: LD_STRING DHandOverCome-Kurt-1
10368: PPUSH
10369: CALL_OW 88
// DialogueOff ;
10373: CALL_OW 7
// KurtWaitingForBuildBarrack = false ;
10377: LD_ADDR_EXP 24
10381: PUSH
10382: LD_INT 0
10384: ST_TO_ADDR
// if GetDistUnits ( Kurt , UnitFilter ( GensherTeam , [ f_type , unit_vehicle ] ) [ 1 ] ) <= 8 or GetSide ( KurtEng ) = 3 then
10385: LD_EXP 80
10389: PPUSH
10390: LD_EXP 83
10394: PPUSH
10395: LD_INT 21
10397: PUSH
10398: LD_INT 2
10400: PUSH
10401: EMPTY
10402: LIST
10403: LIST
10404: PPUSH
10405: CALL_OW 72
10409: PUSH
10410: LD_INT 1
10412: ARRAY
10413: PPUSH
10414: CALL_OW 296
10418: PUSH
10419: LD_INT 8
10421: LESSEQUAL
10422: PUSH
10423: LD_EXP 82
10427: PPUSH
10428: CALL_OW 255
10432: PUSH
10433: LD_INT 3
10435: EQUAL
10436: OR
10437: IFFALSE 10542
// begin KurtCanEscape = false ;
10439: LD_ADDR_EXP 21
10443: PUSH
10444: LD_INT 0
10446: ST_TO_ADDR
// SetSide ( [ Kurt , KurtEng ] , 2 ) ;
10447: LD_EXP 80
10451: PUSH
10452: LD_EXP 82
10456: PUSH
10457: EMPTY
10458: LIST
10459: LIST
10460: PPUSH
10461: LD_INT 2
10463: PPUSH
10464: CALL_OW 235
// ComStop ( [ Kurt , KurtEng ] ) ;
10468: LD_EXP 80
10472: PUSH
10473: LD_EXP 82
10477: PUSH
10478: EMPTY
10479: LIST
10480: LIST
10481: PPUSH
10482: CALL_OW 141
// ComMoveXY ( [ Kurt , KurtEng ] , GetX ( maleSold ) , GetY ( maleSold ) ) ;
10486: LD_EXP 80
10490: PUSH
10491: LD_EXP 82
10495: PUSH
10496: EMPTY
10497: LIST
10498: LIST
10499: PPUSH
10500: LD_VAR 0 3
10504: PPUSH
10505: CALL_OW 250
10509: PPUSH
10510: LD_VAR 0 3
10514: PPUSH
10515: CALL_OW 251
10519: PPUSH
10520: CALL_OW 111
// waitForKurt = true ;
10524: LD_ADDR_VAR 0 4
10528: PUSH
10529: LD_INT 1
10531: ST_TO_ADDR
// KurtStatus = 3 ;
10532: LD_ADDR_EXP 22
10536: PUSH
10537: LD_INT 3
10539: ST_TO_ADDR
// end else
10540: GO 10780
// if GetDistUnits ( Kurt , UnitFilter ( GensherTeam , [ f_type , unit_vehicle ] ) [ 1 ] ) > 8 then
10542: LD_EXP 80
10546: PPUSH
10547: LD_EXP 83
10551: PPUSH
10552: LD_INT 21
10554: PUSH
10555: LD_INT 2
10557: PUSH
10558: EMPTY
10559: LIST
10560: LIST
10561: PPUSH
10562: CALL_OW 72
10566: PUSH
10567: LD_INT 1
10569: ARRAY
10570: PPUSH
10571: CALL_OW 296
10575: PUSH
10576: LD_INT 8
10578: GREATER
10579: IFFALSE 10780
// begin allowExitFromMap = 4 ;
10581: LD_ADDR_EXP 18
10585: PUSH
10586: LD_INT 4
10588: ST_TO_ADDR
// KurtStatus = 2 ;
10589: LD_ADDR_EXP 22
10593: PUSH
10594: LD_INT 2
10596: ST_TO_ADDR
// ComMoveToArea ( [ Kurt , KurtEng ] , KurtExitMapArea ) ;
10597: LD_EXP 80
10601: PUSH
10602: LD_EXP 82
10606: PUSH
10607: EMPTY
10608: LIST
10609: LIST
10610: PPUSH
10611: LD_INT 11
10613: PPUSH
10614: CALL_OW 113
// repeat ComAttackUnit ( UnitFilter ( GensherTeam , [ [ f_type , unit_human ] ] ) , Kurt ) ;
10618: LD_EXP 83
10622: PPUSH
10623: LD_INT 21
10625: PUSH
10626: LD_INT 1
10628: PUSH
10629: EMPTY
10630: LIST
10631: LIST
10632: PUSH
10633: EMPTY
10634: LIST
10635: PPUSH
10636: CALL_OW 72
10640: PPUSH
10641: LD_EXP 80
10645: PPUSH
10646: CALL_OW 115
// wait ( 0 0$1 ) ;
10650: LD_INT 35
10652: PPUSH
10653: CALL_OW 67
// until GetDistUnits ( NearestUnitToUnit ( UnitFilter ( GensherTeam , [ [ f_type , unit_human ] ] ) , Kurt ) , Kurt ) <= 9 or ( not IsPlaced ( Kurt ) and not IsPlaced ( KurtEng ) ) ;
10657: LD_EXP 83
10661: PPUSH
10662: LD_INT 21
10664: PUSH
10665: LD_INT 1
10667: PUSH
10668: EMPTY
10669: LIST
10670: LIST
10671: PUSH
10672: EMPTY
10673: LIST
10674: PPUSH
10675: CALL_OW 72
10679: PPUSH
10680: LD_EXP 80
10684: PPUSH
10685: CALL_OW 74
10689: PPUSH
10690: LD_EXP 80
10694: PPUSH
10695: CALL_OW 296
10699: PUSH
10700: LD_INT 9
10702: LESSEQUAL
10703: PUSH
10704: LD_EXP 80
10708: PPUSH
10709: CALL_OW 305
10713: NOT
10714: PUSH
10715: LD_EXP 82
10719: PPUSH
10720: CALL_OW 305
10724: NOT
10725: AND
10726: OR
10727: IFFALSE 10618
// ComMoveToArea ( [ Kurt , KurtEng ] , ExitMapArea ) ;
10729: LD_EXP 80
10733: PUSH
10734: LD_EXP 82
10738: PUSH
10739: EMPTY
10740: LIST
10741: LIST
10742: PPUSH
10743: LD_INT 8
10745: PPUSH
10746: CALL_OW 113
// ComMoveToArea ( UnitFilter ( GensherTeam , [ [ f_type , unit_human ] ] ) , ExitMapArea ) ;
10750: LD_EXP 83
10754: PPUSH
10755: LD_INT 21
10757: PUSH
10758: LD_INT 1
10760: PUSH
10761: EMPTY
10762: LIST
10763: LIST
10764: PUSH
10765: EMPTY
10766: LIST
10767: PPUSH
10768: CALL_OW 72
10772: PPUSH
10773: LD_INT 8
10775: PPUSH
10776: CALL_OW 113
// end ; if waitForKurt then
10780: LD_VAR 0 4
10784: IFFALSE 10910
// begin repeat wait ( 0 0$1 ) ;
10786: LD_INT 35
10788: PPUSH
10789: CALL_OW 67
// ComMoveXY ( [ Kurt , KurtEng ] , GetX ( maleSold ) , GetY ( maleSold ) ) ;
10793: LD_EXP 80
10797: PUSH
10798: LD_EXP 82
10802: PUSH
10803: EMPTY
10804: LIST
10805: LIST
10806: PPUSH
10807: LD_VAR 0 3
10811: PPUSH
10812: CALL_OW 250
10816: PPUSH
10817: LD_VAR 0 3
10821: PPUSH
10822: CALL_OW 251
10826: PPUSH
10827: CALL_OW 111
// until GetDistUnits ( Kurt , maleSold ) <= 2 ;
10831: LD_EXP 80
10835: PPUSH
10836: LD_VAR 0 3
10840: PPUSH
10841: CALL_OW 296
10845: PUSH
10846: LD_INT 2
10848: LESSEQUAL
10849: IFFALSE 10786
// allowExitFromMap = 4 ;
10851: LD_ADDR_EXP 18
10855: PUSH
10856: LD_INT 4
10858: ST_TO_ADDR
// ComMoveToArea ( [ Kurt , KurtEng ] , ExitMapArea ) ;
10859: LD_EXP 80
10863: PUSH
10864: LD_EXP 82
10868: PUSH
10869: EMPTY
10870: LIST
10871: LIST
10872: PPUSH
10873: LD_INT 8
10875: PPUSH
10876: CALL_OW 113
// ComMoveToArea ( UnitFilter ( GensherTeam , [ [ f_type , unit_human ] ] ) , ExitMapArea ) ;
10880: LD_EXP 83
10884: PPUSH
10885: LD_INT 21
10887: PUSH
10888: LD_INT 1
10890: PUSH
10891: EMPTY
10892: LIST
10893: LIST
10894: PUSH
10895: EMPTY
10896: LIST
10897: PPUSH
10898: CALL_OW 72
10902: PPUSH
10903: LD_INT 8
10905: PPUSH
10906: CALL_OW 113
// end ; exit ;
10910: GO 10913
// end ; enable ;
10912: ENABLE
// end ;
10913: PPOPN 4
10915: END
// export function Dial_AttackGensher ; var unit ; begin
10916: LD_INT 0
10918: PPUSH
10919: PPUSH
// DialogueOn ;
10920: CALL_OW 6
// SayRadio ( Dietrich , DHandOverSpoiled-Diet-1 ) ;
10924: LD_EXP 81
10928: PPUSH
10929: LD_STRING DHandOverSpoiled-Diet-1
10931: PPUSH
10932: CALL_OW 94
// DialogueOff ;
10936: CALL_OW 7
// SetAttitude ( 3 , 2 , att_enemy , true ) ;
10940: LD_INT 3
10942: PPUSH
10943: LD_INT 2
10945: PPUSH
10946: LD_INT 2
10948: PPUSH
10949: LD_INT 1
10951: PPUSH
10952: CALL_OW 80
// for unit in UnitFilter ( GensherTeam , [ [ f_type , unit_human ] ] ) do
10956: LD_ADDR_VAR 0 2
10960: PUSH
10961: LD_EXP 83
10965: PPUSH
10966: LD_INT 21
10968: PUSH
10969: LD_INT 1
10971: PUSH
10972: EMPTY
10973: LIST
10974: LIST
10975: PUSH
10976: EMPTY
10977: LIST
10978: PPUSH
10979: CALL_OW 72
10983: PUSH
10984: FOR_IN
10985: IFFALSE 11045
// begin if IsInUnit ( unit ) then
10987: LD_VAR 0 2
10991: PPUSH
10992: CALL_OW 310
10996: IFFALSE 11007
// ComExitVehicle ( unit ) ;
10998: LD_VAR 0 2
11002: PPUSH
11003: CALL_OW 121
// wait ( 0 0$01 ) ;
11007: LD_INT 35
11009: PPUSH
11010: CALL_OW 67
// AddComAgressiveMove ( unit , GetX ( Burlak ) , GetY ( Burlak ) ) ;
11014: LD_VAR 0 2
11018: PPUSH
11019: LD_EXP 57
11023: PPUSH
11024: CALL_OW 250
11028: PPUSH
11029: LD_EXP 57
11033: PPUSH
11034: CALL_OW 251
11038: PPUSH
11039: CALL_OW 174
// end ;
11043: GO 10984
11045: POP
11046: POP
// coopWithGensher = 2 ;
11047: LD_ADDR_EXP 2
11051: PUSH
11052: LD_INT 2
11054: ST_TO_ADDR
// end ;
11055: LD_VAR 0 1
11059: RET
// every 0 0$1 trigger canSendHeike and IsOK ( Heike ) and GetSide ( Heike ) = 5 do var legionSold ;
11060: LD_EXP 28
11064: PUSH
11065: LD_EXP 79
11069: PPUSH
11070: CALL_OW 302
11074: AND
11075: PUSH
11076: LD_EXP 79
11080: PPUSH
11081: CALL_OW 255
11085: PUSH
11086: LD_INT 5
11088: EQUAL
11089: AND
11090: IFFALSE 11410
11092: GO 11094
11094: DISABLE
11095: LD_INT 0
11097: PPUSH
// begin if IsSelected ( Heike ) then
11098: LD_EXP 79
11102: PPUSH
11103: CALL_OW 306
11107: IFFALSE 11402
// begin if Query ( QSendHeike ) = 1 then
11109: LD_STRING QSendHeike
11111: PPUSH
11112: CALL_OW 97
11116: PUSH
11117: LD_INT 1
11119: EQUAL
11120: IFFALSE 11402
// begin KurtWaitingForFreeHeike = false ;
11122: LD_ADDR_EXP 23
11126: PUSH
11127: LD_INT 0
11129: ST_TO_ADDR
// ComMoveXY ( Heike , 82 , 46 ) ;
11130: LD_EXP 79
11134: PPUSH
11135: LD_INT 82
11137: PPUSH
11138: LD_INT 46
11140: PPUSH
11141: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
11145: LD_INT 35
11147: PPUSH
11148: CALL_OW 67
// until GetDistUnitXY ( Heike , 82 , 46 ) <= 5 or IsDead ( Heike ) ;
11152: LD_EXP 79
11156: PPUSH
11157: LD_INT 82
11159: PPUSH
11160: LD_INT 46
11162: PPUSH
11163: CALL_OW 297
11167: PUSH
11168: LD_INT 5
11170: LESSEQUAL
11171: PUSH
11172: LD_EXP 79
11176: PPUSH
11177: CALL_OW 301
11181: OR
11182: IFFALSE 11145
// if not askCommanders then
11184: LD_EXP 20
11188: NOT
11189: IFFALSE 11235
// begin DialogueOn ;
11191: CALL_OW 6
// SayRadio ( Popov , DMercPopov-Pop-1 ) ;
11195: LD_EXP 76
11199: PPUSH
11200: LD_STRING DMercPopov-Pop-1
11202: PPUSH
11203: CALL_OW 94
// Say ( Burlak , DMercPopov-Bur-1 ) ;
11207: LD_EXP 57
11211: PPUSH
11212: LD_STRING DMercPopov-Bur-1
11214: PPUSH
11215: CALL_OW 88
// SayRadio ( Popov , DMercPopov-Pop-2 ) ;
11219: LD_EXP 76
11223: PPUSH
11224: LD_STRING DMercPopov-Pop-2
11226: PPUSH
11227: CALL_OW 94
// DialogueOff ;
11231: CALL_OW 7
// end ; uc_side = 8 ;
11235: LD_ADDR_OWVAR 20
11239: PUSH
11240: LD_INT 8
11242: ST_TO_ADDR
// uc_nation = 2 ;
11243: LD_ADDR_OWVAR 21
11247: PUSH
11248: LD_INT 2
11250: ST_TO_ADDR
// PrepareSoldier ( false , 6 ) ;
11251: LD_INT 0
11253: PPUSH
11254: LD_INT 6
11256: PPUSH
11257: CALL_OW 381
// legionSold = CreateHuman ;
11261: LD_ADDR_VAR 0 1
11265: PUSH
11266: CALL_OW 44
11270: ST_TO_ADDR
// PlaceUnitXYR ( legionSold , 26 , 48 , 4 , false ) ;
11271: LD_VAR 0 1
11275: PPUSH
11276: LD_INT 26
11278: PPUSH
11279: LD_INT 48
11281: PPUSH
11282: LD_INT 4
11284: PPUSH
11285: LD_INT 0
11287: PPUSH
11288: CALL_OW 50
// repeat wait ( 0 0$1 ) ;
11292: LD_INT 35
11294: PPUSH
11295: CALL_OW 67
// ComMoveXY ( legionSold , GetX ( Heike ) , GetY ( Heike ) ) ;
11299: LD_VAR 0 1
11303: PPUSH
11304: LD_EXP 79
11308: PPUSH
11309: CALL_OW 250
11313: PPUSH
11314: LD_EXP 79
11318: PPUSH
11319: CALL_OW 251
11323: PPUSH
11324: CALL_OW 111
// until GetDistUnits ( legionSold , Heike ) <= 5 or IsDead ( Heike ) ;
11328: LD_VAR 0 1
11332: PPUSH
11333: LD_EXP 79
11337: PPUSH
11338: CALL_OW 296
11342: PUSH
11343: LD_INT 5
11345: LESSEQUAL
11346: PUSH
11347: LD_EXP 79
11351: PPUSH
11352: CALL_OW 301
11356: OR
11357: IFFALSE 11292
// SetSide ( Heike , 8 ) ;
11359: LD_EXP 79
11363: PPUSH
11364: LD_INT 8
11366: PPUSH
11367: CALL_OW 235
// allowExitFromMap = 3 ;
11371: LD_ADDR_EXP 18
11375: PUSH
11376: LD_INT 3
11378: ST_TO_ADDR
// ComMoveToArea ( [ legionSold , Heike ] , KurtExitMapArea ) ;
11379: LD_VAR 0 1
11383: PUSH
11384: LD_EXP 79
11388: PUSH
11389: EMPTY
11390: LIST
11391: LIST
11392: PPUSH
11393: LD_INT 11
11395: PPUSH
11396: CALL_OW 113
// exit ;
11400: GO 11410
// end ; end ; wait ( 0 0$3 ) ;
11402: LD_INT 105
11404: PPUSH
11405: CALL_OW 67
// enable ;
11409: ENABLE
// end ;
11410: PPOPN 1
11412: END
// export function Dial_PlayerDontSendHeike ; begin
11413: LD_INT 0
11415: PPUSH
// DialogueOn ;
11416: CALL_OW 6
// SayRadio ( Kurt , DMercDeceived-Kurt-1 ) ;
11420: LD_EXP 80
11424: PPUSH
11425: LD_STRING DMercDeceived-Kurt-1
11427: PPUSH
11428: CALL_OW 94
// DialogueOff ;
11432: CALL_OW 7
// SetAttitude ( 3 , 8 , att_enemy , true ) ;
11436: LD_INT 3
11438: PPUSH
11439: LD_INT 8
11441: PPUSH
11442: LD_INT 2
11444: PPUSH
11445: LD_INT 1
11447: PPUSH
11448: CALL_OW 80
// KurtAttack = true ;
11452: LD_ADDR_EXP 25
11456: PUSH
11457: LD_INT 1
11459: ST_TO_ADDR
// end ;
11460: LD_VAR 0 1
11464: RET
// export function Dial_BetrayedKurt1 ; begin
11465: LD_INT 0
11467: PPUSH
// DialogueOn ;
11468: CALL_OW 6
// Say ( Kurt , DMercDeceived-Kurt-1 ) ;
11472: LD_EXP 80
11476: PPUSH
11477: LD_STRING DMercDeceived-Kurt-1
11479: PPUSH
11480: CALL_OW 88
// DialogueOff ;
11484: CALL_OW 7
// if IsPlaced ( Kurt ) then
11488: LD_EXP 80
11492: PPUSH
11493: CALL_OW 305
11497: IFFALSE 11546
// begin SetSide ( KurtEng , 8 ) ;
11499: LD_EXP 82
11503: PPUSH
11504: LD_INT 8
11506: PPUSH
11507: CALL_OW 235
// allowExitFromMap = 3 ;
11511: LD_ADDR_EXP 18
11515: PUSH
11516: LD_INT 3
11518: ST_TO_ADDR
// if KurtCanEscape then
11519: LD_EXP 21
11523: IFFALSE 11546
// ComMoveToArea ( [ Kurt , KurtEng ] , KurtExitMapArea ) ;
11525: LD_EXP 80
11529: PUSH
11530: LD_EXP 82
11534: PUSH
11535: EMPTY
11536: LIST
11537: LIST
11538: PPUSH
11539: LD_INT 11
11541: PPUSH
11542: CALL_OW 113
// end ; end ;
11546: LD_VAR 0 1
11550: RET
// export function Dial_BetrayedKurt2 ; begin
11551: LD_INT 0
11553: PPUSH
// DialogueOn ;
11554: CALL_OW 6
// Say ( Kurt , DMercAmbush-Kurt-1 ) ;
11558: LD_EXP 80
11562: PPUSH
11563: LD_STRING DMercAmbush-Kurt-1
11565: PPUSH
11566: CALL_OW 88
// DialogueOff ;
11570: CALL_OW 7
// if IsPlaced ( Kurt ) then
11574: LD_EXP 80
11578: PPUSH
11579: CALL_OW 305
11583: IFFALSE 11632
// begin SetSide ( KurtEng , 8 ) ;
11585: LD_EXP 82
11589: PPUSH
11590: LD_INT 8
11592: PPUSH
11593: CALL_OW 235
// allowExitFromMap = 3 ;
11597: LD_ADDR_EXP 18
11601: PUSH
11602: LD_INT 3
11604: ST_TO_ADDR
// if KurtCanEscape then
11605: LD_EXP 21
11609: IFFALSE 11632
// ComMoveToArea ( [ Kurt , KurtEng ] , KurtExitMapArea ) ;
11611: LD_EXP 80
11615: PUSH
11616: LD_EXP 82
11620: PUSH
11621: EMPTY
11622: LIST
11623: LIST
11624: PPUSH
11625: LD_INT 11
11627: PPUSH
11628: CALL_OW 113
// end ; end ;
11632: LD_VAR 0 1
11636: RET
// every 0 0$1 trigger GetSide ( KurtEng ) = 3 do var playerUnits , unit ;
11637: LD_EXP 82
11641: PPUSH
11642: CALL_OW 255
11646: PUSH
11647: LD_INT 3
11649: EQUAL
11650: IFFALSE 11797
11652: GO 11654
11654: DISABLE
11655: LD_INT 0
11657: PPUSH
11658: PPUSH
// begin playerUnits = FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
11659: LD_ADDR_VAR 0 1
11663: PUSH
11664: LD_INT 22
11666: PUSH
11667: LD_INT 3
11669: PUSH
11670: EMPTY
11671: LIST
11672: LIST
11673: PUSH
11674: LD_INT 2
11676: PUSH
11677: LD_INT 21
11679: PUSH
11680: LD_INT 1
11682: PUSH
11683: EMPTY
11684: LIST
11685: LIST
11686: PUSH
11687: LD_INT 21
11689: PUSH
11690: LD_INT 2
11692: PUSH
11693: EMPTY
11694: LIST
11695: LIST
11696: PUSH
11697: EMPTY
11698: LIST
11699: LIST
11700: LIST
11701: PUSH
11702: EMPTY
11703: LIST
11704: LIST
11705: PPUSH
11706: CALL_OW 69
11710: ST_TO_ADDR
// for unit in playerUnits do
11711: LD_ADDR_VAR 0 2
11715: PUSH
11716: LD_VAR 0 1
11720: PUSH
11721: FOR_IN
11722: IFFALSE 11751
// begin if WantsToAttack ( unit ) = KurtEng then
11724: LD_VAR 0 2
11728: PPUSH
11729: CALL_OW 319
11733: PUSH
11734: LD_EXP 82
11738: EQUAL
11739: IFFALSE 11749
// begin Dial_BetrayedKurt2 ;
11741: CALL 11551 0 0
// exit ;
11745: POP
11746: POP
11747: GO 11797
// end ; end ;
11749: GO 11721
11751: POP
11752: POP
// if ( IsDying ( KurtEng ) or IsDead ( KurtEng ) ) and GetSide ( KurtEng ) = 3 then
11753: LD_EXP 82
11757: PPUSH
11758: CALL_OW 303
11762: PUSH
11763: LD_EXP 82
11767: PPUSH
11768: CALL_OW 301
11772: OR
11773: PUSH
11774: LD_EXP 82
11778: PPUSH
11779: CALL_OW 255
11783: PUSH
11784: LD_INT 3
11786: EQUAL
11787: AND
11788: IFFALSE 11796
// begin Dial_BetrayedKurt2 ;
11790: CALL 11551 0 0
// exit ;
11794: GO 11797
// end ; enable ;
11796: ENABLE
// end ;
11797: PPOPN 2
11799: END
// every 0 0$1 trigger GetAttitude ( 3 , 8 ) = att_neutral and GetLives ( Kurt ) <= 999 do
11800: LD_INT 3
11802: PPUSH
11803: LD_INT 8
11805: PPUSH
11806: CALL_OW 81
11810: PUSH
11811: LD_INT 0
11813: EQUAL
11814: PUSH
11815: LD_EXP 80
11819: PPUSH
11820: CALL_OW 256
11824: PUSH
11825: LD_INT 999
11827: LESSEQUAL
11828: AND
11829: IFFALSE 11854
11831: GO 11833
11833: DISABLE
// begin Dial_BetrayedKurt1 ;
11834: CALL 11465 0 0
// SetAttitude ( 3 , 8 , att_enemy , true ) ;
11838: LD_INT 3
11840: PPUSH
11841: LD_INT 8
11843: PPUSH
11844: LD_INT 2
11846: PPUSH
11847: LD_INT 1
11849: PPUSH
11850: CALL_OW 80
// end ;
11854: END
// every 0 0$1 trigger buildingsToBuild <= 11 do
11855: LD_EXP 8
11859: PUSH
11860: LD_INT 11
11862: LESSEQUAL
11863: IFFALSE 12112
11865: GO 11867
11867: DISABLE
// begin if not IsOK ( Kuzmov ) and not IsOK ( Oblukov ) then
11868: LD_EXP 72
11872: PPUSH
11873: CALL_OW 302
11877: NOT
11878: PUSH
11879: LD_EXP 74
11883: PPUSH
11884: CALL_OW 302
11888: NOT
11889: AND
11890: IFFALSE 11894
// exit ;
11892: GO 12112
// DialogueOn ;
11894: CALL_OW 6
// if IsOK ( Kuzmov ) then
11898: LD_EXP 72
11902: PPUSH
11903: CALL_OW 302
11907: IFFALSE 11923
// Say ( Kuzmov , DFiringRange-Kuz-1 ) else
11909: LD_EXP 72
11913: PPUSH
11914: LD_STRING DFiringRange-Kuz-1
11916: PPUSH
11917: CALL_OW 88
11921: GO 11935
// Say ( Oblukov , DFiringRange-Obl-1 ) ;
11923: LD_EXP 74
11927: PPUSH
11928: LD_STRING DFiringRange-Obl-1
11930: PPUSH
11931: CALL_OW 88
// Say ( Burlak , DFiringRange-Bur-1 ) ;
11935: LD_EXP 57
11939: PPUSH
11940: LD_STRING DFiringRange-Bur-1
11942: PPUSH
11943: CALL_OW 88
// CenterOnXY ( 99 , 30 ) ;
11947: LD_INT 99
11949: PPUSH
11950: LD_INT 30
11952: PPUSH
11953: CALL_OW 84
// Wait ( 0 0$0.5 ) ;
11957: LD_INT 18
11959: PPUSH
11960: CALL_OW 67
// RevealFogArea ( 3 , ShootArea ) ;
11964: LD_INT 3
11966: PPUSH
11967: LD_INT 12
11969: PPUSH
11970: CALL_OW 332
// SetAreaMapShow ( ShootArea , 1 ) ;
11974: LD_INT 12
11976: PPUSH
11977: LD_INT 1
11979: PPUSH
11980: CALL_OW 424
// if IsOK ( Kuzmov ) then
11984: LD_EXP 72
11988: PPUSH
11989: CALL_OW 302
11993: IFFALSE 12009
// Say ( Kuzmov , DFiringRange-Kuz-2 ) else
11995: LD_EXP 72
11999: PPUSH
12000: LD_STRING DFiringRange-Kuz-2
12002: PPUSH
12003: CALL_OW 88
12007: GO 12021
// Say ( Oblukov , DFiringRange-Obl-2 ) ;
12009: LD_EXP 74
12013: PPUSH
12014: LD_STRING DFiringRange-Obl-2
12016: PPUSH
12017: CALL_OW 88
// case Query ( QShootingGallery ) of 1 :
12021: LD_STRING QShootingGallery
12023: PPUSH
12024: CALL_OW 97
12028: PUSH
12029: LD_INT 1
12031: DOUBLE
12032: EQUAL
12033: IFTRUE 12037
12035: GO 12074
12037: POP
// begin Say ( Burlak , DQrShootingGallery#1-Bur-1 ) ;
12038: LD_EXP 57
12042: PPUSH
12043: LD_STRING DQrShootingGallery#1-Bur-1
12045: PPUSH
12046: CALL_OW 88
// BurlakRespect = BurlakRespect + 1 ;
12050: LD_ADDR_EXP 30
12054: PUSH
12055: LD_EXP 30
12059: PUSH
12060: LD_INT 1
12062: PLUS
12063: ST_TO_ADDR
// canShootTrening = true ;
12064: LD_ADDR_EXP 29
12068: PUSH
12069: LD_INT 1
12071: ST_TO_ADDR
// end ; 2 :
12072: GO 12108
12074: LD_INT 2
12076: DOUBLE
12077: EQUAL
12078: IFTRUE 12082
12080: GO 12107
12082: POP
// begin Say ( Burlak , DQrShootingGallery#2-Bur-1 ) ;
12083: LD_EXP 57
12087: PPUSH
12088: LD_STRING DQrShootingGallery#2-Bur-1
12090: PPUSH
12091: CALL_OW 88
// SetAreaMapShow ( ShootArea , 0 ) ;
12095: LD_INT 12
12097: PPUSH
12098: LD_INT 0
12100: PPUSH
12101: CALL_OW 424
// end ; end ;
12105: GO 12108
12107: POP
// DialogueOff ;
12108: CALL_OW 7
// end ;
12112: END
// every 0 0$1 trigger canShootTrening do
12113: LD_EXP 29
12117: IFFALSE 12127
12119: GO 12121
12121: DISABLE
// begin enable ;
12122: ENABLE
// ShootTreningController ;
12123: CALL 7091 0 0
// end ;
12127: END
// every 0 0$1 trigger buildingsToBuild <= 7 do var hunters , hunter ;
12128: LD_EXP 8
12132: PUSH
12133: LD_INT 7
12135: LESSEQUAL
12136: IFFALSE 12526
12138: GO 12140
12140: DISABLE
12141: LD_INT 0
12143: PPUSH
12144: PPUSH
// begin hunters = [ ] ;
12145: LD_ADDR_VAR 0 1
12149: PUSH
12150: EMPTY
12151: ST_TO_ADDR
// if IsOK ( Belkov ) then
12152: LD_EXP 66
12156: PPUSH
12157: CALL_OW 302
12161: IFFALSE 12179
// hunters = hunters ^ Belkov ;
12163: LD_ADDR_VAR 0 1
12167: PUSH
12168: LD_VAR 0 1
12172: PUSH
12173: LD_EXP 66
12177: ADD
12178: ST_TO_ADDR
// if IsOK ( Karamazov ) then
12179: LD_EXP 58
12183: PPUSH
12184: CALL_OW 302
12188: IFFALSE 12206
// hunters = hunters ^ Karamazov ;
12190: LD_ADDR_VAR 0 1
12194: PUSH
12195: LD_VAR 0 1
12199: PUSH
12200: LD_EXP 58
12204: ADD
12205: ST_TO_ADDR
// if IsOK ( Kozlov ) then
12206: LD_EXP 73
12210: PPUSH
12211: CALL_OW 302
12215: IFFALSE 12233
// hunters = hunters ^ Kozlov ;
12217: LD_ADDR_VAR 0 1
12221: PUSH
12222: LD_VAR 0 1
12226: PUSH
12227: LD_EXP 73
12231: ADD
12232: ST_TO_ADDR
// if not hunters then
12233: LD_VAR 0 1
12237: NOT
12238: IFFALSE 12242
// exit ;
12240: GO 12526
// hunter = hunters [ Rand ( 1 , hunters ) ] ;
12242: LD_ADDR_VAR 0 2
12246: PUSH
12247: LD_VAR 0 1
12251: PUSH
12252: LD_INT 1
12254: PPUSH
12255: LD_VAR 0 1
12259: PPUSH
12260: CALL_OW 12
12264: ARRAY
12265: ST_TO_ADDR
// DialogueOn ;
12266: CALL_OW 6
// case hunter of Belkov :
12270: LD_VAR 0 2
12274: PUSH
12275: LD_EXP 66
12279: DOUBLE
12280: EQUAL
12281: IFTRUE 12285
12283: GO 12300
12285: POP
// Say ( Belkov , DHunting-Bel-1 ) ; Karamazov :
12286: LD_EXP 66
12290: PPUSH
12291: LD_STRING DHunting-Bel-1
12293: PPUSH
12294: CALL_OW 88
12298: GO 12351
12300: LD_EXP 58
12304: DOUBLE
12305: EQUAL
12306: IFTRUE 12310
12308: GO 12325
12310: POP
// Say ( Karamazov , DHunting-Kar-1 ) ; Kozlov :
12311: LD_EXP 58
12315: PPUSH
12316: LD_STRING DHunting-Kar-1
12318: PPUSH
12319: CALL_OW 88
12323: GO 12351
12325: LD_EXP 73
12329: DOUBLE
12330: EQUAL
12331: IFTRUE 12335
12333: GO 12350
12335: POP
// Say ( Kozlov , DHunting-Koz-1 ) ; end ;
12336: LD_EXP 73
12340: PPUSH
12341: LD_STRING DHunting-Koz-1
12343: PPUSH
12344: CALL_OW 88
12348: GO 12351
12350: POP
// Say ( Burlak , DHunting-Bur-1 ) ;
12351: LD_EXP 57
12355: PPUSH
12356: LD_STRING DHunting-Bur-1
12358: PPUSH
12359: CALL_OW 88
// case hunter of Belkov :
12363: LD_VAR 0 2
12367: PUSH
12368: LD_EXP 66
12372: DOUBLE
12373: EQUAL
12374: IFTRUE 12378
12376: GO 12393
12378: POP
// Say ( Belkov , DHunting-Bel-2 ) ; Karamazov :
12379: LD_EXP 66
12383: PPUSH
12384: LD_STRING DHunting-Bel-2
12386: PPUSH
12387: CALL_OW 88
12391: GO 12444
12393: LD_EXP 58
12397: DOUBLE
12398: EQUAL
12399: IFTRUE 12403
12401: GO 12418
12403: POP
// Say ( Karamazov , DHunting-Kar-2 ) ; Kozlov :
12404: LD_EXP 58
12408: PPUSH
12409: LD_STRING DHunting-Kar-2
12411: PPUSH
12412: CALL_OW 88
12416: GO 12444
12418: LD_EXP 73
12422: DOUBLE
12423: EQUAL
12424: IFTRUE 12428
12426: GO 12443
12428: POP
// Say ( Kozlov , DHunting-Koz-2 ) ; end ;
12429: LD_EXP 73
12433: PPUSH
12434: LD_STRING DHunting-Koz-2
12436: PPUSH
12437: CALL_OW 88
12441: GO 12444
12443: POP
// DialogueOff ;
12444: CALL_OW 7
// case Query ( QHunting ) of 1 :
12448: LD_STRING QHunting
12450: PPUSH
12451: CALL_OW 97
12455: PUSH
12456: LD_INT 1
12458: DOUBLE
12459: EQUAL
12460: IFTRUE 12464
12462: GO 12502
12464: POP
// begin Say ( Burlak , DQrHunting#1-Bur-1 ) ;
12465: LD_EXP 57
12469: PPUSH
12470: LD_STRING DQrHunting#1-Bur-1
12472: PPUSH
12473: CALL_OW 88
// BurlakRespect = BurlakRespect + 1 ;
12477: LD_ADDR_EXP 30
12481: PUSH
12482: LD_EXP 30
12486: PUSH
12487: LD_INT 1
12489: PLUS
12490: ST_TO_ADDR
// GoToHunt ( hunter ) ;
12491: LD_VAR 0 2
12495: PPUSH
12496: CALL 7719 0 1
// end ; 2 :
12500: GO 12526
12502: LD_INT 2
12504: DOUBLE
12505: EQUAL
12506: IFTRUE 12510
12508: GO 12525
12510: POP
// Say ( Burlak , DQrHunting#2-Bur-1 ) ; end ;
12511: LD_EXP 57
12515: PPUSH
12516: LD_STRING DQrHunting#2-Bur-1
12518: PPUSH
12519: CALL_OW 88
12523: GO 12526
12525: POP
// end ;
12526: PPOPN 2
12528: END
// every 0 0$1 trigger buildingsToBuild <= 3 do var unit , womans , men , woman , man , depots ;
12529: LD_EXP 8
12533: PUSH
12534: LD_INT 3
12536: LESSEQUAL
12537: IFFALSE 13524
12539: GO 12541
12541: DISABLE
12542: LD_INT 0
12544: PPUSH
12545: PPUSH
12546: PPUSH
12547: PPUSH
12548: PPUSH
12549: PPUSH
// begin womans = [ ] ;
12550: LD_ADDR_VAR 0 2
12554: PUSH
12555: EMPTY
12556: ST_TO_ADDR
// men = [ ] ;
12557: LD_ADDR_VAR 0 3
12561: PUSH
12562: EMPTY
12563: ST_TO_ADDR
// if IsOK ( Petrovova ) then
12564: LD_EXP 59
12568: PPUSH
12569: CALL_OW 302
12573: IFFALSE 12591
// womans = womans ^ Petrovova ;
12575: LD_ADDR_VAR 0 2
12579: PUSH
12580: LD_VAR 0 2
12584: PUSH
12585: LD_EXP 59
12589: ADD
12590: ST_TO_ADDR
// if IsOK ( Kirilenkova ) then
12591: LD_EXP 65
12595: PPUSH
12596: CALL_OW 302
12600: IFFALSE 12618
// womans = womans ^ Kirilenkova ;
12602: LD_ADDR_VAR 0 2
12606: PUSH
12607: LD_VAR 0 2
12611: PUSH
12612: LD_EXP 65
12616: ADD
12617: ST_TO_ADDR
// if IsOK ( Kapitsova ) then
12618: LD_EXP 75
12622: PPUSH
12623: CALL_OW 302
12627: IFFALSE 12645
// womans = womans ^ Kapitsova ;
12629: LD_ADDR_VAR 0 2
12633: PUSH
12634: LD_VAR 0 2
12638: PUSH
12639: LD_EXP 75
12643: ADD
12644: ST_TO_ADDR
// DialogueOn ;
12645: CALL_OW 6
// if womans then
12649: LD_VAR 0 2
12653: IFFALSE 12780
// begin case womans [ Rand ( 1 , womans ) ] of Petrovova :
12655: LD_VAR 0 2
12659: PUSH
12660: LD_INT 1
12662: PPUSH
12663: LD_VAR 0 2
12667: PPUSH
12668: CALL_OW 12
12672: ARRAY
12673: PUSH
12674: LD_EXP 59
12678: DOUBLE
12679: EQUAL
12680: IFTRUE 12684
12682: GO 12709
12684: POP
// begin Say ( Petrovova , DFreeTime-Ptr-1 ) ;
12685: LD_EXP 59
12689: PPUSH
12690: LD_STRING DFreeTime-Ptr-1
12692: PPUSH
12693: CALL_OW 88
// woman = Petrovova ;
12697: LD_ADDR_VAR 0 4
12701: PUSH
12702: LD_EXP 59
12706: ST_TO_ADDR
// end ; Kirilenkova :
12707: GO 12780
12709: LD_EXP 65
12713: DOUBLE
12714: EQUAL
12715: IFTRUE 12719
12717: GO 12744
12719: POP
// begin Say ( Kirilenkova , DFreeTime-Kir-1 ) ;
12720: LD_EXP 65
12724: PPUSH
12725: LD_STRING DFreeTime-Kir-1
12727: PPUSH
12728: CALL_OW 88
// woman = Kirilenkova ;
12732: LD_ADDR_VAR 0 4
12736: PUSH
12737: LD_EXP 65
12741: ST_TO_ADDR
// end ; Kapitsova :
12742: GO 12780
12744: LD_EXP 75
12748: DOUBLE
12749: EQUAL
12750: IFTRUE 12754
12752: GO 12779
12754: POP
// begin Say ( Kapitsova , DFreeTime-Kap-1 ) ;
12755: LD_EXP 75
12759: PPUSH
12760: LD_STRING DFreeTime-Kap-1
12762: PPUSH
12763: CALL_OW 88
// woman = Kapitsova ;
12767: LD_ADDR_VAR 0 4
12771: PUSH
12772: LD_EXP 75
12776: ST_TO_ADDR
// end ; end ;
12777: GO 12780
12779: POP
// end ; if IsOK ( Kuzmov ) then
12780: LD_EXP 72
12784: PPUSH
12785: CALL_OW 302
12789: IFFALSE 12807
// men = men ^ Kuzmov ;
12791: LD_ADDR_VAR 0 3
12795: PUSH
12796: LD_VAR 0 3
12800: PUSH
12801: LD_EXP 72
12805: ADD
12806: ST_TO_ADDR
// if IsOK ( Titov ) then
12807: LD_EXP 62
12811: PPUSH
12812: CALL_OW 302
12816: IFFALSE 12834
// men = men ^ Titov ;
12818: LD_ADDR_VAR 0 3
12822: PUSH
12823: LD_VAR 0 3
12827: PUSH
12828: LD_EXP 62
12832: ADD
12833: ST_TO_ADDR
// if IsOK ( Gnyevko ) then
12834: LD_EXP 69
12838: PPUSH
12839: CALL_OW 302
12843: IFFALSE 12861
// men = men ^ Gnyevko ;
12845: LD_ADDR_VAR 0 3
12849: PUSH
12850: LD_VAR 0 3
12854: PUSH
12855: LD_EXP 69
12859: ADD
12860: ST_TO_ADDR
// if IsOK ( Oblukov ) then
12861: LD_EXP 74
12865: PPUSH
12866: CALL_OW 302
12870: IFFALSE 12888
// men = men ^ Oblukov ;
12872: LD_ADDR_VAR 0 3
12876: PUSH
12877: LD_VAR 0 3
12881: PUSH
12882: LD_EXP 74
12886: ADD
12887: ST_TO_ADDR
// if men then
12888: LD_VAR 0 3
12892: IFFALSE 13054
// begin case men [ Rand ( 1 , men ) ] of Kuzmov :
12894: LD_VAR 0 3
12898: PUSH
12899: LD_INT 1
12901: PPUSH
12902: LD_VAR 0 3
12906: PPUSH
12907: CALL_OW 12
12911: ARRAY
12912: PUSH
12913: LD_EXP 72
12917: DOUBLE
12918: EQUAL
12919: IFTRUE 12923
12921: GO 12948
12923: POP
// begin Say ( Kuzmov , DFreeTime-Kuz-1 ) ;
12924: LD_EXP 72
12928: PPUSH
12929: LD_STRING DFreeTime-Kuz-1
12931: PPUSH
12932: CALL_OW 88
// man = Kuzmov ;
12936: LD_ADDR_VAR 0 5
12940: PUSH
12941: LD_EXP 72
12945: ST_TO_ADDR
// end ; Titov :
12946: GO 13054
12948: LD_EXP 62
12952: DOUBLE
12953: EQUAL
12954: IFTRUE 12958
12956: GO 12983
12958: POP
// begin Say ( Titov , DFreeTime-Tit-1 ) ;
12959: LD_EXP 62
12963: PPUSH
12964: LD_STRING DFreeTime-Tit-1
12966: PPUSH
12967: CALL_OW 88
// man = Titov ;
12971: LD_ADDR_VAR 0 5
12975: PUSH
12976: LD_EXP 62
12980: ST_TO_ADDR
// end ; Gnyevko :
12981: GO 13054
12983: LD_EXP 69
12987: DOUBLE
12988: EQUAL
12989: IFTRUE 12993
12991: GO 13018
12993: POP
// begin Say ( Gnyevko , DFreeTime-Gny-1 ) ;
12994: LD_EXP 69
12998: PPUSH
12999: LD_STRING DFreeTime-Gny-1
13001: PPUSH
13002: CALL_OW 88
// man = Gnyevko ;
13006: LD_ADDR_VAR 0 5
13010: PUSH
13011: LD_EXP 69
13015: ST_TO_ADDR
// end ; Oblukov :
13016: GO 13054
13018: LD_EXP 74
13022: DOUBLE
13023: EQUAL
13024: IFTRUE 13028
13026: GO 13053
13028: POP
// begin Say ( Oblukov , DFreeTime-Obl-1 ) ;
13029: LD_EXP 74
13033: PPUSH
13034: LD_STRING DFreeTime-Obl-1
13036: PPUSH
13037: CALL_OW 88
// man = Oblukov ;
13041: LD_ADDR_VAR 0 5
13045: PUSH
13046: LD_EXP 74
13050: ST_TO_ADDR
// end ; end ;
13051: GO 13054
13053: POP
// end ; DialogueOff ;
13054: CALL_OW 7
// if not woman and not man then
13058: LD_VAR 0 4
13062: NOT
13063: PUSH
13064: LD_VAR 0 5
13068: NOT
13069: AND
13070: IFFALSE 13078
// begin DialogueOff ;
13072: CALL_OW 7
// exit ;
13076: GO 13524
// end ; case Query ( QFreeTime ) of 1 :
13078: LD_STRING QFreeTime
13080: PPUSH
13081: CALL_OW 97
13085: PUSH
13086: LD_INT 1
13088: DOUBLE
13089: EQUAL
13090: IFTRUE 13094
13092: GO 13496
13094: POP
// begin Say ( Burlak , DQrFreeTime#1-Bur-1 ) ;
13095: LD_EXP 57
13099: PPUSH
13100: LD_STRING DQrFreeTime#1-Bur-1
13102: PPUSH
13103: CALL_OW 88
// DialogueOff ;
13107: CALL_OW 7
// BurlakRespect = BurlakRespect + 1 ;
13111: LD_ADDR_EXP 30
13115: PUSH
13116: LD_EXP 30
13120: PUSH
13121: LD_INT 1
13123: PLUS
13124: ST_TO_ADDR
// SetSide ( [ woman , man ] , 6 ) ;
13125: LD_VAR 0 4
13129: PUSH
13130: LD_VAR 0 5
13134: PUSH
13135: EMPTY
13136: LIST
13137: LIST
13138: PPUSH
13139: LD_INT 6
13141: PPUSH
13142: CALL_OW 235
// for unit in [ woman , man ] do
13146: LD_ADDR_VAR 0 1
13150: PUSH
13151: LD_VAR 0 4
13155: PUSH
13156: LD_VAR 0 5
13160: PUSH
13161: EMPTY
13162: LIST
13163: LIST
13164: PUSH
13165: FOR_IN
13166: IFFALSE 13221
// if IsInUnit ( unit ) then
13168: LD_VAR 0 1
13172: PPUSH
13173: CALL_OW 310
13177: IFFALSE 13219
// begin if GetType ( IsInUnit ( unit ) ) = unit_vehicle then
13179: LD_VAR 0 1
13183: PPUSH
13184: CALL_OW 310
13188: PPUSH
13189: CALL_OW 247
13193: PUSH
13194: LD_INT 2
13196: EQUAL
13197: IFFALSE 13210
// ComExitVehicle ( unit ) else
13199: LD_VAR 0 1
13203: PPUSH
13204: CALL_OW 121
13208: GO 13219
// ComExitBuilding ( unit ) ;
13210: LD_VAR 0 1
13214: PPUSH
13215: CALL_OW 122
// end ;
13219: GO 13165
13221: POP
13222: POP
// wait ( 0 0$1 ) ;
13223: LD_INT 35
13225: PPUSH
13226: CALL_OW 67
// ComMoveToArea ( [ woman , man ] , ExitMapArea ) ;
13230: LD_VAR 0 4
13234: PUSH
13235: LD_VAR 0 5
13239: PUSH
13240: EMPTY
13241: LIST
13242: LIST
13243: PPUSH
13244: LD_INT 8
13246: PPUSH
13247: CALL_OW 113
// allowExitFromMap = 1 ;
13251: LD_ADDR_EXP 18
13255: PUSH
13256: LD_INT 1
13258: ST_TO_ADDR
// wait ( 3 3$0 ) ;
13259: LD_INT 6300
13261: PPUSH
13262: CALL_OW 67
// PlaceUnitXYR ( woman , 157 , 29 , 3 , false ) ;
13266: LD_VAR 0 4
13270: PPUSH
13271: LD_INT 157
13273: PPUSH
13274: LD_INT 29
13276: PPUSH
13277: LD_INT 3
13279: PPUSH
13280: LD_INT 0
13282: PPUSH
13283: CALL_OW 50
// PlaceUnitXYR ( man , 157 , 29 , 3 , false ) ;
13287: LD_VAR 0 5
13291: PPUSH
13292: LD_INT 157
13294: PPUSH
13295: LD_INT 29
13297: PPUSH
13298: LD_INT 3
13300: PPUSH
13301: LD_INT 0
13303: PPUSH
13304: CALL_OW 50
// SetSide ( [ woman , man ] , 3 ) ;
13308: LD_VAR 0 4
13312: PUSH
13313: LD_VAR 0 5
13317: PUSH
13318: EMPTY
13319: LIST
13320: LIST
13321: PPUSH
13322: LD_INT 3
13324: PPUSH
13325: CALL_OW 235
// depots = FilterAllUnits ( [ [ f_side , 3 ] , [ [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ] ) ;
13329: LD_ADDR_VAR 0 6
13333: PUSH
13334: LD_INT 22
13336: PUSH
13337: LD_INT 3
13339: PUSH
13340: EMPTY
13341: LIST
13342: LIST
13343: PUSH
13344: LD_INT 2
13346: PUSH
13347: LD_INT 30
13349: PUSH
13350: LD_INT 0
13352: PUSH
13353: EMPTY
13354: LIST
13355: LIST
13356: PUSH
13357: LD_INT 30
13359: PUSH
13360: LD_INT 1
13362: PUSH
13363: EMPTY
13364: LIST
13365: LIST
13366: PUSH
13367: EMPTY
13368: LIST
13369: LIST
13370: LIST
13371: PUSH
13372: EMPTY
13373: LIST
13374: PUSH
13375: EMPTY
13376: LIST
13377: LIST
13378: PPUSH
13379: CALL_OW 69
13383: ST_TO_ADDR
// if depots then
13384: LD_VAR 0 6
13388: IFFALSE 13438
// ComMoveXY ( [ woman , man ] , GetX ( depots [ 1 ] ) , GetY ( depots [ 1 ] ) ) else
13390: LD_VAR 0 4
13394: PUSH
13395: LD_VAR 0 5
13399: PUSH
13400: EMPTY
13401: LIST
13402: LIST
13403: PPUSH
13404: LD_VAR 0 6
13408: PUSH
13409: LD_INT 1
13411: ARRAY
13412: PPUSH
13413: CALL_OW 250
13417: PPUSH
13418: LD_VAR 0 6
13422: PUSH
13423: LD_INT 1
13425: ARRAY
13426: PPUSH
13427: CALL_OW 251
13431: PPUSH
13432: CALL_OW 111
13436: GO 13476
// ComMoveXY ( [ woman , man ] , GetX ( Burlak ) , GetY ( Burlak ) ) ;
13438: LD_VAR 0 4
13442: PUSH
13443: LD_VAR 0 5
13447: PUSH
13448: EMPTY
13449: LIST
13450: LIST
13451: PPUSH
13452: LD_EXP 57
13456: PPUSH
13457: CALL_OW 250
13461: PPUSH
13462: LD_EXP 57
13466: PPUSH
13467: CALL_OW 251
13471: PPUSH
13472: CALL_OW 111
// CenterOnUnits ( [ woman , man ] ) ;
13476: LD_VAR 0 4
13480: PUSH
13481: LD_VAR 0 5
13485: PUSH
13486: EMPTY
13487: LIST
13488: LIST
13489: PPUSH
13490: CALL_OW 85
// end ; 2 :
13494: GO 13520
13496: LD_INT 2
13498: DOUBLE
13499: EQUAL
13500: IFTRUE 13504
13502: GO 13519
13504: POP
// Say ( Burlak , DQrFreeTime#2-Bur-1 ) ; end ;
13505: LD_EXP 57
13509: PPUSH
13510: LD_STRING DQrFreeTime#2-Bur-1
13512: PPUSH
13513: CALL_OW 88
13517: GO 13520
13519: POP
// DialogueOff ;
13520: CALL_OW 7
// end ;
13524: PPOPN 6
13526: END
// every 0 0$1 trigger GetAmountWeaponsDataBuildOnVehicle ( false ) <= 2 do
13527: LD_INT 0
13529: PPUSH
13530: CALL 6800 0 1
13534: PUSH
13535: LD_INT 2
13537: LESSEQUAL
13538: IFFALSE 13673
13540: GO 13542
13542: DISABLE
// begin DialogueOn ;
13543: CALL_OW 6
// if IsOK ( Kozlov ) then
13547: LD_EXP 73
13551: PPUSH
13552: CALL_OW 302
13556: IFFALSE 13572
// Say ( Kozlov , DMasha-Koz-1 ) else
13558: LD_EXP 73
13562: PPUSH
13563: LD_STRING DMasha-Koz-1
13565: PPUSH
13566: CALL_OW 88
13570: GO 13635
// DialogRandom ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_ok ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) , DMasha-Koz-1 ,  , false , false ) ;
13572: LD_INT 22
13574: PUSH
13575: LD_INT 3
13577: PUSH
13578: EMPTY
13579: LIST
13580: LIST
13581: PUSH
13582: LD_INT 50
13584: PUSH
13585: EMPTY
13586: LIST
13587: PUSH
13588: LD_INT 21
13590: PUSH
13591: LD_INT 1
13593: PUSH
13594: EMPTY
13595: LIST
13596: LIST
13597: PUSH
13598: LD_INT 26
13600: PUSH
13601: LD_INT 1
13603: PUSH
13604: EMPTY
13605: LIST
13606: LIST
13607: PUSH
13608: EMPTY
13609: LIST
13610: LIST
13611: LIST
13612: LIST
13613: PPUSH
13614: CALL_OW 69
13618: PPUSH
13619: LD_STRING DMasha-Koz-1
13621: PPUSH
13622: LD_STRING 
13624: PPUSH
13625: LD_INT 0
13627: PPUSH
13628: LD_INT 0
13630: PPUSH
13631: CALL 6249 0 5
// Say ( Burlak , DMasha2-Bur-1 ) ;
13635: LD_EXP 57
13639: PPUSH
13640: LD_STRING DMasha2-Bur-1
13642: PPUSH
13643: CALL_OW 88
// DialogueOff ;
13647: CALL_OW 7
// Query ( QMasha ) ;
13651: LD_STRING QMasha
13653: PPUSH
13654: CALL_OW 97
// ChangeMissionObjectives ( MMasha ) ;
13658: LD_STRING MMasha
13660: PPUSH
13661: CALL_OW 337
// canChooseMashaVehicle = true ;
13665: LD_ADDR_EXP 36
13669: PUSH
13670: LD_INT 1
13672: ST_TO_ADDR
// end ;
13673: END
// export function Dial_ComputerTechResearched ; begin
13674: LD_INT 0
13676: PPUSH
// if IsOk ( Scholtze ) or IsOK ( Kapitsova ) then
13677: LD_EXP 71
13681: PPUSH
13682: CALL_OW 302
13686: PUSH
13687: LD_EXP 75
13691: PPUSH
13692: CALL_OW 302
13696: OR
13697: IFFALSE 13793
// begin DialogueOn ;
13699: CALL_OW 6
// if IsOK ( Scholtze ) then
13703: LD_EXP 71
13707: PPUSH
13708: CALL_OW 302
13712: IFFALSE 13728
// Say ( Scholtze , DAI-Sch-1 ) else
13714: LD_EXP 71
13718: PPUSH
13719: LD_STRING DAI-Sch-1
13721: PPUSH
13722: CALL_OW 88
13726: GO 13740
// Say ( Kapitsova , DAI-Kap-1 ) ;
13728: LD_EXP 75
13732: PPUSH
13733: LD_STRING DAI-Kap-1
13735: PPUSH
13736: CALL_OW 88
// Say ( Burlak , DAI-Bur-1 ) ;
13740: LD_EXP 57
13744: PPUSH
13745: LD_STRING DAI-Bur-1
13747: PPUSH
13748: CALL_OW 88
// if IsOK ( Scholtze ) then
13752: LD_EXP 71
13756: PPUSH
13757: CALL_OW 302
13761: IFFALSE 13777
// Say ( Scholtze , DAI-Sch-2 ) else
13763: LD_EXP 71
13767: PPUSH
13768: LD_STRING DAI-Sch-2
13770: PPUSH
13771: CALL_OW 88
13775: GO 13789
// Say ( Kapitsova , DAI-Kap-2 ) ;
13777: LD_EXP 75
13781: PPUSH
13782: LD_STRING DAI-Kap-2
13784: PPUSH
13785: CALL_OW 88
// DialogueOff ;
13789: CALL_OW 7
// end ; ChangeMissionObjectives ( MAI ) ;
13793: LD_STRING MAI
13795: PPUSH
13796: CALL_OW 337
// end ;
13800: LD_VAR 0 1
13804: RET
// export function Dial_TeleportTechResearched ; begin
13805: LD_INT 0
13807: PPUSH
// if IsOk ( Scholtze ) or IsOK ( Kapitsova ) then
13808: LD_EXP 71
13812: PPUSH
13813: CALL_OW 302
13817: PUSH
13818: LD_EXP 75
13822: PPUSH
13823: CALL_OW 302
13827: OR
13828: IFFALSE 13936
// begin DialogueOn ;
13830: CALL_OW 6
// if IsOK ( Scholtze ) then
13834: LD_EXP 71
13838: PPUSH
13839: CALL_OW 302
13843: IFFALSE 13859
// Say ( Scholtze , DSpontTelep-Sch-1 ) else
13845: LD_EXP 71
13849: PPUSH
13850: LD_STRING DSpontTelep-Sch-1
13852: PPUSH
13853: CALL_OW 88
13857: GO 13871
// Say ( Kapitsova , DSpontTelep-Kap-1 ) ;
13859: LD_EXP 75
13863: PPUSH
13864: LD_STRING DSpontTelep-Kap-1
13866: PPUSH
13867: CALL_OW 88
// Say ( Burlak , DSpontTelep-Bur-1 ) ;
13871: LD_EXP 57
13875: PPUSH
13876: LD_STRING DSpontTelep-Bur-1
13878: PPUSH
13879: CALL_OW 88
// if IsOK ( Scholtze ) then
13883: LD_EXP 71
13887: PPUSH
13888: CALL_OW 302
13892: IFFALSE 13908
// Say ( Scholtze , DSpontTelep-Sch-2 ) else
13894: LD_EXP 71
13898: PPUSH
13899: LD_STRING DSpontTelep-Sch-2
13901: PPUSH
13902: CALL_OW 88
13906: GO 13920
// Say ( Kapitsova , DSpontTelep-Kap-2 ) ;
13908: LD_EXP 75
13912: PPUSH
13913: LD_STRING DSpontTelep-Kap-2
13915: PPUSH
13916: CALL_OW 88
// Say ( Burlak , DSpontTelep-Bur-2 ) ;
13920: LD_EXP 57
13924: PPUSH
13925: LD_STRING DSpontTelep-Bur-2
13927: PPUSH
13928: CALL_OW 88
// DialogueOff ;
13932: CALL_OW 7
// end ; ChangeMissionObjectives ( MTele ) ;
13936: LD_STRING MTele
13938: PPUSH
13939: CALL_OW 337
// end ;
13943: LD_VAR 0 1
13947: RET
// every 0 0$1 trigger buildingsToBuild <= 3 and GetAmountWeaponsDataBuildOnVehicle ( false ) <= 1 and techsToResearch <= 4 do
13948: LD_EXP 8
13952: PUSH
13953: LD_INT 3
13955: LESSEQUAL
13956: PUSH
13957: LD_INT 0
13959: PPUSH
13960: CALL 6800 0 1
13964: PUSH
13965: LD_INT 1
13967: LESSEQUAL
13968: AND
13969: PUSH
13970: LD_EXP 9
13974: PUSH
13975: LD_INT 4
13977: LESSEQUAL
13978: AND
13979: IFFALSE 14180
13981: GO 13983
13983: DISABLE
// begin SayRadio ( Popov , DAmAttackStart-Pop-1 ) ;
13984: LD_EXP 76
13988: PPUSH
13989: LD_STRING DAmAttackStart-Pop-1
13991: PPUSH
13992: CALL_OW 94
// if KurtStatus = 1 and HeikeStatus = 1 then
13996: LD_EXP 22
14000: PUSH
14001: LD_INT 1
14003: EQUAL
14004: PUSH
14005: LD_EXP 3
14009: PUSH
14010: LD_INT 1
14012: EQUAL
14013: AND
14014: IFFALSE 14172
// begin wait ( 0 0$10 ) ;
14016: LD_INT 350
14018: PPUSH
14019: CALL_OW 67
// DialogueOn ;
14023: CALL_OW 6
// SayRadio ( Heike , DLegionFormed-Hke-1 ) ;
14027: LD_EXP 79
14031: PPUSH
14032: LD_STRING DLegionFormed-Hke-1
14034: PPUSH
14035: CALL_OW 94
// Say ( Burlak , DLegionFormed-Bur-1 ) ;
14039: LD_EXP 57
14043: PPUSH
14044: LD_STRING DLegionFormed-Bur-1
14046: PPUSH
14047: CALL_OW 88
// SayRadio ( Heike , DLegionFormed-Hke-2 ) ;
14051: LD_EXP 79
14055: PPUSH
14056: LD_STRING DLegionFormed-Hke-2
14058: PPUSH
14059: CALL_OW 94
// Say ( Burlak , DLegionFormed-Bur-2 ) ;
14063: LD_EXP 57
14067: PPUSH
14068: LD_STRING DLegionFormed-Bur-2
14070: PPUSH
14071: CALL_OW 88
// SayRadio ( Heike , DLegionFormed-Hke-3 ) ;
14075: LD_EXP 79
14079: PPUSH
14080: LD_STRING DLegionFormed-Hke-3
14082: PPUSH
14083: CALL_OW 94
// case Query ( QLegion ) of 1 :
14087: LD_STRING QLegion
14089: PPUSH
14090: CALL_OW 97
14094: PUSH
14095: LD_INT 1
14097: DOUBLE
14098: EQUAL
14099: IFTRUE 14103
14101: GO 14134
14103: POP
// begin acceptLegionOffert = true ;
14104: LD_ADDR_EXP 31
14108: PUSH
14109: LD_INT 1
14111: ST_TO_ADDR
// legionOffertCountdown = true ;
14112: LD_ADDR_EXP 33
14116: PUSH
14117: LD_INT 1
14119: ST_TO_ADDR
// Say ( Burlak , DQrLegion#1-Bur-1 ) ;
14120: LD_EXP 57
14124: PPUSH
14125: LD_STRING DQrLegion#1-Bur-1
14127: PPUSH
14128: CALL_OW 88
// end ; 2 :
14132: GO 14166
14134: LD_INT 2
14136: DOUBLE
14137: EQUAL
14138: IFTRUE 14142
14140: GO 14165
14142: POP
// begin Say ( Burlak , DQrLegion#2-Bur-1 ) ;
14143: LD_EXP 57
14147: PPUSH
14148: LD_STRING DQrLegion#2-Bur-1
14150: PPUSH
14151: CALL_OW 88
// americansAttack = true ;
14155: LD_ADDR_EXP 26
14159: PUSH
14160: LD_INT 1
14162: ST_TO_ADDR
// end ; end ;
14163: GO 14166
14165: POP
// DialogueOff ;
14166: CALL_OW 7
// end else
14170: GO 14180
// begin americansAttack = true ;
14172: LD_ADDR_EXP 26
14176: PUSH
14177: LD_INT 1
14179: ST_TO_ADDR
// end ; end ;
14180: END
// every 0 0$1 trigger legionOffertTime <= 0 0$00 do
14181: LD_EXP 34
14185: PUSH
14186: LD_INT 0
14188: LESSEQUAL
14189: IFFALSE 14210
14191: GO 14193
14193: DISABLE
// begin legionOffertCountdown = false ;
14194: LD_ADDR_EXP 33
14198: PUSH
14199: LD_INT 0
14201: ST_TO_ADDR
// americansAttack = true ;
14202: LD_ADDR_EXP 26
14206: PUSH
14207: LD_INT 1
14209: ST_TO_ADDR
// end ;
14210: END
// every 0 0$1 trigger legionOffertCountdown do var needCrates , depots , depot , crates ;
14211: LD_EXP 33
14215: IFFALSE 14401
14217: GO 14219
14219: DISABLE
14220: LD_INT 0
14222: PPUSH
14223: PPUSH
14224: PPUSH
14225: PPUSH
// begin needCrates = 50 ;
14226: LD_ADDR_VAR 0 1
14230: PUSH
14231: LD_INT 50
14233: ST_TO_ADDR
// crates = 0 ;
14234: LD_ADDR_VAR 0 4
14238: PUSH
14239: LD_INT 0
14241: ST_TO_ADDR
// depots = FilterAllUnits ( [ [ f_side , 3 ] , [ [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ] ) ;
14242: LD_ADDR_VAR 0 2
14246: PUSH
14247: LD_INT 22
14249: PUSH
14250: LD_INT 3
14252: PUSH
14253: EMPTY
14254: LIST
14255: LIST
14256: PUSH
14257: LD_INT 2
14259: PUSH
14260: LD_INT 30
14262: PUSH
14263: LD_INT 0
14265: PUSH
14266: EMPTY
14267: LIST
14268: LIST
14269: PUSH
14270: LD_INT 30
14272: PUSH
14273: LD_INT 1
14275: PUSH
14276: EMPTY
14277: LIST
14278: LIST
14279: PUSH
14280: EMPTY
14281: LIST
14282: LIST
14283: LIST
14284: PUSH
14285: EMPTY
14286: LIST
14287: PUSH
14288: EMPTY
14289: LIST
14290: LIST
14291: PPUSH
14292: CALL_OW 69
14296: ST_TO_ADDR
// for depot in depots do
14297: LD_ADDR_VAR 0 3
14301: PUSH
14302: LD_VAR 0 2
14306: PUSH
14307: FOR_IN
14308: IFFALSE 14399
// begin crates = GetResourceType ( GetBase ( depot ) , mat_cans ) ;
14310: LD_ADDR_VAR 0 4
14314: PUSH
14315: LD_VAR 0 3
14319: PPUSH
14320: CALL_OW 274
14324: PPUSH
14325: LD_INT 1
14327: PPUSH
14328: CALL_OW 275
14332: ST_TO_ADDR
// if crates >= needCrates then
14333: LD_VAR 0 4
14337: PUSH
14338: LD_VAR 0 1
14342: GREATEREQUAL
14343: IFFALSE 14397
// begin SetResourceType ( GetBase ( depot ) , mat_cans , crates - needCrates ) ;
14345: LD_VAR 0 3
14349: PPUSH
14350: CALL_OW 274
14354: PPUSH
14355: LD_INT 1
14357: PPUSH
14358: LD_VAR 0 4
14362: PUSH
14363: LD_VAR 0 1
14367: MINUS
14368: PPUSH
14369: CALL_OW 277
// legionOffertCountdown = false ;
14373: LD_ADDR_EXP 33
14377: PUSH
14378: LD_INT 0
14380: ST_TO_ADDR
// paidLegionOffert = true ;
14381: LD_ADDR_EXP 32
14385: PUSH
14386: LD_INT 1
14388: ST_TO_ADDR
// americansAttack = true ;
14389: LD_ADDR_EXP 26
14393: PUSH
14394: LD_INT 1
14396: ST_TO_ADDR
// end ; end ;
14397: GO 14307
14399: POP
14400: POP
// end ;
14401: PPOPN 4
14403: END
// every 0 0$1 trigger currentAmWave >= americansAttackWaves and FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_type , unit_human ] , [ f_and , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ] ] ) = 0 do
14404: LD_EXP 85
14408: PUSH
14409: LD_EXP 48
14413: GREATEREQUAL
14414: PUSH
14415: LD_INT 22
14417: PUSH
14418: LD_INT 1
14420: PUSH
14421: EMPTY
14422: LIST
14423: LIST
14424: PUSH
14425: LD_INT 2
14427: PUSH
14428: LD_INT 21
14430: PUSH
14431: LD_INT 1
14433: PUSH
14434: EMPTY
14435: LIST
14436: LIST
14437: PUSH
14438: LD_INT 1
14440: PUSH
14441: LD_INT 21
14443: PUSH
14444: LD_INT 2
14446: PUSH
14447: EMPTY
14448: LIST
14449: LIST
14450: PUSH
14451: LD_INT 33
14453: PUSH
14454: LD_INT 3
14456: PUSH
14457: EMPTY
14458: LIST
14459: LIST
14460: PUSH
14461: EMPTY
14462: LIST
14463: LIST
14464: LIST
14465: PUSH
14466: EMPTY
14467: LIST
14468: LIST
14469: LIST
14470: PUSH
14471: EMPTY
14472: LIST
14473: LIST
14474: PPUSH
14475: CALL_OW 69
14479: PUSH
14480: LD_INT 0
14482: EQUAL
14483: AND
14484: IFFALSE 14684
14486: GO 14488
14488: DISABLE
// begin DialogueOn ;
14489: CALL_OW 6
// if IsOK ( Belkov ) then
14493: LD_EXP 66
14497: PPUSH
14498: CALL_OW 302
14502: IFFALSE 14518
// Say ( Belkov , DAmAttackFin-Bel-1 ) else
14504: LD_EXP 66
14508: PPUSH
14509: LD_STRING DAmAttackFin-Bel-1
14511: PPUSH
14512: CALL_OW 88
14516: GO 14541
// if IsOK ( Belkov2 ) then
14518: LD_EXP 67
14522: PPUSH
14523: CALL_OW 302
14527: IFFALSE 14541
// Say ( Belkov2 , DAmAttackFin-Bel-1 ) ;
14529: LD_EXP 67
14533: PPUSH
14534: LD_STRING DAmAttackFin-Bel-1
14536: PPUSH
14537: CALL_OW 88
// if IsOK ( Gnyevko ) then
14541: LD_EXP 69
14545: PPUSH
14546: CALL_OW 302
14550: IFFALSE 14564
// Say ( Gnyevko , DAmAttackFin-Gny-1 ) ;
14552: LD_EXP 69
14556: PPUSH
14557: LD_STRING DAmAttackFin-Gny-1
14559: PPUSH
14560: CALL_OW 88
// if IsOK ( Titov ) then
14564: LD_EXP 62
14568: PPUSH
14569: CALL_OW 302
14573: IFFALSE 14587
// Say ( Titov , DAmAttackFin-Tit-1 ) ;
14575: LD_EXP 62
14579: PPUSH
14580: LD_STRING DAmAttackFin-Tit-1
14582: PPUSH
14583: CALL_OW 88
// if IsOK ( Lipshchin ) then
14587: LD_EXP 64
14591: PPUSH
14592: CALL_OW 302
14596: IFFALSE 14610
// Say ( Lipshchin , DAmAttackFin-Lip-1 ) ;
14598: LD_EXP 64
14602: PPUSH
14603: LD_STRING DAmAttackFin-Lip-1
14605: PPUSH
14606: CALL_OW 88
// if IsOK ( Karamazov ) then
14610: LD_EXP 58
14614: PPUSH
14615: CALL_OW 302
14619: IFFALSE 14633
// Say ( Karamazov , DAmAttackFin-Kar-1 ) ;
14621: LD_EXP 58
14625: PPUSH
14626: LD_STRING DAmAttackFin-Kar-1
14628: PPUSH
14629: CALL_OW 88
// if IsOK ( Oblukov ) then
14633: LD_EXP 74
14637: PPUSH
14638: CALL_OW 302
14642: IFFALSE 14656
// Say ( Oblukov , DAmAttackFin-Obl-1 ) ;
14644: LD_EXP 74
14648: PPUSH
14649: LD_STRING DAmAttackFin-Obl-1
14651: PPUSH
14652: CALL_OW 88
// Say ( Burlak , AmAttackFin-Bur-1 ) ;
14656: LD_EXP 57
14660: PPUSH
14661: LD_STRING AmAttackFin-Bur-1
14663: PPUSH
14664: CALL_OW 88
// SayRadio ( Popov , DAmAttackFin-Pop-1 ) ;
14668: LD_EXP 76
14672: PPUSH
14673: LD_STRING DAmAttackFin-Pop-1
14675: PPUSH
14676: CALL_OW 94
// DialogueOff ;
14680: CALL_OW 7
// end ;
14684: END
// every 0 0$1 trigger buildingsToBuild + ( 3 - GetAmountWeaponsDataBuildOnTurret ( true ) ) = 0 do
14685: LD_EXP 8
14689: PUSH
14690: LD_INT 3
14692: PUSH
14693: LD_INT 1
14695: PPUSH
14696: CALL 6690 0 1
14700: MINUS
14701: PLUS
14702: PUSH
14703: LD_INT 0
14705: EQUAL
14706: IFFALSE 14718
14708: GO 14710
14710: DISABLE
// ChangeMissionObjectives ( MBuildingsDone ) ;
14711: LD_STRING MBuildingsDone
14713: PPUSH
14714: CALL_OW 337
14718: END
// every 0 0$1 trigger GetAmountWeaponsDataBuildOnVehicle ( false ) = 0 do
14719: LD_INT 0
14721: PPUSH
14722: CALL 6800 0 1
14726: PUSH
14727: LD_INT 0
14729: EQUAL
14730: IFFALSE 14742
14732: GO 14734
14734: DISABLE
// ChangeMissionObjectives ( MWeaponsDone ) ;
14735: LD_STRING MWeaponsDone
14737: PPUSH
14738: CALL_OW 337
14742: END
// every 0 0$1 trigger techsToResearch = 0 do
14743: LD_EXP 9
14747: PUSH
14748: LD_INT 0
14750: EQUAL
14751: IFFALSE 14763
14753: GO 14755
14755: DISABLE
// ChangeMissionObjectives ( MTechnoDone ) ;
14756: LD_STRING MTechnoDone
14758: PPUSH
14759: CALL_OW 337
14763: END
// every 0 0$1 trigger americansAttack and not FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_type , unit_human ] , [ f_and , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ] ] ) do
14764: LD_EXP 26
14768: PUSH
14769: LD_INT 22
14771: PUSH
14772: LD_INT 1
14774: PUSH
14775: EMPTY
14776: LIST
14777: LIST
14778: PUSH
14779: LD_INT 2
14781: PUSH
14782: LD_INT 21
14784: PUSH
14785: LD_INT 1
14787: PUSH
14788: EMPTY
14789: LIST
14790: LIST
14791: PUSH
14792: LD_INT 1
14794: PUSH
14795: LD_INT 21
14797: PUSH
14798: LD_INT 2
14800: PUSH
14801: EMPTY
14802: LIST
14803: LIST
14804: PUSH
14805: LD_INT 33
14807: PUSH
14808: LD_INT 3
14810: PUSH
14811: EMPTY
14812: LIST
14813: LIST
14814: PUSH
14815: EMPTY
14816: LIST
14817: LIST
14818: LIST
14819: PUSH
14820: EMPTY
14821: LIST
14822: LIST
14823: LIST
14824: PUSH
14825: EMPTY
14826: LIST
14827: LIST
14828: PPUSH
14829: CALL_OW 69
14833: NOT
14834: AND
14835: IFFALSE 14847
14837: GO 14839
14839: DISABLE
// ChangeMissionObjectives ( MEnemyDone ) ;
14840: LD_STRING MEnemyDone
14842: PPUSH
14843: CALL_OW 337
14847: END
// every 0 0$1 trigger ( buildingsToBuild + ( 3 - GetAmountWeaponsDataBuildOnTurret ( true ) ) ) = 0 and GetAmountWeaponsDataBuildOnVehicle ( false ) = 0 and techsToResearch = 0 and FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] ] ) = 0 and FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_type , unit_human ] , [ f_and , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ] ] ) = 0 and Masha and IsOK ( Masha [ 1 ] ) and buildCompVehicle and testedTeleport do
14848: LD_EXP 8
14852: PUSH
14853: LD_INT 3
14855: PUSH
14856: LD_INT 1
14858: PPUSH
14859: CALL 6690 0 1
14863: MINUS
14864: PLUS
14865: PUSH
14866: LD_INT 0
14868: EQUAL
14869: PUSH
14870: LD_INT 0
14872: PPUSH
14873: CALL 6800 0 1
14877: PUSH
14878: LD_INT 0
14880: EQUAL
14881: AND
14882: PUSH
14883: LD_EXP 9
14887: PUSH
14888: LD_INT 0
14890: EQUAL
14891: AND
14892: PUSH
14893: LD_INT 22
14895: PUSH
14896: LD_INT 8
14898: PUSH
14899: EMPTY
14900: LIST
14901: LIST
14902: PUSH
14903: LD_INT 21
14905: PUSH
14906: LD_INT 1
14908: PUSH
14909: EMPTY
14910: LIST
14911: LIST
14912: PUSH
14913: EMPTY
14914: LIST
14915: LIST
14916: PPUSH
14917: CALL_OW 69
14921: PUSH
14922: LD_INT 0
14924: EQUAL
14925: AND
14926: PUSH
14927: LD_INT 22
14929: PUSH
14930: LD_INT 1
14932: PUSH
14933: EMPTY
14934: LIST
14935: LIST
14936: PUSH
14937: LD_INT 2
14939: PUSH
14940: LD_INT 21
14942: PUSH
14943: LD_INT 1
14945: PUSH
14946: EMPTY
14947: LIST
14948: LIST
14949: PUSH
14950: LD_INT 1
14952: PUSH
14953: LD_INT 21
14955: PUSH
14956: LD_INT 2
14958: PUSH
14959: EMPTY
14960: LIST
14961: LIST
14962: PUSH
14963: LD_INT 33
14965: PUSH
14966: LD_INT 3
14968: PUSH
14969: EMPTY
14970: LIST
14971: LIST
14972: PUSH
14973: EMPTY
14974: LIST
14975: LIST
14976: LIST
14977: PUSH
14978: EMPTY
14979: LIST
14980: LIST
14981: LIST
14982: PUSH
14983: EMPTY
14984: LIST
14985: LIST
14986: PPUSH
14987: CALL_OW 69
14991: PUSH
14992: LD_INT 0
14994: EQUAL
14995: AND
14996: PUSH
14997: LD_EXP 4
15001: AND
15002: PUSH
15003: LD_EXP 4
15007: PUSH
15008: LD_INT 1
15010: ARRAY
15011: PPUSH
15012: CALL_OW 302
15016: AND
15017: PUSH
15018: LD_EXP 37
15022: AND
15023: PUSH
15024: LD_EXP 39
15028: AND
15029: IFFALSE 15038
15031: GO 15033
15033: DISABLE
// begin FinishMission ;
15034: CALL 15243 0 0
// end ;
15038: END
// every 0 0$1 do var unit ;
15039: GO 15041
15041: DISABLE
15042: LD_INT 0
15044: PPUSH
// begin case allowExitFromMap of 1 :
15045: LD_EXP 18
15049: PUSH
15050: LD_INT 1
15052: DOUBLE
15053: EQUAL
15054: IFTRUE 15058
15056: GO 15086
15058: POP
// RemoveUnits ( FilterUnitsInArea ( ExitMapArea , [ [ f_side , 6 ] ] ) ) ; 3 :
15059: LD_INT 8
15061: PPUSH
15062: LD_INT 22
15064: PUSH
15065: LD_INT 6
15067: PUSH
15068: EMPTY
15069: LIST
15070: LIST
15071: PUSH
15072: EMPTY
15073: LIST
15074: PPUSH
15075: CALL_OW 70
15079: PPUSH
15080: CALL 6526 0 1
15084: GO 15209
15086: LD_INT 3
15088: DOUBLE
15089: EQUAL
15090: IFTRUE 15094
15092: GO 15122
15094: POP
// RemoveUnits ( FilterUnitsInArea ( KurtExitMapArea , [ [ f_side , 8 ] ] ) ) ; 4 :
15095: LD_INT 11
15097: PPUSH
15098: LD_INT 22
15100: PUSH
15101: LD_INT 8
15103: PUSH
15104: EMPTY
15105: LIST
15106: LIST
15107: PUSH
15108: EMPTY
15109: LIST
15110: PPUSH
15111: CALL_OW 70
15115: PPUSH
15116: CALL 6526 0 1
15120: GO 15209
15122: LD_INT 4
15124: DOUBLE
15125: EQUAL
15126: IFTRUE 15130
15128: GO 15208
15130: POP
// begin RemoveUnits ( FilterUnitsInArea ( ExitMapArea , [ [ f_side , 8 ] ] ) ) ;
15131: LD_INT 8
15133: PPUSH
15134: LD_INT 22
15136: PUSH
15137: LD_INT 8
15139: PUSH
15140: EMPTY
15141: LIST
15142: LIST
15143: PUSH
15144: EMPTY
15145: LIST
15146: PPUSH
15147: CALL_OW 70
15151: PPUSH
15152: CALL 6526 0 1
// RemoveUnits ( FilterUnitsInArea ( KurtExitMapArea , [ [ f_side , 8 ] ] ) ) ;
15156: LD_INT 11
15158: PPUSH
15159: LD_INT 22
15161: PUSH
15162: LD_INT 8
15164: PUSH
15165: EMPTY
15166: LIST
15167: LIST
15168: PUSH
15169: EMPTY
15170: LIST
15171: PPUSH
15172: CALL_OW 70
15176: PPUSH
15177: CALL 6526 0 1
// RemoveUnits ( FilterUnitsInArea ( ExitMapArea , [ [ f_side , 2 ] ] ) ) ;
15181: LD_INT 8
15183: PPUSH
15184: LD_INT 22
15186: PUSH
15187: LD_INT 2
15189: PUSH
15190: EMPTY
15191: LIST
15192: LIST
15193: PUSH
15194: EMPTY
15195: LIST
15196: PPUSH
15197: CALL_OW 70
15201: PPUSH
15202: CALL 6526 0 1
// end ; end ;
15206: GO 15209
15208: POP
// enable ;
15209: ENABLE
// end ; end_of_file
15210: PPOPN 1
15212: END
// export function Lose_Burlak ; begin
15213: LD_INT 0
15215: PPUSH
// YouLost ( Burlak ) ;
15216: LD_STRING Burlak
15218: PPUSH
15219: CALL_OW 104
// end ;
15223: LD_VAR 0 1
15227: RET
// export function Lost_AttackAlly ; begin
15228: LD_INT 0
15230: PPUSH
// YouLost ( SelfAttack ) ;
15231: LD_STRING SelfAttack
15233: PPUSH
15234: CALL_OW 104
// end ; end_of_file
15238: LD_VAR 0 1
15242: RET
// export function FinishMission ; begin
15243: LD_INT 0
15245: PPUSH
// SetRewards ;
15246: CALL 15267 0 0
// SavePlayerCharacters ;
15250: CALL 15528 0 0
// SaveGlobalVariables ;
15254: CALL 16078 0 0
// YouWin ;
15258: CALL_OW 103
// end ;
15262: LD_VAR 0 1
15266: RET
// function SetRewards ; begin
15267: LD_INT 0
15269: PPUSH
// AddMedal ( ArtisticImpression , 1 ) ;
15270: LD_STRING ArtisticImpression
15272: PPUSH
15273: LD_INT 1
15275: PPUSH
15276: CALL_OW 101
// if not HeikeCaptured then
15280: LD_EXP 1
15284: NOT
15285: IFFALSE 15319
// begin if speedMedalTime >= 0 0$00 then
15287: LD_EXP 52
15291: PUSH
15292: LD_INT 0
15294: GREATEREQUAL
15295: IFFALSE 15309
// AddMedal ( Speed , 1 ) else
15297: LD_STRING Speed
15299: PPUSH
15300: LD_INT 1
15302: PPUSH
15303: CALL_OW 101
15307: GO 15319
// AddMedal ( Speed , 1 ) ;
15309: LD_STRING Speed
15311: PPUSH
15312: LD_INT 1
15314: PPUSH
15315: CALL_OW 101
// end ; if lostUnits then
15319: LD_EXP 40
15323: IFFALSE 15338
// begin AddMedal ( FavouriteCommander , - 1 ) ;
15325: LD_STRING FavouriteCommander
15327: PPUSH
15328: LD_INT 1
15330: NEG
15331: PPUSH
15332: CALL_OW 101
// end else
15336: GO 15430
// begin case BurlakRespect of 0 :
15338: LD_EXP 30
15342: PUSH
15343: LD_INT 0
15345: DOUBLE
15346: EQUAL
15347: IFTRUE 15351
15349: GO 15365
15351: POP
// AddMedal ( FavouriteCommander , - 2 ) ; 1 :
15352: LD_STRING FavouriteCommander
15354: PPUSH
15355: LD_INT 2
15357: NEG
15358: PPUSH
15359: CALL_OW 101
15363: GO 15430
15365: LD_INT 1
15367: DOUBLE
15368: EQUAL
15369: IFTRUE 15373
15371: GO 15387
15373: POP
// AddMedal ( FavouriteCommander , - 3 ) ; 2 :
15374: LD_STRING FavouriteCommander
15376: PPUSH
15377: LD_INT 3
15379: NEG
15380: PPUSH
15381: CALL_OW 101
15385: GO 15430
15387: LD_INT 2
15389: DOUBLE
15390: EQUAL
15391: IFTRUE 15395
15393: GO 15408
15395: POP
// AddMedal ( FavouriteCommander , 1 ) ; 3 :
15396: LD_STRING FavouriteCommander
15398: PPUSH
15399: LD_INT 1
15401: PPUSH
15402: CALL_OW 101
15406: GO 15430
15408: LD_INT 3
15410: DOUBLE
15411: EQUAL
15412: IFTRUE 15416
15414: GO 15429
15416: POP
// AddMedal ( FavouriteCommander , 1 ) ; end ;
15417: LD_STRING FavouriteCommander
15419: PPUSH
15420: LD_INT 1
15422: PPUSH
15423: CALL_OW 101
15427: GO 15430
15429: POP
// end ; if HeikeCaptured then
15430: LD_EXP 1
15434: IFFALSE 15465
// begin if buildArabBarrack then
15436: LD_EXP 38
15440: IFFALSE 15454
// AddMedal ( ArabBarracks , 1 ) else
15442: LD_STRING ArabBarracks
15444: PPUSH
15445: LD_INT 1
15447: PPUSH
15448: CALL_OW 101
15452: GO 15465
// AddMedal ( ArabBarracks , - 1 ) ;
15454: LD_STRING ArabBarracks
15456: PPUSH
15457: LD_INT 1
15459: NEG
15460: PPUSH
15461: CALL_OW 101
// end ; GiveMedals ( Main1 ) ;
15465: LD_STRING Main1
15467: PPUSH
15468: CALL_OW 102
// RewardPeople ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_nation , nation_russian ] , [ f_ok ] ] ) ) ;
15472: LD_INT 22
15474: PUSH
15475: LD_INT 3
15477: PUSH
15478: EMPTY
15479: LIST
15480: LIST
15481: PUSH
15482: LD_INT 21
15484: PUSH
15485: LD_INT 1
15487: PUSH
15488: EMPTY
15489: LIST
15490: LIST
15491: PUSH
15492: LD_INT 23
15494: PUSH
15495: LD_INT 3
15497: PUSH
15498: EMPTY
15499: LIST
15500: LIST
15501: PUSH
15502: LD_INT 50
15504: PUSH
15505: EMPTY
15506: LIST
15507: PUSH
15508: EMPTY
15509: LIST
15510: LIST
15511: LIST
15512: LIST
15513: PPUSH
15514: CALL_OW 69
15518: PPUSH
15519: CALL_OW 43
// end ;
15523: LD_VAR 0 1
15527: RET
// function SavePlayerCharacters ; var randomsToSave ; begin
15528: LD_INT 0
15530: PPUSH
15531: PPUSH
// ExtSaveCharacter ( Burlak , Burlak , 3 ) ;
15532: LD_EXP 57
15536: PPUSH
15537: LD_STRING Burlak
15539: PPUSH
15540: LD_INT 3
15542: PPUSH
15543: CALL 6048 0 3
// ExtSaveCharacter ( Karamazov , Karamazov , 3 ) ;
15547: LD_EXP 58
15551: PPUSH
15552: LD_STRING Karamazov
15554: PPUSH
15555: LD_INT 3
15557: PPUSH
15558: CALL 6048 0 3
// ExtSaveCharacter ( Petrovova , Petrovova , 3 ) ;
15562: LD_EXP 59
15566: PPUSH
15567: LD_STRING Petrovova
15569: PPUSH
15570: LD_INT 3
15572: PPUSH
15573: CALL 6048 0 3
// ExtSaveCharacter ( Gleb , Gleb , 3 ) ;
15577: LD_EXP 60
15581: PPUSH
15582: LD_STRING Gleb
15584: PPUSH
15585: LD_INT 3
15587: PPUSH
15588: CALL 6048 0 3
// ExtSaveCharacter ( Petrosyan , Petrosyan , 3 ) ;
15592: LD_EXP 61
15596: PPUSH
15597: LD_STRING Petrosyan
15599: PPUSH
15600: LD_INT 3
15602: PPUSH
15603: CALL 6048 0 3
// ExtSaveCharacter ( Dolgov , Dolgov , 3 ) ;
15607: LD_EXP 63
15611: PPUSH
15612: LD_STRING Dolgov
15614: PPUSH
15615: LD_INT 3
15617: PPUSH
15618: CALL 6048 0 3
// ExtSaveCharacter ( Lipshchin , Lipshchin , 3 ) ;
15622: LD_EXP 64
15626: PPUSH
15627: LD_STRING Lipshchin
15629: PPUSH
15630: LD_INT 3
15632: PPUSH
15633: CALL 6048 0 3
// ExtSaveCharacter ( Titov , Titov , 3 ) ;
15637: LD_EXP 62
15641: PPUSH
15642: LD_STRING Titov
15644: PPUSH
15645: LD_INT 3
15647: PPUSH
15648: CALL 6048 0 3
// ExtSaveCharacter ( Kirilenkova , Kirilenkova , 3 ) ;
15652: LD_EXP 65
15656: PPUSH
15657: LD_STRING Kirilenkova
15659: PPUSH
15660: LD_INT 3
15662: PPUSH
15663: CALL 6048 0 3
// ExtSaveCharacter ( Belkov , Belkov , 3 ) ;
15667: LD_EXP 66
15671: PPUSH
15672: LD_STRING Belkov
15674: PPUSH
15675: LD_INT 3
15677: PPUSH
15678: CALL 6048 0 3
// ExtSaveCharacter ( Belkov2 , Belkov2 , 3 ) ;
15682: LD_EXP 67
15686: PPUSH
15687: LD_STRING Belkov2
15689: PPUSH
15690: LD_INT 3
15692: PPUSH
15693: CALL 6048 0 3
// ExtSaveCharacter ( Xavier , Xavier , 3 ) ;
15697: LD_EXP 68
15701: PPUSH
15702: LD_STRING Xavier
15704: PPUSH
15705: LD_INT 3
15707: PPUSH
15708: CALL 6048 0 3
// ExtSaveCharacter ( Kozlov , Kozlov , 3 ) ;
15712: LD_EXP 73
15716: PPUSH
15717: LD_STRING Kozlov
15719: PPUSH
15720: LD_INT 3
15722: PPUSH
15723: CALL 6048 0 3
// ExtSaveCharacter ( Oblukov , Oblukov , 3 ) ;
15727: LD_EXP 74
15731: PPUSH
15732: LD_STRING Oblukov
15734: PPUSH
15735: LD_INT 3
15737: PPUSH
15738: CALL 6048 0 3
// ExtSaveCharacter ( Kapitsova , Kapitsova , 3 ) ;
15742: LD_EXP 75
15746: PPUSH
15747: LD_STRING Kapitsova
15749: PPUSH
15750: LD_INT 3
15752: PPUSH
15753: CALL 6048 0 3
// ExtSaveCharacter ( Gnyevko , Gnyevko , 3 ) ;
15757: LD_EXP 69
15761: PPUSH
15762: LD_STRING Gnyevko
15764: PPUSH
15765: LD_INT 3
15767: PPUSH
15768: CALL 6048 0 3
// ExtSaveCharacter ( Kovalyuk , Kovalyuk , 3 ) ;
15772: LD_EXP 70
15776: PPUSH
15777: LD_STRING Kovalyuk
15779: PPUSH
15780: LD_INT 3
15782: PPUSH
15783: CALL 6048 0 3
// ExtSaveCharacter ( Scholtze , Scholtze , 3 ) ;
15787: LD_EXP 71
15791: PPUSH
15792: LD_STRING Scholtze
15794: PPUSH
15795: LD_INT 3
15797: PPUSH
15798: CALL 6048 0 3
// ExtSaveCharacter ( Kuzmov , Kuzmov , 3 ) ;
15802: LD_EXP 72
15806: PPUSH
15807: LD_STRING Kuzmov
15809: PPUSH
15810: LD_INT 3
15812: PPUSH
15813: CALL 6048 0 3
// ExtSaveCharacters ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_or , [ f_class , class_apeman ] , [ f_class , class_apeman_engineer ] , [ f_class , class_apeman_soldier ] ] ] ) , other_apemans , 3 ) ;
15817: LD_INT 22
15819: PUSH
15820: LD_INT 3
15822: PUSH
15823: EMPTY
15824: LIST
15825: LIST
15826: PUSH
15827: LD_INT 21
15829: PUSH
15830: LD_INT 1
15832: PUSH
15833: EMPTY
15834: LIST
15835: LIST
15836: PUSH
15837: LD_INT 2
15839: PUSH
15840: LD_INT 25
15842: PUSH
15843: LD_INT 12
15845: PUSH
15846: EMPTY
15847: LIST
15848: LIST
15849: PUSH
15850: LD_INT 25
15852: PUSH
15853: LD_INT 16
15855: PUSH
15856: EMPTY
15857: LIST
15858: LIST
15859: PUSH
15860: LD_INT 25
15862: PUSH
15863: LD_INT 15
15865: PUSH
15866: EMPTY
15867: LIST
15868: LIST
15869: PUSH
15870: EMPTY
15871: LIST
15872: LIST
15873: LIST
15874: LIST
15875: PUSH
15876: EMPTY
15877: LIST
15878: LIST
15879: LIST
15880: PPUSH
15881: CALL_OW 69
15885: PPUSH
15886: LD_STRING other_apemans
15888: PPUSH
15889: LD_INT 3
15891: PPUSH
15892: CALL 6105 0 3
// randomsToSave = FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_nation , nation_russian ] ] ) diff [ Burlak , Karamazov , Petrovova , Gleb , Petrosyan , Titov , Dolgov , Lipshchin , Kirilenkova , Belkov , Belkov2 , Xavier , Gnyevko , Kovalyuk , Scholtze , Kuzmov , Kozlov , Oblukov , Kapitsova ] ;
15896: LD_ADDR_VAR 0 2
15900: PUSH
15901: LD_INT 22
15903: PUSH
15904: LD_INT 3
15906: PUSH
15907: EMPTY
15908: LIST
15909: LIST
15910: PUSH
15911: LD_INT 21
15913: PUSH
15914: LD_INT 1
15916: PUSH
15917: EMPTY
15918: LIST
15919: LIST
15920: PUSH
15921: LD_INT 23
15923: PUSH
15924: LD_INT 3
15926: PUSH
15927: EMPTY
15928: LIST
15929: LIST
15930: PUSH
15931: EMPTY
15932: LIST
15933: LIST
15934: LIST
15935: PPUSH
15936: CALL_OW 69
15940: PUSH
15941: LD_EXP 57
15945: PUSH
15946: LD_EXP 58
15950: PUSH
15951: LD_EXP 59
15955: PUSH
15956: LD_EXP 60
15960: PUSH
15961: LD_EXP 61
15965: PUSH
15966: LD_EXP 62
15970: PUSH
15971: LD_EXP 63
15975: PUSH
15976: LD_EXP 64
15980: PUSH
15981: LD_EXP 65
15985: PUSH
15986: LD_EXP 66
15990: PUSH
15991: LD_EXP 67
15995: PUSH
15996: LD_EXP 68
16000: PUSH
16001: LD_EXP 69
16005: PUSH
16006: LD_EXP 70
16010: PUSH
16011: LD_EXP 71
16015: PUSH
16016: LD_EXP 72
16020: PUSH
16021: LD_EXP 73
16025: PUSH
16026: LD_EXP 74
16030: PUSH
16031: LD_EXP 75
16035: PUSH
16036: EMPTY
16037: LIST
16038: LIST
16039: LIST
16040: LIST
16041: LIST
16042: LIST
16043: LIST
16044: LIST
16045: LIST
16046: LIST
16047: LIST
16048: LIST
16049: LIST
16050: LIST
16051: LIST
16052: LIST
16053: LIST
16054: LIST
16055: LIST
16056: DIFF
16057: ST_TO_ADDR
// ExtSaveCharacters ( randomsToSave , other_survivors , 3 ) ;
16058: LD_VAR 0 2
16062: PPUSH
16063: LD_STRING other_survivors
16065: PPUSH
16066: LD_INT 3
16068: PPUSH
16069: CALL 6105 0 3
// end ;
16073: LD_VAR 0 1
16077: RET
// function SaveGlobalVariables ; begin
16078: LD_INT 0
16080: PPUSH
// SaveBase ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_building ] ] ) , 08_TrockyBase_1 ) ;
16081: LD_INT 22
16083: PUSH
16084: LD_INT 3
16086: PUSH
16087: EMPTY
16088: LIST
16089: LIST
16090: PUSH
16091: LD_INT 21
16093: PUSH
16094: LD_INT 3
16096: PUSH
16097: EMPTY
16098: LIST
16099: LIST
16100: PUSH
16101: EMPTY
16102: LIST
16103: LIST
16104: PPUSH
16105: CALL_OW 69
16109: PPUSH
16110: LD_STRING 08_TrockyBase_1
16112: PPUSH
16113: CALL 8484 0 2
// SaveVariable ( coopWithGensher , 08_CoopWithGensher_2 ) ;
16117: LD_EXP 2
16121: PPUSH
16122: LD_STRING 08_CoopWithGensher_2
16124: PPUSH
16125: CALL_OW 39
// SaveVariable ( HeikeStatus , 08_HeikeStatus_3 ) ;
16129: LD_EXP 3
16133: PPUSH
16134: LD_STRING 08_HeikeStatus_3
16136: PPUSH
16137: CALL_OW 39
// SaveVariable ( Masha , 08_Masha_4 ) ;
16141: LD_EXP 4
16145: PPUSH
16146: LD_STRING 08_Masha_4
16148: PPUSH
16149: CALL_OW 39
// end ; end_of_file
16153: LD_VAR 0 1
16157: RET
// export function CustomEvent ( event ) ; begin
16158: LD_INT 0
16160: PPUSH
// end ;
16161: LD_VAR 0 2
16165: RET
// on BuildingComplete ( building ) do begin if GetBType ( building ) in buildingsToBuild and GetNation ( building ) = nation_russian then
16166: LD_VAR 0 1
16170: PPUSH
16171: CALL_OW 266
16175: PUSH
16176: LD_EXP 8
16180: IN
16181: PUSH
16182: LD_VAR 0 1
16186: PPUSH
16187: CALL_OW 248
16191: PUSH
16192: LD_INT 3
16194: EQUAL
16195: AND
16196: IFFALSE 16219
// buildingsToBuild = buildingsToBuild diff GetBType ( building ) ;
16198: LD_ADDR_EXP 8
16202: PUSH
16203: LD_EXP 8
16207: PUSH
16208: LD_VAR 0 1
16212: PPUSH
16213: CALL_OW 266
16217: DIFF
16218: ST_TO_ADDR
// if GetBType ( building ) = b_depot then
16219: LD_VAR 0 1
16223: PPUSH
16224: CALL_OW 266
16228: PUSH
16229: LD_INT 0
16231: EQUAL
16232: IFFALSE 16283
// begin SetBName ( building , trockij ) ;
16234: LD_VAR 0 1
16238: PPUSH
16239: LD_STRING trockij
16241: PPUSH
16242: CALL_OW 500
// if not dial_BuildDepotBlocker and HeikeCaptured then
16246: LD_EXP 5
16250: NOT
16251: PUSH
16252: LD_EXP 1
16256: AND
16257: IFFALSE 16283
// Dial_EscortHeike ( GetX ( building ) , GetY ( building ) ) ;
16259: LD_VAR 0 1
16263: PPUSH
16264: CALL_OW 250
16268: PPUSH
16269: LD_VAR 0 1
16273: PPUSH
16274: CALL_OW 251
16278: PPUSH
16279: CALL 9149 0 2
// end ; end ;
16283: PPOPN 1
16285: END
// on UpgradeComplete ( building ) do begin if GetBType ( building ) in buildingsToBuild and GetNation ( building ) = nation_russian then
16286: LD_VAR 0 1
16290: PPUSH
16291: CALL_OW 266
16295: PUSH
16296: LD_EXP 8
16300: IN
16301: PUSH
16302: LD_VAR 0 1
16306: PPUSH
16307: CALL_OW 248
16311: PUSH
16312: LD_INT 3
16314: EQUAL
16315: AND
16316: IFFALSE 16339
// buildingsToBuild = buildingsToBuild diff GetBType ( building ) ;
16318: LD_ADDR_EXP 8
16322: PUSH
16323: LD_EXP 8
16327: PUSH
16328: LD_VAR 0 1
16332: PPUSH
16333: CALL_OW 266
16337: DIFF
16338: ST_TO_ADDR
// if GetBType ( building ) = b_barracks and GetNation ( building ) = 2 and not dial_BuildArBarrackBlocker then
16339: LD_VAR 0 1
16343: PPUSH
16344: CALL_OW 266
16348: PUSH
16349: LD_INT 5
16351: EQUAL
16352: PUSH
16353: LD_VAR 0 1
16357: PPUSH
16358: CALL_OW 248
16362: PUSH
16363: LD_INT 2
16365: EQUAL
16366: AND
16367: PUSH
16368: LD_EXP 6
16372: NOT
16373: AND
16374: IFFALSE 16380
// Dial_UpgradeArmoury ;
16376: CALL 9960 0 0
// end ;
16380: PPOPN 1
16382: END
// on ResearchComplete ( research , building ) do begin if research in techsToResearch then
16383: LD_VAR 0 1
16387: PUSH
16388: LD_EXP 9
16392: IN
16393: IFFALSE 16411
// techsToResearch = techsToResearch diff research ;
16395: LD_ADDR_EXP 9
16399: PUSH
16400: LD_EXP 9
16404: PUSH
16405: LD_VAR 0 1
16409: DIFF
16410: ST_TO_ADDR
// if research = tech_LimTeleport then
16411: LD_VAR 0 1
16415: PUSH
16416: LD_INT 37
16418: EQUAL
16419: IFFALSE 16425
// Dial_TeleportTechResearched ;
16421: CALL 13805 0 0
// if research = tech_AdvAI then
16425: LD_VAR 0 1
16429: PUSH
16430: LD_INT 27
16432: EQUAL
16433: IFFALSE 16439
// Dial_ComputerTechResearched ;
16435: CALL 13674 0 0
// end ;
16439: PPOPN 2
16441: END
// on EnterVehicle ( vehicle , human ) do begin if not canChooseMashaVehicle then
16442: LD_EXP 36
16446: NOT
16447: IFFALSE 16451
// exit ;
16449: GO 16618
// wait ( 0 0$1 ) ;
16451: LD_INT 35
16453: PPUSH
16454: CALL_OW 67
// if GetSide ( vehicle ) = 3 and human = Burlak and GetNation ( vehicle ) = nation_russian and GetWeapon ( vehicle ) in [ ru_heavy_machine_gun , ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher ] then
16458: LD_VAR 0 1
16462: PPUSH
16463: CALL_OW 255
16467: PUSH
16468: LD_INT 3
16470: EQUAL
16471: PUSH
16472: LD_VAR 0 2
16476: PUSH
16477: LD_EXP 57
16481: EQUAL
16482: AND
16483: PUSH
16484: LD_VAR 0 1
16488: PPUSH
16489: CALL_OW 248
16493: PUSH
16494: LD_INT 3
16496: EQUAL
16497: AND
16498: PUSH
16499: LD_VAR 0 1
16503: PPUSH
16504: CALL_OW 264
16508: PUSH
16509: LD_INT 42
16511: PUSH
16512: LD_INT 43
16514: PUSH
16515: LD_INT 44
16517: PUSH
16518: LD_INT 46
16520: PUSH
16521: LD_INT 45
16523: PUSH
16524: EMPTY
16525: LIST
16526: LIST
16527: LIST
16528: LIST
16529: LIST
16530: IN
16531: AND
16532: IFFALSE 16618
// begin if Masha then
16534: LD_EXP 4
16538: IFFALSE 16558
// if Masha [ 1 ] = vehicle then
16540: LD_EXP 4
16544: PUSH
16545: LD_INT 1
16547: ARRAY
16548: PUSH
16549: LD_VAR 0 1
16553: EQUAL
16554: IFFALSE 16558
// exit ;
16556: GO 16618
// if firstMashaQuery then
16558: LD_EXP 35
16562: IFFALSE 16596
// begin firstMashaQuery = false ;
16564: LD_ADDR_EXP 35
16568: PUSH
16569: LD_INT 0
16571: ST_TO_ADDR
// if Query ( QMashaQuery ) = 1 then
16572: LD_STRING QMashaQuery
16574: PPUSH
16575: CALL_OW 97
16579: PUSH
16580: LD_INT 1
16582: EQUAL
16583: IFFALSE 16594
// SetMashaData ( vehicle ) ;
16585: LD_VAR 0 1
16589: PPUSH
16590: CALL 8378 0 1
// end else
16594: GO 16618
// begin if Query ( QMashaQuery2 ) = 1 then
16596: LD_STRING QMashaQuery2
16598: PPUSH
16599: CALL_OW 97
16603: PUSH
16604: LD_INT 1
16606: EQUAL
16607: IFFALSE 16618
// SetMashaData ( vehicle ) ;
16609: LD_VAR 0 1
16613: PPUSH
16614: CALL 8378 0 1
// end ; end ; end ;
16618: PPOPN 2
16620: END
// on UnitDestroyed ( unit ) do begin if Masha then
16621: LD_EXP 4
16625: IFFALSE 16650
// if unit = Masha [ 1 ] then
16627: LD_VAR 0 1
16631: PUSH
16632: LD_EXP 4
16636: PUSH
16637: LD_INT 1
16639: ARRAY
16640: EQUAL
16641: IFFALSE 16650
// Masha = [ ] ;
16643: LD_ADDR_EXP 4
16647: PUSH
16648: EMPTY
16649: ST_TO_ADDR
// if unit = Burlak then
16650: LD_VAR 0 1
16654: PUSH
16655: LD_EXP 57
16659: EQUAL
16660: IFFALSE 16666
// Lose_Burlak ;
16662: CALL 15213 0 0
// if GetType ( unit ) = unit_human and GetNation ( unit ) = nation_russian then
16666: LD_VAR 0 1
16670: PPUSH
16671: CALL_OW 247
16675: PUSH
16676: LD_INT 1
16678: EQUAL
16679: PUSH
16680: LD_VAR 0 1
16684: PPUSH
16685: CALL_OW 248
16689: PUSH
16690: LD_INT 3
16692: EQUAL
16693: AND
16694: IFFALSE 16710
// lostUnits = lostUnits + 1 ;
16696: LD_ADDR_EXP 40
16700: PUSH
16701: LD_EXP 40
16705: PUSH
16706: LD_INT 1
16708: PLUS
16709: ST_TO_ADDR
// end ;
16710: PPOPN 1
16712: END
// on UnitGoesToRed ( unit ) do begin if GetType ( unit ) = unit_vehicle and GetNation ( unit ) = nation_russian and GetTech ( tech_LimTeleport , 3 ) = state_researched and not testedTeleport then
16713: LD_VAR 0 1
16717: PPUSH
16718: CALL_OW 247
16722: PUSH
16723: LD_INT 2
16725: EQUAL
16726: PUSH
16727: LD_VAR 0 1
16731: PPUSH
16732: CALL_OW 248
16736: PUSH
16737: LD_INT 3
16739: EQUAL
16740: AND
16741: PUSH
16742: LD_INT 37
16744: PPUSH
16745: LD_INT 3
16747: PPUSH
16748: CALL_OW 321
16752: PUSH
16753: LD_INT 2
16755: EQUAL
16756: AND
16757: PUSH
16758: LD_EXP 39
16762: NOT
16763: AND
16764: IFFALSE 16781
// begin testedTeleport = true ;
16766: LD_ADDR_EXP 39
16770: PUSH
16771: LD_INT 1
16773: ST_TO_ADDR
// ChangeMissionObjectives ( MTeleDone ) ;
16774: LD_STRING MTeleDone
16776: PPUSH
16777: CALL_OW 337
// end ; if unit = Heike then
16781: LD_VAR 0 1
16785: PUSH
16786: LD_EXP 79
16790: EQUAL
16791: IFFALSE 16834
// begin DialogueOn ;
16793: CALL_OW 6
// CenterNowOnUnits ( Heike ) ;
16797: LD_EXP 79
16801: PPUSH
16802: CALL_OW 87
// ForceSay ( Heike , DHeikeKilled-Hke-1 ) ;
16806: LD_EXP 79
16810: PPUSH
16811: LD_STRING DHeikeKilled-Hke-1
16813: PPUSH
16814: CALL_OW 91
// DialogueOff ;
16818: CALL_OW 7
// SetLives ( Heike , 0 ) ;
16822: LD_EXP 79
16826: PPUSH
16827: LD_INT 0
16829: PPUSH
16830: CALL_OW 234
// end ; end ;
16834: PPOPN 1
16836: END
// on Contact ( side1 , side2 ) do begin if side1 = 3 and side2 = 6 then
16837: LD_VAR 0 1
16841: PUSH
16842: LD_INT 3
16844: EQUAL
16845: PUSH
16846: LD_VAR 0 2
16850: PUSH
16851: LD_INT 6
16853: EQUAL
16854: AND
16855: IFFALSE 16861
// Lost_AttackAlly ;
16857: CALL 15228 0 0
// if side1 = 3 and side2 = 2 then
16861: LD_VAR 0 1
16865: PUSH
16866: LD_INT 3
16868: EQUAL
16869: PUSH
16870: LD_VAR 0 2
16874: PUSH
16875: LD_INT 2
16877: EQUAL
16878: AND
16879: IFFALSE 16885
// Dial_AttackGensher ;
16881: CALL 10916 0 0
// if side1 = 3 and side2 = 5 then
16885: LD_VAR 0 1
16889: PUSH
16890: LD_INT 3
16892: EQUAL
16893: PUSH
16894: LD_VAR 0 2
16898: PUSH
16899: LD_INT 5
16901: EQUAL
16902: AND
16903: IFFALSE 16947
// begin SetAttitude ( 3 , 5 , att_enemy , true ) ;
16905: LD_INT 3
16907: PPUSH
16908: LD_INT 5
16910: PPUSH
16911: LD_INT 2
16913: PPUSH
16914: LD_INT 1
16916: PPUSH
16917: CALL_OW 80
// if acceptKurtOffert and not GetSide ( Kurt ) = 2 then
16921: LD_EXP 19
16925: PUSH
16926: LD_EXP 80
16930: PPUSH
16931: CALL_OW 255
16935: PUSH
16936: LD_INT 2
16938: EQUAL
16939: NOT
16940: AND
16941: IFFALSE 16947
// Dial_BetrayedKurt1 ;
16943: CALL 11465 0 0
// end ; if side1 = 3 and side2 = 8 and GetAttitude ( 3 , 8 ) = att_neutral then
16947: LD_VAR 0 1
16951: PUSH
16952: LD_INT 3
16954: EQUAL
16955: PUSH
16956: LD_VAR 0 2
16960: PUSH
16961: LD_INT 8
16963: EQUAL
16964: AND
16965: PUSH
16966: LD_INT 3
16968: PPUSH
16969: LD_INT 8
16971: PPUSH
16972: CALL_OW 81
16976: PUSH
16977: LD_INT 0
16979: EQUAL
16980: AND
16981: IFFALSE 16993
// begin if acceptKurtOffert then
16983: LD_EXP 19
16987: IFFALSE 16993
// Dial_BetrayedKurt2 ;
16989: CALL 11551 0 0
// end ; end ;
16993: PPOPN 2
16995: END
// on VehicleConstructed ( vehicle , building ) do begin SetWeaponDataBuild ( GetWeapon ( vehicle ) , false ) ;
16996: LD_VAR 0 1
17000: PPUSH
17001: CALL_OW 264
17005: PPUSH
17006: LD_INT 0
17008: PPUSH
17009: CALL 6886 0 2
// if GetControl ( vehicle ) = control_computer and not buildCompVehicle then
17013: LD_VAR 0 1
17017: PPUSH
17018: CALL_OW 263
17022: PUSH
17023: LD_INT 3
17025: EQUAL
17026: PUSH
17027: LD_EXP 37
17031: NOT
17032: AND
17033: IFFALSE 17050
// begin buildCompVehicle = true ;
17035: LD_ADDR_EXP 37
17039: PUSH
17040: LD_INT 1
17042: ST_TO_ADDR
// ChangeMissionObjectives ( MAIDone ) ;
17043: LD_STRING MAIDone
17045: PPUSH
17046: CALL_OW 337
// end ; end ;
17050: PPOPN 2
17052: END
// on WeaponPlaced ( building , factory ) do begin SetWeaponDataBuild ( GetBWeapon ( building ) , true ) ;
17053: LD_VAR 0 1
17057: PPUSH
17058: CALL_OW 269
17062: PPUSH
17063: LD_INT 1
17065: PPUSH
17066: CALL 6886 0 2
// end ;
17070: PPOPN 2
17072: END
// on Command ( comandid ) do var i ;
17073: LD_INT 0
17075: PPUSH
// begin if IsOK ( KurtEng ) and GetSide ( KurtEng ) = 3 then
17076: LD_EXP 82
17080: PPUSH
17081: CALL_OW 302
17085: PUSH
17086: LD_EXP 82
17090: PPUSH
17091: CALL_OW 255
17095: PUSH
17096: LD_INT 3
17098: EQUAL
17099: AND
17100: IFFALSE 17309
// if GetTaskList ( KurtEng ) then
17102: LD_EXP 82
17106: PPUSH
17107: CALL_OW 437
17111: IFFALSE 17309
// begin for i := 1 to ( GetTaskList ( KurtEng ) ) do
17113: LD_ADDR_VAR 0 2
17117: PUSH
17118: DOUBLE
17119: LD_INT 1
17121: DEC
17122: ST_TO_ADDR
17123: LD_EXP 82
17127: PPUSH
17128: CALL_OW 437
17132: PUSH
17133: FOR_TO
17134: IFFALSE 17307
// begin if ( GetTaskList ( KurtEng ) [ i ] [ 1 ] in [ F , H , M , U , V , a , h , u , v , ~ , ^ , > , + , ; , 4 , { ] ) or ( GetTaskList ( KurtEng ) [ i ] [ 1 ] = B and GetTaskList ( KurtEng ) [ i ] [ 5 ] = 36 ) then
17136: LD_EXP 82
17140: PPUSH
17141: CALL_OW 437
17145: PUSH
17146: LD_VAR 0 2
17150: ARRAY
17151: PUSH
17152: LD_INT 1
17154: ARRAY
17155: PUSH
17156: LD_STRING F
17158: PUSH
17159: LD_STRING H
17161: PUSH
17162: LD_STRING M
17164: PUSH
17165: LD_STRING U
17167: PUSH
17168: LD_STRING V
17170: PUSH
17171: LD_STRING a
17173: PUSH
17174: LD_STRING h
17176: PUSH
17177: LD_STRING u
17179: PUSH
17180: LD_STRING v
17182: PUSH
17183: LD_STRING ~
17185: PUSH
17186: LD_STRING ^
17188: PUSH
17189: LD_STRING >
17191: PUSH
17192: LD_STRING +
17194: PUSH
17195: LD_STRING ;
17197: PUSH
17198: LD_STRING 4
17200: PUSH
17201: LD_STRING {
17203: PUSH
17204: EMPTY
17205: LIST
17206: LIST
17207: LIST
17208: LIST
17209: LIST
17210: LIST
17211: LIST
17212: LIST
17213: LIST
17214: LIST
17215: LIST
17216: LIST
17217: LIST
17218: LIST
17219: LIST
17220: LIST
17221: IN
17222: PUSH
17223: LD_EXP 82
17227: PPUSH
17228: CALL_OW 437
17232: PUSH
17233: LD_VAR 0 2
17237: ARRAY
17238: PUSH
17239: LD_INT 1
17241: ARRAY
17242: PUSH
17243: LD_STRING B
17245: EQUAL
17246: PUSH
17247: LD_EXP 82
17251: PPUSH
17252: CALL_OW 437
17256: PUSH
17257: LD_VAR 0 2
17261: ARRAY
17262: PUSH
17263: LD_INT 5
17265: ARRAY
17266: PUSH
17267: LD_INT 36
17269: EQUAL
17270: AND
17271: OR
17272: IFFALSE 17276
// else
17274: GO 17305
// begin RemoveTasks ( KurtEng ) ;
17276: LD_EXP 82
17280: PPUSH
17281: CALL_OW 493
// DialogueOn ;
17285: CALL_OW 6
// Say ( Kurt , DMercRefuseBuild-Kurt-1 ) ;
17289: LD_EXP 80
17293: PPUSH
17294: LD_STRING DMercRefuseBuild-Kurt-1
17296: PPUSH
17297: CALL_OW 88
// DialogueOff ;
17301: CALL_OW 7
// end ; end ;
17305: GO 17133
17307: POP
17308: POP
// end ; end ; end_of_file
17309: PPOPN 2
17311: END
// every 0 0$01 do var timer , cratesSpawned ;
17312: GO 17314
17314: DISABLE
17315: LD_INT 0
17317: PPUSH
17318: PPUSH
// begin timer := 1 1$30 ;
17319: LD_ADDR_VAR 0 1
17323: PUSH
17324: LD_INT 3150
17326: ST_TO_ADDR
// repeat wait ( timer ) ;
17327: LD_VAR 0 1
17331: PPUSH
17332: CALL_OW 67
// if cratesSpawned >= 6 and cratesSpawned < 18 then
17336: LD_VAR 0 2
17340: PUSH
17341: LD_INT 6
17343: GREATEREQUAL
17344: PUSH
17345: LD_VAR 0 2
17349: PUSH
17350: LD_INT 18
17352: LESS
17353: AND
17354: IFFALSE 17370
// timer := timer + 0 0$3 ;
17356: LD_ADDR_VAR 0 1
17360: PUSH
17361: LD_VAR 0 1
17365: PUSH
17366: LD_INT 105
17368: PLUS
17369: ST_TO_ADDR
// if cratesSpawned >= 18 then
17370: LD_VAR 0 2
17374: PUSH
17375: LD_INT 18
17377: GREATEREQUAL
17378: IFFALSE 17394
// timer := timer + 0 0$9 ;
17380: LD_ADDR_VAR 0 1
17384: PUSH
17385: LD_VAR 0 1
17389: PUSH
17390: LD_INT 315
17392: PLUS
17393: ST_TO_ADDR
// if timer > 3 3$00 then
17394: LD_VAR 0 1
17398: PUSH
17399: LD_INT 6300
17401: GREATER
17402: IFFALSE 17412
// timer := 0 0$50 ;
17404: LD_ADDR_VAR 0 1
17408: PUSH
17409: LD_INT 1750
17411: ST_TO_ADDR
// CreateCratesArea ( rand ( 3 , 5 ) , CratesSpawnArea , true ) ;
17412: LD_INT 3
17414: PPUSH
17415: LD_INT 5
17417: PPUSH
17418: CALL_OW 12
17422: PPUSH
17423: LD_INT 15
17425: PPUSH
17426: LD_INT 1
17428: PPUSH
17429: CALL_OW 55
// cratesSpawned = cratesSpawned + 1 ;
17433: LD_ADDR_VAR 0 2
17437: PUSH
17438: LD_VAR 0 2
17442: PUSH
17443: LD_INT 1
17445: PLUS
17446: ST_TO_ADDR
// until false ;
17447: LD_INT 0
17449: IFFALSE 17327
// end ; end_of_file
17451: PPOPN 2
17453: END
// every 0 0$1 do
17454: GO 17456
17456: DISABLE
// begin enable ;
17457: ENABLE
// end ;
17458: END
// every 0 0$1 do var building , playerBuildings , playerBuildingsBType ;
17459: GO 17461
17461: DISABLE
17462: LD_INT 0
17464: PPUSH
17465: PPUSH
17466: PPUSH
// begin playerBuildings = FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_building ] , [ f_nation , nation_russian ] ] ) ;
17467: LD_ADDR_VAR 0 2
17471: PUSH
17472: LD_INT 22
17474: PUSH
17475: LD_INT 3
17477: PUSH
17478: EMPTY
17479: LIST
17480: LIST
17481: PUSH
17482: LD_INT 21
17484: PUSH
17485: LD_INT 3
17487: PUSH
17488: EMPTY
17489: LIST
17490: LIST
17491: PUSH
17492: LD_INT 23
17494: PUSH
17495: LD_INT 3
17497: PUSH
17498: EMPTY
17499: LIST
17500: LIST
17501: PUSH
17502: EMPTY
17503: LIST
17504: LIST
17505: LIST
17506: PPUSH
17507: CALL_OW 69
17511: ST_TO_ADDR
// playerBuildingsBType = [ ] ;
17512: LD_ADDR_VAR 0 3
17516: PUSH
17517: EMPTY
17518: ST_TO_ADDR
// for building in playerBuildings do
17519: LD_ADDR_VAR 0 1
17523: PUSH
17524: LD_VAR 0 2
17528: PUSH
17529: FOR_IN
17530: IFFALSE 17555
// playerBuildingsBType = playerBuildingsBType ^ GetBType ( building ) ;
17532: LD_ADDR_VAR 0 3
17536: PUSH
17537: LD_VAR 0 3
17541: PUSH
17542: LD_VAR 0 1
17546: PPUSH
17547: CALL_OW 266
17551: ADD
17552: ST_TO_ADDR
17553: GO 17529
17555: POP
17556: POP
// for building in allBuildings do
17557: LD_ADDR_VAR 0 1
17561: PUSH
17562: LD_EXP 13
17566: PUSH
17567: FOR_IN
17568: IFFALSE 17614
// if not building in playerBuildingsBType and not building in buildingsToBuild then
17570: LD_VAR 0 1
17574: PUSH
17575: LD_VAR 0 3
17579: IN
17580: NOT
17581: PUSH
17582: LD_VAR 0 1
17586: PUSH
17587: LD_EXP 8
17591: IN
17592: NOT
17593: AND
17594: IFFALSE 17612
// buildingsToBuild = buildingsToBuild ^ building ;
17596: LD_ADDR_EXP 8
17600: PUSH
17601: LD_EXP 8
17605: PUSH
17606: LD_VAR 0 1
17610: ADD
17611: ST_TO_ADDR
17612: GO 17567
17614: POP
17615: POP
// enable ;
17616: ENABLE
// end ;
17617: PPOPN 3
17619: END
// every 0 0$1 trigger legionOffertCountdown do
17620: LD_EXP 33
17624: IFFALSE 17644
17626: GO 17628
17628: DISABLE
// begin legionOffertTime = legionOffertTime - 0 0$01 ;
17629: LD_ADDR_EXP 34
17633: PUSH
17634: LD_EXP 34
17638: PUSH
17639: LD_INT 35
17641: MINUS
17642: ST_TO_ADDR
// enable ;
17643: ENABLE
// end ;
17644: END
// every 0 0$1 trigger KurtWaitingForFreeHeike do
17645: LD_EXP 23
17649: IFFALSE 17683
17651: GO 17653
17653: DISABLE
// begin timeToFreeHeike = timeToFreeHeike - 0 0$01 ;
17654: LD_ADDR_EXP 54
17658: PUSH
17659: LD_EXP 54
17663: PUSH
17664: LD_INT 35
17666: MINUS
17667: ST_TO_ADDR
// if timeToFreeHeike <= 0 0$00 then
17668: LD_EXP 54
17672: PUSH
17673: LD_INT 0
17675: LESSEQUAL
17676: IFFALSE 17682
// Dial_PlayerDontSendHeike ;
17678: CALL 11413 0 0
// enable ;
17682: ENABLE
// end ;
17683: END
// every 0 0$1 trigger KurtWaitingForBuildBarrack and GetSide ( KurtEng ) = 3 do
17684: LD_EXP 24
17688: PUSH
17689: LD_EXP 82
17693: PPUSH
17694: CALL_OW 255
17698: PUSH
17699: LD_INT 3
17701: EQUAL
17702: AND
17703: IFFALSE 17776
17705: GO 17707
17707: DISABLE
// begin timeToBuildArBarrack = timeToBuildArBarrack - 0 0$01 ;
17708: LD_ADDR_EXP 55
17712: PUSH
17713: LD_EXP 55
17717: PUSH
17718: LD_INT 35
17720: MINUS
17721: ST_TO_ADDR
// if timeToBuildArBarrack <= 0 0$00 then
17722: LD_EXP 55
17726: PUSH
17727: LD_INT 0
17729: LESSEQUAL
17730: IFFALSE 17775
// begin Dial_BetrayedKurt1 ;
17732: CALL 11465 0 0
// wait ( 2 2$0 ) ;
17736: LD_INT 4200
17738: PPUSH
17739: CALL_OW 67
// SetAttitude ( 3 , 8 , att_enemy , true ) ;
17743: LD_INT 3
17745: PPUSH
17746: LD_INT 8
17748: PPUSH
17749: LD_INT 2
17751: PPUSH
17752: LD_INT 1
17754: PPUSH
17755: CALL_OW 80
// KurtAttack = true ;
17759: LD_ADDR_EXP 25
17763: PUSH
17764: LD_INT 1
17766: ST_TO_ADDR
// KurtWaitingForBuildBarrack = false ;
17767: LD_ADDR_EXP 24
17771: PUSH
17772: LD_INT 0
17774: ST_TO_ADDR
// end ; enable ;
17775: ENABLE
// end ; end_of_file
17776: END
// export currentAmWave , currentArWave ; every 0 0$1 trigger americansAttack do var i ;
17777: LD_EXP 26
17781: IFFALSE 17927
17783: GO 17785
17785: DISABLE
17786: LD_INT 0
17788: PPUSH
// begin currentAmWave = 0 ;
17789: LD_ADDR_EXP 85
17793: PUSH
17794: LD_INT 0
17796: ST_TO_ADDR
// wait ( firstAttackDelay ) ;
17797: LD_EXP 49
17801: PPUSH
17802: CALL_OW 67
// for i := 1 to americansAttackWaves do
17806: LD_ADDR_VAR 0 1
17810: PUSH
17811: DOUBLE
17812: LD_INT 1
17814: DEC
17815: ST_TO_ADDR
17816: LD_EXP 48
17820: PUSH
17821: FOR_TO
17822: IFFALSE 17925
// begin SpawnAmAttackTeam ;
17824: CALL 3214 0 0
// currentAmWave = currentAmWave + 1 ;
17828: LD_ADDR_EXP 85
17832: PUSH
17833: LD_EXP 85
17837: PUSH
17838: LD_INT 1
17840: PLUS
17841: ST_TO_ADDR
// if currentAmWave = 1 then
17842: LD_EXP 85
17846: PUSH
17847: LD_INT 1
17849: EQUAL
17850: IFFALSE 17914
// begin if paidLegionOffert then
17852: LD_EXP 32
17856: IFFALSE 17895
// begin Say ( Burlak , DAmAttackStart-Bur-1 ) ;
17858: LD_EXP 57
17862: PPUSH
17863: LD_STRING DAmAttackStart-Bur-1
17865: PPUSH
17866: CALL_OW 88
// if IsOK ( Gleb ) then
17870: LD_EXP 60
17874: PPUSH
17875: CALL_OW 302
17879: IFFALSE 17893
// Say ( Gleb , DAmAttackStart-Glb-1 ) ;
17881: LD_EXP 60
17885: PPUSH
17886: LD_STRING DAmAttackStart-Glb-1
17888: PPUSH
17889: CALL_OW 88
// end else
17893: GO 17907
// Say ( Burlak , DAmAttackStart-Bur-2 ) ;
17895: LD_EXP 57
17899: PPUSH
17900: LD_STRING DAmAttackStart-Bur-2
17902: PPUSH
17903: CALL_OW 88
// ChangeMissionObjectives ( MEnemy ) ;
17907: LD_STRING MEnemy
17909: PPUSH
17910: CALL_OW 337
// end ; wait ( waveCooldown ) ;
17914: LD_EXP 50
17918: PPUSH
17919: CALL_OW 67
// end ;
17923: GO 17821
17925: POP
17926: POP
// end ;
17927: PPOPN 1
17929: END
// every 0 0$1 trigger currentAmWave = 1 do
17930: LD_EXP 85
17934: PUSH
17935: LD_INT 1
17937: EQUAL
17938: IFFALSE 18027
17940: GO 17942
17942: DISABLE
// Attack ( [ 0 , amAttackTeam , [ [ 115 , 42 ] , [ 51 , 67 ] ] , [ 0 , 0 , 0 , 1 , 1 , 1 , 0 , 0 , 1 , 0 ] ] ) ;
17943: LD_INT 0
17945: PUSH
17946: LD_EXP 78
17950: PUSH
17951: LD_INT 115
17953: PUSH
17954: LD_INT 42
17956: PUSH
17957: EMPTY
17958: LIST
17959: LIST
17960: PUSH
17961: LD_INT 51
17963: PUSH
17964: LD_INT 67
17966: PUSH
17967: EMPTY
17968: LIST
17969: LIST
17970: PUSH
17971: EMPTY
17972: LIST
17973: LIST
17974: PUSH
17975: LD_INT 0
17977: PUSH
17978: LD_INT 0
17980: PUSH
17981: LD_INT 0
17983: PUSH
17984: LD_INT 1
17986: PUSH
17987: LD_INT 1
17989: PUSH
17990: LD_INT 1
17992: PUSH
17993: LD_INT 0
17995: PUSH
17996: LD_INT 0
17998: PUSH
17999: LD_INT 1
18001: PUSH
18002: LD_INT 0
18004: PUSH
18005: EMPTY
18006: LIST
18007: LIST
18008: LIST
18009: LIST
18010: LIST
18011: LIST
18012: LIST
18013: LIST
18014: LIST
18015: LIST
18016: PUSH
18017: EMPTY
18018: LIST
18019: LIST
18020: LIST
18021: LIST
18022: PPUSH
18023: CALL 80708 0 1
18027: END
// every 0 0$1 trigger currentAmWave = 2 do
18028: LD_EXP 85
18032: PUSH
18033: LD_INT 2
18035: EQUAL
18036: IFFALSE 18125
18038: GO 18040
18040: DISABLE
// Attack ( [ 0 , amAttackTeam , [ [ 115 , 42 ] , [ 51 , 67 ] ] , [ 0 , 0 , 0 , 1 , 1 , 1 , 0 , 0 , 1 , 0 ] ] ) ;
18041: LD_INT 0
18043: PUSH
18044: LD_EXP 78
18048: PUSH
18049: LD_INT 115
18051: PUSH
18052: LD_INT 42
18054: PUSH
18055: EMPTY
18056: LIST
18057: LIST
18058: PUSH
18059: LD_INT 51
18061: PUSH
18062: LD_INT 67
18064: PUSH
18065: EMPTY
18066: LIST
18067: LIST
18068: PUSH
18069: EMPTY
18070: LIST
18071: LIST
18072: PUSH
18073: LD_INT 0
18075: PUSH
18076: LD_INT 0
18078: PUSH
18079: LD_INT 0
18081: PUSH
18082: LD_INT 1
18084: PUSH
18085: LD_INT 1
18087: PUSH
18088: LD_INT 1
18090: PUSH
18091: LD_INT 0
18093: PUSH
18094: LD_INT 0
18096: PUSH
18097: LD_INT 1
18099: PUSH
18100: LD_INT 0
18102: PUSH
18103: EMPTY
18104: LIST
18105: LIST
18106: LIST
18107: LIST
18108: LIST
18109: LIST
18110: LIST
18111: LIST
18112: LIST
18113: LIST
18114: PUSH
18115: EMPTY
18116: LIST
18117: LIST
18118: LIST
18119: LIST
18120: PPUSH
18121: CALL 80708 0 1
18125: END
// every 0 0$1 trigger currentAmWave = 3 do
18126: LD_EXP 85
18130: PUSH
18131: LD_INT 3
18133: EQUAL
18134: IFFALSE 18223
18136: GO 18138
18138: DISABLE
// Attack ( [ 0 , amAttackTeam , [ [ 115 , 42 ] , [ 51 , 67 ] ] , [ 0 , 0 , 0 , 1 , 1 , 1 , 0 , 0 , 1 , 0 ] ] ) ;
18139: LD_INT 0
18141: PUSH
18142: LD_EXP 78
18146: PUSH
18147: LD_INT 115
18149: PUSH
18150: LD_INT 42
18152: PUSH
18153: EMPTY
18154: LIST
18155: LIST
18156: PUSH
18157: LD_INT 51
18159: PUSH
18160: LD_INT 67
18162: PUSH
18163: EMPTY
18164: LIST
18165: LIST
18166: PUSH
18167: EMPTY
18168: LIST
18169: LIST
18170: PUSH
18171: LD_INT 0
18173: PUSH
18174: LD_INT 0
18176: PUSH
18177: LD_INT 0
18179: PUSH
18180: LD_INT 1
18182: PUSH
18183: LD_INT 1
18185: PUSH
18186: LD_INT 1
18188: PUSH
18189: LD_INT 0
18191: PUSH
18192: LD_INT 0
18194: PUSH
18195: LD_INT 1
18197: PUSH
18198: LD_INT 0
18200: PUSH
18201: EMPTY
18202: LIST
18203: LIST
18204: LIST
18205: LIST
18206: LIST
18207: LIST
18208: LIST
18209: LIST
18210: LIST
18211: LIST
18212: PUSH
18213: EMPTY
18214: LIST
18215: LIST
18216: LIST
18217: LIST
18218: PPUSH
18219: CALL 80708 0 1
18223: END
// every 0 0$1 trigger KurtAttack do var i ;
18224: LD_EXP 25
18228: IFFALSE 18349
18230: GO 18232
18232: DISABLE
18233: LD_INT 0
18235: PPUSH
// begin currentArWave = 0 ;
18236: LD_ADDR_EXP 86
18240: PUSH
18241: LD_INT 0
18243: ST_TO_ADDR
// wait ( firstAttackDelay ) ;
18244: LD_EXP 49
18248: PPUSH
18249: CALL_OW 67
// for i := 1 to KurtAttackWaves do
18253: LD_ADDR_VAR 0 1
18257: PUSH
18258: DOUBLE
18259: LD_INT 1
18261: DEC
18262: ST_TO_ADDR
18263: LD_EXP 47
18267: PUSH
18268: FOR_TO
18269: IFFALSE 18347
// begin if KurtAttack and IsOK ( Heike ) then
18271: LD_EXP 25
18275: PUSH
18276: LD_EXP 79
18280: PPUSH
18281: CALL_OW 302
18285: AND
18286: IFFALSE 18345
// begin SpawnArAttackTeam ;
18288: CALL 4359 0 0
// currentArWave = currentArWave + 1 ;
18292: LD_ADDR_EXP 86
18296: PUSH
18297: LD_EXP 86
18301: PUSH
18302: LD_INT 1
18304: PLUS
18305: ST_TO_ADDR
// if currentArWave = 2 then
18306: LD_EXP 86
18310: PUSH
18311: LD_INT 2
18313: EQUAL
18314: IFFALSE 18336
// begin SayRadio ( Kurt , DMercAttack-Kurt-1 ) ;
18316: LD_EXP 80
18320: PPUSH
18321: LD_STRING DMercAttack-Kurt-1
18323: PPUSH
18324: CALL_OW 94
// canSendHeike = true ;
18328: LD_ADDR_EXP 28
18332: PUSH
18333: LD_INT 1
18335: ST_TO_ADDR
// end ; wait ( waveCooldown ) ;
18336: LD_EXP 50
18340: PPUSH
18341: CALL_OW 67
// end ; end ;
18345: GO 18268
18347: POP
18348: POP
// end ;
18349: PPOPN 1
18351: END
// every 0 0$1 trigger currentArWave = 1 do
18352: LD_EXP 86
18356: PUSH
18357: LD_INT 1
18359: EQUAL
18360: IFFALSE 18449
18362: GO 18364
18364: DISABLE
// Attack ( [ 0 , arAttackTeam , [ [ 115 , 42 ] , [ 51 , 67 ] ] , [ 0 , 0 , 0 , 1 , 1 , 1 , 0 , 0 , 1 , 0 ] ] ) ;
18365: LD_INT 0
18367: PUSH
18368: LD_EXP 84
18372: PUSH
18373: LD_INT 115
18375: PUSH
18376: LD_INT 42
18378: PUSH
18379: EMPTY
18380: LIST
18381: LIST
18382: PUSH
18383: LD_INT 51
18385: PUSH
18386: LD_INT 67
18388: PUSH
18389: EMPTY
18390: LIST
18391: LIST
18392: PUSH
18393: EMPTY
18394: LIST
18395: LIST
18396: PUSH
18397: LD_INT 0
18399: PUSH
18400: LD_INT 0
18402: PUSH
18403: LD_INT 0
18405: PUSH
18406: LD_INT 1
18408: PUSH
18409: LD_INT 1
18411: PUSH
18412: LD_INT 1
18414: PUSH
18415: LD_INT 0
18417: PUSH
18418: LD_INT 0
18420: PUSH
18421: LD_INT 1
18423: PUSH
18424: LD_INT 0
18426: PUSH
18427: EMPTY
18428: LIST
18429: LIST
18430: LIST
18431: LIST
18432: LIST
18433: LIST
18434: LIST
18435: LIST
18436: LIST
18437: LIST
18438: PUSH
18439: EMPTY
18440: LIST
18441: LIST
18442: LIST
18443: LIST
18444: PPUSH
18445: CALL 80708 0 1
18449: END
// every 0 0$1 trigger currentArWave = 2 do
18450: LD_EXP 86
18454: PUSH
18455: LD_INT 2
18457: EQUAL
18458: IFFALSE 18547
18460: GO 18462
18462: DISABLE
// Attack ( [ 0 , arAttackTeam , [ [ 115 , 42 ] , [ 51 , 67 ] ] , [ 0 , 0 , 0 , 1 , 1 , 1 , 0 , 0 , 1 , 0 ] ] ) ;
18463: LD_INT 0
18465: PUSH
18466: LD_EXP 84
18470: PUSH
18471: LD_INT 115
18473: PUSH
18474: LD_INT 42
18476: PUSH
18477: EMPTY
18478: LIST
18479: LIST
18480: PUSH
18481: LD_INT 51
18483: PUSH
18484: LD_INT 67
18486: PUSH
18487: EMPTY
18488: LIST
18489: LIST
18490: PUSH
18491: EMPTY
18492: LIST
18493: LIST
18494: PUSH
18495: LD_INT 0
18497: PUSH
18498: LD_INT 0
18500: PUSH
18501: LD_INT 0
18503: PUSH
18504: LD_INT 1
18506: PUSH
18507: LD_INT 1
18509: PUSH
18510: LD_INT 1
18512: PUSH
18513: LD_INT 0
18515: PUSH
18516: LD_INT 0
18518: PUSH
18519: LD_INT 1
18521: PUSH
18522: LD_INT 0
18524: PUSH
18525: EMPTY
18526: LIST
18527: LIST
18528: LIST
18529: LIST
18530: LIST
18531: LIST
18532: LIST
18533: LIST
18534: LIST
18535: LIST
18536: PUSH
18537: EMPTY
18538: LIST
18539: LIST
18540: LIST
18541: LIST
18542: PPUSH
18543: CALL 80708 0 1
18547: END
// every 0 0$1 trigger currentArWave = 3 do
18548: LD_EXP 86
18552: PUSH
18553: LD_INT 3
18555: EQUAL
18556: IFFALSE 18645
18558: GO 18560
18560: DISABLE
// Attack ( [ 0 , arAttackTeam , [ [ 115 , 42 ] , [ 51 , 67 ] ] , [ 0 , 0 , 0 , 1 , 1 , 1 , 0 , 0 , 1 , 0 ] ] ) ;
18561: LD_INT 0
18563: PUSH
18564: LD_EXP 84
18568: PUSH
18569: LD_INT 115
18571: PUSH
18572: LD_INT 42
18574: PUSH
18575: EMPTY
18576: LIST
18577: LIST
18578: PUSH
18579: LD_INT 51
18581: PUSH
18582: LD_INT 67
18584: PUSH
18585: EMPTY
18586: LIST
18587: LIST
18588: PUSH
18589: EMPTY
18590: LIST
18591: LIST
18592: PUSH
18593: LD_INT 0
18595: PUSH
18596: LD_INT 0
18598: PUSH
18599: LD_INT 0
18601: PUSH
18602: LD_INT 1
18604: PUSH
18605: LD_INT 1
18607: PUSH
18608: LD_INT 1
18610: PUSH
18611: LD_INT 0
18613: PUSH
18614: LD_INT 0
18616: PUSH
18617: LD_INT 1
18619: PUSH
18620: LD_INT 0
18622: PUSH
18623: EMPTY
18624: LIST
18625: LIST
18626: LIST
18627: LIST
18628: LIST
18629: LIST
18630: LIST
18631: LIST
18632: LIST
18633: LIST
18634: PUSH
18635: EMPTY
18636: LIST
18637: LIST
18638: LIST
18639: LIST
18640: PPUSH
18641: CALL 80708 0 1
18645: END
// every 0 0$1 trigger currentArWave = 4 do
18646: LD_EXP 86
18650: PUSH
18651: LD_INT 4
18653: EQUAL
18654: IFFALSE 18743
18656: GO 18658
18658: DISABLE
// Attack ( [ 0 , arAttackTeam , [ [ 115 , 42 ] , [ 51 , 67 ] ] , [ 0 , 0 , 0 , 1 , 1 , 1 , 0 , 0 , 1 , 0 ] ] ) ;
18659: LD_INT 0
18661: PUSH
18662: LD_EXP 84
18666: PUSH
18667: LD_INT 115
18669: PUSH
18670: LD_INT 42
18672: PUSH
18673: EMPTY
18674: LIST
18675: LIST
18676: PUSH
18677: LD_INT 51
18679: PUSH
18680: LD_INT 67
18682: PUSH
18683: EMPTY
18684: LIST
18685: LIST
18686: PUSH
18687: EMPTY
18688: LIST
18689: LIST
18690: PUSH
18691: LD_INT 0
18693: PUSH
18694: LD_INT 0
18696: PUSH
18697: LD_INT 0
18699: PUSH
18700: LD_INT 1
18702: PUSH
18703: LD_INT 1
18705: PUSH
18706: LD_INT 1
18708: PUSH
18709: LD_INT 0
18711: PUSH
18712: LD_INT 0
18714: PUSH
18715: LD_INT 1
18717: PUSH
18718: LD_INT 0
18720: PUSH
18721: EMPTY
18722: LIST
18723: LIST
18724: LIST
18725: LIST
18726: LIST
18727: LIST
18728: LIST
18729: LIST
18730: LIST
18731: LIST
18732: PUSH
18733: EMPTY
18734: LIST
18735: LIST
18736: LIST
18737: LIST
18738: PPUSH
18739: CALL 80708 0 1
18743: END
// every 0 0$1 trigger currentArWave = 5 do
18744: LD_EXP 86
18748: PUSH
18749: LD_INT 5
18751: EQUAL
18752: IFFALSE 18841
18754: GO 18756
18756: DISABLE
// Attack ( [ 0 , arAttackTeam , [ [ 115 , 42 ] , [ 51 , 67 ] ] , [ 0 , 0 , 0 , 1 , 1 , 1 , 0 , 0 , 1 , 0 ] ] ) ; end_of_file
18757: LD_INT 0
18759: PUSH
18760: LD_EXP 84
18764: PUSH
18765: LD_INT 115
18767: PUSH
18768: LD_INT 42
18770: PUSH
18771: EMPTY
18772: LIST
18773: LIST
18774: PUSH
18775: LD_INT 51
18777: PUSH
18778: LD_INT 67
18780: PUSH
18781: EMPTY
18782: LIST
18783: LIST
18784: PUSH
18785: EMPTY
18786: LIST
18787: LIST
18788: PUSH
18789: LD_INT 0
18791: PUSH
18792: LD_INT 0
18794: PUSH
18795: LD_INT 0
18797: PUSH
18798: LD_INT 1
18800: PUSH
18801: LD_INT 1
18803: PUSH
18804: LD_INT 1
18806: PUSH
18807: LD_INT 0
18809: PUSH
18810: LD_INT 0
18812: PUSH
18813: LD_INT 1
18815: PUSH
18816: LD_INT 0
18818: PUSH
18819: EMPTY
18820: LIST
18821: LIST
18822: LIST
18823: LIST
18824: LIST
18825: LIST
18826: LIST
18827: LIST
18828: LIST
18829: LIST
18830: PUSH
18831: EMPTY
18832: LIST
18833: LIST
18834: LIST
18835: LIST
18836: PPUSH
18837: CALL 80708 0 1
18841: END
// every 0 0$1 do var arVehs , arVeh , nearPlayerUnit ;
18842: GO 18844
18844: DISABLE
18845: LD_INT 0
18847: PPUSH
18848: PPUSH
18849: PPUSH
// begin enable ;
18850: ENABLE
// arVehs = FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_vehicle ] , [ f_empty ] ] ) ;
18851: LD_ADDR_VAR 0 1
18855: PUSH
18856: LD_INT 22
18858: PUSH
18859: LD_INT 8
18861: PUSH
18862: EMPTY
18863: LIST
18864: LIST
18865: PUSH
18866: LD_INT 21
18868: PUSH
18869: LD_INT 2
18871: PUSH
18872: EMPTY
18873: LIST
18874: LIST
18875: PUSH
18876: LD_INT 58
18878: PUSH
18879: EMPTY
18880: LIST
18881: PUSH
18882: EMPTY
18883: LIST
18884: LIST
18885: LIST
18886: PPUSH
18887: CALL_OW 69
18891: ST_TO_ADDR
// if not arVehs or not GetAttitude ( 3 , 8 ) = att_enemy then
18892: LD_VAR 0 1
18896: NOT
18897: PUSH
18898: LD_INT 3
18900: PPUSH
18901: LD_INT 8
18903: PPUSH
18904: CALL_OW 81
18908: PUSH
18909: LD_INT 2
18911: EQUAL
18912: NOT
18913: OR
18914: IFFALSE 18918
// exit ;
18916: GO 19008
// for arVeh in arVehs do
18918: LD_ADDR_VAR 0 2
18922: PUSH
18923: LD_VAR 0 1
18927: PUSH
18928: FOR_IN
18929: IFFALSE 19006
// begin nearPlayerUnit = NearestUnitToUnit ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) , arVeh ) ;
18931: LD_ADDR_VAR 0 3
18935: PUSH
18936: LD_INT 22
18938: PUSH
18939: LD_INT 3
18941: PUSH
18942: EMPTY
18943: LIST
18944: LIST
18945: PUSH
18946: LD_INT 21
18948: PUSH
18949: LD_INT 1
18951: PUSH
18952: EMPTY
18953: LIST
18954: LIST
18955: PUSH
18956: EMPTY
18957: LIST
18958: LIST
18959: PPUSH
18960: CALL_OW 69
18964: PPUSH
18965: LD_VAR 0 2
18969: PPUSH
18970: CALL_OW 74
18974: ST_TO_ADDR
// if GetDistUnits ( nearPlayerUnit , arVeh ) <= 2 then
18975: LD_VAR 0 3
18979: PPUSH
18980: LD_VAR 0 2
18984: PPUSH
18985: CALL_OW 296
18989: PUSH
18990: LD_INT 2
18992: LESSEQUAL
18993: IFFALSE 19004
// ComSelfDestruction ( arVeh ) ;
18995: LD_VAR 0 2
18999: PPUSH
19000: CALL_OW 577
// end ;
19004: GO 18928
19006: POP
19007: POP
// end ;
19008: PPOPN 3
19010: END
// every 0 0$1 trigger forceStopKurtAttack do
19011: LD_EXP 27
19015: IFFALSE 19081
19017: GO 19019
19019: DISABLE
// begin KurtAttack = false ;
19020: LD_ADDR_EXP 25
19024: PUSH
19025: LD_INT 0
19027: ST_TO_ADDR
// allowExitFromMap = 4 ;
19028: LD_ADDR_EXP 18
19032: PUSH
19033: LD_INT 4
19035: ST_TO_ADDR
// SetAttitude ( 3 , 8 , att_friend , true ) ;
19036: LD_INT 3
19038: PPUSH
19039: LD_INT 8
19041: PPUSH
19042: LD_INT 1
19044: PPUSH
19045: LD_INT 1
19047: PPUSH
19048: CALL_OW 80
// arAttackTeam = [ ] ;
19052: LD_ADDR_EXP 84
19056: PUSH
19057: EMPTY
19058: ST_TO_ADDR
// ComMoveToArea ( FilterAllUnits ( [ f_side , 8 ] ) , KurtExitMapArea ) ;
19059: LD_INT 22
19061: PUSH
19062: LD_INT 8
19064: PUSH
19065: EMPTY
19066: LIST
19067: LIST
19068: PPUSH
19069: CALL_OW 69
19073: PPUSH
19074: LD_INT 11
19076: PPUSH
19077: CALL_OW 113
// end ; end_of_file end_of_file
19081: END
// every 0 0$01 do var timer , cratesSpawned ;
19082: GO 19084
19084: DISABLE
19085: LD_INT 0
19087: PPUSH
19088: PPUSH
// begin timer := 1 1$30 ;
19089: LD_ADDR_VAR 0 1
19093: PUSH
19094: LD_INT 3150
19096: ST_TO_ADDR
// repeat wait ( timer ) ;
19097: LD_VAR 0 1
19101: PPUSH
19102: CALL_OW 67
// if cratesSpawned >= 6 and cratesSpawned < 18 then
19106: LD_VAR 0 2
19110: PUSH
19111: LD_INT 6
19113: GREATEREQUAL
19114: PUSH
19115: LD_VAR 0 2
19119: PUSH
19120: LD_INT 18
19122: LESS
19123: AND
19124: IFFALSE 19140
// timer := timer + 0 0$3 ;
19126: LD_ADDR_VAR 0 1
19130: PUSH
19131: LD_VAR 0 1
19135: PUSH
19136: LD_INT 105
19138: PLUS
19139: ST_TO_ADDR
// if cratesSpawned >= 18 then
19140: LD_VAR 0 2
19144: PUSH
19145: LD_INT 18
19147: GREATEREQUAL
19148: IFFALSE 19164
// timer := timer + 0 0$9 ;
19150: LD_ADDR_VAR 0 1
19154: PUSH
19155: LD_VAR 0 1
19159: PUSH
19160: LD_INT 315
19162: PLUS
19163: ST_TO_ADDR
// if timer > 3 3$00 then
19164: LD_VAR 0 1
19168: PUSH
19169: LD_INT 6300
19171: GREATER
19172: IFFALSE 19182
// timer := 0 0$50 ;
19174: LD_ADDR_VAR 0 1
19178: PUSH
19179: LD_INT 1750
19181: ST_TO_ADDR
// CreateCratesArea ( rand ( 3 , 5 ) , CratesSpawnArea , true ) ;
19182: LD_INT 3
19184: PPUSH
19185: LD_INT 5
19187: PPUSH
19188: CALL_OW 12
19192: PPUSH
19193: LD_INT 15
19195: PPUSH
19196: LD_INT 1
19198: PPUSH
19199: CALL_OW 55
// cratesSpawned = cratesSpawned + 1 ;
19203: LD_ADDR_VAR 0 2
19207: PUSH
19208: LD_VAR 0 2
19212: PUSH
19213: LD_INT 1
19215: PLUS
19216: ST_TO_ADDR
// until false ;
19217: LD_INT 0
19219: IFFALSE 19097
// end ; end_of_file
19221: PPOPN 2
19223: END
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
19224: LD_INT 0
19226: PPUSH
19227: PPUSH
// if exist_mode then
19228: LD_VAR 0 2
19232: IFFALSE 19257
// unit := CreateCharacter ( prefix & ident ) else
19234: LD_ADDR_VAR 0 5
19238: PUSH
19239: LD_VAR 0 3
19243: PUSH
19244: LD_VAR 0 1
19248: STR
19249: PPUSH
19250: CALL_OW 34
19254: ST_TO_ADDR
19255: GO 19272
// unit := NewCharacter ( ident ) ;
19257: LD_ADDR_VAR 0 5
19261: PUSH
19262: LD_VAR 0 1
19266: PPUSH
19267: CALL_OW 25
19271: ST_TO_ADDR
// result := unit ;
19272: LD_ADDR_VAR 0 4
19276: PUSH
19277: LD_VAR 0 5
19281: ST_TO_ADDR
// end ;
19282: LD_VAR 0 4
19286: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
19287: LD_INT 0
19289: PPUSH
19290: PPUSH
// if not side or not nation then
19291: LD_VAR 0 1
19295: NOT
19296: PUSH
19297: LD_VAR 0 2
19301: NOT
19302: OR
19303: IFFALSE 19307
// exit ;
19305: GO 20075
// case nation of nation_american :
19307: LD_VAR 0 2
19311: PUSH
19312: LD_INT 1
19314: DOUBLE
19315: EQUAL
19316: IFTRUE 19320
19318: GO 19534
19320: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 86 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 , 82 , 83 , 84 , 85 , 86 ] ; nation_arabian :
19321: LD_ADDR_VAR 0 4
19325: PUSH
19326: LD_INT 35
19328: PUSH
19329: LD_INT 45
19331: PUSH
19332: LD_INT 46
19334: PUSH
19335: LD_INT 47
19337: PUSH
19338: LD_INT 82
19340: PUSH
19341: LD_INT 83
19343: PUSH
19344: LD_INT 84
19346: PUSH
19347: LD_INT 85
19349: PUSH
19350: LD_INT 86
19352: PUSH
19353: LD_INT 1
19355: PUSH
19356: LD_INT 2
19358: PUSH
19359: LD_INT 6
19361: PUSH
19362: LD_INT 15
19364: PUSH
19365: LD_INT 16
19367: PUSH
19368: LD_INT 7
19370: PUSH
19371: LD_INT 12
19373: PUSH
19374: LD_INT 13
19376: PUSH
19377: LD_INT 10
19379: PUSH
19380: LD_INT 14
19382: PUSH
19383: LD_INT 20
19385: PUSH
19386: LD_INT 21
19388: PUSH
19389: LD_INT 22
19391: PUSH
19392: LD_INT 25
19394: PUSH
19395: LD_INT 32
19397: PUSH
19398: LD_INT 27
19400: PUSH
19401: LD_INT 36
19403: PUSH
19404: LD_INT 69
19406: PUSH
19407: LD_INT 39
19409: PUSH
19410: LD_INT 34
19412: PUSH
19413: LD_INT 40
19415: PUSH
19416: LD_INT 48
19418: PUSH
19419: LD_INT 49
19421: PUSH
19422: LD_INT 50
19424: PUSH
19425: LD_INT 51
19427: PUSH
19428: LD_INT 52
19430: PUSH
19431: LD_INT 53
19433: PUSH
19434: LD_INT 54
19436: PUSH
19437: LD_INT 55
19439: PUSH
19440: LD_INT 56
19442: PUSH
19443: LD_INT 57
19445: PUSH
19446: LD_INT 58
19448: PUSH
19449: LD_INT 59
19451: PUSH
19452: LD_INT 60
19454: PUSH
19455: LD_INT 61
19457: PUSH
19458: LD_INT 62
19460: PUSH
19461: LD_INT 80
19463: PUSH
19464: LD_INT 82
19466: PUSH
19467: LD_INT 83
19469: PUSH
19470: LD_INT 84
19472: PUSH
19473: LD_INT 85
19475: PUSH
19476: LD_INT 86
19478: PUSH
19479: EMPTY
19480: LIST
19481: LIST
19482: LIST
19483: LIST
19484: LIST
19485: LIST
19486: LIST
19487: LIST
19488: LIST
19489: LIST
19490: LIST
19491: LIST
19492: LIST
19493: LIST
19494: LIST
19495: LIST
19496: LIST
19497: LIST
19498: LIST
19499: LIST
19500: LIST
19501: LIST
19502: LIST
19503: LIST
19504: LIST
19505: LIST
19506: LIST
19507: LIST
19508: LIST
19509: LIST
19510: LIST
19511: LIST
19512: LIST
19513: LIST
19514: LIST
19515: LIST
19516: LIST
19517: LIST
19518: LIST
19519: LIST
19520: LIST
19521: LIST
19522: LIST
19523: LIST
19524: LIST
19525: LIST
19526: LIST
19527: LIST
19528: LIST
19529: LIST
19530: LIST
19531: ST_TO_ADDR
19532: GO 19999
19534: LD_INT 2
19536: DOUBLE
19537: EQUAL
19538: IFTRUE 19542
19540: GO 19768
19542: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 87 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 , 82 , 83 , 84 , 85 , 87 , 88 ] ; nation_russian :
19543: LD_ADDR_VAR 0 4
19547: PUSH
19548: LD_INT 35
19550: PUSH
19551: LD_INT 45
19553: PUSH
19554: LD_INT 46
19556: PUSH
19557: LD_INT 47
19559: PUSH
19560: LD_INT 82
19562: PUSH
19563: LD_INT 83
19565: PUSH
19566: LD_INT 84
19568: PUSH
19569: LD_INT 85
19571: PUSH
19572: LD_INT 87
19574: PUSH
19575: LD_INT 70
19577: PUSH
19578: LD_INT 1
19580: PUSH
19581: LD_INT 11
19583: PUSH
19584: LD_INT 3
19586: PUSH
19587: LD_INT 4
19589: PUSH
19590: LD_INT 5
19592: PUSH
19593: LD_INT 6
19595: PUSH
19596: LD_INT 15
19598: PUSH
19599: LD_INT 18
19601: PUSH
19602: LD_INT 7
19604: PUSH
19605: LD_INT 17
19607: PUSH
19608: LD_INT 8
19610: PUSH
19611: LD_INT 20
19613: PUSH
19614: LD_INT 21
19616: PUSH
19617: LD_INT 22
19619: PUSH
19620: LD_INT 72
19622: PUSH
19623: LD_INT 26
19625: PUSH
19626: LD_INT 69
19628: PUSH
19629: LD_INT 39
19631: PUSH
19632: LD_INT 40
19634: PUSH
19635: LD_INT 41
19637: PUSH
19638: LD_INT 42
19640: PUSH
19641: LD_INT 43
19643: PUSH
19644: LD_INT 48
19646: PUSH
19647: LD_INT 49
19649: PUSH
19650: LD_INT 50
19652: PUSH
19653: LD_INT 51
19655: PUSH
19656: LD_INT 52
19658: PUSH
19659: LD_INT 53
19661: PUSH
19662: LD_INT 54
19664: PUSH
19665: LD_INT 55
19667: PUSH
19668: LD_INT 56
19670: PUSH
19671: LD_INT 60
19673: PUSH
19674: LD_INT 61
19676: PUSH
19677: LD_INT 62
19679: PUSH
19680: LD_INT 66
19682: PUSH
19683: LD_INT 67
19685: PUSH
19686: LD_INT 68
19688: PUSH
19689: LD_INT 81
19691: PUSH
19692: LD_INT 82
19694: PUSH
19695: LD_INT 83
19697: PUSH
19698: LD_INT 84
19700: PUSH
19701: LD_INT 85
19703: PUSH
19704: LD_INT 87
19706: PUSH
19707: LD_INT 88
19709: PUSH
19710: EMPTY
19711: LIST
19712: LIST
19713: LIST
19714: LIST
19715: LIST
19716: LIST
19717: LIST
19718: LIST
19719: LIST
19720: LIST
19721: LIST
19722: LIST
19723: LIST
19724: LIST
19725: LIST
19726: LIST
19727: LIST
19728: LIST
19729: LIST
19730: LIST
19731: LIST
19732: LIST
19733: LIST
19734: LIST
19735: LIST
19736: LIST
19737: LIST
19738: LIST
19739: LIST
19740: LIST
19741: LIST
19742: LIST
19743: LIST
19744: LIST
19745: LIST
19746: LIST
19747: LIST
19748: LIST
19749: LIST
19750: LIST
19751: LIST
19752: LIST
19753: LIST
19754: LIST
19755: LIST
19756: LIST
19757: LIST
19758: LIST
19759: LIST
19760: LIST
19761: LIST
19762: LIST
19763: LIST
19764: LIST
19765: ST_TO_ADDR
19766: GO 19999
19768: LD_INT 3
19770: DOUBLE
19771: EQUAL
19772: IFTRUE 19776
19774: GO 19998
19776: POP
// result := [ 46 , 47 , 1 , 2 , 82 , 83 , 84 , 85 , 86 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 , 82 , 83 , 84 , 85 , 86 ] ; end ;
19777: LD_ADDR_VAR 0 4
19781: PUSH
19782: LD_INT 46
19784: PUSH
19785: LD_INT 47
19787: PUSH
19788: LD_INT 1
19790: PUSH
19791: LD_INT 2
19793: PUSH
19794: LD_INT 82
19796: PUSH
19797: LD_INT 83
19799: PUSH
19800: LD_INT 84
19802: PUSH
19803: LD_INT 85
19805: PUSH
19806: LD_INT 86
19808: PUSH
19809: LD_INT 11
19811: PUSH
19812: LD_INT 9
19814: PUSH
19815: LD_INT 20
19817: PUSH
19818: LD_INT 19
19820: PUSH
19821: LD_INT 21
19823: PUSH
19824: LD_INT 24
19826: PUSH
19827: LD_INT 22
19829: PUSH
19830: LD_INT 25
19832: PUSH
19833: LD_INT 28
19835: PUSH
19836: LD_INT 29
19838: PUSH
19839: LD_INT 30
19841: PUSH
19842: LD_INT 31
19844: PUSH
19845: LD_INT 37
19847: PUSH
19848: LD_INT 38
19850: PUSH
19851: LD_INT 32
19853: PUSH
19854: LD_INT 27
19856: PUSH
19857: LD_INT 33
19859: PUSH
19860: LD_INT 69
19862: PUSH
19863: LD_INT 39
19865: PUSH
19866: LD_INT 34
19868: PUSH
19869: LD_INT 40
19871: PUSH
19872: LD_INT 71
19874: PUSH
19875: LD_INT 23
19877: PUSH
19878: LD_INT 44
19880: PUSH
19881: LD_INT 48
19883: PUSH
19884: LD_INT 49
19886: PUSH
19887: LD_INT 50
19889: PUSH
19890: LD_INT 51
19892: PUSH
19893: LD_INT 52
19895: PUSH
19896: LD_INT 53
19898: PUSH
19899: LD_INT 54
19901: PUSH
19902: LD_INT 55
19904: PUSH
19905: LD_INT 56
19907: PUSH
19908: LD_INT 57
19910: PUSH
19911: LD_INT 58
19913: PUSH
19914: LD_INT 59
19916: PUSH
19917: LD_INT 63
19919: PUSH
19920: LD_INT 64
19922: PUSH
19923: LD_INT 65
19925: PUSH
19926: LD_INT 82
19928: PUSH
19929: LD_INT 83
19931: PUSH
19932: LD_INT 84
19934: PUSH
19935: LD_INT 85
19937: PUSH
19938: LD_INT 86
19940: PUSH
19941: EMPTY
19942: LIST
19943: LIST
19944: LIST
19945: LIST
19946: LIST
19947: LIST
19948: LIST
19949: LIST
19950: LIST
19951: LIST
19952: LIST
19953: LIST
19954: LIST
19955: LIST
19956: LIST
19957: LIST
19958: LIST
19959: LIST
19960: LIST
19961: LIST
19962: LIST
19963: LIST
19964: LIST
19965: LIST
19966: LIST
19967: LIST
19968: LIST
19969: LIST
19970: LIST
19971: LIST
19972: LIST
19973: LIST
19974: LIST
19975: LIST
19976: LIST
19977: LIST
19978: LIST
19979: LIST
19980: LIST
19981: LIST
19982: LIST
19983: LIST
19984: LIST
19985: LIST
19986: LIST
19987: LIST
19988: LIST
19989: LIST
19990: LIST
19991: LIST
19992: LIST
19993: LIST
19994: LIST
19995: ST_TO_ADDR
19996: GO 19999
19998: POP
// if state > - 1 and state < 3 then
19999: LD_VAR 0 3
20003: PUSH
20004: LD_INT 1
20006: NEG
20007: GREATER
20008: PUSH
20009: LD_VAR 0 3
20013: PUSH
20014: LD_INT 3
20016: LESS
20017: AND
20018: IFFALSE 20075
// for i in result do
20020: LD_ADDR_VAR 0 5
20024: PUSH
20025: LD_VAR 0 4
20029: PUSH
20030: FOR_IN
20031: IFFALSE 20073
// if GetTech ( i , side ) <> state then
20033: LD_VAR 0 5
20037: PPUSH
20038: LD_VAR 0 1
20042: PPUSH
20043: CALL_OW 321
20047: PUSH
20048: LD_VAR 0 3
20052: NONEQUAL
20053: IFFALSE 20071
// result := result diff i ;
20055: LD_ADDR_VAR 0 4
20059: PUSH
20060: LD_VAR 0 4
20064: PUSH
20065: LD_VAR 0 5
20069: DIFF
20070: ST_TO_ADDR
20071: GO 20030
20073: POP
20074: POP
// end ;
20075: LD_VAR 0 4
20079: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
20080: LD_INT 0
20082: PPUSH
20083: PPUSH
20084: PPUSH
// result := true ;
20085: LD_ADDR_VAR 0 3
20089: PUSH
20090: LD_INT 1
20092: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
20093: LD_ADDR_VAR 0 5
20097: PUSH
20098: LD_VAR 0 2
20102: PPUSH
20103: CALL_OW 480
20107: ST_TO_ADDR
// if not tmp then
20108: LD_VAR 0 5
20112: NOT
20113: IFFALSE 20117
// exit ;
20115: GO 20166
// for i in tmp do
20117: LD_ADDR_VAR 0 4
20121: PUSH
20122: LD_VAR 0 5
20126: PUSH
20127: FOR_IN
20128: IFFALSE 20164
// if GetTech ( i , side ) <> state_researched then
20130: LD_VAR 0 4
20134: PPUSH
20135: LD_VAR 0 1
20139: PPUSH
20140: CALL_OW 321
20144: PUSH
20145: LD_INT 2
20147: NONEQUAL
20148: IFFALSE 20162
// begin result := false ;
20150: LD_ADDR_VAR 0 3
20154: PUSH
20155: LD_INT 0
20157: ST_TO_ADDR
// exit ;
20158: POP
20159: POP
20160: GO 20166
// end ;
20162: GO 20127
20164: POP
20165: POP
// end ;
20166: LD_VAR 0 3
20170: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
20171: LD_INT 0
20173: PPUSH
20174: PPUSH
20175: PPUSH
20176: PPUSH
20177: PPUSH
20178: PPUSH
20179: PPUSH
20180: PPUSH
20181: PPUSH
20182: PPUSH
20183: PPUSH
20184: PPUSH
20185: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
20186: LD_VAR 0 1
20190: NOT
20191: PUSH
20192: LD_VAR 0 1
20196: PPUSH
20197: CALL_OW 257
20201: PUSH
20202: LD_INT 9
20204: NONEQUAL
20205: OR
20206: IFFALSE 20210
// exit ;
20208: GO 20783
// side := GetSide ( unit ) ;
20210: LD_ADDR_VAR 0 9
20214: PUSH
20215: LD_VAR 0 1
20219: PPUSH
20220: CALL_OW 255
20224: ST_TO_ADDR
// tech_space := tech_spacanom ;
20225: LD_ADDR_VAR 0 12
20229: PUSH
20230: LD_INT 29
20232: ST_TO_ADDR
// tech_time := tech_taurad ;
20233: LD_ADDR_VAR 0 13
20237: PUSH
20238: LD_INT 28
20240: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
20241: LD_ADDR_VAR 0 11
20245: PUSH
20246: LD_VAR 0 1
20250: PPUSH
20251: CALL_OW 310
20255: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
20256: LD_VAR 0 11
20260: PPUSH
20261: CALL_OW 247
20265: PUSH
20266: LD_INT 2
20268: EQUAL
20269: IFFALSE 20273
// exit ;
20271: GO 20783
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
20273: LD_ADDR_VAR 0 8
20277: PUSH
20278: LD_INT 81
20280: PUSH
20281: LD_VAR 0 9
20285: PUSH
20286: EMPTY
20287: LIST
20288: LIST
20289: PUSH
20290: LD_INT 3
20292: PUSH
20293: LD_INT 21
20295: PUSH
20296: LD_INT 3
20298: PUSH
20299: EMPTY
20300: LIST
20301: LIST
20302: PUSH
20303: EMPTY
20304: LIST
20305: LIST
20306: PUSH
20307: EMPTY
20308: LIST
20309: LIST
20310: PPUSH
20311: CALL_OW 69
20315: ST_TO_ADDR
// if not tmp then
20316: LD_VAR 0 8
20320: NOT
20321: IFFALSE 20325
// exit ;
20323: GO 20783
// if in_unit then
20325: LD_VAR 0 11
20329: IFFALSE 20353
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
20331: LD_ADDR_VAR 0 10
20335: PUSH
20336: LD_VAR 0 8
20340: PPUSH
20341: LD_VAR 0 11
20345: PPUSH
20346: CALL_OW 74
20350: ST_TO_ADDR
20351: GO 20373
// enemy := NearestUnitToUnit ( tmp , unit ) ;
20353: LD_ADDR_VAR 0 10
20357: PUSH
20358: LD_VAR 0 8
20362: PPUSH
20363: LD_VAR 0 1
20367: PPUSH
20368: CALL_OW 74
20372: ST_TO_ADDR
// if not enemy then
20373: LD_VAR 0 10
20377: NOT
20378: IFFALSE 20382
// exit ;
20380: GO 20783
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
20382: LD_VAR 0 11
20386: PUSH
20387: LD_VAR 0 11
20391: PPUSH
20392: LD_VAR 0 10
20396: PPUSH
20397: CALL_OW 296
20401: PUSH
20402: LD_INT 13
20404: GREATER
20405: AND
20406: PUSH
20407: LD_VAR 0 1
20411: PPUSH
20412: LD_VAR 0 10
20416: PPUSH
20417: CALL_OW 296
20421: PUSH
20422: LD_INT 12
20424: GREATER
20425: OR
20426: IFFALSE 20430
// exit ;
20428: GO 20783
// missile := [ 1 ] ;
20430: LD_ADDR_VAR 0 14
20434: PUSH
20435: LD_INT 1
20437: PUSH
20438: EMPTY
20439: LIST
20440: ST_TO_ADDR
// if Researched ( side , tech_space ) then
20441: LD_VAR 0 9
20445: PPUSH
20446: LD_VAR 0 12
20450: PPUSH
20451: CALL_OW 325
20455: IFFALSE 20484
// missile := Replace ( missile , missile + 1 , 2 ) ;
20457: LD_ADDR_VAR 0 14
20461: PUSH
20462: LD_VAR 0 14
20466: PPUSH
20467: LD_VAR 0 14
20471: PUSH
20472: LD_INT 1
20474: PLUS
20475: PPUSH
20476: LD_INT 2
20478: PPUSH
20479: CALL_OW 1
20483: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
20484: LD_VAR 0 9
20488: PPUSH
20489: LD_VAR 0 13
20493: PPUSH
20494: CALL_OW 325
20498: PUSH
20499: LD_VAR 0 10
20503: PPUSH
20504: CALL_OW 255
20508: PPUSH
20509: LD_VAR 0 13
20513: PPUSH
20514: CALL_OW 325
20518: NOT
20519: AND
20520: IFFALSE 20549
// missile := Replace ( missile , missile + 1 , 3 ) ;
20522: LD_ADDR_VAR 0 14
20526: PUSH
20527: LD_VAR 0 14
20531: PPUSH
20532: LD_VAR 0 14
20536: PUSH
20537: LD_INT 1
20539: PLUS
20540: PPUSH
20541: LD_INT 3
20543: PPUSH
20544: CALL_OW 1
20548: ST_TO_ADDR
// if missile < 2 then
20549: LD_VAR 0 14
20553: PUSH
20554: LD_INT 2
20556: LESS
20557: IFFALSE 20561
// exit ;
20559: GO 20783
// x := GetX ( enemy ) ;
20561: LD_ADDR_VAR 0 4
20565: PUSH
20566: LD_VAR 0 10
20570: PPUSH
20571: CALL_OW 250
20575: ST_TO_ADDR
// y := GetY ( enemy ) ;
20576: LD_ADDR_VAR 0 5
20580: PUSH
20581: LD_VAR 0 10
20585: PPUSH
20586: CALL_OW 251
20590: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
20591: LD_ADDR_VAR 0 6
20595: PUSH
20596: LD_VAR 0 4
20600: PUSH
20601: LD_INT 1
20603: NEG
20604: PPUSH
20605: LD_INT 1
20607: PPUSH
20608: CALL_OW 12
20612: PLUS
20613: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
20614: LD_ADDR_VAR 0 7
20618: PUSH
20619: LD_VAR 0 5
20623: PUSH
20624: LD_INT 1
20626: NEG
20627: PPUSH
20628: LD_INT 1
20630: PPUSH
20631: CALL_OW 12
20635: PLUS
20636: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
20637: LD_VAR 0 6
20641: PPUSH
20642: LD_VAR 0 7
20646: PPUSH
20647: CALL_OW 488
20651: NOT
20652: IFFALSE 20674
// begin _x := x ;
20654: LD_ADDR_VAR 0 6
20658: PUSH
20659: LD_VAR 0 4
20663: ST_TO_ADDR
// _y := y ;
20664: LD_ADDR_VAR 0 7
20668: PUSH
20669: LD_VAR 0 5
20673: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
20674: LD_ADDR_VAR 0 3
20678: PUSH
20679: LD_INT 1
20681: PPUSH
20682: LD_VAR 0 14
20686: PPUSH
20687: CALL_OW 12
20691: ST_TO_ADDR
// case i of 1 :
20692: LD_VAR 0 3
20696: PUSH
20697: LD_INT 1
20699: DOUBLE
20700: EQUAL
20701: IFTRUE 20705
20703: GO 20722
20705: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
20706: LD_VAR 0 1
20710: PPUSH
20711: LD_VAR 0 10
20715: PPUSH
20716: CALL_OW 115
20720: GO 20783
20722: LD_INT 2
20724: DOUBLE
20725: EQUAL
20726: IFTRUE 20730
20728: GO 20752
20730: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
20731: LD_VAR 0 1
20735: PPUSH
20736: LD_VAR 0 6
20740: PPUSH
20741: LD_VAR 0 7
20745: PPUSH
20746: CALL_OW 153
20750: GO 20783
20752: LD_INT 3
20754: DOUBLE
20755: EQUAL
20756: IFTRUE 20760
20758: GO 20782
20760: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
20761: LD_VAR 0 1
20765: PPUSH
20766: LD_VAR 0 6
20770: PPUSH
20771: LD_VAR 0 7
20775: PPUSH
20776: CALL_OW 154
20780: GO 20783
20782: POP
// end ;
20783: LD_VAR 0 2
20787: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
20788: LD_INT 0
20790: PPUSH
20791: PPUSH
20792: PPUSH
20793: PPUSH
20794: PPUSH
20795: PPUSH
// if not unit or not building then
20796: LD_VAR 0 1
20800: NOT
20801: PUSH
20802: LD_VAR 0 2
20806: NOT
20807: OR
20808: IFFALSE 20812
// exit ;
20810: GO 20970
// x := GetX ( building ) ;
20812: LD_ADDR_VAR 0 5
20816: PUSH
20817: LD_VAR 0 2
20821: PPUSH
20822: CALL_OW 250
20826: ST_TO_ADDR
// y := GetY ( building ) ;
20827: LD_ADDR_VAR 0 6
20831: PUSH
20832: LD_VAR 0 2
20836: PPUSH
20837: CALL_OW 251
20841: ST_TO_ADDR
// for i = 0 to 5 do
20842: LD_ADDR_VAR 0 4
20846: PUSH
20847: DOUBLE
20848: LD_INT 0
20850: DEC
20851: ST_TO_ADDR
20852: LD_INT 5
20854: PUSH
20855: FOR_TO
20856: IFFALSE 20968
// begin _x := ShiftX ( x , i , 3 ) ;
20858: LD_ADDR_VAR 0 7
20862: PUSH
20863: LD_VAR 0 5
20867: PPUSH
20868: LD_VAR 0 4
20872: PPUSH
20873: LD_INT 3
20875: PPUSH
20876: CALL_OW 272
20880: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
20881: LD_ADDR_VAR 0 8
20885: PUSH
20886: LD_VAR 0 6
20890: PPUSH
20891: LD_VAR 0 4
20895: PPUSH
20896: LD_INT 3
20898: PPUSH
20899: CALL_OW 273
20903: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
20904: LD_VAR 0 7
20908: PPUSH
20909: LD_VAR 0 8
20913: PPUSH
20914: CALL_OW 488
20918: NOT
20919: IFFALSE 20923
// continue ;
20921: GO 20855
// if HexInfo ( _x , _y ) = 0 then
20923: LD_VAR 0 7
20927: PPUSH
20928: LD_VAR 0 8
20932: PPUSH
20933: CALL_OW 428
20937: PUSH
20938: LD_INT 0
20940: EQUAL
20941: IFFALSE 20966
// begin ComMoveXY ( unit , _x , _y ) ;
20943: LD_VAR 0 1
20947: PPUSH
20948: LD_VAR 0 7
20952: PPUSH
20953: LD_VAR 0 8
20957: PPUSH
20958: CALL_OW 111
// exit ;
20962: POP
20963: POP
20964: GO 20970
// end ; end ;
20966: GO 20855
20968: POP
20969: POP
// end ;
20970: LD_VAR 0 3
20974: RET
// export function ScanBase ( side , base_area ) ; begin
20975: LD_INT 0
20977: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
20978: LD_ADDR_VAR 0 3
20982: PUSH
20983: LD_VAR 0 2
20987: PPUSH
20988: LD_INT 81
20990: PUSH
20991: LD_VAR 0 1
20995: PUSH
20996: EMPTY
20997: LIST
20998: LIST
20999: PPUSH
21000: CALL_OW 70
21004: ST_TO_ADDR
// end ;
21005: LD_VAR 0 3
21009: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
21010: LD_INT 0
21012: PPUSH
21013: PPUSH
21014: PPUSH
21015: PPUSH
// result := false ;
21016: LD_ADDR_VAR 0 2
21020: PUSH
21021: LD_INT 0
21023: ST_TO_ADDR
// side := GetSide ( unit ) ;
21024: LD_ADDR_VAR 0 3
21028: PUSH
21029: LD_VAR 0 1
21033: PPUSH
21034: CALL_OW 255
21038: ST_TO_ADDR
// nat := GetNation ( unit ) ;
21039: LD_ADDR_VAR 0 4
21043: PUSH
21044: LD_VAR 0 1
21048: PPUSH
21049: CALL_OW 248
21053: ST_TO_ADDR
// case nat of 1 :
21054: LD_VAR 0 4
21058: PUSH
21059: LD_INT 1
21061: DOUBLE
21062: EQUAL
21063: IFTRUE 21067
21065: GO 21078
21067: POP
// tech := tech_lassight ; 2 :
21068: LD_ADDR_VAR 0 5
21072: PUSH
21073: LD_INT 12
21075: ST_TO_ADDR
21076: GO 21117
21078: LD_INT 2
21080: DOUBLE
21081: EQUAL
21082: IFTRUE 21086
21084: GO 21097
21086: POP
// tech := tech_mortar ; 3 :
21087: LD_ADDR_VAR 0 5
21091: PUSH
21092: LD_INT 41
21094: ST_TO_ADDR
21095: GO 21117
21097: LD_INT 3
21099: DOUBLE
21100: EQUAL
21101: IFTRUE 21105
21103: GO 21116
21105: POP
// tech := tech_bazooka ; end ;
21106: LD_ADDR_VAR 0 5
21110: PUSH
21111: LD_INT 44
21113: ST_TO_ADDR
21114: GO 21117
21116: POP
// if Researched ( side , tech ) then
21117: LD_VAR 0 3
21121: PPUSH
21122: LD_VAR 0 5
21126: PPUSH
21127: CALL_OW 325
21131: IFFALSE 21158
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
21133: LD_ADDR_VAR 0 2
21137: PUSH
21138: LD_INT 5
21140: PUSH
21141: LD_INT 8
21143: PUSH
21144: LD_INT 9
21146: PUSH
21147: EMPTY
21148: LIST
21149: LIST
21150: LIST
21151: PUSH
21152: LD_VAR 0 4
21156: ARRAY
21157: ST_TO_ADDR
// end ;
21158: LD_VAR 0 2
21162: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
21163: LD_INT 0
21165: PPUSH
21166: PPUSH
21167: PPUSH
// if not mines then
21168: LD_VAR 0 2
21172: NOT
21173: IFFALSE 21177
// exit ;
21175: GO 21321
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
21177: LD_ADDR_VAR 0 5
21181: PUSH
21182: LD_INT 81
21184: PUSH
21185: LD_VAR 0 1
21189: PUSH
21190: EMPTY
21191: LIST
21192: LIST
21193: PUSH
21194: LD_INT 3
21196: PUSH
21197: LD_INT 21
21199: PUSH
21200: LD_INT 3
21202: PUSH
21203: EMPTY
21204: LIST
21205: LIST
21206: PUSH
21207: EMPTY
21208: LIST
21209: LIST
21210: PUSH
21211: EMPTY
21212: LIST
21213: LIST
21214: PPUSH
21215: CALL_OW 69
21219: ST_TO_ADDR
// for i in mines do
21220: LD_ADDR_VAR 0 4
21224: PUSH
21225: LD_VAR 0 2
21229: PUSH
21230: FOR_IN
21231: IFFALSE 21319
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
21233: LD_VAR 0 4
21237: PUSH
21238: LD_INT 1
21240: ARRAY
21241: PPUSH
21242: LD_VAR 0 4
21246: PUSH
21247: LD_INT 2
21249: ARRAY
21250: PPUSH
21251: CALL_OW 458
21255: NOT
21256: IFFALSE 21260
// continue ;
21258: GO 21230
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
21260: LD_VAR 0 4
21264: PUSH
21265: LD_INT 1
21267: ARRAY
21268: PPUSH
21269: LD_VAR 0 4
21273: PUSH
21274: LD_INT 2
21276: ARRAY
21277: PPUSH
21278: CALL_OW 428
21282: PUSH
21283: LD_VAR 0 5
21287: IN
21288: IFFALSE 21317
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
21290: LD_VAR 0 4
21294: PUSH
21295: LD_INT 1
21297: ARRAY
21298: PPUSH
21299: LD_VAR 0 4
21303: PUSH
21304: LD_INT 2
21306: ARRAY
21307: PPUSH
21308: LD_VAR 0 1
21312: PPUSH
21313: CALL_OW 456
// end ;
21317: GO 21230
21319: POP
21320: POP
// end ;
21321: LD_VAR 0 3
21325: RET
// export function Count ( array ) ; var i ; begin
21326: LD_INT 0
21328: PPUSH
21329: PPUSH
// result := 0 ;
21330: LD_ADDR_VAR 0 2
21334: PUSH
21335: LD_INT 0
21337: ST_TO_ADDR
// for i in array do
21338: LD_ADDR_VAR 0 3
21342: PUSH
21343: LD_VAR 0 1
21347: PUSH
21348: FOR_IN
21349: IFFALSE 21373
// if i then
21351: LD_VAR 0 3
21355: IFFALSE 21371
// result := result + 1 ;
21357: LD_ADDR_VAR 0 2
21361: PUSH
21362: LD_VAR 0 2
21366: PUSH
21367: LD_INT 1
21369: PLUS
21370: ST_TO_ADDR
21371: GO 21348
21373: POP
21374: POP
// end ;
21375: LD_VAR 0 2
21379: RET
// export function IsEmpty ( building ) ; begin
21380: LD_INT 0
21382: PPUSH
// if not building then
21383: LD_VAR 0 1
21387: NOT
21388: IFFALSE 21392
// exit ;
21390: GO 21435
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
21392: LD_ADDR_VAR 0 2
21396: PUSH
21397: LD_VAR 0 1
21401: PUSH
21402: LD_INT 22
21404: PUSH
21405: LD_VAR 0 1
21409: PPUSH
21410: CALL_OW 255
21414: PUSH
21415: EMPTY
21416: LIST
21417: LIST
21418: PUSH
21419: LD_INT 58
21421: PUSH
21422: EMPTY
21423: LIST
21424: PUSH
21425: EMPTY
21426: LIST
21427: LIST
21428: PPUSH
21429: CALL_OW 69
21433: IN
21434: ST_TO_ADDR
// end ;
21435: LD_VAR 0 2
21439: RET
// export function IsNotFull ( building ) ; var places ; begin
21440: LD_INT 0
21442: PPUSH
21443: PPUSH
// if not building then
21444: LD_VAR 0 1
21448: NOT
21449: IFFALSE 21453
// exit ;
21451: GO 21624
// result := false ;
21453: LD_ADDR_VAR 0 2
21457: PUSH
21458: LD_INT 0
21460: ST_TO_ADDR
// places := 0 ;
21461: LD_ADDR_VAR 0 3
21465: PUSH
21466: LD_INT 0
21468: ST_TO_ADDR
// case GetBType ( building ) of b_depot , b_warehouse , b_lab , b_lab_half , b_lab_full , b_armoury , b_barracks , b_workshop , b_factory , b_fort :
21469: LD_VAR 0 1
21473: PPUSH
21474: CALL_OW 266
21478: PUSH
21479: LD_INT 0
21481: DOUBLE
21482: EQUAL
21483: IFTRUE 21541
21485: LD_INT 1
21487: DOUBLE
21488: EQUAL
21489: IFTRUE 21541
21491: LD_INT 6
21493: DOUBLE
21494: EQUAL
21495: IFTRUE 21541
21497: LD_INT 7
21499: DOUBLE
21500: EQUAL
21501: IFTRUE 21541
21503: LD_INT 8
21505: DOUBLE
21506: EQUAL
21507: IFTRUE 21541
21509: LD_INT 4
21511: DOUBLE
21512: EQUAL
21513: IFTRUE 21541
21515: LD_INT 5
21517: DOUBLE
21518: EQUAL
21519: IFTRUE 21541
21521: LD_INT 2
21523: DOUBLE
21524: EQUAL
21525: IFTRUE 21541
21527: LD_INT 3
21529: DOUBLE
21530: EQUAL
21531: IFTRUE 21541
21533: LD_INT 35
21535: DOUBLE
21536: EQUAL
21537: IFTRUE 21541
21539: GO 21552
21541: POP
// places := 6 ; b_bunker , b_breastwork :
21542: LD_ADDR_VAR 0 3
21546: PUSH
21547: LD_INT 6
21549: ST_TO_ADDR
21550: GO 21597
21552: LD_INT 32
21554: DOUBLE
21555: EQUAL
21556: IFTRUE 21566
21558: LD_INT 31
21560: DOUBLE
21561: EQUAL
21562: IFTRUE 21566
21564: GO 21577
21566: POP
// places := 1 ; b_control_tower :
21567: LD_ADDR_VAR 0 3
21571: PUSH
21572: LD_INT 1
21574: ST_TO_ADDR
21575: GO 21597
21577: LD_INT 36
21579: DOUBLE
21580: EQUAL
21581: IFTRUE 21585
21583: GO 21596
21585: POP
// places := 3 ; end ;
21586: LD_ADDR_VAR 0 3
21590: PUSH
21591: LD_INT 3
21593: ST_TO_ADDR
21594: GO 21597
21596: POP
// if places then
21597: LD_VAR 0 3
21601: IFFALSE 21624
// result := UnitsInside ( building ) < places ;
21603: LD_ADDR_VAR 0 2
21607: PUSH
21608: LD_VAR 0 1
21612: PPUSH
21613: CALL_OW 313
21617: PUSH
21618: LD_VAR 0 3
21622: LESS
21623: ST_TO_ADDR
// end ;
21624: LD_VAR 0 2
21628: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
21629: LD_INT 0
21631: PPUSH
21632: PPUSH
21633: PPUSH
21634: PPUSH
// tmp := [ ] ;
21635: LD_ADDR_VAR 0 3
21639: PUSH
21640: EMPTY
21641: ST_TO_ADDR
// list := [ ] ;
21642: LD_ADDR_VAR 0 5
21646: PUSH
21647: EMPTY
21648: ST_TO_ADDR
// for i = 16 to 25 do
21649: LD_ADDR_VAR 0 4
21653: PUSH
21654: DOUBLE
21655: LD_INT 16
21657: DEC
21658: ST_TO_ADDR
21659: LD_INT 25
21661: PUSH
21662: FOR_TO
21663: IFFALSE 21736
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
21665: LD_ADDR_VAR 0 3
21669: PUSH
21670: LD_VAR 0 3
21674: PUSH
21675: LD_INT 22
21677: PUSH
21678: LD_VAR 0 1
21682: PPUSH
21683: CALL_OW 255
21687: PUSH
21688: EMPTY
21689: LIST
21690: LIST
21691: PUSH
21692: LD_INT 91
21694: PUSH
21695: LD_VAR 0 1
21699: PUSH
21700: LD_INT 6
21702: PUSH
21703: EMPTY
21704: LIST
21705: LIST
21706: LIST
21707: PUSH
21708: LD_INT 30
21710: PUSH
21711: LD_VAR 0 4
21715: PUSH
21716: EMPTY
21717: LIST
21718: LIST
21719: PUSH
21720: EMPTY
21721: LIST
21722: LIST
21723: LIST
21724: PUSH
21725: EMPTY
21726: LIST
21727: PPUSH
21728: CALL_OW 69
21732: ADD
21733: ST_TO_ADDR
21734: GO 21662
21736: POP
21737: POP
// for i = 1 to tmp do
21738: LD_ADDR_VAR 0 4
21742: PUSH
21743: DOUBLE
21744: LD_INT 1
21746: DEC
21747: ST_TO_ADDR
21748: LD_VAR 0 3
21752: PUSH
21753: FOR_TO
21754: IFFALSE 21842
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
21756: LD_ADDR_VAR 0 5
21760: PUSH
21761: LD_VAR 0 5
21765: PUSH
21766: LD_VAR 0 3
21770: PUSH
21771: LD_VAR 0 4
21775: ARRAY
21776: PPUSH
21777: CALL_OW 266
21781: PUSH
21782: LD_VAR 0 3
21786: PUSH
21787: LD_VAR 0 4
21791: ARRAY
21792: PPUSH
21793: CALL_OW 250
21797: PUSH
21798: LD_VAR 0 3
21802: PUSH
21803: LD_VAR 0 4
21807: ARRAY
21808: PPUSH
21809: CALL_OW 251
21813: PUSH
21814: LD_VAR 0 3
21818: PUSH
21819: LD_VAR 0 4
21823: ARRAY
21824: PPUSH
21825: CALL_OW 254
21829: PUSH
21830: EMPTY
21831: LIST
21832: LIST
21833: LIST
21834: LIST
21835: PUSH
21836: EMPTY
21837: LIST
21838: ADD
21839: ST_TO_ADDR
21840: GO 21753
21842: POP
21843: POP
// result := list ;
21844: LD_ADDR_VAR 0 2
21848: PUSH
21849: LD_VAR 0 5
21853: ST_TO_ADDR
// end ;
21854: LD_VAR 0 2
21858: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
21859: LD_INT 0
21861: PPUSH
21862: PPUSH
21863: PPUSH
21864: PPUSH
21865: PPUSH
21866: PPUSH
21867: PPUSH
// if not factory then
21868: LD_VAR 0 1
21872: NOT
21873: IFFALSE 21877
// exit ;
21875: GO 22470
// if control = control_apeman then
21877: LD_VAR 0 4
21881: PUSH
21882: LD_INT 5
21884: EQUAL
21885: IFFALSE 21994
// begin tmp := UnitsInside ( factory ) ;
21887: LD_ADDR_VAR 0 8
21891: PUSH
21892: LD_VAR 0 1
21896: PPUSH
21897: CALL_OW 313
21901: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
21902: LD_VAR 0 8
21906: PPUSH
21907: LD_INT 25
21909: PUSH
21910: LD_INT 12
21912: PUSH
21913: EMPTY
21914: LIST
21915: LIST
21916: PPUSH
21917: CALL_OW 72
21921: NOT
21922: IFFALSE 21932
// control := control_manual ;
21924: LD_ADDR_VAR 0 4
21928: PUSH
21929: LD_INT 1
21931: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
21932: LD_ADDR_VAR 0 8
21936: PUSH
21937: LD_VAR 0 1
21941: PPUSH
21942: CALL 21629 0 1
21946: ST_TO_ADDR
// if tmp then
21947: LD_VAR 0 8
21951: IFFALSE 21994
// begin for i in tmp do
21953: LD_ADDR_VAR 0 7
21957: PUSH
21958: LD_VAR 0 8
21962: PUSH
21963: FOR_IN
21964: IFFALSE 21992
// if i [ 1 ] = b_ext_radio then
21966: LD_VAR 0 7
21970: PUSH
21971: LD_INT 1
21973: ARRAY
21974: PUSH
21975: LD_INT 22
21977: EQUAL
21978: IFFALSE 21990
// begin control := control_remote ;
21980: LD_ADDR_VAR 0 4
21984: PUSH
21985: LD_INT 2
21987: ST_TO_ADDR
// break ;
21988: GO 21992
// end ;
21990: GO 21963
21992: POP
21993: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
21994: LD_VAR 0 1
21998: PPUSH
21999: LD_VAR 0 2
22003: PPUSH
22004: LD_VAR 0 3
22008: PPUSH
22009: LD_VAR 0 4
22013: PPUSH
22014: LD_VAR 0 5
22018: PPUSH
22019: CALL_OW 448
22023: IFFALSE 22058
// begin result := [ chassis , engine , control , weapon ] ;
22025: LD_ADDR_VAR 0 6
22029: PUSH
22030: LD_VAR 0 2
22034: PUSH
22035: LD_VAR 0 3
22039: PUSH
22040: LD_VAR 0 4
22044: PUSH
22045: LD_VAR 0 5
22049: PUSH
22050: EMPTY
22051: LIST
22052: LIST
22053: LIST
22054: LIST
22055: ST_TO_ADDR
// exit ;
22056: GO 22470
// end ; _chassis := AvailableChassisList ( factory ) ;
22058: LD_ADDR_VAR 0 9
22062: PUSH
22063: LD_VAR 0 1
22067: PPUSH
22068: CALL_OW 475
22072: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
22073: LD_ADDR_VAR 0 11
22077: PUSH
22078: LD_VAR 0 1
22082: PPUSH
22083: CALL_OW 476
22087: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
22088: LD_ADDR_VAR 0 12
22092: PUSH
22093: LD_VAR 0 1
22097: PPUSH
22098: CALL_OW 477
22102: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
22103: LD_ADDR_VAR 0 10
22107: PUSH
22108: LD_VAR 0 1
22112: PPUSH
22113: CALL_OW 478
22117: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
22118: LD_VAR 0 9
22122: NOT
22123: PUSH
22124: LD_VAR 0 11
22128: NOT
22129: OR
22130: PUSH
22131: LD_VAR 0 12
22135: NOT
22136: OR
22137: PUSH
22138: LD_VAR 0 10
22142: NOT
22143: OR
22144: IFFALSE 22179
// begin result := [ chassis , engine , control , weapon ] ;
22146: LD_ADDR_VAR 0 6
22150: PUSH
22151: LD_VAR 0 2
22155: PUSH
22156: LD_VAR 0 3
22160: PUSH
22161: LD_VAR 0 4
22165: PUSH
22166: LD_VAR 0 5
22170: PUSH
22171: EMPTY
22172: LIST
22173: LIST
22174: LIST
22175: LIST
22176: ST_TO_ADDR
// exit ;
22177: GO 22470
// end ; if not chassis in _chassis then
22179: LD_VAR 0 2
22183: PUSH
22184: LD_VAR 0 9
22188: IN
22189: NOT
22190: IFFALSE 22216
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
22192: LD_ADDR_VAR 0 2
22196: PUSH
22197: LD_VAR 0 9
22201: PUSH
22202: LD_INT 1
22204: PPUSH
22205: LD_VAR 0 9
22209: PPUSH
22210: CALL_OW 12
22214: ARRAY
22215: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
22216: LD_VAR 0 2
22220: PPUSH
22221: LD_VAR 0 3
22225: PPUSH
22226: CALL 22475 0 2
22230: NOT
22231: IFFALSE 22290
// repeat engine := _engine [ 1 ] ;
22233: LD_ADDR_VAR 0 3
22237: PUSH
22238: LD_VAR 0 11
22242: PUSH
22243: LD_INT 1
22245: ARRAY
22246: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
22247: LD_ADDR_VAR 0 11
22251: PUSH
22252: LD_VAR 0 11
22256: PPUSH
22257: LD_INT 1
22259: PPUSH
22260: CALL_OW 3
22264: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
22265: LD_VAR 0 2
22269: PPUSH
22270: LD_VAR 0 3
22274: PPUSH
22275: CALL 22475 0 2
22279: PUSH
22280: LD_VAR 0 11
22284: PUSH
22285: EMPTY
22286: EQUAL
22287: OR
22288: IFFALSE 22233
// if not control in _control then
22290: LD_VAR 0 4
22294: PUSH
22295: LD_VAR 0 12
22299: IN
22300: NOT
22301: IFFALSE 22327
// control := _control [ rand ( 1 , _control ) ] ;
22303: LD_ADDR_VAR 0 4
22307: PUSH
22308: LD_VAR 0 12
22312: PUSH
22313: LD_INT 1
22315: PPUSH
22316: LD_VAR 0 12
22320: PPUSH
22321: CALL_OW 12
22325: ARRAY
22326: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
22327: LD_VAR 0 2
22331: PPUSH
22332: LD_VAR 0 5
22336: PPUSH
22337: CALL 22695 0 2
22341: NOT
22342: IFFALSE 22401
// repeat weapon := _weapon [ 1 ] ;
22344: LD_ADDR_VAR 0 5
22348: PUSH
22349: LD_VAR 0 10
22353: PUSH
22354: LD_INT 1
22356: ARRAY
22357: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
22358: LD_ADDR_VAR 0 10
22362: PUSH
22363: LD_VAR 0 10
22367: PPUSH
22368: LD_INT 1
22370: PPUSH
22371: CALL_OW 3
22375: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
22376: LD_VAR 0 2
22380: PPUSH
22381: LD_VAR 0 5
22385: PPUSH
22386: CALL 22695 0 2
22390: PUSH
22391: LD_VAR 0 10
22395: PUSH
22396: EMPTY
22397: EQUAL
22398: OR
22399: IFFALSE 22344
// result := [ ] ;
22401: LD_ADDR_VAR 0 6
22405: PUSH
22406: EMPTY
22407: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
22408: LD_VAR 0 1
22412: PPUSH
22413: LD_VAR 0 2
22417: PPUSH
22418: LD_VAR 0 3
22422: PPUSH
22423: LD_VAR 0 4
22427: PPUSH
22428: LD_VAR 0 5
22432: PPUSH
22433: CALL_OW 448
22437: IFFALSE 22470
// result := [ chassis , engine , control , weapon ] ;
22439: LD_ADDR_VAR 0 6
22443: PUSH
22444: LD_VAR 0 2
22448: PUSH
22449: LD_VAR 0 3
22453: PUSH
22454: LD_VAR 0 4
22458: PUSH
22459: LD_VAR 0 5
22463: PUSH
22464: EMPTY
22465: LIST
22466: LIST
22467: LIST
22468: LIST
22469: ST_TO_ADDR
// end ;
22470: LD_VAR 0 6
22474: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
22475: LD_INT 0
22477: PPUSH
// if not chassis or not engine then
22478: LD_VAR 0 1
22482: NOT
22483: PUSH
22484: LD_VAR 0 2
22488: NOT
22489: OR
22490: IFFALSE 22494
// exit ;
22492: GO 22690
// case engine of engine_solar :
22494: LD_VAR 0 2
22498: PUSH
22499: LD_INT 2
22501: DOUBLE
22502: EQUAL
22503: IFTRUE 22507
22505: GO 22545
22507: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
22508: LD_ADDR_VAR 0 3
22512: PUSH
22513: LD_INT 11
22515: PUSH
22516: LD_INT 12
22518: PUSH
22519: LD_INT 13
22521: PUSH
22522: LD_INT 14
22524: PUSH
22525: LD_INT 1
22527: PUSH
22528: LD_INT 2
22530: PUSH
22531: LD_INT 3
22533: PUSH
22534: EMPTY
22535: LIST
22536: LIST
22537: LIST
22538: LIST
22539: LIST
22540: LIST
22541: LIST
22542: ST_TO_ADDR
22543: GO 22674
22545: LD_INT 1
22547: DOUBLE
22548: EQUAL
22549: IFTRUE 22553
22551: GO 22615
22553: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
22554: LD_ADDR_VAR 0 3
22558: PUSH
22559: LD_INT 11
22561: PUSH
22562: LD_INT 12
22564: PUSH
22565: LD_INT 13
22567: PUSH
22568: LD_INT 14
22570: PUSH
22571: LD_INT 1
22573: PUSH
22574: LD_INT 2
22576: PUSH
22577: LD_INT 3
22579: PUSH
22580: LD_INT 4
22582: PUSH
22583: LD_INT 5
22585: PUSH
22586: LD_INT 21
22588: PUSH
22589: LD_INT 23
22591: PUSH
22592: LD_INT 22
22594: PUSH
22595: LD_INT 24
22597: PUSH
22598: EMPTY
22599: LIST
22600: LIST
22601: LIST
22602: LIST
22603: LIST
22604: LIST
22605: LIST
22606: LIST
22607: LIST
22608: LIST
22609: LIST
22610: LIST
22611: LIST
22612: ST_TO_ADDR
22613: GO 22674
22615: LD_INT 3
22617: DOUBLE
22618: EQUAL
22619: IFTRUE 22623
22621: GO 22673
22623: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
22624: LD_ADDR_VAR 0 3
22628: PUSH
22629: LD_INT 13
22631: PUSH
22632: LD_INT 14
22634: PUSH
22635: LD_INT 2
22637: PUSH
22638: LD_INT 3
22640: PUSH
22641: LD_INT 4
22643: PUSH
22644: LD_INT 5
22646: PUSH
22647: LD_INT 21
22649: PUSH
22650: LD_INT 22
22652: PUSH
22653: LD_INT 23
22655: PUSH
22656: LD_INT 24
22658: PUSH
22659: EMPTY
22660: LIST
22661: LIST
22662: LIST
22663: LIST
22664: LIST
22665: LIST
22666: LIST
22667: LIST
22668: LIST
22669: LIST
22670: ST_TO_ADDR
22671: GO 22674
22673: POP
// result := ( chassis in result ) ;
22674: LD_ADDR_VAR 0 3
22678: PUSH
22679: LD_VAR 0 1
22683: PUSH
22684: LD_VAR 0 3
22688: IN
22689: ST_TO_ADDR
// end ;
22690: LD_VAR 0 3
22694: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
22695: LD_INT 0
22697: PPUSH
// if not chassis or not weapon then
22698: LD_VAR 0 1
22702: NOT
22703: PUSH
22704: LD_VAR 0 2
22708: NOT
22709: OR
22710: IFFALSE 22714
// exit ;
22712: GO 23776
// case weapon of us_machine_gun :
22714: LD_VAR 0 2
22718: PUSH
22719: LD_INT 2
22721: DOUBLE
22722: EQUAL
22723: IFTRUE 22727
22725: GO 22757
22727: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
22728: LD_ADDR_VAR 0 3
22732: PUSH
22733: LD_INT 1
22735: PUSH
22736: LD_INT 2
22738: PUSH
22739: LD_INT 3
22741: PUSH
22742: LD_INT 4
22744: PUSH
22745: LD_INT 5
22747: PUSH
22748: EMPTY
22749: LIST
22750: LIST
22751: LIST
22752: LIST
22753: LIST
22754: ST_TO_ADDR
22755: GO 23760
22757: LD_INT 3
22759: DOUBLE
22760: EQUAL
22761: IFTRUE 22765
22763: GO 22795
22765: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
22766: LD_ADDR_VAR 0 3
22770: PUSH
22771: LD_INT 1
22773: PUSH
22774: LD_INT 2
22776: PUSH
22777: LD_INT 3
22779: PUSH
22780: LD_INT 4
22782: PUSH
22783: LD_INT 5
22785: PUSH
22786: EMPTY
22787: LIST
22788: LIST
22789: LIST
22790: LIST
22791: LIST
22792: ST_TO_ADDR
22793: GO 23760
22795: LD_INT 11
22797: DOUBLE
22798: EQUAL
22799: IFTRUE 22803
22801: GO 22833
22803: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
22804: LD_ADDR_VAR 0 3
22808: PUSH
22809: LD_INT 1
22811: PUSH
22812: LD_INT 2
22814: PUSH
22815: LD_INT 3
22817: PUSH
22818: LD_INT 4
22820: PUSH
22821: LD_INT 5
22823: PUSH
22824: EMPTY
22825: LIST
22826: LIST
22827: LIST
22828: LIST
22829: LIST
22830: ST_TO_ADDR
22831: GO 23760
22833: LD_INT 4
22835: DOUBLE
22836: EQUAL
22837: IFTRUE 22841
22839: GO 22867
22841: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
22842: LD_ADDR_VAR 0 3
22846: PUSH
22847: LD_INT 2
22849: PUSH
22850: LD_INT 3
22852: PUSH
22853: LD_INT 4
22855: PUSH
22856: LD_INT 5
22858: PUSH
22859: EMPTY
22860: LIST
22861: LIST
22862: LIST
22863: LIST
22864: ST_TO_ADDR
22865: GO 23760
22867: LD_INT 5
22869: DOUBLE
22870: EQUAL
22871: IFTRUE 22875
22873: GO 22901
22875: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
22876: LD_ADDR_VAR 0 3
22880: PUSH
22881: LD_INT 2
22883: PUSH
22884: LD_INT 3
22886: PUSH
22887: LD_INT 4
22889: PUSH
22890: LD_INT 5
22892: PUSH
22893: EMPTY
22894: LIST
22895: LIST
22896: LIST
22897: LIST
22898: ST_TO_ADDR
22899: GO 23760
22901: LD_INT 9
22903: DOUBLE
22904: EQUAL
22905: IFTRUE 22909
22907: GO 22935
22909: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
22910: LD_ADDR_VAR 0 3
22914: PUSH
22915: LD_INT 2
22917: PUSH
22918: LD_INT 3
22920: PUSH
22921: LD_INT 4
22923: PUSH
22924: LD_INT 5
22926: PUSH
22927: EMPTY
22928: LIST
22929: LIST
22930: LIST
22931: LIST
22932: ST_TO_ADDR
22933: GO 23760
22935: LD_INT 7
22937: DOUBLE
22938: EQUAL
22939: IFTRUE 22943
22941: GO 22969
22943: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
22944: LD_ADDR_VAR 0 3
22948: PUSH
22949: LD_INT 2
22951: PUSH
22952: LD_INT 3
22954: PUSH
22955: LD_INT 4
22957: PUSH
22958: LD_INT 5
22960: PUSH
22961: EMPTY
22962: LIST
22963: LIST
22964: LIST
22965: LIST
22966: ST_TO_ADDR
22967: GO 23760
22969: LD_INT 12
22971: DOUBLE
22972: EQUAL
22973: IFTRUE 22977
22975: GO 23003
22977: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
22978: LD_ADDR_VAR 0 3
22982: PUSH
22983: LD_INT 2
22985: PUSH
22986: LD_INT 3
22988: PUSH
22989: LD_INT 4
22991: PUSH
22992: LD_INT 5
22994: PUSH
22995: EMPTY
22996: LIST
22997: LIST
22998: LIST
22999: LIST
23000: ST_TO_ADDR
23001: GO 23760
23003: LD_INT 13
23005: DOUBLE
23006: EQUAL
23007: IFTRUE 23011
23009: GO 23037
23011: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
23012: LD_ADDR_VAR 0 3
23016: PUSH
23017: LD_INT 2
23019: PUSH
23020: LD_INT 3
23022: PUSH
23023: LD_INT 4
23025: PUSH
23026: LD_INT 5
23028: PUSH
23029: EMPTY
23030: LIST
23031: LIST
23032: LIST
23033: LIST
23034: ST_TO_ADDR
23035: GO 23760
23037: LD_INT 14
23039: DOUBLE
23040: EQUAL
23041: IFTRUE 23045
23043: GO 23063
23045: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
23046: LD_ADDR_VAR 0 3
23050: PUSH
23051: LD_INT 4
23053: PUSH
23054: LD_INT 5
23056: PUSH
23057: EMPTY
23058: LIST
23059: LIST
23060: ST_TO_ADDR
23061: GO 23760
23063: LD_INT 6
23065: DOUBLE
23066: EQUAL
23067: IFTRUE 23071
23069: GO 23089
23071: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
23072: LD_ADDR_VAR 0 3
23076: PUSH
23077: LD_INT 4
23079: PUSH
23080: LD_INT 5
23082: PUSH
23083: EMPTY
23084: LIST
23085: LIST
23086: ST_TO_ADDR
23087: GO 23760
23089: LD_INT 10
23091: DOUBLE
23092: EQUAL
23093: IFTRUE 23097
23095: GO 23115
23097: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
23098: LD_ADDR_VAR 0 3
23102: PUSH
23103: LD_INT 4
23105: PUSH
23106: LD_INT 5
23108: PUSH
23109: EMPTY
23110: LIST
23111: LIST
23112: ST_TO_ADDR
23113: GO 23760
23115: LD_INT 22
23117: DOUBLE
23118: EQUAL
23119: IFTRUE 23123
23121: GO 23149
23123: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
23124: LD_ADDR_VAR 0 3
23128: PUSH
23129: LD_INT 11
23131: PUSH
23132: LD_INT 12
23134: PUSH
23135: LD_INT 13
23137: PUSH
23138: LD_INT 14
23140: PUSH
23141: EMPTY
23142: LIST
23143: LIST
23144: LIST
23145: LIST
23146: ST_TO_ADDR
23147: GO 23760
23149: LD_INT 23
23151: DOUBLE
23152: EQUAL
23153: IFTRUE 23157
23155: GO 23183
23157: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
23158: LD_ADDR_VAR 0 3
23162: PUSH
23163: LD_INT 11
23165: PUSH
23166: LD_INT 12
23168: PUSH
23169: LD_INT 13
23171: PUSH
23172: LD_INT 14
23174: PUSH
23175: EMPTY
23176: LIST
23177: LIST
23178: LIST
23179: LIST
23180: ST_TO_ADDR
23181: GO 23760
23183: LD_INT 24
23185: DOUBLE
23186: EQUAL
23187: IFTRUE 23191
23189: GO 23217
23191: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
23192: LD_ADDR_VAR 0 3
23196: PUSH
23197: LD_INT 11
23199: PUSH
23200: LD_INT 12
23202: PUSH
23203: LD_INT 13
23205: PUSH
23206: LD_INT 14
23208: PUSH
23209: EMPTY
23210: LIST
23211: LIST
23212: LIST
23213: LIST
23214: ST_TO_ADDR
23215: GO 23760
23217: LD_INT 30
23219: DOUBLE
23220: EQUAL
23221: IFTRUE 23225
23223: GO 23251
23225: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
23226: LD_ADDR_VAR 0 3
23230: PUSH
23231: LD_INT 11
23233: PUSH
23234: LD_INT 12
23236: PUSH
23237: LD_INT 13
23239: PUSH
23240: LD_INT 14
23242: PUSH
23243: EMPTY
23244: LIST
23245: LIST
23246: LIST
23247: LIST
23248: ST_TO_ADDR
23249: GO 23760
23251: LD_INT 25
23253: DOUBLE
23254: EQUAL
23255: IFTRUE 23259
23257: GO 23277
23259: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
23260: LD_ADDR_VAR 0 3
23264: PUSH
23265: LD_INT 13
23267: PUSH
23268: LD_INT 14
23270: PUSH
23271: EMPTY
23272: LIST
23273: LIST
23274: ST_TO_ADDR
23275: GO 23760
23277: LD_INT 27
23279: DOUBLE
23280: EQUAL
23281: IFTRUE 23285
23283: GO 23303
23285: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_mortar :
23286: LD_ADDR_VAR 0 3
23290: PUSH
23291: LD_INT 13
23293: PUSH
23294: LD_INT 14
23296: PUSH
23297: EMPTY
23298: LIST
23299: LIST
23300: ST_TO_ADDR
23301: GO 23760
23303: LD_EXP 163
23307: DOUBLE
23308: EQUAL
23309: IFTRUE 23313
23311: GO 23339
23313: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
23314: LD_ADDR_VAR 0 3
23318: PUSH
23319: LD_INT 11
23321: PUSH
23322: LD_INT 12
23324: PUSH
23325: LD_INT 13
23327: PUSH
23328: LD_INT 14
23330: PUSH
23331: EMPTY
23332: LIST
23333: LIST
23334: LIST
23335: LIST
23336: ST_TO_ADDR
23337: GO 23760
23339: LD_INT 28
23341: DOUBLE
23342: EQUAL
23343: IFTRUE 23347
23345: GO 23365
23347: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
23348: LD_ADDR_VAR 0 3
23352: PUSH
23353: LD_INT 13
23355: PUSH
23356: LD_INT 14
23358: PUSH
23359: EMPTY
23360: LIST
23361: LIST
23362: ST_TO_ADDR
23363: GO 23760
23365: LD_INT 29
23367: DOUBLE
23368: EQUAL
23369: IFTRUE 23373
23371: GO 23391
23373: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
23374: LD_ADDR_VAR 0 3
23378: PUSH
23379: LD_INT 13
23381: PUSH
23382: LD_INT 14
23384: PUSH
23385: EMPTY
23386: LIST
23387: LIST
23388: ST_TO_ADDR
23389: GO 23760
23391: LD_INT 31
23393: DOUBLE
23394: EQUAL
23395: IFTRUE 23399
23397: GO 23417
23399: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
23400: LD_ADDR_VAR 0 3
23404: PUSH
23405: LD_INT 13
23407: PUSH
23408: LD_INT 14
23410: PUSH
23411: EMPTY
23412: LIST
23413: LIST
23414: ST_TO_ADDR
23415: GO 23760
23417: LD_INT 26
23419: DOUBLE
23420: EQUAL
23421: IFTRUE 23425
23423: GO 23443
23425: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
23426: LD_ADDR_VAR 0 3
23430: PUSH
23431: LD_INT 13
23433: PUSH
23434: LD_INT 14
23436: PUSH
23437: EMPTY
23438: LIST
23439: LIST
23440: ST_TO_ADDR
23441: GO 23760
23443: LD_INT 42
23445: DOUBLE
23446: EQUAL
23447: IFTRUE 23451
23449: GO 23477
23451: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
23452: LD_ADDR_VAR 0 3
23456: PUSH
23457: LD_INT 21
23459: PUSH
23460: LD_INT 22
23462: PUSH
23463: LD_INT 23
23465: PUSH
23466: LD_INT 24
23468: PUSH
23469: EMPTY
23470: LIST
23471: LIST
23472: LIST
23473: LIST
23474: ST_TO_ADDR
23475: GO 23760
23477: LD_INT 43
23479: DOUBLE
23480: EQUAL
23481: IFTRUE 23485
23483: GO 23511
23485: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
23486: LD_ADDR_VAR 0 3
23490: PUSH
23491: LD_INT 21
23493: PUSH
23494: LD_INT 22
23496: PUSH
23497: LD_INT 23
23499: PUSH
23500: LD_INT 24
23502: PUSH
23503: EMPTY
23504: LIST
23505: LIST
23506: LIST
23507: LIST
23508: ST_TO_ADDR
23509: GO 23760
23511: LD_INT 44
23513: DOUBLE
23514: EQUAL
23515: IFTRUE 23519
23517: GO 23545
23519: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
23520: LD_ADDR_VAR 0 3
23524: PUSH
23525: LD_INT 21
23527: PUSH
23528: LD_INT 22
23530: PUSH
23531: LD_INT 23
23533: PUSH
23534: LD_INT 24
23536: PUSH
23537: EMPTY
23538: LIST
23539: LIST
23540: LIST
23541: LIST
23542: ST_TO_ADDR
23543: GO 23760
23545: LD_INT 45
23547: DOUBLE
23548: EQUAL
23549: IFTRUE 23553
23551: GO 23579
23553: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
23554: LD_ADDR_VAR 0 3
23558: PUSH
23559: LD_INT 21
23561: PUSH
23562: LD_INT 22
23564: PUSH
23565: LD_INT 23
23567: PUSH
23568: LD_INT 24
23570: PUSH
23571: EMPTY
23572: LIST
23573: LIST
23574: LIST
23575: LIST
23576: ST_TO_ADDR
23577: GO 23760
23579: LD_INT 49
23581: DOUBLE
23582: EQUAL
23583: IFTRUE 23587
23585: GO 23613
23587: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
23588: LD_ADDR_VAR 0 3
23592: PUSH
23593: LD_INT 21
23595: PUSH
23596: LD_INT 22
23598: PUSH
23599: LD_INT 23
23601: PUSH
23602: LD_INT 24
23604: PUSH
23605: EMPTY
23606: LIST
23607: LIST
23608: LIST
23609: LIST
23610: ST_TO_ADDR
23611: GO 23760
23613: LD_INT 51
23615: DOUBLE
23616: EQUAL
23617: IFTRUE 23621
23619: GO 23647
23621: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
23622: LD_ADDR_VAR 0 3
23626: PUSH
23627: LD_INT 21
23629: PUSH
23630: LD_INT 22
23632: PUSH
23633: LD_INT 23
23635: PUSH
23636: LD_INT 24
23638: PUSH
23639: EMPTY
23640: LIST
23641: LIST
23642: LIST
23643: LIST
23644: ST_TO_ADDR
23645: GO 23760
23647: LD_INT 52
23649: DOUBLE
23650: EQUAL
23651: IFTRUE 23655
23653: GO 23681
23655: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
23656: LD_ADDR_VAR 0 3
23660: PUSH
23661: LD_INT 21
23663: PUSH
23664: LD_INT 22
23666: PUSH
23667: LD_INT 23
23669: PUSH
23670: LD_INT 24
23672: PUSH
23673: EMPTY
23674: LIST
23675: LIST
23676: LIST
23677: LIST
23678: ST_TO_ADDR
23679: GO 23760
23681: LD_INT 53
23683: DOUBLE
23684: EQUAL
23685: IFTRUE 23689
23687: GO 23707
23689: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
23690: LD_ADDR_VAR 0 3
23694: PUSH
23695: LD_INT 23
23697: PUSH
23698: LD_INT 24
23700: PUSH
23701: EMPTY
23702: LIST
23703: LIST
23704: ST_TO_ADDR
23705: GO 23760
23707: LD_INT 46
23709: DOUBLE
23710: EQUAL
23711: IFTRUE 23715
23713: GO 23733
23715: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
23716: LD_ADDR_VAR 0 3
23720: PUSH
23721: LD_INT 23
23723: PUSH
23724: LD_INT 24
23726: PUSH
23727: EMPTY
23728: LIST
23729: LIST
23730: ST_TO_ADDR
23731: GO 23760
23733: LD_INT 47
23735: DOUBLE
23736: EQUAL
23737: IFTRUE 23741
23739: GO 23759
23741: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
23742: LD_ADDR_VAR 0 3
23746: PUSH
23747: LD_INT 23
23749: PUSH
23750: LD_INT 24
23752: PUSH
23753: EMPTY
23754: LIST
23755: LIST
23756: ST_TO_ADDR
23757: GO 23760
23759: POP
// result := ( chassis in result ) ;
23760: LD_ADDR_VAR 0 3
23764: PUSH
23765: LD_VAR 0 1
23769: PUSH
23770: LD_VAR 0 3
23774: IN
23775: ST_TO_ADDR
// end ;
23776: LD_VAR 0 3
23780: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
23781: LD_INT 0
23783: PPUSH
23784: PPUSH
23785: PPUSH
23786: PPUSH
23787: PPUSH
23788: PPUSH
23789: PPUSH
// result := array ;
23790: LD_ADDR_VAR 0 5
23794: PUSH
23795: LD_VAR 0 1
23799: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
23800: LD_VAR 0 1
23804: NOT
23805: PUSH
23806: LD_VAR 0 2
23810: NOT
23811: OR
23812: PUSH
23813: LD_VAR 0 3
23817: NOT
23818: OR
23819: PUSH
23820: LD_VAR 0 2
23824: PUSH
23825: LD_VAR 0 1
23829: GREATER
23830: OR
23831: PUSH
23832: LD_VAR 0 3
23836: PUSH
23837: LD_VAR 0 1
23841: GREATER
23842: OR
23843: IFFALSE 23847
// exit ;
23845: GO 24143
// if direction then
23847: LD_VAR 0 4
23851: IFFALSE 23915
// begin d := 1 ;
23853: LD_ADDR_VAR 0 9
23857: PUSH
23858: LD_INT 1
23860: ST_TO_ADDR
// if i_from > i_to then
23861: LD_VAR 0 2
23865: PUSH
23866: LD_VAR 0 3
23870: GREATER
23871: IFFALSE 23897
// length := ( array - i_from ) + i_to else
23873: LD_ADDR_VAR 0 11
23877: PUSH
23878: LD_VAR 0 1
23882: PUSH
23883: LD_VAR 0 2
23887: MINUS
23888: PUSH
23889: LD_VAR 0 3
23893: PLUS
23894: ST_TO_ADDR
23895: GO 23913
// length := i_to - i_from ;
23897: LD_ADDR_VAR 0 11
23901: PUSH
23902: LD_VAR 0 3
23906: PUSH
23907: LD_VAR 0 2
23911: MINUS
23912: ST_TO_ADDR
// end else
23913: GO 23976
// begin d := - 1 ;
23915: LD_ADDR_VAR 0 9
23919: PUSH
23920: LD_INT 1
23922: NEG
23923: ST_TO_ADDR
// if i_from > i_to then
23924: LD_VAR 0 2
23928: PUSH
23929: LD_VAR 0 3
23933: GREATER
23934: IFFALSE 23954
// length := i_from - i_to else
23936: LD_ADDR_VAR 0 11
23940: PUSH
23941: LD_VAR 0 2
23945: PUSH
23946: LD_VAR 0 3
23950: MINUS
23951: ST_TO_ADDR
23952: GO 23976
// length := ( array - i_to ) + i_from ;
23954: LD_ADDR_VAR 0 11
23958: PUSH
23959: LD_VAR 0 1
23963: PUSH
23964: LD_VAR 0 3
23968: MINUS
23969: PUSH
23970: LD_VAR 0 2
23974: PLUS
23975: ST_TO_ADDR
// end ; if not length then
23976: LD_VAR 0 11
23980: NOT
23981: IFFALSE 23985
// exit ;
23983: GO 24143
// tmp := array ;
23985: LD_ADDR_VAR 0 10
23989: PUSH
23990: LD_VAR 0 1
23994: ST_TO_ADDR
// for i = 1 to length do
23995: LD_ADDR_VAR 0 6
23999: PUSH
24000: DOUBLE
24001: LD_INT 1
24003: DEC
24004: ST_TO_ADDR
24005: LD_VAR 0 11
24009: PUSH
24010: FOR_TO
24011: IFFALSE 24131
// begin for j = 1 to array do
24013: LD_ADDR_VAR 0 7
24017: PUSH
24018: DOUBLE
24019: LD_INT 1
24021: DEC
24022: ST_TO_ADDR
24023: LD_VAR 0 1
24027: PUSH
24028: FOR_TO
24029: IFFALSE 24117
// begin k := j + d ;
24031: LD_ADDR_VAR 0 8
24035: PUSH
24036: LD_VAR 0 7
24040: PUSH
24041: LD_VAR 0 9
24045: PLUS
24046: ST_TO_ADDR
// if k > array then
24047: LD_VAR 0 8
24051: PUSH
24052: LD_VAR 0 1
24056: GREATER
24057: IFFALSE 24067
// k := 1 ;
24059: LD_ADDR_VAR 0 8
24063: PUSH
24064: LD_INT 1
24066: ST_TO_ADDR
// if not k then
24067: LD_VAR 0 8
24071: NOT
24072: IFFALSE 24084
// k := array ;
24074: LD_ADDR_VAR 0 8
24078: PUSH
24079: LD_VAR 0 1
24083: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
24084: LD_ADDR_VAR 0 10
24088: PUSH
24089: LD_VAR 0 10
24093: PPUSH
24094: LD_VAR 0 8
24098: PPUSH
24099: LD_VAR 0 1
24103: PUSH
24104: LD_VAR 0 7
24108: ARRAY
24109: PPUSH
24110: CALL_OW 1
24114: ST_TO_ADDR
// end ;
24115: GO 24028
24117: POP
24118: POP
// array := tmp ;
24119: LD_ADDR_VAR 0 1
24123: PUSH
24124: LD_VAR 0 10
24128: ST_TO_ADDR
// end ;
24129: GO 24010
24131: POP
24132: POP
// result := array ;
24133: LD_ADDR_VAR 0 5
24137: PUSH
24138: LD_VAR 0 1
24142: ST_TO_ADDR
// end ;
24143: LD_VAR 0 5
24147: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
24148: LD_INT 0
24150: PPUSH
24151: PPUSH
// result := 0 ;
24152: LD_ADDR_VAR 0 3
24156: PUSH
24157: LD_INT 0
24159: ST_TO_ADDR
// if not array or not value in array then
24160: LD_VAR 0 1
24164: NOT
24165: PUSH
24166: LD_VAR 0 2
24170: PUSH
24171: LD_VAR 0 1
24175: IN
24176: NOT
24177: OR
24178: IFFALSE 24182
// exit ;
24180: GO 24236
// for i = 1 to array do
24182: LD_ADDR_VAR 0 4
24186: PUSH
24187: DOUBLE
24188: LD_INT 1
24190: DEC
24191: ST_TO_ADDR
24192: LD_VAR 0 1
24196: PUSH
24197: FOR_TO
24198: IFFALSE 24234
// if value = array [ i ] then
24200: LD_VAR 0 2
24204: PUSH
24205: LD_VAR 0 1
24209: PUSH
24210: LD_VAR 0 4
24214: ARRAY
24215: EQUAL
24216: IFFALSE 24232
// begin result := i ;
24218: LD_ADDR_VAR 0 3
24222: PUSH
24223: LD_VAR 0 4
24227: ST_TO_ADDR
// exit ;
24228: POP
24229: POP
24230: GO 24236
// end ;
24232: GO 24197
24234: POP
24235: POP
// end ;
24236: LD_VAR 0 3
24240: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
24241: LD_INT 0
24243: PPUSH
// vc_chassis := chassis ;
24244: LD_ADDR_OWVAR 37
24248: PUSH
24249: LD_VAR 0 1
24253: ST_TO_ADDR
// vc_engine := engine ;
24254: LD_ADDR_OWVAR 39
24258: PUSH
24259: LD_VAR 0 2
24263: ST_TO_ADDR
// vc_control := control ;
24264: LD_ADDR_OWVAR 38
24268: PUSH
24269: LD_VAR 0 3
24273: ST_TO_ADDR
// vc_weapon := weapon ;
24274: LD_ADDR_OWVAR 40
24278: PUSH
24279: LD_VAR 0 4
24283: ST_TO_ADDR
// vc_fuel_battery := fuel ;
24284: LD_ADDR_OWVAR 41
24288: PUSH
24289: LD_VAR 0 5
24293: ST_TO_ADDR
// end ;
24294: LD_VAR 0 6
24298: RET
// export function WantPlant ( unit ) ; var task ; begin
24299: LD_INT 0
24301: PPUSH
24302: PPUSH
// result := false ;
24303: LD_ADDR_VAR 0 2
24307: PUSH
24308: LD_INT 0
24310: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
24311: LD_ADDR_VAR 0 3
24315: PUSH
24316: LD_VAR 0 1
24320: PPUSH
24321: CALL_OW 437
24325: ST_TO_ADDR
// if task then
24326: LD_VAR 0 3
24330: IFFALSE 24358
// if task [ 1 ] [ 1 ] = p then
24332: LD_VAR 0 3
24336: PUSH
24337: LD_INT 1
24339: ARRAY
24340: PUSH
24341: LD_INT 1
24343: ARRAY
24344: PUSH
24345: LD_STRING p
24347: EQUAL
24348: IFFALSE 24358
// result := true ;
24350: LD_ADDR_VAR 0 2
24354: PUSH
24355: LD_INT 1
24357: ST_TO_ADDR
// end ;
24358: LD_VAR 0 2
24362: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
24363: LD_INT 0
24365: PPUSH
24366: PPUSH
24367: PPUSH
24368: PPUSH
// if pos < 1 then
24369: LD_VAR 0 2
24373: PUSH
24374: LD_INT 1
24376: LESS
24377: IFFALSE 24381
// exit ;
24379: GO 24684
// if pos = 1 then
24381: LD_VAR 0 2
24385: PUSH
24386: LD_INT 1
24388: EQUAL
24389: IFFALSE 24422
// result := Replace ( arr , pos [ 1 ] , value ) else
24391: LD_ADDR_VAR 0 4
24395: PUSH
24396: LD_VAR 0 1
24400: PPUSH
24401: LD_VAR 0 2
24405: PUSH
24406: LD_INT 1
24408: ARRAY
24409: PPUSH
24410: LD_VAR 0 3
24414: PPUSH
24415: CALL_OW 1
24419: ST_TO_ADDR
24420: GO 24684
// begin tmp := arr ;
24422: LD_ADDR_VAR 0 6
24426: PUSH
24427: LD_VAR 0 1
24431: ST_TO_ADDR
// s_arr := [ tmp ] ;
24432: LD_ADDR_VAR 0 7
24436: PUSH
24437: LD_VAR 0 6
24441: PUSH
24442: EMPTY
24443: LIST
24444: ST_TO_ADDR
// for i = 1 to pos - 1 do
24445: LD_ADDR_VAR 0 5
24449: PUSH
24450: DOUBLE
24451: LD_INT 1
24453: DEC
24454: ST_TO_ADDR
24455: LD_VAR 0 2
24459: PUSH
24460: LD_INT 1
24462: MINUS
24463: PUSH
24464: FOR_TO
24465: IFFALSE 24510
// begin tmp := tmp [ pos [ i ] ] ;
24467: LD_ADDR_VAR 0 6
24471: PUSH
24472: LD_VAR 0 6
24476: PUSH
24477: LD_VAR 0 2
24481: PUSH
24482: LD_VAR 0 5
24486: ARRAY
24487: ARRAY
24488: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
24489: LD_ADDR_VAR 0 7
24493: PUSH
24494: LD_VAR 0 7
24498: PUSH
24499: LD_VAR 0 6
24503: PUSH
24504: EMPTY
24505: LIST
24506: ADD
24507: ST_TO_ADDR
// end ;
24508: GO 24464
24510: POP
24511: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
24512: LD_ADDR_VAR 0 6
24516: PUSH
24517: LD_VAR 0 6
24521: PPUSH
24522: LD_VAR 0 2
24526: PUSH
24527: LD_VAR 0 2
24531: ARRAY
24532: PPUSH
24533: LD_VAR 0 3
24537: PPUSH
24538: CALL_OW 1
24542: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
24543: LD_ADDR_VAR 0 7
24547: PUSH
24548: LD_VAR 0 7
24552: PPUSH
24553: LD_VAR 0 7
24557: PPUSH
24558: LD_VAR 0 6
24562: PPUSH
24563: CALL_OW 1
24567: ST_TO_ADDR
// for i = s_arr downto 2 do
24568: LD_ADDR_VAR 0 5
24572: PUSH
24573: DOUBLE
24574: LD_VAR 0 7
24578: INC
24579: ST_TO_ADDR
24580: LD_INT 2
24582: PUSH
24583: FOR_DOWNTO
24584: IFFALSE 24668
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
24586: LD_ADDR_VAR 0 6
24590: PUSH
24591: LD_VAR 0 7
24595: PUSH
24596: LD_VAR 0 5
24600: PUSH
24601: LD_INT 1
24603: MINUS
24604: ARRAY
24605: PPUSH
24606: LD_VAR 0 2
24610: PUSH
24611: LD_VAR 0 5
24615: PUSH
24616: LD_INT 1
24618: MINUS
24619: ARRAY
24620: PPUSH
24621: LD_VAR 0 7
24625: PUSH
24626: LD_VAR 0 5
24630: ARRAY
24631: PPUSH
24632: CALL_OW 1
24636: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
24637: LD_ADDR_VAR 0 7
24641: PUSH
24642: LD_VAR 0 7
24646: PPUSH
24647: LD_VAR 0 5
24651: PUSH
24652: LD_INT 1
24654: MINUS
24655: PPUSH
24656: LD_VAR 0 6
24660: PPUSH
24661: CALL_OW 1
24665: ST_TO_ADDR
// end ;
24666: GO 24583
24668: POP
24669: POP
// result := s_arr [ 1 ] ;
24670: LD_ADDR_VAR 0 4
24674: PUSH
24675: LD_VAR 0 7
24679: PUSH
24680: LD_INT 1
24682: ARRAY
24683: ST_TO_ADDR
// end ; end ;
24684: LD_VAR 0 4
24688: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
24689: LD_INT 0
24691: PPUSH
24692: PPUSH
// if not list then
24693: LD_VAR 0 1
24697: NOT
24698: IFFALSE 24702
// exit ;
24700: GO 24793
// i := list [ pos1 ] ;
24702: LD_ADDR_VAR 0 5
24706: PUSH
24707: LD_VAR 0 1
24711: PUSH
24712: LD_VAR 0 2
24716: ARRAY
24717: ST_TO_ADDR
// if not i then
24718: LD_VAR 0 5
24722: NOT
24723: IFFALSE 24727
// exit ;
24725: GO 24793
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
24727: LD_ADDR_VAR 0 1
24731: PUSH
24732: LD_VAR 0 1
24736: PPUSH
24737: LD_VAR 0 2
24741: PPUSH
24742: LD_VAR 0 1
24746: PUSH
24747: LD_VAR 0 3
24751: ARRAY
24752: PPUSH
24753: CALL_OW 1
24757: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
24758: LD_ADDR_VAR 0 1
24762: PUSH
24763: LD_VAR 0 1
24767: PPUSH
24768: LD_VAR 0 3
24772: PPUSH
24773: LD_VAR 0 5
24777: PPUSH
24778: CALL_OW 1
24782: ST_TO_ADDR
// result := list ;
24783: LD_ADDR_VAR 0 4
24787: PUSH
24788: LD_VAR 0 1
24792: ST_TO_ADDR
// end ;
24793: LD_VAR 0 4
24797: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
24798: LD_INT 0
24800: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
24801: LD_ADDR_VAR 0 5
24805: PUSH
24806: LD_VAR 0 1
24810: PPUSH
24811: CALL_OW 250
24815: PPUSH
24816: LD_VAR 0 1
24820: PPUSH
24821: CALL_OW 251
24825: PPUSH
24826: LD_VAR 0 2
24830: PPUSH
24831: LD_VAR 0 3
24835: PPUSH
24836: LD_VAR 0 4
24840: PPUSH
24841: CALL 24851 0 5
24845: ST_TO_ADDR
// end ;
24846: LD_VAR 0 5
24850: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
24851: LD_INT 0
24853: PPUSH
24854: PPUSH
24855: PPUSH
24856: PPUSH
// if not list then
24857: LD_VAR 0 3
24861: NOT
24862: IFFALSE 24866
// exit ;
24864: GO 25254
// result := [ ] ;
24866: LD_ADDR_VAR 0 6
24870: PUSH
24871: EMPTY
24872: ST_TO_ADDR
// for i in list do
24873: LD_ADDR_VAR 0 7
24877: PUSH
24878: LD_VAR 0 3
24882: PUSH
24883: FOR_IN
24884: IFFALSE 25086
// begin tmp := GetDistUnitXY ( i , x , y ) ;
24886: LD_ADDR_VAR 0 9
24890: PUSH
24891: LD_VAR 0 7
24895: PPUSH
24896: LD_VAR 0 1
24900: PPUSH
24901: LD_VAR 0 2
24905: PPUSH
24906: CALL_OW 297
24910: ST_TO_ADDR
// if not result then
24911: LD_VAR 0 6
24915: NOT
24916: IFFALSE 24942
// result := [ [ i , tmp ] ] else
24918: LD_ADDR_VAR 0 6
24922: PUSH
24923: LD_VAR 0 7
24927: PUSH
24928: LD_VAR 0 9
24932: PUSH
24933: EMPTY
24934: LIST
24935: LIST
24936: PUSH
24937: EMPTY
24938: LIST
24939: ST_TO_ADDR
24940: GO 25084
// begin if result [ result ] [ 2 ] < tmp then
24942: LD_VAR 0 6
24946: PUSH
24947: LD_VAR 0 6
24951: ARRAY
24952: PUSH
24953: LD_INT 2
24955: ARRAY
24956: PUSH
24957: LD_VAR 0 9
24961: LESS
24962: IFFALSE 25004
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
24964: LD_ADDR_VAR 0 6
24968: PUSH
24969: LD_VAR 0 6
24973: PPUSH
24974: LD_VAR 0 6
24978: PUSH
24979: LD_INT 1
24981: PLUS
24982: PPUSH
24983: LD_VAR 0 7
24987: PUSH
24988: LD_VAR 0 9
24992: PUSH
24993: EMPTY
24994: LIST
24995: LIST
24996: PPUSH
24997: CALL_OW 2
25001: ST_TO_ADDR
25002: GO 25084
// for j = 1 to result do
25004: LD_ADDR_VAR 0 8
25008: PUSH
25009: DOUBLE
25010: LD_INT 1
25012: DEC
25013: ST_TO_ADDR
25014: LD_VAR 0 6
25018: PUSH
25019: FOR_TO
25020: IFFALSE 25082
// begin if tmp < result [ j ] [ 2 ] then
25022: LD_VAR 0 9
25026: PUSH
25027: LD_VAR 0 6
25031: PUSH
25032: LD_VAR 0 8
25036: ARRAY
25037: PUSH
25038: LD_INT 2
25040: ARRAY
25041: LESS
25042: IFFALSE 25080
// begin result := Insert ( result , j , [ i , tmp ] ) ;
25044: LD_ADDR_VAR 0 6
25048: PUSH
25049: LD_VAR 0 6
25053: PPUSH
25054: LD_VAR 0 8
25058: PPUSH
25059: LD_VAR 0 7
25063: PUSH
25064: LD_VAR 0 9
25068: PUSH
25069: EMPTY
25070: LIST
25071: LIST
25072: PPUSH
25073: CALL_OW 2
25077: ST_TO_ADDR
// break ;
25078: GO 25082
// end ; end ;
25080: GO 25019
25082: POP
25083: POP
// end ; end ;
25084: GO 24883
25086: POP
25087: POP
// if result and not asc then
25088: LD_VAR 0 6
25092: PUSH
25093: LD_VAR 0 4
25097: NOT
25098: AND
25099: IFFALSE 25174
// begin tmp := result ;
25101: LD_ADDR_VAR 0 9
25105: PUSH
25106: LD_VAR 0 6
25110: ST_TO_ADDR
// for i = tmp downto 1 do
25111: LD_ADDR_VAR 0 7
25115: PUSH
25116: DOUBLE
25117: LD_VAR 0 9
25121: INC
25122: ST_TO_ADDR
25123: LD_INT 1
25125: PUSH
25126: FOR_DOWNTO
25127: IFFALSE 25172
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
25129: LD_ADDR_VAR 0 6
25133: PUSH
25134: LD_VAR 0 6
25138: PPUSH
25139: LD_VAR 0 9
25143: PUSH
25144: LD_VAR 0 7
25148: MINUS
25149: PUSH
25150: LD_INT 1
25152: PLUS
25153: PPUSH
25154: LD_VAR 0 9
25158: PUSH
25159: LD_VAR 0 7
25163: ARRAY
25164: PPUSH
25165: CALL_OW 1
25169: ST_TO_ADDR
25170: GO 25126
25172: POP
25173: POP
// end ; tmp := [ ] ;
25174: LD_ADDR_VAR 0 9
25178: PUSH
25179: EMPTY
25180: ST_TO_ADDR
// if mode then
25181: LD_VAR 0 5
25185: IFFALSE 25254
// begin for i = 1 to result do
25187: LD_ADDR_VAR 0 7
25191: PUSH
25192: DOUBLE
25193: LD_INT 1
25195: DEC
25196: ST_TO_ADDR
25197: LD_VAR 0 6
25201: PUSH
25202: FOR_TO
25203: IFFALSE 25242
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
25205: LD_ADDR_VAR 0 9
25209: PUSH
25210: LD_VAR 0 9
25214: PPUSH
25215: LD_VAR 0 7
25219: PPUSH
25220: LD_VAR 0 6
25224: PUSH
25225: LD_VAR 0 7
25229: ARRAY
25230: PUSH
25231: LD_INT 1
25233: ARRAY
25234: PPUSH
25235: CALL_OW 1
25239: ST_TO_ADDR
25240: GO 25202
25242: POP
25243: POP
// result := tmp ;
25244: LD_ADDR_VAR 0 6
25248: PUSH
25249: LD_VAR 0 9
25253: ST_TO_ADDR
// end ; end ;
25254: LD_VAR 0 6
25258: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
25259: LD_INT 0
25261: PPUSH
25262: PPUSH
25263: PPUSH
25264: PPUSH
25265: PPUSH
25266: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
25267: LD_ADDR_VAR 0 5
25271: PUSH
25272: LD_INT 0
25274: PUSH
25275: LD_INT 0
25277: PUSH
25278: LD_INT 0
25280: PUSH
25281: EMPTY
25282: PUSH
25283: EMPTY
25284: LIST
25285: LIST
25286: LIST
25287: LIST
25288: ST_TO_ADDR
// if not x or not y then
25289: LD_VAR 0 2
25293: NOT
25294: PUSH
25295: LD_VAR 0 3
25299: NOT
25300: OR
25301: IFFALSE 25305
// exit ;
25303: GO 26957
// if not range then
25305: LD_VAR 0 4
25309: NOT
25310: IFFALSE 25320
// range := 10 ;
25312: LD_ADDR_VAR 0 4
25316: PUSH
25317: LD_INT 10
25319: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
25320: LD_ADDR_VAR 0 8
25324: PUSH
25325: LD_INT 81
25327: PUSH
25328: LD_VAR 0 1
25332: PUSH
25333: EMPTY
25334: LIST
25335: LIST
25336: PUSH
25337: LD_INT 92
25339: PUSH
25340: LD_VAR 0 2
25344: PUSH
25345: LD_VAR 0 3
25349: PUSH
25350: LD_VAR 0 4
25354: PUSH
25355: EMPTY
25356: LIST
25357: LIST
25358: LIST
25359: LIST
25360: PUSH
25361: LD_INT 3
25363: PUSH
25364: LD_INT 21
25366: PUSH
25367: LD_INT 3
25369: PUSH
25370: EMPTY
25371: LIST
25372: LIST
25373: PUSH
25374: EMPTY
25375: LIST
25376: LIST
25377: PUSH
25378: EMPTY
25379: LIST
25380: LIST
25381: LIST
25382: PPUSH
25383: CALL_OW 69
25387: ST_TO_ADDR
// if not tmp then
25388: LD_VAR 0 8
25392: NOT
25393: IFFALSE 25397
// exit ;
25395: GO 26957
// for i in tmp do
25397: LD_ADDR_VAR 0 6
25401: PUSH
25402: LD_VAR 0 8
25406: PUSH
25407: FOR_IN
25408: IFFALSE 26932
// begin points := [ 0 , 0 , 0 ] ;
25410: LD_ADDR_VAR 0 9
25414: PUSH
25415: LD_INT 0
25417: PUSH
25418: LD_INT 0
25420: PUSH
25421: LD_INT 0
25423: PUSH
25424: EMPTY
25425: LIST
25426: LIST
25427: LIST
25428: ST_TO_ADDR
// bpoints := 1 ;
25429: LD_ADDR_VAR 0 10
25433: PUSH
25434: LD_INT 1
25436: ST_TO_ADDR
// case GetType ( i ) of unit_human :
25437: LD_VAR 0 6
25441: PPUSH
25442: CALL_OW 247
25446: PUSH
25447: LD_INT 1
25449: DOUBLE
25450: EQUAL
25451: IFTRUE 25455
25453: GO 26033
25455: POP
// begin if GetClass ( i ) = 1 then
25456: LD_VAR 0 6
25460: PPUSH
25461: CALL_OW 257
25465: PUSH
25466: LD_INT 1
25468: EQUAL
25469: IFFALSE 25490
// points := [ 10 , 5 , 3 ] ;
25471: LD_ADDR_VAR 0 9
25475: PUSH
25476: LD_INT 10
25478: PUSH
25479: LD_INT 5
25481: PUSH
25482: LD_INT 3
25484: PUSH
25485: EMPTY
25486: LIST
25487: LIST
25488: LIST
25489: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
25490: LD_VAR 0 6
25494: PPUSH
25495: CALL_OW 257
25499: PUSH
25500: LD_INT 2
25502: PUSH
25503: LD_INT 3
25505: PUSH
25506: LD_INT 4
25508: PUSH
25509: EMPTY
25510: LIST
25511: LIST
25512: LIST
25513: IN
25514: IFFALSE 25535
// points := [ 3 , 2 , 1 ] ;
25516: LD_ADDR_VAR 0 9
25520: PUSH
25521: LD_INT 3
25523: PUSH
25524: LD_INT 2
25526: PUSH
25527: LD_INT 1
25529: PUSH
25530: EMPTY
25531: LIST
25532: LIST
25533: LIST
25534: ST_TO_ADDR
// if GetClass ( i ) = 5 then
25535: LD_VAR 0 6
25539: PPUSH
25540: CALL_OW 257
25544: PUSH
25545: LD_INT 5
25547: EQUAL
25548: IFFALSE 25569
// points := [ 130 , 5 , 2 ] ;
25550: LD_ADDR_VAR 0 9
25554: PUSH
25555: LD_INT 130
25557: PUSH
25558: LD_INT 5
25560: PUSH
25561: LD_INT 2
25563: PUSH
25564: EMPTY
25565: LIST
25566: LIST
25567: LIST
25568: ST_TO_ADDR
// if GetClass ( i ) = 8 then
25569: LD_VAR 0 6
25573: PPUSH
25574: CALL_OW 257
25578: PUSH
25579: LD_INT 8
25581: EQUAL
25582: IFFALSE 25603
// points := [ 35 , 35 , 30 ] ;
25584: LD_ADDR_VAR 0 9
25588: PUSH
25589: LD_INT 35
25591: PUSH
25592: LD_INT 35
25594: PUSH
25595: LD_INT 30
25597: PUSH
25598: EMPTY
25599: LIST
25600: LIST
25601: LIST
25602: ST_TO_ADDR
// if GetClass ( i ) = 9 then
25603: LD_VAR 0 6
25607: PPUSH
25608: CALL_OW 257
25612: PUSH
25613: LD_INT 9
25615: EQUAL
25616: IFFALSE 25637
// points := [ 20 , 55 , 40 ] ;
25618: LD_ADDR_VAR 0 9
25622: PUSH
25623: LD_INT 20
25625: PUSH
25626: LD_INT 55
25628: PUSH
25629: LD_INT 40
25631: PUSH
25632: EMPTY
25633: LIST
25634: LIST
25635: LIST
25636: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
25637: LD_VAR 0 6
25641: PPUSH
25642: CALL_OW 257
25646: PUSH
25647: LD_INT 12
25649: PUSH
25650: LD_INT 16
25652: PUSH
25653: EMPTY
25654: LIST
25655: LIST
25656: IN
25657: IFFALSE 25678
// points := [ 5 , 3 , 2 ] ;
25659: LD_ADDR_VAR 0 9
25663: PUSH
25664: LD_INT 5
25666: PUSH
25667: LD_INT 3
25669: PUSH
25670: LD_INT 2
25672: PUSH
25673: EMPTY
25674: LIST
25675: LIST
25676: LIST
25677: ST_TO_ADDR
// if GetClass ( i ) = 17 then
25678: LD_VAR 0 6
25682: PPUSH
25683: CALL_OW 257
25687: PUSH
25688: LD_INT 17
25690: EQUAL
25691: IFFALSE 25712
// points := [ 100 , 50 , 75 ] ;
25693: LD_ADDR_VAR 0 9
25697: PUSH
25698: LD_INT 100
25700: PUSH
25701: LD_INT 50
25703: PUSH
25704: LD_INT 75
25706: PUSH
25707: EMPTY
25708: LIST
25709: LIST
25710: LIST
25711: ST_TO_ADDR
// if GetClass ( i ) = 15 then
25712: LD_VAR 0 6
25716: PPUSH
25717: CALL_OW 257
25721: PUSH
25722: LD_INT 15
25724: EQUAL
25725: IFFALSE 25746
// points := [ 10 , 5 , 3 ] ;
25727: LD_ADDR_VAR 0 9
25731: PUSH
25732: LD_INT 10
25734: PUSH
25735: LD_INT 5
25737: PUSH
25738: LD_INT 3
25740: PUSH
25741: EMPTY
25742: LIST
25743: LIST
25744: LIST
25745: ST_TO_ADDR
// if GetClass ( i ) = 14 then
25746: LD_VAR 0 6
25750: PPUSH
25751: CALL_OW 257
25755: PUSH
25756: LD_INT 14
25758: EQUAL
25759: IFFALSE 25780
// points := [ 10 , 0 , 0 ] ;
25761: LD_ADDR_VAR 0 9
25765: PUSH
25766: LD_INT 10
25768: PUSH
25769: LD_INT 0
25771: PUSH
25772: LD_INT 0
25774: PUSH
25775: EMPTY
25776: LIST
25777: LIST
25778: LIST
25779: ST_TO_ADDR
// if GetClass ( i ) = 11 then
25780: LD_VAR 0 6
25784: PPUSH
25785: CALL_OW 257
25789: PUSH
25790: LD_INT 11
25792: EQUAL
25793: IFFALSE 25814
// points := [ 30 , 10 , 5 ] ;
25795: LD_ADDR_VAR 0 9
25799: PUSH
25800: LD_INT 30
25802: PUSH
25803: LD_INT 10
25805: PUSH
25806: LD_INT 5
25808: PUSH
25809: EMPTY
25810: LIST
25811: LIST
25812: LIST
25813: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
25814: LD_VAR 0 1
25818: PPUSH
25819: LD_INT 5
25821: PPUSH
25822: CALL_OW 321
25826: PUSH
25827: LD_INT 2
25829: EQUAL
25830: IFFALSE 25847
// bpoints := bpoints * 1.8 ;
25832: LD_ADDR_VAR 0 10
25836: PUSH
25837: LD_VAR 0 10
25841: PUSH
25842: LD_REAL  1.80000000000000E+0000
25845: MUL
25846: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
25847: LD_VAR 0 6
25851: PPUSH
25852: CALL_OW 257
25856: PUSH
25857: LD_INT 1
25859: PUSH
25860: LD_INT 2
25862: PUSH
25863: LD_INT 3
25865: PUSH
25866: LD_INT 4
25868: PUSH
25869: EMPTY
25870: LIST
25871: LIST
25872: LIST
25873: LIST
25874: IN
25875: PUSH
25876: LD_VAR 0 1
25880: PPUSH
25881: LD_INT 51
25883: PPUSH
25884: CALL_OW 321
25888: PUSH
25889: LD_INT 2
25891: EQUAL
25892: AND
25893: IFFALSE 25910
// bpoints := bpoints * 1.2 ;
25895: LD_ADDR_VAR 0 10
25899: PUSH
25900: LD_VAR 0 10
25904: PUSH
25905: LD_REAL  1.20000000000000E+0000
25908: MUL
25909: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
25910: LD_VAR 0 6
25914: PPUSH
25915: CALL_OW 257
25919: PUSH
25920: LD_INT 5
25922: PUSH
25923: LD_INT 7
25925: PUSH
25926: LD_INT 9
25928: PUSH
25929: EMPTY
25930: LIST
25931: LIST
25932: LIST
25933: IN
25934: PUSH
25935: LD_VAR 0 1
25939: PPUSH
25940: LD_INT 52
25942: PPUSH
25943: CALL_OW 321
25947: PUSH
25948: LD_INT 2
25950: EQUAL
25951: AND
25952: IFFALSE 25969
// bpoints := bpoints * 1.5 ;
25954: LD_ADDR_VAR 0 10
25958: PUSH
25959: LD_VAR 0 10
25963: PUSH
25964: LD_REAL  1.50000000000000E+0000
25967: MUL
25968: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
25969: LD_VAR 0 1
25973: PPUSH
25974: LD_INT 66
25976: PPUSH
25977: CALL_OW 321
25981: PUSH
25982: LD_INT 2
25984: EQUAL
25985: IFFALSE 26002
// bpoints := bpoints * 1.1 ;
25987: LD_ADDR_VAR 0 10
25991: PUSH
25992: LD_VAR 0 10
25996: PUSH
25997: LD_REAL  1.10000000000000E+0000
26000: MUL
26001: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
26002: LD_ADDR_VAR 0 10
26006: PUSH
26007: LD_VAR 0 10
26011: PUSH
26012: LD_VAR 0 6
26016: PPUSH
26017: LD_INT 1
26019: PPUSH
26020: CALL_OW 259
26024: PUSH
26025: LD_REAL  1.15000000000000E+0000
26028: MUL
26029: MUL
26030: ST_TO_ADDR
// end ; unit_vehicle :
26031: GO 26861
26033: LD_INT 2
26035: DOUBLE
26036: EQUAL
26037: IFTRUE 26041
26039: GO 26849
26041: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
26042: LD_VAR 0 6
26046: PPUSH
26047: CALL_OW 264
26051: PUSH
26052: LD_INT 2
26054: PUSH
26055: LD_INT 42
26057: PUSH
26058: LD_INT 24
26060: PUSH
26061: EMPTY
26062: LIST
26063: LIST
26064: LIST
26065: IN
26066: IFFALSE 26087
// points := [ 25 , 5 , 3 ] ;
26068: LD_ADDR_VAR 0 9
26072: PUSH
26073: LD_INT 25
26075: PUSH
26076: LD_INT 5
26078: PUSH
26079: LD_INT 3
26081: PUSH
26082: EMPTY
26083: LIST
26084: LIST
26085: LIST
26086: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
26087: LD_VAR 0 6
26091: PPUSH
26092: CALL_OW 264
26096: PUSH
26097: LD_INT 4
26099: PUSH
26100: LD_INT 43
26102: PUSH
26103: LD_INT 25
26105: PUSH
26106: EMPTY
26107: LIST
26108: LIST
26109: LIST
26110: IN
26111: IFFALSE 26132
// points := [ 40 , 15 , 5 ] ;
26113: LD_ADDR_VAR 0 9
26117: PUSH
26118: LD_INT 40
26120: PUSH
26121: LD_INT 15
26123: PUSH
26124: LD_INT 5
26126: PUSH
26127: EMPTY
26128: LIST
26129: LIST
26130: LIST
26131: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
26132: LD_VAR 0 6
26136: PPUSH
26137: CALL_OW 264
26141: PUSH
26142: LD_INT 3
26144: PUSH
26145: LD_INT 23
26147: PUSH
26148: EMPTY
26149: LIST
26150: LIST
26151: IN
26152: IFFALSE 26173
// points := [ 7 , 25 , 8 ] ;
26154: LD_ADDR_VAR 0 9
26158: PUSH
26159: LD_INT 7
26161: PUSH
26162: LD_INT 25
26164: PUSH
26165: LD_INT 8
26167: PUSH
26168: EMPTY
26169: LIST
26170: LIST
26171: LIST
26172: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
26173: LD_VAR 0 6
26177: PPUSH
26178: CALL_OW 264
26182: PUSH
26183: LD_INT 5
26185: PUSH
26186: LD_INT 27
26188: PUSH
26189: LD_INT 44
26191: PUSH
26192: EMPTY
26193: LIST
26194: LIST
26195: LIST
26196: IN
26197: IFFALSE 26218
// points := [ 14 , 50 , 16 ] ;
26199: LD_ADDR_VAR 0 9
26203: PUSH
26204: LD_INT 14
26206: PUSH
26207: LD_INT 50
26209: PUSH
26210: LD_INT 16
26212: PUSH
26213: EMPTY
26214: LIST
26215: LIST
26216: LIST
26217: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
26218: LD_VAR 0 6
26222: PPUSH
26223: CALL_OW 264
26227: PUSH
26228: LD_INT 6
26230: PUSH
26231: LD_INT 46
26233: PUSH
26234: EMPTY
26235: LIST
26236: LIST
26237: IN
26238: IFFALSE 26259
// points := [ 32 , 120 , 70 ] ;
26240: LD_ADDR_VAR 0 9
26244: PUSH
26245: LD_INT 32
26247: PUSH
26248: LD_INT 120
26250: PUSH
26251: LD_INT 70
26253: PUSH
26254: EMPTY
26255: LIST
26256: LIST
26257: LIST
26258: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher , ar_mortar ] then
26259: LD_VAR 0 6
26263: PPUSH
26264: CALL_OW 264
26268: PUSH
26269: LD_INT 7
26271: PUSH
26272: LD_INT 28
26274: PUSH
26275: LD_INT 45
26277: PUSH
26278: LD_EXP 163
26282: PUSH
26283: EMPTY
26284: LIST
26285: LIST
26286: LIST
26287: LIST
26288: IN
26289: IFFALSE 26310
// points := [ 35 , 20 , 45 ] ;
26291: LD_ADDR_VAR 0 9
26295: PUSH
26296: LD_INT 35
26298: PUSH
26299: LD_INT 20
26301: PUSH
26302: LD_INT 45
26304: PUSH
26305: EMPTY
26306: LIST
26307: LIST
26308: LIST
26309: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
26310: LD_VAR 0 6
26314: PPUSH
26315: CALL_OW 264
26319: PUSH
26320: LD_INT 47
26322: PUSH
26323: EMPTY
26324: LIST
26325: IN
26326: IFFALSE 26347
// points := [ 67 , 45 , 75 ] ;
26328: LD_ADDR_VAR 0 9
26332: PUSH
26333: LD_INT 67
26335: PUSH
26336: LD_INT 45
26338: PUSH
26339: LD_INT 75
26341: PUSH
26342: EMPTY
26343: LIST
26344: LIST
26345: LIST
26346: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
26347: LD_VAR 0 6
26351: PPUSH
26352: CALL_OW 264
26356: PUSH
26357: LD_INT 26
26359: PUSH
26360: EMPTY
26361: LIST
26362: IN
26363: IFFALSE 26384
// points := [ 120 , 30 , 80 ] ;
26365: LD_ADDR_VAR 0 9
26369: PUSH
26370: LD_INT 120
26372: PUSH
26373: LD_INT 30
26375: PUSH
26376: LD_INT 80
26378: PUSH
26379: EMPTY
26380: LIST
26381: LIST
26382: LIST
26383: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
26384: LD_VAR 0 6
26388: PPUSH
26389: CALL_OW 264
26393: PUSH
26394: LD_INT 22
26396: PUSH
26397: EMPTY
26398: LIST
26399: IN
26400: IFFALSE 26421
// points := [ 40 , 1 , 1 ] ;
26402: LD_ADDR_VAR 0 9
26406: PUSH
26407: LD_INT 40
26409: PUSH
26410: LD_INT 1
26412: PUSH
26413: LD_INT 1
26415: PUSH
26416: EMPTY
26417: LIST
26418: LIST
26419: LIST
26420: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
26421: LD_VAR 0 6
26425: PPUSH
26426: CALL_OW 264
26430: PUSH
26431: LD_INT 29
26433: PUSH
26434: EMPTY
26435: LIST
26436: IN
26437: IFFALSE 26458
// points := [ 70 , 200 , 400 ] ;
26439: LD_ADDR_VAR 0 9
26443: PUSH
26444: LD_INT 70
26446: PUSH
26447: LD_INT 200
26449: PUSH
26450: LD_INT 400
26452: PUSH
26453: EMPTY
26454: LIST
26455: LIST
26456: LIST
26457: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
26458: LD_VAR 0 6
26462: PPUSH
26463: CALL_OW 264
26467: PUSH
26468: LD_INT 14
26470: PUSH
26471: LD_INT 53
26473: PUSH
26474: EMPTY
26475: LIST
26476: LIST
26477: IN
26478: IFFALSE 26499
// points := [ 40 , 10 , 20 ] ;
26480: LD_ADDR_VAR 0 9
26484: PUSH
26485: LD_INT 40
26487: PUSH
26488: LD_INT 10
26490: PUSH
26491: LD_INT 20
26493: PUSH
26494: EMPTY
26495: LIST
26496: LIST
26497: LIST
26498: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
26499: LD_VAR 0 6
26503: PPUSH
26504: CALL_OW 264
26508: PUSH
26509: LD_INT 9
26511: PUSH
26512: EMPTY
26513: LIST
26514: IN
26515: IFFALSE 26536
// points := [ 5 , 70 , 20 ] ;
26517: LD_ADDR_VAR 0 9
26521: PUSH
26522: LD_INT 5
26524: PUSH
26525: LD_INT 70
26527: PUSH
26528: LD_INT 20
26530: PUSH
26531: EMPTY
26532: LIST
26533: LIST
26534: LIST
26535: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
26536: LD_VAR 0 6
26540: PPUSH
26541: CALL_OW 264
26545: PUSH
26546: LD_INT 10
26548: PUSH
26549: EMPTY
26550: LIST
26551: IN
26552: IFFALSE 26573
// points := [ 35 , 110 , 70 ] ;
26554: LD_ADDR_VAR 0 9
26558: PUSH
26559: LD_INT 35
26561: PUSH
26562: LD_INT 110
26564: PUSH
26565: LD_INT 70
26567: PUSH
26568: EMPTY
26569: LIST
26570: LIST
26571: LIST
26572: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
26573: LD_VAR 0 6
26577: PPUSH
26578: CALL_OW 265
26582: PUSH
26583: LD_INT 25
26585: EQUAL
26586: IFFALSE 26607
// points := [ 80 , 65 , 100 ] ;
26588: LD_ADDR_VAR 0 9
26592: PUSH
26593: LD_INT 80
26595: PUSH
26596: LD_INT 65
26598: PUSH
26599: LD_INT 100
26601: PUSH
26602: EMPTY
26603: LIST
26604: LIST
26605: LIST
26606: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
26607: LD_VAR 0 6
26611: PPUSH
26612: CALL_OW 263
26616: PUSH
26617: LD_INT 1
26619: EQUAL
26620: IFFALSE 26655
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
26622: LD_ADDR_VAR 0 10
26626: PUSH
26627: LD_VAR 0 10
26631: PUSH
26632: LD_VAR 0 6
26636: PPUSH
26637: CALL_OW 311
26641: PPUSH
26642: LD_INT 3
26644: PPUSH
26645: CALL_OW 259
26649: PUSH
26650: LD_INT 4
26652: MUL
26653: MUL
26654: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
26655: LD_VAR 0 6
26659: PPUSH
26660: CALL_OW 263
26664: PUSH
26665: LD_INT 2
26667: EQUAL
26668: IFFALSE 26719
// begin j := IsControledBy ( i ) ;
26670: LD_ADDR_VAR 0 7
26674: PUSH
26675: LD_VAR 0 6
26679: PPUSH
26680: CALL_OW 312
26684: ST_TO_ADDR
// if j then
26685: LD_VAR 0 7
26689: IFFALSE 26719
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
26691: LD_ADDR_VAR 0 10
26695: PUSH
26696: LD_VAR 0 10
26700: PUSH
26701: LD_VAR 0 7
26705: PPUSH
26706: LD_INT 3
26708: PPUSH
26709: CALL_OW 259
26713: PUSH
26714: LD_INT 3
26716: MUL
26717: MUL
26718: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
26719: LD_VAR 0 6
26723: PPUSH
26724: CALL_OW 264
26728: PUSH
26729: LD_INT 5
26731: PUSH
26732: LD_INT 6
26734: PUSH
26735: LD_INT 46
26737: PUSH
26738: LD_INT 44
26740: PUSH
26741: LD_INT 47
26743: PUSH
26744: LD_INT 45
26746: PUSH
26747: LD_INT 28
26749: PUSH
26750: LD_INT 7
26752: PUSH
26753: LD_INT 27
26755: PUSH
26756: LD_INT 29
26758: PUSH
26759: EMPTY
26760: LIST
26761: LIST
26762: LIST
26763: LIST
26764: LIST
26765: LIST
26766: LIST
26767: LIST
26768: LIST
26769: LIST
26770: IN
26771: PUSH
26772: LD_VAR 0 1
26776: PPUSH
26777: LD_INT 52
26779: PPUSH
26780: CALL_OW 321
26784: PUSH
26785: LD_INT 2
26787: EQUAL
26788: AND
26789: IFFALSE 26806
// bpoints := bpoints * 1.2 ;
26791: LD_ADDR_VAR 0 10
26795: PUSH
26796: LD_VAR 0 10
26800: PUSH
26801: LD_REAL  1.20000000000000E+0000
26804: MUL
26805: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
26806: LD_VAR 0 6
26810: PPUSH
26811: CALL_OW 264
26815: PUSH
26816: LD_INT 6
26818: PUSH
26819: LD_INT 46
26821: PUSH
26822: LD_INT 47
26824: PUSH
26825: EMPTY
26826: LIST
26827: LIST
26828: LIST
26829: IN
26830: IFFALSE 26847
// bpoints := bpoints * 1.2 ;
26832: LD_ADDR_VAR 0 10
26836: PUSH
26837: LD_VAR 0 10
26841: PUSH
26842: LD_REAL  1.20000000000000E+0000
26845: MUL
26846: ST_TO_ADDR
// end ; unit_building :
26847: GO 26861
26849: LD_INT 3
26851: DOUBLE
26852: EQUAL
26853: IFTRUE 26857
26855: GO 26860
26857: POP
// ; end ;
26858: GO 26861
26860: POP
// for j = 1 to 3 do
26861: LD_ADDR_VAR 0 7
26865: PUSH
26866: DOUBLE
26867: LD_INT 1
26869: DEC
26870: ST_TO_ADDR
26871: LD_INT 3
26873: PUSH
26874: FOR_TO
26875: IFFALSE 26928
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
26877: LD_ADDR_VAR 0 5
26881: PUSH
26882: LD_VAR 0 5
26886: PPUSH
26887: LD_VAR 0 7
26891: PPUSH
26892: LD_VAR 0 5
26896: PUSH
26897: LD_VAR 0 7
26901: ARRAY
26902: PUSH
26903: LD_VAR 0 9
26907: PUSH
26908: LD_VAR 0 7
26912: ARRAY
26913: PUSH
26914: LD_VAR 0 10
26918: MUL
26919: PLUS
26920: PPUSH
26921: CALL_OW 1
26925: ST_TO_ADDR
26926: GO 26874
26928: POP
26929: POP
// end ;
26930: GO 25407
26932: POP
26933: POP
// result := Replace ( result , 4 , tmp ) ;
26934: LD_ADDR_VAR 0 5
26938: PUSH
26939: LD_VAR 0 5
26943: PPUSH
26944: LD_INT 4
26946: PPUSH
26947: LD_VAR 0 8
26951: PPUSH
26952: CALL_OW 1
26956: ST_TO_ADDR
// end ;
26957: LD_VAR 0 5
26961: RET
// export function DangerAtRange ( unit , range ) ; begin
26962: LD_INT 0
26964: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
26965: LD_ADDR_VAR 0 3
26969: PUSH
26970: LD_VAR 0 1
26974: PPUSH
26975: CALL_OW 255
26979: PPUSH
26980: LD_VAR 0 1
26984: PPUSH
26985: CALL_OW 250
26989: PPUSH
26990: LD_VAR 0 1
26994: PPUSH
26995: CALL_OW 251
26999: PPUSH
27000: LD_VAR 0 2
27004: PPUSH
27005: CALL 25259 0 4
27009: ST_TO_ADDR
// end ;
27010: LD_VAR 0 3
27014: RET
// export function DangerInArea ( side , area ) ; begin
27015: LD_INT 0
27017: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
27018: LD_ADDR_VAR 0 3
27022: PUSH
27023: LD_VAR 0 2
27027: PPUSH
27028: LD_INT 81
27030: PUSH
27031: LD_VAR 0 1
27035: PUSH
27036: EMPTY
27037: LIST
27038: LIST
27039: PPUSH
27040: CALL_OW 70
27044: ST_TO_ADDR
// end ;
27045: LD_VAR 0 3
27049: RET
// export function IsExtension ( b ) ; begin
27050: LD_INT 0
27052: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
27053: LD_ADDR_VAR 0 2
27057: PUSH
27058: LD_VAR 0 1
27062: PUSH
27063: LD_INT 23
27065: PUSH
27066: LD_INT 20
27068: PUSH
27069: LD_INT 22
27071: PUSH
27072: LD_INT 17
27074: PUSH
27075: LD_INT 24
27077: PUSH
27078: LD_INT 21
27080: PUSH
27081: LD_INT 19
27083: PUSH
27084: LD_INT 16
27086: PUSH
27087: LD_INT 25
27089: PUSH
27090: LD_INT 18
27092: PUSH
27093: EMPTY
27094: LIST
27095: LIST
27096: LIST
27097: LIST
27098: LIST
27099: LIST
27100: LIST
27101: LIST
27102: LIST
27103: LIST
27104: IN
27105: ST_TO_ADDR
// end ;
27106: LD_VAR 0 2
27110: RET
// export function GetBaseBuildings ( base , area , checkLink ) ; var tmp , i ; begin
27111: LD_INT 0
27113: PPUSH
27114: PPUSH
27115: PPUSH
// result := [ ] ;
27116: LD_ADDR_VAR 0 4
27120: PUSH
27121: EMPTY
27122: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
27123: LD_ADDR_VAR 0 5
27127: PUSH
27128: LD_VAR 0 2
27132: PPUSH
27133: LD_INT 21
27135: PUSH
27136: LD_INT 3
27138: PUSH
27139: EMPTY
27140: LIST
27141: LIST
27142: PPUSH
27143: CALL_OW 70
27147: ST_TO_ADDR
// if not tmp then
27148: LD_VAR 0 5
27152: NOT
27153: IFFALSE 27157
// exit ;
27155: GO 27221
// if checkLink then
27157: LD_VAR 0 3
27161: IFFALSE 27211
// begin for i in tmp do
27163: LD_ADDR_VAR 0 6
27167: PUSH
27168: LD_VAR 0 5
27172: PUSH
27173: FOR_IN
27174: IFFALSE 27209
// if GetBase ( i ) <> base then
27176: LD_VAR 0 6
27180: PPUSH
27181: CALL_OW 274
27185: PUSH
27186: LD_VAR 0 1
27190: NONEQUAL
27191: IFFALSE 27207
// ComLinkToBase ( base , i ) ;
27193: LD_VAR 0 1
27197: PPUSH
27198: LD_VAR 0 6
27202: PPUSH
27203: CALL_OW 169
27207: GO 27173
27209: POP
27210: POP
// end ; result := tmp ;
27211: LD_ADDR_VAR 0 4
27215: PUSH
27216: LD_VAR 0 5
27220: ST_TO_ADDR
// end ;
27221: LD_VAR 0 4
27225: RET
// export function ComComplete ( units , b ) ; var i ; begin
27226: LD_INT 0
27228: PPUSH
27229: PPUSH
// if not units then
27230: LD_VAR 0 1
27234: NOT
27235: IFFALSE 27239
// exit ;
27237: GO 27329
// for i in units do
27239: LD_ADDR_VAR 0 4
27243: PUSH
27244: LD_VAR 0 1
27248: PUSH
27249: FOR_IN
27250: IFFALSE 27327
// if BuildingStatus ( b ) = bs_build then
27252: LD_VAR 0 2
27256: PPUSH
27257: CALL_OW 461
27261: PUSH
27262: LD_INT 1
27264: EQUAL
27265: IFFALSE 27325
// SetTaskList ( i , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
27267: LD_VAR 0 4
27271: PPUSH
27272: LD_STRING h
27274: PUSH
27275: LD_VAR 0 2
27279: PPUSH
27280: CALL_OW 250
27284: PUSH
27285: LD_VAR 0 2
27289: PPUSH
27290: CALL_OW 251
27294: PUSH
27295: LD_VAR 0 2
27299: PUSH
27300: LD_INT 0
27302: PUSH
27303: LD_INT 0
27305: PUSH
27306: LD_INT 0
27308: PUSH
27309: EMPTY
27310: LIST
27311: LIST
27312: LIST
27313: LIST
27314: LIST
27315: LIST
27316: LIST
27317: PUSH
27318: EMPTY
27319: LIST
27320: PPUSH
27321: CALL_OW 446
27325: GO 27249
27327: POP
27328: POP
// end ;
27329: LD_VAR 0 3
27333: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
27334: LD_INT 0
27336: PPUSH
27337: PPUSH
27338: PPUSH
27339: PPUSH
27340: PPUSH
27341: PPUSH
// if not vehicle or GetControl ( vehicle ) <> control_remote then
27342: LD_VAR 0 1
27346: NOT
27347: PUSH
27348: LD_VAR 0 1
27352: PPUSH
27353: CALL_OW 263
27357: PUSH
27358: LD_INT 2
27360: NONEQUAL
27361: OR
27362: IFFALSE 27366
// exit ;
27364: GO 27682
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
27366: LD_ADDR_VAR 0 6
27370: PUSH
27371: LD_INT 22
27373: PUSH
27374: LD_VAR 0 1
27378: PPUSH
27379: CALL_OW 255
27383: PUSH
27384: EMPTY
27385: LIST
27386: LIST
27387: PUSH
27388: LD_INT 2
27390: PUSH
27391: LD_INT 30
27393: PUSH
27394: LD_INT 36
27396: PUSH
27397: EMPTY
27398: LIST
27399: LIST
27400: PUSH
27401: LD_INT 34
27403: PUSH
27404: LD_INT 31
27406: PUSH
27407: EMPTY
27408: LIST
27409: LIST
27410: PUSH
27411: EMPTY
27412: LIST
27413: LIST
27414: LIST
27415: PUSH
27416: EMPTY
27417: LIST
27418: LIST
27419: PPUSH
27420: CALL_OW 69
27424: ST_TO_ADDR
// if not tmp then
27425: LD_VAR 0 6
27429: NOT
27430: IFFALSE 27434
// exit ;
27432: GO 27682
// result := [ ] ;
27434: LD_ADDR_VAR 0 2
27438: PUSH
27439: EMPTY
27440: ST_TO_ADDR
// for i in tmp do
27441: LD_ADDR_VAR 0 3
27445: PUSH
27446: LD_VAR 0 6
27450: PUSH
27451: FOR_IN
27452: IFFALSE 27523
// begin t := UnitsInside ( i ) ;
27454: LD_ADDR_VAR 0 4
27458: PUSH
27459: LD_VAR 0 3
27463: PPUSH
27464: CALL_OW 313
27468: ST_TO_ADDR
// if t then
27469: LD_VAR 0 4
27473: IFFALSE 27521
// for j in t do
27475: LD_ADDR_VAR 0 7
27479: PUSH
27480: LD_VAR 0 4
27484: PUSH
27485: FOR_IN
27486: IFFALSE 27519
// result := Replace ( result , result + 1 , j ) ;
27488: LD_ADDR_VAR 0 2
27492: PUSH
27493: LD_VAR 0 2
27497: PPUSH
27498: LD_VAR 0 2
27502: PUSH
27503: LD_INT 1
27505: PLUS
27506: PPUSH
27507: LD_VAR 0 7
27511: PPUSH
27512: CALL_OW 1
27516: ST_TO_ADDR
27517: GO 27485
27519: POP
27520: POP
// end ;
27521: GO 27451
27523: POP
27524: POP
// if not result then
27525: LD_VAR 0 2
27529: NOT
27530: IFFALSE 27534
// exit ;
27532: GO 27682
// mech := result [ 1 ] ;
27534: LD_ADDR_VAR 0 5
27538: PUSH
27539: LD_VAR 0 2
27543: PUSH
27544: LD_INT 1
27546: ARRAY
27547: ST_TO_ADDR
// if result > 1 then
27548: LD_VAR 0 2
27552: PUSH
27553: LD_INT 1
27555: GREATER
27556: IFFALSE 27668
// begin for i = 2 to result do
27558: LD_ADDR_VAR 0 3
27562: PUSH
27563: DOUBLE
27564: LD_INT 2
27566: DEC
27567: ST_TO_ADDR
27568: LD_VAR 0 2
27572: PUSH
27573: FOR_TO
27574: IFFALSE 27666
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
27576: LD_ADDR_VAR 0 4
27580: PUSH
27581: LD_VAR 0 2
27585: PUSH
27586: LD_VAR 0 3
27590: ARRAY
27591: PPUSH
27592: LD_INT 3
27594: PPUSH
27595: CALL_OW 259
27599: PUSH
27600: LD_VAR 0 2
27604: PUSH
27605: LD_VAR 0 3
27609: ARRAY
27610: PPUSH
27611: CALL_OW 432
27615: MINUS
27616: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
27617: LD_VAR 0 4
27621: PUSH
27622: LD_VAR 0 5
27626: PPUSH
27627: LD_INT 3
27629: PPUSH
27630: CALL_OW 259
27634: PUSH
27635: LD_VAR 0 5
27639: PPUSH
27640: CALL_OW 432
27644: MINUS
27645: GREATEREQUAL
27646: IFFALSE 27664
// mech := result [ i ] ;
27648: LD_ADDR_VAR 0 5
27652: PUSH
27653: LD_VAR 0 2
27657: PUSH
27658: LD_VAR 0 3
27662: ARRAY
27663: ST_TO_ADDR
// end ;
27664: GO 27573
27666: POP
27667: POP
// end ; ComLinkTo ( vehicle , mech ) ;
27668: LD_VAR 0 1
27672: PPUSH
27673: LD_VAR 0 5
27677: PPUSH
27678: CALL_OW 135
// end ;
27682: LD_VAR 0 2
27686: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
27687: LD_INT 0
27689: PPUSH
27690: PPUSH
27691: PPUSH
27692: PPUSH
27693: PPUSH
27694: PPUSH
27695: PPUSH
27696: PPUSH
27697: PPUSH
27698: PPUSH
27699: PPUSH
27700: PPUSH
27701: PPUSH
// result := [ ] ;
27702: LD_ADDR_VAR 0 7
27706: PUSH
27707: EMPTY
27708: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
27709: LD_VAR 0 1
27713: PPUSH
27714: CALL_OW 266
27718: PUSH
27719: LD_INT 0
27721: PUSH
27722: LD_INT 1
27724: PUSH
27725: EMPTY
27726: LIST
27727: LIST
27728: IN
27729: NOT
27730: IFFALSE 27734
// exit ;
27732: GO 29368
// if name then
27734: LD_VAR 0 3
27738: IFFALSE 27754
// SetBName ( base_dep , name ) ;
27740: LD_VAR 0 1
27744: PPUSH
27745: LD_VAR 0 3
27749: PPUSH
27750: CALL_OW 500
// base := GetBase ( base_dep ) ;
27754: LD_ADDR_VAR 0 15
27758: PUSH
27759: LD_VAR 0 1
27763: PPUSH
27764: CALL_OW 274
27768: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
27769: LD_ADDR_VAR 0 16
27773: PUSH
27774: LD_VAR 0 1
27778: PPUSH
27779: CALL_OW 255
27783: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
27784: LD_ADDR_VAR 0 17
27788: PUSH
27789: LD_VAR 0 1
27793: PPUSH
27794: CALL_OW 248
27798: ST_TO_ADDR
// if sources then
27799: LD_VAR 0 5
27803: IFFALSE 27850
// for i = 1 to 3 do
27805: LD_ADDR_VAR 0 8
27809: PUSH
27810: DOUBLE
27811: LD_INT 1
27813: DEC
27814: ST_TO_ADDR
27815: LD_INT 3
27817: PUSH
27818: FOR_TO
27819: IFFALSE 27848
// AddResourceType ( base , i , sources [ i ] ) ;
27821: LD_VAR 0 15
27825: PPUSH
27826: LD_VAR 0 8
27830: PPUSH
27831: LD_VAR 0 5
27835: PUSH
27836: LD_VAR 0 8
27840: ARRAY
27841: PPUSH
27842: CALL_OW 276
27846: GO 27818
27848: POP
27849: POP
// buildings := GetBaseBuildings ( base , area , true ) ;
27850: LD_ADDR_VAR 0 18
27854: PUSH
27855: LD_VAR 0 15
27859: PPUSH
27860: LD_VAR 0 2
27864: PPUSH
27865: LD_INT 1
27867: PPUSH
27868: CALL 27111 0 3
27872: ST_TO_ADDR
// InitHc ;
27873: CALL_OW 19
// InitUc ;
27877: CALL_OW 18
// uc_side := side ;
27881: LD_ADDR_OWVAR 20
27885: PUSH
27886: LD_VAR 0 16
27890: ST_TO_ADDR
// uc_nation := nation ;
27891: LD_ADDR_OWVAR 21
27895: PUSH
27896: LD_VAR 0 17
27900: ST_TO_ADDR
// if buildings then
27901: LD_VAR 0 18
27905: IFFALSE 29227
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
27907: LD_ADDR_VAR 0 19
27911: PUSH
27912: LD_VAR 0 18
27916: PPUSH
27917: LD_INT 2
27919: PUSH
27920: LD_INT 30
27922: PUSH
27923: LD_INT 29
27925: PUSH
27926: EMPTY
27927: LIST
27928: LIST
27929: PUSH
27930: LD_INT 30
27932: PUSH
27933: LD_INT 30
27935: PUSH
27936: EMPTY
27937: LIST
27938: LIST
27939: PUSH
27940: EMPTY
27941: LIST
27942: LIST
27943: LIST
27944: PPUSH
27945: CALL_OW 72
27949: ST_TO_ADDR
// if tmp then
27950: LD_VAR 0 19
27954: IFFALSE 28002
// for i in tmp do
27956: LD_ADDR_VAR 0 8
27960: PUSH
27961: LD_VAR 0 19
27965: PUSH
27966: FOR_IN
27967: IFFALSE 28000
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
27969: LD_VAR 0 8
27973: PPUSH
27974: CALL_OW 250
27978: PPUSH
27979: LD_VAR 0 8
27983: PPUSH
27984: CALL_OW 251
27988: PPUSH
27989: LD_VAR 0 16
27993: PPUSH
27994: CALL_OW 441
27998: GO 27966
28000: POP
28001: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
28002: LD_VAR 0 18
28006: PPUSH
28007: LD_INT 2
28009: PUSH
28010: LD_INT 30
28012: PUSH
28013: LD_INT 32
28015: PUSH
28016: EMPTY
28017: LIST
28018: LIST
28019: PUSH
28020: LD_INT 30
28022: PUSH
28023: LD_INT 33
28025: PUSH
28026: EMPTY
28027: LIST
28028: LIST
28029: PUSH
28030: EMPTY
28031: LIST
28032: LIST
28033: LIST
28034: PPUSH
28035: CALL_OW 72
28039: IFFALSE 28127
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
28041: LD_ADDR_VAR 0 8
28045: PUSH
28046: LD_VAR 0 18
28050: PPUSH
28051: LD_INT 2
28053: PUSH
28054: LD_INT 30
28056: PUSH
28057: LD_INT 32
28059: PUSH
28060: EMPTY
28061: LIST
28062: LIST
28063: PUSH
28064: LD_INT 30
28066: PUSH
28067: LD_INT 33
28069: PUSH
28070: EMPTY
28071: LIST
28072: LIST
28073: PUSH
28074: EMPTY
28075: LIST
28076: LIST
28077: LIST
28078: PPUSH
28079: CALL_OW 72
28083: PUSH
28084: FOR_IN
28085: IFFALSE 28125
// begin if not GetBWeapon ( i ) then
28087: LD_VAR 0 8
28091: PPUSH
28092: CALL_OW 269
28096: NOT
28097: IFFALSE 28123
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
28099: LD_VAR 0 8
28103: PPUSH
28104: LD_VAR 0 8
28108: PPUSH
28109: LD_VAR 0 2
28113: PPUSH
28114: CALL 29373 0 2
28118: PPUSH
28119: CALL_OW 431
// end ;
28123: GO 28084
28125: POP
28126: POP
// end ; for i = 1 to personel do
28127: LD_ADDR_VAR 0 8
28131: PUSH
28132: DOUBLE
28133: LD_INT 1
28135: DEC
28136: ST_TO_ADDR
28137: LD_VAR 0 6
28141: PUSH
28142: FOR_TO
28143: IFFALSE 29207
// begin if i > 4 then
28145: LD_VAR 0 8
28149: PUSH
28150: LD_INT 4
28152: GREATER
28153: IFFALSE 28157
// break ;
28155: GO 29207
// case i of 1 :
28157: LD_VAR 0 8
28161: PUSH
28162: LD_INT 1
28164: DOUBLE
28165: EQUAL
28166: IFTRUE 28170
28168: GO 28250
28170: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
28171: LD_ADDR_VAR 0 12
28175: PUSH
28176: LD_VAR 0 18
28180: PPUSH
28181: LD_INT 22
28183: PUSH
28184: LD_VAR 0 16
28188: PUSH
28189: EMPTY
28190: LIST
28191: LIST
28192: PUSH
28193: LD_INT 58
28195: PUSH
28196: EMPTY
28197: LIST
28198: PUSH
28199: LD_INT 2
28201: PUSH
28202: LD_INT 30
28204: PUSH
28205: LD_INT 32
28207: PUSH
28208: EMPTY
28209: LIST
28210: LIST
28211: PUSH
28212: LD_INT 30
28214: PUSH
28215: LD_INT 4
28217: PUSH
28218: EMPTY
28219: LIST
28220: LIST
28221: PUSH
28222: LD_INT 30
28224: PUSH
28225: LD_INT 5
28227: PUSH
28228: EMPTY
28229: LIST
28230: LIST
28231: PUSH
28232: EMPTY
28233: LIST
28234: LIST
28235: LIST
28236: LIST
28237: PUSH
28238: EMPTY
28239: LIST
28240: LIST
28241: LIST
28242: PPUSH
28243: CALL_OW 72
28247: ST_TO_ADDR
28248: GO 28472
28250: LD_INT 2
28252: DOUBLE
28253: EQUAL
28254: IFTRUE 28258
28256: GO 28320
28258: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
28259: LD_ADDR_VAR 0 12
28263: PUSH
28264: LD_VAR 0 18
28268: PPUSH
28269: LD_INT 22
28271: PUSH
28272: LD_VAR 0 16
28276: PUSH
28277: EMPTY
28278: LIST
28279: LIST
28280: PUSH
28281: LD_INT 2
28283: PUSH
28284: LD_INT 30
28286: PUSH
28287: LD_INT 0
28289: PUSH
28290: EMPTY
28291: LIST
28292: LIST
28293: PUSH
28294: LD_INT 30
28296: PUSH
28297: LD_INT 1
28299: PUSH
28300: EMPTY
28301: LIST
28302: LIST
28303: PUSH
28304: EMPTY
28305: LIST
28306: LIST
28307: LIST
28308: PUSH
28309: EMPTY
28310: LIST
28311: LIST
28312: PPUSH
28313: CALL_OW 72
28317: ST_TO_ADDR
28318: GO 28472
28320: LD_INT 3
28322: DOUBLE
28323: EQUAL
28324: IFTRUE 28328
28326: GO 28390
28328: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
28329: LD_ADDR_VAR 0 12
28333: PUSH
28334: LD_VAR 0 18
28338: PPUSH
28339: LD_INT 22
28341: PUSH
28342: LD_VAR 0 16
28346: PUSH
28347: EMPTY
28348: LIST
28349: LIST
28350: PUSH
28351: LD_INT 2
28353: PUSH
28354: LD_INT 30
28356: PUSH
28357: LD_INT 2
28359: PUSH
28360: EMPTY
28361: LIST
28362: LIST
28363: PUSH
28364: LD_INT 30
28366: PUSH
28367: LD_INT 3
28369: PUSH
28370: EMPTY
28371: LIST
28372: LIST
28373: PUSH
28374: EMPTY
28375: LIST
28376: LIST
28377: LIST
28378: PUSH
28379: EMPTY
28380: LIST
28381: LIST
28382: PPUSH
28383: CALL_OW 72
28387: ST_TO_ADDR
28388: GO 28472
28390: LD_INT 4
28392: DOUBLE
28393: EQUAL
28394: IFTRUE 28398
28396: GO 28471
28398: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
28399: LD_ADDR_VAR 0 12
28403: PUSH
28404: LD_VAR 0 18
28408: PPUSH
28409: LD_INT 22
28411: PUSH
28412: LD_VAR 0 16
28416: PUSH
28417: EMPTY
28418: LIST
28419: LIST
28420: PUSH
28421: LD_INT 2
28423: PUSH
28424: LD_INT 30
28426: PUSH
28427: LD_INT 6
28429: PUSH
28430: EMPTY
28431: LIST
28432: LIST
28433: PUSH
28434: LD_INT 30
28436: PUSH
28437: LD_INT 7
28439: PUSH
28440: EMPTY
28441: LIST
28442: LIST
28443: PUSH
28444: LD_INT 30
28446: PUSH
28447: LD_INT 8
28449: PUSH
28450: EMPTY
28451: LIST
28452: LIST
28453: PUSH
28454: EMPTY
28455: LIST
28456: LIST
28457: LIST
28458: LIST
28459: PUSH
28460: EMPTY
28461: LIST
28462: LIST
28463: PPUSH
28464: CALL_OW 72
28468: ST_TO_ADDR
28469: GO 28472
28471: POP
// if i = 1 then
28472: LD_VAR 0 8
28476: PUSH
28477: LD_INT 1
28479: EQUAL
28480: IFFALSE 28591
// begin tmp := [ ] ;
28482: LD_ADDR_VAR 0 19
28486: PUSH
28487: EMPTY
28488: ST_TO_ADDR
// for j in f do
28489: LD_ADDR_VAR 0 9
28493: PUSH
28494: LD_VAR 0 12
28498: PUSH
28499: FOR_IN
28500: IFFALSE 28573
// if GetBType ( j ) = b_bunker then
28502: LD_VAR 0 9
28506: PPUSH
28507: CALL_OW 266
28511: PUSH
28512: LD_INT 32
28514: EQUAL
28515: IFFALSE 28542
// tmp := Insert ( tmp , 1 , j ) else
28517: LD_ADDR_VAR 0 19
28521: PUSH
28522: LD_VAR 0 19
28526: PPUSH
28527: LD_INT 1
28529: PPUSH
28530: LD_VAR 0 9
28534: PPUSH
28535: CALL_OW 2
28539: ST_TO_ADDR
28540: GO 28571
// tmp := Insert ( tmp , tmp + 1 , j ) ;
28542: LD_ADDR_VAR 0 19
28546: PUSH
28547: LD_VAR 0 19
28551: PPUSH
28552: LD_VAR 0 19
28556: PUSH
28557: LD_INT 1
28559: PLUS
28560: PPUSH
28561: LD_VAR 0 9
28565: PPUSH
28566: CALL_OW 2
28570: ST_TO_ADDR
28571: GO 28499
28573: POP
28574: POP
// if tmp then
28575: LD_VAR 0 19
28579: IFFALSE 28591
// f := tmp ;
28581: LD_ADDR_VAR 0 12
28585: PUSH
28586: LD_VAR 0 19
28590: ST_TO_ADDR
// end ; x := personel [ i ] ;
28591: LD_ADDR_VAR 0 13
28595: PUSH
28596: LD_VAR 0 6
28600: PUSH
28601: LD_VAR 0 8
28605: ARRAY
28606: ST_TO_ADDR
// if x = - 1 then
28607: LD_VAR 0 13
28611: PUSH
28612: LD_INT 1
28614: NEG
28615: EQUAL
28616: IFFALSE 28825
// begin for j in f do
28618: LD_ADDR_VAR 0 9
28622: PUSH
28623: LD_VAR 0 12
28627: PUSH
28628: FOR_IN
28629: IFFALSE 28821
// repeat InitHc ;
28631: CALL_OW 19
// if GetBType ( j ) = b_barracks then
28635: LD_VAR 0 9
28639: PPUSH
28640: CALL_OW 266
28644: PUSH
28645: LD_INT 5
28647: EQUAL
28648: IFFALSE 28718
// begin if UnitsInside ( j ) < 3 then
28650: LD_VAR 0 9
28654: PPUSH
28655: CALL_OW 313
28659: PUSH
28660: LD_INT 3
28662: LESS
28663: IFFALSE 28699
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
28665: LD_INT 0
28667: PPUSH
28668: LD_INT 5
28670: PUSH
28671: LD_INT 8
28673: PUSH
28674: LD_INT 9
28676: PUSH
28677: EMPTY
28678: LIST
28679: LIST
28680: LIST
28681: PUSH
28682: LD_VAR 0 17
28686: ARRAY
28687: PPUSH
28688: LD_VAR 0 4
28692: PPUSH
28693: CALL_OW 380
28697: GO 28716
// PrepareHuman ( false , i , skill ) ;
28699: LD_INT 0
28701: PPUSH
28702: LD_VAR 0 8
28706: PPUSH
28707: LD_VAR 0 4
28711: PPUSH
28712: CALL_OW 380
// end else
28716: GO 28735
// PrepareHuman ( false , i , skill ) ;
28718: LD_INT 0
28720: PPUSH
28721: LD_VAR 0 8
28725: PPUSH
28726: LD_VAR 0 4
28730: PPUSH
28731: CALL_OW 380
// un := CreateHuman ;
28735: LD_ADDR_VAR 0 14
28739: PUSH
28740: CALL_OW 44
28744: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
28745: LD_ADDR_VAR 0 7
28749: PUSH
28750: LD_VAR 0 7
28754: PPUSH
28755: LD_INT 1
28757: PPUSH
28758: LD_VAR 0 14
28762: PPUSH
28763: CALL_OW 2
28767: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
28768: LD_VAR 0 14
28772: PPUSH
28773: LD_VAR 0 9
28777: PPUSH
28778: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
28782: LD_VAR 0 9
28786: PPUSH
28787: CALL_OW 313
28791: PUSH
28792: LD_INT 6
28794: EQUAL
28795: PUSH
28796: LD_VAR 0 9
28800: PPUSH
28801: CALL_OW 266
28805: PUSH
28806: LD_INT 32
28808: PUSH
28809: LD_INT 31
28811: PUSH
28812: EMPTY
28813: LIST
28814: LIST
28815: IN
28816: OR
28817: IFFALSE 28631
28819: GO 28628
28821: POP
28822: POP
// end else
28823: GO 29205
// for j = 1 to x do
28825: LD_ADDR_VAR 0 9
28829: PUSH
28830: DOUBLE
28831: LD_INT 1
28833: DEC
28834: ST_TO_ADDR
28835: LD_VAR 0 13
28839: PUSH
28840: FOR_TO
28841: IFFALSE 29203
// begin InitHc ;
28843: CALL_OW 19
// if not f then
28847: LD_VAR 0 12
28851: NOT
28852: IFFALSE 28941
// begin PrepareHuman ( false , i , skill ) ;
28854: LD_INT 0
28856: PPUSH
28857: LD_VAR 0 8
28861: PPUSH
28862: LD_VAR 0 4
28866: PPUSH
28867: CALL_OW 380
// un := CreateHuman ;
28871: LD_ADDR_VAR 0 14
28875: PUSH
28876: CALL_OW 44
28880: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
28881: LD_ADDR_VAR 0 7
28885: PUSH
28886: LD_VAR 0 7
28890: PPUSH
28891: LD_INT 1
28893: PPUSH
28894: LD_VAR 0 14
28898: PPUSH
28899: CALL_OW 2
28903: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
28904: LD_VAR 0 14
28908: PPUSH
28909: LD_VAR 0 1
28913: PPUSH
28914: CALL_OW 250
28918: PPUSH
28919: LD_VAR 0 1
28923: PPUSH
28924: CALL_OW 251
28928: PPUSH
28929: LD_INT 10
28931: PPUSH
28932: LD_INT 0
28934: PPUSH
28935: CALL_OW 50
// continue ;
28939: GO 28840
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
28941: LD_VAR 0 12
28945: PUSH
28946: LD_INT 1
28948: ARRAY
28949: PPUSH
28950: CALL_OW 313
28954: PUSH
28955: LD_VAR 0 12
28959: PUSH
28960: LD_INT 1
28962: ARRAY
28963: PPUSH
28964: CALL_OW 266
28968: PUSH
28969: LD_INT 32
28971: PUSH
28972: LD_INT 31
28974: PUSH
28975: EMPTY
28976: LIST
28977: LIST
28978: IN
28979: AND
28980: PUSH
28981: LD_VAR 0 12
28985: PUSH
28986: LD_INT 1
28988: ARRAY
28989: PPUSH
28990: CALL_OW 313
28994: PUSH
28995: LD_INT 6
28997: EQUAL
28998: OR
28999: IFFALSE 29019
// f := Delete ( f , 1 ) ;
29001: LD_ADDR_VAR 0 12
29005: PUSH
29006: LD_VAR 0 12
29010: PPUSH
29011: LD_INT 1
29013: PPUSH
29014: CALL_OW 3
29018: ST_TO_ADDR
// if not f then
29019: LD_VAR 0 12
29023: NOT
29024: IFFALSE 29042
// begin x := x + 2 ;
29026: LD_ADDR_VAR 0 13
29030: PUSH
29031: LD_VAR 0 13
29035: PUSH
29036: LD_INT 2
29038: PLUS
29039: ST_TO_ADDR
// continue ;
29040: GO 28840
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
29042: LD_VAR 0 12
29046: PUSH
29047: LD_INT 1
29049: ARRAY
29050: PPUSH
29051: CALL_OW 266
29055: PUSH
29056: LD_INT 5
29058: EQUAL
29059: IFFALSE 29133
// begin if UnitsInside ( f [ 1 ] ) < 3 then
29061: LD_VAR 0 12
29065: PUSH
29066: LD_INT 1
29068: ARRAY
29069: PPUSH
29070: CALL_OW 313
29074: PUSH
29075: LD_INT 3
29077: LESS
29078: IFFALSE 29114
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
29080: LD_INT 0
29082: PPUSH
29083: LD_INT 5
29085: PUSH
29086: LD_INT 8
29088: PUSH
29089: LD_INT 9
29091: PUSH
29092: EMPTY
29093: LIST
29094: LIST
29095: LIST
29096: PUSH
29097: LD_VAR 0 17
29101: ARRAY
29102: PPUSH
29103: LD_VAR 0 4
29107: PPUSH
29108: CALL_OW 380
29112: GO 29131
// PrepareHuman ( false , i , skill ) ;
29114: LD_INT 0
29116: PPUSH
29117: LD_VAR 0 8
29121: PPUSH
29122: LD_VAR 0 4
29126: PPUSH
29127: CALL_OW 380
// end else
29131: GO 29150
// PrepareHuman ( false , i , skill ) ;
29133: LD_INT 0
29135: PPUSH
29136: LD_VAR 0 8
29140: PPUSH
29141: LD_VAR 0 4
29145: PPUSH
29146: CALL_OW 380
// un := CreateHuman ;
29150: LD_ADDR_VAR 0 14
29154: PUSH
29155: CALL_OW 44
29159: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
29160: LD_ADDR_VAR 0 7
29164: PUSH
29165: LD_VAR 0 7
29169: PPUSH
29170: LD_INT 1
29172: PPUSH
29173: LD_VAR 0 14
29177: PPUSH
29178: CALL_OW 2
29182: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
29183: LD_VAR 0 14
29187: PPUSH
29188: LD_VAR 0 12
29192: PUSH
29193: LD_INT 1
29195: ARRAY
29196: PPUSH
29197: CALL_OW 52
// end ;
29201: GO 28840
29203: POP
29204: POP
// end ;
29205: GO 28142
29207: POP
29208: POP
// result := result ^ buildings ;
29209: LD_ADDR_VAR 0 7
29213: PUSH
29214: LD_VAR 0 7
29218: PUSH
29219: LD_VAR 0 18
29223: ADD
29224: ST_TO_ADDR
// end else
29225: GO 29368
// begin for i = 1 to personel do
29227: LD_ADDR_VAR 0 8
29231: PUSH
29232: DOUBLE
29233: LD_INT 1
29235: DEC
29236: ST_TO_ADDR
29237: LD_VAR 0 6
29241: PUSH
29242: FOR_TO
29243: IFFALSE 29366
// begin if i > 4 then
29245: LD_VAR 0 8
29249: PUSH
29250: LD_INT 4
29252: GREATER
29253: IFFALSE 29257
// break ;
29255: GO 29366
// x := personel [ i ] ;
29257: LD_ADDR_VAR 0 13
29261: PUSH
29262: LD_VAR 0 6
29266: PUSH
29267: LD_VAR 0 8
29271: ARRAY
29272: ST_TO_ADDR
// if x = - 1 then
29273: LD_VAR 0 13
29277: PUSH
29278: LD_INT 1
29280: NEG
29281: EQUAL
29282: IFFALSE 29286
// continue ;
29284: GO 29242
// PrepareHuman ( false , i , skill ) ;
29286: LD_INT 0
29288: PPUSH
29289: LD_VAR 0 8
29293: PPUSH
29294: LD_VAR 0 4
29298: PPUSH
29299: CALL_OW 380
// un := CreateHuman ;
29303: LD_ADDR_VAR 0 14
29307: PUSH
29308: CALL_OW 44
29312: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
29313: LD_VAR 0 14
29317: PPUSH
29318: LD_VAR 0 1
29322: PPUSH
29323: CALL_OW 250
29327: PPUSH
29328: LD_VAR 0 1
29332: PPUSH
29333: CALL_OW 251
29337: PPUSH
29338: LD_INT 10
29340: PPUSH
29341: LD_INT 0
29343: PPUSH
29344: CALL_OW 50
// result := result ^ un ;
29348: LD_ADDR_VAR 0 7
29352: PUSH
29353: LD_VAR 0 7
29357: PUSH
29358: LD_VAR 0 14
29362: ADD
29363: ST_TO_ADDR
// end ;
29364: GO 29242
29366: POP
29367: POP
// end ; end ;
29368: LD_VAR 0 7
29372: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
29373: LD_INT 0
29375: PPUSH
29376: PPUSH
29377: PPUSH
29378: PPUSH
29379: PPUSH
29380: PPUSH
29381: PPUSH
29382: PPUSH
29383: PPUSH
29384: PPUSH
29385: PPUSH
29386: PPUSH
29387: PPUSH
29388: PPUSH
29389: PPUSH
29390: PPUSH
// result := false ;
29391: LD_ADDR_VAR 0 3
29395: PUSH
29396: LD_INT 0
29398: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
29399: LD_VAR 0 1
29403: NOT
29404: PUSH
29405: LD_VAR 0 1
29409: PPUSH
29410: CALL_OW 266
29414: PUSH
29415: LD_INT 32
29417: PUSH
29418: LD_INT 33
29420: PUSH
29421: EMPTY
29422: LIST
29423: LIST
29424: IN
29425: NOT
29426: OR
29427: IFFALSE 29431
// exit ;
29429: GO 30540
// nat := GetNation ( tower ) ;
29431: LD_ADDR_VAR 0 12
29435: PUSH
29436: LD_VAR 0 1
29440: PPUSH
29441: CALL_OW 248
29445: ST_TO_ADDR
// side := GetSide ( tower ) ;
29446: LD_ADDR_VAR 0 16
29450: PUSH
29451: LD_VAR 0 1
29455: PPUSH
29456: CALL_OW 255
29460: ST_TO_ADDR
// x := GetX ( tower ) ;
29461: LD_ADDR_VAR 0 10
29465: PUSH
29466: LD_VAR 0 1
29470: PPUSH
29471: CALL_OW 250
29475: ST_TO_ADDR
// y := GetY ( tower ) ;
29476: LD_ADDR_VAR 0 11
29480: PUSH
29481: LD_VAR 0 1
29485: PPUSH
29486: CALL_OW 251
29490: ST_TO_ADDR
// if not x or not y then
29491: LD_VAR 0 10
29495: NOT
29496: PUSH
29497: LD_VAR 0 11
29501: NOT
29502: OR
29503: IFFALSE 29507
// exit ;
29505: GO 30540
// weapon := 0 ;
29507: LD_ADDR_VAR 0 18
29511: PUSH
29512: LD_INT 0
29514: ST_TO_ADDR
// fac_list := [ ] ;
29515: LD_ADDR_VAR 0 17
29519: PUSH
29520: EMPTY
29521: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area , false ) , [ f_btype , b_factory ] ) ;
29522: LD_ADDR_VAR 0 6
29526: PUSH
29527: LD_VAR 0 1
29531: PPUSH
29532: CALL_OW 274
29536: PPUSH
29537: LD_VAR 0 2
29541: PPUSH
29542: LD_INT 0
29544: PPUSH
29545: CALL 27111 0 3
29549: PPUSH
29550: LD_INT 30
29552: PUSH
29553: LD_INT 3
29555: PUSH
29556: EMPTY
29557: LIST
29558: LIST
29559: PPUSH
29560: CALL_OW 72
29564: ST_TO_ADDR
// if not factories then
29565: LD_VAR 0 6
29569: NOT
29570: IFFALSE 29574
// exit ;
29572: GO 30540
// for i in factories do
29574: LD_ADDR_VAR 0 8
29578: PUSH
29579: LD_VAR 0 6
29583: PUSH
29584: FOR_IN
29585: IFFALSE 29610
// fac_list := fac_list union AvailableWeaponList ( i ) ;
29587: LD_ADDR_VAR 0 17
29591: PUSH
29592: LD_VAR 0 17
29596: PUSH
29597: LD_VAR 0 8
29601: PPUSH
29602: CALL_OW 478
29606: UNION
29607: ST_TO_ADDR
29608: GO 29584
29610: POP
29611: POP
// if not fac_list then
29612: LD_VAR 0 17
29616: NOT
29617: IFFALSE 29621
// exit ;
29619: GO 30540
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
29621: LD_ADDR_VAR 0 5
29625: PUSH
29626: LD_INT 4
29628: PUSH
29629: LD_INT 5
29631: PUSH
29632: LD_INT 9
29634: PUSH
29635: LD_INT 10
29637: PUSH
29638: LD_INT 6
29640: PUSH
29641: LD_INT 7
29643: PUSH
29644: LD_INT 11
29646: PUSH
29647: EMPTY
29648: LIST
29649: LIST
29650: LIST
29651: LIST
29652: LIST
29653: LIST
29654: LIST
29655: PUSH
29656: LD_INT 27
29658: PUSH
29659: LD_INT 28
29661: PUSH
29662: LD_INT 26
29664: PUSH
29665: LD_INT 30
29667: PUSH
29668: EMPTY
29669: LIST
29670: LIST
29671: LIST
29672: LIST
29673: PUSH
29674: LD_INT 43
29676: PUSH
29677: LD_INT 44
29679: PUSH
29680: LD_INT 46
29682: PUSH
29683: LD_INT 45
29685: PUSH
29686: LD_INT 47
29688: PUSH
29689: LD_INT 49
29691: PUSH
29692: EMPTY
29693: LIST
29694: LIST
29695: LIST
29696: LIST
29697: LIST
29698: LIST
29699: PUSH
29700: EMPTY
29701: LIST
29702: LIST
29703: LIST
29704: PUSH
29705: LD_VAR 0 12
29709: ARRAY
29710: ST_TO_ADDR
// list := list isect fac_list ;
29711: LD_ADDR_VAR 0 5
29715: PUSH
29716: LD_VAR 0 5
29720: PUSH
29721: LD_VAR 0 17
29725: ISECT
29726: ST_TO_ADDR
// if not list then
29727: LD_VAR 0 5
29731: NOT
29732: IFFALSE 29736
// exit ;
29734: GO 30540
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
29736: LD_VAR 0 12
29740: PUSH
29741: LD_INT 3
29743: EQUAL
29744: PUSH
29745: LD_INT 49
29747: PUSH
29748: LD_VAR 0 5
29752: IN
29753: AND
29754: PUSH
29755: LD_INT 31
29757: PPUSH
29758: LD_VAR 0 16
29762: PPUSH
29763: CALL_OW 321
29767: PUSH
29768: LD_INT 2
29770: EQUAL
29771: AND
29772: IFFALSE 29832
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
29774: LD_INT 22
29776: PUSH
29777: LD_VAR 0 16
29781: PUSH
29782: EMPTY
29783: LIST
29784: LIST
29785: PUSH
29786: LD_INT 35
29788: PUSH
29789: LD_INT 49
29791: PUSH
29792: EMPTY
29793: LIST
29794: LIST
29795: PUSH
29796: LD_INT 91
29798: PUSH
29799: LD_VAR 0 1
29803: PUSH
29804: LD_INT 10
29806: PUSH
29807: EMPTY
29808: LIST
29809: LIST
29810: LIST
29811: PUSH
29812: EMPTY
29813: LIST
29814: LIST
29815: LIST
29816: PPUSH
29817: CALL_OW 69
29821: NOT
29822: IFFALSE 29832
// weapon := ru_time_lapser ;
29824: LD_ADDR_VAR 0 18
29828: PUSH
29829: LD_INT 49
29831: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
29832: LD_VAR 0 12
29836: PUSH
29837: LD_INT 1
29839: PUSH
29840: LD_INT 2
29842: PUSH
29843: EMPTY
29844: LIST
29845: LIST
29846: IN
29847: PUSH
29848: LD_INT 11
29850: PUSH
29851: LD_VAR 0 5
29855: IN
29856: PUSH
29857: LD_INT 30
29859: PUSH
29860: LD_VAR 0 5
29864: IN
29865: OR
29866: AND
29867: PUSH
29868: LD_INT 6
29870: PPUSH
29871: LD_VAR 0 16
29875: PPUSH
29876: CALL_OW 321
29880: PUSH
29881: LD_INT 2
29883: EQUAL
29884: AND
29885: IFFALSE 30050
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
29887: LD_INT 22
29889: PUSH
29890: LD_VAR 0 16
29894: PUSH
29895: EMPTY
29896: LIST
29897: LIST
29898: PUSH
29899: LD_INT 2
29901: PUSH
29902: LD_INT 35
29904: PUSH
29905: LD_INT 11
29907: PUSH
29908: EMPTY
29909: LIST
29910: LIST
29911: PUSH
29912: LD_INT 35
29914: PUSH
29915: LD_INT 30
29917: PUSH
29918: EMPTY
29919: LIST
29920: LIST
29921: PUSH
29922: EMPTY
29923: LIST
29924: LIST
29925: LIST
29926: PUSH
29927: LD_INT 91
29929: PUSH
29930: LD_VAR 0 1
29934: PUSH
29935: LD_INT 18
29937: PUSH
29938: EMPTY
29939: LIST
29940: LIST
29941: LIST
29942: PUSH
29943: EMPTY
29944: LIST
29945: LIST
29946: LIST
29947: PPUSH
29948: CALL_OW 69
29952: NOT
29953: PUSH
29954: LD_INT 22
29956: PUSH
29957: LD_VAR 0 16
29961: PUSH
29962: EMPTY
29963: LIST
29964: LIST
29965: PUSH
29966: LD_INT 2
29968: PUSH
29969: LD_INT 30
29971: PUSH
29972: LD_INT 32
29974: PUSH
29975: EMPTY
29976: LIST
29977: LIST
29978: PUSH
29979: LD_INT 30
29981: PUSH
29982: LD_INT 33
29984: PUSH
29985: EMPTY
29986: LIST
29987: LIST
29988: PUSH
29989: EMPTY
29990: LIST
29991: LIST
29992: LIST
29993: PUSH
29994: LD_INT 91
29996: PUSH
29997: LD_VAR 0 1
30001: PUSH
30002: LD_INT 12
30004: PUSH
30005: EMPTY
30006: LIST
30007: LIST
30008: LIST
30009: PUSH
30010: EMPTY
30011: LIST
30012: LIST
30013: LIST
30014: PUSH
30015: EMPTY
30016: LIST
30017: PPUSH
30018: CALL_OW 69
30022: PUSH
30023: LD_INT 2
30025: GREATER
30026: AND
30027: IFFALSE 30050
// weapon := [ us_radar , ar_radar ] [ nat ] ;
30029: LD_ADDR_VAR 0 18
30033: PUSH
30034: LD_INT 11
30036: PUSH
30037: LD_INT 30
30039: PUSH
30040: EMPTY
30041: LIST
30042: LIST
30043: PUSH
30044: LD_VAR 0 12
30048: ARRAY
30049: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
30050: LD_VAR 0 18
30054: NOT
30055: PUSH
30056: LD_INT 40
30058: PPUSH
30059: LD_VAR 0 16
30063: PPUSH
30064: CALL_OW 321
30068: PUSH
30069: LD_INT 2
30071: EQUAL
30072: AND
30073: PUSH
30074: LD_INT 7
30076: PUSH
30077: LD_VAR 0 5
30081: IN
30082: PUSH
30083: LD_INT 28
30085: PUSH
30086: LD_VAR 0 5
30090: IN
30091: OR
30092: PUSH
30093: LD_INT 45
30095: PUSH
30096: LD_VAR 0 5
30100: IN
30101: OR
30102: AND
30103: IFFALSE 30357
// begin hex := GetHexInfo ( x , y ) ;
30105: LD_ADDR_VAR 0 4
30109: PUSH
30110: LD_VAR 0 10
30114: PPUSH
30115: LD_VAR 0 11
30119: PPUSH
30120: CALL_OW 546
30124: ST_TO_ADDR
// if hex [ 1 ] then
30125: LD_VAR 0 4
30129: PUSH
30130: LD_INT 1
30132: ARRAY
30133: IFFALSE 30137
// exit ;
30135: GO 30540
// height := hex [ 2 ] ;
30137: LD_ADDR_VAR 0 15
30141: PUSH
30142: LD_VAR 0 4
30146: PUSH
30147: LD_INT 2
30149: ARRAY
30150: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
30151: LD_ADDR_VAR 0 14
30155: PUSH
30156: LD_INT 0
30158: PUSH
30159: LD_INT 2
30161: PUSH
30162: LD_INT 3
30164: PUSH
30165: LD_INT 5
30167: PUSH
30168: EMPTY
30169: LIST
30170: LIST
30171: LIST
30172: LIST
30173: ST_TO_ADDR
// for i in tmp do
30174: LD_ADDR_VAR 0 8
30178: PUSH
30179: LD_VAR 0 14
30183: PUSH
30184: FOR_IN
30185: IFFALSE 30355
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
30187: LD_ADDR_VAR 0 9
30191: PUSH
30192: LD_VAR 0 10
30196: PPUSH
30197: LD_VAR 0 8
30201: PPUSH
30202: LD_INT 5
30204: PPUSH
30205: CALL_OW 272
30209: PUSH
30210: LD_VAR 0 11
30214: PPUSH
30215: LD_VAR 0 8
30219: PPUSH
30220: LD_INT 5
30222: PPUSH
30223: CALL_OW 273
30227: PUSH
30228: EMPTY
30229: LIST
30230: LIST
30231: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
30232: LD_VAR 0 9
30236: PUSH
30237: LD_INT 1
30239: ARRAY
30240: PPUSH
30241: LD_VAR 0 9
30245: PUSH
30246: LD_INT 2
30248: ARRAY
30249: PPUSH
30250: CALL_OW 488
30254: IFFALSE 30353
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
30256: LD_ADDR_VAR 0 4
30260: PUSH
30261: LD_VAR 0 9
30265: PUSH
30266: LD_INT 1
30268: ARRAY
30269: PPUSH
30270: LD_VAR 0 9
30274: PUSH
30275: LD_INT 2
30277: ARRAY
30278: PPUSH
30279: CALL_OW 546
30283: ST_TO_ADDR
// if hex [ 1 ] then
30284: LD_VAR 0 4
30288: PUSH
30289: LD_INT 1
30291: ARRAY
30292: IFFALSE 30296
// continue ;
30294: GO 30184
// h := hex [ 2 ] ;
30296: LD_ADDR_VAR 0 13
30300: PUSH
30301: LD_VAR 0 4
30305: PUSH
30306: LD_INT 2
30308: ARRAY
30309: ST_TO_ADDR
// if h + 7 < height then
30310: LD_VAR 0 13
30314: PUSH
30315: LD_INT 7
30317: PLUS
30318: PUSH
30319: LD_VAR 0 15
30323: LESS
30324: IFFALSE 30353
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
30326: LD_ADDR_VAR 0 18
30330: PUSH
30331: LD_INT 7
30333: PUSH
30334: LD_INT 28
30336: PUSH
30337: LD_INT 45
30339: PUSH
30340: EMPTY
30341: LIST
30342: LIST
30343: LIST
30344: PUSH
30345: LD_VAR 0 12
30349: ARRAY
30350: ST_TO_ADDR
// break ;
30351: GO 30355
// end ; end ; end ;
30353: GO 30184
30355: POP
30356: POP
// end ; if not weapon then
30357: LD_VAR 0 18
30361: NOT
30362: IFFALSE 30422
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
30364: LD_ADDR_VAR 0 5
30368: PUSH
30369: LD_VAR 0 5
30373: PUSH
30374: LD_INT 11
30376: PUSH
30377: LD_INT 30
30379: PUSH
30380: LD_INT 49
30382: PUSH
30383: EMPTY
30384: LIST
30385: LIST
30386: LIST
30387: DIFF
30388: ST_TO_ADDR
// if not list then
30389: LD_VAR 0 5
30393: NOT
30394: IFFALSE 30398
// exit ;
30396: GO 30540
// weapon := list [ rand ( 1 , list ) ] ;
30398: LD_ADDR_VAR 0 18
30402: PUSH
30403: LD_VAR 0 5
30407: PUSH
30408: LD_INT 1
30410: PPUSH
30411: LD_VAR 0 5
30415: PPUSH
30416: CALL_OW 12
30420: ARRAY
30421: ST_TO_ADDR
// end ; if weapon then
30422: LD_VAR 0 18
30426: IFFALSE 30540
// begin tmp := CostOfWeapon ( weapon ) ;
30428: LD_ADDR_VAR 0 14
30432: PUSH
30433: LD_VAR 0 18
30437: PPUSH
30438: CALL_OW 451
30442: ST_TO_ADDR
// j := GetBase ( tower ) ;
30443: LD_ADDR_VAR 0 9
30447: PUSH
30448: LD_VAR 0 1
30452: PPUSH
30453: CALL_OW 274
30457: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
30458: LD_VAR 0 9
30462: PPUSH
30463: LD_INT 1
30465: PPUSH
30466: CALL_OW 275
30470: PUSH
30471: LD_VAR 0 14
30475: PUSH
30476: LD_INT 1
30478: ARRAY
30479: GREATEREQUAL
30480: PUSH
30481: LD_VAR 0 9
30485: PPUSH
30486: LD_INT 2
30488: PPUSH
30489: CALL_OW 275
30493: PUSH
30494: LD_VAR 0 14
30498: PUSH
30499: LD_INT 2
30501: ARRAY
30502: GREATEREQUAL
30503: AND
30504: PUSH
30505: LD_VAR 0 9
30509: PPUSH
30510: LD_INT 3
30512: PPUSH
30513: CALL_OW 275
30517: PUSH
30518: LD_VAR 0 14
30522: PUSH
30523: LD_INT 3
30525: ARRAY
30526: GREATEREQUAL
30527: AND
30528: IFFALSE 30540
// result := weapon ;
30530: LD_ADDR_VAR 0 3
30534: PUSH
30535: LD_VAR 0 18
30539: ST_TO_ADDR
// end ; end ;
30540: LD_VAR 0 3
30544: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
30545: LD_INT 0
30547: PPUSH
30548: PPUSH
// result := true ;
30549: LD_ADDR_VAR 0 3
30553: PUSH
30554: LD_INT 1
30556: ST_TO_ADDR
// if array1 = array2 then
30557: LD_VAR 0 1
30561: PUSH
30562: LD_VAR 0 2
30566: EQUAL
30567: IFFALSE 30627
// begin for i = 1 to array1 do
30569: LD_ADDR_VAR 0 4
30573: PUSH
30574: DOUBLE
30575: LD_INT 1
30577: DEC
30578: ST_TO_ADDR
30579: LD_VAR 0 1
30583: PUSH
30584: FOR_TO
30585: IFFALSE 30623
// if array1 [ i ] <> array2 [ i ] then
30587: LD_VAR 0 1
30591: PUSH
30592: LD_VAR 0 4
30596: ARRAY
30597: PUSH
30598: LD_VAR 0 2
30602: PUSH
30603: LD_VAR 0 4
30607: ARRAY
30608: NONEQUAL
30609: IFFALSE 30621
// begin result := false ;
30611: LD_ADDR_VAR 0 3
30615: PUSH
30616: LD_INT 0
30618: ST_TO_ADDR
// break ;
30619: GO 30623
// end ;
30621: GO 30584
30623: POP
30624: POP
// end else
30625: GO 30635
// result := false ;
30627: LD_ADDR_VAR 0 3
30631: PUSH
30632: LD_INT 0
30634: ST_TO_ADDR
// end ;
30635: LD_VAR 0 3
30639: RET
// export function CompareArrayValues ( array1 , array2 ) ; var i ; begin
30640: LD_INT 0
30642: PPUSH
30643: PPUSH
// if not array1 or not array2 then
30644: LD_VAR 0 1
30648: NOT
30649: PUSH
30650: LD_VAR 0 2
30654: NOT
30655: OR
30656: IFFALSE 30660
// exit ;
30658: GO 30724
// result := true ;
30660: LD_ADDR_VAR 0 3
30664: PUSH
30665: LD_INT 1
30667: ST_TO_ADDR
// for i = 1 to array1 do
30668: LD_ADDR_VAR 0 4
30672: PUSH
30673: DOUBLE
30674: LD_INT 1
30676: DEC
30677: ST_TO_ADDR
30678: LD_VAR 0 1
30682: PUSH
30683: FOR_TO
30684: IFFALSE 30722
// if array1 [ i ] <> array2 [ i ] then
30686: LD_VAR 0 1
30690: PUSH
30691: LD_VAR 0 4
30695: ARRAY
30696: PUSH
30697: LD_VAR 0 2
30701: PUSH
30702: LD_VAR 0 4
30706: ARRAY
30707: NONEQUAL
30708: IFFALSE 30720
// begin result := false ;
30710: LD_ADDR_VAR 0 3
30714: PUSH
30715: LD_INT 0
30717: ST_TO_ADDR
// break ;
30718: GO 30722
// end ;
30720: GO 30683
30722: POP
30723: POP
// end ;
30724: LD_VAR 0 3
30728: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
30729: LD_INT 0
30731: PPUSH
30732: PPUSH
30733: PPUSH
// pom := GetBase ( fac ) ;
30734: LD_ADDR_VAR 0 5
30738: PUSH
30739: LD_VAR 0 1
30743: PPUSH
30744: CALL_OW 274
30748: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
30749: LD_ADDR_VAR 0 4
30753: PUSH
30754: LD_VAR 0 2
30758: PUSH
30759: LD_INT 1
30761: ARRAY
30762: PPUSH
30763: LD_VAR 0 2
30767: PUSH
30768: LD_INT 2
30770: ARRAY
30771: PPUSH
30772: LD_VAR 0 2
30776: PUSH
30777: LD_INT 3
30779: ARRAY
30780: PPUSH
30781: LD_VAR 0 2
30785: PUSH
30786: LD_INT 4
30788: ARRAY
30789: PPUSH
30790: CALL_OW 449
30794: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
30795: LD_ADDR_VAR 0 3
30799: PUSH
30800: LD_VAR 0 5
30804: PPUSH
30805: LD_INT 1
30807: PPUSH
30808: CALL_OW 275
30812: PUSH
30813: LD_VAR 0 4
30817: PUSH
30818: LD_INT 1
30820: ARRAY
30821: GREATEREQUAL
30822: PUSH
30823: LD_VAR 0 5
30827: PPUSH
30828: LD_INT 2
30830: PPUSH
30831: CALL_OW 275
30835: PUSH
30836: LD_VAR 0 4
30840: PUSH
30841: LD_INT 2
30843: ARRAY
30844: GREATEREQUAL
30845: AND
30846: PUSH
30847: LD_VAR 0 5
30851: PPUSH
30852: LD_INT 3
30854: PPUSH
30855: CALL_OW 275
30859: PUSH
30860: LD_VAR 0 4
30864: PUSH
30865: LD_INT 3
30867: ARRAY
30868: GREATEREQUAL
30869: AND
30870: ST_TO_ADDR
// end ;
30871: LD_VAR 0 3
30875: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
30876: LD_INT 0
30878: PPUSH
30879: PPUSH
30880: PPUSH
30881: PPUSH
// pom := GetBase ( building ) ;
30882: LD_ADDR_VAR 0 3
30886: PUSH
30887: LD_VAR 0 1
30891: PPUSH
30892: CALL_OW 274
30896: ST_TO_ADDR
// if not pom then
30897: LD_VAR 0 3
30901: NOT
30902: IFFALSE 30906
// exit ;
30904: GO 31076
// btype := GetBType ( building ) ;
30906: LD_ADDR_VAR 0 5
30910: PUSH
30911: LD_VAR 0 1
30915: PPUSH
30916: CALL_OW 266
30920: ST_TO_ADDR
// if btype = b_armoury then
30921: LD_VAR 0 5
30925: PUSH
30926: LD_INT 4
30928: EQUAL
30929: IFFALSE 30939
// btype := b_barracks ;
30931: LD_ADDR_VAR 0 5
30935: PUSH
30936: LD_INT 5
30938: ST_TO_ADDR
// if btype = b_depot then
30939: LD_VAR 0 5
30943: PUSH
30944: LD_INT 0
30946: EQUAL
30947: IFFALSE 30957
// btype := b_warehouse ;
30949: LD_ADDR_VAR 0 5
30953: PUSH
30954: LD_INT 1
30956: ST_TO_ADDR
// if btype = b_workshop then
30957: LD_VAR 0 5
30961: PUSH
30962: LD_INT 2
30964: EQUAL
30965: IFFALSE 30975
// btype := b_factory ;
30967: LD_ADDR_VAR 0 5
30971: PUSH
30972: LD_INT 3
30974: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
30975: LD_ADDR_VAR 0 4
30979: PUSH
30980: LD_VAR 0 5
30984: PPUSH
30985: LD_VAR 0 1
30989: PPUSH
30990: CALL_OW 248
30994: PPUSH
30995: CALL_OW 450
30999: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
31000: LD_ADDR_VAR 0 2
31004: PUSH
31005: LD_VAR 0 3
31009: PPUSH
31010: LD_INT 1
31012: PPUSH
31013: CALL_OW 275
31017: PUSH
31018: LD_VAR 0 4
31022: PUSH
31023: LD_INT 1
31025: ARRAY
31026: GREATEREQUAL
31027: PUSH
31028: LD_VAR 0 3
31032: PPUSH
31033: LD_INT 2
31035: PPUSH
31036: CALL_OW 275
31040: PUSH
31041: LD_VAR 0 4
31045: PUSH
31046: LD_INT 2
31048: ARRAY
31049: GREATEREQUAL
31050: AND
31051: PUSH
31052: LD_VAR 0 3
31056: PPUSH
31057: LD_INT 3
31059: PPUSH
31060: CALL_OW 275
31064: PUSH
31065: LD_VAR 0 4
31069: PUSH
31070: LD_INT 3
31072: ARRAY
31073: GREATEREQUAL
31074: AND
31075: ST_TO_ADDR
// end ;
31076: LD_VAR 0 2
31080: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
31081: LD_INT 0
31083: PPUSH
31084: PPUSH
31085: PPUSH
// pom := GetBase ( building ) ;
31086: LD_ADDR_VAR 0 4
31090: PUSH
31091: LD_VAR 0 1
31095: PPUSH
31096: CALL_OW 274
31100: ST_TO_ADDR
// if not pom then
31101: LD_VAR 0 4
31105: NOT
31106: IFFALSE 31110
// exit ;
31108: GO 31211
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
31110: LD_ADDR_VAR 0 5
31114: PUSH
31115: LD_VAR 0 2
31119: PPUSH
31120: LD_VAR 0 1
31124: PPUSH
31125: CALL_OW 248
31129: PPUSH
31130: CALL_OW 450
31134: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
31135: LD_ADDR_VAR 0 3
31139: PUSH
31140: LD_VAR 0 4
31144: PPUSH
31145: LD_INT 1
31147: PPUSH
31148: CALL_OW 275
31152: PUSH
31153: LD_VAR 0 5
31157: PUSH
31158: LD_INT 1
31160: ARRAY
31161: GREATEREQUAL
31162: PUSH
31163: LD_VAR 0 4
31167: PPUSH
31168: LD_INT 2
31170: PPUSH
31171: CALL_OW 275
31175: PUSH
31176: LD_VAR 0 5
31180: PUSH
31181: LD_INT 2
31183: ARRAY
31184: GREATEREQUAL
31185: AND
31186: PUSH
31187: LD_VAR 0 4
31191: PPUSH
31192: LD_INT 3
31194: PPUSH
31195: CALL_OW 275
31199: PUSH
31200: LD_VAR 0 5
31204: PUSH
31205: LD_INT 3
31207: ARRAY
31208: GREATEREQUAL
31209: AND
31210: ST_TO_ADDR
// end ;
31211: LD_VAR 0 3
31215: RET
// export function TryClearPlaceForBuilding ( btype , x , y , d , buildings , cleaners , parking ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep , driver ; begin
31216: LD_INT 0
31218: PPUSH
31219: PPUSH
31220: PPUSH
31221: PPUSH
31222: PPUSH
31223: PPUSH
31224: PPUSH
31225: PPUSH
31226: PPUSH
31227: PPUSH
31228: PPUSH
// result := false ;
31229: LD_ADDR_VAR 0 8
31233: PUSH
31234: LD_INT 0
31236: ST_TO_ADDR
// if not buildings or not btype or not x or not y then
31237: LD_VAR 0 5
31241: NOT
31242: PUSH
31243: LD_VAR 0 1
31247: NOT
31248: OR
31249: PUSH
31250: LD_VAR 0 2
31254: NOT
31255: OR
31256: PUSH
31257: LD_VAR 0 3
31261: NOT
31262: OR
31263: IFFALSE 31267
// exit ;
31265: GO 32081
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( buildings [ 1 ] ) , 0 ) ;
31267: LD_ADDR_VAR 0 14
31271: PUSH
31272: LD_VAR 0 1
31276: PPUSH
31277: LD_VAR 0 2
31281: PPUSH
31282: LD_VAR 0 3
31286: PPUSH
31287: LD_VAR 0 4
31291: PPUSH
31292: LD_VAR 0 5
31296: PUSH
31297: LD_INT 1
31299: ARRAY
31300: PPUSH
31301: CALL_OW 248
31305: PPUSH
31306: LD_INT 0
31308: PPUSH
31309: CALL 33318 0 6
31313: ST_TO_ADDR
// if not hexes then
31314: LD_VAR 0 14
31318: NOT
31319: IFFALSE 31323
// exit ;
31321: GO 32081
// dep := UnitFilter ( buildings , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
31323: LD_ADDR_VAR 0 17
31327: PUSH
31328: LD_VAR 0 5
31332: PPUSH
31333: LD_INT 22
31335: PUSH
31336: LD_VAR 0 13
31340: PPUSH
31341: CALL_OW 255
31345: PUSH
31346: EMPTY
31347: LIST
31348: LIST
31349: PUSH
31350: LD_INT 2
31352: PUSH
31353: LD_INT 30
31355: PUSH
31356: LD_INT 0
31358: PUSH
31359: EMPTY
31360: LIST
31361: LIST
31362: PUSH
31363: LD_INT 30
31365: PUSH
31366: LD_INT 1
31368: PUSH
31369: EMPTY
31370: LIST
31371: LIST
31372: PUSH
31373: EMPTY
31374: LIST
31375: LIST
31376: LIST
31377: PUSH
31378: EMPTY
31379: LIST
31380: LIST
31381: PPUSH
31382: CALL_OW 72
31386: ST_TO_ADDR
// for i = 1 to hexes do
31387: LD_ADDR_VAR 0 9
31391: PUSH
31392: DOUBLE
31393: LD_INT 1
31395: DEC
31396: ST_TO_ADDR
31397: LD_VAR 0 14
31401: PUSH
31402: FOR_TO
31403: IFFALSE 32079
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
31405: LD_ADDR_VAR 0 13
31409: PUSH
31410: LD_VAR 0 14
31414: PUSH
31415: LD_VAR 0 9
31419: ARRAY
31420: PUSH
31421: LD_INT 1
31423: ARRAY
31424: PPUSH
31425: LD_VAR 0 14
31429: PUSH
31430: LD_VAR 0 9
31434: ARRAY
31435: PUSH
31436: LD_INT 2
31438: ARRAY
31439: PPUSH
31440: CALL_OW 428
31444: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
31445: LD_VAR 0 14
31449: PUSH
31450: LD_VAR 0 9
31454: ARRAY
31455: PUSH
31456: LD_INT 1
31458: ARRAY
31459: PPUSH
31460: LD_VAR 0 14
31464: PUSH
31465: LD_VAR 0 9
31469: ARRAY
31470: PUSH
31471: LD_INT 2
31473: ARRAY
31474: PPUSH
31475: CALL_OW 351
31479: PUSH
31480: LD_VAR 0 14
31484: PUSH
31485: LD_VAR 0 9
31489: ARRAY
31490: PUSH
31491: LD_INT 1
31493: ARRAY
31494: PPUSH
31495: LD_VAR 0 14
31499: PUSH
31500: LD_VAR 0 9
31504: ARRAY
31505: PUSH
31506: LD_INT 2
31508: ARRAY
31509: PPUSH
31510: CALL_OW 488
31514: NOT
31515: OR
31516: PUSH
31517: LD_VAR 0 13
31521: PPUSH
31522: CALL_OW 247
31526: PUSH
31527: LD_INT 3
31529: EQUAL
31530: OR
31531: IFFALSE 31537
// exit ;
31533: POP
31534: POP
31535: GO 32081
// if not tmp then
31537: LD_VAR 0 13
31541: NOT
31542: IFFALSE 31546
// continue ;
31544: GO 31402
// result := true ;
31546: LD_ADDR_VAR 0 8
31550: PUSH
31551: LD_INT 1
31553: ST_TO_ADDR
// if cleaners and GetType ( tmp ) = unit_vehicle and GetControl ( tmp ) = control_manual then
31554: LD_VAR 0 6
31558: PUSH
31559: LD_VAR 0 13
31563: PPUSH
31564: CALL_OW 247
31568: PUSH
31569: LD_INT 2
31571: EQUAL
31572: AND
31573: PUSH
31574: LD_VAR 0 13
31578: PPUSH
31579: CALL_OW 263
31583: PUSH
31584: LD_INT 1
31586: EQUAL
31587: AND
31588: IFFALSE 31752
// begin if IsDrivenBy ( tmp ) then
31590: LD_VAR 0 13
31594: PPUSH
31595: CALL_OW 311
31599: IFFALSE 31603
// continue ;
31601: GO 31402
// if UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) then
31603: LD_VAR 0 6
31607: PPUSH
31608: LD_INT 3
31610: PUSH
31611: LD_INT 60
31613: PUSH
31614: EMPTY
31615: LIST
31616: PUSH
31617: EMPTY
31618: LIST
31619: LIST
31620: PUSH
31621: LD_INT 3
31623: PUSH
31624: LD_INT 55
31626: PUSH
31627: EMPTY
31628: LIST
31629: PUSH
31630: EMPTY
31631: LIST
31632: LIST
31633: PUSH
31634: EMPTY
31635: LIST
31636: LIST
31637: PPUSH
31638: CALL_OW 72
31642: IFFALSE 31750
// begin driver := UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) [ 1 ] ;
31644: LD_ADDR_VAR 0 18
31648: PUSH
31649: LD_VAR 0 6
31653: PPUSH
31654: LD_INT 3
31656: PUSH
31657: LD_INT 60
31659: PUSH
31660: EMPTY
31661: LIST
31662: PUSH
31663: EMPTY
31664: LIST
31665: LIST
31666: PUSH
31667: LD_INT 3
31669: PUSH
31670: LD_INT 55
31672: PUSH
31673: EMPTY
31674: LIST
31675: PUSH
31676: EMPTY
31677: LIST
31678: LIST
31679: PUSH
31680: EMPTY
31681: LIST
31682: LIST
31683: PPUSH
31684: CALL_OW 72
31688: PUSH
31689: LD_INT 1
31691: ARRAY
31692: ST_TO_ADDR
// if IsInUnit ( driver ) then
31693: LD_VAR 0 18
31697: PPUSH
31698: CALL_OW 310
31702: IFFALSE 31713
// ComExit ( driver ) ;
31704: LD_VAR 0 18
31708: PPUSH
31709: CALL 57006 0 1
// AddComEnterUnit ( driver , tmp ) ;
31713: LD_VAR 0 18
31717: PPUSH
31718: LD_VAR 0 13
31722: PPUSH
31723: CALL_OW 180
// AddComMoveToArea ( driver , parking ) ;
31727: LD_VAR 0 18
31731: PPUSH
31732: LD_VAR 0 7
31736: PPUSH
31737: CALL_OW 173
// AddComExitVehicle ( driver ) ;
31741: LD_VAR 0 18
31745: PPUSH
31746: CALL_OW 181
// end ; continue ;
31750: GO 31402
// end ; if not cleaners or not tmp in cleaners then
31752: LD_VAR 0 6
31756: NOT
31757: PUSH
31758: LD_VAR 0 13
31762: PUSH
31763: LD_VAR 0 6
31767: IN
31768: NOT
31769: OR
31770: IFFALSE 32077
// begin if dep then
31772: LD_VAR 0 17
31776: IFFALSE 31912
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
31778: LD_ADDR_VAR 0 16
31782: PUSH
31783: LD_VAR 0 17
31787: PUSH
31788: LD_INT 1
31790: ARRAY
31791: PPUSH
31792: CALL_OW 250
31796: PPUSH
31797: LD_VAR 0 17
31801: PUSH
31802: LD_INT 1
31804: ARRAY
31805: PPUSH
31806: CALL_OW 254
31810: PPUSH
31811: LD_INT 5
31813: PPUSH
31814: CALL_OW 272
31818: PUSH
31819: LD_VAR 0 17
31823: PUSH
31824: LD_INT 1
31826: ARRAY
31827: PPUSH
31828: CALL_OW 251
31832: PPUSH
31833: LD_VAR 0 17
31837: PUSH
31838: LD_INT 1
31840: ARRAY
31841: PPUSH
31842: CALL_OW 254
31846: PPUSH
31847: LD_INT 5
31849: PPUSH
31850: CALL_OW 273
31854: PUSH
31855: EMPTY
31856: LIST
31857: LIST
31858: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
31859: LD_VAR 0 16
31863: PUSH
31864: LD_INT 1
31866: ARRAY
31867: PPUSH
31868: LD_VAR 0 16
31872: PUSH
31873: LD_INT 2
31875: ARRAY
31876: PPUSH
31877: CALL_OW 488
31881: IFFALSE 31912
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
31883: LD_VAR 0 13
31887: PPUSH
31888: LD_VAR 0 16
31892: PUSH
31893: LD_INT 1
31895: ARRAY
31896: PPUSH
31897: LD_VAR 0 16
31901: PUSH
31902: LD_INT 2
31904: ARRAY
31905: PPUSH
31906: CALL_OW 111
// continue ;
31910: GO 31402
// end ; end ; r := GetDir ( tmp ) ;
31912: LD_ADDR_VAR 0 15
31916: PUSH
31917: LD_VAR 0 13
31921: PPUSH
31922: CALL_OW 254
31926: ST_TO_ADDR
// if r = 5 then
31927: LD_VAR 0 15
31931: PUSH
31932: LD_INT 5
31934: EQUAL
31935: IFFALSE 31945
// r := 0 ;
31937: LD_ADDR_VAR 0 15
31941: PUSH
31942: LD_INT 0
31944: ST_TO_ADDR
// for j = r to 5 do
31945: LD_ADDR_VAR 0 10
31949: PUSH
31950: DOUBLE
31951: LD_VAR 0 15
31955: DEC
31956: ST_TO_ADDR
31957: LD_INT 5
31959: PUSH
31960: FOR_TO
31961: IFFALSE 32075
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
31963: LD_ADDR_VAR 0 11
31967: PUSH
31968: LD_VAR 0 13
31972: PPUSH
31973: CALL_OW 250
31977: PPUSH
31978: LD_VAR 0 10
31982: PPUSH
31983: LD_INT 2
31985: PPUSH
31986: CALL_OW 272
31990: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
31991: LD_ADDR_VAR 0 12
31995: PUSH
31996: LD_VAR 0 13
32000: PPUSH
32001: CALL_OW 251
32005: PPUSH
32006: LD_VAR 0 10
32010: PPUSH
32011: LD_INT 2
32013: PPUSH
32014: CALL_OW 273
32018: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
32019: LD_VAR 0 11
32023: PPUSH
32024: LD_VAR 0 12
32028: PPUSH
32029: CALL_OW 488
32033: PUSH
32034: LD_VAR 0 11
32038: PPUSH
32039: LD_VAR 0 12
32043: PPUSH
32044: CALL_OW 428
32048: NOT
32049: AND
32050: IFFALSE 32073
// begin ComMoveXY ( tmp , _x , _y ) ;
32052: LD_VAR 0 13
32056: PPUSH
32057: LD_VAR 0 11
32061: PPUSH
32062: LD_VAR 0 12
32066: PPUSH
32067: CALL_OW 111
// break ;
32071: GO 32075
// end ; end ;
32073: GO 31960
32075: POP
32076: POP
// end ; end ;
32077: GO 31402
32079: POP
32080: POP
// end ;
32081: LD_VAR 0 8
32085: RET
// export function BuildingTechInvented ( side , btype ) ; begin
32086: LD_INT 0
32088: PPUSH
// result := true ;
32089: LD_ADDR_VAR 0 3
32093: PUSH
32094: LD_INT 1
32096: ST_TO_ADDR
// case btype of b_ext_computer , b_turret :
32097: LD_VAR 0 2
32101: PUSH
32102: LD_INT 24
32104: DOUBLE
32105: EQUAL
32106: IFTRUE 32116
32108: LD_INT 33
32110: DOUBLE
32111: EQUAL
32112: IFTRUE 32116
32114: GO 32141
32116: POP
// result := ( GetTech ( tech_ai , side ) = state_researched ) ; b_ext_radar :
32117: LD_ADDR_VAR 0 3
32121: PUSH
32122: LD_INT 32
32124: PPUSH
32125: LD_VAR 0 1
32129: PPUSH
32130: CALL_OW 321
32134: PUSH
32135: LD_INT 2
32137: EQUAL
32138: ST_TO_ADDR
32139: GO 32461
32141: LD_INT 20
32143: DOUBLE
32144: EQUAL
32145: IFTRUE 32149
32147: GO 32174
32149: POP
// result := ( GetTech ( tech_radar , side ) = state_researched ) ; b_ext_radio , b_control_tower :
32150: LD_ADDR_VAR 0 3
32154: PUSH
32155: LD_INT 6
32157: PPUSH
32158: LD_VAR 0 1
32162: PPUSH
32163: CALL_OW 321
32167: PUSH
32168: LD_INT 2
32170: EQUAL
32171: ST_TO_ADDR
32172: GO 32461
32174: LD_INT 22
32176: DOUBLE
32177: EQUAL
32178: IFTRUE 32188
32180: LD_INT 36
32182: DOUBLE
32183: EQUAL
32184: IFTRUE 32188
32186: GO 32213
32188: POP
// result := ( GetTech ( tech_remcont , side ) = state_researched ) ; b_siberite_mine :
32189: LD_ADDR_VAR 0 3
32193: PUSH
32194: LD_INT 15
32196: PPUSH
32197: LD_VAR 0 1
32201: PPUSH
32202: CALL_OW 321
32206: PUSH
32207: LD_INT 2
32209: EQUAL
32210: ST_TO_ADDR
32211: GO 32461
32213: LD_INT 30
32215: DOUBLE
32216: EQUAL
32217: IFTRUE 32221
32219: GO 32246
32221: POP
// result := ( GetTech ( tech_sibdet , side ) = state_researched ) ; b_siberite_power , b_ext_siberium :
32222: LD_ADDR_VAR 0 3
32226: PUSH
32227: LD_INT 20
32229: PPUSH
32230: LD_VAR 0 1
32234: PPUSH
32235: CALL_OW 321
32239: PUSH
32240: LD_INT 2
32242: EQUAL
32243: ST_TO_ADDR
32244: GO 32461
32246: LD_INT 28
32248: DOUBLE
32249: EQUAL
32250: IFTRUE 32260
32252: LD_INT 21
32254: DOUBLE
32255: EQUAL
32256: IFTRUE 32260
32258: GO 32285
32260: POP
// result := ( GetTech ( tech_sibpow , side ) = state_researched ) ; b_ext_track :
32261: LD_ADDR_VAR 0 3
32265: PUSH
32266: LD_INT 21
32268: PPUSH
32269: LD_VAR 0 1
32273: PPUSH
32274: CALL_OW 321
32278: PUSH
32279: LD_INT 2
32281: EQUAL
32282: ST_TO_ADDR
32283: GO 32461
32285: LD_INT 16
32287: DOUBLE
32288: EQUAL
32289: IFTRUE 32293
32291: GO 32320
32293: POP
// result := ( GetTech ( tech_track , side ) = state_researched ) ; b_ext_noncombat , b_ext_stitch :
32294: LD_ADDR_VAR 0 3
32298: PUSH
32299: LD_EXP 171
32303: PPUSH
32304: LD_VAR 0 1
32308: PPUSH
32309: CALL_OW 321
32313: PUSH
32314: LD_INT 2
32316: EQUAL
32317: ST_TO_ADDR
32318: GO 32461
32320: LD_INT 19
32322: DOUBLE
32323: EQUAL
32324: IFTRUE 32334
32326: LD_INT 23
32328: DOUBLE
32329: EQUAL
32330: IFTRUE 32334
32332: GO 32361
32334: POP
// result := ( GetTech ( tech_cargo , side ) = state_researched ) ; b_ext_gun :
32335: LD_ADDR_VAR 0 3
32339: PUSH
32340: LD_EXP 170
32344: PPUSH
32345: LD_VAR 0 1
32349: PPUSH
32350: CALL_OW 321
32354: PUSH
32355: LD_INT 2
32357: EQUAL
32358: ST_TO_ADDR
32359: GO 32461
32361: LD_INT 17
32363: DOUBLE
32364: EQUAL
32365: IFTRUE 32369
32367: GO 32394
32369: POP
// result := ( GetTech ( tech_gun , side ) = state_researched ) ; b_ext_rocket :
32370: LD_ADDR_VAR 0 3
32374: PUSH
32375: LD_INT 39
32377: PPUSH
32378: LD_VAR 0 1
32382: PPUSH
32383: CALL_OW 321
32387: PUSH
32388: LD_INT 2
32390: EQUAL
32391: ST_TO_ADDR
32392: GO 32461
32394: LD_INT 18
32396: DOUBLE
32397: EQUAL
32398: IFTRUE 32402
32400: GO 32427
32402: POP
// result := ( GetTech ( tech_rocket , side ) = state_researched ) ; b_solar_power :
32403: LD_ADDR_VAR 0 3
32407: PUSH
32408: LD_INT 40
32410: PPUSH
32411: LD_VAR 0 1
32415: PPUSH
32416: CALL_OW 321
32420: PUSH
32421: LD_INT 2
32423: EQUAL
32424: ST_TO_ADDR
32425: GO 32461
32427: LD_INT 27
32429: DOUBLE
32430: EQUAL
32431: IFTRUE 32435
32433: GO 32460
32435: POP
// result := ( GetTech ( tech_solpow , side ) = state_researched ) ; end ;
32436: LD_ADDR_VAR 0 3
32440: PUSH
32441: LD_INT 35
32443: PPUSH
32444: LD_VAR 0 1
32448: PPUSH
32449: CALL_OW 321
32453: PUSH
32454: LD_INT 2
32456: EQUAL
32457: ST_TO_ADDR
32458: GO 32461
32460: POP
// end ;
32461: LD_VAR 0 3
32465: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex , tech ; begin
32466: LD_INT 0
32468: PPUSH
32469: PPUSH
32470: PPUSH
32471: PPUSH
32472: PPUSH
32473: PPUSH
32474: PPUSH
32475: PPUSH
32476: PPUSH
32477: PPUSH
32478: PPUSH
// result := false ;
32479: LD_ADDR_VAR 0 6
32483: PUSH
32484: LD_INT 0
32486: ST_TO_ADDR
// if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
32487: LD_VAR 0 1
32491: NOT
32492: PUSH
32493: LD_VAR 0 1
32497: PPUSH
32498: CALL_OW 266
32502: PUSH
32503: LD_INT 0
32505: PUSH
32506: LD_INT 1
32508: PUSH
32509: EMPTY
32510: LIST
32511: LIST
32512: IN
32513: NOT
32514: OR
32515: PUSH
32516: LD_VAR 0 2
32520: NOT
32521: OR
32522: PUSH
32523: LD_VAR 0 5
32527: PUSH
32528: LD_INT 0
32530: PUSH
32531: LD_INT 1
32533: PUSH
32534: LD_INT 2
32536: PUSH
32537: LD_INT 3
32539: PUSH
32540: LD_INT 4
32542: PUSH
32543: LD_INT 5
32545: PUSH
32546: EMPTY
32547: LIST
32548: LIST
32549: LIST
32550: LIST
32551: LIST
32552: LIST
32553: IN
32554: NOT
32555: OR
32556: PUSH
32557: LD_VAR 0 3
32561: PPUSH
32562: LD_VAR 0 4
32566: PPUSH
32567: CALL_OW 488
32571: NOT
32572: OR
32573: IFFALSE 32577
// exit ;
32575: GO 33313
// side := GetSide ( depot ) ;
32577: LD_ADDR_VAR 0 9
32581: PUSH
32582: LD_VAR 0 1
32586: PPUSH
32587: CALL_OW 255
32591: ST_TO_ADDR
// if not BuildingTechInvented ( side , btype ) then
32592: LD_VAR 0 9
32596: PPUSH
32597: LD_VAR 0 2
32601: PPUSH
32602: CALL 32086 0 2
32606: NOT
32607: IFFALSE 32611
// exit ;
32609: GO 33313
// pom := GetBase ( depot ) ;
32611: LD_ADDR_VAR 0 10
32615: PUSH
32616: LD_VAR 0 1
32620: PPUSH
32621: CALL_OW 274
32625: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
32626: LD_ADDR_VAR 0 11
32630: PUSH
32631: LD_VAR 0 2
32635: PPUSH
32636: LD_VAR 0 1
32640: PPUSH
32641: CALL_OW 248
32645: PPUSH
32646: CALL_OW 450
32650: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
32651: LD_VAR 0 10
32655: PPUSH
32656: LD_INT 1
32658: PPUSH
32659: CALL_OW 275
32663: PUSH
32664: LD_VAR 0 11
32668: PUSH
32669: LD_INT 1
32671: ARRAY
32672: GREATEREQUAL
32673: PUSH
32674: LD_VAR 0 10
32678: PPUSH
32679: LD_INT 2
32681: PPUSH
32682: CALL_OW 275
32686: PUSH
32687: LD_VAR 0 11
32691: PUSH
32692: LD_INT 2
32694: ARRAY
32695: GREATEREQUAL
32696: AND
32697: PUSH
32698: LD_VAR 0 10
32702: PPUSH
32703: LD_INT 3
32705: PPUSH
32706: CALL_OW 275
32710: PUSH
32711: LD_VAR 0 11
32715: PUSH
32716: LD_INT 3
32718: ARRAY
32719: GREATEREQUAL
32720: AND
32721: NOT
32722: IFFALSE 32726
// exit ;
32724: GO 33313
// if GetBType ( depot ) = b_depot then
32726: LD_VAR 0 1
32730: PPUSH
32731: CALL_OW 266
32735: PUSH
32736: LD_INT 0
32738: EQUAL
32739: IFFALSE 32751
// dist := 28 else
32741: LD_ADDR_VAR 0 14
32745: PUSH
32746: LD_INT 28
32748: ST_TO_ADDR
32749: GO 32759
// dist := 36 ;
32751: LD_ADDR_VAR 0 14
32755: PUSH
32756: LD_INT 36
32758: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
32759: LD_VAR 0 1
32763: PPUSH
32764: LD_VAR 0 3
32768: PPUSH
32769: LD_VAR 0 4
32773: PPUSH
32774: CALL_OW 297
32778: PUSH
32779: LD_VAR 0 14
32783: GREATER
32784: IFFALSE 32788
// exit ;
32786: GO 33313
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
32788: LD_ADDR_VAR 0 12
32792: PUSH
32793: LD_VAR 0 2
32797: PPUSH
32798: LD_VAR 0 3
32802: PPUSH
32803: LD_VAR 0 4
32807: PPUSH
32808: LD_VAR 0 5
32812: PPUSH
32813: LD_VAR 0 1
32817: PPUSH
32818: CALL_OW 248
32822: PPUSH
32823: LD_INT 0
32825: PPUSH
32826: CALL 33318 0 6
32830: ST_TO_ADDR
// if not hexes then
32831: LD_VAR 0 12
32835: NOT
32836: IFFALSE 32840
// exit ;
32838: GO 33313
// hex := GetHexInfo ( x , y ) ;
32840: LD_ADDR_VAR 0 15
32844: PUSH
32845: LD_VAR 0 3
32849: PPUSH
32850: LD_VAR 0 4
32854: PPUSH
32855: CALL_OW 546
32859: ST_TO_ADDR
// if hex [ 1 ] then
32860: LD_VAR 0 15
32864: PUSH
32865: LD_INT 1
32867: ARRAY
32868: IFFALSE 32872
// exit ;
32870: GO 33313
// height := hex [ 2 ] ;
32872: LD_ADDR_VAR 0 13
32876: PUSH
32877: LD_VAR 0 15
32881: PUSH
32882: LD_INT 2
32884: ARRAY
32885: ST_TO_ADDR
// for i = 1 to hexes do
32886: LD_ADDR_VAR 0 7
32890: PUSH
32891: DOUBLE
32892: LD_INT 1
32894: DEC
32895: ST_TO_ADDR
32896: LD_VAR 0 12
32900: PUSH
32901: FOR_TO
32902: IFFALSE 33232
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
32904: LD_VAR 0 12
32908: PUSH
32909: LD_VAR 0 7
32913: ARRAY
32914: PUSH
32915: LD_INT 1
32917: ARRAY
32918: PPUSH
32919: LD_VAR 0 12
32923: PUSH
32924: LD_VAR 0 7
32928: ARRAY
32929: PUSH
32930: LD_INT 2
32932: ARRAY
32933: PPUSH
32934: CALL_OW 488
32938: NOT
32939: PUSH
32940: LD_VAR 0 12
32944: PUSH
32945: LD_VAR 0 7
32949: ARRAY
32950: PUSH
32951: LD_INT 1
32953: ARRAY
32954: PPUSH
32955: LD_VAR 0 12
32959: PUSH
32960: LD_VAR 0 7
32964: ARRAY
32965: PUSH
32966: LD_INT 2
32968: ARRAY
32969: PPUSH
32970: CALL_OW 428
32974: PUSH
32975: LD_INT 0
32977: GREATER
32978: OR
32979: PUSH
32980: LD_VAR 0 12
32984: PUSH
32985: LD_VAR 0 7
32989: ARRAY
32990: PUSH
32991: LD_INT 1
32993: ARRAY
32994: PPUSH
32995: LD_VAR 0 12
32999: PUSH
33000: LD_VAR 0 7
33004: ARRAY
33005: PUSH
33006: LD_INT 2
33008: ARRAY
33009: PPUSH
33010: CALL_OW 351
33014: OR
33015: IFFALSE 33021
// exit ;
33017: POP
33018: POP
33019: GO 33313
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
33021: LD_ADDR_VAR 0 8
33025: PUSH
33026: LD_VAR 0 12
33030: PUSH
33031: LD_VAR 0 7
33035: ARRAY
33036: PUSH
33037: LD_INT 1
33039: ARRAY
33040: PPUSH
33041: LD_VAR 0 12
33045: PUSH
33046: LD_VAR 0 7
33050: ARRAY
33051: PUSH
33052: LD_INT 2
33054: ARRAY
33055: PPUSH
33056: CALL_OW 546
33060: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
33061: LD_VAR 0 8
33065: PUSH
33066: LD_INT 1
33068: ARRAY
33069: PUSH
33070: LD_VAR 0 8
33074: PUSH
33075: LD_INT 2
33077: ARRAY
33078: PUSH
33079: LD_VAR 0 13
33083: PUSH
33084: LD_INT 2
33086: PLUS
33087: GREATER
33088: OR
33089: PUSH
33090: LD_VAR 0 8
33094: PUSH
33095: LD_INT 2
33097: ARRAY
33098: PUSH
33099: LD_VAR 0 13
33103: PUSH
33104: LD_INT 2
33106: MINUS
33107: LESS
33108: OR
33109: PUSH
33110: LD_VAR 0 8
33114: PUSH
33115: LD_INT 3
33117: ARRAY
33118: PUSH
33119: LD_INT 0
33121: PUSH
33122: LD_INT 8
33124: PUSH
33125: LD_INT 9
33127: PUSH
33128: LD_INT 10
33130: PUSH
33131: LD_INT 11
33133: PUSH
33134: LD_INT 12
33136: PUSH
33137: LD_INT 13
33139: PUSH
33140: LD_INT 16
33142: PUSH
33143: LD_INT 17
33145: PUSH
33146: LD_INT 18
33148: PUSH
33149: LD_INT 19
33151: PUSH
33152: LD_INT 20
33154: PUSH
33155: LD_INT 21
33157: PUSH
33158: EMPTY
33159: LIST
33160: LIST
33161: LIST
33162: LIST
33163: LIST
33164: LIST
33165: LIST
33166: LIST
33167: LIST
33168: LIST
33169: LIST
33170: LIST
33171: LIST
33172: IN
33173: NOT
33174: OR
33175: PUSH
33176: LD_VAR 0 8
33180: PUSH
33181: LD_INT 5
33183: ARRAY
33184: NOT
33185: OR
33186: PUSH
33187: LD_VAR 0 8
33191: PUSH
33192: LD_INT 6
33194: ARRAY
33195: PUSH
33196: LD_INT 1
33198: PUSH
33199: LD_INT 2
33201: PUSH
33202: LD_INT 7
33204: PUSH
33205: LD_INT 9
33207: PUSH
33208: LD_INT 10
33210: PUSH
33211: LD_INT 11
33213: PUSH
33214: EMPTY
33215: LIST
33216: LIST
33217: LIST
33218: LIST
33219: LIST
33220: LIST
33221: IN
33222: NOT
33223: OR
33224: IFFALSE 33230
// exit ;
33226: POP
33227: POP
33228: GO 33313
// end ;
33230: GO 32901
33232: POP
33233: POP
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
33234: LD_VAR 0 9
33238: PPUSH
33239: LD_VAR 0 3
33243: PPUSH
33244: LD_VAR 0 4
33248: PPUSH
33249: LD_INT 20
33251: PPUSH
33252: CALL 25259 0 4
33256: PUSH
33257: LD_INT 4
33259: ARRAY
33260: IFFALSE 33264
// exit ;
33262: GO 33313
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
33264: LD_VAR 0 2
33268: PUSH
33269: LD_INT 29
33271: PUSH
33272: LD_INT 30
33274: PUSH
33275: EMPTY
33276: LIST
33277: LIST
33278: IN
33279: PUSH
33280: LD_VAR 0 3
33284: PPUSH
33285: LD_VAR 0 4
33289: PPUSH
33290: LD_VAR 0 9
33294: PPUSH
33295: CALL_OW 440
33299: NOT
33300: AND
33301: IFFALSE 33305
// exit ;
33303: GO 33313
// result := true ;
33305: LD_ADDR_VAR 0 6
33309: PUSH
33310: LD_INT 1
33312: ST_TO_ADDR
// end ;
33313: LD_VAR 0 6
33317: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 , fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 , fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ; var fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 , fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ; var fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 , fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ; var fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 , fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ; begin
33318: LD_INT 0
33320: PPUSH
33321: PPUSH
33322: PPUSH
33323: PPUSH
33324: PPUSH
33325: PPUSH
33326: PPUSH
33327: PPUSH
33328: PPUSH
33329: PPUSH
33330: PPUSH
33331: PPUSH
33332: PPUSH
33333: PPUSH
33334: PPUSH
33335: PPUSH
33336: PPUSH
33337: PPUSH
33338: PPUSH
33339: PPUSH
33340: PPUSH
33341: PPUSH
33342: PPUSH
33343: PPUSH
33344: PPUSH
33345: PPUSH
33346: PPUSH
33347: PPUSH
33348: PPUSH
33349: PPUSH
33350: PPUSH
33351: PPUSH
33352: PPUSH
33353: PPUSH
33354: PPUSH
33355: PPUSH
33356: PPUSH
33357: PPUSH
33358: PPUSH
33359: PPUSH
33360: PPUSH
33361: PPUSH
33362: PPUSH
33363: PPUSH
33364: PPUSH
33365: PPUSH
33366: PPUSH
33367: PPUSH
33368: PPUSH
33369: PPUSH
33370: PPUSH
33371: PPUSH
33372: PPUSH
33373: PPUSH
33374: PPUSH
33375: PPUSH
33376: PPUSH
33377: PPUSH
// result = [ ] ;
33378: LD_ADDR_VAR 0 7
33382: PUSH
33383: EMPTY
33384: ST_TO_ADDR
// temp_list = [ ] ;
33385: LD_ADDR_VAR 0 9
33389: PUSH
33390: EMPTY
33391: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
33392: LD_VAR 0 4
33396: PUSH
33397: LD_INT 0
33399: PUSH
33400: LD_INT 1
33402: PUSH
33403: LD_INT 2
33405: PUSH
33406: LD_INT 3
33408: PUSH
33409: LD_INT 4
33411: PUSH
33412: LD_INT 5
33414: PUSH
33415: EMPTY
33416: LIST
33417: LIST
33418: LIST
33419: LIST
33420: LIST
33421: LIST
33422: IN
33423: NOT
33424: PUSH
33425: LD_VAR 0 1
33429: PUSH
33430: LD_INT 0
33432: PUSH
33433: LD_INT 1
33435: PUSH
33436: EMPTY
33437: LIST
33438: LIST
33439: IN
33440: PUSH
33441: LD_VAR 0 5
33445: PUSH
33446: LD_INT 1
33448: PUSH
33449: LD_INT 2
33451: PUSH
33452: LD_INT 3
33454: PUSH
33455: EMPTY
33456: LIST
33457: LIST
33458: LIST
33459: IN
33460: NOT
33461: AND
33462: OR
33463: IFFALSE 33467
// exit ;
33465: GO 51858
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
33467: LD_VAR 0 1
33471: PUSH
33472: LD_INT 6
33474: PUSH
33475: LD_INT 7
33477: PUSH
33478: LD_INT 8
33480: PUSH
33481: LD_INT 13
33483: PUSH
33484: LD_INT 12
33486: PUSH
33487: LD_INT 15
33489: PUSH
33490: LD_INT 11
33492: PUSH
33493: LD_INT 14
33495: PUSH
33496: LD_INT 10
33498: PUSH
33499: EMPTY
33500: LIST
33501: LIST
33502: LIST
33503: LIST
33504: LIST
33505: LIST
33506: LIST
33507: LIST
33508: LIST
33509: IN
33510: IFFALSE 33520
// btype = b_lab ;
33512: LD_ADDR_VAR 0 1
33516: PUSH
33517: LD_INT 6
33519: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
33520: LD_VAR 0 6
33524: PUSH
33525: LD_INT 0
33527: PUSH
33528: LD_INT 1
33530: PUSH
33531: LD_INT 2
33533: PUSH
33534: EMPTY
33535: LIST
33536: LIST
33537: LIST
33538: IN
33539: NOT
33540: PUSH
33541: LD_VAR 0 1
33545: PUSH
33546: LD_INT 0
33548: PUSH
33549: LD_INT 1
33551: PUSH
33552: LD_INT 2
33554: PUSH
33555: LD_INT 3
33557: PUSH
33558: LD_INT 6
33560: PUSH
33561: LD_INT 36
33563: PUSH
33564: LD_INT 4
33566: PUSH
33567: LD_INT 5
33569: PUSH
33570: LD_INT 31
33572: PUSH
33573: LD_INT 32
33575: PUSH
33576: LD_INT 33
33578: PUSH
33579: EMPTY
33580: LIST
33581: LIST
33582: LIST
33583: LIST
33584: LIST
33585: LIST
33586: LIST
33587: LIST
33588: LIST
33589: LIST
33590: LIST
33591: IN
33592: NOT
33593: PUSH
33594: LD_VAR 0 6
33598: PUSH
33599: LD_INT 1
33601: EQUAL
33602: AND
33603: OR
33604: PUSH
33605: LD_VAR 0 1
33609: PUSH
33610: LD_INT 2
33612: PUSH
33613: LD_INT 3
33615: PUSH
33616: EMPTY
33617: LIST
33618: LIST
33619: IN
33620: NOT
33621: PUSH
33622: LD_VAR 0 6
33626: PUSH
33627: LD_INT 2
33629: EQUAL
33630: AND
33631: OR
33632: IFFALSE 33642
// mode = 0 ;
33634: LD_ADDR_VAR 0 6
33638: PUSH
33639: LD_INT 0
33641: ST_TO_ADDR
// case mode of 0 :
33642: LD_VAR 0 6
33646: PUSH
33647: LD_INT 0
33649: DOUBLE
33650: EQUAL
33651: IFTRUE 33655
33653: GO 45108
33655: POP
// begin fDepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
33656: LD_ADDR_VAR 0 11
33660: PUSH
33661: LD_INT 0
33663: PUSH
33664: LD_INT 0
33666: PUSH
33667: EMPTY
33668: LIST
33669: LIST
33670: PUSH
33671: LD_INT 0
33673: PUSH
33674: LD_INT 1
33676: NEG
33677: PUSH
33678: EMPTY
33679: LIST
33680: LIST
33681: PUSH
33682: LD_INT 1
33684: PUSH
33685: LD_INT 0
33687: PUSH
33688: EMPTY
33689: LIST
33690: LIST
33691: PUSH
33692: LD_INT 1
33694: PUSH
33695: LD_INT 1
33697: PUSH
33698: EMPTY
33699: LIST
33700: LIST
33701: PUSH
33702: LD_INT 0
33704: PUSH
33705: LD_INT 1
33707: PUSH
33708: EMPTY
33709: LIST
33710: LIST
33711: PUSH
33712: LD_INT 1
33714: NEG
33715: PUSH
33716: LD_INT 0
33718: PUSH
33719: EMPTY
33720: LIST
33721: LIST
33722: PUSH
33723: LD_INT 1
33725: NEG
33726: PUSH
33727: LD_INT 1
33729: NEG
33730: PUSH
33731: EMPTY
33732: LIST
33733: LIST
33734: PUSH
33735: LD_INT 1
33737: NEG
33738: PUSH
33739: LD_INT 2
33741: NEG
33742: PUSH
33743: EMPTY
33744: LIST
33745: LIST
33746: PUSH
33747: LD_INT 0
33749: PUSH
33750: LD_INT 2
33752: NEG
33753: PUSH
33754: EMPTY
33755: LIST
33756: LIST
33757: PUSH
33758: LD_INT 1
33760: PUSH
33761: LD_INT 1
33763: NEG
33764: PUSH
33765: EMPTY
33766: LIST
33767: LIST
33768: PUSH
33769: LD_INT 1
33771: PUSH
33772: LD_INT 2
33774: PUSH
33775: EMPTY
33776: LIST
33777: LIST
33778: PUSH
33779: LD_INT 0
33781: PUSH
33782: LD_INT 2
33784: PUSH
33785: EMPTY
33786: LIST
33787: LIST
33788: PUSH
33789: LD_INT 1
33791: NEG
33792: PUSH
33793: LD_INT 1
33795: PUSH
33796: EMPTY
33797: LIST
33798: LIST
33799: PUSH
33800: LD_INT 1
33802: PUSH
33803: LD_INT 3
33805: PUSH
33806: EMPTY
33807: LIST
33808: LIST
33809: PUSH
33810: LD_INT 0
33812: PUSH
33813: LD_INT 3
33815: PUSH
33816: EMPTY
33817: LIST
33818: LIST
33819: PUSH
33820: LD_INT 1
33822: NEG
33823: PUSH
33824: LD_INT 2
33826: PUSH
33827: EMPTY
33828: LIST
33829: LIST
33830: PUSH
33831: EMPTY
33832: LIST
33833: LIST
33834: LIST
33835: LIST
33836: LIST
33837: LIST
33838: LIST
33839: LIST
33840: LIST
33841: LIST
33842: LIST
33843: LIST
33844: LIST
33845: LIST
33846: LIST
33847: LIST
33848: ST_TO_ADDR
// fDepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
33849: LD_ADDR_VAR 0 12
33853: PUSH
33854: LD_INT 0
33856: PUSH
33857: LD_INT 0
33859: PUSH
33860: EMPTY
33861: LIST
33862: LIST
33863: PUSH
33864: LD_INT 0
33866: PUSH
33867: LD_INT 1
33869: NEG
33870: PUSH
33871: EMPTY
33872: LIST
33873: LIST
33874: PUSH
33875: LD_INT 1
33877: PUSH
33878: LD_INT 0
33880: PUSH
33881: EMPTY
33882: LIST
33883: LIST
33884: PUSH
33885: LD_INT 1
33887: PUSH
33888: LD_INT 1
33890: PUSH
33891: EMPTY
33892: LIST
33893: LIST
33894: PUSH
33895: LD_INT 0
33897: PUSH
33898: LD_INT 1
33900: PUSH
33901: EMPTY
33902: LIST
33903: LIST
33904: PUSH
33905: LD_INT 1
33907: NEG
33908: PUSH
33909: LD_INT 0
33911: PUSH
33912: EMPTY
33913: LIST
33914: LIST
33915: PUSH
33916: LD_INT 1
33918: NEG
33919: PUSH
33920: LD_INT 1
33922: NEG
33923: PUSH
33924: EMPTY
33925: LIST
33926: LIST
33927: PUSH
33928: LD_INT 1
33930: PUSH
33931: LD_INT 1
33933: NEG
33934: PUSH
33935: EMPTY
33936: LIST
33937: LIST
33938: PUSH
33939: LD_INT 2
33941: PUSH
33942: LD_INT 0
33944: PUSH
33945: EMPTY
33946: LIST
33947: LIST
33948: PUSH
33949: LD_INT 2
33951: PUSH
33952: LD_INT 1
33954: PUSH
33955: EMPTY
33956: LIST
33957: LIST
33958: PUSH
33959: LD_INT 1
33961: NEG
33962: PUSH
33963: LD_INT 1
33965: PUSH
33966: EMPTY
33967: LIST
33968: LIST
33969: PUSH
33970: LD_INT 2
33972: NEG
33973: PUSH
33974: LD_INT 0
33976: PUSH
33977: EMPTY
33978: LIST
33979: LIST
33980: PUSH
33981: LD_INT 2
33983: NEG
33984: PUSH
33985: LD_INT 1
33987: NEG
33988: PUSH
33989: EMPTY
33990: LIST
33991: LIST
33992: PUSH
33993: LD_INT 2
33995: NEG
33996: PUSH
33997: LD_INT 1
33999: PUSH
34000: EMPTY
34001: LIST
34002: LIST
34003: PUSH
34004: LD_INT 3
34006: NEG
34007: PUSH
34008: LD_INT 0
34010: PUSH
34011: EMPTY
34012: LIST
34013: LIST
34014: PUSH
34015: LD_INT 3
34017: NEG
34018: PUSH
34019: LD_INT 1
34021: NEG
34022: PUSH
34023: EMPTY
34024: LIST
34025: LIST
34026: PUSH
34027: EMPTY
34028: LIST
34029: LIST
34030: LIST
34031: LIST
34032: LIST
34033: LIST
34034: LIST
34035: LIST
34036: LIST
34037: LIST
34038: LIST
34039: LIST
34040: LIST
34041: LIST
34042: LIST
34043: LIST
34044: ST_TO_ADDR
// fDepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
34045: LD_ADDR_VAR 0 13
34049: PUSH
34050: LD_INT 0
34052: PUSH
34053: LD_INT 0
34055: PUSH
34056: EMPTY
34057: LIST
34058: LIST
34059: PUSH
34060: LD_INT 0
34062: PUSH
34063: LD_INT 1
34065: NEG
34066: PUSH
34067: EMPTY
34068: LIST
34069: LIST
34070: PUSH
34071: LD_INT 1
34073: PUSH
34074: LD_INT 0
34076: PUSH
34077: EMPTY
34078: LIST
34079: LIST
34080: PUSH
34081: LD_INT 1
34083: PUSH
34084: LD_INT 1
34086: PUSH
34087: EMPTY
34088: LIST
34089: LIST
34090: PUSH
34091: LD_INT 0
34093: PUSH
34094: LD_INT 1
34096: PUSH
34097: EMPTY
34098: LIST
34099: LIST
34100: PUSH
34101: LD_INT 1
34103: NEG
34104: PUSH
34105: LD_INT 0
34107: PUSH
34108: EMPTY
34109: LIST
34110: LIST
34111: PUSH
34112: LD_INT 1
34114: NEG
34115: PUSH
34116: LD_INT 1
34118: NEG
34119: PUSH
34120: EMPTY
34121: LIST
34122: LIST
34123: PUSH
34124: LD_INT 1
34126: NEG
34127: PUSH
34128: LD_INT 2
34130: NEG
34131: PUSH
34132: EMPTY
34133: LIST
34134: LIST
34135: PUSH
34136: LD_INT 2
34138: PUSH
34139: LD_INT 1
34141: PUSH
34142: EMPTY
34143: LIST
34144: LIST
34145: PUSH
34146: LD_INT 2
34148: PUSH
34149: LD_INT 2
34151: PUSH
34152: EMPTY
34153: LIST
34154: LIST
34155: PUSH
34156: LD_INT 1
34158: PUSH
34159: LD_INT 2
34161: PUSH
34162: EMPTY
34163: LIST
34164: LIST
34165: PUSH
34166: LD_INT 2
34168: NEG
34169: PUSH
34170: LD_INT 1
34172: NEG
34173: PUSH
34174: EMPTY
34175: LIST
34176: LIST
34177: PUSH
34178: LD_INT 2
34180: NEG
34181: PUSH
34182: LD_INT 2
34184: NEG
34185: PUSH
34186: EMPTY
34187: LIST
34188: LIST
34189: PUSH
34190: LD_INT 2
34192: NEG
34193: PUSH
34194: LD_INT 3
34196: NEG
34197: PUSH
34198: EMPTY
34199: LIST
34200: LIST
34201: PUSH
34202: LD_INT 3
34204: NEG
34205: PUSH
34206: LD_INT 2
34208: NEG
34209: PUSH
34210: EMPTY
34211: LIST
34212: LIST
34213: PUSH
34214: LD_INT 3
34216: NEG
34217: PUSH
34218: LD_INT 3
34220: NEG
34221: PUSH
34222: EMPTY
34223: LIST
34224: LIST
34225: PUSH
34226: EMPTY
34227: LIST
34228: LIST
34229: LIST
34230: LIST
34231: LIST
34232: LIST
34233: LIST
34234: LIST
34235: LIST
34236: LIST
34237: LIST
34238: LIST
34239: LIST
34240: LIST
34241: LIST
34242: LIST
34243: ST_TO_ADDR
// fDepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
34244: LD_ADDR_VAR 0 14
34248: PUSH
34249: LD_INT 0
34251: PUSH
34252: LD_INT 0
34254: PUSH
34255: EMPTY
34256: LIST
34257: LIST
34258: PUSH
34259: LD_INT 0
34261: PUSH
34262: LD_INT 1
34264: NEG
34265: PUSH
34266: EMPTY
34267: LIST
34268: LIST
34269: PUSH
34270: LD_INT 1
34272: PUSH
34273: LD_INT 0
34275: PUSH
34276: EMPTY
34277: LIST
34278: LIST
34279: PUSH
34280: LD_INT 1
34282: PUSH
34283: LD_INT 1
34285: PUSH
34286: EMPTY
34287: LIST
34288: LIST
34289: PUSH
34290: LD_INT 0
34292: PUSH
34293: LD_INT 1
34295: PUSH
34296: EMPTY
34297: LIST
34298: LIST
34299: PUSH
34300: LD_INT 1
34302: NEG
34303: PUSH
34304: LD_INT 0
34306: PUSH
34307: EMPTY
34308: LIST
34309: LIST
34310: PUSH
34311: LD_INT 1
34313: NEG
34314: PUSH
34315: LD_INT 1
34317: NEG
34318: PUSH
34319: EMPTY
34320: LIST
34321: LIST
34322: PUSH
34323: LD_INT 1
34325: NEG
34326: PUSH
34327: LD_INT 2
34329: NEG
34330: PUSH
34331: EMPTY
34332: LIST
34333: LIST
34334: PUSH
34335: LD_INT 0
34337: PUSH
34338: LD_INT 2
34340: NEG
34341: PUSH
34342: EMPTY
34343: LIST
34344: LIST
34345: PUSH
34346: LD_INT 1
34348: PUSH
34349: LD_INT 1
34351: NEG
34352: PUSH
34353: EMPTY
34354: LIST
34355: LIST
34356: PUSH
34357: LD_INT 1
34359: PUSH
34360: LD_INT 2
34362: PUSH
34363: EMPTY
34364: LIST
34365: LIST
34366: PUSH
34367: LD_INT 0
34369: PUSH
34370: LD_INT 2
34372: PUSH
34373: EMPTY
34374: LIST
34375: LIST
34376: PUSH
34377: LD_INT 1
34379: NEG
34380: PUSH
34381: LD_INT 1
34383: PUSH
34384: EMPTY
34385: LIST
34386: LIST
34387: PUSH
34388: LD_INT 1
34390: NEG
34391: PUSH
34392: LD_INT 3
34394: NEG
34395: PUSH
34396: EMPTY
34397: LIST
34398: LIST
34399: PUSH
34400: LD_INT 0
34402: PUSH
34403: LD_INT 3
34405: NEG
34406: PUSH
34407: EMPTY
34408: LIST
34409: LIST
34410: PUSH
34411: LD_INT 1
34413: PUSH
34414: LD_INT 2
34416: NEG
34417: PUSH
34418: EMPTY
34419: LIST
34420: LIST
34421: PUSH
34422: EMPTY
34423: LIST
34424: LIST
34425: LIST
34426: LIST
34427: LIST
34428: LIST
34429: LIST
34430: LIST
34431: LIST
34432: LIST
34433: LIST
34434: LIST
34435: LIST
34436: LIST
34437: LIST
34438: LIST
34439: ST_TO_ADDR
// fDepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
34440: LD_ADDR_VAR 0 15
34444: PUSH
34445: LD_INT 0
34447: PUSH
34448: LD_INT 0
34450: PUSH
34451: EMPTY
34452: LIST
34453: LIST
34454: PUSH
34455: LD_INT 0
34457: PUSH
34458: LD_INT 1
34460: NEG
34461: PUSH
34462: EMPTY
34463: LIST
34464: LIST
34465: PUSH
34466: LD_INT 1
34468: PUSH
34469: LD_INT 0
34471: PUSH
34472: EMPTY
34473: LIST
34474: LIST
34475: PUSH
34476: LD_INT 1
34478: PUSH
34479: LD_INT 1
34481: PUSH
34482: EMPTY
34483: LIST
34484: LIST
34485: PUSH
34486: LD_INT 0
34488: PUSH
34489: LD_INT 1
34491: PUSH
34492: EMPTY
34493: LIST
34494: LIST
34495: PUSH
34496: LD_INT 1
34498: NEG
34499: PUSH
34500: LD_INT 0
34502: PUSH
34503: EMPTY
34504: LIST
34505: LIST
34506: PUSH
34507: LD_INT 1
34509: NEG
34510: PUSH
34511: LD_INT 1
34513: NEG
34514: PUSH
34515: EMPTY
34516: LIST
34517: LIST
34518: PUSH
34519: LD_INT 1
34521: PUSH
34522: LD_INT 1
34524: NEG
34525: PUSH
34526: EMPTY
34527: LIST
34528: LIST
34529: PUSH
34530: LD_INT 2
34532: PUSH
34533: LD_INT 0
34535: PUSH
34536: EMPTY
34537: LIST
34538: LIST
34539: PUSH
34540: LD_INT 2
34542: PUSH
34543: LD_INT 1
34545: PUSH
34546: EMPTY
34547: LIST
34548: LIST
34549: PUSH
34550: LD_INT 1
34552: NEG
34553: PUSH
34554: LD_INT 1
34556: PUSH
34557: EMPTY
34558: LIST
34559: LIST
34560: PUSH
34561: LD_INT 2
34563: NEG
34564: PUSH
34565: LD_INT 0
34567: PUSH
34568: EMPTY
34569: LIST
34570: LIST
34571: PUSH
34572: LD_INT 2
34574: NEG
34575: PUSH
34576: LD_INT 1
34578: NEG
34579: PUSH
34580: EMPTY
34581: LIST
34582: LIST
34583: PUSH
34584: LD_INT 2
34586: PUSH
34587: LD_INT 1
34589: NEG
34590: PUSH
34591: EMPTY
34592: LIST
34593: LIST
34594: PUSH
34595: LD_INT 3
34597: PUSH
34598: LD_INT 0
34600: PUSH
34601: EMPTY
34602: LIST
34603: LIST
34604: PUSH
34605: LD_INT 3
34607: PUSH
34608: LD_INT 1
34610: PUSH
34611: EMPTY
34612: LIST
34613: LIST
34614: PUSH
34615: EMPTY
34616: LIST
34617: LIST
34618: LIST
34619: LIST
34620: LIST
34621: LIST
34622: LIST
34623: LIST
34624: LIST
34625: LIST
34626: LIST
34627: LIST
34628: LIST
34629: LIST
34630: LIST
34631: LIST
34632: ST_TO_ADDR
// fDepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
34633: LD_ADDR_VAR 0 16
34637: PUSH
34638: LD_INT 0
34640: PUSH
34641: LD_INT 0
34643: PUSH
34644: EMPTY
34645: LIST
34646: LIST
34647: PUSH
34648: LD_INT 0
34650: PUSH
34651: LD_INT 1
34653: NEG
34654: PUSH
34655: EMPTY
34656: LIST
34657: LIST
34658: PUSH
34659: LD_INT 1
34661: PUSH
34662: LD_INT 0
34664: PUSH
34665: EMPTY
34666: LIST
34667: LIST
34668: PUSH
34669: LD_INT 1
34671: PUSH
34672: LD_INT 1
34674: PUSH
34675: EMPTY
34676: LIST
34677: LIST
34678: PUSH
34679: LD_INT 0
34681: PUSH
34682: LD_INT 1
34684: PUSH
34685: EMPTY
34686: LIST
34687: LIST
34688: PUSH
34689: LD_INT 1
34691: NEG
34692: PUSH
34693: LD_INT 0
34695: PUSH
34696: EMPTY
34697: LIST
34698: LIST
34699: PUSH
34700: LD_INT 1
34702: NEG
34703: PUSH
34704: LD_INT 1
34706: NEG
34707: PUSH
34708: EMPTY
34709: LIST
34710: LIST
34711: PUSH
34712: LD_INT 1
34714: NEG
34715: PUSH
34716: LD_INT 2
34718: NEG
34719: PUSH
34720: EMPTY
34721: LIST
34722: LIST
34723: PUSH
34724: LD_INT 2
34726: PUSH
34727: LD_INT 1
34729: PUSH
34730: EMPTY
34731: LIST
34732: LIST
34733: PUSH
34734: LD_INT 2
34736: PUSH
34737: LD_INT 2
34739: PUSH
34740: EMPTY
34741: LIST
34742: LIST
34743: PUSH
34744: LD_INT 1
34746: PUSH
34747: LD_INT 2
34749: PUSH
34750: EMPTY
34751: LIST
34752: LIST
34753: PUSH
34754: LD_INT 2
34756: NEG
34757: PUSH
34758: LD_INT 1
34760: NEG
34761: PUSH
34762: EMPTY
34763: LIST
34764: LIST
34765: PUSH
34766: LD_INT 2
34768: NEG
34769: PUSH
34770: LD_INT 2
34772: NEG
34773: PUSH
34774: EMPTY
34775: LIST
34776: LIST
34777: PUSH
34778: LD_INT 3
34780: PUSH
34781: LD_INT 2
34783: PUSH
34784: EMPTY
34785: LIST
34786: LIST
34787: PUSH
34788: LD_INT 3
34790: PUSH
34791: LD_INT 3
34793: PUSH
34794: EMPTY
34795: LIST
34796: LIST
34797: PUSH
34798: LD_INT 2
34800: PUSH
34801: LD_INT 3
34803: PUSH
34804: EMPTY
34805: LIST
34806: LIST
34807: PUSH
34808: EMPTY
34809: LIST
34810: LIST
34811: LIST
34812: LIST
34813: LIST
34814: LIST
34815: LIST
34816: LIST
34817: LIST
34818: LIST
34819: LIST
34820: LIST
34821: LIST
34822: LIST
34823: LIST
34824: LIST
34825: ST_TO_ADDR
// fDepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
34826: LD_ADDR_VAR 0 17
34830: PUSH
34831: LD_INT 0
34833: PUSH
34834: LD_INT 0
34836: PUSH
34837: EMPTY
34838: LIST
34839: LIST
34840: PUSH
34841: LD_INT 0
34843: PUSH
34844: LD_INT 1
34846: NEG
34847: PUSH
34848: EMPTY
34849: LIST
34850: LIST
34851: PUSH
34852: LD_INT 1
34854: PUSH
34855: LD_INT 0
34857: PUSH
34858: EMPTY
34859: LIST
34860: LIST
34861: PUSH
34862: LD_INT 1
34864: PUSH
34865: LD_INT 1
34867: PUSH
34868: EMPTY
34869: LIST
34870: LIST
34871: PUSH
34872: LD_INT 0
34874: PUSH
34875: LD_INT 1
34877: PUSH
34878: EMPTY
34879: LIST
34880: LIST
34881: PUSH
34882: LD_INT 1
34884: NEG
34885: PUSH
34886: LD_INT 0
34888: PUSH
34889: EMPTY
34890: LIST
34891: LIST
34892: PUSH
34893: LD_INT 1
34895: NEG
34896: PUSH
34897: LD_INT 1
34899: NEG
34900: PUSH
34901: EMPTY
34902: LIST
34903: LIST
34904: PUSH
34905: LD_INT 1
34907: NEG
34908: PUSH
34909: LD_INT 2
34911: NEG
34912: PUSH
34913: EMPTY
34914: LIST
34915: LIST
34916: PUSH
34917: LD_INT 0
34919: PUSH
34920: LD_INT 2
34922: NEG
34923: PUSH
34924: EMPTY
34925: LIST
34926: LIST
34927: PUSH
34928: LD_INT 1
34930: PUSH
34931: LD_INT 1
34933: NEG
34934: PUSH
34935: EMPTY
34936: LIST
34937: LIST
34938: PUSH
34939: LD_INT 2
34941: PUSH
34942: LD_INT 0
34944: PUSH
34945: EMPTY
34946: LIST
34947: LIST
34948: PUSH
34949: LD_INT 2
34951: PUSH
34952: LD_INT 1
34954: PUSH
34955: EMPTY
34956: LIST
34957: LIST
34958: PUSH
34959: LD_INT 2
34961: PUSH
34962: LD_INT 2
34964: PUSH
34965: EMPTY
34966: LIST
34967: LIST
34968: PUSH
34969: LD_INT 1
34971: PUSH
34972: LD_INT 2
34974: PUSH
34975: EMPTY
34976: LIST
34977: LIST
34978: PUSH
34979: LD_INT 0
34981: PUSH
34982: LD_INT 2
34984: PUSH
34985: EMPTY
34986: LIST
34987: LIST
34988: PUSH
34989: LD_INT 1
34991: NEG
34992: PUSH
34993: LD_INT 1
34995: PUSH
34996: EMPTY
34997: LIST
34998: LIST
34999: PUSH
35000: LD_INT 2
35002: NEG
35003: PUSH
35004: LD_INT 0
35006: PUSH
35007: EMPTY
35008: LIST
35009: LIST
35010: PUSH
35011: LD_INT 2
35013: NEG
35014: PUSH
35015: LD_INT 1
35017: NEG
35018: PUSH
35019: EMPTY
35020: LIST
35021: LIST
35022: PUSH
35023: LD_INT 2
35025: NEG
35026: PUSH
35027: LD_INT 2
35029: NEG
35030: PUSH
35031: EMPTY
35032: LIST
35033: LIST
35034: PUSH
35035: EMPTY
35036: LIST
35037: LIST
35038: LIST
35039: LIST
35040: LIST
35041: LIST
35042: LIST
35043: LIST
35044: LIST
35045: LIST
35046: LIST
35047: LIST
35048: LIST
35049: LIST
35050: LIST
35051: LIST
35052: LIST
35053: LIST
35054: LIST
35055: ST_TO_ADDR
// fDepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
35056: LD_ADDR_VAR 0 18
35060: PUSH
35061: LD_INT 0
35063: PUSH
35064: LD_INT 0
35066: PUSH
35067: EMPTY
35068: LIST
35069: LIST
35070: PUSH
35071: LD_INT 0
35073: PUSH
35074: LD_INT 1
35076: NEG
35077: PUSH
35078: EMPTY
35079: LIST
35080: LIST
35081: PUSH
35082: LD_INT 1
35084: PUSH
35085: LD_INT 0
35087: PUSH
35088: EMPTY
35089: LIST
35090: LIST
35091: PUSH
35092: LD_INT 1
35094: PUSH
35095: LD_INT 1
35097: PUSH
35098: EMPTY
35099: LIST
35100: LIST
35101: PUSH
35102: LD_INT 0
35104: PUSH
35105: LD_INT 1
35107: PUSH
35108: EMPTY
35109: LIST
35110: LIST
35111: PUSH
35112: LD_INT 1
35114: NEG
35115: PUSH
35116: LD_INT 0
35118: PUSH
35119: EMPTY
35120: LIST
35121: LIST
35122: PUSH
35123: LD_INT 1
35125: NEG
35126: PUSH
35127: LD_INT 1
35129: NEG
35130: PUSH
35131: EMPTY
35132: LIST
35133: LIST
35134: PUSH
35135: LD_INT 1
35137: NEG
35138: PUSH
35139: LD_INT 2
35141: NEG
35142: PUSH
35143: EMPTY
35144: LIST
35145: LIST
35146: PUSH
35147: LD_INT 0
35149: PUSH
35150: LD_INT 2
35152: NEG
35153: PUSH
35154: EMPTY
35155: LIST
35156: LIST
35157: PUSH
35158: LD_INT 1
35160: PUSH
35161: LD_INT 1
35163: NEG
35164: PUSH
35165: EMPTY
35166: LIST
35167: LIST
35168: PUSH
35169: LD_INT 2
35171: PUSH
35172: LD_INT 0
35174: PUSH
35175: EMPTY
35176: LIST
35177: LIST
35178: PUSH
35179: LD_INT 2
35181: PUSH
35182: LD_INT 1
35184: PUSH
35185: EMPTY
35186: LIST
35187: LIST
35188: PUSH
35189: LD_INT 2
35191: PUSH
35192: LD_INT 2
35194: PUSH
35195: EMPTY
35196: LIST
35197: LIST
35198: PUSH
35199: LD_INT 1
35201: PUSH
35202: LD_INT 2
35204: PUSH
35205: EMPTY
35206: LIST
35207: LIST
35208: PUSH
35209: LD_INT 0
35211: PUSH
35212: LD_INT 2
35214: PUSH
35215: EMPTY
35216: LIST
35217: LIST
35218: PUSH
35219: LD_INT 1
35221: NEG
35222: PUSH
35223: LD_INT 1
35225: PUSH
35226: EMPTY
35227: LIST
35228: LIST
35229: PUSH
35230: LD_INT 2
35232: NEG
35233: PUSH
35234: LD_INT 0
35236: PUSH
35237: EMPTY
35238: LIST
35239: LIST
35240: PUSH
35241: LD_INT 2
35243: NEG
35244: PUSH
35245: LD_INT 1
35247: NEG
35248: PUSH
35249: EMPTY
35250: LIST
35251: LIST
35252: PUSH
35253: LD_INT 2
35255: NEG
35256: PUSH
35257: LD_INT 2
35259: NEG
35260: PUSH
35261: EMPTY
35262: LIST
35263: LIST
35264: PUSH
35265: EMPTY
35266: LIST
35267: LIST
35268: LIST
35269: LIST
35270: LIST
35271: LIST
35272: LIST
35273: LIST
35274: LIST
35275: LIST
35276: LIST
35277: LIST
35278: LIST
35279: LIST
35280: LIST
35281: LIST
35282: LIST
35283: LIST
35284: LIST
35285: ST_TO_ADDR
// fDepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
35286: LD_ADDR_VAR 0 19
35290: PUSH
35291: LD_INT 0
35293: PUSH
35294: LD_INT 0
35296: PUSH
35297: EMPTY
35298: LIST
35299: LIST
35300: PUSH
35301: LD_INT 0
35303: PUSH
35304: LD_INT 1
35306: NEG
35307: PUSH
35308: EMPTY
35309: LIST
35310: LIST
35311: PUSH
35312: LD_INT 1
35314: PUSH
35315: LD_INT 0
35317: PUSH
35318: EMPTY
35319: LIST
35320: LIST
35321: PUSH
35322: LD_INT 1
35324: PUSH
35325: LD_INT 1
35327: PUSH
35328: EMPTY
35329: LIST
35330: LIST
35331: PUSH
35332: LD_INT 0
35334: PUSH
35335: LD_INT 1
35337: PUSH
35338: EMPTY
35339: LIST
35340: LIST
35341: PUSH
35342: LD_INT 1
35344: NEG
35345: PUSH
35346: LD_INT 0
35348: PUSH
35349: EMPTY
35350: LIST
35351: LIST
35352: PUSH
35353: LD_INT 1
35355: NEG
35356: PUSH
35357: LD_INT 1
35359: NEG
35360: PUSH
35361: EMPTY
35362: LIST
35363: LIST
35364: PUSH
35365: LD_INT 1
35367: NEG
35368: PUSH
35369: LD_INT 2
35371: NEG
35372: PUSH
35373: EMPTY
35374: LIST
35375: LIST
35376: PUSH
35377: LD_INT 0
35379: PUSH
35380: LD_INT 2
35382: NEG
35383: PUSH
35384: EMPTY
35385: LIST
35386: LIST
35387: PUSH
35388: LD_INT 1
35390: PUSH
35391: LD_INT 1
35393: NEG
35394: PUSH
35395: EMPTY
35396: LIST
35397: LIST
35398: PUSH
35399: LD_INT 2
35401: PUSH
35402: LD_INT 0
35404: PUSH
35405: EMPTY
35406: LIST
35407: LIST
35408: PUSH
35409: LD_INT 2
35411: PUSH
35412: LD_INT 1
35414: PUSH
35415: EMPTY
35416: LIST
35417: LIST
35418: PUSH
35419: LD_INT 2
35421: PUSH
35422: LD_INT 2
35424: PUSH
35425: EMPTY
35426: LIST
35427: LIST
35428: PUSH
35429: LD_INT 1
35431: PUSH
35432: LD_INT 2
35434: PUSH
35435: EMPTY
35436: LIST
35437: LIST
35438: PUSH
35439: LD_INT 0
35441: PUSH
35442: LD_INT 2
35444: PUSH
35445: EMPTY
35446: LIST
35447: LIST
35448: PUSH
35449: LD_INT 1
35451: NEG
35452: PUSH
35453: LD_INT 1
35455: PUSH
35456: EMPTY
35457: LIST
35458: LIST
35459: PUSH
35460: LD_INT 2
35462: NEG
35463: PUSH
35464: LD_INT 0
35466: PUSH
35467: EMPTY
35468: LIST
35469: LIST
35470: PUSH
35471: LD_INT 2
35473: NEG
35474: PUSH
35475: LD_INT 1
35477: NEG
35478: PUSH
35479: EMPTY
35480: LIST
35481: LIST
35482: PUSH
35483: LD_INT 2
35485: NEG
35486: PUSH
35487: LD_INT 2
35489: NEG
35490: PUSH
35491: EMPTY
35492: LIST
35493: LIST
35494: PUSH
35495: EMPTY
35496: LIST
35497: LIST
35498: LIST
35499: LIST
35500: LIST
35501: LIST
35502: LIST
35503: LIST
35504: LIST
35505: LIST
35506: LIST
35507: LIST
35508: LIST
35509: LIST
35510: LIST
35511: LIST
35512: LIST
35513: LIST
35514: LIST
35515: ST_TO_ADDR
// fDepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
35516: LD_ADDR_VAR 0 20
35520: PUSH
35521: LD_INT 0
35523: PUSH
35524: LD_INT 0
35526: PUSH
35527: EMPTY
35528: LIST
35529: LIST
35530: PUSH
35531: LD_INT 0
35533: PUSH
35534: LD_INT 1
35536: NEG
35537: PUSH
35538: EMPTY
35539: LIST
35540: LIST
35541: PUSH
35542: LD_INT 1
35544: PUSH
35545: LD_INT 0
35547: PUSH
35548: EMPTY
35549: LIST
35550: LIST
35551: PUSH
35552: LD_INT 1
35554: PUSH
35555: LD_INT 1
35557: PUSH
35558: EMPTY
35559: LIST
35560: LIST
35561: PUSH
35562: LD_INT 0
35564: PUSH
35565: LD_INT 1
35567: PUSH
35568: EMPTY
35569: LIST
35570: LIST
35571: PUSH
35572: LD_INT 1
35574: NEG
35575: PUSH
35576: LD_INT 0
35578: PUSH
35579: EMPTY
35580: LIST
35581: LIST
35582: PUSH
35583: LD_INT 1
35585: NEG
35586: PUSH
35587: LD_INT 1
35589: NEG
35590: PUSH
35591: EMPTY
35592: LIST
35593: LIST
35594: PUSH
35595: LD_INT 1
35597: NEG
35598: PUSH
35599: LD_INT 2
35601: NEG
35602: PUSH
35603: EMPTY
35604: LIST
35605: LIST
35606: PUSH
35607: LD_INT 0
35609: PUSH
35610: LD_INT 2
35612: NEG
35613: PUSH
35614: EMPTY
35615: LIST
35616: LIST
35617: PUSH
35618: LD_INT 1
35620: PUSH
35621: LD_INT 1
35623: NEG
35624: PUSH
35625: EMPTY
35626: LIST
35627: LIST
35628: PUSH
35629: LD_INT 2
35631: PUSH
35632: LD_INT 0
35634: PUSH
35635: EMPTY
35636: LIST
35637: LIST
35638: PUSH
35639: LD_INT 2
35641: PUSH
35642: LD_INT 1
35644: PUSH
35645: EMPTY
35646: LIST
35647: LIST
35648: PUSH
35649: LD_INT 2
35651: PUSH
35652: LD_INT 2
35654: PUSH
35655: EMPTY
35656: LIST
35657: LIST
35658: PUSH
35659: LD_INT 1
35661: PUSH
35662: LD_INT 2
35664: PUSH
35665: EMPTY
35666: LIST
35667: LIST
35668: PUSH
35669: LD_INT 0
35671: PUSH
35672: LD_INT 2
35674: PUSH
35675: EMPTY
35676: LIST
35677: LIST
35678: PUSH
35679: LD_INT 1
35681: NEG
35682: PUSH
35683: LD_INT 1
35685: PUSH
35686: EMPTY
35687: LIST
35688: LIST
35689: PUSH
35690: LD_INT 2
35692: NEG
35693: PUSH
35694: LD_INT 0
35696: PUSH
35697: EMPTY
35698: LIST
35699: LIST
35700: PUSH
35701: LD_INT 2
35703: NEG
35704: PUSH
35705: LD_INT 1
35707: NEG
35708: PUSH
35709: EMPTY
35710: LIST
35711: LIST
35712: PUSH
35713: LD_INT 2
35715: NEG
35716: PUSH
35717: LD_INT 2
35719: NEG
35720: PUSH
35721: EMPTY
35722: LIST
35723: LIST
35724: PUSH
35725: EMPTY
35726: LIST
35727: LIST
35728: LIST
35729: LIST
35730: LIST
35731: LIST
35732: LIST
35733: LIST
35734: LIST
35735: LIST
35736: LIST
35737: LIST
35738: LIST
35739: LIST
35740: LIST
35741: LIST
35742: LIST
35743: LIST
35744: LIST
35745: ST_TO_ADDR
// fDepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
35746: LD_ADDR_VAR 0 21
35750: PUSH
35751: LD_INT 0
35753: PUSH
35754: LD_INT 0
35756: PUSH
35757: EMPTY
35758: LIST
35759: LIST
35760: PUSH
35761: LD_INT 0
35763: PUSH
35764: LD_INT 1
35766: NEG
35767: PUSH
35768: EMPTY
35769: LIST
35770: LIST
35771: PUSH
35772: LD_INT 1
35774: PUSH
35775: LD_INT 0
35777: PUSH
35778: EMPTY
35779: LIST
35780: LIST
35781: PUSH
35782: LD_INT 1
35784: PUSH
35785: LD_INT 1
35787: PUSH
35788: EMPTY
35789: LIST
35790: LIST
35791: PUSH
35792: LD_INT 0
35794: PUSH
35795: LD_INT 1
35797: PUSH
35798: EMPTY
35799: LIST
35800: LIST
35801: PUSH
35802: LD_INT 1
35804: NEG
35805: PUSH
35806: LD_INT 0
35808: PUSH
35809: EMPTY
35810: LIST
35811: LIST
35812: PUSH
35813: LD_INT 1
35815: NEG
35816: PUSH
35817: LD_INT 1
35819: NEG
35820: PUSH
35821: EMPTY
35822: LIST
35823: LIST
35824: PUSH
35825: LD_INT 1
35827: NEG
35828: PUSH
35829: LD_INT 2
35831: NEG
35832: PUSH
35833: EMPTY
35834: LIST
35835: LIST
35836: PUSH
35837: LD_INT 0
35839: PUSH
35840: LD_INT 2
35842: NEG
35843: PUSH
35844: EMPTY
35845: LIST
35846: LIST
35847: PUSH
35848: LD_INT 1
35850: PUSH
35851: LD_INT 1
35853: NEG
35854: PUSH
35855: EMPTY
35856: LIST
35857: LIST
35858: PUSH
35859: LD_INT 2
35861: PUSH
35862: LD_INT 0
35864: PUSH
35865: EMPTY
35866: LIST
35867: LIST
35868: PUSH
35869: LD_INT 2
35871: PUSH
35872: LD_INT 1
35874: PUSH
35875: EMPTY
35876: LIST
35877: LIST
35878: PUSH
35879: LD_INT 2
35881: PUSH
35882: LD_INT 2
35884: PUSH
35885: EMPTY
35886: LIST
35887: LIST
35888: PUSH
35889: LD_INT 1
35891: PUSH
35892: LD_INT 2
35894: PUSH
35895: EMPTY
35896: LIST
35897: LIST
35898: PUSH
35899: LD_INT 0
35901: PUSH
35902: LD_INT 2
35904: PUSH
35905: EMPTY
35906: LIST
35907: LIST
35908: PUSH
35909: LD_INT 1
35911: NEG
35912: PUSH
35913: LD_INT 1
35915: PUSH
35916: EMPTY
35917: LIST
35918: LIST
35919: PUSH
35920: LD_INT 2
35922: NEG
35923: PUSH
35924: LD_INT 0
35926: PUSH
35927: EMPTY
35928: LIST
35929: LIST
35930: PUSH
35931: LD_INT 2
35933: NEG
35934: PUSH
35935: LD_INT 1
35937: NEG
35938: PUSH
35939: EMPTY
35940: LIST
35941: LIST
35942: PUSH
35943: LD_INT 2
35945: NEG
35946: PUSH
35947: LD_INT 2
35949: NEG
35950: PUSH
35951: EMPTY
35952: LIST
35953: LIST
35954: PUSH
35955: EMPTY
35956: LIST
35957: LIST
35958: LIST
35959: LIST
35960: LIST
35961: LIST
35962: LIST
35963: LIST
35964: LIST
35965: LIST
35966: LIST
35967: LIST
35968: LIST
35969: LIST
35970: LIST
35971: LIST
35972: LIST
35973: LIST
35974: LIST
35975: ST_TO_ADDR
// fDepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
35976: LD_ADDR_VAR 0 22
35980: PUSH
35981: LD_INT 0
35983: PUSH
35984: LD_INT 0
35986: PUSH
35987: EMPTY
35988: LIST
35989: LIST
35990: PUSH
35991: LD_INT 0
35993: PUSH
35994: LD_INT 1
35996: NEG
35997: PUSH
35998: EMPTY
35999: LIST
36000: LIST
36001: PUSH
36002: LD_INT 1
36004: PUSH
36005: LD_INT 0
36007: PUSH
36008: EMPTY
36009: LIST
36010: LIST
36011: PUSH
36012: LD_INT 1
36014: PUSH
36015: LD_INT 1
36017: PUSH
36018: EMPTY
36019: LIST
36020: LIST
36021: PUSH
36022: LD_INT 0
36024: PUSH
36025: LD_INT 1
36027: PUSH
36028: EMPTY
36029: LIST
36030: LIST
36031: PUSH
36032: LD_INT 1
36034: NEG
36035: PUSH
36036: LD_INT 0
36038: PUSH
36039: EMPTY
36040: LIST
36041: LIST
36042: PUSH
36043: LD_INT 1
36045: NEG
36046: PUSH
36047: LD_INT 1
36049: NEG
36050: PUSH
36051: EMPTY
36052: LIST
36053: LIST
36054: PUSH
36055: LD_INT 1
36057: NEG
36058: PUSH
36059: LD_INT 2
36061: NEG
36062: PUSH
36063: EMPTY
36064: LIST
36065: LIST
36066: PUSH
36067: LD_INT 0
36069: PUSH
36070: LD_INT 2
36072: NEG
36073: PUSH
36074: EMPTY
36075: LIST
36076: LIST
36077: PUSH
36078: LD_INT 1
36080: PUSH
36081: LD_INT 1
36083: NEG
36084: PUSH
36085: EMPTY
36086: LIST
36087: LIST
36088: PUSH
36089: LD_INT 2
36091: PUSH
36092: LD_INT 0
36094: PUSH
36095: EMPTY
36096: LIST
36097: LIST
36098: PUSH
36099: LD_INT 2
36101: PUSH
36102: LD_INT 1
36104: PUSH
36105: EMPTY
36106: LIST
36107: LIST
36108: PUSH
36109: LD_INT 2
36111: PUSH
36112: LD_INT 2
36114: PUSH
36115: EMPTY
36116: LIST
36117: LIST
36118: PUSH
36119: LD_INT 1
36121: PUSH
36122: LD_INT 2
36124: PUSH
36125: EMPTY
36126: LIST
36127: LIST
36128: PUSH
36129: LD_INT 0
36131: PUSH
36132: LD_INT 2
36134: PUSH
36135: EMPTY
36136: LIST
36137: LIST
36138: PUSH
36139: LD_INT 1
36141: NEG
36142: PUSH
36143: LD_INT 1
36145: PUSH
36146: EMPTY
36147: LIST
36148: LIST
36149: PUSH
36150: LD_INT 2
36152: NEG
36153: PUSH
36154: LD_INT 0
36156: PUSH
36157: EMPTY
36158: LIST
36159: LIST
36160: PUSH
36161: LD_INT 2
36163: NEG
36164: PUSH
36165: LD_INT 1
36167: NEG
36168: PUSH
36169: EMPTY
36170: LIST
36171: LIST
36172: PUSH
36173: LD_INT 2
36175: NEG
36176: PUSH
36177: LD_INT 2
36179: NEG
36180: PUSH
36181: EMPTY
36182: LIST
36183: LIST
36184: PUSH
36185: EMPTY
36186: LIST
36187: LIST
36188: LIST
36189: LIST
36190: LIST
36191: LIST
36192: LIST
36193: LIST
36194: LIST
36195: LIST
36196: LIST
36197: LIST
36198: LIST
36199: LIST
36200: LIST
36201: LIST
36202: LIST
36203: LIST
36204: LIST
36205: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
36206: LD_ADDR_VAR 0 23
36210: PUSH
36211: LD_INT 0
36213: PUSH
36214: LD_INT 0
36216: PUSH
36217: EMPTY
36218: LIST
36219: LIST
36220: PUSH
36221: LD_INT 0
36223: PUSH
36224: LD_INT 1
36226: NEG
36227: PUSH
36228: EMPTY
36229: LIST
36230: LIST
36231: PUSH
36232: LD_INT 1
36234: PUSH
36235: LD_INT 0
36237: PUSH
36238: EMPTY
36239: LIST
36240: LIST
36241: PUSH
36242: LD_INT 1
36244: PUSH
36245: LD_INT 1
36247: PUSH
36248: EMPTY
36249: LIST
36250: LIST
36251: PUSH
36252: LD_INT 0
36254: PUSH
36255: LD_INT 1
36257: PUSH
36258: EMPTY
36259: LIST
36260: LIST
36261: PUSH
36262: LD_INT 1
36264: NEG
36265: PUSH
36266: LD_INT 0
36268: PUSH
36269: EMPTY
36270: LIST
36271: LIST
36272: PUSH
36273: LD_INT 1
36275: NEG
36276: PUSH
36277: LD_INT 1
36279: NEG
36280: PUSH
36281: EMPTY
36282: LIST
36283: LIST
36284: PUSH
36285: LD_INT 1
36287: NEG
36288: PUSH
36289: LD_INT 2
36291: NEG
36292: PUSH
36293: EMPTY
36294: LIST
36295: LIST
36296: PUSH
36297: LD_INT 0
36299: PUSH
36300: LD_INT 2
36302: NEG
36303: PUSH
36304: EMPTY
36305: LIST
36306: LIST
36307: PUSH
36308: LD_INT 1
36310: PUSH
36311: LD_INT 1
36313: NEG
36314: PUSH
36315: EMPTY
36316: LIST
36317: LIST
36318: PUSH
36319: LD_INT 2
36321: PUSH
36322: LD_INT 0
36324: PUSH
36325: EMPTY
36326: LIST
36327: LIST
36328: PUSH
36329: LD_INT 2
36331: PUSH
36332: LD_INT 1
36334: PUSH
36335: EMPTY
36336: LIST
36337: LIST
36338: PUSH
36339: LD_INT 2
36341: PUSH
36342: LD_INT 2
36344: PUSH
36345: EMPTY
36346: LIST
36347: LIST
36348: PUSH
36349: LD_INT 1
36351: PUSH
36352: LD_INT 2
36354: PUSH
36355: EMPTY
36356: LIST
36357: LIST
36358: PUSH
36359: LD_INT 0
36361: PUSH
36362: LD_INT 2
36364: PUSH
36365: EMPTY
36366: LIST
36367: LIST
36368: PUSH
36369: LD_INT 1
36371: NEG
36372: PUSH
36373: LD_INT 1
36375: PUSH
36376: EMPTY
36377: LIST
36378: LIST
36379: PUSH
36380: LD_INT 2
36382: NEG
36383: PUSH
36384: LD_INT 0
36386: PUSH
36387: EMPTY
36388: LIST
36389: LIST
36390: PUSH
36391: LD_INT 2
36393: NEG
36394: PUSH
36395: LD_INT 1
36397: NEG
36398: PUSH
36399: EMPTY
36400: LIST
36401: LIST
36402: PUSH
36403: LD_INT 2
36405: NEG
36406: PUSH
36407: LD_INT 2
36409: NEG
36410: PUSH
36411: EMPTY
36412: LIST
36413: LIST
36414: PUSH
36415: LD_INT 2
36417: NEG
36418: PUSH
36419: LD_INT 3
36421: NEG
36422: PUSH
36423: EMPTY
36424: LIST
36425: LIST
36426: PUSH
36427: LD_INT 1
36429: NEG
36430: PUSH
36431: LD_INT 3
36433: NEG
36434: PUSH
36435: EMPTY
36436: LIST
36437: LIST
36438: PUSH
36439: LD_INT 1
36441: PUSH
36442: LD_INT 2
36444: NEG
36445: PUSH
36446: EMPTY
36447: LIST
36448: LIST
36449: PUSH
36450: LD_INT 2
36452: PUSH
36453: LD_INT 1
36455: NEG
36456: PUSH
36457: EMPTY
36458: LIST
36459: LIST
36460: PUSH
36461: EMPTY
36462: LIST
36463: LIST
36464: LIST
36465: LIST
36466: LIST
36467: LIST
36468: LIST
36469: LIST
36470: LIST
36471: LIST
36472: LIST
36473: LIST
36474: LIST
36475: LIST
36476: LIST
36477: LIST
36478: LIST
36479: LIST
36480: LIST
36481: LIST
36482: LIST
36483: LIST
36484: LIST
36485: ST_TO_ADDR
// fDepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
36486: LD_ADDR_VAR 0 24
36490: PUSH
36491: LD_INT 0
36493: PUSH
36494: LD_INT 0
36496: PUSH
36497: EMPTY
36498: LIST
36499: LIST
36500: PUSH
36501: LD_INT 0
36503: PUSH
36504: LD_INT 1
36506: NEG
36507: PUSH
36508: EMPTY
36509: LIST
36510: LIST
36511: PUSH
36512: LD_INT 1
36514: PUSH
36515: LD_INT 0
36517: PUSH
36518: EMPTY
36519: LIST
36520: LIST
36521: PUSH
36522: LD_INT 1
36524: PUSH
36525: LD_INT 1
36527: PUSH
36528: EMPTY
36529: LIST
36530: LIST
36531: PUSH
36532: LD_INT 0
36534: PUSH
36535: LD_INT 1
36537: PUSH
36538: EMPTY
36539: LIST
36540: LIST
36541: PUSH
36542: LD_INT 1
36544: NEG
36545: PUSH
36546: LD_INT 0
36548: PUSH
36549: EMPTY
36550: LIST
36551: LIST
36552: PUSH
36553: LD_INT 1
36555: NEG
36556: PUSH
36557: LD_INT 1
36559: NEG
36560: PUSH
36561: EMPTY
36562: LIST
36563: LIST
36564: PUSH
36565: LD_INT 1
36567: NEG
36568: PUSH
36569: LD_INT 2
36571: NEG
36572: PUSH
36573: EMPTY
36574: LIST
36575: LIST
36576: PUSH
36577: LD_INT 0
36579: PUSH
36580: LD_INT 2
36582: NEG
36583: PUSH
36584: EMPTY
36585: LIST
36586: LIST
36587: PUSH
36588: LD_INT 1
36590: PUSH
36591: LD_INT 1
36593: NEG
36594: PUSH
36595: EMPTY
36596: LIST
36597: LIST
36598: PUSH
36599: LD_INT 2
36601: PUSH
36602: LD_INT 0
36604: PUSH
36605: EMPTY
36606: LIST
36607: LIST
36608: PUSH
36609: LD_INT 2
36611: PUSH
36612: LD_INT 1
36614: PUSH
36615: EMPTY
36616: LIST
36617: LIST
36618: PUSH
36619: LD_INT 2
36621: PUSH
36622: LD_INT 2
36624: PUSH
36625: EMPTY
36626: LIST
36627: LIST
36628: PUSH
36629: LD_INT 1
36631: PUSH
36632: LD_INT 2
36634: PUSH
36635: EMPTY
36636: LIST
36637: LIST
36638: PUSH
36639: LD_INT 0
36641: PUSH
36642: LD_INT 2
36644: PUSH
36645: EMPTY
36646: LIST
36647: LIST
36648: PUSH
36649: LD_INT 1
36651: NEG
36652: PUSH
36653: LD_INT 1
36655: PUSH
36656: EMPTY
36657: LIST
36658: LIST
36659: PUSH
36660: LD_INT 2
36662: NEG
36663: PUSH
36664: LD_INT 0
36666: PUSH
36667: EMPTY
36668: LIST
36669: LIST
36670: PUSH
36671: LD_INT 2
36673: NEG
36674: PUSH
36675: LD_INT 1
36677: NEG
36678: PUSH
36679: EMPTY
36680: LIST
36681: LIST
36682: PUSH
36683: LD_INT 2
36685: NEG
36686: PUSH
36687: LD_INT 2
36689: NEG
36690: PUSH
36691: EMPTY
36692: LIST
36693: LIST
36694: PUSH
36695: LD_INT 1
36697: PUSH
36698: LD_INT 2
36700: NEG
36701: PUSH
36702: EMPTY
36703: LIST
36704: LIST
36705: PUSH
36706: LD_INT 2
36708: PUSH
36709: LD_INT 1
36711: NEG
36712: PUSH
36713: EMPTY
36714: LIST
36715: LIST
36716: PUSH
36717: LD_INT 3
36719: PUSH
36720: LD_INT 1
36722: PUSH
36723: EMPTY
36724: LIST
36725: LIST
36726: PUSH
36727: LD_INT 3
36729: PUSH
36730: LD_INT 2
36732: PUSH
36733: EMPTY
36734: LIST
36735: LIST
36736: PUSH
36737: EMPTY
36738: LIST
36739: LIST
36740: LIST
36741: LIST
36742: LIST
36743: LIST
36744: LIST
36745: LIST
36746: LIST
36747: LIST
36748: LIST
36749: LIST
36750: LIST
36751: LIST
36752: LIST
36753: LIST
36754: LIST
36755: LIST
36756: LIST
36757: LIST
36758: LIST
36759: LIST
36760: LIST
36761: ST_TO_ADDR
// fDepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
36762: LD_ADDR_VAR 0 25
36766: PUSH
36767: LD_INT 0
36769: PUSH
36770: LD_INT 0
36772: PUSH
36773: EMPTY
36774: LIST
36775: LIST
36776: PUSH
36777: LD_INT 0
36779: PUSH
36780: LD_INT 1
36782: NEG
36783: PUSH
36784: EMPTY
36785: LIST
36786: LIST
36787: PUSH
36788: LD_INT 1
36790: PUSH
36791: LD_INT 0
36793: PUSH
36794: EMPTY
36795: LIST
36796: LIST
36797: PUSH
36798: LD_INT 1
36800: PUSH
36801: LD_INT 1
36803: PUSH
36804: EMPTY
36805: LIST
36806: LIST
36807: PUSH
36808: LD_INT 0
36810: PUSH
36811: LD_INT 1
36813: PUSH
36814: EMPTY
36815: LIST
36816: LIST
36817: PUSH
36818: LD_INT 1
36820: NEG
36821: PUSH
36822: LD_INT 0
36824: PUSH
36825: EMPTY
36826: LIST
36827: LIST
36828: PUSH
36829: LD_INT 1
36831: NEG
36832: PUSH
36833: LD_INT 1
36835: NEG
36836: PUSH
36837: EMPTY
36838: LIST
36839: LIST
36840: PUSH
36841: LD_INT 1
36843: NEG
36844: PUSH
36845: LD_INT 2
36847: NEG
36848: PUSH
36849: EMPTY
36850: LIST
36851: LIST
36852: PUSH
36853: LD_INT 0
36855: PUSH
36856: LD_INT 2
36858: NEG
36859: PUSH
36860: EMPTY
36861: LIST
36862: LIST
36863: PUSH
36864: LD_INT 1
36866: PUSH
36867: LD_INT 1
36869: NEG
36870: PUSH
36871: EMPTY
36872: LIST
36873: LIST
36874: PUSH
36875: LD_INT 2
36877: PUSH
36878: LD_INT 0
36880: PUSH
36881: EMPTY
36882: LIST
36883: LIST
36884: PUSH
36885: LD_INT 2
36887: PUSH
36888: LD_INT 1
36890: PUSH
36891: EMPTY
36892: LIST
36893: LIST
36894: PUSH
36895: LD_INT 2
36897: PUSH
36898: LD_INT 2
36900: PUSH
36901: EMPTY
36902: LIST
36903: LIST
36904: PUSH
36905: LD_INT 1
36907: PUSH
36908: LD_INT 2
36910: PUSH
36911: EMPTY
36912: LIST
36913: LIST
36914: PUSH
36915: LD_INT 0
36917: PUSH
36918: LD_INT 2
36920: PUSH
36921: EMPTY
36922: LIST
36923: LIST
36924: PUSH
36925: LD_INT 1
36927: NEG
36928: PUSH
36929: LD_INT 1
36931: PUSH
36932: EMPTY
36933: LIST
36934: LIST
36935: PUSH
36936: LD_INT 2
36938: NEG
36939: PUSH
36940: LD_INT 0
36942: PUSH
36943: EMPTY
36944: LIST
36945: LIST
36946: PUSH
36947: LD_INT 2
36949: NEG
36950: PUSH
36951: LD_INT 1
36953: NEG
36954: PUSH
36955: EMPTY
36956: LIST
36957: LIST
36958: PUSH
36959: LD_INT 2
36961: NEG
36962: PUSH
36963: LD_INT 2
36965: NEG
36966: PUSH
36967: EMPTY
36968: LIST
36969: LIST
36970: PUSH
36971: LD_INT 3
36973: PUSH
36974: LD_INT 1
36976: PUSH
36977: EMPTY
36978: LIST
36979: LIST
36980: PUSH
36981: LD_INT 3
36983: PUSH
36984: LD_INT 2
36986: PUSH
36987: EMPTY
36988: LIST
36989: LIST
36990: PUSH
36991: LD_INT 2
36993: PUSH
36994: LD_INT 3
36996: PUSH
36997: EMPTY
36998: LIST
36999: LIST
37000: PUSH
37001: LD_INT 1
37003: PUSH
37004: LD_INT 3
37006: PUSH
37007: EMPTY
37008: LIST
37009: LIST
37010: PUSH
37011: EMPTY
37012: LIST
37013: LIST
37014: LIST
37015: LIST
37016: LIST
37017: LIST
37018: LIST
37019: LIST
37020: LIST
37021: LIST
37022: LIST
37023: LIST
37024: LIST
37025: LIST
37026: LIST
37027: LIST
37028: LIST
37029: LIST
37030: LIST
37031: LIST
37032: LIST
37033: LIST
37034: LIST
37035: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
37036: LD_ADDR_VAR 0 26
37040: PUSH
37041: LD_INT 0
37043: PUSH
37044: LD_INT 0
37046: PUSH
37047: EMPTY
37048: LIST
37049: LIST
37050: PUSH
37051: LD_INT 0
37053: PUSH
37054: LD_INT 1
37056: NEG
37057: PUSH
37058: EMPTY
37059: LIST
37060: LIST
37061: PUSH
37062: LD_INT 1
37064: PUSH
37065: LD_INT 0
37067: PUSH
37068: EMPTY
37069: LIST
37070: LIST
37071: PUSH
37072: LD_INT 1
37074: PUSH
37075: LD_INT 1
37077: PUSH
37078: EMPTY
37079: LIST
37080: LIST
37081: PUSH
37082: LD_INT 0
37084: PUSH
37085: LD_INT 1
37087: PUSH
37088: EMPTY
37089: LIST
37090: LIST
37091: PUSH
37092: LD_INT 1
37094: NEG
37095: PUSH
37096: LD_INT 0
37098: PUSH
37099: EMPTY
37100: LIST
37101: LIST
37102: PUSH
37103: LD_INT 1
37105: NEG
37106: PUSH
37107: LD_INT 1
37109: NEG
37110: PUSH
37111: EMPTY
37112: LIST
37113: LIST
37114: PUSH
37115: LD_INT 1
37117: NEG
37118: PUSH
37119: LD_INT 2
37121: NEG
37122: PUSH
37123: EMPTY
37124: LIST
37125: LIST
37126: PUSH
37127: LD_INT 0
37129: PUSH
37130: LD_INT 2
37132: NEG
37133: PUSH
37134: EMPTY
37135: LIST
37136: LIST
37137: PUSH
37138: LD_INT 1
37140: PUSH
37141: LD_INT 1
37143: NEG
37144: PUSH
37145: EMPTY
37146: LIST
37147: LIST
37148: PUSH
37149: LD_INT 2
37151: PUSH
37152: LD_INT 0
37154: PUSH
37155: EMPTY
37156: LIST
37157: LIST
37158: PUSH
37159: LD_INT 2
37161: PUSH
37162: LD_INT 1
37164: PUSH
37165: EMPTY
37166: LIST
37167: LIST
37168: PUSH
37169: LD_INT 2
37171: PUSH
37172: LD_INT 2
37174: PUSH
37175: EMPTY
37176: LIST
37177: LIST
37178: PUSH
37179: LD_INT 1
37181: PUSH
37182: LD_INT 2
37184: PUSH
37185: EMPTY
37186: LIST
37187: LIST
37188: PUSH
37189: LD_INT 0
37191: PUSH
37192: LD_INT 2
37194: PUSH
37195: EMPTY
37196: LIST
37197: LIST
37198: PUSH
37199: LD_INT 1
37201: NEG
37202: PUSH
37203: LD_INT 1
37205: PUSH
37206: EMPTY
37207: LIST
37208: LIST
37209: PUSH
37210: LD_INT 2
37212: NEG
37213: PUSH
37214: LD_INT 0
37216: PUSH
37217: EMPTY
37218: LIST
37219: LIST
37220: PUSH
37221: LD_INT 2
37223: NEG
37224: PUSH
37225: LD_INT 1
37227: NEG
37228: PUSH
37229: EMPTY
37230: LIST
37231: LIST
37232: PUSH
37233: LD_INT 2
37235: NEG
37236: PUSH
37237: LD_INT 2
37239: NEG
37240: PUSH
37241: EMPTY
37242: LIST
37243: LIST
37244: PUSH
37245: LD_INT 2
37247: PUSH
37248: LD_INT 3
37250: PUSH
37251: EMPTY
37252: LIST
37253: LIST
37254: PUSH
37255: LD_INT 1
37257: PUSH
37258: LD_INT 3
37260: PUSH
37261: EMPTY
37262: LIST
37263: LIST
37264: PUSH
37265: LD_INT 1
37267: NEG
37268: PUSH
37269: LD_INT 2
37271: PUSH
37272: EMPTY
37273: LIST
37274: LIST
37275: PUSH
37276: LD_INT 2
37278: NEG
37279: PUSH
37280: LD_INT 1
37282: PUSH
37283: EMPTY
37284: LIST
37285: LIST
37286: PUSH
37287: EMPTY
37288: LIST
37289: LIST
37290: LIST
37291: LIST
37292: LIST
37293: LIST
37294: LIST
37295: LIST
37296: LIST
37297: LIST
37298: LIST
37299: LIST
37300: LIST
37301: LIST
37302: LIST
37303: LIST
37304: LIST
37305: LIST
37306: LIST
37307: LIST
37308: LIST
37309: LIST
37310: LIST
37311: ST_TO_ADDR
// fDepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
37312: LD_ADDR_VAR 0 27
37316: PUSH
37317: LD_INT 0
37319: PUSH
37320: LD_INT 0
37322: PUSH
37323: EMPTY
37324: LIST
37325: LIST
37326: PUSH
37327: LD_INT 0
37329: PUSH
37330: LD_INT 1
37332: NEG
37333: PUSH
37334: EMPTY
37335: LIST
37336: LIST
37337: PUSH
37338: LD_INT 1
37340: PUSH
37341: LD_INT 0
37343: PUSH
37344: EMPTY
37345: LIST
37346: LIST
37347: PUSH
37348: LD_INT 1
37350: PUSH
37351: LD_INT 1
37353: PUSH
37354: EMPTY
37355: LIST
37356: LIST
37357: PUSH
37358: LD_INT 0
37360: PUSH
37361: LD_INT 1
37363: PUSH
37364: EMPTY
37365: LIST
37366: LIST
37367: PUSH
37368: LD_INT 1
37370: NEG
37371: PUSH
37372: LD_INT 0
37374: PUSH
37375: EMPTY
37376: LIST
37377: LIST
37378: PUSH
37379: LD_INT 1
37381: NEG
37382: PUSH
37383: LD_INT 1
37385: NEG
37386: PUSH
37387: EMPTY
37388: LIST
37389: LIST
37390: PUSH
37391: LD_INT 1
37393: NEG
37394: PUSH
37395: LD_INT 2
37397: NEG
37398: PUSH
37399: EMPTY
37400: LIST
37401: LIST
37402: PUSH
37403: LD_INT 0
37405: PUSH
37406: LD_INT 2
37408: NEG
37409: PUSH
37410: EMPTY
37411: LIST
37412: LIST
37413: PUSH
37414: LD_INT 1
37416: PUSH
37417: LD_INT 1
37419: NEG
37420: PUSH
37421: EMPTY
37422: LIST
37423: LIST
37424: PUSH
37425: LD_INT 2
37427: PUSH
37428: LD_INT 0
37430: PUSH
37431: EMPTY
37432: LIST
37433: LIST
37434: PUSH
37435: LD_INT 2
37437: PUSH
37438: LD_INT 1
37440: PUSH
37441: EMPTY
37442: LIST
37443: LIST
37444: PUSH
37445: LD_INT 2
37447: PUSH
37448: LD_INT 2
37450: PUSH
37451: EMPTY
37452: LIST
37453: LIST
37454: PUSH
37455: LD_INT 1
37457: PUSH
37458: LD_INT 2
37460: PUSH
37461: EMPTY
37462: LIST
37463: LIST
37464: PUSH
37465: LD_INT 0
37467: PUSH
37468: LD_INT 2
37470: PUSH
37471: EMPTY
37472: LIST
37473: LIST
37474: PUSH
37475: LD_INT 1
37477: NEG
37478: PUSH
37479: LD_INT 1
37481: PUSH
37482: EMPTY
37483: LIST
37484: LIST
37485: PUSH
37486: LD_INT 2
37488: NEG
37489: PUSH
37490: LD_INT 0
37492: PUSH
37493: EMPTY
37494: LIST
37495: LIST
37496: PUSH
37497: LD_INT 2
37499: NEG
37500: PUSH
37501: LD_INT 1
37503: NEG
37504: PUSH
37505: EMPTY
37506: LIST
37507: LIST
37508: PUSH
37509: LD_INT 2
37511: NEG
37512: PUSH
37513: LD_INT 2
37515: NEG
37516: PUSH
37517: EMPTY
37518: LIST
37519: LIST
37520: PUSH
37521: LD_INT 1
37523: NEG
37524: PUSH
37525: LD_INT 2
37527: PUSH
37528: EMPTY
37529: LIST
37530: LIST
37531: PUSH
37532: LD_INT 2
37534: NEG
37535: PUSH
37536: LD_INT 1
37538: PUSH
37539: EMPTY
37540: LIST
37541: LIST
37542: PUSH
37543: LD_INT 3
37545: NEG
37546: PUSH
37547: LD_INT 1
37549: NEG
37550: PUSH
37551: EMPTY
37552: LIST
37553: LIST
37554: PUSH
37555: LD_INT 3
37557: NEG
37558: PUSH
37559: LD_INT 2
37561: NEG
37562: PUSH
37563: EMPTY
37564: LIST
37565: LIST
37566: PUSH
37567: EMPTY
37568: LIST
37569: LIST
37570: LIST
37571: LIST
37572: LIST
37573: LIST
37574: LIST
37575: LIST
37576: LIST
37577: LIST
37578: LIST
37579: LIST
37580: LIST
37581: LIST
37582: LIST
37583: LIST
37584: LIST
37585: LIST
37586: LIST
37587: LIST
37588: LIST
37589: LIST
37590: LIST
37591: ST_TO_ADDR
// fDepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
37592: LD_ADDR_VAR 0 28
37596: PUSH
37597: LD_INT 0
37599: PUSH
37600: LD_INT 0
37602: PUSH
37603: EMPTY
37604: LIST
37605: LIST
37606: PUSH
37607: LD_INT 0
37609: PUSH
37610: LD_INT 1
37612: NEG
37613: PUSH
37614: EMPTY
37615: LIST
37616: LIST
37617: PUSH
37618: LD_INT 1
37620: PUSH
37621: LD_INT 0
37623: PUSH
37624: EMPTY
37625: LIST
37626: LIST
37627: PUSH
37628: LD_INT 1
37630: PUSH
37631: LD_INT 1
37633: PUSH
37634: EMPTY
37635: LIST
37636: LIST
37637: PUSH
37638: LD_INT 0
37640: PUSH
37641: LD_INT 1
37643: PUSH
37644: EMPTY
37645: LIST
37646: LIST
37647: PUSH
37648: LD_INT 1
37650: NEG
37651: PUSH
37652: LD_INT 0
37654: PUSH
37655: EMPTY
37656: LIST
37657: LIST
37658: PUSH
37659: LD_INT 1
37661: NEG
37662: PUSH
37663: LD_INT 1
37665: NEG
37666: PUSH
37667: EMPTY
37668: LIST
37669: LIST
37670: PUSH
37671: LD_INT 1
37673: NEG
37674: PUSH
37675: LD_INT 2
37677: NEG
37678: PUSH
37679: EMPTY
37680: LIST
37681: LIST
37682: PUSH
37683: LD_INT 0
37685: PUSH
37686: LD_INT 2
37688: NEG
37689: PUSH
37690: EMPTY
37691: LIST
37692: LIST
37693: PUSH
37694: LD_INT 1
37696: PUSH
37697: LD_INT 1
37699: NEG
37700: PUSH
37701: EMPTY
37702: LIST
37703: LIST
37704: PUSH
37705: LD_INT 2
37707: PUSH
37708: LD_INT 0
37710: PUSH
37711: EMPTY
37712: LIST
37713: LIST
37714: PUSH
37715: LD_INT 2
37717: PUSH
37718: LD_INT 1
37720: PUSH
37721: EMPTY
37722: LIST
37723: LIST
37724: PUSH
37725: LD_INT 2
37727: PUSH
37728: LD_INT 2
37730: PUSH
37731: EMPTY
37732: LIST
37733: LIST
37734: PUSH
37735: LD_INT 1
37737: PUSH
37738: LD_INT 2
37740: PUSH
37741: EMPTY
37742: LIST
37743: LIST
37744: PUSH
37745: LD_INT 0
37747: PUSH
37748: LD_INT 2
37750: PUSH
37751: EMPTY
37752: LIST
37753: LIST
37754: PUSH
37755: LD_INT 1
37757: NEG
37758: PUSH
37759: LD_INT 1
37761: PUSH
37762: EMPTY
37763: LIST
37764: LIST
37765: PUSH
37766: LD_INT 2
37768: NEG
37769: PUSH
37770: LD_INT 0
37772: PUSH
37773: EMPTY
37774: LIST
37775: LIST
37776: PUSH
37777: LD_INT 2
37779: NEG
37780: PUSH
37781: LD_INT 1
37783: NEG
37784: PUSH
37785: EMPTY
37786: LIST
37787: LIST
37788: PUSH
37789: LD_INT 2
37791: NEG
37792: PUSH
37793: LD_INT 2
37795: NEG
37796: PUSH
37797: EMPTY
37798: LIST
37799: LIST
37800: PUSH
37801: LD_INT 2
37803: NEG
37804: PUSH
37805: LD_INT 3
37807: NEG
37808: PUSH
37809: EMPTY
37810: LIST
37811: LIST
37812: PUSH
37813: LD_INT 1
37815: NEG
37816: PUSH
37817: LD_INT 3
37819: NEG
37820: PUSH
37821: EMPTY
37822: LIST
37823: LIST
37824: PUSH
37825: LD_INT 3
37827: NEG
37828: PUSH
37829: LD_INT 1
37831: NEG
37832: PUSH
37833: EMPTY
37834: LIST
37835: LIST
37836: PUSH
37837: LD_INT 3
37839: NEG
37840: PUSH
37841: LD_INT 2
37843: NEG
37844: PUSH
37845: EMPTY
37846: LIST
37847: LIST
37848: PUSH
37849: EMPTY
37850: LIST
37851: LIST
37852: LIST
37853: LIST
37854: LIST
37855: LIST
37856: LIST
37857: LIST
37858: LIST
37859: LIST
37860: LIST
37861: LIST
37862: LIST
37863: LIST
37864: LIST
37865: LIST
37866: LIST
37867: LIST
37868: LIST
37869: LIST
37870: LIST
37871: LIST
37872: LIST
37873: ST_TO_ADDR
// fFactory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
37874: LD_ADDR_VAR 0 29
37878: PUSH
37879: LD_INT 0
37881: PUSH
37882: LD_INT 0
37884: PUSH
37885: EMPTY
37886: LIST
37887: LIST
37888: PUSH
37889: LD_INT 0
37891: PUSH
37892: LD_INT 1
37894: NEG
37895: PUSH
37896: EMPTY
37897: LIST
37898: LIST
37899: PUSH
37900: LD_INT 1
37902: PUSH
37903: LD_INT 0
37905: PUSH
37906: EMPTY
37907: LIST
37908: LIST
37909: PUSH
37910: LD_INT 1
37912: PUSH
37913: LD_INT 1
37915: PUSH
37916: EMPTY
37917: LIST
37918: LIST
37919: PUSH
37920: LD_INT 0
37922: PUSH
37923: LD_INT 1
37925: PUSH
37926: EMPTY
37927: LIST
37928: LIST
37929: PUSH
37930: LD_INT 1
37932: NEG
37933: PUSH
37934: LD_INT 0
37936: PUSH
37937: EMPTY
37938: LIST
37939: LIST
37940: PUSH
37941: LD_INT 1
37943: NEG
37944: PUSH
37945: LD_INT 1
37947: NEG
37948: PUSH
37949: EMPTY
37950: LIST
37951: LIST
37952: PUSH
37953: LD_INT 1
37955: NEG
37956: PUSH
37957: LD_INT 2
37959: NEG
37960: PUSH
37961: EMPTY
37962: LIST
37963: LIST
37964: PUSH
37965: LD_INT 0
37967: PUSH
37968: LD_INT 2
37970: NEG
37971: PUSH
37972: EMPTY
37973: LIST
37974: LIST
37975: PUSH
37976: LD_INT 1
37978: PUSH
37979: LD_INT 1
37981: NEG
37982: PUSH
37983: EMPTY
37984: LIST
37985: LIST
37986: PUSH
37987: LD_INT 2
37989: PUSH
37990: LD_INT 0
37992: PUSH
37993: EMPTY
37994: LIST
37995: LIST
37996: PUSH
37997: LD_INT 2
37999: PUSH
38000: LD_INT 1
38002: PUSH
38003: EMPTY
38004: LIST
38005: LIST
38006: PUSH
38007: LD_INT 1
38009: PUSH
38010: LD_INT 2
38012: PUSH
38013: EMPTY
38014: LIST
38015: LIST
38016: PUSH
38017: LD_INT 0
38019: PUSH
38020: LD_INT 2
38022: PUSH
38023: EMPTY
38024: LIST
38025: LIST
38026: PUSH
38027: LD_INT 1
38029: NEG
38030: PUSH
38031: LD_INT 1
38033: PUSH
38034: EMPTY
38035: LIST
38036: LIST
38037: PUSH
38038: LD_INT 2
38040: NEG
38041: PUSH
38042: LD_INT 1
38044: NEG
38045: PUSH
38046: EMPTY
38047: LIST
38048: LIST
38049: PUSH
38050: LD_INT 2
38052: NEG
38053: PUSH
38054: LD_INT 2
38056: NEG
38057: PUSH
38058: EMPTY
38059: LIST
38060: LIST
38061: PUSH
38062: LD_INT 2
38064: NEG
38065: PUSH
38066: LD_INT 3
38068: NEG
38069: PUSH
38070: EMPTY
38071: LIST
38072: LIST
38073: PUSH
38074: LD_INT 2
38076: PUSH
38077: LD_INT 1
38079: NEG
38080: PUSH
38081: EMPTY
38082: LIST
38083: LIST
38084: PUSH
38085: LD_INT 3
38087: PUSH
38088: LD_INT 1
38090: PUSH
38091: EMPTY
38092: LIST
38093: LIST
38094: PUSH
38095: LD_INT 1
38097: PUSH
38098: LD_INT 3
38100: PUSH
38101: EMPTY
38102: LIST
38103: LIST
38104: PUSH
38105: LD_INT 1
38107: NEG
38108: PUSH
38109: LD_INT 2
38111: PUSH
38112: EMPTY
38113: LIST
38114: LIST
38115: PUSH
38116: LD_INT 3
38118: NEG
38119: PUSH
38120: LD_INT 2
38122: NEG
38123: PUSH
38124: EMPTY
38125: LIST
38126: LIST
38127: PUSH
38128: EMPTY
38129: LIST
38130: LIST
38131: LIST
38132: LIST
38133: LIST
38134: LIST
38135: LIST
38136: LIST
38137: LIST
38138: LIST
38139: LIST
38140: LIST
38141: LIST
38142: LIST
38143: LIST
38144: LIST
38145: LIST
38146: LIST
38147: LIST
38148: LIST
38149: LIST
38150: LIST
38151: LIST
38152: ST_TO_ADDR
// fFactory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
38153: LD_ADDR_VAR 0 30
38157: PUSH
38158: LD_INT 0
38160: PUSH
38161: LD_INT 0
38163: PUSH
38164: EMPTY
38165: LIST
38166: LIST
38167: PUSH
38168: LD_INT 0
38170: PUSH
38171: LD_INT 1
38173: NEG
38174: PUSH
38175: EMPTY
38176: LIST
38177: LIST
38178: PUSH
38179: LD_INT 1
38181: PUSH
38182: LD_INT 0
38184: PUSH
38185: EMPTY
38186: LIST
38187: LIST
38188: PUSH
38189: LD_INT 1
38191: PUSH
38192: LD_INT 1
38194: PUSH
38195: EMPTY
38196: LIST
38197: LIST
38198: PUSH
38199: LD_INT 0
38201: PUSH
38202: LD_INT 1
38204: PUSH
38205: EMPTY
38206: LIST
38207: LIST
38208: PUSH
38209: LD_INT 1
38211: NEG
38212: PUSH
38213: LD_INT 0
38215: PUSH
38216: EMPTY
38217: LIST
38218: LIST
38219: PUSH
38220: LD_INT 1
38222: NEG
38223: PUSH
38224: LD_INT 1
38226: NEG
38227: PUSH
38228: EMPTY
38229: LIST
38230: LIST
38231: PUSH
38232: LD_INT 1
38234: NEG
38235: PUSH
38236: LD_INT 2
38238: NEG
38239: PUSH
38240: EMPTY
38241: LIST
38242: LIST
38243: PUSH
38244: LD_INT 0
38246: PUSH
38247: LD_INT 2
38249: NEG
38250: PUSH
38251: EMPTY
38252: LIST
38253: LIST
38254: PUSH
38255: LD_INT 1
38257: PUSH
38258: LD_INT 1
38260: NEG
38261: PUSH
38262: EMPTY
38263: LIST
38264: LIST
38265: PUSH
38266: LD_INT 2
38268: PUSH
38269: LD_INT 0
38271: PUSH
38272: EMPTY
38273: LIST
38274: LIST
38275: PUSH
38276: LD_INT 2
38278: PUSH
38279: LD_INT 1
38281: PUSH
38282: EMPTY
38283: LIST
38284: LIST
38285: PUSH
38286: LD_INT 2
38288: PUSH
38289: LD_INT 2
38291: PUSH
38292: EMPTY
38293: LIST
38294: LIST
38295: PUSH
38296: LD_INT 1
38298: PUSH
38299: LD_INT 2
38301: PUSH
38302: EMPTY
38303: LIST
38304: LIST
38305: PUSH
38306: LD_INT 1
38308: NEG
38309: PUSH
38310: LD_INT 1
38312: PUSH
38313: EMPTY
38314: LIST
38315: LIST
38316: PUSH
38317: LD_INT 2
38319: NEG
38320: PUSH
38321: LD_INT 0
38323: PUSH
38324: EMPTY
38325: LIST
38326: LIST
38327: PUSH
38328: LD_INT 2
38330: NEG
38331: PUSH
38332: LD_INT 1
38334: NEG
38335: PUSH
38336: EMPTY
38337: LIST
38338: LIST
38339: PUSH
38340: LD_INT 1
38342: NEG
38343: PUSH
38344: LD_INT 3
38346: NEG
38347: PUSH
38348: EMPTY
38349: LIST
38350: LIST
38351: PUSH
38352: LD_INT 1
38354: PUSH
38355: LD_INT 2
38357: NEG
38358: PUSH
38359: EMPTY
38360: LIST
38361: LIST
38362: PUSH
38363: LD_INT 3
38365: PUSH
38366: LD_INT 2
38368: PUSH
38369: EMPTY
38370: LIST
38371: LIST
38372: PUSH
38373: LD_INT 2
38375: PUSH
38376: LD_INT 3
38378: PUSH
38379: EMPTY
38380: LIST
38381: LIST
38382: PUSH
38383: LD_INT 2
38385: NEG
38386: PUSH
38387: LD_INT 1
38389: PUSH
38390: EMPTY
38391: LIST
38392: LIST
38393: PUSH
38394: LD_INT 3
38396: NEG
38397: PUSH
38398: LD_INT 1
38400: NEG
38401: PUSH
38402: EMPTY
38403: LIST
38404: LIST
38405: PUSH
38406: EMPTY
38407: LIST
38408: LIST
38409: LIST
38410: LIST
38411: LIST
38412: LIST
38413: LIST
38414: LIST
38415: LIST
38416: LIST
38417: LIST
38418: LIST
38419: LIST
38420: LIST
38421: LIST
38422: LIST
38423: LIST
38424: LIST
38425: LIST
38426: LIST
38427: LIST
38428: LIST
38429: LIST
38430: ST_TO_ADDR
// fFactory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
38431: LD_ADDR_VAR 0 31
38435: PUSH
38436: LD_INT 0
38438: PUSH
38439: LD_INT 0
38441: PUSH
38442: EMPTY
38443: LIST
38444: LIST
38445: PUSH
38446: LD_INT 0
38448: PUSH
38449: LD_INT 1
38451: NEG
38452: PUSH
38453: EMPTY
38454: LIST
38455: LIST
38456: PUSH
38457: LD_INT 1
38459: PUSH
38460: LD_INT 0
38462: PUSH
38463: EMPTY
38464: LIST
38465: LIST
38466: PUSH
38467: LD_INT 1
38469: PUSH
38470: LD_INT 1
38472: PUSH
38473: EMPTY
38474: LIST
38475: LIST
38476: PUSH
38477: LD_INT 0
38479: PUSH
38480: LD_INT 1
38482: PUSH
38483: EMPTY
38484: LIST
38485: LIST
38486: PUSH
38487: LD_INT 1
38489: NEG
38490: PUSH
38491: LD_INT 0
38493: PUSH
38494: EMPTY
38495: LIST
38496: LIST
38497: PUSH
38498: LD_INT 1
38500: NEG
38501: PUSH
38502: LD_INT 1
38504: NEG
38505: PUSH
38506: EMPTY
38507: LIST
38508: LIST
38509: PUSH
38510: LD_INT 1
38512: NEG
38513: PUSH
38514: LD_INT 2
38516: NEG
38517: PUSH
38518: EMPTY
38519: LIST
38520: LIST
38521: PUSH
38522: LD_INT 1
38524: PUSH
38525: LD_INT 1
38527: NEG
38528: PUSH
38529: EMPTY
38530: LIST
38531: LIST
38532: PUSH
38533: LD_INT 2
38535: PUSH
38536: LD_INT 0
38538: PUSH
38539: EMPTY
38540: LIST
38541: LIST
38542: PUSH
38543: LD_INT 2
38545: PUSH
38546: LD_INT 1
38548: PUSH
38549: EMPTY
38550: LIST
38551: LIST
38552: PUSH
38553: LD_INT 2
38555: PUSH
38556: LD_INT 2
38558: PUSH
38559: EMPTY
38560: LIST
38561: LIST
38562: PUSH
38563: LD_INT 1
38565: PUSH
38566: LD_INT 2
38568: PUSH
38569: EMPTY
38570: LIST
38571: LIST
38572: PUSH
38573: LD_INT 0
38575: PUSH
38576: LD_INT 2
38578: PUSH
38579: EMPTY
38580: LIST
38581: LIST
38582: PUSH
38583: LD_INT 1
38585: NEG
38586: PUSH
38587: LD_INT 1
38589: PUSH
38590: EMPTY
38591: LIST
38592: LIST
38593: PUSH
38594: LD_INT 2
38596: NEG
38597: PUSH
38598: LD_INT 1
38600: NEG
38601: PUSH
38602: EMPTY
38603: LIST
38604: LIST
38605: PUSH
38606: LD_INT 2
38608: NEG
38609: PUSH
38610: LD_INT 2
38612: NEG
38613: PUSH
38614: EMPTY
38615: LIST
38616: LIST
38617: PUSH
38618: LD_INT 2
38620: NEG
38621: PUSH
38622: LD_INT 3
38624: NEG
38625: PUSH
38626: EMPTY
38627: LIST
38628: LIST
38629: PUSH
38630: LD_INT 2
38632: PUSH
38633: LD_INT 1
38635: NEG
38636: PUSH
38637: EMPTY
38638: LIST
38639: LIST
38640: PUSH
38641: LD_INT 3
38643: PUSH
38644: LD_INT 1
38646: PUSH
38647: EMPTY
38648: LIST
38649: LIST
38650: PUSH
38651: LD_INT 1
38653: PUSH
38654: LD_INT 3
38656: PUSH
38657: EMPTY
38658: LIST
38659: LIST
38660: PUSH
38661: LD_INT 1
38663: NEG
38664: PUSH
38665: LD_INT 2
38667: PUSH
38668: EMPTY
38669: LIST
38670: LIST
38671: PUSH
38672: LD_INT 3
38674: NEG
38675: PUSH
38676: LD_INT 2
38678: NEG
38679: PUSH
38680: EMPTY
38681: LIST
38682: LIST
38683: PUSH
38684: EMPTY
38685: LIST
38686: LIST
38687: LIST
38688: LIST
38689: LIST
38690: LIST
38691: LIST
38692: LIST
38693: LIST
38694: LIST
38695: LIST
38696: LIST
38697: LIST
38698: LIST
38699: LIST
38700: LIST
38701: LIST
38702: LIST
38703: LIST
38704: LIST
38705: LIST
38706: LIST
38707: LIST
38708: ST_TO_ADDR
// fFactory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
38709: LD_ADDR_VAR 0 32
38713: PUSH
38714: LD_INT 0
38716: PUSH
38717: LD_INT 0
38719: PUSH
38720: EMPTY
38721: LIST
38722: LIST
38723: PUSH
38724: LD_INT 0
38726: PUSH
38727: LD_INT 1
38729: NEG
38730: PUSH
38731: EMPTY
38732: LIST
38733: LIST
38734: PUSH
38735: LD_INT 1
38737: PUSH
38738: LD_INT 0
38740: PUSH
38741: EMPTY
38742: LIST
38743: LIST
38744: PUSH
38745: LD_INT 1
38747: PUSH
38748: LD_INT 1
38750: PUSH
38751: EMPTY
38752: LIST
38753: LIST
38754: PUSH
38755: LD_INT 0
38757: PUSH
38758: LD_INT 1
38760: PUSH
38761: EMPTY
38762: LIST
38763: LIST
38764: PUSH
38765: LD_INT 1
38767: NEG
38768: PUSH
38769: LD_INT 0
38771: PUSH
38772: EMPTY
38773: LIST
38774: LIST
38775: PUSH
38776: LD_INT 1
38778: NEG
38779: PUSH
38780: LD_INT 1
38782: NEG
38783: PUSH
38784: EMPTY
38785: LIST
38786: LIST
38787: PUSH
38788: LD_INT 1
38790: NEG
38791: PUSH
38792: LD_INT 2
38794: NEG
38795: PUSH
38796: EMPTY
38797: LIST
38798: LIST
38799: PUSH
38800: LD_INT 0
38802: PUSH
38803: LD_INT 2
38805: NEG
38806: PUSH
38807: EMPTY
38808: LIST
38809: LIST
38810: PUSH
38811: LD_INT 1
38813: PUSH
38814: LD_INT 1
38816: NEG
38817: PUSH
38818: EMPTY
38819: LIST
38820: LIST
38821: PUSH
38822: LD_INT 2
38824: PUSH
38825: LD_INT 1
38827: PUSH
38828: EMPTY
38829: LIST
38830: LIST
38831: PUSH
38832: LD_INT 2
38834: PUSH
38835: LD_INT 2
38837: PUSH
38838: EMPTY
38839: LIST
38840: LIST
38841: PUSH
38842: LD_INT 1
38844: PUSH
38845: LD_INT 2
38847: PUSH
38848: EMPTY
38849: LIST
38850: LIST
38851: PUSH
38852: LD_INT 0
38854: PUSH
38855: LD_INT 2
38857: PUSH
38858: EMPTY
38859: LIST
38860: LIST
38861: PUSH
38862: LD_INT 1
38864: NEG
38865: PUSH
38866: LD_INT 1
38868: PUSH
38869: EMPTY
38870: LIST
38871: LIST
38872: PUSH
38873: LD_INT 2
38875: NEG
38876: PUSH
38877: LD_INT 0
38879: PUSH
38880: EMPTY
38881: LIST
38882: LIST
38883: PUSH
38884: LD_INT 2
38886: NEG
38887: PUSH
38888: LD_INT 1
38890: NEG
38891: PUSH
38892: EMPTY
38893: LIST
38894: LIST
38895: PUSH
38896: LD_INT 1
38898: NEG
38899: PUSH
38900: LD_INT 3
38902: NEG
38903: PUSH
38904: EMPTY
38905: LIST
38906: LIST
38907: PUSH
38908: LD_INT 1
38910: PUSH
38911: LD_INT 2
38913: NEG
38914: PUSH
38915: EMPTY
38916: LIST
38917: LIST
38918: PUSH
38919: LD_INT 3
38921: PUSH
38922: LD_INT 2
38924: PUSH
38925: EMPTY
38926: LIST
38927: LIST
38928: PUSH
38929: LD_INT 2
38931: PUSH
38932: LD_INT 3
38934: PUSH
38935: EMPTY
38936: LIST
38937: LIST
38938: PUSH
38939: LD_INT 2
38941: NEG
38942: PUSH
38943: LD_INT 1
38945: PUSH
38946: EMPTY
38947: LIST
38948: LIST
38949: PUSH
38950: LD_INT 3
38952: NEG
38953: PUSH
38954: LD_INT 1
38956: NEG
38957: PUSH
38958: EMPTY
38959: LIST
38960: LIST
38961: PUSH
38962: EMPTY
38963: LIST
38964: LIST
38965: LIST
38966: LIST
38967: LIST
38968: LIST
38969: LIST
38970: LIST
38971: LIST
38972: LIST
38973: LIST
38974: LIST
38975: LIST
38976: LIST
38977: LIST
38978: LIST
38979: LIST
38980: LIST
38981: LIST
38982: LIST
38983: LIST
38984: LIST
38985: LIST
38986: ST_TO_ADDR
// fFactory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
38987: LD_ADDR_VAR 0 33
38991: PUSH
38992: LD_INT 0
38994: PUSH
38995: LD_INT 0
38997: PUSH
38998: EMPTY
38999: LIST
39000: LIST
39001: PUSH
39002: LD_INT 0
39004: PUSH
39005: LD_INT 1
39007: NEG
39008: PUSH
39009: EMPTY
39010: LIST
39011: LIST
39012: PUSH
39013: LD_INT 1
39015: PUSH
39016: LD_INT 0
39018: PUSH
39019: EMPTY
39020: LIST
39021: LIST
39022: PUSH
39023: LD_INT 1
39025: PUSH
39026: LD_INT 1
39028: PUSH
39029: EMPTY
39030: LIST
39031: LIST
39032: PUSH
39033: LD_INT 0
39035: PUSH
39036: LD_INT 1
39038: PUSH
39039: EMPTY
39040: LIST
39041: LIST
39042: PUSH
39043: LD_INT 1
39045: NEG
39046: PUSH
39047: LD_INT 0
39049: PUSH
39050: EMPTY
39051: LIST
39052: LIST
39053: PUSH
39054: LD_INT 1
39056: NEG
39057: PUSH
39058: LD_INT 1
39060: NEG
39061: PUSH
39062: EMPTY
39063: LIST
39064: LIST
39065: PUSH
39066: LD_INT 1
39068: NEG
39069: PUSH
39070: LD_INT 2
39072: NEG
39073: PUSH
39074: EMPTY
39075: LIST
39076: LIST
39077: PUSH
39078: LD_INT 1
39080: PUSH
39081: LD_INT 1
39083: NEG
39084: PUSH
39085: EMPTY
39086: LIST
39087: LIST
39088: PUSH
39089: LD_INT 2
39091: PUSH
39092: LD_INT 0
39094: PUSH
39095: EMPTY
39096: LIST
39097: LIST
39098: PUSH
39099: LD_INT 2
39101: PUSH
39102: LD_INT 1
39104: PUSH
39105: EMPTY
39106: LIST
39107: LIST
39108: PUSH
39109: LD_INT 1
39111: PUSH
39112: LD_INT 2
39114: PUSH
39115: EMPTY
39116: LIST
39117: LIST
39118: PUSH
39119: LD_INT 0
39121: PUSH
39122: LD_INT 2
39124: PUSH
39125: EMPTY
39126: LIST
39127: LIST
39128: PUSH
39129: LD_INT 1
39131: NEG
39132: PUSH
39133: LD_INT 1
39135: PUSH
39136: EMPTY
39137: LIST
39138: LIST
39139: PUSH
39140: LD_INT 2
39142: NEG
39143: PUSH
39144: LD_INT 0
39146: PUSH
39147: EMPTY
39148: LIST
39149: LIST
39150: PUSH
39151: LD_INT 2
39153: NEG
39154: PUSH
39155: LD_INT 1
39157: NEG
39158: PUSH
39159: EMPTY
39160: LIST
39161: LIST
39162: PUSH
39163: LD_INT 2
39165: NEG
39166: PUSH
39167: LD_INT 2
39169: NEG
39170: PUSH
39171: EMPTY
39172: LIST
39173: LIST
39174: PUSH
39175: LD_INT 2
39177: NEG
39178: PUSH
39179: LD_INT 3
39181: NEG
39182: PUSH
39183: EMPTY
39184: LIST
39185: LIST
39186: PUSH
39187: LD_INT 2
39189: PUSH
39190: LD_INT 1
39192: NEG
39193: PUSH
39194: EMPTY
39195: LIST
39196: LIST
39197: PUSH
39198: LD_INT 3
39200: PUSH
39201: LD_INT 1
39203: PUSH
39204: EMPTY
39205: LIST
39206: LIST
39207: PUSH
39208: LD_INT 1
39210: PUSH
39211: LD_INT 3
39213: PUSH
39214: EMPTY
39215: LIST
39216: LIST
39217: PUSH
39218: LD_INT 1
39220: NEG
39221: PUSH
39222: LD_INT 2
39224: PUSH
39225: EMPTY
39226: LIST
39227: LIST
39228: PUSH
39229: LD_INT 3
39231: NEG
39232: PUSH
39233: LD_INT 2
39235: NEG
39236: PUSH
39237: EMPTY
39238: LIST
39239: LIST
39240: PUSH
39241: EMPTY
39242: LIST
39243: LIST
39244: LIST
39245: LIST
39246: LIST
39247: LIST
39248: LIST
39249: LIST
39250: LIST
39251: LIST
39252: LIST
39253: LIST
39254: LIST
39255: LIST
39256: LIST
39257: LIST
39258: LIST
39259: LIST
39260: LIST
39261: LIST
39262: LIST
39263: LIST
39264: LIST
39265: ST_TO_ADDR
// fFactory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
39266: LD_ADDR_VAR 0 34
39270: PUSH
39271: LD_INT 0
39273: PUSH
39274: LD_INT 0
39276: PUSH
39277: EMPTY
39278: LIST
39279: LIST
39280: PUSH
39281: LD_INT 0
39283: PUSH
39284: LD_INT 1
39286: NEG
39287: PUSH
39288: EMPTY
39289: LIST
39290: LIST
39291: PUSH
39292: LD_INT 1
39294: PUSH
39295: LD_INT 0
39297: PUSH
39298: EMPTY
39299: LIST
39300: LIST
39301: PUSH
39302: LD_INT 1
39304: PUSH
39305: LD_INT 1
39307: PUSH
39308: EMPTY
39309: LIST
39310: LIST
39311: PUSH
39312: LD_INT 0
39314: PUSH
39315: LD_INT 1
39317: PUSH
39318: EMPTY
39319: LIST
39320: LIST
39321: PUSH
39322: LD_INT 1
39324: NEG
39325: PUSH
39326: LD_INT 0
39328: PUSH
39329: EMPTY
39330: LIST
39331: LIST
39332: PUSH
39333: LD_INT 1
39335: NEG
39336: PUSH
39337: LD_INT 1
39339: NEG
39340: PUSH
39341: EMPTY
39342: LIST
39343: LIST
39344: PUSH
39345: LD_INT 1
39347: NEG
39348: PUSH
39349: LD_INT 2
39351: NEG
39352: PUSH
39353: EMPTY
39354: LIST
39355: LIST
39356: PUSH
39357: LD_INT 0
39359: PUSH
39360: LD_INT 2
39362: NEG
39363: PUSH
39364: EMPTY
39365: LIST
39366: LIST
39367: PUSH
39368: LD_INT 1
39370: PUSH
39371: LD_INT 1
39373: NEG
39374: PUSH
39375: EMPTY
39376: LIST
39377: LIST
39378: PUSH
39379: LD_INT 2
39381: PUSH
39382: LD_INT 1
39384: PUSH
39385: EMPTY
39386: LIST
39387: LIST
39388: PUSH
39389: LD_INT 2
39391: PUSH
39392: LD_INT 2
39394: PUSH
39395: EMPTY
39396: LIST
39397: LIST
39398: PUSH
39399: LD_INT 1
39401: PUSH
39402: LD_INT 2
39404: PUSH
39405: EMPTY
39406: LIST
39407: LIST
39408: PUSH
39409: LD_INT 1
39411: NEG
39412: PUSH
39413: LD_INT 1
39415: PUSH
39416: EMPTY
39417: LIST
39418: LIST
39419: PUSH
39420: LD_INT 2
39422: NEG
39423: PUSH
39424: LD_INT 0
39426: PUSH
39427: EMPTY
39428: LIST
39429: LIST
39430: PUSH
39431: LD_INT 2
39433: NEG
39434: PUSH
39435: LD_INT 1
39437: NEG
39438: PUSH
39439: EMPTY
39440: LIST
39441: LIST
39442: PUSH
39443: LD_INT 2
39445: NEG
39446: PUSH
39447: LD_INT 2
39449: NEG
39450: PUSH
39451: EMPTY
39452: LIST
39453: LIST
39454: PUSH
39455: LD_INT 1
39457: NEG
39458: PUSH
39459: LD_INT 3
39461: NEG
39462: PUSH
39463: EMPTY
39464: LIST
39465: LIST
39466: PUSH
39467: LD_INT 1
39469: PUSH
39470: LD_INT 2
39472: NEG
39473: PUSH
39474: EMPTY
39475: LIST
39476: LIST
39477: PUSH
39478: LD_INT 3
39480: PUSH
39481: LD_INT 2
39483: PUSH
39484: EMPTY
39485: LIST
39486: LIST
39487: PUSH
39488: LD_INT 2
39490: PUSH
39491: LD_INT 3
39493: PUSH
39494: EMPTY
39495: LIST
39496: LIST
39497: PUSH
39498: LD_INT 2
39500: NEG
39501: PUSH
39502: LD_INT 1
39504: PUSH
39505: EMPTY
39506: LIST
39507: LIST
39508: PUSH
39509: LD_INT 3
39511: NEG
39512: PUSH
39513: LD_INT 1
39515: NEG
39516: PUSH
39517: EMPTY
39518: LIST
39519: LIST
39520: PUSH
39521: EMPTY
39522: LIST
39523: LIST
39524: LIST
39525: LIST
39526: LIST
39527: LIST
39528: LIST
39529: LIST
39530: LIST
39531: LIST
39532: LIST
39533: LIST
39534: LIST
39535: LIST
39536: LIST
39537: LIST
39538: LIST
39539: LIST
39540: LIST
39541: LIST
39542: LIST
39543: LIST
39544: LIST
39545: ST_TO_ADDR
// fExt0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
39546: LD_ADDR_VAR 0 35
39550: PUSH
39551: LD_INT 0
39553: PUSH
39554: LD_INT 0
39556: PUSH
39557: EMPTY
39558: LIST
39559: LIST
39560: PUSH
39561: LD_INT 0
39563: PUSH
39564: LD_INT 1
39566: NEG
39567: PUSH
39568: EMPTY
39569: LIST
39570: LIST
39571: PUSH
39572: LD_INT 1
39574: PUSH
39575: LD_INT 0
39577: PUSH
39578: EMPTY
39579: LIST
39580: LIST
39581: PUSH
39582: LD_INT 1
39584: PUSH
39585: LD_INT 1
39587: PUSH
39588: EMPTY
39589: LIST
39590: LIST
39591: PUSH
39592: LD_INT 0
39594: PUSH
39595: LD_INT 1
39597: PUSH
39598: EMPTY
39599: LIST
39600: LIST
39601: PUSH
39602: LD_INT 1
39604: NEG
39605: PUSH
39606: LD_INT 0
39608: PUSH
39609: EMPTY
39610: LIST
39611: LIST
39612: PUSH
39613: LD_INT 1
39615: NEG
39616: PUSH
39617: LD_INT 1
39619: NEG
39620: PUSH
39621: EMPTY
39622: LIST
39623: LIST
39624: PUSH
39625: LD_INT 2
39627: PUSH
39628: LD_INT 1
39630: PUSH
39631: EMPTY
39632: LIST
39633: LIST
39634: PUSH
39635: LD_INT 2
39637: NEG
39638: PUSH
39639: LD_INT 1
39641: NEG
39642: PUSH
39643: EMPTY
39644: LIST
39645: LIST
39646: PUSH
39647: EMPTY
39648: LIST
39649: LIST
39650: LIST
39651: LIST
39652: LIST
39653: LIST
39654: LIST
39655: LIST
39656: LIST
39657: ST_TO_ADDR
// fExt1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
39658: LD_ADDR_VAR 0 36
39662: PUSH
39663: LD_INT 0
39665: PUSH
39666: LD_INT 0
39668: PUSH
39669: EMPTY
39670: LIST
39671: LIST
39672: PUSH
39673: LD_INT 0
39675: PUSH
39676: LD_INT 1
39678: NEG
39679: PUSH
39680: EMPTY
39681: LIST
39682: LIST
39683: PUSH
39684: LD_INT 1
39686: PUSH
39687: LD_INT 0
39689: PUSH
39690: EMPTY
39691: LIST
39692: LIST
39693: PUSH
39694: LD_INT 1
39696: PUSH
39697: LD_INT 1
39699: PUSH
39700: EMPTY
39701: LIST
39702: LIST
39703: PUSH
39704: LD_INT 0
39706: PUSH
39707: LD_INT 1
39709: PUSH
39710: EMPTY
39711: LIST
39712: LIST
39713: PUSH
39714: LD_INT 1
39716: NEG
39717: PUSH
39718: LD_INT 0
39720: PUSH
39721: EMPTY
39722: LIST
39723: LIST
39724: PUSH
39725: LD_INT 1
39727: NEG
39728: PUSH
39729: LD_INT 1
39731: NEG
39732: PUSH
39733: EMPTY
39734: LIST
39735: LIST
39736: PUSH
39737: LD_INT 1
39739: NEG
39740: PUSH
39741: LD_INT 2
39743: NEG
39744: PUSH
39745: EMPTY
39746: LIST
39747: LIST
39748: PUSH
39749: LD_INT 1
39751: PUSH
39752: LD_INT 2
39754: PUSH
39755: EMPTY
39756: LIST
39757: LIST
39758: PUSH
39759: EMPTY
39760: LIST
39761: LIST
39762: LIST
39763: LIST
39764: LIST
39765: LIST
39766: LIST
39767: LIST
39768: LIST
39769: ST_TO_ADDR
// fExt2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
39770: LD_ADDR_VAR 0 37
39774: PUSH
39775: LD_INT 0
39777: PUSH
39778: LD_INT 0
39780: PUSH
39781: EMPTY
39782: LIST
39783: LIST
39784: PUSH
39785: LD_INT 0
39787: PUSH
39788: LD_INT 1
39790: NEG
39791: PUSH
39792: EMPTY
39793: LIST
39794: LIST
39795: PUSH
39796: LD_INT 1
39798: PUSH
39799: LD_INT 0
39801: PUSH
39802: EMPTY
39803: LIST
39804: LIST
39805: PUSH
39806: LD_INT 1
39808: PUSH
39809: LD_INT 1
39811: PUSH
39812: EMPTY
39813: LIST
39814: LIST
39815: PUSH
39816: LD_INT 0
39818: PUSH
39819: LD_INT 1
39821: PUSH
39822: EMPTY
39823: LIST
39824: LIST
39825: PUSH
39826: LD_INT 1
39828: NEG
39829: PUSH
39830: LD_INT 0
39832: PUSH
39833: EMPTY
39834: LIST
39835: LIST
39836: PUSH
39837: LD_INT 1
39839: NEG
39840: PUSH
39841: LD_INT 1
39843: NEG
39844: PUSH
39845: EMPTY
39846: LIST
39847: LIST
39848: PUSH
39849: LD_INT 1
39851: PUSH
39852: LD_INT 1
39854: NEG
39855: PUSH
39856: EMPTY
39857: LIST
39858: LIST
39859: PUSH
39860: LD_INT 1
39862: NEG
39863: PUSH
39864: LD_INT 1
39866: PUSH
39867: EMPTY
39868: LIST
39869: LIST
39870: PUSH
39871: EMPTY
39872: LIST
39873: LIST
39874: LIST
39875: LIST
39876: LIST
39877: LIST
39878: LIST
39879: LIST
39880: LIST
39881: ST_TO_ADDR
// fExt3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
39882: LD_ADDR_VAR 0 38
39886: PUSH
39887: LD_INT 0
39889: PUSH
39890: LD_INT 0
39892: PUSH
39893: EMPTY
39894: LIST
39895: LIST
39896: PUSH
39897: LD_INT 0
39899: PUSH
39900: LD_INT 1
39902: NEG
39903: PUSH
39904: EMPTY
39905: LIST
39906: LIST
39907: PUSH
39908: LD_INT 1
39910: PUSH
39911: LD_INT 0
39913: PUSH
39914: EMPTY
39915: LIST
39916: LIST
39917: PUSH
39918: LD_INT 1
39920: PUSH
39921: LD_INT 1
39923: PUSH
39924: EMPTY
39925: LIST
39926: LIST
39927: PUSH
39928: LD_INT 0
39930: PUSH
39931: LD_INT 1
39933: PUSH
39934: EMPTY
39935: LIST
39936: LIST
39937: PUSH
39938: LD_INT 1
39940: NEG
39941: PUSH
39942: LD_INT 0
39944: PUSH
39945: EMPTY
39946: LIST
39947: LIST
39948: PUSH
39949: LD_INT 1
39951: NEG
39952: PUSH
39953: LD_INT 1
39955: NEG
39956: PUSH
39957: EMPTY
39958: LIST
39959: LIST
39960: PUSH
39961: LD_INT 2
39963: PUSH
39964: LD_INT 1
39966: PUSH
39967: EMPTY
39968: LIST
39969: LIST
39970: PUSH
39971: LD_INT 2
39973: NEG
39974: PUSH
39975: LD_INT 1
39977: NEG
39978: PUSH
39979: EMPTY
39980: LIST
39981: LIST
39982: PUSH
39983: EMPTY
39984: LIST
39985: LIST
39986: LIST
39987: LIST
39988: LIST
39989: LIST
39990: LIST
39991: LIST
39992: LIST
39993: ST_TO_ADDR
// fExt4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
39994: LD_ADDR_VAR 0 39
39998: PUSH
39999: LD_INT 0
40001: PUSH
40002: LD_INT 0
40004: PUSH
40005: EMPTY
40006: LIST
40007: LIST
40008: PUSH
40009: LD_INT 0
40011: PUSH
40012: LD_INT 1
40014: NEG
40015: PUSH
40016: EMPTY
40017: LIST
40018: LIST
40019: PUSH
40020: LD_INT 1
40022: PUSH
40023: LD_INT 0
40025: PUSH
40026: EMPTY
40027: LIST
40028: LIST
40029: PUSH
40030: LD_INT 1
40032: PUSH
40033: LD_INT 1
40035: PUSH
40036: EMPTY
40037: LIST
40038: LIST
40039: PUSH
40040: LD_INT 0
40042: PUSH
40043: LD_INT 1
40045: PUSH
40046: EMPTY
40047: LIST
40048: LIST
40049: PUSH
40050: LD_INT 1
40052: NEG
40053: PUSH
40054: LD_INT 0
40056: PUSH
40057: EMPTY
40058: LIST
40059: LIST
40060: PUSH
40061: LD_INT 1
40063: NEG
40064: PUSH
40065: LD_INT 1
40067: NEG
40068: PUSH
40069: EMPTY
40070: LIST
40071: LIST
40072: PUSH
40073: LD_INT 1
40075: NEG
40076: PUSH
40077: LD_INT 2
40079: NEG
40080: PUSH
40081: EMPTY
40082: LIST
40083: LIST
40084: PUSH
40085: LD_INT 1
40087: PUSH
40088: LD_INT 2
40090: PUSH
40091: EMPTY
40092: LIST
40093: LIST
40094: PUSH
40095: EMPTY
40096: LIST
40097: LIST
40098: LIST
40099: LIST
40100: LIST
40101: LIST
40102: LIST
40103: LIST
40104: LIST
40105: ST_TO_ADDR
// fExt5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
40106: LD_ADDR_VAR 0 40
40110: PUSH
40111: LD_INT 0
40113: PUSH
40114: LD_INT 0
40116: PUSH
40117: EMPTY
40118: LIST
40119: LIST
40120: PUSH
40121: LD_INT 0
40123: PUSH
40124: LD_INT 1
40126: NEG
40127: PUSH
40128: EMPTY
40129: LIST
40130: LIST
40131: PUSH
40132: LD_INT 1
40134: PUSH
40135: LD_INT 0
40137: PUSH
40138: EMPTY
40139: LIST
40140: LIST
40141: PUSH
40142: LD_INT 1
40144: PUSH
40145: LD_INT 1
40147: PUSH
40148: EMPTY
40149: LIST
40150: LIST
40151: PUSH
40152: LD_INT 0
40154: PUSH
40155: LD_INT 1
40157: PUSH
40158: EMPTY
40159: LIST
40160: LIST
40161: PUSH
40162: LD_INT 1
40164: NEG
40165: PUSH
40166: LD_INT 0
40168: PUSH
40169: EMPTY
40170: LIST
40171: LIST
40172: PUSH
40173: LD_INT 1
40175: NEG
40176: PUSH
40177: LD_INT 1
40179: NEG
40180: PUSH
40181: EMPTY
40182: LIST
40183: LIST
40184: PUSH
40185: LD_INT 1
40187: PUSH
40188: LD_INT 1
40190: NEG
40191: PUSH
40192: EMPTY
40193: LIST
40194: LIST
40195: PUSH
40196: LD_INT 1
40198: NEG
40199: PUSH
40200: LD_INT 1
40202: PUSH
40203: EMPTY
40204: LIST
40205: LIST
40206: PUSH
40207: EMPTY
40208: LIST
40209: LIST
40210: LIST
40211: LIST
40212: LIST
40213: LIST
40214: LIST
40215: LIST
40216: LIST
40217: ST_TO_ADDR
// fLab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
40218: LD_ADDR_VAR 0 41
40222: PUSH
40223: LD_INT 0
40225: PUSH
40226: LD_INT 0
40228: PUSH
40229: EMPTY
40230: LIST
40231: LIST
40232: PUSH
40233: LD_INT 0
40235: PUSH
40236: LD_INT 1
40238: NEG
40239: PUSH
40240: EMPTY
40241: LIST
40242: LIST
40243: PUSH
40244: LD_INT 1
40246: PUSH
40247: LD_INT 0
40249: PUSH
40250: EMPTY
40251: LIST
40252: LIST
40253: PUSH
40254: LD_INT 1
40256: PUSH
40257: LD_INT 1
40259: PUSH
40260: EMPTY
40261: LIST
40262: LIST
40263: PUSH
40264: LD_INT 0
40266: PUSH
40267: LD_INT 1
40269: PUSH
40270: EMPTY
40271: LIST
40272: LIST
40273: PUSH
40274: LD_INT 1
40276: NEG
40277: PUSH
40278: LD_INT 0
40280: PUSH
40281: EMPTY
40282: LIST
40283: LIST
40284: PUSH
40285: LD_INT 1
40287: NEG
40288: PUSH
40289: LD_INT 1
40291: NEG
40292: PUSH
40293: EMPTY
40294: LIST
40295: LIST
40296: PUSH
40297: LD_INT 1
40299: NEG
40300: PUSH
40301: LD_INT 2
40303: NEG
40304: PUSH
40305: EMPTY
40306: LIST
40307: LIST
40308: PUSH
40309: LD_INT 1
40311: PUSH
40312: LD_INT 1
40314: NEG
40315: PUSH
40316: EMPTY
40317: LIST
40318: LIST
40319: PUSH
40320: LD_INT 2
40322: PUSH
40323: LD_INT 0
40325: PUSH
40326: EMPTY
40327: LIST
40328: LIST
40329: PUSH
40330: LD_INT 2
40332: PUSH
40333: LD_INT 1
40335: PUSH
40336: EMPTY
40337: LIST
40338: LIST
40339: PUSH
40340: LD_INT 2
40342: PUSH
40343: LD_INT 2
40345: PUSH
40346: EMPTY
40347: LIST
40348: LIST
40349: PUSH
40350: LD_INT 1
40352: PUSH
40353: LD_INT 2
40355: PUSH
40356: EMPTY
40357: LIST
40358: LIST
40359: PUSH
40360: LD_INT 1
40362: NEG
40363: PUSH
40364: LD_INT 1
40366: PUSH
40367: EMPTY
40368: LIST
40369: LIST
40370: PUSH
40371: LD_INT 2
40373: NEG
40374: PUSH
40375: LD_INT 0
40377: PUSH
40378: EMPTY
40379: LIST
40380: LIST
40381: PUSH
40382: LD_INT 2
40384: NEG
40385: PUSH
40386: LD_INT 1
40388: NEG
40389: PUSH
40390: EMPTY
40391: LIST
40392: LIST
40393: PUSH
40394: LD_INT 2
40396: NEG
40397: PUSH
40398: LD_INT 2
40400: NEG
40401: PUSH
40402: EMPTY
40403: LIST
40404: LIST
40405: PUSH
40406: LD_INT 2
40408: NEG
40409: PUSH
40410: LD_INT 3
40412: NEG
40413: PUSH
40414: EMPTY
40415: LIST
40416: LIST
40417: PUSH
40418: LD_INT 2
40420: PUSH
40421: LD_INT 1
40423: NEG
40424: PUSH
40425: EMPTY
40426: LIST
40427: LIST
40428: PUSH
40429: LD_INT 3
40431: PUSH
40432: LD_INT 0
40434: PUSH
40435: EMPTY
40436: LIST
40437: LIST
40438: PUSH
40439: LD_INT 3
40441: PUSH
40442: LD_INT 1
40444: PUSH
40445: EMPTY
40446: LIST
40447: LIST
40448: PUSH
40449: LD_INT 3
40451: PUSH
40452: LD_INT 2
40454: PUSH
40455: EMPTY
40456: LIST
40457: LIST
40458: PUSH
40459: LD_INT 3
40461: PUSH
40462: LD_INT 3
40464: PUSH
40465: EMPTY
40466: LIST
40467: LIST
40468: PUSH
40469: LD_INT 2
40471: PUSH
40472: LD_INT 3
40474: PUSH
40475: EMPTY
40476: LIST
40477: LIST
40478: PUSH
40479: LD_INT 2
40481: NEG
40482: PUSH
40483: LD_INT 1
40485: PUSH
40486: EMPTY
40487: LIST
40488: LIST
40489: PUSH
40490: LD_INT 3
40492: NEG
40493: PUSH
40494: LD_INT 0
40496: PUSH
40497: EMPTY
40498: LIST
40499: LIST
40500: PUSH
40501: LD_INT 3
40503: NEG
40504: PUSH
40505: LD_INT 1
40507: NEG
40508: PUSH
40509: EMPTY
40510: LIST
40511: LIST
40512: PUSH
40513: LD_INT 3
40515: NEG
40516: PUSH
40517: LD_INT 2
40519: NEG
40520: PUSH
40521: EMPTY
40522: LIST
40523: LIST
40524: PUSH
40525: LD_INT 3
40527: NEG
40528: PUSH
40529: LD_INT 3
40531: NEG
40532: PUSH
40533: EMPTY
40534: LIST
40535: LIST
40536: PUSH
40537: EMPTY
40538: LIST
40539: LIST
40540: LIST
40541: LIST
40542: LIST
40543: LIST
40544: LIST
40545: LIST
40546: LIST
40547: LIST
40548: LIST
40549: LIST
40550: LIST
40551: LIST
40552: LIST
40553: LIST
40554: LIST
40555: LIST
40556: LIST
40557: LIST
40558: LIST
40559: LIST
40560: LIST
40561: LIST
40562: LIST
40563: LIST
40564: LIST
40565: LIST
40566: LIST
40567: ST_TO_ADDR
// fLab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
40568: LD_ADDR_VAR 0 42
40572: PUSH
40573: LD_INT 0
40575: PUSH
40576: LD_INT 0
40578: PUSH
40579: EMPTY
40580: LIST
40581: LIST
40582: PUSH
40583: LD_INT 0
40585: PUSH
40586: LD_INT 1
40588: NEG
40589: PUSH
40590: EMPTY
40591: LIST
40592: LIST
40593: PUSH
40594: LD_INT 1
40596: PUSH
40597: LD_INT 0
40599: PUSH
40600: EMPTY
40601: LIST
40602: LIST
40603: PUSH
40604: LD_INT 1
40606: PUSH
40607: LD_INT 1
40609: PUSH
40610: EMPTY
40611: LIST
40612: LIST
40613: PUSH
40614: LD_INT 0
40616: PUSH
40617: LD_INT 1
40619: PUSH
40620: EMPTY
40621: LIST
40622: LIST
40623: PUSH
40624: LD_INT 1
40626: NEG
40627: PUSH
40628: LD_INT 0
40630: PUSH
40631: EMPTY
40632: LIST
40633: LIST
40634: PUSH
40635: LD_INT 1
40637: NEG
40638: PUSH
40639: LD_INT 1
40641: NEG
40642: PUSH
40643: EMPTY
40644: LIST
40645: LIST
40646: PUSH
40647: LD_INT 1
40649: NEG
40650: PUSH
40651: LD_INT 2
40653: NEG
40654: PUSH
40655: EMPTY
40656: LIST
40657: LIST
40658: PUSH
40659: LD_INT 0
40661: PUSH
40662: LD_INT 2
40664: NEG
40665: PUSH
40666: EMPTY
40667: LIST
40668: LIST
40669: PUSH
40670: LD_INT 1
40672: PUSH
40673: LD_INT 1
40675: NEG
40676: PUSH
40677: EMPTY
40678: LIST
40679: LIST
40680: PUSH
40681: LD_INT 2
40683: PUSH
40684: LD_INT 1
40686: PUSH
40687: EMPTY
40688: LIST
40689: LIST
40690: PUSH
40691: LD_INT 2
40693: PUSH
40694: LD_INT 2
40696: PUSH
40697: EMPTY
40698: LIST
40699: LIST
40700: PUSH
40701: LD_INT 1
40703: PUSH
40704: LD_INT 2
40706: PUSH
40707: EMPTY
40708: LIST
40709: LIST
40710: PUSH
40711: LD_INT 0
40713: PUSH
40714: LD_INT 2
40716: PUSH
40717: EMPTY
40718: LIST
40719: LIST
40720: PUSH
40721: LD_INT 1
40723: NEG
40724: PUSH
40725: LD_INT 1
40727: PUSH
40728: EMPTY
40729: LIST
40730: LIST
40731: PUSH
40732: LD_INT 2
40734: NEG
40735: PUSH
40736: LD_INT 1
40738: NEG
40739: PUSH
40740: EMPTY
40741: LIST
40742: LIST
40743: PUSH
40744: LD_INT 2
40746: NEG
40747: PUSH
40748: LD_INT 2
40750: NEG
40751: PUSH
40752: EMPTY
40753: LIST
40754: LIST
40755: PUSH
40756: LD_INT 2
40758: NEG
40759: PUSH
40760: LD_INT 3
40762: NEG
40763: PUSH
40764: EMPTY
40765: LIST
40766: LIST
40767: PUSH
40768: LD_INT 1
40770: NEG
40771: PUSH
40772: LD_INT 3
40774: NEG
40775: PUSH
40776: EMPTY
40777: LIST
40778: LIST
40779: PUSH
40780: LD_INT 0
40782: PUSH
40783: LD_INT 3
40785: NEG
40786: PUSH
40787: EMPTY
40788: LIST
40789: LIST
40790: PUSH
40791: LD_INT 1
40793: PUSH
40794: LD_INT 2
40796: NEG
40797: PUSH
40798: EMPTY
40799: LIST
40800: LIST
40801: PUSH
40802: LD_INT 3
40804: PUSH
40805: LD_INT 2
40807: PUSH
40808: EMPTY
40809: LIST
40810: LIST
40811: PUSH
40812: LD_INT 3
40814: PUSH
40815: LD_INT 3
40817: PUSH
40818: EMPTY
40819: LIST
40820: LIST
40821: PUSH
40822: LD_INT 2
40824: PUSH
40825: LD_INT 3
40827: PUSH
40828: EMPTY
40829: LIST
40830: LIST
40831: PUSH
40832: LD_INT 1
40834: PUSH
40835: LD_INT 3
40837: PUSH
40838: EMPTY
40839: LIST
40840: LIST
40841: PUSH
40842: LD_INT 0
40844: PUSH
40845: LD_INT 3
40847: PUSH
40848: EMPTY
40849: LIST
40850: LIST
40851: PUSH
40852: LD_INT 1
40854: NEG
40855: PUSH
40856: LD_INT 2
40858: PUSH
40859: EMPTY
40860: LIST
40861: LIST
40862: PUSH
40863: LD_INT 3
40865: NEG
40866: PUSH
40867: LD_INT 2
40869: NEG
40870: PUSH
40871: EMPTY
40872: LIST
40873: LIST
40874: PUSH
40875: LD_INT 3
40877: NEG
40878: PUSH
40879: LD_INT 3
40881: NEG
40882: PUSH
40883: EMPTY
40884: LIST
40885: LIST
40886: PUSH
40887: EMPTY
40888: LIST
40889: LIST
40890: LIST
40891: LIST
40892: LIST
40893: LIST
40894: LIST
40895: LIST
40896: LIST
40897: LIST
40898: LIST
40899: LIST
40900: LIST
40901: LIST
40902: LIST
40903: LIST
40904: LIST
40905: LIST
40906: LIST
40907: LIST
40908: LIST
40909: LIST
40910: LIST
40911: LIST
40912: LIST
40913: LIST
40914: LIST
40915: LIST
40916: LIST
40917: ST_TO_ADDR
// fLab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
40918: LD_ADDR_VAR 0 43
40922: PUSH
40923: LD_INT 0
40925: PUSH
40926: LD_INT 0
40928: PUSH
40929: EMPTY
40930: LIST
40931: LIST
40932: PUSH
40933: LD_INT 0
40935: PUSH
40936: LD_INT 1
40938: NEG
40939: PUSH
40940: EMPTY
40941: LIST
40942: LIST
40943: PUSH
40944: LD_INT 1
40946: PUSH
40947: LD_INT 0
40949: PUSH
40950: EMPTY
40951: LIST
40952: LIST
40953: PUSH
40954: LD_INT 1
40956: PUSH
40957: LD_INT 1
40959: PUSH
40960: EMPTY
40961: LIST
40962: LIST
40963: PUSH
40964: LD_INT 0
40966: PUSH
40967: LD_INT 1
40969: PUSH
40970: EMPTY
40971: LIST
40972: LIST
40973: PUSH
40974: LD_INT 1
40976: NEG
40977: PUSH
40978: LD_INT 0
40980: PUSH
40981: EMPTY
40982: LIST
40983: LIST
40984: PUSH
40985: LD_INT 1
40987: NEG
40988: PUSH
40989: LD_INT 1
40991: NEG
40992: PUSH
40993: EMPTY
40994: LIST
40995: LIST
40996: PUSH
40997: LD_INT 1
40999: NEG
41000: PUSH
41001: LD_INT 2
41003: NEG
41004: PUSH
41005: EMPTY
41006: LIST
41007: LIST
41008: PUSH
41009: LD_INT 0
41011: PUSH
41012: LD_INT 2
41014: NEG
41015: PUSH
41016: EMPTY
41017: LIST
41018: LIST
41019: PUSH
41020: LD_INT 1
41022: PUSH
41023: LD_INT 1
41025: NEG
41026: PUSH
41027: EMPTY
41028: LIST
41029: LIST
41030: PUSH
41031: LD_INT 2
41033: PUSH
41034: LD_INT 0
41036: PUSH
41037: EMPTY
41038: LIST
41039: LIST
41040: PUSH
41041: LD_INT 2
41043: PUSH
41044: LD_INT 1
41046: PUSH
41047: EMPTY
41048: LIST
41049: LIST
41050: PUSH
41051: LD_INT 1
41053: PUSH
41054: LD_INT 2
41056: PUSH
41057: EMPTY
41058: LIST
41059: LIST
41060: PUSH
41061: LD_INT 0
41063: PUSH
41064: LD_INT 2
41066: PUSH
41067: EMPTY
41068: LIST
41069: LIST
41070: PUSH
41071: LD_INT 1
41073: NEG
41074: PUSH
41075: LD_INT 1
41077: PUSH
41078: EMPTY
41079: LIST
41080: LIST
41081: PUSH
41082: LD_INT 2
41084: NEG
41085: PUSH
41086: LD_INT 0
41088: PUSH
41089: EMPTY
41090: LIST
41091: LIST
41092: PUSH
41093: LD_INT 2
41095: NEG
41096: PUSH
41097: LD_INT 1
41099: NEG
41100: PUSH
41101: EMPTY
41102: LIST
41103: LIST
41104: PUSH
41105: LD_INT 1
41107: NEG
41108: PUSH
41109: LD_INT 3
41111: NEG
41112: PUSH
41113: EMPTY
41114: LIST
41115: LIST
41116: PUSH
41117: LD_INT 0
41119: PUSH
41120: LD_INT 3
41122: NEG
41123: PUSH
41124: EMPTY
41125: LIST
41126: LIST
41127: PUSH
41128: LD_INT 1
41130: PUSH
41131: LD_INT 2
41133: NEG
41134: PUSH
41135: EMPTY
41136: LIST
41137: LIST
41138: PUSH
41139: LD_INT 2
41141: PUSH
41142: LD_INT 1
41144: NEG
41145: PUSH
41146: EMPTY
41147: LIST
41148: LIST
41149: PUSH
41150: LD_INT 3
41152: PUSH
41153: LD_INT 0
41155: PUSH
41156: EMPTY
41157: LIST
41158: LIST
41159: PUSH
41160: LD_INT 3
41162: PUSH
41163: LD_INT 1
41165: PUSH
41166: EMPTY
41167: LIST
41168: LIST
41169: PUSH
41170: LD_INT 1
41172: PUSH
41173: LD_INT 3
41175: PUSH
41176: EMPTY
41177: LIST
41178: LIST
41179: PUSH
41180: LD_INT 0
41182: PUSH
41183: LD_INT 3
41185: PUSH
41186: EMPTY
41187: LIST
41188: LIST
41189: PUSH
41190: LD_INT 1
41192: NEG
41193: PUSH
41194: LD_INT 2
41196: PUSH
41197: EMPTY
41198: LIST
41199: LIST
41200: PUSH
41201: LD_INT 2
41203: NEG
41204: PUSH
41205: LD_INT 1
41207: PUSH
41208: EMPTY
41209: LIST
41210: LIST
41211: PUSH
41212: LD_INT 3
41214: NEG
41215: PUSH
41216: LD_INT 0
41218: PUSH
41219: EMPTY
41220: LIST
41221: LIST
41222: PUSH
41223: LD_INT 3
41225: NEG
41226: PUSH
41227: LD_INT 1
41229: NEG
41230: PUSH
41231: EMPTY
41232: LIST
41233: LIST
41234: PUSH
41235: EMPTY
41236: LIST
41237: LIST
41238: LIST
41239: LIST
41240: LIST
41241: LIST
41242: LIST
41243: LIST
41244: LIST
41245: LIST
41246: LIST
41247: LIST
41248: LIST
41249: LIST
41250: LIST
41251: LIST
41252: LIST
41253: LIST
41254: LIST
41255: LIST
41256: LIST
41257: LIST
41258: LIST
41259: LIST
41260: LIST
41261: LIST
41262: LIST
41263: LIST
41264: LIST
41265: ST_TO_ADDR
// fLab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
41266: LD_ADDR_VAR 0 44
41270: PUSH
41271: LD_INT 0
41273: PUSH
41274: LD_INT 0
41276: PUSH
41277: EMPTY
41278: LIST
41279: LIST
41280: PUSH
41281: LD_INT 0
41283: PUSH
41284: LD_INT 1
41286: NEG
41287: PUSH
41288: EMPTY
41289: LIST
41290: LIST
41291: PUSH
41292: LD_INT 1
41294: PUSH
41295: LD_INT 0
41297: PUSH
41298: EMPTY
41299: LIST
41300: LIST
41301: PUSH
41302: LD_INT 1
41304: PUSH
41305: LD_INT 1
41307: PUSH
41308: EMPTY
41309: LIST
41310: LIST
41311: PUSH
41312: LD_INT 0
41314: PUSH
41315: LD_INT 1
41317: PUSH
41318: EMPTY
41319: LIST
41320: LIST
41321: PUSH
41322: LD_INT 1
41324: NEG
41325: PUSH
41326: LD_INT 0
41328: PUSH
41329: EMPTY
41330: LIST
41331: LIST
41332: PUSH
41333: LD_INT 1
41335: NEG
41336: PUSH
41337: LD_INT 1
41339: NEG
41340: PUSH
41341: EMPTY
41342: LIST
41343: LIST
41344: PUSH
41345: LD_INT 1
41347: NEG
41348: PUSH
41349: LD_INT 2
41351: NEG
41352: PUSH
41353: EMPTY
41354: LIST
41355: LIST
41356: PUSH
41357: LD_INT 1
41359: PUSH
41360: LD_INT 1
41362: NEG
41363: PUSH
41364: EMPTY
41365: LIST
41366: LIST
41367: PUSH
41368: LD_INT 2
41370: PUSH
41371: LD_INT 0
41373: PUSH
41374: EMPTY
41375: LIST
41376: LIST
41377: PUSH
41378: LD_INT 2
41380: PUSH
41381: LD_INT 1
41383: PUSH
41384: EMPTY
41385: LIST
41386: LIST
41387: PUSH
41388: LD_INT 2
41390: PUSH
41391: LD_INT 2
41393: PUSH
41394: EMPTY
41395: LIST
41396: LIST
41397: PUSH
41398: LD_INT 1
41400: PUSH
41401: LD_INT 2
41403: PUSH
41404: EMPTY
41405: LIST
41406: LIST
41407: PUSH
41408: LD_INT 1
41410: NEG
41411: PUSH
41412: LD_INT 1
41414: PUSH
41415: EMPTY
41416: LIST
41417: LIST
41418: PUSH
41419: LD_INT 2
41421: NEG
41422: PUSH
41423: LD_INT 0
41425: PUSH
41426: EMPTY
41427: LIST
41428: LIST
41429: PUSH
41430: LD_INT 2
41432: NEG
41433: PUSH
41434: LD_INT 1
41436: NEG
41437: PUSH
41438: EMPTY
41439: LIST
41440: LIST
41441: PUSH
41442: LD_INT 2
41444: NEG
41445: PUSH
41446: LD_INT 2
41448: NEG
41449: PUSH
41450: EMPTY
41451: LIST
41452: LIST
41453: PUSH
41454: LD_INT 2
41456: NEG
41457: PUSH
41458: LD_INT 3
41460: NEG
41461: PUSH
41462: EMPTY
41463: LIST
41464: LIST
41465: PUSH
41466: LD_INT 2
41468: PUSH
41469: LD_INT 1
41471: NEG
41472: PUSH
41473: EMPTY
41474: LIST
41475: LIST
41476: PUSH
41477: LD_INT 3
41479: PUSH
41480: LD_INT 0
41482: PUSH
41483: EMPTY
41484: LIST
41485: LIST
41486: PUSH
41487: LD_INT 3
41489: PUSH
41490: LD_INT 1
41492: PUSH
41493: EMPTY
41494: LIST
41495: LIST
41496: PUSH
41497: LD_INT 3
41499: PUSH
41500: LD_INT 2
41502: PUSH
41503: EMPTY
41504: LIST
41505: LIST
41506: PUSH
41507: LD_INT 3
41509: PUSH
41510: LD_INT 3
41512: PUSH
41513: EMPTY
41514: LIST
41515: LIST
41516: PUSH
41517: LD_INT 2
41519: PUSH
41520: LD_INT 3
41522: PUSH
41523: EMPTY
41524: LIST
41525: LIST
41526: PUSH
41527: LD_INT 2
41529: NEG
41530: PUSH
41531: LD_INT 1
41533: PUSH
41534: EMPTY
41535: LIST
41536: LIST
41537: PUSH
41538: LD_INT 3
41540: NEG
41541: PUSH
41542: LD_INT 0
41544: PUSH
41545: EMPTY
41546: LIST
41547: LIST
41548: PUSH
41549: LD_INT 3
41551: NEG
41552: PUSH
41553: LD_INT 1
41555: NEG
41556: PUSH
41557: EMPTY
41558: LIST
41559: LIST
41560: PUSH
41561: LD_INT 3
41563: NEG
41564: PUSH
41565: LD_INT 2
41567: NEG
41568: PUSH
41569: EMPTY
41570: LIST
41571: LIST
41572: PUSH
41573: LD_INT 3
41575: NEG
41576: PUSH
41577: LD_INT 3
41579: NEG
41580: PUSH
41581: EMPTY
41582: LIST
41583: LIST
41584: PUSH
41585: EMPTY
41586: LIST
41587: LIST
41588: LIST
41589: LIST
41590: LIST
41591: LIST
41592: LIST
41593: LIST
41594: LIST
41595: LIST
41596: LIST
41597: LIST
41598: LIST
41599: LIST
41600: LIST
41601: LIST
41602: LIST
41603: LIST
41604: LIST
41605: LIST
41606: LIST
41607: LIST
41608: LIST
41609: LIST
41610: LIST
41611: LIST
41612: LIST
41613: LIST
41614: LIST
41615: ST_TO_ADDR
// fLab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
41616: LD_ADDR_VAR 0 45
41620: PUSH
41621: LD_INT 0
41623: PUSH
41624: LD_INT 0
41626: PUSH
41627: EMPTY
41628: LIST
41629: LIST
41630: PUSH
41631: LD_INT 0
41633: PUSH
41634: LD_INT 1
41636: NEG
41637: PUSH
41638: EMPTY
41639: LIST
41640: LIST
41641: PUSH
41642: LD_INT 1
41644: PUSH
41645: LD_INT 0
41647: PUSH
41648: EMPTY
41649: LIST
41650: LIST
41651: PUSH
41652: LD_INT 1
41654: PUSH
41655: LD_INT 1
41657: PUSH
41658: EMPTY
41659: LIST
41660: LIST
41661: PUSH
41662: LD_INT 0
41664: PUSH
41665: LD_INT 1
41667: PUSH
41668: EMPTY
41669: LIST
41670: LIST
41671: PUSH
41672: LD_INT 1
41674: NEG
41675: PUSH
41676: LD_INT 0
41678: PUSH
41679: EMPTY
41680: LIST
41681: LIST
41682: PUSH
41683: LD_INT 1
41685: NEG
41686: PUSH
41687: LD_INT 1
41689: NEG
41690: PUSH
41691: EMPTY
41692: LIST
41693: LIST
41694: PUSH
41695: LD_INT 1
41697: NEG
41698: PUSH
41699: LD_INT 2
41701: NEG
41702: PUSH
41703: EMPTY
41704: LIST
41705: LIST
41706: PUSH
41707: LD_INT 0
41709: PUSH
41710: LD_INT 2
41712: NEG
41713: PUSH
41714: EMPTY
41715: LIST
41716: LIST
41717: PUSH
41718: LD_INT 1
41720: PUSH
41721: LD_INT 1
41723: NEG
41724: PUSH
41725: EMPTY
41726: LIST
41727: LIST
41728: PUSH
41729: LD_INT 2
41731: PUSH
41732: LD_INT 1
41734: PUSH
41735: EMPTY
41736: LIST
41737: LIST
41738: PUSH
41739: LD_INT 2
41741: PUSH
41742: LD_INT 2
41744: PUSH
41745: EMPTY
41746: LIST
41747: LIST
41748: PUSH
41749: LD_INT 1
41751: PUSH
41752: LD_INT 2
41754: PUSH
41755: EMPTY
41756: LIST
41757: LIST
41758: PUSH
41759: LD_INT 0
41761: PUSH
41762: LD_INT 2
41764: PUSH
41765: EMPTY
41766: LIST
41767: LIST
41768: PUSH
41769: LD_INT 1
41771: NEG
41772: PUSH
41773: LD_INT 1
41775: PUSH
41776: EMPTY
41777: LIST
41778: LIST
41779: PUSH
41780: LD_INT 2
41782: NEG
41783: PUSH
41784: LD_INT 1
41786: NEG
41787: PUSH
41788: EMPTY
41789: LIST
41790: LIST
41791: PUSH
41792: LD_INT 2
41794: NEG
41795: PUSH
41796: LD_INT 2
41798: NEG
41799: PUSH
41800: EMPTY
41801: LIST
41802: LIST
41803: PUSH
41804: LD_INT 2
41806: NEG
41807: PUSH
41808: LD_INT 3
41810: NEG
41811: PUSH
41812: EMPTY
41813: LIST
41814: LIST
41815: PUSH
41816: LD_INT 1
41818: NEG
41819: PUSH
41820: LD_INT 3
41822: NEG
41823: PUSH
41824: EMPTY
41825: LIST
41826: LIST
41827: PUSH
41828: LD_INT 0
41830: PUSH
41831: LD_INT 3
41833: NEG
41834: PUSH
41835: EMPTY
41836: LIST
41837: LIST
41838: PUSH
41839: LD_INT 1
41841: PUSH
41842: LD_INT 2
41844: NEG
41845: PUSH
41846: EMPTY
41847: LIST
41848: LIST
41849: PUSH
41850: LD_INT 3
41852: PUSH
41853: LD_INT 2
41855: PUSH
41856: EMPTY
41857: LIST
41858: LIST
41859: PUSH
41860: LD_INT 3
41862: PUSH
41863: LD_INT 3
41865: PUSH
41866: EMPTY
41867: LIST
41868: LIST
41869: PUSH
41870: LD_INT 2
41872: PUSH
41873: LD_INT 3
41875: PUSH
41876: EMPTY
41877: LIST
41878: LIST
41879: PUSH
41880: LD_INT 1
41882: PUSH
41883: LD_INT 3
41885: PUSH
41886: EMPTY
41887: LIST
41888: LIST
41889: PUSH
41890: LD_INT 0
41892: PUSH
41893: LD_INT 3
41895: PUSH
41896: EMPTY
41897: LIST
41898: LIST
41899: PUSH
41900: LD_INT 1
41902: NEG
41903: PUSH
41904: LD_INT 2
41906: PUSH
41907: EMPTY
41908: LIST
41909: LIST
41910: PUSH
41911: LD_INT 3
41913: NEG
41914: PUSH
41915: LD_INT 2
41917: NEG
41918: PUSH
41919: EMPTY
41920: LIST
41921: LIST
41922: PUSH
41923: LD_INT 3
41925: NEG
41926: PUSH
41927: LD_INT 3
41929: NEG
41930: PUSH
41931: EMPTY
41932: LIST
41933: LIST
41934: PUSH
41935: EMPTY
41936: LIST
41937: LIST
41938: LIST
41939: LIST
41940: LIST
41941: LIST
41942: LIST
41943: LIST
41944: LIST
41945: LIST
41946: LIST
41947: LIST
41948: LIST
41949: LIST
41950: LIST
41951: LIST
41952: LIST
41953: LIST
41954: LIST
41955: LIST
41956: LIST
41957: LIST
41958: LIST
41959: LIST
41960: LIST
41961: LIST
41962: LIST
41963: LIST
41964: LIST
41965: ST_TO_ADDR
// fLab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
41966: LD_ADDR_VAR 0 46
41970: PUSH
41971: LD_INT 0
41973: PUSH
41974: LD_INT 0
41976: PUSH
41977: EMPTY
41978: LIST
41979: LIST
41980: PUSH
41981: LD_INT 0
41983: PUSH
41984: LD_INT 1
41986: NEG
41987: PUSH
41988: EMPTY
41989: LIST
41990: LIST
41991: PUSH
41992: LD_INT 1
41994: PUSH
41995: LD_INT 0
41997: PUSH
41998: EMPTY
41999: LIST
42000: LIST
42001: PUSH
42002: LD_INT 1
42004: PUSH
42005: LD_INT 1
42007: PUSH
42008: EMPTY
42009: LIST
42010: LIST
42011: PUSH
42012: LD_INT 0
42014: PUSH
42015: LD_INT 1
42017: PUSH
42018: EMPTY
42019: LIST
42020: LIST
42021: PUSH
42022: LD_INT 1
42024: NEG
42025: PUSH
42026: LD_INT 0
42028: PUSH
42029: EMPTY
42030: LIST
42031: LIST
42032: PUSH
42033: LD_INT 1
42035: NEG
42036: PUSH
42037: LD_INT 1
42039: NEG
42040: PUSH
42041: EMPTY
42042: LIST
42043: LIST
42044: PUSH
42045: LD_INT 1
42047: NEG
42048: PUSH
42049: LD_INT 2
42051: NEG
42052: PUSH
42053: EMPTY
42054: LIST
42055: LIST
42056: PUSH
42057: LD_INT 0
42059: PUSH
42060: LD_INT 2
42062: NEG
42063: PUSH
42064: EMPTY
42065: LIST
42066: LIST
42067: PUSH
42068: LD_INT 1
42070: PUSH
42071: LD_INT 1
42073: NEG
42074: PUSH
42075: EMPTY
42076: LIST
42077: LIST
42078: PUSH
42079: LD_INT 2
42081: PUSH
42082: LD_INT 0
42084: PUSH
42085: EMPTY
42086: LIST
42087: LIST
42088: PUSH
42089: LD_INT 2
42091: PUSH
42092: LD_INT 1
42094: PUSH
42095: EMPTY
42096: LIST
42097: LIST
42098: PUSH
42099: LD_INT 1
42101: PUSH
42102: LD_INT 2
42104: PUSH
42105: EMPTY
42106: LIST
42107: LIST
42108: PUSH
42109: LD_INT 0
42111: PUSH
42112: LD_INT 2
42114: PUSH
42115: EMPTY
42116: LIST
42117: LIST
42118: PUSH
42119: LD_INT 1
42121: NEG
42122: PUSH
42123: LD_INT 1
42125: PUSH
42126: EMPTY
42127: LIST
42128: LIST
42129: PUSH
42130: LD_INT 2
42132: NEG
42133: PUSH
42134: LD_INT 0
42136: PUSH
42137: EMPTY
42138: LIST
42139: LIST
42140: PUSH
42141: LD_INT 2
42143: NEG
42144: PUSH
42145: LD_INT 1
42147: NEG
42148: PUSH
42149: EMPTY
42150: LIST
42151: LIST
42152: PUSH
42153: LD_INT 1
42155: NEG
42156: PUSH
42157: LD_INT 3
42159: NEG
42160: PUSH
42161: EMPTY
42162: LIST
42163: LIST
42164: PUSH
42165: LD_INT 0
42167: PUSH
42168: LD_INT 3
42170: NEG
42171: PUSH
42172: EMPTY
42173: LIST
42174: LIST
42175: PUSH
42176: LD_INT 1
42178: PUSH
42179: LD_INT 2
42181: NEG
42182: PUSH
42183: EMPTY
42184: LIST
42185: LIST
42186: PUSH
42187: LD_INT 2
42189: PUSH
42190: LD_INT 1
42192: NEG
42193: PUSH
42194: EMPTY
42195: LIST
42196: LIST
42197: PUSH
42198: LD_INT 3
42200: PUSH
42201: LD_INT 0
42203: PUSH
42204: EMPTY
42205: LIST
42206: LIST
42207: PUSH
42208: LD_INT 3
42210: PUSH
42211: LD_INT 1
42213: PUSH
42214: EMPTY
42215: LIST
42216: LIST
42217: PUSH
42218: LD_INT 1
42220: PUSH
42221: LD_INT 3
42223: PUSH
42224: EMPTY
42225: LIST
42226: LIST
42227: PUSH
42228: LD_INT 0
42230: PUSH
42231: LD_INT 3
42233: PUSH
42234: EMPTY
42235: LIST
42236: LIST
42237: PUSH
42238: LD_INT 1
42240: NEG
42241: PUSH
42242: LD_INT 2
42244: PUSH
42245: EMPTY
42246: LIST
42247: LIST
42248: PUSH
42249: LD_INT 2
42251: NEG
42252: PUSH
42253: LD_INT 1
42255: PUSH
42256: EMPTY
42257: LIST
42258: LIST
42259: PUSH
42260: LD_INT 3
42262: NEG
42263: PUSH
42264: LD_INT 0
42266: PUSH
42267: EMPTY
42268: LIST
42269: LIST
42270: PUSH
42271: LD_INT 3
42273: NEG
42274: PUSH
42275: LD_INT 1
42277: NEG
42278: PUSH
42279: EMPTY
42280: LIST
42281: LIST
42282: PUSH
42283: EMPTY
42284: LIST
42285: LIST
42286: LIST
42287: LIST
42288: LIST
42289: LIST
42290: LIST
42291: LIST
42292: LIST
42293: LIST
42294: LIST
42295: LIST
42296: LIST
42297: LIST
42298: LIST
42299: LIST
42300: LIST
42301: LIST
42302: LIST
42303: LIST
42304: LIST
42305: LIST
42306: LIST
42307: LIST
42308: LIST
42309: LIST
42310: LIST
42311: LIST
42312: LIST
42313: ST_TO_ADDR
// fControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
42314: LD_ADDR_VAR 0 47
42318: PUSH
42319: LD_INT 0
42321: PUSH
42322: LD_INT 0
42324: PUSH
42325: EMPTY
42326: LIST
42327: LIST
42328: PUSH
42329: LD_INT 0
42331: PUSH
42332: LD_INT 1
42334: NEG
42335: PUSH
42336: EMPTY
42337: LIST
42338: LIST
42339: PUSH
42340: LD_INT 1
42342: PUSH
42343: LD_INT 0
42345: PUSH
42346: EMPTY
42347: LIST
42348: LIST
42349: PUSH
42350: LD_INT 1
42352: PUSH
42353: LD_INT 1
42355: PUSH
42356: EMPTY
42357: LIST
42358: LIST
42359: PUSH
42360: LD_INT 0
42362: PUSH
42363: LD_INT 1
42365: PUSH
42366: EMPTY
42367: LIST
42368: LIST
42369: PUSH
42370: LD_INT 1
42372: NEG
42373: PUSH
42374: LD_INT 0
42376: PUSH
42377: EMPTY
42378: LIST
42379: LIST
42380: PUSH
42381: LD_INT 1
42383: NEG
42384: PUSH
42385: LD_INT 1
42387: NEG
42388: PUSH
42389: EMPTY
42390: LIST
42391: LIST
42392: PUSH
42393: LD_INT 1
42395: NEG
42396: PUSH
42397: LD_INT 2
42399: NEG
42400: PUSH
42401: EMPTY
42402: LIST
42403: LIST
42404: PUSH
42405: LD_INT 0
42407: PUSH
42408: LD_INT 2
42410: NEG
42411: PUSH
42412: EMPTY
42413: LIST
42414: LIST
42415: PUSH
42416: LD_INT 1
42418: PUSH
42419: LD_INT 1
42421: NEG
42422: PUSH
42423: EMPTY
42424: LIST
42425: LIST
42426: PUSH
42427: LD_INT 2
42429: NEG
42430: PUSH
42431: LD_INT 1
42433: NEG
42434: PUSH
42435: EMPTY
42436: LIST
42437: LIST
42438: PUSH
42439: LD_INT 2
42441: NEG
42442: PUSH
42443: LD_INT 2
42445: NEG
42446: PUSH
42447: EMPTY
42448: LIST
42449: LIST
42450: PUSH
42451: EMPTY
42452: LIST
42453: LIST
42454: LIST
42455: LIST
42456: LIST
42457: LIST
42458: LIST
42459: LIST
42460: LIST
42461: LIST
42462: LIST
42463: LIST
42464: ST_TO_ADDR
// fControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
42465: LD_ADDR_VAR 0 48
42469: PUSH
42470: LD_INT 0
42472: PUSH
42473: LD_INT 0
42475: PUSH
42476: EMPTY
42477: LIST
42478: LIST
42479: PUSH
42480: LD_INT 0
42482: PUSH
42483: LD_INT 1
42485: NEG
42486: PUSH
42487: EMPTY
42488: LIST
42489: LIST
42490: PUSH
42491: LD_INT 1
42493: PUSH
42494: LD_INT 0
42496: PUSH
42497: EMPTY
42498: LIST
42499: LIST
42500: PUSH
42501: LD_INT 1
42503: PUSH
42504: LD_INT 1
42506: PUSH
42507: EMPTY
42508: LIST
42509: LIST
42510: PUSH
42511: LD_INT 0
42513: PUSH
42514: LD_INT 1
42516: PUSH
42517: EMPTY
42518: LIST
42519: LIST
42520: PUSH
42521: LD_INT 1
42523: NEG
42524: PUSH
42525: LD_INT 0
42527: PUSH
42528: EMPTY
42529: LIST
42530: LIST
42531: PUSH
42532: LD_INT 1
42534: NEG
42535: PUSH
42536: LD_INT 1
42538: NEG
42539: PUSH
42540: EMPTY
42541: LIST
42542: LIST
42543: PUSH
42544: LD_INT 1
42546: NEG
42547: PUSH
42548: LD_INT 2
42550: NEG
42551: PUSH
42552: EMPTY
42553: LIST
42554: LIST
42555: PUSH
42556: LD_INT 0
42558: PUSH
42559: LD_INT 2
42561: NEG
42562: PUSH
42563: EMPTY
42564: LIST
42565: LIST
42566: PUSH
42567: LD_INT 1
42569: PUSH
42570: LD_INT 1
42572: NEG
42573: PUSH
42574: EMPTY
42575: LIST
42576: LIST
42577: PUSH
42578: LD_INT 2
42580: PUSH
42581: LD_INT 0
42583: PUSH
42584: EMPTY
42585: LIST
42586: LIST
42587: PUSH
42588: LD_INT 2
42590: PUSH
42591: LD_INT 1
42593: PUSH
42594: EMPTY
42595: LIST
42596: LIST
42597: PUSH
42598: EMPTY
42599: LIST
42600: LIST
42601: LIST
42602: LIST
42603: LIST
42604: LIST
42605: LIST
42606: LIST
42607: LIST
42608: LIST
42609: LIST
42610: LIST
42611: ST_TO_ADDR
// fControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
42612: LD_ADDR_VAR 0 49
42616: PUSH
42617: LD_INT 0
42619: PUSH
42620: LD_INT 0
42622: PUSH
42623: EMPTY
42624: LIST
42625: LIST
42626: PUSH
42627: LD_INT 0
42629: PUSH
42630: LD_INT 1
42632: NEG
42633: PUSH
42634: EMPTY
42635: LIST
42636: LIST
42637: PUSH
42638: LD_INT 1
42640: PUSH
42641: LD_INT 0
42643: PUSH
42644: EMPTY
42645: LIST
42646: LIST
42647: PUSH
42648: LD_INT 1
42650: PUSH
42651: LD_INT 1
42653: PUSH
42654: EMPTY
42655: LIST
42656: LIST
42657: PUSH
42658: LD_INT 0
42660: PUSH
42661: LD_INT 1
42663: PUSH
42664: EMPTY
42665: LIST
42666: LIST
42667: PUSH
42668: LD_INT 1
42670: NEG
42671: PUSH
42672: LD_INT 0
42674: PUSH
42675: EMPTY
42676: LIST
42677: LIST
42678: PUSH
42679: LD_INT 1
42681: NEG
42682: PUSH
42683: LD_INT 1
42685: NEG
42686: PUSH
42687: EMPTY
42688: LIST
42689: LIST
42690: PUSH
42691: LD_INT 1
42693: PUSH
42694: LD_INT 1
42696: NEG
42697: PUSH
42698: EMPTY
42699: LIST
42700: LIST
42701: PUSH
42702: LD_INT 2
42704: PUSH
42705: LD_INT 0
42707: PUSH
42708: EMPTY
42709: LIST
42710: LIST
42711: PUSH
42712: LD_INT 2
42714: PUSH
42715: LD_INT 1
42717: PUSH
42718: EMPTY
42719: LIST
42720: LIST
42721: PUSH
42722: LD_INT 2
42724: PUSH
42725: LD_INT 2
42727: PUSH
42728: EMPTY
42729: LIST
42730: LIST
42731: PUSH
42732: LD_INT 1
42734: PUSH
42735: LD_INT 2
42737: PUSH
42738: EMPTY
42739: LIST
42740: LIST
42741: PUSH
42742: EMPTY
42743: LIST
42744: LIST
42745: LIST
42746: LIST
42747: LIST
42748: LIST
42749: LIST
42750: LIST
42751: LIST
42752: LIST
42753: LIST
42754: LIST
42755: ST_TO_ADDR
// fControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
42756: LD_ADDR_VAR 0 50
42760: PUSH
42761: LD_INT 0
42763: PUSH
42764: LD_INT 0
42766: PUSH
42767: EMPTY
42768: LIST
42769: LIST
42770: PUSH
42771: LD_INT 0
42773: PUSH
42774: LD_INT 1
42776: NEG
42777: PUSH
42778: EMPTY
42779: LIST
42780: LIST
42781: PUSH
42782: LD_INT 1
42784: PUSH
42785: LD_INT 0
42787: PUSH
42788: EMPTY
42789: LIST
42790: LIST
42791: PUSH
42792: LD_INT 1
42794: PUSH
42795: LD_INT 1
42797: PUSH
42798: EMPTY
42799: LIST
42800: LIST
42801: PUSH
42802: LD_INT 0
42804: PUSH
42805: LD_INT 1
42807: PUSH
42808: EMPTY
42809: LIST
42810: LIST
42811: PUSH
42812: LD_INT 1
42814: NEG
42815: PUSH
42816: LD_INT 0
42818: PUSH
42819: EMPTY
42820: LIST
42821: LIST
42822: PUSH
42823: LD_INT 1
42825: NEG
42826: PUSH
42827: LD_INT 1
42829: NEG
42830: PUSH
42831: EMPTY
42832: LIST
42833: LIST
42834: PUSH
42835: LD_INT 2
42837: PUSH
42838: LD_INT 1
42840: PUSH
42841: EMPTY
42842: LIST
42843: LIST
42844: PUSH
42845: LD_INT 2
42847: PUSH
42848: LD_INT 2
42850: PUSH
42851: EMPTY
42852: LIST
42853: LIST
42854: PUSH
42855: LD_INT 1
42857: PUSH
42858: LD_INT 2
42860: PUSH
42861: EMPTY
42862: LIST
42863: LIST
42864: PUSH
42865: LD_INT 0
42867: PUSH
42868: LD_INT 2
42870: PUSH
42871: EMPTY
42872: LIST
42873: LIST
42874: PUSH
42875: LD_INT 1
42877: NEG
42878: PUSH
42879: LD_INT 1
42881: PUSH
42882: EMPTY
42883: LIST
42884: LIST
42885: PUSH
42886: EMPTY
42887: LIST
42888: LIST
42889: LIST
42890: LIST
42891: LIST
42892: LIST
42893: LIST
42894: LIST
42895: LIST
42896: LIST
42897: LIST
42898: LIST
42899: ST_TO_ADDR
// fControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
42900: LD_ADDR_VAR 0 51
42904: PUSH
42905: LD_INT 0
42907: PUSH
42908: LD_INT 0
42910: PUSH
42911: EMPTY
42912: LIST
42913: LIST
42914: PUSH
42915: LD_INT 0
42917: PUSH
42918: LD_INT 1
42920: NEG
42921: PUSH
42922: EMPTY
42923: LIST
42924: LIST
42925: PUSH
42926: LD_INT 1
42928: PUSH
42929: LD_INT 0
42931: PUSH
42932: EMPTY
42933: LIST
42934: LIST
42935: PUSH
42936: LD_INT 1
42938: PUSH
42939: LD_INT 1
42941: PUSH
42942: EMPTY
42943: LIST
42944: LIST
42945: PUSH
42946: LD_INT 0
42948: PUSH
42949: LD_INT 1
42951: PUSH
42952: EMPTY
42953: LIST
42954: LIST
42955: PUSH
42956: LD_INT 1
42958: NEG
42959: PUSH
42960: LD_INT 0
42962: PUSH
42963: EMPTY
42964: LIST
42965: LIST
42966: PUSH
42967: LD_INT 1
42969: NEG
42970: PUSH
42971: LD_INT 1
42973: NEG
42974: PUSH
42975: EMPTY
42976: LIST
42977: LIST
42978: PUSH
42979: LD_INT 1
42981: PUSH
42982: LD_INT 2
42984: PUSH
42985: EMPTY
42986: LIST
42987: LIST
42988: PUSH
42989: LD_INT 0
42991: PUSH
42992: LD_INT 2
42994: PUSH
42995: EMPTY
42996: LIST
42997: LIST
42998: PUSH
42999: LD_INT 1
43001: NEG
43002: PUSH
43003: LD_INT 1
43005: PUSH
43006: EMPTY
43007: LIST
43008: LIST
43009: PUSH
43010: LD_INT 2
43012: NEG
43013: PUSH
43014: LD_INT 0
43016: PUSH
43017: EMPTY
43018: LIST
43019: LIST
43020: PUSH
43021: LD_INT 2
43023: NEG
43024: PUSH
43025: LD_INT 1
43027: NEG
43028: PUSH
43029: EMPTY
43030: LIST
43031: LIST
43032: PUSH
43033: EMPTY
43034: LIST
43035: LIST
43036: LIST
43037: LIST
43038: LIST
43039: LIST
43040: LIST
43041: LIST
43042: LIST
43043: LIST
43044: LIST
43045: LIST
43046: ST_TO_ADDR
// fControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
43047: LD_ADDR_VAR 0 52
43051: PUSH
43052: LD_INT 0
43054: PUSH
43055: LD_INT 0
43057: PUSH
43058: EMPTY
43059: LIST
43060: LIST
43061: PUSH
43062: LD_INT 0
43064: PUSH
43065: LD_INT 1
43067: NEG
43068: PUSH
43069: EMPTY
43070: LIST
43071: LIST
43072: PUSH
43073: LD_INT 1
43075: PUSH
43076: LD_INT 0
43078: PUSH
43079: EMPTY
43080: LIST
43081: LIST
43082: PUSH
43083: LD_INT 1
43085: PUSH
43086: LD_INT 1
43088: PUSH
43089: EMPTY
43090: LIST
43091: LIST
43092: PUSH
43093: LD_INT 0
43095: PUSH
43096: LD_INT 1
43098: PUSH
43099: EMPTY
43100: LIST
43101: LIST
43102: PUSH
43103: LD_INT 1
43105: NEG
43106: PUSH
43107: LD_INT 0
43109: PUSH
43110: EMPTY
43111: LIST
43112: LIST
43113: PUSH
43114: LD_INT 1
43116: NEG
43117: PUSH
43118: LD_INT 1
43120: NEG
43121: PUSH
43122: EMPTY
43123: LIST
43124: LIST
43125: PUSH
43126: LD_INT 1
43128: NEG
43129: PUSH
43130: LD_INT 2
43132: NEG
43133: PUSH
43134: EMPTY
43135: LIST
43136: LIST
43137: PUSH
43138: LD_INT 1
43140: NEG
43141: PUSH
43142: LD_INT 1
43144: PUSH
43145: EMPTY
43146: LIST
43147: LIST
43148: PUSH
43149: LD_INT 2
43151: NEG
43152: PUSH
43153: LD_INT 0
43155: PUSH
43156: EMPTY
43157: LIST
43158: LIST
43159: PUSH
43160: LD_INT 2
43162: NEG
43163: PUSH
43164: LD_INT 1
43166: NEG
43167: PUSH
43168: EMPTY
43169: LIST
43170: LIST
43171: PUSH
43172: LD_INT 2
43174: NEG
43175: PUSH
43176: LD_INT 2
43178: NEG
43179: PUSH
43180: EMPTY
43181: LIST
43182: LIST
43183: PUSH
43184: EMPTY
43185: LIST
43186: LIST
43187: LIST
43188: LIST
43189: LIST
43190: LIST
43191: LIST
43192: LIST
43193: LIST
43194: LIST
43195: LIST
43196: LIST
43197: ST_TO_ADDR
// fBarracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
43198: LD_ADDR_VAR 0 53
43202: PUSH
43203: LD_INT 0
43205: PUSH
43206: LD_INT 0
43208: PUSH
43209: EMPTY
43210: LIST
43211: LIST
43212: PUSH
43213: LD_INT 0
43215: PUSH
43216: LD_INT 1
43218: NEG
43219: PUSH
43220: EMPTY
43221: LIST
43222: LIST
43223: PUSH
43224: LD_INT 1
43226: PUSH
43227: LD_INT 0
43229: PUSH
43230: EMPTY
43231: LIST
43232: LIST
43233: PUSH
43234: LD_INT 1
43236: PUSH
43237: LD_INT 1
43239: PUSH
43240: EMPTY
43241: LIST
43242: LIST
43243: PUSH
43244: LD_INT 0
43246: PUSH
43247: LD_INT 1
43249: PUSH
43250: EMPTY
43251: LIST
43252: LIST
43253: PUSH
43254: LD_INT 1
43256: NEG
43257: PUSH
43258: LD_INT 0
43260: PUSH
43261: EMPTY
43262: LIST
43263: LIST
43264: PUSH
43265: LD_INT 1
43267: NEG
43268: PUSH
43269: LD_INT 1
43271: NEG
43272: PUSH
43273: EMPTY
43274: LIST
43275: LIST
43276: PUSH
43277: LD_INT 1
43279: NEG
43280: PUSH
43281: LD_INT 2
43283: NEG
43284: PUSH
43285: EMPTY
43286: LIST
43287: LIST
43288: PUSH
43289: LD_INT 0
43291: PUSH
43292: LD_INT 2
43294: NEG
43295: PUSH
43296: EMPTY
43297: LIST
43298: LIST
43299: PUSH
43300: LD_INT 1
43302: PUSH
43303: LD_INT 1
43305: NEG
43306: PUSH
43307: EMPTY
43308: LIST
43309: LIST
43310: PUSH
43311: LD_INT 2
43313: PUSH
43314: LD_INT 0
43316: PUSH
43317: EMPTY
43318: LIST
43319: LIST
43320: PUSH
43321: LD_INT 2
43323: PUSH
43324: LD_INT 1
43326: PUSH
43327: EMPTY
43328: LIST
43329: LIST
43330: PUSH
43331: LD_INT 2
43333: PUSH
43334: LD_INT 2
43336: PUSH
43337: EMPTY
43338: LIST
43339: LIST
43340: PUSH
43341: LD_INT 1
43343: PUSH
43344: LD_INT 2
43346: PUSH
43347: EMPTY
43348: LIST
43349: LIST
43350: PUSH
43351: LD_INT 0
43353: PUSH
43354: LD_INT 2
43356: PUSH
43357: EMPTY
43358: LIST
43359: LIST
43360: PUSH
43361: LD_INT 1
43363: NEG
43364: PUSH
43365: LD_INT 1
43367: PUSH
43368: EMPTY
43369: LIST
43370: LIST
43371: PUSH
43372: LD_INT 2
43374: NEG
43375: PUSH
43376: LD_INT 0
43378: PUSH
43379: EMPTY
43380: LIST
43381: LIST
43382: PUSH
43383: LD_INT 2
43385: NEG
43386: PUSH
43387: LD_INT 1
43389: NEG
43390: PUSH
43391: EMPTY
43392: LIST
43393: LIST
43394: PUSH
43395: LD_INT 2
43397: NEG
43398: PUSH
43399: LD_INT 2
43401: NEG
43402: PUSH
43403: EMPTY
43404: LIST
43405: LIST
43406: PUSH
43407: EMPTY
43408: LIST
43409: LIST
43410: LIST
43411: LIST
43412: LIST
43413: LIST
43414: LIST
43415: LIST
43416: LIST
43417: LIST
43418: LIST
43419: LIST
43420: LIST
43421: LIST
43422: LIST
43423: LIST
43424: LIST
43425: LIST
43426: LIST
43427: ST_TO_ADDR
// fBarracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
43428: LD_ADDR_VAR 0 54
43432: PUSH
43433: LD_INT 0
43435: PUSH
43436: LD_INT 0
43438: PUSH
43439: EMPTY
43440: LIST
43441: LIST
43442: PUSH
43443: LD_INT 0
43445: PUSH
43446: LD_INT 1
43448: NEG
43449: PUSH
43450: EMPTY
43451: LIST
43452: LIST
43453: PUSH
43454: LD_INT 1
43456: PUSH
43457: LD_INT 0
43459: PUSH
43460: EMPTY
43461: LIST
43462: LIST
43463: PUSH
43464: LD_INT 1
43466: PUSH
43467: LD_INT 1
43469: PUSH
43470: EMPTY
43471: LIST
43472: LIST
43473: PUSH
43474: LD_INT 0
43476: PUSH
43477: LD_INT 1
43479: PUSH
43480: EMPTY
43481: LIST
43482: LIST
43483: PUSH
43484: LD_INT 1
43486: NEG
43487: PUSH
43488: LD_INT 0
43490: PUSH
43491: EMPTY
43492: LIST
43493: LIST
43494: PUSH
43495: LD_INT 1
43497: NEG
43498: PUSH
43499: LD_INT 1
43501: NEG
43502: PUSH
43503: EMPTY
43504: LIST
43505: LIST
43506: PUSH
43507: LD_INT 1
43509: NEG
43510: PUSH
43511: LD_INT 2
43513: NEG
43514: PUSH
43515: EMPTY
43516: LIST
43517: LIST
43518: PUSH
43519: LD_INT 0
43521: PUSH
43522: LD_INT 2
43524: NEG
43525: PUSH
43526: EMPTY
43527: LIST
43528: LIST
43529: PUSH
43530: LD_INT 1
43532: PUSH
43533: LD_INT 1
43535: NEG
43536: PUSH
43537: EMPTY
43538: LIST
43539: LIST
43540: PUSH
43541: LD_INT 2
43543: PUSH
43544: LD_INT 0
43546: PUSH
43547: EMPTY
43548: LIST
43549: LIST
43550: PUSH
43551: LD_INT 2
43553: PUSH
43554: LD_INT 1
43556: PUSH
43557: EMPTY
43558: LIST
43559: LIST
43560: PUSH
43561: LD_INT 2
43563: PUSH
43564: LD_INT 2
43566: PUSH
43567: EMPTY
43568: LIST
43569: LIST
43570: PUSH
43571: LD_INT 1
43573: PUSH
43574: LD_INT 2
43576: PUSH
43577: EMPTY
43578: LIST
43579: LIST
43580: PUSH
43581: LD_INT 0
43583: PUSH
43584: LD_INT 2
43586: PUSH
43587: EMPTY
43588: LIST
43589: LIST
43590: PUSH
43591: LD_INT 1
43593: NEG
43594: PUSH
43595: LD_INT 1
43597: PUSH
43598: EMPTY
43599: LIST
43600: LIST
43601: PUSH
43602: LD_INT 2
43604: NEG
43605: PUSH
43606: LD_INT 0
43608: PUSH
43609: EMPTY
43610: LIST
43611: LIST
43612: PUSH
43613: LD_INT 2
43615: NEG
43616: PUSH
43617: LD_INT 1
43619: NEG
43620: PUSH
43621: EMPTY
43622: LIST
43623: LIST
43624: PUSH
43625: LD_INT 2
43627: NEG
43628: PUSH
43629: LD_INT 2
43631: NEG
43632: PUSH
43633: EMPTY
43634: LIST
43635: LIST
43636: PUSH
43637: EMPTY
43638: LIST
43639: LIST
43640: LIST
43641: LIST
43642: LIST
43643: LIST
43644: LIST
43645: LIST
43646: LIST
43647: LIST
43648: LIST
43649: LIST
43650: LIST
43651: LIST
43652: LIST
43653: LIST
43654: LIST
43655: LIST
43656: LIST
43657: ST_TO_ADDR
// fBarracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
43658: LD_ADDR_VAR 0 55
43662: PUSH
43663: LD_INT 0
43665: PUSH
43666: LD_INT 0
43668: PUSH
43669: EMPTY
43670: LIST
43671: LIST
43672: PUSH
43673: LD_INT 0
43675: PUSH
43676: LD_INT 1
43678: NEG
43679: PUSH
43680: EMPTY
43681: LIST
43682: LIST
43683: PUSH
43684: LD_INT 1
43686: PUSH
43687: LD_INT 0
43689: PUSH
43690: EMPTY
43691: LIST
43692: LIST
43693: PUSH
43694: LD_INT 1
43696: PUSH
43697: LD_INT 1
43699: PUSH
43700: EMPTY
43701: LIST
43702: LIST
43703: PUSH
43704: LD_INT 0
43706: PUSH
43707: LD_INT 1
43709: PUSH
43710: EMPTY
43711: LIST
43712: LIST
43713: PUSH
43714: LD_INT 1
43716: NEG
43717: PUSH
43718: LD_INT 0
43720: PUSH
43721: EMPTY
43722: LIST
43723: LIST
43724: PUSH
43725: LD_INT 1
43727: NEG
43728: PUSH
43729: LD_INT 1
43731: NEG
43732: PUSH
43733: EMPTY
43734: LIST
43735: LIST
43736: PUSH
43737: LD_INT 1
43739: NEG
43740: PUSH
43741: LD_INT 2
43743: NEG
43744: PUSH
43745: EMPTY
43746: LIST
43747: LIST
43748: PUSH
43749: LD_INT 0
43751: PUSH
43752: LD_INT 2
43754: NEG
43755: PUSH
43756: EMPTY
43757: LIST
43758: LIST
43759: PUSH
43760: LD_INT 1
43762: PUSH
43763: LD_INT 1
43765: NEG
43766: PUSH
43767: EMPTY
43768: LIST
43769: LIST
43770: PUSH
43771: LD_INT 2
43773: PUSH
43774: LD_INT 0
43776: PUSH
43777: EMPTY
43778: LIST
43779: LIST
43780: PUSH
43781: LD_INT 2
43783: PUSH
43784: LD_INT 1
43786: PUSH
43787: EMPTY
43788: LIST
43789: LIST
43790: PUSH
43791: LD_INT 2
43793: PUSH
43794: LD_INT 2
43796: PUSH
43797: EMPTY
43798: LIST
43799: LIST
43800: PUSH
43801: LD_INT 1
43803: PUSH
43804: LD_INT 2
43806: PUSH
43807: EMPTY
43808: LIST
43809: LIST
43810: PUSH
43811: LD_INT 0
43813: PUSH
43814: LD_INT 2
43816: PUSH
43817: EMPTY
43818: LIST
43819: LIST
43820: PUSH
43821: LD_INT 1
43823: NEG
43824: PUSH
43825: LD_INT 1
43827: PUSH
43828: EMPTY
43829: LIST
43830: LIST
43831: PUSH
43832: LD_INT 2
43834: NEG
43835: PUSH
43836: LD_INT 0
43838: PUSH
43839: EMPTY
43840: LIST
43841: LIST
43842: PUSH
43843: LD_INT 2
43845: NEG
43846: PUSH
43847: LD_INT 1
43849: NEG
43850: PUSH
43851: EMPTY
43852: LIST
43853: LIST
43854: PUSH
43855: LD_INT 2
43857: NEG
43858: PUSH
43859: LD_INT 2
43861: NEG
43862: PUSH
43863: EMPTY
43864: LIST
43865: LIST
43866: PUSH
43867: EMPTY
43868: LIST
43869: LIST
43870: LIST
43871: LIST
43872: LIST
43873: LIST
43874: LIST
43875: LIST
43876: LIST
43877: LIST
43878: LIST
43879: LIST
43880: LIST
43881: LIST
43882: LIST
43883: LIST
43884: LIST
43885: LIST
43886: LIST
43887: ST_TO_ADDR
// fBarracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
43888: LD_ADDR_VAR 0 56
43892: PUSH
43893: LD_INT 0
43895: PUSH
43896: LD_INT 0
43898: PUSH
43899: EMPTY
43900: LIST
43901: LIST
43902: PUSH
43903: LD_INT 0
43905: PUSH
43906: LD_INT 1
43908: NEG
43909: PUSH
43910: EMPTY
43911: LIST
43912: LIST
43913: PUSH
43914: LD_INT 1
43916: PUSH
43917: LD_INT 0
43919: PUSH
43920: EMPTY
43921: LIST
43922: LIST
43923: PUSH
43924: LD_INT 1
43926: PUSH
43927: LD_INT 1
43929: PUSH
43930: EMPTY
43931: LIST
43932: LIST
43933: PUSH
43934: LD_INT 0
43936: PUSH
43937: LD_INT 1
43939: PUSH
43940: EMPTY
43941: LIST
43942: LIST
43943: PUSH
43944: LD_INT 1
43946: NEG
43947: PUSH
43948: LD_INT 0
43950: PUSH
43951: EMPTY
43952: LIST
43953: LIST
43954: PUSH
43955: LD_INT 1
43957: NEG
43958: PUSH
43959: LD_INT 1
43961: NEG
43962: PUSH
43963: EMPTY
43964: LIST
43965: LIST
43966: PUSH
43967: LD_INT 1
43969: NEG
43970: PUSH
43971: LD_INT 2
43973: NEG
43974: PUSH
43975: EMPTY
43976: LIST
43977: LIST
43978: PUSH
43979: LD_INT 0
43981: PUSH
43982: LD_INT 2
43984: NEG
43985: PUSH
43986: EMPTY
43987: LIST
43988: LIST
43989: PUSH
43990: LD_INT 1
43992: PUSH
43993: LD_INT 1
43995: NEG
43996: PUSH
43997: EMPTY
43998: LIST
43999: LIST
44000: PUSH
44001: LD_INT 2
44003: PUSH
44004: LD_INT 0
44006: PUSH
44007: EMPTY
44008: LIST
44009: LIST
44010: PUSH
44011: LD_INT 2
44013: PUSH
44014: LD_INT 1
44016: PUSH
44017: EMPTY
44018: LIST
44019: LIST
44020: PUSH
44021: LD_INT 2
44023: PUSH
44024: LD_INT 2
44026: PUSH
44027: EMPTY
44028: LIST
44029: LIST
44030: PUSH
44031: LD_INT 1
44033: PUSH
44034: LD_INT 2
44036: PUSH
44037: EMPTY
44038: LIST
44039: LIST
44040: PUSH
44041: LD_INT 0
44043: PUSH
44044: LD_INT 2
44046: PUSH
44047: EMPTY
44048: LIST
44049: LIST
44050: PUSH
44051: LD_INT 1
44053: NEG
44054: PUSH
44055: LD_INT 1
44057: PUSH
44058: EMPTY
44059: LIST
44060: LIST
44061: PUSH
44062: LD_INT 2
44064: NEG
44065: PUSH
44066: LD_INT 0
44068: PUSH
44069: EMPTY
44070: LIST
44071: LIST
44072: PUSH
44073: LD_INT 2
44075: NEG
44076: PUSH
44077: LD_INT 1
44079: NEG
44080: PUSH
44081: EMPTY
44082: LIST
44083: LIST
44084: PUSH
44085: LD_INT 2
44087: NEG
44088: PUSH
44089: LD_INT 2
44091: NEG
44092: PUSH
44093: EMPTY
44094: LIST
44095: LIST
44096: PUSH
44097: EMPTY
44098: LIST
44099: LIST
44100: LIST
44101: LIST
44102: LIST
44103: LIST
44104: LIST
44105: LIST
44106: LIST
44107: LIST
44108: LIST
44109: LIST
44110: LIST
44111: LIST
44112: LIST
44113: LIST
44114: LIST
44115: LIST
44116: LIST
44117: ST_TO_ADDR
// fBarracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
44118: LD_ADDR_VAR 0 57
44122: PUSH
44123: LD_INT 0
44125: PUSH
44126: LD_INT 0
44128: PUSH
44129: EMPTY
44130: LIST
44131: LIST
44132: PUSH
44133: LD_INT 0
44135: PUSH
44136: LD_INT 1
44138: NEG
44139: PUSH
44140: EMPTY
44141: LIST
44142: LIST
44143: PUSH
44144: LD_INT 1
44146: PUSH
44147: LD_INT 0
44149: PUSH
44150: EMPTY
44151: LIST
44152: LIST
44153: PUSH
44154: LD_INT 1
44156: PUSH
44157: LD_INT 1
44159: PUSH
44160: EMPTY
44161: LIST
44162: LIST
44163: PUSH
44164: LD_INT 0
44166: PUSH
44167: LD_INT 1
44169: PUSH
44170: EMPTY
44171: LIST
44172: LIST
44173: PUSH
44174: LD_INT 1
44176: NEG
44177: PUSH
44178: LD_INT 0
44180: PUSH
44181: EMPTY
44182: LIST
44183: LIST
44184: PUSH
44185: LD_INT 1
44187: NEG
44188: PUSH
44189: LD_INT 1
44191: NEG
44192: PUSH
44193: EMPTY
44194: LIST
44195: LIST
44196: PUSH
44197: LD_INT 1
44199: NEG
44200: PUSH
44201: LD_INT 2
44203: NEG
44204: PUSH
44205: EMPTY
44206: LIST
44207: LIST
44208: PUSH
44209: LD_INT 0
44211: PUSH
44212: LD_INT 2
44214: NEG
44215: PUSH
44216: EMPTY
44217: LIST
44218: LIST
44219: PUSH
44220: LD_INT 1
44222: PUSH
44223: LD_INT 1
44225: NEG
44226: PUSH
44227: EMPTY
44228: LIST
44229: LIST
44230: PUSH
44231: LD_INT 2
44233: PUSH
44234: LD_INT 0
44236: PUSH
44237: EMPTY
44238: LIST
44239: LIST
44240: PUSH
44241: LD_INT 2
44243: PUSH
44244: LD_INT 1
44246: PUSH
44247: EMPTY
44248: LIST
44249: LIST
44250: PUSH
44251: LD_INT 2
44253: PUSH
44254: LD_INT 2
44256: PUSH
44257: EMPTY
44258: LIST
44259: LIST
44260: PUSH
44261: LD_INT 1
44263: PUSH
44264: LD_INT 2
44266: PUSH
44267: EMPTY
44268: LIST
44269: LIST
44270: PUSH
44271: LD_INT 0
44273: PUSH
44274: LD_INT 2
44276: PUSH
44277: EMPTY
44278: LIST
44279: LIST
44280: PUSH
44281: LD_INT 1
44283: NEG
44284: PUSH
44285: LD_INT 1
44287: PUSH
44288: EMPTY
44289: LIST
44290: LIST
44291: PUSH
44292: LD_INT 2
44294: NEG
44295: PUSH
44296: LD_INT 0
44298: PUSH
44299: EMPTY
44300: LIST
44301: LIST
44302: PUSH
44303: LD_INT 2
44305: NEG
44306: PUSH
44307: LD_INT 1
44309: NEG
44310: PUSH
44311: EMPTY
44312: LIST
44313: LIST
44314: PUSH
44315: LD_INT 2
44317: NEG
44318: PUSH
44319: LD_INT 2
44321: NEG
44322: PUSH
44323: EMPTY
44324: LIST
44325: LIST
44326: PUSH
44327: EMPTY
44328: LIST
44329: LIST
44330: LIST
44331: LIST
44332: LIST
44333: LIST
44334: LIST
44335: LIST
44336: LIST
44337: LIST
44338: LIST
44339: LIST
44340: LIST
44341: LIST
44342: LIST
44343: LIST
44344: LIST
44345: LIST
44346: LIST
44347: ST_TO_ADDR
// fBarracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
44348: LD_ADDR_VAR 0 58
44352: PUSH
44353: LD_INT 0
44355: PUSH
44356: LD_INT 0
44358: PUSH
44359: EMPTY
44360: LIST
44361: LIST
44362: PUSH
44363: LD_INT 0
44365: PUSH
44366: LD_INT 1
44368: NEG
44369: PUSH
44370: EMPTY
44371: LIST
44372: LIST
44373: PUSH
44374: LD_INT 1
44376: PUSH
44377: LD_INT 0
44379: PUSH
44380: EMPTY
44381: LIST
44382: LIST
44383: PUSH
44384: LD_INT 1
44386: PUSH
44387: LD_INT 1
44389: PUSH
44390: EMPTY
44391: LIST
44392: LIST
44393: PUSH
44394: LD_INT 0
44396: PUSH
44397: LD_INT 1
44399: PUSH
44400: EMPTY
44401: LIST
44402: LIST
44403: PUSH
44404: LD_INT 1
44406: NEG
44407: PUSH
44408: LD_INT 0
44410: PUSH
44411: EMPTY
44412: LIST
44413: LIST
44414: PUSH
44415: LD_INT 1
44417: NEG
44418: PUSH
44419: LD_INT 1
44421: NEG
44422: PUSH
44423: EMPTY
44424: LIST
44425: LIST
44426: PUSH
44427: LD_INT 1
44429: NEG
44430: PUSH
44431: LD_INT 2
44433: NEG
44434: PUSH
44435: EMPTY
44436: LIST
44437: LIST
44438: PUSH
44439: LD_INT 0
44441: PUSH
44442: LD_INT 2
44444: NEG
44445: PUSH
44446: EMPTY
44447: LIST
44448: LIST
44449: PUSH
44450: LD_INT 1
44452: PUSH
44453: LD_INT 1
44455: NEG
44456: PUSH
44457: EMPTY
44458: LIST
44459: LIST
44460: PUSH
44461: LD_INT 2
44463: PUSH
44464: LD_INT 0
44466: PUSH
44467: EMPTY
44468: LIST
44469: LIST
44470: PUSH
44471: LD_INT 2
44473: PUSH
44474: LD_INT 1
44476: PUSH
44477: EMPTY
44478: LIST
44479: LIST
44480: PUSH
44481: LD_INT 2
44483: PUSH
44484: LD_INT 2
44486: PUSH
44487: EMPTY
44488: LIST
44489: LIST
44490: PUSH
44491: LD_INT 1
44493: PUSH
44494: LD_INT 2
44496: PUSH
44497: EMPTY
44498: LIST
44499: LIST
44500: PUSH
44501: LD_INT 0
44503: PUSH
44504: LD_INT 2
44506: PUSH
44507: EMPTY
44508: LIST
44509: LIST
44510: PUSH
44511: LD_INT 1
44513: NEG
44514: PUSH
44515: LD_INT 1
44517: PUSH
44518: EMPTY
44519: LIST
44520: LIST
44521: PUSH
44522: LD_INT 2
44524: NEG
44525: PUSH
44526: LD_INT 0
44528: PUSH
44529: EMPTY
44530: LIST
44531: LIST
44532: PUSH
44533: LD_INT 2
44535: NEG
44536: PUSH
44537: LD_INT 1
44539: NEG
44540: PUSH
44541: EMPTY
44542: LIST
44543: LIST
44544: PUSH
44545: LD_INT 2
44547: NEG
44548: PUSH
44549: LD_INT 2
44551: NEG
44552: PUSH
44553: EMPTY
44554: LIST
44555: LIST
44556: PUSH
44557: EMPTY
44558: LIST
44559: LIST
44560: LIST
44561: LIST
44562: LIST
44563: LIST
44564: LIST
44565: LIST
44566: LIST
44567: LIST
44568: LIST
44569: LIST
44570: LIST
44571: LIST
44572: LIST
44573: LIST
44574: LIST
44575: LIST
44576: LIST
44577: ST_TO_ADDR
// fBunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
44578: LD_ADDR_VAR 0 59
44582: PUSH
44583: LD_INT 0
44585: PUSH
44586: LD_INT 0
44588: PUSH
44589: EMPTY
44590: LIST
44591: LIST
44592: PUSH
44593: LD_INT 0
44595: PUSH
44596: LD_INT 1
44598: NEG
44599: PUSH
44600: EMPTY
44601: LIST
44602: LIST
44603: PUSH
44604: LD_INT 1
44606: PUSH
44607: LD_INT 0
44609: PUSH
44610: EMPTY
44611: LIST
44612: LIST
44613: PUSH
44614: LD_INT 1
44616: PUSH
44617: LD_INT 1
44619: PUSH
44620: EMPTY
44621: LIST
44622: LIST
44623: PUSH
44624: LD_INT 0
44626: PUSH
44627: LD_INT 1
44629: PUSH
44630: EMPTY
44631: LIST
44632: LIST
44633: PUSH
44634: LD_INT 1
44636: NEG
44637: PUSH
44638: LD_INT 0
44640: PUSH
44641: EMPTY
44642: LIST
44643: LIST
44644: PUSH
44645: LD_INT 1
44647: NEG
44648: PUSH
44649: LD_INT 1
44651: NEG
44652: PUSH
44653: EMPTY
44654: LIST
44655: LIST
44656: PUSH
44657: EMPTY
44658: LIST
44659: LIST
44660: LIST
44661: LIST
44662: LIST
44663: LIST
44664: LIST
44665: ST_TO_ADDR
// fBunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
44666: LD_ADDR_VAR 0 60
44670: PUSH
44671: LD_INT 0
44673: PUSH
44674: LD_INT 0
44676: PUSH
44677: EMPTY
44678: LIST
44679: LIST
44680: PUSH
44681: LD_INT 0
44683: PUSH
44684: LD_INT 1
44686: NEG
44687: PUSH
44688: EMPTY
44689: LIST
44690: LIST
44691: PUSH
44692: LD_INT 1
44694: PUSH
44695: LD_INT 0
44697: PUSH
44698: EMPTY
44699: LIST
44700: LIST
44701: PUSH
44702: LD_INT 1
44704: PUSH
44705: LD_INT 1
44707: PUSH
44708: EMPTY
44709: LIST
44710: LIST
44711: PUSH
44712: LD_INT 0
44714: PUSH
44715: LD_INT 1
44717: PUSH
44718: EMPTY
44719: LIST
44720: LIST
44721: PUSH
44722: LD_INT 1
44724: NEG
44725: PUSH
44726: LD_INT 0
44728: PUSH
44729: EMPTY
44730: LIST
44731: LIST
44732: PUSH
44733: LD_INT 1
44735: NEG
44736: PUSH
44737: LD_INT 1
44739: NEG
44740: PUSH
44741: EMPTY
44742: LIST
44743: LIST
44744: PUSH
44745: EMPTY
44746: LIST
44747: LIST
44748: LIST
44749: LIST
44750: LIST
44751: LIST
44752: LIST
44753: ST_TO_ADDR
// fBunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
44754: LD_ADDR_VAR 0 61
44758: PUSH
44759: LD_INT 0
44761: PUSH
44762: LD_INT 0
44764: PUSH
44765: EMPTY
44766: LIST
44767: LIST
44768: PUSH
44769: LD_INT 0
44771: PUSH
44772: LD_INT 1
44774: NEG
44775: PUSH
44776: EMPTY
44777: LIST
44778: LIST
44779: PUSH
44780: LD_INT 1
44782: PUSH
44783: LD_INT 0
44785: PUSH
44786: EMPTY
44787: LIST
44788: LIST
44789: PUSH
44790: LD_INT 1
44792: PUSH
44793: LD_INT 1
44795: PUSH
44796: EMPTY
44797: LIST
44798: LIST
44799: PUSH
44800: LD_INT 0
44802: PUSH
44803: LD_INT 1
44805: PUSH
44806: EMPTY
44807: LIST
44808: LIST
44809: PUSH
44810: LD_INT 1
44812: NEG
44813: PUSH
44814: LD_INT 0
44816: PUSH
44817: EMPTY
44818: LIST
44819: LIST
44820: PUSH
44821: LD_INT 1
44823: NEG
44824: PUSH
44825: LD_INT 1
44827: NEG
44828: PUSH
44829: EMPTY
44830: LIST
44831: LIST
44832: PUSH
44833: EMPTY
44834: LIST
44835: LIST
44836: LIST
44837: LIST
44838: LIST
44839: LIST
44840: LIST
44841: ST_TO_ADDR
// fBunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
44842: LD_ADDR_VAR 0 62
44846: PUSH
44847: LD_INT 0
44849: PUSH
44850: LD_INT 0
44852: PUSH
44853: EMPTY
44854: LIST
44855: LIST
44856: PUSH
44857: LD_INT 0
44859: PUSH
44860: LD_INT 1
44862: NEG
44863: PUSH
44864: EMPTY
44865: LIST
44866: LIST
44867: PUSH
44868: LD_INT 1
44870: PUSH
44871: LD_INT 0
44873: PUSH
44874: EMPTY
44875: LIST
44876: LIST
44877: PUSH
44878: LD_INT 1
44880: PUSH
44881: LD_INT 1
44883: PUSH
44884: EMPTY
44885: LIST
44886: LIST
44887: PUSH
44888: LD_INT 0
44890: PUSH
44891: LD_INT 1
44893: PUSH
44894: EMPTY
44895: LIST
44896: LIST
44897: PUSH
44898: LD_INT 1
44900: NEG
44901: PUSH
44902: LD_INT 0
44904: PUSH
44905: EMPTY
44906: LIST
44907: LIST
44908: PUSH
44909: LD_INT 1
44911: NEG
44912: PUSH
44913: LD_INT 1
44915: NEG
44916: PUSH
44917: EMPTY
44918: LIST
44919: LIST
44920: PUSH
44921: EMPTY
44922: LIST
44923: LIST
44924: LIST
44925: LIST
44926: LIST
44927: LIST
44928: LIST
44929: ST_TO_ADDR
// fBunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
44930: LD_ADDR_VAR 0 63
44934: PUSH
44935: LD_INT 0
44937: PUSH
44938: LD_INT 0
44940: PUSH
44941: EMPTY
44942: LIST
44943: LIST
44944: PUSH
44945: LD_INT 0
44947: PUSH
44948: LD_INT 1
44950: NEG
44951: PUSH
44952: EMPTY
44953: LIST
44954: LIST
44955: PUSH
44956: LD_INT 1
44958: PUSH
44959: LD_INT 0
44961: PUSH
44962: EMPTY
44963: LIST
44964: LIST
44965: PUSH
44966: LD_INT 1
44968: PUSH
44969: LD_INT 1
44971: PUSH
44972: EMPTY
44973: LIST
44974: LIST
44975: PUSH
44976: LD_INT 0
44978: PUSH
44979: LD_INT 1
44981: PUSH
44982: EMPTY
44983: LIST
44984: LIST
44985: PUSH
44986: LD_INT 1
44988: NEG
44989: PUSH
44990: LD_INT 0
44992: PUSH
44993: EMPTY
44994: LIST
44995: LIST
44996: PUSH
44997: LD_INT 1
44999: NEG
45000: PUSH
45001: LD_INT 1
45003: NEG
45004: PUSH
45005: EMPTY
45006: LIST
45007: LIST
45008: PUSH
45009: EMPTY
45010: LIST
45011: LIST
45012: LIST
45013: LIST
45014: LIST
45015: LIST
45016: LIST
45017: ST_TO_ADDR
// fBunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
45018: LD_ADDR_VAR 0 64
45022: PUSH
45023: LD_INT 0
45025: PUSH
45026: LD_INT 0
45028: PUSH
45029: EMPTY
45030: LIST
45031: LIST
45032: PUSH
45033: LD_INT 0
45035: PUSH
45036: LD_INT 1
45038: NEG
45039: PUSH
45040: EMPTY
45041: LIST
45042: LIST
45043: PUSH
45044: LD_INT 1
45046: PUSH
45047: LD_INT 0
45049: PUSH
45050: EMPTY
45051: LIST
45052: LIST
45053: PUSH
45054: LD_INT 1
45056: PUSH
45057: LD_INT 1
45059: PUSH
45060: EMPTY
45061: LIST
45062: LIST
45063: PUSH
45064: LD_INT 0
45066: PUSH
45067: LD_INT 1
45069: PUSH
45070: EMPTY
45071: LIST
45072: LIST
45073: PUSH
45074: LD_INT 1
45076: NEG
45077: PUSH
45078: LD_INT 0
45080: PUSH
45081: EMPTY
45082: LIST
45083: LIST
45084: PUSH
45085: LD_INT 1
45087: NEG
45088: PUSH
45089: LD_INT 1
45091: NEG
45092: PUSH
45093: EMPTY
45094: LIST
45095: LIST
45096: PUSH
45097: EMPTY
45098: LIST
45099: LIST
45100: LIST
45101: LIST
45102: LIST
45103: LIST
45104: LIST
45105: ST_TO_ADDR
// end ; 1 :
45106: GO 51003
45108: LD_INT 1
45110: DOUBLE
45111: EQUAL
45112: IFTRUE 45116
45114: GO 47739
45116: POP
// begin fDepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
45117: LD_ADDR_VAR 0 11
45121: PUSH
45122: LD_INT 1
45124: NEG
45125: PUSH
45126: LD_INT 3
45128: NEG
45129: PUSH
45130: EMPTY
45131: LIST
45132: LIST
45133: PUSH
45134: LD_INT 0
45136: PUSH
45137: LD_INT 3
45139: NEG
45140: PUSH
45141: EMPTY
45142: LIST
45143: LIST
45144: PUSH
45145: LD_INT 1
45147: PUSH
45148: LD_INT 2
45150: NEG
45151: PUSH
45152: EMPTY
45153: LIST
45154: LIST
45155: PUSH
45156: EMPTY
45157: LIST
45158: LIST
45159: LIST
45160: ST_TO_ADDR
// fDepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
45161: LD_ADDR_VAR 0 12
45165: PUSH
45166: LD_INT 2
45168: PUSH
45169: LD_INT 1
45171: NEG
45172: PUSH
45173: EMPTY
45174: LIST
45175: LIST
45176: PUSH
45177: LD_INT 3
45179: PUSH
45180: LD_INT 0
45182: PUSH
45183: EMPTY
45184: LIST
45185: LIST
45186: PUSH
45187: LD_INT 3
45189: PUSH
45190: LD_INT 1
45192: PUSH
45193: EMPTY
45194: LIST
45195: LIST
45196: PUSH
45197: EMPTY
45198: LIST
45199: LIST
45200: LIST
45201: ST_TO_ADDR
// fDepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
45202: LD_ADDR_VAR 0 13
45206: PUSH
45207: LD_INT 3
45209: PUSH
45210: LD_INT 2
45212: PUSH
45213: EMPTY
45214: LIST
45215: LIST
45216: PUSH
45217: LD_INT 3
45219: PUSH
45220: LD_INT 3
45222: PUSH
45223: EMPTY
45224: LIST
45225: LIST
45226: PUSH
45227: LD_INT 2
45229: PUSH
45230: LD_INT 3
45232: PUSH
45233: EMPTY
45234: LIST
45235: LIST
45236: PUSH
45237: EMPTY
45238: LIST
45239: LIST
45240: LIST
45241: ST_TO_ADDR
// fDepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
45242: LD_ADDR_VAR 0 14
45246: PUSH
45247: LD_INT 1
45249: PUSH
45250: LD_INT 3
45252: PUSH
45253: EMPTY
45254: LIST
45255: LIST
45256: PUSH
45257: LD_INT 0
45259: PUSH
45260: LD_INT 3
45262: PUSH
45263: EMPTY
45264: LIST
45265: LIST
45266: PUSH
45267: LD_INT 1
45269: NEG
45270: PUSH
45271: LD_INT 2
45273: PUSH
45274: EMPTY
45275: LIST
45276: LIST
45277: PUSH
45278: EMPTY
45279: LIST
45280: LIST
45281: LIST
45282: ST_TO_ADDR
// fDepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
45283: LD_ADDR_VAR 0 15
45287: PUSH
45288: LD_INT 2
45290: NEG
45291: PUSH
45292: LD_INT 1
45294: PUSH
45295: EMPTY
45296: LIST
45297: LIST
45298: PUSH
45299: LD_INT 3
45301: NEG
45302: PUSH
45303: LD_INT 0
45305: PUSH
45306: EMPTY
45307: LIST
45308: LIST
45309: PUSH
45310: LD_INT 3
45312: NEG
45313: PUSH
45314: LD_INT 1
45316: NEG
45317: PUSH
45318: EMPTY
45319: LIST
45320: LIST
45321: PUSH
45322: EMPTY
45323: LIST
45324: LIST
45325: LIST
45326: ST_TO_ADDR
// fDepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
45327: LD_ADDR_VAR 0 16
45331: PUSH
45332: LD_INT 2
45334: NEG
45335: PUSH
45336: LD_INT 3
45338: NEG
45339: PUSH
45340: EMPTY
45341: LIST
45342: LIST
45343: PUSH
45344: LD_INT 3
45346: NEG
45347: PUSH
45348: LD_INT 2
45350: NEG
45351: PUSH
45352: EMPTY
45353: LIST
45354: LIST
45355: PUSH
45356: LD_INT 3
45358: NEG
45359: PUSH
45360: LD_INT 3
45362: NEG
45363: PUSH
45364: EMPTY
45365: LIST
45366: LIST
45367: PUSH
45368: EMPTY
45369: LIST
45370: LIST
45371: LIST
45372: ST_TO_ADDR
// fDepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
45373: LD_ADDR_VAR 0 17
45377: PUSH
45378: LD_INT 1
45380: NEG
45381: PUSH
45382: LD_INT 3
45384: NEG
45385: PUSH
45386: EMPTY
45387: LIST
45388: LIST
45389: PUSH
45390: LD_INT 0
45392: PUSH
45393: LD_INT 3
45395: NEG
45396: PUSH
45397: EMPTY
45398: LIST
45399: LIST
45400: PUSH
45401: LD_INT 1
45403: PUSH
45404: LD_INT 2
45406: NEG
45407: PUSH
45408: EMPTY
45409: LIST
45410: LIST
45411: PUSH
45412: EMPTY
45413: LIST
45414: LIST
45415: LIST
45416: ST_TO_ADDR
// fDepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
45417: LD_ADDR_VAR 0 18
45421: PUSH
45422: LD_INT 2
45424: PUSH
45425: LD_INT 1
45427: NEG
45428: PUSH
45429: EMPTY
45430: LIST
45431: LIST
45432: PUSH
45433: LD_INT 3
45435: PUSH
45436: LD_INT 0
45438: PUSH
45439: EMPTY
45440: LIST
45441: LIST
45442: PUSH
45443: LD_INT 3
45445: PUSH
45446: LD_INT 1
45448: PUSH
45449: EMPTY
45450: LIST
45451: LIST
45452: PUSH
45453: EMPTY
45454: LIST
45455: LIST
45456: LIST
45457: ST_TO_ADDR
// fDepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
45458: LD_ADDR_VAR 0 19
45462: PUSH
45463: LD_INT 3
45465: PUSH
45466: LD_INT 2
45468: PUSH
45469: EMPTY
45470: LIST
45471: LIST
45472: PUSH
45473: LD_INT 3
45475: PUSH
45476: LD_INT 3
45478: PUSH
45479: EMPTY
45480: LIST
45481: LIST
45482: PUSH
45483: LD_INT 2
45485: PUSH
45486: LD_INT 3
45488: PUSH
45489: EMPTY
45490: LIST
45491: LIST
45492: PUSH
45493: EMPTY
45494: LIST
45495: LIST
45496: LIST
45497: ST_TO_ADDR
// fDepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
45498: LD_ADDR_VAR 0 20
45502: PUSH
45503: LD_INT 1
45505: PUSH
45506: LD_INT 3
45508: PUSH
45509: EMPTY
45510: LIST
45511: LIST
45512: PUSH
45513: LD_INT 0
45515: PUSH
45516: LD_INT 3
45518: PUSH
45519: EMPTY
45520: LIST
45521: LIST
45522: PUSH
45523: LD_INT 1
45525: NEG
45526: PUSH
45527: LD_INT 2
45529: PUSH
45530: EMPTY
45531: LIST
45532: LIST
45533: PUSH
45534: EMPTY
45535: LIST
45536: LIST
45537: LIST
45538: ST_TO_ADDR
// fDepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
45539: LD_ADDR_VAR 0 21
45543: PUSH
45544: LD_INT 2
45546: NEG
45547: PUSH
45548: LD_INT 1
45550: PUSH
45551: EMPTY
45552: LIST
45553: LIST
45554: PUSH
45555: LD_INT 3
45557: NEG
45558: PUSH
45559: LD_INT 0
45561: PUSH
45562: EMPTY
45563: LIST
45564: LIST
45565: PUSH
45566: LD_INT 3
45568: NEG
45569: PUSH
45570: LD_INT 1
45572: NEG
45573: PUSH
45574: EMPTY
45575: LIST
45576: LIST
45577: PUSH
45578: EMPTY
45579: LIST
45580: LIST
45581: LIST
45582: ST_TO_ADDR
// fDepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
45583: LD_ADDR_VAR 0 22
45587: PUSH
45588: LD_INT 2
45590: NEG
45591: PUSH
45592: LD_INT 3
45594: NEG
45595: PUSH
45596: EMPTY
45597: LIST
45598: LIST
45599: PUSH
45600: LD_INT 3
45602: NEG
45603: PUSH
45604: LD_INT 2
45606: NEG
45607: PUSH
45608: EMPTY
45609: LIST
45610: LIST
45611: PUSH
45612: LD_INT 3
45614: NEG
45615: PUSH
45616: LD_INT 3
45618: NEG
45619: PUSH
45620: EMPTY
45621: LIST
45622: LIST
45623: PUSH
45624: EMPTY
45625: LIST
45626: LIST
45627: LIST
45628: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
45629: LD_ADDR_VAR 0 23
45633: PUSH
45634: LD_INT 0
45636: PUSH
45637: LD_INT 3
45639: NEG
45640: PUSH
45641: EMPTY
45642: LIST
45643: LIST
45644: PUSH
45645: LD_INT 1
45647: NEG
45648: PUSH
45649: LD_INT 4
45651: NEG
45652: PUSH
45653: EMPTY
45654: LIST
45655: LIST
45656: PUSH
45657: LD_INT 1
45659: PUSH
45660: LD_INT 3
45662: NEG
45663: PUSH
45664: EMPTY
45665: LIST
45666: LIST
45667: PUSH
45668: EMPTY
45669: LIST
45670: LIST
45671: LIST
45672: ST_TO_ADDR
// fDepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
45673: LD_ADDR_VAR 0 24
45677: PUSH
45678: LD_INT 3
45680: PUSH
45681: LD_INT 0
45683: PUSH
45684: EMPTY
45685: LIST
45686: LIST
45687: PUSH
45688: LD_INT 3
45690: PUSH
45691: LD_INT 1
45693: NEG
45694: PUSH
45695: EMPTY
45696: LIST
45697: LIST
45698: PUSH
45699: LD_INT 4
45701: PUSH
45702: LD_INT 1
45704: PUSH
45705: EMPTY
45706: LIST
45707: LIST
45708: PUSH
45709: EMPTY
45710: LIST
45711: LIST
45712: LIST
45713: ST_TO_ADDR
// fDepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
45714: LD_ADDR_VAR 0 25
45718: PUSH
45719: LD_INT 3
45721: PUSH
45722: LD_INT 3
45724: PUSH
45725: EMPTY
45726: LIST
45727: LIST
45728: PUSH
45729: LD_INT 4
45731: PUSH
45732: LD_INT 3
45734: PUSH
45735: EMPTY
45736: LIST
45737: LIST
45738: PUSH
45739: LD_INT 3
45741: PUSH
45742: LD_INT 4
45744: PUSH
45745: EMPTY
45746: LIST
45747: LIST
45748: PUSH
45749: EMPTY
45750: LIST
45751: LIST
45752: LIST
45753: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
45754: LD_ADDR_VAR 0 26
45758: PUSH
45759: LD_INT 0
45761: PUSH
45762: LD_INT 3
45764: PUSH
45765: EMPTY
45766: LIST
45767: LIST
45768: PUSH
45769: LD_INT 1
45771: PUSH
45772: LD_INT 4
45774: PUSH
45775: EMPTY
45776: LIST
45777: LIST
45778: PUSH
45779: LD_INT 1
45781: NEG
45782: PUSH
45783: LD_INT 3
45785: PUSH
45786: EMPTY
45787: LIST
45788: LIST
45789: PUSH
45790: EMPTY
45791: LIST
45792: LIST
45793: LIST
45794: ST_TO_ADDR
// fDepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
45795: LD_ADDR_VAR 0 27
45799: PUSH
45800: LD_INT 3
45802: NEG
45803: PUSH
45804: LD_INT 0
45806: PUSH
45807: EMPTY
45808: LIST
45809: LIST
45810: PUSH
45811: LD_INT 3
45813: NEG
45814: PUSH
45815: LD_INT 1
45817: PUSH
45818: EMPTY
45819: LIST
45820: LIST
45821: PUSH
45822: LD_INT 4
45824: NEG
45825: PUSH
45826: LD_INT 1
45828: NEG
45829: PUSH
45830: EMPTY
45831: LIST
45832: LIST
45833: PUSH
45834: EMPTY
45835: LIST
45836: LIST
45837: LIST
45838: ST_TO_ADDR
// fDepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
45839: LD_ADDR_VAR 0 28
45843: PUSH
45844: LD_INT 3
45846: NEG
45847: PUSH
45848: LD_INT 3
45850: NEG
45851: PUSH
45852: EMPTY
45853: LIST
45854: LIST
45855: PUSH
45856: LD_INT 3
45858: NEG
45859: PUSH
45860: LD_INT 4
45862: NEG
45863: PUSH
45864: EMPTY
45865: LIST
45866: LIST
45867: PUSH
45868: LD_INT 4
45870: NEG
45871: PUSH
45872: LD_INT 3
45874: NEG
45875: PUSH
45876: EMPTY
45877: LIST
45878: LIST
45879: PUSH
45880: EMPTY
45881: LIST
45882: LIST
45883: LIST
45884: ST_TO_ADDR
// fFactory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
45885: LD_ADDR_VAR 0 29
45889: PUSH
45890: LD_INT 1
45892: NEG
45893: PUSH
45894: LD_INT 3
45896: NEG
45897: PUSH
45898: EMPTY
45899: LIST
45900: LIST
45901: PUSH
45902: LD_INT 0
45904: PUSH
45905: LD_INT 3
45907: NEG
45908: PUSH
45909: EMPTY
45910: LIST
45911: LIST
45912: PUSH
45913: LD_INT 1
45915: PUSH
45916: LD_INT 2
45918: NEG
45919: PUSH
45920: EMPTY
45921: LIST
45922: LIST
45923: PUSH
45924: LD_INT 1
45926: NEG
45927: PUSH
45928: LD_INT 4
45930: NEG
45931: PUSH
45932: EMPTY
45933: LIST
45934: LIST
45935: PUSH
45936: LD_INT 0
45938: PUSH
45939: LD_INT 4
45941: NEG
45942: PUSH
45943: EMPTY
45944: LIST
45945: LIST
45946: PUSH
45947: LD_INT 1
45949: PUSH
45950: LD_INT 3
45952: NEG
45953: PUSH
45954: EMPTY
45955: LIST
45956: LIST
45957: PUSH
45958: LD_INT 1
45960: NEG
45961: PUSH
45962: LD_INT 5
45964: NEG
45965: PUSH
45966: EMPTY
45967: LIST
45968: LIST
45969: PUSH
45970: LD_INT 0
45972: PUSH
45973: LD_INT 5
45975: NEG
45976: PUSH
45977: EMPTY
45978: LIST
45979: LIST
45980: PUSH
45981: LD_INT 1
45983: PUSH
45984: LD_INT 4
45986: NEG
45987: PUSH
45988: EMPTY
45989: LIST
45990: LIST
45991: PUSH
45992: LD_INT 1
45994: NEG
45995: PUSH
45996: LD_INT 6
45998: NEG
45999: PUSH
46000: EMPTY
46001: LIST
46002: LIST
46003: PUSH
46004: LD_INT 0
46006: PUSH
46007: LD_INT 6
46009: NEG
46010: PUSH
46011: EMPTY
46012: LIST
46013: LIST
46014: PUSH
46015: LD_INT 1
46017: PUSH
46018: LD_INT 5
46020: NEG
46021: PUSH
46022: EMPTY
46023: LIST
46024: LIST
46025: PUSH
46026: EMPTY
46027: LIST
46028: LIST
46029: LIST
46030: LIST
46031: LIST
46032: LIST
46033: LIST
46034: LIST
46035: LIST
46036: LIST
46037: LIST
46038: LIST
46039: ST_TO_ADDR
// fFactory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
46040: LD_ADDR_VAR 0 30
46044: PUSH
46045: LD_INT 2
46047: PUSH
46048: LD_INT 1
46050: NEG
46051: PUSH
46052: EMPTY
46053: LIST
46054: LIST
46055: PUSH
46056: LD_INT 3
46058: PUSH
46059: LD_INT 0
46061: PUSH
46062: EMPTY
46063: LIST
46064: LIST
46065: PUSH
46066: LD_INT 3
46068: PUSH
46069: LD_INT 1
46071: PUSH
46072: EMPTY
46073: LIST
46074: LIST
46075: PUSH
46076: LD_INT 3
46078: PUSH
46079: LD_INT 1
46081: NEG
46082: PUSH
46083: EMPTY
46084: LIST
46085: LIST
46086: PUSH
46087: LD_INT 4
46089: PUSH
46090: LD_INT 0
46092: PUSH
46093: EMPTY
46094: LIST
46095: LIST
46096: PUSH
46097: LD_INT 4
46099: PUSH
46100: LD_INT 1
46102: PUSH
46103: EMPTY
46104: LIST
46105: LIST
46106: PUSH
46107: LD_INT 4
46109: PUSH
46110: LD_INT 1
46112: NEG
46113: PUSH
46114: EMPTY
46115: LIST
46116: LIST
46117: PUSH
46118: LD_INT 5
46120: PUSH
46121: LD_INT 0
46123: PUSH
46124: EMPTY
46125: LIST
46126: LIST
46127: PUSH
46128: LD_INT 5
46130: PUSH
46131: LD_INT 1
46133: PUSH
46134: EMPTY
46135: LIST
46136: LIST
46137: PUSH
46138: LD_INT 5
46140: PUSH
46141: LD_INT 1
46143: NEG
46144: PUSH
46145: EMPTY
46146: LIST
46147: LIST
46148: PUSH
46149: LD_INT 6
46151: PUSH
46152: LD_INT 0
46154: PUSH
46155: EMPTY
46156: LIST
46157: LIST
46158: PUSH
46159: LD_INT 6
46161: PUSH
46162: LD_INT 1
46164: PUSH
46165: EMPTY
46166: LIST
46167: LIST
46168: PUSH
46169: EMPTY
46170: LIST
46171: LIST
46172: LIST
46173: LIST
46174: LIST
46175: LIST
46176: LIST
46177: LIST
46178: LIST
46179: LIST
46180: LIST
46181: LIST
46182: ST_TO_ADDR
// fFactory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
46183: LD_ADDR_VAR 0 31
46187: PUSH
46188: LD_INT 3
46190: PUSH
46191: LD_INT 2
46193: PUSH
46194: EMPTY
46195: LIST
46196: LIST
46197: PUSH
46198: LD_INT 3
46200: PUSH
46201: LD_INT 3
46203: PUSH
46204: EMPTY
46205: LIST
46206: LIST
46207: PUSH
46208: LD_INT 2
46210: PUSH
46211: LD_INT 3
46213: PUSH
46214: EMPTY
46215: LIST
46216: LIST
46217: PUSH
46218: LD_INT 4
46220: PUSH
46221: LD_INT 3
46223: PUSH
46224: EMPTY
46225: LIST
46226: LIST
46227: PUSH
46228: LD_INT 4
46230: PUSH
46231: LD_INT 4
46233: PUSH
46234: EMPTY
46235: LIST
46236: LIST
46237: PUSH
46238: LD_INT 3
46240: PUSH
46241: LD_INT 4
46243: PUSH
46244: EMPTY
46245: LIST
46246: LIST
46247: PUSH
46248: LD_INT 5
46250: PUSH
46251: LD_INT 4
46253: PUSH
46254: EMPTY
46255: LIST
46256: LIST
46257: PUSH
46258: LD_INT 5
46260: PUSH
46261: LD_INT 5
46263: PUSH
46264: EMPTY
46265: LIST
46266: LIST
46267: PUSH
46268: LD_INT 4
46270: PUSH
46271: LD_INT 5
46273: PUSH
46274: EMPTY
46275: LIST
46276: LIST
46277: PUSH
46278: LD_INT 6
46280: PUSH
46281: LD_INT 5
46283: PUSH
46284: EMPTY
46285: LIST
46286: LIST
46287: PUSH
46288: LD_INT 6
46290: PUSH
46291: LD_INT 6
46293: PUSH
46294: EMPTY
46295: LIST
46296: LIST
46297: PUSH
46298: LD_INT 5
46300: PUSH
46301: LD_INT 6
46303: PUSH
46304: EMPTY
46305: LIST
46306: LIST
46307: PUSH
46308: EMPTY
46309: LIST
46310: LIST
46311: LIST
46312: LIST
46313: LIST
46314: LIST
46315: LIST
46316: LIST
46317: LIST
46318: LIST
46319: LIST
46320: LIST
46321: ST_TO_ADDR
// fFactory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
46322: LD_ADDR_VAR 0 32
46326: PUSH
46327: LD_INT 1
46329: PUSH
46330: LD_INT 3
46332: PUSH
46333: EMPTY
46334: LIST
46335: LIST
46336: PUSH
46337: LD_INT 0
46339: PUSH
46340: LD_INT 3
46342: PUSH
46343: EMPTY
46344: LIST
46345: LIST
46346: PUSH
46347: LD_INT 1
46349: NEG
46350: PUSH
46351: LD_INT 2
46353: PUSH
46354: EMPTY
46355: LIST
46356: LIST
46357: PUSH
46358: LD_INT 1
46360: PUSH
46361: LD_INT 4
46363: PUSH
46364: EMPTY
46365: LIST
46366: LIST
46367: PUSH
46368: LD_INT 0
46370: PUSH
46371: LD_INT 4
46373: PUSH
46374: EMPTY
46375: LIST
46376: LIST
46377: PUSH
46378: LD_INT 1
46380: NEG
46381: PUSH
46382: LD_INT 3
46384: PUSH
46385: EMPTY
46386: LIST
46387: LIST
46388: PUSH
46389: LD_INT 1
46391: PUSH
46392: LD_INT 5
46394: PUSH
46395: EMPTY
46396: LIST
46397: LIST
46398: PUSH
46399: LD_INT 0
46401: PUSH
46402: LD_INT 5
46404: PUSH
46405: EMPTY
46406: LIST
46407: LIST
46408: PUSH
46409: LD_INT 1
46411: NEG
46412: PUSH
46413: LD_INT 4
46415: PUSH
46416: EMPTY
46417: LIST
46418: LIST
46419: PUSH
46420: LD_INT 1
46422: PUSH
46423: LD_INT 6
46425: PUSH
46426: EMPTY
46427: LIST
46428: LIST
46429: PUSH
46430: LD_INT 0
46432: PUSH
46433: LD_INT 6
46435: PUSH
46436: EMPTY
46437: LIST
46438: LIST
46439: PUSH
46440: LD_INT 1
46442: NEG
46443: PUSH
46444: LD_INT 5
46446: PUSH
46447: EMPTY
46448: LIST
46449: LIST
46450: PUSH
46451: EMPTY
46452: LIST
46453: LIST
46454: LIST
46455: LIST
46456: LIST
46457: LIST
46458: LIST
46459: LIST
46460: LIST
46461: LIST
46462: LIST
46463: LIST
46464: ST_TO_ADDR
// fFactory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
46465: LD_ADDR_VAR 0 33
46469: PUSH
46470: LD_INT 2
46472: NEG
46473: PUSH
46474: LD_INT 1
46476: PUSH
46477: EMPTY
46478: LIST
46479: LIST
46480: PUSH
46481: LD_INT 3
46483: NEG
46484: PUSH
46485: LD_INT 0
46487: PUSH
46488: EMPTY
46489: LIST
46490: LIST
46491: PUSH
46492: LD_INT 3
46494: NEG
46495: PUSH
46496: LD_INT 1
46498: NEG
46499: PUSH
46500: EMPTY
46501: LIST
46502: LIST
46503: PUSH
46504: LD_INT 3
46506: NEG
46507: PUSH
46508: LD_INT 1
46510: PUSH
46511: EMPTY
46512: LIST
46513: LIST
46514: PUSH
46515: LD_INT 4
46517: NEG
46518: PUSH
46519: LD_INT 0
46521: PUSH
46522: EMPTY
46523: LIST
46524: LIST
46525: PUSH
46526: LD_INT 4
46528: NEG
46529: PUSH
46530: LD_INT 1
46532: NEG
46533: PUSH
46534: EMPTY
46535: LIST
46536: LIST
46537: PUSH
46538: LD_INT 4
46540: NEG
46541: PUSH
46542: LD_INT 1
46544: PUSH
46545: EMPTY
46546: LIST
46547: LIST
46548: PUSH
46549: LD_INT 5
46551: NEG
46552: PUSH
46553: LD_INT 0
46555: PUSH
46556: EMPTY
46557: LIST
46558: LIST
46559: PUSH
46560: LD_INT 5
46562: NEG
46563: PUSH
46564: LD_INT 1
46566: NEG
46567: PUSH
46568: EMPTY
46569: LIST
46570: LIST
46571: PUSH
46572: LD_INT 5
46574: NEG
46575: PUSH
46576: LD_INT 1
46578: PUSH
46579: EMPTY
46580: LIST
46581: LIST
46582: PUSH
46583: LD_INT 6
46585: NEG
46586: PUSH
46587: LD_INT 0
46589: PUSH
46590: EMPTY
46591: LIST
46592: LIST
46593: PUSH
46594: LD_INT 6
46596: NEG
46597: PUSH
46598: LD_INT 1
46600: NEG
46601: PUSH
46602: EMPTY
46603: LIST
46604: LIST
46605: PUSH
46606: EMPTY
46607: LIST
46608: LIST
46609: LIST
46610: LIST
46611: LIST
46612: LIST
46613: LIST
46614: LIST
46615: LIST
46616: LIST
46617: LIST
46618: LIST
46619: ST_TO_ADDR
// fFactory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
46620: LD_ADDR_VAR 0 34
46624: PUSH
46625: LD_INT 2
46627: NEG
46628: PUSH
46629: LD_INT 3
46631: NEG
46632: PUSH
46633: EMPTY
46634: LIST
46635: LIST
46636: PUSH
46637: LD_INT 3
46639: NEG
46640: PUSH
46641: LD_INT 2
46643: NEG
46644: PUSH
46645: EMPTY
46646: LIST
46647: LIST
46648: PUSH
46649: LD_INT 3
46651: NEG
46652: PUSH
46653: LD_INT 3
46655: NEG
46656: PUSH
46657: EMPTY
46658: LIST
46659: LIST
46660: PUSH
46661: LD_INT 3
46663: NEG
46664: PUSH
46665: LD_INT 4
46667: NEG
46668: PUSH
46669: EMPTY
46670: LIST
46671: LIST
46672: PUSH
46673: LD_INT 4
46675: NEG
46676: PUSH
46677: LD_INT 3
46679: NEG
46680: PUSH
46681: EMPTY
46682: LIST
46683: LIST
46684: PUSH
46685: LD_INT 4
46687: NEG
46688: PUSH
46689: LD_INT 4
46691: NEG
46692: PUSH
46693: EMPTY
46694: LIST
46695: LIST
46696: PUSH
46697: LD_INT 4
46699: NEG
46700: PUSH
46701: LD_INT 5
46703: NEG
46704: PUSH
46705: EMPTY
46706: LIST
46707: LIST
46708: PUSH
46709: LD_INT 5
46711: NEG
46712: PUSH
46713: LD_INT 4
46715: NEG
46716: PUSH
46717: EMPTY
46718: LIST
46719: LIST
46720: PUSH
46721: LD_INT 5
46723: NEG
46724: PUSH
46725: LD_INT 5
46727: NEG
46728: PUSH
46729: EMPTY
46730: LIST
46731: LIST
46732: PUSH
46733: LD_INT 5
46735: NEG
46736: PUSH
46737: LD_INT 6
46739: NEG
46740: PUSH
46741: EMPTY
46742: LIST
46743: LIST
46744: PUSH
46745: LD_INT 6
46747: NEG
46748: PUSH
46749: LD_INT 5
46751: NEG
46752: PUSH
46753: EMPTY
46754: LIST
46755: LIST
46756: PUSH
46757: LD_INT 6
46759: NEG
46760: PUSH
46761: LD_INT 6
46763: NEG
46764: PUSH
46765: EMPTY
46766: LIST
46767: LIST
46768: PUSH
46769: EMPTY
46770: LIST
46771: LIST
46772: LIST
46773: LIST
46774: LIST
46775: LIST
46776: LIST
46777: LIST
46778: LIST
46779: LIST
46780: LIST
46781: LIST
46782: ST_TO_ADDR
// fLab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
46783: LD_ADDR_VAR 0 41
46787: PUSH
46788: LD_INT 0
46790: PUSH
46791: LD_INT 2
46793: NEG
46794: PUSH
46795: EMPTY
46796: LIST
46797: LIST
46798: PUSH
46799: LD_INT 1
46801: NEG
46802: PUSH
46803: LD_INT 3
46805: NEG
46806: PUSH
46807: EMPTY
46808: LIST
46809: LIST
46810: PUSH
46811: LD_INT 1
46813: PUSH
46814: LD_INT 2
46816: NEG
46817: PUSH
46818: EMPTY
46819: LIST
46820: LIST
46821: PUSH
46822: EMPTY
46823: LIST
46824: LIST
46825: LIST
46826: ST_TO_ADDR
// fLab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
46827: LD_ADDR_VAR 0 42
46831: PUSH
46832: LD_INT 2
46834: PUSH
46835: LD_INT 0
46837: PUSH
46838: EMPTY
46839: LIST
46840: LIST
46841: PUSH
46842: LD_INT 2
46844: PUSH
46845: LD_INT 1
46847: NEG
46848: PUSH
46849: EMPTY
46850: LIST
46851: LIST
46852: PUSH
46853: LD_INT 3
46855: PUSH
46856: LD_INT 1
46858: PUSH
46859: EMPTY
46860: LIST
46861: LIST
46862: PUSH
46863: EMPTY
46864: LIST
46865: LIST
46866: LIST
46867: ST_TO_ADDR
// fLab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
46868: LD_ADDR_VAR 0 43
46872: PUSH
46873: LD_INT 2
46875: PUSH
46876: LD_INT 2
46878: PUSH
46879: EMPTY
46880: LIST
46881: LIST
46882: PUSH
46883: LD_INT 3
46885: PUSH
46886: LD_INT 2
46888: PUSH
46889: EMPTY
46890: LIST
46891: LIST
46892: PUSH
46893: LD_INT 2
46895: PUSH
46896: LD_INT 3
46898: PUSH
46899: EMPTY
46900: LIST
46901: LIST
46902: PUSH
46903: EMPTY
46904: LIST
46905: LIST
46906: LIST
46907: ST_TO_ADDR
// fLab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
46908: LD_ADDR_VAR 0 44
46912: PUSH
46913: LD_INT 0
46915: PUSH
46916: LD_INT 2
46918: PUSH
46919: EMPTY
46920: LIST
46921: LIST
46922: PUSH
46923: LD_INT 1
46925: PUSH
46926: LD_INT 3
46928: PUSH
46929: EMPTY
46930: LIST
46931: LIST
46932: PUSH
46933: LD_INT 1
46935: NEG
46936: PUSH
46937: LD_INT 2
46939: PUSH
46940: EMPTY
46941: LIST
46942: LIST
46943: PUSH
46944: EMPTY
46945: LIST
46946: LIST
46947: LIST
46948: ST_TO_ADDR
// fLab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
46949: LD_ADDR_VAR 0 45
46953: PUSH
46954: LD_INT 2
46956: NEG
46957: PUSH
46958: LD_INT 0
46960: PUSH
46961: EMPTY
46962: LIST
46963: LIST
46964: PUSH
46965: LD_INT 2
46967: NEG
46968: PUSH
46969: LD_INT 1
46971: PUSH
46972: EMPTY
46973: LIST
46974: LIST
46975: PUSH
46976: LD_INT 3
46978: NEG
46979: PUSH
46980: LD_INT 1
46982: NEG
46983: PUSH
46984: EMPTY
46985: LIST
46986: LIST
46987: PUSH
46988: EMPTY
46989: LIST
46990: LIST
46991: LIST
46992: ST_TO_ADDR
// fLab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
46993: LD_ADDR_VAR 0 46
46997: PUSH
46998: LD_INT 2
47000: NEG
47001: PUSH
47002: LD_INT 2
47004: NEG
47005: PUSH
47006: EMPTY
47007: LIST
47008: LIST
47009: PUSH
47010: LD_INT 2
47012: NEG
47013: PUSH
47014: LD_INT 3
47016: NEG
47017: PUSH
47018: EMPTY
47019: LIST
47020: LIST
47021: PUSH
47022: LD_INT 3
47024: NEG
47025: PUSH
47026: LD_INT 2
47028: NEG
47029: PUSH
47030: EMPTY
47031: LIST
47032: LIST
47033: PUSH
47034: EMPTY
47035: LIST
47036: LIST
47037: LIST
47038: ST_TO_ADDR
// fControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
47039: LD_ADDR_VAR 0 47
47043: PUSH
47044: LD_INT 2
47046: NEG
47047: PUSH
47048: LD_INT 3
47050: NEG
47051: PUSH
47052: EMPTY
47053: LIST
47054: LIST
47055: PUSH
47056: LD_INT 1
47058: NEG
47059: PUSH
47060: LD_INT 3
47062: NEG
47063: PUSH
47064: EMPTY
47065: LIST
47066: LIST
47067: PUSH
47068: EMPTY
47069: LIST
47070: LIST
47071: ST_TO_ADDR
// fControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
47072: LD_ADDR_VAR 0 48
47076: PUSH
47077: LD_INT 1
47079: PUSH
47080: LD_INT 2
47082: NEG
47083: PUSH
47084: EMPTY
47085: LIST
47086: LIST
47087: PUSH
47088: LD_INT 2
47090: PUSH
47091: LD_INT 1
47093: NEG
47094: PUSH
47095: EMPTY
47096: LIST
47097: LIST
47098: PUSH
47099: EMPTY
47100: LIST
47101: LIST
47102: ST_TO_ADDR
// fControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
47103: LD_ADDR_VAR 0 49
47107: PUSH
47108: LD_INT 3
47110: PUSH
47111: LD_INT 1
47113: PUSH
47114: EMPTY
47115: LIST
47116: LIST
47117: PUSH
47118: LD_INT 3
47120: PUSH
47121: LD_INT 2
47123: PUSH
47124: EMPTY
47125: LIST
47126: LIST
47127: PUSH
47128: EMPTY
47129: LIST
47130: LIST
47131: ST_TO_ADDR
// fControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
47132: LD_ADDR_VAR 0 50
47136: PUSH
47137: LD_INT 2
47139: PUSH
47140: LD_INT 3
47142: PUSH
47143: EMPTY
47144: LIST
47145: LIST
47146: PUSH
47147: LD_INT 1
47149: PUSH
47150: LD_INT 3
47152: PUSH
47153: EMPTY
47154: LIST
47155: LIST
47156: PUSH
47157: EMPTY
47158: LIST
47159: LIST
47160: ST_TO_ADDR
// fControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
47161: LD_ADDR_VAR 0 51
47165: PUSH
47166: LD_INT 1
47168: NEG
47169: PUSH
47170: LD_INT 2
47172: PUSH
47173: EMPTY
47174: LIST
47175: LIST
47176: PUSH
47177: LD_INT 2
47179: NEG
47180: PUSH
47181: LD_INT 1
47183: PUSH
47184: EMPTY
47185: LIST
47186: LIST
47187: PUSH
47188: EMPTY
47189: LIST
47190: LIST
47191: ST_TO_ADDR
// fControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
47192: LD_ADDR_VAR 0 52
47196: PUSH
47197: LD_INT 3
47199: NEG
47200: PUSH
47201: LD_INT 1
47203: NEG
47204: PUSH
47205: EMPTY
47206: LIST
47207: LIST
47208: PUSH
47209: LD_INT 3
47211: NEG
47212: PUSH
47213: LD_INT 2
47215: NEG
47216: PUSH
47217: EMPTY
47218: LIST
47219: LIST
47220: PUSH
47221: EMPTY
47222: LIST
47223: LIST
47224: ST_TO_ADDR
// fBarracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
47225: LD_ADDR_VAR 0 53
47229: PUSH
47230: LD_INT 1
47232: NEG
47233: PUSH
47234: LD_INT 3
47236: NEG
47237: PUSH
47238: EMPTY
47239: LIST
47240: LIST
47241: PUSH
47242: LD_INT 0
47244: PUSH
47245: LD_INT 3
47247: NEG
47248: PUSH
47249: EMPTY
47250: LIST
47251: LIST
47252: PUSH
47253: LD_INT 1
47255: PUSH
47256: LD_INT 2
47258: NEG
47259: PUSH
47260: EMPTY
47261: LIST
47262: LIST
47263: PUSH
47264: EMPTY
47265: LIST
47266: LIST
47267: LIST
47268: ST_TO_ADDR
// fBarracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
47269: LD_ADDR_VAR 0 54
47273: PUSH
47274: LD_INT 2
47276: PUSH
47277: LD_INT 1
47279: NEG
47280: PUSH
47281: EMPTY
47282: LIST
47283: LIST
47284: PUSH
47285: LD_INT 3
47287: PUSH
47288: LD_INT 0
47290: PUSH
47291: EMPTY
47292: LIST
47293: LIST
47294: PUSH
47295: LD_INT 3
47297: PUSH
47298: LD_INT 1
47300: PUSH
47301: EMPTY
47302: LIST
47303: LIST
47304: PUSH
47305: EMPTY
47306: LIST
47307: LIST
47308: LIST
47309: ST_TO_ADDR
// fBarracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
47310: LD_ADDR_VAR 0 55
47314: PUSH
47315: LD_INT 3
47317: PUSH
47318: LD_INT 2
47320: PUSH
47321: EMPTY
47322: LIST
47323: LIST
47324: PUSH
47325: LD_INT 3
47327: PUSH
47328: LD_INT 3
47330: PUSH
47331: EMPTY
47332: LIST
47333: LIST
47334: PUSH
47335: LD_INT 2
47337: PUSH
47338: LD_INT 3
47340: PUSH
47341: EMPTY
47342: LIST
47343: LIST
47344: PUSH
47345: EMPTY
47346: LIST
47347: LIST
47348: LIST
47349: ST_TO_ADDR
// fBarracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
47350: LD_ADDR_VAR 0 56
47354: PUSH
47355: LD_INT 1
47357: PUSH
47358: LD_INT 3
47360: PUSH
47361: EMPTY
47362: LIST
47363: LIST
47364: PUSH
47365: LD_INT 0
47367: PUSH
47368: LD_INT 3
47370: PUSH
47371: EMPTY
47372: LIST
47373: LIST
47374: PUSH
47375: LD_INT 1
47377: NEG
47378: PUSH
47379: LD_INT 2
47381: PUSH
47382: EMPTY
47383: LIST
47384: LIST
47385: PUSH
47386: EMPTY
47387: LIST
47388: LIST
47389: LIST
47390: ST_TO_ADDR
// fBarracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
47391: LD_ADDR_VAR 0 57
47395: PUSH
47396: LD_INT 2
47398: NEG
47399: PUSH
47400: LD_INT 1
47402: PUSH
47403: EMPTY
47404: LIST
47405: LIST
47406: PUSH
47407: LD_INT 3
47409: NEG
47410: PUSH
47411: LD_INT 0
47413: PUSH
47414: EMPTY
47415: LIST
47416: LIST
47417: PUSH
47418: LD_INT 3
47420: NEG
47421: PUSH
47422: LD_INT 1
47424: NEG
47425: PUSH
47426: EMPTY
47427: LIST
47428: LIST
47429: PUSH
47430: EMPTY
47431: LIST
47432: LIST
47433: LIST
47434: ST_TO_ADDR
// fBarracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
47435: LD_ADDR_VAR 0 58
47439: PUSH
47440: LD_INT 2
47442: NEG
47443: PUSH
47444: LD_INT 3
47446: NEG
47447: PUSH
47448: EMPTY
47449: LIST
47450: LIST
47451: PUSH
47452: LD_INT 3
47454: NEG
47455: PUSH
47456: LD_INT 2
47458: NEG
47459: PUSH
47460: EMPTY
47461: LIST
47462: LIST
47463: PUSH
47464: LD_INT 3
47466: NEG
47467: PUSH
47468: LD_INT 3
47470: NEG
47471: PUSH
47472: EMPTY
47473: LIST
47474: LIST
47475: PUSH
47476: EMPTY
47477: LIST
47478: LIST
47479: LIST
47480: ST_TO_ADDR
// fBunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
47481: LD_ADDR_VAR 0 59
47485: PUSH
47486: LD_INT 1
47488: NEG
47489: PUSH
47490: LD_INT 2
47492: NEG
47493: PUSH
47494: EMPTY
47495: LIST
47496: LIST
47497: PUSH
47498: LD_INT 0
47500: PUSH
47501: LD_INT 2
47503: NEG
47504: PUSH
47505: EMPTY
47506: LIST
47507: LIST
47508: PUSH
47509: LD_INT 1
47511: PUSH
47512: LD_INT 1
47514: NEG
47515: PUSH
47516: EMPTY
47517: LIST
47518: LIST
47519: PUSH
47520: EMPTY
47521: LIST
47522: LIST
47523: LIST
47524: ST_TO_ADDR
// fBunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
47525: LD_ADDR_VAR 0 60
47529: PUSH
47530: LD_INT 1
47532: PUSH
47533: LD_INT 1
47535: NEG
47536: PUSH
47537: EMPTY
47538: LIST
47539: LIST
47540: PUSH
47541: LD_INT 2
47543: PUSH
47544: LD_INT 0
47546: PUSH
47547: EMPTY
47548: LIST
47549: LIST
47550: PUSH
47551: LD_INT 2
47553: PUSH
47554: LD_INT 1
47556: PUSH
47557: EMPTY
47558: LIST
47559: LIST
47560: PUSH
47561: EMPTY
47562: LIST
47563: LIST
47564: LIST
47565: ST_TO_ADDR
// fBunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
47566: LD_ADDR_VAR 0 61
47570: PUSH
47571: LD_INT 2
47573: PUSH
47574: LD_INT 1
47576: PUSH
47577: EMPTY
47578: LIST
47579: LIST
47580: PUSH
47581: LD_INT 2
47583: PUSH
47584: LD_INT 2
47586: PUSH
47587: EMPTY
47588: LIST
47589: LIST
47590: PUSH
47591: LD_INT 1
47593: PUSH
47594: LD_INT 2
47596: PUSH
47597: EMPTY
47598: LIST
47599: LIST
47600: PUSH
47601: EMPTY
47602: LIST
47603: LIST
47604: LIST
47605: ST_TO_ADDR
// fBunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
47606: LD_ADDR_VAR 0 62
47610: PUSH
47611: LD_INT 1
47613: PUSH
47614: LD_INT 2
47616: PUSH
47617: EMPTY
47618: LIST
47619: LIST
47620: PUSH
47621: LD_INT 0
47623: PUSH
47624: LD_INT 2
47626: PUSH
47627: EMPTY
47628: LIST
47629: LIST
47630: PUSH
47631: LD_INT 1
47633: NEG
47634: PUSH
47635: LD_INT 1
47637: PUSH
47638: EMPTY
47639: LIST
47640: LIST
47641: PUSH
47642: EMPTY
47643: LIST
47644: LIST
47645: LIST
47646: ST_TO_ADDR
// fBunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
47647: LD_ADDR_VAR 0 63
47651: PUSH
47652: LD_INT 1
47654: NEG
47655: PUSH
47656: LD_INT 1
47658: PUSH
47659: EMPTY
47660: LIST
47661: LIST
47662: PUSH
47663: LD_INT 2
47665: NEG
47666: PUSH
47667: LD_INT 0
47669: PUSH
47670: EMPTY
47671: LIST
47672: LIST
47673: PUSH
47674: LD_INT 2
47676: NEG
47677: PUSH
47678: LD_INT 1
47680: NEG
47681: PUSH
47682: EMPTY
47683: LIST
47684: LIST
47685: PUSH
47686: EMPTY
47687: LIST
47688: LIST
47689: LIST
47690: ST_TO_ADDR
// fBunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
47691: LD_ADDR_VAR 0 64
47695: PUSH
47696: LD_INT 1
47698: NEG
47699: PUSH
47700: LD_INT 2
47702: NEG
47703: PUSH
47704: EMPTY
47705: LIST
47706: LIST
47707: PUSH
47708: LD_INT 2
47710: NEG
47711: PUSH
47712: LD_INT 1
47714: NEG
47715: PUSH
47716: EMPTY
47717: LIST
47718: LIST
47719: PUSH
47720: LD_INT 2
47722: NEG
47723: PUSH
47724: LD_INT 2
47726: NEG
47727: PUSH
47728: EMPTY
47729: LIST
47730: LIST
47731: PUSH
47732: EMPTY
47733: LIST
47734: LIST
47735: LIST
47736: ST_TO_ADDR
// end ; 2 :
47737: GO 51003
47739: LD_INT 2
47741: DOUBLE
47742: EQUAL
47743: IFTRUE 47747
47745: GO 51002
47747: POP
// begin fFactory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
47748: LD_ADDR_VAR 0 29
47752: PUSH
47753: LD_INT 4
47755: PUSH
47756: LD_INT 0
47758: PUSH
47759: EMPTY
47760: LIST
47761: LIST
47762: PUSH
47763: LD_INT 4
47765: PUSH
47766: LD_INT 1
47768: NEG
47769: PUSH
47770: EMPTY
47771: LIST
47772: LIST
47773: PUSH
47774: LD_INT 5
47776: PUSH
47777: LD_INT 0
47779: PUSH
47780: EMPTY
47781: LIST
47782: LIST
47783: PUSH
47784: LD_INT 5
47786: PUSH
47787: LD_INT 1
47789: PUSH
47790: EMPTY
47791: LIST
47792: LIST
47793: PUSH
47794: LD_INT 4
47796: PUSH
47797: LD_INT 1
47799: PUSH
47800: EMPTY
47801: LIST
47802: LIST
47803: PUSH
47804: LD_INT 3
47806: PUSH
47807: LD_INT 0
47809: PUSH
47810: EMPTY
47811: LIST
47812: LIST
47813: PUSH
47814: LD_INT 3
47816: PUSH
47817: LD_INT 1
47819: NEG
47820: PUSH
47821: EMPTY
47822: LIST
47823: LIST
47824: PUSH
47825: LD_INT 3
47827: PUSH
47828: LD_INT 2
47830: NEG
47831: PUSH
47832: EMPTY
47833: LIST
47834: LIST
47835: PUSH
47836: LD_INT 5
47838: PUSH
47839: LD_INT 2
47841: PUSH
47842: EMPTY
47843: LIST
47844: LIST
47845: PUSH
47846: LD_INT 3
47848: PUSH
47849: LD_INT 3
47851: PUSH
47852: EMPTY
47853: LIST
47854: LIST
47855: PUSH
47856: LD_INT 3
47858: PUSH
47859: LD_INT 2
47861: PUSH
47862: EMPTY
47863: LIST
47864: LIST
47865: PUSH
47866: LD_INT 4
47868: PUSH
47869: LD_INT 3
47871: PUSH
47872: EMPTY
47873: LIST
47874: LIST
47875: PUSH
47876: LD_INT 4
47878: PUSH
47879: LD_INT 4
47881: PUSH
47882: EMPTY
47883: LIST
47884: LIST
47885: PUSH
47886: LD_INT 3
47888: PUSH
47889: LD_INT 4
47891: PUSH
47892: EMPTY
47893: LIST
47894: LIST
47895: PUSH
47896: LD_INT 2
47898: PUSH
47899: LD_INT 3
47901: PUSH
47902: EMPTY
47903: LIST
47904: LIST
47905: PUSH
47906: LD_INT 2
47908: PUSH
47909: LD_INT 2
47911: PUSH
47912: EMPTY
47913: LIST
47914: LIST
47915: PUSH
47916: LD_INT 4
47918: PUSH
47919: LD_INT 2
47921: PUSH
47922: EMPTY
47923: LIST
47924: LIST
47925: PUSH
47926: LD_INT 2
47928: PUSH
47929: LD_INT 4
47931: PUSH
47932: EMPTY
47933: LIST
47934: LIST
47935: PUSH
47936: LD_INT 0
47938: PUSH
47939: LD_INT 4
47941: PUSH
47942: EMPTY
47943: LIST
47944: LIST
47945: PUSH
47946: LD_INT 0
47948: PUSH
47949: LD_INT 3
47951: PUSH
47952: EMPTY
47953: LIST
47954: LIST
47955: PUSH
47956: LD_INT 1
47958: PUSH
47959: LD_INT 4
47961: PUSH
47962: EMPTY
47963: LIST
47964: LIST
47965: PUSH
47966: LD_INT 1
47968: PUSH
47969: LD_INT 5
47971: PUSH
47972: EMPTY
47973: LIST
47974: LIST
47975: PUSH
47976: LD_INT 0
47978: PUSH
47979: LD_INT 5
47981: PUSH
47982: EMPTY
47983: LIST
47984: LIST
47985: PUSH
47986: LD_INT 1
47988: NEG
47989: PUSH
47990: LD_INT 4
47992: PUSH
47993: EMPTY
47994: LIST
47995: LIST
47996: PUSH
47997: LD_INT 1
47999: NEG
48000: PUSH
48001: LD_INT 3
48003: PUSH
48004: EMPTY
48005: LIST
48006: LIST
48007: PUSH
48008: LD_INT 2
48010: PUSH
48011: LD_INT 5
48013: PUSH
48014: EMPTY
48015: LIST
48016: LIST
48017: PUSH
48018: LD_INT 2
48020: NEG
48021: PUSH
48022: LD_INT 3
48024: PUSH
48025: EMPTY
48026: LIST
48027: LIST
48028: PUSH
48029: LD_INT 3
48031: NEG
48032: PUSH
48033: LD_INT 0
48035: PUSH
48036: EMPTY
48037: LIST
48038: LIST
48039: PUSH
48040: LD_INT 3
48042: NEG
48043: PUSH
48044: LD_INT 1
48046: NEG
48047: PUSH
48048: EMPTY
48049: LIST
48050: LIST
48051: PUSH
48052: LD_INT 2
48054: NEG
48055: PUSH
48056: LD_INT 0
48058: PUSH
48059: EMPTY
48060: LIST
48061: LIST
48062: PUSH
48063: LD_INT 2
48065: NEG
48066: PUSH
48067: LD_INT 1
48069: PUSH
48070: EMPTY
48071: LIST
48072: LIST
48073: PUSH
48074: LD_INT 3
48076: NEG
48077: PUSH
48078: LD_INT 1
48080: PUSH
48081: EMPTY
48082: LIST
48083: LIST
48084: PUSH
48085: LD_INT 4
48087: NEG
48088: PUSH
48089: LD_INT 0
48091: PUSH
48092: EMPTY
48093: LIST
48094: LIST
48095: PUSH
48096: LD_INT 4
48098: NEG
48099: PUSH
48100: LD_INT 1
48102: NEG
48103: PUSH
48104: EMPTY
48105: LIST
48106: LIST
48107: PUSH
48108: LD_INT 4
48110: NEG
48111: PUSH
48112: LD_INT 2
48114: NEG
48115: PUSH
48116: EMPTY
48117: LIST
48118: LIST
48119: PUSH
48120: LD_INT 2
48122: NEG
48123: PUSH
48124: LD_INT 2
48126: PUSH
48127: EMPTY
48128: LIST
48129: LIST
48130: PUSH
48131: LD_INT 4
48133: NEG
48134: PUSH
48135: LD_INT 4
48137: NEG
48138: PUSH
48139: EMPTY
48140: LIST
48141: LIST
48142: PUSH
48143: LD_INT 4
48145: NEG
48146: PUSH
48147: LD_INT 5
48149: NEG
48150: PUSH
48151: EMPTY
48152: LIST
48153: LIST
48154: PUSH
48155: LD_INT 3
48157: NEG
48158: PUSH
48159: LD_INT 4
48161: NEG
48162: PUSH
48163: EMPTY
48164: LIST
48165: LIST
48166: PUSH
48167: LD_INT 3
48169: NEG
48170: PUSH
48171: LD_INT 3
48173: NEG
48174: PUSH
48175: EMPTY
48176: LIST
48177: LIST
48178: PUSH
48179: LD_INT 4
48181: NEG
48182: PUSH
48183: LD_INT 3
48185: NEG
48186: PUSH
48187: EMPTY
48188: LIST
48189: LIST
48190: PUSH
48191: LD_INT 5
48193: NEG
48194: PUSH
48195: LD_INT 4
48197: NEG
48198: PUSH
48199: EMPTY
48200: LIST
48201: LIST
48202: PUSH
48203: LD_INT 5
48205: NEG
48206: PUSH
48207: LD_INT 5
48209: NEG
48210: PUSH
48211: EMPTY
48212: LIST
48213: LIST
48214: PUSH
48215: LD_INT 3
48217: NEG
48218: PUSH
48219: LD_INT 5
48221: NEG
48222: PUSH
48223: EMPTY
48224: LIST
48225: LIST
48226: PUSH
48227: LD_INT 5
48229: NEG
48230: PUSH
48231: LD_INT 3
48233: NEG
48234: PUSH
48235: EMPTY
48236: LIST
48237: LIST
48238: PUSH
48239: EMPTY
48240: LIST
48241: LIST
48242: LIST
48243: LIST
48244: LIST
48245: LIST
48246: LIST
48247: LIST
48248: LIST
48249: LIST
48250: LIST
48251: LIST
48252: LIST
48253: LIST
48254: LIST
48255: LIST
48256: LIST
48257: LIST
48258: LIST
48259: LIST
48260: LIST
48261: LIST
48262: LIST
48263: LIST
48264: LIST
48265: LIST
48266: LIST
48267: LIST
48268: LIST
48269: LIST
48270: LIST
48271: LIST
48272: LIST
48273: LIST
48274: LIST
48275: LIST
48276: LIST
48277: LIST
48278: LIST
48279: LIST
48280: LIST
48281: LIST
48282: LIST
48283: LIST
48284: LIST
48285: ST_TO_ADDR
// fFactory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
48286: LD_ADDR_VAR 0 30
48290: PUSH
48291: LD_INT 4
48293: PUSH
48294: LD_INT 4
48296: PUSH
48297: EMPTY
48298: LIST
48299: LIST
48300: PUSH
48301: LD_INT 4
48303: PUSH
48304: LD_INT 3
48306: PUSH
48307: EMPTY
48308: LIST
48309: LIST
48310: PUSH
48311: LD_INT 5
48313: PUSH
48314: LD_INT 4
48316: PUSH
48317: EMPTY
48318: LIST
48319: LIST
48320: PUSH
48321: LD_INT 5
48323: PUSH
48324: LD_INT 5
48326: PUSH
48327: EMPTY
48328: LIST
48329: LIST
48330: PUSH
48331: LD_INT 4
48333: PUSH
48334: LD_INT 5
48336: PUSH
48337: EMPTY
48338: LIST
48339: LIST
48340: PUSH
48341: LD_INT 3
48343: PUSH
48344: LD_INT 4
48346: PUSH
48347: EMPTY
48348: LIST
48349: LIST
48350: PUSH
48351: LD_INT 3
48353: PUSH
48354: LD_INT 3
48356: PUSH
48357: EMPTY
48358: LIST
48359: LIST
48360: PUSH
48361: LD_INT 5
48363: PUSH
48364: LD_INT 3
48366: PUSH
48367: EMPTY
48368: LIST
48369: LIST
48370: PUSH
48371: LD_INT 3
48373: PUSH
48374: LD_INT 5
48376: PUSH
48377: EMPTY
48378: LIST
48379: LIST
48380: PUSH
48381: LD_INT 0
48383: PUSH
48384: LD_INT 3
48386: PUSH
48387: EMPTY
48388: LIST
48389: LIST
48390: PUSH
48391: LD_INT 0
48393: PUSH
48394: LD_INT 2
48396: PUSH
48397: EMPTY
48398: LIST
48399: LIST
48400: PUSH
48401: LD_INT 1
48403: PUSH
48404: LD_INT 3
48406: PUSH
48407: EMPTY
48408: LIST
48409: LIST
48410: PUSH
48411: LD_INT 1
48413: PUSH
48414: LD_INT 4
48416: PUSH
48417: EMPTY
48418: LIST
48419: LIST
48420: PUSH
48421: LD_INT 0
48423: PUSH
48424: LD_INT 4
48426: PUSH
48427: EMPTY
48428: LIST
48429: LIST
48430: PUSH
48431: LD_INT 1
48433: NEG
48434: PUSH
48435: LD_INT 3
48437: PUSH
48438: EMPTY
48439: LIST
48440: LIST
48441: PUSH
48442: LD_INT 1
48444: NEG
48445: PUSH
48446: LD_INT 2
48448: PUSH
48449: EMPTY
48450: LIST
48451: LIST
48452: PUSH
48453: LD_INT 2
48455: PUSH
48456: LD_INT 4
48458: PUSH
48459: EMPTY
48460: LIST
48461: LIST
48462: PUSH
48463: LD_INT 2
48465: NEG
48466: PUSH
48467: LD_INT 2
48469: PUSH
48470: EMPTY
48471: LIST
48472: LIST
48473: PUSH
48474: LD_INT 4
48476: NEG
48477: PUSH
48478: LD_INT 0
48480: PUSH
48481: EMPTY
48482: LIST
48483: LIST
48484: PUSH
48485: LD_INT 4
48487: NEG
48488: PUSH
48489: LD_INT 1
48491: NEG
48492: PUSH
48493: EMPTY
48494: LIST
48495: LIST
48496: PUSH
48497: LD_INT 3
48499: NEG
48500: PUSH
48501: LD_INT 0
48503: PUSH
48504: EMPTY
48505: LIST
48506: LIST
48507: PUSH
48508: LD_INT 3
48510: NEG
48511: PUSH
48512: LD_INT 1
48514: PUSH
48515: EMPTY
48516: LIST
48517: LIST
48518: PUSH
48519: LD_INT 4
48521: NEG
48522: PUSH
48523: LD_INT 1
48525: PUSH
48526: EMPTY
48527: LIST
48528: LIST
48529: PUSH
48530: LD_INT 5
48532: NEG
48533: PUSH
48534: LD_INT 0
48536: PUSH
48537: EMPTY
48538: LIST
48539: LIST
48540: PUSH
48541: LD_INT 5
48543: NEG
48544: PUSH
48545: LD_INT 1
48547: NEG
48548: PUSH
48549: EMPTY
48550: LIST
48551: LIST
48552: PUSH
48553: LD_INT 5
48555: NEG
48556: PUSH
48557: LD_INT 2
48559: NEG
48560: PUSH
48561: EMPTY
48562: LIST
48563: LIST
48564: PUSH
48565: LD_INT 3
48567: NEG
48568: PUSH
48569: LD_INT 2
48571: PUSH
48572: EMPTY
48573: LIST
48574: LIST
48575: PUSH
48576: LD_INT 3
48578: NEG
48579: PUSH
48580: LD_INT 3
48582: NEG
48583: PUSH
48584: EMPTY
48585: LIST
48586: LIST
48587: PUSH
48588: LD_INT 3
48590: NEG
48591: PUSH
48592: LD_INT 4
48594: NEG
48595: PUSH
48596: EMPTY
48597: LIST
48598: LIST
48599: PUSH
48600: LD_INT 2
48602: NEG
48603: PUSH
48604: LD_INT 3
48606: NEG
48607: PUSH
48608: EMPTY
48609: LIST
48610: LIST
48611: PUSH
48612: LD_INT 2
48614: NEG
48615: PUSH
48616: LD_INT 2
48618: NEG
48619: PUSH
48620: EMPTY
48621: LIST
48622: LIST
48623: PUSH
48624: LD_INT 3
48626: NEG
48627: PUSH
48628: LD_INT 2
48630: NEG
48631: PUSH
48632: EMPTY
48633: LIST
48634: LIST
48635: PUSH
48636: LD_INT 4
48638: NEG
48639: PUSH
48640: LD_INT 3
48642: NEG
48643: PUSH
48644: EMPTY
48645: LIST
48646: LIST
48647: PUSH
48648: LD_INT 4
48650: NEG
48651: PUSH
48652: LD_INT 4
48654: NEG
48655: PUSH
48656: EMPTY
48657: LIST
48658: LIST
48659: PUSH
48660: LD_INT 2
48662: NEG
48663: PUSH
48664: LD_INT 4
48666: NEG
48667: PUSH
48668: EMPTY
48669: LIST
48670: LIST
48671: PUSH
48672: LD_INT 4
48674: NEG
48675: PUSH
48676: LD_INT 2
48678: NEG
48679: PUSH
48680: EMPTY
48681: LIST
48682: LIST
48683: PUSH
48684: LD_INT 0
48686: PUSH
48687: LD_INT 4
48689: NEG
48690: PUSH
48691: EMPTY
48692: LIST
48693: LIST
48694: PUSH
48695: LD_INT 0
48697: PUSH
48698: LD_INT 5
48700: NEG
48701: PUSH
48702: EMPTY
48703: LIST
48704: LIST
48705: PUSH
48706: LD_INT 1
48708: PUSH
48709: LD_INT 4
48711: NEG
48712: PUSH
48713: EMPTY
48714: LIST
48715: LIST
48716: PUSH
48717: LD_INT 1
48719: PUSH
48720: LD_INT 3
48722: NEG
48723: PUSH
48724: EMPTY
48725: LIST
48726: LIST
48727: PUSH
48728: LD_INT 0
48730: PUSH
48731: LD_INT 3
48733: NEG
48734: PUSH
48735: EMPTY
48736: LIST
48737: LIST
48738: PUSH
48739: LD_INT 1
48741: NEG
48742: PUSH
48743: LD_INT 4
48745: NEG
48746: PUSH
48747: EMPTY
48748: LIST
48749: LIST
48750: PUSH
48751: LD_INT 1
48753: NEG
48754: PUSH
48755: LD_INT 5
48757: NEG
48758: PUSH
48759: EMPTY
48760: LIST
48761: LIST
48762: PUSH
48763: LD_INT 2
48765: PUSH
48766: LD_INT 3
48768: NEG
48769: PUSH
48770: EMPTY
48771: LIST
48772: LIST
48773: PUSH
48774: LD_INT 2
48776: NEG
48777: PUSH
48778: LD_INT 5
48780: NEG
48781: PUSH
48782: EMPTY
48783: LIST
48784: LIST
48785: PUSH
48786: EMPTY
48787: LIST
48788: LIST
48789: LIST
48790: LIST
48791: LIST
48792: LIST
48793: LIST
48794: LIST
48795: LIST
48796: LIST
48797: LIST
48798: LIST
48799: LIST
48800: LIST
48801: LIST
48802: LIST
48803: LIST
48804: LIST
48805: LIST
48806: LIST
48807: LIST
48808: LIST
48809: LIST
48810: LIST
48811: LIST
48812: LIST
48813: LIST
48814: LIST
48815: LIST
48816: LIST
48817: LIST
48818: LIST
48819: LIST
48820: LIST
48821: LIST
48822: LIST
48823: LIST
48824: LIST
48825: LIST
48826: LIST
48827: LIST
48828: LIST
48829: LIST
48830: LIST
48831: LIST
48832: ST_TO_ADDR
// fFactory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
48833: LD_ADDR_VAR 0 31
48837: PUSH
48838: LD_INT 0
48840: PUSH
48841: LD_INT 4
48843: PUSH
48844: EMPTY
48845: LIST
48846: LIST
48847: PUSH
48848: LD_INT 0
48850: PUSH
48851: LD_INT 3
48853: PUSH
48854: EMPTY
48855: LIST
48856: LIST
48857: PUSH
48858: LD_INT 1
48860: PUSH
48861: LD_INT 4
48863: PUSH
48864: EMPTY
48865: LIST
48866: LIST
48867: PUSH
48868: LD_INT 1
48870: PUSH
48871: LD_INT 5
48873: PUSH
48874: EMPTY
48875: LIST
48876: LIST
48877: PUSH
48878: LD_INT 0
48880: PUSH
48881: LD_INT 5
48883: PUSH
48884: EMPTY
48885: LIST
48886: LIST
48887: PUSH
48888: LD_INT 1
48890: NEG
48891: PUSH
48892: LD_INT 4
48894: PUSH
48895: EMPTY
48896: LIST
48897: LIST
48898: PUSH
48899: LD_INT 1
48901: NEG
48902: PUSH
48903: LD_INT 3
48905: PUSH
48906: EMPTY
48907: LIST
48908: LIST
48909: PUSH
48910: LD_INT 2
48912: PUSH
48913: LD_INT 5
48915: PUSH
48916: EMPTY
48917: LIST
48918: LIST
48919: PUSH
48920: LD_INT 2
48922: NEG
48923: PUSH
48924: LD_INT 3
48926: PUSH
48927: EMPTY
48928: LIST
48929: LIST
48930: PUSH
48931: LD_INT 3
48933: NEG
48934: PUSH
48935: LD_INT 0
48937: PUSH
48938: EMPTY
48939: LIST
48940: LIST
48941: PUSH
48942: LD_INT 3
48944: NEG
48945: PUSH
48946: LD_INT 1
48948: NEG
48949: PUSH
48950: EMPTY
48951: LIST
48952: LIST
48953: PUSH
48954: LD_INT 2
48956: NEG
48957: PUSH
48958: LD_INT 0
48960: PUSH
48961: EMPTY
48962: LIST
48963: LIST
48964: PUSH
48965: LD_INT 2
48967: NEG
48968: PUSH
48969: LD_INT 1
48971: PUSH
48972: EMPTY
48973: LIST
48974: LIST
48975: PUSH
48976: LD_INT 3
48978: NEG
48979: PUSH
48980: LD_INT 1
48982: PUSH
48983: EMPTY
48984: LIST
48985: LIST
48986: PUSH
48987: LD_INT 4
48989: NEG
48990: PUSH
48991: LD_INT 0
48993: PUSH
48994: EMPTY
48995: LIST
48996: LIST
48997: PUSH
48998: LD_INT 4
49000: NEG
49001: PUSH
49002: LD_INT 1
49004: NEG
49005: PUSH
49006: EMPTY
49007: LIST
49008: LIST
49009: PUSH
49010: LD_INT 4
49012: NEG
49013: PUSH
49014: LD_INT 2
49016: NEG
49017: PUSH
49018: EMPTY
49019: LIST
49020: LIST
49021: PUSH
49022: LD_INT 2
49024: NEG
49025: PUSH
49026: LD_INT 2
49028: PUSH
49029: EMPTY
49030: LIST
49031: LIST
49032: PUSH
49033: LD_INT 4
49035: NEG
49036: PUSH
49037: LD_INT 4
49039: NEG
49040: PUSH
49041: EMPTY
49042: LIST
49043: LIST
49044: PUSH
49045: LD_INT 4
49047: NEG
49048: PUSH
49049: LD_INT 5
49051: NEG
49052: PUSH
49053: EMPTY
49054: LIST
49055: LIST
49056: PUSH
49057: LD_INT 3
49059: NEG
49060: PUSH
49061: LD_INT 4
49063: NEG
49064: PUSH
49065: EMPTY
49066: LIST
49067: LIST
49068: PUSH
49069: LD_INT 3
49071: NEG
49072: PUSH
49073: LD_INT 3
49075: NEG
49076: PUSH
49077: EMPTY
49078: LIST
49079: LIST
49080: PUSH
49081: LD_INT 4
49083: NEG
49084: PUSH
49085: LD_INT 3
49087: NEG
49088: PUSH
49089: EMPTY
49090: LIST
49091: LIST
49092: PUSH
49093: LD_INT 5
49095: NEG
49096: PUSH
49097: LD_INT 4
49099: NEG
49100: PUSH
49101: EMPTY
49102: LIST
49103: LIST
49104: PUSH
49105: LD_INT 5
49107: NEG
49108: PUSH
49109: LD_INT 5
49111: NEG
49112: PUSH
49113: EMPTY
49114: LIST
49115: LIST
49116: PUSH
49117: LD_INT 3
49119: NEG
49120: PUSH
49121: LD_INT 5
49123: NEG
49124: PUSH
49125: EMPTY
49126: LIST
49127: LIST
49128: PUSH
49129: LD_INT 5
49131: NEG
49132: PUSH
49133: LD_INT 3
49135: NEG
49136: PUSH
49137: EMPTY
49138: LIST
49139: LIST
49140: PUSH
49141: LD_INT 0
49143: PUSH
49144: LD_INT 3
49146: NEG
49147: PUSH
49148: EMPTY
49149: LIST
49150: LIST
49151: PUSH
49152: LD_INT 0
49154: PUSH
49155: LD_INT 4
49157: NEG
49158: PUSH
49159: EMPTY
49160: LIST
49161: LIST
49162: PUSH
49163: LD_INT 1
49165: PUSH
49166: LD_INT 3
49168: NEG
49169: PUSH
49170: EMPTY
49171: LIST
49172: LIST
49173: PUSH
49174: LD_INT 1
49176: PUSH
49177: LD_INT 2
49179: NEG
49180: PUSH
49181: EMPTY
49182: LIST
49183: LIST
49184: PUSH
49185: LD_INT 0
49187: PUSH
49188: LD_INT 2
49190: NEG
49191: PUSH
49192: EMPTY
49193: LIST
49194: LIST
49195: PUSH
49196: LD_INT 1
49198: NEG
49199: PUSH
49200: LD_INT 3
49202: NEG
49203: PUSH
49204: EMPTY
49205: LIST
49206: LIST
49207: PUSH
49208: LD_INT 1
49210: NEG
49211: PUSH
49212: LD_INT 4
49214: NEG
49215: PUSH
49216: EMPTY
49217: LIST
49218: LIST
49219: PUSH
49220: LD_INT 2
49222: PUSH
49223: LD_INT 2
49225: NEG
49226: PUSH
49227: EMPTY
49228: LIST
49229: LIST
49230: PUSH
49231: LD_INT 2
49233: NEG
49234: PUSH
49235: LD_INT 4
49237: NEG
49238: PUSH
49239: EMPTY
49240: LIST
49241: LIST
49242: PUSH
49243: LD_INT 4
49245: PUSH
49246: LD_INT 0
49248: PUSH
49249: EMPTY
49250: LIST
49251: LIST
49252: PUSH
49253: LD_INT 4
49255: PUSH
49256: LD_INT 1
49258: NEG
49259: PUSH
49260: EMPTY
49261: LIST
49262: LIST
49263: PUSH
49264: LD_INT 5
49266: PUSH
49267: LD_INT 0
49269: PUSH
49270: EMPTY
49271: LIST
49272: LIST
49273: PUSH
49274: LD_INT 5
49276: PUSH
49277: LD_INT 1
49279: PUSH
49280: EMPTY
49281: LIST
49282: LIST
49283: PUSH
49284: LD_INT 4
49286: PUSH
49287: LD_INT 1
49289: PUSH
49290: EMPTY
49291: LIST
49292: LIST
49293: PUSH
49294: LD_INT 3
49296: PUSH
49297: LD_INT 0
49299: PUSH
49300: EMPTY
49301: LIST
49302: LIST
49303: PUSH
49304: LD_INT 3
49306: PUSH
49307: LD_INT 1
49309: NEG
49310: PUSH
49311: EMPTY
49312: LIST
49313: LIST
49314: PUSH
49315: LD_INT 3
49317: PUSH
49318: LD_INT 2
49320: NEG
49321: PUSH
49322: EMPTY
49323: LIST
49324: LIST
49325: PUSH
49326: LD_INT 5
49328: PUSH
49329: LD_INT 2
49331: PUSH
49332: EMPTY
49333: LIST
49334: LIST
49335: PUSH
49336: EMPTY
49337: LIST
49338: LIST
49339: LIST
49340: LIST
49341: LIST
49342: LIST
49343: LIST
49344: LIST
49345: LIST
49346: LIST
49347: LIST
49348: LIST
49349: LIST
49350: LIST
49351: LIST
49352: LIST
49353: LIST
49354: LIST
49355: LIST
49356: LIST
49357: LIST
49358: LIST
49359: LIST
49360: LIST
49361: LIST
49362: LIST
49363: LIST
49364: LIST
49365: LIST
49366: LIST
49367: LIST
49368: LIST
49369: LIST
49370: LIST
49371: LIST
49372: LIST
49373: LIST
49374: LIST
49375: LIST
49376: LIST
49377: LIST
49378: LIST
49379: LIST
49380: LIST
49381: LIST
49382: ST_TO_ADDR
// fFactory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
49383: LD_ADDR_VAR 0 32
49387: PUSH
49388: LD_INT 4
49390: NEG
49391: PUSH
49392: LD_INT 0
49394: PUSH
49395: EMPTY
49396: LIST
49397: LIST
49398: PUSH
49399: LD_INT 4
49401: NEG
49402: PUSH
49403: LD_INT 1
49405: NEG
49406: PUSH
49407: EMPTY
49408: LIST
49409: LIST
49410: PUSH
49411: LD_INT 3
49413: NEG
49414: PUSH
49415: LD_INT 0
49417: PUSH
49418: EMPTY
49419: LIST
49420: LIST
49421: PUSH
49422: LD_INT 3
49424: NEG
49425: PUSH
49426: LD_INT 1
49428: PUSH
49429: EMPTY
49430: LIST
49431: LIST
49432: PUSH
49433: LD_INT 4
49435: NEG
49436: PUSH
49437: LD_INT 1
49439: PUSH
49440: EMPTY
49441: LIST
49442: LIST
49443: PUSH
49444: LD_INT 5
49446: NEG
49447: PUSH
49448: LD_INT 0
49450: PUSH
49451: EMPTY
49452: LIST
49453: LIST
49454: PUSH
49455: LD_INT 5
49457: NEG
49458: PUSH
49459: LD_INT 1
49461: NEG
49462: PUSH
49463: EMPTY
49464: LIST
49465: LIST
49466: PUSH
49467: LD_INT 5
49469: NEG
49470: PUSH
49471: LD_INT 2
49473: NEG
49474: PUSH
49475: EMPTY
49476: LIST
49477: LIST
49478: PUSH
49479: LD_INT 3
49481: NEG
49482: PUSH
49483: LD_INT 2
49485: PUSH
49486: EMPTY
49487: LIST
49488: LIST
49489: PUSH
49490: LD_INT 3
49492: NEG
49493: PUSH
49494: LD_INT 3
49496: NEG
49497: PUSH
49498: EMPTY
49499: LIST
49500: LIST
49501: PUSH
49502: LD_INT 3
49504: NEG
49505: PUSH
49506: LD_INT 4
49508: NEG
49509: PUSH
49510: EMPTY
49511: LIST
49512: LIST
49513: PUSH
49514: LD_INT 2
49516: NEG
49517: PUSH
49518: LD_INT 3
49520: NEG
49521: PUSH
49522: EMPTY
49523: LIST
49524: LIST
49525: PUSH
49526: LD_INT 2
49528: NEG
49529: PUSH
49530: LD_INT 2
49532: NEG
49533: PUSH
49534: EMPTY
49535: LIST
49536: LIST
49537: PUSH
49538: LD_INT 3
49540: NEG
49541: PUSH
49542: LD_INT 2
49544: NEG
49545: PUSH
49546: EMPTY
49547: LIST
49548: LIST
49549: PUSH
49550: LD_INT 4
49552: NEG
49553: PUSH
49554: LD_INT 3
49556: NEG
49557: PUSH
49558: EMPTY
49559: LIST
49560: LIST
49561: PUSH
49562: LD_INT 4
49564: NEG
49565: PUSH
49566: LD_INT 4
49568: NEG
49569: PUSH
49570: EMPTY
49571: LIST
49572: LIST
49573: PUSH
49574: LD_INT 2
49576: NEG
49577: PUSH
49578: LD_INT 4
49580: NEG
49581: PUSH
49582: EMPTY
49583: LIST
49584: LIST
49585: PUSH
49586: LD_INT 4
49588: NEG
49589: PUSH
49590: LD_INT 2
49592: NEG
49593: PUSH
49594: EMPTY
49595: LIST
49596: LIST
49597: PUSH
49598: LD_INT 0
49600: PUSH
49601: LD_INT 4
49603: NEG
49604: PUSH
49605: EMPTY
49606: LIST
49607: LIST
49608: PUSH
49609: LD_INT 0
49611: PUSH
49612: LD_INT 5
49614: NEG
49615: PUSH
49616: EMPTY
49617: LIST
49618: LIST
49619: PUSH
49620: LD_INT 1
49622: PUSH
49623: LD_INT 4
49625: NEG
49626: PUSH
49627: EMPTY
49628: LIST
49629: LIST
49630: PUSH
49631: LD_INT 1
49633: PUSH
49634: LD_INT 3
49636: NEG
49637: PUSH
49638: EMPTY
49639: LIST
49640: LIST
49641: PUSH
49642: LD_INT 0
49644: PUSH
49645: LD_INT 3
49647: NEG
49648: PUSH
49649: EMPTY
49650: LIST
49651: LIST
49652: PUSH
49653: LD_INT 1
49655: NEG
49656: PUSH
49657: LD_INT 4
49659: NEG
49660: PUSH
49661: EMPTY
49662: LIST
49663: LIST
49664: PUSH
49665: LD_INT 1
49667: NEG
49668: PUSH
49669: LD_INT 5
49671: NEG
49672: PUSH
49673: EMPTY
49674: LIST
49675: LIST
49676: PUSH
49677: LD_INT 2
49679: PUSH
49680: LD_INT 3
49682: NEG
49683: PUSH
49684: EMPTY
49685: LIST
49686: LIST
49687: PUSH
49688: LD_INT 2
49690: NEG
49691: PUSH
49692: LD_INT 5
49694: NEG
49695: PUSH
49696: EMPTY
49697: LIST
49698: LIST
49699: PUSH
49700: LD_INT 3
49702: PUSH
49703: LD_INT 0
49705: PUSH
49706: EMPTY
49707: LIST
49708: LIST
49709: PUSH
49710: LD_INT 3
49712: PUSH
49713: LD_INT 1
49715: NEG
49716: PUSH
49717: EMPTY
49718: LIST
49719: LIST
49720: PUSH
49721: LD_INT 4
49723: PUSH
49724: LD_INT 0
49726: PUSH
49727: EMPTY
49728: LIST
49729: LIST
49730: PUSH
49731: LD_INT 4
49733: PUSH
49734: LD_INT 1
49736: PUSH
49737: EMPTY
49738: LIST
49739: LIST
49740: PUSH
49741: LD_INT 3
49743: PUSH
49744: LD_INT 1
49746: PUSH
49747: EMPTY
49748: LIST
49749: LIST
49750: PUSH
49751: LD_INT 2
49753: PUSH
49754: LD_INT 0
49756: PUSH
49757: EMPTY
49758: LIST
49759: LIST
49760: PUSH
49761: LD_INT 2
49763: PUSH
49764: LD_INT 1
49766: NEG
49767: PUSH
49768: EMPTY
49769: LIST
49770: LIST
49771: PUSH
49772: LD_INT 2
49774: PUSH
49775: LD_INT 2
49777: NEG
49778: PUSH
49779: EMPTY
49780: LIST
49781: LIST
49782: PUSH
49783: LD_INT 4
49785: PUSH
49786: LD_INT 2
49788: PUSH
49789: EMPTY
49790: LIST
49791: LIST
49792: PUSH
49793: LD_INT 4
49795: PUSH
49796: LD_INT 4
49798: PUSH
49799: EMPTY
49800: LIST
49801: LIST
49802: PUSH
49803: LD_INT 4
49805: PUSH
49806: LD_INT 3
49808: PUSH
49809: EMPTY
49810: LIST
49811: LIST
49812: PUSH
49813: LD_INT 5
49815: PUSH
49816: LD_INT 4
49818: PUSH
49819: EMPTY
49820: LIST
49821: LIST
49822: PUSH
49823: LD_INT 5
49825: PUSH
49826: LD_INT 5
49828: PUSH
49829: EMPTY
49830: LIST
49831: LIST
49832: PUSH
49833: LD_INT 4
49835: PUSH
49836: LD_INT 5
49838: PUSH
49839: EMPTY
49840: LIST
49841: LIST
49842: PUSH
49843: LD_INT 3
49845: PUSH
49846: LD_INT 4
49848: PUSH
49849: EMPTY
49850: LIST
49851: LIST
49852: PUSH
49853: LD_INT 3
49855: PUSH
49856: LD_INT 3
49858: PUSH
49859: EMPTY
49860: LIST
49861: LIST
49862: PUSH
49863: LD_INT 5
49865: PUSH
49866: LD_INT 3
49868: PUSH
49869: EMPTY
49870: LIST
49871: LIST
49872: PUSH
49873: LD_INT 3
49875: PUSH
49876: LD_INT 5
49878: PUSH
49879: EMPTY
49880: LIST
49881: LIST
49882: PUSH
49883: EMPTY
49884: LIST
49885: LIST
49886: LIST
49887: LIST
49888: LIST
49889: LIST
49890: LIST
49891: LIST
49892: LIST
49893: LIST
49894: LIST
49895: LIST
49896: LIST
49897: LIST
49898: LIST
49899: LIST
49900: LIST
49901: LIST
49902: LIST
49903: LIST
49904: LIST
49905: LIST
49906: LIST
49907: LIST
49908: LIST
49909: LIST
49910: LIST
49911: LIST
49912: LIST
49913: LIST
49914: LIST
49915: LIST
49916: LIST
49917: LIST
49918: LIST
49919: LIST
49920: LIST
49921: LIST
49922: LIST
49923: LIST
49924: LIST
49925: LIST
49926: LIST
49927: LIST
49928: LIST
49929: ST_TO_ADDR
// fFactory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
49930: LD_ADDR_VAR 0 33
49934: PUSH
49935: LD_INT 4
49937: NEG
49938: PUSH
49939: LD_INT 4
49941: NEG
49942: PUSH
49943: EMPTY
49944: LIST
49945: LIST
49946: PUSH
49947: LD_INT 4
49949: NEG
49950: PUSH
49951: LD_INT 5
49953: NEG
49954: PUSH
49955: EMPTY
49956: LIST
49957: LIST
49958: PUSH
49959: LD_INT 3
49961: NEG
49962: PUSH
49963: LD_INT 4
49965: NEG
49966: PUSH
49967: EMPTY
49968: LIST
49969: LIST
49970: PUSH
49971: LD_INT 3
49973: NEG
49974: PUSH
49975: LD_INT 3
49977: NEG
49978: PUSH
49979: EMPTY
49980: LIST
49981: LIST
49982: PUSH
49983: LD_INT 4
49985: NEG
49986: PUSH
49987: LD_INT 3
49989: NEG
49990: PUSH
49991: EMPTY
49992: LIST
49993: LIST
49994: PUSH
49995: LD_INT 5
49997: NEG
49998: PUSH
49999: LD_INT 4
50001: NEG
50002: PUSH
50003: EMPTY
50004: LIST
50005: LIST
50006: PUSH
50007: LD_INT 5
50009: NEG
50010: PUSH
50011: LD_INT 5
50013: NEG
50014: PUSH
50015: EMPTY
50016: LIST
50017: LIST
50018: PUSH
50019: LD_INT 3
50021: NEG
50022: PUSH
50023: LD_INT 5
50025: NEG
50026: PUSH
50027: EMPTY
50028: LIST
50029: LIST
50030: PUSH
50031: LD_INT 5
50033: NEG
50034: PUSH
50035: LD_INT 3
50037: NEG
50038: PUSH
50039: EMPTY
50040: LIST
50041: LIST
50042: PUSH
50043: LD_INT 0
50045: PUSH
50046: LD_INT 3
50048: NEG
50049: PUSH
50050: EMPTY
50051: LIST
50052: LIST
50053: PUSH
50054: LD_INT 0
50056: PUSH
50057: LD_INT 4
50059: NEG
50060: PUSH
50061: EMPTY
50062: LIST
50063: LIST
50064: PUSH
50065: LD_INT 1
50067: PUSH
50068: LD_INT 3
50070: NEG
50071: PUSH
50072: EMPTY
50073: LIST
50074: LIST
50075: PUSH
50076: LD_INT 1
50078: PUSH
50079: LD_INT 2
50081: NEG
50082: PUSH
50083: EMPTY
50084: LIST
50085: LIST
50086: PUSH
50087: LD_INT 0
50089: PUSH
50090: LD_INT 2
50092: NEG
50093: PUSH
50094: EMPTY
50095: LIST
50096: LIST
50097: PUSH
50098: LD_INT 1
50100: NEG
50101: PUSH
50102: LD_INT 3
50104: NEG
50105: PUSH
50106: EMPTY
50107: LIST
50108: LIST
50109: PUSH
50110: LD_INT 1
50112: NEG
50113: PUSH
50114: LD_INT 4
50116: NEG
50117: PUSH
50118: EMPTY
50119: LIST
50120: LIST
50121: PUSH
50122: LD_INT 2
50124: PUSH
50125: LD_INT 2
50127: NEG
50128: PUSH
50129: EMPTY
50130: LIST
50131: LIST
50132: PUSH
50133: LD_INT 2
50135: NEG
50136: PUSH
50137: LD_INT 4
50139: NEG
50140: PUSH
50141: EMPTY
50142: LIST
50143: LIST
50144: PUSH
50145: LD_INT 4
50147: PUSH
50148: LD_INT 0
50150: PUSH
50151: EMPTY
50152: LIST
50153: LIST
50154: PUSH
50155: LD_INT 4
50157: PUSH
50158: LD_INT 1
50160: NEG
50161: PUSH
50162: EMPTY
50163: LIST
50164: LIST
50165: PUSH
50166: LD_INT 5
50168: PUSH
50169: LD_INT 0
50171: PUSH
50172: EMPTY
50173: LIST
50174: LIST
50175: PUSH
50176: LD_INT 5
50178: PUSH
50179: LD_INT 1
50181: PUSH
50182: EMPTY
50183: LIST
50184: LIST
50185: PUSH
50186: LD_INT 4
50188: PUSH
50189: LD_INT 1
50191: PUSH
50192: EMPTY
50193: LIST
50194: LIST
50195: PUSH
50196: LD_INT 3
50198: PUSH
50199: LD_INT 0
50201: PUSH
50202: EMPTY
50203: LIST
50204: LIST
50205: PUSH
50206: LD_INT 3
50208: PUSH
50209: LD_INT 1
50211: NEG
50212: PUSH
50213: EMPTY
50214: LIST
50215: LIST
50216: PUSH
50217: LD_INT 3
50219: PUSH
50220: LD_INT 2
50222: NEG
50223: PUSH
50224: EMPTY
50225: LIST
50226: LIST
50227: PUSH
50228: LD_INT 5
50230: PUSH
50231: LD_INT 2
50233: PUSH
50234: EMPTY
50235: LIST
50236: LIST
50237: PUSH
50238: LD_INT 3
50240: PUSH
50241: LD_INT 3
50243: PUSH
50244: EMPTY
50245: LIST
50246: LIST
50247: PUSH
50248: LD_INT 3
50250: PUSH
50251: LD_INT 2
50253: PUSH
50254: EMPTY
50255: LIST
50256: LIST
50257: PUSH
50258: LD_INT 4
50260: PUSH
50261: LD_INT 3
50263: PUSH
50264: EMPTY
50265: LIST
50266: LIST
50267: PUSH
50268: LD_INT 4
50270: PUSH
50271: LD_INT 4
50273: PUSH
50274: EMPTY
50275: LIST
50276: LIST
50277: PUSH
50278: LD_INT 3
50280: PUSH
50281: LD_INT 4
50283: PUSH
50284: EMPTY
50285: LIST
50286: LIST
50287: PUSH
50288: LD_INT 2
50290: PUSH
50291: LD_INT 3
50293: PUSH
50294: EMPTY
50295: LIST
50296: LIST
50297: PUSH
50298: LD_INT 2
50300: PUSH
50301: LD_INT 2
50303: PUSH
50304: EMPTY
50305: LIST
50306: LIST
50307: PUSH
50308: LD_INT 4
50310: PUSH
50311: LD_INT 2
50313: PUSH
50314: EMPTY
50315: LIST
50316: LIST
50317: PUSH
50318: LD_INT 2
50320: PUSH
50321: LD_INT 4
50323: PUSH
50324: EMPTY
50325: LIST
50326: LIST
50327: PUSH
50328: LD_INT 0
50330: PUSH
50331: LD_INT 4
50333: PUSH
50334: EMPTY
50335: LIST
50336: LIST
50337: PUSH
50338: LD_INT 0
50340: PUSH
50341: LD_INT 3
50343: PUSH
50344: EMPTY
50345: LIST
50346: LIST
50347: PUSH
50348: LD_INT 1
50350: PUSH
50351: LD_INT 4
50353: PUSH
50354: EMPTY
50355: LIST
50356: LIST
50357: PUSH
50358: LD_INT 1
50360: PUSH
50361: LD_INT 5
50363: PUSH
50364: EMPTY
50365: LIST
50366: LIST
50367: PUSH
50368: LD_INT 0
50370: PUSH
50371: LD_INT 5
50373: PUSH
50374: EMPTY
50375: LIST
50376: LIST
50377: PUSH
50378: LD_INT 1
50380: NEG
50381: PUSH
50382: LD_INT 4
50384: PUSH
50385: EMPTY
50386: LIST
50387: LIST
50388: PUSH
50389: LD_INT 1
50391: NEG
50392: PUSH
50393: LD_INT 3
50395: PUSH
50396: EMPTY
50397: LIST
50398: LIST
50399: PUSH
50400: LD_INT 2
50402: PUSH
50403: LD_INT 5
50405: PUSH
50406: EMPTY
50407: LIST
50408: LIST
50409: PUSH
50410: LD_INT 2
50412: NEG
50413: PUSH
50414: LD_INT 3
50416: PUSH
50417: EMPTY
50418: LIST
50419: LIST
50420: PUSH
50421: EMPTY
50422: LIST
50423: LIST
50424: LIST
50425: LIST
50426: LIST
50427: LIST
50428: LIST
50429: LIST
50430: LIST
50431: LIST
50432: LIST
50433: LIST
50434: LIST
50435: LIST
50436: LIST
50437: LIST
50438: LIST
50439: LIST
50440: LIST
50441: LIST
50442: LIST
50443: LIST
50444: LIST
50445: LIST
50446: LIST
50447: LIST
50448: LIST
50449: LIST
50450: LIST
50451: LIST
50452: LIST
50453: LIST
50454: LIST
50455: LIST
50456: LIST
50457: LIST
50458: LIST
50459: LIST
50460: LIST
50461: LIST
50462: LIST
50463: LIST
50464: LIST
50465: LIST
50466: LIST
50467: ST_TO_ADDR
// fFactory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
50468: LD_ADDR_VAR 0 34
50472: PUSH
50473: LD_INT 0
50475: PUSH
50476: LD_INT 4
50478: NEG
50479: PUSH
50480: EMPTY
50481: LIST
50482: LIST
50483: PUSH
50484: LD_INT 0
50486: PUSH
50487: LD_INT 5
50489: NEG
50490: PUSH
50491: EMPTY
50492: LIST
50493: LIST
50494: PUSH
50495: LD_INT 1
50497: PUSH
50498: LD_INT 4
50500: NEG
50501: PUSH
50502: EMPTY
50503: LIST
50504: LIST
50505: PUSH
50506: LD_INT 1
50508: PUSH
50509: LD_INT 3
50511: NEG
50512: PUSH
50513: EMPTY
50514: LIST
50515: LIST
50516: PUSH
50517: LD_INT 0
50519: PUSH
50520: LD_INT 3
50522: NEG
50523: PUSH
50524: EMPTY
50525: LIST
50526: LIST
50527: PUSH
50528: LD_INT 1
50530: NEG
50531: PUSH
50532: LD_INT 4
50534: NEG
50535: PUSH
50536: EMPTY
50537: LIST
50538: LIST
50539: PUSH
50540: LD_INT 1
50542: NEG
50543: PUSH
50544: LD_INT 5
50546: NEG
50547: PUSH
50548: EMPTY
50549: LIST
50550: LIST
50551: PUSH
50552: LD_INT 2
50554: PUSH
50555: LD_INT 3
50557: NEG
50558: PUSH
50559: EMPTY
50560: LIST
50561: LIST
50562: PUSH
50563: LD_INT 2
50565: NEG
50566: PUSH
50567: LD_INT 5
50569: NEG
50570: PUSH
50571: EMPTY
50572: LIST
50573: LIST
50574: PUSH
50575: LD_INT 3
50577: PUSH
50578: LD_INT 0
50580: PUSH
50581: EMPTY
50582: LIST
50583: LIST
50584: PUSH
50585: LD_INT 3
50587: PUSH
50588: LD_INT 1
50590: NEG
50591: PUSH
50592: EMPTY
50593: LIST
50594: LIST
50595: PUSH
50596: LD_INT 4
50598: PUSH
50599: LD_INT 0
50601: PUSH
50602: EMPTY
50603: LIST
50604: LIST
50605: PUSH
50606: LD_INT 4
50608: PUSH
50609: LD_INT 1
50611: PUSH
50612: EMPTY
50613: LIST
50614: LIST
50615: PUSH
50616: LD_INT 3
50618: PUSH
50619: LD_INT 1
50621: PUSH
50622: EMPTY
50623: LIST
50624: LIST
50625: PUSH
50626: LD_INT 2
50628: PUSH
50629: LD_INT 0
50631: PUSH
50632: EMPTY
50633: LIST
50634: LIST
50635: PUSH
50636: LD_INT 2
50638: PUSH
50639: LD_INT 1
50641: NEG
50642: PUSH
50643: EMPTY
50644: LIST
50645: LIST
50646: PUSH
50647: LD_INT 2
50649: PUSH
50650: LD_INT 2
50652: NEG
50653: PUSH
50654: EMPTY
50655: LIST
50656: LIST
50657: PUSH
50658: LD_INT 4
50660: PUSH
50661: LD_INT 2
50663: PUSH
50664: EMPTY
50665: LIST
50666: LIST
50667: PUSH
50668: LD_INT 4
50670: PUSH
50671: LD_INT 4
50673: PUSH
50674: EMPTY
50675: LIST
50676: LIST
50677: PUSH
50678: LD_INT 4
50680: PUSH
50681: LD_INT 3
50683: PUSH
50684: EMPTY
50685: LIST
50686: LIST
50687: PUSH
50688: LD_INT 5
50690: PUSH
50691: LD_INT 4
50693: PUSH
50694: EMPTY
50695: LIST
50696: LIST
50697: PUSH
50698: LD_INT 5
50700: PUSH
50701: LD_INT 5
50703: PUSH
50704: EMPTY
50705: LIST
50706: LIST
50707: PUSH
50708: LD_INT 4
50710: PUSH
50711: LD_INT 5
50713: PUSH
50714: EMPTY
50715: LIST
50716: LIST
50717: PUSH
50718: LD_INT 3
50720: PUSH
50721: LD_INT 4
50723: PUSH
50724: EMPTY
50725: LIST
50726: LIST
50727: PUSH
50728: LD_INT 3
50730: PUSH
50731: LD_INT 3
50733: PUSH
50734: EMPTY
50735: LIST
50736: LIST
50737: PUSH
50738: LD_INT 5
50740: PUSH
50741: LD_INT 3
50743: PUSH
50744: EMPTY
50745: LIST
50746: LIST
50747: PUSH
50748: LD_INT 3
50750: PUSH
50751: LD_INT 5
50753: PUSH
50754: EMPTY
50755: LIST
50756: LIST
50757: PUSH
50758: LD_INT 0
50760: PUSH
50761: LD_INT 3
50763: PUSH
50764: EMPTY
50765: LIST
50766: LIST
50767: PUSH
50768: LD_INT 0
50770: PUSH
50771: LD_INT 2
50773: PUSH
50774: EMPTY
50775: LIST
50776: LIST
50777: PUSH
50778: LD_INT 1
50780: PUSH
50781: LD_INT 3
50783: PUSH
50784: EMPTY
50785: LIST
50786: LIST
50787: PUSH
50788: LD_INT 1
50790: PUSH
50791: LD_INT 4
50793: PUSH
50794: EMPTY
50795: LIST
50796: LIST
50797: PUSH
50798: LD_INT 0
50800: PUSH
50801: LD_INT 4
50803: PUSH
50804: EMPTY
50805: LIST
50806: LIST
50807: PUSH
50808: LD_INT 1
50810: NEG
50811: PUSH
50812: LD_INT 3
50814: PUSH
50815: EMPTY
50816: LIST
50817: LIST
50818: PUSH
50819: LD_INT 1
50821: NEG
50822: PUSH
50823: LD_INT 2
50825: PUSH
50826: EMPTY
50827: LIST
50828: LIST
50829: PUSH
50830: LD_INT 2
50832: PUSH
50833: LD_INT 4
50835: PUSH
50836: EMPTY
50837: LIST
50838: LIST
50839: PUSH
50840: LD_INT 2
50842: NEG
50843: PUSH
50844: LD_INT 2
50846: PUSH
50847: EMPTY
50848: LIST
50849: LIST
50850: PUSH
50851: LD_INT 4
50853: NEG
50854: PUSH
50855: LD_INT 0
50857: PUSH
50858: EMPTY
50859: LIST
50860: LIST
50861: PUSH
50862: LD_INT 4
50864: NEG
50865: PUSH
50866: LD_INT 1
50868: NEG
50869: PUSH
50870: EMPTY
50871: LIST
50872: LIST
50873: PUSH
50874: LD_INT 3
50876: NEG
50877: PUSH
50878: LD_INT 0
50880: PUSH
50881: EMPTY
50882: LIST
50883: LIST
50884: PUSH
50885: LD_INT 3
50887: NEG
50888: PUSH
50889: LD_INT 1
50891: PUSH
50892: EMPTY
50893: LIST
50894: LIST
50895: PUSH
50896: LD_INT 4
50898: NEG
50899: PUSH
50900: LD_INT 1
50902: PUSH
50903: EMPTY
50904: LIST
50905: LIST
50906: PUSH
50907: LD_INT 5
50909: NEG
50910: PUSH
50911: LD_INT 0
50913: PUSH
50914: EMPTY
50915: LIST
50916: LIST
50917: PUSH
50918: LD_INT 5
50920: NEG
50921: PUSH
50922: LD_INT 1
50924: NEG
50925: PUSH
50926: EMPTY
50927: LIST
50928: LIST
50929: PUSH
50930: LD_INT 5
50932: NEG
50933: PUSH
50934: LD_INT 2
50936: NEG
50937: PUSH
50938: EMPTY
50939: LIST
50940: LIST
50941: PUSH
50942: LD_INT 3
50944: NEG
50945: PUSH
50946: LD_INT 2
50948: PUSH
50949: EMPTY
50950: LIST
50951: LIST
50952: PUSH
50953: EMPTY
50954: LIST
50955: LIST
50956: LIST
50957: LIST
50958: LIST
50959: LIST
50960: LIST
50961: LIST
50962: LIST
50963: LIST
50964: LIST
50965: LIST
50966: LIST
50967: LIST
50968: LIST
50969: LIST
50970: LIST
50971: LIST
50972: LIST
50973: LIST
50974: LIST
50975: LIST
50976: LIST
50977: LIST
50978: LIST
50979: LIST
50980: LIST
50981: LIST
50982: LIST
50983: LIST
50984: LIST
50985: LIST
50986: LIST
50987: LIST
50988: LIST
50989: LIST
50990: LIST
50991: LIST
50992: LIST
50993: LIST
50994: LIST
50995: LIST
50996: LIST
50997: LIST
50998: LIST
50999: ST_TO_ADDR
// end ; end ;
51000: GO 51003
51002: POP
// case btype of b_depot , b_warehouse :
51003: LD_VAR 0 1
51007: PUSH
51008: LD_INT 0
51010: DOUBLE
51011: EQUAL
51012: IFTRUE 51022
51014: LD_INT 1
51016: DOUBLE
51017: EQUAL
51018: IFTRUE 51022
51020: GO 51223
51022: POP
// case nation of nation_american :
51023: LD_VAR 0 5
51027: PUSH
51028: LD_INT 1
51030: DOUBLE
51031: EQUAL
51032: IFTRUE 51036
51034: GO 51092
51036: POP
// temp_list = [ fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 ] [ dir + 1 ] ; nation_arabian :
51037: LD_ADDR_VAR 0 9
51041: PUSH
51042: LD_VAR 0 11
51046: PUSH
51047: LD_VAR 0 12
51051: PUSH
51052: LD_VAR 0 13
51056: PUSH
51057: LD_VAR 0 14
51061: PUSH
51062: LD_VAR 0 15
51066: PUSH
51067: LD_VAR 0 16
51071: PUSH
51072: EMPTY
51073: LIST
51074: LIST
51075: LIST
51076: LIST
51077: LIST
51078: LIST
51079: PUSH
51080: LD_VAR 0 4
51084: PUSH
51085: LD_INT 1
51087: PLUS
51088: ARRAY
51089: ST_TO_ADDR
51090: GO 51221
51092: LD_INT 2
51094: DOUBLE
51095: EQUAL
51096: IFTRUE 51100
51098: GO 51156
51100: POP
// temp_list = [ fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 ] [ dir + 1 ] ; nation_russian :
51101: LD_ADDR_VAR 0 9
51105: PUSH
51106: LD_VAR 0 17
51110: PUSH
51111: LD_VAR 0 18
51115: PUSH
51116: LD_VAR 0 19
51120: PUSH
51121: LD_VAR 0 20
51125: PUSH
51126: LD_VAR 0 21
51130: PUSH
51131: LD_VAR 0 22
51135: PUSH
51136: EMPTY
51137: LIST
51138: LIST
51139: LIST
51140: LIST
51141: LIST
51142: LIST
51143: PUSH
51144: LD_VAR 0 4
51148: PUSH
51149: LD_INT 1
51151: PLUS
51152: ARRAY
51153: ST_TO_ADDR
51154: GO 51221
51156: LD_INT 3
51158: DOUBLE
51159: EQUAL
51160: IFTRUE 51164
51162: GO 51220
51164: POP
// temp_list = [ fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
51165: LD_ADDR_VAR 0 9
51169: PUSH
51170: LD_VAR 0 23
51174: PUSH
51175: LD_VAR 0 24
51179: PUSH
51180: LD_VAR 0 25
51184: PUSH
51185: LD_VAR 0 26
51189: PUSH
51190: LD_VAR 0 27
51194: PUSH
51195: LD_VAR 0 28
51199: PUSH
51200: EMPTY
51201: LIST
51202: LIST
51203: LIST
51204: LIST
51205: LIST
51206: LIST
51207: PUSH
51208: LD_VAR 0 4
51212: PUSH
51213: LD_INT 1
51215: PLUS
51216: ARRAY
51217: ST_TO_ADDR
51218: GO 51221
51220: POP
51221: GO 51776
51223: LD_INT 2
51225: DOUBLE
51226: EQUAL
51227: IFTRUE 51237
51229: LD_INT 3
51231: DOUBLE
51232: EQUAL
51233: IFTRUE 51237
51235: GO 51293
51237: POP
// temp_list = [ fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
51238: LD_ADDR_VAR 0 9
51242: PUSH
51243: LD_VAR 0 29
51247: PUSH
51248: LD_VAR 0 30
51252: PUSH
51253: LD_VAR 0 31
51257: PUSH
51258: LD_VAR 0 32
51262: PUSH
51263: LD_VAR 0 33
51267: PUSH
51268: LD_VAR 0 34
51272: PUSH
51273: EMPTY
51274: LIST
51275: LIST
51276: LIST
51277: LIST
51278: LIST
51279: LIST
51280: PUSH
51281: LD_VAR 0 4
51285: PUSH
51286: LD_INT 1
51288: PLUS
51289: ARRAY
51290: ST_TO_ADDR
51291: GO 51776
51293: LD_INT 16
51295: DOUBLE
51296: EQUAL
51297: IFTRUE 51355
51299: LD_INT 17
51301: DOUBLE
51302: EQUAL
51303: IFTRUE 51355
51305: LD_INT 18
51307: DOUBLE
51308: EQUAL
51309: IFTRUE 51355
51311: LD_INT 19
51313: DOUBLE
51314: EQUAL
51315: IFTRUE 51355
51317: LD_INT 22
51319: DOUBLE
51320: EQUAL
51321: IFTRUE 51355
51323: LD_INT 20
51325: DOUBLE
51326: EQUAL
51327: IFTRUE 51355
51329: LD_INT 21
51331: DOUBLE
51332: EQUAL
51333: IFTRUE 51355
51335: LD_INT 23
51337: DOUBLE
51338: EQUAL
51339: IFTRUE 51355
51341: LD_INT 24
51343: DOUBLE
51344: EQUAL
51345: IFTRUE 51355
51347: LD_INT 25
51349: DOUBLE
51350: EQUAL
51351: IFTRUE 51355
51353: GO 51411
51355: POP
// temp_list = [ fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
51356: LD_ADDR_VAR 0 9
51360: PUSH
51361: LD_VAR 0 35
51365: PUSH
51366: LD_VAR 0 36
51370: PUSH
51371: LD_VAR 0 37
51375: PUSH
51376: LD_VAR 0 38
51380: PUSH
51381: LD_VAR 0 39
51385: PUSH
51386: LD_VAR 0 40
51390: PUSH
51391: EMPTY
51392: LIST
51393: LIST
51394: LIST
51395: LIST
51396: LIST
51397: LIST
51398: PUSH
51399: LD_VAR 0 4
51403: PUSH
51404: LD_INT 1
51406: PLUS
51407: ARRAY
51408: ST_TO_ADDR
51409: GO 51776
51411: LD_INT 6
51413: DOUBLE
51414: EQUAL
51415: IFTRUE 51467
51417: LD_INT 7
51419: DOUBLE
51420: EQUAL
51421: IFTRUE 51467
51423: LD_INT 8
51425: DOUBLE
51426: EQUAL
51427: IFTRUE 51467
51429: LD_INT 13
51431: DOUBLE
51432: EQUAL
51433: IFTRUE 51467
51435: LD_INT 12
51437: DOUBLE
51438: EQUAL
51439: IFTRUE 51467
51441: LD_INT 15
51443: DOUBLE
51444: EQUAL
51445: IFTRUE 51467
51447: LD_INT 11
51449: DOUBLE
51450: EQUAL
51451: IFTRUE 51467
51453: LD_INT 14
51455: DOUBLE
51456: EQUAL
51457: IFTRUE 51467
51459: LD_INT 10
51461: DOUBLE
51462: EQUAL
51463: IFTRUE 51467
51465: GO 51523
51467: POP
// temp_list = [ fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 ] [ dir + 1 ] ; b_control_tower :
51468: LD_ADDR_VAR 0 9
51472: PUSH
51473: LD_VAR 0 41
51477: PUSH
51478: LD_VAR 0 42
51482: PUSH
51483: LD_VAR 0 43
51487: PUSH
51488: LD_VAR 0 44
51492: PUSH
51493: LD_VAR 0 45
51497: PUSH
51498: LD_VAR 0 46
51502: PUSH
51503: EMPTY
51504: LIST
51505: LIST
51506: LIST
51507: LIST
51508: LIST
51509: LIST
51510: PUSH
51511: LD_VAR 0 4
51515: PUSH
51516: LD_INT 1
51518: PLUS
51519: ARRAY
51520: ST_TO_ADDR
51521: GO 51776
51523: LD_INT 36
51525: DOUBLE
51526: EQUAL
51527: IFTRUE 51531
51529: GO 51587
51531: POP
// temp_list = [ fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
51532: LD_ADDR_VAR 0 9
51536: PUSH
51537: LD_VAR 0 47
51541: PUSH
51542: LD_VAR 0 48
51546: PUSH
51547: LD_VAR 0 49
51551: PUSH
51552: LD_VAR 0 50
51556: PUSH
51557: LD_VAR 0 51
51561: PUSH
51562: LD_VAR 0 52
51566: PUSH
51567: EMPTY
51568: LIST
51569: LIST
51570: LIST
51571: LIST
51572: LIST
51573: LIST
51574: PUSH
51575: LD_VAR 0 4
51579: PUSH
51580: LD_INT 1
51582: PLUS
51583: ARRAY
51584: ST_TO_ADDR
51585: GO 51776
51587: LD_INT 4
51589: DOUBLE
51590: EQUAL
51591: IFTRUE 51613
51593: LD_INT 5
51595: DOUBLE
51596: EQUAL
51597: IFTRUE 51613
51599: LD_INT 34
51601: DOUBLE
51602: EQUAL
51603: IFTRUE 51613
51605: LD_INT 37
51607: DOUBLE
51608: EQUAL
51609: IFTRUE 51613
51611: GO 51669
51613: POP
// temp_list = [ fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
51614: LD_ADDR_VAR 0 9
51618: PUSH
51619: LD_VAR 0 53
51623: PUSH
51624: LD_VAR 0 54
51628: PUSH
51629: LD_VAR 0 55
51633: PUSH
51634: LD_VAR 0 56
51638: PUSH
51639: LD_VAR 0 57
51643: PUSH
51644: LD_VAR 0 58
51648: PUSH
51649: EMPTY
51650: LIST
51651: LIST
51652: LIST
51653: LIST
51654: LIST
51655: LIST
51656: PUSH
51657: LD_VAR 0 4
51661: PUSH
51662: LD_INT 1
51664: PLUS
51665: ARRAY
51666: ST_TO_ADDR
51667: GO 51776
51669: LD_INT 31
51671: DOUBLE
51672: EQUAL
51673: IFTRUE 51719
51675: LD_INT 32
51677: DOUBLE
51678: EQUAL
51679: IFTRUE 51719
51681: LD_INT 33
51683: DOUBLE
51684: EQUAL
51685: IFTRUE 51719
51687: LD_INT 27
51689: DOUBLE
51690: EQUAL
51691: IFTRUE 51719
51693: LD_INT 26
51695: DOUBLE
51696: EQUAL
51697: IFTRUE 51719
51699: LD_INT 28
51701: DOUBLE
51702: EQUAL
51703: IFTRUE 51719
51705: LD_INT 29
51707: DOUBLE
51708: EQUAL
51709: IFTRUE 51719
51711: LD_INT 30
51713: DOUBLE
51714: EQUAL
51715: IFTRUE 51719
51717: GO 51775
51719: POP
// temp_list = [ fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ] [ dir + 1 ] ; end ;
51720: LD_ADDR_VAR 0 9
51724: PUSH
51725: LD_VAR 0 59
51729: PUSH
51730: LD_VAR 0 60
51734: PUSH
51735: LD_VAR 0 61
51739: PUSH
51740: LD_VAR 0 62
51744: PUSH
51745: LD_VAR 0 63
51749: PUSH
51750: LD_VAR 0 64
51754: PUSH
51755: EMPTY
51756: LIST
51757: LIST
51758: LIST
51759: LIST
51760: LIST
51761: LIST
51762: PUSH
51763: LD_VAR 0 4
51767: PUSH
51768: LD_INT 1
51770: PLUS
51771: ARRAY
51772: ST_TO_ADDR
51773: GO 51776
51775: POP
// temp_list2 = [ ] ;
51776: LD_ADDR_VAR 0 10
51780: PUSH
51781: EMPTY
51782: ST_TO_ADDR
// for i in temp_list do
51783: LD_ADDR_VAR 0 8
51787: PUSH
51788: LD_VAR 0 9
51792: PUSH
51793: FOR_IN
51794: IFFALSE 51846
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
51796: LD_ADDR_VAR 0 10
51800: PUSH
51801: LD_VAR 0 10
51805: PUSH
51806: LD_VAR 0 8
51810: PUSH
51811: LD_INT 1
51813: ARRAY
51814: PUSH
51815: LD_VAR 0 2
51819: PLUS
51820: PUSH
51821: LD_VAR 0 8
51825: PUSH
51826: LD_INT 2
51828: ARRAY
51829: PUSH
51830: LD_VAR 0 3
51834: PLUS
51835: PUSH
51836: EMPTY
51837: LIST
51838: LIST
51839: PUSH
51840: EMPTY
51841: LIST
51842: ADD
51843: ST_TO_ADDR
51844: GO 51793
51846: POP
51847: POP
// result = temp_list2 ;
51848: LD_ADDR_VAR 0 7
51852: PUSH
51853: LD_VAR 0 10
51857: ST_TO_ADDR
// end ;
51858: LD_VAR 0 7
51862: RET
// export function EnemyInRange ( unit , dist ) ; begin
51863: LD_INT 0
51865: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
51866: LD_ADDR_VAR 0 3
51870: PUSH
51871: LD_VAR 0 1
51875: PPUSH
51876: CALL_OW 255
51880: PPUSH
51881: LD_VAR 0 1
51885: PPUSH
51886: CALL_OW 250
51890: PPUSH
51891: LD_VAR 0 1
51895: PPUSH
51896: CALL_OW 251
51900: PPUSH
51901: LD_VAR 0 2
51905: PPUSH
51906: CALL 25259 0 4
51910: PUSH
51911: LD_INT 4
51913: ARRAY
51914: ST_TO_ADDR
// end ;
51915: LD_VAR 0 3
51919: RET
// export function PlayerSeeMe ( unit ) ; begin
51920: LD_INT 0
51922: PPUSH
// result := See ( your_side , unit ) ;
51923: LD_ADDR_VAR 0 2
51927: PUSH
51928: LD_OWVAR 2
51932: PPUSH
51933: LD_VAR 0 1
51937: PPUSH
51938: CALL_OW 292
51942: ST_TO_ADDR
// end ;
51943: LD_VAR 0 2
51947: RET
// export function ReverseDir ( unit ) ; begin
51948: LD_INT 0
51950: PPUSH
// if not unit then
51951: LD_VAR 0 1
51955: NOT
51956: IFFALSE 51960
// exit ;
51958: GO 51983
// result := ( GetDir ( unit ) + 3 ) mod 6 ;
51960: LD_ADDR_VAR 0 2
51964: PUSH
51965: LD_VAR 0 1
51969: PPUSH
51970: CALL_OW 254
51974: PUSH
51975: LD_INT 3
51977: PLUS
51978: PUSH
51979: LD_INT 6
51981: MOD
51982: ST_TO_ADDR
// end ;
51983: LD_VAR 0 2
51987: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tdist , tmp , hex ; begin
51988: LD_INT 0
51990: PPUSH
51991: PPUSH
51992: PPUSH
51993: PPUSH
51994: PPUSH
51995: PPUSH
// if not unit or not hexes then
51996: LD_VAR 0 1
52000: NOT
52001: PUSH
52002: LD_VAR 0 2
52006: NOT
52007: OR
52008: IFFALSE 52012
// exit ;
52010: GO 52135
// dist := 9999 ;
52012: LD_ADDR_VAR 0 5
52016: PUSH
52017: LD_INT 9999
52019: ST_TO_ADDR
// for i = 1 to hexes do
52020: LD_ADDR_VAR 0 4
52024: PUSH
52025: DOUBLE
52026: LD_INT 1
52028: DEC
52029: ST_TO_ADDR
52030: LD_VAR 0 2
52034: PUSH
52035: FOR_TO
52036: IFFALSE 52123
// begin tdist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
52038: LD_ADDR_VAR 0 6
52042: PUSH
52043: LD_VAR 0 1
52047: PPUSH
52048: LD_VAR 0 2
52052: PUSH
52053: LD_VAR 0 4
52057: ARRAY
52058: PUSH
52059: LD_INT 1
52061: ARRAY
52062: PPUSH
52063: LD_VAR 0 2
52067: PUSH
52068: LD_VAR 0 4
52072: ARRAY
52073: PUSH
52074: LD_INT 2
52076: ARRAY
52077: PPUSH
52078: CALL_OW 297
52082: ST_TO_ADDR
// if tdist < dist then
52083: LD_VAR 0 6
52087: PUSH
52088: LD_VAR 0 5
52092: LESS
52093: IFFALSE 52121
// begin hex := hexes [ i ] ;
52095: LD_ADDR_VAR 0 8
52099: PUSH
52100: LD_VAR 0 2
52104: PUSH
52105: LD_VAR 0 4
52109: ARRAY
52110: ST_TO_ADDR
// dist := tdist ;
52111: LD_ADDR_VAR 0 5
52115: PUSH
52116: LD_VAR 0 6
52120: ST_TO_ADDR
// end ; end ;
52121: GO 52035
52123: POP
52124: POP
// result := hex ;
52125: LD_ADDR_VAR 0 3
52129: PUSH
52130: LD_VAR 0 8
52134: ST_TO_ADDR
// end ;
52135: LD_VAR 0 3
52139: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
52140: LD_INT 0
52142: PPUSH
52143: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
52144: LD_VAR 0 1
52148: NOT
52149: PUSH
52150: LD_VAR 0 1
52154: PUSH
52155: LD_INT 21
52157: PUSH
52158: LD_INT 2
52160: PUSH
52161: EMPTY
52162: LIST
52163: LIST
52164: PUSH
52165: LD_INT 23
52167: PUSH
52168: LD_INT 2
52170: PUSH
52171: EMPTY
52172: LIST
52173: LIST
52174: PUSH
52175: EMPTY
52176: LIST
52177: LIST
52178: PPUSH
52179: CALL_OW 69
52183: IN
52184: NOT
52185: OR
52186: IFFALSE 52190
// exit ;
52188: GO 52237
// for i = 1 to 3 do
52190: LD_ADDR_VAR 0 3
52194: PUSH
52195: DOUBLE
52196: LD_INT 1
52198: DEC
52199: ST_TO_ADDR
52200: LD_INT 3
52202: PUSH
52203: FOR_TO
52204: IFFALSE 52235
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
52206: LD_VAR 0 1
52210: PPUSH
52211: CALL_OW 250
52215: PPUSH
52216: LD_VAR 0 1
52220: PPUSH
52221: CALL_OW 251
52225: PPUSH
52226: LD_INT 1
52228: PPUSH
52229: CALL_OW 453
52233: GO 52203
52235: POP
52236: POP
// end ;
52237: LD_VAR 0 2
52241: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
52242: LD_INT 0
52244: PPUSH
52245: PPUSH
52246: PPUSH
52247: PPUSH
52248: PPUSH
52249: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
52250: LD_VAR 0 1
52254: NOT
52255: PUSH
52256: LD_VAR 0 2
52260: NOT
52261: OR
52262: PUSH
52263: LD_VAR 0 1
52267: PPUSH
52268: CALL_OW 314
52272: OR
52273: IFFALSE 52277
// exit ;
52275: GO 52718
// x := GetX ( enemy_unit ) ;
52277: LD_ADDR_VAR 0 7
52281: PUSH
52282: LD_VAR 0 2
52286: PPUSH
52287: CALL_OW 250
52291: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
52292: LD_ADDR_VAR 0 8
52296: PUSH
52297: LD_VAR 0 2
52301: PPUSH
52302: CALL_OW 251
52306: ST_TO_ADDR
// if not x or not y then
52307: LD_VAR 0 7
52311: NOT
52312: PUSH
52313: LD_VAR 0 8
52317: NOT
52318: OR
52319: IFFALSE 52323
// exit ;
52321: GO 52718
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
52323: LD_ADDR_VAR 0 6
52327: PUSH
52328: LD_VAR 0 7
52332: PPUSH
52333: LD_INT 0
52335: PPUSH
52336: LD_INT 4
52338: PPUSH
52339: CALL_OW 272
52343: PUSH
52344: LD_VAR 0 8
52348: PPUSH
52349: LD_INT 0
52351: PPUSH
52352: LD_INT 4
52354: PPUSH
52355: CALL_OW 273
52359: PUSH
52360: EMPTY
52361: LIST
52362: LIST
52363: PUSH
52364: LD_VAR 0 7
52368: PPUSH
52369: LD_INT 1
52371: PPUSH
52372: LD_INT 4
52374: PPUSH
52375: CALL_OW 272
52379: PUSH
52380: LD_VAR 0 8
52384: PPUSH
52385: LD_INT 1
52387: PPUSH
52388: LD_INT 4
52390: PPUSH
52391: CALL_OW 273
52395: PUSH
52396: EMPTY
52397: LIST
52398: LIST
52399: PUSH
52400: LD_VAR 0 7
52404: PPUSH
52405: LD_INT 2
52407: PPUSH
52408: LD_INT 4
52410: PPUSH
52411: CALL_OW 272
52415: PUSH
52416: LD_VAR 0 8
52420: PPUSH
52421: LD_INT 2
52423: PPUSH
52424: LD_INT 4
52426: PPUSH
52427: CALL_OW 273
52431: PUSH
52432: EMPTY
52433: LIST
52434: LIST
52435: PUSH
52436: LD_VAR 0 7
52440: PPUSH
52441: LD_INT 3
52443: PPUSH
52444: LD_INT 4
52446: PPUSH
52447: CALL_OW 272
52451: PUSH
52452: LD_VAR 0 8
52456: PPUSH
52457: LD_INT 3
52459: PPUSH
52460: LD_INT 4
52462: PPUSH
52463: CALL_OW 273
52467: PUSH
52468: EMPTY
52469: LIST
52470: LIST
52471: PUSH
52472: LD_VAR 0 7
52476: PPUSH
52477: LD_INT 4
52479: PPUSH
52480: LD_INT 4
52482: PPUSH
52483: CALL_OW 272
52487: PUSH
52488: LD_VAR 0 8
52492: PPUSH
52493: LD_INT 4
52495: PPUSH
52496: LD_INT 4
52498: PPUSH
52499: CALL_OW 273
52503: PUSH
52504: EMPTY
52505: LIST
52506: LIST
52507: PUSH
52508: LD_VAR 0 7
52512: PPUSH
52513: LD_INT 5
52515: PPUSH
52516: LD_INT 4
52518: PPUSH
52519: CALL_OW 272
52523: PUSH
52524: LD_VAR 0 8
52528: PPUSH
52529: LD_INT 5
52531: PPUSH
52532: LD_INT 4
52534: PPUSH
52535: CALL_OW 273
52539: PUSH
52540: EMPTY
52541: LIST
52542: LIST
52543: PUSH
52544: EMPTY
52545: LIST
52546: LIST
52547: LIST
52548: LIST
52549: LIST
52550: LIST
52551: ST_TO_ADDR
// for i = tmp downto 1 do
52552: LD_ADDR_VAR 0 4
52556: PUSH
52557: DOUBLE
52558: LD_VAR 0 6
52562: INC
52563: ST_TO_ADDR
52564: LD_INT 1
52566: PUSH
52567: FOR_DOWNTO
52568: IFFALSE 52669
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
52570: LD_VAR 0 6
52574: PUSH
52575: LD_VAR 0 4
52579: ARRAY
52580: PUSH
52581: LD_INT 1
52583: ARRAY
52584: PPUSH
52585: LD_VAR 0 6
52589: PUSH
52590: LD_VAR 0 4
52594: ARRAY
52595: PUSH
52596: LD_INT 2
52598: ARRAY
52599: PPUSH
52600: CALL_OW 488
52604: NOT
52605: PUSH
52606: LD_VAR 0 6
52610: PUSH
52611: LD_VAR 0 4
52615: ARRAY
52616: PUSH
52617: LD_INT 1
52619: ARRAY
52620: PPUSH
52621: LD_VAR 0 6
52625: PUSH
52626: LD_VAR 0 4
52630: ARRAY
52631: PUSH
52632: LD_INT 2
52634: ARRAY
52635: PPUSH
52636: CALL_OW 428
52640: PUSH
52641: LD_INT 0
52643: NONEQUAL
52644: OR
52645: IFFALSE 52667
// tmp := Delete ( tmp , i ) ;
52647: LD_ADDR_VAR 0 6
52651: PUSH
52652: LD_VAR 0 6
52656: PPUSH
52657: LD_VAR 0 4
52661: PPUSH
52662: CALL_OW 3
52666: ST_TO_ADDR
52667: GO 52567
52669: POP
52670: POP
// j := GetClosestHex ( unit , tmp ) ;
52671: LD_ADDR_VAR 0 5
52675: PUSH
52676: LD_VAR 0 1
52680: PPUSH
52681: LD_VAR 0 6
52685: PPUSH
52686: CALL 51988 0 2
52690: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
52691: LD_VAR 0 1
52695: PPUSH
52696: LD_VAR 0 5
52700: PUSH
52701: LD_INT 1
52703: ARRAY
52704: PPUSH
52705: LD_VAR 0 5
52709: PUSH
52710: LD_INT 2
52712: ARRAY
52713: PPUSH
52714: CALL_OW 111
// end ;
52718: LD_VAR 0 3
52722: RET
// export function PrepareApemanSoldier ( ) ; begin
52723: LD_INT 0
52725: PPUSH
// uc_nation := 0 ;
52726: LD_ADDR_OWVAR 21
52730: PUSH
52731: LD_INT 0
52733: ST_TO_ADDR
// hc_sex := sex_male ;
52734: LD_ADDR_OWVAR 27
52738: PUSH
52739: LD_INT 1
52741: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
52742: LD_ADDR_OWVAR 28
52746: PUSH
52747: LD_INT 15
52749: ST_TO_ADDR
// hc_gallery :=  ;
52750: LD_ADDR_OWVAR 33
52754: PUSH
52755: LD_STRING 
52757: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
52758: LD_ADDR_OWVAR 31
52762: PUSH
52763: LD_INT 0
52765: PPUSH
52766: LD_INT 3
52768: PPUSH
52769: CALL_OW 12
52773: PUSH
52774: LD_INT 0
52776: PPUSH
52777: LD_INT 3
52779: PPUSH
52780: CALL_OW 12
52784: PUSH
52785: LD_INT 0
52787: PUSH
52788: LD_INT 0
52790: PUSH
52791: EMPTY
52792: LIST
52793: LIST
52794: LIST
52795: LIST
52796: ST_TO_ADDR
// end ;
52797: LD_VAR 0 1
52801: RET
// export function PrepareApemanEngineer ( ) ; begin
52802: LD_INT 0
52804: PPUSH
// uc_nation := 0 ;
52805: LD_ADDR_OWVAR 21
52809: PUSH
52810: LD_INT 0
52812: ST_TO_ADDR
// hc_sex := sex_male ;
52813: LD_ADDR_OWVAR 27
52817: PUSH
52818: LD_INT 1
52820: ST_TO_ADDR
// hc_class := class_apeman_engineer ;
52821: LD_ADDR_OWVAR 28
52825: PUSH
52826: LD_INT 16
52828: ST_TO_ADDR
// hc_gallery :=  ;
52829: LD_ADDR_OWVAR 33
52833: PUSH
52834: LD_STRING 
52836: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
52837: LD_ADDR_OWVAR 31
52841: PUSH
52842: LD_INT 0
52844: PPUSH
52845: LD_INT 3
52847: PPUSH
52848: CALL_OW 12
52852: PUSH
52853: LD_INT 0
52855: PPUSH
52856: LD_INT 3
52858: PPUSH
52859: CALL_OW 12
52863: PUSH
52864: LD_INT 0
52866: PUSH
52867: LD_INT 0
52869: PUSH
52870: EMPTY
52871: LIST
52872: LIST
52873: LIST
52874: LIST
52875: ST_TO_ADDR
// end ;
52876: LD_VAR 0 1
52880: RET
// export function PrepareApeman ( agressivity ) ; begin
52881: LD_INT 0
52883: PPUSH
// uc_side := 0 ;
52884: LD_ADDR_OWVAR 20
52888: PUSH
52889: LD_INT 0
52891: ST_TO_ADDR
// uc_nation := 0 ;
52892: LD_ADDR_OWVAR 21
52896: PUSH
52897: LD_INT 0
52899: ST_TO_ADDR
// hc_sex := sex_male ;
52900: LD_ADDR_OWVAR 27
52904: PUSH
52905: LD_INT 1
52907: ST_TO_ADDR
// hc_class := class_apeman ;
52908: LD_ADDR_OWVAR 28
52912: PUSH
52913: LD_INT 12
52915: ST_TO_ADDR
// hc_gallery :=  ;
52916: LD_ADDR_OWVAR 33
52920: PUSH
52921: LD_STRING 
52923: ST_TO_ADDR
// hc_agressivity := rand ( - agressivity , agressivity ) ;
52924: LD_ADDR_OWVAR 35
52928: PUSH
52929: LD_VAR 0 1
52933: NEG
52934: PPUSH
52935: LD_VAR 0 1
52939: PPUSH
52940: CALL_OW 12
52944: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
52945: LD_ADDR_OWVAR 31
52949: PUSH
52950: LD_INT 0
52952: PPUSH
52953: LD_INT 3
52955: PPUSH
52956: CALL_OW 12
52960: PUSH
52961: LD_INT 0
52963: PPUSH
52964: LD_INT 3
52966: PPUSH
52967: CALL_OW 12
52971: PUSH
52972: LD_INT 0
52974: PUSH
52975: LD_INT 0
52977: PUSH
52978: EMPTY
52979: LIST
52980: LIST
52981: LIST
52982: LIST
52983: ST_TO_ADDR
// end ;
52984: LD_VAR 0 2
52988: RET
// export function PrepareTiger ( agressivity ) ; begin
52989: LD_INT 0
52991: PPUSH
// uc_side := 0 ;
52992: LD_ADDR_OWVAR 20
52996: PUSH
52997: LD_INT 0
52999: ST_TO_ADDR
// uc_nation := 0 ;
53000: LD_ADDR_OWVAR 21
53004: PUSH
53005: LD_INT 0
53007: ST_TO_ADDR
// hc_class := class_tiger ;
53008: LD_ADDR_OWVAR 28
53012: PUSH
53013: LD_INT 14
53015: ST_TO_ADDR
// hc_gallery :=  ;
53016: LD_ADDR_OWVAR 33
53020: PUSH
53021: LD_STRING 
53023: ST_TO_ADDR
// hc_agressivity := rand ( - agressivity , agressivity ) ;
53024: LD_ADDR_OWVAR 35
53028: PUSH
53029: LD_VAR 0 1
53033: NEG
53034: PPUSH
53035: LD_VAR 0 1
53039: PPUSH
53040: CALL_OW 12
53044: ST_TO_ADDR
// end ;
53045: LD_VAR 0 2
53049: RET
// export function PrepareEnchidna ( ) ; begin
53050: LD_INT 0
53052: PPUSH
// uc_side := 0 ;
53053: LD_ADDR_OWVAR 20
53057: PUSH
53058: LD_INT 0
53060: ST_TO_ADDR
// uc_nation := 0 ;
53061: LD_ADDR_OWVAR 21
53065: PUSH
53066: LD_INT 0
53068: ST_TO_ADDR
// hc_class := class_baggie ;
53069: LD_ADDR_OWVAR 28
53073: PUSH
53074: LD_INT 13
53076: ST_TO_ADDR
// hc_gallery :=  ;
53077: LD_ADDR_OWVAR 33
53081: PUSH
53082: LD_STRING 
53084: ST_TO_ADDR
// end ;
53085: LD_VAR 0 1
53089: RET
// export function PrepareFrog ( ) ; begin
53090: LD_INT 0
53092: PPUSH
// uc_side := 0 ;
53093: LD_ADDR_OWVAR 20
53097: PUSH
53098: LD_INT 0
53100: ST_TO_ADDR
// uc_nation := 0 ;
53101: LD_ADDR_OWVAR 21
53105: PUSH
53106: LD_INT 0
53108: ST_TO_ADDR
// hc_class := class_frog ;
53109: LD_ADDR_OWVAR 28
53113: PUSH
53114: LD_INT 19
53116: ST_TO_ADDR
// hc_gallery :=  ;
53117: LD_ADDR_OWVAR 33
53121: PUSH
53122: LD_STRING 
53124: ST_TO_ADDR
// end ;
53125: LD_VAR 0 1
53129: RET
// export function PrepareFish ( ) ; begin
53130: LD_INT 0
53132: PPUSH
// uc_side := 0 ;
53133: LD_ADDR_OWVAR 20
53137: PUSH
53138: LD_INT 0
53140: ST_TO_ADDR
// uc_nation := 0 ;
53141: LD_ADDR_OWVAR 21
53145: PUSH
53146: LD_INT 0
53148: ST_TO_ADDR
// hc_class := class_fish ;
53149: LD_ADDR_OWVAR 28
53153: PUSH
53154: LD_INT 20
53156: ST_TO_ADDR
// hc_gallery :=  ;
53157: LD_ADDR_OWVAR 33
53161: PUSH
53162: LD_STRING 
53164: ST_TO_ADDR
// end ;
53165: LD_VAR 0 1
53169: RET
// export function PrepareBird ( ) ; begin
53170: LD_INT 0
53172: PPUSH
// uc_side := 0 ;
53173: LD_ADDR_OWVAR 20
53177: PUSH
53178: LD_INT 0
53180: ST_TO_ADDR
// uc_nation := 0 ;
53181: LD_ADDR_OWVAR 21
53185: PUSH
53186: LD_INT 0
53188: ST_TO_ADDR
// hc_class := class_phororhacos ;
53189: LD_ADDR_OWVAR 28
53193: PUSH
53194: LD_INT 18
53196: ST_TO_ADDR
// hc_gallery :=  ;
53197: LD_ADDR_OWVAR 33
53201: PUSH
53202: LD_STRING 
53204: ST_TO_ADDR
// end ;
53205: LD_VAR 0 1
53209: RET
// export function PrepareHorse ( ) ; begin
53210: LD_INT 0
53212: PPUSH
// uc_side := 0 ;
53213: LD_ADDR_OWVAR 20
53217: PUSH
53218: LD_INT 0
53220: ST_TO_ADDR
// uc_nation := 0 ;
53221: LD_ADDR_OWVAR 21
53225: PUSH
53226: LD_INT 0
53228: ST_TO_ADDR
// hc_class := class_horse ;
53229: LD_ADDR_OWVAR 28
53233: PUSH
53234: LD_INT 21
53236: ST_TO_ADDR
// hc_gallery :=  ;
53237: LD_ADDR_OWVAR 33
53241: PUSH
53242: LD_STRING 
53244: ST_TO_ADDR
// end ;
53245: LD_VAR 0 1
53249: RET
// export function PrepareMastodont ( ) ; begin
53250: LD_INT 0
53252: PPUSH
// uc_side := 0 ;
53253: LD_ADDR_OWVAR 20
53257: PUSH
53258: LD_INT 0
53260: ST_TO_ADDR
// uc_nation := 0 ;
53261: LD_ADDR_OWVAR 21
53265: PUSH
53266: LD_INT 0
53268: ST_TO_ADDR
// vc_chassis := class_mastodont ;
53269: LD_ADDR_OWVAR 37
53273: PUSH
53274: LD_INT 31
53276: ST_TO_ADDR
// vc_control := control_rider ;
53277: LD_ADDR_OWVAR 38
53281: PUSH
53282: LD_INT 4
53284: ST_TO_ADDR
// end ;
53285: LD_VAR 0 1
53289: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
53290: LD_INT 0
53292: PPUSH
53293: PPUSH
53294: PPUSH
// uc_side = 0 ;
53295: LD_ADDR_OWVAR 20
53299: PUSH
53300: LD_INT 0
53302: ST_TO_ADDR
// uc_nation = 0 ;
53303: LD_ADDR_OWVAR 21
53307: PUSH
53308: LD_INT 0
53310: ST_TO_ADDR
// InitHc_All ( ) ;
53311: CALL_OW 584
// InitVc ;
53315: CALL_OW 20
// if mastodonts then
53319: LD_VAR 0 6
53323: IFFALSE 53390
// for i = 1 to mastodonts do
53325: LD_ADDR_VAR 0 11
53329: PUSH
53330: DOUBLE
53331: LD_INT 1
53333: DEC
53334: ST_TO_ADDR
53335: LD_VAR 0 6
53339: PUSH
53340: FOR_TO
53341: IFFALSE 53388
// begin vc_chassis := 31 ;
53343: LD_ADDR_OWVAR 37
53347: PUSH
53348: LD_INT 31
53350: ST_TO_ADDR
// vc_control := control_rider ;
53351: LD_ADDR_OWVAR 38
53355: PUSH
53356: LD_INT 4
53358: ST_TO_ADDR
// animal := CreateVehicle ;
53359: LD_ADDR_VAR 0 12
53363: PUSH
53364: CALL_OW 45
53368: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
53369: LD_VAR 0 12
53373: PPUSH
53374: LD_VAR 0 8
53378: PPUSH
53379: LD_INT 0
53381: PPUSH
53382: CALL 55525 0 3
// end ;
53386: GO 53340
53388: POP
53389: POP
// if horses then
53390: LD_VAR 0 5
53394: IFFALSE 53461
// for i = 1 to horses do
53396: LD_ADDR_VAR 0 11
53400: PUSH
53401: DOUBLE
53402: LD_INT 1
53404: DEC
53405: ST_TO_ADDR
53406: LD_VAR 0 5
53410: PUSH
53411: FOR_TO
53412: IFFALSE 53459
// begin hc_class := 21 ;
53414: LD_ADDR_OWVAR 28
53418: PUSH
53419: LD_INT 21
53421: ST_TO_ADDR
// hc_gallery :=  ;
53422: LD_ADDR_OWVAR 33
53426: PUSH
53427: LD_STRING 
53429: ST_TO_ADDR
// animal := CreateHuman ;
53430: LD_ADDR_VAR 0 12
53434: PUSH
53435: CALL_OW 44
53439: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
53440: LD_VAR 0 12
53444: PPUSH
53445: LD_VAR 0 8
53449: PPUSH
53450: LD_INT 0
53452: PPUSH
53453: CALL 55525 0 3
// end ;
53457: GO 53411
53459: POP
53460: POP
// if birds then
53461: LD_VAR 0 1
53465: IFFALSE 53532
// for i = 1 to birds do
53467: LD_ADDR_VAR 0 11
53471: PUSH
53472: DOUBLE
53473: LD_INT 1
53475: DEC
53476: ST_TO_ADDR
53477: LD_VAR 0 1
53481: PUSH
53482: FOR_TO
53483: IFFALSE 53530
// begin hc_class = 18 ;
53485: LD_ADDR_OWVAR 28
53489: PUSH
53490: LD_INT 18
53492: ST_TO_ADDR
// hc_gallery =  ;
53493: LD_ADDR_OWVAR 33
53497: PUSH
53498: LD_STRING 
53500: ST_TO_ADDR
// animal := CreateHuman ;
53501: LD_ADDR_VAR 0 12
53505: PUSH
53506: CALL_OW 44
53510: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
53511: LD_VAR 0 12
53515: PPUSH
53516: LD_VAR 0 8
53520: PPUSH
53521: LD_INT 0
53523: PPUSH
53524: CALL 55525 0 3
// end ;
53528: GO 53482
53530: POP
53531: POP
// if tigers then
53532: LD_VAR 0 2
53536: IFFALSE 53620
// for i = 1 to tigers do
53538: LD_ADDR_VAR 0 11
53542: PUSH
53543: DOUBLE
53544: LD_INT 1
53546: DEC
53547: ST_TO_ADDR
53548: LD_VAR 0 2
53552: PUSH
53553: FOR_TO
53554: IFFALSE 53618
// begin hc_class = class_tiger ;
53556: LD_ADDR_OWVAR 28
53560: PUSH
53561: LD_INT 14
53563: ST_TO_ADDR
// hc_gallery =  ;
53564: LD_ADDR_OWVAR 33
53568: PUSH
53569: LD_STRING 
53571: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
53572: LD_ADDR_OWVAR 35
53576: PUSH
53577: LD_INT 7
53579: NEG
53580: PPUSH
53581: LD_INT 7
53583: PPUSH
53584: CALL_OW 12
53588: ST_TO_ADDR
// animal := CreateHuman ;
53589: LD_ADDR_VAR 0 12
53593: PUSH
53594: CALL_OW 44
53598: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
53599: LD_VAR 0 12
53603: PPUSH
53604: LD_VAR 0 8
53608: PPUSH
53609: LD_INT 0
53611: PPUSH
53612: CALL 55525 0 3
// end ;
53616: GO 53553
53618: POP
53619: POP
// if apemans then
53620: LD_VAR 0 3
53624: IFFALSE 53747
// for i = 1 to apemans do
53626: LD_ADDR_VAR 0 11
53630: PUSH
53631: DOUBLE
53632: LD_INT 1
53634: DEC
53635: ST_TO_ADDR
53636: LD_VAR 0 3
53640: PUSH
53641: FOR_TO
53642: IFFALSE 53745
// begin hc_class = class_apeman ;
53644: LD_ADDR_OWVAR 28
53648: PUSH
53649: LD_INT 12
53651: ST_TO_ADDR
// hc_gallery =  ;
53652: LD_ADDR_OWVAR 33
53656: PUSH
53657: LD_STRING 
53659: ST_TO_ADDR
// hc_agressivity = rand ( - 2 , 2 ) ;
53660: LD_ADDR_OWVAR 35
53664: PUSH
53665: LD_INT 2
53667: NEG
53668: PPUSH
53669: LD_INT 2
53671: PPUSH
53672: CALL_OW 12
53676: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
53677: LD_ADDR_OWVAR 31
53681: PUSH
53682: LD_INT 1
53684: PPUSH
53685: LD_INT 3
53687: PPUSH
53688: CALL_OW 12
53692: PUSH
53693: LD_INT 1
53695: PPUSH
53696: LD_INT 3
53698: PPUSH
53699: CALL_OW 12
53703: PUSH
53704: LD_INT 0
53706: PUSH
53707: LD_INT 0
53709: PUSH
53710: EMPTY
53711: LIST
53712: LIST
53713: LIST
53714: LIST
53715: ST_TO_ADDR
// animal := CreateHuman ;
53716: LD_ADDR_VAR 0 12
53720: PUSH
53721: CALL_OW 44
53725: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
53726: LD_VAR 0 12
53730: PPUSH
53731: LD_VAR 0 8
53735: PPUSH
53736: LD_INT 0
53738: PPUSH
53739: CALL 55525 0 3
// end ;
53743: GO 53641
53745: POP
53746: POP
// if enchidnas then
53747: LD_VAR 0 4
53751: IFFALSE 53818
// for i = 1 to enchidnas do
53753: LD_ADDR_VAR 0 11
53757: PUSH
53758: DOUBLE
53759: LD_INT 1
53761: DEC
53762: ST_TO_ADDR
53763: LD_VAR 0 4
53767: PUSH
53768: FOR_TO
53769: IFFALSE 53816
// begin hc_class = 13 ;
53771: LD_ADDR_OWVAR 28
53775: PUSH
53776: LD_INT 13
53778: ST_TO_ADDR
// hc_gallery =  ;
53779: LD_ADDR_OWVAR 33
53783: PUSH
53784: LD_STRING 
53786: ST_TO_ADDR
// animal := CreateHuman ;
53787: LD_ADDR_VAR 0 12
53791: PUSH
53792: CALL_OW 44
53796: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
53797: LD_VAR 0 12
53801: PPUSH
53802: LD_VAR 0 8
53806: PPUSH
53807: LD_INT 0
53809: PPUSH
53810: CALL 55525 0 3
// end ;
53814: GO 53768
53816: POP
53817: POP
// if fishes then
53818: LD_VAR 0 7
53822: IFFALSE 53889
// for i = 1 to fishes do
53824: LD_ADDR_VAR 0 11
53828: PUSH
53829: DOUBLE
53830: LD_INT 1
53832: DEC
53833: ST_TO_ADDR
53834: LD_VAR 0 7
53838: PUSH
53839: FOR_TO
53840: IFFALSE 53887
// begin hc_class = 20 ;
53842: LD_ADDR_OWVAR 28
53846: PUSH
53847: LD_INT 20
53849: ST_TO_ADDR
// hc_gallery =  ;
53850: LD_ADDR_OWVAR 33
53854: PUSH
53855: LD_STRING 
53857: ST_TO_ADDR
// animal := CreateHuman ;
53858: LD_ADDR_VAR 0 12
53862: PUSH
53863: CALL_OW 44
53867: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
53868: LD_VAR 0 12
53872: PPUSH
53873: LD_VAR 0 9
53877: PPUSH
53878: LD_INT 0
53880: PPUSH
53881: CALL 55525 0 3
// end ;
53885: GO 53839
53887: POP
53888: POP
// end ;
53889: LD_VAR 0 10
53893: RET
// export function WantHeal ( sci , unit ) ; begin
53894: LD_INT 0
53896: PPUSH
// if GetTaskList ( sci ) > 0 then
53897: LD_VAR 0 1
53901: PPUSH
53902: CALL_OW 437
53906: PUSH
53907: LD_INT 0
53909: GREATER
53910: IFFALSE 53980
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
53912: LD_VAR 0 1
53916: PPUSH
53917: CALL_OW 437
53921: PUSH
53922: LD_INT 1
53924: ARRAY
53925: PUSH
53926: LD_INT 1
53928: ARRAY
53929: PUSH
53930: LD_STRING l
53932: EQUAL
53933: PUSH
53934: LD_VAR 0 1
53938: PPUSH
53939: CALL_OW 437
53943: PUSH
53944: LD_INT 1
53946: ARRAY
53947: PUSH
53948: LD_INT 4
53950: ARRAY
53951: PUSH
53952: LD_VAR 0 2
53956: EQUAL
53957: AND
53958: IFFALSE 53970
// result := true else
53960: LD_ADDR_VAR 0 3
53964: PUSH
53965: LD_INT 1
53967: ST_TO_ADDR
53968: GO 53978
// result := false ;
53970: LD_ADDR_VAR 0 3
53974: PUSH
53975: LD_INT 0
53977: ST_TO_ADDR
// end else
53978: GO 53988
// result := false ;
53980: LD_ADDR_VAR 0 3
53984: PUSH
53985: LD_INT 0
53987: ST_TO_ADDR
// end ;
53988: LD_VAR 0 3
53992: RET
// export function HealTarget ( sci ) ; begin
53993: LD_INT 0
53995: PPUSH
// if not sci then
53996: LD_VAR 0 1
54000: NOT
54001: IFFALSE 54005
// exit ;
54003: GO 54070
// result := 0 ;
54005: LD_ADDR_VAR 0 2
54009: PUSH
54010: LD_INT 0
54012: ST_TO_ADDR
// if GetTaskList ( sci ) then
54013: LD_VAR 0 1
54017: PPUSH
54018: CALL_OW 437
54022: IFFALSE 54070
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
54024: LD_VAR 0 1
54028: PPUSH
54029: CALL_OW 437
54033: PUSH
54034: LD_INT 1
54036: ARRAY
54037: PUSH
54038: LD_INT 1
54040: ARRAY
54041: PUSH
54042: LD_STRING l
54044: EQUAL
54045: IFFALSE 54070
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
54047: LD_ADDR_VAR 0 2
54051: PUSH
54052: LD_VAR 0 1
54056: PPUSH
54057: CALL_OW 437
54061: PUSH
54062: LD_INT 1
54064: ARRAY
54065: PUSH
54066: LD_INT 4
54068: ARRAY
54069: ST_TO_ADDR
// end ;
54070: LD_VAR 0 2
54074: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
54075: LD_INT 0
54077: PPUSH
54078: PPUSH
54079: PPUSH
54080: PPUSH
// if not base_units then
54081: LD_VAR 0 1
54085: NOT
54086: IFFALSE 54090
// exit ;
54088: GO 54177
// result := false ;
54090: LD_ADDR_VAR 0 2
54094: PUSH
54095: LD_INT 0
54097: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
54098: LD_ADDR_VAR 0 5
54102: PUSH
54103: LD_VAR 0 1
54107: PPUSH
54108: LD_INT 21
54110: PUSH
54111: LD_INT 3
54113: PUSH
54114: EMPTY
54115: LIST
54116: LIST
54117: PPUSH
54118: CALL_OW 72
54122: ST_TO_ADDR
// if not tmp then
54123: LD_VAR 0 5
54127: NOT
54128: IFFALSE 54132
// exit ;
54130: GO 54177
// for i in tmp do
54132: LD_ADDR_VAR 0 3
54136: PUSH
54137: LD_VAR 0 5
54141: PUSH
54142: FOR_IN
54143: IFFALSE 54175
// begin result := EnemyInRange ( i , 22 ) ;
54145: LD_ADDR_VAR 0 2
54149: PUSH
54150: LD_VAR 0 3
54154: PPUSH
54155: LD_INT 22
54157: PPUSH
54158: CALL 51863 0 2
54162: ST_TO_ADDR
// if result then
54163: LD_VAR 0 2
54167: IFFALSE 54173
// exit ;
54169: POP
54170: POP
54171: GO 54177
// end ;
54173: GO 54142
54175: POP
54176: POP
// end ;
54177: LD_VAR 0 2
54181: RET
// export function FilterByTag ( units , tag ) ; begin
54182: LD_INT 0
54184: PPUSH
// result := UnitFilter ( units , [ f_tag , tag ] ) ;
54185: LD_ADDR_VAR 0 3
54189: PUSH
54190: LD_VAR 0 1
54194: PPUSH
54195: LD_INT 120
54197: PUSH
54198: LD_VAR 0 2
54202: PUSH
54203: EMPTY
54204: LIST
54205: LIST
54206: PPUSH
54207: CALL_OW 72
54211: ST_TO_ADDR
// end ;
54212: LD_VAR 0 3
54216: RET
// export function IsDriver ( un ) ; begin
54217: LD_INT 0
54219: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
54220: LD_ADDR_VAR 0 2
54224: PUSH
54225: LD_VAR 0 1
54229: PUSH
54230: LD_INT 55
54232: PUSH
54233: EMPTY
54234: LIST
54235: PPUSH
54236: CALL_OW 69
54240: IN
54241: ST_TO_ADDR
// end ;
54242: LD_VAR 0 2
54246: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
54247: LD_INT 0
54249: PPUSH
54250: PPUSH
// list := [ ] ;
54251: LD_ADDR_VAR 0 5
54255: PUSH
54256: EMPTY
54257: ST_TO_ADDR
// case d of 0 :
54258: LD_VAR 0 3
54262: PUSH
54263: LD_INT 0
54265: DOUBLE
54266: EQUAL
54267: IFTRUE 54271
54269: GO 54404
54271: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
54272: LD_ADDR_VAR 0 5
54276: PUSH
54277: LD_VAR 0 1
54281: PUSH
54282: LD_INT 4
54284: MINUS
54285: PUSH
54286: LD_VAR 0 2
54290: PUSH
54291: LD_INT 4
54293: MINUS
54294: PUSH
54295: LD_INT 2
54297: PUSH
54298: EMPTY
54299: LIST
54300: LIST
54301: LIST
54302: PUSH
54303: LD_VAR 0 1
54307: PUSH
54308: LD_INT 3
54310: MINUS
54311: PUSH
54312: LD_VAR 0 2
54316: PUSH
54317: LD_INT 1
54319: PUSH
54320: EMPTY
54321: LIST
54322: LIST
54323: LIST
54324: PUSH
54325: LD_VAR 0 1
54329: PUSH
54330: LD_INT 4
54332: PLUS
54333: PUSH
54334: LD_VAR 0 2
54338: PUSH
54339: LD_INT 4
54341: PUSH
54342: EMPTY
54343: LIST
54344: LIST
54345: LIST
54346: PUSH
54347: LD_VAR 0 1
54351: PUSH
54352: LD_INT 3
54354: PLUS
54355: PUSH
54356: LD_VAR 0 2
54360: PUSH
54361: LD_INT 3
54363: PLUS
54364: PUSH
54365: LD_INT 5
54367: PUSH
54368: EMPTY
54369: LIST
54370: LIST
54371: LIST
54372: PUSH
54373: LD_VAR 0 1
54377: PUSH
54378: LD_VAR 0 2
54382: PUSH
54383: LD_INT 4
54385: PLUS
54386: PUSH
54387: LD_INT 0
54389: PUSH
54390: EMPTY
54391: LIST
54392: LIST
54393: LIST
54394: PUSH
54395: EMPTY
54396: LIST
54397: LIST
54398: LIST
54399: LIST
54400: LIST
54401: ST_TO_ADDR
// end ; 1 :
54402: GO 55102
54404: LD_INT 1
54406: DOUBLE
54407: EQUAL
54408: IFTRUE 54412
54410: GO 54545
54412: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
54413: LD_ADDR_VAR 0 5
54417: PUSH
54418: LD_VAR 0 1
54422: PUSH
54423: LD_VAR 0 2
54427: PUSH
54428: LD_INT 4
54430: MINUS
54431: PUSH
54432: LD_INT 3
54434: PUSH
54435: EMPTY
54436: LIST
54437: LIST
54438: LIST
54439: PUSH
54440: LD_VAR 0 1
54444: PUSH
54445: LD_INT 3
54447: MINUS
54448: PUSH
54449: LD_VAR 0 2
54453: PUSH
54454: LD_INT 3
54456: MINUS
54457: PUSH
54458: LD_INT 2
54460: PUSH
54461: EMPTY
54462: LIST
54463: LIST
54464: LIST
54465: PUSH
54466: LD_VAR 0 1
54470: PUSH
54471: LD_INT 4
54473: MINUS
54474: PUSH
54475: LD_VAR 0 2
54479: PUSH
54480: LD_INT 1
54482: PUSH
54483: EMPTY
54484: LIST
54485: LIST
54486: LIST
54487: PUSH
54488: LD_VAR 0 1
54492: PUSH
54493: LD_VAR 0 2
54497: PUSH
54498: LD_INT 3
54500: PLUS
54501: PUSH
54502: LD_INT 0
54504: PUSH
54505: EMPTY
54506: LIST
54507: LIST
54508: LIST
54509: PUSH
54510: LD_VAR 0 1
54514: PUSH
54515: LD_INT 4
54517: PLUS
54518: PUSH
54519: LD_VAR 0 2
54523: PUSH
54524: LD_INT 4
54526: PLUS
54527: PUSH
54528: LD_INT 5
54530: PUSH
54531: EMPTY
54532: LIST
54533: LIST
54534: LIST
54535: PUSH
54536: EMPTY
54537: LIST
54538: LIST
54539: LIST
54540: LIST
54541: LIST
54542: ST_TO_ADDR
// end ; 2 :
54543: GO 55102
54545: LD_INT 2
54547: DOUBLE
54548: EQUAL
54549: IFTRUE 54553
54551: GO 54682
54553: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
54554: LD_ADDR_VAR 0 5
54558: PUSH
54559: LD_VAR 0 1
54563: PUSH
54564: LD_VAR 0 2
54568: PUSH
54569: LD_INT 3
54571: MINUS
54572: PUSH
54573: LD_INT 3
54575: PUSH
54576: EMPTY
54577: LIST
54578: LIST
54579: LIST
54580: PUSH
54581: LD_VAR 0 1
54585: PUSH
54586: LD_INT 4
54588: PLUS
54589: PUSH
54590: LD_VAR 0 2
54594: PUSH
54595: LD_INT 4
54597: PUSH
54598: EMPTY
54599: LIST
54600: LIST
54601: LIST
54602: PUSH
54603: LD_VAR 0 1
54607: PUSH
54608: LD_VAR 0 2
54612: PUSH
54613: LD_INT 4
54615: PLUS
54616: PUSH
54617: LD_INT 0
54619: PUSH
54620: EMPTY
54621: LIST
54622: LIST
54623: LIST
54624: PUSH
54625: LD_VAR 0 1
54629: PUSH
54630: LD_INT 3
54632: MINUS
54633: PUSH
54634: LD_VAR 0 2
54638: PUSH
54639: LD_INT 1
54641: PUSH
54642: EMPTY
54643: LIST
54644: LIST
54645: LIST
54646: PUSH
54647: LD_VAR 0 1
54651: PUSH
54652: LD_INT 4
54654: MINUS
54655: PUSH
54656: LD_VAR 0 2
54660: PUSH
54661: LD_INT 4
54663: MINUS
54664: PUSH
54665: LD_INT 2
54667: PUSH
54668: EMPTY
54669: LIST
54670: LIST
54671: LIST
54672: PUSH
54673: EMPTY
54674: LIST
54675: LIST
54676: LIST
54677: LIST
54678: LIST
54679: ST_TO_ADDR
// end ; 3 :
54680: GO 55102
54682: LD_INT 3
54684: DOUBLE
54685: EQUAL
54686: IFTRUE 54690
54688: GO 54823
54690: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
54691: LD_ADDR_VAR 0 5
54695: PUSH
54696: LD_VAR 0 1
54700: PUSH
54701: LD_INT 3
54703: PLUS
54704: PUSH
54705: LD_VAR 0 2
54709: PUSH
54710: LD_INT 4
54712: PUSH
54713: EMPTY
54714: LIST
54715: LIST
54716: LIST
54717: PUSH
54718: LD_VAR 0 1
54722: PUSH
54723: LD_INT 4
54725: PLUS
54726: PUSH
54727: LD_VAR 0 2
54731: PUSH
54732: LD_INT 4
54734: PLUS
54735: PUSH
54736: LD_INT 5
54738: PUSH
54739: EMPTY
54740: LIST
54741: LIST
54742: LIST
54743: PUSH
54744: LD_VAR 0 1
54748: PUSH
54749: LD_INT 4
54751: MINUS
54752: PUSH
54753: LD_VAR 0 2
54757: PUSH
54758: LD_INT 1
54760: PUSH
54761: EMPTY
54762: LIST
54763: LIST
54764: LIST
54765: PUSH
54766: LD_VAR 0 1
54770: PUSH
54771: LD_VAR 0 2
54775: PUSH
54776: LD_INT 4
54778: MINUS
54779: PUSH
54780: LD_INT 3
54782: PUSH
54783: EMPTY
54784: LIST
54785: LIST
54786: LIST
54787: PUSH
54788: LD_VAR 0 1
54792: PUSH
54793: LD_INT 3
54795: MINUS
54796: PUSH
54797: LD_VAR 0 2
54801: PUSH
54802: LD_INT 3
54804: MINUS
54805: PUSH
54806: LD_INT 2
54808: PUSH
54809: EMPTY
54810: LIST
54811: LIST
54812: LIST
54813: PUSH
54814: EMPTY
54815: LIST
54816: LIST
54817: LIST
54818: LIST
54819: LIST
54820: ST_TO_ADDR
// end ; 4 :
54821: GO 55102
54823: LD_INT 4
54825: DOUBLE
54826: EQUAL
54827: IFTRUE 54831
54829: GO 54964
54831: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
54832: LD_ADDR_VAR 0 5
54836: PUSH
54837: LD_VAR 0 1
54841: PUSH
54842: LD_VAR 0 2
54846: PUSH
54847: LD_INT 4
54849: PLUS
54850: PUSH
54851: LD_INT 0
54853: PUSH
54854: EMPTY
54855: LIST
54856: LIST
54857: LIST
54858: PUSH
54859: LD_VAR 0 1
54863: PUSH
54864: LD_INT 3
54866: PLUS
54867: PUSH
54868: LD_VAR 0 2
54872: PUSH
54873: LD_INT 3
54875: PLUS
54876: PUSH
54877: LD_INT 5
54879: PUSH
54880: EMPTY
54881: LIST
54882: LIST
54883: LIST
54884: PUSH
54885: LD_VAR 0 1
54889: PUSH
54890: LD_INT 4
54892: PLUS
54893: PUSH
54894: LD_VAR 0 2
54898: PUSH
54899: LD_INT 4
54901: PUSH
54902: EMPTY
54903: LIST
54904: LIST
54905: LIST
54906: PUSH
54907: LD_VAR 0 1
54911: PUSH
54912: LD_VAR 0 2
54916: PUSH
54917: LD_INT 3
54919: MINUS
54920: PUSH
54921: LD_INT 3
54923: PUSH
54924: EMPTY
54925: LIST
54926: LIST
54927: LIST
54928: PUSH
54929: LD_VAR 0 1
54933: PUSH
54934: LD_INT 4
54936: MINUS
54937: PUSH
54938: LD_VAR 0 2
54942: PUSH
54943: LD_INT 4
54945: MINUS
54946: PUSH
54947: LD_INT 2
54949: PUSH
54950: EMPTY
54951: LIST
54952: LIST
54953: LIST
54954: PUSH
54955: EMPTY
54956: LIST
54957: LIST
54958: LIST
54959: LIST
54960: LIST
54961: ST_TO_ADDR
// end ; 5 :
54962: GO 55102
54964: LD_INT 5
54966: DOUBLE
54967: EQUAL
54968: IFTRUE 54972
54970: GO 55101
54972: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
54973: LD_ADDR_VAR 0 5
54977: PUSH
54978: LD_VAR 0 1
54982: PUSH
54983: LD_INT 4
54985: MINUS
54986: PUSH
54987: LD_VAR 0 2
54991: PUSH
54992: LD_INT 1
54994: PUSH
54995: EMPTY
54996: LIST
54997: LIST
54998: LIST
54999: PUSH
55000: LD_VAR 0 1
55004: PUSH
55005: LD_VAR 0 2
55009: PUSH
55010: LD_INT 4
55012: MINUS
55013: PUSH
55014: LD_INT 3
55016: PUSH
55017: EMPTY
55018: LIST
55019: LIST
55020: LIST
55021: PUSH
55022: LD_VAR 0 1
55026: PUSH
55027: LD_INT 4
55029: PLUS
55030: PUSH
55031: LD_VAR 0 2
55035: PUSH
55036: LD_INT 4
55038: PLUS
55039: PUSH
55040: LD_INT 5
55042: PUSH
55043: EMPTY
55044: LIST
55045: LIST
55046: LIST
55047: PUSH
55048: LD_VAR 0 1
55052: PUSH
55053: LD_INT 3
55055: PLUS
55056: PUSH
55057: LD_VAR 0 2
55061: PUSH
55062: LD_INT 4
55064: PUSH
55065: EMPTY
55066: LIST
55067: LIST
55068: LIST
55069: PUSH
55070: LD_VAR 0 1
55074: PUSH
55075: LD_VAR 0 2
55079: PUSH
55080: LD_INT 3
55082: PLUS
55083: PUSH
55084: LD_INT 0
55086: PUSH
55087: EMPTY
55088: LIST
55089: LIST
55090: LIST
55091: PUSH
55092: EMPTY
55093: LIST
55094: LIST
55095: LIST
55096: LIST
55097: LIST
55098: ST_TO_ADDR
// end ; end ;
55099: GO 55102
55101: POP
// result := list ;
55102: LD_ADDR_VAR 0 4
55106: PUSH
55107: LD_VAR 0 5
55111: ST_TO_ADDR
// end ;
55112: LD_VAR 0 4
55116: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
55117: LD_INT 0
55119: PPUSH
55120: PPUSH
55121: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
55122: LD_VAR 0 1
55126: NOT
55127: PUSH
55128: LD_VAR 0 2
55132: PUSH
55133: LD_INT 1
55135: PUSH
55136: LD_INT 2
55138: PUSH
55139: LD_INT 3
55141: PUSH
55142: LD_INT 4
55144: PUSH
55145: EMPTY
55146: LIST
55147: LIST
55148: LIST
55149: LIST
55150: IN
55151: NOT
55152: OR
55153: IFFALSE 55157
// exit ;
55155: GO 55249
// tmp := [ ] ;
55157: LD_ADDR_VAR 0 5
55161: PUSH
55162: EMPTY
55163: ST_TO_ADDR
// for i in units do
55164: LD_ADDR_VAR 0 4
55168: PUSH
55169: LD_VAR 0 1
55173: PUSH
55174: FOR_IN
55175: IFFALSE 55218
// tmp := Insert ( tmp , tmp + 1 , GetSkill ( i , class ) ) ;
55177: LD_ADDR_VAR 0 5
55181: PUSH
55182: LD_VAR 0 5
55186: PPUSH
55187: LD_VAR 0 5
55191: PUSH
55192: LD_INT 1
55194: PLUS
55195: PPUSH
55196: LD_VAR 0 4
55200: PPUSH
55201: LD_VAR 0 2
55205: PPUSH
55206: CALL_OW 259
55210: PPUSH
55211: CALL_OW 2
55215: ST_TO_ADDR
55216: GO 55174
55218: POP
55219: POP
// if not tmp then
55220: LD_VAR 0 5
55224: NOT
55225: IFFALSE 55229
// exit ;
55227: GO 55249
// result := SortListByListDesc ( units , tmp ) ;
55229: LD_ADDR_VAR 0 3
55233: PUSH
55234: LD_VAR 0 1
55238: PPUSH
55239: LD_VAR 0 5
55243: PPUSH
55244: CALL_OW 77
55248: ST_TO_ADDR
// end ;
55249: LD_VAR 0 3
55253: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
55254: LD_INT 0
55256: PPUSH
55257: PPUSH
55258: PPUSH
// result := false ;
55259: LD_ADDR_VAR 0 3
55263: PUSH
55264: LD_INT 0
55266: ST_TO_ADDR
// x := GetX ( building ) ;
55267: LD_ADDR_VAR 0 4
55271: PUSH
55272: LD_VAR 0 2
55276: PPUSH
55277: CALL_OW 250
55281: ST_TO_ADDR
// y := GetY ( building ) ;
55282: LD_ADDR_VAR 0 5
55286: PUSH
55287: LD_VAR 0 2
55291: PPUSH
55292: CALL_OW 251
55296: ST_TO_ADDR
// if not building or not x or not y then
55297: LD_VAR 0 2
55301: NOT
55302: PUSH
55303: LD_VAR 0 4
55307: NOT
55308: OR
55309: PUSH
55310: LD_VAR 0 5
55314: NOT
55315: OR
55316: IFFALSE 55320
// exit ;
55318: GO 55412
// if GetTaskList ( unit ) then
55320: LD_VAR 0 1
55324: PPUSH
55325: CALL_OW 437
55329: IFFALSE 55412
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
55331: LD_STRING e
55333: PUSH
55334: LD_VAR 0 1
55338: PPUSH
55339: CALL_OW 437
55343: PUSH
55344: LD_INT 1
55346: ARRAY
55347: PUSH
55348: LD_INT 1
55350: ARRAY
55351: EQUAL
55352: PUSH
55353: LD_VAR 0 4
55357: PUSH
55358: LD_VAR 0 1
55362: PPUSH
55363: CALL_OW 437
55367: PUSH
55368: LD_INT 1
55370: ARRAY
55371: PUSH
55372: LD_INT 2
55374: ARRAY
55375: EQUAL
55376: AND
55377: PUSH
55378: LD_VAR 0 5
55382: PUSH
55383: LD_VAR 0 1
55387: PPUSH
55388: CALL_OW 437
55392: PUSH
55393: LD_INT 1
55395: ARRAY
55396: PUSH
55397: LD_INT 3
55399: ARRAY
55400: EQUAL
55401: AND
55402: IFFALSE 55412
// result := true end ;
55404: LD_ADDR_VAR 0 3
55408: PUSH
55409: LD_INT 1
55411: ST_TO_ADDR
// end ;
55412: LD_VAR 0 3
55416: RET
// export function UnitGoingToXY ( unit , x , y ) ; begin
55417: LD_INT 0
55419: PPUSH
// result := false ;
55420: LD_ADDR_VAR 0 4
55424: PUSH
55425: LD_INT 0
55427: ST_TO_ADDR
// if GetTaskList ( unit ) then
55428: LD_VAR 0 1
55432: PPUSH
55433: CALL_OW 437
55437: IFFALSE 55520
// begin if M = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
55439: LD_STRING M
55441: PUSH
55442: LD_VAR 0 1
55446: PPUSH
55447: CALL_OW 437
55451: PUSH
55452: LD_INT 1
55454: ARRAY
55455: PUSH
55456: LD_INT 1
55458: ARRAY
55459: EQUAL
55460: PUSH
55461: LD_VAR 0 2
55465: PUSH
55466: LD_VAR 0 1
55470: PPUSH
55471: CALL_OW 437
55475: PUSH
55476: LD_INT 1
55478: ARRAY
55479: PUSH
55480: LD_INT 2
55482: ARRAY
55483: EQUAL
55484: AND
55485: PUSH
55486: LD_VAR 0 3
55490: PUSH
55491: LD_VAR 0 1
55495: PPUSH
55496: CALL_OW 437
55500: PUSH
55501: LD_INT 1
55503: ARRAY
55504: PUSH
55505: LD_INT 3
55507: ARRAY
55508: EQUAL
55509: AND
55510: IFFALSE 55520
// result := true ;
55512: LD_ADDR_VAR 0 4
55516: PUSH
55517: LD_INT 1
55519: ST_TO_ADDR
// end ; end ;
55520: LD_VAR 0 4
55524: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
55525: LD_INT 0
55527: PPUSH
55528: PPUSH
55529: PPUSH
55530: PPUSH
// if not unit or not area then
55531: LD_VAR 0 1
55535: NOT
55536: PUSH
55537: LD_VAR 0 2
55541: NOT
55542: OR
55543: IFFALSE 55547
// exit ;
55545: GO 55711
// tmp := AreaToList ( area , i ) ;
55547: LD_ADDR_VAR 0 6
55551: PUSH
55552: LD_VAR 0 2
55556: PPUSH
55557: LD_VAR 0 5
55561: PPUSH
55562: CALL_OW 517
55566: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
55567: LD_ADDR_VAR 0 5
55571: PUSH
55572: DOUBLE
55573: LD_INT 1
55575: DEC
55576: ST_TO_ADDR
55577: LD_VAR 0 6
55581: PUSH
55582: LD_INT 1
55584: ARRAY
55585: PUSH
55586: FOR_TO
55587: IFFALSE 55709
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
55589: LD_ADDR_VAR 0 7
55593: PUSH
55594: LD_VAR 0 6
55598: PUSH
55599: LD_INT 1
55601: ARRAY
55602: PUSH
55603: LD_VAR 0 5
55607: ARRAY
55608: PUSH
55609: LD_VAR 0 6
55613: PUSH
55614: LD_INT 2
55616: ARRAY
55617: PUSH
55618: LD_VAR 0 5
55622: ARRAY
55623: PUSH
55624: EMPTY
55625: LIST
55626: LIST
55627: ST_TO_ADDR
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
55628: LD_VAR 0 7
55632: PUSH
55633: LD_INT 1
55635: ARRAY
55636: PPUSH
55637: LD_VAR 0 7
55641: PUSH
55642: LD_INT 2
55644: ARRAY
55645: PPUSH
55646: CALL_OW 428
55650: PUSH
55651: LD_INT 0
55653: EQUAL
55654: IFFALSE 55707
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
55656: LD_VAR 0 1
55660: PPUSH
55661: LD_VAR 0 7
55665: PUSH
55666: LD_INT 1
55668: ARRAY
55669: PPUSH
55670: LD_VAR 0 7
55674: PUSH
55675: LD_INT 2
55677: ARRAY
55678: PPUSH
55679: LD_VAR 0 3
55683: PPUSH
55684: CALL_OW 48
// result := IsPlaced ( unit ) ;
55688: LD_ADDR_VAR 0 4
55692: PUSH
55693: LD_VAR 0 1
55697: PPUSH
55698: CALL_OW 305
55702: ST_TO_ADDR
// exit ;
55703: POP
55704: POP
55705: GO 55711
// end ; end ;
55707: GO 55586
55709: POP
55710: POP
// end ;
55711: LD_VAR 0 4
55715: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
55716: LD_INT 0
55718: PPUSH
55719: PPUSH
55720: PPUSH
// if not side or side > 8 then
55721: LD_VAR 0 1
55725: NOT
55726: PUSH
55727: LD_VAR 0 1
55731: PUSH
55732: LD_INT 8
55734: GREATER
55735: OR
55736: IFFALSE 55740
// exit ;
55738: GO 55927
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
55740: LD_ADDR_VAR 0 4
55744: PUSH
55745: LD_INT 22
55747: PUSH
55748: LD_VAR 0 1
55752: PUSH
55753: EMPTY
55754: LIST
55755: LIST
55756: PUSH
55757: LD_INT 21
55759: PUSH
55760: LD_INT 3
55762: PUSH
55763: EMPTY
55764: LIST
55765: LIST
55766: PUSH
55767: EMPTY
55768: LIST
55769: LIST
55770: PPUSH
55771: CALL_OW 69
55775: ST_TO_ADDR
// if not tmp then
55776: LD_VAR 0 4
55780: NOT
55781: IFFALSE 55785
// exit ;
55783: GO 55927
// enable_addtolog := true ;
55785: LD_ADDR_OWVAR 81
55789: PUSH
55790: LD_INT 1
55792: ST_TO_ADDR
// AddToLog ( [ ) ;
55793: LD_STRING [
55795: PPUSH
55796: CALL_OW 561
// for i in tmp do
55800: LD_ADDR_VAR 0 3
55804: PUSH
55805: LD_VAR 0 4
55809: PUSH
55810: FOR_IN
55811: IFFALSE 55918
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
55813: LD_STRING [
55815: PUSH
55816: LD_VAR 0 3
55820: PPUSH
55821: CALL_OW 266
55825: STR
55826: PUSH
55827: LD_STRING , 
55829: STR
55830: PUSH
55831: LD_VAR 0 3
55835: PPUSH
55836: CALL_OW 250
55840: STR
55841: PUSH
55842: LD_STRING , 
55844: STR
55845: PUSH
55846: LD_VAR 0 3
55850: PPUSH
55851: CALL_OW 251
55855: STR
55856: PUSH
55857: LD_STRING , 
55859: STR
55860: PUSH
55861: LD_VAR 0 3
55865: PPUSH
55866: CALL_OW 254
55870: STR
55871: PUSH
55872: LD_STRING , 
55874: STR
55875: PUSH
55876: LD_VAR 0 3
55880: PPUSH
55881: LD_INT 1
55883: PPUSH
55884: CALL_OW 268
55888: STR
55889: PUSH
55890: LD_STRING , 
55892: STR
55893: PUSH
55894: LD_VAR 0 3
55898: PPUSH
55899: LD_INT 2
55901: PPUSH
55902: CALL_OW 268
55906: STR
55907: PUSH
55908: LD_STRING ],
55910: STR
55911: PPUSH
55912: CALL_OW 561
// end ;
55916: GO 55810
55918: POP
55919: POP
// AddToLog ( ]; ) ;
55920: LD_STRING ];
55922: PPUSH
55923: CALL_OW 561
// end ;
55927: LD_VAR 0 2
55931: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
55932: LD_INT 0
55934: PPUSH
55935: PPUSH
55936: PPUSH
55937: PPUSH
55938: PPUSH
// if not area or not rate or not max then
55939: LD_VAR 0 1
55943: NOT
55944: PUSH
55945: LD_VAR 0 2
55949: NOT
55950: OR
55951: PUSH
55952: LD_VAR 0 4
55956: NOT
55957: OR
55958: IFFALSE 55962
// exit ;
55960: GO 56151
// while 1 do
55962: LD_INT 1
55964: IFFALSE 56151
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
55966: LD_ADDR_VAR 0 9
55970: PUSH
55971: LD_VAR 0 1
55975: PPUSH
55976: LD_INT 1
55978: PPUSH
55979: CALL_OW 287
55983: PUSH
55984: LD_INT 10
55986: MUL
55987: ST_TO_ADDR
// r := rate / 10 ;
55988: LD_ADDR_VAR 0 7
55992: PUSH
55993: LD_VAR 0 2
55997: PUSH
55998: LD_INT 10
56000: DIVREAL
56001: ST_TO_ADDR
// time := 1 1$00 ;
56002: LD_ADDR_VAR 0 8
56006: PUSH
56007: LD_INT 2100
56009: ST_TO_ADDR
// if amount < min then
56010: LD_VAR 0 9
56014: PUSH
56015: LD_VAR 0 3
56019: LESS
56020: IFFALSE 56038
// r := r * 2 else
56022: LD_ADDR_VAR 0 7
56026: PUSH
56027: LD_VAR 0 7
56031: PUSH
56032: LD_INT 2
56034: MUL
56035: ST_TO_ADDR
56036: GO 56064
// if amount > max then
56038: LD_VAR 0 9
56042: PUSH
56043: LD_VAR 0 4
56047: GREATER
56048: IFFALSE 56064
// r := r / 2 ;
56050: LD_ADDR_VAR 0 7
56054: PUSH
56055: LD_VAR 0 7
56059: PUSH
56060: LD_INT 2
56062: DIVREAL
56063: ST_TO_ADDR
// time := time / r ;
56064: LD_ADDR_VAR 0 8
56068: PUSH
56069: LD_VAR 0 8
56073: PUSH
56074: LD_VAR 0 7
56078: DIVREAL
56079: ST_TO_ADDR
// if time < 0 then
56080: LD_VAR 0 8
56084: PUSH
56085: LD_INT 0
56087: LESS
56088: IFFALSE 56105
// time := time * - 1 ;
56090: LD_ADDR_VAR 0 8
56094: PUSH
56095: LD_VAR 0 8
56099: PUSH
56100: LD_INT 1
56102: NEG
56103: MUL
56104: ST_TO_ADDR
// wait ( time + rand ( 0 0$01 , 0 0$25 ) ) ;
56105: LD_VAR 0 8
56109: PUSH
56110: LD_INT 35
56112: PPUSH
56113: LD_INT 875
56115: PPUSH
56116: CALL_OW 12
56120: PLUS
56121: PPUSH
56122: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
56126: LD_INT 1
56128: PPUSH
56129: LD_INT 5
56131: PPUSH
56132: CALL_OW 12
56136: PPUSH
56137: LD_VAR 0 1
56141: PPUSH
56142: LD_INT 1
56144: PPUSH
56145: CALL_OW 55
// end ;
56149: GO 55962
// end ;
56151: LD_VAR 0 5
56155: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
56156: LD_INT 0
56158: PPUSH
56159: PPUSH
56160: PPUSH
56161: PPUSH
56162: PPUSH
56163: PPUSH
56164: PPUSH
56165: PPUSH
// if not turrets or not factories then
56166: LD_VAR 0 1
56170: NOT
56171: PUSH
56172: LD_VAR 0 2
56176: NOT
56177: OR
56178: IFFALSE 56182
// exit ;
56180: GO 56489
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
56182: LD_ADDR_VAR 0 10
56186: PUSH
56187: LD_INT 5
56189: PUSH
56190: LD_INT 6
56192: PUSH
56193: EMPTY
56194: LIST
56195: LIST
56196: PUSH
56197: LD_INT 2
56199: PUSH
56200: LD_INT 4
56202: PUSH
56203: EMPTY
56204: LIST
56205: LIST
56206: PUSH
56207: LD_INT 3
56209: PUSH
56210: LD_INT 5
56212: PUSH
56213: EMPTY
56214: LIST
56215: LIST
56216: PUSH
56217: EMPTY
56218: LIST
56219: LIST
56220: LIST
56221: PUSH
56222: LD_INT 24
56224: PUSH
56225: LD_INT 25
56227: PUSH
56228: EMPTY
56229: LIST
56230: LIST
56231: PUSH
56232: LD_INT 23
56234: PUSH
56235: LD_INT 27
56237: PUSH
56238: EMPTY
56239: LIST
56240: LIST
56241: PUSH
56242: EMPTY
56243: LIST
56244: LIST
56245: PUSH
56246: LD_INT 42
56248: PUSH
56249: LD_INT 43
56251: PUSH
56252: EMPTY
56253: LIST
56254: LIST
56255: PUSH
56256: LD_INT 44
56258: PUSH
56259: LD_INT 46
56261: PUSH
56262: EMPTY
56263: LIST
56264: LIST
56265: PUSH
56266: LD_INT 45
56268: PUSH
56269: LD_INT 47
56271: PUSH
56272: EMPTY
56273: LIST
56274: LIST
56275: PUSH
56276: EMPTY
56277: LIST
56278: LIST
56279: LIST
56280: PUSH
56281: EMPTY
56282: LIST
56283: LIST
56284: LIST
56285: ST_TO_ADDR
// result := [ ] ;
56286: LD_ADDR_VAR 0 3
56290: PUSH
56291: EMPTY
56292: ST_TO_ADDR
// for i in turrets do
56293: LD_ADDR_VAR 0 4
56297: PUSH
56298: LD_VAR 0 1
56302: PUSH
56303: FOR_IN
56304: IFFALSE 56487
// begin nat := GetNation ( i ) ;
56306: LD_ADDR_VAR 0 7
56310: PUSH
56311: LD_VAR 0 4
56315: PPUSH
56316: CALL_OW 248
56320: ST_TO_ADDR
// weapon := 0 ;
56321: LD_ADDR_VAR 0 8
56325: PUSH
56326: LD_INT 0
56328: ST_TO_ADDR
// if not nat then
56329: LD_VAR 0 7
56333: NOT
56334: IFFALSE 56338
// continue ;
56336: GO 56303
// for j in list [ nat ] do
56338: LD_ADDR_VAR 0 5
56342: PUSH
56343: LD_VAR 0 10
56347: PUSH
56348: LD_VAR 0 7
56352: ARRAY
56353: PUSH
56354: FOR_IN
56355: IFFALSE 56396
// if GetBWeapon ( i ) = j [ 1 ] then
56357: LD_VAR 0 4
56361: PPUSH
56362: CALL_OW 269
56366: PUSH
56367: LD_VAR 0 5
56371: PUSH
56372: LD_INT 1
56374: ARRAY
56375: EQUAL
56376: IFFALSE 56394
// begin weapon := j [ 2 ] ;
56378: LD_ADDR_VAR 0 8
56382: PUSH
56383: LD_VAR 0 5
56387: PUSH
56388: LD_INT 2
56390: ARRAY
56391: ST_TO_ADDR
// break ;
56392: GO 56396
// end ;
56394: GO 56354
56396: POP
56397: POP
// if not weapon then
56398: LD_VAR 0 8
56402: NOT
56403: IFFALSE 56407
// continue ;
56405: GO 56303
// for k in factories do
56407: LD_ADDR_VAR 0 6
56411: PUSH
56412: LD_VAR 0 2
56416: PUSH
56417: FOR_IN
56418: IFFALSE 56483
// begin weapons := AvailableWeaponList ( k ) ;
56420: LD_ADDR_VAR 0 9
56424: PUSH
56425: LD_VAR 0 6
56429: PPUSH
56430: CALL_OW 478
56434: ST_TO_ADDR
// if not weapons then
56435: LD_VAR 0 9
56439: NOT
56440: IFFALSE 56444
// continue ;
56442: GO 56417
// if weapon in weapons then
56444: LD_VAR 0 8
56448: PUSH
56449: LD_VAR 0 9
56453: IN
56454: IFFALSE 56481
// begin result := [ i , weapon ] ;
56456: LD_ADDR_VAR 0 3
56460: PUSH
56461: LD_VAR 0 4
56465: PUSH
56466: LD_VAR 0 8
56470: PUSH
56471: EMPTY
56472: LIST
56473: LIST
56474: ST_TO_ADDR
// exit ;
56475: POP
56476: POP
56477: POP
56478: POP
56479: GO 56489
// end ; end ;
56481: GO 56417
56483: POP
56484: POP
// end ;
56485: GO 56303
56487: POP
56488: POP
// end ;
56489: LD_VAR 0 3
56493: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
56494: LD_INT 0
56496: PPUSH
// if not side or side > 8 then
56497: LD_VAR 0 3
56501: NOT
56502: PUSH
56503: LD_VAR 0 3
56507: PUSH
56508: LD_INT 8
56510: GREATER
56511: OR
56512: IFFALSE 56516
// exit ;
56514: GO 56575
// if not range then
56516: LD_VAR 0 4
56520: NOT
56521: IFFALSE 56532
// range := - 12 ;
56523: LD_ADDR_VAR 0 4
56527: PUSH
56528: LD_INT 12
56530: NEG
56531: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
56532: LD_VAR 0 1
56536: PPUSH
56537: LD_VAR 0 2
56541: PPUSH
56542: LD_VAR 0 3
56546: PPUSH
56547: LD_VAR 0 4
56551: PPUSH
56552: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
56556: LD_VAR 0 1
56560: PPUSH
56561: LD_VAR 0 2
56565: PPUSH
56566: LD_VAR 0 3
56570: PPUSH
56571: CALL_OW 331
// end ;
56575: LD_VAR 0 5
56579: RET
// export function Video ( mode ) ; begin
56580: LD_INT 0
56582: PPUSH
// ingame_video = mode ;
56583: LD_ADDR_OWVAR 52
56587: PUSH
56588: LD_VAR 0 1
56592: ST_TO_ADDR
// interface_hidden = mode ;
56593: LD_ADDR_OWVAR 54
56597: PUSH
56598: LD_VAR 0 1
56602: ST_TO_ADDR
// end ;
56603: LD_VAR 0 2
56607: RET
// export function Join ( array , element ) ; begin
56608: LD_INT 0
56610: PPUSH
// result := Replace ( array , array + 1 , element ) ;
56611: LD_ADDR_VAR 0 3
56615: PUSH
56616: LD_VAR 0 1
56620: PPUSH
56621: LD_VAR 0 1
56625: PUSH
56626: LD_INT 1
56628: PLUS
56629: PPUSH
56630: LD_VAR 0 2
56634: PPUSH
56635: CALL_OW 1
56639: ST_TO_ADDR
// end ;
56640: LD_VAR 0 3
56644: RET
// export function JoinUnion ( array , element ) ; begin
56645: LD_INT 0
56647: PPUSH
// result := array union element ;
56648: LD_ADDR_VAR 0 3
56652: PUSH
56653: LD_VAR 0 1
56657: PUSH
56658: LD_VAR 0 2
56662: UNION
56663: ST_TO_ADDR
// end ;
56664: LD_VAR 0 3
56668: RET
// export function GetBehemoths ( side ) ; begin
56669: LD_INT 0
56671: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , ru_behemoth ] ] ) ;
56672: LD_ADDR_VAR 0 2
56676: PUSH
56677: LD_INT 22
56679: PUSH
56680: LD_VAR 0 1
56684: PUSH
56685: EMPTY
56686: LIST
56687: LIST
56688: PUSH
56689: LD_INT 31
56691: PUSH
56692: LD_INT 25
56694: PUSH
56695: EMPTY
56696: LIST
56697: LIST
56698: PUSH
56699: EMPTY
56700: LIST
56701: LIST
56702: PPUSH
56703: CALL_OW 69
56707: ST_TO_ADDR
// end ;
56708: LD_VAR 0 2
56712: RET
// export function Shuffle ( array ) ; var i , index ; begin
56713: LD_INT 0
56715: PPUSH
56716: PPUSH
56717: PPUSH
// result := [ ] ;
56718: LD_ADDR_VAR 0 2
56722: PUSH
56723: EMPTY
56724: ST_TO_ADDR
// if not array then
56725: LD_VAR 0 1
56729: NOT
56730: IFFALSE 56734
// exit ;
56732: GO 56833
// Randomize ;
56734: CALL_OW 10
// for i = array downto 1 do
56738: LD_ADDR_VAR 0 3
56742: PUSH
56743: DOUBLE
56744: LD_VAR 0 1
56748: INC
56749: ST_TO_ADDR
56750: LD_INT 1
56752: PUSH
56753: FOR_DOWNTO
56754: IFFALSE 56831
// begin index := rand ( 1 , array ) ;
56756: LD_ADDR_VAR 0 4
56760: PUSH
56761: LD_INT 1
56763: PPUSH
56764: LD_VAR 0 1
56768: PPUSH
56769: CALL_OW 12
56773: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
56774: LD_ADDR_VAR 0 2
56778: PUSH
56779: LD_VAR 0 2
56783: PPUSH
56784: LD_VAR 0 2
56788: PUSH
56789: LD_INT 1
56791: PLUS
56792: PPUSH
56793: LD_VAR 0 1
56797: PUSH
56798: LD_VAR 0 4
56802: ARRAY
56803: PPUSH
56804: CALL_OW 2
56808: ST_TO_ADDR
// array := Delete ( array , index ) ;
56809: LD_ADDR_VAR 0 1
56813: PUSH
56814: LD_VAR 0 1
56818: PPUSH
56819: LD_VAR 0 4
56823: PPUSH
56824: CALL_OW 3
56828: ST_TO_ADDR
// end ;
56829: GO 56753
56831: POP
56832: POP
// end ;
56833: LD_VAR 0 2
56837: RET
// export function GetBaseMaterials ( base ) ; begin
56838: LD_INT 0
56840: PPUSH
// result := [ 0 , 0 , 0 ] ;
56841: LD_ADDR_VAR 0 2
56845: PUSH
56846: LD_INT 0
56848: PUSH
56849: LD_INT 0
56851: PUSH
56852: LD_INT 0
56854: PUSH
56855: EMPTY
56856: LIST
56857: LIST
56858: LIST
56859: ST_TO_ADDR
// if not base then
56860: LD_VAR 0 1
56864: NOT
56865: IFFALSE 56869
// exit ;
56867: GO 56918
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
56869: LD_ADDR_VAR 0 2
56873: PUSH
56874: LD_VAR 0 1
56878: PPUSH
56879: LD_INT 1
56881: PPUSH
56882: CALL_OW 275
56886: PUSH
56887: LD_VAR 0 1
56891: PPUSH
56892: LD_INT 2
56894: PPUSH
56895: CALL_OW 275
56899: PUSH
56900: LD_VAR 0 1
56904: PPUSH
56905: LD_INT 3
56907: PPUSH
56908: CALL_OW 275
56912: PUSH
56913: EMPTY
56914: LIST
56915: LIST
56916: LIST
56917: ST_TO_ADDR
// end ;
56918: LD_VAR 0 2
56922: RET
// export function ShrinkArray ( array , size ) ; var i ; begin
56923: LD_INT 0
56925: PPUSH
56926: PPUSH
// result := array ;
56927: LD_ADDR_VAR 0 3
56931: PUSH
56932: LD_VAR 0 1
56936: ST_TO_ADDR
// if size >= result then
56937: LD_VAR 0 2
56941: PUSH
56942: LD_VAR 0 3
56946: GREATEREQUAL
56947: IFFALSE 56951
// exit ;
56949: GO 57001
// if size then
56951: LD_VAR 0 2
56955: IFFALSE 57001
// for i := array downto size do
56957: LD_ADDR_VAR 0 4
56961: PUSH
56962: DOUBLE
56963: LD_VAR 0 1
56967: INC
56968: ST_TO_ADDR
56969: LD_VAR 0 2
56973: PUSH
56974: FOR_DOWNTO
56975: IFFALSE 56999
// result := Delete ( result , result ) ;
56977: LD_ADDR_VAR 0 3
56981: PUSH
56982: LD_VAR 0 3
56986: PPUSH
56987: LD_VAR 0 3
56991: PPUSH
56992: CALL_OW 3
56996: ST_TO_ADDR
56997: GO 56974
56999: POP
57000: POP
// end ;
57001: LD_VAR 0 3
57005: RET
// export function ComExit ( unit ) ; var tmp ; begin
57006: LD_INT 0
57008: PPUSH
57009: PPUSH
// if not IsInUnit ( unit ) then
57010: LD_VAR 0 1
57014: PPUSH
57015: CALL_OW 310
57019: NOT
57020: IFFALSE 57024
// exit ;
57022: GO 57084
// tmp := IsInUnit ( unit ) ;
57024: LD_ADDR_VAR 0 3
57028: PUSH
57029: LD_VAR 0 1
57033: PPUSH
57034: CALL_OW 310
57038: ST_TO_ADDR
// if GetType ( tmp ) = unit_vehicle then
57039: LD_VAR 0 3
57043: PPUSH
57044: CALL_OW 247
57048: PUSH
57049: LD_INT 2
57051: EQUAL
57052: IFFALSE 57065
// ComExitVehicle ( unit ) else
57054: LD_VAR 0 1
57058: PPUSH
57059: CALL_OW 121
57063: GO 57074
// ComExitBuilding ( unit ) ;
57065: LD_VAR 0 1
57069: PPUSH
57070: CALL_OW 122
// result := tmp ;
57074: LD_ADDR_VAR 0 2
57078: PUSH
57079: LD_VAR 0 3
57083: ST_TO_ADDR
// end ;
57084: LD_VAR 0 2
57088: RET
// export function ComExitAll ( units ) ; var i ; begin
57089: LD_INT 0
57091: PPUSH
57092: PPUSH
// if not units then
57093: LD_VAR 0 1
57097: NOT
57098: IFFALSE 57102
// exit ;
57100: GO 57128
// for i in units do
57102: LD_ADDR_VAR 0 3
57106: PUSH
57107: LD_VAR 0 1
57111: PUSH
57112: FOR_IN
57113: IFFALSE 57126
// ComExit ( i ) ;
57115: LD_VAR 0 3
57119: PPUSH
57120: CALL 57006 0 1
57124: GO 57112
57126: POP
57127: POP
// end ;
57128: LD_VAR 0 2
57132: RET
// export function ResetHc ; begin
57133: LD_INT 0
57135: PPUSH
// InitHc ;
57136: CALL_OW 19
// hc_importance := 0 ;
57140: LD_ADDR_OWVAR 32
57144: PUSH
57145: LD_INT 0
57147: ST_TO_ADDR
// end ;
57148: LD_VAR 0 1
57152: RET
// export function PointBetweenXY ( x1 , y1 , x2 , y2 ) ; var _x , _y ; begin
57153: LD_INT 0
57155: PPUSH
57156: PPUSH
57157: PPUSH
// _x := ( x1 + x2 ) div 2 ;
57158: LD_ADDR_VAR 0 6
57162: PUSH
57163: LD_VAR 0 1
57167: PUSH
57168: LD_VAR 0 3
57172: PLUS
57173: PUSH
57174: LD_INT 2
57176: DIV
57177: ST_TO_ADDR
// if _x < 0 then
57178: LD_VAR 0 6
57182: PUSH
57183: LD_INT 0
57185: LESS
57186: IFFALSE 57203
// _x := _x * - 1 ;
57188: LD_ADDR_VAR 0 6
57192: PUSH
57193: LD_VAR 0 6
57197: PUSH
57198: LD_INT 1
57200: NEG
57201: MUL
57202: ST_TO_ADDR
// _y := ( y1 + y2 ) div 2 ;
57203: LD_ADDR_VAR 0 7
57207: PUSH
57208: LD_VAR 0 2
57212: PUSH
57213: LD_VAR 0 4
57217: PLUS
57218: PUSH
57219: LD_INT 2
57221: DIV
57222: ST_TO_ADDR
// if _y < 0 then
57223: LD_VAR 0 7
57227: PUSH
57228: LD_INT 0
57230: LESS
57231: IFFALSE 57248
// _y := _y * - 1 ;
57233: LD_ADDR_VAR 0 7
57237: PUSH
57238: LD_VAR 0 7
57242: PUSH
57243: LD_INT 1
57245: NEG
57246: MUL
57247: ST_TO_ADDR
// result := [ _x , _y ] ;
57248: LD_ADDR_VAR 0 5
57252: PUSH
57253: LD_VAR 0 6
57257: PUSH
57258: LD_VAR 0 7
57262: PUSH
57263: EMPTY
57264: LIST
57265: LIST
57266: ST_TO_ADDR
// end ;
57267: LD_VAR 0 5
57271: RET
// export function NotGoToAreaUnit ( unit , area , goAway ) ; var x , y , task ; begin
57272: LD_INT 0
57274: PPUSH
57275: PPUSH
57276: PPUSH
57277: PPUSH
// task := GetTaskList ( unit ) ;
57278: LD_ADDR_VAR 0 7
57282: PUSH
57283: LD_VAR 0 1
57287: PPUSH
57288: CALL_OW 437
57292: ST_TO_ADDR
// if not task and not IsInArea ( unit , area ) then
57293: LD_VAR 0 7
57297: NOT
57298: PUSH
57299: LD_VAR 0 1
57303: PPUSH
57304: LD_VAR 0 2
57308: PPUSH
57309: CALL_OW 308
57313: NOT
57314: AND
57315: IFFALSE 57319
// exit ;
57317: GO 57437
// if IsInArea ( unit , area ) then
57319: LD_VAR 0 1
57323: PPUSH
57324: LD_VAR 0 2
57328: PPUSH
57329: CALL_OW 308
57333: IFFALSE 57351
// begin ComMoveToArea ( unit , goAway ) ;
57335: LD_VAR 0 1
57339: PPUSH
57340: LD_VAR 0 3
57344: PPUSH
57345: CALL_OW 113
// exit ;
57349: GO 57437
// end ; if task [ 1 ] [ 1 ] <> M then
57351: LD_VAR 0 7
57355: PUSH
57356: LD_INT 1
57358: ARRAY
57359: PUSH
57360: LD_INT 1
57362: ARRAY
57363: PUSH
57364: LD_STRING M
57366: NONEQUAL
57367: IFFALSE 57371
// exit ;
57369: GO 57437
// x := task [ 1 ] [ 2 ] ;
57371: LD_ADDR_VAR 0 5
57375: PUSH
57376: LD_VAR 0 7
57380: PUSH
57381: LD_INT 1
57383: ARRAY
57384: PUSH
57385: LD_INT 2
57387: ARRAY
57388: ST_TO_ADDR
// y := task [ 1 ] [ 3 ] ;
57389: LD_ADDR_VAR 0 6
57393: PUSH
57394: LD_VAR 0 7
57398: PUSH
57399: LD_INT 1
57401: ARRAY
57402: PUSH
57403: LD_INT 3
57405: ARRAY
57406: ST_TO_ADDR
// if InArea ( x , y , area ) then
57407: LD_VAR 0 5
57411: PPUSH
57412: LD_VAR 0 6
57416: PPUSH
57417: LD_VAR 0 2
57421: PPUSH
57422: CALL_OW 309
57426: IFFALSE 57437
// ComStop ( unit ) ;
57428: LD_VAR 0 1
57432: PPUSH
57433: CALL_OW 141
// end ;
57437: LD_VAR 0 4
57441: RET
// export function Abs ( value ) ; begin
57442: LD_INT 0
57444: PPUSH
// result := value ;
57445: LD_ADDR_VAR 0 2
57449: PUSH
57450: LD_VAR 0 1
57454: ST_TO_ADDR
// if value < 0 then
57455: LD_VAR 0 1
57459: PUSH
57460: LD_INT 0
57462: LESS
57463: IFFALSE 57480
// result := value * - 1 ;
57465: LD_ADDR_VAR 0 2
57469: PUSH
57470: LD_VAR 0 1
57474: PUSH
57475: LD_INT 1
57477: NEG
57478: MUL
57479: ST_TO_ADDR
// end ;
57480: LD_VAR 0 2
57484: RET
// export function ComMoveToNearbyEntrance ( unit , building ) ; var x , _x , y , _y , d , r , i ; begin
57485: LD_INT 0
57487: PPUSH
57488: PPUSH
57489: PPUSH
57490: PPUSH
57491: PPUSH
57492: PPUSH
57493: PPUSH
57494: PPUSH
// if not unit or not building then
57495: LD_VAR 0 1
57499: NOT
57500: PUSH
57501: LD_VAR 0 2
57505: NOT
57506: OR
57507: IFFALSE 57511
// exit ;
57509: GO 57737
// x := GetX ( building ) ;
57511: LD_ADDR_VAR 0 4
57515: PUSH
57516: LD_VAR 0 2
57520: PPUSH
57521: CALL_OW 250
57525: ST_TO_ADDR
// y := GetY ( building ) ;
57526: LD_ADDR_VAR 0 6
57530: PUSH
57531: LD_VAR 0 2
57535: PPUSH
57536: CALL_OW 251
57540: ST_TO_ADDR
// d := GetDir ( building ) ;
57541: LD_ADDR_VAR 0 8
57545: PUSH
57546: LD_VAR 0 2
57550: PPUSH
57551: CALL_OW 254
57555: ST_TO_ADDR
// r := 4 ;
57556: LD_ADDR_VAR 0 9
57560: PUSH
57561: LD_INT 4
57563: ST_TO_ADDR
// for i := 1 to 5 do
57564: LD_ADDR_VAR 0 10
57568: PUSH
57569: DOUBLE
57570: LD_INT 1
57572: DEC
57573: ST_TO_ADDR
57574: LD_INT 5
57576: PUSH
57577: FOR_TO
57578: IFFALSE 57735
// begin _x := ShiftX ( x , d , r + i ) ;
57580: LD_ADDR_VAR 0 5
57584: PUSH
57585: LD_VAR 0 4
57589: PPUSH
57590: LD_VAR 0 8
57594: PPUSH
57595: LD_VAR 0 9
57599: PUSH
57600: LD_VAR 0 10
57604: PLUS
57605: PPUSH
57606: CALL_OW 272
57610: ST_TO_ADDR
// _y := ShiftY ( y , d , r + i ) ;
57611: LD_ADDR_VAR 0 7
57615: PUSH
57616: LD_VAR 0 6
57620: PPUSH
57621: LD_VAR 0 8
57625: PPUSH
57626: LD_VAR 0 9
57630: PUSH
57631: LD_VAR 0 10
57635: PLUS
57636: PPUSH
57637: CALL_OW 273
57641: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not GetType ( HexInfo ( _x , _y ) ) in [ unit_building , unit_vehicle ] then
57642: LD_VAR 0 5
57646: PPUSH
57647: LD_VAR 0 7
57651: PPUSH
57652: CALL_OW 488
57656: PUSH
57657: LD_VAR 0 5
57661: PPUSH
57662: LD_VAR 0 7
57666: PPUSH
57667: CALL_OW 428
57671: PPUSH
57672: CALL_OW 247
57676: PUSH
57677: LD_INT 3
57679: PUSH
57680: LD_INT 2
57682: PUSH
57683: EMPTY
57684: LIST
57685: LIST
57686: IN
57687: NOT
57688: AND
57689: IFFALSE 57733
// begin ComMoveXY ( unit , _x , _y ) ;
57691: LD_VAR 0 1
57695: PPUSH
57696: LD_VAR 0 5
57700: PPUSH
57701: LD_VAR 0 7
57705: PPUSH
57706: CALL_OW 111
// result := [ _x , _y ] ;
57710: LD_ADDR_VAR 0 3
57714: PUSH
57715: LD_VAR 0 5
57719: PUSH
57720: LD_VAR 0 7
57724: PUSH
57725: EMPTY
57726: LIST
57727: LIST
57728: ST_TO_ADDR
// exit ;
57729: POP
57730: POP
57731: GO 57737
// end ; end ;
57733: GO 57577
57735: POP
57736: POP
// end ;
57737: LD_VAR 0 3
57741: RET
// export function SideAttackedSide ( side1 , side2 ) ; var i , un ; begin
57742: LD_INT 0
57744: PPUSH
57745: PPUSH
57746: PPUSH
// result := 0 ;
57747: LD_ADDR_VAR 0 3
57751: PUSH
57752: LD_INT 0
57754: ST_TO_ADDR
// if side1 < 0 or side1 > 8 or side2 < 0 or side2 > 8 then
57755: LD_VAR 0 1
57759: PUSH
57760: LD_INT 0
57762: LESS
57763: PUSH
57764: LD_VAR 0 1
57768: PUSH
57769: LD_INT 8
57771: GREATER
57772: OR
57773: PUSH
57774: LD_VAR 0 2
57778: PUSH
57779: LD_INT 0
57781: LESS
57782: OR
57783: PUSH
57784: LD_VAR 0 2
57788: PUSH
57789: LD_INT 8
57791: GREATER
57792: OR
57793: IFFALSE 57797
// exit ;
57795: GO 57872
// for i in FilterAllUnits ( [ f_side , side2 ] ) do
57797: LD_ADDR_VAR 0 4
57801: PUSH
57802: LD_INT 22
57804: PUSH
57805: LD_VAR 0 2
57809: PUSH
57810: EMPTY
57811: LIST
57812: LIST
57813: PPUSH
57814: CALL_OW 69
57818: PUSH
57819: FOR_IN
57820: IFFALSE 57870
// begin un := UnitShoot ( i ) ;
57822: LD_ADDR_VAR 0 5
57826: PUSH
57827: LD_VAR 0 4
57831: PPUSH
57832: CALL_OW 504
57836: ST_TO_ADDR
// if GetSide ( un ) = side1 then
57837: LD_VAR 0 5
57841: PPUSH
57842: CALL_OW 255
57846: PUSH
57847: LD_VAR 0 1
57851: EQUAL
57852: IFFALSE 57868
// begin result := un ;
57854: LD_ADDR_VAR 0 3
57858: PUSH
57859: LD_VAR 0 5
57863: ST_TO_ADDR
// exit ;
57864: POP
57865: POP
57866: GO 57872
// end ; end ;
57868: GO 57819
57870: POP
57871: POP
// end ;
57872: LD_VAR 0 3
57876: RET
// export function GetCargoBay ( units ) ; begin
57877: LD_INT 0
57879: PPUSH
// result := UnitFilter ( units , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ) ;
57880: LD_ADDR_VAR 0 2
57884: PUSH
57885: LD_VAR 0 1
57889: PPUSH
57890: LD_INT 2
57892: PUSH
57893: LD_INT 34
57895: PUSH
57896: LD_INT 12
57898: PUSH
57899: EMPTY
57900: LIST
57901: LIST
57902: PUSH
57903: LD_INT 34
57905: PUSH
57906: LD_INT 51
57908: PUSH
57909: EMPTY
57910: LIST
57911: LIST
57912: PUSH
57913: LD_INT 34
57915: PUSH
57916: LD_INT 32
57918: PUSH
57919: EMPTY
57920: LIST
57921: LIST
57922: PUSH
57923: LD_INT 34
57925: PUSH
57926: LD_EXP 159
57930: PUSH
57931: EMPTY
57932: LIST
57933: LIST
57934: PUSH
57935: EMPTY
57936: LIST
57937: LIST
57938: LIST
57939: LIST
57940: LIST
57941: PPUSH
57942: CALL_OW 72
57946: ST_TO_ADDR
// end ;
57947: LD_VAR 0 2
57951: RET
// export function Negate ( value ) ; begin
57952: LD_INT 0
57954: PPUSH
// result := not value ;
57955: LD_ADDR_VAR 0 2
57959: PUSH
57960: LD_VAR 0 1
57964: NOT
57965: ST_TO_ADDR
// end ;
57966: LD_VAR 0 2
57970: RET
// export function Inc ( value ) ; begin
57971: LD_INT 0
57973: PPUSH
// result := value + 1 ;
57974: LD_ADDR_VAR 0 2
57978: PUSH
57979: LD_VAR 0 1
57983: PUSH
57984: LD_INT 1
57986: PLUS
57987: ST_TO_ADDR
// end ;
57988: LD_VAR 0 2
57992: RET
// export function Dec ( value ) ; begin
57993: LD_INT 0
57995: PPUSH
// result := value - 1 ;
57996: LD_ADDR_VAR 0 2
58000: PUSH
58001: LD_VAR 0 1
58005: PUSH
58006: LD_INT 1
58008: MINUS
58009: ST_TO_ADDR
// end ;
58010: LD_VAR 0 2
58014: RET
// export function GetDirFromHex ( x1 , y1 , x2 , y2 ) ; var i , _x , _y , tmp , distance , centerDist , centerPoint ; begin
58015: LD_INT 0
58017: PPUSH
58018: PPUSH
58019: PPUSH
58020: PPUSH
58021: PPUSH
58022: PPUSH
58023: PPUSH
58024: PPUSH
// if not ValidHex ( x1 , y1 ) or not ValidHex ( x2 , y2 ) then
58025: LD_VAR 0 1
58029: PPUSH
58030: LD_VAR 0 2
58034: PPUSH
58035: CALL_OW 488
58039: NOT
58040: PUSH
58041: LD_VAR 0 3
58045: PPUSH
58046: LD_VAR 0 4
58050: PPUSH
58051: CALL_OW 488
58055: NOT
58056: OR
58057: IFFALSE 58070
// begin result := - 1 ;
58059: LD_ADDR_VAR 0 5
58063: PUSH
58064: LD_INT 1
58066: NEG
58067: ST_TO_ADDR
// exit ;
58068: GO 58305
// end ; centerPoint := PointBetweenXY ( x1 , y1 , x2 , y2 ) ;
58070: LD_ADDR_VAR 0 12
58074: PUSH
58075: LD_VAR 0 1
58079: PPUSH
58080: LD_VAR 0 2
58084: PPUSH
58085: LD_VAR 0 3
58089: PPUSH
58090: LD_VAR 0 4
58094: PPUSH
58095: CALL 57153 0 4
58099: ST_TO_ADDR
// centerDist := GetDistXY ( x1 , y1 , centerPoint [ 1 ] , centerPoint [ 2 ] ) ;
58100: LD_ADDR_VAR 0 11
58104: PUSH
58105: LD_VAR 0 1
58109: PPUSH
58110: LD_VAR 0 2
58114: PPUSH
58115: LD_VAR 0 12
58119: PUSH
58120: LD_INT 1
58122: ARRAY
58123: PPUSH
58124: LD_VAR 0 12
58128: PUSH
58129: LD_INT 2
58131: ARRAY
58132: PPUSH
58133: CALL_OW 298
58137: ST_TO_ADDR
// distance := 9999 ;
58138: LD_ADDR_VAR 0 10
58142: PUSH
58143: LD_INT 9999
58145: ST_TO_ADDR
// for i := 0 to 5 do
58146: LD_ADDR_VAR 0 6
58150: PUSH
58151: DOUBLE
58152: LD_INT 0
58154: DEC
58155: ST_TO_ADDR
58156: LD_INT 5
58158: PUSH
58159: FOR_TO
58160: IFFALSE 58303
// begin _x := ShiftX ( x1 , i , centerDist ) ;
58162: LD_ADDR_VAR 0 7
58166: PUSH
58167: LD_VAR 0 1
58171: PPUSH
58172: LD_VAR 0 6
58176: PPUSH
58177: LD_VAR 0 11
58181: PPUSH
58182: CALL_OW 272
58186: ST_TO_ADDR
// _y := ShiftY ( y1 , i , centerDist ) ;
58187: LD_ADDR_VAR 0 8
58191: PUSH
58192: LD_VAR 0 2
58196: PPUSH
58197: LD_VAR 0 6
58201: PPUSH
58202: LD_VAR 0 11
58206: PPUSH
58207: CALL_OW 273
58211: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
58212: LD_VAR 0 7
58216: PPUSH
58217: LD_VAR 0 8
58221: PPUSH
58222: CALL_OW 488
58226: NOT
58227: IFFALSE 58231
// continue ;
58229: GO 58159
// tmp := GetDistXY ( centerPoint [ 1 ] , centerPoint [ 2 ] , _x , _y ) ;
58231: LD_ADDR_VAR 0 9
58235: PUSH
58236: LD_VAR 0 12
58240: PUSH
58241: LD_INT 1
58243: ARRAY
58244: PPUSH
58245: LD_VAR 0 12
58249: PUSH
58250: LD_INT 2
58252: ARRAY
58253: PPUSH
58254: LD_VAR 0 7
58258: PPUSH
58259: LD_VAR 0 8
58263: PPUSH
58264: CALL_OW 298
58268: ST_TO_ADDR
// if tmp < distance then
58269: LD_VAR 0 9
58273: PUSH
58274: LD_VAR 0 10
58278: LESS
58279: IFFALSE 58301
// begin result := i ;
58281: LD_ADDR_VAR 0 5
58285: PUSH
58286: LD_VAR 0 6
58290: ST_TO_ADDR
// distance := tmp ;
58291: LD_ADDR_VAR 0 10
58295: PUSH
58296: LD_VAR 0 9
58300: ST_TO_ADDR
// end ; end ;
58301: GO 58159
58303: POP
58304: POP
// end ;
58305: LD_VAR 0 5
58309: RET
// export function ComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
58310: LD_INT 0
58312: PPUSH
58313: PPUSH
// if not driver or not IsInUnit ( driver ) then
58314: LD_VAR 0 1
58318: NOT
58319: PUSH
58320: LD_VAR 0 1
58324: PPUSH
58325: CALL_OW 310
58329: NOT
58330: OR
58331: IFFALSE 58335
// exit ;
58333: GO 58425
// vehicle := IsInUnit ( driver ) ;
58335: LD_ADDR_VAR 0 3
58339: PUSH
58340: LD_VAR 0 1
58344: PPUSH
58345: CALL_OW 310
58349: ST_TO_ADDR
// SetTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
58350: LD_VAR 0 1
58354: PPUSH
58355: LD_STRING \
58357: PUSH
58358: LD_INT 0
58360: PUSH
58361: LD_INT 0
58363: PUSH
58364: LD_INT 0
58366: PUSH
58367: LD_INT 0
58369: PUSH
58370: LD_INT 0
58372: PUSH
58373: LD_INT 0
58375: PUSH
58376: EMPTY
58377: LIST
58378: LIST
58379: LIST
58380: LIST
58381: LIST
58382: LIST
58383: LIST
58384: PUSH
58385: LD_STRING E
58387: PUSH
58388: LD_INT 0
58390: PUSH
58391: LD_INT 0
58393: PUSH
58394: LD_VAR 0 3
58398: PUSH
58399: LD_INT 0
58401: PUSH
58402: LD_INT 0
58404: PUSH
58405: LD_INT 0
58407: PUSH
58408: EMPTY
58409: LIST
58410: LIST
58411: LIST
58412: LIST
58413: LIST
58414: LIST
58415: LIST
58416: PUSH
58417: EMPTY
58418: LIST
58419: LIST
58420: PPUSH
58421: CALL_OW 446
// end ;
58425: LD_VAR 0 2
58429: RET
// export function AddComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
58430: LD_INT 0
58432: PPUSH
58433: PPUSH
// if not driver or not IsInUnit ( driver ) then
58434: LD_VAR 0 1
58438: NOT
58439: PUSH
58440: LD_VAR 0 1
58444: PPUSH
58445: CALL_OW 310
58449: NOT
58450: OR
58451: IFFALSE 58455
// exit ;
58453: GO 58545
// vehicle := IsInUnit ( driver ) ;
58455: LD_ADDR_VAR 0 3
58459: PUSH
58460: LD_VAR 0 1
58464: PPUSH
58465: CALL_OW 310
58469: ST_TO_ADDR
// AddTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
58470: LD_VAR 0 1
58474: PPUSH
58475: LD_STRING \
58477: PUSH
58478: LD_INT 0
58480: PUSH
58481: LD_INT 0
58483: PUSH
58484: LD_INT 0
58486: PUSH
58487: LD_INT 0
58489: PUSH
58490: LD_INT 0
58492: PUSH
58493: LD_INT 0
58495: PUSH
58496: EMPTY
58497: LIST
58498: LIST
58499: LIST
58500: LIST
58501: LIST
58502: LIST
58503: LIST
58504: PUSH
58505: LD_STRING E
58507: PUSH
58508: LD_INT 0
58510: PUSH
58511: LD_INT 0
58513: PUSH
58514: LD_VAR 0 3
58518: PUSH
58519: LD_INT 0
58521: PUSH
58522: LD_INT 0
58524: PUSH
58525: LD_INT 0
58527: PUSH
58528: EMPTY
58529: LIST
58530: LIST
58531: LIST
58532: LIST
58533: LIST
58534: LIST
58535: LIST
58536: PUSH
58537: EMPTY
58538: LIST
58539: LIST
58540: PPUSH
58541: CALL_OW 447
// end ;
58545: LD_VAR 0 2
58549: RET
// export function SortByHealth ( units , asc ) ; var i , tmp ; begin
58550: LD_INT 0
58552: PPUSH
58553: PPUSH
58554: PPUSH
// tmp := [ ] ;
58555: LD_ADDR_VAR 0 5
58559: PUSH
58560: EMPTY
58561: ST_TO_ADDR
// for i in units do
58562: LD_ADDR_VAR 0 4
58566: PUSH
58567: LD_VAR 0 1
58571: PUSH
58572: FOR_IN
58573: IFFALSE 58611
// tmp := Insert ( tmp , tmp + 1 , GetLives ( i ) ) ;
58575: LD_ADDR_VAR 0 5
58579: PUSH
58580: LD_VAR 0 5
58584: PPUSH
58585: LD_VAR 0 5
58589: PUSH
58590: LD_INT 1
58592: PLUS
58593: PPUSH
58594: LD_VAR 0 4
58598: PPUSH
58599: CALL_OW 256
58603: PPUSH
58604: CALL_OW 2
58608: ST_TO_ADDR
58609: GO 58572
58611: POP
58612: POP
// if not tmp then
58613: LD_VAR 0 5
58617: NOT
58618: IFFALSE 58622
// exit ;
58620: GO 58670
// if asc then
58622: LD_VAR 0 2
58626: IFFALSE 58650
// result := SortListByListAsc ( units , tmp ) else
58628: LD_ADDR_VAR 0 3
58632: PUSH
58633: LD_VAR 0 1
58637: PPUSH
58638: LD_VAR 0 5
58642: PPUSH
58643: CALL_OW 76
58647: ST_TO_ADDR
58648: GO 58670
// result := SortListByListDesc ( units , tmp ) ;
58650: LD_ADDR_VAR 0 3
58654: PUSH
58655: LD_VAR 0 1
58659: PPUSH
58660: LD_VAR 0 5
58664: PPUSH
58665: CALL_OW 77
58669: ST_TO_ADDR
// end ;
58670: LD_VAR 0 3
58674: RET
// export function WantToRepairVehicle ( mech , vehicle ) ; var task ; begin
58675: LD_INT 0
58677: PPUSH
58678: PPUSH
// task := GetTaskList ( mech ) ;
58679: LD_ADDR_VAR 0 4
58683: PUSH
58684: LD_VAR 0 1
58688: PPUSH
58689: CALL_OW 437
58693: ST_TO_ADDR
// if not task then
58694: LD_VAR 0 4
58698: NOT
58699: IFFALSE 58703
// exit ;
58701: GO 58745
// result := task [ 1 ] [ 1 ] = r and task [ 1 ] [ 4 ] = vehicle ;
58703: LD_ADDR_VAR 0 3
58707: PUSH
58708: LD_VAR 0 4
58712: PUSH
58713: LD_INT 1
58715: ARRAY
58716: PUSH
58717: LD_INT 1
58719: ARRAY
58720: PUSH
58721: LD_STRING r
58723: EQUAL
58724: PUSH
58725: LD_VAR 0 4
58729: PUSH
58730: LD_INT 1
58732: ARRAY
58733: PUSH
58734: LD_INT 4
58736: ARRAY
58737: PUSH
58738: LD_VAR 0 2
58742: EQUAL
58743: AND
58744: ST_TO_ADDR
// end ;
58745: LD_VAR 0 3
58749: RET
// export function PlaceUnitXYD ( unit , x , y , d , mode ) ; begin
58750: LD_INT 0
58752: PPUSH
// SetDir ( unit , d ) ;
58753: LD_VAR 0 1
58757: PPUSH
58758: LD_VAR 0 4
58762: PPUSH
58763: CALL_OW 233
// PlaceUnitXY ( unit , x , y , mode ) ;
58767: LD_VAR 0 1
58771: PPUSH
58772: LD_VAR 0 2
58776: PPUSH
58777: LD_VAR 0 3
58781: PPUSH
58782: LD_VAR 0 5
58786: PPUSH
58787: CALL_OW 48
// end ;
58791: LD_VAR 0 6
58795: RET
// export function ToNaturalNumber ( number ) ; begin
58796: LD_INT 0
58798: PPUSH
// result := number div 1 ;
58799: LD_ADDR_VAR 0 2
58803: PUSH
58804: LD_VAR 0 1
58808: PUSH
58809: LD_INT 1
58811: DIV
58812: ST_TO_ADDR
// if number < 0 then
58813: LD_VAR 0 1
58817: PUSH
58818: LD_INT 0
58820: LESS
58821: IFFALSE 58831
// result := 0 ;
58823: LD_ADDR_VAR 0 2
58827: PUSH
58828: LD_INT 0
58830: ST_TO_ADDR
// end ;
58831: LD_VAR 0 2
58835: RET
// export function SortByClass ( units , class ) ; var un ; begin
58836: LD_INT 0
58838: PPUSH
58839: PPUSH
// if not units or not class then
58840: LD_VAR 0 1
58844: NOT
58845: PUSH
58846: LD_VAR 0 2
58850: NOT
58851: OR
58852: IFFALSE 58856
// exit ;
58854: GO 58951
// result := [ ] ;
58856: LD_ADDR_VAR 0 3
58860: PUSH
58861: EMPTY
58862: ST_TO_ADDR
// for un in units do
58863: LD_ADDR_VAR 0 4
58867: PUSH
58868: LD_VAR 0 1
58872: PUSH
58873: FOR_IN
58874: IFFALSE 58949
// if GetClass ( un ) = class then
58876: LD_VAR 0 4
58880: PPUSH
58881: CALL_OW 257
58885: PUSH
58886: LD_VAR 0 2
58890: EQUAL
58891: IFFALSE 58918
// result := Insert ( result , 1 , un ) else
58893: LD_ADDR_VAR 0 3
58897: PUSH
58898: LD_VAR 0 3
58902: PPUSH
58903: LD_INT 1
58905: PPUSH
58906: LD_VAR 0 4
58910: PPUSH
58911: CALL_OW 2
58915: ST_TO_ADDR
58916: GO 58947
// result := Replace ( result , result + 1 , un ) ;
58918: LD_ADDR_VAR 0 3
58922: PUSH
58923: LD_VAR 0 3
58927: PPUSH
58928: LD_VAR 0 3
58932: PUSH
58933: LD_INT 1
58935: PLUS
58936: PPUSH
58937: LD_VAR 0 4
58941: PPUSH
58942: CALL_OW 1
58946: ST_TO_ADDR
58947: GO 58873
58949: POP
58950: POP
// end ;
58951: LD_VAR 0 3
58955: RET
// export function GetCratesNearbyXY ( x , y , r ) ; var _x , _y , min_y , min_x , max_x , max_y ; begin
58956: LD_INT 0
58958: PPUSH
58959: PPUSH
58960: PPUSH
58961: PPUSH
58962: PPUSH
58963: PPUSH
58964: PPUSH
// result := [ ] ;
58965: LD_ADDR_VAR 0 4
58969: PUSH
58970: EMPTY
58971: ST_TO_ADDR
// if x - r < 0 then
58972: LD_VAR 0 1
58976: PUSH
58977: LD_VAR 0 3
58981: MINUS
58982: PUSH
58983: LD_INT 0
58985: LESS
58986: IFFALSE 58998
// min_x := 0 else
58988: LD_ADDR_VAR 0 8
58992: PUSH
58993: LD_INT 0
58995: ST_TO_ADDR
58996: GO 59014
// min_x := x - r ;
58998: LD_ADDR_VAR 0 8
59002: PUSH
59003: LD_VAR 0 1
59007: PUSH
59008: LD_VAR 0 3
59012: MINUS
59013: ST_TO_ADDR
// if y - r < 0 then
59014: LD_VAR 0 2
59018: PUSH
59019: LD_VAR 0 3
59023: MINUS
59024: PUSH
59025: LD_INT 0
59027: LESS
59028: IFFALSE 59040
// min_y := 0 else
59030: LD_ADDR_VAR 0 7
59034: PUSH
59035: LD_INT 0
59037: ST_TO_ADDR
59038: GO 59056
// min_y := y - r ;
59040: LD_ADDR_VAR 0 7
59044: PUSH
59045: LD_VAR 0 2
59049: PUSH
59050: LD_VAR 0 3
59054: MINUS
59055: ST_TO_ADDR
// max_x := x + r ;
59056: LD_ADDR_VAR 0 9
59060: PUSH
59061: LD_VAR 0 1
59065: PUSH
59066: LD_VAR 0 3
59070: PLUS
59071: ST_TO_ADDR
// max_y := y + r ;
59072: LD_ADDR_VAR 0 10
59076: PUSH
59077: LD_VAR 0 2
59081: PUSH
59082: LD_VAR 0 3
59086: PLUS
59087: ST_TO_ADDR
// for _x = min_x to max_x do
59088: LD_ADDR_VAR 0 5
59092: PUSH
59093: DOUBLE
59094: LD_VAR 0 8
59098: DEC
59099: ST_TO_ADDR
59100: LD_VAR 0 9
59104: PUSH
59105: FOR_TO
59106: IFFALSE 59207
// for _y = min_y to max_y do
59108: LD_ADDR_VAR 0 6
59112: PUSH
59113: DOUBLE
59114: LD_VAR 0 7
59118: DEC
59119: ST_TO_ADDR
59120: LD_VAR 0 10
59124: PUSH
59125: FOR_TO
59126: IFFALSE 59203
// begin if not ValidHex ( _x , _y ) then
59128: LD_VAR 0 5
59132: PPUSH
59133: LD_VAR 0 6
59137: PPUSH
59138: CALL_OW 488
59142: NOT
59143: IFFALSE 59147
// continue ;
59145: GO 59125
// if GetResourceTypeXY ( _x , _y ) then
59147: LD_VAR 0 5
59151: PPUSH
59152: LD_VAR 0 6
59156: PPUSH
59157: CALL_OW 283
59161: IFFALSE 59201
// result := Replace ( result , result + 1 , [ _x , _y ] ) ;
59163: LD_ADDR_VAR 0 4
59167: PUSH
59168: LD_VAR 0 4
59172: PPUSH
59173: LD_VAR 0 4
59177: PUSH
59178: LD_INT 1
59180: PLUS
59181: PPUSH
59182: LD_VAR 0 5
59186: PUSH
59187: LD_VAR 0 6
59191: PUSH
59192: EMPTY
59193: LIST
59194: LIST
59195: PPUSH
59196: CALL_OW 1
59200: ST_TO_ADDR
// end ;
59201: GO 59125
59203: POP
59204: POP
59205: GO 59105
59207: POP
59208: POP
// end ;
59209: LD_VAR 0 4
59213: RET
// export function AgressiveMove ( units , path ) ; var i , enemy , nearEnemy , cr , side , tag , ignoreCratesWeapon ; begin
59214: LD_INT 0
59216: PPUSH
59217: PPUSH
59218: PPUSH
59219: PPUSH
59220: PPUSH
59221: PPUSH
59222: PPUSH
59223: PPUSH
// if not units then
59224: LD_VAR 0 1
59228: NOT
59229: IFFALSE 59233
// exit ;
59231: GO 59759
// result := UnitFilter ( units , [ f_ok ] ) ;
59233: LD_ADDR_VAR 0 3
59237: PUSH
59238: LD_VAR 0 1
59242: PPUSH
59243: LD_INT 50
59245: PUSH
59246: EMPTY
59247: LIST
59248: PPUSH
59249: CALL_OW 72
59253: ST_TO_ADDR
// side := GetSide ( units [ 1 ] ) ;
59254: LD_ADDR_VAR 0 8
59258: PUSH
59259: LD_VAR 0 1
59263: PUSH
59264: LD_INT 1
59266: ARRAY
59267: PPUSH
59268: CALL_OW 255
59272: ST_TO_ADDR
// ignoreCratesWeapon := [ ar_selfpropelled_bomb , ar_bio_bomb , ru_time_lapser ] ;
59273: LD_ADDR_VAR 0 10
59277: PUSH
59278: LD_INT 29
59280: PUSH
59281: LD_EXP 162
59285: PUSH
59286: LD_INT 49
59288: PUSH
59289: EMPTY
59290: LIST
59291: LIST
59292: LIST
59293: ST_TO_ADDR
// if not result then
59294: LD_VAR 0 3
59298: NOT
59299: IFFALSE 59303
// exit ;
59301: GO 59759
// enemy := FilterAllUnits ( [ f_enemy , side ] ) ;
59303: LD_ADDR_VAR 0 5
59307: PUSH
59308: LD_INT 81
59310: PUSH
59311: LD_VAR 0 8
59315: PUSH
59316: EMPTY
59317: LIST
59318: LIST
59319: PPUSH
59320: CALL_OW 69
59324: ST_TO_ADDR
// for i in result do
59325: LD_ADDR_VAR 0 4
59329: PUSH
59330: LD_VAR 0 3
59334: PUSH
59335: FOR_IN
59336: IFFALSE 59757
// begin tag := GetTag ( i ) + 1 ;
59338: LD_ADDR_VAR 0 9
59342: PUSH
59343: LD_VAR 0 4
59347: PPUSH
59348: CALL_OW 110
59352: PUSH
59353: LD_INT 1
59355: PLUS
59356: ST_TO_ADDR
// cr := GetCratesNearbyXY ( GetX ( i ) , GetY ( i ) , 6 ) ;
59357: LD_ADDR_VAR 0 7
59361: PUSH
59362: LD_VAR 0 4
59366: PPUSH
59367: CALL_OW 250
59371: PPUSH
59372: LD_VAR 0 4
59376: PPUSH
59377: CALL_OW 251
59381: PPUSH
59382: LD_INT 6
59384: PPUSH
59385: CALL 58956 0 3
59389: ST_TO_ADDR
// if GetType ( i ) = unit_vehicle and cr and not GetWeapon ( i ) in ignoreCratesWeapon then
59390: LD_VAR 0 4
59394: PPUSH
59395: CALL_OW 247
59399: PUSH
59400: LD_INT 2
59402: EQUAL
59403: PUSH
59404: LD_VAR 0 7
59408: AND
59409: PUSH
59410: LD_VAR 0 4
59414: PPUSH
59415: CALL_OW 264
59419: PUSH
59420: LD_VAR 0 10
59424: IN
59425: NOT
59426: AND
59427: IFFALSE 59466
// ComAttackPlace ( i , cr [ 1 ] [ 1 ] , cr [ 1 ] [ 2 ] ) else
59429: LD_VAR 0 4
59433: PPUSH
59434: LD_VAR 0 7
59438: PUSH
59439: LD_INT 1
59441: ARRAY
59442: PUSH
59443: LD_INT 1
59445: ARRAY
59446: PPUSH
59447: LD_VAR 0 7
59451: PUSH
59452: LD_INT 1
59454: ARRAY
59455: PUSH
59456: LD_INT 2
59458: ARRAY
59459: PPUSH
59460: CALL_OW 116
59464: GO 59755
// if path > tag then
59466: LD_VAR 0 2
59470: PUSH
59471: LD_VAR 0 9
59475: GREATER
59476: IFFALSE 59684
// begin nearEnemy := UnitFilter ( enemy , [ f_dist , i , 8 ] ) ;
59478: LD_ADDR_VAR 0 6
59482: PUSH
59483: LD_VAR 0 5
59487: PPUSH
59488: LD_INT 91
59490: PUSH
59491: LD_VAR 0 4
59495: PUSH
59496: LD_INT 8
59498: PUSH
59499: EMPTY
59500: LIST
59501: LIST
59502: LIST
59503: PPUSH
59504: CALL_OW 72
59508: ST_TO_ADDR
// if nearEnemy then
59509: LD_VAR 0 6
59513: IFFALSE 59582
// begin if GetWeapon ( i ) = ru_time_lapser then
59515: LD_VAR 0 4
59519: PPUSH
59520: CALL_OW 264
59524: PUSH
59525: LD_INT 49
59527: EQUAL
59528: IFFALSE 59556
// ComMoveUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) else
59530: LD_VAR 0 4
59534: PPUSH
59535: LD_VAR 0 6
59539: PPUSH
59540: LD_VAR 0 4
59544: PPUSH
59545: CALL_OW 74
59549: PPUSH
59550: CALL_OW 112
59554: GO 59580
// ComAttackUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) ;
59556: LD_VAR 0 4
59560: PPUSH
59561: LD_VAR 0 6
59565: PPUSH
59566: LD_VAR 0 4
59570: PPUSH
59571: CALL_OW 74
59575: PPUSH
59576: CALL_OW 115
// end else
59580: GO 59682
// if GetDistUnitXY ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) > 6 then
59582: LD_VAR 0 4
59586: PPUSH
59587: LD_VAR 0 2
59591: PUSH
59592: LD_VAR 0 9
59596: ARRAY
59597: PUSH
59598: LD_INT 1
59600: ARRAY
59601: PPUSH
59602: LD_VAR 0 2
59606: PUSH
59607: LD_VAR 0 9
59611: ARRAY
59612: PUSH
59613: LD_INT 2
59615: ARRAY
59616: PPUSH
59617: CALL_OW 297
59621: PUSH
59622: LD_INT 6
59624: GREATER
59625: IFFALSE 59668
// ComAgressiveMove ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) else
59627: LD_VAR 0 4
59631: PPUSH
59632: LD_VAR 0 2
59636: PUSH
59637: LD_VAR 0 9
59641: ARRAY
59642: PUSH
59643: LD_INT 1
59645: ARRAY
59646: PPUSH
59647: LD_VAR 0 2
59651: PUSH
59652: LD_VAR 0 9
59656: ARRAY
59657: PUSH
59658: LD_INT 2
59660: ARRAY
59661: PPUSH
59662: CALL_OW 114
59666: GO 59682
// SetTag ( i , tag ) ;
59668: LD_VAR 0 4
59672: PPUSH
59673: LD_VAR 0 9
59677: PPUSH
59678: CALL_OW 109
// end else
59682: GO 59755
// if enemy then
59684: LD_VAR 0 5
59688: IFFALSE 59755
// begin if GetWeapon ( i ) = ru_time_lapser then
59690: LD_VAR 0 4
59694: PPUSH
59695: CALL_OW 264
59699: PUSH
59700: LD_INT 49
59702: EQUAL
59703: IFFALSE 59731
// ComMoveUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
59705: LD_VAR 0 4
59709: PPUSH
59710: LD_VAR 0 5
59714: PPUSH
59715: LD_VAR 0 4
59719: PPUSH
59720: CALL_OW 74
59724: PPUSH
59725: CALL_OW 112
59729: GO 59755
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
59731: LD_VAR 0 4
59735: PPUSH
59736: LD_VAR 0 5
59740: PPUSH
59741: LD_VAR 0 4
59745: PPUSH
59746: CALL_OW 74
59750: PPUSH
59751: CALL_OW 115
// end ; end ;
59755: GO 59335
59757: POP
59758: POP
// end ;
59759: LD_VAR 0 3
59763: RET
// export function ComLookAtDir ( unit , direction ) ; var x , y ; begin
59764: LD_INT 0
59766: PPUSH
59767: PPUSH
59768: PPUSH
// if not unit or IsInUnit ( unit ) then
59769: LD_VAR 0 1
59773: NOT
59774: PUSH
59775: LD_VAR 0 1
59779: PPUSH
59780: CALL_OW 310
59784: OR
59785: IFFALSE 59789
// exit ;
59787: GO 59880
// x := ShiftX ( GetX ( unit ) , direction , 1 ) ;
59789: LD_ADDR_VAR 0 4
59793: PUSH
59794: LD_VAR 0 1
59798: PPUSH
59799: CALL_OW 250
59803: PPUSH
59804: LD_VAR 0 2
59808: PPUSH
59809: LD_INT 1
59811: PPUSH
59812: CALL_OW 272
59816: ST_TO_ADDR
// y := ShiftY ( GetY ( unit ) , direction , 1 ) ;
59817: LD_ADDR_VAR 0 5
59821: PUSH
59822: LD_VAR 0 1
59826: PPUSH
59827: CALL_OW 251
59831: PPUSH
59832: LD_VAR 0 2
59836: PPUSH
59837: LD_INT 1
59839: PPUSH
59840: CALL_OW 273
59844: ST_TO_ADDR
// if ValidHex ( x , y ) then
59845: LD_VAR 0 4
59849: PPUSH
59850: LD_VAR 0 5
59854: PPUSH
59855: CALL_OW 488
59859: IFFALSE 59880
// ComTurnXY ( unit , x , y ) ;
59861: LD_VAR 0 1
59865: PPUSH
59866: LD_VAR 0 4
59870: PPUSH
59871: LD_VAR 0 5
59875: PPUSH
59876: CALL_OW 118
// end ;
59880: LD_VAR 0 3
59884: RET
// export function SeeUnits ( side , units ) ; var i ; begin
59885: LD_INT 0
59887: PPUSH
59888: PPUSH
// result := false ;
59889: LD_ADDR_VAR 0 3
59893: PUSH
59894: LD_INT 0
59896: ST_TO_ADDR
// if not units then
59897: LD_VAR 0 2
59901: NOT
59902: IFFALSE 59906
// exit ;
59904: GO 59951
// for i in units do
59906: LD_ADDR_VAR 0 4
59910: PUSH
59911: LD_VAR 0 2
59915: PUSH
59916: FOR_IN
59917: IFFALSE 59949
// if See ( side , i ) then
59919: LD_VAR 0 1
59923: PPUSH
59924: LD_VAR 0 4
59928: PPUSH
59929: CALL_OW 292
59933: IFFALSE 59947
// begin result := true ;
59935: LD_ADDR_VAR 0 3
59939: PUSH
59940: LD_INT 1
59942: ST_TO_ADDR
// exit ;
59943: POP
59944: POP
59945: GO 59951
// end ;
59947: GO 59916
59949: POP
59950: POP
// end ;
59951: LD_VAR 0 3
59955: RET
// export function GetNearestPoint ( unit , points ) ; var i , dist , tmpDist ; begin
59956: LD_INT 0
59958: PPUSH
59959: PPUSH
59960: PPUSH
59961: PPUSH
// if not unit or not points then
59962: LD_VAR 0 1
59966: NOT
59967: PUSH
59968: LD_VAR 0 2
59972: NOT
59973: OR
59974: IFFALSE 59978
// exit ;
59976: GO 60068
// dist := 99999 ;
59978: LD_ADDR_VAR 0 5
59982: PUSH
59983: LD_INT 99999
59985: ST_TO_ADDR
// for i in points do
59986: LD_ADDR_VAR 0 4
59990: PUSH
59991: LD_VAR 0 2
59995: PUSH
59996: FOR_IN
59997: IFFALSE 60066
// begin tmpDist := GetDistUnitXY ( unit , i [ 1 ] , i [ 2 ] ) ;
59999: LD_ADDR_VAR 0 6
60003: PUSH
60004: LD_VAR 0 1
60008: PPUSH
60009: LD_VAR 0 4
60013: PUSH
60014: LD_INT 1
60016: ARRAY
60017: PPUSH
60018: LD_VAR 0 4
60022: PUSH
60023: LD_INT 2
60025: ARRAY
60026: PPUSH
60027: CALL_OW 297
60031: ST_TO_ADDR
// if tmpDist < dist then
60032: LD_VAR 0 6
60036: PUSH
60037: LD_VAR 0 5
60041: LESS
60042: IFFALSE 60064
// begin result := i ;
60044: LD_ADDR_VAR 0 3
60048: PUSH
60049: LD_VAR 0 4
60053: ST_TO_ADDR
// dist := tmpDist ;
60054: LD_ADDR_VAR 0 5
60058: PUSH
60059: LD_VAR 0 6
60063: ST_TO_ADDR
// end ; end ;
60064: GO 59996
60066: POP
60067: POP
// end ;
60068: LD_VAR 0 3
60072: RET
// export function CreateBehemoth ( side , x , y , d ) ; begin
60073: LD_INT 0
60075: PPUSH
// uc_side := side ;
60076: LD_ADDR_OWVAR 20
60080: PUSH
60081: LD_VAR 0 1
60085: ST_TO_ADDR
// uc_nation := 3 ;
60086: LD_ADDR_OWVAR 21
60090: PUSH
60091: LD_INT 3
60093: ST_TO_ADDR
// vc_chassis := 25 ;
60094: LD_ADDR_OWVAR 37
60098: PUSH
60099: LD_INT 25
60101: ST_TO_ADDR
// vc_engine := engine_siberite ;
60102: LD_ADDR_OWVAR 39
60106: PUSH
60107: LD_INT 3
60109: ST_TO_ADDR
// vc_control := control_computer ;
60110: LD_ADDR_OWVAR 38
60114: PUSH
60115: LD_INT 3
60117: ST_TO_ADDR
// vc_weapon := 59 ;
60118: LD_ADDR_OWVAR 40
60122: PUSH
60123: LD_INT 59
60125: ST_TO_ADDR
// result := CreateVehicle ;
60126: LD_ADDR_VAR 0 5
60130: PUSH
60131: CALL_OW 45
60135: ST_TO_ADDR
// SetDir ( result , d ) ;
60136: LD_VAR 0 5
60140: PPUSH
60141: LD_VAR 0 4
60145: PPUSH
60146: CALL_OW 233
// PlaceUnitXY ( result , x , y , false ) ;
60150: LD_VAR 0 5
60154: PPUSH
60155: LD_VAR 0 2
60159: PPUSH
60160: LD_VAR 0 3
60164: PPUSH
60165: LD_INT 0
60167: PPUSH
60168: CALL_OW 48
// end ;
60172: LD_VAR 0 5
60176: RET
// export function GetMultiCargo ( cargo ) ; var i , tmp ; begin
60177: LD_INT 0
60179: PPUSH
60180: PPUSH
60181: PPUSH
// result := [ 0 , 0 , 0 , 0 ] ;
60182: LD_ADDR_VAR 0 2
60186: PUSH
60187: LD_INT 0
60189: PUSH
60190: LD_INT 0
60192: PUSH
60193: LD_INT 0
60195: PUSH
60196: LD_INT 0
60198: PUSH
60199: EMPTY
60200: LIST
60201: LIST
60202: LIST
60203: LIST
60204: ST_TO_ADDR
// if not cargo or not GetWeapon ( cargo ) in [ us_cargo_bay , ru_cargo_bay , ar_cargo_bay , ru_big_cargo_bay ] then
60205: LD_VAR 0 1
60209: NOT
60210: PUSH
60211: LD_VAR 0 1
60215: PPUSH
60216: CALL_OW 264
60220: PUSH
60221: LD_INT 12
60223: PUSH
60224: LD_INT 51
60226: PUSH
60227: LD_INT 32
60229: PUSH
60230: LD_EXP 159
60234: PUSH
60235: EMPTY
60236: LIST
60237: LIST
60238: LIST
60239: LIST
60240: IN
60241: NOT
60242: OR
60243: IFFALSE 60247
// exit ;
60245: GO 60345
// for i := 1 to 3 do
60247: LD_ADDR_VAR 0 3
60251: PUSH
60252: DOUBLE
60253: LD_INT 1
60255: DEC
60256: ST_TO_ADDR
60257: LD_INT 3
60259: PUSH
60260: FOR_TO
60261: IFFALSE 60343
// begin tmp := GetCargo ( cargo , i ) ;
60263: LD_ADDR_VAR 0 4
60267: PUSH
60268: LD_VAR 0 1
60272: PPUSH
60273: LD_VAR 0 3
60277: PPUSH
60278: CALL_OW 289
60282: ST_TO_ADDR
// result := Replace ( result , i , tmp ) ;
60283: LD_ADDR_VAR 0 2
60287: PUSH
60288: LD_VAR 0 2
60292: PPUSH
60293: LD_VAR 0 3
60297: PPUSH
60298: LD_VAR 0 4
60302: PPUSH
60303: CALL_OW 1
60307: ST_TO_ADDR
// result := Replace ( result , 4 , result [ 4 ] + tmp ) ;
60308: LD_ADDR_VAR 0 2
60312: PUSH
60313: LD_VAR 0 2
60317: PPUSH
60318: LD_INT 4
60320: PPUSH
60321: LD_VAR 0 2
60325: PUSH
60326: LD_INT 4
60328: ARRAY
60329: PUSH
60330: LD_VAR 0 4
60334: PLUS
60335: PPUSH
60336: CALL_OW 1
60340: ST_TO_ADDR
// end ;
60341: GO 60260
60343: POP
60344: POP
// end ;
60345: LD_VAR 0 2
60349: RET
// export function Length ( array ) ; begin
60350: LD_INT 0
60352: PPUSH
// result := array + 0 ;
60353: LD_ADDR_VAR 0 2
60357: PUSH
60358: LD_VAR 0 1
60362: PUSH
60363: LD_INT 0
60365: PLUS
60366: ST_TO_ADDR
// end ;
60367: LD_VAR 0 2
60371: RET
// export function PrepareArray ( array ) ; begin
60372: LD_INT 0
60374: PPUSH
// result := array diff 0 ;
60375: LD_ADDR_VAR 0 2
60379: PUSH
60380: LD_VAR 0 1
60384: PUSH
60385: LD_INT 0
60387: DIFF
60388: ST_TO_ADDR
// if not result [ 1 ] then
60389: LD_VAR 0 2
60393: PUSH
60394: LD_INT 1
60396: ARRAY
60397: NOT
60398: IFFALSE 60418
// result := Delete ( result , 1 ) ;
60400: LD_ADDR_VAR 0 2
60404: PUSH
60405: LD_VAR 0 2
60409: PPUSH
60410: LD_INT 1
60412: PPUSH
60413: CALL_OW 3
60417: ST_TO_ADDR
// end ; end_of_file
60418: LD_VAR 0 2
60422: RET
// export function SOS_UnitDestroyed ( un ) ; var i , eff , side ; begin
60423: LD_INT 0
60425: PPUSH
60426: PPUSH
60427: PPUSH
60428: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
60429: LD_VAR 0 1
60433: PPUSH
60434: CALL_OW 264
60438: PUSH
60439: LD_EXP 162
60443: EQUAL
60444: IFFALSE 60516
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
60446: LD_INT 68
60448: PPUSH
60449: LD_VAR 0 1
60453: PPUSH
60454: CALL_OW 255
60458: PPUSH
60459: CALL_OW 321
60463: PUSH
60464: LD_INT 2
60466: EQUAL
60467: IFFALSE 60479
// eff := 70 else
60469: LD_ADDR_VAR 0 4
60473: PUSH
60474: LD_INT 70
60476: ST_TO_ADDR
60477: GO 60487
// eff := 30 ;
60479: LD_ADDR_VAR 0 4
60483: PUSH
60484: LD_INT 30
60486: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
60487: LD_VAR 0 1
60491: PPUSH
60492: CALL_OW 250
60496: PPUSH
60497: LD_VAR 0 1
60501: PPUSH
60502: CALL_OW 251
60506: PPUSH
60507: LD_VAR 0 4
60511: PPUSH
60512: CALL_OW 495
// end ; end ;
60516: LD_VAR 0 2
60520: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
60521: LD_INT 0
60523: PPUSH
// end ;
60524: LD_VAR 0 4
60528: RET
// export function SOS_Command ( cmd ) ; begin
60529: LD_INT 0
60531: PPUSH
// end ;
60532: LD_VAR 0 2
60536: RET
// export function SOS_CommandUnitXY ( cmd , un , target , x , y ) ; begin
60537: LD_INT 0
60539: PPUSH
// end ;
60540: LD_VAR 0 6
60544: RET
// export function SOS_VehicleConstructed ( vehicle , factory ) ; var driver ; begin
60545: LD_INT 0
60547: PPUSH
60548: PPUSH
// if not vehicle or not factory then
60549: LD_VAR 0 1
60553: NOT
60554: PUSH
60555: LD_VAR 0 2
60559: NOT
60560: OR
60561: IFFALSE 60565
// exit ;
60563: GO 60796
// if factoryWaypoints >= factory then
60565: LD_EXP 155
60569: PUSH
60570: LD_VAR 0 2
60574: GREATEREQUAL
60575: IFFALSE 60796
// if factoryWaypoints [ factory ] then
60577: LD_EXP 155
60581: PUSH
60582: LD_VAR 0 2
60586: ARRAY
60587: IFFALSE 60796
// begin if GetControl ( vehicle ) = control_manual then
60589: LD_VAR 0 1
60593: PPUSH
60594: CALL_OW 263
60598: PUSH
60599: LD_INT 1
60601: EQUAL
60602: IFFALSE 60683
// begin driver := IsDrivenBy ( vehicle ) ;
60604: LD_ADDR_VAR 0 4
60608: PUSH
60609: LD_VAR 0 1
60613: PPUSH
60614: CALL_OW 311
60618: ST_TO_ADDR
// AddComMoveXY ( driver , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
60619: LD_VAR 0 4
60623: PPUSH
60624: LD_EXP 155
60628: PUSH
60629: LD_VAR 0 2
60633: ARRAY
60634: PUSH
60635: LD_INT 3
60637: ARRAY
60638: PPUSH
60639: LD_EXP 155
60643: PUSH
60644: LD_VAR 0 2
60648: ARRAY
60649: PUSH
60650: LD_INT 4
60652: ARRAY
60653: PPUSH
60654: CALL_OW 171
// AddComExitVehicle ( driver ) ;
60658: LD_VAR 0 4
60662: PPUSH
60663: CALL_OW 181
// AddComEnterUnit ( driver , factory ) ;
60667: LD_VAR 0 4
60671: PPUSH
60672: LD_VAR 0 2
60676: PPUSH
60677: CALL_OW 180
// end else
60681: GO 60796
// if GetControl ( vehicle ) = control_remote then
60683: LD_VAR 0 1
60687: PPUSH
60688: CALL_OW 263
60692: PUSH
60693: LD_INT 2
60695: EQUAL
60696: IFFALSE 60757
// begin wait ( 0 0$2 ) ;
60698: LD_INT 70
60700: PPUSH
60701: CALL_OW 67
// if Connect ( vehicle ) then
60705: LD_VAR 0 1
60709: PPUSH
60710: CALL 27334 0 1
60714: IFFALSE 60755
// AddComMoveXY ( vehicle , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
60716: LD_VAR 0 1
60720: PPUSH
60721: LD_EXP 155
60725: PUSH
60726: LD_VAR 0 2
60730: ARRAY
60731: PUSH
60732: LD_INT 3
60734: ARRAY
60735: PPUSH
60736: LD_EXP 155
60740: PUSH
60741: LD_VAR 0 2
60745: ARRAY
60746: PUSH
60747: LD_INT 4
60749: ARRAY
60750: PPUSH
60751: CALL_OW 171
// end else
60755: GO 60796
// AddComMoveXY ( vehicle , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
60757: LD_VAR 0 1
60761: PPUSH
60762: LD_EXP 155
60766: PUSH
60767: LD_VAR 0 2
60771: ARRAY
60772: PUSH
60773: LD_INT 3
60775: ARRAY
60776: PPUSH
60777: LD_EXP 155
60781: PUSH
60782: LD_VAR 0 2
60786: ARRAY
60787: PUSH
60788: LD_INT 4
60790: ARRAY
60791: PPUSH
60792: CALL_OW 171
// end ; end ;
60796: LD_VAR 0 3
60800: RET
// export function SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; begin
60801: LD_INT 0
60803: PPUSH
// if cmd = 250 and GetWeapon ( unit ) = ar_miner then
60804: LD_VAR 0 1
60808: PUSH
60809: LD_INT 250
60811: EQUAL
60812: PUSH
60813: LD_VAR 0 2
60817: PPUSH
60818: CALL_OW 264
60822: PUSH
60823: LD_EXP 165
60827: EQUAL
60828: AND
60829: IFFALSE 60850
// MinerPlaceMine ( unit , x , y ) ;
60831: LD_VAR 0 2
60835: PPUSH
60836: LD_VAR 0 4
60840: PPUSH
60841: LD_VAR 0 5
60845: PPUSH
60846: CALL 63249 0 3
// if cmd = 251 and GetWeapon ( unit ) = ar_miner then
60850: LD_VAR 0 1
60854: PUSH
60855: LD_INT 251
60857: EQUAL
60858: PUSH
60859: LD_VAR 0 2
60863: PPUSH
60864: CALL_OW 264
60868: PUSH
60869: LD_EXP 165
60873: EQUAL
60874: AND
60875: IFFALSE 60896
// MinerDetonateMine ( unit , x , y ) ;
60877: LD_VAR 0 2
60881: PPUSH
60882: LD_VAR 0 4
60886: PPUSH
60887: LD_VAR 0 5
60891: PPUSH
60892: CALL 63526 0 3
// if cmd = 252 and GetWeapon ( unit ) = ar_miner then
60896: LD_VAR 0 1
60900: PUSH
60901: LD_INT 252
60903: EQUAL
60904: PUSH
60905: LD_VAR 0 2
60909: PPUSH
60910: CALL_OW 264
60914: PUSH
60915: LD_EXP 165
60919: EQUAL
60920: AND
60921: IFFALSE 60942
// MinerCreateMinefield ( unit , x , y ) ;
60923: LD_VAR 0 2
60927: PPUSH
60928: LD_VAR 0 4
60932: PPUSH
60933: LD_VAR 0 5
60937: PPUSH
60938: CALL 63943 0 3
// if cmd = 253 and GetClass ( unit ) = class_sniper then
60942: LD_VAR 0 1
60946: PUSH
60947: LD_INT 253
60949: EQUAL
60950: PUSH
60951: LD_VAR 0 2
60955: PPUSH
60956: CALL_OW 257
60960: PUSH
60961: LD_INT 5
60963: EQUAL
60964: AND
60965: IFFALSE 60986
// ComBinocular ( unit , x , y ) ;
60967: LD_VAR 0 2
60971: PPUSH
60972: LD_VAR 0 4
60976: PPUSH
60977: LD_VAR 0 5
60981: PPUSH
60982: CALL 64314 0 3
// if cmd = 254 and GetWeapon ( unit ) = us_hack and GetControl ( selectedUnit ) = control_computer then
60986: LD_VAR 0 1
60990: PUSH
60991: LD_INT 254
60993: EQUAL
60994: PUSH
60995: LD_VAR 0 2
60999: PPUSH
61000: CALL_OW 264
61004: PUSH
61005: LD_EXP 160
61009: EQUAL
61010: AND
61011: PUSH
61012: LD_VAR 0 3
61016: PPUSH
61017: CALL_OW 263
61021: PUSH
61022: LD_INT 3
61024: EQUAL
61025: AND
61026: IFFALSE 61042
// HackDestroyVehicle ( unit , selectedUnit ) ;
61028: LD_VAR 0 2
61032: PPUSH
61033: LD_VAR 0 3
61037: PPUSH
61038: CALL 62609 0 2
// if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
61042: LD_VAR 0 1
61046: PUSH
61047: LD_INT 255
61049: EQUAL
61050: PUSH
61051: LD_VAR 0 2
61055: PPUSH
61056: CALL_OW 264
61060: PUSH
61061: LD_INT 14
61063: PUSH
61064: LD_INT 53
61066: PUSH
61067: EMPTY
61068: LIST
61069: LIST
61070: IN
61071: AND
61072: PUSH
61073: LD_VAR 0 4
61077: PPUSH
61078: LD_VAR 0 5
61082: PPUSH
61083: CALL_OW 488
61087: AND
61088: IFFALSE 61112
// CutTreeXYR ( unit , x , y , 12 ) ;
61090: LD_VAR 0 2
61094: PPUSH
61095: LD_VAR 0 4
61099: PPUSH
61100: LD_VAR 0 5
61104: PPUSH
61105: LD_INT 12
61107: PPUSH
61108: CALL 61175 0 4
// if cmd = 256 then
61112: LD_VAR 0 1
61116: PUSH
61117: LD_INT 256
61119: EQUAL
61120: IFFALSE 61141
// SetFactoryWaypoint ( unit , x , y ) ;
61122: LD_VAR 0 2
61126: PPUSH
61127: LD_VAR 0 4
61131: PPUSH
61132: LD_VAR 0 5
61136: PPUSH
61137: CALL 79072 0 3
// if cmd = 257 then
61141: LD_VAR 0 1
61145: PUSH
61146: LD_INT 257
61148: EQUAL
61149: IFFALSE 61170
// SetWarehouseGatheringPoint ( unit , x , y ) ;
61151: LD_VAR 0 2
61155: PPUSH
61156: LD_VAR 0 4
61160: PPUSH
61161: LD_VAR 0 5
61165: PPUSH
61166: CALL 79434 0 3
// end ;
61170: LD_VAR 0 6
61174: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
61175: LD_INT 0
61177: PPUSH
61178: PPUSH
61179: PPUSH
61180: PPUSH
61181: PPUSH
61182: PPUSH
61183: PPUSH
61184: PPUSH
61185: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
61186: LD_VAR 0 1
61190: NOT
61191: PUSH
61192: LD_VAR 0 2
61196: PPUSH
61197: LD_VAR 0 3
61201: PPUSH
61202: CALL_OW 488
61206: NOT
61207: OR
61208: PUSH
61209: LD_VAR 0 4
61213: NOT
61214: OR
61215: IFFALSE 61219
// exit ;
61217: GO 61559
// list := [ ] ;
61219: LD_ADDR_VAR 0 13
61223: PUSH
61224: EMPTY
61225: ST_TO_ADDR
// if x - r < 0 then
61226: LD_VAR 0 2
61230: PUSH
61231: LD_VAR 0 4
61235: MINUS
61236: PUSH
61237: LD_INT 0
61239: LESS
61240: IFFALSE 61252
// min_x := 0 else
61242: LD_ADDR_VAR 0 7
61246: PUSH
61247: LD_INT 0
61249: ST_TO_ADDR
61250: GO 61268
// min_x := x - r ;
61252: LD_ADDR_VAR 0 7
61256: PUSH
61257: LD_VAR 0 2
61261: PUSH
61262: LD_VAR 0 4
61266: MINUS
61267: ST_TO_ADDR
// if y - r < 0 then
61268: LD_VAR 0 3
61272: PUSH
61273: LD_VAR 0 4
61277: MINUS
61278: PUSH
61279: LD_INT 0
61281: LESS
61282: IFFALSE 61294
// min_y := 0 else
61284: LD_ADDR_VAR 0 8
61288: PUSH
61289: LD_INT 0
61291: ST_TO_ADDR
61292: GO 61310
// min_y := y - r ;
61294: LD_ADDR_VAR 0 8
61298: PUSH
61299: LD_VAR 0 3
61303: PUSH
61304: LD_VAR 0 4
61308: MINUS
61309: ST_TO_ADDR
// max_x := x + r ;
61310: LD_ADDR_VAR 0 9
61314: PUSH
61315: LD_VAR 0 2
61319: PUSH
61320: LD_VAR 0 4
61324: PLUS
61325: ST_TO_ADDR
// max_y := y + r ;
61326: LD_ADDR_VAR 0 10
61330: PUSH
61331: LD_VAR 0 3
61335: PUSH
61336: LD_VAR 0 4
61340: PLUS
61341: ST_TO_ADDR
// for _x = min_x to max_x do
61342: LD_ADDR_VAR 0 11
61346: PUSH
61347: DOUBLE
61348: LD_VAR 0 7
61352: DEC
61353: ST_TO_ADDR
61354: LD_VAR 0 9
61358: PUSH
61359: FOR_TO
61360: IFFALSE 61477
// for _y = min_y to max_y do
61362: LD_ADDR_VAR 0 12
61366: PUSH
61367: DOUBLE
61368: LD_VAR 0 8
61372: DEC
61373: ST_TO_ADDR
61374: LD_VAR 0 10
61378: PUSH
61379: FOR_TO
61380: IFFALSE 61473
// begin if not ValidHex ( _x , _y ) then
61382: LD_VAR 0 11
61386: PPUSH
61387: LD_VAR 0 12
61391: PPUSH
61392: CALL_OW 488
61396: NOT
61397: IFFALSE 61401
// continue ;
61399: GO 61379
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
61401: LD_VAR 0 11
61405: PPUSH
61406: LD_VAR 0 12
61410: PPUSH
61411: CALL_OW 351
61415: PUSH
61416: LD_VAR 0 11
61420: PPUSH
61421: LD_VAR 0 12
61425: PPUSH
61426: CALL_OW 554
61430: AND
61431: IFFALSE 61471
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
61433: LD_ADDR_VAR 0 13
61437: PUSH
61438: LD_VAR 0 13
61442: PPUSH
61443: LD_VAR 0 13
61447: PUSH
61448: LD_INT 1
61450: PLUS
61451: PPUSH
61452: LD_VAR 0 11
61456: PUSH
61457: LD_VAR 0 12
61461: PUSH
61462: EMPTY
61463: LIST
61464: LIST
61465: PPUSH
61466: CALL_OW 2
61470: ST_TO_ADDR
// end ;
61471: GO 61379
61473: POP
61474: POP
61475: GO 61359
61477: POP
61478: POP
// if not list then
61479: LD_VAR 0 13
61483: NOT
61484: IFFALSE 61488
// exit ;
61486: GO 61559
// for i in list do
61488: LD_ADDR_VAR 0 6
61492: PUSH
61493: LD_VAR 0 13
61497: PUSH
61498: FOR_IN
61499: IFFALSE 61557
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
61501: LD_VAR 0 1
61505: PPUSH
61506: LD_STRING M
61508: PUSH
61509: LD_VAR 0 6
61513: PUSH
61514: LD_INT 1
61516: ARRAY
61517: PUSH
61518: LD_VAR 0 6
61522: PUSH
61523: LD_INT 2
61525: ARRAY
61526: PUSH
61527: LD_INT 0
61529: PUSH
61530: LD_INT 0
61532: PUSH
61533: LD_INT 0
61535: PUSH
61536: LD_INT 0
61538: PUSH
61539: EMPTY
61540: LIST
61541: LIST
61542: LIST
61543: LIST
61544: LIST
61545: LIST
61546: LIST
61547: PUSH
61548: EMPTY
61549: LIST
61550: PPUSH
61551: CALL_OW 447
61555: GO 61498
61557: POP
61558: POP
// end ;
61559: LD_VAR 0 5
61563: RET
// export initHack , hackTanks , hackTanksCaptured , hackLimit , hackDist , hackCounter ; every 0 0$1 trigger not initHack do
61564: LD_EXP 87
61568: NOT
61569: IFFALSE 61619
61571: GO 61573
61573: DISABLE
// begin initHack := true ;
61574: LD_ADDR_EXP 87
61578: PUSH
61579: LD_INT 1
61581: ST_TO_ADDR
// hackTanks := [ ] ;
61582: LD_ADDR_EXP 88
61586: PUSH
61587: EMPTY
61588: ST_TO_ADDR
// hackTanksCaptured := [ ] ;
61589: LD_ADDR_EXP 89
61593: PUSH
61594: EMPTY
61595: ST_TO_ADDR
// hackLimit := 3 ;
61596: LD_ADDR_EXP 90
61600: PUSH
61601: LD_INT 3
61603: ST_TO_ADDR
// hackDist := 12 ;
61604: LD_ADDR_EXP 91
61608: PUSH
61609: LD_INT 12
61611: ST_TO_ADDR
// hackCounter := [ ] ;
61612: LD_ADDR_EXP 92
61616: PUSH
61617: EMPTY
61618: ST_TO_ADDR
// end ;
61619: END
// every 0 0$1 trigger initHack and FilterAllUnits ( [ f_weapon , us_hack ] ) do var i , tmp ;
61620: LD_EXP 87
61624: PUSH
61625: LD_INT 34
61627: PUSH
61628: LD_EXP 160
61632: PUSH
61633: EMPTY
61634: LIST
61635: LIST
61636: PPUSH
61637: CALL_OW 69
61641: AND
61642: IFFALSE 61897
61644: GO 61646
61646: DISABLE
61647: LD_INT 0
61649: PPUSH
61650: PPUSH
// begin enable ;
61651: ENABLE
// for i in FilterAllUnits ( [ f_weapon , us_hack ] ) do
61652: LD_ADDR_VAR 0 1
61656: PUSH
61657: LD_INT 34
61659: PUSH
61660: LD_EXP 160
61664: PUSH
61665: EMPTY
61666: LIST
61667: LIST
61668: PPUSH
61669: CALL_OW 69
61673: PUSH
61674: FOR_IN
61675: IFFALSE 61895
// begin if not i in hackTanks then
61677: LD_VAR 0 1
61681: PUSH
61682: LD_EXP 88
61686: IN
61687: NOT
61688: IFFALSE 61771
// begin hackTanks := Replace ( hackTanks , hackTanks + 1 , i ) ;
61690: LD_ADDR_EXP 88
61694: PUSH
61695: LD_EXP 88
61699: PPUSH
61700: LD_EXP 88
61704: PUSH
61705: LD_INT 1
61707: PLUS
61708: PPUSH
61709: LD_VAR 0 1
61713: PPUSH
61714: CALL_OW 1
61718: ST_TO_ADDR
// hackTanksCaptured := Replace ( hackTanksCaptured , hackTanksCaptured + 1 , [ ] ) ;
61719: LD_ADDR_EXP 89
61723: PUSH
61724: LD_EXP 89
61728: PPUSH
61729: LD_EXP 89
61733: PUSH
61734: LD_INT 1
61736: PLUS
61737: PPUSH
61738: EMPTY
61739: PPUSH
61740: CALL_OW 1
61744: ST_TO_ADDR
// hackCounter := Replace ( hackCounter , hackCounter + 1 , [ ] ) ;
61745: LD_ADDR_EXP 92
61749: PUSH
61750: LD_EXP 92
61754: PPUSH
61755: LD_EXP 92
61759: PUSH
61760: LD_INT 1
61762: PLUS
61763: PPUSH
61764: EMPTY
61765: PPUSH
61766: CALL_OW 1
61770: ST_TO_ADDR
// end ; if not IsOk ( i ) then
61771: LD_VAR 0 1
61775: PPUSH
61776: CALL_OW 302
61780: NOT
61781: IFFALSE 61794
// begin HackUnlinkAll ( i ) ;
61783: LD_VAR 0 1
61787: PPUSH
61788: CALL 61900 0 1
// continue ;
61792: GO 61674
// end ; HackCheckCapturedStatus ( i ) ;
61794: LD_VAR 0 1
61798: PPUSH
61799: CALL 62343 0 1
// tmp := FilterAllUnits ( [ [ f_enemy , GetSide ( i ) ] , [ f_control , control_computer ] , [ f_dist , i , hackDist ] , [ f_ok ] ] ) ;
61803: LD_ADDR_VAR 0 2
61807: PUSH
61808: LD_INT 81
61810: PUSH
61811: LD_VAR 0 1
61815: PPUSH
61816: CALL_OW 255
61820: PUSH
61821: EMPTY
61822: LIST
61823: LIST
61824: PUSH
61825: LD_INT 33
61827: PUSH
61828: LD_INT 3
61830: PUSH
61831: EMPTY
61832: LIST
61833: LIST
61834: PUSH
61835: LD_INT 91
61837: PUSH
61838: LD_VAR 0 1
61842: PUSH
61843: LD_EXP 91
61847: PUSH
61848: EMPTY
61849: LIST
61850: LIST
61851: LIST
61852: PUSH
61853: LD_INT 50
61855: PUSH
61856: EMPTY
61857: LIST
61858: PUSH
61859: EMPTY
61860: LIST
61861: LIST
61862: LIST
61863: LIST
61864: PPUSH
61865: CALL_OW 69
61869: ST_TO_ADDR
// if not tmp then
61870: LD_VAR 0 2
61874: NOT
61875: IFFALSE 61879
// continue ;
61877: GO 61674
// HackLink ( i , tmp ) ;
61879: LD_VAR 0 1
61883: PPUSH
61884: LD_VAR 0 2
61888: PPUSH
61889: CALL 62036 0 2
// end ;
61893: GO 61674
61895: POP
61896: POP
// end ;
61897: PPOPN 2
61899: END
// function HackUnlinkAll ( hack ) ; var i , index ; begin
61900: LD_INT 0
61902: PPUSH
61903: PPUSH
61904: PPUSH
// if not hack in hackTanks then
61905: LD_VAR 0 1
61909: PUSH
61910: LD_EXP 88
61914: IN
61915: NOT
61916: IFFALSE 61920
// exit ;
61918: GO 62031
// index := GetElementIndex ( hackTanks , hack ) ;
61920: LD_ADDR_VAR 0 4
61924: PUSH
61925: LD_EXP 88
61929: PPUSH
61930: LD_VAR 0 1
61934: PPUSH
61935: CALL 24148 0 2
61939: ST_TO_ADDR
// if hackTanksCaptured [ index ] then
61940: LD_EXP 89
61944: PUSH
61945: LD_VAR 0 4
61949: ARRAY
61950: IFFALSE 62031
// begin for i in hackTanksCaptured [ index ] do
61952: LD_ADDR_VAR 0 3
61956: PUSH
61957: LD_EXP 89
61961: PUSH
61962: LD_VAR 0 4
61966: ARRAY
61967: PUSH
61968: FOR_IN
61969: IFFALSE 61995
// SetSide ( i [ 1 ] , i [ 2 ] ) ;
61971: LD_VAR 0 3
61975: PUSH
61976: LD_INT 1
61978: ARRAY
61979: PPUSH
61980: LD_VAR 0 3
61984: PUSH
61985: LD_INT 2
61987: ARRAY
61988: PPUSH
61989: CALL_OW 235
61993: GO 61968
61995: POP
61996: POP
// hackTanksCaptured := Replace ( hackTanksCaptured , index , [ ] ) ;
61997: LD_ADDR_EXP 89
62001: PUSH
62002: LD_EXP 89
62006: PPUSH
62007: LD_VAR 0 4
62011: PPUSH
62012: EMPTY
62013: PPUSH
62014: CALL_OW 1
62018: ST_TO_ADDR
// SetUnitDisplayNumber ( hack , 0 ) ;
62019: LD_VAR 0 1
62023: PPUSH
62024: LD_INT 0
62026: PPUSH
62027: CALL_OW 505
// end ; end ;
62031: LD_VAR 0 2
62035: RET
// function HackLink ( hack , vehicles ) ; var i , index ; begin
62036: LD_INT 0
62038: PPUSH
62039: PPUSH
62040: PPUSH
// if not hack in hackTanks or not vehicles then
62041: LD_VAR 0 1
62045: PUSH
62046: LD_EXP 88
62050: IN
62051: NOT
62052: PUSH
62053: LD_VAR 0 2
62057: NOT
62058: OR
62059: IFFALSE 62063
// exit ;
62061: GO 62338
// vehicles := SortByDistanceUnit ( hack , vehicles , true , true ) ;
62063: LD_ADDR_VAR 0 2
62067: PUSH
62068: LD_VAR 0 1
62072: PPUSH
62073: LD_VAR 0 2
62077: PPUSH
62078: LD_INT 1
62080: PPUSH
62081: LD_INT 1
62083: PPUSH
62084: CALL 24798 0 4
62088: ST_TO_ADDR
// index := GetElementIndex ( hackTanks , hack ) ;
62089: LD_ADDR_VAR 0 5
62093: PUSH
62094: LD_EXP 88
62098: PPUSH
62099: LD_VAR 0 1
62103: PPUSH
62104: CALL 24148 0 2
62108: ST_TO_ADDR
// if hackTanksCaptured [ index ] < hackLimit then
62109: LD_EXP 89
62113: PUSH
62114: LD_VAR 0 5
62118: ARRAY
62119: PUSH
62120: LD_EXP 90
62124: LESS
62125: IFFALSE 62314
// begin for i := 1 to vehicles do
62127: LD_ADDR_VAR 0 4
62131: PUSH
62132: DOUBLE
62133: LD_INT 1
62135: DEC
62136: ST_TO_ADDR
62137: LD_VAR 0 2
62141: PUSH
62142: FOR_TO
62143: IFFALSE 62312
// begin if hackTanksCaptured [ index ] = hackLimit then
62145: LD_EXP 89
62149: PUSH
62150: LD_VAR 0 5
62154: ARRAY
62155: PUSH
62156: LD_EXP 90
62160: EQUAL
62161: IFFALSE 62165
// break ;
62163: GO 62312
// hackCounter := Replace ( hackCounter , index , hackCounter [ index ] + 1 ) ;
62165: LD_ADDR_EXP 92
62169: PUSH
62170: LD_EXP 92
62174: PPUSH
62175: LD_VAR 0 5
62179: PPUSH
62180: LD_EXP 92
62184: PUSH
62185: LD_VAR 0 5
62189: ARRAY
62190: PUSH
62191: LD_INT 1
62193: PLUS
62194: PPUSH
62195: CALL_OW 1
62199: ST_TO_ADDR
// hackTanksCaptured := ReplaceIn ( hackTanksCaptured , [ index , hackTanksCaptured [ index ] + 1 ] , [ vehicles [ i ] , GetSide ( vehicles [ i ] ) ] ) ;
62200: LD_ADDR_EXP 89
62204: PUSH
62205: LD_EXP 89
62209: PPUSH
62210: LD_VAR 0 5
62214: PUSH
62215: LD_EXP 89
62219: PUSH
62220: LD_VAR 0 5
62224: ARRAY
62225: PUSH
62226: LD_INT 1
62228: PLUS
62229: PUSH
62230: EMPTY
62231: LIST
62232: LIST
62233: PPUSH
62234: LD_VAR 0 2
62238: PUSH
62239: LD_VAR 0 4
62243: ARRAY
62244: PUSH
62245: LD_VAR 0 2
62249: PUSH
62250: LD_VAR 0 4
62254: ARRAY
62255: PPUSH
62256: CALL_OW 255
62260: PUSH
62261: EMPTY
62262: LIST
62263: LIST
62264: PPUSH
62265: CALL 24363 0 3
62269: ST_TO_ADDR
// SetSide ( vehicles [ i ] , GetSide ( hack ) ) ;
62270: LD_VAR 0 2
62274: PUSH
62275: LD_VAR 0 4
62279: ARRAY
62280: PPUSH
62281: LD_VAR 0 1
62285: PPUSH
62286: CALL_OW 255
62290: PPUSH
62291: CALL_OW 235
// ComStop ( vehicles [ i ] ) ;
62295: LD_VAR 0 2
62299: PUSH
62300: LD_VAR 0 4
62304: ARRAY
62305: PPUSH
62306: CALL_OW 141
// end ;
62310: GO 62142
62312: POP
62313: POP
// end ; SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
62314: LD_VAR 0 1
62318: PPUSH
62319: LD_EXP 89
62323: PUSH
62324: LD_VAR 0 5
62328: ARRAY
62329: PUSH
62330: LD_INT 0
62332: PLUS
62333: PPUSH
62334: CALL_OW 505
// end ;
62338: LD_VAR 0 3
62342: RET
// function HackCheckCapturedStatus ( hack ) ; var i , index , tmp ; begin
62343: LD_INT 0
62345: PPUSH
62346: PPUSH
62347: PPUSH
62348: PPUSH
// if not hack in hackTanks then
62349: LD_VAR 0 1
62353: PUSH
62354: LD_EXP 88
62358: IN
62359: NOT
62360: IFFALSE 62364
// exit ;
62362: GO 62604
// index := GetElementIndex ( hackTanks , hack ) ;
62364: LD_ADDR_VAR 0 4
62368: PUSH
62369: LD_EXP 88
62373: PPUSH
62374: LD_VAR 0 1
62378: PPUSH
62379: CALL 24148 0 2
62383: ST_TO_ADDR
// for i := hackTanksCaptured [ index ] downto 1 do
62384: LD_ADDR_VAR 0 3
62388: PUSH
62389: DOUBLE
62390: LD_EXP 89
62394: PUSH
62395: LD_VAR 0 4
62399: ARRAY
62400: INC
62401: ST_TO_ADDR
62402: LD_INT 1
62404: PUSH
62405: FOR_DOWNTO
62406: IFFALSE 62578
// begin tmp := hackTanksCaptured [ index ] [ i ] ;
62408: LD_ADDR_VAR 0 5
62412: PUSH
62413: LD_EXP 89
62417: PUSH
62418: LD_VAR 0 4
62422: ARRAY
62423: PUSH
62424: LD_VAR 0 3
62428: ARRAY
62429: ST_TO_ADDR
// if not IsOk ( tmp [ 1 ] ) or GetSide ( tmp [ 1 ] ) <> GetSide ( hack ) then
62430: LD_VAR 0 5
62434: PUSH
62435: LD_INT 1
62437: ARRAY
62438: PPUSH
62439: CALL_OW 302
62443: NOT
62444: PUSH
62445: LD_VAR 0 5
62449: PUSH
62450: LD_INT 1
62452: ARRAY
62453: PPUSH
62454: CALL_OW 255
62458: PUSH
62459: LD_VAR 0 1
62463: PPUSH
62464: CALL_OW 255
62468: NONEQUAL
62469: OR
62470: IFFALSE 62576
// begin if IsPlaced ( tmp [ 1 ] ) and GetSide ( tmp [ 1 ] ) = GetSide ( hack ) then
62472: LD_VAR 0 5
62476: PUSH
62477: LD_INT 1
62479: ARRAY
62480: PPUSH
62481: CALL_OW 305
62485: PUSH
62486: LD_VAR 0 5
62490: PUSH
62491: LD_INT 1
62493: ARRAY
62494: PPUSH
62495: CALL_OW 255
62499: PUSH
62500: LD_VAR 0 1
62504: PPUSH
62505: CALL_OW 255
62509: EQUAL
62510: AND
62511: IFFALSE 62535
// SetSide ( tmp [ 1 ] , tmp [ 2 ] ) ;
62513: LD_VAR 0 5
62517: PUSH
62518: LD_INT 1
62520: ARRAY
62521: PPUSH
62522: LD_VAR 0 5
62526: PUSH
62527: LD_INT 2
62529: ARRAY
62530: PPUSH
62531: CALL_OW 235
// hackTanksCaptured := Replace ( hackTanksCaptured , index , Delete ( hackTanksCaptured [ index ] , i ) ) ;
62535: LD_ADDR_EXP 89
62539: PUSH
62540: LD_EXP 89
62544: PPUSH
62545: LD_VAR 0 4
62549: PPUSH
62550: LD_EXP 89
62554: PUSH
62555: LD_VAR 0 4
62559: ARRAY
62560: PPUSH
62561: LD_VAR 0 3
62565: PPUSH
62566: CALL_OW 3
62570: PPUSH
62571: CALL_OW 1
62575: ST_TO_ADDR
// end ; end ;
62576: GO 62405
62578: POP
62579: POP
// SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
62580: LD_VAR 0 1
62584: PPUSH
62585: LD_EXP 89
62589: PUSH
62590: LD_VAR 0 4
62594: ARRAY
62595: PUSH
62596: LD_INT 0
62598: PLUS
62599: PPUSH
62600: CALL_OW 505
// end ;
62604: LD_VAR 0 2
62608: RET
// export function HackDestroyVehicle ( hack , vehicle ) ; var i , index , tmp ; begin
62609: LD_INT 0
62611: PPUSH
62612: PPUSH
62613: PPUSH
62614: PPUSH
// if not hack in hackTanks then
62615: LD_VAR 0 1
62619: PUSH
62620: LD_EXP 88
62624: IN
62625: NOT
62626: IFFALSE 62630
// exit ;
62628: GO 62715
// index := GetElementIndex ( hackTanks , hack ) ;
62630: LD_ADDR_VAR 0 5
62634: PUSH
62635: LD_EXP 88
62639: PPUSH
62640: LD_VAR 0 1
62644: PPUSH
62645: CALL 24148 0 2
62649: ST_TO_ADDR
// for i := 1 to hackTanksCaptured [ index ] do
62650: LD_ADDR_VAR 0 4
62654: PUSH
62655: DOUBLE
62656: LD_INT 1
62658: DEC
62659: ST_TO_ADDR
62660: LD_EXP 89
62664: PUSH
62665: LD_VAR 0 5
62669: ARRAY
62670: PUSH
62671: FOR_TO
62672: IFFALSE 62713
// if hackTanksCaptured [ index ] [ i ] [ 1 ] = vehicle then
62674: LD_EXP 89
62678: PUSH
62679: LD_VAR 0 5
62683: ARRAY
62684: PUSH
62685: LD_VAR 0 4
62689: ARRAY
62690: PUSH
62691: LD_INT 1
62693: ARRAY
62694: PUSH
62695: LD_VAR 0 2
62699: EQUAL
62700: IFFALSE 62711
// KillUnit ( vehicle ) ;
62702: LD_VAR 0 2
62706: PPUSH
62707: CALL_OW 66
62711: GO 62671
62713: POP
62714: POP
// end ;
62715: LD_VAR 0 3
62719: RET
// export initMiner , minersList , minerMinesList , minesLimitPerVehicle ; every 0 0$1 trigger not initMiner do
62720: LD_EXP 93
62724: NOT
62725: IFFALSE 62760
62727: GO 62729
62729: DISABLE
// begin initMiner := true ;
62730: LD_ADDR_EXP 93
62734: PUSH
62735: LD_INT 1
62737: ST_TO_ADDR
// minersList := [ ] ;
62738: LD_ADDR_EXP 94
62742: PUSH
62743: EMPTY
62744: ST_TO_ADDR
// minerMinesList := [ ] ;
62745: LD_ADDR_EXP 95
62749: PUSH
62750: EMPTY
62751: ST_TO_ADDR
// minesLimitPerVehicle := 5 ;
62752: LD_ADDR_EXP 96
62756: PUSH
62757: LD_INT 5
62759: ST_TO_ADDR
// end ;
62760: END
// every 0 0$1 trigger initMiner and FilterAllUnits ( [ f_weapon , ar_miner ] ) do var i , j , side , tmp ;
62761: LD_EXP 93
62765: PUSH
62766: LD_INT 34
62768: PUSH
62769: LD_EXP 165
62773: PUSH
62774: EMPTY
62775: LIST
62776: LIST
62777: PPUSH
62778: CALL_OW 69
62782: AND
62783: IFFALSE 63246
62785: GO 62787
62787: DISABLE
62788: LD_INT 0
62790: PPUSH
62791: PPUSH
62792: PPUSH
62793: PPUSH
// begin enable ;
62794: ENABLE
// for i in FilterAllUnits ( [ f_weapon , ar_miner ] ) do
62795: LD_ADDR_VAR 0 1
62799: PUSH
62800: LD_INT 34
62802: PUSH
62803: LD_EXP 165
62807: PUSH
62808: EMPTY
62809: LIST
62810: LIST
62811: PPUSH
62812: CALL_OW 69
62816: PUSH
62817: FOR_IN
62818: IFFALSE 62890
// begin if not i in minersList then
62820: LD_VAR 0 1
62824: PUSH
62825: LD_EXP 94
62829: IN
62830: NOT
62831: IFFALSE 62888
// begin minersList := Replace ( minersList , minersList + 1 , i ) ;
62833: LD_ADDR_EXP 94
62837: PUSH
62838: LD_EXP 94
62842: PPUSH
62843: LD_EXP 94
62847: PUSH
62848: LD_INT 1
62850: PLUS
62851: PPUSH
62852: LD_VAR 0 1
62856: PPUSH
62857: CALL_OW 1
62861: ST_TO_ADDR
// minerMinesList := Replace ( minerMinesList , minerMinesList + 1 , [ ] ) ;
62862: LD_ADDR_EXP 95
62866: PUSH
62867: LD_EXP 95
62871: PPUSH
62872: LD_EXP 95
62876: PUSH
62877: LD_INT 1
62879: PLUS
62880: PPUSH
62881: EMPTY
62882: PPUSH
62883: CALL_OW 1
62887: ST_TO_ADDR
// end end ;
62888: GO 62817
62890: POP
62891: POP
// for i := minerMinesList downto 1 do
62892: LD_ADDR_VAR 0 1
62896: PUSH
62897: DOUBLE
62898: LD_EXP 95
62902: INC
62903: ST_TO_ADDR
62904: LD_INT 1
62906: PUSH
62907: FOR_DOWNTO
62908: IFFALSE 63244
// begin if IsLive ( minersList [ i ] ) then
62910: LD_EXP 94
62914: PUSH
62915: LD_VAR 0 1
62919: ARRAY
62920: PPUSH
62921: CALL_OW 300
62925: IFFALSE 62953
// SetUnitDisplayNumber ( minersList [ i ] , minerMinesList [ i ] ) ;
62927: LD_EXP 94
62931: PUSH
62932: LD_VAR 0 1
62936: ARRAY
62937: PPUSH
62938: LD_EXP 95
62942: PUSH
62943: LD_VAR 0 1
62947: ARRAY
62948: PPUSH
62949: CALL_OW 505
// if not minerMinesList [ i ] then
62953: LD_EXP 95
62957: PUSH
62958: LD_VAR 0 1
62962: ARRAY
62963: NOT
62964: IFFALSE 62968
// continue ;
62966: GO 62907
// for j := minerMinesList [ i ] downto 1 do
62968: LD_ADDR_VAR 0 2
62972: PUSH
62973: DOUBLE
62974: LD_EXP 95
62978: PUSH
62979: LD_VAR 0 1
62983: ARRAY
62984: INC
62985: ST_TO_ADDR
62986: LD_INT 1
62988: PUSH
62989: FOR_DOWNTO
62990: IFFALSE 63240
// begin side := GetSide ( minersList [ i ] ) ;
62992: LD_ADDR_VAR 0 3
62996: PUSH
62997: LD_EXP 94
63001: PUSH
63002: LD_VAR 0 1
63006: ARRAY
63007: PPUSH
63008: CALL_OW 255
63012: ST_TO_ADDR
// tmp := HexInfo ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) ;
63013: LD_ADDR_VAR 0 4
63017: PUSH
63018: LD_EXP 95
63022: PUSH
63023: LD_VAR 0 1
63027: ARRAY
63028: PUSH
63029: LD_VAR 0 2
63033: ARRAY
63034: PUSH
63035: LD_INT 1
63037: ARRAY
63038: PPUSH
63039: LD_EXP 95
63043: PUSH
63044: LD_VAR 0 1
63048: ARRAY
63049: PUSH
63050: LD_VAR 0 2
63054: ARRAY
63055: PUSH
63056: LD_INT 2
63058: ARRAY
63059: PPUSH
63060: CALL_OW 428
63064: ST_TO_ADDR
// if not tmp then
63065: LD_VAR 0 4
63069: NOT
63070: IFFALSE 63074
// continue ;
63072: GO 62989
// if tmp in FilterAllUnits ( [ f_enemy , side ] ) and MineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) then
63074: LD_VAR 0 4
63078: PUSH
63079: LD_INT 81
63081: PUSH
63082: LD_VAR 0 3
63086: PUSH
63087: EMPTY
63088: LIST
63089: LIST
63090: PPUSH
63091: CALL_OW 69
63095: IN
63096: PUSH
63097: LD_EXP 95
63101: PUSH
63102: LD_VAR 0 1
63106: ARRAY
63107: PUSH
63108: LD_VAR 0 2
63112: ARRAY
63113: PUSH
63114: LD_INT 1
63116: ARRAY
63117: PPUSH
63118: LD_EXP 95
63122: PUSH
63123: LD_VAR 0 1
63127: ARRAY
63128: PUSH
63129: LD_VAR 0 2
63133: ARRAY
63134: PUSH
63135: LD_INT 2
63137: ARRAY
63138: PPUSH
63139: CALL_OW 458
63143: AND
63144: IFFALSE 63238
// begin LaunchMineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] , side ) ;
63146: LD_EXP 95
63150: PUSH
63151: LD_VAR 0 1
63155: ARRAY
63156: PUSH
63157: LD_VAR 0 2
63161: ARRAY
63162: PUSH
63163: LD_INT 1
63165: ARRAY
63166: PPUSH
63167: LD_EXP 95
63171: PUSH
63172: LD_VAR 0 1
63176: ARRAY
63177: PUSH
63178: LD_VAR 0 2
63182: ARRAY
63183: PUSH
63184: LD_INT 2
63186: ARRAY
63187: PPUSH
63188: LD_VAR 0 3
63192: PPUSH
63193: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , i , Delete ( minerMinesList [ i ] , j ) ) ;
63197: LD_ADDR_EXP 95
63201: PUSH
63202: LD_EXP 95
63206: PPUSH
63207: LD_VAR 0 1
63211: PPUSH
63212: LD_EXP 95
63216: PUSH
63217: LD_VAR 0 1
63221: ARRAY
63222: PPUSH
63223: LD_VAR 0 2
63227: PPUSH
63228: CALL_OW 3
63232: PPUSH
63233: CALL_OW 1
63237: ST_TO_ADDR
// end ; end ;
63238: GO 62989
63240: POP
63241: POP
// end ;
63242: GO 62907
63244: POP
63245: POP
// end ;
63246: PPOPN 4
63248: END
// export function MinerPlaceMine ( unit , x , y ) ; var index ; begin
63249: LD_INT 0
63251: PPUSH
63252: PPUSH
// result := false ;
63253: LD_ADDR_VAR 0 4
63257: PUSH
63258: LD_INT 0
63260: ST_TO_ADDR
// if not GetWeapon ( unit ) = ar_miner then
63261: LD_VAR 0 1
63265: PPUSH
63266: CALL_OW 264
63270: PUSH
63271: LD_EXP 165
63275: EQUAL
63276: NOT
63277: IFFALSE 63281
// exit ;
63279: GO 63521
// index := GetElementIndex ( minersList , unit ) ;
63281: LD_ADDR_VAR 0 5
63285: PUSH
63286: LD_EXP 94
63290: PPUSH
63291: LD_VAR 0 1
63295: PPUSH
63296: CALL 24148 0 2
63300: ST_TO_ADDR
// if minerMinesList [ index ] >= minesLimitPerVehicle then
63301: LD_EXP 95
63305: PUSH
63306: LD_VAR 0 5
63310: ARRAY
63311: PUSH
63312: LD_EXP 96
63316: GREATEREQUAL
63317: IFFALSE 63321
// exit ;
63319: GO 63521
// ComMoveXY ( unit , x , y ) ;
63321: LD_VAR 0 1
63325: PPUSH
63326: LD_VAR 0 2
63330: PPUSH
63331: LD_VAR 0 3
63335: PPUSH
63336: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
63340: LD_INT 35
63342: PPUSH
63343: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) and HasTask ( unit ) then
63347: LD_VAR 0 1
63351: PPUSH
63352: LD_VAR 0 2
63356: PPUSH
63357: LD_VAR 0 3
63361: PPUSH
63362: CALL 55417 0 3
63366: NOT
63367: PUSH
63368: LD_VAR 0 1
63372: PPUSH
63373: CALL_OW 314
63377: AND
63378: IFFALSE 63382
// exit ;
63380: GO 63521
// until HexInfo ( x , y ) = unit and not HasTask ( unit ) ;
63382: LD_VAR 0 2
63386: PPUSH
63387: LD_VAR 0 3
63391: PPUSH
63392: CALL_OW 428
63396: PUSH
63397: LD_VAR 0 1
63401: EQUAL
63402: PUSH
63403: LD_VAR 0 1
63407: PPUSH
63408: CALL_OW 314
63412: NOT
63413: AND
63414: IFFALSE 63340
// PlaySoundXY ( x , y , PlantMine ) ;
63416: LD_VAR 0 2
63420: PPUSH
63421: LD_VAR 0 3
63425: PPUSH
63426: LD_STRING PlantMine
63428: PPUSH
63429: CALL_OW 366
// PlaceMine ( x , y , GetSide ( unit ) , 0 ) ;
63433: LD_VAR 0 2
63437: PPUSH
63438: LD_VAR 0 3
63442: PPUSH
63443: LD_VAR 0 1
63447: PPUSH
63448: CALL_OW 255
63452: PPUSH
63453: LD_INT 0
63455: PPUSH
63456: CALL_OW 454
// minerMinesList := ReplaceIn ( minerMinesList , [ index , minerMinesList [ index ] + 1 ] , [ x , y ] ) ;
63460: LD_ADDR_EXP 95
63464: PUSH
63465: LD_EXP 95
63469: PPUSH
63470: LD_VAR 0 5
63474: PUSH
63475: LD_EXP 95
63479: PUSH
63480: LD_VAR 0 5
63484: ARRAY
63485: PUSH
63486: LD_INT 1
63488: PLUS
63489: PUSH
63490: EMPTY
63491: LIST
63492: LIST
63493: PPUSH
63494: LD_VAR 0 2
63498: PUSH
63499: LD_VAR 0 3
63503: PUSH
63504: EMPTY
63505: LIST
63506: LIST
63507: PPUSH
63508: CALL 24363 0 3
63512: ST_TO_ADDR
// result := true ;
63513: LD_ADDR_VAR 0 4
63517: PUSH
63518: LD_INT 1
63520: ST_TO_ADDR
// end ;
63521: LD_VAR 0 4
63525: RET
// export function MinerDetonateMine ( unit , x , y ) ; var i , index ; begin
63526: LD_INT 0
63528: PPUSH
63529: PPUSH
63530: PPUSH
// if not unit in minersList then
63531: LD_VAR 0 1
63535: PUSH
63536: LD_EXP 94
63540: IN
63541: NOT
63542: IFFALSE 63546
// exit ;
63544: GO 63938
// index := GetElementIndex ( minersList , unit ) ;
63546: LD_ADDR_VAR 0 6
63550: PUSH
63551: LD_EXP 94
63555: PPUSH
63556: LD_VAR 0 1
63560: PPUSH
63561: CALL 24148 0 2
63565: ST_TO_ADDR
// for i := minerMinesList [ index ] downto 1 do
63566: LD_ADDR_VAR 0 5
63570: PUSH
63571: DOUBLE
63572: LD_EXP 95
63576: PUSH
63577: LD_VAR 0 6
63581: ARRAY
63582: INC
63583: ST_TO_ADDR
63584: LD_INT 1
63586: PUSH
63587: FOR_DOWNTO
63588: IFFALSE 63749
// begin if minerMinesList [ index ] [ i ] [ 1 ] = x and minerMinesList [ index ] [ i ] [ 2 ] = y then
63590: LD_EXP 95
63594: PUSH
63595: LD_VAR 0 6
63599: ARRAY
63600: PUSH
63601: LD_VAR 0 5
63605: ARRAY
63606: PUSH
63607: LD_INT 1
63609: ARRAY
63610: PUSH
63611: LD_VAR 0 2
63615: EQUAL
63616: PUSH
63617: LD_EXP 95
63621: PUSH
63622: LD_VAR 0 6
63626: ARRAY
63627: PUSH
63628: LD_VAR 0 5
63632: ARRAY
63633: PUSH
63634: LD_INT 2
63636: ARRAY
63637: PUSH
63638: LD_VAR 0 3
63642: EQUAL
63643: AND
63644: IFFALSE 63747
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
63646: LD_EXP 95
63650: PUSH
63651: LD_VAR 0 6
63655: ARRAY
63656: PUSH
63657: LD_VAR 0 5
63661: ARRAY
63662: PUSH
63663: LD_INT 1
63665: ARRAY
63666: PPUSH
63667: LD_EXP 95
63671: PUSH
63672: LD_VAR 0 6
63676: ARRAY
63677: PUSH
63678: LD_VAR 0 5
63682: ARRAY
63683: PUSH
63684: LD_INT 2
63686: ARRAY
63687: PPUSH
63688: LD_VAR 0 1
63692: PPUSH
63693: CALL_OW 255
63697: PPUSH
63698: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
63702: LD_ADDR_EXP 95
63706: PUSH
63707: LD_EXP 95
63711: PPUSH
63712: LD_VAR 0 6
63716: PPUSH
63717: LD_EXP 95
63721: PUSH
63722: LD_VAR 0 6
63726: ARRAY
63727: PPUSH
63728: LD_VAR 0 5
63732: PPUSH
63733: CALL_OW 3
63737: PPUSH
63738: CALL_OW 1
63742: ST_TO_ADDR
// exit ;
63743: POP
63744: POP
63745: GO 63938
// end ; end ;
63747: GO 63587
63749: POP
63750: POP
// for i := minerMinesList [ index ] downto 1 do
63751: LD_ADDR_VAR 0 5
63755: PUSH
63756: DOUBLE
63757: LD_EXP 95
63761: PUSH
63762: LD_VAR 0 6
63766: ARRAY
63767: INC
63768: ST_TO_ADDR
63769: LD_INT 1
63771: PUSH
63772: FOR_DOWNTO
63773: IFFALSE 63936
// begin if GetDistXY ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , x , y ) < 6 then
63775: LD_EXP 95
63779: PUSH
63780: LD_VAR 0 6
63784: ARRAY
63785: PUSH
63786: LD_VAR 0 5
63790: ARRAY
63791: PUSH
63792: LD_INT 1
63794: ARRAY
63795: PPUSH
63796: LD_EXP 95
63800: PUSH
63801: LD_VAR 0 6
63805: ARRAY
63806: PUSH
63807: LD_VAR 0 5
63811: ARRAY
63812: PUSH
63813: LD_INT 2
63815: ARRAY
63816: PPUSH
63817: LD_VAR 0 2
63821: PPUSH
63822: LD_VAR 0 3
63826: PPUSH
63827: CALL_OW 298
63831: PUSH
63832: LD_INT 6
63834: LESS
63835: IFFALSE 63934
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
63837: LD_EXP 95
63841: PUSH
63842: LD_VAR 0 6
63846: ARRAY
63847: PUSH
63848: LD_VAR 0 5
63852: ARRAY
63853: PUSH
63854: LD_INT 1
63856: ARRAY
63857: PPUSH
63858: LD_EXP 95
63862: PUSH
63863: LD_VAR 0 6
63867: ARRAY
63868: PUSH
63869: LD_VAR 0 5
63873: ARRAY
63874: PUSH
63875: LD_INT 2
63877: ARRAY
63878: PPUSH
63879: LD_VAR 0 1
63883: PPUSH
63884: CALL_OW 255
63888: PPUSH
63889: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
63893: LD_ADDR_EXP 95
63897: PUSH
63898: LD_EXP 95
63902: PPUSH
63903: LD_VAR 0 6
63907: PPUSH
63908: LD_EXP 95
63912: PUSH
63913: LD_VAR 0 6
63917: ARRAY
63918: PPUSH
63919: LD_VAR 0 5
63923: PPUSH
63924: CALL_OW 3
63928: PPUSH
63929: CALL_OW 1
63933: ST_TO_ADDR
// end ; end ;
63934: GO 63772
63936: POP
63937: POP
// end ;
63938: LD_VAR 0 4
63942: RET
// export function MinerCreateMinefield ( unit , x , y ) ; var i , index , tmp , minesFreeAmount , _x , _y , _d , _r ; begin
63943: LD_INT 0
63945: PPUSH
63946: PPUSH
63947: PPUSH
63948: PPUSH
63949: PPUSH
63950: PPUSH
63951: PPUSH
63952: PPUSH
63953: PPUSH
// if not GetWeapon ( unit ) = ar_miner or not unit in minersList then
63954: LD_VAR 0 1
63958: PPUSH
63959: CALL_OW 264
63963: PUSH
63964: LD_EXP 165
63968: EQUAL
63969: NOT
63970: PUSH
63971: LD_VAR 0 1
63975: PUSH
63976: LD_EXP 94
63980: IN
63981: NOT
63982: OR
63983: IFFALSE 63987
// exit ;
63985: GO 64309
// index := GetElementIndex ( minersList , unit ) ;
63987: LD_ADDR_VAR 0 6
63991: PUSH
63992: LD_EXP 94
63996: PPUSH
63997: LD_VAR 0 1
64001: PPUSH
64002: CALL 24148 0 2
64006: ST_TO_ADDR
// minesFreeAmount := minesLimitPerVehicle - minerMinesList [ index ] ;
64007: LD_ADDR_VAR 0 8
64011: PUSH
64012: LD_EXP 96
64016: PUSH
64017: LD_EXP 95
64021: PUSH
64022: LD_VAR 0 6
64026: ARRAY
64027: MINUS
64028: ST_TO_ADDR
// if not minesFreeAmount then
64029: LD_VAR 0 8
64033: NOT
64034: IFFALSE 64038
// exit ;
64036: GO 64309
// tmp := [ ] ;
64038: LD_ADDR_VAR 0 7
64042: PUSH
64043: EMPTY
64044: ST_TO_ADDR
// for i := 1 to minesFreeAmount do
64045: LD_ADDR_VAR 0 5
64049: PUSH
64050: DOUBLE
64051: LD_INT 1
64053: DEC
64054: ST_TO_ADDR
64055: LD_VAR 0 8
64059: PUSH
64060: FOR_TO
64061: IFFALSE 64256
// begin _d := rand ( 0 , 5 ) ;
64063: LD_ADDR_VAR 0 11
64067: PUSH
64068: LD_INT 0
64070: PPUSH
64071: LD_INT 5
64073: PPUSH
64074: CALL_OW 12
64078: ST_TO_ADDR
// _r := rand ( 2 , 6 ) ;
64079: LD_ADDR_VAR 0 12
64083: PUSH
64084: LD_INT 2
64086: PPUSH
64087: LD_INT 6
64089: PPUSH
64090: CALL_OW 12
64094: ST_TO_ADDR
// _x := ShiftX ( x , _d , _r ) ;
64095: LD_ADDR_VAR 0 9
64099: PUSH
64100: LD_VAR 0 2
64104: PPUSH
64105: LD_VAR 0 11
64109: PPUSH
64110: LD_VAR 0 12
64114: PPUSH
64115: CALL_OW 272
64119: ST_TO_ADDR
// _y := ShiftY ( y , _d , _r ) ;
64120: LD_ADDR_VAR 0 10
64124: PUSH
64125: LD_VAR 0 3
64129: PPUSH
64130: LD_VAR 0 11
64134: PPUSH
64135: LD_VAR 0 12
64139: PPUSH
64140: CALL_OW 273
64144: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not [ _x , _y ] in tmp and not MineAtPos ( _x , _y ) then
64145: LD_VAR 0 9
64149: PPUSH
64150: LD_VAR 0 10
64154: PPUSH
64155: CALL_OW 488
64159: PUSH
64160: LD_VAR 0 9
64164: PUSH
64165: LD_VAR 0 10
64169: PUSH
64170: EMPTY
64171: LIST
64172: LIST
64173: PUSH
64174: LD_VAR 0 7
64178: IN
64179: NOT
64180: AND
64181: PUSH
64182: LD_VAR 0 9
64186: PPUSH
64187: LD_VAR 0 10
64191: PPUSH
64192: CALL_OW 458
64196: NOT
64197: AND
64198: IFFALSE 64240
// tmp := Replace ( tmp , tmp + 1 , [ _x , _y ] ) else
64200: LD_ADDR_VAR 0 7
64204: PUSH
64205: LD_VAR 0 7
64209: PPUSH
64210: LD_VAR 0 7
64214: PUSH
64215: LD_INT 1
64217: PLUS
64218: PPUSH
64219: LD_VAR 0 9
64223: PUSH
64224: LD_VAR 0 10
64228: PUSH
64229: EMPTY
64230: LIST
64231: LIST
64232: PPUSH
64233: CALL_OW 1
64237: ST_TO_ADDR
64238: GO 64254
// i := i - 1 ;
64240: LD_ADDR_VAR 0 5
64244: PUSH
64245: LD_VAR 0 5
64249: PUSH
64250: LD_INT 1
64252: MINUS
64253: ST_TO_ADDR
// end ;
64254: GO 64060
64256: POP
64257: POP
// for i in tmp do
64258: LD_ADDR_VAR 0 5
64262: PUSH
64263: LD_VAR 0 7
64267: PUSH
64268: FOR_IN
64269: IFFALSE 64307
// if not MinerPlaceMine ( unit , i [ 1 ] , i [ 2 ] ) then
64271: LD_VAR 0 1
64275: PPUSH
64276: LD_VAR 0 5
64280: PUSH
64281: LD_INT 1
64283: ARRAY
64284: PPUSH
64285: LD_VAR 0 5
64289: PUSH
64290: LD_INT 2
64292: ARRAY
64293: PPUSH
64294: CALL 63249 0 3
64298: NOT
64299: IFFALSE 64305
// exit ;
64301: POP
64302: POP
64303: GO 64309
64305: GO 64268
64307: POP
64308: POP
// end ;
64309: LD_VAR 0 4
64313: RET
// export function ComBinocular ( unit , x , y ) ; var dist , side , viewRange , _x , _y , _d ; begin
64314: LD_INT 0
64316: PPUSH
64317: PPUSH
64318: PPUSH
64319: PPUSH
64320: PPUSH
64321: PPUSH
64322: PPUSH
// if not GetClass ( unit ) = class_sniper then
64323: LD_VAR 0 1
64327: PPUSH
64328: CALL_OW 257
64332: PUSH
64333: LD_INT 5
64335: EQUAL
64336: NOT
64337: IFFALSE 64341
// exit ;
64339: GO 64729
// dist := 8 ;
64341: LD_ADDR_VAR 0 5
64345: PUSH
64346: LD_INT 8
64348: ST_TO_ADDR
// viewRange := 12 ;
64349: LD_ADDR_VAR 0 7
64353: PUSH
64354: LD_INT 12
64356: ST_TO_ADDR
// side := GetSide ( unit ) ;
64357: LD_ADDR_VAR 0 6
64361: PUSH
64362: LD_VAR 0 1
64366: PPUSH
64367: CALL_OW 255
64371: ST_TO_ADDR
// if GetTech ( tech_opto2 , side ) = state_researched then
64372: LD_INT 61
64374: PPUSH
64375: LD_VAR 0 6
64379: PPUSH
64380: CALL_OW 321
64384: PUSH
64385: LD_INT 2
64387: EQUAL
64388: IFFALSE 64398
// viewRange := 16 ;
64390: LD_ADDR_VAR 0 7
64394: PUSH
64395: LD_INT 16
64397: ST_TO_ADDR
// if GetDistUnitXY ( unit , x , y ) > dist then
64398: LD_VAR 0 1
64402: PPUSH
64403: LD_VAR 0 2
64407: PPUSH
64408: LD_VAR 0 3
64412: PPUSH
64413: CALL_OW 297
64417: PUSH
64418: LD_VAR 0 5
64422: GREATER
64423: IFFALSE 64502
// begin ComMoveXY ( unit , x , y ) ;
64425: LD_VAR 0 1
64429: PPUSH
64430: LD_VAR 0 2
64434: PPUSH
64435: LD_VAR 0 3
64439: PPUSH
64440: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
64444: LD_INT 35
64446: PPUSH
64447: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) then
64451: LD_VAR 0 1
64455: PPUSH
64456: LD_VAR 0 2
64460: PPUSH
64461: LD_VAR 0 3
64465: PPUSH
64466: CALL 55417 0 3
64470: NOT
64471: IFFALSE 64475
// exit ;
64473: GO 64729
// until GetDistUnitXY ( unit , x , y ) < dist ;
64475: LD_VAR 0 1
64479: PPUSH
64480: LD_VAR 0 2
64484: PPUSH
64485: LD_VAR 0 3
64489: PPUSH
64490: CALL_OW 297
64494: PUSH
64495: LD_VAR 0 5
64499: LESS
64500: IFFALSE 64444
// end ; ComTurnXY ( unit , x , y ) ;
64502: LD_VAR 0 1
64506: PPUSH
64507: LD_VAR 0 2
64511: PPUSH
64512: LD_VAR 0 3
64516: PPUSH
64517: CALL_OW 118
// wait ( 5 ) ;
64521: LD_INT 5
64523: PPUSH
64524: CALL_OW 67
// _d := GetDir ( unit ) ;
64528: LD_ADDR_VAR 0 10
64532: PUSH
64533: LD_VAR 0 1
64537: PPUSH
64538: CALL_OW 254
64542: ST_TO_ADDR
// _x := ShiftX ( GetX ( unit ) , _d , dist ) ;
64543: LD_ADDR_VAR 0 8
64547: PUSH
64548: LD_VAR 0 1
64552: PPUSH
64553: CALL_OW 250
64557: PPUSH
64558: LD_VAR 0 10
64562: PPUSH
64563: LD_VAR 0 5
64567: PPUSH
64568: CALL_OW 272
64572: ST_TO_ADDR
// _y := ShiftY ( GetY ( unit ) , _d , dist ) ;
64573: LD_ADDR_VAR 0 9
64577: PUSH
64578: LD_VAR 0 1
64582: PPUSH
64583: CALL_OW 251
64587: PPUSH
64588: LD_VAR 0 10
64592: PPUSH
64593: LD_VAR 0 5
64597: PPUSH
64598: CALL_OW 273
64602: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
64603: LD_VAR 0 8
64607: PPUSH
64608: LD_VAR 0 9
64612: PPUSH
64613: CALL_OW 488
64617: NOT
64618: IFFALSE 64622
// exit ;
64620: GO 64729
// ComAnimCustom ( unit , 1 ) ;
64622: LD_VAR 0 1
64626: PPUSH
64627: LD_INT 1
64629: PPUSH
64630: CALL_OW 592
// PlaceSeeing ( _x , _y , side , viewRange ) ;
64634: LD_VAR 0 8
64638: PPUSH
64639: LD_VAR 0 9
64643: PPUSH
64644: LD_VAR 0 6
64648: PPUSH
64649: LD_VAR 0 7
64653: PPUSH
64654: CALL_OW 330
// repeat wait ( 1 ) ;
64658: LD_INT 1
64660: PPUSH
64661: CALL_OW 67
// until IsIdle ( unit ) or HasTask ( unit ) or not IsOk ( unit ) or IsDead ( unit ) ;
64665: LD_VAR 0 1
64669: PPUSH
64670: CALL_OW 316
64674: PUSH
64675: LD_VAR 0 1
64679: PPUSH
64680: CALL_OW 314
64684: OR
64685: PUSH
64686: LD_VAR 0 1
64690: PPUSH
64691: CALL_OW 302
64695: NOT
64696: OR
64697: PUSH
64698: LD_VAR 0 1
64702: PPUSH
64703: CALL_OW 301
64707: OR
64708: IFFALSE 64658
// RemoveSeeing ( _x , _y , side ) ;
64710: LD_VAR 0 8
64714: PPUSH
64715: LD_VAR 0 9
64719: PPUSH
64720: LD_VAR 0 6
64724: PPUSH
64725: CALL_OW 331
// end ; end_of_file
64729: LD_VAR 0 4
64733: RET
// every 0 0$1 do
64734: GO 64736
64736: DISABLE
// begin enable ;
64737: ENABLE
// ToLua ( updateTimer( & tick & ); ) ;
64738: LD_STRING updateTimer(
64740: PUSH
64741: LD_OWVAR 1
64745: STR
64746: PUSH
64747: LD_STRING );
64749: STR
64750: PPUSH
64751: CALL_OW 559
// end ;
64755: END
// export function SOS_MapStart ( ) ; begin
64756: LD_INT 0
64758: PPUSH
// if streamModeActive then
64759: LD_EXP 97
64763: IFFALSE 64772
// DefineStreamItems ( true ) ;
64765: LD_INT 1
64767: PPUSH
64768: CALL 66426 0 1
// UpdateFactoryWaypoints ( ) ;
64772: CALL 79287 0 0
// UpdateWarehouseGatheringPoints ( ) ;
64776: CALL 79544 0 0
// end ;
64780: LD_VAR 0 1
64784: RET
// export function SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
64785: LD_INT 0
64787: PPUSH
// if p2 = 100 then
64788: LD_VAR 0 2
64792: PUSH
64793: LD_INT 100
64795: EQUAL
64796: IFFALSE 65799
// begin if not StreamModeActive then
64798: LD_EXP 97
64802: NOT
64803: IFFALSE 64813
// StreamModeActive := true ;
64805: LD_ADDR_EXP 97
64809: PUSH
64810: LD_INT 1
64812: ST_TO_ADDR
// if p3 = 0 then
64813: LD_VAR 0 3
64817: PUSH
64818: LD_INT 0
64820: EQUAL
64821: IFFALSE 64827
// InitStreamMode ;
64823: CALL 65962 0 0
// if p3 = 1 then
64827: LD_VAR 0 3
64831: PUSH
64832: LD_INT 1
64834: EQUAL
64835: IFFALSE 64845
// sRocket := true ;
64837: LD_ADDR_EXP 102
64841: PUSH
64842: LD_INT 1
64844: ST_TO_ADDR
// if p3 = 2 then
64845: LD_VAR 0 3
64849: PUSH
64850: LD_INT 2
64852: EQUAL
64853: IFFALSE 64863
// sSpeed := true ;
64855: LD_ADDR_EXP 101
64859: PUSH
64860: LD_INT 1
64862: ST_TO_ADDR
// if p3 = 3 then
64863: LD_VAR 0 3
64867: PUSH
64868: LD_INT 3
64870: EQUAL
64871: IFFALSE 64881
// sEngine := true ;
64873: LD_ADDR_EXP 103
64877: PUSH
64878: LD_INT 1
64880: ST_TO_ADDR
// if p3 = 4 then
64881: LD_VAR 0 3
64885: PUSH
64886: LD_INT 4
64888: EQUAL
64889: IFFALSE 64899
// sSpec := true ;
64891: LD_ADDR_EXP 100
64895: PUSH
64896: LD_INT 1
64898: ST_TO_ADDR
// if p3 = 5 then
64899: LD_VAR 0 3
64903: PUSH
64904: LD_INT 5
64906: EQUAL
64907: IFFALSE 64917
// sLevel := true ;
64909: LD_ADDR_EXP 104
64913: PUSH
64914: LD_INT 1
64916: ST_TO_ADDR
// if p3 = 6 then
64917: LD_VAR 0 3
64921: PUSH
64922: LD_INT 6
64924: EQUAL
64925: IFFALSE 64935
// sArmoury := true ;
64927: LD_ADDR_EXP 105
64931: PUSH
64932: LD_INT 1
64934: ST_TO_ADDR
// if p3 = 7 then
64935: LD_VAR 0 3
64939: PUSH
64940: LD_INT 7
64942: EQUAL
64943: IFFALSE 64953
// sRadar := true ;
64945: LD_ADDR_EXP 106
64949: PUSH
64950: LD_INT 1
64952: ST_TO_ADDR
// if p3 = 8 then
64953: LD_VAR 0 3
64957: PUSH
64958: LD_INT 8
64960: EQUAL
64961: IFFALSE 64971
// sBunker := true ;
64963: LD_ADDR_EXP 107
64967: PUSH
64968: LD_INT 1
64970: ST_TO_ADDR
// if p3 = 9 then
64971: LD_VAR 0 3
64975: PUSH
64976: LD_INT 9
64978: EQUAL
64979: IFFALSE 64989
// sHack := true ;
64981: LD_ADDR_EXP 108
64985: PUSH
64986: LD_INT 1
64988: ST_TO_ADDR
// if p3 = 10 then
64989: LD_VAR 0 3
64993: PUSH
64994: LD_INT 10
64996: EQUAL
64997: IFFALSE 65007
// sFire := true ;
64999: LD_ADDR_EXP 109
65003: PUSH
65004: LD_INT 1
65006: ST_TO_ADDR
// if p3 = 11 then
65007: LD_VAR 0 3
65011: PUSH
65012: LD_INT 11
65014: EQUAL
65015: IFFALSE 65025
// sRefresh := true ;
65017: LD_ADDR_EXP 110
65021: PUSH
65022: LD_INT 1
65024: ST_TO_ADDR
// if p3 = 12 then
65025: LD_VAR 0 3
65029: PUSH
65030: LD_INT 12
65032: EQUAL
65033: IFFALSE 65043
// sExp := true ;
65035: LD_ADDR_EXP 111
65039: PUSH
65040: LD_INT 1
65042: ST_TO_ADDR
// if p3 = 13 then
65043: LD_VAR 0 3
65047: PUSH
65048: LD_INT 13
65050: EQUAL
65051: IFFALSE 65061
// sDepot := true ;
65053: LD_ADDR_EXP 112
65057: PUSH
65058: LD_INT 1
65060: ST_TO_ADDR
// if p3 = 14 then
65061: LD_VAR 0 3
65065: PUSH
65066: LD_INT 14
65068: EQUAL
65069: IFFALSE 65079
// sFlag := true ;
65071: LD_ADDR_EXP 113
65075: PUSH
65076: LD_INT 1
65078: ST_TO_ADDR
// if p3 = 15 then
65079: LD_VAR 0 3
65083: PUSH
65084: LD_INT 15
65086: EQUAL
65087: IFFALSE 65097
// sKamikadze := true ;
65089: LD_ADDR_EXP 121
65093: PUSH
65094: LD_INT 1
65096: ST_TO_ADDR
// if p3 = 16 then
65097: LD_VAR 0 3
65101: PUSH
65102: LD_INT 16
65104: EQUAL
65105: IFFALSE 65115
// sTroll := true ;
65107: LD_ADDR_EXP 122
65111: PUSH
65112: LD_INT 1
65114: ST_TO_ADDR
// if p3 = 17 then
65115: LD_VAR 0 3
65119: PUSH
65120: LD_INT 17
65122: EQUAL
65123: IFFALSE 65133
// sSlow := true ;
65125: LD_ADDR_EXP 123
65129: PUSH
65130: LD_INT 1
65132: ST_TO_ADDR
// if p3 = 18 then
65133: LD_VAR 0 3
65137: PUSH
65138: LD_INT 18
65140: EQUAL
65141: IFFALSE 65151
// sLack := true ;
65143: LD_ADDR_EXP 124
65147: PUSH
65148: LD_INT 1
65150: ST_TO_ADDR
// if p3 = 19 then
65151: LD_VAR 0 3
65155: PUSH
65156: LD_INT 19
65158: EQUAL
65159: IFFALSE 65169
// sTank := true ;
65161: LD_ADDR_EXP 126
65165: PUSH
65166: LD_INT 1
65168: ST_TO_ADDR
// if p3 = 20 then
65169: LD_VAR 0 3
65173: PUSH
65174: LD_INT 20
65176: EQUAL
65177: IFFALSE 65187
// sRemote := true ;
65179: LD_ADDR_EXP 127
65183: PUSH
65184: LD_INT 1
65186: ST_TO_ADDR
// if p3 = 21 then
65187: LD_VAR 0 3
65191: PUSH
65192: LD_INT 21
65194: EQUAL
65195: IFFALSE 65205
// sPowell := true ;
65197: LD_ADDR_EXP 128
65201: PUSH
65202: LD_INT 1
65204: ST_TO_ADDR
// if p3 = 22 then
65205: LD_VAR 0 3
65209: PUSH
65210: LD_INT 22
65212: EQUAL
65213: IFFALSE 65223
// sTeleport := true ;
65215: LD_ADDR_EXP 131
65219: PUSH
65220: LD_INT 1
65222: ST_TO_ADDR
// if p3 = 23 then
65223: LD_VAR 0 3
65227: PUSH
65228: LD_INT 23
65230: EQUAL
65231: IFFALSE 65241
// sOilTower := true ;
65233: LD_ADDR_EXP 133
65237: PUSH
65238: LD_INT 1
65240: ST_TO_ADDR
// if p3 = 24 then
65241: LD_VAR 0 3
65245: PUSH
65246: LD_INT 24
65248: EQUAL
65249: IFFALSE 65259
// sShovel := true ;
65251: LD_ADDR_EXP 134
65255: PUSH
65256: LD_INT 1
65258: ST_TO_ADDR
// if p3 = 25 then
65259: LD_VAR 0 3
65263: PUSH
65264: LD_INT 25
65266: EQUAL
65267: IFFALSE 65277
// sSheik := true ;
65269: LD_ADDR_EXP 135
65273: PUSH
65274: LD_INT 1
65276: ST_TO_ADDR
// if p3 = 26 then
65277: LD_VAR 0 3
65281: PUSH
65282: LD_INT 26
65284: EQUAL
65285: IFFALSE 65295
// sEarthquake := true ;
65287: LD_ADDR_EXP 137
65291: PUSH
65292: LD_INT 1
65294: ST_TO_ADDR
// if p3 = 27 then
65295: LD_VAR 0 3
65299: PUSH
65300: LD_INT 27
65302: EQUAL
65303: IFFALSE 65313
// sAI := true ;
65305: LD_ADDR_EXP 138
65309: PUSH
65310: LD_INT 1
65312: ST_TO_ADDR
// if p3 = 28 then
65313: LD_VAR 0 3
65317: PUSH
65318: LD_INT 28
65320: EQUAL
65321: IFFALSE 65331
// sCargo := true ;
65323: LD_ADDR_EXP 141
65327: PUSH
65328: LD_INT 1
65330: ST_TO_ADDR
// if p3 = 29 then
65331: LD_VAR 0 3
65335: PUSH
65336: LD_INT 29
65338: EQUAL
65339: IFFALSE 65349
// sDLaser := true ;
65341: LD_ADDR_EXP 142
65345: PUSH
65346: LD_INT 1
65348: ST_TO_ADDR
// if p3 = 30 then
65349: LD_VAR 0 3
65353: PUSH
65354: LD_INT 30
65356: EQUAL
65357: IFFALSE 65367
// sExchange := true ;
65359: LD_ADDR_EXP 143
65363: PUSH
65364: LD_INT 1
65366: ST_TO_ADDR
// if p3 = 31 then
65367: LD_VAR 0 3
65371: PUSH
65372: LD_INT 31
65374: EQUAL
65375: IFFALSE 65385
// sFac := true ;
65377: LD_ADDR_EXP 144
65381: PUSH
65382: LD_INT 1
65384: ST_TO_ADDR
// if p3 = 32 then
65385: LD_VAR 0 3
65389: PUSH
65390: LD_INT 32
65392: EQUAL
65393: IFFALSE 65403
// sPower := true ;
65395: LD_ADDR_EXP 145
65399: PUSH
65400: LD_INT 1
65402: ST_TO_ADDR
// if p3 = 33 then
65403: LD_VAR 0 3
65407: PUSH
65408: LD_INT 33
65410: EQUAL
65411: IFFALSE 65421
// sRandom := true ;
65413: LD_ADDR_EXP 146
65417: PUSH
65418: LD_INT 1
65420: ST_TO_ADDR
// if p3 = 34 then
65421: LD_VAR 0 3
65425: PUSH
65426: LD_INT 34
65428: EQUAL
65429: IFFALSE 65439
// sShield := true ;
65431: LD_ADDR_EXP 147
65435: PUSH
65436: LD_INT 1
65438: ST_TO_ADDR
// if p3 = 35 then
65439: LD_VAR 0 3
65443: PUSH
65444: LD_INT 35
65446: EQUAL
65447: IFFALSE 65457
// sTime := true ;
65449: LD_ADDR_EXP 148
65453: PUSH
65454: LD_INT 1
65456: ST_TO_ADDR
// if p3 = 36 then
65457: LD_VAR 0 3
65461: PUSH
65462: LD_INT 36
65464: EQUAL
65465: IFFALSE 65475
// sTools := true ;
65467: LD_ADDR_EXP 149
65471: PUSH
65472: LD_INT 1
65474: ST_TO_ADDR
// if p3 = 101 then
65475: LD_VAR 0 3
65479: PUSH
65480: LD_INT 101
65482: EQUAL
65483: IFFALSE 65493
// sSold := true ;
65485: LD_ADDR_EXP 114
65489: PUSH
65490: LD_INT 1
65492: ST_TO_ADDR
// if p3 = 102 then
65493: LD_VAR 0 3
65497: PUSH
65498: LD_INT 102
65500: EQUAL
65501: IFFALSE 65511
// sDiff := true ;
65503: LD_ADDR_EXP 115
65507: PUSH
65508: LD_INT 1
65510: ST_TO_ADDR
// if p3 = 103 then
65511: LD_VAR 0 3
65515: PUSH
65516: LD_INT 103
65518: EQUAL
65519: IFFALSE 65529
// sFog := true ;
65521: LD_ADDR_EXP 118
65525: PUSH
65526: LD_INT 1
65528: ST_TO_ADDR
// if p3 = 104 then
65529: LD_VAR 0 3
65533: PUSH
65534: LD_INT 104
65536: EQUAL
65537: IFFALSE 65547
// sReset := true ;
65539: LD_ADDR_EXP 119
65543: PUSH
65544: LD_INT 1
65546: ST_TO_ADDR
// if p3 = 105 then
65547: LD_VAR 0 3
65551: PUSH
65552: LD_INT 105
65554: EQUAL
65555: IFFALSE 65565
// sSun := true ;
65557: LD_ADDR_EXP 120
65561: PUSH
65562: LD_INT 1
65564: ST_TO_ADDR
// if p3 = 106 then
65565: LD_VAR 0 3
65569: PUSH
65570: LD_INT 106
65572: EQUAL
65573: IFFALSE 65583
// sTiger := true ;
65575: LD_ADDR_EXP 116
65579: PUSH
65580: LD_INT 1
65582: ST_TO_ADDR
// if p3 = 107 then
65583: LD_VAR 0 3
65587: PUSH
65588: LD_INT 107
65590: EQUAL
65591: IFFALSE 65601
// sBomb := true ;
65593: LD_ADDR_EXP 117
65597: PUSH
65598: LD_INT 1
65600: ST_TO_ADDR
// if p3 = 108 then
65601: LD_VAR 0 3
65605: PUSH
65606: LD_INT 108
65608: EQUAL
65609: IFFALSE 65619
// sWound := true ;
65611: LD_ADDR_EXP 125
65615: PUSH
65616: LD_INT 1
65618: ST_TO_ADDR
// if p3 = 109 then
65619: LD_VAR 0 3
65623: PUSH
65624: LD_INT 109
65626: EQUAL
65627: IFFALSE 65637
// sBetray := true ;
65629: LD_ADDR_EXP 129
65633: PUSH
65634: LD_INT 1
65636: ST_TO_ADDR
// if p3 = 110 then
65637: LD_VAR 0 3
65641: PUSH
65642: LD_INT 110
65644: EQUAL
65645: IFFALSE 65655
// sContamin := true ;
65647: LD_ADDR_EXP 130
65651: PUSH
65652: LD_INT 1
65654: ST_TO_ADDR
// if p3 = 111 then
65655: LD_VAR 0 3
65659: PUSH
65660: LD_INT 111
65662: EQUAL
65663: IFFALSE 65673
// sOil := true ;
65665: LD_ADDR_EXP 132
65669: PUSH
65670: LD_INT 1
65672: ST_TO_ADDR
// if p3 = 112 then
65673: LD_VAR 0 3
65677: PUSH
65678: LD_INT 112
65680: EQUAL
65681: IFFALSE 65691
// sStu := true ;
65683: LD_ADDR_EXP 136
65687: PUSH
65688: LD_INT 1
65690: ST_TO_ADDR
// if p3 = 113 then
65691: LD_VAR 0 3
65695: PUSH
65696: LD_INT 113
65698: EQUAL
65699: IFFALSE 65709
// sBazooka := true ;
65701: LD_ADDR_EXP 139
65705: PUSH
65706: LD_INT 1
65708: ST_TO_ADDR
// if p3 = 114 then
65709: LD_VAR 0 3
65713: PUSH
65714: LD_INT 114
65716: EQUAL
65717: IFFALSE 65727
// sMortar := true ;
65719: LD_ADDR_EXP 140
65723: PUSH
65724: LD_INT 1
65726: ST_TO_ADDR
// if p3 = 115 then
65727: LD_VAR 0 3
65731: PUSH
65732: LD_INT 115
65734: EQUAL
65735: IFFALSE 65745
// sRanger := true ;
65737: LD_ADDR_EXP 150
65741: PUSH
65742: LD_INT 1
65744: ST_TO_ADDR
// if p3 = 116 then
65745: LD_VAR 0 3
65749: PUSH
65750: LD_INT 116
65752: EQUAL
65753: IFFALSE 65763
// sComputer := true ;
65755: LD_ADDR_EXP 151
65759: PUSH
65760: LD_INT 1
65762: ST_TO_ADDR
// if p3 = 117 then
65763: LD_VAR 0 3
65767: PUSH
65768: LD_INT 117
65770: EQUAL
65771: IFFALSE 65781
// s30 := true ;
65773: LD_ADDR_EXP 152
65777: PUSH
65778: LD_INT 1
65780: ST_TO_ADDR
// if p3 = 118 then
65781: LD_VAR 0 3
65785: PUSH
65786: LD_INT 118
65788: EQUAL
65789: IFFALSE 65799
// s60 := true ;
65791: LD_ADDR_EXP 153
65795: PUSH
65796: LD_INT 1
65798: ST_TO_ADDR
// end ; if p2 = 101 then
65799: LD_VAR 0 2
65803: PUSH
65804: LD_INT 101
65806: EQUAL
65807: IFFALSE 65935
// begin case p3 of 1 :
65809: LD_VAR 0 3
65813: PUSH
65814: LD_INT 1
65816: DOUBLE
65817: EQUAL
65818: IFTRUE 65822
65820: GO 65829
65822: POP
// hHackUnlimitedResources ; 2 :
65823: CALL 78033 0 0
65827: GO 65935
65829: LD_INT 2
65831: DOUBLE
65832: EQUAL
65833: IFTRUE 65837
65835: GO 65844
65837: POP
// hHackSetLevel10 ; 3 :
65838: CALL 78166 0 0
65842: GO 65935
65844: LD_INT 3
65846: DOUBLE
65847: EQUAL
65848: IFTRUE 65852
65850: GO 65859
65852: POP
// hHackSetLevel10YourUnits ; 4 :
65853: CALL 78251 0 0
65857: GO 65935
65859: LD_INT 4
65861: DOUBLE
65862: EQUAL
65863: IFTRUE 65867
65865: GO 65874
65867: POP
// hHackInvincible ; 5 :
65868: CALL 78699 0 0
65872: GO 65935
65874: LD_INT 5
65876: DOUBLE
65877: EQUAL
65878: IFTRUE 65882
65880: GO 65889
65882: POP
// hHackInvisible ; 6 :
65883: CALL 78810 0 0
65887: GO 65935
65889: LD_INT 6
65891: DOUBLE
65892: EQUAL
65893: IFTRUE 65897
65895: GO 65904
65897: POP
// hHackChangeYourSide ; 7 :
65898: CALL 78867 0 0
65902: GO 65935
65904: LD_INT 7
65906: DOUBLE
65907: EQUAL
65908: IFTRUE 65912
65910: GO 65919
65912: POP
// hHackChangeUnitSide ; 8 :
65913: CALL 78909 0 0
65917: GO 65935
65919: LD_INT 8
65921: DOUBLE
65922: EQUAL
65923: IFTRUE 65927
65925: GO 65934
65927: POP
// hHackFog ; end ;
65928: CALL 79010 0 0
65932: GO 65935
65934: POP
// end ; end ;
65935: LD_VAR 0 7
65939: RET
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger , sComputer , s30 , s60 ; every 0 0$1 do
65940: GO 65942
65942: DISABLE
// begin ToLua ( initStreamRollete(); ) ;
65943: LD_STRING initStreamRollete();
65945: PPUSH
65946: CALL_OW 559
// InitStreamMode ;
65950: CALL 65962 0 0
// DefineStreamItems ( false ) ;
65954: LD_INT 0
65956: PPUSH
65957: CALL 66426 0 1
// end ;
65961: END
// function InitStreamMode ; begin
65962: LD_INT 0
65964: PPUSH
// streamModeActive := false ;
65965: LD_ADDR_EXP 97
65969: PUSH
65970: LD_INT 0
65972: ST_TO_ADDR
// normalCounter := 36 ;
65973: LD_ADDR_EXP 98
65977: PUSH
65978: LD_INT 36
65980: ST_TO_ADDR
// hardcoreCounter := 18 ;
65981: LD_ADDR_EXP 99
65985: PUSH
65986: LD_INT 18
65988: ST_TO_ADDR
// sRocket := false ;
65989: LD_ADDR_EXP 102
65993: PUSH
65994: LD_INT 0
65996: ST_TO_ADDR
// sSpeed := false ;
65997: LD_ADDR_EXP 101
66001: PUSH
66002: LD_INT 0
66004: ST_TO_ADDR
// sEngine := false ;
66005: LD_ADDR_EXP 103
66009: PUSH
66010: LD_INT 0
66012: ST_TO_ADDR
// sSpec := false ;
66013: LD_ADDR_EXP 100
66017: PUSH
66018: LD_INT 0
66020: ST_TO_ADDR
// sLevel := false ;
66021: LD_ADDR_EXP 104
66025: PUSH
66026: LD_INT 0
66028: ST_TO_ADDR
// sArmoury := false ;
66029: LD_ADDR_EXP 105
66033: PUSH
66034: LD_INT 0
66036: ST_TO_ADDR
// sRadar := false ;
66037: LD_ADDR_EXP 106
66041: PUSH
66042: LD_INT 0
66044: ST_TO_ADDR
// sBunker := false ;
66045: LD_ADDR_EXP 107
66049: PUSH
66050: LD_INT 0
66052: ST_TO_ADDR
// sHack := false ;
66053: LD_ADDR_EXP 108
66057: PUSH
66058: LD_INT 0
66060: ST_TO_ADDR
// sFire := false ;
66061: LD_ADDR_EXP 109
66065: PUSH
66066: LD_INT 0
66068: ST_TO_ADDR
// sRefresh := false ;
66069: LD_ADDR_EXP 110
66073: PUSH
66074: LD_INT 0
66076: ST_TO_ADDR
// sExp := false ;
66077: LD_ADDR_EXP 111
66081: PUSH
66082: LD_INT 0
66084: ST_TO_ADDR
// sDepot := false ;
66085: LD_ADDR_EXP 112
66089: PUSH
66090: LD_INT 0
66092: ST_TO_ADDR
// sFlag := false ;
66093: LD_ADDR_EXP 113
66097: PUSH
66098: LD_INT 0
66100: ST_TO_ADDR
// sKamikadze := false ;
66101: LD_ADDR_EXP 121
66105: PUSH
66106: LD_INT 0
66108: ST_TO_ADDR
// sTroll := false ;
66109: LD_ADDR_EXP 122
66113: PUSH
66114: LD_INT 0
66116: ST_TO_ADDR
// sSlow := false ;
66117: LD_ADDR_EXP 123
66121: PUSH
66122: LD_INT 0
66124: ST_TO_ADDR
// sLack := false ;
66125: LD_ADDR_EXP 124
66129: PUSH
66130: LD_INT 0
66132: ST_TO_ADDR
// sTank := false ;
66133: LD_ADDR_EXP 126
66137: PUSH
66138: LD_INT 0
66140: ST_TO_ADDR
// sRemote := false ;
66141: LD_ADDR_EXP 127
66145: PUSH
66146: LD_INT 0
66148: ST_TO_ADDR
// sPowell := false ;
66149: LD_ADDR_EXP 128
66153: PUSH
66154: LD_INT 0
66156: ST_TO_ADDR
// sTeleport := false ;
66157: LD_ADDR_EXP 131
66161: PUSH
66162: LD_INT 0
66164: ST_TO_ADDR
// sOilTower := false ;
66165: LD_ADDR_EXP 133
66169: PUSH
66170: LD_INT 0
66172: ST_TO_ADDR
// sShovel := false ;
66173: LD_ADDR_EXP 134
66177: PUSH
66178: LD_INT 0
66180: ST_TO_ADDR
// sSheik := false ;
66181: LD_ADDR_EXP 135
66185: PUSH
66186: LD_INT 0
66188: ST_TO_ADDR
// sEarthquake := false ;
66189: LD_ADDR_EXP 137
66193: PUSH
66194: LD_INT 0
66196: ST_TO_ADDR
// sAI := false ;
66197: LD_ADDR_EXP 138
66201: PUSH
66202: LD_INT 0
66204: ST_TO_ADDR
// sCargo := false ;
66205: LD_ADDR_EXP 141
66209: PUSH
66210: LD_INT 0
66212: ST_TO_ADDR
// sDLaser := false ;
66213: LD_ADDR_EXP 142
66217: PUSH
66218: LD_INT 0
66220: ST_TO_ADDR
// sExchange := false ;
66221: LD_ADDR_EXP 143
66225: PUSH
66226: LD_INT 0
66228: ST_TO_ADDR
// sFac := false ;
66229: LD_ADDR_EXP 144
66233: PUSH
66234: LD_INT 0
66236: ST_TO_ADDR
// sPower := false ;
66237: LD_ADDR_EXP 145
66241: PUSH
66242: LD_INT 0
66244: ST_TO_ADDR
// sRandom := false ;
66245: LD_ADDR_EXP 146
66249: PUSH
66250: LD_INT 0
66252: ST_TO_ADDR
// sShield := false ;
66253: LD_ADDR_EXP 147
66257: PUSH
66258: LD_INT 0
66260: ST_TO_ADDR
// sTime := false ;
66261: LD_ADDR_EXP 148
66265: PUSH
66266: LD_INT 0
66268: ST_TO_ADDR
// sTools := false ;
66269: LD_ADDR_EXP 149
66273: PUSH
66274: LD_INT 0
66276: ST_TO_ADDR
// sSold := false ;
66277: LD_ADDR_EXP 114
66281: PUSH
66282: LD_INT 0
66284: ST_TO_ADDR
// sDiff := false ;
66285: LD_ADDR_EXP 115
66289: PUSH
66290: LD_INT 0
66292: ST_TO_ADDR
// sFog := false ;
66293: LD_ADDR_EXP 118
66297: PUSH
66298: LD_INT 0
66300: ST_TO_ADDR
// sReset := false ;
66301: LD_ADDR_EXP 119
66305: PUSH
66306: LD_INT 0
66308: ST_TO_ADDR
// sSun := false ;
66309: LD_ADDR_EXP 120
66313: PUSH
66314: LD_INT 0
66316: ST_TO_ADDR
// sTiger := false ;
66317: LD_ADDR_EXP 116
66321: PUSH
66322: LD_INT 0
66324: ST_TO_ADDR
// sBomb := false ;
66325: LD_ADDR_EXP 117
66329: PUSH
66330: LD_INT 0
66332: ST_TO_ADDR
// sWound := false ;
66333: LD_ADDR_EXP 125
66337: PUSH
66338: LD_INT 0
66340: ST_TO_ADDR
// sBetray := false ;
66341: LD_ADDR_EXP 129
66345: PUSH
66346: LD_INT 0
66348: ST_TO_ADDR
// sContamin := false ;
66349: LD_ADDR_EXP 130
66353: PUSH
66354: LD_INT 0
66356: ST_TO_ADDR
// sOil := false ;
66357: LD_ADDR_EXP 132
66361: PUSH
66362: LD_INT 0
66364: ST_TO_ADDR
// sStu := false ;
66365: LD_ADDR_EXP 136
66369: PUSH
66370: LD_INT 0
66372: ST_TO_ADDR
// sBazooka := false ;
66373: LD_ADDR_EXP 139
66377: PUSH
66378: LD_INT 0
66380: ST_TO_ADDR
// sMortar := false ;
66381: LD_ADDR_EXP 140
66385: PUSH
66386: LD_INT 0
66388: ST_TO_ADDR
// sRanger := false ;
66389: LD_ADDR_EXP 150
66393: PUSH
66394: LD_INT 0
66396: ST_TO_ADDR
// sComputer := false ;
66397: LD_ADDR_EXP 151
66401: PUSH
66402: LD_INT 0
66404: ST_TO_ADDR
// s30 := false ;
66405: LD_ADDR_EXP 152
66409: PUSH
66410: LD_INT 0
66412: ST_TO_ADDR
// s60 := false ;
66413: LD_ADDR_EXP 153
66417: PUSH
66418: LD_INT 0
66420: ST_TO_ADDR
// end ;
66421: LD_VAR 0 1
66425: RET
// function DefineStreamItems ( isGameLoad ) ; var tmp , flags , normal , hardcore , active , i ; begin
66426: LD_INT 0
66428: PPUSH
66429: PPUSH
66430: PPUSH
66431: PPUSH
66432: PPUSH
66433: PPUSH
66434: PPUSH
// result := [ ] ;
66435: LD_ADDR_VAR 0 2
66439: PUSH
66440: EMPTY
66441: ST_TO_ADDR
// if campaign_id = 1 then
66442: LD_OWVAR 69
66446: PUSH
66447: LD_INT 1
66449: EQUAL
66450: IFFALSE 69616
// begin case mission_number of 1 :
66452: LD_OWVAR 70
66456: PUSH
66457: LD_INT 1
66459: DOUBLE
66460: EQUAL
66461: IFTRUE 66465
66463: GO 66541
66465: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 , 116 , 117 , 118 ] ] ; 2 :
66466: LD_ADDR_VAR 0 2
66470: PUSH
66471: LD_INT 2
66473: PUSH
66474: LD_INT 4
66476: PUSH
66477: LD_INT 11
66479: PUSH
66480: LD_INT 12
66482: PUSH
66483: LD_INT 15
66485: PUSH
66486: LD_INT 16
66488: PUSH
66489: LD_INT 22
66491: PUSH
66492: LD_INT 23
66494: PUSH
66495: LD_INT 26
66497: PUSH
66498: EMPTY
66499: LIST
66500: LIST
66501: LIST
66502: LIST
66503: LIST
66504: LIST
66505: LIST
66506: LIST
66507: LIST
66508: PUSH
66509: LD_INT 101
66511: PUSH
66512: LD_INT 102
66514: PUSH
66515: LD_INT 106
66517: PUSH
66518: LD_INT 116
66520: PUSH
66521: LD_INT 117
66523: PUSH
66524: LD_INT 118
66526: PUSH
66527: EMPTY
66528: LIST
66529: LIST
66530: LIST
66531: LIST
66532: LIST
66533: LIST
66534: PUSH
66535: EMPTY
66536: LIST
66537: LIST
66538: ST_TO_ADDR
66539: GO 69614
66541: LD_INT 2
66543: DOUBLE
66544: EQUAL
66545: IFTRUE 66549
66547: GO 66633
66549: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 3 :
66550: LD_ADDR_VAR 0 2
66554: PUSH
66555: LD_INT 2
66557: PUSH
66558: LD_INT 4
66560: PUSH
66561: LD_INT 11
66563: PUSH
66564: LD_INT 12
66566: PUSH
66567: LD_INT 15
66569: PUSH
66570: LD_INT 16
66572: PUSH
66573: LD_INT 22
66575: PUSH
66576: LD_INT 23
66578: PUSH
66579: LD_INT 26
66581: PUSH
66582: EMPTY
66583: LIST
66584: LIST
66585: LIST
66586: LIST
66587: LIST
66588: LIST
66589: LIST
66590: LIST
66591: LIST
66592: PUSH
66593: LD_INT 101
66595: PUSH
66596: LD_INT 102
66598: PUSH
66599: LD_INT 105
66601: PUSH
66602: LD_INT 106
66604: PUSH
66605: LD_INT 108
66607: PUSH
66608: LD_INT 116
66610: PUSH
66611: LD_INT 117
66613: PUSH
66614: LD_INT 118
66616: PUSH
66617: EMPTY
66618: LIST
66619: LIST
66620: LIST
66621: LIST
66622: LIST
66623: LIST
66624: LIST
66625: LIST
66626: PUSH
66627: EMPTY
66628: LIST
66629: LIST
66630: ST_TO_ADDR
66631: GO 69614
66633: LD_INT 3
66635: DOUBLE
66636: EQUAL
66637: IFTRUE 66641
66639: GO 66729
66641: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 4 :
66642: LD_ADDR_VAR 0 2
66646: PUSH
66647: LD_INT 2
66649: PUSH
66650: LD_INT 4
66652: PUSH
66653: LD_INT 5
66655: PUSH
66656: LD_INT 11
66658: PUSH
66659: LD_INT 12
66661: PUSH
66662: LD_INT 15
66664: PUSH
66665: LD_INT 16
66667: PUSH
66668: LD_INT 22
66670: PUSH
66671: LD_INT 26
66673: PUSH
66674: LD_INT 36
66676: PUSH
66677: EMPTY
66678: LIST
66679: LIST
66680: LIST
66681: LIST
66682: LIST
66683: LIST
66684: LIST
66685: LIST
66686: LIST
66687: LIST
66688: PUSH
66689: LD_INT 101
66691: PUSH
66692: LD_INT 102
66694: PUSH
66695: LD_INT 105
66697: PUSH
66698: LD_INT 106
66700: PUSH
66701: LD_INT 108
66703: PUSH
66704: LD_INT 116
66706: PUSH
66707: LD_INT 117
66709: PUSH
66710: LD_INT 118
66712: PUSH
66713: EMPTY
66714: LIST
66715: LIST
66716: LIST
66717: LIST
66718: LIST
66719: LIST
66720: LIST
66721: LIST
66722: PUSH
66723: EMPTY
66724: LIST
66725: LIST
66726: ST_TO_ADDR
66727: GO 69614
66729: LD_INT 4
66731: DOUBLE
66732: EQUAL
66733: IFTRUE 66737
66735: GO 66833
66737: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 5 :
66738: LD_ADDR_VAR 0 2
66742: PUSH
66743: LD_INT 2
66745: PUSH
66746: LD_INT 4
66748: PUSH
66749: LD_INT 5
66751: PUSH
66752: LD_INT 8
66754: PUSH
66755: LD_INT 11
66757: PUSH
66758: LD_INT 12
66760: PUSH
66761: LD_INT 15
66763: PUSH
66764: LD_INT 16
66766: PUSH
66767: LD_INT 22
66769: PUSH
66770: LD_INT 23
66772: PUSH
66773: LD_INT 26
66775: PUSH
66776: LD_INT 36
66778: PUSH
66779: EMPTY
66780: LIST
66781: LIST
66782: LIST
66783: LIST
66784: LIST
66785: LIST
66786: LIST
66787: LIST
66788: LIST
66789: LIST
66790: LIST
66791: LIST
66792: PUSH
66793: LD_INT 101
66795: PUSH
66796: LD_INT 102
66798: PUSH
66799: LD_INT 105
66801: PUSH
66802: LD_INT 106
66804: PUSH
66805: LD_INT 108
66807: PUSH
66808: LD_INT 116
66810: PUSH
66811: LD_INT 117
66813: PUSH
66814: LD_INT 118
66816: PUSH
66817: EMPTY
66818: LIST
66819: LIST
66820: LIST
66821: LIST
66822: LIST
66823: LIST
66824: LIST
66825: LIST
66826: PUSH
66827: EMPTY
66828: LIST
66829: LIST
66830: ST_TO_ADDR
66831: GO 69614
66833: LD_INT 5
66835: DOUBLE
66836: EQUAL
66837: IFTRUE 66841
66839: GO 66953
66841: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 6 :
66842: LD_ADDR_VAR 0 2
66846: PUSH
66847: LD_INT 2
66849: PUSH
66850: LD_INT 4
66852: PUSH
66853: LD_INT 5
66855: PUSH
66856: LD_INT 6
66858: PUSH
66859: LD_INT 8
66861: PUSH
66862: LD_INT 11
66864: PUSH
66865: LD_INT 12
66867: PUSH
66868: LD_INT 15
66870: PUSH
66871: LD_INT 16
66873: PUSH
66874: LD_INT 22
66876: PUSH
66877: LD_INT 23
66879: PUSH
66880: LD_INT 25
66882: PUSH
66883: LD_INT 26
66885: PUSH
66886: LD_INT 36
66888: PUSH
66889: EMPTY
66890: LIST
66891: LIST
66892: LIST
66893: LIST
66894: LIST
66895: LIST
66896: LIST
66897: LIST
66898: LIST
66899: LIST
66900: LIST
66901: LIST
66902: LIST
66903: LIST
66904: PUSH
66905: LD_INT 101
66907: PUSH
66908: LD_INT 102
66910: PUSH
66911: LD_INT 105
66913: PUSH
66914: LD_INT 106
66916: PUSH
66917: LD_INT 108
66919: PUSH
66920: LD_INT 109
66922: PUSH
66923: LD_INT 112
66925: PUSH
66926: LD_INT 116
66928: PUSH
66929: LD_INT 117
66931: PUSH
66932: LD_INT 118
66934: PUSH
66935: EMPTY
66936: LIST
66937: LIST
66938: LIST
66939: LIST
66940: LIST
66941: LIST
66942: LIST
66943: LIST
66944: LIST
66945: LIST
66946: PUSH
66947: EMPTY
66948: LIST
66949: LIST
66950: ST_TO_ADDR
66951: GO 69614
66953: LD_INT 6
66955: DOUBLE
66956: EQUAL
66957: IFTRUE 66961
66959: GO 67093
66961: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 7 :
66962: LD_ADDR_VAR 0 2
66966: PUSH
66967: LD_INT 2
66969: PUSH
66970: LD_INT 4
66972: PUSH
66973: LD_INT 5
66975: PUSH
66976: LD_INT 6
66978: PUSH
66979: LD_INT 8
66981: PUSH
66982: LD_INT 11
66984: PUSH
66985: LD_INT 12
66987: PUSH
66988: LD_INT 15
66990: PUSH
66991: LD_INT 16
66993: PUSH
66994: LD_INT 20
66996: PUSH
66997: LD_INT 21
66999: PUSH
67000: LD_INT 22
67002: PUSH
67003: LD_INT 23
67005: PUSH
67006: LD_INT 25
67008: PUSH
67009: LD_INT 26
67011: PUSH
67012: LD_INT 30
67014: PUSH
67015: LD_INT 31
67017: PUSH
67018: LD_INT 32
67020: PUSH
67021: LD_INT 36
67023: PUSH
67024: EMPTY
67025: LIST
67026: LIST
67027: LIST
67028: LIST
67029: LIST
67030: LIST
67031: LIST
67032: LIST
67033: LIST
67034: LIST
67035: LIST
67036: LIST
67037: LIST
67038: LIST
67039: LIST
67040: LIST
67041: LIST
67042: LIST
67043: LIST
67044: PUSH
67045: LD_INT 101
67047: PUSH
67048: LD_INT 102
67050: PUSH
67051: LD_INT 105
67053: PUSH
67054: LD_INT 106
67056: PUSH
67057: LD_INT 108
67059: PUSH
67060: LD_INT 109
67062: PUSH
67063: LD_INT 112
67065: PUSH
67066: LD_INT 116
67068: PUSH
67069: LD_INT 117
67071: PUSH
67072: LD_INT 118
67074: PUSH
67075: EMPTY
67076: LIST
67077: LIST
67078: LIST
67079: LIST
67080: LIST
67081: LIST
67082: LIST
67083: LIST
67084: LIST
67085: LIST
67086: PUSH
67087: EMPTY
67088: LIST
67089: LIST
67090: ST_TO_ADDR
67091: GO 69614
67093: LD_INT 7
67095: DOUBLE
67096: EQUAL
67097: IFTRUE 67101
67099: GO 67213
67101: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 , 116 , 117 , 118 ] ] ; 8 :
67102: LD_ADDR_VAR 0 2
67106: PUSH
67107: LD_INT 2
67109: PUSH
67110: LD_INT 4
67112: PUSH
67113: LD_INT 5
67115: PUSH
67116: LD_INT 7
67118: PUSH
67119: LD_INT 11
67121: PUSH
67122: LD_INT 12
67124: PUSH
67125: LD_INT 15
67127: PUSH
67128: LD_INT 16
67130: PUSH
67131: LD_INT 20
67133: PUSH
67134: LD_INT 21
67136: PUSH
67137: LD_INT 22
67139: PUSH
67140: LD_INT 23
67142: PUSH
67143: LD_INT 25
67145: PUSH
67146: LD_INT 26
67148: PUSH
67149: EMPTY
67150: LIST
67151: LIST
67152: LIST
67153: LIST
67154: LIST
67155: LIST
67156: LIST
67157: LIST
67158: LIST
67159: LIST
67160: LIST
67161: LIST
67162: LIST
67163: LIST
67164: PUSH
67165: LD_INT 101
67167: PUSH
67168: LD_INT 102
67170: PUSH
67171: LD_INT 103
67173: PUSH
67174: LD_INT 105
67176: PUSH
67177: LD_INT 106
67179: PUSH
67180: LD_INT 108
67182: PUSH
67183: LD_INT 112
67185: PUSH
67186: LD_INT 116
67188: PUSH
67189: LD_INT 117
67191: PUSH
67192: LD_INT 118
67194: PUSH
67195: EMPTY
67196: LIST
67197: LIST
67198: LIST
67199: LIST
67200: LIST
67201: LIST
67202: LIST
67203: LIST
67204: LIST
67205: LIST
67206: PUSH
67207: EMPTY
67208: LIST
67209: LIST
67210: ST_TO_ADDR
67211: GO 69614
67213: LD_INT 8
67215: DOUBLE
67216: EQUAL
67217: IFTRUE 67221
67219: GO 67361
67221: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 9 :
67222: LD_ADDR_VAR 0 2
67226: PUSH
67227: LD_INT 2
67229: PUSH
67230: LD_INT 4
67232: PUSH
67233: LD_INT 5
67235: PUSH
67236: LD_INT 6
67238: PUSH
67239: LD_INT 7
67241: PUSH
67242: LD_INT 8
67244: PUSH
67245: LD_INT 11
67247: PUSH
67248: LD_INT 12
67250: PUSH
67251: LD_INT 15
67253: PUSH
67254: LD_INT 16
67256: PUSH
67257: LD_INT 20
67259: PUSH
67260: LD_INT 21
67262: PUSH
67263: LD_INT 22
67265: PUSH
67266: LD_INT 23
67268: PUSH
67269: LD_INT 25
67271: PUSH
67272: LD_INT 26
67274: PUSH
67275: LD_INT 30
67277: PUSH
67278: LD_INT 31
67280: PUSH
67281: LD_INT 32
67283: PUSH
67284: LD_INT 36
67286: PUSH
67287: EMPTY
67288: LIST
67289: LIST
67290: LIST
67291: LIST
67292: LIST
67293: LIST
67294: LIST
67295: LIST
67296: LIST
67297: LIST
67298: LIST
67299: LIST
67300: LIST
67301: LIST
67302: LIST
67303: LIST
67304: LIST
67305: LIST
67306: LIST
67307: LIST
67308: PUSH
67309: LD_INT 101
67311: PUSH
67312: LD_INT 102
67314: PUSH
67315: LD_INT 103
67317: PUSH
67318: LD_INT 105
67320: PUSH
67321: LD_INT 106
67323: PUSH
67324: LD_INT 108
67326: PUSH
67327: LD_INT 109
67329: PUSH
67330: LD_INT 112
67332: PUSH
67333: LD_INT 116
67335: PUSH
67336: LD_INT 117
67338: PUSH
67339: LD_INT 118
67341: PUSH
67342: EMPTY
67343: LIST
67344: LIST
67345: LIST
67346: LIST
67347: LIST
67348: LIST
67349: LIST
67350: LIST
67351: LIST
67352: LIST
67353: LIST
67354: PUSH
67355: EMPTY
67356: LIST
67357: LIST
67358: ST_TO_ADDR
67359: GO 69614
67361: LD_INT 9
67363: DOUBLE
67364: EQUAL
67365: IFTRUE 67369
67367: GO 67517
67369: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 , 116 , 117 , 118 ] ] ; 10 :
67370: LD_ADDR_VAR 0 2
67374: PUSH
67375: LD_INT 2
67377: PUSH
67378: LD_INT 4
67380: PUSH
67381: LD_INT 5
67383: PUSH
67384: LD_INT 6
67386: PUSH
67387: LD_INT 7
67389: PUSH
67390: LD_INT 8
67392: PUSH
67393: LD_INT 11
67395: PUSH
67396: LD_INT 12
67398: PUSH
67399: LD_INT 15
67401: PUSH
67402: LD_INT 16
67404: PUSH
67405: LD_INT 20
67407: PUSH
67408: LD_INT 21
67410: PUSH
67411: LD_INT 22
67413: PUSH
67414: LD_INT 23
67416: PUSH
67417: LD_INT 25
67419: PUSH
67420: LD_INT 26
67422: PUSH
67423: LD_INT 28
67425: PUSH
67426: LD_INT 30
67428: PUSH
67429: LD_INT 31
67431: PUSH
67432: LD_INT 32
67434: PUSH
67435: LD_INT 36
67437: PUSH
67438: EMPTY
67439: LIST
67440: LIST
67441: LIST
67442: LIST
67443: LIST
67444: LIST
67445: LIST
67446: LIST
67447: LIST
67448: LIST
67449: LIST
67450: LIST
67451: LIST
67452: LIST
67453: LIST
67454: LIST
67455: LIST
67456: LIST
67457: LIST
67458: LIST
67459: LIST
67460: PUSH
67461: LD_INT 101
67463: PUSH
67464: LD_INT 102
67466: PUSH
67467: LD_INT 103
67469: PUSH
67470: LD_INT 105
67472: PUSH
67473: LD_INT 106
67475: PUSH
67476: LD_INT 108
67478: PUSH
67479: LD_INT 109
67481: PUSH
67482: LD_INT 112
67484: PUSH
67485: LD_INT 114
67487: PUSH
67488: LD_INT 116
67490: PUSH
67491: LD_INT 117
67493: PUSH
67494: LD_INT 118
67496: PUSH
67497: EMPTY
67498: LIST
67499: LIST
67500: LIST
67501: LIST
67502: LIST
67503: LIST
67504: LIST
67505: LIST
67506: LIST
67507: LIST
67508: LIST
67509: LIST
67510: PUSH
67511: EMPTY
67512: LIST
67513: LIST
67514: ST_TO_ADDR
67515: GO 69614
67517: LD_INT 10
67519: DOUBLE
67520: EQUAL
67521: IFTRUE 67525
67523: GO 67721
67525: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 11 :
67526: LD_ADDR_VAR 0 2
67530: PUSH
67531: LD_INT 2
67533: PUSH
67534: LD_INT 4
67536: PUSH
67537: LD_INT 5
67539: PUSH
67540: LD_INT 6
67542: PUSH
67543: LD_INT 7
67545: PUSH
67546: LD_INT 8
67548: PUSH
67549: LD_INT 9
67551: PUSH
67552: LD_INT 10
67554: PUSH
67555: LD_INT 11
67557: PUSH
67558: LD_INT 12
67560: PUSH
67561: LD_INT 13
67563: PUSH
67564: LD_INT 14
67566: PUSH
67567: LD_INT 15
67569: PUSH
67570: LD_INT 16
67572: PUSH
67573: LD_INT 17
67575: PUSH
67576: LD_INT 18
67578: PUSH
67579: LD_INT 19
67581: PUSH
67582: LD_INT 20
67584: PUSH
67585: LD_INT 21
67587: PUSH
67588: LD_INT 22
67590: PUSH
67591: LD_INT 23
67593: PUSH
67594: LD_INT 24
67596: PUSH
67597: LD_INT 25
67599: PUSH
67600: LD_INT 26
67602: PUSH
67603: LD_INT 28
67605: PUSH
67606: LD_INT 30
67608: PUSH
67609: LD_INT 31
67611: PUSH
67612: LD_INT 32
67614: PUSH
67615: LD_INT 36
67617: PUSH
67618: EMPTY
67619: LIST
67620: LIST
67621: LIST
67622: LIST
67623: LIST
67624: LIST
67625: LIST
67626: LIST
67627: LIST
67628: LIST
67629: LIST
67630: LIST
67631: LIST
67632: LIST
67633: LIST
67634: LIST
67635: LIST
67636: LIST
67637: LIST
67638: LIST
67639: LIST
67640: LIST
67641: LIST
67642: LIST
67643: LIST
67644: LIST
67645: LIST
67646: LIST
67647: LIST
67648: PUSH
67649: LD_INT 101
67651: PUSH
67652: LD_INT 102
67654: PUSH
67655: LD_INT 103
67657: PUSH
67658: LD_INT 104
67660: PUSH
67661: LD_INT 105
67663: PUSH
67664: LD_INT 106
67666: PUSH
67667: LD_INT 107
67669: PUSH
67670: LD_INT 108
67672: PUSH
67673: LD_INT 109
67675: PUSH
67676: LD_INT 110
67678: PUSH
67679: LD_INT 111
67681: PUSH
67682: LD_INT 112
67684: PUSH
67685: LD_INT 114
67687: PUSH
67688: LD_INT 116
67690: PUSH
67691: LD_INT 117
67693: PUSH
67694: LD_INT 118
67696: PUSH
67697: EMPTY
67698: LIST
67699: LIST
67700: LIST
67701: LIST
67702: LIST
67703: LIST
67704: LIST
67705: LIST
67706: LIST
67707: LIST
67708: LIST
67709: LIST
67710: LIST
67711: LIST
67712: LIST
67713: LIST
67714: PUSH
67715: EMPTY
67716: LIST
67717: LIST
67718: ST_TO_ADDR
67719: GO 69614
67721: LD_INT 11
67723: DOUBLE
67724: EQUAL
67725: IFTRUE 67729
67727: GO 67933
67729: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 12 :
67730: LD_ADDR_VAR 0 2
67734: PUSH
67735: LD_INT 2
67737: PUSH
67738: LD_INT 3
67740: PUSH
67741: LD_INT 4
67743: PUSH
67744: LD_INT 5
67746: PUSH
67747: LD_INT 6
67749: PUSH
67750: LD_INT 7
67752: PUSH
67753: LD_INT 8
67755: PUSH
67756: LD_INT 9
67758: PUSH
67759: LD_INT 10
67761: PUSH
67762: LD_INT 11
67764: PUSH
67765: LD_INT 12
67767: PUSH
67768: LD_INT 13
67770: PUSH
67771: LD_INT 14
67773: PUSH
67774: LD_INT 15
67776: PUSH
67777: LD_INT 16
67779: PUSH
67780: LD_INT 17
67782: PUSH
67783: LD_INT 18
67785: PUSH
67786: LD_INT 19
67788: PUSH
67789: LD_INT 20
67791: PUSH
67792: LD_INT 21
67794: PUSH
67795: LD_INT 22
67797: PUSH
67798: LD_INT 23
67800: PUSH
67801: LD_INT 24
67803: PUSH
67804: LD_INT 25
67806: PUSH
67807: LD_INT 26
67809: PUSH
67810: LD_INT 28
67812: PUSH
67813: LD_INT 30
67815: PUSH
67816: LD_INT 31
67818: PUSH
67819: LD_INT 32
67821: PUSH
67822: LD_INT 34
67824: PUSH
67825: LD_INT 36
67827: PUSH
67828: EMPTY
67829: LIST
67830: LIST
67831: LIST
67832: LIST
67833: LIST
67834: LIST
67835: LIST
67836: LIST
67837: LIST
67838: LIST
67839: LIST
67840: LIST
67841: LIST
67842: LIST
67843: LIST
67844: LIST
67845: LIST
67846: LIST
67847: LIST
67848: LIST
67849: LIST
67850: LIST
67851: LIST
67852: LIST
67853: LIST
67854: LIST
67855: LIST
67856: LIST
67857: LIST
67858: LIST
67859: LIST
67860: PUSH
67861: LD_INT 101
67863: PUSH
67864: LD_INT 102
67866: PUSH
67867: LD_INT 103
67869: PUSH
67870: LD_INT 104
67872: PUSH
67873: LD_INT 105
67875: PUSH
67876: LD_INT 106
67878: PUSH
67879: LD_INT 107
67881: PUSH
67882: LD_INT 108
67884: PUSH
67885: LD_INT 109
67887: PUSH
67888: LD_INT 110
67890: PUSH
67891: LD_INT 111
67893: PUSH
67894: LD_INT 112
67896: PUSH
67897: LD_INT 114
67899: PUSH
67900: LD_INT 116
67902: PUSH
67903: LD_INT 117
67905: PUSH
67906: LD_INT 118
67908: PUSH
67909: EMPTY
67910: LIST
67911: LIST
67912: LIST
67913: LIST
67914: LIST
67915: LIST
67916: LIST
67917: LIST
67918: LIST
67919: LIST
67920: LIST
67921: LIST
67922: LIST
67923: LIST
67924: LIST
67925: LIST
67926: PUSH
67927: EMPTY
67928: LIST
67929: LIST
67930: ST_TO_ADDR
67931: GO 69614
67933: LD_INT 12
67935: DOUBLE
67936: EQUAL
67937: IFTRUE 67941
67939: GO 68161
67941: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 13 :
67942: LD_ADDR_VAR 0 2
67946: PUSH
67947: LD_INT 1
67949: PUSH
67950: LD_INT 2
67952: PUSH
67953: LD_INT 3
67955: PUSH
67956: LD_INT 4
67958: PUSH
67959: LD_INT 5
67961: PUSH
67962: LD_INT 6
67964: PUSH
67965: LD_INT 7
67967: PUSH
67968: LD_INT 8
67970: PUSH
67971: LD_INT 9
67973: PUSH
67974: LD_INT 10
67976: PUSH
67977: LD_INT 11
67979: PUSH
67980: LD_INT 12
67982: PUSH
67983: LD_INT 13
67985: PUSH
67986: LD_INT 14
67988: PUSH
67989: LD_INT 15
67991: PUSH
67992: LD_INT 16
67994: PUSH
67995: LD_INT 17
67997: PUSH
67998: LD_INT 18
68000: PUSH
68001: LD_INT 19
68003: PUSH
68004: LD_INT 20
68006: PUSH
68007: LD_INT 21
68009: PUSH
68010: LD_INT 22
68012: PUSH
68013: LD_INT 23
68015: PUSH
68016: LD_INT 24
68018: PUSH
68019: LD_INT 25
68021: PUSH
68022: LD_INT 26
68024: PUSH
68025: LD_INT 27
68027: PUSH
68028: LD_INT 28
68030: PUSH
68031: LD_INT 30
68033: PUSH
68034: LD_INT 31
68036: PUSH
68037: LD_INT 32
68039: PUSH
68040: LD_INT 33
68042: PUSH
68043: LD_INT 34
68045: PUSH
68046: LD_INT 36
68048: PUSH
68049: EMPTY
68050: LIST
68051: LIST
68052: LIST
68053: LIST
68054: LIST
68055: LIST
68056: LIST
68057: LIST
68058: LIST
68059: LIST
68060: LIST
68061: LIST
68062: LIST
68063: LIST
68064: LIST
68065: LIST
68066: LIST
68067: LIST
68068: LIST
68069: LIST
68070: LIST
68071: LIST
68072: LIST
68073: LIST
68074: LIST
68075: LIST
68076: LIST
68077: LIST
68078: LIST
68079: LIST
68080: LIST
68081: LIST
68082: LIST
68083: LIST
68084: PUSH
68085: LD_INT 101
68087: PUSH
68088: LD_INT 102
68090: PUSH
68091: LD_INT 103
68093: PUSH
68094: LD_INT 104
68096: PUSH
68097: LD_INT 105
68099: PUSH
68100: LD_INT 106
68102: PUSH
68103: LD_INT 107
68105: PUSH
68106: LD_INT 108
68108: PUSH
68109: LD_INT 109
68111: PUSH
68112: LD_INT 110
68114: PUSH
68115: LD_INT 111
68117: PUSH
68118: LD_INT 112
68120: PUSH
68121: LD_INT 113
68123: PUSH
68124: LD_INT 114
68126: PUSH
68127: LD_INT 116
68129: PUSH
68130: LD_INT 117
68132: PUSH
68133: LD_INT 118
68135: PUSH
68136: EMPTY
68137: LIST
68138: LIST
68139: LIST
68140: LIST
68141: LIST
68142: LIST
68143: LIST
68144: LIST
68145: LIST
68146: LIST
68147: LIST
68148: LIST
68149: LIST
68150: LIST
68151: LIST
68152: LIST
68153: LIST
68154: PUSH
68155: EMPTY
68156: LIST
68157: LIST
68158: ST_TO_ADDR
68159: GO 69614
68161: LD_INT 13
68163: DOUBLE
68164: EQUAL
68165: IFTRUE 68169
68167: GO 68377
68169: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 14 :
68170: LD_ADDR_VAR 0 2
68174: PUSH
68175: LD_INT 1
68177: PUSH
68178: LD_INT 2
68180: PUSH
68181: LD_INT 3
68183: PUSH
68184: LD_INT 4
68186: PUSH
68187: LD_INT 5
68189: PUSH
68190: LD_INT 8
68192: PUSH
68193: LD_INT 9
68195: PUSH
68196: LD_INT 10
68198: PUSH
68199: LD_INT 11
68201: PUSH
68202: LD_INT 12
68204: PUSH
68205: LD_INT 14
68207: PUSH
68208: LD_INT 15
68210: PUSH
68211: LD_INT 16
68213: PUSH
68214: LD_INT 17
68216: PUSH
68217: LD_INT 18
68219: PUSH
68220: LD_INT 19
68222: PUSH
68223: LD_INT 20
68225: PUSH
68226: LD_INT 21
68228: PUSH
68229: LD_INT 22
68231: PUSH
68232: LD_INT 23
68234: PUSH
68235: LD_INT 24
68237: PUSH
68238: LD_INT 25
68240: PUSH
68241: LD_INT 26
68243: PUSH
68244: LD_INT 27
68246: PUSH
68247: LD_INT 28
68249: PUSH
68250: LD_INT 30
68252: PUSH
68253: LD_INT 31
68255: PUSH
68256: LD_INT 32
68258: PUSH
68259: LD_INT 33
68261: PUSH
68262: LD_INT 34
68264: PUSH
68265: LD_INT 36
68267: PUSH
68268: EMPTY
68269: LIST
68270: LIST
68271: LIST
68272: LIST
68273: LIST
68274: LIST
68275: LIST
68276: LIST
68277: LIST
68278: LIST
68279: LIST
68280: LIST
68281: LIST
68282: LIST
68283: LIST
68284: LIST
68285: LIST
68286: LIST
68287: LIST
68288: LIST
68289: LIST
68290: LIST
68291: LIST
68292: LIST
68293: LIST
68294: LIST
68295: LIST
68296: LIST
68297: LIST
68298: LIST
68299: LIST
68300: PUSH
68301: LD_INT 101
68303: PUSH
68304: LD_INT 102
68306: PUSH
68307: LD_INT 103
68309: PUSH
68310: LD_INT 104
68312: PUSH
68313: LD_INT 105
68315: PUSH
68316: LD_INT 106
68318: PUSH
68319: LD_INT 107
68321: PUSH
68322: LD_INT 108
68324: PUSH
68325: LD_INT 109
68327: PUSH
68328: LD_INT 110
68330: PUSH
68331: LD_INT 111
68333: PUSH
68334: LD_INT 112
68336: PUSH
68337: LD_INT 113
68339: PUSH
68340: LD_INT 114
68342: PUSH
68343: LD_INT 116
68345: PUSH
68346: LD_INT 117
68348: PUSH
68349: LD_INT 118
68351: PUSH
68352: EMPTY
68353: LIST
68354: LIST
68355: LIST
68356: LIST
68357: LIST
68358: LIST
68359: LIST
68360: LIST
68361: LIST
68362: LIST
68363: LIST
68364: LIST
68365: LIST
68366: LIST
68367: LIST
68368: LIST
68369: LIST
68370: PUSH
68371: EMPTY
68372: LIST
68373: LIST
68374: ST_TO_ADDR
68375: GO 69614
68377: LD_INT 14
68379: DOUBLE
68380: EQUAL
68381: IFTRUE 68385
68383: GO 68609
68385: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 15 :
68386: LD_ADDR_VAR 0 2
68390: PUSH
68391: LD_INT 1
68393: PUSH
68394: LD_INT 2
68396: PUSH
68397: LD_INT 3
68399: PUSH
68400: LD_INT 4
68402: PUSH
68403: LD_INT 5
68405: PUSH
68406: LD_INT 6
68408: PUSH
68409: LD_INT 7
68411: PUSH
68412: LD_INT 8
68414: PUSH
68415: LD_INT 9
68417: PUSH
68418: LD_INT 10
68420: PUSH
68421: LD_INT 11
68423: PUSH
68424: LD_INT 12
68426: PUSH
68427: LD_INT 13
68429: PUSH
68430: LD_INT 14
68432: PUSH
68433: LD_INT 15
68435: PUSH
68436: LD_INT 16
68438: PUSH
68439: LD_INT 17
68441: PUSH
68442: LD_INT 18
68444: PUSH
68445: LD_INT 19
68447: PUSH
68448: LD_INT 20
68450: PUSH
68451: LD_INT 21
68453: PUSH
68454: LD_INT 22
68456: PUSH
68457: LD_INT 23
68459: PUSH
68460: LD_INT 24
68462: PUSH
68463: LD_INT 25
68465: PUSH
68466: LD_INT 26
68468: PUSH
68469: LD_INT 27
68471: PUSH
68472: LD_INT 28
68474: PUSH
68475: LD_INT 29
68477: PUSH
68478: LD_INT 30
68480: PUSH
68481: LD_INT 31
68483: PUSH
68484: LD_INT 32
68486: PUSH
68487: LD_INT 33
68489: PUSH
68490: LD_INT 34
68492: PUSH
68493: LD_INT 36
68495: PUSH
68496: EMPTY
68497: LIST
68498: LIST
68499: LIST
68500: LIST
68501: LIST
68502: LIST
68503: LIST
68504: LIST
68505: LIST
68506: LIST
68507: LIST
68508: LIST
68509: LIST
68510: LIST
68511: LIST
68512: LIST
68513: LIST
68514: LIST
68515: LIST
68516: LIST
68517: LIST
68518: LIST
68519: LIST
68520: LIST
68521: LIST
68522: LIST
68523: LIST
68524: LIST
68525: LIST
68526: LIST
68527: LIST
68528: LIST
68529: LIST
68530: LIST
68531: LIST
68532: PUSH
68533: LD_INT 101
68535: PUSH
68536: LD_INT 102
68538: PUSH
68539: LD_INT 103
68541: PUSH
68542: LD_INT 104
68544: PUSH
68545: LD_INT 105
68547: PUSH
68548: LD_INT 106
68550: PUSH
68551: LD_INT 107
68553: PUSH
68554: LD_INT 108
68556: PUSH
68557: LD_INT 109
68559: PUSH
68560: LD_INT 110
68562: PUSH
68563: LD_INT 111
68565: PUSH
68566: LD_INT 112
68568: PUSH
68569: LD_INT 113
68571: PUSH
68572: LD_INT 114
68574: PUSH
68575: LD_INT 116
68577: PUSH
68578: LD_INT 117
68580: PUSH
68581: LD_INT 118
68583: PUSH
68584: EMPTY
68585: LIST
68586: LIST
68587: LIST
68588: LIST
68589: LIST
68590: LIST
68591: LIST
68592: LIST
68593: LIST
68594: LIST
68595: LIST
68596: LIST
68597: LIST
68598: LIST
68599: LIST
68600: LIST
68601: LIST
68602: PUSH
68603: EMPTY
68604: LIST
68605: LIST
68606: ST_TO_ADDR
68607: GO 69614
68609: LD_INT 15
68611: DOUBLE
68612: EQUAL
68613: IFTRUE 68617
68615: GO 68841
68617: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 16 :
68618: LD_ADDR_VAR 0 2
68622: PUSH
68623: LD_INT 1
68625: PUSH
68626: LD_INT 2
68628: PUSH
68629: LD_INT 3
68631: PUSH
68632: LD_INT 4
68634: PUSH
68635: LD_INT 5
68637: PUSH
68638: LD_INT 6
68640: PUSH
68641: LD_INT 7
68643: PUSH
68644: LD_INT 8
68646: PUSH
68647: LD_INT 9
68649: PUSH
68650: LD_INT 10
68652: PUSH
68653: LD_INT 11
68655: PUSH
68656: LD_INT 12
68658: PUSH
68659: LD_INT 13
68661: PUSH
68662: LD_INT 14
68664: PUSH
68665: LD_INT 15
68667: PUSH
68668: LD_INT 16
68670: PUSH
68671: LD_INT 17
68673: PUSH
68674: LD_INT 18
68676: PUSH
68677: LD_INT 19
68679: PUSH
68680: LD_INT 20
68682: PUSH
68683: LD_INT 21
68685: PUSH
68686: LD_INT 22
68688: PUSH
68689: LD_INT 23
68691: PUSH
68692: LD_INT 24
68694: PUSH
68695: LD_INT 25
68697: PUSH
68698: LD_INT 26
68700: PUSH
68701: LD_INT 27
68703: PUSH
68704: LD_INT 28
68706: PUSH
68707: LD_INT 29
68709: PUSH
68710: LD_INT 30
68712: PUSH
68713: LD_INT 31
68715: PUSH
68716: LD_INT 32
68718: PUSH
68719: LD_INT 33
68721: PUSH
68722: LD_INT 34
68724: PUSH
68725: LD_INT 36
68727: PUSH
68728: EMPTY
68729: LIST
68730: LIST
68731: LIST
68732: LIST
68733: LIST
68734: LIST
68735: LIST
68736: LIST
68737: LIST
68738: LIST
68739: LIST
68740: LIST
68741: LIST
68742: LIST
68743: LIST
68744: LIST
68745: LIST
68746: LIST
68747: LIST
68748: LIST
68749: LIST
68750: LIST
68751: LIST
68752: LIST
68753: LIST
68754: LIST
68755: LIST
68756: LIST
68757: LIST
68758: LIST
68759: LIST
68760: LIST
68761: LIST
68762: LIST
68763: LIST
68764: PUSH
68765: LD_INT 101
68767: PUSH
68768: LD_INT 102
68770: PUSH
68771: LD_INT 103
68773: PUSH
68774: LD_INT 104
68776: PUSH
68777: LD_INT 105
68779: PUSH
68780: LD_INT 106
68782: PUSH
68783: LD_INT 107
68785: PUSH
68786: LD_INT 108
68788: PUSH
68789: LD_INT 109
68791: PUSH
68792: LD_INT 110
68794: PUSH
68795: LD_INT 111
68797: PUSH
68798: LD_INT 112
68800: PUSH
68801: LD_INT 113
68803: PUSH
68804: LD_INT 114
68806: PUSH
68807: LD_INT 116
68809: PUSH
68810: LD_INT 117
68812: PUSH
68813: LD_INT 118
68815: PUSH
68816: EMPTY
68817: LIST
68818: LIST
68819: LIST
68820: LIST
68821: LIST
68822: LIST
68823: LIST
68824: LIST
68825: LIST
68826: LIST
68827: LIST
68828: LIST
68829: LIST
68830: LIST
68831: LIST
68832: LIST
68833: LIST
68834: PUSH
68835: EMPTY
68836: LIST
68837: LIST
68838: ST_TO_ADDR
68839: GO 69614
68841: LD_INT 16
68843: DOUBLE
68844: EQUAL
68845: IFTRUE 68849
68847: GO 68985
68849: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 17 :
68850: LD_ADDR_VAR 0 2
68854: PUSH
68855: LD_INT 2
68857: PUSH
68858: LD_INT 4
68860: PUSH
68861: LD_INT 5
68863: PUSH
68864: LD_INT 7
68866: PUSH
68867: LD_INT 11
68869: PUSH
68870: LD_INT 12
68872: PUSH
68873: LD_INT 15
68875: PUSH
68876: LD_INT 16
68878: PUSH
68879: LD_INT 20
68881: PUSH
68882: LD_INT 21
68884: PUSH
68885: LD_INT 22
68887: PUSH
68888: LD_INT 23
68890: PUSH
68891: LD_INT 25
68893: PUSH
68894: LD_INT 26
68896: PUSH
68897: LD_INT 30
68899: PUSH
68900: LD_INT 31
68902: PUSH
68903: LD_INT 32
68905: PUSH
68906: LD_INT 33
68908: PUSH
68909: LD_INT 34
68911: PUSH
68912: EMPTY
68913: LIST
68914: LIST
68915: LIST
68916: LIST
68917: LIST
68918: LIST
68919: LIST
68920: LIST
68921: LIST
68922: LIST
68923: LIST
68924: LIST
68925: LIST
68926: LIST
68927: LIST
68928: LIST
68929: LIST
68930: LIST
68931: LIST
68932: PUSH
68933: LD_INT 101
68935: PUSH
68936: LD_INT 102
68938: PUSH
68939: LD_INT 103
68941: PUSH
68942: LD_INT 106
68944: PUSH
68945: LD_INT 108
68947: PUSH
68948: LD_INT 112
68950: PUSH
68951: LD_INT 113
68953: PUSH
68954: LD_INT 114
68956: PUSH
68957: LD_INT 116
68959: PUSH
68960: LD_INT 117
68962: PUSH
68963: LD_INT 118
68965: PUSH
68966: EMPTY
68967: LIST
68968: LIST
68969: LIST
68970: LIST
68971: LIST
68972: LIST
68973: LIST
68974: LIST
68975: LIST
68976: LIST
68977: LIST
68978: PUSH
68979: EMPTY
68980: LIST
68981: LIST
68982: ST_TO_ADDR
68983: GO 69614
68985: LD_INT 17
68987: DOUBLE
68988: EQUAL
68989: IFTRUE 68993
68991: GO 69217
68993: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 18 :
68994: LD_ADDR_VAR 0 2
68998: PUSH
68999: LD_INT 1
69001: PUSH
69002: LD_INT 2
69004: PUSH
69005: LD_INT 3
69007: PUSH
69008: LD_INT 4
69010: PUSH
69011: LD_INT 5
69013: PUSH
69014: LD_INT 6
69016: PUSH
69017: LD_INT 7
69019: PUSH
69020: LD_INT 8
69022: PUSH
69023: LD_INT 9
69025: PUSH
69026: LD_INT 10
69028: PUSH
69029: LD_INT 11
69031: PUSH
69032: LD_INT 12
69034: PUSH
69035: LD_INT 13
69037: PUSH
69038: LD_INT 14
69040: PUSH
69041: LD_INT 15
69043: PUSH
69044: LD_INT 16
69046: PUSH
69047: LD_INT 17
69049: PUSH
69050: LD_INT 18
69052: PUSH
69053: LD_INT 19
69055: PUSH
69056: LD_INT 20
69058: PUSH
69059: LD_INT 21
69061: PUSH
69062: LD_INT 22
69064: PUSH
69065: LD_INT 23
69067: PUSH
69068: LD_INT 24
69070: PUSH
69071: LD_INT 25
69073: PUSH
69074: LD_INT 26
69076: PUSH
69077: LD_INT 27
69079: PUSH
69080: LD_INT 28
69082: PUSH
69083: LD_INT 29
69085: PUSH
69086: LD_INT 30
69088: PUSH
69089: LD_INT 31
69091: PUSH
69092: LD_INT 32
69094: PUSH
69095: LD_INT 33
69097: PUSH
69098: LD_INT 34
69100: PUSH
69101: LD_INT 36
69103: PUSH
69104: EMPTY
69105: LIST
69106: LIST
69107: LIST
69108: LIST
69109: LIST
69110: LIST
69111: LIST
69112: LIST
69113: LIST
69114: LIST
69115: LIST
69116: LIST
69117: LIST
69118: LIST
69119: LIST
69120: LIST
69121: LIST
69122: LIST
69123: LIST
69124: LIST
69125: LIST
69126: LIST
69127: LIST
69128: LIST
69129: LIST
69130: LIST
69131: LIST
69132: LIST
69133: LIST
69134: LIST
69135: LIST
69136: LIST
69137: LIST
69138: LIST
69139: LIST
69140: PUSH
69141: LD_INT 101
69143: PUSH
69144: LD_INT 102
69146: PUSH
69147: LD_INT 103
69149: PUSH
69150: LD_INT 104
69152: PUSH
69153: LD_INT 105
69155: PUSH
69156: LD_INT 106
69158: PUSH
69159: LD_INT 107
69161: PUSH
69162: LD_INT 108
69164: PUSH
69165: LD_INT 109
69167: PUSH
69168: LD_INT 110
69170: PUSH
69171: LD_INT 111
69173: PUSH
69174: LD_INT 112
69176: PUSH
69177: LD_INT 113
69179: PUSH
69180: LD_INT 114
69182: PUSH
69183: LD_INT 116
69185: PUSH
69186: LD_INT 117
69188: PUSH
69189: LD_INT 118
69191: PUSH
69192: EMPTY
69193: LIST
69194: LIST
69195: LIST
69196: LIST
69197: LIST
69198: LIST
69199: LIST
69200: LIST
69201: LIST
69202: LIST
69203: LIST
69204: LIST
69205: LIST
69206: LIST
69207: LIST
69208: LIST
69209: LIST
69210: PUSH
69211: EMPTY
69212: LIST
69213: LIST
69214: ST_TO_ADDR
69215: GO 69614
69217: LD_INT 18
69219: DOUBLE
69220: EQUAL
69221: IFTRUE 69225
69223: GO 69373
69225: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; 19 :
69226: LD_ADDR_VAR 0 2
69230: PUSH
69231: LD_INT 2
69233: PUSH
69234: LD_INT 4
69236: PUSH
69237: LD_INT 5
69239: PUSH
69240: LD_INT 7
69242: PUSH
69243: LD_INT 11
69245: PUSH
69246: LD_INT 12
69248: PUSH
69249: LD_INT 15
69251: PUSH
69252: LD_INT 16
69254: PUSH
69255: LD_INT 20
69257: PUSH
69258: LD_INT 21
69260: PUSH
69261: LD_INT 22
69263: PUSH
69264: LD_INT 23
69266: PUSH
69267: LD_INT 25
69269: PUSH
69270: LD_INT 26
69272: PUSH
69273: LD_INT 30
69275: PUSH
69276: LD_INT 31
69278: PUSH
69279: LD_INT 32
69281: PUSH
69282: LD_INT 33
69284: PUSH
69285: LD_INT 34
69287: PUSH
69288: LD_INT 35
69290: PUSH
69291: LD_INT 36
69293: PUSH
69294: EMPTY
69295: LIST
69296: LIST
69297: LIST
69298: LIST
69299: LIST
69300: LIST
69301: LIST
69302: LIST
69303: LIST
69304: LIST
69305: LIST
69306: LIST
69307: LIST
69308: LIST
69309: LIST
69310: LIST
69311: LIST
69312: LIST
69313: LIST
69314: LIST
69315: LIST
69316: PUSH
69317: LD_INT 101
69319: PUSH
69320: LD_INT 102
69322: PUSH
69323: LD_INT 103
69325: PUSH
69326: LD_INT 106
69328: PUSH
69329: LD_INT 108
69331: PUSH
69332: LD_INT 112
69334: PUSH
69335: LD_INT 113
69337: PUSH
69338: LD_INT 114
69340: PUSH
69341: LD_INT 115
69343: PUSH
69344: LD_INT 116
69346: PUSH
69347: LD_INT 117
69349: PUSH
69350: LD_INT 118
69352: PUSH
69353: EMPTY
69354: LIST
69355: LIST
69356: LIST
69357: LIST
69358: LIST
69359: LIST
69360: LIST
69361: LIST
69362: LIST
69363: LIST
69364: LIST
69365: LIST
69366: PUSH
69367: EMPTY
69368: LIST
69369: LIST
69370: ST_TO_ADDR
69371: GO 69614
69373: LD_INT 19
69375: DOUBLE
69376: EQUAL
69377: IFTRUE 69381
69379: GO 69613
69381: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; end ;
69382: LD_ADDR_VAR 0 2
69386: PUSH
69387: LD_INT 1
69389: PUSH
69390: LD_INT 2
69392: PUSH
69393: LD_INT 3
69395: PUSH
69396: LD_INT 4
69398: PUSH
69399: LD_INT 5
69401: PUSH
69402: LD_INT 6
69404: PUSH
69405: LD_INT 7
69407: PUSH
69408: LD_INT 8
69410: PUSH
69411: LD_INT 9
69413: PUSH
69414: LD_INT 10
69416: PUSH
69417: LD_INT 11
69419: PUSH
69420: LD_INT 12
69422: PUSH
69423: LD_INT 13
69425: PUSH
69426: LD_INT 14
69428: PUSH
69429: LD_INT 15
69431: PUSH
69432: LD_INT 16
69434: PUSH
69435: LD_INT 17
69437: PUSH
69438: LD_INT 18
69440: PUSH
69441: LD_INT 19
69443: PUSH
69444: LD_INT 20
69446: PUSH
69447: LD_INT 21
69449: PUSH
69450: LD_INT 22
69452: PUSH
69453: LD_INT 23
69455: PUSH
69456: LD_INT 24
69458: PUSH
69459: LD_INT 25
69461: PUSH
69462: LD_INT 26
69464: PUSH
69465: LD_INT 27
69467: PUSH
69468: LD_INT 28
69470: PUSH
69471: LD_INT 29
69473: PUSH
69474: LD_INT 30
69476: PUSH
69477: LD_INT 31
69479: PUSH
69480: LD_INT 32
69482: PUSH
69483: LD_INT 33
69485: PUSH
69486: LD_INT 34
69488: PUSH
69489: LD_INT 35
69491: PUSH
69492: LD_INT 36
69494: PUSH
69495: EMPTY
69496: LIST
69497: LIST
69498: LIST
69499: LIST
69500: LIST
69501: LIST
69502: LIST
69503: LIST
69504: LIST
69505: LIST
69506: LIST
69507: LIST
69508: LIST
69509: LIST
69510: LIST
69511: LIST
69512: LIST
69513: LIST
69514: LIST
69515: LIST
69516: LIST
69517: LIST
69518: LIST
69519: LIST
69520: LIST
69521: LIST
69522: LIST
69523: LIST
69524: LIST
69525: LIST
69526: LIST
69527: LIST
69528: LIST
69529: LIST
69530: LIST
69531: LIST
69532: PUSH
69533: LD_INT 101
69535: PUSH
69536: LD_INT 102
69538: PUSH
69539: LD_INT 103
69541: PUSH
69542: LD_INT 104
69544: PUSH
69545: LD_INT 105
69547: PUSH
69548: LD_INT 106
69550: PUSH
69551: LD_INT 107
69553: PUSH
69554: LD_INT 108
69556: PUSH
69557: LD_INT 109
69559: PUSH
69560: LD_INT 110
69562: PUSH
69563: LD_INT 111
69565: PUSH
69566: LD_INT 112
69568: PUSH
69569: LD_INT 113
69571: PUSH
69572: LD_INT 114
69574: PUSH
69575: LD_INT 115
69577: PUSH
69578: LD_INT 116
69580: PUSH
69581: LD_INT 117
69583: PUSH
69584: LD_INT 118
69586: PUSH
69587: EMPTY
69588: LIST
69589: LIST
69590: LIST
69591: LIST
69592: LIST
69593: LIST
69594: LIST
69595: LIST
69596: LIST
69597: LIST
69598: LIST
69599: LIST
69600: LIST
69601: LIST
69602: LIST
69603: LIST
69604: LIST
69605: LIST
69606: PUSH
69607: EMPTY
69608: LIST
69609: LIST
69610: ST_TO_ADDR
69611: GO 69614
69613: POP
// end else
69614: GO 69845
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ;
69616: LD_ADDR_VAR 0 2
69620: PUSH
69621: LD_INT 1
69623: PUSH
69624: LD_INT 2
69626: PUSH
69627: LD_INT 3
69629: PUSH
69630: LD_INT 4
69632: PUSH
69633: LD_INT 5
69635: PUSH
69636: LD_INT 6
69638: PUSH
69639: LD_INT 7
69641: PUSH
69642: LD_INT 8
69644: PUSH
69645: LD_INT 9
69647: PUSH
69648: LD_INT 10
69650: PUSH
69651: LD_INT 11
69653: PUSH
69654: LD_INT 12
69656: PUSH
69657: LD_INT 13
69659: PUSH
69660: LD_INT 14
69662: PUSH
69663: LD_INT 15
69665: PUSH
69666: LD_INT 16
69668: PUSH
69669: LD_INT 17
69671: PUSH
69672: LD_INT 18
69674: PUSH
69675: LD_INT 19
69677: PUSH
69678: LD_INT 20
69680: PUSH
69681: LD_INT 21
69683: PUSH
69684: LD_INT 22
69686: PUSH
69687: LD_INT 23
69689: PUSH
69690: LD_INT 24
69692: PUSH
69693: LD_INT 25
69695: PUSH
69696: LD_INT 26
69698: PUSH
69699: LD_INT 27
69701: PUSH
69702: LD_INT 28
69704: PUSH
69705: LD_INT 29
69707: PUSH
69708: LD_INT 30
69710: PUSH
69711: LD_INT 31
69713: PUSH
69714: LD_INT 32
69716: PUSH
69717: LD_INT 33
69719: PUSH
69720: LD_INT 34
69722: PUSH
69723: LD_INT 35
69725: PUSH
69726: LD_INT 36
69728: PUSH
69729: EMPTY
69730: LIST
69731: LIST
69732: LIST
69733: LIST
69734: LIST
69735: LIST
69736: LIST
69737: LIST
69738: LIST
69739: LIST
69740: LIST
69741: LIST
69742: LIST
69743: LIST
69744: LIST
69745: LIST
69746: LIST
69747: LIST
69748: LIST
69749: LIST
69750: LIST
69751: LIST
69752: LIST
69753: LIST
69754: LIST
69755: LIST
69756: LIST
69757: LIST
69758: LIST
69759: LIST
69760: LIST
69761: LIST
69762: LIST
69763: LIST
69764: LIST
69765: LIST
69766: PUSH
69767: LD_INT 101
69769: PUSH
69770: LD_INT 102
69772: PUSH
69773: LD_INT 103
69775: PUSH
69776: LD_INT 104
69778: PUSH
69779: LD_INT 105
69781: PUSH
69782: LD_INT 106
69784: PUSH
69785: LD_INT 107
69787: PUSH
69788: LD_INT 108
69790: PUSH
69791: LD_INT 109
69793: PUSH
69794: LD_INT 110
69796: PUSH
69797: LD_INT 111
69799: PUSH
69800: LD_INT 112
69802: PUSH
69803: LD_INT 113
69805: PUSH
69806: LD_INT 114
69808: PUSH
69809: LD_INT 115
69811: PUSH
69812: LD_INT 116
69814: PUSH
69815: LD_INT 117
69817: PUSH
69818: LD_INT 118
69820: PUSH
69821: EMPTY
69822: LIST
69823: LIST
69824: LIST
69825: LIST
69826: LIST
69827: LIST
69828: LIST
69829: LIST
69830: LIST
69831: LIST
69832: LIST
69833: LIST
69834: LIST
69835: LIST
69836: LIST
69837: LIST
69838: LIST
69839: LIST
69840: PUSH
69841: EMPTY
69842: LIST
69843: LIST
69844: ST_TO_ADDR
// if result then
69845: LD_VAR 0 2
69849: IFFALSE 70635
// begin normal :=  ;
69851: LD_ADDR_VAR 0 5
69855: PUSH
69856: LD_STRING 
69858: ST_TO_ADDR
// hardcore :=  ;
69859: LD_ADDR_VAR 0 6
69863: PUSH
69864: LD_STRING 
69866: ST_TO_ADDR
// active :=  ;
69867: LD_ADDR_VAR 0 7
69871: PUSH
69872: LD_STRING 
69874: ST_TO_ADDR
// for i = 1 to normalCounter do
69875: LD_ADDR_VAR 0 8
69879: PUSH
69880: DOUBLE
69881: LD_INT 1
69883: DEC
69884: ST_TO_ADDR
69885: LD_EXP 98
69889: PUSH
69890: FOR_TO
69891: IFFALSE 69992
// begin tmp := 0 ;
69893: LD_ADDR_VAR 0 3
69897: PUSH
69898: LD_STRING 0
69900: ST_TO_ADDR
// if result [ 1 ] then
69901: LD_VAR 0 2
69905: PUSH
69906: LD_INT 1
69908: ARRAY
69909: IFFALSE 69974
// if result [ 1 ] [ 1 ] = i then
69911: LD_VAR 0 2
69915: PUSH
69916: LD_INT 1
69918: ARRAY
69919: PUSH
69920: LD_INT 1
69922: ARRAY
69923: PUSH
69924: LD_VAR 0 8
69928: EQUAL
69929: IFFALSE 69974
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
69931: LD_ADDR_VAR 0 2
69935: PUSH
69936: LD_VAR 0 2
69940: PPUSH
69941: LD_INT 1
69943: PPUSH
69944: LD_VAR 0 2
69948: PUSH
69949: LD_INT 1
69951: ARRAY
69952: PPUSH
69953: LD_INT 1
69955: PPUSH
69956: CALL_OW 3
69960: PPUSH
69961: CALL_OW 1
69965: ST_TO_ADDR
// tmp := 1 ;
69966: LD_ADDR_VAR 0 3
69970: PUSH
69971: LD_STRING 1
69973: ST_TO_ADDR
// end ; normal := normal & tmp ;
69974: LD_ADDR_VAR 0 5
69978: PUSH
69979: LD_VAR 0 5
69983: PUSH
69984: LD_VAR 0 3
69988: STR
69989: ST_TO_ADDR
// end ;
69990: GO 69890
69992: POP
69993: POP
// for i = 1 to hardcoreCounter do
69994: LD_ADDR_VAR 0 8
69998: PUSH
69999: DOUBLE
70000: LD_INT 1
70002: DEC
70003: ST_TO_ADDR
70004: LD_EXP 99
70008: PUSH
70009: FOR_TO
70010: IFFALSE 70115
// begin tmp := 0 ;
70012: LD_ADDR_VAR 0 3
70016: PUSH
70017: LD_STRING 0
70019: ST_TO_ADDR
// if result [ 2 ] then
70020: LD_VAR 0 2
70024: PUSH
70025: LD_INT 2
70027: ARRAY
70028: IFFALSE 70097
// if result [ 2 ] [ 1 ] = 100 + i then
70030: LD_VAR 0 2
70034: PUSH
70035: LD_INT 2
70037: ARRAY
70038: PUSH
70039: LD_INT 1
70041: ARRAY
70042: PUSH
70043: LD_INT 100
70045: PUSH
70046: LD_VAR 0 8
70050: PLUS
70051: EQUAL
70052: IFFALSE 70097
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
70054: LD_ADDR_VAR 0 2
70058: PUSH
70059: LD_VAR 0 2
70063: PPUSH
70064: LD_INT 2
70066: PPUSH
70067: LD_VAR 0 2
70071: PUSH
70072: LD_INT 2
70074: ARRAY
70075: PPUSH
70076: LD_INT 1
70078: PPUSH
70079: CALL_OW 3
70083: PPUSH
70084: CALL_OW 1
70088: ST_TO_ADDR
// tmp := 1 ;
70089: LD_ADDR_VAR 0 3
70093: PUSH
70094: LD_STRING 1
70096: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
70097: LD_ADDR_VAR 0 6
70101: PUSH
70102: LD_VAR 0 6
70106: PUSH
70107: LD_VAR 0 3
70111: STR
70112: ST_TO_ADDR
// end ;
70113: GO 70009
70115: POP
70116: POP
// if isGameLoad then
70117: LD_VAR 0 1
70121: IFFALSE 70596
// begin flags := [ sRocket , sSpeed , sEngine , sSpec , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sKamikadze , sTroll , sSlow , sLack , sTank , sRemote , sPowell , sTeleport , sOilTower , sShovel , sSheik , sEarthquake , sAI , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sSold , sDiff , sFog , sReset , sSun , sTiger , sBomb , sWound , sBetray , sContamin , sOil , sStu , sBazooka , sMortar , sRanger , sComputer , s30 , s60 ] ;
70123: LD_ADDR_VAR 0 4
70127: PUSH
70128: LD_EXP 102
70132: PUSH
70133: LD_EXP 101
70137: PUSH
70138: LD_EXP 103
70142: PUSH
70143: LD_EXP 100
70147: PUSH
70148: LD_EXP 104
70152: PUSH
70153: LD_EXP 105
70157: PUSH
70158: LD_EXP 106
70162: PUSH
70163: LD_EXP 107
70167: PUSH
70168: LD_EXP 108
70172: PUSH
70173: LD_EXP 109
70177: PUSH
70178: LD_EXP 110
70182: PUSH
70183: LD_EXP 111
70187: PUSH
70188: LD_EXP 112
70192: PUSH
70193: LD_EXP 113
70197: PUSH
70198: LD_EXP 121
70202: PUSH
70203: LD_EXP 122
70207: PUSH
70208: LD_EXP 123
70212: PUSH
70213: LD_EXP 124
70217: PUSH
70218: LD_EXP 126
70222: PUSH
70223: LD_EXP 127
70227: PUSH
70228: LD_EXP 128
70232: PUSH
70233: LD_EXP 131
70237: PUSH
70238: LD_EXP 133
70242: PUSH
70243: LD_EXP 134
70247: PUSH
70248: LD_EXP 135
70252: PUSH
70253: LD_EXP 137
70257: PUSH
70258: LD_EXP 138
70262: PUSH
70263: LD_EXP 141
70267: PUSH
70268: LD_EXP 142
70272: PUSH
70273: LD_EXP 143
70277: PUSH
70278: LD_EXP 144
70282: PUSH
70283: LD_EXP 145
70287: PUSH
70288: LD_EXP 146
70292: PUSH
70293: LD_EXP 147
70297: PUSH
70298: LD_EXP 148
70302: PUSH
70303: LD_EXP 149
70307: PUSH
70308: LD_EXP 114
70312: PUSH
70313: LD_EXP 115
70317: PUSH
70318: LD_EXP 118
70322: PUSH
70323: LD_EXP 119
70327: PUSH
70328: LD_EXP 120
70332: PUSH
70333: LD_EXP 116
70337: PUSH
70338: LD_EXP 117
70342: PUSH
70343: LD_EXP 125
70347: PUSH
70348: LD_EXP 129
70352: PUSH
70353: LD_EXP 130
70357: PUSH
70358: LD_EXP 132
70362: PUSH
70363: LD_EXP 136
70367: PUSH
70368: LD_EXP 139
70372: PUSH
70373: LD_EXP 140
70377: PUSH
70378: LD_EXP 150
70382: PUSH
70383: LD_EXP 151
70387: PUSH
70388: LD_EXP 152
70392: PUSH
70393: LD_EXP 153
70397: PUSH
70398: EMPTY
70399: LIST
70400: LIST
70401: LIST
70402: LIST
70403: LIST
70404: LIST
70405: LIST
70406: LIST
70407: LIST
70408: LIST
70409: LIST
70410: LIST
70411: LIST
70412: LIST
70413: LIST
70414: LIST
70415: LIST
70416: LIST
70417: LIST
70418: LIST
70419: LIST
70420: LIST
70421: LIST
70422: LIST
70423: LIST
70424: LIST
70425: LIST
70426: LIST
70427: LIST
70428: LIST
70429: LIST
70430: LIST
70431: LIST
70432: LIST
70433: LIST
70434: LIST
70435: LIST
70436: LIST
70437: LIST
70438: LIST
70439: LIST
70440: LIST
70441: LIST
70442: LIST
70443: LIST
70444: LIST
70445: LIST
70446: LIST
70447: LIST
70448: LIST
70449: LIST
70450: LIST
70451: LIST
70452: LIST
70453: ST_TO_ADDR
// tmp :=  ;
70454: LD_ADDR_VAR 0 3
70458: PUSH
70459: LD_STRING 
70461: ST_TO_ADDR
// for i = 1 to normalCounter do
70462: LD_ADDR_VAR 0 8
70466: PUSH
70467: DOUBLE
70468: LD_INT 1
70470: DEC
70471: ST_TO_ADDR
70472: LD_EXP 98
70476: PUSH
70477: FOR_TO
70478: IFFALSE 70514
// begin if flags [ i ] then
70480: LD_VAR 0 4
70484: PUSH
70485: LD_VAR 0 8
70489: ARRAY
70490: IFFALSE 70512
// tmp := tmp & i & ; ;
70492: LD_ADDR_VAR 0 3
70496: PUSH
70497: LD_VAR 0 3
70501: PUSH
70502: LD_VAR 0 8
70506: STR
70507: PUSH
70508: LD_STRING ;
70510: STR
70511: ST_TO_ADDR
// end ;
70512: GO 70477
70514: POP
70515: POP
// for i = 1 to hardcoreCounter do
70516: LD_ADDR_VAR 0 8
70520: PUSH
70521: DOUBLE
70522: LD_INT 1
70524: DEC
70525: ST_TO_ADDR
70526: LD_EXP 99
70530: PUSH
70531: FOR_TO
70532: IFFALSE 70578
// begin if flags [ normalCounter + i ] then
70534: LD_VAR 0 4
70538: PUSH
70539: LD_EXP 98
70543: PUSH
70544: LD_VAR 0 8
70548: PLUS
70549: ARRAY
70550: IFFALSE 70576
// tmp := tmp & ( 100 + i ) & ; ;
70552: LD_ADDR_VAR 0 3
70556: PUSH
70557: LD_VAR 0 3
70561: PUSH
70562: LD_INT 100
70564: PUSH
70565: LD_VAR 0 8
70569: PLUS
70570: STR
70571: PUSH
70572: LD_STRING ;
70574: STR
70575: ST_TO_ADDR
// end ;
70576: GO 70531
70578: POP
70579: POP
// if tmp then
70580: LD_VAR 0 3
70584: IFFALSE 70596
// active := tmp ;
70586: LD_ADDR_VAR 0 7
70590: PUSH
70591: LD_VAR 0 3
70595: ST_TO_ADDR
// end ; ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & "," & active & ") ) ;
70596: LD_STRING getStreamItemsFromMission("
70598: PUSH
70599: LD_VAR 0 5
70603: STR
70604: PUSH
70605: LD_STRING ","
70607: STR
70608: PUSH
70609: LD_VAR 0 6
70613: STR
70614: PUSH
70615: LD_STRING ","
70617: STR
70618: PUSH
70619: LD_VAR 0 7
70623: STR
70624: PUSH
70625: LD_STRING ")
70627: STR
70628: PPUSH
70629: CALL_OW 559
// end else
70633: GO 70642
// ToLua ( getStreamItemsFromMission("","","") ) ;
70635: LD_STRING getStreamItemsFromMission("","","")
70637: PPUSH
70638: CALL_OW 559
// end ;
70642: LD_VAR 0 2
70646: RET
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
70647: LD_EXP 97
70651: PUSH
70652: LD_EXP 102
70656: AND
70657: IFFALSE 70781
70659: GO 70661
70661: DISABLE
70662: LD_INT 0
70664: PPUSH
70665: PPUSH
// begin enable ;
70666: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
70667: LD_ADDR_VAR 0 2
70671: PUSH
70672: LD_INT 22
70674: PUSH
70675: LD_OWVAR 2
70679: PUSH
70680: EMPTY
70681: LIST
70682: LIST
70683: PUSH
70684: LD_INT 2
70686: PUSH
70687: LD_INT 34
70689: PUSH
70690: LD_INT 7
70692: PUSH
70693: EMPTY
70694: LIST
70695: LIST
70696: PUSH
70697: LD_INT 34
70699: PUSH
70700: LD_INT 45
70702: PUSH
70703: EMPTY
70704: LIST
70705: LIST
70706: PUSH
70707: LD_INT 34
70709: PUSH
70710: LD_INT 28
70712: PUSH
70713: EMPTY
70714: LIST
70715: LIST
70716: PUSH
70717: LD_INT 34
70719: PUSH
70720: LD_INT 47
70722: PUSH
70723: EMPTY
70724: LIST
70725: LIST
70726: PUSH
70727: EMPTY
70728: LIST
70729: LIST
70730: LIST
70731: LIST
70732: LIST
70733: PUSH
70734: EMPTY
70735: LIST
70736: LIST
70737: PPUSH
70738: CALL_OW 69
70742: ST_TO_ADDR
// if not tmp then
70743: LD_VAR 0 2
70747: NOT
70748: IFFALSE 70752
// exit ;
70750: GO 70781
// for i in tmp do
70752: LD_ADDR_VAR 0 1
70756: PUSH
70757: LD_VAR 0 2
70761: PUSH
70762: FOR_IN
70763: IFFALSE 70779
// begin SetLives ( i , 0 ) ;
70765: LD_VAR 0 1
70769: PPUSH
70770: LD_INT 0
70772: PPUSH
70773: CALL_OW 234
// end ;
70777: GO 70762
70779: POP
70780: POP
// end ;
70781: PPOPN 2
70783: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
70784: LD_EXP 97
70788: PUSH
70789: LD_EXP 103
70793: AND
70794: IFFALSE 70878
70796: GO 70798
70798: DISABLE
70799: LD_INT 0
70801: PPUSH
70802: PPUSH
// begin enable ;
70803: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
70804: LD_ADDR_VAR 0 2
70808: PUSH
70809: LD_INT 22
70811: PUSH
70812: LD_OWVAR 2
70816: PUSH
70817: EMPTY
70818: LIST
70819: LIST
70820: PUSH
70821: LD_INT 32
70823: PUSH
70824: LD_INT 3
70826: PUSH
70827: EMPTY
70828: LIST
70829: LIST
70830: PUSH
70831: EMPTY
70832: LIST
70833: LIST
70834: PPUSH
70835: CALL_OW 69
70839: ST_TO_ADDR
// if not tmp then
70840: LD_VAR 0 2
70844: NOT
70845: IFFALSE 70849
// exit ;
70847: GO 70878
// for i in tmp do
70849: LD_ADDR_VAR 0 1
70853: PUSH
70854: LD_VAR 0 2
70858: PUSH
70859: FOR_IN
70860: IFFALSE 70876
// begin SetLives ( i , 0 ) ;
70862: LD_VAR 0 1
70866: PPUSH
70867: LD_INT 0
70869: PPUSH
70870: CALL_OW 234
// end ;
70874: GO 70859
70876: POP
70877: POP
// end ;
70878: PPOPN 2
70880: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
70881: LD_EXP 97
70885: PUSH
70886: LD_EXP 100
70890: AND
70891: IFFALSE 70984
70893: GO 70895
70895: DISABLE
70896: LD_INT 0
70898: PPUSH
// begin enable ;
70899: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
70900: LD_ADDR_VAR 0 1
70904: PUSH
70905: LD_INT 22
70907: PUSH
70908: LD_OWVAR 2
70912: PUSH
70913: EMPTY
70914: LIST
70915: LIST
70916: PUSH
70917: LD_INT 2
70919: PUSH
70920: LD_INT 25
70922: PUSH
70923: LD_INT 5
70925: PUSH
70926: EMPTY
70927: LIST
70928: LIST
70929: PUSH
70930: LD_INT 25
70932: PUSH
70933: LD_INT 9
70935: PUSH
70936: EMPTY
70937: LIST
70938: LIST
70939: PUSH
70940: LD_INT 25
70942: PUSH
70943: LD_INT 8
70945: PUSH
70946: EMPTY
70947: LIST
70948: LIST
70949: PUSH
70950: EMPTY
70951: LIST
70952: LIST
70953: LIST
70954: LIST
70955: PUSH
70956: EMPTY
70957: LIST
70958: LIST
70959: PPUSH
70960: CALL_OW 69
70964: PUSH
70965: FOR_IN
70966: IFFALSE 70982
// begin SetClass ( i , 1 ) ;
70968: LD_VAR 0 1
70972: PPUSH
70973: LD_INT 1
70975: PPUSH
70976: CALL_OW 336
// end ;
70980: GO 70965
70982: POP
70983: POP
// end ;
70984: PPOPN 1
70986: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
70987: LD_EXP 97
70991: PUSH
70992: LD_EXP 101
70996: AND
70997: PUSH
70998: LD_OWVAR 65
71002: PUSH
71003: LD_INT 7
71005: LESS
71006: AND
71007: IFFALSE 71021
71009: GO 71011
71011: DISABLE
// begin enable ;
71012: ENABLE
// game_speed := 7 ;
71013: LD_ADDR_OWVAR 65
71017: PUSH
71018: LD_INT 7
71020: ST_TO_ADDR
// end ;
71021: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
71022: LD_EXP 97
71026: PUSH
71027: LD_EXP 104
71031: AND
71032: IFFALSE 71234
71034: GO 71036
71036: DISABLE
71037: LD_INT 0
71039: PPUSH
71040: PPUSH
71041: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
71042: LD_ADDR_VAR 0 3
71046: PUSH
71047: LD_INT 81
71049: PUSH
71050: LD_OWVAR 2
71054: PUSH
71055: EMPTY
71056: LIST
71057: LIST
71058: PUSH
71059: LD_INT 21
71061: PUSH
71062: LD_INT 1
71064: PUSH
71065: EMPTY
71066: LIST
71067: LIST
71068: PUSH
71069: EMPTY
71070: LIST
71071: LIST
71072: PPUSH
71073: CALL_OW 69
71077: ST_TO_ADDR
// if not tmp then
71078: LD_VAR 0 3
71082: NOT
71083: IFFALSE 71087
// exit ;
71085: GO 71234
// if tmp > 5 then
71087: LD_VAR 0 3
71091: PUSH
71092: LD_INT 5
71094: GREATER
71095: IFFALSE 71107
// k := 5 else
71097: LD_ADDR_VAR 0 2
71101: PUSH
71102: LD_INT 5
71104: ST_TO_ADDR
71105: GO 71117
// k := tmp ;
71107: LD_ADDR_VAR 0 2
71111: PUSH
71112: LD_VAR 0 3
71116: ST_TO_ADDR
// for i := 1 to k do
71117: LD_ADDR_VAR 0 1
71121: PUSH
71122: DOUBLE
71123: LD_INT 1
71125: DEC
71126: ST_TO_ADDR
71127: LD_VAR 0 2
71131: PUSH
71132: FOR_TO
71133: IFFALSE 71232
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
71135: LD_VAR 0 3
71139: PUSH
71140: LD_VAR 0 1
71144: ARRAY
71145: PPUSH
71146: LD_VAR 0 1
71150: PUSH
71151: LD_INT 4
71153: MOD
71154: PUSH
71155: LD_INT 1
71157: PLUS
71158: PPUSH
71159: CALL_OW 259
71163: PUSH
71164: LD_INT 10
71166: LESS
71167: IFFALSE 71230
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
71169: LD_VAR 0 3
71173: PUSH
71174: LD_VAR 0 1
71178: ARRAY
71179: PPUSH
71180: LD_VAR 0 1
71184: PUSH
71185: LD_INT 4
71187: MOD
71188: PUSH
71189: LD_INT 1
71191: PLUS
71192: PPUSH
71193: LD_VAR 0 3
71197: PUSH
71198: LD_VAR 0 1
71202: ARRAY
71203: PPUSH
71204: LD_VAR 0 1
71208: PUSH
71209: LD_INT 4
71211: MOD
71212: PUSH
71213: LD_INT 1
71215: PLUS
71216: PPUSH
71217: CALL_OW 259
71221: PUSH
71222: LD_INT 1
71224: PLUS
71225: PPUSH
71226: CALL_OW 237
71230: GO 71132
71232: POP
71233: POP
// end ;
71234: PPOPN 3
71236: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
71237: LD_EXP 97
71241: PUSH
71242: LD_EXP 105
71246: AND
71247: IFFALSE 71267
71249: GO 71251
71251: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
71252: LD_INT 4
71254: PPUSH
71255: LD_OWVAR 2
71259: PPUSH
71260: LD_INT 0
71262: PPUSH
71263: CALL_OW 324
71267: END
// every 0 0$1 trigger StreamModeActive and sShovel do
71268: LD_EXP 97
71272: PUSH
71273: LD_EXP 134
71277: AND
71278: IFFALSE 71298
71280: GO 71282
71282: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
71283: LD_INT 19
71285: PPUSH
71286: LD_OWVAR 2
71290: PPUSH
71291: LD_INT 0
71293: PPUSH
71294: CALL_OW 324
71298: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
71299: LD_EXP 97
71303: PUSH
71304: LD_EXP 106
71308: AND
71309: IFFALSE 71411
71311: GO 71313
71313: DISABLE
71314: LD_INT 0
71316: PPUSH
71317: PPUSH
// begin enable ;
71318: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
71319: LD_ADDR_VAR 0 2
71323: PUSH
71324: LD_INT 22
71326: PUSH
71327: LD_OWVAR 2
71331: PUSH
71332: EMPTY
71333: LIST
71334: LIST
71335: PUSH
71336: LD_INT 2
71338: PUSH
71339: LD_INT 34
71341: PUSH
71342: LD_INT 11
71344: PUSH
71345: EMPTY
71346: LIST
71347: LIST
71348: PUSH
71349: LD_INT 34
71351: PUSH
71352: LD_INT 30
71354: PUSH
71355: EMPTY
71356: LIST
71357: LIST
71358: PUSH
71359: EMPTY
71360: LIST
71361: LIST
71362: LIST
71363: PUSH
71364: EMPTY
71365: LIST
71366: LIST
71367: PPUSH
71368: CALL_OW 69
71372: ST_TO_ADDR
// if not tmp then
71373: LD_VAR 0 2
71377: NOT
71378: IFFALSE 71382
// exit ;
71380: GO 71411
// for i in tmp do
71382: LD_ADDR_VAR 0 1
71386: PUSH
71387: LD_VAR 0 2
71391: PUSH
71392: FOR_IN
71393: IFFALSE 71409
// begin SetLives ( i , 0 ) ;
71395: LD_VAR 0 1
71399: PPUSH
71400: LD_INT 0
71402: PPUSH
71403: CALL_OW 234
// end ;
71407: GO 71392
71409: POP
71410: POP
// end ;
71411: PPOPN 2
71413: END
// every 0 0$1 trigger StreamModeActive and sBunker do
71414: LD_EXP 97
71418: PUSH
71419: LD_EXP 107
71423: AND
71424: IFFALSE 71444
71426: GO 71428
71428: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
71429: LD_INT 32
71431: PPUSH
71432: LD_OWVAR 2
71436: PPUSH
71437: LD_INT 0
71439: PPUSH
71440: CALL_OW 324
71444: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
71445: LD_EXP 97
71449: PUSH
71450: LD_EXP 108
71454: AND
71455: IFFALSE 71636
71457: GO 71459
71459: DISABLE
71460: LD_INT 0
71462: PPUSH
71463: PPUSH
71464: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
71465: LD_ADDR_VAR 0 2
71469: PUSH
71470: LD_INT 22
71472: PUSH
71473: LD_OWVAR 2
71477: PUSH
71478: EMPTY
71479: LIST
71480: LIST
71481: PUSH
71482: LD_INT 33
71484: PUSH
71485: LD_INT 3
71487: PUSH
71488: EMPTY
71489: LIST
71490: LIST
71491: PUSH
71492: EMPTY
71493: LIST
71494: LIST
71495: PPUSH
71496: CALL_OW 69
71500: ST_TO_ADDR
// if not tmp then
71501: LD_VAR 0 2
71505: NOT
71506: IFFALSE 71510
// exit ;
71508: GO 71636
// side := 0 ;
71510: LD_ADDR_VAR 0 3
71514: PUSH
71515: LD_INT 0
71517: ST_TO_ADDR
// for i := 1 to 8 do
71518: LD_ADDR_VAR 0 1
71522: PUSH
71523: DOUBLE
71524: LD_INT 1
71526: DEC
71527: ST_TO_ADDR
71528: LD_INT 8
71530: PUSH
71531: FOR_TO
71532: IFFALSE 71580
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
71534: LD_OWVAR 2
71538: PUSH
71539: LD_VAR 0 1
71543: NONEQUAL
71544: PUSH
71545: LD_OWVAR 2
71549: PPUSH
71550: LD_VAR 0 1
71554: PPUSH
71555: CALL_OW 81
71559: PUSH
71560: LD_INT 2
71562: EQUAL
71563: AND
71564: IFFALSE 71578
// begin side := i ;
71566: LD_ADDR_VAR 0 3
71570: PUSH
71571: LD_VAR 0 1
71575: ST_TO_ADDR
// break ;
71576: GO 71580
// end ;
71578: GO 71531
71580: POP
71581: POP
// if not side then
71582: LD_VAR 0 3
71586: NOT
71587: IFFALSE 71591
// exit ;
71589: GO 71636
// for i := 1 to tmp do
71591: LD_ADDR_VAR 0 1
71595: PUSH
71596: DOUBLE
71597: LD_INT 1
71599: DEC
71600: ST_TO_ADDR
71601: LD_VAR 0 2
71605: PUSH
71606: FOR_TO
71607: IFFALSE 71634
// if Prob ( 60 ) then
71609: LD_INT 60
71611: PPUSH
71612: CALL_OW 13
71616: IFFALSE 71632
// SetSide ( i , side ) ;
71618: LD_VAR 0 1
71622: PPUSH
71623: LD_VAR 0 3
71627: PPUSH
71628: CALL_OW 235
71632: GO 71606
71634: POP
71635: POP
// end ;
71636: PPOPN 3
71638: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
71639: LD_EXP 97
71643: PUSH
71644: LD_EXP 110
71648: AND
71649: IFFALSE 71768
71651: GO 71653
71653: DISABLE
71654: LD_INT 0
71656: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
71657: LD_ADDR_VAR 0 1
71661: PUSH
71662: LD_INT 22
71664: PUSH
71665: LD_OWVAR 2
71669: PUSH
71670: EMPTY
71671: LIST
71672: LIST
71673: PUSH
71674: LD_INT 21
71676: PUSH
71677: LD_INT 1
71679: PUSH
71680: EMPTY
71681: LIST
71682: LIST
71683: PUSH
71684: LD_INT 3
71686: PUSH
71687: LD_INT 23
71689: PUSH
71690: LD_INT 0
71692: PUSH
71693: EMPTY
71694: LIST
71695: LIST
71696: PUSH
71697: EMPTY
71698: LIST
71699: LIST
71700: PUSH
71701: EMPTY
71702: LIST
71703: LIST
71704: LIST
71705: PPUSH
71706: CALL_OW 69
71710: PUSH
71711: FOR_IN
71712: IFFALSE 71766
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
71714: LD_VAR 0 1
71718: PPUSH
71719: CALL_OW 257
71723: PUSH
71724: LD_INT 1
71726: PUSH
71727: LD_INT 2
71729: PUSH
71730: LD_INT 3
71732: PUSH
71733: LD_INT 4
71735: PUSH
71736: EMPTY
71737: LIST
71738: LIST
71739: LIST
71740: LIST
71741: IN
71742: IFFALSE 71764
// SetClass ( un , rand ( 1 , 4 ) ) ;
71744: LD_VAR 0 1
71748: PPUSH
71749: LD_INT 1
71751: PPUSH
71752: LD_INT 4
71754: PPUSH
71755: CALL_OW 12
71759: PPUSH
71760: CALL_OW 336
71764: GO 71711
71766: POP
71767: POP
// end ;
71768: PPOPN 1
71770: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
71771: LD_EXP 97
71775: PUSH
71776: LD_EXP 109
71780: AND
71781: IFFALSE 71860
71783: GO 71785
71785: DISABLE
71786: LD_INT 0
71788: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
71789: LD_ADDR_VAR 0 1
71793: PUSH
71794: LD_INT 22
71796: PUSH
71797: LD_OWVAR 2
71801: PUSH
71802: EMPTY
71803: LIST
71804: LIST
71805: PUSH
71806: LD_INT 21
71808: PUSH
71809: LD_INT 3
71811: PUSH
71812: EMPTY
71813: LIST
71814: LIST
71815: PUSH
71816: EMPTY
71817: LIST
71818: LIST
71819: PPUSH
71820: CALL_OW 69
71824: ST_TO_ADDR
// if not tmp then
71825: LD_VAR 0 1
71829: NOT
71830: IFFALSE 71834
// exit ;
71832: GO 71860
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
71834: LD_VAR 0 1
71838: PUSH
71839: LD_INT 1
71841: PPUSH
71842: LD_VAR 0 1
71846: PPUSH
71847: CALL_OW 12
71851: ARRAY
71852: PPUSH
71853: LD_INT 100
71855: PPUSH
71856: CALL_OW 234
// end ;
71860: PPOPN 1
71862: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
71863: LD_EXP 97
71867: PUSH
71868: LD_EXP 111
71872: AND
71873: IFFALSE 71971
71875: GO 71877
71877: DISABLE
71878: LD_INT 0
71880: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
71881: LD_ADDR_VAR 0 1
71885: PUSH
71886: LD_INT 22
71888: PUSH
71889: LD_OWVAR 2
71893: PUSH
71894: EMPTY
71895: LIST
71896: LIST
71897: PUSH
71898: LD_INT 21
71900: PUSH
71901: LD_INT 1
71903: PUSH
71904: EMPTY
71905: LIST
71906: LIST
71907: PUSH
71908: EMPTY
71909: LIST
71910: LIST
71911: PPUSH
71912: CALL_OW 69
71916: ST_TO_ADDR
// if not tmp then
71917: LD_VAR 0 1
71921: NOT
71922: IFFALSE 71926
// exit ;
71924: GO 71971
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
71926: LD_VAR 0 1
71930: PUSH
71931: LD_INT 1
71933: PPUSH
71934: LD_VAR 0 1
71938: PPUSH
71939: CALL_OW 12
71943: ARRAY
71944: PPUSH
71945: LD_INT 1
71947: PPUSH
71948: LD_INT 4
71950: PPUSH
71951: CALL_OW 12
71955: PPUSH
71956: LD_INT 3000
71958: PPUSH
71959: LD_INT 9000
71961: PPUSH
71962: CALL_OW 12
71966: PPUSH
71967: CALL_OW 492
// end ;
71971: PPOPN 1
71973: END
// every 0 0$1 trigger StreamModeActive and sDepot do
71974: LD_EXP 97
71978: PUSH
71979: LD_EXP 112
71983: AND
71984: IFFALSE 72004
71986: GO 71988
71988: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
71989: LD_INT 1
71991: PPUSH
71992: LD_OWVAR 2
71996: PPUSH
71997: LD_INT 0
71999: PPUSH
72000: CALL_OW 324
72004: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
72005: LD_EXP 97
72009: PUSH
72010: LD_EXP 113
72014: AND
72015: IFFALSE 72098
72017: GO 72019
72019: DISABLE
72020: LD_INT 0
72022: PPUSH
72023: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
72024: LD_ADDR_VAR 0 2
72028: PUSH
72029: LD_INT 22
72031: PUSH
72032: LD_OWVAR 2
72036: PUSH
72037: EMPTY
72038: LIST
72039: LIST
72040: PUSH
72041: LD_INT 21
72043: PUSH
72044: LD_INT 3
72046: PUSH
72047: EMPTY
72048: LIST
72049: LIST
72050: PUSH
72051: EMPTY
72052: LIST
72053: LIST
72054: PPUSH
72055: CALL_OW 69
72059: ST_TO_ADDR
// if not tmp then
72060: LD_VAR 0 2
72064: NOT
72065: IFFALSE 72069
// exit ;
72067: GO 72098
// for i in tmp do
72069: LD_ADDR_VAR 0 1
72073: PUSH
72074: LD_VAR 0 2
72078: PUSH
72079: FOR_IN
72080: IFFALSE 72096
// SetBLevel ( i , 10 ) ;
72082: LD_VAR 0 1
72086: PPUSH
72087: LD_INT 10
72089: PPUSH
72090: CALL_OW 241
72094: GO 72079
72096: POP
72097: POP
// end ;
72098: PPOPN 2
72100: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
72101: LD_EXP 97
72105: PUSH
72106: LD_EXP 114
72110: AND
72111: IFFALSE 72222
72113: GO 72115
72115: DISABLE
72116: LD_INT 0
72118: PPUSH
72119: PPUSH
72120: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
72121: LD_ADDR_VAR 0 3
72125: PUSH
72126: LD_INT 22
72128: PUSH
72129: LD_OWVAR 2
72133: PUSH
72134: EMPTY
72135: LIST
72136: LIST
72137: PUSH
72138: LD_INT 25
72140: PUSH
72141: LD_INT 1
72143: PUSH
72144: EMPTY
72145: LIST
72146: LIST
72147: PUSH
72148: EMPTY
72149: LIST
72150: LIST
72151: PPUSH
72152: CALL_OW 69
72156: ST_TO_ADDR
// if not tmp then
72157: LD_VAR 0 3
72161: NOT
72162: IFFALSE 72166
// exit ;
72164: GO 72222
// un := tmp [ rand ( 1 , tmp ) ] ;
72166: LD_ADDR_VAR 0 2
72170: PUSH
72171: LD_VAR 0 3
72175: PUSH
72176: LD_INT 1
72178: PPUSH
72179: LD_VAR 0 3
72183: PPUSH
72184: CALL_OW 12
72188: ARRAY
72189: ST_TO_ADDR
// if Crawls ( un ) then
72190: LD_VAR 0 2
72194: PPUSH
72195: CALL_OW 318
72199: IFFALSE 72210
// ComWalk ( un ) ;
72201: LD_VAR 0 2
72205: PPUSH
72206: CALL_OW 138
// SetClass ( un , class_sniper ) ;
72210: LD_VAR 0 2
72214: PPUSH
72215: LD_INT 5
72217: PPUSH
72218: CALL_OW 336
// end ;
72222: PPOPN 3
72224: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 4 do
72225: LD_EXP 97
72229: PUSH
72230: LD_EXP 115
72234: AND
72235: PUSH
72236: LD_OWVAR 67
72240: PUSH
72241: LD_INT 4
72243: LESS
72244: AND
72245: IFFALSE 72264
72247: GO 72249
72249: DISABLE
// begin Difficulty := Difficulty + 1 ;
72250: LD_ADDR_OWVAR 67
72254: PUSH
72255: LD_OWVAR 67
72259: PUSH
72260: LD_INT 1
72262: PLUS
72263: ST_TO_ADDR
// end ;
72264: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
72265: LD_EXP 97
72269: PUSH
72270: LD_EXP 116
72274: AND
72275: IFFALSE 72378
72277: GO 72279
72279: DISABLE
72280: LD_INT 0
72282: PPUSH
// begin for i := 1 to 5 do
72283: LD_ADDR_VAR 0 1
72287: PUSH
72288: DOUBLE
72289: LD_INT 1
72291: DEC
72292: ST_TO_ADDR
72293: LD_INT 5
72295: PUSH
72296: FOR_TO
72297: IFFALSE 72376
// begin uc_nation := nation_nature ;
72299: LD_ADDR_OWVAR 21
72303: PUSH
72304: LD_INT 0
72306: ST_TO_ADDR
// uc_side := 0 ;
72307: LD_ADDR_OWVAR 20
72311: PUSH
72312: LD_INT 0
72314: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
72315: LD_ADDR_OWVAR 29
72319: PUSH
72320: LD_INT 12
72322: PUSH
72323: LD_INT 12
72325: PUSH
72326: EMPTY
72327: LIST
72328: LIST
72329: ST_TO_ADDR
// hc_agressivity := 20 ;
72330: LD_ADDR_OWVAR 35
72334: PUSH
72335: LD_INT 20
72337: ST_TO_ADDR
// hc_class := class_tiger ;
72338: LD_ADDR_OWVAR 28
72342: PUSH
72343: LD_INT 14
72345: ST_TO_ADDR
// hc_gallery :=  ;
72346: LD_ADDR_OWVAR 33
72350: PUSH
72351: LD_STRING 
72353: ST_TO_ADDR
// hc_name :=  ;
72354: LD_ADDR_OWVAR 26
72358: PUSH
72359: LD_STRING 
72361: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
72362: CALL_OW 44
72366: PPUSH
72367: LD_INT 0
72369: PPUSH
72370: CALL_OW 51
// end ;
72374: GO 72296
72376: POP
72377: POP
// end ;
72378: PPOPN 1
72380: END
// every 0 0$1 trigger StreamModeActive and sBomb do
72381: LD_EXP 97
72385: PUSH
72386: LD_EXP 117
72390: AND
72391: IFFALSE 72400
72393: GO 72395
72395: DISABLE
// StreamSibBomb ;
72396: CALL 72401 0 0
72400: END
// export function StreamSibBomb ; var i , x , y ; begin
72401: LD_INT 0
72403: PPUSH
72404: PPUSH
72405: PPUSH
72406: PPUSH
// result := false ;
72407: LD_ADDR_VAR 0 1
72411: PUSH
72412: LD_INT 0
72414: ST_TO_ADDR
// for i := 1 to 16 do
72415: LD_ADDR_VAR 0 2
72419: PUSH
72420: DOUBLE
72421: LD_INT 1
72423: DEC
72424: ST_TO_ADDR
72425: LD_INT 16
72427: PUSH
72428: FOR_TO
72429: IFFALSE 72628
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
72431: LD_ADDR_VAR 0 3
72435: PUSH
72436: LD_INT 10
72438: PUSH
72439: LD_INT 20
72441: PUSH
72442: LD_INT 30
72444: PUSH
72445: LD_INT 40
72447: PUSH
72448: LD_INT 50
72450: PUSH
72451: LD_INT 60
72453: PUSH
72454: LD_INT 70
72456: PUSH
72457: LD_INT 80
72459: PUSH
72460: LD_INT 90
72462: PUSH
72463: LD_INT 100
72465: PUSH
72466: LD_INT 110
72468: PUSH
72469: LD_INT 120
72471: PUSH
72472: LD_INT 130
72474: PUSH
72475: LD_INT 140
72477: PUSH
72478: LD_INT 150
72480: PUSH
72481: EMPTY
72482: LIST
72483: LIST
72484: LIST
72485: LIST
72486: LIST
72487: LIST
72488: LIST
72489: LIST
72490: LIST
72491: LIST
72492: LIST
72493: LIST
72494: LIST
72495: LIST
72496: LIST
72497: PUSH
72498: LD_INT 1
72500: PPUSH
72501: LD_INT 15
72503: PPUSH
72504: CALL_OW 12
72508: ARRAY
72509: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
72510: LD_ADDR_VAR 0 4
72514: PUSH
72515: LD_INT 10
72517: PUSH
72518: LD_INT 20
72520: PUSH
72521: LD_INT 30
72523: PUSH
72524: LD_INT 40
72526: PUSH
72527: LD_INT 50
72529: PUSH
72530: LD_INT 60
72532: PUSH
72533: LD_INT 70
72535: PUSH
72536: LD_INT 80
72538: PUSH
72539: LD_INT 90
72541: PUSH
72542: LD_INT 100
72544: PUSH
72545: LD_INT 110
72547: PUSH
72548: LD_INT 120
72550: PUSH
72551: LD_INT 130
72553: PUSH
72554: LD_INT 140
72556: PUSH
72557: LD_INT 150
72559: PUSH
72560: EMPTY
72561: LIST
72562: LIST
72563: LIST
72564: LIST
72565: LIST
72566: LIST
72567: LIST
72568: LIST
72569: LIST
72570: LIST
72571: LIST
72572: LIST
72573: LIST
72574: LIST
72575: LIST
72576: PUSH
72577: LD_INT 1
72579: PPUSH
72580: LD_INT 15
72582: PPUSH
72583: CALL_OW 12
72587: ARRAY
72588: ST_TO_ADDR
// if ValidHex ( x , y ) then
72589: LD_VAR 0 3
72593: PPUSH
72594: LD_VAR 0 4
72598: PPUSH
72599: CALL_OW 488
72603: IFFALSE 72626
// begin result := [ x , y ] ;
72605: LD_ADDR_VAR 0 1
72609: PUSH
72610: LD_VAR 0 3
72614: PUSH
72615: LD_VAR 0 4
72619: PUSH
72620: EMPTY
72621: LIST
72622: LIST
72623: ST_TO_ADDR
// break ;
72624: GO 72628
// end ; end ;
72626: GO 72428
72628: POP
72629: POP
// if result then
72630: LD_VAR 0 1
72634: IFFALSE 72694
// begin ToLua ( playSibBomb() ) ;
72636: LD_STRING playSibBomb()
72638: PPUSH
72639: CALL_OW 559
// wait ( 0 0$14 ) ;
72643: LD_INT 490
72645: PPUSH
72646: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
72650: LD_VAR 0 1
72654: PUSH
72655: LD_INT 1
72657: ARRAY
72658: PPUSH
72659: LD_VAR 0 1
72663: PUSH
72664: LD_INT 2
72666: ARRAY
72667: PPUSH
72668: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
72672: LD_VAR 0 1
72676: PUSH
72677: LD_INT 1
72679: ARRAY
72680: PPUSH
72681: LD_VAR 0 1
72685: PUSH
72686: LD_INT 2
72688: ARRAY
72689: PPUSH
72690: CALL_OW 429
// end ; end ;
72694: LD_VAR 0 1
72698: RET
// every 0 0$1 trigger StreamModeActive and sReset do
72699: LD_EXP 97
72703: PUSH
72704: LD_EXP 119
72708: AND
72709: IFFALSE 72721
72711: GO 72713
72713: DISABLE
// YouLost (  ) ;
72714: LD_STRING 
72716: PPUSH
72717: CALL_OW 104
72721: END
// every 0 0$1 trigger StreamModeActive and sFog do
72722: LD_EXP 97
72726: PUSH
72727: LD_EXP 118
72731: AND
72732: IFFALSE 72746
72734: GO 72736
72736: DISABLE
// FogOff ( your_side ) ;
72737: LD_OWVAR 2
72741: PPUSH
72742: CALL_OW 344
72746: END
// every 0 0$1 trigger StreamModeActive and sSun do
72747: LD_EXP 97
72751: PUSH
72752: LD_EXP 120
72756: AND
72757: IFFALSE 72785
72759: GO 72761
72761: DISABLE
// begin solar_recharge_percent := 0 ;
72762: LD_ADDR_OWVAR 79
72766: PUSH
72767: LD_INT 0
72769: ST_TO_ADDR
// wait ( 5 5$00 ) ;
72770: LD_INT 10500
72772: PPUSH
72773: CALL_OW 67
// solar_recharge_percent := 100 ;
72777: LD_ADDR_OWVAR 79
72781: PUSH
72782: LD_INT 100
72784: ST_TO_ADDR
// end ;
72785: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
72786: LD_EXP 97
72790: PUSH
72791: LD_EXP 121
72795: AND
72796: IFFALSE 73035
72798: GO 72800
72800: DISABLE
72801: LD_INT 0
72803: PPUSH
72804: PPUSH
72805: PPUSH
// begin tmp := [ ] ;
72806: LD_ADDR_VAR 0 3
72810: PUSH
72811: EMPTY
72812: ST_TO_ADDR
// for i := 1 to 6 do
72813: LD_ADDR_VAR 0 1
72817: PUSH
72818: DOUBLE
72819: LD_INT 1
72821: DEC
72822: ST_TO_ADDR
72823: LD_INT 6
72825: PUSH
72826: FOR_TO
72827: IFFALSE 72932
// begin uc_nation := nation_nature ;
72829: LD_ADDR_OWVAR 21
72833: PUSH
72834: LD_INT 0
72836: ST_TO_ADDR
// uc_side := 0 ;
72837: LD_ADDR_OWVAR 20
72841: PUSH
72842: LD_INT 0
72844: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
72845: LD_ADDR_OWVAR 29
72849: PUSH
72850: LD_INT 12
72852: PUSH
72853: LD_INT 12
72855: PUSH
72856: EMPTY
72857: LIST
72858: LIST
72859: ST_TO_ADDR
// hc_agressivity := 20 ;
72860: LD_ADDR_OWVAR 35
72864: PUSH
72865: LD_INT 20
72867: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
72868: LD_ADDR_OWVAR 28
72872: PUSH
72873: LD_INT 17
72875: ST_TO_ADDR
// hc_gallery :=  ;
72876: LD_ADDR_OWVAR 33
72880: PUSH
72881: LD_STRING 
72883: ST_TO_ADDR
// hc_name :=  ;
72884: LD_ADDR_OWVAR 26
72888: PUSH
72889: LD_STRING 
72891: ST_TO_ADDR
// un := CreateHuman ;
72892: LD_ADDR_VAR 0 2
72896: PUSH
72897: CALL_OW 44
72901: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
72902: LD_VAR 0 2
72906: PPUSH
72907: LD_INT 1
72909: PPUSH
72910: CALL_OW 51
// tmp := tmp ^ un ;
72914: LD_ADDR_VAR 0 3
72918: PUSH
72919: LD_VAR 0 3
72923: PUSH
72924: LD_VAR 0 2
72928: ADD
72929: ST_TO_ADDR
// end ;
72930: GO 72826
72932: POP
72933: POP
// repeat wait ( 0 0$1 ) ;
72934: LD_INT 35
72936: PPUSH
72937: CALL_OW 67
// for un in tmp do
72941: LD_ADDR_VAR 0 2
72945: PUSH
72946: LD_VAR 0 3
72950: PUSH
72951: FOR_IN
72952: IFFALSE 73026
// begin if IsDead ( un ) then
72954: LD_VAR 0 2
72958: PPUSH
72959: CALL_OW 301
72963: IFFALSE 72983
// begin tmp := tmp diff un ;
72965: LD_ADDR_VAR 0 3
72969: PUSH
72970: LD_VAR 0 3
72974: PUSH
72975: LD_VAR 0 2
72979: DIFF
72980: ST_TO_ADDR
// continue ;
72981: GO 72951
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
72983: LD_VAR 0 2
72987: PPUSH
72988: LD_INT 3
72990: PUSH
72991: LD_INT 22
72993: PUSH
72994: LD_INT 0
72996: PUSH
72997: EMPTY
72998: LIST
72999: LIST
73000: PUSH
73001: EMPTY
73002: LIST
73003: LIST
73004: PPUSH
73005: CALL_OW 69
73009: PPUSH
73010: LD_VAR 0 2
73014: PPUSH
73015: CALL_OW 74
73019: PPUSH
73020: CALL_OW 115
// end ;
73024: GO 72951
73026: POP
73027: POP
// until not tmp ;
73028: LD_VAR 0 3
73032: NOT
73033: IFFALSE 72934
// end ;
73035: PPOPN 3
73037: END
// every 0 0$1 trigger StreamModeActive and sTroll do
73038: LD_EXP 97
73042: PUSH
73043: LD_EXP 122
73047: AND
73048: IFFALSE 73102
73050: GO 73052
73052: DISABLE
// begin ToLua ( displayTroll(); ) ;
73053: LD_STRING displayTroll();
73055: PPUSH
73056: CALL_OW 559
// wait ( 3 3$00 ) ;
73060: LD_INT 6300
73062: PPUSH
73063: CALL_OW 67
// ToLua ( hideTroll(); ) ;
73067: LD_STRING hideTroll();
73069: PPUSH
73070: CALL_OW 559
// wait ( 1 1$00 ) ;
73074: LD_INT 2100
73076: PPUSH
73077: CALL_OW 67
// ToLua ( displayTroll(); ) ;
73081: LD_STRING displayTroll();
73083: PPUSH
73084: CALL_OW 559
// wait ( 1 1$00 ) ;
73088: LD_INT 2100
73090: PPUSH
73091: CALL_OW 67
// ToLua ( hideTroll(); ) ;
73095: LD_STRING hideTroll();
73097: PPUSH
73098: CALL_OW 559
// end ;
73102: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
73103: LD_EXP 97
73107: PUSH
73108: LD_EXP 123
73112: AND
73113: IFFALSE 73176
73115: GO 73117
73117: DISABLE
73118: LD_INT 0
73120: PPUSH
// begin p := 0 ;
73121: LD_ADDR_VAR 0 1
73125: PUSH
73126: LD_INT 0
73128: ST_TO_ADDR
// repeat game_speed := 1 ;
73129: LD_ADDR_OWVAR 65
73133: PUSH
73134: LD_INT 1
73136: ST_TO_ADDR
// wait ( 0 0$1 ) ;
73137: LD_INT 35
73139: PPUSH
73140: CALL_OW 67
// p := p + 1 ;
73144: LD_ADDR_VAR 0 1
73148: PUSH
73149: LD_VAR 0 1
73153: PUSH
73154: LD_INT 1
73156: PLUS
73157: ST_TO_ADDR
// until p >= 60 ;
73158: LD_VAR 0 1
73162: PUSH
73163: LD_INT 60
73165: GREATEREQUAL
73166: IFFALSE 73129
// game_speed := 4 ;
73168: LD_ADDR_OWVAR 65
73172: PUSH
73173: LD_INT 4
73175: ST_TO_ADDR
// end ;
73176: PPOPN 1
73178: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
73179: LD_EXP 97
73183: PUSH
73184: LD_EXP 124
73188: AND
73189: IFFALSE 73335
73191: GO 73193
73193: DISABLE
73194: LD_INT 0
73196: PPUSH
73197: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
73198: LD_ADDR_VAR 0 1
73202: PUSH
73203: LD_INT 22
73205: PUSH
73206: LD_OWVAR 2
73210: PUSH
73211: EMPTY
73212: LIST
73213: LIST
73214: PUSH
73215: LD_INT 2
73217: PUSH
73218: LD_INT 30
73220: PUSH
73221: LD_INT 0
73223: PUSH
73224: EMPTY
73225: LIST
73226: LIST
73227: PUSH
73228: LD_INT 30
73230: PUSH
73231: LD_INT 1
73233: PUSH
73234: EMPTY
73235: LIST
73236: LIST
73237: PUSH
73238: EMPTY
73239: LIST
73240: LIST
73241: LIST
73242: PUSH
73243: EMPTY
73244: LIST
73245: LIST
73246: PPUSH
73247: CALL_OW 69
73251: ST_TO_ADDR
// if not depot then
73252: LD_VAR 0 1
73256: NOT
73257: IFFALSE 73261
// exit ;
73259: GO 73335
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
73261: LD_ADDR_VAR 0 2
73265: PUSH
73266: LD_VAR 0 1
73270: PUSH
73271: LD_INT 1
73273: PPUSH
73274: LD_VAR 0 1
73278: PPUSH
73279: CALL_OW 12
73283: ARRAY
73284: PPUSH
73285: CALL_OW 274
73289: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
73290: LD_VAR 0 2
73294: PPUSH
73295: LD_INT 1
73297: PPUSH
73298: LD_INT 0
73300: PPUSH
73301: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
73305: LD_VAR 0 2
73309: PPUSH
73310: LD_INT 2
73312: PPUSH
73313: LD_INT 0
73315: PPUSH
73316: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
73320: LD_VAR 0 2
73324: PPUSH
73325: LD_INT 3
73327: PPUSH
73328: LD_INT 0
73330: PPUSH
73331: CALL_OW 277
// end ;
73335: PPOPN 2
73337: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
73338: LD_EXP 97
73342: PUSH
73343: LD_EXP 125
73347: AND
73348: IFFALSE 73445
73350: GO 73352
73352: DISABLE
73353: LD_INT 0
73355: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
73356: LD_ADDR_VAR 0 1
73360: PUSH
73361: LD_INT 22
73363: PUSH
73364: LD_OWVAR 2
73368: PUSH
73369: EMPTY
73370: LIST
73371: LIST
73372: PUSH
73373: LD_INT 21
73375: PUSH
73376: LD_INT 1
73378: PUSH
73379: EMPTY
73380: LIST
73381: LIST
73382: PUSH
73383: LD_INT 3
73385: PUSH
73386: LD_INT 23
73388: PUSH
73389: LD_INT 0
73391: PUSH
73392: EMPTY
73393: LIST
73394: LIST
73395: PUSH
73396: EMPTY
73397: LIST
73398: LIST
73399: PUSH
73400: EMPTY
73401: LIST
73402: LIST
73403: LIST
73404: PPUSH
73405: CALL_OW 69
73409: ST_TO_ADDR
// if not tmp then
73410: LD_VAR 0 1
73414: NOT
73415: IFFALSE 73419
// exit ;
73417: GO 73445
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
73419: LD_VAR 0 1
73423: PUSH
73424: LD_INT 1
73426: PPUSH
73427: LD_VAR 0 1
73431: PPUSH
73432: CALL_OW 12
73436: ARRAY
73437: PPUSH
73438: LD_INT 200
73440: PPUSH
73441: CALL_OW 234
// end ;
73445: PPOPN 1
73447: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
73448: LD_EXP 97
73452: PUSH
73453: LD_EXP 126
73457: AND
73458: IFFALSE 73537
73460: GO 73462
73462: DISABLE
73463: LD_INT 0
73465: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
73466: LD_ADDR_VAR 0 1
73470: PUSH
73471: LD_INT 22
73473: PUSH
73474: LD_OWVAR 2
73478: PUSH
73479: EMPTY
73480: LIST
73481: LIST
73482: PUSH
73483: LD_INT 21
73485: PUSH
73486: LD_INT 2
73488: PUSH
73489: EMPTY
73490: LIST
73491: LIST
73492: PUSH
73493: EMPTY
73494: LIST
73495: LIST
73496: PPUSH
73497: CALL_OW 69
73501: ST_TO_ADDR
// if not tmp then
73502: LD_VAR 0 1
73506: NOT
73507: IFFALSE 73511
// exit ;
73509: GO 73537
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
73511: LD_VAR 0 1
73515: PUSH
73516: LD_INT 1
73518: PPUSH
73519: LD_VAR 0 1
73523: PPUSH
73524: CALL_OW 12
73528: ARRAY
73529: PPUSH
73530: LD_INT 60
73532: PPUSH
73533: CALL_OW 234
// end ;
73537: PPOPN 1
73539: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
73540: LD_EXP 97
73544: PUSH
73545: LD_EXP 127
73549: AND
73550: IFFALSE 73649
73552: GO 73554
73554: DISABLE
73555: LD_INT 0
73557: PPUSH
73558: PPUSH
// begin enable ;
73559: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
73560: LD_ADDR_VAR 0 1
73564: PUSH
73565: LD_INT 22
73567: PUSH
73568: LD_OWVAR 2
73572: PUSH
73573: EMPTY
73574: LIST
73575: LIST
73576: PUSH
73577: LD_INT 61
73579: PUSH
73580: EMPTY
73581: LIST
73582: PUSH
73583: LD_INT 33
73585: PUSH
73586: LD_INT 2
73588: PUSH
73589: EMPTY
73590: LIST
73591: LIST
73592: PUSH
73593: EMPTY
73594: LIST
73595: LIST
73596: LIST
73597: PPUSH
73598: CALL_OW 69
73602: ST_TO_ADDR
// if not tmp then
73603: LD_VAR 0 1
73607: NOT
73608: IFFALSE 73612
// exit ;
73610: GO 73649
// for i in tmp do
73612: LD_ADDR_VAR 0 2
73616: PUSH
73617: LD_VAR 0 1
73621: PUSH
73622: FOR_IN
73623: IFFALSE 73647
// if IsControledBy ( i ) then
73625: LD_VAR 0 2
73629: PPUSH
73630: CALL_OW 312
73634: IFFALSE 73645
// ComUnlink ( i ) ;
73636: LD_VAR 0 2
73640: PPUSH
73641: CALL_OW 136
73645: GO 73622
73647: POP
73648: POP
// end ;
73649: PPOPN 2
73651: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
73652: LD_EXP 97
73656: PUSH
73657: LD_EXP 128
73661: AND
73662: IFFALSE 73802
73664: GO 73666
73666: DISABLE
73667: LD_INT 0
73669: PPUSH
73670: PPUSH
// begin ToLua ( displayPowell(); ) ;
73671: LD_STRING displayPowell();
73673: PPUSH
73674: CALL_OW 559
// uc_side := 0 ;
73678: LD_ADDR_OWVAR 20
73682: PUSH
73683: LD_INT 0
73685: ST_TO_ADDR
// uc_nation := 2 ;
73686: LD_ADDR_OWVAR 21
73690: PUSH
73691: LD_INT 2
73693: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
73694: LD_ADDR_OWVAR 37
73698: PUSH
73699: LD_INT 14
73701: ST_TO_ADDR
// vc_engine := engine_siberite ;
73702: LD_ADDR_OWVAR 39
73706: PUSH
73707: LD_INT 3
73709: ST_TO_ADDR
// vc_control := control_apeman ;
73710: LD_ADDR_OWVAR 38
73714: PUSH
73715: LD_INT 5
73717: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
73718: LD_ADDR_OWVAR 40
73722: PUSH
73723: LD_INT 29
73725: ST_TO_ADDR
// un := CreateVehicle ;
73726: LD_ADDR_VAR 0 2
73730: PUSH
73731: CALL_OW 45
73735: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
73736: LD_VAR 0 2
73740: PPUSH
73741: LD_INT 1
73743: PPUSH
73744: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
73748: LD_INT 35
73750: PPUSH
73751: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
73755: LD_VAR 0 2
73759: PPUSH
73760: LD_INT 22
73762: PUSH
73763: LD_OWVAR 2
73767: PUSH
73768: EMPTY
73769: LIST
73770: LIST
73771: PPUSH
73772: CALL_OW 69
73776: PPUSH
73777: LD_VAR 0 2
73781: PPUSH
73782: CALL_OW 74
73786: PPUSH
73787: CALL_OW 115
// until IsDead ( un ) ;
73791: LD_VAR 0 2
73795: PPUSH
73796: CALL_OW 301
73800: IFFALSE 73748
// end ;
73802: PPOPN 2
73804: END
// every 0 0$1 trigger StreamModeActive and sStu do
73805: LD_EXP 97
73809: PUSH
73810: LD_EXP 136
73814: AND
73815: IFFALSE 73831
73817: GO 73819
73819: DISABLE
// begin ToLua ( displayStucuk(); ) ;
73820: LD_STRING displayStucuk();
73822: PPUSH
73823: CALL_OW 559
// ResetFog ;
73827: CALL_OW 335
// end ;
73831: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
73832: LD_EXP 97
73836: PUSH
73837: LD_EXP 129
73841: AND
73842: IFFALSE 73983
73844: GO 73846
73846: DISABLE
73847: LD_INT 0
73849: PPUSH
73850: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
73851: LD_ADDR_VAR 0 2
73855: PUSH
73856: LD_INT 22
73858: PUSH
73859: LD_OWVAR 2
73863: PUSH
73864: EMPTY
73865: LIST
73866: LIST
73867: PUSH
73868: LD_INT 21
73870: PUSH
73871: LD_INT 1
73873: PUSH
73874: EMPTY
73875: LIST
73876: LIST
73877: PUSH
73878: EMPTY
73879: LIST
73880: LIST
73881: PPUSH
73882: CALL_OW 69
73886: ST_TO_ADDR
// if not tmp then
73887: LD_VAR 0 2
73891: NOT
73892: IFFALSE 73896
// exit ;
73894: GO 73983
// un := tmp [ rand ( 1 , tmp ) ] ;
73896: LD_ADDR_VAR 0 1
73900: PUSH
73901: LD_VAR 0 2
73905: PUSH
73906: LD_INT 1
73908: PPUSH
73909: LD_VAR 0 2
73913: PPUSH
73914: CALL_OW 12
73918: ARRAY
73919: ST_TO_ADDR
// SetSide ( un , 0 ) ;
73920: LD_VAR 0 1
73924: PPUSH
73925: LD_INT 0
73927: PPUSH
73928: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
73932: LD_VAR 0 1
73936: PPUSH
73937: LD_OWVAR 3
73941: PUSH
73942: LD_VAR 0 1
73946: DIFF
73947: PPUSH
73948: LD_VAR 0 1
73952: PPUSH
73953: CALL_OW 74
73957: PPUSH
73958: CALL_OW 115
// wait ( 0 0$20 ) ;
73962: LD_INT 700
73964: PPUSH
73965: CALL_OW 67
// SetSide ( un , your_side ) ;
73969: LD_VAR 0 1
73973: PPUSH
73974: LD_OWVAR 2
73978: PPUSH
73979: CALL_OW 235
// end ;
73983: PPOPN 2
73985: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
73986: LD_EXP 97
73990: PUSH
73991: LD_EXP 130
73995: AND
73996: IFFALSE 74102
73998: GO 74000
74000: DISABLE
74001: LD_INT 0
74003: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
74004: LD_ADDR_VAR 0 1
74008: PUSH
74009: LD_INT 22
74011: PUSH
74012: LD_OWVAR 2
74016: PUSH
74017: EMPTY
74018: LIST
74019: LIST
74020: PUSH
74021: LD_INT 2
74023: PUSH
74024: LD_INT 30
74026: PUSH
74027: LD_INT 0
74029: PUSH
74030: EMPTY
74031: LIST
74032: LIST
74033: PUSH
74034: LD_INT 30
74036: PUSH
74037: LD_INT 1
74039: PUSH
74040: EMPTY
74041: LIST
74042: LIST
74043: PUSH
74044: EMPTY
74045: LIST
74046: LIST
74047: LIST
74048: PUSH
74049: EMPTY
74050: LIST
74051: LIST
74052: PPUSH
74053: CALL_OW 69
74057: ST_TO_ADDR
// if not depot then
74058: LD_VAR 0 1
74062: NOT
74063: IFFALSE 74067
// exit ;
74065: GO 74102
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
74067: LD_VAR 0 1
74071: PUSH
74072: LD_INT 1
74074: ARRAY
74075: PPUSH
74076: CALL_OW 250
74080: PPUSH
74081: LD_VAR 0 1
74085: PUSH
74086: LD_INT 1
74088: ARRAY
74089: PPUSH
74090: CALL_OW 251
74094: PPUSH
74095: LD_INT 70
74097: PPUSH
74098: CALL_OW 495
// end ;
74102: PPOPN 1
74104: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
74105: LD_EXP 97
74109: PUSH
74110: LD_EXP 131
74114: AND
74115: IFFALSE 74326
74117: GO 74119
74119: DISABLE
74120: LD_INT 0
74122: PPUSH
74123: PPUSH
74124: PPUSH
74125: PPUSH
74126: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
74127: LD_ADDR_VAR 0 5
74131: PUSH
74132: LD_INT 22
74134: PUSH
74135: LD_OWVAR 2
74139: PUSH
74140: EMPTY
74141: LIST
74142: LIST
74143: PUSH
74144: LD_INT 21
74146: PUSH
74147: LD_INT 1
74149: PUSH
74150: EMPTY
74151: LIST
74152: LIST
74153: PUSH
74154: EMPTY
74155: LIST
74156: LIST
74157: PPUSH
74158: CALL_OW 69
74162: ST_TO_ADDR
// if not tmp then
74163: LD_VAR 0 5
74167: NOT
74168: IFFALSE 74172
// exit ;
74170: GO 74326
// for i in tmp do
74172: LD_ADDR_VAR 0 1
74176: PUSH
74177: LD_VAR 0 5
74181: PUSH
74182: FOR_IN
74183: IFFALSE 74324
// begin d := rand ( 0 , 5 ) ;
74185: LD_ADDR_VAR 0 4
74189: PUSH
74190: LD_INT 0
74192: PPUSH
74193: LD_INT 5
74195: PPUSH
74196: CALL_OW 12
74200: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
74201: LD_ADDR_VAR 0 2
74205: PUSH
74206: LD_VAR 0 1
74210: PPUSH
74211: CALL_OW 250
74215: PPUSH
74216: LD_VAR 0 4
74220: PPUSH
74221: LD_INT 3
74223: PPUSH
74224: LD_INT 12
74226: PPUSH
74227: CALL_OW 12
74231: PPUSH
74232: CALL_OW 272
74236: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
74237: LD_ADDR_VAR 0 3
74241: PUSH
74242: LD_VAR 0 1
74246: PPUSH
74247: CALL_OW 251
74251: PPUSH
74252: LD_VAR 0 4
74256: PPUSH
74257: LD_INT 3
74259: PPUSH
74260: LD_INT 12
74262: PPUSH
74263: CALL_OW 12
74267: PPUSH
74268: CALL_OW 273
74272: ST_TO_ADDR
// if ValidHex ( x , y ) then
74273: LD_VAR 0 2
74277: PPUSH
74278: LD_VAR 0 3
74282: PPUSH
74283: CALL_OW 488
74287: IFFALSE 74322
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
74289: LD_VAR 0 1
74293: PPUSH
74294: LD_VAR 0 2
74298: PPUSH
74299: LD_VAR 0 3
74303: PPUSH
74304: LD_INT 3
74306: PPUSH
74307: LD_INT 6
74309: PPUSH
74310: CALL_OW 12
74314: PPUSH
74315: LD_INT 1
74317: PPUSH
74318: CALL_OW 483
// end ;
74322: GO 74182
74324: POP
74325: POP
// end ;
74326: PPOPN 5
74328: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
74329: LD_EXP 97
74333: PUSH
74334: LD_EXP 132
74338: AND
74339: IFFALSE 74433
74341: GO 74343
74343: DISABLE
74344: LD_INT 0
74346: PPUSH
74347: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
74348: LD_ADDR_VAR 0 2
74352: PUSH
74353: LD_INT 22
74355: PUSH
74356: LD_OWVAR 2
74360: PUSH
74361: EMPTY
74362: LIST
74363: LIST
74364: PUSH
74365: LD_INT 32
74367: PUSH
74368: LD_INT 1
74370: PUSH
74371: EMPTY
74372: LIST
74373: LIST
74374: PUSH
74375: LD_INT 21
74377: PUSH
74378: LD_INT 2
74380: PUSH
74381: EMPTY
74382: LIST
74383: LIST
74384: PUSH
74385: EMPTY
74386: LIST
74387: LIST
74388: LIST
74389: PPUSH
74390: CALL_OW 69
74394: ST_TO_ADDR
// if not tmp then
74395: LD_VAR 0 2
74399: NOT
74400: IFFALSE 74404
// exit ;
74402: GO 74433
// for i in tmp do
74404: LD_ADDR_VAR 0 1
74408: PUSH
74409: LD_VAR 0 2
74413: PUSH
74414: FOR_IN
74415: IFFALSE 74431
// SetFuel ( i , 0 ) ;
74417: LD_VAR 0 1
74421: PPUSH
74422: LD_INT 0
74424: PPUSH
74425: CALL_OW 240
74429: GO 74414
74431: POP
74432: POP
// end ;
74433: PPOPN 2
74435: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
74436: LD_EXP 97
74440: PUSH
74441: LD_EXP 133
74445: AND
74446: IFFALSE 74512
74448: GO 74450
74450: DISABLE
74451: LD_INT 0
74453: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
74454: LD_ADDR_VAR 0 1
74458: PUSH
74459: LD_INT 22
74461: PUSH
74462: LD_OWVAR 2
74466: PUSH
74467: EMPTY
74468: LIST
74469: LIST
74470: PUSH
74471: LD_INT 30
74473: PUSH
74474: LD_INT 29
74476: PUSH
74477: EMPTY
74478: LIST
74479: LIST
74480: PUSH
74481: EMPTY
74482: LIST
74483: LIST
74484: PPUSH
74485: CALL_OW 69
74489: ST_TO_ADDR
// if not tmp then
74490: LD_VAR 0 1
74494: NOT
74495: IFFALSE 74499
// exit ;
74497: GO 74512
// DestroyUnit ( tmp [ 1 ] ) ;
74499: LD_VAR 0 1
74503: PUSH
74504: LD_INT 1
74506: ARRAY
74507: PPUSH
74508: CALL_OW 65
// end ;
74512: PPOPN 1
74514: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
74515: LD_EXP 97
74519: PUSH
74520: LD_EXP 135
74524: AND
74525: IFFALSE 74654
74527: GO 74529
74529: DISABLE
74530: LD_INT 0
74532: PPUSH
// begin uc_side := 0 ;
74533: LD_ADDR_OWVAR 20
74537: PUSH
74538: LD_INT 0
74540: ST_TO_ADDR
// uc_nation := nation_arabian ;
74541: LD_ADDR_OWVAR 21
74545: PUSH
74546: LD_INT 2
74548: ST_TO_ADDR
// hc_gallery :=  ;
74549: LD_ADDR_OWVAR 33
74553: PUSH
74554: LD_STRING 
74556: ST_TO_ADDR
// hc_name :=  ;
74557: LD_ADDR_OWVAR 26
74561: PUSH
74562: LD_STRING 
74564: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
74565: LD_INT 1
74567: PPUSH
74568: LD_INT 11
74570: PPUSH
74571: LD_INT 10
74573: PPUSH
74574: CALL_OW 380
// un := CreateHuman ;
74578: LD_ADDR_VAR 0 1
74582: PUSH
74583: CALL_OW 44
74587: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
74588: LD_VAR 0 1
74592: PPUSH
74593: LD_INT 1
74595: PPUSH
74596: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
74600: LD_INT 35
74602: PPUSH
74603: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
74607: LD_VAR 0 1
74611: PPUSH
74612: LD_INT 22
74614: PUSH
74615: LD_OWVAR 2
74619: PUSH
74620: EMPTY
74621: LIST
74622: LIST
74623: PPUSH
74624: CALL_OW 69
74628: PPUSH
74629: LD_VAR 0 1
74633: PPUSH
74634: CALL_OW 74
74638: PPUSH
74639: CALL_OW 115
// until IsDead ( un ) ;
74643: LD_VAR 0 1
74647: PPUSH
74648: CALL_OW 301
74652: IFFALSE 74600
// end ;
74654: PPOPN 1
74656: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
74657: LD_EXP 97
74661: PUSH
74662: LD_EXP 137
74666: AND
74667: IFFALSE 74679
74669: GO 74671
74671: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
74672: LD_STRING earthquake(getX(game), 0, 32)
74674: PPUSH
74675: CALL_OW 559
74679: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
74680: LD_EXP 97
74684: PUSH
74685: LD_EXP 138
74689: AND
74690: IFFALSE 74781
74692: GO 74694
74694: DISABLE
74695: LD_INT 0
74697: PPUSH
// begin enable ;
74698: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
74699: LD_ADDR_VAR 0 1
74703: PUSH
74704: LD_INT 22
74706: PUSH
74707: LD_OWVAR 2
74711: PUSH
74712: EMPTY
74713: LIST
74714: LIST
74715: PUSH
74716: LD_INT 21
74718: PUSH
74719: LD_INT 2
74721: PUSH
74722: EMPTY
74723: LIST
74724: LIST
74725: PUSH
74726: LD_INT 33
74728: PUSH
74729: LD_INT 3
74731: PUSH
74732: EMPTY
74733: LIST
74734: LIST
74735: PUSH
74736: EMPTY
74737: LIST
74738: LIST
74739: LIST
74740: PPUSH
74741: CALL_OW 69
74745: ST_TO_ADDR
// if not tmp then
74746: LD_VAR 0 1
74750: NOT
74751: IFFALSE 74755
// exit ;
74753: GO 74781
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
74755: LD_VAR 0 1
74759: PUSH
74760: LD_INT 1
74762: PPUSH
74763: LD_VAR 0 1
74767: PPUSH
74768: CALL_OW 12
74772: ARRAY
74773: PPUSH
74774: LD_INT 1
74776: PPUSH
74777: CALL_OW 234
// end ;
74781: PPOPN 1
74783: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
74784: LD_EXP 97
74788: PUSH
74789: LD_EXP 139
74793: AND
74794: IFFALSE 74935
74796: GO 74798
74798: DISABLE
74799: LD_INT 0
74801: PPUSH
74802: PPUSH
74803: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
74804: LD_ADDR_VAR 0 3
74808: PUSH
74809: LD_INT 22
74811: PUSH
74812: LD_OWVAR 2
74816: PUSH
74817: EMPTY
74818: LIST
74819: LIST
74820: PUSH
74821: LD_INT 25
74823: PUSH
74824: LD_INT 1
74826: PUSH
74827: EMPTY
74828: LIST
74829: LIST
74830: PUSH
74831: EMPTY
74832: LIST
74833: LIST
74834: PPUSH
74835: CALL_OW 69
74839: ST_TO_ADDR
// if not tmp then
74840: LD_VAR 0 3
74844: NOT
74845: IFFALSE 74849
// exit ;
74847: GO 74935
// un := tmp [ rand ( 1 , tmp ) ] ;
74849: LD_ADDR_VAR 0 2
74853: PUSH
74854: LD_VAR 0 3
74858: PUSH
74859: LD_INT 1
74861: PPUSH
74862: LD_VAR 0 3
74866: PPUSH
74867: CALL_OW 12
74871: ARRAY
74872: ST_TO_ADDR
// if Crawls ( un ) then
74873: LD_VAR 0 2
74877: PPUSH
74878: CALL_OW 318
74882: IFFALSE 74893
// ComWalk ( un ) ;
74884: LD_VAR 0 2
74888: PPUSH
74889: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
74893: LD_VAR 0 2
74897: PPUSH
74898: LD_INT 9
74900: PPUSH
74901: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
74905: LD_INT 28
74907: PPUSH
74908: LD_OWVAR 2
74912: PPUSH
74913: LD_INT 2
74915: PPUSH
74916: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
74920: LD_INT 29
74922: PPUSH
74923: LD_OWVAR 2
74927: PPUSH
74928: LD_INT 2
74930: PPUSH
74931: CALL_OW 322
// end ;
74935: PPOPN 3
74937: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
74938: LD_EXP 97
74942: PUSH
74943: LD_EXP 140
74947: AND
74948: IFFALSE 75059
74950: GO 74952
74952: DISABLE
74953: LD_INT 0
74955: PPUSH
74956: PPUSH
74957: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
74958: LD_ADDR_VAR 0 3
74962: PUSH
74963: LD_INT 22
74965: PUSH
74966: LD_OWVAR 2
74970: PUSH
74971: EMPTY
74972: LIST
74973: LIST
74974: PUSH
74975: LD_INT 25
74977: PUSH
74978: LD_INT 1
74980: PUSH
74981: EMPTY
74982: LIST
74983: LIST
74984: PUSH
74985: EMPTY
74986: LIST
74987: LIST
74988: PPUSH
74989: CALL_OW 69
74993: ST_TO_ADDR
// if not tmp then
74994: LD_VAR 0 3
74998: NOT
74999: IFFALSE 75003
// exit ;
75001: GO 75059
// un := tmp [ rand ( 1 , tmp ) ] ;
75003: LD_ADDR_VAR 0 2
75007: PUSH
75008: LD_VAR 0 3
75012: PUSH
75013: LD_INT 1
75015: PPUSH
75016: LD_VAR 0 3
75020: PPUSH
75021: CALL_OW 12
75025: ARRAY
75026: ST_TO_ADDR
// if Crawls ( un ) then
75027: LD_VAR 0 2
75031: PPUSH
75032: CALL_OW 318
75036: IFFALSE 75047
// ComWalk ( un ) ;
75038: LD_VAR 0 2
75042: PPUSH
75043: CALL_OW 138
// SetClass ( un , class_mortar ) ;
75047: LD_VAR 0 2
75051: PPUSH
75052: LD_INT 8
75054: PPUSH
75055: CALL_OW 336
// end ;
75059: PPOPN 3
75061: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
75062: LD_EXP 97
75066: PUSH
75067: LD_EXP 141
75071: AND
75072: IFFALSE 75216
75074: GO 75076
75076: DISABLE
75077: LD_INT 0
75079: PPUSH
75080: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
75081: LD_ADDR_VAR 0 2
75085: PUSH
75086: LD_INT 22
75088: PUSH
75089: LD_OWVAR 2
75093: PUSH
75094: EMPTY
75095: LIST
75096: LIST
75097: PUSH
75098: LD_INT 21
75100: PUSH
75101: LD_INT 2
75103: PUSH
75104: EMPTY
75105: LIST
75106: LIST
75107: PUSH
75108: LD_INT 2
75110: PUSH
75111: LD_INT 34
75113: PUSH
75114: LD_INT 12
75116: PUSH
75117: EMPTY
75118: LIST
75119: LIST
75120: PUSH
75121: LD_INT 34
75123: PUSH
75124: LD_INT 51
75126: PUSH
75127: EMPTY
75128: LIST
75129: LIST
75130: PUSH
75131: LD_INT 34
75133: PUSH
75134: LD_INT 32
75136: PUSH
75137: EMPTY
75138: LIST
75139: LIST
75140: PUSH
75141: EMPTY
75142: LIST
75143: LIST
75144: LIST
75145: LIST
75146: PUSH
75147: EMPTY
75148: LIST
75149: LIST
75150: LIST
75151: PPUSH
75152: CALL_OW 69
75156: ST_TO_ADDR
// if not tmp then
75157: LD_VAR 0 2
75161: NOT
75162: IFFALSE 75166
// exit ;
75164: GO 75216
// for i in tmp do
75166: LD_ADDR_VAR 0 1
75170: PUSH
75171: LD_VAR 0 2
75175: PUSH
75176: FOR_IN
75177: IFFALSE 75214
// if GetCargo ( i , mat_artifact ) = 0 then
75179: LD_VAR 0 1
75183: PPUSH
75184: LD_INT 4
75186: PPUSH
75187: CALL_OW 289
75191: PUSH
75192: LD_INT 0
75194: EQUAL
75195: IFFALSE 75212
// SetCargo ( i , mat_siberit , 100 ) ;
75197: LD_VAR 0 1
75201: PPUSH
75202: LD_INT 3
75204: PPUSH
75205: LD_INT 100
75207: PPUSH
75208: CALL_OW 290
75212: GO 75176
75214: POP
75215: POP
// end ;
75216: PPOPN 2
75218: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
75219: LD_EXP 97
75223: PUSH
75224: LD_EXP 142
75228: AND
75229: IFFALSE 75412
75231: GO 75233
75233: DISABLE
75234: LD_INT 0
75236: PPUSH
75237: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
75238: LD_ADDR_VAR 0 2
75242: PUSH
75243: LD_INT 22
75245: PUSH
75246: LD_OWVAR 2
75250: PUSH
75251: EMPTY
75252: LIST
75253: LIST
75254: PPUSH
75255: CALL_OW 69
75259: ST_TO_ADDR
// if not tmp then
75260: LD_VAR 0 2
75264: NOT
75265: IFFALSE 75269
// exit ;
75267: GO 75412
// for i := 1 to 2 do
75269: LD_ADDR_VAR 0 1
75273: PUSH
75274: DOUBLE
75275: LD_INT 1
75277: DEC
75278: ST_TO_ADDR
75279: LD_INT 2
75281: PUSH
75282: FOR_TO
75283: IFFALSE 75410
// begin uc_side := your_side ;
75285: LD_ADDR_OWVAR 20
75289: PUSH
75290: LD_OWVAR 2
75294: ST_TO_ADDR
// uc_nation := nation_american ;
75295: LD_ADDR_OWVAR 21
75299: PUSH
75300: LD_INT 1
75302: ST_TO_ADDR
// vc_chassis := us_morphling ;
75303: LD_ADDR_OWVAR 37
75307: PUSH
75308: LD_INT 5
75310: ST_TO_ADDR
// vc_engine := engine_siberite ;
75311: LD_ADDR_OWVAR 39
75315: PUSH
75316: LD_INT 3
75318: ST_TO_ADDR
// vc_control := control_computer ;
75319: LD_ADDR_OWVAR 38
75323: PUSH
75324: LD_INT 3
75326: ST_TO_ADDR
// vc_weapon := us_double_laser ;
75327: LD_ADDR_OWVAR 40
75331: PUSH
75332: LD_INT 10
75334: ST_TO_ADDR
// if not IsInUnit ( tmp [ 1 ] ) then
75335: LD_VAR 0 2
75339: PUSH
75340: LD_INT 1
75342: ARRAY
75343: PPUSH
75344: CALL_OW 310
75348: NOT
75349: IFFALSE 75396
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) else
75351: CALL_OW 45
75355: PPUSH
75356: LD_VAR 0 2
75360: PUSH
75361: LD_INT 1
75363: ARRAY
75364: PPUSH
75365: CALL_OW 250
75369: PPUSH
75370: LD_VAR 0 2
75374: PUSH
75375: LD_INT 1
75377: ARRAY
75378: PPUSH
75379: CALL_OW 251
75383: PPUSH
75384: LD_INT 12
75386: PPUSH
75387: LD_INT 1
75389: PPUSH
75390: CALL_OW 50
75394: GO 75408
// PlaceUnitAnywhere ( CreateVehicle , true ) ;
75396: CALL_OW 45
75400: PPUSH
75401: LD_INT 1
75403: PPUSH
75404: CALL_OW 51
// end ;
75408: GO 75282
75410: POP
75411: POP
// end ;
75412: PPOPN 2
75414: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
75415: LD_EXP 97
75419: PUSH
75420: LD_EXP 143
75424: AND
75425: IFFALSE 75647
75427: GO 75429
75429: DISABLE
75430: LD_INT 0
75432: PPUSH
75433: PPUSH
75434: PPUSH
75435: PPUSH
75436: PPUSH
75437: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
75438: LD_ADDR_VAR 0 6
75442: PUSH
75443: LD_INT 22
75445: PUSH
75446: LD_OWVAR 2
75450: PUSH
75451: EMPTY
75452: LIST
75453: LIST
75454: PUSH
75455: LD_INT 21
75457: PUSH
75458: LD_INT 1
75460: PUSH
75461: EMPTY
75462: LIST
75463: LIST
75464: PUSH
75465: LD_INT 3
75467: PUSH
75468: LD_INT 23
75470: PUSH
75471: LD_INT 0
75473: PUSH
75474: EMPTY
75475: LIST
75476: LIST
75477: PUSH
75478: EMPTY
75479: LIST
75480: LIST
75481: PUSH
75482: EMPTY
75483: LIST
75484: LIST
75485: LIST
75486: PPUSH
75487: CALL_OW 69
75491: ST_TO_ADDR
// if not tmp then
75492: LD_VAR 0 6
75496: NOT
75497: IFFALSE 75501
// exit ;
75499: GO 75647
// s1 := rand ( 1 , 4 ) ;
75501: LD_ADDR_VAR 0 2
75505: PUSH
75506: LD_INT 1
75508: PPUSH
75509: LD_INT 4
75511: PPUSH
75512: CALL_OW 12
75516: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
75517: LD_ADDR_VAR 0 4
75521: PUSH
75522: LD_VAR 0 6
75526: PUSH
75527: LD_INT 1
75529: ARRAY
75530: PPUSH
75531: LD_VAR 0 2
75535: PPUSH
75536: CALL_OW 259
75540: ST_TO_ADDR
// if s1 = 1 then
75541: LD_VAR 0 2
75545: PUSH
75546: LD_INT 1
75548: EQUAL
75549: IFFALSE 75569
// s2 := rand ( 2 , 4 ) else
75551: LD_ADDR_VAR 0 3
75555: PUSH
75556: LD_INT 2
75558: PPUSH
75559: LD_INT 4
75561: PPUSH
75562: CALL_OW 12
75566: ST_TO_ADDR
75567: GO 75577
// s2 := 1 ;
75569: LD_ADDR_VAR 0 3
75573: PUSH
75574: LD_INT 1
75576: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
75577: LD_ADDR_VAR 0 5
75581: PUSH
75582: LD_VAR 0 6
75586: PUSH
75587: LD_INT 1
75589: ARRAY
75590: PPUSH
75591: LD_VAR 0 3
75595: PPUSH
75596: CALL_OW 259
75600: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
75601: LD_VAR 0 6
75605: PUSH
75606: LD_INT 1
75608: ARRAY
75609: PPUSH
75610: LD_VAR 0 2
75614: PPUSH
75615: LD_VAR 0 5
75619: PPUSH
75620: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
75624: LD_VAR 0 6
75628: PUSH
75629: LD_INT 1
75631: ARRAY
75632: PPUSH
75633: LD_VAR 0 3
75637: PPUSH
75638: LD_VAR 0 4
75642: PPUSH
75643: CALL_OW 237
// end ;
75647: PPOPN 6
75649: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
75650: LD_EXP 97
75654: PUSH
75655: LD_EXP 144
75659: AND
75660: IFFALSE 75739
75662: GO 75664
75664: DISABLE
75665: LD_INT 0
75667: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
75668: LD_ADDR_VAR 0 1
75672: PUSH
75673: LD_INT 22
75675: PUSH
75676: LD_OWVAR 2
75680: PUSH
75681: EMPTY
75682: LIST
75683: LIST
75684: PUSH
75685: LD_INT 30
75687: PUSH
75688: LD_INT 3
75690: PUSH
75691: EMPTY
75692: LIST
75693: LIST
75694: PUSH
75695: EMPTY
75696: LIST
75697: LIST
75698: PPUSH
75699: CALL_OW 69
75703: ST_TO_ADDR
// if not tmp then
75704: LD_VAR 0 1
75708: NOT
75709: IFFALSE 75713
// exit ;
75711: GO 75739
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
75713: LD_VAR 0 1
75717: PUSH
75718: LD_INT 1
75720: PPUSH
75721: LD_VAR 0 1
75725: PPUSH
75726: CALL_OW 12
75730: ARRAY
75731: PPUSH
75732: LD_INT 1
75734: PPUSH
75735: CALL_OW 234
// end ;
75739: PPOPN 1
75741: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
75742: LD_EXP 97
75746: PUSH
75747: LD_EXP 145
75751: AND
75752: IFFALSE 75864
75754: GO 75756
75756: DISABLE
75757: LD_INT 0
75759: PPUSH
75760: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
75761: LD_ADDR_VAR 0 2
75765: PUSH
75766: LD_INT 22
75768: PUSH
75769: LD_OWVAR 2
75773: PUSH
75774: EMPTY
75775: LIST
75776: LIST
75777: PUSH
75778: LD_INT 2
75780: PUSH
75781: LD_INT 30
75783: PUSH
75784: LD_INT 27
75786: PUSH
75787: EMPTY
75788: LIST
75789: LIST
75790: PUSH
75791: LD_INT 30
75793: PUSH
75794: LD_INT 26
75796: PUSH
75797: EMPTY
75798: LIST
75799: LIST
75800: PUSH
75801: LD_INT 30
75803: PUSH
75804: LD_INT 28
75806: PUSH
75807: EMPTY
75808: LIST
75809: LIST
75810: PUSH
75811: EMPTY
75812: LIST
75813: LIST
75814: LIST
75815: LIST
75816: PUSH
75817: EMPTY
75818: LIST
75819: LIST
75820: PPUSH
75821: CALL_OW 69
75825: ST_TO_ADDR
// if not tmp then
75826: LD_VAR 0 2
75830: NOT
75831: IFFALSE 75835
// exit ;
75833: GO 75864
// for i in tmp do
75835: LD_ADDR_VAR 0 1
75839: PUSH
75840: LD_VAR 0 2
75844: PUSH
75845: FOR_IN
75846: IFFALSE 75862
// SetLives ( i , 1 ) ;
75848: LD_VAR 0 1
75852: PPUSH
75853: LD_INT 1
75855: PPUSH
75856: CALL_OW 234
75860: GO 75845
75862: POP
75863: POP
// end ;
75864: PPOPN 2
75866: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
75867: LD_EXP 97
75871: PUSH
75872: LD_EXP 146
75876: AND
75877: IFFALSE 76164
75879: GO 75881
75881: DISABLE
75882: LD_INT 0
75884: PPUSH
75885: PPUSH
75886: PPUSH
// begin i := rand ( 1 , 7 ) ;
75887: LD_ADDR_VAR 0 1
75891: PUSH
75892: LD_INT 1
75894: PPUSH
75895: LD_INT 7
75897: PPUSH
75898: CALL_OW 12
75902: ST_TO_ADDR
// case i of 1 :
75903: LD_VAR 0 1
75907: PUSH
75908: LD_INT 1
75910: DOUBLE
75911: EQUAL
75912: IFTRUE 75916
75914: GO 75926
75916: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
75917: LD_STRING earthquake(getX(game), 0, 32)
75919: PPUSH
75920: CALL_OW 559
75924: GO 76164
75926: LD_INT 2
75928: DOUBLE
75929: EQUAL
75930: IFTRUE 75934
75932: GO 75948
75934: POP
// begin ToLua ( displayStucuk(); ) ;
75935: LD_STRING displayStucuk();
75937: PPUSH
75938: CALL_OW 559
// ResetFog ;
75942: CALL_OW 335
// end ; 3 :
75946: GO 76164
75948: LD_INT 3
75950: DOUBLE
75951: EQUAL
75952: IFTRUE 75956
75954: GO 76060
75956: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
75957: LD_ADDR_VAR 0 2
75961: PUSH
75962: LD_INT 22
75964: PUSH
75965: LD_OWVAR 2
75969: PUSH
75970: EMPTY
75971: LIST
75972: LIST
75973: PUSH
75974: LD_INT 25
75976: PUSH
75977: LD_INT 1
75979: PUSH
75980: EMPTY
75981: LIST
75982: LIST
75983: PUSH
75984: EMPTY
75985: LIST
75986: LIST
75987: PPUSH
75988: CALL_OW 69
75992: ST_TO_ADDR
// if not tmp then
75993: LD_VAR 0 2
75997: NOT
75998: IFFALSE 76002
// exit ;
76000: GO 76164
// un := tmp [ rand ( 1 , tmp ) ] ;
76002: LD_ADDR_VAR 0 3
76006: PUSH
76007: LD_VAR 0 2
76011: PUSH
76012: LD_INT 1
76014: PPUSH
76015: LD_VAR 0 2
76019: PPUSH
76020: CALL_OW 12
76024: ARRAY
76025: ST_TO_ADDR
// if Crawls ( un ) then
76026: LD_VAR 0 3
76030: PPUSH
76031: CALL_OW 318
76035: IFFALSE 76046
// ComWalk ( un ) ;
76037: LD_VAR 0 3
76041: PPUSH
76042: CALL_OW 138
// SetClass ( un , class_mortar ) ;
76046: LD_VAR 0 3
76050: PPUSH
76051: LD_INT 8
76053: PPUSH
76054: CALL_OW 336
// end ; 4 :
76058: GO 76164
76060: LD_INT 4
76062: DOUBLE
76063: EQUAL
76064: IFTRUE 76068
76066: GO 76142
76068: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
76069: LD_ADDR_VAR 0 2
76073: PUSH
76074: LD_INT 22
76076: PUSH
76077: LD_OWVAR 2
76081: PUSH
76082: EMPTY
76083: LIST
76084: LIST
76085: PUSH
76086: LD_INT 30
76088: PUSH
76089: LD_INT 29
76091: PUSH
76092: EMPTY
76093: LIST
76094: LIST
76095: PUSH
76096: EMPTY
76097: LIST
76098: LIST
76099: PPUSH
76100: CALL_OW 69
76104: ST_TO_ADDR
// if not tmp then
76105: LD_VAR 0 2
76109: NOT
76110: IFFALSE 76114
// exit ;
76112: GO 76164
// CenterNowOnUnits ( tmp [ 1 ] ) ;
76114: LD_VAR 0 2
76118: PUSH
76119: LD_INT 1
76121: ARRAY
76122: PPUSH
76123: CALL_OW 87
// DestroyUnit ( tmp [ 1 ] ) ;
76127: LD_VAR 0 2
76131: PUSH
76132: LD_INT 1
76134: ARRAY
76135: PPUSH
76136: CALL_OW 65
// end ; 5 .. 7 :
76140: GO 76164
76142: LD_INT 5
76144: DOUBLE
76145: GREATEREQUAL
76146: IFFALSE 76154
76148: LD_INT 7
76150: DOUBLE
76151: LESSEQUAL
76152: IFTRUE 76156
76154: GO 76163
76156: POP
// StreamSibBomb ; end ;
76157: CALL 72401 0 0
76161: GO 76164
76163: POP
// end ;
76164: PPOPN 3
76166: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
76167: LD_EXP 97
76171: PUSH
76172: LD_EXP 147
76176: AND
76177: IFFALSE 76333
76179: GO 76181
76181: DISABLE
76182: LD_INT 0
76184: PPUSH
76185: PPUSH
76186: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
76187: LD_ADDR_VAR 0 2
76191: PUSH
76192: LD_INT 81
76194: PUSH
76195: LD_OWVAR 2
76199: PUSH
76200: EMPTY
76201: LIST
76202: LIST
76203: PUSH
76204: LD_INT 2
76206: PUSH
76207: LD_INT 21
76209: PUSH
76210: LD_INT 1
76212: PUSH
76213: EMPTY
76214: LIST
76215: LIST
76216: PUSH
76217: LD_INT 21
76219: PUSH
76220: LD_INT 2
76222: PUSH
76223: EMPTY
76224: LIST
76225: LIST
76226: PUSH
76227: EMPTY
76228: LIST
76229: LIST
76230: LIST
76231: PUSH
76232: EMPTY
76233: LIST
76234: LIST
76235: PPUSH
76236: CALL_OW 69
76240: ST_TO_ADDR
// if not tmp then
76241: LD_VAR 0 2
76245: NOT
76246: IFFALSE 76250
// exit ;
76248: GO 76333
// p := 0 ;
76250: LD_ADDR_VAR 0 3
76254: PUSH
76255: LD_INT 0
76257: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
76258: LD_INT 35
76260: PPUSH
76261: CALL_OW 67
// p := p + 1 ;
76265: LD_ADDR_VAR 0 3
76269: PUSH
76270: LD_VAR 0 3
76274: PUSH
76275: LD_INT 1
76277: PLUS
76278: ST_TO_ADDR
// for i in tmp do
76279: LD_ADDR_VAR 0 1
76283: PUSH
76284: LD_VAR 0 2
76288: PUSH
76289: FOR_IN
76290: IFFALSE 76321
// if GetLives ( i ) < 1000 then
76292: LD_VAR 0 1
76296: PPUSH
76297: CALL_OW 256
76301: PUSH
76302: LD_INT 1000
76304: LESS
76305: IFFALSE 76319
// SetLives ( i , 1000 ) ;
76307: LD_VAR 0 1
76311: PPUSH
76312: LD_INT 1000
76314: PPUSH
76315: CALL_OW 234
76319: GO 76289
76321: POP
76322: POP
// until p > 20 ;
76323: LD_VAR 0 3
76327: PUSH
76328: LD_INT 20
76330: GREATER
76331: IFFALSE 76258
// end ;
76333: PPOPN 3
76335: END
// every 0 0$1 trigger StreamModeActive and sTime do
76336: LD_EXP 97
76340: PUSH
76341: LD_EXP 148
76345: AND
76346: IFFALSE 76381
76348: GO 76350
76350: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
76351: LD_INT 28
76353: PPUSH
76354: LD_OWVAR 2
76358: PPUSH
76359: LD_INT 2
76361: PPUSH
76362: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
76366: LD_INT 30
76368: PPUSH
76369: LD_OWVAR 2
76373: PPUSH
76374: LD_INT 2
76376: PPUSH
76377: CALL_OW 322
// end ;
76381: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
76382: LD_EXP 97
76386: PUSH
76387: LD_EXP 149
76391: AND
76392: IFFALSE 76513
76394: GO 76396
76396: DISABLE
76397: LD_INT 0
76399: PPUSH
76400: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
76401: LD_ADDR_VAR 0 2
76405: PUSH
76406: LD_INT 22
76408: PUSH
76409: LD_OWVAR 2
76413: PUSH
76414: EMPTY
76415: LIST
76416: LIST
76417: PUSH
76418: LD_INT 21
76420: PUSH
76421: LD_INT 1
76423: PUSH
76424: EMPTY
76425: LIST
76426: LIST
76427: PUSH
76428: LD_INT 3
76430: PUSH
76431: LD_INT 23
76433: PUSH
76434: LD_INT 0
76436: PUSH
76437: EMPTY
76438: LIST
76439: LIST
76440: PUSH
76441: EMPTY
76442: LIST
76443: LIST
76444: PUSH
76445: EMPTY
76446: LIST
76447: LIST
76448: LIST
76449: PPUSH
76450: CALL_OW 69
76454: ST_TO_ADDR
// if not tmp then
76455: LD_VAR 0 2
76459: NOT
76460: IFFALSE 76464
// exit ;
76462: GO 76513
// for i in tmp do
76464: LD_ADDR_VAR 0 1
76468: PUSH
76469: LD_VAR 0 2
76473: PUSH
76474: FOR_IN
76475: IFFALSE 76511
// begin if Crawls ( i ) then
76477: LD_VAR 0 1
76481: PPUSH
76482: CALL_OW 318
76486: IFFALSE 76497
// ComWalk ( i ) ;
76488: LD_VAR 0 1
76492: PPUSH
76493: CALL_OW 138
// SetClass ( i , 2 ) ;
76497: LD_VAR 0 1
76501: PPUSH
76502: LD_INT 2
76504: PPUSH
76505: CALL_OW 336
// end ;
76509: GO 76474
76511: POP
76512: POP
// end ;
76513: PPOPN 2
76515: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
76516: LD_EXP 97
76520: PUSH
76521: LD_EXP 150
76525: AND
76526: IFFALSE 76814
76528: GO 76530
76530: DISABLE
76531: LD_INT 0
76533: PPUSH
76534: PPUSH
76535: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
76536: LD_OWVAR 2
76540: PPUSH
76541: LD_INT 9
76543: PPUSH
76544: LD_INT 1
76546: PPUSH
76547: LD_INT 1
76549: PPUSH
76550: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
76554: LD_INT 9
76556: PPUSH
76557: LD_OWVAR 2
76561: PPUSH
76562: CALL_OW 343
// uc_side := 9 ;
76566: LD_ADDR_OWVAR 20
76570: PUSH
76571: LD_INT 9
76573: ST_TO_ADDR
// uc_nation := 2 ;
76574: LD_ADDR_OWVAR 21
76578: PUSH
76579: LD_INT 2
76581: ST_TO_ADDR
// hc_name := Dark Warrior ;
76582: LD_ADDR_OWVAR 26
76586: PUSH
76587: LD_STRING Dark Warrior
76589: ST_TO_ADDR
// hc_gallery :=  ;
76590: LD_ADDR_OWVAR 33
76594: PUSH
76595: LD_STRING 
76597: ST_TO_ADDR
// hc_noskilllimit := true ;
76598: LD_ADDR_OWVAR 76
76602: PUSH
76603: LD_INT 1
76605: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
76606: LD_ADDR_OWVAR 31
76610: PUSH
76611: LD_INT 30
76613: PUSH
76614: LD_INT 30
76616: PUSH
76617: LD_INT 30
76619: PUSH
76620: LD_INT 30
76622: PUSH
76623: EMPTY
76624: LIST
76625: LIST
76626: LIST
76627: LIST
76628: ST_TO_ADDR
// un := CreateHuman ;
76629: LD_ADDR_VAR 0 3
76633: PUSH
76634: CALL_OW 44
76638: ST_TO_ADDR
// hc_noskilllimit := false ;
76639: LD_ADDR_OWVAR 76
76643: PUSH
76644: LD_INT 0
76646: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
76647: LD_VAR 0 3
76651: PPUSH
76652: LD_INT 1
76654: PPUSH
76655: CALL_OW 51
// ToLua ( playRanger() ) ;
76659: LD_STRING playRanger()
76661: PPUSH
76662: CALL_OW 559
// p := 0 ;
76666: LD_ADDR_VAR 0 2
76670: PUSH
76671: LD_INT 0
76673: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
76674: LD_INT 35
76676: PPUSH
76677: CALL_OW 67
// p := p + 1 ;
76681: LD_ADDR_VAR 0 2
76685: PUSH
76686: LD_VAR 0 2
76690: PUSH
76691: LD_INT 1
76693: PLUS
76694: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
76695: LD_VAR 0 3
76699: PPUSH
76700: CALL_OW 256
76704: PUSH
76705: LD_INT 1000
76707: LESS
76708: IFFALSE 76722
// SetLives ( un , 1000 ) ;
76710: LD_VAR 0 3
76714: PPUSH
76715: LD_INT 1000
76717: PPUSH
76718: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
76722: LD_VAR 0 3
76726: PPUSH
76727: LD_INT 81
76729: PUSH
76730: LD_OWVAR 2
76734: PUSH
76735: EMPTY
76736: LIST
76737: LIST
76738: PUSH
76739: LD_INT 91
76741: PUSH
76742: LD_VAR 0 3
76746: PUSH
76747: LD_INT 30
76749: PUSH
76750: EMPTY
76751: LIST
76752: LIST
76753: LIST
76754: PUSH
76755: EMPTY
76756: LIST
76757: LIST
76758: PPUSH
76759: CALL_OW 69
76763: PPUSH
76764: LD_VAR 0 3
76768: PPUSH
76769: CALL_OW 74
76773: PPUSH
76774: CALL_OW 115
// until p > 80 or IsDead ( un ) ;
76778: LD_VAR 0 2
76782: PUSH
76783: LD_INT 80
76785: GREATER
76786: PUSH
76787: LD_VAR 0 3
76791: PPUSH
76792: CALL_OW 301
76796: OR
76797: IFFALSE 76674
// if un then
76799: LD_VAR 0 3
76803: IFFALSE 76814
// RemoveUnit ( un ) ;
76805: LD_VAR 0 3
76809: PPUSH
76810: CALL_OW 64
// end ;
76814: PPOPN 3
76816: END
// every 0 0$1 trigger sComputer do var i , tmp , j ;
76817: LD_EXP 151
76821: IFFALSE 76937
76823: GO 76825
76825: DISABLE
76826: LD_INT 0
76828: PPUSH
76829: PPUSH
76830: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
76831: LD_ADDR_VAR 0 2
76835: PUSH
76836: LD_INT 81
76838: PUSH
76839: LD_OWVAR 2
76843: PUSH
76844: EMPTY
76845: LIST
76846: LIST
76847: PUSH
76848: LD_INT 21
76850: PUSH
76851: LD_INT 1
76853: PUSH
76854: EMPTY
76855: LIST
76856: LIST
76857: PUSH
76858: EMPTY
76859: LIST
76860: LIST
76861: PPUSH
76862: CALL_OW 69
76866: ST_TO_ADDR
// ToLua ( playComputer() ) ;
76867: LD_STRING playComputer()
76869: PPUSH
76870: CALL_OW 559
// if not tmp then
76874: LD_VAR 0 2
76878: NOT
76879: IFFALSE 76883
// exit ;
76881: GO 76937
// for i in tmp do
76883: LD_ADDR_VAR 0 1
76887: PUSH
76888: LD_VAR 0 2
76892: PUSH
76893: FOR_IN
76894: IFFALSE 76935
// for j := 1 to 4 do
76896: LD_ADDR_VAR 0 3
76900: PUSH
76901: DOUBLE
76902: LD_INT 1
76904: DEC
76905: ST_TO_ADDR
76906: LD_INT 4
76908: PUSH
76909: FOR_TO
76910: IFFALSE 76931
// SetSkill ( i , j , 10 ) ;
76912: LD_VAR 0 1
76916: PPUSH
76917: LD_VAR 0 3
76921: PPUSH
76922: LD_INT 10
76924: PPUSH
76925: CALL_OW 237
76929: GO 76909
76931: POP
76932: POP
76933: GO 76893
76935: POP
76936: POP
// end ;
76937: PPOPN 3
76939: END
// every 0 0$1 trigger s30 do var i , tmp ;
76940: LD_EXP 152
76944: IFFALSE 77013
76946: GO 76948
76948: DISABLE
76949: LD_INT 0
76951: PPUSH
76952: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
76953: LD_ADDR_VAR 0 2
76957: PUSH
76958: LD_INT 22
76960: PUSH
76961: LD_OWVAR 2
76965: PUSH
76966: EMPTY
76967: LIST
76968: LIST
76969: PPUSH
76970: CALL_OW 69
76974: ST_TO_ADDR
// if not tmp then
76975: LD_VAR 0 2
76979: NOT
76980: IFFALSE 76984
// exit ;
76982: GO 77013
// for i in tmp do
76984: LD_ADDR_VAR 0 1
76988: PUSH
76989: LD_VAR 0 2
76993: PUSH
76994: FOR_IN
76995: IFFALSE 77011
// SetLives ( i , 300 ) ;
76997: LD_VAR 0 1
77001: PPUSH
77002: LD_INT 300
77004: PPUSH
77005: CALL_OW 234
77009: GO 76994
77011: POP
77012: POP
// end ;
77013: PPOPN 2
77015: END
// every 0 0$1 trigger s60 do var i , tmp ;
77016: LD_EXP 153
77020: IFFALSE 77089
77022: GO 77024
77024: DISABLE
77025: LD_INT 0
77027: PPUSH
77028: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
77029: LD_ADDR_VAR 0 2
77033: PUSH
77034: LD_INT 22
77036: PUSH
77037: LD_OWVAR 2
77041: PUSH
77042: EMPTY
77043: LIST
77044: LIST
77045: PPUSH
77046: CALL_OW 69
77050: ST_TO_ADDR
// if not tmp then
77051: LD_VAR 0 2
77055: NOT
77056: IFFALSE 77060
// exit ;
77058: GO 77089
// for i in tmp do
77060: LD_ADDR_VAR 0 1
77064: PUSH
77065: LD_VAR 0 2
77069: PUSH
77070: FOR_IN
77071: IFFALSE 77087
// SetLives ( i , 600 ) ;
77073: LD_VAR 0 1
77077: PPUSH
77078: LD_INT 600
77080: PPUSH
77081: CALL_OW 234
77085: GO 77070
77087: POP
77088: POP
// end ;
77089: PPOPN 2
77091: END
// export function SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
77092: LD_INT 0
77094: PPUSH
// case cmd of 301 :
77095: LD_VAR 0 1
77099: PUSH
77100: LD_INT 301
77102: DOUBLE
77103: EQUAL
77104: IFTRUE 77108
77106: GO 77140
77108: POP
// hHackSpawnHuman ( p1 , p2 , p3 , x , y ) ; 302 :
77109: LD_VAR 0 6
77113: PPUSH
77114: LD_VAR 0 7
77118: PPUSH
77119: LD_VAR 0 8
77123: PPUSH
77124: LD_VAR 0 4
77128: PPUSH
77129: LD_VAR 0 5
77133: PPUSH
77134: CALL 78341 0 5
77138: GO 77261
77140: LD_INT 302
77142: DOUBLE
77143: EQUAL
77144: IFTRUE 77148
77146: GO 77185
77148: POP
// hHackSpawnVehicle ( p1 , p2 , p3 , p4 , x , y ) ; 303 :
77149: LD_VAR 0 6
77153: PPUSH
77154: LD_VAR 0 7
77158: PPUSH
77159: LD_VAR 0 8
77163: PPUSH
77164: LD_VAR 0 9
77168: PPUSH
77169: LD_VAR 0 4
77173: PPUSH
77174: LD_VAR 0 5
77178: PPUSH
77179: CALL 78432 0 6
77183: GO 77261
77185: LD_INT 303
77187: DOUBLE
77188: EQUAL
77189: IFTRUE 77193
77191: GO 77230
77193: POP
// hHackSpawnBuilding ( p1 , p2 , p3 , p4 , x , y ) ; 304 :
77194: LD_VAR 0 6
77198: PPUSH
77199: LD_VAR 0 7
77203: PPUSH
77204: LD_VAR 0 8
77208: PPUSH
77209: LD_VAR 0 9
77213: PPUSH
77214: LD_VAR 0 4
77218: PPUSH
77219: LD_VAR 0 5
77223: PPUSH
77224: CALL 77266 0 6
77228: GO 77261
77230: LD_INT 304
77232: DOUBLE
77233: EQUAL
77234: IFTRUE 77238
77236: GO 77260
77238: POP
// hHackTeleport ( unit , x , y ) ; end ;
77239: LD_VAR 0 2
77243: PPUSH
77244: LD_VAR 0 4
77248: PPUSH
77249: LD_VAR 0 5
77253: PPUSH
77254: CALL 79025 0 3
77258: GO 77261
77260: POP
// end ;
77261: LD_VAR 0 12
77265: RET
// export function hHackSpawnBuilding ( nation , btype , dir , weapon , x , y ) ; var b ; begin
77266: LD_INT 0
77268: PPUSH
77269: PPUSH
// if nation < 1 or nation > 3 or HexInfo ( x , y ) then
77270: LD_VAR 0 1
77274: PUSH
77275: LD_INT 1
77277: LESS
77278: PUSH
77279: LD_VAR 0 1
77283: PUSH
77284: LD_INT 3
77286: GREATER
77287: OR
77288: PUSH
77289: LD_VAR 0 5
77293: PPUSH
77294: LD_VAR 0 6
77298: PPUSH
77299: CALL_OW 428
77303: OR
77304: IFFALSE 77308
// exit ;
77306: GO 78028
// uc_side := your_side ;
77308: LD_ADDR_OWVAR 20
77312: PUSH
77313: LD_OWVAR 2
77317: ST_TO_ADDR
// uc_nation := nation ;
77318: LD_ADDR_OWVAR 21
77322: PUSH
77323: LD_VAR 0 1
77327: ST_TO_ADDR
// bc_level = 1 ;
77328: LD_ADDR_OWVAR 43
77332: PUSH
77333: LD_INT 1
77335: ST_TO_ADDR
// case btype of 1 :
77336: LD_VAR 0 2
77340: PUSH
77341: LD_INT 1
77343: DOUBLE
77344: EQUAL
77345: IFTRUE 77349
77347: GO 77360
77349: POP
// bc_type := b_depot ; 2 :
77350: LD_ADDR_OWVAR 42
77354: PUSH
77355: LD_INT 0
77357: ST_TO_ADDR
77358: GO 77972
77360: LD_INT 2
77362: DOUBLE
77363: EQUAL
77364: IFTRUE 77368
77366: GO 77379
77368: POP
// bc_type := b_warehouse ; 3 :
77369: LD_ADDR_OWVAR 42
77373: PUSH
77374: LD_INT 1
77376: ST_TO_ADDR
77377: GO 77972
77379: LD_INT 3
77381: DOUBLE
77382: EQUAL
77383: IFTRUE 77387
77385: GO 77398
77387: POP
// bc_type := b_lab ; 4 .. 9 :
77388: LD_ADDR_OWVAR 42
77392: PUSH
77393: LD_INT 6
77395: ST_TO_ADDR
77396: GO 77972
77398: LD_INT 4
77400: DOUBLE
77401: GREATEREQUAL
77402: IFFALSE 77410
77404: LD_INT 9
77406: DOUBLE
77407: LESSEQUAL
77408: IFTRUE 77412
77410: GO 77464
77412: POP
// begin bc_type := b_lab_half ;
77413: LD_ADDR_OWVAR 42
77417: PUSH
77418: LD_INT 7
77420: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_opto , b_lab_spacetime , b_lab_biological ] [ btype - 3 ] ;
77421: LD_ADDR_OWVAR 44
77425: PUSH
77426: LD_INT 10
77428: PUSH
77429: LD_INT 11
77431: PUSH
77432: LD_INT 12
77434: PUSH
77435: LD_INT 15
77437: PUSH
77438: LD_INT 14
77440: PUSH
77441: LD_INT 13
77443: PUSH
77444: EMPTY
77445: LIST
77446: LIST
77447: LIST
77448: LIST
77449: LIST
77450: LIST
77451: PUSH
77452: LD_VAR 0 2
77456: PUSH
77457: LD_INT 3
77459: MINUS
77460: ARRAY
77461: ST_TO_ADDR
// end ; 10 .. 13 :
77462: GO 77972
77464: LD_INT 10
77466: DOUBLE
77467: GREATEREQUAL
77468: IFFALSE 77476
77470: LD_INT 13
77472: DOUBLE
77473: LESSEQUAL
77474: IFTRUE 77478
77476: GO 77555
77478: POP
// begin bc_type := b_lab_full ;
77479: LD_ADDR_OWVAR 42
77483: PUSH
77484: LD_INT 8
77486: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_computer , b_lab_spacetime , b_lab_biological ] [ btype - 9 ] ;
77487: LD_ADDR_OWVAR 44
77491: PUSH
77492: LD_INT 10
77494: PUSH
77495: LD_INT 12
77497: PUSH
77498: LD_INT 14
77500: PUSH
77501: LD_INT 13
77503: PUSH
77504: EMPTY
77505: LIST
77506: LIST
77507: LIST
77508: LIST
77509: PUSH
77510: LD_VAR 0 2
77514: PUSH
77515: LD_INT 9
77517: MINUS
77518: ARRAY
77519: ST_TO_ADDR
// bc_kind2 := [ b_lab_siberium , b_lab_opto , b_lab_computer , b_lab_opto ] [ btype - 9 ] ;
77520: LD_ADDR_OWVAR 45
77524: PUSH
77525: LD_INT 11
77527: PUSH
77528: LD_INT 15
77530: PUSH
77531: LD_INT 12
77533: PUSH
77534: LD_INT 15
77536: PUSH
77537: EMPTY
77538: LIST
77539: LIST
77540: LIST
77541: LIST
77542: PUSH
77543: LD_VAR 0 2
77547: PUSH
77548: LD_INT 9
77550: MINUS
77551: ARRAY
77552: ST_TO_ADDR
// end ; 14 :
77553: GO 77972
77555: LD_INT 14
77557: DOUBLE
77558: EQUAL
77559: IFTRUE 77563
77561: GO 77574
77563: POP
// bc_type := b_workshop ; 15 :
77564: LD_ADDR_OWVAR 42
77568: PUSH
77569: LD_INT 2
77571: ST_TO_ADDR
77572: GO 77972
77574: LD_INT 15
77576: DOUBLE
77577: EQUAL
77578: IFTRUE 77582
77580: GO 77593
77582: POP
// bc_type := b_factory ; 16 :
77583: LD_ADDR_OWVAR 42
77587: PUSH
77588: LD_INT 3
77590: ST_TO_ADDR
77591: GO 77972
77593: LD_INT 16
77595: DOUBLE
77596: EQUAL
77597: IFTRUE 77601
77599: GO 77612
77601: POP
// bc_type := b_ext_gun ; 17 :
77602: LD_ADDR_OWVAR 42
77606: PUSH
77607: LD_INT 17
77609: ST_TO_ADDR
77610: GO 77972
77612: LD_INT 17
77614: DOUBLE
77615: EQUAL
77616: IFTRUE 77620
77618: GO 77648
77620: POP
// bc_type := [ b_ext_noncombat , b_ext_stitch , b_ext_noncombat ] [ nation ] ; 18 :
77621: LD_ADDR_OWVAR 42
77625: PUSH
77626: LD_INT 19
77628: PUSH
77629: LD_INT 23
77631: PUSH
77632: LD_INT 19
77634: PUSH
77635: EMPTY
77636: LIST
77637: LIST
77638: LIST
77639: PUSH
77640: LD_VAR 0 1
77644: ARRAY
77645: ST_TO_ADDR
77646: GO 77972
77648: LD_INT 18
77650: DOUBLE
77651: EQUAL
77652: IFTRUE 77656
77654: GO 77667
77656: POP
// bc_type := b_ext_radar ; 19 :
77657: LD_ADDR_OWVAR 42
77661: PUSH
77662: LD_INT 20
77664: ST_TO_ADDR
77665: GO 77972
77667: LD_INT 19
77669: DOUBLE
77670: EQUAL
77671: IFTRUE 77675
77673: GO 77686
77675: POP
// bc_type := b_ext_radio ; 20 :
77676: LD_ADDR_OWVAR 42
77680: PUSH
77681: LD_INT 22
77683: ST_TO_ADDR
77684: GO 77972
77686: LD_INT 20
77688: DOUBLE
77689: EQUAL
77690: IFTRUE 77694
77692: GO 77705
77694: POP
// bc_type := b_ext_siberium ; 21 :
77695: LD_ADDR_OWVAR 42
77699: PUSH
77700: LD_INT 21
77702: ST_TO_ADDR
77703: GO 77972
77705: LD_INT 21
77707: DOUBLE
77708: EQUAL
77709: IFTRUE 77713
77711: GO 77724
77713: POP
// bc_type := b_ext_computer ; 22 :
77714: LD_ADDR_OWVAR 42
77718: PUSH
77719: LD_INT 24
77721: ST_TO_ADDR
77722: GO 77972
77724: LD_INT 22
77726: DOUBLE
77727: EQUAL
77728: IFTRUE 77732
77730: GO 77743
77732: POP
// bc_type := b_ext_track ; 23 :
77733: LD_ADDR_OWVAR 42
77737: PUSH
77738: LD_INT 16
77740: ST_TO_ADDR
77741: GO 77972
77743: LD_INT 23
77745: DOUBLE
77746: EQUAL
77747: IFTRUE 77751
77749: GO 77762
77751: POP
// bc_type := b_ext_laser ; 24 :
77752: LD_ADDR_OWVAR 42
77756: PUSH
77757: LD_INT 25
77759: ST_TO_ADDR
77760: GO 77972
77762: LD_INT 24
77764: DOUBLE
77765: EQUAL
77766: IFTRUE 77770
77768: GO 77781
77770: POP
// bc_type := b_control_tower ; 25 :
77771: LD_ADDR_OWVAR 42
77775: PUSH
77776: LD_INT 36
77778: ST_TO_ADDR
77779: GO 77972
77781: LD_INT 25
77783: DOUBLE
77784: EQUAL
77785: IFTRUE 77789
77787: GO 77800
77789: POP
// bc_type := b_breastwork ; 26 :
77790: LD_ADDR_OWVAR 42
77794: PUSH
77795: LD_INT 31
77797: ST_TO_ADDR
77798: GO 77972
77800: LD_INT 26
77802: DOUBLE
77803: EQUAL
77804: IFTRUE 77808
77806: GO 77819
77808: POP
// bc_type := b_bunker ; 27 :
77809: LD_ADDR_OWVAR 42
77813: PUSH
77814: LD_INT 32
77816: ST_TO_ADDR
77817: GO 77972
77819: LD_INT 27
77821: DOUBLE
77822: EQUAL
77823: IFTRUE 77827
77825: GO 77838
77827: POP
// bc_type := b_turret ; 28 :
77828: LD_ADDR_OWVAR 42
77832: PUSH
77833: LD_INT 33
77835: ST_TO_ADDR
77836: GO 77972
77838: LD_INT 28
77840: DOUBLE
77841: EQUAL
77842: IFTRUE 77846
77844: GO 77857
77846: POP
// bc_type := b_armoury ; 29 :
77847: LD_ADDR_OWVAR 42
77851: PUSH
77852: LD_INT 4
77854: ST_TO_ADDR
77855: GO 77972
77857: LD_INT 29
77859: DOUBLE
77860: EQUAL
77861: IFTRUE 77865
77863: GO 77876
77865: POP
// bc_type := b_barracks ; 30 :
77866: LD_ADDR_OWVAR 42
77870: PUSH
77871: LD_INT 5
77873: ST_TO_ADDR
77874: GO 77972
77876: LD_INT 30
77878: DOUBLE
77879: EQUAL
77880: IFTRUE 77884
77882: GO 77895
77884: POP
// bc_type := b_solar_power ; 31 :
77885: LD_ADDR_OWVAR 42
77889: PUSH
77890: LD_INT 27
77892: ST_TO_ADDR
77893: GO 77972
77895: LD_INT 31
77897: DOUBLE
77898: EQUAL
77899: IFTRUE 77903
77901: GO 77914
77903: POP
// bc_type := b_oil_power ; 32 :
77904: LD_ADDR_OWVAR 42
77908: PUSH
77909: LD_INT 26
77911: ST_TO_ADDR
77912: GO 77972
77914: LD_INT 32
77916: DOUBLE
77917: EQUAL
77918: IFTRUE 77922
77920: GO 77933
77922: POP
// bc_type := b_siberite_power ; 33 :
77923: LD_ADDR_OWVAR 42
77927: PUSH
77928: LD_INT 28
77930: ST_TO_ADDR
77931: GO 77972
77933: LD_INT 33
77935: DOUBLE
77936: EQUAL
77937: IFTRUE 77941
77939: GO 77952
77941: POP
// bc_type := b_oil_mine ; 34 :
77942: LD_ADDR_OWVAR 42
77946: PUSH
77947: LD_INT 29
77949: ST_TO_ADDR
77950: GO 77972
77952: LD_INT 34
77954: DOUBLE
77955: EQUAL
77956: IFTRUE 77960
77958: GO 77971
77960: POP
// bc_type := b_siberite_mine ; end ;
77961: LD_ADDR_OWVAR 42
77965: PUSH
77966: LD_INT 30
77968: ST_TO_ADDR
77969: GO 77972
77971: POP
// b := CreateAndPlaceBuildingXYD ( x , y , dir ) ;
77972: LD_ADDR_VAR 0 8
77976: PUSH
77977: LD_VAR 0 5
77981: PPUSH
77982: LD_VAR 0 6
77986: PPUSH
77987: LD_VAR 0 3
77991: PPUSH
77992: CALL_OW 47
77996: ST_TO_ADDR
// if bc_type in [ b_bunker , b_turret ] then
77997: LD_OWVAR 42
78001: PUSH
78002: LD_INT 32
78004: PUSH
78005: LD_INT 33
78007: PUSH
78008: EMPTY
78009: LIST
78010: LIST
78011: IN
78012: IFFALSE 78028
// PlaceWeaponTurret ( b , weapon ) ;
78014: LD_VAR 0 8
78018: PPUSH
78019: LD_VAR 0 4
78023: PPUSH
78024: CALL_OW 431
// end ;
78028: LD_VAR 0 7
78032: RET
// export function hHackUnlimitedResources ; var i , j , tmp ; begin
78033: LD_INT 0
78035: PPUSH
78036: PPUSH
78037: PPUSH
78038: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
78039: LD_ADDR_VAR 0 4
78043: PUSH
78044: LD_INT 22
78046: PUSH
78047: LD_OWVAR 2
78051: PUSH
78052: EMPTY
78053: LIST
78054: LIST
78055: PUSH
78056: LD_INT 2
78058: PUSH
78059: LD_INT 30
78061: PUSH
78062: LD_INT 0
78064: PUSH
78065: EMPTY
78066: LIST
78067: LIST
78068: PUSH
78069: LD_INT 30
78071: PUSH
78072: LD_INT 1
78074: PUSH
78075: EMPTY
78076: LIST
78077: LIST
78078: PUSH
78079: EMPTY
78080: LIST
78081: LIST
78082: LIST
78083: PUSH
78084: EMPTY
78085: LIST
78086: LIST
78087: PPUSH
78088: CALL_OW 69
78092: ST_TO_ADDR
// if not tmp then
78093: LD_VAR 0 4
78097: NOT
78098: IFFALSE 78102
// exit ;
78100: GO 78161
// for i in tmp do
78102: LD_ADDR_VAR 0 2
78106: PUSH
78107: LD_VAR 0 4
78111: PUSH
78112: FOR_IN
78113: IFFALSE 78159
// for j = 1 to 3 do
78115: LD_ADDR_VAR 0 3
78119: PUSH
78120: DOUBLE
78121: LD_INT 1
78123: DEC
78124: ST_TO_ADDR
78125: LD_INT 3
78127: PUSH
78128: FOR_TO
78129: IFFALSE 78155
// SetResourceType ( GetBase ( i ) , j , 99999 ) ;
78131: LD_VAR 0 2
78135: PPUSH
78136: CALL_OW 274
78140: PPUSH
78141: LD_VAR 0 3
78145: PPUSH
78146: LD_INT 99999
78148: PPUSH
78149: CALL_OW 277
78153: GO 78128
78155: POP
78156: POP
78157: GO 78112
78159: POP
78160: POP
// end ;
78161: LD_VAR 0 1
78165: RET
// export function hHackSetLevel10 ; var i , j ; begin
78166: LD_INT 0
78168: PPUSH
78169: PPUSH
78170: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
78171: LD_ADDR_VAR 0 2
78175: PUSH
78176: LD_INT 21
78178: PUSH
78179: LD_INT 1
78181: PUSH
78182: EMPTY
78183: LIST
78184: LIST
78185: PPUSH
78186: CALL_OW 69
78190: PUSH
78191: FOR_IN
78192: IFFALSE 78244
// if IsSelected ( i ) then
78194: LD_VAR 0 2
78198: PPUSH
78199: CALL_OW 306
78203: IFFALSE 78242
// begin for j := 1 to 4 do
78205: LD_ADDR_VAR 0 3
78209: PUSH
78210: DOUBLE
78211: LD_INT 1
78213: DEC
78214: ST_TO_ADDR
78215: LD_INT 4
78217: PUSH
78218: FOR_TO
78219: IFFALSE 78240
// SetSkill ( i , j , 10 ) ;
78221: LD_VAR 0 2
78225: PPUSH
78226: LD_VAR 0 3
78230: PPUSH
78231: LD_INT 10
78233: PPUSH
78234: CALL_OW 237
78238: GO 78218
78240: POP
78241: POP
// end ;
78242: GO 78191
78244: POP
78245: POP
// end ;
78246: LD_VAR 0 1
78250: RET
// export function hHackSetLevel10YourUnits ; var i , j ; begin
78251: LD_INT 0
78253: PPUSH
78254: PPUSH
78255: PPUSH
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) do
78256: LD_ADDR_VAR 0 2
78260: PUSH
78261: LD_INT 22
78263: PUSH
78264: LD_OWVAR 2
78268: PUSH
78269: EMPTY
78270: LIST
78271: LIST
78272: PUSH
78273: LD_INT 21
78275: PUSH
78276: LD_INT 1
78278: PUSH
78279: EMPTY
78280: LIST
78281: LIST
78282: PUSH
78283: EMPTY
78284: LIST
78285: LIST
78286: PPUSH
78287: CALL_OW 69
78291: PUSH
78292: FOR_IN
78293: IFFALSE 78334
// begin for j := 1 to 4 do
78295: LD_ADDR_VAR 0 3
78299: PUSH
78300: DOUBLE
78301: LD_INT 1
78303: DEC
78304: ST_TO_ADDR
78305: LD_INT 4
78307: PUSH
78308: FOR_TO
78309: IFFALSE 78330
// SetSkill ( i , j , 10 ) ;
78311: LD_VAR 0 2
78315: PPUSH
78316: LD_VAR 0 3
78320: PPUSH
78321: LD_INT 10
78323: PPUSH
78324: CALL_OW 237
78328: GO 78308
78330: POP
78331: POP
// end ;
78332: GO 78292
78334: POP
78335: POP
// end ;
78336: LD_VAR 0 1
78340: RET
// export function hHackSpawnHuman ( nation , class , skill , x , y ) ; begin
78341: LD_INT 0
78343: PPUSH
// uc_side := your_side ;
78344: LD_ADDR_OWVAR 20
78348: PUSH
78349: LD_OWVAR 2
78353: ST_TO_ADDR
// uc_nation := nation ;
78354: LD_ADDR_OWVAR 21
78358: PUSH
78359: LD_VAR 0 1
78363: ST_TO_ADDR
// InitHc ;
78364: CALL_OW 19
// PrepareHuman ( false , class , skill ) ;
78368: LD_INT 0
78370: PPUSH
78371: LD_VAR 0 2
78375: PPUSH
78376: LD_VAR 0 3
78380: PPUSH
78381: CALL_OW 380
// if HexInfo ( x , y ) = 0 then
78385: LD_VAR 0 4
78389: PPUSH
78390: LD_VAR 0 5
78394: PPUSH
78395: CALL_OW 428
78399: PUSH
78400: LD_INT 0
78402: EQUAL
78403: IFFALSE 78427
// PlaceUnitXY ( CreateHuman , x , y , true ) ;
78405: CALL_OW 44
78409: PPUSH
78410: LD_VAR 0 4
78414: PPUSH
78415: LD_VAR 0 5
78419: PPUSH
78420: LD_INT 1
78422: PPUSH
78423: CALL_OW 48
// end ;
78427: LD_VAR 0 6
78431: RET
// export function hHackSpawnVehicle ( chassis , engine , control , weapon , x , y ) ; var un ; begin
78432: LD_INT 0
78434: PPUSH
78435: PPUSH
// uc_side := your_side ;
78436: LD_ADDR_OWVAR 20
78440: PUSH
78441: LD_OWVAR 2
78445: ST_TO_ADDR
// if chassis in [ 1 , 2 , 3 , 4 , 5 ] then
78446: LD_VAR 0 1
78450: PUSH
78451: LD_INT 1
78453: PUSH
78454: LD_INT 2
78456: PUSH
78457: LD_INT 3
78459: PUSH
78460: LD_INT 4
78462: PUSH
78463: LD_INT 5
78465: PUSH
78466: EMPTY
78467: LIST
78468: LIST
78469: LIST
78470: LIST
78471: LIST
78472: IN
78473: IFFALSE 78485
// uc_nation := nation_american else
78475: LD_ADDR_OWVAR 21
78479: PUSH
78480: LD_INT 1
78482: ST_TO_ADDR
78483: GO 78528
// if chassis in [ 11 , 12 , 13 , 14 ] then
78485: LD_VAR 0 1
78489: PUSH
78490: LD_INT 11
78492: PUSH
78493: LD_INT 12
78495: PUSH
78496: LD_INT 13
78498: PUSH
78499: LD_INT 14
78501: PUSH
78502: EMPTY
78503: LIST
78504: LIST
78505: LIST
78506: LIST
78507: IN
78508: IFFALSE 78520
// uc_nation := nation_arabian else
78510: LD_ADDR_OWVAR 21
78514: PUSH
78515: LD_INT 2
78517: ST_TO_ADDR
78518: GO 78528
// uc_nation := nation_russian ;
78520: LD_ADDR_OWVAR 21
78524: PUSH
78525: LD_INT 3
78527: ST_TO_ADDR
// vc_chassis := chassis ;
78528: LD_ADDR_OWVAR 37
78532: PUSH
78533: LD_VAR 0 1
78537: ST_TO_ADDR
// vc_engine := engine ;
78538: LD_ADDR_OWVAR 39
78542: PUSH
78543: LD_VAR 0 2
78547: ST_TO_ADDR
// vc_control := control ;
78548: LD_ADDR_OWVAR 38
78552: PUSH
78553: LD_VAR 0 3
78557: ST_TO_ADDR
// vc_weapon := weapon ;
78558: LD_ADDR_OWVAR 40
78562: PUSH
78563: LD_VAR 0 4
78567: ST_TO_ADDR
// un := CreateVehicle ;
78568: LD_ADDR_VAR 0 8
78572: PUSH
78573: CALL_OW 45
78577: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
78578: LD_VAR 0 8
78582: PPUSH
78583: LD_INT 0
78585: PPUSH
78586: LD_INT 5
78588: PPUSH
78589: CALL_OW 12
78593: PPUSH
78594: CALL_OW 233
// PlaceUnitXY ( un , x , y , true ) ;
78598: LD_VAR 0 8
78602: PPUSH
78603: LD_VAR 0 5
78607: PPUSH
78608: LD_VAR 0 6
78612: PPUSH
78613: LD_INT 1
78615: PPUSH
78616: CALL_OW 48
// end ;
78620: LD_VAR 0 7
78624: RET
// export hInvincible ; every 1 do
78625: GO 78627
78627: DISABLE
// hInvincible := [ ] ;
78628: LD_ADDR_EXP 154
78632: PUSH
78633: EMPTY
78634: ST_TO_ADDR
78635: END
// every 10 do var i ;
78636: GO 78638
78638: DISABLE
78639: LD_INT 0
78641: PPUSH
// begin enable ;
78642: ENABLE
// if not hInvincible then
78643: LD_EXP 154
78647: NOT
78648: IFFALSE 78652
// exit ;
78650: GO 78696
// for i in hInvincible do
78652: LD_ADDR_VAR 0 1
78656: PUSH
78657: LD_EXP 154
78661: PUSH
78662: FOR_IN
78663: IFFALSE 78694
// if GetLives ( i ) < 1000 then
78665: LD_VAR 0 1
78669: PPUSH
78670: CALL_OW 256
78674: PUSH
78675: LD_INT 1000
78677: LESS
78678: IFFALSE 78692
// SetLives ( i , 1000 ) ;
78680: LD_VAR 0 1
78684: PPUSH
78685: LD_INT 1000
78687: PPUSH
78688: CALL_OW 234
78692: GO 78662
78694: POP
78695: POP
// end ;
78696: PPOPN 1
78698: END
// export function hHackInvincible ; var i ; begin
78699: LD_INT 0
78701: PPUSH
78702: PPUSH
// for i in FilterAllUnits ( [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ) do
78703: LD_ADDR_VAR 0 2
78707: PUSH
78708: LD_INT 2
78710: PUSH
78711: LD_INT 21
78713: PUSH
78714: LD_INT 1
78716: PUSH
78717: EMPTY
78718: LIST
78719: LIST
78720: PUSH
78721: LD_INT 21
78723: PUSH
78724: LD_INT 2
78726: PUSH
78727: EMPTY
78728: LIST
78729: LIST
78730: PUSH
78731: EMPTY
78732: LIST
78733: LIST
78734: LIST
78735: PPUSH
78736: CALL_OW 69
78740: PUSH
78741: FOR_IN
78742: IFFALSE 78803
// if IsSelected ( i ) then
78744: LD_VAR 0 2
78748: PPUSH
78749: CALL_OW 306
78753: IFFALSE 78801
// begin if i in hInvincible then
78755: LD_VAR 0 2
78759: PUSH
78760: LD_EXP 154
78764: IN
78765: IFFALSE 78785
// hInvincible := hInvincible diff i else
78767: LD_ADDR_EXP 154
78771: PUSH
78772: LD_EXP 154
78776: PUSH
78777: LD_VAR 0 2
78781: DIFF
78782: ST_TO_ADDR
78783: GO 78801
// hInvincible := hInvincible union i ;
78785: LD_ADDR_EXP 154
78789: PUSH
78790: LD_EXP 154
78794: PUSH
78795: LD_VAR 0 2
78799: UNION
78800: ST_TO_ADDR
// end ;
78801: GO 78741
78803: POP
78804: POP
// end ;
78805: LD_VAR 0 1
78809: RET
// export function hHackInvisible ; var i , j ; begin
78810: LD_INT 0
78812: PPUSH
78813: PPUSH
78814: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
78815: LD_ADDR_VAR 0 2
78819: PUSH
78820: LD_INT 21
78822: PUSH
78823: LD_INT 1
78825: PUSH
78826: EMPTY
78827: LIST
78828: LIST
78829: PPUSH
78830: CALL_OW 69
78834: PUSH
78835: FOR_IN
78836: IFFALSE 78860
// if IsSelected ( i ) then
78838: LD_VAR 0 2
78842: PPUSH
78843: CALL_OW 306
78847: IFFALSE 78858
// ComForceInvisible ( i ) ;
78849: LD_VAR 0 2
78853: PPUSH
78854: CALL_OW 496
78858: GO 78835
78860: POP
78861: POP
// end ;
78862: LD_VAR 0 1
78866: RET
// export function hHackChangeYourSide ; begin
78867: LD_INT 0
78869: PPUSH
// if your_side = 8 then
78870: LD_OWVAR 2
78874: PUSH
78875: LD_INT 8
78877: EQUAL
78878: IFFALSE 78890
// your_side := 0 else
78880: LD_ADDR_OWVAR 2
78884: PUSH
78885: LD_INT 0
78887: ST_TO_ADDR
78888: GO 78904
// your_side := your_side + 1 ;
78890: LD_ADDR_OWVAR 2
78894: PUSH
78895: LD_OWVAR 2
78899: PUSH
78900: LD_INT 1
78902: PLUS
78903: ST_TO_ADDR
// end ;
78904: LD_VAR 0 1
78908: RET
// export function hHackChangeUnitSide ; var i , j ; begin
78909: LD_INT 0
78911: PPUSH
78912: PPUSH
78913: PPUSH
// for i in all_units do
78914: LD_ADDR_VAR 0 2
78918: PUSH
78919: LD_OWVAR 3
78923: PUSH
78924: FOR_IN
78925: IFFALSE 79003
// if IsSelected ( i ) then
78927: LD_VAR 0 2
78931: PPUSH
78932: CALL_OW 306
78936: IFFALSE 79001
// begin j := GetSide ( i ) ;
78938: LD_ADDR_VAR 0 3
78942: PUSH
78943: LD_VAR 0 2
78947: PPUSH
78948: CALL_OW 255
78952: ST_TO_ADDR
// if j = 8 then
78953: LD_VAR 0 3
78957: PUSH
78958: LD_INT 8
78960: EQUAL
78961: IFFALSE 78973
// j := 0 else
78963: LD_ADDR_VAR 0 3
78967: PUSH
78968: LD_INT 0
78970: ST_TO_ADDR
78971: GO 78987
// j := j + 1 ;
78973: LD_ADDR_VAR 0 3
78977: PUSH
78978: LD_VAR 0 3
78982: PUSH
78983: LD_INT 1
78985: PLUS
78986: ST_TO_ADDR
// SetSide ( i , j ) ;
78987: LD_VAR 0 2
78991: PPUSH
78992: LD_VAR 0 3
78996: PPUSH
78997: CALL_OW 235
// end ;
79001: GO 78924
79003: POP
79004: POP
// end ;
79005: LD_VAR 0 1
79009: RET
// export function hHackFog ; begin
79010: LD_INT 0
79012: PPUSH
// FogOff ( true ) ;
79013: LD_INT 1
79015: PPUSH
79016: CALL_OW 344
// end ;
79020: LD_VAR 0 1
79024: RET
// export function hHackTeleport ( unit , x , y ) ; begin
79025: LD_INT 0
79027: PPUSH
// TeleportUnit ( unit , x , y , 1 , true ) ;
79028: LD_VAR 0 1
79032: PPUSH
79033: LD_VAR 0 2
79037: PPUSH
79038: LD_VAR 0 3
79042: PPUSH
79043: LD_INT 1
79045: PPUSH
79046: LD_INT 1
79048: PPUSH
79049: CALL_OW 483
// CenterOnXY ( x , y ) ;
79053: LD_VAR 0 2
79057: PPUSH
79058: LD_VAR 0 3
79062: PPUSH
79063: CALL_OW 84
// end ;
79067: LD_VAR 0 4
79071: RET
// export factoryWaypoints ; export function SetFactoryWaypoint ( factory , x , y ) ; var i ; begin
79072: LD_INT 0
79074: PPUSH
79075: PPUSH
// if not factory or not ValidHex ( x , y ) or ( GetBType ( factory ) <> b_factory and not GetType ( factory ) = unit_human ) then
79076: LD_VAR 0 1
79080: NOT
79081: PUSH
79082: LD_VAR 0 2
79086: PPUSH
79087: LD_VAR 0 3
79091: PPUSH
79092: CALL_OW 488
79096: NOT
79097: OR
79098: PUSH
79099: LD_VAR 0 1
79103: PPUSH
79104: CALL_OW 266
79108: PUSH
79109: LD_INT 3
79111: NONEQUAL
79112: PUSH
79113: LD_VAR 0 1
79117: PPUSH
79118: CALL_OW 247
79122: PUSH
79123: LD_INT 1
79125: EQUAL
79126: NOT
79127: AND
79128: OR
79129: IFFALSE 79133
// exit ;
79131: GO 79282
// if GetType ( factory ) = unit_human then
79133: LD_VAR 0 1
79137: PPUSH
79138: CALL_OW 247
79142: PUSH
79143: LD_INT 1
79145: EQUAL
79146: IFFALSE 79163
// factory := IsInUnit ( factory ) ;
79148: LD_ADDR_VAR 0 1
79152: PUSH
79153: LD_VAR 0 1
79157: PPUSH
79158: CALL_OW 310
79162: ST_TO_ADDR
// if GetBType ( factory ) <> b_factory then
79163: LD_VAR 0 1
79167: PPUSH
79168: CALL_OW 266
79172: PUSH
79173: LD_INT 3
79175: NONEQUAL
79176: IFFALSE 79180
// exit ;
79178: GO 79282
// if HexInfo ( x , y ) = factory then
79180: LD_VAR 0 2
79184: PPUSH
79185: LD_VAR 0 3
79189: PPUSH
79190: CALL_OW 428
79194: PUSH
79195: LD_VAR 0 1
79199: EQUAL
79200: IFFALSE 79227
// factoryWaypoints := Replace ( factoryWaypoints , factory , 0 ) else
79202: LD_ADDR_EXP 155
79206: PUSH
79207: LD_EXP 155
79211: PPUSH
79212: LD_VAR 0 1
79216: PPUSH
79217: LD_INT 0
79219: PPUSH
79220: CALL_OW 1
79224: ST_TO_ADDR
79225: GO 79278
// factoryWaypoints := Replace ( factoryWaypoints , factory , [ GetSide ( factory ) , factory , x , y ] ) ;
79227: LD_ADDR_EXP 155
79231: PUSH
79232: LD_EXP 155
79236: PPUSH
79237: LD_VAR 0 1
79241: PPUSH
79242: LD_VAR 0 1
79246: PPUSH
79247: CALL_OW 255
79251: PUSH
79252: LD_VAR 0 1
79256: PUSH
79257: LD_VAR 0 2
79261: PUSH
79262: LD_VAR 0 3
79266: PUSH
79267: EMPTY
79268: LIST
79269: LIST
79270: LIST
79271: LIST
79272: PPUSH
79273: CALL_OW 1
79277: ST_TO_ADDR
// UpdateFactoryWaypoints ;
79278: CALL 79287 0 0
// end ;
79282: LD_VAR 0 4
79286: RET
// export function UpdateFactoryWaypoints ( ) ; var i , list ; begin
79287: LD_INT 0
79289: PPUSH
79290: PPUSH
79291: PPUSH
// ToLua ( resetFactoryWaypoint(); ) ;
79292: LD_STRING resetFactoryWaypoint();
79294: PPUSH
79295: CALL_OW 559
// if factoryWaypoints then
79299: LD_EXP 155
79303: IFFALSE 79429
// begin list := PrepareArray ( factoryWaypoints ) ;
79305: LD_ADDR_VAR 0 3
79309: PUSH
79310: LD_EXP 155
79314: PPUSH
79315: CALL 60372 0 1
79319: ST_TO_ADDR
// for i := 1 to list do
79320: LD_ADDR_VAR 0 2
79324: PUSH
79325: DOUBLE
79326: LD_INT 1
79328: DEC
79329: ST_TO_ADDR
79330: LD_VAR 0 3
79334: PUSH
79335: FOR_TO
79336: IFFALSE 79427
// ToLua ( setFactoryWaypointXY( & list [ i ] [ 1 ] & , & list [ i ] [ 2 ] & , & list [ i ] [ 3 ] & , & list [ i ] [ 4 ] & ) ) ;
79338: LD_STRING setFactoryWaypointXY(
79340: PUSH
79341: LD_VAR 0 3
79345: PUSH
79346: LD_VAR 0 2
79350: ARRAY
79351: PUSH
79352: LD_INT 1
79354: ARRAY
79355: STR
79356: PUSH
79357: LD_STRING ,
79359: STR
79360: PUSH
79361: LD_VAR 0 3
79365: PUSH
79366: LD_VAR 0 2
79370: ARRAY
79371: PUSH
79372: LD_INT 2
79374: ARRAY
79375: STR
79376: PUSH
79377: LD_STRING ,
79379: STR
79380: PUSH
79381: LD_VAR 0 3
79385: PUSH
79386: LD_VAR 0 2
79390: ARRAY
79391: PUSH
79392: LD_INT 3
79394: ARRAY
79395: STR
79396: PUSH
79397: LD_STRING ,
79399: STR
79400: PUSH
79401: LD_VAR 0 3
79405: PUSH
79406: LD_VAR 0 2
79410: ARRAY
79411: PUSH
79412: LD_INT 4
79414: ARRAY
79415: STR
79416: PUSH
79417: LD_STRING )
79419: STR
79420: PPUSH
79421: CALL_OW 559
79425: GO 79335
79427: POP
79428: POP
// end ; end ;
79429: LD_VAR 0 1
79433: RET
// export warehouseGatheringPoints , warehouseCratesCollectors ; export function SetWarehouseGatheringPoint ( warehouse , x , y ) ; begin
79434: LD_INT 0
79436: PPUSH
// if HexInfo ( x , y ) = warehouse then
79437: LD_VAR 0 2
79441: PPUSH
79442: LD_VAR 0 3
79446: PPUSH
79447: CALL_OW 428
79451: PUSH
79452: LD_VAR 0 1
79456: EQUAL
79457: IFFALSE 79484
// warehouseGatheringPoints := Replace ( warehouseGatheringPoints , warehouse , 0 ) else
79459: LD_ADDR_EXP 156
79463: PUSH
79464: LD_EXP 156
79468: PPUSH
79469: LD_VAR 0 1
79473: PPUSH
79474: LD_INT 0
79476: PPUSH
79477: CALL_OW 1
79481: ST_TO_ADDR
79482: GO 79535
// warehouseGatheringPoints := Replace ( warehouseGatheringPoints , warehouse , [ GetSide ( warehouse ) , warehouse , x , y ] ) ;
79484: LD_ADDR_EXP 156
79488: PUSH
79489: LD_EXP 156
79493: PPUSH
79494: LD_VAR 0 1
79498: PPUSH
79499: LD_VAR 0 1
79503: PPUSH
79504: CALL_OW 255
79508: PUSH
79509: LD_VAR 0 1
79513: PUSH
79514: LD_VAR 0 2
79518: PUSH
79519: LD_VAR 0 3
79523: PUSH
79524: EMPTY
79525: LIST
79526: LIST
79527: LIST
79528: LIST
79529: PPUSH
79530: CALL_OW 1
79534: ST_TO_ADDR
// UpdateWarehouseGatheringPoints ;
79535: CALL 79544 0 0
// end ;
79539: LD_VAR 0 4
79543: RET
// export function UpdateWarehouseGatheringPoints ( ) ; var i , list ; begin
79544: LD_INT 0
79546: PPUSH
79547: PPUSH
79548: PPUSH
// ToLua ( resetWarehouseGatheringPoints(); ) ;
79549: LD_STRING resetWarehouseGatheringPoints();
79551: PPUSH
79552: CALL_OW 559
// if warehouseGatheringPoints then
79556: LD_EXP 156
79560: IFFALSE 79686
// begin list := PrepareArray ( warehouseGatheringPoints ) ;
79562: LD_ADDR_VAR 0 3
79566: PUSH
79567: LD_EXP 156
79571: PPUSH
79572: CALL 60372 0 1
79576: ST_TO_ADDR
// for i := 1 to list do
79577: LD_ADDR_VAR 0 2
79581: PUSH
79582: DOUBLE
79583: LD_INT 1
79585: DEC
79586: ST_TO_ADDR
79587: LD_VAR 0 3
79591: PUSH
79592: FOR_TO
79593: IFFALSE 79684
// ToLua ( setWarehouseGatheringPointXY( & list [ i ] [ 1 ] & , & list [ i ] [ 2 ] & , & list [ i ] [ 3 ] & , & list [ i ] [ 4 ] & ) ) ;
79595: LD_STRING setWarehouseGatheringPointXY(
79597: PUSH
79598: LD_VAR 0 3
79602: PUSH
79603: LD_VAR 0 2
79607: ARRAY
79608: PUSH
79609: LD_INT 1
79611: ARRAY
79612: STR
79613: PUSH
79614: LD_STRING ,
79616: STR
79617: PUSH
79618: LD_VAR 0 3
79622: PUSH
79623: LD_VAR 0 2
79627: ARRAY
79628: PUSH
79629: LD_INT 2
79631: ARRAY
79632: STR
79633: PUSH
79634: LD_STRING ,
79636: STR
79637: PUSH
79638: LD_VAR 0 3
79642: PUSH
79643: LD_VAR 0 2
79647: ARRAY
79648: PUSH
79649: LD_INT 3
79651: ARRAY
79652: STR
79653: PUSH
79654: LD_STRING ,
79656: STR
79657: PUSH
79658: LD_VAR 0 3
79662: PUSH
79663: LD_VAR 0 2
79667: ARRAY
79668: PUSH
79669: LD_INT 4
79671: ARRAY
79672: STR
79673: PUSH
79674: LD_STRING )
79676: STR
79677: PPUSH
79678: CALL_OW 559
79682: GO 79592
79684: POP
79685: POP
// end ; end ;
79686: LD_VAR 0 1
79690: RET
// every 0 0$20 trigger warehouseGatheringPoints do var i , j , list , tmp , side , x , y , depot , cratesNearbyPoint ;
79691: LD_EXP 156
79695: IFFALSE 80382
79697: GO 79699
79699: DISABLE
79700: LD_INT 0
79702: PPUSH
79703: PPUSH
79704: PPUSH
79705: PPUSH
79706: PPUSH
79707: PPUSH
79708: PPUSH
79709: PPUSH
79710: PPUSH
// begin enable ;
79711: ENABLE
// list := PrepareArray ( warehouseGatheringPoints ) ;
79712: LD_ADDR_VAR 0 3
79716: PUSH
79717: LD_EXP 156
79721: PPUSH
79722: CALL 60372 0 1
79726: ST_TO_ADDR
// if not list then
79727: LD_VAR 0 3
79731: NOT
79732: IFFALSE 79736
// exit ;
79734: GO 80382
// for i := 1 to list do
79736: LD_ADDR_VAR 0 1
79740: PUSH
79741: DOUBLE
79742: LD_INT 1
79744: DEC
79745: ST_TO_ADDR
79746: LD_VAR 0 3
79750: PUSH
79751: FOR_TO
79752: IFFALSE 80380
// begin depot := list [ i ] [ 2 ] ;
79754: LD_ADDR_VAR 0 8
79758: PUSH
79759: LD_VAR 0 3
79763: PUSH
79764: LD_VAR 0 1
79768: ARRAY
79769: PUSH
79770: LD_INT 2
79772: ARRAY
79773: ST_TO_ADDR
// side := list [ i ] [ 1 ] ;
79774: LD_ADDR_VAR 0 5
79778: PUSH
79779: LD_VAR 0 3
79783: PUSH
79784: LD_VAR 0 1
79788: ARRAY
79789: PUSH
79790: LD_INT 1
79792: ARRAY
79793: ST_TO_ADDR
// if IsDead ( depot ) or side <> GetSide ( depot ) then
79794: LD_VAR 0 8
79798: PPUSH
79799: CALL_OW 301
79803: PUSH
79804: LD_VAR 0 5
79808: PUSH
79809: LD_VAR 0 8
79813: PPUSH
79814: CALL_OW 255
79818: NONEQUAL
79819: OR
79820: IFFALSE 79849
// begin warehouseGatheringPoints := Replace ( warehouseGatheringPoints , depot , 0 ) ;
79822: LD_ADDR_EXP 156
79826: PUSH
79827: LD_EXP 156
79831: PPUSH
79832: LD_VAR 0 8
79836: PPUSH
79837: LD_INT 0
79839: PPUSH
79840: CALL_OW 1
79844: ST_TO_ADDR
// exit ;
79845: POP
79846: POP
79847: GO 80382
// end ; x := list [ i ] [ 3 ] ;
79849: LD_ADDR_VAR 0 6
79853: PUSH
79854: LD_VAR 0 3
79858: PUSH
79859: LD_VAR 0 1
79863: ARRAY
79864: PUSH
79865: LD_INT 3
79867: ARRAY
79868: ST_TO_ADDR
// y := list [ i ] [ 4 ] ;
79869: LD_ADDR_VAR 0 7
79873: PUSH
79874: LD_VAR 0 3
79878: PUSH
79879: LD_VAR 0 1
79883: ARRAY
79884: PUSH
79885: LD_INT 4
79887: ARRAY
79888: ST_TO_ADDR
// cratesNearbyPoint := GetCratesNearbyXY ( x , y , 16 ) ;
79889: LD_ADDR_VAR 0 9
79893: PUSH
79894: LD_VAR 0 6
79898: PPUSH
79899: LD_VAR 0 7
79903: PPUSH
79904: LD_INT 16
79906: PPUSH
79907: CALL 58956 0 3
79911: ST_TO_ADDR
// if not cratesNearbyPoint then
79912: LD_VAR 0 9
79916: NOT
79917: IFFALSE 79923
// exit ;
79919: POP
79920: POP
79921: GO 80382
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_hastask ] ] , [ f_dist , depot , 6 ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] ] ] ) union UnitFilter ( UnitsInside ( depot ) , [ [ f_not , [ f_hastask ] ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] ] ] ) ;
79923: LD_ADDR_VAR 0 4
79927: PUSH
79928: LD_INT 22
79930: PUSH
79931: LD_VAR 0 5
79935: PUSH
79936: EMPTY
79937: LIST
79938: LIST
79939: PUSH
79940: LD_INT 3
79942: PUSH
79943: LD_INT 60
79945: PUSH
79946: EMPTY
79947: LIST
79948: PUSH
79949: EMPTY
79950: LIST
79951: LIST
79952: PUSH
79953: LD_INT 91
79955: PUSH
79956: LD_VAR 0 8
79960: PUSH
79961: LD_INT 6
79963: PUSH
79964: EMPTY
79965: LIST
79966: LIST
79967: LIST
79968: PUSH
79969: LD_INT 2
79971: PUSH
79972: LD_INT 25
79974: PUSH
79975: LD_INT 2
79977: PUSH
79978: EMPTY
79979: LIST
79980: LIST
79981: PUSH
79982: LD_INT 25
79984: PUSH
79985: LD_INT 16
79987: PUSH
79988: EMPTY
79989: LIST
79990: LIST
79991: PUSH
79992: EMPTY
79993: LIST
79994: LIST
79995: LIST
79996: PUSH
79997: EMPTY
79998: LIST
79999: LIST
80000: LIST
80001: LIST
80002: PPUSH
80003: CALL_OW 69
80007: PUSH
80008: LD_VAR 0 8
80012: PPUSH
80013: CALL_OW 313
80017: PPUSH
80018: LD_INT 3
80020: PUSH
80021: LD_INT 60
80023: PUSH
80024: EMPTY
80025: LIST
80026: PUSH
80027: EMPTY
80028: LIST
80029: LIST
80030: PUSH
80031: LD_INT 2
80033: PUSH
80034: LD_INT 25
80036: PUSH
80037: LD_INT 2
80039: PUSH
80040: EMPTY
80041: LIST
80042: LIST
80043: PUSH
80044: LD_INT 25
80046: PUSH
80047: LD_INT 16
80049: PUSH
80050: EMPTY
80051: LIST
80052: LIST
80053: PUSH
80054: EMPTY
80055: LIST
80056: LIST
80057: LIST
80058: PUSH
80059: EMPTY
80060: LIST
80061: LIST
80062: PPUSH
80063: CALL_OW 72
80067: UNION
80068: ST_TO_ADDR
// if tmp then
80069: LD_VAR 0 4
80073: IFFALSE 80153
// begin tmp := ShrinkArray ( tmp , 3 ) ;
80075: LD_ADDR_VAR 0 4
80079: PUSH
80080: LD_VAR 0 4
80084: PPUSH
80085: LD_INT 3
80087: PPUSH
80088: CALL 56923 0 2
80092: ST_TO_ADDR
// for j in tmp do
80093: LD_ADDR_VAR 0 2
80097: PUSH
80098: LD_VAR 0 4
80102: PUSH
80103: FOR_IN
80104: IFFALSE 80147
// begin if IsInUnit ( j ) then
80106: LD_VAR 0 2
80110: PPUSH
80111: CALL_OW 310
80115: IFFALSE 80126
// ComExit ( j ) ;
80117: LD_VAR 0 2
80121: PPUSH
80122: CALL 57006 0 1
// AddComCollect ( j , x , y ) ;
80126: LD_VAR 0 2
80130: PPUSH
80131: LD_VAR 0 6
80135: PPUSH
80136: LD_VAR 0 7
80140: PPUSH
80141: CALL_OW 177
// end ;
80145: GO 80103
80147: POP
80148: POP
// exit ;
80149: POP
80150: POP
80151: GO 80382
// end ; tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_dist , depot , 8 ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ] ) ;
80153: LD_ADDR_VAR 0 4
80157: PUSH
80158: LD_INT 22
80160: PUSH
80161: LD_VAR 0 5
80165: PUSH
80166: EMPTY
80167: LIST
80168: LIST
80169: PUSH
80170: LD_INT 91
80172: PUSH
80173: LD_VAR 0 8
80177: PUSH
80178: LD_INT 8
80180: PUSH
80181: EMPTY
80182: LIST
80183: LIST
80184: LIST
80185: PUSH
80186: LD_INT 2
80188: PUSH
80189: LD_INT 34
80191: PUSH
80192: LD_INT 12
80194: PUSH
80195: EMPTY
80196: LIST
80197: LIST
80198: PUSH
80199: LD_INT 34
80201: PUSH
80202: LD_INT 51
80204: PUSH
80205: EMPTY
80206: LIST
80207: LIST
80208: PUSH
80209: LD_INT 34
80211: PUSH
80212: LD_INT 32
80214: PUSH
80215: EMPTY
80216: LIST
80217: LIST
80218: PUSH
80219: LD_INT 34
80221: PUSH
80222: LD_EXP 159
80226: PUSH
80227: EMPTY
80228: LIST
80229: LIST
80230: PUSH
80231: EMPTY
80232: LIST
80233: LIST
80234: LIST
80235: LIST
80236: LIST
80237: PUSH
80238: EMPTY
80239: LIST
80240: LIST
80241: LIST
80242: PPUSH
80243: CALL_OW 69
80247: ST_TO_ADDR
// if tmp then
80248: LD_VAR 0 4
80252: IFFALSE 80378
// begin for j in tmp do
80254: LD_ADDR_VAR 0 2
80258: PUSH
80259: LD_VAR 0 4
80263: PUSH
80264: FOR_IN
80265: IFFALSE 80376
// if ( GetEngine ( j ) = engine_siberite or GetFuel ( j ) > 20 ) and not HasTask ( j ) and ( GetControl ( j ) <> control_manual or IsDrivenBy ( j ) ) then
80267: LD_VAR 0 2
80271: PPUSH
80272: CALL_OW 262
80276: PUSH
80277: LD_INT 3
80279: EQUAL
80280: PUSH
80281: LD_VAR 0 2
80285: PPUSH
80286: CALL_OW 261
80290: PUSH
80291: LD_INT 20
80293: GREATER
80294: OR
80295: PUSH
80296: LD_VAR 0 2
80300: PPUSH
80301: CALL_OW 314
80305: NOT
80306: AND
80307: PUSH
80308: LD_VAR 0 2
80312: PPUSH
80313: CALL_OW 263
80317: PUSH
80318: LD_INT 1
80320: NONEQUAL
80321: PUSH
80322: LD_VAR 0 2
80326: PPUSH
80327: CALL_OW 311
80331: OR
80332: AND
80333: IFFALSE 80374
// begin ComCollect ( j , x , y ) ;
80335: LD_VAR 0 2
80339: PPUSH
80340: LD_VAR 0 6
80344: PPUSH
80345: LD_VAR 0 7
80349: PPUSH
80350: CALL_OW 117
// AddComMoveUnit ( j , depot ) ;
80354: LD_VAR 0 2
80358: PPUSH
80359: LD_VAR 0 8
80363: PPUSH
80364: CALL_OW 172
// exit ;
80368: POP
80369: POP
80370: POP
80371: POP
80372: GO 80382
// end ;
80374: GO 80264
80376: POP
80377: POP
// end ; end ;
80378: GO 79751
80380: POP
80381: POP
// end ; end_of_file
80382: PPOPN 9
80384: END
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb , ar_mortar , ar_crane , ar_miner , ru_flamethrower ; export tech_Artillery , tech_RadMat , tech_BasicTools , tech_Cargo , tech_Track , tech_Crane , tech_Bulldozer , tech_Hovercraft , tech_MultiBarrels ; export function InitGlobalVariables ; begin
80385: LD_INT 0
80387: PPUSH
// ar_miner := 81 ;
80388: LD_ADDR_EXP 165
80392: PUSH
80393: LD_INT 81
80395: ST_TO_ADDR
// ar_crane := 88 ;
80396: LD_ADDR_EXP 164
80400: PUSH
80401: LD_INT 88
80403: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
80404: LD_ADDR_EXP 159
80408: PUSH
80409: LD_INT 89
80411: ST_TO_ADDR
// us_hack := 99 ;
80412: LD_ADDR_EXP 160
80416: PUSH
80417: LD_INT 99
80419: ST_TO_ADDR
// us_artillery := 97 ;
80420: LD_ADDR_EXP 161
80424: PUSH
80425: LD_INT 97
80427: ST_TO_ADDR
// ar_bio_bomb := 91 ;
80428: LD_ADDR_EXP 162
80432: PUSH
80433: LD_INT 91
80435: ST_TO_ADDR
// ar_mortar := 92 ;
80436: LD_ADDR_EXP 163
80440: PUSH
80441: LD_INT 92
80443: ST_TO_ADDR
// ru_flamethrower := 93 ;
80444: LD_ADDR_EXP 166
80448: PUSH
80449: LD_INT 93
80451: ST_TO_ADDR
// ru_radar := 98 ;
80452: LD_ADDR_EXP 158
80456: PUSH
80457: LD_INT 98
80459: ST_TO_ADDR
// tech_Artillery := 80 ;
80460: LD_ADDR_EXP 167
80464: PUSH
80465: LD_INT 80
80467: ST_TO_ADDR
// tech_RadMat := 81 ;
80468: LD_ADDR_EXP 168
80472: PUSH
80473: LD_INT 81
80475: ST_TO_ADDR
// tech_BasicTools := 82 ;
80476: LD_ADDR_EXP 169
80480: PUSH
80481: LD_INT 82
80483: ST_TO_ADDR
// tech_Cargo := 83 ;
80484: LD_ADDR_EXP 170
80488: PUSH
80489: LD_INT 83
80491: ST_TO_ADDR
// tech_Track := 84 ;
80492: LD_ADDR_EXP 171
80496: PUSH
80497: LD_INT 84
80499: ST_TO_ADDR
// tech_Crane := 85 ;
80500: LD_ADDR_EXP 172
80504: PUSH
80505: LD_INT 85
80507: ST_TO_ADDR
// tech_Bulldozer := 86 ;
80508: LD_ADDR_EXP 173
80512: PUSH
80513: LD_INT 86
80515: ST_TO_ADDR
// tech_Hovercraft := 87 ;
80516: LD_ADDR_EXP 174
80520: PUSH
80521: LD_INT 87
80523: ST_TO_ADDR
// tech_MultiBarrels := 88 ;
80524: LD_ADDR_EXP 175
80528: PUSH
80529: LD_INT 88
80531: ST_TO_ADDR
// end ;
80532: LD_VAR 0 1
80536: RET
// every 1 do
80537: GO 80539
80539: DISABLE
// InitGlobalVariables ; end_of_file
80540: CALL 80385 0 0
80544: END
// on TargetableSAIL ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) do begin case cmd of 200 .. 299 :
80545: LD_VAR 0 1
80549: PUSH
80550: LD_INT 200
80552: DOUBLE
80553: GREATEREQUAL
80554: IFFALSE 80562
80556: LD_INT 299
80558: DOUBLE
80559: LESSEQUAL
80560: IFTRUE 80564
80562: GO 80596
80564: POP
// SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; 300 .. 399 :
80565: LD_VAR 0 1
80569: PPUSH
80570: LD_VAR 0 2
80574: PPUSH
80575: LD_VAR 0 3
80579: PPUSH
80580: LD_VAR 0 4
80584: PPUSH
80585: LD_VAR 0 5
80589: PPUSH
80590: CALL 60801 0 5
80594: GO 80673
80596: LD_INT 300
80598: DOUBLE
80599: GREATEREQUAL
80600: IFFALSE 80608
80602: LD_INT 399
80604: DOUBLE
80605: LESSEQUAL
80606: IFTRUE 80610
80608: GO 80672
80610: POP
// SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; end ;
80611: LD_VAR 0 1
80615: PPUSH
80616: LD_VAR 0 2
80620: PPUSH
80621: LD_VAR 0 3
80625: PPUSH
80626: LD_VAR 0 4
80630: PPUSH
80631: LD_VAR 0 5
80635: PPUSH
80636: LD_VAR 0 6
80640: PPUSH
80641: LD_VAR 0 7
80645: PPUSH
80646: LD_VAR 0 8
80650: PPUSH
80651: LD_VAR 0 9
80655: PPUSH
80656: LD_VAR 0 10
80660: PPUSH
80661: LD_VAR 0 11
80665: PPUSH
80666: CALL 77092 0 11
80670: GO 80673
80672: POP
// end ;
80673: PPOPN 11
80675: END
// on CommandUnitXY ( cmd , un , target , x , y ) do begin SOS_CommandUnitXY ( cmd , un , target , x , y ) ;
80676: LD_VAR 0 1
80680: PPUSH
80681: LD_VAR 0 2
80685: PPUSH
80686: LD_VAR 0 3
80690: PPUSH
80691: LD_VAR 0 4
80695: PPUSH
80696: LD_VAR 0 5
80700: PPUSH
80701: CALL 60537 0 5
// end ; end_of_file
80705: PPOPN 5
80707: END
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
80708: LD_INT 0
80710: PPUSH
80711: PPUSH
80712: PPUSH
80713: PPUSH
80714: PPUSH
80715: PPUSH
80716: PPUSH
80717: PPUSH
80718: PPUSH
80719: PPUSH
80720: PPUSH
80721: PPUSH
80722: PPUSH
80723: PPUSH
80724: PPUSH
80725: PPUSH
80726: PPUSH
80727: PPUSH
80728: PPUSH
80729: PPUSH
80730: PPUSH
80731: PPUSH
80732: PPUSH
80733: PPUSH
80734: PPUSH
80735: PPUSH
80736: PPUSH
80737: PPUSH
80738: PPUSH
80739: PPUSH
80740: PPUSH
80741: PPUSH
80742: PPUSH
80743: PPUSH
// if not list then
80744: LD_VAR 0 1
80748: NOT
80749: IFFALSE 80753
// exit ;
80751: GO 85412
// base := list [ 1 ] ;
80753: LD_ADDR_VAR 0 3
80757: PUSH
80758: LD_VAR 0 1
80762: PUSH
80763: LD_INT 1
80765: ARRAY
80766: ST_TO_ADDR
// group := list [ 2 ] ;
80767: LD_ADDR_VAR 0 4
80771: PUSH
80772: LD_VAR 0 1
80776: PUSH
80777: LD_INT 2
80779: ARRAY
80780: ST_TO_ADDR
// path := list [ 3 ] ;
80781: LD_ADDR_VAR 0 5
80785: PUSH
80786: LD_VAR 0 1
80790: PUSH
80791: LD_INT 3
80793: ARRAY
80794: ST_TO_ADDR
// flags := list [ 4 ] ;
80795: LD_ADDR_VAR 0 6
80799: PUSH
80800: LD_VAR 0 1
80804: PUSH
80805: LD_INT 4
80807: ARRAY
80808: ST_TO_ADDR
// mined := [ ] ;
80809: LD_ADDR_VAR 0 27
80813: PUSH
80814: EMPTY
80815: ST_TO_ADDR
// bombed := [ ] ;
80816: LD_ADDR_VAR 0 28
80820: PUSH
80821: EMPTY
80822: ST_TO_ADDR
// healers := [ ] ;
80823: LD_ADDR_VAR 0 31
80827: PUSH
80828: EMPTY
80829: ST_TO_ADDR
// to_heal := [ ] ;
80830: LD_ADDR_VAR 0 30
80834: PUSH
80835: EMPTY
80836: ST_TO_ADDR
// repairs := [ ] ;
80837: LD_ADDR_VAR 0 33
80841: PUSH
80842: EMPTY
80843: ST_TO_ADDR
// to_repair := [ ] ;
80844: LD_ADDR_VAR 0 32
80848: PUSH
80849: EMPTY
80850: ST_TO_ADDR
// if not group or not path then
80851: LD_VAR 0 4
80855: NOT
80856: PUSH
80857: LD_VAR 0 5
80861: NOT
80862: OR
80863: IFFALSE 80867
// exit ;
80865: GO 85412
// side := GetSide ( group [ 1 ] ) ;
80867: LD_ADDR_VAR 0 35
80871: PUSH
80872: LD_VAR 0 4
80876: PUSH
80877: LD_INT 1
80879: ARRAY
80880: PPUSH
80881: CALL_OW 255
80885: ST_TO_ADDR
// if flags then
80886: LD_VAR 0 6
80890: IFFALSE 81034
// begin f_ignore_area := flags [ 1 ] ;
80892: LD_ADDR_VAR 0 17
80896: PUSH
80897: LD_VAR 0 6
80901: PUSH
80902: LD_INT 1
80904: ARRAY
80905: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
80906: LD_ADDR_VAR 0 18
80910: PUSH
80911: LD_VAR 0 6
80915: PUSH
80916: LD_INT 2
80918: ARRAY
80919: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
80920: LD_ADDR_VAR 0 19
80924: PUSH
80925: LD_VAR 0 6
80929: PUSH
80930: LD_INT 3
80932: ARRAY
80933: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
80934: LD_ADDR_VAR 0 20
80938: PUSH
80939: LD_VAR 0 6
80943: PUSH
80944: LD_INT 4
80946: ARRAY
80947: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
80948: LD_ADDR_VAR 0 21
80952: PUSH
80953: LD_VAR 0 6
80957: PUSH
80958: LD_INT 5
80960: ARRAY
80961: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
80962: LD_ADDR_VAR 0 22
80966: PUSH
80967: LD_VAR 0 6
80971: PUSH
80972: LD_INT 6
80974: ARRAY
80975: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
80976: LD_ADDR_VAR 0 23
80980: PUSH
80981: LD_VAR 0 6
80985: PUSH
80986: LD_INT 7
80988: ARRAY
80989: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
80990: LD_ADDR_VAR 0 24
80994: PUSH
80995: LD_VAR 0 6
80999: PUSH
81000: LD_INT 8
81002: ARRAY
81003: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
81004: LD_ADDR_VAR 0 25
81008: PUSH
81009: LD_VAR 0 6
81013: PUSH
81014: LD_INT 9
81016: ARRAY
81017: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
81018: LD_ADDR_VAR 0 26
81022: PUSH
81023: LD_VAR 0 6
81027: PUSH
81028: LD_INT 10
81030: ARRAY
81031: ST_TO_ADDR
// end else
81032: GO 81114
// begin f_ignore_area := false ;
81034: LD_ADDR_VAR 0 17
81038: PUSH
81039: LD_INT 0
81041: ST_TO_ADDR
// f_capture := false ;
81042: LD_ADDR_VAR 0 18
81046: PUSH
81047: LD_INT 0
81049: ST_TO_ADDR
// f_ignore_civ := false ;
81050: LD_ADDR_VAR 0 19
81054: PUSH
81055: LD_INT 0
81057: ST_TO_ADDR
// f_murder := false ;
81058: LD_ADDR_VAR 0 20
81062: PUSH
81063: LD_INT 0
81065: ST_TO_ADDR
// f_mines := false ;
81066: LD_ADDR_VAR 0 21
81070: PUSH
81071: LD_INT 0
81073: ST_TO_ADDR
// f_repair := false ;
81074: LD_ADDR_VAR 0 22
81078: PUSH
81079: LD_INT 0
81081: ST_TO_ADDR
// f_heal := false ;
81082: LD_ADDR_VAR 0 23
81086: PUSH
81087: LD_INT 0
81089: ST_TO_ADDR
// f_spacetime := false ;
81090: LD_ADDR_VAR 0 24
81094: PUSH
81095: LD_INT 0
81097: ST_TO_ADDR
// f_attack_depot := false ;
81098: LD_ADDR_VAR 0 25
81102: PUSH
81103: LD_INT 0
81105: ST_TO_ADDR
// f_crawl := false ;
81106: LD_ADDR_VAR 0 26
81110: PUSH
81111: LD_INT 0
81113: ST_TO_ADDR
// end ; if f_heal then
81114: LD_VAR 0 23
81118: IFFALSE 81145
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
81120: LD_ADDR_VAR 0 31
81124: PUSH
81125: LD_VAR 0 4
81129: PPUSH
81130: LD_INT 25
81132: PUSH
81133: LD_INT 4
81135: PUSH
81136: EMPTY
81137: LIST
81138: LIST
81139: PPUSH
81140: CALL_OW 72
81144: ST_TO_ADDR
// if f_repair then
81145: LD_VAR 0 22
81149: IFFALSE 81176
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
81151: LD_ADDR_VAR 0 33
81155: PUSH
81156: LD_VAR 0 4
81160: PPUSH
81161: LD_INT 25
81163: PUSH
81164: LD_INT 3
81166: PUSH
81167: EMPTY
81168: LIST
81169: LIST
81170: PPUSH
81171: CALL_OW 72
81175: ST_TO_ADDR
// units_path := [ ] ;
81176: LD_ADDR_VAR 0 16
81180: PUSH
81181: EMPTY
81182: ST_TO_ADDR
// for i = 1 to group do
81183: LD_ADDR_VAR 0 7
81187: PUSH
81188: DOUBLE
81189: LD_INT 1
81191: DEC
81192: ST_TO_ADDR
81193: LD_VAR 0 4
81197: PUSH
81198: FOR_TO
81199: IFFALSE 81228
// units_path := Replace ( units_path , i , path ) ;
81201: LD_ADDR_VAR 0 16
81205: PUSH
81206: LD_VAR 0 16
81210: PPUSH
81211: LD_VAR 0 7
81215: PPUSH
81216: LD_VAR 0 5
81220: PPUSH
81221: CALL_OW 1
81225: ST_TO_ADDR
81226: GO 81198
81228: POP
81229: POP
// repeat for i = group downto 1 do
81230: LD_ADDR_VAR 0 7
81234: PUSH
81235: DOUBLE
81236: LD_VAR 0 4
81240: INC
81241: ST_TO_ADDR
81242: LD_INT 1
81244: PUSH
81245: FOR_DOWNTO
81246: IFFALSE 85368
// begin wait ( 5 ) ;
81248: LD_INT 5
81250: PPUSH
81251: CALL_OW 67
// tmp := [ ] ;
81255: LD_ADDR_VAR 0 14
81259: PUSH
81260: EMPTY
81261: ST_TO_ADDR
// attacking := false ;
81262: LD_ADDR_VAR 0 29
81266: PUSH
81267: LD_INT 0
81269: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
81270: LD_VAR 0 4
81274: PUSH
81275: LD_VAR 0 7
81279: ARRAY
81280: PPUSH
81281: CALL_OW 301
81285: PUSH
81286: LD_VAR 0 4
81290: PUSH
81291: LD_VAR 0 7
81295: ARRAY
81296: NOT
81297: OR
81298: IFFALSE 81407
// begin if GetType ( group [ i ] ) = unit_human then
81300: LD_VAR 0 4
81304: PUSH
81305: LD_VAR 0 7
81309: ARRAY
81310: PPUSH
81311: CALL_OW 247
81315: PUSH
81316: LD_INT 1
81318: EQUAL
81319: IFFALSE 81365
// begin to_heal := to_heal diff group [ i ] ;
81321: LD_ADDR_VAR 0 30
81325: PUSH
81326: LD_VAR 0 30
81330: PUSH
81331: LD_VAR 0 4
81335: PUSH
81336: LD_VAR 0 7
81340: ARRAY
81341: DIFF
81342: ST_TO_ADDR
// healers := healers diff group [ i ] ;
81343: LD_ADDR_VAR 0 31
81347: PUSH
81348: LD_VAR 0 31
81352: PUSH
81353: LD_VAR 0 4
81357: PUSH
81358: LD_VAR 0 7
81362: ARRAY
81363: DIFF
81364: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
81365: LD_ADDR_VAR 0 4
81369: PUSH
81370: LD_VAR 0 4
81374: PPUSH
81375: LD_VAR 0 7
81379: PPUSH
81380: CALL_OW 3
81384: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
81385: LD_ADDR_VAR 0 16
81389: PUSH
81390: LD_VAR 0 16
81394: PPUSH
81395: LD_VAR 0 7
81399: PPUSH
81400: CALL_OW 3
81404: ST_TO_ADDR
// continue ;
81405: GO 81245
// end ; if f_repair then
81407: LD_VAR 0 22
81411: IFFALSE 81900
// begin if GetType ( group [ i ] ) = unit_vehicle then
81413: LD_VAR 0 4
81417: PUSH
81418: LD_VAR 0 7
81422: ARRAY
81423: PPUSH
81424: CALL_OW 247
81428: PUSH
81429: LD_INT 2
81431: EQUAL
81432: IFFALSE 81622
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
81434: LD_VAR 0 4
81438: PUSH
81439: LD_VAR 0 7
81443: ARRAY
81444: PPUSH
81445: CALL_OW 256
81449: PUSH
81450: LD_INT 700
81452: LESS
81453: PUSH
81454: LD_VAR 0 4
81458: PUSH
81459: LD_VAR 0 7
81463: ARRAY
81464: PUSH
81465: LD_VAR 0 32
81469: IN
81470: NOT
81471: AND
81472: IFFALSE 81496
// to_repair := to_repair union group [ i ] ;
81474: LD_ADDR_VAR 0 32
81478: PUSH
81479: LD_VAR 0 32
81483: PUSH
81484: LD_VAR 0 4
81488: PUSH
81489: LD_VAR 0 7
81493: ARRAY
81494: UNION
81495: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
81496: LD_VAR 0 4
81500: PUSH
81501: LD_VAR 0 7
81505: ARRAY
81506: PPUSH
81507: CALL_OW 256
81511: PUSH
81512: LD_INT 1000
81514: EQUAL
81515: PUSH
81516: LD_VAR 0 4
81520: PUSH
81521: LD_VAR 0 7
81525: ARRAY
81526: PUSH
81527: LD_VAR 0 32
81531: IN
81532: AND
81533: IFFALSE 81557
// to_repair := to_repair diff group [ i ] ;
81535: LD_ADDR_VAR 0 32
81539: PUSH
81540: LD_VAR 0 32
81544: PUSH
81545: LD_VAR 0 4
81549: PUSH
81550: LD_VAR 0 7
81554: ARRAY
81555: DIFF
81556: ST_TO_ADDR
// if group [ i ] in to_repair then
81557: LD_VAR 0 4
81561: PUSH
81562: LD_VAR 0 7
81566: ARRAY
81567: PUSH
81568: LD_VAR 0 32
81572: IN
81573: IFFALSE 81620
// begin if not IsInArea ( group [ i ] , f_repair ) then
81575: LD_VAR 0 4
81579: PUSH
81580: LD_VAR 0 7
81584: ARRAY
81585: PPUSH
81586: LD_VAR 0 22
81590: PPUSH
81591: CALL_OW 308
81595: NOT
81596: IFFALSE 81618
// ComMoveToArea ( group [ i ] , f_repair ) ;
81598: LD_VAR 0 4
81602: PUSH
81603: LD_VAR 0 7
81607: ARRAY
81608: PPUSH
81609: LD_VAR 0 22
81613: PPUSH
81614: CALL_OW 113
// continue ;
81618: GO 81245
// end ; end else
81620: GO 81900
// if group [ i ] in repairs then
81622: LD_VAR 0 4
81626: PUSH
81627: LD_VAR 0 7
81631: ARRAY
81632: PUSH
81633: LD_VAR 0 33
81637: IN
81638: IFFALSE 81900
// begin if IsInUnit ( group [ i ] ) then
81640: LD_VAR 0 4
81644: PUSH
81645: LD_VAR 0 7
81649: ARRAY
81650: PPUSH
81651: CALL_OW 310
81655: IFFALSE 81723
// begin z := IsInUnit ( group [ i ] ) ;
81657: LD_ADDR_VAR 0 13
81661: PUSH
81662: LD_VAR 0 4
81666: PUSH
81667: LD_VAR 0 7
81671: ARRAY
81672: PPUSH
81673: CALL_OW 310
81677: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
81678: LD_VAR 0 13
81682: PUSH
81683: LD_VAR 0 32
81687: IN
81688: PUSH
81689: LD_VAR 0 13
81693: PPUSH
81694: LD_VAR 0 22
81698: PPUSH
81699: CALL_OW 308
81703: AND
81704: IFFALSE 81721
// ComExitVehicle ( group [ i ] ) ;
81706: LD_VAR 0 4
81710: PUSH
81711: LD_VAR 0 7
81715: ARRAY
81716: PPUSH
81717: CALL_OW 121
// end else
81721: GO 81900
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
81723: LD_ADDR_VAR 0 13
81727: PUSH
81728: LD_VAR 0 4
81732: PPUSH
81733: LD_INT 95
81735: PUSH
81736: LD_VAR 0 22
81740: PUSH
81741: EMPTY
81742: LIST
81743: LIST
81744: PUSH
81745: LD_INT 58
81747: PUSH
81748: EMPTY
81749: LIST
81750: PUSH
81751: EMPTY
81752: LIST
81753: LIST
81754: PPUSH
81755: CALL_OW 72
81759: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
81760: LD_VAR 0 4
81764: PUSH
81765: LD_VAR 0 7
81769: ARRAY
81770: PPUSH
81771: CALL_OW 314
81775: NOT
81776: IFFALSE 81898
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
81778: LD_ADDR_VAR 0 10
81782: PUSH
81783: LD_VAR 0 13
81787: PPUSH
81788: LD_VAR 0 4
81792: PUSH
81793: LD_VAR 0 7
81797: ARRAY
81798: PPUSH
81799: CALL_OW 74
81803: ST_TO_ADDR
// if not x then
81804: LD_VAR 0 10
81808: NOT
81809: IFFALSE 81813
// continue ;
81811: GO 81245
// if GetLives ( x ) < 1000 then
81813: LD_VAR 0 10
81817: PPUSH
81818: CALL_OW 256
81822: PUSH
81823: LD_INT 1000
81825: LESS
81826: IFFALSE 81850
// ComRepairVehicle ( group [ i ] , x ) else
81828: LD_VAR 0 4
81832: PUSH
81833: LD_VAR 0 7
81837: ARRAY
81838: PPUSH
81839: LD_VAR 0 10
81843: PPUSH
81844: CALL_OW 129
81848: GO 81898
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
81850: LD_VAR 0 23
81854: PUSH
81855: LD_VAR 0 4
81859: PUSH
81860: LD_VAR 0 7
81864: ARRAY
81865: PPUSH
81866: CALL_OW 256
81870: PUSH
81871: LD_INT 1000
81873: LESS
81874: AND
81875: NOT
81876: IFFALSE 81898
// ComEnterUnit ( group [ i ] , x ) ;
81878: LD_VAR 0 4
81882: PUSH
81883: LD_VAR 0 7
81887: ARRAY
81888: PPUSH
81889: LD_VAR 0 10
81893: PPUSH
81894: CALL_OW 120
// end ; continue ;
81898: GO 81245
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
81900: LD_VAR 0 23
81904: PUSH
81905: LD_VAR 0 4
81909: PUSH
81910: LD_VAR 0 7
81914: ARRAY
81915: PPUSH
81916: CALL_OW 247
81920: PUSH
81921: LD_INT 1
81923: EQUAL
81924: AND
81925: IFFALSE 82403
// begin if group [ i ] in healers then
81927: LD_VAR 0 4
81931: PUSH
81932: LD_VAR 0 7
81936: ARRAY
81937: PUSH
81938: LD_VAR 0 31
81942: IN
81943: IFFALSE 82216
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
81945: LD_VAR 0 4
81949: PUSH
81950: LD_VAR 0 7
81954: ARRAY
81955: PPUSH
81956: LD_VAR 0 23
81960: PPUSH
81961: CALL_OW 308
81965: NOT
81966: PUSH
81967: LD_VAR 0 4
81971: PUSH
81972: LD_VAR 0 7
81976: ARRAY
81977: PPUSH
81978: CALL_OW 314
81982: NOT
81983: AND
81984: IFFALSE 82008
// ComMoveToArea ( group [ i ] , f_heal ) else
81986: LD_VAR 0 4
81990: PUSH
81991: LD_VAR 0 7
81995: ARRAY
81996: PPUSH
81997: LD_VAR 0 23
82001: PPUSH
82002: CALL_OW 113
82006: GO 82214
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
82008: LD_VAR 0 4
82012: PUSH
82013: LD_VAR 0 7
82017: ARRAY
82018: PPUSH
82019: CALL 53993 0 1
82023: PPUSH
82024: CALL_OW 256
82028: PUSH
82029: LD_INT 1000
82031: EQUAL
82032: IFFALSE 82051
// ComStop ( group [ i ] ) else
82034: LD_VAR 0 4
82038: PUSH
82039: LD_VAR 0 7
82043: ARRAY
82044: PPUSH
82045: CALL_OW 141
82049: GO 82214
// if not HasTask ( group [ i ] ) and to_heal then
82051: LD_VAR 0 4
82055: PUSH
82056: LD_VAR 0 7
82060: ARRAY
82061: PPUSH
82062: CALL_OW 314
82066: NOT
82067: PUSH
82068: LD_VAR 0 30
82072: AND
82073: IFFALSE 82214
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
82075: LD_ADDR_VAR 0 13
82079: PUSH
82080: LD_VAR 0 30
82084: PPUSH
82085: LD_INT 3
82087: PUSH
82088: LD_INT 54
82090: PUSH
82091: EMPTY
82092: LIST
82093: PUSH
82094: EMPTY
82095: LIST
82096: LIST
82097: PPUSH
82098: CALL_OW 72
82102: PPUSH
82103: LD_VAR 0 4
82107: PUSH
82108: LD_VAR 0 7
82112: ARRAY
82113: PPUSH
82114: CALL_OW 74
82118: ST_TO_ADDR
// if z then
82119: LD_VAR 0 13
82123: IFFALSE 82214
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
82125: LD_INT 91
82127: PUSH
82128: LD_VAR 0 13
82132: PUSH
82133: LD_INT 10
82135: PUSH
82136: EMPTY
82137: LIST
82138: LIST
82139: LIST
82140: PUSH
82141: LD_INT 81
82143: PUSH
82144: LD_VAR 0 13
82148: PPUSH
82149: CALL_OW 255
82153: PUSH
82154: EMPTY
82155: LIST
82156: LIST
82157: PUSH
82158: EMPTY
82159: LIST
82160: LIST
82161: PPUSH
82162: CALL_OW 69
82166: PUSH
82167: LD_INT 0
82169: EQUAL
82170: IFFALSE 82194
// ComHeal ( group [ i ] , z ) else
82172: LD_VAR 0 4
82176: PUSH
82177: LD_VAR 0 7
82181: ARRAY
82182: PPUSH
82183: LD_VAR 0 13
82187: PPUSH
82188: CALL_OW 128
82192: GO 82214
// ComMoveToArea ( group [ i ] , f_heal ) ;
82194: LD_VAR 0 4
82198: PUSH
82199: LD_VAR 0 7
82203: ARRAY
82204: PPUSH
82205: LD_VAR 0 23
82209: PPUSH
82210: CALL_OW 113
// end ; continue ;
82214: GO 81245
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
82216: LD_VAR 0 4
82220: PUSH
82221: LD_VAR 0 7
82225: ARRAY
82226: PPUSH
82227: CALL_OW 256
82231: PUSH
82232: LD_INT 700
82234: LESS
82235: PUSH
82236: LD_VAR 0 4
82240: PUSH
82241: LD_VAR 0 7
82245: ARRAY
82246: PUSH
82247: LD_VAR 0 30
82251: IN
82252: NOT
82253: AND
82254: IFFALSE 82278
// to_heal := to_heal union group [ i ] ;
82256: LD_ADDR_VAR 0 30
82260: PUSH
82261: LD_VAR 0 30
82265: PUSH
82266: LD_VAR 0 4
82270: PUSH
82271: LD_VAR 0 7
82275: ARRAY
82276: UNION
82277: ST_TO_ADDR
// if group [ i ] in to_heal then
82278: LD_VAR 0 4
82282: PUSH
82283: LD_VAR 0 7
82287: ARRAY
82288: PUSH
82289: LD_VAR 0 30
82293: IN
82294: IFFALSE 82403
// begin if GetLives ( group [ i ] ) = 1000 then
82296: LD_VAR 0 4
82300: PUSH
82301: LD_VAR 0 7
82305: ARRAY
82306: PPUSH
82307: CALL_OW 256
82311: PUSH
82312: LD_INT 1000
82314: EQUAL
82315: IFFALSE 82341
// to_heal := to_heal diff group [ i ] else
82317: LD_ADDR_VAR 0 30
82321: PUSH
82322: LD_VAR 0 30
82326: PUSH
82327: LD_VAR 0 4
82331: PUSH
82332: LD_VAR 0 7
82336: ARRAY
82337: DIFF
82338: ST_TO_ADDR
82339: GO 82403
// begin if not IsInArea ( group [ i ] , to_heal ) then
82341: LD_VAR 0 4
82345: PUSH
82346: LD_VAR 0 7
82350: ARRAY
82351: PPUSH
82352: LD_VAR 0 30
82356: PPUSH
82357: CALL_OW 308
82361: NOT
82362: IFFALSE 82386
// ComMoveToArea ( group [ i ] , f_heal ) else
82364: LD_VAR 0 4
82368: PUSH
82369: LD_VAR 0 7
82373: ARRAY
82374: PPUSH
82375: LD_VAR 0 23
82379: PPUSH
82380: CALL_OW 113
82384: GO 82401
// ComHold ( group [ i ] ) ;
82386: LD_VAR 0 4
82390: PUSH
82391: LD_VAR 0 7
82395: ARRAY
82396: PPUSH
82397: CALL_OW 140
// continue ;
82401: GO 81245
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
82403: LD_VAR 0 4
82407: PUSH
82408: LD_VAR 0 7
82412: ARRAY
82413: PPUSH
82414: LD_INT 10
82416: PPUSH
82417: CALL 51863 0 2
82421: NOT
82422: PUSH
82423: LD_VAR 0 16
82427: PUSH
82428: LD_VAR 0 7
82432: ARRAY
82433: PUSH
82434: EMPTY
82435: EQUAL
82436: NOT
82437: AND
82438: IFFALSE 82704
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
82440: LD_VAR 0 4
82444: PUSH
82445: LD_VAR 0 7
82449: ARRAY
82450: PPUSH
82451: CALL_OW 262
82455: PUSH
82456: LD_INT 1
82458: PUSH
82459: LD_INT 2
82461: PUSH
82462: EMPTY
82463: LIST
82464: LIST
82465: IN
82466: IFFALSE 82507
// if GetFuel ( group [ i ] ) < 10 then
82468: LD_VAR 0 4
82472: PUSH
82473: LD_VAR 0 7
82477: ARRAY
82478: PPUSH
82479: CALL_OW 261
82483: PUSH
82484: LD_INT 10
82486: LESS
82487: IFFALSE 82507
// SetFuel ( group [ i ] , 12 ) ;
82489: LD_VAR 0 4
82493: PUSH
82494: LD_VAR 0 7
82498: ARRAY
82499: PPUSH
82500: LD_INT 12
82502: PPUSH
82503: CALL_OW 240
// if units_path [ i ] then
82507: LD_VAR 0 16
82511: PUSH
82512: LD_VAR 0 7
82516: ARRAY
82517: IFFALSE 82702
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
82519: LD_VAR 0 4
82523: PUSH
82524: LD_VAR 0 7
82528: ARRAY
82529: PPUSH
82530: LD_VAR 0 16
82534: PUSH
82535: LD_VAR 0 7
82539: ARRAY
82540: PUSH
82541: LD_INT 1
82543: ARRAY
82544: PUSH
82545: LD_INT 1
82547: ARRAY
82548: PPUSH
82549: LD_VAR 0 16
82553: PUSH
82554: LD_VAR 0 7
82558: ARRAY
82559: PUSH
82560: LD_INT 1
82562: ARRAY
82563: PUSH
82564: LD_INT 2
82566: ARRAY
82567: PPUSH
82568: CALL_OW 297
82572: PUSH
82573: LD_INT 6
82575: GREATER
82576: IFFALSE 82651
// begin if not HasTask ( group [ i ] ) then
82578: LD_VAR 0 4
82582: PUSH
82583: LD_VAR 0 7
82587: ARRAY
82588: PPUSH
82589: CALL_OW 314
82593: NOT
82594: IFFALSE 82649
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
82596: LD_VAR 0 4
82600: PUSH
82601: LD_VAR 0 7
82605: ARRAY
82606: PPUSH
82607: LD_VAR 0 16
82611: PUSH
82612: LD_VAR 0 7
82616: ARRAY
82617: PUSH
82618: LD_INT 1
82620: ARRAY
82621: PUSH
82622: LD_INT 1
82624: ARRAY
82625: PPUSH
82626: LD_VAR 0 16
82630: PUSH
82631: LD_VAR 0 7
82635: ARRAY
82636: PUSH
82637: LD_INT 1
82639: ARRAY
82640: PUSH
82641: LD_INT 2
82643: ARRAY
82644: PPUSH
82645: CALL_OW 114
// end else
82649: GO 82702
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
82651: LD_ADDR_VAR 0 15
82655: PUSH
82656: LD_VAR 0 16
82660: PUSH
82661: LD_VAR 0 7
82665: ARRAY
82666: PPUSH
82667: LD_INT 1
82669: PPUSH
82670: CALL_OW 3
82674: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
82675: LD_ADDR_VAR 0 16
82679: PUSH
82680: LD_VAR 0 16
82684: PPUSH
82685: LD_VAR 0 7
82689: PPUSH
82690: LD_VAR 0 15
82694: PPUSH
82695: CALL_OW 1
82699: ST_TO_ADDR
// continue ;
82700: GO 81245
// end ; end ; end else
82702: GO 85366
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
82704: LD_ADDR_VAR 0 14
82708: PUSH
82709: LD_INT 81
82711: PUSH
82712: LD_VAR 0 4
82716: PUSH
82717: LD_VAR 0 7
82721: ARRAY
82722: PPUSH
82723: CALL_OW 255
82727: PUSH
82728: EMPTY
82729: LIST
82730: LIST
82731: PPUSH
82732: CALL_OW 69
82736: ST_TO_ADDR
// if not tmp then
82737: LD_VAR 0 14
82741: NOT
82742: IFFALSE 82746
// continue ;
82744: GO 81245
// if f_ignore_area then
82746: LD_VAR 0 17
82750: IFFALSE 82838
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
82752: LD_ADDR_VAR 0 15
82756: PUSH
82757: LD_VAR 0 14
82761: PPUSH
82762: LD_INT 3
82764: PUSH
82765: LD_INT 92
82767: PUSH
82768: LD_VAR 0 17
82772: PUSH
82773: LD_INT 1
82775: ARRAY
82776: PUSH
82777: LD_VAR 0 17
82781: PUSH
82782: LD_INT 2
82784: ARRAY
82785: PUSH
82786: LD_VAR 0 17
82790: PUSH
82791: LD_INT 3
82793: ARRAY
82794: PUSH
82795: EMPTY
82796: LIST
82797: LIST
82798: LIST
82799: LIST
82800: PUSH
82801: EMPTY
82802: LIST
82803: LIST
82804: PPUSH
82805: CALL_OW 72
82809: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
82810: LD_VAR 0 14
82814: PUSH
82815: LD_VAR 0 15
82819: DIFF
82820: IFFALSE 82838
// tmp := tmp diff tmp2 ;
82822: LD_ADDR_VAR 0 14
82826: PUSH
82827: LD_VAR 0 14
82831: PUSH
82832: LD_VAR 0 15
82836: DIFF
82837: ST_TO_ADDR
// end ; if not f_murder then
82838: LD_VAR 0 20
82842: NOT
82843: IFFALSE 82901
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
82845: LD_ADDR_VAR 0 15
82849: PUSH
82850: LD_VAR 0 14
82854: PPUSH
82855: LD_INT 3
82857: PUSH
82858: LD_INT 50
82860: PUSH
82861: EMPTY
82862: LIST
82863: PUSH
82864: EMPTY
82865: LIST
82866: LIST
82867: PPUSH
82868: CALL_OW 72
82872: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
82873: LD_VAR 0 14
82877: PUSH
82878: LD_VAR 0 15
82882: DIFF
82883: IFFALSE 82901
// tmp := tmp diff tmp2 ;
82885: LD_ADDR_VAR 0 14
82889: PUSH
82890: LD_VAR 0 14
82894: PUSH
82895: LD_VAR 0 15
82899: DIFF
82900: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
82901: LD_ADDR_VAR 0 14
82905: PUSH
82906: LD_VAR 0 4
82910: PUSH
82911: LD_VAR 0 7
82915: ARRAY
82916: PPUSH
82917: LD_VAR 0 14
82921: PPUSH
82922: LD_INT 1
82924: PPUSH
82925: LD_INT 1
82927: PPUSH
82928: CALL 24798 0 4
82932: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
82933: LD_VAR 0 4
82937: PUSH
82938: LD_VAR 0 7
82942: ARRAY
82943: PPUSH
82944: CALL_OW 257
82948: PUSH
82949: LD_INT 1
82951: EQUAL
82952: IFFALSE 83400
// begin if WantPlant ( group [ i ] ) then
82954: LD_VAR 0 4
82958: PUSH
82959: LD_VAR 0 7
82963: ARRAY
82964: PPUSH
82965: CALL 24299 0 1
82969: IFFALSE 82973
// continue ;
82971: GO 81245
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
82973: LD_VAR 0 18
82977: PUSH
82978: LD_VAR 0 4
82982: PUSH
82983: LD_VAR 0 7
82987: ARRAY
82988: PPUSH
82989: CALL_OW 310
82993: NOT
82994: AND
82995: PUSH
82996: LD_VAR 0 14
83000: PUSH
83001: LD_INT 1
83003: ARRAY
83004: PUSH
83005: LD_VAR 0 14
83009: PPUSH
83010: LD_INT 21
83012: PUSH
83013: LD_INT 2
83015: PUSH
83016: EMPTY
83017: LIST
83018: LIST
83019: PUSH
83020: LD_INT 58
83022: PUSH
83023: EMPTY
83024: LIST
83025: PUSH
83026: EMPTY
83027: LIST
83028: LIST
83029: PPUSH
83030: CALL_OW 72
83034: IN
83035: AND
83036: IFFALSE 83072
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
83038: LD_VAR 0 4
83042: PUSH
83043: LD_VAR 0 7
83047: ARRAY
83048: PPUSH
83049: LD_VAR 0 14
83053: PUSH
83054: LD_INT 1
83056: ARRAY
83057: PPUSH
83058: CALL_OW 120
// attacking := true ;
83062: LD_ADDR_VAR 0 29
83066: PUSH
83067: LD_INT 1
83069: ST_TO_ADDR
// continue ;
83070: GO 81245
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
83072: LD_VAR 0 26
83076: PUSH
83077: LD_VAR 0 4
83081: PUSH
83082: LD_VAR 0 7
83086: ARRAY
83087: PPUSH
83088: CALL_OW 257
83092: PUSH
83093: LD_INT 1
83095: EQUAL
83096: AND
83097: PUSH
83098: LD_VAR 0 4
83102: PUSH
83103: LD_VAR 0 7
83107: ARRAY
83108: PPUSH
83109: CALL_OW 256
83113: PUSH
83114: LD_INT 800
83116: LESS
83117: AND
83118: PUSH
83119: LD_VAR 0 4
83123: PUSH
83124: LD_VAR 0 7
83128: ARRAY
83129: PPUSH
83130: CALL_OW 318
83134: NOT
83135: AND
83136: IFFALSE 83153
// ComCrawl ( group [ i ] ) ;
83138: LD_VAR 0 4
83142: PUSH
83143: LD_VAR 0 7
83147: ARRAY
83148: PPUSH
83149: CALL_OW 137
// if f_mines then
83153: LD_VAR 0 21
83157: IFFALSE 83400
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
83159: LD_VAR 0 14
83163: PUSH
83164: LD_INT 1
83166: ARRAY
83167: PPUSH
83168: CALL_OW 247
83172: PUSH
83173: LD_INT 3
83175: EQUAL
83176: PUSH
83177: LD_VAR 0 14
83181: PUSH
83182: LD_INT 1
83184: ARRAY
83185: PUSH
83186: LD_VAR 0 27
83190: IN
83191: NOT
83192: AND
83193: IFFALSE 83400
// begin x := GetX ( tmp [ 1 ] ) ;
83195: LD_ADDR_VAR 0 10
83199: PUSH
83200: LD_VAR 0 14
83204: PUSH
83205: LD_INT 1
83207: ARRAY
83208: PPUSH
83209: CALL_OW 250
83213: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
83214: LD_ADDR_VAR 0 11
83218: PUSH
83219: LD_VAR 0 14
83223: PUSH
83224: LD_INT 1
83226: ARRAY
83227: PPUSH
83228: CALL_OW 251
83232: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
83233: LD_ADDR_VAR 0 12
83237: PUSH
83238: LD_VAR 0 4
83242: PUSH
83243: LD_VAR 0 7
83247: ARRAY
83248: PPUSH
83249: CALL 51948 0 1
83253: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
83254: LD_VAR 0 4
83258: PUSH
83259: LD_VAR 0 7
83263: ARRAY
83264: PPUSH
83265: LD_VAR 0 10
83269: PPUSH
83270: LD_VAR 0 11
83274: PPUSH
83275: LD_VAR 0 14
83279: PUSH
83280: LD_INT 1
83282: ARRAY
83283: PPUSH
83284: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
83288: LD_VAR 0 4
83292: PUSH
83293: LD_VAR 0 7
83297: ARRAY
83298: PPUSH
83299: LD_VAR 0 10
83303: PPUSH
83304: LD_VAR 0 12
83308: PPUSH
83309: LD_INT 7
83311: PPUSH
83312: CALL_OW 272
83316: PPUSH
83317: LD_VAR 0 11
83321: PPUSH
83322: LD_VAR 0 12
83326: PPUSH
83327: LD_INT 7
83329: PPUSH
83330: CALL_OW 273
83334: PPUSH
83335: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
83339: LD_VAR 0 4
83343: PUSH
83344: LD_VAR 0 7
83348: ARRAY
83349: PPUSH
83350: LD_INT 71
83352: PPUSH
83353: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
83357: LD_ADDR_VAR 0 27
83361: PUSH
83362: LD_VAR 0 27
83366: PPUSH
83367: LD_VAR 0 27
83371: PUSH
83372: LD_INT 1
83374: PLUS
83375: PPUSH
83376: LD_VAR 0 14
83380: PUSH
83381: LD_INT 1
83383: ARRAY
83384: PPUSH
83385: CALL_OW 1
83389: ST_TO_ADDR
// attacking := true ;
83390: LD_ADDR_VAR 0 29
83394: PUSH
83395: LD_INT 1
83397: ST_TO_ADDR
// continue ;
83398: GO 81245
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
83400: LD_VAR 0 4
83404: PUSH
83405: LD_VAR 0 7
83409: ARRAY
83410: PPUSH
83411: CALL_OW 257
83415: PUSH
83416: LD_INT 17
83418: EQUAL
83419: PUSH
83420: LD_VAR 0 4
83424: PUSH
83425: LD_VAR 0 7
83429: ARRAY
83430: PPUSH
83431: CALL_OW 110
83435: PUSH
83436: LD_INT 71
83438: EQUAL
83439: NOT
83440: AND
83441: IFFALSE 83587
// begin attacking := false ;
83443: LD_ADDR_VAR 0 29
83447: PUSH
83448: LD_INT 0
83450: ST_TO_ADDR
// k := 5 ;
83451: LD_ADDR_VAR 0 9
83455: PUSH
83456: LD_INT 5
83458: ST_TO_ADDR
// if tmp < k then
83459: LD_VAR 0 14
83463: PUSH
83464: LD_VAR 0 9
83468: LESS
83469: IFFALSE 83481
// k := tmp ;
83471: LD_ADDR_VAR 0 9
83475: PUSH
83476: LD_VAR 0 14
83480: ST_TO_ADDR
// for j = 1 to k do
83481: LD_ADDR_VAR 0 8
83485: PUSH
83486: DOUBLE
83487: LD_INT 1
83489: DEC
83490: ST_TO_ADDR
83491: LD_VAR 0 9
83495: PUSH
83496: FOR_TO
83497: IFFALSE 83585
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
83499: LD_VAR 0 14
83503: PUSH
83504: LD_VAR 0 8
83508: ARRAY
83509: PUSH
83510: LD_VAR 0 14
83514: PPUSH
83515: LD_INT 58
83517: PUSH
83518: EMPTY
83519: LIST
83520: PPUSH
83521: CALL_OW 72
83525: IN
83526: NOT
83527: IFFALSE 83583
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
83529: LD_VAR 0 4
83533: PUSH
83534: LD_VAR 0 7
83538: ARRAY
83539: PPUSH
83540: LD_VAR 0 14
83544: PUSH
83545: LD_VAR 0 8
83549: ARRAY
83550: PPUSH
83551: CALL_OW 115
// attacking := true ;
83555: LD_ADDR_VAR 0 29
83559: PUSH
83560: LD_INT 1
83562: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
83563: LD_VAR 0 4
83567: PUSH
83568: LD_VAR 0 7
83572: ARRAY
83573: PPUSH
83574: LD_INT 71
83576: PPUSH
83577: CALL_OW 109
// continue ;
83581: GO 83496
// end ; end ;
83583: GO 83496
83585: POP
83586: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
83587: LD_VAR 0 4
83591: PUSH
83592: LD_VAR 0 7
83596: ARRAY
83597: PPUSH
83598: CALL_OW 257
83602: PUSH
83603: LD_INT 8
83605: EQUAL
83606: PUSH
83607: LD_VAR 0 4
83611: PUSH
83612: LD_VAR 0 7
83616: ARRAY
83617: PPUSH
83618: CALL_OW 264
83622: PUSH
83623: LD_INT 28
83625: PUSH
83626: LD_INT 45
83628: PUSH
83629: LD_INT 7
83631: PUSH
83632: LD_INT 47
83634: PUSH
83635: EMPTY
83636: LIST
83637: LIST
83638: LIST
83639: LIST
83640: IN
83641: OR
83642: IFFALSE 83898
// begin attacking := false ;
83644: LD_ADDR_VAR 0 29
83648: PUSH
83649: LD_INT 0
83651: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
83652: LD_VAR 0 14
83656: PUSH
83657: LD_INT 1
83659: ARRAY
83660: PPUSH
83661: CALL_OW 266
83665: PUSH
83666: LD_INT 32
83668: PUSH
83669: LD_INT 31
83671: PUSH
83672: LD_INT 33
83674: PUSH
83675: LD_INT 4
83677: PUSH
83678: LD_INT 5
83680: PUSH
83681: EMPTY
83682: LIST
83683: LIST
83684: LIST
83685: LIST
83686: LIST
83687: IN
83688: IFFALSE 83874
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
83690: LD_ADDR_VAR 0 9
83694: PUSH
83695: LD_VAR 0 14
83699: PUSH
83700: LD_INT 1
83702: ARRAY
83703: PPUSH
83704: CALL_OW 266
83708: PPUSH
83709: LD_VAR 0 14
83713: PUSH
83714: LD_INT 1
83716: ARRAY
83717: PPUSH
83718: CALL_OW 250
83722: PPUSH
83723: LD_VAR 0 14
83727: PUSH
83728: LD_INT 1
83730: ARRAY
83731: PPUSH
83732: CALL_OW 251
83736: PPUSH
83737: LD_VAR 0 14
83741: PUSH
83742: LD_INT 1
83744: ARRAY
83745: PPUSH
83746: CALL_OW 254
83750: PPUSH
83751: LD_VAR 0 14
83755: PUSH
83756: LD_INT 1
83758: ARRAY
83759: PPUSH
83760: CALL_OW 248
83764: PPUSH
83765: LD_INT 0
83767: PPUSH
83768: CALL 33318 0 6
83772: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
83773: LD_ADDR_VAR 0 8
83777: PUSH
83778: LD_VAR 0 4
83782: PUSH
83783: LD_VAR 0 7
83787: ARRAY
83788: PPUSH
83789: LD_VAR 0 9
83793: PPUSH
83794: CALL 51988 0 2
83798: ST_TO_ADDR
// if j then
83799: LD_VAR 0 8
83803: IFFALSE 83872
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
83805: LD_VAR 0 8
83809: PUSH
83810: LD_INT 1
83812: ARRAY
83813: PPUSH
83814: LD_VAR 0 8
83818: PUSH
83819: LD_INT 2
83821: ARRAY
83822: PPUSH
83823: CALL_OW 488
83827: IFFALSE 83872
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
83829: LD_VAR 0 4
83833: PUSH
83834: LD_VAR 0 7
83838: ARRAY
83839: PPUSH
83840: LD_VAR 0 8
83844: PUSH
83845: LD_INT 1
83847: ARRAY
83848: PPUSH
83849: LD_VAR 0 8
83853: PUSH
83854: LD_INT 2
83856: ARRAY
83857: PPUSH
83858: CALL_OW 116
// attacking := true ;
83862: LD_ADDR_VAR 0 29
83866: PUSH
83867: LD_INT 1
83869: ST_TO_ADDR
// continue ;
83870: GO 81245
// end ; end else
83872: GO 83898
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
83874: LD_VAR 0 4
83878: PUSH
83879: LD_VAR 0 7
83883: ARRAY
83884: PPUSH
83885: LD_VAR 0 14
83889: PUSH
83890: LD_INT 1
83892: ARRAY
83893: PPUSH
83894: CALL_OW 115
// end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
83898: LD_VAR 0 4
83902: PUSH
83903: LD_VAR 0 7
83907: ARRAY
83908: PPUSH
83909: CALL_OW 265
83913: PUSH
83914: LD_INT 11
83916: EQUAL
83917: IFFALSE 84195
// begin k := 10 ;
83919: LD_ADDR_VAR 0 9
83923: PUSH
83924: LD_INT 10
83926: ST_TO_ADDR
// x := 0 ;
83927: LD_ADDR_VAR 0 10
83931: PUSH
83932: LD_INT 0
83934: ST_TO_ADDR
// if tmp < k then
83935: LD_VAR 0 14
83939: PUSH
83940: LD_VAR 0 9
83944: LESS
83945: IFFALSE 83957
// k := tmp ;
83947: LD_ADDR_VAR 0 9
83951: PUSH
83952: LD_VAR 0 14
83956: ST_TO_ADDR
// for j = k downto 1 do
83957: LD_ADDR_VAR 0 8
83961: PUSH
83962: DOUBLE
83963: LD_VAR 0 9
83967: INC
83968: ST_TO_ADDR
83969: LD_INT 1
83971: PUSH
83972: FOR_DOWNTO
83973: IFFALSE 84048
// begin if GetType ( tmp [ j ] ) = unit_human then
83975: LD_VAR 0 14
83979: PUSH
83980: LD_VAR 0 8
83984: ARRAY
83985: PPUSH
83986: CALL_OW 247
83990: PUSH
83991: LD_INT 1
83993: EQUAL
83994: IFFALSE 84046
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
83996: LD_VAR 0 4
84000: PUSH
84001: LD_VAR 0 7
84005: ARRAY
84006: PPUSH
84007: LD_VAR 0 14
84011: PUSH
84012: LD_VAR 0 8
84016: ARRAY
84017: PPUSH
84018: CALL 52242 0 2
// x := tmp [ j ] ;
84022: LD_ADDR_VAR 0 10
84026: PUSH
84027: LD_VAR 0 14
84031: PUSH
84032: LD_VAR 0 8
84036: ARRAY
84037: ST_TO_ADDR
// attacking := true ;
84038: LD_ADDR_VAR 0 29
84042: PUSH
84043: LD_INT 1
84045: ST_TO_ADDR
// end ; end ;
84046: GO 83972
84048: POP
84049: POP
// if not x then
84050: LD_VAR 0 10
84054: NOT
84055: IFFALSE 84195
// begin attacking := true ;
84057: LD_ADDR_VAR 0 29
84061: PUSH
84062: LD_INT 1
84064: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
84065: LD_VAR 0 4
84069: PUSH
84070: LD_VAR 0 7
84074: ARRAY
84075: PPUSH
84076: CALL_OW 250
84080: PPUSH
84081: LD_VAR 0 4
84085: PUSH
84086: LD_VAR 0 7
84090: ARRAY
84091: PPUSH
84092: CALL_OW 251
84096: PPUSH
84097: CALL_OW 546
84101: PUSH
84102: LD_INT 2
84104: ARRAY
84105: PUSH
84106: LD_VAR 0 14
84110: PUSH
84111: LD_INT 1
84113: ARRAY
84114: PPUSH
84115: CALL_OW 250
84119: PPUSH
84120: LD_VAR 0 14
84124: PUSH
84125: LD_INT 1
84127: ARRAY
84128: PPUSH
84129: CALL_OW 251
84133: PPUSH
84134: CALL_OW 546
84138: PUSH
84139: LD_INT 2
84141: ARRAY
84142: EQUAL
84143: IFFALSE 84171
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
84145: LD_VAR 0 4
84149: PUSH
84150: LD_VAR 0 7
84154: ARRAY
84155: PPUSH
84156: LD_VAR 0 14
84160: PUSH
84161: LD_INT 1
84163: ARRAY
84164: PPUSH
84165: CALL 52242 0 2
84169: GO 84195
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
84171: LD_VAR 0 4
84175: PUSH
84176: LD_VAR 0 7
84180: ARRAY
84181: PPUSH
84182: LD_VAR 0 14
84186: PUSH
84187: LD_INT 1
84189: ARRAY
84190: PPUSH
84191: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
84195: LD_VAR 0 4
84199: PUSH
84200: LD_VAR 0 7
84204: ARRAY
84205: PPUSH
84206: CALL_OW 264
84210: PUSH
84211: LD_INT 29
84213: EQUAL
84214: IFFALSE 84580
// begin if WantsToAttack ( group [ i ] ) in bombed then
84216: LD_VAR 0 4
84220: PUSH
84221: LD_VAR 0 7
84225: ARRAY
84226: PPUSH
84227: CALL_OW 319
84231: PUSH
84232: LD_VAR 0 28
84236: IN
84237: IFFALSE 84241
// continue ;
84239: GO 81245
// k := 8 ;
84241: LD_ADDR_VAR 0 9
84245: PUSH
84246: LD_INT 8
84248: ST_TO_ADDR
// x := 0 ;
84249: LD_ADDR_VAR 0 10
84253: PUSH
84254: LD_INT 0
84256: ST_TO_ADDR
// if tmp < k then
84257: LD_VAR 0 14
84261: PUSH
84262: LD_VAR 0 9
84266: LESS
84267: IFFALSE 84279
// k := tmp ;
84269: LD_ADDR_VAR 0 9
84273: PUSH
84274: LD_VAR 0 14
84278: ST_TO_ADDR
// for j = 1 to k do
84279: LD_ADDR_VAR 0 8
84283: PUSH
84284: DOUBLE
84285: LD_INT 1
84287: DEC
84288: ST_TO_ADDR
84289: LD_VAR 0 9
84293: PUSH
84294: FOR_TO
84295: IFFALSE 84427
// begin if GetType ( tmp [ j ] ) = unit_building then
84297: LD_VAR 0 14
84301: PUSH
84302: LD_VAR 0 8
84306: ARRAY
84307: PPUSH
84308: CALL_OW 247
84312: PUSH
84313: LD_INT 3
84315: EQUAL
84316: IFFALSE 84425
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
84318: LD_VAR 0 14
84322: PUSH
84323: LD_VAR 0 8
84327: ARRAY
84328: PUSH
84329: LD_VAR 0 28
84333: IN
84334: NOT
84335: PUSH
84336: LD_VAR 0 14
84340: PUSH
84341: LD_VAR 0 8
84345: ARRAY
84346: PPUSH
84347: CALL_OW 313
84351: AND
84352: IFFALSE 84425
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
84354: LD_VAR 0 4
84358: PUSH
84359: LD_VAR 0 7
84363: ARRAY
84364: PPUSH
84365: LD_VAR 0 14
84369: PUSH
84370: LD_VAR 0 8
84374: ARRAY
84375: PPUSH
84376: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
84380: LD_ADDR_VAR 0 28
84384: PUSH
84385: LD_VAR 0 28
84389: PPUSH
84390: LD_VAR 0 28
84394: PUSH
84395: LD_INT 1
84397: PLUS
84398: PPUSH
84399: LD_VAR 0 14
84403: PUSH
84404: LD_VAR 0 8
84408: ARRAY
84409: PPUSH
84410: CALL_OW 1
84414: ST_TO_ADDR
// attacking := true ;
84415: LD_ADDR_VAR 0 29
84419: PUSH
84420: LD_INT 1
84422: ST_TO_ADDR
// break ;
84423: GO 84427
// end ; end ;
84425: GO 84294
84427: POP
84428: POP
// if not attacking and f_attack_depot then
84429: LD_VAR 0 29
84433: NOT
84434: PUSH
84435: LD_VAR 0 25
84439: AND
84440: IFFALSE 84535
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
84442: LD_ADDR_VAR 0 13
84446: PUSH
84447: LD_VAR 0 14
84451: PPUSH
84452: LD_INT 2
84454: PUSH
84455: LD_INT 30
84457: PUSH
84458: LD_INT 0
84460: PUSH
84461: EMPTY
84462: LIST
84463: LIST
84464: PUSH
84465: LD_INT 30
84467: PUSH
84468: LD_INT 1
84470: PUSH
84471: EMPTY
84472: LIST
84473: LIST
84474: PUSH
84475: EMPTY
84476: LIST
84477: LIST
84478: LIST
84479: PPUSH
84480: CALL_OW 72
84484: ST_TO_ADDR
// if z then
84485: LD_VAR 0 13
84489: IFFALSE 84535
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
84491: LD_VAR 0 4
84495: PUSH
84496: LD_VAR 0 7
84500: ARRAY
84501: PPUSH
84502: LD_VAR 0 13
84506: PPUSH
84507: LD_VAR 0 4
84511: PUSH
84512: LD_VAR 0 7
84516: ARRAY
84517: PPUSH
84518: CALL_OW 74
84522: PPUSH
84523: CALL_OW 115
// attacking := true ;
84527: LD_ADDR_VAR 0 29
84531: PUSH
84532: LD_INT 1
84534: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
84535: LD_VAR 0 4
84539: PUSH
84540: LD_VAR 0 7
84544: ARRAY
84545: PPUSH
84546: CALL_OW 256
84550: PUSH
84551: LD_INT 500
84553: LESS
84554: IFFALSE 84580
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
84556: LD_VAR 0 4
84560: PUSH
84561: LD_VAR 0 7
84565: ARRAY
84566: PPUSH
84567: LD_VAR 0 14
84571: PUSH
84572: LD_INT 1
84574: ARRAY
84575: PPUSH
84576: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
84580: LD_VAR 0 4
84584: PUSH
84585: LD_VAR 0 7
84589: ARRAY
84590: PPUSH
84591: CALL_OW 264
84595: PUSH
84596: LD_INT 49
84598: EQUAL
84599: IFFALSE 84720
// begin if not HasTask ( group [ i ] ) then
84601: LD_VAR 0 4
84605: PUSH
84606: LD_VAR 0 7
84610: ARRAY
84611: PPUSH
84612: CALL_OW 314
84616: NOT
84617: IFFALSE 84720
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
84619: LD_ADDR_VAR 0 9
84623: PUSH
84624: LD_INT 81
84626: PUSH
84627: LD_VAR 0 4
84631: PUSH
84632: LD_VAR 0 7
84636: ARRAY
84637: PPUSH
84638: CALL_OW 255
84642: PUSH
84643: EMPTY
84644: LIST
84645: LIST
84646: PPUSH
84647: CALL_OW 69
84651: PPUSH
84652: LD_VAR 0 4
84656: PUSH
84657: LD_VAR 0 7
84661: ARRAY
84662: PPUSH
84663: CALL_OW 74
84667: ST_TO_ADDR
// if k then
84668: LD_VAR 0 9
84672: IFFALSE 84720
// if GetDistUnits ( group [ i ] , k ) > 10 then
84674: LD_VAR 0 4
84678: PUSH
84679: LD_VAR 0 7
84683: ARRAY
84684: PPUSH
84685: LD_VAR 0 9
84689: PPUSH
84690: CALL_OW 296
84694: PUSH
84695: LD_INT 10
84697: GREATER
84698: IFFALSE 84720
// ComMoveUnit ( group [ i ] , k ) ;
84700: LD_VAR 0 4
84704: PUSH
84705: LD_VAR 0 7
84709: ARRAY
84710: PPUSH
84711: LD_VAR 0 9
84715: PPUSH
84716: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
84720: LD_VAR 0 4
84724: PUSH
84725: LD_VAR 0 7
84729: ARRAY
84730: PPUSH
84731: CALL_OW 256
84735: PUSH
84736: LD_INT 250
84738: LESS
84739: PUSH
84740: LD_VAR 0 4
84744: PUSH
84745: LD_VAR 0 7
84749: ARRAY
84750: PUSH
84751: LD_INT 21
84753: PUSH
84754: LD_INT 2
84756: PUSH
84757: EMPTY
84758: LIST
84759: LIST
84760: PUSH
84761: LD_INT 23
84763: PUSH
84764: LD_INT 2
84766: PUSH
84767: EMPTY
84768: LIST
84769: LIST
84770: PUSH
84771: EMPTY
84772: LIST
84773: LIST
84774: PPUSH
84775: CALL_OW 69
84779: IN
84780: AND
84781: IFFALSE 84906
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
84783: LD_ADDR_VAR 0 9
84787: PUSH
84788: LD_OWVAR 3
84792: PUSH
84793: LD_VAR 0 4
84797: PUSH
84798: LD_VAR 0 7
84802: ARRAY
84803: DIFF
84804: PPUSH
84805: LD_VAR 0 4
84809: PUSH
84810: LD_VAR 0 7
84814: ARRAY
84815: PPUSH
84816: CALL_OW 74
84820: ST_TO_ADDR
// if not k then
84821: LD_VAR 0 9
84825: NOT
84826: IFFALSE 84830
// continue ;
84828: GO 81245
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
84830: LD_VAR 0 9
84834: PUSH
84835: LD_INT 81
84837: PUSH
84838: LD_VAR 0 4
84842: PUSH
84843: LD_VAR 0 7
84847: ARRAY
84848: PPUSH
84849: CALL_OW 255
84853: PUSH
84854: EMPTY
84855: LIST
84856: LIST
84857: PPUSH
84858: CALL_OW 69
84862: IN
84863: PUSH
84864: LD_VAR 0 9
84868: PPUSH
84869: LD_VAR 0 4
84873: PUSH
84874: LD_VAR 0 7
84878: ARRAY
84879: PPUSH
84880: CALL_OW 296
84884: PUSH
84885: LD_INT 5
84887: LESS
84888: AND
84889: IFFALSE 84906
// ComAutodestruct ( group [ i ] ) ;
84891: LD_VAR 0 4
84895: PUSH
84896: LD_VAR 0 7
84900: ARRAY
84901: PPUSH
84902: CALL 52140 0 1
// end ; if f_attack_depot then
84906: LD_VAR 0 25
84910: IFFALSE 85022
// begin k := 6 ;
84912: LD_ADDR_VAR 0 9
84916: PUSH
84917: LD_INT 6
84919: ST_TO_ADDR
// if tmp < k then
84920: LD_VAR 0 14
84924: PUSH
84925: LD_VAR 0 9
84929: LESS
84930: IFFALSE 84942
// k := tmp ;
84932: LD_ADDR_VAR 0 9
84936: PUSH
84937: LD_VAR 0 14
84941: ST_TO_ADDR
// for j = 1 to k do
84942: LD_ADDR_VAR 0 8
84946: PUSH
84947: DOUBLE
84948: LD_INT 1
84950: DEC
84951: ST_TO_ADDR
84952: LD_VAR 0 9
84956: PUSH
84957: FOR_TO
84958: IFFALSE 85020
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
84960: LD_VAR 0 8
84964: PPUSH
84965: CALL_OW 266
84969: PUSH
84970: LD_INT 0
84972: PUSH
84973: LD_INT 1
84975: PUSH
84976: EMPTY
84977: LIST
84978: LIST
84979: IN
84980: IFFALSE 85018
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
84982: LD_VAR 0 4
84986: PUSH
84987: LD_VAR 0 7
84991: ARRAY
84992: PPUSH
84993: LD_VAR 0 14
84997: PUSH
84998: LD_VAR 0 8
85002: ARRAY
85003: PPUSH
85004: CALL_OW 115
// attacking := true ;
85008: LD_ADDR_VAR 0 29
85012: PUSH
85013: LD_INT 1
85015: ST_TO_ADDR
// break ;
85016: GO 85020
// end ;
85018: GO 84957
85020: POP
85021: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
85022: LD_VAR 0 4
85026: PUSH
85027: LD_VAR 0 7
85031: ARRAY
85032: PPUSH
85033: CALL_OW 302
85037: PUSH
85038: LD_VAR 0 29
85042: NOT
85043: AND
85044: IFFALSE 85366
// begin if GetTag ( group [ i ] ) = 71 then
85046: LD_VAR 0 4
85050: PUSH
85051: LD_VAR 0 7
85055: ARRAY
85056: PPUSH
85057: CALL_OW 110
85061: PUSH
85062: LD_INT 71
85064: EQUAL
85065: IFFALSE 85106
// begin if HasTask ( group [ i ] ) then
85067: LD_VAR 0 4
85071: PUSH
85072: LD_VAR 0 7
85076: ARRAY
85077: PPUSH
85078: CALL_OW 314
85082: IFFALSE 85088
// continue else
85084: GO 81245
85086: GO 85106
// SetTag ( group [ i ] , 0 ) ;
85088: LD_VAR 0 4
85092: PUSH
85093: LD_VAR 0 7
85097: ARRAY
85098: PPUSH
85099: LD_INT 0
85101: PPUSH
85102: CALL_OW 109
// end ; k := 8 ;
85106: LD_ADDR_VAR 0 9
85110: PUSH
85111: LD_INT 8
85113: ST_TO_ADDR
// x := 0 ;
85114: LD_ADDR_VAR 0 10
85118: PUSH
85119: LD_INT 0
85121: ST_TO_ADDR
// if tmp < k then
85122: LD_VAR 0 14
85126: PUSH
85127: LD_VAR 0 9
85131: LESS
85132: IFFALSE 85144
// k := tmp ;
85134: LD_ADDR_VAR 0 9
85138: PUSH
85139: LD_VAR 0 14
85143: ST_TO_ADDR
// for j = 1 to k do
85144: LD_ADDR_VAR 0 8
85148: PUSH
85149: DOUBLE
85150: LD_INT 1
85152: DEC
85153: ST_TO_ADDR
85154: LD_VAR 0 9
85158: PUSH
85159: FOR_TO
85160: IFFALSE 85258
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
85162: LD_VAR 0 14
85166: PUSH
85167: LD_VAR 0 8
85171: ARRAY
85172: PPUSH
85173: CALL_OW 247
85177: PUSH
85178: LD_INT 1
85180: EQUAL
85181: PUSH
85182: LD_VAR 0 14
85186: PUSH
85187: LD_VAR 0 8
85191: ARRAY
85192: PPUSH
85193: CALL_OW 256
85197: PUSH
85198: LD_INT 250
85200: LESS
85201: PUSH
85202: LD_VAR 0 20
85206: AND
85207: PUSH
85208: LD_VAR 0 20
85212: NOT
85213: PUSH
85214: LD_VAR 0 14
85218: PUSH
85219: LD_VAR 0 8
85223: ARRAY
85224: PPUSH
85225: CALL_OW 256
85229: PUSH
85230: LD_INT 250
85232: GREATEREQUAL
85233: AND
85234: OR
85235: AND
85236: IFFALSE 85256
// begin x := tmp [ j ] ;
85238: LD_ADDR_VAR 0 10
85242: PUSH
85243: LD_VAR 0 14
85247: PUSH
85248: LD_VAR 0 8
85252: ARRAY
85253: ST_TO_ADDR
// break ;
85254: GO 85258
// end ;
85256: GO 85159
85258: POP
85259: POP
// if x then
85260: LD_VAR 0 10
85264: IFFALSE 85288
// ComAttackUnit ( group [ i ] , x ) else
85266: LD_VAR 0 4
85270: PUSH
85271: LD_VAR 0 7
85275: ARRAY
85276: PPUSH
85277: LD_VAR 0 10
85281: PPUSH
85282: CALL_OW 115
85286: GO 85312
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
85288: LD_VAR 0 4
85292: PUSH
85293: LD_VAR 0 7
85297: ARRAY
85298: PPUSH
85299: LD_VAR 0 14
85303: PUSH
85304: LD_INT 1
85306: ARRAY
85307: PPUSH
85308: CALL_OW 115
// if not HasTask ( group [ i ] ) then
85312: LD_VAR 0 4
85316: PUSH
85317: LD_VAR 0 7
85321: ARRAY
85322: PPUSH
85323: CALL_OW 314
85327: NOT
85328: IFFALSE 85366
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
85330: LD_VAR 0 4
85334: PUSH
85335: LD_VAR 0 7
85339: ARRAY
85340: PPUSH
85341: LD_VAR 0 14
85345: PPUSH
85346: LD_VAR 0 4
85350: PUSH
85351: LD_VAR 0 7
85355: ARRAY
85356: PPUSH
85357: CALL_OW 74
85361: PPUSH
85362: CALL_OW 115
// end ; end ; end ;
85366: GO 81245
85368: POP
85369: POP
// wait ( 0 0$2 ) ;
85370: LD_INT 70
85372: PPUSH
85373: CALL_OW 67
// until not group or group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
85377: LD_VAR 0 4
85381: NOT
85382: PUSH
85383: LD_VAR 0 4
85387: PUSH
85388: EMPTY
85389: EQUAL
85390: OR
85391: PUSH
85392: LD_INT 81
85394: PUSH
85395: LD_VAR 0 35
85399: PUSH
85400: EMPTY
85401: LIST
85402: LIST
85403: PPUSH
85404: CALL_OW 69
85408: NOT
85409: OR
85410: IFFALSE 81230
// end ;
85412: LD_VAR 0 2
85416: RET
// export function BasicDefend ( base , solds ) ; var enemy , e , side , i , hex ; begin
85417: LD_INT 0
85419: PPUSH
85420: PPUSH
85421: PPUSH
85422: PPUSH
85423: PPUSH
85424: PPUSH
// if not base or not mc_bases [ base ] or not solds then
85425: LD_VAR 0 1
85429: NOT
85430: PUSH
85431: LD_EXP 178
85435: PUSH
85436: LD_VAR 0 1
85440: ARRAY
85441: NOT
85442: OR
85443: PUSH
85444: LD_VAR 0 2
85448: NOT
85449: OR
85450: IFFALSE 85454
// exit ;
85452: GO 86008
// side := mc_sides [ base ] ;
85454: LD_ADDR_VAR 0 6
85458: PUSH
85459: LD_EXP 204
85463: PUSH
85464: LD_VAR 0 1
85468: ARRAY
85469: ST_TO_ADDR
// if not side then
85470: LD_VAR 0 6
85474: NOT
85475: IFFALSE 85479
// exit ;
85477: GO 86008
// for i in solds do
85479: LD_ADDR_VAR 0 7
85483: PUSH
85484: LD_VAR 0 2
85488: PUSH
85489: FOR_IN
85490: IFFALSE 85551
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
85492: LD_VAR 0 7
85496: PPUSH
85497: CALL_OW 310
85501: PPUSH
85502: CALL_OW 266
85506: PUSH
85507: LD_INT 32
85509: PUSH
85510: LD_INT 31
85512: PUSH
85513: EMPTY
85514: LIST
85515: LIST
85516: IN
85517: IFFALSE 85537
// solds := solds diff i else
85519: LD_ADDR_VAR 0 2
85523: PUSH
85524: LD_VAR 0 2
85528: PUSH
85529: LD_VAR 0 7
85533: DIFF
85534: ST_TO_ADDR
85535: GO 85549
// SetTag ( i , 18 ) ;
85537: LD_VAR 0 7
85541: PPUSH
85542: LD_INT 18
85544: PPUSH
85545: CALL_OW 109
85549: GO 85489
85551: POP
85552: POP
// if not solds then
85553: LD_VAR 0 2
85557: NOT
85558: IFFALSE 85562
// exit ;
85560: GO 86008
// repeat wait ( 0 0$2 ) ;
85562: LD_INT 70
85564: PPUSH
85565: CALL_OW 67
// enemy := mc_scan [ base ] ;
85569: LD_ADDR_VAR 0 4
85573: PUSH
85574: LD_EXP 201
85578: PUSH
85579: LD_VAR 0 1
85583: ARRAY
85584: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
85585: LD_EXP 178
85589: PUSH
85590: LD_VAR 0 1
85594: ARRAY
85595: NOT
85596: PUSH
85597: LD_EXP 178
85601: PUSH
85602: LD_VAR 0 1
85606: ARRAY
85607: PUSH
85608: EMPTY
85609: EQUAL
85610: OR
85611: IFFALSE 85648
// begin for i in solds do
85613: LD_ADDR_VAR 0 7
85617: PUSH
85618: LD_VAR 0 2
85622: PUSH
85623: FOR_IN
85624: IFFALSE 85637
// ComStop ( i ) ;
85626: LD_VAR 0 7
85630: PPUSH
85631: CALL_OW 141
85635: GO 85623
85637: POP
85638: POP
// solds := [ ] ;
85639: LD_ADDR_VAR 0 2
85643: PUSH
85644: EMPTY
85645: ST_TO_ADDR
// exit ;
85646: GO 86008
// end ; for i in solds do
85648: LD_ADDR_VAR 0 7
85652: PUSH
85653: LD_VAR 0 2
85657: PUSH
85658: FOR_IN
85659: IFFALSE 85980
// begin if IsInUnit ( i ) then
85661: LD_VAR 0 7
85665: PPUSH
85666: CALL_OW 310
85670: IFFALSE 85681
// ComExitBuilding ( i ) ;
85672: LD_VAR 0 7
85676: PPUSH
85677: CALL_OW 122
// if GetLives ( i ) > 500 then
85681: LD_VAR 0 7
85685: PPUSH
85686: CALL_OW 256
85690: PUSH
85691: LD_INT 500
85693: GREATER
85694: IFFALSE 85747
// begin e := NearestUnitToUnit ( enemy , i ) ;
85696: LD_ADDR_VAR 0 5
85700: PUSH
85701: LD_VAR 0 4
85705: PPUSH
85706: LD_VAR 0 7
85710: PPUSH
85711: CALL_OW 74
85715: ST_TO_ADDR
// ComAgressiveMove ( i , GetX ( e ) , GetY ( e ) ) ;
85716: LD_VAR 0 7
85720: PPUSH
85721: LD_VAR 0 5
85725: PPUSH
85726: CALL_OW 250
85730: PPUSH
85731: LD_VAR 0 5
85735: PPUSH
85736: CALL_OW 251
85740: PPUSH
85741: CALL_OW 114
// end else
85745: GO 85978
// if GetDistUnits ( i , NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ) > 10 then
85747: LD_VAR 0 7
85751: PPUSH
85752: LD_EXP 178
85756: PUSH
85757: LD_VAR 0 1
85761: ARRAY
85762: PPUSH
85763: LD_INT 2
85765: PUSH
85766: LD_INT 30
85768: PUSH
85769: LD_INT 0
85771: PUSH
85772: EMPTY
85773: LIST
85774: LIST
85775: PUSH
85776: LD_INT 30
85778: PUSH
85779: LD_INT 1
85781: PUSH
85782: EMPTY
85783: LIST
85784: LIST
85785: PUSH
85786: LD_INT 30
85788: PUSH
85789: LD_INT 6
85791: PUSH
85792: EMPTY
85793: LIST
85794: LIST
85795: PUSH
85796: EMPTY
85797: LIST
85798: LIST
85799: LIST
85800: LIST
85801: PPUSH
85802: CALL_OW 72
85806: PPUSH
85807: LD_VAR 0 7
85811: PPUSH
85812: CALL_OW 74
85816: PPUSH
85817: CALL_OW 296
85821: PUSH
85822: LD_INT 10
85824: GREATER
85825: IFFALSE 85978
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
85827: LD_ADDR_VAR 0 8
85831: PUSH
85832: LD_EXP 178
85836: PUSH
85837: LD_VAR 0 1
85841: ARRAY
85842: PPUSH
85843: LD_INT 2
85845: PUSH
85846: LD_INT 30
85848: PUSH
85849: LD_INT 0
85851: PUSH
85852: EMPTY
85853: LIST
85854: LIST
85855: PUSH
85856: LD_INT 30
85858: PUSH
85859: LD_INT 1
85861: PUSH
85862: EMPTY
85863: LIST
85864: LIST
85865: PUSH
85866: LD_INT 30
85868: PUSH
85869: LD_INT 6
85871: PUSH
85872: EMPTY
85873: LIST
85874: LIST
85875: PUSH
85876: EMPTY
85877: LIST
85878: LIST
85879: LIST
85880: LIST
85881: PPUSH
85882: CALL_OW 72
85886: PPUSH
85887: LD_VAR 0 7
85891: PPUSH
85892: CALL_OW 74
85896: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
85897: LD_VAR 0 7
85901: PPUSH
85902: LD_VAR 0 8
85906: PPUSH
85907: CALL_OW 250
85911: PPUSH
85912: LD_INT 3
85914: PPUSH
85915: LD_INT 5
85917: PPUSH
85918: CALL_OW 272
85922: PPUSH
85923: LD_VAR 0 8
85927: PPUSH
85928: CALL_OW 251
85932: PPUSH
85933: LD_INT 3
85935: PPUSH
85936: LD_INT 5
85938: PPUSH
85939: CALL_OW 273
85943: PPUSH
85944: CALL_OW 111
// SetTag ( i , 0 ) ;
85948: LD_VAR 0 7
85952: PPUSH
85953: LD_INT 0
85955: PPUSH
85956: CALL_OW 109
// solds := solds diff i ;
85960: LD_ADDR_VAR 0 2
85964: PUSH
85965: LD_VAR 0 2
85969: PUSH
85970: LD_VAR 0 7
85974: DIFF
85975: ST_TO_ADDR
// continue ;
85976: GO 85658
// end ; end ;
85978: GO 85658
85980: POP
85981: POP
// until not solds or not enemy ;
85982: LD_VAR 0 2
85986: NOT
85987: PUSH
85988: LD_VAR 0 4
85992: NOT
85993: OR
85994: IFFALSE 85562
// MC_Reset ( base , 18 ) ;
85996: LD_VAR 0 1
86000: PPUSH
86001: LD_INT 18
86003: PPUSH
86004: CALL 92163 0 2
// end ;
86008: LD_VAR 0 3
86012: RET
// export function Defend ( base , defenders ) ; var i , j , x , depot , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend , class , enemy ; begin
86013: LD_INT 0
86015: PPUSH
86016: PPUSH
86017: PPUSH
86018: PPUSH
86019: PPUSH
86020: PPUSH
86021: PPUSH
86022: PPUSH
86023: PPUSH
86024: PPUSH
86025: PPUSH
86026: PPUSH
86027: PPUSH
86028: PPUSH
86029: PPUSH
86030: PPUSH
86031: PPUSH
86032: PPUSH
86033: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
86034: LD_ADDR_VAR 0 12
86038: PUSH
86039: LD_EXP 178
86043: PUSH
86044: LD_VAR 0 1
86048: ARRAY
86049: PPUSH
86050: LD_INT 25
86052: PUSH
86053: LD_INT 3
86055: PUSH
86056: EMPTY
86057: LIST
86058: LIST
86059: PPUSH
86060: CALL_OW 72
86064: ST_TO_ADDR
// if mc_remote_driver [ base ] then
86065: LD_EXP 218
86069: PUSH
86070: LD_VAR 0 1
86074: ARRAY
86075: IFFALSE 86099
// mechs := mechs diff mc_remote_driver [ base ] ;
86077: LD_ADDR_VAR 0 12
86081: PUSH
86082: LD_VAR 0 12
86086: PUSH
86087: LD_EXP 218
86091: PUSH
86092: LD_VAR 0 1
86096: ARRAY
86097: DIFF
86098: ST_TO_ADDR
// for i in mechs do
86099: LD_ADDR_VAR 0 4
86103: PUSH
86104: LD_VAR 0 12
86108: PUSH
86109: FOR_IN
86110: IFFALSE 86145
// if GetTag ( i ) > 0 then
86112: LD_VAR 0 4
86116: PPUSH
86117: CALL_OW 110
86121: PUSH
86122: LD_INT 0
86124: GREATER
86125: IFFALSE 86143
// mechs := mechs diff i ;
86127: LD_ADDR_VAR 0 12
86131: PUSH
86132: LD_VAR 0 12
86136: PUSH
86137: LD_VAR 0 4
86141: DIFF
86142: ST_TO_ADDR
86143: GO 86109
86145: POP
86146: POP
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
86147: LD_ADDR_VAR 0 8
86151: PUSH
86152: LD_EXP 178
86156: PUSH
86157: LD_VAR 0 1
86161: ARRAY
86162: PPUSH
86163: LD_INT 2
86165: PUSH
86166: LD_INT 25
86168: PUSH
86169: LD_INT 1
86171: PUSH
86172: EMPTY
86173: LIST
86174: LIST
86175: PUSH
86176: LD_INT 25
86178: PUSH
86179: LD_INT 5
86181: PUSH
86182: EMPTY
86183: LIST
86184: LIST
86185: PUSH
86186: LD_INT 25
86188: PUSH
86189: LD_INT 8
86191: PUSH
86192: EMPTY
86193: LIST
86194: LIST
86195: PUSH
86196: LD_INT 25
86198: PUSH
86199: LD_INT 9
86201: PUSH
86202: EMPTY
86203: LIST
86204: LIST
86205: PUSH
86206: EMPTY
86207: LIST
86208: LIST
86209: LIST
86210: LIST
86211: LIST
86212: PPUSH
86213: CALL_OW 72
86217: ST_TO_ADDR
// if not defenders and not solds then
86218: LD_VAR 0 2
86222: NOT
86223: PUSH
86224: LD_VAR 0 8
86228: NOT
86229: AND
86230: IFFALSE 86234
// exit ;
86232: GO 88004
// depot_under_attack := false ;
86234: LD_ADDR_VAR 0 16
86238: PUSH
86239: LD_INT 0
86241: ST_TO_ADDR
// sold_defenders := [ ] ;
86242: LD_ADDR_VAR 0 17
86246: PUSH
86247: EMPTY
86248: ST_TO_ADDR
// if mechs then
86249: LD_VAR 0 12
86253: IFFALSE 86406
// for i in UnitFilter ( defenders , [ f_type , unit_vehicle ] ) do
86255: LD_ADDR_VAR 0 4
86259: PUSH
86260: LD_VAR 0 2
86264: PPUSH
86265: LD_INT 21
86267: PUSH
86268: LD_INT 2
86270: PUSH
86271: EMPTY
86272: LIST
86273: LIST
86274: PPUSH
86275: CALL_OW 72
86279: PUSH
86280: FOR_IN
86281: IFFALSE 86404
// begin if GetTag ( i ) <> 20 then
86283: LD_VAR 0 4
86287: PPUSH
86288: CALL_OW 110
86292: PUSH
86293: LD_INT 20
86295: NONEQUAL
86296: IFFALSE 86310
// SetTag ( i , 20 ) ;
86298: LD_VAR 0 4
86302: PPUSH
86303: LD_INT 20
86305: PPUSH
86306: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) then
86310: LD_VAR 0 4
86314: PPUSH
86315: CALL_OW 263
86319: PUSH
86320: LD_INT 1
86322: EQUAL
86323: PUSH
86324: LD_VAR 0 4
86328: PPUSH
86329: CALL_OW 311
86333: NOT
86334: AND
86335: IFFALSE 86402
// begin un := mechs [ 1 ] ;
86337: LD_ADDR_VAR 0 10
86341: PUSH
86342: LD_VAR 0 12
86346: PUSH
86347: LD_INT 1
86349: ARRAY
86350: ST_TO_ADDR
// ComExit ( un ) ;
86351: LD_VAR 0 10
86355: PPUSH
86356: CALL 57006 0 1
// AddComEnterUnit ( un , i ) ;
86360: LD_VAR 0 10
86364: PPUSH
86365: LD_VAR 0 4
86369: PPUSH
86370: CALL_OW 180
// SetTag ( un , 19 ) ;
86374: LD_VAR 0 10
86378: PPUSH
86379: LD_INT 19
86381: PPUSH
86382: CALL_OW 109
// mechs := mechs diff un ;
86386: LD_ADDR_VAR 0 12
86390: PUSH
86391: LD_VAR 0 12
86395: PUSH
86396: LD_VAR 0 10
86400: DIFF
86401: ST_TO_ADDR
// end ; end ;
86402: GO 86280
86404: POP
86405: POP
// if solds then
86406: LD_VAR 0 8
86410: IFFALSE 86469
// for i in solds do
86412: LD_ADDR_VAR 0 4
86416: PUSH
86417: LD_VAR 0 8
86421: PUSH
86422: FOR_IN
86423: IFFALSE 86467
// if not GetTag ( i ) then
86425: LD_VAR 0 4
86429: PPUSH
86430: CALL_OW 110
86434: NOT
86435: IFFALSE 86465
// begin defenders := defenders union i ;
86437: LD_ADDR_VAR 0 2
86441: PUSH
86442: LD_VAR 0 2
86446: PUSH
86447: LD_VAR 0 4
86451: UNION
86452: ST_TO_ADDR
// SetTag ( i , 18 ) ;
86453: LD_VAR 0 4
86457: PPUSH
86458: LD_INT 18
86460: PPUSH
86461: CALL_OW 109
// end ;
86465: GO 86422
86467: POP
86468: POP
// repeat wait ( 0 0$2 ) ;
86469: LD_INT 70
86471: PPUSH
86472: CALL_OW 67
// enemy := mc_scan [ base ] ;
86476: LD_ADDR_VAR 0 21
86480: PUSH
86481: LD_EXP 201
86485: PUSH
86486: LD_VAR 0 1
86490: ARRAY
86491: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
86492: LD_EXP 178
86496: PUSH
86497: LD_VAR 0 1
86501: ARRAY
86502: NOT
86503: PUSH
86504: LD_EXP 178
86508: PUSH
86509: LD_VAR 0 1
86513: ARRAY
86514: PUSH
86515: EMPTY
86516: EQUAL
86517: OR
86518: IFFALSE 86555
// begin for i in defenders do
86520: LD_ADDR_VAR 0 4
86524: PUSH
86525: LD_VAR 0 2
86529: PUSH
86530: FOR_IN
86531: IFFALSE 86544
// ComStop ( i ) ;
86533: LD_VAR 0 4
86537: PPUSH
86538: CALL_OW 141
86542: GO 86530
86544: POP
86545: POP
// defenders := [ ] ;
86546: LD_ADDR_VAR 0 2
86550: PUSH
86551: EMPTY
86552: ST_TO_ADDR
// exit ;
86553: GO 88004
// end ; for i in defenders do
86555: LD_ADDR_VAR 0 4
86559: PUSH
86560: LD_VAR 0 2
86564: PUSH
86565: FOR_IN
86566: IFFALSE 87464
// begin e := NearestUnitToUnit ( enemy , i ) ;
86568: LD_ADDR_VAR 0 13
86572: PUSH
86573: LD_VAR 0 21
86577: PPUSH
86578: LD_VAR 0 4
86582: PPUSH
86583: CALL_OW 74
86587: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
86588: LD_ADDR_VAR 0 7
86592: PUSH
86593: LD_EXP 178
86597: PUSH
86598: LD_VAR 0 1
86602: ARRAY
86603: PPUSH
86604: LD_INT 2
86606: PUSH
86607: LD_INT 30
86609: PUSH
86610: LD_INT 0
86612: PUSH
86613: EMPTY
86614: LIST
86615: LIST
86616: PUSH
86617: LD_INT 30
86619: PUSH
86620: LD_INT 1
86622: PUSH
86623: EMPTY
86624: LIST
86625: LIST
86626: PUSH
86627: EMPTY
86628: LIST
86629: LIST
86630: LIST
86631: PPUSH
86632: CALL_OW 72
86636: ST_TO_ADDR
// depot_under_attack := ( not depot or UnitFilter ( depot , [ f_not , [ f_lives , 600 ] ] ) ) ;
86637: LD_ADDR_VAR 0 16
86641: PUSH
86642: LD_VAR 0 7
86646: NOT
86647: PUSH
86648: LD_VAR 0 7
86652: PPUSH
86653: LD_INT 3
86655: PUSH
86656: LD_INT 24
86658: PUSH
86659: LD_INT 600
86661: PUSH
86662: EMPTY
86663: LIST
86664: LIST
86665: PUSH
86666: EMPTY
86667: LIST
86668: LIST
86669: PPUSH
86670: CALL_OW 72
86674: OR
86675: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
86676: LD_VAR 0 4
86680: PPUSH
86681: CALL_OW 247
86685: PUSH
86686: LD_INT 2
86688: DOUBLE
86689: EQUAL
86690: IFTRUE 86694
86692: GO 87090
86694: POP
// begin if GetLives ( i ) = 1000 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
86695: LD_VAR 0 4
86699: PPUSH
86700: CALL_OW 256
86704: PUSH
86705: LD_INT 1000
86707: EQUAL
86708: PUSH
86709: LD_VAR 0 4
86713: PPUSH
86714: LD_VAR 0 13
86718: PPUSH
86719: CALL_OW 296
86723: PUSH
86724: LD_INT 40
86726: LESS
86727: PUSH
86728: LD_VAR 0 13
86732: PPUSH
86733: LD_EXP 203
86737: PUSH
86738: LD_VAR 0 1
86742: ARRAY
86743: PPUSH
86744: CALL_OW 308
86748: OR
86749: AND
86750: IFFALSE 86872
// begin if GetEngine ( i ) = engine_combustion and GetFuel ( i ) < 30 and depot then
86752: LD_VAR 0 4
86756: PPUSH
86757: CALL_OW 262
86761: PUSH
86762: LD_INT 1
86764: EQUAL
86765: PUSH
86766: LD_VAR 0 4
86770: PPUSH
86771: CALL_OW 261
86775: PUSH
86776: LD_INT 30
86778: LESS
86779: AND
86780: PUSH
86781: LD_VAR 0 7
86785: AND
86786: IFFALSE 86856
// begin ComMoveUnit ( i , NearestUnitToUnit ( depot , i ) ) ;
86788: LD_VAR 0 4
86792: PPUSH
86793: LD_VAR 0 7
86797: PPUSH
86798: LD_VAR 0 4
86802: PPUSH
86803: CALL_OW 74
86807: PPUSH
86808: CALL_OW 112
// if GetDistUnits ( i , NearestUnitToUnit ( depot , i ) ) < 6 then
86812: LD_VAR 0 4
86816: PPUSH
86817: LD_VAR 0 7
86821: PPUSH
86822: LD_VAR 0 4
86826: PPUSH
86827: CALL_OW 74
86831: PPUSH
86832: CALL_OW 296
86836: PUSH
86837: LD_INT 6
86839: LESS
86840: IFFALSE 86854
// SetFuel ( i , 100 ) ;
86842: LD_VAR 0 4
86846: PPUSH
86847: LD_INT 100
86849: PPUSH
86850: CALL_OW 240
// end else
86854: GO 86870
// ComAttackUnit ( i , e ) ;
86856: LD_VAR 0 4
86860: PPUSH
86861: LD_VAR 0 13
86865: PPUSH
86866: CALL_OW 115
// end else
86870: GO 86973
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
86872: LD_VAR 0 13
86876: PPUSH
86877: LD_EXP 203
86881: PUSH
86882: LD_VAR 0 1
86886: ARRAY
86887: PPUSH
86888: CALL_OW 308
86892: NOT
86893: PUSH
86894: LD_VAR 0 4
86898: PPUSH
86899: LD_VAR 0 13
86903: PPUSH
86904: CALL_OW 296
86908: PUSH
86909: LD_INT 40
86911: GREATEREQUAL
86912: AND
86913: PUSH
86914: LD_VAR 0 4
86918: PPUSH
86919: CALL_OW 256
86923: PUSH
86924: LD_INT 650
86926: LESSEQUAL
86927: OR
86928: PUSH
86929: LD_VAR 0 4
86933: PPUSH
86934: LD_EXP 202
86938: PUSH
86939: LD_VAR 0 1
86943: ARRAY
86944: PPUSH
86945: CALL_OW 308
86949: NOT
86950: AND
86951: IFFALSE 86973
// ComMoveToArea ( i , mc_parking [ base ] ) ;
86953: LD_VAR 0 4
86957: PPUSH
86958: LD_EXP 202
86962: PUSH
86963: LD_VAR 0 1
86967: ARRAY
86968: PPUSH
86969: CALL_OW 113
// if GetLives ( i ) < 1000 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
86973: LD_VAR 0 4
86977: PPUSH
86978: CALL_OW 256
86982: PUSH
86983: LD_INT 1000
86985: LESS
86986: PUSH
86987: LD_VAR 0 4
86991: PPUSH
86992: CALL_OW 263
86996: PUSH
86997: LD_INT 1
86999: EQUAL
87000: AND
87001: PUSH
87002: LD_VAR 0 4
87006: PPUSH
87007: CALL_OW 311
87011: AND
87012: PUSH
87013: LD_VAR 0 4
87017: PPUSH
87018: LD_EXP 202
87022: PUSH
87023: LD_VAR 0 1
87027: ARRAY
87028: PPUSH
87029: CALL_OW 308
87033: AND
87034: IFFALSE 87088
// begin mech := IsDrivenBy ( i ) ;
87036: LD_ADDR_VAR 0 9
87040: PUSH
87041: LD_VAR 0 4
87045: PPUSH
87046: CALL_OW 311
87050: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
87051: LD_VAR 0 9
87055: PPUSH
87056: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
87060: LD_VAR 0 9
87064: PPUSH
87065: LD_VAR 0 4
87069: PPUSH
87070: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
87074: LD_VAR 0 9
87078: PPUSH
87079: LD_VAR 0 4
87083: PPUSH
87084: CALL_OW 180
// end ; end ; unit_human :
87088: GO 87435
87090: LD_INT 1
87092: DOUBLE
87093: EQUAL
87094: IFTRUE 87098
87096: GO 87434
87098: POP
// begin b := IsInUnit ( i ) ;
87099: LD_ADDR_VAR 0 18
87103: PUSH
87104: LD_VAR 0 4
87108: PPUSH
87109: CALL_OW 310
87113: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
87114: LD_ADDR_VAR 0 19
87118: PUSH
87119: LD_VAR 0 18
87123: NOT
87124: PUSH
87125: LD_VAR 0 18
87129: PPUSH
87130: CALL_OW 266
87134: PUSH
87135: LD_INT 32
87137: PUSH
87138: LD_INT 31
87140: PUSH
87141: EMPTY
87142: LIST
87143: LIST
87144: IN
87145: OR
87146: ST_TO_ADDR
// if GetBType ( b ) = b_barracks and GetClass ( i ) in [ 1 , 2 , 3 , 4 ] then
87147: LD_VAR 0 18
87151: PPUSH
87152: CALL_OW 266
87156: PUSH
87157: LD_INT 5
87159: EQUAL
87160: PUSH
87161: LD_VAR 0 4
87165: PPUSH
87166: CALL_OW 257
87170: PUSH
87171: LD_INT 1
87173: PUSH
87174: LD_INT 2
87176: PUSH
87177: LD_INT 3
87179: PUSH
87180: LD_INT 4
87182: PUSH
87183: EMPTY
87184: LIST
87185: LIST
87186: LIST
87187: LIST
87188: IN
87189: AND
87190: IFFALSE 87227
// begin class := AllowSpecClass ( i ) ;
87192: LD_ADDR_VAR 0 20
87196: PUSH
87197: LD_VAR 0 4
87201: PPUSH
87202: CALL 21010 0 1
87206: ST_TO_ADDR
// if class then
87207: LD_VAR 0 20
87211: IFFALSE 87227
// ComChangeProfession ( i , class ) ;
87213: LD_VAR 0 4
87217: PPUSH
87218: LD_VAR 0 20
87222: PPUSH
87223: CALL_OW 123
// end ; if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
87227: LD_VAR 0 16
87231: PUSH
87232: LD_VAR 0 2
87236: PPUSH
87237: LD_INT 21
87239: PUSH
87240: LD_INT 2
87242: PUSH
87243: EMPTY
87244: LIST
87245: LIST
87246: PPUSH
87247: CALL_OW 72
87251: PUSH
87252: LD_INT 1
87254: LESSEQUAL
87255: OR
87256: PUSH
87257: LD_VAR 0 19
87261: AND
87262: PUSH
87263: LD_VAR 0 4
87267: PUSH
87268: LD_VAR 0 17
87272: IN
87273: NOT
87274: AND
87275: IFFALSE 87368
// begin if b then
87277: LD_VAR 0 18
87281: IFFALSE 87330
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
87283: LD_VAR 0 18
87287: PPUSH
87288: LD_VAR 0 21
87292: PPUSH
87293: LD_VAR 0 18
87297: PPUSH
87298: CALL_OW 74
87302: PPUSH
87303: CALL_OW 296
87307: PUSH
87308: LD_INT 10
87310: LESS
87311: PUSH
87312: LD_VAR 0 18
87316: PPUSH
87317: CALL_OW 461
87321: PUSH
87322: LD_INT 7
87324: NONEQUAL
87325: AND
87326: IFFALSE 87330
// continue ;
87328: GO 86565
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
87330: LD_ADDR_VAR 0 17
87334: PUSH
87335: LD_VAR 0 17
87339: PPUSH
87340: LD_VAR 0 17
87344: PUSH
87345: LD_INT 1
87347: PLUS
87348: PPUSH
87349: LD_VAR 0 4
87353: PPUSH
87354: CALL_OW 1
87358: ST_TO_ADDR
// ComExitBuilding ( i ) ;
87359: LD_VAR 0 4
87363: PPUSH
87364: CALL_OW 122
// end ; if sold_defenders then
87368: LD_VAR 0 17
87372: IFFALSE 87432
// if i in sold_defenders then
87374: LD_VAR 0 4
87378: PUSH
87379: LD_VAR 0 17
87383: IN
87384: IFFALSE 87432
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
87386: LD_VAR 0 4
87390: PPUSH
87391: CALL_OW 314
87395: NOT
87396: PUSH
87397: LD_VAR 0 4
87401: PPUSH
87402: LD_VAR 0 13
87406: PPUSH
87407: CALL_OW 296
87411: PUSH
87412: LD_INT 30
87414: LESS
87415: AND
87416: IFFALSE 87432
// ComAttackUnit ( i , e ) ;
87418: LD_VAR 0 4
87422: PPUSH
87423: LD_VAR 0 13
87427: PPUSH
87428: CALL_OW 115
// end ; end ; end ;
87432: GO 87435
87434: POP
// if IsDead ( i ) then
87435: LD_VAR 0 4
87439: PPUSH
87440: CALL_OW 301
87444: IFFALSE 87462
// defenders := defenders diff i ;
87446: LD_ADDR_VAR 0 2
87450: PUSH
87451: LD_VAR 0 2
87455: PUSH
87456: LD_VAR 0 4
87460: DIFF
87461: ST_TO_ADDR
// end ;
87462: GO 86565
87464: POP
87465: POP
// until not enemy or not defenders or not mc_bases [ base ] ;
87466: LD_VAR 0 21
87470: NOT
87471: PUSH
87472: LD_VAR 0 2
87476: NOT
87477: OR
87478: PUSH
87479: LD_EXP 178
87483: PUSH
87484: LD_VAR 0 1
87488: ARRAY
87489: NOT
87490: OR
87491: IFFALSE 86469
// MC_Reset ( base , 18 ) ;
87493: LD_VAR 0 1
87497: PPUSH
87498: LD_INT 18
87500: PPUSH
87501: CALL 92163 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
87505: LD_ADDR_VAR 0 2
87509: PUSH
87510: LD_VAR 0 2
87514: PUSH
87515: LD_VAR 0 2
87519: PPUSH
87520: LD_INT 2
87522: PUSH
87523: LD_INT 25
87525: PUSH
87526: LD_INT 1
87528: PUSH
87529: EMPTY
87530: LIST
87531: LIST
87532: PUSH
87533: LD_INT 25
87535: PUSH
87536: LD_INT 5
87538: PUSH
87539: EMPTY
87540: LIST
87541: LIST
87542: PUSH
87543: LD_INT 25
87545: PUSH
87546: LD_INT 8
87548: PUSH
87549: EMPTY
87550: LIST
87551: LIST
87552: PUSH
87553: LD_INT 25
87555: PUSH
87556: LD_INT 9
87558: PUSH
87559: EMPTY
87560: LIST
87561: LIST
87562: PUSH
87563: EMPTY
87564: LIST
87565: LIST
87566: LIST
87567: LIST
87568: LIST
87569: PPUSH
87570: CALL_OW 72
87574: DIFF
87575: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
87576: LD_VAR 0 21
87580: NOT
87581: PUSH
87582: LD_VAR 0 2
87586: PPUSH
87587: LD_INT 21
87589: PUSH
87590: LD_INT 2
87592: PUSH
87593: EMPTY
87594: LIST
87595: LIST
87596: PPUSH
87597: CALL_OW 72
87601: AND
87602: IFFALSE 87940
// begin tmp := FilterByTag ( defenders , 19 ) ;
87604: LD_ADDR_VAR 0 11
87608: PUSH
87609: LD_VAR 0 2
87613: PPUSH
87614: LD_INT 19
87616: PPUSH
87617: CALL 54182 0 2
87621: ST_TO_ADDR
// if tmp then
87622: LD_VAR 0 11
87626: IFFALSE 87696
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
87628: LD_ADDR_VAR 0 11
87632: PUSH
87633: LD_VAR 0 11
87637: PPUSH
87638: LD_INT 25
87640: PUSH
87641: LD_INT 3
87643: PUSH
87644: EMPTY
87645: LIST
87646: LIST
87647: PPUSH
87648: CALL_OW 72
87652: ST_TO_ADDR
// if tmp then
87653: LD_VAR 0 11
87657: IFFALSE 87696
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
87659: LD_ADDR_EXP 190
87663: PUSH
87664: LD_EXP 190
87668: PPUSH
87669: LD_VAR 0 1
87673: PPUSH
87674: LD_EXP 190
87678: PUSH
87679: LD_VAR 0 1
87683: ARRAY
87684: PUSH
87685: LD_VAR 0 11
87689: UNION
87690: PPUSH
87691: CALL_OW 1
87695: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
87696: LD_VAR 0 1
87700: PPUSH
87701: LD_INT 19
87703: PPUSH
87704: CALL 92163 0 2
// repeat wait ( 0 0$1 ) ;
87708: LD_INT 35
87710: PPUSH
87711: CALL_OW 67
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
87715: LD_EXP 178
87719: PUSH
87720: LD_VAR 0 1
87724: ARRAY
87725: NOT
87726: PUSH
87727: LD_EXP 178
87731: PUSH
87732: LD_VAR 0 1
87736: ARRAY
87737: PUSH
87738: EMPTY
87739: EQUAL
87740: OR
87741: IFFALSE 87778
// begin for i in defenders do
87743: LD_ADDR_VAR 0 4
87747: PUSH
87748: LD_VAR 0 2
87752: PUSH
87753: FOR_IN
87754: IFFALSE 87767
// ComStop ( i ) ;
87756: LD_VAR 0 4
87760: PPUSH
87761: CALL_OW 141
87765: GO 87753
87767: POP
87768: POP
// defenders := [ ] ;
87769: LD_ADDR_VAR 0 2
87773: PUSH
87774: EMPTY
87775: ST_TO_ADDR
// exit ;
87776: GO 88004
// end ; for i in defenders do
87778: LD_ADDR_VAR 0 4
87782: PUSH
87783: LD_VAR 0 2
87787: PUSH
87788: FOR_IN
87789: IFFALSE 87878
// begin if not IsInArea ( i , mc_parking [ base ] ) then
87791: LD_VAR 0 4
87795: PPUSH
87796: LD_EXP 202
87800: PUSH
87801: LD_VAR 0 1
87805: ARRAY
87806: PPUSH
87807: CALL_OW 308
87811: NOT
87812: IFFALSE 87836
// ComMoveToArea ( i , mc_parking [ base ] ) else
87814: LD_VAR 0 4
87818: PPUSH
87819: LD_EXP 202
87823: PUSH
87824: LD_VAR 0 1
87828: ARRAY
87829: PPUSH
87830: CALL_OW 113
87834: GO 87876
// if GetControl ( i ) = control_manual then
87836: LD_VAR 0 4
87840: PPUSH
87841: CALL_OW 263
87845: PUSH
87846: LD_INT 1
87848: EQUAL
87849: IFFALSE 87876
// if IsDrivenBy ( i ) then
87851: LD_VAR 0 4
87855: PPUSH
87856: CALL_OW 311
87860: IFFALSE 87876
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
87862: LD_VAR 0 4
87866: PPUSH
87867: CALL_OW 311
87871: PPUSH
87872: CALL_OW 121
// end ;
87876: GO 87788
87878: POP
87879: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] or not mc_bases [ base ] ;
87880: LD_VAR 0 2
87884: PPUSH
87885: LD_INT 95
87887: PUSH
87888: LD_EXP 202
87892: PUSH
87893: LD_VAR 0 1
87897: ARRAY
87898: PUSH
87899: EMPTY
87900: LIST
87901: LIST
87902: PPUSH
87903: CALL_OW 72
87907: PUSH
87908: LD_VAR 0 2
87912: EQUAL
87913: PUSH
87914: LD_EXP 201
87918: PUSH
87919: LD_VAR 0 1
87923: ARRAY
87924: OR
87925: PUSH
87926: LD_EXP 178
87930: PUSH
87931: LD_VAR 0 1
87935: ARRAY
87936: NOT
87937: OR
87938: IFFALSE 87708
// end ; mc_defender := Replace ( mc_defender , base , UnitFilter ( defenders , [ f_type , unit_vehicle ] ) ) ;
87940: LD_ADDR_EXP 200
87944: PUSH
87945: LD_EXP 200
87949: PPUSH
87950: LD_VAR 0 1
87954: PPUSH
87955: LD_VAR 0 2
87959: PPUSH
87960: LD_INT 21
87962: PUSH
87963: LD_INT 2
87965: PUSH
87966: EMPTY
87967: LIST
87968: LIST
87969: PPUSH
87970: CALL_OW 72
87974: PPUSH
87975: CALL_OW 1
87979: ST_TO_ADDR
// MC_Reset ( base , 19 ) ;
87980: LD_VAR 0 1
87984: PPUSH
87985: LD_INT 19
87987: PPUSH
87988: CALL 92163 0 2
// MC_Reset ( base , 20 ) ;
87992: LD_VAR 0 1
87996: PPUSH
87997: LD_INT 20
87999: PPUSH
88000: CALL 92163 0 2
// end ; end_of_file
88004: LD_VAR 0 3
88008: RET
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use , mc_is_defending ; export function InitMacro ; var i ; begin
88009: LD_INT 0
88011: PPUSH
88012: PPUSH
// skirmish := false ;
88013: LD_ADDR_EXP 176
88017: PUSH
88018: LD_INT 0
88020: ST_TO_ADDR
// debug_mc := false ;
88021: LD_ADDR_EXP 177
88025: PUSH
88026: LD_INT 0
88028: ST_TO_ADDR
// mc_bases := [ ] ;
88029: LD_ADDR_EXP 178
88033: PUSH
88034: EMPTY
88035: ST_TO_ADDR
// mc_sides := [ ] ;
88036: LD_ADDR_EXP 204
88040: PUSH
88041: EMPTY
88042: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
88043: LD_ADDR_EXP 179
88047: PUSH
88048: EMPTY
88049: ST_TO_ADDR
// mc_building_repairs := [ ] ;
88050: LD_ADDR_EXP 180
88054: PUSH
88055: EMPTY
88056: ST_TO_ADDR
// mc_need_heal := [ ] ;
88057: LD_ADDR_EXP 181
88061: PUSH
88062: EMPTY
88063: ST_TO_ADDR
// mc_healers := [ ] ;
88064: LD_ADDR_EXP 182
88068: PUSH
88069: EMPTY
88070: ST_TO_ADDR
// mc_build_list := [ ] ;
88071: LD_ADDR_EXP 183
88075: PUSH
88076: EMPTY
88077: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
88078: LD_ADDR_EXP 210
88082: PUSH
88083: EMPTY
88084: ST_TO_ADDR
// mc_builders := [ ] ;
88085: LD_ADDR_EXP 184
88089: PUSH
88090: EMPTY
88091: ST_TO_ADDR
// mc_construct_list := [ ] ;
88092: LD_ADDR_EXP 185
88096: PUSH
88097: EMPTY
88098: ST_TO_ADDR
// mc_turret_list := [ ] ;
88099: LD_ADDR_EXP 186
88103: PUSH
88104: EMPTY
88105: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
88106: LD_ADDR_EXP 187
88110: PUSH
88111: EMPTY
88112: ST_TO_ADDR
// mc_miners := [ ] ;
88113: LD_ADDR_EXP 192
88117: PUSH
88118: EMPTY
88119: ST_TO_ADDR
// mc_mines := [ ] ;
88120: LD_ADDR_EXP 191
88124: PUSH
88125: EMPTY
88126: ST_TO_ADDR
// mc_minefields := [ ] ;
88127: LD_ADDR_EXP 193
88131: PUSH
88132: EMPTY
88133: ST_TO_ADDR
// mc_crates := [ ] ;
88134: LD_ADDR_EXP 194
88138: PUSH
88139: EMPTY
88140: ST_TO_ADDR
// mc_crates_collector := [ ] ;
88141: LD_ADDR_EXP 195
88145: PUSH
88146: EMPTY
88147: ST_TO_ADDR
// mc_crates_area := [ ] ;
88148: LD_ADDR_EXP 196
88152: PUSH
88153: EMPTY
88154: ST_TO_ADDR
// mc_vehicles := [ ] ;
88155: LD_ADDR_EXP 197
88159: PUSH
88160: EMPTY
88161: ST_TO_ADDR
// mc_attack := [ ] ;
88162: LD_ADDR_EXP 198
88166: PUSH
88167: EMPTY
88168: ST_TO_ADDR
// mc_produce := [ ] ;
88169: LD_ADDR_EXP 199
88173: PUSH
88174: EMPTY
88175: ST_TO_ADDR
// mc_defender := [ ] ;
88176: LD_ADDR_EXP 200
88180: PUSH
88181: EMPTY
88182: ST_TO_ADDR
// mc_parking := [ ] ;
88183: LD_ADDR_EXP 202
88187: PUSH
88188: EMPTY
88189: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
88190: LD_ADDR_EXP 188
88194: PUSH
88195: EMPTY
88196: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
88197: LD_ADDR_EXP 190
88201: PUSH
88202: EMPTY
88203: ST_TO_ADDR
// mc_scan := [ ] ;
88204: LD_ADDR_EXP 201
88208: PUSH
88209: EMPTY
88210: ST_TO_ADDR
// mc_scan_area := [ ] ;
88211: LD_ADDR_EXP 203
88215: PUSH
88216: EMPTY
88217: ST_TO_ADDR
// mc_tech := [ ] ;
88218: LD_ADDR_EXP 205
88222: PUSH
88223: EMPTY
88224: ST_TO_ADDR
// mc_class := [ ] ;
88225: LD_ADDR_EXP 219
88229: PUSH
88230: EMPTY
88231: ST_TO_ADDR
// mc_class_case_use := [ ] ;
88232: LD_ADDR_EXP 220
88236: PUSH
88237: EMPTY
88238: ST_TO_ADDR
// mc_is_defending := [ ] ;
88239: LD_ADDR_EXP 221
88243: PUSH
88244: EMPTY
88245: ST_TO_ADDR
// end ;
88246: LD_VAR 0 1
88250: RET
// export function MC_Kill ( base ) ; begin
88251: LD_INT 0
88253: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
88254: LD_ADDR_EXP 178
88258: PUSH
88259: LD_EXP 178
88263: PPUSH
88264: LD_VAR 0 1
88268: PPUSH
88269: EMPTY
88270: PPUSH
88271: CALL_OW 1
88275: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
88276: LD_ADDR_EXP 179
88280: PUSH
88281: LD_EXP 179
88285: PPUSH
88286: LD_VAR 0 1
88290: PPUSH
88291: EMPTY
88292: PPUSH
88293: CALL_OW 1
88297: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
88298: LD_ADDR_EXP 180
88302: PUSH
88303: LD_EXP 180
88307: PPUSH
88308: LD_VAR 0 1
88312: PPUSH
88313: EMPTY
88314: PPUSH
88315: CALL_OW 1
88319: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
88320: LD_ADDR_EXP 181
88324: PUSH
88325: LD_EXP 181
88329: PPUSH
88330: LD_VAR 0 1
88334: PPUSH
88335: EMPTY
88336: PPUSH
88337: CALL_OW 1
88341: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
88342: LD_ADDR_EXP 182
88346: PUSH
88347: LD_EXP 182
88351: PPUSH
88352: LD_VAR 0 1
88356: PPUSH
88357: EMPTY
88358: PPUSH
88359: CALL_OW 1
88363: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
88364: LD_ADDR_EXP 183
88368: PUSH
88369: LD_EXP 183
88373: PPUSH
88374: LD_VAR 0 1
88378: PPUSH
88379: EMPTY
88380: PPUSH
88381: CALL_OW 1
88385: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
88386: LD_ADDR_EXP 184
88390: PUSH
88391: LD_EXP 184
88395: PPUSH
88396: LD_VAR 0 1
88400: PPUSH
88401: EMPTY
88402: PPUSH
88403: CALL_OW 1
88407: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
88408: LD_ADDR_EXP 185
88412: PUSH
88413: LD_EXP 185
88417: PPUSH
88418: LD_VAR 0 1
88422: PPUSH
88423: EMPTY
88424: PPUSH
88425: CALL_OW 1
88429: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
88430: LD_ADDR_EXP 186
88434: PUSH
88435: LD_EXP 186
88439: PPUSH
88440: LD_VAR 0 1
88444: PPUSH
88445: EMPTY
88446: PPUSH
88447: CALL_OW 1
88451: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
88452: LD_ADDR_EXP 187
88456: PUSH
88457: LD_EXP 187
88461: PPUSH
88462: LD_VAR 0 1
88466: PPUSH
88467: EMPTY
88468: PPUSH
88469: CALL_OW 1
88473: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
88474: LD_ADDR_EXP 188
88478: PUSH
88479: LD_EXP 188
88483: PPUSH
88484: LD_VAR 0 1
88488: PPUSH
88489: EMPTY
88490: PPUSH
88491: CALL_OW 1
88495: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
88496: LD_ADDR_EXP 189
88500: PUSH
88501: LD_EXP 189
88505: PPUSH
88506: LD_VAR 0 1
88510: PPUSH
88511: LD_INT 0
88513: PPUSH
88514: CALL_OW 1
88518: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
88519: LD_ADDR_EXP 190
88523: PUSH
88524: LD_EXP 190
88528: PPUSH
88529: LD_VAR 0 1
88533: PPUSH
88534: EMPTY
88535: PPUSH
88536: CALL_OW 1
88540: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
88541: LD_ADDR_EXP 191
88545: PUSH
88546: LD_EXP 191
88550: PPUSH
88551: LD_VAR 0 1
88555: PPUSH
88556: EMPTY
88557: PPUSH
88558: CALL_OW 1
88562: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
88563: LD_ADDR_EXP 192
88567: PUSH
88568: LD_EXP 192
88572: PPUSH
88573: LD_VAR 0 1
88577: PPUSH
88578: EMPTY
88579: PPUSH
88580: CALL_OW 1
88584: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
88585: LD_ADDR_EXP 193
88589: PUSH
88590: LD_EXP 193
88594: PPUSH
88595: LD_VAR 0 1
88599: PPUSH
88600: EMPTY
88601: PPUSH
88602: CALL_OW 1
88606: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
88607: LD_ADDR_EXP 194
88611: PUSH
88612: LD_EXP 194
88616: PPUSH
88617: LD_VAR 0 1
88621: PPUSH
88622: EMPTY
88623: PPUSH
88624: CALL_OW 1
88628: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
88629: LD_ADDR_EXP 195
88633: PUSH
88634: LD_EXP 195
88638: PPUSH
88639: LD_VAR 0 1
88643: PPUSH
88644: EMPTY
88645: PPUSH
88646: CALL_OW 1
88650: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
88651: LD_ADDR_EXP 196
88655: PUSH
88656: LD_EXP 196
88660: PPUSH
88661: LD_VAR 0 1
88665: PPUSH
88666: EMPTY
88667: PPUSH
88668: CALL_OW 1
88672: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
88673: LD_ADDR_EXP 197
88677: PUSH
88678: LD_EXP 197
88682: PPUSH
88683: LD_VAR 0 1
88687: PPUSH
88688: EMPTY
88689: PPUSH
88690: CALL_OW 1
88694: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
88695: LD_ADDR_EXP 198
88699: PUSH
88700: LD_EXP 198
88704: PPUSH
88705: LD_VAR 0 1
88709: PPUSH
88710: EMPTY
88711: PPUSH
88712: CALL_OW 1
88716: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
88717: LD_ADDR_EXP 199
88721: PUSH
88722: LD_EXP 199
88726: PPUSH
88727: LD_VAR 0 1
88731: PPUSH
88732: EMPTY
88733: PPUSH
88734: CALL_OW 1
88738: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
88739: LD_ADDR_EXP 200
88743: PUSH
88744: LD_EXP 200
88748: PPUSH
88749: LD_VAR 0 1
88753: PPUSH
88754: EMPTY
88755: PPUSH
88756: CALL_OW 1
88760: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
88761: LD_ADDR_EXP 201
88765: PUSH
88766: LD_EXP 201
88770: PPUSH
88771: LD_VAR 0 1
88775: PPUSH
88776: EMPTY
88777: PPUSH
88778: CALL_OW 1
88782: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
88783: LD_ADDR_EXP 202
88787: PUSH
88788: LD_EXP 202
88792: PPUSH
88793: LD_VAR 0 1
88797: PPUSH
88798: EMPTY
88799: PPUSH
88800: CALL_OW 1
88804: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
88805: LD_ADDR_EXP 203
88809: PUSH
88810: LD_EXP 203
88814: PPUSH
88815: LD_VAR 0 1
88819: PPUSH
88820: EMPTY
88821: PPUSH
88822: CALL_OW 1
88826: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
88827: LD_ADDR_EXP 205
88831: PUSH
88832: LD_EXP 205
88836: PPUSH
88837: LD_VAR 0 1
88841: PPUSH
88842: EMPTY
88843: PPUSH
88844: CALL_OW 1
88848: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
88849: LD_ADDR_EXP 207
88853: PUSH
88854: LD_EXP 207
88858: PPUSH
88859: LD_VAR 0 1
88863: PPUSH
88864: EMPTY
88865: PPUSH
88866: CALL_OW 1
88870: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
88871: LD_ADDR_EXP 208
88875: PUSH
88876: LD_EXP 208
88880: PPUSH
88881: LD_VAR 0 1
88885: PPUSH
88886: EMPTY
88887: PPUSH
88888: CALL_OW 1
88892: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
88893: LD_ADDR_EXP 209
88897: PUSH
88898: LD_EXP 209
88902: PPUSH
88903: LD_VAR 0 1
88907: PPUSH
88908: EMPTY
88909: PPUSH
88910: CALL_OW 1
88914: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
88915: LD_ADDR_EXP 210
88919: PUSH
88920: LD_EXP 210
88924: PPUSH
88925: LD_VAR 0 1
88929: PPUSH
88930: EMPTY
88931: PPUSH
88932: CALL_OW 1
88936: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
88937: LD_ADDR_EXP 211
88941: PUSH
88942: LD_EXP 211
88946: PPUSH
88947: LD_VAR 0 1
88951: PPUSH
88952: EMPTY
88953: PPUSH
88954: CALL_OW 1
88958: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
88959: LD_ADDR_EXP 212
88963: PUSH
88964: LD_EXP 212
88968: PPUSH
88969: LD_VAR 0 1
88973: PPUSH
88974: EMPTY
88975: PPUSH
88976: CALL_OW 1
88980: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
88981: LD_ADDR_EXP 213
88985: PUSH
88986: LD_EXP 213
88990: PPUSH
88991: LD_VAR 0 1
88995: PPUSH
88996: EMPTY
88997: PPUSH
88998: CALL_OW 1
89002: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
89003: LD_ADDR_EXP 214
89007: PUSH
89008: LD_EXP 214
89012: PPUSH
89013: LD_VAR 0 1
89017: PPUSH
89018: EMPTY
89019: PPUSH
89020: CALL_OW 1
89024: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
89025: LD_ADDR_EXP 215
89029: PUSH
89030: LD_EXP 215
89034: PPUSH
89035: LD_VAR 0 1
89039: PPUSH
89040: EMPTY
89041: PPUSH
89042: CALL_OW 1
89046: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
89047: LD_ADDR_EXP 216
89051: PUSH
89052: LD_EXP 216
89056: PPUSH
89057: LD_VAR 0 1
89061: PPUSH
89062: EMPTY
89063: PPUSH
89064: CALL_OW 1
89068: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
89069: LD_ADDR_EXP 217
89073: PUSH
89074: LD_EXP 217
89078: PPUSH
89079: LD_VAR 0 1
89083: PPUSH
89084: EMPTY
89085: PPUSH
89086: CALL_OW 1
89090: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
89091: LD_ADDR_EXP 218
89095: PUSH
89096: LD_EXP 218
89100: PPUSH
89101: LD_VAR 0 1
89105: PPUSH
89106: EMPTY
89107: PPUSH
89108: CALL_OW 1
89112: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
89113: LD_ADDR_EXP 219
89117: PUSH
89118: LD_EXP 219
89122: PPUSH
89123: LD_VAR 0 1
89127: PPUSH
89128: EMPTY
89129: PPUSH
89130: CALL_OW 1
89134: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
89135: LD_ADDR_EXP 220
89139: PUSH
89140: LD_EXP 220
89144: PPUSH
89145: LD_VAR 0 1
89149: PPUSH
89150: LD_INT 0
89152: PPUSH
89153: CALL_OW 1
89157: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
89158: LD_ADDR_EXP 221
89162: PUSH
89163: LD_EXP 221
89167: PPUSH
89168: LD_VAR 0 1
89172: PPUSH
89173: LD_INT 0
89175: PPUSH
89176: CALL_OW 1
89180: ST_TO_ADDR
// end ;
89181: LD_VAR 0 2
89185: RET
// export function MC_Add ( side , units ) ; var base ; begin
89186: LD_INT 0
89188: PPUSH
89189: PPUSH
// base := mc_bases + 1 ;
89190: LD_ADDR_VAR 0 4
89194: PUSH
89195: LD_EXP 178
89199: PUSH
89200: LD_INT 1
89202: PLUS
89203: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
89204: LD_ADDR_EXP 204
89208: PUSH
89209: LD_EXP 204
89213: PPUSH
89214: LD_VAR 0 4
89218: PPUSH
89219: LD_VAR 0 1
89223: PPUSH
89224: CALL_OW 1
89228: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
89229: LD_ADDR_EXP 178
89233: PUSH
89234: LD_EXP 178
89238: PPUSH
89239: LD_VAR 0 4
89243: PPUSH
89244: LD_VAR 0 2
89248: PPUSH
89249: CALL_OW 1
89253: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
89254: LD_ADDR_EXP 179
89258: PUSH
89259: LD_EXP 179
89263: PPUSH
89264: LD_VAR 0 4
89268: PPUSH
89269: EMPTY
89270: PPUSH
89271: CALL_OW 1
89275: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
89276: LD_ADDR_EXP 180
89280: PUSH
89281: LD_EXP 180
89285: PPUSH
89286: LD_VAR 0 4
89290: PPUSH
89291: EMPTY
89292: PPUSH
89293: CALL_OW 1
89297: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
89298: LD_ADDR_EXP 181
89302: PUSH
89303: LD_EXP 181
89307: PPUSH
89308: LD_VAR 0 4
89312: PPUSH
89313: EMPTY
89314: PPUSH
89315: CALL_OW 1
89319: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
89320: LD_ADDR_EXP 182
89324: PUSH
89325: LD_EXP 182
89329: PPUSH
89330: LD_VAR 0 4
89334: PPUSH
89335: EMPTY
89336: PPUSH
89337: CALL_OW 1
89341: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
89342: LD_ADDR_EXP 183
89346: PUSH
89347: LD_EXP 183
89351: PPUSH
89352: LD_VAR 0 4
89356: PPUSH
89357: EMPTY
89358: PPUSH
89359: CALL_OW 1
89363: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
89364: LD_ADDR_EXP 184
89368: PUSH
89369: LD_EXP 184
89373: PPUSH
89374: LD_VAR 0 4
89378: PPUSH
89379: EMPTY
89380: PPUSH
89381: CALL_OW 1
89385: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
89386: LD_ADDR_EXP 185
89390: PUSH
89391: LD_EXP 185
89395: PPUSH
89396: LD_VAR 0 4
89400: PPUSH
89401: EMPTY
89402: PPUSH
89403: CALL_OW 1
89407: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
89408: LD_ADDR_EXP 186
89412: PUSH
89413: LD_EXP 186
89417: PPUSH
89418: LD_VAR 0 4
89422: PPUSH
89423: EMPTY
89424: PPUSH
89425: CALL_OW 1
89429: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
89430: LD_ADDR_EXP 187
89434: PUSH
89435: LD_EXP 187
89439: PPUSH
89440: LD_VAR 0 4
89444: PPUSH
89445: EMPTY
89446: PPUSH
89447: CALL_OW 1
89451: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
89452: LD_ADDR_EXP 188
89456: PUSH
89457: LD_EXP 188
89461: PPUSH
89462: LD_VAR 0 4
89466: PPUSH
89467: EMPTY
89468: PPUSH
89469: CALL_OW 1
89473: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
89474: LD_ADDR_EXP 189
89478: PUSH
89479: LD_EXP 189
89483: PPUSH
89484: LD_VAR 0 4
89488: PPUSH
89489: LD_INT 0
89491: PPUSH
89492: CALL_OW 1
89496: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
89497: LD_ADDR_EXP 190
89501: PUSH
89502: LD_EXP 190
89506: PPUSH
89507: LD_VAR 0 4
89511: PPUSH
89512: EMPTY
89513: PPUSH
89514: CALL_OW 1
89518: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
89519: LD_ADDR_EXP 191
89523: PUSH
89524: LD_EXP 191
89528: PPUSH
89529: LD_VAR 0 4
89533: PPUSH
89534: EMPTY
89535: PPUSH
89536: CALL_OW 1
89540: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
89541: LD_ADDR_EXP 192
89545: PUSH
89546: LD_EXP 192
89550: PPUSH
89551: LD_VAR 0 4
89555: PPUSH
89556: EMPTY
89557: PPUSH
89558: CALL_OW 1
89562: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
89563: LD_ADDR_EXP 193
89567: PUSH
89568: LD_EXP 193
89572: PPUSH
89573: LD_VAR 0 4
89577: PPUSH
89578: EMPTY
89579: PPUSH
89580: CALL_OW 1
89584: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
89585: LD_ADDR_EXP 194
89589: PUSH
89590: LD_EXP 194
89594: PPUSH
89595: LD_VAR 0 4
89599: PPUSH
89600: EMPTY
89601: PPUSH
89602: CALL_OW 1
89606: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
89607: LD_ADDR_EXP 195
89611: PUSH
89612: LD_EXP 195
89616: PPUSH
89617: LD_VAR 0 4
89621: PPUSH
89622: EMPTY
89623: PPUSH
89624: CALL_OW 1
89628: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
89629: LD_ADDR_EXP 196
89633: PUSH
89634: LD_EXP 196
89638: PPUSH
89639: LD_VAR 0 4
89643: PPUSH
89644: EMPTY
89645: PPUSH
89646: CALL_OW 1
89650: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
89651: LD_ADDR_EXP 197
89655: PUSH
89656: LD_EXP 197
89660: PPUSH
89661: LD_VAR 0 4
89665: PPUSH
89666: EMPTY
89667: PPUSH
89668: CALL_OW 1
89672: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
89673: LD_ADDR_EXP 198
89677: PUSH
89678: LD_EXP 198
89682: PPUSH
89683: LD_VAR 0 4
89687: PPUSH
89688: EMPTY
89689: PPUSH
89690: CALL_OW 1
89694: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
89695: LD_ADDR_EXP 199
89699: PUSH
89700: LD_EXP 199
89704: PPUSH
89705: LD_VAR 0 4
89709: PPUSH
89710: EMPTY
89711: PPUSH
89712: CALL_OW 1
89716: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
89717: LD_ADDR_EXP 200
89721: PUSH
89722: LD_EXP 200
89726: PPUSH
89727: LD_VAR 0 4
89731: PPUSH
89732: EMPTY
89733: PPUSH
89734: CALL_OW 1
89738: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
89739: LD_ADDR_EXP 201
89743: PUSH
89744: LD_EXP 201
89748: PPUSH
89749: LD_VAR 0 4
89753: PPUSH
89754: EMPTY
89755: PPUSH
89756: CALL_OW 1
89760: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
89761: LD_ADDR_EXP 202
89765: PUSH
89766: LD_EXP 202
89770: PPUSH
89771: LD_VAR 0 4
89775: PPUSH
89776: EMPTY
89777: PPUSH
89778: CALL_OW 1
89782: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
89783: LD_ADDR_EXP 203
89787: PUSH
89788: LD_EXP 203
89792: PPUSH
89793: LD_VAR 0 4
89797: PPUSH
89798: EMPTY
89799: PPUSH
89800: CALL_OW 1
89804: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
89805: LD_ADDR_EXP 205
89809: PUSH
89810: LD_EXP 205
89814: PPUSH
89815: LD_VAR 0 4
89819: PPUSH
89820: EMPTY
89821: PPUSH
89822: CALL_OW 1
89826: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
89827: LD_ADDR_EXP 207
89831: PUSH
89832: LD_EXP 207
89836: PPUSH
89837: LD_VAR 0 4
89841: PPUSH
89842: EMPTY
89843: PPUSH
89844: CALL_OW 1
89848: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
89849: LD_ADDR_EXP 208
89853: PUSH
89854: LD_EXP 208
89858: PPUSH
89859: LD_VAR 0 4
89863: PPUSH
89864: EMPTY
89865: PPUSH
89866: CALL_OW 1
89870: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
89871: LD_ADDR_EXP 209
89875: PUSH
89876: LD_EXP 209
89880: PPUSH
89881: LD_VAR 0 4
89885: PPUSH
89886: EMPTY
89887: PPUSH
89888: CALL_OW 1
89892: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
89893: LD_ADDR_EXP 210
89897: PUSH
89898: LD_EXP 210
89902: PPUSH
89903: LD_VAR 0 4
89907: PPUSH
89908: EMPTY
89909: PPUSH
89910: CALL_OW 1
89914: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
89915: LD_ADDR_EXP 211
89919: PUSH
89920: LD_EXP 211
89924: PPUSH
89925: LD_VAR 0 4
89929: PPUSH
89930: EMPTY
89931: PPUSH
89932: CALL_OW 1
89936: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
89937: LD_ADDR_EXP 212
89941: PUSH
89942: LD_EXP 212
89946: PPUSH
89947: LD_VAR 0 4
89951: PPUSH
89952: EMPTY
89953: PPUSH
89954: CALL_OW 1
89958: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
89959: LD_ADDR_EXP 213
89963: PUSH
89964: LD_EXP 213
89968: PPUSH
89969: LD_VAR 0 4
89973: PPUSH
89974: EMPTY
89975: PPUSH
89976: CALL_OW 1
89980: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
89981: LD_ADDR_EXP 214
89985: PUSH
89986: LD_EXP 214
89990: PPUSH
89991: LD_VAR 0 4
89995: PPUSH
89996: EMPTY
89997: PPUSH
89998: CALL_OW 1
90002: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
90003: LD_ADDR_EXP 215
90007: PUSH
90008: LD_EXP 215
90012: PPUSH
90013: LD_VAR 0 4
90017: PPUSH
90018: EMPTY
90019: PPUSH
90020: CALL_OW 1
90024: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
90025: LD_ADDR_EXP 216
90029: PUSH
90030: LD_EXP 216
90034: PPUSH
90035: LD_VAR 0 4
90039: PPUSH
90040: EMPTY
90041: PPUSH
90042: CALL_OW 1
90046: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
90047: LD_ADDR_EXP 217
90051: PUSH
90052: LD_EXP 217
90056: PPUSH
90057: LD_VAR 0 4
90061: PPUSH
90062: EMPTY
90063: PPUSH
90064: CALL_OW 1
90068: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
90069: LD_ADDR_EXP 218
90073: PUSH
90074: LD_EXP 218
90078: PPUSH
90079: LD_VAR 0 4
90083: PPUSH
90084: EMPTY
90085: PPUSH
90086: CALL_OW 1
90090: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
90091: LD_ADDR_EXP 219
90095: PUSH
90096: LD_EXP 219
90100: PPUSH
90101: LD_VAR 0 4
90105: PPUSH
90106: EMPTY
90107: PPUSH
90108: CALL_OW 1
90112: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
90113: LD_ADDR_EXP 220
90117: PUSH
90118: LD_EXP 220
90122: PPUSH
90123: LD_VAR 0 4
90127: PPUSH
90128: LD_INT 0
90130: PPUSH
90131: CALL_OW 1
90135: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
90136: LD_ADDR_EXP 221
90140: PUSH
90141: LD_EXP 221
90145: PPUSH
90146: LD_VAR 0 4
90150: PPUSH
90151: LD_INT 0
90153: PPUSH
90154: CALL_OW 1
90158: ST_TO_ADDR
// result := base ;
90159: LD_ADDR_VAR 0 3
90163: PUSH
90164: LD_VAR 0 4
90168: ST_TO_ADDR
// end ;
90169: LD_VAR 0 3
90173: RET
// export function MC_Start ( ) ; var i ; begin
90174: LD_INT 0
90176: PPUSH
90177: PPUSH
// for i = 1 to mc_bases do
90178: LD_ADDR_VAR 0 2
90182: PUSH
90183: DOUBLE
90184: LD_INT 1
90186: DEC
90187: ST_TO_ADDR
90188: LD_EXP 178
90192: PUSH
90193: FOR_TO
90194: IFFALSE 91294
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
90196: LD_ADDR_EXP 178
90200: PUSH
90201: LD_EXP 178
90205: PPUSH
90206: LD_VAR 0 2
90210: PPUSH
90211: LD_EXP 178
90215: PUSH
90216: LD_VAR 0 2
90220: ARRAY
90221: PUSH
90222: LD_INT 0
90224: DIFF
90225: PPUSH
90226: CALL_OW 1
90230: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
90231: LD_ADDR_EXP 179
90235: PUSH
90236: LD_EXP 179
90240: PPUSH
90241: LD_VAR 0 2
90245: PPUSH
90246: EMPTY
90247: PPUSH
90248: CALL_OW 1
90252: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
90253: LD_ADDR_EXP 180
90257: PUSH
90258: LD_EXP 180
90262: PPUSH
90263: LD_VAR 0 2
90267: PPUSH
90268: EMPTY
90269: PPUSH
90270: CALL_OW 1
90274: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
90275: LD_ADDR_EXP 181
90279: PUSH
90280: LD_EXP 181
90284: PPUSH
90285: LD_VAR 0 2
90289: PPUSH
90290: EMPTY
90291: PPUSH
90292: CALL_OW 1
90296: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
90297: LD_ADDR_EXP 182
90301: PUSH
90302: LD_EXP 182
90306: PPUSH
90307: LD_VAR 0 2
90311: PPUSH
90312: EMPTY
90313: PUSH
90314: EMPTY
90315: PUSH
90316: EMPTY
90317: LIST
90318: LIST
90319: PPUSH
90320: CALL_OW 1
90324: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
90325: LD_ADDR_EXP 183
90329: PUSH
90330: LD_EXP 183
90334: PPUSH
90335: LD_VAR 0 2
90339: PPUSH
90340: EMPTY
90341: PPUSH
90342: CALL_OW 1
90346: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
90347: LD_ADDR_EXP 210
90351: PUSH
90352: LD_EXP 210
90356: PPUSH
90357: LD_VAR 0 2
90361: PPUSH
90362: EMPTY
90363: PPUSH
90364: CALL_OW 1
90368: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
90369: LD_ADDR_EXP 184
90373: PUSH
90374: LD_EXP 184
90378: PPUSH
90379: LD_VAR 0 2
90383: PPUSH
90384: EMPTY
90385: PPUSH
90386: CALL_OW 1
90390: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
90391: LD_ADDR_EXP 185
90395: PUSH
90396: LD_EXP 185
90400: PPUSH
90401: LD_VAR 0 2
90405: PPUSH
90406: EMPTY
90407: PPUSH
90408: CALL_OW 1
90412: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
90413: LD_ADDR_EXP 186
90417: PUSH
90418: LD_EXP 186
90422: PPUSH
90423: LD_VAR 0 2
90427: PPUSH
90428: LD_EXP 178
90432: PUSH
90433: LD_VAR 0 2
90437: ARRAY
90438: PPUSH
90439: LD_INT 2
90441: PUSH
90442: LD_INT 30
90444: PUSH
90445: LD_INT 32
90447: PUSH
90448: EMPTY
90449: LIST
90450: LIST
90451: PUSH
90452: LD_INT 30
90454: PUSH
90455: LD_INT 33
90457: PUSH
90458: EMPTY
90459: LIST
90460: LIST
90461: PUSH
90462: EMPTY
90463: LIST
90464: LIST
90465: LIST
90466: PPUSH
90467: CALL_OW 72
90471: PPUSH
90472: CALL_OW 1
90476: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
90477: LD_ADDR_EXP 187
90481: PUSH
90482: LD_EXP 187
90486: PPUSH
90487: LD_VAR 0 2
90491: PPUSH
90492: LD_EXP 178
90496: PUSH
90497: LD_VAR 0 2
90501: ARRAY
90502: PPUSH
90503: LD_INT 2
90505: PUSH
90506: LD_INT 30
90508: PUSH
90509: LD_INT 32
90511: PUSH
90512: EMPTY
90513: LIST
90514: LIST
90515: PUSH
90516: LD_INT 30
90518: PUSH
90519: LD_INT 31
90521: PUSH
90522: EMPTY
90523: LIST
90524: LIST
90525: PUSH
90526: EMPTY
90527: LIST
90528: LIST
90529: LIST
90530: PUSH
90531: LD_INT 58
90533: PUSH
90534: EMPTY
90535: LIST
90536: PUSH
90537: EMPTY
90538: LIST
90539: LIST
90540: PPUSH
90541: CALL_OW 72
90545: PPUSH
90546: CALL_OW 1
90550: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
90551: LD_ADDR_EXP 188
90555: PUSH
90556: LD_EXP 188
90560: PPUSH
90561: LD_VAR 0 2
90565: PPUSH
90566: EMPTY
90567: PPUSH
90568: CALL_OW 1
90572: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
90573: LD_ADDR_EXP 192
90577: PUSH
90578: LD_EXP 192
90582: PPUSH
90583: LD_VAR 0 2
90587: PPUSH
90588: EMPTY
90589: PPUSH
90590: CALL_OW 1
90594: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
90595: LD_ADDR_EXP 191
90599: PUSH
90600: LD_EXP 191
90604: PPUSH
90605: LD_VAR 0 2
90609: PPUSH
90610: EMPTY
90611: PPUSH
90612: CALL_OW 1
90616: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
90617: LD_ADDR_EXP 193
90621: PUSH
90622: LD_EXP 193
90626: PPUSH
90627: LD_VAR 0 2
90631: PPUSH
90632: EMPTY
90633: PPUSH
90634: CALL_OW 1
90638: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
90639: LD_ADDR_EXP 194
90643: PUSH
90644: LD_EXP 194
90648: PPUSH
90649: LD_VAR 0 2
90653: PPUSH
90654: EMPTY
90655: PPUSH
90656: CALL_OW 1
90660: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
90661: LD_ADDR_EXP 195
90665: PUSH
90666: LD_EXP 195
90670: PPUSH
90671: LD_VAR 0 2
90675: PPUSH
90676: EMPTY
90677: PPUSH
90678: CALL_OW 1
90682: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
90683: LD_ADDR_EXP 196
90687: PUSH
90688: LD_EXP 196
90692: PPUSH
90693: LD_VAR 0 2
90697: PPUSH
90698: EMPTY
90699: PPUSH
90700: CALL_OW 1
90704: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
90705: LD_ADDR_EXP 197
90709: PUSH
90710: LD_EXP 197
90714: PPUSH
90715: LD_VAR 0 2
90719: PPUSH
90720: EMPTY
90721: PPUSH
90722: CALL_OW 1
90726: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
90727: LD_ADDR_EXP 198
90731: PUSH
90732: LD_EXP 198
90736: PPUSH
90737: LD_VAR 0 2
90741: PPUSH
90742: EMPTY
90743: PPUSH
90744: CALL_OW 1
90748: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
90749: LD_ADDR_EXP 199
90753: PUSH
90754: LD_EXP 199
90758: PPUSH
90759: LD_VAR 0 2
90763: PPUSH
90764: EMPTY
90765: PPUSH
90766: CALL_OW 1
90770: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
90771: LD_ADDR_EXP 200
90775: PUSH
90776: LD_EXP 200
90780: PPUSH
90781: LD_VAR 0 2
90785: PPUSH
90786: EMPTY
90787: PPUSH
90788: CALL_OW 1
90792: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
90793: LD_ADDR_EXP 189
90797: PUSH
90798: LD_EXP 189
90802: PPUSH
90803: LD_VAR 0 2
90807: PPUSH
90808: LD_INT 0
90810: PPUSH
90811: CALL_OW 1
90815: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
90816: LD_ADDR_EXP 202
90820: PUSH
90821: LD_EXP 202
90825: PPUSH
90826: LD_VAR 0 2
90830: PPUSH
90831: LD_INT 0
90833: PPUSH
90834: CALL_OW 1
90838: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
90839: LD_ADDR_EXP 190
90843: PUSH
90844: LD_EXP 190
90848: PPUSH
90849: LD_VAR 0 2
90853: PPUSH
90854: EMPTY
90855: PPUSH
90856: CALL_OW 1
90860: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
90861: LD_ADDR_EXP 201
90865: PUSH
90866: LD_EXP 201
90870: PPUSH
90871: LD_VAR 0 2
90875: PPUSH
90876: LD_INT 0
90878: PPUSH
90879: CALL_OW 1
90883: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
90884: LD_ADDR_EXP 203
90888: PUSH
90889: LD_EXP 203
90893: PPUSH
90894: LD_VAR 0 2
90898: PPUSH
90899: EMPTY
90900: PPUSH
90901: CALL_OW 1
90905: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
90906: LD_ADDR_EXP 206
90910: PUSH
90911: LD_EXP 206
90915: PPUSH
90916: LD_VAR 0 2
90920: PPUSH
90921: LD_INT 0
90923: PPUSH
90924: CALL_OW 1
90928: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
90929: LD_ADDR_EXP 207
90933: PUSH
90934: LD_EXP 207
90938: PPUSH
90939: LD_VAR 0 2
90943: PPUSH
90944: EMPTY
90945: PPUSH
90946: CALL_OW 1
90950: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
90951: LD_ADDR_EXP 208
90955: PUSH
90956: LD_EXP 208
90960: PPUSH
90961: LD_VAR 0 2
90965: PPUSH
90966: EMPTY
90967: PPUSH
90968: CALL_OW 1
90972: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
90973: LD_ADDR_EXP 209
90977: PUSH
90978: LD_EXP 209
90982: PPUSH
90983: LD_VAR 0 2
90987: PPUSH
90988: EMPTY
90989: PPUSH
90990: CALL_OW 1
90994: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
90995: LD_ADDR_EXP 211
90999: PUSH
91000: LD_EXP 211
91004: PPUSH
91005: LD_VAR 0 2
91009: PPUSH
91010: LD_EXP 178
91014: PUSH
91015: LD_VAR 0 2
91019: ARRAY
91020: PPUSH
91021: LD_INT 2
91023: PUSH
91024: LD_INT 30
91026: PUSH
91027: LD_INT 6
91029: PUSH
91030: EMPTY
91031: LIST
91032: LIST
91033: PUSH
91034: LD_INT 30
91036: PUSH
91037: LD_INT 7
91039: PUSH
91040: EMPTY
91041: LIST
91042: LIST
91043: PUSH
91044: LD_INT 30
91046: PUSH
91047: LD_INT 8
91049: PUSH
91050: EMPTY
91051: LIST
91052: LIST
91053: PUSH
91054: EMPTY
91055: LIST
91056: LIST
91057: LIST
91058: LIST
91059: PPUSH
91060: CALL_OW 72
91064: PPUSH
91065: CALL_OW 1
91069: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
91070: LD_ADDR_EXP 212
91074: PUSH
91075: LD_EXP 212
91079: PPUSH
91080: LD_VAR 0 2
91084: PPUSH
91085: EMPTY
91086: PPUSH
91087: CALL_OW 1
91091: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
91092: LD_ADDR_EXP 213
91096: PUSH
91097: LD_EXP 213
91101: PPUSH
91102: LD_VAR 0 2
91106: PPUSH
91107: EMPTY
91108: PPUSH
91109: CALL_OW 1
91113: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
91114: LD_ADDR_EXP 214
91118: PUSH
91119: LD_EXP 214
91123: PPUSH
91124: LD_VAR 0 2
91128: PPUSH
91129: EMPTY
91130: PPUSH
91131: CALL_OW 1
91135: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
91136: LD_ADDR_EXP 215
91140: PUSH
91141: LD_EXP 215
91145: PPUSH
91146: LD_VAR 0 2
91150: PPUSH
91151: EMPTY
91152: PPUSH
91153: CALL_OW 1
91157: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
91158: LD_ADDR_EXP 216
91162: PUSH
91163: LD_EXP 216
91167: PPUSH
91168: LD_VAR 0 2
91172: PPUSH
91173: EMPTY
91174: PPUSH
91175: CALL_OW 1
91179: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
91180: LD_ADDR_EXP 217
91184: PUSH
91185: LD_EXP 217
91189: PPUSH
91190: LD_VAR 0 2
91194: PPUSH
91195: EMPTY
91196: PPUSH
91197: CALL_OW 1
91201: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
91202: LD_ADDR_EXP 218
91206: PUSH
91207: LD_EXP 218
91211: PPUSH
91212: LD_VAR 0 2
91216: PPUSH
91217: EMPTY
91218: PPUSH
91219: CALL_OW 1
91223: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
91224: LD_ADDR_EXP 219
91228: PUSH
91229: LD_EXP 219
91233: PPUSH
91234: LD_VAR 0 2
91238: PPUSH
91239: EMPTY
91240: PPUSH
91241: CALL_OW 1
91245: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
91246: LD_ADDR_EXP 220
91250: PUSH
91251: LD_EXP 220
91255: PPUSH
91256: LD_VAR 0 2
91260: PPUSH
91261: LD_INT 0
91263: PPUSH
91264: CALL_OW 1
91268: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , i , false ) ;
91269: LD_ADDR_EXP 221
91273: PUSH
91274: LD_EXP 221
91278: PPUSH
91279: LD_VAR 0 2
91283: PPUSH
91284: LD_INT 0
91286: PPUSH
91287: CALL_OW 1
91291: ST_TO_ADDR
// end ;
91292: GO 90193
91294: POP
91295: POP
// MC_InitSides ( ) ;
91296: CALL 91582 0 0
// MC_InitResearch ( ) ;
91300: CALL 91321 0 0
// CustomInitMacro ( ) ;
91304: CALL 350 0 0
// skirmish := true ;
91308: LD_ADDR_EXP 176
91312: PUSH
91313: LD_INT 1
91315: ST_TO_ADDR
// end ;
91316: LD_VAR 0 1
91320: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
91321: LD_INT 0
91323: PPUSH
91324: PPUSH
91325: PPUSH
91326: PPUSH
91327: PPUSH
91328: PPUSH
// if not mc_bases then
91329: LD_EXP 178
91333: NOT
91334: IFFALSE 91338
// exit ;
91336: GO 91577
// for i = 1 to 8 do
91338: LD_ADDR_VAR 0 2
91342: PUSH
91343: DOUBLE
91344: LD_INT 1
91346: DEC
91347: ST_TO_ADDR
91348: LD_INT 8
91350: PUSH
91351: FOR_TO
91352: IFFALSE 91378
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
91354: LD_ADDR_EXP 205
91358: PUSH
91359: LD_EXP 205
91363: PPUSH
91364: LD_VAR 0 2
91368: PPUSH
91369: EMPTY
91370: PPUSH
91371: CALL_OW 1
91375: ST_TO_ADDR
91376: GO 91351
91378: POP
91379: POP
// tmp := [ ] ;
91380: LD_ADDR_VAR 0 5
91384: PUSH
91385: EMPTY
91386: ST_TO_ADDR
// for i = 1 to mc_sides do
91387: LD_ADDR_VAR 0 2
91391: PUSH
91392: DOUBLE
91393: LD_INT 1
91395: DEC
91396: ST_TO_ADDR
91397: LD_EXP 204
91401: PUSH
91402: FOR_TO
91403: IFFALSE 91461
// if not mc_sides [ i ] in tmp then
91405: LD_EXP 204
91409: PUSH
91410: LD_VAR 0 2
91414: ARRAY
91415: PUSH
91416: LD_VAR 0 5
91420: IN
91421: NOT
91422: IFFALSE 91459
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
91424: LD_ADDR_VAR 0 5
91428: PUSH
91429: LD_VAR 0 5
91433: PPUSH
91434: LD_VAR 0 5
91438: PUSH
91439: LD_INT 1
91441: PLUS
91442: PPUSH
91443: LD_EXP 204
91447: PUSH
91448: LD_VAR 0 2
91452: ARRAY
91453: PPUSH
91454: CALL_OW 2
91458: ST_TO_ADDR
91459: GO 91402
91461: POP
91462: POP
// if not tmp then
91463: LD_VAR 0 5
91467: NOT
91468: IFFALSE 91472
// exit ;
91470: GO 91577
// for j in tmp do
91472: LD_ADDR_VAR 0 3
91476: PUSH
91477: LD_VAR 0 5
91481: PUSH
91482: FOR_IN
91483: IFFALSE 91575
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
91485: LD_ADDR_VAR 0 6
91489: PUSH
91490: LD_INT 22
91492: PUSH
91493: LD_VAR 0 3
91497: PUSH
91498: EMPTY
91499: LIST
91500: LIST
91501: PPUSH
91502: CALL_OW 69
91506: ST_TO_ADDR
// if not un then
91507: LD_VAR 0 6
91511: NOT
91512: IFFALSE 91516
// continue ;
91514: GO 91482
// nation := GetNation ( un [ 1 ] ) ;
91516: LD_ADDR_VAR 0 4
91520: PUSH
91521: LD_VAR 0 6
91525: PUSH
91526: LD_INT 1
91528: ARRAY
91529: PPUSH
91530: CALL_OW 248
91534: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
91535: LD_ADDR_EXP 205
91539: PUSH
91540: LD_EXP 205
91544: PPUSH
91545: LD_VAR 0 3
91549: PPUSH
91550: LD_VAR 0 3
91554: PPUSH
91555: LD_VAR 0 4
91559: PPUSH
91560: LD_INT 1
91562: PPUSH
91563: CALL 19287 0 3
91567: PPUSH
91568: CALL_OW 1
91572: ST_TO_ADDR
// end ;
91573: GO 91482
91575: POP
91576: POP
// end ;
91577: LD_VAR 0 1
91581: RET
// export function MC_InitSides ( ) ; var i ; begin
91582: LD_INT 0
91584: PPUSH
91585: PPUSH
// if not mc_bases then
91586: LD_EXP 178
91590: NOT
91591: IFFALSE 91595
// exit ;
91593: GO 91669
// for i = 1 to mc_bases do
91595: LD_ADDR_VAR 0 2
91599: PUSH
91600: DOUBLE
91601: LD_INT 1
91603: DEC
91604: ST_TO_ADDR
91605: LD_EXP 178
91609: PUSH
91610: FOR_TO
91611: IFFALSE 91667
// if mc_bases [ i ] then
91613: LD_EXP 178
91617: PUSH
91618: LD_VAR 0 2
91622: ARRAY
91623: IFFALSE 91665
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
91625: LD_ADDR_EXP 204
91629: PUSH
91630: LD_EXP 204
91634: PPUSH
91635: LD_VAR 0 2
91639: PPUSH
91640: LD_EXP 178
91644: PUSH
91645: LD_VAR 0 2
91649: ARRAY
91650: PUSH
91651: LD_INT 1
91653: ARRAY
91654: PPUSH
91655: CALL_OW 255
91659: PPUSH
91660: CALL_OW 1
91664: ST_TO_ADDR
91665: GO 91610
91667: POP
91668: POP
// end ;
91669: LD_VAR 0 1
91673: RET
// every 0 0$03 trigger skirmish do
91674: LD_EXP 176
91678: IFFALSE 91832
91680: GO 91682
91682: DISABLE
// begin enable ;
91683: ENABLE
// MC_CheckBuildings ( ) ;
91684: CALL 96330 0 0
// MC_CheckPeopleLife ( ) ;
91688: CALL 96491 0 0
// RaiseSailEvent ( 100 ) ;
91692: LD_INT 100
91694: PPUSH
91695: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
91699: LD_INT 103
91701: PPUSH
91702: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
91706: LD_INT 104
91708: PPUSH
91709: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
91713: LD_INT 105
91715: PPUSH
91716: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
91720: LD_INT 106
91722: PPUSH
91723: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
91727: LD_INT 107
91729: PPUSH
91730: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
91734: LD_INT 108
91736: PPUSH
91737: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
91741: LD_INT 109
91743: PPUSH
91744: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
91748: LD_INT 110
91750: PPUSH
91751: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
91755: LD_INT 111
91757: PPUSH
91758: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
91762: LD_INT 112
91764: PPUSH
91765: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
91769: LD_INT 113
91771: PPUSH
91772: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
91776: LD_INT 120
91778: PPUSH
91779: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
91783: LD_INT 121
91785: PPUSH
91786: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
91790: LD_INT 122
91792: PPUSH
91793: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
91797: LD_INT 123
91799: PPUSH
91800: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
91804: LD_INT 124
91806: PPUSH
91807: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
91811: LD_INT 125
91813: PPUSH
91814: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
91818: LD_INT 126
91820: PPUSH
91821: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
91825: LD_INT 200
91827: PPUSH
91828: CALL_OW 427
// end ;
91832: END
// on SailEvent ( event ) do begin if event < 100 then
91833: LD_VAR 0 1
91837: PUSH
91838: LD_INT 100
91840: LESS
91841: IFFALSE 91852
// CustomEvent ( event ) ;
91843: LD_VAR 0 1
91847: PPUSH
91848: CALL 16158 0 1
// if event = 100 then
91852: LD_VAR 0 1
91856: PUSH
91857: LD_INT 100
91859: EQUAL
91860: IFFALSE 91866
// MC_ClassManager ( ) ;
91862: CALL 92258 0 0
// if event = 101 then
91866: LD_VAR 0 1
91870: PUSH
91871: LD_INT 101
91873: EQUAL
91874: IFFALSE 91880
// MC_RepairBuildings ( ) ;
91876: CALL 97076 0 0
// if event = 102 then
91880: LD_VAR 0 1
91884: PUSH
91885: LD_INT 102
91887: EQUAL
91888: IFFALSE 91894
// MC_Heal ( ) ;
91890: CALL 97983 0 0
// if event = 103 then
91894: LD_VAR 0 1
91898: PUSH
91899: LD_INT 103
91901: EQUAL
91902: IFFALSE 91908
// MC_Build ( ) ;
91904: CALL 98405 0 0
// if event = 104 then
91908: LD_VAR 0 1
91912: PUSH
91913: LD_INT 104
91915: EQUAL
91916: IFFALSE 91922
// MC_TurretWeapon ( ) ;
91918: CALL 100046 0 0
// if event = 105 then
91922: LD_VAR 0 1
91926: PUSH
91927: LD_INT 105
91929: EQUAL
91930: IFFALSE 91936
// MC_BuildUpgrade ( ) ;
91932: CALL 99597 0 0
// if event = 106 then
91936: LD_VAR 0 1
91940: PUSH
91941: LD_INT 106
91943: EQUAL
91944: IFFALSE 91950
// MC_PlantMines ( ) ;
91946: CALL 100476 0 0
// if event = 107 then
91950: LD_VAR 0 1
91954: PUSH
91955: LD_INT 107
91957: EQUAL
91958: IFFALSE 91964
// MC_CollectCrates ( ) ;
91960: CALL 101267 0 0
// if event = 108 then
91964: LD_VAR 0 1
91968: PUSH
91969: LD_INT 108
91971: EQUAL
91972: IFFALSE 91978
// MC_LinkRemoteControl ( ) ;
91974: CALL 103117 0 0
// if event = 109 then
91978: LD_VAR 0 1
91982: PUSH
91983: LD_INT 109
91985: EQUAL
91986: IFFALSE 91992
// MC_ProduceVehicle ( ) ;
91988: CALL 103298 0 0
// if event = 110 then
91992: LD_VAR 0 1
91996: PUSH
91997: LD_INT 110
91999: EQUAL
92000: IFFALSE 92006
// MC_SendAttack ( ) ;
92002: CALL 103764 0 0
// if event = 111 then
92006: LD_VAR 0 1
92010: PUSH
92011: LD_INT 111
92013: EQUAL
92014: IFFALSE 92020
// MC_Defend ( ) ;
92016: CALL 103872 0 0
// if event = 112 then
92020: LD_VAR 0 1
92024: PUSH
92025: LD_INT 112
92027: EQUAL
92028: IFFALSE 92034
// MC_Research ( ) ;
92030: CALL 104752 0 0
// if event = 113 then
92034: LD_VAR 0 1
92038: PUSH
92039: LD_INT 113
92041: EQUAL
92042: IFFALSE 92048
// MC_MinesTrigger ( ) ;
92044: CALL 105866 0 0
// if event = 120 then
92048: LD_VAR 0 1
92052: PUSH
92053: LD_INT 120
92055: EQUAL
92056: IFFALSE 92062
// MC_RepairVehicle ( ) ;
92058: CALL 105965 0 0
// if event = 121 then
92062: LD_VAR 0 1
92066: PUSH
92067: LD_INT 121
92069: EQUAL
92070: IFFALSE 92076
// MC_TameApe ( ) ;
92072: CALL 106706 0 0
// if event = 122 then
92076: LD_VAR 0 1
92080: PUSH
92081: LD_INT 122
92083: EQUAL
92084: IFFALSE 92090
// MC_ChangeApeClass ( ) ;
92086: CALL 107535 0 0
// if event = 123 then
92090: LD_VAR 0 1
92094: PUSH
92095: LD_INT 123
92097: EQUAL
92098: IFFALSE 92104
// MC_Bazooka ( ) ;
92100: CALL 108185 0 0
// if event = 124 then
92104: LD_VAR 0 1
92108: PUSH
92109: LD_INT 124
92111: EQUAL
92112: IFFALSE 92118
// MC_TeleportExit ( ) ;
92114: CALL 108383 0 0
// if event = 125 then
92118: LD_VAR 0 1
92122: PUSH
92123: LD_INT 125
92125: EQUAL
92126: IFFALSE 92132
// MC_Deposits ( ) ;
92128: CALL 109030 0 0
// if event = 126 then
92132: LD_VAR 0 1
92136: PUSH
92137: LD_INT 126
92139: EQUAL
92140: IFFALSE 92146
// MC_RemoteDriver ( ) ;
92142: CALL 109655 0 0
// if event = 200 then
92146: LD_VAR 0 1
92150: PUSH
92151: LD_INT 200
92153: EQUAL
92154: IFFALSE 92160
// MC_Idle ( ) ;
92156: CALL 111604 0 0
// end ;
92160: PPOPN 1
92162: END
// export function MC_Reset ( base , tag ) ; var i ; begin
92163: LD_INT 0
92165: PPUSH
92166: PPUSH
// if not mc_bases [ base ] or not tag then
92167: LD_EXP 178
92171: PUSH
92172: LD_VAR 0 1
92176: ARRAY
92177: NOT
92178: PUSH
92179: LD_VAR 0 2
92183: NOT
92184: OR
92185: IFFALSE 92189
// exit ;
92187: GO 92253
// for i in mc_bases [ base ] union mc_ape [ base ] do
92189: LD_ADDR_VAR 0 4
92193: PUSH
92194: LD_EXP 178
92198: PUSH
92199: LD_VAR 0 1
92203: ARRAY
92204: PUSH
92205: LD_EXP 207
92209: PUSH
92210: LD_VAR 0 1
92214: ARRAY
92215: UNION
92216: PUSH
92217: FOR_IN
92218: IFFALSE 92251
// if GetTag ( i ) = tag then
92220: LD_VAR 0 4
92224: PPUSH
92225: CALL_OW 110
92229: PUSH
92230: LD_VAR 0 2
92234: EQUAL
92235: IFFALSE 92249
// SetTag ( i , 0 ) ;
92237: LD_VAR 0 4
92241: PPUSH
92242: LD_INT 0
92244: PPUSH
92245: CALL_OW 109
92249: GO 92217
92251: POP
92252: POP
// end ;
92253: LD_VAR 0 3
92257: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
92258: LD_INT 0
92260: PPUSH
92261: PPUSH
92262: PPUSH
92263: PPUSH
92264: PPUSH
92265: PPUSH
92266: PPUSH
92267: PPUSH
// if not mc_bases then
92268: LD_EXP 178
92272: NOT
92273: IFFALSE 92277
// exit ;
92275: GO 92735
// for i = 1 to mc_bases do
92277: LD_ADDR_VAR 0 2
92281: PUSH
92282: DOUBLE
92283: LD_INT 1
92285: DEC
92286: ST_TO_ADDR
92287: LD_EXP 178
92291: PUSH
92292: FOR_TO
92293: IFFALSE 92733
// begin tmp := MC_ClassCheckReq ( i ) ;
92295: LD_ADDR_VAR 0 4
92299: PUSH
92300: LD_VAR 0 2
92304: PPUSH
92305: CALL 92740 0 1
92309: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
92310: LD_ADDR_EXP 219
92314: PUSH
92315: LD_EXP 219
92319: PPUSH
92320: LD_VAR 0 2
92324: PPUSH
92325: LD_VAR 0 4
92329: PPUSH
92330: CALL_OW 1
92334: ST_TO_ADDR
// if not tmp then
92335: LD_VAR 0 4
92339: NOT
92340: IFFALSE 92344
// continue ;
92342: GO 92292
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
92344: LD_ADDR_VAR 0 6
92348: PUSH
92349: LD_EXP 178
92353: PUSH
92354: LD_VAR 0 2
92358: ARRAY
92359: PPUSH
92360: LD_INT 2
92362: PUSH
92363: LD_INT 30
92365: PUSH
92366: LD_INT 4
92368: PUSH
92369: EMPTY
92370: LIST
92371: LIST
92372: PUSH
92373: LD_INT 30
92375: PUSH
92376: LD_INT 5
92378: PUSH
92379: EMPTY
92380: LIST
92381: LIST
92382: PUSH
92383: EMPTY
92384: LIST
92385: LIST
92386: LIST
92387: PPUSH
92388: CALL_OW 72
92392: PUSH
92393: LD_EXP 178
92397: PUSH
92398: LD_VAR 0 2
92402: ARRAY
92403: PPUSH
92404: LD_INT 2
92406: PUSH
92407: LD_INT 30
92409: PUSH
92410: LD_INT 0
92412: PUSH
92413: EMPTY
92414: LIST
92415: LIST
92416: PUSH
92417: LD_INT 30
92419: PUSH
92420: LD_INT 1
92422: PUSH
92423: EMPTY
92424: LIST
92425: LIST
92426: PUSH
92427: EMPTY
92428: LIST
92429: LIST
92430: LIST
92431: PPUSH
92432: CALL_OW 72
92436: PUSH
92437: LD_EXP 178
92441: PUSH
92442: LD_VAR 0 2
92446: ARRAY
92447: PPUSH
92448: LD_INT 30
92450: PUSH
92451: LD_INT 3
92453: PUSH
92454: EMPTY
92455: LIST
92456: LIST
92457: PPUSH
92458: CALL_OW 72
92462: PUSH
92463: LD_EXP 178
92467: PUSH
92468: LD_VAR 0 2
92472: ARRAY
92473: PPUSH
92474: LD_INT 2
92476: PUSH
92477: LD_INT 30
92479: PUSH
92480: LD_INT 6
92482: PUSH
92483: EMPTY
92484: LIST
92485: LIST
92486: PUSH
92487: LD_INT 30
92489: PUSH
92490: LD_INT 7
92492: PUSH
92493: EMPTY
92494: LIST
92495: LIST
92496: PUSH
92497: LD_INT 30
92499: PUSH
92500: LD_INT 8
92502: PUSH
92503: EMPTY
92504: LIST
92505: LIST
92506: PUSH
92507: EMPTY
92508: LIST
92509: LIST
92510: LIST
92511: LIST
92512: PPUSH
92513: CALL_OW 72
92517: PUSH
92518: EMPTY
92519: LIST
92520: LIST
92521: LIST
92522: LIST
92523: ST_TO_ADDR
// for j = 1 to 4 do
92524: LD_ADDR_VAR 0 3
92528: PUSH
92529: DOUBLE
92530: LD_INT 1
92532: DEC
92533: ST_TO_ADDR
92534: LD_INT 4
92536: PUSH
92537: FOR_TO
92538: IFFALSE 92729
// begin if not tmp [ j ] then
92540: LD_VAR 0 4
92544: PUSH
92545: LD_VAR 0 3
92549: ARRAY
92550: NOT
92551: IFFALSE 92555
// continue ;
92553: GO 92537
// for p in tmp [ j ] do
92555: LD_ADDR_VAR 0 5
92559: PUSH
92560: LD_VAR 0 4
92564: PUSH
92565: LD_VAR 0 3
92569: ARRAY
92570: PUSH
92571: FOR_IN
92572: IFFALSE 92725
// begin if not b [ j ] then
92574: LD_VAR 0 6
92578: PUSH
92579: LD_VAR 0 3
92583: ARRAY
92584: NOT
92585: IFFALSE 92589
// break ;
92587: GO 92725
// e := 0 ;
92589: LD_ADDR_VAR 0 7
92593: PUSH
92594: LD_INT 0
92596: ST_TO_ADDR
// for k in b [ j ] do
92597: LD_ADDR_VAR 0 8
92601: PUSH
92602: LD_VAR 0 6
92606: PUSH
92607: LD_VAR 0 3
92611: ARRAY
92612: PUSH
92613: FOR_IN
92614: IFFALSE 92641
// if IsNotFull ( k ) then
92616: LD_VAR 0 8
92620: PPUSH
92621: CALL 21440 0 1
92625: IFFALSE 92639
// begin e := k ;
92627: LD_ADDR_VAR 0 7
92631: PUSH
92632: LD_VAR 0 8
92636: ST_TO_ADDR
// break ;
92637: GO 92641
// end ;
92639: GO 92613
92641: POP
92642: POP
// if e and not UnitGoingToBuilding ( p , e ) then
92643: LD_VAR 0 7
92647: PUSH
92648: LD_VAR 0 5
92652: PPUSH
92653: LD_VAR 0 7
92657: PPUSH
92658: CALL 55254 0 2
92662: NOT
92663: AND
92664: IFFALSE 92723
// begin if IsInUnit ( p ) then
92666: LD_VAR 0 5
92670: PPUSH
92671: CALL_OW 310
92675: IFFALSE 92686
// ComExitBuilding ( p ) ;
92677: LD_VAR 0 5
92681: PPUSH
92682: CALL_OW 122
// ComEnterUnit ( p , e ) ;
92686: LD_VAR 0 5
92690: PPUSH
92691: LD_VAR 0 7
92695: PPUSH
92696: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
92700: LD_VAR 0 5
92704: PPUSH
92705: LD_VAR 0 3
92709: PPUSH
92710: CALL_OW 183
// AddComExitBuilding ( p ) ;
92714: LD_VAR 0 5
92718: PPUSH
92719: CALL_OW 182
// end ; end ;
92723: GO 92571
92725: POP
92726: POP
// end ;
92727: GO 92537
92729: POP
92730: POP
// end ;
92731: GO 92292
92733: POP
92734: POP
// end ;
92735: LD_VAR 0 1
92739: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
92740: LD_INT 0
92742: PPUSH
92743: PPUSH
92744: PPUSH
92745: PPUSH
92746: PPUSH
92747: PPUSH
92748: PPUSH
92749: PPUSH
92750: PPUSH
92751: PPUSH
92752: PPUSH
92753: PPUSH
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
92754: LD_VAR 0 1
92758: NOT
92759: PUSH
92760: LD_EXP 178
92764: PUSH
92765: LD_VAR 0 1
92769: ARRAY
92770: NOT
92771: OR
92772: PUSH
92773: LD_EXP 178
92777: PUSH
92778: LD_VAR 0 1
92782: ARRAY
92783: PPUSH
92784: LD_INT 2
92786: PUSH
92787: LD_INT 30
92789: PUSH
92790: LD_INT 0
92792: PUSH
92793: EMPTY
92794: LIST
92795: LIST
92796: PUSH
92797: LD_INT 30
92799: PUSH
92800: LD_INT 1
92802: PUSH
92803: EMPTY
92804: LIST
92805: LIST
92806: PUSH
92807: EMPTY
92808: LIST
92809: LIST
92810: LIST
92811: PPUSH
92812: CALL_OW 72
92816: NOT
92817: OR
92818: IFFALSE 92822
// exit ;
92820: GO 96325
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
92822: LD_ADDR_VAR 0 4
92826: PUSH
92827: LD_EXP 178
92831: PUSH
92832: LD_VAR 0 1
92836: ARRAY
92837: PPUSH
92838: LD_INT 2
92840: PUSH
92841: LD_INT 25
92843: PUSH
92844: LD_INT 1
92846: PUSH
92847: EMPTY
92848: LIST
92849: LIST
92850: PUSH
92851: LD_INT 25
92853: PUSH
92854: LD_INT 2
92856: PUSH
92857: EMPTY
92858: LIST
92859: LIST
92860: PUSH
92861: LD_INT 25
92863: PUSH
92864: LD_INT 3
92866: PUSH
92867: EMPTY
92868: LIST
92869: LIST
92870: PUSH
92871: LD_INT 25
92873: PUSH
92874: LD_INT 4
92876: PUSH
92877: EMPTY
92878: LIST
92879: LIST
92880: PUSH
92881: LD_INT 25
92883: PUSH
92884: LD_INT 5
92886: PUSH
92887: EMPTY
92888: LIST
92889: LIST
92890: PUSH
92891: LD_INT 25
92893: PUSH
92894: LD_INT 8
92896: PUSH
92897: EMPTY
92898: LIST
92899: LIST
92900: PUSH
92901: LD_INT 25
92903: PUSH
92904: LD_INT 9
92906: PUSH
92907: EMPTY
92908: LIST
92909: LIST
92910: PUSH
92911: EMPTY
92912: LIST
92913: LIST
92914: LIST
92915: LIST
92916: LIST
92917: LIST
92918: LIST
92919: LIST
92920: PPUSH
92921: CALL_OW 72
92925: ST_TO_ADDR
// if not tmp then
92926: LD_VAR 0 4
92930: NOT
92931: IFFALSE 92935
// exit ;
92933: GO 96325
// for i in tmp do
92935: LD_ADDR_VAR 0 3
92939: PUSH
92940: LD_VAR 0 4
92944: PUSH
92945: FOR_IN
92946: IFFALSE 92977
// if GetTag ( i ) then
92948: LD_VAR 0 3
92952: PPUSH
92953: CALL_OW 110
92957: IFFALSE 92975
// tmp := tmp diff i ;
92959: LD_ADDR_VAR 0 4
92963: PUSH
92964: LD_VAR 0 4
92968: PUSH
92969: LD_VAR 0 3
92973: DIFF
92974: ST_TO_ADDR
92975: GO 92945
92977: POP
92978: POP
// if not tmp then
92979: LD_VAR 0 4
92983: NOT
92984: IFFALSE 92988
// exit ;
92986: GO 96325
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
92988: LD_ADDR_VAR 0 5
92992: PUSH
92993: LD_EXP 178
92997: PUSH
92998: LD_VAR 0 1
93002: ARRAY
93003: PPUSH
93004: LD_INT 2
93006: PUSH
93007: LD_INT 25
93009: PUSH
93010: LD_INT 1
93012: PUSH
93013: EMPTY
93014: LIST
93015: LIST
93016: PUSH
93017: LD_INT 25
93019: PUSH
93020: LD_INT 5
93022: PUSH
93023: EMPTY
93024: LIST
93025: LIST
93026: PUSH
93027: LD_INT 25
93029: PUSH
93030: LD_INT 8
93032: PUSH
93033: EMPTY
93034: LIST
93035: LIST
93036: PUSH
93037: LD_INT 25
93039: PUSH
93040: LD_INT 9
93042: PUSH
93043: EMPTY
93044: LIST
93045: LIST
93046: PUSH
93047: EMPTY
93048: LIST
93049: LIST
93050: LIST
93051: LIST
93052: LIST
93053: PPUSH
93054: CALL_OW 72
93058: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
93059: LD_ADDR_VAR 0 6
93063: PUSH
93064: LD_EXP 178
93068: PUSH
93069: LD_VAR 0 1
93073: ARRAY
93074: PPUSH
93075: LD_INT 25
93077: PUSH
93078: LD_INT 2
93080: PUSH
93081: EMPTY
93082: LIST
93083: LIST
93084: PPUSH
93085: CALL_OW 72
93089: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
93090: LD_ADDR_VAR 0 7
93094: PUSH
93095: LD_EXP 178
93099: PUSH
93100: LD_VAR 0 1
93104: ARRAY
93105: PPUSH
93106: LD_INT 25
93108: PUSH
93109: LD_INT 3
93111: PUSH
93112: EMPTY
93113: LIST
93114: LIST
93115: PPUSH
93116: CALL_OW 72
93120: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
93121: LD_ADDR_VAR 0 8
93125: PUSH
93126: LD_EXP 178
93130: PUSH
93131: LD_VAR 0 1
93135: ARRAY
93136: PPUSH
93137: LD_INT 25
93139: PUSH
93140: LD_INT 4
93142: PUSH
93143: EMPTY
93144: LIST
93145: LIST
93146: PUSH
93147: LD_INT 24
93149: PUSH
93150: LD_INT 251
93152: PUSH
93153: EMPTY
93154: LIST
93155: LIST
93156: PUSH
93157: EMPTY
93158: LIST
93159: LIST
93160: PPUSH
93161: CALL_OW 72
93165: ST_TO_ADDR
// if mc_is_defending [ base ] then
93166: LD_EXP 221
93170: PUSH
93171: LD_VAR 0 1
93175: ARRAY
93176: IFFALSE 93637
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
93178: LD_ADDR_EXP 220
93182: PUSH
93183: LD_EXP 220
93187: PPUSH
93188: LD_VAR 0 1
93192: PPUSH
93193: LD_INT 4
93195: PPUSH
93196: CALL_OW 1
93200: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
93201: LD_ADDR_VAR 0 12
93205: PUSH
93206: LD_EXP 178
93210: PUSH
93211: LD_VAR 0 1
93215: ARRAY
93216: PPUSH
93217: LD_INT 2
93219: PUSH
93220: LD_INT 30
93222: PUSH
93223: LD_INT 4
93225: PUSH
93226: EMPTY
93227: LIST
93228: LIST
93229: PUSH
93230: LD_INT 30
93232: PUSH
93233: LD_INT 5
93235: PUSH
93236: EMPTY
93237: LIST
93238: LIST
93239: PUSH
93240: EMPTY
93241: LIST
93242: LIST
93243: LIST
93244: PPUSH
93245: CALL_OW 72
93249: ST_TO_ADDR
// if not b then
93250: LD_VAR 0 12
93254: NOT
93255: IFFALSE 93259
// exit ;
93257: GO 96325
// p := [ ] ;
93259: LD_ADDR_VAR 0 11
93263: PUSH
93264: EMPTY
93265: ST_TO_ADDR
// if sci >= 2 then
93266: LD_VAR 0 8
93270: PUSH
93271: LD_INT 2
93273: GREATEREQUAL
93274: IFFALSE 93305
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
93276: LD_ADDR_VAR 0 8
93280: PUSH
93281: LD_VAR 0 8
93285: PUSH
93286: LD_INT 1
93288: ARRAY
93289: PUSH
93290: LD_VAR 0 8
93294: PUSH
93295: LD_INT 2
93297: ARRAY
93298: PUSH
93299: EMPTY
93300: LIST
93301: LIST
93302: ST_TO_ADDR
93303: GO 93366
// if sci = 1 then
93305: LD_VAR 0 8
93309: PUSH
93310: LD_INT 1
93312: EQUAL
93313: IFFALSE 93334
// sci := [ sci [ 1 ] ] else
93315: LD_ADDR_VAR 0 8
93319: PUSH
93320: LD_VAR 0 8
93324: PUSH
93325: LD_INT 1
93327: ARRAY
93328: PUSH
93329: EMPTY
93330: LIST
93331: ST_TO_ADDR
93332: GO 93366
// if sci = 0 then
93334: LD_VAR 0 8
93338: PUSH
93339: LD_INT 0
93341: EQUAL
93342: IFFALSE 93366
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
93344: LD_ADDR_VAR 0 11
93348: PUSH
93349: LD_VAR 0 4
93353: PPUSH
93354: LD_INT 4
93356: PPUSH
93357: CALL 55117 0 2
93361: PUSH
93362: LD_INT 1
93364: ARRAY
93365: ST_TO_ADDR
// if eng > 4 then
93366: LD_VAR 0 6
93370: PUSH
93371: LD_INT 4
93373: GREATER
93374: IFFALSE 93420
// for i = eng downto 4 do
93376: LD_ADDR_VAR 0 3
93380: PUSH
93381: DOUBLE
93382: LD_VAR 0 6
93386: INC
93387: ST_TO_ADDR
93388: LD_INT 4
93390: PUSH
93391: FOR_DOWNTO
93392: IFFALSE 93418
// eng := eng diff eng [ i ] ;
93394: LD_ADDR_VAR 0 6
93398: PUSH
93399: LD_VAR 0 6
93403: PUSH
93404: LD_VAR 0 6
93408: PUSH
93409: LD_VAR 0 3
93413: ARRAY
93414: DIFF
93415: ST_TO_ADDR
93416: GO 93391
93418: POP
93419: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
93420: LD_ADDR_VAR 0 4
93424: PUSH
93425: LD_VAR 0 4
93429: PUSH
93430: LD_VAR 0 5
93434: PUSH
93435: LD_VAR 0 6
93439: UNION
93440: PUSH
93441: LD_VAR 0 7
93445: UNION
93446: PUSH
93447: LD_VAR 0 8
93451: UNION
93452: DIFF
93453: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
93454: LD_ADDR_VAR 0 13
93458: PUSH
93459: LD_EXP 178
93463: PUSH
93464: LD_VAR 0 1
93468: ARRAY
93469: PPUSH
93470: LD_INT 2
93472: PUSH
93473: LD_INT 30
93475: PUSH
93476: LD_INT 32
93478: PUSH
93479: EMPTY
93480: LIST
93481: LIST
93482: PUSH
93483: LD_INT 30
93485: PUSH
93486: LD_INT 31
93488: PUSH
93489: EMPTY
93490: LIST
93491: LIST
93492: PUSH
93493: EMPTY
93494: LIST
93495: LIST
93496: LIST
93497: PPUSH
93498: CALL_OW 72
93502: PUSH
93503: LD_EXP 178
93507: PUSH
93508: LD_VAR 0 1
93512: ARRAY
93513: PPUSH
93514: LD_INT 2
93516: PUSH
93517: LD_INT 30
93519: PUSH
93520: LD_INT 4
93522: PUSH
93523: EMPTY
93524: LIST
93525: LIST
93526: PUSH
93527: LD_INT 30
93529: PUSH
93530: LD_INT 5
93532: PUSH
93533: EMPTY
93534: LIST
93535: LIST
93536: PUSH
93537: EMPTY
93538: LIST
93539: LIST
93540: LIST
93541: PPUSH
93542: CALL_OW 72
93546: PUSH
93547: LD_INT 6
93549: MUL
93550: PLUS
93551: ST_TO_ADDR
// if bcount < tmp then
93552: LD_VAR 0 13
93556: PUSH
93557: LD_VAR 0 4
93561: LESS
93562: IFFALSE 93608
// for i = tmp downto bcount do
93564: LD_ADDR_VAR 0 3
93568: PUSH
93569: DOUBLE
93570: LD_VAR 0 4
93574: INC
93575: ST_TO_ADDR
93576: LD_VAR 0 13
93580: PUSH
93581: FOR_DOWNTO
93582: IFFALSE 93606
// tmp := Delete ( tmp , tmp ) ;
93584: LD_ADDR_VAR 0 4
93588: PUSH
93589: LD_VAR 0 4
93593: PPUSH
93594: LD_VAR 0 4
93598: PPUSH
93599: CALL_OW 3
93603: ST_TO_ADDR
93604: GO 93581
93606: POP
93607: POP
// result := [ tmp , 0 , 0 , p ] ;
93608: LD_ADDR_VAR 0 2
93612: PUSH
93613: LD_VAR 0 4
93617: PUSH
93618: LD_INT 0
93620: PUSH
93621: LD_INT 0
93623: PUSH
93624: LD_VAR 0 11
93628: PUSH
93629: EMPTY
93630: LIST
93631: LIST
93632: LIST
93633: LIST
93634: ST_TO_ADDR
// exit ;
93635: GO 96325
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
93637: LD_EXP 178
93641: PUSH
93642: LD_VAR 0 1
93646: ARRAY
93647: PPUSH
93648: LD_INT 2
93650: PUSH
93651: LD_INT 30
93653: PUSH
93654: LD_INT 6
93656: PUSH
93657: EMPTY
93658: LIST
93659: LIST
93660: PUSH
93661: LD_INT 30
93663: PUSH
93664: LD_INT 7
93666: PUSH
93667: EMPTY
93668: LIST
93669: LIST
93670: PUSH
93671: LD_INT 30
93673: PUSH
93674: LD_INT 8
93676: PUSH
93677: EMPTY
93678: LIST
93679: LIST
93680: PUSH
93681: EMPTY
93682: LIST
93683: LIST
93684: LIST
93685: LIST
93686: PPUSH
93687: CALL_OW 72
93691: NOT
93692: PUSH
93693: LD_EXP 178
93697: PUSH
93698: LD_VAR 0 1
93702: ARRAY
93703: PPUSH
93704: LD_INT 30
93706: PUSH
93707: LD_INT 3
93709: PUSH
93710: EMPTY
93711: LIST
93712: LIST
93713: PPUSH
93714: CALL_OW 72
93718: NOT
93719: AND
93720: IFFALSE 93792
// begin if eng = tmp then
93722: LD_VAR 0 6
93726: PUSH
93727: LD_VAR 0 4
93731: EQUAL
93732: IFFALSE 93736
// exit ;
93734: GO 96325
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
93736: LD_ADDR_EXP 220
93740: PUSH
93741: LD_EXP 220
93745: PPUSH
93746: LD_VAR 0 1
93750: PPUSH
93751: LD_INT 1
93753: PPUSH
93754: CALL_OW 1
93758: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
93759: LD_ADDR_VAR 0 2
93763: PUSH
93764: LD_INT 0
93766: PUSH
93767: LD_VAR 0 4
93771: PUSH
93772: LD_VAR 0 6
93776: DIFF
93777: PUSH
93778: LD_INT 0
93780: PUSH
93781: LD_INT 0
93783: PUSH
93784: EMPTY
93785: LIST
93786: LIST
93787: LIST
93788: LIST
93789: ST_TO_ADDR
// exit ;
93790: GO 96325
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
93792: LD_EXP 205
93796: PUSH
93797: LD_EXP 204
93801: PUSH
93802: LD_VAR 0 1
93806: ARRAY
93807: ARRAY
93808: PUSH
93809: LD_EXP 178
93813: PUSH
93814: LD_VAR 0 1
93818: ARRAY
93819: PPUSH
93820: LD_INT 2
93822: PUSH
93823: LD_INT 30
93825: PUSH
93826: LD_INT 6
93828: PUSH
93829: EMPTY
93830: LIST
93831: LIST
93832: PUSH
93833: LD_INT 30
93835: PUSH
93836: LD_INT 7
93838: PUSH
93839: EMPTY
93840: LIST
93841: LIST
93842: PUSH
93843: LD_INT 30
93845: PUSH
93846: LD_INT 8
93848: PUSH
93849: EMPTY
93850: LIST
93851: LIST
93852: PUSH
93853: EMPTY
93854: LIST
93855: LIST
93856: LIST
93857: LIST
93858: PPUSH
93859: CALL_OW 72
93863: AND
93864: PUSH
93865: LD_EXP 178
93869: PUSH
93870: LD_VAR 0 1
93874: ARRAY
93875: PPUSH
93876: LD_INT 30
93878: PUSH
93879: LD_INT 3
93881: PUSH
93882: EMPTY
93883: LIST
93884: LIST
93885: PPUSH
93886: CALL_OW 72
93890: NOT
93891: AND
93892: IFFALSE 94106
// begin if sci >= 6 then
93894: LD_VAR 0 8
93898: PUSH
93899: LD_INT 6
93901: GREATEREQUAL
93902: IFFALSE 93906
// exit ;
93904: GO 96325
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
93906: LD_ADDR_EXP 220
93910: PUSH
93911: LD_EXP 220
93915: PPUSH
93916: LD_VAR 0 1
93920: PPUSH
93921: LD_INT 2
93923: PPUSH
93924: CALL_OW 1
93928: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
93929: LD_ADDR_VAR 0 9
93933: PUSH
93934: LD_VAR 0 4
93938: PUSH
93939: LD_VAR 0 8
93943: DIFF
93944: PPUSH
93945: LD_INT 4
93947: PPUSH
93948: CALL 55117 0 2
93952: ST_TO_ADDR
// p := [ ] ;
93953: LD_ADDR_VAR 0 11
93957: PUSH
93958: EMPTY
93959: ST_TO_ADDR
// if sci < 6 and sort > 6 then
93960: LD_VAR 0 8
93964: PUSH
93965: LD_INT 6
93967: LESS
93968: PUSH
93969: LD_VAR 0 9
93973: PUSH
93974: LD_INT 6
93976: GREATER
93977: AND
93978: IFFALSE 94059
// begin for i = 1 to 6 - sci do
93980: LD_ADDR_VAR 0 3
93984: PUSH
93985: DOUBLE
93986: LD_INT 1
93988: DEC
93989: ST_TO_ADDR
93990: LD_INT 6
93992: PUSH
93993: LD_VAR 0 8
93997: MINUS
93998: PUSH
93999: FOR_TO
94000: IFFALSE 94055
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
94002: LD_ADDR_VAR 0 11
94006: PUSH
94007: LD_VAR 0 11
94011: PPUSH
94012: LD_VAR 0 11
94016: PUSH
94017: LD_INT 1
94019: PLUS
94020: PPUSH
94021: LD_VAR 0 9
94025: PUSH
94026: LD_INT 1
94028: ARRAY
94029: PPUSH
94030: CALL_OW 2
94034: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
94035: LD_ADDR_VAR 0 9
94039: PUSH
94040: LD_VAR 0 9
94044: PPUSH
94045: LD_INT 1
94047: PPUSH
94048: CALL_OW 3
94052: ST_TO_ADDR
// end ;
94053: GO 93999
94055: POP
94056: POP
// end else
94057: GO 94079
// if sort then
94059: LD_VAR 0 9
94063: IFFALSE 94079
// p := sort [ 1 ] ;
94065: LD_ADDR_VAR 0 11
94069: PUSH
94070: LD_VAR 0 9
94074: PUSH
94075: LD_INT 1
94077: ARRAY
94078: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
94079: LD_ADDR_VAR 0 2
94083: PUSH
94084: LD_INT 0
94086: PUSH
94087: LD_INT 0
94089: PUSH
94090: LD_INT 0
94092: PUSH
94093: LD_VAR 0 11
94097: PUSH
94098: EMPTY
94099: LIST
94100: LIST
94101: LIST
94102: LIST
94103: ST_TO_ADDR
// exit ;
94104: GO 96325
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
94106: LD_EXP 205
94110: PUSH
94111: LD_EXP 204
94115: PUSH
94116: LD_VAR 0 1
94120: ARRAY
94121: ARRAY
94122: PUSH
94123: LD_EXP 178
94127: PUSH
94128: LD_VAR 0 1
94132: ARRAY
94133: PPUSH
94134: LD_INT 2
94136: PUSH
94137: LD_INT 30
94139: PUSH
94140: LD_INT 6
94142: PUSH
94143: EMPTY
94144: LIST
94145: LIST
94146: PUSH
94147: LD_INT 30
94149: PUSH
94150: LD_INT 7
94152: PUSH
94153: EMPTY
94154: LIST
94155: LIST
94156: PUSH
94157: LD_INT 30
94159: PUSH
94160: LD_INT 8
94162: PUSH
94163: EMPTY
94164: LIST
94165: LIST
94166: PUSH
94167: EMPTY
94168: LIST
94169: LIST
94170: LIST
94171: LIST
94172: PPUSH
94173: CALL_OW 72
94177: AND
94178: PUSH
94179: LD_EXP 178
94183: PUSH
94184: LD_VAR 0 1
94188: ARRAY
94189: PPUSH
94190: LD_INT 30
94192: PUSH
94193: LD_INT 3
94195: PUSH
94196: EMPTY
94197: LIST
94198: LIST
94199: PPUSH
94200: CALL_OW 72
94204: AND
94205: IFFALSE 94939
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
94207: LD_ADDR_EXP 220
94211: PUSH
94212: LD_EXP 220
94216: PPUSH
94217: LD_VAR 0 1
94221: PPUSH
94222: LD_INT 3
94224: PPUSH
94225: CALL_OW 1
94229: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
94230: LD_ADDR_VAR 0 2
94234: PUSH
94235: LD_INT 0
94237: PUSH
94238: LD_INT 0
94240: PUSH
94241: LD_INT 0
94243: PUSH
94244: LD_INT 0
94246: PUSH
94247: EMPTY
94248: LIST
94249: LIST
94250: LIST
94251: LIST
94252: ST_TO_ADDR
// if not eng then
94253: LD_VAR 0 6
94257: NOT
94258: IFFALSE 94321
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
94260: LD_ADDR_VAR 0 11
94264: PUSH
94265: LD_VAR 0 4
94269: PPUSH
94270: LD_INT 2
94272: PPUSH
94273: CALL 55117 0 2
94277: PUSH
94278: LD_INT 1
94280: ARRAY
94281: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
94282: LD_ADDR_VAR 0 2
94286: PUSH
94287: LD_VAR 0 2
94291: PPUSH
94292: LD_INT 2
94294: PPUSH
94295: LD_VAR 0 11
94299: PPUSH
94300: CALL_OW 1
94304: ST_TO_ADDR
// tmp := tmp diff p ;
94305: LD_ADDR_VAR 0 4
94309: PUSH
94310: LD_VAR 0 4
94314: PUSH
94315: LD_VAR 0 11
94319: DIFF
94320: ST_TO_ADDR
// end ; if tmp and sci < 6 then
94321: LD_VAR 0 4
94325: PUSH
94326: LD_VAR 0 8
94330: PUSH
94331: LD_INT 6
94333: LESS
94334: AND
94335: IFFALSE 94523
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
94337: LD_ADDR_VAR 0 9
94341: PUSH
94342: LD_VAR 0 4
94346: PUSH
94347: LD_VAR 0 8
94351: PUSH
94352: LD_VAR 0 7
94356: UNION
94357: DIFF
94358: PPUSH
94359: LD_INT 4
94361: PPUSH
94362: CALL 55117 0 2
94366: ST_TO_ADDR
// p := [ ] ;
94367: LD_ADDR_VAR 0 11
94371: PUSH
94372: EMPTY
94373: ST_TO_ADDR
// if sort then
94374: LD_VAR 0 9
94378: IFFALSE 94494
// for i = 1 to 6 - sci do
94380: LD_ADDR_VAR 0 3
94384: PUSH
94385: DOUBLE
94386: LD_INT 1
94388: DEC
94389: ST_TO_ADDR
94390: LD_INT 6
94392: PUSH
94393: LD_VAR 0 8
94397: MINUS
94398: PUSH
94399: FOR_TO
94400: IFFALSE 94492
// begin if i = sort then
94402: LD_VAR 0 3
94406: PUSH
94407: LD_VAR 0 9
94411: EQUAL
94412: IFFALSE 94416
// break ;
94414: GO 94492
// if GetClass ( i ) = 4 then
94416: LD_VAR 0 3
94420: PPUSH
94421: CALL_OW 257
94425: PUSH
94426: LD_INT 4
94428: EQUAL
94429: IFFALSE 94433
// continue ;
94431: GO 94399
// p := Insert ( p , p + 1 , sort [ i ] ) ;
94433: LD_ADDR_VAR 0 11
94437: PUSH
94438: LD_VAR 0 11
94442: PPUSH
94443: LD_VAR 0 11
94447: PUSH
94448: LD_INT 1
94450: PLUS
94451: PPUSH
94452: LD_VAR 0 9
94456: PUSH
94457: LD_VAR 0 3
94461: ARRAY
94462: PPUSH
94463: CALL_OW 2
94467: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
94468: LD_ADDR_VAR 0 4
94472: PUSH
94473: LD_VAR 0 4
94477: PUSH
94478: LD_VAR 0 9
94482: PUSH
94483: LD_VAR 0 3
94487: ARRAY
94488: DIFF
94489: ST_TO_ADDR
// end ;
94490: GO 94399
94492: POP
94493: POP
// if p then
94494: LD_VAR 0 11
94498: IFFALSE 94523
// result := Replace ( result , 4 , p ) ;
94500: LD_ADDR_VAR 0 2
94504: PUSH
94505: LD_VAR 0 2
94509: PPUSH
94510: LD_INT 4
94512: PPUSH
94513: LD_VAR 0 11
94517: PPUSH
94518: CALL_OW 1
94522: ST_TO_ADDR
// end ; if tmp and mech < 6 then
94523: LD_VAR 0 4
94527: PUSH
94528: LD_VAR 0 7
94532: PUSH
94533: LD_INT 6
94535: LESS
94536: AND
94537: IFFALSE 94725
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
94539: LD_ADDR_VAR 0 9
94543: PUSH
94544: LD_VAR 0 4
94548: PUSH
94549: LD_VAR 0 8
94553: PUSH
94554: LD_VAR 0 7
94558: UNION
94559: DIFF
94560: PPUSH
94561: LD_INT 3
94563: PPUSH
94564: CALL 55117 0 2
94568: ST_TO_ADDR
// p := [ ] ;
94569: LD_ADDR_VAR 0 11
94573: PUSH
94574: EMPTY
94575: ST_TO_ADDR
// if sort then
94576: LD_VAR 0 9
94580: IFFALSE 94696
// for i = 1 to 6 - mech do
94582: LD_ADDR_VAR 0 3
94586: PUSH
94587: DOUBLE
94588: LD_INT 1
94590: DEC
94591: ST_TO_ADDR
94592: LD_INT 6
94594: PUSH
94595: LD_VAR 0 7
94599: MINUS
94600: PUSH
94601: FOR_TO
94602: IFFALSE 94694
// begin if i = sort then
94604: LD_VAR 0 3
94608: PUSH
94609: LD_VAR 0 9
94613: EQUAL
94614: IFFALSE 94618
// break ;
94616: GO 94694
// if GetClass ( i ) = 3 then
94618: LD_VAR 0 3
94622: PPUSH
94623: CALL_OW 257
94627: PUSH
94628: LD_INT 3
94630: EQUAL
94631: IFFALSE 94635
// continue ;
94633: GO 94601
// p := Insert ( p , p + 1 , sort [ i ] ) ;
94635: LD_ADDR_VAR 0 11
94639: PUSH
94640: LD_VAR 0 11
94644: PPUSH
94645: LD_VAR 0 11
94649: PUSH
94650: LD_INT 1
94652: PLUS
94653: PPUSH
94654: LD_VAR 0 9
94658: PUSH
94659: LD_VAR 0 3
94663: ARRAY
94664: PPUSH
94665: CALL_OW 2
94669: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
94670: LD_ADDR_VAR 0 4
94674: PUSH
94675: LD_VAR 0 4
94679: PUSH
94680: LD_VAR 0 9
94684: PUSH
94685: LD_VAR 0 3
94689: ARRAY
94690: DIFF
94691: ST_TO_ADDR
// end ;
94692: GO 94601
94694: POP
94695: POP
// if p then
94696: LD_VAR 0 11
94700: IFFALSE 94725
// result := Replace ( result , 3 , p ) ;
94702: LD_ADDR_VAR 0 2
94706: PUSH
94707: LD_VAR 0 2
94711: PPUSH
94712: LD_INT 3
94714: PPUSH
94715: LD_VAR 0 11
94719: PPUSH
94720: CALL_OW 1
94724: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
94725: LD_VAR 0 4
94729: PUSH
94730: LD_INT 6
94732: GREATER
94733: PUSH
94734: LD_VAR 0 6
94738: PUSH
94739: LD_INT 6
94741: LESS
94742: AND
94743: IFFALSE 94937
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
94745: LD_ADDR_VAR 0 9
94749: PUSH
94750: LD_VAR 0 4
94754: PUSH
94755: LD_VAR 0 8
94759: PUSH
94760: LD_VAR 0 7
94764: UNION
94765: PUSH
94766: LD_VAR 0 6
94770: UNION
94771: DIFF
94772: PPUSH
94773: LD_INT 2
94775: PPUSH
94776: CALL 55117 0 2
94780: ST_TO_ADDR
// p := [ ] ;
94781: LD_ADDR_VAR 0 11
94785: PUSH
94786: EMPTY
94787: ST_TO_ADDR
// if sort then
94788: LD_VAR 0 9
94792: IFFALSE 94908
// for i = 1 to 6 - eng do
94794: LD_ADDR_VAR 0 3
94798: PUSH
94799: DOUBLE
94800: LD_INT 1
94802: DEC
94803: ST_TO_ADDR
94804: LD_INT 6
94806: PUSH
94807: LD_VAR 0 6
94811: MINUS
94812: PUSH
94813: FOR_TO
94814: IFFALSE 94906
// begin if i = sort then
94816: LD_VAR 0 3
94820: PUSH
94821: LD_VAR 0 9
94825: EQUAL
94826: IFFALSE 94830
// break ;
94828: GO 94906
// if GetClass ( i ) = 2 then
94830: LD_VAR 0 3
94834: PPUSH
94835: CALL_OW 257
94839: PUSH
94840: LD_INT 2
94842: EQUAL
94843: IFFALSE 94847
// continue ;
94845: GO 94813
// p := Insert ( p , p + 1 , sort [ i ] ) ;
94847: LD_ADDR_VAR 0 11
94851: PUSH
94852: LD_VAR 0 11
94856: PPUSH
94857: LD_VAR 0 11
94861: PUSH
94862: LD_INT 1
94864: PLUS
94865: PPUSH
94866: LD_VAR 0 9
94870: PUSH
94871: LD_VAR 0 3
94875: ARRAY
94876: PPUSH
94877: CALL_OW 2
94881: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
94882: LD_ADDR_VAR 0 4
94886: PUSH
94887: LD_VAR 0 4
94891: PUSH
94892: LD_VAR 0 9
94896: PUSH
94897: LD_VAR 0 3
94901: ARRAY
94902: DIFF
94903: ST_TO_ADDR
// end ;
94904: GO 94813
94906: POP
94907: POP
// if p then
94908: LD_VAR 0 11
94912: IFFALSE 94937
// result := Replace ( result , 2 , p ) ;
94914: LD_ADDR_VAR 0 2
94918: PUSH
94919: LD_VAR 0 2
94923: PPUSH
94924: LD_INT 2
94926: PPUSH
94927: LD_VAR 0 11
94931: PPUSH
94932: CALL_OW 1
94936: ST_TO_ADDR
// end ; exit ;
94937: GO 96325
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
94939: LD_EXP 205
94943: PUSH
94944: LD_EXP 204
94948: PUSH
94949: LD_VAR 0 1
94953: ARRAY
94954: ARRAY
94955: NOT
94956: PUSH
94957: LD_EXP 178
94961: PUSH
94962: LD_VAR 0 1
94966: ARRAY
94967: PPUSH
94968: LD_INT 30
94970: PUSH
94971: LD_INT 3
94973: PUSH
94974: EMPTY
94975: LIST
94976: LIST
94977: PPUSH
94978: CALL_OW 72
94982: AND
94983: PUSH
94984: LD_EXP 183
94988: PUSH
94989: LD_VAR 0 1
94993: ARRAY
94994: AND
94995: IFFALSE 95603
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
94997: LD_ADDR_EXP 220
95001: PUSH
95002: LD_EXP 220
95006: PPUSH
95007: LD_VAR 0 1
95011: PPUSH
95012: LD_INT 5
95014: PPUSH
95015: CALL_OW 1
95019: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
95020: LD_ADDR_VAR 0 2
95024: PUSH
95025: LD_INT 0
95027: PUSH
95028: LD_INT 0
95030: PUSH
95031: LD_INT 0
95033: PUSH
95034: LD_INT 0
95036: PUSH
95037: EMPTY
95038: LIST
95039: LIST
95040: LIST
95041: LIST
95042: ST_TO_ADDR
// if sci > 1 then
95043: LD_VAR 0 8
95047: PUSH
95048: LD_INT 1
95050: GREATER
95051: IFFALSE 95079
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
95053: LD_ADDR_VAR 0 4
95057: PUSH
95058: LD_VAR 0 4
95062: PUSH
95063: LD_VAR 0 8
95067: PUSH
95068: LD_VAR 0 8
95072: PUSH
95073: LD_INT 1
95075: ARRAY
95076: DIFF
95077: DIFF
95078: ST_TO_ADDR
// if tmp and not sci then
95079: LD_VAR 0 4
95083: PUSH
95084: LD_VAR 0 8
95088: NOT
95089: AND
95090: IFFALSE 95159
// begin sort := SortBySkill ( tmp , 4 ) ;
95092: LD_ADDR_VAR 0 9
95096: PUSH
95097: LD_VAR 0 4
95101: PPUSH
95102: LD_INT 4
95104: PPUSH
95105: CALL 55117 0 2
95109: ST_TO_ADDR
// if sort then
95110: LD_VAR 0 9
95114: IFFALSE 95130
// p := sort [ 1 ] ;
95116: LD_ADDR_VAR 0 11
95120: PUSH
95121: LD_VAR 0 9
95125: PUSH
95126: LD_INT 1
95128: ARRAY
95129: ST_TO_ADDR
// if p then
95130: LD_VAR 0 11
95134: IFFALSE 95159
// result := Replace ( result , 4 , p ) ;
95136: LD_ADDR_VAR 0 2
95140: PUSH
95141: LD_VAR 0 2
95145: PPUSH
95146: LD_INT 4
95148: PPUSH
95149: LD_VAR 0 11
95153: PPUSH
95154: CALL_OW 1
95158: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
95159: LD_ADDR_VAR 0 4
95163: PUSH
95164: LD_VAR 0 4
95168: PUSH
95169: LD_VAR 0 7
95173: DIFF
95174: ST_TO_ADDR
// if tmp and mech < 6 then
95175: LD_VAR 0 4
95179: PUSH
95180: LD_VAR 0 7
95184: PUSH
95185: LD_INT 6
95187: LESS
95188: AND
95189: IFFALSE 95377
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
95191: LD_ADDR_VAR 0 9
95195: PUSH
95196: LD_VAR 0 4
95200: PUSH
95201: LD_VAR 0 8
95205: PUSH
95206: LD_VAR 0 7
95210: UNION
95211: DIFF
95212: PPUSH
95213: LD_INT 3
95215: PPUSH
95216: CALL 55117 0 2
95220: ST_TO_ADDR
// p := [ ] ;
95221: LD_ADDR_VAR 0 11
95225: PUSH
95226: EMPTY
95227: ST_TO_ADDR
// if sort then
95228: LD_VAR 0 9
95232: IFFALSE 95348
// for i = 1 to 6 - mech do
95234: LD_ADDR_VAR 0 3
95238: PUSH
95239: DOUBLE
95240: LD_INT 1
95242: DEC
95243: ST_TO_ADDR
95244: LD_INT 6
95246: PUSH
95247: LD_VAR 0 7
95251: MINUS
95252: PUSH
95253: FOR_TO
95254: IFFALSE 95346
// begin if i = sort then
95256: LD_VAR 0 3
95260: PUSH
95261: LD_VAR 0 9
95265: EQUAL
95266: IFFALSE 95270
// break ;
95268: GO 95346
// if GetClass ( i ) = 3 then
95270: LD_VAR 0 3
95274: PPUSH
95275: CALL_OW 257
95279: PUSH
95280: LD_INT 3
95282: EQUAL
95283: IFFALSE 95287
// continue ;
95285: GO 95253
// p := Insert ( p , p + 1 , sort [ i ] ) ;
95287: LD_ADDR_VAR 0 11
95291: PUSH
95292: LD_VAR 0 11
95296: PPUSH
95297: LD_VAR 0 11
95301: PUSH
95302: LD_INT 1
95304: PLUS
95305: PPUSH
95306: LD_VAR 0 9
95310: PUSH
95311: LD_VAR 0 3
95315: ARRAY
95316: PPUSH
95317: CALL_OW 2
95321: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
95322: LD_ADDR_VAR 0 4
95326: PUSH
95327: LD_VAR 0 4
95331: PUSH
95332: LD_VAR 0 9
95336: PUSH
95337: LD_VAR 0 3
95341: ARRAY
95342: DIFF
95343: ST_TO_ADDR
// end ;
95344: GO 95253
95346: POP
95347: POP
// if p then
95348: LD_VAR 0 11
95352: IFFALSE 95377
// result := Replace ( result , 3 , p ) ;
95354: LD_ADDR_VAR 0 2
95358: PUSH
95359: LD_VAR 0 2
95363: PPUSH
95364: LD_INT 3
95366: PPUSH
95367: LD_VAR 0 11
95371: PPUSH
95372: CALL_OW 1
95376: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
95377: LD_ADDR_VAR 0 4
95381: PUSH
95382: LD_VAR 0 4
95386: PUSH
95387: LD_VAR 0 6
95391: DIFF
95392: ST_TO_ADDR
// if tmp and eng < 6 then
95393: LD_VAR 0 4
95397: PUSH
95398: LD_VAR 0 6
95402: PUSH
95403: LD_INT 6
95405: LESS
95406: AND
95407: IFFALSE 95601
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
95409: LD_ADDR_VAR 0 9
95413: PUSH
95414: LD_VAR 0 4
95418: PUSH
95419: LD_VAR 0 8
95423: PUSH
95424: LD_VAR 0 7
95428: UNION
95429: PUSH
95430: LD_VAR 0 6
95434: UNION
95435: DIFF
95436: PPUSH
95437: LD_INT 2
95439: PPUSH
95440: CALL 55117 0 2
95444: ST_TO_ADDR
// p := [ ] ;
95445: LD_ADDR_VAR 0 11
95449: PUSH
95450: EMPTY
95451: ST_TO_ADDR
// if sort then
95452: LD_VAR 0 9
95456: IFFALSE 95572
// for i = 1 to 6 - eng do
95458: LD_ADDR_VAR 0 3
95462: PUSH
95463: DOUBLE
95464: LD_INT 1
95466: DEC
95467: ST_TO_ADDR
95468: LD_INT 6
95470: PUSH
95471: LD_VAR 0 6
95475: MINUS
95476: PUSH
95477: FOR_TO
95478: IFFALSE 95570
// begin if i = sort then
95480: LD_VAR 0 3
95484: PUSH
95485: LD_VAR 0 9
95489: EQUAL
95490: IFFALSE 95494
// break ;
95492: GO 95570
// if GetClass ( i ) = 2 then
95494: LD_VAR 0 3
95498: PPUSH
95499: CALL_OW 257
95503: PUSH
95504: LD_INT 2
95506: EQUAL
95507: IFFALSE 95511
// continue ;
95509: GO 95477
// p := Insert ( p , p + 1 , sort [ i ] ) ;
95511: LD_ADDR_VAR 0 11
95515: PUSH
95516: LD_VAR 0 11
95520: PPUSH
95521: LD_VAR 0 11
95525: PUSH
95526: LD_INT 1
95528: PLUS
95529: PPUSH
95530: LD_VAR 0 9
95534: PUSH
95535: LD_VAR 0 3
95539: ARRAY
95540: PPUSH
95541: CALL_OW 2
95545: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
95546: LD_ADDR_VAR 0 4
95550: PUSH
95551: LD_VAR 0 4
95555: PUSH
95556: LD_VAR 0 9
95560: PUSH
95561: LD_VAR 0 3
95565: ARRAY
95566: DIFF
95567: ST_TO_ADDR
// end ;
95568: GO 95477
95570: POP
95571: POP
// if p then
95572: LD_VAR 0 11
95576: IFFALSE 95601
// result := Replace ( result , 2 , p ) ;
95578: LD_ADDR_VAR 0 2
95582: PUSH
95583: LD_VAR 0 2
95587: PPUSH
95588: LD_INT 2
95590: PPUSH
95591: LD_VAR 0 11
95595: PPUSH
95596: CALL_OW 1
95600: ST_TO_ADDR
// end ; exit ;
95601: GO 96325
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
95603: LD_EXP 205
95607: PUSH
95608: LD_EXP 204
95612: PUSH
95613: LD_VAR 0 1
95617: ARRAY
95618: ARRAY
95619: NOT
95620: PUSH
95621: LD_EXP 178
95625: PUSH
95626: LD_VAR 0 1
95630: ARRAY
95631: PPUSH
95632: LD_INT 30
95634: PUSH
95635: LD_INT 3
95637: PUSH
95638: EMPTY
95639: LIST
95640: LIST
95641: PPUSH
95642: CALL_OW 72
95646: AND
95647: PUSH
95648: LD_EXP 183
95652: PUSH
95653: LD_VAR 0 1
95657: ARRAY
95658: NOT
95659: AND
95660: IFFALSE 96325
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
95662: LD_ADDR_EXP 220
95666: PUSH
95667: LD_EXP 220
95671: PPUSH
95672: LD_VAR 0 1
95676: PPUSH
95677: LD_INT 6
95679: PPUSH
95680: CALL_OW 1
95684: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
95685: LD_ADDR_VAR 0 2
95689: PUSH
95690: LD_INT 0
95692: PUSH
95693: LD_INT 0
95695: PUSH
95696: LD_INT 0
95698: PUSH
95699: LD_INT 0
95701: PUSH
95702: EMPTY
95703: LIST
95704: LIST
95705: LIST
95706: LIST
95707: ST_TO_ADDR
// if sci >= 1 then
95708: LD_VAR 0 8
95712: PUSH
95713: LD_INT 1
95715: GREATEREQUAL
95716: IFFALSE 95738
// tmp := tmp diff sci [ 1 ] ;
95718: LD_ADDR_VAR 0 4
95722: PUSH
95723: LD_VAR 0 4
95727: PUSH
95728: LD_VAR 0 8
95732: PUSH
95733: LD_INT 1
95735: ARRAY
95736: DIFF
95737: ST_TO_ADDR
// if tmp and not sci then
95738: LD_VAR 0 4
95742: PUSH
95743: LD_VAR 0 8
95747: NOT
95748: AND
95749: IFFALSE 95818
// begin sort := SortBySkill ( tmp , 4 ) ;
95751: LD_ADDR_VAR 0 9
95755: PUSH
95756: LD_VAR 0 4
95760: PPUSH
95761: LD_INT 4
95763: PPUSH
95764: CALL 55117 0 2
95768: ST_TO_ADDR
// if sort then
95769: LD_VAR 0 9
95773: IFFALSE 95789
// p := sort [ 1 ] ;
95775: LD_ADDR_VAR 0 11
95779: PUSH
95780: LD_VAR 0 9
95784: PUSH
95785: LD_INT 1
95787: ARRAY
95788: ST_TO_ADDR
// if p then
95789: LD_VAR 0 11
95793: IFFALSE 95818
// result := Replace ( result , 4 , p ) ;
95795: LD_ADDR_VAR 0 2
95799: PUSH
95800: LD_VAR 0 2
95804: PPUSH
95805: LD_INT 4
95807: PPUSH
95808: LD_VAR 0 11
95812: PPUSH
95813: CALL_OW 1
95817: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
95818: LD_ADDR_VAR 0 4
95822: PUSH
95823: LD_VAR 0 4
95827: PUSH
95828: LD_VAR 0 7
95832: DIFF
95833: ST_TO_ADDR
// if tmp and mech < 6 then
95834: LD_VAR 0 4
95838: PUSH
95839: LD_VAR 0 7
95843: PUSH
95844: LD_INT 6
95846: LESS
95847: AND
95848: IFFALSE 96030
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
95850: LD_ADDR_VAR 0 9
95854: PUSH
95855: LD_VAR 0 4
95859: PUSH
95860: LD_VAR 0 7
95864: DIFF
95865: PPUSH
95866: LD_INT 3
95868: PPUSH
95869: CALL 55117 0 2
95873: ST_TO_ADDR
// p := [ ] ;
95874: LD_ADDR_VAR 0 11
95878: PUSH
95879: EMPTY
95880: ST_TO_ADDR
// if sort then
95881: LD_VAR 0 9
95885: IFFALSE 96001
// for i = 1 to 6 - mech do
95887: LD_ADDR_VAR 0 3
95891: PUSH
95892: DOUBLE
95893: LD_INT 1
95895: DEC
95896: ST_TO_ADDR
95897: LD_INT 6
95899: PUSH
95900: LD_VAR 0 7
95904: MINUS
95905: PUSH
95906: FOR_TO
95907: IFFALSE 95999
// begin if i = sort then
95909: LD_VAR 0 3
95913: PUSH
95914: LD_VAR 0 9
95918: EQUAL
95919: IFFALSE 95923
// break ;
95921: GO 95999
// if GetClass ( i ) = 3 then
95923: LD_VAR 0 3
95927: PPUSH
95928: CALL_OW 257
95932: PUSH
95933: LD_INT 3
95935: EQUAL
95936: IFFALSE 95940
// continue ;
95938: GO 95906
// p := Insert ( p , p + 1 , sort [ i ] ) ;
95940: LD_ADDR_VAR 0 11
95944: PUSH
95945: LD_VAR 0 11
95949: PPUSH
95950: LD_VAR 0 11
95954: PUSH
95955: LD_INT 1
95957: PLUS
95958: PPUSH
95959: LD_VAR 0 9
95963: PUSH
95964: LD_VAR 0 3
95968: ARRAY
95969: PPUSH
95970: CALL_OW 2
95974: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
95975: LD_ADDR_VAR 0 4
95979: PUSH
95980: LD_VAR 0 4
95984: PUSH
95985: LD_VAR 0 9
95989: PUSH
95990: LD_VAR 0 3
95994: ARRAY
95995: DIFF
95996: ST_TO_ADDR
// end ;
95997: GO 95906
95999: POP
96000: POP
// if p then
96001: LD_VAR 0 11
96005: IFFALSE 96030
// result := Replace ( result , 3 , p ) ;
96007: LD_ADDR_VAR 0 2
96011: PUSH
96012: LD_VAR 0 2
96016: PPUSH
96017: LD_INT 3
96019: PPUSH
96020: LD_VAR 0 11
96024: PPUSH
96025: CALL_OW 1
96029: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
96030: LD_ADDR_VAR 0 4
96034: PUSH
96035: LD_VAR 0 4
96039: PUSH
96040: LD_VAR 0 6
96044: DIFF
96045: ST_TO_ADDR
// if tmp and eng < 4 then
96046: LD_VAR 0 4
96050: PUSH
96051: LD_VAR 0 6
96055: PUSH
96056: LD_INT 4
96058: LESS
96059: AND
96060: IFFALSE 96250
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
96062: LD_ADDR_VAR 0 9
96066: PUSH
96067: LD_VAR 0 4
96071: PUSH
96072: LD_VAR 0 7
96076: PUSH
96077: LD_VAR 0 6
96081: UNION
96082: DIFF
96083: PPUSH
96084: LD_INT 2
96086: PPUSH
96087: CALL 55117 0 2
96091: ST_TO_ADDR
// p := [ ] ;
96092: LD_ADDR_VAR 0 11
96096: PUSH
96097: EMPTY
96098: ST_TO_ADDR
// if sort then
96099: LD_VAR 0 9
96103: IFFALSE 96219
// for i = 1 to 4 - eng do
96105: LD_ADDR_VAR 0 3
96109: PUSH
96110: DOUBLE
96111: LD_INT 1
96113: DEC
96114: ST_TO_ADDR
96115: LD_INT 4
96117: PUSH
96118: LD_VAR 0 6
96122: MINUS
96123: PUSH
96124: FOR_TO
96125: IFFALSE 96217
// begin if i = sort then
96127: LD_VAR 0 3
96131: PUSH
96132: LD_VAR 0 9
96136: EQUAL
96137: IFFALSE 96141
// break ;
96139: GO 96217
// if GetClass ( i ) = 2 then
96141: LD_VAR 0 3
96145: PPUSH
96146: CALL_OW 257
96150: PUSH
96151: LD_INT 2
96153: EQUAL
96154: IFFALSE 96158
// continue ;
96156: GO 96124
// p := Insert ( p , p + 1 , sort [ i ] ) ;
96158: LD_ADDR_VAR 0 11
96162: PUSH
96163: LD_VAR 0 11
96167: PPUSH
96168: LD_VAR 0 11
96172: PUSH
96173: LD_INT 1
96175: PLUS
96176: PPUSH
96177: LD_VAR 0 9
96181: PUSH
96182: LD_VAR 0 3
96186: ARRAY
96187: PPUSH
96188: CALL_OW 2
96192: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
96193: LD_ADDR_VAR 0 4
96197: PUSH
96198: LD_VAR 0 4
96202: PUSH
96203: LD_VAR 0 9
96207: PUSH
96208: LD_VAR 0 3
96212: ARRAY
96213: DIFF
96214: ST_TO_ADDR
// end ;
96215: GO 96124
96217: POP
96218: POP
// if p then
96219: LD_VAR 0 11
96223: IFFALSE 96248
// result := Replace ( result , 2 , p ) ;
96225: LD_ADDR_VAR 0 2
96229: PUSH
96230: LD_VAR 0 2
96234: PPUSH
96235: LD_INT 2
96237: PPUSH
96238: LD_VAR 0 11
96242: PPUSH
96243: CALL_OW 1
96247: ST_TO_ADDR
// end else
96248: GO 96294
// for i = eng downto 5 do
96250: LD_ADDR_VAR 0 3
96254: PUSH
96255: DOUBLE
96256: LD_VAR 0 6
96260: INC
96261: ST_TO_ADDR
96262: LD_INT 5
96264: PUSH
96265: FOR_DOWNTO
96266: IFFALSE 96292
// tmp := tmp union eng [ i ] ;
96268: LD_ADDR_VAR 0 4
96272: PUSH
96273: LD_VAR 0 4
96277: PUSH
96278: LD_VAR 0 6
96282: PUSH
96283: LD_VAR 0 3
96287: ARRAY
96288: UNION
96289: ST_TO_ADDR
96290: GO 96265
96292: POP
96293: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
96294: LD_ADDR_VAR 0 2
96298: PUSH
96299: LD_VAR 0 2
96303: PPUSH
96304: LD_INT 1
96306: PPUSH
96307: LD_VAR 0 4
96311: PUSH
96312: LD_VAR 0 5
96316: DIFF
96317: PPUSH
96318: CALL_OW 1
96322: ST_TO_ADDR
// exit ;
96323: GO 96325
// end ; end ;
96325: LD_VAR 0 2
96329: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
96330: LD_INT 0
96332: PPUSH
96333: PPUSH
96334: PPUSH
// if not mc_bases then
96335: LD_EXP 178
96339: NOT
96340: IFFALSE 96344
// exit ;
96342: GO 96486
// for i = 1 to mc_bases do
96344: LD_ADDR_VAR 0 2
96348: PUSH
96349: DOUBLE
96350: LD_INT 1
96352: DEC
96353: ST_TO_ADDR
96354: LD_EXP 178
96358: PUSH
96359: FOR_TO
96360: IFFALSE 96477
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
96362: LD_ADDR_VAR 0 3
96366: PUSH
96367: LD_EXP 178
96371: PUSH
96372: LD_VAR 0 2
96376: ARRAY
96377: PPUSH
96378: LD_INT 21
96380: PUSH
96381: LD_INT 3
96383: PUSH
96384: EMPTY
96385: LIST
96386: LIST
96387: PUSH
96388: LD_INT 3
96390: PUSH
96391: LD_INT 2
96393: PUSH
96394: LD_INT 30
96396: PUSH
96397: LD_INT 29
96399: PUSH
96400: EMPTY
96401: LIST
96402: LIST
96403: PUSH
96404: LD_INT 30
96406: PUSH
96407: LD_INT 30
96409: PUSH
96410: EMPTY
96411: LIST
96412: LIST
96413: PUSH
96414: EMPTY
96415: LIST
96416: LIST
96417: LIST
96418: PUSH
96419: EMPTY
96420: LIST
96421: LIST
96422: PUSH
96423: LD_INT 3
96425: PUSH
96426: LD_INT 24
96428: PUSH
96429: LD_INT 1000
96431: PUSH
96432: EMPTY
96433: LIST
96434: LIST
96435: PUSH
96436: EMPTY
96437: LIST
96438: LIST
96439: PUSH
96440: EMPTY
96441: LIST
96442: LIST
96443: LIST
96444: PPUSH
96445: CALL_OW 72
96449: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
96450: LD_ADDR_EXP 179
96454: PUSH
96455: LD_EXP 179
96459: PPUSH
96460: LD_VAR 0 2
96464: PPUSH
96465: LD_VAR 0 3
96469: PPUSH
96470: CALL_OW 1
96474: ST_TO_ADDR
// end ;
96475: GO 96359
96477: POP
96478: POP
// RaiseSailEvent ( 101 ) ;
96479: LD_INT 101
96481: PPUSH
96482: CALL_OW 427
// end ;
96486: LD_VAR 0 1
96490: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
96491: LD_INT 0
96493: PPUSH
96494: PPUSH
96495: PPUSH
96496: PPUSH
96497: PPUSH
96498: PPUSH
96499: PPUSH
// if not mc_bases then
96500: LD_EXP 178
96504: NOT
96505: IFFALSE 96509
// exit ;
96507: GO 97071
// for i = 1 to mc_bases do
96509: LD_ADDR_VAR 0 2
96513: PUSH
96514: DOUBLE
96515: LD_INT 1
96517: DEC
96518: ST_TO_ADDR
96519: LD_EXP 178
96523: PUSH
96524: FOR_TO
96525: IFFALSE 97062
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 1000 ] ] ] ] ) ;
96527: LD_ADDR_VAR 0 5
96531: PUSH
96532: LD_EXP 178
96536: PUSH
96537: LD_VAR 0 2
96541: ARRAY
96542: PUSH
96543: LD_EXP 207
96547: PUSH
96548: LD_VAR 0 2
96552: ARRAY
96553: UNION
96554: PPUSH
96555: LD_INT 21
96557: PUSH
96558: LD_INT 1
96560: PUSH
96561: EMPTY
96562: LIST
96563: LIST
96564: PUSH
96565: LD_INT 1
96567: PUSH
96568: LD_INT 3
96570: PUSH
96571: LD_INT 54
96573: PUSH
96574: EMPTY
96575: LIST
96576: PUSH
96577: EMPTY
96578: LIST
96579: LIST
96580: PUSH
96581: LD_INT 3
96583: PUSH
96584: LD_INT 24
96586: PUSH
96587: LD_INT 1000
96589: PUSH
96590: EMPTY
96591: LIST
96592: LIST
96593: PUSH
96594: EMPTY
96595: LIST
96596: LIST
96597: PUSH
96598: EMPTY
96599: LIST
96600: LIST
96601: LIST
96602: PUSH
96603: EMPTY
96604: LIST
96605: LIST
96606: PPUSH
96607: CALL_OW 72
96611: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
96612: LD_ADDR_VAR 0 6
96616: PUSH
96617: LD_EXP 178
96621: PUSH
96622: LD_VAR 0 2
96626: ARRAY
96627: PPUSH
96628: LD_INT 21
96630: PUSH
96631: LD_INT 1
96633: PUSH
96634: EMPTY
96635: LIST
96636: LIST
96637: PUSH
96638: LD_INT 1
96640: PUSH
96641: LD_INT 3
96643: PUSH
96644: LD_INT 54
96646: PUSH
96647: EMPTY
96648: LIST
96649: PUSH
96650: EMPTY
96651: LIST
96652: LIST
96653: PUSH
96654: LD_INT 3
96656: PUSH
96657: LD_INT 24
96659: PUSH
96660: LD_INT 250
96662: PUSH
96663: EMPTY
96664: LIST
96665: LIST
96666: PUSH
96667: EMPTY
96668: LIST
96669: LIST
96670: PUSH
96671: EMPTY
96672: LIST
96673: LIST
96674: LIST
96675: PUSH
96676: EMPTY
96677: LIST
96678: LIST
96679: PPUSH
96680: CALL_OW 72
96684: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
96685: LD_ADDR_VAR 0 7
96689: PUSH
96690: LD_VAR 0 5
96694: PUSH
96695: LD_VAR 0 6
96699: DIFF
96700: ST_TO_ADDR
// if not need_heal_1 then
96701: LD_VAR 0 6
96705: NOT
96706: IFFALSE 96739
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
96708: LD_ADDR_EXP 181
96712: PUSH
96713: LD_EXP 181
96717: PPUSH
96718: LD_VAR 0 2
96722: PUSH
96723: LD_INT 1
96725: PUSH
96726: EMPTY
96727: LIST
96728: LIST
96729: PPUSH
96730: EMPTY
96731: PPUSH
96732: CALL 24363 0 3
96736: ST_TO_ADDR
96737: GO 96809
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
96739: LD_ADDR_EXP 181
96743: PUSH
96744: LD_EXP 181
96748: PPUSH
96749: LD_VAR 0 2
96753: PUSH
96754: LD_INT 1
96756: PUSH
96757: EMPTY
96758: LIST
96759: LIST
96760: PPUSH
96761: LD_EXP 181
96765: PUSH
96766: LD_VAR 0 2
96770: ARRAY
96771: PUSH
96772: LD_INT 1
96774: ARRAY
96775: PPUSH
96776: LD_INT 3
96778: PUSH
96779: LD_INT 24
96781: PUSH
96782: LD_INT 1000
96784: PUSH
96785: EMPTY
96786: LIST
96787: LIST
96788: PUSH
96789: EMPTY
96790: LIST
96791: LIST
96792: PPUSH
96793: CALL_OW 72
96797: PUSH
96798: LD_VAR 0 6
96802: UNION
96803: PPUSH
96804: CALL 24363 0 3
96808: ST_TO_ADDR
// if not need_heal_2 then
96809: LD_VAR 0 7
96813: NOT
96814: IFFALSE 96847
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
96816: LD_ADDR_EXP 181
96820: PUSH
96821: LD_EXP 181
96825: PPUSH
96826: LD_VAR 0 2
96830: PUSH
96831: LD_INT 2
96833: PUSH
96834: EMPTY
96835: LIST
96836: LIST
96837: PPUSH
96838: EMPTY
96839: PPUSH
96840: CALL 24363 0 3
96844: ST_TO_ADDR
96845: GO 96879
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
96847: LD_ADDR_EXP 181
96851: PUSH
96852: LD_EXP 181
96856: PPUSH
96857: LD_VAR 0 2
96861: PUSH
96862: LD_INT 2
96864: PUSH
96865: EMPTY
96866: LIST
96867: LIST
96868: PPUSH
96869: LD_VAR 0 7
96873: PPUSH
96874: CALL 24363 0 3
96878: ST_TO_ADDR
// if need_heal_2 then
96879: LD_VAR 0 7
96883: IFFALSE 97044
// for j in need_heal_2 do
96885: LD_ADDR_VAR 0 3
96889: PUSH
96890: LD_VAR 0 7
96894: PUSH
96895: FOR_IN
96896: IFFALSE 97042
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
96898: LD_ADDR_VAR 0 5
96902: PUSH
96903: LD_EXP 178
96907: PUSH
96908: LD_VAR 0 2
96912: ARRAY
96913: PPUSH
96914: LD_INT 2
96916: PUSH
96917: LD_INT 30
96919: PUSH
96920: LD_INT 6
96922: PUSH
96923: EMPTY
96924: LIST
96925: LIST
96926: PUSH
96927: LD_INT 30
96929: PUSH
96930: LD_INT 7
96932: PUSH
96933: EMPTY
96934: LIST
96935: LIST
96936: PUSH
96937: LD_INT 30
96939: PUSH
96940: LD_INT 8
96942: PUSH
96943: EMPTY
96944: LIST
96945: LIST
96946: PUSH
96947: LD_INT 30
96949: PUSH
96950: LD_INT 0
96952: PUSH
96953: EMPTY
96954: LIST
96955: LIST
96956: PUSH
96957: LD_INT 30
96959: PUSH
96960: LD_INT 1
96962: PUSH
96963: EMPTY
96964: LIST
96965: LIST
96966: PUSH
96967: EMPTY
96968: LIST
96969: LIST
96970: LIST
96971: LIST
96972: LIST
96973: LIST
96974: PPUSH
96975: CALL_OW 72
96979: ST_TO_ADDR
// if tmp then
96980: LD_VAR 0 5
96984: IFFALSE 97040
// begin k := NearestUnitToUnit ( tmp , j ) ;
96986: LD_ADDR_VAR 0 4
96990: PUSH
96991: LD_VAR 0 5
96995: PPUSH
96996: LD_VAR 0 3
97000: PPUSH
97001: CALL_OW 74
97005: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 5 then
97006: LD_VAR 0 3
97010: PPUSH
97011: LD_VAR 0 4
97015: PPUSH
97016: CALL_OW 296
97020: PUSH
97021: LD_INT 5
97023: GREATER
97024: IFFALSE 97040
// ComMoveToNearbyEntrance ( j , k ) ;
97026: LD_VAR 0 3
97030: PPUSH
97031: LD_VAR 0 4
97035: PPUSH
97036: CALL 57485 0 2
// end ; end ;
97040: GO 96895
97042: POP
97043: POP
// if not need_heal_1 and not need_heal_2 then
97044: LD_VAR 0 6
97048: NOT
97049: PUSH
97050: LD_VAR 0 7
97054: NOT
97055: AND
97056: IFFALSE 97060
// continue ;
97058: GO 96524
// end ;
97060: GO 96524
97062: POP
97063: POP
// RaiseSailEvent ( 102 ) ;
97064: LD_INT 102
97066: PPUSH
97067: CALL_OW 427
// end ;
97071: LD_VAR 0 1
97075: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes , to_repair_tmp , to_repair ; begin
97076: LD_INT 0
97078: PPUSH
97079: PPUSH
97080: PPUSH
97081: PPUSH
97082: PPUSH
97083: PPUSH
97084: PPUSH
97085: PPUSH
// if not mc_bases then
97086: LD_EXP 178
97090: NOT
97091: IFFALSE 97095
// exit ;
97093: GO 97978
// for i = 1 to mc_bases do
97095: LD_ADDR_VAR 0 2
97099: PUSH
97100: DOUBLE
97101: LD_INT 1
97103: DEC
97104: ST_TO_ADDR
97105: LD_EXP 178
97109: PUSH
97110: FOR_TO
97111: IFFALSE 97976
// begin if not mc_building_need_repair [ i ] then
97113: LD_EXP 179
97117: PUSH
97118: LD_VAR 0 2
97122: ARRAY
97123: NOT
97124: IFFALSE 97311
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ] ) ;
97126: LD_ADDR_VAR 0 6
97130: PUSH
97131: LD_EXP 197
97135: PUSH
97136: LD_VAR 0 2
97140: ARRAY
97141: PPUSH
97142: LD_INT 3
97144: PUSH
97145: LD_INT 24
97147: PUSH
97148: LD_INT 1000
97150: PUSH
97151: EMPTY
97152: LIST
97153: LIST
97154: PUSH
97155: EMPTY
97156: LIST
97157: LIST
97158: PUSH
97159: LD_INT 2
97161: PUSH
97162: LD_INT 34
97164: PUSH
97165: LD_INT 13
97167: PUSH
97168: EMPTY
97169: LIST
97170: LIST
97171: PUSH
97172: LD_INT 34
97174: PUSH
97175: LD_INT 52
97177: PUSH
97178: EMPTY
97179: LIST
97180: LIST
97181: PUSH
97182: LD_INT 34
97184: PUSH
97185: LD_EXP 164
97189: PUSH
97190: EMPTY
97191: LIST
97192: LIST
97193: PUSH
97194: EMPTY
97195: LIST
97196: LIST
97197: LIST
97198: LIST
97199: PUSH
97200: EMPTY
97201: LIST
97202: LIST
97203: PPUSH
97204: CALL_OW 72
97208: ST_TO_ADDR
// if cranes then
97209: LD_VAR 0 6
97213: IFFALSE 97275
// for j in cranes do
97215: LD_ADDR_VAR 0 3
97219: PUSH
97220: LD_VAR 0 6
97224: PUSH
97225: FOR_IN
97226: IFFALSE 97273
// if not IsInArea ( j , mc_parking [ i ] ) then
97228: LD_VAR 0 3
97232: PPUSH
97233: LD_EXP 202
97237: PUSH
97238: LD_VAR 0 2
97242: ARRAY
97243: PPUSH
97244: CALL_OW 308
97248: NOT
97249: IFFALSE 97271
// ComMoveToArea ( j , mc_parking [ i ] ) ;
97251: LD_VAR 0 3
97255: PPUSH
97256: LD_EXP 202
97260: PUSH
97261: LD_VAR 0 2
97265: ARRAY
97266: PPUSH
97267: CALL_OW 113
97271: GO 97225
97273: POP
97274: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
97275: LD_ADDR_EXP 180
97279: PUSH
97280: LD_EXP 180
97284: PPUSH
97285: LD_VAR 0 2
97289: PPUSH
97290: EMPTY
97291: PPUSH
97292: CALL_OW 1
97296: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
97297: LD_VAR 0 2
97301: PPUSH
97302: LD_INT 101
97304: PPUSH
97305: CALL 92163 0 2
// continue ;
97309: GO 97110
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
97311: LD_ADDR_EXP 184
97315: PUSH
97316: LD_EXP 184
97320: PPUSH
97321: LD_VAR 0 2
97325: PPUSH
97326: EMPTY
97327: PPUSH
97328: CALL_OW 1
97332: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
97333: LD_VAR 0 2
97337: PPUSH
97338: LD_INT 103
97340: PPUSH
97341: CALL 92163 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) ;
97345: LD_ADDR_VAR 0 5
97349: PUSH
97350: LD_EXP 178
97354: PUSH
97355: LD_VAR 0 2
97359: ARRAY
97360: PUSH
97361: LD_EXP 207
97365: PUSH
97366: LD_VAR 0 2
97370: ARRAY
97371: UNION
97372: PPUSH
97373: LD_INT 2
97375: PUSH
97376: LD_INT 25
97378: PUSH
97379: LD_INT 2
97381: PUSH
97382: EMPTY
97383: LIST
97384: LIST
97385: PUSH
97386: LD_INT 25
97388: PUSH
97389: LD_INT 16
97391: PUSH
97392: EMPTY
97393: LIST
97394: LIST
97395: PUSH
97396: EMPTY
97397: LIST
97398: LIST
97399: LIST
97400: PUSH
97401: EMPTY
97402: LIST
97403: PPUSH
97404: CALL_OW 72
97408: ST_TO_ADDR
// if mc_need_heal [ i ] then
97409: LD_EXP 181
97413: PUSH
97414: LD_VAR 0 2
97418: ARRAY
97419: IFFALSE 97463
// tmp := tmp diff ( mc_need_heal [ i ] [ 1 ] union mc_need_heal [ i ] [ 2 ] ) ;
97421: LD_ADDR_VAR 0 5
97425: PUSH
97426: LD_VAR 0 5
97430: PUSH
97431: LD_EXP 181
97435: PUSH
97436: LD_VAR 0 2
97440: ARRAY
97441: PUSH
97442: LD_INT 1
97444: ARRAY
97445: PUSH
97446: LD_EXP 181
97450: PUSH
97451: LD_VAR 0 2
97455: ARRAY
97456: PUSH
97457: LD_INT 2
97459: ARRAY
97460: UNION
97461: DIFF
97462: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ) ;
97463: LD_ADDR_VAR 0 6
97467: PUSH
97468: LD_EXP 197
97472: PUSH
97473: LD_VAR 0 2
97477: ARRAY
97478: PPUSH
97479: LD_INT 2
97481: PUSH
97482: LD_INT 34
97484: PUSH
97485: LD_INT 13
97487: PUSH
97488: EMPTY
97489: LIST
97490: LIST
97491: PUSH
97492: LD_INT 34
97494: PUSH
97495: LD_INT 52
97497: PUSH
97498: EMPTY
97499: LIST
97500: LIST
97501: PUSH
97502: LD_INT 34
97504: PUSH
97505: LD_EXP 164
97509: PUSH
97510: EMPTY
97511: LIST
97512: LIST
97513: PUSH
97514: EMPTY
97515: LIST
97516: LIST
97517: LIST
97518: LIST
97519: PPUSH
97520: CALL_OW 72
97524: ST_TO_ADDR
// if cranes then
97525: LD_VAR 0 6
97529: IFFALSE 97665
// begin for j in cranes do
97531: LD_ADDR_VAR 0 3
97535: PUSH
97536: LD_VAR 0 6
97540: PUSH
97541: FOR_IN
97542: IFFALSE 97663
// begin if GetLives ( j ) = 1000 and not HasTask ( j ) then
97544: LD_VAR 0 3
97548: PPUSH
97549: CALL_OW 256
97553: PUSH
97554: LD_INT 1000
97556: EQUAL
97557: PUSH
97558: LD_VAR 0 3
97562: PPUSH
97563: CALL_OW 314
97567: NOT
97568: AND
97569: IFFALSE 97603
// ComRepairBuilding ( j , NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ) else
97571: LD_VAR 0 3
97575: PPUSH
97576: LD_EXP 179
97580: PUSH
97581: LD_VAR 0 2
97585: ARRAY
97586: PPUSH
97587: LD_VAR 0 3
97591: PPUSH
97592: CALL_OW 74
97596: PPUSH
97597: CALL_OW 130
97601: GO 97661
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
97603: LD_VAR 0 3
97607: PPUSH
97608: CALL_OW 256
97612: PUSH
97613: LD_INT 500
97615: LESS
97616: PUSH
97617: LD_VAR 0 3
97621: PPUSH
97622: LD_EXP 202
97626: PUSH
97627: LD_VAR 0 2
97631: ARRAY
97632: PPUSH
97633: CALL_OW 308
97637: NOT
97638: AND
97639: IFFALSE 97661
// ComMoveToArea ( j , mc_parking [ i ] ) ;
97641: LD_VAR 0 3
97645: PPUSH
97646: LD_EXP 202
97650: PUSH
97651: LD_VAR 0 2
97655: ARRAY
97656: PPUSH
97657: CALL_OW 113
// end ;
97661: GO 97541
97663: POP
97664: POP
// end ; if tmp > 3 then
97665: LD_VAR 0 5
97669: PUSH
97670: LD_INT 3
97672: GREATER
97673: IFFALSE 97693
// tmp := ShrinkArray ( tmp , 4 ) ;
97675: LD_ADDR_VAR 0 5
97679: PUSH
97680: LD_VAR 0 5
97684: PPUSH
97685: LD_INT 4
97687: PPUSH
97688: CALL 56923 0 2
97692: ST_TO_ADDR
// if not tmp then
97693: LD_VAR 0 5
97697: NOT
97698: IFFALSE 97702
// continue ;
97700: GO 97110
// for j in tmp do
97702: LD_ADDR_VAR 0 3
97706: PUSH
97707: LD_VAR 0 5
97711: PUSH
97712: FOR_IN
97713: IFFALSE 97972
// begin if IsInUnit ( j ) then
97715: LD_VAR 0 3
97719: PPUSH
97720: CALL_OW 310
97724: IFFALSE 97735
// ComExitBuilding ( j ) ;
97726: LD_VAR 0 3
97730: PPUSH
97731: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
97735: LD_VAR 0 3
97739: PUSH
97740: LD_EXP 180
97744: PUSH
97745: LD_VAR 0 2
97749: ARRAY
97750: IN
97751: NOT
97752: IFFALSE 97810
// begin SetTag ( j , 101 ) ;
97754: LD_VAR 0 3
97758: PPUSH
97759: LD_INT 101
97761: PPUSH
97762: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
97766: LD_ADDR_EXP 180
97770: PUSH
97771: LD_EXP 180
97775: PPUSH
97776: LD_VAR 0 2
97780: PUSH
97781: LD_EXP 180
97785: PUSH
97786: LD_VAR 0 2
97790: ARRAY
97791: PUSH
97792: LD_INT 1
97794: PLUS
97795: PUSH
97796: EMPTY
97797: LIST
97798: LIST
97799: PPUSH
97800: LD_VAR 0 3
97804: PPUSH
97805: CALL 24363 0 3
97809: ST_TO_ADDR
// end ; wait ( 1 ) ;
97810: LD_INT 1
97812: PPUSH
97813: CALL_OW 67
// to_repair_tmp := mc_building_need_repair [ i ] ;
97817: LD_ADDR_VAR 0 7
97821: PUSH
97822: LD_EXP 179
97826: PUSH
97827: LD_VAR 0 2
97831: ARRAY
97832: ST_TO_ADDR
// if mc_scan [ i ] then
97833: LD_EXP 201
97837: PUSH
97838: LD_VAR 0 2
97842: ARRAY
97843: IFFALSE 97905
// to_repair_tmp := UnitFilter ( mc_building_need_repair [ i ] , [ f_not , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_breastwork ] ] ) ;
97845: LD_ADDR_VAR 0 7
97849: PUSH
97850: LD_EXP 179
97854: PUSH
97855: LD_VAR 0 2
97859: ARRAY
97860: PPUSH
97861: LD_INT 3
97863: PUSH
97864: LD_INT 30
97866: PUSH
97867: LD_INT 32
97869: PUSH
97870: EMPTY
97871: LIST
97872: LIST
97873: PUSH
97874: LD_INT 30
97876: PUSH
97877: LD_INT 33
97879: PUSH
97880: EMPTY
97881: LIST
97882: LIST
97883: PUSH
97884: LD_INT 30
97886: PUSH
97887: LD_INT 31
97889: PUSH
97890: EMPTY
97891: LIST
97892: LIST
97893: PUSH
97894: EMPTY
97895: LIST
97896: LIST
97897: LIST
97898: LIST
97899: PPUSH
97900: CALL_OW 72
97904: ST_TO_ADDR
// if not to_repair_tmp then
97905: LD_VAR 0 7
97909: NOT
97910: IFFALSE 97914
// continue ;
97912: GO 97712
// to_repair := NearestUnitToUnit ( to_repair_tmp , j ) ;
97914: LD_ADDR_VAR 0 8
97918: PUSH
97919: LD_VAR 0 7
97923: PPUSH
97924: LD_VAR 0 3
97928: PPUSH
97929: CALL_OW 74
97933: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 10 then
97934: LD_VAR 0 8
97938: PPUSH
97939: LD_INT 16
97941: PPUSH
97942: CALL 26962 0 2
97946: PUSH
97947: LD_INT 4
97949: ARRAY
97950: PUSH
97951: LD_INT 10
97953: LESS
97954: IFFALSE 97970
// ComRepairBuilding ( j , to_repair ) ;
97956: LD_VAR 0 3
97960: PPUSH
97961: LD_VAR 0 8
97965: PPUSH
97966: CALL_OW 130
// end ;
97970: GO 97712
97972: POP
97973: POP
// end ;
97974: GO 97110
97976: POP
97977: POP
// end ;
97978: LD_VAR 0 1
97982: RET
// export function MC_Heal ; var i , j , tmp ; begin
97983: LD_INT 0
97985: PPUSH
97986: PPUSH
97987: PPUSH
97988: PPUSH
// if not mc_bases then
97989: LD_EXP 178
97993: NOT
97994: IFFALSE 97998
// exit ;
97996: GO 98400
// for i = 1 to mc_bases do
97998: LD_ADDR_VAR 0 2
98002: PUSH
98003: DOUBLE
98004: LD_INT 1
98006: DEC
98007: ST_TO_ADDR
98008: LD_EXP 178
98012: PUSH
98013: FOR_TO
98014: IFFALSE 98398
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
98016: LD_EXP 181
98020: PUSH
98021: LD_VAR 0 2
98025: ARRAY
98026: PUSH
98027: LD_INT 1
98029: ARRAY
98030: NOT
98031: PUSH
98032: LD_EXP 181
98036: PUSH
98037: LD_VAR 0 2
98041: ARRAY
98042: PUSH
98043: LD_INT 2
98045: ARRAY
98046: NOT
98047: AND
98048: IFFALSE 98086
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
98050: LD_ADDR_EXP 182
98054: PUSH
98055: LD_EXP 182
98059: PPUSH
98060: LD_VAR 0 2
98064: PPUSH
98065: EMPTY
98066: PPUSH
98067: CALL_OW 1
98071: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
98072: LD_VAR 0 2
98076: PPUSH
98077: LD_INT 102
98079: PPUSH
98080: CALL 92163 0 2
// continue ;
98084: GO 98013
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
98086: LD_ADDR_VAR 0 4
98090: PUSH
98091: LD_EXP 178
98095: PUSH
98096: LD_VAR 0 2
98100: ARRAY
98101: PPUSH
98102: LD_INT 25
98104: PUSH
98105: LD_INT 4
98107: PUSH
98108: EMPTY
98109: LIST
98110: LIST
98111: PPUSH
98112: CALL_OW 72
98116: ST_TO_ADDR
// if not tmp then
98117: LD_VAR 0 4
98121: NOT
98122: IFFALSE 98126
// continue ;
98124: GO 98013
// if mc_taming [ i ] then
98126: LD_EXP 209
98130: PUSH
98131: LD_VAR 0 2
98135: ARRAY
98136: IFFALSE 98160
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
98138: LD_ADDR_EXP 209
98142: PUSH
98143: LD_EXP 209
98147: PPUSH
98148: LD_VAR 0 2
98152: PPUSH
98153: EMPTY
98154: PPUSH
98155: CALL_OW 1
98159: ST_TO_ADDR
// for j in tmp do
98160: LD_ADDR_VAR 0 3
98164: PUSH
98165: LD_VAR 0 4
98169: PUSH
98170: FOR_IN
98171: IFFALSE 98394
// begin if IsInUnit ( j ) then
98173: LD_VAR 0 3
98177: PPUSH
98178: CALL_OW 310
98182: IFFALSE 98193
// ComExitBuilding ( j ) ;
98184: LD_VAR 0 3
98188: PPUSH
98189: CALL_OW 122
// if not j in mc_healers [ i ] then
98193: LD_VAR 0 3
98197: PUSH
98198: LD_EXP 182
98202: PUSH
98203: LD_VAR 0 2
98207: ARRAY
98208: IN
98209: NOT
98210: IFFALSE 98256
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
98212: LD_ADDR_EXP 182
98216: PUSH
98217: LD_EXP 182
98221: PPUSH
98222: LD_VAR 0 2
98226: PUSH
98227: LD_EXP 182
98231: PUSH
98232: LD_VAR 0 2
98236: ARRAY
98237: PUSH
98238: LD_INT 1
98240: PLUS
98241: PUSH
98242: EMPTY
98243: LIST
98244: LIST
98245: PPUSH
98246: LD_VAR 0 3
98250: PPUSH
98251: CALL 24363 0 3
98255: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
98256: LD_VAR 0 3
98260: PPUSH
98261: CALL_OW 110
98265: PUSH
98266: LD_INT 102
98268: NONEQUAL
98269: IFFALSE 98283
// SetTag ( j , 102 ) ;
98271: LD_VAR 0 3
98275: PPUSH
98276: LD_INT 102
98278: PPUSH
98279: CALL_OW 109
// Wait ( 3 ) ;
98283: LD_INT 3
98285: PPUSH
98286: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
98290: LD_EXP 181
98294: PUSH
98295: LD_VAR 0 2
98299: ARRAY
98300: PUSH
98301: LD_INT 1
98303: ARRAY
98304: IFFALSE 98336
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
98306: LD_VAR 0 3
98310: PPUSH
98311: LD_EXP 181
98315: PUSH
98316: LD_VAR 0 2
98320: ARRAY
98321: PUSH
98322: LD_INT 1
98324: ARRAY
98325: PUSH
98326: LD_INT 1
98328: ARRAY
98329: PPUSH
98330: CALL_OW 128
98334: GO 98392
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
98336: LD_VAR 0 3
98340: PPUSH
98341: CALL_OW 314
98345: NOT
98346: PUSH
98347: LD_EXP 181
98351: PUSH
98352: LD_VAR 0 2
98356: ARRAY
98357: PUSH
98358: LD_INT 2
98360: ARRAY
98361: AND
98362: IFFALSE 98392
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
98364: LD_VAR 0 3
98368: PPUSH
98369: LD_EXP 181
98373: PUSH
98374: LD_VAR 0 2
98378: ARRAY
98379: PUSH
98380: LD_INT 2
98382: ARRAY
98383: PUSH
98384: LD_INT 1
98386: ARRAY
98387: PPUSH
98388: CALL_OW 128
// end ;
98392: GO 98170
98394: POP
98395: POP
// end ;
98396: GO 98013
98398: POP
98399: POP
// end ;
98400: LD_VAR 0 1
98404: RET
// export function MC_Build ( ) ; var i , j , tmp , depot ; begin
98405: LD_INT 0
98407: PPUSH
98408: PPUSH
98409: PPUSH
98410: PPUSH
98411: PPUSH
// if not mc_bases then
98412: LD_EXP 178
98416: NOT
98417: IFFALSE 98421
// exit ;
98419: GO 99592
// for i = 1 to mc_bases do
98421: LD_ADDR_VAR 0 2
98425: PUSH
98426: DOUBLE
98427: LD_INT 1
98429: DEC
98430: ST_TO_ADDR
98431: LD_EXP 178
98435: PUSH
98436: FOR_TO
98437: IFFALSE 99590
// begin if mc_scan [ i ] then
98439: LD_EXP 201
98443: PUSH
98444: LD_VAR 0 2
98448: ARRAY
98449: IFFALSE 98453
// continue ;
98451: GO 98436
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
98453: LD_EXP 183
98457: PUSH
98458: LD_VAR 0 2
98462: ARRAY
98463: NOT
98464: PUSH
98465: LD_EXP 185
98469: PUSH
98470: LD_VAR 0 2
98474: ARRAY
98475: NOT
98476: AND
98477: PUSH
98478: LD_EXP 184
98482: PUSH
98483: LD_VAR 0 2
98487: ARRAY
98488: AND
98489: IFFALSE 98527
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
98491: LD_ADDR_EXP 184
98495: PUSH
98496: LD_EXP 184
98500: PPUSH
98501: LD_VAR 0 2
98505: PPUSH
98506: EMPTY
98507: PPUSH
98508: CALL_OW 1
98512: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
98513: LD_VAR 0 2
98517: PPUSH
98518: LD_INT 103
98520: PPUSH
98521: CALL 92163 0 2
// continue ;
98525: GO 98436
// end ; if mc_construct_list [ i ] then
98527: LD_EXP 185
98531: PUSH
98532: LD_VAR 0 2
98536: ARRAY
98537: IFFALSE 98757
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
98539: LD_ADDR_VAR 0 4
98543: PUSH
98544: LD_EXP 178
98548: PUSH
98549: LD_VAR 0 2
98553: ARRAY
98554: PPUSH
98555: LD_INT 25
98557: PUSH
98558: LD_INT 2
98560: PUSH
98561: EMPTY
98562: LIST
98563: LIST
98564: PPUSH
98565: CALL_OW 72
98569: PUSH
98570: LD_EXP 180
98574: PUSH
98575: LD_VAR 0 2
98579: ARRAY
98580: DIFF
98581: ST_TO_ADDR
// if not tmp then
98582: LD_VAR 0 4
98586: NOT
98587: IFFALSE 98591
// continue ;
98589: GO 98436
// for j in tmp do
98591: LD_ADDR_VAR 0 3
98595: PUSH
98596: LD_VAR 0 4
98600: PUSH
98601: FOR_IN
98602: IFFALSE 98753
// begin if not mc_builders [ i ] then
98604: LD_EXP 184
98608: PUSH
98609: LD_VAR 0 2
98613: ARRAY
98614: NOT
98615: IFFALSE 98673
// begin SetTag ( j , 103 ) ;
98617: LD_VAR 0 3
98621: PPUSH
98622: LD_INT 103
98624: PPUSH
98625: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
98629: LD_ADDR_EXP 184
98633: PUSH
98634: LD_EXP 184
98638: PPUSH
98639: LD_VAR 0 2
98643: PUSH
98644: LD_EXP 184
98648: PUSH
98649: LD_VAR 0 2
98653: ARRAY
98654: PUSH
98655: LD_INT 1
98657: PLUS
98658: PUSH
98659: EMPTY
98660: LIST
98661: LIST
98662: PPUSH
98663: LD_VAR 0 3
98667: PPUSH
98668: CALL 24363 0 3
98672: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
98673: LD_VAR 0 3
98677: PPUSH
98678: CALL_OW 310
98682: IFFALSE 98693
// ComExitBuilding ( j ) ;
98684: LD_VAR 0 3
98688: PPUSH
98689: CALL_OW 122
// wait ( 3 ) ;
98693: LD_INT 3
98695: PPUSH
98696: CALL_OW 67
// if not mc_construct_list [ i ] then
98700: LD_EXP 185
98704: PUSH
98705: LD_VAR 0 2
98709: ARRAY
98710: NOT
98711: IFFALSE 98715
// break ;
98713: GO 98753
// if not HasTask ( j ) then
98715: LD_VAR 0 3
98719: PPUSH
98720: CALL_OW 314
98724: NOT
98725: IFFALSE 98751
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
98727: LD_VAR 0 3
98731: PPUSH
98732: LD_EXP 185
98736: PUSH
98737: LD_VAR 0 2
98741: ARRAY
98742: PUSH
98743: LD_INT 1
98745: ARRAY
98746: PPUSH
98747: CALL 27226 0 2
// end ;
98751: GO 98601
98753: POP
98754: POP
// end else
98755: GO 99588
// if mc_build_list [ i ] then
98757: LD_EXP 183
98761: PUSH
98762: LD_VAR 0 2
98766: ARRAY
98767: IFFALSE 99588
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
98769: LD_ADDR_VAR 0 5
98773: PUSH
98774: LD_EXP 178
98778: PUSH
98779: LD_VAR 0 2
98783: ARRAY
98784: PPUSH
98785: LD_INT 2
98787: PUSH
98788: LD_INT 30
98790: PUSH
98791: LD_INT 0
98793: PUSH
98794: EMPTY
98795: LIST
98796: LIST
98797: PUSH
98798: LD_INT 30
98800: PUSH
98801: LD_INT 1
98803: PUSH
98804: EMPTY
98805: LIST
98806: LIST
98807: PUSH
98808: EMPTY
98809: LIST
98810: LIST
98811: LIST
98812: PPUSH
98813: CALL_OW 72
98817: ST_TO_ADDR
// if depot then
98818: LD_VAR 0 5
98822: IFFALSE 98840
// depot := depot [ 1 ] else
98824: LD_ADDR_VAR 0 5
98828: PUSH
98829: LD_VAR 0 5
98833: PUSH
98834: LD_INT 1
98836: ARRAY
98837: ST_TO_ADDR
98838: GO 98848
// depot := 0 ;
98840: LD_ADDR_VAR 0 5
98844: PUSH
98845: LD_INT 0
98847: ST_TO_ADDR
// if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
98848: LD_EXP 183
98852: PUSH
98853: LD_VAR 0 2
98857: ARRAY
98858: PUSH
98859: LD_INT 1
98861: ARRAY
98862: PUSH
98863: LD_INT 1
98865: ARRAY
98866: PPUSH
98867: CALL 27050 0 1
98871: PUSH
98872: LD_EXP 178
98876: PUSH
98877: LD_VAR 0 2
98881: ARRAY
98882: PPUSH
98883: LD_INT 2
98885: PUSH
98886: LD_INT 30
98888: PUSH
98889: LD_INT 2
98891: PUSH
98892: EMPTY
98893: LIST
98894: LIST
98895: PUSH
98896: LD_INT 30
98898: PUSH
98899: LD_INT 3
98901: PUSH
98902: EMPTY
98903: LIST
98904: LIST
98905: PUSH
98906: EMPTY
98907: LIST
98908: LIST
98909: LIST
98910: PPUSH
98911: CALL_OW 72
98915: NOT
98916: AND
98917: IFFALSE 99022
// begin for j = 1 to mc_build_list [ i ] do
98919: LD_ADDR_VAR 0 3
98923: PUSH
98924: DOUBLE
98925: LD_INT 1
98927: DEC
98928: ST_TO_ADDR
98929: LD_EXP 183
98933: PUSH
98934: LD_VAR 0 2
98938: ARRAY
98939: PUSH
98940: FOR_TO
98941: IFFALSE 99020
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
98943: LD_EXP 183
98947: PUSH
98948: LD_VAR 0 2
98952: ARRAY
98953: PUSH
98954: LD_VAR 0 3
98958: ARRAY
98959: PUSH
98960: LD_INT 1
98962: ARRAY
98963: PUSH
98964: LD_INT 2
98966: EQUAL
98967: IFFALSE 99018
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
98969: LD_ADDR_EXP 183
98973: PUSH
98974: LD_EXP 183
98978: PPUSH
98979: LD_VAR 0 2
98983: PPUSH
98984: LD_EXP 183
98988: PUSH
98989: LD_VAR 0 2
98993: ARRAY
98994: PPUSH
98995: LD_VAR 0 3
98999: PPUSH
99000: LD_INT 1
99002: PPUSH
99003: LD_INT 0
99005: PPUSH
99006: CALL 23781 0 4
99010: PPUSH
99011: CALL_OW 1
99015: ST_TO_ADDR
// break ;
99016: GO 99020
// end ;
99018: GO 98940
99020: POP
99021: POP
// end ; if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or ( depot and CanBeBuilt ( depot , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ) then
99022: LD_EXP 183
99026: PUSH
99027: LD_VAR 0 2
99031: ARRAY
99032: PUSH
99033: LD_INT 1
99035: ARRAY
99036: PUSH
99037: LD_INT 1
99039: ARRAY
99040: PUSH
99041: LD_INT 0
99043: EQUAL
99044: PUSH
99045: LD_VAR 0 5
99049: PUSH
99050: LD_VAR 0 5
99054: PPUSH
99055: LD_EXP 183
99059: PUSH
99060: LD_VAR 0 2
99064: ARRAY
99065: PUSH
99066: LD_INT 1
99068: ARRAY
99069: PUSH
99070: LD_INT 1
99072: ARRAY
99073: PPUSH
99074: LD_EXP 183
99078: PUSH
99079: LD_VAR 0 2
99083: ARRAY
99084: PUSH
99085: LD_INT 1
99087: ARRAY
99088: PUSH
99089: LD_INT 2
99091: ARRAY
99092: PPUSH
99093: LD_EXP 183
99097: PUSH
99098: LD_VAR 0 2
99102: ARRAY
99103: PUSH
99104: LD_INT 1
99106: ARRAY
99107: PUSH
99108: LD_INT 3
99110: ARRAY
99111: PPUSH
99112: LD_EXP 183
99116: PUSH
99117: LD_VAR 0 2
99121: ARRAY
99122: PUSH
99123: LD_INT 1
99125: ARRAY
99126: PUSH
99127: LD_INT 4
99129: ARRAY
99130: PPUSH
99131: CALL 32466 0 5
99135: AND
99136: OR
99137: IFFALSE 99418
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
99139: LD_ADDR_VAR 0 4
99143: PUSH
99144: LD_EXP 178
99148: PUSH
99149: LD_VAR 0 2
99153: ARRAY
99154: PPUSH
99155: LD_INT 25
99157: PUSH
99158: LD_INT 2
99160: PUSH
99161: EMPTY
99162: LIST
99163: LIST
99164: PPUSH
99165: CALL_OW 72
99169: PUSH
99170: LD_EXP 180
99174: PUSH
99175: LD_VAR 0 2
99179: ARRAY
99180: DIFF
99181: ST_TO_ADDR
// if not tmp then
99182: LD_VAR 0 4
99186: NOT
99187: IFFALSE 99191
// continue ;
99189: GO 98436
// for j in tmp do
99191: LD_ADDR_VAR 0 3
99195: PUSH
99196: LD_VAR 0 4
99200: PUSH
99201: FOR_IN
99202: IFFALSE 99414
// begin if not mc_builders [ i ] then
99204: LD_EXP 184
99208: PUSH
99209: LD_VAR 0 2
99213: ARRAY
99214: NOT
99215: IFFALSE 99273
// begin SetTag ( j , 103 ) ;
99217: LD_VAR 0 3
99221: PPUSH
99222: LD_INT 103
99224: PPUSH
99225: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
99229: LD_ADDR_EXP 184
99233: PUSH
99234: LD_EXP 184
99238: PPUSH
99239: LD_VAR 0 2
99243: PUSH
99244: LD_EXP 184
99248: PUSH
99249: LD_VAR 0 2
99253: ARRAY
99254: PUSH
99255: LD_INT 1
99257: PLUS
99258: PUSH
99259: EMPTY
99260: LIST
99261: LIST
99262: PPUSH
99263: LD_VAR 0 3
99267: PPUSH
99268: CALL 24363 0 3
99272: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
99273: LD_VAR 0 3
99277: PPUSH
99278: CALL_OW 310
99282: IFFALSE 99293
// ComExitBuilding ( j ) ;
99284: LD_VAR 0 3
99288: PPUSH
99289: CALL_OW 122
// wait ( 3 ) ;
99293: LD_INT 3
99295: PPUSH
99296: CALL_OW 67
// if not mc_build_list [ i ] then
99300: LD_EXP 183
99304: PUSH
99305: LD_VAR 0 2
99309: ARRAY
99310: NOT
99311: IFFALSE 99315
// break ;
99313: GO 99414
// if not HasTask ( j ) then
99315: LD_VAR 0 3
99319: PPUSH
99320: CALL_OW 314
99324: NOT
99325: IFFALSE 99412
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
99327: LD_VAR 0 3
99331: PPUSH
99332: LD_EXP 183
99336: PUSH
99337: LD_VAR 0 2
99341: ARRAY
99342: PUSH
99343: LD_INT 1
99345: ARRAY
99346: PUSH
99347: LD_INT 1
99349: ARRAY
99350: PPUSH
99351: LD_EXP 183
99355: PUSH
99356: LD_VAR 0 2
99360: ARRAY
99361: PUSH
99362: LD_INT 1
99364: ARRAY
99365: PUSH
99366: LD_INT 2
99368: ARRAY
99369: PPUSH
99370: LD_EXP 183
99374: PUSH
99375: LD_VAR 0 2
99379: ARRAY
99380: PUSH
99381: LD_INT 1
99383: ARRAY
99384: PUSH
99385: LD_INT 3
99387: ARRAY
99388: PPUSH
99389: LD_EXP 183
99393: PUSH
99394: LD_VAR 0 2
99398: ARRAY
99399: PUSH
99400: LD_INT 1
99402: ARRAY
99403: PUSH
99404: LD_INT 4
99406: ARRAY
99407: PPUSH
99408: CALL_OW 145
// end ;
99412: GO 99201
99414: POP
99415: POP
// end else
99416: GO 99588
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] , UnitFilter ( mc_bases [ i ] , [ f_type , unit_building ] ) , [ ] ) then
99418: LD_EXP 178
99422: PUSH
99423: LD_VAR 0 2
99427: ARRAY
99428: PPUSH
99429: LD_EXP 183
99433: PUSH
99434: LD_VAR 0 2
99438: ARRAY
99439: PUSH
99440: LD_INT 1
99442: ARRAY
99443: PUSH
99444: LD_INT 1
99446: ARRAY
99447: PPUSH
99448: LD_EXP 183
99452: PUSH
99453: LD_VAR 0 2
99457: ARRAY
99458: PUSH
99459: LD_INT 1
99461: ARRAY
99462: PUSH
99463: LD_INT 2
99465: ARRAY
99466: PPUSH
99467: LD_EXP 183
99471: PUSH
99472: LD_VAR 0 2
99476: ARRAY
99477: PUSH
99478: LD_INT 1
99480: ARRAY
99481: PUSH
99482: LD_INT 3
99484: ARRAY
99485: PPUSH
99486: LD_EXP 183
99490: PUSH
99491: LD_VAR 0 2
99495: ARRAY
99496: PUSH
99497: LD_INT 1
99499: ARRAY
99500: PUSH
99501: LD_INT 4
99503: ARRAY
99504: PPUSH
99505: LD_EXP 178
99509: PUSH
99510: LD_VAR 0 2
99514: ARRAY
99515: PPUSH
99516: LD_INT 21
99518: PUSH
99519: LD_INT 3
99521: PUSH
99522: EMPTY
99523: LIST
99524: LIST
99525: PPUSH
99526: CALL_OW 72
99530: PPUSH
99531: EMPTY
99532: PPUSH
99533: CALL 31216 0 7
99537: NOT
99538: IFFALSE 99588
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
99540: LD_ADDR_EXP 183
99544: PUSH
99545: LD_EXP 183
99549: PPUSH
99550: LD_VAR 0 2
99554: PPUSH
99555: LD_EXP 183
99559: PUSH
99560: LD_VAR 0 2
99564: ARRAY
99565: PPUSH
99566: LD_INT 1
99568: PPUSH
99569: LD_INT 1
99571: NEG
99572: PPUSH
99573: LD_INT 0
99575: PPUSH
99576: CALL 23781 0 4
99580: PPUSH
99581: CALL_OW 1
99585: ST_TO_ADDR
// continue ;
99586: GO 98436
// end ; end ; end ;
99588: GO 98436
99590: POP
99591: POP
// end ;
99592: LD_VAR 0 1
99596: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
99597: LD_INT 0
99599: PPUSH
99600: PPUSH
99601: PPUSH
99602: PPUSH
99603: PPUSH
99604: PPUSH
// if not mc_bases then
99605: LD_EXP 178
99609: NOT
99610: IFFALSE 99614
// exit ;
99612: GO 100041
// for i = 1 to mc_bases do
99614: LD_ADDR_VAR 0 2
99618: PUSH
99619: DOUBLE
99620: LD_INT 1
99622: DEC
99623: ST_TO_ADDR
99624: LD_EXP 178
99628: PUSH
99629: FOR_TO
99630: IFFALSE 100039
// begin tmp := mc_build_upgrade [ i ] ;
99632: LD_ADDR_VAR 0 4
99636: PUSH
99637: LD_EXP 210
99641: PUSH
99642: LD_VAR 0 2
99646: ARRAY
99647: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
99648: LD_ADDR_VAR 0 6
99652: PUSH
99653: LD_EXP 211
99657: PUSH
99658: LD_VAR 0 2
99662: ARRAY
99663: PPUSH
99664: LD_INT 2
99666: PUSH
99667: LD_INT 30
99669: PUSH
99670: LD_INT 6
99672: PUSH
99673: EMPTY
99674: LIST
99675: LIST
99676: PUSH
99677: LD_INT 30
99679: PUSH
99680: LD_INT 7
99682: PUSH
99683: EMPTY
99684: LIST
99685: LIST
99686: PUSH
99687: EMPTY
99688: LIST
99689: LIST
99690: LIST
99691: PPUSH
99692: CALL_OW 72
99696: ST_TO_ADDR
// if not tmp and not lab then
99697: LD_VAR 0 4
99701: NOT
99702: PUSH
99703: LD_VAR 0 6
99707: NOT
99708: AND
99709: IFFALSE 99713
// continue ;
99711: GO 99629
// if tmp then
99713: LD_VAR 0 4
99717: IFFALSE 99837
// for j in tmp do
99719: LD_ADDR_VAR 0 3
99723: PUSH
99724: LD_VAR 0 4
99728: PUSH
99729: FOR_IN
99730: IFFALSE 99835
// begin if UpgradeCost ( j ) then
99732: LD_VAR 0 3
99736: PPUSH
99737: CALL 30876 0 1
99741: IFFALSE 99833
// begin ComUpgrade ( j ) ;
99743: LD_VAR 0 3
99747: PPUSH
99748: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
99752: LD_ADDR_EXP 210
99756: PUSH
99757: LD_EXP 210
99761: PPUSH
99762: LD_VAR 0 2
99766: PPUSH
99767: LD_EXP 210
99771: PUSH
99772: LD_VAR 0 2
99776: ARRAY
99777: PUSH
99778: LD_VAR 0 3
99782: DIFF
99783: PPUSH
99784: CALL_OW 1
99788: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
99789: LD_ADDR_EXP 185
99793: PUSH
99794: LD_EXP 185
99798: PPUSH
99799: LD_VAR 0 2
99803: PUSH
99804: LD_EXP 185
99808: PUSH
99809: LD_VAR 0 2
99813: ARRAY
99814: PUSH
99815: LD_INT 1
99817: PLUS
99818: PUSH
99819: EMPTY
99820: LIST
99821: LIST
99822: PPUSH
99823: LD_VAR 0 3
99827: PPUSH
99828: CALL 24363 0 3
99832: ST_TO_ADDR
// end ; end ;
99833: GO 99729
99835: POP
99836: POP
// if not lab or not mc_lab_upgrade [ i ] then
99837: LD_VAR 0 6
99841: NOT
99842: PUSH
99843: LD_EXP 212
99847: PUSH
99848: LD_VAR 0 2
99852: ARRAY
99853: NOT
99854: OR
99855: IFFALSE 99859
// continue ;
99857: GO 99629
// for j in lab do
99859: LD_ADDR_VAR 0 3
99863: PUSH
99864: LD_VAR 0 6
99868: PUSH
99869: FOR_IN
99870: IFFALSE 100035
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
99872: LD_VAR 0 3
99876: PPUSH
99877: CALL_OW 266
99881: PUSH
99882: LD_INT 6
99884: PUSH
99885: LD_INT 7
99887: PUSH
99888: EMPTY
99889: LIST
99890: LIST
99891: IN
99892: PUSH
99893: LD_VAR 0 3
99897: PPUSH
99898: CALL_OW 461
99902: PUSH
99903: LD_INT 1
99905: NONEQUAL
99906: AND
99907: IFFALSE 100033
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
99909: LD_VAR 0 3
99913: PPUSH
99914: LD_EXP 212
99918: PUSH
99919: LD_VAR 0 2
99923: ARRAY
99924: PUSH
99925: LD_INT 1
99927: ARRAY
99928: PPUSH
99929: CALL 31081 0 2
99933: IFFALSE 100033
// begin ComCancel ( j ) ;
99935: LD_VAR 0 3
99939: PPUSH
99940: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
99944: LD_VAR 0 3
99948: PPUSH
99949: LD_EXP 212
99953: PUSH
99954: LD_VAR 0 2
99958: ARRAY
99959: PUSH
99960: LD_INT 1
99962: ARRAY
99963: PPUSH
99964: CALL_OW 207
// if not j in mc_construct_list [ i ] then
99968: LD_VAR 0 3
99972: PUSH
99973: LD_EXP 185
99977: PUSH
99978: LD_VAR 0 2
99982: ARRAY
99983: IN
99984: NOT
99985: IFFALSE 100031
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
99987: LD_ADDR_EXP 185
99991: PUSH
99992: LD_EXP 185
99996: PPUSH
99997: LD_VAR 0 2
100001: PUSH
100002: LD_EXP 185
100006: PUSH
100007: LD_VAR 0 2
100011: ARRAY
100012: PUSH
100013: LD_INT 1
100015: PLUS
100016: PUSH
100017: EMPTY
100018: LIST
100019: LIST
100020: PPUSH
100021: LD_VAR 0 3
100025: PPUSH
100026: CALL 24363 0 3
100030: ST_TO_ADDR
// break ;
100031: GO 100035
// end ; end ; end ;
100033: GO 99869
100035: POP
100036: POP
// end ;
100037: GO 99629
100039: POP
100040: POP
// end ;
100041: LD_VAR 0 1
100045: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
100046: LD_INT 0
100048: PPUSH
100049: PPUSH
100050: PPUSH
100051: PPUSH
100052: PPUSH
100053: PPUSH
100054: PPUSH
100055: PPUSH
100056: PPUSH
// if not mc_bases then
100057: LD_EXP 178
100061: NOT
100062: IFFALSE 100066
// exit ;
100064: GO 100471
// for i = 1 to mc_bases do
100066: LD_ADDR_VAR 0 2
100070: PUSH
100071: DOUBLE
100072: LD_INT 1
100074: DEC
100075: ST_TO_ADDR
100076: LD_EXP 178
100080: PUSH
100081: FOR_TO
100082: IFFALSE 100469
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
100084: LD_EXP 186
100088: PUSH
100089: LD_VAR 0 2
100093: ARRAY
100094: NOT
100095: PUSH
100096: LD_EXP 178
100100: PUSH
100101: LD_VAR 0 2
100105: ARRAY
100106: PPUSH
100107: LD_INT 30
100109: PUSH
100110: LD_INT 3
100112: PUSH
100113: EMPTY
100114: LIST
100115: LIST
100116: PPUSH
100117: CALL_OW 72
100121: NOT
100122: OR
100123: IFFALSE 100127
// continue ;
100125: GO 100081
// busy := false ;
100127: LD_ADDR_VAR 0 8
100131: PUSH
100132: LD_INT 0
100134: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
100135: LD_ADDR_VAR 0 4
100139: PUSH
100140: LD_EXP 178
100144: PUSH
100145: LD_VAR 0 2
100149: ARRAY
100150: PPUSH
100151: LD_INT 30
100153: PUSH
100154: LD_INT 3
100156: PUSH
100157: EMPTY
100158: LIST
100159: LIST
100160: PPUSH
100161: CALL_OW 72
100165: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
100166: LD_ADDR_VAR 0 6
100170: PUSH
100171: LD_EXP 186
100175: PUSH
100176: LD_VAR 0 2
100180: ARRAY
100181: PPUSH
100182: LD_INT 2
100184: PUSH
100185: LD_INT 30
100187: PUSH
100188: LD_INT 32
100190: PUSH
100191: EMPTY
100192: LIST
100193: LIST
100194: PUSH
100195: LD_INT 30
100197: PUSH
100198: LD_INT 33
100200: PUSH
100201: EMPTY
100202: LIST
100203: LIST
100204: PUSH
100205: EMPTY
100206: LIST
100207: LIST
100208: LIST
100209: PPUSH
100210: CALL_OW 72
100214: ST_TO_ADDR
// if not t then
100215: LD_VAR 0 6
100219: NOT
100220: IFFALSE 100224
// continue ;
100222: GO 100081
// for j in tmp do
100224: LD_ADDR_VAR 0 3
100228: PUSH
100229: LD_VAR 0 4
100233: PUSH
100234: FOR_IN
100235: IFFALSE 100265
// if not BuildingStatus ( j ) = bs_idle then
100237: LD_VAR 0 3
100241: PPUSH
100242: CALL_OW 461
100246: PUSH
100247: LD_INT 2
100249: EQUAL
100250: NOT
100251: IFFALSE 100263
// begin busy := true ;
100253: LD_ADDR_VAR 0 8
100257: PUSH
100258: LD_INT 1
100260: ST_TO_ADDR
// break ;
100261: GO 100265
// end ;
100263: GO 100234
100265: POP
100266: POP
// if busy then
100267: LD_VAR 0 8
100271: IFFALSE 100275
// continue ;
100273: GO 100081
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
100275: LD_ADDR_VAR 0 7
100279: PUSH
100280: LD_VAR 0 6
100284: PPUSH
100285: LD_INT 35
100287: PUSH
100288: LD_INT 0
100290: PUSH
100291: EMPTY
100292: LIST
100293: LIST
100294: PPUSH
100295: CALL_OW 72
100299: ST_TO_ADDR
// if tw then
100300: LD_VAR 0 7
100304: IFFALSE 100381
// begin tw := tw [ 1 ] ;
100306: LD_ADDR_VAR 0 7
100310: PUSH
100311: LD_VAR 0 7
100315: PUSH
100316: LD_INT 1
100318: ARRAY
100319: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
100320: LD_ADDR_VAR 0 9
100324: PUSH
100325: LD_VAR 0 7
100329: PPUSH
100330: LD_EXP 203
100334: PUSH
100335: LD_VAR 0 2
100339: ARRAY
100340: PPUSH
100341: CALL 29373 0 2
100345: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
100346: LD_EXP 217
100350: PUSH
100351: LD_VAR 0 2
100355: ARRAY
100356: IFFALSE 100379
// if not weapon in mc_allowed_tower_weapons [ i ] then
100358: LD_VAR 0 9
100362: PUSH
100363: LD_EXP 217
100367: PUSH
100368: LD_VAR 0 2
100372: ARRAY
100373: IN
100374: NOT
100375: IFFALSE 100379
// continue ;
100377: GO 100081
// end else
100379: GO 100444
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
100381: LD_ADDR_VAR 0 5
100385: PUSH
100386: LD_EXP 186
100390: PUSH
100391: LD_VAR 0 2
100395: ARRAY
100396: PPUSH
100397: LD_VAR 0 4
100401: PPUSH
100402: CALL 56156 0 2
100406: ST_TO_ADDR
// if not tmp2 then
100407: LD_VAR 0 5
100411: NOT
100412: IFFALSE 100416
// continue ;
100414: GO 100081
// tw := tmp2 [ 1 ] ;
100416: LD_ADDR_VAR 0 7
100420: PUSH
100421: LD_VAR 0 5
100425: PUSH
100426: LD_INT 1
100428: ARRAY
100429: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
100430: LD_ADDR_VAR 0 9
100434: PUSH
100435: LD_VAR 0 5
100439: PUSH
100440: LD_INT 2
100442: ARRAY
100443: ST_TO_ADDR
// end ; if not weapon then
100444: LD_VAR 0 9
100448: NOT
100449: IFFALSE 100453
// continue ;
100451: GO 100081
// ComPlaceWeapon ( tw , weapon ) ;
100453: LD_VAR 0 7
100457: PPUSH
100458: LD_VAR 0 9
100462: PPUSH
100463: CALL_OW 148
// end ;
100467: GO 100081
100469: POP
100470: POP
// end ;
100471: LD_VAR 0 1
100475: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list , r ; begin
100476: LD_INT 0
100478: PPUSH
100479: PPUSH
100480: PPUSH
100481: PPUSH
100482: PPUSH
100483: PPUSH
100484: PPUSH
// if not mc_bases then
100485: LD_EXP 178
100489: NOT
100490: IFFALSE 100494
// exit ;
100492: GO 101262
// for i = 1 to mc_bases do
100494: LD_ADDR_VAR 0 2
100498: PUSH
100499: DOUBLE
100500: LD_INT 1
100502: DEC
100503: ST_TO_ADDR
100504: LD_EXP 178
100508: PUSH
100509: FOR_TO
100510: IFFALSE 101260
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] or mc_scan [ i ] then
100512: LD_EXP 191
100516: PUSH
100517: LD_VAR 0 2
100521: ARRAY
100522: NOT
100523: PUSH
100524: LD_EXP 191
100528: PUSH
100529: LD_VAR 0 2
100533: ARRAY
100534: PUSH
100535: LD_EXP 192
100539: PUSH
100540: LD_VAR 0 2
100544: ARRAY
100545: EQUAL
100546: OR
100547: PUSH
100548: LD_EXP 201
100552: PUSH
100553: LD_VAR 0 2
100557: ARRAY
100558: OR
100559: IFFALSE 100563
// continue ;
100561: GO 100509
// if mc_miners [ i ] then
100563: LD_EXP 192
100567: PUSH
100568: LD_VAR 0 2
100572: ARRAY
100573: IFFALSE 100947
// begin for j = mc_miners [ i ] downto 1 do
100575: LD_ADDR_VAR 0 3
100579: PUSH
100580: DOUBLE
100581: LD_EXP 192
100585: PUSH
100586: LD_VAR 0 2
100590: ARRAY
100591: INC
100592: ST_TO_ADDR
100593: LD_INT 1
100595: PUSH
100596: FOR_DOWNTO
100597: IFFALSE 100945
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
100599: LD_EXP 192
100603: PUSH
100604: LD_VAR 0 2
100608: ARRAY
100609: PUSH
100610: LD_VAR 0 3
100614: ARRAY
100615: PPUSH
100616: CALL_OW 301
100620: PUSH
100621: LD_EXP 192
100625: PUSH
100626: LD_VAR 0 2
100630: ARRAY
100631: PUSH
100632: LD_VAR 0 3
100636: ARRAY
100637: PPUSH
100638: CALL_OW 257
100642: PUSH
100643: LD_INT 1
100645: NONEQUAL
100646: OR
100647: IFFALSE 100710
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
100649: LD_ADDR_VAR 0 5
100653: PUSH
100654: LD_EXP 192
100658: PUSH
100659: LD_VAR 0 2
100663: ARRAY
100664: PUSH
100665: LD_EXP 192
100669: PUSH
100670: LD_VAR 0 2
100674: ARRAY
100675: PUSH
100676: LD_VAR 0 3
100680: ARRAY
100681: DIFF
100682: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
100683: LD_ADDR_EXP 192
100687: PUSH
100688: LD_EXP 192
100692: PPUSH
100693: LD_VAR 0 2
100697: PPUSH
100698: LD_VAR 0 5
100702: PPUSH
100703: CALL_OW 1
100707: ST_TO_ADDR
// continue ;
100708: GO 100596
// end ; if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and not HasTask ( mc_miners [ i ] [ j ] ) then
100710: LD_EXP 192
100714: PUSH
100715: LD_VAR 0 2
100719: ARRAY
100720: PUSH
100721: LD_VAR 0 3
100725: ARRAY
100726: PPUSH
100727: CALL_OW 257
100731: PUSH
100732: LD_INT 1
100734: EQUAL
100735: PUSH
100736: LD_EXP 192
100740: PUSH
100741: LD_VAR 0 2
100745: ARRAY
100746: PUSH
100747: LD_VAR 0 3
100751: ARRAY
100752: PPUSH
100753: CALL_OW 459
100757: NOT
100758: AND
100759: PUSH
100760: LD_EXP 192
100764: PUSH
100765: LD_VAR 0 2
100769: ARRAY
100770: PUSH
100771: LD_VAR 0 3
100775: ARRAY
100776: PPUSH
100777: CALL_OW 314
100781: NOT
100782: AND
100783: IFFALSE 100943
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
100785: LD_EXP 192
100789: PUSH
100790: LD_VAR 0 2
100794: ARRAY
100795: PUSH
100796: LD_VAR 0 3
100800: ARRAY
100801: PPUSH
100802: CALL_OW 310
100806: IFFALSE 100829
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
100808: LD_EXP 192
100812: PUSH
100813: LD_VAR 0 2
100817: ARRAY
100818: PUSH
100819: LD_VAR 0 3
100823: ARRAY
100824: PPUSH
100825: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
100829: LD_EXP 192
100833: PUSH
100834: LD_VAR 0 2
100838: ARRAY
100839: PUSH
100840: LD_VAR 0 3
100844: ARRAY
100845: PPUSH
100846: CALL_OW 314
100850: NOT
100851: IFFALSE 100943
// begin r := rand ( 1 , mc_mines [ i ] ) ;
100853: LD_ADDR_VAR 0 7
100857: PUSH
100858: LD_INT 1
100860: PPUSH
100861: LD_EXP 191
100865: PUSH
100866: LD_VAR 0 2
100870: ARRAY
100871: PPUSH
100872: CALL_OW 12
100876: ST_TO_ADDR
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ r ] [ 1 ] , mc_mines [ i ] [ r ] [ 2 ] , 0 ) ;
100877: LD_EXP 192
100881: PUSH
100882: LD_VAR 0 2
100886: ARRAY
100887: PUSH
100888: LD_VAR 0 3
100892: ARRAY
100893: PPUSH
100894: LD_EXP 191
100898: PUSH
100899: LD_VAR 0 2
100903: ARRAY
100904: PUSH
100905: LD_VAR 0 7
100909: ARRAY
100910: PUSH
100911: LD_INT 1
100913: ARRAY
100914: PPUSH
100915: LD_EXP 191
100919: PUSH
100920: LD_VAR 0 2
100924: ARRAY
100925: PUSH
100926: LD_VAR 0 7
100930: ARRAY
100931: PUSH
100932: LD_INT 2
100934: ARRAY
100935: PPUSH
100936: LD_INT 0
100938: PPUSH
100939: CALL_OW 193
// end ; end ; end ;
100943: GO 100596
100945: POP
100946: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
100947: LD_ADDR_VAR 0 5
100951: PUSH
100952: LD_EXP 178
100956: PUSH
100957: LD_VAR 0 2
100961: ARRAY
100962: PPUSH
100963: LD_INT 2
100965: PUSH
100966: LD_INT 30
100968: PUSH
100969: LD_INT 4
100971: PUSH
100972: EMPTY
100973: LIST
100974: LIST
100975: PUSH
100976: LD_INT 30
100978: PUSH
100979: LD_INT 5
100981: PUSH
100982: EMPTY
100983: LIST
100984: LIST
100985: PUSH
100986: LD_INT 30
100988: PUSH
100989: LD_INT 32
100991: PUSH
100992: EMPTY
100993: LIST
100994: LIST
100995: PUSH
100996: EMPTY
100997: LIST
100998: LIST
100999: LIST
101000: LIST
101001: PPUSH
101002: CALL_OW 72
101006: ST_TO_ADDR
// if not tmp then
101007: LD_VAR 0 5
101011: NOT
101012: IFFALSE 101016
// continue ;
101014: GO 100509
// list := [ ] ;
101016: LD_ADDR_VAR 0 6
101020: PUSH
101021: EMPTY
101022: ST_TO_ADDR
// for j in tmp do
101023: LD_ADDR_VAR 0 3
101027: PUSH
101028: LD_VAR 0 5
101032: PUSH
101033: FOR_IN
101034: IFFALSE 101103
// begin for k in UnitsInside ( j ) do
101036: LD_ADDR_VAR 0 4
101040: PUSH
101041: LD_VAR 0 3
101045: PPUSH
101046: CALL_OW 313
101050: PUSH
101051: FOR_IN
101052: IFFALSE 101099
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
101054: LD_VAR 0 4
101058: PPUSH
101059: CALL_OW 257
101063: PUSH
101064: LD_INT 1
101066: EQUAL
101067: PUSH
101068: LD_VAR 0 4
101072: PPUSH
101073: CALL_OW 459
101077: NOT
101078: AND
101079: IFFALSE 101097
// list := list ^ k ;
101081: LD_ADDR_VAR 0 6
101085: PUSH
101086: LD_VAR 0 6
101090: PUSH
101091: LD_VAR 0 4
101095: ADD
101096: ST_TO_ADDR
101097: GO 101051
101099: POP
101100: POP
// end ;
101101: GO 101033
101103: POP
101104: POP
// list := list diff mc_miners [ i ] ;
101105: LD_ADDR_VAR 0 6
101109: PUSH
101110: LD_VAR 0 6
101114: PUSH
101115: LD_EXP 192
101119: PUSH
101120: LD_VAR 0 2
101124: ARRAY
101125: DIFF
101126: ST_TO_ADDR
// if not list then
101127: LD_VAR 0 6
101131: NOT
101132: IFFALSE 101136
// continue ;
101134: GO 100509
// k := mc_mines [ i ] - mc_miners [ i ] ;
101136: LD_ADDR_VAR 0 4
101140: PUSH
101141: LD_EXP 191
101145: PUSH
101146: LD_VAR 0 2
101150: ARRAY
101151: PUSH
101152: LD_EXP 192
101156: PUSH
101157: LD_VAR 0 2
101161: ARRAY
101162: MINUS
101163: ST_TO_ADDR
// if k > list then
101164: LD_VAR 0 4
101168: PUSH
101169: LD_VAR 0 6
101173: GREATER
101174: IFFALSE 101186
// k := list ;
101176: LD_ADDR_VAR 0 4
101180: PUSH
101181: LD_VAR 0 6
101185: ST_TO_ADDR
// for j = 1 to k do
101186: LD_ADDR_VAR 0 3
101190: PUSH
101191: DOUBLE
101192: LD_INT 1
101194: DEC
101195: ST_TO_ADDR
101196: LD_VAR 0 4
101200: PUSH
101201: FOR_TO
101202: IFFALSE 101256
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
101204: LD_ADDR_EXP 192
101208: PUSH
101209: LD_EXP 192
101213: PPUSH
101214: LD_VAR 0 2
101218: PUSH
101219: LD_EXP 192
101223: PUSH
101224: LD_VAR 0 2
101228: ARRAY
101229: PUSH
101230: LD_INT 1
101232: PLUS
101233: PUSH
101234: EMPTY
101235: LIST
101236: LIST
101237: PPUSH
101238: LD_VAR 0 6
101242: PUSH
101243: LD_VAR 0 3
101247: ARRAY
101248: PPUSH
101249: CALL 24363 0 3
101253: ST_TO_ADDR
101254: GO 101201
101256: POP
101257: POP
// end ;
101258: GO 100509
101260: POP
101261: POP
// end ;
101262: LD_VAR 0 1
101266: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , side , target , cargo , depot , fac , components ; begin
101267: LD_INT 0
101269: PPUSH
101270: PPUSH
101271: PPUSH
101272: PPUSH
101273: PPUSH
101274: PPUSH
101275: PPUSH
101276: PPUSH
101277: PPUSH
101278: PPUSH
101279: PPUSH
// if not mc_bases then
101280: LD_EXP 178
101284: NOT
101285: IFFALSE 101289
// exit ;
101287: GO 103112
// for i = 1 to mc_bases do
101289: LD_ADDR_VAR 0 2
101293: PUSH
101294: DOUBLE
101295: LD_INT 1
101297: DEC
101298: ST_TO_ADDR
101299: LD_EXP 178
101303: PUSH
101304: FOR_TO
101305: IFFALSE 103110
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
101307: LD_EXP 178
101311: PUSH
101312: LD_VAR 0 2
101316: ARRAY
101317: NOT
101318: PUSH
101319: LD_EXP 185
101323: PUSH
101324: LD_VAR 0 2
101328: ARRAY
101329: OR
101330: IFFALSE 101334
// continue ;
101332: GO 101304
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
101334: LD_EXP 194
101338: PUSH
101339: LD_VAR 0 2
101343: ARRAY
101344: NOT
101345: PUSH
101346: LD_EXP 195
101350: PUSH
101351: LD_VAR 0 2
101355: ARRAY
101356: AND
101357: IFFALSE 101395
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
101359: LD_ADDR_EXP 195
101363: PUSH
101364: LD_EXP 195
101368: PPUSH
101369: LD_VAR 0 2
101373: PPUSH
101374: EMPTY
101375: PPUSH
101376: CALL_OW 1
101380: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
101381: LD_VAR 0 2
101385: PPUSH
101386: LD_INT 107
101388: PPUSH
101389: CALL 92163 0 2
// continue ;
101393: GO 101304
// end ; target := [ ] ;
101395: LD_ADDR_VAR 0 7
101399: PUSH
101400: EMPTY
101401: ST_TO_ADDR
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
101402: LD_ADDR_VAR 0 6
101406: PUSH
101407: LD_EXP 178
101411: PUSH
101412: LD_VAR 0 2
101416: ARRAY
101417: PUSH
101418: LD_INT 1
101420: ARRAY
101421: PPUSH
101422: CALL_OW 255
101426: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
101427: LD_ADDR_VAR 0 9
101431: PUSH
101432: LD_EXP 178
101436: PUSH
101437: LD_VAR 0 2
101441: ARRAY
101442: PPUSH
101443: LD_INT 2
101445: PUSH
101446: LD_INT 30
101448: PUSH
101449: LD_INT 0
101451: PUSH
101452: EMPTY
101453: LIST
101454: LIST
101455: PUSH
101456: LD_INT 30
101458: PUSH
101459: LD_INT 1
101461: PUSH
101462: EMPTY
101463: LIST
101464: LIST
101465: PUSH
101466: EMPTY
101467: LIST
101468: LIST
101469: LIST
101470: PPUSH
101471: CALL_OW 72
101475: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
101476: LD_ADDR_VAR 0 3
101480: PUSH
101481: DOUBLE
101482: LD_EXP 194
101486: PUSH
101487: LD_VAR 0 2
101491: ARRAY
101492: INC
101493: ST_TO_ADDR
101494: LD_INT 1
101496: PUSH
101497: FOR_DOWNTO
101498: IFFALSE 101743
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
101500: LD_EXP 194
101504: PUSH
101505: LD_VAR 0 2
101509: ARRAY
101510: PUSH
101511: LD_VAR 0 3
101515: ARRAY
101516: PUSH
101517: LD_INT 2
101519: ARRAY
101520: PPUSH
101521: LD_EXP 194
101525: PUSH
101526: LD_VAR 0 2
101530: ARRAY
101531: PUSH
101532: LD_VAR 0 3
101536: ARRAY
101537: PUSH
101538: LD_INT 3
101540: ARRAY
101541: PPUSH
101542: CALL_OW 488
101546: PUSH
101547: LD_EXP 194
101551: PUSH
101552: LD_VAR 0 2
101556: ARRAY
101557: PUSH
101558: LD_VAR 0 3
101562: ARRAY
101563: PUSH
101564: LD_INT 2
101566: ARRAY
101567: PPUSH
101568: LD_EXP 194
101572: PUSH
101573: LD_VAR 0 2
101577: ARRAY
101578: PUSH
101579: LD_VAR 0 3
101583: ARRAY
101584: PUSH
101585: LD_INT 3
101587: ARRAY
101588: PPUSH
101589: CALL_OW 284
101593: PUSH
101594: LD_INT 0
101596: EQUAL
101597: AND
101598: IFFALSE 101653
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
101600: LD_ADDR_VAR 0 5
101604: PUSH
101605: LD_EXP 194
101609: PUSH
101610: LD_VAR 0 2
101614: ARRAY
101615: PPUSH
101616: LD_VAR 0 3
101620: PPUSH
101621: CALL_OW 3
101625: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
101626: LD_ADDR_EXP 194
101630: PUSH
101631: LD_EXP 194
101635: PPUSH
101636: LD_VAR 0 2
101640: PPUSH
101641: LD_VAR 0 5
101645: PPUSH
101646: CALL_OW 1
101650: ST_TO_ADDR
// continue ;
101651: GO 101497
// end ; if DangerAtRangeXY ( side , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
101653: LD_VAR 0 6
101657: PPUSH
101658: LD_EXP 194
101662: PUSH
101663: LD_VAR 0 2
101667: ARRAY
101668: PUSH
101669: LD_VAR 0 3
101673: ARRAY
101674: PUSH
101675: LD_INT 2
101677: ARRAY
101678: PPUSH
101679: LD_EXP 194
101683: PUSH
101684: LD_VAR 0 2
101688: ARRAY
101689: PUSH
101690: LD_VAR 0 3
101694: ARRAY
101695: PUSH
101696: LD_INT 3
101698: ARRAY
101699: PPUSH
101700: LD_INT 30
101702: PPUSH
101703: CALL 25259 0 4
101707: PUSH
101708: LD_INT 4
101710: ARRAY
101711: PUSH
101712: LD_INT 0
101714: EQUAL
101715: IFFALSE 101741
// begin target := mc_crates [ i ] [ j ] ;
101717: LD_ADDR_VAR 0 7
101721: PUSH
101722: LD_EXP 194
101726: PUSH
101727: LD_VAR 0 2
101731: ARRAY
101732: PUSH
101733: LD_VAR 0 3
101737: ARRAY
101738: ST_TO_ADDR
// break ;
101739: GO 101743
// end ; end ;
101741: GO 101497
101743: POP
101744: POP
// if not target then
101745: LD_VAR 0 7
101749: NOT
101750: IFFALSE 101754
// continue ;
101752: GO 101304
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
101754: LD_ADDR_VAR 0 8
101758: PUSH
101759: LD_EXP 197
101763: PUSH
101764: LD_VAR 0 2
101768: ARRAY
101769: PPUSH
101770: LD_INT 2
101772: PUSH
101773: LD_INT 3
101775: PUSH
101776: LD_INT 58
101778: PUSH
101779: EMPTY
101780: LIST
101781: PUSH
101782: EMPTY
101783: LIST
101784: LIST
101785: PUSH
101786: LD_INT 61
101788: PUSH
101789: EMPTY
101790: LIST
101791: PUSH
101792: LD_INT 33
101794: PUSH
101795: LD_INT 5
101797: PUSH
101798: EMPTY
101799: LIST
101800: LIST
101801: PUSH
101802: LD_INT 33
101804: PUSH
101805: LD_INT 3
101807: PUSH
101808: EMPTY
101809: LIST
101810: LIST
101811: PUSH
101812: EMPTY
101813: LIST
101814: LIST
101815: LIST
101816: LIST
101817: LIST
101818: PUSH
101819: LD_INT 2
101821: PUSH
101822: LD_INT 34
101824: PUSH
101825: LD_INT 32
101827: PUSH
101828: EMPTY
101829: LIST
101830: LIST
101831: PUSH
101832: LD_INT 34
101834: PUSH
101835: LD_INT 51
101837: PUSH
101838: EMPTY
101839: LIST
101840: LIST
101841: PUSH
101842: LD_INT 34
101844: PUSH
101845: LD_INT 12
101847: PUSH
101848: EMPTY
101849: LIST
101850: LIST
101851: PUSH
101852: EMPTY
101853: LIST
101854: LIST
101855: LIST
101856: LIST
101857: PUSH
101858: EMPTY
101859: LIST
101860: LIST
101861: PPUSH
101862: CALL_OW 72
101866: ST_TO_ADDR
// if not cargo then
101867: LD_VAR 0 8
101871: NOT
101872: IFFALSE 102578
// begin if mc_crates_collector [ i ] < 5 then
101874: LD_EXP 195
101878: PUSH
101879: LD_VAR 0 2
101883: ARRAY
101884: PUSH
101885: LD_INT 5
101887: LESS
101888: IFFALSE 102254
// begin if mc_ape [ i ] then
101890: LD_EXP 207
101894: PUSH
101895: LD_VAR 0 2
101899: ARRAY
101900: IFFALSE 101947
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
101902: LD_ADDR_VAR 0 5
101906: PUSH
101907: LD_EXP 207
101911: PUSH
101912: LD_VAR 0 2
101916: ARRAY
101917: PPUSH
101918: LD_INT 25
101920: PUSH
101921: LD_INT 16
101923: PUSH
101924: EMPTY
101925: LIST
101926: LIST
101927: PUSH
101928: LD_INT 24
101930: PUSH
101931: LD_INT 750
101933: PUSH
101934: EMPTY
101935: LIST
101936: LIST
101937: PUSH
101938: EMPTY
101939: LIST
101940: LIST
101941: PPUSH
101942: CALL_OW 72
101946: ST_TO_ADDR
// if not tmp then
101947: LD_VAR 0 5
101951: NOT
101952: IFFALSE 101999
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
101954: LD_ADDR_VAR 0 5
101958: PUSH
101959: LD_EXP 178
101963: PUSH
101964: LD_VAR 0 2
101968: ARRAY
101969: PPUSH
101970: LD_INT 25
101972: PUSH
101973: LD_INT 2
101975: PUSH
101976: EMPTY
101977: LIST
101978: LIST
101979: PUSH
101980: LD_INT 24
101982: PUSH
101983: LD_INT 750
101985: PUSH
101986: EMPTY
101987: LIST
101988: LIST
101989: PUSH
101990: EMPTY
101991: LIST
101992: LIST
101993: PPUSH
101994: CALL_OW 72
101998: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
101999: LD_EXP 207
102003: PUSH
102004: LD_VAR 0 2
102008: ARRAY
102009: PUSH
102010: LD_EXP 178
102014: PUSH
102015: LD_VAR 0 2
102019: ARRAY
102020: PPUSH
102021: LD_INT 25
102023: PUSH
102024: LD_INT 2
102026: PUSH
102027: EMPTY
102028: LIST
102029: LIST
102030: PUSH
102031: LD_INT 24
102033: PUSH
102034: LD_INT 750
102036: PUSH
102037: EMPTY
102038: LIST
102039: LIST
102040: PUSH
102041: EMPTY
102042: LIST
102043: LIST
102044: PPUSH
102045: CALL_OW 72
102049: AND
102050: PUSH
102051: LD_VAR 0 5
102055: PUSH
102056: LD_INT 5
102058: LESS
102059: AND
102060: IFFALSE 102142
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
102062: LD_ADDR_VAR 0 3
102066: PUSH
102067: LD_EXP 178
102071: PUSH
102072: LD_VAR 0 2
102076: ARRAY
102077: PPUSH
102078: LD_INT 25
102080: PUSH
102081: LD_INT 2
102083: PUSH
102084: EMPTY
102085: LIST
102086: LIST
102087: PUSH
102088: LD_INT 24
102090: PUSH
102091: LD_INT 750
102093: PUSH
102094: EMPTY
102095: LIST
102096: LIST
102097: PUSH
102098: EMPTY
102099: LIST
102100: LIST
102101: PPUSH
102102: CALL_OW 72
102106: PUSH
102107: FOR_IN
102108: IFFALSE 102140
// begin tmp := tmp union j ;
102110: LD_ADDR_VAR 0 5
102114: PUSH
102115: LD_VAR 0 5
102119: PUSH
102120: LD_VAR 0 3
102124: UNION
102125: ST_TO_ADDR
// if tmp >= 5 then
102126: LD_VAR 0 5
102130: PUSH
102131: LD_INT 5
102133: GREATEREQUAL
102134: IFFALSE 102138
// break ;
102136: GO 102140
// end ;
102138: GO 102107
102140: POP
102141: POP
// end ; if not tmp then
102142: LD_VAR 0 5
102146: NOT
102147: IFFALSE 102151
// continue ;
102149: GO 101304
// for j in tmp do
102151: LD_ADDR_VAR 0 3
102155: PUSH
102156: LD_VAR 0 5
102160: PUSH
102161: FOR_IN
102162: IFFALSE 102252
// if not GetTag ( j ) then
102164: LD_VAR 0 3
102168: PPUSH
102169: CALL_OW 110
102173: NOT
102174: IFFALSE 102250
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
102176: LD_ADDR_EXP 195
102180: PUSH
102181: LD_EXP 195
102185: PPUSH
102186: LD_VAR 0 2
102190: PUSH
102191: LD_EXP 195
102195: PUSH
102196: LD_VAR 0 2
102200: ARRAY
102201: PUSH
102202: LD_INT 1
102204: PLUS
102205: PUSH
102206: EMPTY
102207: LIST
102208: LIST
102209: PPUSH
102210: LD_VAR 0 3
102214: PPUSH
102215: CALL 24363 0 3
102219: ST_TO_ADDR
// SetTag ( j , 107 ) ;
102220: LD_VAR 0 3
102224: PPUSH
102225: LD_INT 107
102227: PPUSH
102228: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
102232: LD_EXP 195
102236: PUSH
102237: LD_VAR 0 2
102241: ARRAY
102242: PUSH
102243: LD_INT 5
102245: GREATEREQUAL
102246: IFFALSE 102250
// break ;
102248: GO 102252
// end ;
102250: GO 102161
102252: POP
102253: POP
// end ; if mc_crates_collector [ i ] and target then
102254: LD_EXP 195
102258: PUSH
102259: LD_VAR 0 2
102263: ARRAY
102264: PUSH
102265: LD_VAR 0 7
102269: AND
102270: IFFALSE 102576
// begin if mc_crates_collector [ i ] < target [ 1 ] then
102272: LD_EXP 195
102276: PUSH
102277: LD_VAR 0 2
102281: ARRAY
102282: PUSH
102283: LD_VAR 0 7
102287: PUSH
102288: LD_INT 1
102290: ARRAY
102291: LESS
102292: IFFALSE 102312
// tmp := mc_crates_collector [ i ] else
102294: LD_ADDR_VAR 0 5
102298: PUSH
102299: LD_EXP 195
102303: PUSH
102304: LD_VAR 0 2
102308: ARRAY
102309: ST_TO_ADDR
102310: GO 102326
// tmp := target [ 1 ] ;
102312: LD_ADDR_VAR 0 5
102316: PUSH
102317: LD_VAR 0 7
102321: PUSH
102322: LD_INT 1
102324: ARRAY
102325: ST_TO_ADDR
// k := 0 ;
102326: LD_ADDR_VAR 0 4
102330: PUSH
102331: LD_INT 0
102333: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
102334: LD_ADDR_VAR 0 3
102338: PUSH
102339: LD_EXP 195
102343: PUSH
102344: LD_VAR 0 2
102348: ARRAY
102349: PUSH
102350: FOR_IN
102351: IFFALSE 102574
// begin k := k + 1 ;
102353: LD_ADDR_VAR 0 4
102357: PUSH
102358: LD_VAR 0 4
102362: PUSH
102363: LD_INT 1
102365: PLUS
102366: ST_TO_ADDR
// if k > tmp then
102367: LD_VAR 0 4
102371: PUSH
102372: LD_VAR 0 5
102376: GREATER
102377: IFFALSE 102381
// break ;
102379: GO 102574
// if not GetClass ( j ) in [ 2 , 16 ] then
102381: LD_VAR 0 3
102385: PPUSH
102386: CALL_OW 257
102390: PUSH
102391: LD_INT 2
102393: PUSH
102394: LD_INT 16
102396: PUSH
102397: EMPTY
102398: LIST
102399: LIST
102400: IN
102401: NOT
102402: IFFALSE 102455
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
102404: LD_ADDR_EXP 195
102408: PUSH
102409: LD_EXP 195
102413: PPUSH
102414: LD_VAR 0 2
102418: PPUSH
102419: LD_EXP 195
102423: PUSH
102424: LD_VAR 0 2
102428: ARRAY
102429: PUSH
102430: LD_VAR 0 3
102434: DIFF
102435: PPUSH
102436: CALL_OW 1
102440: ST_TO_ADDR
// SetTag ( j , 0 ) ;
102441: LD_VAR 0 3
102445: PPUSH
102446: LD_INT 0
102448: PPUSH
102449: CALL_OW 109
// continue ;
102453: GO 102350
// end ; if IsInUnit ( j ) then
102455: LD_VAR 0 3
102459: PPUSH
102460: CALL_OW 310
102464: IFFALSE 102475
// ComExitBuilding ( j ) ;
102466: LD_VAR 0 3
102470: PPUSH
102471: CALL_OW 122
// wait ( 3 ) ;
102475: LD_INT 3
102477: PPUSH
102478: CALL_OW 67
// if HasTask ( j ) and DangerAtRangeXY ( side , target [ 2 ] , target [ 3 ] , 30 ) [ 4 ] then
102482: LD_VAR 0 3
102486: PPUSH
102487: CALL_OW 314
102491: PUSH
102492: LD_VAR 0 6
102496: PPUSH
102497: LD_VAR 0 7
102501: PUSH
102502: LD_INT 2
102504: ARRAY
102505: PPUSH
102506: LD_VAR 0 7
102510: PUSH
102511: LD_INT 3
102513: ARRAY
102514: PPUSH
102515: LD_INT 30
102517: PPUSH
102518: CALL 25259 0 4
102522: PUSH
102523: LD_INT 4
102525: ARRAY
102526: AND
102527: IFFALSE 102545
// ComStandNearbyBuilding ( j , depot ) else
102529: LD_VAR 0 3
102533: PPUSH
102534: LD_VAR 0 9
102538: PPUSH
102539: CALL 20788 0 2
102543: GO 102572
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
102545: LD_VAR 0 3
102549: PPUSH
102550: LD_VAR 0 7
102554: PUSH
102555: LD_INT 2
102557: ARRAY
102558: PPUSH
102559: LD_VAR 0 7
102563: PUSH
102564: LD_INT 3
102566: ARRAY
102567: PPUSH
102568: CALL_OW 117
// end ;
102572: GO 102350
102574: POP
102575: POP
// end ; end else
102576: GO 103108
// begin for j in cargo do
102578: LD_ADDR_VAR 0 3
102582: PUSH
102583: LD_VAR 0 8
102587: PUSH
102588: FOR_IN
102589: IFFALSE 103106
// begin if GetTag ( j ) <> 0 then
102591: LD_VAR 0 3
102595: PPUSH
102596: CALL_OW 110
102600: PUSH
102601: LD_INT 0
102603: NONEQUAL
102604: IFFALSE 102608
// continue ;
102606: GO 102588
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
102608: LD_VAR 0 3
102612: PPUSH
102613: CALL_OW 256
102617: PUSH
102618: LD_INT 1000
102620: LESS
102621: PUSH
102622: LD_VAR 0 3
102626: PPUSH
102627: LD_EXP 202
102631: PUSH
102632: LD_VAR 0 2
102636: ARRAY
102637: PPUSH
102638: CALL_OW 308
102642: NOT
102643: AND
102644: IFFALSE 102666
// ComMoveToArea ( j , mc_parking [ i ] ) ;
102646: LD_VAR 0 3
102650: PPUSH
102651: LD_EXP 202
102655: PUSH
102656: LD_VAR 0 2
102660: ARRAY
102661: PPUSH
102662: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
102666: LD_VAR 0 3
102670: PPUSH
102671: CALL_OW 256
102675: PUSH
102676: LD_INT 1000
102678: LESS
102679: PUSH
102680: LD_VAR 0 3
102684: PPUSH
102685: LD_EXP 202
102689: PUSH
102690: LD_VAR 0 2
102694: ARRAY
102695: PPUSH
102696: CALL_OW 308
102700: AND
102701: IFFALSE 102705
// continue ;
102703: GO 102588
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
102705: LD_VAR 0 3
102709: PPUSH
102710: CALL_OW 262
102714: PUSH
102715: LD_INT 2
102717: EQUAL
102718: PUSH
102719: LD_VAR 0 3
102723: PPUSH
102724: CALL_OW 261
102728: PUSH
102729: LD_INT 15
102731: LESS
102732: AND
102733: IFFALSE 102737
// continue ;
102735: GO 102588
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
102737: LD_VAR 0 3
102741: PPUSH
102742: CALL_OW 262
102746: PUSH
102747: LD_INT 1
102749: EQUAL
102750: PUSH
102751: LD_VAR 0 3
102755: PPUSH
102756: CALL_OW 261
102760: PUSH
102761: LD_INT 10
102763: LESS
102764: AND
102765: IFFALSE 103045
// begin if not depot then
102767: LD_VAR 0 9
102771: NOT
102772: IFFALSE 102776
// continue ;
102774: GO 102588
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
102776: LD_VAR 0 3
102780: PPUSH
102781: LD_VAR 0 9
102785: PPUSH
102786: LD_VAR 0 3
102790: PPUSH
102791: CALL_OW 74
102795: PPUSH
102796: CALL_OW 296
102800: PUSH
102801: LD_INT 6
102803: LESS
102804: IFFALSE 102820
// SetFuel ( j , 100 ) else
102806: LD_VAR 0 3
102810: PPUSH
102811: LD_INT 100
102813: PPUSH
102814: CALL_OW 240
102818: GO 103045
// if GetFuel ( j ) = 0 then
102820: LD_VAR 0 3
102824: PPUSH
102825: CALL_OW 261
102829: PUSH
102830: LD_INT 0
102832: EQUAL
102833: IFFALSE 103045
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
102835: LD_ADDR_EXP 197
102839: PUSH
102840: LD_EXP 197
102844: PPUSH
102845: LD_VAR 0 2
102849: PPUSH
102850: LD_EXP 197
102854: PUSH
102855: LD_VAR 0 2
102859: ARRAY
102860: PUSH
102861: LD_VAR 0 3
102865: DIFF
102866: PPUSH
102867: CALL_OW 1
102871: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
102872: LD_VAR 0 3
102876: PPUSH
102877: CALL_OW 263
102881: PUSH
102882: LD_INT 1
102884: EQUAL
102885: IFFALSE 102901
// ComExitVehicle ( IsInUnit ( j ) ) ;
102887: LD_VAR 0 3
102891: PPUSH
102892: CALL_OW 310
102896: PPUSH
102897: CALL_OW 121
// if GetControl ( j ) = control_remote then
102901: LD_VAR 0 3
102905: PPUSH
102906: CALL_OW 263
102910: PUSH
102911: LD_INT 2
102913: EQUAL
102914: IFFALSE 102925
// ComUnlink ( j ) ;
102916: LD_VAR 0 3
102920: PPUSH
102921: CALL_OW 136
// fac := MC_GetBuildings ( i , b_factory ) ;
102925: LD_ADDR_VAR 0 10
102929: PUSH
102930: LD_VAR 0 2
102934: PPUSH
102935: LD_INT 3
102937: PPUSH
102938: CALL 112684 0 2
102942: ST_TO_ADDR
// if fac then
102943: LD_VAR 0 10
102947: IFFALSE 103043
// begin for k in fac do
102949: LD_ADDR_VAR 0 4
102953: PUSH
102954: LD_VAR 0 10
102958: PUSH
102959: FOR_IN
102960: IFFALSE 103041
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
102962: LD_ADDR_VAR 0 11
102966: PUSH
102967: LD_VAR 0 10
102971: PPUSH
102972: LD_VAR 0 3
102976: PPUSH
102977: CALL_OW 265
102981: PPUSH
102982: LD_VAR 0 3
102986: PPUSH
102987: CALL_OW 262
102991: PPUSH
102992: LD_VAR 0 3
102996: PPUSH
102997: CALL_OW 263
103001: PPUSH
103002: LD_VAR 0 3
103006: PPUSH
103007: CALL_OW 264
103011: PPUSH
103012: CALL 21859 0 5
103016: ST_TO_ADDR
// if components then
103017: LD_VAR 0 11
103021: IFFALSE 103039
// begin MC_InsertProduceList ( i , components ) ;
103023: LD_VAR 0 2
103027: PPUSH
103028: LD_VAR 0 11
103032: PPUSH
103033: CALL 112229 0 2
// break ;
103037: GO 103041
// end ; end ;
103039: GO 102959
103041: POP
103042: POP
// end ; continue ;
103043: GO 102588
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
103045: LD_VAR 0 3
103049: PPUSH
103050: LD_INT 1
103052: PPUSH
103053: CALL_OW 289
103057: PUSH
103058: LD_INT 100
103060: LESS
103061: PUSH
103062: LD_VAR 0 3
103066: PPUSH
103067: CALL_OW 314
103071: NOT
103072: AND
103073: IFFALSE 103102
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
103075: LD_VAR 0 3
103079: PPUSH
103080: LD_VAR 0 7
103084: PUSH
103085: LD_INT 2
103087: ARRAY
103088: PPUSH
103089: LD_VAR 0 7
103093: PUSH
103094: LD_INT 3
103096: ARRAY
103097: PPUSH
103098: CALL_OW 117
// break ;
103102: GO 103106
// end ;
103104: GO 102588
103106: POP
103107: POP
// end ; end ;
103108: GO 101304
103110: POP
103111: POP
// end ;
103112: LD_VAR 0 1
103116: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
103117: LD_INT 0
103119: PPUSH
103120: PPUSH
103121: PPUSH
103122: PPUSH
// if not mc_bases then
103123: LD_EXP 178
103127: NOT
103128: IFFALSE 103132
// exit ;
103130: GO 103293
// for i = 1 to mc_bases do
103132: LD_ADDR_VAR 0 2
103136: PUSH
103137: DOUBLE
103138: LD_INT 1
103140: DEC
103141: ST_TO_ADDR
103142: LD_EXP 178
103146: PUSH
103147: FOR_TO
103148: IFFALSE 103291
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
103150: LD_ADDR_VAR 0 4
103154: PUSH
103155: LD_EXP 197
103159: PUSH
103160: LD_VAR 0 2
103164: ARRAY
103165: PUSH
103166: LD_EXP 200
103170: PUSH
103171: LD_VAR 0 2
103175: ARRAY
103176: UNION
103177: PPUSH
103178: LD_INT 33
103180: PUSH
103181: LD_INT 2
103183: PUSH
103184: EMPTY
103185: LIST
103186: LIST
103187: PPUSH
103188: CALL_OW 72
103192: ST_TO_ADDR
// if tmp then
103193: LD_VAR 0 4
103197: IFFALSE 103289
// for j in tmp do
103199: LD_ADDR_VAR 0 3
103203: PUSH
103204: LD_VAR 0 4
103208: PUSH
103209: FOR_IN
103210: IFFALSE 103287
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
103212: LD_VAR 0 3
103216: PPUSH
103217: CALL_OW 312
103221: NOT
103222: PUSH
103223: LD_VAR 0 3
103227: PPUSH
103228: CALL_OW 256
103232: PUSH
103233: LD_INT 250
103235: GREATEREQUAL
103236: AND
103237: IFFALSE 103250
// Connect ( j ) else
103239: LD_VAR 0 3
103243: PPUSH
103244: CALL 27334 0 1
103248: GO 103285
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
103250: LD_VAR 0 3
103254: PPUSH
103255: CALL_OW 256
103259: PUSH
103260: LD_INT 250
103262: LESS
103263: PUSH
103264: LD_VAR 0 3
103268: PPUSH
103269: CALL_OW 312
103273: AND
103274: IFFALSE 103285
// ComUnlink ( j ) ;
103276: LD_VAR 0 3
103280: PPUSH
103281: CALL_OW 136
103285: GO 103209
103287: POP
103288: POP
// end ;
103289: GO 103147
103291: POP
103292: POP
// end ;
103293: LD_VAR 0 1
103297: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
103298: LD_INT 0
103300: PPUSH
103301: PPUSH
103302: PPUSH
103303: PPUSH
103304: PPUSH
// if not mc_bases then
103305: LD_EXP 178
103309: NOT
103310: IFFALSE 103314
// exit ;
103312: GO 103759
// for i = 1 to mc_bases do
103314: LD_ADDR_VAR 0 2
103318: PUSH
103319: DOUBLE
103320: LD_INT 1
103322: DEC
103323: ST_TO_ADDR
103324: LD_EXP 178
103328: PUSH
103329: FOR_TO
103330: IFFALSE 103757
// begin if not mc_produce [ i ] then
103332: LD_EXP 199
103336: PUSH
103337: LD_VAR 0 2
103341: ARRAY
103342: NOT
103343: IFFALSE 103347
// continue ;
103345: GO 103329
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
103347: LD_ADDR_VAR 0 5
103351: PUSH
103352: LD_EXP 178
103356: PUSH
103357: LD_VAR 0 2
103361: ARRAY
103362: PPUSH
103363: LD_INT 30
103365: PUSH
103366: LD_INT 3
103368: PUSH
103369: EMPTY
103370: LIST
103371: LIST
103372: PPUSH
103373: CALL_OW 72
103377: ST_TO_ADDR
// if not fac then
103378: LD_VAR 0 5
103382: NOT
103383: IFFALSE 103387
// continue ;
103385: GO 103329
// for j in fac do
103387: LD_ADDR_VAR 0 3
103391: PUSH
103392: LD_VAR 0 5
103396: PUSH
103397: FOR_IN
103398: IFFALSE 103753
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
103400: LD_VAR 0 3
103404: PPUSH
103405: CALL_OW 461
103409: PUSH
103410: LD_INT 2
103412: NONEQUAL
103413: PUSH
103414: LD_VAR 0 3
103418: PPUSH
103419: LD_INT 15
103421: PPUSH
103422: CALL 26962 0 2
103426: PUSH
103427: LD_INT 4
103429: ARRAY
103430: OR
103431: IFFALSE 103435
// continue ;
103433: GO 103397
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
103435: LD_VAR 0 3
103439: PPUSH
103440: LD_EXP 199
103444: PUSH
103445: LD_VAR 0 2
103449: ARRAY
103450: PUSH
103451: LD_INT 1
103453: ARRAY
103454: PUSH
103455: LD_INT 1
103457: ARRAY
103458: PPUSH
103459: LD_EXP 199
103463: PUSH
103464: LD_VAR 0 2
103468: ARRAY
103469: PUSH
103470: LD_INT 1
103472: ARRAY
103473: PUSH
103474: LD_INT 2
103476: ARRAY
103477: PPUSH
103478: LD_EXP 199
103482: PUSH
103483: LD_VAR 0 2
103487: ARRAY
103488: PUSH
103489: LD_INT 1
103491: ARRAY
103492: PUSH
103493: LD_INT 3
103495: ARRAY
103496: PPUSH
103497: LD_EXP 199
103501: PUSH
103502: LD_VAR 0 2
103506: ARRAY
103507: PUSH
103508: LD_INT 1
103510: ARRAY
103511: PUSH
103512: LD_INT 4
103514: ARRAY
103515: PPUSH
103516: CALL_OW 448
103520: PUSH
103521: LD_VAR 0 3
103525: PPUSH
103526: LD_EXP 199
103530: PUSH
103531: LD_VAR 0 2
103535: ARRAY
103536: PUSH
103537: LD_INT 1
103539: ARRAY
103540: PUSH
103541: LD_INT 1
103543: ARRAY
103544: PUSH
103545: LD_EXP 199
103549: PUSH
103550: LD_VAR 0 2
103554: ARRAY
103555: PUSH
103556: LD_INT 1
103558: ARRAY
103559: PUSH
103560: LD_INT 2
103562: ARRAY
103563: PUSH
103564: LD_EXP 199
103568: PUSH
103569: LD_VAR 0 2
103573: ARRAY
103574: PUSH
103575: LD_INT 1
103577: ARRAY
103578: PUSH
103579: LD_INT 3
103581: ARRAY
103582: PUSH
103583: LD_EXP 199
103587: PUSH
103588: LD_VAR 0 2
103592: ARRAY
103593: PUSH
103594: LD_INT 1
103596: ARRAY
103597: PUSH
103598: LD_INT 4
103600: ARRAY
103601: PUSH
103602: EMPTY
103603: LIST
103604: LIST
103605: LIST
103606: LIST
103607: PPUSH
103608: CALL 30729 0 2
103612: AND
103613: IFFALSE 103751
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
103615: LD_VAR 0 3
103619: PPUSH
103620: LD_EXP 199
103624: PUSH
103625: LD_VAR 0 2
103629: ARRAY
103630: PUSH
103631: LD_INT 1
103633: ARRAY
103634: PUSH
103635: LD_INT 1
103637: ARRAY
103638: PPUSH
103639: LD_EXP 199
103643: PUSH
103644: LD_VAR 0 2
103648: ARRAY
103649: PUSH
103650: LD_INT 1
103652: ARRAY
103653: PUSH
103654: LD_INT 2
103656: ARRAY
103657: PPUSH
103658: LD_EXP 199
103662: PUSH
103663: LD_VAR 0 2
103667: ARRAY
103668: PUSH
103669: LD_INT 1
103671: ARRAY
103672: PUSH
103673: LD_INT 3
103675: ARRAY
103676: PPUSH
103677: LD_EXP 199
103681: PUSH
103682: LD_VAR 0 2
103686: ARRAY
103687: PUSH
103688: LD_INT 1
103690: ARRAY
103691: PUSH
103692: LD_INT 4
103694: ARRAY
103695: PPUSH
103696: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
103700: LD_ADDR_VAR 0 4
103704: PUSH
103705: LD_EXP 199
103709: PUSH
103710: LD_VAR 0 2
103714: ARRAY
103715: PPUSH
103716: LD_INT 1
103718: PPUSH
103719: CALL_OW 3
103723: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
103724: LD_ADDR_EXP 199
103728: PUSH
103729: LD_EXP 199
103733: PPUSH
103734: LD_VAR 0 2
103738: PPUSH
103739: LD_VAR 0 4
103743: PPUSH
103744: CALL_OW 1
103748: ST_TO_ADDR
// break ;
103749: GO 103753
// end ; end ;
103751: GO 103397
103753: POP
103754: POP
// end ;
103755: GO 103329
103757: POP
103758: POP
// end ;
103759: LD_VAR 0 1
103763: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
103764: LD_INT 0
103766: PPUSH
103767: PPUSH
103768: PPUSH
// if not mc_bases then
103769: LD_EXP 178
103773: NOT
103774: IFFALSE 103778
// exit ;
103776: GO 103867
// for i = 1 to mc_bases do
103778: LD_ADDR_VAR 0 2
103782: PUSH
103783: DOUBLE
103784: LD_INT 1
103786: DEC
103787: ST_TO_ADDR
103788: LD_EXP 178
103792: PUSH
103793: FOR_TO
103794: IFFALSE 103865
// begin if mc_attack [ i ] then
103796: LD_EXP 198
103800: PUSH
103801: LD_VAR 0 2
103805: ARRAY
103806: IFFALSE 103863
// begin tmp := mc_attack [ i ] [ 1 ] ;
103808: LD_ADDR_VAR 0 3
103812: PUSH
103813: LD_EXP 198
103817: PUSH
103818: LD_VAR 0 2
103822: ARRAY
103823: PUSH
103824: LD_INT 1
103826: ARRAY
103827: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
103828: LD_ADDR_EXP 198
103832: PUSH
103833: LD_EXP 198
103837: PPUSH
103838: LD_VAR 0 2
103842: PPUSH
103843: EMPTY
103844: PPUSH
103845: CALL_OW 1
103849: ST_TO_ADDR
// Attack ( tmp ) ;
103850: LD_VAR 0 3
103854: PPUSH
103855: CALL 80708 0 1
// exit ;
103859: POP
103860: POP
103861: GO 103867
// end ; end ;
103863: GO 103793
103865: POP
103866: POP
// end ;
103867: LD_VAR 0 1
103871: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
103872: LD_INT 0
103874: PPUSH
103875: PPUSH
103876: PPUSH
103877: PPUSH
103878: PPUSH
103879: PPUSH
103880: PPUSH
// if not mc_bases then
103881: LD_EXP 178
103885: NOT
103886: IFFALSE 103890
// exit ;
103888: GO 104747
// for i = 1 to mc_bases do
103890: LD_ADDR_VAR 0 2
103894: PUSH
103895: DOUBLE
103896: LD_INT 1
103898: DEC
103899: ST_TO_ADDR
103900: LD_EXP 178
103904: PUSH
103905: FOR_TO
103906: IFFALSE 104745
// begin if not mc_bases [ i ] then
103908: LD_EXP 178
103912: PUSH
103913: LD_VAR 0 2
103917: ARRAY
103918: NOT
103919: IFFALSE 103923
// continue ;
103921: GO 103905
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
103923: LD_ADDR_VAR 0 7
103927: PUSH
103928: LD_EXP 178
103932: PUSH
103933: LD_VAR 0 2
103937: ARRAY
103938: PUSH
103939: LD_INT 1
103941: ARRAY
103942: PPUSH
103943: CALL 21010 0 1
103947: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
103948: LD_ADDR_EXP 201
103952: PUSH
103953: LD_EXP 201
103957: PPUSH
103958: LD_VAR 0 2
103962: PPUSH
103963: LD_EXP 178
103967: PUSH
103968: LD_VAR 0 2
103972: ARRAY
103973: PUSH
103974: LD_INT 1
103976: ARRAY
103977: PPUSH
103978: CALL_OW 255
103982: PPUSH
103983: LD_EXP 203
103987: PUSH
103988: LD_VAR 0 2
103992: ARRAY
103993: PPUSH
103994: CALL 20975 0 2
103998: PPUSH
103999: CALL_OW 1
104003: ST_TO_ADDR
// if not mc_scan [ i ] then
104004: LD_EXP 201
104008: PUSH
104009: LD_VAR 0 2
104013: ARRAY
104014: NOT
104015: IFFALSE 104193
// begin mc_is_defending := Replace ( mc_is_defending , i , false ) ;
104017: LD_ADDR_EXP 221
104021: PUSH
104022: LD_EXP 221
104026: PPUSH
104027: LD_VAR 0 2
104031: PPUSH
104032: LD_INT 0
104034: PPUSH
104035: CALL_OW 1
104039: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
104040: LD_ADDR_VAR 0 4
104044: PUSH
104045: LD_EXP 178
104049: PUSH
104050: LD_VAR 0 2
104054: ARRAY
104055: PPUSH
104056: LD_INT 2
104058: PUSH
104059: LD_INT 25
104061: PUSH
104062: LD_INT 5
104064: PUSH
104065: EMPTY
104066: LIST
104067: LIST
104068: PUSH
104069: LD_INT 25
104071: PUSH
104072: LD_INT 8
104074: PUSH
104075: EMPTY
104076: LIST
104077: LIST
104078: PUSH
104079: LD_INT 25
104081: PUSH
104082: LD_INT 9
104084: PUSH
104085: EMPTY
104086: LIST
104087: LIST
104088: PUSH
104089: EMPTY
104090: LIST
104091: LIST
104092: LIST
104093: LIST
104094: PPUSH
104095: CALL_OW 72
104099: ST_TO_ADDR
// if not tmp then
104100: LD_VAR 0 4
104104: NOT
104105: IFFALSE 104109
// continue ;
104107: GO 103905
// for j in tmp do
104109: LD_ADDR_VAR 0 3
104113: PUSH
104114: LD_VAR 0 4
104118: PUSH
104119: FOR_IN
104120: IFFALSE 104191
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
104122: LD_VAR 0 3
104126: PPUSH
104127: CALL_OW 310
104131: PPUSH
104132: CALL_OW 266
104136: PUSH
104137: LD_INT 5
104139: EQUAL
104140: PUSH
104141: LD_VAR 0 3
104145: PPUSH
104146: CALL_OW 257
104150: PUSH
104151: LD_INT 1
104153: EQUAL
104154: AND
104155: PUSH
104156: LD_VAR 0 3
104160: PPUSH
104161: CALL_OW 459
104165: NOT
104166: AND
104167: PUSH
104168: LD_VAR 0 7
104172: AND
104173: IFFALSE 104189
// ComChangeProfession ( j , class ) ;
104175: LD_VAR 0 3
104179: PPUSH
104180: LD_VAR 0 7
104184: PPUSH
104185: CALL_OW 123
104189: GO 104119
104191: POP
104192: POP
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and not mc_defender [ i ] and ( UnitFilter ( mc_bases [ i ] , [ [ f_ok ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) < 4 or UnitFilter ( mc_bases [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ) then
104193: LD_EXP 201
104197: PUSH
104198: LD_VAR 0 2
104202: ARRAY
104203: PUSH
104204: LD_EXP 221
104208: PUSH
104209: LD_VAR 0 2
104213: ARRAY
104214: NOT
104215: AND
104216: PUSH
104217: LD_EXP 200
104221: PUSH
104222: LD_VAR 0 2
104226: ARRAY
104227: NOT
104228: AND
104229: PUSH
104230: LD_EXP 178
104234: PUSH
104235: LD_VAR 0 2
104239: ARRAY
104240: PPUSH
104241: LD_INT 50
104243: PUSH
104244: EMPTY
104245: LIST
104246: PUSH
104247: LD_INT 2
104249: PUSH
104250: LD_INT 30
104252: PUSH
104253: LD_INT 32
104255: PUSH
104256: EMPTY
104257: LIST
104258: LIST
104259: PUSH
104260: LD_INT 30
104262: PUSH
104263: LD_INT 33
104265: PUSH
104266: EMPTY
104267: LIST
104268: LIST
104269: PUSH
104270: LD_INT 30
104272: PUSH
104273: LD_INT 4
104275: PUSH
104276: EMPTY
104277: LIST
104278: LIST
104279: PUSH
104280: LD_INT 30
104282: PUSH
104283: LD_INT 5
104285: PUSH
104286: EMPTY
104287: LIST
104288: LIST
104289: PUSH
104290: EMPTY
104291: LIST
104292: LIST
104293: LIST
104294: LIST
104295: LIST
104296: PUSH
104297: EMPTY
104298: LIST
104299: LIST
104300: PPUSH
104301: CALL_OW 72
104305: PUSH
104306: LD_INT 4
104308: LESS
104309: PUSH
104310: LD_EXP 178
104314: PUSH
104315: LD_VAR 0 2
104319: ARRAY
104320: PPUSH
104321: LD_INT 3
104323: PUSH
104324: LD_INT 24
104326: PUSH
104327: LD_INT 1000
104329: PUSH
104330: EMPTY
104331: LIST
104332: LIST
104333: PUSH
104334: EMPTY
104335: LIST
104336: LIST
104337: PUSH
104338: LD_INT 2
104340: PUSH
104341: LD_INT 30
104343: PUSH
104344: LD_INT 0
104346: PUSH
104347: EMPTY
104348: LIST
104349: LIST
104350: PUSH
104351: LD_INT 30
104353: PUSH
104354: LD_INT 1
104356: PUSH
104357: EMPTY
104358: LIST
104359: LIST
104360: PUSH
104361: EMPTY
104362: LIST
104363: LIST
104364: LIST
104365: PUSH
104366: EMPTY
104367: LIST
104368: LIST
104369: PPUSH
104370: CALL_OW 72
104374: OR
104375: AND
104376: IFFALSE 104627
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
104378: LD_ADDR_EXP 221
104382: PUSH
104383: LD_EXP 221
104387: PPUSH
104388: LD_VAR 0 2
104392: PPUSH
104393: LD_INT 1
104395: PPUSH
104396: CALL_OW 1
104400: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
104401: LD_ADDR_VAR 0 4
104405: PUSH
104406: LD_EXP 178
104410: PUSH
104411: LD_VAR 0 2
104415: ARRAY
104416: PPUSH
104417: LD_INT 2
104419: PUSH
104420: LD_INT 25
104422: PUSH
104423: LD_INT 1
104425: PUSH
104426: EMPTY
104427: LIST
104428: LIST
104429: PUSH
104430: LD_INT 25
104432: PUSH
104433: LD_INT 5
104435: PUSH
104436: EMPTY
104437: LIST
104438: LIST
104439: PUSH
104440: LD_INT 25
104442: PUSH
104443: LD_INT 8
104445: PUSH
104446: EMPTY
104447: LIST
104448: LIST
104449: PUSH
104450: LD_INT 25
104452: PUSH
104453: LD_INT 9
104455: PUSH
104456: EMPTY
104457: LIST
104458: LIST
104459: PUSH
104460: EMPTY
104461: LIST
104462: LIST
104463: LIST
104464: LIST
104465: LIST
104466: PPUSH
104467: CALL_OW 72
104471: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
104472: LD_ADDR_VAR 0 4
104476: PUSH
104477: LD_VAR 0 4
104481: PUSH
104482: LD_VAR 0 4
104486: PPUSH
104487: LD_INT 18
104489: PPUSH
104490: CALL 54182 0 2
104494: DIFF
104495: ST_TO_ADDR
// if not tmp and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
104496: LD_VAR 0 4
104500: NOT
104501: PUSH
104502: LD_EXP 178
104506: PUSH
104507: LD_VAR 0 2
104511: ARRAY
104512: PPUSH
104513: LD_INT 2
104515: PUSH
104516: LD_INT 30
104518: PUSH
104519: LD_INT 4
104521: PUSH
104522: EMPTY
104523: LIST
104524: LIST
104525: PUSH
104526: LD_INT 30
104528: PUSH
104529: LD_INT 5
104531: PUSH
104532: EMPTY
104533: LIST
104534: LIST
104535: PUSH
104536: EMPTY
104537: LIST
104538: LIST
104539: LIST
104540: PPUSH
104541: CALL_OW 72
104545: NOT
104546: AND
104547: IFFALSE 104609
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ) ;
104549: LD_ADDR_VAR 0 4
104553: PUSH
104554: LD_EXP 178
104558: PUSH
104559: LD_VAR 0 2
104563: ARRAY
104564: PPUSH
104565: LD_INT 2
104567: PUSH
104568: LD_INT 25
104570: PUSH
104571: LD_INT 2
104573: PUSH
104574: EMPTY
104575: LIST
104576: LIST
104577: PUSH
104578: LD_INT 25
104580: PUSH
104581: LD_INT 3
104583: PUSH
104584: EMPTY
104585: LIST
104586: LIST
104587: PUSH
104588: LD_INT 25
104590: PUSH
104591: LD_INT 4
104593: PUSH
104594: EMPTY
104595: LIST
104596: LIST
104597: PUSH
104598: EMPTY
104599: LIST
104600: LIST
104601: LIST
104602: LIST
104603: PPUSH
104604: CALL_OW 72
104608: ST_TO_ADDR
// BasicDefend ( i , tmp ) ;
104609: LD_VAR 0 2
104613: PPUSH
104614: LD_VAR 0 4
104618: PPUSH
104619: CALL 85417 0 2
// exit ;
104623: POP
104624: POP
104625: GO 104747
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and mc_defender [ i ] then
104627: LD_EXP 201
104631: PUSH
104632: LD_VAR 0 2
104636: ARRAY
104637: PUSH
104638: LD_EXP 221
104642: PUSH
104643: LD_VAR 0 2
104647: ARRAY
104648: NOT
104649: AND
104650: PUSH
104651: LD_EXP 200
104655: PUSH
104656: LD_VAR 0 2
104660: ARRAY
104661: AND
104662: IFFALSE 104743
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
104664: LD_ADDR_EXP 221
104668: PUSH
104669: LD_EXP 221
104673: PPUSH
104674: LD_VAR 0 2
104678: PPUSH
104679: LD_INT 1
104681: PPUSH
104682: CALL_OW 1
104686: ST_TO_ADDR
// tmp := mc_defender [ i ] ;
104687: LD_ADDR_VAR 0 4
104691: PUSH
104692: LD_EXP 200
104696: PUSH
104697: LD_VAR 0 2
104701: ARRAY
104702: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
104703: LD_ADDR_EXP 200
104707: PUSH
104708: LD_EXP 200
104712: PPUSH
104713: LD_VAR 0 2
104717: PPUSH
104718: EMPTY
104719: PPUSH
104720: CALL_OW 1
104724: ST_TO_ADDR
// Defend ( i , tmp ) ;
104725: LD_VAR 0 2
104729: PPUSH
104730: LD_VAR 0 4
104734: PPUSH
104735: CALL 86013 0 2
// exit ;
104739: POP
104740: POP
104741: GO 104747
// end ; end ;
104743: GO 103905
104745: POP
104746: POP
// end ;
104747: LD_VAR 0 1
104751: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
104752: LD_INT 0
104754: PPUSH
104755: PPUSH
104756: PPUSH
104757: PPUSH
104758: PPUSH
104759: PPUSH
104760: PPUSH
104761: PPUSH
104762: PPUSH
104763: PPUSH
104764: PPUSH
// if not mc_bases then
104765: LD_EXP 178
104769: NOT
104770: IFFALSE 104774
// exit ;
104772: GO 105861
// for i = 1 to mc_bases do
104774: LD_ADDR_VAR 0 2
104778: PUSH
104779: DOUBLE
104780: LD_INT 1
104782: DEC
104783: ST_TO_ADDR
104784: LD_EXP 178
104788: PUSH
104789: FOR_TO
104790: IFFALSE 105859
// begin tmp := mc_lab [ i ] ;
104792: LD_ADDR_VAR 0 6
104796: PUSH
104797: LD_EXP 211
104801: PUSH
104802: LD_VAR 0 2
104806: ARRAY
104807: ST_TO_ADDR
// if not tmp then
104808: LD_VAR 0 6
104812: NOT
104813: IFFALSE 104817
// continue ;
104815: GO 104789
// idle_lab := 0 ;
104817: LD_ADDR_VAR 0 11
104821: PUSH
104822: LD_INT 0
104824: ST_TO_ADDR
// for j in tmp do
104825: LD_ADDR_VAR 0 3
104829: PUSH
104830: LD_VAR 0 6
104834: PUSH
104835: FOR_IN
104836: IFFALSE 105855
// begin researching := false ;
104838: LD_ADDR_VAR 0 10
104842: PUSH
104843: LD_INT 0
104845: ST_TO_ADDR
// side := GetSide ( j ) ;
104846: LD_ADDR_VAR 0 4
104850: PUSH
104851: LD_VAR 0 3
104855: PPUSH
104856: CALL_OW 255
104860: ST_TO_ADDR
// if not mc_tech [ side ] then
104861: LD_EXP 205
104865: PUSH
104866: LD_VAR 0 4
104870: ARRAY
104871: NOT
104872: IFFALSE 104876
// continue ;
104874: GO 104835
// if BuildingStatus ( j ) = bs_idle then
104876: LD_VAR 0 3
104880: PPUSH
104881: CALL_OW 461
104885: PUSH
104886: LD_INT 2
104888: EQUAL
104889: IFFALSE 105077
// begin if idle_lab and UnitsInside ( j ) < 6 then
104891: LD_VAR 0 11
104895: PUSH
104896: LD_VAR 0 3
104900: PPUSH
104901: CALL_OW 313
104905: PUSH
104906: LD_INT 6
104908: LESS
104909: AND
104910: IFFALSE 104981
// begin tmp2 := UnitsInside ( idle_lab ) ;
104912: LD_ADDR_VAR 0 9
104916: PUSH
104917: LD_VAR 0 11
104921: PPUSH
104922: CALL_OW 313
104926: ST_TO_ADDR
// if tmp2 then
104927: LD_VAR 0 9
104931: IFFALSE 104973
// for x in tmp2 do
104933: LD_ADDR_VAR 0 7
104937: PUSH
104938: LD_VAR 0 9
104942: PUSH
104943: FOR_IN
104944: IFFALSE 104971
// begin ComExitBuilding ( x ) ;
104946: LD_VAR 0 7
104950: PPUSH
104951: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
104955: LD_VAR 0 7
104959: PPUSH
104960: LD_VAR 0 3
104964: PPUSH
104965: CALL_OW 180
// end ;
104969: GO 104943
104971: POP
104972: POP
// idle_lab := 0 ;
104973: LD_ADDR_VAR 0 11
104977: PUSH
104978: LD_INT 0
104980: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
104981: LD_ADDR_VAR 0 5
104985: PUSH
104986: LD_EXP 205
104990: PUSH
104991: LD_VAR 0 4
104995: ARRAY
104996: PUSH
104997: FOR_IN
104998: IFFALSE 105058
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
105000: LD_VAR 0 3
105004: PPUSH
105005: LD_VAR 0 5
105009: PPUSH
105010: CALL_OW 430
105014: PUSH
105015: LD_VAR 0 4
105019: PPUSH
105020: LD_VAR 0 5
105024: PPUSH
105025: CALL 20080 0 2
105029: AND
105030: IFFALSE 105056
// begin researching := true ;
105032: LD_ADDR_VAR 0 10
105036: PUSH
105037: LD_INT 1
105039: ST_TO_ADDR
// ComResearch ( j , t ) ;
105040: LD_VAR 0 3
105044: PPUSH
105045: LD_VAR 0 5
105049: PPUSH
105050: CALL_OW 124
// break ;
105054: GO 105058
// end ;
105056: GO 104997
105058: POP
105059: POP
// if not researching then
105060: LD_VAR 0 10
105064: NOT
105065: IFFALSE 105077
// idle_lab := j ;
105067: LD_ADDR_VAR 0 11
105071: PUSH
105072: LD_VAR 0 3
105076: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
105077: LD_VAR 0 3
105081: PPUSH
105082: CALL_OW 461
105086: PUSH
105087: LD_INT 10
105089: EQUAL
105090: IFFALSE 105678
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
105092: LD_EXP 207
105096: PUSH
105097: LD_VAR 0 2
105101: ARRAY
105102: NOT
105103: PUSH
105104: LD_EXP 208
105108: PUSH
105109: LD_VAR 0 2
105113: ARRAY
105114: NOT
105115: AND
105116: PUSH
105117: LD_EXP 205
105121: PUSH
105122: LD_VAR 0 4
105126: ARRAY
105127: PUSH
105128: LD_INT 1
105130: GREATER
105131: AND
105132: IFFALSE 105263
// begin ComCancel ( j ) ;
105134: LD_VAR 0 3
105138: PPUSH
105139: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
105143: LD_ADDR_EXP 205
105147: PUSH
105148: LD_EXP 205
105152: PPUSH
105153: LD_VAR 0 4
105157: PPUSH
105158: LD_EXP 205
105162: PUSH
105163: LD_VAR 0 4
105167: ARRAY
105168: PPUSH
105169: LD_EXP 205
105173: PUSH
105174: LD_VAR 0 4
105178: ARRAY
105179: PUSH
105180: LD_INT 1
105182: MINUS
105183: PPUSH
105184: LD_EXP 205
105188: PUSH
105189: LD_VAR 0 4
105193: ARRAY
105194: PPUSH
105195: LD_INT 0
105197: PPUSH
105198: CALL 23781 0 4
105202: PPUSH
105203: CALL_OW 1
105207: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
105208: LD_ADDR_EXP 205
105212: PUSH
105213: LD_EXP 205
105217: PPUSH
105218: LD_VAR 0 4
105222: PPUSH
105223: LD_EXP 205
105227: PUSH
105228: LD_VAR 0 4
105232: ARRAY
105233: PPUSH
105234: LD_EXP 205
105238: PUSH
105239: LD_VAR 0 4
105243: ARRAY
105244: PPUSH
105245: LD_INT 1
105247: PPUSH
105248: LD_INT 0
105250: PPUSH
105251: CALL 23781 0 4
105255: PPUSH
105256: CALL_OW 1
105260: ST_TO_ADDR
// continue ;
105261: GO 104835
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
105263: LD_EXP 207
105267: PUSH
105268: LD_VAR 0 2
105272: ARRAY
105273: PUSH
105274: LD_EXP 208
105278: PUSH
105279: LD_VAR 0 2
105283: ARRAY
105284: NOT
105285: AND
105286: IFFALSE 105413
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
105288: LD_ADDR_EXP 208
105292: PUSH
105293: LD_EXP 208
105297: PPUSH
105298: LD_VAR 0 2
105302: PUSH
105303: LD_EXP 208
105307: PUSH
105308: LD_VAR 0 2
105312: ARRAY
105313: PUSH
105314: LD_INT 1
105316: PLUS
105317: PUSH
105318: EMPTY
105319: LIST
105320: LIST
105321: PPUSH
105322: LD_EXP 207
105326: PUSH
105327: LD_VAR 0 2
105331: ARRAY
105332: PUSH
105333: LD_INT 1
105335: ARRAY
105336: PPUSH
105337: CALL 24363 0 3
105341: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
105342: LD_EXP 207
105346: PUSH
105347: LD_VAR 0 2
105351: ARRAY
105352: PUSH
105353: LD_INT 1
105355: ARRAY
105356: PPUSH
105357: LD_INT 112
105359: PPUSH
105360: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
105364: LD_ADDR_VAR 0 9
105368: PUSH
105369: LD_EXP 207
105373: PUSH
105374: LD_VAR 0 2
105378: ARRAY
105379: PPUSH
105380: LD_INT 1
105382: PPUSH
105383: CALL_OW 3
105387: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
105388: LD_ADDR_EXP 207
105392: PUSH
105393: LD_EXP 207
105397: PPUSH
105398: LD_VAR 0 2
105402: PPUSH
105403: LD_VAR 0 9
105407: PPUSH
105408: CALL_OW 1
105412: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
105413: LD_EXP 207
105417: PUSH
105418: LD_VAR 0 2
105422: ARRAY
105423: PUSH
105424: LD_EXP 208
105428: PUSH
105429: LD_VAR 0 2
105433: ARRAY
105434: AND
105435: PUSH
105436: LD_EXP 208
105440: PUSH
105441: LD_VAR 0 2
105445: ARRAY
105446: PUSH
105447: LD_INT 1
105449: ARRAY
105450: PPUSH
105451: CALL_OW 310
105455: NOT
105456: AND
105457: PUSH
105458: LD_VAR 0 3
105462: PPUSH
105463: CALL_OW 313
105467: PUSH
105468: LD_INT 6
105470: EQUAL
105471: AND
105472: IFFALSE 105528
// begin tmp2 := UnitsInside ( j ) ;
105474: LD_ADDR_VAR 0 9
105478: PUSH
105479: LD_VAR 0 3
105483: PPUSH
105484: CALL_OW 313
105488: ST_TO_ADDR
// if tmp2 = 6 then
105489: LD_VAR 0 9
105493: PUSH
105494: LD_INT 6
105496: EQUAL
105497: IFFALSE 105528
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
105499: LD_VAR 0 9
105503: PUSH
105504: LD_INT 1
105506: ARRAY
105507: PPUSH
105508: LD_INT 112
105510: PPUSH
105511: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
105515: LD_VAR 0 9
105519: PUSH
105520: LD_INT 1
105522: ARRAY
105523: PPUSH
105524: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
105528: LD_EXP 208
105532: PUSH
105533: LD_VAR 0 2
105537: ARRAY
105538: PUSH
105539: LD_EXP 208
105543: PUSH
105544: LD_VAR 0 2
105548: ARRAY
105549: PUSH
105550: LD_INT 1
105552: ARRAY
105553: PPUSH
105554: CALL_OW 314
105558: NOT
105559: AND
105560: PUSH
105561: LD_EXP 208
105565: PUSH
105566: LD_VAR 0 2
105570: ARRAY
105571: PUSH
105572: LD_INT 1
105574: ARRAY
105575: PPUSH
105576: CALL_OW 310
105580: NOT
105581: AND
105582: IFFALSE 105608
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
105584: LD_EXP 208
105588: PUSH
105589: LD_VAR 0 2
105593: ARRAY
105594: PUSH
105595: LD_INT 1
105597: ARRAY
105598: PPUSH
105599: LD_VAR 0 3
105603: PPUSH
105604: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
105608: LD_EXP 208
105612: PUSH
105613: LD_VAR 0 2
105617: ARRAY
105618: PUSH
105619: LD_INT 1
105621: ARRAY
105622: PPUSH
105623: CALL_OW 310
105627: PUSH
105628: LD_EXP 208
105632: PUSH
105633: LD_VAR 0 2
105637: ARRAY
105638: PUSH
105639: LD_INT 1
105641: ARRAY
105642: PPUSH
105643: CALL_OW 310
105647: PPUSH
105648: CALL_OW 461
105652: PUSH
105653: LD_INT 3
105655: NONEQUAL
105656: AND
105657: IFFALSE 105678
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
105659: LD_EXP 208
105663: PUSH
105664: LD_VAR 0 2
105668: ARRAY
105669: PUSH
105670: LD_INT 1
105672: ARRAY
105673: PPUSH
105674: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
105678: LD_VAR 0 3
105682: PPUSH
105683: CALL_OW 461
105687: PUSH
105688: LD_INT 6
105690: EQUAL
105691: PUSH
105692: LD_VAR 0 6
105696: PUSH
105697: LD_INT 1
105699: GREATER
105700: AND
105701: IFFALSE 105853
// begin sci := [ ] ;
105703: LD_ADDR_VAR 0 8
105707: PUSH
105708: EMPTY
105709: ST_TO_ADDR
// for x in ( tmp diff j ) do
105710: LD_ADDR_VAR 0 7
105714: PUSH
105715: LD_VAR 0 6
105719: PUSH
105720: LD_VAR 0 3
105724: DIFF
105725: PUSH
105726: FOR_IN
105727: IFFALSE 105779
// begin if sci = 6 then
105729: LD_VAR 0 8
105733: PUSH
105734: LD_INT 6
105736: EQUAL
105737: IFFALSE 105741
// break ;
105739: GO 105779
// if BuildingStatus ( x ) = bs_idle then
105741: LD_VAR 0 7
105745: PPUSH
105746: CALL_OW 461
105750: PUSH
105751: LD_INT 2
105753: EQUAL
105754: IFFALSE 105777
// sci := sci ^ UnitsInside ( x ) ;
105756: LD_ADDR_VAR 0 8
105760: PUSH
105761: LD_VAR 0 8
105765: PUSH
105766: LD_VAR 0 7
105770: PPUSH
105771: CALL_OW 313
105775: ADD
105776: ST_TO_ADDR
// end ;
105777: GO 105726
105779: POP
105780: POP
// if not sci then
105781: LD_VAR 0 8
105785: NOT
105786: IFFALSE 105790
// continue ;
105788: GO 104835
// for x in sci do
105790: LD_ADDR_VAR 0 7
105794: PUSH
105795: LD_VAR 0 8
105799: PUSH
105800: FOR_IN
105801: IFFALSE 105851
// if IsInUnit ( x ) and not HasTask ( x ) then
105803: LD_VAR 0 7
105807: PPUSH
105808: CALL_OW 310
105812: PUSH
105813: LD_VAR 0 7
105817: PPUSH
105818: CALL_OW 314
105822: NOT
105823: AND
105824: IFFALSE 105849
// begin ComExitBuilding ( x ) ;
105826: LD_VAR 0 7
105830: PPUSH
105831: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
105835: LD_VAR 0 7
105839: PPUSH
105840: LD_VAR 0 3
105844: PPUSH
105845: CALL_OW 180
// end ;
105849: GO 105800
105851: POP
105852: POP
// end ; end ;
105853: GO 104835
105855: POP
105856: POP
// end ;
105857: GO 104789
105859: POP
105860: POP
// end ;
105861: LD_VAR 0 1
105865: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
105866: LD_INT 0
105868: PPUSH
105869: PPUSH
// if not mc_bases then
105870: LD_EXP 178
105874: NOT
105875: IFFALSE 105879
// exit ;
105877: GO 105960
// for i = 1 to mc_bases do
105879: LD_ADDR_VAR 0 2
105883: PUSH
105884: DOUBLE
105885: LD_INT 1
105887: DEC
105888: ST_TO_ADDR
105889: LD_EXP 178
105893: PUSH
105894: FOR_TO
105895: IFFALSE 105958
// if mc_mines [ i ] and mc_miners [ i ] then
105897: LD_EXP 191
105901: PUSH
105902: LD_VAR 0 2
105906: ARRAY
105907: PUSH
105908: LD_EXP 192
105912: PUSH
105913: LD_VAR 0 2
105917: ARRAY
105918: AND
105919: IFFALSE 105956
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
105921: LD_EXP 192
105925: PUSH
105926: LD_VAR 0 2
105930: ARRAY
105931: PUSH
105932: LD_INT 1
105934: ARRAY
105935: PPUSH
105936: CALL_OW 255
105940: PPUSH
105941: LD_EXP 191
105945: PUSH
105946: LD_VAR 0 2
105950: ARRAY
105951: PPUSH
105952: CALL 21163 0 2
105956: GO 105894
105958: POP
105959: POP
// end ;
105960: LD_VAR 0 1
105964: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
105965: LD_INT 0
105967: PPUSH
105968: PPUSH
105969: PPUSH
105970: PPUSH
105971: PPUSH
105972: PPUSH
105973: PPUSH
105974: PPUSH
// if not mc_bases or not mc_parking then
105975: LD_EXP 178
105979: NOT
105980: PUSH
105981: LD_EXP 202
105985: NOT
105986: OR
105987: IFFALSE 105991
// exit ;
105989: GO 106701
// for i = 1 to mc_bases do
105991: LD_ADDR_VAR 0 2
105995: PUSH
105996: DOUBLE
105997: LD_INT 1
105999: DEC
106000: ST_TO_ADDR
106001: LD_EXP 178
106005: PUSH
106006: FOR_TO
106007: IFFALSE 106699
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
106009: LD_EXP 178
106013: PUSH
106014: LD_VAR 0 2
106018: ARRAY
106019: NOT
106020: PUSH
106021: LD_EXP 202
106025: PUSH
106026: LD_VAR 0 2
106030: ARRAY
106031: NOT
106032: OR
106033: IFFALSE 106037
// continue ;
106035: GO 106006
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
106037: LD_ADDR_VAR 0 5
106041: PUSH
106042: LD_EXP 178
106046: PUSH
106047: LD_VAR 0 2
106051: ARRAY
106052: PUSH
106053: LD_INT 1
106055: ARRAY
106056: PPUSH
106057: CALL_OW 255
106061: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
106062: LD_ADDR_VAR 0 6
106066: PUSH
106067: LD_EXP 178
106071: PUSH
106072: LD_VAR 0 2
106076: ARRAY
106077: PPUSH
106078: LD_INT 30
106080: PUSH
106081: LD_INT 3
106083: PUSH
106084: EMPTY
106085: LIST
106086: LIST
106087: PPUSH
106088: CALL_OW 72
106092: ST_TO_ADDR
// if not fac then
106093: LD_VAR 0 6
106097: NOT
106098: IFFALSE 106149
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
106100: LD_ADDR_VAR 0 6
106104: PUSH
106105: LD_EXP 178
106109: PUSH
106110: LD_VAR 0 2
106114: ARRAY
106115: PPUSH
106116: LD_INT 2
106118: PUSH
106119: LD_INT 30
106121: PUSH
106122: LD_INT 0
106124: PUSH
106125: EMPTY
106126: LIST
106127: LIST
106128: PUSH
106129: LD_INT 30
106131: PUSH
106132: LD_INT 1
106134: PUSH
106135: EMPTY
106136: LIST
106137: LIST
106138: PUSH
106139: EMPTY
106140: LIST
106141: LIST
106142: LIST
106143: PPUSH
106144: CALL_OW 72
106148: ST_TO_ADDR
// if not fac then
106149: LD_VAR 0 6
106153: NOT
106154: IFFALSE 106158
// continue ;
106156: GO 106006
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
106158: LD_ADDR_VAR 0 7
106162: PUSH
106163: LD_EXP 202
106167: PUSH
106168: LD_VAR 0 2
106172: ARRAY
106173: PPUSH
106174: LD_INT 22
106176: PUSH
106177: LD_VAR 0 5
106181: PUSH
106182: EMPTY
106183: LIST
106184: LIST
106185: PUSH
106186: LD_INT 21
106188: PUSH
106189: LD_INT 2
106191: PUSH
106192: EMPTY
106193: LIST
106194: LIST
106195: PUSH
106196: LD_INT 3
106198: PUSH
106199: LD_INT 24
106201: PUSH
106202: LD_INT 1000
106204: PUSH
106205: EMPTY
106206: LIST
106207: LIST
106208: PUSH
106209: EMPTY
106210: LIST
106211: LIST
106212: PUSH
106213: EMPTY
106214: LIST
106215: LIST
106216: LIST
106217: PPUSH
106218: CALL_OW 70
106222: ST_TO_ADDR
// for j in fac do
106223: LD_ADDR_VAR 0 3
106227: PUSH
106228: LD_VAR 0 6
106232: PUSH
106233: FOR_IN
106234: IFFALSE 106315
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
106236: LD_ADDR_VAR 0 7
106240: PUSH
106241: LD_VAR 0 7
106245: PUSH
106246: LD_INT 22
106248: PUSH
106249: LD_VAR 0 5
106253: PUSH
106254: EMPTY
106255: LIST
106256: LIST
106257: PUSH
106258: LD_INT 91
106260: PUSH
106261: LD_VAR 0 3
106265: PUSH
106266: LD_INT 15
106268: PUSH
106269: EMPTY
106270: LIST
106271: LIST
106272: LIST
106273: PUSH
106274: LD_INT 21
106276: PUSH
106277: LD_INT 2
106279: PUSH
106280: EMPTY
106281: LIST
106282: LIST
106283: PUSH
106284: LD_INT 3
106286: PUSH
106287: LD_INT 24
106289: PUSH
106290: LD_INT 1000
106292: PUSH
106293: EMPTY
106294: LIST
106295: LIST
106296: PUSH
106297: EMPTY
106298: LIST
106299: LIST
106300: PUSH
106301: EMPTY
106302: LIST
106303: LIST
106304: LIST
106305: LIST
106306: PPUSH
106307: CALL_OW 69
106311: UNION
106312: ST_TO_ADDR
106313: GO 106233
106315: POP
106316: POP
// if not vehs then
106317: LD_VAR 0 7
106321: NOT
106322: IFFALSE 106348
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
106324: LD_ADDR_EXP 190
106328: PUSH
106329: LD_EXP 190
106333: PPUSH
106334: LD_VAR 0 2
106338: PPUSH
106339: EMPTY
106340: PPUSH
106341: CALL_OW 1
106345: ST_TO_ADDR
// continue ;
106346: GO 106006
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
106348: LD_ADDR_VAR 0 8
106352: PUSH
106353: LD_EXP 178
106357: PUSH
106358: LD_VAR 0 2
106362: ARRAY
106363: PPUSH
106364: LD_INT 30
106366: PUSH
106367: LD_INT 3
106369: PUSH
106370: EMPTY
106371: LIST
106372: LIST
106373: PPUSH
106374: CALL_OW 72
106378: ST_TO_ADDR
// if tmp then
106379: LD_VAR 0 8
106383: IFFALSE 106486
// begin for j in tmp do
106385: LD_ADDR_VAR 0 3
106389: PUSH
106390: LD_VAR 0 8
106394: PUSH
106395: FOR_IN
106396: IFFALSE 106484
// for k in UnitsInside ( j ) do
106398: LD_ADDR_VAR 0 4
106402: PUSH
106403: LD_VAR 0 3
106407: PPUSH
106408: CALL_OW 313
106412: PUSH
106413: FOR_IN
106414: IFFALSE 106480
// if k then
106416: LD_VAR 0 4
106420: IFFALSE 106478
// if not k in mc_repair_vehicle [ i ] then
106422: LD_VAR 0 4
106426: PUSH
106427: LD_EXP 190
106431: PUSH
106432: LD_VAR 0 2
106436: ARRAY
106437: IN
106438: NOT
106439: IFFALSE 106478
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
106441: LD_ADDR_EXP 190
106445: PUSH
106446: LD_EXP 190
106450: PPUSH
106451: LD_VAR 0 2
106455: PPUSH
106456: LD_EXP 190
106460: PUSH
106461: LD_VAR 0 2
106465: ARRAY
106466: PUSH
106467: LD_VAR 0 4
106471: UNION
106472: PPUSH
106473: CALL_OW 1
106477: ST_TO_ADDR
106478: GO 106413
106480: POP
106481: POP
106482: GO 106395
106484: POP
106485: POP
// end ; if not mc_repair_vehicle [ i ] then
106486: LD_EXP 190
106490: PUSH
106491: LD_VAR 0 2
106495: ARRAY
106496: NOT
106497: IFFALSE 106501
// continue ;
106499: GO 106006
// for j in mc_repair_vehicle [ i ] do
106501: LD_ADDR_VAR 0 3
106505: PUSH
106506: LD_EXP 190
106510: PUSH
106511: LD_VAR 0 2
106515: ARRAY
106516: PUSH
106517: FOR_IN
106518: IFFALSE 106695
// begin if GetClass ( j ) <> 3 then
106520: LD_VAR 0 3
106524: PPUSH
106525: CALL_OW 257
106529: PUSH
106530: LD_INT 3
106532: NONEQUAL
106533: IFFALSE 106574
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
106535: LD_ADDR_EXP 190
106539: PUSH
106540: LD_EXP 190
106544: PPUSH
106545: LD_VAR 0 2
106549: PPUSH
106550: LD_EXP 190
106554: PUSH
106555: LD_VAR 0 2
106559: ARRAY
106560: PUSH
106561: LD_VAR 0 3
106565: DIFF
106566: PPUSH
106567: CALL_OW 1
106571: ST_TO_ADDR
// continue ;
106572: GO 106517
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
106574: LD_VAR 0 3
106578: PPUSH
106579: CALL_OW 311
106583: NOT
106584: PUSH
106585: LD_VAR 0 3
106589: PUSH
106590: LD_EXP 181
106594: PUSH
106595: LD_VAR 0 2
106599: ARRAY
106600: PUSH
106601: LD_INT 1
106603: ARRAY
106604: IN
106605: NOT
106606: AND
106607: PUSH
106608: LD_VAR 0 3
106612: PUSH
106613: LD_EXP 181
106617: PUSH
106618: LD_VAR 0 2
106622: ARRAY
106623: PUSH
106624: LD_INT 2
106626: ARRAY
106627: IN
106628: NOT
106629: AND
106630: IFFALSE 106693
// begin if IsInUnit ( j ) then
106632: LD_VAR 0 3
106636: PPUSH
106637: CALL_OW 310
106641: IFFALSE 106654
// ComExitBuilding ( j ) else
106643: LD_VAR 0 3
106647: PPUSH
106648: CALL_OW 122
106652: GO 106693
// if not WantToRepairVehicle ( j , vehs [ 1 ] ) then
106654: LD_VAR 0 3
106658: PPUSH
106659: LD_VAR 0 7
106663: PUSH
106664: LD_INT 1
106666: ARRAY
106667: PPUSH
106668: CALL 58675 0 2
106672: NOT
106673: IFFALSE 106693
// ComRepairVehicle ( j , vehs [ 1 ] ) ;
106675: LD_VAR 0 3
106679: PPUSH
106680: LD_VAR 0 7
106684: PUSH
106685: LD_INT 1
106687: ARRAY
106688: PPUSH
106689: CALL_OW 129
// end ; end ;
106693: GO 106517
106695: POP
106696: POP
// end ;
106697: GO 106006
106699: POP
106700: POP
// end ;
106701: LD_VAR 0 1
106705: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
106706: LD_INT 0
106708: PPUSH
106709: PPUSH
106710: PPUSH
106711: PPUSH
106712: PPUSH
106713: PPUSH
106714: PPUSH
106715: PPUSH
106716: PPUSH
106717: PPUSH
106718: PPUSH
// if not mc_bases then
106719: LD_EXP 178
106723: NOT
106724: IFFALSE 106728
// exit ;
106726: GO 107530
// for i = 1 to mc_bases do
106728: LD_ADDR_VAR 0 2
106732: PUSH
106733: DOUBLE
106734: LD_INT 1
106736: DEC
106737: ST_TO_ADDR
106738: LD_EXP 178
106742: PUSH
106743: FOR_TO
106744: IFFALSE 107528
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
106746: LD_EXP 206
106750: PUSH
106751: LD_VAR 0 2
106755: ARRAY
106756: NOT
106757: PUSH
106758: LD_EXP 181
106762: PUSH
106763: LD_VAR 0 2
106767: ARRAY
106768: PUSH
106769: LD_INT 1
106771: ARRAY
106772: OR
106773: PUSH
106774: LD_EXP 181
106778: PUSH
106779: LD_VAR 0 2
106783: ARRAY
106784: PUSH
106785: LD_INT 2
106787: ARRAY
106788: OR
106789: PUSH
106790: LD_EXP 204
106794: PUSH
106795: LD_VAR 0 2
106799: ARRAY
106800: PPUSH
106801: LD_INT 1
106803: PPUSH
106804: CALL_OW 325
106808: NOT
106809: OR
106810: PUSH
106811: LD_EXP 201
106815: PUSH
106816: LD_VAR 0 2
106820: ARRAY
106821: OR
106822: IFFALSE 106826
// continue ;
106824: GO 106743
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
106826: LD_ADDR_VAR 0 8
106830: PUSH
106831: LD_EXP 178
106835: PUSH
106836: LD_VAR 0 2
106840: ARRAY
106841: PPUSH
106842: LD_INT 25
106844: PUSH
106845: LD_INT 4
106847: PUSH
106848: EMPTY
106849: LIST
106850: LIST
106851: PUSH
106852: LD_INT 50
106854: PUSH
106855: EMPTY
106856: LIST
106857: PUSH
106858: LD_INT 3
106860: PUSH
106861: LD_INT 60
106863: PUSH
106864: EMPTY
106865: LIST
106866: PUSH
106867: EMPTY
106868: LIST
106869: LIST
106870: PUSH
106871: EMPTY
106872: LIST
106873: LIST
106874: LIST
106875: PPUSH
106876: CALL_OW 72
106880: PUSH
106881: LD_EXP 182
106885: PUSH
106886: LD_VAR 0 2
106890: ARRAY
106891: DIFF
106892: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
106893: LD_ADDR_VAR 0 9
106897: PUSH
106898: LD_EXP 178
106902: PUSH
106903: LD_VAR 0 2
106907: ARRAY
106908: PPUSH
106909: LD_INT 2
106911: PUSH
106912: LD_INT 30
106914: PUSH
106915: LD_INT 0
106917: PUSH
106918: EMPTY
106919: LIST
106920: LIST
106921: PUSH
106922: LD_INT 30
106924: PUSH
106925: LD_INT 1
106927: PUSH
106928: EMPTY
106929: LIST
106930: LIST
106931: PUSH
106932: EMPTY
106933: LIST
106934: LIST
106935: LIST
106936: PPUSH
106937: CALL_OW 72
106941: ST_TO_ADDR
// if not tmp or not dep then
106942: LD_VAR 0 8
106946: NOT
106947: PUSH
106948: LD_VAR 0 9
106952: NOT
106953: OR
106954: IFFALSE 106958
// continue ;
106956: GO 106743
// side := GetSide ( tmp [ 1 ] ) ;
106958: LD_ADDR_VAR 0 11
106962: PUSH
106963: LD_VAR 0 8
106967: PUSH
106968: LD_INT 1
106970: ARRAY
106971: PPUSH
106972: CALL_OW 255
106976: ST_TO_ADDR
// dep := dep [ 1 ] ;
106977: LD_ADDR_VAR 0 9
106981: PUSH
106982: LD_VAR 0 9
106986: PUSH
106987: LD_INT 1
106989: ARRAY
106990: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
106991: LD_ADDR_VAR 0 7
106995: PUSH
106996: LD_EXP 206
107000: PUSH
107001: LD_VAR 0 2
107005: ARRAY
107006: PPUSH
107007: LD_INT 22
107009: PUSH
107010: LD_INT 0
107012: PUSH
107013: EMPTY
107014: LIST
107015: LIST
107016: PUSH
107017: LD_INT 25
107019: PUSH
107020: LD_INT 12
107022: PUSH
107023: EMPTY
107024: LIST
107025: LIST
107026: PUSH
107027: EMPTY
107028: LIST
107029: LIST
107030: PPUSH
107031: CALL_OW 70
107035: PUSH
107036: LD_INT 22
107038: PUSH
107039: LD_INT 0
107041: PUSH
107042: EMPTY
107043: LIST
107044: LIST
107045: PUSH
107046: LD_INT 25
107048: PUSH
107049: LD_INT 12
107051: PUSH
107052: EMPTY
107053: LIST
107054: LIST
107055: PUSH
107056: LD_INT 91
107058: PUSH
107059: LD_VAR 0 9
107063: PUSH
107064: LD_INT 20
107066: PUSH
107067: EMPTY
107068: LIST
107069: LIST
107070: LIST
107071: PUSH
107072: EMPTY
107073: LIST
107074: LIST
107075: LIST
107076: PPUSH
107077: CALL_OW 69
107081: UNION
107082: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
107083: LD_ADDR_VAR 0 10
107087: PUSH
107088: LD_EXP 206
107092: PUSH
107093: LD_VAR 0 2
107097: ARRAY
107098: PPUSH
107099: LD_INT 81
107101: PUSH
107102: LD_VAR 0 11
107106: PUSH
107107: EMPTY
107108: LIST
107109: LIST
107110: PPUSH
107111: CALL_OW 70
107115: ST_TO_ADDR
// if not apes or danger_at_area then
107116: LD_VAR 0 7
107120: NOT
107121: PUSH
107122: LD_VAR 0 10
107126: OR
107127: IFFALSE 107177
// begin if mc_taming [ i ] then
107129: LD_EXP 209
107133: PUSH
107134: LD_VAR 0 2
107138: ARRAY
107139: IFFALSE 107175
// begin MC_Reset ( i , 121 ) ;
107141: LD_VAR 0 2
107145: PPUSH
107146: LD_INT 121
107148: PPUSH
107149: CALL 92163 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
107153: LD_ADDR_EXP 209
107157: PUSH
107158: LD_EXP 209
107162: PPUSH
107163: LD_VAR 0 2
107167: PPUSH
107168: EMPTY
107169: PPUSH
107170: CALL_OW 1
107174: ST_TO_ADDR
// end ; continue ;
107175: GO 106743
// end ; for j in tmp do
107177: LD_ADDR_VAR 0 3
107181: PUSH
107182: LD_VAR 0 8
107186: PUSH
107187: FOR_IN
107188: IFFALSE 107524
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
107190: LD_VAR 0 3
107194: PUSH
107195: LD_EXP 209
107199: PUSH
107200: LD_VAR 0 2
107204: ARRAY
107205: IN
107206: NOT
107207: PUSH
107208: LD_EXP 209
107212: PUSH
107213: LD_VAR 0 2
107217: ARRAY
107218: PUSH
107219: LD_INT 3
107221: LESS
107222: AND
107223: IFFALSE 107281
// begin SetTag ( j , 121 ) ;
107225: LD_VAR 0 3
107229: PPUSH
107230: LD_INT 121
107232: PPUSH
107233: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
107237: LD_ADDR_EXP 209
107241: PUSH
107242: LD_EXP 209
107246: PPUSH
107247: LD_VAR 0 2
107251: PUSH
107252: LD_EXP 209
107256: PUSH
107257: LD_VAR 0 2
107261: ARRAY
107262: PUSH
107263: LD_INT 1
107265: PLUS
107266: PUSH
107267: EMPTY
107268: LIST
107269: LIST
107270: PPUSH
107271: LD_VAR 0 3
107275: PPUSH
107276: CALL 24363 0 3
107280: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
107281: LD_VAR 0 3
107285: PUSH
107286: LD_EXP 209
107290: PUSH
107291: LD_VAR 0 2
107295: ARRAY
107296: IN
107297: IFFALSE 107522
// begin if GetClass ( j ) <> 4 then
107299: LD_VAR 0 3
107303: PPUSH
107304: CALL_OW 257
107308: PUSH
107309: LD_INT 4
107311: NONEQUAL
107312: IFFALSE 107365
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
107314: LD_ADDR_EXP 209
107318: PUSH
107319: LD_EXP 209
107323: PPUSH
107324: LD_VAR 0 2
107328: PPUSH
107329: LD_EXP 209
107333: PUSH
107334: LD_VAR 0 2
107338: ARRAY
107339: PUSH
107340: LD_VAR 0 3
107344: DIFF
107345: PPUSH
107346: CALL_OW 1
107350: ST_TO_ADDR
// SetTag ( j , 0 ) ;
107351: LD_VAR 0 3
107355: PPUSH
107356: LD_INT 0
107358: PPUSH
107359: CALL_OW 109
// continue ;
107363: GO 107187
// end ; if IsInUnit ( j ) then
107365: LD_VAR 0 3
107369: PPUSH
107370: CALL_OW 310
107374: IFFALSE 107385
// ComExitBuilding ( j ) ;
107376: LD_VAR 0 3
107380: PPUSH
107381: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
107385: LD_ADDR_VAR 0 6
107389: PUSH
107390: LD_VAR 0 7
107394: PPUSH
107395: LD_VAR 0 3
107399: PPUSH
107400: CALL_OW 74
107404: ST_TO_ADDR
// if not ape then
107405: LD_VAR 0 6
107409: NOT
107410: IFFALSE 107414
// break ;
107412: GO 107524
// x := GetX ( ape ) ;
107414: LD_ADDR_VAR 0 4
107418: PUSH
107419: LD_VAR 0 6
107423: PPUSH
107424: CALL_OW 250
107428: ST_TO_ADDR
// y := GetY ( ape ) ;
107429: LD_ADDR_VAR 0 5
107433: PUSH
107434: LD_VAR 0 6
107438: PPUSH
107439: CALL_OW 251
107443: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
107444: LD_VAR 0 4
107448: PPUSH
107449: LD_VAR 0 5
107453: PPUSH
107454: CALL_OW 488
107458: NOT
107459: PUSH
107460: LD_VAR 0 11
107464: PPUSH
107465: LD_VAR 0 4
107469: PPUSH
107470: LD_VAR 0 5
107474: PPUSH
107475: LD_INT 20
107477: PPUSH
107478: CALL 25259 0 4
107482: PUSH
107483: LD_INT 4
107485: ARRAY
107486: OR
107487: IFFALSE 107491
// break ;
107489: GO 107524
// if not HasTask ( j ) then
107491: LD_VAR 0 3
107495: PPUSH
107496: CALL_OW 314
107500: NOT
107501: IFFALSE 107522
// ComTameXY ( j , x , y ) ;
107503: LD_VAR 0 3
107507: PPUSH
107508: LD_VAR 0 4
107512: PPUSH
107513: LD_VAR 0 5
107517: PPUSH
107518: CALL_OW 131
// end ; end ;
107522: GO 107187
107524: POP
107525: POP
// end ;
107526: GO 106743
107528: POP
107529: POP
// end ;
107530: LD_VAR 0 1
107534: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
107535: LD_INT 0
107537: PPUSH
107538: PPUSH
107539: PPUSH
107540: PPUSH
107541: PPUSH
107542: PPUSH
107543: PPUSH
107544: PPUSH
// if not mc_bases then
107545: LD_EXP 178
107549: NOT
107550: IFFALSE 107554
// exit ;
107552: GO 108180
// for i = 1 to mc_bases do
107554: LD_ADDR_VAR 0 2
107558: PUSH
107559: DOUBLE
107560: LD_INT 1
107562: DEC
107563: ST_TO_ADDR
107564: LD_EXP 178
107568: PUSH
107569: FOR_TO
107570: IFFALSE 108178
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
107572: LD_EXP 207
107576: PUSH
107577: LD_VAR 0 2
107581: ARRAY
107582: NOT
107583: PUSH
107584: LD_EXP 207
107588: PUSH
107589: LD_VAR 0 2
107593: ARRAY
107594: PPUSH
107595: LD_INT 25
107597: PUSH
107598: LD_INT 12
107600: PUSH
107601: EMPTY
107602: LIST
107603: LIST
107604: PPUSH
107605: CALL_OW 72
107609: NOT
107610: OR
107611: IFFALSE 107615
// continue ;
107613: GO 107569
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
107615: LD_ADDR_VAR 0 5
107619: PUSH
107620: LD_EXP 207
107624: PUSH
107625: LD_VAR 0 2
107629: ARRAY
107630: PUSH
107631: LD_INT 1
107633: ARRAY
107634: PPUSH
107635: CALL_OW 255
107639: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
107640: LD_VAR 0 5
107644: PPUSH
107645: LD_INT 2
107647: PPUSH
107648: CALL_OW 325
107652: IFFALSE 107905
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
107654: LD_ADDR_VAR 0 4
107658: PUSH
107659: LD_EXP 207
107663: PUSH
107664: LD_VAR 0 2
107668: ARRAY
107669: PPUSH
107670: LD_INT 25
107672: PUSH
107673: LD_INT 16
107675: PUSH
107676: EMPTY
107677: LIST
107678: LIST
107679: PPUSH
107680: CALL_OW 72
107684: ST_TO_ADDR
// if tmp < 6 then
107685: LD_VAR 0 4
107689: PUSH
107690: LD_INT 6
107692: LESS
107693: IFFALSE 107905
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
107695: LD_ADDR_VAR 0 6
107699: PUSH
107700: LD_EXP 178
107704: PUSH
107705: LD_VAR 0 2
107709: ARRAY
107710: PPUSH
107711: LD_INT 2
107713: PUSH
107714: LD_INT 30
107716: PUSH
107717: LD_INT 0
107719: PUSH
107720: EMPTY
107721: LIST
107722: LIST
107723: PUSH
107724: LD_INT 30
107726: PUSH
107727: LD_INT 1
107729: PUSH
107730: EMPTY
107731: LIST
107732: LIST
107733: PUSH
107734: EMPTY
107735: LIST
107736: LIST
107737: LIST
107738: PPUSH
107739: CALL_OW 72
107743: ST_TO_ADDR
// if depot then
107744: LD_VAR 0 6
107748: IFFALSE 107905
// begin selected := 0 ;
107750: LD_ADDR_VAR 0 7
107754: PUSH
107755: LD_INT 0
107757: ST_TO_ADDR
// for j in depot do
107758: LD_ADDR_VAR 0 3
107762: PUSH
107763: LD_VAR 0 6
107767: PUSH
107768: FOR_IN
107769: IFFALSE 107800
// begin if UnitsInside ( j ) < 6 then
107771: LD_VAR 0 3
107775: PPUSH
107776: CALL_OW 313
107780: PUSH
107781: LD_INT 6
107783: LESS
107784: IFFALSE 107798
// begin selected := j ;
107786: LD_ADDR_VAR 0 7
107790: PUSH
107791: LD_VAR 0 3
107795: ST_TO_ADDR
// break ;
107796: GO 107800
// end ; end ;
107798: GO 107768
107800: POP
107801: POP
// if selected then
107802: LD_VAR 0 7
107806: IFFALSE 107905
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
107808: LD_ADDR_VAR 0 3
107812: PUSH
107813: LD_EXP 207
107817: PUSH
107818: LD_VAR 0 2
107822: ARRAY
107823: PPUSH
107824: LD_INT 25
107826: PUSH
107827: LD_INT 12
107829: PUSH
107830: EMPTY
107831: LIST
107832: LIST
107833: PPUSH
107834: CALL_OW 72
107838: PUSH
107839: FOR_IN
107840: IFFALSE 107903
// if not HasTask ( j ) then
107842: LD_VAR 0 3
107846: PPUSH
107847: CALL_OW 314
107851: NOT
107852: IFFALSE 107901
// begin if not IsInUnit ( j ) then
107854: LD_VAR 0 3
107858: PPUSH
107859: CALL_OW 310
107863: NOT
107864: IFFALSE 107880
// ComEnterUnit ( j , selected ) ;
107866: LD_VAR 0 3
107870: PPUSH
107871: LD_VAR 0 7
107875: PPUSH
107876: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
107880: LD_VAR 0 3
107884: PPUSH
107885: LD_INT 16
107887: PPUSH
107888: CALL_OW 183
// AddComExitBuilding ( j ) ;
107892: LD_VAR 0 3
107896: PPUSH
107897: CALL_OW 182
// end ;
107901: GO 107839
107903: POP
107904: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
107905: LD_VAR 0 5
107909: PPUSH
107910: LD_INT 11
107912: PPUSH
107913: CALL_OW 325
107917: IFFALSE 108176
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
107919: LD_ADDR_VAR 0 4
107923: PUSH
107924: LD_EXP 207
107928: PUSH
107929: LD_VAR 0 2
107933: ARRAY
107934: PPUSH
107935: LD_INT 25
107937: PUSH
107938: LD_INT 16
107940: PUSH
107941: EMPTY
107942: LIST
107943: LIST
107944: PPUSH
107945: CALL_OW 72
107949: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
107950: LD_VAR 0 4
107954: PUSH
107955: LD_INT 6
107957: GREATEREQUAL
107958: PUSH
107959: LD_VAR 0 5
107963: PPUSH
107964: LD_INT 2
107966: PPUSH
107967: CALL_OW 325
107971: NOT
107972: OR
107973: IFFALSE 108176
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
107975: LD_ADDR_VAR 0 8
107979: PUSH
107980: LD_EXP 178
107984: PUSH
107985: LD_VAR 0 2
107989: ARRAY
107990: PPUSH
107991: LD_INT 2
107993: PUSH
107994: LD_INT 30
107996: PUSH
107997: LD_INT 4
107999: PUSH
108000: EMPTY
108001: LIST
108002: LIST
108003: PUSH
108004: LD_INT 30
108006: PUSH
108007: LD_INT 5
108009: PUSH
108010: EMPTY
108011: LIST
108012: LIST
108013: PUSH
108014: EMPTY
108015: LIST
108016: LIST
108017: LIST
108018: PPUSH
108019: CALL_OW 72
108023: ST_TO_ADDR
// if barracks then
108024: LD_VAR 0 8
108028: IFFALSE 108176
// begin selected := 0 ;
108030: LD_ADDR_VAR 0 7
108034: PUSH
108035: LD_INT 0
108037: ST_TO_ADDR
// for j in barracks do
108038: LD_ADDR_VAR 0 3
108042: PUSH
108043: LD_VAR 0 8
108047: PUSH
108048: FOR_IN
108049: IFFALSE 108080
// begin if UnitsInside ( j ) < 6 then
108051: LD_VAR 0 3
108055: PPUSH
108056: CALL_OW 313
108060: PUSH
108061: LD_INT 6
108063: LESS
108064: IFFALSE 108078
// begin selected := j ;
108066: LD_ADDR_VAR 0 7
108070: PUSH
108071: LD_VAR 0 3
108075: ST_TO_ADDR
// break ;
108076: GO 108080
// end ; end ;
108078: GO 108048
108080: POP
108081: POP
// if selected then
108082: LD_VAR 0 7
108086: IFFALSE 108176
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
108088: LD_ADDR_VAR 0 3
108092: PUSH
108093: LD_EXP 207
108097: PUSH
108098: LD_VAR 0 2
108102: ARRAY
108103: PPUSH
108104: LD_INT 25
108106: PUSH
108107: LD_INT 12
108109: PUSH
108110: EMPTY
108111: LIST
108112: LIST
108113: PPUSH
108114: CALL_OW 72
108118: PUSH
108119: FOR_IN
108120: IFFALSE 108174
// if not IsInUnit ( j ) and not HasTask ( j ) then
108122: LD_VAR 0 3
108126: PPUSH
108127: CALL_OW 310
108131: NOT
108132: PUSH
108133: LD_VAR 0 3
108137: PPUSH
108138: CALL_OW 314
108142: NOT
108143: AND
108144: IFFALSE 108172
// begin ComEnterUnit ( j , selected ) ;
108146: LD_VAR 0 3
108150: PPUSH
108151: LD_VAR 0 7
108155: PPUSH
108156: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
108160: LD_VAR 0 3
108164: PPUSH
108165: LD_INT 15
108167: PPUSH
108168: CALL_OW 183
// end ;
108172: GO 108119
108174: POP
108175: POP
// end ; end ; end ; end ; end ;
108176: GO 107569
108178: POP
108179: POP
// end ;
108180: LD_VAR 0 1
108184: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
108185: LD_INT 0
108187: PPUSH
108188: PPUSH
108189: PPUSH
108190: PPUSH
// if not mc_bases then
108191: LD_EXP 178
108195: NOT
108196: IFFALSE 108200
// exit ;
108198: GO 108378
// for i = 1 to mc_bases do
108200: LD_ADDR_VAR 0 2
108204: PUSH
108205: DOUBLE
108206: LD_INT 1
108208: DEC
108209: ST_TO_ADDR
108210: LD_EXP 178
108214: PUSH
108215: FOR_TO
108216: IFFALSE 108376
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
108218: LD_ADDR_VAR 0 4
108222: PUSH
108223: LD_EXP 178
108227: PUSH
108228: LD_VAR 0 2
108232: ARRAY
108233: PPUSH
108234: LD_INT 25
108236: PUSH
108237: LD_INT 9
108239: PUSH
108240: EMPTY
108241: LIST
108242: LIST
108243: PPUSH
108244: CALL_OW 72
108248: ST_TO_ADDR
// if not tmp then
108249: LD_VAR 0 4
108253: NOT
108254: IFFALSE 108258
// continue ;
108256: GO 108215
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
108258: LD_EXP 204
108262: PUSH
108263: LD_VAR 0 2
108267: ARRAY
108268: PPUSH
108269: LD_INT 29
108271: PPUSH
108272: CALL_OW 325
108276: NOT
108277: PUSH
108278: LD_EXP 204
108282: PUSH
108283: LD_VAR 0 2
108287: ARRAY
108288: PPUSH
108289: LD_INT 28
108291: PPUSH
108292: CALL_OW 325
108296: NOT
108297: AND
108298: IFFALSE 108302
// continue ;
108300: GO 108215
// for j in tmp do
108302: LD_ADDR_VAR 0 3
108306: PUSH
108307: LD_VAR 0 4
108311: PUSH
108312: FOR_IN
108313: IFFALSE 108372
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
108315: LD_VAR 0 3
108319: PUSH
108320: LD_EXP 181
108324: PUSH
108325: LD_VAR 0 2
108329: ARRAY
108330: PUSH
108331: LD_INT 1
108333: ARRAY
108334: IN
108335: NOT
108336: PUSH
108337: LD_VAR 0 3
108341: PUSH
108342: LD_EXP 181
108346: PUSH
108347: LD_VAR 0 2
108351: ARRAY
108352: PUSH
108353: LD_INT 2
108355: ARRAY
108356: IN
108357: NOT
108358: AND
108359: IFFALSE 108370
// ComSpaceTimeShoot ( j ) ;
108361: LD_VAR 0 3
108365: PPUSH
108366: CALL 20171 0 1
108370: GO 108312
108372: POP
108373: POP
// end ;
108374: GO 108215
108376: POP
108377: POP
// end ;
108378: LD_VAR 0 1
108382: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
108383: LD_INT 0
108385: PPUSH
108386: PPUSH
108387: PPUSH
108388: PPUSH
108389: PPUSH
108390: PPUSH
108391: PPUSH
108392: PPUSH
108393: PPUSH
// if not mc_bases then
108394: LD_EXP 178
108398: NOT
108399: IFFALSE 108403
// exit ;
108401: GO 109025
// for i = 1 to mc_bases do
108403: LD_ADDR_VAR 0 2
108407: PUSH
108408: DOUBLE
108409: LD_INT 1
108411: DEC
108412: ST_TO_ADDR
108413: LD_EXP 178
108417: PUSH
108418: FOR_TO
108419: IFFALSE 109023
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
108421: LD_EXP 213
108425: PUSH
108426: LD_VAR 0 2
108430: ARRAY
108431: NOT
108432: PUSH
108433: LD_INT 38
108435: PPUSH
108436: LD_EXP 204
108440: PUSH
108441: LD_VAR 0 2
108445: ARRAY
108446: PPUSH
108447: CALL_OW 321
108451: PUSH
108452: LD_INT 2
108454: NONEQUAL
108455: OR
108456: IFFALSE 108460
// continue ;
108458: GO 108418
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
108460: LD_ADDR_VAR 0 8
108464: PUSH
108465: LD_EXP 178
108469: PUSH
108470: LD_VAR 0 2
108474: ARRAY
108475: PPUSH
108476: LD_INT 30
108478: PUSH
108479: LD_INT 34
108481: PUSH
108482: EMPTY
108483: LIST
108484: LIST
108485: PPUSH
108486: CALL_OW 72
108490: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
108491: LD_ADDR_VAR 0 9
108495: PUSH
108496: LD_EXP 178
108500: PUSH
108501: LD_VAR 0 2
108505: ARRAY
108506: PPUSH
108507: LD_INT 25
108509: PUSH
108510: LD_INT 4
108512: PUSH
108513: EMPTY
108514: LIST
108515: LIST
108516: PPUSH
108517: CALL_OW 72
108521: PPUSH
108522: LD_INT 0
108524: PPUSH
108525: CALL 54182 0 2
108529: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
108530: LD_VAR 0 9
108534: NOT
108535: PUSH
108536: LD_VAR 0 8
108540: NOT
108541: OR
108542: PUSH
108543: LD_EXP 178
108547: PUSH
108548: LD_VAR 0 2
108552: ARRAY
108553: PPUSH
108554: LD_INT 124
108556: PPUSH
108557: CALL 54182 0 2
108561: OR
108562: IFFALSE 108566
// continue ;
108564: GO 108418
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
108566: LD_EXP 214
108570: PUSH
108571: LD_VAR 0 2
108575: ARRAY
108576: PUSH
108577: LD_EXP 213
108581: PUSH
108582: LD_VAR 0 2
108586: ARRAY
108587: LESS
108588: PUSH
108589: LD_EXP 214
108593: PUSH
108594: LD_VAR 0 2
108598: ARRAY
108599: PUSH
108600: LD_VAR 0 8
108604: LESS
108605: AND
108606: IFFALSE 109021
// begin tmp := sci [ 1 ] ;
108608: LD_ADDR_VAR 0 7
108612: PUSH
108613: LD_VAR 0 9
108617: PUSH
108618: LD_INT 1
108620: ARRAY
108621: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
108622: LD_VAR 0 7
108626: PPUSH
108627: LD_INT 124
108629: PPUSH
108630: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
108634: LD_ADDR_VAR 0 3
108638: PUSH
108639: DOUBLE
108640: LD_EXP 213
108644: PUSH
108645: LD_VAR 0 2
108649: ARRAY
108650: INC
108651: ST_TO_ADDR
108652: LD_EXP 213
108656: PUSH
108657: LD_VAR 0 2
108661: ARRAY
108662: PUSH
108663: FOR_DOWNTO
108664: IFFALSE 109007
// begin if IsInUnit ( tmp ) then
108666: LD_VAR 0 7
108670: PPUSH
108671: CALL_OW 310
108675: IFFALSE 108686
// ComExitBuilding ( tmp ) ;
108677: LD_VAR 0 7
108681: PPUSH
108682: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
108686: LD_INT 35
108688: PPUSH
108689: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
108693: LD_VAR 0 7
108697: PPUSH
108698: CALL_OW 310
108702: NOT
108703: PUSH
108704: LD_VAR 0 7
108708: PPUSH
108709: CALL_OW 314
108713: NOT
108714: AND
108715: IFFALSE 108686
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
108717: LD_ADDR_VAR 0 6
108721: PUSH
108722: LD_VAR 0 7
108726: PPUSH
108727: CALL_OW 250
108731: PUSH
108732: LD_VAR 0 7
108736: PPUSH
108737: CALL_OW 251
108741: PUSH
108742: EMPTY
108743: LIST
108744: LIST
108745: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
108746: LD_INT 35
108748: PPUSH
108749: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
108753: LD_ADDR_VAR 0 4
108757: PUSH
108758: LD_EXP 213
108762: PUSH
108763: LD_VAR 0 2
108767: ARRAY
108768: PUSH
108769: LD_VAR 0 3
108773: ARRAY
108774: PUSH
108775: LD_INT 1
108777: ARRAY
108778: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
108779: LD_ADDR_VAR 0 5
108783: PUSH
108784: LD_EXP 213
108788: PUSH
108789: LD_VAR 0 2
108793: ARRAY
108794: PUSH
108795: LD_VAR 0 3
108799: ARRAY
108800: PUSH
108801: LD_INT 2
108803: ARRAY
108804: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
108805: LD_VAR 0 7
108809: PPUSH
108810: LD_INT 10
108812: PPUSH
108813: CALL 26962 0 2
108817: PUSH
108818: LD_INT 4
108820: ARRAY
108821: IFFALSE 108859
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
108823: LD_VAR 0 7
108827: PPUSH
108828: LD_VAR 0 6
108832: PUSH
108833: LD_INT 1
108835: ARRAY
108836: PPUSH
108837: LD_VAR 0 6
108841: PUSH
108842: LD_INT 2
108844: ARRAY
108845: PPUSH
108846: CALL_OW 111
// wait ( 0 0$10 ) ;
108850: LD_INT 350
108852: PPUSH
108853: CALL_OW 67
// end else
108857: GO 108885
// begin ComMoveXY ( tmp , x , y ) ;
108859: LD_VAR 0 7
108863: PPUSH
108864: LD_VAR 0 4
108868: PPUSH
108869: LD_VAR 0 5
108873: PPUSH
108874: CALL_OW 111
// wait ( 0 0$3 ) ;
108878: LD_INT 105
108880: PPUSH
108881: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
108885: LD_VAR 0 7
108889: PPUSH
108890: LD_VAR 0 4
108894: PPUSH
108895: LD_VAR 0 5
108899: PPUSH
108900: CALL_OW 307
108904: IFFALSE 108746
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
108906: LD_VAR 0 7
108910: PPUSH
108911: LD_VAR 0 4
108915: PPUSH
108916: LD_VAR 0 5
108920: PPUSH
108921: LD_VAR 0 8
108925: PUSH
108926: LD_VAR 0 3
108930: ARRAY
108931: PPUSH
108932: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
108936: LD_INT 35
108938: PPUSH
108939: CALL_OW 67
// until not HasTask ( tmp ) ;
108943: LD_VAR 0 7
108947: PPUSH
108948: CALL_OW 314
108952: NOT
108953: IFFALSE 108936
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
108955: LD_ADDR_EXP 214
108959: PUSH
108960: LD_EXP 214
108964: PPUSH
108965: LD_VAR 0 2
108969: PUSH
108970: LD_EXP 214
108974: PUSH
108975: LD_VAR 0 2
108979: ARRAY
108980: PUSH
108981: LD_INT 1
108983: PLUS
108984: PUSH
108985: EMPTY
108986: LIST
108987: LIST
108988: PPUSH
108989: LD_VAR 0 8
108993: PUSH
108994: LD_VAR 0 3
108998: ARRAY
108999: PPUSH
109000: CALL 24363 0 3
109004: ST_TO_ADDR
// end ;
109005: GO 108663
109007: POP
109008: POP
// MC_Reset ( i , 124 ) ;
109009: LD_VAR 0 2
109013: PPUSH
109014: LD_INT 124
109016: PPUSH
109017: CALL 92163 0 2
// end ; end ;
109021: GO 108418
109023: POP
109024: POP
// end ;
109025: LD_VAR 0 1
109029: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
109030: LD_INT 0
109032: PPUSH
109033: PPUSH
109034: PPUSH
// if not mc_bases then
109035: LD_EXP 178
109039: NOT
109040: IFFALSE 109044
// exit ;
109042: GO 109650
// for i = 1 to mc_bases do
109044: LD_ADDR_VAR 0 2
109048: PUSH
109049: DOUBLE
109050: LD_INT 1
109052: DEC
109053: ST_TO_ADDR
109054: LD_EXP 178
109058: PUSH
109059: FOR_TO
109060: IFFALSE 109648
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
109062: LD_ADDR_VAR 0 3
109066: PUSH
109067: LD_EXP 178
109071: PUSH
109072: LD_VAR 0 2
109076: ARRAY
109077: PPUSH
109078: LD_INT 25
109080: PUSH
109081: LD_INT 4
109083: PUSH
109084: EMPTY
109085: LIST
109086: LIST
109087: PPUSH
109088: CALL_OW 72
109092: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
109093: LD_VAR 0 3
109097: NOT
109098: PUSH
109099: LD_EXP 215
109103: PUSH
109104: LD_VAR 0 2
109108: ARRAY
109109: NOT
109110: OR
109111: PUSH
109112: LD_EXP 178
109116: PUSH
109117: LD_VAR 0 2
109121: ARRAY
109122: PPUSH
109123: LD_INT 2
109125: PUSH
109126: LD_INT 30
109128: PUSH
109129: LD_INT 0
109131: PUSH
109132: EMPTY
109133: LIST
109134: LIST
109135: PUSH
109136: LD_INT 30
109138: PUSH
109139: LD_INT 1
109141: PUSH
109142: EMPTY
109143: LIST
109144: LIST
109145: PUSH
109146: EMPTY
109147: LIST
109148: LIST
109149: LIST
109150: PPUSH
109151: CALL_OW 72
109155: NOT
109156: OR
109157: IFFALSE 109207
// begin if mc_deposits_finder [ i ] then
109159: LD_EXP 216
109163: PUSH
109164: LD_VAR 0 2
109168: ARRAY
109169: IFFALSE 109205
// begin MC_Reset ( i , 125 ) ;
109171: LD_VAR 0 2
109175: PPUSH
109176: LD_INT 125
109178: PPUSH
109179: CALL 92163 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
109183: LD_ADDR_EXP 216
109187: PUSH
109188: LD_EXP 216
109192: PPUSH
109193: LD_VAR 0 2
109197: PPUSH
109198: EMPTY
109199: PPUSH
109200: CALL_OW 1
109204: ST_TO_ADDR
// end ; continue ;
109205: GO 109059
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
109207: LD_EXP 215
109211: PUSH
109212: LD_VAR 0 2
109216: ARRAY
109217: PUSH
109218: LD_INT 1
109220: ARRAY
109221: PUSH
109222: LD_INT 3
109224: ARRAY
109225: PUSH
109226: LD_INT 1
109228: EQUAL
109229: PUSH
109230: LD_INT 20
109232: PPUSH
109233: LD_EXP 204
109237: PUSH
109238: LD_VAR 0 2
109242: ARRAY
109243: PPUSH
109244: CALL_OW 321
109248: PUSH
109249: LD_INT 2
109251: NONEQUAL
109252: AND
109253: IFFALSE 109303
// begin if mc_deposits_finder [ i ] then
109255: LD_EXP 216
109259: PUSH
109260: LD_VAR 0 2
109264: ARRAY
109265: IFFALSE 109301
// begin MC_Reset ( i , 125 ) ;
109267: LD_VAR 0 2
109271: PPUSH
109272: LD_INT 125
109274: PPUSH
109275: CALL 92163 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
109279: LD_ADDR_EXP 216
109283: PUSH
109284: LD_EXP 216
109288: PPUSH
109289: LD_VAR 0 2
109293: PPUSH
109294: EMPTY
109295: PPUSH
109296: CALL_OW 1
109300: ST_TO_ADDR
// end ; continue ;
109301: GO 109059
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
109303: LD_EXP 215
109307: PUSH
109308: LD_VAR 0 2
109312: ARRAY
109313: PUSH
109314: LD_INT 1
109316: ARRAY
109317: PUSH
109318: LD_INT 1
109320: ARRAY
109321: PPUSH
109322: LD_EXP 215
109326: PUSH
109327: LD_VAR 0 2
109331: ARRAY
109332: PUSH
109333: LD_INT 1
109335: ARRAY
109336: PUSH
109337: LD_INT 2
109339: ARRAY
109340: PPUSH
109341: LD_EXP 204
109345: PUSH
109346: LD_VAR 0 2
109350: ARRAY
109351: PPUSH
109352: CALL_OW 440
109356: IFFALSE 109399
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
109358: LD_ADDR_EXP 215
109362: PUSH
109363: LD_EXP 215
109367: PPUSH
109368: LD_VAR 0 2
109372: PPUSH
109373: LD_EXP 215
109377: PUSH
109378: LD_VAR 0 2
109382: ARRAY
109383: PPUSH
109384: LD_INT 1
109386: PPUSH
109387: CALL_OW 3
109391: PPUSH
109392: CALL_OW 1
109396: ST_TO_ADDR
109397: GO 109646
// begin if not mc_deposits_finder [ i ] then
109399: LD_EXP 216
109403: PUSH
109404: LD_VAR 0 2
109408: ARRAY
109409: NOT
109410: IFFALSE 109462
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
109412: LD_ADDR_EXP 216
109416: PUSH
109417: LD_EXP 216
109421: PPUSH
109422: LD_VAR 0 2
109426: PPUSH
109427: LD_VAR 0 3
109431: PUSH
109432: LD_INT 1
109434: ARRAY
109435: PUSH
109436: EMPTY
109437: LIST
109438: PPUSH
109439: CALL_OW 1
109443: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
109444: LD_VAR 0 3
109448: PUSH
109449: LD_INT 1
109451: ARRAY
109452: PPUSH
109453: LD_INT 125
109455: PPUSH
109456: CALL_OW 109
// end else
109460: GO 109646
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
109462: LD_EXP 216
109466: PUSH
109467: LD_VAR 0 2
109471: ARRAY
109472: PUSH
109473: LD_INT 1
109475: ARRAY
109476: PPUSH
109477: CALL_OW 310
109481: IFFALSE 109504
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
109483: LD_EXP 216
109487: PUSH
109488: LD_VAR 0 2
109492: ARRAY
109493: PUSH
109494: LD_INT 1
109496: ARRAY
109497: PPUSH
109498: CALL_OW 122
109502: GO 109646
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
109504: LD_EXP 216
109508: PUSH
109509: LD_VAR 0 2
109513: ARRAY
109514: PUSH
109515: LD_INT 1
109517: ARRAY
109518: PPUSH
109519: CALL_OW 314
109523: NOT
109524: PUSH
109525: LD_EXP 216
109529: PUSH
109530: LD_VAR 0 2
109534: ARRAY
109535: PUSH
109536: LD_INT 1
109538: ARRAY
109539: PPUSH
109540: LD_EXP 215
109544: PUSH
109545: LD_VAR 0 2
109549: ARRAY
109550: PUSH
109551: LD_INT 1
109553: ARRAY
109554: PUSH
109555: LD_INT 1
109557: ARRAY
109558: PPUSH
109559: LD_EXP 215
109563: PUSH
109564: LD_VAR 0 2
109568: ARRAY
109569: PUSH
109570: LD_INT 1
109572: ARRAY
109573: PUSH
109574: LD_INT 2
109576: ARRAY
109577: PPUSH
109578: CALL_OW 297
109582: PUSH
109583: LD_INT 6
109585: GREATER
109586: AND
109587: IFFALSE 109646
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
109589: LD_EXP 216
109593: PUSH
109594: LD_VAR 0 2
109598: ARRAY
109599: PUSH
109600: LD_INT 1
109602: ARRAY
109603: PPUSH
109604: LD_EXP 215
109608: PUSH
109609: LD_VAR 0 2
109613: ARRAY
109614: PUSH
109615: LD_INT 1
109617: ARRAY
109618: PUSH
109619: LD_INT 1
109621: ARRAY
109622: PPUSH
109623: LD_EXP 215
109627: PUSH
109628: LD_VAR 0 2
109632: ARRAY
109633: PUSH
109634: LD_INT 1
109636: ARRAY
109637: PUSH
109638: LD_INT 2
109640: ARRAY
109641: PPUSH
109642: CALL_OW 111
// end ; end ; end ;
109646: GO 109059
109648: POP
109649: POP
// end ;
109650: LD_VAR 0 1
109654: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
109655: LD_INT 0
109657: PPUSH
109658: PPUSH
109659: PPUSH
109660: PPUSH
109661: PPUSH
109662: PPUSH
109663: PPUSH
109664: PPUSH
109665: PPUSH
109666: PPUSH
109667: PPUSH
// if not mc_bases then
109668: LD_EXP 178
109672: NOT
109673: IFFALSE 109677
// exit ;
109675: GO 110617
// for i = 1 to mc_bases do
109677: LD_ADDR_VAR 0 2
109681: PUSH
109682: DOUBLE
109683: LD_INT 1
109685: DEC
109686: ST_TO_ADDR
109687: LD_EXP 178
109691: PUSH
109692: FOR_TO
109693: IFFALSE 110615
// begin if not mc_bases [ i ] or mc_scan [ i ] then
109695: LD_EXP 178
109699: PUSH
109700: LD_VAR 0 2
109704: ARRAY
109705: NOT
109706: PUSH
109707: LD_EXP 201
109711: PUSH
109712: LD_VAR 0 2
109716: ARRAY
109717: OR
109718: IFFALSE 109722
// continue ;
109720: GO 109692
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
109722: LD_ADDR_VAR 0 7
109726: PUSH
109727: LD_EXP 178
109731: PUSH
109732: LD_VAR 0 2
109736: ARRAY
109737: PUSH
109738: LD_INT 1
109740: ARRAY
109741: PPUSH
109742: CALL_OW 248
109746: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
109747: LD_VAR 0 7
109751: PUSH
109752: LD_INT 3
109754: EQUAL
109755: PUSH
109756: LD_EXP 197
109760: PUSH
109761: LD_VAR 0 2
109765: ARRAY
109766: PUSH
109767: LD_EXP 200
109771: PUSH
109772: LD_VAR 0 2
109776: ARRAY
109777: UNION
109778: PPUSH
109779: LD_INT 33
109781: PUSH
109782: LD_INT 2
109784: PUSH
109785: EMPTY
109786: LIST
109787: LIST
109788: PPUSH
109789: CALL_OW 72
109793: NOT
109794: OR
109795: IFFALSE 109799
// continue ;
109797: GO 109692
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
109799: LD_ADDR_VAR 0 9
109803: PUSH
109804: LD_EXP 178
109808: PUSH
109809: LD_VAR 0 2
109813: ARRAY
109814: PPUSH
109815: LD_INT 30
109817: PUSH
109818: LD_INT 36
109820: PUSH
109821: EMPTY
109822: LIST
109823: LIST
109824: PPUSH
109825: CALL_OW 72
109829: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
109830: LD_ADDR_VAR 0 10
109834: PUSH
109835: LD_EXP 197
109839: PUSH
109840: LD_VAR 0 2
109844: ARRAY
109845: PPUSH
109846: LD_INT 34
109848: PUSH
109849: LD_INT 31
109851: PUSH
109852: EMPTY
109853: LIST
109854: LIST
109855: PPUSH
109856: CALL_OW 72
109860: ST_TO_ADDR
// if not cts and not mcts then
109861: LD_VAR 0 9
109865: NOT
109866: PUSH
109867: LD_VAR 0 10
109871: NOT
109872: AND
109873: IFFALSE 109877
// continue ;
109875: GO 109692
// x := cts ;
109877: LD_ADDR_VAR 0 11
109881: PUSH
109882: LD_VAR 0 9
109886: ST_TO_ADDR
// if not x then
109887: LD_VAR 0 11
109891: NOT
109892: IFFALSE 109904
// x := mcts ;
109894: LD_ADDR_VAR 0 11
109898: PUSH
109899: LD_VAR 0 10
109903: ST_TO_ADDR
// if not x then
109904: LD_VAR 0 11
109908: NOT
109909: IFFALSE 109913
// continue ;
109911: GO 109692
// if mc_remote_driver [ i ] then
109913: LD_EXP 218
109917: PUSH
109918: LD_VAR 0 2
109922: ARRAY
109923: IFFALSE 110310
// for j in mc_remote_driver [ i ] do
109925: LD_ADDR_VAR 0 3
109929: PUSH
109930: LD_EXP 218
109934: PUSH
109935: LD_VAR 0 2
109939: ARRAY
109940: PUSH
109941: FOR_IN
109942: IFFALSE 110308
// begin if GetClass ( j ) <> 3 then
109944: LD_VAR 0 3
109948: PPUSH
109949: CALL_OW 257
109953: PUSH
109954: LD_INT 3
109956: NONEQUAL
109957: IFFALSE 110010
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
109959: LD_ADDR_EXP 218
109963: PUSH
109964: LD_EXP 218
109968: PPUSH
109969: LD_VAR 0 2
109973: PPUSH
109974: LD_EXP 218
109978: PUSH
109979: LD_VAR 0 2
109983: ARRAY
109984: PUSH
109985: LD_VAR 0 3
109989: DIFF
109990: PPUSH
109991: CALL_OW 1
109995: ST_TO_ADDR
// SetTag ( j , 0 ) ;
109996: LD_VAR 0 3
110000: PPUSH
110001: LD_INT 0
110003: PPUSH
110004: CALL_OW 109
// continue ;
110008: GO 109941
// end ; if UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) and not IsDriver ( j ) then
110010: LD_EXP 197
110014: PUSH
110015: LD_VAR 0 2
110019: ARRAY
110020: PPUSH
110021: LD_INT 34
110023: PUSH
110024: LD_INT 31
110026: PUSH
110027: EMPTY
110028: LIST
110029: LIST
110030: PUSH
110031: LD_INT 58
110033: PUSH
110034: EMPTY
110035: LIST
110036: PUSH
110037: EMPTY
110038: LIST
110039: LIST
110040: PPUSH
110041: CALL_OW 72
110045: PUSH
110046: LD_VAR 0 3
110050: PPUSH
110051: CALL 54217 0 1
110055: NOT
110056: AND
110057: IFFALSE 110128
// begin if IsInUnit ( j ) then
110059: LD_VAR 0 3
110063: PPUSH
110064: CALL_OW 310
110068: IFFALSE 110079
// ComExitBuilding ( j ) ;
110070: LD_VAR 0 3
110074: PPUSH
110075: CALL_OW 122
// AddComEnterUnit ( j , UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) [ 1 ] ) ;
110079: LD_VAR 0 3
110083: PPUSH
110084: LD_EXP 197
110088: PUSH
110089: LD_VAR 0 2
110093: ARRAY
110094: PPUSH
110095: LD_INT 34
110097: PUSH
110098: LD_INT 31
110100: PUSH
110101: EMPTY
110102: LIST
110103: LIST
110104: PUSH
110105: LD_INT 58
110107: PUSH
110108: EMPTY
110109: LIST
110110: PUSH
110111: EMPTY
110112: LIST
110113: LIST
110114: PPUSH
110115: CALL_OW 72
110119: PUSH
110120: LD_INT 1
110122: ARRAY
110123: PPUSH
110124: CALL_OW 180
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
110128: LD_VAR 0 3
110132: PPUSH
110133: CALL_OW 310
110137: NOT
110138: PUSH
110139: LD_VAR 0 3
110143: PPUSH
110144: CALL_OW 310
110148: PPUSH
110149: CALL_OW 266
110153: PUSH
110154: LD_INT 36
110156: NONEQUAL
110157: PUSH
110158: LD_VAR 0 3
110162: PPUSH
110163: CALL 54217 0 1
110167: NOT
110168: AND
110169: OR
110170: IFFALSE 110306
// begin if IsInUnit ( j ) then
110172: LD_VAR 0 3
110176: PPUSH
110177: CALL_OW 310
110181: IFFALSE 110192
// ComExitBuilding ( j ) ;
110183: LD_VAR 0 3
110187: PPUSH
110188: CALL_OW 122
// ct := 0 ;
110192: LD_ADDR_VAR 0 8
110196: PUSH
110197: LD_INT 0
110199: ST_TO_ADDR
// for k in x do
110200: LD_ADDR_VAR 0 4
110204: PUSH
110205: LD_VAR 0 11
110209: PUSH
110210: FOR_IN
110211: IFFALSE 110284
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
110213: LD_VAR 0 4
110217: PPUSH
110218: CALL_OW 264
110222: PUSH
110223: LD_INT 31
110225: EQUAL
110226: PUSH
110227: LD_VAR 0 4
110231: PPUSH
110232: CALL_OW 311
110236: NOT
110237: AND
110238: PUSH
110239: LD_VAR 0 4
110243: PPUSH
110244: CALL_OW 266
110248: PUSH
110249: LD_INT 36
110251: EQUAL
110252: PUSH
110253: LD_VAR 0 4
110257: PPUSH
110258: CALL_OW 313
110262: PUSH
110263: LD_INT 3
110265: LESS
110266: AND
110267: OR
110268: IFFALSE 110282
// begin ct := k ;
110270: LD_ADDR_VAR 0 8
110274: PUSH
110275: LD_VAR 0 4
110279: ST_TO_ADDR
// break ;
110280: GO 110284
// end ;
110282: GO 110210
110284: POP
110285: POP
// if ct then
110286: LD_VAR 0 8
110290: IFFALSE 110306
// ComEnterUnit ( j , ct ) ;
110292: LD_VAR 0 3
110296: PPUSH
110297: LD_VAR 0 8
110301: PPUSH
110302: CALL_OW 120
// end ; end ;
110306: GO 109941
110308: POP
110309: POP
// places := 0 ;
110310: LD_ADDR_VAR 0 5
110314: PUSH
110315: LD_INT 0
110317: ST_TO_ADDR
// for j = 1 to x do
110318: LD_ADDR_VAR 0 3
110322: PUSH
110323: DOUBLE
110324: LD_INT 1
110326: DEC
110327: ST_TO_ADDR
110328: LD_VAR 0 11
110332: PUSH
110333: FOR_TO
110334: IFFALSE 110410
// if GetWeapon ( x [ j ] ) = ar_control_tower then
110336: LD_VAR 0 11
110340: PUSH
110341: LD_VAR 0 3
110345: ARRAY
110346: PPUSH
110347: CALL_OW 264
110351: PUSH
110352: LD_INT 31
110354: EQUAL
110355: IFFALSE 110373
// places := places + 1 else
110357: LD_ADDR_VAR 0 5
110361: PUSH
110362: LD_VAR 0 5
110366: PUSH
110367: LD_INT 1
110369: PLUS
110370: ST_TO_ADDR
110371: GO 110408
// if GetBType ( x [ j ] ) = b_control_tower then
110373: LD_VAR 0 11
110377: PUSH
110378: LD_VAR 0 3
110382: ARRAY
110383: PPUSH
110384: CALL_OW 266
110388: PUSH
110389: LD_INT 36
110391: EQUAL
110392: IFFALSE 110408
// places := places + 3 ;
110394: LD_ADDR_VAR 0 5
110398: PUSH
110399: LD_VAR 0 5
110403: PUSH
110404: LD_INT 3
110406: PLUS
110407: ST_TO_ADDR
110408: GO 110333
110410: POP
110411: POP
// if places = 0 or places <= mc_remote_driver [ i ] then
110412: LD_VAR 0 5
110416: PUSH
110417: LD_INT 0
110419: EQUAL
110420: PUSH
110421: LD_VAR 0 5
110425: PUSH
110426: LD_EXP 218
110430: PUSH
110431: LD_VAR 0 2
110435: ARRAY
110436: LESSEQUAL
110437: OR
110438: IFFALSE 110442
// continue ;
110440: GO 109692
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
110442: LD_ADDR_VAR 0 6
110446: PUSH
110447: LD_EXP 178
110451: PUSH
110452: LD_VAR 0 2
110456: ARRAY
110457: PPUSH
110458: LD_INT 25
110460: PUSH
110461: LD_INT 3
110463: PUSH
110464: EMPTY
110465: LIST
110466: LIST
110467: PPUSH
110468: CALL_OW 72
110472: PUSH
110473: LD_EXP 218
110477: PUSH
110478: LD_VAR 0 2
110482: ARRAY
110483: DIFF
110484: PPUSH
110485: LD_INT 3
110487: PPUSH
110488: CALL 55117 0 2
110492: ST_TO_ADDR
// for j in tmp do
110493: LD_ADDR_VAR 0 3
110497: PUSH
110498: LD_VAR 0 6
110502: PUSH
110503: FOR_IN
110504: IFFALSE 110539
// if GetTag ( j ) > 0 then
110506: LD_VAR 0 3
110510: PPUSH
110511: CALL_OW 110
110515: PUSH
110516: LD_INT 0
110518: GREATER
110519: IFFALSE 110537
// tmp := tmp diff j ;
110521: LD_ADDR_VAR 0 6
110525: PUSH
110526: LD_VAR 0 6
110530: PUSH
110531: LD_VAR 0 3
110535: DIFF
110536: ST_TO_ADDR
110537: GO 110503
110539: POP
110540: POP
// if not tmp then
110541: LD_VAR 0 6
110545: NOT
110546: IFFALSE 110550
// continue ;
110548: GO 109692
// if places then
110550: LD_VAR 0 5
110554: IFFALSE 110613
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
110556: LD_ADDR_EXP 218
110560: PUSH
110561: LD_EXP 218
110565: PPUSH
110566: LD_VAR 0 2
110570: PPUSH
110571: LD_EXP 218
110575: PUSH
110576: LD_VAR 0 2
110580: ARRAY
110581: PUSH
110582: LD_VAR 0 6
110586: PUSH
110587: LD_INT 1
110589: ARRAY
110590: UNION
110591: PPUSH
110592: CALL_OW 1
110596: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
110597: LD_VAR 0 6
110601: PUSH
110602: LD_INT 1
110604: ARRAY
110605: PPUSH
110606: LD_INT 126
110608: PPUSH
110609: CALL_OW 109
// end ; end ;
110613: GO 109692
110615: POP
110616: POP
// end ;
110617: LD_VAR 0 1
110621: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
110622: LD_INT 0
110624: PPUSH
110625: PPUSH
110626: PPUSH
110627: PPUSH
110628: PPUSH
110629: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
110630: LD_VAR 0 1
110634: NOT
110635: PUSH
110636: LD_VAR 0 2
110640: NOT
110641: OR
110642: PUSH
110643: LD_VAR 0 3
110647: NOT
110648: OR
110649: PUSH
110650: LD_VAR 0 4
110654: PUSH
110655: LD_INT 1
110657: PUSH
110658: LD_INT 2
110660: PUSH
110661: LD_INT 3
110663: PUSH
110664: LD_INT 4
110666: PUSH
110667: LD_INT 5
110669: PUSH
110670: LD_INT 8
110672: PUSH
110673: LD_INT 9
110675: PUSH
110676: LD_INT 15
110678: PUSH
110679: LD_INT 16
110681: PUSH
110682: EMPTY
110683: LIST
110684: LIST
110685: LIST
110686: LIST
110687: LIST
110688: LIST
110689: LIST
110690: LIST
110691: LIST
110692: IN
110693: NOT
110694: OR
110695: IFFALSE 110699
// exit ;
110697: GO 111599
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
110699: LD_ADDR_VAR 0 2
110703: PUSH
110704: LD_VAR 0 2
110708: PPUSH
110709: LD_INT 21
110711: PUSH
110712: LD_INT 3
110714: PUSH
110715: EMPTY
110716: LIST
110717: LIST
110718: PUSH
110719: LD_INT 24
110721: PUSH
110722: LD_INT 250
110724: PUSH
110725: EMPTY
110726: LIST
110727: LIST
110728: PUSH
110729: EMPTY
110730: LIST
110731: LIST
110732: PPUSH
110733: CALL_OW 72
110737: ST_TO_ADDR
// case class of 1 , 15 :
110738: LD_VAR 0 4
110742: PUSH
110743: LD_INT 1
110745: DOUBLE
110746: EQUAL
110747: IFTRUE 110757
110749: LD_INT 15
110751: DOUBLE
110752: EQUAL
110753: IFTRUE 110757
110755: GO 110842
110757: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
110758: LD_ADDR_VAR 0 8
110762: PUSH
110763: LD_VAR 0 2
110767: PPUSH
110768: LD_INT 2
110770: PUSH
110771: LD_INT 30
110773: PUSH
110774: LD_INT 32
110776: PUSH
110777: EMPTY
110778: LIST
110779: LIST
110780: PUSH
110781: LD_INT 30
110783: PUSH
110784: LD_INT 31
110786: PUSH
110787: EMPTY
110788: LIST
110789: LIST
110790: PUSH
110791: EMPTY
110792: LIST
110793: LIST
110794: LIST
110795: PPUSH
110796: CALL_OW 72
110800: PUSH
110801: LD_VAR 0 2
110805: PPUSH
110806: LD_INT 2
110808: PUSH
110809: LD_INT 30
110811: PUSH
110812: LD_INT 4
110814: PUSH
110815: EMPTY
110816: LIST
110817: LIST
110818: PUSH
110819: LD_INT 30
110821: PUSH
110822: LD_INT 5
110824: PUSH
110825: EMPTY
110826: LIST
110827: LIST
110828: PUSH
110829: EMPTY
110830: LIST
110831: LIST
110832: LIST
110833: PPUSH
110834: CALL_OW 72
110838: ADD
110839: ST_TO_ADDR
110840: GO 111088
110842: LD_INT 2
110844: DOUBLE
110845: EQUAL
110846: IFTRUE 110856
110848: LD_INT 16
110850: DOUBLE
110851: EQUAL
110852: IFTRUE 110856
110854: GO 110902
110856: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
110857: LD_ADDR_VAR 0 8
110861: PUSH
110862: LD_VAR 0 2
110866: PPUSH
110867: LD_INT 2
110869: PUSH
110870: LD_INT 30
110872: PUSH
110873: LD_INT 0
110875: PUSH
110876: EMPTY
110877: LIST
110878: LIST
110879: PUSH
110880: LD_INT 30
110882: PUSH
110883: LD_INT 1
110885: PUSH
110886: EMPTY
110887: LIST
110888: LIST
110889: PUSH
110890: EMPTY
110891: LIST
110892: LIST
110893: LIST
110894: PPUSH
110895: CALL_OW 72
110899: ST_TO_ADDR
110900: GO 111088
110902: LD_INT 3
110904: DOUBLE
110905: EQUAL
110906: IFTRUE 110910
110908: GO 110956
110910: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
110911: LD_ADDR_VAR 0 8
110915: PUSH
110916: LD_VAR 0 2
110920: PPUSH
110921: LD_INT 2
110923: PUSH
110924: LD_INT 30
110926: PUSH
110927: LD_INT 2
110929: PUSH
110930: EMPTY
110931: LIST
110932: LIST
110933: PUSH
110934: LD_INT 30
110936: PUSH
110937: LD_INT 3
110939: PUSH
110940: EMPTY
110941: LIST
110942: LIST
110943: PUSH
110944: EMPTY
110945: LIST
110946: LIST
110947: LIST
110948: PPUSH
110949: CALL_OW 72
110953: ST_TO_ADDR
110954: GO 111088
110956: LD_INT 4
110958: DOUBLE
110959: EQUAL
110960: IFTRUE 110964
110962: GO 111021
110964: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
110965: LD_ADDR_VAR 0 8
110969: PUSH
110970: LD_VAR 0 2
110974: PPUSH
110975: LD_INT 2
110977: PUSH
110978: LD_INT 30
110980: PUSH
110981: LD_INT 6
110983: PUSH
110984: EMPTY
110985: LIST
110986: LIST
110987: PUSH
110988: LD_INT 30
110990: PUSH
110991: LD_INT 7
110993: PUSH
110994: EMPTY
110995: LIST
110996: LIST
110997: PUSH
110998: LD_INT 30
111000: PUSH
111001: LD_INT 8
111003: PUSH
111004: EMPTY
111005: LIST
111006: LIST
111007: PUSH
111008: EMPTY
111009: LIST
111010: LIST
111011: LIST
111012: LIST
111013: PPUSH
111014: CALL_OW 72
111018: ST_TO_ADDR
111019: GO 111088
111021: LD_INT 5
111023: DOUBLE
111024: EQUAL
111025: IFTRUE 111041
111027: LD_INT 8
111029: DOUBLE
111030: EQUAL
111031: IFTRUE 111041
111033: LD_INT 9
111035: DOUBLE
111036: EQUAL
111037: IFTRUE 111041
111039: GO 111087
111041: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
111042: LD_ADDR_VAR 0 8
111046: PUSH
111047: LD_VAR 0 2
111051: PPUSH
111052: LD_INT 2
111054: PUSH
111055: LD_INT 30
111057: PUSH
111058: LD_INT 4
111060: PUSH
111061: EMPTY
111062: LIST
111063: LIST
111064: PUSH
111065: LD_INT 30
111067: PUSH
111068: LD_INT 5
111070: PUSH
111071: EMPTY
111072: LIST
111073: LIST
111074: PUSH
111075: EMPTY
111076: LIST
111077: LIST
111078: LIST
111079: PPUSH
111080: CALL_OW 72
111084: ST_TO_ADDR
111085: GO 111088
111087: POP
// if not tmp then
111088: LD_VAR 0 8
111092: NOT
111093: IFFALSE 111097
// exit ;
111095: GO 111599
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
111097: LD_VAR 0 4
111101: PUSH
111102: LD_INT 1
111104: PUSH
111105: LD_INT 15
111107: PUSH
111108: EMPTY
111109: LIST
111110: LIST
111111: IN
111112: PUSH
111113: LD_EXP 187
111117: PUSH
111118: LD_VAR 0 1
111122: ARRAY
111123: AND
111124: IFFALSE 111280
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
111126: LD_ADDR_VAR 0 9
111130: PUSH
111131: LD_EXP 187
111135: PUSH
111136: LD_VAR 0 1
111140: ARRAY
111141: PUSH
111142: LD_INT 1
111144: ARRAY
111145: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
111146: LD_VAR 0 9
111150: PUSH
111151: LD_EXP 188
111155: PUSH
111156: LD_VAR 0 1
111160: ARRAY
111161: IN
111162: NOT
111163: IFFALSE 111278
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
111165: LD_ADDR_EXP 188
111169: PUSH
111170: LD_EXP 188
111174: PPUSH
111175: LD_VAR 0 1
111179: PUSH
111180: LD_EXP 188
111184: PUSH
111185: LD_VAR 0 1
111189: ARRAY
111190: PUSH
111191: LD_INT 1
111193: PLUS
111194: PUSH
111195: EMPTY
111196: LIST
111197: LIST
111198: PPUSH
111199: LD_VAR 0 9
111203: PPUSH
111204: CALL 24363 0 3
111208: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
111209: LD_ADDR_EXP 187
111213: PUSH
111214: LD_EXP 187
111218: PPUSH
111219: LD_VAR 0 1
111223: PPUSH
111224: LD_EXP 187
111228: PUSH
111229: LD_VAR 0 1
111233: ARRAY
111234: PUSH
111235: LD_VAR 0 9
111239: DIFF
111240: PPUSH
111241: CALL_OW 1
111245: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
111246: LD_VAR 0 3
111250: PPUSH
111251: LD_EXP 188
111255: PUSH
111256: LD_VAR 0 1
111260: ARRAY
111261: PUSH
111262: LD_EXP 188
111266: PUSH
111267: LD_VAR 0 1
111271: ARRAY
111272: ARRAY
111273: PPUSH
111274: CALL_OW 120
// end ; exit ;
111278: GO 111599
// end ; if tmp > 1 then
111280: LD_VAR 0 8
111284: PUSH
111285: LD_INT 1
111287: GREATER
111288: IFFALSE 111392
// for i = 2 to tmp do
111290: LD_ADDR_VAR 0 6
111294: PUSH
111295: DOUBLE
111296: LD_INT 2
111298: DEC
111299: ST_TO_ADDR
111300: LD_VAR 0 8
111304: PUSH
111305: FOR_TO
111306: IFFALSE 111390
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
111308: LD_VAR 0 8
111312: PUSH
111313: LD_VAR 0 6
111317: ARRAY
111318: PPUSH
111319: CALL_OW 461
111323: PUSH
111324: LD_INT 6
111326: EQUAL
111327: IFFALSE 111388
// begin x := tmp [ i ] ;
111329: LD_ADDR_VAR 0 9
111333: PUSH
111334: LD_VAR 0 8
111338: PUSH
111339: LD_VAR 0 6
111343: ARRAY
111344: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
111345: LD_ADDR_VAR 0 8
111349: PUSH
111350: LD_VAR 0 8
111354: PPUSH
111355: LD_VAR 0 6
111359: PPUSH
111360: CALL_OW 3
111364: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
111365: LD_ADDR_VAR 0 8
111369: PUSH
111370: LD_VAR 0 8
111374: PPUSH
111375: LD_INT 1
111377: PPUSH
111378: LD_VAR 0 9
111382: PPUSH
111383: CALL_OW 2
111387: ST_TO_ADDR
// end ;
111388: GO 111305
111390: POP
111391: POP
// for i in tmp do
111392: LD_ADDR_VAR 0 6
111396: PUSH
111397: LD_VAR 0 8
111401: PUSH
111402: FOR_IN
111403: IFFALSE 111472
// begin if ( UnitsInside ( i ) < 6 and not GetBType ( i ) in [ b_breastwork , b_bunker ] ) or UnitsInside ( i ) = 0 then
111405: LD_VAR 0 6
111409: PPUSH
111410: CALL_OW 313
111414: PUSH
111415: LD_INT 6
111417: LESS
111418: PUSH
111419: LD_VAR 0 6
111423: PPUSH
111424: CALL_OW 266
111428: PUSH
111429: LD_INT 31
111431: PUSH
111432: LD_INT 32
111434: PUSH
111435: EMPTY
111436: LIST
111437: LIST
111438: IN
111439: NOT
111440: AND
111441: PUSH
111442: LD_VAR 0 6
111446: PPUSH
111447: CALL_OW 313
111451: PUSH
111452: LD_INT 0
111454: EQUAL
111455: OR
111456: IFFALSE 111470
// begin j := i ;
111458: LD_ADDR_VAR 0 7
111462: PUSH
111463: LD_VAR 0 6
111467: ST_TO_ADDR
// break ;
111468: GO 111472
// end ; end ;
111470: GO 111402
111472: POP
111473: POP
// if j then
111474: LD_VAR 0 7
111478: IFFALSE 111496
// ComEnterUnit ( unit , j ) else
111480: LD_VAR 0 3
111484: PPUSH
111485: LD_VAR 0 7
111489: PPUSH
111490: CALL_OW 120
111494: GO 111599
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
111496: LD_ADDR_VAR 0 10
111500: PUSH
111501: LD_VAR 0 2
111505: PPUSH
111506: LD_INT 2
111508: PUSH
111509: LD_INT 30
111511: PUSH
111512: LD_INT 0
111514: PUSH
111515: EMPTY
111516: LIST
111517: LIST
111518: PUSH
111519: LD_INT 30
111521: PUSH
111522: LD_INT 1
111524: PUSH
111525: EMPTY
111526: LIST
111527: LIST
111528: PUSH
111529: EMPTY
111530: LIST
111531: LIST
111532: LIST
111533: PPUSH
111534: CALL_OW 72
111538: ST_TO_ADDR
// if depot then
111539: LD_VAR 0 10
111543: IFFALSE 111599
// begin depot := NearestUnitToUnit ( depot , unit ) ;
111545: LD_ADDR_VAR 0 10
111549: PUSH
111550: LD_VAR 0 10
111554: PPUSH
111555: LD_VAR 0 3
111559: PPUSH
111560: CALL_OW 74
111564: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
111565: LD_VAR 0 3
111569: PPUSH
111570: LD_VAR 0 10
111574: PPUSH
111575: CALL_OW 296
111579: PUSH
111580: LD_INT 10
111582: GREATER
111583: IFFALSE 111599
// ComStandNearbyBuilding ( unit , depot ) ;
111585: LD_VAR 0 3
111589: PPUSH
111590: LD_VAR 0 10
111594: PPUSH
111595: CALL 20788 0 2
// end ; end ; end ;
111599: LD_VAR 0 5
111603: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
111604: LD_INT 0
111606: PPUSH
111607: PPUSH
111608: PPUSH
111609: PPUSH
// if not mc_bases then
111610: LD_EXP 178
111614: NOT
111615: IFFALSE 111619
// exit ;
111617: GO 111858
// for i = 1 to mc_bases do
111619: LD_ADDR_VAR 0 2
111623: PUSH
111624: DOUBLE
111625: LD_INT 1
111627: DEC
111628: ST_TO_ADDR
111629: LD_EXP 178
111633: PUSH
111634: FOR_TO
111635: IFFALSE 111856
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
111637: LD_ADDR_VAR 0 4
111641: PUSH
111642: LD_EXP 178
111646: PUSH
111647: LD_VAR 0 2
111651: ARRAY
111652: PPUSH
111653: LD_INT 21
111655: PUSH
111656: LD_INT 1
111658: PUSH
111659: EMPTY
111660: LIST
111661: LIST
111662: PPUSH
111663: CALL_OW 72
111667: PUSH
111668: LD_EXP 207
111672: PUSH
111673: LD_VAR 0 2
111677: ARRAY
111678: UNION
111679: ST_TO_ADDR
// if not tmp then
111680: LD_VAR 0 4
111684: NOT
111685: IFFALSE 111689
// continue ;
111687: GO 111634
// for j in tmp do
111689: LD_ADDR_VAR 0 3
111693: PUSH
111694: LD_VAR 0 4
111698: PUSH
111699: FOR_IN
111700: IFFALSE 111852
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
111702: LD_VAR 0 3
111706: PPUSH
111707: CALL_OW 110
111711: NOT
111712: PUSH
111713: LD_VAR 0 3
111717: PPUSH
111718: CALL_OW 314
111722: NOT
111723: AND
111724: PUSH
111725: LD_VAR 0 3
111729: PPUSH
111730: CALL_OW 311
111734: NOT
111735: AND
111736: PUSH
111737: LD_VAR 0 3
111741: PPUSH
111742: CALL_OW 310
111746: NOT
111747: AND
111748: PUSH
111749: LD_VAR 0 3
111753: PUSH
111754: LD_EXP 181
111758: PUSH
111759: LD_VAR 0 2
111763: ARRAY
111764: PUSH
111765: LD_INT 1
111767: ARRAY
111768: IN
111769: NOT
111770: AND
111771: PUSH
111772: LD_VAR 0 3
111776: PUSH
111777: LD_EXP 181
111781: PUSH
111782: LD_VAR 0 2
111786: ARRAY
111787: PUSH
111788: LD_INT 2
111790: ARRAY
111791: IN
111792: NOT
111793: AND
111794: PUSH
111795: LD_VAR 0 3
111799: PUSH
111800: LD_EXP 190
111804: PUSH
111805: LD_VAR 0 2
111809: ARRAY
111810: IN
111811: NOT
111812: AND
111813: IFFALSE 111850
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
111815: LD_VAR 0 2
111819: PPUSH
111820: LD_EXP 178
111824: PUSH
111825: LD_VAR 0 2
111829: ARRAY
111830: PPUSH
111831: LD_VAR 0 3
111835: PPUSH
111836: LD_VAR 0 3
111840: PPUSH
111841: CALL_OW 257
111845: PPUSH
111846: CALL 110622 0 4
// end ;
111850: GO 111699
111852: POP
111853: POP
// end ;
111854: GO 111634
111856: POP
111857: POP
// end ;
111858: LD_VAR 0 1
111862: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , x , j ; begin
111863: LD_INT 0
111865: PPUSH
111866: PPUSH
111867: PPUSH
111868: PPUSH
111869: PPUSH
111870: PPUSH
// if not mc_bases [ base ] then
111871: LD_EXP 178
111875: PUSH
111876: LD_VAR 0 1
111880: ARRAY
111881: NOT
111882: IFFALSE 111886
// exit ;
111884: GO 112068
// tmp := [ ] ;
111886: LD_ADDR_VAR 0 6
111890: PUSH
111891: EMPTY
111892: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
111893: LD_ADDR_VAR 0 7
111897: PUSH
111898: LD_VAR 0 3
111902: PPUSH
111903: LD_INT 0
111905: PPUSH
111906: CALL_OW 517
111910: ST_TO_ADDR
// if not list then
111911: LD_VAR 0 7
111915: NOT
111916: IFFALSE 111920
// exit ;
111918: GO 112068
// for i = 1 to amount do
111920: LD_ADDR_VAR 0 5
111924: PUSH
111925: DOUBLE
111926: LD_INT 1
111928: DEC
111929: ST_TO_ADDR
111930: LD_VAR 0 2
111934: PUSH
111935: FOR_TO
111936: IFFALSE 112016
// begin x := rand ( 1 , list [ 1 ] ) ;
111938: LD_ADDR_VAR 0 8
111942: PUSH
111943: LD_INT 1
111945: PPUSH
111946: LD_VAR 0 7
111950: PUSH
111951: LD_INT 1
111953: ARRAY
111954: PPUSH
111955: CALL_OW 12
111959: ST_TO_ADDR
// tmp := Replace ( tmp , i , [ list [ 1 ] [ x ] , list [ 2 ] [ x ] ] ) ;
111960: LD_ADDR_VAR 0 6
111964: PUSH
111965: LD_VAR 0 6
111969: PPUSH
111970: LD_VAR 0 5
111974: PPUSH
111975: LD_VAR 0 7
111979: PUSH
111980: LD_INT 1
111982: ARRAY
111983: PUSH
111984: LD_VAR 0 8
111988: ARRAY
111989: PUSH
111990: LD_VAR 0 7
111994: PUSH
111995: LD_INT 2
111997: ARRAY
111998: PUSH
111999: LD_VAR 0 8
112003: ARRAY
112004: PUSH
112005: EMPTY
112006: LIST
112007: LIST
112008: PPUSH
112009: CALL_OW 1
112013: ST_TO_ADDR
// end ;
112014: GO 111935
112016: POP
112017: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
112018: LD_ADDR_EXP 191
112022: PUSH
112023: LD_EXP 191
112027: PPUSH
112028: LD_VAR 0 1
112032: PPUSH
112033: LD_VAR 0 6
112037: PPUSH
112038: CALL_OW 1
112042: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
112043: LD_ADDR_EXP 193
112047: PUSH
112048: LD_EXP 193
112052: PPUSH
112053: LD_VAR 0 1
112057: PPUSH
112058: LD_VAR 0 3
112062: PPUSH
112063: CALL_OW 1
112067: ST_TO_ADDR
// end ;
112068: LD_VAR 0 4
112072: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
112073: LD_INT 0
112075: PPUSH
// if not mc_bases [ base ] then
112076: LD_EXP 178
112080: PUSH
112081: LD_VAR 0 1
112085: ARRAY
112086: NOT
112087: IFFALSE 112091
// exit ;
112089: GO 112116
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
112091: LD_ADDR_EXP 183
112095: PUSH
112096: LD_EXP 183
112100: PPUSH
112101: LD_VAR 0 1
112105: PPUSH
112106: LD_VAR 0 2
112110: PPUSH
112111: CALL_OW 1
112115: ST_TO_ADDR
// end ;
112116: LD_VAR 0 3
112120: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
112121: LD_INT 0
112123: PPUSH
// if not mc_bases [ base ] then
112124: LD_EXP 178
112128: PUSH
112129: LD_VAR 0 1
112133: ARRAY
112134: NOT
112135: IFFALSE 112139
// exit ;
112137: GO 112176
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
112139: LD_ADDR_EXP 183
112143: PUSH
112144: LD_EXP 183
112148: PPUSH
112149: LD_VAR 0 1
112153: PPUSH
112154: LD_EXP 183
112158: PUSH
112159: LD_VAR 0 1
112163: ARRAY
112164: PUSH
112165: LD_VAR 0 2
112169: UNION
112170: PPUSH
112171: CALL_OW 1
112175: ST_TO_ADDR
// end ;
112176: LD_VAR 0 3
112180: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
112181: LD_INT 0
112183: PPUSH
// if not mc_bases [ base ] then
112184: LD_EXP 178
112188: PUSH
112189: LD_VAR 0 1
112193: ARRAY
112194: NOT
112195: IFFALSE 112199
// exit ;
112197: GO 112224
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
112199: LD_ADDR_EXP 199
112203: PUSH
112204: LD_EXP 199
112208: PPUSH
112209: LD_VAR 0 1
112213: PPUSH
112214: LD_VAR 0 2
112218: PPUSH
112219: CALL_OW 1
112223: ST_TO_ADDR
// end ;
112224: LD_VAR 0 3
112228: RET
// export function MC_InsertProduceList ( base , components ) ; begin
112229: LD_INT 0
112231: PPUSH
// if not mc_bases [ base ] then
112232: LD_EXP 178
112236: PUSH
112237: LD_VAR 0 1
112241: ARRAY
112242: NOT
112243: IFFALSE 112247
// exit ;
112245: GO 112284
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
112247: LD_ADDR_EXP 199
112251: PUSH
112252: LD_EXP 199
112256: PPUSH
112257: LD_VAR 0 1
112261: PPUSH
112262: LD_EXP 199
112266: PUSH
112267: LD_VAR 0 1
112271: ARRAY
112272: PUSH
112273: LD_VAR 0 2
112277: ADD
112278: PPUSH
112279: CALL_OW 1
112283: ST_TO_ADDR
// end ;
112284: LD_VAR 0 3
112288: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
112289: LD_INT 0
112291: PPUSH
// if not mc_bases [ base ] then
112292: LD_EXP 178
112296: PUSH
112297: LD_VAR 0 1
112301: ARRAY
112302: NOT
112303: IFFALSE 112307
// exit ;
112305: GO 112361
// mc_defender := Replace ( mc_defender , base , deflist ) ;
112307: LD_ADDR_EXP 200
112311: PUSH
112312: LD_EXP 200
112316: PPUSH
112317: LD_VAR 0 1
112321: PPUSH
112322: LD_VAR 0 2
112326: PPUSH
112327: CALL_OW 1
112331: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
112332: LD_ADDR_EXP 189
112336: PUSH
112337: LD_EXP 189
112341: PPUSH
112342: LD_VAR 0 1
112346: PPUSH
112347: LD_VAR 0 2
112351: PUSH
112352: LD_INT 0
112354: PLUS
112355: PPUSH
112356: CALL_OW 1
112360: ST_TO_ADDR
// end ;
112361: LD_VAR 0 3
112365: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
112366: LD_INT 0
112368: PPUSH
// if not mc_bases [ base ] then
112369: LD_EXP 178
112373: PUSH
112374: LD_VAR 0 1
112378: ARRAY
112379: NOT
112380: IFFALSE 112384
// exit ;
112382: GO 112409
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
112384: LD_ADDR_EXP 189
112388: PUSH
112389: LD_EXP 189
112393: PPUSH
112394: LD_VAR 0 1
112398: PPUSH
112399: LD_VAR 0 2
112403: PPUSH
112404: CALL_OW 1
112408: ST_TO_ADDR
// end ;
112409: LD_VAR 0 3
112413: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
112414: LD_INT 0
112416: PPUSH
112417: PPUSH
112418: PPUSH
112419: PPUSH
// if not mc_bases [ base ] then
112420: LD_EXP 178
112424: PUSH
112425: LD_VAR 0 1
112429: ARRAY
112430: NOT
112431: IFFALSE 112435
// exit ;
112433: GO 112500
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
112435: LD_ADDR_EXP 198
112439: PUSH
112440: LD_EXP 198
112444: PPUSH
112445: LD_VAR 0 1
112449: PUSH
112450: LD_EXP 198
112454: PUSH
112455: LD_VAR 0 1
112459: ARRAY
112460: PUSH
112461: LD_INT 1
112463: PLUS
112464: PUSH
112465: EMPTY
112466: LIST
112467: LIST
112468: PPUSH
112469: LD_VAR 0 1
112473: PUSH
112474: LD_VAR 0 2
112478: PUSH
112479: LD_VAR 0 3
112483: PUSH
112484: LD_VAR 0 4
112488: PUSH
112489: EMPTY
112490: LIST
112491: LIST
112492: LIST
112493: LIST
112494: PPUSH
112495: CALL 24363 0 3
112499: ST_TO_ADDR
// end ;
112500: LD_VAR 0 5
112504: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
112505: LD_INT 0
112507: PPUSH
// if not mc_bases [ base ] then
112508: LD_EXP 178
112512: PUSH
112513: LD_VAR 0 1
112517: ARRAY
112518: NOT
112519: IFFALSE 112523
// exit ;
112521: GO 112548
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
112523: LD_ADDR_EXP 215
112527: PUSH
112528: LD_EXP 215
112532: PPUSH
112533: LD_VAR 0 1
112537: PPUSH
112538: LD_VAR 0 2
112542: PPUSH
112543: CALL_OW 1
112547: ST_TO_ADDR
// end ;
112548: LD_VAR 0 3
112552: RET
// export function MC_GetMinesField ( base ) ; begin
112553: LD_INT 0
112555: PPUSH
// result := mc_mines [ base ] ;
112556: LD_ADDR_VAR 0 2
112560: PUSH
112561: LD_EXP 191
112565: PUSH
112566: LD_VAR 0 1
112570: ARRAY
112571: ST_TO_ADDR
// end ;
112572: LD_VAR 0 2
112576: RET
// export function MC_GetProduceList ( base ) ; begin
112577: LD_INT 0
112579: PPUSH
// result := mc_produce [ base ] ;
112580: LD_ADDR_VAR 0 2
112584: PUSH
112585: LD_EXP 199
112589: PUSH
112590: LD_VAR 0 1
112594: ARRAY
112595: ST_TO_ADDR
// end ;
112596: LD_VAR 0 2
112600: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
112601: LD_INT 0
112603: PPUSH
112604: PPUSH
// if not mc_bases then
112605: LD_EXP 178
112609: NOT
112610: IFFALSE 112614
// exit ;
112612: GO 112679
// if mc_bases [ base ] then
112614: LD_EXP 178
112618: PUSH
112619: LD_VAR 0 1
112623: ARRAY
112624: IFFALSE 112679
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
112626: LD_ADDR_VAR 0 3
112630: PUSH
112631: LD_EXP 178
112635: PUSH
112636: LD_VAR 0 1
112640: ARRAY
112641: PPUSH
112642: LD_INT 30
112644: PUSH
112645: LD_VAR 0 2
112649: PUSH
112650: EMPTY
112651: LIST
112652: LIST
112653: PPUSH
112654: CALL_OW 72
112658: ST_TO_ADDR
// if result then
112659: LD_VAR 0 3
112663: IFFALSE 112679
// result := result [ 1 ] ;
112665: LD_ADDR_VAR 0 3
112669: PUSH
112670: LD_VAR 0 3
112674: PUSH
112675: LD_INT 1
112677: ARRAY
112678: ST_TO_ADDR
// end ; end ;
112679: LD_VAR 0 3
112683: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
112684: LD_INT 0
112686: PPUSH
112687: PPUSH
// if not mc_bases then
112688: LD_EXP 178
112692: NOT
112693: IFFALSE 112697
// exit ;
112695: GO 112742
// if mc_bases [ base ] then
112697: LD_EXP 178
112701: PUSH
112702: LD_VAR 0 1
112706: ARRAY
112707: IFFALSE 112742
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
112709: LD_ADDR_VAR 0 3
112713: PUSH
112714: LD_EXP 178
112718: PUSH
112719: LD_VAR 0 1
112723: ARRAY
112724: PPUSH
112725: LD_INT 30
112727: PUSH
112728: LD_VAR 0 2
112732: PUSH
112733: EMPTY
112734: LIST
112735: LIST
112736: PPUSH
112737: CALL_OW 72
112741: ST_TO_ADDR
// end ;
112742: LD_VAR 0 3
112746: RET
// export function MC_SetTame ( base , area ) ; begin
112747: LD_INT 0
112749: PPUSH
// if not mc_bases or not base then
112750: LD_EXP 178
112754: NOT
112755: PUSH
112756: LD_VAR 0 1
112760: NOT
112761: OR
112762: IFFALSE 112766
// exit ;
112764: GO 112791
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
112766: LD_ADDR_EXP 206
112770: PUSH
112771: LD_EXP 206
112775: PPUSH
112776: LD_VAR 0 1
112780: PPUSH
112781: LD_VAR 0 2
112785: PPUSH
112786: CALL_OW 1
112790: ST_TO_ADDR
// end ;
112791: LD_VAR 0 3
112795: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
112796: LD_INT 0
112798: PPUSH
112799: PPUSH
// if not mc_bases or not base then
112800: LD_EXP 178
112804: NOT
112805: PUSH
112806: LD_VAR 0 1
112810: NOT
112811: OR
112812: IFFALSE 112816
// exit ;
112814: GO 112918
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
112816: LD_ADDR_VAR 0 4
112820: PUSH
112821: LD_EXP 178
112825: PUSH
112826: LD_VAR 0 1
112830: ARRAY
112831: PPUSH
112832: LD_INT 30
112834: PUSH
112835: LD_VAR 0 2
112839: PUSH
112840: EMPTY
112841: LIST
112842: LIST
112843: PPUSH
112844: CALL_OW 72
112848: ST_TO_ADDR
// if not tmp then
112849: LD_VAR 0 4
112853: NOT
112854: IFFALSE 112858
// exit ;
112856: GO 112918
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
112858: LD_ADDR_EXP 210
112862: PUSH
112863: LD_EXP 210
112867: PPUSH
112868: LD_VAR 0 1
112872: PPUSH
112873: LD_EXP 210
112877: PUSH
112878: LD_VAR 0 1
112882: ARRAY
112883: PPUSH
112884: LD_EXP 210
112888: PUSH
112889: LD_VAR 0 1
112893: ARRAY
112894: PUSH
112895: LD_INT 1
112897: PLUS
112898: PPUSH
112899: LD_VAR 0 4
112903: PUSH
112904: LD_INT 1
112906: ARRAY
112907: PPUSH
112908: CALL_OW 2
112912: PPUSH
112913: CALL_OW 1
112917: ST_TO_ADDR
// end ;
112918: LD_VAR 0 3
112922: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
112923: LD_INT 0
112925: PPUSH
112926: PPUSH
// if not mc_bases or not base or not kinds then
112927: LD_EXP 178
112931: NOT
112932: PUSH
112933: LD_VAR 0 1
112937: NOT
112938: OR
112939: PUSH
112940: LD_VAR 0 2
112944: NOT
112945: OR
112946: IFFALSE 112950
// exit ;
112948: GO 113011
// for i in kinds do
112950: LD_ADDR_VAR 0 4
112954: PUSH
112955: LD_VAR 0 2
112959: PUSH
112960: FOR_IN
112961: IFFALSE 113009
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
112963: LD_ADDR_EXP 212
112967: PUSH
112968: LD_EXP 212
112972: PPUSH
112973: LD_VAR 0 1
112977: PUSH
112978: LD_EXP 212
112982: PUSH
112983: LD_VAR 0 1
112987: ARRAY
112988: PUSH
112989: LD_INT 1
112991: PLUS
112992: PUSH
112993: EMPTY
112994: LIST
112995: LIST
112996: PPUSH
112997: LD_VAR 0 4
113001: PPUSH
113002: CALL 24363 0 3
113006: ST_TO_ADDR
113007: GO 112960
113009: POP
113010: POP
// end ;
113011: LD_VAR 0 3
113015: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
113016: LD_INT 0
113018: PPUSH
// if not mc_bases or not base or not areas then
113019: LD_EXP 178
113023: NOT
113024: PUSH
113025: LD_VAR 0 1
113029: NOT
113030: OR
113031: PUSH
113032: LD_VAR 0 2
113036: NOT
113037: OR
113038: IFFALSE 113042
// exit ;
113040: GO 113067
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
113042: LD_ADDR_EXP 196
113046: PUSH
113047: LD_EXP 196
113051: PPUSH
113052: LD_VAR 0 1
113056: PPUSH
113057: LD_VAR 0 2
113061: PPUSH
113062: CALL_OW 1
113066: ST_TO_ADDR
// end ;
113067: LD_VAR 0 3
113071: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
113072: LD_INT 0
113074: PPUSH
// if not mc_bases or not base or not teleports_exit then
113075: LD_EXP 178
113079: NOT
113080: PUSH
113081: LD_VAR 0 1
113085: NOT
113086: OR
113087: PUSH
113088: LD_VAR 0 2
113092: NOT
113093: OR
113094: IFFALSE 113098
// exit ;
113096: GO 113123
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
113098: LD_ADDR_EXP 213
113102: PUSH
113103: LD_EXP 213
113107: PPUSH
113108: LD_VAR 0 1
113112: PPUSH
113113: LD_VAR 0 2
113117: PPUSH
113118: CALL_OW 1
113122: ST_TO_ADDR
// end ;
113123: LD_VAR 0 3
113127: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
113128: LD_INT 0
113130: PPUSH
113131: PPUSH
113132: PPUSH
// if not mc_bases or not base or not ext_list then
113133: LD_EXP 178
113137: NOT
113138: PUSH
113139: LD_VAR 0 1
113143: NOT
113144: OR
113145: PUSH
113146: LD_VAR 0 5
113150: NOT
113151: OR
113152: IFFALSE 113156
// exit ;
113154: GO 113329
// tmp := GetFacExtXYD ( x , y , d ) ;
113156: LD_ADDR_VAR 0 8
113160: PUSH
113161: LD_VAR 0 2
113165: PPUSH
113166: LD_VAR 0 3
113170: PPUSH
113171: LD_VAR 0 4
113175: PPUSH
113176: CALL 54247 0 3
113180: ST_TO_ADDR
// if not tmp then
113181: LD_VAR 0 8
113185: NOT
113186: IFFALSE 113190
// exit ;
113188: GO 113329
// for i in tmp do
113190: LD_ADDR_VAR 0 7
113194: PUSH
113195: LD_VAR 0 8
113199: PUSH
113200: FOR_IN
113201: IFFALSE 113327
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
113203: LD_ADDR_EXP 183
113207: PUSH
113208: LD_EXP 183
113212: PPUSH
113213: LD_VAR 0 1
113217: PPUSH
113218: LD_EXP 183
113222: PUSH
113223: LD_VAR 0 1
113227: ARRAY
113228: PPUSH
113229: LD_EXP 183
113233: PUSH
113234: LD_VAR 0 1
113238: ARRAY
113239: PUSH
113240: LD_INT 1
113242: PLUS
113243: PPUSH
113244: LD_VAR 0 5
113248: PUSH
113249: LD_INT 1
113251: ARRAY
113252: PUSH
113253: LD_VAR 0 7
113257: PUSH
113258: LD_INT 1
113260: ARRAY
113261: PUSH
113262: LD_VAR 0 7
113266: PUSH
113267: LD_INT 2
113269: ARRAY
113270: PUSH
113271: LD_VAR 0 7
113275: PUSH
113276: LD_INT 3
113278: ARRAY
113279: PUSH
113280: EMPTY
113281: LIST
113282: LIST
113283: LIST
113284: LIST
113285: PPUSH
113286: CALL_OW 2
113290: PPUSH
113291: CALL_OW 1
113295: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
113296: LD_ADDR_VAR 0 5
113300: PUSH
113301: LD_VAR 0 5
113305: PPUSH
113306: LD_INT 1
113308: PPUSH
113309: CALL_OW 3
113313: ST_TO_ADDR
// if not ext_list then
113314: LD_VAR 0 5
113318: NOT
113319: IFFALSE 113325
// exit ;
113321: POP
113322: POP
113323: GO 113329
// end ;
113325: GO 113200
113327: POP
113328: POP
// end ;
113329: LD_VAR 0 6
113333: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
113334: LD_INT 0
113336: PPUSH
// if not mc_bases or not base or not weapon_list then
113337: LD_EXP 178
113341: NOT
113342: PUSH
113343: LD_VAR 0 1
113347: NOT
113348: OR
113349: PUSH
113350: LD_VAR 0 2
113354: NOT
113355: OR
113356: IFFALSE 113360
// exit ;
113358: GO 113385
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
113360: LD_ADDR_EXP 217
113364: PUSH
113365: LD_EXP 217
113369: PPUSH
113370: LD_VAR 0 1
113374: PPUSH
113375: LD_VAR 0 2
113379: PPUSH
113380: CALL_OW 1
113384: ST_TO_ADDR
// end ;
113385: LD_VAR 0 3
113389: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
113390: LD_INT 0
113392: PPUSH
// if not mc_bases or not base or not tech_list then
113393: LD_EXP 178
113397: NOT
113398: PUSH
113399: LD_VAR 0 1
113403: NOT
113404: OR
113405: PUSH
113406: LD_VAR 0 2
113410: NOT
113411: OR
113412: IFFALSE 113416
// exit ;
113414: GO 113441
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
113416: LD_ADDR_EXP 205
113420: PUSH
113421: LD_EXP 205
113425: PPUSH
113426: LD_VAR 0 1
113430: PPUSH
113431: LD_VAR 0 2
113435: PPUSH
113436: CALL_OW 1
113440: ST_TO_ADDR
// end ;
113441: LD_VAR 0 3
113445: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
113446: LD_INT 0
113448: PPUSH
// if not mc_bases or not parking_area or not base then
113449: LD_EXP 178
113453: NOT
113454: PUSH
113455: LD_VAR 0 2
113459: NOT
113460: OR
113461: PUSH
113462: LD_VAR 0 1
113466: NOT
113467: OR
113468: IFFALSE 113472
// exit ;
113470: GO 113497
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
113472: LD_ADDR_EXP 202
113476: PUSH
113477: LD_EXP 202
113481: PPUSH
113482: LD_VAR 0 1
113486: PPUSH
113487: LD_VAR 0 2
113491: PPUSH
113492: CALL_OW 1
113496: ST_TO_ADDR
// end ;
113497: LD_VAR 0 3
113501: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
113502: LD_INT 0
113504: PPUSH
// if not mc_bases or not base or not scan_area then
113505: LD_EXP 178
113509: NOT
113510: PUSH
113511: LD_VAR 0 1
113515: NOT
113516: OR
113517: PUSH
113518: LD_VAR 0 2
113522: NOT
113523: OR
113524: IFFALSE 113528
// exit ;
113526: GO 113553
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
113528: LD_ADDR_EXP 203
113532: PUSH
113533: LD_EXP 203
113537: PPUSH
113538: LD_VAR 0 1
113542: PPUSH
113543: LD_VAR 0 2
113547: PPUSH
113548: CALL_OW 1
113552: ST_TO_ADDR
// end ;
113553: LD_VAR 0 3
113557: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
113558: LD_INT 0
113560: PPUSH
113561: PPUSH
// if not mc_bases or not base then
113562: LD_EXP 178
113566: NOT
113567: PUSH
113568: LD_VAR 0 1
113572: NOT
113573: OR
113574: IFFALSE 113578
// exit ;
113576: GO 113642
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
113578: LD_ADDR_VAR 0 3
113582: PUSH
113583: LD_INT 1
113585: PUSH
113586: LD_INT 2
113588: PUSH
113589: LD_INT 3
113591: PUSH
113592: LD_INT 4
113594: PUSH
113595: LD_INT 11
113597: PUSH
113598: EMPTY
113599: LIST
113600: LIST
113601: LIST
113602: LIST
113603: LIST
113604: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
113605: LD_ADDR_EXP 205
113609: PUSH
113610: LD_EXP 205
113614: PPUSH
113615: LD_VAR 0 1
113619: PPUSH
113620: LD_EXP 205
113624: PUSH
113625: LD_VAR 0 1
113629: ARRAY
113630: PUSH
113631: LD_VAR 0 3
113635: DIFF
113636: PPUSH
113637: CALL_OW 1
113641: ST_TO_ADDR
// end ;
113642: LD_VAR 0 2
113646: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
113647: LD_INT 0
113649: PPUSH
// result := mc_vehicles [ base ] ;
113650: LD_ADDR_VAR 0 3
113654: PUSH
113655: LD_EXP 197
113659: PUSH
113660: LD_VAR 0 1
113664: ARRAY
113665: ST_TO_ADDR
// if onlyCombat then
113666: LD_VAR 0 2
113670: IFFALSE 113848
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
113672: LD_ADDR_VAR 0 3
113676: PUSH
113677: LD_VAR 0 3
113681: PUSH
113682: LD_VAR 0 3
113686: PPUSH
113687: LD_INT 2
113689: PUSH
113690: LD_INT 34
113692: PUSH
113693: LD_INT 12
113695: PUSH
113696: EMPTY
113697: LIST
113698: LIST
113699: PUSH
113700: LD_INT 34
113702: PUSH
113703: LD_INT 51
113705: PUSH
113706: EMPTY
113707: LIST
113708: LIST
113709: PUSH
113710: LD_INT 34
113712: PUSH
113713: LD_EXP 159
113717: PUSH
113718: EMPTY
113719: LIST
113720: LIST
113721: PUSH
113722: LD_INT 34
113724: PUSH
113725: LD_INT 32
113727: PUSH
113728: EMPTY
113729: LIST
113730: LIST
113731: PUSH
113732: LD_INT 34
113734: PUSH
113735: LD_INT 13
113737: PUSH
113738: EMPTY
113739: LIST
113740: LIST
113741: PUSH
113742: LD_INT 34
113744: PUSH
113745: LD_INT 52
113747: PUSH
113748: EMPTY
113749: LIST
113750: LIST
113751: PUSH
113752: LD_INT 34
113754: PUSH
113755: LD_EXP 164
113759: PUSH
113760: EMPTY
113761: LIST
113762: LIST
113763: PUSH
113764: LD_INT 34
113766: PUSH
113767: LD_INT 14
113769: PUSH
113770: EMPTY
113771: LIST
113772: LIST
113773: PUSH
113774: LD_INT 34
113776: PUSH
113777: LD_INT 53
113779: PUSH
113780: EMPTY
113781: LIST
113782: LIST
113783: PUSH
113784: LD_INT 34
113786: PUSH
113787: LD_EXP 158
113791: PUSH
113792: EMPTY
113793: LIST
113794: LIST
113795: PUSH
113796: LD_INT 34
113798: PUSH
113799: LD_INT 31
113801: PUSH
113802: EMPTY
113803: LIST
113804: LIST
113805: PUSH
113806: LD_INT 34
113808: PUSH
113809: LD_INT 48
113811: PUSH
113812: EMPTY
113813: LIST
113814: LIST
113815: PUSH
113816: LD_INT 34
113818: PUSH
113819: LD_INT 8
113821: PUSH
113822: EMPTY
113823: LIST
113824: LIST
113825: PUSH
113826: EMPTY
113827: LIST
113828: LIST
113829: LIST
113830: LIST
113831: LIST
113832: LIST
113833: LIST
113834: LIST
113835: LIST
113836: LIST
113837: LIST
113838: LIST
113839: LIST
113840: LIST
113841: PPUSH
113842: CALL_OW 72
113846: DIFF
113847: ST_TO_ADDR
// end ; end_of_file
113848: LD_VAR 0 3
113852: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
113853: LD_INT 0
113855: PPUSH
113856: PPUSH
113857: PPUSH
// if not mc_bases or not skirmish then
113858: LD_EXP 178
113862: NOT
113863: PUSH
113864: LD_EXP 176
113868: NOT
113869: OR
113870: IFFALSE 113874
// exit ;
113872: GO 114039
// for i = 1 to mc_bases do
113874: LD_ADDR_VAR 0 4
113878: PUSH
113879: DOUBLE
113880: LD_INT 1
113882: DEC
113883: ST_TO_ADDR
113884: LD_EXP 178
113888: PUSH
113889: FOR_TO
113890: IFFALSE 114037
// begin if sci in mc_bases [ i ] then
113892: LD_VAR 0 2
113896: PUSH
113897: LD_EXP 178
113901: PUSH
113902: LD_VAR 0 4
113906: ARRAY
113907: IN
113908: IFFALSE 114035
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
113910: LD_ADDR_EXP 207
113914: PUSH
113915: LD_EXP 207
113919: PPUSH
113920: LD_VAR 0 4
113924: PUSH
113925: LD_EXP 207
113929: PUSH
113930: LD_VAR 0 4
113934: ARRAY
113935: PUSH
113936: LD_INT 1
113938: PLUS
113939: PUSH
113940: EMPTY
113941: LIST
113942: LIST
113943: PPUSH
113944: LD_VAR 0 1
113948: PPUSH
113949: CALL 24363 0 3
113953: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
113954: LD_ADDR_VAR 0 5
113958: PUSH
113959: LD_EXP 178
113963: PUSH
113964: LD_VAR 0 4
113968: ARRAY
113969: PPUSH
113970: LD_INT 2
113972: PUSH
113973: LD_INT 30
113975: PUSH
113976: LD_INT 0
113978: PUSH
113979: EMPTY
113980: LIST
113981: LIST
113982: PUSH
113983: LD_INT 30
113985: PUSH
113986: LD_INT 1
113988: PUSH
113989: EMPTY
113990: LIST
113991: LIST
113992: PUSH
113993: EMPTY
113994: LIST
113995: LIST
113996: LIST
113997: PPUSH
113998: CALL_OW 72
114002: PPUSH
114003: LD_VAR 0 1
114007: PPUSH
114008: CALL_OW 74
114012: ST_TO_ADDR
// if tmp then
114013: LD_VAR 0 5
114017: IFFALSE 114033
// ComStandNearbyBuilding ( ape , tmp ) ;
114019: LD_VAR 0 1
114023: PPUSH
114024: LD_VAR 0 5
114028: PPUSH
114029: CALL 20788 0 2
// break ;
114033: GO 114037
// end ; end ;
114035: GO 113889
114037: POP
114038: POP
// end ;
114039: LD_VAR 0 3
114043: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
114044: LD_INT 0
114046: PPUSH
114047: PPUSH
114048: PPUSH
// if not mc_bases or not skirmish then
114049: LD_EXP 178
114053: NOT
114054: PUSH
114055: LD_EXP 176
114059: NOT
114060: OR
114061: IFFALSE 114065
// exit ;
114063: GO 114154
// for i = 1 to mc_bases do
114065: LD_ADDR_VAR 0 4
114069: PUSH
114070: DOUBLE
114071: LD_INT 1
114073: DEC
114074: ST_TO_ADDR
114075: LD_EXP 178
114079: PUSH
114080: FOR_TO
114081: IFFALSE 114152
// begin if building in mc_busy_turret_list [ i ] then
114083: LD_VAR 0 1
114087: PUSH
114088: LD_EXP 188
114092: PUSH
114093: LD_VAR 0 4
114097: ARRAY
114098: IN
114099: IFFALSE 114150
// begin tmp := mc_busy_turret_list [ i ] diff building ;
114101: LD_ADDR_VAR 0 5
114105: PUSH
114106: LD_EXP 188
114110: PUSH
114111: LD_VAR 0 4
114115: ARRAY
114116: PUSH
114117: LD_VAR 0 1
114121: DIFF
114122: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
114123: LD_ADDR_EXP 188
114127: PUSH
114128: LD_EXP 188
114132: PPUSH
114133: LD_VAR 0 4
114137: PPUSH
114138: LD_VAR 0 5
114142: PPUSH
114143: CALL_OW 1
114147: ST_TO_ADDR
// break ;
114148: GO 114152
// end ; end ;
114150: GO 114080
114152: POP
114153: POP
// end ;
114154: LD_VAR 0 3
114158: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
114159: LD_INT 0
114161: PPUSH
114162: PPUSH
114163: PPUSH
// if not mc_bases or not skirmish then
114164: LD_EXP 178
114168: NOT
114169: PUSH
114170: LD_EXP 176
114174: NOT
114175: OR
114176: IFFALSE 114180
// exit ;
114178: GO 114379
// for i = 1 to mc_bases do
114180: LD_ADDR_VAR 0 5
114184: PUSH
114185: DOUBLE
114186: LD_INT 1
114188: DEC
114189: ST_TO_ADDR
114190: LD_EXP 178
114194: PUSH
114195: FOR_TO
114196: IFFALSE 114377
// if building in mc_bases [ i ] then
114198: LD_VAR 0 1
114202: PUSH
114203: LD_EXP 178
114207: PUSH
114208: LD_VAR 0 5
114212: ARRAY
114213: IN
114214: IFFALSE 114375
// begin tmp := mc_bases [ i ] diff building ;
114216: LD_ADDR_VAR 0 6
114220: PUSH
114221: LD_EXP 178
114225: PUSH
114226: LD_VAR 0 5
114230: ARRAY
114231: PUSH
114232: LD_VAR 0 1
114236: DIFF
114237: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
114238: LD_ADDR_EXP 178
114242: PUSH
114243: LD_EXP 178
114247: PPUSH
114248: LD_VAR 0 5
114252: PPUSH
114253: LD_VAR 0 6
114257: PPUSH
114258: CALL_OW 1
114262: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
114263: LD_VAR 0 1
114267: PUSH
114268: LD_EXP 186
114272: PUSH
114273: LD_VAR 0 5
114277: ARRAY
114278: IN
114279: IFFALSE 114318
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
114281: LD_ADDR_EXP 186
114285: PUSH
114286: LD_EXP 186
114290: PPUSH
114291: LD_VAR 0 5
114295: PPUSH
114296: LD_EXP 186
114300: PUSH
114301: LD_VAR 0 5
114305: ARRAY
114306: PUSH
114307: LD_VAR 0 1
114311: DIFF
114312: PPUSH
114313: CALL_OW 1
114317: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
114318: LD_VAR 0 1
114322: PUSH
114323: LD_EXP 187
114327: PUSH
114328: LD_VAR 0 5
114332: ARRAY
114333: IN
114334: IFFALSE 114373
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
114336: LD_ADDR_EXP 187
114340: PUSH
114341: LD_EXP 187
114345: PPUSH
114346: LD_VAR 0 5
114350: PPUSH
114351: LD_EXP 187
114355: PUSH
114356: LD_VAR 0 5
114360: ARRAY
114361: PUSH
114362: LD_VAR 0 1
114366: DIFF
114367: PPUSH
114368: CALL_OW 1
114372: ST_TO_ADDR
// break ;
114373: GO 114377
// end ;
114375: GO 114195
114377: POP
114378: POP
// end ;
114379: LD_VAR 0 4
114383: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
114384: LD_INT 0
114386: PPUSH
114387: PPUSH
114388: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
114389: LD_EXP 178
114393: NOT
114394: PUSH
114395: LD_EXP 176
114399: NOT
114400: OR
114401: PUSH
114402: LD_VAR 0 3
114406: PUSH
114407: LD_EXP 204
114411: IN
114412: NOT
114413: OR
114414: IFFALSE 114418
// exit ;
114416: GO 114541
// for i = 1 to mc_vehicles do
114418: LD_ADDR_VAR 0 6
114422: PUSH
114423: DOUBLE
114424: LD_INT 1
114426: DEC
114427: ST_TO_ADDR
114428: LD_EXP 197
114432: PUSH
114433: FOR_TO
114434: IFFALSE 114539
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
114436: LD_VAR 0 2
114440: PUSH
114441: LD_EXP 197
114445: PUSH
114446: LD_VAR 0 6
114450: ARRAY
114451: IN
114452: PUSH
114453: LD_VAR 0 1
114457: PUSH
114458: LD_EXP 197
114462: PUSH
114463: LD_VAR 0 6
114467: ARRAY
114468: IN
114469: OR
114470: IFFALSE 114537
// begin tmp := mc_vehicles [ i ] diff old ;
114472: LD_ADDR_VAR 0 7
114476: PUSH
114477: LD_EXP 197
114481: PUSH
114482: LD_VAR 0 6
114486: ARRAY
114487: PUSH
114488: LD_VAR 0 2
114492: DIFF
114493: ST_TO_ADDR
// tmp := tmp diff new ;
114494: LD_ADDR_VAR 0 7
114498: PUSH
114499: LD_VAR 0 7
114503: PUSH
114504: LD_VAR 0 1
114508: DIFF
114509: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
114510: LD_ADDR_EXP 197
114514: PUSH
114515: LD_EXP 197
114519: PPUSH
114520: LD_VAR 0 6
114524: PPUSH
114525: LD_VAR 0 7
114529: PPUSH
114530: CALL_OW 1
114534: ST_TO_ADDR
// break ;
114535: GO 114539
// end ;
114537: GO 114433
114539: POP
114540: POP
// end ;
114541: LD_VAR 0 5
114545: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
114546: LD_INT 0
114548: PPUSH
114549: PPUSH
114550: PPUSH
114551: PPUSH
// if not mc_bases or not skirmish then
114552: LD_EXP 178
114556: NOT
114557: PUSH
114558: LD_EXP 176
114562: NOT
114563: OR
114564: IFFALSE 114568
// exit ;
114566: GO 114960
// side := GetSide ( vehicle ) ;
114568: LD_ADDR_VAR 0 5
114572: PUSH
114573: LD_VAR 0 1
114577: PPUSH
114578: CALL_OW 255
114582: ST_TO_ADDR
// for i = 1 to mc_bases do
114583: LD_ADDR_VAR 0 4
114587: PUSH
114588: DOUBLE
114589: LD_INT 1
114591: DEC
114592: ST_TO_ADDR
114593: LD_EXP 178
114597: PUSH
114598: FOR_TO
114599: IFFALSE 114958
// begin if factory in mc_bases [ i ] then
114601: LD_VAR 0 2
114605: PUSH
114606: LD_EXP 178
114610: PUSH
114611: LD_VAR 0 4
114615: ARRAY
114616: IN
114617: IFFALSE 114956
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ar_crane , ru_siberium_rocket , us_siberium_rocket ] then
114619: LD_EXP 200
114623: PUSH
114624: LD_VAR 0 4
114628: ARRAY
114629: PUSH
114630: LD_EXP 189
114634: PUSH
114635: LD_VAR 0 4
114639: ARRAY
114640: LESS
114641: PUSH
114642: LD_VAR 0 1
114646: PPUSH
114647: CALL_OW 264
114651: PUSH
114652: LD_INT 31
114654: PUSH
114655: LD_INT 32
114657: PUSH
114658: LD_INT 51
114660: PUSH
114661: LD_EXP 159
114665: PUSH
114666: LD_INT 12
114668: PUSH
114669: LD_INT 30
114671: PUSH
114672: LD_EXP 158
114676: PUSH
114677: LD_INT 11
114679: PUSH
114680: LD_INT 53
114682: PUSH
114683: LD_INT 14
114685: PUSH
114686: LD_EXP 162
114690: PUSH
114691: LD_INT 29
114693: PUSH
114694: LD_EXP 160
114698: PUSH
114699: LD_INT 13
114701: PUSH
114702: LD_INT 52
114704: PUSH
114705: LD_EXP 164
114709: PUSH
114710: LD_INT 48
114712: PUSH
114713: LD_INT 8
114715: PUSH
114716: EMPTY
114717: LIST
114718: LIST
114719: LIST
114720: LIST
114721: LIST
114722: LIST
114723: LIST
114724: LIST
114725: LIST
114726: LIST
114727: LIST
114728: LIST
114729: LIST
114730: LIST
114731: LIST
114732: LIST
114733: LIST
114734: LIST
114735: IN
114736: NOT
114737: AND
114738: IFFALSE 114786
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
114740: LD_ADDR_EXP 200
114744: PUSH
114745: LD_EXP 200
114749: PPUSH
114750: LD_VAR 0 4
114754: PUSH
114755: LD_EXP 200
114759: PUSH
114760: LD_VAR 0 4
114764: ARRAY
114765: PUSH
114766: LD_INT 1
114768: PLUS
114769: PUSH
114770: EMPTY
114771: LIST
114772: LIST
114773: PPUSH
114774: LD_VAR 0 1
114778: PPUSH
114779: CALL 24363 0 3
114783: ST_TO_ADDR
114784: GO 114830
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
114786: LD_ADDR_EXP 197
114790: PUSH
114791: LD_EXP 197
114795: PPUSH
114796: LD_VAR 0 4
114800: PUSH
114801: LD_EXP 197
114805: PUSH
114806: LD_VAR 0 4
114810: ARRAY
114811: PUSH
114812: LD_INT 1
114814: PLUS
114815: PUSH
114816: EMPTY
114817: LIST
114818: LIST
114819: PPUSH
114820: LD_VAR 0 1
114824: PPUSH
114825: CALL 24363 0 3
114829: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
114830: LD_VAR 0 1
114834: PPUSH
114835: CALL_OW 263
114839: PUSH
114840: LD_INT 2
114842: EQUAL
114843: IFFALSE 114872
// begin repeat wait ( 0 0$3 ) ;
114845: LD_INT 105
114847: PPUSH
114848: CALL_OW 67
// Connect ( vehicle ) ;
114852: LD_VAR 0 1
114856: PPUSH
114857: CALL 27334 0 1
// until IsControledBy ( vehicle ) ;
114861: LD_VAR 0 1
114865: PPUSH
114866: CALL_OW 312
114870: IFFALSE 114845
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
114872: LD_VAR 0 1
114876: PPUSH
114877: LD_EXP 202
114881: PUSH
114882: LD_VAR 0 4
114886: ARRAY
114887: PPUSH
114888: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
114892: LD_VAR 0 1
114896: PPUSH
114897: CALL_OW 263
114901: PUSH
114902: LD_INT 1
114904: NONEQUAL
114905: IFFALSE 114909
// break ;
114907: GO 114958
// repeat wait ( 0 0$1 ) ;
114909: LD_INT 35
114911: PPUSH
114912: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
114916: LD_VAR 0 1
114920: PPUSH
114921: LD_EXP 202
114925: PUSH
114926: LD_VAR 0 4
114930: ARRAY
114931: PPUSH
114932: CALL_OW 308
114936: IFFALSE 114909
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
114938: LD_VAR 0 1
114942: PPUSH
114943: CALL_OW 311
114947: PPUSH
114948: CALL_OW 121
// exit ;
114952: POP
114953: POP
114954: GO 114960
// end ; end ;
114956: GO 114598
114958: POP
114959: POP
// end ;
114960: LD_VAR 0 3
114964: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
114965: LD_INT 0
114967: PPUSH
114968: PPUSH
114969: PPUSH
114970: PPUSH
// if not mc_bases or not skirmish then
114971: LD_EXP 178
114975: NOT
114976: PUSH
114977: LD_EXP 176
114981: NOT
114982: OR
114983: IFFALSE 114987
// exit ;
114985: GO 115340
// repeat wait ( 0 0$1 ) ;
114987: LD_INT 35
114989: PPUSH
114990: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
114994: LD_VAR 0 2
114998: PPUSH
114999: LD_VAR 0 3
115003: PPUSH
115004: CALL_OW 284
115008: IFFALSE 114987
// if GetResourceTypeXY ( x , y ) = mat_artefact then
115010: LD_VAR 0 2
115014: PPUSH
115015: LD_VAR 0 3
115019: PPUSH
115020: CALL_OW 283
115024: PUSH
115025: LD_INT 4
115027: EQUAL
115028: IFFALSE 115032
// exit ;
115030: GO 115340
// for i = 1 to mc_bases do
115032: LD_ADDR_VAR 0 7
115036: PUSH
115037: DOUBLE
115038: LD_INT 1
115040: DEC
115041: ST_TO_ADDR
115042: LD_EXP 178
115046: PUSH
115047: FOR_TO
115048: IFFALSE 115338
// begin if mc_crates_area [ i ] then
115050: LD_EXP 196
115054: PUSH
115055: LD_VAR 0 7
115059: ARRAY
115060: IFFALSE 115171
// for j in mc_crates_area [ i ] do
115062: LD_ADDR_VAR 0 8
115066: PUSH
115067: LD_EXP 196
115071: PUSH
115072: LD_VAR 0 7
115076: ARRAY
115077: PUSH
115078: FOR_IN
115079: IFFALSE 115169
// if InArea ( x , y , j ) then
115081: LD_VAR 0 2
115085: PPUSH
115086: LD_VAR 0 3
115090: PPUSH
115091: LD_VAR 0 8
115095: PPUSH
115096: CALL_OW 309
115100: IFFALSE 115167
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
115102: LD_ADDR_EXP 194
115106: PUSH
115107: LD_EXP 194
115111: PPUSH
115112: LD_VAR 0 7
115116: PUSH
115117: LD_EXP 194
115121: PUSH
115122: LD_VAR 0 7
115126: ARRAY
115127: PUSH
115128: LD_INT 1
115130: PLUS
115131: PUSH
115132: EMPTY
115133: LIST
115134: LIST
115135: PPUSH
115136: LD_VAR 0 4
115140: PUSH
115141: LD_VAR 0 2
115145: PUSH
115146: LD_VAR 0 3
115150: PUSH
115151: EMPTY
115152: LIST
115153: LIST
115154: LIST
115155: PPUSH
115156: CALL 24363 0 3
115160: ST_TO_ADDR
// exit ;
115161: POP
115162: POP
115163: POP
115164: POP
115165: GO 115340
// end ;
115167: GO 115078
115169: POP
115170: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
115171: LD_ADDR_VAR 0 9
115175: PUSH
115176: LD_EXP 178
115180: PUSH
115181: LD_VAR 0 7
115185: ARRAY
115186: PPUSH
115187: LD_INT 2
115189: PUSH
115190: LD_INT 30
115192: PUSH
115193: LD_INT 0
115195: PUSH
115196: EMPTY
115197: LIST
115198: LIST
115199: PUSH
115200: LD_INT 30
115202: PUSH
115203: LD_INT 1
115205: PUSH
115206: EMPTY
115207: LIST
115208: LIST
115209: PUSH
115210: EMPTY
115211: LIST
115212: LIST
115213: LIST
115214: PPUSH
115215: CALL_OW 72
115219: ST_TO_ADDR
// if not depot then
115220: LD_VAR 0 9
115224: NOT
115225: IFFALSE 115229
// continue ;
115227: GO 115047
// for j in depot do
115229: LD_ADDR_VAR 0 8
115233: PUSH
115234: LD_VAR 0 9
115238: PUSH
115239: FOR_IN
115240: IFFALSE 115334
// if GetDistUnitXY ( j , x , y ) < 30 then
115242: LD_VAR 0 8
115246: PPUSH
115247: LD_VAR 0 2
115251: PPUSH
115252: LD_VAR 0 3
115256: PPUSH
115257: CALL_OW 297
115261: PUSH
115262: LD_INT 30
115264: LESS
115265: IFFALSE 115332
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
115267: LD_ADDR_EXP 194
115271: PUSH
115272: LD_EXP 194
115276: PPUSH
115277: LD_VAR 0 7
115281: PUSH
115282: LD_EXP 194
115286: PUSH
115287: LD_VAR 0 7
115291: ARRAY
115292: PUSH
115293: LD_INT 1
115295: PLUS
115296: PUSH
115297: EMPTY
115298: LIST
115299: LIST
115300: PPUSH
115301: LD_VAR 0 4
115305: PUSH
115306: LD_VAR 0 2
115310: PUSH
115311: LD_VAR 0 3
115315: PUSH
115316: EMPTY
115317: LIST
115318: LIST
115319: LIST
115320: PPUSH
115321: CALL 24363 0 3
115325: ST_TO_ADDR
// exit ;
115326: POP
115327: POP
115328: POP
115329: POP
115330: GO 115340
// end ;
115332: GO 115239
115334: POP
115335: POP
// end ;
115336: GO 115047
115338: POP
115339: POP
// end ;
115340: LD_VAR 0 6
115344: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
115345: LD_INT 0
115347: PPUSH
115348: PPUSH
115349: PPUSH
115350: PPUSH
// if not mc_bases or not skirmish then
115351: LD_EXP 178
115355: NOT
115356: PUSH
115357: LD_EXP 176
115361: NOT
115362: OR
115363: IFFALSE 115367
// exit ;
115365: GO 115644
// side := GetSide ( lab ) ;
115367: LD_ADDR_VAR 0 4
115371: PUSH
115372: LD_VAR 0 2
115376: PPUSH
115377: CALL_OW 255
115381: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
115382: LD_VAR 0 4
115386: PUSH
115387: LD_EXP 204
115391: IN
115392: NOT
115393: PUSH
115394: LD_EXP 205
115398: NOT
115399: OR
115400: PUSH
115401: LD_EXP 178
115405: NOT
115406: OR
115407: IFFALSE 115411
// exit ;
115409: GO 115644
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
115411: LD_ADDR_EXP 205
115415: PUSH
115416: LD_EXP 205
115420: PPUSH
115421: LD_VAR 0 4
115425: PPUSH
115426: LD_EXP 205
115430: PUSH
115431: LD_VAR 0 4
115435: ARRAY
115436: PUSH
115437: LD_VAR 0 1
115441: DIFF
115442: PPUSH
115443: CALL_OW 1
115447: ST_TO_ADDR
// for i = 1 to mc_bases do
115448: LD_ADDR_VAR 0 5
115452: PUSH
115453: DOUBLE
115454: LD_INT 1
115456: DEC
115457: ST_TO_ADDR
115458: LD_EXP 178
115462: PUSH
115463: FOR_TO
115464: IFFALSE 115642
// begin if lab in mc_bases [ i ] then
115466: LD_VAR 0 2
115470: PUSH
115471: LD_EXP 178
115475: PUSH
115476: LD_VAR 0 5
115480: ARRAY
115481: IN
115482: IFFALSE 115640
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
115484: LD_VAR 0 1
115488: PUSH
115489: LD_INT 11
115491: PUSH
115492: LD_INT 4
115494: PUSH
115495: LD_INT 3
115497: PUSH
115498: LD_INT 2
115500: PUSH
115501: EMPTY
115502: LIST
115503: LIST
115504: LIST
115505: LIST
115506: IN
115507: PUSH
115508: LD_EXP 208
115512: PUSH
115513: LD_VAR 0 5
115517: ARRAY
115518: AND
115519: IFFALSE 115640
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
115521: LD_ADDR_VAR 0 6
115525: PUSH
115526: LD_EXP 208
115530: PUSH
115531: LD_VAR 0 5
115535: ARRAY
115536: PUSH
115537: LD_INT 1
115539: ARRAY
115540: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
115541: LD_ADDR_EXP 208
115545: PUSH
115546: LD_EXP 208
115550: PPUSH
115551: LD_VAR 0 5
115555: PPUSH
115556: EMPTY
115557: PPUSH
115558: CALL_OW 1
115562: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
115563: LD_VAR 0 6
115567: PPUSH
115568: LD_INT 0
115570: PPUSH
115571: CALL_OW 109
// ComExitBuilding ( tmp ) ;
115575: LD_VAR 0 6
115579: PPUSH
115580: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
115584: LD_ADDR_EXP 207
115588: PUSH
115589: LD_EXP 207
115593: PPUSH
115594: LD_VAR 0 5
115598: PPUSH
115599: LD_EXP 207
115603: PUSH
115604: LD_VAR 0 5
115608: ARRAY
115609: PPUSH
115610: LD_INT 1
115612: PPUSH
115613: LD_VAR 0 6
115617: PPUSH
115618: CALL_OW 2
115622: PPUSH
115623: CALL_OW 1
115627: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
115628: LD_VAR 0 5
115632: PPUSH
115633: LD_INT 112
115635: PPUSH
115636: CALL 92163 0 2
// end ; end ; end ;
115640: GO 115463
115642: POP
115643: POP
// end ;
115644: LD_VAR 0 3
115648: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
115649: LD_INT 0
115651: PPUSH
115652: PPUSH
115653: PPUSH
115654: PPUSH
115655: PPUSH
115656: PPUSH
115657: PPUSH
115658: PPUSH
// if not mc_bases or not skirmish then
115659: LD_EXP 178
115663: NOT
115664: PUSH
115665: LD_EXP 176
115669: NOT
115670: OR
115671: IFFALSE 115675
// exit ;
115673: GO 117046
// for i = 1 to mc_bases do
115675: LD_ADDR_VAR 0 3
115679: PUSH
115680: DOUBLE
115681: LD_INT 1
115683: DEC
115684: ST_TO_ADDR
115685: LD_EXP 178
115689: PUSH
115690: FOR_TO
115691: IFFALSE 117044
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
115693: LD_VAR 0 1
115697: PUSH
115698: LD_EXP 178
115702: PUSH
115703: LD_VAR 0 3
115707: ARRAY
115708: IN
115709: PUSH
115710: LD_VAR 0 1
115714: PUSH
115715: LD_EXP 185
115719: PUSH
115720: LD_VAR 0 3
115724: ARRAY
115725: IN
115726: OR
115727: PUSH
115728: LD_VAR 0 1
115732: PUSH
115733: LD_EXP 200
115737: PUSH
115738: LD_VAR 0 3
115742: ARRAY
115743: IN
115744: OR
115745: PUSH
115746: LD_VAR 0 1
115750: PUSH
115751: LD_EXP 197
115755: PUSH
115756: LD_VAR 0 3
115760: ARRAY
115761: IN
115762: OR
115763: PUSH
115764: LD_VAR 0 1
115768: PUSH
115769: LD_EXP 207
115773: PUSH
115774: LD_VAR 0 3
115778: ARRAY
115779: IN
115780: OR
115781: PUSH
115782: LD_VAR 0 1
115786: PUSH
115787: LD_EXP 208
115791: PUSH
115792: LD_VAR 0 3
115796: ARRAY
115797: IN
115798: OR
115799: IFFALSE 117042
// begin if un in mc_ape [ i ] then
115801: LD_VAR 0 1
115805: PUSH
115806: LD_EXP 207
115810: PUSH
115811: LD_VAR 0 3
115815: ARRAY
115816: IN
115817: IFFALSE 115856
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
115819: LD_ADDR_EXP 207
115823: PUSH
115824: LD_EXP 207
115828: PPUSH
115829: LD_VAR 0 3
115833: PPUSH
115834: LD_EXP 207
115838: PUSH
115839: LD_VAR 0 3
115843: ARRAY
115844: PUSH
115845: LD_VAR 0 1
115849: DIFF
115850: PPUSH
115851: CALL_OW 1
115855: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
115856: LD_VAR 0 1
115860: PUSH
115861: LD_EXP 208
115865: PUSH
115866: LD_VAR 0 3
115870: ARRAY
115871: IN
115872: IFFALSE 115896
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
115874: LD_ADDR_EXP 208
115878: PUSH
115879: LD_EXP 208
115883: PPUSH
115884: LD_VAR 0 3
115888: PPUSH
115889: EMPTY
115890: PPUSH
115891: CALL_OW 1
115895: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane , ar_control_tower ] ) then
115896: LD_VAR 0 1
115900: PPUSH
115901: CALL_OW 247
115905: PUSH
115906: LD_INT 2
115908: EQUAL
115909: PUSH
115910: LD_VAR 0 1
115914: PPUSH
115915: CALL_OW 110
115919: PUSH
115920: LD_INT 20
115922: EQUAL
115923: PUSH
115924: LD_VAR 0 1
115928: PUSH
115929: LD_EXP 200
115933: PUSH
115934: LD_VAR 0 3
115938: ARRAY
115939: IN
115940: OR
115941: PUSH
115942: LD_VAR 0 1
115946: PPUSH
115947: CALL_OW 264
115951: PUSH
115952: LD_INT 12
115954: PUSH
115955: LD_INT 51
115957: PUSH
115958: LD_EXP 159
115962: PUSH
115963: LD_INT 32
115965: PUSH
115966: LD_INT 13
115968: PUSH
115969: LD_INT 52
115971: PUSH
115972: LD_INT 31
115974: PUSH
115975: EMPTY
115976: LIST
115977: LIST
115978: LIST
115979: LIST
115980: LIST
115981: LIST
115982: LIST
115983: IN
115984: OR
115985: AND
115986: IFFALSE 116294
// begin if un in mc_defender [ i ] then
115988: LD_VAR 0 1
115992: PUSH
115993: LD_EXP 200
115997: PUSH
115998: LD_VAR 0 3
116002: ARRAY
116003: IN
116004: IFFALSE 116043
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
116006: LD_ADDR_EXP 200
116010: PUSH
116011: LD_EXP 200
116015: PPUSH
116016: LD_VAR 0 3
116020: PPUSH
116021: LD_EXP 200
116025: PUSH
116026: LD_VAR 0 3
116030: ARRAY
116031: PUSH
116032: LD_VAR 0 1
116036: DIFF
116037: PPUSH
116038: CALL_OW 1
116042: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
116043: LD_ADDR_VAR 0 8
116047: PUSH
116048: LD_VAR 0 3
116052: PPUSH
116053: LD_INT 3
116055: PPUSH
116056: CALL 112684 0 2
116060: ST_TO_ADDR
// if fac then
116061: LD_VAR 0 8
116065: IFFALSE 116294
// begin for j in fac do
116067: LD_ADDR_VAR 0 4
116071: PUSH
116072: LD_VAR 0 8
116076: PUSH
116077: FOR_IN
116078: IFFALSE 116292
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
116080: LD_ADDR_VAR 0 9
116084: PUSH
116085: LD_VAR 0 8
116089: PPUSH
116090: LD_VAR 0 1
116094: PPUSH
116095: CALL_OW 265
116099: PPUSH
116100: LD_VAR 0 1
116104: PPUSH
116105: CALL_OW 262
116109: PPUSH
116110: LD_VAR 0 1
116114: PPUSH
116115: CALL_OW 263
116119: PPUSH
116120: LD_VAR 0 1
116124: PPUSH
116125: CALL_OW 264
116129: PPUSH
116130: CALL 21859 0 5
116134: ST_TO_ADDR
// if components then
116135: LD_VAR 0 9
116139: IFFALSE 116290
// begin if GetWeapon ( un ) = ar_control_tower then
116141: LD_VAR 0 1
116145: PPUSH
116146: CALL_OW 264
116150: PUSH
116151: LD_INT 31
116153: EQUAL
116154: IFFALSE 116271
// begin SetTag ( IsDrivenBy ( un ) , 0 ) ;
116156: LD_VAR 0 1
116160: PPUSH
116161: CALL_OW 311
116165: PPUSH
116166: LD_INT 0
116168: PPUSH
116169: CALL_OW 109
// mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff IsDrivenBy ( un ) ) ;
116173: LD_ADDR_EXP 218
116177: PUSH
116178: LD_EXP 218
116182: PPUSH
116183: LD_VAR 0 3
116187: PPUSH
116188: LD_EXP 218
116192: PUSH
116193: LD_VAR 0 3
116197: ARRAY
116198: PUSH
116199: LD_VAR 0 1
116203: PPUSH
116204: CALL_OW 311
116208: DIFF
116209: PPUSH
116210: CALL_OW 1
116214: ST_TO_ADDR
// tmp := Insert ( mc_produce [ i ] , 1 , components ) ;
116215: LD_ADDR_VAR 0 7
116219: PUSH
116220: LD_EXP 199
116224: PUSH
116225: LD_VAR 0 3
116229: ARRAY
116230: PPUSH
116231: LD_INT 1
116233: PPUSH
116234: LD_VAR 0 9
116238: PPUSH
116239: CALL_OW 2
116243: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
116244: LD_ADDR_EXP 199
116248: PUSH
116249: LD_EXP 199
116253: PPUSH
116254: LD_VAR 0 3
116258: PPUSH
116259: LD_VAR 0 7
116263: PPUSH
116264: CALL_OW 1
116268: ST_TO_ADDR
// end else
116269: GO 116288
// MC_InsertProduceList ( i , [ components ] ) ;
116271: LD_VAR 0 3
116275: PPUSH
116276: LD_VAR 0 9
116280: PUSH
116281: EMPTY
116282: LIST
116283: PPUSH
116284: CALL 112229 0 2
// break ;
116288: GO 116292
// end ; end ;
116290: GO 116077
116292: POP
116293: POP
// end ; end ; if GetType ( un ) = unit_building then
116294: LD_VAR 0 1
116298: PPUSH
116299: CALL_OW 247
116303: PUSH
116304: LD_INT 3
116306: EQUAL
116307: IFFALSE 116710
// begin btype := GetBType ( un ) ;
116309: LD_ADDR_VAR 0 5
116313: PUSH
116314: LD_VAR 0 1
116318: PPUSH
116319: CALL_OW 266
116323: ST_TO_ADDR
// if btype in [ b_oil_mine , b_siberite_mine ] then
116324: LD_VAR 0 5
116328: PUSH
116329: LD_INT 29
116331: PUSH
116332: LD_INT 30
116334: PUSH
116335: EMPTY
116336: LIST
116337: LIST
116338: IN
116339: IFFALSE 116412
// begin if not GetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) then
116341: LD_VAR 0 1
116345: PPUSH
116346: CALL_OW 250
116350: PPUSH
116351: LD_VAR 0 1
116355: PPUSH
116356: CALL_OW 251
116360: PPUSH
116361: LD_VAR 0 1
116365: PPUSH
116366: CALL_OW 255
116370: PPUSH
116371: CALL_OW 440
116375: NOT
116376: IFFALSE 116412
// SetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) ;
116378: LD_VAR 0 1
116382: PPUSH
116383: CALL_OW 250
116387: PPUSH
116388: LD_VAR 0 1
116392: PPUSH
116393: CALL_OW 251
116397: PPUSH
116398: LD_VAR 0 1
116402: PPUSH
116403: CALL_OW 255
116407: PPUSH
116408: CALL_OW 441
// end ; if btype = b_warehouse then
116412: LD_VAR 0 5
116416: PUSH
116417: LD_INT 1
116419: EQUAL
116420: IFFALSE 116438
// begin btype := b_depot ;
116422: LD_ADDR_VAR 0 5
116426: PUSH
116427: LD_INT 0
116429: ST_TO_ADDR
// pos := 1 ;
116430: LD_ADDR_VAR 0 6
116434: PUSH
116435: LD_INT 1
116437: ST_TO_ADDR
// end ; if btype = b_factory then
116438: LD_VAR 0 5
116442: PUSH
116443: LD_INT 3
116445: EQUAL
116446: IFFALSE 116464
// begin btype := b_workshop ;
116448: LD_ADDR_VAR 0 5
116452: PUSH
116453: LD_INT 2
116455: ST_TO_ADDR
// pos := 1 ;
116456: LD_ADDR_VAR 0 6
116460: PUSH
116461: LD_INT 1
116463: ST_TO_ADDR
// end ; if btype = b_barracks then
116464: LD_VAR 0 5
116468: PUSH
116469: LD_INT 5
116471: EQUAL
116472: IFFALSE 116482
// btype := b_armoury ;
116474: LD_ADDR_VAR 0 5
116478: PUSH
116479: LD_INT 4
116481: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
116482: LD_VAR 0 5
116486: PUSH
116487: LD_INT 7
116489: PUSH
116490: LD_INT 8
116492: PUSH
116493: EMPTY
116494: LIST
116495: LIST
116496: IN
116497: IFFALSE 116507
// btype := b_lab ;
116499: LD_ADDR_VAR 0 5
116503: PUSH
116504: LD_INT 6
116506: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
116507: LD_ADDR_EXP 183
116511: PUSH
116512: LD_EXP 183
116516: PPUSH
116517: LD_VAR 0 3
116521: PUSH
116522: LD_EXP 183
116526: PUSH
116527: LD_VAR 0 3
116531: ARRAY
116532: PUSH
116533: LD_INT 1
116535: PLUS
116536: PUSH
116537: EMPTY
116538: LIST
116539: LIST
116540: PPUSH
116541: LD_VAR 0 5
116545: PUSH
116546: LD_VAR 0 1
116550: PPUSH
116551: CALL_OW 250
116555: PUSH
116556: LD_VAR 0 1
116560: PPUSH
116561: CALL_OW 251
116565: PUSH
116566: LD_VAR 0 1
116570: PPUSH
116571: CALL_OW 254
116575: PUSH
116576: EMPTY
116577: LIST
116578: LIST
116579: LIST
116580: LIST
116581: PPUSH
116582: CALL 24363 0 3
116586: ST_TO_ADDR
// if pos = 1 then
116587: LD_VAR 0 6
116591: PUSH
116592: LD_INT 1
116594: EQUAL
116595: IFFALSE 116710
// begin tmp := mc_build_list [ i ] ;
116597: LD_ADDR_VAR 0 7
116601: PUSH
116602: LD_EXP 183
116606: PUSH
116607: LD_VAR 0 3
116611: ARRAY
116612: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
116613: LD_VAR 0 7
116617: PPUSH
116618: LD_INT 2
116620: PUSH
116621: LD_INT 30
116623: PUSH
116624: LD_INT 0
116626: PUSH
116627: EMPTY
116628: LIST
116629: LIST
116630: PUSH
116631: LD_INT 30
116633: PUSH
116634: LD_INT 1
116636: PUSH
116637: EMPTY
116638: LIST
116639: LIST
116640: PUSH
116641: EMPTY
116642: LIST
116643: LIST
116644: LIST
116645: PPUSH
116646: CALL_OW 72
116650: IFFALSE 116660
// pos := 2 ;
116652: LD_ADDR_VAR 0 6
116656: PUSH
116657: LD_INT 2
116659: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
116660: LD_ADDR_VAR 0 7
116664: PUSH
116665: LD_VAR 0 7
116669: PPUSH
116670: LD_VAR 0 6
116674: PPUSH
116675: LD_VAR 0 7
116679: PPUSH
116680: CALL 24689 0 3
116684: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
116685: LD_ADDR_EXP 183
116689: PUSH
116690: LD_EXP 183
116694: PPUSH
116695: LD_VAR 0 3
116699: PPUSH
116700: LD_VAR 0 7
116704: PPUSH
116705: CALL_OW 1
116709: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
116710: LD_VAR 0 1
116714: PUSH
116715: LD_EXP 178
116719: PUSH
116720: LD_VAR 0 3
116724: ARRAY
116725: IN
116726: IFFALSE 116765
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
116728: LD_ADDR_EXP 178
116732: PUSH
116733: LD_EXP 178
116737: PPUSH
116738: LD_VAR 0 3
116742: PPUSH
116743: LD_EXP 178
116747: PUSH
116748: LD_VAR 0 3
116752: ARRAY
116753: PUSH
116754: LD_VAR 0 1
116758: DIFF
116759: PPUSH
116760: CALL_OW 1
116764: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
116765: LD_VAR 0 1
116769: PUSH
116770: LD_EXP 185
116774: PUSH
116775: LD_VAR 0 3
116779: ARRAY
116780: IN
116781: IFFALSE 116820
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
116783: LD_ADDR_EXP 185
116787: PUSH
116788: LD_EXP 185
116792: PPUSH
116793: LD_VAR 0 3
116797: PPUSH
116798: LD_EXP 185
116802: PUSH
116803: LD_VAR 0 3
116807: ARRAY
116808: PUSH
116809: LD_VAR 0 1
116813: DIFF
116814: PPUSH
116815: CALL_OW 1
116819: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
116820: LD_VAR 0 1
116824: PUSH
116825: LD_EXP 197
116829: PUSH
116830: LD_VAR 0 3
116834: ARRAY
116835: IN
116836: IFFALSE 116875
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
116838: LD_ADDR_EXP 197
116842: PUSH
116843: LD_EXP 197
116847: PPUSH
116848: LD_VAR 0 3
116852: PPUSH
116853: LD_EXP 197
116857: PUSH
116858: LD_VAR 0 3
116862: ARRAY
116863: PUSH
116864: LD_VAR 0 1
116868: DIFF
116869: PPUSH
116870: CALL_OW 1
116874: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
116875: LD_VAR 0 1
116879: PUSH
116880: LD_EXP 200
116884: PUSH
116885: LD_VAR 0 3
116889: ARRAY
116890: IN
116891: IFFALSE 116930
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
116893: LD_ADDR_EXP 200
116897: PUSH
116898: LD_EXP 200
116902: PPUSH
116903: LD_VAR 0 3
116907: PPUSH
116908: LD_EXP 200
116912: PUSH
116913: LD_VAR 0 3
116917: ARRAY
116918: PUSH
116919: LD_VAR 0 1
116923: DIFF
116924: PPUSH
116925: CALL_OW 1
116929: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
116930: LD_VAR 0 1
116934: PUSH
116935: LD_EXP 187
116939: PUSH
116940: LD_VAR 0 3
116944: ARRAY
116945: IN
116946: IFFALSE 116985
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
116948: LD_ADDR_EXP 187
116952: PUSH
116953: LD_EXP 187
116957: PPUSH
116958: LD_VAR 0 3
116962: PPUSH
116963: LD_EXP 187
116967: PUSH
116968: LD_VAR 0 3
116972: ARRAY
116973: PUSH
116974: LD_VAR 0 1
116978: DIFF
116979: PPUSH
116980: CALL_OW 1
116984: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
116985: LD_VAR 0 1
116989: PUSH
116990: LD_EXP 186
116994: PUSH
116995: LD_VAR 0 3
116999: ARRAY
117000: IN
117001: IFFALSE 117040
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
117003: LD_ADDR_EXP 186
117007: PUSH
117008: LD_EXP 186
117012: PPUSH
117013: LD_VAR 0 3
117017: PPUSH
117018: LD_EXP 186
117022: PUSH
117023: LD_VAR 0 3
117027: ARRAY
117028: PUSH
117029: LD_VAR 0 1
117033: DIFF
117034: PPUSH
117035: CALL_OW 1
117039: ST_TO_ADDR
// end ; break ;
117040: GO 117044
// end ;
117042: GO 115690
117044: POP
117045: POP
// end ;
117046: LD_VAR 0 2
117050: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
117051: LD_INT 0
117053: PPUSH
117054: PPUSH
117055: PPUSH
// if not mc_bases or not skirmish then
117056: LD_EXP 178
117060: NOT
117061: PUSH
117062: LD_EXP 176
117066: NOT
117067: OR
117068: IFFALSE 117072
// exit ;
117070: GO 117287
// for i = 1 to mc_bases do
117072: LD_ADDR_VAR 0 3
117076: PUSH
117077: DOUBLE
117078: LD_INT 1
117080: DEC
117081: ST_TO_ADDR
117082: LD_EXP 178
117086: PUSH
117087: FOR_TO
117088: IFFALSE 117285
// begin if building in mc_construct_list [ i ] then
117090: LD_VAR 0 1
117094: PUSH
117095: LD_EXP 185
117099: PUSH
117100: LD_VAR 0 3
117104: ARRAY
117105: IN
117106: IFFALSE 117283
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
117108: LD_ADDR_EXP 185
117112: PUSH
117113: LD_EXP 185
117117: PPUSH
117118: LD_VAR 0 3
117122: PPUSH
117123: LD_EXP 185
117127: PUSH
117128: LD_VAR 0 3
117132: ARRAY
117133: PUSH
117134: LD_VAR 0 1
117138: DIFF
117139: PPUSH
117140: CALL_OW 1
117144: ST_TO_ADDR
// if building in mc_lab [ i ] then
117145: LD_VAR 0 1
117149: PUSH
117150: LD_EXP 211
117154: PUSH
117155: LD_VAR 0 3
117159: ARRAY
117160: IN
117161: IFFALSE 117216
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
117163: LD_ADDR_EXP 212
117167: PUSH
117168: LD_EXP 212
117172: PPUSH
117173: LD_VAR 0 3
117177: PPUSH
117178: LD_EXP 212
117182: PUSH
117183: LD_VAR 0 3
117187: ARRAY
117188: PPUSH
117189: LD_INT 1
117191: PPUSH
117192: LD_EXP 212
117196: PUSH
117197: LD_VAR 0 3
117201: ARRAY
117202: PPUSH
117203: LD_INT 0
117205: PPUSH
117206: CALL 23781 0 4
117210: PPUSH
117211: CALL_OW 1
117215: ST_TO_ADDR
// if not building in mc_bases [ i ] then
117216: LD_VAR 0 1
117220: PUSH
117221: LD_EXP 178
117225: PUSH
117226: LD_VAR 0 3
117230: ARRAY
117231: IN
117232: NOT
117233: IFFALSE 117279
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
117235: LD_ADDR_EXP 178
117239: PUSH
117240: LD_EXP 178
117244: PPUSH
117245: LD_VAR 0 3
117249: PUSH
117250: LD_EXP 178
117254: PUSH
117255: LD_VAR 0 3
117259: ARRAY
117260: PUSH
117261: LD_INT 1
117263: PLUS
117264: PUSH
117265: EMPTY
117266: LIST
117267: LIST
117268: PPUSH
117269: LD_VAR 0 1
117273: PPUSH
117274: CALL 24363 0 3
117278: ST_TO_ADDR
// exit ;
117279: POP
117280: POP
117281: GO 117287
// end ; end ;
117283: GO 117087
117285: POP
117286: POP
// end ;
117287: LD_VAR 0 2
117291: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
117292: LD_INT 0
117294: PPUSH
117295: PPUSH
117296: PPUSH
117297: PPUSH
117298: PPUSH
117299: PPUSH
117300: PPUSH
// if not mc_bases or not skirmish then
117301: LD_EXP 178
117305: NOT
117306: PUSH
117307: LD_EXP 176
117311: NOT
117312: OR
117313: IFFALSE 117317
// exit ;
117315: GO 117978
// for i = 1 to mc_bases do
117317: LD_ADDR_VAR 0 3
117321: PUSH
117322: DOUBLE
117323: LD_INT 1
117325: DEC
117326: ST_TO_ADDR
117327: LD_EXP 178
117331: PUSH
117332: FOR_TO
117333: IFFALSE 117976
// begin if building in mc_construct_list [ i ] then
117335: LD_VAR 0 1
117339: PUSH
117340: LD_EXP 185
117344: PUSH
117345: LD_VAR 0 3
117349: ARRAY
117350: IN
117351: IFFALSE 117974
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
117353: LD_ADDR_EXP 185
117357: PUSH
117358: LD_EXP 185
117362: PPUSH
117363: LD_VAR 0 3
117367: PPUSH
117368: LD_EXP 185
117372: PUSH
117373: LD_VAR 0 3
117377: ARRAY
117378: PUSH
117379: LD_VAR 0 1
117383: DIFF
117384: PPUSH
117385: CALL_OW 1
117389: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
117390: LD_ADDR_EXP 178
117394: PUSH
117395: LD_EXP 178
117399: PPUSH
117400: LD_VAR 0 3
117404: PUSH
117405: LD_EXP 178
117409: PUSH
117410: LD_VAR 0 3
117414: ARRAY
117415: PUSH
117416: LD_INT 1
117418: PLUS
117419: PUSH
117420: EMPTY
117421: LIST
117422: LIST
117423: PPUSH
117424: LD_VAR 0 1
117428: PPUSH
117429: CALL 24363 0 3
117433: ST_TO_ADDR
// btype := GetBType ( building ) ;
117434: LD_ADDR_VAR 0 5
117438: PUSH
117439: LD_VAR 0 1
117443: PPUSH
117444: CALL_OW 266
117448: ST_TO_ADDR
// side := GetSide ( building ) ;
117449: LD_ADDR_VAR 0 8
117453: PUSH
117454: LD_VAR 0 1
117458: PPUSH
117459: CALL_OW 255
117463: ST_TO_ADDR
// if btype = b_lab then
117464: LD_VAR 0 5
117468: PUSH
117469: LD_INT 6
117471: EQUAL
117472: IFFALSE 117522
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
117474: LD_ADDR_EXP 211
117478: PUSH
117479: LD_EXP 211
117483: PPUSH
117484: LD_VAR 0 3
117488: PUSH
117489: LD_EXP 211
117493: PUSH
117494: LD_VAR 0 3
117498: ARRAY
117499: PUSH
117500: LD_INT 1
117502: PLUS
117503: PUSH
117504: EMPTY
117505: LIST
117506: LIST
117507: PPUSH
117508: LD_VAR 0 1
117512: PPUSH
117513: CALL 24363 0 3
117517: ST_TO_ADDR
// exit ;
117518: POP
117519: POP
117520: GO 117978
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
117522: LD_VAR 0 5
117526: PUSH
117527: LD_INT 0
117529: PUSH
117530: LD_INT 2
117532: PUSH
117533: LD_INT 4
117535: PUSH
117536: EMPTY
117537: LIST
117538: LIST
117539: LIST
117540: IN
117541: IFFALSE 117665
// begin if btype = b_armoury then
117543: LD_VAR 0 5
117547: PUSH
117548: LD_INT 4
117550: EQUAL
117551: IFFALSE 117561
// btype := b_barracks ;
117553: LD_ADDR_VAR 0 5
117557: PUSH
117558: LD_INT 5
117560: ST_TO_ADDR
// if btype = b_depot then
117561: LD_VAR 0 5
117565: PUSH
117566: LD_INT 0
117568: EQUAL
117569: IFFALSE 117579
// btype := b_warehouse ;
117571: LD_ADDR_VAR 0 5
117575: PUSH
117576: LD_INT 1
117578: ST_TO_ADDR
// if btype = b_workshop then
117579: LD_VAR 0 5
117583: PUSH
117584: LD_INT 2
117586: EQUAL
117587: IFFALSE 117597
// btype := b_factory ;
117589: LD_ADDR_VAR 0 5
117593: PUSH
117594: LD_INT 3
117596: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
117597: LD_VAR 0 5
117601: PPUSH
117602: LD_VAR 0 8
117606: PPUSH
117607: CALL_OW 323
117611: PUSH
117612: LD_INT 1
117614: EQUAL
117615: IFFALSE 117661
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
117617: LD_ADDR_EXP 210
117621: PUSH
117622: LD_EXP 210
117626: PPUSH
117627: LD_VAR 0 3
117631: PUSH
117632: LD_EXP 210
117636: PUSH
117637: LD_VAR 0 3
117641: ARRAY
117642: PUSH
117643: LD_INT 1
117645: PLUS
117646: PUSH
117647: EMPTY
117648: LIST
117649: LIST
117650: PPUSH
117651: LD_VAR 0 1
117655: PPUSH
117656: CALL 24363 0 3
117660: ST_TO_ADDR
// exit ;
117661: POP
117662: POP
117663: GO 117978
// end ; if btype in [ b_bunker , b_turret ] then
117665: LD_VAR 0 5
117669: PUSH
117670: LD_INT 32
117672: PUSH
117673: LD_INT 33
117675: PUSH
117676: EMPTY
117677: LIST
117678: LIST
117679: IN
117680: IFFALSE 117970
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
117682: LD_ADDR_EXP 186
117686: PUSH
117687: LD_EXP 186
117691: PPUSH
117692: LD_VAR 0 3
117696: PUSH
117697: LD_EXP 186
117701: PUSH
117702: LD_VAR 0 3
117706: ARRAY
117707: PUSH
117708: LD_INT 1
117710: PLUS
117711: PUSH
117712: EMPTY
117713: LIST
117714: LIST
117715: PPUSH
117716: LD_VAR 0 1
117720: PPUSH
117721: CALL 24363 0 3
117725: ST_TO_ADDR
// if btype = b_bunker then
117726: LD_VAR 0 5
117730: PUSH
117731: LD_INT 32
117733: EQUAL
117734: IFFALSE 117970
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
117736: LD_ADDR_EXP 187
117740: PUSH
117741: LD_EXP 187
117745: PPUSH
117746: LD_VAR 0 3
117750: PUSH
117751: LD_EXP 187
117755: PUSH
117756: LD_VAR 0 3
117760: ARRAY
117761: PUSH
117762: LD_INT 1
117764: PLUS
117765: PUSH
117766: EMPTY
117767: LIST
117768: LIST
117769: PPUSH
117770: LD_VAR 0 1
117774: PPUSH
117775: CALL 24363 0 3
117779: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
117780: LD_ADDR_VAR 0 6
117784: PUSH
117785: LD_EXP 178
117789: PUSH
117790: LD_VAR 0 3
117794: ARRAY
117795: PPUSH
117796: LD_INT 25
117798: PUSH
117799: LD_INT 1
117801: PUSH
117802: EMPTY
117803: LIST
117804: LIST
117805: PUSH
117806: LD_INT 3
117808: PUSH
117809: LD_INT 54
117811: PUSH
117812: EMPTY
117813: LIST
117814: PUSH
117815: EMPTY
117816: LIST
117817: LIST
117818: PUSH
117819: EMPTY
117820: LIST
117821: LIST
117822: PPUSH
117823: CALL_OW 72
117827: ST_TO_ADDR
// if tmp then
117828: LD_VAR 0 6
117832: IFFALSE 117838
// exit ;
117834: POP
117835: POP
117836: GO 117978
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
117838: LD_ADDR_VAR 0 6
117842: PUSH
117843: LD_EXP 178
117847: PUSH
117848: LD_VAR 0 3
117852: ARRAY
117853: PPUSH
117854: LD_INT 2
117856: PUSH
117857: LD_INT 30
117859: PUSH
117860: LD_INT 4
117862: PUSH
117863: EMPTY
117864: LIST
117865: LIST
117866: PUSH
117867: LD_INT 30
117869: PUSH
117870: LD_INT 5
117872: PUSH
117873: EMPTY
117874: LIST
117875: LIST
117876: PUSH
117877: EMPTY
117878: LIST
117879: LIST
117880: LIST
117881: PPUSH
117882: CALL_OW 72
117886: ST_TO_ADDR
// if not tmp then
117887: LD_VAR 0 6
117891: NOT
117892: IFFALSE 117898
// exit ;
117894: POP
117895: POP
117896: GO 117978
// for j in tmp do
117898: LD_ADDR_VAR 0 4
117902: PUSH
117903: LD_VAR 0 6
117907: PUSH
117908: FOR_IN
117909: IFFALSE 117968
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
117911: LD_ADDR_VAR 0 7
117915: PUSH
117916: LD_VAR 0 4
117920: PPUSH
117921: CALL_OW 313
117925: PPUSH
117926: LD_INT 25
117928: PUSH
117929: LD_INT 1
117931: PUSH
117932: EMPTY
117933: LIST
117934: LIST
117935: PPUSH
117936: CALL_OW 72
117940: ST_TO_ADDR
// if units then
117941: LD_VAR 0 7
117945: IFFALSE 117966
// begin ComExitBuilding ( units [ 1 ] ) ;
117947: LD_VAR 0 7
117951: PUSH
117952: LD_INT 1
117954: ARRAY
117955: PPUSH
117956: CALL_OW 122
// exit ;
117960: POP
117961: POP
117962: POP
117963: POP
117964: GO 117978
// end ; end ;
117966: GO 117908
117968: POP
117969: POP
// end ; end ; exit ;
117970: POP
117971: POP
117972: GO 117978
// end ; end ;
117974: GO 117332
117976: POP
117977: POP
// end ;
117978: LD_VAR 0 2
117982: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
117983: LD_INT 0
117985: PPUSH
117986: PPUSH
117987: PPUSH
117988: PPUSH
117989: PPUSH
117990: PPUSH
117991: PPUSH
// if not mc_bases or not skirmish then
117992: LD_EXP 178
117996: NOT
117997: PUSH
117998: LD_EXP 176
118002: NOT
118003: OR
118004: IFFALSE 118008
// exit ;
118006: GO 118273
// btype := GetBType ( building ) ;
118008: LD_ADDR_VAR 0 6
118012: PUSH
118013: LD_VAR 0 1
118017: PPUSH
118018: CALL_OW 266
118022: ST_TO_ADDR
// x := GetX ( building ) ;
118023: LD_ADDR_VAR 0 7
118027: PUSH
118028: LD_VAR 0 1
118032: PPUSH
118033: CALL_OW 250
118037: ST_TO_ADDR
// y := GetY ( building ) ;
118038: LD_ADDR_VAR 0 8
118042: PUSH
118043: LD_VAR 0 1
118047: PPUSH
118048: CALL_OW 251
118052: ST_TO_ADDR
// d := GetDir ( building ) ;
118053: LD_ADDR_VAR 0 9
118057: PUSH
118058: LD_VAR 0 1
118062: PPUSH
118063: CALL_OW 254
118067: ST_TO_ADDR
// for i = 1 to mc_bases do
118068: LD_ADDR_VAR 0 4
118072: PUSH
118073: DOUBLE
118074: LD_INT 1
118076: DEC
118077: ST_TO_ADDR
118078: LD_EXP 178
118082: PUSH
118083: FOR_TO
118084: IFFALSE 118271
// begin if not mc_build_list [ i ] then
118086: LD_EXP 183
118090: PUSH
118091: LD_VAR 0 4
118095: ARRAY
118096: NOT
118097: IFFALSE 118101
// continue ;
118099: GO 118083
// for j := 1 to mc_build_list [ i ] do
118101: LD_ADDR_VAR 0 5
118105: PUSH
118106: DOUBLE
118107: LD_INT 1
118109: DEC
118110: ST_TO_ADDR
118111: LD_EXP 183
118115: PUSH
118116: LD_VAR 0 4
118120: ARRAY
118121: PUSH
118122: FOR_TO
118123: IFFALSE 118267
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ j ] ) then
118125: LD_VAR 0 6
118129: PUSH
118130: LD_VAR 0 7
118134: PUSH
118135: LD_VAR 0 8
118139: PUSH
118140: LD_VAR 0 9
118144: PUSH
118145: EMPTY
118146: LIST
118147: LIST
118148: LIST
118149: LIST
118150: PPUSH
118151: LD_EXP 183
118155: PUSH
118156: LD_VAR 0 4
118160: ARRAY
118161: PUSH
118162: LD_VAR 0 5
118166: ARRAY
118167: PPUSH
118168: CALL 30545 0 2
118172: IFFALSE 118265
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , j ) ) ;
118174: LD_ADDR_EXP 183
118178: PUSH
118179: LD_EXP 183
118183: PPUSH
118184: LD_VAR 0 4
118188: PPUSH
118189: LD_EXP 183
118193: PUSH
118194: LD_VAR 0 4
118198: ARRAY
118199: PPUSH
118200: LD_VAR 0 5
118204: PPUSH
118205: CALL_OW 3
118209: PPUSH
118210: CALL_OW 1
118214: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
118215: LD_ADDR_EXP 185
118219: PUSH
118220: LD_EXP 185
118224: PPUSH
118225: LD_VAR 0 4
118229: PUSH
118230: LD_EXP 185
118234: PUSH
118235: LD_VAR 0 4
118239: ARRAY
118240: PUSH
118241: LD_INT 1
118243: PLUS
118244: PUSH
118245: EMPTY
118246: LIST
118247: LIST
118248: PPUSH
118249: LD_VAR 0 1
118253: PPUSH
118254: CALL 24363 0 3
118258: ST_TO_ADDR
// exit ;
118259: POP
118260: POP
118261: POP
118262: POP
118263: GO 118273
// end ;
118265: GO 118122
118267: POP
118268: POP
// end ;
118269: GO 118083
118271: POP
118272: POP
// end ;
118273: LD_VAR 0 3
118277: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
118278: LD_INT 0
118280: PPUSH
118281: PPUSH
118282: PPUSH
// if not mc_bases or not skirmish then
118283: LD_EXP 178
118287: NOT
118288: PUSH
118289: LD_EXP 176
118293: NOT
118294: OR
118295: IFFALSE 118299
// exit ;
118297: GO 118489
// for i = 1 to mc_bases do
118299: LD_ADDR_VAR 0 4
118303: PUSH
118304: DOUBLE
118305: LD_INT 1
118307: DEC
118308: ST_TO_ADDR
118309: LD_EXP 178
118313: PUSH
118314: FOR_TO
118315: IFFALSE 118402
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
118317: LD_VAR 0 1
118321: PUSH
118322: LD_EXP 186
118326: PUSH
118327: LD_VAR 0 4
118331: ARRAY
118332: IN
118333: PUSH
118334: LD_VAR 0 1
118338: PUSH
118339: LD_EXP 187
118343: PUSH
118344: LD_VAR 0 4
118348: ARRAY
118349: IN
118350: NOT
118351: AND
118352: IFFALSE 118400
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
118354: LD_ADDR_EXP 187
118358: PUSH
118359: LD_EXP 187
118363: PPUSH
118364: LD_VAR 0 4
118368: PUSH
118369: LD_EXP 187
118373: PUSH
118374: LD_VAR 0 4
118378: ARRAY
118379: PUSH
118380: LD_INT 1
118382: PLUS
118383: PUSH
118384: EMPTY
118385: LIST
118386: LIST
118387: PPUSH
118388: LD_VAR 0 1
118392: PPUSH
118393: CALL 24363 0 3
118397: ST_TO_ADDR
// break ;
118398: GO 118402
// end ; end ;
118400: GO 118314
118402: POP
118403: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
118404: LD_VAR 0 1
118408: PPUSH
118409: CALL_OW 257
118413: PUSH
118414: LD_EXP 204
118418: IN
118419: PUSH
118420: LD_VAR 0 1
118424: PPUSH
118425: CALL_OW 266
118429: PUSH
118430: LD_INT 5
118432: EQUAL
118433: AND
118434: PUSH
118435: LD_VAR 0 2
118439: PPUSH
118440: CALL_OW 110
118444: PUSH
118445: LD_INT 18
118447: NONEQUAL
118448: AND
118449: IFFALSE 118489
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
118451: LD_VAR 0 2
118455: PPUSH
118456: CALL_OW 257
118460: PUSH
118461: LD_INT 5
118463: PUSH
118464: LD_INT 8
118466: PUSH
118467: LD_INT 9
118469: PUSH
118470: EMPTY
118471: LIST
118472: LIST
118473: LIST
118474: IN
118475: IFFALSE 118489
// SetClass ( unit , 1 ) ;
118477: LD_VAR 0 2
118481: PPUSH
118482: LD_INT 1
118484: PPUSH
118485: CALL_OW 336
// end ;
118489: LD_VAR 0 3
118493: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
118494: LD_INT 0
118496: PPUSH
118497: PPUSH
// if not mc_bases or not skirmish then
118498: LD_EXP 178
118502: NOT
118503: PUSH
118504: LD_EXP 176
118508: NOT
118509: OR
118510: IFFALSE 118514
// exit ;
118512: GO 118630
// if GetLives ( abandoned_vehicle ) > 250 then
118514: LD_VAR 0 2
118518: PPUSH
118519: CALL_OW 256
118523: PUSH
118524: LD_INT 250
118526: GREATER
118527: IFFALSE 118531
// exit ;
118529: GO 118630
// for i = 1 to mc_bases do
118531: LD_ADDR_VAR 0 6
118535: PUSH
118536: DOUBLE
118537: LD_INT 1
118539: DEC
118540: ST_TO_ADDR
118541: LD_EXP 178
118545: PUSH
118546: FOR_TO
118547: IFFALSE 118628
// begin if driver in mc_bases [ i ] then
118549: LD_VAR 0 1
118553: PUSH
118554: LD_EXP 178
118558: PUSH
118559: LD_VAR 0 6
118563: ARRAY
118564: IN
118565: IFFALSE 118626
// begin ComMoveToNearbyEntrance ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
118567: LD_VAR 0 1
118571: PPUSH
118572: LD_EXP 178
118576: PUSH
118577: LD_VAR 0 6
118581: ARRAY
118582: PPUSH
118583: LD_INT 2
118585: PUSH
118586: LD_INT 30
118588: PUSH
118589: LD_INT 0
118591: PUSH
118592: EMPTY
118593: LIST
118594: LIST
118595: PUSH
118596: LD_INT 30
118598: PUSH
118599: LD_INT 1
118601: PUSH
118602: EMPTY
118603: LIST
118604: LIST
118605: PUSH
118606: EMPTY
118607: LIST
118608: LIST
118609: LIST
118610: PPUSH
118611: CALL_OW 72
118615: PUSH
118616: LD_INT 1
118618: ARRAY
118619: PPUSH
118620: CALL 57485 0 2
// break ;
118624: GO 118628
// end ; end ;
118626: GO 118546
118628: POP
118629: POP
// end ;
118630: LD_VAR 0 5
118634: RET
