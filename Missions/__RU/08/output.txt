// starting begin InitMission ;
   0: CALL 5 0 0
// end ;
   4: END
// export HeikeCaptured ; export coopWithGensher ; export HeikeStatus ; export Masha ; export dial_BuildDepotBlocker , dial_BuildArBarrackBlocker , dial_ArriveGensherUnitsBlocker ; export buildingsToBuild , techsToResearch , vehWeaponsToConstruct , availableWeapons , weaponsData , allBuildings ; export HeikeTargetX , HeikeTargetY , GensherTargetX , GensherTargetY ; export allowExitFromMap ; export acceptKurtOffert , askCommanders ; export KurtCanEscape , KurtStatus , KurtWaitingForFreeHeike , KurtWaitingForBuildBarrack ; export KurtAttack , americansAttack , forceStopKurtAttack ; export canSendHeike , canShootTrening ; export BurlakRespect ; export acceptLegionOffert , paidLegionOffert , legionOffertCountdown , legionOffertTime ; export firstMashaQuery , canChooseMashaVehicle ; export buildCompVehicle , buildArabBarrack , testedTeleport ; export lostUnits ; function InitMission ; begin
   5: LD_INT 0
   7: PPUSH
// ResetFog ;
   8: CALL_OW 335
// RandomizeAll ;
  12: CALL_OW 11
// InGameOn ;
  16: CALL_OW 8
// InitMapConfig ;
  20: CALL 358 0 0
// HeikeCaptured = LoadVariable ( 07_HeikeCaptured_1 , 0 ) ;
  24: LD_ADDR_EXP 1
  28: PUSH
  29: LD_STRING 07_HeikeCaptured_1
  31: PPUSH
  32: LD_INT 0
  34: PPUSH
  35: CALL_OW 30
  39: ST_TO_ADDR
// coopWithGensher = 0 ;
  40: LD_ADDR_EXP 2
  44: PUSH
  45: LD_INT 0
  47: ST_TO_ADDR
// HeikeStatus = 0 ;
  48: LD_ADDR_EXP 3
  52: PUSH
  53: LD_INT 0
  55: ST_TO_ADDR
// Masha = [ ] ;
  56: LD_ADDR_EXP 4
  60: PUSH
  61: EMPTY
  62: ST_TO_ADDR
// buildingsToBuild = [ ] ;
  63: LD_ADDR_EXP 8
  67: PUSH
  68: EMPTY
  69: ST_TO_ADDR
// techsToResearch = [ ] ;
  70: LD_ADDR_EXP 9
  74: PUSH
  75: EMPTY
  76: ST_TO_ADDR
// vehWeaponsToConstruct = [ ] ;
  77: LD_ADDR_EXP 10
  81: PUSH
  82: EMPTY
  83: ST_TO_ADDR
// availableWeapons = [ ] ;
  84: LD_ADDR_EXP 11
  88: PUSH
  89: EMPTY
  90: ST_TO_ADDR
// weaponsData = [ ] ;
  91: LD_ADDR_EXP 12
  95: PUSH
  96: EMPTY
  97: ST_TO_ADDR
// allBuildings = [ ] ;
  98: LD_ADDR_EXP 13
 102: PUSH
 103: EMPTY
 104: ST_TO_ADDR
// HeikeTargetX = 0 ;
 105: LD_ADDR_EXP 14
 109: PUSH
 110: LD_INT 0
 112: ST_TO_ADDR
// HeikeTargetY = 0 ;
 113: LD_ADDR_EXP 15
 117: PUSH
 118: LD_INT 0
 120: ST_TO_ADDR
// GensherTargetX = 0 ;
 121: LD_ADDR_EXP 16
 125: PUSH
 126: LD_INT 0
 128: ST_TO_ADDR
// GensherTargetY = 0 ;
 129: LD_ADDR_EXP 17
 133: PUSH
 134: LD_INT 0
 136: ST_TO_ADDR
// allowExitFromMap = 0 ;
 137: LD_ADDR_EXP 18
 141: PUSH
 142: LD_INT 0
 144: ST_TO_ADDR
// acceptKurtOffert = 0 ;
 145: LD_ADDR_EXP 19
 149: PUSH
 150: LD_INT 0
 152: ST_TO_ADDR
// askCommanders = 0 ;
 153: LD_ADDR_EXP 20
 157: PUSH
 158: LD_INT 0
 160: ST_TO_ADDR
// KurtCanEscape = true ;
 161: LD_ADDR_EXP 21
 165: PUSH
 166: LD_INT 1
 168: ST_TO_ADDR
// KurtAttack = false ;
 169: LD_ADDR_EXP 25
 173: PUSH
 174: LD_INT 0
 176: ST_TO_ADDR
// KurtWaitingForFreeHeike = false ;
 177: LD_ADDR_EXP 23
 181: PUSH
 182: LD_INT 0
 184: ST_TO_ADDR
// KurtWaitingForBuildBarrack = false ;
 185: LD_ADDR_EXP 24
 189: PUSH
 190: LD_INT 0
 192: ST_TO_ADDR
// KurtStatus = 0 ;
 193: LD_ADDR_EXP 22
 197: PUSH
 198: LD_INT 0
 200: ST_TO_ADDR
// americansAttack = false ;
 201: LD_ADDR_EXP 26
 205: PUSH
 206: LD_INT 0
 208: ST_TO_ADDR
// forceStopKurtAttack = false ;
 209: LD_ADDR_EXP 27
 213: PUSH
 214: LD_INT 0
 216: ST_TO_ADDR
// canSendHeike = false ;
 217: LD_ADDR_EXP 28
 221: PUSH
 222: LD_INT 0
 224: ST_TO_ADDR
// canShootTrening = false ;
 225: LD_ADDR_EXP 29
 229: PUSH
 230: LD_INT 0
 232: ST_TO_ADDR
// BurlakRespect = 0 ;
 233: LD_ADDR_EXP 30
 237: PUSH
 238: LD_INT 0
 240: ST_TO_ADDR
// acceptLegionOffert = false ;
 241: LD_ADDR_EXP 31
 245: PUSH
 246: LD_INT 0
 248: ST_TO_ADDR
// paidLegionOffert = false ;
 249: LD_ADDR_EXP 32
 253: PUSH
 254: LD_INT 0
 256: ST_TO_ADDR
// legionOffertCountdown = false ;
 257: LD_ADDR_EXP 33
 261: PUSH
 262: LD_INT 0
 264: ST_TO_ADDR
// legionOffertTime = 0 0$60 ;
 265: LD_ADDR_EXP 34
 269: PUSH
 270: LD_INT 2100
 272: ST_TO_ADDR
// canChooseMashaVehicle = false ;
 273: LD_ADDR_EXP 36
 277: PUSH
 278: LD_INT 0
 280: ST_TO_ADDR
// firstMashaQuery = true ;
 281: LD_ADDR_EXP 35
 285: PUSH
 286: LD_INT 1
 288: ST_TO_ADDR
// buildArabBarrack = false ;
 289: LD_ADDR_EXP 38
 293: PUSH
 294: LD_INT 0
 296: ST_TO_ADDR
// buildCompVehicle = false ;
 297: LD_ADDR_EXP 37
 301: PUSH
 302: LD_INT 0
 304: ST_TO_ADDR
// testedTeleport = false ;
 305: LD_ADDR_EXP 39
 309: PUSH
 310: LD_INT 0
 312: ST_TO_ADDR
// lostUnits = 0 ;
 313: LD_ADDR_EXP 40
 317: PUSH
 318: LD_INT 0
 320: ST_TO_ADDR
// PrepareRussians ;
 321: CALL 1292 0 0
// PrepareArabians ;
 325: CALL 3847 0 0
// PrepareAmericans ;
 329: CALL 2975 0 0
// Nef_PrepareNature ;
 333: CALL 4831 0 0
// SpawnTrees ;
 337: CALL 5452 0 0
// MissionIntro ;
 341: CALL 9085 0 0
// end ;
 345: LD_VAR 0 1
 349: RET
// export function CustomInitMacro ; begin
 350: LD_INT 0
 352: PPUSH
// end ; end_of_file
 353: LD_VAR 0 1
 357: RET
// export function InitMapConfig ; begin
 358: LD_INT 0
 360: PPUSH
// BaseMapConfig ;
 361: CALL 374 0 0
// MissionMapConfig ;
 365: CALL 464 0 0
// end ;
 369: LD_VAR 0 1
 373: RET
// export animalsAmount , animalsStats , animalsAgression , missionPrefix , previousMissionPrefix , debugMode ; function BaseMapConfig ; begin
 374: LD_INT 0
 376: PPUSH
// animalsAmount = [ 6 , 3 , 4 , 4 , 1 ] ;
 377: LD_ADDR_EXP 41
 381: PUSH
 382: LD_INT 6
 384: PUSH
 385: LD_INT 3
 387: PUSH
 388: LD_INT 4
 390: PUSH
 391: LD_INT 4
 393: PUSH
 394: LD_INT 1
 396: PUSH
 397: EMPTY
 398: LIST
 399: LIST
 400: LIST
 401: LIST
 402: LIST
 403: ST_TO_ADDR
// animalsStats = [ 2 , 2 , 2 , 2 ] ;
 404: LD_ADDR_EXP 42
 408: PUSH
 409: LD_INT 2
 411: PUSH
 412: LD_INT 2
 414: PUSH
 415: LD_INT 2
 417: PUSH
 418: LD_INT 2
 420: PUSH
 421: EMPTY
 422: LIST
 423: LIST
 424: LIST
 425: LIST
 426: ST_TO_ADDR
// animalsAgression = 3 ;
 427: LD_ADDR_EXP 43
 431: PUSH
 432: LD_INT 3
 434: ST_TO_ADDR
// debugMode = 0 ;
 435: LD_ADDR_EXP 46
 439: PUSH
 440: LD_INT 0
 442: ST_TO_ADDR
// missionPrefix = 08_ ;
 443: LD_ADDR_EXP 44
 447: PUSH
 448: LD_STRING 08_
 450: ST_TO_ADDR
// previousMissionPrefix = 07_ ;
 451: LD_ADDR_EXP 45
 455: PUSH
 456: LD_STRING 07_
 458: ST_TO_ADDR
// end ;
 459: LD_VAR 0 1
 463: RET
// export KurtAttackWaves , americansAttackWaves ; export firstAttackDelay ; export waveCooldown ; export legionReduceAmericansUnits ; export speedMedalTime ; export enemyAttackUnitsData ; export timeToFreeHeike , timeToBuildArBarrack ; export enemySkillLevel ; function MissionMapConfig ; begin
 464: LD_INT 0
 466: PPUSH
// KurtAttackWaves = [ 3 , 4 , 5 , 6 ] [ Difficulty ] ;
 467: LD_ADDR_EXP 47
 471: PUSH
 472: LD_INT 3
 474: PUSH
 475: LD_INT 4
 477: PUSH
 478: LD_INT 5
 480: PUSH
 481: LD_INT 6
 483: PUSH
 484: EMPTY
 485: LIST
 486: LIST
 487: LIST
 488: LIST
 489: PUSH
 490: LD_OWVAR 67
 494: ARRAY
 495: ST_TO_ADDR
// americansAttackWaves = [ 1 , 2 , 3 , 4 ] [ Difficulty ] ;
 496: LD_ADDR_EXP 48
 500: PUSH
 501: LD_INT 1
 503: PUSH
 504: LD_INT 2
 506: PUSH
 507: LD_INT 3
 509: PUSH
 510: LD_INT 4
 512: PUSH
 513: EMPTY
 514: LIST
 515: LIST
 516: LIST
 517: LIST
 518: PUSH
 519: LD_OWVAR 67
 523: ARRAY
 524: ST_TO_ADDR
// enemySkillLevel = [ 3 , 4 , 5 , 6 ] [ Difficulty ] ;
 525: LD_ADDR_EXP 56
 529: PUSH
 530: LD_INT 3
 532: PUSH
 533: LD_INT 4
 535: PUSH
 536: LD_INT 5
 538: PUSH
 539: LD_INT 6
 541: PUSH
 542: EMPTY
 543: LIST
 544: LIST
 545: LIST
 546: LIST
 547: PUSH
 548: LD_OWVAR 67
 552: ARRAY
 553: ST_TO_ADDR
// waveCooldown = 1 1$30 ;
 554: LD_ADDR_EXP 50
 558: PUSH
 559: LD_INT 3150
 561: ST_TO_ADDR
// firstAttackDelay = 1 1$00 ;
 562: LD_ADDR_EXP 49
 566: PUSH
 567: LD_INT 2100
 569: ST_TO_ADDR
// timeToFreeHeike = 2 2$00 ;
 570: LD_ADDR_EXP 54
 574: PUSH
 575: LD_INT 4200
 577: ST_TO_ADDR
// timeToBuildArBarrack = 5 5$00 ;
 578: LD_ADDR_EXP 55
 582: PUSH
 583: LD_INT 10500
 585: ST_TO_ADDR
// legionReduceAmericansUnits = [ 5 , 5 , 6 , 6 ] [ Difficulty ] ;
 586: LD_ADDR_EXP 51
 590: PUSH
 591: LD_INT 5
 593: PUSH
 594: LD_INT 5
 596: PUSH
 597: LD_INT 6
 599: PUSH
 600: LD_INT 6
 602: PUSH
 603: EMPTY
 604: LIST
 605: LIST
 606: LIST
 607: LIST
 608: PUSH
 609: LD_OWVAR 67
 613: ARRAY
 614: ST_TO_ADDR
// speedMedalTime = [ 80 80$0 , 70 70$0 , 60 60$0 , 50 50$0 ] [ Difficulty ] ;
 615: LD_ADDR_EXP 52
 619: PUSH
 620: LD_INT 168000
 622: PUSH
 623: LD_INT 147000
 625: PUSH
 626: LD_INT 126000
 628: PUSH
 629: LD_INT 105000
 631: PUSH
 632: EMPTY
 633: LIST
 634: LIST
 635: LIST
 636: LIST
 637: PUSH
 638: LD_OWVAR 67
 642: ARRAY
 643: ST_TO_ADDR
// enemyAttackUnitsData = [ [ 1 , [ 4 , 5 , 6 , 6 ] [ Difficulty ] , [ 7 , 8 , 9 , 9 ] [ Difficulty ] , [ 1 , 2 , 2 , 3 ] [ Difficulty ] , [ 3 , 3 , 4 , 4 ] [ Difficulty ] , [ 6 , 7 , 8 , 8 ] [ Difficulty ] , [ 10 , 12 , 15 , 15 ] [ Difficulty ] ] , [ 8 , [ 2 , 3 , 4 , 4 ] [ Difficulty ] , [ 6 , 6 , 7 , 7 ] [ Difficulty ] , [ 0 , 1 , 1 , 2 ] [ Difficulty ] , [ 1 , 2 , 3 , 3 ] [ Difficulty ] , [ 1 , 2 , 2 , 2 ] [ Difficulty ] , [ 2 , 3 , 5 , 5 ] [ Difficulty ] ] ] ;
 644: LD_ADDR_EXP 53
 648: PUSH
 649: LD_INT 1
 651: PUSH
 652: LD_INT 4
 654: PUSH
 655: LD_INT 5
 657: PUSH
 658: LD_INT 6
 660: PUSH
 661: LD_INT 6
 663: PUSH
 664: EMPTY
 665: LIST
 666: LIST
 667: LIST
 668: LIST
 669: PUSH
 670: LD_OWVAR 67
 674: ARRAY
 675: PUSH
 676: LD_INT 7
 678: PUSH
 679: LD_INT 8
 681: PUSH
 682: LD_INT 9
 684: PUSH
 685: LD_INT 9
 687: PUSH
 688: EMPTY
 689: LIST
 690: LIST
 691: LIST
 692: LIST
 693: PUSH
 694: LD_OWVAR 67
 698: ARRAY
 699: PUSH
 700: LD_INT 1
 702: PUSH
 703: LD_INT 2
 705: PUSH
 706: LD_INT 2
 708: PUSH
 709: LD_INT 3
 711: PUSH
 712: EMPTY
 713: LIST
 714: LIST
 715: LIST
 716: LIST
 717: PUSH
 718: LD_OWVAR 67
 722: ARRAY
 723: PUSH
 724: LD_INT 3
 726: PUSH
 727: LD_INT 3
 729: PUSH
 730: LD_INT 4
 732: PUSH
 733: LD_INT 4
 735: PUSH
 736: EMPTY
 737: LIST
 738: LIST
 739: LIST
 740: LIST
 741: PUSH
 742: LD_OWVAR 67
 746: ARRAY
 747: PUSH
 748: LD_INT 6
 750: PUSH
 751: LD_INT 7
 753: PUSH
 754: LD_INT 8
 756: PUSH
 757: LD_INT 8
 759: PUSH
 760: EMPTY
 761: LIST
 762: LIST
 763: LIST
 764: LIST
 765: PUSH
 766: LD_OWVAR 67
 770: ARRAY
 771: PUSH
 772: LD_INT 10
 774: PUSH
 775: LD_INT 12
 777: PUSH
 778: LD_INT 15
 780: PUSH
 781: LD_INT 15
 783: PUSH
 784: EMPTY
 785: LIST
 786: LIST
 787: LIST
 788: LIST
 789: PUSH
 790: LD_OWVAR 67
 794: ARRAY
 795: PUSH
 796: EMPTY
 797: LIST
 798: LIST
 799: LIST
 800: LIST
 801: LIST
 802: LIST
 803: LIST
 804: PUSH
 805: LD_INT 8
 807: PUSH
 808: LD_INT 2
 810: PUSH
 811: LD_INT 3
 813: PUSH
 814: LD_INT 4
 816: PUSH
 817: LD_INT 4
 819: PUSH
 820: EMPTY
 821: LIST
 822: LIST
 823: LIST
 824: LIST
 825: PUSH
 826: LD_OWVAR 67
 830: ARRAY
 831: PUSH
 832: LD_INT 6
 834: PUSH
 835: LD_INT 6
 837: PUSH
 838: LD_INT 7
 840: PUSH
 841: LD_INT 7
 843: PUSH
 844: EMPTY
 845: LIST
 846: LIST
 847: LIST
 848: LIST
 849: PUSH
 850: LD_OWVAR 67
 854: ARRAY
 855: PUSH
 856: LD_INT 0
 858: PUSH
 859: LD_INT 1
 861: PUSH
 862: LD_INT 1
 864: PUSH
 865: LD_INT 2
 867: PUSH
 868: EMPTY
 869: LIST
 870: LIST
 871: LIST
 872: LIST
 873: PUSH
 874: LD_OWVAR 67
 878: ARRAY
 879: PUSH
 880: LD_INT 1
 882: PUSH
 883: LD_INT 2
 885: PUSH
 886: LD_INT 3
 888: PUSH
 889: LD_INT 3
 891: PUSH
 892: EMPTY
 893: LIST
 894: LIST
 895: LIST
 896: LIST
 897: PUSH
 898: LD_OWVAR 67
 902: ARRAY
 903: PUSH
 904: LD_INT 1
 906: PUSH
 907: LD_INT 2
 909: PUSH
 910: LD_INT 2
 912: PUSH
 913: LD_INT 2
 915: PUSH
 916: EMPTY
 917: LIST
 918: LIST
 919: LIST
 920: LIST
 921: PUSH
 922: LD_OWVAR 67
 926: ARRAY
 927: PUSH
 928: LD_INT 2
 930: PUSH
 931: LD_INT 3
 933: PUSH
 934: LD_INT 5
 936: PUSH
 937: LD_INT 5
 939: PUSH
 940: EMPTY
 941: LIST
 942: LIST
 943: LIST
 944: LIST
 945: PUSH
 946: LD_OWVAR 67
 950: ARRAY
 951: PUSH
 952: EMPTY
 953: LIST
 954: LIST
 955: LIST
 956: LIST
 957: LIST
 958: LIST
 959: LIST
 960: PUSH
 961: EMPTY
 962: LIST
 963: LIST
 964: ST_TO_ADDR
// end ;
 965: LD_VAR 0 1
 969: RET
// every 0 0$1 trigger debugMode do var i ;
 970: LD_EXP 46
 974: IFFALSE 1289
 976: GO 978
 978: DISABLE
 979: LD_INT 0
 981: PPUSH
// begin enable ;
 982: ENABLE
// FogOff ( your_side ) ;
 983: LD_OWVAR 2
 987: PPUSH
 988: CALL_OW 344
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) do
 992: LD_ADDR_VAR 0 1
 996: PUSH
 997: LD_INT 22
 999: PUSH
1000: LD_OWVAR 2
1004: PUSH
1005: EMPTY
1006: LIST
1007: LIST
1008: PUSH
1009: LD_INT 2
1011: PUSH
1012: LD_INT 21
1014: PUSH
1015: LD_INT 1
1017: PUSH
1018: EMPTY
1019: LIST
1020: LIST
1021: PUSH
1022: LD_INT 21
1024: PUSH
1025: LD_INT 2
1027: PUSH
1028: EMPTY
1029: LIST
1030: LIST
1031: PUSH
1032: EMPTY
1033: LIST
1034: LIST
1035: LIST
1036: PUSH
1037: EMPTY
1038: LIST
1039: LIST
1040: PPUSH
1041: CALL_OW 69
1045: PUSH
1046: FOR_IN
1047: IFFALSE 1063
// SetLives ( i , 1000 ) ;
1049: LD_VAR 0 1
1053: PPUSH
1054: LD_INT 1000
1056: PPUSH
1057: CALL_OW 234
1061: GO 1046
1063: POP
1064: POP
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) do
1065: LD_ADDR_VAR 0 1
1069: PUSH
1070: LD_INT 22
1072: PUSH
1073: LD_OWVAR 2
1077: PUSH
1078: EMPTY
1079: LIST
1080: LIST
1081: PUSH
1082: LD_INT 21
1084: PUSH
1085: LD_INT 1
1087: PUSH
1088: EMPTY
1089: LIST
1090: LIST
1091: PUSH
1092: EMPTY
1093: LIST
1094: LIST
1095: PPUSH
1096: CALL_OW 69
1100: PUSH
1101: FOR_IN
1102: IFFALSE 1166
// begin SetSkill ( i , skill_combat , 10 ) ;
1104: LD_VAR 0 1
1108: PPUSH
1109: LD_INT 1
1111: PPUSH
1112: LD_INT 10
1114: PPUSH
1115: CALL_OW 237
// SetSkill ( i , skill_engineering , 10 ) ;
1119: LD_VAR 0 1
1123: PPUSH
1124: LD_INT 2
1126: PPUSH
1127: LD_INT 10
1129: PPUSH
1130: CALL_OW 237
// SetSkill ( i , skill_mechanical , 10 ) ;
1134: LD_VAR 0 1
1138: PPUSH
1139: LD_INT 3
1141: PPUSH
1142: LD_INT 10
1144: PPUSH
1145: CALL_OW 237
// SetSkill ( i , skill_scientistic , 10 ) ;
1149: LD_VAR 0 1
1153: PPUSH
1154: LD_INT 4
1156: PPUSH
1157: LD_INT 10
1159: PPUSH
1160: CALL_OW 237
// end ;
1164: GO 1101
1166: POP
1167: POP
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) do
1168: LD_ADDR_VAR 0 1
1172: PUSH
1173: LD_INT 22
1175: PUSH
1176: LD_OWVAR 2
1180: PUSH
1181: EMPTY
1182: LIST
1183: LIST
1184: PUSH
1185: LD_INT 2
1187: PUSH
1188: LD_INT 30
1190: PUSH
1191: LD_INT 0
1193: PUSH
1194: EMPTY
1195: LIST
1196: LIST
1197: PUSH
1198: LD_INT 30
1200: PUSH
1201: LD_INT 1
1203: PUSH
1204: EMPTY
1205: LIST
1206: LIST
1207: PUSH
1208: EMPTY
1209: LIST
1210: LIST
1211: LIST
1212: PUSH
1213: EMPTY
1214: LIST
1215: LIST
1216: PPUSH
1217: CALL_OW 69
1221: PUSH
1222: FOR_IN
1223: IFFALSE 1287
// begin SetResourceType ( GetBase ( i ) , mat_cans , 9999 ) ;
1225: LD_VAR 0 1
1229: PPUSH
1230: CALL_OW 274
1234: PPUSH
1235: LD_INT 1
1237: PPUSH
1238: LD_INT 9999
1240: PPUSH
1241: CALL_OW 277
// SetResourceType ( GetBase ( i ) , mat_oil , 9999 ) ;
1245: LD_VAR 0 1
1249: PPUSH
1250: CALL_OW 274
1254: PPUSH
1255: LD_INT 2
1257: PPUSH
1258: LD_INT 9999
1260: PPUSH
1261: CALL_OW 277
// SetResourceType ( GetBase ( i ) , mat_siberit , 9999 ) ;
1265: LD_VAR 0 1
1269: PPUSH
1270: CALL_OW 274
1274: PPUSH
1275: LD_INT 3
1277: PPUSH
1278: LD_INT 9999
1280: PPUSH
1281: CALL_OW 277
// end ;
1285: GO 1222
1287: POP
1288: POP
// end ; end_of_file
1289: PPOPN 1
1291: END
// export Burlak , Karamazov , Petrovova , Gleb , Petrosyan , Titov , Dolgov , Lipshchin , Kirilenkova , Belkov , Belkov2 , Xavier ; export Gnyevko , Kovalyuk , Scholtze , Kuzmov ; export Kozlov , Oblukov , Kapitsova ; export Popov ; export russianEscort ; export function PrepareRussians ; begin
1292: LD_INT 0
1294: PPUSH
// russianEscort = [ ] ;
1295: LD_ADDR_EXP 77
1299: PUSH
1300: EMPTY
1301: ST_TO_ADDR
// Masha = [ ] ;
1302: LD_ADDR_EXP 4
1306: PUSH
1307: EMPTY
1308: ST_TO_ADDR
// PrepareHeroes ;
1309: CALL 1322 0 0
// InitRussianRequiments ;
1313: CALL 2717 0 0
// end ;
1317: LD_VAR 0 1
1321: RET
// function PrepareHeroes ; var i , un , other_survivors , yourUnits , emptyVeh ; begin
1322: LD_INT 0
1324: PPUSH
1325: PPUSH
1326: PPUSH
1327: PPUSH
1328: PPUSH
1329: PPUSH
// uc_side = 3 ;
1330: LD_ADDR_OWVAR 20
1334: PUSH
1335: LD_INT 3
1337: ST_TO_ADDR
// uc_nation = 3 ;
1338: LD_ADDR_OWVAR 21
1342: PUSH
1343: LD_INT 3
1345: ST_TO_ADDR
// Burlak := PrepareUnitExt ( Burlak , true , class_mechanic ) ;
1346: LD_ADDR_EXP 57
1350: PUSH
1351: LD_STRING Burlak
1353: PPUSH
1354: LD_INT 1
1356: PPUSH
1357: LD_INT 3
1359: PPUSH
1360: CALL 5930 0 3
1364: ST_TO_ADDR
// Titov := PrepareUnitExt ( Titov , true , class_soldier ) ;
1365: LD_ADDR_EXP 62
1369: PUSH
1370: LD_STRING Titov
1372: PPUSH
1373: LD_INT 1
1375: PPUSH
1376: LD_INT 1
1378: PPUSH
1379: CALL 5930 0 3
1383: ST_TO_ADDR
// Dolgov := PrepareUnitExt ( Dolgov , true , class_scientistic ) ;
1384: LD_ADDR_EXP 63
1388: PUSH
1389: LD_STRING Dolgov
1391: PPUSH
1392: LD_INT 1
1394: PPUSH
1395: LD_INT 4
1397: PPUSH
1398: CALL 5930 0 3
1402: ST_TO_ADDR
// Lipshchin := PrepareUnitExt ( Lipshchin , true , class_soldier ) ;
1403: LD_ADDR_EXP 64
1407: PUSH
1408: LD_STRING Lipshchin
1410: PPUSH
1411: LD_INT 1
1413: PPUSH
1414: LD_INT 1
1416: PPUSH
1417: CALL 5930 0 3
1421: ST_TO_ADDR
// Karamazov := PrepareUnitExt ( Karamazov , true , class_engineer ) ;
1422: LD_ADDR_EXP 58
1426: PUSH
1427: LD_STRING Karamazov
1429: PPUSH
1430: LD_INT 1
1432: PPUSH
1433: LD_INT 2
1435: PPUSH
1436: CALL 5930 0 3
1440: ST_TO_ADDR
// Petrovova := PrepareUnitExt ( Petrovova , true , class_soldier ) ;
1441: LD_ADDR_EXP 59
1445: PUSH
1446: LD_STRING Petrovova
1448: PPUSH
1449: LD_INT 1
1451: PPUSH
1452: LD_INT 1
1454: PPUSH
1455: CALL 5930 0 3
1459: ST_TO_ADDR
// Gleb := PrepareUnitExt ( Gleb , true , class_soldier ) ;
1460: LD_ADDR_EXP 60
1464: PUSH
1465: LD_STRING Gleb
1467: PPUSH
1468: LD_INT 1
1470: PPUSH
1471: LD_INT 1
1473: PPUSH
1474: CALL 5930 0 3
1478: ST_TO_ADDR
// Petrosyan := PrepareUnitExt ( Petrosyan , true , class_scientistic ) ;
1479: LD_ADDR_EXP 61
1483: PUSH
1484: LD_STRING Petrosyan
1486: PPUSH
1487: LD_INT 1
1489: PPUSH
1490: LD_INT 4
1492: PPUSH
1493: CALL 5930 0 3
1497: ST_TO_ADDR
// Kirilenkova := PrepareUnitExt ( Kirilenkova , true , class_scientistic ) ;
1498: LD_ADDR_EXP 65
1502: PUSH
1503: LD_STRING Kirilenkova
1505: PPUSH
1506: LD_INT 1
1508: PPUSH
1509: LD_INT 4
1511: PPUSH
1512: CALL 5930 0 3
1516: ST_TO_ADDR
// Belkov := PrepareUnitExt ( Belkov , true , class_soldier ) ;
1517: LD_ADDR_EXP 66
1521: PUSH
1522: LD_STRING Belkov
1524: PPUSH
1525: LD_INT 1
1527: PPUSH
1528: LD_INT 1
1530: PPUSH
1531: CALL 5930 0 3
1535: ST_TO_ADDR
// Belkov2 := PrepareUnitExt ( Belkov2 , true , class_soldier ) ;
1536: LD_ADDR_EXP 67
1540: PUSH
1541: LD_STRING Belkov2
1543: PPUSH
1544: LD_INT 1
1546: PPUSH
1547: LD_INT 1
1549: PPUSH
1550: CALL 5930 0 3
1554: ST_TO_ADDR
// Xavier := PrepareUnitExt ( Xavier , true , class_soldier ) ;
1555: LD_ADDR_EXP 68
1559: PUSH
1560: LD_STRING Xavier
1562: PPUSH
1563: LD_INT 1
1565: PPUSH
1566: LD_INT 1
1568: PPUSH
1569: CALL 5930 0 3
1573: ST_TO_ADDR
// Gnyevko := CreateCharacter ( 04_Gnyevko ) ;
1574: LD_ADDR_EXP 69
1578: PUSH
1579: LD_STRING 04_Gnyevko
1581: PPUSH
1582: CALL_OW 34
1586: ST_TO_ADDR
// SetClass ( Gnyevko , class_soldier ) ;
1587: LD_EXP 69
1591: PPUSH
1592: LD_INT 1
1594: PPUSH
1595: CALL_OW 336
// Kovalyuk := CreateCharacter ( 04_Kovalyuk ) ;
1599: LD_ADDR_EXP 70
1603: PUSH
1604: LD_STRING 04_Kovalyuk
1606: PPUSH
1607: CALL_OW 34
1611: ST_TO_ADDR
// SetClass ( Kovalyuk , class_mechanic ) ;
1612: LD_EXP 70
1616: PPUSH
1617: LD_INT 3
1619: PPUSH
1620: CALL_OW 336
// Scholtze := CreateCharacter ( 04_Scholtze ) ;
1624: LD_ADDR_EXP 71
1628: PUSH
1629: LD_STRING 04_Scholtze
1631: PPUSH
1632: CALL_OW 34
1636: ST_TO_ADDR
// SetClass ( Scholtze , class_scientistic ) ;
1637: LD_EXP 71
1641: PPUSH
1642: LD_INT 4
1644: PPUSH
1645: CALL_OW 336
// Kuzmov := CreateCharacter ( 04_Kuzmov ) ;
1649: LD_ADDR_EXP 72
1653: PUSH
1654: LD_STRING 04_Kuzmov
1656: PPUSH
1657: CALL_OW 34
1661: ST_TO_ADDR
// SetClass ( Kuzmov , class_soldier ) ;
1662: LD_EXP 72
1666: PPUSH
1667: LD_INT 1
1669: PPUSH
1670: CALL_OW 336
// Kozlov := PrepareUnitExt ( Kozlov , false , class_engineer ) ;
1674: LD_ADDR_EXP 73
1678: PUSH
1679: LD_STRING Kozlov
1681: PPUSH
1682: LD_INT 0
1684: PPUSH
1685: LD_INT 2
1687: PPUSH
1688: CALL 5930 0 3
1692: ST_TO_ADDR
// Oblukov := PrepareUnitExt ( Oblukov , false , class_soldier ) ;
1693: LD_ADDR_EXP 74
1697: PUSH
1698: LD_STRING Oblukov
1700: PPUSH
1701: LD_INT 0
1703: PPUSH
1704: LD_INT 1
1706: PPUSH
1707: CALL 5930 0 3
1711: ST_TO_ADDR
// Kapitsova := PrepareUnitExt ( Kapitsova , false , class_scientistic ) ;
1712: LD_ADDR_EXP 75
1716: PUSH
1717: LD_STRING Kapitsova
1719: PPUSH
1720: LD_INT 0
1722: PPUSH
1723: LD_INT 4
1725: PPUSH
1726: CALL 5930 0 3
1730: ST_TO_ADDR
// Popov := PrepareUnitExt ( Popov , false , 0 ) ;
1731: LD_ADDR_EXP 76
1735: PUSH
1736: LD_STRING Popov
1738: PPUSH
1739: LD_INT 0
1741: PPUSH
1742: LD_INT 0
1744: PPUSH
1745: CALL 5930 0 3
1749: ST_TO_ADDR
// PlaceUnitsArea ( [ Burlak , Karamazov , Petrovova , Gleb , Petrosyan , Titov , Dolgov , Lipshchin , Kirilenkova , Belkov , Belkov2 , Xavier , Gnyevko , Kovalyuk , Scholtze , Kuzmov , Kozlov , Oblukov , Kapitsova ] , RussianSpawnArea , false ) ;
1750: LD_EXP 57
1754: PUSH
1755: LD_EXP 58
1759: PUSH
1760: LD_EXP 59
1764: PUSH
1765: LD_EXP 60
1769: PUSH
1770: LD_EXP 61
1774: PUSH
1775: LD_EXP 62
1779: PUSH
1780: LD_EXP 63
1784: PUSH
1785: LD_EXP 64
1789: PUSH
1790: LD_EXP 65
1794: PUSH
1795: LD_EXP 66
1799: PUSH
1800: LD_EXP 67
1804: PUSH
1805: LD_EXP 68
1809: PUSH
1810: LD_EXP 69
1814: PUSH
1815: LD_EXP 70
1819: PUSH
1820: LD_EXP 71
1824: PUSH
1825: LD_EXP 72
1829: PUSH
1830: LD_EXP 73
1834: PUSH
1835: LD_EXP 74
1839: PUSH
1840: LD_EXP 75
1844: PUSH
1845: EMPTY
1846: LIST
1847: LIST
1848: LIST
1849: LIST
1850: LIST
1851: LIST
1852: LIST
1853: LIST
1854: LIST
1855: LIST
1856: LIST
1857: LIST
1858: LIST
1859: LIST
1860: LIST
1861: LIST
1862: LIST
1863: LIST
1864: LIST
1865: PPUSH
1866: LD_INT 2
1868: PPUSH
1869: LD_INT 0
1871: PPUSH
1872: CALL 6204 0 3
// PrepareVehicles ;
1876: CALL 2417 0 0
// other_survivors = CreateCharacterSet ( 07_other_survivors ) ;
1880: LD_ADDR_VAR 0 4
1884: PUSH
1885: LD_STRING 07_other_survivors
1887: PPUSH
1888: CALL_OW 31
1892: ST_TO_ADDR
// other_survivors = other_survivors ^ CreateCharacterSet ( 04_other_survivors ) ;
1893: LD_ADDR_VAR 0 4
1897: PUSH
1898: LD_VAR 0 4
1902: PUSH
1903: LD_STRING 04_other_survivors
1905: PPUSH
1906: CALL_OW 31
1910: ADD
1911: ST_TO_ADDR
// other_survivors = other_survivors ^ CreateCharacterSet ( 04_other_survivors_with_popov ) ;
1912: LD_ADDR_VAR 0 4
1916: PUSH
1917: LD_VAR 0 4
1921: PUSH
1922: LD_STRING 04_other_survivors_with_popov
1924: PPUSH
1925: CALL_OW 31
1929: ADD
1930: ST_TO_ADDR
// for un in other_survivors do
1931: LD_ADDR_VAR 0 3
1935: PUSH
1936: LD_VAR 0 4
1940: PUSH
1941: FOR_IN
1942: IFFALSE 2028
// begin emptyVeh = FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_vehicle ] , [ f_empty ] ] ) ;
1944: LD_ADDR_VAR 0 6
1948: PUSH
1949: LD_INT 22
1951: PUSH
1952: LD_INT 3
1954: PUSH
1955: EMPTY
1956: LIST
1957: LIST
1958: PUSH
1959: LD_INT 21
1961: PUSH
1962: LD_INT 2
1964: PUSH
1965: EMPTY
1966: LIST
1967: LIST
1968: PUSH
1969: LD_INT 58
1971: PUSH
1972: EMPTY
1973: LIST
1974: PUSH
1975: EMPTY
1976: LIST
1977: LIST
1978: LIST
1979: PPUSH
1980: CALL_OW 69
1984: ST_TO_ADDR
// if emptyVeh then
1985: LD_VAR 0 6
1989: IFFALSE 2011
// PlaceHumanInUnit ( un , emptyVeh [ 1 ] ) else
1991: LD_VAR 0 3
1995: PPUSH
1996: LD_VAR 0 6
2000: PUSH
2001: LD_INT 1
2003: ARRAY
2004: PPUSH
2005: CALL_OW 52
2009: GO 2026
// PlaceUnitArea ( un , RussianSpawnArea , false ) ;
2011: LD_VAR 0 3
2015: PPUSH
2016: LD_INT 2
2018: PPUSH
2019: LD_INT 0
2021: PPUSH
2022: CALL_OW 49
// end ;
2026: GO 1941
2028: POP
2029: POP
// yourUnits = FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_nation , nation_russian ] ] ) ;
2030: LD_ADDR_VAR 0 5
2034: PUSH
2035: LD_INT 22
2037: PUSH
2038: LD_INT 3
2040: PUSH
2041: EMPTY
2042: LIST
2043: LIST
2044: PUSH
2045: LD_INT 21
2047: PUSH
2048: LD_INT 1
2050: PUSH
2051: EMPTY
2052: LIST
2053: LIST
2054: PUSH
2055: LD_INT 23
2057: PUSH
2058: LD_INT 3
2060: PUSH
2061: EMPTY
2062: LIST
2063: LIST
2064: PUSH
2065: EMPTY
2066: LIST
2067: LIST
2068: LIST
2069: PPUSH
2070: CALL_OW 69
2074: ST_TO_ADDR
// if yourUnits < 15 then
2075: LD_VAR 0 5
2079: PUSH
2080: LD_INT 15
2082: LESS
2083: IFFALSE 2232
// for i := 1 to 15 - yourUnits do
2085: LD_ADDR_VAR 0 2
2089: PUSH
2090: DOUBLE
2091: LD_INT 1
2093: DEC
2094: ST_TO_ADDR
2095: LD_INT 15
2097: PUSH
2098: LD_VAR 0 5
2102: MINUS
2103: PUSH
2104: FOR_TO
2105: IFFALSE 2230
// begin PrepareHuman ( false , rand ( 1 , 4 ) , rand ( 2 , 4 ) ) ;
2107: LD_INT 0
2109: PPUSH
2110: LD_INT 1
2112: PPUSH
2113: LD_INT 4
2115: PPUSH
2116: CALL_OW 12
2120: PPUSH
2121: LD_INT 2
2123: PPUSH
2124: LD_INT 4
2126: PPUSH
2127: CALL_OW 12
2131: PPUSH
2132: CALL_OW 380
// un = CreateHuman ;
2136: LD_ADDR_VAR 0 3
2140: PUSH
2141: CALL_OW 44
2145: ST_TO_ADDR
// emptyVeh = FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_vehicle ] , [ f_empty ] ] ) ;
2146: LD_ADDR_VAR 0 6
2150: PUSH
2151: LD_INT 22
2153: PUSH
2154: LD_INT 3
2156: PUSH
2157: EMPTY
2158: LIST
2159: LIST
2160: PUSH
2161: LD_INT 21
2163: PUSH
2164: LD_INT 2
2166: PUSH
2167: EMPTY
2168: LIST
2169: LIST
2170: PUSH
2171: LD_INT 58
2173: PUSH
2174: EMPTY
2175: LIST
2176: PUSH
2177: EMPTY
2178: LIST
2179: LIST
2180: LIST
2181: PPUSH
2182: CALL_OW 69
2186: ST_TO_ADDR
// if emptyVeh then
2187: LD_VAR 0 6
2191: IFFALSE 2213
// PlaceHumanInUnit ( un , emptyVeh [ 1 ] ) else
2193: LD_VAR 0 3
2197: PPUSH
2198: LD_VAR 0 6
2202: PUSH
2203: LD_INT 1
2205: ARRAY
2206: PPUSH
2207: CALL_OW 52
2211: GO 2228
// PlaceUnitArea ( un , RussianSpawnArea , false ) ;
2213: LD_VAR 0 3
2217: PPUSH
2218: LD_INT 2
2220: PPUSH
2221: LD_INT 0
2223: PPUSH
2224: CALL_OW 49
// end ;
2228: GO 2104
2230: POP
2231: POP
// yourUnits = FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_nation , nation_russian ] ] ) ;
2232: LD_ADDR_VAR 0 5
2236: PUSH
2237: LD_INT 22
2239: PUSH
2240: LD_INT 3
2242: PUSH
2243: EMPTY
2244: LIST
2245: LIST
2246: PUSH
2247: LD_INT 21
2249: PUSH
2250: LD_INT 1
2252: PUSH
2253: EMPTY
2254: LIST
2255: LIST
2256: PUSH
2257: LD_INT 23
2259: PUSH
2260: LD_INT 3
2262: PUSH
2263: EMPTY
2264: LIST
2265: LIST
2266: PUSH
2267: EMPTY
2268: LIST
2269: LIST
2270: LIST
2271: PPUSH
2272: CALL_OW 69
2276: ST_TO_ADDR
// if not UnitFilter ( yourUnits , [ f_class , class_engineer ] ) then
2277: LD_VAR 0 5
2281: PPUSH
2282: LD_INT 25
2284: PUSH
2285: LD_INT 2
2287: PUSH
2288: EMPTY
2289: LIST
2290: LIST
2291: PPUSH
2292: CALL_OW 72
2296: NOT
2297: IFFALSE 2315
// SetClass ( yourUnits [ 1 ] , 2 ) ;
2299: LD_VAR 0 5
2303: PUSH
2304: LD_INT 1
2306: ARRAY
2307: PPUSH
2308: LD_INT 2
2310: PPUSH
2311: CALL_OW 336
// end ;
2315: LD_VAR 0 1
2319: RET
// export function PrepareRussianEscort ; var i , unit ; begin
2320: LD_INT 0
2322: PPUSH
2323: PPUSH
2324: PPUSH
// uc_side = 6 ;
2325: LD_ADDR_OWVAR 20
2329: PUSH
2330: LD_INT 6
2332: ST_TO_ADDR
// uc_nation = 3 ;
2333: LD_ADDR_OWVAR 21
2337: PUSH
2338: LD_INT 3
2340: ST_TO_ADDR
// for i := 1 to 2 do
2341: LD_ADDR_VAR 0 2
2345: PUSH
2346: DOUBLE
2347: LD_INT 1
2349: DEC
2350: ST_TO_ADDR
2351: LD_INT 2
2353: PUSH
2354: FOR_TO
2355: IFFALSE 2410
// begin PrepareSoldier ( false , 4 ) ;
2357: LD_INT 0
2359: PPUSH
2360: LD_INT 4
2362: PPUSH
2363: CALL_OW 381
// unit = CreateHuman ;
2367: LD_ADDR_VAR 0 3
2371: PUSH
2372: CALL_OW 44
2376: ST_TO_ADDR
// russianEscort = russianEscort ^ unit ;
2377: LD_ADDR_EXP 77
2381: PUSH
2382: LD_EXP 77
2386: PUSH
2387: LD_VAR 0 3
2391: ADD
2392: ST_TO_ADDR
// PlaceUnitArea ( unit , RussianSpawn2Area , false ) ;
2393: LD_VAR 0 3
2397: PPUSH
2398: LD_INT 7
2400: PPUSH
2401: LD_INT 0
2403: PPUSH
2404: CALL_OW 49
// end ;
2408: GO 2354
2410: POP
2411: POP
// end ;
2412: LD_VAR 0 1
2416: RET
// function PrepareVehicles ; var i , veh ; begin
2417: LD_INT 0
2419: PPUSH
2420: PPUSH
2421: PPUSH
// uc_side = 3 ;
2422: LD_ADDR_OWVAR 20
2426: PUSH
2427: LD_INT 3
2429: ST_TO_ADDR
// uc_nation = 3 ;
2430: LD_ADDR_OWVAR 21
2434: PUSH
2435: LD_INT 3
2437: ST_TO_ADDR
// for i := 1 to 5 do
2438: LD_ADDR_VAR 0 2
2442: PUSH
2443: DOUBLE
2444: LD_INT 1
2446: DEC
2447: ST_TO_ADDR
2448: LD_INT 5
2450: PUSH
2451: FOR_TO
2452: IFFALSE 2562
// begin PrepareVehicle ( ru_medium_wheeled , engine_combustion , control_manual , ru_cargo_bay , rand ( 60 , 80 ) ) ;
2454: LD_INT 21
2456: PPUSH
2457: LD_INT 1
2459: PPUSH
2460: LD_INT 1
2462: PPUSH
2463: LD_INT 51
2465: PPUSH
2466: LD_INT 60
2468: PPUSH
2469: LD_INT 80
2471: PPUSH
2472: CALL_OW 12
2476: PPUSH
2477: CALL 24064 0 5
// veh = CreateVehicle ;
2481: LD_ADDR_VAR 0 3
2485: PUSH
2486: CALL_OW 45
2490: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
2491: LD_VAR 0 3
2495: PPUSH
2496: LD_INT 4
2498: PPUSH
2499: CALL_OW 233
// PlaceUnitArea ( veh , RussianSpawnArea , false ) ;
2503: LD_VAR 0 3
2507: PPUSH
2508: LD_INT 2
2510: PPUSH
2511: LD_INT 0
2513: PPUSH
2514: CALL_OW 49
// if ( i <> 5 ) then
2518: LD_VAR 0 2
2522: PUSH
2523: LD_INT 5
2525: NONEQUAL
2526: IFFALSE 2545
// AddCargo ( veh , mat_cans , 100 ) else
2528: LD_VAR 0 3
2532: PPUSH
2533: LD_INT 1
2535: PPUSH
2536: LD_INT 100
2538: PPUSH
2539: CALL_OW 291
2543: GO 2560
// AddCargo ( veh , mat_oil , 100 ) ;
2545: LD_VAR 0 3
2549: PPUSH
2550: LD_INT 2
2552: PPUSH
2553: LD_INT 100
2555: PPUSH
2556: CALL_OW 291
// end ;
2560: GO 2451
2562: POP
2563: POP
// PrepareVehicle ( ru_medium_wheeled , engine_combustion , control_manual , ru_crane , rand ( 60 , 80 ) ) ;
2564: LD_INT 21
2566: PPUSH
2567: LD_INT 1
2569: PPUSH
2570: LD_INT 1
2572: PPUSH
2573: LD_INT 52
2575: PPUSH
2576: LD_INT 60
2578: PPUSH
2579: LD_INT 80
2581: PPUSH
2582: CALL_OW 12
2586: PPUSH
2587: CALL 24064 0 5
// veh = CreateVehicle ;
2591: LD_ADDR_VAR 0 3
2595: PUSH
2596: CALL_OW 45
2600: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
2601: LD_VAR 0 3
2605: PPUSH
2606: LD_INT 4
2608: PPUSH
2609: CALL_OW 233
// PlaceUnitArea ( veh , RussianSpawnArea , false ) ;
2613: LD_VAR 0 3
2617: PPUSH
2618: LD_INT 2
2620: PPUSH
2621: LD_INT 0
2623: PPUSH
2624: CALL_OW 49
// for i := 1 to 3 do
2628: LD_ADDR_VAR 0 2
2632: PUSH
2633: DOUBLE
2634: LD_INT 1
2636: DEC
2637: ST_TO_ADDR
2638: LD_INT 3
2640: PUSH
2641: FOR_TO
2642: IFFALSE 2710
// begin PrepareVehicle ( ru_heavy_tracked , engine_combustion , control_manual , ru_bulldozer , rand ( 60 , 80 ) ) ;
2644: LD_INT 24
2646: PPUSH
2647: LD_INT 1
2649: PPUSH
2650: LD_INT 1
2652: PPUSH
2653: LD_INT 53
2655: PPUSH
2656: LD_INT 60
2658: PPUSH
2659: LD_INT 80
2661: PPUSH
2662: CALL_OW 12
2666: PPUSH
2667: CALL 24064 0 5
// veh = CreateVehicle ;
2671: LD_ADDR_VAR 0 3
2675: PUSH
2676: CALL_OW 45
2680: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
2681: LD_VAR 0 3
2685: PPUSH
2686: LD_INT 4
2688: PPUSH
2689: CALL_OW 233
// PlaceUnitArea ( veh , RussianSpawnArea , false ) ;
2693: LD_VAR 0 3
2697: PPUSH
2698: LD_INT 2
2700: PPUSH
2701: LD_INT 0
2703: PPUSH
2704: CALL_OW 49
// end ;
2708: GO 2641
2710: POP
2711: POP
// end ;
2712: LD_VAR 0 1
2716: RET
// function InitRussianRequiments ; var i ; begin
2717: LD_INT 0
2719: PPUSH
2720: PPUSH
// availableWeapons = [ ru_heavy_machine_gun , ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher ] ;
2721: LD_ADDR_EXP 11
2725: PUSH
2726: LD_INT 42
2728: PUSH
2729: LD_INT 43
2731: PUSH
2732: LD_INT 44
2734: PUSH
2735: LD_INT 46
2737: PUSH
2738: LD_INT 45
2740: PUSH
2741: EMPTY
2742: LIST
2743: LIST
2744: LIST
2745: LIST
2746: LIST
2747: ST_TO_ADDR
// for i := 1 to availableWeapons do
2748: LD_ADDR_VAR 0 2
2752: PUSH
2753: DOUBLE
2754: LD_INT 1
2756: DEC
2757: ST_TO_ADDR
2758: LD_EXP 11
2762: PUSH
2763: FOR_TO
2764: IFFALSE 2804
// weaponsData = weaponsData ^ [ [ availableWeapons [ i ] , false , false ] ] ;
2766: LD_ADDR_EXP 12
2770: PUSH
2771: LD_EXP 12
2775: PUSH
2776: LD_EXP 11
2780: PUSH
2781: LD_VAR 0 2
2785: ARRAY
2786: PUSH
2787: LD_INT 0
2789: PUSH
2790: LD_INT 0
2792: PUSH
2793: EMPTY
2794: LIST
2795: LIST
2796: LIST
2797: PUSH
2798: EMPTY
2799: LIST
2800: ADD
2801: ST_TO_ADDR
2802: GO 2763
2804: POP
2805: POP
// for i := 0 to 50 do
2806: LD_ADDR_VAR 0 2
2810: PUSH
2811: DOUBLE
2812: LD_INT 0
2814: DEC
2815: ST_TO_ADDR
2816: LD_INT 50
2818: PUSH
2819: FOR_TO
2820: IFFALSE 2858
// if GetRestrict ( i , 3 ) = state_enabled then
2822: LD_VAR 0 2
2826: PPUSH
2827: LD_INT 3
2829: PPUSH
2830: CALL_OW 323
2834: PUSH
2835: LD_INT 1
2837: EQUAL
2838: IFFALSE 2856
// buildingsToBuild = buildingsToBuild ^ i ;
2840: LD_ADDR_EXP 8
2844: PUSH
2845: LD_EXP 8
2849: PUSH
2850: LD_VAR 0 2
2854: ADD
2855: ST_TO_ADDR
2856: GO 2819
2858: POP
2859: POP
// buildingsToBuild = buildingsToBuild diff [ 0 , 2 , 4 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 14 , 22 , 31 , 32 , 33 , 39 , 40 ] ;
2860: LD_ADDR_EXP 8
2864: PUSH
2865: LD_EXP 8
2869: PUSH
2870: LD_INT 0
2872: PUSH
2873: LD_INT 2
2875: PUSH
2876: LD_INT 4
2878: PUSH
2879: LD_INT 6
2881: PUSH
2882: LD_INT 7
2884: PUSH
2885: LD_INT 8
2887: PUSH
2888: LD_INT 9
2890: PUSH
2891: LD_INT 10
2893: PUSH
2894: LD_INT 11
2896: PUSH
2897: LD_INT 12
2899: PUSH
2900: LD_INT 14
2902: PUSH
2903: LD_INT 22
2905: PUSH
2906: LD_INT 31
2908: PUSH
2909: LD_INT 32
2911: PUSH
2912: LD_INT 33
2914: PUSH
2915: LD_INT 39
2917: PUSH
2918: LD_INT 40
2920: PUSH
2921: EMPTY
2922: LIST
2923: LIST
2924: LIST
2925: LIST
2926: LIST
2927: LIST
2928: LIST
2929: LIST
2930: LIST
2931: LIST
2932: LIST
2933: LIST
2934: LIST
2935: LIST
2936: LIST
2937: LIST
2938: LIST
2939: DIFF
2940: ST_TO_ADDR
// allBuildings = buildingsToBuild ;
2941: LD_ADDR_EXP 13
2945: PUSH
2946: LD_EXP 8
2950: ST_TO_ADDR
// techsToResearch = GetTechNation ( 3 , nation_russian , state_enabled ) ;
2951: LD_ADDR_EXP 9
2955: PUSH
2956: LD_INT 3
2958: PPUSH
2959: LD_INT 3
2961: PPUSH
2962: LD_INT 1
2964: PPUSH
2965: CALL 19287 0 3
2969: ST_TO_ADDR
// end ; end_of_file
2970: LD_VAR 0 1
2974: RET
// export amAttackTeam ; export function PrepareAmericans ; begin
2975: LD_INT 0
2977: PPUSH
// amAttackTeam = [ ] ;
2978: LD_ADDR_EXP 78
2982: PUSH
2983: EMPTY
2984: ST_TO_ADDR
// SpawnAmericansSnipers ;
2985: CALL 3119 0 0
// case Difficulty of 2 :
2989: LD_OWVAR 67
2993: PUSH
2994: LD_INT 2
2996: DOUBLE
2997: EQUAL
2998: IFTRUE 3002
3000: GO 3031
3002: POP
// begin SetTech ( tech_comp1 , 1 , state_researched ) ;
3003: LD_INT 57
3005: PPUSH
3006: LD_INT 1
3008: PPUSH
3009: LD_INT 2
3011: PPUSH
3012: CALL_OW 322
// SetTech ( tech_opto1 , 1 , state_researched ) ;
3016: LD_INT 60
3018: PPUSH
3019: LD_INT 1
3021: PPUSH
3022: LD_INT 2
3024: PPUSH
3025: CALL_OW 322
// end ; 3 .. 4 :
3029: GO 3114
3031: LD_INT 3
3033: DOUBLE
3034: GREATEREQUAL
3035: IFFALSE 3043
3037: LD_INT 4
3039: DOUBLE
3040: LESSEQUAL
3041: IFTRUE 3045
3043: GO 3113
3045: POP
// begin SetTech ( tech_comp1 , 1 , state_researched ) ;
3046: LD_INT 57
3048: PPUSH
3049: LD_INT 1
3051: PPUSH
3052: LD_INT 2
3054: PPUSH
3055: CALL_OW 322
// SetTech ( tech_comp2 , 1 , state_researched ) ;
3059: LD_INT 58
3061: PPUSH
3062: LD_INT 1
3064: PPUSH
3065: LD_INT 2
3067: PPUSH
3068: CALL_OW 322
// SetTech ( tech_weap3 , 1 , state_researched ) ;
3072: LD_INT 53
3074: PPUSH
3075: LD_INT 1
3077: PPUSH
3078: LD_INT 2
3080: PPUSH
3081: CALL_OW 322
// SetTech ( tech_opto1 , 1 , state_researched ) ;
3085: LD_INT 60
3087: PPUSH
3088: LD_INT 1
3090: PPUSH
3091: LD_INT 2
3093: PPUSH
3094: CALL_OW 322
// SetTech ( tech_opto2 , 1 , state_researched ) ;
3098: LD_INT 61
3100: PPUSH
3101: LD_INT 1
3103: PPUSH
3104: LD_INT 2
3106: PPUSH
3107: CALL_OW 322
// end ; end ;
3111: GO 3114
3113: POP
// end ;
3114: LD_VAR 0 1
3118: RET
// export function SpawnAmericansSnipers ; var i , un ; begin
3119: LD_INT 0
3121: PPUSH
3122: PPUSH
3123: PPUSH
// uc_side = 1 ;
3124: LD_ADDR_OWVAR 20
3128: PUSH
3129: LD_INT 1
3131: ST_TO_ADDR
// uc_nation = 1 ;
3132: LD_ADDR_OWVAR 21
3136: PUSH
3137: LD_INT 1
3139: ST_TO_ADDR
// for i := 1 to 8 do
3140: LD_ADDR_VAR 0 2
3144: PUSH
3145: DOUBLE
3146: LD_INT 1
3148: DEC
3149: ST_TO_ADDR
3150: LD_INT 8
3152: PUSH
3153: FOR_TO
3154: IFFALSE 3207
// begin PrepareHuman ( false , class_sniper , enemySkillLevel ) ;
3156: LD_INT 0
3158: PPUSH
3159: LD_INT 5
3161: PPUSH
3162: LD_EXP 56
3166: PPUSH
3167: CALL_OW 380
// un = CreateHuman ;
3171: LD_ADDR_VAR 0 3
3175: PUSH
3176: CALL_OW 44
3180: ST_TO_ADDR
// PlaceUnitArea ( un , AmericansSnipersSpawnArea , false ) ;
3181: LD_VAR 0 3
3185: PPUSH
3186: LD_INT 14
3188: PPUSH
3189: LD_INT 0
3191: PPUSH
3192: CALL_OW 49
// ComHold ( un ) ;
3196: LD_VAR 0 3
3200: PPUSH
3201: CALL_OW 140
// end ;
3205: GO 3153
3207: POP
3208: POP
// end ;
3209: LD_VAR 0 1
3213: RET
// export function SpawnAmAttackTeam ; var i , unit , veh , randVehType , weapon , chassis , amSolds , amSnipers , amVehs ; begin
3214: LD_INT 0
3216: PPUSH
3217: PPUSH
3218: PPUSH
3219: PPUSH
3220: PPUSH
3221: PPUSH
3222: PPUSH
3223: PPUSH
3224: PPUSH
3225: PPUSH
// uc_side = 1 ;
3226: LD_ADDR_OWVAR 20
3230: PUSH
3231: LD_INT 1
3233: ST_TO_ADDR
// uc_nation = 1 ;
3234: LD_ADDR_OWVAR 21
3238: PUSH
3239: LD_INT 1
3241: ST_TO_ADDR
// amSolds = Rand ( enemyAttackUnitsData [ 1 ] [ 2 ] , enemyAttackUnitsData [ 1 ] [ 3 ] ) ;
3242: LD_ADDR_VAR 0 8
3246: PUSH
3247: LD_EXP 53
3251: PUSH
3252: LD_INT 1
3254: ARRAY
3255: PUSH
3256: LD_INT 2
3258: ARRAY
3259: PPUSH
3260: LD_EXP 53
3264: PUSH
3265: LD_INT 1
3267: ARRAY
3268: PUSH
3269: LD_INT 3
3271: ARRAY
3272: PPUSH
3273: CALL_OW 12
3277: ST_TO_ADDR
// amSnipers = Rand ( enemyAttackUnitsData [ 1 ] [ 4 ] , enemyAttackUnitsData [ 1 ] [ 5 ] ) ;
3278: LD_ADDR_VAR 0 9
3282: PUSH
3283: LD_EXP 53
3287: PUSH
3288: LD_INT 1
3290: ARRAY
3291: PUSH
3292: LD_INT 4
3294: ARRAY
3295: PPUSH
3296: LD_EXP 53
3300: PUSH
3301: LD_INT 1
3303: ARRAY
3304: PUSH
3305: LD_INT 5
3307: ARRAY
3308: PPUSH
3309: CALL_OW 12
3313: ST_TO_ADDR
// amVehs = Rand ( enemyAttackUnitsData [ 1 ] [ 6 ] , enemyAttackUnitsData [ 1 ] [ 7 ] ) ;
3314: LD_ADDR_VAR 0 10
3318: PUSH
3319: LD_EXP 53
3323: PUSH
3324: LD_INT 1
3326: ARRAY
3327: PUSH
3328: LD_INT 6
3330: ARRAY
3331: PPUSH
3332: LD_EXP 53
3336: PUSH
3337: LD_INT 1
3339: ARRAY
3340: PUSH
3341: LD_INT 7
3343: ARRAY
3344: PPUSH
3345: CALL_OW 12
3349: ST_TO_ADDR
// if paidLegionOffert then
3350: LD_EXP 32
3354: IFFALSE 3388
// begin amSolds = amSolds - legionReduceAmericansUnits ;
3356: LD_ADDR_VAR 0 8
3360: PUSH
3361: LD_VAR 0 8
3365: PUSH
3366: LD_EXP 51
3370: MINUS
3371: ST_TO_ADDR
// amVehs = amVehs - legionReduceAmericansUnits ;
3372: LD_ADDR_VAR 0 10
3376: PUSH
3377: LD_VAR 0 10
3381: PUSH
3382: LD_EXP 51
3386: MINUS
3387: ST_TO_ADDR
// end ; for i := 1 to amSolds do
3388: LD_ADDR_VAR 0 2
3392: PUSH
3393: DOUBLE
3394: LD_INT 1
3396: DEC
3397: ST_TO_ADDR
3398: LD_VAR 0 8
3402: PUSH
3403: FOR_TO
3404: IFFALSE 3461
// begin PrepareSoldier ( false , enemySkillLevel ) ;
3406: LD_INT 0
3408: PPUSH
3409: LD_EXP 56
3413: PPUSH
3414: CALL_OW 381
// unit = CreateHuman ;
3418: LD_ADDR_VAR 0 3
3422: PUSH
3423: CALL_OW 44
3427: ST_TO_ADDR
// PlaceUnitArea ( unit , AmericanSpawnArea , false ) ;
3428: LD_VAR 0 3
3432: PPUSH
3433: LD_INT 3
3435: PPUSH
3436: LD_INT 0
3438: PPUSH
3439: CALL_OW 49
// amAttackTeam = amAttackTeam ^ unit ;
3443: LD_ADDR_EXP 78
3447: PUSH
3448: LD_EXP 78
3452: PUSH
3453: LD_VAR 0 3
3457: ADD
3458: ST_TO_ADDR
// end ;
3459: GO 3403
3461: POP
3462: POP
// for i := 1 to amSnipers do
3463: LD_ADDR_VAR 0 2
3467: PUSH
3468: DOUBLE
3469: LD_INT 1
3471: DEC
3472: ST_TO_ADDR
3473: LD_VAR 0 9
3477: PUSH
3478: FOR_TO
3479: IFFALSE 3539
// begin PrepareHuman ( false , class_sniper , enemySkillLevel ) ;
3481: LD_INT 0
3483: PPUSH
3484: LD_INT 5
3486: PPUSH
3487: LD_EXP 56
3491: PPUSH
3492: CALL_OW 380
// unit = CreateHuman ;
3496: LD_ADDR_VAR 0 3
3500: PUSH
3501: CALL_OW 44
3505: ST_TO_ADDR
// PlaceUnitArea ( unit , AmericanSpawnArea , false ) ;
3506: LD_VAR 0 3
3510: PPUSH
3511: LD_INT 3
3513: PPUSH
3514: LD_INT 0
3516: PPUSH
3517: CALL_OW 49
// amAttackTeam = amAttackTeam ^ unit ;
3521: LD_ADDR_EXP 78
3525: PUSH
3526: LD_EXP 78
3530: PUSH
3531: LD_VAR 0 3
3535: ADD
3536: ST_TO_ADDR
// end ;
3537: GO 3478
3539: POP
3540: POP
// for i := 1 to amVehs do
3541: LD_ADDR_VAR 0 2
3545: PUSH
3546: DOUBLE
3547: LD_INT 1
3549: DEC
3550: ST_TO_ADDR
3551: LD_VAR 0 10
3555: PUSH
3556: FOR_TO
3557: IFFALSE 3840
// begin randVehType = Rand ( 1 , 4 ) ;
3559: LD_ADDR_VAR 0 5
3563: PUSH
3564: LD_INT 1
3566: PPUSH
3567: LD_INT 4
3569: PPUSH
3570: CALL_OW 12
3574: ST_TO_ADDR
// weapon = [ us_gatling_gun , us_double_gun , us_light_gun , us_rocket_launcher , us_heavy_gun ] [ Rand ( 1 , 5 ) ] ;
3575: LD_ADDR_VAR 0 6
3579: PUSH
3580: LD_INT 4
3582: PUSH
3583: LD_INT 5
3585: PUSH
3586: LD_INT 3
3588: PUSH
3589: LD_INT 7
3591: PUSH
3592: LD_INT 6
3594: PUSH
3595: EMPTY
3596: LIST
3597: LIST
3598: LIST
3599: LIST
3600: LIST
3601: PUSH
3602: LD_INT 1
3604: PPUSH
3605: LD_INT 5
3607: PPUSH
3608: CALL_OW 12
3612: ARRAY
3613: ST_TO_ADDR
// if weapon = us_heavy_gun then
3614: LD_VAR 0 6
3618: PUSH
3619: LD_INT 6
3621: EQUAL
3622: IFFALSE 3634
// chassis = us_heavy_tracked else
3624: LD_ADDR_VAR 0 7
3628: PUSH
3629: LD_INT 4
3631: ST_TO_ADDR
3632: GO 3661
// chassis = [ us_medium_tracked , us_heavy_tracked ] [ Rand ( 1 , 2 ) ] ;
3634: LD_ADDR_VAR 0 7
3638: PUSH
3639: LD_INT 3
3641: PUSH
3642: LD_INT 4
3644: PUSH
3645: EMPTY
3646: LIST
3647: LIST
3648: PUSH
3649: LD_INT 1
3651: PPUSH
3652: LD_INT 2
3654: PPUSH
3655: CALL_OW 12
3659: ARRAY
3660: ST_TO_ADDR
// if randVehType = 1 then
3661: LD_VAR 0 5
3665: PUSH
3666: LD_INT 1
3668: EQUAL
3669: IFFALSE 3704
// PrepareVehicle ( chassis , engine_combustion , control_manual , weapon , Rand ( 70 , 90 ) ) else
3671: LD_VAR 0 7
3675: PPUSH
3676: LD_INT 1
3678: PPUSH
3679: LD_INT 1
3681: PPUSH
3682: LD_VAR 0 6
3686: PPUSH
3687: LD_INT 70
3689: PPUSH
3690: LD_INT 90
3692: PPUSH
3693: CALL_OW 12
3697: PPUSH
3698: CALL 24064 0 5
3702: GO 3735
// PrepareVehicle ( chassis , engine_combustion , control_computer , weapon , Rand ( 70 , 90 ) ) ;
3704: LD_VAR 0 7
3708: PPUSH
3709: LD_INT 1
3711: PPUSH
3712: LD_INT 3
3714: PPUSH
3715: LD_VAR 0 6
3719: PPUSH
3720: LD_INT 70
3722: PPUSH
3723: LD_INT 90
3725: PPUSH
3726: CALL_OW 12
3730: PPUSH
3731: CALL 24064 0 5
// veh = CreateVehicle ;
3735: LD_ADDR_VAR 0 4
3739: PUSH
3740: CALL_OW 45
3744: ST_TO_ADDR
// PlaceUnitArea ( veh , AmericanSpawnArea , false ) ;
3745: LD_VAR 0 4
3749: PPUSH
3750: LD_INT 3
3752: PPUSH
3753: LD_INT 0
3755: PPUSH
3756: CALL_OW 49
// amAttackTeam = amAttackTeam ^ veh ;
3760: LD_ADDR_EXP 78
3764: PUSH
3765: LD_EXP 78
3769: PUSH
3770: LD_VAR 0 4
3774: ADD
3775: ST_TO_ADDR
// if randVehType = 1 then
3776: LD_VAR 0 5
3780: PUSH
3781: LD_INT 1
3783: EQUAL
3784: IFFALSE 3838
// begin PrepareMechanic ( false , enemySkillLevel ) ;
3786: LD_INT 0
3788: PPUSH
3789: LD_EXP 56
3793: PPUSH
3794: CALL_OW 383
// unit = CreateHuman ;
3798: LD_ADDR_VAR 0 3
3802: PUSH
3803: CALL_OW 44
3807: ST_TO_ADDR
// PlaceHumanInUnit ( unit , veh ) ;
3808: LD_VAR 0 3
3812: PPUSH
3813: LD_VAR 0 4
3817: PPUSH
3818: CALL_OW 52
// amAttackTeam = amAttackTeam ^ unit ;
3822: LD_ADDR_EXP 78
3826: PUSH
3827: LD_EXP 78
3831: PUSH
3832: LD_VAR 0 3
3836: ADD
3837: ST_TO_ADDR
// end ; end ;
3838: GO 3556
3840: POP
3841: POP
// end ; end_of_file
3842: LD_VAR 0 1
3846: RET
// export Heike , Kurt , Dietrich ; export KurtEng ; export GensherTeam ; export arAttackTeam ; export function PrepareArabians ; begin
3847: LD_INT 0
3849: PPUSH
// arAttackTeam = [ ] ;
3850: LD_ADDR_EXP 84
3854: PUSH
3855: EMPTY
3856: ST_TO_ADDR
// PrepareHeroes ;
3857: CALL 4262 0 0
// case Difficulty of 2 :
3861: LD_OWVAR 67
3865: PUSH
3866: LD_INT 2
3868: DOUBLE
3869: EQUAL
3870: IFTRUE 3874
3872: GO 3890
3874: POP
// begin SetTech ( tech_stimDrugs , 8 , state_researched ) ;
3875: LD_INT 5
3877: PPUSH
3878: LD_INT 8
3880: PPUSH
3881: LD_INT 2
3883: PPUSH
3884: CALL_OW 322
// end ; 3 :
3888: GO 3941
3890: LD_INT 3
3892: DOUBLE
3893: EQUAL
3894: IFTRUE 3898
3896: GO 3940
3898: POP
// begin SetTech ( tech_stimDrugs , 8 , state_researched ) ;
3899: LD_INT 5
3901: PPUSH
3902: LD_INT 8
3904: PPUSH
3905: LD_INT 2
3907: PPUSH
3908: CALL_OW 322
// SetTech ( tech_bio1 , 8 , state_researched ) ;
3912: LD_INT 66
3914: PPUSH
3915: LD_INT 8
3917: PPUSH
3918: LD_INT 2
3920: PPUSH
3921: CALL_OW 322
// SetTech ( tech_weap3 , 8 , state_researched ) ;
3925: LD_INT 53
3927: PPUSH
3928: LD_INT 8
3930: PPUSH
3931: LD_INT 2
3933: PPUSH
3934: CALL_OW 322
// end ; end ;
3938: GO 3941
3940: POP
// end ;
3941: LD_VAR 0 1
3945: RET
// export function SpawnGensherTeam ; var i , driver , veh ; begin
3946: LD_INT 0
3948: PPUSH
3949: PPUSH
3950: PPUSH
3951: PPUSH
// GensherTeam = [ ] ;
3952: LD_ADDR_EXP 83
3956: PUSH
3957: EMPTY
3958: ST_TO_ADDR
// uc_side = 2 ;
3959: LD_ADDR_OWVAR 20
3963: PUSH
3964: LD_INT 2
3966: ST_TO_ADDR
// uc_nation = 2 ;
3967: LD_ADDR_OWVAR 21
3971: PUSH
3972: LD_INT 2
3974: ST_TO_ADDR
// for i := 1 to 3 do
3975: LD_ADDR_VAR 0 2
3979: PUSH
3980: DOUBLE
3981: LD_INT 1
3983: DEC
3984: ST_TO_ADDR
3985: LD_INT 3
3987: PUSH
3988: FOR_TO
3989: IFFALSE 4148
// begin PrepareSoldier ( sex_male , rand ( 3 , 5 ) ) ;
3991: LD_INT 1
3993: PPUSH
3994: LD_INT 3
3996: PPUSH
3997: LD_INT 5
3999: PPUSH
4000: CALL_OW 12
4004: PPUSH
4005: CALL_OW 381
// driver = CreateHuman ;
4009: LD_ADDR_VAR 0 3
4013: PUSH
4014: CALL_OW 44
4018: ST_TO_ADDR
// PrepareVehicle ( ar_medium_trike , engine_combustion , control_manual , ar_cargo_bay , rand ( 50 , 70 ) ) ;
4019: LD_INT 13
4021: PPUSH
4022: LD_INT 1
4024: PPUSH
4025: LD_INT 1
4027: PPUSH
4028: LD_INT 32
4030: PPUSH
4031: LD_INT 50
4033: PPUSH
4034: LD_INT 70
4036: PPUSH
4037: CALL_OW 12
4041: PPUSH
4042: CALL 24064 0 5
// veh = CreateVehicle ;
4046: LD_ADDR_VAR 0 4
4050: PUSH
4051: CALL_OW 45
4055: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
4056: LD_VAR 0 4
4060: PPUSH
4061: LD_INT 4
4063: PPUSH
4064: CALL_OW 233
// PlaceUnitArea ( veh , GensherSpawnArea , false ) ;
4068: LD_VAR 0 4
4072: PPUSH
4073: LD_INT 4
4075: PPUSH
4076: LD_INT 0
4078: PPUSH
4079: CALL_OW 49
// PlaceHumanInUnit ( driver , veh ) ;
4083: LD_VAR 0 3
4087: PPUSH
4088: LD_VAR 0 4
4092: PPUSH
4093: CALL_OW 52
// AddCargo ( veh , i , 100 ) ;
4097: LD_VAR 0 4
4101: PPUSH
4102: LD_VAR 0 2
4106: PPUSH
4107: LD_INT 100
4109: PPUSH
4110: CALL_OW 291
// GensherTeam = GensherTeam ^ driver ;
4114: LD_ADDR_EXP 83
4118: PUSH
4119: LD_EXP 83
4123: PUSH
4124: LD_VAR 0 3
4128: ADD
4129: ST_TO_ADDR
// GensherTeam = GensherTeam ^ veh ;
4130: LD_ADDR_EXP 83
4134: PUSH
4135: LD_EXP 83
4139: PUSH
4140: LD_VAR 0 4
4144: ADD
4145: ST_TO_ADDR
// end ;
4146: GO 3988
4148: POP
4149: POP
// if IsOK ( KurtEng ) and GetSide ( KurtEng ) = 3 then
4150: LD_EXP 82
4154: PPUSH
4155: CALL_OW 302
4159: PUSH
4160: LD_EXP 82
4164: PPUSH
4165: CALL_OW 255
4169: PUSH
4170: LD_INT 3
4172: EQUAL
4173: AND
4174: IFFALSE 4208
// begin GensherTargetX = GetX ( Kurt ) ;
4176: LD_ADDR_EXP 16
4180: PUSH
4181: LD_EXP 80
4185: PPUSH
4186: CALL_OW 250
4190: ST_TO_ADDR
// GensherTargetY = GetY ( Kurt ) ;
4191: LD_ADDR_EXP 17
4195: PUSH
4196: LD_EXP 80
4200: PPUSH
4201: CALL_OW 251
4205: ST_TO_ADDR
// end else
4206: GO 4238
// begin GensherTargetX = GetX ( Burlak ) ;
4208: LD_ADDR_EXP 16
4212: PUSH
4213: LD_EXP 57
4217: PPUSH
4218: CALL_OW 250
4222: ST_TO_ADDR
// GensherTargetY = GetY ( Burlak ) ;
4223: LD_ADDR_EXP 17
4227: PUSH
4228: LD_EXP 57
4232: PPUSH
4233: CALL_OW 251
4237: ST_TO_ADDR
// end ; ComMoveXY ( GensherTeam , GensherTargetX , GensherTargetY ) ;
4238: LD_EXP 83
4242: PPUSH
4243: LD_EXP 16
4247: PPUSH
4248: LD_EXP 17
4252: PPUSH
4253: CALL_OW 111
// end ;
4257: LD_VAR 0 1
4261: RET
// function PrepareHeroes ; begin
4262: LD_INT 0
4264: PPUSH
// uc_side = 5 ;
4265: LD_ADDR_OWVAR 20
4269: PUSH
4270: LD_INT 5
4272: ST_TO_ADDR
// uc_nation = 2 ;
4273: LD_ADDR_OWVAR 21
4277: PUSH
4278: LD_INT 2
4280: ST_TO_ADDR
// Heike = PrepareUnitExt ( Heike , true , class_engineer ) ;
4281: LD_ADDR_EXP 79
4285: PUSH
4286: LD_STRING Heike
4288: PPUSH
4289: LD_INT 1
4291: PPUSH
4292: LD_INT 2
4294: PPUSH
4295: CALL 5930 0 3
4299: ST_TO_ADDR
// uc_side = 8 ;
4300: LD_ADDR_OWVAR 20
4304: PUSH
4305: LD_INT 8
4307: ST_TO_ADDR
// Kurt = PrepareUnitExt ( Kurt , false , 0 ) ;
4308: LD_ADDR_EXP 80
4312: PUSH
4313: LD_STRING Kurt
4315: PPUSH
4316: LD_INT 0
4318: PPUSH
4319: LD_INT 0
4321: PPUSH
4322: CALL 5930 0 3
4326: ST_TO_ADDR
// uc_side = 2 ;
4327: LD_ADDR_OWVAR 20
4331: PUSH
4332: LD_INT 2
4334: ST_TO_ADDR
// Dietrich = PrepareUnitExt ( Dietrich , false , 0 ) ;
4335: LD_ADDR_EXP 81
4339: PUSH
4340: LD_STRING Dietrich
4342: PPUSH
4343: LD_INT 0
4345: PPUSH
4346: LD_INT 0
4348: PPUSH
4349: CALL 5930 0 3
4353: ST_TO_ADDR
// end ;
4354: LD_VAR 0 1
4358: RET
// export function SpawnArAttackTeam ; var i , unit , veh , weapon , chassis ; begin
4359: LD_INT 0
4361: PPUSH
4362: PPUSH
4363: PPUSH
4364: PPUSH
4365: PPUSH
4366: PPUSH
// uc_side = 8 ;
4367: LD_ADDR_OWVAR 20
4371: PUSH
4372: LD_INT 8
4374: ST_TO_ADDR
// uc_nation = 2 ;
4375: LD_ADDR_OWVAR 21
4379: PUSH
4380: LD_INT 2
4382: ST_TO_ADDR
// for i := 1 to Rand ( enemyAttackUnitsData [ 1 ] [ 2 ] , enemyAttackUnitsData [ 1 ] [ 3 ] ) do
4383: LD_ADDR_VAR 0 2
4387: PUSH
4388: DOUBLE
4389: LD_INT 1
4391: DEC
4392: ST_TO_ADDR
4393: LD_EXP 53
4397: PUSH
4398: LD_INT 1
4400: ARRAY
4401: PUSH
4402: LD_INT 2
4404: ARRAY
4405: PPUSH
4406: LD_EXP 53
4410: PUSH
4411: LD_INT 1
4413: ARRAY
4414: PUSH
4415: LD_INT 3
4417: ARRAY
4418: PPUSH
4419: CALL_OW 12
4423: PUSH
4424: FOR_TO
4425: IFFALSE 4482
// begin PrepareSoldier ( false , enemySkillLevel ) ;
4427: LD_INT 0
4429: PPUSH
4430: LD_EXP 56
4434: PPUSH
4435: CALL_OW 381
// unit = CreateHuman ;
4439: LD_ADDR_VAR 0 3
4443: PUSH
4444: CALL_OW 44
4448: ST_TO_ADDR
// PlaceUnitArea ( unit , KurtUnitsSpawnArea , false ) ;
4449: LD_VAR 0 3
4453: PPUSH
4454: LD_INT 10
4456: PPUSH
4457: LD_INT 0
4459: PPUSH
4460: CALL_OW 49
// arAttackTeam = arAttackTeam ^ unit ;
4464: LD_ADDR_EXP 84
4468: PUSH
4469: LD_EXP 84
4473: PUSH
4474: LD_VAR 0 3
4478: ADD
4479: ST_TO_ADDR
// end ;
4480: GO 4424
4482: POP
4483: POP
// for i := 1 to Rand ( enemyAttackUnitsData [ 1 ] [ 4 ] , enemyAttackUnitsData [ 1 ] [ 5 ] ) do
4484: LD_ADDR_VAR 0 2
4488: PUSH
4489: DOUBLE
4490: LD_INT 1
4492: DEC
4493: ST_TO_ADDR
4494: LD_EXP 53
4498: PUSH
4499: LD_INT 1
4501: ARRAY
4502: PUSH
4503: LD_INT 4
4505: ARRAY
4506: PPUSH
4507: LD_EXP 53
4511: PUSH
4512: LD_INT 1
4514: ARRAY
4515: PUSH
4516: LD_INT 5
4518: ARRAY
4519: PPUSH
4520: CALL_OW 12
4524: PUSH
4525: FOR_TO
4526: IFFALSE 4586
// begin PrepareHuman ( false , class_mortar , enemySkillLevel ) ;
4528: LD_INT 0
4530: PPUSH
4531: LD_INT 8
4533: PPUSH
4534: LD_EXP 56
4538: PPUSH
4539: CALL_OW 380
// unit = CreateHuman ;
4543: LD_ADDR_VAR 0 3
4547: PUSH
4548: CALL_OW 44
4552: ST_TO_ADDR
// PlaceUnitArea ( unit , KurtUnitsSpawnArea , false ) ;
4553: LD_VAR 0 3
4557: PPUSH
4558: LD_INT 10
4560: PPUSH
4561: LD_INT 0
4563: PPUSH
4564: CALL_OW 49
// arAttackTeam = arAttackTeam ^ unit ;
4568: LD_ADDR_EXP 84
4572: PUSH
4573: LD_EXP 84
4577: PUSH
4578: LD_VAR 0 3
4582: ADD
4583: ST_TO_ADDR
// end ;
4584: GO 4525
4586: POP
4587: POP
// for i := 1 to Rand ( enemyAttackUnitsData [ 1 ] [ 6 ] , enemyAttackUnitsData [ 1 ] [ 7 ] ) do
4588: LD_ADDR_VAR 0 2
4592: PUSH
4593: DOUBLE
4594: LD_INT 1
4596: DEC
4597: ST_TO_ADDR
4598: LD_EXP 53
4602: PUSH
4603: LD_INT 1
4605: ARRAY
4606: PUSH
4607: LD_INT 6
4609: ARRAY
4610: PPUSH
4611: LD_EXP 53
4615: PUSH
4616: LD_INT 1
4618: ARRAY
4619: PUSH
4620: LD_INT 7
4622: ARRAY
4623: PPUSH
4624: CALL_OW 12
4628: PUSH
4629: FOR_TO
4630: IFFALSE 4824
// begin weapon = [ ar_gun , ar_flame_thrower , ar_rocket_launcher , ar_light_gun , ar_gatling_gun ] [ Rand ( 1 , 5 ) ] ;
4632: LD_ADDR_VAR 0 5
4636: PUSH
4637: LD_INT 27
4639: PUSH
4640: LD_INT 26
4642: PUSH
4643: LD_INT 28
4645: PUSH
4646: LD_INT 23
4648: PUSH
4649: LD_INT 25
4651: PUSH
4652: EMPTY
4653: LIST
4654: LIST
4655: LIST
4656: LIST
4657: LIST
4658: PUSH
4659: LD_INT 1
4661: PPUSH
4662: LD_INT 5
4664: PPUSH
4665: CALL_OW 12
4669: ARRAY
4670: ST_TO_ADDR
// chassis = [ ar_medium_trike , ar_half_tracked ] [ Rand ( 1 , 2 ) ] ;
4671: LD_ADDR_VAR 0 6
4675: PUSH
4676: LD_INT 13
4678: PUSH
4679: LD_INT 14
4681: PUSH
4682: EMPTY
4683: LIST
4684: LIST
4685: PUSH
4686: LD_INT 1
4688: PPUSH
4689: LD_INT 2
4691: PPUSH
4692: CALL_OW 12
4696: ARRAY
4697: ST_TO_ADDR
// PrepareVehicle ( chassis , engine_combustion , control_manual , weapon , Rand ( 70 , 90 ) ) ;
4698: LD_VAR 0 6
4702: PPUSH
4703: LD_INT 1
4705: PPUSH
4706: LD_INT 1
4708: PPUSH
4709: LD_VAR 0 5
4713: PPUSH
4714: LD_INT 70
4716: PPUSH
4717: LD_INT 90
4719: PPUSH
4720: CALL_OW 12
4724: PPUSH
4725: CALL 24064 0 5
// veh = CreateVehicle ;
4729: LD_ADDR_VAR 0 4
4733: PUSH
4734: CALL_OW 45
4738: ST_TO_ADDR
// PlaceUnitArea ( veh , KurtUnitsSpawnArea , false ) ;
4739: LD_VAR 0 4
4743: PPUSH
4744: LD_INT 10
4746: PPUSH
4747: LD_INT 0
4749: PPUSH
4750: CALL_OW 49
// arAttackTeam = arAttackTeam ^ veh ;
4754: LD_ADDR_EXP 84
4758: PUSH
4759: LD_EXP 84
4763: PUSH
4764: LD_VAR 0 4
4768: ADD
4769: ST_TO_ADDR
// PrepareMechanic ( false , enemySkillLevel ) ;
4770: LD_INT 0
4772: PPUSH
4773: LD_EXP 56
4777: PPUSH
4778: CALL_OW 383
// unit = CreateHuman ;
4782: LD_ADDR_VAR 0 3
4786: PUSH
4787: CALL_OW 44
4791: ST_TO_ADDR
// PlaceHumanInUnit ( unit , veh ) ;
4792: LD_VAR 0 3
4796: PPUSH
4797: LD_VAR 0 4
4801: PPUSH
4802: CALL_OW 52
// arAttackTeam = arAttackTeam ^ unit ;
4806: LD_ADDR_EXP 84
4810: PUSH
4811: LD_EXP 84
4815: PUSH
4816: LD_VAR 0 3
4820: ADD
4821: ST_TO_ADDR
// end ;
4822: GO 4629
4824: POP
4825: POP
// end ; end_of_file
4826: LD_VAR 0 1
4830: RET
// export function Nef_PrepareNature ; var i , un ; begin
4831: LD_INT 0
4833: PPUSH
4834: PPUSH
4835: PPUSH
// for i := 1 to animalsAmount [ 1 ] do
4836: LD_ADDR_VAR 0 2
4840: PUSH
4841: DOUBLE
4842: LD_INT 1
4844: DEC
4845: ST_TO_ADDR
4846: LD_EXP 41
4850: PUSH
4851: LD_INT 1
4853: ARRAY
4854: PUSH
4855: FOR_TO
4856: IFFALSE 4966
// begin uc_side = 0 ;
4858: LD_ADDR_OWVAR 20
4862: PUSH
4863: LD_INT 0
4865: ST_TO_ADDR
// uc_nation = nation_nature ;
4866: LD_ADDR_OWVAR 21
4870: PUSH
4871: LD_INT 0
4873: ST_TO_ADDR
// hc_class = class_apeman ;
4874: LD_ADDR_OWVAR 28
4878: PUSH
4879: LD_INT 12
4881: ST_TO_ADDR
// hc_skills = [ animalsStats [ 1 ] , animalsStats [ 2 ] , animalsStats [ 3 ] , animalsStats [ 4 ] ] ;
4882: LD_ADDR_OWVAR 31
4886: PUSH
4887: LD_EXP 42
4891: PUSH
4892: LD_INT 1
4894: ARRAY
4895: PUSH
4896: LD_EXP 42
4900: PUSH
4901: LD_INT 2
4903: ARRAY
4904: PUSH
4905: LD_EXP 42
4909: PUSH
4910: LD_INT 3
4912: ARRAY
4913: PUSH
4914: LD_EXP 42
4918: PUSH
4919: LD_INT 4
4921: ARRAY
4922: PUSH
4923: EMPTY
4924: LIST
4925: LIST
4926: LIST
4927: LIST
4928: ST_TO_ADDR
// hc_agressivity = animalsAgression ;
4929: LD_ADDR_OWVAR 35
4933: PUSH
4934: LD_EXP 43
4938: ST_TO_ADDR
// un = CreateHuman ;
4939: LD_ADDR_VAR 0 3
4943: PUSH
4944: CALL_OW 44
4948: ST_TO_ADDR
// PlaceUnitArea ( un , NatureArea , false ) ;
4949: LD_VAR 0 3
4953: PPUSH
4954: LD_INT 5
4956: PPUSH
4957: LD_INT 0
4959: PPUSH
4960: CALL_OW 49
// end ;
4964: GO 4855
4966: POP
4967: POP
// for i := 1 to animalsAmount [ 2 ] do
4968: LD_ADDR_VAR 0 2
4972: PUSH
4973: DOUBLE
4974: LD_INT 1
4976: DEC
4977: ST_TO_ADDR
4978: LD_EXP 41
4982: PUSH
4983: LD_INT 2
4985: ARRAY
4986: PUSH
4987: FOR_TO
4988: IFFALSE 5098
// begin uc_side = 0 ;
4990: LD_ADDR_OWVAR 20
4994: PUSH
4995: LD_INT 0
4997: ST_TO_ADDR
// uc_nation = nation_nature ;
4998: LD_ADDR_OWVAR 21
5002: PUSH
5003: LD_INT 0
5005: ST_TO_ADDR
// hc_class = class_phororhacos ;
5006: LD_ADDR_OWVAR 28
5010: PUSH
5011: LD_INT 18
5013: ST_TO_ADDR
// hc_skills = [ animalsStats [ 1 ] , animalsStats [ 2 ] , animalsStats [ 3 ] , animalsStats [ 4 ] ] ;
5014: LD_ADDR_OWVAR 31
5018: PUSH
5019: LD_EXP 42
5023: PUSH
5024: LD_INT 1
5026: ARRAY
5027: PUSH
5028: LD_EXP 42
5032: PUSH
5033: LD_INT 2
5035: ARRAY
5036: PUSH
5037: LD_EXP 42
5041: PUSH
5042: LD_INT 3
5044: ARRAY
5045: PUSH
5046: LD_EXP 42
5050: PUSH
5051: LD_INT 4
5053: ARRAY
5054: PUSH
5055: EMPTY
5056: LIST
5057: LIST
5058: LIST
5059: LIST
5060: ST_TO_ADDR
// hc_agressivity = animalsAgression ;
5061: LD_ADDR_OWVAR 35
5065: PUSH
5066: LD_EXP 43
5070: ST_TO_ADDR
// un = CreateHuman ;
5071: LD_ADDR_VAR 0 3
5075: PUSH
5076: CALL_OW 44
5080: ST_TO_ADDR
// PlaceUnitArea ( un , NatureArea , false ) ;
5081: LD_VAR 0 3
5085: PPUSH
5086: LD_INT 5
5088: PPUSH
5089: LD_INT 0
5091: PPUSH
5092: CALL_OW 49
// end ;
5096: GO 4987
5098: POP
5099: POP
// for i := 1 to animalsAmount [ 3 ] do
5100: LD_ADDR_VAR 0 2
5104: PUSH
5105: DOUBLE
5106: LD_INT 1
5108: DEC
5109: ST_TO_ADDR
5110: LD_EXP 41
5114: PUSH
5115: LD_INT 3
5117: ARRAY
5118: PUSH
5119: FOR_TO
5120: IFFALSE 5230
// begin uc_side = 0 ;
5122: LD_ADDR_OWVAR 20
5126: PUSH
5127: LD_INT 0
5129: ST_TO_ADDR
// uc_nation = nation_nature ;
5130: LD_ADDR_OWVAR 21
5134: PUSH
5135: LD_INT 0
5137: ST_TO_ADDR
// hc_class = class_tiger ;
5138: LD_ADDR_OWVAR 28
5142: PUSH
5143: LD_INT 14
5145: ST_TO_ADDR
// hc_skills = [ animalsStats [ 1 ] , animalsStats [ 2 ] , animalsStats [ 3 ] , animalsStats [ 4 ] ] ;
5146: LD_ADDR_OWVAR 31
5150: PUSH
5151: LD_EXP 42
5155: PUSH
5156: LD_INT 1
5158: ARRAY
5159: PUSH
5160: LD_EXP 42
5164: PUSH
5165: LD_INT 2
5167: ARRAY
5168: PUSH
5169: LD_EXP 42
5173: PUSH
5174: LD_INT 3
5176: ARRAY
5177: PUSH
5178: LD_EXP 42
5182: PUSH
5183: LD_INT 4
5185: ARRAY
5186: PUSH
5187: EMPTY
5188: LIST
5189: LIST
5190: LIST
5191: LIST
5192: ST_TO_ADDR
// hc_agressivity = animalsAgression ;
5193: LD_ADDR_OWVAR 35
5197: PUSH
5198: LD_EXP 43
5202: ST_TO_ADDR
// un = CreateHuman ;
5203: LD_ADDR_VAR 0 3
5207: PUSH
5208: CALL_OW 44
5212: ST_TO_ADDR
// PlaceUnitArea ( un , NatureArea , false ) ;
5213: LD_VAR 0 3
5217: PPUSH
5218: LD_INT 5
5220: PPUSH
5221: LD_INT 0
5223: PPUSH
5224: CALL_OW 49
// end ;
5228: GO 5119
5230: POP
5231: POP
// for i := 1 to animalsAmount [ 4 ] do
5232: LD_ADDR_VAR 0 2
5236: PUSH
5237: DOUBLE
5238: LD_INT 1
5240: DEC
5241: ST_TO_ADDR
5242: LD_EXP 41
5246: PUSH
5247: LD_INT 4
5249: ARRAY
5250: PUSH
5251: FOR_TO
5252: IFFALSE 5362
// begin uc_side = 0 ;
5254: LD_ADDR_OWVAR 20
5258: PUSH
5259: LD_INT 0
5261: ST_TO_ADDR
// uc_nation = nation_nature ;
5262: LD_ADDR_OWVAR 21
5266: PUSH
5267: LD_INT 0
5269: ST_TO_ADDR
// hc_class = 21 ;
5270: LD_ADDR_OWVAR 28
5274: PUSH
5275: LD_INT 21
5277: ST_TO_ADDR
// hc_skills = [ animalsStats [ 1 ] , animalsStats [ 2 ] , animalsStats [ 3 ] , animalsStats [ 4 ] ] ;
5278: LD_ADDR_OWVAR 31
5282: PUSH
5283: LD_EXP 42
5287: PUSH
5288: LD_INT 1
5290: ARRAY
5291: PUSH
5292: LD_EXP 42
5296: PUSH
5297: LD_INT 2
5299: ARRAY
5300: PUSH
5301: LD_EXP 42
5305: PUSH
5306: LD_INT 3
5308: ARRAY
5309: PUSH
5310: LD_EXP 42
5314: PUSH
5315: LD_INT 4
5317: ARRAY
5318: PUSH
5319: EMPTY
5320: LIST
5321: LIST
5322: LIST
5323: LIST
5324: ST_TO_ADDR
// hc_agressivity = animalsAgression ;
5325: LD_ADDR_OWVAR 35
5329: PUSH
5330: LD_EXP 43
5334: ST_TO_ADDR
// un = CreateHuman ;
5335: LD_ADDR_VAR 0 3
5339: PUSH
5340: CALL_OW 44
5344: ST_TO_ADDR
// PlaceUnitArea ( un , NatureArea , false ) ;
5345: LD_VAR 0 3
5349: PPUSH
5350: LD_INT 5
5352: PPUSH
5353: LD_INT 0
5355: PPUSH
5356: CALL_OW 49
// end ;
5360: GO 5251
5362: POP
5363: POP
// for i := 1 to animalsAmount [ 5 ] do
5364: LD_ADDR_VAR 0 2
5368: PUSH
5369: DOUBLE
5370: LD_INT 1
5372: DEC
5373: ST_TO_ADDR
5374: LD_EXP 41
5378: PUSH
5379: LD_INT 5
5381: ARRAY
5382: PUSH
5383: FOR_TO
5384: IFFALSE 5445
// begin uc_side = 0 ;
5386: LD_ADDR_OWVAR 20
5390: PUSH
5391: LD_INT 0
5393: ST_TO_ADDR
// uc_nation = nation_nature ;
5394: LD_ADDR_OWVAR 21
5398: PUSH
5399: LD_INT 0
5401: ST_TO_ADDR
// vc_chassis := 31 ;
5402: LD_ADDR_OWVAR 37
5406: PUSH
5407: LD_INT 31
5409: ST_TO_ADDR
// vc_control := control_rider ;
5410: LD_ADDR_OWVAR 38
5414: PUSH
5415: LD_INT 4
5417: ST_TO_ADDR
// un := CreateVehicle ;
5418: LD_ADDR_VAR 0 3
5422: PUSH
5423: CALL_OW 45
5427: ST_TO_ADDR
// PlaceUnitArea ( un , NatureArea , false ) ;
5428: LD_VAR 0 3
5432: PPUSH
5433: LD_INT 5
5435: PPUSH
5436: LD_INT 0
5438: PPUSH
5439: CALL_OW 49
// end ;
5443: GO 5383
5445: POP
5446: POP
// end ;
5447: LD_VAR 0 1
5451: RET
// export function SpawnTrees ; begin
5452: LD_INT 0
5454: PPUSH
// PlaceTreesToArea ( TreeArea , [ 2 , 10 , 11 , 27 , 35 ] , 40 , 10 , 4 ) ;
5455: LD_INT 1
5457: PPUSH
5458: LD_INT 2
5460: PUSH
5461: LD_INT 10
5463: PUSH
5464: LD_INT 11
5466: PUSH
5467: LD_INT 27
5469: PUSH
5470: LD_INT 35
5472: PUSH
5473: EMPTY
5474: LIST
5475: LIST
5476: LIST
5477: LIST
5478: LIST
5479: PPUSH
5480: LD_INT 40
5482: PPUSH
5483: LD_INT 10
5485: PPUSH
5486: LD_INT 4
5488: PPUSH
5489: CALL_OW 352
// PlaceTreesToArea ( TreeArea , [ 9 , 10 , 27 , 35 , 48 ] , 30 , 10 , 4 ) ;
5493: LD_INT 1
5495: PPUSH
5496: LD_INT 9
5498: PUSH
5499: LD_INT 10
5501: PUSH
5502: LD_INT 27
5504: PUSH
5505: LD_INT 35
5507: PUSH
5508: LD_INT 48
5510: PUSH
5511: EMPTY
5512: LIST
5513: LIST
5514: LIST
5515: LIST
5516: LIST
5517: PPUSH
5518: LD_INT 30
5520: PPUSH
5521: LD_INT 10
5523: PPUSH
5524: LD_INT 4
5526: PPUSH
5527: CALL_OW 352
// PlaceTreesToArea ( TreeArea , [ 2 , 9 , 10 , 11 , 27 ] , 60 , 10 , 4 ) ;
5531: LD_INT 1
5533: PPUSH
5534: LD_INT 2
5536: PUSH
5537: LD_INT 9
5539: PUSH
5540: LD_INT 10
5542: PUSH
5543: LD_INT 11
5545: PUSH
5546: LD_INT 27
5548: PUSH
5549: EMPTY
5550: LIST
5551: LIST
5552: LIST
5553: LIST
5554: LIST
5555: PPUSH
5556: LD_INT 60
5558: PPUSH
5559: LD_INT 10
5561: PPUSH
5562: LD_INT 4
5564: PPUSH
5565: CALL_OW 352
// PlaceTreesToArea ( TreeArea , [ 9 , 10 , 27 , 35 , 48 ] , 90 , 10 , 4 ) ;
5569: LD_INT 1
5571: PPUSH
5572: LD_INT 9
5574: PUSH
5575: LD_INT 10
5577: PUSH
5578: LD_INT 27
5580: PUSH
5581: LD_INT 35
5583: PUSH
5584: LD_INT 48
5586: PUSH
5587: EMPTY
5588: LIST
5589: LIST
5590: LIST
5591: LIST
5592: LIST
5593: PPUSH
5594: LD_INT 90
5596: PPUSH
5597: LD_INT 10
5599: PPUSH
5600: LD_INT 4
5602: PPUSH
5603: CALL_OW 352
// PlaceTreesToArea ( TreeArea , [ 2 , 9 , 10 , 11 , 48 ] , 120 , 10 , 4 ) ;
5607: LD_INT 1
5609: PPUSH
5610: LD_INT 2
5612: PUSH
5613: LD_INT 9
5615: PUSH
5616: LD_INT 10
5618: PUSH
5619: LD_INT 11
5621: PUSH
5622: LD_INT 48
5624: PUSH
5625: EMPTY
5626: LIST
5627: LIST
5628: LIST
5629: LIST
5630: LIST
5631: PPUSH
5632: LD_INT 120
5634: PPUSH
5635: LD_INT 10
5637: PPUSH
5638: LD_INT 4
5640: PPUSH
5641: CALL_OW 352
// PlaceTreesToArea ( TreeArea , [ 2 , 11 , 27 , 35 , 48 ] , 45 , 10 , 4 ) ;
5645: LD_INT 1
5647: PPUSH
5648: LD_INT 2
5650: PUSH
5651: LD_INT 11
5653: PUSH
5654: LD_INT 27
5656: PUSH
5657: LD_INT 35
5659: PUSH
5660: LD_INT 48
5662: PUSH
5663: EMPTY
5664: LIST
5665: LIST
5666: LIST
5667: LIST
5668: LIST
5669: PPUSH
5670: LD_INT 45
5672: PPUSH
5673: LD_INT 10
5675: PPUSH
5676: LD_INT 4
5678: PPUSH
5679: CALL_OW 352
// end ;
5683: LD_VAR 0 1
5687: RET
// every 0 0$1 do var i , un ;
5688: GO 5690
5690: DISABLE
5691: LD_INT 0
5693: PPUSH
5694: PPUSH
// begin if ( GetTech ( tech_apelang , 3 ) = state_enabled or GetTech ( tech_apepsych , 3 ) = state_enabled or GetTech ( tech_apeagres , 3 ) = state_enabled ) and not FilterAllUnits ( [ [ f_or , [ f_class , class_apeman ] , [ f_class , class_apeman_engineer ] , [ f_class , class_apeman_soldier ] ] ] ) then
5695: LD_INT 1
5697: PPUSH
5698: LD_INT 3
5700: PPUSH
5701: CALL_OW 321
5705: PUSH
5706: LD_INT 1
5708: EQUAL
5709: PUSH
5710: LD_INT 2
5712: PPUSH
5713: LD_INT 3
5715: PPUSH
5716: CALL_OW 321
5720: PUSH
5721: LD_INT 1
5723: EQUAL
5724: OR
5725: PUSH
5726: LD_INT 11
5728: PPUSH
5729: LD_INT 3
5731: PPUSH
5732: CALL_OW 321
5736: PUSH
5737: LD_INT 1
5739: EQUAL
5740: OR
5741: PUSH
5742: LD_INT 2
5744: PUSH
5745: LD_INT 25
5747: PUSH
5748: LD_INT 12
5750: PUSH
5751: EMPTY
5752: LIST
5753: LIST
5754: PUSH
5755: LD_INT 25
5757: PUSH
5758: LD_INT 16
5760: PUSH
5761: EMPTY
5762: LIST
5763: LIST
5764: PUSH
5765: LD_INT 25
5767: PUSH
5768: LD_INT 15
5770: PUSH
5771: EMPTY
5772: LIST
5773: LIST
5774: PUSH
5775: EMPTY
5776: LIST
5777: LIST
5778: LIST
5779: LIST
5780: PUSH
5781: EMPTY
5782: LIST
5783: PPUSH
5784: CALL_OW 69
5788: NOT
5789: AND
5790: IFFALSE 5926
// begin for i := 1 to Rand ( 2 , 4 ) do
5792: LD_ADDR_VAR 0 1
5796: PUSH
5797: DOUBLE
5798: LD_INT 1
5800: DEC
5801: ST_TO_ADDR
5802: LD_INT 2
5804: PPUSH
5805: LD_INT 4
5807: PPUSH
5808: CALL_OW 12
5812: PUSH
5813: FOR_TO
5814: IFFALSE 5924
// begin uc_side = 0 ;
5816: LD_ADDR_OWVAR 20
5820: PUSH
5821: LD_INT 0
5823: ST_TO_ADDR
// uc_nation = nation_nature ;
5824: LD_ADDR_OWVAR 21
5828: PUSH
5829: LD_INT 0
5831: ST_TO_ADDR
// hc_class = class_apeman ;
5832: LD_ADDR_OWVAR 28
5836: PUSH
5837: LD_INT 12
5839: ST_TO_ADDR
// hc_skills = [ animalsStats [ 1 ] , animalsStats [ 2 ] , animalsStats [ 3 ] , animalsStats [ 4 ] ] ;
5840: LD_ADDR_OWVAR 31
5844: PUSH
5845: LD_EXP 42
5849: PUSH
5850: LD_INT 1
5852: ARRAY
5853: PUSH
5854: LD_EXP 42
5858: PUSH
5859: LD_INT 2
5861: ARRAY
5862: PUSH
5863: LD_EXP 42
5867: PUSH
5868: LD_INT 3
5870: ARRAY
5871: PUSH
5872: LD_EXP 42
5876: PUSH
5877: LD_INT 4
5879: ARRAY
5880: PUSH
5881: EMPTY
5882: LIST
5883: LIST
5884: LIST
5885: LIST
5886: ST_TO_ADDR
// hc_agressivity = animalsAgression ;
5887: LD_ADDR_OWVAR 35
5891: PUSH
5892: LD_EXP 43
5896: ST_TO_ADDR
// un = CreateHuman ;
5897: LD_ADDR_VAR 0 2
5901: PUSH
5902: CALL_OW 44
5906: ST_TO_ADDR
// PlaceUnitArea ( un , NatureArea , false ) ;
5907: LD_VAR 0 2
5911: PPUSH
5912: LD_INT 5
5914: PPUSH
5915: LD_INT 0
5917: PPUSH
5918: CALL_OW 49
// end ;
5922: GO 5813
5924: POP
5925: POP
// end ; enable ;
5926: ENABLE
// end ; end_of_file
5927: PPOPN 2
5929: END
// export function PrepareUnitExt ( ident , exist_mode , class ) ; var unit ; begin
5930: LD_INT 0
5932: PPUSH
5933: PPUSH
// if debugMode then
5934: LD_EXP 46
5938: IFFALSE 5955
// unit := NewCharacter ( ident ) ;
5940: LD_ADDR_VAR 0 5
5944: PUSH
5945: LD_VAR 0 1
5949: PPUSH
5950: CALL_OW 25
5954: ST_TO_ADDR
// if exist_mode and not debugMode then
5955: LD_VAR 0 2
5959: PUSH
5960: LD_EXP 46
5964: NOT
5965: AND
5966: IFFALSE 5991
// unit := CreateCharacter ( previousMissionPrefix & ident ) else
5968: LD_ADDR_VAR 0 5
5972: PUSH
5973: LD_EXP 45
5977: PUSH
5978: LD_VAR 0 1
5982: STR
5983: PPUSH
5984: CALL_OW 34
5988: ST_TO_ADDR
5989: GO 6013
// if not debugMode then
5991: LD_EXP 46
5995: NOT
5996: IFFALSE 6013
// unit := NewCharacter ( ident ) ;
5998: LD_ADDR_VAR 0 5
6002: PUSH
6003: LD_VAR 0 1
6007: PPUSH
6008: CALL_OW 25
6012: ST_TO_ADDR
// if class then
6013: LD_VAR 0 3
6017: IFFALSE 6033
// SetClass ( unit , class ) ;
6019: LD_VAR 0 5
6023: PPUSH
6024: LD_VAR 0 3
6028: PPUSH
6029: CALL_OW 336
// result := unit ;
6033: LD_ADDR_VAR 0 4
6037: PUSH
6038: LD_VAR 0 5
6042: ST_TO_ADDR
// end ;
6043: LD_VAR 0 4
6047: RET
// export function ExtSaveCharacter ( character , characterStringID , side ) ; begin
6048: LD_INT 0
6050: PPUSH
// if GetSide ( character ) = side and not IsDead ( character ) then
6051: LD_VAR 0 1
6055: PPUSH
6056: CALL_OW 255
6060: PUSH
6061: LD_VAR 0 3
6065: EQUAL
6066: PUSH
6067: LD_VAR 0 1
6071: PPUSH
6072: CALL_OW 301
6076: NOT
6077: AND
6078: IFFALSE 6100
// SaveCharacters ( character , missionPrefix & characterStringID ) ;
6080: LD_VAR 0 1
6084: PPUSH
6085: LD_EXP 44
6089: PUSH
6090: LD_VAR 0 2
6094: STR
6095: PPUSH
6096: CALL_OW 38
// end ;
6100: LD_VAR 0 4
6104: RET
// export function ExtSaveCharacters ( characters , charactersStringID , side ) ; var unit , resultCharactersToSave ; begin
6105: LD_INT 0
6107: PPUSH
6108: PPUSH
6109: PPUSH
// resultCharactersToSave = [ ] ;
6110: LD_ADDR_VAR 0 6
6114: PUSH
6115: EMPTY
6116: ST_TO_ADDR
// for unit in characters do
6117: LD_ADDR_VAR 0 5
6121: PUSH
6122: LD_VAR 0 1
6126: PUSH
6127: FOR_IN
6128: IFFALSE 6177
// if GetSide ( unit ) = side and not IsDead ( unit ) then
6130: LD_VAR 0 5
6134: PPUSH
6135: CALL_OW 255
6139: PUSH
6140: LD_VAR 0 3
6144: EQUAL
6145: PUSH
6146: LD_VAR 0 5
6150: PPUSH
6151: CALL_OW 301
6155: NOT
6156: AND
6157: IFFALSE 6175
// resultCharactersToSave = resultCharactersToSave ^ unit ;
6159: LD_ADDR_VAR 0 6
6163: PUSH
6164: LD_VAR 0 6
6168: PUSH
6169: LD_VAR 0 5
6173: ADD
6174: ST_TO_ADDR
6175: GO 6127
6177: POP
6178: POP
// SaveCharacters ( resultCharactersToSave , missionPrefix & charactersStringID ) ;
6179: LD_VAR 0 6
6183: PPUSH
6184: LD_EXP 44
6188: PUSH
6189: LD_VAR 0 2
6193: STR
6194: PPUSH
6195: CALL_OW 38
// end ;
6199: LD_VAR 0 4
6203: RET
// export function PlaceUnitsArea ( units , area , spawnMode ) ; var unit ; begin
6204: LD_INT 0
6206: PPUSH
6207: PPUSH
// for unit in units do
6208: LD_ADDR_VAR 0 5
6212: PUSH
6213: LD_VAR 0 1
6217: PUSH
6218: FOR_IN
6219: IFFALSE 6242
// PlaceUnitArea ( unit , area , spawnMode ) ;
6221: LD_VAR 0 5
6225: PPUSH
6226: LD_VAR 0 2
6230: PPUSH
6231: LD_VAR 0 3
6235: PPUSH
6236: CALL_OW 49
6240: GO 6218
6242: POP
6243: POP
// end ;
6244: LD_VAR 0 4
6248: RET
// export function DialogRandom ( characters , dialogMID , dialogFID , radio , canTalkHero ) ; var i , speaker , units ; begin
6249: LD_INT 0
6251: PPUSH
6252: PPUSH
6253: PPUSH
6254: PPUSH
// units = characters ;
6255: LD_ADDR_VAR 0 9
6259: PUSH
6260: LD_VAR 0 1
6264: ST_TO_ADDR
// units := units diff [ Burlak , Karamazov , Petrovova , Gleb , Petrosyan , Titov , Dolgov , Lipshchin , Kirilenkova ] ;
6265: LD_ADDR_VAR 0 9
6269: PUSH
6270: LD_VAR 0 9
6274: PUSH
6275: LD_EXP 57
6279: PUSH
6280: LD_EXP 58
6284: PUSH
6285: LD_EXP 59
6289: PUSH
6290: LD_EXP 60
6294: PUSH
6295: LD_EXP 61
6299: PUSH
6300: LD_EXP 62
6304: PUSH
6305: LD_EXP 63
6309: PUSH
6310: LD_EXP 64
6314: PUSH
6315: LD_EXP 65
6319: PUSH
6320: EMPTY
6321: LIST
6322: LIST
6323: LIST
6324: LIST
6325: LIST
6326: LIST
6327: LIST
6328: LIST
6329: LIST
6330: DIFF
6331: ST_TO_ADDR
// if not units and not canTalkHero then
6332: LD_VAR 0 9
6336: NOT
6337: PUSH
6338: LD_VAR 0 5
6342: NOT
6343: AND
6344: IFFALSE 6348
// exit ;
6346: GO 6521
// if not units then
6348: LD_VAR 0 9
6352: NOT
6353: IFFALSE 6374
// units = characters diff [ Burlak ] ;
6355: LD_ADDR_VAR 0 9
6359: PUSH
6360: LD_VAR 0 1
6364: PUSH
6365: LD_EXP 57
6369: PUSH
6370: EMPTY
6371: LIST
6372: DIFF
6373: ST_TO_ADDR
// if not units and canTalkHero then
6374: LD_VAR 0 9
6378: NOT
6379: PUSH
6380: LD_VAR 0 5
6384: AND
6385: IFFALSE 6389
// exit ;
6387: GO 6521
// speaker := units [ rand ( 1 , units ) ] ;
6389: LD_ADDR_VAR 0 8
6393: PUSH
6394: LD_VAR 0 9
6398: PUSH
6399: LD_INT 1
6401: PPUSH
6402: LD_VAR 0 9
6406: PPUSH
6407: CALL_OW 12
6411: ARRAY
6412: ST_TO_ADDR
// if radio then
6413: LD_VAR 0 4
6417: IFFALSE 6466
// begin if GetSex ( speaker ) = sex_male then
6419: LD_VAR 0 8
6423: PPUSH
6424: CALL_OW 258
6428: PUSH
6429: LD_INT 1
6431: EQUAL
6432: IFFALSE 6450
// SayRadio ( speaker , dialogMID ) else
6434: LD_VAR 0 8
6438: PPUSH
6439: LD_VAR 0 2
6443: PPUSH
6444: CALL_OW 94
6448: GO 6464
// SayRadio ( speaker , dialogFID ) ;
6450: LD_VAR 0 8
6454: PPUSH
6455: LD_VAR 0 3
6459: PPUSH
6460: CALL_OW 94
// end else
6464: GO 6511
// begin if GetSex ( speaker ) = sex_male then
6466: LD_VAR 0 8
6470: PPUSH
6471: CALL_OW 258
6475: PUSH
6476: LD_INT 1
6478: EQUAL
6479: IFFALSE 6497
// Say ( speaker , dialogMID ) else
6481: LD_VAR 0 8
6485: PPUSH
6486: LD_VAR 0 2
6490: PPUSH
6491: CALL_OW 88
6495: GO 6511
// Say ( speaker , dialogFID ) ;
6497: LD_VAR 0 8
6501: PPUSH
6502: LD_VAR 0 3
6506: PPUSH
6507: CALL_OW 88
// end ; result := speaker ;
6511: LD_ADDR_VAR 0 6
6515: PUSH
6516: LD_VAR 0 8
6520: ST_TO_ADDR
// end ;
6521: LD_VAR 0 6
6525: RET
// export function RemoveUnits ( units ) ; var unit ; begin
6526: LD_INT 0
6528: PPUSH
6529: PPUSH
// if not units then
6530: LD_VAR 0 1
6534: NOT
6535: IFFALSE 6539
// exit ;
6537: GO 6685
// if Heike in units then
6539: LD_EXP 79
6543: PUSH
6544: LD_VAR 0 1
6548: IN
6549: IFFALSE 6605
// begin if GetAttitude ( 3 , 8 ) = att_neutral then
6551: LD_INT 3
6553: PPUSH
6554: LD_INT 8
6556: PPUSH
6557: CALL_OW 81
6561: PUSH
6562: LD_INT 0
6564: EQUAL
6565: IFFALSE 6577
// HeikeStatus = 1 else
6567: LD_ADDR_EXP 3
6571: PUSH
6572: LD_INT 1
6574: ST_TO_ADDR
6575: GO 6585
// HeikeStatus = 2 ;
6577: LD_ADDR_EXP 3
6581: PUSH
6582: LD_INT 2
6584: ST_TO_ADDR
// forceStopKurtAttack = true ;
6585: LD_ADDR_EXP 27
6589: PUSH
6590: LD_INT 1
6592: ST_TO_ADDR
// SetClass ( Heike , 1 ) ;
6593: LD_EXP 79
6597: PPUSH
6598: LD_INT 1
6600: PPUSH
6601: CALL_OW 336
// end ; if Kurt in units then
6605: LD_EXP 80
6609: PUSH
6610: LD_VAR 0 1
6614: IN
6615: IFFALSE 6659
// begin if GetAttitude ( 3 , 8 ) = att_neutral then
6617: LD_INT 3
6619: PPUSH
6620: LD_INT 8
6622: PPUSH
6623: CALL_OW 81
6627: PUSH
6628: LD_INT 0
6630: EQUAL
6631: IFFALSE 6643
// KurtStatus = 1 else
6633: LD_ADDR_EXP 22
6637: PUSH
6638: LD_INT 1
6640: ST_TO_ADDR
6641: GO 6659
// begin KurtStatus = 2 ;
6643: LD_ADDR_EXP 22
6647: PUSH
6648: LD_INT 2
6650: ST_TO_ADDR
// KurtAttack = 1 ;
6651: LD_ADDR_EXP 25
6655: PUSH
6656: LD_INT 1
6658: ST_TO_ADDR
// end ; end ; for unit in units do
6659: LD_ADDR_VAR 0 3
6663: PUSH
6664: LD_VAR 0 1
6668: PUSH
6669: FOR_IN
6670: IFFALSE 6683
// RemoveUnit ( unit ) ;
6672: LD_VAR 0 3
6676: PPUSH
6677: CALL_OW 64
6681: GO 6669
6683: POP
6684: POP
// end ;
6685: LD_VAR 0 2
6689: RET
// export function GetAmountWeaponsDataBuildOnTurret ( isBuild ) ; var i , amount ; begin
6690: LD_INT 0
6692: PPUSH
6693: PPUSH
6694: PPUSH
// amount = 0 ;
6695: LD_ADDR_VAR 0 4
6699: PUSH
6700: LD_INT 0
6702: ST_TO_ADDR
// for i := 1 to weaponsData do
6703: LD_ADDR_VAR 0 3
6707: PUSH
6708: DOUBLE
6709: LD_INT 1
6711: DEC
6712: ST_TO_ADDR
6713: LD_EXP 12
6717: PUSH
6718: FOR_TO
6719: IFFALSE 6759
// if weaponsData [ i ] [ 2 ] = isBuild then
6721: LD_EXP 12
6725: PUSH
6726: LD_VAR 0 3
6730: ARRAY
6731: PUSH
6732: LD_INT 2
6734: ARRAY
6735: PUSH
6736: LD_VAR 0 1
6740: EQUAL
6741: IFFALSE 6757
// amount = amount + 1 ;
6743: LD_ADDR_VAR 0 4
6747: PUSH
6748: LD_VAR 0 4
6752: PUSH
6753: LD_INT 1
6755: PLUS
6756: ST_TO_ADDR
6757: GO 6718
6759: POP
6760: POP
// if isBuild then
6761: LD_VAR 0 1
6765: IFFALSE 6785
// if amount >= 3 then
6767: LD_VAR 0 4
6771: PUSH
6772: LD_INT 3
6774: GREATEREQUAL
6775: IFFALSE 6785
// amount = 3 ;
6777: LD_ADDR_VAR 0 4
6781: PUSH
6782: LD_INT 3
6784: ST_TO_ADDR
// result = amount ;
6785: LD_ADDR_VAR 0 2
6789: PUSH
6790: LD_VAR 0 4
6794: ST_TO_ADDR
// end ;
6795: LD_VAR 0 2
6799: RET
// export function GetAmountWeaponsDataBuildOnVehicle ( isBuild ) ; var i , amount ; begin
6800: LD_INT 0
6802: PPUSH
6803: PPUSH
6804: PPUSH
// amount = 0 ;
6805: LD_ADDR_VAR 0 4
6809: PUSH
6810: LD_INT 0
6812: ST_TO_ADDR
// for i := 1 to weaponsData do
6813: LD_ADDR_VAR 0 3
6817: PUSH
6818: DOUBLE
6819: LD_INT 1
6821: DEC
6822: ST_TO_ADDR
6823: LD_EXP 12
6827: PUSH
6828: FOR_TO
6829: IFFALSE 6869
// if weaponsData [ i ] [ 3 ] = isBuild then
6831: LD_EXP 12
6835: PUSH
6836: LD_VAR 0 3
6840: ARRAY
6841: PUSH
6842: LD_INT 3
6844: ARRAY
6845: PUSH
6846: LD_VAR 0 1
6850: EQUAL
6851: IFFALSE 6867
// amount = amount + 1 ;
6853: LD_ADDR_VAR 0 4
6857: PUSH
6858: LD_VAR 0 4
6862: PUSH
6863: LD_INT 1
6865: PLUS
6866: ST_TO_ADDR
6867: GO 6828
6869: POP
6870: POP
// result = amount ;
6871: LD_ADDR_VAR 0 2
6875: PUSH
6876: LD_VAR 0 4
6880: ST_TO_ADDR
// end ;
6881: LD_VAR 0 2
6885: RET
// export function SetWeaponDataBuild ( weapon , turret ) ; var i ; begin
6886: LD_INT 0
6888: PPUSH
6889: PPUSH
// if turret then
6890: LD_VAR 0 2
6894: IFFALSE 6992
// begin for i := 1 to weaponsData do
6896: LD_ADDR_VAR 0 4
6900: PUSH
6901: DOUBLE
6902: LD_INT 1
6904: DEC
6905: ST_TO_ADDR
6906: LD_EXP 12
6910: PUSH
6911: FOR_TO
6912: IFFALSE 6988
// if weaponsData [ i ] [ 1 ] = weapon and weaponsData [ i ] [ 2 ] = false then
6914: LD_EXP 12
6918: PUSH
6919: LD_VAR 0 4
6923: ARRAY
6924: PUSH
6925: LD_INT 1
6927: ARRAY
6928: PUSH
6929: LD_VAR 0 1
6933: EQUAL
6934: PUSH
6935: LD_EXP 12
6939: PUSH
6940: LD_VAR 0 4
6944: ARRAY
6945: PUSH
6946: LD_INT 2
6948: ARRAY
6949: PUSH
6950: LD_INT 0
6952: EQUAL
6953: AND
6954: IFFALSE 6986
// weaponsData = ReplaceIn ( weaponsData , [ i , 2 ] , true ) ;
6956: LD_ADDR_EXP 12
6960: PUSH
6961: LD_EXP 12
6965: PPUSH
6966: LD_VAR 0 4
6970: PUSH
6971: LD_INT 2
6973: PUSH
6974: EMPTY
6975: LIST
6976: LIST
6977: PPUSH
6978: LD_INT 1
6980: PPUSH
6981: CALL 24186 0 3
6985: ST_TO_ADDR
6986: GO 6911
6988: POP
6989: POP
// end else
6990: GO 7086
// begin for i := 1 to weaponsData do
6992: LD_ADDR_VAR 0 4
6996: PUSH
6997: DOUBLE
6998: LD_INT 1
7000: DEC
7001: ST_TO_ADDR
7002: LD_EXP 12
7006: PUSH
7007: FOR_TO
7008: IFFALSE 7084
// if weaponsData [ i ] [ 1 ] = weapon and weaponsData [ i ] [ 3 ] = false then
7010: LD_EXP 12
7014: PUSH
7015: LD_VAR 0 4
7019: ARRAY
7020: PUSH
7021: LD_INT 1
7023: ARRAY
7024: PUSH
7025: LD_VAR 0 1
7029: EQUAL
7030: PUSH
7031: LD_EXP 12
7035: PUSH
7036: LD_VAR 0 4
7040: ARRAY
7041: PUSH
7042: LD_INT 3
7044: ARRAY
7045: PUSH
7046: LD_INT 0
7048: EQUAL
7049: AND
7050: IFFALSE 7082
// weaponsData = ReplaceIn ( weaponsData , [ i , 3 ] , true ) ;
7052: LD_ADDR_EXP 12
7056: PUSH
7057: LD_EXP 12
7061: PPUSH
7062: LD_VAR 0 4
7066: PUSH
7067: LD_INT 3
7069: PUSH
7070: EMPTY
7071: LIST
7072: LIST
7073: PPUSH
7074: LD_INT 1
7076: PPUSH
7077: CALL 24186 0 3
7081: ST_TO_ADDR
7082: GO 7007
7084: POP
7085: POP
// end ; end ;
7086: LD_VAR 0 3
7090: RET
// export function ShootTreningController ; var i , unitsInArea , unit , depots , depot , barrelsAreaList , randIndex , randPosX , randPosY , barrelsInArea ; begin
7091: LD_INT 0
7093: PPUSH
7094: PPUSH
7095: PPUSH
7096: PPUSH
7097: PPUSH
7098: PPUSH
7099: PPUSH
7100: PPUSH
7101: PPUSH
7102: PPUSH
7103: PPUSH
// unitsInArea = FilterUnitsInArea ( ShootArea , [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) ;
7104: LD_ADDR_VAR 0 3
7108: PUSH
7109: LD_INT 12
7111: PPUSH
7112: LD_INT 22
7114: PUSH
7115: LD_INT 3
7117: PUSH
7118: EMPTY
7119: LIST
7120: LIST
7121: PUSH
7122: LD_INT 21
7124: PUSH
7125: LD_INT 1
7127: PUSH
7128: EMPTY
7129: LIST
7130: LIST
7131: PUSH
7132: LD_INT 50
7134: PUSH
7135: EMPTY
7136: LIST
7137: PUSH
7138: LD_INT 3
7140: PUSH
7141: LD_INT 60
7143: PUSH
7144: EMPTY
7145: LIST
7146: PUSH
7147: EMPTY
7148: LIST
7149: LIST
7150: PUSH
7151: EMPTY
7152: LIST
7153: LIST
7154: LIST
7155: LIST
7156: PPUSH
7157: CALL_OW 70
7161: ST_TO_ADDR
// depots = FilterAllUnits ( [ [ f_side , 3 ] , [ f_ok ] , [ f_type , unit_building ] , [ f_not , [ f_constructed ] ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
7162: LD_ADDR_VAR 0 5
7166: PUSH
7167: LD_INT 22
7169: PUSH
7170: LD_INT 3
7172: PUSH
7173: EMPTY
7174: LIST
7175: LIST
7176: PUSH
7177: LD_INT 50
7179: PUSH
7180: EMPTY
7181: LIST
7182: PUSH
7183: LD_INT 21
7185: PUSH
7186: LD_INT 3
7188: PUSH
7189: EMPTY
7190: LIST
7191: LIST
7192: PUSH
7193: LD_INT 3
7195: PUSH
7196: LD_INT 57
7198: PUSH
7199: EMPTY
7200: LIST
7201: PUSH
7202: EMPTY
7203: LIST
7204: LIST
7205: PUSH
7206: LD_INT 2
7208: PUSH
7209: LD_INT 30
7211: PUSH
7212: LD_INT 0
7214: PUSH
7215: EMPTY
7216: LIST
7217: LIST
7218: PUSH
7219: LD_INT 30
7221: PUSH
7222: LD_INT 1
7224: PUSH
7225: EMPTY
7226: LIST
7227: LIST
7228: PUSH
7229: EMPTY
7230: LIST
7231: LIST
7232: LIST
7233: PUSH
7234: EMPTY
7235: LIST
7236: LIST
7237: LIST
7238: LIST
7239: LIST
7240: PPUSH
7241: CALL_OW 69
7245: ST_TO_ADDR
// barrelsAreaList = AreaToList ( BarrelsArea , 0 ) ;
7246: LD_ADDR_VAR 0 7
7250: PUSH
7251: LD_INT 13
7253: PPUSH
7254: LD_INT 0
7256: PPUSH
7257: CALL_OW 517
7261: ST_TO_ADDR
// if not depots or not unitsInArea then
7262: LD_VAR 0 5
7266: NOT
7267: PUSH
7268: LD_VAR 0 3
7272: NOT
7273: OR
7274: IFFALSE 7278
// exit ;
7276: GO 7714
// depot = depots [ 1 ] ;
7278: LD_ADDR_VAR 0 6
7282: PUSH
7283: LD_VAR 0 5
7287: PUSH
7288: LD_INT 1
7290: ARRAY
7291: ST_TO_ADDR
// for unit in unitsInArea do
7292: LD_ADDR_VAR 0 4
7296: PUSH
7297: LD_VAR 0 3
7301: PUSH
7302: FOR_IN
7303: IFFALSE 7712
// begin if not GetClass ( unit ) = class_engineer then
7305: LD_VAR 0 4
7309: PPUSH
7310: CALL_OW 257
7314: PUSH
7315: LD_INT 2
7317: EQUAL
7318: NOT
7319: IFFALSE 7356
// begin ComEnterUnit ( unit , depot ) ;
7321: LD_VAR 0 4
7325: PPUSH
7326: LD_VAR 0 6
7330: PPUSH
7331: CALL_OW 120
// AddComChangeProfession ( unit , class_engineer ) ;
7335: LD_VAR 0 4
7339: PPUSH
7340: LD_INT 2
7342: PPUSH
7343: CALL_OW 183
// AddComExitBuilding ( unit ) ;
7347: LD_VAR 0 4
7351: PPUSH
7352: CALL_OW 182
// end ; if GetCargo ( unit , mat_oil ) = 0 then
7356: LD_VAR 0 4
7360: PPUSH
7361: LD_INT 2
7363: PPUSH
7364: CALL_OW 289
7368: PUSH
7369: LD_INT 0
7371: EQUAL
7372: IFFALSE 7391
// AddComTransport ( unit , depot , mat_oil ) ;
7374: LD_VAR 0 4
7378: PPUSH
7379: LD_VAR 0 6
7383: PPUSH
7384: LD_INT 2
7386: PPUSH
7387: CALL_OW 211
// repeat wait ( 0 0$1 ) ;
7391: LD_INT 35
7393: PPUSH
7394: CALL_OW 67
// until not HasTask ( unit ) ;
7398: LD_VAR 0 4
7402: PPUSH
7403: CALL_OW 314
7407: NOT
7408: IFFALSE 7391
// if GetCargo ( unit , mat_oil ) > 0 then
7410: LD_VAR 0 4
7414: PPUSH
7415: LD_INT 2
7417: PPUSH
7418: CALL_OW 289
7422: PUSH
7423: LD_INT 0
7425: GREATER
7426: IFFALSE 7710
// begin randIndex = Rand ( 1 , barrelsAreaList [ 1 ] ) ;
7428: LD_ADDR_VAR 0 8
7432: PUSH
7433: LD_INT 1
7435: PPUSH
7436: LD_VAR 0 7
7440: PUSH
7441: LD_INT 1
7443: ARRAY
7444: PPUSH
7445: CALL_OW 12
7449: ST_TO_ADDR
// randPosX = barrelsAreaList [ 1 ] [ randIndex ] ;
7450: LD_ADDR_VAR 0 9
7454: PUSH
7455: LD_VAR 0 7
7459: PUSH
7460: LD_INT 1
7462: ARRAY
7463: PUSH
7464: LD_VAR 0 8
7468: ARRAY
7469: ST_TO_ADDR
// randPosY = barrelsAreaList [ 2 ] [ RandIndex ] ;
7470: LD_ADDR_VAR 0 10
7474: PUSH
7475: LD_VAR 0 7
7479: PUSH
7480: LD_INT 2
7482: ARRAY
7483: PUSH
7484: LD_VAR 0 8
7488: ARRAY
7489: ST_TO_ADDR
// AddComMoveXY ( unit , randPosX , randPosY ) ;
7490: LD_VAR 0 4
7494: PPUSH
7495: LD_VAR 0 9
7499: PPUSH
7500: LD_VAR 0 10
7504: PPUSH
7505: CALL_OW 171
// AddComUnload ( unit ) ;
7509: LD_VAR 0 4
7513: PPUSH
7514: CALL_OW 219
// AddComMoveXY ( unit , randPosX + 2 , randPosY + 2 ) ;
7518: LD_VAR 0 4
7522: PPUSH
7523: LD_VAR 0 9
7527: PUSH
7528: LD_INT 2
7530: PLUS
7531: PPUSH
7532: LD_VAR 0 10
7536: PUSH
7537: LD_INT 2
7539: PLUS
7540: PPUSH
7541: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
7545: LD_INT 35
7547: PPUSH
7548: CALL_OW 67
// until not HasTask ( unit ) ;
7552: LD_VAR 0 4
7556: PPUSH
7557: CALL_OW 314
7561: NOT
7562: IFFALSE 7545
// barrelsInArea = GetListOfCratesInArea ( ShootArea ) ;
7564: LD_ADDR_VAR 0 11
7568: PUSH
7569: LD_INT 12
7571: PPUSH
7572: CALL_OW 435
7576: ST_TO_ADDR
// for i := 1 to barrelsInArea / 2 do
7577: LD_ADDR_VAR 0 2
7581: PUSH
7582: DOUBLE
7583: LD_INT 1
7585: DEC
7586: ST_TO_ADDR
7587: LD_VAR 0 11
7591: PUSH
7592: LD_INT 2
7594: DIVREAL
7595: PUSH
7596: FOR_TO
7597: IFFALSE 7708
// begin if GetDistUnitXY ( unit , barrelsInArea [ i ] , barrelsInArea [ i + 1 ] ) <= 6 then
7599: LD_VAR 0 4
7603: PPUSH
7604: LD_VAR 0 11
7608: PUSH
7609: LD_VAR 0 2
7613: ARRAY
7614: PPUSH
7615: LD_VAR 0 11
7619: PUSH
7620: LD_VAR 0 2
7624: PUSH
7625: LD_INT 1
7627: PLUS
7628: ARRAY
7629: PPUSH
7630: CALL_OW 297
7634: PUSH
7635: LD_INT 6
7637: LESSEQUAL
7638: IFFALSE 7692
// begin AddComAttackPlace ( unit , barrelsInArea [ i ] , barrelsInArea [ i + 1 ] ) ;
7640: LD_VAR 0 4
7644: PPUSH
7645: LD_VAR 0 11
7649: PUSH
7650: LD_VAR 0 2
7654: ARRAY
7655: PPUSH
7656: LD_VAR 0 11
7660: PUSH
7661: LD_VAR 0 2
7665: PUSH
7666: LD_INT 1
7668: PLUS
7669: ARRAY
7670: PPUSH
7671: CALL_OW 176
// AddExperience ( unit , skill_combat , 5 ) ;
7675: LD_VAR 0 4
7679: PPUSH
7680: LD_INT 1
7682: PPUSH
7683: LD_INT 5
7685: PPUSH
7686: CALL_OW 492
// break ;
7690: GO 7708
// end ; i = i + 2 ;
7692: LD_ADDR_VAR 0 2
7696: PUSH
7697: LD_VAR 0 2
7701: PUSH
7702: LD_INT 2
7704: PLUS
7705: ST_TO_ADDR
// end ;
7706: GO 7596
7708: POP
7709: POP
// end ; end ;
7710: GO 7302
7712: POP
7713: POP
// end ;
7714: LD_VAR 0 1
7718: RET
// export function GoToHunt ( hunter ) ; var i , barracks , barrackTarget , barrackTargetCurrentHP , animals , animal ; begin
7719: LD_INT 0
7721: PPUSH
7722: PPUSH
7723: PPUSH
7724: PPUSH
7725: PPUSH
7726: PPUSH
7727: PPUSH
// animals = [ ] ;
7728: LD_ADDR_VAR 0 7
7732: PUSH
7733: EMPTY
7734: ST_TO_ADDR
// barracks = FilterAllUnits ( [ [ f_ok ] , [ f_not , [ f_constructed ] ] , [ f_or , [ f_btype , b_barracks ] , [ f_btype , b_armoury ] ] ] ) ;
7735: LD_ADDR_VAR 0 4
7739: PUSH
7740: LD_INT 50
7742: PUSH
7743: EMPTY
7744: LIST
7745: PUSH
7746: LD_INT 3
7748: PUSH
7749: LD_INT 57
7751: PUSH
7752: EMPTY
7753: LIST
7754: PUSH
7755: EMPTY
7756: LIST
7757: LIST
7758: PUSH
7759: LD_INT 2
7761: PUSH
7762: LD_INT 30
7764: PUSH
7765: LD_INT 5
7767: PUSH
7768: EMPTY
7769: LIST
7770: LIST
7771: PUSH
7772: LD_INT 30
7774: PUSH
7775: LD_INT 4
7777: PUSH
7778: EMPTY
7779: LIST
7780: LIST
7781: PUSH
7782: EMPTY
7783: LIST
7784: LIST
7785: LIST
7786: PUSH
7787: EMPTY
7788: LIST
7789: LIST
7790: LIST
7791: PPUSH
7792: CALL_OW 69
7796: ST_TO_ADDR
// SetSide ( hunter , 6 ) ;
7797: LD_VAR 0 1
7801: PPUSH
7802: LD_INT 6
7804: PPUSH
7805: CALL_OW 235
// if IsInUnit ( hunter ) then
7809: LD_VAR 0 1
7813: PPUSH
7814: CALL_OW 310
7818: IFFALSE 7860
// begin if GetBType ( IsInUnit ( hunter ) = unit_vehicle ) then
7820: LD_VAR 0 1
7824: PPUSH
7825: CALL_OW 310
7829: PUSH
7830: LD_INT 2
7832: EQUAL
7833: PPUSH
7834: CALL_OW 266
7838: IFFALSE 7851
// ComExitVehicle ( hunter ) else
7840: LD_VAR 0 1
7844: PPUSH
7845: CALL_OW 121
7849: GO 7860
// ComExitBuilding ( hunter ) ;
7851: LD_VAR 0 1
7855: PPUSH
7856: CALL_OW 122
// end ; ComWalk ( hunter ) ;
7860: LD_VAR 0 1
7864: PPUSH
7865: CALL_OW 138
// wait ( 0 0$1 ) ;
7869: LD_INT 35
7871: PPUSH
7872: CALL_OW 67
// if not GetClass ( hunter ) = class_soldier and barracks then
7876: LD_VAR 0 1
7880: PPUSH
7881: CALL_OW 257
7885: PUSH
7886: LD_INT 1
7888: EQUAL
7889: NOT
7890: PUSH
7891: LD_VAR 0 4
7895: AND
7896: IFFALSE 8039
// begin barrackTarget = barracks [ 1 ] ;
7898: LD_ADDR_VAR 0 5
7902: PUSH
7903: LD_VAR 0 4
7907: PUSH
7908: LD_INT 1
7910: ARRAY
7911: ST_TO_ADDR
// barrackTargetCurrentHP = GetLives ( barrackTarget ) ;
7912: LD_ADDR_VAR 0 6
7916: PUSH
7917: LD_VAR 0 5
7921: PPUSH
7922: CALL_OW 256
7926: ST_TO_ADDR
// SetSide ( barrackTarget , 6 ) ;
7927: LD_VAR 0 5
7931: PPUSH
7932: LD_INT 6
7934: PPUSH
7935: CALL_OW 235
// ComEnterUnit ( hunter , barrackTarget ) ;
7939: LD_VAR 0 1
7943: PPUSH
7944: LD_VAR 0 5
7948: PPUSH
7949: CALL_OW 120
// repeat wait ( 0 0$1 ) ;
7953: LD_INT 35
7955: PPUSH
7956: CALL_OW 67
// ComEnterUnit ( hunter , barrackTarget ) ;
7960: LD_VAR 0 1
7964: PPUSH
7965: LD_VAR 0 5
7969: PPUSH
7970: CALL_OW 120
// SetLives ( barrackTarget , barrackTargetCurrentHP ) ;
7974: LD_VAR 0 5
7978: PPUSH
7979: LD_VAR 0 6
7983: PPUSH
7984: CALL_OW 234
// until IsInUnit ( hunter ) ;
7988: LD_VAR 0 1
7992: PPUSH
7993: CALL_OW 310
7997: IFFALSE 7953
// SetClass ( hunter , class_soldier ) ;
7999: LD_VAR 0 1
8003: PPUSH
8004: LD_INT 1
8006: PPUSH
8007: CALL_OW 336
// ComExitBuilding ( hunter ) ;
8011: LD_VAR 0 1
8015: PPUSH
8016: CALL_OW 122
// SetSide ( barrackTarget , 3 ) ;
8020: LD_VAR 0 5
8024: PPUSH
8025: LD_INT 3
8027: PPUSH
8028: CALL_OW 235
// wait ( 0 0$1 ) ;
8032: LD_INT 35
8034: PPUSH
8035: CALL_OW 67
// end ; for i := 1 to 3 do
8039: LD_ADDR_VAR 0 3
8043: PUSH
8044: DOUBLE
8045: LD_INT 1
8047: DEC
8048: ST_TO_ADDR
8049: LD_INT 3
8051: PUSH
8052: FOR_TO
8053: IFFALSE 8158
// begin uc_side = 0 ;
8055: LD_ADDR_OWVAR 20
8059: PUSH
8060: LD_INT 0
8062: ST_TO_ADDR
// uc_nation = nation_nature ;
8063: LD_ADDR_OWVAR 21
8067: PUSH
8068: LD_INT 0
8070: ST_TO_ADDR
// PrepareHuman ( false , [ class_phororhacos , class_tiger , 21 ] [ Rand ( 1 , 3 ) ] , 0 ) ;
8071: LD_INT 0
8073: PPUSH
8074: LD_INT 18
8076: PUSH
8077: LD_INT 14
8079: PUSH
8080: LD_INT 21
8082: PUSH
8083: EMPTY
8084: LIST
8085: LIST
8086: LIST
8087: PUSH
8088: LD_INT 1
8090: PPUSH
8091: LD_INT 3
8093: PPUSH
8094: CALL_OW 12
8098: ARRAY
8099: PPUSH
8100: LD_INT 0
8102: PPUSH
8103: CALL_OW 380
// hc_agressivity = 0 ;
8107: LD_ADDR_OWVAR 35
8111: PUSH
8112: LD_INT 0
8114: ST_TO_ADDR
// animal = CreateHuman ;
8115: LD_ADDR_VAR 0 8
8119: PUSH
8120: CALL_OW 44
8124: ST_TO_ADDR
// PlaceUnitArea ( animal , NatureArea , false ) ;
8125: LD_VAR 0 8
8129: PPUSH
8130: LD_INT 5
8132: PPUSH
8133: LD_INT 0
8135: PPUSH
8136: CALL_OW 49
// animals = animals ^ animal ;
8140: LD_ADDR_VAR 0 7
8144: PUSH
8145: LD_VAR 0 7
8149: PUSH
8150: LD_VAR 0 8
8154: ADD
8155: ST_TO_ADDR
// end ;
8156: GO 8052
8158: POP
8159: POP
// for i := 1 to animals do
8160: LD_ADDR_VAR 0 3
8164: PUSH
8165: DOUBLE
8166: LD_INT 1
8168: DEC
8169: ST_TO_ADDR
8170: LD_VAR 0 7
8174: PUSH
8175: FOR_TO
8176: IFFALSE 8200
// AddComAttackUnit ( hunter , animals [ i ] ) ;
8178: LD_VAR 0 1
8182: PPUSH
8183: LD_VAR 0 7
8187: PUSH
8188: LD_VAR 0 3
8192: ARRAY
8193: PPUSH
8194: CALL_OW 175
8198: GO 8175
8200: POP
8201: POP
// repeat wait ( 0 0$1 ) ;
8202: LD_INT 35
8204: PPUSH
8205: CALL_OW 67
// if GetClass ( hunter ) = class_soldier then
8209: LD_VAR 0 1
8213: PPUSH
8214: CALL_OW 257
8218: PUSH
8219: LD_INT 1
8221: EQUAL
8222: IFFALSE 8269
// begin if GetDistUnits ( hunter , WantsToAttack ( hunter ) ) < 13 then
8224: LD_VAR 0 1
8228: PPUSH
8229: LD_VAR 0 1
8233: PPUSH
8234: CALL_OW 319
8238: PPUSH
8239: CALL_OW 296
8243: PUSH
8244: LD_INT 13
8246: LESS
8247: IFFALSE 8260
// ComCrawl ( hunter ) else
8249: LD_VAR 0 1
8253: PPUSH
8254: CALL_OW 137
8258: GO 8269
// ComWalk ( hunter ) ;
8260: LD_VAR 0 1
8264: PPUSH
8265: CALL_OW 138
// end ; until not HasTask ( hunter ) ;
8269: LD_VAR 0 1
8273: PPUSH
8274: CALL_OW 314
8278: NOT
8279: IFFALSE 8202
// repeat wait ( 0 0$1 ) ;
8281: LD_INT 35
8283: PPUSH
8284: CALL_OW 67
// ComMoveXY ( hunter , GetX ( Burlak ) , GetY ( Burlak ) ) ;
8288: LD_VAR 0 1
8292: PPUSH
8293: LD_EXP 57
8297: PPUSH
8298: CALL_OW 250
8302: PPUSH
8303: LD_EXP 57
8307: PPUSH
8308: CALL_OW 251
8312: PPUSH
8313: CALL_OW 111
// until GetDistUnits ( hunter , Burlak ) <= 9 ;
8317: LD_VAR 0 1
8321: PPUSH
8322: LD_EXP 57
8326: PPUSH
8327: CALL_OW 296
8331: PUSH
8332: LD_INT 9
8334: LESSEQUAL
8335: IFFALSE 8281
// SetSide ( hunter , 3 ) ;
8337: LD_VAR 0 1
8341: PPUSH
8342: LD_INT 3
8344: PPUSH
8345: CALL_OW 235
// CenterOnUnits ( hunter ) ;
8349: LD_VAR 0 1
8353: PPUSH
8354: CALL_OW 85
// AddExperience ( hunter , skill_combat , 3000 ) ;
8358: LD_VAR 0 1
8362: PPUSH
8363: LD_INT 1
8365: PPUSH
8366: LD_INT 3000
8368: PPUSH
8369: CALL_OW 492
// end ;
8373: LD_VAR 0 2
8377: RET
// export function SetMashaData ( vehicle ) ; begin
8378: LD_INT 0
8380: PPUSH
// if Masha then
8381: LD_EXP 4
8385: IFFALSE 8403
// SetMark ( Masha [ 1 ] , 0 ) ;
8387: LD_EXP 4
8391: PUSH
8392: LD_INT 1
8394: ARRAY
8395: PPUSH
8396: LD_INT 0
8398: PPUSH
8399: CALL_OW 242
// Masha = [ vehicle , GetChassis ( vehicle ) , GetEngine ( vehicle ) , GetControl ( vehicle ) , GetWeapon ( vehicle ) ] ;
8403: LD_ADDR_EXP 4
8407: PUSH
8408: LD_VAR 0 1
8412: PUSH
8413: LD_VAR 0 1
8417: PPUSH
8418: CALL_OW 265
8422: PUSH
8423: LD_VAR 0 1
8427: PPUSH
8428: CALL_OW 262
8432: PUSH
8433: LD_VAR 0 1
8437: PPUSH
8438: CALL_OW 263
8442: PUSH
8443: LD_VAR 0 1
8447: PPUSH
8448: CALL_OW 264
8452: PUSH
8453: EMPTY
8454: LIST
8455: LIST
8456: LIST
8457: LIST
8458: LIST
8459: ST_TO_ADDR
// ChangeMissionObjectives ( MMashaDone ) ;
8460: LD_STRING MMashaDone
8462: PPUSH
8463: CALL_OW 337
// SetMark ( vehicle , 1 ) ;
8467: LD_VAR 0 1
8471: PPUSH
8472: LD_INT 1
8474: PPUSH
8475: CALL_OW 242
// end ;
8479: LD_VAR 0 2
8483: RET
// export function SaveBase ( buildings , ident ) ; var i , buildingsToSave ; begin
8484: LD_INT 0
8486: PPUSH
8487: PPUSH
8488: PPUSH
// buildingsToSave = [ ] ;
8489: LD_ADDR_VAR 0 5
8493: PUSH
8494: EMPTY
8495: ST_TO_ADDR
// if not buildings then
8496: LD_VAR 0 1
8500: NOT
8501: IFFALSE 8505
// exit ;
8503: GO 9080
// for i in buildings do
8505: LD_ADDR_VAR 0 4
8509: PUSH
8510: LD_VAR 0 1
8514: PUSH
8515: FOR_IN
8516: IFFALSE 9064
// begin if GetBType ( i ) in [ b_lab , b_lab_half , b_lab_full ] then
8518: LD_VAR 0 4
8522: PPUSH
8523: CALL_OW 266
8527: PUSH
8528: LD_INT 6
8530: PUSH
8531: LD_INT 7
8533: PUSH
8534: LD_INT 8
8536: PUSH
8537: EMPTY
8538: LIST
8539: LIST
8540: LIST
8541: IN
8542: IFFALSE 8667
// buildingsToSave = buildingsToSave ^ [ [ GetBType ( i ) , GetX ( i ) , GetY ( i ) , GetDir ( i ) , GetBLevel ( i ) , GetNation ( i ) , GetLives ( i ) , GetLabKind ( i , 1 ) , GetLabKind ( i , 2 ) ] ] else
8544: LD_ADDR_VAR 0 5
8548: PUSH
8549: LD_VAR 0 5
8553: PUSH
8554: LD_VAR 0 4
8558: PPUSH
8559: CALL_OW 266
8563: PUSH
8564: LD_VAR 0 4
8568: PPUSH
8569: CALL_OW 250
8573: PUSH
8574: LD_VAR 0 4
8578: PPUSH
8579: CALL_OW 251
8583: PUSH
8584: LD_VAR 0 4
8588: PPUSH
8589: CALL_OW 254
8593: PUSH
8594: LD_VAR 0 4
8598: PPUSH
8599: CALL_OW 267
8603: PUSH
8604: LD_VAR 0 4
8608: PPUSH
8609: CALL_OW 248
8613: PUSH
8614: LD_VAR 0 4
8618: PPUSH
8619: CALL_OW 256
8623: PUSH
8624: LD_VAR 0 4
8628: PPUSH
8629: LD_INT 1
8631: PPUSH
8632: CALL_OW 268
8636: PUSH
8637: LD_VAR 0 4
8641: PPUSH
8642: LD_INT 2
8644: PPUSH
8645: CALL_OW 268
8649: PUSH
8650: EMPTY
8651: LIST
8652: LIST
8653: LIST
8654: LIST
8655: LIST
8656: LIST
8657: LIST
8658: LIST
8659: LIST
8660: PUSH
8661: EMPTY
8662: LIST
8663: ADD
8664: ST_TO_ADDR
8665: GO 9062
// if GetBType ( i ) in [ b_bunker , b_turret ] then
8667: LD_VAR 0 4
8671: PPUSH
8672: CALL_OW 266
8676: PUSH
8677: LD_INT 32
8679: PUSH
8680: LD_INT 33
8682: PUSH
8683: EMPTY
8684: LIST
8685: LIST
8686: IN
8687: IFFALSE 8795
// buildingsToSave = buildingsToSave ^ [ [ GetBType ( i ) , GetX ( i ) , GetY ( i ) , GetDir ( i ) , GetBLevel ( i ) , GetNation ( i ) , GetLives ( i ) , GetBWeapon ( i ) ] ] else
8689: LD_ADDR_VAR 0 5
8693: PUSH
8694: LD_VAR 0 5
8698: PUSH
8699: LD_VAR 0 4
8703: PPUSH
8704: CALL_OW 266
8708: PUSH
8709: LD_VAR 0 4
8713: PPUSH
8714: CALL_OW 250
8718: PUSH
8719: LD_VAR 0 4
8723: PPUSH
8724: CALL_OW 251
8728: PUSH
8729: LD_VAR 0 4
8733: PPUSH
8734: CALL_OW 254
8738: PUSH
8739: LD_VAR 0 4
8743: PPUSH
8744: CALL_OW 267
8748: PUSH
8749: LD_VAR 0 4
8753: PPUSH
8754: CALL_OW 248
8758: PUSH
8759: LD_VAR 0 4
8763: PPUSH
8764: CALL_OW 256
8768: PUSH
8769: LD_VAR 0 4
8773: PPUSH
8774: CALL_OW 269
8778: PUSH
8779: EMPTY
8780: LIST
8781: LIST
8782: LIST
8783: LIST
8784: LIST
8785: LIST
8786: LIST
8787: LIST
8788: PUSH
8789: EMPTY
8790: LIST
8791: ADD
8792: ST_TO_ADDR
8793: GO 9062
// if GetBType ( i ) in [ b_depot , b_warehouse ] then
8795: LD_VAR 0 4
8799: PPUSH
8800: CALL_OW 266
8804: PUSH
8805: LD_INT 0
8807: PUSH
8808: LD_INT 1
8810: PUSH
8811: EMPTY
8812: LIST
8813: LIST
8814: IN
8815: IFFALSE 8969
// buildingsToSave = buildingsToSave ^ [ [ GetBType ( i ) , GetX ( i ) , GetY ( i ) , GetDir ( i ) , GetBLevel ( i ) , GetNation ( i ) , GetLives ( i ) , GetResourceType ( GetBase ( i ) , mat_cans ) , GetResourceType ( GetBase ( i ) , mat_oil ) , GetResourceType ( GetBase ( i ) , mat_siberit ) ] ] else
8817: LD_ADDR_VAR 0 5
8821: PUSH
8822: LD_VAR 0 5
8826: PUSH
8827: LD_VAR 0 4
8831: PPUSH
8832: CALL_OW 266
8836: PUSH
8837: LD_VAR 0 4
8841: PPUSH
8842: CALL_OW 250
8846: PUSH
8847: LD_VAR 0 4
8851: PPUSH
8852: CALL_OW 251
8856: PUSH
8857: LD_VAR 0 4
8861: PPUSH
8862: CALL_OW 254
8866: PUSH
8867: LD_VAR 0 4
8871: PPUSH
8872: CALL_OW 267
8876: PUSH
8877: LD_VAR 0 4
8881: PPUSH
8882: CALL_OW 248
8886: PUSH
8887: LD_VAR 0 4
8891: PPUSH
8892: CALL_OW 256
8896: PUSH
8897: LD_VAR 0 4
8901: PPUSH
8902: CALL_OW 274
8906: PPUSH
8907: LD_INT 1
8909: PPUSH
8910: CALL_OW 275
8914: PUSH
8915: LD_VAR 0 4
8919: PPUSH
8920: CALL_OW 274
8924: PPUSH
8925: LD_INT 2
8927: PPUSH
8928: CALL_OW 275
8932: PUSH
8933: LD_VAR 0 4
8937: PPUSH
8938: CALL_OW 274
8942: PPUSH
8943: LD_INT 3
8945: PPUSH
8946: CALL_OW 275
8950: PUSH
8951: EMPTY
8952: LIST
8953: LIST
8954: LIST
8955: LIST
8956: LIST
8957: LIST
8958: LIST
8959: LIST
8960: LIST
8961: LIST
8962: PUSH
8963: EMPTY
8964: LIST
8965: ADD
8966: ST_TO_ADDR
8967: GO 9062
// buildingsToSave = buildingsToSave ^ [ [ GetBType ( i ) , GetX ( i ) , GetY ( i ) , GetDir ( i ) , GetBLevel ( i ) , GetNation ( i ) , GetLives ( i ) ] ] ;
8969: LD_ADDR_VAR 0 5
8973: PUSH
8974: LD_VAR 0 5
8978: PUSH
8979: LD_VAR 0 4
8983: PPUSH
8984: CALL_OW 266
8988: PUSH
8989: LD_VAR 0 4
8993: PPUSH
8994: CALL_OW 250
8998: PUSH
8999: LD_VAR 0 4
9003: PPUSH
9004: CALL_OW 251
9008: PUSH
9009: LD_VAR 0 4
9013: PPUSH
9014: CALL_OW 254
9018: PUSH
9019: LD_VAR 0 4
9023: PPUSH
9024: CALL_OW 267
9028: PUSH
9029: LD_VAR 0 4
9033: PPUSH
9034: CALL_OW 248
9038: PUSH
9039: LD_VAR 0 4
9043: PPUSH
9044: CALL_OW 256
9048: PUSH
9049: EMPTY
9050: LIST
9051: LIST
9052: LIST
9053: LIST
9054: LIST
9055: LIST
9056: LIST
9057: PUSH
9058: EMPTY
9059: LIST
9060: ADD
9061: ST_TO_ADDR
// end ;
9062: GO 8515
9064: POP
9065: POP
// SaveVariable ( buildingsToSave , ident ) ;
9066: LD_VAR 0 5
9070: PPUSH
9071: LD_VAR 0 2
9075: PPUSH
9076: CALL_OW 39
// end ; end_of_file
9080: LD_VAR 0 3
9084: RET
// export function MissionIntro ; begin
9085: LD_INT 0
9087: PPUSH
// CenterNowOnUnits ( Burlak ) ;
9088: LD_EXP 57
9092: PPUSH
9093: CALL_OW 87
// DialogueOn ;
9097: CALL_OW 6
// SayRadio ( Popov , DStart-Pop-1 ) ;
9101: LD_EXP 76
9105: PPUSH
9106: LD_STRING DStart-Pop-1
9108: PPUSH
9109: CALL_OW 94
// Say ( Burlak , DStart-Bur-1 ) ;
9113: LD_EXP 57
9117: PPUSH
9118: LD_STRING DStart-Bur-1
9120: PPUSH
9121: CALL_OW 88
// DialogueOff ;
9125: CALL_OW 7
// IngameOff ;
9129: CALL_OW 9
// ChangeMissionObjectives ( MStart ) ;
9133: LD_STRING MStart
9135: PPUSH
9136: CALL_OW 337
// SaveForQuickRestart ;
9140: CALL_OW 22
// end ;
9144: LD_VAR 0 1
9148: RET
// export function Dial_EscortHeike ( x , y ) ; begin
9149: LD_INT 0
9151: PPUSH
// dial_BuildDepotBlocker = true ;
9152: LD_ADDR_EXP 5
9156: PUSH
9157: LD_INT 1
9159: ST_TO_ADDR
// HeikeTargetX = x ;
9160: LD_ADDR_EXP 14
9164: PUSH
9165: LD_VAR 0 1
9169: ST_TO_ADDR
// HeikeTargetY = y ;
9170: LD_ADDR_EXP 15
9174: PUSH
9175: LD_VAR 0 2
9179: ST_TO_ADDR
// SayRadio ( Popov , DHeike-Pop-1 ) ;
9180: LD_EXP 76
9184: PPUSH
9185: LD_STRING DHeike-Pop-1
9187: PPUSH
9188: CALL_OW 94
// wait ( 0 0$10 ) ;
9192: LD_INT 350
9194: PPUSH
9195: CALL_OW 67
// PrepareRussianEscort ;
9199: CALL 2320 0 0
// PlaceUnitArea ( Heike , RussianSpawn2Area , false ) ;
9203: LD_EXP 79
9207: PPUSH
9208: LD_INT 7
9210: PPUSH
9211: LD_INT 0
9213: PPUSH
9214: CALL_OW 49
// ComMoveXY ( russianEscort , HeikeTargetX , HeikeTargetY ) ;
9218: LD_EXP 77
9222: PPUSH
9223: LD_EXP 14
9227: PPUSH
9228: LD_EXP 15
9232: PPUSH
9233: CALL_OW 111
// AddComMoveToArea ( russianEscort , RussianSpawn2Area ) ;
9237: LD_EXP 77
9241: PPUSH
9242: LD_INT 7
9244: PPUSH
9245: CALL_OW 173
// ComMoveXY ( Heike , HeikeTargetX , HeikeTargetY ) ;
9249: LD_EXP 79
9253: PPUSH
9254: LD_EXP 14
9258: PPUSH
9259: LD_EXP 15
9263: PPUSH
9264: CALL_OW 111
// AddComHold ( Heike ) ;
9268: LD_EXP 79
9272: PPUSH
9273: CALL_OW 200
// end ;
9277: LD_VAR 0 3
9281: RET
// every 1 trigger GetDistUnitXY ( Heike , HeikeTargetX , HeikeTargetY ) <= 5 do
9282: LD_EXP 79
9286: PPUSH
9287: LD_EXP 14
9291: PPUSH
9292: LD_EXP 15
9296: PPUSH
9297: CALL_OW 297
9301: PUSH
9302: LD_INT 5
9304: LESSEQUAL
9305: IFFALSE 9318
9307: GO 9309
9309: DISABLE
// allowExitFromMap = 1 ;
9310: LD_ADDR_EXP 18
9314: PUSH
9315: LD_INT 1
9317: ST_TO_ADDR
9318: END
// every 7 7$0 trigger IsPlaced ( Heike ) and IsOk ( Heike ) and GetAttitude ( 3 , 5 ) = att_friend and HeikeCaptured do
9319: LD_EXP 79
9323: PPUSH
9324: CALL_OW 305
9328: PUSH
9329: LD_EXP 79
9333: PPUSH
9334: CALL_OW 302
9338: AND
9339: PUSH
9340: LD_INT 3
9342: PPUSH
9343: LD_INT 5
9345: PPUSH
9346: CALL_OW 81
9350: PUSH
9351: LD_INT 1
9353: EQUAL
9354: AND
9355: PUSH
9356: LD_EXP 1
9360: AND
9361: IFFALSE 9580
9363: GO 9365
9365: DISABLE
// begin DialogueOn ;
9366: CALL_OW 6
// SayRadio ( Kurt , DMercHelp-Kurt-1 ) ;
9370: LD_EXP 80
9374: PPUSH
9375: LD_STRING DMercHelp-Kurt-1
9377: PPUSH
9378: CALL_OW 94
// Say ( Burlak , DMercHelp-Bur-1 ) ;
9382: LD_EXP 57
9386: PPUSH
9387: LD_STRING DMercHelp-Bur-1
9389: PPUSH
9390: CALL_OW 88
// SayRadio ( Kurt , DMercHelp-Kurt-2 ) ;
9394: LD_EXP 80
9398: PPUSH
9399: LD_STRING DMercHelp-Kurt-2
9401: PPUSH
9402: CALL_OW 94
// Say ( Burlak , DMercHelp-Bur-2 ) ;
9406: LD_EXP 57
9410: PPUSH
9411: LD_STRING DMercHelp-Bur-2
9413: PPUSH
9414: CALL_OW 88
// SayRadio ( Kurt , DMercHelp-Kurt-3 ) ;
9418: LD_EXP 80
9422: PPUSH
9423: LD_STRING DMercHelp-Kurt-3
9425: PPUSH
9426: CALL_OW 94
// case Query ( QMerc ) of 1 :
9430: LD_STRING QMerc
9432: PPUSH
9433: CALL_OW 97
9437: PUSH
9438: LD_INT 1
9440: DOUBLE
9441: EQUAL
9442: IFTRUE 9446
9444: GO 9481
9446: POP
// begin Say ( Burlak , DQrMerc#1-Bur-1 ) ;
9447: LD_EXP 57
9451: PPUSH
9452: LD_STRING DQrMerc#1-Bur-1
9454: PPUSH
9455: CALL_OW 88
// SayRadio ( Kurt , DQrMerc#1-Kurt-1 ) ;
9459: LD_EXP 80
9463: PPUSH
9464: LD_STRING DQrMerc#1-Kurt-1
9466: PPUSH
9467: CALL_OW 94
// acceptKurtOffert = true ;
9471: LD_ADDR_EXP 19
9475: PUSH
9476: LD_INT 1
9478: ST_TO_ADDR
// end ; 2 :
9479: GO 9576
9481: LD_INT 2
9483: DOUBLE
9484: EQUAL
9485: IFTRUE 9489
9487: GO 9544
9489: POP
// begin askCommanders = true ;
9490: LD_ADDR_EXP 20
9494: PUSH
9495: LD_INT 1
9497: ST_TO_ADDR
// Say ( Burlak , DQrMerc#2-Bur-1 ) ;
9498: LD_EXP 57
9502: PPUSH
9503: LD_STRING DQrMerc#2-Bur-1
9505: PPUSH
9506: CALL_OW 88
// SayRadio ( Popov , DQrMerc#2-Pop-1 ) ;
9510: LD_EXP 76
9514: PPUSH
9515: LD_STRING DQrMerc#2-Pop-1
9517: PPUSH
9518: CALL_OW 94
// Say ( Burlak , DQrMerc#2-Bur-2 ) ;
9522: LD_EXP 57
9526: PPUSH
9527: LD_STRING DQrMerc#2-Bur-2
9529: PPUSH
9530: CALL_OW 88
// acceptKurtOffert = true ;
9534: LD_ADDR_EXP 19
9538: PUSH
9539: LD_INT 1
9541: ST_TO_ADDR
// end ; 3 :
9542: GO 9576
9544: LD_INT 3
9546: DOUBLE
9547: EQUAL
9548: IFTRUE 9552
9550: GO 9575
9552: POP
// begin Say ( Burlak , DQrMerc#3-Bur-1 ) ;
9553: LD_EXP 57
9557: PPUSH
9558: LD_STRING DQrMerc#3-Bur-1
9560: PPUSH
9561: CALL_OW 88
// KurtAttack = true ;
9565: LD_ADDR_EXP 25
9569: PUSH
9570: LD_INT 1
9572: ST_TO_ADDR
// end ; end ;
9573: GO 9576
9575: POP
// DialogueOff ;
9576: CALL_OW 7
// end ;
9580: END
// every 0 0$1 trigger acceptKurtOffert do
9581: LD_EXP 19
9585: IFFALSE 9741
9587: GO 9589
9589: DISABLE
// begin PlaceUnitArea ( Kurt , KurtSpawnArea , false ) ;
9590: LD_EXP 80
9594: PPUSH
9595: LD_INT 9
9597: PPUSH
9598: LD_INT 0
9600: PPUSH
9601: CALL_OW 49
// uc_side = 8 ;
9605: LD_ADDR_OWVAR 20
9609: PUSH
9610: LD_INT 8
9612: ST_TO_ADDR
// uc_nation = 2 ;
9613: LD_ADDR_OWVAR 21
9617: PUSH
9618: LD_INT 2
9620: ST_TO_ADDR
// PrepareEngineer ( false , 3 ) ;
9621: LD_INT 0
9623: PPUSH
9624: LD_INT 3
9626: PPUSH
9627: CALL_OW 382
// KurtEng = CreateHuman ;
9631: LD_ADDR_EXP 82
9635: PUSH
9636: CALL_OW 44
9640: ST_TO_ADDR
// PlaceUnitArea ( KurtEng , KurtSpawnArea , false ) ;
9641: LD_EXP 82
9645: PPUSH
9646: LD_INT 9
9648: PPUSH
9649: LD_INT 0
9651: PPUSH
9652: CALL_OW 49
// repeat wait ( 0 0$1 ) ;
9656: LD_INT 35
9658: PPUSH
9659: CALL_OW 67
// ComMoveXY ( [ Kurt , KurtEng ] , GetX ( Burlak ) , GetY ( Burlak ) ) ;
9663: LD_EXP 80
9667: PUSH
9668: LD_EXP 82
9672: PUSH
9673: EMPTY
9674: LIST
9675: LIST
9676: PPUSH
9677: LD_EXP 57
9681: PPUSH
9682: CALL_OW 250
9686: PPUSH
9687: LD_EXP 57
9691: PPUSH
9692: CALL_OW 251
9696: PPUSH
9697: CALL_OW 111
// until GetDistUnits ( Kurt , Burlak ) <= 5 or GetDistUnits ( KurtEng , Burlak ) <= 5 ;
9701: LD_EXP 80
9705: PPUSH
9706: LD_EXP 57
9710: PPUSH
9711: CALL_OW 296
9715: PUSH
9716: LD_INT 5
9718: LESSEQUAL
9719: PUSH
9720: LD_EXP 82
9724: PPUSH
9725: LD_EXP 57
9729: PPUSH
9730: CALL_OW 296
9734: PUSH
9735: LD_INT 5
9737: LESSEQUAL
9738: OR
9739: IFFALSE 9656
// end ;
9741: END
// every 0 0$1 trigger GetDistUnits ( Kurt , Burlak ) <= 5 or GetDistUnits ( KurtEng , Burlak ) <= 5 do
9742: LD_EXP 80
9746: PPUSH
9747: LD_EXP 57
9751: PPUSH
9752: CALL_OW 296
9756: PUSH
9757: LD_INT 5
9759: LESSEQUAL
9760: PUSH
9761: LD_EXP 82
9765: PPUSH
9766: LD_EXP 57
9770: PPUSH
9771: CALL_OW 296
9775: PUSH
9776: LD_INT 5
9778: LESSEQUAL
9779: OR
9780: IFFALSE 9959
9782: GO 9784
9784: DISABLE
// begin KurtWaitingForBuildBarrack = true ;
9785: LD_ADDR_EXP 24
9789: PUSH
9790: LD_INT 1
9792: ST_TO_ADDR
// SetSide ( KurtEng , 3 ) ;
9793: LD_EXP 82
9797: PPUSH
9798: LD_INT 3
9800: PPUSH
9801: CALL_OW 235
// wait ( 1 1$30 ) ;
9805: LD_INT 3150
9807: PPUSH
9808: CALL_OW 67
// DialogueOn ;
9812: CALL_OW 6
// SayRadio ( Dietrich , DArabianRequest-Diet-1 ) ;
9816: LD_EXP 81
9820: PPUSH
9821: LD_STRING DArabianRequest-Diet-1
9823: PPUSH
9824: CALL_OW 94
// Say ( Burlak , DArabianRequest-Bur-1 ) ;
9828: LD_EXP 57
9832: PPUSH
9833: LD_STRING DArabianRequest-Bur-1
9835: PPUSH
9836: CALL_OW 88
// SayRadio ( Dietrich , DArabianRequest-Diet-2 ) ;
9840: LD_EXP 81
9844: PPUSH
9845: LD_STRING DArabianRequest-Diet-2
9847: PPUSH
9848: CALL_OW 94
// DialogueOff ;
9852: CALL_OW 7
// case Query ( QHandOver ) of 1 :
9856: LD_STRING QHandOver
9858: PPUSH
9859: CALL_OW 97
9863: PUSH
9864: LD_INT 1
9866: DOUBLE
9867: EQUAL
9868: IFTRUE 9872
9870: GO 9911
9872: POP
// begin Say ( Burlak , DQrHandOver#1-Bur-1 ) ;
9873: LD_EXP 57
9877: PPUSH
9878: LD_STRING DQrHandOver#1-Bur-1
9880: PPUSH
9881: CALL_OW 88
// SayRadio ( Dietrich , DQrHandOver#1-Diet-1 ) ;
9885: LD_EXP 81
9889: PPUSH
9890: LD_STRING DQrHandOver#1-Diet-1
9892: PPUSH
9893: CALL_OW 94
// coopWithGensher = true ;
9897: LD_ADDR_EXP 2
9901: PUSH
9902: LD_INT 1
9904: ST_TO_ADDR
// SpawnGensherTeam ;
9905: CALL 3946 0 0
// end ; 2 :
9909: GO 9959
9911: LD_INT 2
9913: DOUBLE
9914: EQUAL
9915: IFTRUE 9919
9917: GO 9958
9919: POP
// begin Say ( Burlak , DQrHandOver#2-Bur-1 ) ;
9920: LD_EXP 57
9924: PPUSH
9925: LD_STRING DQrHandOver#2-Bur-1
9927: PPUSH
9928: CALL_OW 88
// SayRadio ( Dietrich , DQrHandOver#2-Diet-1 ) ;
9932: LD_EXP 81
9936: PPUSH
9937: LD_STRING DQrHandOver#2-Diet-1
9939: PPUSH
9940: CALL_OW 94
// Say ( Burlak , DQrHandOver#2-Bur-2 ) ;
9944: LD_EXP 57
9948: PPUSH
9949: LD_STRING DQrHandOver#2-Bur-2
9951: PPUSH
9952: CALL_OW 88
// end ; end ;
9956: GO 9959
9958: POP
// end ;
9959: END
// export function Dial_UpgradeArmoury ; begin
9960: LD_INT 0
9962: PPUSH
// dial_BuildArBarrackBlocker = true ;
9963: LD_ADDR_EXP 6
9967: PUSH
9968: LD_INT 1
9970: ST_TO_ADDR
// buildArabBarrack = true ;
9971: LD_ADDR_EXP 38
9975: PUSH
9976: LD_INT 1
9978: ST_TO_ADDR
// if GetSide ( Kurt ) = 2 or GetSide ( KurtEng ) = 8 then
9979: LD_EXP 80
9983: PPUSH
9984: CALL_OW 255
9988: PUSH
9989: LD_INT 2
9991: EQUAL
9992: PUSH
9993: LD_EXP 82
9997: PPUSH
9998: CALL_OW 255
10002: PUSH
10003: LD_INT 8
10005: EQUAL
10006: OR
10007: IFFALSE 10011
// exit ;
10009: GO 10111
// SetSide ( KurtEng , 8 ) ;
10011: LD_EXP 82
10015: PPUSH
10016: LD_INT 8
10018: PPUSH
10019: CALL_OW 235
// ComStop ( KurtEng ) ;
10023: LD_EXP 82
10027: PPUSH
10028: CALL_OW 141
// DialogueOn ;
10032: CALL_OW 6
// Say ( Kurt , DMercCompleted-Kurt-1 ) ;
10036: LD_EXP 80
10040: PPUSH
10041: LD_STRING DMercCompleted-Kurt-1
10043: PPUSH
10044: CALL_OW 88
// DialogueOff ;
10048: CALL_OW 7
// canSendHeike = true ;
10052: LD_ADDR_EXP 28
10056: PUSH
10057: LD_INT 1
10059: ST_TO_ADDR
// KurtWaitingForFreeHeike = true ;
10060: LD_ADDR_EXP 23
10064: PUSH
10065: LD_INT 1
10067: ST_TO_ADDR
// KurtWaitingForBuildBarrack = false ;
10068: LD_ADDR_EXP 24
10072: PUSH
10073: LD_INT 0
10075: ST_TO_ADDR
// allowExitFromMap = 3 ;
10076: LD_ADDR_EXP 18
10080: PUSH
10081: LD_INT 3
10083: ST_TO_ADDR
// if KurtCanEscape then
10084: LD_EXP 21
10088: IFFALSE 10111
// ComMoveToArea ( [ Kurt , KurtEng ] , KurtExitMapArea ) ;
10090: LD_EXP 80
10094: PUSH
10095: LD_EXP 82
10099: PUSH
10100: EMPTY
10101: LIST
10102: LIST
10103: PPUSH
10104: LD_INT 11
10106: PPUSH
10107: CALL_OW 113
// end ;
10111: LD_VAR 0 1
10115: RET
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 2 ] ] ) and not dial_ArriveGensherUnitsBlocker do var veh , nearGensherUnit , maleSold , waitForKurt ;
10116: LD_INT 22
10118: PUSH
10119: LD_INT 2
10121: PUSH
10122: EMPTY
10123: LIST
10124: LIST
10125: PUSH
10126: EMPTY
10127: LIST
10128: PPUSH
10129: CALL_OW 69
10133: PUSH
10134: LD_EXP 7
10138: NOT
10139: AND
10140: IFFALSE 10913
10142: GO 10144
10144: DISABLE
10145: LD_INT 0
10147: PPUSH
10148: PPUSH
10149: PPUSH
10150: PPUSH
// begin nearGensherUnit = NearestUnitToXY ( UnitFilter ( GensherTeam , [ [ f_type , unit_vehicle ] ] ) , GensherTargetX , GensherTargetY ) ;
10151: LD_ADDR_VAR 0 2
10155: PUSH
10156: LD_EXP 83
10160: PPUSH
10161: LD_INT 21
10163: PUSH
10164: LD_INT 2
10166: PUSH
10167: EMPTY
10168: LIST
10169: LIST
10170: PUSH
10171: EMPTY
10172: LIST
10173: PPUSH
10174: CALL_OW 72
10178: PPUSH
10179: LD_EXP 16
10183: PPUSH
10184: LD_EXP 17
10188: PPUSH
10189: CALL_OW 73
10193: ST_TO_ADDR
// maleSold = UnitsInside ( nearGensherUnit [ 1 ] ) ;
10194: LD_ADDR_VAR 0 3
10198: PUSH
10199: LD_VAR 0 2
10203: PUSH
10204: LD_INT 1
10206: ARRAY
10207: PPUSH
10208: CALL_OW 313
10212: ST_TO_ADDR
// if GetDistUnitXY ( nearGensherUnit , GensherTargetX , GensherTargetY ) <= 5 then
10213: LD_VAR 0 2
10217: PPUSH
10218: LD_EXP 16
10222: PPUSH
10223: LD_EXP 17
10227: PPUSH
10228: CALL_OW 297
10232: PUSH
10233: LD_INT 5
10235: LESSEQUAL
10236: IFFALSE 10912
// begin dial_ArriveGensherUnitsBlocker = true ;
10238: LD_ADDR_EXP 7
10242: PUSH
10243: LD_INT 1
10245: ST_TO_ADDR
// for veh in UnitFilter ( GensherTeam , [ [ f_type , unit_vehicle ] ] ) do
10246: LD_ADDR_VAR 0 1
10250: PUSH
10251: LD_EXP 83
10255: PPUSH
10256: LD_INT 21
10258: PUSH
10259: LD_INT 2
10261: PUSH
10262: EMPTY
10263: LIST
10264: LIST
10265: PUSH
10266: EMPTY
10267: LIST
10268: PPUSH
10269: CALL_OW 72
10273: PUSH
10274: FOR_IN
10275: IFFALSE 10297
// ComExitVehicle ( UnitsInside ( veh ) [ 1 ] ) ;
10277: LD_VAR 0 1
10281: PPUSH
10282: CALL_OW 313
10286: PUSH
10287: LD_INT 1
10289: ARRAY
10290: PPUSH
10291: CALL_OW 121
10295: GO 10274
10297: POP
10298: POP
// wait ( 0 0$1 ) ;
10299: LD_INT 35
10301: PPUSH
10302: CALL_OW 67
// SetSide ( UnitFilter ( GensherTeam , [ [ f_type , unit_vehicle ] ] ) , 3 ) ;
10306: LD_EXP 83
10310: PPUSH
10311: LD_INT 21
10313: PUSH
10314: LD_INT 2
10316: PUSH
10317: EMPTY
10318: LIST
10319: LIST
10320: PUSH
10321: EMPTY
10322: LIST
10323: PPUSH
10324: CALL_OW 72
10328: PPUSH
10329: LD_INT 3
10331: PPUSH
10332: CALL_OW 235
// CenterOnUnits ( maleSold ) ;
10336: LD_VAR 0 3
10340: PPUSH
10341: CALL_OW 85
// DialogueOn ;
10345: CALL_OW 6
// Say ( maleSold , DHandOverCome-ASol1-1 ) ;
10349: LD_VAR 0 3
10353: PPUSH
10354: LD_STRING DHandOverCome-ASol1-1
10356: PPUSH
10357: CALL_OW 88
// Say ( Kurt , DHandOverCome-Kurt-1 ) ;
10361: LD_EXP 80
10365: PPUSH
10366: LD_STRING DHandOverCome-Kurt-1
10368: PPUSH
10369: CALL_OW 88
// DialogueOff ;
10373: CALL_OW 7
// KurtWaitingForBuildBarrack = false ;
10377: LD_ADDR_EXP 24
10381: PUSH
10382: LD_INT 0
10384: ST_TO_ADDR
// if GetDistUnits ( Kurt , UnitFilter ( GensherTeam , [ f_type , unit_vehicle ] ) [ 1 ] ) <= 8 or GetSide ( KurtEng ) = 3 then
10385: LD_EXP 80
10389: PPUSH
10390: LD_EXP 83
10394: PPUSH
10395: LD_INT 21
10397: PUSH
10398: LD_INT 2
10400: PUSH
10401: EMPTY
10402: LIST
10403: LIST
10404: PPUSH
10405: CALL_OW 72
10409: PUSH
10410: LD_INT 1
10412: ARRAY
10413: PPUSH
10414: CALL_OW 296
10418: PUSH
10419: LD_INT 8
10421: LESSEQUAL
10422: PUSH
10423: LD_EXP 82
10427: PPUSH
10428: CALL_OW 255
10432: PUSH
10433: LD_INT 3
10435: EQUAL
10436: OR
10437: IFFALSE 10542
// begin KurtCanEscape = false ;
10439: LD_ADDR_EXP 21
10443: PUSH
10444: LD_INT 0
10446: ST_TO_ADDR
// SetSide ( [ Kurt , KurtEng ] , 2 ) ;
10447: LD_EXP 80
10451: PUSH
10452: LD_EXP 82
10456: PUSH
10457: EMPTY
10458: LIST
10459: LIST
10460: PPUSH
10461: LD_INT 2
10463: PPUSH
10464: CALL_OW 235
// ComStop ( [ Kurt , KurtEng ] ) ;
10468: LD_EXP 80
10472: PUSH
10473: LD_EXP 82
10477: PUSH
10478: EMPTY
10479: LIST
10480: LIST
10481: PPUSH
10482: CALL_OW 141
// ComMoveXY ( [ Kurt , KurtEng ] , GetX ( maleSold ) , GetY ( maleSold ) ) ;
10486: LD_EXP 80
10490: PUSH
10491: LD_EXP 82
10495: PUSH
10496: EMPTY
10497: LIST
10498: LIST
10499: PPUSH
10500: LD_VAR 0 3
10504: PPUSH
10505: CALL_OW 250
10509: PPUSH
10510: LD_VAR 0 3
10514: PPUSH
10515: CALL_OW 251
10519: PPUSH
10520: CALL_OW 111
// waitForKurt = true ;
10524: LD_ADDR_VAR 0 4
10528: PUSH
10529: LD_INT 1
10531: ST_TO_ADDR
// KurtStatus = 3 ;
10532: LD_ADDR_EXP 22
10536: PUSH
10537: LD_INT 3
10539: ST_TO_ADDR
// end else
10540: GO 10780
// if GetDistUnits ( Kurt , UnitFilter ( GensherTeam , [ f_type , unit_vehicle ] ) [ 1 ] ) > 8 then
10542: LD_EXP 80
10546: PPUSH
10547: LD_EXP 83
10551: PPUSH
10552: LD_INT 21
10554: PUSH
10555: LD_INT 2
10557: PUSH
10558: EMPTY
10559: LIST
10560: LIST
10561: PPUSH
10562: CALL_OW 72
10566: PUSH
10567: LD_INT 1
10569: ARRAY
10570: PPUSH
10571: CALL_OW 296
10575: PUSH
10576: LD_INT 8
10578: GREATER
10579: IFFALSE 10780
// begin allowExitFromMap = 4 ;
10581: LD_ADDR_EXP 18
10585: PUSH
10586: LD_INT 4
10588: ST_TO_ADDR
// KurtStatus = 2 ;
10589: LD_ADDR_EXP 22
10593: PUSH
10594: LD_INT 2
10596: ST_TO_ADDR
// ComMoveToArea ( [ Kurt , KurtEng ] , KurtExitMapArea ) ;
10597: LD_EXP 80
10601: PUSH
10602: LD_EXP 82
10606: PUSH
10607: EMPTY
10608: LIST
10609: LIST
10610: PPUSH
10611: LD_INT 11
10613: PPUSH
10614: CALL_OW 113
// repeat ComAttackUnit ( UnitFilter ( GensherTeam , [ [ f_type , unit_human ] ] ) , Kurt ) ;
10618: LD_EXP 83
10622: PPUSH
10623: LD_INT 21
10625: PUSH
10626: LD_INT 1
10628: PUSH
10629: EMPTY
10630: LIST
10631: LIST
10632: PUSH
10633: EMPTY
10634: LIST
10635: PPUSH
10636: CALL_OW 72
10640: PPUSH
10641: LD_EXP 80
10645: PPUSH
10646: CALL_OW 115
// wait ( 0 0$1 ) ;
10650: LD_INT 35
10652: PPUSH
10653: CALL_OW 67
// until GetDistUnits ( NearestUnitToUnit ( UnitFilter ( GensherTeam , [ [ f_type , unit_human ] ] ) , Kurt ) , Kurt ) <= 9 or ( not IsPlaced ( Kurt ) and not IsPlaced ( KurtEng ) ) ;
10657: LD_EXP 83
10661: PPUSH
10662: LD_INT 21
10664: PUSH
10665: LD_INT 1
10667: PUSH
10668: EMPTY
10669: LIST
10670: LIST
10671: PUSH
10672: EMPTY
10673: LIST
10674: PPUSH
10675: CALL_OW 72
10679: PPUSH
10680: LD_EXP 80
10684: PPUSH
10685: CALL_OW 74
10689: PPUSH
10690: LD_EXP 80
10694: PPUSH
10695: CALL_OW 296
10699: PUSH
10700: LD_INT 9
10702: LESSEQUAL
10703: PUSH
10704: LD_EXP 80
10708: PPUSH
10709: CALL_OW 305
10713: NOT
10714: PUSH
10715: LD_EXP 82
10719: PPUSH
10720: CALL_OW 305
10724: NOT
10725: AND
10726: OR
10727: IFFALSE 10618
// ComMoveToArea ( [ Kurt , KurtEng ] , ExitMapArea ) ;
10729: LD_EXP 80
10733: PUSH
10734: LD_EXP 82
10738: PUSH
10739: EMPTY
10740: LIST
10741: LIST
10742: PPUSH
10743: LD_INT 8
10745: PPUSH
10746: CALL_OW 113
// ComMoveToArea ( UnitFilter ( GensherTeam , [ [ f_type , unit_human ] ] ) , ExitMapArea ) ;
10750: LD_EXP 83
10754: PPUSH
10755: LD_INT 21
10757: PUSH
10758: LD_INT 1
10760: PUSH
10761: EMPTY
10762: LIST
10763: LIST
10764: PUSH
10765: EMPTY
10766: LIST
10767: PPUSH
10768: CALL_OW 72
10772: PPUSH
10773: LD_INT 8
10775: PPUSH
10776: CALL_OW 113
// end ; if waitForKurt then
10780: LD_VAR 0 4
10784: IFFALSE 10910
// begin repeat wait ( 0 0$1 ) ;
10786: LD_INT 35
10788: PPUSH
10789: CALL_OW 67
// ComMoveXY ( [ Kurt , KurtEng ] , GetX ( maleSold ) , GetY ( maleSold ) ) ;
10793: LD_EXP 80
10797: PUSH
10798: LD_EXP 82
10802: PUSH
10803: EMPTY
10804: LIST
10805: LIST
10806: PPUSH
10807: LD_VAR 0 3
10811: PPUSH
10812: CALL_OW 250
10816: PPUSH
10817: LD_VAR 0 3
10821: PPUSH
10822: CALL_OW 251
10826: PPUSH
10827: CALL_OW 111
// until GetDistUnits ( Kurt , maleSold ) <= 2 ;
10831: LD_EXP 80
10835: PPUSH
10836: LD_VAR 0 3
10840: PPUSH
10841: CALL_OW 296
10845: PUSH
10846: LD_INT 2
10848: LESSEQUAL
10849: IFFALSE 10786
// allowExitFromMap = 4 ;
10851: LD_ADDR_EXP 18
10855: PUSH
10856: LD_INT 4
10858: ST_TO_ADDR
// ComMoveToArea ( [ Kurt , KurtEng ] , ExitMapArea ) ;
10859: LD_EXP 80
10863: PUSH
10864: LD_EXP 82
10868: PUSH
10869: EMPTY
10870: LIST
10871: LIST
10872: PPUSH
10873: LD_INT 8
10875: PPUSH
10876: CALL_OW 113
// ComMoveToArea ( UnitFilter ( GensherTeam , [ [ f_type , unit_human ] ] ) , ExitMapArea ) ;
10880: LD_EXP 83
10884: PPUSH
10885: LD_INT 21
10887: PUSH
10888: LD_INT 1
10890: PUSH
10891: EMPTY
10892: LIST
10893: LIST
10894: PUSH
10895: EMPTY
10896: LIST
10897: PPUSH
10898: CALL_OW 72
10902: PPUSH
10903: LD_INT 8
10905: PPUSH
10906: CALL_OW 113
// end ; exit ;
10910: GO 10913
// end ; enable ;
10912: ENABLE
// end ;
10913: PPOPN 4
10915: END
// export function Dial_AttackGensher ; var unit ; begin
10916: LD_INT 0
10918: PPUSH
10919: PPUSH
// DialogueOn ;
10920: CALL_OW 6
// SayRadio ( Dietrich , DHandOverSpoiled-Diet-1 ) ;
10924: LD_EXP 81
10928: PPUSH
10929: LD_STRING DHandOverSpoiled-Diet-1
10931: PPUSH
10932: CALL_OW 94
// DialogueOff ;
10936: CALL_OW 7
// SetAttitude ( 3 , 2 , att_enemy , true ) ;
10940: LD_INT 3
10942: PPUSH
10943: LD_INT 2
10945: PPUSH
10946: LD_INT 2
10948: PPUSH
10949: LD_INT 1
10951: PPUSH
10952: CALL_OW 80
// for unit in UnitFilter ( GensherTeam , [ [ f_type , unit_human ] ] ) do
10956: LD_ADDR_VAR 0 2
10960: PUSH
10961: LD_EXP 83
10965: PPUSH
10966: LD_INT 21
10968: PUSH
10969: LD_INT 1
10971: PUSH
10972: EMPTY
10973: LIST
10974: LIST
10975: PUSH
10976: EMPTY
10977: LIST
10978: PPUSH
10979: CALL_OW 72
10983: PUSH
10984: FOR_IN
10985: IFFALSE 11045
// begin if IsInUnit ( unit ) then
10987: LD_VAR 0 2
10991: PPUSH
10992: CALL_OW 310
10996: IFFALSE 11007
// ComExitVehicle ( unit ) ;
10998: LD_VAR 0 2
11002: PPUSH
11003: CALL_OW 121
// wait ( 0 0$01 ) ;
11007: LD_INT 35
11009: PPUSH
11010: CALL_OW 67
// AddComAgressiveMove ( unit , GetX ( Burlak ) , GetY ( Burlak ) ) ;
11014: LD_VAR 0 2
11018: PPUSH
11019: LD_EXP 57
11023: PPUSH
11024: CALL_OW 250
11028: PPUSH
11029: LD_EXP 57
11033: PPUSH
11034: CALL_OW 251
11038: PPUSH
11039: CALL_OW 174
// end ;
11043: GO 10984
11045: POP
11046: POP
// coopWithGensher = 2 ;
11047: LD_ADDR_EXP 2
11051: PUSH
11052: LD_INT 2
11054: ST_TO_ADDR
// end ;
11055: LD_VAR 0 1
11059: RET
// every 0 0$1 trigger canSendHeike and IsOK ( Heike ) and GetSide ( Heike ) = 5 do var legionSold ;
11060: LD_EXP 28
11064: PUSH
11065: LD_EXP 79
11069: PPUSH
11070: CALL_OW 302
11074: AND
11075: PUSH
11076: LD_EXP 79
11080: PPUSH
11081: CALL_OW 255
11085: PUSH
11086: LD_INT 5
11088: EQUAL
11089: AND
11090: IFFALSE 11410
11092: GO 11094
11094: DISABLE
11095: LD_INT 0
11097: PPUSH
// begin if IsSelected ( Heike ) then
11098: LD_EXP 79
11102: PPUSH
11103: CALL_OW 306
11107: IFFALSE 11402
// begin if Query ( QSendHeike ) = 1 then
11109: LD_STRING QSendHeike
11111: PPUSH
11112: CALL_OW 97
11116: PUSH
11117: LD_INT 1
11119: EQUAL
11120: IFFALSE 11402
// begin KurtWaitingForFreeHeike = false ;
11122: LD_ADDR_EXP 23
11126: PUSH
11127: LD_INT 0
11129: ST_TO_ADDR
// ComMoveXY ( Heike , 82 , 46 ) ;
11130: LD_EXP 79
11134: PPUSH
11135: LD_INT 82
11137: PPUSH
11138: LD_INT 46
11140: PPUSH
11141: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
11145: LD_INT 35
11147: PPUSH
11148: CALL_OW 67
// until GetDistUnitXY ( Heike , 82 , 46 ) <= 5 or IsDead ( Heike ) ;
11152: LD_EXP 79
11156: PPUSH
11157: LD_INT 82
11159: PPUSH
11160: LD_INT 46
11162: PPUSH
11163: CALL_OW 297
11167: PUSH
11168: LD_INT 5
11170: LESSEQUAL
11171: PUSH
11172: LD_EXP 79
11176: PPUSH
11177: CALL_OW 301
11181: OR
11182: IFFALSE 11145
// if not askCommanders then
11184: LD_EXP 20
11188: NOT
11189: IFFALSE 11235
// begin DialogueOn ;
11191: CALL_OW 6
// SayRadio ( Popov , DMercPopov-Pop-1 ) ;
11195: LD_EXP 76
11199: PPUSH
11200: LD_STRING DMercPopov-Pop-1
11202: PPUSH
11203: CALL_OW 94
// Say ( Burlak , DMercPopov-Bur-1 ) ;
11207: LD_EXP 57
11211: PPUSH
11212: LD_STRING DMercPopov-Bur-1
11214: PPUSH
11215: CALL_OW 88
// SayRadio ( Popov , DMercPopov-Pop-2 ) ;
11219: LD_EXP 76
11223: PPUSH
11224: LD_STRING DMercPopov-Pop-2
11226: PPUSH
11227: CALL_OW 94
// DialogueOff ;
11231: CALL_OW 7
// end ; uc_side = 8 ;
11235: LD_ADDR_OWVAR 20
11239: PUSH
11240: LD_INT 8
11242: ST_TO_ADDR
// uc_nation = 2 ;
11243: LD_ADDR_OWVAR 21
11247: PUSH
11248: LD_INT 2
11250: ST_TO_ADDR
// PrepareSoldier ( false , 6 ) ;
11251: LD_INT 0
11253: PPUSH
11254: LD_INT 6
11256: PPUSH
11257: CALL_OW 381
// legionSold = CreateHuman ;
11261: LD_ADDR_VAR 0 1
11265: PUSH
11266: CALL_OW 44
11270: ST_TO_ADDR
// PlaceUnitXYR ( legionSold , 26 , 48 , 4 , false ) ;
11271: LD_VAR 0 1
11275: PPUSH
11276: LD_INT 26
11278: PPUSH
11279: LD_INT 48
11281: PPUSH
11282: LD_INT 4
11284: PPUSH
11285: LD_INT 0
11287: PPUSH
11288: CALL_OW 50
// repeat wait ( 0 0$1 ) ;
11292: LD_INT 35
11294: PPUSH
11295: CALL_OW 67
// ComMoveXY ( legionSold , GetX ( Heike ) , GetY ( Heike ) ) ;
11299: LD_VAR 0 1
11303: PPUSH
11304: LD_EXP 79
11308: PPUSH
11309: CALL_OW 250
11313: PPUSH
11314: LD_EXP 79
11318: PPUSH
11319: CALL_OW 251
11323: PPUSH
11324: CALL_OW 111
// until GetDistUnits ( legionSold , Heike ) <= 5 or IsDead ( Heike ) ;
11328: LD_VAR 0 1
11332: PPUSH
11333: LD_EXP 79
11337: PPUSH
11338: CALL_OW 296
11342: PUSH
11343: LD_INT 5
11345: LESSEQUAL
11346: PUSH
11347: LD_EXP 79
11351: PPUSH
11352: CALL_OW 301
11356: OR
11357: IFFALSE 11292
// SetSide ( Heike , 8 ) ;
11359: LD_EXP 79
11363: PPUSH
11364: LD_INT 8
11366: PPUSH
11367: CALL_OW 235
// allowExitFromMap = 3 ;
11371: LD_ADDR_EXP 18
11375: PUSH
11376: LD_INT 3
11378: ST_TO_ADDR
// ComMoveToArea ( [ legionSold , Heike ] , KurtExitMapArea ) ;
11379: LD_VAR 0 1
11383: PUSH
11384: LD_EXP 79
11388: PUSH
11389: EMPTY
11390: LIST
11391: LIST
11392: PPUSH
11393: LD_INT 11
11395: PPUSH
11396: CALL_OW 113
// exit ;
11400: GO 11410
// end ; end ; wait ( 0 0$3 ) ;
11402: LD_INT 105
11404: PPUSH
11405: CALL_OW 67
// enable ;
11409: ENABLE
// end ;
11410: PPOPN 1
11412: END
// export function Dial_PlayerDontSendHeike ; begin
11413: LD_INT 0
11415: PPUSH
// DialogueOn ;
11416: CALL_OW 6
// SayRadio ( Kurt , DMercDeceived-Kurt-1 ) ;
11420: LD_EXP 80
11424: PPUSH
11425: LD_STRING DMercDeceived-Kurt-1
11427: PPUSH
11428: CALL_OW 94
// DialogueOff ;
11432: CALL_OW 7
// SetAttitude ( 3 , 8 , att_enemy , true ) ;
11436: LD_INT 3
11438: PPUSH
11439: LD_INT 8
11441: PPUSH
11442: LD_INT 2
11444: PPUSH
11445: LD_INT 1
11447: PPUSH
11448: CALL_OW 80
// KurtAttack = true ;
11452: LD_ADDR_EXP 25
11456: PUSH
11457: LD_INT 1
11459: ST_TO_ADDR
// end ;
11460: LD_VAR 0 1
11464: RET
// export function Dial_BetrayedKurt1 ; begin
11465: LD_INT 0
11467: PPUSH
// DialogueOn ;
11468: CALL_OW 6
// Say ( Kurt , DMercDeceived-Kurt-1 ) ;
11472: LD_EXP 80
11476: PPUSH
11477: LD_STRING DMercDeceived-Kurt-1
11479: PPUSH
11480: CALL_OW 88
// DialogueOff ;
11484: CALL_OW 7
// if IsPlaced ( Kurt ) then
11488: LD_EXP 80
11492: PPUSH
11493: CALL_OW 305
11497: IFFALSE 11546
// begin SetSide ( KurtEng , 8 ) ;
11499: LD_EXP 82
11503: PPUSH
11504: LD_INT 8
11506: PPUSH
11507: CALL_OW 235
// allowExitFromMap = 3 ;
11511: LD_ADDR_EXP 18
11515: PUSH
11516: LD_INT 3
11518: ST_TO_ADDR
// if KurtCanEscape then
11519: LD_EXP 21
11523: IFFALSE 11546
// ComMoveToArea ( [ Kurt , KurtEng ] , KurtExitMapArea ) ;
11525: LD_EXP 80
11529: PUSH
11530: LD_EXP 82
11534: PUSH
11535: EMPTY
11536: LIST
11537: LIST
11538: PPUSH
11539: LD_INT 11
11541: PPUSH
11542: CALL_OW 113
// end ; end ;
11546: LD_VAR 0 1
11550: RET
// export function Dial_BetrayedKurt2 ; begin
11551: LD_INT 0
11553: PPUSH
// DialogueOn ;
11554: CALL_OW 6
// Say ( Kurt , DMercAmbush-Kurt-1 ) ;
11558: LD_EXP 80
11562: PPUSH
11563: LD_STRING DMercAmbush-Kurt-1
11565: PPUSH
11566: CALL_OW 88
// DialogueOff ;
11570: CALL_OW 7
// if IsPlaced ( Kurt ) then
11574: LD_EXP 80
11578: PPUSH
11579: CALL_OW 305
11583: IFFALSE 11632
// begin SetSide ( KurtEng , 8 ) ;
11585: LD_EXP 82
11589: PPUSH
11590: LD_INT 8
11592: PPUSH
11593: CALL_OW 235
// allowExitFromMap = 3 ;
11597: LD_ADDR_EXP 18
11601: PUSH
11602: LD_INT 3
11604: ST_TO_ADDR
// if KurtCanEscape then
11605: LD_EXP 21
11609: IFFALSE 11632
// ComMoveToArea ( [ Kurt , KurtEng ] , KurtExitMapArea ) ;
11611: LD_EXP 80
11615: PUSH
11616: LD_EXP 82
11620: PUSH
11621: EMPTY
11622: LIST
11623: LIST
11624: PPUSH
11625: LD_INT 11
11627: PPUSH
11628: CALL_OW 113
// end ; end ;
11632: LD_VAR 0 1
11636: RET
// every 0 0$1 trigger GetSide ( KurtEng ) = 3 do var playerUnits , unit ;
11637: LD_EXP 82
11641: PPUSH
11642: CALL_OW 255
11646: PUSH
11647: LD_INT 3
11649: EQUAL
11650: IFFALSE 11797
11652: GO 11654
11654: DISABLE
11655: LD_INT 0
11657: PPUSH
11658: PPUSH
// begin playerUnits = FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
11659: LD_ADDR_VAR 0 1
11663: PUSH
11664: LD_INT 22
11666: PUSH
11667: LD_INT 3
11669: PUSH
11670: EMPTY
11671: LIST
11672: LIST
11673: PUSH
11674: LD_INT 2
11676: PUSH
11677: LD_INT 21
11679: PUSH
11680: LD_INT 1
11682: PUSH
11683: EMPTY
11684: LIST
11685: LIST
11686: PUSH
11687: LD_INT 21
11689: PUSH
11690: LD_INT 2
11692: PUSH
11693: EMPTY
11694: LIST
11695: LIST
11696: PUSH
11697: EMPTY
11698: LIST
11699: LIST
11700: LIST
11701: PUSH
11702: EMPTY
11703: LIST
11704: LIST
11705: PPUSH
11706: CALL_OW 69
11710: ST_TO_ADDR
// for unit in playerUnits do
11711: LD_ADDR_VAR 0 2
11715: PUSH
11716: LD_VAR 0 1
11720: PUSH
11721: FOR_IN
11722: IFFALSE 11751
// begin if WantsToAttack ( unit ) = KurtEng then
11724: LD_VAR 0 2
11728: PPUSH
11729: CALL_OW 319
11733: PUSH
11734: LD_EXP 82
11738: EQUAL
11739: IFFALSE 11749
// begin Dial_BetrayedKurt2 ;
11741: CALL 11551 0 0
// exit ;
11745: POP
11746: POP
11747: GO 11797
// end ; end ;
11749: GO 11721
11751: POP
11752: POP
// if ( IsDying ( KurtEng ) or IsDead ( KurtEng ) ) and GetSide ( KurtEng ) = 3 then
11753: LD_EXP 82
11757: PPUSH
11758: CALL_OW 303
11762: PUSH
11763: LD_EXP 82
11767: PPUSH
11768: CALL_OW 301
11772: OR
11773: PUSH
11774: LD_EXP 82
11778: PPUSH
11779: CALL_OW 255
11783: PUSH
11784: LD_INT 3
11786: EQUAL
11787: AND
11788: IFFALSE 11796
// begin Dial_BetrayedKurt2 ;
11790: CALL 11551 0 0
// exit ;
11794: GO 11797
// end ; enable ;
11796: ENABLE
// end ;
11797: PPOPN 2
11799: END
// every 0 0$1 trigger GetAttitude ( 3 , 8 ) = att_neutral and GetLives ( Kurt ) <= 999 do
11800: LD_INT 3
11802: PPUSH
11803: LD_INT 8
11805: PPUSH
11806: CALL_OW 81
11810: PUSH
11811: LD_INT 0
11813: EQUAL
11814: PUSH
11815: LD_EXP 80
11819: PPUSH
11820: CALL_OW 256
11824: PUSH
11825: LD_INT 999
11827: LESSEQUAL
11828: AND
11829: IFFALSE 11854
11831: GO 11833
11833: DISABLE
// begin Dial_BetrayedKurt1 ;
11834: CALL 11465 0 0
// SetAttitude ( 3 , 8 , att_enemy , true ) ;
11838: LD_INT 3
11840: PPUSH
11841: LD_INT 8
11843: PPUSH
11844: LD_INT 2
11846: PPUSH
11847: LD_INT 1
11849: PPUSH
11850: CALL_OW 80
// end ;
11854: END
// every 0 0$1 trigger buildingsToBuild <= 11 do
11855: LD_EXP 8
11859: PUSH
11860: LD_INT 11
11862: LESSEQUAL
11863: IFFALSE 12112
11865: GO 11867
11867: DISABLE
// begin if not IsOK ( Kuzmov ) and not IsOK ( Oblukov ) then
11868: LD_EXP 72
11872: PPUSH
11873: CALL_OW 302
11877: NOT
11878: PUSH
11879: LD_EXP 74
11883: PPUSH
11884: CALL_OW 302
11888: NOT
11889: AND
11890: IFFALSE 11894
// exit ;
11892: GO 12112
// DialogueOn ;
11894: CALL_OW 6
// if IsOK ( Kuzmov ) then
11898: LD_EXP 72
11902: PPUSH
11903: CALL_OW 302
11907: IFFALSE 11923
// Say ( Kuzmov , DFiringRange-Kuz-1 ) else
11909: LD_EXP 72
11913: PPUSH
11914: LD_STRING DFiringRange-Kuz-1
11916: PPUSH
11917: CALL_OW 88
11921: GO 11935
// Say ( Oblukov , DFiringRange-Obl-1 ) ;
11923: LD_EXP 74
11927: PPUSH
11928: LD_STRING DFiringRange-Obl-1
11930: PPUSH
11931: CALL_OW 88
// Say ( Burlak , DFiringRange-Bur-1 ) ;
11935: LD_EXP 57
11939: PPUSH
11940: LD_STRING DFiringRange-Bur-1
11942: PPUSH
11943: CALL_OW 88
// CenterOnXY ( 99 , 30 ) ;
11947: LD_INT 99
11949: PPUSH
11950: LD_INT 30
11952: PPUSH
11953: CALL_OW 84
// Wait ( 0 0$0.5 ) ;
11957: LD_INT 18
11959: PPUSH
11960: CALL_OW 67
// RevealFogArea ( 3 , ShootArea ) ;
11964: LD_INT 3
11966: PPUSH
11967: LD_INT 12
11969: PPUSH
11970: CALL_OW 332
// SetAreaMapShow ( ShootArea , 1 ) ;
11974: LD_INT 12
11976: PPUSH
11977: LD_INT 1
11979: PPUSH
11980: CALL_OW 424
// if IsOK ( Kuzmov ) then
11984: LD_EXP 72
11988: PPUSH
11989: CALL_OW 302
11993: IFFALSE 12009
// Say ( Kuzmov , DFiringRange-Kuz-2 ) else
11995: LD_EXP 72
11999: PPUSH
12000: LD_STRING DFiringRange-Kuz-2
12002: PPUSH
12003: CALL_OW 88
12007: GO 12021
// Say ( Oblukov , DFiringRange-Obl-2 ) ;
12009: LD_EXP 74
12013: PPUSH
12014: LD_STRING DFiringRange-Obl-2
12016: PPUSH
12017: CALL_OW 88
// case Query ( QShootingGallery ) of 1 :
12021: LD_STRING QShootingGallery
12023: PPUSH
12024: CALL_OW 97
12028: PUSH
12029: LD_INT 1
12031: DOUBLE
12032: EQUAL
12033: IFTRUE 12037
12035: GO 12074
12037: POP
// begin Say ( Burlak , DQrShootingGallery#1-Bur-1 ) ;
12038: LD_EXP 57
12042: PPUSH
12043: LD_STRING DQrShootingGallery#1-Bur-1
12045: PPUSH
12046: CALL_OW 88
// BurlakRespect = BurlakRespect + 1 ;
12050: LD_ADDR_EXP 30
12054: PUSH
12055: LD_EXP 30
12059: PUSH
12060: LD_INT 1
12062: PLUS
12063: ST_TO_ADDR
// canShootTrening = true ;
12064: LD_ADDR_EXP 29
12068: PUSH
12069: LD_INT 1
12071: ST_TO_ADDR
// end ; 2 :
12072: GO 12108
12074: LD_INT 2
12076: DOUBLE
12077: EQUAL
12078: IFTRUE 12082
12080: GO 12107
12082: POP
// begin Say ( Burlak , DQrShootingGallery#2-Bur-1 ) ;
12083: LD_EXP 57
12087: PPUSH
12088: LD_STRING DQrShootingGallery#2-Bur-1
12090: PPUSH
12091: CALL_OW 88
// SetAreaMapShow ( ShootArea , 0 ) ;
12095: LD_INT 12
12097: PPUSH
12098: LD_INT 0
12100: PPUSH
12101: CALL_OW 424
// end ; end ;
12105: GO 12108
12107: POP
// DialogueOff ;
12108: CALL_OW 7
// end ;
12112: END
// every 0 0$1 trigger canShootTrening do
12113: LD_EXP 29
12117: IFFALSE 12127
12119: GO 12121
12121: DISABLE
// begin enable ;
12122: ENABLE
// ShootTreningController ;
12123: CALL 7091 0 0
// end ;
12127: END
// every 0 0$1 trigger buildingsToBuild <= 7 do var hunters , hunter ;
12128: LD_EXP 8
12132: PUSH
12133: LD_INT 7
12135: LESSEQUAL
12136: IFFALSE 12526
12138: GO 12140
12140: DISABLE
12141: LD_INT 0
12143: PPUSH
12144: PPUSH
// begin hunters = [ ] ;
12145: LD_ADDR_VAR 0 1
12149: PUSH
12150: EMPTY
12151: ST_TO_ADDR
// if IsOK ( Belkov ) then
12152: LD_EXP 66
12156: PPUSH
12157: CALL_OW 302
12161: IFFALSE 12179
// hunters = hunters ^ Belkov ;
12163: LD_ADDR_VAR 0 1
12167: PUSH
12168: LD_VAR 0 1
12172: PUSH
12173: LD_EXP 66
12177: ADD
12178: ST_TO_ADDR
// if IsOK ( Karamazov ) then
12179: LD_EXP 58
12183: PPUSH
12184: CALL_OW 302
12188: IFFALSE 12206
// hunters = hunters ^ Karamazov ;
12190: LD_ADDR_VAR 0 1
12194: PUSH
12195: LD_VAR 0 1
12199: PUSH
12200: LD_EXP 58
12204: ADD
12205: ST_TO_ADDR
// if IsOK ( Kozlov ) then
12206: LD_EXP 73
12210: PPUSH
12211: CALL_OW 302
12215: IFFALSE 12233
// hunters = hunters ^ Kozlov ;
12217: LD_ADDR_VAR 0 1
12221: PUSH
12222: LD_VAR 0 1
12226: PUSH
12227: LD_EXP 73
12231: ADD
12232: ST_TO_ADDR
// if not hunters then
12233: LD_VAR 0 1
12237: NOT
12238: IFFALSE 12242
// exit ;
12240: GO 12526
// hunter = hunters [ Rand ( 1 , hunters ) ] ;
12242: LD_ADDR_VAR 0 2
12246: PUSH
12247: LD_VAR 0 1
12251: PUSH
12252: LD_INT 1
12254: PPUSH
12255: LD_VAR 0 1
12259: PPUSH
12260: CALL_OW 12
12264: ARRAY
12265: ST_TO_ADDR
// DialogueOn ;
12266: CALL_OW 6
// case hunter of Belkov :
12270: LD_VAR 0 2
12274: PUSH
12275: LD_EXP 66
12279: DOUBLE
12280: EQUAL
12281: IFTRUE 12285
12283: GO 12300
12285: POP
// Say ( Belkov , DHunting-Bel-1 ) ; Karamazov :
12286: LD_EXP 66
12290: PPUSH
12291: LD_STRING DHunting-Bel-1
12293: PPUSH
12294: CALL_OW 88
12298: GO 12351
12300: LD_EXP 58
12304: DOUBLE
12305: EQUAL
12306: IFTRUE 12310
12308: GO 12325
12310: POP
// Say ( Karamazov , DHunting-Kar-1 ) ; Kozlov :
12311: LD_EXP 58
12315: PPUSH
12316: LD_STRING DHunting-Kar-1
12318: PPUSH
12319: CALL_OW 88
12323: GO 12351
12325: LD_EXP 73
12329: DOUBLE
12330: EQUAL
12331: IFTRUE 12335
12333: GO 12350
12335: POP
// Say ( Kozlov , DHunting-Koz-1 ) ; end ;
12336: LD_EXP 73
12340: PPUSH
12341: LD_STRING DHunting-Koz-1
12343: PPUSH
12344: CALL_OW 88
12348: GO 12351
12350: POP
// Say ( Burlak , DHunting-Bur-1 ) ;
12351: LD_EXP 57
12355: PPUSH
12356: LD_STRING DHunting-Bur-1
12358: PPUSH
12359: CALL_OW 88
// case hunter of Belkov :
12363: LD_VAR 0 2
12367: PUSH
12368: LD_EXP 66
12372: DOUBLE
12373: EQUAL
12374: IFTRUE 12378
12376: GO 12393
12378: POP
// Say ( Belkov , DHunting-Bel-2 ) ; Karamazov :
12379: LD_EXP 66
12383: PPUSH
12384: LD_STRING DHunting-Bel-2
12386: PPUSH
12387: CALL_OW 88
12391: GO 12444
12393: LD_EXP 58
12397: DOUBLE
12398: EQUAL
12399: IFTRUE 12403
12401: GO 12418
12403: POP
// Say ( Karamazov , DHunting-Kar-2 ) ; Kozlov :
12404: LD_EXP 58
12408: PPUSH
12409: LD_STRING DHunting-Kar-2
12411: PPUSH
12412: CALL_OW 88
12416: GO 12444
12418: LD_EXP 73
12422: DOUBLE
12423: EQUAL
12424: IFTRUE 12428
12426: GO 12443
12428: POP
// Say ( Kozlov , DHunting-Koz-2 ) ; end ;
12429: LD_EXP 73
12433: PPUSH
12434: LD_STRING DHunting-Koz-2
12436: PPUSH
12437: CALL_OW 88
12441: GO 12444
12443: POP
// DialogueOff ;
12444: CALL_OW 7
// case Query ( QHunting ) of 1 :
12448: LD_STRING QHunting
12450: PPUSH
12451: CALL_OW 97
12455: PUSH
12456: LD_INT 1
12458: DOUBLE
12459: EQUAL
12460: IFTRUE 12464
12462: GO 12502
12464: POP
// begin Say ( Burlak , DQrHunting#1-Bur-1 ) ;
12465: LD_EXP 57
12469: PPUSH
12470: LD_STRING DQrHunting#1-Bur-1
12472: PPUSH
12473: CALL_OW 88
// BurlakRespect = BurlakRespect + 1 ;
12477: LD_ADDR_EXP 30
12481: PUSH
12482: LD_EXP 30
12486: PUSH
12487: LD_INT 1
12489: PLUS
12490: ST_TO_ADDR
// GoToHunt ( hunter ) ;
12491: LD_VAR 0 2
12495: PPUSH
12496: CALL 7719 0 1
// end ; 2 :
12500: GO 12526
12502: LD_INT 2
12504: DOUBLE
12505: EQUAL
12506: IFTRUE 12510
12508: GO 12525
12510: POP
// Say ( Burlak , DQrHunting#2-Bur-1 ) ; end ;
12511: LD_EXP 57
12515: PPUSH
12516: LD_STRING DQrHunting#2-Bur-1
12518: PPUSH
12519: CALL_OW 88
12523: GO 12526
12525: POP
// end ;
12526: PPOPN 2
12528: END
// every 0 0$1 trigger buildingsToBuild <= 3 do var unit , womans , men , woman , man , depots ;
12529: LD_EXP 8
12533: PUSH
12534: LD_INT 3
12536: LESSEQUAL
12537: IFFALSE 13524
12539: GO 12541
12541: DISABLE
12542: LD_INT 0
12544: PPUSH
12545: PPUSH
12546: PPUSH
12547: PPUSH
12548: PPUSH
12549: PPUSH
// begin womans = [ ] ;
12550: LD_ADDR_VAR 0 2
12554: PUSH
12555: EMPTY
12556: ST_TO_ADDR
// men = [ ] ;
12557: LD_ADDR_VAR 0 3
12561: PUSH
12562: EMPTY
12563: ST_TO_ADDR
// if IsOK ( Petrovova ) then
12564: LD_EXP 59
12568: PPUSH
12569: CALL_OW 302
12573: IFFALSE 12591
// womans = womans ^ Petrovova ;
12575: LD_ADDR_VAR 0 2
12579: PUSH
12580: LD_VAR 0 2
12584: PUSH
12585: LD_EXP 59
12589: ADD
12590: ST_TO_ADDR
// if IsOK ( Kirilenkova ) then
12591: LD_EXP 65
12595: PPUSH
12596: CALL_OW 302
12600: IFFALSE 12618
// womans = womans ^ Kirilenkova ;
12602: LD_ADDR_VAR 0 2
12606: PUSH
12607: LD_VAR 0 2
12611: PUSH
12612: LD_EXP 65
12616: ADD
12617: ST_TO_ADDR
// if IsOK ( Kapitsova ) then
12618: LD_EXP 75
12622: PPUSH
12623: CALL_OW 302
12627: IFFALSE 12645
// womans = womans ^ Kapitsova ;
12629: LD_ADDR_VAR 0 2
12633: PUSH
12634: LD_VAR 0 2
12638: PUSH
12639: LD_EXP 75
12643: ADD
12644: ST_TO_ADDR
// DialogueOn ;
12645: CALL_OW 6
// if womans then
12649: LD_VAR 0 2
12653: IFFALSE 12780
// begin case womans [ Rand ( 1 , womans ) ] of Petrovova :
12655: LD_VAR 0 2
12659: PUSH
12660: LD_INT 1
12662: PPUSH
12663: LD_VAR 0 2
12667: PPUSH
12668: CALL_OW 12
12672: ARRAY
12673: PUSH
12674: LD_EXP 59
12678: DOUBLE
12679: EQUAL
12680: IFTRUE 12684
12682: GO 12709
12684: POP
// begin Say ( Petrovova , DFreeTime-Ptr-1 ) ;
12685: LD_EXP 59
12689: PPUSH
12690: LD_STRING DFreeTime-Ptr-1
12692: PPUSH
12693: CALL_OW 88
// woman = Petrovova ;
12697: LD_ADDR_VAR 0 4
12701: PUSH
12702: LD_EXP 59
12706: ST_TO_ADDR
// end ; Kirilenkova :
12707: GO 12780
12709: LD_EXP 65
12713: DOUBLE
12714: EQUAL
12715: IFTRUE 12719
12717: GO 12744
12719: POP
// begin Say ( Kirilenkova , DFreeTime-Kir-1 ) ;
12720: LD_EXP 65
12724: PPUSH
12725: LD_STRING DFreeTime-Kir-1
12727: PPUSH
12728: CALL_OW 88
// woman = Kirilenkova ;
12732: LD_ADDR_VAR 0 4
12736: PUSH
12737: LD_EXP 65
12741: ST_TO_ADDR
// end ; Kapitsova :
12742: GO 12780
12744: LD_EXP 75
12748: DOUBLE
12749: EQUAL
12750: IFTRUE 12754
12752: GO 12779
12754: POP
// begin Say ( Kapitsova , DFreeTime-Kap-1 ) ;
12755: LD_EXP 75
12759: PPUSH
12760: LD_STRING DFreeTime-Kap-1
12762: PPUSH
12763: CALL_OW 88
// woman = Kapitsova ;
12767: LD_ADDR_VAR 0 4
12771: PUSH
12772: LD_EXP 75
12776: ST_TO_ADDR
// end ; end ;
12777: GO 12780
12779: POP
// end ; if IsOK ( Kuzmov ) then
12780: LD_EXP 72
12784: PPUSH
12785: CALL_OW 302
12789: IFFALSE 12807
// men = men ^ Kuzmov ;
12791: LD_ADDR_VAR 0 3
12795: PUSH
12796: LD_VAR 0 3
12800: PUSH
12801: LD_EXP 72
12805: ADD
12806: ST_TO_ADDR
// if IsOK ( Titov ) then
12807: LD_EXP 62
12811: PPUSH
12812: CALL_OW 302
12816: IFFALSE 12834
// men = men ^ Titov ;
12818: LD_ADDR_VAR 0 3
12822: PUSH
12823: LD_VAR 0 3
12827: PUSH
12828: LD_EXP 62
12832: ADD
12833: ST_TO_ADDR
// if IsOK ( Gnyevko ) then
12834: LD_EXP 69
12838: PPUSH
12839: CALL_OW 302
12843: IFFALSE 12861
// men = men ^ Gnyevko ;
12845: LD_ADDR_VAR 0 3
12849: PUSH
12850: LD_VAR 0 3
12854: PUSH
12855: LD_EXP 69
12859: ADD
12860: ST_TO_ADDR
// if IsOK ( Oblukov ) then
12861: LD_EXP 74
12865: PPUSH
12866: CALL_OW 302
12870: IFFALSE 12888
// men = men ^ Oblukov ;
12872: LD_ADDR_VAR 0 3
12876: PUSH
12877: LD_VAR 0 3
12881: PUSH
12882: LD_EXP 74
12886: ADD
12887: ST_TO_ADDR
// if men then
12888: LD_VAR 0 3
12892: IFFALSE 13054
// begin case men [ Rand ( 1 , men ) ] of Kuzmov :
12894: LD_VAR 0 3
12898: PUSH
12899: LD_INT 1
12901: PPUSH
12902: LD_VAR 0 3
12906: PPUSH
12907: CALL_OW 12
12911: ARRAY
12912: PUSH
12913: LD_EXP 72
12917: DOUBLE
12918: EQUAL
12919: IFTRUE 12923
12921: GO 12948
12923: POP
// begin Say ( Kuzmov , DFreeTime-Kuz-1 ) ;
12924: LD_EXP 72
12928: PPUSH
12929: LD_STRING DFreeTime-Kuz-1
12931: PPUSH
12932: CALL_OW 88
// man = Kuzmov ;
12936: LD_ADDR_VAR 0 5
12940: PUSH
12941: LD_EXP 72
12945: ST_TO_ADDR
// end ; Titov :
12946: GO 13054
12948: LD_EXP 62
12952: DOUBLE
12953: EQUAL
12954: IFTRUE 12958
12956: GO 12983
12958: POP
// begin Say ( Titov , DFreeTime-Tit-1 ) ;
12959: LD_EXP 62
12963: PPUSH
12964: LD_STRING DFreeTime-Tit-1
12966: PPUSH
12967: CALL_OW 88
// man = Titov ;
12971: LD_ADDR_VAR 0 5
12975: PUSH
12976: LD_EXP 62
12980: ST_TO_ADDR
// end ; Gnyevko :
12981: GO 13054
12983: LD_EXP 69
12987: DOUBLE
12988: EQUAL
12989: IFTRUE 12993
12991: GO 13018
12993: POP
// begin Say ( Gnyevko , DFreeTime-Gny-1 ) ;
12994: LD_EXP 69
12998: PPUSH
12999: LD_STRING DFreeTime-Gny-1
13001: PPUSH
13002: CALL_OW 88
// man = Gnyevko ;
13006: LD_ADDR_VAR 0 5
13010: PUSH
13011: LD_EXP 69
13015: ST_TO_ADDR
// end ; Oblukov :
13016: GO 13054
13018: LD_EXP 74
13022: DOUBLE
13023: EQUAL
13024: IFTRUE 13028
13026: GO 13053
13028: POP
// begin Say ( Oblukov , DFreeTime-Obl-1 ) ;
13029: LD_EXP 74
13033: PPUSH
13034: LD_STRING DFreeTime-Obl-1
13036: PPUSH
13037: CALL_OW 88
// man = Oblukov ;
13041: LD_ADDR_VAR 0 5
13045: PUSH
13046: LD_EXP 74
13050: ST_TO_ADDR
// end ; end ;
13051: GO 13054
13053: POP
// end ; DialogueOff ;
13054: CALL_OW 7
// if not woman and not man then
13058: LD_VAR 0 4
13062: NOT
13063: PUSH
13064: LD_VAR 0 5
13068: NOT
13069: AND
13070: IFFALSE 13078
// begin DialogueOff ;
13072: CALL_OW 7
// exit ;
13076: GO 13524
// end ; case Query ( QFreeTime ) of 1 :
13078: LD_STRING QFreeTime
13080: PPUSH
13081: CALL_OW 97
13085: PUSH
13086: LD_INT 1
13088: DOUBLE
13089: EQUAL
13090: IFTRUE 13094
13092: GO 13496
13094: POP
// begin Say ( Burlak , DQrFreeTime#1-Bur-1 ) ;
13095: LD_EXP 57
13099: PPUSH
13100: LD_STRING DQrFreeTime#1-Bur-1
13102: PPUSH
13103: CALL_OW 88
// DialogueOff ;
13107: CALL_OW 7
// BurlakRespect = BurlakRespect + 1 ;
13111: LD_ADDR_EXP 30
13115: PUSH
13116: LD_EXP 30
13120: PUSH
13121: LD_INT 1
13123: PLUS
13124: ST_TO_ADDR
// SetSide ( [ woman , man ] , 6 ) ;
13125: LD_VAR 0 4
13129: PUSH
13130: LD_VAR 0 5
13134: PUSH
13135: EMPTY
13136: LIST
13137: LIST
13138: PPUSH
13139: LD_INT 6
13141: PPUSH
13142: CALL_OW 235
// for unit in [ woman , man ] do
13146: LD_ADDR_VAR 0 1
13150: PUSH
13151: LD_VAR 0 4
13155: PUSH
13156: LD_VAR 0 5
13160: PUSH
13161: EMPTY
13162: LIST
13163: LIST
13164: PUSH
13165: FOR_IN
13166: IFFALSE 13221
// if IsInUnit ( unit ) then
13168: LD_VAR 0 1
13172: PPUSH
13173: CALL_OW 310
13177: IFFALSE 13219
// begin if GetType ( IsInUnit ( unit ) ) = unit_vehicle then
13179: LD_VAR 0 1
13183: PPUSH
13184: CALL_OW 310
13188: PPUSH
13189: CALL_OW 247
13193: PUSH
13194: LD_INT 2
13196: EQUAL
13197: IFFALSE 13210
// ComExitVehicle ( unit ) else
13199: LD_VAR 0 1
13203: PPUSH
13204: CALL_OW 121
13208: GO 13219
// ComExitBuilding ( unit ) ;
13210: LD_VAR 0 1
13214: PPUSH
13215: CALL_OW 122
// end ;
13219: GO 13165
13221: POP
13222: POP
// wait ( 0 0$1 ) ;
13223: LD_INT 35
13225: PPUSH
13226: CALL_OW 67
// ComMoveToArea ( [ woman , man ] , ExitMapArea ) ;
13230: LD_VAR 0 4
13234: PUSH
13235: LD_VAR 0 5
13239: PUSH
13240: EMPTY
13241: LIST
13242: LIST
13243: PPUSH
13244: LD_INT 8
13246: PPUSH
13247: CALL_OW 113
// allowExitFromMap = 1 ;
13251: LD_ADDR_EXP 18
13255: PUSH
13256: LD_INT 1
13258: ST_TO_ADDR
// wait ( 3 3$0 ) ;
13259: LD_INT 6300
13261: PPUSH
13262: CALL_OW 67
// PlaceUnitXYR ( woman , 157 , 29 , 3 , false ) ;
13266: LD_VAR 0 4
13270: PPUSH
13271: LD_INT 157
13273: PPUSH
13274: LD_INT 29
13276: PPUSH
13277: LD_INT 3
13279: PPUSH
13280: LD_INT 0
13282: PPUSH
13283: CALL_OW 50
// PlaceUnitXYR ( man , 157 , 29 , 3 , false ) ;
13287: LD_VAR 0 5
13291: PPUSH
13292: LD_INT 157
13294: PPUSH
13295: LD_INT 29
13297: PPUSH
13298: LD_INT 3
13300: PPUSH
13301: LD_INT 0
13303: PPUSH
13304: CALL_OW 50
// SetSide ( [ woman , man ] , 3 ) ;
13308: LD_VAR 0 4
13312: PUSH
13313: LD_VAR 0 5
13317: PUSH
13318: EMPTY
13319: LIST
13320: LIST
13321: PPUSH
13322: LD_INT 3
13324: PPUSH
13325: CALL_OW 235
// depots = FilterAllUnits ( [ [ f_side , 3 ] , [ [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ] ) ;
13329: LD_ADDR_VAR 0 6
13333: PUSH
13334: LD_INT 22
13336: PUSH
13337: LD_INT 3
13339: PUSH
13340: EMPTY
13341: LIST
13342: LIST
13343: PUSH
13344: LD_INT 2
13346: PUSH
13347: LD_INT 30
13349: PUSH
13350: LD_INT 0
13352: PUSH
13353: EMPTY
13354: LIST
13355: LIST
13356: PUSH
13357: LD_INT 30
13359: PUSH
13360: LD_INT 1
13362: PUSH
13363: EMPTY
13364: LIST
13365: LIST
13366: PUSH
13367: EMPTY
13368: LIST
13369: LIST
13370: LIST
13371: PUSH
13372: EMPTY
13373: LIST
13374: PUSH
13375: EMPTY
13376: LIST
13377: LIST
13378: PPUSH
13379: CALL_OW 69
13383: ST_TO_ADDR
// if depots then
13384: LD_VAR 0 6
13388: IFFALSE 13438
// ComMoveXY ( [ woman , man ] , GetX ( depots [ 1 ] ) , GetY ( depots [ 1 ] ) ) else
13390: LD_VAR 0 4
13394: PUSH
13395: LD_VAR 0 5
13399: PUSH
13400: EMPTY
13401: LIST
13402: LIST
13403: PPUSH
13404: LD_VAR 0 6
13408: PUSH
13409: LD_INT 1
13411: ARRAY
13412: PPUSH
13413: CALL_OW 250
13417: PPUSH
13418: LD_VAR 0 6
13422: PUSH
13423: LD_INT 1
13425: ARRAY
13426: PPUSH
13427: CALL_OW 251
13431: PPUSH
13432: CALL_OW 111
13436: GO 13476
// ComMoveXY ( [ woman , man ] , GetX ( Burlak ) , GetY ( Burlak ) ) ;
13438: LD_VAR 0 4
13442: PUSH
13443: LD_VAR 0 5
13447: PUSH
13448: EMPTY
13449: LIST
13450: LIST
13451: PPUSH
13452: LD_EXP 57
13456: PPUSH
13457: CALL_OW 250
13461: PPUSH
13462: LD_EXP 57
13466: PPUSH
13467: CALL_OW 251
13471: PPUSH
13472: CALL_OW 111
// CenterOnUnits ( [ woman , man ] ) ;
13476: LD_VAR 0 4
13480: PUSH
13481: LD_VAR 0 5
13485: PUSH
13486: EMPTY
13487: LIST
13488: LIST
13489: PPUSH
13490: CALL_OW 85
// end ; 2 :
13494: GO 13520
13496: LD_INT 2
13498: DOUBLE
13499: EQUAL
13500: IFTRUE 13504
13502: GO 13519
13504: POP
// Say ( Burlak , DQrFreeTime#2-Bur-1 ) ; end ;
13505: LD_EXP 57
13509: PPUSH
13510: LD_STRING DQrFreeTime#2-Bur-1
13512: PPUSH
13513: CALL_OW 88
13517: GO 13520
13519: POP
// DialogueOff ;
13520: CALL_OW 7
// end ;
13524: PPOPN 6
13526: END
// every 0 0$1 trigger GetAmountWeaponsDataBuildOnVehicle ( false ) <= 2 do
13527: LD_INT 0
13529: PPUSH
13530: CALL 6800 0 1
13534: PUSH
13535: LD_INT 2
13537: LESSEQUAL
13538: IFFALSE 13673
13540: GO 13542
13542: DISABLE
// begin DialogueOn ;
13543: CALL_OW 6
// if IsOK ( Kozlov ) then
13547: LD_EXP 73
13551: PPUSH
13552: CALL_OW 302
13556: IFFALSE 13572
// Say ( Kozlov , DMasha-Koz-1 ) else
13558: LD_EXP 73
13562: PPUSH
13563: LD_STRING DMasha-Koz-1
13565: PPUSH
13566: CALL_OW 88
13570: GO 13635
// DialogRandom ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_ok ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) , DMasha-Koz-1 ,  , false , false ) ;
13572: LD_INT 22
13574: PUSH
13575: LD_INT 3
13577: PUSH
13578: EMPTY
13579: LIST
13580: LIST
13581: PUSH
13582: LD_INT 50
13584: PUSH
13585: EMPTY
13586: LIST
13587: PUSH
13588: LD_INT 21
13590: PUSH
13591: LD_INT 1
13593: PUSH
13594: EMPTY
13595: LIST
13596: LIST
13597: PUSH
13598: LD_INT 26
13600: PUSH
13601: LD_INT 1
13603: PUSH
13604: EMPTY
13605: LIST
13606: LIST
13607: PUSH
13608: EMPTY
13609: LIST
13610: LIST
13611: LIST
13612: LIST
13613: PPUSH
13614: CALL_OW 69
13618: PPUSH
13619: LD_STRING DMasha-Koz-1
13621: PPUSH
13622: LD_STRING 
13624: PPUSH
13625: LD_INT 0
13627: PPUSH
13628: LD_INT 0
13630: PPUSH
13631: CALL 6249 0 5
// Say ( Burlak , DMasha2-Bur-1 ) ;
13635: LD_EXP 57
13639: PPUSH
13640: LD_STRING DMasha2-Bur-1
13642: PPUSH
13643: CALL_OW 88
// DialogueOff ;
13647: CALL_OW 7
// Query ( QMasha ) ;
13651: LD_STRING QMasha
13653: PPUSH
13654: CALL_OW 97
// ChangeMissionObjectives ( MMasha ) ;
13658: LD_STRING MMasha
13660: PPUSH
13661: CALL_OW 337
// canChooseMashaVehicle = true ;
13665: LD_ADDR_EXP 36
13669: PUSH
13670: LD_INT 1
13672: ST_TO_ADDR
// end ;
13673: END
// export function Dial_ComputerTechResearched ; begin
13674: LD_INT 0
13676: PPUSH
// if IsOk ( Scholtze ) or IsOK ( Kapitsova ) then
13677: LD_EXP 71
13681: PPUSH
13682: CALL_OW 302
13686: PUSH
13687: LD_EXP 75
13691: PPUSH
13692: CALL_OW 302
13696: OR
13697: IFFALSE 13793
// begin DialogueOn ;
13699: CALL_OW 6
// if IsOK ( Scholtze ) then
13703: LD_EXP 71
13707: PPUSH
13708: CALL_OW 302
13712: IFFALSE 13728
// Say ( Scholtze , DAI-Sch-1 ) else
13714: LD_EXP 71
13718: PPUSH
13719: LD_STRING DAI-Sch-1
13721: PPUSH
13722: CALL_OW 88
13726: GO 13740
// Say ( Kapitsova , DAI-Kap-1 ) ;
13728: LD_EXP 75
13732: PPUSH
13733: LD_STRING DAI-Kap-1
13735: PPUSH
13736: CALL_OW 88
// Say ( Burlak , DAI-Bur-1 ) ;
13740: LD_EXP 57
13744: PPUSH
13745: LD_STRING DAI-Bur-1
13747: PPUSH
13748: CALL_OW 88
// if IsOK ( Scholtze ) then
13752: LD_EXP 71
13756: PPUSH
13757: CALL_OW 302
13761: IFFALSE 13777
// Say ( Scholtze , DAI-Sch-2 ) else
13763: LD_EXP 71
13767: PPUSH
13768: LD_STRING DAI-Sch-2
13770: PPUSH
13771: CALL_OW 88
13775: GO 13789
// Say ( Kapitsova , DAI-Kap-2 ) ;
13777: LD_EXP 75
13781: PPUSH
13782: LD_STRING DAI-Kap-2
13784: PPUSH
13785: CALL_OW 88
// DialogueOff ;
13789: CALL_OW 7
// end ; ChangeMissionObjectives ( MAI ) ;
13793: LD_STRING MAI
13795: PPUSH
13796: CALL_OW 337
// end ;
13800: LD_VAR 0 1
13804: RET
// export function Dial_TeleportTechResearched ; begin
13805: LD_INT 0
13807: PPUSH
// if IsOk ( Scholtze ) or IsOK ( Kapitsova ) then
13808: LD_EXP 71
13812: PPUSH
13813: CALL_OW 302
13817: PUSH
13818: LD_EXP 75
13822: PPUSH
13823: CALL_OW 302
13827: OR
13828: IFFALSE 13936
// begin DialogueOn ;
13830: CALL_OW 6
// if IsOK ( Scholtze ) then
13834: LD_EXP 71
13838: PPUSH
13839: CALL_OW 302
13843: IFFALSE 13859
// Say ( Scholtze , DSpontTelep-Sch-1 ) else
13845: LD_EXP 71
13849: PPUSH
13850: LD_STRING DSpontTelep-Sch-1
13852: PPUSH
13853: CALL_OW 88
13857: GO 13871
// Say ( Kapitsova , DSpontTelep-Kap-1 ) ;
13859: LD_EXP 75
13863: PPUSH
13864: LD_STRING DSpontTelep-Kap-1
13866: PPUSH
13867: CALL_OW 88
// Say ( Burlak , DSpontTelep-Bur-1 ) ;
13871: LD_EXP 57
13875: PPUSH
13876: LD_STRING DSpontTelep-Bur-1
13878: PPUSH
13879: CALL_OW 88
// if IsOK ( Scholtze ) then
13883: LD_EXP 71
13887: PPUSH
13888: CALL_OW 302
13892: IFFALSE 13908
// Say ( Scholtze , DSpontTelep-Sch-2 ) else
13894: LD_EXP 71
13898: PPUSH
13899: LD_STRING DSpontTelep-Sch-2
13901: PPUSH
13902: CALL_OW 88
13906: GO 13920
// Say ( Kapitsova , DSpontTelep-Kap-2 ) ;
13908: LD_EXP 75
13912: PPUSH
13913: LD_STRING DSpontTelep-Kap-2
13915: PPUSH
13916: CALL_OW 88
// Say ( Burlak , DSpontTelep-Bur-2 ) ;
13920: LD_EXP 57
13924: PPUSH
13925: LD_STRING DSpontTelep-Bur-2
13927: PPUSH
13928: CALL_OW 88
// DialogueOff ;
13932: CALL_OW 7
// end ; ChangeMissionObjectives ( MTele ) ;
13936: LD_STRING MTele
13938: PPUSH
13939: CALL_OW 337
// end ;
13943: LD_VAR 0 1
13947: RET
// every 0 0$1 trigger buildingsToBuild <= 3 and GetAmountWeaponsDataBuildOnVehicle ( false ) <= 1 and techsToResearch <= 4 do
13948: LD_EXP 8
13952: PUSH
13953: LD_INT 3
13955: LESSEQUAL
13956: PUSH
13957: LD_INT 0
13959: PPUSH
13960: CALL 6800 0 1
13964: PUSH
13965: LD_INT 1
13967: LESSEQUAL
13968: AND
13969: PUSH
13970: LD_EXP 9
13974: PUSH
13975: LD_INT 4
13977: LESSEQUAL
13978: AND
13979: IFFALSE 14180
13981: GO 13983
13983: DISABLE
// begin SayRadio ( Popov , DAmAttackStart-Pop-1 ) ;
13984: LD_EXP 76
13988: PPUSH
13989: LD_STRING DAmAttackStart-Pop-1
13991: PPUSH
13992: CALL_OW 94
// if KurtStatus = 1 and HeikeStatus = 1 then
13996: LD_EXP 22
14000: PUSH
14001: LD_INT 1
14003: EQUAL
14004: PUSH
14005: LD_EXP 3
14009: PUSH
14010: LD_INT 1
14012: EQUAL
14013: AND
14014: IFFALSE 14172
// begin wait ( 0 0$10 ) ;
14016: LD_INT 350
14018: PPUSH
14019: CALL_OW 67
// DialogueOn ;
14023: CALL_OW 6
// SayRadio ( Heike , DLegionFormed-Hke-1 ) ;
14027: LD_EXP 79
14031: PPUSH
14032: LD_STRING DLegionFormed-Hke-1
14034: PPUSH
14035: CALL_OW 94
// Say ( Burlak , DLegionFormed-Bur-1 ) ;
14039: LD_EXP 57
14043: PPUSH
14044: LD_STRING DLegionFormed-Bur-1
14046: PPUSH
14047: CALL_OW 88
// SayRadio ( Heike , DLegionFormed-Hke-2 ) ;
14051: LD_EXP 79
14055: PPUSH
14056: LD_STRING DLegionFormed-Hke-2
14058: PPUSH
14059: CALL_OW 94
// Say ( Burlak , DLegionFormed-Bur-2 ) ;
14063: LD_EXP 57
14067: PPUSH
14068: LD_STRING DLegionFormed-Bur-2
14070: PPUSH
14071: CALL_OW 88
// SayRadio ( Heike , DLegionFormed-Hke-3 ) ;
14075: LD_EXP 79
14079: PPUSH
14080: LD_STRING DLegionFormed-Hke-3
14082: PPUSH
14083: CALL_OW 94
// case Query ( QLegion ) of 1 :
14087: LD_STRING QLegion
14089: PPUSH
14090: CALL_OW 97
14094: PUSH
14095: LD_INT 1
14097: DOUBLE
14098: EQUAL
14099: IFTRUE 14103
14101: GO 14134
14103: POP
// begin acceptLegionOffert = true ;
14104: LD_ADDR_EXP 31
14108: PUSH
14109: LD_INT 1
14111: ST_TO_ADDR
// legionOffertCountdown = true ;
14112: LD_ADDR_EXP 33
14116: PUSH
14117: LD_INT 1
14119: ST_TO_ADDR
// Say ( Burlak , DQrLegion#1-Bur-1 ) ;
14120: LD_EXP 57
14124: PPUSH
14125: LD_STRING DQrLegion#1-Bur-1
14127: PPUSH
14128: CALL_OW 88
// end ; 2 :
14132: GO 14166
14134: LD_INT 2
14136: DOUBLE
14137: EQUAL
14138: IFTRUE 14142
14140: GO 14165
14142: POP
// begin Say ( Burlak , DQrLegion#2-Bur-1 ) ;
14143: LD_EXP 57
14147: PPUSH
14148: LD_STRING DQrLegion#2-Bur-1
14150: PPUSH
14151: CALL_OW 88
// americansAttack = true ;
14155: LD_ADDR_EXP 26
14159: PUSH
14160: LD_INT 1
14162: ST_TO_ADDR
// end ; end ;
14163: GO 14166
14165: POP
// DialogueOff ;
14166: CALL_OW 7
// end else
14170: GO 14180
// begin americansAttack = true ;
14172: LD_ADDR_EXP 26
14176: PUSH
14177: LD_INT 1
14179: ST_TO_ADDR
// end ; end ;
14180: END
// every 0 0$1 trigger legionOffertTime <= 0 0$00 do
14181: LD_EXP 34
14185: PUSH
14186: LD_INT 0
14188: LESSEQUAL
14189: IFFALSE 14210
14191: GO 14193
14193: DISABLE
// begin legionOffertCountdown = false ;
14194: LD_ADDR_EXP 33
14198: PUSH
14199: LD_INT 0
14201: ST_TO_ADDR
// americansAttack = true ;
14202: LD_ADDR_EXP 26
14206: PUSH
14207: LD_INT 1
14209: ST_TO_ADDR
// end ;
14210: END
// every 0 0$1 trigger legionOffertCountdown do var needCrates , depots , depot , crates ;
14211: LD_EXP 33
14215: IFFALSE 14401
14217: GO 14219
14219: DISABLE
14220: LD_INT 0
14222: PPUSH
14223: PPUSH
14224: PPUSH
14225: PPUSH
// begin needCrates = 50 ;
14226: LD_ADDR_VAR 0 1
14230: PUSH
14231: LD_INT 50
14233: ST_TO_ADDR
// crates = 0 ;
14234: LD_ADDR_VAR 0 4
14238: PUSH
14239: LD_INT 0
14241: ST_TO_ADDR
// depots = FilterAllUnits ( [ [ f_side , 3 ] , [ [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ] ) ;
14242: LD_ADDR_VAR 0 2
14246: PUSH
14247: LD_INT 22
14249: PUSH
14250: LD_INT 3
14252: PUSH
14253: EMPTY
14254: LIST
14255: LIST
14256: PUSH
14257: LD_INT 2
14259: PUSH
14260: LD_INT 30
14262: PUSH
14263: LD_INT 0
14265: PUSH
14266: EMPTY
14267: LIST
14268: LIST
14269: PUSH
14270: LD_INT 30
14272: PUSH
14273: LD_INT 1
14275: PUSH
14276: EMPTY
14277: LIST
14278: LIST
14279: PUSH
14280: EMPTY
14281: LIST
14282: LIST
14283: LIST
14284: PUSH
14285: EMPTY
14286: LIST
14287: PUSH
14288: EMPTY
14289: LIST
14290: LIST
14291: PPUSH
14292: CALL_OW 69
14296: ST_TO_ADDR
// for depot in depots do
14297: LD_ADDR_VAR 0 3
14301: PUSH
14302: LD_VAR 0 2
14306: PUSH
14307: FOR_IN
14308: IFFALSE 14399
// begin crates = GetResourceType ( GetBase ( depot ) , mat_cans ) ;
14310: LD_ADDR_VAR 0 4
14314: PUSH
14315: LD_VAR 0 3
14319: PPUSH
14320: CALL_OW 274
14324: PPUSH
14325: LD_INT 1
14327: PPUSH
14328: CALL_OW 275
14332: ST_TO_ADDR
// if crates >= needCrates then
14333: LD_VAR 0 4
14337: PUSH
14338: LD_VAR 0 1
14342: GREATEREQUAL
14343: IFFALSE 14397
// begin SetResourceType ( GetBase ( depot ) , mat_cans , crates - needCrates ) ;
14345: LD_VAR 0 3
14349: PPUSH
14350: CALL_OW 274
14354: PPUSH
14355: LD_INT 1
14357: PPUSH
14358: LD_VAR 0 4
14362: PUSH
14363: LD_VAR 0 1
14367: MINUS
14368: PPUSH
14369: CALL_OW 277
// legionOffertCountdown = false ;
14373: LD_ADDR_EXP 33
14377: PUSH
14378: LD_INT 0
14380: ST_TO_ADDR
// paidLegionOffert = true ;
14381: LD_ADDR_EXP 32
14385: PUSH
14386: LD_INT 1
14388: ST_TO_ADDR
// americansAttack = true ;
14389: LD_ADDR_EXP 26
14393: PUSH
14394: LD_INT 1
14396: ST_TO_ADDR
// end ; end ;
14397: GO 14307
14399: POP
14400: POP
// end ;
14401: PPOPN 4
14403: END
// every 0 0$1 trigger currentAmWave >= americansAttackWaves and FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_type , unit_human ] , [ f_and , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ] ] ) = 0 do
14404: LD_EXP 85
14408: PUSH
14409: LD_EXP 48
14413: GREATEREQUAL
14414: PUSH
14415: LD_INT 22
14417: PUSH
14418: LD_INT 1
14420: PUSH
14421: EMPTY
14422: LIST
14423: LIST
14424: PUSH
14425: LD_INT 2
14427: PUSH
14428: LD_INT 21
14430: PUSH
14431: LD_INT 1
14433: PUSH
14434: EMPTY
14435: LIST
14436: LIST
14437: PUSH
14438: LD_INT 1
14440: PUSH
14441: LD_INT 21
14443: PUSH
14444: LD_INT 2
14446: PUSH
14447: EMPTY
14448: LIST
14449: LIST
14450: PUSH
14451: LD_INT 33
14453: PUSH
14454: LD_INT 3
14456: PUSH
14457: EMPTY
14458: LIST
14459: LIST
14460: PUSH
14461: EMPTY
14462: LIST
14463: LIST
14464: LIST
14465: PUSH
14466: EMPTY
14467: LIST
14468: LIST
14469: LIST
14470: PUSH
14471: EMPTY
14472: LIST
14473: LIST
14474: PPUSH
14475: CALL_OW 69
14479: PUSH
14480: LD_INT 0
14482: EQUAL
14483: AND
14484: IFFALSE 14684
14486: GO 14488
14488: DISABLE
// begin DialogueOn ;
14489: CALL_OW 6
// if IsOK ( Belkov ) then
14493: LD_EXP 66
14497: PPUSH
14498: CALL_OW 302
14502: IFFALSE 14518
// Say ( Belkov , DAmAttackFin-Bel-1 ) else
14504: LD_EXP 66
14508: PPUSH
14509: LD_STRING DAmAttackFin-Bel-1
14511: PPUSH
14512: CALL_OW 88
14516: GO 14541
// if IsOK ( Belkov2 ) then
14518: LD_EXP 67
14522: PPUSH
14523: CALL_OW 302
14527: IFFALSE 14541
// Say ( Belkov2 , DAmAttackFin-Bel-1 ) ;
14529: LD_EXP 67
14533: PPUSH
14534: LD_STRING DAmAttackFin-Bel-1
14536: PPUSH
14537: CALL_OW 88
// if IsOK ( Gnyevko ) then
14541: LD_EXP 69
14545: PPUSH
14546: CALL_OW 302
14550: IFFALSE 14564
// Say ( Gnyevko , DAmAttackFin-Gny-1 ) ;
14552: LD_EXP 69
14556: PPUSH
14557: LD_STRING DAmAttackFin-Gny-1
14559: PPUSH
14560: CALL_OW 88
// if IsOK ( Titov ) then
14564: LD_EXP 62
14568: PPUSH
14569: CALL_OW 302
14573: IFFALSE 14587
// Say ( Titov , DAmAttackFin-Tit-1 ) ;
14575: LD_EXP 62
14579: PPUSH
14580: LD_STRING DAmAttackFin-Tit-1
14582: PPUSH
14583: CALL_OW 88
// if IsOK ( Lipshchin ) then
14587: LD_EXP 64
14591: PPUSH
14592: CALL_OW 302
14596: IFFALSE 14610
// Say ( Lipshchin , DAmAttackFin-Lip-1 ) ;
14598: LD_EXP 64
14602: PPUSH
14603: LD_STRING DAmAttackFin-Lip-1
14605: PPUSH
14606: CALL_OW 88
// if IsOK ( Karamazov ) then
14610: LD_EXP 58
14614: PPUSH
14615: CALL_OW 302
14619: IFFALSE 14633
// Say ( Karamazov , DAmAttackFin-Kar-1 ) ;
14621: LD_EXP 58
14625: PPUSH
14626: LD_STRING DAmAttackFin-Kar-1
14628: PPUSH
14629: CALL_OW 88
// if IsOK ( Oblukov ) then
14633: LD_EXP 74
14637: PPUSH
14638: CALL_OW 302
14642: IFFALSE 14656
// Say ( Oblukov , DAmAttackFin-Obl-1 ) ;
14644: LD_EXP 74
14648: PPUSH
14649: LD_STRING DAmAttackFin-Obl-1
14651: PPUSH
14652: CALL_OW 88
// Say ( Burlak , AmAttackFin-Bur-1 ) ;
14656: LD_EXP 57
14660: PPUSH
14661: LD_STRING AmAttackFin-Bur-1
14663: PPUSH
14664: CALL_OW 88
// SayRadio ( Popov , DAmAttackFin-Pop-1 ) ;
14668: LD_EXP 76
14672: PPUSH
14673: LD_STRING DAmAttackFin-Pop-1
14675: PPUSH
14676: CALL_OW 94
// DialogueOff ;
14680: CALL_OW 7
// end ;
14684: END
// every 0 0$1 trigger buildingsToBuild + ( 3 - GetAmountWeaponsDataBuildOnTurret ( true ) ) = 0 do
14685: LD_EXP 8
14689: PUSH
14690: LD_INT 3
14692: PUSH
14693: LD_INT 1
14695: PPUSH
14696: CALL 6690 0 1
14700: MINUS
14701: PLUS
14702: PUSH
14703: LD_INT 0
14705: EQUAL
14706: IFFALSE 14718
14708: GO 14710
14710: DISABLE
// ChangeMissionObjectives ( MBuildingsDone ) ;
14711: LD_STRING MBuildingsDone
14713: PPUSH
14714: CALL_OW 337
14718: END
// every 0 0$1 trigger GetAmountWeaponsDataBuildOnVehicle ( false ) = 0 do
14719: LD_INT 0
14721: PPUSH
14722: CALL 6800 0 1
14726: PUSH
14727: LD_INT 0
14729: EQUAL
14730: IFFALSE 14742
14732: GO 14734
14734: DISABLE
// ChangeMissionObjectives ( MWeaponsDone ) ;
14735: LD_STRING MWeaponsDone
14737: PPUSH
14738: CALL_OW 337
14742: END
// every 0 0$1 trigger techsToResearch = 0 do
14743: LD_EXP 9
14747: PUSH
14748: LD_INT 0
14750: EQUAL
14751: IFFALSE 14763
14753: GO 14755
14755: DISABLE
// ChangeMissionObjectives ( MTechnoDone ) ;
14756: LD_STRING MTechnoDone
14758: PPUSH
14759: CALL_OW 337
14763: END
// every 0 0$1 trigger americansAttack and not FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_type , unit_human ] , [ f_and , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ] ] ) do
14764: LD_EXP 26
14768: PUSH
14769: LD_INT 22
14771: PUSH
14772: LD_INT 1
14774: PUSH
14775: EMPTY
14776: LIST
14777: LIST
14778: PUSH
14779: LD_INT 2
14781: PUSH
14782: LD_INT 21
14784: PUSH
14785: LD_INT 1
14787: PUSH
14788: EMPTY
14789: LIST
14790: LIST
14791: PUSH
14792: LD_INT 1
14794: PUSH
14795: LD_INT 21
14797: PUSH
14798: LD_INT 2
14800: PUSH
14801: EMPTY
14802: LIST
14803: LIST
14804: PUSH
14805: LD_INT 33
14807: PUSH
14808: LD_INT 3
14810: PUSH
14811: EMPTY
14812: LIST
14813: LIST
14814: PUSH
14815: EMPTY
14816: LIST
14817: LIST
14818: LIST
14819: PUSH
14820: EMPTY
14821: LIST
14822: LIST
14823: LIST
14824: PUSH
14825: EMPTY
14826: LIST
14827: LIST
14828: PPUSH
14829: CALL_OW 69
14833: NOT
14834: AND
14835: IFFALSE 14847
14837: GO 14839
14839: DISABLE
// ChangeMissionObjectives ( MEnemyDone ) ;
14840: LD_STRING MEnemyDone
14842: PPUSH
14843: CALL_OW 337
14847: END
// every 0 0$1 trigger ( buildingsToBuild + ( 3 - GetAmountWeaponsDataBuildOnTurret ( true ) ) ) = 0 and GetAmountWeaponsDataBuildOnVehicle ( false ) = 0 and techsToResearch = 0 and FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] ] ) = 0 and FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_type , unit_human ] , [ f_and , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ] ] ) = 0 and Masha and IsOK ( Masha [ 1 ] ) and buildCompVehicle and testedTeleport do
14848: LD_EXP 8
14852: PUSH
14853: LD_INT 3
14855: PUSH
14856: LD_INT 1
14858: PPUSH
14859: CALL 6690 0 1
14863: MINUS
14864: PLUS
14865: PUSH
14866: LD_INT 0
14868: EQUAL
14869: PUSH
14870: LD_INT 0
14872: PPUSH
14873: CALL 6800 0 1
14877: PUSH
14878: LD_INT 0
14880: EQUAL
14881: AND
14882: PUSH
14883: LD_EXP 9
14887: PUSH
14888: LD_INT 0
14890: EQUAL
14891: AND
14892: PUSH
14893: LD_INT 22
14895: PUSH
14896: LD_INT 8
14898: PUSH
14899: EMPTY
14900: LIST
14901: LIST
14902: PUSH
14903: LD_INT 21
14905: PUSH
14906: LD_INT 1
14908: PUSH
14909: EMPTY
14910: LIST
14911: LIST
14912: PUSH
14913: EMPTY
14914: LIST
14915: LIST
14916: PPUSH
14917: CALL_OW 69
14921: PUSH
14922: LD_INT 0
14924: EQUAL
14925: AND
14926: PUSH
14927: LD_INT 22
14929: PUSH
14930: LD_INT 1
14932: PUSH
14933: EMPTY
14934: LIST
14935: LIST
14936: PUSH
14937: LD_INT 2
14939: PUSH
14940: LD_INT 21
14942: PUSH
14943: LD_INT 1
14945: PUSH
14946: EMPTY
14947: LIST
14948: LIST
14949: PUSH
14950: LD_INT 1
14952: PUSH
14953: LD_INT 21
14955: PUSH
14956: LD_INT 2
14958: PUSH
14959: EMPTY
14960: LIST
14961: LIST
14962: PUSH
14963: LD_INT 33
14965: PUSH
14966: LD_INT 3
14968: PUSH
14969: EMPTY
14970: LIST
14971: LIST
14972: PUSH
14973: EMPTY
14974: LIST
14975: LIST
14976: LIST
14977: PUSH
14978: EMPTY
14979: LIST
14980: LIST
14981: LIST
14982: PUSH
14983: EMPTY
14984: LIST
14985: LIST
14986: PPUSH
14987: CALL_OW 69
14991: PUSH
14992: LD_INT 0
14994: EQUAL
14995: AND
14996: PUSH
14997: LD_EXP 4
15001: AND
15002: PUSH
15003: LD_EXP 4
15007: PUSH
15008: LD_INT 1
15010: ARRAY
15011: PPUSH
15012: CALL_OW 302
15016: AND
15017: PUSH
15018: LD_EXP 37
15022: AND
15023: PUSH
15024: LD_EXP 39
15028: AND
15029: IFFALSE 15038
15031: GO 15033
15033: DISABLE
// begin FinishMission ;
15034: CALL 15243 0 0
// end ;
15038: END
// every 0 0$1 do var unit ;
15039: GO 15041
15041: DISABLE
15042: LD_INT 0
15044: PPUSH
// begin case allowExitFromMap of 1 :
15045: LD_EXP 18
15049: PUSH
15050: LD_INT 1
15052: DOUBLE
15053: EQUAL
15054: IFTRUE 15058
15056: GO 15086
15058: POP
// RemoveUnits ( FilterUnitsInArea ( ExitMapArea , [ [ f_side , 6 ] ] ) ) ; 3 :
15059: LD_INT 8
15061: PPUSH
15062: LD_INT 22
15064: PUSH
15065: LD_INT 6
15067: PUSH
15068: EMPTY
15069: LIST
15070: LIST
15071: PUSH
15072: EMPTY
15073: LIST
15074: PPUSH
15075: CALL_OW 70
15079: PPUSH
15080: CALL 6526 0 1
15084: GO 15209
15086: LD_INT 3
15088: DOUBLE
15089: EQUAL
15090: IFTRUE 15094
15092: GO 15122
15094: POP
// RemoveUnits ( FilterUnitsInArea ( KurtExitMapArea , [ [ f_side , 8 ] ] ) ) ; 4 :
15095: LD_INT 11
15097: PPUSH
15098: LD_INT 22
15100: PUSH
15101: LD_INT 8
15103: PUSH
15104: EMPTY
15105: LIST
15106: LIST
15107: PUSH
15108: EMPTY
15109: LIST
15110: PPUSH
15111: CALL_OW 70
15115: PPUSH
15116: CALL 6526 0 1
15120: GO 15209
15122: LD_INT 4
15124: DOUBLE
15125: EQUAL
15126: IFTRUE 15130
15128: GO 15208
15130: POP
// begin RemoveUnits ( FilterUnitsInArea ( ExitMapArea , [ [ f_side , 8 ] ] ) ) ;
15131: LD_INT 8
15133: PPUSH
15134: LD_INT 22
15136: PUSH
15137: LD_INT 8
15139: PUSH
15140: EMPTY
15141: LIST
15142: LIST
15143: PUSH
15144: EMPTY
15145: LIST
15146: PPUSH
15147: CALL_OW 70
15151: PPUSH
15152: CALL 6526 0 1
// RemoveUnits ( FilterUnitsInArea ( KurtExitMapArea , [ [ f_side , 8 ] ] ) ) ;
15156: LD_INT 11
15158: PPUSH
15159: LD_INT 22
15161: PUSH
15162: LD_INT 8
15164: PUSH
15165: EMPTY
15166: LIST
15167: LIST
15168: PUSH
15169: EMPTY
15170: LIST
15171: PPUSH
15172: CALL_OW 70
15176: PPUSH
15177: CALL 6526 0 1
// RemoveUnits ( FilterUnitsInArea ( ExitMapArea , [ [ f_side , 2 ] ] ) ) ;
15181: LD_INT 8
15183: PPUSH
15184: LD_INT 22
15186: PUSH
15187: LD_INT 2
15189: PUSH
15190: EMPTY
15191: LIST
15192: LIST
15193: PUSH
15194: EMPTY
15195: LIST
15196: PPUSH
15197: CALL_OW 70
15201: PPUSH
15202: CALL 6526 0 1
// end ; end ;
15206: GO 15209
15208: POP
// enable ;
15209: ENABLE
// end ; end_of_file
15210: PPOPN 1
15212: END
// export function Lose_Burlak ; begin
15213: LD_INT 0
15215: PPUSH
// YouLost ( Burlak ) ;
15216: LD_STRING Burlak
15218: PPUSH
15219: CALL_OW 104
// end ;
15223: LD_VAR 0 1
15227: RET
// export function Lost_AttackAlly ; begin
15228: LD_INT 0
15230: PPUSH
// YouLost ( SelfAttack ) ;
15231: LD_STRING SelfAttack
15233: PPUSH
15234: CALL_OW 104
// end ; end_of_file
15238: LD_VAR 0 1
15242: RET
// export function FinishMission ; begin
15243: LD_INT 0
15245: PPUSH
// SetRewards ;
15246: CALL 15267 0 0
// SavePlayerCharacters ;
15250: CALL 15528 0 0
// SaveGlobalVariables ;
15254: CALL 16078 0 0
// YouWin ;
15258: CALL_OW 103
// end ;
15262: LD_VAR 0 1
15266: RET
// function SetRewards ; begin
15267: LD_INT 0
15269: PPUSH
// AddMedal ( ArtisticImpression , 1 ) ;
15270: LD_STRING ArtisticImpression
15272: PPUSH
15273: LD_INT 1
15275: PPUSH
15276: CALL_OW 101
// if not HeikeCaptured then
15280: LD_EXP 1
15284: NOT
15285: IFFALSE 15319
// begin if speedMedalTime >= 0 0$00 then
15287: LD_EXP 52
15291: PUSH
15292: LD_INT 0
15294: GREATEREQUAL
15295: IFFALSE 15309
// AddMedal ( Speed , 1 ) else
15297: LD_STRING Speed
15299: PPUSH
15300: LD_INT 1
15302: PPUSH
15303: CALL_OW 101
15307: GO 15319
// AddMedal ( Speed , 1 ) ;
15309: LD_STRING Speed
15311: PPUSH
15312: LD_INT 1
15314: PPUSH
15315: CALL_OW 101
// end ; if lostUnits then
15319: LD_EXP 40
15323: IFFALSE 15338
// begin AddMedal ( FavouriteCommander , - 1 ) ;
15325: LD_STRING FavouriteCommander
15327: PPUSH
15328: LD_INT 1
15330: NEG
15331: PPUSH
15332: CALL_OW 101
// end else
15336: GO 15430
// begin case BurlakRespect of 0 :
15338: LD_EXP 30
15342: PUSH
15343: LD_INT 0
15345: DOUBLE
15346: EQUAL
15347: IFTRUE 15351
15349: GO 15365
15351: POP
// AddMedal ( FavouriteCommander , - 2 ) ; 1 :
15352: LD_STRING FavouriteCommander
15354: PPUSH
15355: LD_INT 2
15357: NEG
15358: PPUSH
15359: CALL_OW 101
15363: GO 15430
15365: LD_INT 1
15367: DOUBLE
15368: EQUAL
15369: IFTRUE 15373
15371: GO 15387
15373: POP
// AddMedal ( FavouriteCommander , - 3 ) ; 2 :
15374: LD_STRING FavouriteCommander
15376: PPUSH
15377: LD_INT 3
15379: NEG
15380: PPUSH
15381: CALL_OW 101
15385: GO 15430
15387: LD_INT 2
15389: DOUBLE
15390: EQUAL
15391: IFTRUE 15395
15393: GO 15408
15395: POP
// AddMedal ( FavouriteCommander , 1 ) ; 3 :
15396: LD_STRING FavouriteCommander
15398: PPUSH
15399: LD_INT 1
15401: PPUSH
15402: CALL_OW 101
15406: GO 15430
15408: LD_INT 3
15410: DOUBLE
15411: EQUAL
15412: IFTRUE 15416
15414: GO 15429
15416: POP
// AddMedal ( FavouriteCommander , 1 ) ; end ;
15417: LD_STRING FavouriteCommander
15419: PPUSH
15420: LD_INT 1
15422: PPUSH
15423: CALL_OW 101
15427: GO 15430
15429: POP
// end ; if HeikeCaptured then
15430: LD_EXP 1
15434: IFFALSE 15465
// begin if buildArabBarrack then
15436: LD_EXP 38
15440: IFFALSE 15454
// AddMedal ( ArabBarracks , 1 ) else
15442: LD_STRING ArabBarracks
15444: PPUSH
15445: LD_INT 1
15447: PPUSH
15448: CALL_OW 101
15452: GO 15465
// AddMedal ( ArabBarracks , - 1 ) ;
15454: LD_STRING ArabBarracks
15456: PPUSH
15457: LD_INT 1
15459: NEG
15460: PPUSH
15461: CALL_OW 101
// end ; GiveMedals ( Main1 ) ;
15465: LD_STRING Main1
15467: PPUSH
15468: CALL_OW 102
// RewardPeople ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_nation , nation_russian ] , [ f_ok ] ] ) ) ;
15472: LD_INT 22
15474: PUSH
15475: LD_INT 3
15477: PUSH
15478: EMPTY
15479: LIST
15480: LIST
15481: PUSH
15482: LD_INT 21
15484: PUSH
15485: LD_INT 1
15487: PUSH
15488: EMPTY
15489: LIST
15490: LIST
15491: PUSH
15492: LD_INT 23
15494: PUSH
15495: LD_INT 3
15497: PUSH
15498: EMPTY
15499: LIST
15500: LIST
15501: PUSH
15502: LD_INT 50
15504: PUSH
15505: EMPTY
15506: LIST
15507: PUSH
15508: EMPTY
15509: LIST
15510: LIST
15511: LIST
15512: LIST
15513: PPUSH
15514: CALL_OW 69
15518: PPUSH
15519: CALL_OW 43
// end ;
15523: LD_VAR 0 1
15527: RET
// function SavePlayerCharacters ; var randomsToSave ; begin
15528: LD_INT 0
15530: PPUSH
15531: PPUSH
// ExtSaveCharacter ( Burlak , Burlak , 3 ) ;
15532: LD_EXP 57
15536: PPUSH
15537: LD_STRING Burlak
15539: PPUSH
15540: LD_INT 3
15542: PPUSH
15543: CALL 6048 0 3
// ExtSaveCharacter ( Karamazov , Karamazov , 3 ) ;
15547: LD_EXP 58
15551: PPUSH
15552: LD_STRING Karamazov
15554: PPUSH
15555: LD_INT 3
15557: PPUSH
15558: CALL 6048 0 3
// ExtSaveCharacter ( Petrovova , Petrovova , 3 ) ;
15562: LD_EXP 59
15566: PPUSH
15567: LD_STRING Petrovova
15569: PPUSH
15570: LD_INT 3
15572: PPUSH
15573: CALL 6048 0 3
// ExtSaveCharacter ( Gleb , Gleb , 3 ) ;
15577: LD_EXP 60
15581: PPUSH
15582: LD_STRING Gleb
15584: PPUSH
15585: LD_INT 3
15587: PPUSH
15588: CALL 6048 0 3
// ExtSaveCharacter ( Petrosyan , Petrosyan , 3 ) ;
15592: LD_EXP 61
15596: PPUSH
15597: LD_STRING Petrosyan
15599: PPUSH
15600: LD_INT 3
15602: PPUSH
15603: CALL 6048 0 3
// ExtSaveCharacter ( Dolgov , Dolgov , 3 ) ;
15607: LD_EXP 63
15611: PPUSH
15612: LD_STRING Dolgov
15614: PPUSH
15615: LD_INT 3
15617: PPUSH
15618: CALL 6048 0 3
// ExtSaveCharacter ( Lipshchin , Lipshchin , 3 ) ;
15622: LD_EXP 64
15626: PPUSH
15627: LD_STRING Lipshchin
15629: PPUSH
15630: LD_INT 3
15632: PPUSH
15633: CALL 6048 0 3
// ExtSaveCharacter ( Titov , Titov , 3 ) ;
15637: LD_EXP 62
15641: PPUSH
15642: LD_STRING Titov
15644: PPUSH
15645: LD_INT 3
15647: PPUSH
15648: CALL 6048 0 3
// ExtSaveCharacter ( Kirilenkova , Kirilenkova , 3 ) ;
15652: LD_EXP 65
15656: PPUSH
15657: LD_STRING Kirilenkova
15659: PPUSH
15660: LD_INT 3
15662: PPUSH
15663: CALL 6048 0 3
// ExtSaveCharacter ( Belkov , Belkov , 3 ) ;
15667: LD_EXP 66
15671: PPUSH
15672: LD_STRING Belkov
15674: PPUSH
15675: LD_INT 3
15677: PPUSH
15678: CALL 6048 0 3
// ExtSaveCharacter ( Belkov2 , Belkov2 , 3 ) ;
15682: LD_EXP 67
15686: PPUSH
15687: LD_STRING Belkov2
15689: PPUSH
15690: LD_INT 3
15692: PPUSH
15693: CALL 6048 0 3
// ExtSaveCharacter ( Xavier , Xavier , 3 ) ;
15697: LD_EXP 68
15701: PPUSH
15702: LD_STRING Xavier
15704: PPUSH
15705: LD_INT 3
15707: PPUSH
15708: CALL 6048 0 3
// ExtSaveCharacter ( Kozlov , Kozlov , 3 ) ;
15712: LD_EXP 73
15716: PPUSH
15717: LD_STRING Kozlov
15719: PPUSH
15720: LD_INT 3
15722: PPUSH
15723: CALL 6048 0 3
// ExtSaveCharacter ( Oblukov , Oblukov , 3 ) ;
15727: LD_EXP 74
15731: PPUSH
15732: LD_STRING Oblukov
15734: PPUSH
15735: LD_INT 3
15737: PPUSH
15738: CALL 6048 0 3
// ExtSaveCharacter ( Kapitsova , Kapitsova , 3 ) ;
15742: LD_EXP 75
15746: PPUSH
15747: LD_STRING Kapitsova
15749: PPUSH
15750: LD_INT 3
15752: PPUSH
15753: CALL 6048 0 3
// ExtSaveCharacter ( Gnyevko , Gnyevko , 3 ) ;
15757: LD_EXP 69
15761: PPUSH
15762: LD_STRING Gnyevko
15764: PPUSH
15765: LD_INT 3
15767: PPUSH
15768: CALL 6048 0 3
// ExtSaveCharacter ( Kovalyuk , Kovalyuk , 3 ) ;
15772: LD_EXP 70
15776: PPUSH
15777: LD_STRING Kovalyuk
15779: PPUSH
15780: LD_INT 3
15782: PPUSH
15783: CALL 6048 0 3
// ExtSaveCharacter ( Scholtze , Scholtze , 3 ) ;
15787: LD_EXP 71
15791: PPUSH
15792: LD_STRING Scholtze
15794: PPUSH
15795: LD_INT 3
15797: PPUSH
15798: CALL 6048 0 3
// ExtSaveCharacter ( Kuzmov , Kuzmov , 3 ) ;
15802: LD_EXP 72
15806: PPUSH
15807: LD_STRING Kuzmov
15809: PPUSH
15810: LD_INT 3
15812: PPUSH
15813: CALL 6048 0 3
// ExtSaveCharacters ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_or , [ f_class , class_apeman ] , [ f_class , class_apeman_engineer ] , [ f_class , class_apeman_soldier ] ] ] ) , other_apemans , 3 ) ;
15817: LD_INT 22
15819: PUSH
15820: LD_INT 3
15822: PUSH
15823: EMPTY
15824: LIST
15825: LIST
15826: PUSH
15827: LD_INT 21
15829: PUSH
15830: LD_INT 1
15832: PUSH
15833: EMPTY
15834: LIST
15835: LIST
15836: PUSH
15837: LD_INT 2
15839: PUSH
15840: LD_INT 25
15842: PUSH
15843: LD_INT 12
15845: PUSH
15846: EMPTY
15847: LIST
15848: LIST
15849: PUSH
15850: LD_INT 25
15852: PUSH
15853: LD_INT 16
15855: PUSH
15856: EMPTY
15857: LIST
15858: LIST
15859: PUSH
15860: LD_INT 25
15862: PUSH
15863: LD_INT 15
15865: PUSH
15866: EMPTY
15867: LIST
15868: LIST
15869: PUSH
15870: EMPTY
15871: LIST
15872: LIST
15873: LIST
15874: LIST
15875: PUSH
15876: EMPTY
15877: LIST
15878: LIST
15879: LIST
15880: PPUSH
15881: CALL_OW 69
15885: PPUSH
15886: LD_STRING other_apemans
15888: PPUSH
15889: LD_INT 3
15891: PPUSH
15892: CALL 6105 0 3
// randomsToSave = FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_nation , nation_russian ] ] ) diff [ Burlak , Karamazov , Petrovova , Gleb , Petrosyan , Titov , Dolgov , Lipshchin , Kirilenkova , Belkov , Belkov2 , Xavier , Gnyevko , Kovalyuk , Scholtze , Kuzmov , Kozlov , Oblukov , Kapitsova ] ;
15896: LD_ADDR_VAR 0 2
15900: PUSH
15901: LD_INT 22
15903: PUSH
15904: LD_INT 3
15906: PUSH
15907: EMPTY
15908: LIST
15909: LIST
15910: PUSH
15911: LD_INT 21
15913: PUSH
15914: LD_INT 1
15916: PUSH
15917: EMPTY
15918: LIST
15919: LIST
15920: PUSH
15921: LD_INT 23
15923: PUSH
15924: LD_INT 3
15926: PUSH
15927: EMPTY
15928: LIST
15929: LIST
15930: PUSH
15931: EMPTY
15932: LIST
15933: LIST
15934: LIST
15935: PPUSH
15936: CALL_OW 69
15940: PUSH
15941: LD_EXP 57
15945: PUSH
15946: LD_EXP 58
15950: PUSH
15951: LD_EXP 59
15955: PUSH
15956: LD_EXP 60
15960: PUSH
15961: LD_EXP 61
15965: PUSH
15966: LD_EXP 62
15970: PUSH
15971: LD_EXP 63
15975: PUSH
15976: LD_EXP 64
15980: PUSH
15981: LD_EXP 65
15985: PUSH
15986: LD_EXP 66
15990: PUSH
15991: LD_EXP 67
15995: PUSH
15996: LD_EXP 68
16000: PUSH
16001: LD_EXP 69
16005: PUSH
16006: LD_EXP 70
16010: PUSH
16011: LD_EXP 71
16015: PUSH
16016: LD_EXP 72
16020: PUSH
16021: LD_EXP 73
16025: PUSH
16026: LD_EXP 74
16030: PUSH
16031: LD_EXP 75
16035: PUSH
16036: EMPTY
16037: LIST
16038: LIST
16039: LIST
16040: LIST
16041: LIST
16042: LIST
16043: LIST
16044: LIST
16045: LIST
16046: LIST
16047: LIST
16048: LIST
16049: LIST
16050: LIST
16051: LIST
16052: LIST
16053: LIST
16054: LIST
16055: LIST
16056: DIFF
16057: ST_TO_ADDR
// ExtSaveCharacters ( randomsToSave , other_survivors , 3 ) ;
16058: LD_VAR 0 2
16062: PPUSH
16063: LD_STRING other_survivors
16065: PPUSH
16066: LD_INT 3
16068: PPUSH
16069: CALL 6105 0 3
// end ;
16073: LD_VAR 0 1
16077: RET
// function SaveGlobalVariables ; begin
16078: LD_INT 0
16080: PPUSH
// SaveBase ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_building ] ] ) , 08_TrockyBase_1 ) ;
16081: LD_INT 22
16083: PUSH
16084: LD_INT 3
16086: PUSH
16087: EMPTY
16088: LIST
16089: LIST
16090: PUSH
16091: LD_INT 21
16093: PUSH
16094: LD_INT 3
16096: PUSH
16097: EMPTY
16098: LIST
16099: LIST
16100: PUSH
16101: EMPTY
16102: LIST
16103: LIST
16104: PPUSH
16105: CALL_OW 69
16109: PPUSH
16110: LD_STRING 08_TrockyBase_1
16112: PPUSH
16113: CALL 8484 0 2
// SaveVariable ( coopWithGensher , 08_CoopWithGensher_2 ) ;
16117: LD_EXP 2
16121: PPUSH
16122: LD_STRING 08_CoopWithGensher_2
16124: PPUSH
16125: CALL_OW 39
// SaveVariable ( HeikeStatus , 08_HeikeStatus_3 ) ;
16129: LD_EXP 3
16133: PPUSH
16134: LD_STRING 08_HeikeStatus_3
16136: PPUSH
16137: CALL_OW 39
// SaveVariable ( Masha , 08_Masha_4 ) ;
16141: LD_EXP 4
16145: PPUSH
16146: LD_STRING 08_Masha_4
16148: PPUSH
16149: CALL_OW 39
// end ; end_of_file
16153: LD_VAR 0 1
16157: RET
// export function CustomEvent ( event ) ; begin
16158: LD_INT 0
16160: PPUSH
// end ;
16161: LD_VAR 0 2
16165: RET
// on BuildingComplete ( building ) do begin if GetBType ( building ) in buildingsToBuild and GetNation ( building ) = nation_russian then
16166: LD_VAR 0 1
16170: PPUSH
16171: CALL_OW 266
16175: PUSH
16176: LD_EXP 8
16180: IN
16181: PUSH
16182: LD_VAR 0 1
16186: PPUSH
16187: CALL_OW 248
16191: PUSH
16192: LD_INT 3
16194: EQUAL
16195: AND
16196: IFFALSE 16219
// buildingsToBuild = buildingsToBuild diff GetBType ( building ) ;
16198: LD_ADDR_EXP 8
16202: PUSH
16203: LD_EXP 8
16207: PUSH
16208: LD_VAR 0 1
16212: PPUSH
16213: CALL_OW 266
16217: DIFF
16218: ST_TO_ADDR
// if GetBType ( building ) = b_depot then
16219: LD_VAR 0 1
16223: PPUSH
16224: CALL_OW 266
16228: PUSH
16229: LD_INT 0
16231: EQUAL
16232: IFFALSE 16283
// begin SetBName ( building , trockij ) ;
16234: LD_VAR 0 1
16238: PPUSH
16239: LD_STRING trockij
16241: PPUSH
16242: CALL_OW 500
// if not dial_BuildDepotBlocker and HeikeCaptured then
16246: LD_EXP 5
16250: NOT
16251: PUSH
16252: LD_EXP 1
16256: AND
16257: IFFALSE 16283
// Dial_EscortHeike ( GetX ( building ) , GetY ( building ) ) ;
16259: LD_VAR 0 1
16263: PPUSH
16264: CALL_OW 250
16268: PPUSH
16269: LD_VAR 0 1
16273: PPUSH
16274: CALL_OW 251
16278: PPUSH
16279: CALL 9149 0 2
// end ; end ;
16283: PPOPN 1
16285: END
// on UpgradeComplete ( building ) do begin if GetBType ( building ) in buildingsToBuild and GetNation ( building ) = nation_russian then
16286: LD_VAR 0 1
16290: PPUSH
16291: CALL_OW 266
16295: PUSH
16296: LD_EXP 8
16300: IN
16301: PUSH
16302: LD_VAR 0 1
16306: PPUSH
16307: CALL_OW 248
16311: PUSH
16312: LD_INT 3
16314: EQUAL
16315: AND
16316: IFFALSE 16339
// buildingsToBuild = buildingsToBuild diff GetBType ( building ) ;
16318: LD_ADDR_EXP 8
16322: PUSH
16323: LD_EXP 8
16327: PUSH
16328: LD_VAR 0 1
16332: PPUSH
16333: CALL_OW 266
16337: DIFF
16338: ST_TO_ADDR
// if GetBType ( building ) = b_barracks and GetNation ( building ) = 2 and not dial_BuildArBarrackBlocker then
16339: LD_VAR 0 1
16343: PPUSH
16344: CALL_OW 266
16348: PUSH
16349: LD_INT 5
16351: EQUAL
16352: PUSH
16353: LD_VAR 0 1
16357: PPUSH
16358: CALL_OW 248
16362: PUSH
16363: LD_INT 2
16365: EQUAL
16366: AND
16367: PUSH
16368: LD_EXP 6
16372: NOT
16373: AND
16374: IFFALSE 16380
// Dial_UpgradeArmoury ;
16376: CALL 9960 0 0
// end ;
16380: PPOPN 1
16382: END
// on ResearchComplete ( research , building ) do begin if research in techsToResearch then
16383: LD_VAR 0 1
16387: PUSH
16388: LD_EXP 9
16392: IN
16393: IFFALSE 16411
// techsToResearch = techsToResearch diff research ;
16395: LD_ADDR_EXP 9
16399: PUSH
16400: LD_EXP 9
16404: PUSH
16405: LD_VAR 0 1
16409: DIFF
16410: ST_TO_ADDR
// if research = tech_LimTeleport then
16411: LD_VAR 0 1
16415: PUSH
16416: LD_INT 37
16418: EQUAL
16419: IFFALSE 16425
// Dial_TeleportTechResearched ;
16421: CALL 13805 0 0
// if research = tech_AdvAI then
16425: LD_VAR 0 1
16429: PUSH
16430: LD_INT 27
16432: EQUAL
16433: IFFALSE 16439
// Dial_ComputerTechResearched ;
16435: CALL 13674 0 0
// end ;
16439: PPOPN 2
16441: END
// on EnterVehicle ( vehicle , human ) do begin if not canChooseMashaVehicle then
16442: LD_EXP 36
16446: NOT
16447: IFFALSE 16451
// exit ;
16449: GO 16618
// wait ( 0 0$1 ) ;
16451: LD_INT 35
16453: PPUSH
16454: CALL_OW 67
// if GetSide ( vehicle ) = 3 and human = Burlak and GetNation ( vehicle ) = nation_russian and GetWeapon ( vehicle ) in [ ru_heavy_machine_gun , ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher ] then
16458: LD_VAR 0 1
16462: PPUSH
16463: CALL_OW 255
16467: PUSH
16468: LD_INT 3
16470: EQUAL
16471: PUSH
16472: LD_VAR 0 2
16476: PUSH
16477: LD_EXP 57
16481: EQUAL
16482: AND
16483: PUSH
16484: LD_VAR 0 1
16488: PPUSH
16489: CALL_OW 248
16493: PUSH
16494: LD_INT 3
16496: EQUAL
16497: AND
16498: PUSH
16499: LD_VAR 0 1
16503: PPUSH
16504: CALL_OW 264
16508: PUSH
16509: LD_INT 42
16511: PUSH
16512: LD_INT 43
16514: PUSH
16515: LD_INT 44
16517: PUSH
16518: LD_INT 46
16520: PUSH
16521: LD_INT 45
16523: PUSH
16524: EMPTY
16525: LIST
16526: LIST
16527: LIST
16528: LIST
16529: LIST
16530: IN
16531: AND
16532: IFFALSE 16618
// begin if Masha then
16534: LD_EXP 4
16538: IFFALSE 16558
// if Masha [ 1 ] = vehicle then
16540: LD_EXP 4
16544: PUSH
16545: LD_INT 1
16547: ARRAY
16548: PUSH
16549: LD_VAR 0 1
16553: EQUAL
16554: IFFALSE 16558
// exit ;
16556: GO 16618
// if firstMashaQuery then
16558: LD_EXP 35
16562: IFFALSE 16596
// begin firstMashaQuery = false ;
16564: LD_ADDR_EXP 35
16568: PUSH
16569: LD_INT 0
16571: ST_TO_ADDR
// if Query ( QMashaQuery ) = 1 then
16572: LD_STRING QMashaQuery
16574: PPUSH
16575: CALL_OW 97
16579: PUSH
16580: LD_INT 1
16582: EQUAL
16583: IFFALSE 16594
// SetMashaData ( vehicle ) ;
16585: LD_VAR 0 1
16589: PPUSH
16590: CALL 8378 0 1
// end else
16594: GO 16618
// begin if Query ( QMashaQuery2 ) = 1 then
16596: LD_STRING QMashaQuery2
16598: PPUSH
16599: CALL_OW 97
16603: PUSH
16604: LD_INT 1
16606: EQUAL
16607: IFFALSE 16618
// SetMashaData ( vehicle ) ;
16609: LD_VAR 0 1
16613: PPUSH
16614: CALL 8378 0 1
// end ; end ; end ;
16618: PPOPN 2
16620: END
// on UnitDestroyed ( unit ) do begin if Masha then
16621: LD_EXP 4
16625: IFFALSE 16650
// if unit = Masha [ 1 ] then
16627: LD_VAR 0 1
16631: PUSH
16632: LD_EXP 4
16636: PUSH
16637: LD_INT 1
16639: ARRAY
16640: EQUAL
16641: IFFALSE 16650
// Masha = [ ] ;
16643: LD_ADDR_EXP 4
16647: PUSH
16648: EMPTY
16649: ST_TO_ADDR
// if unit = Burlak then
16650: LD_VAR 0 1
16654: PUSH
16655: LD_EXP 57
16659: EQUAL
16660: IFFALSE 16666
// Lose_Burlak ;
16662: CALL 15213 0 0
// if GetType ( unit ) = unit_human and GetNation ( unit ) = nation_russian then
16666: LD_VAR 0 1
16670: PPUSH
16671: CALL_OW 247
16675: PUSH
16676: LD_INT 1
16678: EQUAL
16679: PUSH
16680: LD_VAR 0 1
16684: PPUSH
16685: CALL_OW 248
16689: PUSH
16690: LD_INT 3
16692: EQUAL
16693: AND
16694: IFFALSE 16710
// lostUnits = lostUnits + 1 ;
16696: LD_ADDR_EXP 40
16700: PUSH
16701: LD_EXP 40
16705: PUSH
16706: LD_INT 1
16708: PLUS
16709: ST_TO_ADDR
// end ;
16710: PPOPN 1
16712: END
// on UnitGoesToRed ( unit ) do begin if GetType ( unit ) = unit_vehicle and GetNation ( unit ) = nation_russian and GetTech ( tech_LimTeleport , 3 ) = state_researched and not testedTeleport then
16713: LD_VAR 0 1
16717: PPUSH
16718: CALL_OW 247
16722: PUSH
16723: LD_INT 2
16725: EQUAL
16726: PUSH
16727: LD_VAR 0 1
16731: PPUSH
16732: CALL_OW 248
16736: PUSH
16737: LD_INT 3
16739: EQUAL
16740: AND
16741: PUSH
16742: LD_INT 37
16744: PPUSH
16745: LD_INT 3
16747: PPUSH
16748: CALL_OW 321
16752: PUSH
16753: LD_INT 2
16755: EQUAL
16756: AND
16757: PUSH
16758: LD_EXP 39
16762: NOT
16763: AND
16764: IFFALSE 16781
// begin testedTeleport = true ;
16766: LD_ADDR_EXP 39
16770: PUSH
16771: LD_INT 1
16773: ST_TO_ADDR
// ChangeMissionObjectives ( MTeleDone ) ;
16774: LD_STRING MTeleDone
16776: PPUSH
16777: CALL_OW 337
// end ; if unit = Heike then
16781: LD_VAR 0 1
16785: PUSH
16786: LD_EXP 79
16790: EQUAL
16791: IFFALSE 16834
// begin DialogueOn ;
16793: CALL_OW 6
// CenterNowOnUnits ( Heike ) ;
16797: LD_EXP 79
16801: PPUSH
16802: CALL_OW 87
// ForceSay ( Heike , DHeikeKilled-Hke-1 ) ;
16806: LD_EXP 79
16810: PPUSH
16811: LD_STRING DHeikeKilled-Hke-1
16813: PPUSH
16814: CALL_OW 91
// DialogueOff ;
16818: CALL_OW 7
// SetLives ( Heike , 0 ) ;
16822: LD_EXP 79
16826: PPUSH
16827: LD_INT 0
16829: PPUSH
16830: CALL_OW 234
// end ; end ;
16834: PPOPN 1
16836: END
// on Contact ( side1 , side2 ) do begin if side1 = 3 and side2 = 6 then
16837: LD_VAR 0 1
16841: PUSH
16842: LD_INT 3
16844: EQUAL
16845: PUSH
16846: LD_VAR 0 2
16850: PUSH
16851: LD_INT 6
16853: EQUAL
16854: AND
16855: IFFALSE 16861
// Lost_AttackAlly ;
16857: CALL 15228 0 0
// if side1 = 3 and side2 = 2 then
16861: LD_VAR 0 1
16865: PUSH
16866: LD_INT 3
16868: EQUAL
16869: PUSH
16870: LD_VAR 0 2
16874: PUSH
16875: LD_INT 2
16877: EQUAL
16878: AND
16879: IFFALSE 16885
// Dial_AttackGensher ;
16881: CALL 10916 0 0
// if side1 = 3 and side2 = 5 then
16885: LD_VAR 0 1
16889: PUSH
16890: LD_INT 3
16892: EQUAL
16893: PUSH
16894: LD_VAR 0 2
16898: PUSH
16899: LD_INT 5
16901: EQUAL
16902: AND
16903: IFFALSE 16947
// begin SetAttitude ( 3 , 5 , att_enemy , true ) ;
16905: LD_INT 3
16907: PPUSH
16908: LD_INT 5
16910: PPUSH
16911: LD_INT 2
16913: PPUSH
16914: LD_INT 1
16916: PPUSH
16917: CALL_OW 80
// if acceptKurtOffert and not GetSide ( Kurt ) = 2 then
16921: LD_EXP 19
16925: PUSH
16926: LD_EXP 80
16930: PPUSH
16931: CALL_OW 255
16935: PUSH
16936: LD_INT 2
16938: EQUAL
16939: NOT
16940: AND
16941: IFFALSE 16947
// Dial_BetrayedKurt1 ;
16943: CALL 11465 0 0
// end ; if side1 = 3 and side2 = 8 and GetAttitude ( 3 , 8 ) = att_neutral then
16947: LD_VAR 0 1
16951: PUSH
16952: LD_INT 3
16954: EQUAL
16955: PUSH
16956: LD_VAR 0 2
16960: PUSH
16961: LD_INT 8
16963: EQUAL
16964: AND
16965: PUSH
16966: LD_INT 3
16968: PPUSH
16969: LD_INT 8
16971: PPUSH
16972: CALL_OW 81
16976: PUSH
16977: LD_INT 0
16979: EQUAL
16980: AND
16981: IFFALSE 16993
// begin if acceptKurtOffert then
16983: LD_EXP 19
16987: IFFALSE 16993
// Dial_BetrayedKurt2 ;
16989: CALL 11551 0 0
// end ; end ;
16993: PPOPN 2
16995: END
// on VehicleConstructed ( vehicle , building ) do begin SetWeaponDataBuild ( GetWeapon ( vehicle ) , false ) ;
16996: LD_VAR 0 1
17000: PPUSH
17001: CALL_OW 264
17005: PPUSH
17006: LD_INT 0
17008: PPUSH
17009: CALL 6886 0 2
// if GetControl ( vehicle ) = control_computer and not buildCompVehicle then
17013: LD_VAR 0 1
17017: PPUSH
17018: CALL_OW 263
17022: PUSH
17023: LD_INT 3
17025: EQUAL
17026: PUSH
17027: LD_EXP 37
17031: NOT
17032: AND
17033: IFFALSE 17050
// begin buildCompVehicle = true ;
17035: LD_ADDR_EXP 37
17039: PUSH
17040: LD_INT 1
17042: ST_TO_ADDR
// ChangeMissionObjectives ( MAIDone ) ;
17043: LD_STRING MAIDone
17045: PPUSH
17046: CALL_OW 337
// end ; end ;
17050: PPOPN 2
17052: END
// on WeaponPlaced ( building , factory ) do begin SetWeaponDataBuild ( GetBWeapon ( building ) , true ) ;
17053: LD_VAR 0 1
17057: PPUSH
17058: CALL_OW 269
17062: PPUSH
17063: LD_INT 1
17065: PPUSH
17066: CALL 6886 0 2
// end ;
17070: PPOPN 2
17072: END
// on Command ( comandid ) do var i ;
17073: LD_INT 0
17075: PPUSH
// begin if IsOK ( KurtEng ) and GetSide ( KurtEng ) = 3 then
17076: LD_EXP 82
17080: PPUSH
17081: CALL_OW 302
17085: PUSH
17086: LD_EXP 82
17090: PPUSH
17091: CALL_OW 255
17095: PUSH
17096: LD_INT 3
17098: EQUAL
17099: AND
17100: IFFALSE 17309
// if GetTaskList ( KurtEng ) then
17102: LD_EXP 82
17106: PPUSH
17107: CALL_OW 437
17111: IFFALSE 17309
// begin for i := 1 to ( GetTaskList ( KurtEng ) ) do
17113: LD_ADDR_VAR 0 2
17117: PUSH
17118: DOUBLE
17119: LD_INT 1
17121: DEC
17122: ST_TO_ADDR
17123: LD_EXP 82
17127: PPUSH
17128: CALL_OW 437
17132: PUSH
17133: FOR_TO
17134: IFFALSE 17307
// begin if ( GetTaskList ( KurtEng ) [ i ] [ 1 ] in [ F , H , M , U , V , a , h , u , v , ~ , ^ , > , + , ; , 4 , { ] ) or ( GetTaskList ( KurtEng ) [ i ] [ 1 ] = B and GetTaskList ( KurtEng ) [ i ] [ 5 ] = 36 ) then
17136: LD_EXP 82
17140: PPUSH
17141: CALL_OW 437
17145: PUSH
17146: LD_VAR 0 2
17150: ARRAY
17151: PUSH
17152: LD_INT 1
17154: ARRAY
17155: PUSH
17156: LD_STRING F
17158: PUSH
17159: LD_STRING H
17161: PUSH
17162: LD_STRING M
17164: PUSH
17165: LD_STRING U
17167: PUSH
17168: LD_STRING V
17170: PUSH
17171: LD_STRING a
17173: PUSH
17174: LD_STRING h
17176: PUSH
17177: LD_STRING u
17179: PUSH
17180: LD_STRING v
17182: PUSH
17183: LD_STRING ~
17185: PUSH
17186: LD_STRING ^
17188: PUSH
17189: LD_STRING >
17191: PUSH
17192: LD_STRING +
17194: PUSH
17195: LD_STRING ;
17197: PUSH
17198: LD_STRING 4
17200: PUSH
17201: LD_STRING {
17203: PUSH
17204: EMPTY
17205: LIST
17206: LIST
17207: LIST
17208: LIST
17209: LIST
17210: LIST
17211: LIST
17212: LIST
17213: LIST
17214: LIST
17215: LIST
17216: LIST
17217: LIST
17218: LIST
17219: LIST
17220: LIST
17221: IN
17222: PUSH
17223: LD_EXP 82
17227: PPUSH
17228: CALL_OW 437
17232: PUSH
17233: LD_VAR 0 2
17237: ARRAY
17238: PUSH
17239: LD_INT 1
17241: ARRAY
17242: PUSH
17243: LD_STRING B
17245: EQUAL
17246: PUSH
17247: LD_EXP 82
17251: PPUSH
17252: CALL_OW 437
17256: PUSH
17257: LD_VAR 0 2
17261: ARRAY
17262: PUSH
17263: LD_INT 5
17265: ARRAY
17266: PUSH
17267: LD_INT 36
17269: EQUAL
17270: AND
17271: OR
17272: IFFALSE 17276
// else
17274: GO 17305
// begin RemoveTasks ( KurtEng ) ;
17276: LD_EXP 82
17280: PPUSH
17281: CALL_OW 493
// DialogueOn ;
17285: CALL_OW 6
// Say ( Kurt , DMercRefuseBuild-Kurt-1 ) ;
17289: LD_EXP 80
17293: PPUSH
17294: LD_STRING DMercRefuseBuild-Kurt-1
17296: PPUSH
17297: CALL_OW 88
// DialogueOff ;
17301: CALL_OW 7
// end ; end ;
17305: GO 17133
17307: POP
17308: POP
// end ; end ; end_of_file
17309: PPOPN 2
17311: END
// every 0 0$01 do var timer , cratesSpawned ;
17312: GO 17314
17314: DISABLE
17315: LD_INT 0
17317: PPUSH
17318: PPUSH
// begin timer := 1 1$30 ;
17319: LD_ADDR_VAR 0 1
17323: PUSH
17324: LD_INT 3150
17326: ST_TO_ADDR
// repeat wait ( timer ) ;
17327: LD_VAR 0 1
17331: PPUSH
17332: CALL_OW 67
// if cratesSpawned >= 6 and cratesSpawned < 18 then
17336: LD_VAR 0 2
17340: PUSH
17341: LD_INT 6
17343: GREATEREQUAL
17344: PUSH
17345: LD_VAR 0 2
17349: PUSH
17350: LD_INT 18
17352: LESS
17353: AND
17354: IFFALSE 17370
// timer := timer + 0 0$3 ;
17356: LD_ADDR_VAR 0 1
17360: PUSH
17361: LD_VAR 0 1
17365: PUSH
17366: LD_INT 105
17368: PLUS
17369: ST_TO_ADDR
// if cratesSpawned >= 18 then
17370: LD_VAR 0 2
17374: PUSH
17375: LD_INT 18
17377: GREATEREQUAL
17378: IFFALSE 17394
// timer := timer + 0 0$9 ;
17380: LD_ADDR_VAR 0 1
17384: PUSH
17385: LD_VAR 0 1
17389: PUSH
17390: LD_INT 315
17392: PLUS
17393: ST_TO_ADDR
// if timer > 3 3$00 then
17394: LD_VAR 0 1
17398: PUSH
17399: LD_INT 6300
17401: GREATER
17402: IFFALSE 17412
// timer := 0 0$50 ;
17404: LD_ADDR_VAR 0 1
17408: PUSH
17409: LD_INT 1750
17411: ST_TO_ADDR
// CreateCratesArea ( rand ( 3 , 5 ) , CratesSpawnArea , true ) ;
17412: LD_INT 3
17414: PPUSH
17415: LD_INT 5
17417: PPUSH
17418: CALL_OW 12
17422: PPUSH
17423: LD_INT 15
17425: PPUSH
17426: LD_INT 1
17428: PPUSH
17429: CALL_OW 55
// cratesSpawned = cratesSpawned + 1 ;
17433: LD_ADDR_VAR 0 2
17437: PUSH
17438: LD_VAR 0 2
17442: PUSH
17443: LD_INT 1
17445: PLUS
17446: ST_TO_ADDR
// until false ;
17447: LD_INT 0
17449: IFFALSE 17327
// end ; end_of_file
17451: PPOPN 2
17453: END
// every 0 0$1 do
17454: GO 17456
17456: DISABLE
// begin enable ;
17457: ENABLE
// end ;
17458: END
// every 0 0$1 do var building , playerBuildings , playerBuildingsBType ;
17459: GO 17461
17461: DISABLE
17462: LD_INT 0
17464: PPUSH
17465: PPUSH
17466: PPUSH
// begin playerBuildings = FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_building ] , [ f_nation , nation_russian ] ] ) ;
17467: LD_ADDR_VAR 0 2
17471: PUSH
17472: LD_INT 22
17474: PUSH
17475: LD_INT 3
17477: PUSH
17478: EMPTY
17479: LIST
17480: LIST
17481: PUSH
17482: LD_INT 21
17484: PUSH
17485: LD_INT 3
17487: PUSH
17488: EMPTY
17489: LIST
17490: LIST
17491: PUSH
17492: LD_INT 23
17494: PUSH
17495: LD_INT 3
17497: PUSH
17498: EMPTY
17499: LIST
17500: LIST
17501: PUSH
17502: EMPTY
17503: LIST
17504: LIST
17505: LIST
17506: PPUSH
17507: CALL_OW 69
17511: ST_TO_ADDR
// playerBuildingsBType = [ ] ;
17512: LD_ADDR_VAR 0 3
17516: PUSH
17517: EMPTY
17518: ST_TO_ADDR
// for building in playerBuildings do
17519: LD_ADDR_VAR 0 1
17523: PUSH
17524: LD_VAR 0 2
17528: PUSH
17529: FOR_IN
17530: IFFALSE 17555
// playerBuildingsBType = playerBuildingsBType ^ GetBType ( building ) ;
17532: LD_ADDR_VAR 0 3
17536: PUSH
17537: LD_VAR 0 3
17541: PUSH
17542: LD_VAR 0 1
17546: PPUSH
17547: CALL_OW 266
17551: ADD
17552: ST_TO_ADDR
17553: GO 17529
17555: POP
17556: POP
// for building in allBuildings do
17557: LD_ADDR_VAR 0 1
17561: PUSH
17562: LD_EXP 13
17566: PUSH
17567: FOR_IN
17568: IFFALSE 17614
// if not building in playerBuildingsBType and not building in buildingsToBuild then
17570: LD_VAR 0 1
17574: PUSH
17575: LD_VAR 0 3
17579: IN
17580: NOT
17581: PUSH
17582: LD_VAR 0 1
17586: PUSH
17587: LD_EXP 8
17591: IN
17592: NOT
17593: AND
17594: IFFALSE 17612
// buildingsToBuild = buildingsToBuild ^ building ;
17596: LD_ADDR_EXP 8
17600: PUSH
17601: LD_EXP 8
17605: PUSH
17606: LD_VAR 0 1
17610: ADD
17611: ST_TO_ADDR
17612: GO 17567
17614: POP
17615: POP
// enable ;
17616: ENABLE
// end ;
17617: PPOPN 3
17619: END
// every 0 0$1 trigger legionOffertCountdown do
17620: LD_EXP 33
17624: IFFALSE 17644
17626: GO 17628
17628: DISABLE
// begin legionOffertTime = legionOffertTime - 0 0$01 ;
17629: LD_ADDR_EXP 34
17633: PUSH
17634: LD_EXP 34
17638: PUSH
17639: LD_INT 35
17641: MINUS
17642: ST_TO_ADDR
// enable ;
17643: ENABLE
// end ;
17644: END
// every 0 0$1 trigger KurtWaitingForFreeHeike do
17645: LD_EXP 23
17649: IFFALSE 17683
17651: GO 17653
17653: DISABLE
// begin timeToFreeHeike = timeToFreeHeike - 0 0$01 ;
17654: LD_ADDR_EXP 54
17658: PUSH
17659: LD_EXP 54
17663: PUSH
17664: LD_INT 35
17666: MINUS
17667: ST_TO_ADDR
// if timeToFreeHeike <= 0 0$00 then
17668: LD_EXP 54
17672: PUSH
17673: LD_INT 0
17675: LESSEQUAL
17676: IFFALSE 17682
// Dial_PlayerDontSendHeike ;
17678: CALL 11413 0 0
// enable ;
17682: ENABLE
// end ;
17683: END
// every 0 0$1 trigger KurtWaitingForBuildBarrack and GetSide ( KurtEng ) = 3 do
17684: LD_EXP 24
17688: PUSH
17689: LD_EXP 82
17693: PPUSH
17694: CALL_OW 255
17698: PUSH
17699: LD_INT 3
17701: EQUAL
17702: AND
17703: IFFALSE 17776
17705: GO 17707
17707: DISABLE
// begin timeToBuildArBarrack = timeToBuildArBarrack - 0 0$01 ;
17708: LD_ADDR_EXP 55
17712: PUSH
17713: LD_EXP 55
17717: PUSH
17718: LD_INT 35
17720: MINUS
17721: ST_TO_ADDR
// if timeToBuildArBarrack <= 0 0$00 then
17722: LD_EXP 55
17726: PUSH
17727: LD_INT 0
17729: LESSEQUAL
17730: IFFALSE 17775
// begin Dial_BetrayedKurt1 ;
17732: CALL 11465 0 0
// wait ( 2 2$0 ) ;
17736: LD_INT 4200
17738: PPUSH
17739: CALL_OW 67
// SetAttitude ( 3 , 8 , att_enemy , true ) ;
17743: LD_INT 3
17745: PPUSH
17746: LD_INT 8
17748: PPUSH
17749: LD_INT 2
17751: PPUSH
17752: LD_INT 1
17754: PPUSH
17755: CALL_OW 80
// KurtAttack = true ;
17759: LD_ADDR_EXP 25
17763: PUSH
17764: LD_INT 1
17766: ST_TO_ADDR
// KurtWaitingForBuildBarrack = false ;
17767: LD_ADDR_EXP 24
17771: PUSH
17772: LD_INT 0
17774: ST_TO_ADDR
// end ; enable ;
17775: ENABLE
// end ; end_of_file
17776: END
// export currentAmWave , currentArWave ; every 0 0$1 trigger americansAttack do var i ;
17777: LD_EXP 26
17781: IFFALSE 17927
17783: GO 17785
17785: DISABLE
17786: LD_INT 0
17788: PPUSH
// begin currentAmWave = 0 ;
17789: LD_ADDR_EXP 85
17793: PUSH
17794: LD_INT 0
17796: ST_TO_ADDR
// wait ( firstAttackDelay ) ;
17797: LD_EXP 49
17801: PPUSH
17802: CALL_OW 67
// for i := 1 to americansAttackWaves do
17806: LD_ADDR_VAR 0 1
17810: PUSH
17811: DOUBLE
17812: LD_INT 1
17814: DEC
17815: ST_TO_ADDR
17816: LD_EXP 48
17820: PUSH
17821: FOR_TO
17822: IFFALSE 17925
// begin SpawnAmAttackTeam ;
17824: CALL 3214 0 0
// currentAmWave = currentAmWave + 1 ;
17828: LD_ADDR_EXP 85
17832: PUSH
17833: LD_EXP 85
17837: PUSH
17838: LD_INT 1
17840: PLUS
17841: ST_TO_ADDR
// if currentAmWave = 1 then
17842: LD_EXP 85
17846: PUSH
17847: LD_INT 1
17849: EQUAL
17850: IFFALSE 17914
// begin if paidLegionOffert then
17852: LD_EXP 32
17856: IFFALSE 17895
// begin Say ( Burlak , DAmAttackStart-Bur-1 ) ;
17858: LD_EXP 57
17862: PPUSH
17863: LD_STRING DAmAttackStart-Bur-1
17865: PPUSH
17866: CALL_OW 88
// if IsOK ( Gleb ) then
17870: LD_EXP 60
17874: PPUSH
17875: CALL_OW 302
17879: IFFALSE 17893
// Say ( Gleb , DAmAttackStart-Glb-1 ) ;
17881: LD_EXP 60
17885: PPUSH
17886: LD_STRING DAmAttackStart-Glb-1
17888: PPUSH
17889: CALL_OW 88
// end else
17893: GO 17907
// Say ( Burlak , DAmAttackStart-Bur-2 ) ;
17895: LD_EXP 57
17899: PPUSH
17900: LD_STRING DAmAttackStart-Bur-2
17902: PPUSH
17903: CALL_OW 88
// ChangeMissionObjectives ( MEnemy ) ;
17907: LD_STRING MEnemy
17909: PPUSH
17910: CALL_OW 337
// end ; wait ( waveCooldown ) ;
17914: LD_EXP 50
17918: PPUSH
17919: CALL_OW 67
// end ;
17923: GO 17821
17925: POP
17926: POP
// end ;
17927: PPOPN 1
17929: END
// every 0 0$1 trigger currentAmWave = 1 do
17930: LD_EXP 85
17934: PUSH
17935: LD_INT 1
17937: EQUAL
17938: IFFALSE 18027
17940: GO 17942
17942: DISABLE
// Attack ( [ 0 , amAttackTeam , [ [ 115 , 42 ] , [ 51 , 67 ] ] , [ 0 , 0 , 0 , 1 , 1 , 1 , 0 , 0 , 1 , 0 ] ] ) ;
17943: LD_INT 0
17945: PUSH
17946: LD_EXP 78
17950: PUSH
17951: LD_INT 115
17953: PUSH
17954: LD_INT 42
17956: PUSH
17957: EMPTY
17958: LIST
17959: LIST
17960: PUSH
17961: LD_INT 51
17963: PUSH
17964: LD_INT 67
17966: PUSH
17967: EMPTY
17968: LIST
17969: LIST
17970: PUSH
17971: EMPTY
17972: LIST
17973: LIST
17974: PUSH
17975: LD_INT 0
17977: PUSH
17978: LD_INT 0
17980: PUSH
17981: LD_INT 0
17983: PUSH
17984: LD_INT 1
17986: PUSH
17987: LD_INT 1
17989: PUSH
17990: LD_INT 1
17992: PUSH
17993: LD_INT 0
17995: PUSH
17996: LD_INT 0
17998: PUSH
17999: LD_INT 1
18001: PUSH
18002: LD_INT 0
18004: PUSH
18005: EMPTY
18006: LIST
18007: LIST
18008: LIST
18009: LIST
18010: LIST
18011: LIST
18012: LIST
18013: LIST
18014: LIST
18015: LIST
18016: PUSH
18017: EMPTY
18018: LIST
18019: LIST
18020: LIST
18021: LIST
18022: PPUSH
18023: CALL 81021 0 1
18027: END
// every 0 0$1 trigger currentAmWave = 2 do
18028: LD_EXP 85
18032: PUSH
18033: LD_INT 2
18035: EQUAL
18036: IFFALSE 18125
18038: GO 18040
18040: DISABLE
// Attack ( [ 0 , amAttackTeam , [ [ 115 , 42 ] , [ 51 , 67 ] ] , [ 0 , 0 , 0 , 1 , 1 , 1 , 0 , 0 , 1 , 0 ] ] ) ;
18041: LD_INT 0
18043: PUSH
18044: LD_EXP 78
18048: PUSH
18049: LD_INT 115
18051: PUSH
18052: LD_INT 42
18054: PUSH
18055: EMPTY
18056: LIST
18057: LIST
18058: PUSH
18059: LD_INT 51
18061: PUSH
18062: LD_INT 67
18064: PUSH
18065: EMPTY
18066: LIST
18067: LIST
18068: PUSH
18069: EMPTY
18070: LIST
18071: LIST
18072: PUSH
18073: LD_INT 0
18075: PUSH
18076: LD_INT 0
18078: PUSH
18079: LD_INT 0
18081: PUSH
18082: LD_INT 1
18084: PUSH
18085: LD_INT 1
18087: PUSH
18088: LD_INT 1
18090: PUSH
18091: LD_INT 0
18093: PUSH
18094: LD_INT 0
18096: PUSH
18097: LD_INT 1
18099: PUSH
18100: LD_INT 0
18102: PUSH
18103: EMPTY
18104: LIST
18105: LIST
18106: LIST
18107: LIST
18108: LIST
18109: LIST
18110: LIST
18111: LIST
18112: LIST
18113: LIST
18114: PUSH
18115: EMPTY
18116: LIST
18117: LIST
18118: LIST
18119: LIST
18120: PPUSH
18121: CALL 81021 0 1
18125: END
// every 0 0$1 trigger currentAmWave = 3 do
18126: LD_EXP 85
18130: PUSH
18131: LD_INT 3
18133: EQUAL
18134: IFFALSE 18223
18136: GO 18138
18138: DISABLE
// Attack ( [ 0 , amAttackTeam , [ [ 115 , 42 ] , [ 51 , 67 ] ] , [ 0 , 0 , 0 , 1 , 1 , 1 , 0 , 0 , 1 , 0 ] ] ) ;
18139: LD_INT 0
18141: PUSH
18142: LD_EXP 78
18146: PUSH
18147: LD_INT 115
18149: PUSH
18150: LD_INT 42
18152: PUSH
18153: EMPTY
18154: LIST
18155: LIST
18156: PUSH
18157: LD_INT 51
18159: PUSH
18160: LD_INT 67
18162: PUSH
18163: EMPTY
18164: LIST
18165: LIST
18166: PUSH
18167: EMPTY
18168: LIST
18169: LIST
18170: PUSH
18171: LD_INT 0
18173: PUSH
18174: LD_INT 0
18176: PUSH
18177: LD_INT 0
18179: PUSH
18180: LD_INT 1
18182: PUSH
18183: LD_INT 1
18185: PUSH
18186: LD_INT 1
18188: PUSH
18189: LD_INT 0
18191: PUSH
18192: LD_INT 0
18194: PUSH
18195: LD_INT 1
18197: PUSH
18198: LD_INT 0
18200: PUSH
18201: EMPTY
18202: LIST
18203: LIST
18204: LIST
18205: LIST
18206: LIST
18207: LIST
18208: LIST
18209: LIST
18210: LIST
18211: LIST
18212: PUSH
18213: EMPTY
18214: LIST
18215: LIST
18216: LIST
18217: LIST
18218: PPUSH
18219: CALL 81021 0 1
18223: END
// every 0 0$1 trigger KurtAttack do var i ;
18224: LD_EXP 25
18228: IFFALSE 18349
18230: GO 18232
18232: DISABLE
18233: LD_INT 0
18235: PPUSH
// begin currentArWave = 0 ;
18236: LD_ADDR_EXP 86
18240: PUSH
18241: LD_INT 0
18243: ST_TO_ADDR
// wait ( firstAttackDelay ) ;
18244: LD_EXP 49
18248: PPUSH
18249: CALL_OW 67
// for i := 1 to KurtAttackWaves do
18253: LD_ADDR_VAR 0 1
18257: PUSH
18258: DOUBLE
18259: LD_INT 1
18261: DEC
18262: ST_TO_ADDR
18263: LD_EXP 47
18267: PUSH
18268: FOR_TO
18269: IFFALSE 18347
// begin if KurtAttack and IsOK ( Heike ) then
18271: LD_EXP 25
18275: PUSH
18276: LD_EXP 79
18280: PPUSH
18281: CALL_OW 302
18285: AND
18286: IFFALSE 18345
// begin SpawnArAttackTeam ;
18288: CALL 4359 0 0
// currentArWave = currentArWave + 1 ;
18292: LD_ADDR_EXP 86
18296: PUSH
18297: LD_EXP 86
18301: PUSH
18302: LD_INT 1
18304: PLUS
18305: ST_TO_ADDR
// if currentArWave = 2 then
18306: LD_EXP 86
18310: PUSH
18311: LD_INT 2
18313: EQUAL
18314: IFFALSE 18336
// begin SayRadio ( Kurt , DMercAttack-Kurt-1 ) ;
18316: LD_EXP 80
18320: PPUSH
18321: LD_STRING DMercAttack-Kurt-1
18323: PPUSH
18324: CALL_OW 94
// canSendHeike = true ;
18328: LD_ADDR_EXP 28
18332: PUSH
18333: LD_INT 1
18335: ST_TO_ADDR
// end ; wait ( waveCooldown ) ;
18336: LD_EXP 50
18340: PPUSH
18341: CALL_OW 67
// end ; end ;
18345: GO 18268
18347: POP
18348: POP
// end ;
18349: PPOPN 1
18351: END
// every 0 0$1 trigger currentArWave = 1 do
18352: LD_EXP 86
18356: PUSH
18357: LD_INT 1
18359: EQUAL
18360: IFFALSE 18449
18362: GO 18364
18364: DISABLE
// Attack ( [ 0 , arAttackTeam , [ [ 115 , 42 ] , [ 51 , 67 ] ] , [ 0 , 0 , 0 , 1 , 1 , 1 , 0 , 0 , 1 , 0 ] ] ) ;
18365: LD_INT 0
18367: PUSH
18368: LD_EXP 84
18372: PUSH
18373: LD_INT 115
18375: PUSH
18376: LD_INT 42
18378: PUSH
18379: EMPTY
18380: LIST
18381: LIST
18382: PUSH
18383: LD_INT 51
18385: PUSH
18386: LD_INT 67
18388: PUSH
18389: EMPTY
18390: LIST
18391: LIST
18392: PUSH
18393: EMPTY
18394: LIST
18395: LIST
18396: PUSH
18397: LD_INT 0
18399: PUSH
18400: LD_INT 0
18402: PUSH
18403: LD_INT 0
18405: PUSH
18406: LD_INT 1
18408: PUSH
18409: LD_INT 1
18411: PUSH
18412: LD_INT 1
18414: PUSH
18415: LD_INT 0
18417: PUSH
18418: LD_INT 0
18420: PUSH
18421: LD_INT 1
18423: PUSH
18424: LD_INT 0
18426: PUSH
18427: EMPTY
18428: LIST
18429: LIST
18430: LIST
18431: LIST
18432: LIST
18433: LIST
18434: LIST
18435: LIST
18436: LIST
18437: LIST
18438: PUSH
18439: EMPTY
18440: LIST
18441: LIST
18442: LIST
18443: LIST
18444: PPUSH
18445: CALL 81021 0 1
18449: END
// every 0 0$1 trigger currentArWave = 2 do
18450: LD_EXP 86
18454: PUSH
18455: LD_INT 2
18457: EQUAL
18458: IFFALSE 18547
18460: GO 18462
18462: DISABLE
// Attack ( [ 0 , arAttackTeam , [ [ 115 , 42 ] , [ 51 , 67 ] ] , [ 0 , 0 , 0 , 1 , 1 , 1 , 0 , 0 , 1 , 0 ] ] ) ;
18463: LD_INT 0
18465: PUSH
18466: LD_EXP 84
18470: PUSH
18471: LD_INT 115
18473: PUSH
18474: LD_INT 42
18476: PUSH
18477: EMPTY
18478: LIST
18479: LIST
18480: PUSH
18481: LD_INT 51
18483: PUSH
18484: LD_INT 67
18486: PUSH
18487: EMPTY
18488: LIST
18489: LIST
18490: PUSH
18491: EMPTY
18492: LIST
18493: LIST
18494: PUSH
18495: LD_INT 0
18497: PUSH
18498: LD_INT 0
18500: PUSH
18501: LD_INT 0
18503: PUSH
18504: LD_INT 1
18506: PUSH
18507: LD_INT 1
18509: PUSH
18510: LD_INT 1
18512: PUSH
18513: LD_INT 0
18515: PUSH
18516: LD_INT 0
18518: PUSH
18519: LD_INT 1
18521: PUSH
18522: LD_INT 0
18524: PUSH
18525: EMPTY
18526: LIST
18527: LIST
18528: LIST
18529: LIST
18530: LIST
18531: LIST
18532: LIST
18533: LIST
18534: LIST
18535: LIST
18536: PUSH
18537: EMPTY
18538: LIST
18539: LIST
18540: LIST
18541: LIST
18542: PPUSH
18543: CALL 81021 0 1
18547: END
// every 0 0$1 trigger currentArWave = 3 do
18548: LD_EXP 86
18552: PUSH
18553: LD_INT 3
18555: EQUAL
18556: IFFALSE 18645
18558: GO 18560
18560: DISABLE
// Attack ( [ 0 , arAttackTeam , [ [ 115 , 42 ] , [ 51 , 67 ] ] , [ 0 , 0 , 0 , 1 , 1 , 1 , 0 , 0 , 1 , 0 ] ] ) ;
18561: LD_INT 0
18563: PUSH
18564: LD_EXP 84
18568: PUSH
18569: LD_INT 115
18571: PUSH
18572: LD_INT 42
18574: PUSH
18575: EMPTY
18576: LIST
18577: LIST
18578: PUSH
18579: LD_INT 51
18581: PUSH
18582: LD_INT 67
18584: PUSH
18585: EMPTY
18586: LIST
18587: LIST
18588: PUSH
18589: EMPTY
18590: LIST
18591: LIST
18592: PUSH
18593: LD_INT 0
18595: PUSH
18596: LD_INT 0
18598: PUSH
18599: LD_INT 0
18601: PUSH
18602: LD_INT 1
18604: PUSH
18605: LD_INT 1
18607: PUSH
18608: LD_INT 1
18610: PUSH
18611: LD_INT 0
18613: PUSH
18614: LD_INT 0
18616: PUSH
18617: LD_INT 1
18619: PUSH
18620: LD_INT 0
18622: PUSH
18623: EMPTY
18624: LIST
18625: LIST
18626: LIST
18627: LIST
18628: LIST
18629: LIST
18630: LIST
18631: LIST
18632: LIST
18633: LIST
18634: PUSH
18635: EMPTY
18636: LIST
18637: LIST
18638: LIST
18639: LIST
18640: PPUSH
18641: CALL 81021 0 1
18645: END
// every 0 0$1 trigger currentArWave = 4 do
18646: LD_EXP 86
18650: PUSH
18651: LD_INT 4
18653: EQUAL
18654: IFFALSE 18743
18656: GO 18658
18658: DISABLE
// Attack ( [ 0 , arAttackTeam , [ [ 115 , 42 ] , [ 51 , 67 ] ] , [ 0 , 0 , 0 , 1 , 1 , 1 , 0 , 0 , 1 , 0 ] ] ) ;
18659: LD_INT 0
18661: PUSH
18662: LD_EXP 84
18666: PUSH
18667: LD_INT 115
18669: PUSH
18670: LD_INT 42
18672: PUSH
18673: EMPTY
18674: LIST
18675: LIST
18676: PUSH
18677: LD_INT 51
18679: PUSH
18680: LD_INT 67
18682: PUSH
18683: EMPTY
18684: LIST
18685: LIST
18686: PUSH
18687: EMPTY
18688: LIST
18689: LIST
18690: PUSH
18691: LD_INT 0
18693: PUSH
18694: LD_INT 0
18696: PUSH
18697: LD_INT 0
18699: PUSH
18700: LD_INT 1
18702: PUSH
18703: LD_INT 1
18705: PUSH
18706: LD_INT 1
18708: PUSH
18709: LD_INT 0
18711: PUSH
18712: LD_INT 0
18714: PUSH
18715: LD_INT 1
18717: PUSH
18718: LD_INT 0
18720: PUSH
18721: EMPTY
18722: LIST
18723: LIST
18724: LIST
18725: LIST
18726: LIST
18727: LIST
18728: LIST
18729: LIST
18730: LIST
18731: LIST
18732: PUSH
18733: EMPTY
18734: LIST
18735: LIST
18736: LIST
18737: LIST
18738: PPUSH
18739: CALL 81021 0 1
18743: END
// every 0 0$1 trigger currentArWave = 5 do
18744: LD_EXP 86
18748: PUSH
18749: LD_INT 5
18751: EQUAL
18752: IFFALSE 18841
18754: GO 18756
18756: DISABLE
// Attack ( [ 0 , arAttackTeam , [ [ 115 , 42 ] , [ 51 , 67 ] ] , [ 0 , 0 , 0 , 1 , 1 , 1 , 0 , 0 , 1 , 0 ] ] ) ; end_of_file
18757: LD_INT 0
18759: PUSH
18760: LD_EXP 84
18764: PUSH
18765: LD_INT 115
18767: PUSH
18768: LD_INT 42
18770: PUSH
18771: EMPTY
18772: LIST
18773: LIST
18774: PUSH
18775: LD_INT 51
18777: PUSH
18778: LD_INT 67
18780: PUSH
18781: EMPTY
18782: LIST
18783: LIST
18784: PUSH
18785: EMPTY
18786: LIST
18787: LIST
18788: PUSH
18789: LD_INT 0
18791: PUSH
18792: LD_INT 0
18794: PUSH
18795: LD_INT 0
18797: PUSH
18798: LD_INT 1
18800: PUSH
18801: LD_INT 1
18803: PUSH
18804: LD_INT 1
18806: PUSH
18807: LD_INT 0
18809: PUSH
18810: LD_INT 0
18812: PUSH
18813: LD_INT 1
18815: PUSH
18816: LD_INT 0
18818: PUSH
18819: EMPTY
18820: LIST
18821: LIST
18822: LIST
18823: LIST
18824: LIST
18825: LIST
18826: LIST
18827: LIST
18828: LIST
18829: LIST
18830: PUSH
18831: EMPTY
18832: LIST
18833: LIST
18834: LIST
18835: LIST
18836: PPUSH
18837: CALL 81021 0 1
18841: END
// every 0 0$1 do var arVehs , arVeh , nearPlayerUnit ;
18842: GO 18844
18844: DISABLE
18845: LD_INT 0
18847: PPUSH
18848: PPUSH
18849: PPUSH
// begin enable ;
18850: ENABLE
// arVehs = FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_vehicle ] , [ f_empty ] ] ) ;
18851: LD_ADDR_VAR 0 1
18855: PUSH
18856: LD_INT 22
18858: PUSH
18859: LD_INT 8
18861: PUSH
18862: EMPTY
18863: LIST
18864: LIST
18865: PUSH
18866: LD_INT 21
18868: PUSH
18869: LD_INT 2
18871: PUSH
18872: EMPTY
18873: LIST
18874: LIST
18875: PUSH
18876: LD_INT 58
18878: PUSH
18879: EMPTY
18880: LIST
18881: PUSH
18882: EMPTY
18883: LIST
18884: LIST
18885: LIST
18886: PPUSH
18887: CALL_OW 69
18891: ST_TO_ADDR
// if not arVehs or not GetAttitude ( 3 , 8 ) = att_enemy then
18892: LD_VAR 0 1
18896: NOT
18897: PUSH
18898: LD_INT 3
18900: PPUSH
18901: LD_INT 8
18903: PPUSH
18904: CALL_OW 81
18908: PUSH
18909: LD_INT 2
18911: EQUAL
18912: NOT
18913: OR
18914: IFFALSE 18918
// exit ;
18916: GO 19008
// for arVeh in arVehs do
18918: LD_ADDR_VAR 0 2
18922: PUSH
18923: LD_VAR 0 1
18927: PUSH
18928: FOR_IN
18929: IFFALSE 19006
// begin nearPlayerUnit = NearestUnitToUnit ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) , arVeh ) ;
18931: LD_ADDR_VAR 0 3
18935: PUSH
18936: LD_INT 22
18938: PUSH
18939: LD_INT 3
18941: PUSH
18942: EMPTY
18943: LIST
18944: LIST
18945: PUSH
18946: LD_INT 21
18948: PUSH
18949: LD_INT 1
18951: PUSH
18952: EMPTY
18953: LIST
18954: LIST
18955: PUSH
18956: EMPTY
18957: LIST
18958: LIST
18959: PPUSH
18960: CALL_OW 69
18964: PPUSH
18965: LD_VAR 0 2
18969: PPUSH
18970: CALL_OW 74
18974: ST_TO_ADDR
// if GetDistUnits ( nearPlayerUnit , arVeh ) <= 2 then
18975: LD_VAR 0 3
18979: PPUSH
18980: LD_VAR 0 2
18984: PPUSH
18985: CALL_OW 296
18989: PUSH
18990: LD_INT 2
18992: LESSEQUAL
18993: IFFALSE 19004
// ComSelfDestruction ( arVeh ) ;
18995: LD_VAR 0 2
18999: PPUSH
19000: CALL_OW 577
// end ;
19004: GO 18928
19006: POP
19007: POP
// end ;
19008: PPOPN 3
19010: END
// every 0 0$1 trigger forceStopKurtAttack do
19011: LD_EXP 27
19015: IFFALSE 19081
19017: GO 19019
19019: DISABLE
// begin KurtAttack = false ;
19020: LD_ADDR_EXP 25
19024: PUSH
19025: LD_INT 0
19027: ST_TO_ADDR
// allowExitFromMap = 4 ;
19028: LD_ADDR_EXP 18
19032: PUSH
19033: LD_INT 4
19035: ST_TO_ADDR
// SetAttitude ( 3 , 8 , att_friend , true ) ;
19036: LD_INT 3
19038: PPUSH
19039: LD_INT 8
19041: PPUSH
19042: LD_INT 1
19044: PPUSH
19045: LD_INT 1
19047: PPUSH
19048: CALL_OW 80
// arAttackTeam = [ ] ;
19052: LD_ADDR_EXP 84
19056: PUSH
19057: EMPTY
19058: ST_TO_ADDR
// ComMoveToArea ( FilterAllUnits ( [ f_side , 8 ] ) , KurtExitMapArea ) ;
19059: LD_INT 22
19061: PUSH
19062: LD_INT 8
19064: PUSH
19065: EMPTY
19066: LIST
19067: LIST
19068: PPUSH
19069: CALL_OW 69
19073: PPUSH
19074: LD_INT 11
19076: PPUSH
19077: CALL_OW 113
// end ; end_of_file end_of_file
19081: END
// every 0 0$01 do var timer , cratesSpawned ;
19082: GO 19084
19084: DISABLE
19085: LD_INT 0
19087: PPUSH
19088: PPUSH
// begin timer := 1 1$30 ;
19089: LD_ADDR_VAR 0 1
19093: PUSH
19094: LD_INT 3150
19096: ST_TO_ADDR
// repeat wait ( timer ) ;
19097: LD_VAR 0 1
19101: PPUSH
19102: CALL_OW 67
// if cratesSpawned >= 6 and cratesSpawned < 18 then
19106: LD_VAR 0 2
19110: PUSH
19111: LD_INT 6
19113: GREATEREQUAL
19114: PUSH
19115: LD_VAR 0 2
19119: PUSH
19120: LD_INT 18
19122: LESS
19123: AND
19124: IFFALSE 19140
// timer := timer + 0 0$3 ;
19126: LD_ADDR_VAR 0 1
19130: PUSH
19131: LD_VAR 0 1
19135: PUSH
19136: LD_INT 105
19138: PLUS
19139: ST_TO_ADDR
// if cratesSpawned >= 18 then
19140: LD_VAR 0 2
19144: PUSH
19145: LD_INT 18
19147: GREATEREQUAL
19148: IFFALSE 19164
// timer := timer + 0 0$9 ;
19150: LD_ADDR_VAR 0 1
19154: PUSH
19155: LD_VAR 0 1
19159: PUSH
19160: LD_INT 315
19162: PLUS
19163: ST_TO_ADDR
// if timer > 3 3$00 then
19164: LD_VAR 0 1
19168: PUSH
19169: LD_INT 6300
19171: GREATER
19172: IFFALSE 19182
// timer := 0 0$50 ;
19174: LD_ADDR_VAR 0 1
19178: PUSH
19179: LD_INT 1750
19181: ST_TO_ADDR
// CreateCratesArea ( rand ( 3 , 5 ) , CratesSpawnArea , true ) ;
19182: LD_INT 3
19184: PPUSH
19185: LD_INT 5
19187: PPUSH
19188: CALL_OW 12
19192: PPUSH
19193: LD_INT 15
19195: PPUSH
19196: LD_INT 1
19198: PPUSH
19199: CALL_OW 55
// cratesSpawned = cratesSpawned + 1 ;
19203: LD_ADDR_VAR 0 2
19207: PUSH
19208: LD_VAR 0 2
19212: PUSH
19213: LD_INT 1
19215: PLUS
19216: ST_TO_ADDR
// until false ;
19217: LD_INT 0
19219: IFFALSE 19097
// end ; end_of_file
19221: PPOPN 2
19223: END
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
19224: LD_INT 0
19226: PPUSH
19227: PPUSH
// if exist_mode then
19228: LD_VAR 0 2
19232: IFFALSE 19257
// unit := CreateCharacter ( prefix & ident ) else
19234: LD_ADDR_VAR 0 5
19238: PUSH
19239: LD_VAR 0 3
19243: PUSH
19244: LD_VAR 0 1
19248: STR
19249: PPUSH
19250: CALL_OW 34
19254: ST_TO_ADDR
19255: GO 19272
// unit := NewCharacter ( ident ) ;
19257: LD_ADDR_VAR 0 5
19261: PUSH
19262: LD_VAR 0 1
19266: PPUSH
19267: CALL_OW 25
19271: ST_TO_ADDR
// result := unit ;
19272: LD_ADDR_VAR 0 4
19276: PUSH
19277: LD_VAR 0 5
19281: ST_TO_ADDR
// end ;
19282: LD_VAR 0 4
19286: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
19287: LD_INT 0
19289: PPUSH
19290: PPUSH
// if not side or not nation then
19291: LD_VAR 0 1
19295: NOT
19296: PUSH
19297: LD_VAR 0 2
19301: NOT
19302: OR
19303: IFFALSE 19307
// exit ;
19305: GO 20075
// case nation of nation_american :
19307: LD_VAR 0 2
19311: PUSH
19312: LD_INT 1
19314: DOUBLE
19315: EQUAL
19316: IFTRUE 19320
19318: GO 19534
19320: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 86 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 , 82 , 83 , 84 , 85 , 86 ] ; nation_arabian :
19321: LD_ADDR_VAR 0 4
19325: PUSH
19326: LD_INT 35
19328: PUSH
19329: LD_INT 45
19331: PUSH
19332: LD_INT 46
19334: PUSH
19335: LD_INT 47
19337: PUSH
19338: LD_INT 82
19340: PUSH
19341: LD_INT 83
19343: PUSH
19344: LD_INT 84
19346: PUSH
19347: LD_INT 85
19349: PUSH
19350: LD_INT 86
19352: PUSH
19353: LD_INT 1
19355: PUSH
19356: LD_INT 2
19358: PUSH
19359: LD_INT 6
19361: PUSH
19362: LD_INT 15
19364: PUSH
19365: LD_INT 16
19367: PUSH
19368: LD_INT 7
19370: PUSH
19371: LD_INT 12
19373: PUSH
19374: LD_INT 13
19376: PUSH
19377: LD_INT 10
19379: PUSH
19380: LD_INT 14
19382: PUSH
19383: LD_INT 20
19385: PUSH
19386: LD_INT 21
19388: PUSH
19389: LD_INT 22
19391: PUSH
19392: LD_INT 25
19394: PUSH
19395: LD_INT 32
19397: PUSH
19398: LD_INT 27
19400: PUSH
19401: LD_INT 36
19403: PUSH
19404: LD_INT 69
19406: PUSH
19407: LD_INT 39
19409: PUSH
19410: LD_INT 34
19412: PUSH
19413: LD_INT 40
19415: PUSH
19416: LD_INT 48
19418: PUSH
19419: LD_INT 49
19421: PUSH
19422: LD_INT 50
19424: PUSH
19425: LD_INT 51
19427: PUSH
19428: LD_INT 52
19430: PUSH
19431: LD_INT 53
19433: PUSH
19434: LD_INT 54
19436: PUSH
19437: LD_INT 55
19439: PUSH
19440: LD_INT 56
19442: PUSH
19443: LD_INT 57
19445: PUSH
19446: LD_INT 58
19448: PUSH
19449: LD_INT 59
19451: PUSH
19452: LD_INT 60
19454: PUSH
19455: LD_INT 61
19457: PUSH
19458: LD_INT 62
19460: PUSH
19461: LD_INT 80
19463: PUSH
19464: LD_INT 82
19466: PUSH
19467: LD_INT 83
19469: PUSH
19470: LD_INT 84
19472: PUSH
19473: LD_INT 85
19475: PUSH
19476: LD_INT 86
19478: PUSH
19479: EMPTY
19480: LIST
19481: LIST
19482: LIST
19483: LIST
19484: LIST
19485: LIST
19486: LIST
19487: LIST
19488: LIST
19489: LIST
19490: LIST
19491: LIST
19492: LIST
19493: LIST
19494: LIST
19495: LIST
19496: LIST
19497: LIST
19498: LIST
19499: LIST
19500: LIST
19501: LIST
19502: LIST
19503: LIST
19504: LIST
19505: LIST
19506: LIST
19507: LIST
19508: LIST
19509: LIST
19510: LIST
19511: LIST
19512: LIST
19513: LIST
19514: LIST
19515: LIST
19516: LIST
19517: LIST
19518: LIST
19519: LIST
19520: LIST
19521: LIST
19522: LIST
19523: LIST
19524: LIST
19525: LIST
19526: LIST
19527: LIST
19528: LIST
19529: LIST
19530: LIST
19531: ST_TO_ADDR
19532: GO 19999
19534: LD_INT 2
19536: DOUBLE
19537: EQUAL
19538: IFTRUE 19542
19540: GO 19768
19542: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 87 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 , 82 , 83 , 84 , 85 , 87 , 88 ] ; nation_russian :
19543: LD_ADDR_VAR 0 4
19547: PUSH
19548: LD_INT 35
19550: PUSH
19551: LD_INT 45
19553: PUSH
19554: LD_INT 46
19556: PUSH
19557: LD_INT 47
19559: PUSH
19560: LD_INT 82
19562: PUSH
19563: LD_INT 83
19565: PUSH
19566: LD_INT 84
19568: PUSH
19569: LD_INT 85
19571: PUSH
19572: LD_INT 87
19574: PUSH
19575: LD_INT 70
19577: PUSH
19578: LD_INT 1
19580: PUSH
19581: LD_INT 11
19583: PUSH
19584: LD_INT 3
19586: PUSH
19587: LD_INT 4
19589: PUSH
19590: LD_INT 5
19592: PUSH
19593: LD_INT 6
19595: PUSH
19596: LD_INT 15
19598: PUSH
19599: LD_INT 18
19601: PUSH
19602: LD_INT 7
19604: PUSH
19605: LD_INT 17
19607: PUSH
19608: LD_INT 8
19610: PUSH
19611: LD_INT 20
19613: PUSH
19614: LD_INT 21
19616: PUSH
19617: LD_INT 22
19619: PUSH
19620: LD_INT 72
19622: PUSH
19623: LD_INT 26
19625: PUSH
19626: LD_INT 69
19628: PUSH
19629: LD_INT 39
19631: PUSH
19632: LD_INT 40
19634: PUSH
19635: LD_INT 41
19637: PUSH
19638: LD_INT 42
19640: PUSH
19641: LD_INT 43
19643: PUSH
19644: LD_INT 48
19646: PUSH
19647: LD_INT 49
19649: PUSH
19650: LD_INT 50
19652: PUSH
19653: LD_INT 51
19655: PUSH
19656: LD_INT 52
19658: PUSH
19659: LD_INT 53
19661: PUSH
19662: LD_INT 54
19664: PUSH
19665: LD_INT 55
19667: PUSH
19668: LD_INT 56
19670: PUSH
19671: LD_INT 60
19673: PUSH
19674: LD_INT 61
19676: PUSH
19677: LD_INT 62
19679: PUSH
19680: LD_INT 66
19682: PUSH
19683: LD_INT 67
19685: PUSH
19686: LD_INT 68
19688: PUSH
19689: LD_INT 81
19691: PUSH
19692: LD_INT 82
19694: PUSH
19695: LD_INT 83
19697: PUSH
19698: LD_INT 84
19700: PUSH
19701: LD_INT 85
19703: PUSH
19704: LD_INT 87
19706: PUSH
19707: LD_INT 88
19709: PUSH
19710: EMPTY
19711: LIST
19712: LIST
19713: LIST
19714: LIST
19715: LIST
19716: LIST
19717: LIST
19718: LIST
19719: LIST
19720: LIST
19721: LIST
19722: LIST
19723: LIST
19724: LIST
19725: LIST
19726: LIST
19727: LIST
19728: LIST
19729: LIST
19730: LIST
19731: LIST
19732: LIST
19733: LIST
19734: LIST
19735: LIST
19736: LIST
19737: LIST
19738: LIST
19739: LIST
19740: LIST
19741: LIST
19742: LIST
19743: LIST
19744: LIST
19745: LIST
19746: LIST
19747: LIST
19748: LIST
19749: LIST
19750: LIST
19751: LIST
19752: LIST
19753: LIST
19754: LIST
19755: LIST
19756: LIST
19757: LIST
19758: LIST
19759: LIST
19760: LIST
19761: LIST
19762: LIST
19763: LIST
19764: LIST
19765: ST_TO_ADDR
19766: GO 19999
19768: LD_INT 3
19770: DOUBLE
19771: EQUAL
19772: IFTRUE 19776
19774: GO 19998
19776: POP
// result := [ 46 , 47 , 1 , 2 , 82 , 83 , 84 , 85 , 86 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 , 82 , 83 , 84 , 85 , 86 ] ; end ;
19777: LD_ADDR_VAR 0 4
19781: PUSH
19782: LD_INT 46
19784: PUSH
19785: LD_INT 47
19787: PUSH
19788: LD_INT 1
19790: PUSH
19791: LD_INT 2
19793: PUSH
19794: LD_INT 82
19796: PUSH
19797: LD_INT 83
19799: PUSH
19800: LD_INT 84
19802: PUSH
19803: LD_INT 85
19805: PUSH
19806: LD_INT 86
19808: PUSH
19809: LD_INT 11
19811: PUSH
19812: LD_INT 9
19814: PUSH
19815: LD_INT 20
19817: PUSH
19818: LD_INT 19
19820: PUSH
19821: LD_INT 21
19823: PUSH
19824: LD_INT 24
19826: PUSH
19827: LD_INT 22
19829: PUSH
19830: LD_INT 25
19832: PUSH
19833: LD_INT 28
19835: PUSH
19836: LD_INT 29
19838: PUSH
19839: LD_INT 30
19841: PUSH
19842: LD_INT 31
19844: PUSH
19845: LD_INT 37
19847: PUSH
19848: LD_INT 38
19850: PUSH
19851: LD_INT 32
19853: PUSH
19854: LD_INT 27
19856: PUSH
19857: LD_INT 33
19859: PUSH
19860: LD_INT 69
19862: PUSH
19863: LD_INT 39
19865: PUSH
19866: LD_INT 34
19868: PUSH
19869: LD_INT 40
19871: PUSH
19872: LD_INT 71
19874: PUSH
19875: LD_INT 23
19877: PUSH
19878: LD_INT 44
19880: PUSH
19881: LD_INT 48
19883: PUSH
19884: LD_INT 49
19886: PUSH
19887: LD_INT 50
19889: PUSH
19890: LD_INT 51
19892: PUSH
19893: LD_INT 52
19895: PUSH
19896: LD_INT 53
19898: PUSH
19899: LD_INT 54
19901: PUSH
19902: LD_INT 55
19904: PUSH
19905: LD_INT 56
19907: PUSH
19908: LD_INT 57
19910: PUSH
19911: LD_INT 58
19913: PUSH
19914: LD_INT 59
19916: PUSH
19917: LD_INT 63
19919: PUSH
19920: LD_INT 64
19922: PUSH
19923: LD_INT 65
19925: PUSH
19926: LD_INT 82
19928: PUSH
19929: LD_INT 83
19931: PUSH
19932: LD_INT 84
19934: PUSH
19935: LD_INT 85
19937: PUSH
19938: LD_INT 86
19940: PUSH
19941: EMPTY
19942: LIST
19943: LIST
19944: LIST
19945: LIST
19946: LIST
19947: LIST
19948: LIST
19949: LIST
19950: LIST
19951: LIST
19952: LIST
19953: LIST
19954: LIST
19955: LIST
19956: LIST
19957: LIST
19958: LIST
19959: LIST
19960: LIST
19961: LIST
19962: LIST
19963: LIST
19964: LIST
19965: LIST
19966: LIST
19967: LIST
19968: LIST
19969: LIST
19970: LIST
19971: LIST
19972: LIST
19973: LIST
19974: LIST
19975: LIST
19976: LIST
19977: LIST
19978: LIST
19979: LIST
19980: LIST
19981: LIST
19982: LIST
19983: LIST
19984: LIST
19985: LIST
19986: LIST
19987: LIST
19988: LIST
19989: LIST
19990: LIST
19991: LIST
19992: LIST
19993: LIST
19994: LIST
19995: ST_TO_ADDR
19996: GO 19999
19998: POP
// if state > - 1 and state < 3 then
19999: LD_VAR 0 3
20003: PUSH
20004: LD_INT 1
20006: NEG
20007: GREATER
20008: PUSH
20009: LD_VAR 0 3
20013: PUSH
20014: LD_INT 3
20016: LESS
20017: AND
20018: IFFALSE 20075
// for i in result do
20020: LD_ADDR_VAR 0 5
20024: PUSH
20025: LD_VAR 0 4
20029: PUSH
20030: FOR_IN
20031: IFFALSE 20073
// if GetTech ( i , side ) <> state then
20033: LD_VAR 0 5
20037: PPUSH
20038: LD_VAR 0 1
20042: PPUSH
20043: CALL_OW 321
20047: PUSH
20048: LD_VAR 0 3
20052: NONEQUAL
20053: IFFALSE 20071
// result := result diff i ;
20055: LD_ADDR_VAR 0 4
20059: PUSH
20060: LD_VAR 0 4
20064: PUSH
20065: LD_VAR 0 5
20069: DIFF
20070: ST_TO_ADDR
20071: GO 20030
20073: POP
20074: POP
// end ;
20075: LD_VAR 0 4
20079: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
20080: LD_INT 0
20082: PPUSH
20083: PPUSH
20084: PPUSH
// result := true ;
20085: LD_ADDR_VAR 0 3
20089: PUSH
20090: LD_INT 1
20092: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
20093: LD_ADDR_VAR 0 5
20097: PUSH
20098: LD_VAR 0 2
20102: PPUSH
20103: CALL_OW 480
20107: ST_TO_ADDR
// if not tmp then
20108: LD_VAR 0 5
20112: NOT
20113: IFFALSE 20117
// exit ;
20115: GO 20166
// for i in tmp do
20117: LD_ADDR_VAR 0 4
20121: PUSH
20122: LD_VAR 0 5
20126: PUSH
20127: FOR_IN
20128: IFFALSE 20164
// if GetTech ( i , side ) <> state_researched then
20130: LD_VAR 0 4
20134: PPUSH
20135: LD_VAR 0 1
20139: PPUSH
20140: CALL_OW 321
20144: PUSH
20145: LD_INT 2
20147: NONEQUAL
20148: IFFALSE 20162
// begin result := false ;
20150: LD_ADDR_VAR 0 3
20154: PUSH
20155: LD_INT 0
20157: ST_TO_ADDR
// exit ;
20158: POP
20159: POP
20160: GO 20166
// end ;
20162: GO 20127
20164: POP
20165: POP
// end ;
20166: LD_VAR 0 3
20170: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
20171: LD_INT 0
20173: PPUSH
20174: PPUSH
20175: PPUSH
20176: PPUSH
20177: PPUSH
20178: PPUSH
20179: PPUSH
20180: PPUSH
20181: PPUSH
20182: PPUSH
20183: PPUSH
20184: PPUSH
20185: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
20186: LD_VAR 0 1
20190: NOT
20191: PUSH
20192: LD_VAR 0 1
20196: PPUSH
20197: CALL_OW 257
20201: PUSH
20202: LD_INT 9
20204: NONEQUAL
20205: OR
20206: IFFALSE 20210
// exit ;
20208: GO 20783
// side := GetSide ( unit ) ;
20210: LD_ADDR_VAR 0 9
20214: PUSH
20215: LD_VAR 0 1
20219: PPUSH
20220: CALL_OW 255
20224: ST_TO_ADDR
// tech_space := tech_spacanom ;
20225: LD_ADDR_VAR 0 12
20229: PUSH
20230: LD_INT 29
20232: ST_TO_ADDR
// tech_time := tech_taurad ;
20233: LD_ADDR_VAR 0 13
20237: PUSH
20238: LD_INT 28
20240: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
20241: LD_ADDR_VAR 0 11
20245: PUSH
20246: LD_VAR 0 1
20250: PPUSH
20251: CALL_OW 310
20255: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
20256: LD_VAR 0 11
20260: PPUSH
20261: CALL_OW 247
20265: PUSH
20266: LD_INT 2
20268: EQUAL
20269: IFFALSE 20273
// exit ;
20271: GO 20783
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
20273: LD_ADDR_VAR 0 8
20277: PUSH
20278: LD_INT 81
20280: PUSH
20281: LD_VAR 0 9
20285: PUSH
20286: EMPTY
20287: LIST
20288: LIST
20289: PUSH
20290: LD_INT 3
20292: PUSH
20293: LD_INT 21
20295: PUSH
20296: LD_INT 3
20298: PUSH
20299: EMPTY
20300: LIST
20301: LIST
20302: PUSH
20303: EMPTY
20304: LIST
20305: LIST
20306: PUSH
20307: EMPTY
20308: LIST
20309: LIST
20310: PPUSH
20311: CALL_OW 69
20315: ST_TO_ADDR
// if not tmp then
20316: LD_VAR 0 8
20320: NOT
20321: IFFALSE 20325
// exit ;
20323: GO 20783
// if in_unit then
20325: LD_VAR 0 11
20329: IFFALSE 20353
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
20331: LD_ADDR_VAR 0 10
20335: PUSH
20336: LD_VAR 0 8
20340: PPUSH
20341: LD_VAR 0 11
20345: PPUSH
20346: CALL_OW 74
20350: ST_TO_ADDR
20351: GO 20373
// enemy := NearestUnitToUnit ( tmp , unit ) ;
20353: LD_ADDR_VAR 0 10
20357: PUSH
20358: LD_VAR 0 8
20362: PPUSH
20363: LD_VAR 0 1
20367: PPUSH
20368: CALL_OW 74
20372: ST_TO_ADDR
// if not enemy then
20373: LD_VAR 0 10
20377: NOT
20378: IFFALSE 20382
// exit ;
20380: GO 20783
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
20382: LD_VAR 0 11
20386: PUSH
20387: LD_VAR 0 11
20391: PPUSH
20392: LD_VAR 0 10
20396: PPUSH
20397: CALL_OW 296
20401: PUSH
20402: LD_INT 13
20404: GREATER
20405: AND
20406: PUSH
20407: LD_VAR 0 1
20411: PPUSH
20412: LD_VAR 0 10
20416: PPUSH
20417: CALL_OW 296
20421: PUSH
20422: LD_INT 12
20424: GREATER
20425: OR
20426: IFFALSE 20430
// exit ;
20428: GO 20783
// missile := [ 1 ] ;
20430: LD_ADDR_VAR 0 14
20434: PUSH
20435: LD_INT 1
20437: PUSH
20438: EMPTY
20439: LIST
20440: ST_TO_ADDR
// if Researched ( side , tech_space ) then
20441: LD_VAR 0 9
20445: PPUSH
20446: LD_VAR 0 12
20450: PPUSH
20451: CALL_OW 325
20455: IFFALSE 20484
// missile := Replace ( missile , missile + 1 , 2 ) ;
20457: LD_ADDR_VAR 0 14
20461: PUSH
20462: LD_VAR 0 14
20466: PPUSH
20467: LD_VAR 0 14
20471: PUSH
20472: LD_INT 1
20474: PLUS
20475: PPUSH
20476: LD_INT 2
20478: PPUSH
20479: CALL_OW 1
20483: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
20484: LD_VAR 0 9
20488: PPUSH
20489: LD_VAR 0 13
20493: PPUSH
20494: CALL_OW 325
20498: PUSH
20499: LD_VAR 0 10
20503: PPUSH
20504: CALL_OW 255
20508: PPUSH
20509: LD_VAR 0 13
20513: PPUSH
20514: CALL_OW 325
20518: NOT
20519: AND
20520: IFFALSE 20549
// missile := Replace ( missile , missile + 1 , 3 ) ;
20522: LD_ADDR_VAR 0 14
20526: PUSH
20527: LD_VAR 0 14
20531: PPUSH
20532: LD_VAR 0 14
20536: PUSH
20537: LD_INT 1
20539: PLUS
20540: PPUSH
20541: LD_INT 3
20543: PPUSH
20544: CALL_OW 1
20548: ST_TO_ADDR
// if missile < 2 then
20549: LD_VAR 0 14
20553: PUSH
20554: LD_INT 2
20556: LESS
20557: IFFALSE 20561
// exit ;
20559: GO 20783
// x := GetX ( enemy ) ;
20561: LD_ADDR_VAR 0 4
20565: PUSH
20566: LD_VAR 0 10
20570: PPUSH
20571: CALL_OW 250
20575: ST_TO_ADDR
// y := GetY ( enemy ) ;
20576: LD_ADDR_VAR 0 5
20580: PUSH
20581: LD_VAR 0 10
20585: PPUSH
20586: CALL_OW 251
20590: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
20591: LD_ADDR_VAR 0 6
20595: PUSH
20596: LD_VAR 0 4
20600: PUSH
20601: LD_INT 1
20603: NEG
20604: PPUSH
20605: LD_INT 1
20607: PPUSH
20608: CALL_OW 12
20612: PLUS
20613: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
20614: LD_ADDR_VAR 0 7
20618: PUSH
20619: LD_VAR 0 5
20623: PUSH
20624: LD_INT 1
20626: NEG
20627: PPUSH
20628: LD_INT 1
20630: PPUSH
20631: CALL_OW 12
20635: PLUS
20636: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
20637: LD_VAR 0 6
20641: PPUSH
20642: LD_VAR 0 7
20646: PPUSH
20647: CALL_OW 488
20651: NOT
20652: IFFALSE 20674
// begin _x := x ;
20654: LD_ADDR_VAR 0 6
20658: PUSH
20659: LD_VAR 0 4
20663: ST_TO_ADDR
// _y := y ;
20664: LD_ADDR_VAR 0 7
20668: PUSH
20669: LD_VAR 0 5
20673: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
20674: LD_ADDR_VAR 0 3
20678: PUSH
20679: LD_INT 1
20681: PPUSH
20682: LD_VAR 0 14
20686: PPUSH
20687: CALL_OW 12
20691: ST_TO_ADDR
// case i of 1 :
20692: LD_VAR 0 3
20696: PUSH
20697: LD_INT 1
20699: DOUBLE
20700: EQUAL
20701: IFTRUE 20705
20703: GO 20722
20705: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
20706: LD_VAR 0 1
20710: PPUSH
20711: LD_VAR 0 10
20715: PPUSH
20716: CALL_OW 115
20720: GO 20783
20722: LD_INT 2
20724: DOUBLE
20725: EQUAL
20726: IFTRUE 20730
20728: GO 20752
20730: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
20731: LD_VAR 0 1
20735: PPUSH
20736: LD_VAR 0 6
20740: PPUSH
20741: LD_VAR 0 7
20745: PPUSH
20746: CALL_OW 153
20750: GO 20783
20752: LD_INT 3
20754: DOUBLE
20755: EQUAL
20756: IFTRUE 20760
20758: GO 20782
20760: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
20761: LD_VAR 0 1
20765: PPUSH
20766: LD_VAR 0 6
20770: PPUSH
20771: LD_VAR 0 7
20775: PPUSH
20776: CALL_OW 154
20780: GO 20783
20782: POP
// end ;
20783: LD_VAR 0 2
20787: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
20788: LD_INT 0
20790: PPUSH
20791: PPUSH
20792: PPUSH
20793: PPUSH
20794: PPUSH
20795: PPUSH
// if not unit or not building then
20796: LD_VAR 0 1
20800: NOT
20801: PUSH
20802: LD_VAR 0 2
20806: NOT
20807: OR
20808: IFFALSE 20812
// exit ;
20810: GO 20970
// x := GetX ( building ) ;
20812: LD_ADDR_VAR 0 5
20816: PUSH
20817: LD_VAR 0 2
20821: PPUSH
20822: CALL_OW 250
20826: ST_TO_ADDR
// y := GetY ( building ) ;
20827: LD_ADDR_VAR 0 6
20831: PUSH
20832: LD_VAR 0 2
20836: PPUSH
20837: CALL_OW 251
20841: ST_TO_ADDR
// for i = 0 to 5 do
20842: LD_ADDR_VAR 0 4
20846: PUSH
20847: DOUBLE
20848: LD_INT 0
20850: DEC
20851: ST_TO_ADDR
20852: LD_INT 5
20854: PUSH
20855: FOR_TO
20856: IFFALSE 20968
// begin _x := ShiftX ( x , i , 3 ) ;
20858: LD_ADDR_VAR 0 7
20862: PUSH
20863: LD_VAR 0 5
20867: PPUSH
20868: LD_VAR 0 4
20872: PPUSH
20873: LD_INT 3
20875: PPUSH
20876: CALL_OW 272
20880: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
20881: LD_ADDR_VAR 0 8
20885: PUSH
20886: LD_VAR 0 6
20890: PPUSH
20891: LD_VAR 0 4
20895: PPUSH
20896: LD_INT 3
20898: PPUSH
20899: CALL_OW 273
20903: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
20904: LD_VAR 0 7
20908: PPUSH
20909: LD_VAR 0 8
20913: PPUSH
20914: CALL_OW 488
20918: NOT
20919: IFFALSE 20923
// continue ;
20921: GO 20855
// if HexInfo ( _x , _y ) = 0 then
20923: LD_VAR 0 7
20927: PPUSH
20928: LD_VAR 0 8
20932: PPUSH
20933: CALL_OW 428
20937: PUSH
20938: LD_INT 0
20940: EQUAL
20941: IFFALSE 20966
// begin ComMoveXY ( unit , _x , _y ) ;
20943: LD_VAR 0 1
20947: PPUSH
20948: LD_VAR 0 7
20952: PPUSH
20953: LD_VAR 0 8
20957: PPUSH
20958: CALL_OW 111
// exit ;
20962: POP
20963: POP
20964: GO 20970
// end ; end ;
20966: GO 20855
20968: POP
20969: POP
// end ;
20970: LD_VAR 0 3
20974: RET
// export function ScanBase ( side , base_area ) ; begin
20975: LD_INT 0
20977: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
20978: LD_ADDR_VAR 0 3
20982: PUSH
20983: LD_VAR 0 2
20987: PPUSH
20988: LD_INT 81
20990: PUSH
20991: LD_VAR 0 1
20995: PUSH
20996: EMPTY
20997: LIST
20998: LIST
20999: PPUSH
21000: CALL_OW 70
21004: ST_TO_ADDR
// end ;
21005: LD_VAR 0 3
21009: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
21010: LD_INT 0
21012: PPUSH
21013: PPUSH
21014: PPUSH
21015: PPUSH
// result := false ;
21016: LD_ADDR_VAR 0 2
21020: PUSH
21021: LD_INT 0
21023: ST_TO_ADDR
// side := GetSide ( unit ) ;
21024: LD_ADDR_VAR 0 3
21028: PUSH
21029: LD_VAR 0 1
21033: PPUSH
21034: CALL_OW 255
21038: ST_TO_ADDR
// nat := GetNation ( unit ) ;
21039: LD_ADDR_VAR 0 4
21043: PUSH
21044: LD_VAR 0 1
21048: PPUSH
21049: CALL_OW 248
21053: ST_TO_ADDR
// case nat of 1 :
21054: LD_VAR 0 4
21058: PUSH
21059: LD_INT 1
21061: DOUBLE
21062: EQUAL
21063: IFTRUE 21067
21065: GO 21078
21067: POP
// tech := tech_lassight ; 2 :
21068: LD_ADDR_VAR 0 5
21072: PUSH
21073: LD_INT 12
21075: ST_TO_ADDR
21076: GO 21117
21078: LD_INT 2
21080: DOUBLE
21081: EQUAL
21082: IFTRUE 21086
21084: GO 21097
21086: POP
// tech := tech_mortar ; 3 :
21087: LD_ADDR_VAR 0 5
21091: PUSH
21092: LD_INT 41
21094: ST_TO_ADDR
21095: GO 21117
21097: LD_INT 3
21099: DOUBLE
21100: EQUAL
21101: IFTRUE 21105
21103: GO 21116
21105: POP
// tech := tech_bazooka ; end ;
21106: LD_ADDR_VAR 0 5
21110: PUSH
21111: LD_INT 44
21113: ST_TO_ADDR
21114: GO 21117
21116: POP
// if Researched ( side , tech ) then
21117: LD_VAR 0 3
21121: PPUSH
21122: LD_VAR 0 5
21126: PPUSH
21127: CALL_OW 325
21131: IFFALSE 21158
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
21133: LD_ADDR_VAR 0 2
21137: PUSH
21138: LD_INT 5
21140: PUSH
21141: LD_INT 8
21143: PUSH
21144: LD_INT 9
21146: PUSH
21147: EMPTY
21148: LIST
21149: LIST
21150: LIST
21151: PUSH
21152: LD_VAR 0 4
21156: ARRAY
21157: ST_TO_ADDR
// end ;
21158: LD_VAR 0 2
21162: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
21163: LD_INT 0
21165: PPUSH
21166: PPUSH
21167: PPUSH
// if not mines then
21168: LD_VAR 0 2
21172: NOT
21173: IFFALSE 21177
// exit ;
21175: GO 21321
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
21177: LD_ADDR_VAR 0 5
21181: PUSH
21182: LD_INT 81
21184: PUSH
21185: LD_VAR 0 1
21189: PUSH
21190: EMPTY
21191: LIST
21192: LIST
21193: PUSH
21194: LD_INT 3
21196: PUSH
21197: LD_INT 21
21199: PUSH
21200: LD_INT 3
21202: PUSH
21203: EMPTY
21204: LIST
21205: LIST
21206: PUSH
21207: EMPTY
21208: LIST
21209: LIST
21210: PUSH
21211: EMPTY
21212: LIST
21213: LIST
21214: PPUSH
21215: CALL_OW 69
21219: ST_TO_ADDR
// for i in mines do
21220: LD_ADDR_VAR 0 4
21224: PUSH
21225: LD_VAR 0 2
21229: PUSH
21230: FOR_IN
21231: IFFALSE 21319
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
21233: LD_VAR 0 4
21237: PUSH
21238: LD_INT 1
21240: ARRAY
21241: PPUSH
21242: LD_VAR 0 4
21246: PUSH
21247: LD_INT 2
21249: ARRAY
21250: PPUSH
21251: CALL_OW 458
21255: NOT
21256: IFFALSE 21260
// continue ;
21258: GO 21230
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
21260: LD_VAR 0 4
21264: PUSH
21265: LD_INT 1
21267: ARRAY
21268: PPUSH
21269: LD_VAR 0 4
21273: PUSH
21274: LD_INT 2
21276: ARRAY
21277: PPUSH
21278: CALL_OW 428
21282: PUSH
21283: LD_VAR 0 5
21287: IN
21288: IFFALSE 21317
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
21290: LD_VAR 0 4
21294: PUSH
21295: LD_INT 1
21297: ARRAY
21298: PPUSH
21299: LD_VAR 0 4
21303: PUSH
21304: LD_INT 2
21306: ARRAY
21307: PPUSH
21308: LD_VAR 0 1
21312: PPUSH
21313: CALL_OW 456
// end ;
21317: GO 21230
21319: POP
21320: POP
// end ;
21321: LD_VAR 0 3
21325: RET
// export function Count ( array ) ; begin
21326: LD_INT 0
21328: PPUSH
// result := array + 0 ;
21329: LD_ADDR_VAR 0 2
21333: PUSH
21334: LD_VAR 0 1
21338: PUSH
21339: LD_INT 0
21341: PLUS
21342: ST_TO_ADDR
// end ;
21343: LD_VAR 0 2
21347: RET
// export function IsEmpty ( building ) ; begin
21348: LD_INT 0
21350: PPUSH
// if not building then
21351: LD_VAR 0 1
21355: NOT
21356: IFFALSE 21360
// exit ;
21358: GO 21403
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
21360: LD_ADDR_VAR 0 2
21364: PUSH
21365: LD_VAR 0 1
21369: PUSH
21370: LD_INT 22
21372: PUSH
21373: LD_VAR 0 1
21377: PPUSH
21378: CALL_OW 255
21382: PUSH
21383: EMPTY
21384: LIST
21385: LIST
21386: PUSH
21387: LD_INT 58
21389: PUSH
21390: EMPTY
21391: LIST
21392: PUSH
21393: EMPTY
21394: LIST
21395: LIST
21396: PPUSH
21397: CALL_OW 69
21401: IN
21402: ST_TO_ADDR
// end ;
21403: LD_VAR 0 2
21407: RET
// export function IsNotFull ( building ) ; var places ; begin
21408: LD_INT 0
21410: PPUSH
21411: PPUSH
// if not building then
21412: LD_VAR 0 1
21416: NOT
21417: IFFALSE 21421
// exit ;
21419: GO 21449
// result := UnitFilter ( building , [ f_not , [ f_full ] ] ) ;
21421: LD_ADDR_VAR 0 2
21425: PUSH
21426: LD_VAR 0 1
21430: PPUSH
21431: LD_INT 3
21433: PUSH
21434: LD_INT 62
21436: PUSH
21437: EMPTY
21438: LIST
21439: PUSH
21440: EMPTY
21441: LIST
21442: LIST
21443: PPUSH
21444: CALL_OW 72
21448: ST_TO_ADDR
// end ;
21449: LD_VAR 0 2
21453: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
21454: LD_INT 0
21456: PPUSH
21457: PPUSH
21458: PPUSH
21459: PPUSH
// tmp := [ ] ;
21460: LD_ADDR_VAR 0 3
21464: PUSH
21465: EMPTY
21466: ST_TO_ADDR
// list := [ ] ;
21467: LD_ADDR_VAR 0 5
21471: PUSH
21472: EMPTY
21473: ST_TO_ADDR
// for i = 16 to 25 do
21474: LD_ADDR_VAR 0 4
21478: PUSH
21479: DOUBLE
21480: LD_INT 16
21482: DEC
21483: ST_TO_ADDR
21484: LD_INT 25
21486: PUSH
21487: FOR_TO
21488: IFFALSE 21561
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
21490: LD_ADDR_VAR 0 3
21494: PUSH
21495: LD_VAR 0 3
21499: PUSH
21500: LD_INT 22
21502: PUSH
21503: LD_VAR 0 1
21507: PPUSH
21508: CALL_OW 255
21512: PUSH
21513: EMPTY
21514: LIST
21515: LIST
21516: PUSH
21517: LD_INT 91
21519: PUSH
21520: LD_VAR 0 1
21524: PUSH
21525: LD_INT 6
21527: PUSH
21528: EMPTY
21529: LIST
21530: LIST
21531: LIST
21532: PUSH
21533: LD_INT 30
21535: PUSH
21536: LD_VAR 0 4
21540: PUSH
21541: EMPTY
21542: LIST
21543: LIST
21544: PUSH
21545: EMPTY
21546: LIST
21547: LIST
21548: LIST
21549: PUSH
21550: EMPTY
21551: LIST
21552: PPUSH
21553: CALL_OW 69
21557: ADD
21558: ST_TO_ADDR
21559: GO 21487
21561: POP
21562: POP
// for i = 1 to tmp do
21563: LD_ADDR_VAR 0 4
21567: PUSH
21568: DOUBLE
21569: LD_INT 1
21571: DEC
21572: ST_TO_ADDR
21573: LD_VAR 0 3
21577: PUSH
21578: FOR_TO
21579: IFFALSE 21667
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
21581: LD_ADDR_VAR 0 5
21585: PUSH
21586: LD_VAR 0 5
21590: PUSH
21591: LD_VAR 0 3
21595: PUSH
21596: LD_VAR 0 4
21600: ARRAY
21601: PPUSH
21602: CALL_OW 266
21606: PUSH
21607: LD_VAR 0 3
21611: PUSH
21612: LD_VAR 0 4
21616: ARRAY
21617: PPUSH
21618: CALL_OW 250
21622: PUSH
21623: LD_VAR 0 3
21627: PUSH
21628: LD_VAR 0 4
21632: ARRAY
21633: PPUSH
21634: CALL_OW 251
21638: PUSH
21639: LD_VAR 0 3
21643: PUSH
21644: LD_VAR 0 4
21648: ARRAY
21649: PPUSH
21650: CALL_OW 254
21654: PUSH
21655: EMPTY
21656: LIST
21657: LIST
21658: LIST
21659: LIST
21660: PUSH
21661: EMPTY
21662: LIST
21663: ADD
21664: ST_TO_ADDR
21665: GO 21578
21667: POP
21668: POP
// result := list ;
21669: LD_ADDR_VAR 0 2
21673: PUSH
21674: LD_VAR 0 5
21678: ST_TO_ADDR
// end ;
21679: LD_VAR 0 2
21683: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
21684: LD_INT 0
21686: PPUSH
21687: PPUSH
21688: PPUSH
21689: PPUSH
21690: PPUSH
21691: PPUSH
21692: PPUSH
// if not factory then
21693: LD_VAR 0 1
21697: NOT
21698: IFFALSE 21702
// exit ;
21700: GO 22295
// if control = control_apeman then
21702: LD_VAR 0 4
21706: PUSH
21707: LD_INT 5
21709: EQUAL
21710: IFFALSE 21819
// begin tmp := UnitsInside ( factory ) ;
21712: LD_ADDR_VAR 0 8
21716: PUSH
21717: LD_VAR 0 1
21721: PPUSH
21722: CALL_OW 313
21726: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
21727: LD_VAR 0 8
21731: PPUSH
21732: LD_INT 25
21734: PUSH
21735: LD_INT 12
21737: PUSH
21738: EMPTY
21739: LIST
21740: LIST
21741: PPUSH
21742: CALL_OW 72
21746: NOT
21747: IFFALSE 21757
// control := control_manual ;
21749: LD_ADDR_VAR 0 4
21753: PUSH
21754: LD_INT 1
21756: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
21757: LD_ADDR_VAR 0 8
21761: PUSH
21762: LD_VAR 0 1
21766: PPUSH
21767: CALL 21454 0 1
21771: ST_TO_ADDR
// if tmp then
21772: LD_VAR 0 8
21776: IFFALSE 21819
// begin for i in tmp do
21778: LD_ADDR_VAR 0 7
21782: PUSH
21783: LD_VAR 0 8
21787: PUSH
21788: FOR_IN
21789: IFFALSE 21817
// if i [ 1 ] = b_ext_radio then
21791: LD_VAR 0 7
21795: PUSH
21796: LD_INT 1
21798: ARRAY
21799: PUSH
21800: LD_INT 22
21802: EQUAL
21803: IFFALSE 21815
// begin control := control_remote ;
21805: LD_ADDR_VAR 0 4
21809: PUSH
21810: LD_INT 2
21812: ST_TO_ADDR
// break ;
21813: GO 21817
// end ;
21815: GO 21788
21817: POP
21818: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
21819: LD_VAR 0 1
21823: PPUSH
21824: LD_VAR 0 2
21828: PPUSH
21829: LD_VAR 0 3
21833: PPUSH
21834: LD_VAR 0 4
21838: PPUSH
21839: LD_VAR 0 5
21843: PPUSH
21844: CALL_OW 448
21848: IFFALSE 21883
// begin result := [ chassis , engine , control , weapon ] ;
21850: LD_ADDR_VAR 0 6
21854: PUSH
21855: LD_VAR 0 2
21859: PUSH
21860: LD_VAR 0 3
21864: PUSH
21865: LD_VAR 0 4
21869: PUSH
21870: LD_VAR 0 5
21874: PUSH
21875: EMPTY
21876: LIST
21877: LIST
21878: LIST
21879: LIST
21880: ST_TO_ADDR
// exit ;
21881: GO 22295
// end ; _chassis := AvailableChassisList ( factory ) ;
21883: LD_ADDR_VAR 0 9
21887: PUSH
21888: LD_VAR 0 1
21892: PPUSH
21893: CALL_OW 475
21897: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
21898: LD_ADDR_VAR 0 11
21902: PUSH
21903: LD_VAR 0 1
21907: PPUSH
21908: CALL_OW 476
21912: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
21913: LD_ADDR_VAR 0 12
21917: PUSH
21918: LD_VAR 0 1
21922: PPUSH
21923: CALL_OW 477
21927: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
21928: LD_ADDR_VAR 0 10
21932: PUSH
21933: LD_VAR 0 1
21937: PPUSH
21938: CALL_OW 478
21942: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
21943: LD_VAR 0 9
21947: NOT
21948: PUSH
21949: LD_VAR 0 11
21953: NOT
21954: OR
21955: PUSH
21956: LD_VAR 0 12
21960: NOT
21961: OR
21962: PUSH
21963: LD_VAR 0 10
21967: NOT
21968: OR
21969: IFFALSE 22004
// begin result := [ chassis , engine , control , weapon ] ;
21971: LD_ADDR_VAR 0 6
21975: PUSH
21976: LD_VAR 0 2
21980: PUSH
21981: LD_VAR 0 3
21985: PUSH
21986: LD_VAR 0 4
21990: PUSH
21991: LD_VAR 0 5
21995: PUSH
21996: EMPTY
21997: LIST
21998: LIST
21999: LIST
22000: LIST
22001: ST_TO_ADDR
// exit ;
22002: GO 22295
// end ; if not chassis in _chassis then
22004: LD_VAR 0 2
22008: PUSH
22009: LD_VAR 0 9
22013: IN
22014: NOT
22015: IFFALSE 22041
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
22017: LD_ADDR_VAR 0 2
22021: PUSH
22022: LD_VAR 0 9
22026: PUSH
22027: LD_INT 1
22029: PPUSH
22030: LD_VAR 0 9
22034: PPUSH
22035: CALL_OW 12
22039: ARRAY
22040: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
22041: LD_VAR 0 2
22045: PPUSH
22046: LD_VAR 0 3
22050: PPUSH
22051: CALL 22300 0 2
22055: NOT
22056: IFFALSE 22115
// repeat engine := _engine [ 1 ] ;
22058: LD_ADDR_VAR 0 3
22062: PUSH
22063: LD_VAR 0 11
22067: PUSH
22068: LD_INT 1
22070: ARRAY
22071: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
22072: LD_ADDR_VAR 0 11
22076: PUSH
22077: LD_VAR 0 11
22081: PPUSH
22082: LD_INT 1
22084: PPUSH
22085: CALL_OW 3
22089: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
22090: LD_VAR 0 2
22094: PPUSH
22095: LD_VAR 0 3
22099: PPUSH
22100: CALL 22300 0 2
22104: PUSH
22105: LD_VAR 0 11
22109: PUSH
22110: EMPTY
22111: EQUAL
22112: OR
22113: IFFALSE 22058
// if not control in _control then
22115: LD_VAR 0 4
22119: PUSH
22120: LD_VAR 0 12
22124: IN
22125: NOT
22126: IFFALSE 22152
// control := _control [ rand ( 1 , _control ) ] ;
22128: LD_ADDR_VAR 0 4
22132: PUSH
22133: LD_VAR 0 12
22137: PUSH
22138: LD_INT 1
22140: PPUSH
22141: LD_VAR 0 12
22145: PPUSH
22146: CALL_OW 12
22150: ARRAY
22151: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
22152: LD_VAR 0 2
22156: PPUSH
22157: LD_VAR 0 5
22161: PPUSH
22162: CALL 22520 0 2
22166: NOT
22167: IFFALSE 22226
// repeat weapon := _weapon [ 1 ] ;
22169: LD_ADDR_VAR 0 5
22173: PUSH
22174: LD_VAR 0 10
22178: PUSH
22179: LD_INT 1
22181: ARRAY
22182: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
22183: LD_ADDR_VAR 0 10
22187: PUSH
22188: LD_VAR 0 10
22192: PPUSH
22193: LD_INT 1
22195: PPUSH
22196: CALL_OW 3
22200: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
22201: LD_VAR 0 2
22205: PPUSH
22206: LD_VAR 0 5
22210: PPUSH
22211: CALL 22520 0 2
22215: PUSH
22216: LD_VAR 0 10
22220: PUSH
22221: EMPTY
22222: EQUAL
22223: OR
22224: IFFALSE 22169
// result := [ ] ;
22226: LD_ADDR_VAR 0 6
22230: PUSH
22231: EMPTY
22232: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
22233: LD_VAR 0 1
22237: PPUSH
22238: LD_VAR 0 2
22242: PPUSH
22243: LD_VAR 0 3
22247: PPUSH
22248: LD_VAR 0 4
22252: PPUSH
22253: LD_VAR 0 5
22257: PPUSH
22258: CALL_OW 448
22262: IFFALSE 22295
// result := [ chassis , engine , control , weapon ] ;
22264: LD_ADDR_VAR 0 6
22268: PUSH
22269: LD_VAR 0 2
22273: PUSH
22274: LD_VAR 0 3
22278: PUSH
22279: LD_VAR 0 4
22283: PUSH
22284: LD_VAR 0 5
22288: PUSH
22289: EMPTY
22290: LIST
22291: LIST
22292: LIST
22293: LIST
22294: ST_TO_ADDR
// end ;
22295: LD_VAR 0 6
22299: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
22300: LD_INT 0
22302: PPUSH
// if not chassis or not engine then
22303: LD_VAR 0 1
22307: NOT
22308: PUSH
22309: LD_VAR 0 2
22313: NOT
22314: OR
22315: IFFALSE 22319
// exit ;
22317: GO 22515
// case engine of engine_solar :
22319: LD_VAR 0 2
22323: PUSH
22324: LD_INT 2
22326: DOUBLE
22327: EQUAL
22328: IFTRUE 22332
22330: GO 22370
22332: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
22333: LD_ADDR_VAR 0 3
22337: PUSH
22338: LD_INT 11
22340: PUSH
22341: LD_INT 12
22343: PUSH
22344: LD_INT 13
22346: PUSH
22347: LD_INT 14
22349: PUSH
22350: LD_INT 1
22352: PUSH
22353: LD_INT 2
22355: PUSH
22356: LD_INT 3
22358: PUSH
22359: EMPTY
22360: LIST
22361: LIST
22362: LIST
22363: LIST
22364: LIST
22365: LIST
22366: LIST
22367: ST_TO_ADDR
22368: GO 22499
22370: LD_INT 1
22372: DOUBLE
22373: EQUAL
22374: IFTRUE 22378
22376: GO 22440
22378: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
22379: LD_ADDR_VAR 0 3
22383: PUSH
22384: LD_INT 11
22386: PUSH
22387: LD_INT 12
22389: PUSH
22390: LD_INT 13
22392: PUSH
22393: LD_INT 14
22395: PUSH
22396: LD_INT 1
22398: PUSH
22399: LD_INT 2
22401: PUSH
22402: LD_INT 3
22404: PUSH
22405: LD_INT 4
22407: PUSH
22408: LD_INT 5
22410: PUSH
22411: LD_INT 21
22413: PUSH
22414: LD_INT 23
22416: PUSH
22417: LD_INT 22
22419: PUSH
22420: LD_INT 24
22422: PUSH
22423: EMPTY
22424: LIST
22425: LIST
22426: LIST
22427: LIST
22428: LIST
22429: LIST
22430: LIST
22431: LIST
22432: LIST
22433: LIST
22434: LIST
22435: LIST
22436: LIST
22437: ST_TO_ADDR
22438: GO 22499
22440: LD_INT 3
22442: DOUBLE
22443: EQUAL
22444: IFTRUE 22448
22446: GO 22498
22448: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
22449: LD_ADDR_VAR 0 3
22453: PUSH
22454: LD_INT 13
22456: PUSH
22457: LD_INT 14
22459: PUSH
22460: LD_INT 2
22462: PUSH
22463: LD_INT 3
22465: PUSH
22466: LD_INT 4
22468: PUSH
22469: LD_INT 5
22471: PUSH
22472: LD_INT 21
22474: PUSH
22475: LD_INT 22
22477: PUSH
22478: LD_INT 23
22480: PUSH
22481: LD_INT 24
22483: PUSH
22484: EMPTY
22485: LIST
22486: LIST
22487: LIST
22488: LIST
22489: LIST
22490: LIST
22491: LIST
22492: LIST
22493: LIST
22494: LIST
22495: ST_TO_ADDR
22496: GO 22499
22498: POP
// result := ( chassis in result ) ;
22499: LD_ADDR_VAR 0 3
22503: PUSH
22504: LD_VAR 0 1
22508: PUSH
22509: LD_VAR 0 3
22513: IN
22514: ST_TO_ADDR
// end ;
22515: LD_VAR 0 3
22519: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
22520: LD_INT 0
22522: PPUSH
// if not chassis or not weapon then
22523: LD_VAR 0 1
22527: NOT
22528: PUSH
22529: LD_VAR 0 2
22533: NOT
22534: OR
22535: IFFALSE 22539
// exit ;
22537: GO 23599
// case weapon of us_machine_gun :
22539: LD_VAR 0 2
22543: PUSH
22544: LD_INT 2
22546: DOUBLE
22547: EQUAL
22548: IFTRUE 22552
22550: GO 22582
22552: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
22553: LD_ADDR_VAR 0 3
22557: PUSH
22558: LD_INT 1
22560: PUSH
22561: LD_INT 2
22563: PUSH
22564: LD_INT 3
22566: PUSH
22567: LD_INT 4
22569: PUSH
22570: LD_INT 5
22572: PUSH
22573: EMPTY
22574: LIST
22575: LIST
22576: LIST
22577: LIST
22578: LIST
22579: ST_TO_ADDR
22580: GO 23583
22582: LD_INT 3
22584: DOUBLE
22585: EQUAL
22586: IFTRUE 22590
22588: GO 22620
22590: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
22591: LD_ADDR_VAR 0 3
22595: PUSH
22596: LD_INT 1
22598: PUSH
22599: LD_INT 2
22601: PUSH
22602: LD_INT 3
22604: PUSH
22605: LD_INT 4
22607: PUSH
22608: LD_INT 5
22610: PUSH
22611: EMPTY
22612: LIST
22613: LIST
22614: LIST
22615: LIST
22616: LIST
22617: ST_TO_ADDR
22618: GO 23583
22620: LD_INT 11
22622: DOUBLE
22623: EQUAL
22624: IFTRUE 22628
22626: GO 22658
22628: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
22629: LD_ADDR_VAR 0 3
22633: PUSH
22634: LD_INT 1
22636: PUSH
22637: LD_INT 2
22639: PUSH
22640: LD_INT 3
22642: PUSH
22643: LD_INT 4
22645: PUSH
22646: LD_INT 5
22648: PUSH
22649: EMPTY
22650: LIST
22651: LIST
22652: LIST
22653: LIST
22654: LIST
22655: ST_TO_ADDR
22656: GO 23583
22658: LD_INT 4
22660: DOUBLE
22661: EQUAL
22662: IFTRUE 22666
22664: GO 22692
22666: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
22667: LD_ADDR_VAR 0 3
22671: PUSH
22672: LD_INT 2
22674: PUSH
22675: LD_INT 3
22677: PUSH
22678: LD_INT 4
22680: PUSH
22681: LD_INT 5
22683: PUSH
22684: EMPTY
22685: LIST
22686: LIST
22687: LIST
22688: LIST
22689: ST_TO_ADDR
22690: GO 23583
22692: LD_INT 5
22694: DOUBLE
22695: EQUAL
22696: IFTRUE 22700
22698: GO 22726
22700: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
22701: LD_ADDR_VAR 0 3
22705: PUSH
22706: LD_INT 2
22708: PUSH
22709: LD_INT 3
22711: PUSH
22712: LD_INT 4
22714: PUSH
22715: LD_INT 5
22717: PUSH
22718: EMPTY
22719: LIST
22720: LIST
22721: LIST
22722: LIST
22723: ST_TO_ADDR
22724: GO 23583
22726: LD_INT 9
22728: DOUBLE
22729: EQUAL
22730: IFTRUE 22734
22732: GO 22760
22734: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
22735: LD_ADDR_VAR 0 3
22739: PUSH
22740: LD_INT 2
22742: PUSH
22743: LD_INT 3
22745: PUSH
22746: LD_INT 4
22748: PUSH
22749: LD_INT 5
22751: PUSH
22752: EMPTY
22753: LIST
22754: LIST
22755: LIST
22756: LIST
22757: ST_TO_ADDR
22758: GO 23583
22760: LD_INT 7
22762: DOUBLE
22763: EQUAL
22764: IFTRUE 22768
22766: GO 22794
22768: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
22769: LD_ADDR_VAR 0 3
22773: PUSH
22774: LD_INT 2
22776: PUSH
22777: LD_INT 3
22779: PUSH
22780: LD_INT 4
22782: PUSH
22783: LD_INT 5
22785: PUSH
22786: EMPTY
22787: LIST
22788: LIST
22789: LIST
22790: LIST
22791: ST_TO_ADDR
22792: GO 23583
22794: LD_INT 12
22796: DOUBLE
22797: EQUAL
22798: IFTRUE 22802
22800: GO 22828
22802: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
22803: LD_ADDR_VAR 0 3
22807: PUSH
22808: LD_INT 2
22810: PUSH
22811: LD_INT 3
22813: PUSH
22814: LD_INT 4
22816: PUSH
22817: LD_INT 5
22819: PUSH
22820: EMPTY
22821: LIST
22822: LIST
22823: LIST
22824: LIST
22825: ST_TO_ADDR
22826: GO 23583
22828: LD_INT 13
22830: DOUBLE
22831: EQUAL
22832: IFTRUE 22836
22834: GO 22862
22836: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
22837: LD_ADDR_VAR 0 3
22841: PUSH
22842: LD_INT 2
22844: PUSH
22845: LD_INT 3
22847: PUSH
22848: LD_INT 4
22850: PUSH
22851: LD_INT 5
22853: PUSH
22854: EMPTY
22855: LIST
22856: LIST
22857: LIST
22858: LIST
22859: ST_TO_ADDR
22860: GO 23583
22862: LD_INT 14
22864: DOUBLE
22865: EQUAL
22866: IFTRUE 22870
22868: GO 22888
22870: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
22871: LD_ADDR_VAR 0 3
22875: PUSH
22876: LD_INT 4
22878: PUSH
22879: LD_INT 5
22881: PUSH
22882: EMPTY
22883: LIST
22884: LIST
22885: ST_TO_ADDR
22886: GO 23583
22888: LD_INT 6
22890: DOUBLE
22891: EQUAL
22892: IFTRUE 22896
22894: GO 22914
22896: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
22897: LD_ADDR_VAR 0 3
22901: PUSH
22902: LD_INT 4
22904: PUSH
22905: LD_INT 5
22907: PUSH
22908: EMPTY
22909: LIST
22910: LIST
22911: ST_TO_ADDR
22912: GO 23583
22914: LD_INT 10
22916: DOUBLE
22917: EQUAL
22918: IFTRUE 22922
22920: GO 22940
22922: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
22923: LD_ADDR_VAR 0 3
22927: PUSH
22928: LD_INT 4
22930: PUSH
22931: LD_INT 5
22933: PUSH
22934: EMPTY
22935: LIST
22936: LIST
22937: ST_TO_ADDR
22938: GO 23583
22940: LD_INT 22
22942: DOUBLE
22943: EQUAL
22944: IFTRUE 22948
22946: GO 22974
22948: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
22949: LD_ADDR_VAR 0 3
22953: PUSH
22954: LD_INT 11
22956: PUSH
22957: LD_INT 12
22959: PUSH
22960: LD_INT 13
22962: PUSH
22963: LD_INT 14
22965: PUSH
22966: EMPTY
22967: LIST
22968: LIST
22969: LIST
22970: LIST
22971: ST_TO_ADDR
22972: GO 23583
22974: LD_INT 23
22976: DOUBLE
22977: EQUAL
22978: IFTRUE 22982
22980: GO 23008
22982: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
22983: LD_ADDR_VAR 0 3
22987: PUSH
22988: LD_INT 11
22990: PUSH
22991: LD_INT 12
22993: PUSH
22994: LD_INT 13
22996: PUSH
22997: LD_INT 14
22999: PUSH
23000: EMPTY
23001: LIST
23002: LIST
23003: LIST
23004: LIST
23005: ST_TO_ADDR
23006: GO 23583
23008: LD_INT 24
23010: DOUBLE
23011: EQUAL
23012: IFTRUE 23016
23014: GO 23042
23016: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
23017: LD_ADDR_VAR 0 3
23021: PUSH
23022: LD_INT 11
23024: PUSH
23025: LD_INT 12
23027: PUSH
23028: LD_INT 13
23030: PUSH
23031: LD_INT 14
23033: PUSH
23034: EMPTY
23035: LIST
23036: LIST
23037: LIST
23038: LIST
23039: ST_TO_ADDR
23040: GO 23583
23042: LD_INT 30
23044: DOUBLE
23045: EQUAL
23046: IFTRUE 23050
23048: GO 23076
23050: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
23051: LD_ADDR_VAR 0 3
23055: PUSH
23056: LD_INT 11
23058: PUSH
23059: LD_INT 12
23061: PUSH
23062: LD_INT 13
23064: PUSH
23065: LD_INT 14
23067: PUSH
23068: EMPTY
23069: LIST
23070: LIST
23071: LIST
23072: LIST
23073: ST_TO_ADDR
23074: GO 23583
23076: LD_INT 25
23078: DOUBLE
23079: EQUAL
23080: IFTRUE 23084
23082: GO 23102
23084: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
23085: LD_ADDR_VAR 0 3
23089: PUSH
23090: LD_INT 13
23092: PUSH
23093: LD_INT 14
23095: PUSH
23096: EMPTY
23097: LIST
23098: LIST
23099: ST_TO_ADDR
23100: GO 23583
23102: LD_INT 27
23104: DOUBLE
23105: EQUAL
23106: IFTRUE 23110
23108: GO 23128
23110: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_mortar :
23111: LD_ADDR_VAR 0 3
23115: PUSH
23116: LD_INT 13
23118: PUSH
23119: LD_INT 14
23121: PUSH
23122: EMPTY
23123: LIST
23124: LIST
23125: ST_TO_ADDR
23126: GO 23583
23128: LD_INT 92
23130: DOUBLE
23131: EQUAL
23132: IFTRUE 23136
23134: GO 23162
23136: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
23137: LD_ADDR_VAR 0 3
23141: PUSH
23142: LD_INT 11
23144: PUSH
23145: LD_INT 12
23147: PUSH
23148: LD_INT 13
23150: PUSH
23151: LD_INT 14
23153: PUSH
23154: EMPTY
23155: LIST
23156: LIST
23157: LIST
23158: LIST
23159: ST_TO_ADDR
23160: GO 23583
23162: LD_INT 28
23164: DOUBLE
23165: EQUAL
23166: IFTRUE 23170
23168: GO 23188
23170: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
23171: LD_ADDR_VAR 0 3
23175: PUSH
23176: LD_INT 13
23178: PUSH
23179: LD_INT 14
23181: PUSH
23182: EMPTY
23183: LIST
23184: LIST
23185: ST_TO_ADDR
23186: GO 23583
23188: LD_INT 29
23190: DOUBLE
23191: EQUAL
23192: IFTRUE 23196
23194: GO 23214
23196: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
23197: LD_ADDR_VAR 0 3
23201: PUSH
23202: LD_INT 13
23204: PUSH
23205: LD_INT 14
23207: PUSH
23208: EMPTY
23209: LIST
23210: LIST
23211: ST_TO_ADDR
23212: GO 23583
23214: LD_INT 31
23216: DOUBLE
23217: EQUAL
23218: IFTRUE 23222
23220: GO 23240
23222: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
23223: LD_ADDR_VAR 0 3
23227: PUSH
23228: LD_INT 13
23230: PUSH
23231: LD_INT 14
23233: PUSH
23234: EMPTY
23235: LIST
23236: LIST
23237: ST_TO_ADDR
23238: GO 23583
23240: LD_INT 26
23242: DOUBLE
23243: EQUAL
23244: IFTRUE 23248
23246: GO 23266
23248: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
23249: LD_ADDR_VAR 0 3
23253: PUSH
23254: LD_INT 13
23256: PUSH
23257: LD_INT 14
23259: PUSH
23260: EMPTY
23261: LIST
23262: LIST
23263: ST_TO_ADDR
23264: GO 23583
23266: LD_INT 42
23268: DOUBLE
23269: EQUAL
23270: IFTRUE 23274
23272: GO 23300
23274: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
23275: LD_ADDR_VAR 0 3
23279: PUSH
23280: LD_INT 21
23282: PUSH
23283: LD_INT 22
23285: PUSH
23286: LD_INT 23
23288: PUSH
23289: LD_INT 24
23291: PUSH
23292: EMPTY
23293: LIST
23294: LIST
23295: LIST
23296: LIST
23297: ST_TO_ADDR
23298: GO 23583
23300: LD_INT 43
23302: DOUBLE
23303: EQUAL
23304: IFTRUE 23308
23306: GO 23334
23308: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
23309: LD_ADDR_VAR 0 3
23313: PUSH
23314: LD_INT 21
23316: PUSH
23317: LD_INT 22
23319: PUSH
23320: LD_INT 23
23322: PUSH
23323: LD_INT 24
23325: PUSH
23326: EMPTY
23327: LIST
23328: LIST
23329: LIST
23330: LIST
23331: ST_TO_ADDR
23332: GO 23583
23334: LD_INT 44
23336: DOUBLE
23337: EQUAL
23338: IFTRUE 23342
23340: GO 23368
23342: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
23343: LD_ADDR_VAR 0 3
23347: PUSH
23348: LD_INT 21
23350: PUSH
23351: LD_INT 22
23353: PUSH
23354: LD_INT 23
23356: PUSH
23357: LD_INT 24
23359: PUSH
23360: EMPTY
23361: LIST
23362: LIST
23363: LIST
23364: LIST
23365: ST_TO_ADDR
23366: GO 23583
23368: LD_INT 45
23370: DOUBLE
23371: EQUAL
23372: IFTRUE 23376
23374: GO 23402
23376: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
23377: LD_ADDR_VAR 0 3
23381: PUSH
23382: LD_INT 21
23384: PUSH
23385: LD_INT 22
23387: PUSH
23388: LD_INT 23
23390: PUSH
23391: LD_INT 24
23393: PUSH
23394: EMPTY
23395: LIST
23396: LIST
23397: LIST
23398: LIST
23399: ST_TO_ADDR
23400: GO 23583
23402: LD_INT 49
23404: DOUBLE
23405: EQUAL
23406: IFTRUE 23410
23408: GO 23436
23410: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
23411: LD_ADDR_VAR 0 3
23415: PUSH
23416: LD_INT 21
23418: PUSH
23419: LD_INT 22
23421: PUSH
23422: LD_INT 23
23424: PUSH
23425: LD_INT 24
23427: PUSH
23428: EMPTY
23429: LIST
23430: LIST
23431: LIST
23432: LIST
23433: ST_TO_ADDR
23434: GO 23583
23436: LD_INT 51
23438: DOUBLE
23439: EQUAL
23440: IFTRUE 23444
23442: GO 23470
23444: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
23445: LD_ADDR_VAR 0 3
23449: PUSH
23450: LD_INT 21
23452: PUSH
23453: LD_INT 22
23455: PUSH
23456: LD_INT 23
23458: PUSH
23459: LD_INT 24
23461: PUSH
23462: EMPTY
23463: LIST
23464: LIST
23465: LIST
23466: LIST
23467: ST_TO_ADDR
23468: GO 23583
23470: LD_INT 52
23472: DOUBLE
23473: EQUAL
23474: IFTRUE 23478
23476: GO 23504
23478: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
23479: LD_ADDR_VAR 0 3
23483: PUSH
23484: LD_INT 21
23486: PUSH
23487: LD_INT 22
23489: PUSH
23490: LD_INT 23
23492: PUSH
23493: LD_INT 24
23495: PUSH
23496: EMPTY
23497: LIST
23498: LIST
23499: LIST
23500: LIST
23501: ST_TO_ADDR
23502: GO 23583
23504: LD_INT 53
23506: DOUBLE
23507: EQUAL
23508: IFTRUE 23512
23510: GO 23530
23512: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
23513: LD_ADDR_VAR 0 3
23517: PUSH
23518: LD_INT 23
23520: PUSH
23521: LD_INT 24
23523: PUSH
23524: EMPTY
23525: LIST
23526: LIST
23527: ST_TO_ADDR
23528: GO 23583
23530: LD_INT 46
23532: DOUBLE
23533: EQUAL
23534: IFTRUE 23538
23536: GO 23556
23538: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
23539: LD_ADDR_VAR 0 3
23543: PUSH
23544: LD_INT 23
23546: PUSH
23547: LD_INT 24
23549: PUSH
23550: EMPTY
23551: LIST
23552: LIST
23553: ST_TO_ADDR
23554: GO 23583
23556: LD_INT 47
23558: DOUBLE
23559: EQUAL
23560: IFTRUE 23564
23562: GO 23582
23564: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
23565: LD_ADDR_VAR 0 3
23569: PUSH
23570: LD_INT 23
23572: PUSH
23573: LD_INT 24
23575: PUSH
23576: EMPTY
23577: LIST
23578: LIST
23579: ST_TO_ADDR
23580: GO 23583
23582: POP
// result := ( chassis in result ) ;
23583: LD_ADDR_VAR 0 3
23587: PUSH
23588: LD_VAR 0 1
23592: PUSH
23593: LD_VAR 0 3
23597: IN
23598: ST_TO_ADDR
// end ;
23599: LD_VAR 0 3
23603: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
23604: LD_INT 0
23606: PPUSH
23607: PPUSH
23608: PPUSH
23609: PPUSH
23610: PPUSH
23611: PPUSH
23612: PPUSH
// result := array ;
23613: LD_ADDR_VAR 0 5
23617: PUSH
23618: LD_VAR 0 1
23622: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
23623: LD_VAR 0 1
23627: NOT
23628: PUSH
23629: LD_VAR 0 2
23633: NOT
23634: OR
23635: PUSH
23636: LD_VAR 0 3
23640: NOT
23641: OR
23642: PUSH
23643: LD_VAR 0 2
23647: PUSH
23648: LD_VAR 0 1
23652: GREATER
23653: OR
23654: PUSH
23655: LD_VAR 0 3
23659: PUSH
23660: LD_VAR 0 1
23664: GREATER
23665: OR
23666: IFFALSE 23670
// exit ;
23668: GO 23966
// if direction then
23670: LD_VAR 0 4
23674: IFFALSE 23738
// begin d := 1 ;
23676: LD_ADDR_VAR 0 9
23680: PUSH
23681: LD_INT 1
23683: ST_TO_ADDR
// if i_from > i_to then
23684: LD_VAR 0 2
23688: PUSH
23689: LD_VAR 0 3
23693: GREATER
23694: IFFALSE 23720
// length := ( array - i_from ) + i_to else
23696: LD_ADDR_VAR 0 11
23700: PUSH
23701: LD_VAR 0 1
23705: PUSH
23706: LD_VAR 0 2
23710: MINUS
23711: PUSH
23712: LD_VAR 0 3
23716: PLUS
23717: ST_TO_ADDR
23718: GO 23736
// length := i_to - i_from ;
23720: LD_ADDR_VAR 0 11
23724: PUSH
23725: LD_VAR 0 3
23729: PUSH
23730: LD_VAR 0 2
23734: MINUS
23735: ST_TO_ADDR
// end else
23736: GO 23799
// begin d := - 1 ;
23738: LD_ADDR_VAR 0 9
23742: PUSH
23743: LD_INT 1
23745: NEG
23746: ST_TO_ADDR
// if i_from > i_to then
23747: LD_VAR 0 2
23751: PUSH
23752: LD_VAR 0 3
23756: GREATER
23757: IFFALSE 23777
// length := i_from - i_to else
23759: LD_ADDR_VAR 0 11
23763: PUSH
23764: LD_VAR 0 2
23768: PUSH
23769: LD_VAR 0 3
23773: MINUS
23774: ST_TO_ADDR
23775: GO 23799
// length := ( array - i_to ) + i_from ;
23777: LD_ADDR_VAR 0 11
23781: PUSH
23782: LD_VAR 0 1
23786: PUSH
23787: LD_VAR 0 3
23791: MINUS
23792: PUSH
23793: LD_VAR 0 2
23797: PLUS
23798: ST_TO_ADDR
// end ; if not length then
23799: LD_VAR 0 11
23803: NOT
23804: IFFALSE 23808
// exit ;
23806: GO 23966
// tmp := array ;
23808: LD_ADDR_VAR 0 10
23812: PUSH
23813: LD_VAR 0 1
23817: ST_TO_ADDR
// for i = 1 to length do
23818: LD_ADDR_VAR 0 6
23822: PUSH
23823: DOUBLE
23824: LD_INT 1
23826: DEC
23827: ST_TO_ADDR
23828: LD_VAR 0 11
23832: PUSH
23833: FOR_TO
23834: IFFALSE 23954
// begin for j = 1 to array do
23836: LD_ADDR_VAR 0 7
23840: PUSH
23841: DOUBLE
23842: LD_INT 1
23844: DEC
23845: ST_TO_ADDR
23846: LD_VAR 0 1
23850: PUSH
23851: FOR_TO
23852: IFFALSE 23940
// begin k := j + d ;
23854: LD_ADDR_VAR 0 8
23858: PUSH
23859: LD_VAR 0 7
23863: PUSH
23864: LD_VAR 0 9
23868: PLUS
23869: ST_TO_ADDR
// if k > array then
23870: LD_VAR 0 8
23874: PUSH
23875: LD_VAR 0 1
23879: GREATER
23880: IFFALSE 23890
// k := 1 ;
23882: LD_ADDR_VAR 0 8
23886: PUSH
23887: LD_INT 1
23889: ST_TO_ADDR
// if not k then
23890: LD_VAR 0 8
23894: NOT
23895: IFFALSE 23907
// k := array ;
23897: LD_ADDR_VAR 0 8
23901: PUSH
23902: LD_VAR 0 1
23906: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
23907: LD_ADDR_VAR 0 10
23911: PUSH
23912: LD_VAR 0 10
23916: PPUSH
23917: LD_VAR 0 8
23921: PPUSH
23922: LD_VAR 0 1
23926: PUSH
23927: LD_VAR 0 7
23931: ARRAY
23932: PPUSH
23933: CALL_OW 1
23937: ST_TO_ADDR
// end ;
23938: GO 23851
23940: POP
23941: POP
// array := tmp ;
23942: LD_ADDR_VAR 0 1
23946: PUSH
23947: LD_VAR 0 10
23951: ST_TO_ADDR
// end ;
23952: GO 23833
23954: POP
23955: POP
// result := array ;
23956: LD_ADDR_VAR 0 5
23960: PUSH
23961: LD_VAR 0 1
23965: ST_TO_ADDR
// end ;
23966: LD_VAR 0 5
23970: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
23971: LD_INT 0
23973: PPUSH
23974: PPUSH
// result := 0 ;
23975: LD_ADDR_VAR 0 3
23979: PUSH
23980: LD_INT 0
23982: ST_TO_ADDR
// if not array or not value in array then
23983: LD_VAR 0 1
23987: NOT
23988: PUSH
23989: LD_VAR 0 2
23993: PUSH
23994: LD_VAR 0 1
23998: IN
23999: NOT
24000: OR
24001: IFFALSE 24005
// exit ;
24003: GO 24059
// for i = 1 to array do
24005: LD_ADDR_VAR 0 4
24009: PUSH
24010: DOUBLE
24011: LD_INT 1
24013: DEC
24014: ST_TO_ADDR
24015: LD_VAR 0 1
24019: PUSH
24020: FOR_TO
24021: IFFALSE 24057
// if value = array [ i ] then
24023: LD_VAR 0 2
24027: PUSH
24028: LD_VAR 0 1
24032: PUSH
24033: LD_VAR 0 4
24037: ARRAY
24038: EQUAL
24039: IFFALSE 24055
// begin result := i ;
24041: LD_ADDR_VAR 0 3
24045: PUSH
24046: LD_VAR 0 4
24050: ST_TO_ADDR
// exit ;
24051: POP
24052: POP
24053: GO 24059
// end ;
24055: GO 24020
24057: POP
24058: POP
// end ;
24059: LD_VAR 0 3
24063: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
24064: LD_INT 0
24066: PPUSH
// vc_chassis := chassis ;
24067: LD_ADDR_OWVAR 37
24071: PUSH
24072: LD_VAR 0 1
24076: ST_TO_ADDR
// vc_engine := engine ;
24077: LD_ADDR_OWVAR 39
24081: PUSH
24082: LD_VAR 0 2
24086: ST_TO_ADDR
// vc_control := control ;
24087: LD_ADDR_OWVAR 38
24091: PUSH
24092: LD_VAR 0 3
24096: ST_TO_ADDR
// vc_weapon := weapon ;
24097: LD_ADDR_OWVAR 40
24101: PUSH
24102: LD_VAR 0 4
24106: ST_TO_ADDR
// vc_fuel_battery := fuel ;
24107: LD_ADDR_OWVAR 41
24111: PUSH
24112: LD_VAR 0 5
24116: ST_TO_ADDR
// end ;
24117: LD_VAR 0 6
24121: RET
// export function WantPlant ( unit ) ; var task ; begin
24122: LD_INT 0
24124: PPUSH
24125: PPUSH
// result := false ;
24126: LD_ADDR_VAR 0 2
24130: PUSH
24131: LD_INT 0
24133: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
24134: LD_ADDR_VAR 0 3
24138: PUSH
24139: LD_VAR 0 1
24143: PPUSH
24144: CALL_OW 437
24148: ST_TO_ADDR
// if task then
24149: LD_VAR 0 3
24153: IFFALSE 24181
// if task [ 1 ] [ 1 ] = p then
24155: LD_VAR 0 3
24159: PUSH
24160: LD_INT 1
24162: ARRAY
24163: PUSH
24164: LD_INT 1
24166: ARRAY
24167: PUSH
24168: LD_STRING p
24170: EQUAL
24171: IFFALSE 24181
// result := true ;
24173: LD_ADDR_VAR 0 2
24177: PUSH
24178: LD_INT 1
24180: ST_TO_ADDR
// end ;
24181: LD_VAR 0 2
24185: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
24186: LD_INT 0
24188: PPUSH
24189: PPUSH
24190: PPUSH
24191: PPUSH
// if pos < 1 then
24192: LD_VAR 0 2
24196: PUSH
24197: LD_INT 1
24199: LESS
24200: IFFALSE 24204
// exit ;
24202: GO 24507
// if pos = 1 then
24204: LD_VAR 0 2
24208: PUSH
24209: LD_INT 1
24211: EQUAL
24212: IFFALSE 24245
// result := Replace ( arr , pos [ 1 ] , value ) else
24214: LD_ADDR_VAR 0 4
24218: PUSH
24219: LD_VAR 0 1
24223: PPUSH
24224: LD_VAR 0 2
24228: PUSH
24229: LD_INT 1
24231: ARRAY
24232: PPUSH
24233: LD_VAR 0 3
24237: PPUSH
24238: CALL_OW 1
24242: ST_TO_ADDR
24243: GO 24507
// begin tmp := arr ;
24245: LD_ADDR_VAR 0 6
24249: PUSH
24250: LD_VAR 0 1
24254: ST_TO_ADDR
// s_arr := [ tmp ] ;
24255: LD_ADDR_VAR 0 7
24259: PUSH
24260: LD_VAR 0 6
24264: PUSH
24265: EMPTY
24266: LIST
24267: ST_TO_ADDR
// for i = 1 to pos - 1 do
24268: LD_ADDR_VAR 0 5
24272: PUSH
24273: DOUBLE
24274: LD_INT 1
24276: DEC
24277: ST_TO_ADDR
24278: LD_VAR 0 2
24282: PUSH
24283: LD_INT 1
24285: MINUS
24286: PUSH
24287: FOR_TO
24288: IFFALSE 24333
// begin tmp := tmp [ pos [ i ] ] ;
24290: LD_ADDR_VAR 0 6
24294: PUSH
24295: LD_VAR 0 6
24299: PUSH
24300: LD_VAR 0 2
24304: PUSH
24305: LD_VAR 0 5
24309: ARRAY
24310: ARRAY
24311: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
24312: LD_ADDR_VAR 0 7
24316: PUSH
24317: LD_VAR 0 7
24321: PUSH
24322: LD_VAR 0 6
24326: PUSH
24327: EMPTY
24328: LIST
24329: ADD
24330: ST_TO_ADDR
// end ;
24331: GO 24287
24333: POP
24334: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
24335: LD_ADDR_VAR 0 6
24339: PUSH
24340: LD_VAR 0 6
24344: PPUSH
24345: LD_VAR 0 2
24349: PUSH
24350: LD_VAR 0 2
24354: ARRAY
24355: PPUSH
24356: LD_VAR 0 3
24360: PPUSH
24361: CALL_OW 1
24365: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
24366: LD_ADDR_VAR 0 7
24370: PUSH
24371: LD_VAR 0 7
24375: PPUSH
24376: LD_VAR 0 7
24380: PPUSH
24381: LD_VAR 0 6
24385: PPUSH
24386: CALL_OW 1
24390: ST_TO_ADDR
// for i = s_arr downto 2 do
24391: LD_ADDR_VAR 0 5
24395: PUSH
24396: DOUBLE
24397: LD_VAR 0 7
24401: INC
24402: ST_TO_ADDR
24403: LD_INT 2
24405: PUSH
24406: FOR_DOWNTO
24407: IFFALSE 24491
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
24409: LD_ADDR_VAR 0 6
24413: PUSH
24414: LD_VAR 0 7
24418: PUSH
24419: LD_VAR 0 5
24423: PUSH
24424: LD_INT 1
24426: MINUS
24427: ARRAY
24428: PPUSH
24429: LD_VAR 0 2
24433: PUSH
24434: LD_VAR 0 5
24438: PUSH
24439: LD_INT 1
24441: MINUS
24442: ARRAY
24443: PPUSH
24444: LD_VAR 0 7
24448: PUSH
24449: LD_VAR 0 5
24453: ARRAY
24454: PPUSH
24455: CALL_OW 1
24459: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
24460: LD_ADDR_VAR 0 7
24464: PUSH
24465: LD_VAR 0 7
24469: PPUSH
24470: LD_VAR 0 5
24474: PUSH
24475: LD_INT 1
24477: MINUS
24478: PPUSH
24479: LD_VAR 0 6
24483: PPUSH
24484: CALL_OW 1
24488: ST_TO_ADDR
// end ;
24489: GO 24406
24491: POP
24492: POP
// result := s_arr [ 1 ] ;
24493: LD_ADDR_VAR 0 4
24497: PUSH
24498: LD_VAR 0 7
24502: PUSH
24503: LD_INT 1
24505: ARRAY
24506: ST_TO_ADDR
// end ; end ;
24507: LD_VAR 0 4
24511: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
24512: LD_INT 0
24514: PPUSH
24515: PPUSH
// if not list then
24516: LD_VAR 0 1
24520: NOT
24521: IFFALSE 24525
// exit ;
24523: GO 24616
// i := list [ pos1 ] ;
24525: LD_ADDR_VAR 0 5
24529: PUSH
24530: LD_VAR 0 1
24534: PUSH
24535: LD_VAR 0 2
24539: ARRAY
24540: ST_TO_ADDR
// if not i then
24541: LD_VAR 0 5
24545: NOT
24546: IFFALSE 24550
// exit ;
24548: GO 24616
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
24550: LD_ADDR_VAR 0 1
24554: PUSH
24555: LD_VAR 0 1
24559: PPUSH
24560: LD_VAR 0 2
24564: PPUSH
24565: LD_VAR 0 1
24569: PUSH
24570: LD_VAR 0 3
24574: ARRAY
24575: PPUSH
24576: CALL_OW 1
24580: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
24581: LD_ADDR_VAR 0 1
24585: PUSH
24586: LD_VAR 0 1
24590: PPUSH
24591: LD_VAR 0 3
24595: PPUSH
24596: LD_VAR 0 5
24600: PPUSH
24601: CALL_OW 1
24605: ST_TO_ADDR
// result := list ;
24606: LD_ADDR_VAR 0 4
24610: PUSH
24611: LD_VAR 0 1
24615: ST_TO_ADDR
// end ;
24616: LD_VAR 0 4
24620: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
24621: LD_INT 0
24623: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
24624: LD_ADDR_VAR 0 5
24628: PUSH
24629: LD_VAR 0 1
24633: PPUSH
24634: CALL_OW 250
24638: PPUSH
24639: LD_VAR 0 1
24643: PPUSH
24644: CALL_OW 251
24648: PPUSH
24649: LD_VAR 0 2
24653: PPUSH
24654: LD_VAR 0 3
24658: PPUSH
24659: LD_VAR 0 4
24663: PPUSH
24664: CALL 24674 0 5
24668: ST_TO_ADDR
// end ;
24669: LD_VAR 0 5
24673: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
24674: LD_INT 0
24676: PPUSH
24677: PPUSH
24678: PPUSH
24679: PPUSH
// if not list then
24680: LD_VAR 0 3
24684: NOT
24685: IFFALSE 24689
// exit ;
24687: GO 25077
// result := [ ] ;
24689: LD_ADDR_VAR 0 6
24693: PUSH
24694: EMPTY
24695: ST_TO_ADDR
// for i in list do
24696: LD_ADDR_VAR 0 7
24700: PUSH
24701: LD_VAR 0 3
24705: PUSH
24706: FOR_IN
24707: IFFALSE 24909
// begin tmp := GetDistUnitXY ( i , x , y ) ;
24709: LD_ADDR_VAR 0 9
24713: PUSH
24714: LD_VAR 0 7
24718: PPUSH
24719: LD_VAR 0 1
24723: PPUSH
24724: LD_VAR 0 2
24728: PPUSH
24729: CALL_OW 297
24733: ST_TO_ADDR
// if not result then
24734: LD_VAR 0 6
24738: NOT
24739: IFFALSE 24765
// result := [ [ i , tmp ] ] else
24741: LD_ADDR_VAR 0 6
24745: PUSH
24746: LD_VAR 0 7
24750: PUSH
24751: LD_VAR 0 9
24755: PUSH
24756: EMPTY
24757: LIST
24758: LIST
24759: PUSH
24760: EMPTY
24761: LIST
24762: ST_TO_ADDR
24763: GO 24907
// begin if result [ result ] [ 2 ] < tmp then
24765: LD_VAR 0 6
24769: PUSH
24770: LD_VAR 0 6
24774: ARRAY
24775: PUSH
24776: LD_INT 2
24778: ARRAY
24779: PUSH
24780: LD_VAR 0 9
24784: LESS
24785: IFFALSE 24827
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
24787: LD_ADDR_VAR 0 6
24791: PUSH
24792: LD_VAR 0 6
24796: PPUSH
24797: LD_VAR 0 6
24801: PUSH
24802: LD_INT 1
24804: PLUS
24805: PPUSH
24806: LD_VAR 0 7
24810: PUSH
24811: LD_VAR 0 9
24815: PUSH
24816: EMPTY
24817: LIST
24818: LIST
24819: PPUSH
24820: CALL_OW 2
24824: ST_TO_ADDR
24825: GO 24907
// for j = 1 to result do
24827: LD_ADDR_VAR 0 8
24831: PUSH
24832: DOUBLE
24833: LD_INT 1
24835: DEC
24836: ST_TO_ADDR
24837: LD_VAR 0 6
24841: PUSH
24842: FOR_TO
24843: IFFALSE 24905
// begin if tmp < result [ j ] [ 2 ] then
24845: LD_VAR 0 9
24849: PUSH
24850: LD_VAR 0 6
24854: PUSH
24855: LD_VAR 0 8
24859: ARRAY
24860: PUSH
24861: LD_INT 2
24863: ARRAY
24864: LESS
24865: IFFALSE 24903
// begin result := Insert ( result , j , [ i , tmp ] ) ;
24867: LD_ADDR_VAR 0 6
24871: PUSH
24872: LD_VAR 0 6
24876: PPUSH
24877: LD_VAR 0 8
24881: PPUSH
24882: LD_VAR 0 7
24886: PUSH
24887: LD_VAR 0 9
24891: PUSH
24892: EMPTY
24893: LIST
24894: LIST
24895: PPUSH
24896: CALL_OW 2
24900: ST_TO_ADDR
// break ;
24901: GO 24905
// end ; end ;
24903: GO 24842
24905: POP
24906: POP
// end ; end ;
24907: GO 24706
24909: POP
24910: POP
// if result and not asc then
24911: LD_VAR 0 6
24915: PUSH
24916: LD_VAR 0 4
24920: NOT
24921: AND
24922: IFFALSE 24997
// begin tmp := result ;
24924: LD_ADDR_VAR 0 9
24928: PUSH
24929: LD_VAR 0 6
24933: ST_TO_ADDR
// for i = tmp downto 1 do
24934: LD_ADDR_VAR 0 7
24938: PUSH
24939: DOUBLE
24940: LD_VAR 0 9
24944: INC
24945: ST_TO_ADDR
24946: LD_INT 1
24948: PUSH
24949: FOR_DOWNTO
24950: IFFALSE 24995
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
24952: LD_ADDR_VAR 0 6
24956: PUSH
24957: LD_VAR 0 6
24961: PPUSH
24962: LD_VAR 0 9
24966: PUSH
24967: LD_VAR 0 7
24971: MINUS
24972: PUSH
24973: LD_INT 1
24975: PLUS
24976: PPUSH
24977: LD_VAR 0 9
24981: PUSH
24982: LD_VAR 0 7
24986: ARRAY
24987: PPUSH
24988: CALL_OW 1
24992: ST_TO_ADDR
24993: GO 24949
24995: POP
24996: POP
// end ; tmp := [ ] ;
24997: LD_ADDR_VAR 0 9
25001: PUSH
25002: EMPTY
25003: ST_TO_ADDR
// if mode then
25004: LD_VAR 0 5
25008: IFFALSE 25077
// begin for i = 1 to result do
25010: LD_ADDR_VAR 0 7
25014: PUSH
25015: DOUBLE
25016: LD_INT 1
25018: DEC
25019: ST_TO_ADDR
25020: LD_VAR 0 6
25024: PUSH
25025: FOR_TO
25026: IFFALSE 25065
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
25028: LD_ADDR_VAR 0 9
25032: PUSH
25033: LD_VAR 0 9
25037: PPUSH
25038: LD_VAR 0 7
25042: PPUSH
25043: LD_VAR 0 6
25047: PUSH
25048: LD_VAR 0 7
25052: ARRAY
25053: PUSH
25054: LD_INT 1
25056: ARRAY
25057: PPUSH
25058: CALL_OW 1
25062: ST_TO_ADDR
25063: GO 25025
25065: POP
25066: POP
// result := tmp ;
25067: LD_ADDR_VAR 0 6
25071: PUSH
25072: LD_VAR 0 9
25076: ST_TO_ADDR
// end ; end ;
25077: LD_VAR 0 6
25081: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
25082: LD_INT 0
25084: PPUSH
25085: PPUSH
25086: PPUSH
25087: PPUSH
25088: PPUSH
25089: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
25090: LD_ADDR_VAR 0 5
25094: PUSH
25095: LD_INT 0
25097: PUSH
25098: LD_INT 0
25100: PUSH
25101: LD_INT 0
25103: PUSH
25104: EMPTY
25105: PUSH
25106: EMPTY
25107: LIST
25108: LIST
25109: LIST
25110: LIST
25111: ST_TO_ADDR
// if not x or not y then
25112: LD_VAR 0 2
25116: NOT
25117: PUSH
25118: LD_VAR 0 3
25122: NOT
25123: OR
25124: IFFALSE 25128
// exit ;
25126: GO 26778
// if not range then
25128: LD_VAR 0 4
25132: NOT
25133: IFFALSE 25143
// range := 10 ;
25135: LD_ADDR_VAR 0 4
25139: PUSH
25140: LD_INT 10
25142: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
25143: LD_ADDR_VAR 0 8
25147: PUSH
25148: LD_INT 81
25150: PUSH
25151: LD_VAR 0 1
25155: PUSH
25156: EMPTY
25157: LIST
25158: LIST
25159: PUSH
25160: LD_INT 92
25162: PUSH
25163: LD_VAR 0 2
25167: PUSH
25168: LD_VAR 0 3
25172: PUSH
25173: LD_VAR 0 4
25177: PUSH
25178: EMPTY
25179: LIST
25180: LIST
25181: LIST
25182: LIST
25183: PUSH
25184: LD_INT 3
25186: PUSH
25187: LD_INT 21
25189: PUSH
25190: LD_INT 3
25192: PUSH
25193: EMPTY
25194: LIST
25195: LIST
25196: PUSH
25197: EMPTY
25198: LIST
25199: LIST
25200: PUSH
25201: EMPTY
25202: LIST
25203: LIST
25204: LIST
25205: PPUSH
25206: CALL_OW 69
25210: ST_TO_ADDR
// if not tmp then
25211: LD_VAR 0 8
25215: NOT
25216: IFFALSE 25220
// exit ;
25218: GO 26778
// for i in tmp do
25220: LD_ADDR_VAR 0 6
25224: PUSH
25225: LD_VAR 0 8
25229: PUSH
25230: FOR_IN
25231: IFFALSE 26753
// begin points := [ 0 , 0 , 0 ] ;
25233: LD_ADDR_VAR 0 9
25237: PUSH
25238: LD_INT 0
25240: PUSH
25241: LD_INT 0
25243: PUSH
25244: LD_INT 0
25246: PUSH
25247: EMPTY
25248: LIST
25249: LIST
25250: LIST
25251: ST_TO_ADDR
// bpoints := 1 ;
25252: LD_ADDR_VAR 0 10
25256: PUSH
25257: LD_INT 1
25259: ST_TO_ADDR
// case GetType ( i ) of unit_human :
25260: LD_VAR 0 6
25264: PPUSH
25265: CALL_OW 247
25269: PUSH
25270: LD_INT 1
25272: DOUBLE
25273: EQUAL
25274: IFTRUE 25278
25276: GO 25856
25278: POP
// begin if GetClass ( i ) = 1 then
25279: LD_VAR 0 6
25283: PPUSH
25284: CALL_OW 257
25288: PUSH
25289: LD_INT 1
25291: EQUAL
25292: IFFALSE 25313
// points := [ 10 , 5 , 3 ] ;
25294: LD_ADDR_VAR 0 9
25298: PUSH
25299: LD_INT 10
25301: PUSH
25302: LD_INT 5
25304: PUSH
25305: LD_INT 3
25307: PUSH
25308: EMPTY
25309: LIST
25310: LIST
25311: LIST
25312: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
25313: LD_VAR 0 6
25317: PPUSH
25318: CALL_OW 257
25322: PUSH
25323: LD_INT 2
25325: PUSH
25326: LD_INT 3
25328: PUSH
25329: LD_INT 4
25331: PUSH
25332: EMPTY
25333: LIST
25334: LIST
25335: LIST
25336: IN
25337: IFFALSE 25358
// points := [ 3 , 2 , 1 ] ;
25339: LD_ADDR_VAR 0 9
25343: PUSH
25344: LD_INT 3
25346: PUSH
25347: LD_INT 2
25349: PUSH
25350: LD_INT 1
25352: PUSH
25353: EMPTY
25354: LIST
25355: LIST
25356: LIST
25357: ST_TO_ADDR
// if GetClass ( i ) = 5 then
25358: LD_VAR 0 6
25362: PPUSH
25363: CALL_OW 257
25367: PUSH
25368: LD_INT 5
25370: EQUAL
25371: IFFALSE 25392
// points := [ 130 , 5 , 2 ] ;
25373: LD_ADDR_VAR 0 9
25377: PUSH
25378: LD_INT 130
25380: PUSH
25381: LD_INT 5
25383: PUSH
25384: LD_INT 2
25386: PUSH
25387: EMPTY
25388: LIST
25389: LIST
25390: LIST
25391: ST_TO_ADDR
// if GetClass ( i ) = 8 then
25392: LD_VAR 0 6
25396: PPUSH
25397: CALL_OW 257
25401: PUSH
25402: LD_INT 8
25404: EQUAL
25405: IFFALSE 25426
// points := [ 35 , 35 , 30 ] ;
25407: LD_ADDR_VAR 0 9
25411: PUSH
25412: LD_INT 35
25414: PUSH
25415: LD_INT 35
25417: PUSH
25418: LD_INT 30
25420: PUSH
25421: EMPTY
25422: LIST
25423: LIST
25424: LIST
25425: ST_TO_ADDR
// if GetClass ( i ) = 9 then
25426: LD_VAR 0 6
25430: PPUSH
25431: CALL_OW 257
25435: PUSH
25436: LD_INT 9
25438: EQUAL
25439: IFFALSE 25460
// points := [ 20 , 55 , 40 ] ;
25441: LD_ADDR_VAR 0 9
25445: PUSH
25446: LD_INT 20
25448: PUSH
25449: LD_INT 55
25451: PUSH
25452: LD_INT 40
25454: PUSH
25455: EMPTY
25456: LIST
25457: LIST
25458: LIST
25459: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
25460: LD_VAR 0 6
25464: PPUSH
25465: CALL_OW 257
25469: PUSH
25470: LD_INT 12
25472: PUSH
25473: LD_INT 16
25475: PUSH
25476: EMPTY
25477: LIST
25478: LIST
25479: IN
25480: IFFALSE 25501
// points := [ 5 , 3 , 2 ] ;
25482: LD_ADDR_VAR 0 9
25486: PUSH
25487: LD_INT 5
25489: PUSH
25490: LD_INT 3
25492: PUSH
25493: LD_INT 2
25495: PUSH
25496: EMPTY
25497: LIST
25498: LIST
25499: LIST
25500: ST_TO_ADDR
// if GetClass ( i ) = 17 then
25501: LD_VAR 0 6
25505: PPUSH
25506: CALL_OW 257
25510: PUSH
25511: LD_INT 17
25513: EQUAL
25514: IFFALSE 25535
// points := [ 100 , 50 , 75 ] ;
25516: LD_ADDR_VAR 0 9
25520: PUSH
25521: LD_INT 100
25523: PUSH
25524: LD_INT 50
25526: PUSH
25527: LD_INT 75
25529: PUSH
25530: EMPTY
25531: LIST
25532: LIST
25533: LIST
25534: ST_TO_ADDR
// if GetClass ( i ) = 15 then
25535: LD_VAR 0 6
25539: PPUSH
25540: CALL_OW 257
25544: PUSH
25545: LD_INT 15
25547: EQUAL
25548: IFFALSE 25569
// points := [ 10 , 5 , 3 ] ;
25550: LD_ADDR_VAR 0 9
25554: PUSH
25555: LD_INT 10
25557: PUSH
25558: LD_INT 5
25560: PUSH
25561: LD_INT 3
25563: PUSH
25564: EMPTY
25565: LIST
25566: LIST
25567: LIST
25568: ST_TO_ADDR
// if GetClass ( i ) = 14 then
25569: LD_VAR 0 6
25573: PPUSH
25574: CALL_OW 257
25578: PUSH
25579: LD_INT 14
25581: EQUAL
25582: IFFALSE 25603
// points := [ 10 , 0 , 0 ] ;
25584: LD_ADDR_VAR 0 9
25588: PUSH
25589: LD_INT 10
25591: PUSH
25592: LD_INT 0
25594: PUSH
25595: LD_INT 0
25597: PUSH
25598: EMPTY
25599: LIST
25600: LIST
25601: LIST
25602: ST_TO_ADDR
// if GetClass ( i ) = 11 then
25603: LD_VAR 0 6
25607: PPUSH
25608: CALL_OW 257
25612: PUSH
25613: LD_INT 11
25615: EQUAL
25616: IFFALSE 25637
// points := [ 30 , 10 , 5 ] ;
25618: LD_ADDR_VAR 0 9
25622: PUSH
25623: LD_INT 30
25625: PUSH
25626: LD_INT 10
25628: PUSH
25629: LD_INT 5
25631: PUSH
25632: EMPTY
25633: LIST
25634: LIST
25635: LIST
25636: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
25637: LD_VAR 0 1
25641: PPUSH
25642: LD_INT 5
25644: PPUSH
25645: CALL_OW 321
25649: PUSH
25650: LD_INT 2
25652: EQUAL
25653: IFFALSE 25670
// bpoints := bpoints * 1.8 ;
25655: LD_ADDR_VAR 0 10
25659: PUSH
25660: LD_VAR 0 10
25664: PUSH
25665: LD_REAL  1.80000000000000E+0000
25668: MUL
25669: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
25670: LD_VAR 0 6
25674: PPUSH
25675: CALL_OW 257
25679: PUSH
25680: LD_INT 1
25682: PUSH
25683: LD_INT 2
25685: PUSH
25686: LD_INT 3
25688: PUSH
25689: LD_INT 4
25691: PUSH
25692: EMPTY
25693: LIST
25694: LIST
25695: LIST
25696: LIST
25697: IN
25698: PUSH
25699: LD_VAR 0 1
25703: PPUSH
25704: LD_INT 51
25706: PPUSH
25707: CALL_OW 321
25711: PUSH
25712: LD_INT 2
25714: EQUAL
25715: AND
25716: IFFALSE 25733
// bpoints := bpoints * 1.2 ;
25718: LD_ADDR_VAR 0 10
25722: PUSH
25723: LD_VAR 0 10
25727: PUSH
25728: LD_REAL  1.20000000000000E+0000
25731: MUL
25732: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
25733: LD_VAR 0 6
25737: PPUSH
25738: CALL_OW 257
25742: PUSH
25743: LD_INT 5
25745: PUSH
25746: LD_INT 7
25748: PUSH
25749: LD_INT 9
25751: PUSH
25752: EMPTY
25753: LIST
25754: LIST
25755: LIST
25756: IN
25757: PUSH
25758: LD_VAR 0 1
25762: PPUSH
25763: LD_INT 52
25765: PPUSH
25766: CALL_OW 321
25770: PUSH
25771: LD_INT 2
25773: EQUAL
25774: AND
25775: IFFALSE 25792
// bpoints := bpoints * 1.5 ;
25777: LD_ADDR_VAR 0 10
25781: PUSH
25782: LD_VAR 0 10
25786: PUSH
25787: LD_REAL  1.50000000000000E+0000
25790: MUL
25791: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
25792: LD_VAR 0 1
25796: PPUSH
25797: LD_INT 66
25799: PPUSH
25800: CALL_OW 321
25804: PUSH
25805: LD_INT 2
25807: EQUAL
25808: IFFALSE 25825
// bpoints := bpoints * 1.1 ;
25810: LD_ADDR_VAR 0 10
25814: PUSH
25815: LD_VAR 0 10
25819: PUSH
25820: LD_REAL  1.10000000000000E+0000
25823: MUL
25824: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
25825: LD_ADDR_VAR 0 10
25829: PUSH
25830: LD_VAR 0 10
25834: PUSH
25835: LD_VAR 0 6
25839: PPUSH
25840: LD_INT 1
25842: PPUSH
25843: CALL_OW 259
25847: PUSH
25848: LD_REAL  1.15000000000000E+0000
25851: MUL
25852: MUL
25853: ST_TO_ADDR
// end ; unit_vehicle :
25854: GO 26682
25856: LD_INT 2
25858: DOUBLE
25859: EQUAL
25860: IFTRUE 25864
25862: GO 26670
25864: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
25865: LD_VAR 0 6
25869: PPUSH
25870: CALL_OW 264
25874: PUSH
25875: LD_INT 2
25877: PUSH
25878: LD_INT 42
25880: PUSH
25881: LD_INT 24
25883: PUSH
25884: EMPTY
25885: LIST
25886: LIST
25887: LIST
25888: IN
25889: IFFALSE 25910
// points := [ 25 , 5 , 3 ] ;
25891: LD_ADDR_VAR 0 9
25895: PUSH
25896: LD_INT 25
25898: PUSH
25899: LD_INT 5
25901: PUSH
25902: LD_INT 3
25904: PUSH
25905: EMPTY
25906: LIST
25907: LIST
25908: LIST
25909: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
25910: LD_VAR 0 6
25914: PPUSH
25915: CALL_OW 264
25919: PUSH
25920: LD_INT 4
25922: PUSH
25923: LD_INT 43
25925: PUSH
25926: LD_INT 25
25928: PUSH
25929: EMPTY
25930: LIST
25931: LIST
25932: LIST
25933: IN
25934: IFFALSE 25955
// points := [ 40 , 15 , 5 ] ;
25936: LD_ADDR_VAR 0 9
25940: PUSH
25941: LD_INT 40
25943: PUSH
25944: LD_INT 15
25946: PUSH
25947: LD_INT 5
25949: PUSH
25950: EMPTY
25951: LIST
25952: LIST
25953: LIST
25954: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
25955: LD_VAR 0 6
25959: PPUSH
25960: CALL_OW 264
25964: PUSH
25965: LD_INT 3
25967: PUSH
25968: LD_INT 23
25970: PUSH
25971: EMPTY
25972: LIST
25973: LIST
25974: IN
25975: IFFALSE 25996
// points := [ 7 , 25 , 8 ] ;
25977: LD_ADDR_VAR 0 9
25981: PUSH
25982: LD_INT 7
25984: PUSH
25985: LD_INT 25
25987: PUSH
25988: LD_INT 8
25990: PUSH
25991: EMPTY
25992: LIST
25993: LIST
25994: LIST
25995: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
25996: LD_VAR 0 6
26000: PPUSH
26001: CALL_OW 264
26005: PUSH
26006: LD_INT 5
26008: PUSH
26009: LD_INT 27
26011: PUSH
26012: LD_INT 44
26014: PUSH
26015: EMPTY
26016: LIST
26017: LIST
26018: LIST
26019: IN
26020: IFFALSE 26041
// points := [ 14 , 50 , 16 ] ;
26022: LD_ADDR_VAR 0 9
26026: PUSH
26027: LD_INT 14
26029: PUSH
26030: LD_INT 50
26032: PUSH
26033: LD_INT 16
26035: PUSH
26036: EMPTY
26037: LIST
26038: LIST
26039: LIST
26040: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
26041: LD_VAR 0 6
26045: PPUSH
26046: CALL_OW 264
26050: PUSH
26051: LD_INT 6
26053: PUSH
26054: LD_INT 46
26056: PUSH
26057: EMPTY
26058: LIST
26059: LIST
26060: IN
26061: IFFALSE 26082
// points := [ 32 , 120 , 70 ] ;
26063: LD_ADDR_VAR 0 9
26067: PUSH
26068: LD_INT 32
26070: PUSH
26071: LD_INT 120
26073: PUSH
26074: LD_INT 70
26076: PUSH
26077: EMPTY
26078: LIST
26079: LIST
26080: LIST
26081: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher , ar_mortar ] then
26082: LD_VAR 0 6
26086: PPUSH
26087: CALL_OW 264
26091: PUSH
26092: LD_INT 7
26094: PUSH
26095: LD_INT 28
26097: PUSH
26098: LD_INT 45
26100: PUSH
26101: LD_INT 92
26103: PUSH
26104: EMPTY
26105: LIST
26106: LIST
26107: LIST
26108: LIST
26109: IN
26110: IFFALSE 26131
// points := [ 35 , 20 , 45 ] ;
26112: LD_ADDR_VAR 0 9
26116: PUSH
26117: LD_INT 35
26119: PUSH
26120: LD_INT 20
26122: PUSH
26123: LD_INT 45
26125: PUSH
26126: EMPTY
26127: LIST
26128: LIST
26129: LIST
26130: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
26131: LD_VAR 0 6
26135: PPUSH
26136: CALL_OW 264
26140: PUSH
26141: LD_INT 47
26143: PUSH
26144: EMPTY
26145: LIST
26146: IN
26147: IFFALSE 26168
// points := [ 67 , 45 , 75 ] ;
26149: LD_ADDR_VAR 0 9
26153: PUSH
26154: LD_INT 67
26156: PUSH
26157: LD_INT 45
26159: PUSH
26160: LD_INT 75
26162: PUSH
26163: EMPTY
26164: LIST
26165: LIST
26166: LIST
26167: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
26168: LD_VAR 0 6
26172: PPUSH
26173: CALL_OW 264
26177: PUSH
26178: LD_INT 26
26180: PUSH
26181: EMPTY
26182: LIST
26183: IN
26184: IFFALSE 26205
// points := [ 120 , 30 , 80 ] ;
26186: LD_ADDR_VAR 0 9
26190: PUSH
26191: LD_INT 120
26193: PUSH
26194: LD_INT 30
26196: PUSH
26197: LD_INT 80
26199: PUSH
26200: EMPTY
26201: LIST
26202: LIST
26203: LIST
26204: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
26205: LD_VAR 0 6
26209: PPUSH
26210: CALL_OW 264
26214: PUSH
26215: LD_INT 22
26217: PUSH
26218: EMPTY
26219: LIST
26220: IN
26221: IFFALSE 26242
// points := [ 40 , 1 , 1 ] ;
26223: LD_ADDR_VAR 0 9
26227: PUSH
26228: LD_INT 40
26230: PUSH
26231: LD_INT 1
26233: PUSH
26234: LD_INT 1
26236: PUSH
26237: EMPTY
26238: LIST
26239: LIST
26240: LIST
26241: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
26242: LD_VAR 0 6
26246: PPUSH
26247: CALL_OW 264
26251: PUSH
26252: LD_INT 29
26254: PUSH
26255: EMPTY
26256: LIST
26257: IN
26258: IFFALSE 26279
// points := [ 70 , 200 , 400 ] ;
26260: LD_ADDR_VAR 0 9
26264: PUSH
26265: LD_INT 70
26267: PUSH
26268: LD_INT 200
26270: PUSH
26271: LD_INT 400
26273: PUSH
26274: EMPTY
26275: LIST
26276: LIST
26277: LIST
26278: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
26279: LD_VAR 0 6
26283: PPUSH
26284: CALL_OW 264
26288: PUSH
26289: LD_INT 14
26291: PUSH
26292: LD_INT 53
26294: PUSH
26295: EMPTY
26296: LIST
26297: LIST
26298: IN
26299: IFFALSE 26320
// points := [ 40 , 10 , 20 ] ;
26301: LD_ADDR_VAR 0 9
26305: PUSH
26306: LD_INT 40
26308: PUSH
26309: LD_INT 10
26311: PUSH
26312: LD_INT 20
26314: PUSH
26315: EMPTY
26316: LIST
26317: LIST
26318: LIST
26319: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
26320: LD_VAR 0 6
26324: PPUSH
26325: CALL_OW 264
26329: PUSH
26330: LD_INT 9
26332: PUSH
26333: EMPTY
26334: LIST
26335: IN
26336: IFFALSE 26357
// points := [ 5 , 70 , 20 ] ;
26338: LD_ADDR_VAR 0 9
26342: PUSH
26343: LD_INT 5
26345: PUSH
26346: LD_INT 70
26348: PUSH
26349: LD_INT 20
26351: PUSH
26352: EMPTY
26353: LIST
26354: LIST
26355: LIST
26356: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
26357: LD_VAR 0 6
26361: PPUSH
26362: CALL_OW 264
26366: PUSH
26367: LD_INT 10
26369: PUSH
26370: EMPTY
26371: LIST
26372: IN
26373: IFFALSE 26394
// points := [ 35 , 110 , 70 ] ;
26375: LD_ADDR_VAR 0 9
26379: PUSH
26380: LD_INT 35
26382: PUSH
26383: LD_INT 110
26385: PUSH
26386: LD_INT 70
26388: PUSH
26389: EMPTY
26390: LIST
26391: LIST
26392: LIST
26393: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
26394: LD_VAR 0 6
26398: PPUSH
26399: CALL_OW 265
26403: PUSH
26404: LD_INT 25
26406: EQUAL
26407: IFFALSE 26428
// points := [ 80 , 65 , 100 ] ;
26409: LD_ADDR_VAR 0 9
26413: PUSH
26414: LD_INT 80
26416: PUSH
26417: LD_INT 65
26419: PUSH
26420: LD_INT 100
26422: PUSH
26423: EMPTY
26424: LIST
26425: LIST
26426: LIST
26427: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
26428: LD_VAR 0 6
26432: PPUSH
26433: CALL_OW 263
26437: PUSH
26438: LD_INT 1
26440: EQUAL
26441: IFFALSE 26476
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
26443: LD_ADDR_VAR 0 10
26447: PUSH
26448: LD_VAR 0 10
26452: PUSH
26453: LD_VAR 0 6
26457: PPUSH
26458: CALL_OW 311
26462: PPUSH
26463: LD_INT 3
26465: PPUSH
26466: CALL_OW 259
26470: PUSH
26471: LD_INT 4
26473: MUL
26474: MUL
26475: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
26476: LD_VAR 0 6
26480: PPUSH
26481: CALL_OW 263
26485: PUSH
26486: LD_INT 2
26488: EQUAL
26489: IFFALSE 26540
// begin j := IsControledBy ( i ) ;
26491: LD_ADDR_VAR 0 7
26495: PUSH
26496: LD_VAR 0 6
26500: PPUSH
26501: CALL_OW 312
26505: ST_TO_ADDR
// if j then
26506: LD_VAR 0 7
26510: IFFALSE 26540
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
26512: LD_ADDR_VAR 0 10
26516: PUSH
26517: LD_VAR 0 10
26521: PUSH
26522: LD_VAR 0 7
26526: PPUSH
26527: LD_INT 3
26529: PPUSH
26530: CALL_OW 259
26534: PUSH
26535: LD_INT 3
26537: MUL
26538: MUL
26539: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
26540: LD_VAR 0 6
26544: PPUSH
26545: CALL_OW 264
26549: PUSH
26550: LD_INT 5
26552: PUSH
26553: LD_INT 6
26555: PUSH
26556: LD_INT 46
26558: PUSH
26559: LD_INT 44
26561: PUSH
26562: LD_INT 47
26564: PUSH
26565: LD_INT 45
26567: PUSH
26568: LD_INT 28
26570: PUSH
26571: LD_INT 7
26573: PUSH
26574: LD_INT 27
26576: PUSH
26577: LD_INT 29
26579: PUSH
26580: EMPTY
26581: LIST
26582: LIST
26583: LIST
26584: LIST
26585: LIST
26586: LIST
26587: LIST
26588: LIST
26589: LIST
26590: LIST
26591: IN
26592: PUSH
26593: LD_VAR 0 1
26597: PPUSH
26598: LD_INT 52
26600: PPUSH
26601: CALL_OW 321
26605: PUSH
26606: LD_INT 2
26608: EQUAL
26609: AND
26610: IFFALSE 26627
// bpoints := bpoints * 1.2 ;
26612: LD_ADDR_VAR 0 10
26616: PUSH
26617: LD_VAR 0 10
26621: PUSH
26622: LD_REAL  1.20000000000000E+0000
26625: MUL
26626: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
26627: LD_VAR 0 6
26631: PPUSH
26632: CALL_OW 264
26636: PUSH
26637: LD_INT 6
26639: PUSH
26640: LD_INT 46
26642: PUSH
26643: LD_INT 47
26645: PUSH
26646: EMPTY
26647: LIST
26648: LIST
26649: LIST
26650: IN
26651: IFFALSE 26668
// bpoints := bpoints * 1.2 ;
26653: LD_ADDR_VAR 0 10
26657: PUSH
26658: LD_VAR 0 10
26662: PUSH
26663: LD_REAL  1.20000000000000E+0000
26666: MUL
26667: ST_TO_ADDR
// end ; unit_building :
26668: GO 26682
26670: LD_INT 3
26672: DOUBLE
26673: EQUAL
26674: IFTRUE 26678
26676: GO 26681
26678: POP
// ; end ;
26679: GO 26682
26681: POP
// for j = 1 to 3 do
26682: LD_ADDR_VAR 0 7
26686: PUSH
26687: DOUBLE
26688: LD_INT 1
26690: DEC
26691: ST_TO_ADDR
26692: LD_INT 3
26694: PUSH
26695: FOR_TO
26696: IFFALSE 26749
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
26698: LD_ADDR_VAR 0 5
26702: PUSH
26703: LD_VAR 0 5
26707: PPUSH
26708: LD_VAR 0 7
26712: PPUSH
26713: LD_VAR 0 5
26717: PUSH
26718: LD_VAR 0 7
26722: ARRAY
26723: PUSH
26724: LD_VAR 0 9
26728: PUSH
26729: LD_VAR 0 7
26733: ARRAY
26734: PUSH
26735: LD_VAR 0 10
26739: MUL
26740: PLUS
26741: PPUSH
26742: CALL_OW 1
26746: ST_TO_ADDR
26747: GO 26695
26749: POP
26750: POP
// end ;
26751: GO 25230
26753: POP
26754: POP
// result := Replace ( result , 4 , tmp ) ;
26755: LD_ADDR_VAR 0 5
26759: PUSH
26760: LD_VAR 0 5
26764: PPUSH
26765: LD_INT 4
26767: PPUSH
26768: LD_VAR 0 8
26772: PPUSH
26773: CALL_OW 1
26777: ST_TO_ADDR
// end ;
26778: LD_VAR 0 5
26782: RET
// export function DangerAtRange ( unit , range ) ; begin
26783: LD_INT 0
26785: PPUSH
// if not unit then
26786: LD_VAR 0 1
26790: NOT
26791: IFFALSE 26795
// exit ;
26793: GO 26840
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
26795: LD_ADDR_VAR 0 3
26799: PUSH
26800: LD_VAR 0 1
26804: PPUSH
26805: CALL_OW 255
26809: PPUSH
26810: LD_VAR 0 1
26814: PPUSH
26815: CALL_OW 250
26819: PPUSH
26820: LD_VAR 0 1
26824: PPUSH
26825: CALL_OW 251
26829: PPUSH
26830: LD_VAR 0 2
26834: PPUSH
26835: CALL 25082 0 4
26839: ST_TO_ADDR
// end ;
26840: LD_VAR 0 3
26844: RET
// export function DangerInArea ( side , area ) ; begin
26845: LD_INT 0
26847: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
26848: LD_ADDR_VAR 0 3
26852: PUSH
26853: LD_VAR 0 2
26857: PPUSH
26858: LD_INT 81
26860: PUSH
26861: LD_VAR 0 1
26865: PUSH
26866: EMPTY
26867: LIST
26868: LIST
26869: PPUSH
26870: CALL_OW 70
26874: ST_TO_ADDR
// end ;
26875: LD_VAR 0 3
26879: RET
// export function IsExtension ( b ) ; begin
26880: LD_INT 0
26882: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
26883: LD_ADDR_VAR 0 2
26887: PUSH
26888: LD_VAR 0 1
26892: PUSH
26893: LD_INT 23
26895: PUSH
26896: LD_INT 20
26898: PUSH
26899: LD_INT 22
26901: PUSH
26902: LD_INT 17
26904: PUSH
26905: LD_INT 24
26907: PUSH
26908: LD_INT 21
26910: PUSH
26911: LD_INT 19
26913: PUSH
26914: LD_INT 16
26916: PUSH
26917: LD_INT 25
26919: PUSH
26920: LD_INT 18
26922: PUSH
26923: EMPTY
26924: LIST
26925: LIST
26926: LIST
26927: LIST
26928: LIST
26929: LIST
26930: LIST
26931: LIST
26932: LIST
26933: LIST
26934: IN
26935: ST_TO_ADDR
// end ;
26936: LD_VAR 0 2
26940: RET
// export function GetBaseBuildings ( base , area , checkLink ) ; var tmp , i ; begin
26941: LD_INT 0
26943: PPUSH
26944: PPUSH
26945: PPUSH
// result := [ ] ;
26946: LD_ADDR_VAR 0 4
26950: PUSH
26951: EMPTY
26952: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
26953: LD_ADDR_VAR 0 5
26957: PUSH
26958: LD_VAR 0 2
26962: PPUSH
26963: LD_INT 21
26965: PUSH
26966: LD_INT 3
26968: PUSH
26969: EMPTY
26970: LIST
26971: LIST
26972: PPUSH
26973: CALL_OW 70
26977: ST_TO_ADDR
// if not tmp then
26978: LD_VAR 0 5
26982: NOT
26983: IFFALSE 26987
// exit ;
26985: GO 27051
// if checkLink then
26987: LD_VAR 0 3
26991: IFFALSE 27041
// begin for i in tmp do
26993: LD_ADDR_VAR 0 6
26997: PUSH
26998: LD_VAR 0 5
27002: PUSH
27003: FOR_IN
27004: IFFALSE 27039
// if GetBase ( i ) <> base then
27006: LD_VAR 0 6
27010: PPUSH
27011: CALL_OW 274
27015: PUSH
27016: LD_VAR 0 1
27020: NONEQUAL
27021: IFFALSE 27037
// ComLinkToBase ( base , i ) ;
27023: LD_VAR 0 1
27027: PPUSH
27028: LD_VAR 0 6
27032: PPUSH
27033: CALL_OW 169
27037: GO 27003
27039: POP
27040: POP
// end ; result := tmp ;
27041: LD_ADDR_VAR 0 4
27045: PUSH
27046: LD_VAR 0 5
27050: ST_TO_ADDR
// end ;
27051: LD_VAR 0 4
27055: RET
// export function ComComplete ( units , b ) ; var i ; begin
27056: LD_INT 0
27058: PPUSH
27059: PPUSH
// if not units then
27060: LD_VAR 0 1
27064: NOT
27065: IFFALSE 27069
// exit ;
27067: GO 27159
// for i in units do
27069: LD_ADDR_VAR 0 4
27073: PUSH
27074: LD_VAR 0 1
27078: PUSH
27079: FOR_IN
27080: IFFALSE 27157
// if BuildingStatus ( b ) = bs_build then
27082: LD_VAR 0 2
27086: PPUSH
27087: CALL_OW 461
27091: PUSH
27092: LD_INT 1
27094: EQUAL
27095: IFFALSE 27155
// SetTaskList ( i , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
27097: LD_VAR 0 4
27101: PPUSH
27102: LD_STRING h
27104: PUSH
27105: LD_VAR 0 2
27109: PPUSH
27110: CALL_OW 250
27114: PUSH
27115: LD_VAR 0 2
27119: PPUSH
27120: CALL_OW 251
27124: PUSH
27125: LD_VAR 0 2
27129: PUSH
27130: LD_INT 0
27132: PUSH
27133: LD_INT 0
27135: PUSH
27136: LD_INT 0
27138: PUSH
27139: EMPTY
27140: LIST
27141: LIST
27142: LIST
27143: LIST
27144: LIST
27145: LIST
27146: LIST
27147: PUSH
27148: EMPTY
27149: LIST
27150: PPUSH
27151: CALL_OW 446
27155: GO 27079
27157: POP
27158: POP
// end ;
27159: LD_VAR 0 3
27163: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
27164: LD_INT 0
27166: PPUSH
27167: PPUSH
27168: PPUSH
27169: PPUSH
27170: PPUSH
27171: PPUSH
// if not vehicle or GetControl ( vehicle ) <> control_remote then
27172: LD_VAR 0 1
27176: NOT
27177: PUSH
27178: LD_VAR 0 1
27182: PPUSH
27183: CALL_OW 263
27187: PUSH
27188: LD_INT 2
27190: NONEQUAL
27191: OR
27192: IFFALSE 27196
// exit ;
27194: GO 27512
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
27196: LD_ADDR_VAR 0 6
27200: PUSH
27201: LD_INT 22
27203: PUSH
27204: LD_VAR 0 1
27208: PPUSH
27209: CALL_OW 255
27213: PUSH
27214: EMPTY
27215: LIST
27216: LIST
27217: PUSH
27218: LD_INT 2
27220: PUSH
27221: LD_INT 30
27223: PUSH
27224: LD_INT 36
27226: PUSH
27227: EMPTY
27228: LIST
27229: LIST
27230: PUSH
27231: LD_INT 34
27233: PUSH
27234: LD_INT 31
27236: PUSH
27237: EMPTY
27238: LIST
27239: LIST
27240: PUSH
27241: EMPTY
27242: LIST
27243: LIST
27244: LIST
27245: PUSH
27246: EMPTY
27247: LIST
27248: LIST
27249: PPUSH
27250: CALL_OW 69
27254: ST_TO_ADDR
// if not tmp then
27255: LD_VAR 0 6
27259: NOT
27260: IFFALSE 27264
// exit ;
27262: GO 27512
// result := [ ] ;
27264: LD_ADDR_VAR 0 2
27268: PUSH
27269: EMPTY
27270: ST_TO_ADDR
// for i in tmp do
27271: LD_ADDR_VAR 0 3
27275: PUSH
27276: LD_VAR 0 6
27280: PUSH
27281: FOR_IN
27282: IFFALSE 27353
// begin t := UnitsInside ( i ) ;
27284: LD_ADDR_VAR 0 4
27288: PUSH
27289: LD_VAR 0 3
27293: PPUSH
27294: CALL_OW 313
27298: ST_TO_ADDR
// if t then
27299: LD_VAR 0 4
27303: IFFALSE 27351
// for j in t do
27305: LD_ADDR_VAR 0 7
27309: PUSH
27310: LD_VAR 0 4
27314: PUSH
27315: FOR_IN
27316: IFFALSE 27349
// result := Replace ( result , result + 1 , j ) ;
27318: LD_ADDR_VAR 0 2
27322: PUSH
27323: LD_VAR 0 2
27327: PPUSH
27328: LD_VAR 0 2
27332: PUSH
27333: LD_INT 1
27335: PLUS
27336: PPUSH
27337: LD_VAR 0 7
27341: PPUSH
27342: CALL_OW 1
27346: ST_TO_ADDR
27347: GO 27315
27349: POP
27350: POP
// end ;
27351: GO 27281
27353: POP
27354: POP
// if not result then
27355: LD_VAR 0 2
27359: NOT
27360: IFFALSE 27364
// exit ;
27362: GO 27512
// mech := result [ 1 ] ;
27364: LD_ADDR_VAR 0 5
27368: PUSH
27369: LD_VAR 0 2
27373: PUSH
27374: LD_INT 1
27376: ARRAY
27377: ST_TO_ADDR
// if result > 1 then
27378: LD_VAR 0 2
27382: PUSH
27383: LD_INT 1
27385: GREATER
27386: IFFALSE 27498
// begin for i = 2 to result do
27388: LD_ADDR_VAR 0 3
27392: PUSH
27393: DOUBLE
27394: LD_INT 2
27396: DEC
27397: ST_TO_ADDR
27398: LD_VAR 0 2
27402: PUSH
27403: FOR_TO
27404: IFFALSE 27496
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
27406: LD_ADDR_VAR 0 4
27410: PUSH
27411: LD_VAR 0 2
27415: PUSH
27416: LD_VAR 0 3
27420: ARRAY
27421: PPUSH
27422: LD_INT 3
27424: PPUSH
27425: CALL_OW 259
27429: PUSH
27430: LD_VAR 0 2
27434: PUSH
27435: LD_VAR 0 3
27439: ARRAY
27440: PPUSH
27441: CALL_OW 432
27445: MINUS
27446: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
27447: LD_VAR 0 4
27451: PUSH
27452: LD_VAR 0 5
27456: PPUSH
27457: LD_INT 3
27459: PPUSH
27460: CALL_OW 259
27464: PUSH
27465: LD_VAR 0 5
27469: PPUSH
27470: CALL_OW 432
27474: MINUS
27475: GREATEREQUAL
27476: IFFALSE 27494
// mech := result [ i ] ;
27478: LD_ADDR_VAR 0 5
27482: PUSH
27483: LD_VAR 0 2
27487: PUSH
27488: LD_VAR 0 3
27492: ARRAY
27493: ST_TO_ADDR
// end ;
27494: GO 27403
27496: POP
27497: POP
// end ; ComLinkTo ( vehicle , mech ) ;
27498: LD_VAR 0 1
27502: PPUSH
27503: LD_VAR 0 5
27507: PPUSH
27508: CALL_OW 135
// end ;
27512: LD_VAR 0 2
27516: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
27517: LD_INT 0
27519: PPUSH
27520: PPUSH
27521: PPUSH
27522: PPUSH
27523: PPUSH
27524: PPUSH
27525: PPUSH
27526: PPUSH
27527: PPUSH
27528: PPUSH
27529: PPUSH
27530: PPUSH
27531: PPUSH
// result := [ ] ;
27532: LD_ADDR_VAR 0 7
27536: PUSH
27537: EMPTY
27538: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
27539: LD_VAR 0 1
27543: PPUSH
27544: CALL_OW 266
27548: PUSH
27549: LD_INT 0
27551: PUSH
27552: LD_INT 1
27554: PUSH
27555: EMPTY
27556: LIST
27557: LIST
27558: IN
27559: NOT
27560: IFFALSE 27564
// exit ;
27562: GO 29198
// if name then
27564: LD_VAR 0 3
27568: IFFALSE 27584
// SetBName ( base_dep , name ) ;
27570: LD_VAR 0 1
27574: PPUSH
27575: LD_VAR 0 3
27579: PPUSH
27580: CALL_OW 500
// base := GetBase ( base_dep ) ;
27584: LD_ADDR_VAR 0 15
27588: PUSH
27589: LD_VAR 0 1
27593: PPUSH
27594: CALL_OW 274
27598: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
27599: LD_ADDR_VAR 0 16
27603: PUSH
27604: LD_VAR 0 1
27608: PPUSH
27609: CALL_OW 255
27613: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
27614: LD_ADDR_VAR 0 17
27618: PUSH
27619: LD_VAR 0 1
27623: PPUSH
27624: CALL_OW 248
27628: ST_TO_ADDR
// if sources then
27629: LD_VAR 0 5
27633: IFFALSE 27680
// for i = 1 to 3 do
27635: LD_ADDR_VAR 0 8
27639: PUSH
27640: DOUBLE
27641: LD_INT 1
27643: DEC
27644: ST_TO_ADDR
27645: LD_INT 3
27647: PUSH
27648: FOR_TO
27649: IFFALSE 27678
// AddResourceType ( base , i , sources [ i ] ) ;
27651: LD_VAR 0 15
27655: PPUSH
27656: LD_VAR 0 8
27660: PPUSH
27661: LD_VAR 0 5
27665: PUSH
27666: LD_VAR 0 8
27670: ARRAY
27671: PPUSH
27672: CALL_OW 276
27676: GO 27648
27678: POP
27679: POP
// buildings := GetBaseBuildings ( base , area , true ) ;
27680: LD_ADDR_VAR 0 18
27684: PUSH
27685: LD_VAR 0 15
27689: PPUSH
27690: LD_VAR 0 2
27694: PPUSH
27695: LD_INT 1
27697: PPUSH
27698: CALL 26941 0 3
27702: ST_TO_ADDR
// InitHc ;
27703: CALL_OW 19
// InitUc ;
27707: CALL_OW 18
// uc_side := side ;
27711: LD_ADDR_OWVAR 20
27715: PUSH
27716: LD_VAR 0 16
27720: ST_TO_ADDR
// uc_nation := nation ;
27721: LD_ADDR_OWVAR 21
27725: PUSH
27726: LD_VAR 0 17
27730: ST_TO_ADDR
// if buildings then
27731: LD_VAR 0 18
27735: IFFALSE 29057
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
27737: LD_ADDR_VAR 0 19
27741: PUSH
27742: LD_VAR 0 18
27746: PPUSH
27747: LD_INT 2
27749: PUSH
27750: LD_INT 30
27752: PUSH
27753: LD_INT 29
27755: PUSH
27756: EMPTY
27757: LIST
27758: LIST
27759: PUSH
27760: LD_INT 30
27762: PUSH
27763: LD_INT 30
27765: PUSH
27766: EMPTY
27767: LIST
27768: LIST
27769: PUSH
27770: EMPTY
27771: LIST
27772: LIST
27773: LIST
27774: PPUSH
27775: CALL_OW 72
27779: ST_TO_ADDR
// if tmp then
27780: LD_VAR 0 19
27784: IFFALSE 27832
// for i in tmp do
27786: LD_ADDR_VAR 0 8
27790: PUSH
27791: LD_VAR 0 19
27795: PUSH
27796: FOR_IN
27797: IFFALSE 27830
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
27799: LD_VAR 0 8
27803: PPUSH
27804: CALL_OW 250
27808: PPUSH
27809: LD_VAR 0 8
27813: PPUSH
27814: CALL_OW 251
27818: PPUSH
27819: LD_VAR 0 16
27823: PPUSH
27824: CALL_OW 441
27828: GO 27796
27830: POP
27831: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
27832: LD_VAR 0 18
27836: PPUSH
27837: LD_INT 2
27839: PUSH
27840: LD_INT 30
27842: PUSH
27843: LD_INT 32
27845: PUSH
27846: EMPTY
27847: LIST
27848: LIST
27849: PUSH
27850: LD_INT 30
27852: PUSH
27853: LD_INT 33
27855: PUSH
27856: EMPTY
27857: LIST
27858: LIST
27859: PUSH
27860: EMPTY
27861: LIST
27862: LIST
27863: LIST
27864: PPUSH
27865: CALL_OW 72
27869: IFFALSE 27957
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
27871: LD_ADDR_VAR 0 8
27875: PUSH
27876: LD_VAR 0 18
27880: PPUSH
27881: LD_INT 2
27883: PUSH
27884: LD_INT 30
27886: PUSH
27887: LD_INT 32
27889: PUSH
27890: EMPTY
27891: LIST
27892: LIST
27893: PUSH
27894: LD_INT 30
27896: PUSH
27897: LD_INT 33
27899: PUSH
27900: EMPTY
27901: LIST
27902: LIST
27903: PUSH
27904: EMPTY
27905: LIST
27906: LIST
27907: LIST
27908: PPUSH
27909: CALL_OW 72
27913: PUSH
27914: FOR_IN
27915: IFFALSE 27955
// begin if not GetBWeapon ( i ) then
27917: LD_VAR 0 8
27921: PPUSH
27922: CALL_OW 269
27926: NOT
27927: IFFALSE 27953
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
27929: LD_VAR 0 8
27933: PPUSH
27934: LD_VAR 0 8
27938: PPUSH
27939: LD_VAR 0 2
27943: PPUSH
27944: CALL 29203 0 2
27948: PPUSH
27949: CALL_OW 431
// end ;
27953: GO 27914
27955: POP
27956: POP
// end ; for i = 1 to personel do
27957: LD_ADDR_VAR 0 8
27961: PUSH
27962: DOUBLE
27963: LD_INT 1
27965: DEC
27966: ST_TO_ADDR
27967: LD_VAR 0 6
27971: PUSH
27972: FOR_TO
27973: IFFALSE 29037
// begin if i > 4 then
27975: LD_VAR 0 8
27979: PUSH
27980: LD_INT 4
27982: GREATER
27983: IFFALSE 27987
// break ;
27985: GO 29037
// case i of 1 :
27987: LD_VAR 0 8
27991: PUSH
27992: LD_INT 1
27994: DOUBLE
27995: EQUAL
27996: IFTRUE 28000
27998: GO 28080
28000: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
28001: LD_ADDR_VAR 0 12
28005: PUSH
28006: LD_VAR 0 18
28010: PPUSH
28011: LD_INT 22
28013: PUSH
28014: LD_VAR 0 16
28018: PUSH
28019: EMPTY
28020: LIST
28021: LIST
28022: PUSH
28023: LD_INT 58
28025: PUSH
28026: EMPTY
28027: LIST
28028: PUSH
28029: LD_INT 2
28031: PUSH
28032: LD_INT 30
28034: PUSH
28035: LD_INT 32
28037: PUSH
28038: EMPTY
28039: LIST
28040: LIST
28041: PUSH
28042: LD_INT 30
28044: PUSH
28045: LD_INT 4
28047: PUSH
28048: EMPTY
28049: LIST
28050: LIST
28051: PUSH
28052: LD_INT 30
28054: PUSH
28055: LD_INT 5
28057: PUSH
28058: EMPTY
28059: LIST
28060: LIST
28061: PUSH
28062: EMPTY
28063: LIST
28064: LIST
28065: LIST
28066: LIST
28067: PUSH
28068: EMPTY
28069: LIST
28070: LIST
28071: LIST
28072: PPUSH
28073: CALL_OW 72
28077: ST_TO_ADDR
28078: GO 28302
28080: LD_INT 2
28082: DOUBLE
28083: EQUAL
28084: IFTRUE 28088
28086: GO 28150
28088: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
28089: LD_ADDR_VAR 0 12
28093: PUSH
28094: LD_VAR 0 18
28098: PPUSH
28099: LD_INT 22
28101: PUSH
28102: LD_VAR 0 16
28106: PUSH
28107: EMPTY
28108: LIST
28109: LIST
28110: PUSH
28111: LD_INT 2
28113: PUSH
28114: LD_INT 30
28116: PUSH
28117: LD_INT 0
28119: PUSH
28120: EMPTY
28121: LIST
28122: LIST
28123: PUSH
28124: LD_INT 30
28126: PUSH
28127: LD_INT 1
28129: PUSH
28130: EMPTY
28131: LIST
28132: LIST
28133: PUSH
28134: EMPTY
28135: LIST
28136: LIST
28137: LIST
28138: PUSH
28139: EMPTY
28140: LIST
28141: LIST
28142: PPUSH
28143: CALL_OW 72
28147: ST_TO_ADDR
28148: GO 28302
28150: LD_INT 3
28152: DOUBLE
28153: EQUAL
28154: IFTRUE 28158
28156: GO 28220
28158: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
28159: LD_ADDR_VAR 0 12
28163: PUSH
28164: LD_VAR 0 18
28168: PPUSH
28169: LD_INT 22
28171: PUSH
28172: LD_VAR 0 16
28176: PUSH
28177: EMPTY
28178: LIST
28179: LIST
28180: PUSH
28181: LD_INT 2
28183: PUSH
28184: LD_INT 30
28186: PUSH
28187: LD_INT 2
28189: PUSH
28190: EMPTY
28191: LIST
28192: LIST
28193: PUSH
28194: LD_INT 30
28196: PUSH
28197: LD_INT 3
28199: PUSH
28200: EMPTY
28201: LIST
28202: LIST
28203: PUSH
28204: EMPTY
28205: LIST
28206: LIST
28207: LIST
28208: PUSH
28209: EMPTY
28210: LIST
28211: LIST
28212: PPUSH
28213: CALL_OW 72
28217: ST_TO_ADDR
28218: GO 28302
28220: LD_INT 4
28222: DOUBLE
28223: EQUAL
28224: IFTRUE 28228
28226: GO 28301
28228: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
28229: LD_ADDR_VAR 0 12
28233: PUSH
28234: LD_VAR 0 18
28238: PPUSH
28239: LD_INT 22
28241: PUSH
28242: LD_VAR 0 16
28246: PUSH
28247: EMPTY
28248: LIST
28249: LIST
28250: PUSH
28251: LD_INT 2
28253: PUSH
28254: LD_INT 30
28256: PUSH
28257: LD_INT 6
28259: PUSH
28260: EMPTY
28261: LIST
28262: LIST
28263: PUSH
28264: LD_INT 30
28266: PUSH
28267: LD_INT 7
28269: PUSH
28270: EMPTY
28271: LIST
28272: LIST
28273: PUSH
28274: LD_INT 30
28276: PUSH
28277: LD_INT 8
28279: PUSH
28280: EMPTY
28281: LIST
28282: LIST
28283: PUSH
28284: EMPTY
28285: LIST
28286: LIST
28287: LIST
28288: LIST
28289: PUSH
28290: EMPTY
28291: LIST
28292: LIST
28293: PPUSH
28294: CALL_OW 72
28298: ST_TO_ADDR
28299: GO 28302
28301: POP
// if i = 1 then
28302: LD_VAR 0 8
28306: PUSH
28307: LD_INT 1
28309: EQUAL
28310: IFFALSE 28421
// begin tmp := [ ] ;
28312: LD_ADDR_VAR 0 19
28316: PUSH
28317: EMPTY
28318: ST_TO_ADDR
// for j in f do
28319: LD_ADDR_VAR 0 9
28323: PUSH
28324: LD_VAR 0 12
28328: PUSH
28329: FOR_IN
28330: IFFALSE 28403
// if GetBType ( j ) = b_bunker then
28332: LD_VAR 0 9
28336: PPUSH
28337: CALL_OW 266
28341: PUSH
28342: LD_INT 32
28344: EQUAL
28345: IFFALSE 28372
// tmp := Insert ( tmp , 1 , j ) else
28347: LD_ADDR_VAR 0 19
28351: PUSH
28352: LD_VAR 0 19
28356: PPUSH
28357: LD_INT 1
28359: PPUSH
28360: LD_VAR 0 9
28364: PPUSH
28365: CALL_OW 2
28369: ST_TO_ADDR
28370: GO 28401
// tmp := Insert ( tmp , tmp + 1 , j ) ;
28372: LD_ADDR_VAR 0 19
28376: PUSH
28377: LD_VAR 0 19
28381: PPUSH
28382: LD_VAR 0 19
28386: PUSH
28387: LD_INT 1
28389: PLUS
28390: PPUSH
28391: LD_VAR 0 9
28395: PPUSH
28396: CALL_OW 2
28400: ST_TO_ADDR
28401: GO 28329
28403: POP
28404: POP
// if tmp then
28405: LD_VAR 0 19
28409: IFFALSE 28421
// f := tmp ;
28411: LD_ADDR_VAR 0 12
28415: PUSH
28416: LD_VAR 0 19
28420: ST_TO_ADDR
// end ; x := personel [ i ] ;
28421: LD_ADDR_VAR 0 13
28425: PUSH
28426: LD_VAR 0 6
28430: PUSH
28431: LD_VAR 0 8
28435: ARRAY
28436: ST_TO_ADDR
// if x = - 1 then
28437: LD_VAR 0 13
28441: PUSH
28442: LD_INT 1
28444: NEG
28445: EQUAL
28446: IFFALSE 28655
// begin for j in f do
28448: LD_ADDR_VAR 0 9
28452: PUSH
28453: LD_VAR 0 12
28457: PUSH
28458: FOR_IN
28459: IFFALSE 28651
// repeat InitHc ;
28461: CALL_OW 19
// if GetBType ( j ) = b_barracks then
28465: LD_VAR 0 9
28469: PPUSH
28470: CALL_OW 266
28474: PUSH
28475: LD_INT 5
28477: EQUAL
28478: IFFALSE 28548
// begin if UnitsInside ( j ) < 3 then
28480: LD_VAR 0 9
28484: PPUSH
28485: CALL_OW 313
28489: PUSH
28490: LD_INT 3
28492: LESS
28493: IFFALSE 28529
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
28495: LD_INT 0
28497: PPUSH
28498: LD_INT 5
28500: PUSH
28501: LD_INT 8
28503: PUSH
28504: LD_INT 9
28506: PUSH
28507: EMPTY
28508: LIST
28509: LIST
28510: LIST
28511: PUSH
28512: LD_VAR 0 17
28516: ARRAY
28517: PPUSH
28518: LD_VAR 0 4
28522: PPUSH
28523: CALL_OW 380
28527: GO 28546
// PrepareHuman ( false , i , skill ) ;
28529: LD_INT 0
28531: PPUSH
28532: LD_VAR 0 8
28536: PPUSH
28537: LD_VAR 0 4
28541: PPUSH
28542: CALL_OW 380
// end else
28546: GO 28565
// PrepareHuman ( false , i , skill ) ;
28548: LD_INT 0
28550: PPUSH
28551: LD_VAR 0 8
28555: PPUSH
28556: LD_VAR 0 4
28560: PPUSH
28561: CALL_OW 380
// un := CreateHuman ;
28565: LD_ADDR_VAR 0 14
28569: PUSH
28570: CALL_OW 44
28574: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
28575: LD_ADDR_VAR 0 7
28579: PUSH
28580: LD_VAR 0 7
28584: PPUSH
28585: LD_INT 1
28587: PPUSH
28588: LD_VAR 0 14
28592: PPUSH
28593: CALL_OW 2
28597: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
28598: LD_VAR 0 14
28602: PPUSH
28603: LD_VAR 0 9
28607: PPUSH
28608: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
28612: LD_VAR 0 9
28616: PPUSH
28617: CALL_OW 313
28621: PUSH
28622: LD_INT 6
28624: EQUAL
28625: PUSH
28626: LD_VAR 0 9
28630: PPUSH
28631: CALL_OW 266
28635: PUSH
28636: LD_INT 32
28638: PUSH
28639: LD_INT 31
28641: PUSH
28642: EMPTY
28643: LIST
28644: LIST
28645: IN
28646: OR
28647: IFFALSE 28461
28649: GO 28458
28651: POP
28652: POP
// end else
28653: GO 29035
// for j = 1 to x do
28655: LD_ADDR_VAR 0 9
28659: PUSH
28660: DOUBLE
28661: LD_INT 1
28663: DEC
28664: ST_TO_ADDR
28665: LD_VAR 0 13
28669: PUSH
28670: FOR_TO
28671: IFFALSE 29033
// begin InitHc ;
28673: CALL_OW 19
// if not f then
28677: LD_VAR 0 12
28681: NOT
28682: IFFALSE 28771
// begin PrepareHuman ( false , i , skill ) ;
28684: LD_INT 0
28686: PPUSH
28687: LD_VAR 0 8
28691: PPUSH
28692: LD_VAR 0 4
28696: PPUSH
28697: CALL_OW 380
// un := CreateHuman ;
28701: LD_ADDR_VAR 0 14
28705: PUSH
28706: CALL_OW 44
28710: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
28711: LD_ADDR_VAR 0 7
28715: PUSH
28716: LD_VAR 0 7
28720: PPUSH
28721: LD_INT 1
28723: PPUSH
28724: LD_VAR 0 14
28728: PPUSH
28729: CALL_OW 2
28733: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
28734: LD_VAR 0 14
28738: PPUSH
28739: LD_VAR 0 1
28743: PPUSH
28744: CALL_OW 250
28748: PPUSH
28749: LD_VAR 0 1
28753: PPUSH
28754: CALL_OW 251
28758: PPUSH
28759: LD_INT 10
28761: PPUSH
28762: LD_INT 0
28764: PPUSH
28765: CALL_OW 50
// continue ;
28769: GO 28670
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
28771: LD_VAR 0 12
28775: PUSH
28776: LD_INT 1
28778: ARRAY
28779: PPUSH
28780: CALL_OW 313
28784: PUSH
28785: LD_VAR 0 12
28789: PUSH
28790: LD_INT 1
28792: ARRAY
28793: PPUSH
28794: CALL_OW 266
28798: PUSH
28799: LD_INT 32
28801: PUSH
28802: LD_INT 31
28804: PUSH
28805: EMPTY
28806: LIST
28807: LIST
28808: IN
28809: AND
28810: PUSH
28811: LD_VAR 0 12
28815: PUSH
28816: LD_INT 1
28818: ARRAY
28819: PPUSH
28820: CALL_OW 313
28824: PUSH
28825: LD_INT 6
28827: EQUAL
28828: OR
28829: IFFALSE 28849
// f := Delete ( f , 1 ) ;
28831: LD_ADDR_VAR 0 12
28835: PUSH
28836: LD_VAR 0 12
28840: PPUSH
28841: LD_INT 1
28843: PPUSH
28844: CALL_OW 3
28848: ST_TO_ADDR
// if not f then
28849: LD_VAR 0 12
28853: NOT
28854: IFFALSE 28872
// begin x := x + 2 ;
28856: LD_ADDR_VAR 0 13
28860: PUSH
28861: LD_VAR 0 13
28865: PUSH
28866: LD_INT 2
28868: PLUS
28869: ST_TO_ADDR
// continue ;
28870: GO 28670
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
28872: LD_VAR 0 12
28876: PUSH
28877: LD_INT 1
28879: ARRAY
28880: PPUSH
28881: CALL_OW 266
28885: PUSH
28886: LD_INT 5
28888: EQUAL
28889: IFFALSE 28963
// begin if UnitsInside ( f [ 1 ] ) < 3 then
28891: LD_VAR 0 12
28895: PUSH
28896: LD_INT 1
28898: ARRAY
28899: PPUSH
28900: CALL_OW 313
28904: PUSH
28905: LD_INT 3
28907: LESS
28908: IFFALSE 28944
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
28910: LD_INT 0
28912: PPUSH
28913: LD_INT 5
28915: PUSH
28916: LD_INT 8
28918: PUSH
28919: LD_INT 9
28921: PUSH
28922: EMPTY
28923: LIST
28924: LIST
28925: LIST
28926: PUSH
28927: LD_VAR 0 17
28931: ARRAY
28932: PPUSH
28933: LD_VAR 0 4
28937: PPUSH
28938: CALL_OW 380
28942: GO 28961
// PrepareHuman ( false , i , skill ) ;
28944: LD_INT 0
28946: PPUSH
28947: LD_VAR 0 8
28951: PPUSH
28952: LD_VAR 0 4
28956: PPUSH
28957: CALL_OW 380
// end else
28961: GO 28980
// PrepareHuman ( false , i , skill ) ;
28963: LD_INT 0
28965: PPUSH
28966: LD_VAR 0 8
28970: PPUSH
28971: LD_VAR 0 4
28975: PPUSH
28976: CALL_OW 380
// un := CreateHuman ;
28980: LD_ADDR_VAR 0 14
28984: PUSH
28985: CALL_OW 44
28989: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
28990: LD_ADDR_VAR 0 7
28994: PUSH
28995: LD_VAR 0 7
28999: PPUSH
29000: LD_INT 1
29002: PPUSH
29003: LD_VAR 0 14
29007: PPUSH
29008: CALL_OW 2
29012: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
29013: LD_VAR 0 14
29017: PPUSH
29018: LD_VAR 0 12
29022: PUSH
29023: LD_INT 1
29025: ARRAY
29026: PPUSH
29027: CALL_OW 52
// end ;
29031: GO 28670
29033: POP
29034: POP
// end ;
29035: GO 27972
29037: POP
29038: POP
// result := result ^ buildings ;
29039: LD_ADDR_VAR 0 7
29043: PUSH
29044: LD_VAR 0 7
29048: PUSH
29049: LD_VAR 0 18
29053: ADD
29054: ST_TO_ADDR
// end else
29055: GO 29198
// begin for i = 1 to personel do
29057: LD_ADDR_VAR 0 8
29061: PUSH
29062: DOUBLE
29063: LD_INT 1
29065: DEC
29066: ST_TO_ADDR
29067: LD_VAR 0 6
29071: PUSH
29072: FOR_TO
29073: IFFALSE 29196
// begin if i > 4 then
29075: LD_VAR 0 8
29079: PUSH
29080: LD_INT 4
29082: GREATER
29083: IFFALSE 29087
// break ;
29085: GO 29196
// x := personel [ i ] ;
29087: LD_ADDR_VAR 0 13
29091: PUSH
29092: LD_VAR 0 6
29096: PUSH
29097: LD_VAR 0 8
29101: ARRAY
29102: ST_TO_ADDR
// if x = - 1 then
29103: LD_VAR 0 13
29107: PUSH
29108: LD_INT 1
29110: NEG
29111: EQUAL
29112: IFFALSE 29116
// continue ;
29114: GO 29072
// PrepareHuman ( false , i , skill ) ;
29116: LD_INT 0
29118: PPUSH
29119: LD_VAR 0 8
29123: PPUSH
29124: LD_VAR 0 4
29128: PPUSH
29129: CALL_OW 380
// un := CreateHuman ;
29133: LD_ADDR_VAR 0 14
29137: PUSH
29138: CALL_OW 44
29142: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
29143: LD_VAR 0 14
29147: PPUSH
29148: LD_VAR 0 1
29152: PPUSH
29153: CALL_OW 250
29157: PPUSH
29158: LD_VAR 0 1
29162: PPUSH
29163: CALL_OW 251
29167: PPUSH
29168: LD_INT 10
29170: PPUSH
29171: LD_INT 0
29173: PPUSH
29174: CALL_OW 50
// result := result ^ un ;
29178: LD_ADDR_VAR 0 7
29182: PUSH
29183: LD_VAR 0 7
29187: PUSH
29188: LD_VAR 0 14
29192: ADD
29193: ST_TO_ADDR
// end ;
29194: GO 29072
29196: POP
29197: POP
// end ; end ;
29198: LD_VAR 0 7
29202: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
29203: LD_INT 0
29205: PPUSH
29206: PPUSH
29207: PPUSH
29208: PPUSH
29209: PPUSH
29210: PPUSH
29211: PPUSH
29212: PPUSH
29213: PPUSH
29214: PPUSH
29215: PPUSH
29216: PPUSH
29217: PPUSH
29218: PPUSH
29219: PPUSH
29220: PPUSH
// result := false ;
29221: LD_ADDR_VAR 0 3
29225: PUSH
29226: LD_INT 0
29228: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
29229: LD_VAR 0 1
29233: NOT
29234: PUSH
29235: LD_VAR 0 1
29239: PPUSH
29240: CALL_OW 266
29244: PUSH
29245: LD_INT 32
29247: PUSH
29248: LD_INT 33
29250: PUSH
29251: EMPTY
29252: LIST
29253: LIST
29254: IN
29255: NOT
29256: OR
29257: IFFALSE 29261
// exit ;
29259: GO 30370
// nat := GetNation ( tower ) ;
29261: LD_ADDR_VAR 0 12
29265: PUSH
29266: LD_VAR 0 1
29270: PPUSH
29271: CALL_OW 248
29275: ST_TO_ADDR
// side := GetSide ( tower ) ;
29276: LD_ADDR_VAR 0 16
29280: PUSH
29281: LD_VAR 0 1
29285: PPUSH
29286: CALL_OW 255
29290: ST_TO_ADDR
// x := GetX ( tower ) ;
29291: LD_ADDR_VAR 0 10
29295: PUSH
29296: LD_VAR 0 1
29300: PPUSH
29301: CALL_OW 250
29305: ST_TO_ADDR
// y := GetY ( tower ) ;
29306: LD_ADDR_VAR 0 11
29310: PUSH
29311: LD_VAR 0 1
29315: PPUSH
29316: CALL_OW 251
29320: ST_TO_ADDR
// if not x or not y then
29321: LD_VAR 0 10
29325: NOT
29326: PUSH
29327: LD_VAR 0 11
29331: NOT
29332: OR
29333: IFFALSE 29337
// exit ;
29335: GO 30370
// weapon := 0 ;
29337: LD_ADDR_VAR 0 18
29341: PUSH
29342: LD_INT 0
29344: ST_TO_ADDR
// fac_list := [ ] ;
29345: LD_ADDR_VAR 0 17
29349: PUSH
29350: EMPTY
29351: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area , false ) , [ f_btype , b_factory ] ) ;
29352: LD_ADDR_VAR 0 6
29356: PUSH
29357: LD_VAR 0 1
29361: PPUSH
29362: CALL_OW 274
29366: PPUSH
29367: LD_VAR 0 2
29371: PPUSH
29372: LD_INT 0
29374: PPUSH
29375: CALL 26941 0 3
29379: PPUSH
29380: LD_INT 30
29382: PUSH
29383: LD_INT 3
29385: PUSH
29386: EMPTY
29387: LIST
29388: LIST
29389: PPUSH
29390: CALL_OW 72
29394: ST_TO_ADDR
// if not factories then
29395: LD_VAR 0 6
29399: NOT
29400: IFFALSE 29404
// exit ;
29402: GO 30370
// for i in factories do
29404: LD_ADDR_VAR 0 8
29408: PUSH
29409: LD_VAR 0 6
29413: PUSH
29414: FOR_IN
29415: IFFALSE 29440
// fac_list := fac_list union AvailableWeaponList ( i ) ;
29417: LD_ADDR_VAR 0 17
29421: PUSH
29422: LD_VAR 0 17
29426: PUSH
29427: LD_VAR 0 8
29431: PPUSH
29432: CALL_OW 478
29436: UNION
29437: ST_TO_ADDR
29438: GO 29414
29440: POP
29441: POP
// if not fac_list then
29442: LD_VAR 0 17
29446: NOT
29447: IFFALSE 29451
// exit ;
29449: GO 30370
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
29451: LD_ADDR_VAR 0 5
29455: PUSH
29456: LD_INT 4
29458: PUSH
29459: LD_INT 5
29461: PUSH
29462: LD_INT 9
29464: PUSH
29465: LD_INT 10
29467: PUSH
29468: LD_INT 6
29470: PUSH
29471: LD_INT 7
29473: PUSH
29474: LD_INT 11
29476: PUSH
29477: EMPTY
29478: LIST
29479: LIST
29480: LIST
29481: LIST
29482: LIST
29483: LIST
29484: LIST
29485: PUSH
29486: LD_INT 27
29488: PUSH
29489: LD_INT 28
29491: PUSH
29492: LD_INT 26
29494: PUSH
29495: LD_INT 30
29497: PUSH
29498: EMPTY
29499: LIST
29500: LIST
29501: LIST
29502: LIST
29503: PUSH
29504: LD_INT 43
29506: PUSH
29507: LD_INT 44
29509: PUSH
29510: LD_INT 46
29512: PUSH
29513: LD_INT 45
29515: PUSH
29516: LD_INT 47
29518: PUSH
29519: LD_INT 49
29521: PUSH
29522: EMPTY
29523: LIST
29524: LIST
29525: LIST
29526: LIST
29527: LIST
29528: LIST
29529: PUSH
29530: EMPTY
29531: LIST
29532: LIST
29533: LIST
29534: PUSH
29535: LD_VAR 0 12
29539: ARRAY
29540: ST_TO_ADDR
// list := list isect fac_list ;
29541: LD_ADDR_VAR 0 5
29545: PUSH
29546: LD_VAR 0 5
29550: PUSH
29551: LD_VAR 0 17
29555: ISECT
29556: ST_TO_ADDR
// if not list then
29557: LD_VAR 0 5
29561: NOT
29562: IFFALSE 29566
// exit ;
29564: GO 30370
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
29566: LD_VAR 0 12
29570: PUSH
29571: LD_INT 3
29573: EQUAL
29574: PUSH
29575: LD_INT 49
29577: PUSH
29578: LD_VAR 0 5
29582: IN
29583: AND
29584: PUSH
29585: LD_INT 31
29587: PPUSH
29588: LD_VAR 0 16
29592: PPUSH
29593: CALL_OW 321
29597: PUSH
29598: LD_INT 2
29600: EQUAL
29601: AND
29602: IFFALSE 29662
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
29604: LD_INT 22
29606: PUSH
29607: LD_VAR 0 16
29611: PUSH
29612: EMPTY
29613: LIST
29614: LIST
29615: PUSH
29616: LD_INT 35
29618: PUSH
29619: LD_INT 49
29621: PUSH
29622: EMPTY
29623: LIST
29624: LIST
29625: PUSH
29626: LD_INT 91
29628: PUSH
29629: LD_VAR 0 1
29633: PUSH
29634: LD_INT 10
29636: PUSH
29637: EMPTY
29638: LIST
29639: LIST
29640: LIST
29641: PUSH
29642: EMPTY
29643: LIST
29644: LIST
29645: LIST
29646: PPUSH
29647: CALL_OW 69
29651: NOT
29652: IFFALSE 29662
// weapon := ru_time_lapser ;
29654: LD_ADDR_VAR 0 18
29658: PUSH
29659: LD_INT 49
29661: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
29662: LD_VAR 0 12
29666: PUSH
29667: LD_INT 1
29669: PUSH
29670: LD_INT 2
29672: PUSH
29673: EMPTY
29674: LIST
29675: LIST
29676: IN
29677: PUSH
29678: LD_INT 11
29680: PUSH
29681: LD_VAR 0 5
29685: IN
29686: PUSH
29687: LD_INT 30
29689: PUSH
29690: LD_VAR 0 5
29694: IN
29695: OR
29696: AND
29697: PUSH
29698: LD_INT 6
29700: PPUSH
29701: LD_VAR 0 16
29705: PPUSH
29706: CALL_OW 321
29710: PUSH
29711: LD_INT 2
29713: EQUAL
29714: AND
29715: IFFALSE 29880
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
29717: LD_INT 22
29719: PUSH
29720: LD_VAR 0 16
29724: PUSH
29725: EMPTY
29726: LIST
29727: LIST
29728: PUSH
29729: LD_INT 2
29731: PUSH
29732: LD_INT 35
29734: PUSH
29735: LD_INT 11
29737: PUSH
29738: EMPTY
29739: LIST
29740: LIST
29741: PUSH
29742: LD_INT 35
29744: PUSH
29745: LD_INT 30
29747: PUSH
29748: EMPTY
29749: LIST
29750: LIST
29751: PUSH
29752: EMPTY
29753: LIST
29754: LIST
29755: LIST
29756: PUSH
29757: LD_INT 91
29759: PUSH
29760: LD_VAR 0 1
29764: PUSH
29765: LD_INT 18
29767: PUSH
29768: EMPTY
29769: LIST
29770: LIST
29771: LIST
29772: PUSH
29773: EMPTY
29774: LIST
29775: LIST
29776: LIST
29777: PPUSH
29778: CALL_OW 69
29782: NOT
29783: PUSH
29784: LD_INT 22
29786: PUSH
29787: LD_VAR 0 16
29791: PUSH
29792: EMPTY
29793: LIST
29794: LIST
29795: PUSH
29796: LD_INT 2
29798: PUSH
29799: LD_INT 30
29801: PUSH
29802: LD_INT 32
29804: PUSH
29805: EMPTY
29806: LIST
29807: LIST
29808: PUSH
29809: LD_INT 30
29811: PUSH
29812: LD_INT 33
29814: PUSH
29815: EMPTY
29816: LIST
29817: LIST
29818: PUSH
29819: EMPTY
29820: LIST
29821: LIST
29822: LIST
29823: PUSH
29824: LD_INT 91
29826: PUSH
29827: LD_VAR 0 1
29831: PUSH
29832: LD_INT 12
29834: PUSH
29835: EMPTY
29836: LIST
29837: LIST
29838: LIST
29839: PUSH
29840: EMPTY
29841: LIST
29842: LIST
29843: LIST
29844: PUSH
29845: EMPTY
29846: LIST
29847: PPUSH
29848: CALL_OW 69
29852: PUSH
29853: LD_INT 2
29855: GREATER
29856: AND
29857: IFFALSE 29880
// weapon := [ us_radar , ar_radar ] [ nat ] ;
29859: LD_ADDR_VAR 0 18
29863: PUSH
29864: LD_INT 11
29866: PUSH
29867: LD_INT 30
29869: PUSH
29870: EMPTY
29871: LIST
29872: LIST
29873: PUSH
29874: LD_VAR 0 12
29878: ARRAY
29879: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
29880: LD_VAR 0 18
29884: NOT
29885: PUSH
29886: LD_INT 40
29888: PPUSH
29889: LD_VAR 0 16
29893: PPUSH
29894: CALL_OW 321
29898: PUSH
29899: LD_INT 2
29901: EQUAL
29902: AND
29903: PUSH
29904: LD_INT 7
29906: PUSH
29907: LD_VAR 0 5
29911: IN
29912: PUSH
29913: LD_INT 28
29915: PUSH
29916: LD_VAR 0 5
29920: IN
29921: OR
29922: PUSH
29923: LD_INT 45
29925: PUSH
29926: LD_VAR 0 5
29930: IN
29931: OR
29932: AND
29933: IFFALSE 30187
// begin hex := GetHexInfo ( x , y ) ;
29935: LD_ADDR_VAR 0 4
29939: PUSH
29940: LD_VAR 0 10
29944: PPUSH
29945: LD_VAR 0 11
29949: PPUSH
29950: CALL_OW 546
29954: ST_TO_ADDR
// if hex [ 1 ] then
29955: LD_VAR 0 4
29959: PUSH
29960: LD_INT 1
29962: ARRAY
29963: IFFALSE 29967
// exit ;
29965: GO 30370
// height := hex [ 2 ] ;
29967: LD_ADDR_VAR 0 15
29971: PUSH
29972: LD_VAR 0 4
29976: PUSH
29977: LD_INT 2
29979: ARRAY
29980: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
29981: LD_ADDR_VAR 0 14
29985: PUSH
29986: LD_INT 0
29988: PUSH
29989: LD_INT 2
29991: PUSH
29992: LD_INT 3
29994: PUSH
29995: LD_INT 5
29997: PUSH
29998: EMPTY
29999: LIST
30000: LIST
30001: LIST
30002: LIST
30003: ST_TO_ADDR
// for i in tmp do
30004: LD_ADDR_VAR 0 8
30008: PUSH
30009: LD_VAR 0 14
30013: PUSH
30014: FOR_IN
30015: IFFALSE 30185
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
30017: LD_ADDR_VAR 0 9
30021: PUSH
30022: LD_VAR 0 10
30026: PPUSH
30027: LD_VAR 0 8
30031: PPUSH
30032: LD_INT 5
30034: PPUSH
30035: CALL_OW 272
30039: PUSH
30040: LD_VAR 0 11
30044: PPUSH
30045: LD_VAR 0 8
30049: PPUSH
30050: LD_INT 5
30052: PPUSH
30053: CALL_OW 273
30057: PUSH
30058: EMPTY
30059: LIST
30060: LIST
30061: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
30062: LD_VAR 0 9
30066: PUSH
30067: LD_INT 1
30069: ARRAY
30070: PPUSH
30071: LD_VAR 0 9
30075: PUSH
30076: LD_INT 2
30078: ARRAY
30079: PPUSH
30080: CALL_OW 488
30084: IFFALSE 30183
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
30086: LD_ADDR_VAR 0 4
30090: PUSH
30091: LD_VAR 0 9
30095: PUSH
30096: LD_INT 1
30098: ARRAY
30099: PPUSH
30100: LD_VAR 0 9
30104: PUSH
30105: LD_INT 2
30107: ARRAY
30108: PPUSH
30109: CALL_OW 546
30113: ST_TO_ADDR
// if hex [ 1 ] then
30114: LD_VAR 0 4
30118: PUSH
30119: LD_INT 1
30121: ARRAY
30122: IFFALSE 30126
// continue ;
30124: GO 30014
// h := hex [ 2 ] ;
30126: LD_ADDR_VAR 0 13
30130: PUSH
30131: LD_VAR 0 4
30135: PUSH
30136: LD_INT 2
30138: ARRAY
30139: ST_TO_ADDR
// if h + 7 < height then
30140: LD_VAR 0 13
30144: PUSH
30145: LD_INT 7
30147: PLUS
30148: PUSH
30149: LD_VAR 0 15
30153: LESS
30154: IFFALSE 30183
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
30156: LD_ADDR_VAR 0 18
30160: PUSH
30161: LD_INT 7
30163: PUSH
30164: LD_INT 28
30166: PUSH
30167: LD_INT 45
30169: PUSH
30170: EMPTY
30171: LIST
30172: LIST
30173: LIST
30174: PUSH
30175: LD_VAR 0 12
30179: ARRAY
30180: ST_TO_ADDR
// break ;
30181: GO 30185
// end ; end ; end ;
30183: GO 30014
30185: POP
30186: POP
// end ; if not weapon then
30187: LD_VAR 0 18
30191: NOT
30192: IFFALSE 30252
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
30194: LD_ADDR_VAR 0 5
30198: PUSH
30199: LD_VAR 0 5
30203: PUSH
30204: LD_INT 11
30206: PUSH
30207: LD_INT 30
30209: PUSH
30210: LD_INT 49
30212: PUSH
30213: EMPTY
30214: LIST
30215: LIST
30216: LIST
30217: DIFF
30218: ST_TO_ADDR
// if not list then
30219: LD_VAR 0 5
30223: NOT
30224: IFFALSE 30228
// exit ;
30226: GO 30370
// weapon := list [ rand ( 1 , list ) ] ;
30228: LD_ADDR_VAR 0 18
30232: PUSH
30233: LD_VAR 0 5
30237: PUSH
30238: LD_INT 1
30240: PPUSH
30241: LD_VAR 0 5
30245: PPUSH
30246: CALL_OW 12
30250: ARRAY
30251: ST_TO_ADDR
// end ; if weapon then
30252: LD_VAR 0 18
30256: IFFALSE 30370
// begin tmp := CostOfWeapon ( weapon ) ;
30258: LD_ADDR_VAR 0 14
30262: PUSH
30263: LD_VAR 0 18
30267: PPUSH
30268: CALL_OW 451
30272: ST_TO_ADDR
// j := GetBase ( tower ) ;
30273: LD_ADDR_VAR 0 9
30277: PUSH
30278: LD_VAR 0 1
30282: PPUSH
30283: CALL_OW 274
30287: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
30288: LD_VAR 0 9
30292: PPUSH
30293: LD_INT 1
30295: PPUSH
30296: CALL_OW 275
30300: PUSH
30301: LD_VAR 0 14
30305: PUSH
30306: LD_INT 1
30308: ARRAY
30309: GREATEREQUAL
30310: PUSH
30311: LD_VAR 0 9
30315: PPUSH
30316: LD_INT 2
30318: PPUSH
30319: CALL_OW 275
30323: PUSH
30324: LD_VAR 0 14
30328: PUSH
30329: LD_INT 2
30331: ARRAY
30332: GREATEREQUAL
30333: AND
30334: PUSH
30335: LD_VAR 0 9
30339: PPUSH
30340: LD_INT 3
30342: PPUSH
30343: CALL_OW 275
30347: PUSH
30348: LD_VAR 0 14
30352: PUSH
30353: LD_INT 3
30355: ARRAY
30356: GREATEREQUAL
30357: AND
30358: IFFALSE 30370
// result := weapon ;
30360: LD_ADDR_VAR 0 3
30364: PUSH
30365: LD_VAR 0 18
30369: ST_TO_ADDR
// end ; end ;
30370: LD_VAR 0 3
30374: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
30375: LD_INT 0
30377: PPUSH
30378: PPUSH
// result := true ;
30379: LD_ADDR_VAR 0 3
30383: PUSH
30384: LD_INT 1
30386: ST_TO_ADDR
// if array1 = array2 then
30387: LD_VAR 0 1
30391: PUSH
30392: LD_VAR 0 2
30396: EQUAL
30397: IFFALSE 30457
// begin for i = 1 to array1 do
30399: LD_ADDR_VAR 0 4
30403: PUSH
30404: DOUBLE
30405: LD_INT 1
30407: DEC
30408: ST_TO_ADDR
30409: LD_VAR 0 1
30413: PUSH
30414: FOR_TO
30415: IFFALSE 30453
// if array1 [ i ] <> array2 [ i ] then
30417: LD_VAR 0 1
30421: PUSH
30422: LD_VAR 0 4
30426: ARRAY
30427: PUSH
30428: LD_VAR 0 2
30432: PUSH
30433: LD_VAR 0 4
30437: ARRAY
30438: NONEQUAL
30439: IFFALSE 30451
// begin result := false ;
30441: LD_ADDR_VAR 0 3
30445: PUSH
30446: LD_INT 0
30448: ST_TO_ADDR
// break ;
30449: GO 30453
// end ;
30451: GO 30414
30453: POP
30454: POP
// end else
30455: GO 30465
// result := false ;
30457: LD_ADDR_VAR 0 3
30461: PUSH
30462: LD_INT 0
30464: ST_TO_ADDR
// end ;
30465: LD_VAR 0 3
30469: RET
// export function CompareArrayValues ( array1 , array2 ) ; var i ; begin
30470: LD_INT 0
30472: PPUSH
30473: PPUSH
// if not array1 or not array2 then
30474: LD_VAR 0 1
30478: NOT
30479: PUSH
30480: LD_VAR 0 2
30484: NOT
30485: OR
30486: IFFALSE 30490
// exit ;
30488: GO 30554
// result := true ;
30490: LD_ADDR_VAR 0 3
30494: PUSH
30495: LD_INT 1
30497: ST_TO_ADDR
// for i = 1 to array1 do
30498: LD_ADDR_VAR 0 4
30502: PUSH
30503: DOUBLE
30504: LD_INT 1
30506: DEC
30507: ST_TO_ADDR
30508: LD_VAR 0 1
30512: PUSH
30513: FOR_TO
30514: IFFALSE 30552
// if array1 [ i ] <> array2 [ i ] then
30516: LD_VAR 0 1
30520: PUSH
30521: LD_VAR 0 4
30525: ARRAY
30526: PUSH
30527: LD_VAR 0 2
30531: PUSH
30532: LD_VAR 0 4
30536: ARRAY
30537: NONEQUAL
30538: IFFALSE 30550
// begin result := false ;
30540: LD_ADDR_VAR 0 3
30544: PUSH
30545: LD_INT 0
30547: ST_TO_ADDR
// break ;
30548: GO 30552
// end ;
30550: GO 30513
30552: POP
30553: POP
// end ;
30554: LD_VAR 0 3
30558: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
30559: LD_INT 0
30561: PPUSH
30562: PPUSH
30563: PPUSH
// pom := GetBase ( fac ) ;
30564: LD_ADDR_VAR 0 5
30568: PUSH
30569: LD_VAR 0 1
30573: PPUSH
30574: CALL_OW 274
30578: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
30579: LD_ADDR_VAR 0 4
30583: PUSH
30584: LD_VAR 0 2
30588: PUSH
30589: LD_INT 1
30591: ARRAY
30592: PPUSH
30593: LD_VAR 0 2
30597: PUSH
30598: LD_INT 2
30600: ARRAY
30601: PPUSH
30602: LD_VAR 0 2
30606: PUSH
30607: LD_INT 3
30609: ARRAY
30610: PPUSH
30611: LD_VAR 0 2
30615: PUSH
30616: LD_INT 4
30618: ARRAY
30619: PPUSH
30620: CALL_OW 449
30624: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
30625: LD_ADDR_VAR 0 3
30629: PUSH
30630: LD_VAR 0 5
30634: PPUSH
30635: LD_INT 1
30637: PPUSH
30638: CALL_OW 275
30642: PUSH
30643: LD_VAR 0 4
30647: PUSH
30648: LD_INT 1
30650: ARRAY
30651: GREATEREQUAL
30652: PUSH
30653: LD_VAR 0 5
30657: PPUSH
30658: LD_INT 2
30660: PPUSH
30661: CALL_OW 275
30665: PUSH
30666: LD_VAR 0 4
30670: PUSH
30671: LD_INT 2
30673: ARRAY
30674: GREATEREQUAL
30675: AND
30676: PUSH
30677: LD_VAR 0 5
30681: PPUSH
30682: LD_INT 3
30684: PPUSH
30685: CALL_OW 275
30689: PUSH
30690: LD_VAR 0 4
30694: PUSH
30695: LD_INT 3
30697: ARRAY
30698: GREATEREQUAL
30699: AND
30700: ST_TO_ADDR
// end ;
30701: LD_VAR 0 3
30705: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
30706: LD_INT 0
30708: PPUSH
30709: PPUSH
30710: PPUSH
30711: PPUSH
// pom := GetBase ( building ) ;
30712: LD_ADDR_VAR 0 3
30716: PUSH
30717: LD_VAR 0 1
30721: PPUSH
30722: CALL_OW 274
30726: ST_TO_ADDR
// if not pom then
30727: LD_VAR 0 3
30731: NOT
30732: IFFALSE 30736
// exit ;
30734: GO 30906
// btype := GetBType ( building ) ;
30736: LD_ADDR_VAR 0 5
30740: PUSH
30741: LD_VAR 0 1
30745: PPUSH
30746: CALL_OW 266
30750: ST_TO_ADDR
// if btype = b_armoury then
30751: LD_VAR 0 5
30755: PUSH
30756: LD_INT 4
30758: EQUAL
30759: IFFALSE 30769
// btype := b_barracks ;
30761: LD_ADDR_VAR 0 5
30765: PUSH
30766: LD_INT 5
30768: ST_TO_ADDR
// if btype = b_depot then
30769: LD_VAR 0 5
30773: PUSH
30774: LD_INT 0
30776: EQUAL
30777: IFFALSE 30787
// btype := b_warehouse ;
30779: LD_ADDR_VAR 0 5
30783: PUSH
30784: LD_INT 1
30786: ST_TO_ADDR
// if btype = b_workshop then
30787: LD_VAR 0 5
30791: PUSH
30792: LD_INT 2
30794: EQUAL
30795: IFFALSE 30805
// btype := b_factory ;
30797: LD_ADDR_VAR 0 5
30801: PUSH
30802: LD_INT 3
30804: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
30805: LD_ADDR_VAR 0 4
30809: PUSH
30810: LD_VAR 0 5
30814: PPUSH
30815: LD_VAR 0 1
30819: PPUSH
30820: CALL_OW 248
30824: PPUSH
30825: CALL_OW 450
30829: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
30830: LD_ADDR_VAR 0 2
30834: PUSH
30835: LD_VAR 0 3
30839: PPUSH
30840: LD_INT 1
30842: PPUSH
30843: CALL_OW 275
30847: PUSH
30848: LD_VAR 0 4
30852: PUSH
30853: LD_INT 1
30855: ARRAY
30856: GREATEREQUAL
30857: PUSH
30858: LD_VAR 0 3
30862: PPUSH
30863: LD_INT 2
30865: PPUSH
30866: CALL_OW 275
30870: PUSH
30871: LD_VAR 0 4
30875: PUSH
30876: LD_INT 2
30878: ARRAY
30879: GREATEREQUAL
30880: AND
30881: PUSH
30882: LD_VAR 0 3
30886: PPUSH
30887: LD_INT 3
30889: PPUSH
30890: CALL_OW 275
30894: PUSH
30895: LD_VAR 0 4
30899: PUSH
30900: LD_INT 3
30902: ARRAY
30903: GREATEREQUAL
30904: AND
30905: ST_TO_ADDR
// end ;
30906: LD_VAR 0 2
30910: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
30911: LD_INT 0
30913: PPUSH
30914: PPUSH
30915: PPUSH
// pom := GetBase ( building ) ;
30916: LD_ADDR_VAR 0 4
30920: PUSH
30921: LD_VAR 0 1
30925: PPUSH
30926: CALL_OW 274
30930: ST_TO_ADDR
// if not pom then
30931: LD_VAR 0 4
30935: NOT
30936: IFFALSE 30940
// exit ;
30938: GO 31041
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
30940: LD_ADDR_VAR 0 5
30944: PUSH
30945: LD_VAR 0 2
30949: PPUSH
30950: LD_VAR 0 1
30954: PPUSH
30955: CALL_OW 248
30959: PPUSH
30960: CALL_OW 450
30964: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
30965: LD_ADDR_VAR 0 3
30969: PUSH
30970: LD_VAR 0 4
30974: PPUSH
30975: LD_INT 1
30977: PPUSH
30978: CALL_OW 275
30982: PUSH
30983: LD_VAR 0 5
30987: PUSH
30988: LD_INT 1
30990: ARRAY
30991: GREATEREQUAL
30992: PUSH
30993: LD_VAR 0 4
30997: PPUSH
30998: LD_INT 2
31000: PPUSH
31001: CALL_OW 275
31005: PUSH
31006: LD_VAR 0 5
31010: PUSH
31011: LD_INT 2
31013: ARRAY
31014: GREATEREQUAL
31015: AND
31016: PUSH
31017: LD_VAR 0 4
31021: PPUSH
31022: LD_INT 3
31024: PPUSH
31025: CALL_OW 275
31029: PUSH
31030: LD_VAR 0 5
31034: PUSH
31035: LD_INT 3
31037: ARRAY
31038: GREATEREQUAL
31039: AND
31040: ST_TO_ADDR
// end ;
31041: LD_VAR 0 3
31045: RET
// export function TryClearPlaceForBuilding ( btype , x , y , d , buildings , cleaners , parking ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep , driver ; begin
31046: LD_INT 0
31048: PPUSH
31049: PPUSH
31050: PPUSH
31051: PPUSH
31052: PPUSH
31053: PPUSH
31054: PPUSH
31055: PPUSH
31056: PPUSH
31057: PPUSH
31058: PPUSH
// result := false ;
31059: LD_ADDR_VAR 0 8
31063: PUSH
31064: LD_INT 0
31066: ST_TO_ADDR
// if not buildings or not btype or not x or not y then
31067: LD_VAR 0 5
31071: NOT
31072: PUSH
31073: LD_VAR 0 1
31077: NOT
31078: OR
31079: PUSH
31080: LD_VAR 0 2
31084: NOT
31085: OR
31086: PUSH
31087: LD_VAR 0 3
31091: NOT
31092: OR
31093: IFFALSE 31097
// exit ;
31095: GO 31911
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( buildings [ 1 ] ) , 0 ) ;
31097: LD_ADDR_VAR 0 14
31101: PUSH
31102: LD_VAR 0 1
31106: PPUSH
31107: LD_VAR 0 2
31111: PPUSH
31112: LD_VAR 0 3
31116: PPUSH
31117: LD_VAR 0 4
31121: PPUSH
31122: LD_VAR 0 5
31126: PUSH
31127: LD_INT 1
31129: ARRAY
31130: PPUSH
31131: CALL_OW 248
31135: PPUSH
31136: LD_INT 0
31138: PPUSH
31139: CALL 33164 0 6
31143: ST_TO_ADDR
// if not hexes then
31144: LD_VAR 0 14
31148: NOT
31149: IFFALSE 31153
// exit ;
31151: GO 31911
// dep := UnitFilter ( buildings , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
31153: LD_ADDR_VAR 0 17
31157: PUSH
31158: LD_VAR 0 5
31162: PPUSH
31163: LD_INT 22
31165: PUSH
31166: LD_VAR 0 13
31170: PPUSH
31171: CALL_OW 255
31175: PUSH
31176: EMPTY
31177: LIST
31178: LIST
31179: PUSH
31180: LD_INT 2
31182: PUSH
31183: LD_INT 30
31185: PUSH
31186: LD_INT 0
31188: PUSH
31189: EMPTY
31190: LIST
31191: LIST
31192: PUSH
31193: LD_INT 30
31195: PUSH
31196: LD_INT 1
31198: PUSH
31199: EMPTY
31200: LIST
31201: LIST
31202: PUSH
31203: EMPTY
31204: LIST
31205: LIST
31206: LIST
31207: PUSH
31208: EMPTY
31209: LIST
31210: LIST
31211: PPUSH
31212: CALL_OW 72
31216: ST_TO_ADDR
// for i = 1 to hexes do
31217: LD_ADDR_VAR 0 9
31221: PUSH
31222: DOUBLE
31223: LD_INT 1
31225: DEC
31226: ST_TO_ADDR
31227: LD_VAR 0 14
31231: PUSH
31232: FOR_TO
31233: IFFALSE 31909
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
31235: LD_ADDR_VAR 0 13
31239: PUSH
31240: LD_VAR 0 14
31244: PUSH
31245: LD_VAR 0 9
31249: ARRAY
31250: PUSH
31251: LD_INT 1
31253: ARRAY
31254: PPUSH
31255: LD_VAR 0 14
31259: PUSH
31260: LD_VAR 0 9
31264: ARRAY
31265: PUSH
31266: LD_INT 2
31268: ARRAY
31269: PPUSH
31270: CALL_OW 428
31274: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
31275: LD_VAR 0 14
31279: PUSH
31280: LD_VAR 0 9
31284: ARRAY
31285: PUSH
31286: LD_INT 1
31288: ARRAY
31289: PPUSH
31290: LD_VAR 0 14
31294: PUSH
31295: LD_VAR 0 9
31299: ARRAY
31300: PUSH
31301: LD_INT 2
31303: ARRAY
31304: PPUSH
31305: CALL_OW 351
31309: PUSH
31310: LD_VAR 0 14
31314: PUSH
31315: LD_VAR 0 9
31319: ARRAY
31320: PUSH
31321: LD_INT 1
31323: ARRAY
31324: PPUSH
31325: LD_VAR 0 14
31329: PUSH
31330: LD_VAR 0 9
31334: ARRAY
31335: PUSH
31336: LD_INT 2
31338: ARRAY
31339: PPUSH
31340: CALL_OW 488
31344: NOT
31345: OR
31346: PUSH
31347: LD_VAR 0 13
31351: PPUSH
31352: CALL_OW 247
31356: PUSH
31357: LD_INT 3
31359: EQUAL
31360: OR
31361: IFFALSE 31367
// exit ;
31363: POP
31364: POP
31365: GO 31911
// if not tmp then
31367: LD_VAR 0 13
31371: NOT
31372: IFFALSE 31376
// continue ;
31374: GO 31232
// result := true ;
31376: LD_ADDR_VAR 0 8
31380: PUSH
31381: LD_INT 1
31383: ST_TO_ADDR
// if cleaners and GetType ( tmp ) = unit_vehicle and GetControl ( tmp ) = control_manual then
31384: LD_VAR 0 6
31388: PUSH
31389: LD_VAR 0 13
31393: PPUSH
31394: CALL_OW 247
31398: PUSH
31399: LD_INT 2
31401: EQUAL
31402: AND
31403: PUSH
31404: LD_VAR 0 13
31408: PPUSH
31409: CALL_OW 263
31413: PUSH
31414: LD_INT 1
31416: EQUAL
31417: AND
31418: IFFALSE 31582
// begin if IsDrivenBy ( tmp ) then
31420: LD_VAR 0 13
31424: PPUSH
31425: CALL_OW 311
31429: IFFALSE 31433
// continue ;
31431: GO 31232
// if UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) then
31433: LD_VAR 0 6
31437: PPUSH
31438: LD_INT 3
31440: PUSH
31441: LD_INT 60
31443: PUSH
31444: EMPTY
31445: LIST
31446: PUSH
31447: EMPTY
31448: LIST
31449: LIST
31450: PUSH
31451: LD_INT 3
31453: PUSH
31454: LD_INT 55
31456: PUSH
31457: EMPTY
31458: LIST
31459: PUSH
31460: EMPTY
31461: LIST
31462: LIST
31463: PUSH
31464: EMPTY
31465: LIST
31466: LIST
31467: PPUSH
31468: CALL_OW 72
31472: IFFALSE 31580
// begin driver := UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) [ 1 ] ;
31474: LD_ADDR_VAR 0 18
31478: PUSH
31479: LD_VAR 0 6
31483: PPUSH
31484: LD_INT 3
31486: PUSH
31487: LD_INT 60
31489: PUSH
31490: EMPTY
31491: LIST
31492: PUSH
31493: EMPTY
31494: LIST
31495: LIST
31496: PUSH
31497: LD_INT 3
31499: PUSH
31500: LD_INT 55
31502: PUSH
31503: EMPTY
31504: LIST
31505: PUSH
31506: EMPTY
31507: LIST
31508: LIST
31509: PUSH
31510: EMPTY
31511: LIST
31512: LIST
31513: PPUSH
31514: CALL_OW 72
31518: PUSH
31519: LD_INT 1
31521: ARRAY
31522: ST_TO_ADDR
// if IsInUnit ( driver ) then
31523: LD_VAR 0 18
31527: PPUSH
31528: CALL_OW 310
31532: IFFALSE 31543
// ComExit ( driver ) ;
31534: LD_VAR 0 18
31538: PPUSH
31539: CALL 56943 0 1
// AddComEnterUnit ( driver , tmp ) ;
31543: LD_VAR 0 18
31547: PPUSH
31548: LD_VAR 0 13
31552: PPUSH
31553: CALL_OW 180
// AddComMoveToArea ( driver , parking ) ;
31557: LD_VAR 0 18
31561: PPUSH
31562: LD_VAR 0 7
31566: PPUSH
31567: CALL_OW 173
// AddComExitVehicle ( driver ) ;
31571: LD_VAR 0 18
31575: PPUSH
31576: CALL_OW 181
// end ; continue ;
31580: GO 31232
// end ; if not cleaners or not tmp in cleaners then
31582: LD_VAR 0 6
31586: NOT
31587: PUSH
31588: LD_VAR 0 13
31592: PUSH
31593: LD_VAR 0 6
31597: IN
31598: NOT
31599: OR
31600: IFFALSE 31907
// begin if dep then
31602: LD_VAR 0 17
31606: IFFALSE 31742
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
31608: LD_ADDR_VAR 0 16
31612: PUSH
31613: LD_VAR 0 17
31617: PUSH
31618: LD_INT 1
31620: ARRAY
31621: PPUSH
31622: CALL_OW 250
31626: PPUSH
31627: LD_VAR 0 17
31631: PUSH
31632: LD_INT 1
31634: ARRAY
31635: PPUSH
31636: CALL_OW 254
31640: PPUSH
31641: LD_INT 5
31643: PPUSH
31644: CALL_OW 272
31648: PUSH
31649: LD_VAR 0 17
31653: PUSH
31654: LD_INT 1
31656: ARRAY
31657: PPUSH
31658: CALL_OW 251
31662: PPUSH
31663: LD_VAR 0 17
31667: PUSH
31668: LD_INT 1
31670: ARRAY
31671: PPUSH
31672: CALL_OW 254
31676: PPUSH
31677: LD_INT 5
31679: PPUSH
31680: CALL_OW 273
31684: PUSH
31685: EMPTY
31686: LIST
31687: LIST
31688: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
31689: LD_VAR 0 16
31693: PUSH
31694: LD_INT 1
31696: ARRAY
31697: PPUSH
31698: LD_VAR 0 16
31702: PUSH
31703: LD_INT 2
31705: ARRAY
31706: PPUSH
31707: CALL_OW 488
31711: IFFALSE 31742
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
31713: LD_VAR 0 13
31717: PPUSH
31718: LD_VAR 0 16
31722: PUSH
31723: LD_INT 1
31725: ARRAY
31726: PPUSH
31727: LD_VAR 0 16
31731: PUSH
31732: LD_INT 2
31734: ARRAY
31735: PPUSH
31736: CALL_OW 111
// continue ;
31740: GO 31232
// end ; end ; r := GetDir ( tmp ) ;
31742: LD_ADDR_VAR 0 15
31746: PUSH
31747: LD_VAR 0 13
31751: PPUSH
31752: CALL_OW 254
31756: ST_TO_ADDR
// if r = 5 then
31757: LD_VAR 0 15
31761: PUSH
31762: LD_INT 5
31764: EQUAL
31765: IFFALSE 31775
// r := 0 ;
31767: LD_ADDR_VAR 0 15
31771: PUSH
31772: LD_INT 0
31774: ST_TO_ADDR
// for j = r to 5 do
31775: LD_ADDR_VAR 0 10
31779: PUSH
31780: DOUBLE
31781: LD_VAR 0 15
31785: DEC
31786: ST_TO_ADDR
31787: LD_INT 5
31789: PUSH
31790: FOR_TO
31791: IFFALSE 31905
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
31793: LD_ADDR_VAR 0 11
31797: PUSH
31798: LD_VAR 0 13
31802: PPUSH
31803: CALL_OW 250
31807: PPUSH
31808: LD_VAR 0 10
31812: PPUSH
31813: LD_INT 2
31815: PPUSH
31816: CALL_OW 272
31820: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
31821: LD_ADDR_VAR 0 12
31825: PUSH
31826: LD_VAR 0 13
31830: PPUSH
31831: CALL_OW 251
31835: PPUSH
31836: LD_VAR 0 10
31840: PPUSH
31841: LD_INT 2
31843: PPUSH
31844: CALL_OW 273
31848: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
31849: LD_VAR 0 11
31853: PPUSH
31854: LD_VAR 0 12
31858: PPUSH
31859: CALL_OW 488
31863: PUSH
31864: LD_VAR 0 11
31868: PPUSH
31869: LD_VAR 0 12
31873: PPUSH
31874: CALL_OW 428
31878: NOT
31879: AND
31880: IFFALSE 31903
// begin ComMoveXY ( tmp , _x , _y ) ;
31882: LD_VAR 0 13
31886: PPUSH
31887: LD_VAR 0 11
31891: PPUSH
31892: LD_VAR 0 12
31896: PPUSH
31897: CALL_OW 111
// break ;
31901: GO 31905
// end ; end ;
31903: GO 31790
31905: POP
31906: POP
// end ; end ;
31907: GO 31232
31909: POP
31910: POP
// end ;
31911: LD_VAR 0 8
31915: RET
// export function BuildingTechInvented ( side , btype ) ; begin
31916: LD_INT 0
31918: PPUSH
// result := true ;
31919: LD_ADDR_VAR 0 3
31923: PUSH
31924: LD_INT 1
31926: ST_TO_ADDR
// case btype of b_ext_computer , b_turret :
31927: LD_VAR 0 2
31931: PUSH
31932: LD_INT 24
31934: DOUBLE
31935: EQUAL
31936: IFTRUE 31946
31938: LD_INT 33
31940: DOUBLE
31941: EQUAL
31942: IFTRUE 31946
31944: GO 31971
31946: POP
// result := ( GetTech ( tech_ai , side ) = state_researched ) ; b_ext_radar :
31947: LD_ADDR_VAR 0 3
31951: PUSH
31952: LD_INT 32
31954: PPUSH
31955: LD_VAR 0 1
31959: PPUSH
31960: CALL_OW 321
31964: PUSH
31965: LD_INT 2
31967: EQUAL
31968: ST_TO_ADDR
31969: GO 32287
31971: LD_INT 20
31973: DOUBLE
31974: EQUAL
31975: IFTRUE 31979
31977: GO 32004
31979: POP
// result := ( GetTech ( tech_radar , side ) = state_researched ) ; b_ext_radio , b_control_tower :
31980: LD_ADDR_VAR 0 3
31984: PUSH
31985: LD_INT 6
31987: PPUSH
31988: LD_VAR 0 1
31992: PPUSH
31993: CALL_OW 321
31997: PUSH
31998: LD_INT 2
32000: EQUAL
32001: ST_TO_ADDR
32002: GO 32287
32004: LD_INT 22
32006: DOUBLE
32007: EQUAL
32008: IFTRUE 32018
32010: LD_INT 36
32012: DOUBLE
32013: EQUAL
32014: IFTRUE 32018
32016: GO 32043
32018: POP
// result := ( GetTech ( tech_remcont , side ) = state_researched ) ; b_siberite_mine :
32019: LD_ADDR_VAR 0 3
32023: PUSH
32024: LD_INT 15
32026: PPUSH
32027: LD_VAR 0 1
32031: PPUSH
32032: CALL_OW 321
32036: PUSH
32037: LD_INT 2
32039: EQUAL
32040: ST_TO_ADDR
32041: GO 32287
32043: LD_INT 30
32045: DOUBLE
32046: EQUAL
32047: IFTRUE 32051
32049: GO 32076
32051: POP
// result := ( GetTech ( tech_sibdet , side ) = state_researched ) ; b_siberite_power , b_ext_siberium :
32052: LD_ADDR_VAR 0 3
32056: PUSH
32057: LD_INT 20
32059: PPUSH
32060: LD_VAR 0 1
32064: PPUSH
32065: CALL_OW 321
32069: PUSH
32070: LD_INT 2
32072: EQUAL
32073: ST_TO_ADDR
32074: GO 32287
32076: LD_INT 28
32078: DOUBLE
32079: EQUAL
32080: IFTRUE 32090
32082: LD_INT 21
32084: DOUBLE
32085: EQUAL
32086: IFTRUE 32090
32088: GO 32115
32090: POP
// result := ( GetTech ( tech_sibpow , side ) = state_researched ) ; b_ext_track :
32091: LD_ADDR_VAR 0 3
32095: PUSH
32096: LD_INT 21
32098: PPUSH
32099: LD_VAR 0 1
32103: PPUSH
32104: CALL_OW 321
32108: PUSH
32109: LD_INT 2
32111: EQUAL
32112: ST_TO_ADDR
32113: GO 32287
32115: LD_INT 16
32117: DOUBLE
32118: EQUAL
32119: IFTRUE 32123
32121: GO 32148
32123: POP
// result := ( GetTech ( tech_track , side ) = state_researched ) ; b_ext_noncombat , b_ext_stitch :
32124: LD_ADDR_VAR 0 3
32128: PUSH
32129: LD_INT 84
32131: PPUSH
32132: LD_VAR 0 1
32136: PPUSH
32137: CALL_OW 321
32141: PUSH
32142: LD_INT 2
32144: EQUAL
32145: ST_TO_ADDR
32146: GO 32287
32148: LD_INT 19
32150: DOUBLE
32151: EQUAL
32152: IFTRUE 32162
32154: LD_INT 23
32156: DOUBLE
32157: EQUAL
32158: IFTRUE 32162
32160: GO 32187
32162: POP
// result := ( GetTech ( tech_cargo , side ) = state_researched ) ; b_ext_gun :
32163: LD_ADDR_VAR 0 3
32167: PUSH
32168: LD_INT 83
32170: PPUSH
32171: LD_VAR 0 1
32175: PPUSH
32176: CALL_OW 321
32180: PUSH
32181: LD_INT 2
32183: EQUAL
32184: ST_TO_ADDR
32185: GO 32287
32187: LD_INT 17
32189: DOUBLE
32190: EQUAL
32191: IFTRUE 32195
32193: GO 32220
32195: POP
// result := ( GetTech ( tech_gun , side ) = state_researched ) ; b_ext_rocket :
32196: LD_ADDR_VAR 0 3
32200: PUSH
32201: LD_INT 39
32203: PPUSH
32204: LD_VAR 0 1
32208: PPUSH
32209: CALL_OW 321
32213: PUSH
32214: LD_INT 2
32216: EQUAL
32217: ST_TO_ADDR
32218: GO 32287
32220: LD_INT 18
32222: DOUBLE
32223: EQUAL
32224: IFTRUE 32228
32226: GO 32253
32228: POP
// result := ( GetTech ( tech_rocket , side ) = state_researched ) ; b_solar_power :
32229: LD_ADDR_VAR 0 3
32233: PUSH
32234: LD_INT 40
32236: PPUSH
32237: LD_VAR 0 1
32241: PPUSH
32242: CALL_OW 321
32246: PUSH
32247: LD_INT 2
32249: EQUAL
32250: ST_TO_ADDR
32251: GO 32287
32253: LD_INT 27
32255: DOUBLE
32256: EQUAL
32257: IFTRUE 32261
32259: GO 32286
32261: POP
// result := ( GetTech ( tech_solpow , side ) = state_researched ) ; end ;
32262: LD_ADDR_VAR 0 3
32266: PUSH
32267: LD_INT 35
32269: PPUSH
32270: LD_VAR 0 1
32274: PPUSH
32275: CALL_OW 321
32279: PUSH
32280: LD_INT 2
32282: EQUAL
32283: ST_TO_ADDR
32284: GO 32287
32286: POP
// end ;
32287: LD_VAR 0 3
32291: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex , tech ; begin
32292: LD_INT 0
32294: PPUSH
32295: PPUSH
32296: PPUSH
32297: PPUSH
32298: PPUSH
32299: PPUSH
32300: PPUSH
32301: PPUSH
32302: PPUSH
32303: PPUSH
32304: PPUSH
// result := false ;
32305: LD_ADDR_VAR 0 6
32309: PUSH
32310: LD_INT 0
32312: ST_TO_ADDR
// if btype = b_depot then
32313: LD_VAR 0 2
32317: PUSH
32318: LD_INT 0
32320: EQUAL
32321: IFFALSE 32333
// begin result := true ;
32323: LD_ADDR_VAR 0 6
32327: PUSH
32328: LD_INT 1
32330: ST_TO_ADDR
// exit ;
32331: GO 33159
// end ; if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
32333: LD_VAR 0 1
32337: NOT
32338: PUSH
32339: LD_VAR 0 1
32343: PPUSH
32344: CALL_OW 266
32348: PUSH
32349: LD_INT 0
32351: PUSH
32352: LD_INT 1
32354: PUSH
32355: EMPTY
32356: LIST
32357: LIST
32358: IN
32359: NOT
32360: OR
32361: PUSH
32362: LD_VAR 0 2
32366: NOT
32367: OR
32368: PUSH
32369: LD_VAR 0 5
32373: PUSH
32374: LD_INT 0
32376: PUSH
32377: LD_INT 1
32379: PUSH
32380: LD_INT 2
32382: PUSH
32383: LD_INT 3
32385: PUSH
32386: LD_INT 4
32388: PUSH
32389: LD_INT 5
32391: PUSH
32392: EMPTY
32393: LIST
32394: LIST
32395: LIST
32396: LIST
32397: LIST
32398: LIST
32399: IN
32400: NOT
32401: OR
32402: PUSH
32403: LD_VAR 0 3
32407: PPUSH
32408: LD_VAR 0 4
32412: PPUSH
32413: CALL_OW 488
32417: NOT
32418: OR
32419: IFFALSE 32423
// exit ;
32421: GO 33159
// side := GetSide ( depot ) ;
32423: LD_ADDR_VAR 0 9
32427: PUSH
32428: LD_VAR 0 1
32432: PPUSH
32433: CALL_OW 255
32437: ST_TO_ADDR
// if not BuildingTechInvented ( side , btype ) then
32438: LD_VAR 0 9
32442: PPUSH
32443: LD_VAR 0 2
32447: PPUSH
32448: CALL 31916 0 2
32452: NOT
32453: IFFALSE 32457
// exit ;
32455: GO 33159
// pom := GetBase ( depot ) ;
32457: LD_ADDR_VAR 0 10
32461: PUSH
32462: LD_VAR 0 1
32466: PPUSH
32467: CALL_OW 274
32471: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
32472: LD_ADDR_VAR 0 11
32476: PUSH
32477: LD_VAR 0 2
32481: PPUSH
32482: LD_VAR 0 1
32486: PPUSH
32487: CALL_OW 248
32491: PPUSH
32492: CALL_OW 450
32496: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
32497: LD_VAR 0 10
32501: PPUSH
32502: LD_INT 1
32504: PPUSH
32505: CALL_OW 275
32509: PUSH
32510: LD_VAR 0 11
32514: PUSH
32515: LD_INT 1
32517: ARRAY
32518: GREATEREQUAL
32519: PUSH
32520: LD_VAR 0 10
32524: PPUSH
32525: LD_INT 2
32527: PPUSH
32528: CALL_OW 275
32532: PUSH
32533: LD_VAR 0 11
32537: PUSH
32538: LD_INT 2
32540: ARRAY
32541: GREATEREQUAL
32542: AND
32543: PUSH
32544: LD_VAR 0 10
32548: PPUSH
32549: LD_INT 3
32551: PPUSH
32552: CALL_OW 275
32556: PUSH
32557: LD_VAR 0 11
32561: PUSH
32562: LD_INT 3
32564: ARRAY
32565: GREATEREQUAL
32566: AND
32567: NOT
32568: IFFALSE 32572
// exit ;
32570: GO 33159
// if GetBType ( depot ) = b_depot then
32572: LD_VAR 0 1
32576: PPUSH
32577: CALL_OW 266
32581: PUSH
32582: LD_INT 0
32584: EQUAL
32585: IFFALSE 32597
// dist := 28 else
32587: LD_ADDR_VAR 0 14
32591: PUSH
32592: LD_INT 28
32594: ST_TO_ADDR
32595: GO 32605
// dist := 36 ;
32597: LD_ADDR_VAR 0 14
32601: PUSH
32602: LD_INT 36
32604: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
32605: LD_VAR 0 1
32609: PPUSH
32610: LD_VAR 0 3
32614: PPUSH
32615: LD_VAR 0 4
32619: PPUSH
32620: CALL_OW 297
32624: PUSH
32625: LD_VAR 0 14
32629: GREATER
32630: IFFALSE 32634
// exit ;
32632: GO 33159
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
32634: LD_ADDR_VAR 0 12
32638: PUSH
32639: LD_VAR 0 2
32643: PPUSH
32644: LD_VAR 0 3
32648: PPUSH
32649: LD_VAR 0 4
32653: PPUSH
32654: LD_VAR 0 5
32658: PPUSH
32659: LD_VAR 0 1
32663: PPUSH
32664: CALL_OW 248
32668: PPUSH
32669: LD_INT 0
32671: PPUSH
32672: CALL 33164 0 6
32676: ST_TO_ADDR
// if not hexes then
32677: LD_VAR 0 12
32681: NOT
32682: IFFALSE 32686
// exit ;
32684: GO 33159
// hex := GetHexInfo ( x , y ) ;
32686: LD_ADDR_VAR 0 15
32690: PUSH
32691: LD_VAR 0 3
32695: PPUSH
32696: LD_VAR 0 4
32700: PPUSH
32701: CALL_OW 546
32705: ST_TO_ADDR
// if hex [ 1 ] then
32706: LD_VAR 0 15
32710: PUSH
32711: LD_INT 1
32713: ARRAY
32714: IFFALSE 32718
// exit ;
32716: GO 33159
// height := hex [ 2 ] ;
32718: LD_ADDR_VAR 0 13
32722: PUSH
32723: LD_VAR 0 15
32727: PUSH
32728: LD_INT 2
32730: ARRAY
32731: ST_TO_ADDR
// for i = 1 to hexes do
32732: LD_ADDR_VAR 0 7
32736: PUSH
32737: DOUBLE
32738: LD_INT 1
32740: DEC
32741: ST_TO_ADDR
32742: LD_VAR 0 12
32746: PUSH
32747: FOR_TO
32748: IFFALSE 33078
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
32750: LD_VAR 0 12
32754: PUSH
32755: LD_VAR 0 7
32759: ARRAY
32760: PUSH
32761: LD_INT 1
32763: ARRAY
32764: PPUSH
32765: LD_VAR 0 12
32769: PUSH
32770: LD_VAR 0 7
32774: ARRAY
32775: PUSH
32776: LD_INT 2
32778: ARRAY
32779: PPUSH
32780: CALL_OW 488
32784: NOT
32785: PUSH
32786: LD_VAR 0 12
32790: PUSH
32791: LD_VAR 0 7
32795: ARRAY
32796: PUSH
32797: LD_INT 1
32799: ARRAY
32800: PPUSH
32801: LD_VAR 0 12
32805: PUSH
32806: LD_VAR 0 7
32810: ARRAY
32811: PUSH
32812: LD_INT 2
32814: ARRAY
32815: PPUSH
32816: CALL_OW 428
32820: PUSH
32821: LD_INT 0
32823: GREATER
32824: OR
32825: PUSH
32826: LD_VAR 0 12
32830: PUSH
32831: LD_VAR 0 7
32835: ARRAY
32836: PUSH
32837: LD_INT 1
32839: ARRAY
32840: PPUSH
32841: LD_VAR 0 12
32845: PUSH
32846: LD_VAR 0 7
32850: ARRAY
32851: PUSH
32852: LD_INT 2
32854: ARRAY
32855: PPUSH
32856: CALL_OW 351
32860: OR
32861: IFFALSE 32867
// exit ;
32863: POP
32864: POP
32865: GO 33159
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
32867: LD_ADDR_VAR 0 8
32871: PUSH
32872: LD_VAR 0 12
32876: PUSH
32877: LD_VAR 0 7
32881: ARRAY
32882: PUSH
32883: LD_INT 1
32885: ARRAY
32886: PPUSH
32887: LD_VAR 0 12
32891: PUSH
32892: LD_VAR 0 7
32896: ARRAY
32897: PUSH
32898: LD_INT 2
32900: ARRAY
32901: PPUSH
32902: CALL_OW 546
32906: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
32907: LD_VAR 0 8
32911: PUSH
32912: LD_INT 1
32914: ARRAY
32915: PUSH
32916: LD_VAR 0 8
32920: PUSH
32921: LD_INT 2
32923: ARRAY
32924: PUSH
32925: LD_VAR 0 13
32929: PUSH
32930: LD_INT 2
32932: PLUS
32933: GREATER
32934: OR
32935: PUSH
32936: LD_VAR 0 8
32940: PUSH
32941: LD_INT 2
32943: ARRAY
32944: PUSH
32945: LD_VAR 0 13
32949: PUSH
32950: LD_INT 2
32952: MINUS
32953: LESS
32954: OR
32955: PUSH
32956: LD_VAR 0 8
32960: PUSH
32961: LD_INT 3
32963: ARRAY
32964: PUSH
32965: LD_INT 0
32967: PUSH
32968: LD_INT 8
32970: PUSH
32971: LD_INT 9
32973: PUSH
32974: LD_INT 10
32976: PUSH
32977: LD_INT 11
32979: PUSH
32980: LD_INT 12
32982: PUSH
32983: LD_INT 13
32985: PUSH
32986: LD_INT 16
32988: PUSH
32989: LD_INT 17
32991: PUSH
32992: LD_INT 18
32994: PUSH
32995: LD_INT 19
32997: PUSH
32998: LD_INT 20
33000: PUSH
33001: LD_INT 21
33003: PUSH
33004: EMPTY
33005: LIST
33006: LIST
33007: LIST
33008: LIST
33009: LIST
33010: LIST
33011: LIST
33012: LIST
33013: LIST
33014: LIST
33015: LIST
33016: LIST
33017: LIST
33018: IN
33019: NOT
33020: OR
33021: PUSH
33022: LD_VAR 0 8
33026: PUSH
33027: LD_INT 5
33029: ARRAY
33030: NOT
33031: OR
33032: PUSH
33033: LD_VAR 0 8
33037: PUSH
33038: LD_INT 6
33040: ARRAY
33041: PUSH
33042: LD_INT 1
33044: PUSH
33045: LD_INT 2
33047: PUSH
33048: LD_INT 7
33050: PUSH
33051: LD_INT 9
33053: PUSH
33054: LD_INT 10
33056: PUSH
33057: LD_INT 11
33059: PUSH
33060: EMPTY
33061: LIST
33062: LIST
33063: LIST
33064: LIST
33065: LIST
33066: LIST
33067: IN
33068: NOT
33069: OR
33070: IFFALSE 33076
// exit ;
33072: POP
33073: POP
33074: GO 33159
// end ;
33076: GO 32747
33078: POP
33079: POP
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
33080: LD_VAR 0 9
33084: PPUSH
33085: LD_VAR 0 3
33089: PPUSH
33090: LD_VAR 0 4
33094: PPUSH
33095: LD_INT 20
33097: PPUSH
33098: CALL 25082 0 4
33102: PUSH
33103: LD_INT 4
33105: ARRAY
33106: IFFALSE 33110
// exit ;
33108: GO 33159
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
33110: LD_VAR 0 2
33114: PUSH
33115: LD_INT 29
33117: PUSH
33118: LD_INT 30
33120: PUSH
33121: EMPTY
33122: LIST
33123: LIST
33124: IN
33125: PUSH
33126: LD_VAR 0 3
33130: PPUSH
33131: LD_VAR 0 4
33135: PPUSH
33136: LD_VAR 0 9
33140: PPUSH
33141: CALL_OW 440
33145: NOT
33146: AND
33147: IFFALSE 33151
// exit ;
33149: GO 33159
// result := true ;
33151: LD_ADDR_VAR 0 6
33155: PUSH
33156: LD_INT 1
33158: ST_TO_ADDR
// end ;
33159: LD_VAR 0 6
33163: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 , fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 , fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ; var fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 , fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ; var fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 , fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ; var fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 , fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ; begin
33164: LD_INT 0
33166: PPUSH
33167: PPUSH
33168: PPUSH
33169: PPUSH
33170: PPUSH
33171: PPUSH
33172: PPUSH
33173: PPUSH
33174: PPUSH
33175: PPUSH
33176: PPUSH
33177: PPUSH
33178: PPUSH
33179: PPUSH
33180: PPUSH
33181: PPUSH
33182: PPUSH
33183: PPUSH
33184: PPUSH
33185: PPUSH
33186: PPUSH
33187: PPUSH
33188: PPUSH
33189: PPUSH
33190: PPUSH
33191: PPUSH
33192: PPUSH
33193: PPUSH
33194: PPUSH
33195: PPUSH
33196: PPUSH
33197: PPUSH
33198: PPUSH
33199: PPUSH
33200: PPUSH
33201: PPUSH
33202: PPUSH
33203: PPUSH
33204: PPUSH
33205: PPUSH
33206: PPUSH
33207: PPUSH
33208: PPUSH
33209: PPUSH
33210: PPUSH
33211: PPUSH
33212: PPUSH
33213: PPUSH
33214: PPUSH
33215: PPUSH
33216: PPUSH
33217: PPUSH
33218: PPUSH
33219: PPUSH
33220: PPUSH
33221: PPUSH
33222: PPUSH
33223: PPUSH
// result = [ ] ;
33224: LD_ADDR_VAR 0 7
33228: PUSH
33229: EMPTY
33230: ST_TO_ADDR
// temp_list = [ ] ;
33231: LD_ADDR_VAR 0 9
33235: PUSH
33236: EMPTY
33237: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
33238: LD_VAR 0 4
33242: PUSH
33243: LD_INT 0
33245: PUSH
33246: LD_INT 1
33248: PUSH
33249: LD_INT 2
33251: PUSH
33252: LD_INT 3
33254: PUSH
33255: LD_INT 4
33257: PUSH
33258: LD_INT 5
33260: PUSH
33261: EMPTY
33262: LIST
33263: LIST
33264: LIST
33265: LIST
33266: LIST
33267: LIST
33268: IN
33269: NOT
33270: PUSH
33271: LD_VAR 0 1
33275: PUSH
33276: LD_INT 0
33278: PUSH
33279: LD_INT 1
33281: PUSH
33282: EMPTY
33283: LIST
33284: LIST
33285: IN
33286: PUSH
33287: LD_VAR 0 5
33291: PUSH
33292: LD_INT 1
33294: PUSH
33295: LD_INT 2
33297: PUSH
33298: LD_INT 3
33300: PUSH
33301: EMPTY
33302: LIST
33303: LIST
33304: LIST
33305: IN
33306: NOT
33307: AND
33308: OR
33309: IFFALSE 33313
// exit ;
33311: GO 51704
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
33313: LD_VAR 0 1
33317: PUSH
33318: LD_INT 6
33320: PUSH
33321: LD_INT 7
33323: PUSH
33324: LD_INT 8
33326: PUSH
33327: LD_INT 13
33329: PUSH
33330: LD_INT 12
33332: PUSH
33333: LD_INT 15
33335: PUSH
33336: LD_INT 11
33338: PUSH
33339: LD_INT 14
33341: PUSH
33342: LD_INT 10
33344: PUSH
33345: EMPTY
33346: LIST
33347: LIST
33348: LIST
33349: LIST
33350: LIST
33351: LIST
33352: LIST
33353: LIST
33354: LIST
33355: IN
33356: IFFALSE 33366
// btype = b_lab ;
33358: LD_ADDR_VAR 0 1
33362: PUSH
33363: LD_INT 6
33365: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
33366: LD_VAR 0 6
33370: PUSH
33371: LD_INT 0
33373: PUSH
33374: LD_INT 1
33376: PUSH
33377: LD_INT 2
33379: PUSH
33380: EMPTY
33381: LIST
33382: LIST
33383: LIST
33384: IN
33385: NOT
33386: PUSH
33387: LD_VAR 0 1
33391: PUSH
33392: LD_INT 0
33394: PUSH
33395: LD_INT 1
33397: PUSH
33398: LD_INT 2
33400: PUSH
33401: LD_INT 3
33403: PUSH
33404: LD_INT 6
33406: PUSH
33407: LD_INT 36
33409: PUSH
33410: LD_INT 4
33412: PUSH
33413: LD_INT 5
33415: PUSH
33416: LD_INT 31
33418: PUSH
33419: LD_INT 32
33421: PUSH
33422: LD_INT 33
33424: PUSH
33425: EMPTY
33426: LIST
33427: LIST
33428: LIST
33429: LIST
33430: LIST
33431: LIST
33432: LIST
33433: LIST
33434: LIST
33435: LIST
33436: LIST
33437: IN
33438: NOT
33439: PUSH
33440: LD_VAR 0 6
33444: PUSH
33445: LD_INT 1
33447: EQUAL
33448: AND
33449: OR
33450: PUSH
33451: LD_VAR 0 1
33455: PUSH
33456: LD_INT 2
33458: PUSH
33459: LD_INT 3
33461: PUSH
33462: EMPTY
33463: LIST
33464: LIST
33465: IN
33466: NOT
33467: PUSH
33468: LD_VAR 0 6
33472: PUSH
33473: LD_INT 2
33475: EQUAL
33476: AND
33477: OR
33478: IFFALSE 33488
// mode = 0 ;
33480: LD_ADDR_VAR 0 6
33484: PUSH
33485: LD_INT 0
33487: ST_TO_ADDR
// case mode of 0 :
33488: LD_VAR 0 6
33492: PUSH
33493: LD_INT 0
33495: DOUBLE
33496: EQUAL
33497: IFTRUE 33501
33499: GO 44954
33501: POP
// begin fDepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
33502: LD_ADDR_VAR 0 11
33506: PUSH
33507: LD_INT 0
33509: PUSH
33510: LD_INT 0
33512: PUSH
33513: EMPTY
33514: LIST
33515: LIST
33516: PUSH
33517: LD_INT 0
33519: PUSH
33520: LD_INT 1
33522: NEG
33523: PUSH
33524: EMPTY
33525: LIST
33526: LIST
33527: PUSH
33528: LD_INT 1
33530: PUSH
33531: LD_INT 0
33533: PUSH
33534: EMPTY
33535: LIST
33536: LIST
33537: PUSH
33538: LD_INT 1
33540: PUSH
33541: LD_INT 1
33543: PUSH
33544: EMPTY
33545: LIST
33546: LIST
33547: PUSH
33548: LD_INT 0
33550: PUSH
33551: LD_INT 1
33553: PUSH
33554: EMPTY
33555: LIST
33556: LIST
33557: PUSH
33558: LD_INT 1
33560: NEG
33561: PUSH
33562: LD_INT 0
33564: PUSH
33565: EMPTY
33566: LIST
33567: LIST
33568: PUSH
33569: LD_INT 1
33571: NEG
33572: PUSH
33573: LD_INT 1
33575: NEG
33576: PUSH
33577: EMPTY
33578: LIST
33579: LIST
33580: PUSH
33581: LD_INT 1
33583: NEG
33584: PUSH
33585: LD_INT 2
33587: NEG
33588: PUSH
33589: EMPTY
33590: LIST
33591: LIST
33592: PUSH
33593: LD_INT 0
33595: PUSH
33596: LD_INT 2
33598: NEG
33599: PUSH
33600: EMPTY
33601: LIST
33602: LIST
33603: PUSH
33604: LD_INT 1
33606: PUSH
33607: LD_INT 1
33609: NEG
33610: PUSH
33611: EMPTY
33612: LIST
33613: LIST
33614: PUSH
33615: LD_INT 1
33617: PUSH
33618: LD_INT 2
33620: PUSH
33621: EMPTY
33622: LIST
33623: LIST
33624: PUSH
33625: LD_INT 0
33627: PUSH
33628: LD_INT 2
33630: PUSH
33631: EMPTY
33632: LIST
33633: LIST
33634: PUSH
33635: LD_INT 1
33637: NEG
33638: PUSH
33639: LD_INT 1
33641: PUSH
33642: EMPTY
33643: LIST
33644: LIST
33645: PUSH
33646: LD_INT 1
33648: PUSH
33649: LD_INT 3
33651: PUSH
33652: EMPTY
33653: LIST
33654: LIST
33655: PUSH
33656: LD_INT 0
33658: PUSH
33659: LD_INT 3
33661: PUSH
33662: EMPTY
33663: LIST
33664: LIST
33665: PUSH
33666: LD_INT 1
33668: NEG
33669: PUSH
33670: LD_INT 2
33672: PUSH
33673: EMPTY
33674: LIST
33675: LIST
33676: PUSH
33677: EMPTY
33678: LIST
33679: LIST
33680: LIST
33681: LIST
33682: LIST
33683: LIST
33684: LIST
33685: LIST
33686: LIST
33687: LIST
33688: LIST
33689: LIST
33690: LIST
33691: LIST
33692: LIST
33693: LIST
33694: ST_TO_ADDR
// fDepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
33695: LD_ADDR_VAR 0 12
33699: PUSH
33700: LD_INT 0
33702: PUSH
33703: LD_INT 0
33705: PUSH
33706: EMPTY
33707: LIST
33708: LIST
33709: PUSH
33710: LD_INT 0
33712: PUSH
33713: LD_INT 1
33715: NEG
33716: PUSH
33717: EMPTY
33718: LIST
33719: LIST
33720: PUSH
33721: LD_INT 1
33723: PUSH
33724: LD_INT 0
33726: PUSH
33727: EMPTY
33728: LIST
33729: LIST
33730: PUSH
33731: LD_INT 1
33733: PUSH
33734: LD_INT 1
33736: PUSH
33737: EMPTY
33738: LIST
33739: LIST
33740: PUSH
33741: LD_INT 0
33743: PUSH
33744: LD_INT 1
33746: PUSH
33747: EMPTY
33748: LIST
33749: LIST
33750: PUSH
33751: LD_INT 1
33753: NEG
33754: PUSH
33755: LD_INT 0
33757: PUSH
33758: EMPTY
33759: LIST
33760: LIST
33761: PUSH
33762: LD_INT 1
33764: NEG
33765: PUSH
33766: LD_INT 1
33768: NEG
33769: PUSH
33770: EMPTY
33771: LIST
33772: LIST
33773: PUSH
33774: LD_INT 1
33776: PUSH
33777: LD_INT 1
33779: NEG
33780: PUSH
33781: EMPTY
33782: LIST
33783: LIST
33784: PUSH
33785: LD_INT 2
33787: PUSH
33788: LD_INT 0
33790: PUSH
33791: EMPTY
33792: LIST
33793: LIST
33794: PUSH
33795: LD_INT 2
33797: PUSH
33798: LD_INT 1
33800: PUSH
33801: EMPTY
33802: LIST
33803: LIST
33804: PUSH
33805: LD_INT 1
33807: NEG
33808: PUSH
33809: LD_INT 1
33811: PUSH
33812: EMPTY
33813: LIST
33814: LIST
33815: PUSH
33816: LD_INT 2
33818: NEG
33819: PUSH
33820: LD_INT 0
33822: PUSH
33823: EMPTY
33824: LIST
33825: LIST
33826: PUSH
33827: LD_INT 2
33829: NEG
33830: PUSH
33831: LD_INT 1
33833: NEG
33834: PUSH
33835: EMPTY
33836: LIST
33837: LIST
33838: PUSH
33839: LD_INT 2
33841: NEG
33842: PUSH
33843: LD_INT 1
33845: PUSH
33846: EMPTY
33847: LIST
33848: LIST
33849: PUSH
33850: LD_INT 3
33852: NEG
33853: PUSH
33854: LD_INT 0
33856: PUSH
33857: EMPTY
33858: LIST
33859: LIST
33860: PUSH
33861: LD_INT 3
33863: NEG
33864: PUSH
33865: LD_INT 1
33867: NEG
33868: PUSH
33869: EMPTY
33870: LIST
33871: LIST
33872: PUSH
33873: EMPTY
33874: LIST
33875: LIST
33876: LIST
33877: LIST
33878: LIST
33879: LIST
33880: LIST
33881: LIST
33882: LIST
33883: LIST
33884: LIST
33885: LIST
33886: LIST
33887: LIST
33888: LIST
33889: LIST
33890: ST_TO_ADDR
// fDepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
33891: LD_ADDR_VAR 0 13
33895: PUSH
33896: LD_INT 0
33898: PUSH
33899: LD_INT 0
33901: PUSH
33902: EMPTY
33903: LIST
33904: LIST
33905: PUSH
33906: LD_INT 0
33908: PUSH
33909: LD_INT 1
33911: NEG
33912: PUSH
33913: EMPTY
33914: LIST
33915: LIST
33916: PUSH
33917: LD_INT 1
33919: PUSH
33920: LD_INT 0
33922: PUSH
33923: EMPTY
33924: LIST
33925: LIST
33926: PUSH
33927: LD_INT 1
33929: PUSH
33930: LD_INT 1
33932: PUSH
33933: EMPTY
33934: LIST
33935: LIST
33936: PUSH
33937: LD_INT 0
33939: PUSH
33940: LD_INT 1
33942: PUSH
33943: EMPTY
33944: LIST
33945: LIST
33946: PUSH
33947: LD_INT 1
33949: NEG
33950: PUSH
33951: LD_INT 0
33953: PUSH
33954: EMPTY
33955: LIST
33956: LIST
33957: PUSH
33958: LD_INT 1
33960: NEG
33961: PUSH
33962: LD_INT 1
33964: NEG
33965: PUSH
33966: EMPTY
33967: LIST
33968: LIST
33969: PUSH
33970: LD_INT 1
33972: NEG
33973: PUSH
33974: LD_INT 2
33976: NEG
33977: PUSH
33978: EMPTY
33979: LIST
33980: LIST
33981: PUSH
33982: LD_INT 2
33984: PUSH
33985: LD_INT 1
33987: PUSH
33988: EMPTY
33989: LIST
33990: LIST
33991: PUSH
33992: LD_INT 2
33994: PUSH
33995: LD_INT 2
33997: PUSH
33998: EMPTY
33999: LIST
34000: LIST
34001: PUSH
34002: LD_INT 1
34004: PUSH
34005: LD_INT 2
34007: PUSH
34008: EMPTY
34009: LIST
34010: LIST
34011: PUSH
34012: LD_INT 2
34014: NEG
34015: PUSH
34016: LD_INT 1
34018: NEG
34019: PUSH
34020: EMPTY
34021: LIST
34022: LIST
34023: PUSH
34024: LD_INT 2
34026: NEG
34027: PUSH
34028: LD_INT 2
34030: NEG
34031: PUSH
34032: EMPTY
34033: LIST
34034: LIST
34035: PUSH
34036: LD_INT 2
34038: NEG
34039: PUSH
34040: LD_INT 3
34042: NEG
34043: PUSH
34044: EMPTY
34045: LIST
34046: LIST
34047: PUSH
34048: LD_INT 3
34050: NEG
34051: PUSH
34052: LD_INT 2
34054: NEG
34055: PUSH
34056: EMPTY
34057: LIST
34058: LIST
34059: PUSH
34060: LD_INT 3
34062: NEG
34063: PUSH
34064: LD_INT 3
34066: NEG
34067: PUSH
34068: EMPTY
34069: LIST
34070: LIST
34071: PUSH
34072: EMPTY
34073: LIST
34074: LIST
34075: LIST
34076: LIST
34077: LIST
34078: LIST
34079: LIST
34080: LIST
34081: LIST
34082: LIST
34083: LIST
34084: LIST
34085: LIST
34086: LIST
34087: LIST
34088: LIST
34089: ST_TO_ADDR
// fDepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
34090: LD_ADDR_VAR 0 14
34094: PUSH
34095: LD_INT 0
34097: PUSH
34098: LD_INT 0
34100: PUSH
34101: EMPTY
34102: LIST
34103: LIST
34104: PUSH
34105: LD_INT 0
34107: PUSH
34108: LD_INT 1
34110: NEG
34111: PUSH
34112: EMPTY
34113: LIST
34114: LIST
34115: PUSH
34116: LD_INT 1
34118: PUSH
34119: LD_INT 0
34121: PUSH
34122: EMPTY
34123: LIST
34124: LIST
34125: PUSH
34126: LD_INT 1
34128: PUSH
34129: LD_INT 1
34131: PUSH
34132: EMPTY
34133: LIST
34134: LIST
34135: PUSH
34136: LD_INT 0
34138: PUSH
34139: LD_INT 1
34141: PUSH
34142: EMPTY
34143: LIST
34144: LIST
34145: PUSH
34146: LD_INT 1
34148: NEG
34149: PUSH
34150: LD_INT 0
34152: PUSH
34153: EMPTY
34154: LIST
34155: LIST
34156: PUSH
34157: LD_INT 1
34159: NEG
34160: PUSH
34161: LD_INT 1
34163: NEG
34164: PUSH
34165: EMPTY
34166: LIST
34167: LIST
34168: PUSH
34169: LD_INT 1
34171: NEG
34172: PUSH
34173: LD_INT 2
34175: NEG
34176: PUSH
34177: EMPTY
34178: LIST
34179: LIST
34180: PUSH
34181: LD_INT 0
34183: PUSH
34184: LD_INT 2
34186: NEG
34187: PUSH
34188: EMPTY
34189: LIST
34190: LIST
34191: PUSH
34192: LD_INT 1
34194: PUSH
34195: LD_INT 1
34197: NEG
34198: PUSH
34199: EMPTY
34200: LIST
34201: LIST
34202: PUSH
34203: LD_INT 1
34205: PUSH
34206: LD_INT 2
34208: PUSH
34209: EMPTY
34210: LIST
34211: LIST
34212: PUSH
34213: LD_INT 0
34215: PUSH
34216: LD_INT 2
34218: PUSH
34219: EMPTY
34220: LIST
34221: LIST
34222: PUSH
34223: LD_INT 1
34225: NEG
34226: PUSH
34227: LD_INT 1
34229: PUSH
34230: EMPTY
34231: LIST
34232: LIST
34233: PUSH
34234: LD_INT 1
34236: NEG
34237: PUSH
34238: LD_INT 3
34240: NEG
34241: PUSH
34242: EMPTY
34243: LIST
34244: LIST
34245: PUSH
34246: LD_INT 0
34248: PUSH
34249: LD_INT 3
34251: NEG
34252: PUSH
34253: EMPTY
34254: LIST
34255: LIST
34256: PUSH
34257: LD_INT 1
34259: PUSH
34260: LD_INT 2
34262: NEG
34263: PUSH
34264: EMPTY
34265: LIST
34266: LIST
34267: PUSH
34268: EMPTY
34269: LIST
34270: LIST
34271: LIST
34272: LIST
34273: LIST
34274: LIST
34275: LIST
34276: LIST
34277: LIST
34278: LIST
34279: LIST
34280: LIST
34281: LIST
34282: LIST
34283: LIST
34284: LIST
34285: ST_TO_ADDR
// fDepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
34286: LD_ADDR_VAR 0 15
34290: PUSH
34291: LD_INT 0
34293: PUSH
34294: LD_INT 0
34296: PUSH
34297: EMPTY
34298: LIST
34299: LIST
34300: PUSH
34301: LD_INT 0
34303: PUSH
34304: LD_INT 1
34306: NEG
34307: PUSH
34308: EMPTY
34309: LIST
34310: LIST
34311: PUSH
34312: LD_INT 1
34314: PUSH
34315: LD_INT 0
34317: PUSH
34318: EMPTY
34319: LIST
34320: LIST
34321: PUSH
34322: LD_INT 1
34324: PUSH
34325: LD_INT 1
34327: PUSH
34328: EMPTY
34329: LIST
34330: LIST
34331: PUSH
34332: LD_INT 0
34334: PUSH
34335: LD_INT 1
34337: PUSH
34338: EMPTY
34339: LIST
34340: LIST
34341: PUSH
34342: LD_INT 1
34344: NEG
34345: PUSH
34346: LD_INT 0
34348: PUSH
34349: EMPTY
34350: LIST
34351: LIST
34352: PUSH
34353: LD_INT 1
34355: NEG
34356: PUSH
34357: LD_INT 1
34359: NEG
34360: PUSH
34361: EMPTY
34362: LIST
34363: LIST
34364: PUSH
34365: LD_INT 1
34367: PUSH
34368: LD_INT 1
34370: NEG
34371: PUSH
34372: EMPTY
34373: LIST
34374: LIST
34375: PUSH
34376: LD_INT 2
34378: PUSH
34379: LD_INT 0
34381: PUSH
34382: EMPTY
34383: LIST
34384: LIST
34385: PUSH
34386: LD_INT 2
34388: PUSH
34389: LD_INT 1
34391: PUSH
34392: EMPTY
34393: LIST
34394: LIST
34395: PUSH
34396: LD_INT 1
34398: NEG
34399: PUSH
34400: LD_INT 1
34402: PUSH
34403: EMPTY
34404: LIST
34405: LIST
34406: PUSH
34407: LD_INT 2
34409: NEG
34410: PUSH
34411: LD_INT 0
34413: PUSH
34414: EMPTY
34415: LIST
34416: LIST
34417: PUSH
34418: LD_INT 2
34420: NEG
34421: PUSH
34422: LD_INT 1
34424: NEG
34425: PUSH
34426: EMPTY
34427: LIST
34428: LIST
34429: PUSH
34430: LD_INT 2
34432: PUSH
34433: LD_INT 1
34435: NEG
34436: PUSH
34437: EMPTY
34438: LIST
34439: LIST
34440: PUSH
34441: LD_INT 3
34443: PUSH
34444: LD_INT 0
34446: PUSH
34447: EMPTY
34448: LIST
34449: LIST
34450: PUSH
34451: LD_INT 3
34453: PUSH
34454: LD_INT 1
34456: PUSH
34457: EMPTY
34458: LIST
34459: LIST
34460: PUSH
34461: EMPTY
34462: LIST
34463: LIST
34464: LIST
34465: LIST
34466: LIST
34467: LIST
34468: LIST
34469: LIST
34470: LIST
34471: LIST
34472: LIST
34473: LIST
34474: LIST
34475: LIST
34476: LIST
34477: LIST
34478: ST_TO_ADDR
// fDepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
34479: LD_ADDR_VAR 0 16
34483: PUSH
34484: LD_INT 0
34486: PUSH
34487: LD_INT 0
34489: PUSH
34490: EMPTY
34491: LIST
34492: LIST
34493: PUSH
34494: LD_INT 0
34496: PUSH
34497: LD_INT 1
34499: NEG
34500: PUSH
34501: EMPTY
34502: LIST
34503: LIST
34504: PUSH
34505: LD_INT 1
34507: PUSH
34508: LD_INT 0
34510: PUSH
34511: EMPTY
34512: LIST
34513: LIST
34514: PUSH
34515: LD_INT 1
34517: PUSH
34518: LD_INT 1
34520: PUSH
34521: EMPTY
34522: LIST
34523: LIST
34524: PUSH
34525: LD_INT 0
34527: PUSH
34528: LD_INT 1
34530: PUSH
34531: EMPTY
34532: LIST
34533: LIST
34534: PUSH
34535: LD_INT 1
34537: NEG
34538: PUSH
34539: LD_INT 0
34541: PUSH
34542: EMPTY
34543: LIST
34544: LIST
34545: PUSH
34546: LD_INT 1
34548: NEG
34549: PUSH
34550: LD_INT 1
34552: NEG
34553: PUSH
34554: EMPTY
34555: LIST
34556: LIST
34557: PUSH
34558: LD_INT 1
34560: NEG
34561: PUSH
34562: LD_INT 2
34564: NEG
34565: PUSH
34566: EMPTY
34567: LIST
34568: LIST
34569: PUSH
34570: LD_INT 2
34572: PUSH
34573: LD_INT 1
34575: PUSH
34576: EMPTY
34577: LIST
34578: LIST
34579: PUSH
34580: LD_INT 2
34582: PUSH
34583: LD_INT 2
34585: PUSH
34586: EMPTY
34587: LIST
34588: LIST
34589: PUSH
34590: LD_INT 1
34592: PUSH
34593: LD_INT 2
34595: PUSH
34596: EMPTY
34597: LIST
34598: LIST
34599: PUSH
34600: LD_INT 2
34602: NEG
34603: PUSH
34604: LD_INT 1
34606: NEG
34607: PUSH
34608: EMPTY
34609: LIST
34610: LIST
34611: PUSH
34612: LD_INT 2
34614: NEG
34615: PUSH
34616: LD_INT 2
34618: NEG
34619: PUSH
34620: EMPTY
34621: LIST
34622: LIST
34623: PUSH
34624: LD_INT 3
34626: PUSH
34627: LD_INT 2
34629: PUSH
34630: EMPTY
34631: LIST
34632: LIST
34633: PUSH
34634: LD_INT 3
34636: PUSH
34637: LD_INT 3
34639: PUSH
34640: EMPTY
34641: LIST
34642: LIST
34643: PUSH
34644: LD_INT 2
34646: PUSH
34647: LD_INT 3
34649: PUSH
34650: EMPTY
34651: LIST
34652: LIST
34653: PUSH
34654: EMPTY
34655: LIST
34656: LIST
34657: LIST
34658: LIST
34659: LIST
34660: LIST
34661: LIST
34662: LIST
34663: LIST
34664: LIST
34665: LIST
34666: LIST
34667: LIST
34668: LIST
34669: LIST
34670: LIST
34671: ST_TO_ADDR
// fDepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
34672: LD_ADDR_VAR 0 17
34676: PUSH
34677: LD_INT 0
34679: PUSH
34680: LD_INT 0
34682: PUSH
34683: EMPTY
34684: LIST
34685: LIST
34686: PUSH
34687: LD_INT 0
34689: PUSH
34690: LD_INT 1
34692: NEG
34693: PUSH
34694: EMPTY
34695: LIST
34696: LIST
34697: PUSH
34698: LD_INT 1
34700: PUSH
34701: LD_INT 0
34703: PUSH
34704: EMPTY
34705: LIST
34706: LIST
34707: PUSH
34708: LD_INT 1
34710: PUSH
34711: LD_INT 1
34713: PUSH
34714: EMPTY
34715: LIST
34716: LIST
34717: PUSH
34718: LD_INT 0
34720: PUSH
34721: LD_INT 1
34723: PUSH
34724: EMPTY
34725: LIST
34726: LIST
34727: PUSH
34728: LD_INT 1
34730: NEG
34731: PUSH
34732: LD_INT 0
34734: PUSH
34735: EMPTY
34736: LIST
34737: LIST
34738: PUSH
34739: LD_INT 1
34741: NEG
34742: PUSH
34743: LD_INT 1
34745: NEG
34746: PUSH
34747: EMPTY
34748: LIST
34749: LIST
34750: PUSH
34751: LD_INT 1
34753: NEG
34754: PUSH
34755: LD_INT 2
34757: NEG
34758: PUSH
34759: EMPTY
34760: LIST
34761: LIST
34762: PUSH
34763: LD_INT 0
34765: PUSH
34766: LD_INT 2
34768: NEG
34769: PUSH
34770: EMPTY
34771: LIST
34772: LIST
34773: PUSH
34774: LD_INT 1
34776: PUSH
34777: LD_INT 1
34779: NEG
34780: PUSH
34781: EMPTY
34782: LIST
34783: LIST
34784: PUSH
34785: LD_INT 2
34787: PUSH
34788: LD_INT 0
34790: PUSH
34791: EMPTY
34792: LIST
34793: LIST
34794: PUSH
34795: LD_INT 2
34797: PUSH
34798: LD_INT 1
34800: PUSH
34801: EMPTY
34802: LIST
34803: LIST
34804: PUSH
34805: LD_INT 2
34807: PUSH
34808: LD_INT 2
34810: PUSH
34811: EMPTY
34812: LIST
34813: LIST
34814: PUSH
34815: LD_INT 1
34817: PUSH
34818: LD_INT 2
34820: PUSH
34821: EMPTY
34822: LIST
34823: LIST
34824: PUSH
34825: LD_INT 0
34827: PUSH
34828: LD_INT 2
34830: PUSH
34831: EMPTY
34832: LIST
34833: LIST
34834: PUSH
34835: LD_INT 1
34837: NEG
34838: PUSH
34839: LD_INT 1
34841: PUSH
34842: EMPTY
34843: LIST
34844: LIST
34845: PUSH
34846: LD_INT 2
34848: NEG
34849: PUSH
34850: LD_INT 0
34852: PUSH
34853: EMPTY
34854: LIST
34855: LIST
34856: PUSH
34857: LD_INT 2
34859: NEG
34860: PUSH
34861: LD_INT 1
34863: NEG
34864: PUSH
34865: EMPTY
34866: LIST
34867: LIST
34868: PUSH
34869: LD_INT 2
34871: NEG
34872: PUSH
34873: LD_INT 2
34875: NEG
34876: PUSH
34877: EMPTY
34878: LIST
34879: LIST
34880: PUSH
34881: EMPTY
34882: LIST
34883: LIST
34884: LIST
34885: LIST
34886: LIST
34887: LIST
34888: LIST
34889: LIST
34890: LIST
34891: LIST
34892: LIST
34893: LIST
34894: LIST
34895: LIST
34896: LIST
34897: LIST
34898: LIST
34899: LIST
34900: LIST
34901: ST_TO_ADDR
// fDepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
34902: LD_ADDR_VAR 0 18
34906: PUSH
34907: LD_INT 0
34909: PUSH
34910: LD_INT 0
34912: PUSH
34913: EMPTY
34914: LIST
34915: LIST
34916: PUSH
34917: LD_INT 0
34919: PUSH
34920: LD_INT 1
34922: NEG
34923: PUSH
34924: EMPTY
34925: LIST
34926: LIST
34927: PUSH
34928: LD_INT 1
34930: PUSH
34931: LD_INT 0
34933: PUSH
34934: EMPTY
34935: LIST
34936: LIST
34937: PUSH
34938: LD_INT 1
34940: PUSH
34941: LD_INT 1
34943: PUSH
34944: EMPTY
34945: LIST
34946: LIST
34947: PUSH
34948: LD_INT 0
34950: PUSH
34951: LD_INT 1
34953: PUSH
34954: EMPTY
34955: LIST
34956: LIST
34957: PUSH
34958: LD_INT 1
34960: NEG
34961: PUSH
34962: LD_INT 0
34964: PUSH
34965: EMPTY
34966: LIST
34967: LIST
34968: PUSH
34969: LD_INT 1
34971: NEG
34972: PUSH
34973: LD_INT 1
34975: NEG
34976: PUSH
34977: EMPTY
34978: LIST
34979: LIST
34980: PUSH
34981: LD_INT 1
34983: NEG
34984: PUSH
34985: LD_INT 2
34987: NEG
34988: PUSH
34989: EMPTY
34990: LIST
34991: LIST
34992: PUSH
34993: LD_INT 0
34995: PUSH
34996: LD_INT 2
34998: NEG
34999: PUSH
35000: EMPTY
35001: LIST
35002: LIST
35003: PUSH
35004: LD_INT 1
35006: PUSH
35007: LD_INT 1
35009: NEG
35010: PUSH
35011: EMPTY
35012: LIST
35013: LIST
35014: PUSH
35015: LD_INT 2
35017: PUSH
35018: LD_INT 0
35020: PUSH
35021: EMPTY
35022: LIST
35023: LIST
35024: PUSH
35025: LD_INT 2
35027: PUSH
35028: LD_INT 1
35030: PUSH
35031: EMPTY
35032: LIST
35033: LIST
35034: PUSH
35035: LD_INT 2
35037: PUSH
35038: LD_INT 2
35040: PUSH
35041: EMPTY
35042: LIST
35043: LIST
35044: PUSH
35045: LD_INT 1
35047: PUSH
35048: LD_INT 2
35050: PUSH
35051: EMPTY
35052: LIST
35053: LIST
35054: PUSH
35055: LD_INT 0
35057: PUSH
35058: LD_INT 2
35060: PUSH
35061: EMPTY
35062: LIST
35063: LIST
35064: PUSH
35065: LD_INT 1
35067: NEG
35068: PUSH
35069: LD_INT 1
35071: PUSH
35072: EMPTY
35073: LIST
35074: LIST
35075: PUSH
35076: LD_INT 2
35078: NEG
35079: PUSH
35080: LD_INT 0
35082: PUSH
35083: EMPTY
35084: LIST
35085: LIST
35086: PUSH
35087: LD_INT 2
35089: NEG
35090: PUSH
35091: LD_INT 1
35093: NEG
35094: PUSH
35095: EMPTY
35096: LIST
35097: LIST
35098: PUSH
35099: LD_INT 2
35101: NEG
35102: PUSH
35103: LD_INT 2
35105: NEG
35106: PUSH
35107: EMPTY
35108: LIST
35109: LIST
35110: PUSH
35111: EMPTY
35112: LIST
35113: LIST
35114: LIST
35115: LIST
35116: LIST
35117: LIST
35118: LIST
35119: LIST
35120: LIST
35121: LIST
35122: LIST
35123: LIST
35124: LIST
35125: LIST
35126: LIST
35127: LIST
35128: LIST
35129: LIST
35130: LIST
35131: ST_TO_ADDR
// fDepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
35132: LD_ADDR_VAR 0 19
35136: PUSH
35137: LD_INT 0
35139: PUSH
35140: LD_INT 0
35142: PUSH
35143: EMPTY
35144: LIST
35145: LIST
35146: PUSH
35147: LD_INT 0
35149: PUSH
35150: LD_INT 1
35152: NEG
35153: PUSH
35154: EMPTY
35155: LIST
35156: LIST
35157: PUSH
35158: LD_INT 1
35160: PUSH
35161: LD_INT 0
35163: PUSH
35164: EMPTY
35165: LIST
35166: LIST
35167: PUSH
35168: LD_INT 1
35170: PUSH
35171: LD_INT 1
35173: PUSH
35174: EMPTY
35175: LIST
35176: LIST
35177: PUSH
35178: LD_INT 0
35180: PUSH
35181: LD_INT 1
35183: PUSH
35184: EMPTY
35185: LIST
35186: LIST
35187: PUSH
35188: LD_INT 1
35190: NEG
35191: PUSH
35192: LD_INT 0
35194: PUSH
35195: EMPTY
35196: LIST
35197: LIST
35198: PUSH
35199: LD_INT 1
35201: NEG
35202: PUSH
35203: LD_INT 1
35205: NEG
35206: PUSH
35207: EMPTY
35208: LIST
35209: LIST
35210: PUSH
35211: LD_INT 1
35213: NEG
35214: PUSH
35215: LD_INT 2
35217: NEG
35218: PUSH
35219: EMPTY
35220: LIST
35221: LIST
35222: PUSH
35223: LD_INT 0
35225: PUSH
35226: LD_INT 2
35228: NEG
35229: PUSH
35230: EMPTY
35231: LIST
35232: LIST
35233: PUSH
35234: LD_INT 1
35236: PUSH
35237: LD_INT 1
35239: NEG
35240: PUSH
35241: EMPTY
35242: LIST
35243: LIST
35244: PUSH
35245: LD_INT 2
35247: PUSH
35248: LD_INT 0
35250: PUSH
35251: EMPTY
35252: LIST
35253: LIST
35254: PUSH
35255: LD_INT 2
35257: PUSH
35258: LD_INT 1
35260: PUSH
35261: EMPTY
35262: LIST
35263: LIST
35264: PUSH
35265: LD_INT 2
35267: PUSH
35268: LD_INT 2
35270: PUSH
35271: EMPTY
35272: LIST
35273: LIST
35274: PUSH
35275: LD_INT 1
35277: PUSH
35278: LD_INT 2
35280: PUSH
35281: EMPTY
35282: LIST
35283: LIST
35284: PUSH
35285: LD_INT 0
35287: PUSH
35288: LD_INT 2
35290: PUSH
35291: EMPTY
35292: LIST
35293: LIST
35294: PUSH
35295: LD_INT 1
35297: NEG
35298: PUSH
35299: LD_INT 1
35301: PUSH
35302: EMPTY
35303: LIST
35304: LIST
35305: PUSH
35306: LD_INT 2
35308: NEG
35309: PUSH
35310: LD_INT 0
35312: PUSH
35313: EMPTY
35314: LIST
35315: LIST
35316: PUSH
35317: LD_INT 2
35319: NEG
35320: PUSH
35321: LD_INT 1
35323: NEG
35324: PUSH
35325: EMPTY
35326: LIST
35327: LIST
35328: PUSH
35329: LD_INT 2
35331: NEG
35332: PUSH
35333: LD_INT 2
35335: NEG
35336: PUSH
35337: EMPTY
35338: LIST
35339: LIST
35340: PUSH
35341: EMPTY
35342: LIST
35343: LIST
35344: LIST
35345: LIST
35346: LIST
35347: LIST
35348: LIST
35349: LIST
35350: LIST
35351: LIST
35352: LIST
35353: LIST
35354: LIST
35355: LIST
35356: LIST
35357: LIST
35358: LIST
35359: LIST
35360: LIST
35361: ST_TO_ADDR
// fDepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
35362: LD_ADDR_VAR 0 20
35366: PUSH
35367: LD_INT 0
35369: PUSH
35370: LD_INT 0
35372: PUSH
35373: EMPTY
35374: LIST
35375: LIST
35376: PUSH
35377: LD_INT 0
35379: PUSH
35380: LD_INT 1
35382: NEG
35383: PUSH
35384: EMPTY
35385: LIST
35386: LIST
35387: PUSH
35388: LD_INT 1
35390: PUSH
35391: LD_INT 0
35393: PUSH
35394: EMPTY
35395: LIST
35396: LIST
35397: PUSH
35398: LD_INT 1
35400: PUSH
35401: LD_INT 1
35403: PUSH
35404: EMPTY
35405: LIST
35406: LIST
35407: PUSH
35408: LD_INT 0
35410: PUSH
35411: LD_INT 1
35413: PUSH
35414: EMPTY
35415: LIST
35416: LIST
35417: PUSH
35418: LD_INT 1
35420: NEG
35421: PUSH
35422: LD_INT 0
35424: PUSH
35425: EMPTY
35426: LIST
35427: LIST
35428: PUSH
35429: LD_INT 1
35431: NEG
35432: PUSH
35433: LD_INT 1
35435: NEG
35436: PUSH
35437: EMPTY
35438: LIST
35439: LIST
35440: PUSH
35441: LD_INT 1
35443: NEG
35444: PUSH
35445: LD_INT 2
35447: NEG
35448: PUSH
35449: EMPTY
35450: LIST
35451: LIST
35452: PUSH
35453: LD_INT 0
35455: PUSH
35456: LD_INT 2
35458: NEG
35459: PUSH
35460: EMPTY
35461: LIST
35462: LIST
35463: PUSH
35464: LD_INT 1
35466: PUSH
35467: LD_INT 1
35469: NEG
35470: PUSH
35471: EMPTY
35472: LIST
35473: LIST
35474: PUSH
35475: LD_INT 2
35477: PUSH
35478: LD_INT 0
35480: PUSH
35481: EMPTY
35482: LIST
35483: LIST
35484: PUSH
35485: LD_INT 2
35487: PUSH
35488: LD_INT 1
35490: PUSH
35491: EMPTY
35492: LIST
35493: LIST
35494: PUSH
35495: LD_INT 2
35497: PUSH
35498: LD_INT 2
35500: PUSH
35501: EMPTY
35502: LIST
35503: LIST
35504: PUSH
35505: LD_INT 1
35507: PUSH
35508: LD_INT 2
35510: PUSH
35511: EMPTY
35512: LIST
35513: LIST
35514: PUSH
35515: LD_INT 0
35517: PUSH
35518: LD_INT 2
35520: PUSH
35521: EMPTY
35522: LIST
35523: LIST
35524: PUSH
35525: LD_INT 1
35527: NEG
35528: PUSH
35529: LD_INT 1
35531: PUSH
35532: EMPTY
35533: LIST
35534: LIST
35535: PUSH
35536: LD_INT 2
35538: NEG
35539: PUSH
35540: LD_INT 0
35542: PUSH
35543: EMPTY
35544: LIST
35545: LIST
35546: PUSH
35547: LD_INT 2
35549: NEG
35550: PUSH
35551: LD_INT 1
35553: NEG
35554: PUSH
35555: EMPTY
35556: LIST
35557: LIST
35558: PUSH
35559: LD_INT 2
35561: NEG
35562: PUSH
35563: LD_INT 2
35565: NEG
35566: PUSH
35567: EMPTY
35568: LIST
35569: LIST
35570: PUSH
35571: EMPTY
35572: LIST
35573: LIST
35574: LIST
35575: LIST
35576: LIST
35577: LIST
35578: LIST
35579: LIST
35580: LIST
35581: LIST
35582: LIST
35583: LIST
35584: LIST
35585: LIST
35586: LIST
35587: LIST
35588: LIST
35589: LIST
35590: LIST
35591: ST_TO_ADDR
// fDepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
35592: LD_ADDR_VAR 0 21
35596: PUSH
35597: LD_INT 0
35599: PUSH
35600: LD_INT 0
35602: PUSH
35603: EMPTY
35604: LIST
35605: LIST
35606: PUSH
35607: LD_INT 0
35609: PUSH
35610: LD_INT 1
35612: NEG
35613: PUSH
35614: EMPTY
35615: LIST
35616: LIST
35617: PUSH
35618: LD_INT 1
35620: PUSH
35621: LD_INT 0
35623: PUSH
35624: EMPTY
35625: LIST
35626: LIST
35627: PUSH
35628: LD_INT 1
35630: PUSH
35631: LD_INT 1
35633: PUSH
35634: EMPTY
35635: LIST
35636: LIST
35637: PUSH
35638: LD_INT 0
35640: PUSH
35641: LD_INT 1
35643: PUSH
35644: EMPTY
35645: LIST
35646: LIST
35647: PUSH
35648: LD_INT 1
35650: NEG
35651: PUSH
35652: LD_INT 0
35654: PUSH
35655: EMPTY
35656: LIST
35657: LIST
35658: PUSH
35659: LD_INT 1
35661: NEG
35662: PUSH
35663: LD_INT 1
35665: NEG
35666: PUSH
35667: EMPTY
35668: LIST
35669: LIST
35670: PUSH
35671: LD_INT 1
35673: NEG
35674: PUSH
35675: LD_INT 2
35677: NEG
35678: PUSH
35679: EMPTY
35680: LIST
35681: LIST
35682: PUSH
35683: LD_INT 0
35685: PUSH
35686: LD_INT 2
35688: NEG
35689: PUSH
35690: EMPTY
35691: LIST
35692: LIST
35693: PUSH
35694: LD_INT 1
35696: PUSH
35697: LD_INT 1
35699: NEG
35700: PUSH
35701: EMPTY
35702: LIST
35703: LIST
35704: PUSH
35705: LD_INT 2
35707: PUSH
35708: LD_INT 0
35710: PUSH
35711: EMPTY
35712: LIST
35713: LIST
35714: PUSH
35715: LD_INT 2
35717: PUSH
35718: LD_INT 1
35720: PUSH
35721: EMPTY
35722: LIST
35723: LIST
35724: PUSH
35725: LD_INT 2
35727: PUSH
35728: LD_INT 2
35730: PUSH
35731: EMPTY
35732: LIST
35733: LIST
35734: PUSH
35735: LD_INT 1
35737: PUSH
35738: LD_INT 2
35740: PUSH
35741: EMPTY
35742: LIST
35743: LIST
35744: PUSH
35745: LD_INT 0
35747: PUSH
35748: LD_INT 2
35750: PUSH
35751: EMPTY
35752: LIST
35753: LIST
35754: PUSH
35755: LD_INT 1
35757: NEG
35758: PUSH
35759: LD_INT 1
35761: PUSH
35762: EMPTY
35763: LIST
35764: LIST
35765: PUSH
35766: LD_INT 2
35768: NEG
35769: PUSH
35770: LD_INT 0
35772: PUSH
35773: EMPTY
35774: LIST
35775: LIST
35776: PUSH
35777: LD_INT 2
35779: NEG
35780: PUSH
35781: LD_INT 1
35783: NEG
35784: PUSH
35785: EMPTY
35786: LIST
35787: LIST
35788: PUSH
35789: LD_INT 2
35791: NEG
35792: PUSH
35793: LD_INT 2
35795: NEG
35796: PUSH
35797: EMPTY
35798: LIST
35799: LIST
35800: PUSH
35801: EMPTY
35802: LIST
35803: LIST
35804: LIST
35805: LIST
35806: LIST
35807: LIST
35808: LIST
35809: LIST
35810: LIST
35811: LIST
35812: LIST
35813: LIST
35814: LIST
35815: LIST
35816: LIST
35817: LIST
35818: LIST
35819: LIST
35820: LIST
35821: ST_TO_ADDR
// fDepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
35822: LD_ADDR_VAR 0 22
35826: PUSH
35827: LD_INT 0
35829: PUSH
35830: LD_INT 0
35832: PUSH
35833: EMPTY
35834: LIST
35835: LIST
35836: PUSH
35837: LD_INT 0
35839: PUSH
35840: LD_INT 1
35842: NEG
35843: PUSH
35844: EMPTY
35845: LIST
35846: LIST
35847: PUSH
35848: LD_INT 1
35850: PUSH
35851: LD_INT 0
35853: PUSH
35854: EMPTY
35855: LIST
35856: LIST
35857: PUSH
35858: LD_INT 1
35860: PUSH
35861: LD_INT 1
35863: PUSH
35864: EMPTY
35865: LIST
35866: LIST
35867: PUSH
35868: LD_INT 0
35870: PUSH
35871: LD_INT 1
35873: PUSH
35874: EMPTY
35875: LIST
35876: LIST
35877: PUSH
35878: LD_INT 1
35880: NEG
35881: PUSH
35882: LD_INT 0
35884: PUSH
35885: EMPTY
35886: LIST
35887: LIST
35888: PUSH
35889: LD_INT 1
35891: NEG
35892: PUSH
35893: LD_INT 1
35895: NEG
35896: PUSH
35897: EMPTY
35898: LIST
35899: LIST
35900: PUSH
35901: LD_INT 1
35903: NEG
35904: PUSH
35905: LD_INT 2
35907: NEG
35908: PUSH
35909: EMPTY
35910: LIST
35911: LIST
35912: PUSH
35913: LD_INT 0
35915: PUSH
35916: LD_INT 2
35918: NEG
35919: PUSH
35920: EMPTY
35921: LIST
35922: LIST
35923: PUSH
35924: LD_INT 1
35926: PUSH
35927: LD_INT 1
35929: NEG
35930: PUSH
35931: EMPTY
35932: LIST
35933: LIST
35934: PUSH
35935: LD_INT 2
35937: PUSH
35938: LD_INT 0
35940: PUSH
35941: EMPTY
35942: LIST
35943: LIST
35944: PUSH
35945: LD_INT 2
35947: PUSH
35948: LD_INT 1
35950: PUSH
35951: EMPTY
35952: LIST
35953: LIST
35954: PUSH
35955: LD_INT 2
35957: PUSH
35958: LD_INT 2
35960: PUSH
35961: EMPTY
35962: LIST
35963: LIST
35964: PUSH
35965: LD_INT 1
35967: PUSH
35968: LD_INT 2
35970: PUSH
35971: EMPTY
35972: LIST
35973: LIST
35974: PUSH
35975: LD_INT 0
35977: PUSH
35978: LD_INT 2
35980: PUSH
35981: EMPTY
35982: LIST
35983: LIST
35984: PUSH
35985: LD_INT 1
35987: NEG
35988: PUSH
35989: LD_INT 1
35991: PUSH
35992: EMPTY
35993: LIST
35994: LIST
35995: PUSH
35996: LD_INT 2
35998: NEG
35999: PUSH
36000: LD_INT 0
36002: PUSH
36003: EMPTY
36004: LIST
36005: LIST
36006: PUSH
36007: LD_INT 2
36009: NEG
36010: PUSH
36011: LD_INT 1
36013: NEG
36014: PUSH
36015: EMPTY
36016: LIST
36017: LIST
36018: PUSH
36019: LD_INT 2
36021: NEG
36022: PUSH
36023: LD_INT 2
36025: NEG
36026: PUSH
36027: EMPTY
36028: LIST
36029: LIST
36030: PUSH
36031: EMPTY
36032: LIST
36033: LIST
36034: LIST
36035: LIST
36036: LIST
36037: LIST
36038: LIST
36039: LIST
36040: LIST
36041: LIST
36042: LIST
36043: LIST
36044: LIST
36045: LIST
36046: LIST
36047: LIST
36048: LIST
36049: LIST
36050: LIST
36051: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
36052: LD_ADDR_VAR 0 23
36056: PUSH
36057: LD_INT 0
36059: PUSH
36060: LD_INT 0
36062: PUSH
36063: EMPTY
36064: LIST
36065: LIST
36066: PUSH
36067: LD_INT 0
36069: PUSH
36070: LD_INT 1
36072: NEG
36073: PUSH
36074: EMPTY
36075: LIST
36076: LIST
36077: PUSH
36078: LD_INT 1
36080: PUSH
36081: LD_INT 0
36083: PUSH
36084: EMPTY
36085: LIST
36086: LIST
36087: PUSH
36088: LD_INT 1
36090: PUSH
36091: LD_INT 1
36093: PUSH
36094: EMPTY
36095: LIST
36096: LIST
36097: PUSH
36098: LD_INT 0
36100: PUSH
36101: LD_INT 1
36103: PUSH
36104: EMPTY
36105: LIST
36106: LIST
36107: PUSH
36108: LD_INT 1
36110: NEG
36111: PUSH
36112: LD_INT 0
36114: PUSH
36115: EMPTY
36116: LIST
36117: LIST
36118: PUSH
36119: LD_INT 1
36121: NEG
36122: PUSH
36123: LD_INT 1
36125: NEG
36126: PUSH
36127: EMPTY
36128: LIST
36129: LIST
36130: PUSH
36131: LD_INT 1
36133: NEG
36134: PUSH
36135: LD_INT 2
36137: NEG
36138: PUSH
36139: EMPTY
36140: LIST
36141: LIST
36142: PUSH
36143: LD_INT 0
36145: PUSH
36146: LD_INT 2
36148: NEG
36149: PUSH
36150: EMPTY
36151: LIST
36152: LIST
36153: PUSH
36154: LD_INT 1
36156: PUSH
36157: LD_INT 1
36159: NEG
36160: PUSH
36161: EMPTY
36162: LIST
36163: LIST
36164: PUSH
36165: LD_INT 2
36167: PUSH
36168: LD_INT 0
36170: PUSH
36171: EMPTY
36172: LIST
36173: LIST
36174: PUSH
36175: LD_INT 2
36177: PUSH
36178: LD_INT 1
36180: PUSH
36181: EMPTY
36182: LIST
36183: LIST
36184: PUSH
36185: LD_INT 2
36187: PUSH
36188: LD_INT 2
36190: PUSH
36191: EMPTY
36192: LIST
36193: LIST
36194: PUSH
36195: LD_INT 1
36197: PUSH
36198: LD_INT 2
36200: PUSH
36201: EMPTY
36202: LIST
36203: LIST
36204: PUSH
36205: LD_INT 0
36207: PUSH
36208: LD_INT 2
36210: PUSH
36211: EMPTY
36212: LIST
36213: LIST
36214: PUSH
36215: LD_INT 1
36217: NEG
36218: PUSH
36219: LD_INT 1
36221: PUSH
36222: EMPTY
36223: LIST
36224: LIST
36225: PUSH
36226: LD_INT 2
36228: NEG
36229: PUSH
36230: LD_INT 0
36232: PUSH
36233: EMPTY
36234: LIST
36235: LIST
36236: PUSH
36237: LD_INT 2
36239: NEG
36240: PUSH
36241: LD_INT 1
36243: NEG
36244: PUSH
36245: EMPTY
36246: LIST
36247: LIST
36248: PUSH
36249: LD_INT 2
36251: NEG
36252: PUSH
36253: LD_INT 2
36255: NEG
36256: PUSH
36257: EMPTY
36258: LIST
36259: LIST
36260: PUSH
36261: LD_INT 2
36263: NEG
36264: PUSH
36265: LD_INT 3
36267: NEG
36268: PUSH
36269: EMPTY
36270: LIST
36271: LIST
36272: PUSH
36273: LD_INT 1
36275: NEG
36276: PUSH
36277: LD_INT 3
36279: NEG
36280: PUSH
36281: EMPTY
36282: LIST
36283: LIST
36284: PUSH
36285: LD_INT 1
36287: PUSH
36288: LD_INT 2
36290: NEG
36291: PUSH
36292: EMPTY
36293: LIST
36294: LIST
36295: PUSH
36296: LD_INT 2
36298: PUSH
36299: LD_INT 1
36301: NEG
36302: PUSH
36303: EMPTY
36304: LIST
36305: LIST
36306: PUSH
36307: EMPTY
36308: LIST
36309: LIST
36310: LIST
36311: LIST
36312: LIST
36313: LIST
36314: LIST
36315: LIST
36316: LIST
36317: LIST
36318: LIST
36319: LIST
36320: LIST
36321: LIST
36322: LIST
36323: LIST
36324: LIST
36325: LIST
36326: LIST
36327: LIST
36328: LIST
36329: LIST
36330: LIST
36331: ST_TO_ADDR
// fDepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
36332: LD_ADDR_VAR 0 24
36336: PUSH
36337: LD_INT 0
36339: PUSH
36340: LD_INT 0
36342: PUSH
36343: EMPTY
36344: LIST
36345: LIST
36346: PUSH
36347: LD_INT 0
36349: PUSH
36350: LD_INT 1
36352: NEG
36353: PUSH
36354: EMPTY
36355: LIST
36356: LIST
36357: PUSH
36358: LD_INT 1
36360: PUSH
36361: LD_INT 0
36363: PUSH
36364: EMPTY
36365: LIST
36366: LIST
36367: PUSH
36368: LD_INT 1
36370: PUSH
36371: LD_INT 1
36373: PUSH
36374: EMPTY
36375: LIST
36376: LIST
36377: PUSH
36378: LD_INT 0
36380: PUSH
36381: LD_INT 1
36383: PUSH
36384: EMPTY
36385: LIST
36386: LIST
36387: PUSH
36388: LD_INT 1
36390: NEG
36391: PUSH
36392: LD_INT 0
36394: PUSH
36395: EMPTY
36396: LIST
36397: LIST
36398: PUSH
36399: LD_INT 1
36401: NEG
36402: PUSH
36403: LD_INT 1
36405: NEG
36406: PUSH
36407: EMPTY
36408: LIST
36409: LIST
36410: PUSH
36411: LD_INT 1
36413: NEG
36414: PUSH
36415: LD_INT 2
36417: NEG
36418: PUSH
36419: EMPTY
36420: LIST
36421: LIST
36422: PUSH
36423: LD_INT 0
36425: PUSH
36426: LD_INT 2
36428: NEG
36429: PUSH
36430: EMPTY
36431: LIST
36432: LIST
36433: PUSH
36434: LD_INT 1
36436: PUSH
36437: LD_INT 1
36439: NEG
36440: PUSH
36441: EMPTY
36442: LIST
36443: LIST
36444: PUSH
36445: LD_INT 2
36447: PUSH
36448: LD_INT 0
36450: PUSH
36451: EMPTY
36452: LIST
36453: LIST
36454: PUSH
36455: LD_INT 2
36457: PUSH
36458: LD_INT 1
36460: PUSH
36461: EMPTY
36462: LIST
36463: LIST
36464: PUSH
36465: LD_INT 2
36467: PUSH
36468: LD_INT 2
36470: PUSH
36471: EMPTY
36472: LIST
36473: LIST
36474: PUSH
36475: LD_INT 1
36477: PUSH
36478: LD_INT 2
36480: PUSH
36481: EMPTY
36482: LIST
36483: LIST
36484: PUSH
36485: LD_INT 0
36487: PUSH
36488: LD_INT 2
36490: PUSH
36491: EMPTY
36492: LIST
36493: LIST
36494: PUSH
36495: LD_INT 1
36497: NEG
36498: PUSH
36499: LD_INT 1
36501: PUSH
36502: EMPTY
36503: LIST
36504: LIST
36505: PUSH
36506: LD_INT 2
36508: NEG
36509: PUSH
36510: LD_INT 0
36512: PUSH
36513: EMPTY
36514: LIST
36515: LIST
36516: PUSH
36517: LD_INT 2
36519: NEG
36520: PUSH
36521: LD_INT 1
36523: NEG
36524: PUSH
36525: EMPTY
36526: LIST
36527: LIST
36528: PUSH
36529: LD_INT 2
36531: NEG
36532: PUSH
36533: LD_INT 2
36535: NEG
36536: PUSH
36537: EMPTY
36538: LIST
36539: LIST
36540: PUSH
36541: LD_INT 1
36543: PUSH
36544: LD_INT 2
36546: NEG
36547: PUSH
36548: EMPTY
36549: LIST
36550: LIST
36551: PUSH
36552: LD_INT 2
36554: PUSH
36555: LD_INT 1
36557: NEG
36558: PUSH
36559: EMPTY
36560: LIST
36561: LIST
36562: PUSH
36563: LD_INT 3
36565: PUSH
36566: LD_INT 1
36568: PUSH
36569: EMPTY
36570: LIST
36571: LIST
36572: PUSH
36573: LD_INT 3
36575: PUSH
36576: LD_INT 2
36578: PUSH
36579: EMPTY
36580: LIST
36581: LIST
36582: PUSH
36583: EMPTY
36584: LIST
36585: LIST
36586: LIST
36587: LIST
36588: LIST
36589: LIST
36590: LIST
36591: LIST
36592: LIST
36593: LIST
36594: LIST
36595: LIST
36596: LIST
36597: LIST
36598: LIST
36599: LIST
36600: LIST
36601: LIST
36602: LIST
36603: LIST
36604: LIST
36605: LIST
36606: LIST
36607: ST_TO_ADDR
// fDepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
36608: LD_ADDR_VAR 0 25
36612: PUSH
36613: LD_INT 0
36615: PUSH
36616: LD_INT 0
36618: PUSH
36619: EMPTY
36620: LIST
36621: LIST
36622: PUSH
36623: LD_INT 0
36625: PUSH
36626: LD_INT 1
36628: NEG
36629: PUSH
36630: EMPTY
36631: LIST
36632: LIST
36633: PUSH
36634: LD_INT 1
36636: PUSH
36637: LD_INT 0
36639: PUSH
36640: EMPTY
36641: LIST
36642: LIST
36643: PUSH
36644: LD_INT 1
36646: PUSH
36647: LD_INT 1
36649: PUSH
36650: EMPTY
36651: LIST
36652: LIST
36653: PUSH
36654: LD_INT 0
36656: PUSH
36657: LD_INT 1
36659: PUSH
36660: EMPTY
36661: LIST
36662: LIST
36663: PUSH
36664: LD_INT 1
36666: NEG
36667: PUSH
36668: LD_INT 0
36670: PUSH
36671: EMPTY
36672: LIST
36673: LIST
36674: PUSH
36675: LD_INT 1
36677: NEG
36678: PUSH
36679: LD_INT 1
36681: NEG
36682: PUSH
36683: EMPTY
36684: LIST
36685: LIST
36686: PUSH
36687: LD_INT 1
36689: NEG
36690: PUSH
36691: LD_INT 2
36693: NEG
36694: PUSH
36695: EMPTY
36696: LIST
36697: LIST
36698: PUSH
36699: LD_INT 0
36701: PUSH
36702: LD_INT 2
36704: NEG
36705: PUSH
36706: EMPTY
36707: LIST
36708: LIST
36709: PUSH
36710: LD_INT 1
36712: PUSH
36713: LD_INT 1
36715: NEG
36716: PUSH
36717: EMPTY
36718: LIST
36719: LIST
36720: PUSH
36721: LD_INT 2
36723: PUSH
36724: LD_INT 0
36726: PUSH
36727: EMPTY
36728: LIST
36729: LIST
36730: PUSH
36731: LD_INT 2
36733: PUSH
36734: LD_INT 1
36736: PUSH
36737: EMPTY
36738: LIST
36739: LIST
36740: PUSH
36741: LD_INT 2
36743: PUSH
36744: LD_INT 2
36746: PUSH
36747: EMPTY
36748: LIST
36749: LIST
36750: PUSH
36751: LD_INT 1
36753: PUSH
36754: LD_INT 2
36756: PUSH
36757: EMPTY
36758: LIST
36759: LIST
36760: PUSH
36761: LD_INT 0
36763: PUSH
36764: LD_INT 2
36766: PUSH
36767: EMPTY
36768: LIST
36769: LIST
36770: PUSH
36771: LD_INT 1
36773: NEG
36774: PUSH
36775: LD_INT 1
36777: PUSH
36778: EMPTY
36779: LIST
36780: LIST
36781: PUSH
36782: LD_INT 2
36784: NEG
36785: PUSH
36786: LD_INT 0
36788: PUSH
36789: EMPTY
36790: LIST
36791: LIST
36792: PUSH
36793: LD_INT 2
36795: NEG
36796: PUSH
36797: LD_INT 1
36799: NEG
36800: PUSH
36801: EMPTY
36802: LIST
36803: LIST
36804: PUSH
36805: LD_INT 2
36807: NEG
36808: PUSH
36809: LD_INT 2
36811: NEG
36812: PUSH
36813: EMPTY
36814: LIST
36815: LIST
36816: PUSH
36817: LD_INT 3
36819: PUSH
36820: LD_INT 1
36822: PUSH
36823: EMPTY
36824: LIST
36825: LIST
36826: PUSH
36827: LD_INT 3
36829: PUSH
36830: LD_INT 2
36832: PUSH
36833: EMPTY
36834: LIST
36835: LIST
36836: PUSH
36837: LD_INT 2
36839: PUSH
36840: LD_INT 3
36842: PUSH
36843: EMPTY
36844: LIST
36845: LIST
36846: PUSH
36847: LD_INT 1
36849: PUSH
36850: LD_INT 3
36852: PUSH
36853: EMPTY
36854: LIST
36855: LIST
36856: PUSH
36857: EMPTY
36858: LIST
36859: LIST
36860: LIST
36861: LIST
36862: LIST
36863: LIST
36864: LIST
36865: LIST
36866: LIST
36867: LIST
36868: LIST
36869: LIST
36870: LIST
36871: LIST
36872: LIST
36873: LIST
36874: LIST
36875: LIST
36876: LIST
36877: LIST
36878: LIST
36879: LIST
36880: LIST
36881: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
36882: LD_ADDR_VAR 0 26
36886: PUSH
36887: LD_INT 0
36889: PUSH
36890: LD_INT 0
36892: PUSH
36893: EMPTY
36894: LIST
36895: LIST
36896: PUSH
36897: LD_INT 0
36899: PUSH
36900: LD_INT 1
36902: NEG
36903: PUSH
36904: EMPTY
36905: LIST
36906: LIST
36907: PUSH
36908: LD_INT 1
36910: PUSH
36911: LD_INT 0
36913: PUSH
36914: EMPTY
36915: LIST
36916: LIST
36917: PUSH
36918: LD_INT 1
36920: PUSH
36921: LD_INT 1
36923: PUSH
36924: EMPTY
36925: LIST
36926: LIST
36927: PUSH
36928: LD_INT 0
36930: PUSH
36931: LD_INT 1
36933: PUSH
36934: EMPTY
36935: LIST
36936: LIST
36937: PUSH
36938: LD_INT 1
36940: NEG
36941: PUSH
36942: LD_INT 0
36944: PUSH
36945: EMPTY
36946: LIST
36947: LIST
36948: PUSH
36949: LD_INT 1
36951: NEG
36952: PUSH
36953: LD_INT 1
36955: NEG
36956: PUSH
36957: EMPTY
36958: LIST
36959: LIST
36960: PUSH
36961: LD_INT 1
36963: NEG
36964: PUSH
36965: LD_INT 2
36967: NEG
36968: PUSH
36969: EMPTY
36970: LIST
36971: LIST
36972: PUSH
36973: LD_INT 0
36975: PUSH
36976: LD_INT 2
36978: NEG
36979: PUSH
36980: EMPTY
36981: LIST
36982: LIST
36983: PUSH
36984: LD_INT 1
36986: PUSH
36987: LD_INT 1
36989: NEG
36990: PUSH
36991: EMPTY
36992: LIST
36993: LIST
36994: PUSH
36995: LD_INT 2
36997: PUSH
36998: LD_INT 0
37000: PUSH
37001: EMPTY
37002: LIST
37003: LIST
37004: PUSH
37005: LD_INT 2
37007: PUSH
37008: LD_INT 1
37010: PUSH
37011: EMPTY
37012: LIST
37013: LIST
37014: PUSH
37015: LD_INT 2
37017: PUSH
37018: LD_INT 2
37020: PUSH
37021: EMPTY
37022: LIST
37023: LIST
37024: PUSH
37025: LD_INT 1
37027: PUSH
37028: LD_INT 2
37030: PUSH
37031: EMPTY
37032: LIST
37033: LIST
37034: PUSH
37035: LD_INT 0
37037: PUSH
37038: LD_INT 2
37040: PUSH
37041: EMPTY
37042: LIST
37043: LIST
37044: PUSH
37045: LD_INT 1
37047: NEG
37048: PUSH
37049: LD_INT 1
37051: PUSH
37052: EMPTY
37053: LIST
37054: LIST
37055: PUSH
37056: LD_INT 2
37058: NEG
37059: PUSH
37060: LD_INT 0
37062: PUSH
37063: EMPTY
37064: LIST
37065: LIST
37066: PUSH
37067: LD_INT 2
37069: NEG
37070: PUSH
37071: LD_INT 1
37073: NEG
37074: PUSH
37075: EMPTY
37076: LIST
37077: LIST
37078: PUSH
37079: LD_INT 2
37081: NEG
37082: PUSH
37083: LD_INT 2
37085: NEG
37086: PUSH
37087: EMPTY
37088: LIST
37089: LIST
37090: PUSH
37091: LD_INT 2
37093: PUSH
37094: LD_INT 3
37096: PUSH
37097: EMPTY
37098: LIST
37099: LIST
37100: PUSH
37101: LD_INT 1
37103: PUSH
37104: LD_INT 3
37106: PUSH
37107: EMPTY
37108: LIST
37109: LIST
37110: PUSH
37111: LD_INT 1
37113: NEG
37114: PUSH
37115: LD_INT 2
37117: PUSH
37118: EMPTY
37119: LIST
37120: LIST
37121: PUSH
37122: LD_INT 2
37124: NEG
37125: PUSH
37126: LD_INT 1
37128: PUSH
37129: EMPTY
37130: LIST
37131: LIST
37132: PUSH
37133: EMPTY
37134: LIST
37135: LIST
37136: LIST
37137: LIST
37138: LIST
37139: LIST
37140: LIST
37141: LIST
37142: LIST
37143: LIST
37144: LIST
37145: LIST
37146: LIST
37147: LIST
37148: LIST
37149: LIST
37150: LIST
37151: LIST
37152: LIST
37153: LIST
37154: LIST
37155: LIST
37156: LIST
37157: ST_TO_ADDR
// fDepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
37158: LD_ADDR_VAR 0 27
37162: PUSH
37163: LD_INT 0
37165: PUSH
37166: LD_INT 0
37168: PUSH
37169: EMPTY
37170: LIST
37171: LIST
37172: PUSH
37173: LD_INT 0
37175: PUSH
37176: LD_INT 1
37178: NEG
37179: PUSH
37180: EMPTY
37181: LIST
37182: LIST
37183: PUSH
37184: LD_INT 1
37186: PUSH
37187: LD_INT 0
37189: PUSH
37190: EMPTY
37191: LIST
37192: LIST
37193: PUSH
37194: LD_INT 1
37196: PUSH
37197: LD_INT 1
37199: PUSH
37200: EMPTY
37201: LIST
37202: LIST
37203: PUSH
37204: LD_INT 0
37206: PUSH
37207: LD_INT 1
37209: PUSH
37210: EMPTY
37211: LIST
37212: LIST
37213: PUSH
37214: LD_INT 1
37216: NEG
37217: PUSH
37218: LD_INT 0
37220: PUSH
37221: EMPTY
37222: LIST
37223: LIST
37224: PUSH
37225: LD_INT 1
37227: NEG
37228: PUSH
37229: LD_INT 1
37231: NEG
37232: PUSH
37233: EMPTY
37234: LIST
37235: LIST
37236: PUSH
37237: LD_INT 1
37239: NEG
37240: PUSH
37241: LD_INT 2
37243: NEG
37244: PUSH
37245: EMPTY
37246: LIST
37247: LIST
37248: PUSH
37249: LD_INT 0
37251: PUSH
37252: LD_INT 2
37254: NEG
37255: PUSH
37256: EMPTY
37257: LIST
37258: LIST
37259: PUSH
37260: LD_INT 1
37262: PUSH
37263: LD_INT 1
37265: NEG
37266: PUSH
37267: EMPTY
37268: LIST
37269: LIST
37270: PUSH
37271: LD_INT 2
37273: PUSH
37274: LD_INT 0
37276: PUSH
37277: EMPTY
37278: LIST
37279: LIST
37280: PUSH
37281: LD_INT 2
37283: PUSH
37284: LD_INT 1
37286: PUSH
37287: EMPTY
37288: LIST
37289: LIST
37290: PUSH
37291: LD_INT 2
37293: PUSH
37294: LD_INT 2
37296: PUSH
37297: EMPTY
37298: LIST
37299: LIST
37300: PUSH
37301: LD_INT 1
37303: PUSH
37304: LD_INT 2
37306: PUSH
37307: EMPTY
37308: LIST
37309: LIST
37310: PUSH
37311: LD_INT 0
37313: PUSH
37314: LD_INT 2
37316: PUSH
37317: EMPTY
37318: LIST
37319: LIST
37320: PUSH
37321: LD_INT 1
37323: NEG
37324: PUSH
37325: LD_INT 1
37327: PUSH
37328: EMPTY
37329: LIST
37330: LIST
37331: PUSH
37332: LD_INT 2
37334: NEG
37335: PUSH
37336: LD_INT 0
37338: PUSH
37339: EMPTY
37340: LIST
37341: LIST
37342: PUSH
37343: LD_INT 2
37345: NEG
37346: PUSH
37347: LD_INT 1
37349: NEG
37350: PUSH
37351: EMPTY
37352: LIST
37353: LIST
37354: PUSH
37355: LD_INT 2
37357: NEG
37358: PUSH
37359: LD_INT 2
37361: NEG
37362: PUSH
37363: EMPTY
37364: LIST
37365: LIST
37366: PUSH
37367: LD_INT 1
37369: NEG
37370: PUSH
37371: LD_INT 2
37373: PUSH
37374: EMPTY
37375: LIST
37376: LIST
37377: PUSH
37378: LD_INT 2
37380: NEG
37381: PUSH
37382: LD_INT 1
37384: PUSH
37385: EMPTY
37386: LIST
37387: LIST
37388: PUSH
37389: LD_INT 3
37391: NEG
37392: PUSH
37393: LD_INT 1
37395: NEG
37396: PUSH
37397: EMPTY
37398: LIST
37399: LIST
37400: PUSH
37401: LD_INT 3
37403: NEG
37404: PUSH
37405: LD_INT 2
37407: NEG
37408: PUSH
37409: EMPTY
37410: LIST
37411: LIST
37412: PUSH
37413: EMPTY
37414: LIST
37415: LIST
37416: LIST
37417: LIST
37418: LIST
37419: LIST
37420: LIST
37421: LIST
37422: LIST
37423: LIST
37424: LIST
37425: LIST
37426: LIST
37427: LIST
37428: LIST
37429: LIST
37430: LIST
37431: LIST
37432: LIST
37433: LIST
37434: LIST
37435: LIST
37436: LIST
37437: ST_TO_ADDR
// fDepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
37438: LD_ADDR_VAR 0 28
37442: PUSH
37443: LD_INT 0
37445: PUSH
37446: LD_INT 0
37448: PUSH
37449: EMPTY
37450: LIST
37451: LIST
37452: PUSH
37453: LD_INT 0
37455: PUSH
37456: LD_INT 1
37458: NEG
37459: PUSH
37460: EMPTY
37461: LIST
37462: LIST
37463: PUSH
37464: LD_INT 1
37466: PUSH
37467: LD_INT 0
37469: PUSH
37470: EMPTY
37471: LIST
37472: LIST
37473: PUSH
37474: LD_INT 1
37476: PUSH
37477: LD_INT 1
37479: PUSH
37480: EMPTY
37481: LIST
37482: LIST
37483: PUSH
37484: LD_INT 0
37486: PUSH
37487: LD_INT 1
37489: PUSH
37490: EMPTY
37491: LIST
37492: LIST
37493: PUSH
37494: LD_INT 1
37496: NEG
37497: PUSH
37498: LD_INT 0
37500: PUSH
37501: EMPTY
37502: LIST
37503: LIST
37504: PUSH
37505: LD_INT 1
37507: NEG
37508: PUSH
37509: LD_INT 1
37511: NEG
37512: PUSH
37513: EMPTY
37514: LIST
37515: LIST
37516: PUSH
37517: LD_INT 1
37519: NEG
37520: PUSH
37521: LD_INT 2
37523: NEG
37524: PUSH
37525: EMPTY
37526: LIST
37527: LIST
37528: PUSH
37529: LD_INT 0
37531: PUSH
37532: LD_INT 2
37534: NEG
37535: PUSH
37536: EMPTY
37537: LIST
37538: LIST
37539: PUSH
37540: LD_INT 1
37542: PUSH
37543: LD_INT 1
37545: NEG
37546: PUSH
37547: EMPTY
37548: LIST
37549: LIST
37550: PUSH
37551: LD_INT 2
37553: PUSH
37554: LD_INT 0
37556: PUSH
37557: EMPTY
37558: LIST
37559: LIST
37560: PUSH
37561: LD_INT 2
37563: PUSH
37564: LD_INT 1
37566: PUSH
37567: EMPTY
37568: LIST
37569: LIST
37570: PUSH
37571: LD_INT 2
37573: PUSH
37574: LD_INT 2
37576: PUSH
37577: EMPTY
37578: LIST
37579: LIST
37580: PUSH
37581: LD_INT 1
37583: PUSH
37584: LD_INT 2
37586: PUSH
37587: EMPTY
37588: LIST
37589: LIST
37590: PUSH
37591: LD_INT 0
37593: PUSH
37594: LD_INT 2
37596: PUSH
37597: EMPTY
37598: LIST
37599: LIST
37600: PUSH
37601: LD_INT 1
37603: NEG
37604: PUSH
37605: LD_INT 1
37607: PUSH
37608: EMPTY
37609: LIST
37610: LIST
37611: PUSH
37612: LD_INT 2
37614: NEG
37615: PUSH
37616: LD_INT 0
37618: PUSH
37619: EMPTY
37620: LIST
37621: LIST
37622: PUSH
37623: LD_INT 2
37625: NEG
37626: PUSH
37627: LD_INT 1
37629: NEG
37630: PUSH
37631: EMPTY
37632: LIST
37633: LIST
37634: PUSH
37635: LD_INT 2
37637: NEG
37638: PUSH
37639: LD_INT 2
37641: NEG
37642: PUSH
37643: EMPTY
37644: LIST
37645: LIST
37646: PUSH
37647: LD_INT 2
37649: NEG
37650: PUSH
37651: LD_INT 3
37653: NEG
37654: PUSH
37655: EMPTY
37656: LIST
37657: LIST
37658: PUSH
37659: LD_INT 1
37661: NEG
37662: PUSH
37663: LD_INT 3
37665: NEG
37666: PUSH
37667: EMPTY
37668: LIST
37669: LIST
37670: PUSH
37671: LD_INT 3
37673: NEG
37674: PUSH
37675: LD_INT 1
37677: NEG
37678: PUSH
37679: EMPTY
37680: LIST
37681: LIST
37682: PUSH
37683: LD_INT 3
37685: NEG
37686: PUSH
37687: LD_INT 2
37689: NEG
37690: PUSH
37691: EMPTY
37692: LIST
37693: LIST
37694: PUSH
37695: EMPTY
37696: LIST
37697: LIST
37698: LIST
37699: LIST
37700: LIST
37701: LIST
37702: LIST
37703: LIST
37704: LIST
37705: LIST
37706: LIST
37707: LIST
37708: LIST
37709: LIST
37710: LIST
37711: LIST
37712: LIST
37713: LIST
37714: LIST
37715: LIST
37716: LIST
37717: LIST
37718: LIST
37719: ST_TO_ADDR
// fFactory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
37720: LD_ADDR_VAR 0 29
37724: PUSH
37725: LD_INT 0
37727: PUSH
37728: LD_INT 0
37730: PUSH
37731: EMPTY
37732: LIST
37733: LIST
37734: PUSH
37735: LD_INT 0
37737: PUSH
37738: LD_INT 1
37740: NEG
37741: PUSH
37742: EMPTY
37743: LIST
37744: LIST
37745: PUSH
37746: LD_INT 1
37748: PUSH
37749: LD_INT 0
37751: PUSH
37752: EMPTY
37753: LIST
37754: LIST
37755: PUSH
37756: LD_INT 1
37758: PUSH
37759: LD_INT 1
37761: PUSH
37762: EMPTY
37763: LIST
37764: LIST
37765: PUSH
37766: LD_INT 0
37768: PUSH
37769: LD_INT 1
37771: PUSH
37772: EMPTY
37773: LIST
37774: LIST
37775: PUSH
37776: LD_INT 1
37778: NEG
37779: PUSH
37780: LD_INT 0
37782: PUSH
37783: EMPTY
37784: LIST
37785: LIST
37786: PUSH
37787: LD_INT 1
37789: NEG
37790: PUSH
37791: LD_INT 1
37793: NEG
37794: PUSH
37795: EMPTY
37796: LIST
37797: LIST
37798: PUSH
37799: LD_INT 1
37801: NEG
37802: PUSH
37803: LD_INT 2
37805: NEG
37806: PUSH
37807: EMPTY
37808: LIST
37809: LIST
37810: PUSH
37811: LD_INT 0
37813: PUSH
37814: LD_INT 2
37816: NEG
37817: PUSH
37818: EMPTY
37819: LIST
37820: LIST
37821: PUSH
37822: LD_INT 1
37824: PUSH
37825: LD_INT 1
37827: NEG
37828: PUSH
37829: EMPTY
37830: LIST
37831: LIST
37832: PUSH
37833: LD_INT 2
37835: PUSH
37836: LD_INT 0
37838: PUSH
37839: EMPTY
37840: LIST
37841: LIST
37842: PUSH
37843: LD_INT 2
37845: PUSH
37846: LD_INT 1
37848: PUSH
37849: EMPTY
37850: LIST
37851: LIST
37852: PUSH
37853: LD_INT 1
37855: PUSH
37856: LD_INT 2
37858: PUSH
37859: EMPTY
37860: LIST
37861: LIST
37862: PUSH
37863: LD_INT 0
37865: PUSH
37866: LD_INT 2
37868: PUSH
37869: EMPTY
37870: LIST
37871: LIST
37872: PUSH
37873: LD_INT 1
37875: NEG
37876: PUSH
37877: LD_INT 1
37879: PUSH
37880: EMPTY
37881: LIST
37882: LIST
37883: PUSH
37884: LD_INT 2
37886: NEG
37887: PUSH
37888: LD_INT 1
37890: NEG
37891: PUSH
37892: EMPTY
37893: LIST
37894: LIST
37895: PUSH
37896: LD_INT 2
37898: NEG
37899: PUSH
37900: LD_INT 2
37902: NEG
37903: PUSH
37904: EMPTY
37905: LIST
37906: LIST
37907: PUSH
37908: LD_INT 2
37910: NEG
37911: PUSH
37912: LD_INT 3
37914: NEG
37915: PUSH
37916: EMPTY
37917: LIST
37918: LIST
37919: PUSH
37920: LD_INT 2
37922: PUSH
37923: LD_INT 1
37925: NEG
37926: PUSH
37927: EMPTY
37928: LIST
37929: LIST
37930: PUSH
37931: LD_INT 3
37933: PUSH
37934: LD_INT 1
37936: PUSH
37937: EMPTY
37938: LIST
37939: LIST
37940: PUSH
37941: LD_INT 1
37943: PUSH
37944: LD_INT 3
37946: PUSH
37947: EMPTY
37948: LIST
37949: LIST
37950: PUSH
37951: LD_INT 1
37953: NEG
37954: PUSH
37955: LD_INT 2
37957: PUSH
37958: EMPTY
37959: LIST
37960: LIST
37961: PUSH
37962: LD_INT 3
37964: NEG
37965: PUSH
37966: LD_INT 2
37968: NEG
37969: PUSH
37970: EMPTY
37971: LIST
37972: LIST
37973: PUSH
37974: EMPTY
37975: LIST
37976: LIST
37977: LIST
37978: LIST
37979: LIST
37980: LIST
37981: LIST
37982: LIST
37983: LIST
37984: LIST
37985: LIST
37986: LIST
37987: LIST
37988: LIST
37989: LIST
37990: LIST
37991: LIST
37992: LIST
37993: LIST
37994: LIST
37995: LIST
37996: LIST
37997: LIST
37998: ST_TO_ADDR
// fFactory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
37999: LD_ADDR_VAR 0 30
38003: PUSH
38004: LD_INT 0
38006: PUSH
38007: LD_INT 0
38009: PUSH
38010: EMPTY
38011: LIST
38012: LIST
38013: PUSH
38014: LD_INT 0
38016: PUSH
38017: LD_INT 1
38019: NEG
38020: PUSH
38021: EMPTY
38022: LIST
38023: LIST
38024: PUSH
38025: LD_INT 1
38027: PUSH
38028: LD_INT 0
38030: PUSH
38031: EMPTY
38032: LIST
38033: LIST
38034: PUSH
38035: LD_INT 1
38037: PUSH
38038: LD_INT 1
38040: PUSH
38041: EMPTY
38042: LIST
38043: LIST
38044: PUSH
38045: LD_INT 0
38047: PUSH
38048: LD_INT 1
38050: PUSH
38051: EMPTY
38052: LIST
38053: LIST
38054: PUSH
38055: LD_INT 1
38057: NEG
38058: PUSH
38059: LD_INT 0
38061: PUSH
38062: EMPTY
38063: LIST
38064: LIST
38065: PUSH
38066: LD_INT 1
38068: NEG
38069: PUSH
38070: LD_INT 1
38072: NEG
38073: PUSH
38074: EMPTY
38075: LIST
38076: LIST
38077: PUSH
38078: LD_INT 1
38080: NEG
38081: PUSH
38082: LD_INT 2
38084: NEG
38085: PUSH
38086: EMPTY
38087: LIST
38088: LIST
38089: PUSH
38090: LD_INT 0
38092: PUSH
38093: LD_INT 2
38095: NEG
38096: PUSH
38097: EMPTY
38098: LIST
38099: LIST
38100: PUSH
38101: LD_INT 1
38103: PUSH
38104: LD_INT 1
38106: NEG
38107: PUSH
38108: EMPTY
38109: LIST
38110: LIST
38111: PUSH
38112: LD_INT 2
38114: PUSH
38115: LD_INT 0
38117: PUSH
38118: EMPTY
38119: LIST
38120: LIST
38121: PUSH
38122: LD_INT 2
38124: PUSH
38125: LD_INT 1
38127: PUSH
38128: EMPTY
38129: LIST
38130: LIST
38131: PUSH
38132: LD_INT 2
38134: PUSH
38135: LD_INT 2
38137: PUSH
38138: EMPTY
38139: LIST
38140: LIST
38141: PUSH
38142: LD_INT 1
38144: PUSH
38145: LD_INT 2
38147: PUSH
38148: EMPTY
38149: LIST
38150: LIST
38151: PUSH
38152: LD_INT 1
38154: NEG
38155: PUSH
38156: LD_INT 1
38158: PUSH
38159: EMPTY
38160: LIST
38161: LIST
38162: PUSH
38163: LD_INT 2
38165: NEG
38166: PUSH
38167: LD_INT 0
38169: PUSH
38170: EMPTY
38171: LIST
38172: LIST
38173: PUSH
38174: LD_INT 2
38176: NEG
38177: PUSH
38178: LD_INT 1
38180: NEG
38181: PUSH
38182: EMPTY
38183: LIST
38184: LIST
38185: PUSH
38186: LD_INT 1
38188: NEG
38189: PUSH
38190: LD_INT 3
38192: NEG
38193: PUSH
38194: EMPTY
38195: LIST
38196: LIST
38197: PUSH
38198: LD_INT 1
38200: PUSH
38201: LD_INT 2
38203: NEG
38204: PUSH
38205: EMPTY
38206: LIST
38207: LIST
38208: PUSH
38209: LD_INT 3
38211: PUSH
38212: LD_INT 2
38214: PUSH
38215: EMPTY
38216: LIST
38217: LIST
38218: PUSH
38219: LD_INT 2
38221: PUSH
38222: LD_INT 3
38224: PUSH
38225: EMPTY
38226: LIST
38227: LIST
38228: PUSH
38229: LD_INT 2
38231: NEG
38232: PUSH
38233: LD_INT 1
38235: PUSH
38236: EMPTY
38237: LIST
38238: LIST
38239: PUSH
38240: LD_INT 3
38242: NEG
38243: PUSH
38244: LD_INT 1
38246: NEG
38247: PUSH
38248: EMPTY
38249: LIST
38250: LIST
38251: PUSH
38252: EMPTY
38253: LIST
38254: LIST
38255: LIST
38256: LIST
38257: LIST
38258: LIST
38259: LIST
38260: LIST
38261: LIST
38262: LIST
38263: LIST
38264: LIST
38265: LIST
38266: LIST
38267: LIST
38268: LIST
38269: LIST
38270: LIST
38271: LIST
38272: LIST
38273: LIST
38274: LIST
38275: LIST
38276: ST_TO_ADDR
// fFactory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
38277: LD_ADDR_VAR 0 31
38281: PUSH
38282: LD_INT 0
38284: PUSH
38285: LD_INT 0
38287: PUSH
38288: EMPTY
38289: LIST
38290: LIST
38291: PUSH
38292: LD_INT 0
38294: PUSH
38295: LD_INT 1
38297: NEG
38298: PUSH
38299: EMPTY
38300: LIST
38301: LIST
38302: PUSH
38303: LD_INT 1
38305: PUSH
38306: LD_INT 0
38308: PUSH
38309: EMPTY
38310: LIST
38311: LIST
38312: PUSH
38313: LD_INT 1
38315: PUSH
38316: LD_INT 1
38318: PUSH
38319: EMPTY
38320: LIST
38321: LIST
38322: PUSH
38323: LD_INT 0
38325: PUSH
38326: LD_INT 1
38328: PUSH
38329: EMPTY
38330: LIST
38331: LIST
38332: PUSH
38333: LD_INT 1
38335: NEG
38336: PUSH
38337: LD_INT 0
38339: PUSH
38340: EMPTY
38341: LIST
38342: LIST
38343: PUSH
38344: LD_INT 1
38346: NEG
38347: PUSH
38348: LD_INT 1
38350: NEG
38351: PUSH
38352: EMPTY
38353: LIST
38354: LIST
38355: PUSH
38356: LD_INT 1
38358: NEG
38359: PUSH
38360: LD_INT 2
38362: NEG
38363: PUSH
38364: EMPTY
38365: LIST
38366: LIST
38367: PUSH
38368: LD_INT 1
38370: PUSH
38371: LD_INT 1
38373: NEG
38374: PUSH
38375: EMPTY
38376: LIST
38377: LIST
38378: PUSH
38379: LD_INT 2
38381: PUSH
38382: LD_INT 0
38384: PUSH
38385: EMPTY
38386: LIST
38387: LIST
38388: PUSH
38389: LD_INT 2
38391: PUSH
38392: LD_INT 1
38394: PUSH
38395: EMPTY
38396: LIST
38397: LIST
38398: PUSH
38399: LD_INT 2
38401: PUSH
38402: LD_INT 2
38404: PUSH
38405: EMPTY
38406: LIST
38407: LIST
38408: PUSH
38409: LD_INT 1
38411: PUSH
38412: LD_INT 2
38414: PUSH
38415: EMPTY
38416: LIST
38417: LIST
38418: PUSH
38419: LD_INT 0
38421: PUSH
38422: LD_INT 2
38424: PUSH
38425: EMPTY
38426: LIST
38427: LIST
38428: PUSH
38429: LD_INT 1
38431: NEG
38432: PUSH
38433: LD_INT 1
38435: PUSH
38436: EMPTY
38437: LIST
38438: LIST
38439: PUSH
38440: LD_INT 2
38442: NEG
38443: PUSH
38444: LD_INT 1
38446: NEG
38447: PUSH
38448: EMPTY
38449: LIST
38450: LIST
38451: PUSH
38452: LD_INT 2
38454: NEG
38455: PUSH
38456: LD_INT 2
38458: NEG
38459: PUSH
38460: EMPTY
38461: LIST
38462: LIST
38463: PUSH
38464: LD_INT 2
38466: NEG
38467: PUSH
38468: LD_INT 3
38470: NEG
38471: PUSH
38472: EMPTY
38473: LIST
38474: LIST
38475: PUSH
38476: LD_INT 2
38478: PUSH
38479: LD_INT 1
38481: NEG
38482: PUSH
38483: EMPTY
38484: LIST
38485: LIST
38486: PUSH
38487: LD_INT 3
38489: PUSH
38490: LD_INT 1
38492: PUSH
38493: EMPTY
38494: LIST
38495: LIST
38496: PUSH
38497: LD_INT 1
38499: PUSH
38500: LD_INT 3
38502: PUSH
38503: EMPTY
38504: LIST
38505: LIST
38506: PUSH
38507: LD_INT 1
38509: NEG
38510: PUSH
38511: LD_INT 2
38513: PUSH
38514: EMPTY
38515: LIST
38516: LIST
38517: PUSH
38518: LD_INT 3
38520: NEG
38521: PUSH
38522: LD_INT 2
38524: NEG
38525: PUSH
38526: EMPTY
38527: LIST
38528: LIST
38529: PUSH
38530: EMPTY
38531: LIST
38532: LIST
38533: LIST
38534: LIST
38535: LIST
38536: LIST
38537: LIST
38538: LIST
38539: LIST
38540: LIST
38541: LIST
38542: LIST
38543: LIST
38544: LIST
38545: LIST
38546: LIST
38547: LIST
38548: LIST
38549: LIST
38550: LIST
38551: LIST
38552: LIST
38553: LIST
38554: ST_TO_ADDR
// fFactory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
38555: LD_ADDR_VAR 0 32
38559: PUSH
38560: LD_INT 0
38562: PUSH
38563: LD_INT 0
38565: PUSH
38566: EMPTY
38567: LIST
38568: LIST
38569: PUSH
38570: LD_INT 0
38572: PUSH
38573: LD_INT 1
38575: NEG
38576: PUSH
38577: EMPTY
38578: LIST
38579: LIST
38580: PUSH
38581: LD_INT 1
38583: PUSH
38584: LD_INT 0
38586: PUSH
38587: EMPTY
38588: LIST
38589: LIST
38590: PUSH
38591: LD_INT 1
38593: PUSH
38594: LD_INT 1
38596: PUSH
38597: EMPTY
38598: LIST
38599: LIST
38600: PUSH
38601: LD_INT 0
38603: PUSH
38604: LD_INT 1
38606: PUSH
38607: EMPTY
38608: LIST
38609: LIST
38610: PUSH
38611: LD_INT 1
38613: NEG
38614: PUSH
38615: LD_INT 0
38617: PUSH
38618: EMPTY
38619: LIST
38620: LIST
38621: PUSH
38622: LD_INT 1
38624: NEG
38625: PUSH
38626: LD_INT 1
38628: NEG
38629: PUSH
38630: EMPTY
38631: LIST
38632: LIST
38633: PUSH
38634: LD_INT 1
38636: NEG
38637: PUSH
38638: LD_INT 2
38640: NEG
38641: PUSH
38642: EMPTY
38643: LIST
38644: LIST
38645: PUSH
38646: LD_INT 0
38648: PUSH
38649: LD_INT 2
38651: NEG
38652: PUSH
38653: EMPTY
38654: LIST
38655: LIST
38656: PUSH
38657: LD_INT 1
38659: PUSH
38660: LD_INT 1
38662: NEG
38663: PUSH
38664: EMPTY
38665: LIST
38666: LIST
38667: PUSH
38668: LD_INT 2
38670: PUSH
38671: LD_INT 1
38673: PUSH
38674: EMPTY
38675: LIST
38676: LIST
38677: PUSH
38678: LD_INT 2
38680: PUSH
38681: LD_INT 2
38683: PUSH
38684: EMPTY
38685: LIST
38686: LIST
38687: PUSH
38688: LD_INT 1
38690: PUSH
38691: LD_INT 2
38693: PUSH
38694: EMPTY
38695: LIST
38696: LIST
38697: PUSH
38698: LD_INT 0
38700: PUSH
38701: LD_INT 2
38703: PUSH
38704: EMPTY
38705: LIST
38706: LIST
38707: PUSH
38708: LD_INT 1
38710: NEG
38711: PUSH
38712: LD_INT 1
38714: PUSH
38715: EMPTY
38716: LIST
38717: LIST
38718: PUSH
38719: LD_INT 2
38721: NEG
38722: PUSH
38723: LD_INT 0
38725: PUSH
38726: EMPTY
38727: LIST
38728: LIST
38729: PUSH
38730: LD_INT 2
38732: NEG
38733: PUSH
38734: LD_INT 1
38736: NEG
38737: PUSH
38738: EMPTY
38739: LIST
38740: LIST
38741: PUSH
38742: LD_INT 1
38744: NEG
38745: PUSH
38746: LD_INT 3
38748: NEG
38749: PUSH
38750: EMPTY
38751: LIST
38752: LIST
38753: PUSH
38754: LD_INT 1
38756: PUSH
38757: LD_INT 2
38759: NEG
38760: PUSH
38761: EMPTY
38762: LIST
38763: LIST
38764: PUSH
38765: LD_INT 3
38767: PUSH
38768: LD_INT 2
38770: PUSH
38771: EMPTY
38772: LIST
38773: LIST
38774: PUSH
38775: LD_INT 2
38777: PUSH
38778: LD_INT 3
38780: PUSH
38781: EMPTY
38782: LIST
38783: LIST
38784: PUSH
38785: LD_INT 2
38787: NEG
38788: PUSH
38789: LD_INT 1
38791: PUSH
38792: EMPTY
38793: LIST
38794: LIST
38795: PUSH
38796: LD_INT 3
38798: NEG
38799: PUSH
38800: LD_INT 1
38802: NEG
38803: PUSH
38804: EMPTY
38805: LIST
38806: LIST
38807: PUSH
38808: EMPTY
38809: LIST
38810: LIST
38811: LIST
38812: LIST
38813: LIST
38814: LIST
38815: LIST
38816: LIST
38817: LIST
38818: LIST
38819: LIST
38820: LIST
38821: LIST
38822: LIST
38823: LIST
38824: LIST
38825: LIST
38826: LIST
38827: LIST
38828: LIST
38829: LIST
38830: LIST
38831: LIST
38832: ST_TO_ADDR
// fFactory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
38833: LD_ADDR_VAR 0 33
38837: PUSH
38838: LD_INT 0
38840: PUSH
38841: LD_INT 0
38843: PUSH
38844: EMPTY
38845: LIST
38846: LIST
38847: PUSH
38848: LD_INT 0
38850: PUSH
38851: LD_INT 1
38853: NEG
38854: PUSH
38855: EMPTY
38856: LIST
38857: LIST
38858: PUSH
38859: LD_INT 1
38861: PUSH
38862: LD_INT 0
38864: PUSH
38865: EMPTY
38866: LIST
38867: LIST
38868: PUSH
38869: LD_INT 1
38871: PUSH
38872: LD_INT 1
38874: PUSH
38875: EMPTY
38876: LIST
38877: LIST
38878: PUSH
38879: LD_INT 0
38881: PUSH
38882: LD_INT 1
38884: PUSH
38885: EMPTY
38886: LIST
38887: LIST
38888: PUSH
38889: LD_INT 1
38891: NEG
38892: PUSH
38893: LD_INT 0
38895: PUSH
38896: EMPTY
38897: LIST
38898: LIST
38899: PUSH
38900: LD_INT 1
38902: NEG
38903: PUSH
38904: LD_INT 1
38906: NEG
38907: PUSH
38908: EMPTY
38909: LIST
38910: LIST
38911: PUSH
38912: LD_INT 1
38914: NEG
38915: PUSH
38916: LD_INT 2
38918: NEG
38919: PUSH
38920: EMPTY
38921: LIST
38922: LIST
38923: PUSH
38924: LD_INT 1
38926: PUSH
38927: LD_INT 1
38929: NEG
38930: PUSH
38931: EMPTY
38932: LIST
38933: LIST
38934: PUSH
38935: LD_INT 2
38937: PUSH
38938: LD_INT 0
38940: PUSH
38941: EMPTY
38942: LIST
38943: LIST
38944: PUSH
38945: LD_INT 2
38947: PUSH
38948: LD_INT 1
38950: PUSH
38951: EMPTY
38952: LIST
38953: LIST
38954: PUSH
38955: LD_INT 1
38957: PUSH
38958: LD_INT 2
38960: PUSH
38961: EMPTY
38962: LIST
38963: LIST
38964: PUSH
38965: LD_INT 0
38967: PUSH
38968: LD_INT 2
38970: PUSH
38971: EMPTY
38972: LIST
38973: LIST
38974: PUSH
38975: LD_INT 1
38977: NEG
38978: PUSH
38979: LD_INT 1
38981: PUSH
38982: EMPTY
38983: LIST
38984: LIST
38985: PUSH
38986: LD_INT 2
38988: NEG
38989: PUSH
38990: LD_INT 0
38992: PUSH
38993: EMPTY
38994: LIST
38995: LIST
38996: PUSH
38997: LD_INT 2
38999: NEG
39000: PUSH
39001: LD_INT 1
39003: NEG
39004: PUSH
39005: EMPTY
39006: LIST
39007: LIST
39008: PUSH
39009: LD_INT 2
39011: NEG
39012: PUSH
39013: LD_INT 2
39015: NEG
39016: PUSH
39017: EMPTY
39018: LIST
39019: LIST
39020: PUSH
39021: LD_INT 2
39023: NEG
39024: PUSH
39025: LD_INT 3
39027: NEG
39028: PUSH
39029: EMPTY
39030: LIST
39031: LIST
39032: PUSH
39033: LD_INT 2
39035: PUSH
39036: LD_INT 1
39038: NEG
39039: PUSH
39040: EMPTY
39041: LIST
39042: LIST
39043: PUSH
39044: LD_INT 3
39046: PUSH
39047: LD_INT 1
39049: PUSH
39050: EMPTY
39051: LIST
39052: LIST
39053: PUSH
39054: LD_INT 1
39056: PUSH
39057: LD_INT 3
39059: PUSH
39060: EMPTY
39061: LIST
39062: LIST
39063: PUSH
39064: LD_INT 1
39066: NEG
39067: PUSH
39068: LD_INT 2
39070: PUSH
39071: EMPTY
39072: LIST
39073: LIST
39074: PUSH
39075: LD_INT 3
39077: NEG
39078: PUSH
39079: LD_INT 2
39081: NEG
39082: PUSH
39083: EMPTY
39084: LIST
39085: LIST
39086: PUSH
39087: EMPTY
39088: LIST
39089: LIST
39090: LIST
39091: LIST
39092: LIST
39093: LIST
39094: LIST
39095: LIST
39096: LIST
39097: LIST
39098: LIST
39099: LIST
39100: LIST
39101: LIST
39102: LIST
39103: LIST
39104: LIST
39105: LIST
39106: LIST
39107: LIST
39108: LIST
39109: LIST
39110: LIST
39111: ST_TO_ADDR
// fFactory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
39112: LD_ADDR_VAR 0 34
39116: PUSH
39117: LD_INT 0
39119: PUSH
39120: LD_INT 0
39122: PUSH
39123: EMPTY
39124: LIST
39125: LIST
39126: PUSH
39127: LD_INT 0
39129: PUSH
39130: LD_INT 1
39132: NEG
39133: PUSH
39134: EMPTY
39135: LIST
39136: LIST
39137: PUSH
39138: LD_INT 1
39140: PUSH
39141: LD_INT 0
39143: PUSH
39144: EMPTY
39145: LIST
39146: LIST
39147: PUSH
39148: LD_INT 1
39150: PUSH
39151: LD_INT 1
39153: PUSH
39154: EMPTY
39155: LIST
39156: LIST
39157: PUSH
39158: LD_INT 0
39160: PUSH
39161: LD_INT 1
39163: PUSH
39164: EMPTY
39165: LIST
39166: LIST
39167: PUSH
39168: LD_INT 1
39170: NEG
39171: PUSH
39172: LD_INT 0
39174: PUSH
39175: EMPTY
39176: LIST
39177: LIST
39178: PUSH
39179: LD_INT 1
39181: NEG
39182: PUSH
39183: LD_INT 1
39185: NEG
39186: PUSH
39187: EMPTY
39188: LIST
39189: LIST
39190: PUSH
39191: LD_INT 1
39193: NEG
39194: PUSH
39195: LD_INT 2
39197: NEG
39198: PUSH
39199: EMPTY
39200: LIST
39201: LIST
39202: PUSH
39203: LD_INT 0
39205: PUSH
39206: LD_INT 2
39208: NEG
39209: PUSH
39210: EMPTY
39211: LIST
39212: LIST
39213: PUSH
39214: LD_INT 1
39216: PUSH
39217: LD_INT 1
39219: NEG
39220: PUSH
39221: EMPTY
39222: LIST
39223: LIST
39224: PUSH
39225: LD_INT 2
39227: PUSH
39228: LD_INT 1
39230: PUSH
39231: EMPTY
39232: LIST
39233: LIST
39234: PUSH
39235: LD_INT 2
39237: PUSH
39238: LD_INT 2
39240: PUSH
39241: EMPTY
39242: LIST
39243: LIST
39244: PUSH
39245: LD_INT 1
39247: PUSH
39248: LD_INT 2
39250: PUSH
39251: EMPTY
39252: LIST
39253: LIST
39254: PUSH
39255: LD_INT 1
39257: NEG
39258: PUSH
39259: LD_INT 1
39261: PUSH
39262: EMPTY
39263: LIST
39264: LIST
39265: PUSH
39266: LD_INT 2
39268: NEG
39269: PUSH
39270: LD_INT 0
39272: PUSH
39273: EMPTY
39274: LIST
39275: LIST
39276: PUSH
39277: LD_INT 2
39279: NEG
39280: PUSH
39281: LD_INT 1
39283: NEG
39284: PUSH
39285: EMPTY
39286: LIST
39287: LIST
39288: PUSH
39289: LD_INT 2
39291: NEG
39292: PUSH
39293: LD_INT 2
39295: NEG
39296: PUSH
39297: EMPTY
39298: LIST
39299: LIST
39300: PUSH
39301: LD_INT 1
39303: NEG
39304: PUSH
39305: LD_INT 3
39307: NEG
39308: PUSH
39309: EMPTY
39310: LIST
39311: LIST
39312: PUSH
39313: LD_INT 1
39315: PUSH
39316: LD_INT 2
39318: NEG
39319: PUSH
39320: EMPTY
39321: LIST
39322: LIST
39323: PUSH
39324: LD_INT 3
39326: PUSH
39327: LD_INT 2
39329: PUSH
39330: EMPTY
39331: LIST
39332: LIST
39333: PUSH
39334: LD_INT 2
39336: PUSH
39337: LD_INT 3
39339: PUSH
39340: EMPTY
39341: LIST
39342: LIST
39343: PUSH
39344: LD_INT 2
39346: NEG
39347: PUSH
39348: LD_INT 1
39350: PUSH
39351: EMPTY
39352: LIST
39353: LIST
39354: PUSH
39355: LD_INT 3
39357: NEG
39358: PUSH
39359: LD_INT 1
39361: NEG
39362: PUSH
39363: EMPTY
39364: LIST
39365: LIST
39366: PUSH
39367: EMPTY
39368: LIST
39369: LIST
39370: LIST
39371: LIST
39372: LIST
39373: LIST
39374: LIST
39375: LIST
39376: LIST
39377: LIST
39378: LIST
39379: LIST
39380: LIST
39381: LIST
39382: LIST
39383: LIST
39384: LIST
39385: LIST
39386: LIST
39387: LIST
39388: LIST
39389: LIST
39390: LIST
39391: ST_TO_ADDR
// fExt0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
39392: LD_ADDR_VAR 0 35
39396: PUSH
39397: LD_INT 0
39399: PUSH
39400: LD_INT 0
39402: PUSH
39403: EMPTY
39404: LIST
39405: LIST
39406: PUSH
39407: LD_INT 0
39409: PUSH
39410: LD_INT 1
39412: NEG
39413: PUSH
39414: EMPTY
39415: LIST
39416: LIST
39417: PUSH
39418: LD_INT 1
39420: PUSH
39421: LD_INT 0
39423: PUSH
39424: EMPTY
39425: LIST
39426: LIST
39427: PUSH
39428: LD_INT 1
39430: PUSH
39431: LD_INT 1
39433: PUSH
39434: EMPTY
39435: LIST
39436: LIST
39437: PUSH
39438: LD_INT 0
39440: PUSH
39441: LD_INT 1
39443: PUSH
39444: EMPTY
39445: LIST
39446: LIST
39447: PUSH
39448: LD_INT 1
39450: NEG
39451: PUSH
39452: LD_INT 0
39454: PUSH
39455: EMPTY
39456: LIST
39457: LIST
39458: PUSH
39459: LD_INT 1
39461: NEG
39462: PUSH
39463: LD_INT 1
39465: NEG
39466: PUSH
39467: EMPTY
39468: LIST
39469: LIST
39470: PUSH
39471: LD_INT 2
39473: PUSH
39474: LD_INT 1
39476: PUSH
39477: EMPTY
39478: LIST
39479: LIST
39480: PUSH
39481: LD_INT 2
39483: NEG
39484: PUSH
39485: LD_INT 1
39487: NEG
39488: PUSH
39489: EMPTY
39490: LIST
39491: LIST
39492: PUSH
39493: EMPTY
39494: LIST
39495: LIST
39496: LIST
39497: LIST
39498: LIST
39499: LIST
39500: LIST
39501: LIST
39502: LIST
39503: ST_TO_ADDR
// fExt1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
39504: LD_ADDR_VAR 0 36
39508: PUSH
39509: LD_INT 0
39511: PUSH
39512: LD_INT 0
39514: PUSH
39515: EMPTY
39516: LIST
39517: LIST
39518: PUSH
39519: LD_INT 0
39521: PUSH
39522: LD_INT 1
39524: NEG
39525: PUSH
39526: EMPTY
39527: LIST
39528: LIST
39529: PUSH
39530: LD_INT 1
39532: PUSH
39533: LD_INT 0
39535: PUSH
39536: EMPTY
39537: LIST
39538: LIST
39539: PUSH
39540: LD_INT 1
39542: PUSH
39543: LD_INT 1
39545: PUSH
39546: EMPTY
39547: LIST
39548: LIST
39549: PUSH
39550: LD_INT 0
39552: PUSH
39553: LD_INT 1
39555: PUSH
39556: EMPTY
39557: LIST
39558: LIST
39559: PUSH
39560: LD_INT 1
39562: NEG
39563: PUSH
39564: LD_INT 0
39566: PUSH
39567: EMPTY
39568: LIST
39569: LIST
39570: PUSH
39571: LD_INT 1
39573: NEG
39574: PUSH
39575: LD_INT 1
39577: NEG
39578: PUSH
39579: EMPTY
39580: LIST
39581: LIST
39582: PUSH
39583: LD_INT 1
39585: NEG
39586: PUSH
39587: LD_INT 2
39589: NEG
39590: PUSH
39591: EMPTY
39592: LIST
39593: LIST
39594: PUSH
39595: LD_INT 1
39597: PUSH
39598: LD_INT 2
39600: PUSH
39601: EMPTY
39602: LIST
39603: LIST
39604: PUSH
39605: EMPTY
39606: LIST
39607: LIST
39608: LIST
39609: LIST
39610: LIST
39611: LIST
39612: LIST
39613: LIST
39614: LIST
39615: ST_TO_ADDR
// fExt2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
39616: LD_ADDR_VAR 0 37
39620: PUSH
39621: LD_INT 0
39623: PUSH
39624: LD_INT 0
39626: PUSH
39627: EMPTY
39628: LIST
39629: LIST
39630: PUSH
39631: LD_INT 0
39633: PUSH
39634: LD_INT 1
39636: NEG
39637: PUSH
39638: EMPTY
39639: LIST
39640: LIST
39641: PUSH
39642: LD_INT 1
39644: PUSH
39645: LD_INT 0
39647: PUSH
39648: EMPTY
39649: LIST
39650: LIST
39651: PUSH
39652: LD_INT 1
39654: PUSH
39655: LD_INT 1
39657: PUSH
39658: EMPTY
39659: LIST
39660: LIST
39661: PUSH
39662: LD_INT 0
39664: PUSH
39665: LD_INT 1
39667: PUSH
39668: EMPTY
39669: LIST
39670: LIST
39671: PUSH
39672: LD_INT 1
39674: NEG
39675: PUSH
39676: LD_INT 0
39678: PUSH
39679: EMPTY
39680: LIST
39681: LIST
39682: PUSH
39683: LD_INT 1
39685: NEG
39686: PUSH
39687: LD_INT 1
39689: NEG
39690: PUSH
39691: EMPTY
39692: LIST
39693: LIST
39694: PUSH
39695: LD_INT 1
39697: PUSH
39698: LD_INT 1
39700: NEG
39701: PUSH
39702: EMPTY
39703: LIST
39704: LIST
39705: PUSH
39706: LD_INT 1
39708: NEG
39709: PUSH
39710: LD_INT 1
39712: PUSH
39713: EMPTY
39714: LIST
39715: LIST
39716: PUSH
39717: EMPTY
39718: LIST
39719: LIST
39720: LIST
39721: LIST
39722: LIST
39723: LIST
39724: LIST
39725: LIST
39726: LIST
39727: ST_TO_ADDR
// fExt3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
39728: LD_ADDR_VAR 0 38
39732: PUSH
39733: LD_INT 0
39735: PUSH
39736: LD_INT 0
39738: PUSH
39739: EMPTY
39740: LIST
39741: LIST
39742: PUSH
39743: LD_INT 0
39745: PUSH
39746: LD_INT 1
39748: NEG
39749: PUSH
39750: EMPTY
39751: LIST
39752: LIST
39753: PUSH
39754: LD_INT 1
39756: PUSH
39757: LD_INT 0
39759: PUSH
39760: EMPTY
39761: LIST
39762: LIST
39763: PUSH
39764: LD_INT 1
39766: PUSH
39767: LD_INT 1
39769: PUSH
39770: EMPTY
39771: LIST
39772: LIST
39773: PUSH
39774: LD_INT 0
39776: PUSH
39777: LD_INT 1
39779: PUSH
39780: EMPTY
39781: LIST
39782: LIST
39783: PUSH
39784: LD_INT 1
39786: NEG
39787: PUSH
39788: LD_INT 0
39790: PUSH
39791: EMPTY
39792: LIST
39793: LIST
39794: PUSH
39795: LD_INT 1
39797: NEG
39798: PUSH
39799: LD_INT 1
39801: NEG
39802: PUSH
39803: EMPTY
39804: LIST
39805: LIST
39806: PUSH
39807: LD_INT 2
39809: PUSH
39810: LD_INT 1
39812: PUSH
39813: EMPTY
39814: LIST
39815: LIST
39816: PUSH
39817: LD_INT 2
39819: NEG
39820: PUSH
39821: LD_INT 1
39823: NEG
39824: PUSH
39825: EMPTY
39826: LIST
39827: LIST
39828: PUSH
39829: EMPTY
39830: LIST
39831: LIST
39832: LIST
39833: LIST
39834: LIST
39835: LIST
39836: LIST
39837: LIST
39838: LIST
39839: ST_TO_ADDR
// fExt4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
39840: LD_ADDR_VAR 0 39
39844: PUSH
39845: LD_INT 0
39847: PUSH
39848: LD_INT 0
39850: PUSH
39851: EMPTY
39852: LIST
39853: LIST
39854: PUSH
39855: LD_INT 0
39857: PUSH
39858: LD_INT 1
39860: NEG
39861: PUSH
39862: EMPTY
39863: LIST
39864: LIST
39865: PUSH
39866: LD_INT 1
39868: PUSH
39869: LD_INT 0
39871: PUSH
39872: EMPTY
39873: LIST
39874: LIST
39875: PUSH
39876: LD_INT 1
39878: PUSH
39879: LD_INT 1
39881: PUSH
39882: EMPTY
39883: LIST
39884: LIST
39885: PUSH
39886: LD_INT 0
39888: PUSH
39889: LD_INT 1
39891: PUSH
39892: EMPTY
39893: LIST
39894: LIST
39895: PUSH
39896: LD_INT 1
39898: NEG
39899: PUSH
39900: LD_INT 0
39902: PUSH
39903: EMPTY
39904: LIST
39905: LIST
39906: PUSH
39907: LD_INT 1
39909: NEG
39910: PUSH
39911: LD_INT 1
39913: NEG
39914: PUSH
39915: EMPTY
39916: LIST
39917: LIST
39918: PUSH
39919: LD_INT 1
39921: NEG
39922: PUSH
39923: LD_INT 2
39925: NEG
39926: PUSH
39927: EMPTY
39928: LIST
39929: LIST
39930: PUSH
39931: LD_INT 1
39933: PUSH
39934: LD_INT 2
39936: PUSH
39937: EMPTY
39938: LIST
39939: LIST
39940: PUSH
39941: EMPTY
39942: LIST
39943: LIST
39944: LIST
39945: LIST
39946: LIST
39947: LIST
39948: LIST
39949: LIST
39950: LIST
39951: ST_TO_ADDR
// fExt5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
39952: LD_ADDR_VAR 0 40
39956: PUSH
39957: LD_INT 0
39959: PUSH
39960: LD_INT 0
39962: PUSH
39963: EMPTY
39964: LIST
39965: LIST
39966: PUSH
39967: LD_INT 0
39969: PUSH
39970: LD_INT 1
39972: NEG
39973: PUSH
39974: EMPTY
39975: LIST
39976: LIST
39977: PUSH
39978: LD_INT 1
39980: PUSH
39981: LD_INT 0
39983: PUSH
39984: EMPTY
39985: LIST
39986: LIST
39987: PUSH
39988: LD_INT 1
39990: PUSH
39991: LD_INT 1
39993: PUSH
39994: EMPTY
39995: LIST
39996: LIST
39997: PUSH
39998: LD_INT 0
40000: PUSH
40001: LD_INT 1
40003: PUSH
40004: EMPTY
40005: LIST
40006: LIST
40007: PUSH
40008: LD_INT 1
40010: NEG
40011: PUSH
40012: LD_INT 0
40014: PUSH
40015: EMPTY
40016: LIST
40017: LIST
40018: PUSH
40019: LD_INT 1
40021: NEG
40022: PUSH
40023: LD_INT 1
40025: NEG
40026: PUSH
40027: EMPTY
40028: LIST
40029: LIST
40030: PUSH
40031: LD_INT 1
40033: PUSH
40034: LD_INT 1
40036: NEG
40037: PUSH
40038: EMPTY
40039: LIST
40040: LIST
40041: PUSH
40042: LD_INT 1
40044: NEG
40045: PUSH
40046: LD_INT 1
40048: PUSH
40049: EMPTY
40050: LIST
40051: LIST
40052: PUSH
40053: EMPTY
40054: LIST
40055: LIST
40056: LIST
40057: LIST
40058: LIST
40059: LIST
40060: LIST
40061: LIST
40062: LIST
40063: ST_TO_ADDR
// fLab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
40064: LD_ADDR_VAR 0 41
40068: PUSH
40069: LD_INT 0
40071: PUSH
40072: LD_INT 0
40074: PUSH
40075: EMPTY
40076: LIST
40077: LIST
40078: PUSH
40079: LD_INT 0
40081: PUSH
40082: LD_INT 1
40084: NEG
40085: PUSH
40086: EMPTY
40087: LIST
40088: LIST
40089: PUSH
40090: LD_INT 1
40092: PUSH
40093: LD_INT 0
40095: PUSH
40096: EMPTY
40097: LIST
40098: LIST
40099: PUSH
40100: LD_INT 1
40102: PUSH
40103: LD_INT 1
40105: PUSH
40106: EMPTY
40107: LIST
40108: LIST
40109: PUSH
40110: LD_INT 0
40112: PUSH
40113: LD_INT 1
40115: PUSH
40116: EMPTY
40117: LIST
40118: LIST
40119: PUSH
40120: LD_INT 1
40122: NEG
40123: PUSH
40124: LD_INT 0
40126: PUSH
40127: EMPTY
40128: LIST
40129: LIST
40130: PUSH
40131: LD_INT 1
40133: NEG
40134: PUSH
40135: LD_INT 1
40137: NEG
40138: PUSH
40139: EMPTY
40140: LIST
40141: LIST
40142: PUSH
40143: LD_INT 1
40145: NEG
40146: PUSH
40147: LD_INT 2
40149: NEG
40150: PUSH
40151: EMPTY
40152: LIST
40153: LIST
40154: PUSH
40155: LD_INT 1
40157: PUSH
40158: LD_INT 1
40160: NEG
40161: PUSH
40162: EMPTY
40163: LIST
40164: LIST
40165: PUSH
40166: LD_INT 2
40168: PUSH
40169: LD_INT 0
40171: PUSH
40172: EMPTY
40173: LIST
40174: LIST
40175: PUSH
40176: LD_INT 2
40178: PUSH
40179: LD_INT 1
40181: PUSH
40182: EMPTY
40183: LIST
40184: LIST
40185: PUSH
40186: LD_INT 2
40188: PUSH
40189: LD_INT 2
40191: PUSH
40192: EMPTY
40193: LIST
40194: LIST
40195: PUSH
40196: LD_INT 1
40198: PUSH
40199: LD_INT 2
40201: PUSH
40202: EMPTY
40203: LIST
40204: LIST
40205: PUSH
40206: LD_INT 1
40208: NEG
40209: PUSH
40210: LD_INT 1
40212: PUSH
40213: EMPTY
40214: LIST
40215: LIST
40216: PUSH
40217: LD_INT 2
40219: NEG
40220: PUSH
40221: LD_INT 0
40223: PUSH
40224: EMPTY
40225: LIST
40226: LIST
40227: PUSH
40228: LD_INT 2
40230: NEG
40231: PUSH
40232: LD_INT 1
40234: NEG
40235: PUSH
40236: EMPTY
40237: LIST
40238: LIST
40239: PUSH
40240: LD_INT 2
40242: NEG
40243: PUSH
40244: LD_INT 2
40246: NEG
40247: PUSH
40248: EMPTY
40249: LIST
40250: LIST
40251: PUSH
40252: LD_INT 2
40254: NEG
40255: PUSH
40256: LD_INT 3
40258: NEG
40259: PUSH
40260: EMPTY
40261: LIST
40262: LIST
40263: PUSH
40264: LD_INT 2
40266: PUSH
40267: LD_INT 1
40269: NEG
40270: PUSH
40271: EMPTY
40272: LIST
40273: LIST
40274: PUSH
40275: LD_INT 3
40277: PUSH
40278: LD_INT 0
40280: PUSH
40281: EMPTY
40282: LIST
40283: LIST
40284: PUSH
40285: LD_INT 3
40287: PUSH
40288: LD_INT 1
40290: PUSH
40291: EMPTY
40292: LIST
40293: LIST
40294: PUSH
40295: LD_INT 3
40297: PUSH
40298: LD_INT 2
40300: PUSH
40301: EMPTY
40302: LIST
40303: LIST
40304: PUSH
40305: LD_INT 3
40307: PUSH
40308: LD_INT 3
40310: PUSH
40311: EMPTY
40312: LIST
40313: LIST
40314: PUSH
40315: LD_INT 2
40317: PUSH
40318: LD_INT 3
40320: PUSH
40321: EMPTY
40322: LIST
40323: LIST
40324: PUSH
40325: LD_INT 2
40327: NEG
40328: PUSH
40329: LD_INT 1
40331: PUSH
40332: EMPTY
40333: LIST
40334: LIST
40335: PUSH
40336: LD_INT 3
40338: NEG
40339: PUSH
40340: LD_INT 0
40342: PUSH
40343: EMPTY
40344: LIST
40345: LIST
40346: PUSH
40347: LD_INT 3
40349: NEG
40350: PUSH
40351: LD_INT 1
40353: NEG
40354: PUSH
40355: EMPTY
40356: LIST
40357: LIST
40358: PUSH
40359: LD_INT 3
40361: NEG
40362: PUSH
40363: LD_INT 2
40365: NEG
40366: PUSH
40367: EMPTY
40368: LIST
40369: LIST
40370: PUSH
40371: LD_INT 3
40373: NEG
40374: PUSH
40375: LD_INT 3
40377: NEG
40378: PUSH
40379: EMPTY
40380: LIST
40381: LIST
40382: PUSH
40383: EMPTY
40384: LIST
40385: LIST
40386: LIST
40387: LIST
40388: LIST
40389: LIST
40390: LIST
40391: LIST
40392: LIST
40393: LIST
40394: LIST
40395: LIST
40396: LIST
40397: LIST
40398: LIST
40399: LIST
40400: LIST
40401: LIST
40402: LIST
40403: LIST
40404: LIST
40405: LIST
40406: LIST
40407: LIST
40408: LIST
40409: LIST
40410: LIST
40411: LIST
40412: LIST
40413: ST_TO_ADDR
// fLab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
40414: LD_ADDR_VAR 0 42
40418: PUSH
40419: LD_INT 0
40421: PUSH
40422: LD_INT 0
40424: PUSH
40425: EMPTY
40426: LIST
40427: LIST
40428: PUSH
40429: LD_INT 0
40431: PUSH
40432: LD_INT 1
40434: NEG
40435: PUSH
40436: EMPTY
40437: LIST
40438: LIST
40439: PUSH
40440: LD_INT 1
40442: PUSH
40443: LD_INT 0
40445: PUSH
40446: EMPTY
40447: LIST
40448: LIST
40449: PUSH
40450: LD_INT 1
40452: PUSH
40453: LD_INT 1
40455: PUSH
40456: EMPTY
40457: LIST
40458: LIST
40459: PUSH
40460: LD_INT 0
40462: PUSH
40463: LD_INT 1
40465: PUSH
40466: EMPTY
40467: LIST
40468: LIST
40469: PUSH
40470: LD_INT 1
40472: NEG
40473: PUSH
40474: LD_INT 0
40476: PUSH
40477: EMPTY
40478: LIST
40479: LIST
40480: PUSH
40481: LD_INT 1
40483: NEG
40484: PUSH
40485: LD_INT 1
40487: NEG
40488: PUSH
40489: EMPTY
40490: LIST
40491: LIST
40492: PUSH
40493: LD_INT 1
40495: NEG
40496: PUSH
40497: LD_INT 2
40499: NEG
40500: PUSH
40501: EMPTY
40502: LIST
40503: LIST
40504: PUSH
40505: LD_INT 0
40507: PUSH
40508: LD_INT 2
40510: NEG
40511: PUSH
40512: EMPTY
40513: LIST
40514: LIST
40515: PUSH
40516: LD_INT 1
40518: PUSH
40519: LD_INT 1
40521: NEG
40522: PUSH
40523: EMPTY
40524: LIST
40525: LIST
40526: PUSH
40527: LD_INT 2
40529: PUSH
40530: LD_INT 1
40532: PUSH
40533: EMPTY
40534: LIST
40535: LIST
40536: PUSH
40537: LD_INT 2
40539: PUSH
40540: LD_INT 2
40542: PUSH
40543: EMPTY
40544: LIST
40545: LIST
40546: PUSH
40547: LD_INT 1
40549: PUSH
40550: LD_INT 2
40552: PUSH
40553: EMPTY
40554: LIST
40555: LIST
40556: PUSH
40557: LD_INT 0
40559: PUSH
40560: LD_INT 2
40562: PUSH
40563: EMPTY
40564: LIST
40565: LIST
40566: PUSH
40567: LD_INT 1
40569: NEG
40570: PUSH
40571: LD_INT 1
40573: PUSH
40574: EMPTY
40575: LIST
40576: LIST
40577: PUSH
40578: LD_INT 2
40580: NEG
40581: PUSH
40582: LD_INT 1
40584: NEG
40585: PUSH
40586: EMPTY
40587: LIST
40588: LIST
40589: PUSH
40590: LD_INT 2
40592: NEG
40593: PUSH
40594: LD_INT 2
40596: NEG
40597: PUSH
40598: EMPTY
40599: LIST
40600: LIST
40601: PUSH
40602: LD_INT 2
40604: NEG
40605: PUSH
40606: LD_INT 3
40608: NEG
40609: PUSH
40610: EMPTY
40611: LIST
40612: LIST
40613: PUSH
40614: LD_INT 1
40616: NEG
40617: PUSH
40618: LD_INT 3
40620: NEG
40621: PUSH
40622: EMPTY
40623: LIST
40624: LIST
40625: PUSH
40626: LD_INT 0
40628: PUSH
40629: LD_INT 3
40631: NEG
40632: PUSH
40633: EMPTY
40634: LIST
40635: LIST
40636: PUSH
40637: LD_INT 1
40639: PUSH
40640: LD_INT 2
40642: NEG
40643: PUSH
40644: EMPTY
40645: LIST
40646: LIST
40647: PUSH
40648: LD_INT 3
40650: PUSH
40651: LD_INT 2
40653: PUSH
40654: EMPTY
40655: LIST
40656: LIST
40657: PUSH
40658: LD_INT 3
40660: PUSH
40661: LD_INT 3
40663: PUSH
40664: EMPTY
40665: LIST
40666: LIST
40667: PUSH
40668: LD_INT 2
40670: PUSH
40671: LD_INT 3
40673: PUSH
40674: EMPTY
40675: LIST
40676: LIST
40677: PUSH
40678: LD_INT 1
40680: PUSH
40681: LD_INT 3
40683: PUSH
40684: EMPTY
40685: LIST
40686: LIST
40687: PUSH
40688: LD_INT 0
40690: PUSH
40691: LD_INT 3
40693: PUSH
40694: EMPTY
40695: LIST
40696: LIST
40697: PUSH
40698: LD_INT 1
40700: NEG
40701: PUSH
40702: LD_INT 2
40704: PUSH
40705: EMPTY
40706: LIST
40707: LIST
40708: PUSH
40709: LD_INT 3
40711: NEG
40712: PUSH
40713: LD_INT 2
40715: NEG
40716: PUSH
40717: EMPTY
40718: LIST
40719: LIST
40720: PUSH
40721: LD_INT 3
40723: NEG
40724: PUSH
40725: LD_INT 3
40727: NEG
40728: PUSH
40729: EMPTY
40730: LIST
40731: LIST
40732: PUSH
40733: EMPTY
40734: LIST
40735: LIST
40736: LIST
40737: LIST
40738: LIST
40739: LIST
40740: LIST
40741: LIST
40742: LIST
40743: LIST
40744: LIST
40745: LIST
40746: LIST
40747: LIST
40748: LIST
40749: LIST
40750: LIST
40751: LIST
40752: LIST
40753: LIST
40754: LIST
40755: LIST
40756: LIST
40757: LIST
40758: LIST
40759: LIST
40760: LIST
40761: LIST
40762: LIST
40763: ST_TO_ADDR
// fLab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
40764: LD_ADDR_VAR 0 43
40768: PUSH
40769: LD_INT 0
40771: PUSH
40772: LD_INT 0
40774: PUSH
40775: EMPTY
40776: LIST
40777: LIST
40778: PUSH
40779: LD_INT 0
40781: PUSH
40782: LD_INT 1
40784: NEG
40785: PUSH
40786: EMPTY
40787: LIST
40788: LIST
40789: PUSH
40790: LD_INT 1
40792: PUSH
40793: LD_INT 0
40795: PUSH
40796: EMPTY
40797: LIST
40798: LIST
40799: PUSH
40800: LD_INT 1
40802: PUSH
40803: LD_INT 1
40805: PUSH
40806: EMPTY
40807: LIST
40808: LIST
40809: PUSH
40810: LD_INT 0
40812: PUSH
40813: LD_INT 1
40815: PUSH
40816: EMPTY
40817: LIST
40818: LIST
40819: PUSH
40820: LD_INT 1
40822: NEG
40823: PUSH
40824: LD_INT 0
40826: PUSH
40827: EMPTY
40828: LIST
40829: LIST
40830: PUSH
40831: LD_INT 1
40833: NEG
40834: PUSH
40835: LD_INT 1
40837: NEG
40838: PUSH
40839: EMPTY
40840: LIST
40841: LIST
40842: PUSH
40843: LD_INT 1
40845: NEG
40846: PUSH
40847: LD_INT 2
40849: NEG
40850: PUSH
40851: EMPTY
40852: LIST
40853: LIST
40854: PUSH
40855: LD_INT 0
40857: PUSH
40858: LD_INT 2
40860: NEG
40861: PUSH
40862: EMPTY
40863: LIST
40864: LIST
40865: PUSH
40866: LD_INT 1
40868: PUSH
40869: LD_INT 1
40871: NEG
40872: PUSH
40873: EMPTY
40874: LIST
40875: LIST
40876: PUSH
40877: LD_INT 2
40879: PUSH
40880: LD_INT 0
40882: PUSH
40883: EMPTY
40884: LIST
40885: LIST
40886: PUSH
40887: LD_INT 2
40889: PUSH
40890: LD_INT 1
40892: PUSH
40893: EMPTY
40894: LIST
40895: LIST
40896: PUSH
40897: LD_INT 1
40899: PUSH
40900: LD_INT 2
40902: PUSH
40903: EMPTY
40904: LIST
40905: LIST
40906: PUSH
40907: LD_INT 0
40909: PUSH
40910: LD_INT 2
40912: PUSH
40913: EMPTY
40914: LIST
40915: LIST
40916: PUSH
40917: LD_INT 1
40919: NEG
40920: PUSH
40921: LD_INT 1
40923: PUSH
40924: EMPTY
40925: LIST
40926: LIST
40927: PUSH
40928: LD_INT 2
40930: NEG
40931: PUSH
40932: LD_INT 0
40934: PUSH
40935: EMPTY
40936: LIST
40937: LIST
40938: PUSH
40939: LD_INT 2
40941: NEG
40942: PUSH
40943: LD_INT 1
40945: NEG
40946: PUSH
40947: EMPTY
40948: LIST
40949: LIST
40950: PUSH
40951: LD_INT 1
40953: NEG
40954: PUSH
40955: LD_INT 3
40957: NEG
40958: PUSH
40959: EMPTY
40960: LIST
40961: LIST
40962: PUSH
40963: LD_INT 0
40965: PUSH
40966: LD_INT 3
40968: NEG
40969: PUSH
40970: EMPTY
40971: LIST
40972: LIST
40973: PUSH
40974: LD_INT 1
40976: PUSH
40977: LD_INT 2
40979: NEG
40980: PUSH
40981: EMPTY
40982: LIST
40983: LIST
40984: PUSH
40985: LD_INT 2
40987: PUSH
40988: LD_INT 1
40990: NEG
40991: PUSH
40992: EMPTY
40993: LIST
40994: LIST
40995: PUSH
40996: LD_INT 3
40998: PUSH
40999: LD_INT 0
41001: PUSH
41002: EMPTY
41003: LIST
41004: LIST
41005: PUSH
41006: LD_INT 3
41008: PUSH
41009: LD_INT 1
41011: PUSH
41012: EMPTY
41013: LIST
41014: LIST
41015: PUSH
41016: LD_INT 1
41018: PUSH
41019: LD_INT 3
41021: PUSH
41022: EMPTY
41023: LIST
41024: LIST
41025: PUSH
41026: LD_INT 0
41028: PUSH
41029: LD_INT 3
41031: PUSH
41032: EMPTY
41033: LIST
41034: LIST
41035: PUSH
41036: LD_INT 1
41038: NEG
41039: PUSH
41040: LD_INT 2
41042: PUSH
41043: EMPTY
41044: LIST
41045: LIST
41046: PUSH
41047: LD_INT 2
41049: NEG
41050: PUSH
41051: LD_INT 1
41053: PUSH
41054: EMPTY
41055: LIST
41056: LIST
41057: PUSH
41058: LD_INT 3
41060: NEG
41061: PUSH
41062: LD_INT 0
41064: PUSH
41065: EMPTY
41066: LIST
41067: LIST
41068: PUSH
41069: LD_INT 3
41071: NEG
41072: PUSH
41073: LD_INT 1
41075: NEG
41076: PUSH
41077: EMPTY
41078: LIST
41079: LIST
41080: PUSH
41081: EMPTY
41082: LIST
41083: LIST
41084: LIST
41085: LIST
41086: LIST
41087: LIST
41088: LIST
41089: LIST
41090: LIST
41091: LIST
41092: LIST
41093: LIST
41094: LIST
41095: LIST
41096: LIST
41097: LIST
41098: LIST
41099: LIST
41100: LIST
41101: LIST
41102: LIST
41103: LIST
41104: LIST
41105: LIST
41106: LIST
41107: LIST
41108: LIST
41109: LIST
41110: LIST
41111: ST_TO_ADDR
// fLab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
41112: LD_ADDR_VAR 0 44
41116: PUSH
41117: LD_INT 0
41119: PUSH
41120: LD_INT 0
41122: PUSH
41123: EMPTY
41124: LIST
41125: LIST
41126: PUSH
41127: LD_INT 0
41129: PUSH
41130: LD_INT 1
41132: NEG
41133: PUSH
41134: EMPTY
41135: LIST
41136: LIST
41137: PUSH
41138: LD_INT 1
41140: PUSH
41141: LD_INT 0
41143: PUSH
41144: EMPTY
41145: LIST
41146: LIST
41147: PUSH
41148: LD_INT 1
41150: PUSH
41151: LD_INT 1
41153: PUSH
41154: EMPTY
41155: LIST
41156: LIST
41157: PUSH
41158: LD_INT 0
41160: PUSH
41161: LD_INT 1
41163: PUSH
41164: EMPTY
41165: LIST
41166: LIST
41167: PUSH
41168: LD_INT 1
41170: NEG
41171: PUSH
41172: LD_INT 0
41174: PUSH
41175: EMPTY
41176: LIST
41177: LIST
41178: PUSH
41179: LD_INT 1
41181: NEG
41182: PUSH
41183: LD_INT 1
41185: NEG
41186: PUSH
41187: EMPTY
41188: LIST
41189: LIST
41190: PUSH
41191: LD_INT 1
41193: NEG
41194: PUSH
41195: LD_INT 2
41197: NEG
41198: PUSH
41199: EMPTY
41200: LIST
41201: LIST
41202: PUSH
41203: LD_INT 1
41205: PUSH
41206: LD_INT 1
41208: NEG
41209: PUSH
41210: EMPTY
41211: LIST
41212: LIST
41213: PUSH
41214: LD_INT 2
41216: PUSH
41217: LD_INT 0
41219: PUSH
41220: EMPTY
41221: LIST
41222: LIST
41223: PUSH
41224: LD_INT 2
41226: PUSH
41227: LD_INT 1
41229: PUSH
41230: EMPTY
41231: LIST
41232: LIST
41233: PUSH
41234: LD_INT 2
41236: PUSH
41237: LD_INT 2
41239: PUSH
41240: EMPTY
41241: LIST
41242: LIST
41243: PUSH
41244: LD_INT 1
41246: PUSH
41247: LD_INT 2
41249: PUSH
41250: EMPTY
41251: LIST
41252: LIST
41253: PUSH
41254: LD_INT 1
41256: NEG
41257: PUSH
41258: LD_INT 1
41260: PUSH
41261: EMPTY
41262: LIST
41263: LIST
41264: PUSH
41265: LD_INT 2
41267: NEG
41268: PUSH
41269: LD_INT 0
41271: PUSH
41272: EMPTY
41273: LIST
41274: LIST
41275: PUSH
41276: LD_INT 2
41278: NEG
41279: PUSH
41280: LD_INT 1
41282: NEG
41283: PUSH
41284: EMPTY
41285: LIST
41286: LIST
41287: PUSH
41288: LD_INT 2
41290: NEG
41291: PUSH
41292: LD_INT 2
41294: NEG
41295: PUSH
41296: EMPTY
41297: LIST
41298: LIST
41299: PUSH
41300: LD_INT 2
41302: NEG
41303: PUSH
41304: LD_INT 3
41306: NEG
41307: PUSH
41308: EMPTY
41309: LIST
41310: LIST
41311: PUSH
41312: LD_INT 2
41314: PUSH
41315: LD_INT 1
41317: NEG
41318: PUSH
41319: EMPTY
41320: LIST
41321: LIST
41322: PUSH
41323: LD_INT 3
41325: PUSH
41326: LD_INT 0
41328: PUSH
41329: EMPTY
41330: LIST
41331: LIST
41332: PUSH
41333: LD_INT 3
41335: PUSH
41336: LD_INT 1
41338: PUSH
41339: EMPTY
41340: LIST
41341: LIST
41342: PUSH
41343: LD_INT 3
41345: PUSH
41346: LD_INT 2
41348: PUSH
41349: EMPTY
41350: LIST
41351: LIST
41352: PUSH
41353: LD_INT 3
41355: PUSH
41356: LD_INT 3
41358: PUSH
41359: EMPTY
41360: LIST
41361: LIST
41362: PUSH
41363: LD_INT 2
41365: PUSH
41366: LD_INT 3
41368: PUSH
41369: EMPTY
41370: LIST
41371: LIST
41372: PUSH
41373: LD_INT 2
41375: NEG
41376: PUSH
41377: LD_INT 1
41379: PUSH
41380: EMPTY
41381: LIST
41382: LIST
41383: PUSH
41384: LD_INT 3
41386: NEG
41387: PUSH
41388: LD_INT 0
41390: PUSH
41391: EMPTY
41392: LIST
41393: LIST
41394: PUSH
41395: LD_INT 3
41397: NEG
41398: PUSH
41399: LD_INT 1
41401: NEG
41402: PUSH
41403: EMPTY
41404: LIST
41405: LIST
41406: PUSH
41407: LD_INT 3
41409: NEG
41410: PUSH
41411: LD_INT 2
41413: NEG
41414: PUSH
41415: EMPTY
41416: LIST
41417: LIST
41418: PUSH
41419: LD_INT 3
41421: NEG
41422: PUSH
41423: LD_INT 3
41425: NEG
41426: PUSH
41427: EMPTY
41428: LIST
41429: LIST
41430: PUSH
41431: EMPTY
41432: LIST
41433: LIST
41434: LIST
41435: LIST
41436: LIST
41437: LIST
41438: LIST
41439: LIST
41440: LIST
41441: LIST
41442: LIST
41443: LIST
41444: LIST
41445: LIST
41446: LIST
41447: LIST
41448: LIST
41449: LIST
41450: LIST
41451: LIST
41452: LIST
41453: LIST
41454: LIST
41455: LIST
41456: LIST
41457: LIST
41458: LIST
41459: LIST
41460: LIST
41461: ST_TO_ADDR
// fLab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
41462: LD_ADDR_VAR 0 45
41466: PUSH
41467: LD_INT 0
41469: PUSH
41470: LD_INT 0
41472: PUSH
41473: EMPTY
41474: LIST
41475: LIST
41476: PUSH
41477: LD_INT 0
41479: PUSH
41480: LD_INT 1
41482: NEG
41483: PUSH
41484: EMPTY
41485: LIST
41486: LIST
41487: PUSH
41488: LD_INT 1
41490: PUSH
41491: LD_INT 0
41493: PUSH
41494: EMPTY
41495: LIST
41496: LIST
41497: PUSH
41498: LD_INT 1
41500: PUSH
41501: LD_INT 1
41503: PUSH
41504: EMPTY
41505: LIST
41506: LIST
41507: PUSH
41508: LD_INT 0
41510: PUSH
41511: LD_INT 1
41513: PUSH
41514: EMPTY
41515: LIST
41516: LIST
41517: PUSH
41518: LD_INT 1
41520: NEG
41521: PUSH
41522: LD_INT 0
41524: PUSH
41525: EMPTY
41526: LIST
41527: LIST
41528: PUSH
41529: LD_INT 1
41531: NEG
41532: PUSH
41533: LD_INT 1
41535: NEG
41536: PUSH
41537: EMPTY
41538: LIST
41539: LIST
41540: PUSH
41541: LD_INT 1
41543: NEG
41544: PUSH
41545: LD_INT 2
41547: NEG
41548: PUSH
41549: EMPTY
41550: LIST
41551: LIST
41552: PUSH
41553: LD_INT 0
41555: PUSH
41556: LD_INT 2
41558: NEG
41559: PUSH
41560: EMPTY
41561: LIST
41562: LIST
41563: PUSH
41564: LD_INT 1
41566: PUSH
41567: LD_INT 1
41569: NEG
41570: PUSH
41571: EMPTY
41572: LIST
41573: LIST
41574: PUSH
41575: LD_INT 2
41577: PUSH
41578: LD_INT 1
41580: PUSH
41581: EMPTY
41582: LIST
41583: LIST
41584: PUSH
41585: LD_INT 2
41587: PUSH
41588: LD_INT 2
41590: PUSH
41591: EMPTY
41592: LIST
41593: LIST
41594: PUSH
41595: LD_INT 1
41597: PUSH
41598: LD_INT 2
41600: PUSH
41601: EMPTY
41602: LIST
41603: LIST
41604: PUSH
41605: LD_INT 0
41607: PUSH
41608: LD_INT 2
41610: PUSH
41611: EMPTY
41612: LIST
41613: LIST
41614: PUSH
41615: LD_INT 1
41617: NEG
41618: PUSH
41619: LD_INT 1
41621: PUSH
41622: EMPTY
41623: LIST
41624: LIST
41625: PUSH
41626: LD_INT 2
41628: NEG
41629: PUSH
41630: LD_INT 1
41632: NEG
41633: PUSH
41634: EMPTY
41635: LIST
41636: LIST
41637: PUSH
41638: LD_INT 2
41640: NEG
41641: PUSH
41642: LD_INT 2
41644: NEG
41645: PUSH
41646: EMPTY
41647: LIST
41648: LIST
41649: PUSH
41650: LD_INT 2
41652: NEG
41653: PUSH
41654: LD_INT 3
41656: NEG
41657: PUSH
41658: EMPTY
41659: LIST
41660: LIST
41661: PUSH
41662: LD_INT 1
41664: NEG
41665: PUSH
41666: LD_INT 3
41668: NEG
41669: PUSH
41670: EMPTY
41671: LIST
41672: LIST
41673: PUSH
41674: LD_INT 0
41676: PUSH
41677: LD_INT 3
41679: NEG
41680: PUSH
41681: EMPTY
41682: LIST
41683: LIST
41684: PUSH
41685: LD_INT 1
41687: PUSH
41688: LD_INT 2
41690: NEG
41691: PUSH
41692: EMPTY
41693: LIST
41694: LIST
41695: PUSH
41696: LD_INT 3
41698: PUSH
41699: LD_INT 2
41701: PUSH
41702: EMPTY
41703: LIST
41704: LIST
41705: PUSH
41706: LD_INT 3
41708: PUSH
41709: LD_INT 3
41711: PUSH
41712: EMPTY
41713: LIST
41714: LIST
41715: PUSH
41716: LD_INT 2
41718: PUSH
41719: LD_INT 3
41721: PUSH
41722: EMPTY
41723: LIST
41724: LIST
41725: PUSH
41726: LD_INT 1
41728: PUSH
41729: LD_INT 3
41731: PUSH
41732: EMPTY
41733: LIST
41734: LIST
41735: PUSH
41736: LD_INT 0
41738: PUSH
41739: LD_INT 3
41741: PUSH
41742: EMPTY
41743: LIST
41744: LIST
41745: PUSH
41746: LD_INT 1
41748: NEG
41749: PUSH
41750: LD_INT 2
41752: PUSH
41753: EMPTY
41754: LIST
41755: LIST
41756: PUSH
41757: LD_INT 3
41759: NEG
41760: PUSH
41761: LD_INT 2
41763: NEG
41764: PUSH
41765: EMPTY
41766: LIST
41767: LIST
41768: PUSH
41769: LD_INT 3
41771: NEG
41772: PUSH
41773: LD_INT 3
41775: NEG
41776: PUSH
41777: EMPTY
41778: LIST
41779: LIST
41780: PUSH
41781: EMPTY
41782: LIST
41783: LIST
41784: LIST
41785: LIST
41786: LIST
41787: LIST
41788: LIST
41789: LIST
41790: LIST
41791: LIST
41792: LIST
41793: LIST
41794: LIST
41795: LIST
41796: LIST
41797: LIST
41798: LIST
41799: LIST
41800: LIST
41801: LIST
41802: LIST
41803: LIST
41804: LIST
41805: LIST
41806: LIST
41807: LIST
41808: LIST
41809: LIST
41810: LIST
41811: ST_TO_ADDR
// fLab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
41812: LD_ADDR_VAR 0 46
41816: PUSH
41817: LD_INT 0
41819: PUSH
41820: LD_INT 0
41822: PUSH
41823: EMPTY
41824: LIST
41825: LIST
41826: PUSH
41827: LD_INT 0
41829: PUSH
41830: LD_INT 1
41832: NEG
41833: PUSH
41834: EMPTY
41835: LIST
41836: LIST
41837: PUSH
41838: LD_INT 1
41840: PUSH
41841: LD_INT 0
41843: PUSH
41844: EMPTY
41845: LIST
41846: LIST
41847: PUSH
41848: LD_INT 1
41850: PUSH
41851: LD_INT 1
41853: PUSH
41854: EMPTY
41855: LIST
41856: LIST
41857: PUSH
41858: LD_INT 0
41860: PUSH
41861: LD_INT 1
41863: PUSH
41864: EMPTY
41865: LIST
41866: LIST
41867: PUSH
41868: LD_INT 1
41870: NEG
41871: PUSH
41872: LD_INT 0
41874: PUSH
41875: EMPTY
41876: LIST
41877: LIST
41878: PUSH
41879: LD_INT 1
41881: NEG
41882: PUSH
41883: LD_INT 1
41885: NEG
41886: PUSH
41887: EMPTY
41888: LIST
41889: LIST
41890: PUSH
41891: LD_INT 1
41893: NEG
41894: PUSH
41895: LD_INT 2
41897: NEG
41898: PUSH
41899: EMPTY
41900: LIST
41901: LIST
41902: PUSH
41903: LD_INT 0
41905: PUSH
41906: LD_INT 2
41908: NEG
41909: PUSH
41910: EMPTY
41911: LIST
41912: LIST
41913: PUSH
41914: LD_INT 1
41916: PUSH
41917: LD_INT 1
41919: NEG
41920: PUSH
41921: EMPTY
41922: LIST
41923: LIST
41924: PUSH
41925: LD_INT 2
41927: PUSH
41928: LD_INT 0
41930: PUSH
41931: EMPTY
41932: LIST
41933: LIST
41934: PUSH
41935: LD_INT 2
41937: PUSH
41938: LD_INT 1
41940: PUSH
41941: EMPTY
41942: LIST
41943: LIST
41944: PUSH
41945: LD_INT 1
41947: PUSH
41948: LD_INT 2
41950: PUSH
41951: EMPTY
41952: LIST
41953: LIST
41954: PUSH
41955: LD_INT 0
41957: PUSH
41958: LD_INT 2
41960: PUSH
41961: EMPTY
41962: LIST
41963: LIST
41964: PUSH
41965: LD_INT 1
41967: NEG
41968: PUSH
41969: LD_INT 1
41971: PUSH
41972: EMPTY
41973: LIST
41974: LIST
41975: PUSH
41976: LD_INT 2
41978: NEG
41979: PUSH
41980: LD_INT 0
41982: PUSH
41983: EMPTY
41984: LIST
41985: LIST
41986: PUSH
41987: LD_INT 2
41989: NEG
41990: PUSH
41991: LD_INT 1
41993: NEG
41994: PUSH
41995: EMPTY
41996: LIST
41997: LIST
41998: PUSH
41999: LD_INT 1
42001: NEG
42002: PUSH
42003: LD_INT 3
42005: NEG
42006: PUSH
42007: EMPTY
42008: LIST
42009: LIST
42010: PUSH
42011: LD_INT 0
42013: PUSH
42014: LD_INT 3
42016: NEG
42017: PUSH
42018: EMPTY
42019: LIST
42020: LIST
42021: PUSH
42022: LD_INT 1
42024: PUSH
42025: LD_INT 2
42027: NEG
42028: PUSH
42029: EMPTY
42030: LIST
42031: LIST
42032: PUSH
42033: LD_INT 2
42035: PUSH
42036: LD_INT 1
42038: NEG
42039: PUSH
42040: EMPTY
42041: LIST
42042: LIST
42043: PUSH
42044: LD_INT 3
42046: PUSH
42047: LD_INT 0
42049: PUSH
42050: EMPTY
42051: LIST
42052: LIST
42053: PUSH
42054: LD_INT 3
42056: PUSH
42057: LD_INT 1
42059: PUSH
42060: EMPTY
42061: LIST
42062: LIST
42063: PUSH
42064: LD_INT 1
42066: PUSH
42067: LD_INT 3
42069: PUSH
42070: EMPTY
42071: LIST
42072: LIST
42073: PUSH
42074: LD_INT 0
42076: PUSH
42077: LD_INT 3
42079: PUSH
42080: EMPTY
42081: LIST
42082: LIST
42083: PUSH
42084: LD_INT 1
42086: NEG
42087: PUSH
42088: LD_INT 2
42090: PUSH
42091: EMPTY
42092: LIST
42093: LIST
42094: PUSH
42095: LD_INT 2
42097: NEG
42098: PUSH
42099: LD_INT 1
42101: PUSH
42102: EMPTY
42103: LIST
42104: LIST
42105: PUSH
42106: LD_INT 3
42108: NEG
42109: PUSH
42110: LD_INT 0
42112: PUSH
42113: EMPTY
42114: LIST
42115: LIST
42116: PUSH
42117: LD_INT 3
42119: NEG
42120: PUSH
42121: LD_INT 1
42123: NEG
42124: PUSH
42125: EMPTY
42126: LIST
42127: LIST
42128: PUSH
42129: EMPTY
42130: LIST
42131: LIST
42132: LIST
42133: LIST
42134: LIST
42135: LIST
42136: LIST
42137: LIST
42138: LIST
42139: LIST
42140: LIST
42141: LIST
42142: LIST
42143: LIST
42144: LIST
42145: LIST
42146: LIST
42147: LIST
42148: LIST
42149: LIST
42150: LIST
42151: LIST
42152: LIST
42153: LIST
42154: LIST
42155: LIST
42156: LIST
42157: LIST
42158: LIST
42159: ST_TO_ADDR
// fControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
42160: LD_ADDR_VAR 0 47
42164: PUSH
42165: LD_INT 0
42167: PUSH
42168: LD_INT 0
42170: PUSH
42171: EMPTY
42172: LIST
42173: LIST
42174: PUSH
42175: LD_INT 0
42177: PUSH
42178: LD_INT 1
42180: NEG
42181: PUSH
42182: EMPTY
42183: LIST
42184: LIST
42185: PUSH
42186: LD_INT 1
42188: PUSH
42189: LD_INT 0
42191: PUSH
42192: EMPTY
42193: LIST
42194: LIST
42195: PUSH
42196: LD_INT 1
42198: PUSH
42199: LD_INT 1
42201: PUSH
42202: EMPTY
42203: LIST
42204: LIST
42205: PUSH
42206: LD_INT 0
42208: PUSH
42209: LD_INT 1
42211: PUSH
42212: EMPTY
42213: LIST
42214: LIST
42215: PUSH
42216: LD_INT 1
42218: NEG
42219: PUSH
42220: LD_INT 0
42222: PUSH
42223: EMPTY
42224: LIST
42225: LIST
42226: PUSH
42227: LD_INT 1
42229: NEG
42230: PUSH
42231: LD_INT 1
42233: NEG
42234: PUSH
42235: EMPTY
42236: LIST
42237: LIST
42238: PUSH
42239: LD_INT 1
42241: NEG
42242: PUSH
42243: LD_INT 2
42245: NEG
42246: PUSH
42247: EMPTY
42248: LIST
42249: LIST
42250: PUSH
42251: LD_INT 0
42253: PUSH
42254: LD_INT 2
42256: NEG
42257: PUSH
42258: EMPTY
42259: LIST
42260: LIST
42261: PUSH
42262: LD_INT 1
42264: PUSH
42265: LD_INT 1
42267: NEG
42268: PUSH
42269: EMPTY
42270: LIST
42271: LIST
42272: PUSH
42273: LD_INT 2
42275: NEG
42276: PUSH
42277: LD_INT 1
42279: NEG
42280: PUSH
42281: EMPTY
42282: LIST
42283: LIST
42284: PUSH
42285: LD_INT 2
42287: NEG
42288: PUSH
42289: LD_INT 2
42291: NEG
42292: PUSH
42293: EMPTY
42294: LIST
42295: LIST
42296: PUSH
42297: EMPTY
42298: LIST
42299: LIST
42300: LIST
42301: LIST
42302: LIST
42303: LIST
42304: LIST
42305: LIST
42306: LIST
42307: LIST
42308: LIST
42309: LIST
42310: ST_TO_ADDR
// fControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
42311: LD_ADDR_VAR 0 48
42315: PUSH
42316: LD_INT 0
42318: PUSH
42319: LD_INT 0
42321: PUSH
42322: EMPTY
42323: LIST
42324: LIST
42325: PUSH
42326: LD_INT 0
42328: PUSH
42329: LD_INT 1
42331: NEG
42332: PUSH
42333: EMPTY
42334: LIST
42335: LIST
42336: PUSH
42337: LD_INT 1
42339: PUSH
42340: LD_INT 0
42342: PUSH
42343: EMPTY
42344: LIST
42345: LIST
42346: PUSH
42347: LD_INT 1
42349: PUSH
42350: LD_INT 1
42352: PUSH
42353: EMPTY
42354: LIST
42355: LIST
42356: PUSH
42357: LD_INT 0
42359: PUSH
42360: LD_INT 1
42362: PUSH
42363: EMPTY
42364: LIST
42365: LIST
42366: PUSH
42367: LD_INT 1
42369: NEG
42370: PUSH
42371: LD_INT 0
42373: PUSH
42374: EMPTY
42375: LIST
42376: LIST
42377: PUSH
42378: LD_INT 1
42380: NEG
42381: PUSH
42382: LD_INT 1
42384: NEG
42385: PUSH
42386: EMPTY
42387: LIST
42388: LIST
42389: PUSH
42390: LD_INT 1
42392: NEG
42393: PUSH
42394: LD_INT 2
42396: NEG
42397: PUSH
42398: EMPTY
42399: LIST
42400: LIST
42401: PUSH
42402: LD_INT 0
42404: PUSH
42405: LD_INT 2
42407: NEG
42408: PUSH
42409: EMPTY
42410: LIST
42411: LIST
42412: PUSH
42413: LD_INT 1
42415: PUSH
42416: LD_INT 1
42418: NEG
42419: PUSH
42420: EMPTY
42421: LIST
42422: LIST
42423: PUSH
42424: LD_INT 2
42426: PUSH
42427: LD_INT 0
42429: PUSH
42430: EMPTY
42431: LIST
42432: LIST
42433: PUSH
42434: LD_INT 2
42436: PUSH
42437: LD_INT 1
42439: PUSH
42440: EMPTY
42441: LIST
42442: LIST
42443: PUSH
42444: EMPTY
42445: LIST
42446: LIST
42447: LIST
42448: LIST
42449: LIST
42450: LIST
42451: LIST
42452: LIST
42453: LIST
42454: LIST
42455: LIST
42456: LIST
42457: ST_TO_ADDR
// fControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
42458: LD_ADDR_VAR 0 49
42462: PUSH
42463: LD_INT 0
42465: PUSH
42466: LD_INT 0
42468: PUSH
42469: EMPTY
42470: LIST
42471: LIST
42472: PUSH
42473: LD_INT 0
42475: PUSH
42476: LD_INT 1
42478: NEG
42479: PUSH
42480: EMPTY
42481: LIST
42482: LIST
42483: PUSH
42484: LD_INT 1
42486: PUSH
42487: LD_INT 0
42489: PUSH
42490: EMPTY
42491: LIST
42492: LIST
42493: PUSH
42494: LD_INT 1
42496: PUSH
42497: LD_INT 1
42499: PUSH
42500: EMPTY
42501: LIST
42502: LIST
42503: PUSH
42504: LD_INT 0
42506: PUSH
42507: LD_INT 1
42509: PUSH
42510: EMPTY
42511: LIST
42512: LIST
42513: PUSH
42514: LD_INT 1
42516: NEG
42517: PUSH
42518: LD_INT 0
42520: PUSH
42521: EMPTY
42522: LIST
42523: LIST
42524: PUSH
42525: LD_INT 1
42527: NEG
42528: PUSH
42529: LD_INT 1
42531: NEG
42532: PUSH
42533: EMPTY
42534: LIST
42535: LIST
42536: PUSH
42537: LD_INT 1
42539: PUSH
42540: LD_INT 1
42542: NEG
42543: PUSH
42544: EMPTY
42545: LIST
42546: LIST
42547: PUSH
42548: LD_INT 2
42550: PUSH
42551: LD_INT 0
42553: PUSH
42554: EMPTY
42555: LIST
42556: LIST
42557: PUSH
42558: LD_INT 2
42560: PUSH
42561: LD_INT 1
42563: PUSH
42564: EMPTY
42565: LIST
42566: LIST
42567: PUSH
42568: LD_INT 2
42570: PUSH
42571: LD_INT 2
42573: PUSH
42574: EMPTY
42575: LIST
42576: LIST
42577: PUSH
42578: LD_INT 1
42580: PUSH
42581: LD_INT 2
42583: PUSH
42584: EMPTY
42585: LIST
42586: LIST
42587: PUSH
42588: EMPTY
42589: LIST
42590: LIST
42591: LIST
42592: LIST
42593: LIST
42594: LIST
42595: LIST
42596: LIST
42597: LIST
42598: LIST
42599: LIST
42600: LIST
42601: ST_TO_ADDR
// fControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
42602: LD_ADDR_VAR 0 50
42606: PUSH
42607: LD_INT 0
42609: PUSH
42610: LD_INT 0
42612: PUSH
42613: EMPTY
42614: LIST
42615: LIST
42616: PUSH
42617: LD_INT 0
42619: PUSH
42620: LD_INT 1
42622: NEG
42623: PUSH
42624: EMPTY
42625: LIST
42626: LIST
42627: PUSH
42628: LD_INT 1
42630: PUSH
42631: LD_INT 0
42633: PUSH
42634: EMPTY
42635: LIST
42636: LIST
42637: PUSH
42638: LD_INT 1
42640: PUSH
42641: LD_INT 1
42643: PUSH
42644: EMPTY
42645: LIST
42646: LIST
42647: PUSH
42648: LD_INT 0
42650: PUSH
42651: LD_INT 1
42653: PUSH
42654: EMPTY
42655: LIST
42656: LIST
42657: PUSH
42658: LD_INT 1
42660: NEG
42661: PUSH
42662: LD_INT 0
42664: PUSH
42665: EMPTY
42666: LIST
42667: LIST
42668: PUSH
42669: LD_INT 1
42671: NEG
42672: PUSH
42673: LD_INT 1
42675: NEG
42676: PUSH
42677: EMPTY
42678: LIST
42679: LIST
42680: PUSH
42681: LD_INT 2
42683: PUSH
42684: LD_INT 1
42686: PUSH
42687: EMPTY
42688: LIST
42689: LIST
42690: PUSH
42691: LD_INT 2
42693: PUSH
42694: LD_INT 2
42696: PUSH
42697: EMPTY
42698: LIST
42699: LIST
42700: PUSH
42701: LD_INT 1
42703: PUSH
42704: LD_INT 2
42706: PUSH
42707: EMPTY
42708: LIST
42709: LIST
42710: PUSH
42711: LD_INT 0
42713: PUSH
42714: LD_INT 2
42716: PUSH
42717: EMPTY
42718: LIST
42719: LIST
42720: PUSH
42721: LD_INT 1
42723: NEG
42724: PUSH
42725: LD_INT 1
42727: PUSH
42728: EMPTY
42729: LIST
42730: LIST
42731: PUSH
42732: EMPTY
42733: LIST
42734: LIST
42735: LIST
42736: LIST
42737: LIST
42738: LIST
42739: LIST
42740: LIST
42741: LIST
42742: LIST
42743: LIST
42744: LIST
42745: ST_TO_ADDR
// fControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
42746: LD_ADDR_VAR 0 51
42750: PUSH
42751: LD_INT 0
42753: PUSH
42754: LD_INT 0
42756: PUSH
42757: EMPTY
42758: LIST
42759: LIST
42760: PUSH
42761: LD_INT 0
42763: PUSH
42764: LD_INT 1
42766: NEG
42767: PUSH
42768: EMPTY
42769: LIST
42770: LIST
42771: PUSH
42772: LD_INT 1
42774: PUSH
42775: LD_INT 0
42777: PUSH
42778: EMPTY
42779: LIST
42780: LIST
42781: PUSH
42782: LD_INT 1
42784: PUSH
42785: LD_INT 1
42787: PUSH
42788: EMPTY
42789: LIST
42790: LIST
42791: PUSH
42792: LD_INT 0
42794: PUSH
42795: LD_INT 1
42797: PUSH
42798: EMPTY
42799: LIST
42800: LIST
42801: PUSH
42802: LD_INT 1
42804: NEG
42805: PUSH
42806: LD_INT 0
42808: PUSH
42809: EMPTY
42810: LIST
42811: LIST
42812: PUSH
42813: LD_INT 1
42815: NEG
42816: PUSH
42817: LD_INT 1
42819: NEG
42820: PUSH
42821: EMPTY
42822: LIST
42823: LIST
42824: PUSH
42825: LD_INT 1
42827: PUSH
42828: LD_INT 2
42830: PUSH
42831: EMPTY
42832: LIST
42833: LIST
42834: PUSH
42835: LD_INT 0
42837: PUSH
42838: LD_INT 2
42840: PUSH
42841: EMPTY
42842: LIST
42843: LIST
42844: PUSH
42845: LD_INT 1
42847: NEG
42848: PUSH
42849: LD_INT 1
42851: PUSH
42852: EMPTY
42853: LIST
42854: LIST
42855: PUSH
42856: LD_INT 2
42858: NEG
42859: PUSH
42860: LD_INT 0
42862: PUSH
42863: EMPTY
42864: LIST
42865: LIST
42866: PUSH
42867: LD_INT 2
42869: NEG
42870: PUSH
42871: LD_INT 1
42873: NEG
42874: PUSH
42875: EMPTY
42876: LIST
42877: LIST
42878: PUSH
42879: EMPTY
42880: LIST
42881: LIST
42882: LIST
42883: LIST
42884: LIST
42885: LIST
42886: LIST
42887: LIST
42888: LIST
42889: LIST
42890: LIST
42891: LIST
42892: ST_TO_ADDR
// fControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
42893: LD_ADDR_VAR 0 52
42897: PUSH
42898: LD_INT 0
42900: PUSH
42901: LD_INT 0
42903: PUSH
42904: EMPTY
42905: LIST
42906: LIST
42907: PUSH
42908: LD_INT 0
42910: PUSH
42911: LD_INT 1
42913: NEG
42914: PUSH
42915: EMPTY
42916: LIST
42917: LIST
42918: PUSH
42919: LD_INT 1
42921: PUSH
42922: LD_INT 0
42924: PUSH
42925: EMPTY
42926: LIST
42927: LIST
42928: PUSH
42929: LD_INT 1
42931: PUSH
42932: LD_INT 1
42934: PUSH
42935: EMPTY
42936: LIST
42937: LIST
42938: PUSH
42939: LD_INT 0
42941: PUSH
42942: LD_INT 1
42944: PUSH
42945: EMPTY
42946: LIST
42947: LIST
42948: PUSH
42949: LD_INT 1
42951: NEG
42952: PUSH
42953: LD_INT 0
42955: PUSH
42956: EMPTY
42957: LIST
42958: LIST
42959: PUSH
42960: LD_INT 1
42962: NEG
42963: PUSH
42964: LD_INT 1
42966: NEG
42967: PUSH
42968: EMPTY
42969: LIST
42970: LIST
42971: PUSH
42972: LD_INT 1
42974: NEG
42975: PUSH
42976: LD_INT 2
42978: NEG
42979: PUSH
42980: EMPTY
42981: LIST
42982: LIST
42983: PUSH
42984: LD_INT 1
42986: NEG
42987: PUSH
42988: LD_INT 1
42990: PUSH
42991: EMPTY
42992: LIST
42993: LIST
42994: PUSH
42995: LD_INT 2
42997: NEG
42998: PUSH
42999: LD_INT 0
43001: PUSH
43002: EMPTY
43003: LIST
43004: LIST
43005: PUSH
43006: LD_INT 2
43008: NEG
43009: PUSH
43010: LD_INT 1
43012: NEG
43013: PUSH
43014: EMPTY
43015: LIST
43016: LIST
43017: PUSH
43018: LD_INT 2
43020: NEG
43021: PUSH
43022: LD_INT 2
43024: NEG
43025: PUSH
43026: EMPTY
43027: LIST
43028: LIST
43029: PUSH
43030: EMPTY
43031: LIST
43032: LIST
43033: LIST
43034: LIST
43035: LIST
43036: LIST
43037: LIST
43038: LIST
43039: LIST
43040: LIST
43041: LIST
43042: LIST
43043: ST_TO_ADDR
// fBarracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
43044: LD_ADDR_VAR 0 53
43048: PUSH
43049: LD_INT 0
43051: PUSH
43052: LD_INT 0
43054: PUSH
43055: EMPTY
43056: LIST
43057: LIST
43058: PUSH
43059: LD_INT 0
43061: PUSH
43062: LD_INT 1
43064: NEG
43065: PUSH
43066: EMPTY
43067: LIST
43068: LIST
43069: PUSH
43070: LD_INT 1
43072: PUSH
43073: LD_INT 0
43075: PUSH
43076: EMPTY
43077: LIST
43078: LIST
43079: PUSH
43080: LD_INT 1
43082: PUSH
43083: LD_INT 1
43085: PUSH
43086: EMPTY
43087: LIST
43088: LIST
43089: PUSH
43090: LD_INT 0
43092: PUSH
43093: LD_INT 1
43095: PUSH
43096: EMPTY
43097: LIST
43098: LIST
43099: PUSH
43100: LD_INT 1
43102: NEG
43103: PUSH
43104: LD_INT 0
43106: PUSH
43107: EMPTY
43108: LIST
43109: LIST
43110: PUSH
43111: LD_INT 1
43113: NEG
43114: PUSH
43115: LD_INT 1
43117: NEG
43118: PUSH
43119: EMPTY
43120: LIST
43121: LIST
43122: PUSH
43123: LD_INT 1
43125: NEG
43126: PUSH
43127: LD_INT 2
43129: NEG
43130: PUSH
43131: EMPTY
43132: LIST
43133: LIST
43134: PUSH
43135: LD_INT 0
43137: PUSH
43138: LD_INT 2
43140: NEG
43141: PUSH
43142: EMPTY
43143: LIST
43144: LIST
43145: PUSH
43146: LD_INT 1
43148: PUSH
43149: LD_INT 1
43151: NEG
43152: PUSH
43153: EMPTY
43154: LIST
43155: LIST
43156: PUSH
43157: LD_INT 2
43159: PUSH
43160: LD_INT 0
43162: PUSH
43163: EMPTY
43164: LIST
43165: LIST
43166: PUSH
43167: LD_INT 2
43169: PUSH
43170: LD_INT 1
43172: PUSH
43173: EMPTY
43174: LIST
43175: LIST
43176: PUSH
43177: LD_INT 2
43179: PUSH
43180: LD_INT 2
43182: PUSH
43183: EMPTY
43184: LIST
43185: LIST
43186: PUSH
43187: LD_INT 1
43189: PUSH
43190: LD_INT 2
43192: PUSH
43193: EMPTY
43194: LIST
43195: LIST
43196: PUSH
43197: LD_INT 0
43199: PUSH
43200: LD_INT 2
43202: PUSH
43203: EMPTY
43204: LIST
43205: LIST
43206: PUSH
43207: LD_INT 1
43209: NEG
43210: PUSH
43211: LD_INT 1
43213: PUSH
43214: EMPTY
43215: LIST
43216: LIST
43217: PUSH
43218: LD_INT 2
43220: NEG
43221: PUSH
43222: LD_INT 0
43224: PUSH
43225: EMPTY
43226: LIST
43227: LIST
43228: PUSH
43229: LD_INT 2
43231: NEG
43232: PUSH
43233: LD_INT 1
43235: NEG
43236: PUSH
43237: EMPTY
43238: LIST
43239: LIST
43240: PUSH
43241: LD_INT 2
43243: NEG
43244: PUSH
43245: LD_INT 2
43247: NEG
43248: PUSH
43249: EMPTY
43250: LIST
43251: LIST
43252: PUSH
43253: EMPTY
43254: LIST
43255: LIST
43256: LIST
43257: LIST
43258: LIST
43259: LIST
43260: LIST
43261: LIST
43262: LIST
43263: LIST
43264: LIST
43265: LIST
43266: LIST
43267: LIST
43268: LIST
43269: LIST
43270: LIST
43271: LIST
43272: LIST
43273: ST_TO_ADDR
// fBarracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
43274: LD_ADDR_VAR 0 54
43278: PUSH
43279: LD_INT 0
43281: PUSH
43282: LD_INT 0
43284: PUSH
43285: EMPTY
43286: LIST
43287: LIST
43288: PUSH
43289: LD_INT 0
43291: PUSH
43292: LD_INT 1
43294: NEG
43295: PUSH
43296: EMPTY
43297: LIST
43298: LIST
43299: PUSH
43300: LD_INT 1
43302: PUSH
43303: LD_INT 0
43305: PUSH
43306: EMPTY
43307: LIST
43308: LIST
43309: PUSH
43310: LD_INT 1
43312: PUSH
43313: LD_INT 1
43315: PUSH
43316: EMPTY
43317: LIST
43318: LIST
43319: PUSH
43320: LD_INT 0
43322: PUSH
43323: LD_INT 1
43325: PUSH
43326: EMPTY
43327: LIST
43328: LIST
43329: PUSH
43330: LD_INT 1
43332: NEG
43333: PUSH
43334: LD_INT 0
43336: PUSH
43337: EMPTY
43338: LIST
43339: LIST
43340: PUSH
43341: LD_INT 1
43343: NEG
43344: PUSH
43345: LD_INT 1
43347: NEG
43348: PUSH
43349: EMPTY
43350: LIST
43351: LIST
43352: PUSH
43353: LD_INT 1
43355: NEG
43356: PUSH
43357: LD_INT 2
43359: NEG
43360: PUSH
43361: EMPTY
43362: LIST
43363: LIST
43364: PUSH
43365: LD_INT 0
43367: PUSH
43368: LD_INT 2
43370: NEG
43371: PUSH
43372: EMPTY
43373: LIST
43374: LIST
43375: PUSH
43376: LD_INT 1
43378: PUSH
43379: LD_INT 1
43381: NEG
43382: PUSH
43383: EMPTY
43384: LIST
43385: LIST
43386: PUSH
43387: LD_INT 2
43389: PUSH
43390: LD_INT 0
43392: PUSH
43393: EMPTY
43394: LIST
43395: LIST
43396: PUSH
43397: LD_INT 2
43399: PUSH
43400: LD_INT 1
43402: PUSH
43403: EMPTY
43404: LIST
43405: LIST
43406: PUSH
43407: LD_INT 2
43409: PUSH
43410: LD_INT 2
43412: PUSH
43413: EMPTY
43414: LIST
43415: LIST
43416: PUSH
43417: LD_INT 1
43419: PUSH
43420: LD_INT 2
43422: PUSH
43423: EMPTY
43424: LIST
43425: LIST
43426: PUSH
43427: LD_INT 0
43429: PUSH
43430: LD_INT 2
43432: PUSH
43433: EMPTY
43434: LIST
43435: LIST
43436: PUSH
43437: LD_INT 1
43439: NEG
43440: PUSH
43441: LD_INT 1
43443: PUSH
43444: EMPTY
43445: LIST
43446: LIST
43447: PUSH
43448: LD_INT 2
43450: NEG
43451: PUSH
43452: LD_INT 0
43454: PUSH
43455: EMPTY
43456: LIST
43457: LIST
43458: PUSH
43459: LD_INT 2
43461: NEG
43462: PUSH
43463: LD_INT 1
43465: NEG
43466: PUSH
43467: EMPTY
43468: LIST
43469: LIST
43470: PUSH
43471: LD_INT 2
43473: NEG
43474: PUSH
43475: LD_INT 2
43477: NEG
43478: PUSH
43479: EMPTY
43480: LIST
43481: LIST
43482: PUSH
43483: EMPTY
43484: LIST
43485: LIST
43486: LIST
43487: LIST
43488: LIST
43489: LIST
43490: LIST
43491: LIST
43492: LIST
43493: LIST
43494: LIST
43495: LIST
43496: LIST
43497: LIST
43498: LIST
43499: LIST
43500: LIST
43501: LIST
43502: LIST
43503: ST_TO_ADDR
// fBarracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
43504: LD_ADDR_VAR 0 55
43508: PUSH
43509: LD_INT 0
43511: PUSH
43512: LD_INT 0
43514: PUSH
43515: EMPTY
43516: LIST
43517: LIST
43518: PUSH
43519: LD_INT 0
43521: PUSH
43522: LD_INT 1
43524: NEG
43525: PUSH
43526: EMPTY
43527: LIST
43528: LIST
43529: PUSH
43530: LD_INT 1
43532: PUSH
43533: LD_INT 0
43535: PUSH
43536: EMPTY
43537: LIST
43538: LIST
43539: PUSH
43540: LD_INT 1
43542: PUSH
43543: LD_INT 1
43545: PUSH
43546: EMPTY
43547: LIST
43548: LIST
43549: PUSH
43550: LD_INT 0
43552: PUSH
43553: LD_INT 1
43555: PUSH
43556: EMPTY
43557: LIST
43558: LIST
43559: PUSH
43560: LD_INT 1
43562: NEG
43563: PUSH
43564: LD_INT 0
43566: PUSH
43567: EMPTY
43568: LIST
43569: LIST
43570: PUSH
43571: LD_INT 1
43573: NEG
43574: PUSH
43575: LD_INT 1
43577: NEG
43578: PUSH
43579: EMPTY
43580: LIST
43581: LIST
43582: PUSH
43583: LD_INT 1
43585: NEG
43586: PUSH
43587: LD_INT 2
43589: NEG
43590: PUSH
43591: EMPTY
43592: LIST
43593: LIST
43594: PUSH
43595: LD_INT 0
43597: PUSH
43598: LD_INT 2
43600: NEG
43601: PUSH
43602: EMPTY
43603: LIST
43604: LIST
43605: PUSH
43606: LD_INT 1
43608: PUSH
43609: LD_INT 1
43611: NEG
43612: PUSH
43613: EMPTY
43614: LIST
43615: LIST
43616: PUSH
43617: LD_INT 2
43619: PUSH
43620: LD_INT 0
43622: PUSH
43623: EMPTY
43624: LIST
43625: LIST
43626: PUSH
43627: LD_INT 2
43629: PUSH
43630: LD_INT 1
43632: PUSH
43633: EMPTY
43634: LIST
43635: LIST
43636: PUSH
43637: LD_INT 2
43639: PUSH
43640: LD_INT 2
43642: PUSH
43643: EMPTY
43644: LIST
43645: LIST
43646: PUSH
43647: LD_INT 1
43649: PUSH
43650: LD_INT 2
43652: PUSH
43653: EMPTY
43654: LIST
43655: LIST
43656: PUSH
43657: LD_INT 0
43659: PUSH
43660: LD_INT 2
43662: PUSH
43663: EMPTY
43664: LIST
43665: LIST
43666: PUSH
43667: LD_INT 1
43669: NEG
43670: PUSH
43671: LD_INT 1
43673: PUSH
43674: EMPTY
43675: LIST
43676: LIST
43677: PUSH
43678: LD_INT 2
43680: NEG
43681: PUSH
43682: LD_INT 0
43684: PUSH
43685: EMPTY
43686: LIST
43687: LIST
43688: PUSH
43689: LD_INT 2
43691: NEG
43692: PUSH
43693: LD_INT 1
43695: NEG
43696: PUSH
43697: EMPTY
43698: LIST
43699: LIST
43700: PUSH
43701: LD_INT 2
43703: NEG
43704: PUSH
43705: LD_INT 2
43707: NEG
43708: PUSH
43709: EMPTY
43710: LIST
43711: LIST
43712: PUSH
43713: EMPTY
43714: LIST
43715: LIST
43716: LIST
43717: LIST
43718: LIST
43719: LIST
43720: LIST
43721: LIST
43722: LIST
43723: LIST
43724: LIST
43725: LIST
43726: LIST
43727: LIST
43728: LIST
43729: LIST
43730: LIST
43731: LIST
43732: LIST
43733: ST_TO_ADDR
// fBarracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
43734: LD_ADDR_VAR 0 56
43738: PUSH
43739: LD_INT 0
43741: PUSH
43742: LD_INT 0
43744: PUSH
43745: EMPTY
43746: LIST
43747: LIST
43748: PUSH
43749: LD_INT 0
43751: PUSH
43752: LD_INT 1
43754: NEG
43755: PUSH
43756: EMPTY
43757: LIST
43758: LIST
43759: PUSH
43760: LD_INT 1
43762: PUSH
43763: LD_INT 0
43765: PUSH
43766: EMPTY
43767: LIST
43768: LIST
43769: PUSH
43770: LD_INT 1
43772: PUSH
43773: LD_INT 1
43775: PUSH
43776: EMPTY
43777: LIST
43778: LIST
43779: PUSH
43780: LD_INT 0
43782: PUSH
43783: LD_INT 1
43785: PUSH
43786: EMPTY
43787: LIST
43788: LIST
43789: PUSH
43790: LD_INT 1
43792: NEG
43793: PUSH
43794: LD_INT 0
43796: PUSH
43797: EMPTY
43798: LIST
43799: LIST
43800: PUSH
43801: LD_INT 1
43803: NEG
43804: PUSH
43805: LD_INT 1
43807: NEG
43808: PUSH
43809: EMPTY
43810: LIST
43811: LIST
43812: PUSH
43813: LD_INT 1
43815: NEG
43816: PUSH
43817: LD_INT 2
43819: NEG
43820: PUSH
43821: EMPTY
43822: LIST
43823: LIST
43824: PUSH
43825: LD_INT 0
43827: PUSH
43828: LD_INT 2
43830: NEG
43831: PUSH
43832: EMPTY
43833: LIST
43834: LIST
43835: PUSH
43836: LD_INT 1
43838: PUSH
43839: LD_INT 1
43841: NEG
43842: PUSH
43843: EMPTY
43844: LIST
43845: LIST
43846: PUSH
43847: LD_INT 2
43849: PUSH
43850: LD_INT 0
43852: PUSH
43853: EMPTY
43854: LIST
43855: LIST
43856: PUSH
43857: LD_INT 2
43859: PUSH
43860: LD_INT 1
43862: PUSH
43863: EMPTY
43864: LIST
43865: LIST
43866: PUSH
43867: LD_INT 2
43869: PUSH
43870: LD_INT 2
43872: PUSH
43873: EMPTY
43874: LIST
43875: LIST
43876: PUSH
43877: LD_INT 1
43879: PUSH
43880: LD_INT 2
43882: PUSH
43883: EMPTY
43884: LIST
43885: LIST
43886: PUSH
43887: LD_INT 0
43889: PUSH
43890: LD_INT 2
43892: PUSH
43893: EMPTY
43894: LIST
43895: LIST
43896: PUSH
43897: LD_INT 1
43899: NEG
43900: PUSH
43901: LD_INT 1
43903: PUSH
43904: EMPTY
43905: LIST
43906: LIST
43907: PUSH
43908: LD_INT 2
43910: NEG
43911: PUSH
43912: LD_INT 0
43914: PUSH
43915: EMPTY
43916: LIST
43917: LIST
43918: PUSH
43919: LD_INT 2
43921: NEG
43922: PUSH
43923: LD_INT 1
43925: NEG
43926: PUSH
43927: EMPTY
43928: LIST
43929: LIST
43930: PUSH
43931: LD_INT 2
43933: NEG
43934: PUSH
43935: LD_INT 2
43937: NEG
43938: PUSH
43939: EMPTY
43940: LIST
43941: LIST
43942: PUSH
43943: EMPTY
43944: LIST
43945: LIST
43946: LIST
43947: LIST
43948: LIST
43949: LIST
43950: LIST
43951: LIST
43952: LIST
43953: LIST
43954: LIST
43955: LIST
43956: LIST
43957: LIST
43958: LIST
43959: LIST
43960: LIST
43961: LIST
43962: LIST
43963: ST_TO_ADDR
// fBarracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
43964: LD_ADDR_VAR 0 57
43968: PUSH
43969: LD_INT 0
43971: PUSH
43972: LD_INT 0
43974: PUSH
43975: EMPTY
43976: LIST
43977: LIST
43978: PUSH
43979: LD_INT 0
43981: PUSH
43982: LD_INT 1
43984: NEG
43985: PUSH
43986: EMPTY
43987: LIST
43988: LIST
43989: PUSH
43990: LD_INT 1
43992: PUSH
43993: LD_INT 0
43995: PUSH
43996: EMPTY
43997: LIST
43998: LIST
43999: PUSH
44000: LD_INT 1
44002: PUSH
44003: LD_INT 1
44005: PUSH
44006: EMPTY
44007: LIST
44008: LIST
44009: PUSH
44010: LD_INT 0
44012: PUSH
44013: LD_INT 1
44015: PUSH
44016: EMPTY
44017: LIST
44018: LIST
44019: PUSH
44020: LD_INT 1
44022: NEG
44023: PUSH
44024: LD_INT 0
44026: PUSH
44027: EMPTY
44028: LIST
44029: LIST
44030: PUSH
44031: LD_INT 1
44033: NEG
44034: PUSH
44035: LD_INT 1
44037: NEG
44038: PUSH
44039: EMPTY
44040: LIST
44041: LIST
44042: PUSH
44043: LD_INT 1
44045: NEG
44046: PUSH
44047: LD_INT 2
44049: NEG
44050: PUSH
44051: EMPTY
44052: LIST
44053: LIST
44054: PUSH
44055: LD_INT 0
44057: PUSH
44058: LD_INT 2
44060: NEG
44061: PUSH
44062: EMPTY
44063: LIST
44064: LIST
44065: PUSH
44066: LD_INT 1
44068: PUSH
44069: LD_INT 1
44071: NEG
44072: PUSH
44073: EMPTY
44074: LIST
44075: LIST
44076: PUSH
44077: LD_INT 2
44079: PUSH
44080: LD_INT 0
44082: PUSH
44083: EMPTY
44084: LIST
44085: LIST
44086: PUSH
44087: LD_INT 2
44089: PUSH
44090: LD_INT 1
44092: PUSH
44093: EMPTY
44094: LIST
44095: LIST
44096: PUSH
44097: LD_INT 2
44099: PUSH
44100: LD_INT 2
44102: PUSH
44103: EMPTY
44104: LIST
44105: LIST
44106: PUSH
44107: LD_INT 1
44109: PUSH
44110: LD_INT 2
44112: PUSH
44113: EMPTY
44114: LIST
44115: LIST
44116: PUSH
44117: LD_INT 0
44119: PUSH
44120: LD_INT 2
44122: PUSH
44123: EMPTY
44124: LIST
44125: LIST
44126: PUSH
44127: LD_INT 1
44129: NEG
44130: PUSH
44131: LD_INT 1
44133: PUSH
44134: EMPTY
44135: LIST
44136: LIST
44137: PUSH
44138: LD_INT 2
44140: NEG
44141: PUSH
44142: LD_INT 0
44144: PUSH
44145: EMPTY
44146: LIST
44147: LIST
44148: PUSH
44149: LD_INT 2
44151: NEG
44152: PUSH
44153: LD_INT 1
44155: NEG
44156: PUSH
44157: EMPTY
44158: LIST
44159: LIST
44160: PUSH
44161: LD_INT 2
44163: NEG
44164: PUSH
44165: LD_INT 2
44167: NEG
44168: PUSH
44169: EMPTY
44170: LIST
44171: LIST
44172: PUSH
44173: EMPTY
44174: LIST
44175: LIST
44176: LIST
44177: LIST
44178: LIST
44179: LIST
44180: LIST
44181: LIST
44182: LIST
44183: LIST
44184: LIST
44185: LIST
44186: LIST
44187: LIST
44188: LIST
44189: LIST
44190: LIST
44191: LIST
44192: LIST
44193: ST_TO_ADDR
// fBarracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
44194: LD_ADDR_VAR 0 58
44198: PUSH
44199: LD_INT 0
44201: PUSH
44202: LD_INT 0
44204: PUSH
44205: EMPTY
44206: LIST
44207: LIST
44208: PUSH
44209: LD_INT 0
44211: PUSH
44212: LD_INT 1
44214: NEG
44215: PUSH
44216: EMPTY
44217: LIST
44218: LIST
44219: PUSH
44220: LD_INT 1
44222: PUSH
44223: LD_INT 0
44225: PUSH
44226: EMPTY
44227: LIST
44228: LIST
44229: PUSH
44230: LD_INT 1
44232: PUSH
44233: LD_INT 1
44235: PUSH
44236: EMPTY
44237: LIST
44238: LIST
44239: PUSH
44240: LD_INT 0
44242: PUSH
44243: LD_INT 1
44245: PUSH
44246: EMPTY
44247: LIST
44248: LIST
44249: PUSH
44250: LD_INT 1
44252: NEG
44253: PUSH
44254: LD_INT 0
44256: PUSH
44257: EMPTY
44258: LIST
44259: LIST
44260: PUSH
44261: LD_INT 1
44263: NEG
44264: PUSH
44265: LD_INT 1
44267: NEG
44268: PUSH
44269: EMPTY
44270: LIST
44271: LIST
44272: PUSH
44273: LD_INT 1
44275: NEG
44276: PUSH
44277: LD_INT 2
44279: NEG
44280: PUSH
44281: EMPTY
44282: LIST
44283: LIST
44284: PUSH
44285: LD_INT 0
44287: PUSH
44288: LD_INT 2
44290: NEG
44291: PUSH
44292: EMPTY
44293: LIST
44294: LIST
44295: PUSH
44296: LD_INT 1
44298: PUSH
44299: LD_INT 1
44301: NEG
44302: PUSH
44303: EMPTY
44304: LIST
44305: LIST
44306: PUSH
44307: LD_INT 2
44309: PUSH
44310: LD_INT 0
44312: PUSH
44313: EMPTY
44314: LIST
44315: LIST
44316: PUSH
44317: LD_INT 2
44319: PUSH
44320: LD_INT 1
44322: PUSH
44323: EMPTY
44324: LIST
44325: LIST
44326: PUSH
44327: LD_INT 2
44329: PUSH
44330: LD_INT 2
44332: PUSH
44333: EMPTY
44334: LIST
44335: LIST
44336: PUSH
44337: LD_INT 1
44339: PUSH
44340: LD_INT 2
44342: PUSH
44343: EMPTY
44344: LIST
44345: LIST
44346: PUSH
44347: LD_INT 0
44349: PUSH
44350: LD_INT 2
44352: PUSH
44353: EMPTY
44354: LIST
44355: LIST
44356: PUSH
44357: LD_INT 1
44359: NEG
44360: PUSH
44361: LD_INT 1
44363: PUSH
44364: EMPTY
44365: LIST
44366: LIST
44367: PUSH
44368: LD_INT 2
44370: NEG
44371: PUSH
44372: LD_INT 0
44374: PUSH
44375: EMPTY
44376: LIST
44377: LIST
44378: PUSH
44379: LD_INT 2
44381: NEG
44382: PUSH
44383: LD_INT 1
44385: NEG
44386: PUSH
44387: EMPTY
44388: LIST
44389: LIST
44390: PUSH
44391: LD_INT 2
44393: NEG
44394: PUSH
44395: LD_INT 2
44397: NEG
44398: PUSH
44399: EMPTY
44400: LIST
44401: LIST
44402: PUSH
44403: EMPTY
44404: LIST
44405: LIST
44406: LIST
44407: LIST
44408: LIST
44409: LIST
44410: LIST
44411: LIST
44412: LIST
44413: LIST
44414: LIST
44415: LIST
44416: LIST
44417: LIST
44418: LIST
44419: LIST
44420: LIST
44421: LIST
44422: LIST
44423: ST_TO_ADDR
// fBunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
44424: LD_ADDR_VAR 0 59
44428: PUSH
44429: LD_INT 0
44431: PUSH
44432: LD_INT 0
44434: PUSH
44435: EMPTY
44436: LIST
44437: LIST
44438: PUSH
44439: LD_INT 0
44441: PUSH
44442: LD_INT 1
44444: NEG
44445: PUSH
44446: EMPTY
44447: LIST
44448: LIST
44449: PUSH
44450: LD_INT 1
44452: PUSH
44453: LD_INT 0
44455: PUSH
44456: EMPTY
44457: LIST
44458: LIST
44459: PUSH
44460: LD_INT 1
44462: PUSH
44463: LD_INT 1
44465: PUSH
44466: EMPTY
44467: LIST
44468: LIST
44469: PUSH
44470: LD_INT 0
44472: PUSH
44473: LD_INT 1
44475: PUSH
44476: EMPTY
44477: LIST
44478: LIST
44479: PUSH
44480: LD_INT 1
44482: NEG
44483: PUSH
44484: LD_INT 0
44486: PUSH
44487: EMPTY
44488: LIST
44489: LIST
44490: PUSH
44491: LD_INT 1
44493: NEG
44494: PUSH
44495: LD_INT 1
44497: NEG
44498: PUSH
44499: EMPTY
44500: LIST
44501: LIST
44502: PUSH
44503: EMPTY
44504: LIST
44505: LIST
44506: LIST
44507: LIST
44508: LIST
44509: LIST
44510: LIST
44511: ST_TO_ADDR
// fBunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
44512: LD_ADDR_VAR 0 60
44516: PUSH
44517: LD_INT 0
44519: PUSH
44520: LD_INT 0
44522: PUSH
44523: EMPTY
44524: LIST
44525: LIST
44526: PUSH
44527: LD_INT 0
44529: PUSH
44530: LD_INT 1
44532: NEG
44533: PUSH
44534: EMPTY
44535: LIST
44536: LIST
44537: PUSH
44538: LD_INT 1
44540: PUSH
44541: LD_INT 0
44543: PUSH
44544: EMPTY
44545: LIST
44546: LIST
44547: PUSH
44548: LD_INT 1
44550: PUSH
44551: LD_INT 1
44553: PUSH
44554: EMPTY
44555: LIST
44556: LIST
44557: PUSH
44558: LD_INT 0
44560: PUSH
44561: LD_INT 1
44563: PUSH
44564: EMPTY
44565: LIST
44566: LIST
44567: PUSH
44568: LD_INT 1
44570: NEG
44571: PUSH
44572: LD_INT 0
44574: PUSH
44575: EMPTY
44576: LIST
44577: LIST
44578: PUSH
44579: LD_INT 1
44581: NEG
44582: PUSH
44583: LD_INT 1
44585: NEG
44586: PUSH
44587: EMPTY
44588: LIST
44589: LIST
44590: PUSH
44591: EMPTY
44592: LIST
44593: LIST
44594: LIST
44595: LIST
44596: LIST
44597: LIST
44598: LIST
44599: ST_TO_ADDR
// fBunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
44600: LD_ADDR_VAR 0 61
44604: PUSH
44605: LD_INT 0
44607: PUSH
44608: LD_INT 0
44610: PUSH
44611: EMPTY
44612: LIST
44613: LIST
44614: PUSH
44615: LD_INT 0
44617: PUSH
44618: LD_INT 1
44620: NEG
44621: PUSH
44622: EMPTY
44623: LIST
44624: LIST
44625: PUSH
44626: LD_INT 1
44628: PUSH
44629: LD_INT 0
44631: PUSH
44632: EMPTY
44633: LIST
44634: LIST
44635: PUSH
44636: LD_INT 1
44638: PUSH
44639: LD_INT 1
44641: PUSH
44642: EMPTY
44643: LIST
44644: LIST
44645: PUSH
44646: LD_INT 0
44648: PUSH
44649: LD_INT 1
44651: PUSH
44652: EMPTY
44653: LIST
44654: LIST
44655: PUSH
44656: LD_INT 1
44658: NEG
44659: PUSH
44660: LD_INT 0
44662: PUSH
44663: EMPTY
44664: LIST
44665: LIST
44666: PUSH
44667: LD_INT 1
44669: NEG
44670: PUSH
44671: LD_INT 1
44673: NEG
44674: PUSH
44675: EMPTY
44676: LIST
44677: LIST
44678: PUSH
44679: EMPTY
44680: LIST
44681: LIST
44682: LIST
44683: LIST
44684: LIST
44685: LIST
44686: LIST
44687: ST_TO_ADDR
// fBunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
44688: LD_ADDR_VAR 0 62
44692: PUSH
44693: LD_INT 0
44695: PUSH
44696: LD_INT 0
44698: PUSH
44699: EMPTY
44700: LIST
44701: LIST
44702: PUSH
44703: LD_INT 0
44705: PUSH
44706: LD_INT 1
44708: NEG
44709: PUSH
44710: EMPTY
44711: LIST
44712: LIST
44713: PUSH
44714: LD_INT 1
44716: PUSH
44717: LD_INT 0
44719: PUSH
44720: EMPTY
44721: LIST
44722: LIST
44723: PUSH
44724: LD_INT 1
44726: PUSH
44727: LD_INT 1
44729: PUSH
44730: EMPTY
44731: LIST
44732: LIST
44733: PUSH
44734: LD_INT 0
44736: PUSH
44737: LD_INT 1
44739: PUSH
44740: EMPTY
44741: LIST
44742: LIST
44743: PUSH
44744: LD_INT 1
44746: NEG
44747: PUSH
44748: LD_INT 0
44750: PUSH
44751: EMPTY
44752: LIST
44753: LIST
44754: PUSH
44755: LD_INT 1
44757: NEG
44758: PUSH
44759: LD_INT 1
44761: NEG
44762: PUSH
44763: EMPTY
44764: LIST
44765: LIST
44766: PUSH
44767: EMPTY
44768: LIST
44769: LIST
44770: LIST
44771: LIST
44772: LIST
44773: LIST
44774: LIST
44775: ST_TO_ADDR
// fBunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
44776: LD_ADDR_VAR 0 63
44780: PUSH
44781: LD_INT 0
44783: PUSH
44784: LD_INT 0
44786: PUSH
44787: EMPTY
44788: LIST
44789: LIST
44790: PUSH
44791: LD_INT 0
44793: PUSH
44794: LD_INT 1
44796: NEG
44797: PUSH
44798: EMPTY
44799: LIST
44800: LIST
44801: PUSH
44802: LD_INT 1
44804: PUSH
44805: LD_INT 0
44807: PUSH
44808: EMPTY
44809: LIST
44810: LIST
44811: PUSH
44812: LD_INT 1
44814: PUSH
44815: LD_INT 1
44817: PUSH
44818: EMPTY
44819: LIST
44820: LIST
44821: PUSH
44822: LD_INT 0
44824: PUSH
44825: LD_INT 1
44827: PUSH
44828: EMPTY
44829: LIST
44830: LIST
44831: PUSH
44832: LD_INT 1
44834: NEG
44835: PUSH
44836: LD_INT 0
44838: PUSH
44839: EMPTY
44840: LIST
44841: LIST
44842: PUSH
44843: LD_INT 1
44845: NEG
44846: PUSH
44847: LD_INT 1
44849: NEG
44850: PUSH
44851: EMPTY
44852: LIST
44853: LIST
44854: PUSH
44855: EMPTY
44856: LIST
44857: LIST
44858: LIST
44859: LIST
44860: LIST
44861: LIST
44862: LIST
44863: ST_TO_ADDR
// fBunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
44864: LD_ADDR_VAR 0 64
44868: PUSH
44869: LD_INT 0
44871: PUSH
44872: LD_INT 0
44874: PUSH
44875: EMPTY
44876: LIST
44877: LIST
44878: PUSH
44879: LD_INT 0
44881: PUSH
44882: LD_INT 1
44884: NEG
44885: PUSH
44886: EMPTY
44887: LIST
44888: LIST
44889: PUSH
44890: LD_INT 1
44892: PUSH
44893: LD_INT 0
44895: PUSH
44896: EMPTY
44897: LIST
44898: LIST
44899: PUSH
44900: LD_INT 1
44902: PUSH
44903: LD_INT 1
44905: PUSH
44906: EMPTY
44907: LIST
44908: LIST
44909: PUSH
44910: LD_INT 0
44912: PUSH
44913: LD_INT 1
44915: PUSH
44916: EMPTY
44917: LIST
44918: LIST
44919: PUSH
44920: LD_INT 1
44922: NEG
44923: PUSH
44924: LD_INT 0
44926: PUSH
44927: EMPTY
44928: LIST
44929: LIST
44930: PUSH
44931: LD_INT 1
44933: NEG
44934: PUSH
44935: LD_INT 1
44937: NEG
44938: PUSH
44939: EMPTY
44940: LIST
44941: LIST
44942: PUSH
44943: EMPTY
44944: LIST
44945: LIST
44946: LIST
44947: LIST
44948: LIST
44949: LIST
44950: LIST
44951: ST_TO_ADDR
// end ; 1 :
44952: GO 50849
44954: LD_INT 1
44956: DOUBLE
44957: EQUAL
44958: IFTRUE 44962
44960: GO 47585
44962: POP
// begin fDepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
44963: LD_ADDR_VAR 0 11
44967: PUSH
44968: LD_INT 1
44970: NEG
44971: PUSH
44972: LD_INT 3
44974: NEG
44975: PUSH
44976: EMPTY
44977: LIST
44978: LIST
44979: PUSH
44980: LD_INT 0
44982: PUSH
44983: LD_INT 3
44985: NEG
44986: PUSH
44987: EMPTY
44988: LIST
44989: LIST
44990: PUSH
44991: LD_INT 1
44993: PUSH
44994: LD_INT 2
44996: NEG
44997: PUSH
44998: EMPTY
44999: LIST
45000: LIST
45001: PUSH
45002: EMPTY
45003: LIST
45004: LIST
45005: LIST
45006: ST_TO_ADDR
// fDepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
45007: LD_ADDR_VAR 0 12
45011: PUSH
45012: LD_INT 2
45014: PUSH
45015: LD_INT 1
45017: NEG
45018: PUSH
45019: EMPTY
45020: LIST
45021: LIST
45022: PUSH
45023: LD_INT 3
45025: PUSH
45026: LD_INT 0
45028: PUSH
45029: EMPTY
45030: LIST
45031: LIST
45032: PUSH
45033: LD_INT 3
45035: PUSH
45036: LD_INT 1
45038: PUSH
45039: EMPTY
45040: LIST
45041: LIST
45042: PUSH
45043: EMPTY
45044: LIST
45045: LIST
45046: LIST
45047: ST_TO_ADDR
// fDepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
45048: LD_ADDR_VAR 0 13
45052: PUSH
45053: LD_INT 3
45055: PUSH
45056: LD_INT 2
45058: PUSH
45059: EMPTY
45060: LIST
45061: LIST
45062: PUSH
45063: LD_INT 3
45065: PUSH
45066: LD_INT 3
45068: PUSH
45069: EMPTY
45070: LIST
45071: LIST
45072: PUSH
45073: LD_INT 2
45075: PUSH
45076: LD_INT 3
45078: PUSH
45079: EMPTY
45080: LIST
45081: LIST
45082: PUSH
45083: EMPTY
45084: LIST
45085: LIST
45086: LIST
45087: ST_TO_ADDR
// fDepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
45088: LD_ADDR_VAR 0 14
45092: PUSH
45093: LD_INT 1
45095: PUSH
45096: LD_INT 3
45098: PUSH
45099: EMPTY
45100: LIST
45101: LIST
45102: PUSH
45103: LD_INT 0
45105: PUSH
45106: LD_INT 3
45108: PUSH
45109: EMPTY
45110: LIST
45111: LIST
45112: PUSH
45113: LD_INT 1
45115: NEG
45116: PUSH
45117: LD_INT 2
45119: PUSH
45120: EMPTY
45121: LIST
45122: LIST
45123: PUSH
45124: EMPTY
45125: LIST
45126: LIST
45127: LIST
45128: ST_TO_ADDR
// fDepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
45129: LD_ADDR_VAR 0 15
45133: PUSH
45134: LD_INT 2
45136: NEG
45137: PUSH
45138: LD_INT 1
45140: PUSH
45141: EMPTY
45142: LIST
45143: LIST
45144: PUSH
45145: LD_INT 3
45147: NEG
45148: PUSH
45149: LD_INT 0
45151: PUSH
45152: EMPTY
45153: LIST
45154: LIST
45155: PUSH
45156: LD_INT 3
45158: NEG
45159: PUSH
45160: LD_INT 1
45162: NEG
45163: PUSH
45164: EMPTY
45165: LIST
45166: LIST
45167: PUSH
45168: EMPTY
45169: LIST
45170: LIST
45171: LIST
45172: ST_TO_ADDR
// fDepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
45173: LD_ADDR_VAR 0 16
45177: PUSH
45178: LD_INT 2
45180: NEG
45181: PUSH
45182: LD_INT 3
45184: NEG
45185: PUSH
45186: EMPTY
45187: LIST
45188: LIST
45189: PUSH
45190: LD_INT 3
45192: NEG
45193: PUSH
45194: LD_INT 2
45196: NEG
45197: PUSH
45198: EMPTY
45199: LIST
45200: LIST
45201: PUSH
45202: LD_INT 3
45204: NEG
45205: PUSH
45206: LD_INT 3
45208: NEG
45209: PUSH
45210: EMPTY
45211: LIST
45212: LIST
45213: PUSH
45214: EMPTY
45215: LIST
45216: LIST
45217: LIST
45218: ST_TO_ADDR
// fDepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
45219: LD_ADDR_VAR 0 17
45223: PUSH
45224: LD_INT 1
45226: NEG
45227: PUSH
45228: LD_INT 3
45230: NEG
45231: PUSH
45232: EMPTY
45233: LIST
45234: LIST
45235: PUSH
45236: LD_INT 0
45238: PUSH
45239: LD_INT 3
45241: NEG
45242: PUSH
45243: EMPTY
45244: LIST
45245: LIST
45246: PUSH
45247: LD_INT 1
45249: PUSH
45250: LD_INT 2
45252: NEG
45253: PUSH
45254: EMPTY
45255: LIST
45256: LIST
45257: PUSH
45258: EMPTY
45259: LIST
45260: LIST
45261: LIST
45262: ST_TO_ADDR
// fDepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
45263: LD_ADDR_VAR 0 18
45267: PUSH
45268: LD_INT 2
45270: PUSH
45271: LD_INT 1
45273: NEG
45274: PUSH
45275: EMPTY
45276: LIST
45277: LIST
45278: PUSH
45279: LD_INT 3
45281: PUSH
45282: LD_INT 0
45284: PUSH
45285: EMPTY
45286: LIST
45287: LIST
45288: PUSH
45289: LD_INT 3
45291: PUSH
45292: LD_INT 1
45294: PUSH
45295: EMPTY
45296: LIST
45297: LIST
45298: PUSH
45299: EMPTY
45300: LIST
45301: LIST
45302: LIST
45303: ST_TO_ADDR
// fDepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
45304: LD_ADDR_VAR 0 19
45308: PUSH
45309: LD_INT 3
45311: PUSH
45312: LD_INT 2
45314: PUSH
45315: EMPTY
45316: LIST
45317: LIST
45318: PUSH
45319: LD_INT 3
45321: PUSH
45322: LD_INT 3
45324: PUSH
45325: EMPTY
45326: LIST
45327: LIST
45328: PUSH
45329: LD_INT 2
45331: PUSH
45332: LD_INT 3
45334: PUSH
45335: EMPTY
45336: LIST
45337: LIST
45338: PUSH
45339: EMPTY
45340: LIST
45341: LIST
45342: LIST
45343: ST_TO_ADDR
// fDepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
45344: LD_ADDR_VAR 0 20
45348: PUSH
45349: LD_INT 1
45351: PUSH
45352: LD_INT 3
45354: PUSH
45355: EMPTY
45356: LIST
45357: LIST
45358: PUSH
45359: LD_INT 0
45361: PUSH
45362: LD_INT 3
45364: PUSH
45365: EMPTY
45366: LIST
45367: LIST
45368: PUSH
45369: LD_INT 1
45371: NEG
45372: PUSH
45373: LD_INT 2
45375: PUSH
45376: EMPTY
45377: LIST
45378: LIST
45379: PUSH
45380: EMPTY
45381: LIST
45382: LIST
45383: LIST
45384: ST_TO_ADDR
// fDepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
45385: LD_ADDR_VAR 0 21
45389: PUSH
45390: LD_INT 2
45392: NEG
45393: PUSH
45394: LD_INT 1
45396: PUSH
45397: EMPTY
45398: LIST
45399: LIST
45400: PUSH
45401: LD_INT 3
45403: NEG
45404: PUSH
45405: LD_INT 0
45407: PUSH
45408: EMPTY
45409: LIST
45410: LIST
45411: PUSH
45412: LD_INT 3
45414: NEG
45415: PUSH
45416: LD_INT 1
45418: NEG
45419: PUSH
45420: EMPTY
45421: LIST
45422: LIST
45423: PUSH
45424: EMPTY
45425: LIST
45426: LIST
45427: LIST
45428: ST_TO_ADDR
// fDepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
45429: LD_ADDR_VAR 0 22
45433: PUSH
45434: LD_INT 2
45436: NEG
45437: PUSH
45438: LD_INT 3
45440: NEG
45441: PUSH
45442: EMPTY
45443: LIST
45444: LIST
45445: PUSH
45446: LD_INT 3
45448: NEG
45449: PUSH
45450: LD_INT 2
45452: NEG
45453: PUSH
45454: EMPTY
45455: LIST
45456: LIST
45457: PUSH
45458: LD_INT 3
45460: NEG
45461: PUSH
45462: LD_INT 3
45464: NEG
45465: PUSH
45466: EMPTY
45467: LIST
45468: LIST
45469: PUSH
45470: EMPTY
45471: LIST
45472: LIST
45473: LIST
45474: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
45475: LD_ADDR_VAR 0 23
45479: PUSH
45480: LD_INT 0
45482: PUSH
45483: LD_INT 3
45485: NEG
45486: PUSH
45487: EMPTY
45488: LIST
45489: LIST
45490: PUSH
45491: LD_INT 1
45493: NEG
45494: PUSH
45495: LD_INT 4
45497: NEG
45498: PUSH
45499: EMPTY
45500: LIST
45501: LIST
45502: PUSH
45503: LD_INT 1
45505: PUSH
45506: LD_INT 3
45508: NEG
45509: PUSH
45510: EMPTY
45511: LIST
45512: LIST
45513: PUSH
45514: EMPTY
45515: LIST
45516: LIST
45517: LIST
45518: ST_TO_ADDR
// fDepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
45519: LD_ADDR_VAR 0 24
45523: PUSH
45524: LD_INT 3
45526: PUSH
45527: LD_INT 0
45529: PUSH
45530: EMPTY
45531: LIST
45532: LIST
45533: PUSH
45534: LD_INT 3
45536: PUSH
45537: LD_INT 1
45539: NEG
45540: PUSH
45541: EMPTY
45542: LIST
45543: LIST
45544: PUSH
45545: LD_INT 4
45547: PUSH
45548: LD_INT 1
45550: PUSH
45551: EMPTY
45552: LIST
45553: LIST
45554: PUSH
45555: EMPTY
45556: LIST
45557: LIST
45558: LIST
45559: ST_TO_ADDR
// fDepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
45560: LD_ADDR_VAR 0 25
45564: PUSH
45565: LD_INT 3
45567: PUSH
45568: LD_INT 3
45570: PUSH
45571: EMPTY
45572: LIST
45573: LIST
45574: PUSH
45575: LD_INT 4
45577: PUSH
45578: LD_INT 3
45580: PUSH
45581: EMPTY
45582: LIST
45583: LIST
45584: PUSH
45585: LD_INT 3
45587: PUSH
45588: LD_INT 4
45590: PUSH
45591: EMPTY
45592: LIST
45593: LIST
45594: PUSH
45595: EMPTY
45596: LIST
45597: LIST
45598: LIST
45599: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
45600: LD_ADDR_VAR 0 26
45604: PUSH
45605: LD_INT 0
45607: PUSH
45608: LD_INT 3
45610: PUSH
45611: EMPTY
45612: LIST
45613: LIST
45614: PUSH
45615: LD_INT 1
45617: PUSH
45618: LD_INT 4
45620: PUSH
45621: EMPTY
45622: LIST
45623: LIST
45624: PUSH
45625: LD_INT 1
45627: NEG
45628: PUSH
45629: LD_INT 3
45631: PUSH
45632: EMPTY
45633: LIST
45634: LIST
45635: PUSH
45636: EMPTY
45637: LIST
45638: LIST
45639: LIST
45640: ST_TO_ADDR
// fDepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
45641: LD_ADDR_VAR 0 27
45645: PUSH
45646: LD_INT 3
45648: NEG
45649: PUSH
45650: LD_INT 0
45652: PUSH
45653: EMPTY
45654: LIST
45655: LIST
45656: PUSH
45657: LD_INT 3
45659: NEG
45660: PUSH
45661: LD_INT 1
45663: PUSH
45664: EMPTY
45665: LIST
45666: LIST
45667: PUSH
45668: LD_INT 4
45670: NEG
45671: PUSH
45672: LD_INT 1
45674: NEG
45675: PUSH
45676: EMPTY
45677: LIST
45678: LIST
45679: PUSH
45680: EMPTY
45681: LIST
45682: LIST
45683: LIST
45684: ST_TO_ADDR
// fDepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
45685: LD_ADDR_VAR 0 28
45689: PUSH
45690: LD_INT 3
45692: NEG
45693: PUSH
45694: LD_INT 3
45696: NEG
45697: PUSH
45698: EMPTY
45699: LIST
45700: LIST
45701: PUSH
45702: LD_INT 3
45704: NEG
45705: PUSH
45706: LD_INT 4
45708: NEG
45709: PUSH
45710: EMPTY
45711: LIST
45712: LIST
45713: PUSH
45714: LD_INT 4
45716: NEG
45717: PUSH
45718: LD_INT 3
45720: NEG
45721: PUSH
45722: EMPTY
45723: LIST
45724: LIST
45725: PUSH
45726: EMPTY
45727: LIST
45728: LIST
45729: LIST
45730: ST_TO_ADDR
// fFactory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
45731: LD_ADDR_VAR 0 29
45735: PUSH
45736: LD_INT 1
45738: NEG
45739: PUSH
45740: LD_INT 3
45742: NEG
45743: PUSH
45744: EMPTY
45745: LIST
45746: LIST
45747: PUSH
45748: LD_INT 0
45750: PUSH
45751: LD_INT 3
45753: NEG
45754: PUSH
45755: EMPTY
45756: LIST
45757: LIST
45758: PUSH
45759: LD_INT 1
45761: PUSH
45762: LD_INT 2
45764: NEG
45765: PUSH
45766: EMPTY
45767: LIST
45768: LIST
45769: PUSH
45770: LD_INT 1
45772: NEG
45773: PUSH
45774: LD_INT 4
45776: NEG
45777: PUSH
45778: EMPTY
45779: LIST
45780: LIST
45781: PUSH
45782: LD_INT 0
45784: PUSH
45785: LD_INT 4
45787: NEG
45788: PUSH
45789: EMPTY
45790: LIST
45791: LIST
45792: PUSH
45793: LD_INT 1
45795: PUSH
45796: LD_INT 3
45798: NEG
45799: PUSH
45800: EMPTY
45801: LIST
45802: LIST
45803: PUSH
45804: LD_INT 1
45806: NEG
45807: PUSH
45808: LD_INT 5
45810: NEG
45811: PUSH
45812: EMPTY
45813: LIST
45814: LIST
45815: PUSH
45816: LD_INT 0
45818: PUSH
45819: LD_INT 5
45821: NEG
45822: PUSH
45823: EMPTY
45824: LIST
45825: LIST
45826: PUSH
45827: LD_INT 1
45829: PUSH
45830: LD_INT 4
45832: NEG
45833: PUSH
45834: EMPTY
45835: LIST
45836: LIST
45837: PUSH
45838: LD_INT 1
45840: NEG
45841: PUSH
45842: LD_INT 6
45844: NEG
45845: PUSH
45846: EMPTY
45847: LIST
45848: LIST
45849: PUSH
45850: LD_INT 0
45852: PUSH
45853: LD_INT 6
45855: NEG
45856: PUSH
45857: EMPTY
45858: LIST
45859: LIST
45860: PUSH
45861: LD_INT 1
45863: PUSH
45864: LD_INT 5
45866: NEG
45867: PUSH
45868: EMPTY
45869: LIST
45870: LIST
45871: PUSH
45872: EMPTY
45873: LIST
45874: LIST
45875: LIST
45876: LIST
45877: LIST
45878: LIST
45879: LIST
45880: LIST
45881: LIST
45882: LIST
45883: LIST
45884: LIST
45885: ST_TO_ADDR
// fFactory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
45886: LD_ADDR_VAR 0 30
45890: PUSH
45891: LD_INT 2
45893: PUSH
45894: LD_INT 1
45896: NEG
45897: PUSH
45898: EMPTY
45899: LIST
45900: LIST
45901: PUSH
45902: LD_INT 3
45904: PUSH
45905: LD_INT 0
45907: PUSH
45908: EMPTY
45909: LIST
45910: LIST
45911: PUSH
45912: LD_INT 3
45914: PUSH
45915: LD_INT 1
45917: PUSH
45918: EMPTY
45919: LIST
45920: LIST
45921: PUSH
45922: LD_INT 3
45924: PUSH
45925: LD_INT 1
45927: NEG
45928: PUSH
45929: EMPTY
45930: LIST
45931: LIST
45932: PUSH
45933: LD_INT 4
45935: PUSH
45936: LD_INT 0
45938: PUSH
45939: EMPTY
45940: LIST
45941: LIST
45942: PUSH
45943: LD_INT 4
45945: PUSH
45946: LD_INT 1
45948: PUSH
45949: EMPTY
45950: LIST
45951: LIST
45952: PUSH
45953: LD_INT 4
45955: PUSH
45956: LD_INT 1
45958: NEG
45959: PUSH
45960: EMPTY
45961: LIST
45962: LIST
45963: PUSH
45964: LD_INT 5
45966: PUSH
45967: LD_INT 0
45969: PUSH
45970: EMPTY
45971: LIST
45972: LIST
45973: PUSH
45974: LD_INT 5
45976: PUSH
45977: LD_INT 1
45979: PUSH
45980: EMPTY
45981: LIST
45982: LIST
45983: PUSH
45984: LD_INT 5
45986: PUSH
45987: LD_INT 1
45989: NEG
45990: PUSH
45991: EMPTY
45992: LIST
45993: LIST
45994: PUSH
45995: LD_INT 6
45997: PUSH
45998: LD_INT 0
46000: PUSH
46001: EMPTY
46002: LIST
46003: LIST
46004: PUSH
46005: LD_INT 6
46007: PUSH
46008: LD_INT 1
46010: PUSH
46011: EMPTY
46012: LIST
46013: LIST
46014: PUSH
46015: EMPTY
46016: LIST
46017: LIST
46018: LIST
46019: LIST
46020: LIST
46021: LIST
46022: LIST
46023: LIST
46024: LIST
46025: LIST
46026: LIST
46027: LIST
46028: ST_TO_ADDR
// fFactory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
46029: LD_ADDR_VAR 0 31
46033: PUSH
46034: LD_INT 3
46036: PUSH
46037: LD_INT 2
46039: PUSH
46040: EMPTY
46041: LIST
46042: LIST
46043: PUSH
46044: LD_INT 3
46046: PUSH
46047: LD_INT 3
46049: PUSH
46050: EMPTY
46051: LIST
46052: LIST
46053: PUSH
46054: LD_INT 2
46056: PUSH
46057: LD_INT 3
46059: PUSH
46060: EMPTY
46061: LIST
46062: LIST
46063: PUSH
46064: LD_INT 4
46066: PUSH
46067: LD_INT 3
46069: PUSH
46070: EMPTY
46071: LIST
46072: LIST
46073: PUSH
46074: LD_INT 4
46076: PUSH
46077: LD_INT 4
46079: PUSH
46080: EMPTY
46081: LIST
46082: LIST
46083: PUSH
46084: LD_INT 3
46086: PUSH
46087: LD_INT 4
46089: PUSH
46090: EMPTY
46091: LIST
46092: LIST
46093: PUSH
46094: LD_INT 5
46096: PUSH
46097: LD_INT 4
46099: PUSH
46100: EMPTY
46101: LIST
46102: LIST
46103: PUSH
46104: LD_INT 5
46106: PUSH
46107: LD_INT 5
46109: PUSH
46110: EMPTY
46111: LIST
46112: LIST
46113: PUSH
46114: LD_INT 4
46116: PUSH
46117: LD_INT 5
46119: PUSH
46120: EMPTY
46121: LIST
46122: LIST
46123: PUSH
46124: LD_INT 6
46126: PUSH
46127: LD_INT 5
46129: PUSH
46130: EMPTY
46131: LIST
46132: LIST
46133: PUSH
46134: LD_INT 6
46136: PUSH
46137: LD_INT 6
46139: PUSH
46140: EMPTY
46141: LIST
46142: LIST
46143: PUSH
46144: LD_INT 5
46146: PUSH
46147: LD_INT 6
46149: PUSH
46150: EMPTY
46151: LIST
46152: LIST
46153: PUSH
46154: EMPTY
46155: LIST
46156: LIST
46157: LIST
46158: LIST
46159: LIST
46160: LIST
46161: LIST
46162: LIST
46163: LIST
46164: LIST
46165: LIST
46166: LIST
46167: ST_TO_ADDR
// fFactory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
46168: LD_ADDR_VAR 0 32
46172: PUSH
46173: LD_INT 1
46175: PUSH
46176: LD_INT 3
46178: PUSH
46179: EMPTY
46180: LIST
46181: LIST
46182: PUSH
46183: LD_INT 0
46185: PUSH
46186: LD_INT 3
46188: PUSH
46189: EMPTY
46190: LIST
46191: LIST
46192: PUSH
46193: LD_INT 1
46195: NEG
46196: PUSH
46197: LD_INT 2
46199: PUSH
46200: EMPTY
46201: LIST
46202: LIST
46203: PUSH
46204: LD_INT 1
46206: PUSH
46207: LD_INT 4
46209: PUSH
46210: EMPTY
46211: LIST
46212: LIST
46213: PUSH
46214: LD_INT 0
46216: PUSH
46217: LD_INT 4
46219: PUSH
46220: EMPTY
46221: LIST
46222: LIST
46223: PUSH
46224: LD_INT 1
46226: NEG
46227: PUSH
46228: LD_INT 3
46230: PUSH
46231: EMPTY
46232: LIST
46233: LIST
46234: PUSH
46235: LD_INT 1
46237: PUSH
46238: LD_INT 5
46240: PUSH
46241: EMPTY
46242: LIST
46243: LIST
46244: PUSH
46245: LD_INT 0
46247: PUSH
46248: LD_INT 5
46250: PUSH
46251: EMPTY
46252: LIST
46253: LIST
46254: PUSH
46255: LD_INT 1
46257: NEG
46258: PUSH
46259: LD_INT 4
46261: PUSH
46262: EMPTY
46263: LIST
46264: LIST
46265: PUSH
46266: LD_INT 1
46268: PUSH
46269: LD_INT 6
46271: PUSH
46272: EMPTY
46273: LIST
46274: LIST
46275: PUSH
46276: LD_INT 0
46278: PUSH
46279: LD_INT 6
46281: PUSH
46282: EMPTY
46283: LIST
46284: LIST
46285: PUSH
46286: LD_INT 1
46288: NEG
46289: PUSH
46290: LD_INT 5
46292: PUSH
46293: EMPTY
46294: LIST
46295: LIST
46296: PUSH
46297: EMPTY
46298: LIST
46299: LIST
46300: LIST
46301: LIST
46302: LIST
46303: LIST
46304: LIST
46305: LIST
46306: LIST
46307: LIST
46308: LIST
46309: LIST
46310: ST_TO_ADDR
// fFactory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
46311: LD_ADDR_VAR 0 33
46315: PUSH
46316: LD_INT 2
46318: NEG
46319: PUSH
46320: LD_INT 1
46322: PUSH
46323: EMPTY
46324: LIST
46325: LIST
46326: PUSH
46327: LD_INT 3
46329: NEG
46330: PUSH
46331: LD_INT 0
46333: PUSH
46334: EMPTY
46335: LIST
46336: LIST
46337: PUSH
46338: LD_INT 3
46340: NEG
46341: PUSH
46342: LD_INT 1
46344: NEG
46345: PUSH
46346: EMPTY
46347: LIST
46348: LIST
46349: PUSH
46350: LD_INT 3
46352: NEG
46353: PUSH
46354: LD_INT 1
46356: PUSH
46357: EMPTY
46358: LIST
46359: LIST
46360: PUSH
46361: LD_INT 4
46363: NEG
46364: PUSH
46365: LD_INT 0
46367: PUSH
46368: EMPTY
46369: LIST
46370: LIST
46371: PUSH
46372: LD_INT 4
46374: NEG
46375: PUSH
46376: LD_INT 1
46378: NEG
46379: PUSH
46380: EMPTY
46381: LIST
46382: LIST
46383: PUSH
46384: LD_INT 4
46386: NEG
46387: PUSH
46388: LD_INT 1
46390: PUSH
46391: EMPTY
46392: LIST
46393: LIST
46394: PUSH
46395: LD_INT 5
46397: NEG
46398: PUSH
46399: LD_INT 0
46401: PUSH
46402: EMPTY
46403: LIST
46404: LIST
46405: PUSH
46406: LD_INT 5
46408: NEG
46409: PUSH
46410: LD_INT 1
46412: NEG
46413: PUSH
46414: EMPTY
46415: LIST
46416: LIST
46417: PUSH
46418: LD_INT 5
46420: NEG
46421: PUSH
46422: LD_INT 1
46424: PUSH
46425: EMPTY
46426: LIST
46427: LIST
46428: PUSH
46429: LD_INT 6
46431: NEG
46432: PUSH
46433: LD_INT 0
46435: PUSH
46436: EMPTY
46437: LIST
46438: LIST
46439: PUSH
46440: LD_INT 6
46442: NEG
46443: PUSH
46444: LD_INT 1
46446: NEG
46447: PUSH
46448: EMPTY
46449: LIST
46450: LIST
46451: PUSH
46452: EMPTY
46453: LIST
46454: LIST
46455: LIST
46456: LIST
46457: LIST
46458: LIST
46459: LIST
46460: LIST
46461: LIST
46462: LIST
46463: LIST
46464: LIST
46465: ST_TO_ADDR
// fFactory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
46466: LD_ADDR_VAR 0 34
46470: PUSH
46471: LD_INT 2
46473: NEG
46474: PUSH
46475: LD_INT 3
46477: NEG
46478: PUSH
46479: EMPTY
46480: LIST
46481: LIST
46482: PUSH
46483: LD_INT 3
46485: NEG
46486: PUSH
46487: LD_INT 2
46489: NEG
46490: PUSH
46491: EMPTY
46492: LIST
46493: LIST
46494: PUSH
46495: LD_INT 3
46497: NEG
46498: PUSH
46499: LD_INT 3
46501: NEG
46502: PUSH
46503: EMPTY
46504: LIST
46505: LIST
46506: PUSH
46507: LD_INT 3
46509: NEG
46510: PUSH
46511: LD_INT 4
46513: NEG
46514: PUSH
46515: EMPTY
46516: LIST
46517: LIST
46518: PUSH
46519: LD_INT 4
46521: NEG
46522: PUSH
46523: LD_INT 3
46525: NEG
46526: PUSH
46527: EMPTY
46528: LIST
46529: LIST
46530: PUSH
46531: LD_INT 4
46533: NEG
46534: PUSH
46535: LD_INT 4
46537: NEG
46538: PUSH
46539: EMPTY
46540: LIST
46541: LIST
46542: PUSH
46543: LD_INT 4
46545: NEG
46546: PUSH
46547: LD_INT 5
46549: NEG
46550: PUSH
46551: EMPTY
46552: LIST
46553: LIST
46554: PUSH
46555: LD_INT 5
46557: NEG
46558: PUSH
46559: LD_INT 4
46561: NEG
46562: PUSH
46563: EMPTY
46564: LIST
46565: LIST
46566: PUSH
46567: LD_INT 5
46569: NEG
46570: PUSH
46571: LD_INT 5
46573: NEG
46574: PUSH
46575: EMPTY
46576: LIST
46577: LIST
46578: PUSH
46579: LD_INT 5
46581: NEG
46582: PUSH
46583: LD_INT 6
46585: NEG
46586: PUSH
46587: EMPTY
46588: LIST
46589: LIST
46590: PUSH
46591: LD_INT 6
46593: NEG
46594: PUSH
46595: LD_INT 5
46597: NEG
46598: PUSH
46599: EMPTY
46600: LIST
46601: LIST
46602: PUSH
46603: LD_INT 6
46605: NEG
46606: PUSH
46607: LD_INT 6
46609: NEG
46610: PUSH
46611: EMPTY
46612: LIST
46613: LIST
46614: PUSH
46615: EMPTY
46616: LIST
46617: LIST
46618: LIST
46619: LIST
46620: LIST
46621: LIST
46622: LIST
46623: LIST
46624: LIST
46625: LIST
46626: LIST
46627: LIST
46628: ST_TO_ADDR
// fLab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
46629: LD_ADDR_VAR 0 41
46633: PUSH
46634: LD_INT 0
46636: PUSH
46637: LD_INT 2
46639: NEG
46640: PUSH
46641: EMPTY
46642: LIST
46643: LIST
46644: PUSH
46645: LD_INT 1
46647: NEG
46648: PUSH
46649: LD_INT 3
46651: NEG
46652: PUSH
46653: EMPTY
46654: LIST
46655: LIST
46656: PUSH
46657: LD_INT 1
46659: PUSH
46660: LD_INT 2
46662: NEG
46663: PUSH
46664: EMPTY
46665: LIST
46666: LIST
46667: PUSH
46668: EMPTY
46669: LIST
46670: LIST
46671: LIST
46672: ST_TO_ADDR
// fLab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
46673: LD_ADDR_VAR 0 42
46677: PUSH
46678: LD_INT 2
46680: PUSH
46681: LD_INT 0
46683: PUSH
46684: EMPTY
46685: LIST
46686: LIST
46687: PUSH
46688: LD_INT 2
46690: PUSH
46691: LD_INT 1
46693: NEG
46694: PUSH
46695: EMPTY
46696: LIST
46697: LIST
46698: PUSH
46699: LD_INT 3
46701: PUSH
46702: LD_INT 1
46704: PUSH
46705: EMPTY
46706: LIST
46707: LIST
46708: PUSH
46709: EMPTY
46710: LIST
46711: LIST
46712: LIST
46713: ST_TO_ADDR
// fLab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
46714: LD_ADDR_VAR 0 43
46718: PUSH
46719: LD_INT 2
46721: PUSH
46722: LD_INT 2
46724: PUSH
46725: EMPTY
46726: LIST
46727: LIST
46728: PUSH
46729: LD_INT 3
46731: PUSH
46732: LD_INT 2
46734: PUSH
46735: EMPTY
46736: LIST
46737: LIST
46738: PUSH
46739: LD_INT 2
46741: PUSH
46742: LD_INT 3
46744: PUSH
46745: EMPTY
46746: LIST
46747: LIST
46748: PUSH
46749: EMPTY
46750: LIST
46751: LIST
46752: LIST
46753: ST_TO_ADDR
// fLab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
46754: LD_ADDR_VAR 0 44
46758: PUSH
46759: LD_INT 0
46761: PUSH
46762: LD_INT 2
46764: PUSH
46765: EMPTY
46766: LIST
46767: LIST
46768: PUSH
46769: LD_INT 1
46771: PUSH
46772: LD_INT 3
46774: PUSH
46775: EMPTY
46776: LIST
46777: LIST
46778: PUSH
46779: LD_INT 1
46781: NEG
46782: PUSH
46783: LD_INT 2
46785: PUSH
46786: EMPTY
46787: LIST
46788: LIST
46789: PUSH
46790: EMPTY
46791: LIST
46792: LIST
46793: LIST
46794: ST_TO_ADDR
// fLab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
46795: LD_ADDR_VAR 0 45
46799: PUSH
46800: LD_INT 2
46802: NEG
46803: PUSH
46804: LD_INT 0
46806: PUSH
46807: EMPTY
46808: LIST
46809: LIST
46810: PUSH
46811: LD_INT 2
46813: NEG
46814: PUSH
46815: LD_INT 1
46817: PUSH
46818: EMPTY
46819: LIST
46820: LIST
46821: PUSH
46822: LD_INT 3
46824: NEG
46825: PUSH
46826: LD_INT 1
46828: NEG
46829: PUSH
46830: EMPTY
46831: LIST
46832: LIST
46833: PUSH
46834: EMPTY
46835: LIST
46836: LIST
46837: LIST
46838: ST_TO_ADDR
// fLab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
46839: LD_ADDR_VAR 0 46
46843: PUSH
46844: LD_INT 2
46846: NEG
46847: PUSH
46848: LD_INT 2
46850: NEG
46851: PUSH
46852: EMPTY
46853: LIST
46854: LIST
46855: PUSH
46856: LD_INT 2
46858: NEG
46859: PUSH
46860: LD_INT 3
46862: NEG
46863: PUSH
46864: EMPTY
46865: LIST
46866: LIST
46867: PUSH
46868: LD_INT 3
46870: NEG
46871: PUSH
46872: LD_INT 2
46874: NEG
46875: PUSH
46876: EMPTY
46877: LIST
46878: LIST
46879: PUSH
46880: EMPTY
46881: LIST
46882: LIST
46883: LIST
46884: ST_TO_ADDR
// fControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
46885: LD_ADDR_VAR 0 47
46889: PUSH
46890: LD_INT 2
46892: NEG
46893: PUSH
46894: LD_INT 3
46896: NEG
46897: PUSH
46898: EMPTY
46899: LIST
46900: LIST
46901: PUSH
46902: LD_INT 1
46904: NEG
46905: PUSH
46906: LD_INT 3
46908: NEG
46909: PUSH
46910: EMPTY
46911: LIST
46912: LIST
46913: PUSH
46914: EMPTY
46915: LIST
46916: LIST
46917: ST_TO_ADDR
// fControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
46918: LD_ADDR_VAR 0 48
46922: PUSH
46923: LD_INT 1
46925: PUSH
46926: LD_INT 2
46928: NEG
46929: PUSH
46930: EMPTY
46931: LIST
46932: LIST
46933: PUSH
46934: LD_INT 2
46936: PUSH
46937: LD_INT 1
46939: NEG
46940: PUSH
46941: EMPTY
46942: LIST
46943: LIST
46944: PUSH
46945: EMPTY
46946: LIST
46947: LIST
46948: ST_TO_ADDR
// fControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
46949: LD_ADDR_VAR 0 49
46953: PUSH
46954: LD_INT 3
46956: PUSH
46957: LD_INT 1
46959: PUSH
46960: EMPTY
46961: LIST
46962: LIST
46963: PUSH
46964: LD_INT 3
46966: PUSH
46967: LD_INT 2
46969: PUSH
46970: EMPTY
46971: LIST
46972: LIST
46973: PUSH
46974: EMPTY
46975: LIST
46976: LIST
46977: ST_TO_ADDR
// fControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
46978: LD_ADDR_VAR 0 50
46982: PUSH
46983: LD_INT 2
46985: PUSH
46986: LD_INT 3
46988: PUSH
46989: EMPTY
46990: LIST
46991: LIST
46992: PUSH
46993: LD_INT 1
46995: PUSH
46996: LD_INT 3
46998: PUSH
46999: EMPTY
47000: LIST
47001: LIST
47002: PUSH
47003: EMPTY
47004: LIST
47005: LIST
47006: ST_TO_ADDR
// fControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
47007: LD_ADDR_VAR 0 51
47011: PUSH
47012: LD_INT 1
47014: NEG
47015: PUSH
47016: LD_INT 2
47018: PUSH
47019: EMPTY
47020: LIST
47021: LIST
47022: PUSH
47023: LD_INT 2
47025: NEG
47026: PUSH
47027: LD_INT 1
47029: PUSH
47030: EMPTY
47031: LIST
47032: LIST
47033: PUSH
47034: EMPTY
47035: LIST
47036: LIST
47037: ST_TO_ADDR
// fControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
47038: LD_ADDR_VAR 0 52
47042: PUSH
47043: LD_INT 3
47045: NEG
47046: PUSH
47047: LD_INT 1
47049: NEG
47050: PUSH
47051: EMPTY
47052: LIST
47053: LIST
47054: PUSH
47055: LD_INT 3
47057: NEG
47058: PUSH
47059: LD_INT 2
47061: NEG
47062: PUSH
47063: EMPTY
47064: LIST
47065: LIST
47066: PUSH
47067: EMPTY
47068: LIST
47069: LIST
47070: ST_TO_ADDR
// fBarracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
47071: LD_ADDR_VAR 0 53
47075: PUSH
47076: LD_INT 1
47078: NEG
47079: PUSH
47080: LD_INT 3
47082: NEG
47083: PUSH
47084: EMPTY
47085: LIST
47086: LIST
47087: PUSH
47088: LD_INT 0
47090: PUSH
47091: LD_INT 3
47093: NEG
47094: PUSH
47095: EMPTY
47096: LIST
47097: LIST
47098: PUSH
47099: LD_INT 1
47101: PUSH
47102: LD_INT 2
47104: NEG
47105: PUSH
47106: EMPTY
47107: LIST
47108: LIST
47109: PUSH
47110: EMPTY
47111: LIST
47112: LIST
47113: LIST
47114: ST_TO_ADDR
// fBarracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
47115: LD_ADDR_VAR 0 54
47119: PUSH
47120: LD_INT 2
47122: PUSH
47123: LD_INT 1
47125: NEG
47126: PUSH
47127: EMPTY
47128: LIST
47129: LIST
47130: PUSH
47131: LD_INT 3
47133: PUSH
47134: LD_INT 0
47136: PUSH
47137: EMPTY
47138: LIST
47139: LIST
47140: PUSH
47141: LD_INT 3
47143: PUSH
47144: LD_INT 1
47146: PUSH
47147: EMPTY
47148: LIST
47149: LIST
47150: PUSH
47151: EMPTY
47152: LIST
47153: LIST
47154: LIST
47155: ST_TO_ADDR
// fBarracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
47156: LD_ADDR_VAR 0 55
47160: PUSH
47161: LD_INT 3
47163: PUSH
47164: LD_INT 2
47166: PUSH
47167: EMPTY
47168: LIST
47169: LIST
47170: PUSH
47171: LD_INT 3
47173: PUSH
47174: LD_INT 3
47176: PUSH
47177: EMPTY
47178: LIST
47179: LIST
47180: PUSH
47181: LD_INT 2
47183: PUSH
47184: LD_INT 3
47186: PUSH
47187: EMPTY
47188: LIST
47189: LIST
47190: PUSH
47191: EMPTY
47192: LIST
47193: LIST
47194: LIST
47195: ST_TO_ADDR
// fBarracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
47196: LD_ADDR_VAR 0 56
47200: PUSH
47201: LD_INT 1
47203: PUSH
47204: LD_INT 3
47206: PUSH
47207: EMPTY
47208: LIST
47209: LIST
47210: PUSH
47211: LD_INT 0
47213: PUSH
47214: LD_INT 3
47216: PUSH
47217: EMPTY
47218: LIST
47219: LIST
47220: PUSH
47221: LD_INT 1
47223: NEG
47224: PUSH
47225: LD_INT 2
47227: PUSH
47228: EMPTY
47229: LIST
47230: LIST
47231: PUSH
47232: EMPTY
47233: LIST
47234: LIST
47235: LIST
47236: ST_TO_ADDR
// fBarracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
47237: LD_ADDR_VAR 0 57
47241: PUSH
47242: LD_INT 2
47244: NEG
47245: PUSH
47246: LD_INT 1
47248: PUSH
47249: EMPTY
47250: LIST
47251: LIST
47252: PUSH
47253: LD_INT 3
47255: NEG
47256: PUSH
47257: LD_INT 0
47259: PUSH
47260: EMPTY
47261: LIST
47262: LIST
47263: PUSH
47264: LD_INT 3
47266: NEG
47267: PUSH
47268: LD_INT 1
47270: NEG
47271: PUSH
47272: EMPTY
47273: LIST
47274: LIST
47275: PUSH
47276: EMPTY
47277: LIST
47278: LIST
47279: LIST
47280: ST_TO_ADDR
// fBarracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
47281: LD_ADDR_VAR 0 58
47285: PUSH
47286: LD_INT 2
47288: NEG
47289: PUSH
47290: LD_INT 3
47292: NEG
47293: PUSH
47294: EMPTY
47295: LIST
47296: LIST
47297: PUSH
47298: LD_INT 3
47300: NEG
47301: PUSH
47302: LD_INT 2
47304: NEG
47305: PUSH
47306: EMPTY
47307: LIST
47308: LIST
47309: PUSH
47310: LD_INT 3
47312: NEG
47313: PUSH
47314: LD_INT 3
47316: NEG
47317: PUSH
47318: EMPTY
47319: LIST
47320: LIST
47321: PUSH
47322: EMPTY
47323: LIST
47324: LIST
47325: LIST
47326: ST_TO_ADDR
// fBunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
47327: LD_ADDR_VAR 0 59
47331: PUSH
47332: LD_INT 1
47334: NEG
47335: PUSH
47336: LD_INT 2
47338: NEG
47339: PUSH
47340: EMPTY
47341: LIST
47342: LIST
47343: PUSH
47344: LD_INT 0
47346: PUSH
47347: LD_INT 2
47349: NEG
47350: PUSH
47351: EMPTY
47352: LIST
47353: LIST
47354: PUSH
47355: LD_INT 1
47357: PUSH
47358: LD_INT 1
47360: NEG
47361: PUSH
47362: EMPTY
47363: LIST
47364: LIST
47365: PUSH
47366: EMPTY
47367: LIST
47368: LIST
47369: LIST
47370: ST_TO_ADDR
// fBunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
47371: LD_ADDR_VAR 0 60
47375: PUSH
47376: LD_INT 1
47378: PUSH
47379: LD_INT 1
47381: NEG
47382: PUSH
47383: EMPTY
47384: LIST
47385: LIST
47386: PUSH
47387: LD_INT 2
47389: PUSH
47390: LD_INT 0
47392: PUSH
47393: EMPTY
47394: LIST
47395: LIST
47396: PUSH
47397: LD_INT 2
47399: PUSH
47400: LD_INT 1
47402: PUSH
47403: EMPTY
47404: LIST
47405: LIST
47406: PUSH
47407: EMPTY
47408: LIST
47409: LIST
47410: LIST
47411: ST_TO_ADDR
// fBunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
47412: LD_ADDR_VAR 0 61
47416: PUSH
47417: LD_INT 2
47419: PUSH
47420: LD_INT 1
47422: PUSH
47423: EMPTY
47424: LIST
47425: LIST
47426: PUSH
47427: LD_INT 2
47429: PUSH
47430: LD_INT 2
47432: PUSH
47433: EMPTY
47434: LIST
47435: LIST
47436: PUSH
47437: LD_INT 1
47439: PUSH
47440: LD_INT 2
47442: PUSH
47443: EMPTY
47444: LIST
47445: LIST
47446: PUSH
47447: EMPTY
47448: LIST
47449: LIST
47450: LIST
47451: ST_TO_ADDR
// fBunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
47452: LD_ADDR_VAR 0 62
47456: PUSH
47457: LD_INT 1
47459: PUSH
47460: LD_INT 2
47462: PUSH
47463: EMPTY
47464: LIST
47465: LIST
47466: PUSH
47467: LD_INT 0
47469: PUSH
47470: LD_INT 2
47472: PUSH
47473: EMPTY
47474: LIST
47475: LIST
47476: PUSH
47477: LD_INT 1
47479: NEG
47480: PUSH
47481: LD_INT 1
47483: PUSH
47484: EMPTY
47485: LIST
47486: LIST
47487: PUSH
47488: EMPTY
47489: LIST
47490: LIST
47491: LIST
47492: ST_TO_ADDR
// fBunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
47493: LD_ADDR_VAR 0 63
47497: PUSH
47498: LD_INT 1
47500: NEG
47501: PUSH
47502: LD_INT 1
47504: PUSH
47505: EMPTY
47506: LIST
47507: LIST
47508: PUSH
47509: LD_INT 2
47511: NEG
47512: PUSH
47513: LD_INT 0
47515: PUSH
47516: EMPTY
47517: LIST
47518: LIST
47519: PUSH
47520: LD_INT 2
47522: NEG
47523: PUSH
47524: LD_INT 1
47526: NEG
47527: PUSH
47528: EMPTY
47529: LIST
47530: LIST
47531: PUSH
47532: EMPTY
47533: LIST
47534: LIST
47535: LIST
47536: ST_TO_ADDR
// fBunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
47537: LD_ADDR_VAR 0 64
47541: PUSH
47542: LD_INT 1
47544: NEG
47545: PUSH
47546: LD_INT 2
47548: NEG
47549: PUSH
47550: EMPTY
47551: LIST
47552: LIST
47553: PUSH
47554: LD_INT 2
47556: NEG
47557: PUSH
47558: LD_INT 1
47560: NEG
47561: PUSH
47562: EMPTY
47563: LIST
47564: LIST
47565: PUSH
47566: LD_INT 2
47568: NEG
47569: PUSH
47570: LD_INT 2
47572: NEG
47573: PUSH
47574: EMPTY
47575: LIST
47576: LIST
47577: PUSH
47578: EMPTY
47579: LIST
47580: LIST
47581: LIST
47582: ST_TO_ADDR
// end ; 2 :
47583: GO 50849
47585: LD_INT 2
47587: DOUBLE
47588: EQUAL
47589: IFTRUE 47593
47591: GO 50848
47593: POP
// begin fFactory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
47594: LD_ADDR_VAR 0 29
47598: PUSH
47599: LD_INT 4
47601: PUSH
47602: LD_INT 0
47604: PUSH
47605: EMPTY
47606: LIST
47607: LIST
47608: PUSH
47609: LD_INT 4
47611: PUSH
47612: LD_INT 1
47614: NEG
47615: PUSH
47616: EMPTY
47617: LIST
47618: LIST
47619: PUSH
47620: LD_INT 5
47622: PUSH
47623: LD_INT 0
47625: PUSH
47626: EMPTY
47627: LIST
47628: LIST
47629: PUSH
47630: LD_INT 5
47632: PUSH
47633: LD_INT 1
47635: PUSH
47636: EMPTY
47637: LIST
47638: LIST
47639: PUSH
47640: LD_INT 4
47642: PUSH
47643: LD_INT 1
47645: PUSH
47646: EMPTY
47647: LIST
47648: LIST
47649: PUSH
47650: LD_INT 3
47652: PUSH
47653: LD_INT 0
47655: PUSH
47656: EMPTY
47657: LIST
47658: LIST
47659: PUSH
47660: LD_INT 3
47662: PUSH
47663: LD_INT 1
47665: NEG
47666: PUSH
47667: EMPTY
47668: LIST
47669: LIST
47670: PUSH
47671: LD_INT 3
47673: PUSH
47674: LD_INT 2
47676: NEG
47677: PUSH
47678: EMPTY
47679: LIST
47680: LIST
47681: PUSH
47682: LD_INT 5
47684: PUSH
47685: LD_INT 2
47687: PUSH
47688: EMPTY
47689: LIST
47690: LIST
47691: PUSH
47692: LD_INT 3
47694: PUSH
47695: LD_INT 3
47697: PUSH
47698: EMPTY
47699: LIST
47700: LIST
47701: PUSH
47702: LD_INT 3
47704: PUSH
47705: LD_INT 2
47707: PUSH
47708: EMPTY
47709: LIST
47710: LIST
47711: PUSH
47712: LD_INT 4
47714: PUSH
47715: LD_INT 3
47717: PUSH
47718: EMPTY
47719: LIST
47720: LIST
47721: PUSH
47722: LD_INT 4
47724: PUSH
47725: LD_INT 4
47727: PUSH
47728: EMPTY
47729: LIST
47730: LIST
47731: PUSH
47732: LD_INT 3
47734: PUSH
47735: LD_INT 4
47737: PUSH
47738: EMPTY
47739: LIST
47740: LIST
47741: PUSH
47742: LD_INT 2
47744: PUSH
47745: LD_INT 3
47747: PUSH
47748: EMPTY
47749: LIST
47750: LIST
47751: PUSH
47752: LD_INT 2
47754: PUSH
47755: LD_INT 2
47757: PUSH
47758: EMPTY
47759: LIST
47760: LIST
47761: PUSH
47762: LD_INT 4
47764: PUSH
47765: LD_INT 2
47767: PUSH
47768: EMPTY
47769: LIST
47770: LIST
47771: PUSH
47772: LD_INT 2
47774: PUSH
47775: LD_INT 4
47777: PUSH
47778: EMPTY
47779: LIST
47780: LIST
47781: PUSH
47782: LD_INT 0
47784: PUSH
47785: LD_INT 4
47787: PUSH
47788: EMPTY
47789: LIST
47790: LIST
47791: PUSH
47792: LD_INT 0
47794: PUSH
47795: LD_INT 3
47797: PUSH
47798: EMPTY
47799: LIST
47800: LIST
47801: PUSH
47802: LD_INT 1
47804: PUSH
47805: LD_INT 4
47807: PUSH
47808: EMPTY
47809: LIST
47810: LIST
47811: PUSH
47812: LD_INT 1
47814: PUSH
47815: LD_INT 5
47817: PUSH
47818: EMPTY
47819: LIST
47820: LIST
47821: PUSH
47822: LD_INT 0
47824: PUSH
47825: LD_INT 5
47827: PUSH
47828: EMPTY
47829: LIST
47830: LIST
47831: PUSH
47832: LD_INT 1
47834: NEG
47835: PUSH
47836: LD_INT 4
47838: PUSH
47839: EMPTY
47840: LIST
47841: LIST
47842: PUSH
47843: LD_INT 1
47845: NEG
47846: PUSH
47847: LD_INT 3
47849: PUSH
47850: EMPTY
47851: LIST
47852: LIST
47853: PUSH
47854: LD_INT 2
47856: PUSH
47857: LD_INT 5
47859: PUSH
47860: EMPTY
47861: LIST
47862: LIST
47863: PUSH
47864: LD_INT 2
47866: NEG
47867: PUSH
47868: LD_INT 3
47870: PUSH
47871: EMPTY
47872: LIST
47873: LIST
47874: PUSH
47875: LD_INT 3
47877: NEG
47878: PUSH
47879: LD_INT 0
47881: PUSH
47882: EMPTY
47883: LIST
47884: LIST
47885: PUSH
47886: LD_INT 3
47888: NEG
47889: PUSH
47890: LD_INT 1
47892: NEG
47893: PUSH
47894: EMPTY
47895: LIST
47896: LIST
47897: PUSH
47898: LD_INT 2
47900: NEG
47901: PUSH
47902: LD_INT 0
47904: PUSH
47905: EMPTY
47906: LIST
47907: LIST
47908: PUSH
47909: LD_INT 2
47911: NEG
47912: PUSH
47913: LD_INT 1
47915: PUSH
47916: EMPTY
47917: LIST
47918: LIST
47919: PUSH
47920: LD_INT 3
47922: NEG
47923: PUSH
47924: LD_INT 1
47926: PUSH
47927: EMPTY
47928: LIST
47929: LIST
47930: PUSH
47931: LD_INT 4
47933: NEG
47934: PUSH
47935: LD_INT 0
47937: PUSH
47938: EMPTY
47939: LIST
47940: LIST
47941: PUSH
47942: LD_INT 4
47944: NEG
47945: PUSH
47946: LD_INT 1
47948: NEG
47949: PUSH
47950: EMPTY
47951: LIST
47952: LIST
47953: PUSH
47954: LD_INT 4
47956: NEG
47957: PUSH
47958: LD_INT 2
47960: NEG
47961: PUSH
47962: EMPTY
47963: LIST
47964: LIST
47965: PUSH
47966: LD_INT 2
47968: NEG
47969: PUSH
47970: LD_INT 2
47972: PUSH
47973: EMPTY
47974: LIST
47975: LIST
47976: PUSH
47977: LD_INT 4
47979: NEG
47980: PUSH
47981: LD_INT 4
47983: NEG
47984: PUSH
47985: EMPTY
47986: LIST
47987: LIST
47988: PUSH
47989: LD_INT 4
47991: NEG
47992: PUSH
47993: LD_INT 5
47995: NEG
47996: PUSH
47997: EMPTY
47998: LIST
47999: LIST
48000: PUSH
48001: LD_INT 3
48003: NEG
48004: PUSH
48005: LD_INT 4
48007: NEG
48008: PUSH
48009: EMPTY
48010: LIST
48011: LIST
48012: PUSH
48013: LD_INT 3
48015: NEG
48016: PUSH
48017: LD_INT 3
48019: NEG
48020: PUSH
48021: EMPTY
48022: LIST
48023: LIST
48024: PUSH
48025: LD_INT 4
48027: NEG
48028: PUSH
48029: LD_INT 3
48031: NEG
48032: PUSH
48033: EMPTY
48034: LIST
48035: LIST
48036: PUSH
48037: LD_INT 5
48039: NEG
48040: PUSH
48041: LD_INT 4
48043: NEG
48044: PUSH
48045: EMPTY
48046: LIST
48047: LIST
48048: PUSH
48049: LD_INT 5
48051: NEG
48052: PUSH
48053: LD_INT 5
48055: NEG
48056: PUSH
48057: EMPTY
48058: LIST
48059: LIST
48060: PUSH
48061: LD_INT 3
48063: NEG
48064: PUSH
48065: LD_INT 5
48067: NEG
48068: PUSH
48069: EMPTY
48070: LIST
48071: LIST
48072: PUSH
48073: LD_INT 5
48075: NEG
48076: PUSH
48077: LD_INT 3
48079: NEG
48080: PUSH
48081: EMPTY
48082: LIST
48083: LIST
48084: PUSH
48085: EMPTY
48086: LIST
48087: LIST
48088: LIST
48089: LIST
48090: LIST
48091: LIST
48092: LIST
48093: LIST
48094: LIST
48095: LIST
48096: LIST
48097: LIST
48098: LIST
48099: LIST
48100: LIST
48101: LIST
48102: LIST
48103: LIST
48104: LIST
48105: LIST
48106: LIST
48107: LIST
48108: LIST
48109: LIST
48110: LIST
48111: LIST
48112: LIST
48113: LIST
48114: LIST
48115: LIST
48116: LIST
48117: LIST
48118: LIST
48119: LIST
48120: LIST
48121: LIST
48122: LIST
48123: LIST
48124: LIST
48125: LIST
48126: LIST
48127: LIST
48128: LIST
48129: LIST
48130: LIST
48131: ST_TO_ADDR
// fFactory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
48132: LD_ADDR_VAR 0 30
48136: PUSH
48137: LD_INT 4
48139: PUSH
48140: LD_INT 4
48142: PUSH
48143: EMPTY
48144: LIST
48145: LIST
48146: PUSH
48147: LD_INT 4
48149: PUSH
48150: LD_INT 3
48152: PUSH
48153: EMPTY
48154: LIST
48155: LIST
48156: PUSH
48157: LD_INT 5
48159: PUSH
48160: LD_INT 4
48162: PUSH
48163: EMPTY
48164: LIST
48165: LIST
48166: PUSH
48167: LD_INT 5
48169: PUSH
48170: LD_INT 5
48172: PUSH
48173: EMPTY
48174: LIST
48175: LIST
48176: PUSH
48177: LD_INT 4
48179: PUSH
48180: LD_INT 5
48182: PUSH
48183: EMPTY
48184: LIST
48185: LIST
48186: PUSH
48187: LD_INT 3
48189: PUSH
48190: LD_INT 4
48192: PUSH
48193: EMPTY
48194: LIST
48195: LIST
48196: PUSH
48197: LD_INT 3
48199: PUSH
48200: LD_INT 3
48202: PUSH
48203: EMPTY
48204: LIST
48205: LIST
48206: PUSH
48207: LD_INT 5
48209: PUSH
48210: LD_INT 3
48212: PUSH
48213: EMPTY
48214: LIST
48215: LIST
48216: PUSH
48217: LD_INT 3
48219: PUSH
48220: LD_INT 5
48222: PUSH
48223: EMPTY
48224: LIST
48225: LIST
48226: PUSH
48227: LD_INT 0
48229: PUSH
48230: LD_INT 3
48232: PUSH
48233: EMPTY
48234: LIST
48235: LIST
48236: PUSH
48237: LD_INT 0
48239: PUSH
48240: LD_INT 2
48242: PUSH
48243: EMPTY
48244: LIST
48245: LIST
48246: PUSH
48247: LD_INT 1
48249: PUSH
48250: LD_INT 3
48252: PUSH
48253: EMPTY
48254: LIST
48255: LIST
48256: PUSH
48257: LD_INT 1
48259: PUSH
48260: LD_INT 4
48262: PUSH
48263: EMPTY
48264: LIST
48265: LIST
48266: PUSH
48267: LD_INT 0
48269: PUSH
48270: LD_INT 4
48272: PUSH
48273: EMPTY
48274: LIST
48275: LIST
48276: PUSH
48277: LD_INT 1
48279: NEG
48280: PUSH
48281: LD_INT 3
48283: PUSH
48284: EMPTY
48285: LIST
48286: LIST
48287: PUSH
48288: LD_INT 1
48290: NEG
48291: PUSH
48292: LD_INT 2
48294: PUSH
48295: EMPTY
48296: LIST
48297: LIST
48298: PUSH
48299: LD_INT 2
48301: PUSH
48302: LD_INT 4
48304: PUSH
48305: EMPTY
48306: LIST
48307: LIST
48308: PUSH
48309: LD_INT 2
48311: NEG
48312: PUSH
48313: LD_INT 2
48315: PUSH
48316: EMPTY
48317: LIST
48318: LIST
48319: PUSH
48320: LD_INT 4
48322: NEG
48323: PUSH
48324: LD_INT 0
48326: PUSH
48327: EMPTY
48328: LIST
48329: LIST
48330: PUSH
48331: LD_INT 4
48333: NEG
48334: PUSH
48335: LD_INT 1
48337: NEG
48338: PUSH
48339: EMPTY
48340: LIST
48341: LIST
48342: PUSH
48343: LD_INT 3
48345: NEG
48346: PUSH
48347: LD_INT 0
48349: PUSH
48350: EMPTY
48351: LIST
48352: LIST
48353: PUSH
48354: LD_INT 3
48356: NEG
48357: PUSH
48358: LD_INT 1
48360: PUSH
48361: EMPTY
48362: LIST
48363: LIST
48364: PUSH
48365: LD_INT 4
48367: NEG
48368: PUSH
48369: LD_INT 1
48371: PUSH
48372: EMPTY
48373: LIST
48374: LIST
48375: PUSH
48376: LD_INT 5
48378: NEG
48379: PUSH
48380: LD_INT 0
48382: PUSH
48383: EMPTY
48384: LIST
48385: LIST
48386: PUSH
48387: LD_INT 5
48389: NEG
48390: PUSH
48391: LD_INT 1
48393: NEG
48394: PUSH
48395: EMPTY
48396: LIST
48397: LIST
48398: PUSH
48399: LD_INT 5
48401: NEG
48402: PUSH
48403: LD_INT 2
48405: NEG
48406: PUSH
48407: EMPTY
48408: LIST
48409: LIST
48410: PUSH
48411: LD_INT 3
48413: NEG
48414: PUSH
48415: LD_INT 2
48417: PUSH
48418: EMPTY
48419: LIST
48420: LIST
48421: PUSH
48422: LD_INT 3
48424: NEG
48425: PUSH
48426: LD_INT 3
48428: NEG
48429: PUSH
48430: EMPTY
48431: LIST
48432: LIST
48433: PUSH
48434: LD_INT 3
48436: NEG
48437: PUSH
48438: LD_INT 4
48440: NEG
48441: PUSH
48442: EMPTY
48443: LIST
48444: LIST
48445: PUSH
48446: LD_INT 2
48448: NEG
48449: PUSH
48450: LD_INT 3
48452: NEG
48453: PUSH
48454: EMPTY
48455: LIST
48456: LIST
48457: PUSH
48458: LD_INT 2
48460: NEG
48461: PUSH
48462: LD_INT 2
48464: NEG
48465: PUSH
48466: EMPTY
48467: LIST
48468: LIST
48469: PUSH
48470: LD_INT 3
48472: NEG
48473: PUSH
48474: LD_INT 2
48476: NEG
48477: PUSH
48478: EMPTY
48479: LIST
48480: LIST
48481: PUSH
48482: LD_INT 4
48484: NEG
48485: PUSH
48486: LD_INT 3
48488: NEG
48489: PUSH
48490: EMPTY
48491: LIST
48492: LIST
48493: PUSH
48494: LD_INT 4
48496: NEG
48497: PUSH
48498: LD_INT 4
48500: NEG
48501: PUSH
48502: EMPTY
48503: LIST
48504: LIST
48505: PUSH
48506: LD_INT 2
48508: NEG
48509: PUSH
48510: LD_INT 4
48512: NEG
48513: PUSH
48514: EMPTY
48515: LIST
48516: LIST
48517: PUSH
48518: LD_INT 4
48520: NEG
48521: PUSH
48522: LD_INT 2
48524: NEG
48525: PUSH
48526: EMPTY
48527: LIST
48528: LIST
48529: PUSH
48530: LD_INT 0
48532: PUSH
48533: LD_INT 4
48535: NEG
48536: PUSH
48537: EMPTY
48538: LIST
48539: LIST
48540: PUSH
48541: LD_INT 0
48543: PUSH
48544: LD_INT 5
48546: NEG
48547: PUSH
48548: EMPTY
48549: LIST
48550: LIST
48551: PUSH
48552: LD_INT 1
48554: PUSH
48555: LD_INT 4
48557: NEG
48558: PUSH
48559: EMPTY
48560: LIST
48561: LIST
48562: PUSH
48563: LD_INT 1
48565: PUSH
48566: LD_INT 3
48568: NEG
48569: PUSH
48570: EMPTY
48571: LIST
48572: LIST
48573: PUSH
48574: LD_INT 0
48576: PUSH
48577: LD_INT 3
48579: NEG
48580: PUSH
48581: EMPTY
48582: LIST
48583: LIST
48584: PUSH
48585: LD_INT 1
48587: NEG
48588: PUSH
48589: LD_INT 4
48591: NEG
48592: PUSH
48593: EMPTY
48594: LIST
48595: LIST
48596: PUSH
48597: LD_INT 1
48599: NEG
48600: PUSH
48601: LD_INT 5
48603: NEG
48604: PUSH
48605: EMPTY
48606: LIST
48607: LIST
48608: PUSH
48609: LD_INT 2
48611: PUSH
48612: LD_INT 3
48614: NEG
48615: PUSH
48616: EMPTY
48617: LIST
48618: LIST
48619: PUSH
48620: LD_INT 2
48622: NEG
48623: PUSH
48624: LD_INT 5
48626: NEG
48627: PUSH
48628: EMPTY
48629: LIST
48630: LIST
48631: PUSH
48632: EMPTY
48633: LIST
48634: LIST
48635: LIST
48636: LIST
48637: LIST
48638: LIST
48639: LIST
48640: LIST
48641: LIST
48642: LIST
48643: LIST
48644: LIST
48645: LIST
48646: LIST
48647: LIST
48648: LIST
48649: LIST
48650: LIST
48651: LIST
48652: LIST
48653: LIST
48654: LIST
48655: LIST
48656: LIST
48657: LIST
48658: LIST
48659: LIST
48660: LIST
48661: LIST
48662: LIST
48663: LIST
48664: LIST
48665: LIST
48666: LIST
48667: LIST
48668: LIST
48669: LIST
48670: LIST
48671: LIST
48672: LIST
48673: LIST
48674: LIST
48675: LIST
48676: LIST
48677: LIST
48678: ST_TO_ADDR
// fFactory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
48679: LD_ADDR_VAR 0 31
48683: PUSH
48684: LD_INT 0
48686: PUSH
48687: LD_INT 4
48689: PUSH
48690: EMPTY
48691: LIST
48692: LIST
48693: PUSH
48694: LD_INT 0
48696: PUSH
48697: LD_INT 3
48699: PUSH
48700: EMPTY
48701: LIST
48702: LIST
48703: PUSH
48704: LD_INT 1
48706: PUSH
48707: LD_INT 4
48709: PUSH
48710: EMPTY
48711: LIST
48712: LIST
48713: PUSH
48714: LD_INT 1
48716: PUSH
48717: LD_INT 5
48719: PUSH
48720: EMPTY
48721: LIST
48722: LIST
48723: PUSH
48724: LD_INT 0
48726: PUSH
48727: LD_INT 5
48729: PUSH
48730: EMPTY
48731: LIST
48732: LIST
48733: PUSH
48734: LD_INT 1
48736: NEG
48737: PUSH
48738: LD_INT 4
48740: PUSH
48741: EMPTY
48742: LIST
48743: LIST
48744: PUSH
48745: LD_INT 1
48747: NEG
48748: PUSH
48749: LD_INT 3
48751: PUSH
48752: EMPTY
48753: LIST
48754: LIST
48755: PUSH
48756: LD_INT 2
48758: PUSH
48759: LD_INT 5
48761: PUSH
48762: EMPTY
48763: LIST
48764: LIST
48765: PUSH
48766: LD_INT 2
48768: NEG
48769: PUSH
48770: LD_INT 3
48772: PUSH
48773: EMPTY
48774: LIST
48775: LIST
48776: PUSH
48777: LD_INT 3
48779: NEG
48780: PUSH
48781: LD_INT 0
48783: PUSH
48784: EMPTY
48785: LIST
48786: LIST
48787: PUSH
48788: LD_INT 3
48790: NEG
48791: PUSH
48792: LD_INT 1
48794: NEG
48795: PUSH
48796: EMPTY
48797: LIST
48798: LIST
48799: PUSH
48800: LD_INT 2
48802: NEG
48803: PUSH
48804: LD_INT 0
48806: PUSH
48807: EMPTY
48808: LIST
48809: LIST
48810: PUSH
48811: LD_INT 2
48813: NEG
48814: PUSH
48815: LD_INT 1
48817: PUSH
48818: EMPTY
48819: LIST
48820: LIST
48821: PUSH
48822: LD_INT 3
48824: NEG
48825: PUSH
48826: LD_INT 1
48828: PUSH
48829: EMPTY
48830: LIST
48831: LIST
48832: PUSH
48833: LD_INT 4
48835: NEG
48836: PUSH
48837: LD_INT 0
48839: PUSH
48840: EMPTY
48841: LIST
48842: LIST
48843: PUSH
48844: LD_INT 4
48846: NEG
48847: PUSH
48848: LD_INT 1
48850: NEG
48851: PUSH
48852: EMPTY
48853: LIST
48854: LIST
48855: PUSH
48856: LD_INT 4
48858: NEG
48859: PUSH
48860: LD_INT 2
48862: NEG
48863: PUSH
48864: EMPTY
48865: LIST
48866: LIST
48867: PUSH
48868: LD_INT 2
48870: NEG
48871: PUSH
48872: LD_INT 2
48874: PUSH
48875: EMPTY
48876: LIST
48877: LIST
48878: PUSH
48879: LD_INT 4
48881: NEG
48882: PUSH
48883: LD_INT 4
48885: NEG
48886: PUSH
48887: EMPTY
48888: LIST
48889: LIST
48890: PUSH
48891: LD_INT 4
48893: NEG
48894: PUSH
48895: LD_INT 5
48897: NEG
48898: PUSH
48899: EMPTY
48900: LIST
48901: LIST
48902: PUSH
48903: LD_INT 3
48905: NEG
48906: PUSH
48907: LD_INT 4
48909: NEG
48910: PUSH
48911: EMPTY
48912: LIST
48913: LIST
48914: PUSH
48915: LD_INT 3
48917: NEG
48918: PUSH
48919: LD_INT 3
48921: NEG
48922: PUSH
48923: EMPTY
48924: LIST
48925: LIST
48926: PUSH
48927: LD_INT 4
48929: NEG
48930: PUSH
48931: LD_INT 3
48933: NEG
48934: PUSH
48935: EMPTY
48936: LIST
48937: LIST
48938: PUSH
48939: LD_INT 5
48941: NEG
48942: PUSH
48943: LD_INT 4
48945: NEG
48946: PUSH
48947: EMPTY
48948: LIST
48949: LIST
48950: PUSH
48951: LD_INT 5
48953: NEG
48954: PUSH
48955: LD_INT 5
48957: NEG
48958: PUSH
48959: EMPTY
48960: LIST
48961: LIST
48962: PUSH
48963: LD_INT 3
48965: NEG
48966: PUSH
48967: LD_INT 5
48969: NEG
48970: PUSH
48971: EMPTY
48972: LIST
48973: LIST
48974: PUSH
48975: LD_INT 5
48977: NEG
48978: PUSH
48979: LD_INT 3
48981: NEG
48982: PUSH
48983: EMPTY
48984: LIST
48985: LIST
48986: PUSH
48987: LD_INT 0
48989: PUSH
48990: LD_INT 3
48992: NEG
48993: PUSH
48994: EMPTY
48995: LIST
48996: LIST
48997: PUSH
48998: LD_INT 0
49000: PUSH
49001: LD_INT 4
49003: NEG
49004: PUSH
49005: EMPTY
49006: LIST
49007: LIST
49008: PUSH
49009: LD_INT 1
49011: PUSH
49012: LD_INT 3
49014: NEG
49015: PUSH
49016: EMPTY
49017: LIST
49018: LIST
49019: PUSH
49020: LD_INT 1
49022: PUSH
49023: LD_INT 2
49025: NEG
49026: PUSH
49027: EMPTY
49028: LIST
49029: LIST
49030: PUSH
49031: LD_INT 0
49033: PUSH
49034: LD_INT 2
49036: NEG
49037: PUSH
49038: EMPTY
49039: LIST
49040: LIST
49041: PUSH
49042: LD_INT 1
49044: NEG
49045: PUSH
49046: LD_INT 3
49048: NEG
49049: PUSH
49050: EMPTY
49051: LIST
49052: LIST
49053: PUSH
49054: LD_INT 1
49056: NEG
49057: PUSH
49058: LD_INT 4
49060: NEG
49061: PUSH
49062: EMPTY
49063: LIST
49064: LIST
49065: PUSH
49066: LD_INT 2
49068: PUSH
49069: LD_INT 2
49071: NEG
49072: PUSH
49073: EMPTY
49074: LIST
49075: LIST
49076: PUSH
49077: LD_INT 2
49079: NEG
49080: PUSH
49081: LD_INT 4
49083: NEG
49084: PUSH
49085: EMPTY
49086: LIST
49087: LIST
49088: PUSH
49089: LD_INT 4
49091: PUSH
49092: LD_INT 0
49094: PUSH
49095: EMPTY
49096: LIST
49097: LIST
49098: PUSH
49099: LD_INT 4
49101: PUSH
49102: LD_INT 1
49104: NEG
49105: PUSH
49106: EMPTY
49107: LIST
49108: LIST
49109: PUSH
49110: LD_INT 5
49112: PUSH
49113: LD_INT 0
49115: PUSH
49116: EMPTY
49117: LIST
49118: LIST
49119: PUSH
49120: LD_INT 5
49122: PUSH
49123: LD_INT 1
49125: PUSH
49126: EMPTY
49127: LIST
49128: LIST
49129: PUSH
49130: LD_INT 4
49132: PUSH
49133: LD_INT 1
49135: PUSH
49136: EMPTY
49137: LIST
49138: LIST
49139: PUSH
49140: LD_INT 3
49142: PUSH
49143: LD_INT 0
49145: PUSH
49146: EMPTY
49147: LIST
49148: LIST
49149: PUSH
49150: LD_INT 3
49152: PUSH
49153: LD_INT 1
49155: NEG
49156: PUSH
49157: EMPTY
49158: LIST
49159: LIST
49160: PUSH
49161: LD_INT 3
49163: PUSH
49164: LD_INT 2
49166: NEG
49167: PUSH
49168: EMPTY
49169: LIST
49170: LIST
49171: PUSH
49172: LD_INT 5
49174: PUSH
49175: LD_INT 2
49177: PUSH
49178: EMPTY
49179: LIST
49180: LIST
49181: PUSH
49182: EMPTY
49183: LIST
49184: LIST
49185: LIST
49186: LIST
49187: LIST
49188: LIST
49189: LIST
49190: LIST
49191: LIST
49192: LIST
49193: LIST
49194: LIST
49195: LIST
49196: LIST
49197: LIST
49198: LIST
49199: LIST
49200: LIST
49201: LIST
49202: LIST
49203: LIST
49204: LIST
49205: LIST
49206: LIST
49207: LIST
49208: LIST
49209: LIST
49210: LIST
49211: LIST
49212: LIST
49213: LIST
49214: LIST
49215: LIST
49216: LIST
49217: LIST
49218: LIST
49219: LIST
49220: LIST
49221: LIST
49222: LIST
49223: LIST
49224: LIST
49225: LIST
49226: LIST
49227: LIST
49228: ST_TO_ADDR
// fFactory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
49229: LD_ADDR_VAR 0 32
49233: PUSH
49234: LD_INT 4
49236: NEG
49237: PUSH
49238: LD_INT 0
49240: PUSH
49241: EMPTY
49242: LIST
49243: LIST
49244: PUSH
49245: LD_INT 4
49247: NEG
49248: PUSH
49249: LD_INT 1
49251: NEG
49252: PUSH
49253: EMPTY
49254: LIST
49255: LIST
49256: PUSH
49257: LD_INT 3
49259: NEG
49260: PUSH
49261: LD_INT 0
49263: PUSH
49264: EMPTY
49265: LIST
49266: LIST
49267: PUSH
49268: LD_INT 3
49270: NEG
49271: PUSH
49272: LD_INT 1
49274: PUSH
49275: EMPTY
49276: LIST
49277: LIST
49278: PUSH
49279: LD_INT 4
49281: NEG
49282: PUSH
49283: LD_INT 1
49285: PUSH
49286: EMPTY
49287: LIST
49288: LIST
49289: PUSH
49290: LD_INT 5
49292: NEG
49293: PUSH
49294: LD_INT 0
49296: PUSH
49297: EMPTY
49298: LIST
49299: LIST
49300: PUSH
49301: LD_INT 5
49303: NEG
49304: PUSH
49305: LD_INT 1
49307: NEG
49308: PUSH
49309: EMPTY
49310: LIST
49311: LIST
49312: PUSH
49313: LD_INT 5
49315: NEG
49316: PUSH
49317: LD_INT 2
49319: NEG
49320: PUSH
49321: EMPTY
49322: LIST
49323: LIST
49324: PUSH
49325: LD_INT 3
49327: NEG
49328: PUSH
49329: LD_INT 2
49331: PUSH
49332: EMPTY
49333: LIST
49334: LIST
49335: PUSH
49336: LD_INT 3
49338: NEG
49339: PUSH
49340: LD_INT 3
49342: NEG
49343: PUSH
49344: EMPTY
49345: LIST
49346: LIST
49347: PUSH
49348: LD_INT 3
49350: NEG
49351: PUSH
49352: LD_INT 4
49354: NEG
49355: PUSH
49356: EMPTY
49357: LIST
49358: LIST
49359: PUSH
49360: LD_INT 2
49362: NEG
49363: PUSH
49364: LD_INT 3
49366: NEG
49367: PUSH
49368: EMPTY
49369: LIST
49370: LIST
49371: PUSH
49372: LD_INT 2
49374: NEG
49375: PUSH
49376: LD_INT 2
49378: NEG
49379: PUSH
49380: EMPTY
49381: LIST
49382: LIST
49383: PUSH
49384: LD_INT 3
49386: NEG
49387: PUSH
49388: LD_INT 2
49390: NEG
49391: PUSH
49392: EMPTY
49393: LIST
49394: LIST
49395: PUSH
49396: LD_INT 4
49398: NEG
49399: PUSH
49400: LD_INT 3
49402: NEG
49403: PUSH
49404: EMPTY
49405: LIST
49406: LIST
49407: PUSH
49408: LD_INT 4
49410: NEG
49411: PUSH
49412: LD_INT 4
49414: NEG
49415: PUSH
49416: EMPTY
49417: LIST
49418: LIST
49419: PUSH
49420: LD_INT 2
49422: NEG
49423: PUSH
49424: LD_INT 4
49426: NEG
49427: PUSH
49428: EMPTY
49429: LIST
49430: LIST
49431: PUSH
49432: LD_INT 4
49434: NEG
49435: PUSH
49436: LD_INT 2
49438: NEG
49439: PUSH
49440: EMPTY
49441: LIST
49442: LIST
49443: PUSH
49444: LD_INT 0
49446: PUSH
49447: LD_INT 4
49449: NEG
49450: PUSH
49451: EMPTY
49452: LIST
49453: LIST
49454: PUSH
49455: LD_INT 0
49457: PUSH
49458: LD_INT 5
49460: NEG
49461: PUSH
49462: EMPTY
49463: LIST
49464: LIST
49465: PUSH
49466: LD_INT 1
49468: PUSH
49469: LD_INT 4
49471: NEG
49472: PUSH
49473: EMPTY
49474: LIST
49475: LIST
49476: PUSH
49477: LD_INT 1
49479: PUSH
49480: LD_INT 3
49482: NEG
49483: PUSH
49484: EMPTY
49485: LIST
49486: LIST
49487: PUSH
49488: LD_INT 0
49490: PUSH
49491: LD_INT 3
49493: NEG
49494: PUSH
49495: EMPTY
49496: LIST
49497: LIST
49498: PUSH
49499: LD_INT 1
49501: NEG
49502: PUSH
49503: LD_INT 4
49505: NEG
49506: PUSH
49507: EMPTY
49508: LIST
49509: LIST
49510: PUSH
49511: LD_INT 1
49513: NEG
49514: PUSH
49515: LD_INT 5
49517: NEG
49518: PUSH
49519: EMPTY
49520: LIST
49521: LIST
49522: PUSH
49523: LD_INT 2
49525: PUSH
49526: LD_INT 3
49528: NEG
49529: PUSH
49530: EMPTY
49531: LIST
49532: LIST
49533: PUSH
49534: LD_INT 2
49536: NEG
49537: PUSH
49538: LD_INT 5
49540: NEG
49541: PUSH
49542: EMPTY
49543: LIST
49544: LIST
49545: PUSH
49546: LD_INT 3
49548: PUSH
49549: LD_INT 0
49551: PUSH
49552: EMPTY
49553: LIST
49554: LIST
49555: PUSH
49556: LD_INT 3
49558: PUSH
49559: LD_INT 1
49561: NEG
49562: PUSH
49563: EMPTY
49564: LIST
49565: LIST
49566: PUSH
49567: LD_INT 4
49569: PUSH
49570: LD_INT 0
49572: PUSH
49573: EMPTY
49574: LIST
49575: LIST
49576: PUSH
49577: LD_INT 4
49579: PUSH
49580: LD_INT 1
49582: PUSH
49583: EMPTY
49584: LIST
49585: LIST
49586: PUSH
49587: LD_INT 3
49589: PUSH
49590: LD_INT 1
49592: PUSH
49593: EMPTY
49594: LIST
49595: LIST
49596: PUSH
49597: LD_INT 2
49599: PUSH
49600: LD_INT 0
49602: PUSH
49603: EMPTY
49604: LIST
49605: LIST
49606: PUSH
49607: LD_INT 2
49609: PUSH
49610: LD_INT 1
49612: NEG
49613: PUSH
49614: EMPTY
49615: LIST
49616: LIST
49617: PUSH
49618: LD_INT 2
49620: PUSH
49621: LD_INT 2
49623: NEG
49624: PUSH
49625: EMPTY
49626: LIST
49627: LIST
49628: PUSH
49629: LD_INT 4
49631: PUSH
49632: LD_INT 2
49634: PUSH
49635: EMPTY
49636: LIST
49637: LIST
49638: PUSH
49639: LD_INT 4
49641: PUSH
49642: LD_INT 4
49644: PUSH
49645: EMPTY
49646: LIST
49647: LIST
49648: PUSH
49649: LD_INT 4
49651: PUSH
49652: LD_INT 3
49654: PUSH
49655: EMPTY
49656: LIST
49657: LIST
49658: PUSH
49659: LD_INT 5
49661: PUSH
49662: LD_INT 4
49664: PUSH
49665: EMPTY
49666: LIST
49667: LIST
49668: PUSH
49669: LD_INT 5
49671: PUSH
49672: LD_INT 5
49674: PUSH
49675: EMPTY
49676: LIST
49677: LIST
49678: PUSH
49679: LD_INT 4
49681: PUSH
49682: LD_INT 5
49684: PUSH
49685: EMPTY
49686: LIST
49687: LIST
49688: PUSH
49689: LD_INT 3
49691: PUSH
49692: LD_INT 4
49694: PUSH
49695: EMPTY
49696: LIST
49697: LIST
49698: PUSH
49699: LD_INT 3
49701: PUSH
49702: LD_INT 3
49704: PUSH
49705: EMPTY
49706: LIST
49707: LIST
49708: PUSH
49709: LD_INT 5
49711: PUSH
49712: LD_INT 3
49714: PUSH
49715: EMPTY
49716: LIST
49717: LIST
49718: PUSH
49719: LD_INT 3
49721: PUSH
49722: LD_INT 5
49724: PUSH
49725: EMPTY
49726: LIST
49727: LIST
49728: PUSH
49729: EMPTY
49730: LIST
49731: LIST
49732: LIST
49733: LIST
49734: LIST
49735: LIST
49736: LIST
49737: LIST
49738: LIST
49739: LIST
49740: LIST
49741: LIST
49742: LIST
49743: LIST
49744: LIST
49745: LIST
49746: LIST
49747: LIST
49748: LIST
49749: LIST
49750: LIST
49751: LIST
49752: LIST
49753: LIST
49754: LIST
49755: LIST
49756: LIST
49757: LIST
49758: LIST
49759: LIST
49760: LIST
49761: LIST
49762: LIST
49763: LIST
49764: LIST
49765: LIST
49766: LIST
49767: LIST
49768: LIST
49769: LIST
49770: LIST
49771: LIST
49772: LIST
49773: LIST
49774: LIST
49775: ST_TO_ADDR
// fFactory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
49776: LD_ADDR_VAR 0 33
49780: PUSH
49781: LD_INT 4
49783: NEG
49784: PUSH
49785: LD_INT 4
49787: NEG
49788: PUSH
49789: EMPTY
49790: LIST
49791: LIST
49792: PUSH
49793: LD_INT 4
49795: NEG
49796: PUSH
49797: LD_INT 5
49799: NEG
49800: PUSH
49801: EMPTY
49802: LIST
49803: LIST
49804: PUSH
49805: LD_INT 3
49807: NEG
49808: PUSH
49809: LD_INT 4
49811: NEG
49812: PUSH
49813: EMPTY
49814: LIST
49815: LIST
49816: PUSH
49817: LD_INT 3
49819: NEG
49820: PUSH
49821: LD_INT 3
49823: NEG
49824: PUSH
49825: EMPTY
49826: LIST
49827: LIST
49828: PUSH
49829: LD_INT 4
49831: NEG
49832: PUSH
49833: LD_INT 3
49835: NEG
49836: PUSH
49837: EMPTY
49838: LIST
49839: LIST
49840: PUSH
49841: LD_INT 5
49843: NEG
49844: PUSH
49845: LD_INT 4
49847: NEG
49848: PUSH
49849: EMPTY
49850: LIST
49851: LIST
49852: PUSH
49853: LD_INT 5
49855: NEG
49856: PUSH
49857: LD_INT 5
49859: NEG
49860: PUSH
49861: EMPTY
49862: LIST
49863: LIST
49864: PUSH
49865: LD_INT 3
49867: NEG
49868: PUSH
49869: LD_INT 5
49871: NEG
49872: PUSH
49873: EMPTY
49874: LIST
49875: LIST
49876: PUSH
49877: LD_INT 5
49879: NEG
49880: PUSH
49881: LD_INT 3
49883: NEG
49884: PUSH
49885: EMPTY
49886: LIST
49887: LIST
49888: PUSH
49889: LD_INT 0
49891: PUSH
49892: LD_INT 3
49894: NEG
49895: PUSH
49896: EMPTY
49897: LIST
49898: LIST
49899: PUSH
49900: LD_INT 0
49902: PUSH
49903: LD_INT 4
49905: NEG
49906: PUSH
49907: EMPTY
49908: LIST
49909: LIST
49910: PUSH
49911: LD_INT 1
49913: PUSH
49914: LD_INT 3
49916: NEG
49917: PUSH
49918: EMPTY
49919: LIST
49920: LIST
49921: PUSH
49922: LD_INT 1
49924: PUSH
49925: LD_INT 2
49927: NEG
49928: PUSH
49929: EMPTY
49930: LIST
49931: LIST
49932: PUSH
49933: LD_INT 0
49935: PUSH
49936: LD_INT 2
49938: NEG
49939: PUSH
49940: EMPTY
49941: LIST
49942: LIST
49943: PUSH
49944: LD_INT 1
49946: NEG
49947: PUSH
49948: LD_INT 3
49950: NEG
49951: PUSH
49952: EMPTY
49953: LIST
49954: LIST
49955: PUSH
49956: LD_INT 1
49958: NEG
49959: PUSH
49960: LD_INT 4
49962: NEG
49963: PUSH
49964: EMPTY
49965: LIST
49966: LIST
49967: PUSH
49968: LD_INT 2
49970: PUSH
49971: LD_INT 2
49973: NEG
49974: PUSH
49975: EMPTY
49976: LIST
49977: LIST
49978: PUSH
49979: LD_INT 2
49981: NEG
49982: PUSH
49983: LD_INT 4
49985: NEG
49986: PUSH
49987: EMPTY
49988: LIST
49989: LIST
49990: PUSH
49991: LD_INT 4
49993: PUSH
49994: LD_INT 0
49996: PUSH
49997: EMPTY
49998: LIST
49999: LIST
50000: PUSH
50001: LD_INT 4
50003: PUSH
50004: LD_INT 1
50006: NEG
50007: PUSH
50008: EMPTY
50009: LIST
50010: LIST
50011: PUSH
50012: LD_INT 5
50014: PUSH
50015: LD_INT 0
50017: PUSH
50018: EMPTY
50019: LIST
50020: LIST
50021: PUSH
50022: LD_INT 5
50024: PUSH
50025: LD_INT 1
50027: PUSH
50028: EMPTY
50029: LIST
50030: LIST
50031: PUSH
50032: LD_INT 4
50034: PUSH
50035: LD_INT 1
50037: PUSH
50038: EMPTY
50039: LIST
50040: LIST
50041: PUSH
50042: LD_INT 3
50044: PUSH
50045: LD_INT 0
50047: PUSH
50048: EMPTY
50049: LIST
50050: LIST
50051: PUSH
50052: LD_INT 3
50054: PUSH
50055: LD_INT 1
50057: NEG
50058: PUSH
50059: EMPTY
50060: LIST
50061: LIST
50062: PUSH
50063: LD_INT 3
50065: PUSH
50066: LD_INT 2
50068: NEG
50069: PUSH
50070: EMPTY
50071: LIST
50072: LIST
50073: PUSH
50074: LD_INT 5
50076: PUSH
50077: LD_INT 2
50079: PUSH
50080: EMPTY
50081: LIST
50082: LIST
50083: PUSH
50084: LD_INT 3
50086: PUSH
50087: LD_INT 3
50089: PUSH
50090: EMPTY
50091: LIST
50092: LIST
50093: PUSH
50094: LD_INT 3
50096: PUSH
50097: LD_INT 2
50099: PUSH
50100: EMPTY
50101: LIST
50102: LIST
50103: PUSH
50104: LD_INT 4
50106: PUSH
50107: LD_INT 3
50109: PUSH
50110: EMPTY
50111: LIST
50112: LIST
50113: PUSH
50114: LD_INT 4
50116: PUSH
50117: LD_INT 4
50119: PUSH
50120: EMPTY
50121: LIST
50122: LIST
50123: PUSH
50124: LD_INT 3
50126: PUSH
50127: LD_INT 4
50129: PUSH
50130: EMPTY
50131: LIST
50132: LIST
50133: PUSH
50134: LD_INT 2
50136: PUSH
50137: LD_INT 3
50139: PUSH
50140: EMPTY
50141: LIST
50142: LIST
50143: PUSH
50144: LD_INT 2
50146: PUSH
50147: LD_INT 2
50149: PUSH
50150: EMPTY
50151: LIST
50152: LIST
50153: PUSH
50154: LD_INT 4
50156: PUSH
50157: LD_INT 2
50159: PUSH
50160: EMPTY
50161: LIST
50162: LIST
50163: PUSH
50164: LD_INT 2
50166: PUSH
50167: LD_INT 4
50169: PUSH
50170: EMPTY
50171: LIST
50172: LIST
50173: PUSH
50174: LD_INT 0
50176: PUSH
50177: LD_INT 4
50179: PUSH
50180: EMPTY
50181: LIST
50182: LIST
50183: PUSH
50184: LD_INT 0
50186: PUSH
50187: LD_INT 3
50189: PUSH
50190: EMPTY
50191: LIST
50192: LIST
50193: PUSH
50194: LD_INT 1
50196: PUSH
50197: LD_INT 4
50199: PUSH
50200: EMPTY
50201: LIST
50202: LIST
50203: PUSH
50204: LD_INT 1
50206: PUSH
50207: LD_INT 5
50209: PUSH
50210: EMPTY
50211: LIST
50212: LIST
50213: PUSH
50214: LD_INT 0
50216: PUSH
50217: LD_INT 5
50219: PUSH
50220: EMPTY
50221: LIST
50222: LIST
50223: PUSH
50224: LD_INT 1
50226: NEG
50227: PUSH
50228: LD_INT 4
50230: PUSH
50231: EMPTY
50232: LIST
50233: LIST
50234: PUSH
50235: LD_INT 1
50237: NEG
50238: PUSH
50239: LD_INT 3
50241: PUSH
50242: EMPTY
50243: LIST
50244: LIST
50245: PUSH
50246: LD_INT 2
50248: PUSH
50249: LD_INT 5
50251: PUSH
50252: EMPTY
50253: LIST
50254: LIST
50255: PUSH
50256: LD_INT 2
50258: NEG
50259: PUSH
50260: LD_INT 3
50262: PUSH
50263: EMPTY
50264: LIST
50265: LIST
50266: PUSH
50267: EMPTY
50268: LIST
50269: LIST
50270: LIST
50271: LIST
50272: LIST
50273: LIST
50274: LIST
50275: LIST
50276: LIST
50277: LIST
50278: LIST
50279: LIST
50280: LIST
50281: LIST
50282: LIST
50283: LIST
50284: LIST
50285: LIST
50286: LIST
50287: LIST
50288: LIST
50289: LIST
50290: LIST
50291: LIST
50292: LIST
50293: LIST
50294: LIST
50295: LIST
50296: LIST
50297: LIST
50298: LIST
50299: LIST
50300: LIST
50301: LIST
50302: LIST
50303: LIST
50304: LIST
50305: LIST
50306: LIST
50307: LIST
50308: LIST
50309: LIST
50310: LIST
50311: LIST
50312: LIST
50313: ST_TO_ADDR
// fFactory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
50314: LD_ADDR_VAR 0 34
50318: PUSH
50319: LD_INT 0
50321: PUSH
50322: LD_INT 4
50324: NEG
50325: PUSH
50326: EMPTY
50327: LIST
50328: LIST
50329: PUSH
50330: LD_INT 0
50332: PUSH
50333: LD_INT 5
50335: NEG
50336: PUSH
50337: EMPTY
50338: LIST
50339: LIST
50340: PUSH
50341: LD_INT 1
50343: PUSH
50344: LD_INT 4
50346: NEG
50347: PUSH
50348: EMPTY
50349: LIST
50350: LIST
50351: PUSH
50352: LD_INT 1
50354: PUSH
50355: LD_INT 3
50357: NEG
50358: PUSH
50359: EMPTY
50360: LIST
50361: LIST
50362: PUSH
50363: LD_INT 0
50365: PUSH
50366: LD_INT 3
50368: NEG
50369: PUSH
50370: EMPTY
50371: LIST
50372: LIST
50373: PUSH
50374: LD_INT 1
50376: NEG
50377: PUSH
50378: LD_INT 4
50380: NEG
50381: PUSH
50382: EMPTY
50383: LIST
50384: LIST
50385: PUSH
50386: LD_INT 1
50388: NEG
50389: PUSH
50390: LD_INT 5
50392: NEG
50393: PUSH
50394: EMPTY
50395: LIST
50396: LIST
50397: PUSH
50398: LD_INT 2
50400: PUSH
50401: LD_INT 3
50403: NEG
50404: PUSH
50405: EMPTY
50406: LIST
50407: LIST
50408: PUSH
50409: LD_INT 2
50411: NEG
50412: PUSH
50413: LD_INT 5
50415: NEG
50416: PUSH
50417: EMPTY
50418: LIST
50419: LIST
50420: PUSH
50421: LD_INT 3
50423: PUSH
50424: LD_INT 0
50426: PUSH
50427: EMPTY
50428: LIST
50429: LIST
50430: PUSH
50431: LD_INT 3
50433: PUSH
50434: LD_INT 1
50436: NEG
50437: PUSH
50438: EMPTY
50439: LIST
50440: LIST
50441: PUSH
50442: LD_INT 4
50444: PUSH
50445: LD_INT 0
50447: PUSH
50448: EMPTY
50449: LIST
50450: LIST
50451: PUSH
50452: LD_INT 4
50454: PUSH
50455: LD_INT 1
50457: PUSH
50458: EMPTY
50459: LIST
50460: LIST
50461: PUSH
50462: LD_INT 3
50464: PUSH
50465: LD_INT 1
50467: PUSH
50468: EMPTY
50469: LIST
50470: LIST
50471: PUSH
50472: LD_INT 2
50474: PUSH
50475: LD_INT 0
50477: PUSH
50478: EMPTY
50479: LIST
50480: LIST
50481: PUSH
50482: LD_INT 2
50484: PUSH
50485: LD_INT 1
50487: NEG
50488: PUSH
50489: EMPTY
50490: LIST
50491: LIST
50492: PUSH
50493: LD_INT 2
50495: PUSH
50496: LD_INT 2
50498: NEG
50499: PUSH
50500: EMPTY
50501: LIST
50502: LIST
50503: PUSH
50504: LD_INT 4
50506: PUSH
50507: LD_INT 2
50509: PUSH
50510: EMPTY
50511: LIST
50512: LIST
50513: PUSH
50514: LD_INT 4
50516: PUSH
50517: LD_INT 4
50519: PUSH
50520: EMPTY
50521: LIST
50522: LIST
50523: PUSH
50524: LD_INT 4
50526: PUSH
50527: LD_INT 3
50529: PUSH
50530: EMPTY
50531: LIST
50532: LIST
50533: PUSH
50534: LD_INT 5
50536: PUSH
50537: LD_INT 4
50539: PUSH
50540: EMPTY
50541: LIST
50542: LIST
50543: PUSH
50544: LD_INT 5
50546: PUSH
50547: LD_INT 5
50549: PUSH
50550: EMPTY
50551: LIST
50552: LIST
50553: PUSH
50554: LD_INT 4
50556: PUSH
50557: LD_INT 5
50559: PUSH
50560: EMPTY
50561: LIST
50562: LIST
50563: PUSH
50564: LD_INT 3
50566: PUSH
50567: LD_INT 4
50569: PUSH
50570: EMPTY
50571: LIST
50572: LIST
50573: PUSH
50574: LD_INT 3
50576: PUSH
50577: LD_INT 3
50579: PUSH
50580: EMPTY
50581: LIST
50582: LIST
50583: PUSH
50584: LD_INT 5
50586: PUSH
50587: LD_INT 3
50589: PUSH
50590: EMPTY
50591: LIST
50592: LIST
50593: PUSH
50594: LD_INT 3
50596: PUSH
50597: LD_INT 5
50599: PUSH
50600: EMPTY
50601: LIST
50602: LIST
50603: PUSH
50604: LD_INT 0
50606: PUSH
50607: LD_INT 3
50609: PUSH
50610: EMPTY
50611: LIST
50612: LIST
50613: PUSH
50614: LD_INT 0
50616: PUSH
50617: LD_INT 2
50619: PUSH
50620: EMPTY
50621: LIST
50622: LIST
50623: PUSH
50624: LD_INT 1
50626: PUSH
50627: LD_INT 3
50629: PUSH
50630: EMPTY
50631: LIST
50632: LIST
50633: PUSH
50634: LD_INT 1
50636: PUSH
50637: LD_INT 4
50639: PUSH
50640: EMPTY
50641: LIST
50642: LIST
50643: PUSH
50644: LD_INT 0
50646: PUSH
50647: LD_INT 4
50649: PUSH
50650: EMPTY
50651: LIST
50652: LIST
50653: PUSH
50654: LD_INT 1
50656: NEG
50657: PUSH
50658: LD_INT 3
50660: PUSH
50661: EMPTY
50662: LIST
50663: LIST
50664: PUSH
50665: LD_INT 1
50667: NEG
50668: PUSH
50669: LD_INT 2
50671: PUSH
50672: EMPTY
50673: LIST
50674: LIST
50675: PUSH
50676: LD_INT 2
50678: PUSH
50679: LD_INT 4
50681: PUSH
50682: EMPTY
50683: LIST
50684: LIST
50685: PUSH
50686: LD_INT 2
50688: NEG
50689: PUSH
50690: LD_INT 2
50692: PUSH
50693: EMPTY
50694: LIST
50695: LIST
50696: PUSH
50697: LD_INT 4
50699: NEG
50700: PUSH
50701: LD_INT 0
50703: PUSH
50704: EMPTY
50705: LIST
50706: LIST
50707: PUSH
50708: LD_INT 4
50710: NEG
50711: PUSH
50712: LD_INT 1
50714: NEG
50715: PUSH
50716: EMPTY
50717: LIST
50718: LIST
50719: PUSH
50720: LD_INT 3
50722: NEG
50723: PUSH
50724: LD_INT 0
50726: PUSH
50727: EMPTY
50728: LIST
50729: LIST
50730: PUSH
50731: LD_INT 3
50733: NEG
50734: PUSH
50735: LD_INT 1
50737: PUSH
50738: EMPTY
50739: LIST
50740: LIST
50741: PUSH
50742: LD_INT 4
50744: NEG
50745: PUSH
50746: LD_INT 1
50748: PUSH
50749: EMPTY
50750: LIST
50751: LIST
50752: PUSH
50753: LD_INT 5
50755: NEG
50756: PUSH
50757: LD_INT 0
50759: PUSH
50760: EMPTY
50761: LIST
50762: LIST
50763: PUSH
50764: LD_INT 5
50766: NEG
50767: PUSH
50768: LD_INT 1
50770: NEG
50771: PUSH
50772: EMPTY
50773: LIST
50774: LIST
50775: PUSH
50776: LD_INT 5
50778: NEG
50779: PUSH
50780: LD_INT 2
50782: NEG
50783: PUSH
50784: EMPTY
50785: LIST
50786: LIST
50787: PUSH
50788: LD_INT 3
50790: NEG
50791: PUSH
50792: LD_INT 2
50794: PUSH
50795: EMPTY
50796: LIST
50797: LIST
50798: PUSH
50799: EMPTY
50800: LIST
50801: LIST
50802: LIST
50803: LIST
50804: LIST
50805: LIST
50806: LIST
50807: LIST
50808: LIST
50809: LIST
50810: LIST
50811: LIST
50812: LIST
50813: LIST
50814: LIST
50815: LIST
50816: LIST
50817: LIST
50818: LIST
50819: LIST
50820: LIST
50821: LIST
50822: LIST
50823: LIST
50824: LIST
50825: LIST
50826: LIST
50827: LIST
50828: LIST
50829: LIST
50830: LIST
50831: LIST
50832: LIST
50833: LIST
50834: LIST
50835: LIST
50836: LIST
50837: LIST
50838: LIST
50839: LIST
50840: LIST
50841: LIST
50842: LIST
50843: LIST
50844: LIST
50845: ST_TO_ADDR
// end ; end ;
50846: GO 50849
50848: POP
// case btype of b_depot , b_warehouse :
50849: LD_VAR 0 1
50853: PUSH
50854: LD_INT 0
50856: DOUBLE
50857: EQUAL
50858: IFTRUE 50868
50860: LD_INT 1
50862: DOUBLE
50863: EQUAL
50864: IFTRUE 50868
50866: GO 51069
50868: POP
// case nation of nation_american :
50869: LD_VAR 0 5
50873: PUSH
50874: LD_INT 1
50876: DOUBLE
50877: EQUAL
50878: IFTRUE 50882
50880: GO 50938
50882: POP
// temp_list = [ fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 ] [ dir + 1 ] ; nation_arabian :
50883: LD_ADDR_VAR 0 9
50887: PUSH
50888: LD_VAR 0 11
50892: PUSH
50893: LD_VAR 0 12
50897: PUSH
50898: LD_VAR 0 13
50902: PUSH
50903: LD_VAR 0 14
50907: PUSH
50908: LD_VAR 0 15
50912: PUSH
50913: LD_VAR 0 16
50917: PUSH
50918: EMPTY
50919: LIST
50920: LIST
50921: LIST
50922: LIST
50923: LIST
50924: LIST
50925: PUSH
50926: LD_VAR 0 4
50930: PUSH
50931: LD_INT 1
50933: PLUS
50934: ARRAY
50935: ST_TO_ADDR
50936: GO 51067
50938: LD_INT 2
50940: DOUBLE
50941: EQUAL
50942: IFTRUE 50946
50944: GO 51002
50946: POP
// temp_list = [ fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 ] [ dir + 1 ] ; nation_russian :
50947: LD_ADDR_VAR 0 9
50951: PUSH
50952: LD_VAR 0 17
50956: PUSH
50957: LD_VAR 0 18
50961: PUSH
50962: LD_VAR 0 19
50966: PUSH
50967: LD_VAR 0 20
50971: PUSH
50972: LD_VAR 0 21
50976: PUSH
50977: LD_VAR 0 22
50981: PUSH
50982: EMPTY
50983: LIST
50984: LIST
50985: LIST
50986: LIST
50987: LIST
50988: LIST
50989: PUSH
50990: LD_VAR 0 4
50994: PUSH
50995: LD_INT 1
50997: PLUS
50998: ARRAY
50999: ST_TO_ADDR
51000: GO 51067
51002: LD_INT 3
51004: DOUBLE
51005: EQUAL
51006: IFTRUE 51010
51008: GO 51066
51010: POP
// temp_list = [ fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
51011: LD_ADDR_VAR 0 9
51015: PUSH
51016: LD_VAR 0 23
51020: PUSH
51021: LD_VAR 0 24
51025: PUSH
51026: LD_VAR 0 25
51030: PUSH
51031: LD_VAR 0 26
51035: PUSH
51036: LD_VAR 0 27
51040: PUSH
51041: LD_VAR 0 28
51045: PUSH
51046: EMPTY
51047: LIST
51048: LIST
51049: LIST
51050: LIST
51051: LIST
51052: LIST
51053: PUSH
51054: LD_VAR 0 4
51058: PUSH
51059: LD_INT 1
51061: PLUS
51062: ARRAY
51063: ST_TO_ADDR
51064: GO 51067
51066: POP
51067: GO 51622
51069: LD_INT 2
51071: DOUBLE
51072: EQUAL
51073: IFTRUE 51083
51075: LD_INT 3
51077: DOUBLE
51078: EQUAL
51079: IFTRUE 51083
51081: GO 51139
51083: POP
// temp_list = [ fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
51084: LD_ADDR_VAR 0 9
51088: PUSH
51089: LD_VAR 0 29
51093: PUSH
51094: LD_VAR 0 30
51098: PUSH
51099: LD_VAR 0 31
51103: PUSH
51104: LD_VAR 0 32
51108: PUSH
51109: LD_VAR 0 33
51113: PUSH
51114: LD_VAR 0 34
51118: PUSH
51119: EMPTY
51120: LIST
51121: LIST
51122: LIST
51123: LIST
51124: LIST
51125: LIST
51126: PUSH
51127: LD_VAR 0 4
51131: PUSH
51132: LD_INT 1
51134: PLUS
51135: ARRAY
51136: ST_TO_ADDR
51137: GO 51622
51139: LD_INT 16
51141: DOUBLE
51142: EQUAL
51143: IFTRUE 51201
51145: LD_INT 17
51147: DOUBLE
51148: EQUAL
51149: IFTRUE 51201
51151: LD_INT 18
51153: DOUBLE
51154: EQUAL
51155: IFTRUE 51201
51157: LD_INT 19
51159: DOUBLE
51160: EQUAL
51161: IFTRUE 51201
51163: LD_INT 22
51165: DOUBLE
51166: EQUAL
51167: IFTRUE 51201
51169: LD_INT 20
51171: DOUBLE
51172: EQUAL
51173: IFTRUE 51201
51175: LD_INT 21
51177: DOUBLE
51178: EQUAL
51179: IFTRUE 51201
51181: LD_INT 23
51183: DOUBLE
51184: EQUAL
51185: IFTRUE 51201
51187: LD_INT 24
51189: DOUBLE
51190: EQUAL
51191: IFTRUE 51201
51193: LD_INT 25
51195: DOUBLE
51196: EQUAL
51197: IFTRUE 51201
51199: GO 51257
51201: POP
// temp_list = [ fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
51202: LD_ADDR_VAR 0 9
51206: PUSH
51207: LD_VAR 0 35
51211: PUSH
51212: LD_VAR 0 36
51216: PUSH
51217: LD_VAR 0 37
51221: PUSH
51222: LD_VAR 0 38
51226: PUSH
51227: LD_VAR 0 39
51231: PUSH
51232: LD_VAR 0 40
51236: PUSH
51237: EMPTY
51238: LIST
51239: LIST
51240: LIST
51241: LIST
51242: LIST
51243: LIST
51244: PUSH
51245: LD_VAR 0 4
51249: PUSH
51250: LD_INT 1
51252: PLUS
51253: ARRAY
51254: ST_TO_ADDR
51255: GO 51622
51257: LD_INT 6
51259: DOUBLE
51260: EQUAL
51261: IFTRUE 51313
51263: LD_INT 7
51265: DOUBLE
51266: EQUAL
51267: IFTRUE 51313
51269: LD_INT 8
51271: DOUBLE
51272: EQUAL
51273: IFTRUE 51313
51275: LD_INT 13
51277: DOUBLE
51278: EQUAL
51279: IFTRUE 51313
51281: LD_INT 12
51283: DOUBLE
51284: EQUAL
51285: IFTRUE 51313
51287: LD_INT 15
51289: DOUBLE
51290: EQUAL
51291: IFTRUE 51313
51293: LD_INT 11
51295: DOUBLE
51296: EQUAL
51297: IFTRUE 51313
51299: LD_INT 14
51301: DOUBLE
51302: EQUAL
51303: IFTRUE 51313
51305: LD_INT 10
51307: DOUBLE
51308: EQUAL
51309: IFTRUE 51313
51311: GO 51369
51313: POP
// temp_list = [ fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 ] [ dir + 1 ] ; b_control_tower :
51314: LD_ADDR_VAR 0 9
51318: PUSH
51319: LD_VAR 0 41
51323: PUSH
51324: LD_VAR 0 42
51328: PUSH
51329: LD_VAR 0 43
51333: PUSH
51334: LD_VAR 0 44
51338: PUSH
51339: LD_VAR 0 45
51343: PUSH
51344: LD_VAR 0 46
51348: PUSH
51349: EMPTY
51350: LIST
51351: LIST
51352: LIST
51353: LIST
51354: LIST
51355: LIST
51356: PUSH
51357: LD_VAR 0 4
51361: PUSH
51362: LD_INT 1
51364: PLUS
51365: ARRAY
51366: ST_TO_ADDR
51367: GO 51622
51369: LD_INT 36
51371: DOUBLE
51372: EQUAL
51373: IFTRUE 51377
51375: GO 51433
51377: POP
// temp_list = [ fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
51378: LD_ADDR_VAR 0 9
51382: PUSH
51383: LD_VAR 0 47
51387: PUSH
51388: LD_VAR 0 48
51392: PUSH
51393: LD_VAR 0 49
51397: PUSH
51398: LD_VAR 0 50
51402: PUSH
51403: LD_VAR 0 51
51407: PUSH
51408: LD_VAR 0 52
51412: PUSH
51413: EMPTY
51414: LIST
51415: LIST
51416: LIST
51417: LIST
51418: LIST
51419: LIST
51420: PUSH
51421: LD_VAR 0 4
51425: PUSH
51426: LD_INT 1
51428: PLUS
51429: ARRAY
51430: ST_TO_ADDR
51431: GO 51622
51433: LD_INT 4
51435: DOUBLE
51436: EQUAL
51437: IFTRUE 51459
51439: LD_INT 5
51441: DOUBLE
51442: EQUAL
51443: IFTRUE 51459
51445: LD_INT 34
51447: DOUBLE
51448: EQUAL
51449: IFTRUE 51459
51451: LD_INT 37
51453: DOUBLE
51454: EQUAL
51455: IFTRUE 51459
51457: GO 51515
51459: POP
// temp_list = [ fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
51460: LD_ADDR_VAR 0 9
51464: PUSH
51465: LD_VAR 0 53
51469: PUSH
51470: LD_VAR 0 54
51474: PUSH
51475: LD_VAR 0 55
51479: PUSH
51480: LD_VAR 0 56
51484: PUSH
51485: LD_VAR 0 57
51489: PUSH
51490: LD_VAR 0 58
51494: PUSH
51495: EMPTY
51496: LIST
51497: LIST
51498: LIST
51499: LIST
51500: LIST
51501: LIST
51502: PUSH
51503: LD_VAR 0 4
51507: PUSH
51508: LD_INT 1
51510: PLUS
51511: ARRAY
51512: ST_TO_ADDR
51513: GO 51622
51515: LD_INT 31
51517: DOUBLE
51518: EQUAL
51519: IFTRUE 51565
51521: LD_INT 32
51523: DOUBLE
51524: EQUAL
51525: IFTRUE 51565
51527: LD_INT 33
51529: DOUBLE
51530: EQUAL
51531: IFTRUE 51565
51533: LD_INT 27
51535: DOUBLE
51536: EQUAL
51537: IFTRUE 51565
51539: LD_INT 26
51541: DOUBLE
51542: EQUAL
51543: IFTRUE 51565
51545: LD_INT 28
51547: DOUBLE
51548: EQUAL
51549: IFTRUE 51565
51551: LD_INT 29
51553: DOUBLE
51554: EQUAL
51555: IFTRUE 51565
51557: LD_INT 30
51559: DOUBLE
51560: EQUAL
51561: IFTRUE 51565
51563: GO 51621
51565: POP
// temp_list = [ fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ] [ dir + 1 ] ; end ;
51566: LD_ADDR_VAR 0 9
51570: PUSH
51571: LD_VAR 0 59
51575: PUSH
51576: LD_VAR 0 60
51580: PUSH
51581: LD_VAR 0 61
51585: PUSH
51586: LD_VAR 0 62
51590: PUSH
51591: LD_VAR 0 63
51595: PUSH
51596: LD_VAR 0 64
51600: PUSH
51601: EMPTY
51602: LIST
51603: LIST
51604: LIST
51605: LIST
51606: LIST
51607: LIST
51608: PUSH
51609: LD_VAR 0 4
51613: PUSH
51614: LD_INT 1
51616: PLUS
51617: ARRAY
51618: ST_TO_ADDR
51619: GO 51622
51621: POP
// temp_list2 = [ ] ;
51622: LD_ADDR_VAR 0 10
51626: PUSH
51627: EMPTY
51628: ST_TO_ADDR
// for i in temp_list do
51629: LD_ADDR_VAR 0 8
51633: PUSH
51634: LD_VAR 0 9
51638: PUSH
51639: FOR_IN
51640: IFFALSE 51692
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
51642: LD_ADDR_VAR 0 10
51646: PUSH
51647: LD_VAR 0 10
51651: PUSH
51652: LD_VAR 0 8
51656: PUSH
51657: LD_INT 1
51659: ARRAY
51660: PUSH
51661: LD_VAR 0 2
51665: PLUS
51666: PUSH
51667: LD_VAR 0 8
51671: PUSH
51672: LD_INT 2
51674: ARRAY
51675: PUSH
51676: LD_VAR 0 3
51680: PLUS
51681: PUSH
51682: EMPTY
51683: LIST
51684: LIST
51685: PUSH
51686: EMPTY
51687: LIST
51688: ADD
51689: ST_TO_ADDR
51690: GO 51639
51692: POP
51693: POP
// result = temp_list2 ;
51694: LD_ADDR_VAR 0 7
51698: PUSH
51699: LD_VAR 0 10
51703: ST_TO_ADDR
// end ;
51704: LD_VAR 0 7
51708: RET
// export function EnemyInRange ( unit , dist ) ; begin
51709: LD_INT 0
51711: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
51712: LD_ADDR_VAR 0 3
51716: PUSH
51717: LD_VAR 0 1
51721: PPUSH
51722: CALL_OW 255
51726: PPUSH
51727: LD_VAR 0 1
51731: PPUSH
51732: CALL_OW 250
51736: PPUSH
51737: LD_VAR 0 1
51741: PPUSH
51742: CALL_OW 251
51746: PPUSH
51747: LD_VAR 0 2
51751: PPUSH
51752: CALL 25082 0 4
51756: PUSH
51757: LD_INT 4
51759: ARRAY
51760: ST_TO_ADDR
// end ;
51761: LD_VAR 0 3
51765: RET
// export function PlayerSeeMe ( unit ) ; begin
51766: LD_INT 0
51768: PPUSH
// result := See ( your_side , unit ) ;
51769: LD_ADDR_VAR 0 2
51773: PUSH
51774: LD_OWVAR 2
51778: PPUSH
51779: LD_VAR 0 1
51783: PPUSH
51784: CALL_OW 292
51788: ST_TO_ADDR
// end ;
51789: LD_VAR 0 2
51793: RET
// export function ReverseDir ( unit ) ; begin
51794: LD_INT 0
51796: PPUSH
// if not unit then
51797: LD_VAR 0 1
51801: NOT
51802: IFFALSE 51806
// exit ;
51804: GO 51829
// result := ( GetDir ( unit ) + 3 ) mod 6 ;
51806: LD_ADDR_VAR 0 2
51810: PUSH
51811: LD_VAR 0 1
51815: PPUSH
51816: CALL_OW 254
51820: PUSH
51821: LD_INT 3
51823: PLUS
51824: PUSH
51825: LD_INT 6
51827: MOD
51828: ST_TO_ADDR
// end ;
51829: LD_VAR 0 2
51833: RET
// export function ReverseArray ( array ) ; var i ; begin
51834: LD_INT 0
51836: PPUSH
51837: PPUSH
// if not array then
51838: LD_VAR 0 1
51842: NOT
51843: IFFALSE 51847
// exit ;
51845: GO 51902
// result := [ ] ;
51847: LD_ADDR_VAR 0 2
51851: PUSH
51852: EMPTY
51853: ST_TO_ADDR
// for i := array downto 1 do
51854: LD_ADDR_VAR 0 3
51858: PUSH
51859: DOUBLE
51860: LD_VAR 0 1
51864: INC
51865: ST_TO_ADDR
51866: LD_INT 1
51868: PUSH
51869: FOR_DOWNTO
51870: IFFALSE 51900
// result := Join ( result , array [ i ] ) ;
51872: LD_ADDR_VAR 0 2
51876: PUSH
51877: LD_VAR 0 2
51881: PPUSH
51882: LD_VAR 0 1
51886: PUSH
51887: LD_VAR 0 3
51891: ARRAY
51892: PPUSH
51893: CALL 56545 0 2
51897: ST_TO_ADDR
51898: GO 51869
51900: POP
51901: POP
// end ;
51902: LD_VAR 0 2
51906: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tdist , tmp , hex ; begin
51907: LD_INT 0
51909: PPUSH
51910: PPUSH
51911: PPUSH
51912: PPUSH
51913: PPUSH
51914: PPUSH
// if not unit or not hexes then
51915: LD_VAR 0 1
51919: NOT
51920: PUSH
51921: LD_VAR 0 2
51925: NOT
51926: OR
51927: IFFALSE 51931
// exit ;
51929: GO 52054
// dist := 9999 ;
51931: LD_ADDR_VAR 0 5
51935: PUSH
51936: LD_INT 9999
51938: ST_TO_ADDR
// for i = 1 to hexes do
51939: LD_ADDR_VAR 0 4
51943: PUSH
51944: DOUBLE
51945: LD_INT 1
51947: DEC
51948: ST_TO_ADDR
51949: LD_VAR 0 2
51953: PUSH
51954: FOR_TO
51955: IFFALSE 52042
// begin tdist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
51957: LD_ADDR_VAR 0 6
51961: PUSH
51962: LD_VAR 0 1
51966: PPUSH
51967: LD_VAR 0 2
51971: PUSH
51972: LD_VAR 0 4
51976: ARRAY
51977: PUSH
51978: LD_INT 1
51980: ARRAY
51981: PPUSH
51982: LD_VAR 0 2
51986: PUSH
51987: LD_VAR 0 4
51991: ARRAY
51992: PUSH
51993: LD_INT 2
51995: ARRAY
51996: PPUSH
51997: CALL_OW 297
52001: ST_TO_ADDR
// if tdist < dist then
52002: LD_VAR 0 6
52006: PUSH
52007: LD_VAR 0 5
52011: LESS
52012: IFFALSE 52040
// begin hex := hexes [ i ] ;
52014: LD_ADDR_VAR 0 8
52018: PUSH
52019: LD_VAR 0 2
52023: PUSH
52024: LD_VAR 0 4
52028: ARRAY
52029: ST_TO_ADDR
// dist := tdist ;
52030: LD_ADDR_VAR 0 5
52034: PUSH
52035: LD_VAR 0 6
52039: ST_TO_ADDR
// end ; end ;
52040: GO 51954
52042: POP
52043: POP
// result := hex ;
52044: LD_ADDR_VAR 0 3
52048: PUSH
52049: LD_VAR 0 8
52053: ST_TO_ADDR
// end ;
52054: LD_VAR 0 3
52058: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
52059: LD_INT 0
52061: PPUSH
52062: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
52063: LD_VAR 0 1
52067: NOT
52068: PUSH
52069: LD_VAR 0 1
52073: PUSH
52074: LD_INT 21
52076: PUSH
52077: LD_INT 2
52079: PUSH
52080: EMPTY
52081: LIST
52082: LIST
52083: PUSH
52084: LD_INT 23
52086: PUSH
52087: LD_INT 2
52089: PUSH
52090: EMPTY
52091: LIST
52092: LIST
52093: PUSH
52094: EMPTY
52095: LIST
52096: LIST
52097: PPUSH
52098: CALL_OW 69
52102: IN
52103: NOT
52104: OR
52105: IFFALSE 52109
// exit ;
52107: GO 52156
// for i = 1 to 3 do
52109: LD_ADDR_VAR 0 3
52113: PUSH
52114: DOUBLE
52115: LD_INT 1
52117: DEC
52118: ST_TO_ADDR
52119: LD_INT 3
52121: PUSH
52122: FOR_TO
52123: IFFALSE 52154
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
52125: LD_VAR 0 1
52129: PPUSH
52130: CALL_OW 250
52134: PPUSH
52135: LD_VAR 0 1
52139: PPUSH
52140: CALL_OW 251
52144: PPUSH
52145: LD_INT 1
52147: PPUSH
52148: CALL_OW 453
52152: GO 52122
52154: POP
52155: POP
// end ;
52156: LD_VAR 0 2
52160: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
52161: LD_INT 0
52163: PPUSH
52164: PPUSH
52165: PPUSH
52166: PPUSH
52167: PPUSH
52168: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
52169: LD_VAR 0 1
52173: NOT
52174: PUSH
52175: LD_VAR 0 2
52179: NOT
52180: OR
52181: PUSH
52182: LD_VAR 0 1
52186: PPUSH
52187: CALL_OW 314
52191: OR
52192: IFFALSE 52196
// exit ;
52194: GO 52663
// if GetLives ( i ) < 250 then
52196: LD_VAR 0 4
52200: PPUSH
52201: CALL_OW 256
52205: PUSH
52206: LD_INT 250
52208: LESS
52209: IFFALSE 52222
// begin ComAutodestruct ( i ) ;
52211: LD_VAR 0 4
52215: PPUSH
52216: CALL 52059 0 1
// exit ;
52220: GO 52663
// end ; x := GetX ( enemy_unit ) ;
52222: LD_ADDR_VAR 0 7
52226: PUSH
52227: LD_VAR 0 2
52231: PPUSH
52232: CALL_OW 250
52236: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
52237: LD_ADDR_VAR 0 8
52241: PUSH
52242: LD_VAR 0 2
52246: PPUSH
52247: CALL_OW 251
52251: ST_TO_ADDR
// if not x or not y then
52252: LD_VAR 0 7
52256: NOT
52257: PUSH
52258: LD_VAR 0 8
52262: NOT
52263: OR
52264: IFFALSE 52268
// exit ;
52266: GO 52663
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
52268: LD_ADDR_VAR 0 6
52272: PUSH
52273: LD_VAR 0 7
52277: PPUSH
52278: LD_INT 0
52280: PPUSH
52281: LD_INT 4
52283: PPUSH
52284: CALL_OW 272
52288: PUSH
52289: LD_VAR 0 8
52293: PPUSH
52294: LD_INT 0
52296: PPUSH
52297: LD_INT 4
52299: PPUSH
52300: CALL_OW 273
52304: PUSH
52305: EMPTY
52306: LIST
52307: LIST
52308: PUSH
52309: LD_VAR 0 7
52313: PPUSH
52314: LD_INT 1
52316: PPUSH
52317: LD_INT 4
52319: PPUSH
52320: CALL_OW 272
52324: PUSH
52325: LD_VAR 0 8
52329: PPUSH
52330: LD_INT 1
52332: PPUSH
52333: LD_INT 4
52335: PPUSH
52336: CALL_OW 273
52340: PUSH
52341: EMPTY
52342: LIST
52343: LIST
52344: PUSH
52345: LD_VAR 0 7
52349: PPUSH
52350: LD_INT 2
52352: PPUSH
52353: LD_INT 4
52355: PPUSH
52356: CALL_OW 272
52360: PUSH
52361: LD_VAR 0 8
52365: PPUSH
52366: LD_INT 2
52368: PPUSH
52369: LD_INT 4
52371: PPUSH
52372: CALL_OW 273
52376: PUSH
52377: EMPTY
52378: LIST
52379: LIST
52380: PUSH
52381: LD_VAR 0 7
52385: PPUSH
52386: LD_INT 3
52388: PPUSH
52389: LD_INT 4
52391: PPUSH
52392: CALL_OW 272
52396: PUSH
52397: LD_VAR 0 8
52401: PPUSH
52402: LD_INT 3
52404: PPUSH
52405: LD_INT 4
52407: PPUSH
52408: CALL_OW 273
52412: PUSH
52413: EMPTY
52414: LIST
52415: LIST
52416: PUSH
52417: LD_VAR 0 7
52421: PPUSH
52422: LD_INT 4
52424: PPUSH
52425: LD_INT 4
52427: PPUSH
52428: CALL_OW 272
52432: PUSH
52433: LD_VAR 0 8
52437: PPUSH
52438: LD_INT 4
52440: PPUSH
52441: LD_INT 4
52443: PPUSH
52444: CALL_OW 273
52448: PUSH
52449: EMPTY
52450: LIST
52451: LIST
52452: PUSH
52453: LD_VAR 0 7
52457: PPUSH
52458: LD_INT 5
52460: PPUSH
52461: LD_INT 4
52463: PPUSH
52464: CALL_OW 272
52468: PUSH
52469: LD_VAR 0 8
52473: PPUSH
52474: LD_INT 5
52476: PPUSH
52477: LD_INT 4
52479: PPUSH
52480: CALL_OW 273
52484: PUSH
52485: EMPTY
52486: LIST
52487: LIST
52488: PUSH
52489: EMPTY
52490: LIST
52491: LIST
52492: LIST
52493: LIST
52494: LIST
52495: LIST
52496: ST_TO_ADDR
// for i = tmp downto 1 do
52497: LD_ADDR_VAR 0 4
52501: PUSH
52502: DOUBLE
52503: LD_VAR 0 6
52507: INC
52508: ST_TO_ADDR
52509: LD_INT 1
52511: PUSH
52512: FOR_DOWNTO
52513: IFFALSE 52614
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
52515: LD_VAR 0 6
52519: PUSH
52520: LD_VAR 0 4
52524: ARRAY
52525: PUSH
52526: LD_INT 1
52528: ARRAY
52529: PPUSH
52530: LD_VAR 0 6
52534: PUSH
52535: LD_VAR 0 4
52539: ARRAY
52540: PUSH
52541: LD_INT 2
52543: ARRAY
52544: PPUSH
52545: CALL_OW 488
52549: NOT
52550: PUSH
52551: LD_VAR 0 6
52555: PUSH
52556: LD_VAR 0 4
52560: ARRAY
52561: PUSH
52562: LD_INT 1
52564: ARRAY
52565: PPUSH
52566: LD_VAR 0 6
52570: PUSH
52571: LD_VAR 0 4
52575: ARRAY
52576: PUSH
52577: LD_INT 2
52579: ARRAY
52580: PPUSH
52581: CALL_OW 428
52585: PUSH
52586: LD_INT 0
52588: NONEQUAL
52589: OR
52590: IFFALSE 52612
// tmp := Delete ( tmp , i ) ;
52592: LD_ADDR_VAR 0 6
52596: PUSH
52597: LD_VAR 0 6
52601: PPUSH
52602: LD_VAR 0 4
52606: PPUSH
52607: CALL_OW 3
52611: ST_TO_ADDR
52612: GO 52512
52614: POP
52615: POP
// j := GetClosestHex ( unit , tmp ) ;
52616: LD_ADDR_VAR 0 5
52620: PUSH
52621: LD_VAR 0 1
52625: PPUSH
52626: LD_VAR 0 6
52630: PPUSH
52631: CALL 51907 0 2
52635: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
52636: LD_VAR 0 1
52640: PPUSH
52641: LD_VAR 0 5
52645: PUSH
52646: LD_INT 1
52648: ARRAY
52649: PPUSH
52650: LD_VAR 0 5
52654: PUSH
52655: LD_INT 2
52657: ARRAY
52658: PPUSH
52659: CALL_OW 111
// end ;
52663: LD_VAR 0 3
52667: RET
// export function PrepareApemanSoldier ( ) ; begin
52668: LD_INT 0
52670: PPUSH
// uc_nation := 0 ;
52671: LD_ADDR_OWVAR 21
52675: PUSH
52676: LD_INT 0
52678: ST_TO_ADDR
// hc_sex := sex_male ;
52679: LD_ADDR_OWVAR 27
52683: PUSH
52684: LD_INT 1
52686: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
52687: LD_ADDR_OWVAR 28
52691: PUSH
52692: LD_INT 15
52694: ST_TO_ADDR
// hc_gallery :=  ;
52695: LD_ADDR_OWVAR 33
52699: PUSH
52700: LD_STRING 
52702: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
52703: LD_ADDR_OWVAR 31
52707: PUSH
52708: LD_INT 0
52710: PPUSH
52711: LD_INT 3
52713: PPUSH
52714: CALL_OW 12
52718: PUSH
52719: LD_INT 0
52721: PPUSH
52722: LD_INT 3
52724: PPUSH
52725: CALL_OW 12
52729: PUSH
52730: LD_INT 0
52732: PUSH
52733: LD_INT 0
52735: PUSH
52736: EMPTY
52737: LIST
52738: LIST
52739: LIST
52740: LIST
52741: ST_TO_ADDR
// end ;
52742: LD_VAR 0 1
52746: RET
// export function PrepareApemanEngineer ( ) ; begin
52747: LD_INT 0
52749: PPUSH
// uc_nation := 0 ;
52750: LD_ADDR_OWVAR 21
52754: PUSH
52755: LD_INT 0
52757: ST_TO_ADDR
// hc_sex := sex_male ;
52758: LD_ADDR_OWVAR 27
52762: PUSH
52763: LD_INT 1
52765: ST_TO_ADDR
// hc_class := class_apeman_engineer ;
52766: LD_ADDR_OWVAR 28
52770: PUSH
52771: LD_INT 16
52773: ST_TO_ADDR
// hc_gallery :=  ;
52774: LD_ADDR_OWVAR 33
52778: PUSH
52779: LD_STRING 
52781: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
52782: LD_ADDR_OWVAR 31
52786: PUSH
52787: LD_INT 0
52789: PPUSH
52790: LD_INT 3
52792: PPUSH
52793: CALL_OW 12
52797: PUSH
52798: LD_INT 0
52800: PPUSH
52801: LD_INT 3
52803: PPUSH
52804: CALL_OW 12
52808: PUSH
52809: LD_INT 0
52811: PUSH
52812: LD_INT 0
52814: PUSH
52815: EMPTY
52816: LIST
52817: LIST
52818: LIST
52819: LIST
52820: ST_TO_ADDR
// end ;
52821: LD_VAR 0 1
52825: RET
// export function PrepareApeman ( agressivity ) ; begin
52826: LD_INT 0
52828: PPUSH
// uc_side := 0 ;
52829: LD_ADDR_OWVAR 20
52833: PUSH
52834: LD_INT 0
52836: ST_TO_ADDR
// uc_nation := 0 ;
52837: LD_ADDR_OWVAR 21
52841: PUSH
52842: LD_INT 0
52844: ST_TO_ADDR
// hc_sex := sex_male ;
52845: LD_ADDR_OWVAR 27
52849: PUSH
52850: LD_INT 1
52852: ST_TO_ADDR
// hc_class := class_apeman ;
52853: LD_ADDR_OWVAR 28
52857: PUSH
52858: LD_INT 12
52860: ST_TO_ADDR
// hc_gallery :=  ;
52861: LD_ADDR_OWVAR 33
52865: PUSH
52866: LD_STRING 
52868: ST_TO_ADDR
// hc_agressivity := rand ( - agressivity , agressivity ) ;
52869: LD_ADDR_OWVAR 35
52873: PUSH
52874: LD_VAR 0 1
52878: NEG
52879: PPUSH
52880: LD_VAR 0 1
52884: PPUSH
52885: CALL_OW 12
52889: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
52890: LD_ADDR_OWVAR 31
52894: PUSH
52895: LD_INT 0
52897: PPUSH
52898: LD_INT 3
52900: PPUSH
52901: CALL_OW 12
52905: PUSH
52906: LD_INT 0
52908: PPUSH
52909: LD_INT 3
52911: PPUSH
52912: CALL_OW 12
52916: PUSH
52917: LD_INT 0
52919: PUSH
52920: LD_INT 0
52922: PUSH
52923: EMPTY
52924: LIST
52925: LIST
52926: LIST
52927: LIST
52928: ST_TO_ADDR
// end ;
52929: LD_VAR 0 2
52933: RET
// export function PrepareTiger ( agressivity ) ; begin
52934: LD_INT 0
52936: PPUSH
// uc_side := 0 ;
52937: LD_ADDR_OWVAR 20
52941: PUSH
52942: LD_INT 0
52944: ST_TO_ADDR
// uc_nation := 0 ;
52945: LD_ADDR_OWVAR 21
52949: PUSH
52950: LD_INT 0
52952: ST_TO_ADDR
// hc_class := class_tiger ;
52953: LD_ADDR_OWVAR 28
52957: PUSH
52958: LD_INT 14
52960: ST_TO_ADDR
// hc_gallery :=  ;
52961: LD_ADDR_OWVAR 33
52965: PUSH
52966: LD_STRING 
52968: ST_TO_ADDR
// hc_agressivity := rand ( - agressivity , agressivity ) ;
52969: LD_ADDR_OWVAR 35
52973: PUSH
52974: LD_VAR 0 1
52978: NEG
52979: PPUSH
52980: LD_VAR 0 1
52984: PPUSH
52985: CALL_OW 12
52989: ST_TO_ADDR
// end ;
52990: LD_VAR 0 2
52994: RET
// export function PrepareEnchidna ( ) ; begin
52995: LD_INT 0
52997: PPUSH
// uc_side := 0 ;
52998: LD_ADDR_OWVAR 20
53002: PUSH
53003: LD_INT 0
53005: ST_TO_ADDR
// uc_nation := 0 ;
53006: LD_ADDR_OWVAR 21
53010: PUSH
53011: LD_INT 0
53013: ST_TO_ADDR
// hc_class := class_baggie ;
53014: LD_ADDR_OWVAR 28
53018: PUSH
53019: LD_INT 13
53021: ST_TO_ADDR
// hc_gallery :=  ;
53022: LD_ADDR_OWVAR 33
53026: PUSH
53027: LD_STRING 
53029: ST_TO_ADDR
// end ;
53030: LD_VAR 0 1
53034: RET
// export function PrepareFrog ( ) ; begin
53035: LD_INT 0
53037: PPUSH
// uc_side := 0 ;
53038: LD_ADDR_OWVAR 20
53042: PUSH
53043: LD_INT 0
53045: ST_TO_ADDR
// uc_nation := 0 ;
53046: LD_ADDR_OWVAR 21
53050: PUSH
53051: LD_INT 0
53053: ST_TO_ADDR
// hc_class := class_frog ;
53054: LD_ADDR_OWVAR 28
53058: PUSH
53059: LD_INT 19
53061: ST_TO_ADDR
// hc_gallery :=  ;
53062: LD_ADDR_OWVAR 33
53066: PUSH
53067: LD_STRING 
53069: ST_TO_ADDR
// end ;
53070: LD_VAR 0 1
53074: RET
// export function PrepareFish ( ) ; begin
53075: LD_INT 0
53077: PPUSH
// uc_side := 0 ;
53078: LD_ADDR_OWVAR 20
53082: PUSH
53083: LD_INT 0
53085: ST_TO_ADDR
// uc_nation := 0 ;
53086: LD_ADDR_OWVAR 21
53090: PUSH
53091: LD_INT 0
53093: ST_TO_ADDR
// hc_class := class_fish ;
53094: LD_ADDR_OWVAR 28
53098: PUSH
53099: LD_INT 20
53101: ST_TO_ADDR
// hc_gallery :=  ;
53102: LD_ADDR_OWVAR 33
53106: PUSH
53107: LD_STRING 
53109: ST_TO_ADDR
// end ;
53110: LD_VAR 0 1
53114: RET
// export function PrepareBird ( ) ; begin
53115: LD_INT 0
53117: PPUSH
// uc_side := 0 ;
53118: LD_ADDR_OWVAR 20
53122: PUSH
53123: LD_INT 0
53125: ST_TO_ADDR
// uc_nation := 0 ;
53126: LD_ADDR_OWVAR 21
53130: PUSH
53131: LD_INT 0
53133: ST_TO_ADDR
// hc_class := class_phororhacos ;
53134: LD_ADDR_OWVAR 28
53138: PUSH
53139: LD_INT 18
53141: ST_TO_ADDR
// hc_gallery :=  ;
53142: LD_ADDR_OWVAR 33
53146: PUSH
53147: LD_STRING 
53149: ST_TO_ADDR
// end ;
53150: LD_VAR 0 1
53154: RET
// export function PrepareHorse ( ) ; begin
53155: LD_INT 0
53157: PPUSH
// uc_side := 0 ;
53158: LD_ADDR_OWVAR 20
53162: PUSH
53163: LD_INT 0
53165: ST_TO_ADDR
// uc_nation := 0 ;
53166: LD_ADDR_OWVAR 21
53170: PUSH
53171: LD_INT 0
53173: ST_TO_ADDR
// hc_class := class_horse ;
53174: LD_ADDR_OWVAR 28
53178: PUSH
53179: LD_INT 21
53181: ST_TO_ADDR
// hc_gallery :=  ;
53182: LD_ADDR_OWVAR 33
53186: PUSH
53187: LD_STRING 
53189: ST_TO_ADDR
// end ;
53190: LD_VAR 0 1
53194: RET
// export function PrepareMastodont ( ) ; begin
53195: LD_INT 0
53197: PPUSH
// uc_side := 0 ;
53198: LD_ADDR_OWVAR 20
53202: PUSH
53203: LD_INT 0
53205: ST_TO_ADDR
// uc_nation := 0 ;
53206: LD_ADDR_OWVAR 21
53210: PUSH
53211: LD_INT 0
53213: ST_TO_ADDR
// vc_chassis := class_mastodont ;
53214: LD_ADDR_OWVAR 37
53218: PUSH
53219: LD_INT 31
53221: ST_TO_ADDR
// vc_control := control_rider ;
53222: LD_ADDR_OWVAR 38
53226: PUSH
53227: LD_INT 4
53229: ST_TO_ADDR
// end ;
53230: LD_VAR 0 1
53234: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
53235: LD_INT 0
53237: PPUSH
53238: PPUSH
53239: PPUSH
// uc_side = 0 ;
53240: LD_ADDR_OWVAR 20
53244: PUSH
53245: LD_INT 0
53247: ST_TO_ADDR
// uc_nation = 0 ;
53248: LD_ADDR_OWVAR 21
53252: PUSH
53253: LD_INT 0
53255: ST_TO_ADDR
// InitHc_All ( ) ;
53256: CALL_OW 584
// InitVc ;
53260: CALL_OW 20
// if mastodonts then
53264: LD_VAR 0 6
53268: IFFALSE 53335
// for i = 1 to mastodonts do
53270: LD_ADDR_VAR 0 11
53274: PUSH
53275: DOUBLE
53276: LD_INT 1
53278: DEC
53279: ST_TO_ADDR
53280: LD_VAR 0 6
53284: PUSH
53285: FOR_TO
53286: IFFALSE 53333
// begin vc_chassis := 31 ;
53288: LD_ADDR_OWVAR 37
53292: PUSH
53293: LD_INT 31
53295: ST_TO_ADDR
// vc_control := control_rider ;
53296: LD_ADDR_OWVAR 38
53300: PUSH
53301: LD_INT 4
53303: ST_TO_ADDR
// animal := CreateVehicle ;
53304: LD_ADDR_VAR 0 12
53308: PUSH
53309: CALL_OW 45
53313: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
53314: LD_VAR 0 12
53318: PPUSH
53319: LD_VAR 0 8
53323: PPUSH
53324: LD_INT 0
53326: PPUSH
53327: CALL 55463 0 3
// end ;
53331: GO 53285
53333: POP
53334: POP
// if horses then
53335: LD_VAR 0 5
53339: IFFALSE 53406
// for i = 1 to horses do
53341: LD_ADDR_VAR 0 11
53345: PUSH
53346: DOUBLE
53347: LD_INT 1
53349: DEC
53350: ST_TO_ADDR
53351: LD_VAR 0 5
53355: PUSH
53356: FOR_TO
53357: IFFALSE 53404
// begin hc_class := 21 ;
53359: LD_ADDR_OWVAR 28
53363: PUSH
53364: LD_INT 21
53366: ST_TO_ADDR
// hc_gallery :=  ;
53367: LD_ADDR_OWVAR 33
53371: PUSH
53372: LD_STRING 
53374: ST_TO_ADDR
// animal := CreateHuman ;
53375: LD_ADDR_VAR 0 12
53379: PUSH
53380: CALL_OW 44
53384: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
53385: LD_VAR 0 12
53389: PPUSH
53390: LD_VAR 0 8
53394: PPUSH
53395: LD_INT 0
53397: PPUSH
53398: CALL 55463 0 3
// end ;
53402: GO 53356
53404: POP
53405: POP
// if birds then
53406: LD_VAR 0 1
53410: IFFALSE 53477
// for i = 1 to birds do
53412: LD_ADDR_VAR 0 11
53416: PUSH
53417: DOUBLE
53418: LD_INT 1
53420: DEC
53421: ST_TO_ADDR
53422: LD_VAR 0 1
53426: PUSH
53427: FOR_TO
53428: IFFALSE 53475
// begin hc_class := 18 ;
53430: LD_ADDR_OWVAR 28
53434: PUSH
53435: LD_INT 18
53437: ST_TO_ADDR
// hc_gallery =  ;
53438: LD_ADDR_OWVAR 33
53442: PUSH
53443: LD_STRING 
53445: ST_TO_ADDR
// animal := CreateHuman ;
53446: LD_ADDR_VAR 0 12
53450: PUSH
53451: CALL_OW 44
53455: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
53456: LD_VAR 0 12
53460: PPUSH
53461: LD_VAR 0 8
53465: PPUSH
53466: LD_INT 0
53468: PPUSH
53469: CALL 55463 0 3
// end ;
53473: GO 53427
53475: POP
53476: POP
// if tigers then
53477: LD_VAR 0 2
53481: IFFALSE 53565
// for i = 1 to tigers do
53483: LD_ADDR_VAR 0 11
53487: PUSH
53488: DOUBLE
53489: LD_INT 1
53491: DEC
53492: ST_TO_ADDR
53493: LD_VAR 0 2
53497: PUSH
53498: FOR_TO
53499: IFFALSE 53563
// begin hc_class = class_tiger ;
53501: LD_ADDR_OWVAR 28
53505: PUSH
53506: LD_INT 14
53508: ST_TO_ADDR
// hc_gallery =  ;
53509: LD_ADDR_OWVAR 33
53513: PUSH
53514: LD_STRING 
53516: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
53517: LD_ADDR_OWVAR 35
53521: PUSH
53522: LD_INT 7
53524: NEG
53525: PPUSH
53526: LD_INT 7
53528: PPUSH
53529: CALL_OW 12
53533: ST_TO_ADDR
// animal := CreateHuman ;
53534: LD_ADDR_VAR 0 12
53538: PUSH
53539: CALL_OW 44
53543: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
53544: LD_VAR 0 12
53548: PPUSH
53549: LD_VAR 0 8
53553: PPUSH
53554: LD_INT 0
53556: PPUSH
53557: CALL 55463 0 3
// end ;
53561: GO 53498
53563: POP
53564: POP
// if apemans then
53565: LD_VAR 0 3
53569: IFFALSE 53692
// for i = 1 to apemans do
53571: LD_ADDR_VAR 0 11
53575: PUSH
53576: DOUBLE
53577: LD_INT 1
53579: DEC
53580: ST_TO_ADDR
53581: LD_VAR 0 3
53585: PUSH
53586: FOR_TO
53587: IFFALSE 53690
// begin hc_class = class_apeman ;
53589: LD_ADDR_OWVAR 28
53593: PUSH
53594: LD_INT 12
53596: ST_TO_ADDR
// hc_gallery =  ;
53597: LD_ADDR_OWVAR 33
53601: PUSH
53602: LD_STRING 
53604: ST_TO_ADDR
// hc_agressivity = rand ( - 2 , 2 ) ;
53605: LD_ADDR_OWVAR 35
53609: PUSH
53610: LD_INT 2
53612: NEG
53613: PPUSH
53614: LD_INT 2
53616: PPUSH
53617: CALL_OW 12
53621: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
53622: LD_ADDR_OWVAR 31
53626: PUSH
53627: LD_INT 1
53629: PPUSH
53630: LD_INT 3
53632: PPUSH
53633: CALL_OW 12
53637: PUSH
53638: LD_INT 1
53640: PPUSH
53641: LD_INT 3
53643: PPUSH
53644: CALL_OW 12
53648: PUSH
53649: LD_INT 0
53651: PUSH
53652: LD_INT 0
53654: PUSH
53655: EMPTY
53656: LIST
53657: LIST
53658: LIST
53659: LIST
53660: ST_TO_ADDR
// animal := CreateHuman ;
53661: LD_ADDR_VAR 0 12
53665: PUSH
53666: CALL_OW 44
53670: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
53671: LD_VAR 0 12
53675: PPUSH
53676: LD_VAR 0 8
53680: PPUSH
53681: LD_INT 0
53683: PPUSH
53684: CALL 55463 0 3
// end ;
53688: GO 53586
53690: POP
53691: POP
// if enchidnas then
53692: LD_VAR 0 4
53696: IFFALSE 53763
// for i = 1 to enchidnas do
53698: LD_ADDR_VAR 0 11
53702: PUSH
53703: DOUBLE
53704: LD_INT 1
53706: DEC
53707: ST_TO_ADDR
53708: LD_VAR 0 4
53712: PUSH
53713: FOR_TO
53714: IFFALSE 53761
// begin hc_class = 13 ;
53716: LD_ADDR_OWVAR 28
53720: PUSH
53721: LD_INT 13
53723: ST_TO_ADDR
// hc_gallery =  ;
53724: LD_ADDR_OWVAR 33
53728: PUSH
53729: LD_STRING 
53731: ST_TO_ADDR
// animal := CreateHuman ;
53732: LD_ADDR_VAR 0 12
53736: PUSH
53737: CALL_OW 44
53741: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
53742: LD_VAR 0 12
53746: PPUSH
53747: LD_VAR 0 8
53751: PPUSH
53752: LD_INT 0
53754: PPUSH
53755: CALL 55463 0 3
// end ;
53759: GO 53713
53761: POP
53762: POP
// if fishes then
53763: LD_VAR 0 7
53767: IFFALSE 53834
// for i = 1 to fishes do
53769: LD_ADDR_VAR 0 11
53773: PUSH
53774: DOUBLE
53775: LD_INT 1
53777: DEC
53778: ST_TO_ADDR
53779: LD_VAR 0 7
53783: PUSH
53784: FOR_TO
53785: IFFALSE 53832
// begin hc_class = 20 ;
53787: LD_ADDR_OWVAR 28
53791: PUSH
53792: LD_INT 20
53794: ST_TO_ADDR
// hc_gallery =  ;
53795: LD_ADDR_OWVAR 33
53799: PUSH
53800: LD_STRING 
53802: ST_TO_ADDR
// animal := CreateHuman ;
53803: LD_ADDR_VAR 0 12
53807: PUSH
53808: CALL_OW 44
53812: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
53813: LD_VAR 0 12
53817: PPUSH
53818: LD_VAR 0 9
53822: PPUSH
53823: LD_INT 0
53825: PPUSH
53826: CALL 55463 0 3
// end ;
53830: GO 53784
53832: POP
53833: POP
// end ;
53834: LD_VAR 0 10
53838: RET
// export function WantHeal ( sci , unit ) ; begin
53839: LD_INT 0
53841: PPUSH
// if GetTaskList ( sci ) > 0 then
53842: LD_VAR 0 1
53846: PPUSH
53847: CALL_OW 437
53851: PUSH
53852: LD_INT 0
53854: GREATER
53855: IFFALSE 53925
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
53857: LD_VAR 0 1
53861: PPUSH
53862: CALL_OW 437
53866: PUSH
53867: LD_INT 1
53869: ARRAY
53870: PUSH
53871: LD_INT 1
53873: ARRAY
53874: PUSH
53875: LD_STRING l
53877: EQUAL
53878: PUSH
53879: LD_VAR 0 1
53883: PPUSH
53884: CALL_OW 437
53888: PUSH
53889: LD_INT 1
53891: ARRAY
53892: PUSH
53893: LD_INT 4
53895: ARRAY
53896: PUSH
53897: LD_VAR 0 2
53901: EQUAL
53902: AND
53903: IFFALSE 53915
// result := true else
53905: LD_ADDR_VAR 0 3
53909: PUSH
53910: LD_INT 1
53912: ST_TO_ADDR
53913: GO 53923
// result := false ;
53915: LD_ADDR_VAR 0 3
53919: PUSH
53920: LD_INT 0
53922: ST_TO_ADDR
// end else
53923: GO 53933
// result := false ;
53925: LD_ADDR_VAR 0 3
53929: PUSH
53930: LD_INT 0
53932: ST_TO_ADDR
// end ;
53933: LD_VAR 0 3
53937: RET
// export function HealTarget ( sci ) ; begin
53938: LD_INT 0
53940: PPUSH
// if not sci then
53941: LD_VAR 0 1
53945: NOT
53946: IFFALSE 53950
// exit ;
53948: GO 54015
// result := 0 ;
53950: LD_ADDR_VAR 0 2
53954: PUSH
53955: LD_INT 0
53957: ST_TO_ADDR
// if GetTaskList ( sci ) then
53958: LD_VAR 0 1
53962: PPUSH
53963: CALL_OW 437
53967: IFFALSE 54015
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
53969: LD_VAR 0 1
53973: PPUSH
53974: CALL_OW 437
53978: PUSH
53979: LD_INT 1
53981: ARRAY
53982: PUSH
53983: LD_INT 1
53985: ARRAY
53986: PUSH
53987: LD_STRING l
53989: EQUAL
53990: IFFALSE 54015
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
53992: LD_ADDR_VAR 0 2
53996: PUSH
53997: LD_VAR 0 1
54001: PPUSH
54002: CALL_OW 437
54006: PUSH
54007: LD_INT 1
54009: ARRAY
54010: PUSH
54011: LD_INT 4
54013: ARRAY
54014: ST_TO_ADDR
// end ;
54015: LD_VAR 0 2
54019: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
54020: LD_INT 0
54022: PPUSH
54023: PPUSH
54024: PPUSH
54025: PPUSH
// if not base_units then
54026: LD_VAR 0 1
54030: NOT
54031: IFFALSE 54035
// exit ;
54033: GO 54122
// result := false ;
54035: LD_ADDR_VAR 0 2
54039: PUSH
54040: LD_INT 0
54042: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
54043: LD_ADDR_VAR 0 5
54047: PUSH
54048: LD_VAR 0 1
54052: PPUSH
54053: LD_INT 21
54055: PUSH
54056: LD_INT 3
54058: PUSH
54059: EMPTY
54060: LIST
54061: LIST
54062: PPUSH
54063: CALL_OW 72
54067: ST_TO_ADDR
// if not tmp then
54068: LD_VAR 0 5
54072: NOT
54073: IFFALSE 54077
// exit ;
54075: GO 54122
// for i in tmp do
54077: LD_ADDR_VAR 0 3
54081: PUSH
54082: LD_VAR 0 5
54086: PUSH
54087: FOR_IN
54088: IFFALSE 54120
// begin result := EnemyInRange ( i , 22 ) ;
54090: LD_ADDR_VAR 0 2
54094: PUSH
54095: LD_VAR 0 3
54099: PPUSH
54100: LD_INT 22
54102: PPUSH
54103: CALL 51709 0 2
54107: ST_TO_ADDR
// if result then
54108: LD_VAR 0 2
54112: IFFALSE 54118
// exit ;
54114: POP
54115: POP
54116: GO 54122
// end ;
54118: GO 54087
54120: POP
54121: POP
// end ;
54122: LD_VAR 0 2
54126: RET
// export function FilterByTag ( units , tag ) ; begin
54127: LD_INT 0
54129: PPUSH
// result := UnitFilter ( units , [ f_tag , tag ] ) ;
54130: LD_ADDR_VAR 0 3
54134: PUSH
54135: LD_VAR 0 1
54139: PPUSH
54140: LD_INT 120
54142: PUSH
54143: LD_VAR 0 2
54147: PUSH
54148: EMPTY
54149: LIST
54150: LIST
54151: PPUSH
54152: CALL_OW 72
54156: ST_TO_ADDR
// end ;
54157: LD_VAR 0 3
54161: RET
// export function IsDriver ( un ) ; begin
54162: LD_INT 0
54164: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
54165: LD_ADDR_VAR 0 2
54169: PUSH
54170: LD_VAR 0 1
54174: PUSH
54175: LD_INT 55
54177: PUSH
54178: EMPTY
54179: LIST
54180: PPUSH
54181: CALL_OW 69
54185: IN
54186: ST_TO_ADDR
// end ;
54187: LD_VAR 0 2
54191: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
54192: LD_INT 0
54194: PPUSH
54195: PPUSH
// list := [ ] ;
54196: LD_ADDR_VAR 0 5
54200: PUSH
54201: EMPTY
54202: ST_TO_ADDR
// case d of 0 :
54203: LD_VAR 0 3
54207: PUSH
54208: LD_INT 0
54210: DOUBLE
54211: EQUAL
54212: IFTRUE 54216
54214: GO 54349
54216: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
54217: LD_ADDR_VAR 0 5
54221: PUSH
54222: LD_VAR 0 1
54226: PUSH
54227: LD_INT 4
54229: MINUS
54230: PUSH
54231: LD_VAR 0 2
54235: PUSH
54236: LD_INT 4
54238: MINUS
54239: PUSH
54240: LD_INT 2
54242: PUSH
54243: EMPTY
54244: LIST
54245: LIST
54246: LIST
54247: PUSH
54248: LD_VAR 0 1
54252: PUSH
54253: LD_INT 3
54255: MINUS
54256: PUSH
54257: LD_VAR 0 2
54261: PUSH
54262: LD_INT 1
54264: PUSH
54265: EMPTY
54266: LIST
54267: LIST
54268: LIST
54269: PUSH
54270: LD_VAR 0 1
54274: PUSH
54275: LD_INT 4
54277: PLUS
54278: PUSH
54279: LD_VAR 0 2
54283: PUSH
54284: LD_INT 4
54286: PUSH
54287: EMPTY
54288: LIST
54289: LIST
54290: LIST
54291: PUSH
54292: LD_VAR 0 1
54296: PUSH
54297: LD_INT 3
54299: PLUS
54300: PUSH
54301: LD_VAR 0 2
54305: PUSH
54306: LD_INT 3
54308: PLUS
54309: PUSH
54310: LD_INT 5
54312: PUSH
54313: EMPTY
54314: LIST
54315: LIST
54316: LIST
54317: PUSH
54318: LD_VAR 0 1
54322: PUSH
54323: LD_VAR 0 2
54327: PUSH
54328: LD_INT 4
54330: PLUS
54331: PUSH
54332: LD_INT 0
54334: PUSH
54335: EMPTY
54336: LIST
54337: LIST
54338: LIST
54339: PUSH
54340: EMPTY
54341: LIST
54342: LIST
54343: LIST
54344: LIST
54345: LIST
54346: ST_TO_ADDR
// end ; 1 :
54347: GO 55047
54349: LD_INT 1
54351: DOUBLE
54352: EQUAL
54353: IFTRUE 54357
54355: GO 54490
54357: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
54358: LD_ADDR_VAR 0 5
54362: PUSH
54363: LD_VAR 0 1
54367: PUSH
54368: LD_VAR 0 2
54372: PUSH
54373: LD_INT 4
54375: MINUS
54376: PUSH
54377: LD_INT 3
54379: PUSH
54380: EMPTY
54381: LIST
54382: LIST
54383: LIST
54384: PUSH
54385: LD_VAR 0 1
54389: PUSH
54390: LD_INT 3
54392: MINUS
54393: PUSH
54394: LD_VAR 0 2
54398: PUSH
54399: LD_INT 3
54401: MINUS
54402: PUSH
54403: LD_INT 2
54405: PUSH
54406: EMPTY
54407: LIST
54408: LIST
54409: LIST
54410: PUSH
54411: LD_VAR 0 1
54415: PUSH
54416: LD_INT 4
54418: MINUS
54419: PUSH
54420: LD_VAR 0 2
54424: PUSH
54425: LD_INT 1
54427: PUSH
54428: EMPTY
54429: LIST
54430: LIST
54431: LIST
54432: PUSH
54433: LD_VAR 0 1
54437: PUSH
54438: LD_VAR 0 2
54442: PUSH
54443: LD_INT 3
54445: PLUS
54446: PUSH
54447: LD_INT 0
54449: PUSH
54450: EMPTY
54451: LIST
54452: LIST
54453: LIST
54454: PUSH
54455: LD_VAR 0 1
54459: PUSH
54460: LD_INT 4
54462: PLUS
54463: PUSH
54464: LD_VAR 0 2
54468: PUSH
54469: LD_INT 4
54471: PLUS
54472: PUSH
54473: LD_INT 5
54475: PUSH
54476: EMPTY
54477: LIST
54478: LIST
54479: LIST
54480: PUSH
54481: EMPTY
54482: LIST
54483: LIST
54484: LIST
54485: LIST
54486: LIST
54487: ST_TO_ADDR
// end ; 2 :
54488: GO 55047
54490: LD_INT 2
54492: DOUBLE
54493: EQUAL
54494: IFTRUE 54498
54496: GO 54627
54498: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
54499: LD_ADDR_VAR 0 5
54503: PUSH
54504: LD_VAR 0 1
54508: PUSH
54509: LD_VAR 0 2
54513: PUSH
54514: LD_INT 3
54516: MINUS
54517: PUSH
54518: LD_INT 3
54520: PUSH
54521: EMPTY
54522: LIST
54523: LIST
54524: LIST
54525: PUSH
54526: LD_VAR 0 1
54530: PUSH
54531: LD_INT 4
54533: PLUS
54534: PUSH
54535: LD_VAR 0 2
54539: PUSH
54540: LD_INT 4
54542: PUSH
54543: EMPTY
54544: LIST
54545: LIST
54546: LIST
54547: PUSH
54548: LD_VAR 0 1
54552: PUSH
54553: LD_VAR 0 2
54557: PUSH
54558: LD_INT 4
54560: PLUS
54561: PUSH
54562: LD_INT 0
54564: PUSH
54565: EMPTY
54566: LIST
54567: LIST
54568: LIST
54569: PUSH
54570: LD_VAR 0 1
54574: PUSH
54575: LD_INT 3
54577: MINUS
54578: PUSH
54579: LD_VAR 0 2
54583: PUSH
54584: LD_INT 1
54586: PUSH
54587: EMPTY
54588: LIST
54589: LIST
54590: LIST
54591: PUSH
54592: LD_VAR 0 1
54596: PUSH
54597: LD_INT 4
54599: MINUS
54600: PUSH
54601: LD_VAR 0 2
54605: PUSH
54606: LD_INT 4
54608: MINUS
54609: PUSH
54610: LD_INT 2
54612: PUSH
54613: EMPTY
54614: LIST
54615: LIST
54616: LIST
54617: PUSH
54618: EMPTY
54619: LIST
54620: LIST
54621: LIST
54622: LIST
54623: LIST
54624: ST_TO_ADDR
// end ; 3 :
54625: GO 55047
54627: LD_INT 3
54629: DOUBLE
54630: EQUAL
54631: IFTRUE 54635
54633: GO 54768
54635: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
54636: LD_ADDR_VAR 0 5
54640: PUSH
54641: LD_VAR 0 1
54645: PUSH
54646: LD_INT 3
54648: PLUS
54649: PUSH
54650: LD_VAR 0 2
54654: PUSH
54655: LD_INT 4
54657: PUSH
54658: EMPTY
54659: LIST
54660: LIST
54661: LIST
54662: PUSH
54663: LD_VAR 0 1
54667: PUSH
54668: LD_INT 4
54670: PLUS
54671: PUSH
54672: LD_VAR 0 2
54676: PUSH
54677: LD_INT 4
54679: PLUS
54680: PUSH
54681: LD_INT 5
54683: PUSH
54684: EMPTY
54685: LIST
54686: LIST
54687: LIST
54688: PUSH
54689: LD_VAR 0 1
54693: PUSH
54694: LD_INT 4
54696: MINUS
54697: PUSH
54698: LD_VAR 0 2
54702: PUSH
54703: LD_INT 1
54705: PUSH
54706: EMPTY
54707: LIST
54708: LIST
54709: LIST
54710: PUSH
54711: LD_VAR 0 1
54715: PUSH
54716: LD_VAR 0 2
54720: PUSH
54721: LD_INT 4
54723: MINUS
54724: PUSH
54725: LD_INT 3
54727: PUSH
54728: EMPTY
54729: LIST
54730: LIST
54731: LIST
54732: PUSH
54733: LD_VAR 0 1
54737: PUSH
54738: LD_INT 3
54740: MINUS
54741: PUSH
54742: LD_VAR 0 2
54746: PUSH
54747: LD_INT 3
54749: MINUS
54750: PUSH
54751: LD_INT 2
54753: PUSH
54754: EMPTY
54755: LIST
54756: LIST
54757: LIST
54758: PUSH
54759: EMPTY
54760: LIST
54761: LIST
54762: LIST
54763: LIST
54764: LIST
54765: ST_TO_ADDR
// end ; 4 :
54766: GO 55047
54768: LD_INT 4
54770: DOUBLE
54771: EQUAL
54772: IFTRUE 54776
54774: GO 54909
54776: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
54777: LD_ADDR_VAR 0 5
54781: PUSH
54782: LD_VAR 0 1
54786: PUSH
54787: LD_VAR 0 2
54791: PUSH
54792: LD_INT 4
54794: PLUS
54795: PUSH
54796: LD_INT 0
54798: PUSH
54799: EMPTY
54800: LIST
54801: LIST
54802: LIST
54803: PUSH
54804: LD_VAR 0 1
54808: PUSH
54809: LD_INT 3
54811: PLUS
54812: PUSH
54813: LD_VAR 0 2
54817: PUSH
54818: LD_INT 3
54820: PLUS
54821: PUSH
54822: LD_INT 5
54824: PUSH
54825: EMPTY
54826: LIST
54827: LIST
54828: LIST
54829: PUSH
54830: LD_VAR 0 1
54834: PUSH
54835: LD_INT 4
54837: PLUS
54838: PUSH
54839: LD_VAR 0 2
54843: PUSH
54844: LD_INT 4
54846: PUSH
54847: EMPTY
54848: LIST
54849: LIST
54850: LIST
54851: PUSH
54852: LD_VAR 0 1
54856: PUSH
54857: LD_VAR 0 2
54861: PUSH
54862: LD_INT 3
54864: MINUS
54865: PUSH
54866: LD_INT 3
54868: PUSH
54869: EMPTY
54870: LIST
54871: LIST
54872: LIST
54873: PUSH
54874: LD_VAR 0 1
54878: PUSH
54879: LD_INT 4
54881: MINUS
54882: PUSH
54883: LD_VAR 0 2
54887: PUSH
54888: LD_INT 4
54890: MINUS
54891: PUSH
54892: LD_INT 2
54894: PUSH
54895: EMPTY
54896: LIST
54897: LIST
54898: LIST
54899: PUSH
54900: EMPTY
54901: LIST
54902: LIST
54903: LIST
54904: LIST
54905: LIST
54906: ST_TO_ADDR
// end ; 5 :
54907: GO 55047
54909: LD_INT 5
54911: DOUBLE
54912: EQUAL
54913: IFTRUE 54917
54915: GO 55046
54917: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
54918: LD_ADDR_VAR 0 5
54922: PUSH
54923: LD_VAR 0 1
54927: PUSH
54928: LD_INT 4
54930: MINUS
54931: PUSH
54932: LD_VAR 0 2
54936: PUSH
54937: LD_INT 1
54939: PUSH
54940: EMPTY
54941: LIST
54942: LIST
54943: LIST
54944: PUSH
54945: LD_VAR 0 1
54949: PUSH
54950: LD_VAR 0 2
54954: PUSH
54955: LD_INT 4
54957: MINUS
54958: PUSH
54959: LD_INT 3
54961: PUSH
54962: EMPTY
54963: LIST
54964: LIST
54965: LIST
54966: PUSH
54967: LD_VAR 0 1
54971: PUSH
54972: LD_INT 4
54974: PLUS
54975: PUSH
54976: LD_VAR 0 2
54980: PUSH
54981: LD_INT 4
54983: PLUS
54984: PUSH
54985: LD_INT 5
54987: PUSH
54988: EMPTY
54989: LIST
54990: LIST
54991: LIST
54992: PUSH
54993: LD_VAR 0 1
54997: PUSH
54998: LD_INT 3
55000: PLUS
55001: PUSH
55002: LD_VAR 0 2
55006: PUSH
55007: LD_INT 4
55009: PUSH
55010: EMPTY
55011: LIST
55012: LIST
55013: LIST
55014: PUSH
55015: LD_VAR 0 1
55019: PUSH
55020: LD_VAR 0 2
55024: PUSH
55025: LD_INT 3
55027: PLUS
55028: PUSH
55029: LD_INT 0
55031: PUSH
55032: EMPTY
55033: LIST
55034: LIST
55035: LIST
55036: PUSH
55037: EMPTY
55038: LIST
55039: LIST
55040: LIST
55041: LIST
55042: LIST
55043: ST_TO_ADDR
// end ; end ;
55044: GO 55047
55046: POP
// result := list ;
55047: LD_ADDR_VAR 0 4
55051: PUSH
55052: LD_VAR 0 5
55056: ST_TO_ADDR
// end ;
55057: LD_VAR 0 4
55061: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
55062: LD_INT 0
55064: PPUSH
55065: PPUSH
55066: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
55067: LD_VAR 0 1
55071: NOT
55072: PUSH
55073: LD_VAR 0 2
55077: PUSH
55078: LD_INT 1
55080: PUSH
55081: LD_INT 2
55083: PUSH
55084: LD_INT 3
55086: PUSH
55087: LD_INT 4
55089: PUSH
55090: EMPTY
55091: LIST
55092: LIST
55093: LIST
55094: LIST
55095: IN
55096: NOT
55097: OR
55098: IFFALSE 55102
// exit ;
55100: GO 55185
// tmp := [ ] ;
55102: LD_ADDR_VAR 0 5
55106: PUSH
55107: EMPTY
55108: ST_TO_ADDR
// for i in units do
55109: LD_ADDR_VAR 0 4
55113: PUSH
55114: LD_VAR 0 1
55118: PUSH
55119: FOR_IN
55120: IFFALSE 55154
// tmp := Join ( tmp , GetSkill ( i , class ) ) ;
55122: LD_ADDR_VAR 0 5
55126: PUSH
55127: LD_VAR 0 5
55131: PPUSH
55132: LD_VAR 0 4
55136: PPUSH
55137: LD_VAR 0 2
55141: PPUSH
55142: CALL_OW 259
55146: PPUSH
55147: CALL 56545 0 2
55151: ST_TO_ADDR
55152: GO 55119
55154: POP
55155: POP
// if not tmp then
55156: LD_VAR 0 5
55160: NOT
55161: IFFALSE 55165
// exit ;
55163: GO 55185
// result := SortListByListDesc ( units , tmp ) ;
55165: LD_ADDR_VAR 0 3
55169: PUSH
55170: LD_VAR 0 1
55174: PPUSH
55175: LD_VAR 0 5
55179: PPUSH
55180: CALL_OW 77
55184: ST_TO_ADDR
// end ;
55185: LD_VAR 0 3
55189: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
55190: LD_INT 0
55192: PPUSH
55193: PPUSH
55194: PPUSH
// result := false ;
55195: LD_ADDR_VAR 0 3
55199: PUSH
55200: LD_INT 0
55202: ST_TO_ADDR
// if not building then
55203: LD_VAR 0 2
55207: NOT
55208: IFFALSE 55212
// exit ;
55210: GO 55350
// x := GetX ( building ) ;
55212: LD_ADDR_VAR 0 4
55216: PUSH
55217: LD_VAR 0 2
55221: PPUSH
55222: CALL_OW 250
55226: ST_TO_ADDR
// y := GetY ( building ) ;
55227: LD_ADDR_VAR 0 5
55231: PUSH
55232: LD_VAR 0 2
55236: PPUSH
55237: CALL_OW 251
55241: ST_TO_ADDR
// if not x or not y then
55242: LD_VAR 0 4
55246: NOT
55247: PUSH
55248: LD_VAR 0 5
55252: NOT
55253: OR
55254: IFFALSE 55258
// exit ;
55256: GO 55350
// if GetTaskList ( unit ) then
55258: LD_VAR 0 1
55262: PPUSH
55263: CALL_OW 437
55267: IFFALSE 55350
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
55269: LD_STRING e
55271: PUSH
55272: LD_VAR 0 1
55276: PPUSH
55277: CALL_OW 437
55281: PUSH
55282: LD_INT 1
55284: ARRAY
55285: PUSH
55286: LD_INT 1
55288: ARRAY
55289: EQUAL
55290: PUSH
55291: LD_VAR 0 4
55295: PUSH
55296: LD_VAR 0 1
55300: PPUSH
55301: CALL_OW 437
55305: PUSH
55306: LD_INT 1
55308: ARRAY
55309: PUSH
55310: LD_INT 2
55312: ARRAY
55313: EQUAL
55314: AND
55315: PUSH
55316: LD_VAR 0 5
55320: PUSH
55321: LD_VAR 0 1
55325: PPUSH
55326: CALL_OW 437
55330: PUSH
55331: LD_INT 1
55333: ARRAY
55334: PUSH
55335: LD_INT 3
55337: ARRAY
55338: EQUAL
55339: AND
55340: IFFALSE 55350
// result := true end ;
55342: LD_ADDR_VAR 0 3
55346: PUSH
55347: LD_INT 1
55349: ST_TO_ADDR
// end ;
55350: LD_VAR 0 3
55354: RET
// export function UnitGoingToXY ( unit , x , y ) ; begin
55355: LD_INT 0
55357: PPUSH
// result := false ;
55358: LD_ADDR_VAR 0 4
55362: PUSH
55363: LD_INT 0
55365: ST_TO_ADDR
// if GetTaskList ( unit ) then
55366: LD_VAR 0 1
55370: PPUSH
55371: CALL_OW 437
55375: IFFALSE 55458
// begin if M = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
55377: LD_STRING M
55379: PUSH
55380: LD_VAR 0 1
55384: PPUSH
55385: CALL_OW 437
55389: PUSH
55390: LD_INT 1
55392: ARRAY
55393: PUSH
55394: LD_INT 1
55396: ARRAY
55397: EQUAL
55398: PUSH
55399: LD_VAR 0 2
55403: PUSH
55404: LD_VAR 0 1
55408: PPUSH
55409: CALL_OW 437
55413: PUSH
55414: LD_INT 1
55416: ARRAY
55417: PUSH
55418: LD_INT 2
55420: ARRAY
55421: EQUAL
55422: AND
55423: PUSH
55424: LD_VAR 0 3
55428: PUSH
55429: LD_VAR 0 1
55433: PPUSH
55434: CALL_OW 437
55438: PUSH
55439: LD_INT 1
55441: ARRAY
55442: PUSH
55443: LD_INT 3
55445: ARRAY
55446: EQUAL
55447: AND
55448: IFFALSE 55458
// result := true ;
55450: LD_ADDR_VAR 0 4
55454: PUSH
55455: LD_INT 1
55457: ST_TO_ADDR
// end ; end ;
55458: LD_VAR 0 4
55462: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
55463: LD_INT 0
55465: PPUSH
55466: PPUSH
55467: PPUSH
55468: PPUSH
// if not unit or not area then
55469: LD_VAR 0 1
55473: NOT
55474: PUSH
55475: LD_VAR 0 2
55479: NOT
55480: OR
55481: IFFALSE 55485
// exit ;
55483: GO 55648
// tmp := AreaToList ( area , i ) ;
55485: LD_ADDR_VAR 0 6
55489: PUSH
55490: LD_VAR 0 2
55494: PPUSH
55495: LD_VAR 0 5
55499: PPUSH
55500: CALL_OW 517
55504: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
55505: LD_ADDR_VAR 0 5
55509: PUSH
55510: DOUBLE
55511: LD_INT 1
55513: DEC
55514: ST_TO_ADDR
55515: LD_VAR 0 6
55519: PUSH
55520: LD_INT 1
55522: ARRAY
55523: PUSH
55524: FOR_TO
55525: IFFALSE 55646
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
55527: LD_ADDR_VAR 0 7
55531: PUSH
55532: LD_VAR 0 6
55536: PUSH
55537: LD_INT 1
55539: ARRAY
55540: PUSH
55541: LD_VAR 0 5
55545: ARRAY
55546: PUSH
55547: LD_VAR 0 6
55551: PUSH
55552: LD_INT 2
55554: ARRAY
55555: PUSH
55556: LD_VAR 0 5
55560: ARRAY
55561: PUSH
55562: EMPTY
55563: LIST
55564: LIST
55565: ST_TO_ADDR
// if FilterAllUnits ( [ f_distxy , hex [ 1 ] , hex [ 2 ] , 3 ] ) = 0 then
55566: LD_INT 92
55568: PUSH
55569: LD_VAR 0 7
55573: PUSH
55574: LD_INT 1
55576: ARRAY
55577: PUSH
55578: LD_VAR 0 7
55582: PUSH
55583: LD_INT 2
55585: ARRAY
55586: PUSH
55587: LD_INT 3
55589: PUSH
55590: EMPTY
55591: LIST
55592: LIST
55593: LIST
55594: LIST
55595: PPUSH
55596: CALL_OW 69
55600: PUSH
55601: LD_INT 0
55603: EQUAL
55604: IFFALSE 55644
// begin PlaceUnitArea ( unit , area , mode ) ;
55606: LD_VAR 0 1
55610: PPUSH
55611: LD_VAR 0 2
55615: PPUSH
55616: LD_VAR 0 3
55620: PPUSH
55621: CALL_OW 49
// result := IsPlaced ( unit ) ;
55625: LD_ADDR_VAR 0 4
55629: PUSH
55630: LD_VAR 0 1
55634: PPUSH
55635: CALL_OW 305
55639: ST_TO_ADDR
// exit ;
55640: POP
55641: POP
55642: GO 55648
// end ; end ;
55644: GO 55524
55646: POP
55647: POP
// end ;
55648: LD_VAR 0 4
55652: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
55653: LD_INT 0
55655: PPUSH
55656: PPUSH
55657: PPUSH
// if not side or side > 8 then
55658: LD_VAR 0 1
55662: NOT
55663: PUSH
55664: LD_VAR 0 1
55668: PUSH
55669: LD_INT 8
55671: GREATER
55672: OR
55673: IFFALSE 55677
// exit ;
55675: GO 55864
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
55677: LD_ADDR_VAR 0 4
55681: PUSH
55682: LD_INT 22
55684: PUSH
55685: LD_VAR 0 1
55689: PUSH
55690: EMPTY
55691: LIST
55692: LIST
55693: PUSH
55694: LD_INT 21
55696: PUSH
55697: LD_INT 3
55699: PUSH
55700: EMPTY
55701: LIST
55702: LIST
55703: PUSH
55704: EMPTY
55705: LIST
55706: LIST
55707: PPUSH
55708: CALL_OW 69
55712: ST_TO_ADDR
// if not tmp then
55713: LD_VAR 0 4
55717: NOT
55718: IFFALSE 55722
// exit ;
55720: GO 55864
// enable_addtolog := true ;
55722: LD_ADDR_OWVAR 81
55726: PUSH
55727: LD_INT 1
55729: ST_TO_ADDR
// AddToLog ( [ ) ;
55730: LD_STRING [
55732: PPUSH
55733: CALL_OW 561
// for i in tmp do
55737: LD_ADDR_VAR 0 3
55741: PUSH
55742: LD_VAR 0 4
55746: PUSH
55747: FOR_IN
55748: IFFALSE 55855
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
55750: LD_STRING [
55752: PUSH
55753: LD_VAR 0 3
55757: PPUSH
55758: CALL_OW 266
55762: STR
55763: PUSH
55764: LD_STRING , 
55766: STR
55767: PUSH
55768: LD_VAR 0 3
55772: PPUSH
55773: CALL_OW 250
55777: STR
55778: PUSH
55779: LD_STRING , 
55781: STR
55782: PUSH
55783: LD_VAR 0 3
55787: PPUSH
55788: CALL_OW 251
55792: STR
55793: PUSH
55794: LD_STRING , 
55796: STR
55797: PUSH
55798: LD_VAR 0 3
55802: PPUSH
55803: CALL_OW 254
55807: STR
55808: PUSH
55809: LD_STRING , 
55811: STR
55812: PUSH
55813: LD_VAR 0 3
55817: PPUSH
55818: LD_INT 1
55820: PPUSH
55821: CALL_OW 268
55825: STR
55826: PUSH
55827: LD_STRING , 
55829: STR
55830: PUSH
55831: LD_VAR 0 3
55835: PPUSH
55836: LD_INT 2
55838: PPUSH
55839: CALL_OW 268
55843: STR
55844: PUSH
55845: LD_STRING ],
55847: STR
55848: PPUSH
55849: CALL_OW 561
// end ;
55853: GO 55747
55855: POP
55856: POP
// AddToLog ( ]; ) ;
55857: LD_STRING ];
55859: PPUSH
55860: CALL_OW 561
// end ;
55864: LD_VAR 0 2
55868: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
55869: LD_INT 0
55871: PPUSH
55872: PPUSH
55873: PPUSH
55874: PPUSH
55875: PPUSH
// if not area or not rate or not max then
55876: LD_VAR 0 1
55880: NOT
55881: PUSH
55882: LD_VAR 0 2
55886: NOT
55887: OR
55888: PUSH
55889: LD_VAR 0 4
55893: NOT
55894: OR
55895: IFFALSE 55899
// exit ;
55897: GO 56088
// while 1 do
55899: LD_INT 1
55901: IFFALSE 56088
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
55903: LD_ADDR_VAR 0 9
55907: PUSH
55908: LD_VAR 0 1
55912: PPUSH
55913: LD_INT 1
55915: PPUSH
55916: CALL_OW 287
55920: PUSH
55921: LD_INT 10
55923: MUL
55924: ST_TO_ADDR
// r := rate / 10 ;
55925: LD_ADDR_VAR 0 7
55929: PUSH
55930: LD_VAR 0 2
55934: PUSH
55935: LD_INT 10
55937: DIVREAL
55938: ST_TO_ADDR
// time := 1 1$00 ;
55939: LD_ADDR_VAR 0 8
55943: PUSH
55944: LD_INT 2100
55946: ST_TO_ADDR
// if amount < min then
55947: LD_VAR 0 9
55951: PUSH
55952: LD_VAR 0 3
55956: LESS
55957: IFFALSE 55975
// r := r * 2 else
55959: LD_ADDR_VAR 0 7
55963: PUSH
55964: LD_VAR 0 7
55968: PUSH
55969: LD_INT 2
55971: MUL
55972: ST_TO_ADDR
55973: GO 56001
// if amount > max then
55975: LD_VAR 0 9
55979: PUSH
55980: LD_VAR 0 4
55984: GREATER
55985: IFFALSE 56001
// r := r / 2 ;
55987: LD_ADDR_VAR 0 7
55991: PUSH
55992: LD_VAR 0 7
55996: PUSH
55997: LD_INT 2
55999: DIVREAL
56000: ST_TO_ADDR
// time := time / r ;
56001: LD_ADDR_VAR 0 8
56005: PUSH
56006: LD_VAR 0 8
56010: PUSH
56011: LD_VAR 0 7
56015: DIVREAL
56016: ST_TO_ADDR
// if time < 0 then
56017: LD_VAR 0 8
56021: PUSH
56022: LD_INT 0
56024: LESS
56025: IFFALSE 56042
// time := time * - 1 ;
56027: LD_ADDR_VAR 0 8
56031: PUSH
56032: LD_VAR 0 8
56036: PUSH
56037: LD_INT 1
56039: NEG
56040: MUL
56041: ST_TO_ADDR
// wait ( time + rand ( 0 0$01 , 0 0$25 ) ) ;
56042: LD_VAR 0 8
56046: PUSH
56047: LD_INT 35
56049: PPUSH
56050: LD_INT 875
56052: PPUSH
56053: CALL_OW 12
56057: PLUS
56058: PPUSH
56059: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
56063: LD_INT 1
56065: PPUSH
56066: LD_INT 5
56068: PPUSH
56069: CALL_OW 12
56073: PPUSH
56074: LD_VAR 0 1
56078: PPUSH
56079: LD_INT 1
56081: PPUSH
56082: CALL_OW 55
// end ;
56086: GO 55899
// end ;
56088: LD_VAR 0 5
56092: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
56093: LD_INT 0
56095: PPUSH
56096: PPUSH
56097: PPUSH
56098: PPUSH
56099: PPUSH
56100: PPUSH
56101: PPUSH
56102: PPUSH
// if not turrets or not factories then
56103: LD_VAR 0 1
56107: NOT
56108: PUSH
56109: LD_VAR 0 2
56113: NOT
56114: OR
56115: IFFALSE 56119
// exit ;
56117: GO 56426
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
56119: LD_ADDR_VAR 0 10
56123: PUSH
56124: LD_INT 5
56126: PUSH
56127: LD_INT 6
56129: PUSH
56130: EMPTY
56131: LIST
56132: LIST
56133: PUSH
56134: LD_INT 2
56136: PUSH
56137: LD_INT 4
56139: PUSH
56140: EMPTY
56141: LIST
56142: LIST
56143: PUSH
56144: LD_INT 3
56146: PUSH
56147: LD_INT 5
56149: PUSH
56150: EMPTY
56151: LIST
56152: LIST
56153: PUSH
56154: EMPTY
56155: LIST
56156: LIST
56157: LIST
56158: PUSH
56159: LD_INT 24
56161: PUSH
56162: LD_INT 25
56164: PUSH
56165: EMPTY
56166: LIST
56167: LIST
56168: PUSH
56169: LD_INT 23
56171: PUSH
56172: LD_INT 27
56174: PUSH
56175: EMPTY
56176: LIST
56177: LIST
56178: PUSH
56179: EMPTY
56180: LIST
56181: LIST
56182: PUSH
56183: LD_INT 42
56185: PUSH
56186: LD_INT 43
56188: PUSH
56189: EMPTY
56190: LIST
56191: LIST
56192: PUSH
56193: LD_INT 44
56195: PUSH
56196: LD_INT 46
56198: PUSH
56199: EMPTY
56200: LIST
56201: LIST
56202: PUSH
56203: LD_INT 45
56205: PUSH
56206: LD_INT 47
56208: PUSH
56209: EMPTY
56210: LIST
56211: LIST
56212: PUSH
56213: EMPTY
56214: LIST
56215: LIST
56216: LIST
56217: PUSH
56218: EMPTY
56219: LIST
56220: LIST
56221: LIST
56222: ST_TO_ADDR
// result := [ ] ;
56223: LD_ADDR_VAR 0 3
56227: PUSH
56228: EMPTY
56229: ST_TO_ADDR
// for i in turrets do
56230: LD_ADDR_VAR 0 4
56234: PUSH
56235: LD_VAR 0 1
56239: PUSH
56240: FOR_IN
56241: IFFALSE 56424
// begin nat := GetNation ( i ) ;
56243: LD_ADDR_VAR 0 7
56247: PUSH
56248: LD_VAR 0 4
56252: PPUSH
56253: CALL_OW 248
56257: ST_TO_ADDR
// weapon := 0 ;
56258: LD_ADDR_VAR 0 8
56262: PUSH
56263: LD_INT 0
56265: ST_TO_ADDR
// if not nat then
56266: LD_VAR 0 7
56270: NOT
56271: IFFALSE 56275
// continue ;
56273: GO 56240
// for j in list [ nat ] do
56275: LD_ADDR_VAR 0 5
56279: PUSH
56280: LD_VAR 0 10
56284: PUSH
56285: LD_VAR 0 7
56289: ARRAY
56290: PUSH
56291: FOR_IN
56292: IFFALSE 56333
// if GetBWeapon ( i ) = j [ 1 ] then
56294: LD_VAR 0 4
56298: PPUSH
56299: CALL_OW 269
56303: PUSH
56304: LD_VAR 0 5
56308: PUSH
56309: LD_INT 1
56311: ARRAY
56312: EQUAL
56313: IFFALSE 56331
// begin weapon := j [ 2 ] ;
56315: LD_ADDR_VAR 0 8
56319: PUSH
56320: LD_VAR 0 5
56324: PUSH
56325: LD_INT 2
56327: ARRAY
56328: ST_TO_ADDR
// break ;
56329: GO 56333
// end ;
56331: GO 56291
56333: POP
56334: POP
// if not weapon then
56335: LD_VAR 0 8
56339: NOT
56340: IFFALSE 56344
// continue ;
56342: GO 56240
// for k in factories do
56344: LD_ADDR_VAR 0 6
56348: PUSH
56349: LD_VAR 0 2
56353: PUSH
56354: FOR_IN
56355: IFFALSE 56420
// begin weapons := AvailableWeaponList ( k ) ;
56357: LD_ADDR_VAR 0 9
56361: PUSH
56362: LD_VAR 0 6
56366: PPUSH
56367: CALL_OW 478
56371: ST_TO_ADDR
// if not weapons then
56372: LD_VAR 0 9
56376: NOT
56377: IFFALSE 56381
// continue ;
56379: GO 56354
// if weapon in weapons then
56381: LD_VAR 0 8
56385: PUSH
56386: LD_VAR 0 9
56390: IN
56391: IFFALSE 56418
// begin result := [ i , weapon ] ;
56393: LD_ADDR_VAR 0 3
56397: PUSH
56398: LD_VAR 0 4
56402: PUSH
56403: LD_VAR 0 8
56407: PUSH
56408: EMPTY
56409: LIST
56410: LIST
56411: ST_TO_ADDR
// exit ;
56412: POP
56413: POP
56414: POP
56415: POP
56416: GO 56426
// end ; end ;
56418: GO 56354
56420: POP
56421: POP
// end ;
56422: GO 56240
56424: POP
56425: POP
// end ;
56426: LD_VAR 0 3
56430: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
56431: LD_INT 0
56433: PPUSH
// if not side or side > 8 then
56434: LD_VAR 0 3
56438: NOT
56439: PUSH
56440: LD_VAR 0 3
56444: PUSH
56445: LD_INT 8
56447: GREATER
56448: OR
56449: IFFALSE 56453
// exit ;
56451: GO 56512
// if not range then
56453: LD_VAR 0 4
56457: NOT
56458: IFFALSE 56469
// range := - 12 ;
56460: LD_ADDR_VAR 0 4
56464: PUSH
56465: LD_INT 12
56467: NEG
56468: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
56469: LD_VAR 0 1
56473: PPUSH
56474: LD_VAR 0 2
56478: PPUSH
56479: LD_VAR 0 3
56483: PPUSH
56484: LD_VAR 0 4
56488: PPUSH
56489: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
56493: LD_VAR 0 1
56497: PPUSH
56498: LD_VAR 0 2
56502: PPUSH
56503: LD_VAR 0 3
56507: PPUSH
56508: CALL_OW 331
// end ;
56512: LD_VAR 0 5
56516: RET
// export function Video ( mode ) ; begin
56517: LD_INT 0
56519: PPUSH
// ingame_video = mode ;
56520: LD_ADDR_OWVAR 52
56524: PUSH
56525: LD_VAR 0 1
56529: ST_TO_ADDR
// interface_hidden = mode ;
56530: LD_ADDR_OWVAR 54
56534: PUSH
56535: LD_VAR 0 1
56539: ST_TO_ADDR
// end ;
56540: LD_VAR 0 2
56544: RET
// export function Join ( array , element ) ; begin
56545: LD_INT 0
56547: PPUSH
// result := Replace ( array , array + 1 , element ) ;
56548: LD_ADDR_VAR 0 3
56552: PUSH
56553: LD_VAR 0 1
56557: PPUSH
56558: LD_VAR 0 1
56562: PUSH
56563: LD_INT 1
56565: PLUS
56566: PPUSH
56567: LD_VAR 0 2
56571: PPUSH
56572: CALL_OW 1
56576: ST_TO_ADDR
// end ;
56577: LD_VAR 0 3
56581: RET
// export function JoinUnion ( array , element ) ; begin
56582: LD_INT 0
56584: PPUSH
// result := array union element ;
56585: LD_ADDR_VAR 0 3
56589: PUSH
56590: LD_VAR 0 1
56594: PUSH
56595: LD_VAR 0 2
56599: UNION
56600: ST_TO_ADDR
// end ;
56601: LD_VAR 0 3
56605: RET
// export function GetBehemoths ( side ) ; begin
56606: LD_INT 0
56608: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , ru_behemoth ] ] ) ;
56609: LD_ADDR_VAR 0 2
56613: PUSH
56614: LD_INT 22
56616: PUSH
56617: LD_VAR 0 1
56621: PUSH
56622: EMPTY
56623: LIST
56624: LIST
56625: PUSH
56626: LD_INT 31
56628: PUSH
56629: LD_INT 25
56631: PUSH
56632: EMPTY
56633: LIST
56634: LIST
56635: PUSH
56636: EMPTY
56637: LIST
56638: LIST
56639: PPUSH
56640: CALL_OW 69
56644: ST_TO_ADDR
// end ;
56645: LD_VAR 0 2
56649: RET
// export function Shuffle ( array ) ; var i , index ; begin
56650: LD_INT 0
56652: PPUSH
56653: PPUSH
56654: PPUSH
// result := [ ] ;
56655: LD_ADDR_VAR 0 2
56659: PUSH
56660: EMPTY
56661: ST_TO_ADDR
// if not array then
56662: LD_VAR 0 1
56666: NOT
56667: IFFALSE 56671
// exit ;
56669: GO 56770
// Randomize ;
56671: CALL_OW 10
// for i = array downto 1 do
56675: LD_ADDR_VAR 0 3
56679: PUSH
56680: DOUBLE
56681: LD_VAR 0 1
56685: INC
56686: ST_TO_ADDR
56687: LD_INT 1
56689: PUSH
56690: FOR_DOWNTO
56691: IFFALSE 56768
// begin index := rand ( 1 , array ) ;
56693: LD_ADDR_VAR 0 4
56697: PUSH
56698: LD_INT 1
56700: PPUSH
56701: LD_VAR 0 1
56705: PPUSH
56706: CALL_OW 12
56710: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
56711: LD_ADDR_VAR 0 2
56715: PUSH
56716: LD_VAR 0 2
56720: PPUSH
56721: LD_VAR 0 2
56725: PUSH
56726: LD_INT 1
56728: PLUS
56729: PPUSH
56730: LD_VAR 0 1
56734: PUSH
56735: LD_VAR 0 4
56739: ARRAY
56740: PPUSH
56741: CALL_OW 2
56745: ST_TO_ADDR
// array := Delete ( array , index ) ;
56746: LD_ADDR_VAR 0 1
56750: PUSH
56751: LD_VAR 0 1
56755: PPUSH
56756: LD_VAR 0 4
56760: PPUSH
56761: CALL_OW 3
56765: ST_TO_ADDR
// end ;
56766: GO 56690
56768: POP
56769: POP
// end ;
56770: LD_VAR 0 2
56774: RET
// export function GetBaseMaterials ( base ) ; begin
56775: LD_INT 0
56777: PPUSH
// result := [ 0 , 0 , 0 ] ;
56778: LD_ADDR_VAR 0 2
56782: PUSH
56783: LD_INT 0
56785: PUSH
56786: LD_INT 0
56788: PUSH
56789: LD_INT 0
56791: PUSH
56792: EMPTY
56793: LIST
56794: LIST
56795: LIST
56796: ST_TO_ADDR
// if not base then
56797: LD_VAR 0 1
56801: NOT
56802: IFFALSE 56806
// exit ;
56804: GO 56855
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
56806: LD_ADDR_VAR 0 2
56810: PUSH
56811: LD_VAR 0 1
56815: PPUSH
56816: LD_INT 1
56818: PPUSH
56819: CALL_OW 275
56823: PUSH
56824: LD_VAR 0 1
56828: PPUSH
56829: LD_INT 2
56831: PPUSH
56832: CALL_OW 275
56836: PUSH
56837: LD_VAR 0 1
56841: PPUSH
56842: LD_INT 3
56844: PPUSH
56845: CALL_OW 275
56849: PUSH
56850: EMPTY
56851: LIST
56852: LIST
56853: LIST
56854: ST_TO_ADDR
// end ;
56855: LD_VAR 0 2
56859: RET
// export function ShrinkArray ( array , size ) ; var i ; begin
56860: LD_INT 0
56862: PPUSH
56863: PPUSH
// result := array ;
56864: LD_ADDR_VAR 0 3
56868: PUSH
56869: LD_VAR 0 1
56873: ST_TO_ADDR
// if size >= result then
56874: LD_VAR 0 2
56878: PUSH
56879: LD_VAR 0 3
56883: GREATEREQUAL
56884: IFFALSE 56888
// exit ;
56886: GO 56938
// if size then
56888: LD_VAR 0 2
56892: IFFALSE 56938
// for i := array downto size do
56894: LD_ADDR_VAR 0 4
56898: PUSH
56899: DOUBLE
56900: LD_VAR 0 1
56904: INC
56905: ST_TO_ADDR
56906: LD_VAR 0 2
56910: PUSH
56911: FOR_DOWNTO
56912: IFFALSE 56936
// result := Delete ( result , result ) ;
56914: LD_ADDR_VAR 0 3
56918: PUSH
56919: LD_VAR 0 3
56923: PPUSH
56924: LD_VAR 0 3
56928: PPUSH
56929: CALL_OW 3
56933: ST_TO_ADDR
56934: GO 56911
56936: POP
56937: POP
// end ;
56938: LD_VAR 0 3
56942: RET
// export function ComExit ( unit ) ; var tmp ; begin
56943: LD_INT 0
56945: PPUSH
56946: PPUSH
// if not IsInUnit ( unit ) then
56947: LD_VAR 0 1
56951: PPUSH
56952: CALL_OW 310
56956: NOT
56957: IFFALSE 56961
// exit ;
56959: GO 57021
// tmp := IsInUnit ( unit ) ;
56961: LD_ADDR_VAR 0 3
56965: PUSH
56966: LD_VAR 0 1
56970: PPUSH
56971: CALL_OW 310
56975: ST_TO_ADDR
// if GetType ( tmp ) = unit_vehicle then
56976: LD_VAR 0 3
56980: PPUSH
56981: CALL_OW 247
56985: PUSH
56986: LD_INT 2
56988: EQUAL
56989: IFFALSE 57002
// ComExitVehicle ( unit ) else
56991: LD_VAR 0 1
56995: PPUSH
56996: CALL_OW 121
57000: GO 57011
// ComExitBuilding ( unit ) ;
57002: LD_VAR 0 1
57006: PPUSH
57007: CALL_OW 122
// result := tmp ;
57011: LD_ADDR_VAR 0 2
57015: PUSH
57016: LD_VAR 0 3
57020: ST_TO_ADDR
// end ;
57021: LD_VAR 0 2
57025: RET
// export function ComExitAll ( units ) ; var i ; begin
57026: LD_INT 0
57028: PPUSH
57029: PPUSH
// if not units then
57030: LD_VAR 0 1
57034: NOT
57035: IFFALSE 57039
// exit ;
57037: GO 57065
// for i in units do
57039: LD_ADDR_VAR 0 3
57043: PUSH
57044: LD_VAR 0 1
57048: PUSH
57049: FOR_IN
57050: IFFALSE 57063
// ComExit ( i ) ;
57052: LD_VAR 0 3
57056: PPUSH
57057: CALL 56943 0 1
57061: GO 57049
57063: POP
57064: POP
// end ;
57065: LD_VAR 0 2
57069: RET
// export function ResetHc ; begin
57070: LD_INT 0
57072: PPUSH
// InitHc ;
57073: CALL_OW 19
// hc_importance := 0 ;
57077: LD_ADDR_OWVAR 32
57081: PUSH
57082: LD_INT 0
57084: ST_TO_ADDR
// end ;
57085: LD_VAR 0 1
57089: RET
// export function PointBetweenXY ( x1 , y1 , x2 , y2 ) ; var _x , _y ; begin
57090: LD_INT 0
57092: PPUSH
57093: PPUSH
57094: PPUSH
// _x := ( x1 + x2 ) div 2 ;
57095: LD_ADDR_VAR 0 6
57099: PUSH
57100: LD_VAR 0 1
57104: PUSH
57105: LD_VAR 0 3
57109: PLUS
57110: PUSH
57111: LD_INT 2
57113: DIV
57114: ST_TO_ADDR
// if _x < 0 then
57115: LD_VAR 0 6
57119: PUSH
57120: LD_INT 0
57122: LESS
57123: IFFALSE 57140
// _x := _x * - 1 ;
57125: LD_ADDR_VAR 0 6
57129: PUSH
57130: LD_VAR 0 6
57134: PUSH
57135: LD_INT 1
57137: NEG
57138: MUL
57139: ST_TO_ADDR
// _y := ( y1 + y2 ) div 2 ;
57140: LD_ADDR_VAR 0 7
57144: PUSH
57145: LD_VAR 0 2
57149: PUSH
57150: LD_VAR 0 4
57154: PLUS
57155: PUSH
57156: LD_INT 2
57158: DIV
57159: ST_TO_ADDR
// if _y < 0 then
57160: LD_VAR 0 7
57164: PUSH
57165: LD_INT 0
57167: LESS
57168: IFFALSE 57185
// _y := _y * - 1 ;
57170: LD_ADDR_VAR 0 7
57174: PUSH
57175: LD_VAR 0 7
57179: PUSH
57180: LD_INT 1
57182: NEG
57183: MUL
57184: ST_TO_ADDR
// result := [ _x , _y ] ;
57185: LD_ADDR_VAR 0 5
57189: PUSH
57190: LD_VAR 0 6
57194: PUSH
57195: LD_VAR 0 7
57199: PUSH
57200: EMPTY
57201: LIST
57202: LIST
57203: ST_TO_ADDR
// end ;
57204: LD_VAR 0 5
57208: RET
// export function NotGoToAreaUnit ( unit , area , goAway ) ; var x , y , task ; begin
57209: LD_INT 0
57211: PPUSH
57212: PPUSH
57213: PPUSH
57214: PPUSH
// task := GetTaskList ( unit ) ;
57215: LD_ADDR_VAR 0 7
57219: PUSH
57220: LD_VAR 0 1
57224: PPUSH
57225: CALL_OW 437
57229: ST_TO_ADDR
// if not task and not IsInArea ( unit , area ) then
57230: LD_VAR 0 7
57234: NOT
57235: PUSH
57236: LD_VAR 0 1
57240: PPUSH
57241: LD_VAR 0 2
57245: PPUSH
57246: CALL_OW 308
57250: NOT
57251: AND
57252: IFFALSE 57256
// exit ;
57254: GO 57374
// if IsInArea ( unit , area ) then
57256: LD_VAR 0 1
57260: PPUSH
57261: LD_VAR 0 2
57265: PPUSH
57266: CALL_OW 308
57270: IFFALSE 57288
// begin ComMoveToArea ( unit , goAway ) ;
57272: LD_VAR 0 1
57276: PPUSH
57277: LD_VAR 0 3
57281: PPUSH
57282: CALL_OW 113
// exit ;
57286: GO 57374
// end ; if task [ 1 ] [ 1 ] <> M then
57288: LD_VAR 0 7
57292: PUSH
57293: LD_INT 1
57295: ARRAY
57296: PUSH
57297: LD_INT 1
57299: ARRAY
57300: PUSH
57301: LD_STRING M
57303: NONEQUAL
57304: IFFALSE 57308
// exit ;
57306: GO 57374
// x := task [ 1 ] [ 2 ] ;
57308: LD_ADDR_VAR 0 5
57312: PUSH
57313: LD_VAR 0 7
57317: PUSH
57318: LD_INT 1
57320: ARRAY
57321: PUSH
57322: LD_INT 2
57324: ARRAY
57325: ST_TO_ADDR
// y := task [ 1 ] [ 3 ] ;
57326: LD_ADDR_VAR 0 6
57330: PUSH
57331: LD_VAR 0 7
57335: PUSH
57336: LD_INT 1
57338: ARRAY
57339: PUSH
57340: LD_INT 3
57342: ARRAY
57343: ST_TO_ADDR
// if InArea ( x , y , area ) then
57344: LD_VAR 0 5
57348: PPUSH
57349: LD_VAR 0 6
57353: PPUSH
57354: LD_VAR 0 2
57358: PPUSH
57359: CALL_OW 309
57363: IFFALSE 57374
// ComStop ( unit ) ;
57365: LD_VAR 0 1
57369: PPUSH
57370: CALL_OW 141
// end ;
57374: LD_VAR 0 4
57378: RET
// export function Abs ( value ) ; begin
57379: LD_INT 0
57381: PPUSH
// result := value ;
57382: LD_ADDR_VAR 0 2
57386: PUSH
57387: LD_VAR 0 1
57391: ST_TO_ADDR
// if value < 0 then
57392: LD_VAR 0 1
57396: PUSH
57397: LD_INT 0
57399: LESS
57400: IFFALSE 57417
// result := value * - 1 ;
57402: LD_ADDR_VAR 0 2
57406: PUSH
57407: LD_VAR 0 1
57411: PUSH
57412: LD_INT 1
57414: NEG
57415: MUL
57416: ST_TO_ADDR
// end ;
57417: LD_VAR 0 2
57421: RET
// export function ComMoveToNearbyEntrance ( unit , building ) ; var x , _x , y , _y , d , r , i ; begin
57422: LD_INT 0
57424: PPUSH
57425: PPUSH
57426: PPUSH
57427: PPUSH
57428: PPUSH
57429: PPUSH
57430: PPUSH
57431: PPUSH
// if not unit or not building then
57432: LD_VAR 0 1
57436: NOT
57437: PUSH
57438: LD_VAR 0 2
57442: NOT
57443: OR
57444: IFFALSE 57448
// exit ;
57446: GO 57674
// x := GetX ( building ) ;
57448: LD_ADDR_VAR 0 4
57452: PUSH
57453: LD_VAR 0 2
57457: PPUSH
57458: CALL_OW 250
57462: ST_TO_ADDR
// y := GetY ( building ) ;
57463: LD_ADDR_VAR 0 6
57467: PUSH
57468: LD_VAR 0 2
57472: PPUSH
57473: CALL_OW 251
57477: ST_TO_ADDR
// d := GetDir ( building ) ;
57478: LD_ADDR_VAR 0 8
57482: PUSH
57483: LD_VAR 0 2
57487: PPUSH
57488: CALL_OW 254
57492: ST_TO_ADDR
// r := 4 ;
57493: LD_ADDR_VAR 0 9
57497: PUSH
57498: LD_INT 4
57500: ST_TO_ADDR
// for i := 1 to 5 do
57501: LD_ADDR_VAR 0 10
57505: PUSH
57506: DOUBLE
57507: LD_INT 1
57509: DEC
57510: ST_TO_ADDR
57511: LD_INT 5
57513: PUSH
57514: FOR_TO
57515: IFFALSE 57672
// begin _x := ShiftX ( x , d , r + i ) ;
57517: LD_ADDR_VAR 0 5
57521: PUSH
57522: LD_VAR 0 4
57526: PPUSH
57527: LD_VAR 0 8
57531: PPUSH
57532: LD_VAR 0 9
57536: PUSH
57537: LD_VAR 0 10
57541: PLUS
57542: PPUSH
57543: CALL_OW 272
57547: ST_TO_ADDR
// _y := ShiftY ( y , d , r + i ) ;
57548: LD_ADDR_VAR 0 7
57552: PUSH
57553: LD_VAR 0 6
57557: PPUSH
57558: LD_VAR 0 8
57562: PPUSH
57563: LD_VAR 0 9
57567: PUSH
57568: LD_VAR 0 10
57572: PLUS
57573: PPUSH
57574: CALL_OW 273
57578: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not GetType ( HexInfo ( _x , _y ) ) in [ unit_building , unit_vehicle ] then
57579: LD_VAR 0 5
57583: PPUSH
57584: LD_VAR 0 7
57588: PPUSH
57589: CALL_OW 488
57593: PUSH
57594: LD_VAR 0 5
57598: PPUSH
57599: LD_VAR 0 7
57603: PPUSH
57604: CALL_OW 428
57608: PPUSH
57609: CALL_OW 247
57613: PUSH
57614: LD_INT 3
57616: PUSH
57617: LD_INT 2
57619: PUSH
57620: EMPTY
57621: LIST
57622: LIST
57623: IN
57624: NOT
57625: AND
57626: IFFALSE 57670
// begin ComMoveXY ( unit , _x , _y ) ;
57628: LD_VAR 0 1
57632: PPUSH
57633: LD_VAR 0 5
57637: PPUSH
57638: LD_VAR 0 7
57642: PPUSH
57643: CALL_OW 111
// result := [ _x , _y ] ;
57647: LD_ADDR_VAR 0 3
57651: PUSH
57652: LD_VAR 0 5
57656: PUSH
57657: LD_VAR 0 7
57661: PUSH
57662: EMPTY
57663: LIST
57664: LIST
57665: ST_TO_ADDR
// exit ;
57666: POP
57667: POP
57668: GO 57674
// end ; end ;
57670: GO 57514
57672: POP
57673: POP
// end ;
57674: LD_VAR 0 3
57678: RET
// export function SideAttackedSide ( side1 , side2 ) ; var i , un ; begin
57679: LD_INT 0
57681: PPUSH
57682: PPUSH
57683: PPUSH
// result := 0 ;
57684: LD_ADDR_VAR 0 3
57688: PUSH
57689: LD_INT 0
57691: ST_TO_ADDR
// if side1 < 0 or side1 > 8 or side2 < 0 or side2 > 8 then
57692: LD_VAR 0 1
57696: PUSH
57697: LD_INT 0
57699: LESS
57700: PUSH
57701: LD_VAR 0 1
57705: PUSH
57706: LD_INT 8
57708: GREATER
57709: OR
57710: PUSH
57711: LD_VAR 0 2
57715: PUSH
57716: LD_INT 0
57718: LESS
57719: OR
57720: PUSH
57721: LD_VAR 0 2
57725: PUSH
57726: LD_INT 8
57728: GREATER
57729: OR
57730: IFFALSE 57734
// exit ;
57732: GO 57809
// for i in FilterAllUnits ( [ f_side , side2 ] ) do
57734: LD_ADDR_VAR 0 4
57738: PUSH
57739: LD_INT 22
57741: PUSH
57742: LD_VAR 0 2
57746: PUSH
57747: EMPTY
57748: LIST
57749: LIST
57750: PPUSH
57751: CALL_OW 69
57755: PUSH
57756: FOR_IN
57757: IFFALSE 57807
// begin un := UnitShoot ( i ) ;
57759: LD_ADDR_VAR 0 5
57763: PUSH
57764: LD_VAR 0 4
57768: PPUSH
57769: CALL_OW 504
57773: ST_TO_ADDR
// if GetSide ( un ) = side1 then
57774: LD_VAR 0 5
57778: PPUSH
57779: CALL_OW 255
57783: PUSH
57784: LD_VAR 0 1
57788: EQUAL
57789: IFFALSE 57805
// begin result := un ;
57791: LD_ADDR_VAR 0 3
57795: PUSH
57796: LD_VAR 0 5
57800: ST_TO_ADDR
// exit ;
57801: POP
57802: POP
57803: GO 57809
// end ; end ;
57805: GO 57756
57807: POP
57808: POP
// end ;
57809: LD_VAR 0 3
57813: RET
// export function GetCargoBay ( units ) ; begin
57814: LD_INT 0
57816: PPUSH
// result := UnitFilter ( units , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ) ;
57817: LD_ADDR_VAR 0 2
57821: PUSH
57822: LD_VAR 0 1
57826: PPUSH
57827: LD_INT 2
57829: PUSH
57830: LD_INT 34
57832: PUSH
57833: LD_INT 12
57835: PUSH
57836: EMPTY
57837: LIST
57838: LIST
57839: PUSH
57840: LD_INT 34
57842: PUSH
57843: LD_INT 51
57845: PUSH
57846: EMPTY
57847: LIST
57848: LIST
57849: PUSH
57850: LD_INT 34
57852: PUSH
57853: LD_INT 32
57855: PUSH
57856: EMPTY
57857: LIST
57858: LIST
57859: PUSH
57860: LD_INT 34
57862: PUSH
57863: LD_INT 89
57865: PUSH
57866: EMPTY
57867: LIST
57868: LIST
57869: PUSH
57870: EMPTY
57871: LIST
57872: LIST
57873: LIST
57874: LIST
57875: LIST
57876: PPUSH
57877: CALL_OW 72
57881: ST_TO_ADDR
// end ;
57882: LD_VAR 0 2
57886: RET
// export function Negate ( value ) ; begin
57887: LD_INT 0
57889: PPUSH
// result := not value ;
57890: LD_ADDR_VAR 0 2
57894: PUSH
57895: LD_VAR 0 1
57899: NOT
57900: ST_TO_ADDR
// end ;
57901: LD_VAR 0 2
57905: RET
// export function Inc ( value ) ; begin
57906: LD_INT 0
57908: PPUSH
// result := value + 1 ;
57909: LD_ADDR_VAR 0 2
57913: PUSH
57914: LD_VAR 0 1
57918: PUSH
57919: LD_INT 1
57921: PLUS
57922: ST_TO_ADDR
// end ;
57923: LD_VAR 0 2
57927: RET
// export function Dec ( value ) ; begin
57928: LD_INT 0
57930: PPUSH
// result := value - 1 ;
57931: LD_ADDR_VAR 0 2
57935: PUSH
57936: LD_VAR 0 1
57940: PUSH
57941: LD_INT 1
57943: MINUS
57944: ST_TO_ADDR
// end ;
57945: LD_VAR 0 2
57949: RET
// export function GetDirFromHex ( x1 , y1 , x2 , y2 ) ; var i , _x , _y , tmp , distance , centerDist , centerPoint ; begin
57950: LD_INT 0
57952: PPUSH
57953: PPUSH
57954: PPUSH
57955: PPUSH
57956: PPUSH
57957: PPUSH
57958: PPUSH
57959: PPUSH
// if not ValidHex ( x1 , y1 ) or not ValidHex ( x2 , y2 ) then
57960: LD_VAR 0 1
57964: PPUSH
57965: LD_VAR 0 2
57969: PPUSH
57970: CALL_OW 488
57974: NOT
57975: PUSH
57976: LD_VAR 0 3
57980: PPUSH
57981: LD_VAR 0 4
57985: PPUSH
57986: CALL_OW 488
57990: NOT
57991: OR
57992: IFFALSE 58005
// begin result := - 1 ;
57994: LD_ADDR_VAR 0 5
57998: PUSH
57999: LD_INT 1
58001: NEG
58002: ST_TO_ADDR
// exit ;
58003: GO 58240
// end ; centerPoint := PointBetweenXY ( x1 , y1 , x2 , y2 ) ;
58005: LD_ADDR_VAR 0 12
58009: PUSH
58010: LD_VAR 0 1
58014: PPUSH
58015: LD_VAR 0 2
58019: PPUSH
58020: LD_VAR 0 3
58024: PPUSH
58025: LD_VAR 0 4
58029: PPUSH
58030: CALL 57090 0 4
58034: ST_TO_ADDR
// centerDist := GetDistXY ( x1 , y1 , centerPoint [ 1 ] , centerPoint [ 2 ] ) ;
58035: LD_ADDR_VAR 0 11
58039: PUSH
58040: LD_VAR 0 1
58044: PPUSH
58045: LD_VAR 0 2
58049: PPUSH
58050: LD_VAR 0 12
58054: PUSH
58055: LD_INT 1
58057: ARRAY
58058: PPUSH
58059: LD_VAR 0 12
58063: PUSH
58064: LD_INT 2
58066: ARRAY
58067: PPUSH
58068: CALL_OW 298
58072: ST_TO_ADDR
// distance := 9999 ;
58073: LD_ADDR_VAR 0 10
58077: PUSH
58078: LD_INT 9999
58080: ST_TO_ADDR
// for i := 0 to 5 do
58081: LD_ADDR_VAR 0 6
58085: PUSH
58086: DOUBLE
58087: LD_INT 0
58089: DEC
58090: ST_TO_ADDR
58091: LD_INT 5
58093: PUSH
58094: FOR_TO
58095: IFFALSE 58238
// begin _x := ShiftX ( x1 , i , centerDist ) ;
58097: LD_ADDR_VAR 0 7
58101: PUSH
58102: LD_VAR 0 1
58106: PPUSH
58107: LD_VAR 0 6
58111: PPUSH
58112: LD_VAR 0 11
58116: PPUSH
58117: CALL_OW 272
58121: ST_TO_ADDR
// _y := ShiftY ( y1 , i , centerDist ) ;
58122: LD_ADDR_VAR 0 8
58126: PUSH
58127: LD_VAR 0 2
58131: PPUSH
58132: LD_VAR 0 6
58136: PPUSH
58137: LD_VAR 0 11
58141: PPUSH
58142: CALL_OW 273
58146: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
58147: LD_VAR 0 7
58151: PPUSH
58152: LD_VAR 0 8
58156: PPUSH
58157: CALL_OW 488
58161: NOT
58162: IFFALSE 58166
// continue ;
58164: GO 58094
// tmp := GetDistXY ( centerPoint [ 1 ] , centerPoint [ 2 ] , _x , _y ) ;
58166: LD_ADDR_VAR 0 9
58170: PUSH
58171: LD_VAR 0 12
58175: PUSH
58176: LD_INT 1
58178: ARRAY
58179: PPUSH
58180: LD_VAR 0 12
58184: PUSH
58185: LD_INT 2
58187: ARRAY
58188: PPUSH
58189: LD_VAR 0 7
58193: PPUSH
58194: LD_VAR 0 8
58198: PPUSH
58199: CALL_OW 298
58203: ST_TO_ADDR
// if tmp < distance then
58204: LD_VAR 0 9
58208: PUSH
58209: LD_VAR 0 10
58213: LESS
58214: IFFALSE 58236
// begin result := i ;
58216: LD_ADDR_VAR 0 5
58220: PUSH
58221: LD_VAR 0 6
58225: ST_TO_ADDR
// distance := tmp ;
58226: LD_ADDR_VAR 0 10
58230: PUSH
58231: LD_VAR 0 9
58235: ST_TO_ADDR
// end ; end ;
58236: GO 58094
58238: POP
58239: POP
// end ;
58240: LD_VAR 0 5
58244: RET
// export function ComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
58245: LD_INT 0
58247: PPUSH
58248: PPUSH
// if not driver or not IsInUnit ( driver ) then
58249: LD_VAR 0 1
58253: NOT
58254: PUSH
58255: LD_VAR 0 1
58259: PPUSH
58260: CALL_OW 310
58264: NOT
58265: OR
58266: IFFALSE 58270
// exit ;
58268: GO 58360
// vehicle := IsInUnit ( driver ) ;
58270: LD_ADDR_VAR 0 3
58274: PUSH
58275: LD_VAR 0 1
58279: PPUSH
58280: CALL_OW 310
58284: ST_TO_ADDR
// SetTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
58285: LD_VAR 0 1
58289: PPUSH
58290: LD_STRING \
58292: PUSH
58293: LD_INT 0
58295: PUSH
58296: LD_INT 0
58298: PUSH
58299: LD_INT 0
58301: PUSH
58302: LD_INT 0
58304: PUSH
58305: LD_INT 0
58307: PUSH
58308: LD_INT 0
58310: PUSH
58311: EMPTY
58312: LIST
58313: LIST
58314: LIST
58315: LIST
58316: LIST
58317: LIST
58318: LIST
58319: PUSH
58320: LD_STRING E
58322: PUSH
58323: LD_INT 0
58325: PUSH
58326: LD_INT 0
58328: PUSH
58329: LD_VAR 0 3
58333: PUSH
58334: LD_INT 0
58336: PUSH
58337: LD_INT 0
58339: PUSH
58340: LD_INT 0
58342: PUSH
58343: EMPTY
58344: LIST
58345: LIST
58346: LIST
58347: LIST
58348: LIST
58349: LIST
58350: LIST
58351: PUSH
58352: EMPTY
58353: LIST
58354: LIST
58355: PPUSH
58356: CALL_OW 446
// end ;
58360: LD_VAR 0 2
58364: RET
// export function AddComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
58365: LD_INT 0
58367: PPUSH
58368: PPUSH
// if not driver or not IsInUnit ( driver ) then
58369: LD_VAR 0 1
58373: NOT
58374: PUSH
58375: LD_VAR 0 1
58379: PPUSH
58380: CALL_OW 310
58384: NOT
58385: OR
58386: IFFALSE 58390
// exit ;
58388: GO 58480
// vehicle := IsInUnit ( driver ) ;
58390: LD_ADDR_VAR 0 3
58394: PUSH
58395: LD_VAR 0 1
58399: PPUSH
58400: CALL_OW 310
58404: ST_TO_ADDR
// AddTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
58405: LD_VAR 0 1
58409: PPUSH
58410: LD_STRING \
58412: PUSH
58413: LD_INT 0
58415: PUSH
58416: LD_INT 0
58418: PUSH
58419: LD_INT 0
58421: PUSH
58422: LD_INT 0
58424: PUSH
58425: LD_INT 0
58427: PUSH
58428: LD_INT 0
58430: PUSH
58431: EMPTY
58432: LIST
58433: LIST
58434: LIST
58435: LIST
58436: LIST
58437: LIST
58438: LIST
58439: PUSH
58440: LD_STRING E
58442: PUSH
58443: LD_INT 0
58445: PUSH
58446: LD_INT 0
58448: PUSH
58449: LD_VAR 0 3
58453: PUSH
58454: LD_INT 0
58456: PUSH
58457: LD_INT 0
58459: PUSH
58460: LD_INT 0
58462: PUSH
58463: EMPTY
58464: LIST
58465: LIST
58466: LIST
58467: LIST
58468: LIST
58469: LIST
58470: LIST
58471: PUSH
58472: EMPTY
58473: LIST
58474: LIST
58475: PPUSH
58476: CALL_OW 447
// end ;
58480: LD_VAR 0 2
58484: RET
// export function SortByHealth ( units , asc ) ; var i , tmp ; begin
58485: LD_INT 0
58487: PPUSH
58488: PPUSH
58489: PPUSH
// tmp := [ ] ;
58490: LD_ADDR_VAR 0 5
58494: PUSH
58495: EMPTY
58496: ST_TO_ADDR
// for i in units do
58497: LD_ADDR_VAR 0 4
58501: PUSH
58502: LD_VAR 0 1
58506: PUSH
58507: FOR_IN
58508: IFFALSE 58546
// tmp := Insert ( tmp , tmp + 1 , GetLives ( i ) ) ;
58510: LD_ADDR_VAR 0 5
58514: PUSH
58515: LD_VAR 0 5
58519: PPUSH
58520: LD_VAR 0 5
58524: PUSH
58525: LD_INT 1
58527: PLUS
58528: PPUSH
58529: LD_VAR 0 4
58533: PPUSH
58534: CALL_OW 256
58538: PPUSH
58539: CALL_OW 2
58543: ST_TO_ADDR
58544: GO 58507
58546: POP
58547: POP
// if not tmp then
58548: LD_VAR 0 5
58552: NOT
58553: IFFALSE 58557
// exit ;
58555: GO 58605
// if asc then
58557: LD_VAR 0 2
58561: IFFALSE 58585
// result := SortListByListAsc ( units , tmp ) else
58563: LD_ADDR_VAR 0 3
58567: PUSH
58568: LD_VAR 0 1
58572: PPUSH
58573: LD_VAR 0 5
58577: PPUSH
58578: CALL_OW 76
58582: ST_TO_ADDR
58583: GO 58605
// result := SortListByListDesc ( units , tmp ) ;
58585: LD_ADDR_VAR 0 3
58589: PUSH
58590: LD_VAR 0 1
58594: PPUSH
58595: LD_VAR 0 5
58599: PPUSH
58600: CALL_OW 77
58604: ST_TO_ADDR
// end ;
58605: LD_VAR 0 3
58609: RET
// export function WantToRepairVehicle ( mech , vehicle ) ; var task ; begin
58610: LD_INT 0
58612: PPUSH
58613: PPUSH
// task := GetTaskList ( mech ) ;
58614: LD_ADDR_VAR 0 4
58618: PUSH
58619: LD_VAR 0 1
58623: PPUSH
58624: CALL_OW 437
58628: ST_TO_ADDR
// if not task then
58629: LD_VAR 0 4
58633: NOT
58634: IFFALSE 58638
// exit ;
58636: GO 58680
// result := task [ 1 ] [ 1 ] = r and task [ 1 ] [ 4 ] = vehicle ;
58638: LD_ADDR_VAR 0 3
58642: PUSH
58643: LD_VAR 0 4
58647: PUSH
58648: LD_INT 1
58650: ARRAY
58651: PUSH
58652: LD_INT 1
58654: ARRAY
58655: PUSH
58656: LD_STRING r
58658: EQUAL
58659: PUSH
58660: LD_VAR 0 4
58664: PUSH
58665: LD_INT 1
58667: ARRAY
58668: PUSH
58669: LD_INT 4
58671: ARRAY
58672: PUSH
58673: LD_VAR 0 2
58677: EQUAL
58678: AND
58679: ST_TO_ADDR
// end ;
58680: LD_VAR 0 3
58684: RET
// export function PlaceUnitXYD ( unit , x , y , d , mode ) ; begin
58685: LD_INT 0
58687: PPUSH
// SetDir ( unit , d ) ;
58688: LD_VAR 0 1
58692: PPUSH
58693: LD_VAR 0 4
58697: PPUSH
58698: CALL_OW 233
// PlaceUnitXY ( unit , x , y , mode ) ;
58702: LD_VAR 0 1
58706: PPUSH
58707: LD_VAR 0 2
58711: PPUSH
58712: LD_VAR 0 3
58716: PPUSH
58717: LD_VAR 0 5
58721: PPUSH
58722: CALL_OW 48
// end ;
58726: LD_VAR 0 6
58730: RET
// export function ToNaturalNumber ( number ) ; begin
58731: LD_INT 0
58733: PPUSH
// result := number div 1 ;
58734: LD_ADDR_VAR 0 2
58738: PUSH
58739: LD_VAR 0 1
58743: PUSH
58744: LD_INT 1
58746: DIV
58747: ST_TO_ADDR
// if number < 0 then
58748: LD_VAR 0 1
58752: PUSH
58753: LD_INT 0
58755: LESS
58756: IFFALSE 58766
// result := 0 ;
58758: LD_ADDR_VAR 0 2
58762: PUSH
58763: LD_INT 0
58765: ST_TO_ADDR
// end ;
58766: LD_VAR 0 2
58770: RET
// export function SortByClass ( units , class ) ; var un ; begin
58771: LD_INT 0
58773: PPUSH
58774: PPUSH
// if not units or not class then
58775: LD_VAR 0 1
58779: NOT
58780: PUSH
58781: LD_VAR 0 2
58785: NOT
58786: OR
58787: IFFALSE 58791
// exit ;
58789: GO 58886
// result := [ ] ;
58791: LD_ADDR_VAR 0 3
58795: PUSH
58796: EMPTY
58797: ST_TO_ADDR
// for un in units do
58798: LD_ADDR_VAR 0 4
58802: PUSH
58803: LD_VAR 0 1
58807: PUSH
58808: FOR_IN
58809: IFFALSE 58884
// if GetClass ( un ) = class then
58811: LD_VAR 0 4
58815: PPUSH
58816: CALL_OW 257
58820: PUSH
58821: LD_VAR 0 2
58825: EQUAL
58826: IFFALSE 58853
// result := Insert ( result , 1 , un ) else
58828: LD_ADDR_VAR 0 3
58832: PUSH
58833: LD_VAR 0 3
58837: PPUSH
58838: LD_INT 1
58840: PPUSH
58841: LD_VAR 0 4
58845: PPUSH
58846: CALL_OW 2
58850: ST_TO_ADDR
58851: GO 58882
// result := Replace ( result , result + 1 , un ) ;
58853: LD_ADDR_VAR 0 3
58857: PUSH
58858: LD_VAR 0 3
58862: PPUSH
58863: LD_VAR 0 3
58867: PUSH
58868: LD_INT 1
58870: PLUS
58871: PPUSH
58872: LD_VAR 0 4
58876: PPUSH
58877: CALL_OW 1
58881: ST_TO_ADDR
58882: GO 58808
58884: POP
58885: POP
// end ;
58886: LD_VAR 0 3
58890: RET
// export function GetCratesNearbyXY ( x , y , r ) ; var _x , _y , min_y , min_x , max_x , max_y ; begin
58891: LD_INT 0
58893: PPUSH
58894: PPUSH
58895: PPUSH
58896: PPUSH
58897: PPUSH
58898: PPUSH
58899: PPUSH
// result := [ ] ;
58900: LD_ADDR_VAR 0 4
58904: PUSH
58905: EMPTY
58906: ST_TO_ADDR
// if x - r < 0 then
58907: LD_VAR 0 1
58911: PUSH
58912: LD_VAR 0 3
58916: MINUS
58917: PUSH
58918: LD_INT 0
58920: LESS
58921: IFFALSE 58933
// min_x := 0 else
58923: LD_ADDR_VAR 0 8
58927: PUSH
58928: LD_INT 0
58930: ST_TO_ADDR
58931: GO 58949
// min_x := x - r ;
58933: LD_ADDR_VAR 0 8
58937: PUSH
58938: LD_VAR 0 1
58942: PUSH
58943: LD_VAR 0 3
58947: MINUS
58948: ST_TO_ADDR
// if y - r < 0 then
58949: LD_VAR 0 2
58953: PUSH
58954: LD_VAR 0 3
58958: MINUS
58959: PUSH
58960: LD_INT 0
58962: LESS
58963: IFFALSE 58975
// min_y := 0 else
58965: LD_ADDR_VAR 0 7
58969: PUSH
58970: LD_INT 0
58972: ST_TO_ADDR
58973: GO 58991
// min_y := y - r ;
58975: LD_ADDR_VAR 0 7
58979: PUSH
58980: LD_VAR 0 2
58984: PUSH
58985: LD_VAR 0 3
58989: MINUS
58990: ST_TO_ADDR
// max_x := x + r ;
58991: LD_ADDR_VAR 0 9
58995: PUSH
58996: LD_VAR 0 1
59000: PUSH
59001: LD_VAR 0 3
59005: PLUS
59006: ST_TO_ADDR
// max_y := y + r ;
59007: LD_ADDR_VAR 0 10
59011: PUSH
59012: LD_VAR 0 2
59016: PUSH
59017: LD_VAR 0 3
59021: PLUS
59022: ST_TO_ADDR
// for _x = min_x to max_x do
59023: LD_ADDR_VAR 0 5
59027: PUSH
59028: DOUBLE
59029: LD_VAR 0 8
59033: DEC
59034: ST_TO_ADDR
59035: LD_VAR 0 9
59039: PUSH
59040: FOR_TO
59041: IFFALSE 59142
// for _y = min_y to max_y do
59043: LD_ADDR_VAR 0 6
59047: PUSH
59048: DOUBLE
59049: LD_VAR 0 7
59053: DEC
59054: ST_TO_ADDR
59055: LD_VAR 0 10
59059: PUSH
59060: FOR_TO
59061: IFFALSE 59138
// begin if not ValidHex ( _x , _y ) then
59063: LD_VAR 0 5
59067: PPUSH
59068: LD_VAR 0 6
59072: PPUSH
59073: CALL_OW 488
59077: NOT
59078: IFFALSE 59082
// continue ;
59080: GO 59060
// if GetResourceTypeXY ( _x , _y ) then
59082: LD_VAR 0 5
59086: PPUSH
59087: LD_VAR 0 6
59091: PPUSH
59092: CALL_OW 283
59096: IFFALSE 59136
// result := Replace ( result , result + 1 , [ _x , _y ] ) ;
59098: LD_ADDR_VAR 0 4
59102: PUSH
59103: LD_VAR 0 4
59107: PPUSH
59108: LD_VAR 0 4
59112: PUSH
59113: LD_INT 1
59115: PLUS
59116: PPUSH
59117: LD_VAR 0 5
59121: PUSH
59122: LD_VAR 0 6
59126: PUSH
59127: EMPTY
59128: LIST
59129: LIST
59130: PPUSH
59131: CALL_OW 1
59135: ST_TO_ADDR
// end ;
59136: GO 59060
59138: POP
59139: POP
59140: GO 59040
59142: POP
59143: POP
// end ;
59144: LD_VAR 0 4
59148: RET
// export function AgressiveMove ( units , path ) ; var i , enemy , nearEnemy , cr , side , tag , ignoreCratesWeapon ; begin
59149: LD_INT 0
59151: PPUSH
59152: PPUSH
59153: PPUSH
59154: PPUSH
59155: PPUSH
59156: PPUSH
59157: PPUSH
59158: PPUSH
// if not units then
59159: LD_VAR 0 1
59163: NOT
59164: IFFALSE 59168
// exit ;
59166: GO 59692
// result := UnitFilter ( units , [ f_ok ] ) ;
59168: LD_ADDR_VAR 0 3
59172: PUSH
59173: LD_VAR 0 1
59177: PPUSH
59178: LD_INT 50
59180: PUSH
59181: EMPTY
59182: LIST
59183: PPUSH
59184: CALL_OW 72
59188: ST_TO_ADDR
// side := GetSide ( units [ 1 ] ) ;
59189: LD_ADDR_VAR 0 8
59193: PUSH
59194: LD_VAR 0 1
59198: PUSH
59199: LD_INT 1
59201: ARRAY
59202: PPUSH
59203: CALL_OW 255
59207: ST_TO_ADDR
// ignoreCratesWeapon := [ ar_selfpropelled_bomb , ar_bio_bomb , ru_time_lapser ] ;
59208: LD_ADDR_VAR 0 10
59212: PUSH
59213: LD_INT 29
59215: PUSH
59216: LD_INT 91
59218: PUSH
59219: LD_INT 49
59221: PUSH
59222: EMPTY
59223: LIST
59224: LIST
59225: LIST
59226: ST_TO_ADDR
// if not result then
59227: LD_VAR 0 3
59231: NOT
59232: IFFALSE 59236
// exit ;
59234: GO 59692
// enemy := FilterAllUnits ( [ f_enemy , side ] ) ;
59236: LD_ADDR_VAR 0 5
59240: PUSH
59241: LD_INT 81
59243: PUSH
59244: LD_VAR 0 8
59248: PUSH
59249: EMPTY
59250: LIST
59251: LIST
59252: PPUSH
59253: CALL_OW 69
59257: ST_TO_ADDR
// for i in result do
59258: LD_ADDR_VAR 0 4
59262: PUSH
59263: LD_VAR 0 3
59267: PUSH
59268: FOR_IN
59269: IFFALSE 59690
// begin tag := GetTag ( i ) + 1 ;
59271: LD_ADDR_VAR 0 9
59275: PUSH
59276: LD_VAR 0 4
59280: PPUSH
59281: CALL_OW 110
59285: PUSH
59286: LD_INT 1
59288: PLUS
59289: ST_TO_ADDR
// cr := GetCratesNearbyXY ( GetX ( i ) , GetY ( i ) , 6 ) ;
59290: LD_ADDR_VAR 0 7
59294: PUSH
59295: LD_VAR 0 4
59299: PPUSH
59300: CALL_OW 250
59304: PPUSH
59305: LD_VAR 0 4
59309: PPUSH
59310: CALL_OW 251
59314: PPUSH
59315: LD_INT 6
59317: PPUSH
59318: CALL 58891 0 3
59322: ST_TO_ADDR
// if GetType ( i ) = unit_vehicle and cr and not GetWeapon ( i ) in ignoreCratesWeapon then
59323: LD_VAR 0 4
59327: PPUSH
59328: CALL_OW 247
59332: PUSH
59333: LD_INT 2
59335: EQUAL
59336: PUSH
59337: LD_VAR 0 7
59341: AND
59342: PUSH
59343: LD_VAR 0 4
59347: PPUSH
59348: CALL_OW 264
59352: PUSH
59353: LD_VAR 0 10
59357: IN
59358: NOT
59359: AND
59360: IFFALSE 59399
// ComAttackPlace ( i , cr [ 1 ] [ 1 ] , cr [ 1 ] [ 2 ] ) else
59362: LD_VAR 0 4
59366: PPUSH
59367: LD_VAR 0 7
59371: PUSH
59372: LD_INT 1
59374: ARRAY
59375: PUSH
59376: LD_INT 1
59378: ARRAY
59379: PPUSH
59380: LD_VAR 0 7
59384: PUSH
59385: LD_INT 1
59387: ARRAY
59388: PUSH
59389: LD_INT 2
59391: ARRAY
59392: PPUSH
59393: CALL_OW 116
59397: GO 59688
// if path > tag then
59399: LD_VAR 0 2
59403: PUSH
59404: LD_VAR 0 9
59408: GREATER
59409: IFFALSE 59617
// begin nearEnemy := UnitFilter ( enemy , [ f_dist , i , 8 ] ) ;
59411: LD_ADDR_VAR 0 6
59415: PUSH
59416: LD_VAR 0 5
59420: PPUSH
59421: LD_INT 91
59423: PUSH
59424: LD_VAR 0 4
59428: PUSH
59429: LD_INT 8
59431: PUSH
59432: EMPTY
59433: LIST
59434: LIST
59435: LIST
59436: PPUSH
59437: CALL_OW 72
59441: ST_TO_ADDR
// if nearEnemy then
59442: LD_VAR 0 6
59446: IFFALSE 59515
// begin if GetWeapon ( i ) = ru_time_lapser then
59448: LD_VAR 0 4
59452: PPUSH
59453: CALL_OW 264
59457: PUSH
59458: LD_INT 49
59460: EQUAL
59461: IFFALSE 59489
// ComMoveUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) else
59463: LD_VAR 0 4
59467: PPUSH
59468: LD_VAR 0 6
59472: PPUSH
59473: LD_VAR 0 4
59477: PPUSH
59478: CALL_OW 74
59482: PPUSH
59483: CALL_OW 112
59487: GO 59513
// ComAgressiveMoveToUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) ;
59489: LD_VAR 0 4
59493: PPUSH
59494: LD_VAR 0 6
59498: PPUSH
59499: LD_VAR 0 4
59503: PPUSH
59504: CALL_OW 74
59508: PPUSH
59509: CALL 60617 0 2
// end else
59513: GO 59615
// if GetDistUnitXY ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) > 6 then
59515: LD_VAR 0 4
59519: PPUSH
59520: LD_VAR 0 2
59524: PUSH
59525: LD_VAR 0 9
59529: ARRAY
59530: PUSH
59531: LD_INT 1
59533: ARRAY
59534: PPUSH
59535: LD_VAR 0 2
59539: PUSH
59540: LD_VAR 0 9
59544: ARRAY
59545: PUSH
59546: LD_INT 2
59548: ARRAY
59549: PPUSH
59550: CALL_OW 297
59554: PUSH
59555: LD_INT 6
59557: GREATER
59558: IFFALSE 59601
// ComAgressiveMove ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) else
59560: LD_VAR 0 4
59564: PPUSH
59565: LD_VAR 0 2
59569: PUSH
59570: LD_VAR 0 9
59574: ARRAY
59575: PUSH
59576: LD_INT 1
59578: ARRAY
59579: PPUSH
59580: LD_VAR 0 2
59584: PUSH
59585: LD_VAR 0 9
59589: ARRAY
59590: PUSH
59591: LD_INT 2
59593: ARRAY
59594: PPUSH
59595: CALL_OW 114
59599: GO 59615
// SetTag ( i , tag ) ;
59601: LD_VAR 0 4
59605: PPUSH
59606: LD_VAR 0 9
59610: PPUSH
59611: CALL_OW 109
// end else
59615: GO 59688
// if enemy then
59617: LD_VAR 0 5
59621: IFFALSE 59688
// begin if GetWeapon ( i ) = ru_time_lapser then
59623: LD_VAR 0 4
59627: PPUSH
59628: CALL_OW 264
59632: PUSH
59633: LD_INT 49
59635: EQUAL
59636: IFFALSE 59664
// ComMoveUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
59638: LD_VAR 0 4
59642: PPUSH
59643: LD_VAR 0 5
59647: PPUSH
59648: LD_VAR 0 4
59652: PPUSH
59653: CALL_OW 74
59657: PPUSH
59658: CALL_OW 112
59662: GO 59688
// ComAgressiveMoveToUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
59664: LD_VAR 0 4
59668: PPUSH
59669: LD_VAR 0 5
59673: PPUSH
59674: LD_VAR 0 4
59678: PPUSH
59679: CALL_OW 74
59683: PPUSH
59684: CALL 60617 0 2
// end ; end ;
59688: GO 59268
59690: POP
59691: POP
// end ;
59692: LD_VAR 0 3
59696: RET
// export function ComLookAtDir ( unit , direction ) ; var x , y ; begin
59697: LD_INT 0
59699: PPUSH
59700: PPUSH
59701: PPUSH
// if not unit or IsInUnit ( unit ) then
59702: LD_VAR 0 1
59706: NOT
59707: PUSH
59708: LD_VAR 0 1
59712: PPUSH
59713: CALL_OW 310
59717: OR
59718: IFFALSE 59722
// exit ;
59720: GO 59813
// x := ShiftX ( GetX ( unit ) , direction , 1 ) ;
59722: LD_ADDR_VAR 0 4
59726: PUSH
59727: LD_VAR 0 1
59731: PPUSH
59732: CALL_OW 250
59736: PPUSH
59737: LD_VAR 0 2
59741: PPUSH
59742: LD_INT 1
59744: PPUSH
59745: CALL_OW 272
59749: ST_TO_ADDR
// y := ShiftY ( GetY ( unit ) , direction , 1 ) ;
59750: LD_ADDR_VAR 0 5
59754: PUSH
59755: LD_VAR 0 1
59759: PPUSH
59760: CALL_OW 251
59764: PPUSH
59765: LD_VAR 0 2
59769: PPUSH
59770: LD_INT 1
59772: PPUSH
59773: CALL_OW 273
59777: ST_TO_ADDR
// if ValidHex ( x , y ) then
59778: LD_VAR 0 4
59782: PPUSH
59783: LD_VAR 0 5
59787: PPUSH
59788: CALL_OW 488
59792: IFFALSE 59813
// ComTurnXY ( unit , x , y ) ;
59794: LD_VAR 0 1
59798: PPUSH
59799: LD_VAR 0 4
59803: PPUSH
59804: LD_VAR 0 5
59808: PPUSH
59809: CALL_OW 118
// end ;
59813: LD_VAR 0 3
59817: RET
// export function SeeUnits ( side , units ) ; var i ; begin
59818: LD_INT 0
59820: PPUSH
59821: PPUSH
// result := false ;
59822: LD_ADDR_VAR 0 3
59826: PUSH
59827: LD_INT 0
59829: ST_TO_ADDR
// if not units then
59830: LD_VAR 0 2
59834: NOT
59835: IFFALSE 59839
// exit ;
59837: GO 59884
// for i in units do
59839: LD_ADDR_VAR 0 4
59843: PUSH
59844: LD_VAR 0 2
59848: PUSH
59849: FOR_IN
59850: IFFALSE 59882
// if See ( side , i ) then
59852: LD_VAR 0 1
59856: PPUSH
59857: LD_VAR 0 4
59861: PPUSH
59862: CALL_OW 292
59866: IFFALSE 59880
// begin result := true ;
59868: LD_ADDR_VAR 0 3
59872: PUSH
59873: LD_INT 1
59875: ST_TO_ADDR
// exit ;
59876: POP
59877: POP
59878: GO 59884
// end ;
59880: GO 59849
59882: POP
59883: POP
// end ;
59884: LD_VAR 0 3
59888: RET
// export function GetNearestPoint ( unit , points ) ; var i , dist , tmpDist ; begin
59889: LD_INT 0
59891: PPUSH
59892: PPUSH
59893: PPUSH
59894: PPUSH
// if not unit or not points then
59895: LD_VAR 0 1
59899: NOT
59900: PUSH
59901: LD_VAR 0 2
59905: NOT
59906: OR
59907: IFFALSE 59911
// exit ;
59909: GO 60001
// dist := 99999 ;
59911: LD_ADDR_VAR 0 5
59915: PUSH
59916: LD_INT 99999
59918: ST_TO_ADDR
// for i in points do
59919: LD_ADDR_VAR 0 4
59923: PUSH
59924: LD_VAR 0 2
59928: PUSH
59929: FOR_IN
59930: IFFALSE 59999
// begin tmpDist := GetDistUnitXY ( unit , i [ 1 ] , i [ 2 ] ) ;
59932: LD_ADDR_VAR 0 6
59936: PUSH
59937: LD_VAR 0 1
59941: PPUSH
59942: LD_VAR 0 4
59946: PUSH
59947: LD_INT 1
59949: ARRAY
59950: PPUSH
59951: LD_VAR 0 4
59955: PUSH
59956: LD_INT 2
59958: ARRAY
59959: PPUSH
59960: CALL_OW 297
59964: ST_TO_ADDR
// if tmpDist < dist then
59965: LD_VAR 0 6
59969: PUSH
59970: LD_VAR 0 5
59974: LESS
59975: IFFALSE 59997
// begin result := i ;
59977: LD_ADDR_VAR 0 3
59981: PUSH
59982: LD_VAR 0 4
59986: ST_TO_ADDR
// dist := tmpDist ;
59987: LD_ADDR_VAR 0 5
59991: PUSH
59992: LD_VAR 0 6
59996: ST_TO_ADDR
// end ; end ;
59997: GO 59929
59999: POP
60000: POP
// end ;
60001: LD_VAR 0 3
60005: RET
// export function CreateBehemoth ( side , x , y , d ) ; begin
60006: LD_INT 0
60008: PPUSH
// uc_side := side ;
60009: LD_ADDR_OWVAR 20
60013: PUSH
60014: LD_VAR 0 1
60018: ST_TO_ADDR
// uc_nation := 3 ;
60019: LD_ADDR_OWVAR 21
60023: PUSH
60024: LD_INT 3
60026: ST_TO_ADDR
// vc_chassis := 25 ;
60027: LD_ADDR_OWVAR 37
60031: PUSH
60032: LD_INT 25
60034: ST_TO_ADDR
// vc_engine := engine_siberite ;
60035: LD_ADDR_OWVAR 39
60039: PUSH
60040: LD_INT 3
60042: ST_TO_ADDR
// vc_control := control_computer ;
60043: LD_ADDR_OWVAR 38
60047: PUSH
60048: LD_INT 3
60050: ST_TO_ADDR
// vc_weapon := 59 ;
60051: LD_ADDR_OWVAR 40
60055: PUSH
60056: LD_INT 59
60058: ST_TO_ADDR
// result := CreateVehicle ;
60059: LD_ADDR_VAR 0 5
60063: PUSH
60064: CALL_OW 45
60068: ST_TO_ADDR
// SetDir ( result , d ) ;
60069: LD_VAR 0 5
60073: PPUSH
60074: LD_VAR 0 4
60078: PPUSH
60079: CALL_OW 233
// PlaceUnitXY ( result , x , y , false ) ;
60083: LD_VAR 0 5
60087: PPUSH
60088: LD_VAR 0 2
60092: PPUSH
60093: LD_VAR 0 3
60097: PPUSH
60098: LD_INT 0
60100: PPUSH
60101: CALL_OW 48
// end ;
60105: LD_VAR 0 5
60109: RET
// export function GetMultiCargo ( cargo ) ; var i , tmp ; begin
60110: LD_INT 0
60112: PPUSH
60113: PPUSH
60114: PPUSH
// result := [ 0 , 0 , 0 , 0 ] ;
60115: LD_ADDR_VAR 0 2
60119: PUSH
60120: LD_INT 0
60122: PUSH
60123: LD_INT 0
60125: PUSH
60126: LD_INT 0
60128: PUSH
60129: LD_INT 0
60131: PUSH
60132: EMPTY
60133: LIST
60134: LIST
60135: LIST
60136: LIST
60137: ST_TO_ADDR
// if not cargo or not GetWeapon ( cargo ) in [ us_cargo_bay , ru_cargo_bay , ar_cargo_bay , ru_big_cargo_bay ] then
60138: LD_VAR 0 1
60142: NOT
60143: PUSH
60144: LD_VAR 0 1
60148: PPUSH
60149: CALL_OW 264
60153: PUSH
60154: LD_INT 12
60156: PUSH
60157: LD_INT 51
60159: PUSH
60160: LD_INT 32
60162: PUSH
60163: LD_INT 89
60165: PUSH
60166: EMPTY
60167: LIST
60168: LIST
60169: LIST
60170: LIST
60171: IN
60172: NOT
60173: OR
60174: IFFALSE 60178
// exit ;
60176: GO 60276
// for i := 1 to 3 do
60178: LD_ADDR_VAR 0 3
60182: PUSH
60183: DOUBLE
60184: LD_INT 1
60186: DEC
60187: ST_TO_ADDR
60188: LD_INT 3
60190: PUSH
60191: FOR_TO
60192: IFFALSE 60274
// begin tmp := GetCargo ( cargo , i ) ;
60194: LD_ADDR_VAR 0 4
60198: PUSH
60199: LD_VAR 0 1
60203: PPUSH
60204: LD_VAR 0 3
60208: PPUSH
60209: CALL_OW 289
60213: ST_TO_ADDR
// result := Replace ( result , i , tmp ) ;
60214: LD_ADDR_VAR 0 2
60218: PUSH
60219: LD_VAR 0 2
60223: PPUSH
60224: LD_VAR 0 3
60228: PPUSH
60229: LD_VAR 0 4
60233: PPUSH
60234: CALL_OW 1
60238: ST_TO_ADDR
// result := Replace ( result , 4 , result [ 4 ] + tmp ) ;
60239: LD_ADDR_VAR 0 2
60243: PUSH
60244: LD_VAR 0 2
60248: PPUSH
60249: LD_INT 4
60251: PPUSH
60252: LD_VAR 0 2
60256: PUSH
60257: LD_INT 4
60259: ARRAY
60260: PUSH
60261: LD_VAR 0 4
60265: PLUS
60266: PPUSH
60267: CALL_OW 1
60271: ST_TO_ADDR
// end ;
60272: GO 60191
60274: POP
60275: POP
// end ;
60276: LD_VAR 0 2
60280: RET
// export function Length ( array ) ; begin
60281: LD_INT 0
60283: PPUSH
// result := array + 0 ;
60284: LD_ADDR_VAR 0 2
60288: PUSH
60289: LD_VAR 0 1
60293: PUSH
60294: LD_INT 0
60296: PLUS
60297: ST_TO_ADDR
// end ;
60298: LD_VAR 0 2
60302: RET
// export function PrepareArray ( array ) ; begin
60303: LD_INT 0
60305: PPUSH
// result := array diff 0 ;
60306: LD_ADDR_VAR 0 2
60310: PUSH
60311: LD_VAR 0 1
60315: PUSH
60316: LD_INT 0
60318: DIFF
60319: ST_TO_ADDR
// if not result [ 1 ] then
60320: LD_VAR 0 2
60324: PUSH
60325: LD_INT 1
60327: ARRAY
60328: NOT
60329: IFFALSE 60349
// result := Delete ( result , 1 ) ;
60331: LD_ADDR_VAR 0 2
60335: PUSH
60336: LD_VAR 0 2
60340: PPUSH
60341: LD_INT 1
60343: PPUSH
60344: CALL_OW 3
60348: ST_TO_ADDR
// end ;
60349: LD_VAR 0 2
60353: RET
// export function IsInSibRocketRange ( x , y , area ) ; var i , sibRocketRange , tmp ; begin
60354: LD_INT 0
60356: PPUSH
60357: PPUSH
60358: PPUSH
60359: PPUSH
// sibRocketRange := 25 ;
60360: LD_ADDR_VAR 0 6
60364: PUSH
60365: LD_INT 25
60367: ST_TO_ADDR
// result := false ;
60368: LD_ADDR_VAR 0 4
60372: PUSH
60373: LD_INT 0
60375: ST_TO_ADDR
// for i := 0 to 5 do
60376: LD_ADDR_VAR 0 5
60380: PUSH
60381: DOUBLE
60382: LD_INT 0
60384: DEC
60385: ST_TO_ADDR
60386: LD_INT 5
60388: PUSH
60389: FOR_TO
60390: IFFALSE 60457
// if InArea ( ShiftX ( x , i , sibRocketRange ) , ShiftY ( y , i , sibRocketRange ) , area ) then
60392: LD_VAR 0 1
60396: PPUSH
60397: LD_VAR 0 5
60401: PPUSH
60402: LD_VAR 0 6
60406: PPUSH
60407: CALL_OW 272
60411: PPUSH
60412: LD_VAR 0 2
60416: PPUSH
60417: LD_VAR 0 5
60421: PPUSH
60422: LD_VAR 0 6
60426: PPUSH
60427: CALL_OW 273
60431: PPUSH
60432: LD_VAR 0 3
60436: PPUSH
60437: CALL_OW 309
60441: IFFALSE 60455
// begin result := true ;
60443: LD_ADDR_VAR 0 4
60447: PUSH
60448: LD_INT 1
60450: ST_TO_ADDR
// exit ;
60451: POP
60452: POP
60453: GO 60459
// end ;
60455: GO 60389
60457: POP
60458: POP
// end ;
60459: LD_VAR 0 4
60463: RET
// export function SayRadioNoFaceNoName ( unit , dialog ) ; begin
60464: LD_INT 0
60466: PPUSH
// SayEX ( unit , dialog , false , false , true , false ) ;
60467: LD_VAR 0 1
60471: PPUSH
60472: LD_VAR 0 2
60476: PPUSH
60477: LD_INT 0
60479: PPUSH
60480: LD_INT 0
60482: PPUSH
60483: LD_INT 1
60485: PPUSH
60486: LD_INT 0
60488: PPUSH
60489: CALL_OW 587
// end ;
60493: LD_VAR 0 3
60497: RET
// export function CenterOnNow ( unit ) ; begin
60498: LD_INT 0
60500: PPUSH
// result := IsInUnit ( unit ) ;
60501: LD_ADDR_VAR 0 2
60505: PUSH
60506: LD_VAR 0 1
60510: PPUSH
60511: CALL_OW 310
60515: ST_TO_ADDR
// if not result then
60516: LD_VAR 0 2
60520: NOT
60521: IFFALSE 60533
// result := unit ;
60523: LD_ADDR_VAR 0 2
60527: PUSH
60528: LD_VAR 0 1
60532: ST_TO_ADDR
// CenterNowOnUnits ( unit ) ;
60533: LD_VAR 0 1
60537: PPUSH
60538: CALL_OW 87
// end ;
60542: LD_VAR 0 2
60546: RET
// export function ComMoveHex ( unit , hex ) ; begin
60547: LD_INT 0
60549: PPUSH
// if not hex then
60550: LD_VAR 0 2
60554: NOT
60555: IFFALSE 60559
// exit ;
60557: GO 60612
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) then
60559: LD_VAR 0 2
60563: PUSH
60564: LD_INT 1
60566: ARRAY
60567: PPUSH
60568: LD_VAR 0 2
60572: PUSH
60573: LD_INT 2
60575: ARRAY
60576: PPUSH
60577: CALL_OW 428
60581: IFFALSE 60585
// exit ;
60583: GO 60612
// ComMoveXY ( unit , hex [ 1 ] , hex [ 2 ] ) ;
60585: LD_VAR 0 1
60589: PPUSH
60590: LD_VAR 0 2
60594: PUSH
60595: LD_INT 1
60597: ARRAY
60598: PPUSH
60599: LD_VAR 0 2
60603: PUSH
60604: LD_INT 2
60606: ARRAY
60607: PPUSH
60608: CALL_OW 111
// end ;
60612: LD_VAR 0 3
60616: RET
// export function ComAgressiveMoveToUnit ( unit , enemy ) ; var x , y ; begin
60617: LD_INT 0
60619: PPUSH
60620: PPUSH
60621: PPUSH
// if not unit or not enemy then
60622: LD_VAR 0 1
60626: NOT
60627: PUSH
60628: LD_VAR 0 2
60632: NOT
60633: OR
60634: IFFALSE 60638
// exit ;
60636: GO 60762
// x := GetX ( enemy ) ;
60638: LD_ADDR_VAR 0 4
60642: PUSH
60643: LD_VAR 0 2
60647: PPUSH
60648: CALL_OW 250
60652: ST_TO_ADDR
// y := GetY ( enemy ) ;
60653: LD_ADDR_VAR 0 5
60657: PUSH
60658: LD_VAR 0 2
60662: PPUSH
60663: CALL_OW 251
60667: ST_TO_ADDR
// if ValidHex ( x , y ) then
60668: LD_VAR 0 4
60672: PPUSH
60673: LD_VAR 0 5
60677: PPUSH
60678: CALL_OW 488
60682: IFFALSE 60762
// if GetType ( enemy ) in [ unit_building , unit_vehicle ] and See ( GetSide ( unit ) , enemy ) then
60684: LD_VAR 0 2
60688: PPUSH
60689: CALL_OW 247
60693: PUSH
60694: LD_INT 3
60696: PUSH
60697: LD_INT 2
60699: PUSH
60700: EMPTY
60701: LIST
60702: LIST
60703: IN
60704: PUSH
60705: LD_VAR 0 1
60709: PPUSH
60710: CALL_OW 255
60714: PPUSH
60715: LD_VAR 0 2
60719: PPUSH
60720: CALL_OW 292
60724: AND
60725: IFFALSE 60743
// ComAttackUnit ( unit , enemy ) else
60727: LD_VAR 0 1
60731: PPUSH
60732: LD_VAR 0 2
60736: PPUSH
60737: CALL_OW 115
60741: GO 60762
// ComAgressiveMove ( unit , x , y ) ;
60743: LD_VAR 0 1
60747: PPUSH
60748: LD_VAR 0 4
60752: PPUSH
60753: LD_VAR 0 5
60757: PPUSH
60758: CALL_OW 114
// end ; end_of_file
60762: LD_VAR 0 3
60766: RET
// export function SOS_UnitDestroyed ( un ) ; var i , eff , side ; begin
60767: LD_INT 0
60769: PPUSH
60770: PPUSH
60771: PPUSH
60772: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
60773: LD_VAR 0 1
60777: PPUSH
60778: CALL_OW 264
60782: PUSH
60783: LD_INT 91
60785: EQUAL
60786: IFFALSE 60858
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
60788: LD_INT 68
60790: PPUSH
60791: LD_VAR 0 1
60795: PPUSH
60796: CALL_OW 255
60800: PPUSH
60801: CALL_OW 321
60805: PUSH
60806: LD_INT 2
60808: EQUAL
60809: IFFALSE 60821
// eff := 70 else
60811: LD_ADDR_VAR 0 4
60815: PUSH
60816: LD_INT 70
60818: ST_TO_ADDR
60819: GO 60829
// eff := 30 ;
60821: LD_ADDR_VAR 0 4
60825: PUSH
60826: LD_INT 30
60828: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
60829: LD_VAR 0 1
60833: PPUSH
60834: CALL_OW 250
60838: PPUSH
60839: LD_VAR 0 1
60843: PPUSH
60844: CALL_OW 251
60848: PPUSH
60849: LD_VAR 0 4
60853: PPUSH
60854: CALL_OW 495
// end ; end ;
60858: LD_VAR 0 2
60862: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
60863: LD_INT 0
60865: PPUSH
// end ;
60866: LD_VAR 0 4
60870: RET
// export function SOS_Command ( cmd ) ; begin
60871: LD_INT 0
60873: PPUSH
// end ;
60874: LD_VAR 0 2
60878: RET
// export function SOS_CommandUnitXY ( cmd , un , target , x , y ) ; begin
60879: LD_INT 0
60881: PPUSH
// end ;
60882: LD_VAR 0 6
60886: RET
// export function SOS_VehicleConstructed ( vehicle , factory ) ; var driver ; begin
60887: LD_INT 0
60889: PPUSH
60890: PPUSH
// if not vehicle or not factory then
60891: LD_VAR 0 1
60895: NOT
60896: PUSH
60897: LD_VAR 0 2
60901: NOT
60902: OR
60903: IFFALSE 60907
// exit ;
60905: GO 61138
// if factoryWaypoints >= factory then
60907: LD_EXP 156
60911: PUSH
60912: LD_VAR 0 2
60916: GREATEREQUAL
60917: IFFALSE 61138
// if factoryWaypoints [ factory ] then
60919: LD_EXP 156
60923: PUSH
60924: LD_VAR 0 2
60928: ARRAY
60929: IFFALSE 61138
// begin if GetControl ( vehicle ) = control_manual then
60931: LD_VAR 0 1
60935: PPUSH
60936: CALL_OW 263
60940: PUSH
60941: LD_INT 1
60943: EQUAL
60944: IFFALSE 61025
// begin driver := IsDrivenBy ( vehicle ) ;
60946: LD_ADDR_VAR 0 4
60950: PUSH
60951: LD_VAR 0 1
60955: PPUSH
60956: CALL_OW 311
60960: ST_TO_ADDR
// AddComMoveXY ( driver , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
60961: LD_VAR 0 4
60965: PPUSH
60966: LD_EXP 156
60970: PUSH
60971: LD_VAR 0 2
60975: ARRAY
60976: PUSH
60977: LD_INT 3
60979: ARRAY
60980: PPUSH
60981: LD_EXP 156
60985: PUSH
60986: LD_VAR 0 2
60990: ARRAY
60991: PUSH
60992: LD_INT 4
60994: ARRAY
60995: PPUSH
60996: CALL_OW 171
// AddComExitVehicle ( driver ) ;
61000: LD_VAR 0 4
61004: PPUSH
61005: CALL_OW 181
// AddComEnterUnit ( driver , factory ) ;
61009: LD_VAR 0 4
61013: PPUSH
61014: LD_VAR 0 2
61018: PPUSH
61019: CALL_OW 180
// end else
61023: GO 61138
// if GetControl ( vehicle ) = control_remote then
61025: LD_VAR 0 1
61029: PPUSH
61030: CALL_OW 263
61034: PUSH
61035: LD_INT 2
61037: EQUAL
61038: IFFALSE 61099
// begin wait ( 0 0$2 ) ;
61040: LD_INT 70
61042: PPUSH
61043: CALL_OW 67
// if Connect ( vehicle ) then
61047: LD_VAR 0 1
61051: PPUSH
61052: CALL 27164 0 1
61056: IFFALSE 61097
// AddComMoveXY ( vehicle , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
61058: LD_VAR 0 1
61062: PPUSH
61063: LD_EXP 156
61067: PUSH
61068: LD_VAR 0 2
61072: ARRAY
61073: PUSH
61074: LD_INT 3
61076: ARRAY
61077: PPUSH
61078: LD_EXP 156
61082: PUSH
61083: LD_VAR 0 2
61087: ARRAY
61088: PUSH
61089: LD_INT 4
61091: ARRAY
61092: PPUSH
61093: CALL_OW 171
// end else
61097: GO 61138
// AddComMoveXY ( vehicle , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
61099: LD_VAR 0 1
61103: PPUSH
61104: LD_EXP 156
61108: PUSH
61109: LD_VAR 0 2
61113: ARRAY
61114: PUSH
61115: LD_INT 3
61117: ARRAY
61118: PPUSH
61119: LD_EXP 156
61123: PUSH
61124: LD_VAR 0 2
61128: ARRAY
61129: PUSH
61130: LD_INT 4
61132: ARRAY
61133: PPUSH
61134: CALL_OW 171
// end ; end ;
61138: LD_VAR 0 3
61142: RET
// export function SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; begin
61143: LD_INT 0
61145: PPUSH
// if cmd = 250 and GetWeapon ( unit ) = ar_miner then
61146: LD_VAR 0 1
61150: PUSH
61151: LD_INT 250
61153: EQUAL
61154: PUSH
61155: LD_VAR 0 2
61159: PPUSH
61160: CALL_OW 264
61164: PUSH
61165: LD_INT 81
61167: EQUAL
61168: AND
61169: IFFALSE 61190
// MinerPlaceMine ( unit , x , y ) ;
61171: LD_VAR 0 2
61175: PPUSH
61176: LD_VAR 0 4
61180: PPUSH
61181: LD_VAR 0 5
61185: PPUSH
61186: CALL 63575 0 3
// if cmd = 251 and GetWeapon ( unit ) = ar_miner then
61190: LD_VAR 0 1
61194: PUSH
61195: LD_INT 251
61197: EQUAL
61198: PUSH
61199: LD_VAR 0 2
61203: PPUSH
61204: CALL_OW 264
61208: PUSH
61209: LD_INT 81
61211: EQUAL
61212: AND
61213: IFFALSE 61234
// MinerDetonateMine ( unit , x , y ) ;
61215: LD_VAR 0 2
61219: PPUSH
61220: LD_VAR 0 4
61224: PPUSH
61225: LD_VAR 0 5
61229: PPUSH
61230: CALL 63850 0 3
// if cmd = 252 and GetWeapon ( unit ) = ar_miner then
61234: LD_VAR 0 1
61238: PUSH
61239: LD_INT 252
61241: EQUAL
61242: PUSH
61243: LD_VAR 0 2
61247: PPUSH
61248: CALL_OW 264
61252: PUSH
61253: LD_INT 81
61255: EQUAL
61256: AND
61257: IFFALSE 61278
// MinerCreateMinefield ( unit , x , y ) ;
61259: LD_VAR 0 2
61263: PPUSH
61264: LD_VAR 0 4
61268: PPUSH
61269: LD_VAR 0 5
61273: PPUSH
61274: CALL 64267 0 3
// if cmd = 253 and GetClass ( unit ) = class_sniper then
61278: LD_VAR 0 1
61282: PUSH
61283: LD_INT 253
61285: EQUAL
61286: PUSH
61287: LD_VAR 0 2
61291: PPUSH
61292: CALL_OW 257
61296: PUSH
61297: LD_INT 5
61299: EQUAL
61300: AND
61301: IFFALSE 61322
// ComBinocular ( unit , x , y ) ;
61303: LD_VAR 0 2
61307: PPUSH
61308: LD_VAR 0 4
61312: PPUSH
61313: LD_VAR 0 5
61317: PPUSH
61318: CALL 64636 0 3
// if cmd = 254 and GetWeapon ( unit ) = us_hack and GetControl ( selectedUnit ) = control_computer then
61322: LD_VAR 0 1
61326: PUSH
61327: LD_INT 254
61329: EQUAL
61330: PUSH
61331: LD_VAR 0 2
61335: PPUSH
61336: CALL_OW 264
61340: PUSH
61341: LD_INT 99
61343: EQUAL
61344: AND
61345: PUSH
61346: LD_VAR 0 3
61350: PPUSH
61351: CALL_OW 263
61355: PUSH
61356: LD_INT 3
61358: EQUAL
61359: AND
61360: IFFALSE 61376
// HackDestroyVehicle ( unit , selectedUnit ) ;
61362: LD_VAR 0 2
61366: PPUSH
61367: LD_VAR 0 3
61371: PPUSH
61372: CALL 62939 0 2
// if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
61376: LD_VAR 0 1
61380: PUSH
61381: LD_INT 255
61383: EQUAL
61384: PUSH
61385: LD_VAR 0 2
61389: PPUSH
61390: CALL_OW 264
61394: PUSH
61395: LD_INT 14
61397: PUSH
61398: LD_INT 53
61400: PUSH
61401: EMPTY
61402: LIST
61403: LIST
61404: IN
61405: AND
61406: PUSH
61407: LD_VAR 0 4
61411: PPUSH
61412: LD_VAR 0 5
61416: PPUSH
61417: CALL_OW 488
61421: AND
61422: IFFALSE 61446
// CutTreeXYR ( unit , x , y , 12 ) ;
61424: LD_VAR 0 2
61428: PPUSH
61429: LD_VAR 0 4
61433: PPUSH
61434: LD_VAR 0 5
61438: PPUSH
61439: LD_INT 12
61441: PPUSH
61442: CALL 61509 0 4
// if cmd = 256 then
61446: LD_VAR 0 1
61450: PUSH
61451: LD_INT 256
61453: EQUAL
61454: IFFALSE 61475
// SetFactoryWaypoint ( unit , x , y ) ;
61456: LD_VAR 0 2
61460: PPUSH
61461: LD_VAR 0 4
61465: PPUSH
61466: LD_VAR 0 5
61470: PPUSH
61471: CALL 79547 0 3
// if cmd = 257 then
61475: LD_VAR 0 1
61479: PUSH
61480: LD_INT 257
61482: EQUAL
61483: IFFALSE 61504
// SetWarehouseGatheringPoint ( unit , x , y ) ;
61485: LD_VAR 0 2
61489: PPUSH
61490: LD_VAR 0 4
61494: PPUSH
61495: LD_VAR 0 5
61499: PPUSH
61500: CALL 79909 0 3
// end ;
61504: LD_VAR 0 6
61508: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
61509: LD_INT 0
61511: PPUSH
61512: PPUSH
61513: PPUSH
61514: PPUSH
61515: PPUSH
61516: PPUSH
61517: PPUSH
61518: PPUSH
61519: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
61520: LD_VAR 0 1
61524: NOT
61525: PUSH
61526: LD_VAR 0 2
61530: PPUSH
61531: LD_VAR 0 3
61535: PPUSH
61536: CALL_OW 488
61540: NOT
61541: OR
61542: PUSH
61543: LD_VAR 0 4
61547: NOT
61548: OR
61549: IFFALSE 61553
// exit ;
61551: GO 61893
// list := [ ] ;
61553: LD_ADDR_VAR 0 13
61557: PUSH
61558: EMPTY
61559: ST_TO_ADDR
// if x - r < 0 then
61560: LD_VAR 0 2
61564: PUSH
61565: LD_VAR 0 4
61569: MINUS
61570: PUSH
61571: LD_INT 0
61573: LESS
61574: IFFALSE 61586
// min_x := 0 else
61576: LD_ADDR_VAR 0 7
61580: PUSH
61581: LD_INT 0
61583: ST_TO_ADDR
61584: GO 61602
// min_x := x - r ;
61586: LD_ADDR_VAR 0 7
61590: PUSH
61591: LD_VAR 0 2
61595: PUSH
61596: LD_VAR 0 4
61600: MINUS
61601: ST_TO_ADDR
// if y - r < 0 then
61602: LD_VAR 0 3
61606: PUSH
61607: LD_VAR 0 4
61611: MINUS
61612: PUSH
61613: LD_INT 0
61615: LESS
61616: IFFALSE 61628
// min_y := 0 else
61618: LD_ADDR_VAR 0 8
61622: PUSH
61623: LD_INT 0
61625: ST_TO_ADDR
61626: GO 61644
// min_y := y - r ;
61628: LD_ADDR_VAR 0 8
61632: PUSH
61633: LD_VAR 0 3
61637: PUSH
61638: LD_VAR 0 4
61642: MINUS
61643: ST_TO_ADDR
// max_x := x + r ;
61644: LD_ADDR_VAR 0 9
61648: PUSH
61649: LD_VAR 0 2
61653: PUSH
61654: LD_VAR 0 4
61658: PLUS
61659: ST_TO_ADDR
// max_y := y + r ;
61660: LD_ADDR_VAR 0 10
61664: PUSH
61665: LD_VAR 0 3
61669: PUSH
61670: LD_VAR 0 4
61674: PLUS
61675: ST_TO_ADDR
// for _x = min_x to max_x do
61676: LD_ADDR_VAR 0 11
61680: PUSH
61681: DOUBLE
61682: LD_VAR 0 7
61686: DEC
61687: ST_TO_ADDR
61688: LD_VAR 0 9
61692: PUSH
61693: FOR_TO
61694: IFFALSE 61811
// for _y = min_y to max_y do
61696: LD_ADDR_VAR 0 12
61700: PUSH
61701: DOUBLE
61702: LD_VAR 0 8
61706: DEC
61707: ST_TO_ADDR
61708: LD_VAR 0 10
61712: PUSH
61713: FOR_TO
61714: IFFALSE 61807
// begin if not ValidHex ( _x , _y ) then
61716: LD_VAR 0 11
61720: PPUSH
61721: LD_VAR 0 12
61725: PPUSH
61726: CALL_OW 488
61730: NOT
61731: IFFALSE 61735
// continue ;
61733: GO 61713
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
61735: LD_VAR 0 11
61739: PPUSH
61740: LD_VAR 0 12
61744: PPUSH
61745: CALL_OW 351
61749: PUSH
61750: LD_VAR 0 11
61754: PPUSH
61755: LD_VAR 0 12
61759: PPUSH
61760: CALL_OW 554
61764: AND
61765: IFFALSE 61805
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
61767: LD_ADDR_VAR 0 13
61771: PUSH
61772: LD_VAR 0 13
61776: PPUSH
61777: LD_VAR 0 13
61781: PUSH
61782: LD_INT 1
61784: PLUS
61785: PPUSH
61786: LD_VAR 0 11
61790: PUSH
61791: LD_VAR 0 12
61795: PUSH
61796: EMPTY
61797: LIST
61798: LIST
61799: PPUSH
61800: CALL_OW 2
61804: ST_TO_ADDR
// end ;
61805: GO 61713
61807: POP
61808: POP
61809: GO 61693
61811: POP
61812: POP
// if not list then
61813: LD_VAR 0 13
61817: NOT
61818: IFFALSE 61822
// exit ;
61820: GO 61893
// for i in list do
61822: LD_ADDR_VAR 0 6
61826: PUSH
61827: LD_VAR 0 13
61831: PUSH
61832: FOR_IN
61833: IFFALSE 61891
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
61835: LD_VAR 0 1
61839: PPUSH
61840: LD_STRING M
61842: PUSH
61843: LD_VAR 0 6
61847: PUSH
61848: LD_INT 1
61850: ARRAY
61851: PUSH
61852: LD_VAR 0 6
61856: PUSH
61857: LD_INT 2
61859: ARRAY
61860: PUSH
61861: LD_INT 0
61863: PUSH
61864: LD_INT 0
61866: PUSH
61867: LD_INT 0
61869: PUSH
61870: LD_INT 0
61872: PUSH
61873: EMPTY
61874: LIST
61875: LIST
61876: LIST
61877: LIST
61878: LIST
61879: LIST
61880: LIST
61881: PUSH
61882: EMPTY
61883: LIST
61884: PPUSH
61885: CALL_OW 447
61889: GO 61832
61891: POP
61892: POP
// end ;
61893: LD_VAR 0 5
61897: RET
// export initHack , hackTanks , hackTanksCaptured , hackLimit , hackDist , hackCounter ; every 0 0$1 trigger not initHack do
61898: LD_EXP 87
61902: NOT
61903: IFFALSE 61953
61905: GO 61907
61907: DISABLE
// begin initHack := true ;
61908: LD_ADDR_EXP 87
61912: PUSH
61913: LD_INT 1
61915: ST_TO_ADDR
// hackTanks := [ ] ;
61916: LD_ADDR_EXP 88
61920: PUSH
61921: EMPTY
61922: ST_TO_ADDR
// hackTanksCaptured := [ ] ;
61923: LD_ADDR_EXP 89
61927: PUSH
61928: EMPTY
61929: ST_TO_ADDR
// hackLimit := 3 ;
61930: LD_ADDR_EXP 90
61934: PUSH
61935: LD_INT 3
61937: ST_TO_ADDR
// hackDist := 12 ;
61938: LD_ADDR_EXP 91
61942: PUSH
61943: LD_INT 12
61945: ST_TO_ADDR
// hackCounter := [ ] ;
61946: LD_ADDR_EXP 92
61950: PUSH
61951: EMPTY
61952: ST_TO_ADDR
// end ;
61953: END
// every 0 0$1 trigger initHack and FilterAllUnits ( [ f_weapon , us_hack ] ) do var i , tmp ;
61954: LD_EXP 87
61958: PUSH
61959: LD_INT 34
61961: PUSH
61962: LD_INT 99
61964: PUSH
61965: EMPTY
61966: LIST
61967: LIST
61968: PPUSH
61969: CALL_OW 69
61973: AND
61974: IFFALSE 62227
61976: GO 61978
61978: DISABLE
61979: LD_INT 0
61981: PPUSH
61982: PPUSH
// begin enable ;
61983: ENABLE
// for i in FilterAllUnits ( [ f_weapon , us_hack ] ) do
61984: LD_ADDR_VAR 0 1
61988: PUSH
61989: LD_INT 34
61991: PUSH
61992: LD_INT 99
61994: PUSH
61995: EMPTY
61996: LIST
61997: LIST
61998: PPUSH
61999: CALL_OW 69
62003: PUSH
62004: FOR_IN
62005: IFFALSE 62225
// begin if not i in hackTanks then
62007: LD_VAR 0 1
62011: PUSH
62012: LD_EXP 88
62016: IN
62017: NOT
62018: IFFALSE 62101
// begin hackTanks := Replace ( hackTanks , hackTanks + 1 , i ) ;
62020: LD_ADDR_EXP 88
62024: PUSH
62025: LD_EXP 88
62029: PPUSH
62030: LD_EXP 88
62034: PUSH
62035: LD_INT 1
62037: PLUS
62038: PPUSH
62039: LD_VAR 0 1
62043: PPUSH
62044: CALL_OW 1
62048: ST_TO_ADDR
// hackTanksCaptured := Replace ( hackTanksCaptured , hackTanksCaptured + 1 , [ ] ) ;
62049: LD_ADDR_EXP 89
62053: PUSH
62054: LD_EXP 89
62058: PPUSH
62059: LD_EXP 89
62063: PUSH
62064: LD_INT 1
62066: PLUS
62067: PPUSH
62068: EMPTY
62069: PPUSH
62070: CALL_OW 1
62074: ST_TO_ADDR
// hackCounter := Replace ( hackCounter , hackCounter + 1 , [ ] ) ;
62075: LD_ADDR_EXP 92
62079: PUSH
62080: LD_EXP 92
62084: PPUSH
62085: LD_EXP 92
62089: PUSH
62090: LD_INT 1
62092: PLUS
62093: PPUSH
62094: EMPTY
62095: PPUSH
62096: CALL_OW 1
62100: ST_TO_ADDR
// end ; if not IsOk ( i ) then
62101: LD_VAR 0 1
62105: PPUSH
62106: CALL_OW 302
62110: NOT
62111: IFFALSE 62124
// begin HackUnlinkAll ( i ) ;
62113: LD_VAR 0 1
62117: PPUSH
62118: CALL 62230 0 1
// continue ;
62122: GO 62004
// end ; HackCheckCapturedStatus ( i ) ;
62124: LD_VAR 0 1
62128: PPUSH
62129: CALL 62673 0 1
// tmp := FilterAllUnits ( [ [ f_enemy , GetSide ( i ) ] , [ f_control , control_computer ] , [ f_dist , i , hackDist ] , [ f_ok ] ] ) ;
62133: LD_ADDR_VAR 0 2
62137: PUSH
62138: LD_INT 81
62140: PUSH
62141: LD_VAR 0 1
62145: PPUSH
62146: CALL_OW 255
62150: PUSH
62151: EMPTY
62152: LIST
62153: LIST
62154: PUSH
62155: LD_INT 33
62157: PUSH
62158: LD_INT 3
62160: PUSH
62161: EMPTY
62162: LIST
62163: LIST
62164: PUSH
62165: LD_INT 91
62167: PUSH
62168: LD_VAR 0 1
62172: PUSH
62173: LD_EXP 91
62177: PUSH
62178: EMPTY
62179: LIST
62180: LIST
62181: LIST
62182: PUSH
62183: LD_INT 50
62185: PUSH
62186: EMPTY
62187: LIST
62188: PUSH
62189: EMPTY
62190: LIST
62191: LIST
62192: LIST
62193: LIST
62194: PPUSH
62195: CALL_OW 69
62199: ST_TO_ADDR
// if not tmp then
62200: LD_VAR 0 2
62204: NOT
62205: IFFALSE 62209
// continue ;
62207: GO 62004
// HackLink ( i , tmp ) ;
62209: LD_VAR 0 1
62213: PPUSH
62214: LD_VAR 0 2
62218: PPUSH
62219: CALL 62366 0 2
// end ;
62223: GO 62004
62225: POP
62226: POP
// end ;
62227: PPOPN 2
62229: END
// function HackUnlinkAll ( hack ) ; var i , index ; begin
62230: LD_INT 0
62232: PPUSH
62233: PPUSH
62234: PPUSH
// if not hack in hackTanks then
62235: LD_VAR 0 1
62239: PUSH
62240: LD_EXP 88
62244: IN
62245: NOT
62246: IFFALSE 62250
// exit ;
62248: GO 62361
// index := GetElementIndex ( hackTanks , hack ) ;
62250: LD_ADDR_VAR 0 4
62254: PUSH
62255: LD_EXP 88
62259: PPUSH
62260: LD_VAR 0 1
62264: PPUSH
62265: CALL 23971 0 2
62269: ST_TO_ADDR
// if hackTanksCaptured [ index ] then
62270: LD_EXP 89
62274: PUSH
62275: LD_VAR 0 4
62279: ARRAY
62280: IFFALSE 62361
// begin for i in hackTanksCaptured [ index ] do
62282: LD_ADDR_VAR 0 3
62286: PUSH
62287: LD_EXP 89
62291: PUSH
62292: LD_VAR 0 4
62296: ARRAY
62297: PUSH
62298: FOR_IN
62299: IFFALSE 62325
// SetSide ( i [ 1 ] , i [ 2 ] ) ;
62301: LD_VAR 0 3
62305: PUSH
62306: LD_INT 1
62308: ARRAY
62309: PPUSH
62310: LD_VAR 0 3
62314: PUSH
62315: LD_INT 2
62317: ARRAY
62318: PPUSH
62319: CALL_OW 235
62323: GO 62298
62325: POP
62326: POP
// hackTanksCaptured := Replace ( hackTanksCaptured , index , [ ] ) ;
62327: LD_ADDR_EXP 89
62331: PUSH
62332: LD_EXP 89
62336: PPUSH
62337: LD_VAR 0 4
62341: PPUSH
62342: EMPTY
62343: PPUSH
62344: CALL_OW 1
62348: ST_TO_ADDR
// SetUnitDisplayNumber ( hack , 0 ) ;
62349: LD_VAR 0 1
62353: PPUSH
62354: LD_INT 0
62356: PPUSH
62357: CALL_OW 505
// end ; end ;
62361: LD_VAR 0 2
62365: RET
// function HackLink ( hack , vehicles ) ; var i , index ; begin
62366: LD_INT 0
62368: PPUSH
62369: PPUSH
62370: PPUSH
// if not hack in hackTanks or not vehicles then
62371: LD_VAR 0 1
62375: PUSH
62376: LD_EXP 88
62380: IN
62381: NOT
62382: PUSH
62383: LD_VAR 0 2
62387: NOT
62388: OR
62389: IFFALSE 62393
// exit ;
62391: GO 62668
// vehicles := SortByDistanceUnit ( hack , vehicles , true , true ) ;
62393: LD_ADDR_VAR 0 2
62397: PUSH
62398: LD_VAR 0 1
62402: PPUSH
62403: LD_VAR 0 2
62407: PPUSH
62408: LD_INT 1
62410: PPUSH
62411: LD_INT 1
62413: PPUSH
62414: CALL 24621 0 4
62418: ST_TO_ADDR
// index := GetElementIndex ( hackTanks , hack ) ;
62419: LD_ADDR_VAR 0 5
62423: PUSH
62424: LD_EXP 88
62428: PPUSH
62429: LD_VAR 0 1
62433: PPUSH
62434: CALL 23971 0 2
62438: ST_TO_ADDR
// if hackTanksCaptured [ index ] < hackLimit then
62439: LD_EXP 89
62443: PUSH
62444: LD_VAR 0 5
62448: ARRAY
62449: PUSH
62450: LD_EXP 90
62454: LESS
62455: IFFALSE 62644
// begin for i := 1 to vehicles do
62457: LD_ADDR_VAR 0 4
62461: PUSH
62462: DOUBLE
62463: LD_INT 1
62465: DEC
62466: ST_TO_ADDR
62467: LD_VAR 0 2
62471: PUSH
62472: FOR_TO
62473: IFFALSE 62642
// begin if hackTanksCaptured [ index ] = hackLimit then
62475: LD_EXP 89
62479: PUSH
62480: LD_VAR 0 5
62484: ARRAY
62485: PUSH
62486: LD_EXP 90
62490: EQUAL
62491: IFFALSE 62495
// break ;
62493: GO 62642
// hackCounter := Replace ( hackCounter , index , hackCounter [ index ] + 1 ) ;
62495: LD_ADDR_EXP 92
62499: PUSH
62500: LD_EXP 92
62504: PPUSH
62505: LD_VAR 0 5
62509: PPUSH
62510: LD_EXP 92
62514: PUSH
62515: LD_VAR 0 5
62519: ARRAY
62520: PUSH
62521: LD_INT 1
62523: PLUS
62524: PPUSH
62525: CALL_OW 1
62529: ST_TO_ADDR
// hackTanksCaptured := ReplaceIn ( hackTanksCaptured , [ index , hackTanksCaptured [ index ] + 1 ] , [ vehicles [ i ] , GetSide ( vehicles [ i ] ) ] ) ;
62530: LD_ADDR_EXP 89
62534: PUSH
62535: LD_EXP 89
62539: PPUSH
62540: LD_VAR 0 5
62544: PUSH
62545: LD_EXP 89
62549: PUSH
62550: LD_VAR 0 5
62554: ARRAY
62555: PUSH
62556: LD_INT 1
62558: PLUS
62559: PUSH
62560: EMPTY
62561: LIST
62562: LIST
62563: PPUSH
62564: LD_VAR 0 2
62568: PUSH
62569: LD_VAR 0 4
62573: ARRAY
62574: PUSH
62575: LD_VAR 0 2
62579: PUSH
62580: LD_VAR 0 4
62584: ARRAY
62585: PPUSH
62586: CALL_OW 255
62590: PUSH
62591: EMPTY
62592: LIST
62593: LIST
62594: PPUSH
62595: CALL 24186 0 3
62599: ST_TO_ADDR
// SetSide ( vehicles [ i ] , GetSide ( hack ) ) ;
62600: LD_VAR 0 2
62604: PUSH
62605: LD_VAR 0 4
62609: ARRAY
62610: PPUSH
62611: LD_VAR 0 1
62615: PPUSH
62616: CALL_OW 255
62620: PPUSH
62621: CALL_OW 235
// ComStop ( vehicles [ i ] ) ;
62625: LD_VAR 0 2
62629: PUSH
62630: LD_VAR 0 4
62634: ARRAY
62635: PPUSH
62636: CALL_OW 141
// end ;
62640: GO 62472
62642: POP
62643: POP
// end ; SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
62644: LD_VAR 0 1
62648: PPUSH
62649: LD_EXP 89
62653: PUSH
62654: LD_VAR 0 5
62658: ARRAY
62659: PUSH
62660: LD_INT 0
62662: PLUS
62663: PPUSH
62664: CALL_OW 505
// end ;
62668: LD_VAR 0 3
62672: RET
// function HackCheckCapturedStatus ( hack ) ; var i , index , tmp ; begin
62673: LD_INT 0
62675: PPUSH
62676: PPUSH
62677: PPUSH
62678: PPUSH
// if not hack in hackTanks then
62679: LD_VAR 0 1
62683: PUSH
62684: LD_EXP 88
62688: IN
62689: NOT
62690: IFFALSE 62694
// exit ;
62692: GO 62934
// index := GetElementIndex ( hackTanks , hack ) ;
62694: LD_ADDR_VAR 0 4
62698: PUSH
62699: LD_EXP 88
62703: PPUSH
62704: LD_VAR 0 1
62708: PPUSH
62709: CALL 23971 0 2
62713: ST_TO_ADDR
// for i := hackTanksCaptured [ index ] downto 1 do
62714: LD_ADDR_VAR 0 3
62718: PUSH
62719: DOUBLE
62720: LD_EXP 89
62724: PUSH
62725: LD_VAR 0 4
62729: ARRAY
62730: INC
62731: ST_TO_ADDR
62732: LD_INT 1
62734: PUSH
62735: FOR_DOWNTO
62736: IFFALSE 62908
// begin tmp := hackTanksCaptured [ index ] [ i ] ;
62738: LD_ADDR_VAR 0 5
62742: PUSH
62743: LD_EXP 89
62747: PUSH
62748: LD_VAR 0 4
62752: ARRAY
62753: PUSH
62754: LD_VAR 0 3
62758: ARRAY
62759: ST_TO_ADDR
// if not IsOk ( tmp [ 1 ] ) or GetSide ( tmp [ 1 ] ) <> GetSide ( hack ) then
62760: LD_VAR 0 5
62764: PUSH
62765: LD_INT 1
62767: ARRAY
62768: PPUSH
62769: CALL_OW 302
62773: NOT
62774: PUSH
62775: LD_VAR 0 5
62779: PUSH
62780: LD_INT 1
62782: ARRAY
62783: PPUSH
62784: CALL_OW 255
62788: PUSH
62789: LD_VAR 0 1
62793: PPUSH
62794: CALL_OW 255
62798: NONEQUAL
62799: OR
62800: IFFALSE 62906
// begin if IsPlaced ( tmp [ 1 ] ) and GetSide ( tmp [ 1 ] ) = GetSide ( hack ) then
62802: LD_VAR 0 5
62806: PUSH
62807: LD_INT 1
62809: ARRAY
62810: PPUSH
62811: CALL_OW 305
62815: PUSH
62816: LD_VAR 0 5
62820: PUSH
62821: LD_INT 1
62823: ARRAY
62824: PPUSH
62825: CALL_OW 255
62829: PUSH
62830: LD_VAR 0 1
62834: PPUSH
62835: CALL_OW 255
62839: EQUAL
62840: AND
62841: IFFALSE 62865
// SetSide ( tmp [ 1 ] , tmp [ 2 ] ) ;
62843: LD_VAR 0 5
62847: PUSH
62848: LD_INT 1
62850: ARRAY
62851: PPUSH
62852: LD_VAR 0 5
62856: PUSH
62857: LD_INT 2
62859: ARRAY
62860: PPUSH
62861: CALL_OW 235
// hackTanksCaptured := Replace ( hackTanksCaptured , index , Delete ( hackTanksCaptured [ index ] , i ) ) ;
62865: LD_ADDR_EXP 89
62869: PUSH
62870: LD_EXP 89
62874: PPUSH
62875: LD_VAR 0 4
62879: PPUSH
62880: LD_EXP 89
62884: PUSH
62885: LD_VAR 0 4
62889: ARRAY
62890: PPUSH
62891: LD_VAR 0 3
62895: PPUSH
62896: CALL_OW 3
62900: PPUSH
62901: CALL_OW 1
62905: ST_TO_ADDR
// end ; end ;
62906: GO 62735
62908: POP
62909: POP
// SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
62910: LD_VAR 0 1
62914: PPUSH
62915: LD_EXP 89
62919: PUSH
62920: LD_VAR 0 4
62924: ARRAY
62925: PUSH
62926: LD_INT 0
62928: PLUS
62929: PPUSH
62930: CALL_OW 505
// end ;
62934: LD_VAR 0 2
62938: RET
// export function HackDestroyVehicle ( hack , vehicle ) ; var i , index , tmp ; begin
62939: LD_INT 0
62941: PPUSH
62942: PPUSH
62943: PPUSH
62944: PPUSH
// if not hack in hackTanks then
62945: LD_VAR 0 1
62949: PUSH
62950: LD_EXP 88
62954: IN
62955: NOT
62956: IFFALSE 62960
// exit ;
62958: GO 63045
// index := GetElementIndex ( hackTanks , hack ) ;
62960: LD_ADDR_VAR 0 5
62964: PUSH
62965: LD_EXP 88
62969: PPUSH
62970: LD_VAR 0 1
62974: PPUSH
62975: CALL 23971 0 2
62979: ST_TO_ADDR
// for i := 1 to hackTanksCaptured [ index ] do
62980: LD_ADDR_VAR 0 4
62984: PUSH
62985: DOUBLE
62986: LD_INT 1
62988: DEC
62989: ST_TO_ADDR
62990: LD_EXP 89
62994: PUSH
62995: LD_VAR 0 5
62999: ARRAY
63000: PUSH
63001: FOR_TO
63002: IFFALSE 63043
// if hackTanksCaptured [ index ] [ i ] [ 1 ] = vehicle then
63004: LD_EXP 89
63008: PUSH
63009: LD_VAR 0 5
63013: ARRAY
63014: PUSH
63015: LD_VAR 0 4
63019: ARRAY
63020: PUSH
63021: LD_INT 1
63023: ARRAY
63024: PUSH
63025: LD_VAR 0 2
63029: EQUAL
63030: IFFALSE 63041
// KillUnit ( vehicle ) ;
63032: LD_VAR 0 2
63036: PPUSH
63037: CALL_OW 66
63041: GO 63001
63043: POP
63044: POP
// end ;
63045: LD_VAR 0 3
63049: RET
// export initMiner , minersList , minerMinesList , minesLimitPerVehicle ; every 0 0$1 trigger not initMiner do
63050: LD_EXP 93
63054: NOT
63055: IFFALSE 63090
63057: GO 63059
63059: DISABLE
// begin initMiner := true ;
63060: LD_ADDR_EXP 93
63064: PUSH
63065: LD_INT 1
63067: ST_TO_ADDR
// minersList := [ ] ;
63068: LD_ADDR_EXP 94
63072: PUSH
63073: EMPTY
63074: ST_TO_ADDR
// minerMinesList := [ ] ;
63075: LD_ADDR_EXP 95
63079: PUSH
63080: EMPTY
63081: ST_TO_ADDR
// minesLimitPerVehicle := 5 ;
63082: LD_ADDR_EXP 96
63086: PUSH
63087: LD_INT 5
63089: ST_TO_ADDR
// end ;
63090: END
// every 0 0$1 trigger initMiner and FilterAllUnits ( [ f_weapon , ar_miner ] ) do var i , j , side , tmp ;
63091: LD_EXP 93
63095: PUSH
63096: LD_INT 34
63098: PUSH
63099: LD_INT 81
63101: PUSH
63102: EMPTY
63103: LIST
63104: LIST
63105: PPUSH
63106: CALL_OW 69
63110: AND
63111: IFFALSE 63572
63113: GO 63115
63115: DISABLE
63116: LD_INT 0
63118: PPUSH
63119: PPUSH
63120: PPUSH
63121: PPUSH
// begin enable ;
63122: ENABLE
// for i in FilterAllUnits ( [ f_weapon , ar_miner ] ) do
63123: LD_ADDR_VAR 0 1
63127: PUSH
63128: LD_INT 34
63130: PUSH
63131: LD_INT 81
63133: PUSH
63134: EMPTY
63135: LIST
63136: LIST
63137: PPUSH
63138: CALL_OW 69
63142: PUSH
63143: FOR_IN
63144: IFFALSE 63216
// begin if not i in minersList then
63146: LD_VAR 0 1
63150: PUSH
63151: LD_EXP 94
63155: IN
63156: NOT
63157: IFFALSE 63214
// begin minersList := Replace ( minersList , minersList + 1 , i ) ;
63159: LD_ADDR_EXP 94
63163: PUSH
63164: LD_EXP 94
63168: PPUSH
63169: LD_EXP 94
63173: PUSH
63174: LD_INT 1
63176: PLUS
63177: PPUSH
63178: LD_VAR 0 1
63182: PPUSH
63183: CALL_OW 1
63187: ST_TO_ADDR
// minerMinesList := Replace ( minerMinesList , minerMinesList + 1 , [ ] ) ;
63188: LD_ADDR_EXP 95
63192: PUSH
63193: LD_EXP 95
63197: PPUSH
63198: LD_EXP 95
63202: PUSH
63203: LD_INT 1
63205: PLUS
63206: PPUSH
63207: EMPTY
63208: PPUSH
63209: CALL_OW 1
63213: ST_TO_ADDR
// end end ;
63214: GO 63143
63216: POP
63217: POP
// for i := minerMinesList downto 1 do
63218: LD_ADDR_VAR 0 1
63222: PUSH
63223: DOUBLE
63224: LD_EXP 95
63228: INC
63229: ST_TO_ADDR
63230: LD_INT 1
63232: PUSH
63233: FOR_DOWNTO
63234: IFFALSE 63570
// begin if IsLive ( minersList [ i ] ) then
63236: LD_EXP 94
63240: PUSH
63241: LD_VAR 0 1
63245: ARRAY
63246: PPUSH
63247: CALL_OW 300
63251: IFFALSE 63279
// SetUnitDisplayNumber ( minersList [ i ] , minerMinesList [ i ] ) ;
63253: LD_EXP 94
63257: PUSH
63258: LD_VAR 0 1
63262: ARRAY
63263: PPUSH
63264: LD_EXP 95
63268: PUSH
63269: LD_VAR 0 1
63273: ARRAY
63274: PPUSH
63275: CALL_OW 505
// if not minerMinesList [ i ] then
63279: LD_EXP 95
63283: PUSH
63284: LD_VAR 0 1
63288: ARRAY
63289: NOT
63290: IFFALSE 63294
// continue ;
63292: GO 63233
// for j := minerMinesList [ i ] downto 1 do
63294: LD_ADDR_VAR 0 2
63298: PUSH
63299: DOUBLE
63300: LD_EXP 95
63304: PUSH
63305: LD_VAR 0 1
63309: ARRAY
63310: INC
63311: ST_TO_ADDR
63312: LD_INT 1
63314: PUSH
63315: FOR_DOWNTO
63316: IFFALSE 63566
// begin side := GetSide ( minersList [ i ] ) ;
63318: LD_ADDR_VAR 0 3
63322: PUSH
63323: LD_EXP 94
63327: PUSH
63328: LD_VAR 0 1
63332: ARRAY
63333: PPUSH
63334: CALL_OW 255
63338: ST_TO_ADDR
// tmp := HexInfo ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) ;
63339: LD_ADDR_VAR 0 4
63343: PUSH
63344: LD_EXP 95
63348: PUSH
63349: LD_VAR 0 1
63353: ARRAY
63354: PUSH
63355: LD_VAR 0 2
63359: ARRAY
63360: PUSH
63361: LD_INT 1
63363: ARRAY
63364: PPUSH
63365: LD_EXP 95
63369: PUSH
63370: LD_VAR 0 1
63374: ARRAY
63375: PUSH
63376: LD_VAR 0 2
63380: ARRAY
63381: PUSH
63382: LD_INT 2
63384: ARRAY
63385: PPUSH
63386: CALL_OW 428
63390: ST_TO_ADDR
// if not tmp then
63391: LD_VAR 0 4
63395: NOT
63396: IFFALSE 63400
// continue ;
63398: GO 63315
// if tmp in FilterAllUnits ( [ f_enemy , side ] ) and MineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) then
63400: LD_VAR 0 4
63404: PUSH
63405: LD_INT 81
63407: PUSH
63408: LD_VAR 0 3
63412: PUSH
63413: EMPTY
63414: LIST
63415: LIST
63416: PPUSH
63417: CALL_OW 69
63421: IN
63422: PUSH
63423: LD_EXP 95
63427: PUSH
63428: LD_VAR 0 1
63432: ARRAY
63433: PUSH
63434: LD_VAR 0 2
63438: ARRAY
63439: PUSH
63440: LD_INT 1
63442: ARRAY
63443: PPUSH
63444: LD_EXP 95
63448: PUSH
63449: LD_VAR 0 1
63453: ARRAY
63454: PUSH
63455: LD_VAR 0 2
63459: ARRAY
63460: PUSH
63461: LD_INT 2
63463: ARRAY
63464: PPUSH
63465: CALL_OW 458
63469: AND
63470: IFFALSE 63564
// begin LaunchMineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] , side ) ;
63472: LD_EXP 95
63476: PUSH
63477: LD_VAR 0 1
63481: ARRAY
63482: PUSH
63483: LD_VAR 0 2
63487: ARRAY
63488: PUSH
63489: LD_INT 1
63491: ARRAY
63492: PPUSH
63493: LD_EXP 95
63497: PUSH
63498: LD_VAR 0 1
63502: ARRAY
63503: PUSH
63504: LD_VAR 0 2
63508: ARRAY
63509: PUSH
63510: LD_INT 2
63512: ARRAY
63513: PPUSH
63514: LD_VAR 0 3
63518: PPUSH
63519: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , i , Delete ( minerMinesList [ i ] , j ) ) ;
63523: LD_ADDR_EXP 95
63527: PUSH
63528: LD_EXP 95
63532: PPUSH
63533: LD_VAR 0 1
63537: PPUSH
63538: LD_EXP 95
63542: PUSH
63543: LD_VAR 0 1
63547: ARRAY
63548: PPUSH
63549: LD_VAR 0 2
63553: PPUSH
63554: CALL_OW 3
63558: PPUSH
63559: CALL_OW 1
63563: ST_TO_ADDR
// end ; end ;
63564: GO 63315
63566: POP
63567: POP
// end ;
63568: GO 63233
63570: POP
63571: POP
// end ;
63572: PPOPN 4
63574: END
// export function MinerPlaceMine ( unit , x , y ) ; var index ; begin
63575: LD_INT 0
63577: PPUSH
63578: PPUSH
// result := false ;
63579: LD_ADDR_VAR 0 4
63583: PUSH
63584: LD_INT 0
63586: ST_TO_ADDR
// if not GetWeapon ( unit ) = ar_miner then
63587: LD_VAR 0 1
63591: PPUSH
63592: CALL_OW 264
63596: PUSH
63597: LD_INT 81
63599: EQUAL
63600: NOT
63601: IFFALSE 63605
// exit ;
63603: GO 63845
// index := GetElementIndex ( minersList , unit ) ;
63605: LD_ADDR_VAR 0 5
63609: PUSH
63610: LD_EXP 94
63614: PPUSH
63615: LD_VAR 0 1
63619: PPUSH
63620: CALL 23971 0 2
63624: ST_TO_ADDR
// if minerMinesList [ index ] >= minesLimitPerVehicle then
63625: LD_EXP 95
63629: PUSH
63630: LD_VAR 0 5
63634: ARRAY
63635: PUSH
63636: LD_EXP 96
63640: GREATEREQUAL
63641: IFFALSE 63645
// exit ;
63643: GO 63845
// ComMoveXY ( unit , x , y ) ;
63645: LD_VAR 0 1
63649: PPUSH
63650: LD_VAR 0 2
63654: PPUSH
63655: LD_VAR 0 3
63659: PPUSH
63660: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
63664: LD_INT 35
63666: PPUSH
63667: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) and HasTask ( unit ) then
63671: LD_VAR 0 1
63675: PPUSH
63676: LD_VAR 0 2
63680: PPUSH
63681: LD_VAR 0 3
63685: PPUSH
63686: CALL 55355 0 3
63690: NOT
63691: PUSH
63692: LD_VAR 0 1
63696: PPUSH
63697: CALL_OW 314
63701: AND
63702: IFFALSE 63706
// exit ;
63704: GO 63845
// until HexInfo ( x , y ) = unit and not HasTask ( unit ) ;
63706: LD_VAR 0 2
63710: PPUSH
63711: LD_VAR 0 3
63715: PPUSH
63716: CALL_OW 428
63720: PUSH
63721: LD_VAR 0 1
63725: EQUAL
63726: PUSH
63727: LD_VAR 0 1
63731: PPUSH
63732: CALL_OW 314
63736: NOT
63737: AND
63738: IFFALSE 63664
// PlaySoundXY ( x , y , PlantMine ) ;
63740: LD_VAR 0 2
63744: PPUSH
63745: LD_VAR 0 3
63749: PPUSH
63750: LD_STRING PlantMine
63752: PPUSH
63753: CALL_OW 366
// PlaceMine ( x , y , GetSide ( unit ) , 0 ) ;
63757: LD_VAR 0 2
63761: PPUSH
63762: LD_VAR 0 3
63766: PPUSH
63767: LD_VAR 0 1
63771: PPUSH
63772: CALL_OW 255
63776: PPUSH
63777: LD_INT 0
63779: PPUSH
63780: CALL_OW 454
// minerMinesList := ReplaceIn ( minerMinesList , [ index , minerMinesList [ index ] + 1 ] , [ x , y ] ) ;
63784: LD_ADDR_EXP 95
63788: PUSH
63789: LD_EXP 95
63793: PPUSH
63794: LD_VAR 0 5
63798: PUSH
63799: LD_EXP 95
63803: PUSH
63804: LD_VAR 0 5
63808: ARRAY
63809: PUSH
63810: LD_INT 1
63812: PLUS
63813: PUSH
63814: EMPTY
63815: LIST
63816: LIST
63817: PPUSH
63818: LD_VAR 0 2
63822: PUSH
63823: LD_VAR 0 3
63827: PUSH
63828: EMPTY
63829: LIST
63830: LIST
63831: PPUSH
63832: CALL 24186 0 3
63836: ST_TO_ADDR
// result := true ;
63837: LD_ADDR_VAR 0 4
63841: PUSH
63842: LD_INT 1
63844: ST_TO_ADDR
// end ;
63845: LD_VAR 0 4
63849: RET
// export function MinerDetonateMine ( unit , x , y ) ; var i , index ; begin
63850: LD_INT 0
63852: PPUSH
63853: PPUSH
63854: PPUSH
// if not unit in minersList then
63855: LD_VAR 0 1
63859: PUSH
63860: LD_EXP 94
63864: IN
63865: NOT
63866: IFFALSE 63870
// exit ;
63868: GO 64262
// index := GetElementIndex ( minersList , unit ) ;
63870: LD_ADDR_VAR 0 6
63874: PUSH
63875: LD_EXP 94
63879: PPUSH
63880: LD_VAR 0 1
63884: PPUSH
63885: CALL 23971 0 2
63889: ST_TO_ADDR
// for i := minerMinesList [ index ] downto 1 do
63890: LD_ADDR_VAR 0 5
63894: PUSH
63895: DOUBLE
63896: LD_EXP 95
63900: PUSH
63901: LD_VAR 0 6
63905: ARRAY
63906: INC
63907: ST_TO_ADDR
63908: LD_INT 1
63910: PUSH
63911: FOR_DOWNTO
63912: IFFALSE 64073
// begin if minerMinesList [ index ] [ i ] [ 1 ] = x and minerMinesList [ index ] [ i ] [ 2 ] = y then
63914: LD_EXP 95
63918: PUSH
63919: LD_VAR 0 6
63923: ARRAY
63924: PUSH
63925: LD_VAR 0 5
63929: ARRAY
63930: PUSH
63931: LD_INT 1
63933: ARRAY
63934: PUSH
63935: LD_VAR 0 2
63939: EQUAL
63940: PUSH
63941: LD_EXP 95
63945: PUSH
63946: LD_VAR 0 6
63950: ARRAY
63951: PUSH
63952: LD_VAR 0 5
63956: ARRAY
63957: PUSH
63958: LD_INT 2
63960: ARRAY
63961: PUSH
63962: LD_VAR 0 3
63966: EQUAL
63967: AND
63968: IFFALSE 64071
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
63970: LD_EXP 95
63974: PUSH
63975: LD_VAR 0 6
63979: ARRAY
63980: PUSH
63981: LD_VAR 0 5
63985: ARRAY
63986: PUSH
63987: LD_INT 1
63989: ARRAY
63990: PPUSH
63991: LD_EXP 95
63995: PUSH
63996: LD_VAR 0 6
64000: ARRAY
64001: PUSH
64002: LD_VAR 0 5
64006: ARRAY
64007: PUSH
64008: LD_INT 2
64010: ARRAY
64011: PPUSH
64012: LD_VAR 0 1
64016: PPUSH
64017: CALL_OW 255
64021: PPUSH
64022: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
64026: LD_ADDR_EXP 95
64030: PUSH
64031: LD_EXP 95
64035: PPUSH
64036: LD_VAR 0 6
64040: PPUSH
64041: LD_EXP 95
64045: PUSH
64046: LD_VAR 0 6
64050: ARRAY
64051: PPUSH
64052: LD_VAR 0 5
64056: PPUSH
64057: CALL_OW 3
64061: PPUSH
64062: CALL_OW 1
64066: ST_TO_ADDR
// exit ;
64067: POP
64068: POP
64069: GO 64262
// end ; end ;
64071: GO 63911
64073: POP
64074: POP
// for i := minerMinesList [ index ] downto 1 do
64075: LD_ADDR_VAR 0 5
64079: PUSH
64080: DOUBLE
64081: LD_EXP 95
64085: PUSH
64086: LD_VAR 0 6
64090: ARRAY
64091: INC
64092: ST_TO_ADDR
64093: LD_INT 1
64095: PUSH
64096: FOR_DOWNTO
64097: IFFALSE 64260
// begin if GetDistXY ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , x , y ) < 6 then
64099: LD_EXP 95
64103: PUSH
64104: LD_VAR 0 6
64108: ARRAY
64109: PUSH
64110: LD_VAR 0 5
64114: ARRAY
64115: PUSH
64116: LD_INT 1
64118: ARRAY
64119: PPUSH
64120: LD_EXP 95
64124: PUSH
64125: LD_VAR 0 6
64129: ARRAY
64130: PUSH
64131: LD_VAR 0 5
64135: ARRAY
64136: PUSH
64137: LD_INT 2
64139: ARRAY
64140: PPUSH
64141: LD_VAR 0 2
64145: PPUSH
64146: LD_VAR 0 3
64150: PPUSH
64151: CALL_OW 298
64155: PUSH
64156: LD_INT 6
64158: LESS
64159: IFFALSE 64258
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
64161: LD_EXP 95
64165: PUSH
64166: LD_VAR 0 6
64170: ARRAY
64171: PUSH
64172: LD_VAR 0 5
64176: ARRAY
64177: PUSH
64178: LD_INT 1
64180: ARRAY
64181: PPUSH
64182: LD_EXP 95
64186: PUSH
64187: LD_VAR 0 6
64191: ARRAY
64192: PUSH
64193: LD_VAR 0 5
64197: ARRAY
64198: PUSH
64199: LD_INT 2
64201: ARRAY
64202: PPUSH
64203: LD_VAR 0 1
64207: PPUSH
64208: CALL_OW 255
64212: PPUSH
64213: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
64217: LD_ADDR_EXP 95
64221: PUSH
64222: LD_EXP 95
64226: PPUSH
64227: LD_VAR 0 6
64231: PPUSH
64232: LD_EXP 95
64236: PUSH
64237: LD_VAR 0 6
64241: ARRAY
64242: PPUSH
64243: LD_VAR 0 5
64247: PPUSH
64248: CALL_OW 3
64252: PPUSH
64253: CALL_OW 1
64257: ST_TO_ADDR
// end ; end ;
64258: GO 64096
64260: POP
64261: POP
// end ;
64262: LD_VAR 0 4
64266: RET
// export function MinerCreateMinefield ( unit , x , y ) ; var i , index , tmp , minesFreeAmount , _x , _y , _d , _r ; begin
64267: LD_INT 0
64269: PPUSH
64270: PPUSH
64271: PPUSH
64272: PPUSH
64273: PPUSH
64274: PPUSH
64275: PPUSH
64276: PPUSH
64277: PPUSH
// if not GetWeapon ( unit ) = ar_miner or not unit in minersList then
64278: LD_VAR 0 1
64282: PPUSH
64283: CALL_OW 264
64287: PUSH
64288: LD_INT 81
64290: EQUAL
64291: NOT
64292: PUSH
64293: LD_VAR 0 1
64297: PUSH
64298: LD_EXP 94
64302: IN
64303: NOT
64304: OR
64305: IFFALSE 64309
// exit ;
64307: GO 64631
// index := GetElementIndex ( minersList , unit ) ;
64309: LD_ADDR_VAR 0 6
64313: PUSH
64314: LD_EXP 94
64318: PPUSH
64319: LD_VAR 0 1
64323: PPUSH
64324: CALL 23971 0 2
64328: ST_TO_ADDR
// minesFreeAmount := minesLimitPerVehicle - minerMinesList [ index ] ;
64329: LD_ADDR_VAR 0 8
64333: PUSH
64334: LD_EXP 96
64338: PUSH
64339: LD_EXP 95
64343: PUSH
64344: LD_VAR 0 6
64348: ARRAY
64349: MINUS
64350: ST_TO_ADDR
// if not minesFreeAmount then
64351: LD_VAR 0 8
64355: NOT
64356: IFFALSE 64360
// exit ;
64358: GO 64631
// tmp := [ ] ;
64360: LD_ADDR_VAR 0 7
64364: PUSH
64365: EMPTY
64366: ST_TO_ADDR
// for i := 1 to minesFreeAmount do
64367: LD_ADDR_VAR 0 5
64371: PUSH
64372: DOUBLE
64373: LD_INT 1
64375: DEC
64376: ST_TO_ADDR
64377: LD_VAR 0 8
64381: PUSH
64382: FOR_TO
64383: IFFALSE 64578
// begin _d := rand ( 0 , 5 ) ;
64385: LD_ADDR_VAR 0 11
64389: PUSH
64390: LD_INT 0
64392: PPUSH
64393: LD_INT 5
64395: PPUSH
64396: CALL_OW 12
64400: ST_TO_ADDR
// _r := rand ( 2 , 6 ) ;
64401: LD_ADDR_VAR 0 12
64405: PUSH
64406: LD_INT 2
64408: PPUSH
64409: LD_INT 6
64411: PPUSH
64412: CALL_OW 12
64416: ST_TO_ADDR
// _x := ShiftX ( x , _d , _r ) ;
64417: LD_ADDR_VAR 0 9
64421: PUSH
64422: LD_VAR 0 2
64426: PPUSH
64427: LD_VAR 0 11
64431: PPUSH
64432: LD_VAR 0 12
64436: PPUSH
64437: CALL_OW 272
64441: ST_TO_ADDR
// _y := ShiftY ( y , _d , _r ) ;
64442: LD_ADDR_VAR 0 10
64446: PUSH
64447: LD_VAR 0 3
64451: PPUSH
64452: LD_VAR 0 11
64456: PPUSH
64457: LD_VAR 0 12
64461: PPUSH
64462: CALL_OW 273
64466: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not [ _x , _y ] in tmp and not MineAtPos ( _x , _y ) then
64467: LD_VAR 0 9
64471: PPUSH
64472: LD_VAR 0 10
64476: PPUSH
64477: CALL_OW 488
64481: PUSH
64482: LD_VAR 0 9
64486: PUSH
64487: LD_VAR 0 10
64491: PUSH
64492: EMPTY
64493: LIST
64494: LIST
64495: PUSH
64496: LD_VAR 0 7
64500: IN
64501: NOT
64502: AND
64503: PUSH
64504: LD_VAR 0 9
64508: PPUSH
64509: LD_VAR 0 10
64513: PPUSH
64514: CALL_OW 458
64518: NOT
64519: AND
64520: IFFALSE 64562
// tmp := Replace ( tmp , tmp + 1 , [ _x , _y ] ) else
64522: LD_ADDR_VAR 0 7
64526: PUSH
64527: LD_VAR 0 7
64531: PPUSH
64532: LD_VAR 0 7
64536: PUSH
64537: LD_INT 1
64539: PLUS
64540: PPUSH
64541: LD_VAR 0 9
64545: PUSH
64546: LD_VAR 0 10
64550: PUSH
64551: EMPTY
64552: LIST
64553: LIST
64554: PPUSH
64555: CALL_OW 1
64559: ST_TO_ADDR
64560: GO 64576
// i := i - 1 ;
64562: LD_ADDR_VAR 0 5
64566: PUSH
64567: LD_VAR 0 5
64571: PUSH
64572: LD_INT 1
64574: MINUS
64575: ST_TO_ADDR
// end ;
64576: GO 64382
64578: POP
64579: POP
// for i in tmp do
64580: LD_ADDR_VAR 0 5
64584: PUSH
64585: LD_VAR 0 7
64589: PUSH
64590: FOR_IN
64591: IFFALSE 64629
// if not MinerPlaceMine ( unit , i [ 1 ] , i [ 2 ] ) then
64593: LD_VAR 0 1
64597: PPUSH
64598: LD_VAR 0 5
64602: PUSH
64603: LD_INT 1
64605: ARRAY
64606: PPUSH
64607: LD_VAR 0 5
64611: PUSH
64612: LD_INT 2
64614: ARRAY
64615: PPUSH
64616: CALL 63575 0 3
64620: NOT
64621: IFFALSE 64627
// exit ;
64623: POP
64624: POP
64625: GO 64631
64627: GO 64590
64629: POP
64630: POP
// end ;
64631: LD_VAR 0 4
64635: RET
// export function ComBinocular ( unit , x , y ) ; var dist , side , viewRange , _x , _y , _d ; begin
64636: LD_INT 0
64638: PPUSH
64639: PPUSH
64640: PPUSH
64641: PPUSH
64642: PPUSH
64643: PPUSH
64644: PPUSH
// if not GetClass ( unit ) = class_sniper then
64645: LD_VAR 0 1
64649: PPUSH
64650: CALL_OW 257
64654: PUSH
64655: LD_INT 5
64657: EQUAL
64658: NOT
64659: IFFALSE 64663
// exit ;
64661: GO 65051
// dist := 8 ;
64663: LD_ADDR_VAR 0 5
64667: PUSH
64668: LD_INT 8
64670: ST_TO_ADDR
// viewRange := 12 ;
64671: LD_ADDR_VAR 0 7
64675: PUSH
64676: LD_INT 12
64678: ST_TO_ADDR
// side := GetSide ( unit ) ;
64679: LD_ADDR_VAR 0 6
64683: PUSH
64684: LD_VAR 0 1
64688: PPUSH
64689: CALL_OW 255
64693: ST_TO_ADDR
// if GetTech ( tech_opto2 , side ) = state_researched then
64694: LD_INT 61
64696: PPUSH
64697: LD_VAR 0 6
64701: PPUSH
64702: CALL_OW 321
64706: PUSH
64707: LD_INT 2
64709: EQUAL
64710: IFFALSE 64720
// viewRange := 16 ;
64712: LD_ADDR_VAR 0 7
64716: PUSH
64717: LD_INT 16
64719: ST_TO_ADDR
// if GetDistUnitXY ( unit , x , y ) > dist then
64720: LD_VAR 0 1
64724: PPUSH
64725: LD_VAR 0 2
64729: PPUSH
64730: LD_VAR 0 3
64734: PPUSH
64735: CALL_OW 297
64739: PUSH
64740: LD_VAR 0 5
64744: GREATER
64745: IFFALSE 64824
// begin ComMoveXY ( unit , x , y ) ;
64747: LD_VAR 0 1
64751: PPUSH
64752: LD_VAR 0 2
64756: PPUSH
64757: LD_VAR 0 3
64761: PPUSH
64762: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
64766: LD_INT 35
64768: PPUSH
64769: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) then
64773: LD_VAR 0 1
64777: PPUSH
64778: LD_VAR 0 2
64782: PPUSH
64783: LD_VAR 0 3
64787: PPUSH
64788: CALL 55355 0 3
64792: NOT
64793: IFFALSE 64797
// exit ;
64795: GO 65051
// until GetDistUnitXY ( unit , x , y ) < dist ;
64797: LD_VAR 0 1
64801: PPUSH
64802: LD_VAR 0 2
64806: PPUSH
64807: LD_VAR 0 3
64811: PPUSH
64812: CALL_OW 297
64816: PUSH
64817: LD_VAR 0 5
64821: LESS
64822: IFFALSE 64766
// end ; ComTurnXY ( unit , x , y ) ;
64824: LD_VAR 0 1
64828: PPUSH
64829: LD_VAR 0 2
64833: PPUSH
64834: LD_VAR 0 3
64838: PPUSH
64839: CALL_OW 118
// wait ( 5 ) ;
64843: LD_INT 5
64845: PPUSH
64846: CALL_OW 67
// _d := GetDir ( unit ) ;
64850: LD_ADDR_VAR 0 10
64854: PUSH
64855: LD_VAR 0 1
64859: PPUSH
64860: CALL_OW 254
64864: ST_TO_ADDR
// _x := ShiftX ( GetX ( unit ) , _d , dist ) ;
64865: LD_ADDR_VAR 0 8
64869: PUSH
64870: LD_VAR 0 1
64874: PPUSH
64875: CALL_OW 250
64879: PPUSH
64880: LD_VAR 0 10
64884: PPUSH
64885: LD_VAR 0 5
64889: PPUSH
64890: CALL_OW 272
64894: ST_TO_ADDR
// _y := ShiftY ( GetY ( unit ) , _d , dist ) ;
64895: LD_ADDR_VAR 0 9
64899: PUSH
64900: LD_VAR 0 1
64904: PPUSH
64905: CALL_OW 251
64909: PPUSH
64910: LD_VAR 0 10
64914: PPUSH
64915: LD_VAR 0 5
64919: PPUSH
64920: CALL_OW 273
64924: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
64925: LD_VAR 0 8
64929: PPUSH
64930: LD_VAR 0 9
64934: PPUSH
64935: CALL_OW 488
64939: NOT
64940: IFFALSE 64944
// exit ;
64942: GO 65051
// ComAnimCustom ( unit , 1 ) ;
64944: LD_VAR 0 1
64948: PPUSH
64949: LD_INT 1
64951: PPUSH
64952: CALL_OW 592
// PlaceSeeing ( _x , _y , side , viewRange ) ;
64956: LD_VAR 0 8
64960: PPUSH
64961: LD_VAR 0 9
64965: PPUSH
64966: LD_VAR 0 6
64970: PPUSH
64971: LD_VAR 0 7
64975: PPUSH
64976: CALL_OW 330
// repeat wait ( 1 ) ;
64980: LD_INT 1
64982: PPUSH
64983: CALL_OW 67
// until IsIdle ( unit ) or HasTask ( unit ) or not IsOk ( unit ) or IsDead ( unit ) ;
64987: LD_VAR 0 1
64991: PPUSH
64992: CALL_OW 316
64996: PUSH
64997: LD_VAR 0 1
65001: PPUSH
65002: CALL_OW 314
65006: OR
65007: PUSH
65008: LD_VAR 0 1
65012: PPUSH
65013: CALL_OW 302
65017: NOT
65018: OR
65019: PUSH
65020: LD_VAR 0 1
65024: PPUSH
65025: CALL_OW 301
65029: OR
65030: IFFALSE 64980
// RemoveSeeing ( _x , _y , side ) ;
65032: LD_VAR 0 8
65036: PPUSH
65037: LD_VAR 0 9
65041: PPUSH
65042: LD_VAR 0 6
65046: PPUSH
65047: CALL_OW 331
// end ; end_of_file
65051: LD_VAR 0 4
65055: RET
// export globalGameSaveCounter ; every 0 0$1 do
65056: GO 65058
65058: DISABLE
// begin enable ;
65059: ENABLE
// ToLua ( updateTimer( & tick & ); ) ;
65060: LD_STRING updateTimer(
65062: PUSH
65063: LD_OWVAR 1
65067: STR
65068: PUSH
65069: LD_STRING );
65071: STR
65072: PPUSH
65073: CALL_OW 559
// end ;
65077: END
// every 0 0$1 do
65078: GO 65080
65080: DISABLE
// begin globalGameSaveCounter := 0 ;
65081: LD_ADDR_EXP 97
65085: PUSH
65086: LD_INT 0
65088: ST_TO_ADDR
// ToLua ( setGameSaveCounter(0) ) ;
65089: LD_STRING setGameSaveCounter(0)
65091: PPUSH
65092: CALL_OW 559
// ToLua ( initStreamRollete(); ) ;
65096: LD_STRING initStreamRollete();
65098: PPUSH
65099: CALL_OW 559
// InitStreamMode ;
65103: CALL 66429 0 0
// DefineStreamItems ( false ) ;
65107: LD_INT 0
65109: PPUSH
65110: CALL 66893 0 1
// end ;
65114: END
// export function SOS_MapStart ( ) ; begin
65115: LD_INT 0
65117: PPUSH
// if streamModeActive then
65118: LD_EXP 98
65122: IFFALSE 65131
// DefineStreamItems ( true ) ;
65124: LD_INT 1
65126: PPUSH
65127: CALL 66893 0 1
// UpdateLuaVariables ( ) ;
65131: CALL 65148 0 0
// UpdateFactoryWaypoints ( ) ;
65135: CALL 79762 0 0
// UpdateWarehouseGatheringPoints ( ) ;
65139: CALL 80019 0 0
// end ;
65143: LD_VAR 0 1
65147: RET
// function UpdateLuaVariables ( ) ; begin
65148: LD_INT 0
65150: PPUSH
// if globalGameSaveCounter then
65151: LD_EXP 97
65155: IFFALSE 65189
// begin globalGameSaveCounter := Inc ( globalGameSaveCounter ) ;
65157: LD_ADDR_EXP 97
65161: PUSH
65162: LD_EXP 97
65166: PPUSH
65167: CALL 57906 0 1
65171: ST_TO_ADDR
// ToLua ( setGameSaveCounter( & globalGameSaveCounter & ) ) ;
65172: LD_STRING setGameSaveCounter(
65174: PUSH
65175: LD_EXP 97
65179: STR
65180: PUSH
65181: LD_STRING )
65183: STR
65184: PPUSH
65185: CALL_OW 559
// end ; ToLua ( setGameDifficulty( & Difficulty & ) ) ;
65189: LD_STRING setGameDifficulty(
65191: PUSH
65192: LD_OWVAR 67
65196: STR
65197: PUSH
65198: LD_STRING )
65200: STR
65201: PPUSH
65202: CALL_OW 559
// end ;
65206: LD_VAR 0 1
65210: RET
// export function SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
65211: LD_INT 0
65213: PPUSH
// if p2 = stream_mode then
65214: LD_VAR 0 2
65218: PUSH
65219: LD_INT 100
65221: EQUAL
65222: IFFALSE 66225
// begin if not StreamModeActive then
65224: LD_EXP 98
65228: NOT
65229: IFFALSE 65239
// StreamModeActive := true ;
65231: LD_ADDR_EXP 98
65235: PUSH
65236: LD_INT 1
65238: ST_TO_ADDR
// if p3 = 0 then
65239: LD_VAR 0 3
65243: PUSH
65244: LD_INT 0
65246: EQUAL
65247: IFFALSE 65253
// InitStreamMode ;
65249: CALL 66429 0 0
// if p3 = 1 then
65253: LD_VAR 0 3
65257: PUSH
65258: LD_INT 1
65260: EQUAL
65261: IFFALSE 65271
// sRocket := true ;
65263: LD_ADDR_EXP 103
65267: PUSH
65268: LD_INT 1
65270: ST_TO_ADDR
// if p3 = 2 then
65271: LD_VAR 0 3
65275: PUSH
65276: LD_INT 2
65278: EQUAL
65279: IFFALSE 65289
// sSpeed := true ;
65281: LD_ADDR_EXP 102
65285: PUSH
65286: LD_INT 1
65288: ST_TO_ADDR
// if p3 = 3 then
65289: LD_VAR 0 3
65293: PUSH
65294: LD_INT 3
65296: EQUAL
65297: IFFALSE 65307
// sEngine := true ;
65299: LD_ADDR_EXP 104
65303: PUSH
65304: LD_INT 1
65306: ST_TO_ADDR
// if p3 = 4 then
65307: LD_VAR 0 3
65311: PUSH
65312: LD_INT 4
65314: EQUAL
65315: IFFALSE 65325
// sSpec := true ;
65317: LD_ADDR_EXP 101
65321: PUSH
65322: LD_INT 1
65324: ST_TO_ADDR
// if p3 = 5 then
65325: LD_VAR 0 3
65329: PUSH
65330: LD_INT 5
65332: EQUAL
65333: IFFALSE 65343
// sLevel := true ;
65335: LD_ADDR_EXP 105
65339: PUSH
65340: LD_INT 1
65342: ST_TO_ADDR
// if p3 = 6 then
65343: LD_VAR 0 3
65347: PUSH
65348: LD_INT 6
65350: EQUAL
65351: IFFALSE 65361
// sArmoury := true ;
65353: LD_ADDR_EXP 106
65357: PUSH
65358: LD_INT 1
65360: ST_TO_ADDR
// if p3 = 7 then
65361: LD_VAR 0 3
65365: PUSH
65366: LD_INT 7
65368: EQUAL
65369: IFFALSE 65379
// sRadar := true ;
65371: LD_ADDR_EXP 107
65375: PUSH
65376: LD_INT 1
65378: ST_TO_ADDR
// if p3 = 8 then
65379: LD_VAR 0 3
65383: PUSH
65384: LD_INT 8
65386: EQUAL
65387: IFFALSE 65397
// sBunker := true ;
65389: LD_ADDR_EXP 108
65393: PUSH
65394: LD_INT 1
65396: ST_TO_ADDR
// if p3 = 9 then
65397: LD_VAR 0 3
65401: PUSH
65402: LD_INT 9
65404: EQUAL
65405: IFFALSE 65415
// sHack := true ;
65407: LD_ADDR_EXP 109
65411: PUSH
65412: LD_INT 1
65414: ST_TO_ADDR
// if p3 = 10 then
65415: LD_VAR 0 3
65419: PUSH
65420: LD_INT 10
65422: EQUAL
65423: IFFALSE 65433
// sFire := true ;
65425: LD_ADDR_EXP 110
65429: PUSH
65430: LD_INT 1
65432: ST_TO_ADDR
// if p3 = 11 then
65433: LD_VAR 0 3
65437: PUSH
65438: LD_INT 11
65440: EQUAL
65441: IFFALSE 65451
// sRefresh := true ;
65443: LD_ADDR_EXP 111
65447: PUSH
65448: LD_INT 1
65450: ST_TO_ADDR
// if p3 = 12 then
65451: LD_VAR 0 3
65455: PUSH
65456: LD_INT 12
65458: EQUAL
65459: IFFALSE 65469
// sExp := true ;
65461: LD_ADDR_EXP 112
65465: PUSH
65466: LD_INT 1
65468: ST_TO_ADDR
// if p3 = 13 then
65469: LD_VAR 0 3
65473: PUSH
65474: LD_INT 13
65476: EQUAL
65477: IFFALSE 65487
// sDepot := true ;
65479: LD_ADDR_EXP 113
65483: PUSH
65484: LD_INT 1
65486: ST_TO_ADDR
// if p3 = 14 then
65487: LD_VAR 0 3
65491: PUSH
65492: LD_INT 14
65494: EQUAL
65495: IFFALSE 65505
// sFlag := true ;
65497: LD_ADDR_EXP 114
65501: PUSH
65502: LD_INT 1
65504: ST_TO_ADDR
// if p3 = 15 then
65505: LD_VAR 0 3
65509: PUSH
65510: LD_INT 15
65512: EQUAL
65513: IFFALSE 65523
// sKamikadze := true ;
65515: LD_ADDR_EXP 122
65519: PUSH
65520: LD_INT 1
65522: ST_TO_ADDR
// if p3 = 16 then
65523: LD_VAR 0 3
65527: PUSH
65528: LD_INT 16
65530: EQUAL
65531: IFFALSE 65541
// sTroll := true ;
65533: LD_ADDR_EXP 123
65537: PUSH
65538: LD_INT 1
65540: ST_TO_ADDR
// if p3 = 17 then
65541: LD_VAR 0 3
65545: PUSH
65546: LD_INT 17
65548: EQUAL
65549: IFFALSE 65559
// sSlow := true ;
65551: LD_ADDR_EXP 124
65555: PUSH
65556: LD_INT 1
65558: ST_TO_ADDR
// if p3 = 18 then
65559: LD_VAR 0 3
65563: PUSH
65564: LD_INT 18
65566: EQUAL
65567: IFFALSE 65577
// sLack := true ;
65569: LD_ADDR_EXP 125
65573: PUSH
65574: LD_INT 1
65576: ST_TO_ADDR
// if p3 = 19 then
65577: LD_VAR 0 3
65581: PUSH
65582: LD_INT 19
65584: EQUAL
65585: IFFALSE 65595
// sTank := true ;
65587: LD_ADDR_EXP 127
65591: PUSH
65592: LD_INT 1
65594: ST_TO_ADDR
// if p3 = 20 then
65595: LD_VAR 0 3
65599: PUSH
65600: LD_INT 20
65602: EQUAL
65603: IFFALSE 65613
// sRemote := true ;
65605: LD_ADDR_EXP 128
65609: PUSH
65610: LD_INT 1
65612: ST_TO_ADDR
// if p3 = 21 then
65613: LD_VAR 0 3
65617: PUSH
65618: LD_INT 21
65620: EQUAL
65621: IFFALSE 65631
// sPowell := true ;
65623: LD_ADDR_EXP 129
65627: PUSH
65628: LD_INT 1
65630: ST_TO_ADDR
// if p3 = 22 then
65631: LD_VAR 0 3
65635: PUSH
65636: LD_INT 22
65638: EQUAL
65639: IFFALSE 65649
// sTeleport := true ;
65641: LD_ADDR_EXP 132
65645: PUSH
65646: LD_INT 1
65648: ST_TO_ADDR
// if p3 = 23 then
65649: LD_VAR 0 3
65653: PUSH
65654: LD_INT 23
65656: EQUAL
65657: IFFALSE 65667
// sOilTower := true ;
65659: LD_ADDR_EXP 134
65663: PUSH
65664: LD_INT 1
65666: ST_TO_ADDR
// if p3 = 24 then
65667: LD_VAR 0 3
65671: PUSH
65672: LD_INT 24
65674: EQUAL
65675: IFFALSE 65685
// sShovel := true ;
65677: LD_ADDR_EXP 135
65681: PUSH
65682: LD_INT 1
65684: ST_TO_ADDR
// if p3 = 25 then
65685: LD_VAR 0 3
65689: PUSH
65690: LD_INT 25
65692: EQUAL
65693: IFFALSE 65703
// sSheik := true ;
65695: LD_ADDR_EXP 136
65699: PUSH
65700: LD_INT 1
65702: ST_TO_ADDR
// if p3 = 26 then
65703: LD_VAR 0 3
65707: PUSH
65708: LD_INT 26
65710: EQUAL
65711: IFFALSE 65721
// sEarthquake := true ;
65713: LD_ADDR_EXP 138
65717: PUSH
65718: LD_INT 1
65720: ST_TO_ADDR
// if p3 = 27 then
65721: LD_VAR 0 3
65725: PUSH
65726: LD_INT 27
65728: EQUAL
65729: IFFALSE 65739
// sAI := true ;
65731: LD_ADDR_EXP 139
65735: PUSH
65736: LD_INT 1
65738: ST_TO_ADDR
// if p3 = 28 then
65739: LD_VAR 0 3
65743: PUSH
65744: LD_INT 28
65746: EQUAL
65747: IFFALSE 65757
// sCargo := true ;
65749: LD_ADDR_EXP 142
65753: PUSH
65754: LD_INT 1
65756: ST_TO_ADDR
// if p3 = 29 then
65757: LD_VAR 0 3
65761: PUSH
65762: LD_INT 29
65764: EQUAL
65765: IFFALSE 65775
// sDLaser := true ;
65767: LD_ADDR_EXP 143
65771: PUSH
65772: LD_INT 1
65774: ST_TO_ADDR
// if p3 = 30 then
65775: LD_VAR 0 3
65779: PUSH
65780: LD_INT 30
65782: EQUAL
65783: IFFALSE 65793
// sExchange := true ;
65785: LD_ADDR_EXP 144
65789: PUSH
65790: LD_INT 1
65792: ST_TO_ADDR
// if p3 = 31 then
65793: LD_VAR 0 3
65797: PUSH
65798: LD_INT 31
65800: EQUAL
65801: IFFALSE 65811
// sFac := true ;
65803: LD_ADDR_EXP 145
65807: PUSH
65808: LD_INT 1
65810: ST_TO_ADDR
// if p3 = 32 then
65811: LD_VAR 0 3
65815: PUSH
65816: LD_INT 32
65818: EQUAL
65819: IFFALSE 65829
// sPower := true ;
65821: LD_ADDR_EXP 146
65825: PUSH
65826: LD_INT 1
65828: ST_TO_ADDR
// if p3 = 33 then
65829: LD_VAR 0 3
65833: PUSH
65834: LD_INT 33
65836: EQUAL
65837: IFFALSE 65847
// sRandom := true ;
65839: LD_ADDR_EXP 147
65843: PUSH
65844: LD_INT 1
65846: ST_TO_ADDR
// if p3 = 34 then
65847: LD_VAR 0 3
65851: PUSH
65852: LD_INT 34
65854: EQUAL
65855: IFFALSE 65865
// sShield := true ;
65857: LD_ADDR_EXP 148
65861: PUSH
65862: LD_INT 1
65864: ST_TO_ADDR
// if p3 = 35 then
65865: LD_VAR 0 3
65869: PUSH
65870: LD_INT 35
65872: EQUAL
65873: IFFALSE 65883
// sTime := true ;
65875: LD_ADDR_EXP 149
65879: PUSH
65880: LD_INT 1
65882: ST_TO_ADDR
// if p3 = 36 then
65883: LD_VAR 0 3
65887: PUSH
65888: LD_INT 36
65890: EQUAL
65891: IFFALSE 65901
// sTools := true ;
65893: LD_ADDR_EXP 150
65897: PUSH
65898: LD_INT 1
65900: ST_TO_ADDR
// if p3 = 101 then
65901: LD_VAR 0 3
65905: PUSH
65906: LD_INT 101
65908: EQUAL
65909: IFFALSE 65919
// sSold := true ;
65911: LD_ADDR_EXP 115
65915: PUSH
65916: LD_INT 1
65918: ST_TO_ADDR
// if p3 = 102 then
65919: LD_VAR 0 3
65923: PUSH
65924: LD_INT 102
65926: EQUAL
65927: IFFALSE 65937
// sDiff := true ;
65929: LD_ADDR_EXP 116
65933: PUSH
65934: LD_INT 1
65936: ST_TO_ADDR
// if p3 = 103 then
65937: LD_VAR 0 3
65941: PUSH
65942: LD_INT 103
65944: EQUAL
65945: IFFALSE 65955
// sFog := true ;
65947: LD_ADDR_EXP 119
65951: PUSH
65952: LD_INT 1
65954: ST_TO_ADDR
// if p3 = 104 then
65955: LD_VAR 0 3
65959: PUSH
65960: LD_INT 104
65962: EQUAL
65963: IFFALSE 65973
// sReset := true ;
65965: LD_ADDR_EXP 120
65969: PUSH
65970: LD_INT 1
65972: ST_TO_ADDR
// if p3 = 105 then
65973: LD_VAR 0 3
65977: PUSH
65978: LD_INT 105
65980: EQUAL
65981: IFFALSE 65991
// sSun := true ;
65983: LD_ADDR_EXP 121
65987: PUSH
65988: LD_INT 1
65990: ST_TO_ADDR
// if p3 = 106 then
65991: LD_VAR 0 3
65995: PUSH
65996: LD_INT 106
65998: EQUAL
65999: IFFALSE 66009
// sTiger := true ;
66001: LD_ADDR_EXP 117
66005: PUSH
66006: LD_INT 1
66008: ST_TO_ADDR
// if p3 = 107 then
66009: LD_VAR 0 3
66013: PUSH
66014: LD_INT 107
66016: EQUAL
66017: IFFALSE 66027
// sBomb := true ;
66019: LD_ADDR_EXP 118
66023: PUSH
66024: LD_INT 1
66026: ST_TO_ADDR
// if p3 = 108 then
66027: LD_VAR 0 3
66031: PUSH
66032: LD_INT 108
66034: EQUAL
66035: IFFALSE 66045
// sWound := true ;
66037: LD_ADDR_EXP 126
66041: PUSH
66042: LD_INT 1
66044: ST_TO_ADDR
// if p3 = 109 then
66045: LD_VAR 0 3
66049: PUSH
66050: LD_INT 109
66052: EQUAL
66053: IFFALSE 66063
// sBetray := true ;
66055: LD_ADDR_EXP 130
66059: PUSH
66060: LD_INT 1
66062: ST_TO_ADDR
// if p3 = 110 then
66063: LD_VAR 0 3
66067: PUSH
66068: LD_INT 110
66070: EQUAL
66071: IFFALSE 66081
// sContamin := true ;
66073: LD_ADDR_EXP 131
66077: PUSH
66078: LD_INT 1
66080: ST_TO_ADDR
// if p3 = 111 then
66081: LD_VAR 0 3
66085: PUSH
66086: LD_INT 111
66088: EQUAL
66089: IFFALSE 66099
// sOil := true ;
66091: LD_ADDR_EXP 133
66095: PUSH
66096: LD_INT 1
66098: ST_TO_ADDR
// if p3 = 112 then
66099: LD_VAR 0 3
66103: PUSH
66104: LD_INT 112
66106: EQUAL
66107: IFFALSE 66117
// sStu := true ;
66109: LD_ADDR_EXP 137
66113: PUSH
66114: LD_INT 1
66116: ST_TO_ADDR
// if p3 = 113 then
66117: LD_VAR 0 3
66121: PUSH
66122: LD_INT 113
66124: EQUAL
66125: IFFALSE 66135
// sBazooka := true ;
66127: LD_ADDR_EXP 140
66131: PUSH
66132: LD_INT 1
66134: ST_TO_ADDR
// if p3 = 114 then
66135: LD_VAR 0 3
66139: PUSH
66140: LD_INT 114
66142: EQUAL
66143: IFFALSE 66153
// sMortar := true ;
66145: LD_ADDR_EXP 141
66149: PUSH
66150: LD_INT 1
66152: ST_TO_ADDR
// if p3 = 115 then
66153: LD_VAR 0 3
66157: PUSH
66158: LD_INT 115
66160: EQUAL
66161: IFFALSE 66171
// sRanger := true ;
66163: LD_ADDR_EXP 151
66167: PUSH
66168: LD_INT 1
66170: ST_TO_ADDR
// if p3 = 116 then
66171: LD_VAR 0 3
66175: PUSH
66176: LD_INT 116
66178: EQUAL
66179: IFFALSE 66189
// sComputer := true ;
66181: LD_ADDR_EXP 152
66185: PUSH
66186: LD_INT 1
66188: ST_TO_ADDR
// if p3 = 117 then
66189: LD_VAR 0 3
66193: PUSH
66194: LD_INT 117
66196: EQUAL
66197: IFFALSE 66207
// s30 := true ;
66199: LD_ADDR_EXP 153
66203: PUSH
66204: LD_INT 1
66206: ST_TO_ADDR
// if p3 = 118 then
66207: LD_VAR 0 3
66211: PUSH
66212: LD_INT 118
66214: EQUAL
66215: IFFALSE 66225
// s60 := true ;
66217: LD_ADDR_EXP 154
66221: PUSH
66222: LD_INT 1
66224: ST_TO_ADDR
// end ; if p2 = hack_mode then
66225: LD_VAR 0 2
66229: PUSH
66230: LD_INT 101
66232: EQUAL
66233: IFFALSE 66361
// begin case p3 of 1 :
66235: LD_VAR 0 3
66239: PUSH
66240: LD_INT 1
66242: DOUBLE
66243: EQUAL
66244: IFTRUE 66248
66246: GO 66255
66248: POP
// hHackUnlimitedResources ; 2 :
66249: CALL 78508 0 0
66253: GO 66361
66255: LD_INT 2
66257: DOUBLE
66258: EQUAL
66259: IFTRUE 66263
66261: GO 66270
66263: POP
// hHackSetLevel10 ; 3 :
66264: CALL 78641 0 0
66268: GO 66361
66270: LD_INT 3
66272: DOUBLE
66273: EQUAL
66274: IFTRUE 66278
66276: GO 66285
66278: POP
// hHackSetLevel10YourUnits ; 4 :
66279: CALL 78726 0 0
66283: GO 66361
66285: LD_INT 4
66287: DOUBLE
66288: EQUAL
66289: IFTRUE 66293
66291: GO 66300
66293: POP
// hHackInvincible ; 5 :
66294: CALL 79174 0 0
66298: GO 66361
66300: LD_INT 5
66302: DOUBLE
66303: EQUAL
66304: IFTRUE 66308
66306: GO 66315
66308: POP
// hHackInvisible ; 6 :
66309: CALL 79285 0 0
66313: GO 66361
66315: LD_INT 6
66317: DOUBLE
66318: EQUAL
66319: IFTRUE 66323
66321: GO 66330
66323: POP
// hHackChangeYourSide ; 7 :
66324: CALL 79342 0 0
66328: GO 66361
66330: LD_INT 7
66332: DOUBLE
66333: EQUAL
66334: IFTRUE 66338
66336: GO 66345
66338: POP
// hHackChangeUnitSide ; 8 :
66339: CALL 79384 0 0
66343: GO 66361
66345: LD_INT 8
66347: DOUBLE
66348: EQUAL
66349: IFTRUE 66353
66351: GO 66360
66353: POP
// hHackFog ; end ;
66354: CALL 79485 0 0
66358: GO 66361
66360: POP
// end ; if p2 = game_save_mode then
66361: LD_VAR 0 2
66365: PUSH
66366: LD_INT 102
66368: EQUAL
66369: IFFALSE 66424
// begin if p3 = 1 then
66371: LD_VAR 0 3
66375: PUSH
66376: LD_INT 1
66378: EQUAL
66379: IFFALSE 66391
// globalGameSaveCounter := p4 ;
66381: LD_ADDR_EXP 97
66385: PUSH
66386: LD_VAR 0 4
66390: ST_TO_ADDR
// if p3 = 2 and globalGameSaveCounter then
66391: LD_VAR 0 3
66395: PUSH
66396: LD_INT 2
66398: EQUAL
66399: PUSH
66400: LD_EXP 97
66404: AND
66405: IFFALSE 66424
// ToLua ( setGameSaveCounter( & globalGameSaveCounter & ) ) ;
66407: LD_STRING setGameSaveCounter(
66409: PUSH
66410: LD_EXP 97
66414: STR
66415: PUSH
66416: LD_STRING )
66418: STR
66419: PPUSH
66420: CALL_OW 559
// end ; end ;
66424: LD_VAR 0 7
66428: RET
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger , sComputer , s30 , s60 ; function InitStreamMode ; begin
66429: LD_INT 0
66431: PPUSH
// streamModeActive := false ;
66432: LD_ADDR_EXP 98
66436: PUSH
66437: LD_INT 0
66439: ST_TO_ADDR
// normalCounter := 36 ;
66440: LD_ADDR_EXP 99
66444: PUSH
66445: LD_INT 36
66447: ST_TO_ADDR
// hardcoreCounter := 18 ;
66448: LD_ADDR_EXP 100
66452: PUSH
66453: LD_INT 18
66455: ST_TO_ADDR
// sRocket := false ;
66456: LD_ADDR_EXP 103
66460: PUSH
66461: LD_INT 0
66463: ST_TO_ADDR
// sSpeed := false ;
66464: LD_ADDR_EXP 102
66468: PUSH
66469: LD_INT 0
66471: ST_TO_ADDR
// sEngine := false ;
66472: LD_ADDR_EXP 104
66476: PUSH
66477: LD_INT 0
66479: ST_TO_ADDR
// sSpec := false ;
66480: LD_ADDR_EXP 101
66484: PUSH
66485: LD_INT 0
66487: ST_TO_ADDR
// sLevel := false ;
66488: LD_ADDR_EXP 105
66492: PUSH
66493: LD_INT 0
66495: ST_TO_ADDR
// sArmoury := false ;
66496: LD_ADDR_EXP 106
66500: PUSH
66501: LD_INT 0
66503: ST_TO_ADDR
// sRadar := false ;
66504: LD_ADDR_EXP 107
66508: PUSH
66509: LD_INT 0
66511: ST_TO_ADDR
// sBunker := false ;
66512: LD_ADDR_EXP 108
66516: PUSH
66517: LD_INT 0
66519: ST_TO_ADDR
// sHack := false ;
66520: LD_ADDR_EXP 109
66524: PUSH
66525: LD_INT 0
66527: ST_TO_ADDR
// sFire := false ;
66528: LD_ADDR_EXP 110
66532: PUSH
66533: LD_INT 0
66535: ST_TO_ADDR
// sRefresh := false ;
66536: LD_ADDR_EXP 111
66540: PUSH
66541: LD_INT 0
66543: ST_TO_ADDR
// sExp := false ;
66544: LD_ADDR_EXP 112
66548: PUSH
66549: LD_INT 0
66551: ST_TO_ADDR
// sDepot := false ;
66552: LD_ADDR_EXP 113
66556: PUSH
66557: LD_INT 0
66559: ST_TO_ADDR
// sFlag := false ;
66560: LD_ADDR_EXP 114
66564: PUSH
66565: LD_INT 0
66567: ST_TO_ADDR
// sKamikadze := false ;
66568: LD_ADDR_EXP 122
66572: PUSH
66573: LD_INT 0
66575: ST_TO_ADDR
// sTroll := false ;
66576: LD_ADDR_EXP 123
66580: PUSH
66581: LD_INT 0
66583: ST_TO_ADDR
// sSlow := false ;
66584: LD_ADDR_EXP 124
66588: PUSH
66589: LD_INT 0
66591: ST_TO_ADDR
// sLack := false ;
66592: LD_ADDR_EXP 125
66596: PUSH
66597: LD_INT 0
66599: ST_TO_ADDR
// sTank := false ;
66600: LD_ADDR_EXP 127
66604: PUSH
66605: LD_INT 0
66607: ST_TO_ADDR
// sRemote := false ;
66608: LD_ADDR_EXP 128
66612: PUSH
66613: LD_INT 0
66615: ST_TO_ADDR
// sPowell := false ;
66616: LD_ADDR_EXP 129
66620: PUSH
66621: LD_INT 0
66623: ST_TO_ADDR
// sTeleport := false ;
66624: LD_ADDR_EXP 132
66628: PUSH
66629: LD_INT 0
66631: ST_TO_ADDR
// sOilTower := false ;
66632: LD_ADDR_EXP 134
66636: PUSH
66637: LD_INT 0
66639: ST_TO_ADDR
// sShovel := false ;
66640: LD_ADDR_EXP 135
66644: PUSH
66645: LD_INT 0
66647: ST_TO_ADDR
// sSheik := false ;
66648: LD_ADDR_EXP 136
66652: PUSH
66653: LD_INT 0
66655: ST_TO_ADDR
// sEarthquake := false ;
66656: LD_ADDR_EXP 138
66660: PUSH
66661: LD_INT 0
66663: ST_TO_ADDR
// sAI := false ;
66664: LD_ADDR_EXP 139
66668: PUSH
66669: LD_INT 0
66671: ST_TO_ADDR
// sCargo := false ;
66672: LD_ADDR_EXP 142
66676: PUSH
66677: LD_INT 0
66679: ST_TO_ADDR
// sDLaser := false ;
66680: LD_ADDR_EXP 143
66684: PUSH
66685: LD_INT 0
66687: ST_TO_ADDR
// sExchange := false ;
66688: LD_ADDR_EXP 144
66692: PUSH
66693: LD_INT 0
66695: ST_TO_ADDR
// sFac := false ;
66696: LD_ADDR_EXP 145
66700: PUSH
66701: LD_INT 0
66703: ST_TO_ADDR
// sPower := false ;
66704: LD_ADDR_EXP 146
66708: PUSH
66709: LD_INT 0
66711: ST_TO_ADDR
// sRandom := false ;
66712: LD_ADDR_EXP 147
66716: PUSH
66717: LD_INT 0
66719: ST_TO_ADDR
// sShield := false ;
66720: LD_ADDR_EXP 148
66724: PUSH
66725: LD_INT 0
66727: ST_TO_ADDR
// sTime := false ;
66728: LD_ADDR_EXP 149
66732: PUSH
66733: LD_INT 0
66735: ST_TO_ADDR
// sTools := false ;
66736: LD_ADDR_EXP 150
66740: PUSH
66741: LD_INT 0
66743: ST_TO_ADDR
// sSold := false ;
66744: LD_ADDR_EXP 115
66748: PUSH
66749: LD_INT 0
66751: ST_TO_ADDR
// sDiff := false ;
66752: LD_ADDR_EXP 116
66756: PUSH
66757: LD_INT 0
66759: ST_TO_ADDR
// sFog := false ;
66760: LD_ADDR_EXP 119
66764: PUSH
66765: LD_INT 0
66767: ST_TO_ADDR
// sReset := false ;
66768: LD_ADDR_EXP 120
66772: PUSH
66773: LD_INT 0
66775: ST_TO_ADDR
// sSun := false ;
66776: LD_ADDR_EXP 121
66780: PUSH
66781: LD_INT 0
66783: ST_TO_ADDR
// sTiger := false ;
66784: LD_ADDR_EXP 117
66788: PUSH
66789: LD_INT 0
66791: ST_TO_ADDR
// sBomb := false ;
66792: LD_ADDR_EXP 118
66796: PUSH
66797: LD_INT 0
66799: ST_TO_ADDR
// sWound := false ;
66800: LD_ADDR_EXP 126
66804: PUSH
66805: LD_INT 0
66807: ST_TO_ADDR
// sBetray := false ;
66808: LD_ADDR_EXP 130
66812: PUSH
66813: LD_INT 0
66815: ST_TO_ADDR
// sContamin := false ;
66816: LD_ADDR_EXP 131
66820: PUSH
66821: LD_INT 0
66823: ST_TO_ADDR
// sOil := false ;
66824: LD_ADDR_EXP 133
66828: PUSH
66829: LD_INT 0
66831: ST_TO_ADDR
// sStu := false ;
66832: LD_ADDR_EXP 137
66836: PUSH
66837: LD_INT 0
66839: ST_TO_ADDR
// sBazooka := false ;
66840: LD_ADDR_EXP 140
66844: PUSH
66845: LD_INT 0
66847: ST_TO_ADDR
// sMortar := false ;
66848: LD_ADDR_EXP 141
66852: PUSH
66853: LD_INT 0
66855: ST_TO_ADDR
// sRanger := false ;
66856: LD_ADDR_EXP 151
66860: PUSH
66861: LD_INT 0
66863: ST_TO_ADDR
// sComputer := false ;
66864: LD_ADDR_EXP 152
66868: PUSH
66869: LD_INT 0
66871: ST_TO_ADDR
// s30 := false ;
66872: LD_ADDR_EXP 153
66876: PUSH
66877: LD_INT 0
66879: ST_TO_ADDR
// s60 := false ;
66880: LD_ADDR_EXP 154
66884: PUSH
66885: LD_INT 0
66887: ST_TO_ADDR
// end ;
66888: LD_VAR 0 1
66892: RET
// function DefineStreamItems ( isGameLoad ) ; var tmp , flags , normal , hardcore , active , i ; begin
66893: LD_INT 0
66895: PPUSH
66896: PPUSH
66897: PPUSH
66898: PPUSH
66899: PPUSH
66900: PPUSH
66901: PPUSH
// result := [ ] ;
66902: LD_ADDR_VAR 0 2
66906: PUSH
66907: EMPTY
66908: ST_TO_ADDR
// if campaign_id = 1 then
66909: LD_OWVAR 69
66913: PUSH
66914: LD_INT 1
66916: EQUAL
66917: IFFALSE 70083
// begin case mission_number of 1 :
66919: LD_OWVAR 70
66923: PUSH
66924: LD_INT 1
66926: DOUBLE
66927: EQUAL
66928: IFTRUE 66932
66930: GO 67008
66932: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 , 116 , 117 , 118 ] ] ; 2 :
66933: LD_ADDR_VAR 0 2
66937: PUSH
66938: LD_INT 2
66940: PUSH
66941: LD_INT 4
66943: PUSH
66944: LD_INT 11
66946: PUSH
66947: LD_INT 12
66949: PUSH
66950: LD_INT 15
66952: PUSH
66953: LD_INT 16
66955: PUSH
66956: LD_INT 22
66958: PUSH
66959: LD_INT 23
66961: PUSH
66962: LD_INT 26
66964: PUSH
66965: EMPTY
66966: LIST
66967: LIST
66968: LIST
66969: LIST
66970: LIST
66971: LIST
66972: LIST
66973: LIST
66974: LIST
66975: PUSH
66976: LD_INT 101
66978: PUSH
66979: LD_INT 102
66981: PUSH
66982: LD_INT 106
66984: PUSH
66985: LD_INT 116
66987: PUSH
66988: LD_INT 117
66990: PUSH
66991: LD_INT 118
66993: PUSH
66994: EMPTY
66995: LIST
66996: LIST
66997: LIST
66998: LIST
66999: LIST
67000: LIST
67001: PUSH
67002: EMPTY
67003: LIST
67004: LIST
67005: ST_TO_ADDR
67006: GO 70081
67008: LD_INT 2
67010: DOUBLE
67011: EQUAL
67012: IFTRUE 67016
67014: GO 67100
67016: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 3 :
67017: LD_ADDR_VAR 0 2
67021: PUSH
67022: LD_INT 2
67024: PUSH
67025: LD_INT 4
67027: PUSH
67028: LD_INT 11
67030: PUSH
67031: LD_INT 12
67033: PUSH
67034: LD_INT 15
67036: PUSH
67037: LD_INT 16
67039: PUSH
67040: LD_INT 22
67042: PUSH
67043: LD_INT 23
67045: PUSH
67046: LD_INT 26
67048: PUSH
67049: EMPTY
67050: LIST
67051: LIST
67052: LIST
67053: LIST
67054: LIST
67055: LIST
67056: LIST
67057: LIST
67058: LIST
67059: PUSH
67060: LD_INT 101
67062: PUSH
67063: LD_INT 102
67065: PUSH
67066: LD_INT 105
67068: PUSH
67069: LD_INT 106
67071: PUSH
67072: LD_INT 108
67074: PUSH
67075: LD_INT 116
67077: PUSH
67078: LD_INT 117
67080: PUSH
67081: LD_INT 118
67083: PUSH
67084: EMPTY
67085: LIST
67086: LIST
67087: LIST
67088: LIST
67089: LIST
67090: LIST
67091: LIST
67092: LIST
67093: PUSH
67094: EMPTY
67095: LIST
67096: LIST
67097: ST_TO_ADDR
67098: GO 70081
67100: LD_INT 3
67102: DOUBLE
67103: EQUAL
67104: IFTRUE 67108
67106: GO 67196
67108: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 4 :
67109: LD_ADDR_VAR 0 2
67113: PUSH
67114: LD_INT 2
67116: PUSH
67117: LD_INT 4
67119: PUSH
67120: LD_INT 5
67122: PUSH
67123: LD_INT 11
67125: PUSH
67126: LD_INT 12
67128: PUSH
67129: LD_INT 15
67131: PUSH
67132: LD_INT 16
67134: PUSH
67135: LD_INT 22
67137: PUSH
67138: LD_INT 26
67140: PUSH
67141: LD_INT 36
67143: PUSH
67144: EMPTY
67145: LIST
67146: LIST
67147: LIST
67148: LIST
67149: LIST
67150: LIST
67151: LIST
67152: LIST
67153: LIST
67154: LIST
67155: PUSH
67156: LD_INT 101
67158: PUSH
67159: LD_INT 102
67161: PUSH
67162: LD_INT 105
67164: PUSH
67165: LD_INT 106
67167: PUSH
67168: LD_INT 108
67170: PUSH
67171: LD_INT 116
67173: PUSH
67174: LD_INT 117
67176: PUSH
67177: LD_INT 118
67179: PUSH
67180: EMPTY
67181: LIST
67182: LIST
67183: LIST
67184: LIST
67185: LIST
67186: LIST
67187: LIST
67188: LIST
67189: PUSH
67190: EMPTY
67191: LIST
67192: LIST
67193: ST_TO_ADDR
67194: GO 70081
67196: LD_INT 4
67198: DOUBLE
67199: EQUAL
67200: IFTRUE 67204
67202: GO 67300
67204: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 5 :
67205: LD_ADDR_VAR 0 2
67209: PUSH
67210: LD_INT 2
67212: PUSH
67213: LD_INT 4
67215: PUSH
67216: LD_INT 5
67218: PUSH
67219: LD_INT 8
67221: PUSH
67222: LD_INT 11
67224: PUSH
67225: LD_INT 12
67227: PUSH
67228: LD_INT 15
67230: PUSH
67231: LD_INT 16
67233: PUSH
67234: LD_INT 22
67236: PUSH
67237: LD_INT 23
67239: PUSH
67240: LD_INT 26
67242: PUSH
67243: LD_INT 36
67245: PUSH
67246: EMPTY
67247: LIST
67248: LIST
67249: LIST
67250: LIST
67251: LIST
67252: LIST
67253: LIST
67254: LIST
67255: LIST
67256: LIST
67257: LIST
67258: LIST
67259: PUSH
67260: LD_INT 101
67262: PUSH
67263: LD_INT 102
67265: PUSH
67266: LD_INT 105
67268: PUSH
67269: LD_INT 106
67271: PUSH
67272: LD_INT 108
67274: PUSH
67275: LD_INT 116
67277: PUSH
67278: LD_INT 117
67280: PUSH
67281: LD_INT 118
67283: PUSH
67284: EMPTY
67285: LIST
67286: LIST
67287: LIST
67288: LIST
67289: LIST
67290: LIST
67291: LIST
67292: LIST
67293: PUSH
67294: EMPTY
67295: LIST
67296: LIST
67297: ST_TO_ADDR
67298: GO 70081
67300: LD_INT 5
67302: DOUBLE
67303: EQUAL
67304: IFTRUE 67308
67306: GO 67420
67308: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 6 :
67309: LD_ADDR_VAR 0 2
67313: PUSH
67314: LD_INT 2
67316: PUSH
67317: LD_INT 4
67319: PUSH
67320: LD_INT 5
67322: PUSH
67323: LD_INT 6
67325: PUSH
67326: LD_INT 8
67328: PUSH
67329: LD_INT 11
67331: PUSH
67332: LD_INT 12
67334: PUSH
67335: LD_INT 15
67337: PUSH
67338: LD_INT 16
67340: PUSH
67341: LD_INT 22
67343: PUSH
67344: LD_INT 23
67346: PUSH
67347: LD_INT 25
67349: PUSH
67350: LD_INT 26
67352: PUSH
67353: LD_INT 36
67355: PUSH
67356: EMPTY
67357: LIST
67358: LIST
67359: LIST
67360: LIST
67361: LIST
67362: LIST
67363: LIST
67364: LIST
67365: LIST
67366: LIST
67367: LIST
67368: LIST
67369: LIST
67370: LIST
67371: PUSH
67372: LD_INT 101
67374: PUSH
67375: LD_INT 102
67377: PUSH
67378: LD_INT 105
67380: PUSH
67381: LD_INT 106
67383: PUSH
67384: LD_INT 108
67386: PUSH
67387: LD_INT 109
67389: PUSH
67390: LD_INT 112
67392: PUSH
67393: LD_INT 116
67395: PUSH
67396: LD_INT 117
67398: PUSH
67399: LD_INT 118
67401: PUSH
67402: EMPTY
67403: LIST
67404: LIST
67405: LIST
67406: LIST
67407: LIST
67408: LIST
67409: LIST
67410: LIST
67411: LIST
67412: LIST
67413: PUSH
67414: EMPTY
67415: LIST
67416: LIST
67417: ST_TO_ADDR
67418: GO 70081
67420: LD_INT 6
67422: DOUBLE
67423: EQUAL
67424: IFTRUE 67428
67426: GO 67560
67428: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 7 :
67429: LD_ADDR_VAR 0 2
67433: PUSH
67434: LD_INT 2
67436: PUSH
67437: LD_INT 4
67439: PUSH
67440: LD_INT 5
67442: PUSH
67443: LD_INT 6
67445: PUSH
67446: LD_INT 8
67448: PUSH
67449: LD_INT 11
67451: PUSH
67452: LD_INT 12
67454: PUSH
67455: LD_INT 15
67457: PUSH
67458: LD_INT 16
67460: PUSH
67461: LD_INT 20
67463: PUSH
67464: LD_INT 21
67466: PUSH
67467: LD_INT 22
67469: PUSH
67470: LD_INT 23
67472: PUSH
67473: LD_INT 25
67475: PUSH
67476: LD_INT 26
67478: PUSH
67479: LD_INT 30
67481: PUSH
67482: LD_INT 31
67484: PUSH
67485: LD_INT 32
67487: PUSH
67488: LD_INT 36
67490: PUSH
67491: EMPTY
67492: LIST
67493: LIST
67494: LIST
67495: LIST
67496: LIST
67497: LIST
67498: LIST
67499: LIST
67500: LIST
67501: LIST
67502: LIST
67503: LIST
67504: LIST
67505: LIST
67506: LIST
67507: LIST
67508: LIST
67509: LIST
67510: LIST
67511: PUSH
67512: LD_INT 101
67514: PUSH
67515: LD_INT 102
67517: PUSH
67518: LD_INT 105
67520: PUSH
67521: LD_INT 106
67523: PUSH
67524: LD_INT 108
67526: PUSH
67527: LD_INT 109
67529: PUSH
67530: LD_INT 112
67532: PUSH
67533: LD_INT 116
67535: PUSH
67536: LD_INT 117
67538: PUSH
67539: LD_INT 118
67541: PUSH
67542: EMPTY
67543: LIST
67544: LIST
67545: LIST
67546: LIST
67547: LIST
67548: LIST
67549: LIST
67550: LIST
67551: LIST
67552: LIST
67553: PUSH
67554: EMPTY
67555: LIST
67556: LIST
67557: ST_TO_ADDR
67558: GO 70081
67560: LD_INT 7
67562: DOUBLE
67563: EQUAL
67564: IFTRUE 67568
67566: GO 67680
67568: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 , 116 , 117 , 118 ] ] ; 8 :
67569: LD_ADDR_VAR 0 2
67573: PUSH
67574: LD_INT 2
67576: PUSH
67577: LD_INT 4
67579: PUSH
67580: LD_INT 5
67582: PUSH
67583: LD_INT 7
67585: PUSH
67586: LD_INT 11
67588: PUSH
67589: LD_INT 12
67591: PUSH
67592: LD_INT 15
67594: PUSH
67595: LD_INT 16
67597: PUSH
67598: LD_INT 20
67600: PUSH
67601: LD_INT 21
67603: PUSH
67604: LD_INT 22
67606: PUSH
67607: LD_INT 23
67609: PUSH
67610: LD_INT 25
67612: PUSH
67613: LD_INT 26
67615: PUSH
67616: EMPTY
67617: LIST
67618: LIST
67619: LIST
67620: LIST
67621: LIST
67622: LIST
67623: LIST
67624: LIST
67625: LIST
67626: LIST
67627: LIST
67628: LIST
67629: LIST
67630: LIST
67631: PUSH
67632: LD_INT 101
67634: PUSH
67635: LD_INT 102
67637: PUSH
67638: LD_INT 103
67640: PUSH
67641: LD_INT 105
67643: PUSH
67644: LD_INT 106
67646: PUSH
67647: LD_INT 108
67649: PUSH
67650: LD_INT 112
67652: PUSH
67653: LD_INT 116
67655: PUSH
67656: LD_INT 117
67658: PUSH
67659: LD_INT 118
67661: PUSH
67662: EMPTY
67663: LIST
67664: LIST
67665: LIST
67666: LIST
67667: LIST
67668: LIST
67669: LIST
67670: LIST
67671: LIST
67672: LIST
67673: PUSH
67674: EMPTY
67675: LIST
67676: LIST
67677: ST_TO_ADDR
67678: GO 70081
67680: LD_INT 8
67682: DOUBLE
67683: EQUAL
67684: IFTRUE 67688
67686: GO 67828
67688: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 9 :
67689: LD_ADDR_VAR 0 2
67693: PUSH
67694: LD_INT 2
67696: PUSH
67697: LD_INT 4
67699: PUSH
67700: LD_INT 5
67702: PUSH
67703: LD_INT 6
67705: PUSH
67706: LD_INT 7
67708: PUSH
67709: LD_INT 8
67711: PUSH
67712: LD_INT 11
67714: PUSH
67715: LD_INT 12
67717: PUSH
67718: LD_INT 15
67720: PUSH
67721: LD_INT 16
67723: PUSH
67724: LD_INT 20
67726: PUSH
67727: LD_INT 21
67729: PUSH
67730: LD_INT 22
67732: PUSH
67733: LD_INT 23
67735: PUSH
67736: LD_INT 25
67738: PUSH
67739: LD_INT 26
67741: PUSH
67742: LD_INT 30
67744: PUSH
67745: LD_INT 31
67747: PUSH
67748: LD_INT 32
67750: PUSH
67751: LD_INT 36
67753: PUSH
67754: EMPTY
67755: LIST
67756: LIST
67757: LIST
67758: LIST
67759: LIST
67760: LIST
67761: LIST
67762: LIST
67763: LIST
67764: LIST
67765: LIST
67766: LIST
67767: LIST
67768: LIST
67769: LIST
67770: LIST
67771: LIST
67772: LIST
67773: LIST
67774: LIST
67775: PUSH
67776: LD_INT 101
67778: PUSH
67779: LD_INT 102
67781: PUSH
67782: LD_INT 103
67784: PUSH
67785: LD_INT 105
67787: PUSH
67788: LD_INT 106
67790: PUSH
67791: LD_INT 108
67793: PUSH
67794: LD_INT 109
67796: PUSH
67797: LD_INT 112
67799: PUSH
67800: LD_INT 116
67802: PUSH
67803: LD_INT 117
67805: PUSH
67806: LD_INT 118
67808: PUSH
67809: EMPTY
67810: LIST
67811: LIST
67812: LIST
67813: LIST
67814: LIST
67815: LIST
67816: LIST
67817: LIST
67818: LIST
67819: LIST
67820: LIST
67821: PUSH
67822: EMPTY
67823: LIST
67824: LIST
67825: ST_TO_ADDR
67826: GO 70081
67828: LD_INT 9
67830: DOUBLE
67831: EQUAL
67832: IFTRUE 67836
67834: GO 67984
67836: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 , 116 , 117 , 118 ] ] ; 10 :
67837: LD_ADDR_VAR 0 2
67841: PUSH
67842: LD_INT 2
67844: PUSH
67845: LD_INT 4
67847: PUSH
67848: LD_INT 5
67850: PUSH
67851: LD_INT 6
67853: PUSH
67854: LD_INT 7
67856: PUSH
67857: LD_INT 8
67859: PUSH
67860: LD_INT 11
67862: PUSH
67863: LD_INT 12
67865: PUSH
67866: LD_INT 15
67868: PUSH
67869: LD_INT 16
67871: PUSH
67872: LD_INT 20
67874: PUSH
67875: LD_INT 21
67877: PUSH
67878: LD_INT 22
67880: PUSH
67881: LD_INT 23
67883: PUSH
67884: LD_INT 25
67886: PUSH
67887: LD_INT 26
67889: PUSH
67890: LD_INT 28
67892: PUSH
67893: LD_INT 30
67895: PUSH
67896: LD_INT 31
67898: PUSH
67899: LD_INT 32
67901: PUSH
67902: LD_INT 36
67904: PUSH
67905: EMPTY
67906: LIST
67907: LIST
67908: LIST
67909: LIST
67910: LIST
67911: LIST
67912: LIST
67913: LIST
67914: LIST
67915: LIST
67916: LIST
67917: LIST
67918: LIST
67919: LIST
67920: LIST
67921: LIST
67922: LIST
67923: LIST
67924: LIST
67925: LIST
67926: LIST
67927: PUSH
67928: LD_INT 101
67930: PUSH
67931: LD_INT 102
67933: PUSH
67934: LD_INT 103
67936: PUSH
67937: LD_INT 105
67939: PUSH
67940: LD_INT 106
67942: PUSH
67943: LD_INT 108
67945: PUSH
67946: LD_INT 109
67948: PUSH
67949: LD_INT 112
67951: PUSH
67952: LD_INT 114
67954: PUSH
67955: LD_INT 116
67957: PUSH
67958: LD_INT 117
67960: PUSH
67961: LD_INT 118
67963: PUSH
67964: EMPTY
67965: LIST
67966: LIST
67967: LIST
67968: LIST
67969: LIST
67970: LIST
67971: LIST
67972: LIST
67973: LIST
67974: LIST
67975: LIST
67976: LIST
67977: PUSH
67978: EMPTY
67979: LIST
67980: LIST
67981: ST_TO_ADDR
67982: GO 70081
67984: LD_INT 10
67986: DOUBLE
67987: EQUAL
67988: IFTRUE 67992
67990: GO 68188
67992: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 11 :
67993: LD_ADDR_VAR 0 2
67997: PUSH
67998: LD_INT 2
68000: PUSH
68001: LD_INT 4
68003: PUSH
68004: LD_INT 5
68006: PUSH
68007: LD_INT 6
68009: PUSH
68010: LD_INT 7
68012: PUSH
68013: LD_INT 8
68015: PUSH
68016: LD_INT 9
68018: PUSH
68019: LD_INT 10
68021: PUSH
68022: LD_INT 11
68024: PUSH
68025: LD_INT 12
68027: PUSH
68028: LD_INT 13
68030: PUSH
68031: LD_INT 14
68033: PUSH
68034: LD_INT 15
68036: PUSH
68037: LD_INT 16
68039: PUSH
68040: LD_INT 17
68042: PUSH
68043: LD_INT 18
68045: PUSH
68046: LD_INT 19
68048: PUSH
68049: LD_INT 20
68051: PUSH
68052: LD_INT 21
68054: PUSH
68055: LD_INT 22
68057: PUSH
68058: LD_INT 23
68060: PUSH
68061: LD_INT 24
68063: PUSH
68064: LD_INT 25
68066: PUSH
68067: LD_INT 26
68069: PUSH
68070: LD_INT 28
68072: PUSH
68073: LD_INT 30
68075: PUSH
68076: LD_INT 31
68078: PUSH
68079: LD_INT 32
68081: PUSH
68082: LD_INT 36
68084: PUSH
68085: EMPTY
68086: LIST
68087: LIST
68088: LIST
68089: LIST
68090: LIST
68091: LIST
68092: LIST
68093: LIST
68094: LIST
68095: LIST
68096: LIST
68097: LIST
68098: LIST
68099: LIST
68100: LIST
68101: LIST
68102: LIST
68103: LIST
68104: LIST
68105: LIST
68106: LIST
68107: LIST
68108: LIST
68109: LIST
68110: LIST
68111: LIST
68112: LIST
68113: LIST
68114: LIST
68115: PUSH
68116: LD_INT 101
68118: PUSH
68119: LD_INT 102
68121: PUSH
68122: LD_INT 103
68124: PUSH
68125: LD_INT 104
68127: PUSH
68128: LD_INT 105
68130: PUSH
68131: LD_INT 106
68133: PUSH
68134: LD_INT 107
68136: PUSH
68137: LD_INT 108
68139: PUSH
68140: LD_INT 109
68142: PUSH
68143: LD_INT 110
68145: PUSH
68146: LD_INT 111
68148: PUSH
68149: LD_INT 112
68151: PUSH
68152: LD_INT 114
68154: PUSH
68155: LD_INT 116
68157: PUSH
68158: LD_INT 117
68160: PUSH
68161: LD_INT 118
68163: PUSH
68164: EMPTY
68165: LIST
68166: LIST
68167: LIST
68168: LIST
68169: LIST
68170: LIST
68171: LIST
68172: LIST
68173: LIST
68174: LIST
68175: LIST
68176: LIST
68177: LIST
68178: LIST
68179: LIST
68180: LIST
68181: PUSH
68182: EMPTY
68183: LIST
68184: LIST
68185: ST_TO_ADDR
68186: GO 70081
68188: LD_INT 11
68190: DOUBLE
68191: EQUAL
68192: IFTRUE 68196
68194: GO 68400
68196: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 12 :
68197: LD_ADDR_VAR 0 2
68201: PUSH
68202: LD_INT 2
68204: PUSH
68205: LD_INT 3
68207: PUSH
68208: LD_INT 4
68210: PUSH
68211: LD_INT 5
68213: PUSH
68214: LD_INT 6
68216: PUSH
68217: LD_INT 7
68219: PUSH
68220: LD_INT 8
68222: PUSH
68223: LD_INT 9
68225: PUSH
68226: LD_INT 10
68228: PUSH
68229: LD_INT 11
68231: PUSH
68232: LD_INT 12
68234: PUSH
68235: LD_INT 13
68237: PUSH
68238: LD_INT 14
68240: PUSH
68241: LD_INT 15
68243: PUSH
68244: LD_INT 16
68246: PUSH
68247: LD_INT 17
68249: PUSH
68250: LD_INT 18
68252: PUSH
68253: LD_INT 19
68255: PUSH
68256: LD_INT 20
68258: PUSH
68259: LD_INT 21
68261: PUSH
68262: LD_INT 22
68264: PUSH
68265: LD_INT 23
68267: PUSH
68268: LD_INT 24
68270: PUSH
68271: LD_INT 25
68273: PUSH
68274: LD_INT 26
68276: PUSH
68277: LD_INT 28
68279: PUSH
68280: LD_INT 30
68282: PUSH
68283: LD_INT 31
68285: PUSH
68286: LD_INT 32
68288: PUSH
68289: LD_INT 34
68291: PUSH
68292: LD_INT 36
68294: PUSH
68295: EMPTY
68296: LIST
68297: LIST
68298: LIST
68299: LIST
68300: LIST
68301: LIST
68302: LIST
68303: LIST
68304: LIST
68305: LIST
68306: LIST
68307: LIST
68308: LIST
68309: LIST
68310: LIST
68311: LIST
68312: LIST
68313: LIST
68314: LIST
68315: LIST
68316: LIST
68317: LIST
68318: LIST
68319: LIST
68320: LIST
68321: LIST
68322: LIST
68323: LIST
68324: LIST
68325: LIST
68326: LIST
68327: PUSH
68328: LD_INT 101
68330: PUSH
68331: LD_INT 102
68333: PUSH
68334: LD_INT 103
68336: PUSH
68337: LD_INT 104
68339: PUSH
68340: LD_INT 105
68342: PUSH
68343: LD_INT 106
68345: PUSH
68346: LD_INT 107
68348: PUSH
68349: LD_INT 108
68351: PUSH
68352: LD_INT 109
68354: PUSH
68355: LD_INT 110
68357: PUSH
68358: LD_INT 111
68360: PUSH
68361: LD_INT 112
68363: PUSH
68364: LD_INT 114
68366: PUSH
68367: LD_INT 116
68369: PUSH
68370: LD_INT 117
68372: PUSH
68373: LD_INT 118
68375: PUSH
68376: EMPTY
68377: LIST
68378: LIST
68379: LIST
68380: LIST
68381: LIST
68382: LIST
68383: LIST
68384: LIST
68385: LIST
68386: LIST
68387: LIST
68388: LIST
68389: LIST
68390: LIST
68391: LIST
68392: LIST
68393: PUSH
68394: EMPTY
68395: LIST
68396: LIST
68397: ST_TO_ADDR
68398: GO 70081
68400: LD_INT 12
68402: DOUBLE
68403: EQUAL
68404: IFTRUE 68408
68406: GO 68628
68408: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 13 :
68409: LD_ADDR_VAR 0 2
68413: PUSH
68414: LD_INT 1
68416: PUSH
68417: LD_INT 2
68419: PUSH
68420: LD_INT 3
68422: PUSH
68423: LD_INT 4
68425: PUSH
68426: LD_INT 5
68428: PUSH
68429: LD_INT 6
68431: PUSH
68432: LD_INT 7
68434: PUSH
68435: LD_INT 8
68437: PUSH
68438: LD_INT 9
68440: PUSH
68441: LD_INT 10
68443: PUSH
68444: LD_INT 11
68446: PUSH
68447: LD_INT 12
68449: PUSH
68450: LD_INT 13
68452: PUSH
68453: LD_INT 14
68455: PUSH
68456: LD_INT 15
68458: PUSH
68459: LD_INT 16
68461: PUSH
68462: LD_INT 17
68464: PUSH
68465: LD_INT 18
68467: PUSH
68468: LD_INT 19
68470: PUSH
68471: LD_INT 20
68473: PUSH
68474: LD_INT 21
68476: PUSH
68477: LD_INT 22
68479: PUSH
68480: LD_INT 23
68482: PUSH
68483: LD_INT 24
68485: PUSH
68486: LD_INT 25
68488: PUSH
68489: LD_INT 26
68491: PUSH
68492: LD_INT 27
68494: PUSH
68495: LD_INT 28
68497: PUSH
68498: LD_INT 30
68500: PUSH
68501: LD_INT 31
68503: PUSH
68504: LD_INT 32
68506: PUSH
68507: LD_INT 33
68509: PUSH
68510: LD_INT 34
68512: PUSH
68513: LD_INT 36
68515: PUSH
68516: EMPTY
68517: LIST
68518: LIST
68519: LIST
68520: LIST
68521: LIST
68522: LIST
68523: LIST
68524: LIST
68525: LIST
68526: LIST
68527: LIST
68528: LIST
68529: LIST
68530: LIST
68531: LIST
68532: LIST
68533: LIST
68534: LIST
68535: LIST
68536: LIST
68537: LIST
68538: LIST
68539: LIST
68540: LIST
68541: LIST
68542: LIST
68543: LIST
68544: LIST
68545: LIST
68546: LIST
68547: LIST
68548: LIST
68549: LIST
68550: LIST
68551: PUSH
68552: LD_INT 101
68554: PUSH
68555: LD_INT 102
68557: PUSH
68558: LD_INT 103
68560: PUSH
68561: LD_INT 104
68563: PUSH
68564: LD_INT 105
68566: PUSH
68567: LD_INT 106
68569: PUSH
68570: LD_INT 107
68572: PUSH
68573: LD_INT 108
68575: PUSH
68576: LD_INT 109
68578: PUSH
68579: LD_INT 110
68581: PUSH
68582: LD_INT 111
68584: PUSH
68585: LD_INT 112
68587: PUSH
68588: LD_INT 113
68590: PUSH
68591: LD_INT 114
68593: PUSH
68594: LD_INT 116
68596: PUSH
68597: LD_INT 117
68599: PUSH
68600: LD_INT 118
68602: PUSH
68603: EMPTY
68604: LIST
68605: LIST
68606: LIST
68607: LIST
68608: LIST
68609: LIST
68610: LIST
68611: LIST
68612: LIST
68613: LIST
68614: LIST
68615: LIST
68616: LIST
68617: LIST
68618: LIST
68619: LIST
68620: LIST
68621: PUSH
68622: EMPTY
68623: LIST
68624: LIST
68625: ST_TO_ADDR
68626: GO 70081
68628: LD_INT 13
68630: DOUBLE
68631: EQUAL
68632: IFTRUE 68636
68634: GO 68844
68636: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 14 :
68637: LD_ADDR_VAR 0 2
68641: PUSH
68642: LD_INT 1
68644: PUSH
68645: LD_INT 2
68647: PUSH
68648: LD_INT 3
68650: PUSH
68651: LD_INT 4
68653: PUSH
68654: LD_INT 5
68656: PUSH
68657: LD_INT 8
68659: PUSH
68660: LD_INT 9
68662: PUSH
68663: LD_INT 10
68665: PUSH
68666: LD_INT 11
68668: PUSH
68669: LD_INT 12
68671: PUSH
68672: LD_INT 14
68674: PUSH
68675: LD_INT 15
68677: PUSH
68678: LD_INT 16
68680: PUSH
68681: LD_INT 17
68683: PUSH
68684: LD_INT 18
68686: PUSH
68687: LD_INT 19
68689: PUSH
68690: LD_INT 20
68692: PUSH
68693: LD_INT 21
68695: PUSH
68696: LD_INT 22
68698: PUSH
68699: LD_INT 23
68701: PUSH
68702: LD_INT 24
68704: PUSH
68705: LD_INT 25
68707: PUSH
68708: LD_INT 26
68710: PUSH
68711: LD_INT 27
68713: PUSH
68714: LD_INT 28
68716: PUSH
68717: LD_INT 30
68719: PUSH
68720: LD_INT 31
68722: PUSH
68723: LD_INT 32
68725: PUSH
68726: LD_INT 33
68728: PUSH
68729: LD_INT 34
68731: PUSH
68732: LD_INT 36
68734: PUSH
68735: EMPTY
68736: LIST
68737: LIST
68738: LIST
68739: LIST
68740: LIST
68741: LIST
68742: LIST
68743: LIST
68744: LIST
68745: LIST
68746: LIST
68747: LIST
68748: LIST
68749: LIST
68750: LIST
68751: LIST
68752: LIST
68753: LIST
68754: LIST
68755: LIST
68756: LIST
68757: LIST
68758: LIST
68759: LIST
68760: LIST
68761: LIST
68762: LIST
68763: LIST
68764: LIST
68765: LIST
68766: LIST
68767: PUSH
68768: LD_INT 101
68770: PUSH
68771: LD_INT 102
68773: PUSH
68774: LD_INT 103
68776: PUSH
68777: LD_INT 104
68779: PUSH
68780: LD_INT 105
68782: PUSH
68783: LD_INT 106
68785: PUSH
68786: LD_INT 107
68788: PUSH
68789: LD_INT 108
68791: PUSH
68792: LD_INT 109
68794: PUSH
68795: LD_INT 110
68797: PUSH
68798: LD_INT 111
68800: PUSH
68801: LD_INT 112
68803: PUSH
68804: LD_INT 113
68806: PUSH
68807: LD_INT 114
68809: PUSH
68810: LD_INT 116
68812: PUSH
68813: LD_INT 117
68815: PUSH
68816: LD_INT 118
68818: PUSH
68819: EMPTY
68820: LIST
68821: LIST
68822: LIST
68823: LIST
68824: LIST
68825: LIST
68826: LIST
68827: LIST
68828: LIST
68829: LIST
68830: LIST
68831: LIST
68832: LIST
68833: LIST
68834: LIST
68835: LIST
68836: LIST
68837: PUSH
68838: EMPTY
68839: LIST
68840: LIST
68841: ST_TO_ADDR
68842: GO 70081
68844: LD_INT 14
68846: DOUBLE
68847: EQUAL
68848: IFTRUE 68852
68850: GO 69076
68852: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 15 :
68853: LD_ADDR_VAR 0 2
68857: PUSH
68858: LD_INT 1
68860: PUSH
68861: LD_INT 2
68863: PUSH
68864: LD_INT 3
68866: PUSH
68867: LD_INT 4
68869: PUSH
68870: LD_INT 5
68872: PUSH
68873: LD_INT 6
68875: PUSH
68876: LD_INT 7
68878: PUSH
68879: LD_INT 8
68881: PUSH
68882: LD_INT 9
68884: PUSH
68885: LD_INT 10
68887: PUSH
68888: LD_INT 11
68890: PUSH
68891: LD_INT 12
68893: PUSH
68894: LD_INT 13
68896: PUSH
68897: LD_INT 14
68899: PUSH
68900: LD_INT 15
68902: PUSH
68903: LD_INT 16
68905: PUSH
68906: LD_INT 17
68908: PUSH
68909: LD_INT 18
68911: PUSH
68912: LD_INT 19
68914: PUSH
68915: LD_INT 20
68917: PUSH
68918: LD_INT 21
68920: PUSH
68921: LD_INT 22
68923: PUSH
68924: LD_INT 23
68926: PUSH
68927: LD_INT 24
68929: PUSH
68930: LD_INT 25
68932: PUSH
68933: LD_INT 26
68935: PUSH
68936: LD_INT 27
68938: PUSH
68939: LD_INT 28
68941: PUSH
68942: LD_INT 29
68944: PUSH
68945: LD_INT 30
68947: PUSH
68948: LD_INT 31
68950: PUSH
68951: LD_INT 32
68953: PUSH
68954: LD_INT 33
68956: PUSH
68957: LD_INT 34
68959: PUSH
68960: LD_INT 36
68962: PUSH
68963: EMPTY
68964: LIST
68965: LIST
68966: LIST
68967: LIST
68968: LIST
68969: LIST
68970: LIST
68971: LIST
68972: LIST
68973: LIST
68974: LIST
68975: LIST
68976: LIST
68977: LIST
68978: LIST
68979: LIST
68980: LIST
68981: LIST
68982: LIST
68983: LIST
68984: LIST
68985: LIST
68986: LIST
68987: LIST
68988: LIST
68989: LIST
68990: LIST
68991: LIST
68992: LIST
68993: LIST
68994: LIST
68995: LIST
68996: LIST
68997: LIST
68998: LIST
68999: PUSH
69000: LD_INT 101
69002: PUSH
69003: LD_INT 102
69005: PUSH
69006: LD_INT 103
69008: PUSH
69009: LD_INT 104
69011: PUSH
69012: LD_INT 105
69014: PUSH
69015: LD_INT 106
69017: PUSH
69018: LD_INT 107
69020: PUSH
69021: LD_INT 108
69023: PUSH
69024: LD_INT 109
69026: PUSH
69027: LD_INT 110
69029: PUSH
69030: LD_INT 111
69032: PUSH
69033: LD_INT 112
69035: PUSH
69036: LD_INT 113
69038: PUSH
69039: LD_INT 114
69041: PUSH
69042: LD_INT 116
69044: PUSH
69045: LD_INT 117
69047: PUSH
69048: LD_INT 118
69050: PUSH
69051: EMPTY
69052: LIST
69053: LIST
69054: LIST
69055: LIST
69056: LIST
69057: LIST
69058: LIST
69059: LIST
69060: LIST
69061: LIST
69062: LIST
69063: LIST
69064: LIST
69065: LIST
69066: LIST
69067: LIST
69068: LIST
69069: PUSH
69070: EMPTY
69071: LIST
69072: LIST
69073: ST_TO_ADDR
69074: GO 70081
69076: LD_INT 15
69078: DOUBLE
69079: EQUAL
69080: IFTRUE 69084
69082: GO 69308
69084: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 16 :
69085: LD_ADDR_VAR 0 2
69089: PUSH
69090: LD_INT 1
69092: PUSH
69093: LD_INT 2
69095: PUSH
69096: LD_INT 3
69098: PUSH
69099: LD_INT 4
69101: PUSH
69102: LD_INT 5
69104: PUSH
69105: LD_INT 6
69107: PUSH
69108: LD_INT 7
69110: PUSH
69111: LD_INT 8
69113: PUSH
69114: LD_INT 9
69116: PUSH
69117: LD_INT 10
69119: PUSH
69120: LD_INT 11
69122: PUSH
69123: LD_INT 12
69125: PUSH
69126: LD_INT 13
69128: PUSH
69129: LD_INT 14
69131: PUSH
69132: LD_INT 15
69134: PUSH
69135: LD_INT 16
69137: PUSH
69138: LD_INT 17
69140: PUSH
69141: LD_INT 18
69143: PUSH
69144: LD_INT 19
69146: PUSH
69147: LD_INT 20
69149: PUSH
69150: LD_INT 21
69152: PUSH
69153: LD_INT 22
69155: PUSH
69156: LD_INT 23
69158: PUSH
69159: LD_INT 24
69161: PUSH
69162: LD_INT 25
69164: PUSH
69165: LD_INT 26
69167: PUSH
69168: LD_INT 27
69170: PUSH
69171: LD_INT 28
69173: PUSH
69174: LD_INT 29
69176: PUSH
69177: LD_INT 30
69179: PUSH
69180: LD_INT 31
69182: PUSH
69183: LD_INT 32
69185: PUSH
69186: LD_INT 33
69188: PUSH
69189: LD_INT 34
69191: PUSH
69192: LD_INT 36
69194: PUSH
69195: EMPTY
69196: LIST
69197: LIST
69198: LIST
69199: LIST
69200: LIST
69201: LIST
69202: LIST
69203: LIST
69204: LIST
69205: LIST
69206: LIST
69207: LIST
69208: LIST
69209: LIST
69210: LIST
69211: LIST
69212: LIST
69213: LIST
69214: LIST
69215: LIST
69216: LIST
69217: LIST
69218: LIST
69219: LIST
69220: LIST
69221: LIST
69222: LIST
69223: LIST
69224: LIST
69225: LIST
69226: LIST
69227: LIST
69228: LIST
69229: LIST
69230: LIST
69231: PUSH
69232: LD_INT 101
69234: PUSH
69235: LD_INT 102
69237: PUSH
69238: LD_INT 103
69240: PUSH
69241: LD_INT 104
69243: PUSH
69244: LD_INT 105
69246: PUSH
69247: LD_INT 106
69249: PUSH
69250: LD_INT 107
69252: PUSH
69253: LD_INT 108
69255: PUSH
69256: LD_INT 109
69258: PUSH
69259: LD_INT 110
69261: PUSH
69262: LD_INT 111
69264: PUSH
69265: LD_INT 112
69267: PUSH
69268: LD_INT 113
69270: PUSH
69271: LD_INT 114
69273: PUSH
69274: LD_INT 116
69276: PUSH
69277: LD_INT 117
69279: PUSH
69280: LD_INT 118
69282: PUSH
69283: EMPTY
69284: LIST
69285: LIST
69286: LIST
69287: LIST
69288: LIST
69289: LIST
69290: LIST
69291: LIST
69292: LIST
69293: LIST
69294: LIST
69295: LIST
69296: LIST
69297: LIST
69298: LIST
69299: LIST
69300: LIST
69301: PUSH
69302: EMPTY
69303: LIST
69304: LIST
69305: ST_TO_ADDR
69306: GO 70081
69308: LD_INT 16
69310: DOUBLE
69311: EQUAL
69312: IFTRUE 69316
69314: GO 69452
69316: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 17 :
69317: LD_ADDR_VAR 0 2
69321: PUSH
69322: LD_INT 2
69324: PUSH
69325: LD_INT 4
69327: PUSH
69328: LD_INT 5
69330: PUSH
69331: LD_INT 7
69333: PUSH
69334: LD_INT 11
69336: PUSH
69337: LD_INT 12
69339: PUSH
69340: LD_INT 15
69342: PUSH
69343: LD_INT 16
69345: PUSH
69346: LD_INT 20
69348: PUSH
69349: LD_INT 21
69351: PUSH
69352: LD_INT 22
69354: PUSH
69355: LD_INT 23
69357: PUSH
69358: LD_INT 25
69360: PUSH
69361: LD_INT 26
69363: PUSH
69364: LD_INT 30
69366: PUSH
69367: LD_INT 31
69369: PUSH
69370: LD_INT 32
69372: PUSH
69373: LD_INT 33
69375: PUSH
69376: LD_INT 34
69378: PUSH
69379: EMPTY
69380: LIST
69381: LIST
69382: LIST
69383: LIST
69384: LIST
69385: LIST
69386: LIST
69387: LIST
69388: LIST
69389: LIST
69390: LIST
69391: LIST
69392: LIST
69393: LIST
69394: LIST
69395: LIST
69396: LIST
69397: LIST
69398: LIST
69399: PUSH
69400: LD_INT 101
69402: PUSH
69403: LD_INT 102
69405: PUSH
69406: LD_INT 103
69408: PUSH
69409: LD_INT 106
69411: PUSH
69412: LD_INT 108
69414: PUSH
69415: LD_INT 112
69417: PUSH
69418: LD_INT 113
69420: PUSH
69421: LD_INT 114
69423: PUSH
69424: LD_INT 116
69426: PUSH
69427: LD_INT 117
69429: PUSH
69430: LD_INT 118
69432: PUSH
69433: EMPTY
69434: LIST
69435: LIST
69436: LIST
69437: LIST
69438: LIST
69439: LIST
69440: LIST
69441: LIST
69442: LIST
69443: LIST
69444: LIST
69445: PUSH
69446: EMPTY
69447: LIST
69448: LIST
69449: ST_TO_ADDR
69450: GO 70081
69452: LD_INT 17
69454: DOUBLE
69455: EQUAL
69456: IFTRUE 69460
69458: GO 69684
69460: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 18 :
69461: LD_ADDR_VAR 0 2
69465: PUSH
69466: LD_INT 1
69468: PUSH
69469: LD_INT 2
69471: PUSH
69472: LD_INT 3
69474: PUSH
69475: LD_INT 4
69477: PUSH
69478: LD_INT 5
69480: PUSH
69481: LD_INT 6
69483: PUSH
69484: LD_INT 7
69486: PUSH
69487: LD_INT 8
69489: PUSH
69490: LD_INT 9
69492: PUSH
69493: LD_INT 10
69495: PUSH
69496: LD_INT 11
69498: PUSH
69499: LD_INT 12
69501: PUSH
69502: LD_INT 13
69504: PUSH
69505: LD_INT 14
69507: PUSH
69508: LD_INT 15
69510: PUSH
69511: LD_INT 16
69513: PUSH
69514: LD_INT 17
69516: PUSH
69517: LD_INT 18
69519: PUSH
69520: LD_INT 19
69522: PUSH
69523: LD_INT 20
69525: PUSH
69526: LD_INT 21
69528: PUSH
69529: LD_INT 22
69531: PUSH
69532: LD_INT 23
69534: PUSH
69535: LD_INT 24
69537: PUSH
69538: LD_INT 25
69540: PUSH
69541: LD_INT 26
69543: PUSH
69544: LD_INT 27
69546: PUSH
69547: LD_INT 28
69549: PUSH
69550: LD_INT 29
69552: PUSH
69553: LD_INT 30
69555: PUSH
69556: LD_INT 31
69558: PUSH
69559: LD_INT 32
69561: PUSH
69562: LD_INT 33
69564: PUSH
69565: LD_INT 34
69567: PUSH
69568: LD_INT 36
69570: PUSH
69571: EMPTY
69572: LIST
69573: LIST
69574: LIST
69575: LIST
69576: LIST
69577: LIST
69578: LIST
69579: LIST
69580: LIST
69581: LIST
69582: LIST
69583: LIST
69584: LIST
69585: LIST
69586: LIST
69587: LIST
69588: LIST
69589: LIST
69590: LIST
69591: LIST
69592: LIST
69593: LIST
69594: LIST
69595: LIST
69596: LIST
69597: LIST
69598: LIST
69599: LIST
69600: LIST
69601: LIST
69602: LIST
69603: LIST
69604: LIST
69605: LIST
69606: LIST
69607: PUSH
69608: LD_INT 101
69610: PUSH
69611: LD_INT 102
69613: PUSH
69614: LD_INT 103
69616: PUSH
69617: LD_INT 104
69619: PUSH
69620: LD_INT 105
69622: PUSH
69623: LD_INT 106
69625: PUSH
69626: LD_INT 107
69628: PUSH
69629: LD_INT 108
69631: PUSH
69632: LD_INT 109
69634: PUSH
69635: LD_INT 110
69637: PUSH
69638: LD_INT 111
69640: PUSH
69641: LD_INT 112
69643: PUSH
69644: LD_INT 113
69646: PUSH
69647: LD_INT 114
69649: PUSH
69650: LD_INT 116
69652: PUSH
69653: LD_INT 117
69655: PUSH
69656: LD_INT 118
69658: PUSH
69659: EMPTY
69660: LIST
69661: LIST
69662: LIST
69663: LIST
69664: LIST
69665: LIST
69666: LIST
69667: LIST
69668: LIST
69669: LIST
69670: LIST
69671: LIST
69672: LIST
69673: LIST
69674: LIST
69675: LIST
69676: LIST
69677: PUSH
69678: EMPTY
69679: LIST
69680: LIST
69681: ST_TO_ADDR
69682: GO 70081
69684: LD_INT 18
69686: DOUBLE
69687: EQUAL
69688: IFTRUE 69692
69690: GO 69840
69692: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; 19 :
69693: LD_ADDR_VAR 0 2
69697: PUSH
69698: LD_INT 2
69700: PUSH
69701: LD_INT 4
69703: PUSH
69704: LD_INT 5
69706: PUSH
69707: LD_INT 7
69709: PUSH
69710: LD_INT 11
69712: PUSH
69713: LD_INT 12
69715: PUSH
69716: LD_INT 15
69718: PUSH
69719: LD_INT 16
69721: PUSH
69722: LD_INT 20
69724: PUSH
69725: LD_INT 21
69727: PUSH
69728: LD_INT 22
69730: PUSH
69731: LD_INT 23
69733: PUSH
69734: LD_INT 25
69736: PUSH
69737: LD_INT 26
69739: PUSH
69740: LD_INT 30
69742: PUSH
69743: LD_INT 31
69745: PUSH
69746: LD_INT 32
69748: PUSH
69749: LD_INT 33
69751: PUSH
69752: LD_INT 34
69754: PUSH
69755: LD_INT 35
69757: PUSH
69758: LD_INT 36
69760: PUSH
69761: EMPTY
69762: LIST
69763: LIST
69764: LIST
69765: LIST
69766: LIST
69767: LIST
69768: LIST
69769: LIST
69770: LIST
69771: LIST
69772: LIST
69773: LIST
69774: LIST
69775: LIST
69776: LIST
69777: LIST
69778: LIST
69779: LIST
69780: LIST
69781: LIST
69782: LIST
69783: PUSH
69784: LD_INT 101
69786: PUSH
69787: LD_INT 102
69789: PUSH
69790: LD_INT 103
69792: PUSH
69793: LD_INT 106
69795: PUSH
69796: LD_INT 108
69798: PUSH
69799: LD_INT 112
69801: PUSH
69802: LD_INT 113
69804: PUSH
69805: LD_INT 114
69807: PUSH
69808: LD_INT 115
69810: PUSH
69811: LD_INT 116
69813: PUSH
69814: LD_INT 117
69816: PUSH
69817: LD_INT 118
69819: PUSH
69820: EMPTY
69821: LIST
69822: LIST
69823: LIST
69824: LIST
69825: LIST
69826: LIST
69827: LIST
69828: LIST
69829: LIST
69830: LIST
69831: LIST
69832: LIST
69833: PUSH
69834: EMPTY
69835: LIST
69836: LIST
69837: ST_TO_ADDR
69838: GO 70081
69840: LD_INT 19
69842: DOUBLE
69843: EQUAL
69844: IFTRUE 69848
69846: GO 70080
69848: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; end ;
69849: LD_ADDR_VAR 0 2
69853: PUSH
69854: LD_INT 1
69856: PUSH
69857: LD_INT 2
69859: PUSH
69860: LD_INT 3
69862: PUSH
69863: LD_INT 4
69865: PUSH
69866: LD_INT 5
69868: PUSH
69869: LD_INT 6
69871: PUSH
69872: LD_INT 7
69874: PUSH
69875: LD_INT 8
69877: PUSH
69878: LD_INT 9
69880: PUSH
69881: LD_INT 10
69883: PUSH
69884: LD_INT 11
69886: PUSH
69887: LD_INT 12
69889: PUSH
69890: LD_INT 13
69892: PUSH
69893: LD_INT 14
69895: PUSH
69896: LD_INT 15
69898: PUSH
69899: LD_INT 16
69901: PUSH
69902: LD_INT 17
69904: PUSH
69905: LD_INT 18
69907: PUSH
69908: LD_INT 19
69910: PUSH
69911: LD_INT 20
69913: PUSH
69914: LD_INT 21
69916: PUSH
69917: LD_INT 22
69919: PUSH
69920: LD_INT 23
69922: PUSH
69923: LD_INT 24
69925: PUSH
69926: LD_INT 25
69928: PUSH
69929: LD_INT 26
69931: PUSH
69932: LD_INT 27
69934: PUSH
69935: LD_INT 28
69937: PUSH
69938: LD_INT 29
69940: PUSH
69941: LD_INT 30
69943: PUSH
69944: LD_INT 31
69946: PUSH
69947: LD_INT 32
69949: PUSH
69950: LD_INT 33
69952: PUSH
69953: LD_INT 34
69955: PUSH
69956: LD_INT 35
69958: PUSH
69959: LD_INT 36
69961: PUSH
69962: EMPTY
69963: LIST
69964: LIST
69965: LIST
69966: LIST
69967: LIST
69968: LIST
69969: LIST
69970: LIST
69971: LIST
69972: LIST
69973: LIST
69974: LIST
69975: LIST
69976: LIST
69977: LIST
69978: LIST
69979: LIST
69980: LIST
69981: LIST
69982: LIST
69983: LIST
69984: LIST
69985: LIST
69986: LIST
69987: LIST
69988: LIST
69989: LIST
69990: LIST
69991: LIST
69992: LIST
69993: LIST
69994: LIST
69995: LIST
69996: LIST
69997: LIST
69998: LIST
69999: PUSH
70000: LD_INT 101
70002: PUSH
70003: LD_INT 102
70005: PUSH
70006: LD_INT 103
70008: PUSH
70009: LD_INT 104
70011: PUSH
70012: LD_INT 105
70014: PUSH
70015: LD_INT 106
70017: PUSH
70018: LD_INT 107
70020: PUSH
70021: LD_INT 108
70023: PUSH
70024: LD_INT 109
70026: PUSH
70027: LD_INT 110
70029: PUSH
70030: LD_INT 111
70032: PUSH
70033: LD_INT 112
70035: PUSH
70036: LD_INT 113
70038: PUSH
70039: LD_INT 114
70041: PUSH
70042: LD_INT 115
70044: PUSH
70045: LD_INT 116
70047: PUSH
70048: LD_INT 117
70050: PUSH
70051: LD_INT 118
70053: PUSH
70054: EMPTY
70055: LIST
70056: LIST
70057: LIST
70058: LIST
70059: LIST
70060: LIST
70061: LIST
70062: LIST
70063: LIST
70064: LIST
70065: LIST
70066: LIST
70067: LIST
70068: LIST
70069: LIST
70070: LIST
70071: LIST
70072: LIST
70073: PUSH
70074: EMPTY
70075: LIST
70076: LIST
70077: ST_TO_ADDR
70078: GO 70081
70080: POP
// end else
70081: GO 70312
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ;
70083: LD_ADDR_VAR 0 2
70087: PUSH
70088: LD_INT 1
70090: PUSH
70091: LD_INT 2
70093: PUSH
70094: LD_INT 3
70096: PUSH
70097: LD_INT 4
70099: PUSH
70100: LD_INT 5
70102: PUSH
70103: LD_INT 6
70105: PUSH
70106: LD_INT 7
70108: PUSH
70109: LD_INT 8
70111: PUSH
70112: LD_INT 9
70114: PUSH
70115: LD_INT 10
70117: PUSH
70118: LD_INT 11
70120: PUSH
70121: LD_INT 12
70123: PUSH
70124: LD_INT 13
70126: PUSH
70127: LD_INT 14
70129: PUSH
70130: LD_INT 15
70132: PUSH
70133: LD_INT 16
70135: PUSH
70136: LD_INT 17
70138: PUSH
70139: LD_INT 18
70141: PUSH
70142: LD_INT 19
70144: PUSH
70145: LD_INT 20
70147: PUSH
70148: LD_INT 21
70150: PUSH
70151: LD_INT 22
70153: PUSH
70154: LD_INT 23
70156: PUSH
70157: LD_INT 24
70159: PUSH
70160: LD_INT 25
70162: PUSH
70163: LD_INT 26
70165: PUSH
70166: LD_INT 27
70168: PUSH
70169: LD_INT 28
70171: PUSH
70172: LD_INT 29
70174: PUSH
70175: LD_INT 30
70177: PUSH
70178: LD_INT 31
70180: PUSH
70181: LD_INT 32
70183: PUSH
70184: LD_INT 33
70186: PUSH
70187: LD_INT 34
70189: PUSH
70190: LD_INT 35
70192: PUSH
70193: LD_INT 36
70195: PUSH
70196: EMPTY
70197: LIST
70198: LIST
70199: LIST
70200: LIST
70201: LIST
70202: LIST
70203: LIST
70204: LIST
70205: LIST
70206: LIST
70207: LIST
70208: LIST
70209: LIST
70210: LIST
70211: LIST
70212: LIST
70213: LIST
70214: LIST
70215: LIST
70216: LIST
70217: LIST
70218: LIST
70219: LIST
70220: LIST
70221: LIST
70222: LIST
70223: LIST
70224: LIST
70225: LIST
70226: LIST
70227: LIST
70228: LIST
70229: LIST
70230: LIST
70231: LIST
70232: LIST
70233: PUSH
70234: LD_INT 101
70236: PUSH
70237: LD_INT 102
70239: PUSH
70240: LD_INT 103
70242: PUSH
70243: LD_INT 104
70245: PUSH
70246: LD_INT 105
70248: PUSH
70249: LD_INT 106
70251: PUSH
70252: LD_INT 107
70254: PUSH
70255: LD_INT 108
70257: PUSH
70258: LD_INT 109
70260: PUSH
70261: LD_INT 110
70263: PUSH
70264: LD_INT 111
70266: PUSH
70267: LD_INT 112
70269: PUSH
70270: LD_INT 113
70272: PUSH
70273: LD_INT 114
70275: PUSH
70276: LD_INT 115
70278: PUSH
70279: LD_INT 116
70281: PUSH
70282: LD_INT 117
70284: PUSH
70285: LD_INT 118
70287: PUSH
70288: EMPTY
70289: LIST
70290: LIST
70291: LIST
70292: LIST
70293: LIST
70294: LIST
70295: LIST
70296: LIST
70297: LIST
70298: LIST
70299: LIST
70300: LIST
70301: LIST
70302: LIST
70303: LIST
70304: LIST
70305: LIST
70306: LIST
70307: PUSH
70308: EMPTY
70309: LIST
70310: LIST
70311: ST_TO_ADDR
// if result then
70312: LD_VAR 0 2
70316: IFFALSE 71102
// begin normal :=  ;
70318: LD_ADDR_VAR 0 5
70322: PUSH
70323: LD_STRING 
70325: ST_TO_ADDR
// hardcore :=  ;
70326: LD_ADDR_VAR 0 6
70330: PUSH
70331: LD_STRING 
70333: ST_TO_ADDR
// active :=  ;
70334: LD_ADDR_VAR 0 7
70338: PUSH
70339: LD_STRING 
70341: ST_TO_ADDR
// for i = 1 to normalCounter do
70342: LD_ADDR_VAR 0 8
70346: PUSH
70347: DOUBLE
70348: LD_INT 1
70350: DEC
70351: ST_TO_ADDR
70352: LD_EXP 99
70356: PUSH
70357: FOR_TO
70358: IFFALSE 70459
// begin tmp := 0 ;
70360: LD_ADDR_VAR 0 3
70364: PUSH
70365: LD_STRING 0
70367: ST_TO_ADDR
// if result [ 1 ] then
70368: LD_VAR 0 2
70372: PUSH
70373: LD_INT 1
70375: ARRAY
70376: IFFALSE 70441
// if result [ 1 ] [ 1 ] = i then
70378: LD_VAR 0 2
70382: PUSH
70383: LD_INT 1
70385: ARRAY
70386: PUSH
70387: LD_INT 1
70389: ARRAY
70390: PUSH
70391: LD_VAR 0 8
70395: EQUAL
70396: IFFALSE 70441
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
70398: LD_ADDR_VAR 0 2
70402: PUSH
70403: LD_VAR 0 2
70407: PPUSH
70408: LD_INT 1
70410: PPUSH
70411: LD_VAR 0 2
70415: PUSH
70416: LD_INT 1
70418: ARRAY
70419: PPUSH
70420: LD_INT 1
70422: PPUSH
70423: CALL_OW 3
70427: PPUSH
70428: CALL_OW 1
70432: ST_TO_ADDR
// tmp := 1 ;
70433: LD_ADDR_VAR 0 3
70437: PUSH
70438: LD_STRING 1
70440: ST_TO_ADDR
// end ; normal := normal & tmp ;
70441: LD_ADDR_VAR 0 5
70445: PUSH
70446: LD_VAR 0 5
70450: PUSH
70451: LD_VAR 0 3
70455: STR
70456: ST_TO_ADDR
// end ;
70457: GO 70357
70459: POP
70460: POP
// for i = 1 to hardcoreCounter do
70461: LD_ADDR_VAR 0 8
70465: PUSH
70466: DOUBLE
70467: LD_INT 1
70469: DEC
70470: ST_TO_ADDR
70471: LD_EXP 100
70475: PUSH
70476: FOR_TO
70477: IFFALSE 70582
// begin tmp := 0 ;
70479: LD_ADDR_VAR 0 3
70483: PUSH
70484: LD_STRING 0
70486: ST_TO_ADDR
// if result [ 2 ] then
70487: LD_VAR 0 2
70491: PUSH
70492: LD_INT 2
70494: ARRAY
70495: IFFALSE 70564
// if result [ 2 ] [ 1 ] = 100 + i then
70497: LD_VAR 0 2
70501: PUSH
70502: LD_INT 2
70504: ARRAY
70505: PUSH
70506: LD_INT 1
70508: ARRAY
70509: PUSH
70510: LD_INT 100
70512: PUSH
70513: LD_VAR 0 8
70517: PLUS
70518: EQUAL
70519: IFFALSE 70564
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
70521: LD_ADDR_VAR 0 2
70525: PUSH
70526: LD_VAR 0 2
70530: PPUSH
70531: LD_INT 2
70533: PPUSH
70534: LD_VAR 0 2
70538: PUSH
70539: LD_INT 2
70541: ARRAY
70542: PPUSH
70543: LD_INT 1
70545: PPUSH
70546: CALL_OW 3
70550: PPUSH
70551: CALL_OW 1
70555: ST_TO_ADDR
// tmp := 1 ;
70556: LD_ADDR_VAR 0 3
70560: PUSH
70561: LD_STRING 1
70563: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
70564: LD_ADDR_VAR 0 6
70568: PUSH
70569: LD_VAR 0 6
70573: PUSH
70574: LD_VAR 0 3
70578: STR
70579: ST_TO_ADDR
// end ;
70580: GO 70476
70582: POP
70583: POP
// if isGameLoad then
70584: LD_VAR 0 1
70588: IFFALSE 71063
// begin flags := [ sRocket , sSpeed , sEngine , sSpec , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sKamikadze , sTroll , sSlow , sLack , sTank , sRemote , sPowell , sTeleport , sOilTower , sShovel , sSheik , sEarthquake , sAI , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sSold , sDiff , sFog , sReset , sSun , sTiger , sBomb , sWound , sBetray , sContamin , sOil , sStu , sBazooka , sMortar , sRanger , sComputer , s30 , s60 ] ;
70590: LD_ADDR_VAR 0 4
70594: PUSH
70595: LD_EXP 103
70599: PUSH
70600: LD_EXP 102
70604: PUSH
70605: LD_EXP 104
70609: PUSH
70610: LD_EXP 101
70614: PUSH
70615: LD_EXP 105
70619: PUSH
70620: LD_EXP 106
70624: PUSH
70625: LD_EXP 107
70629: PUSH
70630: LD_EXP 108
70634: PUSH
70635: LD_EXP 109
70639: PUSH
70640: LD_EXP 110
70644: PUSH
70645: LD_EXP 111
70649: PUSH
70650: LD_EXP 112
70654: PUSH
70655: LD_EXP 113
70659: PUSH
70660: LD_EXP 114
70664: PUSH
70665: LD_EXP 122
70669: PUSH
70670: LD_EXP 123
70674: PUSH
70675: LD_EXP 124
70679: PUSH
70680: LD_EXP 125
70684: PUSH
70685: LD_EXP 127
70689: PUSH
70690: LD_EXP 128
70694: PUSH
70695: LD_EXP 129
70699: PUSH
70700: LD_EXP 132
70704: PUSH
70705: LD_EXP 134
70709: PUSH
70710: LD_EXP 135
70714: PUSH
70715: LD_EXP 136
70719: PUSH
70720: LD_EXP 138
70724: PUSH
70725: LD_EXP 139
70729: PUSH
70730: LD_EXP 142
70734: PUSH
70735: LD_EXP 143
70739: PUSH
70740: LD_EXP 144
70744: PUSH
70745: LD_EXP 145
70749: PUSH
70750: LD_EXP 146
70754: PUSH
70755: LD_EXP 147
70759: PUSH
70760: LD_EXP 148
70764: PUSH
70765: LD_EXP 149
70769: PUSH
70770: LD_EXP 150
70774: PUSH
70775: LD_EXP 115
70779: PUSH
70780: LD_EXP 116
70784: PUSH
70785: LD_EXP 119
70789: PUSH
70790: LD_EXP 120
70794: PUSH
70795: LD_EXP 121
70799: PUSH
70800: LD_EXP 117
70804: PUSH
70805: LD_EXP 118
70809: PUSH
70810: LD_EXP 126
70814: PUSH
70815: LD_EXP 130
70819: PUSH
70820: LD_EXP 131
70824: PUSH
70825: LD_EXP 133
70829: PUSH
70830: LD_EXP 137
70834: PUSH
70835: LD_EXP 140
70839: PUSH
70840: LD_EXP 141
70844: PUSH
70845: LD_EXP 151
70849: PUSH
70850: LD_EXP 152
70854: PUSH
70855: LD_EXP 153
70859: PUSH
70860: LD_EXP 154
70864: PUSH
70865: EMPTY
70866: LIST
70867: LIST
70868: LIST
70869: LIST
70870: LIST
70871: LIST
70872: LIST
70873: LIST
70874: LIST
70875: LIST
70876: LIST
70877: LIST
70878: LIST
70879: LIST
70880: LIST
70881: LIST
70882: LIST
70883: LIST
70884: LIST
70885: LIST
70886: LIST
70887: LIST
70888: LIST
70889: LIST
70890: LIST
70891: LIST
70892: LIST
70893: LIST
70894: LIST
70895: LIST
70896: LIST
70897: LIST
70898: LIST
70899: LIST
70900: LIST
70901: LIST
70902: LIST
70903: LIST
70904: LIST
70905: LIST
70906: LIST
70907: LIST
70908: LIST
70909: LIST
70910: LIST
70911: LIST
70912: LIST
70913: LIST
70914: LIST
70915: LIST
70916: LIST
70917: LIST
70918: LIST
70919: LIST
70920: ST_TO_ADDR
// tmp :=  ;
70921: LD_ADDR_VAR 0 3
70925: PUSH
70926: LD_STRING 
70928: ST_TO_ADDR
// for i = 1 to normalCounter do
70929: LD_ADDR_VAR 0 8
70933: PUSH
70934: DOUBLE
70935: LD_INT 1
70937: DEC
70938: ST_TO_ADDR
70939: LD_EXP 99
70943: PUSH
70944: FOR_TO
70945: IFFALSE 70981
// begin if flags [ i ] then
70947: LD_VAR 0 4
70951: PUSH
70952: LD_VAR 0 8
70956: ARRAY
70957: IFFALSE 70979
// tmp := tmp & i & ; ;
70959: LD_ADDR_VAR 0 3
70963: PUSH
70964: LD_VAR 0 3
70968: PUSH
70969: LD_VAR 0 8
70973: STR
70974: PUSH
70975: LD_STRING ;
70977: STR
70978: ST_TO_ADDR
// end ;
70979: GO 70944
70981: POP
70982: POP
// for i = 1 to hardcoreCounter do
70983: LD_ADDR_VAR 0 8
70987: PUSH
70988: DOUBLE
70989: LD_INT 1
70991: DEC
70992: ST_TO_ADDR
70993: LD_EXP 100
70997: PUSH
70998: FOR_TO
70999: IFFALSE 71045
// begin if flags [ normalCounter + i ] then
71001: LD_VAR 0 4
71005: PUSH
71006: LD_EXP 99
71010: PUSH
71011: LD_VAR 0 8
71015: PLUS
71016: ARRAY
71017: IFFALSE 71043
// tmp := tmp & ( 100 + i ) & ; ;
71019: LD_ADDR_VAR 0 3
71023: PUSH
71024: LD_VAR 0 3
71028: PUSH
71029: LD_INT 100
71031: PUSH
71032: LD_VAR 0 8
71036: PLUS
71037: STR
71038: PUSH
71039: LD_STRING ;
71041: STR
71042: ST_TO_ADDR
// end ;
71043: GO 70998
71045: POP
71046: POP
// if tmp then
71047: LD_VAR 0 3
71051: IFFALSE 71063
// active := tmp ;
71053: LD_ADDR_VAR 0 7
71057: PUSH
71058: LD_VAR 0 3
71062: ST_TO_ADDR
// end ; ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & "," & active & ") ) ;
71063: LD_STRING getStreamItemsFromMission("
71065: PUSH
71066: LD_VAR 0 5
71070: STR
71071: PUSH
71072: LD_STRING ","
71074: STR
71075: PUSH
71076: LD_VAR 0 6
71080: STR
71081: PUSH
71082: LD_STRING ","
71084: STR
71085: PUSH
71086: LD_VAR 0 7
71090: STR
71091: PUSH
71092: LD_STRING ")
71094: STR
71095: PPUSH
71096: CALL_OW 559
// end else
71100: GO 71109
// ToLua ( getStreamItemsFromMission("","","") ) ;
71102: LD_STRING getStreamItemsFromMission("","","")
71104: PPUSH
71105: CALL_OW 559
// end ;
71109: LD_VAR 0 2
71113: RET
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
71114: LD_EXP 98
71118: PUSH
71119: LD_EXP 103
71123: AND
71124: IFFALSE 71248
71126: GO 71128
71128: DISABLE
71129: LD_INT 0
71131: PPUSH
71132: PPUSH
// begin enable ;
71133: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
71134: LD_ADDR_VAR 0 2
71138: PUSH
71139: LD_INT 22
71141: PUSH
71142: LD_OWVAR 2
71146: PUSH
71147: EMPTY
71148: LIST
71149: LIST
71150: PUSH
71151: LD_INT 2
71153: PUSH
71154: LD_INT 34
71156: PUSH
71157: LD_INT 7
71159: PUSH
71160: EMPTY
71161: LIST
71162: LIST
71163: PUSH
71164: LD_INT 34
71166: PUSH
71167: LD_INT 45
71169: PUSH
71170: EMPTY
71171: LIST
71172: LIST
71173: PUSH
71174: LD_INT 34
71176: PUSH
71177: LD_INT 28
71179: PUSH
71180: EMPTY
71181: LIST
71182: LIST
71183: PUSH
71184: LD_INT 34
71186: PUSH
71187: LD_INT 47
71189: PUSH
71190: EMPTY
71191: LIST
71192: LIST
71193: PUSH
71194: EMPTY
71195: LIST
71196: LIST
71197: LIST
71198: LIST
71199: LIST
71200: PUSH
71201: EMPTY
71202: LIST
71203: LIST
71204: PPUSH
71205: CALL_OW 69
71209: ST_TO_ADDR
// if not tmp then
71210: LD_VAR 0 2
71214: NOT
71215: IFFALSE 71219
// exit ;
71217: GO 71248
// for i in tmp do
71219: LD_ADDR_VAR 0 1
71223: PUSH
71224: LD_VAR 0 2
71228: PUSH
71229: FOR_IN
71230: IFFALSE 71246
// begin SetLives ( i , 0 ) ;
71232: LD_VAR 0 1
71236: PPUSH
71237: LD_INT 0
71239: PPUSH
71240: CALL_OW 234
// end ;
71244: GO 71229
71246: POP
71247: POP
// end ;
71248: PPOPN 2
71250: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
71251: LD_EXP 98
71255: PUSH
71256: LD_EXP 104
71260: AND
71261: IFFALSE 71345
71263: GO 71265
71265: DISABLE
71266: LD_INT 0
71268: PPUSH
71269: PPUSH
// begin enable ;
71270: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
71271: LD_ADDR_VAR 0 2
71275: PUSH
71276: LD_INT 22
71278: PUSH
71279: LD_OWVAR 2
71283: PUSH
71284: EMPTY
71285: LIST
71286: LIST
71287: PUSH
71288: LD_INT 32
71290: PUSH
71291: LD_INT 3
71293: PUSH
71294: EMPTY
71295: LIST
71296: LIST
71297: PUSH
71298: EMPTY
71299: LIST
71300: LIST
71301: PPUSH
71302: CALL_OW 69
71306: ST_TO_ADDR
// if not tmp then
71307: LD_VAR 0 2
71311: NOT
71312: IFFALSE 71316
// exit ;
71314: GO 71345
// for i in tmp do
71316: LD_ADDR_VAR 0 1
71320: PUSH
71321: LD_VAR 0 2
71325: PUSH
71326: FOR_IN
71327: IFFALSE 71343
// begin SetLives ( i , 0 ) ;
71329: LD_VAR 0 1
71333: PPUSH
71334: LD_INT 0
71336: PPUSH
71337: CALL_OW 234
// end ;
71341: GO 71326
71343: POP
71344: POP
// end ;
71345: PPOPN 2
71347: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
71348: LD_EXP 98
71352: PUSH
71353: LD_EXP 101
71357: AND
71358: IFFALSE 71451
71360: GO 71362
71362: DISABLE
71363: LD_INT 0
71365: PPUSH
// begin enable ;
71366: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
71367: LD_ADDR_VAR 0 1
71371: PUSH
71372: LD_INT 22
71374: PUSH
71375: LD_OWVAR 2
71379: PUSH
71380: EMPTY
71381: LIST
71382: LIST
71383: PUSH
71384: LD_INT 2
71386: PUSH
71387: LD_INT 25
71389: PUSH
71390: LD_INT 5
71392: PUSH
71393: EMPTY
71394: LIST
71395: LIST
71396: PUSH
71397: LD_INT 25
71399: PUSH
71400: LD_INT 9
71402: PUSH
71403: EMPTY
71404: LIST
71405: LIST
71406: PUSH
71407: LD_INT 25
71409: PUSH
71410: LD_INT 8
71412: PUSH
71413: EMPTY
71414: LIST
71415: LIST
71416: PUSH
71417: EMPTY
71418: LIST
71419: LIST
71420: LIST
71421: LIST
71422: PUSH
71423: EMPTY
71424: LIST
71425: LIST
71426: PPUSH
71427: CALL_OW 69
71431: PUSH
71432: FOR_IN
71433: IFFALSE 71449
// begin SetClass ( i , 1 ) ;
71435: LD_VAR 0 1
71439: PPUSH
71440: LD_INT 1
71442: PPUSH
71443: CALL_OW 336
// end ;
71447: GO 71432
71449: POP
71450: POP
// end ;
71451: PPOPN 1
71453: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
71454: LD_EXP 98
71458: PUSH
71459: LD_EXP 102
71463: AND
71464: PUSH
71465: LD_OWVAR 65
71469: PUSH
71470: LD_INT 7
71472: LESS
71473: AND
71474: IFFALSE 71488
71476: GO 71478
71478: DISABLE
// begin enable ;
71479: ENABLE
// game_speed := 7 ;
71480: LD_ADDR_OWVAR 65
71484: PUSH
71485: LD_INT 7
71487: ST_TO_ADDR
// end ;
71488: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
71489: LD_EXP 98
71493: PUSH
71494: LD_EXP 105
71498: AND
71499: IFFALSE 71701
71501: GO 71503
71503: DISABLE
71504: LD_INT 0
71506: PPUSH
71507: PPUSH
71508: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
71509: LD_ADDR_VAR 0 3
71513: PUSH
71514: LD_INT 81
71516: PUSH
71517: LD_OWVAR 2
71521: PUSH
71522: EMPTY
71523: LIST
71524: LIST
71525: PUSH
71526: LD_INT 21
71528: PUSH
71529: LD_INT 1
71531: PUSH
71532: EMPTY
71533: LIST
71534: LIST
71535: PUSH
71536: EMPTY
71537: LIST
71538: LIST
71539: PPUSH
71540: CALL_OW 69
71544: ST_TO_ADDR
// if not tmp then
71545: LD_VAR 0 3
71549: NOT
71550: IFFALSE 71554
// exit ;
71552: GO 71701
// if tmp > 5 then
71554: LD_VAR 0 3
71558: PUSH
71559: LD_INT 5
71561: GREATER
71562: IFFALSE 71574
// k := 5 else
71564: LD_ADDR_VAR 0 2
71568: PUSH
71569: LD_INT 5
71571: ST_TO_ADDR
71572: GO 71584
// k := tmp ;
71574: LD_ADDR_VAR 0 2
71578: PUSH
71579: LD_VAR 0 3
71583: ST_TO_ADDR
// for i := 1 to k do
71584: LD_ADDR_VAR 0 1
71588: PUSH
71589: DOUBLE
71590: LD_INT 1
71592: DEC
71593: ST_TO_ADDR
71594: LD_VAR 0 2
71598: PUSH
71599: FOR_TO
71600: IFFALSE 71699
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
71602: LD_VAR 0 3
71606: PUSH
71607: LD_VAR 0 1
71611: ARRAY
71612: PPUSH
71613: LD_VAR 0 1
71617: PUSH
71618: LD_INT 4
71620: MOD
71621: PUSH
71622: LD_INT 1
71624: PLUS
71625: PPUSH
71626: CALL_OW 259
71630: PUSH
71631: LD_INT 10
71633: LESS
71634: IFFALSE 71697
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
71636: LD_VAR 0 3
71640: PUSH
71641: LD_VAR 0 1
71645: ARRAY
71646: PPUSH
71647: LD_VAR 0 1
71651: PUSH
71652: LD_INT 4
71654: MOD
71655: PUSH
71656: LD_INT 1
71658: PLUS
71659: PPUSH
71660: LD_VAR 0 3
71664: PUSH
71665: LD_VAR 0 1
71669: ARRAY
71670: PPUSH
71671: LD_VAR 0 1
71675: PUSH
71676: LD_INT 4
71678: MOD
71679: PUSH
71680: LD_INT 1
71682: PLUS
71683: PPUSH
71684: CALL_OW 259
71688: PUSH
71689: LD_INT 1
71691: PLUS
71692: PPUSH
71693: CALL_OW 237
71697: GO 71599
71699: POP
71700: POP
// end ;
71701: PPOPN 3
71703: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
71704: LD_EXP 98
71708: PUSH
71709: LD_EXP 106
71713: AND
71714: IFFALSE 71734
71716: GO 71718
71718: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
71719: LD_INT 4
71721: PPUSH
71722: LD_OWVAR 2
71726: PPUSH
71727: LD_INT 0
71729: PPUSH
71730: CALL_OW 324
71734: END
// every 0 0$1 trigger StreamModeActive and sShovel do
71735: LD_EXP 98
71739: PUSH
71740: LD_EXP 135
71744: AND
71745: IFFALSE 71765
71747: GO 71749
71749: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
71750: LD_INT 19
71752: PPUSH
71753: LD_OWVAR 2
71757: PPUSH
71758: LD_INT 0
71760: PPUSH
71761: CALL_OW 324
71765: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
71766: LD_EXP 98
71770: PUSH
71771: LD_EXP 107
71775: AND
71776: IFFALSE 71878
71778: GO 71780
71780: DISABLE
71781: LD_INT 0
71783: PPUSH
71784: PPUSH
// begin enable ;
71785: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
71786: LD_ADDR_VAR 0 2
71790: PUSH
71791: LD_INT 22
71793: PUSH
71794: LD_OWVAR 2
71798: PUSH
71799: EMPTY
71800: LIST
71801: LIST
71802: PUSH
71803: LD_INT 2
71805: PUSH
71806: LD_INT 34
71808: PUSH
71809: LD_INT 11
71811: PUSH
71812: EMPTY
71813: LIST
71814: LIST
71815: PUSH
71816: LD_INT 34
71818: PUSH
71819: LD_INT 30
71821: PUSH
71822: EMPTY
71823: LIST
71824: LIST
71825: PUSH
71826: EMPTY
71827: LIST
71828: LIST
71829: LIST
71830: PUSH
71831: EMPTY
71832: LIST
71833: LIST
71834: PPUSH
71835: CALL_OW 69
71839: ST_TO_ADDR
// if not tmp then
71840: LD_VAR 0 2
71844: NOT
71845: IFFALSE 71849
// exit ;
71847: GO 71878
// for i in tmp do
71849: LD_ADDR_VAR 0 1
71853: PUSH
71854: LD_VAR 0 2
71858: PUSH
71859: FOR_IN
71860: IFFALSE 71876
// begin SetLives ( i , 0 ) ;
71862: LD_VAR 0 1
71866: PPUSH
71867: LD_INT 0
71869: PPUSH
71870: CALL_OW 234
// end ;
71874: GO 71859
71876: POP
71877: POP
// end ;
71878: PPOPN 2
71880: END
// every 0 0$1 trigger StreamModeActive and sBunker do
71881: LD_EXP 98
71885: PUSH
71886: LD_EXP 108
71890: AND
71891: IFFALSE 71911
71893: GO 71895
71895: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
71896: LD_INT 32
71898: PPUSH
71899: LD_OWVAR 2
71903: PPUSH
71904: LD_INT 0
71906: PPUSH
71907: CALL_OW 324
71911: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
71912: LD_EXP 98
71916: PUSH
71917: LD_EXP 109
71921: AND
71922: IFFALSE 72103
71924: GO 71926
71926: DISABLE
71927: LD_INT 0
71929: PPUSH
71930: PPUSH
71931: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
71932: LD_ADDR_VAR 0 2
71936: PUSH
71937: LD_INT 22
71939: PUSH
71940: LD_OWVAR 2
71944: PUSH
71945: EMPTY
71946: LIST
71947: LIST
71948: PUSH
71949: LD_INT 33
71951: PUSH
71952: LD_INT 3
71954: PUSH
71955: EMPTY
71956: LIST
71957: LIST
71958: PUSH
71959: EMPTY
71960: LIST
71961: LIST
71962: PPUSH
71963: CALL_OW 69
71967: ST_TO_ADDR
// if not tmp then
71968: LD_VAR 0 2
71972: NOT
71973: IFFALSE 71977
// exit ;
71975: GO 72103
// side := 0 ;
71977: LD_ADDR_VAR 0 3
71981: PUSH
71982: LD_INT 0
71984: ST_TO_ADDR
// for i := 1 to 8 do
71985: LD_ADDR_VAR 0 1
71989: PUSH
71990: DOUBLE
71991: LD_INT 1
71993: DEC
71994: ST_TO_ADDR
71995: LD_INT 8
71997: PUSH
71998: FOR_TO
71999: IFFALSE 72047
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
72001: LD_OWVAR 2
72005: PUSH
72006: LD_VAR 0 1
72010: NONEQUAL
72011: PUSH
72012: LD_OWVAR 2
72016: PPUSH
72017: LD_VAR 0 1
72021: PPUSH
72022: CALL_OW 81
72026: PUSH
72027: LD_INT 2
72029: EQUAL
72030: AND
72031: IFFALSE 72045
// begin side := i ;
72033: LD_ADDR_VAR 0 3
72037: PUSH
72038: LD_VAR 0 1
72042: ST_TO_ADDR
// break ;
72043: GO 72047
// end ;
72045: GO 71998
72047: POP
72048: POP
// if not side then
72049: LD_VAR 0 3
72053: NOT
72054: IFFALSE 72058
// exit ;
72056: GO 72103
// for i := 1 to tmp do
72058: LD_ADDR_VAR 0 1
72062: PUSH
72063: DOUBLE
72064: LD_INT 1
72066: DEC
72067: ST_TO_ADDR
72068: LD_VAR 0 2
72072: PUSH
72073: FOR_TO
72074: IFFALSE 72101
// if Prob ( 60 ) then
72076: LD_INT 60
72078: PPUSH
72079: CALL_OW 13
72083: IFFALSE 72099
// SetSide ( i , side ) ;
72085: LD_VAR 0 1
72089: PPUSH
72090: LD_VAR 0 3
72094: PPUSH
72095: CALL_OW 235
72099: GO 72073
72101: POP
72102: POP
// end ;
72103: PPOPN 3
72105: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
72106: LD_EXP 98
72110: PUSH
72111: LD_EXP 111
72115: AND
72116: IFFALSE 72235
72118: GO 72120
72120: DISABLE
72121: LD_INT 0
72123: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
72124: LD_ADDR_VAR 0 1
72128: PUSH
72129: LD_INT 22
72131: PUSH
72132: LD_OWVAR 2
72136: PUSH
72137: EMPTY
72138: LIST
72139: LIST
72140: PUSH
72141: LD_INT 21
72143: PUSH
72144: LD_INT 1
72146: PUSH
72147: EMPTY
72148: LIST
72149: LIST
72150: PUSH
72151: LD_INT 3
72153: PUSH
72154: LD_INT 23
72156: PUSH
72157: LD_INT 0
72159: PUSH
72160: EMPTY
72161: LIST
72162: LIST
72163: PUSH
72164: EMPTY
72165: LIST
72166: LIST
72167: PUSH
72168: EMPTY
72169: LIST
72170: LIST
72171: LIST
72172: PPUSH
72173: CALL_OW 69
72177: PUSH
72178: FOR_IN
72179: IFFALSE 72233
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
72181: LD_VAR 0 1
72185: PPUSH
72186: CALL_OW 257
72190: PUSH
72191: LD_INT 1
72193: PUSH
72194: LD_INT 2
72196: PUSH
72197: LD_INT 3
72199: PUSH
72200: LD_INT 4
72202: PUSH
72203: EMPTY
72204: LIST
72205: LIST
72206: LIST
72207: LIST
72208: IN
72209: IFFALSE 72231
// SetClass ( un , rand ( 1 , 4 ) ) ;
72211: LD_VAR 0 1
72215: PPUSH
72216: LD_INT 1
72218: PPUSH
72219: LD_INT 4
72221: PPUSH
72222: CALL_OW 12
72226: PPUSH
72227: CALL_OW 336
72231: GO 72178
72233: POP
72234: POP
// end ;
72235: PPOPN 1
72237: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
72238: LD_EXP 98
72242: PUSH
72243: LD_EXP 110
72247: AND
72248: IFFALSE 72327
72250: GO 72252
72252: DISABLE
72253: LD_INT 0
72255: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
72256: LD_ADDR_VAR 0 1
72260: PUSH
72261: LD_INT 22
72263: PUSH
72264: LD_OWVAR 2
72268: PUSH
72269: EMPTY
72270: LIST
72271: LIST
72272: PUSH
72273: LD_INT 21
72275: PUSH
72276: LD_INT 3
72278: PUSH
72279: EMPTY
72280: LIST
72281: LIST
72282: PUSH
72283: EMPTY
72284: LIST
72285: LIST
72286: PPUSH
72287: CALL_OW 69
72291: ST_TO_ADDR
// if not tmp then
72292: LD_VAR 0 1
72296: NOT
72297: IFFALSE 72301
// exit ;
72299: GO 72327
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
72301: LD_VAR 0 1
72305: PUSH
72306: LD_INT 1
72308: PPUSH
72309: LD_VAR 0 1
72313: PPUSH
72314: CALL_OW 12
72318: ARRAY
72319: PPUSH
72320: LD_INT 100
72322: PPUSH
72323: CALL_OW 234
// end ;
72327: PPOPN 1
72329: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
72330: LD_EXP 98
72334: PUSH
72335: LD_EXP 112
72339: AND
72340: IFFALSE 72438
72342: GO 72344
72344: DISABLE
72345: LD_INT 0
72347: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
72348: LD_ADDR_VAR 0 1
72352: PUSH
72353: LD_INT 22
72355: PUSH
72356: LD_OWVAR 2
72360: PUSH
72361: EMPTY
72362: LIST
72363: LIST
72364: PUSH
72365: LD_INT 21
72367: PUSH
72368: LD_INT 1
72370: PUSH
72371: EMPTY
72372: LIST
72373: LIST
72374: PUSH
72375: EMPTY
72376: LIST
72377: LIST
72378: PPUSH
72379: CALL_OW 69
72383: ST_TO_ADDR
// if not tmp then
72384: LD_VAR 0 1
72388: NOT
72389: IFFALSE 72393
// exit ;
72391: GO 72438
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
72393: LD_VAR 0 1
72397: PUSH
72398: LD_INT 1
72400: PPUSH
72401: LD_VAR 0 1
72405: PPUSH
72406: CALL_OW 12
72410: ARRAY
72411: PPUSH
72412: LD_INT 1
72414: PPUSH
72415: LD_INT 4
72417: PPUSH
72418: CALL_OW 12
72422: PPUSH
72423: LD_INT 3000
72425: PPUSH
72426: LD_INT 9000
72428: PPUSH
72429: CALL_OW 12
72433: PPUSH
72434: CALL_OW 492
// end ;
72438: PPOPN 1
72440: END
// every 0 0$1 trigger StreamModeActive and sDepot do
72441: LD_EXP 98
72445: PUSH
72446: LD_EXP 113
72450: AND
72451: IFFALSE 72471
72453: GO 72455
72455: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
72456: LD_INT 1
72458: PPUSH
72459: LD_OWVAR 2
72463: PPUSH
72464: LD_INT 0
72466: PPUSH
72467: CALL_OW 324
72471: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
72472: LD_EXP 98
72476: PUSH
72477: LD_EXP 114
72481: AND
72482: IFFALSE 72565
72484: GO 72486
72486: DISABLE
72487: LD_INT 0
72489: PPUSH
72490: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
72491: LD_ADDR_VAR 0 2
72495: PUSH
72496: LD_INT 22
72498: PUSH
72499: LD_OWVAR 2
72503: PUSH
72504: EMPTY
72505: LIST
72506: LIST
72507: PUSH
72508: LD_INT 21
72510: PUSH
72511: LD_INT 3
72513: PUSH
72514: EMPTY
72515: LIST
72516: LIST
72517: PUSH
72518: EMPTY
72519: LIST
72520: LIST
72521: PPUSH
72522: CALL_OW 69
72526: ST_TO_ADDR
// if not tmp then
72527: LD_VAR 0 2
72531: NOT
72532: IFFALSE 72536
// exit ;
72534: GO 72565
// for i in tmp do
72536: LD_ADDR_VAR 0 1
72540: PUSH
72541: LD_VAR 0 2
72545: PUSH
72546: FOR_IN
72547: IFFALSE 72563
// SetBLevel ( i , 10 ) ;
72549: LD_VAR 0 1
72553: PPUSH
72554: LD_INT 10
72556: PPUSH
72557: CALL_OW 241
72561: GO 72546
72563: POP
72564: POP
// end ;
72565: PPOPN 2
72567: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
72568: LD_EXP 98
72572: PUSH
72573: LD_EXP 115
72577: AND
72578: IFFALSE 72689
72580: GO 72582
72582: DISABLE
72583: LD_INT 0
72585: PPUSH
72586: PPUSH
72587: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
72588: LD_ADDR_VAR 0 3
72592: PUSH
72593: LD_INT 22
72595: PUSH
72596: LD_OWVAR 2
72600: PUSH
72601: EMPTY
72602: LIST
72603: LIST
72604: PUSH
72605: LD_INT 25
72607: PUSH
72608: LD_INT 1
72610: PUSH
72611: EMPTY
72612: LIST
72613: LIST
72614: PUSH
72615: EMPTY
72616: LIST
72617: LIST
72618: PPUSH
72619: CALL_OW 69
72623: ST_TO_ADDR
// if not tmp then
72624: LD_VAR 0 3
72628: NOT
72629: IFFALSE 72633
// exit ;
72631: GO 72689
// un := tmp [ rand ( 1 , tmp ) ] ;
72633: LD_ADDR_VAR 0 2
72637: PUSH
72638: LD_VAR 0 3
72642: PUSH
72643: LD_INT 1
72645: PPUSH
72646: LD_VAR 0 3
72650: PPUSH
72651: CALL_OW 12
72655: ARRAY
72656: ST_TO_ADDR
// if Crawls ( un ) then
72657: LD_VAR 0 2
72661: PPUSH
72662: CALL_OW 318
72666: IFFALSE 72677
// ComWalk ( un ) ;
72668: LD_VAR 0 2
72672: PPUSH
72673: CALL_OW 138
// SetClass ( un , class_sniper ) ;
72677: LD_VAR 0 2
72681: PPUSH
72682: LD_INT 5
72684: PPUSH
72685: CALL_OW 336
// end ;
72689: PPOPN 3
72691: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 4 do
72692: LD_EXP 98
72696: PUSH
72697: LD_EXP 116
72701: AND
72702: PUSH
72703: LD_OWVAR 67
72707: PUSH
72708: LD_INT 4
72710: LESS
72711: AND
72712: IFFALSE 72731
72714: GO 72716
72716: DISABLE
// begin Difficulty := Difficulty + 1 ;
72717: LD_ADDR_OWVAR 67
72721: PUSH
72722: LD_OWVAR 67
72726: PUSH
72727: LD_INT 1
72729: PLUS
72730: ST_TO_ADDR
// end ;
72731: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
72732: LD_EXP 98
72736: PUSH
72737: LD_EXP 117
72741: AND
72742: IFFALSE 72845
72744: GO 72746
72746: DISABLE
72747: LD_INT 0
72749: PPUSH
// begin for i := 1 to 5 do
72750: LD_ADDR_VAR 0 1
72754: PUSH
72755: DOUBLE
72756: LD_INT 1
72758: DEC
72759: ST_TO_ADDR
72760: LD_INT 5
72762: PUSH
72763: FOR_TO
72764: IFFALSE 72843
// begin uc_nation := nation_nature ;
72766: LD_ADDR_OWVAR 21
72770: PUSH
72771: LD_INT 0
72773: ST_TO_ADDR
// uc_side := 0 ;
72774: LD_ADDR_OWVAR 20
72778: PUSH
72779: LD_INT 0
72781: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
72782: LD_ADDR_OWVAR 29
72786: PUSH
72787: LD_INT 12
72789: PUSH
72790: LD_INT 12
72792: PUSH
72793: EMPTY
72794: LIST
72795: LIST
72796: ST_TO_ADDR
// hc_agressivity := 20 ;
72797: LD_ADDR_OWVAR 35
72801: PUSH
72802: LD_INT 20
72804: ST_TO_ADDR
// hc_class := class_tiger ;
72805: LD_ADDR_OWVAR 28
72809: PUSH
72810: LD_INT 14
72812: ST_TO_ADDR
// hc_gallery :=  ;
72813: LD_ADDR_OWVAR 33
72817: PUSH
72818: LD_STRING 
72820: ST_TO_ADDR
// hc_name :=  ;
72821: LD_ADDR_OWVAR 26
72825: PUSH
72826: LD_STRING 
72828: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
72829: CALL_OW 44
72833: PPUSH
72834: LD_INT 0
72836: PPUSH
72837: CALL_OW 51
// end ;
72841: GO 72763
72843: POP
72844: POP
// end ;
72845: PPOPN 1
72847: END
// every 0 0$1 trigger StreamModeActive and sBomb do
72848: LD_EXP 98
72852: PUSH
72853: LD_EXP 118
72857: AND
72858: IFFALSE 72867
72860: GO 72862
72862: DISABLE
// StreamSibBomb ;
72863: CALL 72868 0 0
72867: END
// export function StreamSibBomb ; var i , x , y ; begin
72868: LD_INT 0
72870: PPUSH
72871: PPUSH
72872: PPUSH
72873: PPUSH
// result := false ;
72874: LD_ADDR_VAR 0 1
72878: PUSH
72879: LD_INT 0
72881: ST_TO_ADDR
// for i := 1 to 16 do
72882: LD_ADDR_VAR 0 2
72886: PUSH
72887: DOUBLE
72888: LD_INT 1
72890: DEC
72891: ST_TO_ADDR
72892: LD_INT 16
72894: PUSH
72895: FOR_TO
72896: IFFALSE 73095
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
72898: LD_ADDR_VAR 0 3
72902: PUSH
72903: LD_INT 10
72905: PUSH
72906: LD_INT 20
72908: PUSH
72909: LD_INT 30
72911: PUSH
72912: LD_INT 40
72914: PUSH
72915: LD_INT 50
72917: PUSH
72918: LD_INT 60
72920: PUSH
72921: LD_INT 70
72923: PUSH
72924: LD_INT 80
72926: PUSH
72927: LD_INT 90
72929: PUSH
72930: LD_INT 100
72932: PUSH
72933: LD_INT 110
72935: PUSH
72936: LD_INT 120
72938: PUSH
72939: LD_INT 130
72941: PUSH
72942: LD_INT 140
72944: PUSH
72945: LD_INT 150
72947: PUSH
72948: EMPTY
72949: LIST
72950: LIST
72951: LIST
72952: LIST
72953: LIST
72954: LIST
72955: LIST
72956: LIST
72957: LIST
72958: LIST
72959: LIST
72960: LIST
72961: LIST
72962: LIST
72963: LIST
72964: PUSH
72965: LD_INT 1
72967: PPUSH
72968: LD_INT 15
72970: PPUSH
72971: CALL_OW 12
72975: ARRAY
72976: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
72977: LD_ADDR_VAR 0 4
72981: PUSH
72982: LD_INT 10
72984: PUSH
72985: LD_INT 20
72987: PUSH
72988: LD_INT 30
72990: PUSH
72991: LD_INT 40
72993: PUSH
72994: LD_INT 50
72996: PUSH
72997: LD_INT 60
72999: PUSH
73000: LD_INT 70
73002: PUSH
73003: LD_INT 80
73005: PUSH
73006: LD_INT 90
73008: PUSH
73009: LD_INT 100
73011: PUSH
73012: LD_INT 110
73014: PUSH
73015: LD_INT 120
73017: PUSH
73018: LD_INT 130
73020: PUSH
73021: LD_INT 140
73023: PUSH
73024: LD_INT 150
73026: PUSH
73027: EMPTY
73028: LIST
73029: LIST
73030: LIST
73031: LIST
73032: LIST
73033: LIST
73034: LIST
73035: LIST
73036: LIST
73037: LIST
73038: LIST
73039: LIST
73040: LIST
73041: LIST
73042: LIST
73043: PUSH
73044: LD_INT 1
73046: PPUSH
73047: LD_INT 15
73049: PPUSH
73050: CALL_OW 12
73054: ARRAY
73055: ST_TO_ADDR
// if ValidHex ( x , y ) then
73056: LD_VAR 0 3
73060: PPUSH
73061: LD_VAR 0 4
73065: PPUSH
73066: CALL_OW 488
73070: IFFALSE 73093
// begin result := [ x , y ] ;
73072: LD_ADDR_VAR 0 1
73076: PUSH
73077: LD_VAR 0 3
73081: PUSH
73082: LD_VAR 0 4
73086: PUSH
73087: EMPTY
73088: LIST
73089: LIST
73090: ST_TO_ADDR
// break ;
73091: GO 73095
// end ; end ;
73093: GO 72895
73095: POP
73096: POP
// if result then
73097: LD_VAR 0 1
73101: IFFALSE 73161
// begin ToLua ( playSibBomb() ) ;
73103: LD_STRING playSibBomb()
73105: PPUSH
73106: CALL_OW 559
// wait ( 0 0$14 ) ;
73110: LD_INT 490
73112: PPUSH
73113: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
73117: LD_VAR 0 1
73121: PUSH
73122: LD_INT 1
73124: ARRAY
73125: PPUSH
73126: LD_VAR 0 1
73130: PUSH
73131: LD_INT 2
73133: ARRAY
73134: PPUSH
73135: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
73139: LD_VAR 0 1
73143: PUSH
73144: LD_INT 1
73146: ARRAY
73147: PPUSH
73148: LD_VAR 0 1
73152: PUSH
73153: LD_INT 2
73155: ARRAY
73156: PPUSH
73157: CALL_OW 429
// end ; end ;
73161: LD_VAR 0 1
73165: RET
// every 0 0$1 trigger StreamModeActive and sReset do
73166: LD_EXP 98
73170: PUSH
73171: LD_EXP 120
73175: AND
73176: IFFALSE 73188
73178: GO 73180
73180: DISABLE
// YouLost (  ) ;
73181: LD_STRING 
73183: PPUSH
73184: CALL_OW 104
73188: END
// every 0 0$1 trigger StreamModeActive and sFog do
73189: LD_EXP 98
73193: PUSH
73194: LD_EXP 119
73198: AND
73199: IFFALSE 73213
73201: GO 73203
73203: DISABLE
// FogOff ( your_side ) ;
73204: LD_OWVAR 2
73208: PPUSH
73209: CALL_OW 344
73213: END
// every 0 0$1 trigger StreamModeActive and sSun do
73214: LD_EXP 98
73218: PUSH
73219: LD_EXP 121
73223: AND
73224: IFFALSE 73252
73226: GO 73228
73228: DISABLE
// begin solar_recharge_percent := 0 ;
73229: LD_ADDR_OWVAR 79
73233: PUSH
73234: LD_INT 0
73236: ST_TO_ADDR
// wait ( 5 5$00 ) ;
73237: LD_INT 10500
73239: PPUSH
73240: CALL_OW 67
// solar_recharge_percent := 100 ;
73244: LD_ADDR_OWVAR 79
73248: PUSH
73249: LD_INT 100
73251: ST_TO_ADDR
// end ;
73252: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
73253: LD_EXP 98
73257: PUSH
73258: LD_EXP 122
73262: AND
73263: IFFALSE 73502
73265: GO 73267
73267: DISABLE
73268: LD_INT 0
73270: PPUSH
73271: PPUSH
73272: PPUSH
// begin tmp := [ ] ;
73273: LD_ADDR_VAR 0 3
73277: PUSH
73278: EMPTY
73279: ST_TO_ADDR
// for i := 1 to 6 do
73280: LD_ADDR_VAR 0 1
73284: PUSH
73285: DOUBLE
73286: LD_INT 1
73288: DEC
73289: ST_TO_ADDR
73290: LD_INT 6
73292: PUSH
73293: FOR_TO
73294: IFFALSE 73399
// begin uc_nation := nation_nature ;
73296: LD_ADDR_OWVAR 21
73300: PUSH
73301: LD_INT 0
73303: ST_TO_ADDR
// uc_side := 0 ;
73304: LD_ADDR_OWVAR 20
73308: PUSH
73309: LD_INT 0
73311: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
73312: LD_ADDR_OWVAR 29
73316: PUSH
73317: LD_INT 12
73319: PUSH
73320: LD_INT 12
73322: PUSH
73323: EMPTY
73324: LIST
73325: LIST
73326: ST_TO_ADDR
// hc_agressivity := 20 ;
73327: LD_ADDR_OWVAR 35
73331: PUSH
73332: LD_INT 20
73334: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
73335: LD_ADDR_OWVAR 28
73339: PUSH
73340: LD_INT 17
73342: ST_TO_ADDR
// hc_gallery :=  ;
73343: LD_ADDR_OWVAR 33
73347: PUSH
73348: LD_STRING 
73350: ST_TO_ADDR
// hc_name :=  ;
73351: LD_ADDR_OWVAR 26
73355: PUSH
73356: LD_STRING 
73358: ST_TO_ADDR
// un := CreateHuman ;
73359: LD_ADDR_VAR 0 2
73363: PUSH
73364: CALL_OW 44
73368: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
73369: LD_VAR 0 2
73373: PPUSH
73374: LD_INT 1
73376: PPUSH
73377: CALL_OW 51
// tmp := tmp ^ un ;
73381: LD_ADDR_VAR 0 3
73385: PUSH
73386: LD_VAR 0 3
73390: PUSH
73391: LD_VAR 0 2
73395: ADD
73396: ST_TO_ADDR
// end ;
73397: GO 73293
73399: POP
73400: POP
// repeat wait ( 0 0$1 ) ;
73401: LD_INT 35
73403: PPUSH
73404: CALL_OW 67
// for un in tmp do
73408: LD_ADDR_VAR 0 2
73412: PUSH
73413: LD_VAR 0 3
73417: PUSH
73418: FOR_IN
73419: IFFALSE 73493
// begin if IsDead ( un ) then
73421: LD_VAR 0 2
73425: PPUSH
73426: CALL_OW 301
73430: IFFALSE 73450
// begin tmp := tmp diff un ;
73432: LD_ADDR_VAR 0 3
73436: PUSH
73437: LD_VAR 0 3
73441: PUSH
73442: LD_VAR 0 2
73446: DIFF
73447: ST_TO_ADDR
// continue ;
73448: GO 73418
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
73450: LD_VAR 0 2
73454: PPUSH
73455: LD_INT 3
73457: PUSH
73458: LD_INT 22
73460: PUSH
73461: LD_INT 0
73463: PUSH
73464: EMPTY
73465: LIST
73466: LIST
73467: PUSH
73468: EMPTY
73469: LIST
73470: LIST
73471: PPUSH
73472: CALL_OW 69
73476: PPUSH
73477: LD_VAR 0 2
73481: PPUSH
73482: CALL_OW 74
73486: PPUSH
73487: CALL_OW 115
// end ;
73491: GO 73418
73493: POP
73494: POP
// until not tmp ;
73495: LD_VAR 0 3
73499: NOT
73500: IFFALSE 73401
// end ;
73502: PPOPN 3
73504: END
// every 0 0$1 trigger StreamModeActive and sTroll do
73505: LD_EXP 98
73509: PUSH
73510: LD_EXP 123
73514: AND
73515: IFFALSE 73569
73517: GO 73519
73519: DISABLE
// begin ToLua ( displayTroll(); ) ;
73520: LD_STRING displayTroll();
73522: PPUSH
73523: CALL_OW 559
// wait ( 3 3$00 ) ;
73527: LD_INT 6300
73529: PPUSH
73530: CALL_OW 67
// ToLua ( hideTroll(); ) ;
73534: LD_STRING hideTroll();
73536: PPUSH
73537: CALL_OW 559
// wait ( 1 1$00 ) ;
73541: LD_INT 2100
73543: PPUSH
73544: CALL_OW 67
// ToLua ( displayTroll(); ) ;
73548: LD_STRING displayTroll();
73550: PPUSH
73551: CALL_OW 559
// wait ( 1 1$00 ) ;
73555: LD_INT 2100
73557: PPUSH
73558: CALL_OW 67
// ToLua ( hideTroll(); ) ;
73562: LD_STRING hideTroll();
73564: PPUSH
73565: CALL_OW 559
// end ;
73569: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
73570: LD_EXP 98
73574: PUSH
73575: LD_EXP 124
73579: AND
73580: IFFALSE 73643
73582: GO 73584
73584: DISABLE
73585: LD_INT 0
73587: PPUSH
// begin p := 0 ;
73588: LD_ADDR_VAR 0 1
73592: PUSH
73593: LD_INT 0
73595: ST_TO_ADDR
// repeat game_speed := 1 ;
73596: LD_ADDR_OWVAR 65
73600: PUSH
73601: LD_INT 1
73603: ST_TO_ADDR
// wait ( 0 0$1 ) ;
73604: LD_INT 35
73606: PPUSH
73607: CALL_OW 67
// p := p + 1 ;
73611: LD_ADDR_VAR 0 1
73615: PUSH
73616: LD_VAR 0 1
73620: PUSH
73621: LD_INT 1
73623: PLUS
73624: ST_TO_ADDR
// until p >= 60 ;
73625: LD_VAR 0 1
73629: PUSH
73630: LD_INT 60
73632: GREATEREQUAL
73633: IFFALSE 73596
// game_speed := 4 ;
73635: LD_ADDR_OWVAR 65
73639: PUSH
73640: LD_INT 4
73642: ST_TO_ADDR
// end ;
73643: PPOPN 1
73645: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
73646: LD_EXP 98
73650: PUSH
73651: LD_EXP 125
73655: AND
73656: IFFALSE 73802
73658: GO 73660
73660: DISABLE
73661: LD_INT 0
73663: PPUSH
73664: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
73665: LD_ADDR_VAR 0 1
73669: PUSH
73670: LD_INT 22
73672: PUSH
73673: LD_OWVAR 2
73677: PUSH
73678: EMPTY
73679: LIST
73680: LIST
73681: PUSH
73682: LD_INT 2
73684: PUSH
73685: LD_INT 30
73687: PUSH
73688: LD_INT 0
73690: PUSH
73691: EMPTY
73692: LIST
73693: LIST
73694: PUSH
73695: LD_INT 30
73697: PUSH
73698: LD_INT 1
73700: PUSH
73701: EMPTY
73702: LIST
73703: LIST
73704: PUSH
73705: EMPTY
73706: LIST
73707: LIST
73708: LIST
73709: PUSH
73710: EMPTY
73711: LIST
73712: LIST
73713: PPUSH
73714: CALL_OW 69
73718: ST_TO_ADDR
// if not depot then
73719: LD_VAR 0 1
73723: NOT
73724: IFFALSE 73728
// exit ;
73726: GO 73802
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
73728: LD_ADDR_VAR 0 2
73732: PUSH
73733: LD_VAR 0 1
73737: PUSH
73738: LD_INT 1
73740: PPUSH
73741: LD_VAR 0 1
73745: PPUSH
73746: CALL_OW 12
73750: ARRAY
73751: PPUSH
73752: CALL_OW 274
73756: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
73757: LD_VAR 0 2
73761: PPUSH
73762: LD_INT 1
73764: PPUSH
73765: LD_INT 0
73767: PPUSH
73768: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
73772: LD_VAR 0 2
73776: PPUSH
73777: LD_INT 2
73779: PPUSH
73780: LD_INT 0
73782: PPUSH
73783: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
73787: LD_VAR 0 2
73791: PPUSH
73792: LD_INT 3
73794: PPUSH
73795: LD_INT 0
73797: PPUSH
73798: CALL_OW 277
// end ;
73802: PPOPN 2
73804: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
73805: LD_EXP 98
73809: PUSH
73810: LD_EXP 126
73814: AND
73815: IFFALSE 73912
73817: GO 73819
73819: DISABLE
73820: LD_INT 0
73822: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
73823: LD_ADDR_VAR 0 1
73827: PUSH
73828: LD_INT 22
73830: PUSH
73831: LD_OWVAR 2
73835: PUSH
73836: EMPTY
73837: LIST
73838: LIST
73839: PUSH
73840: LD_INT 21
73842: PUSH
73843: LD_INT 1
73845: PUSH
73846: EMPTY
73847: LIST
73848: LIST
73849: PUSH
73850: LD_INT 3
73852: PUSH
73853: LD_INT 23
73855: PUSH
73856: LD_INT 0
73858: PUSH
73859: EMPTY
73860: LIST
73861: LIST
73862: PUSH
73863: EMPTY
73864: LIST
73865: LIST
73866: PUSH
73867: EMPTY
73868: LIST
73869: LIST
73870: LIST
73871: PPUSH
73872: CALL_OW 69
73876: ST_TO_ADDR
// if not tmp then
73877: LD_VAR 0 1
73881: NOT
73882: IFFALSE 73886
// exit ;
73884: GO 73912
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
73886: LD_VAR 0 1
73890: PUSH
73891: LD_INT 1
73893: PPUSH
73894: LD_VAR 0 1
73898: PPUSH
73899: CALL_OW 12
73903: ARRAY
73904: PPUSH
73905: LD_INT 200
73907: PPUSH
73908: CALL_OW 234
// end ;
73912: PPOPN 1
73914: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
73915: LD_EXP 98
73919: PUSH
73920: LD_EXP 127
73924: AND
73925: IFFALSE 74004
73927: GO 73929
73929: DISABLE
73930: LD_INT 0
73932: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
73933: LD_ADDR_VAR 0 1
73937: PUSH
73938: LD_INT 22
73940: PUSH
73941: LD_OWVAR 2
73945: PUSH
73946: EMPTY
73947: LIST
73948: LIST
73949: PUSH
73950: LD_INT 21
73952: PUSH
73953: LD_INT 2
73955: PUSH
73956: EMPTY
73957: LIST
73958: LIST
73959: PUSH
73960: EMPTY
73961: LIST
73962: LIST
73963: PPUSH
73964: CALL_OW 69
73968: ST_TO_ADDR
// if not tmp then
73969: LD_VAR 0 1
73973: NOT
73974: IFFALSE 73978
// exit ;
73976: GO 74004
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
73978: LD_VAR 0 1
73982: PUSH
73983: LD_INT 1
73985: PPUSH
73986: LD_VAR 0 1
73990: PPUSH
73991: CALL_OW 12
73995: ARRAY
73996: PPUSH
73997: LD_INT 60
73999: PPUSH
74000: CALL_OW 234
// end ;
74004: PPOPN 1
74006: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
74007: LD_EXP 98
74011: PUSH
74012: LD_EXP 128
74016: AND
74017: IFFALSE 74116
74019: GO 74021
74021: DISABLE
74022: LD_INT 0
74024: PPUSH
74025: PPUSH
// begin enable ;
74026: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
74027: LD_ADDR_VAR 0 1
74031: PUSH
74032: LD_INT 22
74034: PUSH
74035: LD_OWVAR 2
74039: PUSH
74040: EMPTY
74041: LIST
74042: LIST
74043: PUSH
74044: LD_INT 61
74046: PUSH
74047: EMPTY
74048: LIST
74049: PUSH
74050: LD_INT 33
74052: PUSH
74053: LD_INT 2
74055: PUSH
74056: EMPTY
74057: LIST
74058: LIST
74059: PUSH
74060: EMPTY
74061: LIST
74062: LIST
74063: LIST
74064: PPUSH
74065: CALL_OW 69
74069: ST_TO_ADDR
// if not tmp then
74070: LD_VAR 0 1
74074: NOT
74075: IFFALSE 74079
// exit ;
74077: GO 74116
// for i in tmp do
74079: LD_ADDR_VAR 0 2
74083: PUSH
74084: LD_VAR 0 1
74088: PUSH
74089: FOR_IN
74090: IFFALSE 74114
// if IsControledBy ( i ) then
74092: LD_VAR 0 2
74096: PPUSH
74097: CALL_OW 312
74101: IFFALSE 74112
// ComUnlink ( i ) ;
74103: LD_VAR 0 2
74107: PPUSH
74108: CALL_OW 136
74112: GO 74089
74114: POP
74115: POP
// end ;
74116: PPOPN 2
74118: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
74119: LD_EXP 98
74123: PUSH
74124: LD_EXP 129
74128: AND
74129: IFFALSE 74269
74131: GO 74133
74133: DISABLE
74134: LD_INT 0
74136: PPUSH
74137: PPUSH
// begin ToLua ( displayPowell(); ) ;
74138: LD_STRING displayPowell();
74140: PPUSH
74141: CALL_OW 559
// uc_side := 0 ;
74145: LD_ADDR_OWVAR 20
74149: PUSH
74150: LD_INT 0
74152: ST_TO_ADDR
// uc_nation := 2 ;
74153: LD_ADDR_OWVAR 21
74157: PUSH
74158: LD_INT 2
74160: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
74161: LD_ADDR_OWVAR 37
74165: PUSH
74166: LD_INT 14
74168: ST_TO_ADDR
// vc_engine := engine_siberite ;
74169: LD_ADDR_OWVAR 39
74173: PUSH
74174: LD_INT 3
74176: ST_TO_ADDR
// vc_control := control_apeman ;
74177: LD_ADDR_OWVAR 38
74181: PUSH
74182: LD_INT 5
74184: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
74185: LD_ADDR_OWVAR 40
74189: PUSH
74190: LD_INT 29
74192: ST_TO_ADDR
// un := CreateVehicle ;
74193: LD_ADDR_VAR 0 2
74197: PUSH
74198: CALL_OW 45
74202: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
74203: LD_VAR 0 2
74207: PPUSH
74208: LD_INT 1
74210: PPUSH
74211: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
74215: LD_INT 35
74217: PPUSH
74218: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
74222: LD_VAR 0 2
74226: PPUSH
74227: LD_INT 22
74229: PUSH
74230: LD_OWVAR 2
74234: PUSH
74235: EMPTY
74236: LIST
74237: LIST
74238: PPUSH
74239: CALL_OW 69
74243: PPUSH
74244: LD_VAR 0 2
74248: PPUSH
74249: CALL_OW 74
74253: PPUSH
74254: CALL_OW 115
// until IsDead ( un ) ;
74258: LD_VAR 0 2
74262: PPUSH
74263: CALL_OW 301
74267: IFFALSE 74215
// end ;
74269: PPOPN 2
74271: END
// every 0 0$1 trigger StreamModeActive and sStu do
74272: LD_EXP 98
74276: PUSH
74277: LD_EXP 137
74281: AND
74282: IFFALSE 74298
74284: GO 74286
74286: DISABLE
// begin ToLua ( displayStucuk(); ) ;
74287: LD_STRING displayStucuk();
74289: PPUSH
74290: CALL_OW 559
// ResetFog ;
74294: CALL_OW 335
// end ;
74298: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
74299: LD_EXP 98
74303: PUSH
74304: LD_EXP 130
74308: AND
74309: IFFALSE 74450
74311: GO 74313
74313: DISABLE
74314: LD_INT 0
74316: PPUSH
74317: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
74318: LD_ADDR_VAR 0 2
74322: PUSH
74323: LD_INT 22
74325: PUSH
74326: LD_OWVAR 2
74330: PUSH
74331: EMPTY
74332: LIST
74333: LIST
74334: PUSH
74335: LD_INT 21
74337: PUSH
74338: LD_INT 1
74340: PUSH
74341: EMPTY
74342: LIST
74343: LIST
74344: PUSH
74345: EMPTY
74346: LIST
74347: LIST
74348: PPUSH
74349: CALL_OW 69
74353: ST_TO_ADDR
// if not tmp then
74354: LD_VAR 0 2
74358: NOT
74359: IFFALSE 74363
// exit ;
74361: GO 74450
// un := tmp [ rand ( 1 , tmp ) ] ;
74363: LD_ADDR_VAR 0 1
74367: PUSH
74368: LD_VAR 0 2
74372: PUSH
74373: LD_INT 1
74375: PPUSH
74376: LD_VAR 0 2
74380: PPUSH
74381: CALL_OW 12
74385: ARRAY
74386: ST_TO_ADDR
// SetSide ( un , 0 ) ;
74387: LD_VAR 0 1
74391: PPUSH
74392: LD_INT 0
74394: PPUSH
74395: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
74399: LD_VAR 0 1
74403: PPUSH
74404: LD_OWVAR 3
74408: PUSH
74409: LD_VAR 0 1
74413: DIFF
74414: PPUSH
74415: LD_VAR 0 1
74419: PPUSH
74420: CALL_OW 74
74424: PPUSH
74425: CALL_OW 115
// wait ( 0 0$20 ) ;
74429: LD_INT 700
74431: PPUSH
74432: CALL_OW 67
// SetSide ( un , your_side ) ;
74436: LD_VAR 0 1
74440: PPUSH
74441: LD_OWVAR 2
74445: PPUSH
74446: CALL_OW 235
// end ;
74450: PPOPN 2
74452: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
74453: LD_EXP 98
74457: PUSH
74458: LD_EXP 131
74462: AND
74463: IFFALSE 74569
74465: GO 74467
74467: DISABLE
74468: LD_INT 0
74470: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
74471: LD_ADDR_VAR 0 1
74475: PUSH
74476: LD_INT 22
74478: PUSH
74479: LD_OWVAR 2
74483: PUSH
74484: EMPTY
74485: LIST
74486: LIST
74487: PUSH
74488: LD_INT 2
74490: PUSH
74491: LD_INT 30
74493: PUSH
74494: LD_INT 0
74496: PUSH
74497: EMPTY
74498: LIST
74499: LIST
74500: PUSH
74501: LD_INT 30
74503: PUSH
74504: LD_INT 1
74506: PUSH
74507: EMPTY
74508: LIST
74509: LIST
74510: PUSH
74511: EMPTY
74512: LIST
74513: LIST
74514: LIST
74515: PUSH
74516: EMPTY
74517: LIST
74518: LIST
74519: PPUSH
74520: CALL_OW 69
74524: ST_TO_ADDR
// if not depot then
74525: LD_VAR 0 1
74529: NOT
74530: IFFALSE 74534
// exit ;
74532: GO 74569
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
74534: LD_VAR 0 1
74538: PUSH
74539: LD_INT 1
74541: ARRAY
74542: PPUSH
74543: CALL_OW 250
74547: PPUSH
74548: LD_VAR 0 1
74552: PUSH
74553: LD_INT 1
74555: ARRAY
74556: PPUSH
74557: CALL_OW 251
74561: PPUSH
74562: LD_INT 70
74564: PPUSH
74565: CALL_OW 495
// end ;
74569: PPOPN 1
74571: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
74572: LD_EXP 98
74576: PUSH
74577: LD_EXP 132
74581: AND
74582: IFFALSE 74793
74584: GO 74586
74586: DISABLE
74587: LD_INT 0
74589: PPUSH
74590: PPUSH
74591: PPUSH
74592: PPUSH
74593: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
74594: LD_ADDR_VAR 0 5
74598: PUSH
74599: LD_INT 22
74601: PUSH
74602: LD_OWVAR 2
74606: PUSH
74607: EMPTY
74608: LIST
74609: LIST
74610: PUSH
74611: LD_INT 21
74613: PUSH
74614: LD_INT 1
74616: PUSH
74617: EMPTY
74618: LIST
74619: LIST
74620: PUSH
74621: EMPTY
74622: LIST
74623: LIST
74624: PPUSH
74625: CALL_OW 69
74629: ST_TO_ADDR
// if not tmp then
74630: LD_VAR 0 5
74634: NOT
74635: IFFALSE 74639
// exit ;
74637: GO 74793
// for i in tmp do
74639: LD_ADDR_VAR 0 1
74643: PUSH
74644: LD_VAR 0 5
74648: PUSH
74649: FOR_IN
74650: IFFALSE 74791
// begin d := rand ( 0 , 5 ) ;
74652: LD_ADDR_VAR 0 4
74656: PUSH
74657: LD_INT 0
74659: PPUSH
74660: LD_INT 5
74662: PPUSH
74663: CALL_OW 12
74667: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
74668: LD_ADDR_VAR 0 2
74672: PUSH
74673: LD_VAR 0 1
74677: PPUSH
74678: CALL_OW 250
74682: PPUSH
74683: LD_VAR 0 4
74687: PPUSH
74688: LD_INT 3
74690: PPUSH
74691: LD_INT 12
74693: PPUSH
74694: CALL_OW 12
74698: PPUSH
74699: CALL_OW 272
74703: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
74704: LD_ADDR_VAR 0 3
74708: PUSH
74709: LD_VAR 0 1
74713: PPUSH
74714: CALL_OW 251
74718: PPUSH
74719: LD_VAR 0 4
74723: PPUSH
74724: LD_INT 3
74726: PPUSH
74727: LD_INT 12
74729: PPUSH
74730: CALL_OW 12
74734: PPUSH
74735: CALL_OW 273
74739: ST_TO_ADDR
// if ValidHex ( x , y ) then
74740: LD_VAR 0 2
74744: PPUSH
74745: LD_VAR 0 3
74749: PPUSH
74750: CALL_OW 488
74754: IFFALSE 74789
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
74756: LD_VAR 0 1
74760: PPUSH
74761: LD_VAR 0 2
74765: PPUSH
74766: LD_VAR 0 3
74770: PPUSH
74771: LD_INT 3
74773: PPUSH
74774: LD_INT 6
74776: PPUSH
74777: CALL_OW 12
74781: PPUSH
74782: LD_INT 1
74784: PPUSH
74785: CALL_OW 483
// end ;
74789: GO 74649
74791: POP
74792: POP
// end ;
74793: PPOPN 5
74795: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
74796: LD_EXP 98
74800: PUSH
74801: LD_EXP 133
74805: AND
74806: IFFALSE 74900
74808: GO 74810
74810: DISABLE
74811: LD_INT 0
74813: PPUSH
74814: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
74815: LD_ADDR_VAR 0 2
74819: PUSH
74820: LD_INT 22
74822: PUSH
74823: LD_OWVAR 2
74827: PUSH
74828: EMPTY
74829: LIST
74830: LIST
74831: PUSH
74832: LD_INT 32
74834: PUSH
74835: LD_INT 1
74837: PUSH
74838: EMPTY
74839: LIST
74840: LIST
74841: PUSH
74842: LD_INT 21
74844: PUSH
74845: LD_INT 2
74847: PUSH
74848: EMPTY
74849: LIST
74850: LIST
74851: PUSH
74852: EMPTY
74853: LIST
74854: LIST
74855: LIST
74856: PPUSH
74857: CALL_OW 69
74861: ST_TO_ADDR
// if not tmp then
74862: LD_VAR 0 2
74866: NOT
74867: IFFALSE 74871
// exit ;
74869: GO 74900
// for i in tmp do
74871: LD_ADDR_VAR 0 1
74875: PUSH
74876: LD_VAR 0 2
74880: PUSH
74881: FOR_IN
74882: IFFALSE 74898
// SetFuel ( i , 0 ) ;
74884: LD_VAR 0 1
74888: PPUSH
74889: LD_INT 0
74891: PPUSH
74892: CALL_OW 240
74896: GO 74881
74898: POP
74899: POP
// end ;
74900: PPOPN 2
74902: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
74903: LD_EXP 98
74907: PUSH
74908: LD_EXP 134
74912: AND
74913: IFFALSE 74979
74915: GO 74917
74917: DISABLE
74918: LD_INT 0
74920: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
74921: LD_ADDR_VAR 0 1
74925: PUSH
74926: LD_INT 22
74928: PUSH
74929: LD_OWVAR 2
74933: PUSH
74934: EMPTY
74935: LIST
74936: LIST
74937: PUSH
74938: LD_INT 30
74940: PUSH
74941: LD_INT 29
74943: PUSH
74944: EMPTY
74945: LIST
74946: LIST
74947: PUSH
74948: EMPTY
74949: LIST
74950: LIST
74951: PPUSH
74952: CALL_OW 69
74956: ST_TO_ADDR
// if not tmp then
74957: LD_VAR 0 1
74961: NOT
74962: IFFALSE 74966
// exit ;
74964: GO 74979
// DestroyUnit ( tmp [ 1 ] ) ;
74966: LD_VAR 0 1
74970: PUSH
74971: LD_INT 1
74973: ARRAY
74974: PPUSH
74975: CALL_OW 65
// end ;
74979: PPOPN 1
74981: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
74982: LD_EXP 98
74986: PUSH
74987: LD_EXP 136
74991: AND
74992: IFFALSE 75121
74994: GO 74996
74996: DISABLE
74997: LD_INT 0
74999: PPUSH
// begin uc_side := 0 ;
75000: LD_ADDR_OWVAR 20
75004: PUSH
75005: LD_INT 0
75007: ST_TO_ADDR
// uc_nation := nation_arabian ;
75008: LD_ADDR_OWVAR 21
75012: PUSH
75013: LD_INT 2
75015: ST_TO_ADDR
// hc_gallery :=  ;
75016: LD_ADDR_OWVAR 33
75020: PUSH
75021: LD_STRING 
75023: ST_TO_ADDR
// hc_name :=  ;
75024: LD_ADDR_OWVAR 26
75028: PUSH
75029: LD_STRING 
75031: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
75032: LD_INT 1
75034: PPUSH
75035: LD_INT 11
75037: PPUSH
75038: LD_INT 10
75040: PPUSH
75041: CALL_OW 380
// un := CreateHuman ;
75045: LD_ADDR_VAR 0 1
75049: PUSH
75050: CALL_OW 44
75054: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
75055: LD_VAR 0 1
75059: PPUSH
75060: LD_INT 1
75062: PPUSH
75063: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
75067: LD_INT 35
75069: PPUSH
75070: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
75074: LD_VAR 0 1
75078: PPUSH
75079: LD_INT 22
75081: PUSH
75082: LD_OWVAR 2
75086: PUSH
75087: EMPTY
75088: LIST
75089: LIST
75090: PPUSH
75091: CALL_OW 69
75095: PPUSH
75096: LD_VAR 0 1
75100: PPUSH
75101: CALL_OW 74
75105: PPUSH
75106: CALL_OW 115
// until IsDead ( un ) ;
75110: LD_VAR 0 1
75114: PPUSH
75115: CALL_OW 301
75119: IFFALSE 75067
// end ;
75121: PPOPN 1
75123: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
75124: LD_EXP 98
75128: PUSH
75129: LD_EXP 138
75133: AND
75134: IFFALSE 75146
75136: GO 75138
75138: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
75139: LD_STRING earthquake(getX(game), 0, 32)
75141: PPUSH
75142: CALL_OW 559
75146: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
75147: LD_EXP 98
75151: PUSH
75152: LD_EXP 139
75156: AND
75157: IFFALSE 75248
75159: GO 75161
75161: DISABLE
75162: LD_INT 0
75164: PPUSH
// begin enable ;
75165: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
75166: LD_ADDR_VAR 0 1
75170: PUSH
75171: LD_INT 22
75173: PUSH
75174: LD_OWVAR 2
75178: PUSH
75179: EMPTY
75180: LIST
75181: LIST
75182: PUSH
75183: LD_INT 21
75185: PUSH
75186: LD_INT 2
75188: PUSH
75189: EMPTY
75190: LIST
75191: LIST
75192: PUSH
75193: LD_INT 33
75195: PUSH
75196: LD_INT 3
75198: PUSH
75199: EMPTY
75200: LIST
75201: LIST
75202: PUSH
75203: EMPTY
75204: LIST
75205: LIST
75206: LIST
75207: PPUSH
75208: CALL_OW 69
75212: ST_TO_ADDR
// if not tmp then
75213: LD_VAR 0 1
75217: NOT
75218: IFFALSE 75222
// exit ;
75220: GO 75248
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
75222: LD_VAR 0 1
75226: PUSH
75227: LD_INT 1
75229: PPUSH
75230: LD_VAR 0 1
75234: PPUSH
75235: CALL_OW 12
75239: ARRAY
75240: PPUSH
75241: LD_INT 1
75243: PPUSH
75244: CALL_OW 234
// end ;
75248: PPOPN 1
75250: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
75251: LD_EXP 98
75255: PUSH
75256: LD_EXP 140
75260: AND
75261: IFFALSE 75402
75263: GO 75265
75265: DISABLE
75266: LD_INT 0
75268: PPUSH
75269: PPUSH
75270: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
75271: LD_ADDR_VAR 0 3
75275: PUSH
75276: LD_INT 22
75278: PUSH
75279: LD_OWVAR 2
75283: PUSH
75284: EMPTY
75285: LIST
75286: LIST
75287: PUSH
75288: LD_INT 25
75290: PUSH
75291: LD_INT 1
75293: PUSH
75294: EMPTY
75295: LIST
75296: LIST
75297: PUSH
75298: EMPTY
75299: LIST
75300: LIST
75301: PPUSH
75302: CALL_OW 69
75306: ST_TO_ADDR
// if not tmp then
75307: LD_VAR 0 3
75311: NOT
75312: IFFALSE 75316
// exit ;
75314: GO 75402
// un := tmp [ rand ( 1 , tmp ) ] ;
75316: LD_ADDR_VAR 0 2
75320: PUSH
75321: LD_VAR 0 3
75325: PUSH
75326: LD_INT 1
75328: PPUSH
75329: LD_VAR 0 3
75333: PPUSH
75334: CALL_OW 12
75338: ARRAY
75339: ST_TO_ADDR
// if Crawls ( un ) then
75340: LD_VAR 0 2
75344: PPUSH
75345: CALL_OW 318
75349: IFFALSE 75360
// ComWalk ( un ) ;
75351: LD_VAR 0 2
75355: PPUSH
75356: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
75360: LD_VAR 0 2
75364: PPUSH
75365: LD_INT 9
75367: PPUSH
75368: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
75372: LD_INT 28
75374: PPUSH
75375: LD_OWVAR 2
75379: PPUSH
75380: LD_INT 2
75382: PPUSH
75383: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
75387: LD_INT 29
75389: PPUSH
75390: LD_OWVAR 2
75394: PPUSH
75395: LD_INT 2
75397: PPUSH
75398: CALL_OW 322
// end ;
75402: PPOPN 3
75404: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
75405: LD_EXP 98
75409: PUSH
75410: LD_EXP 141
75414: AND
75415: IFFALSE 75526
75417: GO 75419
75419: DISABLE
75420: LD_INT 0
75422: PPUSH
75423: PPUSH
75424: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
75425: LD_ADDR_VAR 0 3
75429: PUSH
75430: LD_INT 22
75432: PUSH
75433: LD_OWVAR 2
75437: PUSH
75438: EMPTY
75439: LIST
75440: LIST
75441: PUSH
75442: LD_INT 25
75444: PUSH
75445: LD_INT 1
75447: PUSH
75448: EMPTY
75449: LIST
75450: LIST
75451: PUSH
75452: EMPTY
75453: LIST
75454: LIST
75455: PPUSH
75456: CALL_OW 69
75460: ST_TO_ADDR
// if not tmp then
75461: LD_VAR 0 3
75465: NOT
75466: IFFALSE 75470
// exit ;
75468: GO 75526
// un := tmp [ rand ( 1 , tmp ) ] ;
75470: LD_ADDR_VAR 0 2
75474: PUSH
75475: LD_VAR 0 3
75479: PUSH
75480: LD_INT 1
75482: PPUSH
75483: LD_VAR 0 3
75487: PPUSH
75488: CALL_OW 12
75492: ARRAY
75493: ST_TO_ADDR
// if Crawls ( un ) then
75494: LD_VAR 0 2
75498: PPUSH
75499: CALL_OW 318
75503: IFFALSE 75514
// ComWalk ( un ) ;
75505: LD_VAR 0 2
75509: PPUSH
75510: CALL_OW 138
// SetClass ( un , class_mortar ) ;
75514: LD_VAR 0 2
75518: PPUSH
75519: LD_INT 8
75521: PPUSH
75522: CALL_OW 336
// end ;
75526: PPOPN 3
75528: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
75529: LD_EXP 98
75533: PUSH
75534: LD_EXP 142
75538: AND
75539: IFFALSE 75683
75541: GO 75543
75543: DISABLE
75544: LD_INT 0
75546: PPUSH
75547: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
75548: LD_ADDR_VAR 0 2
75552: PUSH
75553: LD_INT 22
75555: PUSH
75556: LD_OWVAR 2
75560: PUSH
75561: EMPTY
75562: LIST
75563: LIST
75564: PUSH
75565: LD_INT 21
75567: PUSH
75568: LD_INT 2
75570: PUSH
75571: EMPTY
75572: LIST
75573: LIST
75574: PUSH
75575: LD_INT 2
75577: PUSH
75578: LD_INT 34
75580: PUSH
75581: LD_INT 12
75583: PUSH
75584: EMPTY
75585: LIST
75586: LIST
75587: PUSH
75588: LD_INT 34
75590: PUSH
75591: LD_INT 51
75593: PUSH
75594: EMPTY
75595: LIST
75596: LIST
75597: PUSH
75598: LD_INT 34
75600: PUSH
75601: LD_INT 32
75603: PUSH
75604: EMPTY
75605: LIST
75606: LIST
75607: PUSH
75608: EMPTY
75609: LIST
75610: LIST
75611: LIST
75612: LIST
75613: PUSH
75614: EMPTY
75615: LIST
75616: LIST
75617: LIST
75618: PPUSH
75619: CALL_OW 69
75623: ST_TO_ADDR
// if not tmp then
75624: LD_VAR 0 2
75628: NOT
75629: IFFALSE 75633
// exit ;
75631: GO 75683
// for i in tmp do
75633: LD_ADDR_VAR 0 1
75637: PUSH
75638: LD_VAR 0 2
75642: PUSH
75643: FOR_IN
75644: IFFALSE 75681
// if GetCargo ( i , mat_artifact ) = 0 then
75646: LD_VAR 0 1
75650: PPUSH
75651: LD_INT 4
75653: PPUSH
75654: CALL_OW 289
75658: PUSH
75659: LD_INT 0
75661: EQUAL
75662: IFFALSE 75679
// SetCargo ( i , mat_siberit , 100 ) ;
75664: LD_VAR 0 1
75668: PPUSH
75669: LD_INT 3
75671: PPUSH
75672: LD_INT 100
75674: PPUSH
75675: CALL_OW 290
75679: GO 75643
75681: POP
75682: POP
// end ;
75683: PPOPN 2
75685: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
75686: LD_EXP 98
75690: PUSH
75691: LD_EXP 143
75695: AND
75696: IFFALSE 75879
75698: GO 75700
75700: DISABLE
75701: LD_INT 0
75703: PPUSH
75704: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
75705: LD_ADDR_VAR 0 2
75709: PUSH
75710: LD_INT 22
75712: PUSH
75713: LD_OWVAR 2
75717: PUSH
75718: EMPTY
75719: LIST
75720: LIST
75721: PPUSH
75722: CALL_OW 69
75726: ST_TO_ADDR
// if not tmp then
75727: LD_VAR 0 2
75731: NOT
75732: IFFALSE 75736
// exit ;
75734: GO 75879
// for i := 1 to 2 do
75736: LD_ADDR_VAR 0 1
75740: PUSH
75741: DOUBLE
75742: LD_INT 1
75744: DEC
75745: ST_TO_ADDR
75746: LD_INT 2
75748: PUSH
75749: FOR_TO
75750: IFFALSE 75877
// begin uc_side := your_side ;
75752: LD_ADDR_OWVAR 20
75756: PUSH
75757: LD_OWVAR 2
75761: ST_TO_ADDR
// uc_nation := nation_american ;
75762: LD_ADDR_OWVAR 21
75766: PUSH
75767: LD_INT 1
75769: ST_TO_ADDR
// vc_chassis := us_morphling ;
75770: LD_ADDR_OWVAR 37
75774: PUSH
75775: LD_INT 5
75777: ST_TO_ADDR
// vc_engine := engine_siberite ;
75778: LD_ADDR_OWVAR 39
75782: PUSH
75783: LD_INT 3
75785: ST_TO_ADDR
// vc_control := control_computer ;
75786: LD_ADDR_OWVAR 38
75790: PUSH
75791: LD_INT 3
75793: ST_TO_ADDR
// vc_weapon := us_double_laser ;
75794: LD_ADDR_OWVAR 40
75798: PUSH
75799: LD_INT 10
75801: ST_TO_ADDR
// if not IsInUnit ( tmp [ 1 ] ) then
75802: LD_VAR 0 2
75806: PUSH
75807: LD_INT 1
75809: ARRAY
75810: PPUSH
75811: CALL_OW 310
75815: NOT
75816: IFFALSE 75863
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) else
75818: CALL_OW 45
75822: PPUSH
75823: LD_VAR 0 2
75827: PUSH
75828: LD_INT 1
75830: ARRAY
75831: PPUSH
75832: CALL_OW 250
75836: PPUSH
75837: LD_VAR 0 2
75841: PUSH
75842: LD_INT 1
75844: ARRAY
75845: PPUSH
75846: CALL_OW 251
75850: PPUSH
75851: LD_INT 12
75853: PPUSH
75854: LD_INT 1
75856: PPUSH
75857: CALL_OW 50
75861: GO 75875
// PlaceUnitAnywhere ( CreateVehicle , true ) ;
75863: CALL_OW 45
75867: PPUSH
75868: LD_INT 1
75870: PPUSH
75871: CALL_OW 51
// end ;
75875: GO 75749
75877: POP
75878: POP
// end ;
75879: PPOPN 2
75881: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
75882: LD_EXP 98
75886: PUSH
75887: LD_EXP 144
75891: AND
75892: IFFALSE 76114
75894: GO 75896
75896: DISABLE
75897: LD_INT 0
75899: PPUSH
75900: PPUSH
75901: PPUSH
75902: PPUSH
75903: PPUSH
75904: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
75905: LD_ADDR_VAR 0 6
75909: PUSH
75910: LD_INT 22
75912: PUSH
75913: LD_OWVAR 2
75917: PUSH
75918: EMPTY
75919: LIST
75920: LIST
75921: PUSH
75922: LD_INT 21
75924: PUSH
75925: LD_INT 1
75927: PUSH
75928: EMPTY
75929: LIST
75930: LIST
75931: PUSH
75932: LD_INT 3
75934: PUSH
75935: LD_INT 23
75937: PUSH
75938: LD_INT 0
75940: PUSH
75941: EMPTY
75942: LIST
75943: LIST
75944: PUSH
75945: EMPTY
75946: LIST
75947: LIST
75948: PUSH
75949: EMPTY
75950: LIST
75951: LIST
75952: LIST
75953: PPUSH
75954: CALL_OW 69
75958: ST_TO_ADDR
// if not tmp then
75959: LD_VAR 0 6
75963: NOT
75964: IFFALSE 75968
// exit ;
75966: GO 76114
// s1 := rand ( 1 , 4 ) ;
75968: LD_ADDR_VAR 0 2
75972: PUSH
75973: LD_INT 1
75975: PPUSH
75976: LD_INT 4
75978: PPUSH
75979: CALL_OW 12
75983: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
75984: LD_ADDR_VAR 0 4
75988: PUSH
75989: LD_VAR 0 6
75993: PUSH
75994: LD_INT 1
75996: ARRAY
75997: PPUSH
75998: LD_VAR 0 2
76002: PPUSH
76003: CALL_OW 259
76007: ST_TO_ADDR
// if s1 = 1 then
76008: LD_VAR 0 2
76012: PUSH
76013: LD_INT 1
76015: EQUAL
76016: IFFALSE 76036
// s2 := rand ( 2 , 4 ) else
76018: LD_ADDR_VAR 0 3
76022: PUSH
76023: LD_INT 2
76025: PPUSH
76026: LD_INT 4
76028: PPUSH
76029: CALL_OW 12
76033: ST_TO_ADDR
76034: GO 76044
// s2 := 1 ;
76036: LD_ADDR_VAR 0 3
76040: PUSH
76041: LD_INT 1
76043: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
76044: LD_ADDR_VAR 0 5
76048: PUSH
76049: LD_VAR 0 6
76053: PUSH
76054: LD_INT 1
76056: ARRAY
76057: PPUSH
76058: LD_VAR 0 3
76062: PPUSH
76063: CALL_OW 259
76067: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
76068: LD_VAR 0 6
76072: PUSH
76073: LD_INT 1
76075: ARRAY
76076: PPUSH
76077: LD_VAR 0 2
76081: PPUSH
76082: LD_VAR 0 5
76086: PPUSH
76087: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
76091: LD_VAR 0 6
76095: PUSH
76096: LD_INT 1
76098: ARRAY
76099: PPUSH
76100: LD_VAR 0 3
76104: PPUSH
76105: LD_VAR 0 4
76109: PPUSH
76110: CALL_OW 237
// end ;
76114: PPOPN 6
76116: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
76117: LD_EXP 98
76121: PUSH
76122: LD_EXP 145
76126: AND
76127: IFFALSE 76206
76129: GO 76131
76131: DISABLE
76132: LD_INT 0
76134: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
76135: LD_ADDR_VAR 0 1
76139: PUSH
76140: LD_INT 22
76142: PUSH
76143: LD_OWVAR 2
76147: PUSH
76148: EMPTY
76149: LIST
76150: LIST
76151: PUSH
76152: LD_INT 30
76154: PUSH
76155: LD_INT 3
76157: PUSH
76158: EMPTY
76159: LIST
76160: LIST
76161: PUSH
76162: EMPTY
76163: LIST
76164: LIST
76165: PPUSH
76166: CALL_OW 69
76170: ST_TO_ADDR
// if not tmp then
76171: LD_VAR 0 1
76175: NOT
76176: IFFALSE 76180
// exit ;
76178: GO 76206
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
76180: LD_VAR 0 1
76184: PUSH
76185: LD_INT 1
76187: PPUSH
76188: LD_VAR 0 1
76192: PPUSH
76193: CALL_OW 12
76197: ARRAY
76198: PPUSH
76199: LD_INT 1
76201: PPUSH
76202: CALL_OW 234
// end ;
76206: PPOPN 1
76208: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
76209: LD_EXP 98
76213: PUSH
76214: LD_EXP 146
76218: AND
76219: IFFALSE 76331
76221: GO 76223
76223: DISABLE
76224: LD_INT 0
76226: PPUSH
76227: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
76228: LD_ADDR_VAR 0 2
76232: PUSH
76233: LD_INT 22
76235: PUSH
76236: LD_OWVAR 2
76240: PUSH
76241: EMPTY
76242: LIST
76243: LIST
76244: PUSH
76245: LD_INT 2
76247: PUSH
76248: LD_INT 30
76250: PUSH
76251: LD_INT 27
76253: PUSH
76254: EMPTY
76255: LIST
76256: LIST
76257: PUSH
76258: LD_INT 30
76260: PUSH
76261: LD_INT 26
76263: PUSH
76264: EMPTY
76265: LIST
76266: LIST
76267: PUSH
76268: LD_INT 30
76270: PUSH
76271: LD_INT 28
76273: PUSH
76274: EMPTY
76275: LIST
76276: LIST
76277: PUSH
76278: EMPTY
76279: LIST
76280: LIST
76281: LIST
76282: LIST
76283: PUSH
76284: EMPTY
76285: LIST
76286: LIST
76287: PPUSH
76288: CALL_OW 69
76292: ST_TO_ADDR
// if not tmp then
76293: LD_VAR 0 2
76297: NOT
76298: IFFALSE 76302
// exit ;
76300: GO 76331
// for i in tmp do
76302: LD_ADDR_VAR 0 1
76306: PUSH
76307: LD_VAR 0 2
76311: PUSH
76312: FOR_IN
76313: IFFALSE 76329
// SetLives ( i , 1 ) ;
76315: LD_VAR 0 1
76319: PPUSH
76320: LD_INT 1
76322: PPUSH
76323: CALL_OW 234
76327: GO 76312
76329: POP
76330: POP
// end ;
76331: PPOPN 2
76333: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
76334: LD_EXP 98
76338: PUSH
76339: LD_EXP 147
76343: AND
76344: IFFALSE 76631
76346: GO 76348
76348: DISABLE
76349: LD_INT 0
76351: PPUSH
76352: PPUSH
76353: PPUSH
// begin i := rand ( 1 , 7 ) ;
76354: LD_ADDR_VAR 0 1
76358: PUSH
76359: LD_INT 1
76361: PPUSH
76362: LD_INT 7
76364: PPUSH
76365: CALL_OW 12
76369: ST_TO_ADDR
// case i of 1 :
76370: LD_VAR 0 1
76374: PUSH
76375: LD_INT 1
76377: DOUBLE
76378: EQUAL
76379: IFTRUE 76383
76381: GO 76393
76383: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
76384: LD_STRING earthquake(getX(game), 0, 32)
76386: PPUSH
76387: CALL_OW 559
76391: GO 76631
76393: LD_INT 2
76395: DOUBLE
76396: EQUAL
76397: IFTRUE 76401
76399: GO 76415
76401: POP
// begin ToLua ( displayStucuk(); ) ;
76402: LD_STRING displayStucuk();
76404: PPUSH
76405: CALL_OW 559
// ResetFog ;
76409: CALL_OW 335
// end ; 3 :
76413: GO 76631
76415: LD_INT 3
76417: DOUBLE
76418: EQUAL
76419: IFTRUE 76423
76421: GO 76527
76423: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
76424: LD_ADDR_VAR 0 2
76428: PUSH
76429: LD_INT 22
76431: PUSH
76432: LD_OWVAR 2
76436: PUSH
76437: EMPTY
76438: LIST
76439: LIST
76440: PUSH
76441: LD_INT 25
76443: PUSH
76444: LD_INT 1
76446: PUSH
76447: EMPTY
76448: LIST
76449: LIST
76450: PUSH
76451: EMPTY
76452: LIST
76453: LIST
76454: PPUSH
76455: CALL_OW 69
76459: ST_TO_ADDR
// if not tmp then
76460: LD_VAR 0 2
76464: NOT
76465: IFFALSE 76469
// exit ;
76467: GO 76631
// un := tmp [ rand ( 1 , tmp ) ] ;
76469: LD_ADDR_VAR 0 3
76473: PUSH
76474: LD_VAR 0 2
76478: PUSH
76479: LD_INT 1
76481: PPUSH
76482: LD_VAR 0 2
76486: PPUSH
76487: CALL_OW 12
76491: ARRAY
76492: ST_TO_ADDR
// if Crawls ( un ) then
76493: LD_VAR 0 3
76497: PPUSH
76498: CALL_OW 318
76502: IFFALSE 76513
// ComWalk ( un ) ;
76504: LD_VAR 0 3
76508: PPUSH
76509: CALL_OW 138
// SetClass ( un , class_mortar ) ;
76513: LD_VAR 0 3
76517: PPUSH
76518: LD_INT 8
76520: PPUSH
76521: CALL_OW 336
// end ; 4 :
76525: GO 76631
76527: LD_INT 4
76529: DOUBLE
76530: EQUAL
76531: IFTRUE 76535
76533: GO 76609
76535: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
76536: LD_ADDR_VAR 0 2
76540: PUSH
76541: LD_INT 22
76543: PUSH
76544: LD_OWVAR 2
76548: PUSH
76549: EMPTY
76550: LIST
76551: LIST
76552: PUSH
76553: LD_INT 30
76555: PUSH
76556: LD_INT 29
76558: PUSH
76559: EMPTY
76560: LIST
76561: LIST
76562: PUSH
76563: EMPTY
76564: LIST
76565: LIST
76566: PPUSH
76567: CALL_OW 69
76571: ST_TO_ADDR
// if not tmp then
76572: LD_VAR 0 2
76576: NOT
76577: IFFALSE 76581
// exit ;
76579: GO 76631
// CenterNowOnUnits ( tmp [ 1 ] ) ;
76581: LD_VAR 0 2
76585: PUSH
76586: LD_INT 1
76588: ARRAY
76589: PPUSH
76590: CALL_OW 87
// DestroyUnit ( tmp [ 1 ] ) ;
76594: LD_VAR 0 2
76598: PUSH
76599: LD_INT 1
76601: ARRAY
76602: PPUSH
76603: CALL_OW 65
// end ; 5 .. 7 :
76607: GO 76631
76609: LD_INT 5
76611: DOUBLE
76612: GREATEREQUAL
76613: IFFALSE 76621
76615: LD_INT 7
76617: DOUBLE
76618: LESSEQUAL
76619: IFTRUE 76623
76621: GO 76630
76623: POP
// StreamSibBomb ; end ;
76624: CALL 72868 0 0
76628: GO 76631
76630: POP
// end ;
76631: PPOPN 3
76633: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
76634: LD_EXP 98
76638: PUSH
76639: LD_EXP 148
76643: AND
76644: IFFALSE 76800
76646: GO 76648
76648: DISABLE
76649: LD_INT 0
76651: PPUSH
76652: PPUSH
76653: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
76654: LD_ADDR_VAR 0 2
76658: PUSH
76659: LD_INT 81
76661: PUSH
76662: LD_OWVAR 2
76666: PUSH
76667: EMPTY
76668: LIST
76669: LIST
76670: PUSH
76671: LD_INT 2
76673: PUSH
76674: LD_INT 21
76676: PUSH
76677: LD_INT 1
76679: PUSH
76680: EMPTY
76681: LIST
76682: LIST
76683: PUSH
76684: LD_INT 21
76686: PUSH
76687: LD_INT 2
76689: PUSH
76690: EMPTY
76691: LIST
76692: LIST
76693: PUSH
76694: EMPTY
76695: LIST
76696: LIST
76697: LIST
76698: PUSH
76699: EMPTY
76700: LIST
76701: LIST
76702: PPUSH
76703: CALL_OW 69
76707: ST_TO_ADDR
// if not tmp then
76708: LD_VAR 0 2
76712: NOT
76713: IFFALSE 76717
// exit ;
76715: GO 76800
// p := 0 ;
76717: LD_ADDR_VAR 0 3
76721: PUSH
76722: LD_INT 0
76724: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
76725: LD_INT 35
76727: PPUSH
76728: CALL_OW 67
// p := p + 1 ;
76732: LD_ADDR_VAR 0 3
76736: PUSH
76737: LD_VAR 0 3
76741: PUSH
76742: LD_INT 1
76744: PLUS
76745: ST_TO_ADDR
// for i in tmp do
76746: LD_ADDR_VAR 0 1
76750: PUSH
76751: LD_VAR 0 2
76755: PUSH
76756: FOR_IN
76757: IFFALSE 76788
// if GetLives ( i ) < 1000 then
76759: LD_VAR 0 1
76763: PPUSH
76764: CALL_OW 256
76768: PUSH
76769: LD_INT 1000
76771: LESS
76772: IFFALSE 76786
// SetLives ( i , 1000 ) ;
76774: LD_VAR 0 1
76778: PPUSH
76779: LD_INT 1000
76781: PPUSH
76782: CALL_OW 234
76786: GO 76756
76788: POP
76789: POP
// until p > 20 ;
76790: LD_VAR 0 3
76794: PUSH
76795: LD_INT 20
76797: GREATER
76798: IFFALSE 76725
// end ;
76800: PPOPN 3
76802: END
// every 0 0$1 trigger StreamModeActive and sTime do
76803: LD_EXP 98
76807: PUSH
76808: LD_EXP 149
76812: AND
76813: IFFALSE 76848
76815: GO 76817
76817: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
76818: LD_INT 28
76820: PPUSH
76821: LD_OWVAR 2
76825: PPUSH
76826: LD_INT 2
76828: PPUSH
76829: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
76833: LD_INT 30
76835: PPUSH
76836: LD_OWVAR 2
76840: PPUSH
76841: LD_INT 2
76843: PPUSH
76844: CALL_OW 322
// end ;
76848: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
76849: LD_EXP 98
76853: PUSH
76854: LD_EXP 150
76858: AND
76859: IFFALSE 76980
76861: GO 76863
76863: DISABLE
76864: LD_INT 0
76866: PPUSH
76867: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
76868: LD_ADDR_VAR 0 2
76872: PUSH
76873: LD_INT 22
76875: PUSH
76876: LD_OWVAR 2
76880: PUSH
76881: EMPTY
76882: LIST
76883: LIST
76884: PUSH
76885: LD_INT 21
76887: PUSH
76888: LD_INT 1
76890: PUSH
76891: EMPTY
76892: LIST
76893: LIST
76894: PUSH
76895: LD_INT 3
76897: PUSH
76898: LD_INT 23
76900: PUSH
76901: LD_INT 0
76903: PUSH
76904: EMPTY
76905: LIST
76906: LIST
76907: PUSH
76908: EMPTY
76909: LIST
76910: LIST
76911: PUSH
76912: EMPTY
76913: LIST
76914: LIST
76915: LIST
76916: PPUSH
76917: CALL_OW 69
76921: ST_TO_ADDR
// if not tmp then
76922: LD_VAR 0 2
76926: NOT
76927: IFFALSE 76931
// exit ;
76929: GO 76980
// for i in tmp do
76931: LD_ADDR_VAR 0 1
76935: PUSH
76936: LD_VAR 0 2
76940: PUSH
76941: FOR_IN
76942: IFFALSE 76978
// begin if Crawls ( i ) then
76944: LD_VAR 0 1
76948: PPUSH
76949: CALL_OW 318
76953: IFFALSE 76964
// ComWalk ( i ) ;
76955: LD_VAR 0 1
76959: PPUSH
76960: CALL_OW 138
// SetClass ( i , 2 ) ;
76964: LD_VAR 0 1
76968: PPUSH
76969: LD_INT 2
76971: PPUSH
76972: CALL_OW 336
// end ;
76976: GO 76941
76978: POP
76979: POP
// end ;
76980: PPOPN 2
76982: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
76983: LD_EXP 98
76987: PUSH
76988: LD_EXP 151
76992: AND
76993: IFFALSE 77281
76995: GO 76997
76997: DISABLE
76998: LD_INT 0
77000: PPUSH
77001: PPUSH
77002: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
77003: LD_OWVAR 2
77007: PPUSH
77008: LD_INT 9
77010: PPUSH
77011: LD_INT 1
77013: PPUSH
77014: LD_INT 1
77016: PPUSH
77017: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
77021: LD_INT 9
77023: PPUSH
77024: LD_OWVAR 2
77028: PPUSH
77029: CALL_OW 343
// uc_side := 9 ;
77033: LD_ADDR_OWVAR 20
77037: PUSH
77038: LD_INT 9
77040: ST_TO_ADDR
// uc_nation := 2 ;
77041: LD_ADDR_OWVAR 21
77045: PUSH
77046: LD_INT 2
77048: ST_TO_ADDR
// hc_name := Dark Warrior ;
77049: LD_ADDR_OWVAR 26
77053: PUSH
77054: LD_STRING Dark Warrior
77056: ST_TO_ADDR
// hc_gallery :=  ;
77057: LD_ADDR_OWVAR 33
77061: PUSH
77062: LD_STRING 
77064: ST_TO_ADDR
// hc_noskilllimit := true ;
77065: LD_ADDR_OWVAR 76
77069: PUSH
77070: LD_INT 1
77072: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
77073: LD_ADDR_OWVAR 31
77077: PUSH
77078: LD_INT 30
77080: PUSH
77081: LD_INT 30
77083: PUSH
77084: LD_INT 30
77086: PUSH
77087: LD_INT 30
77089: PUSH
77090: EMPTY
77091: LIST
77092: LIST
77093: LIST
77094: LIST
77095: ST_TO_ADDR
// un := CreateHuman ;
77096: LD_ADDR_VAR 0 3
77100: PUSH
77101: CALL_OW 44
77105: ST_TO_ADDR
// hc_noskilllimit := false ;
77106: LD_ADDR_OWVAR 76
77110: PUSH
77111: LD_INT 0
77113: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
77114: LD_VAR 0 3
77118: PPUSH
77119: LD_INT 1
77121: PPUSH
77122: CALL_OW 51
// ToLua ( playRanger() ) ;
77126: LD_STRING playRanger()
77128: PPUSH
77129: CALL_OW 559
// p := 0 ;
77133: LD_ADDR_VAR 0 2
77137: PUSH
77138: LD_INT 0
77140: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
77141: LD_INT 35
77143: PPUSH
77144: CALL_OW 67
// p := p + 1 ;
77148: LD_ADDR_VAR 0 2
77152: PUSH
77153: LD_VAR 0 2
77157: PUSH
77158: LD_INT 1
77160: PLUS
77161: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
77162: LD_VAR 0 3
77166: PPUSH
77167: CALL_OW 256
77171: PUSH
77172: LD_INT 1000
77174: LESS
77175: IFFALSE 77189
// SetLives ( un , 1000 ) ;
77177: LD_VAR 0 3
77181: PPUSH
77182: LD_INT 1000
77184: PPUSH
77185: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
77189: LD_VAR 0 3
77193: PPUSH
77194: LD_INT 81
77196: PUSH
77197: LD_OWVAR 2
77201: PUSH
77202: EMPTY
77203: LIST
77204: LIST
77205: PUSH
77206: LD_INT 91
77208: PUSH
77209: LD_VAR 0 3
77213: PUSH
77214: LD_INT 30
77216: PUSH
77217: EMPTY
77218: LIST
77219: LIST
77220: LIST
77221: PUSH
77222: EMPTY
77223: LIST
77224: LIST
77225: PPUSH
77226: CALL_OW 69
77230: PPUSH
77231: LD_VAR 0 3
77235: PPUSH
77236: CALL_OW 74
77240: PPUSH
77241: CALL_OW 115
// until p > 80 or IsDead ( un ) ;
77245: LD_VAR 0 2
77249: PUSH
77250: LD_INT 80
77252: GREATER
77253: PUSH
77254: LD_VAR 0 3
77258: PPUSH
77259: CALL_OW 301
77263: OR
77264: IFFALSE 77141
// if un then
77266: LD_VAR 0 3
77270: IFFALSE 77281
// RemoveUnit ( un ) ;
77272: LD_VAR 0 3
77276: PPUSH
77277: CALL_OW 64
// end ;
77281: PPOPN 3
77283: END
// every 0 0$1 trigger sComputer do var i , tmp , j ;
77284: LD_EXP 152
77288: IFFALSE 77404
77290: GO 77292
77292: DISABLE
77293: LD_INT 0
77295: PPUSH
77296: PPUSH
77297: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
77298: LD_ADDR_VAR 0 2
77302: PUSH
77303: LD_INT 81
77305: PUSH
77306: LD_OWVAR 2
77310: PUSH
77311: EMPTY
77312: LIST
77313: LIST
77314: PUSH
77315: LD_INT 21
77317: PUSH
77318: LD_INT 1
77320: PUSH
77321: EMPTY
77322: LIST
77323: LIST
77324: PUSH
77325: EMPTY
77326: LIST
77327: LIST
77328: PPUSH
77329: CALL_OW 69
77333: ST_TO_ADDR
// ToLua ( playComputer() ) ;
77334: LD_STRING playComputer()
77336: PPUSH
77337: CALL_OW 559
// if not tmp then
77341: LD_VAR 0 2
77345: NOT
77346: IFFALSE 77350
// exit ;
77348: GO 77404
// for i in tmp do
77350: LD_ADDR_VAR 0 1
77354: PUSH
77355: LD_VAR 0 2
77359: PUSH
77360: FOR_IN
77361: IFFALSE 77402
// for j := 1 to 4 do
77363: LD_ADDR_VAR 0 3
77367: PUSH
77368: DOUBLE
77369: LD_INT 1
77371: DEC
77372: ST_TO_ADDR
77373: LD_INT 4
77375: PUSH
77376: FOR_TO
77377: IFFALSE 77398
// SetSkill ( i , j , 10 ) ;
77379: LD_VAR 0 1
77383: PPUSH
77384: LD_VAR 0 3
77388: PPUSH
77389: LD_INT 10
77391: PPUSH
77392: CALL_OW 237
77396: GO 77376
77398: POP
77399: POP
77400: GO 77360
77402: POP
77403: POP
// end ;
77404: PPOPN 3
77406: END
// every 0 0$1 trigger s30 do var i , tmp ;
77407: LD_EXP 153
77411: IFFALSE 77480
77413: GO 77415
77415: DISABLE
77416: LD_INT 0
77418: PPUSH
77419: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
77420: LD_ADDR_VAR 0 2
77424: PUSH
77425: LD_INT 22
77427: PUSH
77428: LD_OWVAR 2
77432: PUSH
77433: EMPTY
77434: LIST
77435: LIST
77436: PPUSH
77437: CALL_OW 69
77441: ST_TO_ADDR
// if not tmp then
77442: LD_VAR 0 2
77446: NOT
77447: IFFALSE 77451
// exit ;
77449: GO 77480
// for i in tmp do
77451: LD_ADDR_VAR 0 1
77455: PUSH
77456: LD_VAR 0 2
77460: PUSH
77461: FOR_IN
77462: IFFALSE 77478
// SetLives ( i , 300 ) ;
77464: LD_VAR 0 1
77468: PPUSH
77469: LD_INT 300
77471: PPUSH
77472: CALL_OW 234
77476: GO 77461
77478: POP
77479: POP
// end ;
77480: PPOPN 2
77482: END
// every 0 0$1 trigger s60 do var i , tmp ;
77483: LD_EXP 154
77487: IFFALSE 77556
77489: GO 77491
77491: DISABLE
77492: LD_INT 0
77494: PPUSH
77495: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
77496: LD_ADDR_VAR 0 2
77500: PUSH
77501: LD_INT 22
77503: PUSH
77504: LD_OWVAR 2
77508: PUSH
77509: EMPTY
77510: LIST
77511: LIST
77512: PPUSH
77513: CALL_OW 69
77517: ST_TO_ADDR
// if not tmp then
77518: LD_VAR 0 2
77522: NOT
77523: IFFALSE 77527
// exit ;
77525: GO 77556
// for i in tmp do
77527: LD_ADDR_VAR 0 1
77531: PUSH
77532: LD_VAR 0 2
77536: PUSH
77537: FOR_IN
77538: IFFALSE 77554
// SetLives ( i , 600 ) ;
77540: LD_VAR 0 1
77544: PPUSH
77545: LD_INT 600
77547: PPUSH
77548: CALL_OW 234
77552: GO 77537
77554: POP
77555: POP
// end ;
77556: PPOPN 2
77558: END
// export function SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
77559: LD_INT 0
77561: PPUSH
// case cmd of 301 :
77562: LD_VAR 0 1
77566: PUSH
77567: LD_INT 301
77569: DOUBLE
77570: EQUAL
77571: IFTRUE 77575
77573: GO 77607
77575: POP
// hHackSpawnHuman ( p1 , p2 , p3 , x , y ) ; 302 :
77576: LD_VAR 0 6
77580: PPUSH
77581: LD_VAR 0 7
77585: PPUSH
77586: LD_VAR 0 8
77590: PPUSH
77591: LD_VAR 0 4
77595: PPUSH
77596: LD_VAR 0 5
77600: PPUSH
77601: CALL 78816 0 5
77605: GO 77728
77607: LD_INT 302
77609: DOUBLE
77610: EQUAL
77611: IFTRUE 77615
77613: GO 77652
77615: POP
// hHackSpawnVehicle ( p1 , p2 , p3 , p4 , x , y ) ; 303 :
77616: LD_VAR 0 6
77620: PPUSH
77621: LD_VAR 0 7
77625: PPUSH
77626: LD_VAR 0 8
77630: PPUSH
77631: LD_VAR 0 9
77635: PPUSH
77636: LD_VAR 0 4
77640: PPUSH
77641: LD_VAR 0 5
77645: PPUSH
77646: CALL 78907 0 6
77650: GO 77728
77652: LD_INT 303
77654: DOUBLE
77655: EQUAL
77656: IFTRUE 77660
77658: GO 77697
77660: POP
// hHackSpawnBuilding ( p1 , p2 , p3 , p4 , x , y ) ; 304 :
77661: LD_VAR 0 6
77665: PPUSH
77666: LD_VAR 0 7
77670: PPUSH
77671: LD_VAR 0 8
77675: PPUSH
77676: LD_VAR 0 9
77680: PPUSH
77681: LD_VAR 0 4
77685: PPUSH
77686: LD_VAR 0 5
77690: PPUSH
77691: CALL 77733 0 6
77695: GO 77728
77697: LD_INT 304
77699: DOUBLE
77700: EQUAL
77701: IFTRUE 77705
77703: GO 77727
77705: POP
// hHackTeleport ( unit , x , y ) ; end ;
77706: LD_VAR 0 2
77710: PPUSH
77711: LD_VAR 0 4
77715: PPUSH
77716: LD_VAR 0 5
77720: PPUSH
77721: CALL 79500 0 3
77725: GO 77728
77727: POP
// end ;
77728: LD_VAR 0 12
77732: RET
// export function hHackSpawnBuilding ( nation , btype , dir , weapon , x , y ) ; var b ; begin
77733: LD_INT 0
77735: PPUSH
77736: PPUSH
// if nation < 1 or nation > 3 or HexInfo ( x , y ) then
77737: LD_VAR 0 1
77741: PUSH
77742: LD_INT 1
77744: LESS
77745: PUSH
77746: LD_VAR 0 1
77750: PUSH
77751: LD_INT 3
77753: GREATER
77754: OR
77755: PUSH
77756: LD_VAR 0 5
77760: PPUSH
77761: LD_VAR 0 6
77765: PPUSH
77766: CALL_OW 428
77770: OR
77771: IFFALSE 77775
// exit ;
77773: GO 78503
// uc_side := your_side ;
77775: LD_ADDR_OWVAR 20
77779: PUSH
77780: LD_OWVAR 2
77784: ST_TO_ADDR
// uc_nation := nation ;
77785: LD_ADDR_OWVAR 21
77789: PUSH
77790: LD_VAR 0 1
77794: ST_TO_ADDR
// bc_level = 1 ;
77795: LD_ADDR_OWVAR 43
77799: PUSH
77800: LD_INT 1
77802: ST_TO_ADDR
// case btype of 1 :
77803: LD_VAR 0 2
77807: PUSH
77808: LD_INT 1
77810: DOUBLE
77811: EQUAL
77812: IFTRUE 77816
77814: GO 77827
77816: POP
// bc_type := b_depot ; 2 :
77817: LD_ADDR_OWVAR 42
77821: PUSH
77822: LD_INT 0
77824: ST_TO_ADDR
77825: GO 78447
77827: LD_INT 2
77829: DOUBLE
77830: EQUAL
77831: IFTRUE 77835
77833: GO 77846
77835: POP
// bc_type := b_warehouse ; 3 :
77836: LD_ADDR_OWVAR 42
77840: PUSH
77841: LD_INT 1
77843: ST_TO_ADDR
77844: GO 78447
77846: LD_INT 3
77848: DOUBLE
77849: EQUAL
77850: IFTRUE 77854
77852: GO 77865
77854: POP
// bc_type := b_lab ; 4 .. 9 :
77855: LD_ADDR_OWVAR 42
77859: PUSH
77860: LD_INT 6
77862: ST_TO_ADDR
77863: GO 78447
77865: LD_INT 4
77867: DOUBLE
77868: GREATEREQUAL
77869: IFFALSE 77877
77871: LD_INT 9
77873: DOUBLE
77874: LESSEQUAL
77875: IFTRUE 77879
77877: GO 77939
77879: POP
// begin bc_type := b_lab_half ;
77880: LD_ADDR_OWVAR 42
77884: PUSH
77885: LD_INT 7
77887: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_opto , b_lab_spacetime , b_lab_biological ] [ btype - 3 ] ;
77888: LD_ADDR_OWVAR 44
77892: PUSH
77893: LD_INT 10
77895: PUSH
77896: LD_INT 11
77898: PUSH
77899: LD_INT 12
77901: PUSH
77902: LD_INT 15
77904: PUSH
77905: LD_INT 14
77907: PUSH
77908: LD_INT 13
77910: PUSH
77911: EMPTY
77912: LIST
77913: LIST
77914: LIST
77915: LIST
77916: LIST
77917: LIST
77918: PUSH
77919: LD_VAR 0 2
77923: PUSH
77924: LD_INT 3
77926: MINUS
77927: ARRAY
77928: ST_TO_ADDR
// bc_kind2 := b_lab_basic ;
77929: LD_ADDR_OWVAR 45
77933: PUSH
77934: LD_INT 9
77936: ST_TO_ADDR
// end ; 10 .. 13 :
77937: GO 78447
77939: LD_INT 10
77941: DOUBLE
77942: GREATEREQUAL
77943: IFFALSE 77951
77945: LD_INT 13
77947: DOUBLE
77948: LESSEQUAL
77949: IFTRUE 77953
77951: GO 78030
77953: POP
// begin bc_type := b_lab_full ;
77954: LD_ADDR_OWVAR 42
77958: PUSH
77959: LD_INT 8
77961: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_computer , b_lab_spacetime , b_lab_biological ] [ btype - 9 ] ;
77962: LD_ADDR_OWVAR 44
77966: PUSH
77967: LD_INT 10
77969: PUSH
77970: LD_INT 12
77972: PUSH
77973: LD_INT 14
77975: PUSH
77976: LD_INT 13
77978: PUSH
77979: EMPTY
77980: LIST
77981: LIST
77982: LIST
77983: LIST
77984: PUSH
77985: LD_VAR 0 2
77989: PUSH
77990: LD_INT 9
77992: MINUS
77993: ARRAY
77994: ST_TO_ADDR
// bc_kind2 := [ b_lab_siberium , b_lab_opto , b_lab_computer , b_lab_opto ] [ btype - 9 ] ;
77995: LD_ADDR_OWVAR 45
77999: PUSH
78000: LD_INT 11
78002: PUSH
78003: LD_INT 15
78005: PUSH
78006: LD_INT 12
78008: PUSH
78009: LD_INT 15
78011: PUSH
78012: EMPTY
78013: LIST
78014: LIST
78015: LIST
78016: LIST
78017: PUSH
78018: LD_VAR 0 2
78022: PUSH
78023: LD_INT 9
78025: MINUS
78026: ARRAY
78027: ST_TO_ADDR
// end ; 14 :
78028: GO 78447
78030: LD_INT 14
78032: DOUBLE
78033: EQUAL
78034: IFTRUE 78038
78036: GO 78049
78038: POP
// bc_type := b_workshop ; 15 :
78039: LD_ADDR_OWVAR 42
78043: PUSH
78044: LD_INT 2
78046: ST_TO_ADDR
78047: GO 78447
78049: LD_INT 15
78051: DOUBLE
78052: EQUAL
78053: IFTRUE 78057
78055: GO 78068
78057: POP
// bc_type := b_factory ; 16 :
78058: LD_ADDR_OWVAR 42
78062: PUSH
78063: LD_INT 3
78065: ST_TO_ADDR
78066: GO 78447
78068: LD_INT 16
78070: DOUBLE
78071: EQUAL
78072: IFTRUE 78076
78074: GO 78087
78076: POP
// bc_type := b_ext_gun ; 17 :
78077: LD_ADDR_OWVAR 42
78081: PUSH
78082: LD_INT 17
78084: ST_TO_ADDR
78085: GO 78447
78087: LD_INT 17
78089: DOUBLE
78090: EQUAL
78091: IFTRUE 78095
78093: GO 78123
78095: POP
// bc_type := [ b_ext_noncombat , b_ext_stitch , b_ext_noncombat ] [ nation ] ; 18 :
78096: LD_ADDR_OWVAR 42
78100: PUSH
78101: LD_INT 19
78103: PUSH
78104: LD_INT 23
78106: PUSH
78107: LD_INT 19
78109: PUSH
78110: EMPTY
78111: LIST
78112: LIST
78113: LIST
78114: PUSH
78115: LD_VAR 0 1
78119: ARRAY
78120: ST_TO_ADDR
78121: GO 78447
78123: LD_INT 18
78125: DOUBLE
78126: EQUAL
78127: IFTRUE 78131
78129: GO 78142
78131: POP
// bc_type := b_ext_radar ; 19 :
78132: LD_ADDR_OWVAR 42
78136: PUSH
78137: LD_INT 20
78139: ST_TO_ADDR
78140: GO 78447
78142: LD_INT 19
78144: DOUBLE
78145: EQUAL
78146: IFTRUE 78150
78148: GO 78161
78150: POP
// bc_type := b_ext_radio ; 20 :
78151: LD_ADDR_OWVAR 42
78155: PUSH
78156: LD_INT 22
78158: ST_TO_ADDR
78159: GO 78447
78161: LD_INT 20
78163: DOUBLE
78164: EQUAL
78165: IFTRUE 78169
78167: GO 78180
78169: POP
// bc_type := b_ext_siberium ; 21 :
78170: LD_ADDR_OWVAR 42
78174: PUSH
78175: LD_INT 21
78177: ST_TO_ADDR
78178: GO 78447
78180: LD_INT 21
78182: DOUBLE
78183: EQUAL
78184: IFTRUE 78188
78186: GO 78199
78188: POP
// bc_type := b_ext_computer ; 22 :
78189: LD_ADDR_OWVAR 42
78193: PUSH
78194: LD_INT 24
78196: ST_TO_ADDR
78197: GO 78447
78199: LD_INT 22
78201: DOUBLE
78202: EQUAL
78203: IFTRUE 78207
78205: GO 78218
78207: POP
// bc_type := b_ext_track ; 23 :
78208: LD_ADDR_OWVAR 42
78212: PUSH
78213: LD_INT 16
78215: ST_TO_ADDR
78216: GO 78447
78218: LD_INT 23
78220: DOUBLE
78221: EQUAL
78222: IFTRUE 78226
78224: GO 78237
78226: POP
// bc_type := b_ext_laser ; 24 :
78227: LD_ADDR_OWVAR 42
78231: PUSH
78232: LD_INT 25
78234: ST_TO_ADDR
78235: GO 78447
78237: LD_INT 24
78239: DOUBLE
78240: EQUAL
78241: IFTRUE 78245
78243: GO 78256
78245: POP
// bc_type := b_control_tower ; 25 :
78246: LD_ADDR_OWVAR 42
78250: PUSH
78251: LD_INT 36
78253: ST_TO_ADDR
78254: GO 78447
78256: LD_INT 25
78258: DOUBLE
78259: EQUAL
78260: IFTRUE 78264
78262: GO 78275
78264: POP
// bc_type := b_breastwork ; 26 :
78265: LD_ADDR_OWVAR 42
78269: PUSH
78270: LD_INT 31
78272: ST_TO_ADDR
78273: GO 78447
78275: LD_INT 26
78277: DOUBLE
78278: EQUAL
78279: IFTRUE 78283
78281: GO 78294
78283: POP
// bc_type := b_bunker ; 27 :
78284: LD_ADDR_OWVAR 42
78288: PUSH
78289: LD_INT 32
78291: ST_TO_ADDR
78292: GO 78447
78294: LD_INT 27
78296: DOUBLE
78297: EQUAL
78298: IFTRUE 78302
78300: GO 78313
78302: POP
// bc_type := b_turret ; 28 :
78303: LD_ADDR_OWVAR 42
78307: PUSH
78308: LD_INT 33
78310: ST_TO_ADDR
78311: GO 78447
78313: LD_INT 28
78315: DOUBLE
78316: EQUAL
78317: IFTRUE 78321
78319: GO 78332
78321: POP
// bc_type := b_armoury ; 29 :
78322: LD_ADDR_OWVAR 42
78326: PUSH
78327: LD_INT 4
78329: ST_TO_ADDR
78330: GO 78447
78332: LD_INT 29
78334: DOUBLE
78335: EQUAL
78336: IFTRUE 78340
78338: GO 78351
78340: POP
// bc_type := b_barracks ; 30 :
78341: LD_ADDR_OWVAR 42
78345: PUSH
78346: LD_INT 5
78348: ST_TO_ADDR
78349: GO 78447
78351: LD_INT 30
78353: DOUBLE
78354: EQUAL
78355: IFTRUE 78359
78357: GO 78370
78359: POP
// bc_type := b_solar_power ; 31 :
78360: LD_ADDR_OWVAR 42
78364: PUSH
78365: LD_INT 27
78367: ST_TO_ADDR
78368: GO 78447
78370: LD_INT 31
78372: DOUBLE
78373: EQUAL
78374: IFTRUE 78378
78376: GO 78389
78378: POP
// bc_type := b_oil_power ; 32 :
78379: LD_ADDR_OWVAR 42
78383: PUSH
78384: LD_INT 26
78386: ST_TO_ADDR
78387: GO 78447
78389: LD_INT 32
78391: DOUBLE
78392: EQUAL
78393: IFTRUE 78397
78395: GO 78408
78397: POP
// bc_type := b_siberite_power ; 33 :
78398: LD_ADDR_OWVAR 42
78402: PUSH
78403: LD_INT 28
78405: ST_TO_ADDR
78406: GO 78447
78408: LD_INT 33
78410: DOUBLE
78411: EQUAL
78412: IFTRUE 78416
78414: GO 78427
78416: POP
// bc_type := b_oil_mine ; 34 :
78417: LD_ADDR_OWVAR 42
78421: PUSH
78422: LD_INT 29
78424: ST_TO_ADDR
78425: GO 78447
78427: LD_INT 34
78429: DOUBLE
78430: EQUAL
78431: IFTRUE 78435
78433: GO 78446
78435: POP
// bc_type := b_siberite_mine ; end ;
78436: LD_ADDR_OWVAR 42
78440: PUSH
78441: LD_INT 30
78443: ST_TO_ADDR
78444: GO 78447
78446: POP
// b := CreateAndPlaceBuildingXYD ( x , y , dir ) ;
78447: LD_ADDR_VAR 0 8
78451: PUSH
78452: LD_VAR 0 5
78456: PPUSH
78457: LD_VAR 0 6
78461: PPUSH
78462: LD_VAR 0 3
78466: PPUSH
78467: CALL_OW 47
78471: ST_TO_ADDR
// if bc_type in [ b_bunker , b_turret ] then
78472: LD_OWVAR 42
78476: PUSH
78477: LD_INT 32
78479: PUSH
78480: LD_INT 33
78482: PUSH
78483: EMPTY
78484: LIST
78485: LIST
78486: IN
78487: IFFALSE 78503
// PlaceWeaponTurret ( b , weapon ) ;
78489: LD_VAR 0 8
78493: PPUSH
78494: LD_VAR 0 4
78498: PPUSH
78499: CALL_OW 431
// end ;
78503: LD_VAR 0 7
78507: RET
// export function hHackUnlimitedResources ; var i , j , tmp ; begin
78508: LD_INT 0
78510: PPUSH
78511: PPUSH
78512: PPUSH
78513: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
78514: LD_ADDR_VAR 0 4
78518: PUSH
78519: LD_INT 22
78521: PUSH
78522: LD_OWVAR 2
78526: PUSH
78527: EMPTY
78528: LIST
78529: LIST
78530: PUSH
78531: LD_INT 2
78533: PUSH
78534: LD_INT 30
78536: PUSH
78537: LD_INT 0
78539: PUSH
78540: EMPTY
78541: LIST
78542: LIST
78543: PUSH
78544: LD_INT 30
78546: PUSH
78547: LD_INT 1
78549: PUSH
78550: EMPTY
78551: LIST
78552: LIST
78553: PUSH
78554: EMPTY
78555: LIST
78556: LIST
78557: LIST
78558: PUSH
78559: EMPTY
78560: LIST
78561: LIST
78562: PPUSH
78563: CALL_OW 69
78567: ST_TO_ADDR
// if not tmp then
78568: LD_VAR 0 4
78572: NOT
78573: IFFALSE 78577
// exit ;
78575: GO 78636
// for i in tmp do
78577: LD_ADDR_VAR 0 2
78581: PUSH
78582: LD_VAR 0 4
78586: PUSH
78587: FOR_IN
78588: IFFALSE 78634
// for j = 1 to 3 do
78590: LD_ADDR_VAR 0 3
78594: PUSH
78595: DOUBLE
78596: LD_INT 1
78598: DEC
78599: ST_TO_ADDR
78600: LD_INT 3
78602: PUSH
78603: FOR_TO
78604: IFFALSE 78630
// SetResourceType ( GetBase ( i ) , j , 99999 ) ;
78606: LD_VAR 0 2
78610: PPUSH
78611: CALL_OW 274
78615: PPUSH
78616: LD_VAR 0 3
78620: PPUSH
78621: LD_INT 99999
78623: PPUSH
78624: CALL_OW 277
78628: GO 78603
78630: POP
78631: POP
78632: GO 78587
78634: POP
78635: POP
// end ;
78636: LD_VAR 0 1
78640: RET
// export function hHackSetLevel10 ; var i , j ; begin
78641: LD_INT 0
78643: PPUSH
78644: PPUSH
78645: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
78646: LD_ADDR_VAR 0 2
78650: PUSH
78651: LD_INT 21
78653: PUSH
78654: LD_INT 1
78656: PUSH
78657: EMPTY
78658: LIST
78659: LIST
78660: PPUSH
78661: CALL_OW 69
78665: PUSH
78666: FOR_IN
78667: IFFALSE 78719
// if IsSelected ( i ) then
78669: LD_VAR 0 2
78673: PPUSH
78674: CALL_OW 306
78678: IFFALSE 78717
// begin for j := 1 to 4 do
78680: LD_ADDR_VAR 0 3
78684: PUSH
78685: DOUBLE
78686: LD_INT 1
78688: DEC
78689: ST_TO_ADDR
78690: LD_INT 4
78692: PUSH
78693: FOR_TO
78694: IFFALSE 78715
// SetSkill ( i , j , 10 ) ;
78696: LD_VAR 0 2
78700: PPUSH
78701: LD_VAR 0 3
78705: PPUSH
78706: LD_INT 10
78708: PPUSH
78709: CALL_OW 237
78713: GO 78693
78715: POP
78716: POP
// end ;
78717: GO 78666
78719: POP
78720: POP
// end ;
78721: LD_VAR 0 1
78725: RET
// export function hHackSetLevel10YourUnits ; var i , j ; begin
78726: LD_INT 0
78728: PPUSH
78729: PPUSH
78730: PPUSH
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) do
78731: LD_ADDR_VAR 0 2
78735: PUSH
78736: LD_INT 22
78738: PUSH
78739: LD_OWVAR 2
78743: PUSH
78744: EMPTY
78745: LIST
78746: LIST
78747: PUSH
78748: LD_INT 21
78750: PUSH
78751: LD_INT 1
78753: PUSH
78754: EMPTY
78755: LIST
78756: LIST
78757: PUSH
78758: EMPTY
78759: LIST
78760: LIST
78761: PPUSH
78762: CALL_OW 69
78766: PUSH
78767: FOR_IN
78768: IFFALSE 78809
// begin for j := 1 to 4 do
78770: LD_ADDR_VAR 0 3
78774: PUSH
78775: DOUBLE
78776: LD_INT 1
78778: DEC
78779: ST_TO_ADDR
78780: LD_INT 4
78782: PUSH
78783: FOR_TO
78784: IFFALSE 78805
// SetSkill ( i , j , 10 ) ;
78786: LD_VAR 0 2
78790: PPUSH
78791: LD_VAR 0 3
78795: PPUSH
78796: LD_INT 10
78798: PPUSH
78799: CALL_OW 237
78803: GO 78783
78805: POP
78806: POP
// end ;
78807: GO 78767
78809: POP
78810: POP
// end ;
78811: LD_VAR 0 1
78815: RET
// export function hHackSpawnHuman ( nation , class , skill , x , y ) ; begin
78816: LD_INT 0
78818: PPUSH
// uc_side := your_side ;
78819: LD_ADDR_OWVAR 20
78823: PUSH
78824: LD_OWVAR 2
78828: ST_TO_ADDR
// uc_nation := nation ;
78829: LD_ADDR_OWVAR 21
78833: PUSH
78834: LD_VAR 0 1
78838: ST_TO_ADDR
// InitHc ;
78839: CALL_OW 19
// PrepareHuman ( false , class , skill ) ;
78843: LD_INT 0
78845: PPUSH
78846: LD_VAR 0 2
78850: PPUSH
78851: LD_VAR 0 3
78855: PPUSH
78856: CALL_OW 380
// if HexInfo ( x , y ) = 0 then
78860: LD_VAR 0 4
78864: PPUSH
78865: LD_VAR 0 5
78869: PPUSH
78870: CALL_OW 428
78874: PUSH
78875: LD_INT 0
78877: EQUAL
78878: IFFALSE 78902
// PlaceUnitXY ( CreateHuman , x , y , true ) ;
78880: CALL_OW 44
78884: PPUSH
78885: LD_VAR 0 4
78889: PPUSH
78890: LD_VAR 0 5
78894: PPUSH
78895: LD_INT 1
78897: PPUSH
78898: CALL_OW 48
// end ;
78902: LD_VAR 0 6
78906: RET
// export function hHackSpawnVehicle ( chassis , engine , control , weapon , x , y ) ; var un ; begin
78907: LD_INT 0
78909: PPUSH
78910: PPUSH
// uc_side := your_side ;
78911: LD_ADDR_OWVAR 20
78915: PUSH
78916: LD_OWVAR 2
78920: ST_TO_ADDR
// if chassis in [ 1 , 2 , 3 , 4 , 5 ] then
78921: LD_VAR 0 1
78925: PUSH
78926: LD_INT 1
78928: PUSH
78929: LD_INT 2
78931: PUSH
78932: LD_INT 3
78934: PUSH
78935: LD_INT 4
78937: PUSH
78938: LD_INT 5
78940: PUSH
78941: EMPTY
78942: LIST
78943: LIST
78944: LIST
78945: LIST
78946: LIST
78947: IN
78948: IFFALSE 78960
// uc_nation := nation_american else
78950: LD_ADDR_OWVAR 21
78954: PUSH
78955: LD_INT 1
78957: ST_TO_ADDR
78958: GO 79003
// if chassis in [ 11 , 12 , 13 , 14 ] then
78960: LD_VAR 0 1
78964: PUSH
78965: LD_INT 11
78967: PUSH
78968: LD_INT 12
78970: PUSH
78971: LD_INT 13
78973: PUSH
78974: LD_INT 14
78976: PUSH
78977: EMPTY
78978: LIST
78979: LIST
78980: LIST
78981: LIST
78982: IN
78983: IFFALSE 78995
// uc_nation := nation_arabian else
78985: LD_ADDR_OWVAR 21
78989: PUSH
78990: LD_INT 2
78992: ST_TO_ADDR
78993: GO 79003
// uc_nation := nation_russian ;
78995: LD_ADDR_OWVAR 21
78999: PUSH
79000: LD_INT 3
79002: ST_TO_ADDR
// vc_chassis := chassis ;
79003: LD_ADDR_OWVAR 37
79007: PUSH
79008: LD_VAR 0 1
79012: ST_TO_ADDR
// vc_engine := engine ;
79013: LD_ADDR_OWVAR 39
79017: PUSH
79018: LD_VAR 0 2
79022: ST_TO_ADDR
// vc_control := control ;
79023: LD_ADDR_OWVAR 38
79027: PUSH
79028: LD_VAR 0 3
79032: ST_TO_ADDR
// vc_weapon := weapon ;
79033: LD_ADDR_OWVAR 40
79037: PUSH
79038: LD_VAR 0 4
79042: ST_TO_ADDR
// un := CreateVehicle ;
79043: LD_ADDR_VAR 0 8
79047: PUSH
79048: CALL_OW 45
79052: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
79053: LD_VAR 0 8
79057: PPUSH
79058: LD_INT 0
79060: PPUSH
79061: LD_INT 5
79063: PPUSH
79064: CALL_OW 12
79068: PPUSH
79069: CALL_OW 233
// PlaceUnitXY ( un , x , y , true ) ;
79073: LD_VAR 0 8
79077: PPUSH
79078: LD_VAR 0 5
79082: PPUSH
79083: LD_VAR 0 6
79087: PPUSH
79088: LD_INT 1
79090: PPUSH
79091: CALL_OW 48
// end ;
79095: LD_VAR 0 7
79099: RET
// export hInvincible ; every 1 do
79100: GO 79102
79102: DISABLE
// hInvincible := [ ] ;
79103: LD_ADDR_EXP 155
79107: PUSH
79108: EMPTY
79109: ST_TO_ADDR
79110: END
// every 10 do var i ;
79111: GO 79113
79113: DISABLE
79114: LD_INT 0
79116: PPUSH
// begin enable ;
79117: ENABLE
// if not hInvincible then
79118: LD_EXP 155
79122: NOT
79123: IFFALSE 79127
// exit ;
79125: GO 79171
// for i in hInvincible do
79127: LD_ADDR_VAR 0 1
79131: PUSH
79132: LD_EXP 155
79136: PUSH
79137: FOR_IN
79138: IFFALSE 79169
// if GetLives ( i ) < 1000 then
79140: LD_VAR 0 1
79144: PPUSH
79145: CALL_OW 256
79149: PUSH
79150: LD_INT 1000
79152: LESS
79153: IFFALSE 79167
// SetLives ( i , 1000 ) ;
79155: LD_VAR 0 1
79159: PPUSH
79160: LD_INT 1000
79162: PPUSH
79163: CALL_OW 234
79167: GO 79137
79169: POP
79170: POP
// end ;
79171: PPOPN 1
79173: END
// export function hHackInvincible ; var i ; begin
79174: LD_INT 0
79176: PPUSH
79177: PPUSH
// for i in FilterAllUnits ( [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ) do
79178: LD_ADDR_VAR 0 2
79182: PUSH
79183: LD_INT 2
79185: PUSH
79186: LD_INT 21
79188: PUSH
79189: LD_INT 1
79191: PUSH
79192: EMPTY
79193: LIST
79194: LIST
79195: PUSH
79196: LD_INT 21
79198: PUSH
79199: LD_INT 2
79201: PUSH
79202: EMPTY
79203: LIST
79204: LIST
79205: PUSH
79206: EMPTY
79207: LIST
79208: LIST
79209: LIST
79210: PPUSH
79211: CALL_OW 69
79215: PUSH
79216: FOR_IN
79217: IFFALSE 79278
// if IsSelected ( i ) then
79219: LD_VAR 0 2
79223: PPUSH
79224: CALL_OW 306
79228: IFFALSE 79276
// begin if i in hInvincible then
79230: LD_VAR 0 2
79234: PUSH
79235: LD_EXP 155
79239: IN
79240: IFFALSE 79260
// hInvincible := hInvincible diff i else
79242: LD_ADDR_EXP 155
79246: PUSH
79247: LD_EXP 155
79251: PUSH
79252: LD_VAR 0 2
79256: DIFF
79257: ST_TO_ADDR
79258: GO 79276
// hInvincible := hInvincible union i ;
79260: LD_ADDR_EXP 155
79264: PUSH
79265: LD_EXP 155
79269: PUSH
79270: LD_VAR 0 2
79274: UNION
79275: ST_TO_ADDR
// end ;
79276: GO 79216
79278: POP
79279: POP
// end ;
79280: LD_VAR 0 1
79284: RET
// export function hHackInvisible ; var i , j ; begin
79285: LD_INT 0
79287: PPUSH
79288: PPUSH
79289: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
79290: LD_ADDR_VAR 0 2
79294: PUSH
79295: LD_INT 21
79297: PUSH
79298: LD_INT 1
79300: PUSH
79301: EMPTY
79302: LIST
79303: LIST
79304: PPUSH
79305: CALL_OW 69
79309: PUSH
79310: FOR_IN
79311: IFFALSE 79335
// if IsSelected ( i ) then
79313: LD_VAR 0 2
79317: PPUSH
79318: CALL_OW 306
79322: IFFALSE 79333
// ComForceInvisible ( i ) ;
79324: LD_VAR 0 2
79328: PPUSH
79329: CALL_OW 496
79333: GO 79310
79335: POP
79336: POP
// end ;
79337: LD_VAR 0 1
79341: RET
// export function hHackChangeYourSide ; begin
79342: LD_INT 0
79344: PPUSH
// if your_side = 8 then
79345: LD_OWVAR 2
79349: PUSH
79350: LD_INT 8
79352: EQUAL
79353: IFFALSE 79365
// your_side := 0 else
79355: LD_ADDR_OWVAR 2
79359: PUSH
79360: LD_INT 0
79362: ST_TO_ADDR
79363: GO 79379
// your_side := your_side + 1 ;
79365: LD_ADDR_OWVAR 2
79369: PUSH
79370: LD_OWVAR 2
79374: PUSH
79375: LD_INT 1
79377: PLUS
79378: ST_TO_ADDR
// end ;
79379: LD_VAR 0 1
79383: RET
// export function hHackChangeUnitSide ; var i , j ; begin
79384: LD_INT 0
79386: PPUSH
79387: PPUSH
79388: PPUSH
// for i in all_units do
79389: LD_ADDR_VAR 0 2
79393: PUSH
79394: LD_OWVAR 3
79398: PUSH
79399: FOR_IN
79400: IFFALSE 79478
// if IsSelected ( i ) then
79402: LD_VAR 0 2
79406: PPUSH
79407: CALL_OW 306
79411: IFFALSE 79476
// begin j := GetSide ( i ) ;
79413: LD_ADDR_VAR 0 3
79417: PUSH
79418: LD_VAR 0 2
79422: PPUSH
79423: CALL_OW 255
79427: ST_TO_ADDR
// if j = 8 then
79428: LD_VAR 0 3
79432: PUSH
79433: LD_INT 8
79435: EQUAL
79436: IFFALSE 79448
// j := 0 else
79438: LD_ADDR_VAR 0 3
79442: PUSH
79443: LD_INT 0
79445: ST_TO_ADDR
79446: GO 79462
// j := j + 1 ;
79448: LD_ADDR_VAR 0 3
79452: PUSH
79453: LD_VAR 0 3
79457: PUSH
79458: LD_INT 1
79460: PLUS
79461: ST_TO_ADDR
// SetSide ( i , j ) ;
79462: LD_VAR 0 2
79466: PPUSH
79467: LD_VAR 0 3
79471: PPUSH
79472: CALL_OW 235
// end ;
79476: GO 79399
79478: POP
79479: POP
// end ;
79480: LD_VAR 0 1
79484: RET
// export function hHackFog ; begin
79485: LD_INT 0
79487: PPUSH
// FogOff ( true ) ;
79488: LD_INT 1
79490: PPUSH
79491: CALL_OW 344
// end ;
79495: LD_VAR 0 1
79499: RET
// export function hHackTeleport ( unit , x , y ) ; begin
79500: LD_INT 0
79502: PPUSH
// TeleportUnit ( unit , x , y , 1 , true ) ;
79503: LD_VAR 0 1
79507: PPUSH
79508: LD_VAR 0 2
79512: PPUSH
79513: LD_VAR 0 3
79517: PPUSH
79518: LD_INT 1
79520: PPUSH
79521: LD_INT 1
79523: PPUSH
79524: CALL_OW 483
// CenterOnXY ( x , y ) ;
79528: LD_VAR 0 2
79532: PPUSH
79533: LD_VAR 0 3
79537: PPUSH
79538: CALL_OW 84
// end ;
79542: LD_VAR 0 4
79546: RET
// export factoryWaypoints ; export function SetFactoryWaypoint ( factory , x , y ) ; var i ; begin
79547: LD_INT 0
79549: PPUSH
79550: PPUSH
// if not factory or not ValidHex ( x , y ) or ( GetBType ( factory ) <> b_factory and not GetType ( factory ) = unit_human ) then
79551: LD_VAR 0 1
79555: NOT
79556: PUSH
79557: LD_VAR 0 2
79561: PPUSH
79562: LD_VAR 0 3
79566: PPUSH
79567: CALL_OW 488
79571: NOT
79572: OR
79573: PUSH
79574: LD_VAR 0 1
79578: PPUSH
79579: CALL_OW 266
79583: PUSH
79584: LD_INT 3
79586: NONEQUAL
79587: PUSH
79588: LD_VAR 0 1
79592: PPUSH
79593: CALL_OW 247
79597: PUSH
79598: LD_INT 1
79600: EQUAL
79601: NOT
79602: AND
79603: OR
79604: IFFALSE 79608
// exit ;
79606: GO 79757
// if GetType ( factory ) = unit_human then
79608: LD_VAR 0 1
79612: PPUSH
79613: CALL_OW 247
79617: PUSH
79618: LD_INT 1
79620: EQUAL
79621: IFFALSE 79638
// factory := IsInUnit ( factory ) ;
79623: LD_ADDR_VAR 0 1
79627: PUSH
79628: LD_VAR 0 1
79632: PPUSH
79633: CALL_OW 310
79637: ST_TO_ADDR
// if GetBType ( factory ) <> b_factory then
79638: LD_VAR 0 1
79642: PPUSH
79643: CALL_OW 266
79647: PUSH
79648: LD_INT 3
79650: NONEQUAL
79651: IFFALSE 79655
// exit ;
79653: GO 79757
// if HexInfo ( x , y ) = factory then
79655: LD_VAR 0 2
79659: PPUSH
79660: LD_VAR 0 3
79664: PPUSH
79665: CALL_OW 428
79669: PUSH
79670: LD_VAR 0 1
79674: EQUAL
79675: IFFALSE 79702
// factoryWaypoints := Replace ( factoryWaypoints , factory , 0 ) else
79677: LD_ADDR_EXP 156
79681: PUSH
79682: LD_EXP 156
79686: PPUSH
79687: LD_VAR 0 1
79691: PPUSH
79692: LD_INT 0
79694: PPUSH
79695: CALL_OW 1
79699: ST_TO_ADDR
79700: GO 79753
// factoryWaypoints := Replace ( factoryWaypoints , factory , [ GetSide ( factory ) , factory , x , y ] ) ;
79702: LD_ADDR_EXP 156
79706: PUSH
79707: LD_EXP 156
79711: PPUSH
79712: LD_VAR 0 1
79716: PPUSH
79717: LD_VAR 0 1
79721: PPUSH
79722: CALL_OW 255
79726: PUSH
79727: LD_VAR 0 1
79731: PUSH
79732: LD_VAR 0 2
79736: PUSH
79737: LD_VAR 0 3
79741: PUSH
79742: EMPTY
79743: LIST
79744: LIST
79745: LIST
79746: LIST
79747: PPUSH
79748: CALL_OW 1
79752: ST_TO_ADDR
// UpdateFactoryWaypoints ;
79753: CALL 79762 0 0
// end ;
79757: LD_VAR 0 4
79761: RET
// export function UpdateFactoryWaypoints ( ) ; var i , list ; begin
79762: LD_INT 0
79764: PPUSH
79765: PPUSH
79766: PPUSH
// ToLua ( resetFactoryWaypoint(); ) ;
79767: LD_STRING resetFactoryWaypoint();
79769: PPUSH
79770: CALL_OW 559
// if factoryWaypoints then
79774: LD_EXP 156
79778: IFFALSE 79904
// begin list := PrepareArray ( factoryWaypoints ) ;
79780: LD_ADDR_VAR 0 3
79784: PUSH
79785: LD_EXP 156
79789: PPUSH
79790: CALL 60303 0 1
79794: ST_TO_ADDR
// for i := 1 to list do
79795: LD_ADDR_VAR 0 2
79799: PUSH
79800: DOUBLE
79801: LD_INT 1
79803: DEC
79804: ST_TO_ADDR
79805: LD_VAR 0 3
79809: PUSH
79810: FOR_TO
79811: IFFALSE 79902
// ToLua ( setFactoryWaypointXY( & list [ i ] [ 1 ] & , & list [ i ] [ 2 ] & , & list [ i ] [ 3 ] & , & list [ i ] [ 4 ] & ) ) ;
79813: LD_STRING setFactoryWaypointXY(
79815: PUSH
79816: LD_VAR 0 3
79820: PUSH
79821: LD_VAR 0 2
79825: ARRAY
79826: PUSH
79827: LD_INT 1
79829: ARRAY
79830: STR
79831: PUSH
79832: LD_STRING ,
79834: STR
79835: PUSH
79836: LD_VAR 0 3
79840: PUSH
79841: LD_VAR 0 2
79845: ARRAY
79846: PUSH
79847: LD_INT 2
79849: ARRAY
79850: STR
79851: PUSH
79852: LD_STRING ,
79854: STR
79855: PUSH
79856: LD_VAR 0 3
79860: PUSH
79861: LD_VAR 0 2
79865: ARRAY
79866: PUSH
79867: LD_INT 3
79869: ARRAY
79870: STR
79871: PUSH
79872: LD_STRING ,
79874: STR
79875: PUSH
79876: LD_VAR 0 3
79880: PUSH
79881: LD_VAR 0 2
79885: ARRAY
79886: PUSH
79887: LD_INT 4
79889: ARRAY
79890: STR
79891: PUSH
79892: LD_STRING )
79894: STR
79895: PPUSH
79896: CALL_OW 559
79900: GO 79810
79902: POP
79903: POP
// end ; end ;
79904: LD_VAR 0 1
79908: RET
// export warehouseGatheringPoints , warehouseCratesCollectors ; export function SetWarehouseGatheringPoint ( warehouse , x , y ) ; begin
79909: LD_INT 0
79911: PPUSH
// if HexInfo ( x , y ) = warehouse then
79912: LD_VAR 0 2
79916: PPUSH
79917: LD_VAR 0 3
79921: PPUSH
79922: CALL_OW 428
79926: PUSH
79927: LD_VAR 0 1
79931: EQUAL
79932: IFFALSE 79959
// warehouseGatheringPoints := Replace ( warehouseGatheringPoints , warehouse , 0 ) else
79934: LD_ADDR_EXP 157
79938: PUSH
79939: LD_EXP 157
79943: PPUSH
79944: LD_VAR 0 1
79948: PPUSH
79949: LD_INT 0
79951: PPUSH
79952: CALL_OW 1
79956: ST_TO_ADDR
79957: GO 80010
// warehouseGatheringPoints := Replace ( warehouseGatheringPoints , warehouse , [ GetSide ( warehouse ) , warehouse , x , y ] ) ;
79959: LD_ADDR_EXP 157
79963: PUSH
79964: LD_EXP 157
79968: PPUSH
79969: LD_VAR 0 1
79973: PPUSH
79974: LD_VAR 0 1
79978: PPUSH
79979: CALL_OW 255
79983: PUSH
79984: LD_VAR 0 1
79988: PUSH
79989: LD_VAR 0 2
79993: PUSH
79994: LD_VAR 0 3
79998: PUSH
79999: EMPTY
80000: LIST
80001: LIST
80002: LIST
80003: LIST
80004: PPUSH
80005: CALL_OW 1
80009: ST_TO_ADDR
// UpdateWarehouseGatheringPoints ;
80010: CALL 80019 0 0
// end ;
80014: LD_VAR 0 4
80018: RET
// export function UpdateWarehouseGatheringPoints ( ) ; var i , list ; begin
80019: LD_INT 0
80021: PPUSH
80022: PPUSH
80023: PPUSH
// ToLua ( resetWarehouseGatheringPoints(); ) ;
80024: LD_STRING resetWarehouseGatheringPoints();
80026: PPUSH
80027: CALL_OW 559
// if warehouseGatheringPoints then
80031: LD_EXP 157
80035: IFFALSE 80161
// begin list := PrepareArray ( warehouseGatheringPoints ) ;
80037: LD_ADDR_VAR 0 3
80041: PUSH
80042: LD_EXP 157
80046: PPUSH
80047: CALL 60303 0 1
80051: ST_TO_ADDR
// for i := 1 to list do
80052: LD_ADDR_VAR 0 2
80056: PUSH
80057: DOUBLE
80058: LD_INT 1
80060: DEC
80061: ST_TO_ADDR
80062: LD_VAR 0 3
80066: PUSH
80067: FOR_TO
80068: IFFALSE 80159
// ToLua ( setWarehouseGatheringPointXY( & list [ i ] [ 1 ] & , & list [ i ] [ 2 ] & , & list [ i ] [ 3 ] & , & list [ i ] [ 4 ] & ) ) ;
80070: LD_STRING setWarehouseGatheringPointXY(
80072: PUSH
80073: LD_VAR 0 3
80077: PUSH
80078: LD_VAR 0 2
80082: ARRAY
80083: PUSH
80084: LD_INT 1
80086: ARRAY
80087: STR
80088: PUSH
80089: LD_STRING ,
80091: STR
80092: PUSH
80093: LD_VAR 0 3
80097: PUSH
80098: LD_VAR 0 2
80102: ARRAY
80103: PUSH
80104: LD_INT 2
80106: ARRAY
80107: STR
80108: PUSH
80109: LD_STRING ,
80111: STR
80112: PUSH
80113: LD_VAR 0 3
80117: PUSH
80118: LD_VAR 0 2
80122: ARRAY
80123: PUSH
80124: LD_INT 3
80126: ARRAY
80127: STR
80128: PUSH
80129: LD_STRING ,
80131: STR
80132: PUSH
80133: LD_VAR 0 3
80137: PUSH
80138: LD_VAR 0 2
80142: ARRAY
80143: PUSH
80144: LD_INT 4
80146: ARRAY
80147: STR
80148: PUSH
80149: LD_STRING )
80151: STR
80152: PPUSH
80153: CALL_OW 559
80157: GO 80067
80159: POP
80160: POP
// end ; end ;
80161: LD_VAR 0 1
80165: RET
// every 0 0$20 trigger warehouseGatheringPoints do var i , j , list , tmp , side , x , y , depot , cratesNearbyPoint ;
80166: LD_EXP 157
80170: IFFALSE 80855
80172: GO 80174
80174: DISABLE
80175: LD_INT 0
80177: PPUSH
80178: PPUSH
80179: PPUSH
80180: PPUSH
80181: PPUSH
80182: PPUSH
80183: PPUSH
80184: PPUSH
80185: PPUSH
// begin enable ;
80186: ENABLE
// list := PrepareArray ( warehouseGatheringPoints ) ;
80187: LD_ADDR_VAR 0 3
80191: PUSH
80192: LD_EXP 157
80196: PPUSH
80197: CALL 60303 0 1
80201: ST_TO_ADDR
// if not list then
80202: LD_VAR 0 3
80206: NOT
80207: IFFALSE 80211
// exit ;
80209: GO 80855
// for i := 1 to list do
80211: LD_ADDR_VAR 0 1
80215: PUSH
80216: DOUBLE
80217: LD_INT 1
80219: DEC
80220: ST_TO_ADDR
80221: LD_VAR 0 3
80225: PUSH
80226: FOR_TO
80227: IFFALSE 80853
// begin depot := list [ i ] [ 2 ] ;
80229: LD_ADDR_VAR 0 8
80233: PUSH
80234: LD_VAR 0 3
80238: PUSH
80239: LD_VAR 0 1
80243: ARRAY
80244: PUSH
80245: LD_INT 2
80247: ARRAY
80248: ST_TO_ADDR
// side := list [ i ] [ 1 ] ;
80249: LD_ADDR_VAR 0 5
80253: PUSH
80254: LD_VAR 0 3
80258: PUSH
80259: LD_VAR 0 1
80263: ARRAY
80264: PUSH
80265: LD_INT 1
80267: ARRAY
80268: ST_TO_ADDR
// if IsDead ( depot ) or side <> GetSide ( depot ) then
80269: LD_VAR 0 8
80273: PPUSH
80274: CALL_OW 301
80278: PUSH
80279: LD_VAR 0 5
80283: PUSH
80284: LD_VAR 0 8
80288: PPUSH
80289: CALL_OW 255
80293: NONEQUAL
80294: OR
80295: IFFALSE 80324
// begin warehouseGatheringPoints := Replace ( warehouseGatheringPoints , depot , 0 ) ;
80297: LD_ADDR_EXP 157
80301: PUSH
80302: LD_EXP 157
80306: PPUSH
80307: LD_VAR 0 8
80311: PPUSH
80312: LD_INT 0
80314: PPUSH
80315: CALL_OW 1
80319: ST_TO_ADDR
// exit ;
80320: POP
80321: POP
80322: GO 80855
// end ; x := list [ i ] [ 3 ] ;
80324: LD_ADDR_VAR 0 6
80328: PUSH
80329: LD_VAR 0 3
80333: PUSH
80334: LD_VAR 0 1
80338: ARRAY
80339: PUSH
80340: LD_INT 3
80342: ARRAY
80343: ST_TO_ADDR
// y := list [ i ] [ 4 ] ;
80344: LD_ADDR_VAR 0 7
80348: PUSH
80349: LD_VAR 0 3
80353: PUSH
80354: LD_VAR 0 1
80358: ARRAY
80359: PUSH
80360: LD_INT 4
80362: ARRAY
80363: ST_TO_ADDR
// cratesNearbyPoint := GetCratesNearbyXY ( x , y , 16 ) ;
80364: LD_ADDR_VAR 0 9
80368: PUSH
80369: LD_VAR 0 6
80373: PPUSH
80374: LD_VAR 0 7
80378: PPUSH
80379: LD_INT 16
80381: PPUSH
80382: CALL 58891 0 3
80386: ST_TO_ADDR
// if not cratesNearbyPoint then
80387: LD_VAR 0 9
80391: NOT
80392: IFFALSE 80398
// exit ;
80394: POP
80395: POP
80396: GO 80855
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_hastask ] ] , [ f_dist , depot , 6 ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] ] ] ) union UnitFilter ( UnitsInside ( depot ) , [ [ f_not , [ f_hastask ] ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] ] ] ) ;
80398: LD_ADDR_VAR 0 4
80402: PUSH
80403: LD_INT 22
80405: PUSH
80406: LD_VAR 0 5
80410: PUSH
80411: EMPTY
80412: LIST
80413: LIST
80414: PUSH
80415: LD_INT 3
80417: PUSH
80418: LD_INT 60
80420: PUSH
80421: EMPTY
80422: LIST
80423: PUSH
80424: EMPTY
80425: LIST
80426: LIST
80427: PUSH
80428: LD_INT 91
80430: PUSH
80431: LD_VAR 0 8
80435: PUSH
80436: LD_INT 6
80438: PUSH
80439: EMPTY
80440: LIST
80441: LIST
80442: LIST
80443: PUSH
80444: LD_INT 2
80446: PUSH
80447: LD_INT 25
80449: PUSH
80450: LD_INT 2
80452: PUSH
80453: EMPTY
80454: LIST
80455: LIST
80456: PUSH
80457: LD_INT 25
80459: PUSH
80460: LD_INT 16
80462: PUSH
80463: EMPTY
80464: LIST
80465: LIST
80466: PUSH
80467: EMPTY
80468: LIST
80469: LIST
80470: LIST
80471: PUSH
80472: EMPTY
80473: LIST
80474: LIST
80475: LIST
80476: LIST
80477: PPUSH
80478: CALL_OW 69
80482: PUSH
80483: LD_VAR 0 8
80487: PPUSH
80488: CALL_OW 313
80492: PPUSH
80493: LD_INT 3
80495: PUSH
80496: LD_INT 60
80498: PUSH
80499: EMPTY
80500: LIST
80501: PUSH
80502: EMPTY
80503: LIST
80504: LIST
80505: PUSH
80506: LD_INT 2
80508: PUSH
80509: LD_INT 25
80511: PUSH
80512: LD_INT 2
80514: PUSH
80515: EMPTY
80516: LIST
80517: LIST
80518: PUSH
80519: LD_INT 25
80521: PUSH
80522: LD_INT 16
80524: PUSH
80525: EMPTY
80526: LIST
80527: LIST
80528: PUSH
80529: EMPTY
80530: LIST
80531: LIST
80532: LIST
80533: PUSH
80534: EMPTY
80535: LIST
80536: LIST
80537: PPUSH
80538: CALL_OW 72
80542: UNION
80543: ST_TO_ADDR
// if tmp then
80544: LD_VAR 0 4
80548: IFFALSE 80628
// begin tmp := ShrinkArray ( tmp , 3 ) ;
80550: LD_ADDR_VAR 0 4
80554: PUSH
80555: LD_VAR 0 4
80559: PPUSH
80560: LD_INT 3
80562: PPUSH
80563: CALL 56860 0 2
80567: ST_TO_ADDR
// for j in tmp do
80568: LD_ADDR_VAR 0 2
80572: PUSH
80573: LD_VAR 0 4
80577: PUSH
80578: FOR_IN
80579: IFFALSE 80622
// begin if IsInUnit ( j ) then
80581: LD_VAR 0 2
80585: PPUSH
80586: CALL_OW 310
80590: IFFALSE 80601
// ComExit ( j ) ;
80592: LD_VAR 0 2
80596: PPUSH
80597: CALL 56943 0 1
// AddComCollect ( j , x , y ) ;
80601: LD_VAR 0 2
80605: PPUSH
80606: LD_VAR 0 6
80610: PPUSH
80611: LD_VAR 0 7
80615: PPUSH
80616: CALL_OW 177
// end ;
80620: GO 80578
80622: POP
80623: POP
// exit ;
80624: POP
80625: POP
80626: GO 80855
// end ; tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_dist , depot , 8 ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ] ) ;
80628: LD_ADDR_VAR 0 4
80632: PUSH
80633: LD_INT 22
80635: PUSH
80636: LD_VAR 0 5
80640: PUSH
80641: EMPTY
80642: LIST
80643: LIST
80644: PUSH
80645: LD_INT 91
80647: PUSH
80648: LD_VAR 0 8
80652: PUSH
80653: LD_INT 8
80655: PUSH
80656: EMPTY
80657: LIST
80658: LIST
80659: LIST
80660: PUSH
80661: LD_INT 2
80663: PUSH
80664: LD_INT 34
80666: PUSH
80667: LD_INT 12
80669: PUSH
80670: EMPTY
80671: LIST
80672: LIST
80673: PUSH
80674: LD_INT 34
80676: PUSH
80677: LD_INT 51
80679: PUSH
80680: EMPTY
80681: LIST
80682: LIST
80683: PUSH
80684: LD_INT 34
80686: PUSH
80687: LD_INT 32
80689: PUSH
80690: EMPTY
80691: LIST
80692: LIST
80693: PUSH
80694: LD_INT 34
80696: PUSH
80697: LD_INT 89
80699: PUSH
80700: EMPTY
80701: LIST
80702: LIST
80703: PUSH
80704: EMPTY
80705: LIST
80706: LIST
80707: LIST
80708: LIST
80709: LIST
80710: PUSH
80711: EMPTY
80712: LIST
80713: LIST
80714: LIST
80715: PPUSH
80716: CALL_OW 69
80720: ST_TO_ADDR
// if tmp then
80721: LD_VAR 0 4
80725: IFFALSE 80851
// begin for j in tmp do
80727: LD_ADDR_VAR 0 2
80731: PUSH
80732: LD_VAR 0 4
80736: PUSH
80737: FOR_IN
80738: IFFALSE 80849
// if ( GetEngine ( j ) = engine_siberite or GetFuel ( j ) > 20 ) and not HasTask ( j ) and ( GetControl ( j ) <> control_manual or IsDrivenBy ( j ) ) then
80740: LD_VAR 0 2
80744: PPUSH
80745: CALL_OW 262
80749: PUSH
80750: LD_INT 3
80752: EQUAL
80753: PUSH
80754: LD_VAR 0 2
80758: PPUSH
80759: CALL_OW 261
80763: PUSH
80764: LD_INT 20
80766: GREATER
80767: OR
80768: PUSH
80769: LD_VAR 0 2
80773: PPUSH
80774: CALL_OW 314
80778: NOT
80779: AND
80780: PUSH
80781: LD_VAR 0 2
80785: PPUSH
80786: CALL_OW 263
80790: PUSH
80791: LD_INT 1
80793: NONEQUAL
80794: PUSH
80795: LD_VAR 0 2
80799: PPUSH
80800: CALL_OW 311
80804: OR
80805: AND
80806: IFFALSE 80847
// begin ComCollect ( j , x , y ) ;
80808: LD_VAR 0 2
80812: PPUSH
80813: LD_VAR 0 6
80817: PPUSH
80818: LD_VAR 0 7
80822: PPUSH
80823: CALL_OW 117
// AddComMoveUnit ( j , depot ) ;
80827: LD_VAR 0 2
80831: PPUSH
80832: LD_VAR 0 8
80836: PPUSH
80837: CALL_OW 172
// exit ;
80841: POP
80842: POP
80843: POP
80844: POP
80845: GO 80855
// end ;
80847: GO 80737
80849: POP
80850: POP
// end ; end ;
80851: GO 80226
80853: POP
80854: POP
// end ; end_of_file
80855: PPOPN 9
80857: END
// export ru_radar on TargetableSAIL ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) do begin case cmd of 200 .. 299 :
80858: LD_VAR 0 1
80862: PUSH
80863: LD_INT 200
80865: DOUBLE
80866: GREATEREQUAL
80867: IFFALSE 80875
80869: LD_INT 299
80871: DOUBLE
80872: LESSEQUAL
80873: IFTRUE 80877
80875: GO 80909
80877: POP
// SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; 300 .. 399 :
80878: LD_VAR 0 1
80882: PPUSH
80883: LD_VAR 0 2
80887: PPUSH
80888: LD_VAR 0 3
80892: PPUSH
80893: LD_VAR 0 4
80897: PPUSH
80898: LD_VAR 0 5
80902: PPUSH
80903: CALL 61143 0 5
80907: GO 80986
80909: LD_INT 300
80911: DOUBLE
80912: GREATEREQUAL
80913: IFFALSE 80921
80915: LD_INT 399
80917: DOUBLE
80918: LESSEQUAL
80919: IFTRUE 80923
80921: GO 80985
80923: POP
// SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; end ;
80924: LD_VAR 0 1
80928: PPUSH
80929: LD_VAR 0 2
80933: PPUSH
80934: LD_VAR 0 3
80938: PPUSH
80939: LD_VAR 0 4
80943: PPUSH
80944: LD_VAR 0 5
80948: PPUSH
80949: LD_VAR 0 6
80953: PPUSH
80954: LD_VAR 0 7
80958: PPUSH
80959: LD_VAR 0 8
80963: PPUSH
80964: LD_VAR 0 9
80968: PPUSH
80969: LD_VAR 0 10
80973: PPUSH
80974: LD_VAR 0 11
80978: PPUSH
80979: CALL 77559 0 11
80983: GO 80986
80985: POP
// end ;
80986: PPOPN 11
80988: END
// on CommandUnitXY ( cmd , un , target , x , y ) do begin SOS_CommandUnitXY ( cmd , un , target , x , y ) ;
80989: LD_VAR 0 1
80993: PPUSH
80994: LD_VAR 0 2
80998: PPUSH
80999: LD_VAR 0 3
81003: PPUSH
81004: LD_VAR 0 4
81008: PPUSH
81009: LD_VAR 0 5
81013: PPUSH
81014: CALL 60879 0 5
// end ; end_of_file
81018: PPOPN 5
81020: END
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
81021: LD_INT 0
81023: PPUSH
81024: PPUSH
81025: PPUSH
81026: PPUSH
81027: PPUSH
81028: PPUSH
81029: PPUSH
81030: PPUSH
81031: PPUSH
81032: PPUSH
81033: PPUSH
81034: PPUSH
81035: PPUSH
81036: PPUSH
81037: PPUSH
81038: PPUSH
81039: PPUSH
81040: PPUSH
81041: PPUSH
81042: PPUSH
81043: PPUSH
81044: PPUSH
81045: PPUSH
81046: PPUSH
81047: PPUSH
81048: PPUSH
81049: PPUSH
81050: PPUSH
81051: PPUSH
81052: PPUSH
81053: PPUSH
81054: PPUSH
81055: PPUSH
81056: PPUSH
// if not list then
81057: LD_VAR 0 1
81061: NOT
81062: IFFALSE 81066
// exit ;
81064: GO 85725
// base := list [ 1 ] ;
81066: LD_ADDR_VAR 0 3
81070: PUSH
81071: LD_VAR 0 1
81075: PUSH
81076: LD_INT 1
81078: ARRAY
81079: ST_TO_ADDR
// group := list [ 2 ] ;
81080: LD_ADDR_VAR 0 4
81084: PUSH
81085: LD_VAR 0 1
81089: PUSH
81090: LD_INT 2
81092: ARRAY
81093: ST_TO_ADDR
// path := list [ 3 ] ;
81094: LD_ADDR_VAR 0 5
81098: PUSH
81099: LD_VAR 0 1
81103: PUSH
81104: LD_INT 3
81106: ARRAY
81107: ST_TO_ADDR
// flags := list [ 4 ] ;
81108: LD_ADDR_VAR 0 6
81112: PUSH
81113: LD_VAR 0 1
81117: PUSH
81118: LD_INT 4
81120: ARRAY
81121: ST_TO_ADDR
// mined := [ ] ;
81122: LD_ADDR_VAR 0 27
81126: PUSH
81127: EMPTY
81128: ST_TO_ADDR
// bombed := [ ] ;
81129: LD_ADDR_VAR 0 28
81133: PUSH
81134: EMPTY
81135: ST_TO_ADDR
// healers := [ ] ;
81136: LD_ADDR_VAR 0 31
81140: PUSH
81141: EMPTY
81142: ST_TO_ADDR
// to_heal := [ ] ;
81143: LD_ADDR_VAR 0 30
81147: PUSH
81148: EMPTY
81149: ST_TO_ADDR
// repairs := [ ] ;
81150: LD_ADDR_VAR 0 33
81154: PUSH
81155: EMPTY
81156: ST_TO_ADDR
// to_repair := [ ] ;
81157: LD_ADDR_VAR 0 32
81161: PUSH
81162: EMPTY
81163: ST_TO_ADDR
// if not group or not path then
81164: LD_VAR 0 4
81168: NOT
81169: PUSH
81170: LD_VAR 0 5
81174: NOT
81175: OR
81176: IFFALSE 81180
// exit ;
81178: GO 85725
// side := GetSide ( group [ 1 ] ) ;
81180: LD_ADDR_VAR 0 35
81184: PUSH
81185: LD_VAR 0 4
81189: PUSH
81190: LD_INT 1
81192: ARRAY
81193: PPUSH
81194: CALL_OW 255
81198: ST_TO_ADDR
// if flags then
81199: LD_VAR 0 6
81203: IFFALSE 81347
// begin f_ignore_area := flags [ 1 ] ;
81205: LD_ADDR_VAR 0 17
81209: PUSH
81210: LD_VAR 0 6
81214: PUSH
81215: LD_INT 1
81217: ARRAY
81218: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
81219: LD_ADDR_VAR 0 18
81223: PUSH
81224: LD_VAR 0 6
81228: PUSH
81229: LD_INT 2
81231: ARRAY
81232: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
81233: LD_ADDR_VAR 0 19
81237: PUSH
81238: LD_VAR 0 6
81242: PUSH
81243: LD_INT 3
81245: ARRAY
81246: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
81247: LD_ADDR_VAR 0 20
81251: PUSH
81252: LD_VAR 0 6
81256: PUSH
81257: LD_INT 4
81259: ARRAY
81260: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
81261: LD_ADDR_VAR 0 21
81265: PUSH
81266: LD_VAR 0 6
81270: PUSH
81271: LD_INT 5
81273: ARRAY
81274: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
81275: LD_ADDR_VAR 0 22
81279: PUSH
81280: LD_VAR 0 6
81284: PUSH
81285: LD_INT 6
81287: ARRAY
81288: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
81289: LD_ADDR_VAR 0 23
81293: PUSH
81294: LD_VAR 0 6
81298: PUSH
81299: LD_INT 7
81301: ARRAY
81302: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
81303: LD_ADDR_VAR 0 24
81307: PUSH
81308: LD_VAR 0 6
81312: PUSH
81313: LD_INT 8
81315: ARRAY
81316: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
81317: LD_ADDR_VAR 0 25
81321: PUSH
81322: LD_VAR 0 6
81326: PUSH
81327: LD_INT 9
81329: ARRAY
81330: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
81331: LD_ADDR_VAR 0 26
81335: PUSH
81336: LD_VAR 0 6
81340: PUSH
81341: LD_INT 10
81343: ARRAY
81344: ST_TO_ADDR
// end else
81345: GO 81427
// begin f_ignore_area := false ;
81347: LD_ADDR_VAR 0 17
81351: PUSH
81352: LD_INT 0
81354: ST_TO_ADDR
// f_capture := false ;
81355: LD_ADDR_VAR 0 18
81359: PUSH
81360: LD_INT 0
81362: ST_TO_ADDR
// f_ignore_civ := false ;
81363: LD_ADDR_VAR 0 19
81367: PUSH
81368: LD_INT 0
81370: ST_TO_ADDR
// f_murder := false ;
81371: LD_ADDR_VAR 0 20
81375: PUSH
81376: LD_INT 0
81378: ST_TO_ADDR
// f_mines := false ;
81379: LD_ADDR_VAR 0 21
81383: PUSH
81384: LD_INT 0
81386: ST_TO_ADDR
// f_repair := false ;
81387: LD_ADDR_VAR 0 22
81391: PUSH
81392: LD_INT 0
81394: ST_TO_ADDR
// f_heal := false ;
81395: LD_ADDR_VAR 0 23
81399: PUSH
81400: LD_INT 0
81402: ST_TO_ADDR
// f_spacetime := false ;
81403: LD_ADDR_VAR 0 24
81407: PUSH
81408: LD_INT 0
81410: ST_TO_ADDR
// f_attack_depot := false ;
81411: LD_ADDR_VAR 0 25
81415: PUSH
81416: LD_INT 0
81418: ST_TO_ADDR
// f_crawl := false ;
81419: LD_ADDR_VAR 0 26
81423: PUSH
81424: LD_INT 0
81426: ST_TO_ADDR
// end ; if f_heal then
81427: LD_VAR 0 23
81431: IFFALSE 81458
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
81433: LD_ADDR_VAR 0 31
81437: PUSH
81438: LD_VAR 0 4
81442: PPUSH
81443: LD_INT 25
81445: PUSH
81446: LD_INT 4
81448: PUSH
81449: EMPTY
81450: LIST
81451: LIST
81452: PPUSH
81453: CALL_OW 72
81457: ST_TO_ADDR
// if f_repair then
81458: LD_VAR 0 22
81462: IFFALSE 81489
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
81464: LD_ADDR_VAR 0 33
81468: PUSH
81469: LD_VAR 0 4
81473: PPUSH
81474: LD_INT 25
81476: PUSH
81477: LD_INT 3
81479: PUSH
81480: EMPTY
81481: LIST
81482: LIST
81483: PPUSH
81484: CALL_OW 72
81488: ST_TO_ADDR
// units_path := [ ] ;
81489: LD_ADDR_VAR 0 16
81493: PUSH
81494: EMPTY
81495: ST_TO_ADDR
// for i = 1 to group do
81496: LD_ADDR_VAR 0 7
81500: PUSH
81501: DOUBLE
81502: LD_INT 1
81504: DEC
81505: ST_TO_ADDR
81506: LD_VAR 0 4
81510: PUSH
81511: FOR_TO
81512: IFFALSE 81541
// units_path := Replace ( units_path , i , path ) ;
81514: LD_ADDR_VAR 0 16
81518: PUSH
81519: LD_VAR 0 16
81523: PPUSH
81524: LD_VAR 0 7
81528: PPUSH
81529: LD_VAR 0 5
81533: PPUSH
81534: CALL_OW 1
81538: ST_TO_ADDR
81539: GO 81511
81541: POP
81542: POP
// repeat for i = group downto 1 do
81543: LD_ADDR_VAR 0 7
81547: PUSH
81548: DOUBLE
81549: LD_VAR 0 4
81553: INC
81554: ST_TO_ADDR
81555: LD_INT 1
81557: PUSH
81558: FOR_DOWNTO
81559: IFFALSE 85681
// begin wait ( 5 ) ;
81561: LD_INT 5
81563: PPUSH
81564: CALL_OW 67
// tmp := [ ] ;
81568: LD_ADDR_VAR 0 14
81572: PUSH
81573: EMPTY
81574: ST_TO_ADDR
// attacking := false ;
81575: LD_ADDR_VAR 0 29
81579: PUSH
81580: LD_INT 0
81582: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
81583: LD_VAR 0 4
81587: PUSH
81588: LD_VAR 0 7
81592: ARRAY
81593: PPUSH
81594: CALL_OW 301
81598: PUSH
81599: LD_VAR 0 4
81603: PUSH
81604: LD_VAR 0 7
81608: ARRAY
81609: NOT
81610: OR
81611: IFFALSE 81720
// begin if GetType ( group [ i ] ) = unit_human then
81613: LD_VAR 0 4
81617: PUSH
81618: LD_VAR 0 7
81622: ARRAY
81623: PPUSH
81624: CALL_OW 247
81628: PUSH
81629: LD_INT 1
81631: EQUAL
81632: IFFALSE 81678
// begin to_heal := to_heal diff group [ i ] ;
81634: LD_ADDR_VAR 0 30
81638: PUSH
81639: LD_VAR 0 30
81643: PUSH
81644: LD_VAR 0 4
81648: PUSH
81649: LD_VAR 0 7
81653: ARRAY
81654: DIFF
81655: ST_TO_ADDR
// healers := healers diff group [ i ] ;
81656: LD_ADDR_VAR 0 31
81660: PUSH
81661: LD_VAR 0 31
81665: PUSH
81666: LD_VAR 0 4
81670: PUSH
81671: LD_VAR 0 7
81675: ARRAY
81676: DIFF
81677: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
81678: LD_ADDR_VAR 0 4
81682: PUSH
81683: LD_VAR 0 4
81687: PPUSH
81688: LD_VAR 0 7
81692: PPUSH
81693: CALL_OW 3
81697: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
81698: LD_ADDR_VAR 0 16
81702: PUSH
81703: LD_VAR 0 16
81707: PPUSH
81708: LD_VAR 0 7
81712: PPUSH
81713: CALL_OW 3
81717: ST_TO_ADDR
// continue ;
81718: GO 81558
// end ; if f_repair then
81720: LD_VAR 0 22
81724: IFFALSE 82213
// begin if GetType ( group [ i ] ) = unit_vehicle then
81726: LD_VAR 0 4
81730: PUSH
81731: LD_VAR 0 7
81735: ARRAY
81736: PPUSH
81737: CALL_OW 247
81741: PUSH
81742: LD_INT 2
81744: EQUAL
81745: IFFALSE 81935
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
81747: LD_VAR 0 4
81751: PUSH
81752: LD_VAR 0 7
81756: ARRAY
81757: PPUSH
81758: CALL_OW 256
81762: PUSH
81763: LD_INT 700
81765: LESS
81766: PUSH
81767: LD_VAR 0 4
81771: PUSH
81772: LD_VAR 0 7
81776: ARRAY
81777: PUSH
81778: LD_VAR 0 32
81782: IN
81783: NOT
81784: AND
81785: IFFALSE 81809
// to_repair := to_repair union group [ i ] ;
81787: LD_ADDR_VAR 0 32
81791: PUSH
81792: LD_VAR 0 32
81796: PUSH
81797: LD_VAR 0 4
81801: PUSH
81802: LD_VAR 0 7
81806: ARRAY
81807: UNION
81808: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
81809: LD_VAR 0 4
81813: PUSH
81814: LD_VAR 0 7
81818: ARRAY
81819: PPUSH
81820: CALL_OW 256
81824: PUSH
81825: LD_INT 1000
81827: EQUAL
81828: PUSH
81829: LD_VAR 0 4
81833: PUSH
81834: LD_VAR 0 7
81838: ARRAY
81839: PUSH
81840: LD_VAR 0 32
81844: IN
81845: AND
81846: IFFALSE 81870
// to_repair := to_repair diff group [ i ] ;
81848: LD_ADDR_VAR 0 32
81852: PUSH
81853: LD_VAR 0 32
81857: PUSH
81858: LD_VAR 0 4
81862: PUSH
81863: LD_VAR 0 7
81867: ARRAY
81868: DIFF
81869: ST_TO_ADDR
// if group [ i ] in to_repair then
81870: LD_VAR 0 4
81874: PUSH
81875: LD_VAR 0 7
81879: ARRAY
81880: PUSH
81881: LD_VAR 0 32
81885: IN
81886: IFFALSE 81933
// begin if not IsInArea ( group [ i ] , f_repair ) then
81888: LD_VAR 0 4
81892: PUSH
81893: LD_VAR 0 7
81897: ARRAY
81898: PPUSH
81899: LD_VAR 0 22
81903: PPUSH
81904: CALL_OW 308
81908: NOT
81909: IFFALSE 81931
// ComMoveToArea ( group [ i ] , f_repair ) ;
81911: LD_VAR 0 4
81915: PUSH
81916: LD_VAR 0 7
81920: ARRAY
81921: PPUSH
81922: LD_VAR 0 22
81926: PPUSH
81927: CALL_OW 113
// continue ;
81931: GO 81558
// end ; end else
81933: GO 82213
// if group [ i ] in repairs then
81935: LD_VAR 0 4
81939: PUSH
81940: LD_VAR 0 7
81944: ARRAY
81945: PUSH
81946: LD_VAR 0 33
81950: IN
81951: IFFALSE 82213
// begin if IsInUnit ( group [ i ] ) then
81953: LD_VAR 0 4
81957: PUSH
81958: LD_VAR 0 7
81962: ARRAY
81963: PPUSH
81964: CALL_OW 310
81968: IFFALSE 82036
// begin z := IsInUnit ( group [ i ] ) ;
81970: LD_ADDR_VAR 0 13
81974: PUSH
81975: LD_VAR 0 4
81979: PUSH
81980: LD_VAR 0 7
81984: ARRAY
81985: PPUSH
81986: CALL_OW 310
81990: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
81991: LD_VAR 0 13
81995: PUSH
81996: LD_VAR 0 32
82000: IN
82001: PUSH
82002: LD_VAR 0 13
82006: PPUSH
82007: LD_VAR 0 22
82011: PPUSH
82012: CALL_OW 308
82016: AND
82017: IFFALSE 82034
// ComExitVehicle ( group [ i ] ) ;
82019: LD_VAR 0 4
82023: PUSH
82024: LD_VAR 0 7
82028: ARRAY
82029: PPUSH
82030: CALL_OW 121
// end else
82034: GO 82213
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
82036: LD_ADDR_VAR 0 13
82040: PUSH
82041: LD_VAR 0 4
82045: PPUSH
82046: LD_INT 95
82048: PUSH
82049: LD_VAR 0 22
82053: PUSH
82054: EMPTY
82055: LIST
82056: LIST
82057: PUSH
82058: LD_INT 58
82060: PUSH
82061: EMPTY
82062: LIST
82063: PUSH
82064: EMPTY
82065: LIST
82066: LIST
82067: PPUSH
82068: CALL_OW 72
82072: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
82073: LD_VAR 0 4
82077: PUSH
82078: LD_VAR 0 7
82082: ARRAY
82083: PPUSH
82084: CALL_OW 314
82088: NOT
82089: IFFALSE 82211
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
82091: LD_ADDR_VAR 0 10
82095: PUSH
82096: LD_VAR 0 13
82100: PPUSH
82101: LD_VAR 0 4
82105: PUSH
82106: LD_VAR 0 7
82110: ARRAY
82111: PPUSH
82112: CALL_OW 74
82116: ST_TO_ADDR
// if not x then
82117: LD_VAR 0 10
82121: NOT
82122: IFFALSE 82126
// continue ;
82124: GO 81558
// if GetLives ( x ) < 1000 then
82126: LD_VAR 0 10
82130: PPUSH
82131: CALL_OW 256
82135: PUSH
82136: LD_INT 1000
82138: LESS
82139: IFFALSE 82163
// ComRepairVehicle ( group [ i ] , x ) else
82141: LD_VAR 0 4
82145: PUSH
82146: LD_VAR 0 7
82150: ARRAY
82151: PPUSH
82152: LD_VAR 0 10
82156: PPUSH
82157: CALL_OW 129
82161: GO 82211
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
82163: LD_VAR 0 23
82167: PUSH
82168: LD_VAR 0 4
82172: PUSH
82173: LD_VAR 0 7
82177: ARRAY
82178: PPUSH
82179: CALL_OW 256
82183: PUSH
82184: LD_INT 1000
82186: LESS
82187: AND
82188: NOT
82189: IFFALSE 82211
// ComEnterUnit ( group [ i ] , x ) ;
82191: LD_VAR 0 4
82195: PUSH
82196: LD_VAR 0 7
82200: ARRAY
82201: PPUSH
82202: LD_VAR 0 10
82206: PPUSH
82207: CALL_OW 120
// end ; continue ;
82211: GO 81558
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
82213: LD_VAR 0 23
82217: PUSH
82218: LD_VAR 0 4
82222: PUSH
82223: LD_VAR 0 7
82227: ARRAY
82228: PPUSH
82229: CALL_OW 247
82233: PUSH
82234: LD_INT 1
82236: EQUAL
82237: AND
82238: IFFALSE 82716
// begin if group [ i ] in healers then
82240: LD_VAR 0 4
82244: PUSH
82245: LD_VAR 0 7
82249: ARRAY
82250: PUSH
82251: LD_VAR 0 31
82255: IN
82256: IFFALSE 82529
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
82258: LD_VAR 0 4
82262: PUSH
82263: LD_VAR 0 7
82267: ARRAY
82268: PPUSH
82269: LD_VAR 0 23
82273: PPUSH
82274: CALL_OW 308
82278: NOT
82279: PUSH
82280: LD_VAR 0 4
82284: PUSH
82285: LD_VAR 0 7
82289: ARRAY
82290: PPUSH
82291: CALL_OW 314
82295: NOT
82296: AND
82297: IFFALSE 82321
// ComMoveToArea ( group [ i ] , f_heal ) else
82299: LD_VAR 0 4
82303: PUSH
82304: LD_VAR 0 7
82308: ARRAY
82309: PPUSH
82310: LD_VAR 0 23
82314: PPUSH
82315: CALL_OW 113
82319: GO 82527
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
82321: LD_VAR 0 4
82325: PUSH
82326: LD_VAR 0 7
82330: ARRAY
82331: PPUSH
82332: CALL 53938 0 1
82336: PPUSH
82337: CALL_OW 256
82341: PUSH
82342: LD_INT 1000
82344: EQUAL
82345: IFFALSE 82364
// ComStop ( group [ i ] ) else
82347: LD_VAR 0 4
82351: PUSH
82352: LD_VAR 0 7
82356: ARRAY
82357: PPUSH
82358: CALL_OW 141
82362: GO 82527
// if not HasTask ( group [ i ] ) and to_heal then
82364: LD_VAR 0 4
82368: PUSH
82369: LD_VAR 0 7
82373: ARRAY
82374: PPUSH
82375: CALL_OW 314
82379: NOT
82380: PUSH
82381: LD_VAR 0 30
82385: AND
82386: IFFALSE 82527
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
82388: LD_ADDR_VAR 0 13
82392: PUSH
82393: LD_VAR 0 30
82397: PPUSH
82398: LD_INT 3
82400: PUSH
82401: LD_INT 54
82403: PUSH
82404: EMPTY
82405: LIST
82406: PUSH
82407: EMPTY
82408: LIST
82409: LIST
82410: PPUSH
82411: CALL_OW 72
82415: PPUSH
82416: LD_VAR 0 4
82420: PUSH
82421: LD_VAR 0 7
82425: ARRAY
82426: PPUSH
82427: CALL_OW 74
82431: ST_TO_ADDR
// if z then
82432: LD_VAR 0 13
82436: IFFALSE 82527
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
82438: LD_INT 91
82440: PUSH
82441: LD_VAR 0 13
82445: PUSH
82446: LD_INT 10
82448: PUSH
82449: EMPTY
82450: LIST
82451: LIST
82452: LIST
82453: PUSH
82454: LD_INT 81
82456: PUSH
82457: LD_VAR 0 13
82461: PPUSH
82462: CALL_OW 255
82466: PUSH
82467: EMPTY
82468: LIST
82469: LIST
82470: PUSH
82471: EMPTY
82472: LIST
82473: LIST
82474: PPUSH
82475: CALL_OW 69
82479: PUSH
82480: LD_INT 0
82482: EQUAL
82483: IFFALSE 82507
// ComHeal ( group [ i ] , z ) else
82485: LD_VAR 0 4
82489: PUSH
82490: LD_VAR 0 7
82494: ARRAY
82495: PPUSH
82496: LD_VAR 0 13
82500: PPUSH
82501: CALL_OW 128
82505: GO 82527
// ComMoveToArea ( group [ i ] , f_heal ) ;
82507: LD_VAR 0 4
82511: PUSH
82512: LD_VAR 0 7
82516: ARRAY
82517: PPUSH
82518: LD_VAR 0 23
82522: PPUSH
82523: CALL_OW 113
// end ; continue ;
82527: GO 81558
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
82529: LD_VAR 0 4
82533: PUSH
82534: LD_VAR 0 7
82538: ARRAY
82539: PPUSH
82540: CALL_OW 256
82544: PUSH
82545: LD_INT 700
82547: LESS
82548: PUSH
82549: LD_VAR 0 4
82553: PUSH
82554: LD_VAR 0 7
82558: ARRAY
82559: PUSH
82560: LD_VAR 0 30
82564: IN
82565: NOT
82566: AND
82567: IFFALSE 82591
// to_heal := to_heal union group [ i ] ;
82569: LD_ADDR_VAR 0 30
82573: PUSH
82574: LD_VAR 0 30
82578: PUSH
82579: LD_VAR 0 4
82583: PUSH
82584: LD_VAR 0 7
82588: ARRAY
82589: UNION
82590: ST_TO_ADDR
// if group [ i ] in to_heal then
82591: LD_VAR 0 4
82595: PUSH
82596: LD_VAR 0 7
82600: ARRAY
82601: PUSH
82602: LD_VAR 0 30
82606: IN
82607: IFFALSE 82716
// begin if GetLives ( group [ i ] ) = 1000 then
82609: LD_VAR 0 4
82613: PUSH
82614: LD_VAR 0 7
82618: ARRAY
82619: PPUSH
82620: CALL_OW 256
82624: PUSH
82625: LD_INT 1000
82627: EQUAL
82628: IFFALSE 82654
// to_heal := to_heal diff group [ i ] else
82630: LD_ADDR_VAR 0 30
82634: PUSH
82635: LD_VAR 0 30
82639: PUSH
82640: LD_VAR 0 4
82644: PUSH
82645: LD_VAR 0 7
82649: ARRAY
82650: DIFF
82651: ST_TO_ADDR
82652: GO 82716
// begin if not IsInArea ( group [ i ] , to_heal ) then
82654: LD_VAR 0 4
82658: PUSH
82659: LD_VAR 0 7
82663: ARRAY
82664: PPUSH
82665: LD_VAR 0 30
82669: PPUSH
82670: CALL_OW 308
82674: NOT
82675: IFFALSE 82699
// ComMoveToArea ( group [ i ] , f_heal ) else
82677: LD_VAR 0 4
82681: PUSH
82682: LD_VAR 0 7
82686: ARRAY
82687: PPUSH
82688: LD_VAR 0 23
82692: PPUSH
82693: CALL_OW 113
82697: GO 82714
// ComHold ( group [ i ] ) ;
82699: LD_VAR 0 4
82703: PUSH
82704: LD_VAR 0 7
82708: ARRAY
82709: PPUSH
82710: CALL_OW 140
// continue ;
82714: GO 81558
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
82716: LD_VAR 0 4
82720: PUSH
82721: LD_VAR 0 7
82725: ARRAY
82726: PPUSH
82727: LD_INT 10
82729: PPUSH
82730: CALL 51709 0 2
82734: NOT
82735: PUSH
82736: LD_VAR 0 16
82740: PUSH
82741: LD_VAR 0 7
82745: ARRAY
82746: PUSH
82747: EMPTY
82748: EQUAL
82749: NOT
82750: AND
82751: IFFALSE 83017
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
82753: LD_VAR 0 4
82757: PUSH
82758: LD_VAR 0 7
82762: ARRAY
82763: PPUSH
82764: CALL_OW 262
82768: PUSH
82769: LD_INT 1
82771: PUSH
82772: LD_INT 2
82774: PUSH
82775: EMPTY
82776: LIST
82777: LIST
82778: IN
82779: IFFALSE 82820
// if GetFuel ( group [ i ] ) < 10 then
82781: LD_VAR 0 4
82785: PUSH
82786: LD_VAR 0 7
82790: ARRAY
82791: PPUSH
82792: CALL_OW 261
82796: PUSH
82797: LD_INT 10
82799: LESS
82800: IFFALSE 82820
// SetFuel ( group [ i ] , 12 ) ;
82802: LD_VAR 0 4
82806: PUSH
82807: LD_VAR 0 7
82811: ARRAY
82812: PPUSH
82813: LD_INT 12
82815: PPUSH
82816: CALL_OW 240
// if units_path [ i ] then
82820: LD_VAR 0 16
82824: PUSH
82825: LD_VAR 0 7
82829: ARRAY
82830: IFFALSE 83015
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
82832: LD_VAR 0 4
82836: PUSH
82837: LD_VAR 0 7
82841: ARRAY
82842: PPUSH
82843: LD_VAR 0 16
82847: PUSH
82848: LD_VAR 0 7
82852: ARRAY
82853: PUSH
82854: LD_INT 1
82856: ARRAY
82857: PUSH
82858: LD_INT 1
82860: ARRAY
82861: PPUSH
82862: LD_VAR 0 16
82866: PUSH
82867: LD_VAR 0 7
82871: ARRAY
82872: PUSH
82873: LD_INT 1
82875: ARRAY
82876: PUSH
82877: LD_INT 2
82879: ARRAY
82880: PPUSH
82881: CALL_OW 297
82885: PUSH
82886: LD_INT 6
82888: GREATER
82889: IFFALSE 82964
// begin if not HasTask ( group [ i ] ) then
82891: LD_VAR 0 4
82895: PUSH
82896: LD_VAR 0 7
82900: ARRAY
82901: PPUSH
82902: CALL_OW 314
82906: NOT
82907: IFFALSE 82962
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
82909: LD_VAR 0 4
82913: PUSH
82914: LD_VAR 0 7
82918: ARRAY
82919: PPUSH
82920: LD_VAR 0 16
82924: PUSH
82925: LD_VAR 0 7
82929: ARRAY
82930: PUSH
82931: LD_INT 1
82933: ARRAY
82934: PUSH
82935: LD_INT 1
82937: ARRAY
82938: PPUSH
82939: LD_VAR 0 16
82943: PUSH
82944: LD_VAR 0 7
82948: ARRAY
82949: PUSH
82950: LD_INT 1
82952: ARRAY
82953: PUSH
82954: LD_INT 2
82956: ARRAY
82957: PPUSH
82958: CALL_OW 114
// end else
82962: GO 83015
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
82964: LD_ADDR_VAR 0 15
82968: PUSH
82969: LD_VAR 0 16
82973: PUSH
82974: LD_VAR 0 7
82978: ARRAY
82979: PPUSH
82980: LD_INT 1
82982: PPUSH
82983: CALL_OW 3
82987: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
82988: LD_ADDR_VAR 0 16
82992: PUSH
82993: LD_VAR 0 16
82997: PPUSH
82998: LD_VAR 0 7
83002: PPUSH
83003: LD_VAR 0 15
83007: PPUSH
83008: CALL_OW 1
83012: ST_TO_ADDR
// continue ;
83013: GO 81558
// end ; end ; end else
83015: GO 85679
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
83017: LD_ADDR_VAR 0 14
83021: PUSH
83022: LD_INT 81
83024: PUSH
83025: LD_VAR 0 4
83029: PUSH
83030: LD_VAR 0 7
83034: ARRAY
83035: PPUSH
83036: CALL_OW 255
83040: PUSH
83041: EMPTY
83042: LIST
83043: LIST
83044: PPUSH
83045: CALL_OW 69
83049: ST_TO_ADDR
// if not tmp then
83050: LD_VAR 0 14
83054: NOT
83055: IFFALSE 83059
// continue ;
83057: GO 81558
// if f_ignore_area then
83059: LD_VAR 0 17
83063: IFFALSE 83151
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
83065: LD_ADDR_VAR 0 15
83069: PUSH
83070: LD_VAR 0 14
83074: PPUSH
83075: LD_INT 3
83077: PUSH
83078: LD_INT 92
83080: PUSH
83081: LD_VAR 0 17
83085: PUSH
83086: LD_INT 1
83088: ARRAY
83089: PUSH
83090: LD_VAR 0 17
83094: PUSH
83095: LD_INT 2
83097: ARRAY
83098: PUSH
83099: LD_VAR 0 17
83103: PUSH
83104: LD_INT 3
83106: ARRAY
83107: PUSH
83108: EMPTY
83109: LIST
83110: LIST
83111: LIST
83112: LIST
83113: PUSH
83114: EMPTY
83115: LIST
83116: LIST
83117: PPUSH
83118: CALL_OW 72
83122: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
83123: LD_VAR 0 14
83127: PUSH
83128: LD_VAR 0 15
83132: DIFF
83133: IFFALSE 83151
// tmp := tmp diff tmp2 ;
83135: LD_ADDR_VAR 0 14
83139: PUSH
83140: LD_VAR 0 14
83144: PUSH
83145: LD_VAR 0 15
83149: DIFF
83150: ST_TO_ADDR
// end ; if not f_murder then
83151: LD_VAR 0 20
83155: NOT
83156: IFFALSE 83214
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
83158: LD_ADDR_VAR 0 15
83162: PUSH
83163: LD_VAR 0 14
83167: PPUSH
83168: LD_INT 3
83170: PUSH
83171: LD_INT 50
83173: PUSH
83174: EMPTY
83175: LIST
83176: PUSH
83177: EMPTY
83178: LIST
83179: LIST
83180: PPUSH
83181: CALL_OW 72
83185: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
83186: LD_VAR 0 14
83190: PUSH
83191: LD_VAR 0 15
83195: DIFF
83196: IFFALSE 83214
// tmp := tmp diff tmp2 ;
83198: LD_ADDR_VAR 0 14
83202: PUSH
83203: LD_VAR 0 14
83207: PUSH
83208: LD_VAR 0 15
83212: DIFF
83213: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
83214: LD_ADDR_VAR 0 14
83218: PUSH
83219: LD_VAR 0 4
83223: PUSH
83224: LD_VAR 0 7
83228: ARRAY
83229: PPUSH
83230: LD_VAR 0 14
83234: PPUSH
83235: LD_INT 1
83237: PPUSH
83238: LD_INT 1
83240: PPUSH
83241: CALL 24621 0 4
83245: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
83246: LD_VAR 0 4
83250: PUSH
83251: LD_VAR 0 7
83255: ARRAY
83256: PPUSH
83257: CALL_OW 257
83261: PUSH
83262: LD_INT 1
83264: EQUAL
83265: IFFALSE 83713
// begin if WantPlant ( group [ i ] ) then
83267: LD_VAR 0 4
83271: PUSH
83272: LD_VAR 0 7
83276: ARRAY
83277: PPUSH
83278: CALL 24122 0 1
83282: IFFALSE 83286
// continue ;
83284: GO 81558
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
83286: LD_VAR 0 18
83290: PUSH
83291: LD_VAR 0 4
83295: PUSH
83296: LD_VAR 0 7
83300: ARRAY
83301: PPUSH
83302: CALL_OW 310
83306: NOT
83307: AND
83308: PUSH
83309: LD_VAR 0 14
83313: PUSH
83314: LD_INT 1
83316: ARRAY
83317: PUSH
83318: LD_VAR 0 14
83322: PPUSH
83323: LD_INT 21
83325: PUSH
83326: LD_INT 2
83328: PUSH
83329: EMPTY
83330: LIST
83331: LIST
83332: PUSH
83333: LD_INT 58
83335: PUSH
83336: EMPTY
83337: LIST
83338: PUSH
83339: EMPTY
83340: LIST
83341: LIST
83342: PPUSH
83343: CALL_OW 72
83347: IN
83348: AND
83349: IFFALSE 83385
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
83351: LD_VAR 0 4
83355: PUSH
83356: LD_VAR 0 7
83360: ARRAY
83361: PPUSH
83362: LD_VAR 0 14
83366: PUSH
83367: LD_INT 1
83369: ARRAY
83370: PPUSH
83371: CALL_OW 120
// attacking := true ;
83375: LD_ADDR_VAR 0 29
83379: PUSH
83380: LD_INT 1
83382: ST_TO_ADDR
// continue ;
83383: GO 81558
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
83385: LD_VAR 0 26
83389: PUSH
83390: LD_VAR 0 4
83394: PUSH
83395: LD_VAR 0 7
83399: ARRAY
83400: PPUSH
83401: CALL_OW 257
83405: PUSH
83406: LD_INT 1
83408: EQUAL
83409: AND
83410: PUSH
83411: LD_VAR 0 4
83415: PUSH
83416: LD_VAR 0 7
83420: ARRAY
83421: PPUSH
83422: CALL_OW 256
83426: PUSH
83427: LD_INT 800
83429: LESS
83430: AND
83431: PUSH
83432: LD_VAR 0 4
83436: PUSH
83437: LD_VAR 0 7
83441: ARRAY
83442: PPUSH
83443: CALL_OW 318
83447: NOT
83448: AND
83449: IFFALSE 83466
// ComCrawl ( group [ i ] ) ;
83451: LD_VAR 0 4
83455: PUSH
83456: LD_VAR 0 7
83460: ARRAY
83461: PPUSH
83462: CALL_OW 137
// if f_mines then
83466: LD_VAR 0 21
83470: IFFALSE 83713
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
83472: LD_VAR 0 14
83476: PUSH
83477: LD_INT 1
83479: ARRAY
83480: PPUSH
83481: CALL_OW 247
83485: PUSH
83486: LD_INT 3
83488: EQUAL
83489: PUSH
83490: LD_VAR 0 14
83494: PUSH
83495: LD_INT 1
83497: ARRAY
83498: PUSH
83499: LD_VAR 0 27
83503: IN
83504: NOT
83505: AND
83506: IFFALSE 83713
// begin x := GetX ( tmp [ 1 ] ) ;
83508: LD_ADDR_VAR 0 10
83512: PUSH
83513: LD_VAR 0 14
83517: PUSH
83518: LD_INT 1
83520: ARRAY
83521: PPUSH
83522: CALL_OW 250
83526: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
83527: LD_ADDR_VAR 0 11
83531: PUSH
83532: LD_VAR 0 14
83536: PUSH
83537: LD_INT 1
83539: ARRAY
83540: PPUSH
83541: CALL_OW 251
83545: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
83546: LD_ADDR_VAR 0 12
83550: PUSH
83551: LD_VAR 0 4
83555: PUSH
83556: LD_VAR 0 7
83560: ARRAY
83561: PPUSH
83562: CALL 51794 0 1
83566: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
83567: LD_VAR 0 4
83571: PUSH
83572: LD_VAR 0 7
83576: ARRAY
83577: PPUSH
83578: LD_VAR 0 10
83582: PPUSH
83583: LD_VAR 0 11
83587: PPUSH
83588: LD_VAR 0 14
83592: PUSH
83593: LD_INT 1
83595: ARRAY
83596: PPUSH
83597: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
83601: LD_VAR 0 4
83605: PUSH
83606: LD_VAR 0 7
83610: ARRAY
83611: PPUSH
83612: LD_VAR 0 10
83616: PPUSH
83617: LD_VAR 0 12
83621: PPUSH
83622: LD_INT 7
83624: PPUSH
83625: CALL_OW 272
83629: PPUSH
83630: LD_VAR 0 11
83634: PPUSH
83635: LD_VAR 0 12
83639: PPUSH
83640: LD_INT 7
83642: PPUSH
83643: CALL_OW 273
83647: PPUSH
83648: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
83652: LD_VAR 0 4
83656: PUSH
83657: LD_VAR 0 7
83661: ARRAY
83662: PPUSH
83663: LD_INT 71
83665: PPUSH
83666: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
83670: LD_ADDR_VAR 0 27
83674: PUSH
83675: LD_VAR 0 27
83679: PPUSH
83680: LD_VAR 0 27
83684: PUSH
83685: LD_INT 1
83687: PLUS
83688: PPUSH
83689: LD_VAR 0 14
83693: PUSH
83694: LD_INT 1
83696: ARRAY
83697: PPUSH
83698: CALL_OW 1
83702: ST_TO_ADDR
// attacking := true ;
83703: LD_ADDR_VAR 0 29
83707: PUSH
83708: LD_INT 1
83710: ST_TO_ADDR
// continue ;
83711: GO 81558
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
83713: LD_VAR 0 4
83717: PUSH
83718: LD_VAR 0 7
83722: ARRAY
83723: PPUSH
83724: CALL_OW 257
83728: PUSH
83729: LD_INT 17
83731: EQUAL
83732: PUSH
83733: LD_VAR 0 4
83737: PUSH
83738: LD_VAR 0 7
83742: ARRAY
83743: PPUSH
83744: CALL_OW 110
83748: PUSH
83749: LD_INT 71
83751: EQUAL
83752: NOT
83753: AND
83754: IFFALSE 83900
// begin attacking := false ;
83756: LD_ADDR_VAR 0 29
83760: PUSH
83761: LD_INT 0
83763: ST_TO_ADDR
// k := 5 ;
83764: LD_ADDR_VAR 0 9
83768: PUSH
83769: LD_INT 5
83771: ST_TO_ADDR
// if tmp < k then
83772: LD_VAR 0 14
83776: PUSH
83777: LD_VAR 0 9
83781: LESS
83782: IFFALSE 83794
// k := tmp ;
83784: LD_ADDR_VAR 0 9
83788: PUSH
83789: LD_VAR 0 14
83793: ST_TO_ADDR
// for j = 1 to k do
83794: LD_ADDR_VAR 0 8
83798: PUSH
83799: DOUBLE
83800: LD_INT 1
83802: DEC
83803: ST_TO_ADDR
83804: LD_VAR 0 9
83808: PUSH
83809: FOR_TO
83810: IFFALSE 83898
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
83812: LD_VAR 0 14
83816: PUSH
83817: LD_VAR 0 8
83821: ARRAY
83822: PUSH
83823: LD_VAR 0 14
83827: PPUSH
83828: LD_INT 58
83830: PUSH
83831: EMPTY
83832: LIST
83833: PPUSH
83834: CALL_OW 72
83838: IN
83839: NOT
83840: IFFALSE 83896
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
83842: LD_VAR 0 4
83846: PUSH
83847: LD_VAR 0 7
83851: ARRAY
83852: PPUSH
83853: LD_VAR 0 14
83857: PUSH
83858: LD_VAR 0 8
83862: ARRAY
83863: PPUSH
83864: CALL_OW 115
// attacking := true ;
83868: LD_ADDR_VAR 0 29
83872: PUSH
83873: LD_INT 1
83875: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
83876: LD_VAR 0 4
83880: PUSH
83881: LD_VAR 0 7
83885: ARRAY
83886: PPUSH
83887: LD_INT 71
83889: PPUSH
83890: CALL_OW 109
// continue ;
83894: GO 83809
// end ; end ;
83896: GO 83809
83898: POP
83899: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
83900: LD_VAR 0 4
83904: PUSH
83905: LD_VAR 0 7
83909: ARRAY
83910: PPUSH
83911: CALL_OW 257
83915: PUSH
83916: LD_INT 8
83918: EQUAL
83919: PUSH
83920: LD_VAR 0 4
83924: PUSH
83925: LD_VAR 0 7
83929: ARRAY
83930: PPUSH
83931: CALL_OW 264
83935: PUSH
83936: LD_INT 28
83938: PUSH
83939: LD_INT 45
83941: PUSH
83942: LD_INT 7
83944: PUSH
83945: LD_INT 47
83947: PUSH
83948: EMPTY
83949: LIST
83950: LIST
83951: LIST
83952: LIST
83953: IN
83954: OR
83955: IFFALSE 84211
// begin attacking := false ;
83957: LD_ADDR_VAR 0 29
83961: PUSH
83962: LD_INT 0
83964: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
83965: LD_VAR 0 14
83969: PUSH
83970: LD_INT 1
83972: ARRAY
83973: PPUSH
83974: CALL_OW 266
83978: PUSH
83979: LD_INT 32
83981: PUSH
83982: LD_INT 31
83984: PUSH
83985: LD_INT 33
83987: PUSH
83988: LD_INT 4
83990: PUSH
83991: LD_INT 5
83993: PUSH
83994: EMPTY
83995: LIST
83996: LIST
83997: LIST
83998: LIST
83999: LIST
84000: IN
84001: IFFALSE 84187
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
84003: LD_ADDR_VAR 0 9
84007: PUSH
84008: LD_VAR 0 14
84012: PUSH
84013: LD_INT 1
84015: ARRAY
84016: PPUSH
84017: CALL_OW 266
84021: PPUSH
84022: LD_VAR 0 14
84026: PUSH
84027: LD_INT 1
84029: ARRAY
84030: PPUSH
84031: CALL_OW 250
84035: PPUSH
84036: LD_VAR 0 14
84040: PUSH
84041: LD_INT 1
84043: ARRAY
84044: PPUSH
84045: CALL_OW 251
84049: PPUSH
84050: LD_VAR 0 14
84054: PUSH
84055: LD_INT 1
84057: ARRAY
84058: PPUSH
84059: CALL_OW 254
84063: PPUSH
84064: LD_VAR 0 14
84068: PUSH
84069: LD_INT 1
84071: ARRAY
84072: PPUSH
84073: CALL_OW 248
84077: PPUSH
84078: LD_INT 0
84080: PPUSH
84081: CALL 33164 0 6
84085: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
84086: LD_ADDR_VAR 0 8
84090: PUSH
84091: LD_VAR 0 4
84095: PUSH
84096: LD_VAR 0 7
84100: ARRAY
84101: PPUSH
84102: LD_VAR 0 9
84106: PPUSH
84107: CALL 51907 0 2
84111: ST_TO_ADDR
// if j then
84112: LD_VAR 0 8
84116: IFFALSE 84185
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
84118: LD_VAR 0 8
84122: PUSH
84123: LD_INT 1
84125: ARRAY
84126: PPUSH
84127: LD_VAR 0 8
84131: PUSH
84132: LD_INT 2
84134: ARRAY
84135: PPUSH
84136: CALL_OW 488
84140: IFFALSE 84185
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
84142: LD_VAR 0 4
84146: PUSH
84147: LD_VAR 0 7
84151: ARRAY
84152: PPUSH
84153: LD_VAR 0 8
84157: PUSH
84158: LD_INT 1
84160: ARRAY
84161: PPUSH
84162: LD_VAR 0 8
84166: PUSH
84167: LD_INT 2
84169: ARRAY
84170: PPUSH
84171: CALL_OW 116
// attacking := true ;
84175: LD_ADDR_VAR 0 29
84179: PUSH
84180: LD_INT 1
84182: ST_TO_ADDR
// continue ;
84183: GO 81558
// end ; end else
84185: GO 84211
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
84187: LD_VAR 0 4
84191: PUSH
84192: LD_VAR 0 7
84196: ARRAY
84197: PPUSH
84198: LD_VAR 0 14
84202: PUSH
84203: LD_INT 1
84205: ARRAY
84206: PPUSH
84207: CALL_OW 115
// end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
84211: LD_VAR 0 4
84215: PUSH
84216: LD_VAR 0 7
84220: ARRAY
84221: PPUSH
84222: CALL_OW 265
84226: PUSH
84227: LD_INT 11
84229: EQUAL
84230: IFFALSE 84508
// begin k := 10 ;
84232: LD_ADDR_VAR 0 9
84236: PUSH
84237: LD_INT 10
84239: ST_TO_ADDR
// x := 0 ;
84240: LD_ADDR_VAR 0 10
84244: PUSH
84245: LD_INT 0
84247: ST_TO_ADDR
// if tmp < k then
84248: LD_VAR 0 14
84252: PUSH
84253: LD_VAR 0 9
84257: LESS
84258: IFFALSE 84270
// k := tmp ;
84260: LD_ADDR_VAR 0 9
84264: PUSH
84265: LD_VAR 0 14
84269: ST_TO_ADDR
// for j = k downto 1 do
84270: LD_ADDR_VAR 0 8
84274: PUSH
84275: DOUBLE
84276: LD_VAR 0 9
84280: INC
84281: ST_TO_ADDR
84282: LD_INT 1
84284: PUSH
84285: FOR_DOWNTO
84286: IFFALSE 84361
// begin if GetType ( tmp [ j ] ) = unit_human then
84288: LD_VAR 0 14
84292: PUSH
84293: LD_VAR 0 8
84297: ARRAY
84298: PPUSH
84299: CALL_OW 247
84303: PUSH
84304: LD_INT 1
84306: EQUAL
84307: IFFALSE 84359
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
84309: LD_VAR 0 4
84313: PUSH
84314: LD_VAR 0 7
84318: ARRAY
84319: PPUSH
84320: LD_VAR 0 14
84324: PUSH
84325: LD_VAR 0 8
84329: ARRAY
84330: PPUSH
84331: CALL 52161 0 2
// x := tmp [ j ] ;
84335: LD_ADDR_VAR 0 10
84339: PUSH
84340: LD_VAR 0 14
84344: PUSH
84345: LD_VAR 0 8
84349: ARRAY
84350: ST_TO_ADDR
// attacking := true ;
84351: LD_ADDR_VAR 0 29
84355: PUSH
84356: LD_INT 1
84358: ST_TO_ADDR
// end ; end ;
84359: GO 84285
84361: POP
84362: POP
// if not x then
84363: LD_VAR 0 10
84367: NOT
84368: IFFALSE 84508
// begin attacking := true ;
84370: LD_ADDR_VAR 0 29
84374: PUSH
84375: LD_INT 1
84377: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
84378: LD_VAR 0 4
84382: PUSH
84383: LD_VAR 0 7
84387: ARRAY
84388: PPUSH
84389: CALL_OW 250
84393: PPUSH
84394: LD_VAR 0 4
84398: PUSH
84399: LD_VAR 0 7
84403: ARRAY
84404: PPUSH
84405: CALL_OW 251
84409: PPUSH
84410: CALL_OW 546
84414: PUSH
84415: LD_INT 2
84417: ARRAY
84418: PUSH
84419: LD_VAR 0 14
84423: PUSH
84424: LD_INT 1
84426: ARRAY
84427: PPUSH
84428: CALL_OW 250
84432: PPUSH
84433: LD_VAR 0 14
84437: PUSH
84438: LD_INT 1
84440: ARRAY
84441: PPUSH
84442: CALL_OW 251
84446: PPUSH
84447: CALL_OW 546
84451: PUSH
84452: LD_INT 2
84454: ARRAY
84455: EQUAL
84456: IFFALSE 84484
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
84458: LD_VAR 0 4
84462: PUSH
84463: LD_VAR 0 7
84467: ARRAY
84468: PPUSH
84469: LD_VAR 0 14
84473: PUSH
84474: LD_INT 1
84476: ARRAY
84477: PPUSH
84478: CALL 52161 0 2
84482: GO 84508
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
84484: LD_VAR 0 4
84488: PUSH
84489: LD_VAR 0 7
84493: ARRAY
84494: PPUSH
84495: LD_VAR 0 14
84499: PUSH
84500: LD_INT 1
84502: ARRAY
84503: PPUSH
84504: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
84508: LD_VAR 0 4
84512: PUSH
84513: LD_VAR 0 7
84517: ARRAY
84518: PPUSH
84519: CALL_OW 264
84523: PUSH
84524: LD_INT 29
84526: EQUAL
84527: IFFALSE 84893
// begin if WantsToAttack ( group [ i ] ) in bombed then
84529: LD_VAR 0 4
84533: PUSH
84534: LD_VAR 0 7
84538: ARRAY
84539: PPUSH
84540: CALL_OW 319
84544: PUSH
84545: LD_VAR 0 28
84549: IN
84550: IFFALSE 84554
// continue ;
84552: GO 81558
// k := 8 ;
84554: LD_ADDR_VAR 0 9
84558: PUSH
84559: LD_INT 8
84561: ST_TO_ADDR
// x := 0 ;
84562: LD_ADDR_VAR 0 10
84566: PUSH
84567: LD_INT 0
84569: ST_TO_ADDR
// if tmp < k then
84570: LD_VAR 0 14
84574: PUSH
84575: LD_VAR 0 9
84579: LESS
84580: IFFALSE 84592
// k := tmp ;
84582: LD_ADDR_VAR 0 9
84586: PUSH
84587: LD_VAR 0 14
84591: ST_TO_ADDR
// for j = 1 to k do
84592: LD_ADDR_VAR 0 8
84596: PUSH
84597: DOUBLE
84598: LD_INT 1
84600: DEC
84601: ST_TO_ADDR
84602: LD_VAR 0 9
84606: PUSH
84607: FOR_TO
84608: IFFALSE 84740
// begin if GetType ( tmp [ j ] ) = unit_building then
84610: LD_VAR 0 14
84614: PUSH
84615: LD_VAR 0 8
84619: ARRAY
84620: PPUSH
84621: CALL_OW 247
84625: PUSH
84626: LD_INT 3
84628: EQUAL
84629: IFFALSE 84738
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
84631: LD_VAR 0 14
84635: PUSH
84636: LD_VAR 0 8
84640: ARRAY
84641: PUSH
84642: LD_VAR 0 28
84646: IN
84647: NOT
84648: PUSH
84649: LD_VAR 0 14
84653: PUSH
84654: LD_VAR 0 8
84658: ARRAY
84659: PPUSH
84660: CALL_OW 313
84664: AND
84665: IFFALSE 84738
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
84667: LD_VAR 0 4
84671: PUSH
84672: LD_VAR 0 7
84676: ARRAY
84677: PPUSH
84678: LD_VAR 0 14
84682: PUSH
84683: LD_VAR 0 8
84687: ARRAY
84688: PPUSH
84689: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
84693: LD_ADDR_VAR 0 28
84697: PUSH
84698: LD_VAR 0 28
84702: PPUSH
84703: LD_VAR 0 28
84707: PUSH
84708: LD_INT 1
84710: PLUS
84711: PPUSH
84712: LD_VAR 0 14
84716: PUSH
84717: LD_VAR 0 8
84721: ARRAY
84722: PPUSH
84723: CALL_OW 1
84727: ST_TO_ADDR
// attacking := true ;
84728: LD_ADDR_VAR 0 29
84732: PUSH
84733: LD_INT 1
84735: ST_TO_ADDR
// break ;
84736: GO 84740
// end ; end ;
84738: GO 84607
84740: POP
84741: POP
// if not attacking and f_attack_depot then
84742: LD_VAR 0 29
84746: NOT
84747: PUSH
84748: LD_VAR 0 25
84752: AND
84753: IFFALSE 84848
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
84755: LD_ADDR_VAR 0 13
84759: PUSH
84760: LD_VAR 0 14
84764: PPUSH
84765: LD_INT 2
84767: PUSH
84768: LD_INT 30
84770: PUSH
84771: LD_INT 0
84773: PUSH
84774: EMPTY
84775: LIST
84776: LIST
84777: PUSH
84778: LD_INT 30
84780: PUSH
84781: LD_INT 1
84783: PUSH
84784: EMPTY
84785: LIST
84786: LIST
84787: PUSH
84788: EMPTY
84789: LIST
84790: LIST
84791: LIST
84792: PPUSH
84793: CALL_OW 72
84797: ST_TO_ADDR
// if z then
84798: LD_VAR 0 13
84802: IFFALSE 84848
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
84804: LD_VAR 0 4
84808: PUSH
84809: LD_VAR 0 7
84813: ARRAY
84814: PPUSH
84815: LD_VAR 0 13
84819: PPUSH
84820: LD_VAR 0 4
84824: PUSH
84825: LD_VAR 0 7
84829: ARRAY
84830: PPUSH
84831: CALL_OW 74
84835: PPUSH
84836: CALL_OW 115
// attacking := true ;
84840: LD_ADDR_VAR 0 29
84844: PUSH
84845: LD_INT 1
84847: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
84848: LD_VAR 0 4
84852: PUSH
84853: LD_VAR 0 7
84857: ARRAY
84858: PPUSH
84859: CALL_OW 256
84863: PUSH
84864: LD_INT 500
84866: LESS
84867: IFFALSE 84893
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
84869: LD_VAR 0 4
84873: PUSH
84874: LD_VAR 0 7
84878: ARRAY
84879: PPUSH
84880: LD_VAR 0 14
84884: PUSH
84885: LD_INT 1
84887: ARRAY
84888: PPUSH
84889: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
84893: LD_VAR 0 4
84897: PUSH
84898: LD_VAR 0 7
84902: ARRAY
84903: PPUSH
84904: CALL_OW 264
84908: PUSH
84909: LD_INT 49
84911: EQUAL
84912: IFFALSE 85033
// begin if not HasTask ( group [ i ] ) then
84914: LD_VAR 0 4
84918: PUSH
84919: LD_VAR 0 7
84923: ARRAY
84924: PPUSH
84925: CALL_OW 314
84929: NOT
84930: IFFALSE 85033
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
84932: LD_ADDR_VAR 0 9
84936: PUSH
84937: LD_INT 81
84939: PUSH
84940: LD_VAR 0 4
84944: PUSH
84945: LD_VAR 0 7
84949: ARRAY
84950: PPUSH
84951: CALL_OW 255
84955: PUSH
84956: EMPTY
84957: LIST
84958: LIST
84959: PPUSH
84960: CALL_OW 69
84964: PPUSH
84965: LD_VAR 0 4
84969: PUSH
84970: LD_VAR 0 7
84974: ARRAY
84975: PPUSH
84976: CALL_OW 74
84980: ST_TO_ADDR
// if k then
84981: LD_VAR 0 9
84985: IFFALSE 85033
// if GetDistUnits ( group [ i ] , k ) > 10 then
84987: LD_VAR 0 4
84991: PUSH
84992: LD_VAR 0 7
84996: ARRAY
84997: PPUSH
84998: LD_VAR 0 9
85002: PPUSH
85003: CALL_OW 296
85007: PUSH
85008: LD_INT 10
85010: GREATER
85011: IFFALSE 85033
// ComMoveUnit ( group [ i ] , k ) ;
85013: LD_VAR 0 4
85017: PUSH
85018: LD_VAR 0 7
85022: ARRAY
85023: PPUSH
85024: LD_VAR 0 9
85028: PPUSH
85029: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
85033: LD_VAR 0 4
85037: PUSH
85038: LD_VAR 0 7
85042: ARRAY
85043: PPUSH
85044: CALL_OW 256
85048: PUSH
85049: LD_INT 250
85051: LESS
85052: PUSH
85053: LD_VAR 0 4
85057: PUSH
85058: LD_VAR 0 7
85062: ARRAY
85063: PUSH
85064: LD_INT 21
85066: PUSH
85067: LD_INT 2
85069: PUSH
85070: EMPTY
85071: LIST
85072: LIST
85073: PUSH
85074: LD_INT 23
85076: PUSH
85077: LD_INT 2
85079: PUSH
85080: EMPTY
85081: LIST
85082: LIST
85083: PUSH
85084: EMPTY
85085: LIST
85086: LIST
85087: PPUSH
85088: CALL_OW 69
85092: IN
85093: AND
85094: IFFALSE 85219
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
85096: LD_ADDR_VAR 0 9
85100: PUSH
85101: LD_OWVAR 3
85105: PUSH
85106: LD_VAR 0 4
85110: PUSH
85111: LD_VAR 0 7
85115: ARRAY
85116: DIFF
85117: PPUSH
85118: LD_VAR 0 4
85122: PUSH
85123: LD_VAR 0 7
85127: ARRAY
85128: PPUSH
85129: CALL_OW 74
85133: ST_TO_ADDR
// if not k then
85134: LD_VAR 0 9
85138: NOT
85139: IFFALSE 85143
// continue ;
85141: GO 81558
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
85143: LD_VAR 0 9
85147: PUSH
85148: LD_INT 81
85150: PUSH
85151: LD_VAR 0 4
85155: PUSH
85156: LD_VAR 0 7
85160: ARRAY
85161: PPUSH
85162: CALL_OW 255
85166: PUSH
85167: EMPTY
85168: LIST
85169: LIST
85170: PPUSH
85171: CALL_OW 69
85175: IN
85176: PUSH
85177: LD_VAR 0 9
85181: PPUSH
85182: LD_VAR 0 4
85186: PUSH
85187: LD_VAR 0 7
85191: ARRAY
85192: PPUSH
85193: CALL_OW 296
85197: PUSH
85198: LD_INT 5
85200: LESS
85201: AND
85202: IFFALSE 85219
// ComAutodestruct ( group [ i ] ) ;
85204: LD_VAR 0 4
85208: PUSH
85209: LD_VAR 0 7
85213: ARRAY
85214: PPUSH
85215: CALL 52059 0 1
// end ; if f_attack_depot then
85219: LD_VAR 0 25
85223: IFFALSE 85335
// begin k := 6 ;
85225: LD_ADDR_VAR 0 9
85229: PUSH
85230: LD_INT 6
85232: ST_TO_ADDR
// if tmp < k then
85233: LD_VAR 0 14
85237: PUSH
85238: LD_VAR 0 9
85242: LESS
85243: IFFALSE 85255
// k := tmp ;
85245: LD_ADDR_VAR 0 9
85249: PUSH
85250: LD_VAR 0 14
85254: ST_TO_ADDR
// for j = 1 to k do
85255: LD_ADDR_VAR 0 8
85259: PUSH
85260: DOUBLE
85261: LD_INT 1
85263: DEC
85264: ST_TO_ADDR
85265: LD_VAR 0 9
85269: PUSH
85270: FOR_TO
85271: IFFALSE 85333
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
85273: LD_VAR 0 8
85277: PPUSH
85278: CALL_OW 266
85282: PUSH
85283: LD_INT 0
85285: PUSH
85286: LD_INT 1
85288: PUSH
85289: EMPTY
85290: LIST
85291: LIST
85292: IN
85293: IFFALSE 85331
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
85295: LD_VAR 0 4
85299: PUSH
85300: LD_VAR 0 7
85304: ARRAY
85305: PPUSH
85306: LD_VAR 0 14
85310: PUSH
85311: LD_VAR 0 8
85315: ARRAY
85316: PPUSH
85317: CALL_OW 115
// attacking := true ;
85321: LD_ADDR_VAR 0 29
85325: PUSH
85326: LD_INT 1
85328: ST_TO_ADDR
// break ;
85329: GO 85333
// end ;
85331: GO 85270
85333: POP
85334: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
85335: LD_VAR 0 4
85339: PUSH
85340: LD_VAR 0 7
85344: ARRAY
85345: PPUSH
85346: CALL_OW 302
85350: PUSH
85351: LD_VAR 0 29
85355: NOT
85356: AND
85357: IFFALSE 85679
// begin if GetTag ( group [ i ] ) = 71 then
85359: LD_VAR 0 4
85363: PUSH
85364: LD_VAR 0 7
85368: ARRAY
85369: PPUSH
85370: CALL_OW 110
85374: PUSH
85375: LD_INT 71
85377: EQUAL
85378: IFFALSE 85419
// begin if HasTask ( group [ i ] ) then
85380: LD_VAR 0 4
85384: PUSH
85385: LD_VAR 0 7
85389: ARRAY
85390: PPUSH
85391: CALL_OW 314
85395: IFFALSE 85401
// continue else
85397: GO 81558
85399: GO 85419
// SetTag ( group [ i ] , 0 ) ;
85401: LD_VAR 0 4
85405: PUSH
85406: LD_VAR 0 7
85410: ARRAY
85411: PPUSH
85412: LD_INT 0
85414: PPUSH
85415: CALL_OW 109
// end ; k := 8 ;
85419: LD_ADDR_VAR 0 9
85423: PUSH
85424: LD_INT 8
85426: ST_TO_ADDR
// x := 0 ;
85427: LD_ADDR_VAR 0 10
85431: PUSH
85432: LD_INT 0
85434: ST_TO_ADDR
// if tmp < k then
85435: LD_VAR 0 14
85439: PUSH
85440: LD_VAR 0 9
85444: LESS
85445: IFFALSE 85457
// k := tmp ;
85447: LD_ADDR_VAR 0 9
85451: PUSH
85452: LD_VAR 0 14
85456: ST_TO_ADDR
// for j = 1 to k do
85457: LD_ADDR_VAR 0 8
85461: PUSH
85462: DOUBLE
85463: LD_INT 1
85465: DEC
85466: ST_TO_ADDR
85467: LD_VAR 0 9
85471: PUSH
85472: FOR_TO
85473: IFFALSE 85571
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
85475: LD_VAR 0 14
85479: PUSH
85480: LD_VAR 0 8
85484: ARRAY
85485: PPUSH
85486: CALL_OW 247
85490: PUSH
85491: LD_INT 1
85493: EQUAL
85494: PUSH
85495: LD_VAR 0 14
85499: PUSH
85500: LD_VAR 0 8
85504: ARRAY
85505: PPUSH
85506: CALL_OW 256
85510: PUSH
85511: LD_INT 250
85513: LESS
85514: PUSH
85515: LD_VAR 0 20
85519: AND
85520: PUSH
85521: LD_VAR 0 20
85525: NOT
85526: PUSH
85527: LD_VAR 0 14
85531: PUSH
85532: LD_VAR 0 8
85536: ARRAY
85537: PPUSH
85538: CALL_OW 256
85542: PUSH
85543: LD_INT 250
85545: GREATEREQUAL
85546: AND
85547: OR
85548: AND
85549: IFFALSE 85569
// begin x := tmp [ j ] ;
85551: LD_ADDR_VAR 0 10
85555: PUSH
85556: LD_VAR 0 14
85560: PUSH
85561: LD_VAR 0 8
85565: ARRAY
85566: ST_TO_ADDR
// break ;
85567: GO 85571
// end ;
85569: GO 85472
85571: POP
85572: POP
// if x then
85573: LD_VAR 0 10
85577: IFFALSE 85601
// ComAttackUnit ( group [ i ] , x ) else
85579: LD_VAR 0 4
85583: PUSH
85584: LD_VAR 0 7
85588: ARRAY
85589: PPUSH
85590: LD_VAR 0 10
85594: PPUSH
85595: CALL_OW 115
85599: GO 85625
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
85601: LD_VAR 0 4
85605: PUSH
85606: LD_VAR 0 7
85610: ARRAY
85611: PPUSH
85612: LD_VAR 0 14
85616: PUSH
85617: LD_INT 1
85619: ARRAY
85620: PPUSH
85621: CALL_OW 115
// if not HasTask ( group [ i ] ) then
85625: LD_VAR 0 4
85629: PUSH
85630: LD_VAR 0 7
85634: ARRAY
85635: PPUSH
85636: CALL_OW 314
85640: NOT
85641: IFFALSE 85679
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
85643: LD_VAR 0 4
85647: PUSH
85648: LD_VAR 0 7
85652: ARRAY
85653: PPUSH
85654: LD_VAR 0 14
85658: PPUSH
85659: LD_VAR 0 4
85663: PUSH
85664: LD_VAR 0 7
85668: ARRAY
85669: PPUSH
85670: CALL_OW 74
85674: PPUSH
85675: CALL_OW 115
// end ; end ; end ;
85679: GO 81558
85681: POP
85682: POP
// wait ( 0 0$2 ) ;
85683: LD_INT 70
85685: PPUSH
85686: CALL_OW 67
// until not group or group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
85690: LD_VAR 0 4
85694: NOT
85695: PUSH
85696: LD_VAR 0 4
85700: PUSH
85701: EMPTY
85702: EQUAL
85703: OR
85704: PUSH
85705: LD_INT 81
85707: PUSH
85708: LD_VAR 0 35
85712: PUSH
85713: EMPTY
85714: LIST
85715: LIST
85716: PPUSH
85717: CALL_OW 69
85721: NOT
85722: OR
85723: IFFALSE 81543
// end ;
85725: LD_VAR 0 2
85729: RET
// export function BasicDefend ( base , solds ) ; var enemy , e , side , i , hex ; begin
85730: LD_INT 0
85732: PPUSH
85733: PPUSH
85734: PPUSH
85735: PPUSH
85736: PPUSH
85737: PPUSH
// if not base or not mc_bases [ base ] or not solds then
85738: LD_VAR 0 1
85742: NOT
85743: PUSH
85744: LD_EXP 161
85748: PUSH
85749: LD_VAR 0 1
85753: ARRAY
85754: NOT
85755: OR
85756: PUSH
85757: LD_VAR 0 2
85761: NOT
85762: OR
85763: IFFALSE 85767
// exit ;
85765: GO 86321
// side := mc_sides [ base ] ;
85767: LD_ADDR_VAR 0 6
85771: PUSH
85772: LD_EXP 187
85776: PUSH
85777: LD_VAR 0 1
85781: ARRAY
85782: ST_TO_ADDR
// if not side then
85783: LD_VAR 0 6
85787: NOT
85788: IFFALSE 85792
// exit ;
85790: GO 86321
// for i in solds do
85792: LD_ADDR_VAR 0 7
85796: PUSH
85797: LD_VAR 0 2
85801: PUSH
85802: FOR_IN
85803: IFFALSE 85864
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
85805: LD_VAR 0 7
85809: PPUSH
85810: CALL_OW 310
85814: PPUSH
85815: CALL_OW 266
85819: PUSH
85820: LD_INT 32
85822: PUSH
85823: LD_INT 31
85825: PUSH
85826: EMPTY
85827: LIST
85828: LIST
85829: IN
85830: IFFALSE 85850
// solds := solds diff i else
85832: LD_ADDR_VAR 0 2
85836: PUSH
85837: LD_VAR 0 2
85841: PUSH
85842: LD_VAR 0 7
85846: DIFF
85847: ST_TO_ADDR
85848: GO 85862
// SetTag ( i , 18 ) ;
85850: LD_VAR 0 7
85854: PPUSH
85855: LD_INT 18
85857: PPUSH
85858: CALL_OW 109
85862: GO 85802
85864: POP
85865: POP
// if not solds then
85866: LD_VAR 0 2
85870: NOT
85871: IFFALSE 85875
// exit ;
85873: GO 86321
// repeat wait ( 0 0$2 ) ;
85875: LD_INT 70
85877: PPUSH
85878: CALL_OW 67
// enemy := mc_scan [ base ] ;
85882: LD_ADDR_VAR 0 4
85886: PUSH
85887: LD_EXP 184
85891: PUSH
85892: LD_VAR 0 1
85896: ARRAY
85897: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
85898: LD_EXP 161
85902: PUSH
85903: LD_VAR 0 1
85907: ARRAY
85908: NOT
85909: PUSH
85910: LD_EXP 161
85914: PUSH
85915: LD_VAR 0 1
85919: ARRAY
85920: PUSH
85921: EMPTY
85922: EQUAL
85923: OR
85924: IFFALSE 85961
// begin for i in solds do
85926: LD_ADDR_VAR 0 7
85930: PUSH
85931: LD_VAR 0 2
85935: PUSH
85936: FOR_IN
85937: IFFALSE 85950
// ComStop ( i ) ;
85939: LD_VAR 0 7
85943: PPUSH
85944: CALL_OW 141
85948: GO 85936
85950: POP
85951: POP
// solds := [ ] ;
85952: LD_ADDR_VAR 0 2
85956: PUSH
85957: EMPTY
85958: ST_TO_ADDR
// exit ;
85959: GO 86321
// end ; for i in solds do
85961: LD_ADDR_VAR 0 7
85965: PUSH
85966: LD_VAR 0 2
85970: PUSH
85971: FOR_IN
85972: IFFALSE 86293
// begin if IsInUnit ( i ) then
85974: LD_VAR 0 7
85978: PPUSH
85979: CALL_OW 310
85983: IFFALSE 85994
// ComExitBuilding ( i ) ;
85985: LD_VAR 0 7
85989: PPUSH
85990: CALL_OW 122
// if GetLives ( i ) > 500 then
85994: LD_VAR 0 7
85998: PPUSH
85999: CALL_OW 256
86003: PUSH
86004: LD_INT 500
86006: GREATER
86007: IFFALSE 86060
// begin e := NearestUnitToUnit ( enemy , i ) ;
86009: LD_ADDR_VAR 0 5
86013: PUSH
86014: LD_VAR 0 4
86018: PPUSH
86019: LD_VAR 0 7
86023: PPUSH
86024: CALL_OW 74
86028: ST_TO_ADDR
// ComAgressiveMove ( i , GetX ( e ) , GetY ( e ) ) ;
86029: LD_VAR 0 7
86033: PPUSH
86034: LD_VAR 0 5
86038: PPUSH
86039: CALL_OW 250
86043: PPUSH
86044: LD_VAR 0 5
86048: PPUSH
86049: CALL_OW 251
86053: PPUSH
86054: CALL_OW 114
// end else
86058: GO 86291
// if GetDistUnits ( i , NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ) > 10 then
86060: LD_VAR 0 7
86064: PPUSH
86065: LD_EXP 161
86069: PUSH
86070: LD_VAR 0 1
86074: ARRAY
86075: PPUSH
86076: LD_INT 2
86078: PUSH
86079: LD_INT 30
86081: PUSH
86082: LD_INT 0
86084: PUSH
86085: EMPTY
86086: LIST
86087: LIST
86088: PUSH
86089: LD_INT 30
86091: PUSH
86092: LD_INT 1
86094: PUSH
86095: EMPTY
86096: LIST
86097: LIST
86098: PUSH
86099: LD_INT 30
86101: PUSH
86102: LD_INT 6
86104: PUSH
86105: EMPTY
86106: LIST
86107: LIST
86108: PUSH
86109: EMPTY
86110: LIST
86111: LIST
86112: LIST
86113: LIST
86114: PPUSH
86115: CALL_OW 72
86119: PPUSH
86120: LD_VAR 0 7
86124: PPUSH
86125: CALL_OW 74
86129: PPUSH
86130: CALL_OW 296
86134: PUSH
86135: LD_INT 10
86137: GREATER
86138: IFFALSE 86291
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
86140: LD_ADDR_VAR 0 8
86144: PUSH
86145: LD_EXP 161
86149: PUSH
86150: LD_VAR 0 1
86154: ARRAY
86155: PPUSH
86156: LD_INT 2
86158: PUSH
86159: LD_INT 30
86161: PUSH
86162: LD_INT 0
86164: PUSH
86165: EMPTY
86166: LIST
86167: LIST
86168: PUSH
86169: LD_INT 30
86171: PUSH
86172: LD_INT 1
86174: PUSH
86175: EMPTY
86176: LIST
86177: LIST
86178: PUSH
86179: LD_INT 30
86181: PUSH
86182: LD_INT 6
86184: PUSH
86185: EMPTY
86186: LIST
86187: LIST
86188: PUSH
86189: EMPTY
86190: LIST
86191: LIST
86192: LIST
86193: LIST
86194: PPUSH
86195: CALL_OW 72
86199: PPUSH
86200: LD_VAR 0 7
86204: PPUSH
86205: CALL_OW 74
86209: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
86210: LD_VAR 0 7
86214: PPUSH
86215: LD_VAR 0 8
86219: PPUSH
86220: CALL_OW 250
86224: PPUSH
86225: LD_INT 3
86227: PPUSH
86228: LD_INT 5
86230: PPUSH
86231: CALL_OW 272
86235: PPUSH
86236: LD_VAR 0 8
86240: PPUSH
86241: CALL_OW 251
86245: PPUSH
86246: LD_INT 3
86248: PPUSH
86249: LD_INT 5
86251: PPUSH
86252: CALL_OW 273
86256: PPUSH
86257: CALL_OW 111
// SetTag ( i , 0 ) ;
86261: LD_VAR 0 7
86265: PPUSH
86266: LD_INT 0
86268: PPUSH
86269: CALL_OW 109
// solds := solds diff i ;
86273: LD_ADDR_VAR 0 2
86277: PUSH
86278: LD_VAR 0 2
86282: PUSH
86283: LD_VAR 0 7
86287: DIFF
86288: ST_TO_ADDR
// continue ;
86289: GO 85971
// end ; end ;
86291: GO 85971
86293: POP
86294: POP
// until not solds or not enemy ;
86295: LD_VAR 0 2
86299: NOT
86300: PUSH
86301: LD_VAR 0 4
86305: NOT
86306: OR
86307: IFFALSE 85875
// MC_Reset ( base , 18 ) ;
86309: LD_VAR 0 1
86313: PPUSH
86314: LD_INT 18
86316: PPUSH
86317: CALL 92491 0 2
// end ;
86321: LD_VAR 0 3
86325: RET
// export function Defend ( base , defenders ) ; var i , j , x , depot , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend , class , enemy ; begin
86326: LD_INT 0
86328: PPUSH
86329: PPUSH
86330: PPUSH
86331: PPUSH
86332: PPUSH
86333: PPUSH
86334: PPUSH
86335: PPUSH
86336: PPUSH
86337: PPUSH
86338: PPUSH
86339: PPUSH
86340: PPUSH
86341: PPUSH
86342: PPUSH
86343: PPUSH
86344: PPUSH
86345: PPUSH
86346: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
86347: LD_ADDR_VAR 0 12
86351: PUSH
86352: LD_EXP 161
86356: PUSH
86357: LD_VAR 0 1
86361: ARRAY
86362: PPUSH
86363: LD_INT 25
86365: PUSH
86366: LD_INT 3
86368: PUSH
86369: EMPTY
86370: LIST
86371: LIST
86372: PPUSH
86373: CALL_OW 72
86377: ST_TO_ADDR
// if mc_remote_driver [ base ] then
86378: LD_EXP 201
86382: PUSH
86383: LD_VAR 0 1
86387: ARRAY
86388: IFFALSE 86412
// mechs := mechs diff mc_remote_driver [ base ] ;
86390: LD_ADDR_VAR 0 12
86394: PUSH
86395: LD_VAR 0 12
86399: PUSH
86400: LD_EXP 201
86404: PUSH
86405: LD_VAR 0 1
86409: ARRAY
86410: DIFF
86411: ST_TO_ADDR
// for i in mechs do
86412: LD_ADDR_VAR 0 4
86416: PUSH
86417: LD_VAR 0 12
86421: PUSH
86422: FOR_IN
86423: IFFALSE 86458
// if GetTag ( i ) > 0 then
86425: LD_VAR 0 4
86429: PPUSH
86430: CALL_OW 110
86434: PUSH
86435: LD_INT 0
86437: GREATER
86438: IFFALSE 86456
// mechs := mechs diff i ;
86440: LD_ADDR_VAR 0 12
86444: PUSH
86445: LD_VAR 0 12
86449: PUSH
86450: LD_VAR 0 4
86454: DIFF
86455: ST_TO_ADDR
86456: GO 86422
86458: POP
86459: POP
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
86460: LD_ADDR_VAR 0 8
86464: PUSH
86465: LD_EXP 161
86469: PUSH
86470: LD_VAR 0 1
86474: ARRAY
86475: PPUSH
86476: LD_INT 2
86478: PUSH
86479: LD_INT 25
86481: PUSH
86482: LD_INT 1
86484: PUSH
86485: EMPTY
86486: LIST
86487: LIST
86488: PUSH
86489: LD_INT 25
86491: PUSH
86492: LD_INT 5
86494: PUSH
86495: EMPTY
86496: LIST
86497: LIST
86498: PUSH
86499: LD_INT 25
86501: PUSH
86502: LD_INT 8
86504: PUSH
86505: EMPTY
86506: LIST
86507: LIST
86508: PUSH
86509: LD_INT 25
86511: PUSH
86512: LD_INT 9
86514: PUSH
86515: EMPTY
86516: LIST
86517: LIST
86518: PUSH
86519: EMPTY
86520: LIST
86521: LIST
86522: LIST
86523: LIST
86524: LIST
86525: PPUSH
86526: CALL_OW 72
86530: ST_TO_ADDR
// if not defenders and not solds then
86531: LD_VAR 0 2
86535: NOT
86536: PUSH
86537: LD_VAR 0 8
86541: NOT
86542: AND
86543: IFFALSE 86547
// exit ;
86545: GO 88317
// depot_under_attack := false ;
86547: LD_ADDR_VAR 0 16
86551: PUSH
86552: LD_INT 0
86554: ST_TO_ADDR
// sold_defenders := [ ] ;
86555: LD_ADDR_VAR 0 17
86559: PUSH
86560: EMPTY
86561: ST_TO_ADDR
// if mechs then
86562: LD_VAR 0 12
86566: IFFALSE 86719
// for i in UnitFilter ( defenders , [ f_type , unit_vehicle ] ) do
86568: LD_ADDR_VAR 0 4
86572: PUSH
86573: LD_VAR 0 2
86577: PPUSH
86578: LD_INT 21
86580: PUSH
86581: LD_INT 2
86583: PUSH
86584: EMPTY
86585: LIST
86586: LIST
86587: PPUSH
86588: CALL_OW 72
86592: PUSH
86593: FOR_IN
86594: IFFALSE 86717
// begin if GetTag ( i ) <> 20 then
86596: LD_VAR 0 4
86600: PPUSH
86601: CALL_OW 110
86605: PUSH
86606: LD_INT 20
86608: NONEQUAL
86609: IFFALSE 86623
// SetTag ( i , 20 ) ;
86611: LD_VAR 0 4
86615: PPUSH
86616: LD_INT 20
86618: PPUSH
86619: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) then
86623: LD_VAR 0 4
86627: PPUSH
86628: CALL_OW 263
86632: PUSH
86633: LD_INT 1
86635: EQUAL
86636: PUSH
86637: LD_VAR 0 4
86641: PPUSH
86642: CALL_OW 311
86646: NOT
86647: AND
86648: IFFALSE 86715
// begin un := mechs [ 1 ] ;
86650: LD_ADDR_VAR 0 10
86654: PUSH
86655: LD_VAR 0 12
86659: PUSH
86660: LD_INT 1
86662: ARRAY
86663: ST_TO_ADDR
// ComExit ( un ) ;
86664: LD_VAR 0 10
86668: PPUSH
86669: CALL 56943 0 1
// AddComEnterUnit ( un , i ) ;
86673: LD_VAR 0 10
86677: PPUSH
86678: LD_VAR 0 4
86682: PPUSH
86683: CALL_OW 180
// SetTag ( un , 19 ) ;
86687: LD_VAR 0 10
86691: PPUSH
86692: LD_INT 19
86694: PPUSH
86695: CALL_OW 109
// mechs := mechs diff un ;
86699: LD_ADDR_VAR 0 12
86703: PUSH
86704: LD_VAR 0 12
86708: PUSH
86709: LD_VAR 0 10
86713: DIFF
86714: ST_TO_ADDR
// end ; end ;
86715: GO 86593
86717: POP
86718: POP
// if solds then
86719: LD_VAR 0 8
86723: IFFALSE 86782
// for i in solds do
86725: LD_ADDR_VAR 0 4
86729: PUSH
86730: LD_VAR 0 8
86734: PUSH
86735: FOR_IN
86736: IFFALSE 86780
// if not GetTag ( i ) then
86738: LD_VAR 0 4
86742: PPUSH
86743: CALL_OW 110
86747: NOT
86748: IFFALSE 86778
// begin defenders := defenders union i ;
86750: LD_ADDR_VAR 0 2
86754: PUSH
86755: LD_VAR 0 2
86759: PUSH
86760: LD_VAR 0 4
86764: UNION
86765: ST_TO_ADDR
// SetTag ( i , 18 ) ;
86766: LD_VAR 0 4
86770: PPUSH
86771: LD_INT 18
86773: PPUSH
86774: CALL_OW 109
// end ;
86778: GO 86735
86780: POP
86781: POP
// repeat wait ( 0 0$2 ) ;
86782: LD_INT 70
86784: PPUSH
86785: CALL_OW 67
// enemy := mc_scan [ base ] ;
86789: LD_ADDR_VAR 0 21
86793: PUSH
86794: LD_EXP 184
86798: PUSH
86799: LD_VAR 0 1
86803: ARRAY
86804: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
86805: LD_EXP 161
86809: PUSH
86810: LD_VAR 0 1
86814: ARRAY
86815: NOT
86816: PUSH
86817: LD_EXP 161
86821: PUSH
86822: LD_VAR 0 1
86826: ARRAY
86827: PUSH
86828: EMPTY
86829: EQUAL
86830: OR
86831: IFFALSE 86868
// begin for i in defenders do
86833: LD_ADDR_VAR 0 4
86837: PUSH
86838: LD_VAR 0 2
86842: PUSH
86843: FOR_IN
86844: IFFALSE 86857
// ComStop ( i ) ;
86846: LD_VAR 0 4
86850: PPUSH
86851: CALL_OW 141
86855: GO 86843
86857: POP
86858: POP
// defenders := [ ] ;
86859: LD_ADDR_VAR 0 2
86863: PUSH
86864: EMPTY
86865: ST_TO_ADDR
// exit ;
86866: GO 88317
// end ; for i in defenders do
86868: LD_ADDR_VAR 0 4
86872: PUSH
86873: LD_VAR 0 2
86877: PUSH
86878: FOR_IN
86879: IFFALSE 87777
// begin e := NearestUnitToUnit ( enemy , i ) ;
86881: LD_ADDR_VAR 0 13
86885: PUSH
86886: LD_VAR 0 21
86890: PPUSH
86891: LD_VAR 0 4
86895: PPUSH
86896: CALL_OW 74
86900: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
86901: LD_ADDR_VAR 0 7
86905: PUSH
86906: LD_EXP 161
86910: PUSH
86911: LD_VAR 0 1
86915: ARRAY
86916: PPUSH
86917: LD_INT 2
86919: PUSH
86920: LD_INT 30
86922: PUSH
86923: LD_INT 0
86925: PUSH
86926: EMPTY
86927: LIST
86928: LIST
86929: PUSH
86930: LD_INT 30
86932: PUSH
86933: LD_INT 1
86935: PUSH
86936: EMPTY
86937: LIST
86938: LIST
86939: PUSH
86940: EMPTY
86941: LIST
86942: LIST
86943: LIST
86944: PPUSH
86945: CALL_OW 72
86949: ST_TO_ADDR
// depot_under_attack := ( not depot or UnitFilter ( depot , [ f_not , [ f_lives , 600 ] ] ) ) ;
86950: LD_ADDR_VAR 0 16
86954: PUSH
86955: LD_VAR 0 7
86959: NOT
86960: PUSH
86961: LD_VAR 0 7
86965: PPUSH
86966: LD_INT 3
86968: PUSH
86969: LD_INT 24
86971: PUSH
86972: LD_INT 600
86974: PUSH
86975: EMPTY
86976: LIST
86977: LIST
86978: PUSH
86979: EMPTY
86980: LIST
86981: LIST
86982: PPUSH
86983: CALL_OW 72
86987: OR
86988: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
86989: LD_VAR 0 4
86993: PPUSH
86994: CALL_OW 247
86998: PUSH
86999: LD_INT 2
87001: DOUBLE
87002: EQUAL
87003: IFTRUE 87007
87005: GO 87403
87007: POP
// begin if GetLives ( i ) = 1000 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
87008: LD_VAR 0 4
87012: PPUSH
87013: CALL_OW 256
87017: PUSH
87018: LD_INT 1000
87020: EQUAL
87021: PUSH
87022: LD_VAR 0 4
87026: PPUSH
87027: LD_VAR 0 13
87031: PPUSH
87032: CALL_OW 296
87036: PUSH
87037: LD_INT 40
87039: LESS
87040: PUSH
87041: LD_VAR 0 13
87045: PPUSH
87046: LD_EXP 186
87050: PUSH
87051: LD_VAR 0 1
87055: ARRAY
87056: PPUSH
87057: CALL_OW 308
87061: OR
87062: AND
87063: IFFALSE 87185
// begin if GetEngine ( i ) = engine_combustion and GetFuel ( i ) < 30 and depot then
87065: LD_VAR 0 4
87069: PPUSH
87070: CALL_OW 262
87074: PUSH
87075: LD_INT 1
87077: EQUAL
87078: PUSH
87079: LD_VAR 0 4
87083: PPUSH
87084: CALL_OW 261
87088: PUSH
87089: LD_INT 30
87091: LESS
87092: AND
87093: PUSH
87094: LD_VAR 0 7
87098: AND
87099: IFFALSE 87169
// begin ComMoveUnit ( i , NearestUnitToUnit ( depot , i ) ) ;
87101: LD_VAR 0 4
87105: PPUSH
87106: LD_VAR 0 7
87110: PPUSH
87111: LD_VAR 0 4
87115: PPUSH
87116: CALL_OW 74
87120: PPUSH
87121: CALL_OW 112
// if GetDistUnits ( i , NearestUnitToUnit ( depot , i ) ) < 6 then
87125: LD_VAR 0 4
87129: PPUSH
87130: LD_VAR 0 7
87134: PPUSH
87135: LD_VAR 0 4
87139: PPUSH
87140: CALL_OW 74
87144: PPUSH
87145: CALL_OW 296
87149: PUSH
87150: LD_INT 6
87152: LESS
87153: IFFALSE 87167
// SetFuel ( i , 100 ) ;
87155: LD_VAR 0 4
87159: PPUSH
87160: LD_INT 100
87162: PPUSH
87163: CALL_OW 240
// end else
87167: GO 87183
// ComAttackUnit ( i , e ) ;
87169: LD_VAR 0 4
87173: PPUSH
87174: LD_VAR 0 13
87178: PPUSH
87179: CALL_OW 115
// end else
87183: GO 87286
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
87185: LD_VAR 0 13
87189: PPUSH
87190: LD_EXP 186
87194: PUSH
87195: LD_VAR 0 1
87199: ARRAY
87200: PPUSH
87201: CALL_OW 308
87205: NOT
87206: PUSH
87207: LD_VAR 0 4
87211: PPUSH
87212: LD_VAR 0 13
87216: PPUSH
87217: CALL_OW 296
87221: PUSH
87222: LD_INT 40
87224: GREATEREQUAL
87225: AND
87226: PUSH
87227: LD_VAR 0 4
87231: PPUSH
87232: CALL_OW 256
87236: PUSH
87237: LD_INT 650
87239: LESSEQUAL
87240: OR
87241: PUSH
87242: LD_VAR 0 4
87246: PPUSH
87247: LD_EXP 185
87251: PUSH
87252: LD_VAR 0 1
87256: ARRAY
87257: PPUSH
87258: CALL_OW 308
87262: NOT
87263: AND
87264: IFFALSE 87286
// ComMoveToArea ( i , mc_parking [ base ] ) ;
87266: LD_VAR 0 4
87270: PPUSH
87271: LD_EXP 185
87275: PUSH
87276: LD_VAR 0 1
87280: ARRAY
87281: PPUSH
87282: CALL_OW 113
// if GetLives ( i ) < 1000 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
87286: LD_VAR 0 4
87290: PPUSH
87291: CALL_OW 256
87295: PUSH
87296: LD_INT 1000
87298: LESS
87299: PUSH
87300: LD_VAR 0 4
87304: PPUSH
87305: CALL_OW 263
87309: PUSH
87310: LD_INT 1
87312: EQUAL
87313: AND
87314: PUSH
87315: LD_VAR 0 4
87319: PPUSH
87320: CALL_OW 311
87324: AND
87325: PUSH
87326: LD_VAR 0 4
87330: PPUSH
87331: LD_EXP 185
87335: PUSH
87336: LD_VAR 0 1
87340: ARRAY
87341: PPUSH
87342: CALL_OW 308
87346: AND
87347: IFFALSE 87401
// begin mech := IsDrivenBy ( i ) ;
87349: LD_ADDR_VAR 0 9
87353: PUSH
87354: LD_VAR 0 4
87358: PPUSH
87359: CALL_OW 311
87363: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
87364: LD_VAR 0 9
87368: PPUSH
87369: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
87373: LD_VAR 0 9
87377: PPUSH
87378: LD_VAR 0 4
87382: PPUSH
87383: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
87387: LD_VAR 0 9
87391: PPUSH
87392: LD_VAR 0 4
87396: PPUSH
87397: CALL_OW 180
// end ; end ; unit_human :
87401: GO 87748
87403: LD_INT 1
87405: DOUBLE
87406: EQUAL
87407: IFTRUE 87411
87409: GO 87747
87411: POP
// begin b := IsInUnit ( i ) ;
87412: LD_ADDR_VAR 0 18
87416: PUSH
87417: LD_VAR 0 4
87421: PPUSH
87422: CALL_OW 310
87426: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
87427: LD_ADDR_VAR 0 19
87431: PUSH
87432: LD_VAR 0 18
87436: NOT
87437: PUSH
87438: LD_VAR 0 18
87442: PPUSH
87443: CALL_OW 266
87447: PUSH
87448: LD_INT 32
87450: PUSH
87451: LD_INT 31
87453: PUSH
87454: EMPTY
87455: LIST
87456: LIST
87457: IN
87458: OR
87459: ST_TO_ADDR
// if GetBType ( b ) = b_barracks and GetClass ( i ) in [ 1 , 2 , 3 , 4 ] then
87460: LD_VAR 0 18
87464: PPUSH
87465: CALL_OW 266
87469: PUSH
87470: LD_INT 5
87472: EQUAL
87473: PUSH
87474: LD_VAR 0 4
87478: PPUSH
87479: CALL_OW 257
87483: PUSH
87484: LD_INT 1
87486: PUSH
87487: LD_INT 2
87489: PUSH
87490: LD_INT 3
87492: PUSH
87493: LD_INT 4
87495: PUSH
87496: EMPTY
87497: LIST
87498: LIST
87499: LIST
87500: LIST
87501: IN
87502: AND
87503: IFFALSE 87540
// begin class := AllowSpecClass ( i ) ;
87505: LD_ADDR_VAR 0 20
87509: PUSH
87510: LD_VAR 0 4
87514: PPUSH
87515: CALL 21010 0 1
87519: ST_TO_ADDR
// if class then
87520: LD_VAR 0 20
87524: IFFALSE 87540
// ComChangeProfession ( i , class ) ;
87526: LD_VAR 0 4
87530: PPUSH
87531: LD_VAR 0 20
87535: PPUSH
87536: CALL_OW 123
// end ; if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
87540: LD_VAR 0 16
87544: PUSH
87545: LD_VAR 0 2
87549: PPUSH
87550: LD_INT 21
87552: PUSH
87553: LD_INT 2
87555: PUSH
87556: EMPTY
87557: LIST
87558: LIST
87559: PPUSH
87560: CALL_OW 72
87564: PUSH
87565: LD_INT 1
87567: LESSEQUAL
87568: OR
87569: PUSH
87570: LD_VAR 0 19
87574: AND
87575: PUSH
87576: LD_VAR 0 4
87580: PUSH
87581: LD_VAR 0 17
87585: IN
87586: NOT
87587: AND
87588: IFFALSE 87681
// begin if b then
87590: LD_VAR 0 18
87594: IFFALSE 87643
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
87596: LD_VAR 0 18
87600: PPUSH
87601: LD_VAR 0 21
87605: PPUSH
87606: LD_VAR 0 18
87610: PPUSH
87611: CALL_OW 74
87615: PPUSH
87616: CALL_OW 296
87620: PUSH
87621: LD_INT 10
87623: LESS
87624: PUSH
87625: LD_VAR 0 18
87629: PPUSH
87630: CALL_OW 461
87634: PUSH
87635: LD_INT 7
87637: NONEQUAL
87638: AND
87639: IFFALSE 87643
// continue ;
87641: GO 86878
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
87643: LD_ADDR_VAR 0 17
87647: PUSH
87648: LD_VAR 0 17
87652: PPUSH
87653: LD_VAR 0 17
87657: PUSH
87658: LD_INT 1
87660: PLUS
87661: PPUSH
87662: LD_VAR 0 4
87666: PPUSH
87667: CALL_OW 1
87671: ST_TO_ADDR
// ComExitBuilding ( i ) ;
87672: LD_VAR 0 4
87676: PPUSH
87677: CALL_OW 122
// end ; if sold_defenders then
87681: LD_VAR 0 17
87685: IFFALSE 87745
// if i in sold_defenders then
87687: LD_VAR 0 4
87691: PUSH
87692: LD_VAR 0 17
87696: IN
87697: IFFALSE 87745
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
87699: LD_VAR 0 4
87703: PPUSH
87704: CALL_OW 314
87708: NOT
87709: PUSH
87710: LD_VAR 0 4
87714: PPUSH
87715: LD_VAR 0 13
87719: PPUSH
87720: CALL_OW 296
87724: PUSH
87725: LD_INT 30
87727: LESS
87728: AND
87729: IFFALSE 87745
// ComAttackUnit ( i , e ) ;
87731: LD_VAR 0 4
87735: PPUSH
87736: LD_VAR 0 13
87740: PPUSH
87741: CALL_OW 115
// end ; end ; end ;
87745: GO 87748
87747: POP
// if IsDead ( i ) then
87748: LD_VAR 0 4
87752: PPUSH
87753: CALL_OW 301
87757: IFFALSE 87775
// defenders := defenders diff i ;
87759: LD_ADDR_VAR 0 2
87763: PUSH
87764: LD_VAR 0 2
87768: PUSH
87769: LD_VAR 0 4
87773: DIFF
87774: ST_TO_ADDR
// end ;
87775: GO 86878
87777: POP
87778: POP
// until not enemy or not defenders or not mc_bases [ base ] ;
87779: LD_VAR 0 21
87783: NOT
87784: PUSH
87785: LD_VAR 0 2
87789: NOT
87790: OR
87791: PUSH
87792: LD_EXP 161
87796: PUSH
87797: LD_VAR 0 1
87801: ARRAY
87802: NOT
87803: OR
87804: IFFALSE 86782
// MC_Reset ( base , 18 ) ;
87806: LD_VAR 0 1
87810: PPUSH
87811: LD_INT 18
87813: PPUSH
87814: CALL 92491 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
87818: LD_ADDR_VAR 0 2
87822: PUSH
87823: LD_VAR 0 2
87827: PUSH
87828: LD_VAR 0 2
87832: PPUSH
87833: LD_INT 2
87835: PUSH
87836: LD_INT 25
87838: PUSH
87839: LD_INT 1
87841: PUSH
87842: EMPTY
87843: LIST
87844: LIST
87845: PUSH
87846: LD_INT 25
87848: PUSH
87849: LD_INT 5
87851: PUSH
87852: EMPTY
87853: LIST
87854: LIST
87855: PUSH
87856: LD_INT 25
87858: PUSH
87859: LD_INT 8
87861: PUSH
87862: EMPTY
87863: LIST
87864: LIST
87865: PUSH
87866: LD_INT 25
87868: PUSH
87869: LD_INT 9
87871: PUSH
87872: EMPTY
87873: LIST
87874: LIST
87875: PUSH
87876: EMPTY
87877: LIST
87878: LIST
87879: LIST
87880: LIST
87881: LIST
87882: PPUSH
87883: CALL_OW 72
87887: DIFF
87888: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
87889: LD_VAR 0 21
87893: NOT
87894: PUSH
87895: LD_VAR 0 2
87899: PPUSH
87900: LD_INT 21
87902: PUSH
87903: LD_INT 2
87905: PUSH
87906: EMPTY
87907: LIST
87908: LIST
87909: PPUSH
87910: CALL_OW 72
87914: AND
87915: IFFALSE 88253
// begin tmp := FilterByTag ( defenders , 19 ) ;
87917: LD_ADDR_VAR 0 11
87921: PUSH
87922: LD_VAR 0 2
87926: PPUSH
87927: LD_INT 19
87929: PPUSH
87930: CALL 54127 0 2
87934: ST_TO_ADDR
// if tmp then
87935: LD_VAR 0 11
87939: IFFALSE 88009
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
87941: LD_ADDR_VAR 0 11
87945: PUSH
87946: LD_VAR 0 11
87950: PPUSH
87951: LD_INT 25
87953: PUSH
87954: LD_INT 3
87956: PUSH
87957: EMPTY
87958: LIST
87959: LIST
87960: PPUSH
87961: CALL_OW 72
87965: ST_TO_ADDR
// if tmp then
87966: LD_VAR 0 11
87970: IFFALSE 88009
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
87972: LD_ADDR_EXP 173
87976: PUSH
87977: LD_EXP 173
87981: PPUSH
87982: LD_VAR 0 1
87986: PPUSH
87987: LD_EXP 173
87991: PUSH
87992: LD_VAR 0 1
87996: ARRAY
87997: PUSH
87998: LD_VAR 0 11
88002: UNION
88003: PPUSH
88004: CALL_OW 1
88008: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
88009: LD_VAR 0 1
88013: PPUSH
88014: LD_INT 19
88016: PPUSH
88017: CALL 92491 0 2
// repeat wait ( 0 0$1 ) ;
88021: LD_INT 35
88023: PPUSH
88024: CALL_OW 67
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
88028: LD_EXP 161
88032: PUSH
88033: LD_VAR 0 1
88037: ARRAY
88038: NOT
88039: PUSH
88040: LD_EXP 161
88044: PUSH
88045: LD_VAR 0 1
88049: ARRAY
88050: PUSH
88051: EMPTY
88052: EQUAL
88053: OR
88054: IFFALSE 88091
// begin for i in defenders do
88056: LD_ADDR_VAR 0 4
88060: PUSH
88061: LD_VAR 0 2
88065: PUSH
88066: FOR_IN
88067: IFFALSE 88080
// ComStop ( i ) ;
88069: LD_VAR 0 4
88073: PPUSH
88074: CALL_OW 141
88078: GO 88066
88080: POP
88081: POP
// defenders := [ ] ;
88082: LD_ADDR_VAR 0 2
88086: PUSH
88087: EMPTY
88088: ST_TO_ADDR
// exit ;
88089: GO 88317
// end ; for i in defenders do
88091: LD_ADDR_VAR 0 4
88095: PUSH
88096: LD_VAR 0 2
88100: PUSH
88101: FOR_IN
88102: IFFALSE 88191
// begin if not IsInArea ( i , mc_parking [ base ] ) then
88104: LD_VAR 0 4
88108: PPUSH
88109: LD_EXP 185
88113: PUSH
88114: LD_VAR 0 1
88118: ARRAY
88119: PPUSH
88120: CALL_OW 308
88124: NOT
88125: IFFALSE 88149
// ComMoveToArea ( i , mc_parking [ base ] ) else
88127: LD_VAR 0 4
88131: PPUSH
88132: LD_EXP 185
88136: PUSH
88137: LD_VAR 0 1
88141: ARRAY
88142: PPUSH
88143: CALL_OW 113
88147: GO 88189
// if GetControl ( i ) = control_manual then
88149: LD_VAR 0 4
88153: PPUSH
88154: CALL_OW 263
88158: PUSH
88159: LD_INT 1
88161: EQUAL
88162: IFFALSE 88189
// if IsDrivenBy ( i ) then
88164: LD_VAR 0 4
88168: PPUSH
88169: CALL_OW 311
88173: IFFALSE 88189
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
88175: LD_VAR 0 4
88179: PPUSH
88180: CALL_OW 311
88184: PPUSH
88185: CALL_OW 121
// end ;
88189: GO 88101
88191: POP
88192: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] or not mc_bases [ base ] ;
88193: LD_VAR 0 2
88197: PPUSH
88198: LD_INT 95
88200: PUSH
88201: LD_EXP 185
88205: PUSH
88206: LD_VAR 0 1
88210: ARRAY
88211: PUSH
88212: EMPTY
88213: LIST
88214: LIST
88215: PPUSH
88216: CALL_OW 72
88220: PUSH
88221: LD_VAR 0 2
88225: EQUAL
88226: PUSH
88227: LD_EXP 184
88231: PUSH
88232: LD_VAR 0 1
88236: ARRAY
88237: OR
88238: PUSH
88239: LD_EXP 161
88243: PUSH
88244: LD_VAR 0 1
88248: ARRAY
88249: NOT
88250: OR
88251: IFFALSE 88021
// end ; mc_defender := Replace ( mc_defender , base , UnitFilter ( defenders , [ f_type , unit_vehicle ] ) ) ;
88253: LD_ADDR_EXP 183
88257: PUSH
88258: LD_EXP 183
88262: PPUSH
88263: LD_VAR 0 1
88267: PPUSH
88268: LD_VAR 0 2
88272: PPUSH
88273: LD_INT 21
88275: PUSH
88276: LD_INT 2
88278: PUSH
88279: EMPTY
88280: LIST
88281: LIST
88282: PPUSH
88283: CALL_OW 72
88287: PPUSH
88288: CALL_OW 1
88292: ST_TO_ADDR
// MC_Reset ( base , 19 ) ;
88293: LD_VAR 0 1
88297: PPUSH
88298: LD_INT 19
88300: PPUSH
88301: CALL 92491 0 2
// MC_Reset ( base , 20 ) ;
88305: LD_VAR 0 1
88309: PPUSH
88310: LD_INT 20
88312: PPUSH
88313: CALL 92491 0 2
// end ; end_of_file
88317: LD_VAR 0 3
88321: RET
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use , mc_is_defending ; export mc_block_vehicle_constructed_thread ; export function InitMacro ; var i ; begin
88322: LD_INT 0
88324: PPUSH
88325: PPUSH
// skirmish := false ;
88326: LD_ADDR_EXP 159
88330: PUSH
88331: LD_INT 0
88333: ST_TO_ADDR
// debug_mc := false ;
88334: LD_ADDR_EXP 160
88338: PUSH
88339: LD_INT 0
88341: ST_TO_ADDR
// mc_bases := [ ] ;
88342: LD_ADDR_EXP 161
88346: PUSH
88347: EMPTY
88348: ST_TO_ADDR
// mc_sides := [ ] ;
88349: LD_ADDR_EXP 187
88353: PUSH
88354: EMPTY
88355: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
88356: LD_ADDR_EXP 162
88360: PUSH
88361: EMPTY
88362: ST_TO_ADDR
// mc_building_repairs := [ ] ;
88363: LD_ADDR_EXP 163
88367: PUSH
88368: EMPTY
88369: ST_TO_ADDR
// mc_need_heal := [ ] ;
88370: LD_ADDR_EXP 164
88374: PUSH
88375: EMPTY
88376: ST_TO_ADDR
// mc_healers := [ ] ;
88377: LD_ADDR_EXP 165
88381: PUSH
88382: EMPTY
88383: ST_TO_ADDR
// mc_build_list := [ ] ;
88384: LD_ADDR_EXP 166
88388: PUSH
88389: EMPTY
88390: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
88391: LD_ADDR_EXP 193
88395: PUSH
88396: EMPTY
88397: ST_TO_ADDR
// mc_builders := [ ] ;
88398: LD_ADDR_EXP 167
88402: PUSH
88403: EMPTY
88404: ST_TO_ADDR
// mc_construct_list := [ ] ;
88405: LD_ADDR_EXP 168
88409: PUSH
88410: EMPTY
88411: ST_TO_ADDR
// mc_turret_list := [ ] ;
88412: LD_ADDR_EXP 169
88416: PUSH
88417: EMPTY
88418: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
88419: LD_ADDR_EXP 170
88423: PUSH
88424: EMPTY
88425: ST_TO_ADDR
// mc_miners := [ ] ;
88426: LD_ADDR_EXP 175
88430: PUSH
88431: EMPTY
88432: ST_TO_ADDR
// mc_mines := [ ] ;
88433: LD_ADDR_EXP 174
88437: PUSH
88438: EMPTY
88439: ST_TO_ADDR
// mc_minefields := [ ] ;
88440: LD_ADDR_EXP 176
88444: PUSH
88445: EMPTY
88446: ST_TO_ADDR
// mc_crates := [ ] ;
88447: LD_ADDR_EXP 177
88451: PUSH
88452: EMPTY
88453: ST_TO_ADDR
// mc_crates_collector := [ ] ;
88454: LD_ADDR_EXP 178
88458: PUSH
88459: EMPTY
88460: ST_TO_ADDR
// mc_crates_area := [ ] ;
88461: LD_ADDR_EXP 179
88465: PUSH
88466: EMPTY
88467: ST_TO_ADDR
// mc_vehicles := [ ] ;
88468: LD_ADDR_EXP 180
88472: PUSH
88473: EMPTY
88474: ST_TO_ADDR
// mc_attack := [ ] ;
88475: LD_ADDR_EXP 181
88479: PUSH
88480: EMPTY
88481: ST_TO_ADDR
// mc_produce := [ ] ;
88482: LD_ADDR_EXP 182
88486: PUSH
88487: EMPTY
88488: ST_TO_ADDR
// mc_defender := [ ] ;
88489: LD_ADDR_EXP 183
88493: PUSH
88494: EMPTY
88495: ST_TO_ADDR
// mc_parking := [ ] ;
88496: LD_ADDR_EXP 185
88500: PUSH
88501: EMPTY
88502: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
88503: LD_ADDR_EXP 171
88507: PUSH
88508: EMPTY
88509: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
88510: LD_ADDR_EXP 173
88514: PUSH
88515: EMPTY
88516: ST_TO_ADDR
// mc_scan := [ ] ;
88517: LD_ADDR_EXP 184
88521: PUSH
88522: EMPTY
88523: ST_TO_ADDR
// mc_scan_area := [ ] ;
88524: LD_ADDR_EXP 186
88528: PUSH
88529: EMPTY
88530: ST_TO_ADDR
// mc_tech := [ ] ;
88531: LD_ADDR_EXP 188
88535: PUSH
88536: EMPTY
88537: ST_TO_ADDR
// mc_class := [ ] ;
88538: LD_ADDR_EXP 202
88542: PUSH
88543: EMPTY
88544: ST_TO_ADDR
// mc_class_case_use := [ ] ;
88545: LD_ADDR_EXP 203
88549: PUSH
88550: EMPTY
88551: ST_TO_ADDR
// mc_is_defending := [ ] ;
88552: LD_ADDR_EXP 204
88556: PUSH
88557: EMPTY
88558: ST_TO_ADDR
// mc_lab_upgrade := [ ] ;
88559: LD_ADDR_EXP 195
88563: PUSH
88564: EMPTY
88565: ST_TO_ADDR
// mc_block_vehicle_constructed_thread := false ;
88566: LD_ADDR_EXP 205
88570: PUSH
88571: LD_INT 0
88573: ST_TO_ADDR
// end ;
88574: LD_VAR 0 1
88578: RET
// export function MC_Kill ( base ) ; begin
88579: LD_INT 0
88581: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
88582: LD_ADDR_EXP 161
88586: PUSH
88587: LD_EXP 161
88591: PPUSH
88592: LD_VAR 0 1
88596: PPUSH
88597: EMPTY
88598: PPUSH
88599: CALL_OW 1
88603: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
88604: LD_ADDR_EXP 162
88608: PUSH
88609: LD_EXP 162
88613: PPUSH
88614: LD_VAR 0 1
88618: PPUSH
88619: EMPTY
88620: PPUSH
88621: CALL_OW 1
88625: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
88626: LD_ADDR_EXP 163
88630: PUSH
88631: LD_EXP 163
88635: PPUSH
88636: LD_VAR 0 1
88640: PPUSH
88641: EMPTY
88642: PPUSH
88643: CALL_OW 1
88647: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
88648: LD_ADDR_EXP 164
88652: PUSH
88653: LD_EXP 164
88657: PPUSH
88658: LD_VAR 0 1
88662: PPUSH
88663: EMPTY
88664: PPUSH
88665: CALL_OW 1
88669: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
88670: LD_ADDR_EXP 165
88674: PUSH
88675: LD_EXP 165
88679: PPUSH
88680: LD_VAR 0 1
88684: PPUSH
88685: EMPTY
88686: PPUSH
88687: CALL_OW 1
88691: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
88692: LD_ADDR_EXP 166
88696: PUSH
88697: LD_EXP 166
88701: PPUSH
88702: LD_VAR 0 1
88706: PPUSH
88707: EMPTY
88708: PPUSH
88709: CALL_OW 1
88713: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
88714: LD_ADDR_EXP 167
88718: PUSH
88719: LD_EXP 167
88723: PPUSH
88724: LD_VAR 0 1
88728: PPUSH
88729: EMPTY
88730: PPUSH
88731: CALL_OW 1
88735: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
88736: LD_ADDR_EXP 168
88740: PUSH
88741: LD_EXP 168
88745: PPUSH
88746: LD_VAR 0 1
88750: PPUSH
88751: EMPTY
88752: PPUSH
88753: CALL_OW 1
88757: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
88758: LD_ADDR_EXP 169
88762: PUSH
88763: LD_EXP 169
88767: PPUSH
88768: LD_VAR 0 1
88772: PPUSH
88773: EMPTY
88774: PPUSH
88775: CALL_OW 1
88779: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
88780: LD_ADDR_EXP 170
88784: PUSH
88785: LD_EXP 170
88789: PPUSH
88790: LD_VAR 0 1
88794: PPUSH
88795: EMPTY
88796: PPUSH
88797: CALL_OW 1
88801: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
88802: LD_ADDR_EXP 171
88806: PUSH
88807: LD_EXP 171
88811: PPUSH
88812: LD_VAR 0 1
88816: PPUSH
88817: EMPTY
88818: PPUSH
88819: CALL_OW 1
88823: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
88824: LD_ADDR_EXP 172
88828: PUSH
88829: LD_EXP 172
88833: PPUSH
88834: LD_VAR 0 1
88838: PPUSH
88839: LD_INT 0
88841: PPUSH
88842: CALL_OW 1
88846: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
88847: LD_ADDR_EXP 173
88851: PUSH
88852: LD_EXP 173
88856: PPUSH
88857: LD_VAR 0 1
88861: PPUSH
88862: EMPTY
88863: PPUSH
88864: CALL_OW 1
88868: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
88869: LD_ADDR_EXP 174
88873: PUSH
88874: LD_EXP 174
88878: PPUSH
88879: LD_VAR 0 1
88883: PPUSH
88884: EMPTY
88885: PPUSH
88886: CALL_OW 1
88890: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
88891: LD_ADDR_EXP 175
88895: PUSH
88896: LD_EXP 175
88900: PPUSH
88901: LD_VAR 0 1
88905: PPUSH
88906: EMPTY
88907: PPUSH
88908: CALL_OW 1
88912: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
88913: LD_ADDR_EXP 176
88917: PUSH
88918: LD_EXP 176
88922: PPUSH
88923: LD_VAR 0 1
88927: PPUSH
88928: EMPTY
88929: PPUSH
88930: CALL_OW 1
88934: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
88935: LD_ADDR_EXP 177
88939: PUSH
88940: LD_EXP 177
88944: PPUSH
88945: LD_VAR 0 1
88949: PPUSH
88950: EMPTY
88951: PPUSH
88952: CALL_OW 1
88956: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
88957: LD_ADDR_EXP 178
88961: PUSH
88962: LD_EXP 178
88966: PPUSH
88967: LD_VAR 0 1
88971: PPUSH
88972: EMPTY
88973: PPUSH
88974: CALL_OW 1
88978: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
88979: LD_ADDR_EXP 179
88983: PUSH
88984: LD_EXP 179
88988: PPUSH
88989: LD_VAR 0 1
88993: PPUSH
88994: EMPTY
88995: PPUSH
88996: CALL_OW 1
89000: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
89001: LD_ADDR_EXP 180
89005: PUSH
89006: LD_EXP 180
89010: PPUSH
89011: LD_VAR 0 1
89015: PPUSH
89016: EMPTY
89017: PPUSH
89018: CALL_OW 1
89022: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
89023: LD_ADDR_EXP 181
89027: PUSH
89028: LD_EXP 181
89032: PPUSH
89033: LD_VAR 0 1
89037: PPUSH
89038: EMPTY
89039: PPUSH
89040: CALL_OW 1
89044: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
89045: LD_ADDR_EXP 182
89049: PUSH
89050: LD_EXP 182
89054: PPUSH
89055: LD_VAR 0 1
89059: PPUSH
89060: EMPTY
89061: PPUSH
89062: CALL_OW 1
89066: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
89067: LD_ADDR_EXP 183
89071: PUSH
89072: LD_EXP 183
89076: PPUSH
89077: LD_VAR 0 1
89081: PPUSH
89082: EMPTY
89083: PPUSH
89084: CALL_OW 1
89088: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
89089: LD_ADDR_EXP 184
89093: PUSH
89094: LD_EXP 184
89098: PPUSH
89099: LD_VAR 0 1
89103: PPUSH
89104: EMPTY
89105: PPUSH
89106: CALL_OW 1
89110: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
89111: LD_ADDR_EXP 185
89115: PUSH
89116: LD_EXP 185
89120: PPUSH
89121: LD_VAR 0 1
89125: PPUSH
89126: EMPTY
89127: PPUSH
89128: CALL_OW 1
89132: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
89133: LD_ADDR_EXP 186
89137: PUSH
89138: LD_EXP 186
89142: PPUSH
89143: LD_VAR 0 1
89147: PPUSH
89148: EMPTY
89149: PPUSH
89150: CALL_OW 1
89154: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
89155: LD_ADDR_EXP 188
89159: PUSH
89160: LD_EXP 188
89164: PPUSH
89165: LD_VAR 0 1
89169: PPUSH
89170: EMPTY
89171: PPUSH
89172: CALL_OW 1
89176: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
89177: LD_ADDR_EXP 190
89181: PUSH
89182: LD_EXP 190
89186: PPUSH
89187: LD_VAR 0 1
89191: PPUSH
89192: EMPTY
89193: PPUSH
89194: CALL_OW 1
89198: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
89199: LD_ADDR_EXP 191
89203: PUSH
89204: LD_EXP 191
89208: PPUSH
89209: LD_VAR 0 1
89213: PPUSH
89214: EMPTY
89215: PPUSH
89216: CALL_OW 1
89220: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
89221: LD_ADDR_EXP 192
89225: PUSH
89226: LD_EXP 192
89230: PPUSH
89231: LD_VAR 0 1
89235: PPUSH
89236: EMPTY
89237: PPUSH
89238: CALL_OW 1
89242: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
89243: LD_ADDR_EXP 193
89247: PUSH
89248: LD_EXP 193
89252: PPUSH
89253: LD_VAR 0 1
89257: PPUSH
89258: EMPTY
89259: PPUSH
89260: CALL_OW 1
89264: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
89265: LD_ADDR_EXP 194
89269: PUSH
89270: LD_EXP 194
89274: PPUSH
89275: LD_VAR 0 1
89279: PPUSH
89280: EMPTY
89281: PPUSH
89282: CALL_OW 1
89286: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
89287: LD_ADDR_EXP 195
89291: PUSH
89292: LD_EXP 195
89296: PPUSH
89297: LD_VAR 0 1
89301: PPUSH
89302: EMPTY
89303: PPUSH
89304: CALL_OW 1
89308: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
89309: LD_ADDR_EXP 196
89313: PUSH
89314: LD_EXP 196
89318: PPUSH
89319: LD_VAR 0 1
89323: PPUSH
89324: EMPTY
89325: PPUSH
89326: CALL_OW 1
89330: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
89331: LD_ADDR_EXP 197
89335: PUSH
89336: LD_EXP 197
89340: PPUSH
89341: LD_VAR 0 1
89345: PPUSH
89346: EMPTY
89347: PPUSH
89348: CALL_OW 1
89352: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
89353: LD_ADDR_EXP 198
89357: PUSH
89358: LD_EXP 198
89362: PPUSH
89363: LD_VAR 0 1
89367: PPUSH
89368: EMPTY
89369: PPUSH
89370: CALL_OW 1
89374: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
89375: LD_ADDR_EXP 199
89379: PUSH
89380: LD_EXP 199
89384: PPUSH
89385: LD_VAR 0 1
89389: PPUSH
89390: EMPTY
89391: PPUSH
89392: CALL_OW 1
89396: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
89397: LD_ADDR_EXP 200
89401: PUSH
89402: LD_EXP 200
89406: PPUSH
89407: LD_VAR 0 1
89411: PPUSH
89412: EMPTY
89413: PPUSH
89414: CALL_OW 1
89418: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
89419: LD_ADDR_EXP 201
89423: PUSH
89424: LD_EXP 201
89428: PPUSH
89429: LD_VAR 0 1
89433: PPUSH
89434: EMPTY
89435: PPUSH
89436: CALL_OW 1
89440: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
89441: LD_ADDR_EXP 202
89445: PUSH
89446: LD_EXP 202
89450: PPUSH
89451: LD_VAR 0 1
89455: PPUSH
89456: EMPTY
89457: PPUSH
89458: CALL_OW 1
89462: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
89463: LD_ADDR_EXP 203
89467: PUSH
89468: LD_EXP 203
89472: PPUSH
89473: LD_VAR 0 1
89477: PPUSH
89478: LD_INT 0
89480: PPUSH
89481: CALL_OW 1
89485: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
89486: LD_ADDR_EXP 204
89490: PUSH
89491: LD_EXP 204
89495: PPUSH
89496: LD_VAR 0 1
89500: PPUSH
89501: LD_INT 0
89503: PPUSH
89504: CALL_OW 1
89508: ST_TO_ADDR
// end ;
89509: LD_VAR 0 2
89513: RET
// export function MC_Add ( side , units ) ; var base ; begin
89514: LD_INT 0
89516: PPUSH
89517: PPUSH
// base := mc_bases + 1 ;
89518: LD_ADDR_VAR 0 4
89522: PUSH
89523: LD_EXP 161
89527: PUSH
89528: LD_INT 1
89530: PLUS
89531: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
89532: LD_ADDR_EXP 187
89536: PUSH
89537: LD_EXP 187
89541: PPUSH
89542: LD_VAR 0 4
89546: PPUSH
89547: LD_VAR 0 1
89551: PPUSH
89552: CALL_OW 1
89556: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
89557: LD_ADDR_EXP 161
89561: PUSH
89562: LD_EXP 161
89566: PPUSH
89567: LD_VAR 0 4
89571: PPUSH
89572: LD_VAR 0 2
89576: PPUSH
89577: CALL_OW 1
89581: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
89582: LD_ADDR_EXP 162
89586: PUSH
89587: LD_EXP 162
89591: PPUSH
89592: LD_VAR 0 4
89596: PPUSH
89597: EMPTY
89598: PPUSH
89599: CALL_OW 1
89603: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
89604: LD_ADDR_EXP 163
89608: PUSH
89609: LD_EXP 163
89613: PPUSH
89614: LD_VAR 0 4
89618: PPUSH
89619: EMPTY
89620: PPUSH
89621: CALL_OW 1
89625: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
89626: LD_ADDR_EXP 164
89630: PUSH
89631: LD_EXP 164
89635: PPUSH
89636: LD_VAR 0 4
89640: PPUSH
89641: EMPTY
89642: PPUSH
89643: CALL_OW 1
89647: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
89648: LD_ADDR_EXP 165
89652: PUSH
89653: LD_EXP 165
89657: PPUSH
89658: LD_VAR 0 4
89662: PPUSH
89663: EMPTY
89664: PPUSH
89665: CALL_OW 1
89669: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
89670: LD_ADDR_EXP 166
89674: PUSH
89675: LD_EXP 166
89679: PPUSH
89680: LD_VAR 0 4
89684: PPUSH
89685: EMPTY
89686: PPUSH
89687: CALL_OW 1
89691: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
89692: LD_ADDR_EXP 167
89696: PUSH
89697: LD_EXP 167
89701: PPUSH
89702: LD_VAR 0 4
89706: PPUSH
89707: EMPTY
89708: PPUSH
89709: CALL_OW 1
89713: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
89714: LD_ADDR_EXP 168
89718: PUSH
89719: LD_EXP 168
89723: PPUSH
89724: LD_VAR 0 4
89728: PPUSH
89729: EMPTY
89730: PPUSH
89731: CALL_OW 1
89735: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
89736: LD_ADDR_EXP 169
89740: PUSH
89741: LD_EXP 169
89745: PPUSH
89746: LD_VAR 0 4
89750: PPUSH
89751: EMPTY
89752: PPUSH
89753: CALL_OW 1
89757: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
89758: LD_ADDR_EXP 170
89762: PUSH
89763: LD_EXP 170
89767: PPUSH
89768: LD_VAR 0 4
89772: PPUSH
89773: EMPTY
89774: PPUSH
89775: CALL_OW 1
89779: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
89780: LD_ADDR_EXP 171
89784: PUSH
89785: LD_EXP 171
89789: PPUSH
89790: LD_VAR 0 4
89794: PPUSH
89795: EMPTY
89796: PPUSH
89797: CALL_OW 1
89801: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
89802: LD_ADDR_EXP 172
89806: PUSH
89807: LD_EXP 172
89811: PPUSH
89812: LD_VAR 0 4
89816: PPUSH
89817: LD_INT 0
89819: PPUSH
89820: CALL_OW 1
89824: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
89825: LD_ADDR_EXP 173
89829: PUSH
89830: LD_EXP 173
89834: PPUSH
89835: LD_VAR 0 4
89839: PPUSH
89840: EMPTY
89841: PPUSH
89842: CALL_OW 1
89846: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
89847: LD_ADDR_EXP 174
89851: PUSH
89852: LD_EXP 174
89856: PPUSH
89857: LD_VAR 0 4
89861: PPUSH
89862: EMPTY
89863: PPUSH
89864: CALL_OW 1
89868: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
89869: LD_ADDR_EXP 175
89873: PUSH
89874: LD_EXP 175
89878: PPUSH
89879: LD_VAR 0 4
89883: PPUSH
89884: EMPTY
89885: PPUSH
89886: CALL_OW 1
89890: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
89891: LD_ADDR_EXP 176
89895: PUSH
89896: LD_EXP 176
89900: PPUSH
89901: LD_VAR 0 4
89905: PPUSH
89906: EMPTY
89907: PPUSH
89908: CALL_OW 1
89912: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
89913: LD_ADDR_EXP 177
89917: PUSH
89918: LD_EXP 177
89922: PPUSH
89923: LD_VAR 0 4
89927: PPUSH
89928: EMPTY
89929: PPUSH
89930: CALL_OW 1
89934: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
89935: LD_ADDR_EXP 178
89939: PUSH
89940: LD_EXP 178
89944: PPUSH
89945: LD_VAR 0 4
89949: PPUSH
89950: EMPTY
89951: PPUSH
89952: CALL_OW 1
89956: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
89957: LD_ADDR_EXP 179
89961: PUSH
89962: LD_EXP 179
89966: PPUSH
89967: LD_VAR 0 4
89971: PPUSH
89972: EMPTY
89973: PPUSH
89974: CALL_OW 1
89978: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
89979: LD_ADDR_EXP 180
89983: PUSH
89984: LD_EXP 180
89988: PPUSH
89989: LD_VAR 0 4
89993: PPUSH
89994: EMPTY
89995: PPUSH
89996: CALL_OW 1
90000: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
90001: LD_ADDR_EXP 181
90005: PUSH
90006: LD_EXP 181
90010: PPUSH
90011: LD_VAR 0 4
90015: PPUSH
90016: EMPTY
90017: PPUSH
90018: CALL_OW 1
90022: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
90023: LD_ADDR_EXP 182
90027: PUSH
90028: LD_EXP 182
90032: PPUSH
90033: LD_VAR 0 4
90037: PPUSH
90038: EMPTY
90039: PPUSH
90040: CALL_OW 1
90044: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
90045: LD_ADDR_EXP 183
90049: PUSH
90050: LD_EXP 183
90054: PPUSH
90055: LD_VAR 0 4
90059: PPUSH
90060: EMPTY
90061: PPUSH
90062: CALL_OW 1
90066: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
90067: LD_ADDR_EXP 184
90071: PUSH
90072: LD_EXP 184
90076: PPUSH
90077: LD_VAR 0 4
90081: PPUSH
90082: EMPTY
90083: PPUSH
90084: CALL_OW 1
90088: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
90089: LD_ADDR_EXP 185
90093: PUSH
90094: LD_EXP 185
90098: PPUSH
90099: LD_VAR 0 4
90103: PPUSH
90104: EMPTY
90105: PPUSH
90106: CALL_OW 1
90110: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
90111: LD_ADDR_EXP 186
90115: PUSH
90116: LD_EXP 186
90120: PPUSH
90121: LD_VAR 0 4
90125: PPUSH
90126: EMPTY
90127: PPUSH
90128: CALL_OW 1
90132: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
90133: LD_ADDR_EXP 188
90137: PUSH
90138: LD_EXP 188
90142: PPUSH
90143: LD_VAR 0 4
90147: PPUSH
90148: EMPTY
90149: PPUSH
90150: CALL_OW 1
90154: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
90155: LD_ADDR_EXP 190
90159: PUSH
90160: LD_EXP 190
90164: PPUSH
90165: LD_VAR 0 4
90169: PPUSH
90170: EMPTY
90171: PPUSH
90172: CALL_OW 1
90176: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
90177: LD_ADDR_EXP 191
90181: PUSH
90182: LD_EXP 191
90186: PPUSH
90187: LD_VAR 0 4
90191: PPUSH
90192: EMPTY
90193: PPUSH
90194: CALL_OW 1
90198: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
90199: LD_ADDR_EXP 192
90203: PUSH
90204: LD_EXP 192
90208: PPUSH
90209: LD_VAR 0 4
90213: PPUSH
90214: EMPTY
90215: PPUSH
90216: CALL_OW 1
90220: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
90221: LD_ADDR_EXP 193
90225: PUSH
90226: LD_EXP 193
90230: PPUSH
90231: LD_VAR 0 4
90235: PPUSH
90236: EMPTY
90237: PPUSH
90238: CALL_OW 1
90242: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
90243: LD_ADDR_EXP 194
90247: PUSH
90248: LD_EXP 194
90252: PPUSH
90253: LD_VAR 0 4
90257: PPUSH
90258: EMPTY
90259: PPUSH
90260: CALL_OW 1
90264: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
90265: LD_ADDR_EXP 195
90269: PUSH
90270: LD_EXP 195
90274: PPUSH
90275: LD_VAR 0 4
90279: PPUSH
90280: EMPTY
90281: PPUSH
90282: CALL_OW 1
90286: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
90287: LD_ADDR_EXP 196
90291: PUSH
90292: LD_EXP 196
90296: PPUSH
90297: LD_VAR 0 4
90301: PPUSH
90302: EMPTY
90303: PPUSH
90304: CALL_OW 1
90308: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
90309: LD_ADDR_EXP 197
90313: PUSH
90314: LD_EXP 197
90318: PPUSH
90319: LD_VAR 0 4
90323: PPUSH
90324: EMPTY
90325: PPUSH
90326: CALL_OW 1
90330: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
90331: LD_ADDR_EXP 198
90335: PUSH
90336: LD_EXP 198
90340: PPUSH
90341: LD_VAR 0 4
90345: PPUSH
90346: EMPTY
90347: PPUSH
90348: CALL_OW 1
90352: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
90353: LD_ADDR_EXP 199
90357: PUSH
90358: LD_EXP 199
90362: PPUSH
90363: LD_VAR 0 4
90367: PPUSH
90368: EMPTY
90369: PPUSH
90370: CALL_OW 1
90374: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
90375: LD_ADDR_EXP 200
90379: PUSH
90380: LD_EXP 200
90384: PPUSH
90385: LD_VAR 0 4
90389: PPUSH
90390: EMPTY
90391: PPUSH
90392: CALL_OW 1
90396: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
90397: LD_ADDR_EXP 201
90401: PUSH
90402: LD_EXP 201
90406: PPUSH
90407: LD_VAR 0 4
90411: PPUSH
90412: EMPTY
90413: PPUSH
90414: CALL_OW 1
90418: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
90419: LD_ADDR_EXP 202
90423: PUSH
90424: LD_EXP 202
90428: PPUSH
90429: LD_VAR 0 4
90433: PPUSH
90434: EMPTY
90435: PPUSH
90436: CALL_OW 1
90440: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
90441: LD_ADDR_EXP 203
90445: PUSH
90446: LD_EXP 203
90450: PPUSH
90451: LD_VAR 0 4
90455: PPUSH
90456: LD_INT 0
90458: PPUSH
90459: CALL_OW 1
90463: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
90464: LD_ADDR_EXP 204
90468: PUSH
90469: LD_EXP 204
90473: PPUSH
90474: LD_VAR 0 4
90478: PPUSH
90479: LD_INT 0
90481: PPUSH
90482: CALL_OW 1
90486: ST_TO_ADDR
// result := base ;
90487: LD_ADDR_VAR 0 3
90491: PUSH
90492: LD_VAR 0 4
90496: ST_TO_ADDR
// end ;
90497: LD_VAR 0 3
90501: RET
// export function MC_Start ( ) ; var i ; begin
90502: LD_INT 0
90504: PPUSH
90505: PPUSH
// for i = 1 to mc_bases do
90506: LD_ADDR_VAR 0 2
90510: PUSH
90511: DOUBLE
90512: LD_INT 1
90514: DEC
90515: ST_TO_ADDR
90516: LD_EXP 161
90520: PUSH
90521: FOR_TO
90522: IFFALSE 91622
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
90524: LD_ADDR_EXP 161
90528: PUSH
90529: LD_EXP 161
90533: PPUSH
90534: LD_VAR 0 2
90538: PPUSH
90539: LD_EXP 161
90543: PUSH
90544: LD_VAR 0 2
90548: ARRAY
90549: PUSH
90550: LD_INT 0
90552: DIFF
90553: PPUSH
90554: CALL_OW 1
90558: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
90559: LD_ADDR_EXP 162
90563: PUSH
90564: LD_EXP 162
90568: PPUSH
90569: LD_VAR 0 2
90573: PPUSH
90574: EMPTY
90575: PPUSH
90576: CALL_OW 1
90580: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
90581: LD_ADDR_EXP 163
90585: PUSH
90586: LD_EXP 163
90590: PPUSH
90591: LD_VAR 0 2
90595: PPUSH
90596: EMPTY
90597: PPUSH
90598: CALL_OW 1
90602: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
90603: LD_ADDR_EXP 164
90607: PUSH
90608: LD_EXP 164
90612: PPUSH
90613: LD_VAR 0 2
90617: PPUSH
90618: EMPTY
90619: PPUSH
90620: CALL_OW 1
90624: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
90625: LD_ADDR_EXP 165
90629: PUSH
90630: LD_EXP 165
90634: PPUSH
90635: LD_VAR 0 2
90639: PPUSH
90640: EMPTY
90641: PUSH
90642: EMPTY
90643: PUSH
90644: EMPTY
90645: LIST
90646: LIST
90647: PPUSH
90648: CALL_OW 1
90652: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
90653: LD_ADDR_EXP 166
90657: PUSH
90658: LD_EXP 166
90662: PPUSH
90663: LD_VAR 0 2
90667: PPUSH
90668: EMPTY
90669: PPUSH
90670: CALL_OW 1
90674: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
90675: LD_ADDR_EXP 193
90679: PUSH
90680: LD_EXP 193
90684: PPUSH
90685: LD_VAR 0 2
90689: PPUSH
90690: EMPTY
90691: PPUSH
90692: CALL_OW 1
90696: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
90697: LD_ADDR_EXP 167
90701: PUSH
90702: LD_EXP 167
90706: PPUSH
90707: LD_VAR 0 2
90711: PPUSH
90712: EMPTY
90713: PPUSH
90714: CALL_OW 1
90718: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
90719: LD_ADDR_EXP 168
90723: PUSH
90724: LD_EXP 168
90728: PPUSH
90729: LD_VAR 0 2
90733: PPUSH
90734: EMPTY
90735: PPUSH
90736: CALL_OW 1
90740: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
90741: LD_ADDR_EXP 169
90745: PUSH
90746: LD_EXP 169
90750: PPUSH
90751: LD_VAR 0 2
90755: PPUSH
90756: LD_EXP 161
90760: PUSH
90761: LD_VAR 0 2
90765: ARRAY
90766: PPUSH
90767: LD_INT 2
90769: PUSH
90770: LD_INT 30
90772: PUSH
90773: LD_INT 32
90775: PUSH
90776: EMPTY
90777: LIST
90778: LIST
90779: PUSH
90780: LD_INT 30
90782: PUSH
90783: LD_INT 33
90785: PUSH
90786: EMPTY
90787: LIST
90788: LIST
90789: PUSH
90790: EMPTY
90791: LIST
90792: LIST
90793: LIST
90794: PPUSH
90795: CALL_OW 72
90799: PPUSH
90800: CALL_OW 1
90804: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
90805: LD_ADDR_EXP 170
90809: PUSH
90810: LD_EXP 170
90814: PPUSH
90815: LD_VAR 0 2
90819: PPUSH
90820: LD_EXP 161
90824: PUSH
90825: LD_VAR 0 2
90829: ARRAY
90830: PPUSH
90831: LD_INT 2
90833: PUSH
90834: LD_INT 30
90836: PUSH
90837: LD_INT 32
90839: PUSH
90840: EMPTY
90841: LIST
90842: LIST
90843: PUSH
90844: LD_INT 30
90846: PUSH
90847: LD_INT 31
90849: PUSH
90850: EMPTY
90851: LIST
90852: LIST
90853: PUSH
90854: EMPTY
90855: LIST
90856: LIST
90857: LIST
90858: PUSH
90859: LD_INT 58
90861: PUSH
90862: EMPTY
90863: LIST
90864: PUSH
90865: EMPTY
90866: LIST
90867: LIST
90868: PPUSH
90869: CALL_OW 72
90873: PPUSH
90874: CALL_OW 1
90878: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
90879: LD_ADDR_EXP 171
90883: PUSH
90884: LD_EXP 171
90888: PPUSH
90889: LD_VAR 0 2
90893: PPUSH
90894: EMPTY
90895: PPUSH
90896: CALL_OW 1
90900: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
90901: LD_ADDR_EXP 175
90905: PUSH
90906: LD_EXP 175
90910: PPUSH
90911: LD_VAR 0 2
90915: PPUSH
90916: EMPTY
90917: PPUSH
90918: CALL_OW 1
90922: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
90923: LD_ADDR_EXP 174
90927: PUSH
90928: LD_EXP 174
90932: PPUSH
90933: LD_VAR 0 2
90937: PPUSH
90938: EMPTY
90939: PPUSH
90940: CALL_OW 1
90944: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
90945: LD_ADDR_EXP 176
90949: PUSH
90950: LD_EXP 176
90954: PPUSH
90955: LD_VAR 0 2
90959: PPUSH
90960: EMPTY
90961: PPUSH
90962: CALL_OW 1
90966: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
90967: LD_ADDR_EXP 177
90971: PUSH
90972: LD_EXP 177
90976: PPUSH
90977: LD_VAR 0 2
90981: PPUSH
90982: EMPTY
90983: PPUSH
90984: CALL_OW 1
90988: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
90989: LD_ADDR_EXP 178
90993: PUSH
90994: LD_EXP 178
90998: PPUSH
90999: LD_VAR 0 2
91003: PPUSH
91004: EMPTY
91005: PPUSH
91006: CALL_OW 1
91010: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
91011: LD_ADDR_EXP 179
91015: PUSH
91016: LD_EXP 179
91020: PPUSH
91021: LD_VAR 0 2
91025: PPUSH
91026: EMPTY
91027: PPUSH
91028: CALL_OW 1
91032: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
91033: LD_ADDR_EXP 180
91037: PUSH
91038: LD_EXP 180
91042: PPUSH
91043: LD_VAR 0 2
91047: PPUSH
91048: EMPTY
91049: PPUSH
91050: CALL_OW 1
91054: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
91055: LD_ADDR_EXP 181
91059: PUSH
91060: LD_EXP 181
91064: PPUSH
91065: LD_VAR 0 2
91069: PPUSH
91070: EMPTY
91071: PPUSH
91072: CALL_OW 1
91076: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
91077: LD_ADDR_EXP 182
91081: PUSH
91082: LD_EXP 182
91086: PPUSH
91087: LD_VAR 0 2
91091: PPUSH
91092: EMPTY
91093: PPUSH
91094: CALL_OW 1
91098: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
91099: LD_ADDR_EXP 183
91103: PUSH
91104: LD_EXP 183
91108: PPUSH
91109: LD_VAR 0 2
91113: PPUSH
91114: EMPTY
91115: PPUSH
91116: CALL_OW 1
91120: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
91121: LD_ADDR_EXP 172
91125: PUSH
91126: LD_EXP 172
91130: PPUSH
91131: LD_VAR 0 2
91135: PPUSH
91136: LD_INT 0
91138: PPUSH
91139: CALL_OW 1
91143: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
91144: LD_ADDR_EXP 185
91148: PUSH
91149: LD_EXP 185
91153: PPUSH
91154: LD_VAR 0 2
91158: PPUSH
91159: LD_INT 0
91161: PPUSH
91162: CALL_OW 1
91166: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
91167: LD_ADDR_EXP 173
91171: PUSH
91172: LD_EXP 173
91176: PPUSH
91177: LD_VAR 0 2
91181: PPUSH
91182: EMPTY
91183: PPUSH
91184: CALL_OW 1
91188: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
91189: LD_ADDR_EXP 184
91193: PUSH
91194: LD_EXP 184
91198: PPUSH
91199: LD_VAR 0 2
91203: PPUSH
91204: LD_INT 0
91206: PPUSH
91207: CALL_OW 1
91211: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
91212: LD_ADDR_EXP 186
91216: PUSH
91217: LD_EXP 186
91221: PPUSH
91222: LD_VAR 0 2
91226: PPUSH
91227: EMPTY
91228: PPUSH
91229: CALL_OW 1
91233: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
91234: LD_ADDR_EXP 189
91238: PUSH
91239: LD_EXP 189
91243: PPUSH
91244: LD_VAR 0 2
91248: PPUSH
91249: LD_INT 0
91251: PPUSH
91252: CALL_OW 1
91256: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
91257: LD_ADDR_EXP 190
91261: PUSH
91262: LD_EXP 190
91266: PPUSH
91267: LD_VAR 0 2
91271: PPUSH
91272: EMPTY
91273: PPUSH
91274: CALL_OW 1
91278: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
91279: LD_ADDR_EXP 191
91283: PUSH
91284: LD_EXP 191
91288: PPUSH
91289: LD_VAR 0 2
91293: PPUSH
91294: EMPTY
91295: PPUSH
91296: CALL_OW 1
91300: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
91301: LD_ADDR_EXP 192
91305: PUSH
91306: LD_EXP 192
91310: PPUSH
91311: LD_VAR 0 2
91315: PPUSH
91316: EMPTY
91317: PPUSH
91318: CALL_OW 1
91322: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
91323: LD_ADDR_EXP 194
91327: PUSH
91328: LD_EXP 194
91332: PPUSH
91333: LD_VAR 0 2
91337: PPUSH
91338: LD_EXP 161
91342: PUSH
91343: LD_VAR 0 2
91347: ARRAY
91348: PPUSH
91349: LD_INT 2
91351: PUSH
91352: LD_INT 30
91354: PUSH
91355: LD_INT 6
91357: PUSH
91358: EMPTY
91359: LIST
91360: LIST
91361: PUSH
91362: LD_INT 30
91364: PUSH
91365: LD_INT 7
91367: PUSH
91368: EMPTY
91369: LIST
91370: LIST
91371: PUSH
91372: LD_INT 30
91374: PUSH
91375: LD_INT 8
91377: PUSH
91378: EMPTY
91379: LIST
91380: LIST
91381: PUSH
91382: EMPTY
91383: LIST
91384: LIST
91385: LIST
91386: LIST
91387: PPUSH
91388: CALL_OW 72
91392: PPUSH
91393: CALL_OW 1
91397: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
91398: LD_ADDR_EXP 195
91402: PUSH
91403: LD_EXP 195
91407: PPUSH
91408: LD_VAR 0 2
91412: PPUSH
91413: EMPTY
91414: PPUSH
91415: CALL_OW 1
91419: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
91420: LD_ADDR_EXP 196
91424: PUSH
91425: LD_EXP 196
91429: PPUSH
91430: LD_VAR 0 2
91434: PPUSH
91435: EMPTY
91436: PPUSH
91437: CALL_OW 1
91441: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
91442: LD_ADDR_EXP 197
91446: PUSH
91447: LD_EXP 197
91451: PPUSH
91452: LD_VAR 0 2
91456: PPUSH
91457: EMPTY
91458: PPUSH
91459: CALL_OW 1
91463: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
91464: LD_ADDR_EXP 198
91468: PUSH
91469: LD_EXP 198
91473: PPUSH
91474: LD_VAR 0 2
91478: PPUSH
91479: EMPTY
91480: PPUSH
91481: CALL_OW 1
91485: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
91486: LD_ADDR_EXP 199
91490: PUSH
91491: LD_EXP 199
91495: PPUSH
91496: LD_VAR 0 2
91500: PPUSH
91501: EMPTY
91502: PPUSH
91503: CALL_OW 1
91507: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
91508: LD_ADDR_EXP 200
91512: PUSH
91513: LD_EXP 200
91517: PPUSH
91518: LD_VAR 0 2
91522: PPUSH
91523: EMPTY
91524: PPUSH
91525: CALL_OW 1
91529: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
91530: LD_ADDR_EXP 201
91534: PUSH
91535: LD_EXP 201
91539: PPUSH
91540: LD_VAR 0 2
91544: PPUSH
91545: EMPTY
91546: PPUSH
91547: CALL_OW 1
91551: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
91552: LD_ADDR_EXP 202
91556: PUSH
91557: LD_EXP 202
91561: PPUSH
91562: LD_VAR 0 2
91566: PPUSH
91567: EMPTY
91568: PPUSH
91569: CALL_OW 1
91573: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
91574: LD_ADDR_EXP 203
91578: PUSH
91579: LD_EXP 203
91583: PPUSH
91584: LD_VAR 0 2
91588: PPUSH
91589: LD_INT 0
91591: PPUSH
91592: CALL_OW 1
91596: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , i , false ) ;
91597: LD_ADDR_EXP 204
91601: PUSH
91602: LD_EXP 204
91606: PPUSH
91607: LD_VAR 0 2
91611: PPUSH
91612: LD_INT 0
91614: PPUSH
91615: CALL_OW 1
91619: ST_TO_ADDR
// end ;
91620: GO 90521
91622: POP
91623: POP
// MC_InitSides ( ) ;
91624: CALL 91910 0 0
// MC_InitResearch ( ) ;
91628: CALL 91649 0 0
// CustomInitMacro ( ) ;
91632: CALL 350 0 0
// skirmish := true ;
91636: LD_ADDR_EXP 159
91640: PUSH
91641: LD_INT 1
91643: ST_TO_ADDR
// end ;
91644: LD_VAR 0 1
91648: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
91649: LD_INT 0
91651: PPUSH
91652: PPUSH
91653: PPUSH
91654: PPUSH
91655: PPUSH
91656: PPUSH
// if not mc_bases then
91657: LD_EXP 161
91661: NOT
91662: IFFALSE 91666
// exit ;
91664: GO 91905
// for i = 1 to 8 do
91666: LD_ADDR_VAR 0 2
91670: PUSH
91671: DOUBLE
91672: LD_INT 1
91674: DEC
91675: ST_TO_ADDR
91676: LD_INT 8
91678: PUSH
91679: FOR_TO
91680: IFFALSE 91706
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
91682: LD_ADDR_EXP 188
91686: PUSH
91687: LD_EXP 188
91691: PPUSH
91692: LD_VAR 0 2
91696: PPUSH
91697: EMPTY
91698: PPUSH
91699: CALL_OW 1
91703: ST_TO_ADDR
91704: GO 91679
91706: POP
91707: POP
// tmp := [ ] ;
91708: LD_ADDR_VAR 0 5
91712: PUSH
91713: EMPTY
91714: ST_TO_ADDR
// for i = 1 to mc_sides do
91715: LD_ADDR_VAR 0 2
91719: PUSH
91720: DOUBLE
91721: LD_INT 1
91723: DEC
91724: ST_TO_ADDR
91725: LD_EXP 187
91729: PUSH
91730: FOR_TO
91731: IFFALSE 91789
// if not mc_sides [ i ] in tmp then
91733: LD_EXP 187
91737: PUSH
91738: LD_VAR 0 2
91742: ARRAY
91743: PUSH
91744: LD_VAR 0 5
91748: IN
91749: NOT
91750: IFFALSE 91787
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
91752: LD_ADDR_VAR 0 5
91756: PUSH
91757: LD_VAR 0 5
91761: PPUSH
91762: LD_VAR 0 5
91766: PUSH
91767: LD_INT 1
91769: PLUS
91770: PPUSH
91771: LD_EXP 187
91775: PUSH
91776: LD_VAR 0 2
91780: ARRAY
91781: PPUSH
91782: CALL_OW 2
91786: ST_TO_ADDR
91787: GO 91730
91789: POP
91790: POP
// if not tmp then
91791: LD_VAR 0 5
91795: NOT
91796: IFFALSE 91800
// exit ;
91798: GO 91905
// for j in tmp do
91800: LD_ADDR_VAR 0 3
91804: PUSH
91805: LD_VAR 0 5
91809: PUSH
91810: FOR_IN
91811: IFFALSE 91903
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
91813: LD_ADDR_VAR 0 6
91817: PUSH
91818: LD_INT 22
91820: PUSH
91821: LD_VAR 0 3
91825: PUSH
91826: EMPTY
91827: LIST
91828: LIST
91829: PPUSH
91830: CALL_OW 69
91834: ST_TO_ADDR
// if not un then
91835: LD_VAR 0 6
91839: NOT
91840: IFFALSE 91844
// continue ;
91842: GO 91810
// nation := GetNation ( un [ 1 ] ) ;
91844: LD_ADDR_VAR 0 4
91848: PUSH
91849: LD_VAR 0 6
91853: PUSH
91854: LD_INT 1
91856: ARRAY
91857: PPUSH
91858: CALL_OW 248
91862: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
91863: LD_ADDR_EXP 188
91867: PUSH
91868: LD_EXP 188
91872: PPUSH
91873: LD_VAR 0 3
91877: PPUSH
91878: LD_VAR 0 3
91882: PPUSH
91883: LD_VAR 0 4
91887: PPUSH
91888: LD_INT 1
91890: PPUSH
91891: CALL 19287 0 3
91895: PPUSH
91896: CALL_OW 1
91900: ST_TO_ADDR
// end ;
91901: GO 91810
91903: POP
91904: POP
// end ;
91905: LD_VAR 0 1
91909: RET
// export function MC_InitSides ( ) ; var i ; begin
91910: LD_INT 0
91912: PPUSH
91913: PPUSH
// if not mc_bases then
91914: LD_EXP 161
91918: NOT
91919: IFFALSE 91923
// exit ;
91921: GO 91997
// for i = 1 to mc_bases do
91923: LD_ADDR_VAR 0 2
91927: PUSH
91928: DOUBLE
91929: LD_INT 1
91931: DEC
91932: ST_TO_ADDR
91933: LD_EXP 161
91937: PUSH
91938: FOR_TO
91939: IFFALSE 91995
// if mc_bases [ i ] then
91941: LD_EXP 161
91945: PUSH
91946: LD_VAR 0 2
91950: ARRAY
91951: IFFALSE 91993
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
91953: LD_ADDR_EXP 187
91957: PUSH
91958: LD_EXP 187
91962: PPUSH
91963: LD_VAR 0 2
91967: PPUSH
91968: LD_EXP 161
91972: PUSH
91973: LD_VAR 0 2
91977: ARRAY
91978: PUSH
91979: LD_INT 1
91981: ARRAY
91982: PPUSH
91983: CALL_OW 255
91987: PPUSH
91988: CALL_OW 1
91992: ST_TO_ADDR
91993: GO 91938
91995: POP
91996: POP
// end ;
91997: LD_VAR 0 1
92001: RET
// every 0 0$03 trigger skirmish do
92002: LD_EXP 159
92006: IFFALSE 92160
92008: GO 92010
92010: DISABLE
// begin enable ;
92011: ENABLE
// MC_CheckBuildings ( ) ;
92012: CALL 96672 0 0
// MC_CheckPeopleLife ( ) ;
92016: CALL 96833 0 0
// RaiseSailEvent ( 100 ) ;
92020: LD_INT 100
92022: PPUSH
92023: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
92027: LD_INT 103
92029: PPUSH
92030: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
92034: LD_INT 104
92036: PPUSH
92037: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
92041: LD_INT 105
92043: PPUSH
92044: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
92048: LD_INT 106
92050: PPUSH
92051: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
92055: LD_INT 107
92057: PPUSH
92058: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
92062: LD_INT 108
92064: PPUSH
92065: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
92069: LD_INT 109
92071: PPUSH
92072: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
92076: LD_INT 110
92078: PPUSH
92079: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
92083: LD_INT 111
92085: PPUSH
92086: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
92090: LD_INT 112
92092: PPUSH
92093: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
92097: LD_INT 113
92099: PPUSH
92100: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
92104: LD_INT 120
92106: PPUSH
92107: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
92111: LD_INT 121
92113: PPUSH
92114: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
92118: LD_INT 122
92120: PPUSH
92121: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
92125: LD_INT 123
92127: PPUSH
92128: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
92132: LD_INT 124
92134: PPUSH
92135: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
92139: LD_INT 125
92141: PPUSH
92142: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
92146: LD_INT 126
92148: PPUSH
92149: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
92153: LD_INT 200
92155: PPUSH
92156: CALL_OW 427
// end ;
92160: END
// on SailEvent ( event ) do begin if event < 100 then
92161: LD_VAR 0 1
92165: PUSH
92166: LD_INT 100
92168: LESS
92169: IFFALSE 92180
// CustomEvent ( event ) ;
92171: LD_VAR 0 1
92175: PPUSH
92176: CALL 16158 0 1
// if event = 100 then
92180: LD_VAR 0 1
92184: PUSH
92185: LD_INT 100
92187: EQUAL
92188: IFFALSE 92194
// MC_ClassManager ( ) ;
92190: CALL 92586 0 0
// if event = 101 then
92194: LD_VAR 0 1
92198: PUSH
92199: LD_INT 101
92201: EQUAL
92202: IFFALSE 92208
// MC_RepairBuildings ( ) ;
92204: CALL 97418 0 0
// if event = 102 then
92208: LD_VAR 0 1
92212: PUSH
92213: LD_INT 102
92215: EQUAL
92216: IFFALSE 92222
// MC_Heal ( ) ;
92218: CALL 98353 0 0
// if event = 103 then
92222: LD_VAR 0 1
92226: PUSH
92227: LD_INT 103
92229: EQUAL
92230: IFFALSE 92236
// MC_Build ( ) ;
92232: CALL 98775 0 0
// if event = 104 then
92236: LD_VAR 0 1
92240: PUSH
92241: LD_INT 104
92243: EQUAL
92244: IFFALSE 92250
// MC_TurretWeapon ( ) ;
92246: CALL 100409 0 0
// if event = 105 then
92250: LD_VAR 0 1
92254: PUSH
92255: LD_INT 105
92257: EQUAL
92258: IFFALSE 92264
// MC_BuildUpgrade ( ) ;
92260: CALL 99960 0 0
// if event = 106 then
92264: LD_VAR 0 1
92268: PUSH
92269: LD_INT 106
92271: EQUAL
92272: IFFALSE 92278
// MC_PlantMines ( ) ;
92274: CALL 100839 0 0
// if event = 107 then
92278: LD_VAR 0 1
92282: PUSH
92283: LD_INT 107
92285: EQUAL
92286: IFFALSE 92292
// MC_CollectCrates ( ) ;
92288: CALL 101637 0 0
// if event = 108 then
92292: LD_VAR 0 1
92296: PUSH
92297: LD_INT 108
92299: EQUAL
92300: IFFALSE 92306
// MC_LinkRemoteControl ( ) ;
92302: CALL 103487 0 0
// if event = 109 then
92306: LD_VAR 0 1
92310: PUSH
92311: LD_INT 109
92313: EQUAL
92314: IFFALSE 92320
// MC_ProduceVehicle ( ) ;
92316: CALL 103668 0 0
// if event = 110 then
92320: LD_VAR 0 1
92324: PUSH
92325: LD_INT 110
92327: EQUAL
92328: IFFALSE 92334
// MC_SendAttack ( ) ;
92330: CALL 104134 0 0
// if event = 111 then
92334: LD_VAR 0 1
92338: PUSH
92339: LD_INT 111
92341: EQUAL
92342: IFFALSE 92348
// MC_Defend ( ) ;
92344: CALL 104242 0 0
// if event = 112 then
92348: LD_VAR 0 1
92352: PUSH
92353: LD_INT 112
92355: EQUAL
92356: IFFALSE 92362
// MC_Research ( ) ;
92358: CALL 105122 0 0
// if event = 113 then
92362: LD_VAR 0 1
92366: PUSH
92367: LD_INT 113
92369: EQUAL
92370: IFFALSE 92376
// MC_MinesTrigger ( ) ;
92372: CALL 106236 0 0
// if event = 120 then
92376: LD_VAR 0 1
92380: PUSH
92381: LD_INT 120
92383: EQUAL
92384: IFFALSE 92390
// MC_RepairVehicle ( ) ;
92386: CALL 106335 0 0
// if event = 121 then
92390: LD_VAR 0 1
92394: PUSH
92395: LD_INT 121
92397: EQUAL
92398: IFFALSE 92404
// MC_TameApe ( ) ;
92400: CALL 107104 0 0
// if event = 122 then
92404: LD_VAR 0 1
92408: PUSH
92409: LD_INT 122
92411: EQUAL
92412: IFFALSE 92418
// MC_ChangeApeClass ( ) ;
92414: CALL 107933 0 0
// if event = 123 then
92418: LD_VAR 0 1
92422: PUSH
92423: LD_INT 123
92425: EQUAL
92426: IFFALSE 92432
// MC_Bazooka ( ) ;
92428: CALL 108583 0 0
// if event = 124 then
92432: LD_VAR 0 1
92436: PUSH
92437: LD_INT 124
92439: EQUAL
92440: IFFALSE 92446
// MC_TeleportExit ( ) ;
92442: CALL 108781 0 0
// if event = 125 then
92446: LD_VAR 0 1
92450: PUSH
92451: LD_INT 125
92453: EQUAL
92454: IFFALSE 92460
// MC_Deposits ( ) ;
92456: CALL 109428 0 0
// if event = 126 then
92460: LD_VAR 0 1
92464: PUSH
92465: LD_INT 126
92467: EQUAL
92468: IFFALSE 92474
// MC_RemoteDriver ( ) ;
92470: CALL 110053 0 0
// if event = 200 then
92474: LD_VAR 0 1
92478: PUSH
92479: LD_INT 200
92481: EQUAL
92482: IFFALSE 92488
// MC_Idle ( ) ;
92484: CALL 111960 0 0
// end ;
92488: PPOPN 1
92490: END
// export function MC_Reset ( base , tag ) ; var i ; begin
92491: LD_INT 0
92493: PPUSH
92494: PPUSH
// if not mc_bases [ base ] or not tag then
92495: LD_EXP 161
92499: PUSH
92500: LD_VAR 0 1
92504: ARRAY
92505: NOT
92506: PUSH
92507: LD_VAR 0 2
92511: NOT
92512: OR
92513: IFFALSE 92517
// exit ;
92515: GO 92581
// for i in mc_bases [ base ] union mc_ape [ base ] do
92517: LD_ADDR_VAR 0 4
92521: PUSH
92522: LD_EXP 161
92526: PUSH
92527: LD_VAR 0 1
92531: ARRAY
92532: PUSH
92533: LD_EXP 190
92537: PUSH
92538: LD_VAR 0 1
92542: ARRAY
92543: UNION
92544: PUSH
92545: FOR_IN
92546: IFFALSE 92579
// if GetTag ( i ) = tag then
92548: LD_VAR 0 4
92552: PPUSH
92553: CALL_OW 110
92557: PUSH
92558: LD_VAR 0 2
92562: EQUAL
92563: IFFALSE 92577
// SetTag ( i , 0 ) ;
92565: LD_VAR 0 4
92569: PPUSH
92570: LD_INT 0
92572: PPUSH
92573: CALL_OW 109
92577: GO 92545
92579: POP
92580: POP
// end ;
92581: LD_VAR 0 3
92585: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
92586: LD_INT 0
92588: PPUSH
92589: PPUSH
92590: PPUSH
92591: PPUSH
92592: PPUSH
92593: PPUSH
92594: PPUSH
92595: PPUSH
// if not mc_bases then
92596: LD_EXP 161
92600: NOT
92601: IFFALSE 92605
// exit ;
92603: GO 93054
// for i = 1 to mc_bases do
92605: LD_ADDR_VAR 0 2
92609: PUSH
92610: DOUBLE
92611: LD_INT 1
92613: DEC
92614: ST_TO_ADDR
92615: LD_EXP 161
92619: PUSH
92620: FOR_TO
92621: IFFALSE 93052
// begin tmp := MC_ClassCheckReq ( i ) ;
92623: LD_ADDR_VAR 0 4
92627: PUSH
92628: LD_VAR 0 2
92632: PPUSH
92633: CALL 93059 0 1
92637: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
92638: LD_ADDR_EXP 202
92642: PUSH
92643: LD_EXP 202
92647: PPUSH
92648: LD_VAR 0 2
92652: PPUSH
92653: LD_VAR 0 4
92657: PPUSH
92658: CALL_OW 1
92662: ST_TO_ADDR
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
92663: LD_ADDR_VAR 0 6
92667: PUSH
92668: LD_EXP 161
92672: PUSH
92673: LD_VAR 0 2
92677: ARRAY
92678: PPUSH
92679: LD_INT 2
92681: PUSH
92682: LD_INT 30
92684: PUSH
92685: LD_INT 4
92687: PUSH
92688: EMPTY
92689: LIST
92690: LIST
92691: PUSH
92692: LD_INT 30
92694: PUSH
92695: LD_INT 5
92697: PUSH
92698: EMPTY
92699: LIST
92700: LIST
92701: PUSH
92702: EMPTY
92703: LIST
92704: LIST
92705: LIST
92706: PPUSH
92707: CALL_OW 72
92711: PUSH
92712: LD_EXP 161
92716: PUSH
92717: LD_VAR 0 2
92721: ARRAY
92722: PPUSH
92723: LD_INT 2
92725: PUSH
92726: LD_INT 30
92728: PUSH
92729: LD_INT 0
92731: PUSH
92732: EMPTY
92733: LIST
92734: LIST
92735: PUSH
92736: LD_INT 30
92738: PUSH
92739: LD_INT 1
92741: PUSH
92742: EMPTY
92743: LIST
92744: LIST
92745: PUSH
92746: EMPTY
92747: LIST
92748: LIST
92749: LIST
92750: PPUSH
92751: CALL_OW 72
92755: PUSH
92756: LD_EXP 161
92760: PUSH
92761: LD_VAR 0 2
92765: ARRAY
92766: PPUSH
92767: LD_INT 30
92769: PUSH
92770: LD_INT 3
92772: PUSH
92773: EMPTY
92774: LIST
92775: LIST
92776: PPUSH
92777: CALL_OW 72
92781: PUSH
92782: LD_EXP 161
92786: PUSH
92787: LD_VAR 0 2
92791: ARRAY
92792: PPUSH
92793: LD_INT 2
92795: PUSH
92796: LD_INT 30
92798: PUSH
92799: LD_INT 6
92801: PUSH
92802: EMPTY
92803: LIST
92804: LIST
92805: PUSH
92806: LD_INT 30
92808: PUSH
92809: LD_INT 7
92811: PUSH
92812: EMPTY
92813: LIST
92814: LIST
92815: PUSH
92816: LD_INT 30
92818: PUSH
92819: LD_INT 8
92821: PUSH
92822: EMPTY
92823: LIST
92824: LIST
92825: PUSH
92826: EMPTY
92827: LIST
92828: LIST
92829: LIST
92830: LIST
92831: PPUSH
92832: CALL_OW 72
92836: PUSH
92837: EMPTY
92838: LIST
92839: LIST
92840: LIST
92841: LIST
92842: ST_TO_ADDR
// for j := 1 to 4 do
92843: LD_ADDR_VAR 0 3
92847: PUSH
92848: DOUBLE
92849: LD_INT 1
92851: DEC
92852: ST_TO_ADDR
92853: LD_INT 4
92855: PUSH
92856: FOR_TO
92857: IFFALSE 93048
// begin if not tmp [ j ] then
92859: LD_VAR 0 4
92863: PUSH
92864: LD_VAR 0 3
92868: ARRAY
92869: NOT
92870: IFFALSE 92874
// continue ;
92872: GO 92856
// for p in tmp [ j ] do
92874: LD_ADDR_VAR 0 5
92878: PUSH
92879: LD_VAR 0 4
92883: PUSH
92884: LD_VAR 0 3
92888: ARRAY
92889: PUSH
92890: FOR_IN
92891: IFFALSE 93044
// begin if not b [ j ] then
92893: LD_VAR 0 6
92897: PUSH
92898: LD_VAR 0 3
92902: ARRAY
92903: NOT
92904: IFFALSE 92908
// break ;
92906: GO 93044
// e := 0 ;
92908: LD_ADDR_VAR 0 7
92912: PUSH
92913: LD_INT 0
92915: ST_TO_ADDR
// for k in b [ j ] do
92916: LD_ADDR_VAR 0 8
92920: PUSH
92921: LD_VAR 0 6
92925: PUSH
92926: LD_VAR 0 3
92930: ARRAY
92931: PUSH
92932: FOR_IN
92933: IFFALSE 92960
// if IsNotFull ( k ) then
92935: LD_VAR 0 8
92939: PPUSH
92940: CALL 21408 0 1
92944: IFFALSE 92958
// begin e := k ;
92946: LD_ADDR_VAR 0 7
92950: PUSH
92951: LD_VAR 0 8
92955: ST_TO_ADDR
// break ;
92956: GO 92960
// end ;
92958: GO 92932
92960: POP
92961: POP
// if e and not UnitGoingToBuilding ( p , e ) then
92962: LD_VAR 0 7
92966: PUSH
92967: LD_VAR 0 5
92971: PPUSH
92972: LD_VAR 0 7
92976: PPUSH
92977: CALL 55190 0 2
92981: NOT
92982: AND
92983: IFFALSE 93042
// begin if IsInUnit ( p ) then
92985: LD_VAR 0 5
92989: PPUSH
92990: CALL_OW 310
92994: IFFALSE 93005
// ComExitBuilding ( p ) ;
92996: LD_VAR 0 5
93000: PPUSH
93001: CALL_OW 122
// ComEnterUnit ( p , e ) ;
93005: LD_VAR 0 5
93009: PPUSH
93010: LD_VAR 0 7
93014: PPUSH
93015: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
93019: LD_VAR 0 5
93023: PPUSH
93024: LD_VAR 0 3
93028: PPUSH
93029: CALL_OW 183
// AddComExitBuilding ( p ) ;
93033: LD_VAR 0 5
93037: PPUSH
93038: CALL_OW 182
// end ; end ;
93042: GO 92890
93044: POP
93045: POP
// end ;
93046: GO 92856
93048: POP
93049: POP
// end ;
93050: GO 92620
93052: POP
93053: POP
// end ;
93054: LD_VAR 0 1
93058: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
93059: LD_INT 0
93061: PPUSH
93062: PPUSH
93063: PPUSH
93064: PPUSH
93065: PPUSH
93066: PPUSH
93067: PPUSH
93068: PPUSH
93069: PPUSH
93070: PPUSH
93071: PPUSH
93072: PPUSH
// result := [ 0 , 0 , 0 , 0 ] ;
93073: LD_ADDR_VAR 0 2
93077: PUSH
93078: LD_INT 0
93080: PUSH
93081: LD_INT 0
93083: PUSH
93084: LD_INT 0
93086: PUSH
93087: LD_INT 0
93089: PUSH
93090: EMPTY
93091: LIST
93092: LIST
93093: LIST
93094: LIST
93095: ST_TO_ADDR
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
93096: LD_VAR 0 1
93100: NOT
93101: PUSH
93102: LD_EXP 161
93106: PUSH
93107: LD_VAR 0 1
93111: ARRAY
93112: NOT
93113: OR
93114: PUSH
93115: LD_EXP 161
93119: PUSH
93120: LD_VAR 0 1
93124: ARRAY
93125: PPUSH
93126: LD_INT 2
93128: PUSH
93129: LD_INT 30
93131: PUSH
93132: LD_INT 0
93134: PUSH
93135: EMPTY
93136: LIST
93137: LIST
93138: PUSH
93139: LD_INT 30
93141: PUSH
93142: LD_INT 1
93144: PUSH
93145: EMPTY
93146: LIST
93147: LIST
93148: PUSH
93149: EMPTY
93150: LIST
93151: LIST
93152: LIST
93153: PPUSH
93154: CALL_OW 72
93158: NOT
93159: OR
93160: IFFALSE 93164
// exit ;
93162: GO 96667
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
93164: LD_ADDR_VAR 0 4
93168: PUSH
93169: LD_EXP 161
93173: PUSH
93174: LD_VAR 0 1
93178: ARRAY
93179: PPUSH
93180: LD_INT 2
93182: PUSH
93183: LD_INT 25
93185: PUSH
93186: LD_INT 1
93188: PUSH
93189: EMPTY
93190: LIST
93191: LIST
93192: PUSH
93193: LD_INT 25
93195: PUSH
93196: LD_INT 2
93198: PUSH
93199: EMPTY
93200: LIST
93201: LIST
93202: PUSH
93203: LD_INT 25
93205: PUSH
93206: LD_INT 3
93208: PUSH
93209: EMPTY
93210: LIST
93211: LIST
93212: PUSH
93213: LD_INT 25
93215: PUSH
93216: LD_INT 4
93218: PUSH
93219: EMPTY
93220: LIST
93221: LIST
93222: PUSH
93223: LD_INT 25
93225: PUSH
93226: LD_INT 5
93228: PUSH
93229: EMPTY
93230: LIST
93231: LIST
93232: PUSH
93233: LD_INT 25
93235: PUSH
93236: LD_INT 8
93238: PUSH
93239: EMPTY
93240: LIST
93241: LIST
93242: PUSH
93243: LD_INT 25
93245: PUSH
93246: LD_INT 9
93248: PUSH
93249: EMPTY
93250: LIST
93251: LIST
93252: PUSH
93253: EMPTY
93254: LIST
93255: LIST
93256: LIST
93257: LIST
93258: LIST
93259: LIST
93260: LIST
93261: LIST
93262: PPUSH
93263: CALL_OW 72
93267: ST_TO_ADDR
// if not tmp then
93268: LD_VAR 0 4
93272: NOT
93273: IFFALSE 93277
// exit ;
93275: GO 96667
// for i in tmp do
93277: LD_ADDR_VAR 0 3
93281: PUSH
93282: LD_VAR 0 4
93286: PUSH
93287: FOR_IN
93288: IFFALSE 93319
// if GetTag ( i ) then
93290: LD_VAR 0 3
93294: PPUSH
93295: CALL_OW 110
93299: IFFALSE 93317
// tmp := tmp diff i ;
93301: LD_ADDR_VAR 0 4
93305: PUSH
93306: LD_VAR 0 4
93310: PUSH
93311: LD_VAR 0 3
93315: DIFF
93316: ST_TO_ADDR
93317: GO 93287
93319: POP
93320: POP
// if not tmp then
93321: LD_VAR 0 4
93325: NOT
93326: IFFALSE 93330
// exit ;
93328: GO 96667
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
93330: LD_ADDR_VAR 0 5
93334: PUSH
93335: LD_EXP 161
93339: PUSH
93340: LD_VAR 0 1
93344: ARRAY
93345: PPUSH
93346: LD_INT 2
93348: PUSH
93349: LD_INT 25
93351: PUSH
93352: LD_INT 1
93354: PUSH
93355: EMPTY
93356: LIST
93357: LIST
93358: PUSH
93359: LD_INT 25
93361: PUSH
93362: LD_INT 5
93364: PUSH
93365: EMPTY
93366: LIST
93367: LIST
93368: PUSH
93369: LD_INT 25
93371: PUSH
93372: LD_INT 8
93374: PUSH
93375: EMPTY
93376: LIST
93377: LIST
93378: PUSH
93379: LD_INT 25
93381: PUSH
93382: LD_INT 9
93384: PUSH
93385: EMPTY
93386: LIST
93387: LIST
93388: PUSH
93389: EMPTY
93390: LIST
93391: LIST
93392: LIST
93393: LIST
93394: LIST
93395: PPUSH
93396: CALL_OW 72
93400: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
93401: LD_ADDR_VAR 0 6
93405: PUSH
93406: LD_EXP 161
93410: PUSH
93411: LD_VAR 0 1
93415: ARRAY
93416: PPUSH
93417: LD_INT 25
93419: PUSH
93420: LD_INT 2
93422: PUSH
93423: EMPTY
93424: LIST
93425: LIST
93426: PPUSH
93427: CALL_OW 72
93431: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
93432: LD_ADDR_VAR 0 7
93436: PUSH
93437: LD_EXP 161
93441: PUSH
93442: LD_VAR 0 1
93446: ARRAY
93447: PPUSH
93448: LD_INT 25
93450: PUSH
93451: LD_INT 3
93453: PUSH
93454: EMPTY
93455: LIST
93456: LIST
93457: PPUSH
93458: CALL_OW 72
93462: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
93463: LD_ADDR_VAR 0 8
93467: PUSH
93468: LD_EXP 161
93472: PUSH
93473: LD_VAR 0 1
93477: ARRAY
93478: PPUSH
93479: LD_INT 25
93481: PUSH
93482: LD_INT 4
93484: PUSH
93485: EMPTY
93486: LIST
93487: LIST
93488: PUSH
93489: LD_INT 24
93491: PUSH
93492: LD_INT 251
93494: PUSH
93495: EMPTY
93496: LIST
93497: LIST
93498: PUSH
93499: EMPTY
93500: LIST
93501: LIST
93502: PPUSH
93503: CALL_OW 72
93507: ST_TO_ADDR
// if mc_is_defending [ base ] then
93508: LD_EXP 204
93512: PUSH
93513: LD_VAR 0 1
93517: ARRAY
93518: IFFALSE 93979
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
93520: LD_ADDR_EXP 203
93524: PUSH
93525: LD_EXP 203
93529: PPUSH
93530: LD_VAR 0 1
93534: PPUSH
93535: LD_INT 4
93537: PPUSH
93538: CALL_OW 1
93542: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
93543: LD_ADDR_VAR 0 12
93547: PUSH
93548: LD_EXP 161
93552: PUSH
93553: LD_VAR 0 1
93557: ARRAY
93558: PPUSH
93559: LD_INT 2
93561: PUSH
93562: LD_INT 30
93564: PUSH
93565: LD_INT 4
93567: PUSH
93568: EMPTY
93569: LIST
93570: LIST
93571: PUSH
93572: LD_INT 30
93574: PUSH
93575: LD_INT 5
93577: PUSH
93578: EMPTY
93579: LIST
93580: LIST
93581: PUSH
93582: EMPTY
93583: LIST
93584: LIST
93585: LIST
93586: PPUSH
93587: CALL_OW 72
93591: ST_TO_ADDR
// if not b then
93592: LD_VAR 0 12
93596: NOT
93597: IFFALSE 93601
// exit ;
93599: GO 96667
// p := [ ] ;
93601: LD_ADDR_VAR 0 11
93605: PUSH
93606: EMPTY
93607: ST_TO_ADDR
// if sci >= 2 then
93608: LD_VAR 0 8
93612: PUSH
93613: LD_INT 2
93615: GREATEREQUAL
93616: IFFALSE 93647
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
93618: LD_ADDR_VAR 0 8
93622: PUSH
93623: LD_VAR 0 8
93627: PUSH
93628: LD_INT 1
93630: ARRAY
93631: PUSH
93632: LD_VAR 0 8
93636: PUSH
93637: LD_INT 2
93639: ARRAY
93640: PUSH
93641: EMPTY
93642: LIST
93643: LIST
93644: ST_TO_ADDR
93645: GO 93708
// if sci = 1 then
93647: LD_VAR 0 8
93651: PUSH
93652: LD_INT 1
93654: EQUAL
93655: IFFALSE 93676
// sci := [ sci [ 1 ] ] else
93657: LD_ADDR_VAR 0 8
93661: PUSH
93662: LD_VAR 0 8
93666: PUSH
93667: LD_INT 1
93669: ARRAY
93670: PUSH
93671: EMPTY
93672: LIST
93673: ST_TO_ADDR
93674: GO 93708
// if sci = 0 then
93676: LD_VAR 0 8
93680: PUSH
93681: LD_INT 0
93683: EQUAL
93684: IFFALSE 93708
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
93686: LD_ADDR_VAR 0 11
93690: PUSH
93691: LD_VAR 0 4
93695: PPUSH
93696: LD_INT 4
93698: PPUSH
93699: CALL 55062 0 2
93703: PUSH
93704: LD_INT 1
93706: ARRAY
93707: ST_TO_ADDR
// if eng > 4 then
93708: LD_VAR 0 6
93712: PUSH
93713: LD_INT 4
93715: GREATER
93716: IFFALSE 93762
// for i = eng downto 4 do
93718: LD_ADDR_VAR 0 3
93722: PUSH
93723: DOUBLE
93724: LD_VAR 0 6
93728: INC
93729: ST_TO_ADDR
93730: LD_INT 4
93732: PUSH
93733: FOR_DOWNTO
93734: IFFALSE 93760
// eng := eng diff eng [ i ] ;
93736: LD_ADDR_VAR 0 6
93740: PUSH
93741: LD_VAR 0 6
93745: PUSH
93746: LD_VAR 0 6
93750: PUSH
93751: LD_VAR 0 3
93755: ARRAY
93756: DIFF
93757: ST_TO_ADDR
93758: GO 93733
93760: POP
93761: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
93762: LD_ADDR_VAR 0 4
93766: PUSH
93767: LD_VAR 0 4
93771: PUSH
93772: LD_VAR 0 5
93776: PUSH
93777: LD_VAR 0 6
93781: UNION
93782: PUSH
93783: LD_VAR 0 7
93787: UNION
93788: PUSH
93789: LD_VAR 0 8
93793: UNION
93794: DIFF
93795: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
93796: LD_ADDR_VAR 0 13
93800: PUSH
93801: LD_EXP 161
93805: PUSH
93806: LD_VAR 0 1
93810: ARRAY
93811: PPUSH
93812: LD_INT 2
93814: PUSH
93815: LD_INT 30
93817: PUSH
93818: LD_INT 32
93820: PUSH
93821: EMPTY
93822: LIST
93823: LIST
93824: PUSH
93825: LD_INT 30
93827: PUSH
93828: LD_INT 31
93830: PUSH
93831: EMPTY
93832: LIST
93833: LIST
93834: PUSH
93835: EMPTY
93836: LIST
93837: LIST
93838: LIST
93839: PPUSH
93840: CALL_OW 72
93844: PUSH
93845: LD_EXP 161
93849: PUSH
93850: LD_VAR 0 1
93854: ARRAY
93855: PPUSH
93856: LD_INT 2
93858: PUSH
93859: LD_INT 30
93861: PUSH
93862: LD_INT 4
93864: PUSH
93865: EMPTY
93866: LIST
93867: LIST
93868: PUSH
93869: LD_INT 30
93871: PUSH
93872: LD_INT 5
93874: PUSH
93875: EMPTY
93876: LIST
93877: LIST
93878: PUSH
93879: EMPTY
93880: LIST
93881: LIST
93882: LIST
93883: PPUSH
93884: CALL_OW 72
93888: PUSH
93889: LD_INT 6
93891: MUL
93892: PLUS
93893: ST_TO_ADDR
// if bcount < tmp then
93894: LD_VAR 0 13
93898: PUSH
93899: LD_VAR 0 4
93903: LESS
93904: IFFALSE 93950
// for i = tmp downto bcount do
93906: LD_ADDR_VAR 0 3
93910: PUSH
93911: DOUBLE
93912: LD_VAR 0 4
93916: INC
93917: ST_TO_ADDR
93918: LD_VAR 0 13
93922: PUSH
93923: FOR_DOWNTO
93924: IFFALSE 93948
// tmp := Delete ( tmp , tmp ) ;
93926: LD_ADDR_VAR 0 4
93930: PUSH
93931: LD_VAR 0 4
93935: PPUSH
93936: LD_VAR 0 4
93940: PPUSH
93941: CALL_OW 3
93945: ST_TO_ADDR
93946: GO 93923
93948: POP
93949: POP
// result := [ tmp , 0 , 0 , p ] ;
93950: LD_ADDR_VAR 0 2
93954: PUSH
93955: LD_VAR 0 4
93959: PUSH
93960: LD_INT 0
93962: PUSH
93963: LD_INT 0
93965: PUSH
93966: LD_VAR 0 11
93970: PUSH
93971: EMPTY
93972: LIST
93973: LIST
93974: LIST
93975: LIST
93976: ST_TO_ADDR
// exit ;
93977: GO 96667
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
93979: LD_EXP 161
93983: PUSH
93984: LD_VAR 0 1
93988: ARRAY
93989: PPUSH
93990: LD_INT 2
93992: PUSH
93993: LD_INT 30
93995: PUSH
93996: LD_INT 6
93998: PUSH
93999: EMPTY
94000: LIST
94001: LIST
94002: PUSH
94003: LD_INT 30
94005: PUSH
94006: LD_INT 7
94008: PUSH
94009: EMPTY
94010: LIST
94011: LIST
94012: PUSH
94013: LD_INT 30
94015: PUSH
94016: LD_INT 8
94018: PUSH
94019: EMPTY
94020: LIST
94021: LIST
94022: PUSH
94023: EMPTY
94024: LIST
94025: LIST
94026: LIST
94027: LIST
94028: PPUSH
94029: CALL_OW 72
94033: NOT
94034: PUSH
94035: LD_EXP 161
94039: PUSH
94040: LD_VAR 0 1
94044: ARRAY
94045: PPUSH
94046: LD_INT 30
94048: PUSH
94049: LD_INT 3
94051: PUSH
94052: EMPTY
94053: LIST
94054: LIST
94055: PPUSH
94056: CALL_OW 72
94060: NOT
94061: AND
94062: IFFALSE 94134
// begin if eng = tmp then
94064: LD_VAR 0 6
94068: PUSH
94069: LD_VAR 0 4
94073: EQUAL
94074: IFFALSE 94078
// exit ;
94076: GO 96667
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
94078: LD_ADDR_EXP 203
94082: PUSH
94083: LD_EXP 203
94087: PPUSH
94088: LD_VAR 0 1
94092: PPUSH
94093: LD_INT 1
94095: PPUSH
94096: CALL_OW 1
94100: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
94101: LD_ADDR_VAR 0 2
94105: PUSH
94106: LD_INT 0
94108: PUSH
94109: LD_VAR 0 4
94113: PUSH
94114: LD_VAR 0 6
94118: DIFF
94119: PUSH
94120: LD_INT 0
94122: PUSH
94123: LD_INT 0
94125: PUSH
94126: EMPTY
94127: LIST
94128: LIST
94129: LIST
94130: LIST
94131: ST_TO_ADDR
// exit ;
94132: GO 96667
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
94134: LD_EXP 188
94138: PUSH
94139: LD_EXP 187
94143: PUSH
94144: LD_VAR 0 1
94148: ARRAY
94149: ARRAY
94150: PUSH
94151: LD_EXP 161
94155: PUSH
94156: LD_VAR 0 1
94160: ARRAY
94161: PPUSH
94162: LD_INT 2
94164: PUSH
94165: LD_INT 30
94167: PUSH
94168: LD_INT 6
94170: PUSH
94171: EMPTY
94172: LIST
94173: LIST
94174: PUSH
94175: LD_INT 30
94177: PUSH
94178: LD_INT 7
94180: PUSH
94181: EMPTY
94182: LIST
94183: LIST
94184: PUSH
94185: LD_INT 30
94187: PUSH
94188: LD_INT 8
94190: PUSH
94191: EMPTY
94192: LIST
94193: LIST
94194: PUSH
94195: EMPTY
94196: LIST
94197: LIST
94198: LIST
94199: LIST
94200: PPUSH
94201: CALL_OW 72
94205: AND
94206: PUSH
94207: LD_EXP 161
94211: PUSH
94212: LD_VAR 0 1
94216: ARRAY
94217: PPUSH
94218: LD_INT 30
94220: PUSH
94221: LD_INT 3
94223: PUSH
94224: EMPTY
94225: LIST
94226: LIST
94227: PPUSH
94228: CALL_OW 72
94232: NOT
94233: AND
94234: IFFALSE 94448
// begin if sci >= 6 then
94236: LD_VAR 0 8
94240: PUSH
94241: LD_INT 6
94243: GREATEREQUAL
94244: IFFALSE 94248
// exit ;
94246: GO 96667
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
94248: LD_ADDR_EXP 203
94252: PUSH
94253: LD_EXP 203
94257: PPUSH
94258: LD_VAR 0 1
94262: PPUSH
94263: LD_INT 2
94265: PPUSH
94266: CALL_OW 1
94270: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
94271: LD_ADDR_VAR 0 9
94275: PUSH
94276: LD_VAR 0 4
94280: PUSH
94281: LD_VAR 0 8
94285: DIFF
94286: PPUSH
94287: LD_INT 4
94289: PPUSH
94290: CALL 55062 0 2
94294: ST_TO_ADDR
// p := [ ] ;
94295: LD_ADDR_VAR 0 11
94299: PUSH
94300: EMPTY
94301: ST_TO_ADDR
// if sci < 6 and sort > 6 then
94302: LD_VAR 0 8
94306: PUSH
94307: LD_INT 6
94309: LESS
94310: PUSH
94311: LD_VAR 0 9
94315: PUSH
94316: LD_INT 6
94318: GREATER
94319: AND
94320: IFFALSE 94401
// begin for i = 1 to 6 - sci do
94322: LD_ADDR_VAR 0 3
94326: PUSH
94327: DOUBLE
94328: LD_INT 1
94330: DEC
94331: ST_TO_ADDR
94332: LD_INT 6
94334: PUSH
94335: LD_VAR 0 8
94339: MINUS
94340: PUSH
94341: FOR_TO
94342: IFFALSE 94397
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
94344: LD_ADDR_VAR 0 11
94348: PUSH
94349: LD_VAR 0 11
94353: PPUSH
94354: LD_VAR 0 11
94358: PUSH
94359: LD_INT 1
94361: PLUS
94362: PPUSH
94363: LD_VAR 0 9
94367: PUSH
94368: LD_INT 1
94370: ARRAY
94371: PPUSH
94372: CALL_OW 2
94376: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
94377: LD_ADDR_VAR 0 9
94381: PUSH
94382: LD_VAR 0 9
94386: PPUSH
94387: LD_INT 1
94389: PPUSH
94390: CALL_OW 3
94394: ST_TO_ADDR
// end ;
94395: GO 94341
94397: POP
94398: POP
// end else
94399: GO 94421
// if sort then
94401: LD_VAR 0 9
94405: IFFALSE 94421
// p := sort [ 1 ] ;
94407: LD_ADDR_VAR 0 11
94411: PUSH
94412: LD_VAR 0 9
94416: PUSH
94417: LD_INT 1
94419: ARRAY
94420: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
94421: LD_ADDR_VAR 0 2
94425: PUSH
94426: LD_INT 0
94428: PUSH
94429: LD_INT 0
94431: PUSH
94432: LD_INT 0
94434: PUSH
94435: LD_VAR 0 11
94439: PUSH
94440: EMPTY
94441: LIST
94442: LIST
94443: LIST
94444: LIST
94445: ST_TO_ADDR
// exit ;
94446: GO 96667
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
94448: LD_EXP 188
94452: PUSH
94453: LD_EXP 187
94457: PUSH
94458: LD_VAR 0 1
94462: ARRAY
94463: ARRAY
94464: PUSH
94465: LD_EXP 161
94469: PUSH
94470: LD_VAR 0 1
94474: ARRAY
94475: PPUSH
94476: LD_INT 2
94478: PUSH
94479: LD_INT 30
94481: PUSH
94482: LD_INT 6
94484: PUSH
94485: EMPTY
94486: LIST
94487: LIST
94488: PUSH
94489: LD_INT 30
94491: PUSH
94492: LD_INT 7
94494: PUSH
94495: EMPTY
94496: LIST
94497: LIST
94498: PUSH
94499: LD_INT 30
94501: PUSH
94502: LD_INT 8
94504: PUSH
94505: EMPTY
94506: LIST
94507: LIST
94508: PUSH
94509: EMPTY
94510: LIST
94511: LIST
94512: LIST
94513: LIST
94514: PPUSH
94515: CALL_OW 72
94519: AND
94520: PUSH
94521: LD_EXP 161
94525: PUSH
94526: LD_VAR 0 1
94530: ARRAY
94531: PPUSH
94532: LD_INT 30
94534: PUSH
94535: LD_INT 3
94537: PUSH
94538: EMPTY
94539: LIST
94540: LIST
94541: PPUSH
94542: CALL_OW 72
94546: AND
94547: IFFALSE 95281
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
94549: LD_ADDR_EXP 203
94553: PUSH
94554: LD_EXP 203
94558: PPUSH
94559: LD_VAR 0 1
94563: PPUSH
94564: LD_INT 3
94566: PPUSH
94567: CALL_OW 1
94571: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
94572: LD_ADDR_VAR 0 2
94576: PUSH
94577: LD_INT 0
94579: PUSH
94580: LD_INT 0
94582: PUSH
94583: LD_INT 0
94585: PUSH
94586: LD_INT 0
94588: PUSH
94589: EMPTY
94590: LIST
94591: LIST
94592: LIST
94593: LIST
94594: ST_TO_ADDR
// if not eng then
94595: LD_VAR 0 6
94599: NOT
94600: IFFALSE 94663
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
94602: LD_ADDR_VAR 0 11
94606: PUSH
94607: LD_VAR 0 4
94611: PPUSH
94612: LD_INT 2
94614: PPUSH
94615: CALL 55062 0 2
94619: PUSH
94620: LD_INT 1
94622: ARRAY
94623: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
94624: LD_ADDR_VAR 0 2
94628: PUSH
94629: LD_VAR 0 2
94633: PPUSH
94634: LD_INT 2
94636: PPUSH
94637: LD_VAR 0 11
94641: PPUSH
94642: CALL_OW 1
94646: ST_TO_ADDR
// tmp := tmp diff p ;
94647: LD_ADDR_VAR 0 4
94651: PUSH
94652: LD_VAR 0 4
94656: PUSH
94657: LD_VAR 0 11
94661: DIFF
94662: ST_TO_ADDR
// end ; if tmp and sci < 6 then
94663: LD_VAR 0 4
94667: PUSH
94668: LD_VAR 0 8
94672: PUSH
94673: LD_INT 6
94675: LESS
94676: AND
94677: IFFALSE 94865
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
94679: LD_ADDR_VAR 0 9
94683: PUSH
94684: LD_VAR 0 4
94688: PUSH
94689: LD_VAR 0 8
94693: PUSH
94694: LD_VAR 0 7
94698: UNION
94699: DIFF
94700: PPUSH
94701: LD_INT 4
94703: PPUSH
94704: CALL 55062 0 2
94708: ST_TO_ADDR
// p := [ ] ;
94709: LD_ADDR_VAR 0 11
94713: PUSH
94714: EMPTY
94715: ST_TO_ADDR
// if sort then
94716: LD_VAR 0 9
94720: IFFALSE 94836
// for i = 1 to 6 - sci do
94722: LD_ADDR_VAR 0 3
94726: PUSH
94727: DOUBLE
94728: LD_INT 1
94730: DEC
94731: ST_TO_ADDR
94732: LD_INT 6
94734: PUSH
94735: LD_VAR 0 8
94739: MINUS
94740: PUSH
94741: FOR_TO
94742: IFFALSE 94834
// begin if i = sort then
94744: LD_VAR 0 3
94748: PUSH
94749: LD_VAR 0 9
94753: EQUAL
94754: IFFALSE 94758
// break ;
94756: GO 94834
// if GetClass ( i ) = 4 then
94758: LD_VAR 0 3
94762: PPUSH
94763: CALL_OW 257
94767: PUSH
94768: LD_INT 4
94770: EQUAL
94771: IFFALSE 94775
// continue ;
94773: GO 94741
// p := Insert ( p , p + 1 , sort [ i ] ) ;
94775: LD_ADDR_VAR 0 11
94779: PUSH
94780: LD_VAR 0 11
94784: PPUSH
94785: LD_VAR 0 11
94789: PUSH
94790: LD_INT 1
94792: PLUS
94793: PPUSH
94794: LD_VAR 0 9
94798: PUSH
94799: LD_VAR 0 3
94803: ARRAY
94804: PPUSH
94805: CALL_OW 2
94809: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
94810: LD_ADDR_VAR 0 4
94814: PUSH
94815: LD_VAR 0 4
94819: PUSH
94820: LD_VAR 0 9
94824: PUSH
94825: LD_VAR 0 3
94829: ARRAY
94830: DIFF
94831: ST_TO_ADDR
// end ;
94832: GO 94741
94834: POP
94835: POP
// if p then
94836: LD_VAR 0 11
94840: IFFALSE 94865
// result := Replace ( result , 4 , p ) ;
94842: LD_ADDR_VAR 0 2
94846: PUSH
94847: LD_VAR 0 2
94851: PPUSH
94852: LD_INT 4
94854: PPUSH
94855: LD_VAR 0 11
94859: PPUSH
94860: CALL_OW 1
94864: ST_TO_ADDR
// end ; if tmp and mech < 6 then
94865: LD_VAR 0 4
94869: PUSH
94870: LD_VAR 0 7
94874: PUSH
94875: LD_INT 6
94877: LESS
94878: AND
94879: IFFALSE 95067
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
94881: LD_ADDR_VAR 0 9
94885: PUSH
94886: LD_VAR 0 4
94890: PUSH
94891: LD_VAR 0 8
94895: PUSH
94896: LD_VAR 0 7
94900: UNION
94901: DIFF
94902: PPUSH
94903: LD_INT 3
94905: PPUSH
94906: CALL 55062 0 2
94910: ST_TO_ADDR
// p := [ ] ;
94911: LD_ADDR_VAR 0 11
94915: PUSH
94916: EMPTY
94917: ST_TO_ADDR
// if sort then
94918: LD_VAR 0 9
94922: IFFALSE 95038
// for i = 1 to 6 - mech do
94924: LD_ADDR_VAR 0 3
94928: PUSH
94929: DOUBLE
94930: LD_INT 1
94932: DEC
94933: ST_TO_ADDR
94934: LD_INT 6
94936: PUSH
94937: LD_VAR 0 7
94941: MINUS
94942: PUSH
94943: FOR_TO
94944: IFFALSE 95036
// begin if i = sort then
94946: LD_VAR 0 3
94950: PUSH
94951: LD_VAR 0 9
94955: EQUAL
94956: IFFALSE 94960
// break ;
94958: GO 95036
// if GetClass ( i ) = 3 then
94960: LD_VAR 0 3
94964: PPUSH
94965: CALL_OW 257
94969: PUSH
94970: LD_INT 3
94972: EQUAL
94973: IFFALSE 94977
// continue ;
94975: GO 94943
// p := Insert ( p , p + 1 , sort [ i ] ) ;
94977: LD_ADDR_VAR 0 11
94981: PUSH
94982: LD_VAR 0 11
94986: PPUSH
94987: LD_VAR 0 11
94991: PUSH
94992: LD_INT 1
94994: PLUS
94995: PPUSH
94996: LD_VAR 0 9
95000: PUSH
95001: LD_VAR 0 3
95005: ARRAY
95006: PPUSH
95007: CALL_OW 2
95011: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
95012: LD_ADDR_VAR 0 4
95016: PUSH
95017: LD_VAR 0 4
95021: PUSH
95022: LD_VAR 0 9
95026: PUSH
95027: LD_VAR 0 3
95031: ARRAY
95032: DIFF
95033: ST_TO_ADDR
// end ;
95034: GO 94943
95036: POP
95037: POP
// if p then
95038: LD_VAR 0 11
95042: IFFALSE 95067
// result := Replace ( result , 3 , p ) ;
95044: LD_ADDR_VAR 0 2
95048: PUSH
95049: LD_VAR 0 2
95053: PPUSH
95054: LD_INT 3
95056: PPUSH
95057: LD_VAR 0 11
95061: PPUSH
95062: CALL_OW 1
95066: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
95067: LD_VAR 0 4
95071: PUSH
95072: LD_INT 6
95074: GREATER
95075: PUSH
95076: LD_VAR 0 6
95080: PUSH
95081: LD_INT 6
95083: LESS
95084: AND
95085: IFFALSE 95279
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
95087: LD_ADDR_VAR 0 9
95091: PUSH
95092: LD_VAR 0 4
95096: PUSH
95097: LD_VAR 0 8
95101: PUSH
95102: LD_VAR 0 7
95106: UNION
95107: PUSH
95108: LD_VAR 0 6
95112: UNION
95113: DIFF
95114: PPUSH
95115: LD_INT 2
95117: PPUSH
95118: CALL 55062 0 2
95122: ST_TO_ADDR
// p := [ ] ;
95123: LD_ADDR_VAR 0 11
95127: PUSH
95128: EMPTY
95129: ST_TO_ADDR
// if sort then
95130: LD_VAR 0 9
95134: IFFALSE 95250
// for i = 1 to 6 - eng do
95136: LD_ADDR_VAR 0 3
95140: PUSH
95141: DOUBLE
95142: LD_INT 1
95144: DEC
95145: ST_TO_ADDR
95146: LD_INT 6
95148: PUSH
95149: LD_VAR 0 6
95153: MINUS
95154: PUSH
95155: FOR_TO
95156: IFFALSE 95248
// begin if i = sort then
95158: LD_VAR 0 3
95162: PUSH
95163: LD_VAR 0 9
95167: EQUAL
95168: IFFALSE 95172
// break ;
95170: GO 95248
// if GetClass ( i ) = 2 then
95172: LD_VAR 0 3
95176: PPUSH
95177: CALL_OW 257
95181: PUSH
95182: LD_INT 2
95184: EQUAL
95185: IFFALSE 95189
// continue ;
95187: GO 95155
// p := Insert ( p , p + 1 , sort [ i ] ) ;
95189: LD_ADDR_VAR 0 11
95193: PUSH
95194: LD_VAR 0 11
95198: PPUSH
95199: LD_VAR 0 11
95203: PUSH
95204: LD_INT 1
95206: PLUS
95207: PPUSH
95208: LD_VAR 0 9
95212: PUSH
95213: LD_VAR 0 3
95217: ARRAY
95218: PPUSH
95219: CALL_OW 2
95223: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
95224: LD_ADDR_VAR 0 4
95228: PUSH
95229: LD_VAR 0 4
95233: PUSH
95234: LD_VAR 0 9
95238: PUSH
95239: LD_VAR 0 3
95243: ARRAY
95244: DIFF
95245: ST_TO_ADDR
// end ;
95246: GO 95155
95248: POP
95249: POP
// if p then
95250: LD_VAR 0 11
95254: IFFALSE 95279
// result := Replace ( result , 2 , p ) ;
95256: LD_ADDR_VAR 0 2
95260: PUSH
95261: LD_VAR 0 2
95265: PPUSH
95266: LD_INT 2
95268: PPUSH
95269: LD_VAR 0 11
95273: PPUSH
95274: CALL_OW 1
95278: ST_TO_ADDR
// end ; exit ;
95279: GO 96667
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
95281: LD_EXP 188
95285: PUSH
95286: LD_EXP 187
95290: PUSH
95291: LD_VAR 0 1
95295: ARRAY
95296: ARRAY
95297: NOT
95298: PUSH
95299: LD_EXP 161
95303: PUSH
95304: LD_VAR 0 1
95308: ARRAY
95309: PPUSH
95310: LD_INT 30
95312: PUSH
95313: LD_INT 3
95315: PUSH
95316: EMPTY
95317: LIST
95318: LIST
95319: PPUSH
95320: CALL_OW 72
95324: AND
95325: PUSH
95326: LD_EXP 166
95330: PUSH
95331: LD_VAR 0 1
95335: ARRAY
95336: AND
95337: IFFALSE 95945
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
95339: LD_ADDR_EXP 203
95343: PUSH
95344: LD_EXP 203
95348: PPUSH
95349: LD_VAR 0 1
95353: PPUSH
95354: LD_INT 5
95356: PPUSH
95357: CALL_OW 1
95361: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
95362: LD_ADDR_VAR 0 2
95366: PUSH
95367: LD_INT 0
95369: PUSH
95370: LD_INT 0
95372: PUSH
95373: LD_INT 0
95375: PUSH
95376: LD_INT 0
95378: PUSH
95379: EMPTY
95380: LIST
95381: LIST
95382: LIST
95383: LIST
95384: ST_TO_ADDR
// if sci > 1 then
95385: LD_VAR 0 8
95389: PUSH
95390: LD_INT 1
95392: GREATER
95393: IFFALSE 95421
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
95395: LD_ADDR_VAR 0 4
95399: PUSH
95400: LD_VAR 0 4
95404: PUSH
95405: LD_VAR 0 8
95409: PUSH
95410: LD_VAR 0 8
95414: PUSH
95415: LD_INT 1
95417: ARRAY
95418: DIFF
95419: DIFF
95420: ST_TO_ADDR
// if tmp and not sci then
95421: LD_VAR 0 4
95425: PUSH
95426: LD_VAR 0 8
95430: NOT
95431: AND
95432: IFFALSE 95501
// begin sort := SortBySkill ( tmp , 4 ) ;
95434: LD_ADDR_VAR 0 9
95438: PUSH
95439: LD_VAR 0 4
95443: PPUSH
95444: LD_INT 4
95446: PPUSH
95447: CALL 55062 0 2
95451: ST_TO_ADDR
// if sort then
95452: LD_VAR 0 9
95456: IFFALSE 95472
// p := sort [ 1 ] ;
95458: LD_ADDR_VAR 0 11
95462: PUSH
95463: LD_VAR 0 9
95467: PUSH
95468: LD_INT 1
95470: ARRAY
95471: ST_TO_ADDR
// if p then
95472: LD_VAR 0 11
95476: IFFALSE 95501
// result := Replace ( result , 4 , p ) ;
95478: LD_ADDR_VAR 0 2
95482: PUSH
95483: LD_VAR 0 2
95487: PPUSH
95488: LD_INT 4
95490: PPUSH
95491: LD_VAR 0 11
95495: PPUSH
95496: CALL_OW 1
95500: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
95501: LD_ADDR_VAR 0 4
95505: PUSH
95506: LD_VAR 0 4
95510: PUSH
95511: LD_VAR 0 7
95515: DIFF
95516: ST_TO_ADDR
// if tmp and mech < 6 then
95517: LD_VAR 0 4
95521: PUSH
95522: LD_VAR 0 7
95526: PUSH
95527: LD_INT 6
95529: LESS
95530: AND
95531: IFFALSE 95719
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
95533: LD_ADDR_VAR 0 9
95537: PUSH
95538: LD_VAR 0 4
95542: PUSH
95543: LD_VAR 0 8
95547: PUSH
95548: LD_VAR 0 7
95552: UNION
95553: DIFF
95554: PPUSH
95555: LD_INT 3
95557: PPUSH
95558: CALL 55062 0 2
95562: ST_TO_ADDR
// p := [ ] ;
95563: LD_ADDR_VAR 0 11
95567: PUSH
95568: EMPTY
95569: ST_TO_ADDR
// if sort then
95570: LD_VAR 0 9
95574: IFFALSE 95690
// for i = 1 to 6 - mech do
95576: LD_ADDR_VAR 0 3
95580: PUSH
95581: DOUBLE
95582: LD_INT 1
95584: DEC
95585: ST_TO_ADDR
95586: LD_INT 6
95588: PUSH
95589: LD_VAR 0 7
95593: MINUS
95594: PUSH
95595: FOR_TO
95596: IFFALSE 95688
// begin if i = sort then
95598: LD_VAR 0 3
95602: PUSH
95603: LD_VAR 0 9
95607: EQUAL
95608: IFFALSE 95612
// break ;
95610: GO 95688
// if GetClass ( i ) = 3 then
95612: LD_VAR 0 3
95616: PPUSH
95617: CALL_OW 257
95621: PUSH
95622: LD_INT 3
95624: EQUAL
95625: IFFALSE 95629
// continue ;
95627: GO 95595
// p := Insert ( p , p + 1 , sort [ i ] ) ;
95629: LD_ADDR_VAR 0 11
95633: PUSH
95634: LD_VAR 0 11
95638: PPUSH
95639: LD_VAR 0 11
95643: PUSH
95644: LD_INT 1
95646: PLUS
95647: PPUSH
95648: LD_VAR 0 9
95652: PUSH
95653: LD_VAR 0 3
95657: ARRAY
95658: PPUSH
95659: CALL_OW 2
95663: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
95664: LD_ADDR_VAR 0 4
95668: PUSH
95669: LD_VAR 0 4
95673: PUSH
95674: LD_VAR 0 9
95678: PUSH
95679: LD_VAR 0 3
95683: ARRAY
95684: DIFF
95685: ST_TO_ADDR
// end ;
95686: GO 95595
95688: POP
95689: POP
// if p then
95690: LD_VAR 0 11
95694: IFFALSE 95719
// result := Replace ( result , 3 , p ) ;
95696: LD_ADDR_VAR 0 2
95700: PUSH
95701: LD_VAR 0 2
95705: PPUSH
95706: LD_INT 3
95708: PPUSH
95709: LD_VAR 0 11
95713: PPUSH
95714: CALL_OW 1
95718: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
95719: LD_ADDR_VAR 0 4
95723: PUSH
95724: LD_VAR 0 4
95728: PUSH
95729: LD_VAR 0 6
95733: DIFF
95734: ST_TO_ADDR
// if tmp and eng < 6 then
95735: LD_VAR 0 4
95739: PUSH
95740: LD_VAR 0 6
95744: PUSH
95745: LD_INT 6
95747: LESS
95748: AND
95749: IFFALSE 95943
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
95751: LD_ADDR_VAR 0 9
95755: PUSH
95756: LD_VAR 0 4
95760: PUSH
95761: LD_VAR 0 8
95765: PUSH
95766: LD_VAR 0 7
95770: UNION
95771: PUSH
95772: LD_VAR 0 6
95776: UNION
95777: DIFF
95778: PPUSH
95779: LD_INT 2
95781: PPUSH
95782: CALL 55062 0 2
95786: ST_TO_ADDR
// p := [ ] ;
95787: LD_ADDR_VAR 0 11
95791: PUSH
95792: EMPTY
95793: ST_TO_ADDR
// if sort then
95794: LD_VAR 0 9
95798: IFFALSE 95914
// for i = 1 to 6 - eng do
95800: LD_ADDR_VAR 0 3
95804: PUSH
95805: DOUBLE
95806: LD_INT 1
95808: DEC
95809: ST_TO_ADDR
95810: LD_INT 6
95812: PUSH
95813: LD_VAR 0 6
95817: MINUS
95818: PUSH
95819: FOR_TO
95820: IFFALSE 95912
// begin if i = sort then
95822: LD_VAR 0 3
95826: PUSH
95827: LD_VAR 0 9
95831: EQUAL
95832: IFFALSE 95836
// break ;
95834: GO 95912
// if GetClass ( i ) = 2 then
95836: LD_VAR 0 3
95840: PPUSH
95841: CALL_OW 257
95845: PUSH
95846: LD_INT 2
95848: EQUAL
95849: IFFALSE 95853
// continue ;
95851: GO 95819
// p := Insert ( p , p + 1 , sort [ i ] ) ;
95853: LD_ADDR_VAR 0 11
95857: PUSH
95858: LD_VAR 0 11
95862: PPUSH
95863: LD_VAR 0 11
95867: PUSH
95868: LD_INT 1
95870: PLUS
95871: PPUSH
95872: LD_VAR 0 9
95876: PUSH
95877: LD_VAR 0 3
95881: ARRAY
95882: PPUSH
95883: CALL_OW 2
95887: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
95888: LD_ADDR_VAR 0 4
95892: PUSH
95893: LD_VAR 0 4
95897: PUSH
95898: LD_VAR 0 9
95902: PUSH
95903: LD_VAR 0 3
95907: ARRAY
95908: DIFF
95909: ST_TO_ADDR
// end ;
95910: GO 95819
95912: POP
95913: POP
// if p then
95914: LD_VAR 0 11
95918: IFFALSE 95943
// result := Replace ( result , 2 , p ) ;
95920: LD_ADDR_VAR 0 2
95924: PUSH
95925: LD_VAR 0 2
95929: PPUSH
95930: LD_INT 2
95932: PPUSH
95933: LD_VAR 0 11
95937: PPUSH
95938: CALL_OW 1
95942: ST_TO_ADDR
// end ; exit ;
95943: GO 96667
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
95945: LD_EXP 188
95949: PUSH
95950: LD_EXP 187
95954: PUSH
95955: LD_VAR 0 1
95959: ARRAY
95960: ARRAY
95961: NOT
95962: PUSH
95963: LD_EXP 161
95967: PUSH
95968: LD_VAR 0 1
95972: ARRAY
95973: PPUSH
95974: LD_INT 30
95976: PUSH
95977: LD_INT 3
95979: PUSH
95980: EMPTY
95981: LIST
95982: LIST
95983: PPUSH
95984: CALL_OW 72
95988: AND
95989: PUSH
95990: LD_EXP 166
95994: PUSH
95995: LD_VAR 0 1
95999: ARRAY
96000: NOT
96001: AND
96002: IFFALSE 96667
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
96004: LD_ADDR_EXP 203
96008: PUSH
96009: LD_EXP 203
96013: PPUSH
96014: LD_VAR 0 1
96018: PPUSH
96019: LD_INT 6
96021: PPUSH
96022: CALL_OW 1
96026: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
96027: LD_ADDR_VAR 0 2
96031: PUSH
96032: LD_INT 0
96034: PUSH
96035: LD_INT 0
96037: PUSH
96038: LD_INT 0
96040: PUSH
96041: LD_INT 0
96043: PUSH
96044: EMPTY
96045: LIST
96046: LIST
96047: LIST
96048: LIST
96049: ST_TO_ADDR
// if sci >= 1 then
96050: LD_VAR 0 8
96054: PUSH
96055: LD_INT 1
96057: GREATEREQUAL
96058: IFFALSE 96080
// tmp := tmp diff sci [ 1 ] ;
96060: LD_ADDR_VAR 0 4
96064: PUSH
96065: LD_VAR 0 4
96069: PUSH
96070: LD_VAR 0 8
96074: PUSH
96075: LD_INT 1
96077: ARRAY
96078: DIFF
96079: ST_TO_ADDR
// if tmp and not sci then
96080: LD_VAR 0 4
96084: PUSH
96085: LD_VAR 0 8
96089: NOT
96090: AND
96091: IFFALSE 96160
// begin sort := SortBySkill ( tmp , 4 ) ;
96093: LD_ADDR_VAR 0 9
96097: PUSH
96098: LD_VAR 0 4
96102: PPUSH
96103: LD_INT 4
96105: PPUSH
96106: CALL 55062 0 2
96110: ST_TO_ADDR
// if sort then
96111: LD_VAR 0 9
96115: IFFALSE 96131
// p := sort [ 1 ] ;
96117: LD_ADDR_VAR 0 11
96121: PUSH
96122: LD_VAR 0 9
96126: PUSH
96127: LD_INT 1
96129: ARRAY
96130: ST_TO_ADDR
// if p then
96131: LD_VAR 0 11
96135: IFFALSE 96160
// result := Replace ( result , 4 , p ) ;
96137: LD_ADDR_VAR 0 2
96141: PUSH
96142: LD_VAR 0 2
96146: PPUSH
96147: LD_INT 4
96149: PPUSH
96150: LD_VAR 0 11
96154: PPUSH
96155: CALL_OW 1
96159: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
96160: LD_ADDR_VAR 0 4
96164: PUSH
96165: LD_VAR 0 4
96169: PUSH
96170: LD_VAR 0 7
96174: DIFF
96175: ST_TO_ADDR
// if tmp and mech < 6 then
96176: LD_VAR 0 4
96180: PUSH
96181: LD_VAR 0 7
96185: PUSH
96186: LD_INT 6
96188: LESS
96189: AND
96190: IFFALSE 96372
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
96192: LD_ADDR_VAR 0 9
96196: PUSH
96197: LD_VAR 0 4
96201: PUSH
96202: LD_VAR 0 7
96206: DIFF
96207: PPUSH
96208: LD_INT 3
96210: PPUSH
96211: CALL 55062 0 2
96215: ST_TO_ADDR
// p := [ ] ;
96216: LD_ADDR_VAR 0 11
96220: PUSH
96221: EMPTY
96222: ST_TO_ADDR
// if sort then
96223: LD_VAR 0 9
96227: IFFALSE 96343
// for i = 1 to 6 - mech do
96229: LD_ADDR_VAR 0 3
96233: PUSH
96234: DOUBLE
96235: LD_INT 1
96237: DEC
96238: ST_TO_ADDR
96239: LD_INT 6
96241: PUSH
96242: LD_VAR 0 7
96246: MINUS
96247: PUSH
96248: FOR_TO
96249: IFFALSE 96341
// begin if i = sort then
96251: LD_VAR 0 3
96255: PUSH
96256: LD_VAR 0 9
96260: EQUAL
96261: IFFALSE 96265
// break ;
96263: GO 96341
// if GetClass ( i ) = 3 then
96265: LD_VAR 0 3
96269: PPUSH
96270: CALL_OW 257
96274: PUSH
96275: LD_INT 3
96277: EQUAL
96278: IFFALSE 96282
// continue ;
96280: GO 96248
// p := Insert ( p , p + 1 , sort [ i ] ) ;
96282: LD_ADDR_VAR 0 11
96286: PUSH
96287: LD_VAR 0 11
96291: PPUSH
96292: LD_VAR 0 11
96296: PUSH
96297: LD_INT 1
96299: PLUS
96300: PPUSH
96301: LD_VAR 0 9
96305: PUSH
96306: LD_VAR 0 3
96310: ARRAY
96311: PPUSH
96312: CALL_OW 2
96316: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
96317: LD_ADDR_VAR 0 4
96321: PUSH
96322: LD_VAR 0 4
96326: PUSH
96327: LD_VAR 0 9
96331: PUSH
96332: LD_VAR 0 3
96336: ARRAY
96337: DIFF
96338: ST_TO_ADDR
// end ;
96339: GO 96248
96341: POP
96342: POP
// if p then
96343: LD_VAR 0 11
96347: IFFALSE 96372
// result := Replace ( result , 3 , p ) ;
96349: LD_ADDR_VAR 0 2
96353: PUSH
96354: LD_VAR 0 2
96358: PPUSH
96359: LD_INT 3
96361: PPUSH
96362: LD_VAR 0 11
96366: PPUSH
96367: CALL_OW 1
96371: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
96372: LD_ADDR_VAR 0 4
96376: PUSH
96377: LD_VAR 0 4
96381: PUSH
96382: LD_VAR 0 6
96386: DIFF
96387: ST_TO_ADDR
// if tmp and eng < 4 then
96388: LD_VAR 0 4
96392: PUSH
96393: LD_VAR 0 6
96397: PUSH
96398: LD_INT 4
96400: LESS
96401: AND
96402: IFFALSE 96592
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
96404: LD_ADDR_VAR 0 9
96408: PUSH
96409: LD_VAR 0 4
96413: PUSH
96414: LD_VAR 0 7
96418: PUSH
96419: LD_VAR 0 6
96423: UNION
96424: DIFF
96425: PPUSH
96426: LD_INT 2
96428: PPUSH
96429: CALL 55062 0 2
96433: ST_TO_ADDR
// p := [ ] ;
96434: LD_ADDR_VAR 0 11
96438: PUSH
96439: EMPTY
96440: ST_TO_ADDR
// if sort then
96441: LD_VAR 0 9
96445: IFFALSE 96561
// for i = 1 to 4 - eng do
96447: LD_ADDR_VAR 0 3
96451: PUSH
96452: DOUBLE
96453: LD_INT 1
96455: DEC
96456: ST_TO_ADDR
96457: LD_INT 4
96459: PUSH
96460: LD_VAR 0 6
96464: MINUS
96465: PUSH
96466: FOR_TO
96467: IFFALSE 96559
// begin if i = sort then
96469: LD_VAR 0 3
96473: PUSH
96474: LD_VAR 0 9
96478: EQUAL
96479: IFFALSE 96483
// break ;
96481: GO 96559
// if GetClass ( i ) = 2 then
96483: LD_VAR 0 3
96487: PPUSH
96488: CALL_OW 257
96492: PUSH
96493: LD_INT 2
96495: EQUAL
96496: IFFALSE 96500
// continue ;
96498: GO 96466
// p := Insert ( p , p + 1 , sort [ i ] ) ;
96500: LD_ADDR_VAR 0 11
96504: PUSH
96505: LD_VAR 0 11
96509: PPUSH
96510: LD_VAR 0 11
96514: PUSH
96515: LD_INT 1
96517: PLUS
96518: PPUSH
96519: LD_VAR 0 9
96523: PUSH
96524: LD_VAR 0 3
96528: ARRAY
96529: PPUSH
96530: CALL_OW 2
96534: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
96535: LD_ADDR_VAR 0 4
96539: PUSH
96540: LD_VAR 0 4
96544: PUSH
96545: LD_VAR 0 9
96549: PUSH
96550: LD_VAR 0 3
96554: ARRAY
96555: DIFF
96556: ST_TO_ADDR
// end ;
96557: GO 96466
96559: POP
96560: POP
// if p then
96561: LD_VAR 0 11
96565: IFFALSE 96590
// result := Replace ( result , 2 , p ) ;
96567: LD_ADDR_VAR 0 2
96571: PUSH
96572: LD_VAR 0 2
96576: PPUSH
96577: LD_INT 2
96579: PPUSH
96580: LD_VAR 0 11
96584: PPUSH
96585: CALL_OW 1
96589: ST_TO_ADDR
// end else
96590: GO 96636
// for i = eng downto 5 do
96592: LD_ADDR_VAR 0 3
96596: PUSH
96597: DOUBLE
96598: LD_VAR 0 6
96602: INC
96603: ST_TO_ADDR
96604: LD_INT 5
96606: PUSH
96607: FOR_DOWNTO
96608: IFFALSE 96634
// tmp := tmp union eng [ i ] ;
96610: LD_ADDR_VAR 0 4
96614: PUSH
96615: LD_VAR 0 4
96619: PUSH
96620: LD_VAR 0 6
96624: PUSH
96625: LD_VAR 0 3
96629: ARRAY
96630: UNION
96631: ST_TO_ADDR
96632: GO 96607
96634: POP
96635: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
96636: LD_ADDR_VAR 0 2
96640: PUSH
96641: LD_VAR 0 2
96645: PPUSH
96646: LD_INT 1
96648: PPUSH
96649: LD_VAR 0 4
96653: PUSH
96654: LD_VAR 0 5
96658: DIFF
96659: PPUSH
96660: CALL_OW 1
96664: ST_TO_ADDR
// exit ;
96665: GO 96667
// end ; end ;
96667: LD_VAR 0 2
96671: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
96672: LD_INT 0
96674: PPUSH
96675: PPUSH
96676: PPUSH
// if not mc_bases then
96677: LD_EXP 161
96681: NOT
96682: IFFALSE 96686
// exit ;
96684: GO 96828
// for i = 1 to mc_bases do
96686: LD_ADDR_VAR 0 2
96690: PUSH
96691: DOUBLE
96692: LD_INT 1
96694: DEC
96695: ST_TO_ADDR
96696: LD_EXP 161
96700: PUSH
96701: FOR_TO
96702: IFFALSE 96819
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
96704: LD_ADDR_VAR 0 3
96708: PUSH
96709: LD_EXP 161
96713: PUSH
96714: LD_VAR 0 2
96718: ARRAY
96719: PPUSH
96720: LD_INT 21
96722: PUSH
96723: LD_INT 3
96725: PUSH
96726: EMPTY
96727: LIST
96728: LIST
96729: PUSH
96730: LD_INT 3
96732: PUSH
96733: LD_INT 2
96735: PUSH
96736: LD_INT 30
96738: PUSH
96739: LD_INT 29
96741: PUSH
96742: EMPTY
96743: LIST
96744: LIST
96745: PUSH
96746: LD_INT 30
96748: PUSH
96749: LD_INT 30
96751: PUSH
96752: EMPTY
96753: LIST
96754: LIST
96755: PUSH
96756: EMPTY
96757: LIST
96758: LIST
96759: LIST
96760: PUSH
96761: EMPTY
96762: LIST
96763: LIST
96764: PUSH
96765: LD_INT 3
96767: PUSH
96768: LD_INT 24
96770: PUSH
96771: LD_INT 1000
96773: PUSH
96774: EMPTY
96775: LIST
96776: LIST
96777: PUSH
96778: EMPTY
96779: LIST
96780: LIST
96781: PUSH
96782: EMPTY
96783: LIST
96784: LIST
96785: LIST
96786: PPUSH
96787: CALL_OW 72
96791: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
96792: LD_ADDR_EXP 162
96796: PUSH
96797: LD_EXP 162
96801: PPUSH
96802: LD_VAR 0 2
96806: PPUSH
96807: LD_VAR 0 3
96811: PPUSH
96812: CALL_OW 1
96816: ST_TO_ADDR
// end ;
96817: GO 96701
96819: POP
96820: POP
// RaiseSailEvent ( 101 ) ;
96821: LD_INT 101
96823: PPUSH
96824: CALL_OW 427
// end ;
96828: LD_VAR 0 1
96832: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
96833: LD_INT 0
96835: PPUSH
96836: PPUSH
96837: PPUSH
96838: PPUSH
96839: PPUSH
96840: PPUSH
96841: PPUSH
// if not mc_bases then
96842: LD_EXP 161
96846: NOT
96847: IFFALSE 96851
// exit ;
96849: GO 97413
// for i = 1 to mc_bases do
96851: LD_ADDR_VAR 0 2
96855: PUSH
96856: DOUBLE
96857: LD_INT 1
96859: DEC
96860: ST_TO_ADDR
96861: LD_EXP 161
96865: PUSH
96866: FOR_TO
96867: IFFALSE 97404
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 1000 ] ] ] ] ) ;
96869: LD_ADDR_VAR 0 5
96873: PUSH
96874: LD_EXP 161
96878: PUSH
96879: LD_VAR 0 2
96883: ARRAY
96884: PUSH
96885: LD_EXP 190
96889: PUSH
96890: LD_VAR 0 2
96894: ARRAY
96895: UNION
96896: PPUSH
96897: LD_INT 21
96899: PUSH
96900: LD_INT 1
96902: PUSH
96903: EMPTY
96904: LIST
96905: LIST
96906: PUSH
96907: LD_INT 1
96909: PUSH
96910: LD_INT 3
96912: PUSH
96913: LD_INT 54
96915: PUSH
96916: EMPTY
96917: LIST
96918: PUSH
96919: EMPTY
96920: LIST
96921: LIST
96922: PUSH
96923: LD_INT 3
96925: PUSH
96926: LD_INT 24
96928: PUSH
96929: LD_INT 1000
96931: PUSH
96932: EMPTY
96933: LIST
96934: LIST
96935: PUSH
96936: EMPTY
96937: LIST
96938: LIST
96939: PUSH
96940: EMPTY
96941: LIST
96942: LIST
96943: LIST
96944: PUSH
96945: EMPTY
96946: LIST
96947: LIST
96948: PPUSH
96949: CALL_OW 72
96953: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
96954: LD_ADDR_VAR 0 6
96958: PUSH
96959: LD_EXP 161
96963: PUSH
96964: LD_VAR 0 2
96968: ARRAY
96969: PPUSH
96970: LD_INT 21
96972: PUSH
96973: LD_INT 1
96975: PUSH
96976: EMPTY
96977: LIST
96978: LIST
96979: PUSH
96980: LD_INT 1
96982: PUSH
96983: LD_INT 3
96985: PUSH
96986: LD_INT 54
96988: PUSH
96989: EMPTY
96990: LIST
96991: PUSH
96992: EMPTY
96993: LIST
96994: LIST
96995: PUSH
96996: LD_INT 3
96998: PUSH
96999: LD_INT 24
97001: PUSH
97002: LD_INT 250
97004: PUSH
97005: EMPTY
97006: LIST
97007: LIST
97008: PUSH
97009: EMPTY
97010: LIST
97011: LIST
97012: PUSH
97013: EMPTY
97014: LIST
97015: LIST
97016: LIST
97017: PUSH
97018: EMPTY
97019: LIST
97020: LIST
97021: PPUSH
97022: CALL_OW 72
97026: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
97027: LD_ADDR_VAR 0 7
97031: PUSH
97032: LD_VAR 0 5
97036: PUSH
97037: LD_VAR 0 6
97041: DIFF
97042: ST_TO_ADDR
// if not need_heal_1 then
97043: LD_VAR 0 6
97047: NOT
97048: IFFALSE 97081
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
97050: LD_ADDR_EXP 164
97054: PUSH
97055: LD_EXP 164
97059: PPUSH
97060: LD_VAR 0 2
97064: PUSH
97065: LD_INT 1
97067: PUSH
97068: EMPTY
97069: LIST
97070: LIST
97071: PPUSH
97072: EMPTY
97073: PPUSH
97074: CALL 24186 0 3
97078: ST_TO_ADDR
97079: GO 97151
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
97081: LD_ADDR_EXP 164
97085: PUSH
97086: LD_EXP 164
97090: PPUSH
97091: LD_VAR 0 2
97095: PUSH
97096: LD_INT 1
97098: PUSH
97099: EMPTY
97100: LIST
97101: LIST
97102: PPUSH
97103: LD_EXP 164
97107: PUSH
97108: LD_VAR 0 2
97112: ARRAY
97113: PUSH
97114: LD_INT 1
97116: ARRAY
97117: PPUSH
97118: LD_INT 3
97120: PUSH
97121: LD_INT 24
97123: PUSH
97124: LD_INT 1000
97126: PUSH
97127: EMPTY
97128: LIST
97129: LIST
97130: PUSH
97131: EMPTY
97132: LIST
97133: LIST
97134: PPUSH
97135: CALL_OW 72
97139: PUSH
97140: LD_VAR 0 6
97144: UNION
97145: PPUSH
97146: CALL 24186 0 3
97150: ST_TO_ADDR
// if not need_heal_2 then
97151: LD_VAR 0 7
97155: NOT
97156: IFFALSE 97189
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
97158: LD_ADDR_EXP 164
97162: PUSH
97163: LD_EXP 164
97167: PPUSH
97168: LD_VAR 0 2
97172: PUSH
97173: LD_INT 2
97175: PUSH
97176: EMPTY
97177: LIST
97178: LIST
97179: PPUSH
97180: EMPTY
97181: PPUSH
97182: CALL 24186 0 3
97186: ST_TO_ADDR
97187: GO 97221
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
97189: LD_ADDR_EXP 164
97193: PUSH
97194: LD_EXP 164
97198: PPUSH
97199: LD_VAR 0 2
97203: PUSH
97204: LD_INT 2
97206: PUSH
97207: EMPTY
97208: LIST
97209: LIST
97210: PPUSH
97211: LD_VAR 0 7
97215: PPUSH
97216: CALL 24186 0 3
97220: ST_TO_ADDR
// if need_heal_2 then
97221: LD_VAR 0 7
97225: IFFALSE 97386
// for j in need_heal_2 do
97227: LD_ADDR_VAR 0 3
97231: PUSH
97232: LD_VAR 0 7
97236: PUSH
97237: FOR_IN
97238: IFFALSE 97384
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
97240: LD_ADDR_VAR 0 5
97244: PUSH
97245: LD_EXP 161
97249: PUSH
97250: LD_VAR 0 2
97254: ARRAY
97255: PPUSH
97256: LD_INT 2
97258: PUSH
97259: LD_INT 30
97261: PUSH
97262: LD_INT 6
97264: PUSH
97265: EMPTY
97266: LIST
97267: LIST
97268: PUSH
97269: LD_INT 30
97271: PUSH
97272: LD_INT 7
97274: PUSH
97275: EMPTY
97276: LIST
97277: LIST
97278: PUSH
97279: LD_INT 30
97281: PUSH
97282: LD_INT 8
97284: PUSH
97285: EMPTY
97286: LIST
97287: LIST
97288: PUSH
97289: LD_INT 30
97291: PUSH
97292: LD_INT 0
97294: PUSH
97295: EMPTY
97296: LIST
97297: LIST
97298: PUSH
97299: LD_INT 30
97301: PUSH
97302: LD_INT 1
97304: PUSH
97305: EMPTY
97306: LIST
97307: LIST
97308: PUSH
97309: EMPTY
97310: LIST
97311: LIST
97312: LIST
97313: LIST
97314: LIST
97315: LIST
97316: PPUSH
97317: CALL_OW 72
97321: ST_TO_ADDR
// if tmp then
97322: LD_VAR 0 5
97326: IFFALSE 97382
// begin k := NearestUnitToUnit ( tmp , j ) ;
97328: LD_ADDR_VAR 0 4
97332: PUSH
97333: LD_VAR 0 5
97337: PPUSH
97338: LD_VAR 0 3
97342: PPUSH
97343: CALL_OW 74
97347: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 5 then
97348: LD_VAR 0 3
97352: PPUSH
97353: LD_VAR 0 4
97357: PPUSH
97358: CALL_OW 296
97362: PUSH
97363: LD_INT 5
97365: GREATER
97366: IFFALSE 97382
// ComMoveToNearbyEntrance ( j , k ) ;
97368: LD_VAR 0 3
97372: PPUSH
97373: LD_VAR 0 4
97377: PPUSH
97378: CALL 57422 0 2
// end ; end ;
97382: GO 97237
97384: POP
97385: POP
// if not need_heal_1 and not need_heal_2 then
97386: LD_VAR 0 6
97390: NOT
97391: PUSH
97392: LD_VAR 0 7
97396: NOT
97397: AND
97398: IFFALSE 97402
// continue ;
97400: GO 96866
// end ;
97402: GO 96866
97404: POP
97405: POP
// RaiseSailEvent ( 102 ) ;
97406: LD_INT 102
97408: PPUSH
97409: CALL_OW 427
// end ;
97413: LD_VAR 0 1
97417: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes , to_repair_tmp , to_repair ; begin
97418: LD_INT 0
97420: PPUSH
97421: PPUSH
97422: PPUSH
97423: PPUSH
97424: PPUSH
97425: PPUSH
97426: PPUSH
97427: PPUSH
// if not mc_bases then
97428: LD_EXP 161
97432: NOT
97433: IFFALSE 97437
// exit ;
97435: GO 98348
// for i = 1 to mc_bases do
97437: LD_ADDR_VAR 0 2
97441: PUSH
97442: DOUBLE
97443: LD_INT 1
97445: DEC
97446: ST_TO_ADDR
97447: LD_EXP 161
97451: PUSH
97452: FOR_TO
97453: IFFALSE 98346
// begin if not mc_building_need_repair [ i ] then
97455: LD_EXP 162
97459: PUSH
97460: LD_VAR 0 2
97464: ARRAY
97465: NOT
97466: IFFALSE 97651
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ] ) ;
97468: LD_ADDR_VAR 0 6
97472: PUSH
97473: LD_EXP 180
97477: PUSH
97478: LD_VAR 0 2
97482: ARRAY
97483: PPUSH
97484: LD_INT 3
97486: PUSH
97487: LD_INT 24
97489: PUSH
97490: LD_INT 1000
97492: PUSH
97493: EMPTY
97494: LIST
97495: LIST
97496: PUSH
97497: EMPTY
97498: LIST
97499: LIST
97500: PUSH
97501: LD_INT 2
97503: PUSH
97504: LD_INT 34
97506: PUSH
97507: LD_INT 13
97509: PUSH
97510: EMPTY
97511: LIST
97512: LIST
97513: PUSH
97514: LD_INT 34
97516: PUSH
97517: LD_INT 52
97519: PUSH
97520: EMPTY
97521: LIST
97522: LIST
97523: PUSH
97524: LD_INT 34
97526: PUSH
97527: LD_INT 88
97529: PUSH
97530: EMPTY
97531: LIST
97532: LIST
97533: PUSH
97534: EMPTY
97535: LIST
97536: LIST
97537: LIST
97538: LIST
97539: PUSH
97540: EMPTY
97541: LIST
97542: LIST
97543: PPUSH
97544: CALL_OW 72
97548: ST_TO_ADDR
// if cranes then
97549: LD_VAR 0 6
97553: IFFALSE 97615
// for j in cranes do
97555: LD_ADDR_VAR 0 3
97559: PUSH
97560: LD_VAR 0 6
97564: PUSH
97565: FOR_IN
97566: IFFALSE 97613
// if not IsInArea ( j , mc_parking [ i ] ) then
97568: LD_VAR 0 3
97572: PPUSH
97573: LD_EXP 185
97577: PUSH
97578: LD_VAR 0 2
97582: ARRAY
97583: PPUSH
97584: CALL_OW 308
97588: NOT
97589: IFFALSE 97611
// ComMoveToArea ( j , mc_parking [ i ] ) ;
97591: LD_VAR 0 3
97595: PPUSH
97596: LD_EXP 185
97600: PUSH
97601: LD_VAR 0 2
97605: ARRAY
97606: PPUSH
97607: CALL_OW 113
97611: GO 97565
97613: POP
97614: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
97615: LD_ADDR_EXP 163
97619: PUSH
97620: LD_EXP 163
97624: PPUSH
97625: LD_VAR 0 2
97629: PPUSH
97630: EMPTY
97631: PPUSH
97632: CALL_OW 1
97636: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
97637: LD_VAR 0 2
97641: PPUSH
97642: LD_INT 101
97644: PPUSH
97645: CALL 92491 0 2
// continue ;
97649: GO 97452
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
97651: LD_ADDR_EXP 167
97655: PUSH
97656: LD_EXP 167
97660: PPUSH
97661: LD_VAR 0 2
97665: PPUSH
97666: EMPTY
97667: PPUSH
97668: CALL_OW 1
97672: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
97673: LD_VAR 0 2
97677: PPUSH
97678: LD_INT 103
97680: PPUSH
97681: CALL 92491 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) ;
97685: LD_ADDR_VAR 0 5
97689: PUSH
97690: LD_EXP 161
97694: PUSH
97695: LD_VAR 0 2
97699: ARRAY
97700: PUSH
97701: LD_EXP 190
97705: PUSH
97706: LD_VAR 0 2
97710: ARRAY
97711: UNION
97712: PPUSH
97713: LD_INT 2
97715: PUSH
97716: LD_INT 25
97718: PUSH
97719: LD_INT 2
97721: PUSH
97722: EMPTY
97723: LIST
97724: LIST
97725: PUSH
97726: LD_INT 25
97728: PUSH
97729: LD_INT 16
97731: PUSH
97732: EMPTY
97733: LIST
97734: LIST
97735: PUSH
97736: EMPTY
97737: LIST
97738: LIST
97739: LIST
97740: PUSH
97741: EMPTY
97742: LIST
97743: PPUSH
97744: CALL_OW 72
97748: ST_TO_ADDR
// if mc_need_heal [ i ] then
97749: LD_EXP 164
97753: PUSH
97754: LD_VAR 0 2
97758: ARRAY
97759: IFFALSE 97803
// tmp := tmp diff ( mc_need_heal [ i ] [ 1 ] union mc_need_heal [ i ] [ 2 ] ) ;
97761: LD_ADDR_VAR 0 5
97765: PUSH
97766: LD_VAR 0 5
97770: PUSH
97771: LD_EXP 164
97775: PUSH
97776: LD_VAR 0 2
97780: ARRAY
97781: PUSH
97782: LD_INT 1
97784: ARRAY
97785: PUSH
97786: LD_EXP 164
97790: PUSH
97791: LD_VAR 0 2
97795: ARRAY
97796: PUSH
97797: LD_INT 2
97799: ARRAY
97800: UNION
97801: DIFF
97802: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ) ;
97803: LD_ADDR_VAR 0 6
97807: PUSH
97808: LD_EXP 180
97812: PUSH
97813: LD_VAR 0 2
97817: ARRAY
97818: PPUSH
97819: LD_INT 2
97821: PUSH
97822: LD_INT 34
97824: PUSH
97825: LD_INT 13
97827: PUSH
97828: EMPTY
97829: LIST
97830: LIST
97831: PUSH
97832: LD_INT 34
97834: PUSH
97835: LD_INT 52
97837: PUSH
97838: EMPTY
97839: LIST
97840: LIST
97841: PUSH
97842: LD_INT 34
97844: PUSH
97845: LD_INT 88
97847: PUSH
97848: EMPTY
97849: LIST
97850: LIST
97851: PUSH
97852: EMPTY
97853: LIST
97854: LIST
97855: LIST
97856: LIST
97857: PPUSH
97858: CALL_OW 72
97862: ST_TO_ADDR
// if cranes then
97863: LD_VAR 0 6
97867: IFFALSE 98035
// begin for j in cranes do
97869: LD_ADDR_VAR 0 3
97873: PUSH
97874: LD_VAR 0 6
97878: PUSH
97879: FOR_IN
97880: IFFALSE 98033
// begin if GetLives ( j ) = 1000 and not HasTask ( j ) then
97882: LD_VAR 0 3
97886: PPUSH
97887: CALL_OW 256
97891: PUSH
97892: LD_INT 1000
97894: EQUAL
97895: PUSH
97896: LD_VAR 0 3
97900: PPUSH
97901: CALL_OW 314
97905: NOT
97906: AND
97907: IFFALSE 97973
// begin to_repair := NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ;
97909: LD_ADDR_VAR 0 8
97913: PUSH
97914: LD_EXP 162
97918: PUSH
97919: LD_VAR 0 2
97923: ARRAY
97924: PPUSH
97925: LD_VAR 0 3
97929: PPUSH
97930: CALL_OW 74
97934: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 10 then
97935: LD_VAR 0 8
97939: PPUSH
97940: LD_INT 16
97942: PPUSH
97943: CALL 26783 0 2
97947: PUSH
97948: LD_INT 4
97950: ARRAY
97951: PUSH
97952: LD_INT 10
97954: LESS
97955: IFFALSE 97971
// ComRepairBuilding ( j , to_repair ) ;
97957: LD_VAR 0 3
97961: PPUSH
97962: LD_VAR 0 8
97966: PPUSH
97967: CALL_OW 130
// end else
97971: GO 98031
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
97973: LD_VAR 0 3
97977: PPUSH
97978: CALL_OW 256
97982: PUSH
97983: LD_INT 500
97985: LESS
97986: PUSH
97987: LD_VAR 0 3
97991: PPUSH
97992: LD_EXP 185
97996: PUSH
97997: LD_VAR 0 2
98001: ARRAY
98002: PPUSH
98003: CALL_OW 308
98007: NOT
98008: AND
98009: IFFALSE 98031
// ComMoveToArea ( j , mc_parking [ i ] ) ;
98011: LD_VAR 0 3
98015: PPUSH
98016: LD_EXP 185
98020: PUSH
98021: LD_VAR 0 2
98025: ARRAY
98026: PPUSH
98027: CALL_OW 113
// end ;
98031: GO 97879
98033: POP
98034: POP
// end ; if tmp > 3 then
98035: LD_VAR 0 5
98039: PUSH
98040: LD_INT 3
98042: GREATER
98043: IFFALSE 98063
// tmp := ShrinkArray ( tmp , 4 ) ;
98045: LD_ADDR_VAR 0 5
98049: PUSH
98050: LD_VAR 0 5
98054: PPUSH
98055: LD_INT 4
98057: PPUSH
98058: CALL 56860 0 2
98062: ST_TO_ADDR
// if not tmp then
98063: LD_VAR 0 5
98067: NOT
98068: IFFALSE 98072
// continue ;
98070: GO 97452
// for j in tmp do
98072: LD_ADDR_VAR 0 3
98076: PUSH
98077: LD_VAR 0 5
98081: PUSH
98082: FOR_IN
98083: IFFALSE 98342
// begin if IsInUnit ( j ) then
98085: LD_VAR 0 3
98089: PPUSH
98090: CALL_OW 310
98094: IFFALSE 98105
// ComExitBuilding ( j ) ;
98096: LD_VAR 0 3
98100: PPUSH
98101: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
98105: LD_VAR 0 3
98109: PUSH
98110: LD_EXP 163
98114: PUSH
98115: LD_VAR 0 2
98119: ARRAY
98120: IN
98121: NOT
98122: IFFALSE 98180
// begin SetTag ( j , 101 ) ;
98124: LD_VAR 0 3
98128: PPUSH
98129: LD_INT 101
98131: PPUSH
98132: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
98136: LD_ADDR_EXP 163
98140: PUSH
98141: LD_EXP 163
98145: PPUSH
98146: LD_VAR 0 2
98150: PUSH
98151: LD_EXP 163
98155: PUSH
98156: LD_VAR 0 2
98160: ARRAY
98161: PUSH
98162: LD_INT 1
98164: PLUS
98165: PUSH
98166: EMPTY
98167: LIST
98168: LIST
98169: PPUSH
98170: LD_VAR 0 3
98174: PPUSH
98175: CALL 24186 0 3
98179: ST_TO_ADDR
// end ; wait ( 1 ) ;
98180: LD_INT 1
98182: PPUSH
98183: CALL_OW 67
// to_repair_tmp := mc_building_need_repair [ i ] ;
98187: LD_ADDR_VAR 0 7
98191: PUSH
98192: LD_EXP 162
98196: PUSH
98197: LD_VAR 0 2
98201: ARRAY
98202: ST_TO_ADDR
// if mc_scan [ i ] then
98203: LD_EXP 184
98207: PUSH
98208: LD_VAR 0 2
98212: ARRAY
98213: IFFALSE 98275
// to_repair_tmp := UnitFilter ( mc_building_need_repair [ i ] , [ f_not , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_breastwork ] ] ) ;
98215: LD_ADDR_VAR 0 7
98219: PUSH
98220: LD_EXP 162
98224: PUSH
98225: LD_VAR 0 2
98229: ARRAY
98230: PPUSH
98231: LD_INT 3
98233: PUSH
98234: LD_INT 30
98236: PUSH
98237: LD_INT 32
98239: PUSH
98240: EMPTY
98241: LIST
98242: LIST
98243: PUSH
98244: LD_INT 30
98246: PUSH
98247: LD_INT 33
98249: PUSH
98250: EMPTY
98251: LIST
98252: LIST
98253: PUSH
98254: LD_INT 30
98256: PUSH
98257: LD_INT 31
98259: PUSH
98260: EMPTY
98261: LIST
98262: LIST
98263: PUSH
98264: EMPTY
98265: LIST
98266: LIST
98267: LIST
98268: LIST
98269: PPUSH
98270: CALL_OW 72
98274: ST_TO_ADDR
// if not to_repair_tmp then
98275: LD_VAR 0 7
98279: NOT
98280: IFFALSE 98284
// continue ;
98282: GO 98082
// to_repair := NearestUnitToUnit ( to_repair_tmp , j ) ;
98284: LD_ADDR_VAR 0 8
98288: PUSH
98289: LD_VAR 0 7
98293: PPUSH
98294: LD_VAR 0 3
98298: PPUSH
98299: CALL_OW 74
98303: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 14 then
98304: LD_VAR 0 8
98308: PPUSH
98309: LD_INT 16
98311: PPUSH
98312: CALL 26783 0 2
98316: PUSH
98317: LD_INT 4
98319: ARRAY
98320: PUSH
98321: LD_INT 14
98323: LESS
98324: IFFALSE 98340
// ComRepairBuilding ( j , to_repair ) ;
98326: LD_VAR 0 3
98330: PPUSH
98331: LD_VAR 0 8
98335: PPUSH
98336: CALL_OW 130
// end ;
98340: GO 98082
98342: POP
98343: POP
// end ;
98344: GO 97452
98346: POP
98347: POP
// end ;
98348: LD_VAR 0 1
98352: RET
// export function MC_Heal ; var i , j , tmp ; begin
98353: LD_INT 0
98355: PPUSH
98356: PPUSH
98357: PPUSH
98358: PPUSH
// if not mc_bases then
98359: LD_EXP 161
98363: NOT
98364: IFFALSE 98368
// exit ;
98366: GO 98770
// for i = 1 to mc_bases do
98368: LD_ADDR_VAR 0 2
98372: PUSH
98373: DOUBLE
98374: LD_INT 1
98376: DEC
98377: ST_TO_ADDR
98378: LD_EXP 161
98382: PUSH
98383: FOR_TO
98384: IFFALSE 98768
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
98386: LD_EXP 164
98390: PUSH
98391: LD_VAR 0 2
98395: ARRAY
98396: PUSH
98397: LD_INT 1
98399: ARRAY
98400: NOT
98401: PUSH
98402: LD_EXP 164
98406: PUSH
98407: LD_VAR 0 2
98411: ARRAY
98412: PUSH
98413: LD_INT 2
98415: ARRAY
98416: NOT
98417: AND
98418: IFFALSE 98456
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
98420: LD_ADDR_EXP 165
98424: PUSH
98425: LD_EXP 165
98429: PPUSH
98430: LD_VAR 0 2
98434: PPUSH
98435: EMPTY
98436: PPUSH
98437: CALL_OW 1
98441: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
98442: LD_VAR 0 2
98446: PPUSH
98447: LD_INT 102
98449: PPUSH
98450: CALL 92491 0 2
// continue ;
98454: GO 98383
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
98456: LD_ADDR_VAR 0 4
98460: PUSH
98461: LD_EXP 161
98465: PUSH
98466: LD_VAR 0 2
98470: ARRAY
98471: PPUSH
98472: LD_INT 25
98474: PUSH
98475: LD_INT 4
98477: PUSH
98478: EMPTY
98479: LIST
98480: LIST
98481: PPUSH
98482: CALL_OW 72
98486: ST_TO_ADDR
// if not tmp then
98487: LD_VAR 0 4
98491: NOT
98492: IFFALSE 98496
// continue ;
98494: GO 98383
// if mc_taming [ i ] then
98496: LD_EXP 192
98500: PUSH
98501: LD_VAR 0 2
98505: ARRAY
98506: IFFALSE 98530
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
98508: LD_ADDR_EXP 192
98512: PUSH
98513: LD_EXP 192
98517: PPUSH
98518: LD_VAR 0 2
98522: PPUSH
98523: EMPTY
98524: PPUSH
98525: CALL_OW 1
98529: ST_TO_ADDR
// for j in tmp do
98530: LD_ADDR_VAR 0 3
98534: PUSH
98535: LD_VAR 0 4
98539: PUSH
98540: FOR_IN
98541: IFFALSE 98764
// begin if IsInUnit ( j ) then
98543: LD_VAR 0 3
98547: PPUSH
98548: CALL_OW 310
98552: IFFALSE 98563
// ComExitBuilding ( j ) ;
98554: LD_VAR 0 3
98558: PPUSH
98559: CALL_OW 122
// if not j in mc_healers [ i ] then
98563: LD_VAR 0 3
98567: PUSH
98568: LD_EXP 165
98572: PUSH
98573: LD_VAR 0 2
98577: ARRAY
98578: IN
98579: NOT
98580: IFFALSE 98626
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
98582: LD_ADDR_EXP 165
98586: PUSH
98587: LD_EXP 165
98591: PPUSH
98592: LD_VAR 0 2
98596: PUSH
98597: LD_EXP 165
98601: PUSH
98602: LD_VAR 0 2
98606: ARRAY
98607: PUSH
98608: LD_INT 1
98610: PLUS
98611: PUSH
98612: EMPTY
98613: LIST
98614: LIST
98615: PPUSH
98616: LD_VAR 0 3
98620: PPUSH
98621: CALL 24186 0 3
98625: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
98626: LD_VAR 0 3
98630: PPUSH
98631: CALL_OW 110
98635: PUSH
98636: LD_INT 102
98638: NONEQUAL
98639: IFFALSE 98653
// SetTag ( j , 102 ) ;
98641: LD_VAR 0 3
98645: PPUSH
98646: LD_INT 102
98648: PPUSH
98649: CALL_OW 109
// Wait ( 3 ) ;
98653: LD_INT 3
98655: PPUSH
98656: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
98660: LD_EXP 164
98664: PUSH
98665: LD_VAR 0 2
98669: ARRAY
98670: PUSH
98671: LD_INT 1
98673: ARRAY
98674: IFFALSE 98706
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
98676: LD_VAR 0 3
98680: PPUSH
98681: LD_EXP 164
98685: PUSH
98686: LD_VAR 0 2
98690: ARRAY
98691: PUSH
98692: LD_INT 1
98694: ARRAY
98695: PUSH
98696: LD_INT 1
98698: ARRAY
98699: PPUSH
98700: CALL_OW 128
98704: GO 98762
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
98706: LD_VAR 0 3
98710: PPUSH
98711: CALL_OW 314
98715: NOT
98716: PUSH
98717: LD_EXP 164
98721: PUSH
98722: LD_VAR 0 2
98726: ARRAY
98727: PUSH
98728: LD_INT 2
98730: ARRAY
98731: AND
98732: IFFALSE 98762
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
98734: LD_VAR 0 3
98738: PPUSH
98739: LD_EXP 164
98743: PUSH
98744: LD_VAR 0 2
98748: ARRAY
98749: PUSH
98750: LD_INT 2
98752: ARRAY
98753: PUSH
98754: LD_INT 1
98756: ARRAY
98757: PPUSH
98758: CALL_OW 128
// end ;
98762: GO 98540
98764: POP
98765: POP
// end ;
98766: GO 98383
98768: POP
98769: POP
// end ;
98770: LD_VAR 0 1
98774: RET
// export function MC_Build ( ) ; var i , j , k , tmp , depot ; begin
98775: LD_INT 0
98777: PPUSH
98778: PPUSH
98779: PPUSH
98780: PPUSH
98781: PPUSH
98782: PPUSH
// if not mc_bases then
98783: LD_EXP 161
98787: NOT
98788: IFFALSE 98792
// exit ;
98790: GO 99955
// for i = 1 to mc_bases do
98792: LD_ADDR_VAR 0 2
98796: PUSH
98797: DOUBLE
98798: LD_INT 1
98800: DEC
98801: ST_TO_ADDR
98802: LD_EXP 161
98806: PUSH
98807: FOR_TO
98808: IFFALSE 99953
// begin if mc_scan [ i ] then
98810: LD_EXP 184
98814: PUSH
98815: LD_VAR 0 2
98819: ARRAY
98820: IFFALSE 98824
// continue ;
98822: GO 98807
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
98824: LD_EXP 166
98828: PUSH
98829: LD_VAR 0 2
98833: ARRAY
98834: NOT
98835: PUSH
98836: LD_EXP 168
98840: PUSH
98841: LD_VAR 0 2
98845: ARRAY
98846: NOT
98847: AND
98848: PUSH
98849: LD_EXP 167
98853: PUSH
98854: LD_VAR 0 2
98858: ARRAY
98859: AND
98860: IFFALSE 98898
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
98862: LD_ADDR_EXP 167
98866: PUSH
98867: LD_EXP 167
98871: PPUSH
98872: LD_VAR 0 2
98876: PPUSH
98877: EMPTY
98878: PPUSH
98879: CALL_OW 1
98883: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
98884: LD_VAR 0 2
98888: PPUSH
98889: LD_INT 103
98891: PPUSH
98892: CALL 92491 0 2
// continue ;
98896: GO 98807
// end ; if mc_construct_list [ i ] then
98898: LD_EXP 168
98902: PUSH
98903: LD_VAR 0 2
98907: ARRAY
98908: IFFALSE 99128
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
98910: LD_ADDR_VAR 0 5
98914: PUSH
98915: LD_EXP 161
98919: PUSH
98920: LD_VAR 0 2
98924: ARRAY
98925: PPUSH
98926: LD_INT 25
98928: PUSH
98929: LD_INT 2
98931: PUSH
98932: EMPTY
98933: LIST
98934: LIST
98935: PPUSH
98936: CALL_OW 72
98940: PUSH
98941: LD_EXP 163
98945: PUSH
98946: LD_VAR 0 2
98950: ARRAY
98951: DIFF
98952: ST_TO_ADDR
// if not tmp then
98953: LD_VAR 0 5
98957: NOT
98958: IFFALSE 98962
// continue ;
98960: GO 98807
// for j in tmp do
98962: LD_ADDR_VAR 0 3
98966: PUSH
98967: LD_VAR 0 5
98971: PUSH
98972: FOR_IN
98973: IFFALSE 99124
// begin if not mc_builders [ i ] then
98975: LD_EXP 167
98979: PUSH
98980: LD_VAR 0 2
98984: ARRAY
98985: NOT
98986: IFFALSE 99044
// begin SetTag ( j , 103 ) ;
98988: LD_VAR 0 3
98992: PPUSH
98993: LD_INT 103
98995: PPUSH
98996: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
99000: LD_ADDR_EXP 167
99004: PUSH
99005: LD_EXP 167
99009: PPUSH
99010: LD_VAR 0 2
99014: PUSH
99015: LD_EXP 167
99019: PUSH
99020: LD_VAR 0 2
99024: ARRAY
99025: PUSH
99026: LD_INT 1
99028: PLUS
99029: PUSH
99030: EMPTY
99031: LIST
99032: LIST
99033: PPUSH
99034: LD_VAR 0 3
99038: PPUSH
99039: CALL 24186 0 3
99043: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
99044: LD_VAR 0 3
99048: PPUSH
99049: CALL_OW 310
99053: IFFALSE 99064
// ComExitBuilding ( j ) ;
99055: LD_VAR 0 3
99059: PPUSH
99060: CALL_OW 122
// wait ( 3 ) ;
99064: LD_INT 3
99066: PPUSH
99067: CALL_OW 67
// if not mc_construct_list [ i ] then
99071: LD_EXP 168
99075: PUSH
99076: LD_VAR 0 2
99080: ARRAY
99081: NOT
99082: IFFALSE 99086
// break ;
99084: GO 99124
// if not HasTask ( j ) then
99086: LD_VAR 0 3
99090: PPUSH
99091: CALL_OW 314
99095: NOT
99096: IFFALSE 99122
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
99098: LD_VAR 0 3
99102: PPUSH
99103: LD_EXP 168
99107: PUSH
99108: LD_VAR 0 2
99112: ARRAY
99113: PUSH
99114: LD_INT 1
99116: ARRAY
99117: PPUSH
99118: CALL 27056 0 2
// end ;
99122: GO 98972
99124: POP
99125: POP
// end else
99126: GO 99951
// if mc_build_list [ i ] then
99128: LD_EXP 166
99132: PUSH
99133: LD_VAR 0 2
99137: ARRAY
99138: IFFALSE 99951
// begin if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
99140: LD_EXP 166
99144: PUSH
99145: LD_VAR 0 2
99149: ARRAY
99150: PUSH
99151: LD_INT 1
99153: ARRAY
99154: PUSH
99155: LD_INT 1
99157: ARRAY
99158: PPUSH
99159: CALL 26880 0 1
99163: PUSH
99164: LD_EXP 161
99168: PUSH
99169: LD_VAR 0 2
99173: ARRAY
99174: PPUSH
99175: LD_INT 2
99177: PUSH
99178: LD_INT 30
99180: PUSH
99181: LD_INT 2
99183: PUSH
99184: EMPTY
99185: LIST
99186: LIST
99187: PUSH
99188: LD_INT 30
99190: PUSH
99191: LD_INT 3
99193: PUSH
99194: EMPTY
99195: LIST
99196: LIST
99197: PUSH
99198: EMPTY
99199: LIST
99200: LIST
99201: LIST
99202: PPUSH
99203: CALL_OW 72
99207: NOT
99208: AND
99209: IFFALSE 99314
// begin for j = 1 to mc_build_list [ i ] do
99211: LD_ADDR_VAR 0 3
99215: PUSH
99216: DOUBLE
99217: LD_INT 1
99219: DEC
99220: ST_TO_ADDR
99221: LD_EXP 166
99225: PUSH
99226: LD_VAR 0 2
99230: ARRAY
99231: PUSH
99232: FOR_TO
99233: IFFALSE 99312
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
99235: LD_EXP 166
99239: PUSH
99240: LD_VAR 0 2
99244: ARRAY
99245: PUSH
99246: LD_VAR 0 3
99250: ARRAY
99251: PUSH
99252: LD_INT 1
99254: ARRAY
99255: PUSH
99256: LD_INT 2
99258: EQUAL
99259: IFFALSE 99310
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
99261: LD_ADDR_EXP 166
99265: PUSH
99266: LD_EXP 166
99270: PPUSH
99271: LD_VAR 0 2
99275: PPUSH
99276: LD_EXP 166
99280: PUSH
99281: LD_VAR 0 2
99285: ARRAY
99286: PPUSH
99287: LD_VAR 0 3
99291: PPUSH
99292: LD_INT 1
99294: PPUSH
99295: LD_INT 0
99297: PPUSH
99298: CALL 23604 0 4
99302: PPUSH
99303: CALL_OW 1
99307: ST_TO_ADDR
// break ;
99308: GO 99312
// end ;
99310: GO 99232
99312: POP
99313: POP
// end ; depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
99314: LD_ADDR_VAR 0 6
99318: PUSH
99319: LD_EXP 161
99323: PUSH
99324: LD_VAR 0 2
99328: ARRAY
99329: PPUSH
99330: LD_INT 2
99332: PUSH
99333: LD_INT 30
99335: PUSH
99336: LD_INT 0
99338: PUSH
99339: EMPTY
99340: LIST
99341: LIST
99342: PUSH
99343: LD_INT 30
99345: PUSH
99346: LD_INT 1
99348: PUSH
99349: EMPTY
99350: LIST
99351: LIST
99352: PUSH
99353: EMPTY
99354: LIST
99355: LIST
99356: LIST
99357: PPUSH
99358: CALL_OW 72
99362: ST_TO_ADDR
// for k := 1 to depot do
99363: LD_ADDR_VAR 0 4
99367: PUSH
99368: DOUBLE
99369: LD_INT 1
99371: DEC
99372: ST_TO_ADDR
99373: LD_VAR 0 6
99377: PUSH
99378: FOR_TO
99379: IFFALSE 99949
// begin if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or CanBeBuilt ( depot [ k ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) then
99381: LD_EXP 166
99385: PUSH
99386: LD_VAR 0 2
99390: ARRAY
99391: PUSH
99392: LD_INT 1
99394: ARRAY
99395: PUSH
99396: LD_INT 1
99398: ARRAY
99399: PUSH
99400: LD_INT 0
99402: EQUAL
99403: PUSH
99404: LD_VAR 0 6
99408: PUSH
99409: LD_VAR 0 4
99413: ARRAY
99414: PPUSH
99415: LD_EXP 166
99419: PUSH
99420: LD_VAR 0 2
99424: ARRAY
99425: PUSH
99426: LD_INT 1
99428: ARRAY
99429: PUSH
99430: LD_INT 1
99432: ARRAY
99433: PPUSH
99434: LD_EXP 166
99438: PUSH
99439: LD_VAR 0 2
99443: ARRAY
99444: PUSH
99445: LD_INT 1
99447: ARRAY
99448: PUSH
99449: LD_INT 2
99451: ARRAY
99452: PPUSH
99453: LD_EXP 166
99457: PUSH
99458: LD_VAR 0 2
99462: ARRAY
99463: PUSH
99464: LD_INT 1
99466: ARRAY
99467: PUSH
99468: LD_INT 3
99470: ARRAY
99471: PPUSH
99472: LD_EXP 166
99476: PUSH
99477: LD_VAR 0 2
99481: ARRAY
99482: PUSH
99483: LD_INT 1
99485: ARRAY
99486: PUSH
99487: LD_INT 4
99489: ARRAY
99490: PPUSH
99491: CALL 32292 0 5
99495: OR
99496: IFFALSE 99777
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
99498: LD_ADDR_VAR 0 5
99502: PUSH
99503: LD_EXP 161
99507: PUSH
99508: LD_VAR 0 2
99512: ARRAY
99513: PPUSH
99514: LD_INT 25
99516: PUSH
99517: LD_INT 2
99519: PUSH
99520: EMPTY
99521: LIST
99522: LIST
99523: PPUSH
99524: CALL_OW 72
99528: PUSH
99529: LD_EXP 163
99533: PUSH
99534: LD_VAR 0 2
99538: ARRAY
99539: DIFF
99540: ST_TO_ADDR
// if not tmp then
99541: LD_VAR 0 5
99545: NOT
99546: IFFALSE 99550
// continue ;
99548: GO 99378
// for j in tmp do
99550: LD_ADDR_VAR 0 3
99554: PUSH
99555: LD_VAR 0 5
99559: PUSH
99560: FOR_IN
99561: IFFALSE 99773
// begin if not mc_builders [ i ] then
99563: LD_EXP 167
99567: PUSH
99568: LD_VAR 0 2
99572: ARRAY
99573: NOT
99574: IFFALSE 99632
// begin SetTag ( j , 103 ) ;
99576: LD_VAR 0 3
99580: PPUSH
99581: LD_INT 103
99583: PPUSH
99584: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
99588: LD_ADDR_EXP 167
99592: PUSH
99593: LD_EXP 167
99597: PPUSH
99598: LD_VAR 0 2
99602: PUSH
99603: LD_EXP 167
99607: PUSH
99608: LD_VAR 0 2
99612: ARRAY
99613: PUSH
99614: LD_INT 1
99616: PLUS
99617: PUSH
99618: EMPTY
99619: LIST
99620: LIST
99621: PPUSH
99622: LD_VAR 0 3
99626: PPUSH
99627: CALL 24186 0 3
99631: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
99632: LD_VAR 0 3
99636: PPUSH
99637: CALL_OW 310
99641: IFFALSE 99652
// ComExitBuilding ( j ) ;
99643: LD_VAR 0 3
99647: PPUSH
99648: CALL_OW 122
// wait ( 3 ) ;
99652: LD_INT 3
99654: PPUSH
99655: CALL_OW 67
// if not mc_build_list [ i ] then
99659: LD_EXP 166
99663: PUSH
99664: LD_VAR 0 2
99668: ARRAY
99669: NOT
99670: IFFALSE 99674
// break ;
99672: GO 99773
// if not HasTask ( j ) then
99674: LD_VAR 0 3
99678: PPUSH
99679: CALL_OW 314
99683: NOT
99684: IFFALSE 99771
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
99686: LD_VAR 0 3
99690: PPUSH
99691: LD_EXP 166
99695: PUSH
99696: LD_VAR 0 2
99700: ARRAY
99701: PUSH
99702: LD_INT 1
99704: ARRAY
99705: PUSH
99706: LD_INT 1
99708: ARRAY
99709: PPUSH
99710: LD_EXP 166
99714: PUSH
99715: LD_VAR 0 2
99719: ARRAY
99720: PUSH
99721: LD_INT 1
99723: ARRAY
99724: PUSH
99725: LD_INT 2
99727: ARRAY
99728: PPUSH
99729: LD_EXP 166
99733: PUSH
99734: LD_VAR 0 2
99738: ARRAY
99739: PUSH
99740: LD_INT 1
99742: ARRAY
99743: PUSH
99744: LD_INT 3
99746: ARRAY
99747: PPUSH
99748: LD_EXP 166
99752: PUSH
99753: LD_VAR 0 2
99757: ARRAY
99758: PUSH
99759: LD_INT 1
99761: ARRAY
99762: PUSH
99763: LD_INT 4
99765: ARRAY
99766: PPUSH
99767: CALL_OW 145
// end ;
99771: GO 99560
99773: POP
99774: POP
// end else
99775: GO 99947
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] , UnitFilter ( mc_bases [ i ] , [ f_type , unit_building ] ) , [ ] ) then
99777: LD_EXP 161
99781: PUSH
99782: LD_VAR 0 2
99786: ARRAY
99787: PPUSH
99788: LD_EXP 166
99792: PUSH
99793: LD_VAR 0 2
99797: ARRAY
99798: PUSH
99799: LD_INT 1
99801: ARRAY
99802: PUSH
99803: LD_INT 1
99805: ARRAY
99806: PPUSH
99807: LD_EXP 166
99811: PUSH
99812: LD_VAR 0 2
99816: ARRAY
99817: PUSH
99818: LD_INT 1
99820: ARRAY
99821: PUSH
99822: LD_INT 2
99824: ARRAY
99825: PPUSH
99826: LD_EXP 166
99830: PUSH
99831: LD_VAR 0 2
99835: ARRAY
99836: PUSH
99837: LD_INT 1
99839: ARRAY
99840: PUSH
99841: LD_INT 3
99843: ARRAY
99844: PPUSH
99845: LD_EXP 166
99849: PUSH
99850: LD_VAR 0 2
99854: ARRAY
99855: PUSH
99856: LD_INT 1
99858: ARRAY
99859: PUSH
99860: LD_INT 4
99862: ARRAY
99863: PPUSH
99864: LD_EXP 161
99868: PUSH
99869: LD_VAR 0 2
99873: ARRAY
99874: PPUSH
99875: LD_INT 21
99877: PUSH
99878: LD_INT 3
99880: PUSH
99881: EMPTY
99882: LIST
99883: LIST
99884: PPUSH
99885: CALL_OW 72
99889: PPUSH
99890: EMPTY
99891: PPUSH
99892: CALL 31046 0 7
99896: NOT
99897: IFFALSE 99947
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
99899: LD_ADDR_EXP 166
99903: PUSH
99904: LD_EXP 166
99908: PPUSH
99909: LD_VAR 0 2
99913: PPUSH
99914: LD_EXP 166
99918: PUSH
99919: LD_VAR 0 2
99923: ARRAY
99924: PPUSH
99925: LD_INT 1
99927: PPUSH
99928: LD_INT 1
99930: NEG
99931: PPUSH
99932: LD_INT 0
99934: PPUSH
99935: CALL 23604 0 4
99939: PPUSH
99940: CALL_OW 1
99944: ST_TO_ADDR
// continue ;
99945: GO 99378
// end ; end ;
99947: GO 99378
99949: POP
99950: POP
// end ; end ;
99951: GO 98807
99953: POP
99954: POP
// end ;
99955: LD_VAR 0 1
99959: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
99960: LD_INT 0
99962: PPUSH
99963: PPUSH
99964: PPUSH
99965: PPUSH
99966: PPUSH
99967: PPUSH
// if not mc_bases then
99968: LD_EXP 161
99972: NOT
99973: IFFALSE 99977
// exit ;
99975: GO 100404
// for i = 1 to mc_bases do
99977: LD_ADDR_VAR 0 2
99981: PUSH
99982: DOUBLE
99983: LD_INT 1
99985: DEC
99986: ST_TO_ADDR
99987: LD_EXP 161
99991: PUSH
99992: FOR_TO
99993: IFFALSE 100402
// begin tmp := mc_build_upgrade [ i ] ;
99995: LD_ADDR_VAR 0 4
99999: PUSH
100000: LD_EXP 193
100004: PUSH
100005: LD_VAR 0 2
100009: ARRAY
100010: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
100011: LD_ADDR_VAR 0 6
100015: PUSH
100016: LD_EXP 194
100020: PUSH
100021: LD_VAR 0 2
100025: ARRAY
100026: PPUSH
100027: LD_INT 2
100029: PUSH
100030: LD_INT 30
100032: PUSH
100033: LD_INT 6
100035: PUSH
100036: EMPTY
100037: LIST
100038: LIST
100039: PUSH
100040: LD_INT 30
100042: PUSH
100043: LD_INT 7
100045: PUSH
100046: EMPTY
100047: LIST
100048: LIST
100049: PUSH
100050: EMPTY
100051: LIST
100052: LIST
100053: LIST
100054: PPUSH
100055: CALL_OW 72
100059: ST_TO_ADDR
// if not tmp and not lab then
100060: LD_VAR 0 4
100064: NOT
100065: PUSH
100066: LD_VAR 0 6
100070: NOT
100071: AND
100072: IFFALSE 100076
// continue ;
100074: GO 99992
// if tmp then
100076: LD_VAR 0 4
100080: IFFALSE 100200
// for j in tmp do
100082: LD_ADDR_VAR 0 3
100086: PUSH
100087: LD_VAR 0 4
100091: PUSH
100092: FOR_IN
100093: IFFALSE 100198
// begin if UpgradeCost ( j ) then
100095: LD_VAR 0 3
100099: PPUSH
100100: CALL 30706 0 1
100104: IFFALSE 100196
// begin ComUpgrade ( j ) ;
100106: LD_VAR 0 3
100110: PPUSH
100111: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
100115: LD_ADDR_EXP 193
100119: PUSH
100120: LD_EXP 193
100124: PPUSH
100125: LD_VAR 0 2
100129: PPUSH
100130: LD_EXP 193
100134: PUSH
100135: LD_VAR 0 2
100139: ARRAY
100140: PUSH
100141: LD_VAR 0 3
100145: DIFF
100146: PPUSH
100147: CALL_OW 1
100151: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
100152: LD_ADDR_EXP 168
100156: PUSH
100157: LD_EXP 168
100161: PPUSH
100162: LD_VAR 0 2
100166: PUSH
100167: LD_EXP 168
100171: PUSH
100172: LD_VAR 0 2
100176: ARRAY
100177: PUSH
100178: LD_INT 1
100180: PLUS
100181: PUSH
100182: EMPTY
100183: LIST
100184: LIST
100185: PPUSH
100186: LD_VAR 0 3
100190: PPUSH
100191: CALL 24186 0 3
100195: ST_TO_ADDR
// end ; end ;
100196: GO 100092
100198: POP
100199: POP
// if not lab or not mc_lab_upgrade [ i ] then
100200: LD_VAR 0 6
100204: NOT
100205: PUSH
100206: LD_EXP 195
100210: PUSH
100211: LD_VAR 0 2
100215: ARRAY
100216: NOT
100217: OR
100218: IFFALSE 100222
// continue ;
100220: GO 99992
// for j in lab do
100222: LD_ADDR_VAR 0 3
100226: PUSH
100227: LD_VAR 0 6
100231: PUSH
100232: FOR_IN
100233: IFFALSE 100398
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
100235: LD_VAR 0 3
100239: PPUSH
100240: CALL_OW 266
100244: PUSH
100245: LD_INT 6
100247: PUSH
100248: LD_INT 7
100250: PUSH
100251: EMPTY
100252: LIST
100253: LIST
100254: IN
100255: PUSH
100256: LD_VAR 0 3
100260: PPUSH
100261: CALL_OW 461
100265: PUSH
100266: LD_INT 1
100268: NONEQUAL
100269: AND
100270: IFFALSE 100396
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
100272: LD_VAR 0 3
100276: PPUSH
100277: LD_EXP 195
100281: PUSH
100282: LD_VAR 0 2
100286: ARRAY
100287: PUSH
100288: LD_INT 1
100290: ARRAY
100291: PPUSH
100292: CALL 30911 0 2
100296: IFFALSE 100396
// begin ComCancel ( j ) ;
100298: LD_VAR 0 3
100302: PPUSH
100303: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
100307: LD_VAR 0 3
100311: PPUSH
100312: LD_EXP 195
100316: PUSH
100317: LD_VAR 0 2
100321: ARRAY
100322: PUSH
100323: LD_INT 1
100325: ARRAY
100326: PPUSH
100327: CALL_OW 207
// if not j in mc_construct_list [ i ] then
100331: LD_VAR 0 3
100335: PUSH
100336: LD_EXP 168
100340: PUSH
100341: LD_VAR 0 2
100345: ARRAY
100346: IN
100347: NOT
100348: IFFALSE 100394
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
100350: LD_ADDR_EXP 168
100354: PUSH
100355: LD_EXP 168
100359: PPUSH
100360: LD_VAR 0 2
100364: PUSH
100365: LD_EXP 168
100369: PUSH
100370: LD_VAR 0 2
100374: ARRAY
100375: PUSH
100376: LD_INT 1
100378: PLUS
100379: PUSH
100380: EMPTY
100381: LIST
100382: LIST
100383: PPUSH
100384: LD_VAR 0 3
100388: PPUSH
100389: CALL 24186 0 3
100393: ST_TO_ADDR
// break ;
100394: GO 100398
// end ; end ; end ;
100396: GO 100232
100398: POP
100399: POP
// end ;
100400: GO 99992
100402: POP
100403: POP
// end ;
100404: LD_VAR 0 1
100408: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
100409: LD_INT 0
100411: PPUSH
100412: PPUSH
100413: PPUSH
100414: PPUSH
100415: PPUSH
100416: PPUSH
100417: PPUSH
100418: PPUSH
100419: PPUSH
// if not mc_bases then
100420: LD_EXP 161
100424: NOT
100425: IFFALSE 100429
// exit ;
100427: GO 100834
// for i = 1 to mc_bases do
100429: LD_ADDR_VAR 0 2
100433: PUSH
100434: DOUBLE
100435: LD_INT 1
100437: DEC
100438: ST_TO_ADDR
100439: LD_EXP 161
100443: PUSH
100444: FOR_TO
100445: IFFALSE 100832
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
100447: LD_EXP 169
100451: PUSH
100452: LD_VAR 0 2
100456: ARRAY
100457: NOT
100458: PUSH
100459: LD_EXP 161
100463: PUSH
100464: LD_VAR 0 2
100468: ARRAY
100469: PPUSH
100470: LD_INT 30
100472: PUSH
100473: LD_INT 3
100475: PUSH
100476: EMPTY
100477: LIST
100478: LIST
100479: PPUSH
100480: CALL_OW 72
100484: NOT
100485: OR
100486: IFFALSE 100490
// continue ;
100488: GO 100444
// busy := false ;
100490: LD_ADDR_VAR 0 8
100494: PUSH
100495: LD_INT 0
100497: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
100498: LD_ADDR_VAR 0 4
100502: PUSH
100503: LD_EXP 161
100507: PUSH
100508: LD_VAR 0 2
100512: ARRAY
100513: PPUSH
100514: LD_INT 30
100516: PUSH
100517: LD_INT 3
100519: PUSH
100520: EMPTY
100521: LIST
100522: LIST
100523: PPUSH
100524: CALL_OW 72
100528: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
100529: LD_ADDR_VAR 0 6
100533: PUSH
100534: LD_EXP 169
100538: PUSH
100539: LD_VAR 0 2
100543: ARRAY
100544: PPUSH
100545: LD_INT 2
100547: PUSH
100548: LD_INT 30
100550: PUSH
100551: LD_INT 32
100553: PUSH
100554: EMPTY
100555: LIST
100556: LIST
100557: PUSH
100558: LD_INT 30
100560: PUSH
100561: LD_INT 33
100563: PUSH
100564: EMPTY
100565: LIST
100566: LIST
100567: PUSH
100568: EMPTY
100569: LIST
100570: LIST
100571: LIST
100572: PPUSH
100573: CALL_OW 72
100577: ST_TO_ADDR
// if not t then
100578: LD_VAR 0 6
100582: NOT
100583: IFFALSE 100587
// continue ;
100585: GO 100444
// for j in tmp do
100587: LD_ADDR_VAR 0 3
100591: PUSH
100592: LD_VAR 0 4
100596: PUSH
100597: FOR_IN
100598: IFFALSE 100628
// if not BuildingStatus ( j ) = bs_idle then
100600: LD_VAR 0 3
100604: PPUSH
100605: CALL_OW 461
100609: PUSH
100610: LD_INT 2
100612: EQUAL
100613: NOT
100614: IFFALSE 100626
// begin busy := true ;
100616: LD_ADDR_VAR 0 8
100620: PUSH
100621: LD_INT 1
100623: ST_TO_ADDR
// break ;
100624: GO 100628
// end ;
100626: GO 100597
100628: POP
100629: POP
// if busy then
100630: LD_VAR 0 8
100634: IFFALSE 100638
// continue ;
100636: GO 100444
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
100638: LD_ADDR_VAR 0 7
100642: PUSH
100643: LD_VAR 0 6
100647: PPUSH
100648: LD_INT 35
100650: PUSH
100651: LD_INT 0
100653: PUSH
100654: EMPTY
100655: LIST
100656: LIST
100657: PPUSH
100658: CALL_OW 72
100662: ST_TO_ADDR
// if tw then
100663: LD_VAR 0 7
100667: IFFALSE 100744
// begin tw := tw [ 1 ] ;
100669: LD_ADDR_VAR 0 7
100673: PUSH
100674: LD_VAR 0 7
100678: PUSH
100679: LD_INT 1
100681: ARRAY
100682: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
100683: LD_ADDR_VAR 0 9
100687: PUSH
100688: LD_VAR 0 7
100692: PPUSH
100693: LD_EXP 186
100697: PUSH
100698: LD_VAR 0 2
100702: ARRAY
100703: PPUSH
100704: CALL 29203 0 2
100708: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
100709: LD_EXP 200
100713: PUSH
100714: LD_VAR 0 2
100718: ARRAY
100719: IFFALSE 100742
// if not weapon in mc_allowed_tower_weapons [ i ] then
100721: LD_VAR 0 9
100725: PUSH
100726: LD_EXP 200
100730: PUSH
100731: LD_VAR 0 2
100735: ARRAY
100736: IN
100737: NOT
100738: IFFALSE 100742
// continue ;
100740: GO 100444
// end else
100742: GO 100807
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
100744: LD_ADDR_VAR 0 5
100748: PUSH
100749: LD_EXP 169
100753: PUSH
100754: LD_VAR 0 2
100758: ARRAY
100759: PPUSH
100760: LD_VAR 0 4
100764: PPUSH
100765: CALL 56093 0 2
100769: ST_TO_ADDR
// if not tmp2 then
100770: LD_VAR 0 5
100774: NOT
100775: IFFALSE 100779
// continue ;
100777: GO 100444
// tw := tmp2 [ 1 ] ;
100779: LD_ADDR_VAR 0 7
100783: PUSH
100784: LD_VAR 0 5
100788: PUSH
100789: LD_INT 1
100791: ARRAY
100792: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
100793: LD_ADDR_VAR 0 9
100797: PUSH
100798: LD_VAR 0 5
100802: PUSH
100803: LD_INT 2
100805: ARRAY
100806: ST_TO_ADDR
// end ; if not weapon then
100807: LD_VAR 0 9
100811: NOT
100812: IFFALSE 100816
// continue ;
100814: GO 100444
// ComPlaceWeapon ( tw , weapon ) ;
100816: LD_VAR 0 7
100820: PPUSH
100821: LD_VAR 0 9
100825: PPUSH
100826: CALL_OW 148
// end ;
100830: GO 100444
100832: POP
100833: POP
// end ;
100834: LD_VAR 0 1
100838: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list , r ; begin
100839: LD_INT 0
100841: PPUSH
100842: PPUSH
100843: PPUSH
100844: PPUSH
100845: PPUSH
100846: PPUSH
100847: PPUSH
// if not mc_bases then
100848: LD_EXP 161
100852: NOT
100853: IFFALSE 100857
// exit ;
100855: GO 101632
// for i = 1 to mc_bases do
100857: LD_ADDR_VAR 0 2
100861: PUSH
100862: DOUBLE
100863: LD_INT 1
100865: DEC
100866: ST_TO_ADDR
100867: LD_EXP 161
100871: PUSH
100872: FOR_TO
100873: IFFALSE 101630
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] or mc_scan [ i ] then
100875: LD_EXP 174
100879: PUSH
100880: LD_VAR 0 2
100884: ARRAY
100885: NOT
100886: PUSH
100887: LD_EXP 174
100891: PUSH
100892: LD_VAR 0 2
100896: ARRAY
100897: PUSH
100898: LD_EXP 175
100902: PUSH
100903: LD_VAR 0 2
100907: ARRAY
100908: EQUAL
100909: OR
100910: PUSH
100911: LD_EXP 184
100915: PUSH
100916: LD_VAR 0 2
100920: ARRAY
100921: OR
100922: IFFALSE 100926
// continue ;
100924: GO 100872
// if mc_miners [ i ] then
100926: LD_EXP 175
100930: PUSH
100931: LD_VAR 0 2
100935: ARRAY
100936: IFFALSE 101317
// begin for j = mc_miners [ i ] downto 1 do
100938: LD_ADDR_VAR 0 3
100942: PUSH
100943: DOUBLE
100944: LD_EXP 175
100948: PUSH
100949: LD_VAR 0 2
100953: ARRAY
100954: INC
100955: ST_TO_ADDR
100956: LD_INT 1
100958: PUSH
100959: FOR_DOWNTO
100960: IFFALSE 101315
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
100962: LD_EXP 175
100966: PUSH
100967: LD_VAR 0 2
100971: ARRAY
100972: PUSH
100973: LD_VAR 0 3
100977: ARRAY
100978: PPUSH
100979: CALL_OW 301
100983: PUSH
100984: LD_EXP 175
100988: PUSH
100989: LD_VAR 0 2
100993: ARRAY
100994: PUSH
100995: LD_VAR 0 3
100999: ARRAY
101000: PPUSH
101001: CALL_OW 257
101005: PUSH
101006: LD_INT 1
101008: NONEQUAL
101009: OR
101010: IFFALSE 101073
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
101012: LD_ADDR_VAR 0 5
101016: PUSH
101017: LD_EXP 175
101021: PUSH
101022: LD_VAR 0 2
101026: ARRAY
101027: PUSH
101028: LD_EXP 175
101032: PUSH
101033: LD_VAR 0 2
101037: ARRAY
101038: PUSH
101039: LD_VAR 0 3
101043: ARRAY
101044: DIFF
101045: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
101046: LD_ADDR_EXP 175
101050: PUSH
101051: LD_EXP 175
101055: PPUSH
101056: LD_VAR 0 2
101060: PPUSH
101061: LD_VAR 0 5
101065: PPUSH
101066: CALL_OW 1
101070: ST_TO_ADDR
// continue ;
101071: GO 100959
// end ; if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and not HasTask ( mc_miners [ i ] [ j ] ) then
101073: LD_EXP 175
101077: PUSH
101078: LD_VAR 0 2
101082: ARRAY
101083: PUSH
101084: LD_VAR 0 3
101088: ARRAY
101089: PPUSH
101090: CALL_OW 257
101094: PUSH
101095: LD_INT 1
101097: EQUAL
101098: PUSH
101099: LD_EXP 175
101103: PUSH
101104: LD_VAR 0 2
101108: ARRAY
101109: PUSH
101110: LD_VAR 0 3
101114: ARRAY
101115: PPUSH
101116: CALL_OW 459
101120: NOT
101121: AND
101122: PUSH
101123: LD_EXP 175
101127: PUSH
101128: LD_VAR 0 2
101132: ARRAY
101133: PUSH
101134: LD_VAR 0 3
101138: ARRAY
101139: PPUSH
101140: CALL_OW 314
101144: NOT
101145: AND
101146: IFFALSE 101313
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
101148: LD_EXP 175
101152: PUSH
101153: LD_VAR 0 2
101157: ARRAY
101158: PUSH
101159: LD_VAR 0 3
101163: ARRAY
101164: PPUSH
101165: CALL_OW 310
101169: IFFALSE 101192
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
101171: LD_EXP 175
101175: PUSH
101176: LD_VAR 0 2
101180: ARRAY
101181: PUSH
101182: LD_VAR 0 3
101186: ARRAY
101187: PPUSH
101188: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
101192: LD_EXP 175
101196: PUSH
101197: LD_VAR 0 2
101201: ARRAY
101202: PUSH
101203: LD_VAR 0 3
101207: ARRAY
101208: PPUSH
101209: CALL_OW 314
101213: NOT
101214: IFFALSE 101313
// begin r := ( j mod Count ( mc_mines [ i ] ) ) + 1 ;
101216: LD_ADDR_VAR 0 7
101220: PUSH
101221: LD_VAR 0 3
101225: PUSH
101226: LD_EXP 174
101230: PUSH
101231: LD_VAR 0 2
101235: ARRAY
101236: PPUSH
101237: CALL 21326 0 1
101241: MOD
101242: PUSH
101243: LD_INT 1
101245: PLUS
101246: ST_TO_ADDR
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ r ] [ 1 ] , mc_mines [ i ] [ r ] [ 2 ] , 0 ) ;
101247: LD_EXP 175
101251: PUSH
101252: LD_VAR 0 2
101256: ARRAY
101257: PUSH
101258: LD_VAR 0 3
101262: ARRAY
101263: PPUSH
101264: LD_EXP 174
101268: PUSH
101269: LD_VAR 0 2
101273: ARRAY
101274: PUSH
101275: LD_VAR 0 7
101279: ARRAY
101280: PUSH
101281: LD_INT 1
101283: ARRAY
101284: PPUSH
101285: LD_EXP 174
101289: PUSH
101290: LD_VAR 0 2
101294: ARRAY
101295: PUSH
101296: LD_VAR 0 7
101300: ARRAY
101301: PUSH
101302: LD_INT 2
101304: ARRAY
101305: PPUSH
101306: LD_INT 0
101308: PPUSH
101309: CALL_OW 193
// end ; end ; end ;
101313: GO 100959
101315: POP
101316: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
101317: LD_ADDR_VAR 0 5
101321: PUSH
101322: LD_EXP 161
101326: PUSH
101327: LD_VAR 0 2
101331: ARRAY
101332: PPUSH
101333: LD_INT 2
101335: PUSH
101336: LD_INT 30
101338: PUSH
101339: LD_INT 4
101341: PUSH
101342: EMPTY
101343: LIST
101344: LIST
101345: PUSH
101346: LD_INT 30
101348: PUSH
101349: LD_INT 5
101351: PUSH
101352: EMPTY
101353: LIST
101354: LIST
101355: PUSH
101356: LD_INT 30
101358: PUSH
101359: LD_INT 32
101361: PUSH
101362: EMPTY
101363: LIST
101364: LIST
101365: PUSH
101366: EMPTY
101367: LIST
101368: LIST
101369: LIST
101370: LIST
101371: PPUSH
101372: CALL_OW 72
101376: ST_TO_ADDR
// if not tmp then
101377: LD_VAR 0 5
101381: NOT
101382: IFFALSE 101386
// continue ;
101384: GO 100872
// list := [ ] ;
101386: LD_ADDR_VAR 0 6
101390: PUSH
101391: EMPTY
101392: ST_TO_ADDR
// for j in tmp do
101393: LD_ADDR_VAR 0 3
101397: PUSH
101398: LD_VAR 0 5
101402: PUSH
101403: FOR_IN
101404: IFFALSE 101473
// begin for k in UnitsInside ( j ) do
101406: LD_ADDR_VAR 0 4
101410: PUSH
101411: LD_VAR 0 3
101415: PPUSH
101416: CALL_OW 313
101420: PUSH
101421: FOR_IN
101422: IFFALSE 101469
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
101424: LD_VAR 0 4
101428: PPUSH
101429: CALL_OW 257
101433: PUSH
101434: LD_INT 1
101436: EQUAL
101437: PUSH
101438: LD_VAR 0 4
101442: PPUSH
101443: CALL_OW 459
101447: NOT
101448: AND
101449: IFFALSE 101467
// list := list ^ k ;
101451: LD_ADDR_VAR 0 6
101455: PUSH
101456: LD_VAR 0 6
101460: PUSH
101461: LD_VAR 0 4
101465: ADD
101466: ST_TO_ADDR
101467: GO 101421
101469: POP
101470: POP
// end ;
101471: GO 101403
101473: POP
101474: POP
// list := list diff mc_miners [ i ] ;
101475: LD_ADDR_VAR 0 6
101479: PUSH
101480: LD_VAR 0 6
101484: PUSH
101485: LD_EXP 175
101489: PUSH
101490: LD_VAR 0 2
101494: ARRAY
101495: DIFF
101496: ST_TO_ADDR
// if not list then
101497: LD_VAR 0 6
101501: NOT
101502: IFFALSE 101506
// continue ;
101504: GO 100872
// k := mc_mines [ i ] - mc_miners [ i ] ;
101506: LD_ADDR_VAR 0 4
101510: PUSH
101511: LD_EXP 174
101515: PUSH
101516: LD_VAR 0 2
101520: ARRAY
101521: PUSH
101522: LD_EXP 175
101526: PUSH
101527: LD_VAR 0 2
101531: ARRAY
101532: MINUS
101533: ST_TO_ADDR
// if k > list then
101534: LD_VAR 0 4
101538: PUSH
101539: LD_VAR 0 6
101543: GREATER
101544: IFFALSE 101556
// k := list ;
101546: LD_ADDR_VAR 0 4
101550: PUSH
101551: LD_VAR 0 6
101555: ST_TO_ADDR
// for j = 1 to k do
101556: LD_ADDR_VAR 0 3
101560: PUSH
101561: DOUBLE
101562: LD_INT 1
101564: DEC
101565: ST_TO_ADDR
101566: LD_VAR 0 4
101570: PUSH
101571: FOR_TO
101572: IFFALSE 101626
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
101574: LD_ADDR_EXP 175
101578: PUSH
101579: LD_EXP 175
101583: PPUSH
101584: LD_VAR 0 2
101588: PUSH
101589: LD_EXP 175
101593: PUSH
101594: LD_VAR 0 2
101598: ARRAY
101599: PUSH
101600: LD_INT 1
101602: PLUS
101603: PUSH
101604: EMPTY
101605: LIST
101606: LIST
101607: PPUSH
101608: LD_VAR 0 6
101612: PUSH
101613: LD_VAR 0 3
101617: ARRAY
101618: PPUSH
101619: CALL 24186 0 3
101623: ST_TO_ADDR
101624: GO 101571
101626: POP
101627: POP
// end ;
101628: GO 100872
101630: POP
101631: POP
// end ;
101632: LD_VAR 0 1
101636: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , side , target , cargo , depot , fac , components ; begin
101637: LD_INT 0
101639: PPUSH
101640: PPUSH
101641: PPUSH
101642: PPUSH
101643: PPUSH
101644: PPUSH
101645: PPUSH
101646: PPUSH
101647: PPUSH
101648: PPUSH
101649: PPUSH
// if not mc_bases then
101650: LD_EXP 161
101654: NOT
101655: IFFALSE 101659
// exit ;
101657: GO 103482
// for i = 1 to mc_bases do
101659: LD_ADDR_VAR 0 2
101663: PUSH
101664: DOUBLE
101665: LD_INT 1
101667: DEC
101668: ST_TO_ADDR
101669: LD_EXP 161
101673: PUSH
101674: FOR_TO
101675: IFFALSE 103480
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
101677: LD_EXP 161
101681: PUSH
101682: LD_VAR 0 2
101686: ARRAY
101687: NOT
101688: PUSH
101689: LD_EXP 168
101693: PUSH
101694: LD_VAR 0 2
101698: ARRAY
101699: OR
101700: IFFALSE 101704
// continue ;
101702: GO 101674
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
101704: LD_EXP 177
101708: PUSH
101709: LD_VAR 0 2
101713: ARRAY
101714: NOT
101715: PUSH
101716: LD_EXP 178
101720: PUSH
101721: LD_VAR 0 2
101725: ARRAY
101726: AND
101727: IFFALSE 101765
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
101729: LD_ADDR_EXP 178
101733: PUSH
101734: LD_EXP 178
101738: PPUSH
101739: LD_VAR 0 2
101743: PPUSH
101744: EMPTY
101745: PPUSH
101746: CALL_OW 1
101750: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
101751: LD_VAR 0 2
101755: PPUSH
101756: LD_INT 107
101758: PPUSH
101759: CALL 92491 0 2
// continue ;
101763: GO 101674
// end ; target := [ ] ;
101765: LD_ADDR_VAR 0 7
101769: PUSH
101770: EMPTY
101771: ST_TO_ADDR
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
101772: LD_ADDR_VAR 0 6
101776: PUSH
101777: LD_EXP 161
101781: PUSH
101782: LD_VAR 0 2
101786: ARRAY
101787: PUSH
101788: LD_INT 1
101790: ARRAY
101791: PPUSH
101792: CALL_OW 255
101796: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
101797: LD_ADDR_VAR 0 9
101801: PUSH
101802: LD_EXP 161
101806: PUSH
101807: LD_VAR 0 2
101811: ARRAY
101812: PPUSH
101813: LD_INT 2
101815: PUSH
101816: LD_INT 30
101818: PUSH
101819: LD_INT 0
101821: PUSH
101822: EMPTY
101823: LIST
101824: LIST
101825: PUSH
101826: LD_INT 30
101828: PUSH
101829: LD_INT 1
101831: PUSH
101832: EMPTY
101833: LIST
101834: LIST
101835: PUSH
101836: EMPTY
101837: LIST
101838: LIST
101839: LIST
101840: PPUSH
101841: CALL_OW 72
101845: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
101846: LD_ADDR_VAR 0 3
101850: PUSH
101851: DOUBLE
101852: LD_EXP 177
101856: PUSH
101857: LD_VAR 0 2
101861: ARRAY
101862: INC
101863: ST_TO_ADDR
101864: LD_INT 1
101866: PUSH
101867: FOR_DOWNTO
101868: IFFALSE 102113
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
101870: LD_EXP 177
101874: PUSH
101875: LD_VAR 0 2
101879: ARRAY
101880: PUSH
101881: LD_VAR 0 3
101885: ARRAY
101886: PUSH
101887: LD_INT 2
101889: ARRAY
101890: PPUSH
101891: LD_EXP 177
101895: PUSH
101896: LD_VAR 0 2
101900: ARRAY
101901: PUSH
101902: LD_VAR 0 3
101906: ARRAY
101907: PUSH
101908: LD_INT 3
101910: ARRAY
101911: PPUSH
101912: CALL_OW 488
101916: PUSH
101917: LD_EXP 177
101921: PUSH
101922: LD_VAR 0 2
101926: ARRAY
101927: PUSH
101928: LD_VAR 0 3
101932: ARRAY
101933: PUSH
101934: LD_INT 2
101936: ARRAY
101937: PPUSH
101938: LD_EXP 177
101942: PUSH
101943: LD_VAR 0 2
101947: ARRAY
101948: PUSH
101949: LD_VAR 0 3
101953: ARRAY
101954: PUSH
101955: LD_INT 3
101957: ARRAY
101958: PPUSH
101959: CALL_OW 284
101963: PUSH
101964: LD_INT 0
101966: EQUAL
101967: AND
101968: IFFALSE 102023
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
101970: LD_ADDR_VAR 0 5
101974: PUSH
101975: LD_EXP 177
101979: PUSH
101980: LD_VAR 0 2
101984: ARRAY
101985: PPUSH
101986: LD_VAR 0 3
101990: PPUSH
101991: CALL_OW 3
101995: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
101996: LD_ADDR_EXP 177
102000: PUSH
102001: LD_EXP 177
102005: PPUSH
102006: LD_VAR 0 2
102010: PPUSH
102011: LD_VAR 0 5
102015: PPUSH
102016: CALL_OW 1
102020: ST_TO_ADDR
// continue ;
102021: GO 101867
// end ; if DangerAtRangeXY ( side , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
102023: LD_VAR 0 6
102027: PPUSH
102028: LD_EXP 177
102032: PUSH
102033: LD_VAR 0 2
102037: ARRAY
102038: PUSH
102039: LD_VAR 0 3
102043: ARRAY
102044: PUSH
102045: LD_INT 2
102047: ARRAY
102048: PPUSH
102049: LD_EXP 177
102053: PUSH
102054: LD_VAR 0 2
102058: ARRAY
102059: PUSH
102060: LD_VAR 0 3
102064: ARRAY
102065: PUSH
102066: LD_INT 3
102068: ARRAY
102069: PPUSH
102070: LD_INT 30
102072: PPUSH
102073: CALL 25082 0 4
102077: PUSH
102078: LD_INT 4
102080: ARRAY
102081: PUSH
102082: LD_INT 0
102084: EQUAL
102085: IFFALSE 102111
// begin target := mc_crates [ i ] [ j ] ;
102087: LD_ADDR_VAR 0 7
102091: PUSH
102092: LD_EXP 177
102096: PUSH
102097: LD_VAR 0 2
102101: ARRAY
102102: PUSH
102103: LD_VAR 0 3
102107: ARRAY
102108: ST_TO_ADDR
// break ;
102109: GO 102113
// end ; end ;
102111: GO 101867
102113: POP
102114: POP
// if not target then
102115: LD_VAR 0 7
102119: NOT
102120: IFFALSE 102124
// continue ;
102122: GO 101674
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
102124: LD_ADDR_VAR 0 8
102128: PUSH
102129: LD_EXP 180
102133: PUSH
102134: LD_VAR 0 2
102138: ARRAY
102139: PPUSH
102140: LD_INT 2
102142: PUSH
102143: LD_INT 3
102145: PUSH
102146: LD_INT 58
102148: PUSH
102149: EMPTY
102150: LIST
102151: PUSH
102152: EMPTY
102153: LIST
102154: LIST
102155: PUSH
102156: LD_INT 61
102158: PUSH
102159: EMPTY
102160: LIST
102161: PUSH
102162: LD_INT 33
102164: PUSH
102165: LD_INT 5
102167: PUSH
102168: EMPTY
102169: LIST
102170: LIST
102171: PUSH
102172: LD_INT 33
102174: PUSH
102175: LD_INT 3
102177: PUSH
102178: EMPTY
102179: LIST
102180: LIST
102181: PUSH
102182: EMPTY
102183: LIST
102184: LIST
102185: LIST
102186: LIST
102187: LIST
102188: PUSH
102189: LD_INT 2
102191: PUSH
102192: LD_INT 34
102194: PUSH
102195: LD_INT 32
102197: PUSH
102198: EMPTY
102199: LIST
102200: LIST
102201: PUSH
102202: LD_INT 34
102204: PUSH
102205: LD_INT 51
102207: PUSH
102208: EMPTY
102209: LIST
102210: LIST
102211: PUSH
102212: LD_INT 34
102214: PUSH
102215: LD_INT 12
102217: PUSH
102218: EMPTY
102219: LIST
102220: LIST
102221: PUSH
102222: EMPTY
102223: LIST
102224: LIST
102225: LIST
102226: LIST
102227: PUSH
102228: EMPTY
102229: LIST
102230: LIST
102231: PPUSH
102232: CALL_OW 72
102236: ST_TO_ADDR
// if not cargo then
102237: LD_VAR 0 8
102241: NOT
102242: IFFALSE 102948
// begin if mc_crates_collector [ i ] < 5 then
102244: LD_EXP 178
102248: PUSH
102249: LD_VAR 0 2
102253: ARRAY
102254: PUSH
102255: LD_INT 5
102257: LESS
102258: IFFALSE 102624
// begin if mc_ape [ i ] then
102260: LD_EXP 190
102264: PUSH
102265: LD_VAR 0 2
102269: ARRAY
102270: IFFALSE 102317
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
102272: LD_ADDR_VAR 0 5
102276: PUSH
102277: LD_EXP 190
102281: PUSH
102282: LD_VAR 0 2
102286: ARRAY
102287: PPUSH
102288: LD_INT 25
102290: PUSH
102291: LD_INT 16
102293: PUSH
102294: EMPTY
102295: LIST
102296: LIST
102297: PUSH
102298: LD_INT 24
102300: PUSH
102301: LD_INT 750
102303: PUSH
102304: EMPTY
102305: LIST
102306: LIST
102307: PUSH
102308: EMPTY
102309: LIST
102310: LIST
102311: PPUSH
102312: CALL_OW 72
102316: ST_TO_ADDR
// if not tmp then
102317: LD_VAR 0 5
102321: NOT
102322: IFFALSE 102369
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
102324: LD_ADDR_VAR 0 5
102328: PUSH
102329: LD_EXP 161
102333: PUSH
102334: LD_VAR 0 2
102338: ARRAY
102339: PPUSH
102340: LD_INT 25
102342: PUSH
102343: LD_INT 2
102345: PUSH
102346: EMPTY
102347: LIST
102348: LIST
102349: PUSH
102350: LD_INT 24
102352: PUSH
102353: LD_INT 750
102355: PUSH
102356: EMPTY
102357: LIST
102358: LIST
102359: PUSH
102360: EMPTY
102361: LIST
102362: LIST
102363: PPUSH
102364: CALL_OW 72
102368: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
102369: LD_EXP 190
102373: PUSH
102374: LD_VAR 0 2
102378: ARRAY
102379: PUSH
102380: LD_EXP 161
102384: PUSH
102385: LD_VAR 0 2
102389: ARRAY
102390: PPUSH
102391: LD_INT 25
102393: PUSH
102394: LD_INT 2
102396: PUSH
102397: EMPTY
102398: LIST
102399: LIST
102400: PUSH
102401: LD_INT 24
102403: PUSH
102404: LD_INT 750
102406: PUSH
102407: EMPTY
102408: LIST
102409: LIST
102410: PUSH
102411: EMPTY
102412: LIST
102413: LIST
102414: PPUSH
102415: CALL_OW 72
102419: AND
102420: PUSH
102421: LD_VAR 0 5
102425: PUSH
102426: LD_INT 5
102428: LESS
102429: AND
102430: IFFALSE 102512
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
102432: LD_ADDR_VAR 0 3
102436: PUSH
102437: LD_EXP 161
102441: PUSH
102442: LD_VAR 0 2
102446: ARRAY
102447: PPUSH
102448: LD_INT 25
102450: PUSH
102451: LD_INT 2
102453: PUSH
102454: EMPTY
102455: LIST
102456: LIST
102457: PUSH
102458: LD_INT 24
102460: PUSH
102461: LD_INT 750
102463: PUSH
102464: EMPTY
102465: LIST
102466: LIST
102467: PUSH
102468: EMPTY
102469: LIST
102470: LIST
102471: PPUSH
102472: CALL_OW 72
102476: PUSH
102477: FOR_IN
102478: IFFALSE 102510
// begin tmp := tmp union j ;
102480: LD_ADDR_VAR 0 5
102484: PUSH
102485: LD_VAR 0 5
102489: PUSH
102490: LD_VAR 0 3
102494: UNION
102495: ST_TO_ADDR
// if tmp >= 5 then
102496: LD_VAR 0 5
102500: PUSH
102501: LD_INT 5
102503: GREATEREQUAL
102504: IFFALSE 102508
// break ;
102506: GO 102510
// end ;
102508: GO 102477
102510: POP
102511: POP
// end ; if not tmp then
102512: LD_VAR 0 5
102516: NOT
102517: IFFALSE 102521
// continue ;
102519: GO 101674
// for j in tmp do
102521: LD_ADDR_VAR 0 3
102525: PUSH
102526: LD_VAR 0 5
102530: PUSH
102531: FOR_IN
102532: IFFALSE 102622
// if not GetTag ( j ) then
102534: LD_VAR 0 3
102538: PPUSH
102539: CALL_OW 110
102543: NOT
102544: IFFALSE 102620
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
102546: LD_ADDR_EXP 178
102550: PUSH
102551: LD_EXP 178
102555: PPUSH
102556: LD_VAR 0 2
102560: PUSH
102561: LD_EXP 178
102565: PUSH
102566: LD_VAR 0 2
102570: ARRAY
102571: PUSH
102572: LD_INT 1
102574: PLUS
102575: PUSH
102576: EMPTY
102577: LIST
102578: LIST
102579: PPUSH
102580: LD_VAR 0 3
102584: PPUSH
102585: CALL 24186 0 3
102589: ST_TO_ADDR
// SetTag ( j , 107 ) ;
102590: LD_VAR 0 3
102594: PPUSH
102595: LD_INT 107
102597: PPUSH
102598: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
102602: LD_EXP 178
102606: PUSH
102607: LD_VAR 0 2
102611: ARRAY
102612: PUSH
102613: LD_INT 5
102615: GREATEREQUAL
102616: IFFALSE 102620
// break ;
102618: GO 102622
// end ;
102620: GO 102531
102622: POP
102623: POP
// end ; if mc_crates_collector [ i ] and target then
102624: LD_EXP 178
102628: PUSH
102629: LD_VAR 0 2
102633: ARRAY
102634: PUSH
102635: LD_VAR 0 7
102639: AND
102640: IFFALSE 102946
// begin if mc_crates_collector [ i ] < target [ 1 ] then
102642: LD_EXP 178
102646: PUSH
102647: LD_VAR 0 2
102651: ARRAY
102652: PUSH
102653: LD_VAR 0 7
102657: PUSH
102658: LD_INT 1
102660: ARRAY
102661: LESS
102662: IFFALSE 102682
// tmp := mc_crates_collector [ i ] else
102664: LD_ADDR_VAR 0 5
102668: PUSH
102669: LD_EXP 178
102673: PUSH
102674: LD_VAR 0 2
102678: ARRAY
102679: ST_TO_ADDR
102680: GO 102696
// tmp := target [ 1 ] ;
102682: LD_ADDR_VAR 0 5
102686: PUSH
102687: LD_VAR 0 7
102691: PUSH
102692: LD_INT 1
102694: ARRAY
102695: ST_TO_ADDR
// k := 0 ;
102696: LD_ADDR_VAR 0 4
102700: PUSH
102701: LD_INT 0
102703: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
102704: LD_ADDR_VAR 0 3
102708: PUSH
102709: LD_EXP 178
102713: PUSH
102714: LD_VAR 0 2
102718: ARRAY
102719: PUSH
102720: FOR_IN
102721: IFFALSE 102944
// begin k := k + 1 ;
102723: LD_ADDR_VAR 0 4
102727: PUSH
102728: LD_VAR 0 4
102732: PUSH
102733: LD_INT 1
102735: PLUS
102736: ST_TO_ADDR
// if k > tmp then
102737: LD_VAR 0 4
102741: PUSH
102742: LD_VAR 0 5
102746: GREATER
102747: IFFALSE 102751
// break ;
102749: GO 102944
// if not GetClass ( j ) in [ 2 , 16 ] then
102751: LD_VAR 0 3
102755: PPUSH
102756: CALL_OW 257
102760: PUSH
102761: LD_INT 2
102763: PUSH
102764: LD_INT 16
102766: PUSH
102767: EMPTY
102768: LIST
102769: LIST
102770: IN
102771: NOT
102772: IFFALSE 102825
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
102774: LD_ADDR_EXP 178
102778: PUSH
102779: LD_EXP 178
102783: PPUSH
102784: LD_VAR 0 2
102788: PPUSH
102789: LD_EXP 178
102793: PUSH
102794: LD_VAR 0 2
102798: ARRAY
102799: PUSH
102800: LD_VAR 0 3
102804: DIFF
102805: PPUSH
102806: CALL_OW 1
102810: ST_TO_ADDR
// SetTag ( j , 0 ) ;
102811: LD_VAR 0 3
102815: PPUSH
102816: LD_INT 0
102818: PPUSH
102819: CALL_OW 109
// continue ;
102823: GO 102720
// end ; if IsInUnit ( j ) then
102825: LD_VAR 0 3
102829: PPUSH
102830: CALL_OW 310
102834: IFFALSE 102845
// ComExitBuilding ( j ) ;
102836: LD_VAR 0 3
102840: PPUSH
102841: CALL_OW 122
// wait ( 3 ) ;
102845: LD_INT 3
102847: PPUSH
102848: CALL_OW 67
// if HasTask ( j ) and DangerAtRangeXY ( side , target [ 2 ] , target [ 3 ] , 30 ) [ 4 ] then
102852: LD_VAR 0 3
102856: PPUSH
102857: CALL_OW 314
102861: PUSH
102862: LD_VAR 0 6
102866: PPUSH
102867: LD_VAR 0 7
102871: PUSH
102872: LD_INT 2
102874: ARRAY
102875: PPUSH
102876: LD_VAR 0 7
102880: PUSH
102881: LD_INT 3
102883: ARRAY
102884: PPUSH
102885: LD_INT 30
102887: PPUSH
102888: CALL 25082 0 4
102892: PUSH
102893: LD_INT 4
102895: ARRAY
102896: AND
102897: IFFALSE 102915
// ComStandNearbyBuilding ( j , depot ) else
102899: LD_VAR 0 3
102903: PPUSH
102904: LD_VAR 0 9
102908: PPUSH
102909: CALL 20788 0 2
102913: GO 102942
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
102915: LD_VAR 0 3
102919: PPUSH
102920: LD_VAR 0 7
102924: PUSH
102925: LD_INT 2
102927: ARRAY
102928: PPUSH
102929: LD_VAR 0 7
102933: PUSH
102934: LD_INT 3
102936: ARRAY
102937: PPUSH
102938: CALL_OW 117
// end ;
102942: GO 102720
102944: POP
102945: POP
// end ; end else
102946: GO 103478
// begin for j in cargo do
102948: LD_ADDR_VAR 0 3
102952: PUSH
102953: LD_VAR 0 8
102957: PUSH
102958: FOR_IN
102959: IFFALSE 103476
// begin if GetTag ( j ) <> 0 then
102961: LD_VAR 0 3
102965: PPUSH
102966: CALL_OW 110
102970: PUSH
102971: LD_INT 0
102973: NONEQUAL
102974: IFFALSE 102978
// continue ;
102976: GO 102958
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
102978: LD_VAR 0 3
102982: PPUSH
102983: CALL_OW 256
102987: PUSH
102988: LD_INT 1000
102990: LESS
102991: PUSH
102992: LD_VAR 0 3
102996: PPUSH
102997: LD_EXP 185
103001: PUSH
103002: LD_VAR 0 2
103006: ARRAY
103007: PPUSH
103008: CALL_OW 308
103012: NOT
103013: AND
103014: IFFALSE 103036
// ComMoveToArea ( j , mc_parking [ i ] ) ;
103016: LD_VAR 0 3
103020: PPUSH
103021: LD_EXP 185
103025: PUSH
103026: LD_VAR 0 2
103030: ARRAY
103031: PPUSH
103032: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
103036: LD_VAR 0 3
103040: PPUSH
103041: CALL_OW 256
103045: PUSH
103046: LD_INT 1000
103048: LESS
103049: PUSH
103050: LD_VAR 0 3
103054: PPUSH
103055: LD_EXP 185
103059: PUSH
103060: LD_VAR 0 2
103064: ARRAY
103065: PPUSH
103066: CALL_OW 308
103070: AND
103071: IFFALSE 103075
// continue ;
103073: GO 102958
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
103075: LD_VAR 0 3
103079: PPUSH
103080: CALL_OW 262
103084: PUSH
103085: LD_INT 2
103087: EQUAL
103088: PUSH
103089: LD_VAR 0 3
103093: PPUSH
103094: CALL_OW 261
103098: PUSH
103099: LD_INT 15
103101: LESS
103102: AND
103103: IFFALSE 103107
// continue ;
103105: GO 102958
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
103107: LD_VAR 0 3
103111: PPUSH
103112: CALL_OW 262
103116: PUSH
103117: LD_INT 1
103119: EQUAL
103120: PUSH
103121: LD_VAR 0 3
103125: PPUSH
103126: CALL_OW 261
103130: PUSH
103131: LD_INT 10
103133: LESS
103134: AND
103135: IFFALSE 103415
// begin if not depot then
103137: LD_VAR 0 9
103141: NOT
103142: IFFALSE 103146
// continue ;
103144: GO 102958
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
103146: LD_VAR 0 3
103150: PPUSH
103151: LD_VAR 0 9
103155: PPUSH
103156: LD_VAR 0 3
103160: PPUSH
103161: CALL_OW 74
103165: PPUSH
103166: CALL_OW 296
103170: PUSH
103171: LD_INT 6
103173: LESS
103174: IFFALSE 103190
// SetFuel ( j , 100 ) else
103176: LD_VAR 0 3
103180: PPUSH
103181: LD_INT 100
103183: PPUSH
103184: CALL_OW 240
103188: GO 103415
// if GetFuel ( j ) = 0 then
103190: LD_VAR 0 3
103194: PPUSH
103195: CALL_OW 261
103199: PUSH
103200: LD_INT 0
103202: EQUAL
103203: IFFALSE 103415
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
103205: LD_ADDR_EXP 180
103209: PUSH
103210: LD_EXP 180
103214: PPUSH
103215: LD_VAR 0 2
103219: PPUSH
103220: LD_EXP 180
103224: PUSH
103225: LD_VAR 0 2
103229: ARRAY
103230: PUSH
103231: LD_VAR 0 3
103235: DIFF
103236: PPUSH
103237: CALL_OW 1
103241: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
103242: LD_VAR 0 3
103246: PPUSH
103247: CALL_OW 263
103251: PUSH
103252: LD_INT 1
103254: EQUAL
103255: IFFALSE 103271
// ComExitVehicle ( IsInUnit ( j ) ) ;
103257: LD_VAR 0 3
103261: PPUSH
103262: CALL_OW 310
103266: PPUSH
103267: CALL_OW 121
// if GetControl ( j ) = control_remote then
103271: LD_VAR 0 3
103275: PPUSH
103276: CALL_OW 263
103280: PUSH
103281: LD_INT 2
103283: EQUAL
103284: IFFALSE 103295
// ComUnlink ( j ) ;
103286: LD_VAR 0 3
103290: PPUSH
103291: CALL_OW 136
// fac := MC_GetBuildings ( i , b_factory ) ;
103295: LD_ADDR_VAR 0 10
103299: PUSH
103300: LD_VAR 0 2
103304: PPUSH
103305: LD_INT 3
103307: PPUSH
103308: CALL 113059 0 2
103312: ST_TO_ADDR
// if fac then
103313: LD_VAR 0 10
103317: IFFALSE 103413
// begin for k in fac do
103319: LD_ADDR_VAR 0 4
103323: PUSH
103324: LD_VAR 0 10
103328: PUSH
103329: FOR_IN
103330: IFFALSE 103411
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
103332: LD_ADDR_VAR 0 11
103336: PUSH
103337: LD_VAR 0 10
103341: PPUSH
103342: LD_VAR 0 3
103346: PPUSH
103347: CALL_OW 265
103351: PPUSH
103352: LD_VAR 0 3
103356: PPUSH
103357: CALL_OW 262
103361: PPUSH
103362: LD_VAR 0 3
103366: PPUSH
103367: CALL_OW 263
103371: PPUSH
103372: LD_VAR 0 3
103376: PPUSH
103377: CALL_OW 264
103381: PPUSH
103382: CALL 21684 0 5
103386: ST_TO_ADDR
// if components then
103387: LD_VAR 0 11
103391: IFFALSE 103409
// begin MC_InsertProduceList ( i , components ) ;
103393: LD_VAR 0 2
103397: PPUSH
103398: LD_VAR 0 11
103402: PPUSH
103403: CALL 112604 0 2
// break ;
103407: GO 103411
// end ; end ;
103409: GO 103329
103411: POP
103412: POP
// end ; continue ;
103413: GO 102958
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
103415: LD_VAR 0 3
103419: PPUSH
103420: LD_INT 1
103422: PPUSH
103423: CALL_OW 289
103427: PUSH
103428: LD_INT 100
103430: LESS
103431: PUSH
103432: LD_VAR 0 3
103436: PPUSH
103437: CALL_OW 314
103441: NOT
103442: AND
103443: IFFALSE 103472
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
103445: LD_VAR 0 3
103449: PPUSH
103450: LD_VAR 0 7
103454: PUSH
103455: LD_INT 2
103457: ARRAY
103458: PPUSH
103459: LD_VAR 0 7
103463: PUSH
103464: LD_INT 3
103466: ARRAY
103467: PPUSH
103468: CALL_OW 117
// break ;
103472: GO 103476
// end ;
103474: GO 102958
103476: POP
103477: POP
// end ; end ;
103478: GO 101674
103480: POP
103481: POP
// end ;
103482: LD_VAR 0 1
103486: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
103487: LD_INT 0
103489: PPUSH
103490: PPUSH
103491: PPUSH
103492: PPUSH
// if not mc_bases then
103493: LD_EXP 161
103497: NOT
103498: IFFALSE 103502
// exit ;
103500: GO 103663
// for i = 1 to mc_bases do
103502: LD_ADDR_VAR 0 2
103506: PUSH
103507: DOUBLE
103508: LD_INT 1
103510: DEC
103511: ST_TO_ADDR
103512: LD_EXP 161
103516: PUSH
103517: FOR_TO
103518: IFFALSE 103661
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
103520: LD_ADDR_VAR 0 4
103524: PUSH
103525: LD_EXP 180
103529: PUSH
103530: LD_VAR 0 2
103534: ARRAY
103535: PUSH
103536: LD_EXP 183
103540: PUSH
103541: LD_VAR 0 2
103545: ARRAY
103546: UNION
103547: PPUSH
103548: LD_INT 33
103550: PUSH
103551: LD_INT 2
103553: PUSH
103554: EMPTY
103555: LIST
103556: LIST
103557: PPUSH
103558: CALL_OW 72
103562: ST_TO_ADDR
// if tmp then
103563: LD_VAR 0 4
103567: IFFALSE 103659
// for j in tmp do
103569: LD_ADDR_VAR 0 3
103573: PUSH
103574: LD_VAR 0 4
103578: PUSH
103579: FOR_IN
103580: IFFALSE 103657
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
103582: LD_VAR 0 3
103586: PPUSH
103587: CALL_OW 312
103591: NOT
103592: PUSH
103593: LD_VAR 0 3
103597: PPUSH
103598: CALL_OW 256
103602: PUSH
103603: LD_INT 250
103605: GREATEREQUAL
103606: AND
103607: IFFALSE 103620
// Connect ( j ) else
103609: LD_VAR 0 3
103613: PPUSH
103614: CALL 27164 0 1
103618: GO 103655
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
103620: LD_VAR 0 3
103624: PPUSH
103625: CALL_OW 256
103629: PUSH
103630: LD_INT 250
103632: LESS
103633: PUSH
103634: LD_VAR 0 3
103638: PPUSH
103639: CALL_OW 312
103643: AND
103644: IFFALSE 103655
// ComUnlink ( j ) ;
103646: LD_VAR 0 3
103650: PPUSH
103651: CALL_OW 136
103655: GO 103579
103657: POP
103658: POP
// end ;
103659: GO 103517
103661: POP
103662: POP
// end ;
103663: LD_VAR 0 1
103667: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
103668: LD_INT 0
103670: PPUSH
103671: PPUSH
103672: PPUSH
103673: PPUSH
103674: PPUSH
// if not mc_bases then
103675: LD_EXP 161
103679: NOT
103680: IFFALSE 103684
// exit ;
103682: GO 104129
// for i = 1 to mc_bases do
103684: LD_ADDR_VAR 0 2
103688: PUSH
103689: DOUBLE
103690: LD_INT 1
103692: DEC
103693: ST_TO_ADDR
103694: LD_EXP 161
103698: PUSH
103699: FOR_TO
103700: IFFALSE 104127
// begin if not mc_produce [ i ] then
103702: LD_EXP 182
103706: PUSH
103707: LD_VAR 0 2
103711: ARRAY
103712: NOT
103713: IFFALSE 103717
// continue ;
103715: GO 103699
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
103717: LD_ADDR_VAR 0 5
103721: PUSH
103722: LD_EXP 161
103726: PUSH
103727: LD_VAR 0 2
103731: ARRAY
103732: PPUSH
103733: LD_INT 30
103735: PUSH
103736: LD_INT 3
103738: PUSH
103739: EMPTY
103740: LIST
103741: LIST
103742: PPUSH
103743: CALL_OW 72
103747: ST_TO_ADDR
// if not fac then
103748: LD_VAR 0 5
103752: NOT
103753: IFFALSE 103757
// continue ;
103755: GO 103699
// for j in fac do
103757: LD_ADDR_VAR 0 3
103761: PUSH
103762: LD_VAR 0 5
103766: PUSH
103767: FOR_IN
103768: IFFALSE 104123
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
103770: LD_VAR 0 3
103774: PPUSH
103775: CALL_OW 461
103779: PUSH
103780: LD_INT 2
103782: NONEQUAL
103783: PUSH
103784: LD_VAR 0 3
103788: PPUSH
103789: LD_INT 15
103791: PPUSH
103792: CALL 26783 0 2
103796: PUSH
103797: LD_INT 4
103799: ARRAY
103800: OR
103801: IFFALSE 103805
// continue ;
103803: GO 103767
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
103805: LD_VAR 0 3
103809: PPUSH
103810: LD_EXP 182
103814: PUSH
103815: LD_VAR 0 2
103819: ARRAY
103820: PUSH
103821: LD_INT 1
103823: ARRAY
103824: PUSH
103825: LD_INT 1
103827: ARRAY
103828: PPUSH
103829: LD_EXP 182
103833: PUSH
103834: LD_VAR 0 2
103838: ARRAY
103839: PUSH
103840: LD_INT 1
103842: ARRAY
103843: PUSH
103844: LD_INT 2
103846: ARRAY
103847: PPUSH
103848: LD_EXP 182
103852: PUSH
103853: LD_VAR 0 2
103857: ARRAY
103858: PUSH
103859: LD_INT 1
103861: ARRAY
103862: PUSH
103863: LD_INT 3
103865: ARRAY
103866: PPUSH
103867: LD_EXP 182
103871: PUSH
103872: LD_VAR 0 2
103876: ARRAY
103877: PUSH
103878: LD_INT 1
103880: ARRAY
103881: PUSH
103882: LD_INT 4
103884: ARRAY
103885: PPUSH
103886: CALL_OW 448
103890: PUSH
103891: LD_VAR 0 3
103895: PPUSH
103896: LD_EXP 182
103900: PUSH
103901: LD_VAR 0 2
103905: ARRAY
103906: PUSH
103907: LD_INT 1
103909: ARRAY
103910: PUSH
103911: LD_INT 1
103913: ARRAY
103914: PUSH
103915: LD_EXP 182
103919: PUSH
103920: LD_VAR 0 2
103924: ARRAY
103925: PUSH
103926: LD_INT 1
103928: ARRAY
103929: PUSH
103930: LD_INT 2
103932: ARRAY
103933: PUSH
103934: LD_EXP 182
103938: PUSH
103939: LD_VAR 0 2
103943: ARRAY
103944: PUSH
103945: LD_INT 1
103947: ARRAY
103948: PUSH
103949: LD_INT 3
103951: ARRAY
103952: PUSH
103953: LD_EXP 182
103957: PUSH
103958: LD_VAR 0 2
103962: ARRAY
103963: PUSH
103964: LD_INT 1
103966: ARRAY
103967: PUSH
103968: LD_INT 4
103970: ARRAY
103971: PUSH
103972: EMPTY
103973: LIST
103974: LIST
103975: LIST
103976: LIST
103977: PPUSH
103978: CALL 30559 0 2
103982: AND
103983: IFFALSE 104121
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
103985: LD_VAR 0 3
103989: PPUSH
103990: LD_EXP 182
103994: PUSH
103995: LD_VAR 0 2
103999: ARRAY
104000: PUSH
104001: LD_INT 1
104003: ARRAY
104004: PUSH
104005: LD_INT 1
104007: ARRAY
104008: PPUSH
104009: LD_EXP 182
104013: PUSH
104014: LD_VAR 0 2
104018: ARRAY
104019: PUSH
104020: LD_INT 1
104022: ARRAY
104023: PUSH
104024: LD_INT 2
104026: ARRAY
104027: PPUSH
104028: LD_EXP 182
104032: PUSH
104033: LD_VAR 0 2
104037: ARRAY
104038: PUSH
104039: LD_INT 1
104041: ARRAY
104042: PUSH
104043: LD_INT 3
104045: ARRAY
104046: PPUSH
104047: LD_EXP 182
104051: PUSH
104052: LD_VAR 0 2
104056: ARRAY
104057: PUSH
104058: LD_INT 1
104060: ARRAY
104061: PUSH
104062: LD_INT 4
104064: ARRAY
104065: PPUSH
104066: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
104070: LD_ADDR_VAR 0 4
104074: PUSH
104075: LD_EXP 182
104079: PUSH
104080: LD_VAR 0 2
104084: ARRAY
104085: PPUSH
104086: LD_INT 1
104088: PPUSH
104089: CALL_OW 3
104093: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
104094: LD_ADDR_EXP 182
104098: PUSH
104099: LD_EXP 182
104103: PPUSH
104104: LD_VAR 0 2
104108: PPUSH
104109: LD_VAR 0 4
104113: PPUSH
104114: CALL_OW 1
104118: ST_TO_ADDR
// break ;
104119: GO 104123
// end ; end ;
104121: GO 103767
104123: POP
104124: POP
// end ;
104125: GO 103699
104127: POP
104128: POP
// end ;
104129: LD_VAR 0 1
104133: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
104134: LD_INT 0
104136: PPUSH
104137: PPUSH
104138: PPUSH
// if not mc_bases then
104139: LD_EXP 161
104143: NOT
104144: IFFALSE 104148
// exit ;
104146: GO 104237
// for i = 1 to mc_bases do
104148: LD_ADDR_VAR 0 2
104152: PUSH
104153: DOUBLE
104154: LD_INT 1
104156: DEC
104157: ST_TO_ADDR
104158: LD_EXP 161
104162: PUSH
104163: FOR_TO
104164: IFFALSE 104235
// begin if mc_attack [ i ] then
104166: LD_EXP 181
104170: PUSH
104171: LD_VAR 0 2
104175: ARRAY
104176: IFFALSE 104233
// begin tmp := mc_attack [ i ] [ 1 ] ;
104178: LD_ADDR_VAR 0 3
104182: PUSH
104183: LD_EXP 181
104187: PUSH
104188: LD_VAR 0 2
104192: ARRAY
104193: PUSH
104194: LD_INT 1
104196: ARRAY
104197: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
104198: LD_ADDR_EXP 181
104202: PUSH
104203: LD_EXP 181
104207: PPUSH
104208: LD_VAR 0 2
104212: PPUSH
104213: EMPTY
104214: PPUSH
104215: CALL_OW 1
104219: ST_TO_ADDR
// Attack ( tmp ) ;
104220: LD_VAR 0 3
104224: PPUSH
104225: CALL 81021 0 1
// exit ;
104229: POP
104230: POP
104231: GO 104237
// end ; end ;
104233: GO 104163
104235: POP
104236: POP
// end ;
104237: LD_VAR 0 1
104241: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
104242: LD_INT 0
104244: PPUSH
104245: PPUSH
104246: PPUSH
104247: PPUSH
104248: PPUSH
104249: PPUSH
104250: PPUSH
// if not mc_bases then
104251: LD_EXP 161
104255: NOT
104256: IFFALSE 104260
// exit ;
104258: GO 105117
// for i = 1 to mc_bases do
104260: LD_ADDR_VAR 0 2
104264: PUSH
104265: DOUBLE
104266: LD_INT 1
104268: DEC
104269: ST_TO_ADDR
104270: LD_EXP 161
104274: PUSH
104275: FOR_TO
104276: IFFALSE 105115
// begin if not mc_bases [ i ] then
104278: LD_EXP 161
104282: PUSH
104283: LD_VAR 0 2
104287: ARRAY
104288: NOT
104289: IFFALSE 104293
// continue ;
104291: GO 104275
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
104293: LD_ADDR_VAR 0 7
104297: PUSH
104298: LD_EXP 161
104302: PUSH
104303: LD_VAR 0 2
104307: ARRAY
104308: PUSH
104309: LD_INT 1
104311: ARRAY
104312: PPUSH
104313: CALL 21010 0 1
104317: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
104318: LD_ADDR_EXP 184
104322: PUSH
104323: LD_EXP 184
104327: PPUSH
104328: LD_VAR 0 2
104332: PPUSH
104333: LD_EXP 161
104337: PUSH
104338: LD_VAR 0 2
104342: ARRAY
104343: PUSH
104344: LD_INT 1
104346: ARRAY
104347: PPUSH
104348: CALL_OW 255
104352: PPUSH
104353: LD_EXP 186
104357: PUSH
104358: LD_VAR 0 2
104362: ARRAY
104363: PPUSH
104364: CALL 20975 0 2
104368: PPUSH
104369: CALL_OW 1
104373: ST_TO_ADDR
// if not mc_scan [ i ] then
104374: LD_EXP 184
104378: PUSH
104379: LD_VAR 0 2
104383: ARRAY
104384: NOT
104385: IFFALSE 104563
// begin mc_is_defending := Replace ( mc_is_defending , i , false ) ;
104387: LD_ADDR_EXP 204
104391: PUSH
104392: LD_EXP 204
104396: PPUSH
104397: LD_VAR 0 2
104401: PPUSH
104402: LD_INT 0
104404: PPUSH
104405: CALL_OW 1
104409: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
104410: LD_ADDR_VAR 0 4
104414: PUSH
104415: LD_EXP 161
104419: PUSH
104420: LD_VAR 0 2
104424: ARRAY
104425: PPUSH
104426: LD_INT 2
104428: PUSH
104429: LD_INT 25
104431: PUSH
104432: LD_INT 5
104434: PUSH
104435: EMPTY
104436: LIST
104437: LIST
104438: PUSH
104439: LD_INT 25
104441: PUSH
104442: LD_INT 8
104444: PUSH
104445: EMPTY
104446: LIST
104447: LIST
104448: PUSH
104449: LD_INT 25
104451: PUSH
104452: LD_INT 9
104454: PUSH
104455: EMPTY
104456: LIST
104457: LIST
104458: PUSH
104459: EMPTY
104460: LIST
104461: LIST
104462: LIST
104463: LIST
104464: PPUSH
104465: CALL_OW 72
104469: ST_TO_ADDR
// if not tmp then
104470: LD_VAR 0 4
104474: NOT
104475: IFFALSE 104479
// continue ;
104477: GO 104275
// for j in tmp do
104479: LD_ADDR_VAR 0 3
104483: PUSH
104484: LD_VAR 0 4
104488: PUSH
104489: FOR_IN
104490: IFFALSE 104561
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
104492: LD_VAR 0 3
104496: PPUSH
104497: CALL_OW 310
104501: PPUSH
104502: CALL_OW 266
104506: PUSH
104507: LD_INT 5
104509: EQUAL
104510: PUSH
104511: LD_VAR 0 3
104515: PPUSH
104516: CALL_OW 257
104520: PUSH
104521: LD_INT 1
104523: EQUAL
104524: AND
104525: PUSH
104526: LD_VAR 0 3
104530: PPUSH
104531: CALL_OW 459
104535: NOT
104536: AND
104537: PUSH
104538: LD_VAR 0 7
104542: AND
104543: IFFALSE 104559
// ComChangeProfession ( j , class ) ;
104545: LD_VAR 0 3
104549: PPUSH
104550: LD_VAR 0 7
104554: PPUSH
104555: CALL_OW 123
104559: GO 104489
104561: POP
104562: POP
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and not mc_defender [ i ] and ( UnitFilter ( mc_bases [ i ] , [ [ f_ok ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) < 4 or UnitFilter ( mc_bases [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ) then
104563: LD_EXP 184
104567: PUSH
104568: LD_VAR 0 2
104572: ARRAY
104573: PUSH
104574: LD_EXP 204
104578: PUSH
104579: LD_VAR 0 2
104583: ARRAY
104584: NOT
104585: AND
104586: PUSH
104587: LD_EXP 183
104591: PUSH
104592: LD_VAR 0 2
104596: ARRAY
104597: NOT
104598: AND
104599: PUSH
104600: LD_EXP 161
104604: PUSH
104605: LD_VAR 0 2
104609: ARRAY
104610: PPUSH
104611: LD_INT 50
104613: PUSH
104614: EMPTY
104615: LIST
104616: PUSH
104617: LD_INT 2
104619: PUSH
104620: LD_INT 30
104622: PUSH
104623: LD_INT 32
104625: PUSH
104626: EMPTY
104627: LIST
104628: LIST
104629: PUSH
104630: LD_INT 30
104632: PUSH
104633: LD_INT 33
104635: PUSH
104636: EMPTY
104637: LIST
104638: LIST
104639: PUSH
104640: LD_INT 30
104642: PUSH
104643: LD_INT 4
104645: PUSH
104646: EMPTY
104647: LIST
104648: LIST
104649: PUSH
104650: LD_INT 30
104652: PUSH
104653: LD_INT 5
104655: PUSH
104656: EMPTY
104657: LIST
104658: LIST
104659: PUSH
104660: EMPTY
104661: LIST
104662: LIST
104663: LIST
104664: LIST
104665: LIST
104666: PUSH
104667: EMPTY
104668: LIST
104669: LIST
104670: PPUSH
104671: CALL_OW 72
104675: PUSH
104676: LD_INT 4
104678: LESS
104679: PUSH
104680: LD_EXP 161
104684: PUSH
104685: LD_VAR 0 2
104689: ARRAY
104690: PPUSH
104691: LD_INT 3
104693: PUSH
104694: LD_INT 24
104696: PUSH
104697: LD_INT 1000
104699: PUSH
104700: EMPTY
104701: LIST
104702: LIST
104703: PUSH
104704: EMPTY
104705: LIST
104706: LIST
104707: PUSH
104708: LD_INT 2
104710: PUSH
104711: LD_INT 30
104713: PUSH
104714: LD_INT 0
104716: PUSH
104717: EMPTY
104718: LIST
104719: LIST
104720: PUSH
104721: LD_INT 30
104723: PUSH
104724: LD_INT 1
104726: PUSH
104727: EMPTY
104728: LIST
104729: LIST
104730: PUSH
104731: EMPTY
104732: LIST
104733: LIST
104734: LIST
104735: PUSH
104736: EMPTY
104737: LIST
104738: LIST
104739: PPUSH
104740: CALL_OW 72
104744: OR
104745: AND
104746: IFFALSE 104997
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
104748: LD_ADDR_EXP 204
104752: PUSH
104753: LD_EXP 204
104757: PPUSH
104758: LD_VAR 0 2
104762: PPUSH
104763: LD_INT 1
104765: PPUSH
104766: CALL_OW 1
104770: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
104771: LD_ADDR_VAR 0 4
104775: PUSH
104776: LD_EXP 161
104780: PUSH
104781: LD_VAR 0 2
104785: ARRAY
104786: PPUSH
104787: LD_INT 2
104789: PUSH
104790: LD_INT 25
104792: PUSH
104793: LD_INT 1
104795: PUSH
104796: EMPTY
104797: LIST
104798: LIST
104799: PUSH
104800: LD_INT 25
104802: PUSH
104803: LD_INT 5
104805: PUSH
104806: EMPTY
104807: LIST
104808: LIST
104809: PUSH
104810: LD_INT 25
104812: PUSH
104813: LD_INT 8
104815: PUSH
104816: EMPTY
104817: LIST
104818: LIST
104819: PUSH
104820: LD_INT 25
104822: PUSH
104823: LD_INT 9
104825: PUSH
104826: EMPTY
104827: LIST
104828: LIST
104829: PUSH
104830: EMPTY
104831: LIST
104832: LIST
104833: LIST
104834: LIST
104835: LIST
104836: PPUSH
104837: CALL_OW 72
104841: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
104842: LD_ADDR_VAR 0 4
104846: PUSH
104847: LD_VAR 0 4
104851: PUSH
104852: LD_VAR 0 4
104856: PPUSH
104857: LD_INT 18
104859: PPUSH
104860: CALL 54127 0 2
104864: DIFF
104865: ST_TO_ADDR
// if not tmp and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
104866: LD_VAR 0 4
104870: NOT
104871: PUSH
104872: LD_EXP 161
104876: PUSH
104877: LD_VAR 0 2
104881: ARRAY
104882: PPUSH
104883: LD_INT 2
104885: PUSH
104886: LD_INT 30
104888: PUSH
104889: LD_INT 4
104891: PUSH
104892: EMPTY
104893: LIST
104894: LIST
104895: PUSH
104896: LD_INT 30
104898: PUSH
104899: LD_INT 5
104901: PUSH
104902: EMPTY
104903: LIST
104904: LIST
104905: PUSH
104906: EMPTY
104907: LIST
104908: LIST
104909: LIST
104910: PPUSH
104911: CALL_OW 72
104915: NOT
104916: AND
104917: IFFALSE 104979
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ) ;
104919: LD_ADDR_VAR 0 4
104923: PUSH
104924: LD_EXP 161
104928: PUSH
104929: LD_VAR 0 2
104933: ARRAY
104934: PPUSH
104935: LD_INT 2
104937: PUSH
104938: LD_INT 25
104940: PUSH
104941: LD_INT 2
104943: PUSH
104944: EMPTY
104945: LIST
104946: LIST
104947: PUSH
104948: LD_INT 25
104950: PUSH
104951: LD_INT 3
104953: PUSH
104954: EMPTY
104955: LIST
104956: LIST
104957: PUSH
104958: LD_INT 25
104960: PUSH
104961: LD_INT 4
104963: PUSH
104964: EMPTY
104965: LIST
104966: LIST
104967: PUSH
104968: EMPTY
104969: LIST
104970: LIST
104971: LIST
104972: LIST
104973: PPUSH
104974: CALL_OW 72
104978: ST_TO_ADDR
// BasicDefend ( i , tmp ) ;
104979: LD_VAR 0 2
104983: PPUSH
104984: LD_VAR 0 4
104988: PPUSH
104989: CALL 85730 0 2
// exit ;
104993: POP
104994: POP
104995: GO 105117
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and mc_defender [ i ] then
104997: LD_EXP 184
105001: PUSH
105002: LD_VAR 0 2
105006: ARRAY
105007: PUSH
105008: LD_EXP 204
105012: PUSH
105013: LD_VAR 0 2
105017: ARRAY
105018: NOT
105019: AND
105020: PUSH
105021: LD_EXP 183
105025: PUSH
105026: LD_VAR 0 2
105030: ARRAY
105031: AND
105032: IFFALSE 105113
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
105034: LD_ADDR_EXP 204
105038: PUSH
105039: LD_EXP 204
105043: PPUSH
105044: LD_VAR 0 2
105048: PPUSH
105049: LD_INT 1
105051: PPUSH
105052: CALL_OW 1
105056: ST_TO_ADDR
// tmp := mc_defender [ i ] ;
105057: LD_ADDR_VAR 0 4
105061: PUSH
105062: LD_EXP 183
105066: PUSH
105067: LD_VAR 0 2
105071: ARRAY
105072: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
105073: LD_ADDR_EXP 183
105077: PUSH
105078: LD_EXP 183
105082: PPUSH
105083: LD_VAR 0 2
105087: PPUSH
105088: EMPTY
105089: PPUSH
105090: CALL_OW 1
105094: ST_TO_ADDR
// Defend ( i , tmp ) ;
105095: LD_VAR 0 2
105099: PPUSH
105100: LD_VAR 0 4
105104: PPUSH
105105: CALL 86326 0 2
// exit ;
105109: POP
105110: POP
105111: GO 105117
// end ; end ;
105113: GO 104275
105115: POP
105116: POP
// end ;
105117: LD_VAR 0 1
105121: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
105122: LD_INT 0
105124: PPUSH
105125: PPUSH
105126: PPUSH
105127: PPUSH
105128: PPUSH
105129: PPUSH
105130: PPUSH
105131: PPUSH
105132: PPUSH
105133: PPUSH
105134: PPUSH
// if not mc_bases then
105135: LD_EXP 161
105139: NOT
105140: IFFALSE 105144
// exit ;
105142: GO 106231
// for i = 1 to mc_bases do
105144: LD_ADDR_VAR 0 2
105148: PUSH
105149: DOUBLE
105150: LD_INT 1
105152: DEC
105153: ST_TO_ADDR
105154: LD_EXP 161
105158: PUSH
105159: FOR_TO
105160: IFFALSE 106229
// begin tmp := mc_lab [ i ] ;
105162: LD_ADDR_VAR 0 6
105166: PUSH
105167: LD_EXP 194
105171: PUSH
105172: LD_VAR 0 2
105176: ARRAY
105177: ST_TO_ADDR
// if not tmp then
105178: LD_VAR 0 6
105182: NOT
105183: IFFALSE 105187
// continue ;
105185: GO 105159
// idle_lab := 0 ;
105187: LD_ADDR_VAR 0 11
105191: PUSH
105192: LD_INT 0
105194: ST_TO_ADDR
// for j in tmp do
105195: LD_ADDR_VAR 0 3
105199: PUSH
105200: LD_VAR 0 6
105204: PUSH
105205: FOR_IN
105206: IFFALSE 106225
// begin researching := false ;
105208: LD_ADDR_VAR 0 10
105212: PUSH
105213: LD_INT 0
105215: ST_TO_ADDR
// side := GetSide ( j ) ;
105216: LD_ADDR_VAR 0 4
105220: PUSH
105221: LD_VAR 0 3
105225: PPUSH
105226: CALL_OW 255
105230: ST_TO_ADDR
// if not mc_tech [ side ] then
105231: LD_EXP 188
105235: PUSH
105236: LD_VAR 0 4
105240: ARRAY
105241: NOT
105242: IFFALSE 105246
// continue ;
105244: GO 105205
// if BuildingStatus ( j ) = bs_idle then
105246: LD_VAR 0 3
105250: PPUSH
105251: CALL_OW 461
105255: PUSH
105256: LD_INT 2
105258: EQUAL
105259: IFFALSE 105447
// begin if idle_lab and UnitsInside ( j ) < 6 then
105261: LD_VAR 0 11
105265: PUSH
105266: LD_VAR 0 3
105270: PPUSH
105271: CALL_OW 313
105275: PUSH
105276: LD_INT 6
105278: LESS
105279: AND
105280: IFFALSE 105351
// begin tmp2 := UnitsInside ( idle_lab ) ;
105282: LD_ADDR_VAR 0 9
105286: PUSH
105287: LD_VAR 0 11
105291: PPUSH
105292: CALL_OW 313
105296: ST_TO_ADDR
// if tmp2 then
105297: LD_VAR 0 9
105301: IFFALSE 105343
// for x in tmp2 do
105303: LD_ADDR_VAR 0 7
105307: PUSH
105308: LD_VAR 0 9
105312: PUSH
105313: FOR_IN
105314: IFFALSE 105341
// begin ComExitBuilding ( x ) ;
105316: LD_VAR 0 7
105320: PPUSH
105321: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
105325: LD_VAR 0 7
105329: PPUSH
105330: LD_VAR 0 3
105334: PPUSH
105335: CALL_OW 180
// end ;
105339: GO 105313
105341: POP
105342: POP
// idle_lab := 0 ;
105343: LD_ADDR_VAR 0 11
105347: PUSH
105348: LD_INT 0
105350: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
105351: LD_ADDR_VAR 0 5
105355: PUSH
105356: LD_EXP 188
105360: PUSH
105361: LD_VAR 0 4
105365: ARRAY
105366: PUSH
105367: FOR_IN
105368: IFFALSE 105428
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
105370: LD_VAR 0 3
105374: PPUSH
105375: LD_VAR 0 5
105379: PPUSH
105380: CALL_OW 430
105384: PUSH
105385: LD_VAR 0 4
105389: PPUSH
105390: LD_VAR 0 5
105394: PPUSH
105395: CALL 20080 0 2
105399: AND
105400: IFFALSE 105426
// begin researching := true ;
105402: LD_ADDR_VAR 0 10
105406: PUSH
105407: LD_INT 1
105409: ST_TO_ADDR
// ComResearch ( j , t ) ;
105410: LD_VAR 0 3
105414: PPUSH
105415: LD_VAR 0 5
105419: PPUSH
105420: CALL_OW 124
// break ;
105424: GO 105428
// end ;
105426: GO 105367
105428: POP
105429: POP
// if not researching then
105430: LD_VAR 0 10
105434: NOT
105435: IFFALSE 105447
// idle_lab := j ;
105437: LD_ADDR_VAR 0 11
105441: PUSH
105442: LD_VAR 0 3
105446: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
105447: LD_VAR 0 3
105451: PPUSH
105452: CALL_OW 461
105456: PUSH
105457: LD_INT 10
105459: EQUAL
105460: IFFALSE 106048
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
105462: LD_EXP 190
105466: PUSH
105467: LD_VAR 0 2
105471: ARRAY
105472: NOT
105473: PUSH
105474: LD_EXP 191
105478: PUSH
105479: LD_VAR 0 2
105483: ARRAY
105484: NOT
105485: AND
105486: PUSH
105487: LD_EXP 188
105491: PUSH
105492: LD_VAR 0 4
105496: ARRAY
105497: PUSH
105498: LD_INT 1
105500: GREATER
105501: AND
105502: IFFALSE 105633
// begin ComCancel ( j ) ;
105504: LD_VAR 0 3
105508: PPUSH
105509: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
105513: LD_ADDR_EXP 188
105517: PUSH
105518: LD_EXP 188
105522: PPUSH
105523: LD_VAR 0 4
105527: PPUSH
105528: LD_EXP 188
105532: PUSH
105533: LD_VAR 0 4
105537: ARRAY
105538: PPUSH
105539: LD_EXP 188
105543: PUSH
105544: LD_VAR 0 4
105548: ARRAY
105549: PUSH
105550: LD_INT 1
105552: MINUS
105553: PPUSH
105554: LD_EXP 188
105558: PUSH
105559: LD_VAR 0 4
105563: ARRAY
105564: PPUSH
105565: LD_INT 0
105567: PPUSH
105568: CALL 23604 0 4
105572: PPUSH
105573: CALL_OW 1
105577: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
105578: LD_ADDR_EXP 188
105582: PUSH
105583: LD_EXP 188
105587: PPUSH
105588: LD_VAR 0 4
105592: PPUSH
105593: LD_EXP 188
105597: PUSH
105598: LD_VAR 0 4
105602: ARRAY
105603: PPUSH
105604: LD_EXP 188
105608: PUSH
105609: LD_VAR 0 4
105613: ARRAY
105614: PPUSH
105615: LD_INT 1
105617: PPUSH
105618: LD_INT 0
105620: PPUSH
105621: CALL 23604 0 4
105625: PPUSH
105626: CALL_OW 1
105630: ST_TO_ADDR
// continue ;
105631: GO 105205
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
105633: LD_EXP 190
105637: PUSH
105638: LD_VAR 0 2
105642: ARRAY
105643: PUSH
105644: LD_EXP 191
105648: PUSH
105649: LD_VAR 0 2
105653: ARRAY
105654: NOT
105655: AND
105656: IFFALSE 105783
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
105658: LD_ADDR_EXP 191
105662: PUSH
105663: LD_EXP 191
105667: PPUSH
105668: LD_VAR 0 2
105672: PUSH
105673: LD_EXP 191
105677: PUSH
105678: LD_VAR 0 2
105682: ARRAY
105683: PUSH
105684: LD_INT 1
105686: PLUS
105687: PUSH
105688: EMPTY
105689: LIST
105690: LIST
105691: PPUSH
105692: LD_EXP 190
105696: PUSH
105697: LD_VAR 0 2
105701: ARRAY
105702: PUSH
105703: LD_INT 1
105705: ARRAY
105706: PPUSH
105707: CALL 24186 0 3
105711: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
105712: LD_EXP 190
105716: PUSH
105717: LD_VAR 0 2
105721: ARRAY
105722: PUSH
105723: LD_INT 1
105725: ARRAY
105726: PPUSH
105727: LD_INT 112
105729: PPUSH
105730: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
105734: LD_ADDR_VAR 0 9
105738: PUSH
105739: LD_EXP 190
105743: PUSH
105744: LD_VAR 0 2
105748: ARRAY
105749: PPUSH
105750: LD_INT 1
105752: PPUSH
105753: CALL_OW 3
105757: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
105758: LD_ADDR_EXP 190
105762: PUSH
105763: LD_EXP 190
105767: PPUSH
105768: LD_VAR 0 2
105772: PPUSH
105773: LD_VAR 0 9
105777: PPUSH
105778: CALL_OW 1
105782: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
105783: LD_EXP 190
105787: PUSH
105788: LD_VAR 0 2
105792: ARRAY
105793: PUSH
105794: LD_EXP 191
105798: PUSH
105799: LD_VAR 0 2
105803: ARRAY
105804: AND
105805: PUSH
105806: LD_EXP 191
105810: PUSH
105811: LD_VAR 0 2
105815: ARRAY
105816: PUSH
105817: LD_INT 1
105819: ARRAY
105820: PPUSH
105821: CALL_OW 310
105825: NOT
105826: AND
105827: PUSH
105828: LD_VAR 0 3
105832: PPUSH
105833: CALL_OW 313
105837: PUSH
105838: LD_INT 6
105840: EQUAL
105841: AND
105842: IFFALSE 105898
// begin tmp2 := UnitsInside ( j ) ;
105844: LD_ADDR_VAR 0 9
105848: PUSH
105849: LD_VAR 0 3
105853: PPUSH
105854: CALL_OW 313
105858: ST_TO_ADDR
// if tmp2 = 6 then
105859: LD_VAR 0 9
105863: PUSH
105864: LD_INT 6
105866: EQUAL
105867: IFFALSE 105898
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
105869: LD_VAR 0 9
105873: PUSH
105874: LD_INT 1
105876: ARRAY
105877: PPUSH
105878: LD_INT 112
105880: PPUSH
105881: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
105885: LD_VAR 0 9
105889: PUSH
105890: LD_INT 1
105892: ARRAY
105893: PPUSH
105894: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
105898: LD_EXP 191
105902: PUSH
105903: LD_VAR 0 2
105907: ARRAY
105908: PUSH
105909: LD_EXP 191
105913: PUSH
105914: LD_VAR 0 2
105918: ARRAY
105919: PUSH
105920: LD_INT 1
105922: ARRAY
105923: PPUSH
105924: CALL_OW 314
105928: NOT
105929: AND
105930: PUSH
105931: LD_EXP 191
105935: PUSH
105936: LD_VAR 0 2
105940: ARRAY
105941: PUSH
105942: LD_INT 1
105944: ARRAY
105945: PPUSH
105946: CALL_OW 310
105950: NOT
105951: AND
105952: IFFALSE 105978
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
105954: LD_EXP 191
105958: PUSH
105959: LD_VAR 0 2
105963: ARRAY
105964: PUSH
105965: LD_INT 1
105967: ARRAY
105968: PPUSH
105969: LD_VAR 0 3
105973: PPUSH
105974: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
105978: LD_EXP 191
105982: PUSH
105983: LD_VAR 0 2
105987: ARRAY
105988: PUSH
105989: LD_INT 1
105991: ARRAY
105992: PPUSH
105993: CALL_OW 310
105997: PUSH
105998: LD_EXP 191
106002: PUSH
106003: LD_VAR 0 2
106007: ARRAY
106008: PUSH
106009: LD_INT 1
106011: ARRAY
106012: PPUSH
106013: CALL_OW 310
106017: PPUSH
106018: CALL_OW 461
106022: PUSH
106023: LD_INT 3
106025: NONEQUAL
106026: AND
106027: IFFALSE 106048
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
106029: LD_EXP 191
106033: PUSH
106034: LD_VAR 0 2
106038: ARRAY
106039: PUSH
106040: LD_INT 1
106042: ARRAY
106043: PPUSH
106044: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
106048: LD_VAR 0 3
106052: PPUSH
106053: CALL_OW 461
106057: PUSH
106058: LD_INT 6
106060: EQUAL
106061: PUSH
106062: LD_VAR 0 6
106066: PUSH
106067: LD_INT 1
106069: GREATER
106070: AND
106071: IFFALSE 106223
// begin sci := [ ] ;
106073: LD_ADDR_VAR 0 8
106077: PUSH
106078: EMPTY
106079: ST_TO_ADDR
// for x in ( tmp diff j ) do
106080: LD_ADDR_VAR 0 7
106084: PUSH
106085: LD_VAR 0 6
106089: PUSH
106090: LD_VAR 0 3
106094: DIFF
106095: PUSH
106096: FOR_IN
106097: IFFALSE 106149
// begin if sci = 6 then
106099: LD_VAR 0 8
106103: PUSH
106104: LD_INT 6
106106: EQUAL
106107: IFFALSE 106111
// break ;
106109: GO 106149
// if BuildingStatus ( x ) = bs_idle then
106111: LD_VAR 0 7
106115: PPUSH
106116: CALL_OW 461
106120: PUSH
106121: LD_INT 2
106123: EQUAL
106124: IFFALSE 106147
// sci := sci ^ UnitsInside ( x ) ;
106126: LD_ADDR_VAR 0 8
106130: PUSH
106131: LD_VAR 0 8
106135: PUSH
106136: LD_VAR 0 7
106140: PPUSH
106141: CALL_OW 313
106145: ADD
106146: ST_TO_ADDR
// end ;
106147: GO 106096
106149: POP
106150: POP
// if not sci then
106151: LD_VAR 0 8
106155: NOT
106156: IFFALSE 106160
// continue ;
106158: GO 105205
// for x in sci do
106160: LD_ADDR_VAR 0 7
106164: PUSH
106165: LD_VAR 0 8
106169: PUSH
106170: FOR_IN
106171: IFFALSE 106221
// if IsInUnit ( x ) and not HasTask ( x ) then
106173: LD_VAR 0 7
106177: PPUSH
106178: CALL_OW 310
106182: PUSH
106183: LD_VAR 0 7
106187: PPUSH
106188: CALL_OW 314
106192: NOT
106193: AND
106194: IFFALSE 106219
// begin ComExitBuilding ( x ) ;
106196: LD_VAR 0 7
106200: PPUSH
106201: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
106205: LD_VAR 0 7
106209: PPUSH
106210: LD_VAR 0 3
106214: PPUSH
106215: CALL_OW 180
// end ;
106219: GO 106170
106221: POP
106222: POP
// end ; end ;
106223: GO 105205
106225: POP
106226: POP
// end ;
106227: GO 105159
106229: POP
106230: POP
// end ;
106231: LD_VAR 0 1
106235: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
106236: LD_INT 0
106238: PPUSH
106239: PPUSH
// if not mc_bases then
106240: LD_EXP 161
106244: NOT
106245: IFFALSE 106249
// exit ;
106247: GO 106330
// for i = 1 to mc_bases do
106249: LD_ADDR_VAR 0 2
106253: PUSH
106254: DOUBLE
106255: LD_INT 1
106257: DEC
106258: ST_TO_ADDR
106259: LD_EXP 161
106263: PUSH
106264: FOR_TO
106265: IFFALSE 106328
// if mc_mines [ i ] and mc_miners [ i ] then
106267: LD_EXP 174
106271: PUSH
106272: LD_VAR 0 2
106276: ARRAY
106277: PUSH
106278: LD_EXP 175
106282: PUSH
106283: LD_VAR 0 2
106287: ARRAY
106288: AND
106289: IFFALSE 106326
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
106291: LD_EXP 175
106295: PUSH
106296: LD_VAR 0 2
106300: ARRAY
106301: PUSH
106302: LD_INT 1
106304: ARRAY
106305: PPUSH
106306: CALL_OW 255
106310: PPUSH
106311: LD_EXP 174
106315: PUSH
106316: LD_VAR 0 2
106320: ARRAY
106321: PPUSH
106322: CALL 21163 0 2
106326: GO 106264
106328: POP
106329: POP
// end ;
106330: LD_VAR 0 1
106334: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
106335: LD_INT 0
106337: PPUSH
106338: PPUSH
106339: PPUSH
106340: PPUSH
106341: PPUSH
106342: PPUSH
106343: PPUSH
106344: PPUSH
// if not mc_bases or not mc_parking then
106345: LD_EXP 161
106349: NOT
106350: PUSH
106351: LD_EXP 185
106355: NOT
106356: OR
106357: IFFALSE 106361
// exit ;
106359: GO 107099
// for i = 1 to mc_bases do
106361: LD_ADDR_VAR 0 2
106365: PUSH
106366: DOUBLE
106367: LD_INT 1
106369: DEC
106370: ST_TO_ADDR
106371: LD_EXP 161
106375: PUSH
106376: FOR_TO
106377: IFFALSE 107097
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
106379: LD_EXP 161
106383: PUSH
106384: LD_VAR 0 2
106388: ARRAY
106389: NOT
106390: PUSH
106391: LD_EXP 185
106395: PUSH
106396: LD_VAR 0 2
106400: ARRAY
106401: NOT
106402: OR
106403: IFFALSE 106407
// continue ;
106405: GO 106376
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
106407: LD_ADDR_VAR 0 5
106411: PUSH
106412: LD_EXP 161
106416: PUSH
106417: LD_VAR 0 2
106421: ARRAY
106422: PUSH
106423: LD_INT 1
106425: ARRAY
106426: PPUSH
106427: CALL_OW 255
106431: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
106432: LD_ADDR_VAR 0 6
106436: PUSH
106437: LD_EXP 161
106441: PUSH
106442: LD_VAR 0 2
106446: ARRAY
106447: PPUSH
106448: LD_INT 30
106450: PUSH
106451: LD_INT 3
106453: PUSH
106454: EMPTY
106455: LIST
106456: LIST
106457: PPUSH
106458: CALL_OW 72
106462: ST_TO_ADDR
// if not fac then
106463: LD_VAR 0 6
106467: NOT
106468: IFFALSE 106519
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
106470: LD_ADDR_VAR 0 6
106474: PUSH
106475: LD_EXP 161
106479: PUSH
106480: LD_VAR 0 2
106484: ARRAY
106485: PPUSH
106486: LD_INT 2
106488: PUSH
106489: LD_INT 30
106491: PUSH
106492: LD_INT 0
106494: PUSH
106495: EMPTY
106496: LIST
106497: LIST
106498: PUSH
106499: LD_INT 30
106501: PUSH
106502: LD_INT 1
106504: PUSH
106505: EMPTY
106506: LIST
106507: LIST
106508: PUSH
106509: EMPTY
106510: LIST
106511: LIST
106512: LIST
106513: PPUSH
106514: CALL_OW 72
106518: ST_TO_ADDR
// if not fac then
106519: LD_VAR 0 6
106523: NOT
106524: IFFALSE 106528
// continue ;
106526: GO 106376
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_hastask ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
106528: LD_ADDR_VAR 0 7
106532: PUSH
106533: LD_EXP 185
106537: PUSH
106538: LD_VAR 0 2
106542: ARRAY
106543: PPUSH
106544: LD_INT 22
106546: PUSH
106547: LD_VAR 0 5
106551: PUSH
106552: EMPTY
106553: LIST
106554: LIST
106555: PUSH
106556: LD_INT 21
106558: PUSH
106559: LD_INT 2
106561: PUSH
106562: EMPTY
106563: LIST
106564: LIST
106565: PUSH
106566: LD_INT 3
106568: PUSH
106569: LD_INT 60
106571: PUSH
106572: EMPTY
106573: LIST
106574: PUSH
106575: EMPTY
106576: LIST
106577: LIST
106578: PUSH
106579: LD_INT 3
106581: PUSH
106582: LD_INT 24
106584: PUSH
106585: LD_INT 1000
106587: PUSH
106588: EMPTY
106589: LIST
106590: LIST
106591: PUSH
106592: EMPTY
106593: LIST
106594: LIST
106595: PUSH
106596: EMPTY
106597: LIST
106598: LIST
106599: LIST
106600: LIST
106601: PPUSH
106602: CALL_OW 70
106606: ST_TO_ADDR
// for j in fac do
106607: LD_ADDR_VAR 0 3
106611: PUSH
106612: LD_VAR 0 6
106616: PUSH
106617: FOR_IN
106618: IFFALSE 106713
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_hastask ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
106620: LD_ADDR_VAR 0 7
106624: PUSH
106625: LD_VAR 0 7
106629: PUSH
106630: LD_INT 22
106632: PUSH
106633: LD_VAR 0 5
106637: PUSH
106638: EMPTY
106639: LIST
106640: LIST
106641: PUSH
106642: LD_INT 91
106644: PUSH
106645: LD_VAR 0 3
106649: PUSH
106650: LD_INT 15
106652: PUSH
106653: EMPTY
106654: LIST
106655: LIST
106656: LIST
106657: PUSH
106658: LD_INT 21
106660: PUSH
106661: LD_INT 2
106663: PUSH
106664: EMPTY
106665: LIST
106666: LIST
106667: PUSH
106668: LD_INT 3
106670: PUSH
106671: LD_INT 60
106673: PUSH
106674: EMPTY
106675: LIST
106676: PUSH
106677: EMPTY
106678: LIST
106679: LIST
106680: PUSH
106681: LD_INT 3
106683: PUSH
106684: LD_INT 24
106686: PUSH
106687: LD_INT 1000
106689: PUSH
106690: EMPTY
106691: LIST
106692: LIST
106693: PUSH
106694: EMPTY
106695: LIST
106696: LIST
106697: PUSH
106698: EMPTY
106699: LIST
106700: LIST
106701: LIST
106702: LIST
106703: LIST
106704: PPUSH
106705: CALL_OW 69
106709: UNION
106710: ST_TO_ADDR
106711: GO 106617
106713: POP
106714: POP
// if not vehs then
106715: LD_VAR 0 7
106719: NOT
106720: IFFALSE 106746
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
106722: LD_ADDR_EXP 173
106726: PUSH
106727: LD_EXP 173
106731: PPUSH
106732: LD_VAR 0 2
106736: PPUSH
106737: EMPTY
106738: PPUSH
106739: CALL_OW 1
106743: ST_TO_ADDR
// continue ;
106744: GO 106376
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
106746: LD_ADDR_VAR 0 8
106750: PUSH
106751: LD_EXP 161
106755: PUSH
106756: LD_VAR 0 2
106760: ARRAY
106761: PPUSH
106762: LD_INT 30
106764: PUSH
106765: LD_INT 3
106767: PUSH
106768: EMPTY
106769: LIST
106770: LIST
106771: PPUSH
106772: CALL_OW 72
106776: ST_TO_ADDR
// if tmp then
106777: LD_VAR 0 8
106781: IFFALSE 106884
// begin for j in tmp do
106783: LD_ADDR_VAR 0 3
106787: PUSH
106788: LD_VAR 0 8
106792: PUSH
106793: FOR_IN
106794: IFFALSE 106882
// for k in UnitsInside ( j ) do
106796: LD_ADDR_VAR 0 4
106800: PUSH
106801: LD_VAR 0 3
106805: PPUSH
106806: CALL_OW 313
106810: PUSH
106811: FOR_IN
106812: IFFALSE 106878
// if k then
106814: LD_VAR 0 4
106818: IFFALSE 106876
// if not k in mc_repair_vehicle [ i ] then
106820: LD_VAR 0 4
106824: PUSH
106825: LD_EXP 173
106829: PUSH
106830: LD_VAR 0 2
106834: ARRAY
106835: IN
106836: NOT
106837: IFFALSE 106876
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
106839: LD_ADDR_EXP 173
106843: PUSH
106844: LD_EXP 173
106848: PPUSH
106849: LD_VAR 0 2
106853: PPUSH
106854: LD_EXP 173
106858: PUSH
106859: LD_VAR 0 2
106863: ARRAY
106864: PUSH
106865: LD_VAR 0 4
106869: UNION
106870: PPUSH
106871: CALL_OW 1
106875: ST_TO_ADDR
106876: GO 106811
106878: POP
106879: POP
106880: GO 106793
106882: POP
106883: POP
// end ; if not mc_repair_vehicle [ i ] then
106884: LD_EXP 173
106888: PUSH
106889: LD_VAR 0 2
106893: ARRAY
106894: NOT
106895: IFFALSE 106899
// continue ;
106897: GO 106376
// for j in mc_repair_vehicle [ i ] do
106899: LD_ADDR_VAR 0 3
106903: PUSH
106904: LD_EXP 173
106908: PUSH
106909: LD_VAR 0 2
106913: ARRAY
106914: PUSH
106915: FOR_IN
106916: IFFALSE 107093
// begin if GetClass ( j ) <> 3 then
106918: LD_VAR 0 3
106922: PPUSH
106923: CALL_OW 257
106927: PUSH
106928: LD_INT 3
106930: NONEQUAL
106931: IFFALSE 106972
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
106933: LD_ADDR_EXP 173
106937: PUSH
106938: LD_EXP 173
106942: PPUSH
106943: LD_VAR 0 2
106947: PPUSH
106948: LD_EXP 173
106952: PUSH
106953: LD_VAR 0 2
106957: ARRAY
106958: PUSH
106959: LD_VAR 0 3
106963: DIFF
106964: PPUSH
106965: CALL_OW 1
106969: ST_TO_ADDR
// continue ;
106970: GO 106915
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
106972: LD_VAR 0 3
106976: PPUSH
106977: CALL_OW 311
106981: NOT
106982: PUSH
106983: LD_VAR 0 3
106987: PUSH
106988: LD_EXP 164
106992: PUSH
106993: LD_VAR 0 2
106997: ARRAY
106998: PUSH
106999: LD_INT 1
107001: ARRAY
107002: IN
107003: NOT
107004: AND
107005: PUSH
107006: LD_VAR 0 3
107010: PUSH
107011: LD_EXP 164
107015: PUSH
107016: LD_VAR 0 2
107020: ARRAY
107021: PUSH
107022: LD_INT 2
107024: ARRAY
107025: IN
107026: NOT
107027: AND
107028: IFFALSE 107091
// begin if IsInUnit ( j ) then
107030: LD_VAR 0 3
107034: PPUSH
107035: CALL_OW 310
107039: IFFALSE 107052
// ComExitBuilding ( j ) else
107041: LD_VAR 0 3
107045: PPUSH
107046: CALL_OW 122
107050: GO 107091
// if not WantToRepairVehicle ( j , vehs [ 1 ] ) then
107052: LD_VAR 0 3
107056: PPUSH
107057: LD_VAR 0 7
107061: PUSH
107062: LD_INT 1
107064: ARRAY
107065: PPUSH
107066: CALL 58610 0 2
107070: NOT
107071: IFFALSE 107091
// ComRepairVehicle ( j , vehs [ 1 ] ) ;
107073: LD_VAR 0 3
107077: PPUSH
107078: LD_VAR 0 7
107082: PUSH
107083: LD_INT 1
107085: ARRAY
107086: PPUSH
107087: CALL_OW 129
// end ; end ;
107091: GO 106915
107093: POP
107094: POP
// end ;
107095: GO 106376
107097: POP
107098: POP
// end ;
107099: LD_VAR 0 1
107103: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
107104: LD_INT 0
107106: PPUSH
107107: PPUSH
107108: PPUSH
107109: PPUSH
107110: PPUSH
107111: PPUSH
107112: PPUSH
107113: PPUSH
107114: PPUSH
107115: PPUSH
107116: PPUSH
// if not mc_bases then
107117: LD_EXP 161
107121: NOT
107122: IFFALSE 107126
// exit ;
107124: GO 107928
// for i = 1 to mc_bases do
107126: LD_ADDR_VAR 0 2
107130: PUSH
107131: DOUBLE
107132: LD_INT 1
107134: DEC
107135: ST_TO_ADDR
107136: LD_EXP 161
107140: PUSH
107141: FOR_TO
107142: IFFALSE 107926
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
107144: LD_EXP 189
107148: PUSH
107149: LD_VAR 0 2
107153: ARRAY
107154: NOT
107155: PUSH
107156: LD_EXP 164
107160: PUSH
107161: LD_VAR 0 2
107165: ARRAY
107166: PUSH
107167: LD_INT 1
107169: ARRAY
107170: OR
107171: PUSH
107172: LD_EXP 164
107176: PUSH
107177: LD_VAR 0 2
107181: ARRAY
107182: PUSH
107183: LD_INT 2
107185: ARRAY
107186: OR
107187: PUSH
107188: LD_EXP 187
107192: PUSH
107193: LD_VAR 0 2
107197: ARRAY
107198: PPUSH
107199: LD_INT 1
107201: PPUSH
107202: CALL_OW 325
107206: NOT
107207: OR
107208: PUSH
107209: LD_EXP 184
107213: PUSH
107214: LD_VAR 0 2
107218: ARRAY
107219: OR
107220: IFFALSE 107224
// continue ;
107222: GO 107141
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
107224: LD_ADDR_VAR 0 8
107228: PUSH
107229: LD_EXP 161
107233: PUSH
107234: LD_VAR 0 2
107238: ARRAY
107239: PPUSH
107240: LD_INT 25
107242: PUSH
107243: LD_INT 4
107245: PUSH
107246: EMPTY
107247: LIST
107248: LIST
107249: PUSH
107250: LD_INT 50
107252: PUSH
107253: EMPTY
107254: LIST
107255: PUSH
107256: LD_INT 3
107258: PUSH
107259: LD_INT 60
107261: PUSH
107262: EMPTY
107263: LIST
107264: PUSH
107265: EMPTY
107266: LIST
107267: LIST
107268: PUSH
107269: EMPTY
107270: LIST
107271: LIST
107272: LIST
107273: PPUSH
107274: CALL_OW 72
107278: PUSH
107279: LD_EXP 165
107283: PUSH
107284: LD_VAR 0 2
107288: ARRAY
107289: DIFF
107290: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
107291: LD_ADDR_VAR 0 9
107295: PUSH
107296: LD_EXP 161
107300: PUSH
107301: LD_VAR 0 2
107305: ARRAY
107306: PPUSH
107307: LD_INT 2
107309: PUSH
107310: LD_INT 30
107312: PUSH
107313: LD_INT 0
107315: PUSH
107316: EMPTY
107317: LIST
107318: LIST
107319: PUSH
107320: LD_INT 30
107322: PUSH
107323: LD_INT 1
107325: PUSH
107326: EMPTY
107327: LIST
107328: LIST
107329: PUSH
107330: EMPTY
107331: LIST
107332: LIST
107333: LIST
107334: PPUSH
107335: CALL_OW 72
107339: ST_TO_ADDR
// if not tmp or not dep then
107340: LD_VAR 0 8
107344: NOT
107345: PUSH
107346: LD_VAR 0 9
107350: NOT
107351: OR
107352: IFFALSE 107356
// continue ;
107354: GO 107141
// side := GetSide ( tmp [ 1 ] ) ;
107356: LD_ADDR_VAR 0 11
107360: PUSH
107361: LD_VAR 0 8
107365: PUSH
107366: LD_INT 1
107368: ARRAY
107369: PPUSH
107370: CALL_OW 255
107374: ST_TO_ADDR
// dep := dep [ 1 ] ;
107375: LD_ADDR_VAR 0 9
107379: PUSH
107380: LD_VAR 0 9
107384: PUSH
107385: LD_INT 1
107387: ARRAY
107388: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
107389: LD_ADDR_VAR 0 7
107393: PUSH
107394: LD_EXP 189
107398: PUSH
107399: LD_VAR 0 2
107403: ARRAY
107404: PPUSH
107405: LD_INT 22
107407: PUSH
107408: LD_INT 0
107410: PUSH
107411: EMPTY
107412: LIST
107413: LIST
107414: PUSH
107415: LD_INT 25
107417: PUSH
107418: LD_INT 12
107420: PUSH
107421: EMPTY
107422: LIST
107423: LIST
107424: PUSH
107425: EMPTY
107426: LIST
107427: LIST
107428: PPUSH
107429: CALL_OW 70
107433: PUSH
107434: LD_INT 22
107436: PUSH
107437: LD_INT 0
107439: PUSH
107440: EMPTY
107441: LIST
107442: LIST
107443: PUSH
107444: LD_INT 25
107446: PUSH
107447: LD_INT 12
107449: PUSH
107450: EMPTY
107451: LIST
107452: LIST
107453: PUSH
107454: LD_INT 91
107456: PUSH
107457: LD_VAR 0 9
107461: PUSH
107462: LD_INT 20
107464: PUSH
107465: EMPTY
107466: LIST
107467: LIST
107468: LIST
107469: PUSH
107470: EMPTY
107471: LIST
107472: LIST
107473: LIST
107474: PPUSH
107475: CALL_OW 69
107479: UNION
107480: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
107481: LD_ADDR_VAR 0 10
107485: PUSH
107486: LD_EXP 189
107490: PUSH
107491: LD_VAR 0 2
107495: ARRAY
107496: PPUSH
107497: LD_INT 81
107499: PUSH
107500: LD_VAR 0 11
107504: PUSH
107505: EMPTY
107506: LIST
107507: LIST
107508: PPUSH
107509: CALL_OW 70
107513: ST_TO_ADDR
// if not apes or danger_at_area then
107514: LD_VAR 0 7
107518: NOT
107519: PUSH
107520: LD_VAR 0 10
107524: OR
107525: IFFALSE 107575
// begin if mc_taming [ i ] then
107527: LD_EXP 192
107531: PUSH
107532: LD_VAR 0 2
107536: ARRAY
107537: IFFALSE 107573
// begin MC_Reset ( i , 121 ) ;
107539: LD_VAR 0 2
107543: PPUSH
107544: LD_INT 121
107546: PPUSH
107547: CALL 92491 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
107551: LD_ADDR_EXP 192
107555: PUSH
107556: LD_EXP 192
107560: PPUSH
107561: LD_VAR 0 2
107565: PPUSH
107566: EMPTY
107567: PPUSH
107568: CALL_OW 1
107572: ST_TO_ADDR
// end ; continue ;
107573: GO 107141
// end ; for j in tmp do
107575: LD_ADDR_VAR 0 3
107579: PUSH
107580: LD_VAR 0 8
107584: PUSH
107585: FOR_IN
107586: IFFALSE 107922
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
107588: LD_VAR 0 3
107592: PUSH
107593: LD_EXP 192
107597: PUSH
107598: LD_VAR 0 2
107602: ARRAY
107603: IN
107604: NOT
107605: PUSH
107606: LD_EXP 192
107610: PUSH
107611: LD_VAR 0 2
107615: ARRAY
107616: PUSH
107617: LD_INT 3
107619: LESS
107620: AND
107621: IFFALSE 107679
// begin SetTag ( j , 121 ) ;
107623: LD_VAR 0 3
107627: PPUSH
107628: LD_INT 121
107630: PPUSH
107631: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
107635: LD_ADDR_EXP 192
107639: PUSH
107640: LD_EXP 192
107644: PPUSH
107645: LD_VAR 0 2
107649: PUSH
107650: LD_EXP 192
107654: PUSH
107655: LD_VAR 0 2
107659: ARRAY
107660: PUSH
107661: LD_INT 1
107663: PLUS
107664: PUSH
107665: EMPTY
107666: LIST
107667: LIST
107668: PPUSH
107669: LD_VAR 0 3
107673: PPUSH
107674: CALL 24186 0 3
107678: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
107679: LD_VAR 0 3
107683: PUSH
107684: LD_EXP 192
107688: PUSH
107689: LD_VAR 0 2
107693: ARRAY
107694: IN
107695: IFFALSE 107920
// begin if GetClass ( j ) <> 4 then
107697: LD_VAR 0 3
107701: PPUSH
107702: CALL_OW 257
107706: PUSH
107707: LD_INT 4
107709: NONEQUAL
107710: IFFALSE 107763
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
107712: LD_ADDR_EXP 192
107716: PUSH
107717: LD_EXP 192
107721: PPUSH
107722: LD_VAR 0 2
107726: PPUSH
107727: LD_EXP 192
107731: PUSH
107732: LD_VAR 0 2
107736: ARRAY
107737: PUSH
107738: LD_VAR 0 3
107742: DIFF
107743: PPUSH
107744: CALL_OW 1
107748: ST_TO_ADDR
// SetTag ( j , 0 ) ;
107749: LD_VAR 0 3
107753: PPUSH
107754: LD_INT 0
107756: PPUSH
107757: CALL_OW 109
// continue ;
107761: GO 107585
// end ; if IsInUnit ( j ) then
107763: LD_VAR 0 3
107767: PPUSH
107768: CALL_OW 310
107772: IFFALSE 107783
// ComExitBuilding ( j ) ;
107774: LD_VAR 0 3
107778: PPUSH
107779: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
107783: LD_ADDR_VAR 0 6
107787: PUSH
107788: LD_VAR 0 7
107792: PPUSH
107793: LD_VAR 0 3
107797: PPUSH
107798: CALL_OW 74
107802: ST_TO_ADDR
// if not ape then
107803: LD_VAR 0 6
107807: NOT
107808: IFFALSE 107812
// break ;
107810: GO 107922
// x := GetX ( ape ) ;
107812: LD_ADDR_VAR 0 4
107816: PUSH
107817: LD_VAR 0 6
107821: PPUSH
107822: CALL_OW 250
107826: ST_TO_ADDR
// y := GetY ( ape ) ;
107827: LD_ADDR_VAR 0 5
107831: PUSH
107832: LD_VAR 0 6
107836: PPUSH
107837: CALL_OW 251
107841: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
107842: LD_VAR 0 4
107846: PPUSH
107847: LD_VAR 0 5
107851: PPUSH
107852: CALL_OW 488
107856: NOT
107857: PUSH
107858: LD_VAR 0 11
107862: PPUSH
107863: LD_VAR 0 4
107867: PPUSH
107868: LD_VAR 0 5
107872: PPUSH
107873: LD_INT 20
107875: PPUSH
107876: CALL 25082 0 4
107880: PUSH
107881: LD_INT 4
107883: ARRAY
107884: OR
107885: IFFALSE 107889
// break ;
107887: GO 107922
// if not HasTask ( j ) then
107889: LD_VAR 0 3
107893: PPUSH
107894: CALL_OW 314
107898: NOT
107899: IFFALSE 107920
// ComTameXY ( j , x , y ) ;
107901: LD_VAR 0 3
107905: PPUSH
107906: LD_VAR 0 4
107910: PPUSH
107911: LD_VAR 0 5
107915: PPUSH
107916: CALL_OW 131
// end ; end ;
107920: GO 107585
107922: POP
107923: POP
// end ;
107924: GO 107141
107926: POP
107927: POP
// end ;
107928: LD_VAR 0 1
107932: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
107933: LD_INT 0
107935: PPUSH
107936: PPUSH
107937: PPUSH
107938: PPUSH
107939: PPUSH
107940: PPUSH
107941: PPUSH
107942: PPUSH
// if not mc_bases then
107943: LD_EXP 161
107947: NOT
107948: IFFALSE 107952
// exit ;
107950: GO 108578
// for i = 1 to mc_bases do
107952: LD_ADDR_VAR 0 2
107956: PUSH
107957: DOUBLE
107958: LD_INT 1
107960: DEC
107961: ST_TO_ADDR
107962: LD_EXP 161
107966: PUSH
107967: FOR_TO
107968: IFFALSE 108576
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
107970: LD_EXP 190
107974: PUSH
107975: LD_VAR 0 2
107979: ARRAY
107980: NOT
107981: PUSH
107982: LD_EXP 190
107986: PUSH
107987: LD_VAR 0 2
107991: ARRAY
107992: PPUSH
107993: LD_INT 25
107995: PUSH
107996: LD_INT 12
107998: PUSH
107999: EMPTY
108000: LIST
108001: LIST
108002: PPUSH
108003: CALL_OW 72
108007: NOT
108008: OR
108009: IFFALSE 108013
// continue ;
108011: GO 107967
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
108013: LD_ADDR_VAR 0 5
108017: PUSH
108018: LD_EXP 190
108022: PUSH
108023: LD_VAR 0 2
108027: ARRAY
108028: PUSH
108029: LD_INT 1
108031: ARRAY
108032: PPUSH
108033: CALL_OW 255
108037: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
108038: LD_VAR 0 5
108042: PPUSH
108043: LD_INT 2
108045: PPUSH
108046: CALL_OW 325
108050: IFFALSE 108303
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
108052: LD_ADDR_VAR 0 4
108056: PUSH
108057: LD_EXP 190
108061: PUSH
108062: LD_VAR 0 2
108066: ARRAY
108067: PPUSH
108068: LD_INT 25
108070: PUSH
108071: LD_INT 16
108073: PUSH
108074: EMPTY
108075: LIST
108076: LIST
108077: PPUSH
108078: CALL_OW 72
108082: ST_TO_ADDR
// if tmp < 6 then
108083: LD_VAR 0 4
108087: PUSH
108088: LD_INT 6
108090: LESS
108091: IFFALSE 108303
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
108093: LD_ADDR_VAR 0 6
108097: PUSH
108098: LD_EXP 161
108102: PUSH
108103: LD_VAR 0 2
108107: ARRAY
108108: PPUSH
108109: LD_INT 2
108111: PUSH
108112: LD_INT 30
108114: PUSH
108115: LD_INT 0
108117: PUSH
108118: EMPTY
108119: LIST
108120: LIST
108121: PUSH
108122: LD_INT 30
108124: PUSH
108125: LD_INT 1
108127: PUSH
108128: EMPTY
108129: LIST
108130: LIST
108131: PUSH
108132: EMPTY
108133: LIST
108134: LIST
108135: LIST
108136: PPUSH
108137: CALL_OW 72
108141: ST_TO_ADDR
// if depot then
108142: LD_VAR 0 6
108146: IFFALSE 108303
// begin selected := 0 ;
108148: LD_ADDR_VAR 0 7
108152: PUSH
108153: LD_INT 0
108155: ST_TO_ADDR
// for j in depot do
108156: LD_ADDR_VAR 0 3
108160: PUSH
108161: LD_VAR 0 6
108165: PUSH
108166: FOR_IN
108167: IFFALSE 108198
// begin if UnitsInside ( j ) < 6 then
108169: LD_VAR 0 3
108173: PPUSH
108174: CALL_OW 313
108178: PUSH
108179: LD_INT 6
108181: LESS
108182: IFFALSE 108196
// begin selected := j ;
108184: LD_ADDR_VAR 0 7
108188: PUSH
108189: LD_VAR 0 3
108193: ST_TO_ADDR
// break ;
108194: GO 108198
// end ; end ;
108196: GO 108166
108198: POP
108199: POP
// if selected then
108200: LD_VAR 0 7
108204: IFFALSE 108303
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
108206: LD_ADDR_VAR 0 3
108210: PUSH
108211: LD_EXP 190
108215: PUSH
108216: LD_VAR 0 2
108220: ARRAY
108221: PPUSH
108222: LD_INT 25
108224: PUSH
108225: LD_INT 12
108227: PUSH
108228: EMPTY
108229: LIST
108230: LIST
108231: PPUSH
108232: CALL_OW 72
108236: PUSH
108237: FOR_IN
108238: IFFALSE 108301
// if not HasTask ( j ) then
108240: LD_VAR 0 3
108244: PPUSH
108245: CALL_OW 314
108249: NOT
108250: IFFALSE 108299
// begin if not IsInUnit ( j ) then
108252: LD_VAR 0 3
108256: PPUSH
108257: CALL_OW 310
108261: NOT
108262: IFFALSE 108278
// ComEnterUnit ( j , selected ) ;
108264: LD_VAR 0 3
108268: PPUSH
108269: LD_VAR 0 7
108273: PPUSH
108274: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
108278: LD_VAR 0 3
108282: PPUSH
108283: LD_INT 16
108285: PPUSH
108286: CALL_OW 183
// AddComExitBuilding ( j ) ;
108290: LD_VAR 0 3
108294: PPUSH
108295: CALL_OW 182
// end ;
108299: GO 108237
108301: POP
108302: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
108303: LD_VAR 0 5
108307: PPUSH
108308: LD_INT 11
108310: PPUSH
108311: CALL_OW 325
108315: IFFALSE 108574
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
108317: LD_ADDR_VAR 0 4
108321: PUSH
108322: LD_EXP 190
108326: PUSH
108327: LD_VAR 0 2
108331: ARRAY
108332: PPUSH
108333: LD_INT 25
108335: PUSH
108336: LD_INT 16
108338: PUSH
108339: EMPTY
108340: LIST
108341: LIST
108342: PPUSH
108343: CALL_OW 72
108347: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
108348: LD_VAR 0 4
108352: PUSH
108353: LD_INT 6
108355: GREATEREQUAL
108356: PUSH
108357: LD_VAR 0 5
108361: PPUSH
108362: LD_INT 2
108364: PPUSH
108365: CALL_OW 325
108369: NOT
108370: OR
108371: IFFALSE 108574
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
108373: LD_ADDR_VAR 0 8
108377: PUSH
108378: LD_EXP 161
108382: PUSH
108383: LD_VAR 0 2
108387: ARRAY
108388: PPUSH
108389: LD_INT 2
108391: PUSH
108392: LD_INT 30
108394: PUSH
108395: LD_INT 4
108397: PUSH
108398: EMPTY
108399: LIST
108400: LIST
108401: PUSH
108402: LD_INT 30
108404: PUSH
108405: LD_INT 5
108407: PUSH
108408: EMPTY
108409: LIST
108410: LIST
108411: PUSH
108412: EMPTY
108413: LIST
108414: LIST
108415: LIST
108416: PPUSH
108417: CALL_OW 72
108421: ST_TO_ADDR
// if barracks then
108422: LD_VAR 0 8
108426: IFFALSE 108574
// begin selected := 0 ;
108428: LD_ADDR_VAR 0 7
108432: PUSH
108433: LD_INT 0
108435: ST_TO_ADDR
// for j in barracks do
108436: LD_ADDR_VAR 0 3
108440: PUSH
108441: LD_VAR 0 8
108445: PUSH
108446: FOR_IN
108447: IFFALSE 108478
// begin if UnitsInside ( j ) < 6 then
108449: LD_VAR 0 3
108453: PPUSH
108454: CALL_OW 313
108458: PUSH
108459: LD_INT 6
108461: LESS
108462: IFFALSE 108476
// begin selected := j ;
108464: LD_ADDR_VAR 0 7
108468: PUSH
108469: LD_VAR 0 3
108473: ST_TO_ADDR
// break ;
108474: GO 108478
// end ; end ;
108476: GO 108446
108478: POP
108479: POP
// if selected then
108480: LD_VAR 0 7
108484: IFFALSE 108574
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
108486: LD_ADDR_VAR 0 3
108490: PUSH
108491: LD_EXP 190
108495: PUSH
108496: LD_VAR 0 2
108500: ARRAY
108501: PPUSH
108502: LD_INT 25
108504: PUSH
108505: LD_INT 12
108507: PUSH
108508: EMPTY
108509: LIST
108510: LIST
108511: PPUSH
108512: CALL_OW 72
108516: PUSH
108517: FOR_IN
108518: IFFALSE 108572
// if not IsInUnit ( j ) and not HasTask ( j ) then
108520: LD_VAR 0 3
108524: PPUSH
108525: CALL_OW 310
108529: NOT
108530: PUSH
108531: LD_VAR 0 3
108535: PPUSH
108536: CALL_OW 314
108540: NOT
108541: AND
108542: IFFALSE 108570
// begin ComEnterUnit ( j , selected ) ;
108544: LD_VAR 0 3
108548: PPUSH
108549: LD_VAR 0 7
108553: PPUSH
108554: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
108558: LD_VAR 0 3
108562: PPUSH
108563: LD_INT 15
108565: PPUSH
108566: CALL_OW 183
// end ;
108570: GO 108517
108572: POP
108573: POP
// end ; end ; end ; end ; end ;
108574: GO 107967
108576: POP
108577: POP
// end ;
108578: LD_VAR 0 1
108582: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
108583: LD_INT 0
108585: PPUSH
108586: PPUSH
108587: PPUSH
108588: PPUSH
// if not mc_bases then
108589: LD_EXP 161
108593: NOT
108594: IFFALSE 108598
// exit ;
108596: GO 108776
// for i = 1 to mc_bases do
108598: LD_ADDR_VAR 0 2
108602: PUSH
108603: DOUBLE
108604: LD_INT 1
108606: DEC
108607: ST_TO_ADDR
108608: LD_EXP 161
108612: PUSH
108613: FOR_TO
108614: IFFALSE 108774
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
108616: LD_ADDR_VAR 0 4
108620: PUSH
108621: LD_EXP 161
108625: PUSH
108626: LD_VAR 0 2
108630: ARRAY
108631: PPUSH
108632: LD_INT 25
108634: PUSH
108635: LD_INT 9
108637: PUSH
108638: EMPTY
108639: LIST
108640: LIST
108641: PPUSH
108642: CALL_OW 72
108646: ST_TO_ADDR
// if not tmp then
108647: LD_VAR 0 4
108651: NOT
108652: IFFALSE 108656
// continue ;
108654: GO 108613
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
108656: LD_EXP 187
108660: PUSH
108661: LD_VAR 0 2
108665: ARRAY
108666: PPUSH
108667: LD_INT 29
108669: PPUSH
108670: CALL_OW 325
108674: NOT
108675: PUSH
108676: LD_EXP 187
108680: PUSH
108681: LD_VAR 0 2
108685: ARRAY
108686: PPUSH
108687: LD_INT 28
108689: PPUSH
108690: CALL_OW 325
108694: NOT
108695: AND
108696: IFFALSE 108700
// continue ;
108698: GO 108613
// for j in tmp do
108700: LD_ADDR_VAR 0 3
108704: PUSH
108705: LD_VAR 0 4
108709: PUSH
108710: FOR_IN
108711: IFFALSE 108770
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
108713: LD_VAR 0 3
108717: PUSH
108718: LD_EXP 164
108722: PUSH
108723: LD_VAR 0 2
108727: ARRAY
108728: PUSH
108729: LD_INT 1
108731: ARRAY
108732: IN
108733: NOT
108734: PUSH
108735: LD_VAR 0 3
108739: PUSH
108740: LD_EXP 164
108744: PUSH
108745: LD_VAR 0 2
108749: ARRAY
108750: PUSH
108751: LD_INT 2
108753: ARRAY
108754: IN
108755: NOT
108756: AND
108757: IFFALSE 108768
// ComSpaceTimeShoot ( j ) ;
108759: LD_VAR 0 3
108763: PPUSH
108764: CALL 20171 0 1
108768: GO 108710
108770: POP
108771: POP
// end ;
108772: GO 108613
108774: POP
108775: POP
// end ;
108776: LD_VAR 0 1
108780: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
108781: LD_INT 0
108783: PPUSH
108784: PPUSH
108785: PPUSH
108786: PPUSH
108787: PPUSH
108788: PPUSH
108789: PPUSH
108790: PPUSH
108791: PPUSH
// if not mc_bases then
108792: LD_EXP 161
108796: NOT
108797: IFFALSE 108801
// exit ;
108799: GO 109423
// for i = 1 to mc_bases do
108801: LD_ADDR_VAR 0 2
108805: PUSH
108806: DOUBLE
108807: LD_INT 1
108809: DEC
108810: ST_TO_ADDR
108811: LD_EXP 161
108815: PUSH
108816: FOR_TO
108817: IFFALSE 109421
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
108819: LD_EXP 196
108823: PUSH
108824: LD_VAR 0 2
108828: ARRAY
108829: NOT
108830: PUSH
108831: LD_INT 38
108833: PPUSH
108834: LD_EXP 187
108838: PUSH
108839: LD_VAR 0 2
108843: ARRAY
108844: PPUSH
108845: CALL_OW 321
108849: PUSH
108850: LD_INT 2
108852: NONEQUAL
108853: OR
108854: IFFALSE 108858
// continue ;
108856: GO 108816
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
108858: LD_ADDR_VAR 0 8
108862: PUSH
108863: LD_EXP 161
108867: PUSH
108868: LD_VAR 0 2
108872: ARRAY
108873: PPUSH
108874: LD_INT 30
108876: PUSH
108877: LD_INT 34
108879: PUSH
108880: EMPTY
108881: LIST
108882: LIST
108883: PPUSH
108884: CALL_OW 72
108888: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
108889: LD_ADDR_VAR 0 9
108893: PUSH
108894: LD_EXP 161
108898: PUSH
108899: LD_VAR 0 2
108903: ARRAY
108904: PPUSH
108905: LD_INT 25
108907: PUSH
108908: LD_INT 4
108910: PUSH
108911: EMPTY
108912: LIST
108913: LIST
108914: PPUSH
108915: CALL_OW 72
108919: PPUSH
108920: LD_INT 0
108922: PPUSH
108923: CALL 54127 0 2
108927: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
108928: LD_VAR 0 9
108932: NOT
108933: PUSH
108934: LD_VAR 0 8
108938: NOT
108939: OR
108940: PUSH
108941: LD_EXP 161
108945: PUSH
108946: LD_VAR 0 2
108950: ARRAY
108951: PPUSH
108952: LD_INT 124
108954: PPUSH
108955: CALL 54127 0 2
108959: OR
108960: IFFALSE 108964
// continue ;
108962: GO 108816
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
108964: LD_EXP 197
108968: PUSH
108969: LD_VAR 0 2
108973: ARRAY
108974: PUSH
108975: LD_EXP 196
108979: PUSH
108980: LD_VAR 0 2
108984: ARRAY
108985: LESS
108986: PUSH
108987: LD_EXP 197
108991: PUSH
108992: LD_VAR 0 2
108996: ARRAY
108997: PUSH
108998: LD_VAR 0 8
109002: LESS
109003: AND
109004: IFFALSE 109419
// begin tmp := sci [ 1 ] ;
109006: LD_ADDR_VAR 0 7
109010: PUSH
109011: LD_VAR 0 9
109015: PUSH
109016: LD_INT 1
109018: ARRAY
109019: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
109020: LD_VAR 0 7
109024: PPUSH
109025: LD_INT 124
109027: PPUSH
109028: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
109032: LD_ADDR_VAR 0 3
109036: PUSH
109037: DOUBLE
109038: LD_EXP 196
109042: PUSH
109043: LD_VAR 0 2
109047: ARRAY
109048: INC
109049: ST_TO_ADDR
109050: LD_EXP 196
109054: PUSH
109055: LD_VAR 0 2
109059: ARRAY
109060: PUSH
109061: FOR_DOWNTO
109062: IFFALSE 109405
// begin if IsInUnit ( tmp ) then
109064: LD_VAR 0 7
109068: PPUSH
109069: CALL_OW 310
109073: IFFALSE 109084
// ComExitBuilding ( tmp ) ;
109075: LD_VAR 0 7
109079: PPUSH
109080: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
109084: LD_INT 35
109086: PPUSH
109087: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
109091: LD_VAR 0 7
109095: PPUSH
109096: CALL_OW 310
109100: NOT
109101: PUSH
109102: LD_VAR 0 7
109106: PPUSH
109107: CALL_OW 314
109111: NOT
109112: AND
109113: IFFALSE 109084
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
109115: LD_ADDR_VAR 0 6
109119: PUSH
109120: LD_VAR 0 7
109124: PPUSH
109125: CALL_OW 250
109129: PUSH
109130: LD_VAR 0 7
109134: PPUSH
109135: CALL_OW 251
109139: PUSH
109140: EMPTY
109141: LIST
109142: LIST
109143: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
109144: LD_INT 35
109146: PPUSH
109147: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
109151: LD_ADDR_VAR 0 4
109155: PUSH
109156: LD_EXP 196
109160: PUSH
109161: LD_VAR 0 2
109165: ARRAY
109166: PUSH
109167: LD_VAR 0 3
109171: ARRAY
109172: PUSH
109173: LD_INT 1
109175: ARRAY
109176: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
109177: LD_ADDR_VAR 0 5
109181: PUSH
109182: LD_EXP 196
109186: PUSH
109187: LD_VAR 0 2
109191: ARRAY
109192: PUSH
109193: LD_VAR 0 3
109197: ARRAY
109198: PUSH
109199: LD_INT 2
109201: ARRAY
109202: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
109203: LD_VAR 0 7
109207: PPUSH
109208: LD_INT 10
109210: PPUSH
109211: CALL 26783 0 2
109215: PUSH
109216: LD_INT 4
109218: ARRAY
109219: IFFALSE 109257
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
109221: LD_VAR 0 7
109225: PPUSH
109226: LD_VAR 0 6
109230: PUSH
109231: LD_INT 1
109233: ARRAY
109234: PPUSH
109235: LD_VAR 0 6
109239: PUSH
109240: LD_INT 2
109242: ARRAY
109243: PPUSH
109244: CALL_OW 111
// wait ( 0 0$10 ) ;
109248: LD_INT 350
109250: PPUSH
109251: CALL_OW 67
// end else
109255: GO 109283
// begin ComMoveXY ( tmp , x , y ) ;
109257: LD_VAR 0 7
109261: PPUSH
109262: LD_VAR 0 4
109266: PPUSH
109267: LD_VAR 0 5
109271: PPUSH
109272: CALL_OW 111
// wait ( 0 0$3 ) ;
109276: LD_INT 105
109278: PPUSH
109279: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
109283: LD_VAR 0 7
109287: PPUSH
109288: LD_VAR 0 4
109292: PPUSH
109293: LD_VAR 0 5
109297: PPUSH
109298: CALL_OW 307
109302: IFFALSE 109144
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
109304: LD_VAR 0 7
109308: PPUSH
109309: LD_VAR 0 4
109313: PPUSH
109314: LD_VAR 0 5
109318: PPUSH
109319: LD_VAR 0 8
109323: PUSH
109324: LD_VAR 0 3
109328: ARRAY
109329: PPUSH
109330: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
109334: LD_INT 35
109336: PPUSH
109337: CALL_OW 67
// until not HasTask ( tmp ) ;
109341: LD_VAR 0 7
109345: PPUSH
109346: CALL_OW 314
109350: NOT
109351: IFFALSE 109334
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
109353: LD_ADDR_EXP 197
109357: PUSH
109358: LD_EXP 197
109362: PPUSH
109363: LD_VAR 0 2
109367: PUSH
109368: LD_EXP 197
109372: PUSH
109373: LD_VAR 0 2
109377: ARRAY
109378: PUSH
109379: LD_INT 1
109381: PLUS
109382: PUSH
109383: EMPTY
109384: LIST
109385: LIST
109386: PPUSH
109387: LD_VAR 0 8
109391: PUSH
109392: LD_VAR 0 3
109396: ARRAY
109397: PPUSH
109398: CALL 24186 0 3
109402: ST_TO_ADDR
// end ;
109403: GO 109061
109405: POP
109406: POP
// MC_Reset ( i , 124 ) ;
109407: LD_VAR 0 2
109411: PPUSH
109412: LD_INT 124
109414: PPUSH
109415: CALL 92491 0 2
// end ; end ;
109419: GO 108816
109421: POP
109422: POP
// end ;
109423: LD_VAR 0 1
109427: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
109428: LD_INT 0
109430: PPUSH
109431: PPUSH
109432: PPUSH
// if not mc_bases then
109433: LD_EXP 161
109437: NOT
109438: IFFALSE 109442
// exit ;
109440: GO 110048
// for i = 1 to mc_bases do
109442: LD_ADDR_VAR 0 2
109446: PUSH
109447: DOUBLE
109448: LD_INT 1
109450: DEC
109451: ST_TO_ADDR
109452: LD_EXP 161
109456: PUSH
109457: FOR_TO
109458: IFFALSE 110046
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
109460: LD_ADDR_VAR 0 3
109464: PUSH
109465: LD_EXP 161
109469: PUSH
109470: LD_VAR 0 2
109474: ARRAY
109475: PPUSH
109476: LD_INT 25
109478: PUSH
109479: LD_INT 4
109481: PUSH
109482: EMPTY
109483: LIST
109484: LIST
109485: PPUSH
109486: CALL_OW 72
109490: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
109491: LD_VAR 0 3
109495: NOT
109496: PUSH
109497: LD_EXP 198
109501: PUSH
109502: LD_VAR 0 2
109506: ARRAY
109507: NOT
109508: OR
109509: PUSH
109510: LD_EXP 161
109514: PUSH
109515: LD_VAR 0 2
109519: ARRAY
109520: PPUSH
109521: LD_INT 2
109523: PUSH
109524: LD_INT 30
109526: PUSH
109527: LD_INT 0
109529: PUSH
109530: EMPTY
109531: LIST
109532: LIST
109533: PUSH
109534: LD_INT 30
109536: PUSH
109537: LD_INT 1
109539: PUSH
109540: EMPTY
109541: LIST
109542: LIST
109543: PUSH
109544: EMPTY
109545: LIST
109546: LIST
109547: LIST
109548: PPUSH
109549: CALL_OW 72
109553: NOT
109554: OR
109555: IFFALSE 109605
// begin if mc_deposits_finder [ i ] then
109557: LD_EXP 199
109561: PUSH
109562: LD_VAR 0 2
109566: ARRAY
109567: IFFALSE 109603
// begin MC_Reset ( i , 125 ) ;
109569: LD_VAR 0 2
109573: PPUSH
109574: LD_INT 125
109576: PPUSH
109577: CALL 92491 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
109581: LD_ADDR_EXP 199
109585: PUSH
109586: LD_EXP 199
109590: PPUSH
109591: LD_VAR 0 2
109595: PPUSH
109596: EMPTY
109597: PPUSH
109598: CALL_OW 1
109602: ST_TO_ADDR
// end ; continue ;
109603: GO 109457
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
109605: LD_EXP 198
109609: PUSH
109610: LD_VAR 0 2
109614: ARRAY
109615: PUSH
109616: LD_INT 1
109618: ARRAY
109619: PUSH
109620: LD_INT 3
109622: ARRAY
109623: PUSH
109624: LD_INT 1
109626: EQUAL
109627: PUSH
109628: LD_INT 20
109630: PPUSH
109631: LD_EXP 187
109635: PUSH
109636: LD_VAR 0 2
109640: ARRAY
109641: PPUSH
109642: CALL_OW 321
109646: PUSH
109647: LD_INT 2
109649: NONEQUAL
109650: AND
109651: IFFALSE 109701
// begin if mc_deposits_finder [ i ] then
109653: LD_EXP 199
109657: PUSH
109658: LD_VAR 0 2
109662: ARRAY
109663: IFFALSE 109699
// begin MC_Reset ( i , 125 ) ;
109665: LD_VAR 0 2
109669: PPUSH
109670: LD_INT 125
109672: PPUSH
109673: CALL 92491 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
109677: LD_ADDR_EXP 199
109681: PUSH
109682: LD_EXP 199
109686: PPUSH
109687: LD_VAR 0 2
109691: PPUSH
109692: EMPTY
109693: PPUSH
109694: CALL_OW 1
109698: ST_TO_ADDR
// end ; continue ;
109699: GO 109457
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
109701: LD_EXP 198
109705: PUSH
109706: LD_VAR 0 2
109710: ARRAY
109711: PUSH
109712: LD_INT 1
109714: ARRAY
109715: PUSH
109716: LD_INT 1
109718: ARRAY
109719: PPUSH
109720: LD_EXP 198
109724: PUSH
109725: LD_VAR 0 2
109729: ARRAY
109730: PUSH
109731: LD_INT 1
109733: ARRAY
109734: PUSH
109735: LD_INT 2
109737: ARRAY
109738: PPUSH
109739: LD_EXP 187
109743: PUSH
109744: LD_VAR 0 2
109748: ARRAY
109749: PPUSH
109750: CALL_OW 440
109754: IFFALSE 109797
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
109756: LD_ADDR_EXP 198
109760: PUSH
109761: LD_EXP 198
109765: PPUSH
109766: LD_VAR 0 2
109770: PPUSH
109771: LD_EXP 198
109775: PUSH
109776: LD_VAR 0 2
109780: ARRAY
109781: PPUSH
109782: LD_INT 1
109784: PPUSH
109785: CALL_OW 3
109789: PPUSH
109790: CALL_OW 1
109794: ST_TO_ADDR
109795: GO 110044
// begin if not mc_deposits_finder [ i ] then
109797: LD_EXP 199
109801: PUSH
109802: LD_VAR 0 2
109806: ARRAY
109807: NOT
109808: IFFALSE 109860
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
109810: LD_ADDR_EXP 199
109814: PUSH
109815: LD_EXP 199
109819: PPUSH
109820: LD_VAR 0 2
109824: PPUSH
109825: LD_VAR 0 3
109829: PUSH
109830: LD_INT 1
109832: ARRAY
109833: PUSH
109834: EMPTY
109835: LIST
109836: PPUSH
109837: CALL_OW 1
109841: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
109842: LD_VAR 0 3
109846: PUSH
109847: LD_INT 1
109849: ARRAY
109850: PPUSH
109851: LD_INT 125
109853: PPUSH
109854: CALL_OW 109
// end else
109858: GO 110044
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
109860: LD_EXP 199
109864: PUSH
109865: LD_VAR 0 2
109869: ARRAY
109870: PUSH
109871: LD_INT 1
109873: ARRAY
109874: PPUSH
109875: CALL_OW 310
109879: IFFALSE 109902
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
109881: LD_EXP 199
109885: PUSH
109886: LD_VAR 0 2
109890: ARRAY
109891: PUSH
109892: LD_INT 1
109894: ARRAY
109895: PPUSH
109896: CALL_OW 122
109900: GO 110044
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
109902: LD_EXP 199
109906: PUSH
109907: LD_VAR 0 2
109911: ARRAY
109912: PUSH
109913: LD_INT 1
109915: ARRAY
109916: PPUSH
109917: CALL_OW 314
109921: NOT
109922: PUSH
109923: LD_EXP 199
109927: PUSH
109928: LD_VAR 0 2
109932: ARRAY
109933: PUSH
109934: LD_INT 1
109936: ARRAY
109937: PPUSH
109938: LD_EXP 198
109942: PUSH
109943: LD_VAR 0 2
109947: ARRAY
109948: PUSH
109949: LD_INT 1
109951: ARRAY
109952: PUSH
109953: LD_INT 1
109955: ARRAY
109956: PPUSH
109957: LD_EXP 198
109961: PUSH
109962: LD_VAR 0 2
109966: ARRAY
109967: PUSH
109968: LD_INT 1
109970: ARRAY
109971: PUSH
109972: LD_INT 2
109974: ARRAY
109975: PPUSH
109976: CALL_OW 297
109980: PUSH
109981: LD_INT 6
109983: GREATER
109984: AND
109985: IFFALSE 110044
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
109987: LD_EXP 199
109991: PUSH
109992: LD_VAR 0 2
109996: ARRAY
109997: PUSH
109998: LD_INT 1
110000: ARRAY
110001: PPUSH
110002: LD_EXP 198
110006: PUSH
110007: LD_VAR 0 2
110011: ARRAY
110012: PUSH
110013: LD_INT 1
110015: ARRAY
110016: PUSH
110017: LD_INT 1
110019: ARRAY
110020: PPUSH
110021: LD_EXP 198
110025: PUSH
110026: LD_VAR 0 2
110030: ARRAY
110031: PUSH
110032: LD_INT 1
110034: ARRAY
110035: PUSH
110036: LD_INT 2
110038: ARRAY
110039: PPUSH
110040: CALL_OW 111
// end ; end ; end ;
110044: GO 109457
110046: POP
110047: POP
// end ;
110048: LD_VAR 0 1
110052: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
110053: LD_INT 0
110055: PPUSH
110056: PPUSH
110057: PPUSH
110058: PPUSH
110059: PPUSH
110060: PPUSH
110061: PPUSH
110062: PPUSH
110063: PPUSH
110064: PPUSH
110065: PPUSH
// if not mc_bases then
110066: LD_EXP 161
110070: NOT
110071: IFFALSE 110075
// exit ;
110073: GO 111015
// for i = 1 to mc_bases do
110075: LD_ADDR_VAR 0 2
110079: PUSH
110080: DOUBLE
110081: LD_INT 1
110083: DEC
110084: ST_TO_ADDR
110085: LD_EXP 161
110089: PUSH
110090: FOR_TO
110091: IFFALSE 111013
// begin if not mc_bases [ i ] or mc_scan [ i ] then
110093: LD_EXP 161
110097: PUSH
110098: LD_VAR 0 2
110102: ARRAY
110103: NOT
110104: PUSH
110105: LD_EXP 184
110109: PUSH
110110: LD_VAR 0 2
110114: ARRAY
110115: OR
110116: IFFALSE 110120
// continue ;
110118: GO 110090
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
110120: LD_ADDR_VAR 0 7
110124: PUSH
110125: LD_EXP 161
110129: PUSH
110130: LD_VAR 0 2
110134: ARRAY
110135: PUSH
110136: LD_INT 1
110138: ARRAY
110139: PPUSH
110140: CALL_OW 248
110144: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
110145: LD_VAR 0 7
110149: PUSH
110150: LD_INT 3
110152: EQUAL
110153: PUSH
110154: LD_EXP 180
110158: PUSH
110159: LD_VAR 0 2
110163: ARRAY
110164: PUSH
110165: LD_EXP 183
110169: PUSH
110170: LD_VAR 0 2
110174: ARRAY
110175: UNION
110176: PPUSH
110177: LD_INT 33
110179: PUSH
110180: LD_INT 2
110182: PUSH
110183: EMPTY
110184: LIST
110185: LIST
110186: PPUSH
110187: CALL_OW 72
110191: NOT
110192: OR
110193: IFFALSE 110197
// continue ;
110195: GO 110090
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
110197: LD_ADDR_VAR 0 9
110201: PUSH
110202: LD_EXP 161
110206: PUSH
110207: LD_VAR 0 2
110211: ARRAY
110212: PPUSH
110213: LD_INT 30
110215: PUSH
110216: LD_INT 36
110218: PUSH
110219: EMPTY
110220: LIST
110221: LIST
110222: PPUSH
110223: CALL_OW 72
110227: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
110228: LD_ADDR_VAR 0 10
110232: PUSH
110233: LD_EXP 180
110237: PUSH
110238: LD_VAR 0 2
110242: ARRAY
110243: PPUSH
110244: LD_INT 34
110246: PUSH
110247: LD_INT 31
110249: PUSH
110250: EMPTY
110251: LIST
110252: LIST
110253: PPUSH
110254: CALL_OW 72
110258: ST_TO_ADDR
// if not cts and not mcts then
110259: LD_VAR 0 9
110263: NOT
110264: PUSH
110265: LD_VAR 0 10
110269: NOT
110270: AND
110271: IFFALSE 110275
// continue ;
110273: GO 110090
// x := cts ;
110275: LD_ADDR_VAR 0 11
110279: PUSH
110280: LD_VAR 0 9
110284: ST_TO_ADDR
// if not x then
110285: LD_VAR 0 11
110289: NOT
110290: IFFALSE 110302
// x := mcts ;
110292: LD_ADDR_VAR 0 11
110296: PUSH
110297: LD_VAR 0 10
110301: ST_TO_ADDR
// if not x then
110302: LD_VAR 0 11
110306: NOT
110307: IFFALSE 110311
// continue ;
110309: GO 110090
// if mc_remote_driver [ i ] then
110311: LD_EXP 201
110315: PUSH
110316: LD_VAR 0 2
110320: ARRAY
110321: IFFALSE 110708
// for j in mc_remote_driver [ i ] do
110323: LD_ADDR_VAR 0 3
110327: PUSH
110328: LD_EXP 201
110332: PUSH
110333: LD_VAR 0 2
110337: ARRAY
110338: PUSH
110339: FOR_IN
110340: IFFALSE 110706
// begin if GetClass ( j ) <> 3 then
110342: LD_VAR 0 3
110346: PPUSH
110347: CALL_OW 257
110351: PUSH
110352: LD_INT 3
110354: NONEQUAL
110355: IFFALSE 110408
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
110357: LD_ADDR_EXP 201
110361: PUSH
110362: LD_EXP 201
110366: PPUSH
110367: LD_VAR 0 2
110371: PPUSH
110372: LD_EXP 201
110376: PUSH
110377: LD_VAR 0 2
110381: ARRAY
110382: PUSH
110383: LD_VAR 0 3
110387: DIFF
110388: PPUSH
110389: CALL_OW 1
110393: ST_TO_ADDR
// SetTag ( j , 0 ) ;
110394: LD_VAR 0 3
110398: PPUSH
110399: LD_INT 0
110401: PPUSH
110402: CALL_OW 109
// continue ;
110406: GO 110339
// end ; if UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) and not IsDriver ( j ) then
110408: LD_EXP 180
110412: PUSH
110413: LD_VAR 0 2
110417: ARRAY
110418: PPUSH
110419: LD_INT 34
110421: PUSH
110422: LD_INT 31
110424: PUSH
110425: EMPTY
110426: LIST
110427: LIST
110428: PUSH
110429: LD_INT 58
110431: PUSH
110432: EMPTY
110433: LIST
110434: PUSH
110435: EMPTY
110436: LIST
110437: LIST
110438: PPUSH
110439: CALL_OW 72
110443: PUSH
110444: LD_VAR 0 3
110448: PPUSH
110449: CALL 54162 0 1
110453: NOT
110454: AND
110455: IFFALSE 110526
// begin if IsInUnit ( j ) then
110457: LD_VAR 0 3
110461: PPUSH
110462: CALL_OW 310
110466: IFFALSE 110477
// ComExitBuilding ( j ) ;
110468: LD_VAR 0 3
110472: PPUSH
110473: CALL_OW 122
// AddComEnterUnit ( j , UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) [ 1 ] ) ;
110477: LD_VAR 0 3
110481: PPUSH
110482: LD_EXP 180
110486: PUSH
110487: LD_VAR 0 2
110491: ARRAY
110492: PPUSH
110493: LD_INT 34
110495: PUSH
110496: LD_INT 31
110498: PUSH
110499: EMPTY
110500: LIST
110501: LIST
110502: PUSH
110503: LD_INT 58
110505: PUSH
110506: EMPTY
110507: LIST
110508: PUSH
110509: EMPTY
110510: LIST
110511: LIST
110512: PPUSH
110513: CALL_OW 72
110517: PUSH
110518: LD_INT 1
110520: ARRAY
110521: PPUSH
110522: CALL_OW 180
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
110526: LD_VAR 0 3
110530: PPUSH
110531: CALL_OW 310
110535: NOT
110536: PUSH
110537: LD_VAR 0 3
110541: PPUSH
110542: CALL_OW 310
110546: PPUSH
110547: CALL_OW 266
110551: PUSH
110552: LD_INT 36
110554: NONEQUAL
110555: PUSH
110556: LD_VAR 0 3
110560: PPUSH
110561: CALL 54162 0 1
110565: NOT
110566: AND
110567: OR
110568: IFFALSE 110704
// begin if IsInUnit ( j ) then
110570: LD_VAR 0 3
110574: PPUSH
110575: CALL_OW 310
110579: IFFALSE 110590
// ComExitBuilding ( j ) ;
110581: LD_VAR 0 3
110585: PPUSH
110586: CALL_OW 122
// ct := 0 ;
110590: LD_ADDR_VAR 0 8
110594: PUSH
110595: LD_INT 0
110597: ST_TO_ADDR
// for k in x do
110598: LD_ADDR_VAR 0 4
110602: PUSH
110603: LD_VAR 0 11
110607: PUSH
110608: FOR_IN
110609: IFFALSE 110682
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
110611: LD_VAR 0 4
110615: PPUSH
110616: CALL_OW 264
110620: PUSH
110621: LD_INT 31
110623: EQUAL
110624: PUSH
110625: LD_VAR 0 4
110629: PPUSH
110630: CALL_OW 311
110634: NOT
110635: AND
110636: PUSH
110637: LD_VAR 0 4
110641: PPUSH
110642: CALL_OW 266
110646: PUSH
110647: LD_INT 36
110649: EQUAL
110650: PUSH
110651: LD_VAR 0 4
110655: PPUSH
110656: CALL_OW 313
110660: PUSH
110661: LD_INT 3
110663: LESS
110664: AND
110665: OR
110666: IFFALSE 110680
// begin ct := k ;
110668: LD_ADDR_VAR 0 8
110672: PUSH
110673: LD_VAR 0 4
110677: ST_TO_ADDR
// break ;
110678: GO 110682
// end ;
110680: GO 110608
110682: POP
110683: POP
// if ct then
110684: LD_VAR 0 8
110688: IFFALSE 110704
// ComEnterUnit ( j , ct ) ;
110690: LD_VAR 0 3
110694: PPUSH
110695: LD_VAR 0 8
110699: PPUSH
110700: CALL_OW 120
// end ; end ;
110704: GO 110339
110706: POP
110707: POP
// places := 0 ;
110708: LD_ADDR_VAR 0 5
110712: PUSH
110713: LD_INT 0
110715: ST_TO_ADDR
// for j = 1 to x do
110716: LD_ADDR_VAR 0 3
110720: PUSH
110721: DOUBLE
110722: LD_INT 1
110724: DEC
110725: ST_TO_ADDR
110726: LD_VAR 0 11
110730: PUSH
110731: FOR_TO
110732: IFFALSE 110808
// if GetWeapon ( x [ j ] ) = ar_control_tower then
110734: LD_VAR 0 11
110738: PUSH
110739: LD_VAR 0 3
110743: ARRAY
110744: PPUSH
110745: CALL_OW 264
110749: PUSH
110750: LD_INT 31
110752: EQUAL
110753: IFFALSE 110771
// places := places + 1 else
110755: LD_ADDR_VAR 0 5
110759: PUSH
110760: LD_VAR 0 5
110764: PUSH
110765: LD_INT 1
110767: PLUS
110768: ST_TO_ADDR
110769: GO 110806
// if GetBType ( x [ j ] ) = b_control_tower then
110771: LD_VAR 0 11
110775: PUSH
110776: LD_VAR 0 3
110780: ARRAY
110781: PPUSH
110782: CALL_OW 266
110786: PUSH
110787: LD_INT 36
110789: EQUAL
110790: IFFALSE 110806
// places := places + 3 ;
110792: LD_ADDR_VAR 0 5
110796: PUSH
110797: LD_VAR 0 5
110801: PUSH
110802: LD_INT 3
110804: PLUS
110805: ST_TO_ADDR
110806: GO 110731
110808: POP
110809: POP
// if places = 0 or places <= mc_remote_driver [ i ] then
110810: LD_VAR 0 5
110814: PUSH
110815: LD_INT 0
110817: EQUAL
110818: PUSH
110819: LD_VAR 0 5
110823: PUSH
110824: LD_EXP 201
110828: PUSH
110829: LD_VAR 0 2
110833: ARRAY
110834: LESSEQUAL
110835: OR
110836: IFFALSE 110840
// continue ;
110838: GO 110090
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
110840: LD_ADDR_VAR 0 6
110844: PUSH
110845: LD_EXP 161
110849: PUSH
110850: LD_VAR 0 2
110854: ARRAY
110855: PPUSH
110856: LD_INT 25
110858: PUSH
110859: LD_INT 3
110861: PUSH
110862: EMPTY
110863: LIST
110864: LIST
110865: PPUSH
110866: CALL_OW 72
110870: PUSH
110871: LD_EXP 201
110875: PUSH
110876: LD_VAR 0 2
110880: ARRAY
110881: DIFF
110882: PPUSH
110883: LD_INT 3
110885: PPUSH
110886: CALL 55062 0 2
110890: ST_TO_ADDR
// for j in tmp do
110891: LD_ADDR_VAR 0 3
110895: PUSH
110896: LD_VAR 0 6
110900: PUSH
110901: FOR_IN
110902: IFFALSE 110937
// if GetTag ( j ) > 0 then
110904: LD_VAR 0 3
110908: PPUSH
110909: CALL_OW 110
110913: PUSH
110914: LD_INT 0
110916: GREATER
110917: IFFALSE 110935
// tmp := tmp diff j ;
110919: LD_ADDR_VAR 0 6
110923: PUSH
110924: LD_VAR 0 6
110928: PUSH
110929: LD_VAR 0 3
110933: DIFF
110934: ST_TO_ADDR
110935: GO 110901
110937: POP
110938: POP
// if not tmp then
110939: LD_VAR 0 6
110943: NOT
110944: IFFALSE 110948
// continue ;
110946: GO 110090
// if places then
110948: LD_VAR 0 5
110952: IFFALSE 111011
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
110954: LD_ADDR_EXP 201
110958: PUSH
110959: LD_EXP 201
110963: PPUSH
110964: LD_VAR 0 2
110968: PPUSH
110969: LD_EXP 201
110973: PUSH
110974: LD_VAR 0 2
110978: ARRAY
110979: PUSH
110980: LD_VAR 0 6
110984: PUSH
110985: LD_INT 1
110987: ARRAY
110988: UNION
110989: PPUSH
110990: CALL_OW 1
110994: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
110995: LD_VAR 0 6
110999: PUSH
111000: LD_INT 1
111002: ARRAY
111003: PPUSH
111004: LD_INT 126
111006: PPUSH
111007: CALL_OW 109
// end ; end ;
111011: GO 110090
111013: POP
111014: POP
// end ;
111015: LD_VAR 0 1
111019: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
111020: LD_INT 0
111022: PPUSH
111023: PPUSH
111024: PPUSH
111025: PPUSH
111026: PPUSH
111027: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
111028: LD_VAR 0 1
111032: NOT
111033: PUSH
111034: LD_VAR 0 2
111038: NOT
111039: OR
111040: PUSH
111041: LD_VAR 0 3
111045: NOT
111046: OR
111047: PUSH
111048: LD_VAR 0 4
111052: PUSH
111053: LD_INT 1
111055: PUSH
111056: LD_INT 2
111058: PUSH
111059: LD_INT 3
111061: PUSH
111062: LD_INT 4
111064: PUSH
111065: LD_INT 5
111067: PUSH
111068: LD_INT 8
111070: PUSH
111071: LD_INT 9
111073: PUSH
111074: LD_INT 15
111076: PUSH
111077: LD_INT 16
111079: PUSH
111080: EMPTY
111081: LIST
111082: LIST
111083: LIST
111084: LIST
111085: LIST
111086: LIST
111087: LIST
111088: LIST
111089: LIST
111090: IN
111091: NOT
111092: OR
111093: IFFALSE 111097
// exit ;
111095: GO 111955
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
111097: LD_ADDR_VAR 0 2
111101: PUSH
111102: LD_VAR 0 2
111106: PPUSH
111107: LD_INT 21
111109: PUSH
111110: LD_INT 3
111112: PUSH
111113: EMPTY
111114: LIST
111115: LIST
111116: PUSH
111117: LD_INT 24
111119: PUSH
111120: LD_INT 250
111122: PUSH
111123: EMPTY
111124: LIST
111125: LIST
111126: PUSH
111127: EMPTY
111128: LIST
111129: LIST
111130: PPUSH
111131: CALL_OW 72
111135: ST_TO_ADDR
// case class of 1 , 15 :
111136: LD_VAR 0 4
111140: PUSH
111141: LD_INT 1
111143: DOUBLE
111144: EQUAL
111145: IFTRUE 111155
111147: LD_INT 15
111149: DOUBLE
111150: EQUAL
111151: IFTRUE 111155
111153: GO 111240
111155: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
111156: LD_ADDR_VAR 0 8
111160: PUSH
111161: LD_VAR 0 2
111165: PPUSH
111166: LD_INT 2
111168: PUSH
111169: LD_INT 30
111171: PUSH
111172: LD_INT 32
111174: PUSH
111175: EMPTY
111176: LIST
111177: LIST
111178: PUSH
111179: LD_INT 30
111181: PUSH
111182: LD_INT 31
111184: PUSH
111185: EMPTY
111186: LIST
111187: LIST
111188: PUSH
111189: EMPTY
111190: LIST
111191: LIST
111192: LIST
111193: PPUSH
111194: CALL_OW 72
111198: PUSH
111199: LD_VAR 0 2
111203: PPUSH
111204: LD_INT 2
111206: PUSH
111207: LD_INT 30
111209: PUSH
111210: LD_INT 4
111212: PUSH
111213: EMPTY
111214: LIST
111215: LIST
111216: PUSH
111217: LD_INT 30
111219: PUSH
111220: LD_INT 5
111222: PUSH
111223: EMPTY
111224: LIST
111225: LIST
111226: PUSH
111227: EMPTY
111228: LIST
111229: LIST
111230: LIST
111231: PPUSH
111232: CALL_OW 72
111236: ADD
111237: ST_TO_ADDR
111238: GO 111486
111240: LD_INT 2
111242: DOUBLE
111243: EQUAL
111244: IFTRUE 111254
111246: LD_INT 16
111248: DOUBLE
111249: EQUAL
111250: IFTRUE 111254
111252: GO 111300
111254: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
111255: LD_ADDR_VAR 0 8
111259: PUSH
111260: LD_VAR 0 2
111264: PPUSH
111265: LD_INT 2
111267: PUSH
111268: LD_INT 30
111270: PUSH
111271: LD_INT 0
111273: PUSH
111274: EMPTY
111275: LIST
111276: LIST
111277: PUSH
111278: LD_INT 30
111280: PUSH
111281: LD_INT 1
111283: PUSH
111284: EMPTY
111285: LIST
111286: LIST
111287: PUSH
111288: EMPTY
111289: LIST
111290: LIST
111291: LIST
111292: PPUSH
111293: CALL_OW 72
111297: ST_TO_ADDR
111298: GO 111486
111300: LD_INT 3
111302: DOUBLE
111303: EQUAL
111304: IFTRUE 111308
111306: GO 111354
111308: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
111309: LD_ADDR_VAR 0 8
111313: PUSH
111314: LD_VAR 0 2
111318: PPUSH
111319: LD_INT 2
111321: PUSH
111322: LD_INT 30
111324: PUSH
111325: LD_INT 2
111327: PUSH
111328: EMPTY
111329: LIST
111330: LIST
111331: PUSH
111332: LD_INT 30
111334: PUSH
111335: LD_INT 3
111337: PUSH
111338: EMPTY
111339: LIST
111340: LIST
111341: PUSH
111342: EMPTY
111343: LIST
111344: LIST
111345: LIST
111346: PPUSH
111347: CALL_OW 72
111351: ST_TO_ADDR
111352: GO 111486
111354: LD_INT 4
111356: DOUBLE
111357: EQUAL
111358: IFTRUE 111362
111360: GO 111419
111362: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
111363: LD_ADDR_VAR 0 8
111367: PUSH
111368: LD_VAR 0 2
111372: PPUSH
111373: LD_INT 2
111375: PUSH
111376: LD_INT 30
111378: PUSH
111379: LD_INT 6
111381: PUSH
111382: EMPTY
111383: LIST
111384: LIST
111385: PUSH
111386: LD_INT 30
111388: PUSH
111389: LD_INT 7
111391: PUSH
111392: EMPTY
111393: LIST
111394: LIST
111395: PUSH
111396: LD_INT 30
111398: PUSH
111399: LD_INT 8
111401: PUSH
111402: EMPTY
111403: LIST
111404: LIST
111405: PUSH
111406: EMPTY
111407: LIST
111408: LIST
111409: LIST
111410: LIST
111411: PPUSH
111412: CALL_OW 72
111416: ST_TO_ADDR
111417: GO 111486
111419: LD_INT 5
111421: DOUBLE
111422: EQUAL
111423: IFTRUE 111439
111425: LD_INT 8
111427: DOUBLE
111428: EQUAL
111429: IFTRUE 111439
111431: LD_INT 9
111433: DOUBLE
111434: EQUAL
111435: IFTRUE 111439
111437: GO 111485
111439: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
111440: LD_ADDR_VAR 0 8
111444: PUSH
111445: LD_VAR 0 2
111449: PPUSH
111450: LD_INT 2
111452: PUSH
111453: LD_INT 30
111455: PUSH
111456: LD_INT 4
111458: PUSH
111459: EMPTY
111460: LIST
111461: LIST
111462: PUSH
111463: LD_INT 30
111465: PUSH
111466: LD_INT 5
111468: PUSH
111469: EMPTY
111470: LIST
111471: LIST
111472: PUSH
111473: EMPTY
111474: LIST
111475: LIST
111476: LIST
111477: PPUSH
111478: CALL_OW 72
111482: ST_TO_ADDR
111483: GO 111486
111485: POP
// if not tmp then
111486: LD_VAR 0 8
111490: NOT
111491: IFFALSE 111495
// exit ;
111493: GO 111955
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
111495: LD_VAR 0 4
111499: PUSH
111500: LD_INT 1
111502: PUSH
111503: LD_INT 15
111505: PUSH
111506: EMPTY
111507: LIST
111508: LIST
111509: IN
111510: PUSH
111511: LD_EXP 170
111515: PUSH
111516: LD_VAR 0 1
111520: ARRAY
111521: AND
111522: IFFALSE 111678
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
111524: LD_ADDR_VAR 0 9
111528: PUSH
111529: LD_EXP 170
111533: PUSH
111534: LD_VAR 0 1
111538: ARRAY
111539: PUSH
111540: LD_INT 1
111542: ARRAY
111543: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
111544: LD_VAR 0 9
111548: PUSH
111549: LD_EXP 171
111553: PUSH
111554: LD_VAR 0 1
111558: ARRAY
111559: IN
111560: NOT
111561: IFFALSE 111676
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
111563: LD_ADDR_EXP 171
111567: PUSH
111568: LD_EXP 171
111572: PPUSH
111573: LD_VAR 0 1
111577: PUSH
111578: LD_EXP 171
111582: PUSH
111583: LD_VAR 0 1
111587: ARRAY
111588: PUSH
111589: LD_INT 1
111591: PLUS
111592: PUSH
111593: EMPTY
111594: LIST
111595: LIST
111596: PPUSH
111597: LD_VAR 0 9
111601: PPUSH
111602: CALL 24186 0 3
111606: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
111607: LD_ADDR_EXP 170
111611: PUSH
111612: LD_EXP 170
111616: PPUSH
111617: LD_VAR 0 1
111621: PPUSH
111622: LD_EXP 170
111626: PUSH
111627: LD_VAR 0 1
111631: ARRAY
111632: PUSH
111633: LD_VAR 0 9
111637: DIFF
111638: PPUSH
111639: CALL_OW 1
111643: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
111644: LD_VAR 0 3
111648: PPUSH
111649: LD_EXP 171
111653: PUSH
111654: LD_VAR 0 1
111658: ARRAY
111659: PUSH
111660: LD_EXP 171
111664: PUSH
111665: LD_VAR 0 1
111669: ARRAY
111670: ARRAY
111671: PPUSH
111672: CALL_OW 120
// end ; exit ;
111676: GO 111955
// end ; if tmp > 1 then
111678: LD_VAR 0 8
111682: PUSH
111683: LD_INT 1
111685: GREATER
111686: IFFALSE 111790
// for i = 2 to tmp do
111688: LD_ADDR_VAR 0 6
111692: PUSH
111693: DOUBLE
111694: LD_INT 2
111696: DEC
111697: ST_TO_ADDR
111698: LD_VAR 0 8
111702: PUSH
111703: FOR_TO
111704: IFFALSE 111788
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
111706: LD_VAR 0 8
111710: PUSH
111711: LD_VAR 0 6
111715: ARRAY
111716: PPUSH
111717: CALL_OW 461
111721: PUSH
111722: LD_INT 6
111724: EQUAL
111725: IFFALSE 111786
// begin x := tmp [ i ] ;
111727: LD_ADDR_VAR 0 9
111731: PUSH
111732: LD_VAR 0 8
111736: PUSH
111737: LD_VAR 0 6
111741: ARRAY
111742: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
111743: LD_ADDR_VAR 0 8
111747: PUSH
111748: LD_VAR 0 8
111752: PPUSH
111753: LD_VAR 0 6
111757: PPUSH
111758: CALL_OW 3
111762: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
111763: LD_ADDR_VAR 0 8
111767: PUSH
111768: LD_VAR 0 8
111772: PPUSH
111773: LD_INT 1
111775: PPUSH
111776: LD_VAR 0 9
111780: PPUSH
111781: CALL_OW 2
111785: ST_TO_ADDR
// end ;
111786: GO 111703
111788: POP
111789: POP
// for i in tmp do
111790: LD_ADDR_VAR 0 6
111794: PUSH
111795: LD_VAR 0 8
111799: PUSH
111800: FOR_IN
111801: IFFALSE 111828
// begin if IsNotFull ( i ) then
111803: LD_VAR 0 6
111807: PPUSH
111808: CALL 21408 0 1
111812: IFFALSE 111826
// begin j := i ;
111814: LD_ADDR_VAR 0 7
111818: PUSH
111819: LD_VAR 0 6
111823: ST_TO_ADDR
// break ;
111824: GO 111828
// end ; end ;
111826: GO 111800
111828: POP
111829: POP
// if j then
111830: LD_VAR 0 7
111834: IFFALSE 111852
// ComEnterUnit ( unit , j ) else
111836: LD_VAR 0 3
111840: PPUSH
111841: LD_VAR 0 7
111845: PPUSH
111846: CALL_OW 120
111850: GO 111955
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
111852: LD_ADDR_VAR 0 10
111856: PUSH
111857: LD_VAR 0 2
111861: PPUSH
111862: LD_INT 2
111864: PUSH
111865: LD_INT 30
111867: PUSH
111868: LD_INT 0
111870: PUSH
111871: EMPTY
111872: LIST
111873: LIST
111874: PUSH
111875: LD_INT 30
111877: PUSH
111878: LD_INT 1
111880: PUSH
111881: EMPTY
111882: LIST
111883: LIST
111884: PUSH
111885: EMPTY
111886: LIST
111887: LIST
111888: LIST
111889: PPUSH
111890: CALL_OW 72
111894: ST_TO_ADDR
// if depot then
111895: LD_VAR 0 10
111899: IFFALSE 111955
// begin depot := NearestUnitToUnit ( depot , unit ) ;
111901: LD_ADDR_VAR 0 10
111905: PUSH
111906: LD_VAR 0 10
111910: PPUSH
111911: LD_VAR 0 3
111915: PPUSH
111916: CALL_OW 74
111920: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
111921: LD_VAR 0 3
111925: PPUSH
111926: LD_VAR 0 10
111930: PPUSH
111931: CALL_OW 296
111935: PUSH
111936: LD_INT 10
111938: GREATER
111939: IFFALSE 111955
// ComStandNearbyBuilding ( unit , depot ) ;
111941: LD_VAR 0 3
111945: PPUSH
111946: LD_VAR 0 10
111950: PPUSH
111951: CALL 20788 0 2
// end ; end ; end ;
111955: LD_VAR 0 5
111959: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
111960: LD_INT 0
111962: PPUSH
111963: PPUSH
111964: PPUSH
111965: PPUSH
// if not mc_bases then
111966: LD_EXP 161
111970: NOT
111971: IFFALSE 111975
// exit ;
111973: GO 112214
// for i = 1 to mc_bases do
111975: LD_ADDR_VAR 0 2
111979: PUSH
111980: DOUBLE
111981: LD_INT 1
111983: DEC
111984: ST_TO_ADDR
111985: LD_EXP 161
111989: PUSH
111990: FOR_TO
111991: IFFALSE 112212
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
111993: LD_ADDR_VAR 0 4
111997: PUSH
111998: LD_EXP 161
112002: PUSH
112003: LD_VAR 0 2
112007: ARRAY
112008: PPUSH
112009: LD_INT 21
112011: PUSH
112012: LD_INT 1
112014: PUSH
112015: EMPTY
112016: LIST
112017: LIST
112018: PPUSH
112019: CALL_OW 72
112023: PUSH
112024: LD_EXP 190
112028: PUSH
112029: LD_VAR 0 2
112033: ARRAY
112034: UNION
112035: ST_TO_ADDR
// if not tmp then
112036: LD_VAR 0 4
112040: NOT
112041: IFFALSE 112045
// continue ;
112043: GO 111990
// for j in tmp do
112045: LD_ADDR_VAR 0 3
112049: PUSH
112050: LD_VAR 0 4
112054: PUSH
112055: FOR_IN
112056: IFFALSE 112208
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
112058: LD_VAR 0 3
112062: PPUSH
112063: CALL_OW 110
112067: NOT
112068: PUSH
112069: LD_VAR 0 3
112073: PPUSH
112074: CALL_OW 314
112078: NOT
112079: AND
112080: PUSH
112081: LD_VAR 0 3
112085: PPUSH
112086: CALL_OW 311
112090: NOT
112091: AND
112092: PUSH
112093: LD_VAR 0 3
112097: PPUSH
112098: CALL_OW 310
112102: NOT
112103: AND
112104: PUSH
112105: LD_VAR 0 3
112109: PUSH
112110: LD_EXP 164
112114: PUSH
112115: LD_VAR 0 2
112119: ARRAY
112120: PUSH
112121: LD_INT 1
112123: ARRAY
112124: IN
112125: NOT
112126: AND
112127: PUSH
112128: LD_VAR 0 3
112132: PUSH
112133: LD_EXP 164
112137: PUSH
112138: LD_VAR 0 2
112142: ARRAY
112143: PUSH
112144: LD_INT 2
112146: ARRAY
112147: IN
112148: NOT
112149: AND
112150: PUSH
112151: LD_VAR 0 3
112155: PUSH
112156: LD_EXP 173
112160: PUSH
112161: LD_VAR 0 2
112165: ARRAY
112166: IN
112167: NOT
112168: AND
112169: IFFALSE 112206
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
112171: LD_VAR 0 2
112175: PPUSH
112176: LD_EXP 161
112180: PUSH
112181: LD_VAR 0 2
112185: ARRAY
112186: PPUSH
112187: LD_VAR 0 3
112191: PPUSH
112192: LD_VAR 0 3
112196: PPUSH
112197: CALL_OW 257
112201: PPUSH
112202: CALL 111020 0 4
// end ;
112206: GO 112055
112208: POP
112209: POP
// end ;
112210: GO 111990
112212: POP
112213: POP
// end ;
112214: LD_VAR 0 1
112218: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , j , c ; begin
112219: LD_INT 0
112221: PPUSH
112222: PPUSH
112223: PPUSH
112224: PPUSH
112225: PPUSH
112226: PPUSH
// if not mc_bases [ base ] then
112227: LD_EXP 161
112231: PUSH
112232: LD_VAR 0 1
112236: ARRAY
112237: NOT
112238: IFFALSE 112242
// exit ;
112240: GO 112443
// tmp := [ ] ;
112242: LD_ADDR_VAR 0 6
112246: PUSH
112247: EMPTY
112248: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
112249: LD_ADDR_VAR 0 7
112253: PUSH
112254: LD_VAR 0 3
112258: PPUSH
112259: LD_INT 0
112261: PPUSH
112262: CALL_OW 517
112266: ST_TO_ADDR
// if not list then
112267: LD_VAR 0 7
112271: NOT
112272: IFFALSE 112276
// exit ;
112274: GO 112443
// c := Count ( list [ 1 ] ) ;
112276: LD_ADDR_VAR 0 9
112280: PUSH
112281: LD_VAR 0 7
112285: PUSH
112286: LD_INT 1
112288: ARRAY
112289: PPUSH
112290: CALL 21326 0 1
112294: ST_TO_ADDR
// if amount > c then
112295: LD_VAR 0 2
112299: PUSH
112300: LD_VAR 0 9
112304: GREATER
112305: IFFALSE 112317
// amount := c ;
112307: LD_ADDR_VAR 0 2
112311: PUSH
112312: LD_VAR 0 9
112316: ST_TO_ADDR
// for i := 1 to amount do
112317: LD_ADDR_VAR 0 5
112321: PUSH
112322: DOUBLE
112323: LD_INT 1
112325: DEC
112326: ST_TO_ADDR
112327: LD_VAR 0 2
112331: PUSH
112332: FOR_TO
112333: IFFALSE 112391
// tmp := Replace ( tmp , i , [ list [ 1 ] [ i ] , list [ 2 ] [ i ] ] ) ;
112335: LD_ADDR_VAR 0 6
112339: PUSH
112340: LD_VAR 0 6
112344: PPUSH
112345: LD_VAR 0 5
112349: PPUSH
112350: LD_VAR 0 7
112354: PUSH
112355: LD_INT 1
112357: ARRAY
112358: PUSH
112359: LD_VAR 0 5
112363: ARRAY
112364: PUSH
112365: LD_VAR 0 7
112369: PUSH
112370: LD_INT 2
112372: ARRAY
112373: PUSH
112374: LD_VAR 0 5
112378: ARRAY
112379: PUSH
112380: EMPTY
112381: LIST
112382: LIST
112383: PPUSH
112384: CALL_OW 1
112388: ST_TO_ADDR
112389: GO 112332
112391: POP
112392: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
112393: LD_ADDR_EXP 174
112397: PUSH
112398: LD_EXP 174
112402: PPUSH
112403: LD_VAR 0 1
112407: PPUSH
112408: LD_VAR 0 6
112412: PPUSH
112413: CALL_OW 1
112417: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
112418: LD_ADDR_EXP 176
112422: PUSH
112423: LD_EXP 176
112427: PPUSH
112428: LD_VAR 0 1
112432: PPUSH
112433: LD_VAR 0 3
112437: PPUSH
112438: CALL_OW 1
112442: ST_TO_ADDR
// end ;
112443: LD_VAR 0 4
112447: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
112448: LD_INT 0
112450: PPUSH
// if not mc_bases [ base ] then
112451: LD_EXP 161
112455: PUSH
112456: LD_VAR 0 1
112460: ARRAY
112461: NOT
112462: IFFALSE 112466
// exit ;
112464: GO 112491
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
112466: LD_ADDR_EXP 166
112470: PUSH
112471: LD_EXP 166
112475: PPUSH
112476: LD_VAR 0 1
112480: PPUSH
112481: LD_VAR 0 2
112485: PPUSH
112486: CALL_OW 1
112490: ST_TO_ADDR
// end ;
112491: LD_VAR 0 3
112495: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
112496: LD_INT 0
112498: PPUSH
// if not mc_bases [ base ] then
112499: LD_EXP 161
112503: PUSH
112504: LD_VAR 0 1
112508: ARRAY
112509: NOT
112510: IFFALSE 112514
// exit ;
112512: GO 112551
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
112514: LD_ADDR_EXP 166
112518: PUSH
112519: LD_EXP 166
112523: PPUSH
112524: LD_VAR 0 1
112528: PPUSH
112529: LD_EXP 166
112533: PUSH
112534: LD_VAR 0 1
112538: ARRAY
112539: PUSH
112540: LD_VAR 0 2
112544: UNION
112545: PPUSH
112546: CALL_OW 1
112550: ST_TO_ADDR
// end ;
112551: LD_VAR 0 3
112555: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
112556: LD_INT 0
112558: PPUSH
// if not mc_bases [ base ] then
112559: LD_EXP 161
112563: PUSH
112564: LD_VAR 0 1
112568: ARRAY
112569: NOT
112570: IFFALSE 112574
// exit ;
112572: GO 112599
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
112574: LD_ADDR_EXP 182
112578: PUSH
112579: LD_EXP 182
112583: PPUSH
112584: LD_VAR 0 1
112588: PPUSH
112589: LD_VAR 0 2
112593: PPUSH
112594: CALL_OW 1
112598: ST_TO_ADDR
// end ;
112599: LD_VAR 0 3
112603: RET
// export function MC_InsertProduceList ( base , components ) ; begin
112604: LD_INT 0
112606: PPUSH
// if not mc_bases [ base ] then
112607: LD_EXP 161
112611: PUSH
112612: LD_VAR 0 1
112616: ARRAY
112617: NOT
112618: IFFALSE 112622
// exit ;
112620: GO 112659
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
112622: LD_ADDR_EXP 182
112626: PUSH
112627: LD_EXP 182
112631: PPUSH
112632: LD_VAR 0 1
112636: PPUSH
112637: LD_EXP 182
112641: PUSH
112642: LD_VAR 0 1
112646: ARRAY
112647: PUSH
112648: LD_VAR 0 2
112652: ADD
112653: PPUSH
112654: CALL_OW 1
112658: ST_TO_ADDR
// end ;
112659: LD_VAR 0 3
112663: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
112664: LD_INT 0
112666: PPUSH
// if not mc_bases [ base ] then
112667: LD_EXP 161
112671: PUSH
112672: LD_VAR 0 1
112676: ARRAY
112677: NOT
112678: IFFALSE 112682
// exit ;
112680: GO 112736
// mc_defender := Replace ( mc_defender , base , deflist ) ;
112682: LD_ADDR_EXP 183
112686: PUSH
112687: LD_EXP 183
112691: PPUSH
112692: LD_VAR 0 1
112696: PPUSH
112697: LD_VAR 0 2
112701: PPUSH
112702: CALL_OW 1
112706: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
112707: LD_ADDR_EXP 172
112711: PUSH
112712: LD_EXP 172
112716: PPUSH
112717: LD_VAR 0 1
112721: PPUSH
112722: LD_VAR 0 2
112726: PUSH
112727: LD_INT 0
112729: PLUS
112730: PPUSH
112731: CALL_OW 1
112735: ST_TO_ADDR
// end ;
112736: LD_VAR 0 3
112740: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
112741: LD_INT 0
112743: PPUSH
// if not mc_bases [ base ] then
112744: LD_EXP 161
112748: PUSH
112749: LD_VAR 0 1
112753: ARRAY
112754: NOT
112755: IFFALSE 112759
// exit ;
112757: GO 112784
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
112759: LD_ADDR_EXP 172
112763: PUSH
112764: LD_EXP 172
112768: PPUSH
112769: LD_VAR 0 1
112773: PPUSH
112774: LD_VAR 0 2
112778: PPUSH
112779: CALL_OW 1
112783: ST_TO_ADDR
// end ;
112784: LD_VAR 0 3
112788: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
112789: LD_INT 0
112791: PPUSH
112792: PPUSH
112793: PPUSH
112794: PPUSH
// if not mc_bases [ base ] then
112795: LD_EXP 161
112799: PUSH
112800: LD_VAR 0 1
112804: ARRAY
112805: NOT
112806: IFFALSE 112810
// exit ;
112808: GO 112875
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
112810: LD_ADDR_EXP 181
112814: PUSH
112815: LD_EXP 181
112819: PPUSH
112820: LD_VAR 0 1
112824: PUSH
112825: LD_EXP 181
112829: PUSH
112830: LD_VAR 0 1
112834: ARRAY
112835: PUSH
112836: LD_INT 1
112838: PLUS
112839: PUSH
112840: EMPTY
112841: LIST
112842: LIST
112843: PPUSH
112844: LD_VAR 0 1
112848: PUSH
112849: LD_VAR 0 2
112853: PUSH
112854: LD_VAR 0 3
112858: PUSH
112859: LD_VAR 0 4
112863: PUSH
112864: EMPTY
112865: LIST
112866: LIST
112867: LIST
112868: LIST
112869: PPUSH
112870: CALL 24186 0 3
112874: ST_TO_ADDR
// end ;
112875: LD_VAR 0 5
112879: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
112880: LD_INT 0
112882: PPUSH
// if not mc_bases [ base ] then
112883: LD_EXP 161
112887: PUSH
112888: LD_VAR 0 1
112892: ARRAY
112893: NOT
112894: IFFALSE 112898
// exit ;
112896: GO 112923
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
112898: LD_ADDR_EXP 198
112902: PUSH
112903: LD_EXP 198
112907: PPUSH
112908: LD_VAR 0 1
112912: PPUSH
112913: LD_VAR 0 2
112917: PPUSH
112918: CALL_OW 1
112922: ST_TO_ADDR
// end ;
112923: LD_VAR 0 3
112927: RET
// export function MC_GetMinesField ( base ) ; begin
112928: LD_INT 0
112930: PPUSH
// result := mc_mines [ base ] ;
112931: LD_ADDR_VAR 0 2
112935: PUSH
112936: LD_EXP 174
112940: PUSH
112941: LD_VAR 0 1
112945: ARRAY
112946: ST_TO_ADDR
// end ;
112947: LD_VAR 0 2
112951: RET
// export function MC_GetProduceList ( base ) ; begin
112952: LD_INT 0
112954: PPUSH
// result := mc_produce [ base ] ;
112955: LD_ADDR_VAR 0 2
112959: PUSH
112960: LD_EXP 182
112964: PUSH
112965: LD_VAR 0 1
112969: ARRAY
112970: ST_TO_ADDR
// end ;
112971: LD_VAR 0 2
112975: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
112976: LD_INT 0
112978: PPUSH
112979: PPUSH
// if not mc_bases then
112980: LD_EXP 161
112984: NOT
112985: IFFALSE 112989
// exit ;
112987: GO 113054
// if mc_bases [ base ] then
112989: LD_EXP 161
112993: PUSH
112994: LD_VAR 0 1
112998: ARRAY
112999: IFFALSE 113054
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
113001: LD_ADDR_VAR 0 3
113005: PUSH
113006: LD_EXP 161
113010: PUSH
113011: LD_VAR 0 1
113015: ARRAY
113016: PPUSH
113017: LD_INT 30
113019: PUSH
113020: LD_VAR 0 2
113024: PUSH
113025: EMPTY
113026: LIST
113027: LIST
113028: PPUSH
113029: CALL_OW 72
113033: ST_TO_ADDR
// if result then
113034: LD_VAR 0 3
113038: IFFALSE 113054
// result := result [ 1 ] ;
113040: LD_ADDR_VAR 0 3
113044: PUSH
113045: LD_VAR 0 3
113049: PUSH
113050: LD_INT 1
113052: ARRAY
113053: ST_TO_ADDR
// end ; end ;
113054: LD_VAR 0 3
113058: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
113059: LD_INT 0
113061: PPUSH
113062: PPUSH
// if not mc_bases then
113063: LD_EXP 161
113067: NOT
113068: IFFALSE 113072
// exit ;
113070: GO 113117
// if mc_bases [ base ] then
113072: LD_EXP 161
113076: PUSH
113077: LD_VAR 0 1
113081: ARRAY
113082: IFFALSE 113117
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
113084: LD_ADDR_VAR 0 3
113088: PUSH
113089: LD_EXP 161
113093: PUSH
113094: LD_VAR 0 1
113098: ARRAY
113099: PPUSH
113100: LD_INT 30
113102: PUSH
113103: LD_VAR 0 2
113107: PUSH
113108: EMPTY
113109: LIST
113110: LIST
113111: PPUSH
113112: CALL_OW 72
113116: ST_TO_ADDR
// end ;
113117: LD_VAR 0 3
113121: RET
// export function MC_SetTame ( base , area ) ; begin
113122: LD_INT 0
113124: PPUSH
// if not mc_bases or not base then
113125: LD_EXP 161
113129: NOT
113130: PUSH
113131: LD_VAR 0 1
113135: NOT
113136: OR
113137: IFFALSE 113141
// exit ;
113139: GO 113166
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
113141: LD_ADDR_EXP 189
113145: PUSH
113146: LD_EXP 189
113150: PPUSH
113151: LD_VAR 0 1
113155: PPUSH
113156: LD_VAR 0 2
113160: PPUSH
113161: CALL_OW 1
113165: ST_TO_ADDR
// end ;
113166: LD_VAR 0 3
113170: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
113171: LD_INT 0
113173: PPUSH
113174: PPUSH
// if not mc_bases or not base then
113175: LD_EXP 161
113179: NOT
113180: PUSH
113181: LD_VAR 0 1
113185: NOT
113186: OR
113187: IFFALSE 113191
// exit ;
113189: GO 113293
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
113191: LD_ADDR_VAR 0 4
113195: PUSH
113196: LD_EXP 161
113200: PUSH
113201: LD_VAR 0 1
113205: ARRAY
113206: PPUSH
113207: LD_INT 30
113209: PUSH
113210: LD_VAR 0 2
113214: PUSH
113215: EMPTY
113216: LIST
113217: LIST
113218: PPUSH
113219: CALL_OW 72
113223: ST_TO_ADDR
// if not tmp then
113224: LD_VAR 0 4
113228: NOT
113229: IFFALSE 113233
// exit ;
113231: GO 113293
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
113233: LD_ADDR_EXP 193
113237: PUSH
113238: LD_EXP 193
113242: PPUSH
113243: LD_VAR 0 1
113247: PPUSH
113248: LD_EXP 193
113252: PUSH
113253: LD_VAR 0 1
113257: ARRAY
113258: PPUSH
113259: LD_EXP 193
113263: PUSH
113264: LD_VAR 0 1
113268: ARRAY
113269: PUSH
113270: LD_INT 1
113272: PLUS
113273: PPUSH
113274: LD_VAR 0 4
113278: PUSH
113279: LD_INT 1
113281: ARRAY
113282: PPUSH
113283: CALL_OW 2
113287: PPUSH
113288: CALL_OW 1
113292: ST_TO_ADDR
// end ;
113293: LD_VAR 0 3
113297: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
113298: LD_INT 0
113300: PPUSH
113301: PPUSH
// if not mc_bases or not base or not kinds then
113302: LD_EXP 161
113306: NOT
113307: PUSH
113308: LD_VAR 0 1
113312: NOT
113313: OR
113314: PUSH
113315: LD_VAR 0 2
113319: NOT
113320: OR
113321: IFFALSE 113325
// exit ;
113323: GO 113386
// for i in kinds do
113325: LD_ADDR_VAR 0 4
113329: PUSH
113330: LD_VAR 0 2
113334: PUSH
113335: FOR_IN
113336: IFFALSE 113384
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
113338: LD_ADDR_EXP 195
113342: PUSH
113343: LD_EXP 195
113347: PPUSH
113348: LD_VAR 0 1
113352: PUSH
113353: LD_EXP 195
113357: PUSH
113358: LD_VAR 0 1
113362: ARRAY
113363: PUSH
113364: LD_INT 1
113366: PLUS
113367: PUSH
113368: EMPTY
113369: LIST
113370: LIST
113371: PPUSH
113372: LD_VAR 0 4
113376: PPUSH
113377: CALL 24186 0 3
113381: ST_TO_ADDR
113382: GO 113335
113384: POP
113385: POP
// end ;
113386: LD_VAR 0 3
113390: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
113391: LD_INT 0
113393: PPUSH
// if not mc_bases or not base or not areas then
113394: LD_EXP 161
113398: NOT
113399: PUSH
113400: LD_VAR 0 1
113404: NOT
113405: OR
113406: PUSH
113407: LD_VAR 0 2
113411: NOT
113412: OR
113413: IFFALSE 113417
// exit ;
113415: GO 113442
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
113417: LD_ADDR_EXP 179
113421: PUSH
113422: LD_EXP 179
113426: PPUSH
113427: LD_VAR 0 1
113431: PPUSH
113432: LD_VAR 0 2
113436: PPUSH
113437: CALL_OW 1
113441: ST_TO_ADDR
// end ;
113442: LD_VAR 0 3
113446: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
113447: LD_INT 0
113449: PPUSH
// if not mc_bases or not base or not teleports_exit then
113450: LD_EXP 161
113454: NOT
113455: PUSH
113456: LD_VAR 0 1
113460: NOT
113461: OR
113462: PUSH
113463: LD_VAR 0 2
113467: NOT
113468: OR
113469: IFFALSE 113473
// exit ;
113471: GO 113498
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
113473: LD_ADDR_EXP 196
113477: PUSH
113478: LD_EXP 196
113482: PPUSH
113483: LD_VAR 0 1
113487: PPUSH
113488: LD_VAR 0 2
113492: PPUSH
113493: CALL_OW 1
113497: ST_TO_ADDR
// end ;
113498: LD_VAR 0 3
113502: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
113503: LD_INT 0
113505: PPUSH
113506: PPUSH
113507: PPUSH
// if not mc_bases or not base or not ext_list then
113508: LD_EXP 161
113512: NOT
113513: PUSH
113514: LD_VAR 0 1
113518: NOT
113519: OR
113520: PUSH
113521: LD_VAR 0 5
113525: NOT
113526: OR
113527: IFFALSE 113531
// exit ;
113529: GO 113704
// tmp := GetFacExtXYD ( x , y , d ) ;
113531: LD_ADDR_VAR 0 8
113535: PUSH
113536: LD_VAR 0 2
113540: PPUSH
113541: LD_VAR 0 3
113545: PPUSH
113546: LD_VAR 0 4
113550: PPUSH
113551: CALL 54192 0 3
113555: ST_TO_ADDR
// if not tmp then
113556: LD_VAR 0 8
113560: NOT
113561: IFFALSE 113565
// exit ;
113563: GO 113704
// for i in tmp do
113565: LD_ADDR_VAR 0 7
113569: PUSH
113570: LD_VAR 0 8
113574: PUSH
113575: FOR_IN
113576: IFFALSE 113702
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
113578: LD_ADDR_EXP 166
113582: PUSH
113583: LD_EXP 166
113587: PPUSH
113588: LD_VAR 0 1
113592: PPUSH
113593: LD_EXP 166
113597: PUSH
113598: LD_VAR 0 1
113602: ARRAY
113603: PPUSH
113604: LD_EXP 166
113608: PUSH
113609: LD_VAR 0 1
113613: ARRAY
113614: PUSH
113615: LD_INT 1
113617: PLUS
113618: PPUSH
113619: LD_VAR 0 5
113623: PUSH
113624: LD_INT 1
113626: ARRAY
113627: PUSH
113628: LD_VAR 0 7
113632: PUSH
113633: LD_INT 1
113635: ARRAY
113636: PUSH
113637: LD_VAR 0 7
113641: PUSH
113642: LD_INT 2
113644: ARRAY
113645: PUSH
113646: LD_VAR 0 7
113650: PUSH
113651: LD_INT 3
113653: ARRAY
113654: PUSH
113655: EMPTY
113656: LIST
113657: LIST
113658: LIST
113659: LIST
113660: PPUSH
113661: CALL_OW 2
113665: PPUSH
113666: CALL_OW 1
113670: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
113671: LD_ADDR_VAR 0 5
113675: PUSH
113676: LD_VAR 0 5
113680: PPUSH
113681: LD_INT 1
113683: PPUSH
113684: CALL_OW 3
113688: ST_TO_ADDR
// if not ext_list then
113689: LD_VAR 0 5
113693: NOT
113694: IFFALSE 113700
// exit ;
113696: POP
113697: POP
113698: GO 113704
// end ;
113700: GO 113575
113702: POP
113703: POP
// end ;
113704: LD_VAR 0 6
113708: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
113709: LD_INT 0
113711: PPUSH
// if not mc_bases or not base or not weapon_list then
113712: LD_EXP 161
113716: NOT
113717: PUSH
113718: LD_VAR 0 1
113722: NOT
113723: OR
113724: PUSH
113725: LD_VAR 0 2
113729: NOT
113730: OR
113731: IFFALSE 113735
// exit ;
113733: GO 113760
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
113735: LD_ADDR_EXP 200
113739: PUSH
113740: LD_EXP 200
113744: PPUSH
113745: LD_VAR 0 1
113749: PPUSH
113750: LD_VAR 0 2
113754: PPUSH
113755: CALL_OW 1
113759: ST_TO_ADDR
// end ;
113760: LD_VAR 0 3
113764: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
113765: LD_INT 0
113767: PPUSH
// if not mc_bases or not base or not tech_list then
113768: LD_EXP 161
113772: NOT
113773: PUSH
113774: LD_VAR 0 1
113778: NOT
113779: OR
113780: PUSH
113781: LD_VAR 0 2
113785: NOT
113786: OR
113787: IFFALSE 113791
// exit ;
113789: GO 113816
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
113791: LD_ADDR_EXP 188
113795: PUSH
113796: LD_EXP 188
113800: PPUSH
113801: LD_VAR 0 1
113805: PPUSH
113806: LD_VAR 0 2
113810: PPUSH
113811: CALL_OW 1
113815: ST_TO_ADDR
// end ;
113816: LD_VAR 0 3
113820: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
113821: LD_INT 0
113823: PPUSH
// if not mc_bases or not parking_area or not base then
113824: LD_EXP 161
113828: NOT
113829: PUSH
113830: LD_VAR 0 2
113834: NOT
113835: OR
113836: PUSH
113837: LD_VAR 0 1
113841: NOT
113842: OR
113843: IFFALSE 113847
// exit ;
113845: GO 113872
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
113847: LD_ADDR_EXP 185
113851: PUSH
113852: LD_EXP 185
113856: PPUSH
113857: LD_VAR 0 1
113861: PPUSH
113862: LD_VAR 0 2
113866: PPUSH
113867: CALL_OW 1
113871: ST_TO_ADDR
// end ;
113872: LD_VAR 0 3
113876: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
113877: LD_INT 0
113879: PPUSH
// if not mc_bases or not base or not scan_area then
113880: LD_EXP 161
113884: NOT
113885: PUSH
113886: LD_VAR 0 1
113890: NOT
113891: OR
113892: PUSH
113893: LD_VAR 0 2
113897: NOT
113898: OR
113899: IFFALSE 113903
// exit ;
113901: GO 113928
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
113903: LD_ADDR_EXP 186
113907: PUSH
113908: LD_EXP 186
113912: PPUSH
113913: LD_VAR 0 1
113917: PPUSH
113918: LD_VAR 0 2
113922: PPUSH
113923: CALL_OW 1
113927: ST_TO_ADDR
// end ;
113928: LD_VAR 0 3
113932: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
113933: LD_INT 0
113935: PPUSH
113936: PPUSH
// if not mc_bases or not base then
113937: LD_EXP 161
113941: NOT
113942: PUSH
113943: LD_VAR 0 1
113947: NOT
113948: OR
113949: IFFALSE 113953
// exit ;
113951: GO 114017
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
113953: LD_ADDR_VAR 0 3
113957: PUSH
113958: LD_INT 1
113960: PUSH
113961: LD_INT 2
113963: PUSH
113964: LD_INT 3
113966: PUSH
113967: LD_INT 4
113969: PUSH
113970: LD_INT 11
113972: PUSH
113973: EMPTY
113974: LIST
113975: LIST
113976: LIST
113977: LIST
113978: LIST
113979: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
113980: LD_ADDR_EXP 188
113984: PUSH
113985: LD_EXP 188
113989: PPUSH
113990: LD_VAR 0 1
113994: PPUSH
113995: LD_EXP 188
113999: PUSH
114000: LD_VAR 0 1
114004: ARRAY
114005: PUSH
114006: LD_VAR 0 3
114010: DIFF
114011: PPUSH
114012: CALL_OW 1
114016: ST_TO_ADDR
// end ;
114017: LD_VAR 0 2
114021: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
114022: LD_INT 0
114024: PPUSH
// result := mc_vehicles [ base ] ;
114025: LD_ADDR_VAR 0 3
114029: PUSH
114030: LD_EXP 180
114034: PUSH
114035: LD_VAR 0 1
114039: ARRAY
114040: ST_TO_ADDR
// if onlyCombat then
114041: LD_VAR 0 2
114045: IFFALSE 114217
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
114047: LD_ADDR_VAR 0 3
114051: PUSH
114052: LD_VAR 0 3
114056: PUSH
114057: LD_VAR 0 3
114061: PPUSH
114062: LD_INT 2
114064: PUSH
114065: LD_INT 34
114067: PUSH
114068: LD_INT 12
114070: PUSH
114071: EMPTY
114072: LIST
114073: LIST
114074: PUSH
114075: LD_INT 34
114077: PUSH
114078: LD_INT 51
114080: PUSH
114081: EMPTY
114082: LIST
114083: LIST
114084: PUSH
114085: LD_INT 34
114087: PUSH
114088: LD_INT 89
114090: PUSH
114091: EMPTY
114092: LIST
114093: LIST
114094: PUSH
114095: LD_INT 34
114097: PUSH
114098: LD_INT 32
114100: PUSH
114101: EMPTY
114102: LIST
114103: LIST
114104: PUSH
114105: LD_INT 34
114107: PUSH
114108: LD_INT 13
114110: PUSH
114111: EMPTY
114112: LIST
114113: LIST
114114: PUSH
114115: LD_INT 34
114117: PUSH
114118: LD_INT 52
114120: PUSH
114121: EMPTY
114122: LIST
114123: LIST
114124: PUSH
114125: LD_INT 34
114127: PUSH
114128: LD_INT 88
114130: PUSH
114131: EMPTY
114132: LIST
114133: LIST
114134: PUSH
114135: LD_INT 34
114137: PUSH
114138: LD_INT 14
114140: PUSH
114141: EMPTY
114142: LIST
114143: LIST
114144: PUSH
114145: LD_INT 34
114147: PUSH
114148: LD_INT 53
114150: PUSH
114151: EMPTY
114152: LIST
114153: LIST
114154: PUSH
114155: LD_INT 34
114157: PUSH
114158: LD_INT 98
114160: PUSH
114161: EMPTY
114162: LIST
114163: LIST
114164: PUSH
114165: LD_INT 34
114167: PUSH
114168: LD_INT 31
114170: PUSH
114171: EMPTY
114172: LIST
114173: LIST
114174: PUSH
114175: LD_INT 34
114177: PUSH
114178: LD_INT 48
114180: PUSH
114181: EMPTY
114182: LIST
114183: LIST
114184: PUSH
114185: LD_INT 34
114187: PUSH
114188: LD_INT 8
114190: PUSH
114191: EMPTY
114192: LIST
114193: LIST
114194: PUSH
114195: EMPTY
114196: LIST
114197: LIST
114198: LIST
114199: LIST
114200: LIST
114201: LIST
114202: LIST
114203: LIST
114204: LIST
114205: LIST
114206: LIST
114207: LIST
114208: LIST
114209: LIST
114210: PPUSH
114211: CALL_OW 72
114215: DIFF
114216: ST_TO_ADDR
// end ; end_of_file
114217: LD_VAR 0 3
114221: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
114222: LD_INT 0
114224: PPUSH
114225: PPUSH
114226: PPUSH
// if not mc_bases or not skirmish then
114227: LD_EXP 161
114231: NOT
114232: PUSH
114233: LD_EXP 159
114237: NOT
114238: OR
114239: IFFALSE 114243
// exit ;
114241: GO 114408
// for i = 1 to mc_bases do
114243: LD_ADDR_VAR 0 4
114247: PUSH
114248: DOUBLE
114249: LD_INT 1
114251: DEC
114252: ST_TO_ADDR
114253: LD_EXP 161
114257: PUSH
114258: FOR_TO
114259: IFFALSE 114406
// begin if sci in mc_bases [ i ] then
114261: LD_VAR 0 2
114265: PUSH
114266: LD_EXP 161
114270: PUSH
114271: LD_VAR 0 4
114275: ARRAY
114276: IN
114277: IFFALSE 114404
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
114279: LD_ADDR_EXP 190
114283: PUSH
114284: LD_EXP 190
114288: PPUSH
114289: LD_VAR 0 4
114293: PUSH
114294: LD_EXP 190
114298: PUSH
114299: LD_VAR 0 4
114303: ARRAY
114304: PUSH
114305: LD_INT 1
114307: PLUS
114308: PUSH
114309: EMPTY
114310: LIST
114311: LIST
114312: PPUSH
114313: LD_VAR 0 1
114317: PPUSH
114318: CALL 24186 0 3
114322: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
114323: LD_ADDR_VAR 0 5
114327: PUSH
114328: LD_EXP 161
114332: PUSH
114333: LD_VAR 0 4
114337: ARRAY
114338: PPUSH
114339: LD_INT 2
114341: PUSH
114342: LD_INT 30
114344: PUSH
114345: LD_INT 0
114347: PUSH
114348: EMPTY
114349: LIST
114350: LIST
114351: PUSH
114352: LD_INT 30
114354: PUSH
114355: LD_INT 1
114357: PUSH
114358: EMPTY
114359: LIST
114360: LIST
114361: PUSH
114362: EMPTY
114363: LIST
114364: LIST
114365: LIST
114366: PPUSH
114367: CALL_OW 72
114371: PPUSH
114372: LD_VAR 0 1
114376: PPUSH
114377: CALL_OW 74
114381: ST_TO_ADDR
// if tmp then
114382: LD_VAR 0 5
114386: IFFALSE 114402
// ComStandNearbyBuilding ( ape , tmp ) ;
114388: LD_VAR 0 1
114392: PPUSH
114393: LD_VAR 0 5
114397: PPUSH
114398: CALL 20788 0 2
// break ;
114402: GO 114406
// end ; end ;
114404: GO 114258
114406: POP
114407: POP
// end ;
114408: LD_VAR 0 3
114412: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
114413: LD_INT 0
114415: PPUSH
114416: PPUSH
114417: PPUSH
// if not mc_bases or not skirmish then
114418: LD_EXP 161
114422: NOT
114423: PUSH
114424: LD_EXP 159
114428: NOT
114429: OR
114430: IFFALSE 114434
// exit ;
114432: GO 114523
// for i = 1 to mc_bases do
114434: LD_ADDR_VAR 0 4
114438: PUSH
114439: DOUBLE
114440: LD_INT 1
114442: DEC
114443: ST_TO_ADDR
114444: LD_EXP 161
114448: PUSH
114449: FOR_TO
114450: IFFALSE 114521
// begin if building in mc_busy_turret_list [ i ] then
114452: LD_VAR 0 1
114456: PUSH
114457: LD_EXP 171
114461: PUSH
114462: LD_VAR 0 4
114466: ARRAY
114467: IN
114468: IFFALSE 114519
// begin tmp := mc_busy_turret_list [ i ] diff building ;
114470: LD_ADDR_VAR 0 5
114474: PUSH
114475: LD_EXP 171
114479: PUSH
114480: LD_VAR 0 4
114484: ARRAY
114485: PUSH
114486: LD_VAR 0 1
114490: DIFF
114491: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
114492: LD_ADDR_EXP 171
114496: PUSH
114497: LD_EXP 171
114501: PPUSH
114502: LD_VAR 0 4
114506: PPUSH
114507: LD_VAR 0 5
114511: PPUSH
114512: CALL_OW 1
114516: ST_TO_ADDR
// break ;
114517: GO 114521
// end ; end ;
114519: GO 114449
114521: POP
114522: POP
// end ;
114523: LD_VAR 0 3
114527: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
114528: LD_INT 0
114530: PPUSH
114531: PPUSH
114532: PPUSH
// if not mc_bases or not skirmish then
114533: LD_EXP 161
114537: NOT
114538: PUSH
114539: LD_EXP 159
114543: NOT
114544: OR
114545: IFFALSE 114549
// exit ;
114547: GO 114748
// for i = 1 to mc_bases do
114549: LD_ADDR_VAR 0 5
114553: PUSH
114554: DOUBLE
114555: LD_INT 1
114557: DEC
114558: ST_TO_ADDR
114559: LD_EXP 161
114563: PUSH
114564: FOR_TO
114565: IFFALSE 114746
// if building in mc_bases [ i ] then
114567: LD_VAR 0 1
114571: PUSH
114572: LD_EXP 161
114576: PUSH
114577: LD_VAR 0 5
114581: ARRAY
114582: IN
114583: IFFALSE 114744
// begin tmp := mc_bases [ i ] diff building ;
114585: LD_ADDR_VAR 0 6
114589: PUSH
114590: LD_EXP 161
114594: PUSH
114595: LD_VAR 0 5
114599: ARRAY
114600: PUSH
114601: LD_VAR 0 1
114605: DIFF
114606: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
114607: LD_ADDR_EXP 161
114611: PUSH
114612: LD_EXP 161
114616: PPUSH
114617: LD_VAR 0 5
114621: PPUSH
114622: LD_VAR 0 6
114626: PPUSH
114627: CALL_OW 1
114631: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
114632: LD_VAR 0 1
114636: PUSH
114637: LD_EXP 169
114641: PUSH
114642: LD_VAR 0 5
114646: ARRAY
114647: IN
114648: IFFALSE 114687
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
114650: LD_ADDR_EXP 169
114654: PUSH
114655: LD_EXP 169
114659: PPUSH
114660: LD_VAR 0 5
114664: PPUSH
114665: LD_EXP 169
114669: PUSH
114670: LD_VAR 0 5
114674: ARRAY
114675: PUSH
114676: LD_VAR 0 1
114680: DIFF
114681: PPUSH
114682: CALL_OW 1
114686: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
114687: LD_VAR 0 1
114691: PUSH
114692: LD_EXP 170
114696: PUSH
114697: LD_VAR 0 5
114701: ARRAY
114702: IN
114703: IFFALSE 114742
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
114705: LD_ADDR_EXP 170
114709: PUSH
114710: LD_EXP 170
114714: PPUSH
114715: LD_VAR 0 5
114719: PPUSH
114720: LD_EXP 170
114724: PUSH
114725: LD_VAR 0 5
114729: ARRAY
114730: PUSH
114731: LD_VAR 0 1
114735: DIFF
114736: PPUSH
114737: CALL_OW 1
114741: ST_TO_ADDR
// break ;
114742: GO 114746
// end ;
114744: GO 114564
114746: POP
114747: POP
// end ;
114748: LD_VAR 0 4
114752: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
114753: LD_INT 0
114755: PPUSH
114756: PPUSH
114757: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
114758: LD_EXP 161
114762: NOT
114763: PUSH
114764: LD_EXP 159
114768: NOT
114769: OR
114770: PUSH
114771: LD_VAR 0 3
114775: PUSH
114776: LD_EXP 187
114780: IN
114781: NOT
114782: OR
114783: IFFALSE 114787
// exit ;
114785: GO 114910
// for i = 1 to mc_vehicles do
114787: LD_ADDR_VAR 0 6
114791: PUSH
114792: DOUBLE
114793: LD_INT 1
114795: DEC
114796: ST_TO_ADDR
114797: LD_EXP 180
114801: PUSH
114802: FOR_TO
114803: IFFALSE 114908
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
114805: LD_VAR 0 2
114809: PUSH
114810: LD_EXP 180
114814: PUSH
114815: LD_VAR 0 6
114819: ARRAY
114820: IN
114821: PUSH
114822: LD_VAR 0 1
114826: PUSH
114827: LD_EXP 180
114831: PUSH
114832: LD_VAR 0 6
114836: ARRAY
114837: IN
114838: OR
114839: IFFALSE 114906
// begin tmp := mc_vehicles [ i ] diff old ;
114841: LD_ADDR_VAR 0 7
114845: PUSH
114846: LD_EXP 180
114850: PUSH
114851: LD_VAR 0 6
114855: ARRAY
114856: PUSH
114857: LD_VAR 0 2
114861: DIFF
114862: ST_TO_ADDR
// tmp := tmp diff new ;
114863: LD_ADDR_VAR 0 7
114867: PUSH
114868: LD_VAR 0 7
114872: PUSH
114873: LD_VAR 0 1
114877: DIFF
114878: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
114879: LD_ADDR_EXP 180
114883: PUSH
114884: LD_EXP 180
114888: PPUSH
114889: LD_VAR 0 6
114893: PPUSH
114894: LD_VAR 0 7
114898: PPUSH
114899: CALL_OW 1
114903: ST_TO_ADDR
// break ;
114904: GO 114908
// end ;
114906: GO 114802
114908: POP
114909: POP
// end ;
114910: LD_VAR 0 5
114914: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
114915: LD_INT 0
114917: PPUSH
114918: PPUSH
114919: PPUSH
114920: PPUSH
// if not mc_bases or not skirmish then
114921: LD_EXP 161
114925: NOT
114926: PUSH
114927: LD_EXP 159
114931: NOT
114932: OR
114933: IFFALSE 114937
// exit ;
114935: GO 115357
// repeat wait ( 0 0$1 ) ;
114937: LD_INT 35
114939: PPUSH
114940: CALL_OW 67
// until not mc_block_vehicle_constructed_thread ;
114944: LD_EXP 205
114948: NOT
114949: IFFALSE 114937
// mc_block_vehicle_constructed_thread := true ;
114951: LD_ADDR_EXP 205
114955: PUSH
114956: LD_INT 1
114958: ST_TO_ADDR
// side := GetSide ( vehicle ) ;
114959: LD_ADDR_VAR 0 5
114963: PUSH
114964: LD_VAR 0 1
114968: PPUSH
114969: CALL_OW 255
114973: ST_TO_ADDR
// for i = 1 to mc_bases do
114974: LD_ADDR_VAR 0 4
114978: PUSH
114979: DOUBLE
114980: LD_INT 1
114982: DEC
114983: ST_TO_ADDR
114984: LD_EXP 161
114988: PUSH
114989: FOR_TO
114990: IFFALSE 115347
// begin if factory in mc_bases [ i ] then
114992: LD_VAR 0 2
114996: PUSH
114997: LD_EXP 161
115001: PUSH
115002: LD_VAR 0 4
115006: ARRAY
115007: IN
115008: IFFALSE 115345
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ar_crane , ru_siberium_rocket , us_siberium_rocket ] then
115010: LD_EXP 183
115014: PUSH
115015: LD_VAR 0 4
115019: ARRAY
115020: PUSH
115021: LD_EXP 172
115025: PUSH
115026: LD_VAR 0 4
115030: ARRAY
115031: LESS
115032: PUSH
115033: LD_VAR 0 1
115037: PPUSH
115038: CALL_OW 264
115042: PUSH
115043: LD_INT 31
115045: PUSH
115046: LD_INT 32
115048: PUSH
115049: LD_INT 51
115051: PUSH
115052: LD_INT 89
115054: PUSH
115055: LD_INT 12
115057: PUSH
115058: LD_INT 30
115060: PUSH
115061: LD_INT 98
115063: PUSH
115064: LD_INT 11
115066: PUSH
115067: LD_INT 53
115069: PUSH
115070: LD_INT 14
115072: PUSH
115073: LD_INT 91
115075: PUSH
115076: LD_INT 29
115078: PUSH
115079: LD_INT 99
115081: PUSH
115082: LD_INT 13
115084: PUSH
115085: LD_INT 52
115087: PUSH
115088: LD_INT 88
115090: PUSH
115091: LD_INT 48
115093: PUSH
115094: LD_INT 8
115096: PUSH
115097: EMPTY
115098: LIST
115099: LIST
115100: LIST
115101: LIST
115102: LIST
115103: LIST
115104: LIST
115105: LIST
115106: LIST
115107: LIST
115108: LIST
115109: LIST
115110: LIST
115111: LIST
115112: LIST
115113: LIST
115114: LIST
115115: LIST
115116: IN
115117: NOT
115118: AND
115119: IFFALSE 115167
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
115121: LD_ADDR_EXP 183
115125: PUSH
115126: LD_EXP 183
115130: PPUSH
115131: LD_VAR 0 4
115135: PUSH
115136: LD_EXP 183
115140: PUSH
115141: LD_VAR 0 4
115145: ARRAY
115146: PUSH
115147: LD_INT 1
115149: PLUS
115150: PUSH
115151: EMPTY
115152: LIST
115153: LIST
115154: PPUSH
115155: LD_VAR 0 1
115159: PPUSH
115160: CALL 24186 0 3
115164: ST_TO_ADDR
115165: GO 115211
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
115167: LD_ADDR_EXP 180
115171: PUSH
115172: LD_EXP 180
115176: PPUSH
115177: LD_VAR 0 4
115181: PUSH
115182: LD_EXP 180
115186: PUSH
115187: LD_VAR 0 4
115191: ARRAY
115192: PUSH
115193: LD_INT 1
115195: PLUS
115196: PUSH
115197: EMPTY
115198: LIST
115199: LIST
115200: PPUSH
115201: LD_VAR 0 1
115205: PPUSH
115206: CALL 24186 0 3
115210: ST_TO_ADDR
// mc_block_vehicle_constructed_thread := false ;
115211: LD_ADDR_EXP 205
115215: PUSH
115216: LD_INT 0
115218: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
115219: LD_VAR 0 1
115223: PPUSH
115224: CALL_OW 263
115228: PUSH
115229: LD_INT 2
115231: EQUAL
115232: IFFALSE 115261
// begin repeat wait ( 0 0$3 ) ;
115234: LD_INT 105
115236: PPUSH
115237: CALL_OW 67
// Connect ( vehicle ) ;
115241: LD_VAR 0 1
115245: PPUSH
115246: CALL 27164 0 1
// until IsControledBy ( vehicle ) ;
115250: LD_VAR 0 1
115254: PPUSH
115255: CALL_OW 312
115259: IFFALSE 115234
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
115261: LD_VAR 0 1
115265: PPUSH
115266: LD_EXP 185
115270: PUSH
115271: LD_VAR 0 4
115275: ARRAY
115276: PPUSH
115277: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
115281: LD_VAR 0 1
115285: PPUSH
115286: CALL_OW 263
115290: PUSH
115291: LD_INT 1
115293: NONEQUAL
115294: IFFALSE 115298
// break ;
115296: GO 115347
// repeat wait ( 0 0$1 ) ;
115298: LD_INT 35
115300: PPUSH
115301: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
115305: LD_VAR 0 1
115309: PPUSH
115310: LD_EXP 185
115314: PUSH
115315: LD_VAR 0 4
115319: ARRAY
115320: PPUSH
115321: CALL_OW 308
115325: IFFALSE 115298
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
115327: LD_VAR 0 1
115331: PPUSH
115332: CALL_OW 311
115336: PPUSH
115337: CALL_OW 121
// exit ;
115341: POP
115342: POP
115343: GO 115357
// end ; end ;
115345: GO 114989
115347: POP
115348: POP
// mc_block_vehicle_constructed_thread := false ;
115349: LD_ADDR_EXP 205
115353: PUSH
115354: LD_INT 0
115356: ST_TO_ADDR
// end ;
115357: LD_VAR 0 3
115361: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
115362: LD_INT 0
115364: PPUSH
115365: PPUSH
115366: PPUSH
115367: PPUSH
// if not mc_bases or not skirmish then
115368: LD_EXP 161
115372: NOT
115373: PUSH
115374: LD_EXP 159
115378: NOT
115379: OR
115380: IFFALSE 115384
// exit ;
115382: GO 115737
// repeat wait ( 0 0$1 ) ;
115384: LD_INT 35
115386: PPUSH
115387: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
115391: LD_VAR 0 2
115395: PPUSH
115396: LD_VAR 0 3
115400: PPUSH
115401: CALL_OW 284
115405: IFFALSE 115384
// if GetResourceTypeXY ( x , y ) = mat_artefact then
115407: LD_VAR 0 2
115411: PPUSH
115412: LD_VAR 0 3
115416: PPUSH
115417: CALL_OW 283
115421: PUSH
115422: LD_INT 4
115424: EQUAL
115425: IFFALSE 115429
// exit ;
115427: GO 115737
// for i = 1 to mc_bases do
115429: LD_ADDR_VAR 0 7
115433: PUSH
115434: DOUBLE
115435: LD_INT 1
115437: DEC
115438: ST_TO_ADDR
115439: LD_EXP 161
115443: PUSH
115444: FOR_TO
115445: IFFALSE 115735
// begin if mc_crates_area [ i ] then
115447: LD_EXP 179
115451: PUSH
115452: LD_VAR 0 7
115456: ARRAY
115457: IFFALSE 115568
// for j in mc_crates_area [ i ] do
115459: LD_ADDR_VAR 0 8
115463: PUSH
115464: LD_EXP 179
115468: PUSH
115469: LD_VAR 0 7
115473: ARRAY
115474: PUSH
115475: FOR_IN
115476: IFFALSE 115566
// if InArea ( x , y , j ) then
115478: LD_VAR 0 2
115482: PPUSH
115483: LD_VAR 0 3
115487: PPUSH
115488: LD_VAR 0 8
115492: PPUSH
115493: CALL_OW 309
115497: IFFALSE 115564
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
115499: LD_ADDR_EXP 177
115503: PUSH
115504: LD_EXP 177
115508: PPUSH
115509: LD_VAR 0 7
115513: PUSH
115514: LD_EXP 177
115518: PUSH
115519: LD_VAR 0 7
115523: ARRAY
115524: PUSH
115525: LD_INT 1
115527: PLUS
115528: PUSH
115529: EMPTY
115530: LIST
115531: LIST
115532: PPUSH
115533: LD_VAR 0 4
115537: PUSH
115538: LD_VAR 0 2
115542: PUSH
115543: LD_VAR 0 3
115547: PUSH
115548: EMPTY
115549: LIST
115550: LIST
115551: LIST
115552: PPUSH
115553: CALL 24186 0 3
115557: ST_TO_ADDR
// exit ;
115558: POP
115559: POP
115560: POP
115561: POP
115562: GO 115737
// end ;
115564: GO 115475
115566: POP
115567: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
115568: LD_ADDR_VAR 0 9
115572: PUSH
115573: LD_EXP 161
115577: PUSH
115578: LD_VAR 0 7
115582: ARRAY
115583: PPUSH
115584: LD_INT 2
115586: PUSH
115587: LD_INT 30
115589: PUSH
115590: LD_INT 0
115592: PUSH
115593: EMPTY
115594: LIST
115595: LIST
115596: PUSH
115597: LD_INT 30
115599: PUSH
115600: LD_INT 1
115602: PUSH
115603: EMPTY
115604: LIST
115605: LIST
115606: PUSH
115607: EMPTY
115608: LIST
115609: LIST
115610: LIST
115611: PPUSH
115612: CALL_OW 72
115616: ST_TO_ADDR
// if not depot then
115617: LD_VAR 0 9
115621: NOT
115622: IFFALSE 115626
// continue ;
115624: GO 115444
// for j in depot do
115626: LD_ADDR_VAR 0 8
115630: PUSH
115631: LD_VAR 0 9
115635: PUSH
115636: FOR_IN
115637: IFFALSE 115731
// if GetDistUnitXY ( j , x , y ) < 30 then
115639: LD_VAR 0 8
115643: PPUSH
115644: LD_VAR 0 2
115648: PPUSH
115649: LD_VAR 0 3
115653: PPUSH
115654: CALL_OW 297
115658: PUSH
115659: LD_INT 30
115661: LESS
115662: IFFALSE 115729
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
115664: LD_ADDR_EXP 177
115668: PUSH
115669: LD_EXP 177
115673: PPUSH
115674: LD_VAR 0 7
115678: PUSH
115679: LD_EXP 177
115683: PUSH
115684: LD_VAR 0 7
115688: ARRAY
115689: PUSH
115690: LD_INT 1
115692: PLUS
115693: PUSH
115694: EMPTY
115695: LIST
115696: LIST
115697: PPUSH
115698: LD_VAR 0 4
115702: PUSH
115703: LD_VAR 0 2
115707: PUSH
115708: LD_VAR 0 3
115712: PUSH
115713: EMPTY
115714: LIST
115715: LIST
115716: LIST
115717: PPUSH
115718: CALL 24186 0 3
115722: ST_TO_ADDR
// exit ;
115723: POP
115724: POP
115725: POP
115726: POP
115727: GO 115737
// end ;
115729: GO 115636
115731: POP
115732: POP
// end ;
115733: GO 115444
115735: POP
115736: POP
// end ;
115737: LD_VAR 0 6
115741: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
115742: LD_INT 0
115744: PPUSH
115745: PPUSH
115746: PPUSH
115747: PPUSH
// if not mc_bases or not skirmish then
115748: LD_EXP 161
115752: NOT
115753: PUSH
115754: LD_EXP 159
115758: NOT
115759: OR
115760: IFFALSE 115764
// exit ;
115762: GO 116041
// side := GetSide ( lab ) ;
115764: LD_ADDR_VAR 0 4
115768: PUSH
115769: LD_VAR 0 2
115773: PPUSH
115774: CALL_OW 255
115778: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
115779: LD_VAR 0 4
115783: PUSH
115784: LD_EXP 187
115788: IN
115789: NOT
115790: PUSH
115791: LD_EXP 188
115795: NOT
115796: OR
115797: PUSH
115798: LD_EXP 161
115802: NOT
115803: OR
115804: IFFALSE 115808
// exit ;
115806: GO 116041
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
115808: LD_ADDR_EXP 188
115812: PUSH
115813: LD_EXP 188
115817: PPUSH
115818: LD_VAR 0 4
115822: PPUSH
115823: LD_EXP 188
115827: PUSH
115828: LD_VAR 0 4
115832: ARRAY
115833: PUSH
115834: LD_VAR 0 1
115838: DIFF
115839: PPUSH
115840: CALL_OW 1
115844: ST_TO_ADDR
// for i = 1 to mc_bases do
115845: LD_ADDR_VAR 0 5
115849: PUSH
115850: DOUBLE
115851: LD_INT 1
115853: DEC
115854: ST_TO_ADDR
115855: LD_EXP 161
115859: PUSH
115860: FOR_TO
115861: IFFALSE 116039
// begin if lab in mc_bases [ i ] then
115863: LD_VAR 0 2
115867: PUSH
115868: LD_EXP 161
115872: PUSH
115873: LD_VAR 0 5
115877: ARRAY
115878: IN
115879: IFFALSE 116037
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
115881: LD_VAR 0 1
115885: PUSH
115886: LD_INT 11
115888: PUSH
115889: LD_INT 4
115891: PUSH
115892: LD_INT 3
115894: PUSH
115895: LD_INT 2
115897: PUSH
115898: EMPTY
115899: LIST
115900: LIST
115901: LIST
115902: LIST
115903: IN
115904: PUSH
115905: LD_EXP 191
115909: PUSH
115910: LD_VAR 0 5
115914: ARRAY
115915: AND
115916: IFFALSE 116037
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
115918: LD_ADDR_VAR 0 6
115922: PUSH
115923: LD_EXP 191
115927: PUSH
115928: LD_VAR 0 5
115932: ARRAY
115933: PUSH
115934: LD_INT 1
115936: ARRAY
115937: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
115938: LD_ADDR_EXP 191
115942: PUSH
115943: LD_EXP 191
115947: PPUSH
115948: LD_VAR 0 5
115952: PPUSH
115953: EMPTY
115954: PPUSH
115955: CALL_OW 1
115959: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
115960: LD_VAR 0 6
115964: PPUSH
115965: LD_INT 0
115967: PPUSH
115968: CALL_OW 109
// ComExitBuilding ( tmp ) ;
115972: LD_VAR 0 6
115976: PPUSH
115977: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
115981: LD_ADDR_EXP 190
115985: PUSH
115986: LD_EXP 190
115990: PPUSH
115991: LD_VAR 0 5
115995: PPUSH
115996: LD_EXP 190
116000: PUSH
116001: LD_VAR 0 5
116005: ARRAY
116006: PPUSH
116007: LD_INT 1
116009: PPUSH
116010: LD_VAR 0 6
116014: PPUSH
116015: CALL_OW 2
116019: PPUSH
116020: CALL_OW 1
116024: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
116025: LD_VAR 0 5
116029: PPUSH
116030: LD_INT 112
116032: PPUSH
116033: CALL 92491 0 2
// end ; end ; end ;
116037: GO 115860
116039: POP
116040: POP
// end ;
116041: LD_VAR 0 3
116045: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
116046: LD_INT 0
116048: PPUSH
116049: PPUSH
116050: PPUSH
116051: PPUSH
116052: PPUSH
116053: PPUSH
116054: PPUSH
116055: PPUSH
// if not mc_bases or not skirmish then
116056: LD_EXP 161
116060: NOT
116061: PUSH
116062: LD_EXP 159
116066: NOT
116067: OR
116068: IFFALSE 116072
// exit ;
116070: GO 117441
// for i = 1 to mc_bases do
116072: LD_ADDR_VAR 0 3
116076: PUSH
116077: DOUBLE
116078: LD_INT 1
116080: DEC
116081: ST_TO_ADDR
116082: LD_EXP 161
116086: PUSH
116087: FOR_TO
116088: IFFALSE 117439
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
116090: LD_VAR 0 1
116094: PUSH
116095: LD_EXP 161
116099: PUSH
116100: LD_VAR 0 3
116104: ARRAY
116105: IN
116106: PUSH
116107: LD_VAR 0 1
116111: PUSH
116112: LD_EXP 168
116116: PUSH
116117: LD_VAR 0 3
116121: ARRAY
116122: IN
116123: OR
116124: PUSH
116125: LD_VAR 0 1
116129: PUSH
116130: LD_EXP 183
116134: PUSH
116135: LD_VAR 0 3
116139: ARRAY
116140: IN
116141: OR
116142: PUSH
116143: LD_VAR 0 1
116147: PUSH
116148: LD_EXP 180
116152: PUSH
116153: LD_VAR 0 3
116157: ARRAY
116158: IN
116159: OR
116160: PUSH
116161: LD_VAR 0 1
116165: PUSH
116166: LD_EXP 190
116170: PUSH
116171: LD_VAR 0 3
116175: ARRAY
116176: IN
116177: OR
116178: PUSH
116179: LD_VAR 0 1
116183: PUSH
116184: LD_EXP 191
116188: PUSH
116189: LD_VAR 0 3
116193: ARRAY
116194: IN
116195: OR
116196: IFFALSE 117437
// begin if un in mc_ape [ i ] then
116198: LD_VAR 0 1
116202: PUSH
116203: LD_EXP 190
116207: PUSH
116208: LD_VAR 0 3
116212: ARRAY
116213: IN
116214: IFFALSE 116253
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
116216: LD_ADDR_EXP 190
116220: PUSH
116221: LD_EXP 190
116225: PPUSH
116226: LD_VAR 0 3
116230: PPUSH
116231: LD_EXP 190
116235: PUSH
116236: LD_VAR 0 3
116240: ARRAY
116241: PUSH
116242: LD_VAR 0 1
116246: DIFF
116247: PPUSH
116248: CALL_OW 1
116252: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
116253: LD_VAR 0 1
116257: PUSH
116258: LD_EXP 191
116262: PUSH
116263: LD_VAR 0 3
116267: ARRAY
116268: IN
116269: IFFALSE 116293
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
116271: LD_ADDR_EXP 191
116275: PUSH
116276: LD_EXP 191
116280: PPUSH
116281: LD_VAR 0 3
116285: PPUSH
116286: EMPTY
116287: PPUSH
116288: CALL_OW 1
116292: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane , ar_control_tower ] ) then
116293: LD_VAR 0 1
116297: PPUSH
116298: CALL_OW 247
116302: PUSH
116303: LD_INT 2
116305: EQUAL
116306: PUSH
116307: LD_VAR 0 1
116311: PPUSH
116312: CALL_OW 110
116316: PUSH
116317: LD_INT 20
116319: EQUAL
116320: PUSH
116321: LD_VAR 0 1
116325: PUSH
116326: LD_EXP 183
116330: PUSH
116331: LD_VAR 0 3
116335: ARRAY
116336: IN
116337: OR
116338: PUSH
116339: LD_VAR 0 1
116343: PPUSH
116344: CALL_OW 264
116348: PUSH
116349: LD_INT 12
116351: PUSH
116352: LD_INT 51
116354: PUSH
116355: LD_INT 89
116357: PUSH
116358: LD_INT 32
116360: PUSH
116361: LD_INT 13
116363: PUSH
116364: LD_INT 52
116366: PUSH
116367: LD_INT 31
116369: PUSH
116370: EMPTY
116371: LIST
116372: LIST
116373: LIST
116374: LIST
116375: LIST
116376: LIST
116377: LIST
116378: IN
116379: OR
116380: AND
116381: IFFALSE 116689
// begin if un in mc_defender [ i ] then
116383: LD_VAR 0 1
116387: PUSH
116388: LD_EXP 183
116392: PUSH
116393: LD_VAR 0 3
116397: ARRAY
116398: IN
116399: IFFALSE 116438
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
116401: LD_ADDR_EXP 183
116405: PUSH
116406: LD_EXP 183
116410: PPUSH
116411: LD_VAR 0 3
116415: PPUSH
116416: LD_EXP 183
116420: PUSH
116421: LD_VAR 0 3
116425: ARRAY
116426: PUSH
116427: LD_VAR 0 1
116431: DIFF
116432: PPUSH
116433: CALL_OW 1
116437: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
116438: LD_ADDR_VAR 0 8
116442: PUSH
116443: LD_VAR 0 3
116447: PPUSH
116448: LD_INT 3
116450: PPUSH
116451: CALL 113059 0 2
116455: ST_TO_ADDR
// if fac then
116456: LD_VAR 0 8
116460: IFFALSE 116689
// begin for j in fac do
116462: LD_ADDR_VAR 0 4
116466: PUSH
116467: LD_VAR 0 8
116471: PUSH
116472: FOR_IN
116473: IFFALSE 116687
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
116475: LD_ADDR_VAR 0 9
116479: PUSH
116480: LD_VAR 0 8
116484: PPUSH
116485: LD_VAR 0 1
116489: PPUSH
116490: CALL_OW 265
116494: PPUSH
116495: LD_VAR 0 1
116499: PPUSH
116500: CALL_OW 262
116504: PPUSH
116505: LD_VAR 0 1
116509: PPUSH
116510: CALL_OW 263
116514: PPUSH
116515: LD_VAR 0 1
116519: PPUSH
116520: CALL_OW 264
116524: PPUSH
116525: CALL 21684 0 5
116529: ST_TO_ADDR
// if components then
116530: LD_VAR 0 9
116534: IFFALSE 116685
// begin if GetWeapon ( un ) = ar_control_tower then
116536: LD_VAR 0 1
116540: PPUSH
116541: CALL_OW 264
116545: PUSH
116546: LD_INT 31
116548: EQUAL
116549: IFFALSE 116666
// begin SetTag ( IsDrivenBy ( un ) , 0 ) ;
116551: LD_VAR 0 1
116555: PPUSH
116556: CALL_OW 311
116560: PPUSH
116561: LD_INT 0
116563: PPUSH
116564: CALL_OW 109
// mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff IsDrivenBy ( un ) ) ;
116568: LD_ADDR_EXP 201
116572: PUSH
116573: LD_EXP 201
116577: PPUSH
116578: LD_VAR 0 3
116582: PPUSH
116583: LD_EXP 201
116587: PUSH
116588: LD_VAR 0 3
116592: ARRAY
116593: PUSH
116594: LD_VAR 0 1
116598: PPUSH
116599: CALL_OW 311
116603: DIFF
116604: PPUSH
116605: CALL_OW 1
116609: ST_TO_ADDR
// tmp := Insert ( mc_produce [ i ] , 1 , components ) ;
116610: LD_ADDR_VAR 0 7
116614: PUSH
116615: LD_EXP 182
116619: PUSH
116620: LD_VAR 0 3
116624: ARRAY
116625: PPUSH
116626: LD_INT 1
116628: PPUSH
116629: LD_VAR 0 9
116633: PPUSH
116634: CALL_OW 2
116638: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
116639: LD_ADDR_EXP 182
116643: PUSH
116644: LD_EXP 182
116648: PPUSH
116649: LD_VAR 0 3
116653: PPUSH
116654: LD_VAR 0 7
116658: PPUSH
116659: CALL_OW 1
116663: ST_TO_ADDR
// end else
116664: GO 116683
// MC_InsertProduceList ( i , [ components ] ) ;
116666: LD_VAR 0 3
116670: PPUSH
116671: LD_VAR 0 9
116675: PUSH
116676: EMPTY
116677: LIST
116678: PPUSH
116679: CALL 112604 0 2
// break ;
116683: GO 116687
// end ; end ;
116685: GO 116472
116687: POP
116688: POP
// end ; end ; if GetType ( un ) = unit_building then
116689: LD_VAR 0 1
116693: PPUSH
116694: CALL_OW 247
116698: PUSH
116699: LD_INT 3
116701: EQUAL
116702: IFFALSE 117105
// begin btype := GetBType ( un ) ;
116704: LD_ADDR_VAR 0 5
116708: PUSH
116709: LD_VAR 0 1
116713: PPUSH
116714: CALL_OW 266
116718: ST_TO_ADDR
// if btype in [ b_oil_mine , b_siberite_mine ] then
116719: LD_VAR 0 5
116723: PUSH
116724: LD_INT 29
116726: PUSH
116727: LD_INT 30
116729: PUSH
116730: EMPTY
116731: LIST
116732: LIST
116733: IN
116734: IFFALSE 116807
// begin if not GetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) then
116736: LD_VAR 0 1
116740: PPUSH
116741: CALL_OW 250
116745: PPUSH
116746: LD_VAR 0 1
116750: PPUSH
116751: CALL_OW 251
116755: PPUSH
116756: LD_VAR 0 1
116760: PPUSH
116761: CALL_OW 255
116765: PPUSH
116766: CALL_OW 440
116770: NOT
116771: IFFALSE 116807
// SetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) ;
116773: LD_VAR 0 1
116777: PPUSH
116778: CALL_OW 250
116782: PPUSH
116783: LD_VAR 0 1
116787: PPUSH
116788: CALL_OW 251
116792: PPUSH
116793: LD_VAR 0 1
116797: PPUSH
116798: CALL_OW 255
116802: PPUSH
116803: CALL_OW 441
// end ; if btype = b_warehouse then
116807: LD_VAR 0 5
116811: PUSH
116812: LD_INT 1
116814: EQUAL
116815: IFFALSE 116833
// begin btype := b_depot ;
116817: LD_ADDR_VAR 0 5
116821: PUSH
116822: LD_INT 0
116824: ST_TO_ADDR
// pos := 1 ;
116825: LD_ADDR_VAR 0 6
116829: PUSH
116830: LD_INT 1
116832: ST_TO_ADDR
// end ; if btype = b_factory then
116833: LD_VAR 0 5
116837: PUSH
116838: LD_INT 3
116840: EQUAL
116841: IFFALSE 116859
// begin btype := b_workshop ;
116843: LD_ADDR_VAR 0 5
116847: PUSH
116848: LD_INT 2
116850: ST_TO_ADDR
// pos := 1 ;
116851: LD_ADDR_VAR 0 6
116855: PUSH
116856: LD_INT 1
116858: ST_TO_ADDR
// end ; if btype = b_barracks then
116859: LD_VAR 0 5
116863: PUSH
116864: LD_INT 5
116866: EQUAL
116867: IFFALSE 116877
// btype := b_armoury ;
116869: LD_ADDR_VAR 0 5
116873: PUSH
116874: LD_INT 4
116876: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
116877: LD_VAR 0 5
116881: PUSH
116882: LD_INT 7
116884: PUSH
116885: LD_INT 8
116887: PUSH
116888: EMPTY
116889: LIST
116890: LIST
116891: IN
116892: IFFALSE 116902
// btype := b_lab ;
116894: LD_ADDR_VAR 0 5
116898: PUSH
116899: LD_INT 6
116901: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
116902: LD_ADDR_EXP 166
116906: PUSH
116907: LD_EXP 166
116911: PPUSH
116912: LD_VAR 0 3
116916: PUSH
116917: LD_EXP 166
116921: PUSH
116922: LD_VAR 0 3
116926: ARRAY
116927: PUSH
116928: LD_INT 1
116930: PLUS
116931: PUSH
116932: EMPTY
116933: LIST
116934: LIST
116935: PPUSH
116936: LD_VAR 0 5
116940: PUSH
116941: LD_VAR 0 1
116945: PPUSH
116946: CALL_OW 250
116950: PUSH
116951: LD_VAR 0 1
116955: PPUSH
116956: CALL_OW 251
116960: PUSH
116961: LD_VAR 0 1
116965: PPUSH
116966: CALL_OW 254
116970: PUSH
116971: EMPTY
116972: LIST
116973: LIST
116974: LIST
116975: LIST
116976: PPUSH
116977: CALL 24186 0 3
116981: ST_TO_ADDR
// if pos = 1 then
116982: LD_VAR 0 6
116986: PUSH
116987: LD_INT 1
116989: EQUAL
116990: IFFALSE 117105
// begin tmp := mc_build_list [ i ] ;
116992: LD_ADDR_VAR 0 7
116996: PUSH
116997: LD_EXP 166
117001: PUSH
117002: LD_VAR 0 3
117006: ARRAY
117007: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
117008: LD_VAR 0 7
117012: PPUSH
117013: LD_INT 2
117015: PUSH
117016: LD_INT 30
117018: PUSH
117019: LD_INT 0
117021: PUSH
117022: EMPTY
117023: LIST
117024: LIST
117025: PUSH
117026: LD_INT 30
117028: PUSH
117029: LD_INT 1
117031: PUSH
117032: EMPTY
117033: LIST
117034: LIST
117035: PUSH
117036: EMPTY
117037: LIST
117038: LIST
117039: LIST
117040: PPUSH
117041: CALL_OW 72
117045: IFFALSE 117055
// pos := 2 ;
117047: LD_ADDR_VAR 0 6
117051: PUSH
117052: LD_INT 2
117054: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
117055: LD_ADDR_VAR 0 7
117059: PUSH
117060: LD_VAR 0 7
117064: PPUSH
117065: LD_VAR 0 6
117069: PPUSH
117070: LD_VAR 0 7
117074: PPUSH
117075: CALL 24512 0 3
117079: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
117080: LD_ADDR_EXP 166
117084: PUSH
117085: LD_EXP 166
117089: PPUSH
117090: LD_VAR 0 3
117094: PPUSH
117095: LD_VAR 0 7
117099: PPUSH
117100: CALL_OW 1
117104: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
117105: LD_VAR 0 1
117109: PUSH
117110: LD_EXP 161
117114: PUSH
117115: LD_VAR 0 3
117119: ARRAY
117120: IN
117121: IFFALSE 117160
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
117123: LD_ADDR_EXP 161
117127: PUSH
117128: LD_EXP 161
117132: PPUSH
117133: LD_VAR 0 3
117137: PPUSH
117138: LD_EXP 161
117142: PUSH
117143: LD_VAR 0 3
117147: ARRAY
117148: PUSH
117149: LD_VAR 0 1
117153: DIFF
117154: PPUSH
117155: CALL_OW 1
117159: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
117160: LD_VAR 0 1
117164: PUSH
117165: LD_EXP 168
117169: PUSH
117170: LD_VAR 0 3
117174: ARRAY
117175: IN
117176: IFFALSE 117215
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
117178: LD_ADDR_EXP 168
117182: PUSH
117183: LD_EXP 168
117187: PPUSH
117188: LD_VAR 0 3
117192: PPUSH
117193: LD_EXP 168
117197: PUSH
117198: LD_VAR 0 3
117202: ARRAY
117203: PUSH
117204: LD_VAR 0 1
117208: DIFF
117209: PPUSH
117210: CALL_OW 1
117214: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
117215: LD_VAR 0 1
117219: PUSH
117220: LD_EXP 180
117224: PUSH
117225: LD_VAR 0 3
117229: ARRAY
117230: IN
117231: IFFALSE 117270
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
117233: LD_ADDR_EXP 180
117237: PUSH
117238: LD_EXP 180
117242: PPUSH
117243: LD_VAR 0 3
117247: PPUSH
117248: LD_EXP 180
117252: PUSH
117253: LD_VAR 0 3
117257: ARRAY
117258: PUSH
117259: LD_VAR 0 1
117263: DIFF
117264: PPUSH
117265: CALL_OW 1
117269: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
117270: LD_VAR 0 1
117274: PUSH
117275: LD_EXP 183
117279: PUSH
117280: LD_VAR 0 3
117284: ARRAY
117285: IN
117286: IFFALSE 117325
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
117288: LD_ADDR_EXP 183
117292: PUSH
117293: LD_EXP 183
117297: PPUSH
117298: LD_VAR 0 3
117302: PPUSH
117303: LD_EXP 183
117307: PUSH
117308: LD_VAR 0 3
117312: ARRAY
117313: PUSH
117314: LD_VAR 0 1
117318: DIFF
117319: PPUSH
117320: CALL_OW 1
117324: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
117325: LD_VAR 0 1
117329: PUSH
117330: LD_EXP 170
117334: PUSH
117335: LD_VAR 0 3
117339: ARRAY
117340: IN
117341: IFFALSE 117380
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
117343: LD_ADDR_EXP 170
117347: PUSH
117348: LD_EXP 170
117352: PPUSH
117353: LD_VAR 0 3
117357: PPUSH
117358: LD_EXP 170
117362: PUSH
117363: LD_VAR 0 3
117367: ARRAY
117368: PUSH
117369: LD_VAR 0 1
117373: DIFF
117374: PPUSH
117375: CALL_OW 1
117379: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
117380: LD_VAR 0 1
117384: PUSH
117385: LD_EXP 169
117389: PUSH
117390: LD_VAR 0 3
117394: ARRAY
117395: IN
117396: IFFALSE 117435
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
117398: LD_ADDR_EXP 169
117402: PUSH
117403: LD_EXP 169
117407: PPUSH
117408: LD_VAR 0 3
117412: PPUSH
117413: LD_EXP 169
117417: PUSH
117418: LD_VAR 0 3
117422: ARRAY
117423: PUSH
117424: LD_VAR 0 1
117428: DIFF
117429: PPUSH
117430: CALL_OW 1
117434: ST_TO_ADDR
// end ; break ;
117435: GO 117439
// end ;
117437: GO 116087
117439: POP
117440: POP
// end ;
117441: LD_VAR 0 2
117445: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
117446: LD_INT 0
117448: PPUSH
117449: PPUSH
117450: PPUSH
// if not mc_bases or not skirmish then
117451: LD_EXP 161
117455: NOT
117456: PUSH
117457: LD_EXP 159
117461: NOT
117462: OR
117463: IFFALSE 117467
// exit ;
117465: GO 117682
// for i = 1 to mc_bases do
117467: LD_ADDR_VAR 0 3
117471: PUSH
117472: DOUBLE
117473: LD_INT 1
117475: DEC
117476: ST_TO_ADDR
117477: LD_EXP 161
117481: PUSH
117482: FOR_TO
117483: IFFALSE 117680
// begin if building in mc_construct_list [ i ] then
117485: LD_VAR 0 1
117489: PUSH
117490: LD_EXP 168
117494: PUSH
117495: LD_VAR 0 3
117499: ARRAY
117500: IN
117501: IFFALSE 117678
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
117503: LD_ADDR_EXP 168
117507: PUSH
117508: LD_EXP 168
117512: PPUSH
117513: LD_VAR 0 3
117517: PPUSH
117518: LD_EXP 168
117522: PUSH
117523: LD_VAR 0 3
117527: ARRAY
117528: PUSH
117529: LD_VAR 0 1
117533: DIFF
117534: PPUSH
117535: CALL_OW 1
117539: ST_TO_ADDR
// if building in mc_lab [ i ] then
117540: LD_VAR 0 1
117544: PUSH
117545: LD_EXP 194
117549: PUSH
117550: LD_VAR 0 3
117554: ARRAY
117555: IN
117556: IFFALSE 117611
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
117558: LD_ADDR_EXP 195
117562: PUSH
117563: LD_EXP 195
117567: PPUSH
117568: LD_VAR 0 3
117572: PPUSH
117573: LD_EXP 195
117577: PUSH
117578: LD_VAR 0 3
117582: ARRAY
117583: PPUSH
117584: LD_INT 1
117586: PPUSH
117587: LD_EXP 195
117591: PUSH
117592: LD_VAR 0 3
117596: ARRAY
117597: PPUSH
117598: LD_INT 0
117600: PPUSH
117601: CALL 23604 0 4
117605: PPUSH
117606: CALL_OW 1
117610: ST_TO_ADDR
// if not building in mc_bases [ i ] then
117611: LD_VAR 0 1
117615: PUSH
117616: LD_EXP 161
117620: PUSH
117621: LD_VAR 0 3
117625: ARRAY
117626: IN
117627: NOT
117628: IFFALSE 117674
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
117630: LD_ADDR_EXP 161
117634: PUSH
117635: LD_EXP 161
117639: PPUSH
117640: LD_VAR 0 3
117644: PUSH
117645: LD_EXP 161
117649: PUSH
117650: LD_VAR 0 3
117654: ARRAY
117655: PUSH
117656: LD_INT 1
117658: PLUS
117659: PUSH
117660: EMPTY
117661: LIST
117662: LIST
117663: PPUSH
117664: LD_VAR 0 1
117668: PPUSH
117669: CALL 24186 0 3
117673: ST_TO_ADDR
// exit ;
117674: POP
117675: POP
117676: GO 117682
// end ; end ;
117678: GO 117482
117680: POP
117681: POP
// end ;
117682: LD_VAR 0 2
117686: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
117687: LD_INT 0
117689: PPUSH
117690: PPUSH
117691: PPUSH
117692: PPUSH
117693: PPUSH
117694: PPUSH
117695: PPUSH
// if not mc_bases or not skirmish then
117696: LD_EXP 161
117700: NOT
117701: PUSH
117702: LD_EXP 159
117706: NOT
117707: OR
117708: IFFALSE 117712
// exit ;
117710: GO 118373
// for i = 1 to mc_bases do
117712: LD_ADDR_VAR 0 3
117716: PUSH
117717: DOUBLE
117718: LD_INT 1
117720: DEC
117721: ST_TO_ADDR
117722: LD_EXP 161
117726: PUSH
117727: FOR_TO
117728: IFFALSE 118371
// begin if building in mc_construct_list [ i ] then
117730: LD_VAR 0 1
117734: PUSH
117735: LD_EXP 168
117739: PUSH
117740: LD_VAR 0 3
117744: ARRAY
117745: IN
117746: IFFALSE 118369
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
117748: LD_ADDR_EXP 168
117752: PUSH
117753: LD_EXP 168
117757: PPUSH
117758: LD_VAR 0 3
117762: PPUSH
117763: LD_EXP 168
117767: PUSH
117768: LD_VAR 0 3
117772: ARRAY
117773: PUSH
117774: LD_VAR 0 1
117778: DIFF
117779: PPUSH
117780: CALL_OW 1
117784: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
117785: LD_ADDR_EXP 161
117789: PUSH
117790: LD_EXP 161
117794: PPUSH
117795: LD_VAR 0 3
117799: PUSH
117800: LD_EXP 161
117804: PUSH
117805: LD_VAR 0 3
117809: ARRAY
117810: PUSH
117811: LD_INT 1
117813: PLUS
117814: PUSH
117815: EMPTY
117816: LIST
117817: LIST
117818: PPUSH
117819: LD_VAR 0 1
117823: PPUSH
117824: CALL 24186 0 3
117828: ST_TO_ADDR
// btype := GetBType ( building ) ;
117829: LD_ADDR_VAR 0 5
117833: PUSH
117834: LD_VAR 0 1
117838: PPUSH
117839: CALL_OW 266
117843: ST_TO_ADDR
// side := GetSide ( building ) ;
117844: LD_ADDR_VAR 0 8
117848: PUSH
117849: LD_VAR 0 1
117853: PPUSH
117854: CALL_OW 255
117858: ST_TO_ADDR
// if btype = b_lab then
117859: LD_VAR 0 5
117863: PUSH
117864: LD_INT 6
117866: EQUAL
117867: IFFALSE 117917
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
117869: LD_ADDR_EXP 194
117873: PUSH
117874: LD_EXP 194
117878: PPUSH
117879: LD_VAR 0 3
117883: PUSH
117884: LD_EXP 194
117888: PUSH
117889: LD_VAR 0 3
117893: ARRAY
117894: PUSH
117895: LD_INT 1
117897: PLUS
117898: PUSH
117899: EMPTY
117900: LIST
117901: LIST
117902: PPUSH
117903: LD_VAR 0 1
117907: PPUSH
117908: CALL 24186 0 3
117912: ST_TO_ADDR
// exit ;
117913: POP
117914: POP
117915: GO 118373
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
117917: LD_VAR 0 5
117921: PUSH
117922: LD_INT 0
117924: PUSH
117925: LD_INT 2
117927: PUSH
117928: LD_INT 4
117930: PUSH
117931: EMPTY
117932: LIST
117933: LIST
117934: LIST
117935: IN
117936: IFFALSE 118060
// begin if btype = b_armoury then
117938: LD_VAR 0 5
117942: PUSH
117943: LD_INT 4
117945: EQUAL
117946: IFFALSE 117956
// btype := b_barracks ;
117948: LD_ADDR_VAR 0 5
117952: PUSH
117953: LD_INT 5
117955: ST_TO_ADDR
// if btype = b_depot then
117956: LD_VAR 0 5
117960: PUSH
117961: LD_INT 0
117963: EQUAL
117964: IFFALSE 117974
// btype := b_warehouse ;
117966: LD_ADDR_VAR 0 5
117970: PUSH
117971: LD_INT 1
117973: ST_TO_ADDR
// if btype = b_workshop then
117974: LD_VAR 0 5
117978: PUSH
117979: LD_INT 2
117981: EQUAL
117982: IFFALSE 117992
// btype := b_factory ;
117984: LD_ADDR_VAR 0 5
117988: PUSH
117989: LD_INT 3
117991: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
117992: LD_VAR 0 5
117996: PPUSH
117997: LD_VAR 0 8
118001: PPUSH
118002: CALL_OW 323
118006: PUSH
118007: LD_INT 1
118009: EQUAL
118010: IFFALSE 118056
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
118012: LD_ADDR_EXP 193
118016: PUSH
118017: LD_EXP 193
118021: PPUSH
118022: LD_VAR 0 3
118026: PUSH
118027: LD_EXP 193
118031: PUSH
118032: LD_VAR 0 3
118036: ARRAY
118037: PUSH
118038: LD_INT 1
118040: PLUS
118041: PUSH
118042: EMPTY
118043: LIST
118044: LIST
118045: PPUSH
118046: LD_VAR 0 1
118050: PPUSH
118051: CALL 24186 0 3
118055: ST_TO_ADDR
// exit ;
118056: POP
118057: POP
118058: GO 118373
// end ; if btype in [ b_bunker , b_turret ] then
118060: LD_VAR 0 5
118064: PUSH
118065: LD_INT 32
118067: PUSH
118068: LD_INT 33
118070: PUSH
118071: EMPTY
118072: LIST
118073: LIST
118074: IN
118075: IFFALSE 118365
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
118077: LD_ADDR_EXP 169
118081: PUSH
118082: LD_EXP 169
118086: PPUSH
118087: LD_VAR 0 3
118091: PUSH
118092: LD_EXP 169
118096: PUSH
118097: LD_VAR 0 3
118101: ARRAY
118102: PUSH
118103: LD_INT 1
118105: PLUS
118106: PUSH
118107: EMPTY
118108: LIST
118109: LIST
118110: PPUSH
118111: LD_VAR 0 1
118115: PPUSH
118116: CALL 24186 0 3
118120: ST_TO_ADDR
// if btype = b_bunker then
118121: LD_VAR 0 5
118125: PUSH
118126: LD_INT 32
118128: EQUAL
118129: IFFALSE 118365
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
118131: LD_ADDR_EXP 170
118135: PUSH
118136: LD_EXP 170
118140: PPUSH
118141: LD_VAR 0 3
118145: PUSH
118146: LD_EXP 170
118150: PUSH
118151: LD_VAR 0 3
118155: ARRAY
118156: PUSH
118157: LD_INT 1
118159: PLUS
118160: PUSH
118161: EMPTY
118162: LIST
118163: LIST
118164: PPUSH
118165: LD_VAR 0 1
118169: PPUSH
118170: CALL 24186 0 3
118174: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
118175: LD_ADDR_VAR 0 6
118179: PUSH
118180: LD_EXP 161
118184: PUSH
118185: LD_VAR 0 3
118189: ARRAY
118190: PPUSH
118191: LD_INT 25
118193: PUSH
118194: LD_INT 1
118196: PUSH
118197: EMPTY
118198: LIST
118199: LIST
118200: PUSH
118201: LD_INT 3
118203: PUSH
118204: LD_INT 54
118206: PUSH
118207: EMPTY
118208: LIST
118209: PUSH
118210: EMPTY
118211: LIST
118212: LIST
118213: PUSH
118214: EMPTY
118215: LIST
118216: LIST
118217: PPUSH
118218: CALL_OW 72
118222: ST_TO_ADDR
// if tmp then
118223: LD_VAR 0 6
118227: IFFALSE 118233
// exit ;
118229: POP
118230: POP
118231: GO 118373
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
118233: LD_ADDR_VAR 0 6
118237: PUSH
118238: LD_EXP 161
118242: PUSH
118243: LD_VAR 0 3
118247: ARRAY
118248: PPUSH
118249: LD_INT 2
118251: PUSH
118252: LD_INT 30
118254: PUSH
118255: LD_INT 4
118257: PUSH
118258: EMPTY
118259: LIST
118260: LIST
118261: PUSH
118262: LD_INT 30
118264: PUSH
118265: LD_INT 5
118267: PUSH
118268: EMPTY
118269: LIST
118270: LIST
118271: PUSH
118272: EMPTY
118273: LIST
118274: LIST
118275: LIST
118276: PPUSH
118277: CALL_OW 72
118281: ST_TO_ADDR
// if not tmp then
118282: LD_VAR 0 6
118286: NOT
118287: IFFALSE 118293
// exit ;
118289: POP
118290: POP
118291: GO 118373
// for j in tmp do
118293: LD_ADDR_VAR 0 4
118297: PUSH
118298: LD_VAR 0 6
118302: PUSH
118303: FOR_IN
118304: IFFALSE 118363
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
118306: LD_ADDR_VAR 0 7
118310: PUSH
118311: LD_VAR 0 4
118315: PPUSH
118316: CALL_OW 313
118320: PPUSH
118321: LD_INT 25
118323: PUSH
118324: LD_INT 1
118326: PUSH
118327: EMPTY
118328: LIST
118329: LIST
118330: PPUSH
118331: CALL_OW 72
118335: ST_TO_ADDR
// if units then
118336: LD_VAR 0 7
118340: IFFALSE 118361
// begin ComExitBuilding ( units [ 1 ] ) ;
118342: LD_VAR 0 7
118346: PUSH
118347: LD_INT 1
118349: ARRAY
118350: PPUSH
118351: CALL_OW 122
// exit ;
118355: POP
118356: POP
118357: POP
118358: POP
118359: GO 118373
// end ; end ;
118361: GO 118303
118363: POP
118364: POP
// end ; end ; exit ;
118365: POP
118366: POP
118367: GO 118373
// end ; end ;
118369: GO 117727
118371: POP
118372: POP
// end ;
118373: LD_VAR 0 2
118377: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
118378: LD_INT 0
118380: PPUSH
118381: PPUSH
118382: PPUSH
118383: PPUSH
118384: PPUSH
118385: PPUSH
118386: PPUSH
// if not mc_bases or not skirmish then
118387: LD_EXP 161
118391: NOT
118392: PUSH
118393: LD_EXP 159
118397: NOT
118398: OR
118399: IFFALSE 118403
// exit ;
118401: GO 118668
// btype := GetBType ( building ) ;
118403: LD_ADDR_VAR 0 6
118407: PUSH
118408: LD_VAR 0 1
118412: PPUSH
118413: CALL_OW 266
118417: ST_TO_ADDR
// x := GetX ( building ) ;
118418: LD_ADDR_VAR 0 7
118422: PUSH
118423: LD_VAR 0 1
118427: PPUSH
118428: CALL_OW 250
118432: ST_TO_ADDR
// y := GetY ( building ) ;
118433: LD_ADDR_VAR 0 8
118437: PUSH
118438: LD_VAR 0 1
118442: PPUSH
118443: CALL_OW 251
118447: ST_TO_ADDR
// d := GetDir ( building ) ;
118448: LD_ADDR_VAR 0 9
118452: PUSH
118453: LD_VAR 0 1
118457: PPUSH
118458: CALL_OW 254
118462: ST_TO_ADDR
// for i = 1 to mc_bases do
118463: LD_ADDR_VAR 0 4
118467: PUSH
118468: DOUBLE
118469: LD_INT 1
118471: DEC
118472: ST_TO_ADDR
118473: LD_EXP 161
118477: PUSH
118478: FOR_TO
118479: IFFALSE 118666
// begin if not mc_build_list [ i ] then
118481: LD_EXP 166
118485: PUSH
118486: LD_VAR 0 4
118490: ARRAY
118491: NOT
118492: IFFALSE 118496
// continue ;
118494: GO 118478
// for j := 1 to mc_build_list [ i ] do
118496: LD_ADDR_VAR 0 5
118500: PUSH
118501: DOUBLE
118502: LD_INT 1
118504: DEC
118505: ST_TO_ADDR
118506: LD_EXP 166
118510: PUSH
118511: LD_VAR 0 4
118515: ARRAY
118516: PUSH
118517: FOR_TO
118518: IFFALSE 118662
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ j ] ) then
118520: LD_VAR 0 6
118524: PUSH
118525: LD_VAR 0 7
118529: PUSH
118530: LD_VAR 0 8
118534: PUSH
118535: LD_VAR 0 9
118539: PUSH
118540: EMPTY
118541: LIST
118542: LIST
118543: LIST
118544: LIST
118545: PPUSH
118546: LD_EXP 166
118550: PUSH
118551: LD_VAR 0 4
118555: ARRAY
118556: PUSH
118557: LD_VAR 0 5
118561: ARRAY
118562: PPUSH
118563: CALL 30375 0 2
118567: IFFALSE 118660
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , j ) ) ;
118569: LD_ADDR_EXP 166
118573: PUSH
118574: LD_EXP 166
118578: PPUSH
118579: LD_VAR 0 4
118583: PPUSH
118584: LD_EXP 166
118588: PUSH
118589: LD_VAR 0 4
118593: ARRAY
118594: PPUSH
118595: LD_VAR 0 5
118599: PPUSH
118600: CALL_OW 3
118604: PPUSH
118605: CALL_OW 1
118609: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
118610: LD_ADDR_EXP 168
118614: PUSH
118615: LD_EXP 168
118619: PPUSH
118620: LD_VAR 0 4
118624: PUSH
118625: LD_EXP 168
118629: PUSH
118630: LD_VAR 0 4
118634: ARRAY
118635: PUSH
118636: LD_INT 1
118638: PLUS
118639: PUSH
118640: EMPTY
118641: LIST
118642: LIST
118643: PPUSH
118644: LD_VAR 0 1
118648: PPUSH
118649: CALL 24186 0 3
118653: ST_TO_ADDR
// exit ;
118654: POP
118655: POP
118656: POP
118657: POP
118658: GO 118668
// end ;
118660: GO 118517
118662: POP
118663: POP
// end ;
118664: GO 118478
118666: POP
118667: POP
// end ;
118668: LD_VAR 0 3
118672: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
118673: LD_INT 0
118675: PPUSH
118676: PPUSH
118677: PPUSH
// if not mc_bases or not skirmish then
118678: LD_EXP 161
118682: NOT
118683: PUSH
118684: LD_EXP 159
118688: NOT
118689: OR
118690: IFFALSE 118694
// exit ;
118692: GO 118884
// for i = 1 to mc_bases do
118694: LD_ADDR_VAR 0 4
118698: PUSH
118699: DOUBLE
118700: LD_INT 1
118702: DEC
118703: ST_TO_ADDR
118704: LD_EXP 161
118708: PUSH
118709: FOR_TO
118710: IFFALSE 118797
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
118712: LD_VAR 0 1
118716: PUSH
118717: LD_EXP 169
118721: PUSH
118722: LD_VAR 0 4
118726: ARRAY
118727: IN
118728: PUSH
118729: LD_VAR 0 1
118733: PUSH
118734: LD_EXP 170
118738: PUSH
118739: LD_VAR 0 4
118743: ARRAY
118744: IN
118745: NOT
118746: AND
118747: IFFALSE 118795
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
118749: LD_ADDR_EXP 170
118753: PUSH
118754: LD_EXP 170
118758: PPUSH
118759: LD_VAR 0 4
118763: PUSH
118764: LD_EXP 170
118768: PUSH
118769: LD_VAR 0 4
118773: ARRAY
118774: PUSH
118775: LD_INT 1
118777: PLUS
118778: PUSH
118779: EMPTY
118780: LIST
118781: LIST
118782: PPUSH
118783: LD_VAR 0 1
118787: PPUSH
118788: CALL 24186 0 3
118792: ST_TO_ADDR
// break ;
118793: GO 118797
// end ; end ;
118795: GO 118709
118797: POP
118798: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
118799: LD_VAR 0 1
118803: PPUSH
118804: CALL_OW 257
118808: PUSH
118809: LD_EXP 187
118813: IN
118814: PUSH
118815: LD_VAR 0 1
118819: PPUSH
118820: CALL_OW 266
118824: PUSH
118825: LD_INT 5
118827: EQUAL
118828: AND
118829: PUSH
118830: LD_VAR 0 2
118834: PPUSH
118835: CALL_OW 110
118839: PUSH
118840: LD_INT 18
118842: NONEQUAL
118843: AND
118844: IFFALSE 118884
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
118846: LD_VAR 0 2
118850: PPUSH
118851: CALL_OW 257
118855: PUSH
118856: LD_INT 5
118858: PUSH
118859: LD_INT 8
118861: PUSH
118862: LD_INT 9
118864: PUSH
118865: EMPTY
118866: LIST
118867: LIST
118868: LIST
118869: IN
118870: IFFALSE 118884
// SetClass ( unit , 1 ) ;
118872: LD_VAR 0 2
118876: PPUSH
118877: LD_INT 1
118879: PPUSH
118880: CALL_OW 336
// end ;
118884: LD_VAR 0 3
118888: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
118889: LD_INT 0
118891: PPUSH
118892: PPUSH
// if not mc_bases or not skirmish then
118893: LD_EXP 161
118897: NOT
118898: PUSH
118899: LD_EXP 159
118903: NOT
118904: OR
118905: IFFALSE 118909
// exit ;
118907: GO 119025
// if GetLives ( abandoned_vehicle ) > 250 then
118909: LD_VAR 0 2
118913: PPUSH
118914: CALL_OW 256
118918: PUSH
118919: LD_INT 250
118921: GREATER
118922: IFFALSE 118926
// exit ;
118924: GO 119025
// for i = 1 to mc_bases do
118926: LD_ADDR_VAR 0 6
118930: PUSH
118931: DOUBLE
118932: LD_INT 1
118934: DEC
118935: ST_TO_ADDR
118936: LD_EXP 161
118940: PUSH
118941: FOR_TO
118942: IFFALSE 119023
// begin if driver in mc_bases [ i ] then
118944: LD_VAR 0 1
118948: PUSH
118949: LD_EXP 161
118953: PUSH
118954: LD_VAR 0 6
118958: ARRAY
118959: IN
118960: IFFALSE 119021
// begin ComMoveToNearbyEntrance ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
118962: LD_VAR 0 1
118966: PPUSH
118967: LD_EXP 161
118971: PUSH
118972: LD_VAR 0 6
118976: ARRAY
118977: PPUSH
118978: LD_INT 2
118980: PUSH
118981: LD_INT 30
118983: PUSH
118984: LD_INT 0
118986: PUSH
118987: EMPTY
118988: LIST
118989: LIST
118990: PUSH
118991: LD_INT 30
118993: PUSH
118994: LD_INT 1
118996: PUSH
118997: EMPTY
118998: LIST
118999: LIST
119000: PUSH
119001: EMPTY
119002: LIST
119003: LIST
119004: LIST
119005: PPUSH
119006: CALL_OW 72
119010: PUSH
119011: LD_INT 1
119013: ARRAY
119014: PPUSH
119015: CALL 57422 0 2
// break ;
119019: GO 119023
// end ; end ;
119021: GO 118941
119023: POP
119024: POP
// end ;
119025: LD_VAR 0 5
119029: RET
