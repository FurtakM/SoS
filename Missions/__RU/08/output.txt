// starting begin InitMission ;
   0: CALL 5 0 0
// end ;
   4: END
// export HeikeCaptured ; export coopWithGensher ; export HeikeStatus ; export Masha ; export dial_BuildDepotBlocker , dial_BuildArBarrackBlocker , dial_ArriveGensherUnitsBlocker ; export buildingsToBuild , techsToResearch , vehWeaponsToConstruct , availableWeapons , weaponsData , allBuildings ; export HeikeTargetX , HeikeTargetY , GensherTargetX , GensherTargetY ; export allowExitFromMap ; export acceptKurtOffert , askCommanders ; export KurtCanEscape , KurtStatus , KurtWaitingForFreeHeike , KurtWaitingForBuildBarrack ; export KurtAttack , americansAttack , forceStopKurtAttack ; export canSendHeike , canShootTrening ; export BurlakRespect ; export acceptLegionOffert , paidLegionOffert , legionOffertCountdown , legionOffertTime ; export firstMashaQuery , canChooseMashaVehicle ; export buildCompVehicle , buildArabBarrack , testedTeleport ; export lostUnits ; function InitMission ; begin
   5: LD_INT 0
   7: PPUSH
// ResetFog ;
   8: CALL_OW 335
// RandomizeAll ;
  12: CALL_OW 11
// InGameOn ;
  16: CALL_OW 8
// InitMapConfig ;
  20: CALL 358 0 0
// HeikeCaptured = LoadVariable ( 07_HeikeCaptured_1 , 0 ) ;
  24: LD_ADDR_EXP 1
  28: PUSH
  29: LD_STRING 07_HeikeCaptured_1
  31: PPUSH
  32: LD_INT 0
  34: PPUSH
  35: CALL_OW 30
  39: ST_TO_ADDR
// coopWithGensher = 0 ;
  40: LD_ADDR_EXP 2
  44: PUSH
  45: LD_INT 0
  47: ST_TO_ADDR
// HeikeStatus = 0 ;
  48: LD_ADDR_EXP 3
  52: PUSH
  53: LD_INT 0
  55: ST_TO_ADDR
// Masha = [ ] ;
  56: LD_ADDR_EXP 4
  60: PUSH
  61: EMPTY
  62: ST_TO_ADDR
// buildingsToBuild = [ ] ;
  63: LD_ADDR_EXP 8
  67: PUSH
  68: EMPTY
  69: ST_TO_ADDR
// techsToResearch = [ ] ;
  70: LD_ADDR_EXP 9
  74: PUSH
  75: EMPTY
  76: ST_TO_ADDR
// vehWeaponsToConstruct = [ ] ;
  77: LD_ADDR_EXP 10
  81: PUSH
  82: EMPTY
  83: ST_TO_ADDR
// availableWeapons = [ ] ;
  84: LD_ADDR_EXP 11
  88: PUSH
  89: EMPTY
  90: ST_TO_ADDR
// weaponsData = [ ] ;
  91: LD_ADDR_EXP 12
  95: PUSH
  96: EMPTY
  97: ST_TO_ADDR
// allBuildings = [ ] ;
  98: LD_ADDR_EXP 13
 102: PUSH
 103: EMPTY
 104: ST_TO_ADDR
// HeikeTargetX = 0 ;
 105: LD_ADDR_EXP 14
 109: PUSH
 110: LD_INT 0
 112: ST_TO_ADDR
// HeikeTargetY = 0 ;
 113: LD_ADDR_EXP 15
 117: PUSH
 118: LD_INT 0
 120: ST_TO_ADDR
// GensherTargetX = 0 ;
 121: LD_ADDR_EXP 16
 125: PUSH
 126: LD_INT 0
 128: ST_TO_ADDR
// GensherTargetY = 0 ;
 129: LD_ADDR_EXP 17
 133: PUSH
 134: LD_INT 0
 136: ST_TO_ADDR
// allowExitFromMap = 0 ;
 137: LD_ADDR_EXP 18
 141: PUSH
 142: LD_INT 0
 144: ST_TO_ADDR
// acceptKurtOffert = 0 ;
 145: LD_ADDR_EXP 19
 149: PUSH
 150: LD_INT 0
 152: ST_TO_ADDR
// askCommanders = 0 ;
 153: LD_ADDR_EXP 20
 157: PUSH
 158: LD_INT 0
 160: ST_TO_ADDR
// KurtCanEscape = true ;
 161: LD_ADDR_EXP 21
 165: PUSH
 166: LD_INT 1
 168: ST_TO_ADDR
// KurtAttack = false ;
 169: LD_ADDR_EXP 25
 173: PUSH
 174: LD_INT 0
 176: ST_TO_ADDR
// KurtWaitingForFreeHeike = false ;
 177: LD_ADDR_EXP 23
 181: PUSH
 182: LD_INT 0
 184: ST_TO_ADDR
// KurtWaitingForBuildBarrack = false ;
 185: LD_ADDR_EXP 24
 189: PUSH
 190: LD_INT 0
 192: ST_TO_ADDR
// KurtStatus = 0 ;
 193: LD_ADDR_EXP 22
 197: PUSH
 198: LD_INT 0
 200: ST_TO_ADDR
// americansAttack = false ;
 201: LD_ADDR_EXP 26
 205: PUSH
 206: LD_INT 0
 208: ST_TO_ADDR
// forceStopKurtAttack = false ;
 209: LD_ADDR_EXP 27
 213: PUSH
 214: LD_INT 0
 216: ST_TO_ADDR
// canSendHeike = false ;
 217: LD_ADDR_EXP 28
 221: PUSH
 222: LD_INT 0
 224: ST_TO_ADDR
// canShootTrening = false ;
 225: LD_ADDR_EXP 29
 229: PUSH
 230: LD_INT 0
 232: ST_TO_ADDR
// BurlakRespect = 0 ;
 233: LD_ADDR_EXP 30
 237: PUSH
 238: LD_INT 0
 240: ST_TO_ADDR
// acceptLegionOffert = false ;
 241: LD_ADDR_EXP 31
 245: PUSH
 246: LD_INT 0
 248: ST_TO_ADDR
// paidLegionOffert = false ;
 249: LD_ADDR_EXP 32
 253: PUSH
 254: LD_INT 0
 256: ST_TO_ADDR
// legionOffertCountdown = false ;
 257: LD_ADDR_EXP 33
 261: PUSH
 262: LD_INT 0
 264: ST_TO_ADDR
// legionOffertTime = 0 0$60 ;
 265: LD_ADDR_EXP 34
 269: PUSH
 270: LD_INT 2100
 272: ST_TO_ADDR
// canChooseMashaVehicle = false ;
 273: LD_ADDR_EXP 36
 277: PUSH
 278: LD_INT 0
 280: ST_TO_ADDR
// firstMashaQuery = true ;
 281: LD_ADDR_EXP 35
 285: PUSH
 286: LD_INT 1
 288: ST_TO_ADDR
// buildArabBarrack = false ;
 289: LD_ADDR_EXP 38
 293: PUSH
 294: LD_INT 0
 296: ST_TO_ADDR
// buildCompVehicle = false ;
 297: LD_ADDR_EXP 37
 301: PUSH
 302: LD_INT 0
 304: ST_TO_ADDR
// testedTeleport = false ;
 305: LD_ADDR_EXP 39
 309: PUSH
 310: LD_INT 0
 312: ST_TO_ADDR
// lostUnits = 0 ;
 313: LD_ADDR_EXP 40
 317: PUSH
 318: LD_INT 0
 320: ST_TO_ADDR
// PrepareRussians ;
 321: CALL 1292 0 0
// PrepareArabians ;
 325: CALL 3847 0 0
// PrepareAmericans ;
 329: CALL 2975 0 0
// Nef_PrepareNature ;
 333: CALL 4831 0 0
// SpawnTrees ;
 337: CALL 5452 0 0
// MissionIntro ;
 341: CALL 9085 0 0
// end ;
 345: LD_VAR 0 1
 349: RET
// export function CustomInitMacro ; begin
 350: LD_INT 0
 352: PPUSH
// end ; end_of_file
 353: LD_VAR 0 1
 357: RET
// export function InitMapConfig ; begin
 358: LD_INT 0
 360: PPUSH
// BaseMapConfig ;
 361: CALL 374 0 0
// MissionMapConfig ;
 365: CALL 464 0 0
// end ;
 369: LD_VAR 0 1
 373: RET
// export animalsAmount , animalsStats , animalsAgression , missionPrefix , previousMissionPrefix , debugMode ; function BaseMapConfig ; begin
 374: LD_INT 0
 376: PPUSH
// animalsAmount = [ 6 , 3 , 4 , 4 , 1 ] ;
 377: LD_ADDR_EXP 41
 381: PUSH
 382: LD_INT 6
 384: PUSH
 385: LD_INT 3
 387: PUSH
 388: LD_INT 4
 390: PUSH
 391: LD_INT 4
 393: PUSH
 394: LD_INT 1
 396: PUSH
 397: EMPTY
 398: LIST
 399: LIST
 400: LIST
 401: LIST
 402: LIST
 403: ST_TO_ADDR
// animalsStats = [ 2 , 2 , 2 , 2 ] ;
 404: LD_ADDR_EXP 42
 408: PUSH
 409: LD_INT 2
 411: PUSH
 412: LD_INT 2
 414: PUSH
 415: LD_INT 2
 417: PUSH
 418: LD_INT 2
 420: PUSH
 421: EMPTY
 422: LIST
 423: LIST
 424: LIST
 425: LIST
 426: ST_TO_ADDR
// animalsAgression = 3 ;
 427: LD_ADDR_EXP 43
 431: PUSH
 432: LD_INT 3
 434: ST_TO_ADDR
// debugMode = 0 ;
 435: LD_ADDR_EXP 46
 439: PUSH
 440: LD_INT 0
 442: ST_TO_ADDR
// missionPrefix = 08_ ;
 443: LD_ADDR_EXP 44
 447: PUSH
 448: LD_STRING 08_
 450: ST_TO_ADDR
// previousMissionPrefix = 07_ ;
 451: LD_ADDR_EXP 45
 455: PUSH
 456: LD_STRING 07_
 458: ST_TO_ADDR
// end ;
 459: LD_VAR 0 1
 463: RET
// export KurtAttackWaves , americansAttackWaves ; export firstAttackDelay ; export waveCooldown ; export legionReduceAmericansUnits ; export speedMedalTime ; export enemyAttackUnitsData ; export timeToFreeHeike , timeToBuildArBarrack ; export enemySkillLevel ; function MissionMapConfig ; begin
 464: LD_INT 0
 466: PPUSH
// KurtAttackWaves = [ 3 , 4 , 5 , 6 ] [ Difficulty ] ;
 467: LD_ADDR_EXP 47
 471: PUSH
 472: LD_INT 3
 474: PUSH
 475: LD_INT 4
 477: PUSH
 478: LD_INT 5
 480: PUSH
 481: LD_INT 6
 483: PUSH
 484: EMPTY
 485: LIST
 486: LIST
 487: LIST
 488: LIST
 489: PUSH
 490: LD_OWVAR 67
 494: ARRAY
 495: ST_TO_ADDR
// americansAttackWaves = [ 1 , 2 , 3 , 4 ] [ Difficulty ] ;
 496: LD_ADDR_EXP 48
 500: PUSH
 501: LD_INT 1
 503: PUSH
 504: LD_INT 2
 506: PUSH
 507: LD_INT 3
 509: PUSH
 510: LD_INT 4
 512: PUSH
 513: EMPTY
 514: LIST
 515: LIST
 516: LIST
 517: LIST
 518: PUSH
 519: LD_OWVAR 67
 523: ARRAY
 524: ST_TO_ADDR
// enemySkillLevel = [ 3 , 4 , 5 , 6 ] [ Difficulty ] ;
 525: LD_ADDR_EXP 56
 529: PUSH
 530: LD_INT 3
 532: PUSH
 533: LD_INT 4
 535: PUSH
 536: LD_INT 5
 538: PUSH
 539: LD_INT 6
 541: PUSH
 542: EMPTY
 543: LIST
 544: LIST
 545: LIST
 546: LIST
 547: PUSH
 548: LD_OWVAR 67
 552: ARRAY
 553: ST_TO_ADDR
// waveCooldown = 1 1$30 ;
 554: LD_ADDR_EXP 50
 558: PUSH
 559: LD_INT 3150
 561: ST_TO_ADDR
// firstAttackDelay = 1 1$00 ;
 562: LD_ADDR_EXP 49
 566: PUSH
 567: LD_INT 2100
 569: ST_TO_ADDR
// timeToFreeHeike = 2 2$00 ;
 570: LD_ADDR_EXP 54
 574: PUSH
 575: LD_INT 4200
 577: ST_TO_ADDR
// timeToBuildArBarrack = 5 5$00 ;
 578: LD_ADDR_EXP 55
 582: PUSH
 583: LD_INT 10500
 585: ST_TO_ADDR
// legionReduceAmericansUnits = [ 5 , 5 , 6 , 6 ] [ Difficulty ] ;
 586: LD_ADDR_EXP 51
 590: PUSH
 591: LD_INT 5
 593: PUSH
 594: LD_INT 5
 596: PUSH
 597: LD_INT 6
 599: PUSH
 600: LD_INT 6
 602: PUSH
 603: EMPTY
 604: LIST
 605: LIST
 606: LIST
 607: LIST
 608: PUSH
 609: LD_OWVAR 67
 613: ARRAY
 614: ST_TO_ADDR
// speedMedalTime = [ 80 80$0 , 70 70$0 , 60 60$0 , 50 50$0 ] [ Difficulty ] ;
 615: LD_ADDR_EXP 52
 619: PUSH
 620: LD_INT 168000
 622: PUSH
 623: LD_INT 147000
 625: PUSH
 626: LD_INT 126000
 628: PUSH
 629: LD_INT 105000
 631: PUSH
 632: EMPTY
 633: LIST
 634: LIST
 635: LIST
 636: LIST
 637: PUSH
 638: LD_OWVAR 67
 642: ARRAY
 643: ST_TO_ADDR
// enemyAttackUnitsData = [ [ 1 , [ 4 , 5 , 6 , 6 ] [ Difficulty ] , [ 7 , 8 , 9 , 9 ] [ Difficulty ] , [ 1 , 2 , 2 , 3 ] [ Difficulty ] , [ 3 , 3 , 4 , 4 ] [ Difficulty ] , [ 6 , 7 , 8 , 8 ] [ Difficulty ] , [ 10 , 12 , 15 , 15 ] [ Difficulty ] ] , [ 8 , [ 2 , 3 , 4 , 4 ] [ Difficulty ] , [ 6 , 6 , 7 , 7 ] [ Difficulty ] , [ 0 , 1 , 1 , 2 ] [ Difficulty ] , [ 1 , 2 , 3 , 3 ] [ Difficulty ] , [ 1 , 2 , 2 , 2 ] [ Difficulty ] , [ 2 , 3 , 5 , 5 ] [ Difficulty ] ] ] ;
 644: LD_ADDR_EXP 53
 648: PUSH
 649: LD_INT 1
 651: PUSH
 652: LD_INT 4
 654: PUSH
 655: LD_INT 5
 657: PUSH
 658: LD_INT 6
 660: PUSH
 661: LD_INT 6
 663: PUSH
 664: EMPTY
 665: LIST
 666: LIST
 667: LIST
 668: LIST
 669: PUSH
 670: LD_OWVAR 67
 674: ARRAY
 675: PUSH
 676: LD_INT 7
 678: PUSH
 679: LD_INT 8
 681: PUSH
 682: LD_INT 9
 684: PUSH
 685: LD_INT 9
 687: PUSH
 688: EMPTY
 689: LIST
 690: LIST
 691: LIST
 692: LIST
 693: PUSH
 694: LD_OWVAR 67
 698: ARRAY
 699: PUSH
 700: LD_INT 1
 702: PUSH
 703: LD_INT 2
 705: PUSH
 706: LD_INT 2
 708: PUSH
 709: LD_INT 3
 711: PUSH
 712: EMPTY
 713: LIST
 714: LIST
 715: LIST
 716: LIST
 717: PUSH
 718: LD_OWVAR 67
 722: ARRAY
 723: PUSH
 724: LD_INT 3
 726: PUSH
 727: LD_INT 3
 729: PUSH
 730: LD_INT 4
 732: PUSH
 733: LD_INT 4
 735: PUSH
 736: EMPTY
 737: LIST
 738: LIST
 739: LIST
 740: LIST
 741: PUSH
 742: LD_OWVAR 67
 746: ARRAY
 747: PUSH
 748: LD_INT 6
 750: PUSH
 751: LD_INT 7
 753: PUSH
 754: LD_INT 8
 756: PUSH
 757: LD_INT 8
 759: PUSH
 760: EMPTY
 761: LIST
 762: LIST
 763: LIST
 764: LIST
 765: PUSH
 766: LD_OWVAR 67
 770: ARRAY
 771: PUSH
 772: LD_INT 10
 774: PUSH
 775: LD_INT 12
 777: PUSH
 778: LD_INT 15
 780: PUSH
 781: LD_INT 15
 783: PUSH
 784: EMPTY
 785: LIST
 786: LIST
 787: LIST
 788: LIST
 789: PUSH
 790: LD_OWVAR 67
 794: ARRAY
 795: PUSH
 796: EMPTY
 797: LIST
 798: LIST
 799: LIST
 800: LIST
 801: LIST
 802: LIST
 803: LIST
 804: PUSH
 805: LD_INT 8
 807: PUSH
 808: LD_INT 2
 810: PUSH
 811: LD_INT 3
 813: PUSH
 814: LD_INT 4
 816: PUSH
 817: LD_INT 4
 819: PUSH
 820: EMPTY
 821: LIST
 822: LIST
 823: LIST
 824: LIST
 825: PUSH
 826: LD_OWVAR 67
 830: ARRAY
 831: PUSH
 832: LD_INT 6
 834: PUSH
 835: LD_INT 6
 837: PUSH
 838: LD_INT 7
 840: PUSH
 841: LD_INT 7
 843: PUSH
 844: EMPTY
 845: LIST
 846: LIST
 847: LIST
 848: LIST
 849: PUSH
 850: LD_OWVAR 67
 854: ARRAY
 855: PUSH
 856: LD_INT 0
 858: PUSH
 859: LD_INT 1
 861: PUSH
 862: LD_INT 1
 864: PUSH
 865: LD_INT 2
 867: PUSH
 868: EMPTY
 869: LIST
 870: LIST
 871: LIST
 872: LIST
 873: PUSH
 874: LD_OWVAR 67
 878: ARRAY
 879: PUSH
 880: LD_INT 1
 882: PUSH
 883: LD_INT 2
 885: PUSH
 886: LD_INT 3
 888: PUSH
 889: LD_INT 3
 891: PUSH
 892: EMPTY
 893: LIST
 894: LIST
 895: LIST
 896: LIST
 897: PUSH
 898: LD_OWVAR 67
 902: ARRAY
 903: PUSH
 904: LD_INT 1
 906: PUSH
 907: LD_INT 2
 909: PUSH
 910: LD_INT 2
 912: PUSH
 913: LD_INT 2
 915: PUSH
 916: EMPTY
 917: LIST
 918: LIST
 919: LIST
 920: LIST
 921: PUSH
 922: LD_OWVAR 67
 926: ARRAY
 927: PUSH
 928: LD_INT 2
 930: PUSH
 931: LD_INT 3
 933: PUSH
 934: LD_INT 5
 936: PUSH
 937: LD_INT 5
 939: PUSH
 940: EMPTY
 941: LIST
 942: LIST
 943: LIST
 944: LIST
 945: PUSH
 946: LD_OWVAR 67
 950: ARRAY
 951: PUSH
 952: EMPTY
 953: LIST
 954: LIST
 955: LIST
 956: LIST
 957: LIST
 958: LIST
 959: LIST
 960: PUSH
 961: EMPTY
 962: LIST
 963: LIST
 964: ST_TO_ADDR
// end ;
 965: LD_VAR 0 1
 969: RET
// every 0 0$1 trigger debugMode do var i ;
 970: LD_EXP 46
 974: IFFALSE 1289
 976: GO 978
 978: DISABLE
 979: LD_INT 0
 981: PPUSH
// begin enable ;
 982: ENABLE
// FogOff ( your_side ) ;
 983: LD_OWVAR 2
 987: PPUSH
 988: CALL_OW 344
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) do
 992: LD_ADDR_VAR 0 1
 996: PUSH
 997: LD_INT 22
 999: PUSH
1000: LD_OWVAR 2
1004: PUSH
1005: EMPTY
1006: LIST
1007: LIST
1008: PUSH
1009: LD_INT 2
1011: PUSH
1012: LD_INT 21
1014: PUSH
1015: LD_INT 1
1017: PUSH
1018: EMPTY
1019: LIST
1020: LIST
1021: PUSH
1022: LD_INT 21
1024: PUSH
1025: LD_INT 2
1027: PUSH
1028: EMPTY
1029: LIST
1030: LIST
1031: PUSH
1032: EMPTY
1033: LIST
1034: LIST
1035: LIST
1036: PUSH
1037: EMPTY
1038: LIST
1039: LIST
1040: PPUSH
1041: CALL_OW 69
1045: PUSH
1046: FOR_IN
1047: IFFALSE 1063
// SetLives ( i , 1000 ) ;
1049: LD_VAR 0 1
1053: PPUSH
1054: LD_INT 1000
1056: PPUSH
1057: CALL_OW 234
1061: GO 1046
1063: POP
1064: POP
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) do
1065: LD_ADDR_VAR 0 1
1069: PUSH
1070: LD_INT 22
1072: PUSH
1073: LD_OWVAR 2
1077: PUSH
1078: EMPTY
1079: LIST
1080: LIST
1081: PUSH
1082: LD_INT 21
1084: PUSH
1085: LD_INT 1
1087: PUSH
1088: EMPTY
1089: LIST
1090: LIST
1091: PUSH
1092: EMPTY
1093: LIST
1094: LIST
1095: PPUSH
1096: CALL_OW 69
1100: PUSH
1101: FOR_IN
1102: IFFALSE 1166
// begin SetSkill ( i , skill_combat , 10 ) ;
1104: LD_VAR 0 1
1108: PPUSH
1109: LD_INT 1
1111: PPUSH
1112: LD_INT 10
1114: PPUSH
1115: CALL_OW 237
// SetSkill ( i , skill_engineering , 10 ) ;
1119: LD_VAR 0 1
1123: PPUSH
1124: LD_INT 2
1126: PPUSH
1127: LD_INT 10
1129: PPUSH
1130: CALL_OW 237
// SetSkill ( i , skill_mechanical , 10 ) ;
1134: LD_VAR 0 1
1138: PPUSH
1139: LD_INT 3
1141: PPUSH
1142: LD_INT 10
1144: PPUSH
1145: CALL_OW 237
// SetSkill ( i , skill_scientistic , 10 ) ;
1149: LD_VAR 0 1
1153: PPUSH
1154: LD_INT 4
1156: PPUSH
1157: LD_INT 10
1159: PPUSH
1160: CALL_OW 237
// end ;
1164: GO 1101
1166: POP
1167: POP
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) do
1168: LD_ADDR_VAR 0 1
1172: PUSH
1173: LD_INT 22
1175: PUSH
1176: LD_OWVAR 2
1180: PUSH
1181: EMPTY
1182: LIST
1183: LIST
1184: PUSH
1185: LD_INT 2
1187: PUSH
1188: LD_INT 30
1190: PUSH
1191: LD_INT 0
1193: PUSH
1194: EMPTY
1195: LIST
1196: LIST
1197: PUSH
1198: LD_INT 30
1200: PUSH
1201: LD_INT 1
1203: PUSH
1204: EMPTY
1205: LIST
1206: LIST
1207: PUSH
1208: EMPTY
1209: LIST
1210: LIST
1211: LIST
1212: PUSH
1213: EMPTY
1214: LIST
1215: LIST
1216: PPUSH
1217: CALL_OW 69
1221: PUSH
1222: FOR_IN
1223: IFFALSE 1287
// begin SetResourceType ( GetBase ( i ) , mat_cans , 9999 ) ;
1225: LD_VAR 0 1
1229: PPUSH
1230: CALL_OW 274
1234: PPUSH
1235: LD_INT 1
1237: PPUSH
1238: LD_INT 9999
1240: PPUSH
1241: CALL_OW 277
// SetResourceType ( GetBase ( i ) , mat_oil , 9999 ) ;
1245: LD_VAR 0 1
1249: PPUSH
1250: CALL_OW 274
1254: PPUSH
1255: LD_INT 2
1257: PPUSH
1258: LD_INT 9999
1260: PPUSH
1261: CALL_OW 277
// SetResourceType ( GetBase ( i ) , mat_siberit , 9999 ) ;
1265: LD_VAR 0 1
1269: PPUSH
1270: CALL_OW 274
1274: PPUSH
1275: LD_INT 3
1277: PPUSH
1278: LD_INT 9999
1280: PPUSH
1281: CALL_OW 277
// end ;
1285: GO 1222
1287: POP
1288: POP
// end ; end_of_file
1289: PPOPN 1
1291: END
// export Burlak , Karamazov , Petrovova , Gleb , Petrosyan , Titov , Dolgov , Lipshchin , Kirilenkova , Belkov , Belkov2 , Xavier ; export Gnyevko , Kovalyuk , Scholtze , Kuzmov ; export Kozlov , Oblukov , Kapitsova ; export Popov ; export russianEscort ; export function PrepareRussians ; begin
1292: LD_INT 0
1294: PPUSH
// russianEscort = [ ] ;
1295: LD_ADDR_EXP 77
1299: PUSH
1300: EMPTY
1301: ST_TO_ADDR
// Masha = [ ] ;
1302: LD_ADDR_EXP 4
1306: PUSH
1307: EMPTY
1308: ST_TO_ADDR
// PrepareHeroes ;
1309: CALL 1322 0 0
// InitRussianRequiments ;
1313: CALL 2717 0 0
// end ;
1317: LD_VAR 0 1
1321: RET
// function PrepareHeroes ; var i , un , other_survivors , yourUnits , emptyVeh ; begin
1322: LD_INT 0
1324: PPUSH
1325: PPUSH
1326: PPUSH
1327: PPUSH
1328: PPUSH
1329: PPUSH
// uc_side = 3 ;
1330: LD_ADDR_OWVAR 20
1334: PUSH
1335: LD_INT 3
1337: ST_TO_ADDR
// uc_nation = 3 ;
1338: LD_ADDR_OWVAR 21
1342: PUSH
1343: LD_INT 3
1345: ST_TO_ADDR
// Burlak := PrepareUnitExt ( Burlak , true , class_mechanic ) ;
1346: LD_ADDR_EXP 57
1350: PUSH
1351: LD_STRING Burlak
1353: PPUSH
1354: LD_INT 1
1356: PPUSH
1357: LD_INT 3
1359: PPUSH
1360: CALL 5930 0 3
1364: ST_TO_ADDR
// Titov := PrepareUnitExt ( Titov , true , class_soldier ) ;
1365: LD_ADDR_EXP 62
1369: PUSH
1370: LD_STRING Titov
1372: PPUSH
1373: LD_INT 1
1375: PPUSH
1376: LD_INT 1
1378: PPUSH
1379: CALL 5930 0 3
1383: ST_TO_ADDR
// Dolgov := PrepareUnitExt ( Dolgov , true , class_scientistic ) ;
1384: LD_ADDR_EXP 63
1388: PUSH
1389: LD_STRING Dolgov
1391: PPUSH
1392: LD_INT 1
1394: PPUSH
1395: LD_INT 4
1397: PPUSH
1398: CALL 5930 0 3
1402: ST_TO_ADDR
// Lipshchin := PrepareUnitExt ( Lipshchin , true , class_soldier ) ;
1403: LD_ADDR_EXP 64
1407: PUSH
1408: LD_STRING Lipshchin
1410: PPUSH
1411: LD_INT 1
1413: PPUSH
1414: LD_INT 1
1416: PPUSH
1417: CALL 5930 0 3
1421: ST_TO_ADDR
// Karamazov := PrepareUnitExt ( Karamazov , true , class_engineer ) ;
1422: LD_ADDR_EXP 58
1426: PUSH
1427: LD_STRING Karamazov
1429: PPUSH
1430: LD_INT 1
1432: PPUSH
1433: LD_INT 2
1435: PPUSH
1436: CALL 5930 0 3
1440: ST_TO_ADDR
// Petrovova := PrepareUnitExt ( Petrovova , true , class_soldier ) ;
1441: LD_ADDR_EXP 59
1445: PUSH
1446: LD_STRING Petrovova
1448: PPUSH
1449: LD_INT 1
1451: PPUSH
1452: LD_INT 1
1454: PPUSH
1455: CALL 5930 0 3
1459: ST_TO_ADDR
// Gleb := PrepareUnitExt ( Gleb , true , class_soldier ) ;
1460: LD_ADDR_EXP 60
1464: PUSH
1465: LD_STRING Gleb
1467: PPUSH
1468: LD_INT 1
1470: PPUSH
1471: LD_INT 1
1473: PPUSH
1474: CALL 5930 0 3
1478: ST_TO_ADDR
// Petrosyan := PrepareUnitExt ( Petrosyan , true , class_scientistic ) ;
1479: LD_ADDR_EXP 61
1483: PUSH
1484: LD_STRING Petrosyan
1486: PPUSH
1487: LD_INT 1
1489: PPUSH
1490: LD_INT 4
1492: PPUSH
1493: CALL 5930 0 3
1497: ST_TO_ADDR
// Kirilenkova := PrepareUnitExt ( Kirilenkova , true , class_scientistic ) ;
1498: LD_ADDR_EXP 65
1502: PUSH
1503: LD_STRING Kirilenkova
1505: PPUSH
1506: LD_INT 1
1508: PPUSH
1509: LD_INT 4
1511: PPUSH
1512: CALL 5930 0 3
1516: ST_TO_ADDR
// Belkov := PrepareUnitExt ( Belkov , true , class_soldier ) ;
1517: LD_ADDR_EXP 66
1521: PUSH
1522: LD_STRING Belkov
1524: PPUSH
1525: LD_INT 1
1527: PPUSH
1528: LD_INT 1
1530: PPUSH
1531: CALL 5930 0 3
1535: ST_TO_ADDR
// Belkov2 := PrepareUnitExt ( Belkov2 , true , class_soldier ) ;
1536: LD_ADDR_EXP 67
1540: PUSH
1541: LD_STRING Belkov2
1543: PPUSH
1544: LD_INT 1
1546: PPUSH
1547: LD_INT 1
1549: PPUSH
1550: CALL 5930 0 3
1554: ST_TO_ADDR
// Xavier := PrepareUnitExt ( Xavier , true , class_soldier ) ;
1555: LD_ADDR_EXP 68
1559: PUSH
1560: LD_STRING Xavier
1562: PPUSH
1563: LD_INT 1
1565: PPUSH
1566: LD_INT 1
1568: PPUSH
1569: CALL 5930 0 3
1573: ST_TO_ADDR
// Gnyevko := CreateCharacter ( 04_Gnyevko ) ;
1574: LD_ADDR_EXP 69
1578: PUSH
1579: LD_STRING 04_Gnyevko
1581: PPUSH
1582: CALL_OW 34
1586: ST_TO_ADDR
// SetClass ( Gnyevko , class_soldier ) ;
1587: LD_EXP 69
1591: PPUSH
1592: LD_INT 1
1594: PPUSH
1595: CALL_OW 336
// Kovalyuk := CreateCharacter ( 04_Kovalyuk ) ;
1599: LD_ADDR_EXP 70
1603: PUSH
1604: LD_STRING 04_Kovalyuk
1606: PPUSH
1607: CALL_OW 34
1611: ST_TO_ADDR
// SetClass ( Kovalyuk , class_mechanic ) ;
1612: LD_EXP 70
1616: PPUSH
1617: LD_INT 3
1619: PPUSH
1620: CALL_OW 336
// Scholtze := CreateCharacter ( 04_Scholtze ) ;
1624: LD_ADDR_EXP 71
1628: PUSH
1629: LD_STRING 04_Scholtze
1631: PPUSH
1632: CALL_OW 34
1636: ST_TO_ADDR
// SetClass ( Scholtze , class_scientistic ) ;
1637: LD_EXP 71
1641: PPUSH
1642: LD_INT 4
1644: PPUSH
1645: CALL_OW 336
// Kuzmov := CreateCharacter ( 04_Kuzmov ) ;
1649: LD_ADDR_EXP 72
1653: PUSH
1654: LD_STRING 04_Kuzmov
1656: PPUSH
1657: CALL_OW 34
1661: ST_TO_ADDR
// SetClass ( Kuzmov , class_soldier ) ;
1662: LD_EXP 72
1666: PPUSH
1667: LD_INT 1
1669: PPUSH
1670: CALL_OW 336
// Kozlov := PrepareUnitExt ( Kozlov , false , class_engineer ) ;
1674: LD_ADDR_EXP 73
1678: PUSH
1679: LD_STRING Kozlov
1681: PPUSH
1682: LD_INT 0
1684: PPUSH
1685: LD_INT 2
1687: PPUSH
1688: CALL 5930 0 3
1692: ST_TO_ADDR
// Oblukov := PrepareUnitExt ( Oblukov , false , class_soldier ) ;
1693: LD_ADDR_EXP 74
1697: PUSH
1698: LD_STRING Oblukov
1700: PPUSH
1701: LD_INT 0
1703: PPUSH
1704: LD_INT 1
1706: PPUSH
1707: CALL 5930 0 3
1711: ST_TO_ADDR
// Kapitsova := PrepareUnitExt ( Kapitsova , false , class_scientistic ) ;
1712: LD_ADDR_EXP 75
1716: PUSH
1717: LD_STRING Kapitsova
1719: PPUSH
1720: LD_INT 0
1722: PPUSH
1723: LD_INT 4
1725: PPUSH
1726: CALL 5930 0 3
1730: ST_TO_ADDR
// Popov := PrepareUnitExt ( Popov , false , 0 ) ;
1731: LD_ADDR_EXP 76
1735: PUSH
1736: LD_STRING Popov
1738: PPUSH
1739: LD_INT 0
1741: PPUSH
1742: LD_INT 0
1744: PPUSH
1745: CALL 5930 0 3
1749: ST_TO_ADDR
// PlaceUnitsArea ( [ Burlak , Karamazov , Petrovova , Gleb , Petrosyan , Titov , Dolgov , Lipshchin , Kirilenkova , Belkov , Belkov2 , Xavier , Gnyevko , Kovalyuk , Scholtze , Kuzmov , Kozlov , Oblukov , Kapitsova ] , RussianSpawnArea , false ) ;
1750: LD_EXP 57
1754: PUSH
1755: LD_EXP 58
1759: PUSH
1760: LD_EXP 59
1764: PUSH
1765: LD_EXP 60
1769: PUSH
1770: LD_EXP 61
1774: PUSH
1775: LD_EXP 62
1779: PUSH
1780: LD_EXP 63
1784: PUSH
1785: LD_EXP 64
1789: PUSH
1790: LD_EXP 65
1794: PUSH
1795: LD_EXP 66
1799: PUSH
1800: LD_EXP 67
1804: PUSH
1805: LD_EXP 68
1809: PUSH
1810: LD_EXP 69
1814: PUSH
1815: LD_EXP 70
1819: PUSH
1820: LD_EXP 71
1824: PUSH
1825: LD_EXP 72
1829: PUSH
1830: LD_EXP 73
1834: PUSH
1835: LD_EXP 74
1839: PUSH
1840: LD_EXP 75
1844: PUSH
1845: EMPTY
1846: LIST
1847: LIST
1848: LIST
1849: LIST
1850: LIST
1851: LIST
1852: LIST
1853: LIST
1854: LIST
1855: LIST
1856: LIST
1857: LIST
1858: LIST
1859: LIST
1860: LIST
1861: LIST
1862: LIST
1863: LIST
1864: LIST
1865: PPUSH
1866: LD_INT 2
1868: PPUSH
1869: LD_INT 0
1871: PPUSH
1872: CALL 6204 0 3
// PrepareVehicles ;
1876: CALL 2417 0 0
// other_survivors = CreateCharacterSet ( 07_other_survivors ) ;
1880: LD_ADDR_VAR 0 4
1884: PUSH
1885: LD_STRING 07_other_survivors
1887: PPUSH
1888: CALL_OW 31
1892: ST_TO_ADDR
// other_survivors = other_survivors ^ CreateCharacterSet ( 04_other_survivors ) ;
1893: LD_ADDR_VAR 0 4
1897: PUSH
1898: LD_VAR 0 4
1902: PUSH
1903: LD_STRING 04_other_survivors
1905: PPUSH
1906: CALL_OW 31
1910: ADD
1911: ST_TO_ADDR
// other_survivors = other_survivors ^ CreateCharacterSet ( 04_other_survivors_with_popov ) ;
1912: LD_ADDR_VAR 0 4
1916: PUSH
1917: LD_VAR 0 4
1921: PUSH
1922: LD_STRING 04_other_survivors_with_popov
1924: PPUSH
1925: CALL_OW 31
1929: ADD
1930: ST_TO_ADDR
// for un in other_survivors do
1931: LD_ADDR_VAR 0 3
1935: PUSH
1936: LD_VAR 0 4
1940: PUSH
1941: FOR_IN
1942: IFFALSE 2028
// begin emptyVeh = FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_vehicle ] , [ f_empty ] ] ) ;
1944: LD_ADDR_VAR 0 6
1948: PUSH
1949: LD_INT 22
1951: PUSH
1952: LD_INT 3
1954: PUSH
1955: EMPTY
1956: LIST
1957: LIST
1958: PUSH
1959: LD_INT 21
1961: PUSH
1962: LD_INT 2
1964: PUSH
1965: EMPTY
1966: LIST
1967: LIST
1968: PUSH
1969: LD_INT 58
1971: PUSH
1972: EMPTY
1973: LIST
1974: PUSH
1975: EMPTY
1976: LIST
1977: LIST
1978: LIST
1979: PPUSH
1980: CALL_OW 69
1984: ST_TO_ADDR
// if emptyVeh then
1985: LD_VAR 0 6
1989: IFFALSE 2011
// PlaceHumanInUnit ( un , emptyVeh [ 1 ] ) else
1991: LD_VAR 0 3
1995: PPUSH
1996: LD_VAR 0 6
2000: PUSH
2001: LD_INT 1
2003: ARRAY
2004: PPUSH
2005: CALL_OW 52
2009: GO 2026
// PlaceUnitArea ( un , RussianSpawnArea , false ) ;
2011: LD_VAR 0 3
2015: PPUSH
2016: LD_INT 2
2018: PPUSH
2019: LD_INT 0
2021: PPUSH
2022: CALL_OW 49
// end ;
2026: GO 1941
2028: POP
2029: POP
// yourUnits = FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_nation , nation_russian ] ] ) ;
2030: LD_ADDR_VAR 0 5
2034: PUSH
2035: LD_INT 22
2037: PUSH
2038: LD_INT 3
2040: PUSH
2041: EMPTY
2042: LIST
2043: LIST
2044: PUSH
2045: LD_INT 21
2047: PUSH
2048: LD_INT 1
2050: PUSH
2051: EMPTY
2052: LIST
2053: LIST
2054: PUSH
2055: LD_INT 23
2057: PUSH
2058: LD_INT 3
2060: PUSH
2061: EMPTY
2062: LIST
2063: LIST
2064: PUSH
2065: EMPTY
2066: LIST
2067: LIST
2068: LIST
2069: PPUSH
2070: CALL_OW 69
2074: ST_TO_ADDR
// if yourUnits < 15 then
2075: LD_VAR 0 5
2079: PUSH
2080: LD_INT 15
2082: LESS
2083: IFFALSE 2232
// for i := 1 to 15 - yourUnits do
2085: LD_ADDR_VAR 0 2
2089: PUSH
2090: DOUBLE
2091: LD_INT 1
2093: DEC
2094: ST_TO_ADDR
2095: LD_INT 15
2097: PUSH
2098: LD_VAR 0 5
2102: MINUS
2103: PUSH
2104: FOR_TO
2105: IFFALSE 2230
// begin PrepareHuman ( false , rand ( 1 , 4 ) , rand ( 2 , 4 ) ) ;
2107: LD_INT 0
2109: PPUSH
2110: LD_INT 1
2112: PPUSH
2113: LD_INT 4
2115: PPUSH
2116: CALL_OW 12
2120: PPUSH
2121: LD_INT 2
2123: PPUSH
2124: LD_INT 4
2126: PPUSH
2127: CALL_OW 12
2131: PPUSH
2132: CALL_OW 380
// un = CreateHuman ;
2136: LD_ADDR_VAR 0 3
2140: PUSH
2141: CALL_OW 44
2145: ST_TO_ADDR
// emptyVeh = FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_vehicle ] , [ f_empty ] ] ) ;
2146: LD_ADDR_VAR 0 6
2150: PUSH
2151: LD_INT 22
2153: PUSH
2154: LD_INT 3
2156: PUSH
2157: EMPTY
2158: LIST
2159: LIST
2160: PUSH
2161: LD_INT 21
2163: PUSH
2164: LD_INT 2
2166: PUSH
2167: EMPTY
2168: LIST
2169: LIST
2170: PUSH
2171: LD_INT 58
2173: PUSH
2174: EMPTY
2175: LIST
2176: PUSH
2177: EMPTY
2178: LIST
2179: LIST
2180: LIST
2181: PPUSH
2182: CALL_OW 69
2186: ST_TO_ADDR
// if emptyVeh then
2187: LD_VAR 0 6
2191: IFFALSE 2213
// PlaceHumanInUnit ( un , emptyVeh [ 1 ] ) else
2193: LD_VAR 0 3
2197: PPUSH
2198: LD_VAR 0 6
2202: PUSH
2203: LD_INT 1
2205: ARRAY
2206: PPUSH
2207: CALL_OW 52
2211: GO 2228
// PlaceUnitArea ( un , RussianSpawnArea , false ) ;
2213: LD_VAR 0 3
2217: PPUSH
2218: LD_INT 2
2220: PPUSH
2221: LD_INT 0
2223: PPUSH
2224: CALL_OW 49
// end ;
2228: GO 2104
2230: POP
2231: POP
// yourUnits = FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_nation , nation_russian ] ] ) ;
2232: LD_ADDR_VAR 0 5
2236: PUSH
2237: LD_INT 22
2239: PUSH
2240: LD_INT 3
2242: PUSH
2243: EMPTY
2244: LIST
2245: LIST
2246: PUSH
2247: LD_INT 21
2249: PUSH
2250: LD_INT 1
2252: PUSH
2253: EMPTY
2254: LIST
2255: LIST
2256: PUSH
2257: LD_INT 23
2259: PUSH
2260: LD_INT 3
2262: PUSH
2263: EMPTY
2264: LIST
2265: LIST
2266: PUSH
2267: EMPTY
2268: LIST
2269: LIST
2270: LIST
2271: PPUSH
2272: CALL_OW 69
2276: ST_TO_ADDR
// if not UnitFilter ( yourUnits , [ f_class , class_engineer ] ) then
2277: LD_VAR 0 5
2281: PPUSH
2282: LD_INT 25
2284: PUSH
2285: LD_INT 2
2287: PUSH
2288: EMPTY
2289: LIST
2290: LIST
2291: PPUSH
2292: CALL_OW 72
2296: NOT
2297: IFFALSE 2315
// SetClass ( yourUnits [ 1 ] , 2 ) ;
2299: LD_VAR 0 5
2303: PUSH
2304: LD_INT 1
2306: ARRAY
2307: PPUSH
2308: LD_INT 2
2310: PPUSH
2311: CALL_OW 336
// end ;
2315: LD_VAR 0 1
2319: RET
// export function PrepareRussianEscort ; var i , unit ; begin
2320: LD_INT 0
2322: PPUSH
2323: PPUSH
2324: PPUSH
// uc_side = 6 ;
2325: LD_ADDR_OWVAR 20
2329: PUSH
2330: LD_INT 6
2332: ST_TO_ADDR
// uc_nation = 3 ;
2333: LD_ADDR_OWVAR 21
2337: PUSH
2338: LD_INT 3
2340: ST_TO_ADDR
// for i := 1 to 2 do
2341: LD_ADDR_VAR 0 2
2345: PUSH
2346: DOUBLE
2347: LD_INT 1
2349: DEC
2350: ST_TO_ADDR
2351: LD_INT 2
2353: PUSH
2354: FOR_TO
2355: IFFALSE 2410
// begin PrepareSoldier ( false , 4 ) ;
2357: LD_INT 0
2359: PPUSH
2360: LD_INT 4
2362: PPUSH
2363: CALL_OW 381
// unit = CreateHuman ;
2367: LD_ADDR_VAR 0 3
2371: PUSH
2372: CALL_OW 44
2376: ST_TO_ADDR
// russianEscort = russianEscort ^ unit ;
2377: LD_ADDR_EXP 77
2381: PUSH
2382: LD_EXP 77
2386: PUSH
2387: LD_VAR 0 3
2391: ADD
2392: ST_TO_ADDR
// PlaceUnitArea ( unit , RussianSpawn2Area , false ) ;
2393: LD_VAR 0 3
2397: PPUSH
2398: LD_INT 7
2400: PPUSH
2401: LD_INT 0
2403: PPUSH
2404: CALL_OW 49
// end ;
2408: GO 2354
2410: POP
2411: POP
// end ;
2412: LD_VAR 0 1
2416: RET
// function PrepareVehicles ; var i , veh ; begin
2417: LD_INT 0
2419: PPUSH
2420: PPUSH
2421: PPUSH
// uc_side = 3 ;
2422: LD_ADDR_OWVAR 20
2426: PUSH
2427: LD_INT 3
2429: ST_TO_ADDR
// uc_nation = 3 ;
2430: LD_ADDR_OWVAR 21
2434: PUSH
2435: LD_INT 3
2437: ST_TO_ADDR
// for i := 1 to 5 do
2438: LD_ADDR_VAR 0 2
2442: PUSH
2443: DOUBLE
2444: LD_INT 1
2446: DEC
2447: ST_TO_ADDR
2448: LD_INT 5
2450: PUSH
2451: FOR_TO
2452: IFFALSE 2562
// begin PrepareVehicle ( ru_medium_wheeled , engine_combustion , control_manual , ru_cargo_bay , rand ( 60 , 80 ) ) ;
2454: LD_INT 21
2456: PPUSH
2457: LD_INT 1
2459: PPUSH
2460: LD_INT 1
2462: PPUSH
2463: LD_INT 51
2465: PPUSH
2466: LD_INT 60
2468: PPUSH
2469: LD_INT 80
2471: PPUSH
2472: CALL_OW 12
2476: PPUSH
2477: CALL 24088 0 5
// veh = CreateVehicle ;
2481: LD_ADDR_VAR 0 3
2485: PUSH
2486: CALL_OW 45
2490: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
2491: LD_VAR 0 3
2495: PPUSH
2496: LD_INT 4
2498: PPUSH
2499: CALL_OW 233
// PlaceUnitArea ( veh , RussianSpawnArea , false ) ;
2503: LD_VAR 0 3
2507: PPUSH
2508: LD_INT 2
2510: PPUSH
2511: LD_INT 0
2513: PPUSH
2514: CALL_OW 49
// if ( i <> 5 ) then
2518: LD_VAR 0 2
2522: PUSH
2523: LD_INT 5
2525: NONEQUAL
2526: IFFALSE 2545
// AddCargo ( veh , mat_cans , 100 ) else
2528: LD_VAR 0 3
2532: PPUSH
2533: LD_INT 1
2535: PPUSH
2536: LD_INT 100
2538: PPUSH
2539: CALL_OW 291
2543: GO 2560
// AddCargo ( veh , mat_oil , 100 ) ;
2545: LD_VAR 0 3
2549: PPUSH
2550: LD_INT 2
2552: PPUSH
2553: LD_INT 100
2555: PPUSH
2556: CALL_OW 291
// end ;
2560: GO 2451
2562: POP
2563: POP
// PrepareVehicle ( ru_medium_wheeled , engine_combustion , control_manual , ru_crane , rand ( 60 , 80 ) ) ;
2564: LD_INT 21
2566: PPUSH
2567: LD_INT 1
2569: PPUSH
2570: LD_INT 1
2572: PPUSH
2573: LD_INT 52
2575: PPUSH
2576: LD_INT 60
2578: PPUSH
2579: LD_INT 80
2581: PPUSH
2582: CALL_OW 12
2586: PPUSH
2587: CALL 24088 0 5
// veh = CreateVehicle ;
2591: LD_ADDR_VAR 0 3
2595: PUSH
2596: CALL_OW 45
2600: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
2601: LD_VAR 0 3
2605: PPUSH
2606: LD_INT 4
2608: PPUSH
2609: CALL_OW 233
// PlaceUnitArea ( veh , RussianSpawnArea , false ) ;
2613: LD_VAR 0 3
2617: PPUSH
2618: LD_INT 2
2620: PPUSH
2621: LD_INT 0
2623: PPUSH
2624: CALL_OW 49
// for i := 1 to 3 do
2628: LD_ADDR_VAR 0 2
2632: PUSH
2633: DOUBLE
2634: LD_INT 1
2636: DEC
2637: ST_TO_ADDR
2638: LD_INT 3
2640: PUSH
2641: FOR_TO
2642: IFFALSE 2710
// begin PrepareVehicle ( ru_heavy_tracked , engine_combustion , control_manual , ru_bulldozer , rand ( 60 , 80 ) ) ;
2644: LD_INT 24
2646: PPUSH
2647: LD_INT 1
2649: PPUSH
2650: LD_INT 1
2652: PPUSH
2653: LD_INT 53
2655: PPUSH
2656: LD_INT 60
2658: PPUSH
2659: LD_INT 80
2661: PPUSH
2662: CALL_OW 12
2666: PPUSH
2667: CALL 24088 0 5
// veh = CreateVehicle ;
2671: LD_ADDR_VAR 0 3
2675: PUSH
2676: CALL_OW 45
2680: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
2681: LD_VAR 0 3
2685: PPUSH
2686: LD_INT 4
2688: PPUSH
2689: CALL_OW 233
// PlaceUnitArea ( veh , RussianSpawnArea , false ) ;
2693: LD_VAR 0 3
2697: PPUSH
2698: LD_INT 2
2700: PPUSH
2701: LD_INT 0
2703: PPUSH
2704: CALL_OW 49
// end ;
2708: GO 2641
2710: POP
2711: POP
// end ;
2712: LD_VAR 0 1
2716: RET
// function InitRussianRequiments ; var i ; begin
2717: LD_INT 0
2719: PPUSH
2720: PPUSH
// availableWeapons = [ ru_heavy_machine_gun , ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher ] ;
2721: LD_ADDR_EXP 11
2725: PUSH
2726: LD_INT 42
2728: PUSH
2729: LD_INT 43
2731: PUSH
2732: LD_INT 44
2734: PUSH
2735: LD_INT 46
2737: PUSH
2738: LD_INT 45
2740: PUSH
2741: EMPTY
2742: LIST
2743: LIST
2744: LIST
2745: LIST
2746: LIST
2747: ST_TO_ADDR
// for i := 1 to availableWeapons do
2748: LD_ADDR_VAR 0 2
2752: PUSH
2753: DOUBLE
2754: LD_INT 1
2756: DEC
2757: ST_TO_ADDR
2758: LD_EXP 11
2762: PUSH
2763: FOR_TO
2764: IFFALSE 2804
// weaponsData = weaponsData ^ [ [ availableWeapons [ i ] , false , false ] ] ;
2766: LD_ADDR_EXP 12
2770: PUSH
2771: LD_EXP 12
2775: PUSH
2776: LD_EXP 11
2780: PUSH
2781: LD_VAR 0 2
2785: ARRAY
2786: PUSH
2787: LD_INT 0
2789: PUSH
2790: LD_INT 0
2792: PUSH
2793: EMPTY
2794: LIST
2795: LIST
2796: LIST
2797: PUSH
2798: EMPTY
2799: LIST
2800: ADD
2801: ST_TO_ADDR
2802: GO 2763
2804: POP
2805: POP
// for i := 0 to 50 do
2806: LD_ADDR_VAR 0 2
2810: PUSH
2811: DOUBLE
2812: LD_INT 0
2814: DEC
2815: ST_TO_ADDR
2816: LD_INT 50
2818: PUSH
2819: FOR_TO
2820: IFFALSE 2858
// if GetRestrict ( i , 3 ) = state_enabled then
2822: LD_VAR 0 2
2826: PPUSH
2827: LD_INT 3
2829: PPUSH
2830: CALL_OW 323
2834: PUSH
2835: LD_INT 1
2837: EQUAL
2838: IFFALSE 2856
// buildingsToBuild = buildingsToBuild ^ i ;
2840: LD_ADDR_EXP 8
2844: PUSH
2845: LD_EXP 8
2849: PUSH
2850: LD_VAR 0 2
2854: ADD
2855: ST_TO_ADDR
2856: GO 2819
2858: POP
2859: POP
// buildingsToBuild = buildingsToBuild diff [ 0 , 2 , 4 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 14 , 22 , 31 , 32 , 33 , 39 , 40 ] ;
2860: LD_ADDR_EXP 8
2864: PUSH
2865: LD_EXP 8
2869: PUSH
2870: LD_INT 0
2872: PUSH
2873: LD_INT 2
2875: PUSH
2876: LD_INT 4
2878: PUSH
2879: LD_INT 6
2881: PUSH
2882: LD_INT 7
2884: PUSH
2885: LD_INT 8
2887: PUSH
2888: LD_INT 9
2890: PUSH
2891: LD_INT 10
2893: PUSH
2894: LD_INT 11
2896: PUSH
2897: LD_INT 12
2899: PUSH
2900: LD_INT 14
2902: PUSH
2903: LD_INT 22
2905: PUSH
2906: LD_INT 31
2908: PUSH
2909: LD_INT 32
2911: PUSH
2912: LD_INT 33
2914: PUSH
2915: LD_INT 39
2917: PUSH
2918: LD_INT 40
2920: PUSH
2921: EMPTY
2922: LIST
2923: LIST
2924: LIST
2925: LIST
2926: LIST
2927: LIST
2928: LIST
2929: LIST
2930: LIST
2931: LIST
2932: LIST
2933: LIST
2934: LIST
2935: LIST
2936: LIST
2937: LIST
2938: LIST
2939: DIFF
2940: ST_TO_ADDR
// allBuildings = buildingsToBuild ;
2941: LD_ADDR_EXP 13
2945: PUSH
2946: LD_EXP 8
2950: ST_TO_ADDR
// techsToResearch = GetTechNation ( 3 , nation_russian , state_enabled ) ;
2951: LD_ADDR_EXP 9
2955: PUSH
2956: LD_INT 3
2958: PPUSH
2959: LD_INT 3
2961: PPUSH
2962: LD_INT 1
2964: PPUSH
2965: CALL 19287 0 3
2969: ST_TO_ADDR
// end ; end_of_file
2970: LD_VAR 0 1
2974: RET
// export amAttackTeam ; export function PrepareAmericans ; begin
2975: LD_INT 0
2977: PPUSH
// amAttackTeam = [ ] ;
2978: LD_ADDR_EXP 78
2982: PUSH
2983: EMPTY
2984: ST_TO_ADDR
// SpawnAmericansSnipers ;
2985: CALL 3119 0 0
// case Difficulty of 2 :
2989: LD_OWVAR 67
2993: PUSH
2994: LD_INT 2
2996: DOUBLE
2997: EQUAL
2998: IFTRUE 3002
3000: GO 3031
3002: POP
// begin SetTech ( tech_comp1 , 1 , state_researched ) ;
3003: LD_INT 57
3005: PPUSH
3006: LD_INT 1
3008: PPUSH
3009: LD_INT 2
3011: PPUSH
3012: CALL_OW 322
// SetTech ( tech_opto1 , 1 , state_researched ) ;
3016: LD_INT 60
3018: PPUSH
3019: LD_INT 1
3021: PPUSH
3022: LD_INT 2
3024: PPUSH
3025: CALL_OW 322
// end ; 3 .. 4 :
3029: GO 3114
3031: LD_INT 3
3033: DOUBLE
3034: GREATEREQUAL
3035: IFFALSE 3043
3037: LD_INT 4
3039: DOUBLE
3040: LESSEQUAL
3041: IFTRUE 3045
3043: GO 3113
3045: POP
// begin SetTech ( tech_comp1 , 1 , state_researched ) ;
3046: LD_INT 57
3048: PPUSH
3049: LD_INT 1
3051: PPUSH
3052: LD_INT 2
3054: PPUSH
3055: CALL_OW 322
// SetTech ( tech_comp2 , 1 , state_researched ) ;
3059: LD_INT 58
3061: PPUSH
3062: LD_INT 1
3064: PPUSH
3065: LD_INT 2
3067: PPUSH
3068: CALL_OW 322
// SetTech ( tech_weap3 , 1 , state_researched ) ;
3072: LD_INT 53
3074: PPUSH
3075: LD_INT 1
3077: PPUSH
3078: LD_INT 2
3080: PPUSH
3081: CALL_OW 322
// SetTech ( tech_opto1 , 1 , state_researched ) ;
3085: LD_INT 60
3087: PPUSH
3088: LD_INT 1
3090: PPUSH
3091: LD_INT 2
3093: PPUSH
3094: CALL_OW 322
// SetTech ( tech_opto2 , 1 , state_researched ) ;
3098: LD_INT 61
3100: PPUSH
3101: LD_INT 1
3103: PPUSH
3104: LD_INT 2
3106: PPUSH
3107: CALL_OW 322
// end ; end ;
3111: GO 3114
3113: POP
// end ;
3114: LD_VAR 0 1
3118: RET
// export function SpawnAmericansSnipers ; var i , un ; begin
3119: LD_INT 0
3121: PPUSH
3122: PPUSH
3123: PPUSH
// uc_side = 1 ;
3124: LD_ADDR_OWVAR 20
3128: PUSH
3129: LD_INT 1
3131: ST_TO_ADDR
// uc_nation = 1 ;
3132: LD_ADDR_OWVAR 21
3136: PUSH
3137: LD_INT 1
3139: ST_TO_ADDR
// for i := 1 to 8 do
3140: LD_ADDR_VAR 0 2
3144: PUSH
3145: DOUBLE
3146: LD_INT 1
3148: DEC
3149: ST_TO_ADDR
3150: LD_INT 8
3152: PUSH
3153: FOR_TO
3154: IFFALSE 3207
// begin PrepareHuman ( false , class_sniper , enemySkillLevel ) ;
3156: LD_INT 0
3158: PPUSH
3159: LD_INT 5
3161: PPUSH
3162: LD_EXP 56
3166: PPUSH
3167: CALL_OW 380
// un = CreateHuman ;
3171: LD_ADDR_VAR 0 3
3175: PUSH
3176: CALL_OW 44
3180: ST_TO_ADDR
// PlaceUnitArea ( un , AmericansSnipersSpawnArea , false ) ;
3181: LD_VAR 0 3
3185: PPUSH
3186: LD_INT 14
3188: PPUSH
3189: LD_INT 0
3191: PPUSH
3192: CALL_OW 49
// ComHold ( un ) ;
3196: LD_VAR 0 3
3200: PPUSH
3201: CALL_OW 140
// end ;
3205: GO 3153
3207: POP
3208: POP
// end ;
3209: LD_VAR 0 1
3213: RET
// export function SpawnAmAttackTeam ; var i , unit , veh , randVehType , weapon , chassis , amSolds , amSnipers , amVehs ; begin
3214: LD_INT 0
3216: PPUSH
3217: PPUSH
3218: PPUSH
3219: PPUSH
3220: PPUSH
3221: PPUSH
3222: PPUSH
3223: PPUSH
3224: PPUSH
3225: PPUSH
// uc_side = 1 ;
3226: LD_ADDR_OWVAR 20
3230: PUSH
3231: LD_INT 1
3233: ST_TO_ADDR
// uc_nation = 1 ;
3234: LD_ADDR_OWVAR 21
3238: PUSH
3239: LD_INT 1
3241: ST_TO_ADDR
// amSolds = Rand ( enemyAttackUnitsData [ 1 ] [ 2 ] , enemyAttackUnitsData [ 1 ] [ 3 ] ) ;
3242: LD_ADDR_VAR 0 8
3246: PUSH
3247: LD_EXP 53
3251: PUSH
3252: LD_INT 1
3254: ARRAY
3255: PUSH
3256: LD_INT 2
3258: ARRAY
3259: PPUSH
3260: LD_EXP 53
3264: PUSH
3265: LD_INT 1
3267: ARRAY
3268: PUSH
3269: LD_INT 3
3271: ARRAY
3272: PPUSH
3273: CALL_OW 12
3277: ST_TO_ADDR
// amSnipers = Rand ( enemyAttackUnitsData [ 1 ] [ 4 ] , enemyAttackUnitsData [ 1 ] [ 5 ] ) ;
3278: LD_ADDR_VAR 0 9
3282: PUSH
3283: LD_EXP 53
3287: PUSH
3288: LD_INT 1
3290: ARRAY
3291: PUSH
3292: LD_INT 4
3294: ARRAY
3295: PPUSH
3296: LD_EXP 53
3300: PUSH
3301: LD_INT 1
3303: ARRAY
3304: PUSH
3305: LD_INT 5
3307: ARRAY
3308: PPUSH
3309: CALL_OW 12
3313: ST_TO_ADDR
// amVehs = Rand ( enemyAttackUnitsData [ 1 ] [ 6 ] , enemyAttackUnitsData [ 1 ] [ 7 ] ) ;
3314: LD_ADDR_VAR 0 10
3318: PUSH
3319: LD_EXP 53
3323: PUSH
3324: LD_INT 1
3326: ARRAY
3327: PUSH
3328: LD_INT 6
3330: ARRAY
3331: PPUSH
3332: LD_EXP 53
3336: PUSH
3337: LD_INT 1
3339: ARRAY
3340: PUSH
3341: LD_INT 7
3343: ARRAY
3344: PPUSH
3345: CALL_OW 12
3349: ST_TO_ADDR
// if paidLegionOffert then
3350: LD_EXP 32
3354: IFFALSE 3388
// begin amSolds = amSolds - legionReduceAmericansUnits ;
3356: LD_ADDR_VAR 0 8
3360: PUSH
3361: LD_VAR 0 8
3365: PUSH
3366: LD_EXP 51
3370: MINUS
3371: ST_TO_ADDR
// amVehs = amVehs - legionReduceAmericansUnits ;
3372: LD_ADDR_VAR 0 10
3376: PUSH
3377: LD_VAR 0 10
3381: PUSH
3382: LD_EXP 51
3386: MINUS
3387: ST_TO_ADDR
// end ; for i := 1 to amSolds do
3388: LD_ADDR_VAR 0 2
3392: PUSH
3393: DOUBLE
3394: LD_INT 1
3396: DEC
3397: ST_TO_ADDR
3398: LD_VAR 0 8
3402: PUSH
3403: FOR_TO
3404: IFFALSE 3461
// begin PrepareSoldier ( false , enemySkillLevel ) ;
3406: LD_INT 0
3408: PPUSH
3409: LD_EXP 56
3413: PPUSH
3414: CALL_OW 381
// unit = CreateHuman ;
3418: LD_ADDR_VAR 0 3
3422: PUSH
3423: CALL_OW 44
3427: ST_TO_ADDR
// PlaceUnitArea ( unit , AmericanSpawnArea , false ) ;
3428: LD_VAR 0 3
3432: PPUSH
3433: LD_INT 3
3435: PPUSH
3436: LD_INT 0
3438: PPUSH
3439: CALL_OW 49
// amAttackTeam = amAttackTeam ^ unit ;
3443: LD_ADDR_EXP 78
3447: PUSH
3448: LD_EXP 78
3452: PUSH
3453: LD_VAR 0 3
3457: ADD
3458: ST_TO_ADDR
// end ;
3459: GO 3403
3461: POP
3462: POP
// for i := 1 to amSnipers do
3463: LD_ADDR_VAR 0 2
3467: PUSH
3468: DOUBLE
3469: LD_INT 1
3471: DEC
3472: ST_TO_ADDR
3473: LD_VAR 0 9
3477: PUSH
3478: FOR_TO
3479: IFFALSE 3539
// begin PrepareHuman ( false , class_sniper , enemySkillLevel ) ;
3481: LD_INT 0
3483: PPUSH
3484: LD_INT 5
3486: PPUSH
3487: LD_EXP 56
3491: PPUSH
3492: CALL_OW 380
// unit = CreateHuman ;
3496: LD_ADDR_VAR 0 3
3500: PUSH
3501: CALL_OW 44
3505: ST_TO_ADDR
// PlaceUnitArea ( unit , AmericanSpawnArea , false ) ;
3506: LD_VAR 0 3
3510: PPUSH
3511: LD_INT 3
3513: PPUSH
3514: LD_INT 0
3516: PPUSH
3517: CALL_OW 49
// amAttackTeam = amAttackTeam ^ unit ;
3521: LD_ADDR_EXP 78
3525: PUSH
3526: LD_EXP 78
3530: PUSH
3531: LD_VAR 0 3
3535: ADD
3536: ST_TO_ADDR
// end ;
3537: GO 3478
3539: POP
3540: POP
// for i := 1 to amVehs do
3541: LD_ADDR_VAR 0 2
3545: PUSH
3546: DOUBLE
3547: LD_INT 1
3549: DEC
3550: ST_TO_ADDR
3551: LD_VAR 0 10
3555: PUSH
3556: FOR_TO
3557: IFFALSE 3840
// begin randVehType = Rand ( 1 , 4 ) ;
3559: LD_ADDR_VAR 0 5
3563: PUSH
3564: LD_INT 1
3566: PPUSH
3567: LD_INT 4
3569: PPUSH
3570: CALL_OW 12
3574: ST_TO_ADDR
// weapon = [ us_gatling_gun , us_double_gun , us_light_gun , us_rocket_launcher , us_heavy_gun ] [ Rand ( 1 , 5 ) ] ;
3575: LD_ADDR_VAR 0 6
3579: PUSH
3580: LD_INT 4
3582: PUSH
3583: LD_INT 5
3585: PUSH
3586: LD_INT 3
3588: PUSH
3589: LD_INT 7
3591: PUSH
3592: LD_INT 6
3594: PUSH
3595: EMPTY
3596: LIST
3597: LIST
3598: LIST
3599: LIST
3600: LIST
3601: PUSH
3602: LD_INT 1
3604: PPUSH
3605: LD_INT 5
3607: PPUSH
3608: CALL_OW 12
3612: ARRAY
3613: ST_TO_ADDR
// if weapon = us_heavy_gun then
3614: LD_VAR 0 6
3618: PUSH
3619: LD_INT 6
3621: EQUAL
3622: IFFALSE 3634
// chassis = us_heavy_tracked else
3624: LD_ADDR_VAR 0 7
3628: PUSH
3629: LD_INT 4
3631: ST_TO_ADDR
3632: GO 3661
// chassis = [ us_medium_tracked , us_heavy_tracked ] [ Rand ( 1 , 2 ) ] ;
3634: LD_ADDR_VAR 0 7
3638: PUSH
3639: LD_INT 3
3641: PUSH
3642: LD_INT 4
3644: PUSH
3645: EMPTY
3646: LIST
3647: LIST
3648: PUSH
3649: LD_INT 1
3651: PPUSH
3652: LD_INT 2
3654: PPUSH
3655: CALL_OW 12
3659: ARRAY
3660: ST_TO_ADDR
// if randVehType = 1 then
3661: LD_VAR 0 5
3665: PUSH
3666: LD_INT 1
3668: EQUAL
3669: IFFALSE 3704
// PrepareVehicle ( chassis , engine_combustion , control_manual , weapon , Rand ( 70 , 90 ) ) else
3671: LD_VAR 0 7
3675: PPUSH
3676: LD_INT 1
3678: PPUSH
3679: LD_INT 1
3681: PPUSH
3682: LD_VAR 0 6
3686: PPUSH
3687: LD_INT 70
3689: PPUSH
3690: LD_INT 90
3692: PPUSH
3693: CALL_OW 12
3697: PPUSH
3698: CALL 24088 0 5
3702: GO 3735
// PrepareVehicle ( chassis , engine_combustion , control_computer , weapon , Rand ( 70 , 90 ) ) ;
3704: LD_VAR 0 7
3708: PPUSH
3709: LD_INT 1
3711: PPUSH
3712: LD_INT 3
3714: PPUSH
3715: LD_VAR 0 6
3719: PPUSH
3720: LD_INT 70
3722: PPUSH
3723: LD_INT 90
3725: PPUSH
3726: CALL_OW 12
3730: PPUSH
3731: CALL 24088 0 5
// veh = CreateVehicle ;
3735: LD_ADDR_VAR 0 4
3739: PUSH
3740: CALL_OW 45
3744: ST_TO_ADDR
// PlaceUnitArea ( veh , AmericanSpawnArea , false ) ;
3745: LD_VAR 0 4
3749: PPUSH
3750: LD_INT 3
3752: PPUSH
3753: LD_INT 0
3755: PPUSH
3756: CALL_OW 49
// amAttackTeam = amAttackTeam ^ veh ;
3760: LD_ADDR_EXP 78
3764: PUSH
3765: LD_EXP 78
3769: PUSH
3770: LD_VAR 0 4
3774: ADD
3775: ST_TO_ADDR
// if randVehType = 1 then
3776: LD_VAR 0 5
3780: PUSH
3781: LD_INT 1
3783: EQUAL
3784: IFFALSE 3838
// begin PrepareMechanic ( false , enemySkillLevel ) ;
3786: LD_INT 0
3788: PPUSH
3789: LD_EXP 56
3793: PPUSH
3794: CALL_OW 383
// unit = CreateHuman ;
3798: LD_ADDR_VAR 0 3
3802: PUSH
3803: CALL_OW 44
3807: ST_TO_ADDR
// PlaceHumanInUnit ( unit , veh ) ;
3808: LD_VAR 0 3
3812: PPUSH
3813: LD_VAR 0 4
3817: PPUSH
3818: CALL_OW 52
// amAttackTeam = amAttackTeam ^ unit ;
3822: LD_ADDR_EXP 78
3826: PUSH
3827: LD_EXP 78
3831: PUSH
3832: LD_VAR 0 3
3836: ADD
3837: ST_TO_ADDR
// end ; end ;
3838: GO 3556
3840: POP
3841: POP
// end ; end_of_file
3842: LD_VAR 0 1
3846: RET
// export Heike , Kurt , Dietrich ; export KurtEng ; export GensherTeam ; export arAttackTeam ; export function PrepareArabians ; begin
3847: LD_INT 0
3849: PPUSH
// arAttackTeam = [ ] ;
3850: LD_ADDR_EXP 84
3854: PUSH
3855: EMPTY
3856: ST_TO_ADDR
// PrepareHeroes ;
3857: CALL 4262 0 0
// case Difficulty of 2 :
3861: LD_OWVAR 67
3865: PUSH
3866: LD_INT 2
3868: DOUBLE
3869: EQUAL
3870: IFTRUE 3874
3872: GO 3890
3874: POP
// begin SetTech ( tech_stimDrugs , 8 , state_researched ) ;
3875: LD_INT 5
3877: PPUSH
3878: LD_INT 8
3880: PPUSH
3881: LD_INT 2
3883: PPUSH
3884: CALL_OW 322
// end ; 3 :
3888: GO 3941
3890: LD_INT 3
3892: DOUBLE
3893: EQUAL
3894: IFTRUE 3898
3896: GO 3940
3898: POP
// begin SetTech ( tech_stimDrugs , 8 , state_researched ) ;
3899: LD_INT 5
3901: PPUSH
3902: LD_INT 8
3904: PPUSH
3905: LD_INT 2
3907: PPUSH
3908: CALL_OW 322
// SetTech ( tech_bio1 , 8 , state_researched ) ;
3912: LD_INT 66
3914: PPUSH
3915: LD_INT 8
3917: PPUSH
3918: LD_INT 2
3920: PPUSH
3921: CALL_OW 322
// SetTech ( tech_weap3 , 8 , state_researched ) ;
3925: LD_INT 53
3927: PPUSH
3928: LD_INT 8
3930: PPUSH
3931: LD_INT 2
3933: PPUSH
3934: CALL_OW 322
// end ; end ;
3938: GO 3941
3940: POP
// end ;
3941: LD_VAR 0 1
3945: RET
// export function SpawnGensherTeam ; var i , driver , veh ; begin
3946: LD_INT 0
3948: PPUSH
3949: PPUSH
3950: PPUSH
3951: PPUSH
// GensherTeam = [ ] ;
3952: LD_ADDR_EXP 83
3956: PUSH
3957: EMPTY
3958: ST_TO_ADDR
// uc_side = 2 ;
3959: LD_ADDR_OWVAR 20
3963: PUSH
3964: LD_INT 2
3966: ST_TO_ADDR
// uc_nation = 2 ;
3967: LD_ADDR_OWVAR 21
3971: PUSH
3972: LD_INT 2
3974: ST_TO_ADDR
// for i := 1 to 3 do
3975: LD_ADDR_VAR 0 2
3979: PUSH
3980: DOUBLE
3981: LD_INT 1
3983: DEC
3984: ST_TO_ADDR
3985: LD_INT 3
3987: PUSH
3988: FOR_TO
3989: IFFALSE 4148
// begin PrepareSoldier ( sex_male , rand ( 3 , 5 ) ) ;
3991: LD_INT 1
3993: PPUSH
3994: LD_INT 3
3996: PPUSH
3997: LD_INT 5
3999: PPUSH
4000: CALL_OW 12
4004: PPUSH
4005: CALL_OW 381
// driver = CreateHuman ;
4009: LD_ADDR_VAR 0 3
4013: PUSH
4014: CALL_OW 44
4018: ST_TO_ADDR
// PrepareVehicle ( ar_medium_trike , engine_combustion , control_manual , ar_cargo_bay , rand ( 50 , 70 ) ) ;
4019: LD_INT 13
4021: PPUSH
4022: LD_INT 1
4024: PPUSH
4025: LD_INT 1
4027: PPUSH
4028: LD_INT 32
4030: PPUSH
4031: LD_INT 50
4033: PPUSH
4034: LD_INT 70
4036: PPUSH
4037: CALL_OW 12
4041: PPUSH
4042: CALL 24088 0 5
// veh = CreateVehicle ;
4046: LD_ADDR_VAR 0 4
4050: PUSH
4051: CALL_OW 45
4055: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
4056: LD_VAR 0 4
4060: PPUSH
4061: LD_INT 4
4063: PPUSH
4064: CALL_OW 233
// PlaceUnitArea ( veh , GensherSpawnArea , false ) ;
4068: LD_VAR 0 4
4072: PPUSH
4073: LD_INT 4
4075: PPUSH
4076: LD_INT 0
4078: PPUSH
4079: CALL_OW 49
// PlaceHumanInUnit ( driver , veh ) ;
4083: LD_VAR 0 3
4087: PPUSH
4088: LD_VAR 0 4
4092: PPUSH
4093: CALL_OW 52
// AddCargo ( veh , i , 100 ) ;
4097: LD_VAR 0 4
4101: PPUSH
4102: LD_VAR 0 2
4106: PPUSH
4107: LD_INT 100
4109: PPUSH
4110: CALL_OW 291
// GensherTeam = GensherTeam ^ driver ;
4114: LD_ADDR_EXP 83
4118: PUSH
4119: LD_EXP 83
4123: PUSH
4124: LD_VAR 0 3
4128: ADD
4129: ST_TO_ADDR
// GensherTeam = GensherTeam ^ veh ;
4130: LD_ADDR_EXP 83
4134: PUSH
4135: LD_EXP 83
4139: PUSH
4140: LD_VAR 0 4
4144: ADD
4145: ST_TO_ADDR
// end ;
4146: GO 3988
4148: POP
4149: POP
// if IsOK ( KurtEng ) and GetSide ( KurtEng ) = 3 then
4150: LD_EXP 82
4154: PPUSH
4155: CALL_OW 302
4159: PUSH
4160: LD_EXP 82
4164: PPUSH
4165: CALL_OW 255
4169: PUSH
4170: LD_INT 3
4172: EQUAL
4173: AND
4174: IFFALSE 4208
// begin GensherTargetX = GetX ( Kurt ) ;
4176: LD_ADDR_EXP 16
4180: PUSH
4181: LD_EXP 80
4185: PPUSH
4186: CALL_OW 250
4190: ST_TO_ADDR
// GensherTargetY = GetY ( Kurt ) ;
4191: LD_ADDR_EXP 17
4195: PUSH
4196: LD_EXP 80
4200: PPUSH
4201: CALL_OW 251
4205: ST_TO_ADDR
// end else
4206: GO 4238
// begin GensherTargetX = GetX ( Burlak ) ;
4208: LD_ADDR_EXP 16
4212: PUSH
4213: LD_EXP 57
4217: PPUSH
4218: CALL_OW 250
4222: ST_TO_ADDR
// GensherTargetY = GetY ( Burlak ) ;
4223: LD_ADDR_EXP 17
4227: PUSH
4228: LD_EXP 57
4232: PPUSH
4233: CALL_OW 251
4237: ST_TO_ADDR
// end ; ComMoveXY ( GensherTeam , GensherTargetX , GensherTargetY ) ;
4238: LD_EXP 83
4242: PPUSH
4243: LD_EXP 16
4247: PPUSH
4248: LD_EXP 17
4252: PPUSH
4253: CALL_OW 111
// end ;
4257: LD_VAR 0 1
4261: RET
// function PrepareHeroes ; begin
4262: LD_INT 0
4264: PPUSH
// uc_side = 5 ;
4265: LD_ADDR_OWVAR 20
4269: PUSH
4270: LD_INT 5
4272: ST_TO_ADDR
// uc_nation = 2 ;
4273: LD_ADDR_OWVAR 21
4277: PUSH
4278: LD_INT 2
4280: ST_TO_ADDR
// Heike = PrepareUnitExt ( Heike , true , class_engineer ) ;
4281: LD_ADDR_EXP 79
4285: PUSH
4286: LD_STRING Heike
4288: PPUSH
4289: LD_INT 1
4291: PPUSH
4292: LD_INT 2
4294: PPUSH
4295: CALL 5930 0 3
4299: ST_TO_ADDR
// uc_side = 8 ;
4300: LD_ADDR_OWVAR 20
4304: PUSH
4305: LD_INT 8
4307: ST_TO_ADDR
// Kurt = PrepareUnitExt ( Kurt , false , 0 ) ;
4308: LD_ADDR_EXP 80
4312: PUSH
4313: LD_STRING Kurt
4315: PPUSH
4316: LD_INT 0
4318: PPUSH
4319: LD_INT 0
4321: PPUSH
4322: CALL 5930 0 3
4326: ST_TO_ADDR
// uc_side = 2 ;
4327: LD_ADDR_OWVAR 20
4331: PUSH
4332: LD_INT 2
4334: ST_TO_ADDR
// Dietrich = PrepareUnitExt ( Dietrich , false , 0 ) ;
4335: LD_ADDR_EXP 81
4339: PUSH
4340: LD_STRING Dietrich
4342: PPUSH
4343: LD_INT 0
4345: PPUSH
4346: LD_INT 0
4348: PPUSH
4349: CALL 5930 0 3
4353: ST_TO_ADDR
// end ;
4354: LD_VAR 0 1
4358: RET
// export function SpawnArAttackTeam ; var i , unit , veh , weapon , chassis ; begin
4359: LD_INT 0
4361: PPUSH
4362: PPUSH
4363: PPUSH
4364: PPUSH
4365: PPUSH
4366: PPUSH
// uc_side = 8 ;
4367: LD_ADDR_OWVAR 20
4371: PUSH
4372: LD_INT 8
4374: ST_TO_ADDR
// uc_nation = 2 ;
4375: LD_ADDR_OWVAR 21
4379: PUSH
4380: LD_INT 2
4382: ST_TO_ADDR
// for i := 1 to Rand ( enemyAttackUnitsData [ 1 ] [ 2 ] , enemyAttackUnitsData [ 1 ] [ 3 ] ) do
4383: LD_ADDR_VAR 0 2
4387: PUSH
4388: DOUBLE
4389: LD_INT 1
4391: DEC
4392: ST_TO_ADDR
4393: LD_EXP 53
4397: PUSH
4398: LD_INT 1
4400: ARRAY
4401: PUSH
4402: LD_INT 2
4404: ARRAY
4405: PPUSH
4406: LD_EXP 53
4410: PUSH
4411: LD_INT 1
4413: ARRAY
4414: PUSH
4415: LD_INT 3
4417: ARRAY
4418: PPUSH
4419: CALL_OW 12
4423: PUSH
4424: FOR_TO
4425: IFFALSE 4482
// begin PrepareSoldier ( false , enemySkillLevel ) ;
4427: LD_INT 0
4429: PPUSH
4430: LD_EXP 56
4434: PPUSH
4435: CALL_OW 381
// unit = CreateHuman ;
4439: LD_ADDR_VAR 0 3
4443: PUSH
4444: CALL_OW 44
4448: ST_TO_ADDR
// PlaceUnitArea ( unit , KurtUnitsSpawnArea , false ) ;
4449: LD_VAR 0 3
4453: PPUSH
4454: LD_INT 10
4456: PPUSH
4457: LD_INT 0
4459: PPUSH
4460: CALL_OW 49
// arAttackTeam = arAttackTeam ^ unit ;
4464: LD_ADDR_EXP 84
4468: PUSH
4469: LD_EXP 84
4473: PUSH
4474: LD_VAR 0 3
4478: ADD
4479: ST_TO_ADDR
// end ;
4480: GO 4424
4482: POP
4483: POP
// for i := 1 to Rand ( enemyAttackUnitsData [ 1 ] [ 4 ] , enemyAttackUnitsData [ 1 ] [ 5 ] ) do
4484: LD_ADDR_VAR 0 2
4488: PUSH
4489: DOUBLE
4490: LD_INT 1
4492: DEC
4493: ST_TO_ADDR
4494: LD_EXP 53
4498: PUSH
4499: LD_INT 1
4501: ARRAY
4502: PUSH
4503: LD_INT 4
4505: ARRAY
4506: PPUSH
4507: LD_EXP 53
4511: PUSH
4512: LD_INT 1
4514: ARRAY
4515: PUSH
4516: LD_INT 5
4518: ARRAY
4519: PPUSH
4520: CALL_OW 12
4524: PUSH
4525: FOR_TO
4526: IFFALSE 4586
// begin PrepareHuman ( false , class_mortar , enemySkillLevel ) ;
4528: LD_INT 0
4530: PPUSH
4531: LD_INT 8
4533: PPUSH
4534: LD_EXP 56
4538: PPUSH
4539: CALL_OW 380
// unit = CreateHuman ;
4543: LD_ADDR_VAR 0 3
4547: PUSH
4548: CALL_OW 44
4552: ST_TO_ADDR
// PlaceUnitArea ( unit , KurtUnitsSpawnArea , false ) ;
4553: LD_VAR 0 3
4557: PPUSH
4558: LD_INT 10
4560: PPUSH
4561: LD_INT 0
4563: PPUSH
4564: CALL_OW 49
// arAttackTeam = arAttackTeam ^ unit ;
4568: LD_ADDR_EXP 84
4572: PUSH
4573: LD_EXP 84
4577: PUSH
4578: LD_VAR 0 3
4582: ADD
4583: ST_TO_ADDR
// end ;
4584: GO 4525
4586: POP
4587: POP
// for i := 1 to Rand ( enemyAttackUnitsData [ 1 ] [ 6 ] , enemyAttackUnitsData [ 1 ] [ 7 ] ) do
4588: LD_ADDR_VAR 0 2
4592: PUSH
4593: DOUBLE
4594: LD_INT 1
4596: DEC
4597: ST_TO_ADDR
4598: LD_EXP 53
4602: PUSH
4603: LD_INT 1
4605: ARRAY
4606: PUSH
4607: LD_INT 6
4609: ARRAY
4610: PPUSH
4611: LD_EXP 53
4615: PUSH
4616: LD_INT 1
4618: ARRAY
4619: PUSH
4620: LD_INT 7
4622: ARRAY
4623: PPUSH
4624: CALL_OW 12
4628: PUSH
4629: FOR_TO
4630: IFFALSE 4824
// begin weapon = [ ar_gun , ar_flame_thrower , ar_rocket_launcher , ar_light_gun , ar_gatling_gun ] [ Rand ( 1 , 5 ) ] ;
4632: LD_ADDR_VAR 0 5
4636: PUSH
4637: LD_INT 27
4639: PUSH
4640: LD_INT 26
4642: PUSH
4643: LD_INT 28
4645: PUSH
4646: LD_INT 23
4648: PUSH
4649: LD_INT 25
4651: PUSH
4652: EMPTY
4653: LIST
4654: LIST
4655: LIST
4656: LIST
4657: LIST
4658: PUSH
4659: LD_INT 1
4661: PPUSH
4662: LD_INT 5
4664: PPUSH
4665: CALL_OW 12
4669: ARRAY
4670: ST_TO_ADDR
// chassis = [ ar_medium_trike , ar_half_tracked ] [ Rand ( 1 , 2 ) ] ;
4671: LD_ADDR_VAR 0 6
4675: PUSH
4676: LD_INT 13
4678: PUSH
4679: LD_INT 14
4681: PUSH
4682: EMPTY
4683: LIST
4684: LIST
4685: PUSH
4686: LD_INT 1
4688: PPUSH
4689: LD_INT 2
4691: PPUSH
4692: CALL_OW 12
4696: ARRAY
4697: ST_TO_ADDR
// PrepareVehicle ( chassis , engine_combustion , control_manual , weapon , Rand ( 70 , 90 ) ) ;
4698: LD_VAR 0 6
4702: PPUSH
4703: LD_INT 1
4705: PPUSH
4706: LD_INT 1
4708: PPUSH
4709: LD_VAR 0 5
4713: PPUSH
4714: LD_INT 70
4716: PPUSH
4717: LD_INT 90
4719: PPUSH
4720: CALL_OW 12
4724: PPUSH
4725: CALL 24088 0 5
// veh = CreateVehicle ;
4729: LD_ADDR_VAR 0 4
4733: PUSH
4734: CALL_OW 45
4738: ST_TO_ADDR
// PlaceUnitArea ( veh , KurtUnitsSpawnArea , false ) ;
4739: LD_VAR 0 4
4743: PPUSH
4744: LD_INT 10
4746: PPUSH
4747: LD_INT 0
4749: PPUSH
4750: CALL_OW 49
// arAttackTeam = arAttackTeam ^ veh ;
4754: LD_ADDR_EXP 84
4758: PUSH
4759: LD_EXP 84
4763: PUSH
4764: LD_VAR 0 4
4768: ADD
4769: ST_TO_ADDR
// PrepareMechanic ( false , enemySkillLevel ) ;
4770: LD_INT 0
4772: PPUSH
4773: LD_EXP 56
4777: PPUSH
4778: CALL_OW 383
// unit = CreateHuman ;
4782: LD_ADDR_VAR 0 3
4786: PUSH
4787: CALL_OW 44
4791: ST_TO_ADDR
// PlaceHumanInUnit ( unit , veh ) ;
4792: LD_VAR 0 3
4796: PPUSH
4797: LD_VAR 0 4
4801: PPUSH
4802: CALL_OW 52
// arAttackTeam = arAttackTeam ^ unit ;
4806: LD_ADDR_EXP 84
4810: PUSH
4811: LD_EXP 84
4815: PUSH
4816: LD_VAR 0 3
4820: ADD
4821: ST_TO_ADDR
// end ;
4822: GO 4629
4824: POP
4825: POP
// end ; end_of_file
4826: LD_VAR 0 1
4830: RET
// export function Nef_PrepareNature ; var i , un ; begin
4831: LD_INT 0
4833: PPUSH
4834: PPUSH
4835: PPUSH
// for i := 1 to animalsAmount [ 1 ] do
4836: LD_ADDR_VAR 0 2
4840: PUSH
4841: DOUBLE
4842: LD_INT 1
4844: DEC
4845: ST_TO_ADDR
4846: LD_EXP 41
4850: PUSH
4851: LD_INT 1
4853: ARRAY
4854: PUSH
4855: FOR_TO
4856: IFFALSE 4966
// begin uc_side = 0 ;
4858: LD_ADDR_OWVAR 20
4862: PUSH
4863: LD_INT 0
4865: ST_TO_ADDR
// uc_nation = nation_nature ;
4866: LD_ADDR_OWVAR 21
4870: PUSH
4871: LD_INT 0
4873: ST_TO_ADDR
// hc_class = class_apeman ;
4874: LD_ADDR_OWVAR 28
4878: PUSH
4879: LD_INT 12
4881: ST_TO_ADDR
// hc_skills = [ animalsStats [ 1 ] , animalsStats [ 2 ] , animalsStats [ 3 ] , animalsStats [ 4 ] ] ;
4882: LD_ADDR_OWVAR 31
4886: PUSH
4887: LD_EXP 42
4891: PUSH
4892: LD_INT 1
4894: ARRAY
4895: PUSH
4896: LD_EXP 42
4900: PUSH
4901: LD_INT 2
4903: ARRAY
4904: PUSH
4905: LD_EXP 42
4909: PUSH
4910: LD_INT 3
4912: ARRAY
4913: PUSH
4914: LD_EXP 42
4918: PUSH
4919: LD_INT 4
4921: ARRAY
4922: PUSH
4923: EMPTY
4924: LIST
4925: LIST
4926: LIST
4927: LIST
4928: ST_TO_ADDR
// hc_agressivity = animalsAgression ;
4929: LD_ADDR_OWVAR 35
4933: PUSH
4934: LD_EXP 43
4938: ST_TO_ADDR
// un = CreateHuman ;
4939: LD_ADDR_VAR 0 3
4943: PUSH
4944: CALL_OW 44
4948: ST_TO_ADDR
// PlaceUnitArea ( un , NatureArea , false ) ;
4949: LD_VAR 0 3
4953: PPUSH
4954: LD_INT 5
4956: PPUSH
4957: LD_INT 0
4959: PPUSH
4960: CALL_OW 49
// end ;
4964: GO 4855
4966: POP
4967: POP
// for i := 1 to animalsAmount [ 2 ] do
4968: LD_ADDR_VAR 0 2
4972: PUSH
4973: DOUBLE
4974: LD_INT 1
4976: DEC
4977: ST_TO_ADDR
4978: LD_EXP 41
4982: PUSH
4983: LD_INT 2
4985: ARRAY
4986: PUSH
4987: FOR_TO
4988: IFFALSE 5098
// begin uc_side = 0 ;
4990: LD_ADDR_OWVAR 20
4994: PUSH
4995: LD_INT 0
4997: ST_TO_ADDR
// uc_nation = nation_nature ;
4998: LD_ADDR_OWVAR 21
5002: PUSH
5003: LD_INT 0
5005: ST_TO_ADDR
// hc_class = class_phororhacos ;
5006: LD_ADDR_OWVAR 28
5010: PUSH
5011: LD_INT 18
5013: ST_TO_ADDR
// hc_skills = [ animalsStats [ 1 ] , animalsStats [ 2 ] , animalsStats [ 3 ] , animalsStats [ 4 ] ] ;
5014: LD_ADDR_OWVAR 31
5018: PUSH
5019: LD_EXP 42
5023: PUSH
5024: LD_INT 1
5026: ARRAY
5027: PUSH
5028: LD_EXP 42
5032: PUSH
5033: LD_INT 2
5035: ARRAY
5036: PUSH
5037: LD_EXP 42
5041: PUSH
5042: LD_INT 3
5044: ARRAY
5045: PUSH
5046: LD_EXP 42
5050: PUSH
5051: LD_INT 4
5053: ARRAY
5054: PUSH
5055: EMPTY
5056: LIST
5057: LIST
5058: LIST
5059: LIST
5060: ST_TO_ADDR
// hc_agressivity = animalsAgression ;
5061: LD_ADDR_OWVAR 35
5065: PUSH
5066: LD_EXP 43
5070: ST_TO_ADDR
// un = CreateHuman ;
5071: LD_ADDR_VAR 0 3
5075: PUSH
5076: CALL_OW 44
5080: ST_TO_ADDR
// PlaceUnitArea ( un , NatureArea , false ) ;
5081: LD_VAR 0 3
5085: PPUSH
5086: LD_INT 5
5088: PPUSH
5089: LD_INT 0
5091: PPUSH
5092: CALL_OW 49
// end ;
5096: GO 4987
5098: POP
5099: POP
// for i := 1 to animalsAmount [ 3 ] do
5100: LD_ADDR_VAR 0 2
5104: PUSH
5105: DOUBLE
5106: LD_INT 1
5108: DEC
5109: ST_TO_ADDR
5110: LD_EXP 41
5114: PUSH
5115: LD_INT 3
5117: ARRAY
5118: PUSH
5119: FOR_TO
5120: IFFALSE 5230
// begin uc_side = 0 ;
5122: LD_ADDR_OWVAR 20
5126: PUSH
5127: LD_INT 0
5129: ST_TO_ADDR
// uc_nation = nation_nature ;
5130: LD_ADDR_OWVAR 21
5134: PUSH
5135: LD_INT 0
5137: ST_TO_ADDR
// hc_class = class_tiger ;
5138: LD_ADDR_OWVAR 28
5142: PUSH
5143: LD_INT 14
5145: ST_TO_ADDR
// hc_skills = [ animalsStats [ 1 ] , animalsStats [ 2 ] , animalsStats [ 3 ] , animalsStats [ 4 ] ] ;
5146: LD_ADDR_OWVAR 31
5150: PUSH
5151: LD_EXP 42
5155: PUSH
5156: LD_INT 1
5158: ARRAY
5159: PUSH
5160: LD_EXP 42
5164: PUSH
5165: LD_INT 2
5167: ARRAY
5168: PUSH
5169: LD_EXP 42
5173: PUSH
5174: LD_INT 3
5176: ARRAY
5177: PUSH
5178: LD_EXP 42
5182: PUSH
5183: LD_INT 4
5185: ARRAY
5186: PUSH
5187: EMPTY
5188: LIST
5189: LIST
5190: LIST
5191: LIST
5192: ST_TO_ADDR
// hc_agressivity = animalsAgression ;
5193: LD_ADDR_OWVAR 35
5197: PUSH
5198: LD_EXP 43
5202: ST_TO_ADDR
// un = CreateHuman ;
5203: LD_ADDR_VAR 0 3
5207: PUSH
5208: CALL_OW 44
5212: ST_TO_ADDR
// PlaceUnitArea ( un , NatureArea , false ) ;
5213: LD_VAR 0 3
5217: PPUSH
5218: LD_INT 5
5220: PPUSH
5221: LD_INT 0
5223: PPUSH
5224: CALL_OW 49
// end ;
5228: GO 5119
5230: POP
5231: POP
// for i := 1 to animalsAmount [ 4 ] do
5232: LD_ADDR_VAR 0 2
5236: PUSH
5237: DOUBLE
5238: LD_INT 1
5240: DEC
5241: ST_TO_ADDR
5242: LD_EXP 41
5246: PUSH
5247: LD_INT 4
5249: ARRAY
5250: PUSH
5251: FOR_TO
5252: IFFALSE 5362
// begin uc_side = 0 ;
5254: LD_ADDR_OWVAR 20
5258: PUSH
5259: LD_INT 0
5261: ST_TO_ADDR
// uc_nation = nation_nature ;
5262: LD_ADDR_OWVAR 21
5266: PUSH
5267: LD_INT 0
5269: ST_TO_ADDR
// hc_class = 21 ;
5270: LD_ADDR_OWVAR 28
5274: PUSH
5275: LD_INT 21
5277: ST_TO_ADDR
// hc_skills = [ animalsStats [ 1 ] , animalsStats [ 2 ] , animalsStats [ 3 ] , animalsStats [ 4 ] ] ;
5278: LD_ADDR_OWVAR 31
5282: PUSH
5283: LD_EXP 42
5287: PUSH
5288: LD_INT 1
5290: ARRAY
5291: PUSH
5292: LD_EXP 42
5296: PUSH
5297: LD_INT 2
5299: ARRAY
5300: PUSH
5301: LD_EXP 42
5305: PUSH
5306: LD_INT 3
5308: ARRAY
5309: PUSH
5310: LD_EXP 42
5314: PUSH
5315: LD_INT 4
5317: ARRAY
5318: PUSH
5319: EMPTY
5320: LIST
5321: LIST
5322: LIST
5323: LIST
5324: ST_TO_ADDR
// hc_agressivity = animalsAgression ;
5325: LD_ADDR_OWVAR 35
5329: PUSH
5330: LD_EXP 43
5334: ST_TO_ADDR
// un = CreateHuman ;
5335: LD_ADDR_VAR 0 3
5339: PUSH
5340: CALL_OW 44
5344: ST_TO_ADDR
// PlaceUnitArea ( un , NatureArea , false ) ;
5345: LD_VAR 0 3
5349: PPUSH
5350: LD_INT 5
5352: PPUSH
5353: LD_INT 0
5355: PPUSH
5356: CALL_OW 49
// end ;
5360: GO 5251
5362: POP
5363: POP
// for i := 1 to animalsAmount [ 5 ] do
5364: LD_ADDR_VAR 0 2
5368: PUSH
5369: DOUBLE
5370: LD_INT 1
5372: DEC
5373: ST_TO_ADDR
5374: LD_EXP 41
5378: PUSH
5379: LD_INT 5
5381: ARRAY
5382: PUSH
5383: FOR_TO
5384: IFFALSE 5445
// begin uc_side = 0 ;
5386: LD_ADDR_OWVAR 20
5390: PUSH
5391: LD_INT 0
5393: ST_TO_ADDR
// uc_nation = nation_nature ;
5394: LD_ADDR_OWVAR 21
5398: PUSH
5399: LD_INT 0
5401: ST_TO_ADDR
// vc_chassis := 31 ;
5402: LD_ADDR_OWVAR 37
5406: PUSH
5407: LD_INT 31
5409: ST_TO_ADDR
// vc_control := control_rider ;
5410: LD_ADDR_OWVAR 38
5414: PUSH
5415: LD_INT 4
5417: ST_TO_ADDR
// un := CreateVehicle ;
5418: LD_ADDR_VAR 0 3
5422: PUSH
5423: CALL_OW 45
5427: ST_TO_ADDR
// PlaceUnitArea ( un , NatureArea , false ) ;
5428: LD_VAR 0 3
5432: PPUSH
5433: LD_INT 5
5435: PPUSH
5436: LD_INT 0
5438: PPUSH
5439: CALL_OW 49
// end ;
5443: GO 5383
5445: POP
5446: POP
// end ;
5447: LD_VAR 0 1
5451: RET
// export function SpawnTrees ; begin
5452: LD_INT 0
5454: PPUSH
// PlaceTreesToArea ( TreeArea , [ 2 , 10 , 11 , 27 , 35 ] , 40 , 10 , 4 ) ;
5455: LD_INT 1
5457: PPUSH
5458: LD_INT 2
5460: PUSH
5461: LD_INT 10
5463: PUSH
5464: LD_INT 11
5466: PUSH
5467: LD_INT 27
5469: PUSH
5470: LD_INT 35
5472: PUSH
5473: EMPTY
5474: LIST
5475: LIST
5476: LIST
5477: LIST
5478: LIST
5479: PPUSH
5480: LD_INT 40
5482: PPUSH
5483: LD_INT 10
5485: PPUSH
5486: LD_INT 4
5488: PPUSH
5489: CALL_OW 352
// PlaceTreesToArea ( TreeArea , [ 9 , 10 , 27 , 35 , 48 ] , 30 , 10 , 4 ) ;
5493: LD_INT 1
5495: PPUSH
5496: LD_INT 9
5498: PUSH
5499: LD_INT 10
5501: PUSH
5502: LD_INT 27
5504: PUSH
5505: LD_INT 35
5507: PUSH
5508: LD_INT 48
5510: PUSH
5511: EMPTY
5512: LIST
5513: LIST
5514: LIST
5515: LIST
5516: LIST
5517: PPUSH
5518: LD_INT 30
5520: PPUSH
5521: LD_INT 10
5523: PPUSH
5524: LD_INT 4
5526: PPUSH
5527: CALL_OW 352
// PlaceTreesToArea ( TreeArea , [ 2 , 9 , 10 , 11 , 27 ] , 60 , 10 , 4 ) ;
5531: LD_INT 1
5533: PPUSH
5534: LD_INT 2
5536: PUSH
5537: LD_INT 9
5539: PUSH
5540: LD_INT 10
5542: PUSH
5543: LD_INT 11
5545: PUSH
5546: LD_INT 27
5548: PUSH
5549: EMPTY
5550: LIST
5551: LIST
5552: LIST
5553: LIST
5554: LIST
5555: PPUSH
5556: LD_INT 60
5558: PPUSH
5559: LD_INT 10
5561: PPUSH
5562: LD_INT 4
5564: PPUSH
5565: CALL_OW 352
// PlaceTreesToArea ( TreeArea , [ 9 , 10 , 27 , 35 , 48 ] , 90 , 10 , 4 ) ;
5569: LD_INT 1
5571: PPUSH
5572: LD_INT 9
5574: PUSH
5575: LD_INT 10
5577: PUSH
5578: LD_INT 27
5580: PUSH
5581: LD_INT 35
5583: PUSH
5584: LD_INT 48
5586: PUSH
5587: EMPTY
5588: LIST
5589: LIST
5590: LIST
5591: LIST
5592: LIST
5593: PPUSH
5594: LD_INT 90
5596: PPUSH
5597: LD_INT 10
5599: PPUSH
5600: LD_INT 4
5602: PPUSH
5603: CALL_OW 352
// PlaceTreesToArea ( TreeArea , [ 2 , 9 , 10 , 11 , 48 ] , 120 , 10 , 4 ) ;
5607: LD_INT 1
5609: PPUSH
5610: LD_INT 2
5612: PUSH
5613: LD_INT 9
5615: PUSH
5616: LD_INT 10
5618: PUSH
5619: LD_INT 11
5621: PUSH
5622: LD_INT 48
5624: PUSH
5625: EMPTY
5626: LIST
5627: LIST
5628: LIST
5629: LIST
5630: LIST
5631: PPUSH
5632: LD_INT 120
5634: PPUSH
5635: LD_INT 10
5637: PPUSH
5638: LD_INT 4
5640: PPUSH
5641: CALL_OW 352
// PlaceTreesToArea ( TreeArea , [ 2 , 11 , 27 , 35 , 48 ] , 45 , 10 , 4 ) ;
5645: LD_INT 1
5647: PPUSH
5648: LD_INT 2
5650: PUSH
5651: LD_INT 11
5653: PUSH
5654: LD_INT 27
5656: PUSH
5657: LD_INT 35
5659: PUSH
5660: LD_INT 48
5662: PUSH
5663: EMPTY
5664: LIST
5665: LIST
5666: LIST
5667: LIST
5668: LIST
5669: PPUSH
5670: LD_INT 45
5672: PPUSH
5673: LD_INT 10
5675: PPUSH
5676: LD_INT 4
5678: PPUSH
5679: CALL_OW 352
// end ;
5683: LD_VAR 0 1
5687: RET
// every 0 0$1 do var i , un ;
5688: GO 5690
5690: DISABLE
5691: LD_INT 0
5693: PPUSH
5694: PPUSH
// begin if ( GetTech ( tech_apelang , 3 ) = state_enabled or GetTech ( tech_apepsych , 3 ) = state_enabled or GetTech ( tech_apeagres , 3 ) = state_enabled ) and not FilterAllUnits ( [ [ f_or , [ f_class , class_apeman ] , [ f_class , class_apeman_engineer ] , [ f_class , class_apeman_soldier ] ] ] ) then
5695: LD_INT 1
5697: PPUSH
5698: LD_INT 3
5700: PPUSH
5701: CALL_OW 321
5705: PUSH
5706: LD_INT 1
5708: EQUAL
5709: PUSH
5710: LD_INT 2
5712: PPUSH
5713: LD_INT 3
5715: PPUSH
5716: CALL_OW 321
5720: PUSH
5721: LD_INT 1
5723: EQUAL
5724: OR
5725: PUSH
5726: LD_INT 11
5728: PPUSH
5729: LD_INT 3
5731: PPUSH
5732: CALL_OW 321
5736: PUSH
5737: LD_INT 1
5739: EQUAL
5740: OR
5741: PUSH
5742: LD_INT 2
5744: PUSH
5745: LD_INT 25
5747: PUSH
5748: LD_INT 12
5750: PUSH
5751: EMPTY
5752: LIST
5753: LIST
5754: PUSH
5755: LD_INT 25
5757: PUSH
5758: LD_INT 16
5760: PUSH
5761: EMPTY
5762: LIST
5763: LIST
5764: PUSH
5765: LD_INT 25
5767: PUSH
5768: LD_INT 15
5770: PUSH
5771: EMPTY
5772: LIST
5773: LIST
5774: PUSH
5775: EMPTY
5776: LIST
5777: LIST
5778: LIST
5779: LIST
5780: PUSH
5781: EMPTY
5782: LIST
5783: PPUSH
5784: CALL_OW 69
5788: NOT
5789: AND
5790: IFFALSE 5926
// begin for i := 1 to Rand ( 2 , 4 ) do
5792: LD_ADDR_VAR 0 1
5796: PUSH
5797: DOUBLE
5798: LD_INT 1
5800: DEC
5801: ST_TO_ADDR
5802: LD_INT 2
5804: PPUSH
5805: LD_INT 4
5807: PPUSH
5808: CALL_OW 12
5812: PUSH
5813: FOR_TO
5814: IFFALSE 5924
// begin uc_side = 0 ;
5816: LD_ADDR_OWVAR 20
5820: PUSH
5821: LD_INT 0
5823: ST_TO_ADDR
// uc_nation = nation_nature ;
5824: LD_ADDR_OWVAR 21
5828: PUSH
5829: LD_INT 0
5831: ST_TO_ADDR
// hc_class = class_apeman ;
5832: LD_ADDR_OWVAR 28
5836: PUSH
5837: LD_INT 12
5839: ST_TO_ADDR
// hc_skills = [ animalsStats [ 1 ] , animalsStats [ 2 ] , animalsStats [ 3 ] , animalsStats [ 4 ] ] ;
5840: LD_ADDR_OWVAR 31
5844: PUSH
5845: LD_EXP 42
5849: PUSH
5850: LD_INT 1
5852: ARRAY
5853: PUSH
5854: LD_EXP 42
5858: PUSH
5859: LD_INT 2
5861: ARRAY
5862: PUSH
5863: LD_EXP 42
5867: PUSH
5868: LD_INT 3
5870: ARRAY
5871: PUSH
5872: LD_EXP 42
5876: PUSH
5877: LD_INT 4
5879: ARRAY
5880: PUSH
5881: EMPTY
5882: LIST
5883: LIST
5884: LIST
5885: LIST
5886: ST_TO_ADDR
// hc_agressivity = animalsAgression ;
5887: LD_ADDR_OWVAR 35
5891: PUSH
5892: LD_EXP 43
5896: ST_TO_ADDR
// un = CreateHuman ;
5897: LD_ADDR_VAR 0 2
5901: PUSH
5902: CALL_OW 44
5906: ST_TO_ADDR
// PlaceUnitArea ( un , NatureArea , false ) ;
5907: LD_VAR 0 2
5911: PPUSH
5912: LD_INT 5
5914: PPUSH
5915: LD_INT 0
5917: PPUSH
5918: CALL_OW 49
// end ;
5922: GO 5813
5924: POP
5925: POP
// end ; enable ;
5926: ENABLE
// end ; end_of_file
5927: PPOPN 2
5929: END
// export function PrepareUnitExt ( ident , exist_mode , class ) ; var unit ; begin
5930: LD_INT 0
5932: PPUSH
5933: PPUSH
// if debugMode then
5934: LD_EXP 46
5938: IFFALSE 5955
// unit := NewCharacter ( ident ) ;
5940: LD_ADDR_VAR 0 5
5944: PUSH
5945: LD_VAR 0 1
5949: PPUSH
5950: CALL_OW 25
5954: ST_TO_ADDR
// if exist_mode and not debugMode then
5955: LD_VAR 0 2
5959: PUSH
5960: LD_EXP 46
5964: NOT
5965: AND
5966: IFFALSE 5991
// unit := CreateCharacter ( previousMissionPrefix & ident ) else
5968: LD_ADDR_VAR 0 5
5972: PUSH
5973: LD_EXP 45
5977: PUSH
5978: LD_VAR 0 1
5982: STR
5983: PPUSH
5984: CALL_OW 34
5988: ST_TO_ADDR
5989: GO 6013
// if not debugMode then
5991: LD_EXP 46
5995: NOT
5996: IFFALSE 6013
// unit := NewCharacter ( ident ) ;
5998: LD_ADDR_VAR 0 5
6002: PUSH
6003: LD_VAR 0 1
6007: PPUSH
6008: CALL_OW 25
6012: ST_TO_ADDR
// if class then
6013: LD_VAR 0 3
6017: IFFALSE 6033
// SetClass ( unit , class ) ;
6019: LD_VAR 0 5
6023: PPUSH
6024: LD_VAR 0 3
6028: PPUSH
6029: CALL_OW 336
// result := unit ;
6033: LD_ADDR_VAR 0 4
6037: PUSH
6038: LD_VAR 0 5
6042: ST_TO_ADDR
// end ;
6043: LD_VAR 0 4
6047: RET
// export function ExtSaveCharacter ( character , characterStringID , side ) ; begin
6048: LD_INT 0
6050: PPUSH
// if GetSide ( character ) = side and not IsDead ( character ) then
6051: LD_VAR 0 1
6055: PPUSH
6056: CALL_OW 255
6060: PUSH
6061: LD_VAR 0 3
6065: EQUAL
6066: PUSH
6067: LD_VAR 0 1
6071: PPUSH
6072: CALL_OW 301
6076: NOT
6077: AND
6078: IFFALSE 6100
// SaveCharacters ( character , missionPrefix & characterStringID ) ;
6080: LD_VAR 0 1
6084: PPUSH
6085: LD_EXP 44
6089: PUSH
6090: LD_VAR 0 2
6094: STR
6095: PPUSH
6096: CALL_OW 38
// end ;
6100: LD_VAR 0 4
6104: RET
// export function ExtSaveCharacters ( characters , charactersStringID , side ) ; var unit , resultCharactersToSave ; begin
6105: LD_INT 0
6107: PPUSH
6108: PPUSH
6109: PPUSH
// resultCharactersToSave = [ ] ;
6110: LD_ADDR_VAR 0 6
6114: PUSH
6115: EMPTY
6116: ST_TO_ADDR
// for unit in characters do
6117: LD_ADDR_VAR 0 5
6121: PUSH
6122: LD_VAR 0 1
6126: PUSH
6127: FOR_IN
6128: IFFALSE 6177
// if GetSide ( unit ) = side and not IsDead ( unit ) then
6130: LD_VAR 0 5
6134: PPUSH
6135: CALL_OW 255
6139: PUSH
6140: LD_VAR 0 3
6144: EQUAL
6145: PUSH
6146: LD_VAR 0 5
6150: PPUSH
6151: CALL_OW 301
6155: NOT
6156: AND
6157: IFFALSE 6175
// resultCharactersToSave = resultCharactersToSave ^ unit ;
6159: LD_ADDR_VAR 0 6
6163: PUSH
6164: LD_VAR 0 6
6168: PUSH
6169: LD_VAR 0 5
6173: ADD
6174: ST_TO_ADDR
6175: GO 6127
6177: POP
6178: POP
// SaveCharacters ( resultCharactersToSave , missionPrefix & charactersStringID ) ;
6179: LD_VAR 0 6
6183: PPUSH
6184: LD_EXP 44
6188: PUSH
6189: LD_VAR 0 2
6193: STR
6194: PPUSH
6195: CALL_OW 38
// end ;
6199: LD_VAR 0 4
6203: RET
// export function PlaceUnitsArea ( units , area , spawnMode ) ; var unit ; begin
6204: LD_INT 0
6206: PPUSH
6207: PPUSH
// for unit in units do
6208: LD_ADDR_VAR 0 5
6212: PUSH
6213: LD_VAR 0 1
6217: PUSH
6218: FOR_IN
6219: IFFALSE 6242
// PlaceUnitArea ( unit , area , spawnMode ) ;
6221: LD_VAR 0 5
6225: PPUSH
6226: LD_VAR 0 2
6230: PPUSH
6231: LD_VAR 0 3
6235: PPUSH
6236: CALL_OW 49
6240: GO 6218
6242: POP
6243: POP
// end ;
6244: LD_VAR 0 4
6248: RET
// export function DialogRandom ( characters , dialogMID , dialogFID , radio , canTalkHero ) ; var i , speaker , units ; begin
6249: LD_INT 0
6251: PPUSH
6252: PPUSH
6253: PPUSH
6254: PPUSH
// units = characters ;
6255: LD_ADDR_VAR 0 9
6259: PUSH
6260: LD_VAR 0 1
6264: ST_TO_ADDR
// units := units diff [ Burlak , Karamazov , Petrovova , Gleb , Petrosyan , Titov , Dolgov , Lipshchin , Kirilenkova ] ;
6265: LD_ADDR_VAR 0 9
6269: PUSH
6270: LD_VAR 0 9
6274: PUSH
6275: LD_EXP 57
6279: PUSH
6280: LD_EXP 58
6284: PUSH
6285: LD_EXP 59
6289: PUSH
6290: LD_EXP 60
6294: PUSH
6295: LD_EXP 61
6299: PUSH
6300: LD_EXP 62
6304: PUSH
6305: LD_EXP 63
6309: PUSH
6310: LD_EXP 64
6314: PUSH
6315: LD_EXP 65
6319: PUSH
6320: EMPTY
6321: LIST
6322: LIST
6323: LIST
6324: LIST
6325: LIST
6326: LIST
6327: LIST
6328: LIST
6329: LIST
6330: DIFF
6331: ST_TO_ADDR
// if not units and not canTalkHero then
6332: LD_VAR 0 9
6336: NOT
6337: PUSH
6338: LD_VAR 0 5
6342: NOT
6343: AND
6344: IFFALSE 6348
// exit ;
6346: GO 6521
// if not units then
6348: LD_VAR 0 9
6352: NOT
6353: IFFALSE 6374
// units = characters diff [ Burlak ] ;
6355: LD_ADDR_VAR 0 9
6359: PUSH
6360: LD_VAR 0 1
6364: PUSH
6365: LD_EXP 57
6369: PUSH
6370: EMPTY
6371: LIST
6372: DIFF
6373: ST_TO_ADDR
// if not units and canTalkHero then
6374: LD_VAR 0 9
6378: NOT
6379: PUSH
6380: LD_VAR 0 5
6384: AND
6385: IFFALSE 6389
// exit ;
6387: GO 6521
// speaker := units [ rand ( 1 , units ) ] ;
6389: LD_ADDR_VAR 0 8
6393: PUSH
6394: LD_VAR 0 9
6398: PUSH
6399: LD_INT 1
6401: PPUSH
6402: LD_VAR 0 9
6406: PPUSH
6407: CALL_OW 12
6411: ARRAY
6412: ST_TO_ADDR
// if radio then
6413: LD_VAR 0 4
6417: IFFALSE 6466
// begin if GetSex ( speaker ) = sex_male then
6419: LD_VAR 0 8
6423: PPUSH
6424: CALL_OW 258
6428: PUSH
6429: LD_INT 1
6431: EQUAL
6432: IFFALSE 6450
// SayRadio ( speaker , dialogMID ) else
6434: LD_VAR 0 8
6438: PPUSH
6439: LD_VAR 0 2
6443: PPUSH
6444: CALL_OW 94
6448: GO 6464
// SayRadio ( speaker , dialogFID ) ;
6450: LD_VAR 0 8
6454: PPUSH
6455: LD_VAR 0 3
6459: PPUSH
6460: CALL_OW 94
// end else
6464: GO 6511
// begin if GetSex ( speaker ) = sex_male then
6466: LD_VAR 0 8
6470: PPUSH
6471: CALL_OW 258
6475: PUSH
6476: LD_INT 1
6478: EQUAL
6479: IFFALSE 6497
// Say ( speaker , dialogMID ) else
6481: LD_VAR 0 8
6485: PPUSH
6486: LD_VAR 0 2
6490: PPUSH
6491: CALL_OW 88
6495: GO 6511
// Say ( speaker , dialogFID ) ;
6497: LD_VAR 0 8
6501: PPUSH
6502: LD_VAR 0 3
6506: PPUSH
6507: CALL_OW 88
// end ; result := speaker ;
6511: LD_ADDR_VAR 0 6
6515: PUSH
6516: LD_VAR 0 8
6520: ST_TO_ADDR
// end ;
6521: LD_VAR 0 6
6525: RET
// export function RemoveUnits ( units ) ; var unit ; begin
6526: LD_INT 0
6528: PPUSH
6529: PPUSH
// if not units then
6530: LD_VAR 0 1
6534: NOT
6535: IFFALSE 6539
// exit ;
6537: GO 6685
// if Heike in units then
6539: LD_EXP 79
6543: PUSH
6544: LD_VAR 0 1
6548: IN
6549: IFFALSE 6605
// begin if GetAttitude ( 3 , 8 ) = att_neutral then
6551: LD_INT 3
6553: PPUSH
6554: LD_INT 8
6556: PPUSH
6557: CALL_OW 81
6561: PUSH
6562: LD_INT 0
6564: EQUAL
6565: IFFALSE 6577
// HeikeStatus = 1 else
6567: LD_ADDR_EXP 3
6571: PUSH
6572: LD_INT 1
6574: ST_TO_ADDR
6575: GO 6585
// HeikeStatus = 2 ;
6577: LD_ADDR_EXP 3
6581: PUSH
6582: LD_INT 2
6584: ST_TO_ADDR
// forceStopKurtAttack = true ;
6585: LD_ADDR_EXP 27
6589: PUSH
6590: LD_INT 1
6592: ST_TO_ADDR
// SetClass ( Heike , 1 ) ;
6593: LD_EXP 79
6597: PPUSH
6598: LD_INT 1
6600: PPUSH
6601: CALL_OW 336
// end ; if Kurt in units then
6605: LD_EXP 80
6609: PUSH
6610: LD_VAR 0 1
6614: IN
6615: IFFALSE 6659
// begin if GetAttitude ( 3 , 8 ) = att_neutral then
6617: LD_INT 3
6619: PPUSH
6620: LD_INT 8
6622: PPUSH
6623: CALL_OW 81
6627: PUSH
6628: LD_INT 0
6630: EQUAL
6631: IFFALSE 6643
// KurtStatus = 1 else
6633: LD_ADDR_EXP 22
6637: PUSH
6638: LD_INT 1
6640: ST_TO_ADDR
6641: GO 6659
// begin KurtStatus = 2 ;
6643: LD_ADDR_EXP 22
6647: PUSH
6648: LD_INT 2
6650: ST_TO_ADDR
// KurtAttack = 1 ;
6651: LD_ADDR_EXP 25
6655: PUSH
6656: LD_INT 1
6658: ST_TO_ADDR
// end ; end ; for unit in units do
6659: LD_ADDR_VAR 0 3
6663: PUSH
6664: LD_VAR 0 1
6668: PUSH
6669: FOR_IN
6670: IFFALSE 6683
// RemoveUnit ( unit ) ;
6672: LD_VAR 0 3
6676: PPUSH
6677: CALL_OW 64
6681: GO 6669
6683: POP
6684: POP
// end ;
6685: LD_VAR 0 2
6689: RET
// export function GetAmountWeaponsDataBuildOnTurret ( isBuild ) ; var i , amount ; begin
6690: LD_INT 0
6692: PPUSH
6693: PPUSH
6694: PPUSH
// amount = 0 ;
6695: LD_ADDR_VAR 0 4
6699: PUSH
6700: LD_INT 0
6702: ST_TO_ADDR
// for i := 1 to weaponsData do
6703: LD_ADDR_VAR 0 3
6707: PUSH
6708: DOUBLE
6709: LD_INT 1
6711: DEC
6712: ST_TO_ADDR
6713: LD_EXP 12
6717: PUSH
6718: FOR_TO
6719: IFFALSE 6759
// if weaponsData [ i ] [ 2 ] = isBuild then
6721: LD_EXP 12
6725: PUSH
6726: LD_VAR 0 3
6730: ARRAY
6731: PUSH
6732: LD_INT 2
6734: ARRAY
6735: PUSH
6736: LD_VAR 0 1
6740: EQUAL
6741: IFFALSE 6757
// amount = amount + 1 ;
6743: LD_ADDR_VAR 0 4
6747: PUSH
6748: LD_VAR 0 4
6752: PUSH
6753: LD_INT 1
6755: PLUS
6756: ST_TO_ADDR
6757: GO 6718
6759: POP
6760: POP
// if isBuild then
6761: LD_VAR 0 1
6765: IFFALSE 6785
// if amount >= 3 then
6767: LD_VAR 0 4
6771: PUSH
6772: LD_INT 3
6774: GREATEREQUAL
6775: IFFALSE 6785
// amount = 3 ;
6777: LD_ADDR_VAR 0 4
6781: PUSH
6782: LD_INT 3
6784: ST_TO_ADDR
// result = amount ;
6785: LD_ADDR_VAR 0 2
6789: PUSH
6790: LD_VAR 0 4
6794: ST_TO_ADDR
// end ;
6795: LD_VAR 0 2
6799: RET
// export function GetAmountWeaponsDataBuildOnVehicle ( isBuild ) ; var i , amount ; begin
6800: LD_INT 0
6802: PPUSH
6803: PPUSH
6804: PPUSH
// amount = 0 ;
6805: LD_ADDR_VAR 0 4
6809: PUSH
6810: LD_INT 0
6812: ST_TO_ADDR
// for i := 1 to weaponsData do
6813: LD_ADDR_VAR 0 3
6817: PUSH
6818: DOUBLE
6819: LD_INT 1
6821: DEC
6822: ST_TO_ADDR
6823: LD_EXP 12
6827: PUSH
6828: FOR_TO
6829: IFFALSE 6869
// if weaponsData [ i ] [ 3 ] = isBuild then
6831: LD_EXP 12
6835: PUSH
6836: LD_VAR 0 3
6840: ARRAY
6841: PUSH
6842: LD_INT 3
6844: ARRAY
6845: PUSH
6846: LD_VAR 0 1
6850: EQUAL
6851: IFFALSE 6867
// amount = amount + 1 ;
6853: LD_ADDR_VAR 0 4
6857: PUSH
6858: LD_VAR 0 4
6862: PUSH
6863: LD_INT 1
6865: PLUS
6866: ST_TO_ADDR
6867: GO 6828
6869: POP
6870: POP
// result = amount ;
6871: LD_ADDR_VAR 0 2
6875: PUSH
6876: LD_VAR 0 4
6880: ST_TO_ADDR
// end ;
6881: LD_VAR 0 2
6885: RET
// export function SetWeaponDataBuild ( weapon , turret ) ; var i ; begin
6886: LD_INT 0
6888: PPUSH
6889: PPUSH
// if turret then
6890: LD_VAR 0 2
6894: IFFALSE 6992
// begin for i := 1 to weaponsData do
6896: LD_ADDR_VAR 0 4
6900: PUSH
6901: DOUBLE
6902: LD_INT 1
6904: DEC
6905: ST_TO_ADDR
6906: LD_EXP 12
6910: PUSH
6911: FOR_TO
6912: IFFALSE 6988
// if weaponsData [ i ] [ 1 ] = weapon and weaponsData [ i ] [ 2 ] = false then
6914: LD_EXP 12
6918: PUSH
6919: LD_VAR 0 4
6923: ARRAY
6924: PUSH
6925: LD_INT 1
6927: ARRAY
6928: PUSH
6929: LD_VAR 0 1
6933: EQUAL
6934: PUSH
6935: LD_EXP 12
6939: PUSH
6940: LD_VAR 0 4
6944: ARRAY
6945: PUSH
6946: LD_INT 2
6948: ARRAY
6949: PUSH
6950: LD_INT 0
6952: EQUAL
6953: AND
6954: IFFALSE 6986
// weaponsData = ReplaceIn ( weaponsData , [ i , 2 ] , true ) ;
6956: LD_ADDR_EXP 12
6960: PUSH
6961: LD_EXP 12
6965: PPUSH
6966: LD_VAR 0 4
6970: PUSH
6971: LD_INT 2
6973: PUSH
6974: EMPTY
6975: LIST
6976: LIST
6977: PPUSH
6978: LD_INT 1
6980: PPUSH
6981: CALL 24210 0 3
6985: ST_TO_ADDR
6986: GO 6911
6988: POP
6989: POP
// end else
6990: GO 7086
// begin for i := 1 to weaponsData do
6992: LD_ADDR_VAR 0 4
6996: PUSH
6997: DOUBLE
6998: LD_INT 1
7000: DEC
7001: ST_TO_ADDR
7002: LD_EXP 12
7006: PUSH
7007: FOR_TO
7008: IFFALSE 7084
// if weaponsData [ i ] [ 1 ] = weapon and weaponsData [ i ] [ 3 ] = false then
7010: LD_EXP 12
7014: PUSH
7015: LD_VAR 0 4
7019: ARRAY
7020: PUSH
7021: LD_INT 1
7023: ARRAY
7024: PUSH
7025: LD_VAR 0 1
7029: EQUAL
7030: PUSH
7031: LD_EXP 12
7035: PUSH
7036: LD_VAR 0 4
7040: ARRAY
7041: PUSH
7042: LD_INT 3
7044: ARRAY
7045: PUSH
7046: LD_INT 0
7048: EQUAL
7049: AND
7050: IFFALSE 7082
// weaponsData = ReplaceIn ( weaponsData , [ i , 3 ] , true ) ;
7052: LD_ADDR_EXP 12
7056: PUSH
7057: LD_EXP 12
7061: PPUSH
7062: LD_VAR 0 4
7066: PUSH
7067: LD_INT 3
7069: PUSH
7070: EMPTY
7071: LIST
7072: LIST
7073: PPUSH
7074: LD_INT 1
7076: PPUSH
7077: CALL 24210 0 3
7081: ST_TO_ADDR
7082: GO 7007
7084: POP
7085: POP
// end ; end ;
7086: LD_VAR 0 3
7090: RET
// export function ShootTreningController ; var i , unitsInArea , unit , depots , depot , barrelsAreaList , randIndex , randPosX , randPosY , barrelsInArea ; begin
7091: LD_INT 0
7093: PPUSH
7094: PPUSH
7095: PPUSH
7096: PPUSH
7097: PPUSH
7098: PPUSH
7099: PPUSH
7100: PPUSH
7101: PPUSH
7102: PPUSH
7103: PPUSH
// unitsInArea = FilterUnitsInArea ( ShootArea , [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) ;
7104: LD_ADDR_VAR 0 3
7108: PUSH
7109: LD_INT 12
7111: PPUSH
7112: LD_INT 22
7114: PUSH
7115: LD_INT 3
7117: PUSH
7118: EMPTY
7119: LIST
7120: LIST
7121: PUSH
7122: LD_INT 21
7124: PUSH
7125: LD_INT 1
7127: PUSH
7128: EMPTY
7129: LIST
7130: LIST
7131: PUSH
7132: LD_INT 50
7134: PUSH
7135: EMPTY
7136: LIST
7137: PUSH
7138: LD_INT 3
7140: PUSH
7141: LD_INT 60
7143: PUSH
7144: EMPTY
7145: LIST
7146: PUSH
7147: EMPTY
7148: LIST
7149: LIST
7150: PUSH
7151: EMPTY
7152: LIST
7153: LIST
7154: LIST
7155: LIST
7156: PPUSH
7157: CALL_OW 70
7161: ST_TO_ADDR
// depots = FilterAllUnits ( [ [ f_side , 3 ] , [ f_ok ] , [ f_type , unit_building ] , [ f_not , [ f_constructed ] ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
7162: LD_ADDR_VAR 0 5
7166: PUSH
7167: LD_INT 22
7169: PUSH
7170: LD_INT 3
7172: PUSH
7173: EMPTY
7174: LIST
7175: LIST
7176: PUSH
7177: LD_INT 50
7179: PUSH
7180: EMPTY
7181: LIST
7182: PUSH
7183: LD_INT 21
7185: PUSH
7186: LD_INT 3
7188: PUSH
7189: EMPTY
7190: LIST
7191: LIST
7192: PUSH
7193: LD_INT 3
7195: PUSH
7196: LD_INT 57
7198: PUSH
7199: EMPTY
7200: LIST
7201: PUSH
7202: EMPTY
7203: LIST
7204: LIST
7205: PUSH
7206: LD_INT 2
7208: PUSH
7209: LD_INT 30
7211: PUSH
7212: LD_INT 0
7214: PUSH
7215: EMPTY
7216: LIST
7217: LIST
7218: PUSH
7219: LD_INT 30
7221: PUSH
7222: LD_INT 1
7224: PUSH
7225: EMPTY
7226: LIST
7227: LIST
7228: PUSH
7229: EMPTY
7230: LIST
7231: LIST
7232: LIST
7233: PUSH
7234: EMPTY
7235: LIST
7236: LIST
7237: LIST
7238: LIST
7239: LIST
7240: PPUSH
7241: CALL_OW 69
7245: ST_TO_ADDR
// barrelsAreaList = AreaToList ( BarrelsArea , 0 ) ;
7246: LD_ADDR_VAR 0 7
7250: PUSH
7251: LD_INT 13
7253: PPUSH
7254: LD_INT 0
7256: PPUSH
7257: CALL_OW 517
7261: ST_TO_ADDR
// if not depots or not unitsInArea then
7262: LD_VAR 0 5
7266: NOT
7267: PUSH
7268: LD_VAR 0 3
7272: NOT
7273: OR
7274: IFFALSE 7278
// exit ;
7276: GO 7714
// depot = depots [ 1 ] ;
7278: LD_ADDR_VAR 0 6
7282: PUSH
7283: LD_VAR 0 5
7287: PUSH
7288: LD_INT 1
7290: ARRAY
7291: ST_TO_ADDR
// for unit in unitsInArea do
7292: LD_ADDR_VAR 0 4
7296: PUSH
7297: LD_VAR 0 3
7301: PUSH
7302: FOR_IN
7303: IFFALSE 7712
// begin if not GetClass ( unit ) = class_engineer then
7305: LD_VAR 0 4
7309: PPUSH
7310: CALL_OW 257
7314: PUSH
7315: LD_INT 2
7317: EQUAL
7318: NOT
7319: IFFALSE 7356
// begin ComEnterUnit ( unit , depot ) ;
7321: LD_VAR 0 4
7325: PPUSH
7326: LD_VAR 0 6
7330: PPUSH
7331: CALL_OW 120
// AddComChangeProfession ( unit , class_engineer ) ;
7335: LD_VAR 0 4
7339: PPUSH
7340: LD_INT 2
7342: PPUSH
7343: CALL_OW 183
// AddComExitBuilding ( unit ) ;
7347: LD_VAR 0 4
7351: PPUSH
7352: CALL_OW 182
// end ; if GetCargo ( unit , mat_oil ) = 0 then
7356: LD_VAR 0 4
7360: PPUSH
7361: LD_INT 2
7363: PPUSH
7364: CALL_OW 289
7368: PUSH
7369: LD_INT 0
7371: EQUAL
7372: IFFALSE 7391
// AddComTransport ( unit , depot , mat_oil ) ;
7374: LD_VAR 0 4
7378: PPUSH
7379: LD_VAR 0 6
7383: PPUSH
7384: LD_INT 2
7386: PPUSH
7387: CALL_OW 211
// repeat wait ( 0 0$1 ) ;
7391: LD_INT 35
7393: PPUSH
7394: CALL_OW 67
// until not HasTask ( unit ) ;
7398: LD_VAR 0 4
7402: PPUSH
7403: CALL_OW 314
7407: NOT
7408: IFFALSE 7391
// if GetCargo ( unit , mat_oil ) > 0 then
7410: LD_VAR 0 4
7414: PPUSH
7415: LD_INT 2
7417: PPUSH
7418: CALL_OW 289
7422: PUSH
7423: LD_INT 0
7425: GREATER
7426: IFFALSE 7710
// begin randIndex = Rand ( 1 , barrelsAreaList [ 1 ] ) ;
7428: LD_ADDR_VAR 0 8
7432: PUSH
7433: LD_INT 1
7435: PPUSH
7436: LD_VAR 0 7
7440: PUSH
7441: LD_INT 1
7443: ARRAY
7444: PPUSH
7445: CALL_OW 12
7449: ST_TO_ADDR
// randPosX = barrelsAreaList [ 1 ] [ randIndex ] ;
7450: LD_ADDR_VAR 0 9
7454: PUSH
7455: LD_VAR 0 7
7459: PUSH
7460: LD_INT 1
7462: ARRAY
7463: PUSH
7464: LD_VAR 0 8
7468: ARRAY
7469: ST_TO_ADDR
// randPosY = barrelsAreaList [ 2 ] [ RandIndex ] ;
7470: LD_ADDR_VAR 0 10
7474: PUSH
7475: LD_VAR 0 7
7479: PUSH
7480: LD_INT 2
7482: ARRAY
7483: PUSH
7484: LD_VAR 0 8
7488: ARRAY
7489: ST_TO_ADDR
// AddComMoveXY ( unit , randPosX , randPosY ) ;
7490: LD_VAR 0 4
7494: PPUSH
7495: LD_VAR 0 9
7499: PPUSH
7500: LD_VAR 0 10
7504: PPUSH
7505: CALL_OW 171
// AddComUnload ( unit ) ;
7509: LD_VAR 0 4
7513: PPUSH
7514: CALL_OW 219
// AddComMoveXY ( unit , randPosX + 2 , randPosY + 2 ) ;
7518: LD_VAR 0 4
7522: PPUSH
7523: LD_VAR 0 9
7527: PUSH
7528: LD_INT 2
7530: PLUS
7531: PPUSH
7532: LD_VAR 0 10
7536: PUSH
7537: LD_INT 2
7539: PLUS
7540: PPUSH
7541: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
7545: LD_INT 35
7547: PPUSH
7548: CALL_OW 67
// until not HasTask ( unit ) ;
7552: LD_VAR 0 4
7556: PPUSH
7557: CALL_OW 314
7561: NOT
7562: IFFALSE 7545
// barrelsInArea = GetListOfCratesInArea ( ShootArea ) ;
7564: LD_ADDR_VAR 0 11
7568: PUSH
7569: LD_INT 12
7571: PPUSH
7572: CALL_OW 435
7576: ST_TO_ADDR
// for i := 1 to barrelsInArea / 2 do
7577: LD_ADDR_VAR 0 2
7581: PUSH
7582: DOUBLE
7583: LD_INT 1
7585: DEC
7586: ST_TO_ADDR
7587: LD_VAR 0 11
7591: PUSH
7592: LD_INT 2
7594: DIVREAL
7595: PUSH
7596: FOR_TO
7597: IFFALSE 7708
// begin if GetDistUnitXY ( unit , barrelsInArea [ i ] , barrelsInArea [ i + 1 ] ) <= 6 then
7599: LD_VAR 0 4
7603: PPUSH
7604: LD_VAR 0 11
7608: PUSH
7609: LD_VAR 0 2
7613: ARRAY
7614: PPUSH
7615: LD_VAR 0 11
7619: PUSH
7620: LD_VAR 0 2
7624: PUSH
7625: LD_INT 1
7627: PLUS
7628: ARRAY
7629: PPUSH
7630: CALL_OW 297
7634: PUSH
7635: LD_INT 6
7637: LESSEQUAL
7638: IFFALSE 7692
// begin AddComAttackPlace ( unit , barrelsInArea [ i ] , barrelsInArea [ i + 1 ] ) ;
7640: LD_VAR 0 4
7644: PPUSH
7645: LD_VAR 0 11
7649: PUSH
7650: LD_VAR 0 2
7654: ARRAY
7655: PPUSH
7656: LD_VAR 0 11
7660: PUSH
7661: LD_VAR 0 2
7665: PUSH
7666: LD_INT 1
7668: PLUS
7669: ARRAY
7670: PPUSH
7671: CALL_OW 176
// AddExperience ( unit , skill_combat , 5 ) ;
7675: LD_VAR 0 4
7679: PPUSH
7680: LD_INT 1
7682: PPUSH
7683: LD_INT 5
7685: PPUSH
7686: CALL_OW 492
// break ;
7690: GO 7708
// end ; i = i + 2 ;
7692: LD_ADDR_VAR 0 2
7696: PUSH
7697: LD_VAR 0 2
7701: PUSH
7702: LD_INT 2
7704: PLUS
7705: ST_TO_ADDR
// end ;
7706: GO 7596
7708: POP
7709: POP
// end ; end ;
7710: GO 7302
7712: POP
7713: POP
// end ;
7714: LD_VAR 0 1
7718: RET
// export function GoToHunt ( hunter ) ; var i , barracks , barrackTarget , barrackTargetCurrentHP , animals , animal ; begin
7719: LD_INT 0
7721: PPUSH
7722: PPUSH
7723: PPUSH
7724: PPUSH
7725: PPUSH
7726: PPUSH
7727: PPUSH
// animals = [ ] ;
7728: LD_ADDR_VAR 0 7
7732: PUSH
7733: EMPTY
7734: ST_TO_ADDR
// barracks = FilterAllUnits ( [ [ f_ok ] , [ f_not , [ f_constructed ] ] , [ f_or , [ f_btype , b_barracks ] , [ f_btype , b_armoury ] ] ] ) ;
7735: LD_ADDR_VAR 0 4
7739: PUSH
7740: LD_INT 50
7742: PUSH
7743: EMPTY
7744: LIST
7745: PUSH
7746: LD_INT 3
7748: PUSH
7749: LD_INT 57
7751: PUSH
7752: EMPTY
7753: LIST
7754: PUSH
7755: EMPTY
7756: LIST
7757: LIST
7758: PUSH
7759: LD_INT 2
7761: PUSH
7762: LD_INT 30
7764: PUSH
7765: LD_INT 5
7767: PUSH
7768: EMPTY
7769: LIST
7770: LIST
7771: PUSH
7772: LD_INT 30
7774: PUSH
7775: LD_INT 4
7777: PUSH
7778: EMPTY
7779: LIST
7780: LIST
7781: PUSH
7782: EMPTY
7783: LIST
7784: LIST
7785: LIST
7786: PUSH
7787: EMPTY
7788: LIST
7789: LIST
7790: LIST
7791: PPUSH
7792: CALL_OW 69
7796: ST_TO_ADDR
// SetSide ( hunter , 6 ) ;
7797: LD_VAR 0 1
7801: PPUSH
7802: LD_INT 6
7804: PPUSH
7805: CALL_OW 235
// if IsInUnit ( hunter ) then
7809: LD_VAR 0 1
7813: PPUSH
7814: CALL_OW 310
7818: IFFALSE 7860
// begin if GetBType ( IsInUnit ( hunter ) = unit_vehicle ) then
7820: LD_VAR 0 1
7824: PPUSH
7825: CALL_OW 310
7829: PUSH
7830: LD_INT 2
7832: EQUAL
7833: PPUSH
7834: CALL_OW 266
7838: IFFALSE 7851
// ComExitVehicle ( hunter ) else
7840: LD_VAR 0 1
7844: PPUSH
7845: CALL_OW 121
7849: GO 7860
// ComExitBuilding ( hunter ) ;
7851: LD_VAR 0 1
7855: PPUSH
7856: CALL_OW 122
// end ; ComWalk ( hunter ) ;
7860: LD_VAR 0 1
7864: PPUSH
7865: CALL_OW 138
// wait ( 0 0$1 ) ;
7869: LD_INT 35
7871: PPUSH
7872: CALL_OW 67
// if not GetClass ( hunter ) = class_soldier and barracks then
7876: LD_VAR 0 1
7880: PPUSH
7881: CALL_OW 257
7885: PUSH
7886: LD_INT 1
7888: EQUAL
7889: NOT
7890: PUSH
7891: LD_VAR 0 4
7895: AND
7896: IFFALSE 8039
// begin barrackTarget = barracks [ 1 ] ;
7898: LD_ADDR_VAR 0 5
7902: PUSH
7903: LD_VAR 0 4
7907: PUSH
7908: LD_INT 1
7910: ARRAY
7911: ST_TO_ADDR
// barrackTargetCurrentHP = GetLives ( barrackTarget ) ;
7912: LD_ADDR_VAR 0 6
7916: PUSH
7917: LD_VAR 0 5
7921: PPUSH
7922: CALL_OW 256
7926: ST_TO_ADDR
// SetSide ( barrackTarget , 6 ) ;
7927: LD_VAR 0 5
7931: PPUSH
7932: LD_INT 6
7934: PPUSH
7935: CALL_OW 235
// ComEnterUnit ( hunter , barrackTarget ) ;
7939: LD_VAR 0 1
7943: PPUSH
7944: LD_VAR 0 5
7948: PPUSH
7949: CALL_OW 120
// repeat wait ( 0 0$1 ) ;
7953: LD_INT 35
7955: PPUSH
7956: CALL_OW 67
// ComEnterUnit ( hunter , barrackTarget ) ;
7960: LD_VAR 0 1
7964: PPUSH
7965: LD_VAR 0 5
7969: PPUSH
7970: CALL_OW 120
// SetLives ( barrackTarget , barrackTargetCurrentHP ) ;
7974: LD_VAR 0 5
7978: PPUSH
7979: LD_VAR 0 6
7983: PPUSH
7984: CALL_OW 234
// until IsInUnit ( hunter ) ;
7988: LD_VAR 0 1
7992: PPUSH
7993: CALL_OW 310
7997: IFFALSE 7953
// SetClass ( hunter , class_soldier ) ;
7999: LD_VAR 0 1
8003: PPUSH
8004: LD_INT 1
8006: PPUSH
8007: CALL_OW 336
// ComExitBuilding ( hunter ) ;
8011: LD_VAR 0 1
8015: PPUSH
8016: CALL_OW 122
// SetSide ( barrackTarget , 3 ) ;
8020: LD_VAR 0 5
8024: PPUSH
8025: LD_INT 3
8027: PPUSH
8028: CALL_OW 235
// wait ( 0 0$1 ) ;
8032: LD_INT 35
8034: PPUSH
8035: CALL_OW 67
// end ; for i := 1 to 3 do
8039: LD_ADDR_VAR 0 3
8043: PUSH
8044: DOUBLE
8045: LD_INT 1
8047: DEC
8048: ST_TO_ADDR
8049: LD_INT 3
8051: PUSH
8052: FOR_TO
8053: IFFALSE 8158
// begin uc_side = 0 ;
8055: LD_ADDR_OWVAR 20
8059: PUSH
8060: LD_INT 0
8062: ST_TO_ADDR
// uc_nation = nation_nature ;
8063: LD_ADDR_OWVAR 21
8067: PUSH
8068: LD_INT 0
8070: ST_TO_ADDR
// PrepareHuman ( false , [ class_phororhacos , class_tiger , 21 ] [ Rand ( 1 , 3 ) ] , 0 ) ;
8071: LD_INT 0
8073: PPUSH
8074: LD_INT 18
8076: PUSH
8077: LD_INT 14
8079: PUSH
8080: LD_INT 21
8082: PUSH
8083: EMPTY
8084: LIST
8085: LIST
8086: LIST
8087: PUSH
8088: LD_INT 1
8090: PPUSH
8091: LD_INT 3
8093: PPUSH
8094: CALL_OW 12
8098: ARRAY
8099: PPUSH
8100: LD_INT 0
8102: PPUSH
8103: CALL_OW 380
// hc_agressivity = 0 ;
8107: LD_ADDR_OWVAR 35
8111: PUSH
8112: LD_INT 0
8114: ST_TO_ADDR
// animal = CreateHuman ;
8115: LD_ADDR_VAR 0 8
8119: PUSH
8120: CALL_OW 44
8124: ST_TO_ADDR
// PlaceUnitArea ( animal , NatureArea , false ) ;
8125: LD_VAR 0 8
8129: PPUSH
8130: LD_INT 5
8132: PPUSH
8133: LD_INT 0
8135: PPUSH
8136: CALL_OW 49
// animals = animals ^ animal ;
8140: LD_ADDR_VAR 0 7
8144: PUSH
8145: LD_VAR 0 7
8149: PUSH
8150: LD_VAR 0 8
8154: ADD
8155: ST_TO_ADDR
// end ;
8156: GO 8052
8158: POP
8159: POP
// for i := 1 to animals do
8160: LD_ADDR_VAR 0 3
8164: PUSH
8165: DOUBLE
8166: LD_INT 1
8168: DEC
8169: ST_TO_ADDR
8170: LD_VAR 0 7
8174: PUSH
8175: FOR_TO
8176: IFFALSE 8200
// AddComAttackUnit ( hunter , animals [ i ] ) ;
8178: LD_VAR 0 1
8182: PPUSH
8183: LD_VAR 0 7
8187: PUSH
8188: LD_VAR 0 3
8192: ARRAY
8193: PPUSH
8194: CALL_OW 175
8198: GO 8175
8200: POP
8201: POP
// repeat wait ( 0 0$1 ) ;
8202: LD_INT 35
8204: PPUSH
8205: CALL_OW 67
// if GetClass ( hunter ) = class_soldier then
8209: LD_VAR 0 1
8213: PPUSH
8214: CALL_OW 257
8218: PUSH
8219: LD_INT 1
8221: EQUAL
8222: IFFALSE 8269
// begin if GetDistUnits ( hunter , WantsToAttack ( hunter ) ) < 13 then
8224: LD_VAR 0 1
8228: PPUSH
8229: LD_VAR 0 1
8233: PPUSH
8234: CALL_OW 319
8238: PPUSH
8239: CALL_OW 296
8243: PUSH
8244: LD_INT 13
8246: LESS
8247: IFFALSE 8260
// ComCrawl ( hunter ) else
8249: LD_VAR 0 1
8253: PPUSH
8254: CALL_OW 137
8258: GO 8269
// ComWalk ( hunter ) ;
8260: LD_VAR 0 1
8264: PPUSH
8265: CALL_OW 138
// end ; until not HasTask ( hunter ) ;
8269: LD_VAR 0 1
8273: PPUSH
8274: CALL_OW 314
8278: NOT
8279: IFFALSE 8202
// repeat wait ( 0 0$1 ) ;
8281: LD_INT 35
8283: PPUSH
8284: CALL_OW 67
// ComMoveXY ( hunter , GetX ( Burlak ) , GetY ( Burlak ) ) ;
8288: LD_VAR 0 1
8292: PPUSH
8293: LD_EXP 57
8297: PPUSH
8298: CALL_OW 250
8302: PPUSH
8303: LD_EXP 57
8307: PPUSH
8308: CALL_OW 251
8312: PPUSH
8313: CALL_OW 111
// until GetDistUnits ( hunter , Burlak ) <= 9 ;
8317: LD_VAR 0 1
8321: PPUSH
8322: LD_EXP 57
8326: PPUSH
8327: CALL_OW 296
8331: PUSH
8332: LD_INT 9
8334: LESSEQUAL
8335: IFFALSE 8281
// SetSide ( hunter , 3 ) ;
8337: LD_VAR 0 1
8341: PPUSH
8342: LD_INT 3
8344: PPUSH
8345: CALL_OW 235
// CenterOnUnits ( hunter ) ;
8349: LD_VAR 0 1
8353: PPUSH
8354: CALL_OW 85
// AddExperience ( hunter , skill_combat , 3000 ) ;
8358: LD_VAR 0 1
8362: PPUSH
8363: LD_INT 1
8365: PPUSH
8366: LD_INT 3000
8368: PPUSH
8369: CALL_OW 492
// end ;
8373: LD_VAR 0 2
8377: RET
// export function SetMashaData ( vehicle ) ; begin
8378: LD_INT 0
8380: PPUSH
// if Masha then
8381: LD_EXP 4
8385: IFFALSE 8403
// SetMark ( Masha [ 1 ] , 0 ) ;
8387: LD_EXP 4
8391: PUSH
8392: LD_INT 1
8394: ARRAY
8395: PPUSH
8396: LD_INT 0
8398: PPUSH
8399: CALL_OW 242
// Masha = [ vehicle , GetChassis ( vehicle ) , GetEngine ( vehicle ) , GetControl ( vehicle ) , GetWeapon ( vehicle ) ] ;
8403: LD_ADDR_EXP 4
8407: PUSH
8408: LD_VAR 0 1
8412: PUSH
8413: LD_VAR 0 1
8417: PPUSH
8418: CALL_OW 265
8422: PUSH
8423: LD_VAR 0 1
8427: PPUSH
8428: CALL_OW 262
8432: PUSH
8433: LD_VAR 0 1
8437: PPUSH
8438: CALL_OW 263
8442: PUSH
8443: LD_VAR 0 1
8447: PPUSH
8448: CALL_OW 264
8452: PUSH
8453: EMPTY
8454: LIST
8455: LIST
8456: LIST
8457: LIST
8458: LIST
8459: ST_TO_ADDR
// ChangeMissionObjectives ( MMashaDone ) ;
8460: LD_STRING MMashaDone
8462: PPUSH
8463: CALL_OW 337
// SetMark ( vehicle , 1 ) ;
8467: LD_VAR 0 1
8471: PPUSH
8472: LD_INT 1
8474: PPUSH
8475: CALL_OW 242
// end ;
8479: LD_VAR 0 2
8483: RET
// export function SaveBase ( buildings , ident ) ; var i , buildingsToSave ; begin
8484: LD_INT 0
8486: PPUSH
8487: PPUSH
8488: PPUSH
// buildingsToSave = [ ] ;
8489: LD_ADDR_VAR 0 5
8493: PUSH
8494: EMPTY
8495: ST_TO_ADDR
// if not buildings then
8496: LD_VAR 0 1
8500: NOT
8501: IFFALSE 8505
// exit ;
8503: GO 9080
// for i in buildings do
8505: LD_ADDR_VAR 0 4
8509: PUSH
8510: LD_VAR 0 1
8514: PUSH
8515: FOR_IN
8516: IFFALSE 9064
// begin if GetBType ( i ) in [ b_lab , b_lab_half , b_lab_full ] then
8518: LD_VAR 0 4
8522: PPUSH
8523: CALL_OW 266
8527: PUSH
8528: LD_INT 6
8530: PUSH
8531: LD_INT 7
8533: PUSH
8534: LD_INT 8
8536: PUSH
8537: EMPTY
8538: LIST
8539: LIST
8540: LIST
8541: IN
8542: IFFALSE 8667
// buildingsToSave = buildingsToSave ^ [ [ GetBType ( i ) , GetX ( i ) , GetY ( i ) , GetDir ( i ) , GetBLevel ( i ) , GetNation ( i ) , GetLives ( i ) , GetLabKind ( i , 1 ) , GetLabKind ( i , 2 ) ] ] else
8544: LD_ADDR_VAR 0 5
8548: PUSH
8549: LD_VAR 0 5
8553: PUSH
8554: LD_VAR 0 4
8558: PPUSH
8559: CALL_OW 266
8563: PUSH
8564: LD_VAR 0 4
8568: PPUSH
8569: CALL_OW 250
8573: PUSH
8574: LD_VAR 0 4
8578: PPUSH
8579: CALL_OW 251
8583: PUSH
8584: LD_VAR 0 4
8588: PPUSH
8589: CALL_OW 254
8593: PUSH
8594: LD_VAR 0 4
8598: PPUSH
8599: CALL_OW 267
8603: PUSH
8604: LD_VAR 0 4
8608: PPUSH
8609: CALL_OW 248
8613: PUSH
8614: LD_VAR 0 4
8618: PPUSH
8619: CALL_OW 256
8623: PUSH
8624: LD_VAR 0 4
8628: PPUSH
8629: LD_INT 1
8631: PPUSH
8632: CALL_OW 268
8636: PUSH
8637: LD_VAR 0 4
8641: PPUSH
8642: LD_INT 2
8644: PPUSH
8645: CALL_OW 268
8649: PUSH
8650: EMPTY
8651: LIST
8652: LIST
8653: LIST
8654: LIST
8655: LIST
8656: LIST
8657: LIST
8658: LIST
8659: LIST
8660: PUSH
8661: EMPTY
8662: LIST
8663: ADD
8664: ST_TO_ADDR
8665: GO 9062
// if GetBType ( i ) in [ b_bunker , b_turret ] then
8667: LD_VAR 0 4
8671: PPUSH
8672: CALL_OW 266
8676: PUSH
8677: LD_INT 32
8679: PUSH
8680: LD_INT 33
8682: PUSH
8683: EMPTY
8684: LIST
8685: LIST
8686: IN
8687: IFFALSE 8795
// buildingsToSave = buildingsToSave ^ [ [ GetBType ( i ) , GetX ( i ) , GetY ( i ) , GetDir ( i ) , GetBLevel ( i ) , GetNation ( i ) , GetLives ( i ) , GetBWeapon ( i ) ] ] else
8689: LD_ADDR_VAR 0 5
8693: PUSH
8694: LD_VAR 0 5
8698: PUSH
8699: LD_VAR 0 4
8703: PPUSH
8704: CALL_OW 266
8708: PUSH
8709: LD_VAR 0 4
8713: PPUSH
8714: CALL_OW 250
8718: PUSH
8719: LD_VAR 0 4
8723: PPUSH
8724: CALL_OW 251
8728: PUSH
8729: LD_VAR 0 4
8733: PPUSH
8734: CALL_OW 254
8738: PUSH
8739: LD_VAR 0 4
8743: PPUSH
8744: CALL_OW 267
8748: PUSH
8749: LD_VAR 0 4
8753: PPUSH
8754: CALL_OW 248
8758: PUSH
8759: LD_VAR 0 4
8763: PPUSH
8764: CALL_OW 256
8768: PUSH
8769: LD_VAR 0 4
8773: PPUSH
8774: CALL_OW 269
8778: PUSH
8779: EMPTY
8780: LIST
8781: LIST
8782: LIST
8783: LIST
8784: LIST
8785: LIST
8786: LIST
8787: LIST
8788: PUSH
8789: EMPTY
8790: LIST
8791: ADD
8792: ST_TO_ADDR
8793: GO 9062
// if GetBType ( i ) in [ b_depot , b_warehouse ] then
8795: LD_VAR 0 4
8799: PPUSH
8800: CALL_OW 266
8804: PUSH
8805: LD_INT 0
8807: PUSH
8808: LD_INT 1
8810: PUSH
8811: EMPTY
8812: LIST
8813: LIST
8814: IN
8815: IFFALSE 8969
// buildingsToSave = buildingsToSave ^ [ [ GetBType ( i ) , GetX ( i ) , GetY ( i ) , GetDir ( i ) , GetBLevel ( i ) , GetNation ( i ) , GetLives ( i ) , GetResourceType ( GetBase ( i ) , mat_cans ) , GetResourceType ( GetBase ( i ) , mat_oil ) , GetResourceType ( GetBase ( i ) , mat_siberit ) ] ] else
8817: LD_ADDR_VAR 0 5
8821: PUSH
8822: LD_VAR 0 5
8826: PUSH
8827: LD_VAR 0 4
8831: PPUSH
8832: CALL_OW 266
8836: PUSH
8837: LD_VAR 0 4
8841: PPUSH
8842: CALL_OW 250
8846: PUSH
8847: LD_VAR 0 4
8851: PPUSH
8852: CALL_OW 251
8856: PUSH
8857: LD_VAR 0 4
8861: PPUSH
8862: CALL_OW 254
8866: PUSH
8867: LD_VAR 0 4
8871: PPUSH
8872: CALL_OW 267
8876: PUSH
8877: LD_VAR 0 4
8881: PPUSH
8882: CALL_OW 248
8886: PUSH
8887: LD_VAR 0 4
8891: PPUSH
8892: CALL_OW 256
8896: PUSH
8897: LD_VAR 0 4
8901: PPUSH
8902: CALL_OW 274
8906: PPUSH
8907: LD_INT 1
8909: PPUSH
8910: CALL_OW 275
8914: PUSH
8915: LD_VAR 0 4
8919: PPUSH
8920: CALL_OW 274
8924: PPUSH
8925: LD_INT 2
8927: PPUSH
8928: CALL_OW 275
8932: PUSH
8933: LD_VAR 0 4
8937: PPUSH
8938: CALL_OW 274
8942: PPUSH
8943: LD_INT 3
8945: PPUSH
8946: CALL_OW 275
8950: PUSH
8951: EMPTY
8952: LIST
8953: LIST
8954: LIST
8955: LIST
8956: LIST
8957: LIST
8958: LIST
8959: LIST
8960: LIST
8961: LIST
8962: PUSH
8963: EMPTY
8964: LIST
8965: ADD
8966: ST_TO_ADDR
8967: GO 9062
// buildingsToSave = buildingsToSave ^ [ [ GetBType ( i ) , GetX ( i ) , GetY ( i ) , GetDir ( i ) , GetBLevel ( i ) , GetNation ( i ) , GetLives ( i ) ] ] ;
8969: LD_ADDR_VAR 0 5
8973: PUSH
8974: LD_VAR 0 5
8978: PUSH
8979: LD_VAR 0 4
8983: PPUSH
8984: CALL_OW 266
8988: PUSH
8989: LD_VAR 0 4
8993: PPUSH
8994: CALL_OW 250
8998: PUSH
8999: LD_VAR 0 4
9003: PPUSH
9004: CALL_OW 251
9008: PUSH
9009: LD_VAR 0 4
9013: PPUSH
9014: CALL_OW 254
9018: PUSH
9019: LD_VAR 0 4
9023: PPUSH
9024: CALL_OW 267
9028: PUSH
9029: LD_VAR 0 4
9033: PPUSH
9034: CALL_OW 248
9038: PUSH
9039: LD_VAR 0 4
9043: PPUSH
9044: CALL_OW 256
9048: PUSH
9049: EMPTY
9050: LIST
9051: LIST
9052: LIST
9053: LIST
9054: LIST
9055: LIST
9056: LIST
9057: PUSH
9058: EMPTY
9059: LIST
9060: ADD
9061: ST_TO_ADDR
// end ;
9062: GO 8515
9064: POP
9065: POP
// SaveVariable ( buildingsToSave , ident ) ;
9066: LD_VAR 0 5
9070: PPUSH
9071: LD_VAR 0 2
9075: PPUSH
9076: CALL_OW 39
// end ; end_of_file
9080: LD_VAR 0 3
9084: RET
// export function MissionIntro ; begin
9085: LD_INT 0
9087: PPUSH
// CenterNowOnUnits ( Burlak ) ;
9088: LD_EXP 57
9092: PPUSH
9093: CALL_OW 87
// DialogueOn ;
9097: CALL_OW 6
// SayRadio ( Popov , DStart-Pop-1 ) ;
9101: LD_EXP 76
9105: PPUSH
9106: LD_STRING DStart-Pop-1
9108: PPUSH
9109: CALL_OW 94
// Say ( Burlak , DStart-Bur-1 ) ;
9113: LD_EXP 57
9117: PPUSH
9118: LD_STRING DStart-Bur-1
9120: PPUSH
9121: CALL_OW 88
// DialogueOff ;
9125: CALL_OW 7
// IngameOff ;
9129: CALL_OW 9
// ChangeMissionObjectives ( MStart ) ;
9133: LD_STRING MStart
9135: PPUSH
9136: CALL_OW 337
// SaveForQuickRestart ;
9140: CALL_OW 22
// end ;
9144: LD_VAR 0 1
9148: RET
// export function Dial_EscortHeike ( x , y ) ; begin
9149: LD_INT 0
9151: PPUSH
// dial_BuildDepotBlocker = true ;
9152: LD_ADDR_EXP 5
9156: PUSH
9157: LD_INT 1
9159: ST_TO_ADDR
// HeikeTargetX = x ;
9160: LD_ADDR_EXP 14
9164: PUSH
9165: LD_VAR 0 1
9169: ST_TO_ADDR
// HeikeTargetY = y ;
9170: LD_ADDR_EXP 15
9174: PUSH
9175: LD_VAR 0 2
9179: ST_TO_ADDR
// SayRadio ( Popov , DHeike-Pop-1 ) ;
9180: LD_EXP 76
9184: PPUSH
9185: LD_STRING DHeike-Pop-1
9187: PPUSH
9188: CALL_OW 94
// wait ( 0 0$10 ) ;
9192: LD_INT 350
9194: PPUSH
9195: CALL_OW 67
// PrepareRussianEscort ;
9199: CALL 2320 0 0
// PlaceUnitArea ( Heike , RussianSpawn2Area , false ) ;
9203: LD_EXP 79
9207: PPUSH
9208: LD_INT 7
9210: PPUSH
9211: LD_INT 0
9213: PPUSH
9214: CALL_OW 49
// ComMoveXY ( russianEscort , HeikeTargetX , HeikeTargetY ) ;
9218: LD_EXP 77
9222: PPUSH
9223: LD_EXP 14
9227: PPUSH
9228: LD_EXP 15
9232: PPUSH
9233: CALL_OW 111
// AddComMoveToArea ( russianEscort , RussianSpawn2Area ) ;
9237: LD_EXP 77
9241: PPUSH
9242: LD_INT 7
9244: PPUSH
9245: CALL_OW 173
// ComMoveXY ( Heike , HeikeTargetX , HeikeTargetY ) ;
9249: LD_EXP 79
9253: PPUSH
9254: LD_EXP 14
9258: PPUSH
9259: LD_EXP 15
9263: PPUSH
9264: CALL_OW 111
// AddComHold ( Heike ) ;
9268: LD_EXP 79
9272: PPUSH
9273: CALL_OW 200
// end ;
9277: LD_VAR 0 3
9281: RET
// every 1 trigger GetDistUnitXY ( Heike , HeikeTargetX , HeikeTargetY ) <= 5 do
9282: LD_EXP 79
9286: PPUSH
9287: LD_EXP 14
9291: PPUSH
9292: LD_EXP 15
9296: PPUSH
9297: CALL_OW 297
9301: PUSH
9302: LD_INT 5
9304: LESSEQUAL
9305: IFFALSE 9318
9307: GO 9309
9309: DISABLE
// allowExitFromMap = 1 ;
9310: LD_ADDR_EXP 18
9314: PUSH
9315: LD_INT 1
9317: ST_TO_ADDR
9318: END
// every 7 7$0 trigger IsPlaced ( Heike ) and IsOk ( Heike ) and GetAttitude ( 3 , 5 ) = att_friend and HeikeCaptured do
9319: LD_EXP 79
9323: PPUSH
9324: CALL_OW 305
9328: PUSH
9329: LD_EXP 79
9333: PPUSH
9334: CALL_OW 302
9338: AND
9339: PUSH
9340: LD_INT 3
9342: PPUSH
9343: LD_INT 5
9345: PPUSH
9346: CALL_OW 81
9350: PUSH
9351: LD_INT 1
9353: EQUAL
9354: AND
9355: PUSH
9356: LD_EXP 1
9360: AND
9361: IFFALSE 9580
9363: GO 9365
9365: DISABLE
// begin DialogueOn ;
9366: CALL_OW 6
// SayRadio ( Kurt , DMercHelp-Kurt-1 ) ;
9370: LD_EXP 80
9374: PPUSH
9375: LD_STRING DMercHelp-Kurt-1
9377: PPUSH
9378: CALL_OW 94
// Say ( Burlak , DMercHelp-Bur-1 ) ;
9382: LD_EXP 57
9386: PPUSH
9387: LD_STRING DMercHelp-Bur-1
9389: PPUSH
9390: CALL_OW 88
// SayRadio ( Kurt , DMercHelp-Kurt-2 ) ;
9394: LD_EXP 80
9398: PPUSH
9399: LD_STRING DMercHelp-Kurt-2
9401: PPUSH
9402: CALL_OW 94
// Say ( Burlak , DMercHelp-Bur-2 ) ;
9406: LD_EXP 57
9410: PPUSH
9411: LD_STRING DMercHelp-Bur-2
9413: PPUSH
9414: CALL_OW 88
// SayRadio ( Kurt , DMercHelp-Kurt-3 ) ;
9418: LD_EXP 80
9422: PPUSH
9423: LD_STRING DMercHelp-Kurt-3
9425: PPUSH
9426: CALL_OW 94
// case Query ( QMerc ) of 1 :
9430: LD_STRING QMerc
9432: PPUSH
9433: CALL_OW 97
9437: PUSH
9438: LD_INT 1
9440: DOUBLE
9441: EQUAL
9442: IFTRUE 9446
9444: GO 9481
9446: POP
// begin Say ( Burlak , DQrMerc#1-Bur-1 ) ;
9447: LD_EXP 57
9451: PPUSH
9452: LD_STRING DQrMerc#1-Bur-1
9454: PPUSH
9455: CALL_OW 88
// SayRadio ( Kurt , DQrMerc#1-Kurt-1 ) ;
9459: LD_EXP 80
9463: PPUSH
9464: LD_STRING DQrMerc#1-Kurt-1
9466: PPUSH
9467: CALL_OW 94
// acceptKurtOffert = true ;
9471: LD_ADDR_EXP 19
9475: PUSH
9476: LD_INT 1
9478: ST_TO_ADDR
// end ; 2 :
9479: GO 9576
9481: LD_INT 2
9483: DOUBLE
9484: EQUAL
9485: IFTRUE 9489
9487: GO 9544
9489: POP
// begin askCommanders = true ;
9490: LD_ADDR_EXP 20
9494: PUSH
9495: LD_INT 1
9497: ST_TO_ADDR
// Say ( Burlak , DQrMerc#2-Bur-1 ) ;
9498: LD_EXP 57
9502: PPUSH
9503: LD_STRING DQrMerc#2-Bur-1
9505: PPUSH
9506: CALL_OW 88
// SayRadio ( Popov , DQrMerc#2-Pop-1 ) ;
9510: LD_EXP 76
9514: PPUSH
9515: LD_STRING DQrMerc#2-Pop-1
9517: PPUSH
9518: CALL_OW 94
// Say ( Burlak , DQrMerc#2-Bur-2 ) ;
9522: LD_EXP 57
9526: PPUSH
9527: LD_STRING DQrMerc#2-Bur-2
9529: PPUSH
9530: CALL_OW 88
// acceptKurtOffert = true ;
9534: LD_ADDR_EXP 19
9538: PUSH
9539: LD_INT 1
9541: ST_TO_ADDR
// end ; 3 :
9542: GO 9576
9544: LD_INT 3
9546: DOUBLE
9547: EQUAL
9548: IFTRUE 9552
9550: GO 9575
9552: POP
// begin Say ( Burlak , DQrMerc#3-Bur-1 ) ;
9553: LD_EXP 57
9557: PPUSH
9558: LD_STRING DQrMerc#3-Bur-1
9560: PPUSH
9561: CALL_OW 88
// KurtAttack = true ;
9565: LD_ADDR_EXP 25
9569: PUSH
9570: LD_INT 1
9572: ST_TO_ADDR
// end ; end ;
9573: GO 9576
9575: POP
// DialogueOff ;
9576: CALL_OW 7
// end ;
9580: END
// every 0 0$1 trigger acceptKurtOffert do
9581: LD_EXP 19
9585: IFFALSE 9741
9587: GO 9589
9589: DISABLE
// begin PlaceUnitArea ( Kurt , KurtSpawnArea , false ) ;
9590: LD_EXP 80
9594: PPUSH
9595: LD_INT 9
9597: PPUSH
9598: LD_INT 0
9600: PPUSH
9601: CALL_OW 49
// uc_side = 8 ;
9605: LD_ADDR_OWVAR 20
9609: PUSH
9610: LD_INT 8
9612: ST_TO_ADDR
// uc_nation = 2 ;
9613: LD_ADDR_OWVAR 21
9617: PUSH
9618: LD_INT 2
9620: ST_TO_ADDR
// PrepareEngineer ( false , 3 ) ;
9621: LD_INT 0
9623: PPUSH
9624: LD_INT 3
9626: PPUSH
9627: CALL_OW 382
// KurtEng = CreateHuman ;
9631: LD_ADDR_EXP 82
9635: PUSH
9636: CALL_OW 44
9640: ST_TO_ADDR
// PlaceUnitArea ( KurtEng , KurtSpawnArea , false ) ;
9641: LD_EXP 82
9645: PPUSH
9646: LD_INT 9
9648: PPUSH
9649: LD_INT 0
9651: PPUSH
9652: CALL_OW 49
// repeat wait ( 0 0$1 ) ;
9656: LD_INT 35
9658: PPUSH
9659: CALL_OW 67
// ComMoveXY ( [ Kurt , KurtEng ] , GetX ( Burlak ) , GetY ( Burlak ) ) ;
9663: LD_EXP 80
9667: PUSH
9668: LD_EXP 82
9672: PUSH
9673: EMPTY
9674: LIST
9675: LIST
9676: PPUSH
9677: LD_EXP 57
9681: PPUSH
9682: CALL_OW 250
9686: PPUSH
9687: LD_EXP 57
9691: PPUSH
9692: CALL_OW 251
9696: PPUSH
9697: CALL_OW 111
// until GetDistUnits ( Kurt , Burlak ) <= 5 or GetDistUnits ( KurtEng , Burlak ) <= 5 ;
9701: LD_EXP 80
9705: PPUSH
9706: LD_EXP 57
9710: PPUSH
9711: CALL_OW 296
9715: PUSH
9716: LD_INT 5
9718: LESSEQUAL
9719: PUSH
9720: LD_EXP 82
9724: PPUSH
9725: LD_EXP 57
9729: PPUSH
9730: CALL_OW 296
9734: PUSH
9735: LD_INT 5
9737: LESSEQUAL
9738: OR
9739: IFFALSE 9656
// end ;
9741: END
// every 0 0$1 trigger GetDistUnits ( Kurt , Burlak ) <= 5 or GetDistUnits ( KurtEng , Burlak ) <= 5 do
9742: LD_EXP 80
9746: PPUSH
9747: LD_EXP 57
9751: PPUSH
9752: CALL_OW 296
9756: PUSH
9757: LD_INT 5
9759: LESSEQUAL
9760: PUSH
9761: LD_EXP 82
9765: PPUSH
9766: LD_EXP 57
9770: PPUSH
9771: CALL_OW 296
9775: PUSH
9776: LD_INT 5
9778: LESSEQUAL
9779: OR
9780: IFFALSE 9959
9782: GO 9784
9784: DISABLE
// begin KurtWaitingForBuildBarrack = true ;
9785: LD_ADDR_EXP 24
9789: PUSH
9790: LD_INT 1
9792: ST_TO_ADDR
// SetSide ( KurtEng , 3 ) ;
9793: LD_EXP 82
9797: PPUSH
9798: LD_INT 3
9800: PPUSH
9801: CALL_OW 235
// wait ( 1 1$30 ) ;
9805: LD_INT 3150
9807: PPUSH
9808: CALL_OW 67
// DialogueOn ;
9812: CALL_OW 6
// SayRadio ( Dietrich , DArabianRequest-Diet-1 ) ;
9816: LD_EXP 81
9820: PPUSH
9821: LD_STRING DArabianRequest-Diet-1
9823: PPUSH
9824: CALL_OW 94
// Say ( Burlak , DArabianRequest-Bur-1 ) ;
9828: LD_EXP 57
9832: PPUSH
9833: LD_STRING DArabianRequest-Bur-1
9835: PPUSH
9836: CALL_OW 88
// SayRadio ( Dietrich , DArabianRequest-Diet-2 ) ;
9840: LD_EXP 81
9844: PPUSH
9845: LD_STRING DArabianRequest-Diet-2
9847: PPUSH
9848: CALL_OW 94
// DialogueOff ;
9852: CALL_OW 7
// case Query ( QHandOver ) of 1 :
9856: LD_STRING QHandOver
9858: PPUSH
9859: CALL_OW 97
9863: PUSH
9864: LD_INT 1
9866: DOUBLE
9867: EQUAL
9868: IFTRUE 9872
9870: GO 9911
9872: POP
// begin Say ( Burlak , DQrHandOver#1-Bur-1 ) ;
9873: LD_EXP 57
9877: PPUSH
9878: LD_STRING DQrHandOver#1-Bur-1
9880: PPUSH
9881: CALL_OW 88
// SayRadio ( Dietrich , DQrHandOver#1-Diet-1 ) ;
9885: LD_EXP 81
9889: PPUSH
9890: LD_STRING DQrHandOver#1-Diet-1
9892: PPUSH
9893: CALL_OW 94
// coopWithGensher = true ;
9897: LD_ADDR_EXP 2
9901: PUSH
9902: LD_INT 1
9904: ST_TO_ADDR
// SpawnGensherTeam ;
9905: CALL 3946 0 0
// end ; 2 :
9909: GO 9959
9911: LD_INT 2
9913: DOUBLE
9914: EQUAL
9915: IFTRUE 9919
9917: GO 9958
9919: POP
// begin Say ( Burlak , DQrHandOver#2-Bur-1 ) ;
9920: LD_EXP 57
9924: PPUSH
9925: LD_STRING DQrHandOver#2-Bur-1
9927: PPUSH
9928: CALL_OW 88
// SayRadio ( Dietrich , DQrHandOver#2-Diet-1 ) ;
9932: LD_EXP 81
9936: PPUSH
9937: LD_STRING DQrHandOver#2-Diet-1
9939: PPUSH
9940: CALL_OW 94
// Say ( Burlak , DQrHandOver#2-Bur-2 ) ;
9944: LD_EXP 57
9948: PPUSH
9949: LD_STRING DQrHandOver#2-Bur-2
9951: PPUSH
9952: CALL_OW 88
// end ; end ;
9956: GO 9959
9958: POP
// end ;
9959: END
// export function Dial_UpgradeArmoury ; begin
9960: LD_INT 0
9962: PPUSH
// dial_BuildArBarrackBlocker = true ;
9963: LD_ADDR_EXP 6
9967: PUSH
9968: LD_INT 1
9970: ST_TO_ADDR
// buildArabBarrack = true ;
9971: LD_ADDR_EXP 38
9975: PUSH
9976: LD_INT 1
9978: ST_TO_ADDR
// if GetSide ( Kurt ) = 2 or GetSide ( KurtEng ) = 8 then
9979: LD_EXP 80
9983: PPUSH
9984: CALL_OW 255
9988: PUSH
9989: LD_INT 2
9991: EQUAL
9992: PUSH
9993: LD_EXP 82
9997: PPUSH
9998: CALL_OW 255
10002: PUSH
10003: LD_INT 8
10005: EQUAL
10006: OR
10007: IFFALSE 10011
// exit ;
10009: GO 10111
// SetSide ( KurtEng , 8 ) ;
10011: LD_EXP 82
10015: PPUSH
10016: LD_INT 8
10018: PPUSH
10019: CALL_OW 235
// ComStop ( KurtEng ) ;
10023: LD_EXP 82
10027: PPUSH
10028: CALL_OW 141
// DialogueOn ;
10032: CALL_OW 6
// Say ( Kurt , DMercCompleted-Kurt-1 ) ;
10036: LD_EXP 80
10040: PPUSH
10041: LD_STRING DMercCompleted-Kurt-1
10043: PPUSH
10044: CALL_OW 88
// DialogueOff ;
10048: CALL_OW 7
// canSendHeike = true ;
10052: LD_ADDR_EXP 28
10056: PUSH
10057: LD_INT 1
10059: ST_TO_ADDR
// KurtWaitingForFreeHeike = true ;
10060: LD_ADDR_EXP 23
10064: PUSH
10065: LD_INT 1
10067: ST_TO_ADDR
// KurtWaitingForBuildBarrack = false ;
10068: LD_ADDR_EXP 24
10072: PUSH
10073: LD_INT 0
10075: ST_TO_ADDR
// allowExitFromMap = 3 ;
10076: LD_ADDR_EXP 18
10080: PUSH
10081: LD_INT 3
10083: ST_TO_ADDR
// if KurtCanEscape then
10084: LD_EXP 21
10088: IFFALSE 10111
// ComMoveToArea ( [ Kurt , KurtEng ] , KurtExitMapArea ) ;
10090: LD_EXP 80
10094: PUSH
10095: LD_EXP 82
10099: PUSH
10100: EMPTY
10101: LIST
10102: LIST
10103: PPUSH
10104: LD_INT 11
10106: PPUSH
10107: CALL_OW 113
// end ;
10111: LD_VAR 0 1
10115: RET
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 2 ] ] ) and not dial_ArriveGensherUnitsBlocker do var veh , nearGensherUnit , maleSold , waitForKurt ;
10116: LD_INT 22
10118: PUSH
10119: LD_INT 2
10121: PUSH
10122: EMPTY
10123: LIST
10124: LIST
10125: PUSH
10126: EMPTY
10127: LIST
10128: PPUSH
10129: CALL_OW 69
10133: PUSH
10134: LD_EXP 7
10138: NOT
10139: AND
10140: IFFALSE 10913
10142: GO 10144
10144: DISABLE
10145: LD_INT 0
10147: PPUSH
10148: PPUSH
10149: PPUSH
10150: PPUSH
// begin nearGensherUnit = NearestUnitToXY ( UnitFilter ( GensherTeam , [ [ f_type , unit_vehicle ] ] ) , GensherTargetX , GensherTargetY ) ;
10151: LD_ADDR_VAR 0 2
10155: PUSH
10156: LD_EXP 83
10160: PPUSH
10161: LD_INT 21
10163: PUSH
10164: LD_INT 2
10166: PUSH
10167: EMPTY
10168: LIST
10169: LIST
10170: PUSH
10171: EMPTY
10172: LIST
10173: PPUSH
10174: CALL_OW 72
10178: PPUSH
10179: LD_EXP 16
10183: PPUSH
10184: LD_EXP 17
10188: PPUSH
10189: CALL_OW 73
10193: ST_TO_ADDR
// maleSold = UnitsInside ( nearGensherUnit [ 1 ] ) ;
10194: LD_ADDR_VAR 0 3
10198: PUSH
10199: LD_VAR 0 2
10203: PUSH
10204: LD_INT 1
10206: ARRAY
10207: PPUSH
10208: CALL_OW 313
10212: ST_TO_ADDR
// if GetDistUnitXY ( nearGensherUnit , GensherTargetX , GensherTargetY ) <= 5 then
10213: LD_VAR 0 2
10217: PPUSH
10218: LD_EXP 16
10222: PPUSH
10223: LD_EXP 17
10227: PPUSH
10228: CALL_OW 297
10232: PUSH
10233: LD_INT 5
10235: LESSEQUAL
10236: IFFALSE 10912
// begin dial_ArriveGensherUnitsBlocker = true ;
10238: LD_ADDR_EXP 7
10242: PUSH
10243: LD_INT 1
10245: ST_TO_ADDR
// for veh in UnitFilter ( GensherTeam , [ [ f_type , unit_vehicle ] ] ) do
10246: LD_ADDR_VAR 0 1
10250: PUSH
10251: LD_EXP 83
10255: PPUSH
10256: LD_INT 21
10258: PUSH
10259: LD_INT 2
10261: PUSH
10262: EMPTY
10263: LIST
10264: LIST
10265: PUSH
10266: EMPTY
10267: LIST
10268: PPUSH
10269: CALL_OW 72
10273: PUSH
10274: FOR_IN
10275: IFFALSE 10297
// ComExitVehicle ( UnitsInside ( veh ) [ 1 ] ) ;
10277: LD_VAR 0 1
10281: PPUSH
10282: CALL_OW 313
10286: PUSH
10287: LD_INT 1
10289: ARRAY
10290: PPUSH
10291: CALL_OW 121
10295: GO 10274
10297: POP
10298: POP
// wait ( 0 0$1 ) ;
10299: LD_INT 35
10301: PPUSH
10302: CALL_OW 67
// SetSide ( UnitFilter ( GensherTeam , [ [ f_type , unit_vehicle ] ] ) , 3 ) ;
10306: LD_EXP 83
10310: PPUSH
10311: LD_INT 21
10313: PUSH
10314: LD_INT 2
10316: PUSH
10317: EMPTY
10318: LIST
10319: LIST
10320: PUSH
10321: EMPTY
10322: LIST
10323: PPUSH
10324: CALL_OW 72
10328: PPUSH
10329: LD_INT 3
10331: PPUSH
10332: CALL_OW 235
// CenterOnUnits ( maleSold ) ;
10336: LD_VAR 0 3
10340: PPUSH
10341: CALL_OW 85
// DialogueOn ;
10345: CALL_OW 6
// Say ( maleSold , DHandOverCome-ASol1-1 ) ;
10349: LD_VAR 0 3
10353: PPUSH
10354: LD_STRING DHandOverCome-ASol1-1
10356: PPUSH
10357: CALL_OW 88
// Say ( Kurt , DHandOverCome-Kurt-1 ) ;
10361: LD_EXP 80
10365: PPUSH
10366: LD_STRING DHandOverCome-Kurt-1
10368: PPUSH
10369: CALL_OW 88
// DialogueOff ;
10373: CALL_OW 7
// KurtWaitingForBuildBarrack = false ;
10377: LD_ADDR_EXP 24
10381: PUSH
10382: LD_INT 0
10384: ST_TO_ADDR
// if GetDistUnits ( Kurt , UnitFilter ( GensherTeam , [ f_type , unit_vehicle ] ) [ 1 ] ) <= 8 or GetSide ( KurtEng ) = 3 then
10385: LD_EXP 80
10389: PPUSH
10390: LD_EXP 83
10394: PPUSH
10395: LD_INT 21
10397: PUSH
10398: LD_INT 2
10400: PUSH
10401: EMPTY
10402: LIST
10403: LIST
10404: PPUSH
10405: CALL_OW 72
10409: PUSH
10410: LD_INT 1
10412: ARRAY
10413: PPUSH
10414: CALL_OW 296
10418: PUSH
10419: LD_INT 8
10421: LESSEQUAL
10422: PUSH
10423: LD_EXP 82
10427: PPUSH
10428: CALL_OW 255
10432: PUSH
10433: LD_INT 3
10435: EQUAL
10436: OR
10437: IFFALSE 10542
// begin KurtCanEscape = false ;
10439: LD_ADDR_EXP 21
10443: PUSH
10444: LD_INT 0
10446: ST_TO_ADDR
// SetSide ( [ Kurt , KurtEng ] , 2 ) ;
10447: LD_EXP 80
10451: PUSH
10452: LD_EXP 82
10456: PUSH
10457: EMPTY
10458: LIST
10459: LIST
10460: PPUSH
10461: LD_INT 2
10463: PPUSH
10464: CALL_OW 235
// ComStop ( [ Kurt , KurtEng ] ) ;
10468: LD_EXP 80
10472: PUSH
10473: LD_EXP 82
10477: PUSH
10478: EMPTY
10479: LIST
10480: LIST
10481: PPUSH
10482: CALL_OW 141
// ComMoveXY ( [ Kurt , KurtEng ] , GetX ( maleSold ) , GetY ( maleSold ) ) ;
10486: LD_EXP 80
10490: PUSH
10491: LD_EXP 82
10495: PUSH
10496: EMPTY
10497: LIST
10498: LIST
10499: PPUSH
10500: LD_VAR 0 3
10504: PPUSH
10505: CALL_OW 250
10509: PPUSH
10510: LD_VAR 0 3
10514: PPUSH
10515: CALL_OW 251
10519: PPUSH
10520: CALL_OW 111
// waitForKurt = true ;
10524: LD_ADDR_VAR 0 4
10528: PUSH
10529: LD_INT 1
10531: ST_TO_ADDR
// KurtStatus = 3 ;
10532: LD_ADDR_EXP 22
10536: PUSH
10537: LD_INT 3
10539: ST_TO_ADDR
// end else
10540: GO 10780
// if GetDistUnits ( Kurt , UnitFilter ( GensherTeam , [ f_type , unit_vehicle ] ) [ 1 ] ) > 8 then
10542: LD_EXP 80
10546: PPUSH
10547: LD_EXP 83
10551: PPUSH
10552: LD_INT 21
10554: PUSH
10555: LD_INT 2
10557: PUSH
10558: EMPTY
10559: LIST
10560: LIST
10561: PPUSH
10562: CALL_OW 72
10566: PUSH
10567: LD_INT 1
10569: ARRAY
10570: PPUSH
10571: CALL_OW 296
10575: PUSH
10576: LD_INT 8
10578: GREATER
10579: IFFALSE 10780
// begin allowExitFromMap = 4 ;
10581: LD_ADDR_EXP 18
10585: PUSH
10586: LD_INT 4
10588: ST_TO_ADDR
// KurtStatus = 2 ;
10589: LD_ADDR_EXP 22
10593: PUSH
10594: LD_INT 2
10596: ST_TO_ADDR
// ComMoveToArea ( [ Kurt , KurtEng ] , KurtExitMapArea ) ;
10597: LD_EXP 80
10601: PUSH
10602: LD_EXP 82
10606: PUSH
10607: EMPTY
10608: LIST
10609: LIST
10610: PPUSH
10611: LD_INT 11
10613: PPUSH
10614: CALL_OW 113
// repeat ComAttackUnit ( UnitFilter ( GensherTeam , [ [ f_type , unit_human ] ] ) , Kurt ) ;
10618: LD_EXP 83
10622: PPUSH
10623: LD_INT 21
10625: PUSH
10626: LD_INT 1
10628: PUSH
10629: EMPTY
10630: LIST
10631: LIST
10632: PUSH
10633: EMPTY
10634: LIST
10635: PPUSH
10636: CALL_OW 72
10640: PPUSH
10641: LD_EXP 80
10645: PPUSH
10646: CALL_OW 115
// wait ( 0 0$1 ) ;
10650: LD_INT 35
10652: PPUSH
10653: CALL_OW 67
// until GetDistUnits ( NearestUnitToUnit ( UnitFilter ( GensherTeam , [ [ f_type , unit_human ] ] ) , Kurt ) , Kurt ) <= 9 or ( not IsPlaced ( Kurt ) and not IsPlaced ( KurtEng ) ) ;
10657: LD_EXP 83
10661: PPUSH
10662: LD_INT 21
10664: PUSH
10665: LD_INT 1
10667: PUSH
10668: EMPTY
10669: LIST
10670: LIST
10671: PUSH
10672: EMPTY
10673: LIST
10674: PPUSH
10675: CALL_OW 72
10679: PPUSH
10680: LD_EXP 80
10684: PPUSH
10685: CALL_OW 74
10689: PPUSH
10690: LD_EXP 80
10694: PPUSH
10695: CALL_OW 296
10699: PUSH
10700: LD_INT 9
10702: LESSEQUAL
10703: PUSH
10704: LD_EXP 80
10708: PPUSH
10709: CALL_OW 305
10713: NOT
10714: PUSH
10715: LD_EXP 82
10719: PPUSH
10720: CALL_OW 305
10724: NOT
10725: AND
10726: OR
10727: IFFALSE 10618
// ComMoveToArea ( [ Kurt , KurtEng ] , ExitMapArea ) ;
10729: LD_EXP 80
10733: PUSH
10734: LD_EXP 82
10738: PUSH
10739: EMPTY
10740: LIST
10741: LIST
10742: PPUSH
10743: LD_INT 8
10745: PPUSH
10746: CALL_OW 113
// ComMoveToArea ( UnitFilter ( GensherTeam , [ [ f_type , unit_human ] ] ) , ExitMapArea ) ;
10750: LD_EXP 83
10754: PPUSH
10755: LD_INT 21
10757: PUSH
10758: LD_INT 1
10760: PUSH
10761: EMPTY
10762: LIST
10763: LIST
10764: PUSH
10765: EMPTY
10766: LIST
10767: PPUSH
10768: CALL_OW 72
10772: PPUSH
10773: LD_INT 8
10775: PPUSH
10776: CALL_OW 113
// end ; if waitForKurt then
10780: LD_VAR 0 4
10784: IFFALSE 10910
// begin repeat wait ( 0 0$1 ) ;
10786: LD_INT 35
10788: PPUSH
10789: CALL_OW 67
// ComMoveXY ( [ Kurt , KurtEng ] , GetX ( maleSold ) , GetY ( maleSold ) ) ;
10793: LD_EXP 80
10797: PUSH
10798: LD_EXP 82
10802: PUSH
10803: EMPTY
10804: LIST
10805: LIST
10806: PPUSH
10807: LD_VAR 0 3
10811: PPUSH
10812: CALL_OW 250
10816: PPUSH
10817: LD_VAR 0 3
10821: PPUSH
10822: CALL_OW 251
10826: PPUSH
10827: CALL_OW 111
// until GetDistUnits ( Kurt , maleSold ) <= 2 ;
10831: LD_EXP 80
10835: PPUSH
10836: LD_VAR 0 3
10840: PPUSH
10841: CALL_OW 296
10845: PUSH
10846: LD_INT 2
10848: LESSEQUAL
10849: IFFALSE 10786
// allowExitFromMap = 4 ;
10851: LD_ADDR_EXP 18
10855: PUSH
10856: LD_INT 4
10858: ST_TO_ADDR
// ComMoveToArea ( [ Kurt , KurtEng ] , ExitMapArea ) ;
10859: LD_EXP 80
10863: PUSH
10864: LD_EXP 82
10868: PUSH
10869: EMPTY
10870: LIST
10871: LIST
10872: PPUSH
10873: LD_INT 8
10875: PPUSH
10876: CALL_OW 113
// ComMoveToArea ( UnitFilter ( GensherTeam , [ [ f_type , unit_human ] ] ) , ExitMapArea ) ;
10880: LD_EXP 83
10884: PPUSH
10885: LD_INT 21
10887: PUSH
10888: LD_INT 1
10890: PUSH
10891: EMPTY
10892: LIST
10893: LIST
10894: PUSH
10895: EMPTY
10896: LIST
10897: PPUSH
10898: CALL_OW 72
10902: PPUSH
10903: LD_INT 8
10905: PPUSH
10906: CALL_OW 113
// end ; exit ;
10910: GO 10913
// end ; enable ;
10912: ENABLE
// end ;
10913: PPOPN 4
10915: END
// export function Dial_AttackGensher ; var unit ; begin
10916: LD_INT 0
10918: PPUSH
10919: PPUSH
// DialogueOn ;
10920: CALL_OW 6
// SayRadio ( Dietrich , DHandOverSpoiled-Diet-1 ) ;
10924: LD_EXP 81
10928: PPUSH
10929: LD_STRING DHandOverSpoiled-Diet-1
10931: PPUSH
10932: CALL_OW 94
// DialogueOff ;
10936: CALL_OW 7
// SetAttitude ( 3 , 2 , att_enemy , true ) ;
10940: LD_INT 3
10942: PPUSH
10943: LD_INT 2
10945: PPUSH
10946: LD_INT 2
10948: PPUSH
10949: LD_INT 1
10951: PPUSH
10952: CALL_OW 80
// for unit in UnitFilter ( GensherTeam , [ [ f_type , unit_human ] ] ) do
10956: LD_ADDR_VAR 0 2
10960: PUSH
10961: LD_EXP 83
10965: PPUSH
10966: LD_INT 21
10968: PUSH
10969: LD_INT 1
10971: PUSH
10972: EMPTY
10973: LIST
10974: LIST
10975: PUSH
10976: EMPTY
10977: LIST
10978: PPUSH
10979: CALL_OW 72
10983: PUSH
10984: FOR_IN
10985: IFFALSE 11045
// begin if IsInUnit ( unit ) then
10987: LD_VAR 0 2
10991: PPUSH
10992: CALL_OW 310
10996: IFFALSE 11007
// ComExitVehicle ( unit ) ;
10998: LD_VAR 0 2
11002: PPUSH
11003: CALL_OW 121
// wait ( 0 0$01 ) ;
11007: LD_INT 35
11009: PPUSH
11010: CALL_OW 67
// AddComAgressiveMove ( unit , GetX ( Burlak ) , GetY ( Burlak ) ) ;
11014: LD_VAR 0 2
11018: PPUSH
11019: LD_EXP 57
11023: PPUSH
11024: CALL_OW 250
11028: PPUSH
11029: LD_EXP 57
11033: PPUSH
11034: CALL_OW 251
11038: PPUSH
11039: CALL_OW 174
// end ;
11043: GO 10984
11045: POP
11046: POP
// coopWithGensher = 2 ;
11047: LD_ADDR_EXP 2
11051: PUSH
11052: LD_INT 2
11054: ST_TO_ADDR
// end ;
11055: LD_VAR 0 1
11059: RET
// every 0 0$1 trigger canSendHeike and IsOK ( Heike ) and GetSide ( Heike ) = 5 do var legionSold ;
11060: LD_EXP 28
11064: PUSH
11065: LD_EXP 79
11069: PPUSH
11070: CALL_OW 302
11074: AND
11075: PUSH
11076: LD_EXP 79
11080: PPUSH
11081: CALL_OW 255
11085: PUSH
11086: LD_INT 5
11088: EQUAL
11089: AND
11090: IFFALSE 11410
11092: GO 11094
11094: DISABLE
11095: LD_INT 0
11097: PPUSH
// begin if IsSelected ( Heike ) then
11098: LD_EXP 79
11102: PPUSH
11103: CALL_OW 306
11107: IFFALSE 11402
// begin if Query ( QSendHeike ) = 1 then
11109: LD_STRING QSendHeike
11111: PPUSH
11112: CALL_OW 97
11116: PUSH
11117: LD_INT 1
11119: EQUAL
11120: IFFALSE 11402
// begin KurtWaitingForFreeHeike = false ;
11122: LD_ADDR_EXP 23
11126: PUSH
11127: LD_INT 0
11129: ST_TO_ADDR
// ComMoveXY ( Heike , 82 , 46 ) ;
11130: LD_EXP 79
11134: PPUSH
11135: LD_INT 82
11137: PPUSH
11138: LD_INT 46
11140: PPUSH
11141: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
11145: LD_INT 35
11147: PPUSH
11148: CALL_OW 67
// until GetDistUnitXY ( Heike , 82 , 46 ) <= 5 or IsDead ( Heike ) ;
11152: LD_EXP 79
11156: PPUSH
11157: LD_INT 82
11159: PPUSH
11160: LD_INT 46
11162: PPUSH
11163: CALL_OW 297
11167: PUSH
11168: LD_INT 5
11170: LESSEQUAL
11171: PUSH
11172: LD_EXP 79
11176: PPUSH
11177: CALL_OW 301
11181: OR
11182: IFFALSE 11145
// if not askCommanders then
11184: LD_EXP 20
11188: NOT
11189: IFFALSE 11235
// begin DialogueOn ;
11191: CALL_OW 6
// SayRadio ( Popov , DMercPopov-Pop-1 ) ;
11195: LD_EXP 76
11199: PPUSH
11200: LD_STRING DMercPopov-Pop-1
11202: PPUSH
11203: CALL_OW 94
// Say ( Burlak , DMercPopov-Bur-1 ) ;
11207: LD_EXP 57
11211: PPUSH
11212: LD_STRING DMercPopov-Bur-1
11214: PPUSH
11215: CALL_OW 88
// SayRadio ( Popov , DMercPopov-Pop-2 ) ;
11219: LD_EXP 76
11223: PPUSH
11224: LD_STRING DMercPopov-Pop-2
11226: PPUSH
11227: CALL_OW 94
// DialogueOff ;
11231: CALL_OW 7
// end ; uc_side = 8 ;
11235: LD_ADDR_OWVAR 20
11239: PUSH
11240: LD_INT 8
11242: ST_TO_ADDR
// uc_nation = 2 ;
11243: LD_ADDR_OWVAR 21
11247: PUSH
11248: LD_INT 2
11250: ST_TO_ADDR
// PrepareSoldier ( false , 6 ) ;
11251: LD_INT 0
11253: PPUSH
11254: LD_INT 6
11256: PPUSH
11257: CALL_OW 381
// legionSold = CreateHuman ;
11261: LD_ADDR_VAR 0 1
11265: PUSH
11266: CALL_OW 44
11270: ST_TO_ADDR
// PlaceUnitXYR ( legionSold , 26 , 48 , 4 , false ) ;
11271: LD_VAR 0 1
11275: PPUSH
11276: LD_INT 26
11278: PPUSH
11279: LD_INT 48
11281: PPUSH
11282: LD_INT 4
11284: PPUSH
11285: LD_INT 0
11287: PPUSH
11288: CALL_OW 50
// repeat wait ( 0 0$1 ) ;
11292: LD_INT 35
11294: PPUSH
11295: CALL_OW 67
// ComMoveXY ( legionSold , GetX ( Heike ) , GetY ( Heike ) ) ;
11299: LD_VAR 0 1
11303: PPUSH
11304: LD_EXP 79
11308: PPUSH
11309: CALL_OW 250
11313: PPUSH
11314: LD_EXP 79
11318: PPUSH
11319: CALL_OW 251
11323: PPUSH
11324: CALL_OW 111
// until GetDistUnits ( legionSold , Heike ) <= 5 or IsDead ( Heike ) ;
11328: LD_VAR 0 1
11332: PPUSH
11333: LD_EXP 79
11337: PPUSH
11338: CALL_OW 296
11342: PUSH
11343: LD_INT 5
11345: LESSEQUAL
11346: PUSH
11347: LD_EXP 79
11351: PPUSH
11352: CALL_OW 301
11356: OR
11357: IFFALSE 11292
// SetSide ( Heike , 8 ) ;
11359: LD_EXP 79
11363: PPUSH
11364: LD_INT 8
11366: PPUSH
11367: CALL_OW 235
// allowExitFromMap = 3 ;
11371: LD_ADDR_EXP 18
11375: PUSH
11376: LD_INT 3
11378: ST_TO_ADDR
// ComMoveToArea ( [ legionSold , Heike ] , KurtExitMapArea ) ;
11379: LD_VAR 0 1
11383: PUSH
11384: LD_EXP 79
11388: PUSH
11389: EMPTY
11390: LIST
11391: LIST
11392: PPUSH
11393: LD_INT 11
11395: PPUSH
11396: CALL_OW 113
// exit ;
11400: GO 11410
// end ; end ; wait ( 0 0$3 ) ;
11402: LD_INT 105
11404: PPUSH
11405: CALL_OW 67
// enable ;
11409: ENABLE
// end ;
11410: PPOPN 1
11412: END
// export function Dial_PlayerDontSendHeike ; begin
11413: LD_INT 0
11415: PPUSH
// DialogueOn ;
11416: CALL_OW 6
// SayRadio ( Kurt , DMercDeceived-Kurt-1 ) ;
11420: LD_EXP 80
11424: PPUSH
11425: LD_STRING DMercDeceived-Kurt-1
11427: PPUSH
11428: CALL_OW 94
// DialogueOff ;
11432: CALL_OW 7
// SetAttitude ( 3 , 8 , att_enemy , true ) ;
11436: LD_INT 3
11438: PPUSH
11439: LD_INT 8
11441: PPUSH
11442: LD_INT 2
11444: PPUSH
11445: LD_INT 1
11447: PPUSH
11448: CALL_OW 80
// KurtAttack = true ;
11452: LD_ADDR_EXP 25
11456: PUSH
11457: LD_INT 1
11459: ST_TO_ADDR
// end ;
11460: LD_VAR 0 1
11464: RET
// export function Dial_BetrayedKurt1 ; begin
11465: LD_INT 0
11467: PPUSH
// DialogueOn ;
11468: CALL_OW 6
// Say ( Kurt , DMercDeceived-Kurt-1 ) ;
11472: LD_EXP 80
11476: PPUSH
11477: LD_STRING DMercDeceived-Kurt-1
11479: PPUSH
11480: CALL_OW 88
// DialogueOff ;
11484: CALL_OW 7
// if IsPlaced ( Kurt ) then
11488: LD_EXP 80
11492: PPUSH
11493: CALL_OW 305
11497: IFFALSE 11546
// begin SetSide ( KurtEng , 8 ) ;
11499: LD_EXP 82
11503: PPUSH
11504: LD_INT 8
11506: PPUSH
11507: CALL_OW 235
// allowExitFromMap = 3 ;
11511: LD_ADDR_EXP 18
11515: PUSH
11516: LD_INT 3
11518: ST_TO_ADDR
// if KurtCanEscape then
11519: LD_EXP 21
11523: IFFALSE 11546
// ComMoveToArea ( [ Kurt , KurtEng ] , KurtExitMapArea ) ;
11525: LD_EXP 80
11529: PUSH
11530: LD_EXP 82
11534: PUSH
11535: EMPTY
11536: LIST
11537: LIST
11538: PPUSH
11539: LD_INT 11
11541: PPUSH
11542: CALL_OW 113
// end ; end ;
11546: LD_VAR 0 1
11550: RET
// export function Dial_BetrayedKurt2 ; begin
11551: LD_INT 0
11553: PPUSH
// DialogueOn ;
11554: CALL_OW 6
// Say ( Kurt , DMercAmbush-Kurt-1 ) ;
11558: LD_EXP 80
11562: PPUSH
11563: LD_STRING DMercAmbush-Kurt-1
11565: PPUSH
11566: CALL_OW 88
// DialogueOff ;
11570: CALL_OW 7
// if IsPlaced ( Kurt ) then
11574: LD_EXP 80
11578: PPUSH
11579: CALL_OW 305
11583: IFFALSE 11632
// begin SetSide ( KurtEng , 8 ) ;
11585: LD_EXP 82
11589: PPUSH
11590: LD_INT 8
11592: PPUSH
11593: CALL_OW 235
// allowExitFromMap = 3 ;
11597: LD_ADDR_EXP 18
11601: PUSH
11602: LD_INT 3
11604: ST_TO_ADDR
// if KurtCanEscape then
11605: LD_EXP 21
11609: IFFALSE 11632
// ComMoveToArea ( [ Kurt , KurtEng ] , KurtExitMapArea ) ;
11611: LD_EXP 80
11615: PUSH
11616: LD_EXP 82
11620: PUSH
11621: EMPTY
11622: LIST
11623: LIST
11624: PPUSH
11625: LD_INT 11
11627: PPUSH
11628: CALL_OW 113
// end ; end ;
11632: LD_VAR 0 1
11636: RET
// every 0 0$1 trigger GetSide ( KurtEng ) = 3 do var playerUnits , unit ;
11637: LD_EXP 82
11641: PPUSH
11642: CALL_OW 255
11646: PUSH
11647: LD_INT 3
11649: EQUAL
11650: IFFALSE 11797
11652: GO 11654
11654: DISABLE
11655: LD_INT 0
11657: PPUSH
11658: PPUSH
// begin playerUnits = FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
11659: LD_ADDR_VAR 0 1
11663: PUSH
11664: LD_INT 22
11666: PUSH
11667: LD_INT 3
11669: PUSH
11670: EMPTY
11671: LIST
11672: LIST
11673: PUSH
11674: LD_INT 2
11676: PUSH
11677: LD_INT 21
11679: PUSH
11680: LD_INT 1
11682: PUSH
11683: EMPTY
11684: LIST
11685: LIST
11686: PUSH
11687: LD_INT 21
11689: PUSH
11690: LD_INT 2
11692: PUSH
11693: EMPTY
11694: LIST
11695: LIST
11696: PUSH
11697: EMPTY
11698: LIST
11699: LIST
11700: LIST
11701: PUSH
11702: EMPTY
11703: LIST
11704: LIST
11705: PPUSH
11706: CALL_OW 69
11710: ST_TO_ADDR
// for unit in playerUnits do
11711: LD_ADDR_VAR 0 2
11715: PUSH
11716: LD_VAR 0 1
11720: PUSH
11721: FOR_IN
11722: IFFALSE 11751
// begin if WantsToAttack ( unit ) = KurtEng then
11724: LD_VAR 0 2
11728: PPUSH
11729: CALL_OW 319
11733: PUSH
11734: LD_EXP 82
11738: EQUAL
11739: IFFALSE 11749
// begin Dial_BetrayedKurt2 ;
11741: CALL 11551 0 0
// exit ;
11745: POP
11746: POP
11747: GO 11797
// end ; end ;
11749: GO 11721
11751: POP
11752: POP
// if ( IsDying ( KurtEng ) or IsDead ( KurtEng ) ) and GetSide ( KurtEng ) = 3 then
11753: LD_EXP 82
11757: PPUSH
11758: CALL_OW 303
11762: PUSH
11763: LD_EXP 82
11767: PPUSH
11768: CALL_OW 301
11772: OR
11773: PUSH
11774: LD_EXP 82
11778: PPUSH
11779: CALL_OW 255
11783: PUSH
11784: LD_INT 3
11786: EQUAL
11787: AND
11788: IFFALSE 11796
// begin Dial_BetrayedKurt2 ;
11790: CALL 11551 0 0
// exit ;
11794: GO 11797
// end ; enable ;
11796: ENABLE
// end ;
11797: PPOPN 2
11799: END
// every 0 0$1 trigger GetAttitude ( 3 , 8 ) = att_neutral and GetLives ( Kurt ) <= 999 do
11800: LD_INT 3
11802: PPUSH
11803: LD_INT 8
11805: PPUSH
11806: CALL_OW 81
11810: PUSH
11811: LD_INT 0
11813: EQUAL
11814: PUSH
11815: LD_EXP 80
11819: PPUSH
11820: CALL_OW 256
11824: PUSH
11825: LD_INT 999
11827: LESSEQUAL
11828: AND
11829: IFFALSE 11854
11831: GO 11833
11833: DISABLE
// begin Dial_BetrayedKurt1 ;
11834: CALL 11465 0 0
// SetAttitude ( 3 , 8 , att_enemy , true ) ;
11838: LD_INT 3
11840: PPUSH
11841: LD_INT 8
11843: PPUSH
11844: LD_INT 2
11846: PPUSH
11847: LD_INT 1
11849: PPUSH
11850: CALL_OW 80
// end ;
11854: END
// every 0 0$1 trigger buildingsToBuild <= 11 do
11855: LD_EXP 8
11859: PUSH
11860: LD_INT 11
11862: LESSEQUAL
11863: IFFALSE 12112
11865: GO 11867
11867: DISABLE
// begin if not IsOK ( Kuzmov ) and not IsOK ( Oblukov ) then
11868: LD_EXP 72
11872: PPUSH
11873: CALL_OW 302
11877: NOT
11878: PUSH
11879: LD_EXP 74
11883: PPUSH
11884: CALL_OW 302
11888: NOT
11889: AND
11890: IFFALSE 11894
// exit ;
11892: GO 12112
// DialogueOn ;
11894: CALL_OW 6
// if IsOK ( Kuzmov ) then
11898: LD_EXP 72
11902: PPUSH
11903: CALL_OW 302
11907: IFFALSE 11923
// Say ( Kuzmov , DFiringRange-Kuz-1 ) else
11909: LD_EXP 72
11913: PPUSH
11914: LD_STRING DFiringRange-Kuz-1
11916: PPUSH
11917: CALL_OW 88
11921: GO 11935
// Say ( Oblukov , DFiringRange-Obl-1 ) ;
11923: LD_EXP 74
11927: PPUSH
11928: LD_STRING DFiringRange-Obl-1
11930: PPUSH
11931: CALL_OW 88
// Say ( Burlak , DFiringRange-Bur-1 ) ;
11935: LD_EXP 57
11939: PPUSH
11940: LD_STRING DFiringRange-Bur-1
11942: PPUSH
11943: CALL_OW 88
// CenterOnXY ( 99 , 30 ) ;
11947: LD_INT 99
11949: PPUSH
11950: LD_INT 30
11952: PPUSH
11953: CALL_OW 84
// Wait ( 0 0$0.5 ) ;
11957: LD_INT 18
11959: PPUSH
11960: CALL_OW 67
// RevealFogArea ( 3 , ShootArea ) ;
11964: LD_INT 3
11966: PPUSH
11967: LD_INT 12
11969: PPUSH
11970: CALL_OW 332
// SetAreaMapShow ( ShootArea , 1 ) ;
11974: LD_INT 12
11976: PPUSH
11977: LD_INT 1
11979: PPUSH
11980: CALL_OW 424
// if IsOK ( Kuzmov ) then
11984: LD_EXP 72
11988: PPUSH
11989: CALL_OW 302
11993: IFFALSE 12009
// Say ( Kuzmov , DFiringRange-Kuz-2 ) else
11995: LD_EXP 72
11999: PPUSH
12000: LD_STRING DFiringRange-Kuz-2
12002: PPUSH
12003: CALL_OW 88
12007: GO 12021
// Say ( Oblukov , DFiringRange-Obl-2 ) ;
12009: LD_EXP 74
12013: PPUSH
12014: LD_STRING DFiringRange-Obl-2
12016: PPUSH
12017: CALL_OW 88
// case Query ( QShootingGallery ) of 1 :
12021: LD_STRING QShootingGallery
12023: PPUSH
12024: CALL_OW 97
12028: PUSH
12029: LD_INT 1
12031: DOUBLE
12032: EQUAL
12033: IFTRUE 12037
12035: GO 12074
12037: POP
// begin Say ( Burlak , DQrShootingGallery#1-Bur-1 ) ;
12038: LD_EXP 57
12042: PPUSH
12043: LD_STRING DQrShootingGallery#1-Bur-1
12045: PPUSH
12046: CALL_OW 88
// BurlakRespect = BurlakRespect + 1 ;
12050: LD_ADDR_EXP 30
12054: PUSH
12055: LD_EXP 30
12059: PUSH
12060: LD_INT 1
12062: PLUS
12063: ST_TO_ADDR
// canShootTrening = true ;
12064: LD_ADDR_EXP 29
12068: PUSH
12069: LD_INT 1
12071: ST_TO_ADDR
// end ; 2 :
12072: GO 12108
12074: LD_INT 2
12076: DOUBLE
12077: EQUAL
12078: IFTRUE 12082
12080: GO 12107
12082: POP
// begin Say ( Burlak , DQrShootingGallery#2-Bur-1 ) ;
12083: LD_EXP 57
12087: PPUSH
12088: LD_STRING DQrShootingGallery#2-Bur-1
12090: PPUSH
12091: CALL_OW 88
// SetAreaMapShow ( ShootArea , 0 ) ;
12095: LD_INT 12
12097: PPUSH
12098: LD_INT 0
12100: PPUSH
12101: CALL_OW 424
// end ; end ;
12105: GO 12108
12107: POP
// DialogueOff ;
12108: CALL_OW 7
// end ;
12112: END
// every 0 0$1 trigger canShootTrening do
12113: LD_EXP 29
12117: IFFALSE 12127
12119: GO 12121
12121: DISABLE
// begin enable ;
12122: ENABLE
// ShootTreningController ;
12123: CALL 7091 0 0
// end ;
12127: END
// every 0 0$1 trigger buildingsToBuild <= 7 do var hunters , hunter ;
12128: LD_EXP 8
12132: PUSH
12133: LD_INT 7
12135: LESSEQUAL
12136: IFFALSE 12526
12138: GO 12140
12140: DISABLE
12141: LD_INT 0
12143: PPUSH
12144: PPUSH
// begin hunters = [ ] ;
12145: LD_ADDR_VAR 0 1
12149: PUSH
12150: EMPTY
12151: ST_TO_ADDR
// if IsOK ( Belkov ) then
12152: LD_EXP 66
12156: PPUSH
12157: CALL_OW 302
12161: IFFALSE 12179
// hunters = hunters ^ Belkov ;
12163: LD_ADDR_VAR 0 1
12167: PUSH
12168: LD_VAR 0 1
12172: PUSH
12173: LD_EXP 66
12177: ADD
12178: ST_TO_ADDR
// if IsOK ( Karamazov ) then
12179: LD_EXP 58
12183: PPUSH
12184: CALL_OW 302
12188: IFFALSE 12206
// hunters = hunters ^ Karamazov ;
12190: LD_ADDR_VAR 0 1
12194: PUSH
12195: LD_VAR 0 1
12199: PUSH
12200: LD_EXP 58
12204: ADD
12205: ST_TO_ADDR
// if IsOK ( Kozlov ) then
12206: LD_EXP 73
12210: PPUSH
12211: CALL_OW 302
12215: IFFALSE 12233
// hunters = hunters ^ Kozlov ;
12217: LD_ADDR_VAR 0 1
12221: PUSH
12222: LD_VAR 0 1
12226: PUSH
12227: LD_EXP 73
12231: ADD
12232: ST_TO_ADDR
// if not hunters then
12233: LD_VAR 0 1
12237: NOT
12238: IFFALSE 12242
// exit ;
12240: GO 12526
// hunter = hunters [ Rand ( 1 , hunters ) ] ;
12242: LD_ADDR_VAR 0 2
12246: PUSH
12247: LD_VAR 0 1
12251: PUSH
12252: LD_INT 1
12254: PPUSH
12255: LD_VAR 0 1
12259: PPUSH
12260: CALL_OW 12
12264: ARRAY
12265: ST_TO_ADDR
// DialogueOn ;
12266: CALL_OW 6
// case hunter of Belkov :
12270: LD_VAR 0 2
12274: PUSH
12275: LD_EXP 66
12279: DOUBLE
12280: EQUAL
12281: IFTRUE 12285
12283: GO 12300
12285: POP
// Say ( Belkov , DHunting-Bel-1 ) ; Karamazov :
12286: LD_EXP 66
12290: PPUSH
12291: LD_STRING DHunting-Bel-1
12293: PPUSH
12294: CALL_OW 88
12298: GO 12351
12300: LD_EXP 58
12304: DOUBLE
12305: EQUAL
12306: IFTRUE 12310
12308: GO 12325
12310: POP
// Say ( Karamazov , DHunting-Kar-1 ) ; Kozlov :
12311: LD_EXP 58
12315: PPUSH
12316: LD_STRING DHunting-Kar-1
12318: PPUSH
12319: CALL_OW 88
12323: GO 12351
12325: LD_EXP 73
12329: DOUBLE
12330: EQUAL
12331: IFTRUE 12335
12333: GO 12350
12335: POP
// Say ( Kozlov , DHunting-Koz-1 ) ; end ;
12336: LD_EXP 73
12340: PPUSH
12341: LD_STRING DHunting-Koz-1
12343: PPUSH
12344: CALL_OW 88
12348: GO 12351
12350: POP
// Say ( Burlak , DHunting-Bur-1 ) ;
12351: LD_EXP 57
12355: PPUSH
12356: LD_STRING DHunting-Bur-1
12358: PPUSH
12359: CALL_OW 88
// case hunter of Belkov :
12363: LD_VAR 0 2
12367: PUSH
12368: LD_EXP 66
12372: DOUBLE
12373: EQUAL
12374: IFTRUE 12378
12376: GO 12393
12378: POP
// Say ( Belkov , DHunting-Bel-2 ) ; Karamazov :
12379: LD_EXP 66
12383: PPUSH
12384: LD_STRING DHunting-Bel-2
12386: PPUSH
12387: CALL_OW 88
12391: GO 12444
12393: LD_EXP 58
12397: DOUBLE
12398: EQUAL
12399: IFTRUE 12403
12401: GO 12418
12403: POP
// Say ( Karamazov , DHunting-Kar-2 ) ; Kozlov :
12404: LD_EXP 58
12408: PPUSH
12409: LD_STRING DHunting-Kar-2
12411: PPUSH
12412: CALL_OW 88
12416: GO 12444
12418: LD_EXP 73
12422: DOUBLE
12423: EQUAL
12424: IFTRUE 12428
12426: GO 12443
12428: POP
// Say ( Kozlov , DHunting-Koz-2 ) ; end ;
12429: LD_EXP 73
12433: PPUSH
12434: LD_STRING DHunting-Koz-2
12436: PPUSH
12437: CALL_OW 88
12441: GO 12444
12443: POP
// DialogueOff ;
12444: CALL_OW 7
// case Query ( QHunting ) of 1 :
12448: LD_STRING QHunting
12450: PPUSH
12451: CALL_OW 97
12455: PUSH
12456: LD_INT 1
12458: DOUBLE
12459: EQUAL
12460: IFTRUE 12464
12462: GO 12502
12464: POP
// begin Say ( Burlak , DQrHunting#1-Bur-1 ) ;
12465: LD_EXP 57
12469: PPUSH
12470: LD_STRING DQrHunting#1-Bur-1
12472: PPUSH
12473: CALL_OW 88
// BurlakRespect = BurlakRespect + 1 ;
12477: LD_ADDR_EXP 30
12481: PUSH
12482: LD_EXP 30
12486: PUSH
12487: LD_INT 1
12489: PLUS
12490: ST_TO_ADDR
// GoToHunt ( hunter ) ;
12491: LD_VAR 0 2
12495: PPUSH
12496: CALL 7719 0 1
// end ; 2 :
12500: GO 12526
12502: LD_INT 2
12504: DOUBLE
12505: EQUAL
12506: IFTRUE 12510
12508: GO 12525
12510: POP
// Say ( Burlak , DQrHunting#2-Bur-1 ) ; end ;
12511: LD_EXP 57
12515: PPUSH
12516: LD_STRING DQrHunting#2-Bur-1
12518: PPUSH
12519: CALL_OW 88
12523: GO 12526
12525: POP
// end ;
12526: PPOPN 2
12528: END
// every 0 0$1 trigger buildingsToBuild <= 3 do var unit , womans , men , woman , man , depots ;
12529: LD_EXP 8
12533: PUSH
12534: LD_INT 3
12536: LESSEQUAL
12537: IFFALSE 13524
12539: GO 12541
12541: DISABLE
12542: LD_INT 0
12544: PPUSH
12545: PPUSH
12546: PPUSH
12547: PPUSH
12548: PPUSH
12549: PPUSH
// begin womans = [ ] ;
12550: LD_ADDR_VAR 0 2
12554: PUSH
12555: EMPTY
12556: ST_TO_ADDR
// men = [ ] ;
12557: LD_ADDR_VAR 0 3
12561: PUSH
12562: EMPTY
12563: ST_TO_ADDR
// if IsOK ( Petrovova ) then
12564: LD_EXP 59
12568: PPUSH
12569: CALL_OW 302
12573: IFFALSE 12591
// womans = womans ^ Petrovova ;
12575: LD_ADDR_VAR 0 2
12579: PUSH
12580: LD_VAR 0 2
12584: PUSH
12585: LD_EXP 59
12589: ADD
12590: ST_TO_ADDR
// if IsOK ( Kirilenkova ) then
12591: LD_EXP 65
12595: PPUSH
12596: CALL_OW 302
12600: IFFALSE 12618
// womans = womans ^ Kirilenkova ;
12602: LD_ADDR_VAR 0 2
12606: PUSH
12607: LD_VAR 0 2
12611: PUSH
12612: LD_EXP 65
12616: ADD
12617: ST_TO_ADDR
// if IsOK ( Kapitsova ) then
12618: LD_EXP 75
12622: PPUSH
12623: CALL_OW 302
12627: IFFALSE 12645
// womans = womans ^ Kapitsova ;
12629: LD_ADDR_VAR 0 2
12633: PUSH
12634: LD_VAR 0 2
12638: PUSH
12639: LD_EXP 75
12643: ADD
12644: ST_TO_ADDR
// DialogueOn ;
12645: CALL_OW 6
// if womans then
12649: LD_VAR 0 2
12653: IFFALSE 12780
// begin case womans [ Rand ( 1 , womans ) ] of Petrovova :
12655: LD_VAR 0 2
12659: PUSH
12660: LD_INT 1
12662: PPUSH
12663: LD_VAR 0 2
12667: PPUSH
12668: CALL_OW 12
12672: ARRAY
12673: PUSH
12674: LD_EXP 59
12678: DOUBLE
12679: EQUAL
12680: IFTRUE 12684
12682: GO 12709
12684: POP
// begin Say ( Petrovova , DFreeTime-Ptr-1 ) ;
12685: LD_EXP 59
12689: PPUSH
12690: LD_STRING DFreeTime-Ptr-1
12692: PPUSH
12693: CALL_OW 88
// woman = Petrovova ;
12697: LD_ADDR_VAR 0 4
12701: PUSH
12702: LD_EXP 59
12706: ST_TO_ADDR
// end ; Kirilenkova :
12707: GO 12780
12709: LD_EXP 65
12713: DOUBLE
12714: EQUAL
12715: IFTRUE 12719
12717: GO 12744
12719: POP
// begin Say ( Kirilenkova , DFreeTime-Kir-1 ) ;
12720: LD_EXP 65
12724: PPUSH
12725: LD_STRING DFreeTime-Kir-1
12727: PPUSH
12728: CALL_OW 88
// woman = Kirilenkova ;
12732: LD_ADDR_VAR 0 4
12736: PUSH
12737: LD_EXP 65
12741: ST_TO_ADDR
// end ; Kapitsova :
12742: GO 12780
12744: LD_EXP 75
12748: DOUBLE
12749: EQUAL
12750: IFTRUE 12754
12752: GO 12779
12754: POP
// begin Say ( Kapitsova , DFreeTime-Kap-1 ) ;
12755: LD_EXP 75
12759: PPUSH
12760: LD_STRING DFreeTime-Kap-1
12762: PPUSH
12763: CALL_OW 88
// woman = Kapitsova ;
12767: LD_ADDR_VAR 0 4
12771: PUSH
12772: LD_EXP 75
12776: ST_TO_ADDR
// end ; end ;
12777: GO 12780
12779: POP
// end ; if IsOK ( Kuzmov ) then
12780: LD_EXP 72
12784: PPUSH
12785: CALL_OW 302
12789: IFFALSE 12807
// men = men ^ Kuzmov ;
12791: LD_ADDR_VAR 0 3
12795: PUSH
12796: LD_VAR 0 3
12800: PUSH
12801: LD_EXP 72
12805: ADD
12806: ST_TO_ADDR
// if IsOK ( Titov ) then
12807: LD_EXP 62
12811: PPUSH
12812: CALL_OW 302
12816: IFFALSE 12834
// men = men ^ Titov ;
12818: LD_ADDR_VAR 0 3
12822: PUSH
12823: LD_VAR 0 3
12827: PUSH
12828: LD_EXP 62
12832: ADD
12833: ST_TO_ADDR
// if IsOK ( Gnyevko ) then
12834: LD_EXP 69
12838: PPUSH
12839: CALL_OW 302
12843: IFFALSE 12861
// men = men ^ Gnyevko ;
12845: LD_ADDR_VAR 0 3
12849: PUSH
12850: LD_VAR 0 3
12854: PUSH
12855: LD_EXP 69
12859: ADD
12860: ST_TO_ADDR
// if IsOK ( Oblukov ) then
12861: LD_EXP 74
12865: PPUSH
12866: CALL_OW 302
12870: IFFALSE 12888
// men = men ^ Oblukov ;
12872: LD_ADDR_VAR 0 3
12876: PUSH
12877: LD_VAR 0 3
12881: PUSH
12882: LD_EXP 74
12886: ADD
12887: ST_TO_ADDR
// if men then
12888: LD_VAR 0 3
12892: IFFALSE 13054
// begin case men [ Rand ( 1 , men ) ] of Kuzmov :
12894: LD_VAR 0 3
12898: PUSH
12899: LD_INT 1
12901: PPUSH
12902: LD_VAR 0 3
12906: PPUSH
12907: CALL_OW 12
12911: ARRAY
12912: PUSH
12913: LD_EXP 72
12917: DOUBLE
12918: EQUAL
12919: IFTRUE 12923
12921: GO 12948
12923: POP
// begin Say ( Kuzmov , DFreeTime-Kuz-1 ) ;
12924: LD_EXP 72
12928: PPUSH
12929: LD_STRING DFreeTime-Kuz-1
12931: PPUSH
12932: CALL_OW 88
// man = Kuzmov ;
12936: LD_ADDR_VAR 0 5
12940: PUSH
12941: LD_EXP 72
12945: ST_TO_ADDR
// end ; Titov :
12946: GO 13054
12948: LD_EXP 62
12952: DOUBLE
12953: EQUAL
12954: IFTRUE 12958
12956: GO 12983
12958: POP
// begin Say ( Titov , DFreeTime-Tit-1 ) ;
12959: LD_EXP 62
12963: PPUSH
12964: LD_STRING DFreeTime-Tit-1
12966: PPUSH
12967: CALL_OW 88
// man = Titov ;
12971: LD_ADDR_VAR 0 5
12975: PUSH
12976: LD_EXP 62
12980: ST_TO_ADDR
// end ; Gnyevko :
12981: GO 13054
12983: LD_EXP 69
12987: DOUBLE
12988: EQUAL
12989: IFTRUE 12993
12991: GO 13018
12993: POP
// begin Say ( Gnyevko , DFreeTime-Gny-1 ) ;
12994: LD_EXP 69
12998: PPUSH
12999: LD_STRING DFreeTime-Gny-1
13001: PPUSH
13002: CALL_OW 88
// man = Gnyevko ;
13006: LD_ADDR_VAR 0 5
13010: PUSH
13011: LD_EXP 69
13015: ST_TO_ADDR
// end ; Oblukov :
13016: GO 13054
13018: LD_EXP 74
13022: DOUBLE
13023: EQUAL
13024: IFTRUE 13028
13026: GO 13053
13028: POP
// begin Say ( Oblukov , DFreeTime-Obl-1 ) ;
13029: LD_EXP 74
13033: PPUSH
13034: LD_STRING DFreeTime-Obl-1
13036: PPUSH
13037: CALL_OW 88
// man = Oblukov ;
13041: LD_ADDR_VAR 0 5
13045: PUSH
13046: LD_EXP 74
13050: ST_TO_ADDR
// end ; end ;
13051: GO 13054
13053: POP
// end ; DialogueOff ;
13054: CALL_OW 7
// if not woman and not man then
13058: LD_VAR 0 4
13062: NOT
13063: PUSH
13064: LD_VAR 0 5
13068: NOT
13069: AND
13070: IFFALSE 13078
// begin DialogueOff ;
13072: CALL_OW 7
// exit ;
13076: GO 13524
// end ; case Query ( QFreeTime ) of 1 :
13078: LD_STRING QFreeTime
13080: PPUSH
13081: CALL_OW 97
13085: PUSH
13086: LD_INT 1
13088: DOUBLE
13089: EQUAL
13090: IFTRUE 13094
13092: GO 13496
13094: POP
// begin Say ( Burlak , DQrFreeTime#1-Bur-1 ) ;
13095: LD_EXP 57
13099: PPUSH
13100: LD_STRING DQrFreeTime#1-Bur-1
13102: PPUSH
13103: CALL_OW 88
// DialogueOff ;
13107: CALL_OW 7
// BurlakRespect = BurlakRespect + 1 ;
13111: LD_ADDR_EXP 30
13115: PUSH
13116: LD_EXP 30
13120: PUSH
13121: LD_INT 1
13123: PLUS
13124: ST_TO_ADDR
// SetSide ( [ woman , man ] , 6 ) ;
13125: LD_VAR 0 4
13129: PUSH
13130: LD_VAR 0 5
13134: PUSH
13135: EMPTY
13136: LIST
13137: LIST
13138: PPUSH
13139: LD_INT 6
13141: PPUSH
13142: CALL_OW 235
// for unit in [ woman , man ] do
13146: LD_ADDR_VAR 0 1
13150: PUSH
13151: LD_VAR 0 4
13155: PUSH
13156: LD_VAR 0 5
13160: PUSH
13161: EMPTY
13162: LIST
13163: LIST
13164: PUSH
13165: FOR_IN
13166: IFFALSE 13221
// if IsInUnit ( unit ) then
13168: LD_VAR 0 1
13172: PPUSH
13173: CALL_OW 310
13177: IFFALSE 13219
// begin if GetType ( IsInUnit ( unit ) ) = unit_vehicle then
13179: LD_VAR 0 1
13183: PPUSH
13184: CALL_OW 310
13188: PPUSH
13189: CALL_OW 247
13193: PUSH
13194: LD_INT 2
13196: EQUAL
13197: IFFALSE 13210
// ComExitVehicle ( unit ) else
13199: LD_VAR 0 1
13203: PPUSH
13204: CALL_OW 121
13208: GO 13219
// ComExitBuilding ( unit ) ;
13210: LD_VAR 0 1
13214: PPUSH
13215: CALL_OW 122
// end ;
13219: GO 13165
13221: POP
13222: POP
// wait ( 0 0$1 ) ;
13223: LD_INT 35
13225: PPUSH
13226: CALL_OW 67
// ComMoveToArea ( [ woman , man ] , ExitMapArea ) ;
13230: LD_VAR 0 4
13234: PUSH
13235: LD_VAR 0 5
13239: PUSH
13240: EMPTY
13241: LIST
13242: LIST
13243: PPUSH
13244: LD_INT 8
13246: PPUSH
13247: CALL_OW 113
// allowExitFromMap = 1 ;
13251: LD_ADDR_EXP 18
13255: PUSH
13256: LD_INT 1
13258: ST_TO_ADDR
// wait ( 3 3$0 ) ;
13259: LD_INT 6300
13261: PPUSH
13262: CALL_OW 67
// PlaceUnitXYR ( woman , 157 , 29 , 3 , false ) ;
13266: LD_VAR 0 4
13270: PPUSH
13271: LD_INT 157
13273: PPUSH
13274: LD_INT 29
13276: PPUSH
13277: LD_INT 3
13279: PPUSH
13280: LD_INT 0
13282: PPUSH
13283: CALL_OW 50
// PlaceUnitXYR ( man , 157 , 29 , 3 , false ) ;
13287: LD_VAR 0 5
13291: PPUSH
13292: LD_INT 157
13294: PPUSH
13295: LD_INT 29
13297: PPUSH
13298: LD_INT 3
13300: PPUSH
13301: LD_INT 0
13303: PPUSH
13304: CALL_OW 50
// SetSide ( [ woman , man ] , 3 ) ;
13308: LD_VAR 0 4
13312: PUSH
13313: LD_VAR 0 5
13317: PUSH
13318: EMPTY
13319: LIST
13320: LIST
13321: PPUSH
13322: LD_INT 3
13324: PPUSH
13325: CALL_OW 235
// depots = FilterAllUnits ( [ [ f_side , 3 ] , [ [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ] ) ;
13329: LD_ADDR_VAR 0 6
13333: PUSH
13334: LD_INT 22
13336: PUSH
13337: LD_INT 3
13339: PUSH
13340: EMPTY
13341: LIST
13342: LIST
13343: PUSH
13344: LD_INT 2
13346: PUSH
13347: LD_INT 30
13349: PUSH
13350: LD_INT 0
13352: PUSH
13353: EMPTY
13354: LIST
13355: LIST
13356: PUSH
13357: LD_INT 30
13359: PUSH
13360: LD_INT 1
13362: PUSH
13363: EMPTY
13364: LIST
13365: LIST
13366: PUSH
13367: EMPTY
13368: LIST
13369: LIST
13370: LIST
13371: PUSH
13372: EMPTY
13373: LIST
13374: PUSH
13375: EMPTY
13376: LIST
13377: LIST
13378: PPUSH
13379: CALL_OW 69
13383: ST_TO_ADDR
// if depots then
13384: LD_VAR 0 6
13388: IFFALSE 13438
// ComMoveXY ( [ woman , man ] , GetX ( depots [ 1 ] ) , GetY ( depots [ 1 ] ) ) else
13390: LD_VAR 0 4
13394: PUSH
13395: LD_VAR 0 5
13399: PUSH
13400: EMPTY
13401: LIST
13402: LIST
13403: PPUSH
13404: LD_VAR 0 6
13408: PUSH
13409: LD_INT 1
13411: ARRAY
13412: PPUSH
13413: CALL_OW 250
13417: PPUSH
13418: LD_VAR 0 6
13422: PUSH
13423: LD_INT 1
13425: ARRAY
13426: PPUSH
13427: CALL_OW 251
13431: PPUSH
13432: CALL_OW 111
13436: GO 13476
// ComMoveXY ( [ woman , man ] , GetX ( Burlak ) , GetY ( Burlak ) ) ;
13438: LD_VAR 0 4
13442: PUSH
13443: LD_VAR 0 5
13447: PUSH
13448: EMPTY
13449: LIST
13450: LIST
13451: PPUSH
13452: LD_EXP 57
13456: PPUSH
13457: CALL_OW 250
13461: PPUSH
13462: LD_EXP 57
13466: PPUSH
13467: CALL_OW 251
13471: PPUSH
13472: CALL_OW 111
// CenterOnUnits ( [ woman , man ] ) ;
13476: LD_VAR 0 4
13480: PUSH
13481: LD_VAR 0 5
13485: PUSH
13486: EMPTY
13487: LIST
13488: LIST
13489: PPUSH
13490: CALL_OW 85
// end ; 2 :
13494: GO 13520
13496: LD_INT 2
13498: DOUBLE
13499: EQUAL
13500: IFTRUE 13504
13502: GO 13519
13504: POP
// Say ( Burlak , DQrFreeTime#2-Bur-1 ) ; end ;
13505: LD_EXP 57
13509: PPUSH
13510: LD_STRING DQrFreeTime#2-Bur-1
13512: PPUSH
13513: CALL_OW 88
13517: GO 13520
13519: POP
// DialogueOff ;
13520: CALL_OW 7
// end ;
13524: PPOPN 6
13526: END
// every 0 0$1 trigger GetAmountWeaponsDataBuildOnVehicle ( false ) <= 2 do
13527: LD_INT 0
13529: PPUSH
13530: CALL 6800 0 1
13534: PUSH
13535: LD_INT 2
13537: LESSEQUAL
13538: IFFALSE 13673
13540: GO 13542
13542: DISABLE
// begin DialogueOn ;
13543: CALL_OW 6
// if IsOK ( Kozlov ) then
13547: LD_EXP 73
13551: PPUSH
13552: CALL_OW 302
13556: IFFALSE 13572
// Say ( Kozlov , DMasha-Koz-1 ) else
13558: LD_EXP 73
13562: PPUSH
13563: LD_STRING DMasha-Koz-1
13565: PPUSH
13566: CALL_OW 88
13570: GO 13635
// DialogRandom ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_ok ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) , DMasha-Koz-1 ,  , false , false ) ;
13572: LD_INT 22
13574: PUSH
13575: LD_INT 3
13577: PUSH
13578: EMPTY
13579: LIST
13580: LIST
13581: PUSH
13582: LD_INT 50
13584: PUSH
13585: EMPTY
13586: LIST
13587: PUSH
13588: LD_INT 21
13590: PUSH
13591: LD_INT 1
13593: PUSH
13594: EMPTY
13595: LIST
13596: LIST
13597: PUSH
13598: LD_INT 26
13600: PUSH
13601: LD_INT 1
13603: PUSH
13604: EMPTY
13605: LIST
13606: LIST
13607: PUSH
13608: EMPTY
13609: LIST
13610: LIST
13611: LIST
13612: LIST
13613: PPUSH
13614: CALL_OW 69
13618: PPUSH
13619: LD_STRING DMasha-Koz-1
13621: PPUSH
13622: LD_STRING 
13624: PPUSH
13625: LD_INT 0
13627: PPUSH
13628: LD_INT 0
13630: PPUSH
13631: CALL 6249 0 5
// Say ( Burlak , DMasha2-Bur-1 ) ;
13635: LD_EXP 57
13639: PPUSH
13640: LD_STRING DMasha2-Bur-1
13642: PPUSH
13643: CALL_OW 88
// DialogueOff ;
13647: CALL_OW 7
// Query ( QMasha ) ;
13651: LD_STRING QMasha
13653: PPUSH
13654: CALL_OW 97
// ChangeMissionObjectives ( MMasha ) ;
13658: LD_STRING MMasha
13660: PPUSH
13661: CALL_OW 337
// canChooseMashaVehicle = true ;
13665: LD_ADDR_EXP 36
13669: PUSH
13670: LD_INT 1
13672: ST_TO_ADDR
// end ;
13673: END
// export function Dial_ComputerTechResearched ; begin
13674: LD_INT 0
13676: PPUSH
// if IsOk ( Scholtze ) or IsOK ( Kapitsova ) then
13677: LD_EXP 71
13681: PPUSH
13682: CALL_OW 302
13686: PUSH
13687: LD_EXP 75
13691: PPUSH
13692: CALL_OW 302
13696: OR
13697: IFFALSE 13793
// begin DialogueOn ;
13699: CALL_OW 6
// if IsOK ( Scholtze ) then
13703: LD_EXP 71
13707: PPUSH
13708: CALL_OW 302
13712: IFFALSE 13728
// Say ( Scholtze , DAI-Sch-1 ) else
13714: LD_EXP 71
13718: PPUSH
13719: LD_STRING DAI-Sch-1
13721: PPUSH
13722: CALL_OW 88
13726: GO 13740
// Say ( Kapitsova , DAI-Kap-1 ) ;
13728: LD_EXP 75
13732: PPUSH
13733: LD_STRING DAI-Kap-1
13735: PPUSH
13736: CALL_OW 88
// Say ( Burlak , DAI-Bur-1 ) ;
13740: LD_EXP 57
13744: PPUSH
13745: LD_STRING DAI-Bur-1
13747: PPUSH
13748: CALL_OW 88
// if IsOK ( Scholtze ) then
13752: LD_EXP 71
13756: PPUSH
13757: CALL_OW 302
13761: IFFALSE 13777
// Say ( Scholtze , DAI-Sch-2 ) else
13763: LD_EXP 71
13767: PPUSH
13768: LD_STRING DAI-Sch-2
13770: PPUSH
13771: CALL_OW 88
13775: GO 13789
// Say ( Kapitsova , DAI-Kap-2 ) ;
13777: LD_EXP 75
13781: PPUSH
13782: LD_STRING DAI-Kap-2
13784: PPUSH
13785: CALL_OW 88
// DialogueOff ;
13789: CALL_OW 7
// end ; ChangeMissionObjectives ( MAI ) ;
13793: LD_STRING MAI
13795: PPUSH
13796: CALL_OW 337
// end ;
13800: LD_VAR 0 1
13804: RET
// export function Dial_TeleportTechResearched ; begin
13805: LD_INT 0
13807: PPUSH
// if IsOk ( Scholtze ) or IsOK ( Kapitsova ) then
13808: LD_EXP 71
13812: PPUSH
13813: CALL_OW 302
13817: PUSH
13818: LD_EXP 75
13822: PPUSH
13823: CALL_OW 302
13827: OR
13828: IFFALSE 13936
// begin DialogueOn ;
13830: CALL_OW 6
// if IsOK ( Scholtze ) then
13834: LD_EXP 71
13838: PPUSH
13839: CALL_OW 302
13843: IFFALSE 13859
// Say ( Scholtze , DSpontTelep-Sch-1 ) else
13845: LD_EXP 71
13849: PPUSH
13850: LD_STRING DSpontTelep-Sch-1
13852: PPUSH
13853: CALL_OW 88
13857: GO 13871
// Say ( Kapitsova , DSpontTelep-Kap-1 ) ;
13859: LD_EXP 75
13863: PPUSH
13864: LD_STRING DSpontTelep-Kap-1
13866: PPUSH
13867: CALL_OW 88
// Say ( Burlak , DSpontTelep-Bur-1 ) ;
13871: LD_EXP 57
13875: PPUSH
13876: LD_STRING DSpontTelep-Bur-1
13878: PPUSH
13879: CALL_OW 88
// if IsOK ( Scholtze ) then
13883: LD_EXP 71
13887: PPUSH
13888: CALL_OW 302
13892: IFFALSE 13908
// Say ( Scholtze , DSpontTelep-Sch-2 ) else
13894: LD_EXP 71
13898: PPUSH
13899: LD_STRING DSpontTelep-Sch-2
13901: PPUSH
13902: CALL_OW 88
13906: GO 13920
// Say ( Kapitsova , DSpontTelep-Kap-2 ) ;
13908: LD_EXP 75
13912: PPUSH
13913: LD_STRING DSpontTelep-Kap-2
13915: PPUSH
13916: CALL_OW 88
// Say ( Burlak , DSpontTelep-Bur-2 ) ;
13920: LD_EXP 57
13924: PPUSH
13925: LD_STRING DSpontTelep-Bur-2
13927: PPUSH
13928: CALL_OW 88
// DialogueOff ;
13932: CALL_OW 7
// end ; ChangeMissionObjectives ( MTele ) ;
13936: LD_STRING MTele
13938: PPUSH
13939: CALL_OW 337
// end ;
13943: LD_VAR 0 1
13947: RET
// every 0 0$1 trigger buildingsToBuild <= 3 and GetAmountWeaponsDataBuildOnVehicle ( false ) <= 1 and techsToResearch <= 4 do
13948: LD_EXP 8
13952: PUSH
13953: LD_INT 3
13955: LESSEQUAL
13956: PUSH
13957: LD_INT 0
13959: PPUSH
13960: CALL 6800 0 1
13964: PUSH
13965: LD_INT 1
13967: LESSEQUAL
13968: AND
13969: PUSH
13970: LD_EXP 9
13974: PUSH
13975: LD_INT 4
13977: LESSEQUAL
13978: AND
13979: IFFALSE 14180
13981: GO 13983
13983: DISABLE
// begin SayRadio ( Popov , DAmAttackStart-Pop-1 ) ;
13984: LD_EXP 76
13988: PPUSH
13989: LD_STRING DAmAttackStart-Pop-1
13991: PPUSH
13992: CALL_OW 94
// if KurtStatus = 1 and HeikeStatus = 1 then
13996: LD_EXP 22
14000: PUSH
14001: LD_INT 1
14003: EQUAL
14004: PUSH
14005: LD_EXP 3
14009: PUSH
14010: LD_INT 1
14012: EQUAL
14013: AND
14014: IFFALSE 14172
// begin wait ( 0 0$10 ) ;
14016: LD_INT 350
14018: PPUSH
14019: CALL_OW 67
// DialogueOn ;
14023: CALL_OW 6
// SayRadio ( Heike , DLegionFormed-Hke-1 ) ;
14027: LD_EXP 79
14031: PPUSH
14032: LD_STRING DLegionFormed-Hke-1
14034: PPUSH
14035: CALL_OW 94
// Say ( Burlak , DLegionFormed-Bur-1 ) ;
14039: LD_EXP 57
14043: PPUSH
14044: LD_STRING DLegionFormed-Bur-1
14046: PPUSH
14047: CALL_OW 88
// SayRadio ( Heike , DLegionFormed-Hke-2 ) ;
14051: LD_EXP 79
14055: PPUSH
14056: LD_STRING DLegionFormed-Hke-2
14058: PPUSH
14059: CALL_OW 94
// Say ( Burlak , DLegionFormed-Bur-2 ) ;
14063: LD_EXP 57
14067: PPUSH
14068: LD_STRING DLegionFormed-Bur-2
14070: PPUSH
14071: CALL_OW 88
// SayRadio ( Heike , DLegionFormed-Hke-3 ) ;
14075: LD_EXP 79
14079: PPUSH
14080: LD_STRING DLegionFormed-Hke-3
14082: PPUSH
14083: CALL_OW 94
// case Query ( QLegion ) of 1 :
14087: LD_STRING QLegion
14089: PPUSH
14090: CALL_OW 97
14094: PUSH
14095: LD_INT 1
14097: DOUBLE
14098: EQUAL
14099: IFTRUE 14103
14101: GO 14134
14103: POP
// begin acceptLegionOffert = true ;
14104: LD_ADDR_EXP 31
14108: PUSH
14109: LD_INT 1
14111: ST_TO_ADDR
// legionOffertCountdown = true ;
14112: LD_ADDR_EXP 33
14116: PUSH
14117: LD_INT 1
14119: ST_TO_ADDR
// Say ( Burlak , DQrLegion#1-Bur-1 ) ;
14120: LD_EXP 57
14124: PPUSH
14125: LD_STRING DQrLegion#1-Bur-1
14127: PPUSH
14128: CALL_OW 88
// end ; 2 :
14132: GO 14166
14134: LD_INT 2
14136: DOUBLE
14137: EQUAL
14138: IFTRUE 14142
14140: GO 14165
14142: POP
// begin Say ( Burlak , DQrLegion#2-Bur-1 ) ;
14143: LD_EXP 57
14147: PPUSH
14148: LD_STRING DQrLegion#2-Bur-1
14150: PPUSH
14151: CALL_OW 88
// americansAttack = true ;
14155: LD_ADDR_EXP 26
14159: PUSH
14160: LD_INT 1
14162: ST_TO_ADDR
// end ; end ;
14163: GO 14166
14165: POP
// DialogueOff ;
14166: CALL_OW 7
// end else
14170: GO 14180
// begin americansAttack = true ;
14172: LD_ADDR_EXP 26
14176: PUSH
14177: LD_INT 1
14179: ST_TO_ADDR
// end ; end ;
14180: END
// every 0 0$1 trigger legionOffertTime <= 0 0$00 do
14181: LD_EXP 34
14185: PUSH
14186: LD_INT 0
14188: LESSEQUAL
14189: IFFALSE 14210
14191: GO 14193
14193: DISABLE
// begin legionOffertCountdown = false ;
14194: LD_ADDR_EXP 33
14198: PUSH
14199: LD_INT 0
14201: ST_TO_ADDR
// americansAttack = true ;
14202: LD_ADDR_EXP 26
14206: PUSH
14207: LD_INT 1
14209: ST_TO_ADDR
// end ;
14210: END
// every 0 0$1 trigger legionOffertCountdown do var needCrates , depots , depot , crates ;
14211: LD_EXP 33
14215: IFFALSE 14401
14217: GO 14219
14219: DISABLE
14220: LD_INT 0
14222: PPUSH
14223: PPUSH
14224: PPUSH
14225: PPUSH
// begin needCrates = 50 ;
14226: LD_ADDR_VAR 0 1
14230: PUSH
14231: LD_INT 50
14233: ST_TO_ADDR
// crates = 0 ;
14234: LD_ADDR_VAR 0 4
14238: PUSH
14239: LD_INT 0
14241: ST_TO_ADDR
// depots = FilterAllUnits ( [ [ f_side , 3 ] , [ [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ] ) ;
14242: LD_ADDR_VAR 0 2
14246: PUSH
14247: LD_INT 22
14249: PUSH
14250: LD_INT 3
14252: PUSH
14253: EMPTY
14254: LIST
14255: LIST
14256: PUSH
14257: LD_INT 2
14259: PUSH
14260: LD_INT 30
14262: PUSH
14263: LD_INT 0
14265: PUSH
14266: EMPTY
14267: LIST
14268: LIST
14269: PUSH
14270: LD_INT 30
14272: PUSH
14273: LD_INT 1
14275: PUSH
14276: EMPTY
14277: LIST
14278: LIST
14279: PUSH
14280: EMPTY
14281: LIST
14282: LIST
14283: LIST
14284: PUSH
14285: EMPTY
14286: LIST
14287: PUSH
14288: EMPTY
14289: LIST
14290: LIST
14291: PPUSH
14292: CALL_OW 69
14296: ST_TO_ADDR
// for depot in depots do
14297: LD_ADDR_VAR 0 3
14301: PUSH
14302: LD_VAR 0 2
14306: PUSH
14307: FOR_IN
14308: IFFALSE 14399
// begin crates = GetResourceType ( GetBase ( depot ) , mat_cans ) ;
14310: LD_ADDR_VAR 0 4
14314: PUSH
14315: LD_VAR 0 3
14319: PPUSH
14320: CALL_OW 274
14324: PPUSH
14325: LD_INT 1
14327: PPUSH
14328: CALL_OW 275
14332: ST_TO_ADDR
// if crates >= needCrates then
14333: LD_VAR 0 4
14337: PUSH
14338: LD_VAR 0 1
14342: GREATEREQUAL
14343: IFFALSE 14397
// begin SetResourceType ( GetBase ( depot ) , mat_cans , crates - needCrates ) ;
14345: LD_VAR 0 3
14349: PPUSH
14350: CALL_OW 274
14354: PPUSH
14355: LD_INT 1
14357: PPUSH
14358: LD_VAR 0 4
14362: PUSH
14363: LD_VAR 0 1
14367: MINUS
14368: PPUSH
14369: CALL_OW 277
// legionOffertCountdown = false ;
14373: LD_ADDR_EXP 33
14377: PUSH
14378: LD_INT 0
14380: ST_TO_ADDR
// paidLegionOffert = true ;
14381: LD_ADDR_EXP 32
14385: PUSH
14386: LD_INT 1
14388: ST_TO_ADDR
// americansAttack = true ;
14389: LD_ADDR_EXP 26
14393: PUSH
14394: LD_INT 1
14396: ST_TO_ADDR
// end ; end ;
14397: GO 14307
14399: POP
14400: POP
// end ;
14401: PPOPN 4
14403: END
// every 0 0$1 trigger currentAmWave >= americansAttackWaves and FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_type , unit_human ] , [ f_and , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ] ] ) = 0 do
14404: LD_EXP 85
14408: PUSH
14409: LD_EXP 48
14413: GREATEREQUAL
14414: PUSH
14415: LD_INT 22
14417: PUSH
14418: LD_INT 1
14420: PUSH
14421: EMPTY
14422: LIST
14423: LIST
14424: PUSH
14425: LD_INT 2
14427: PUSH
14428: LD_INT 21
14430: PUSH
14431: LD_INT 1
14433: PUSH
14434: EMPTY
14435: LIST
14436: LIST
14437: PUSH
14438: LD_INT 1
14440: PUSH
14441: LD_INT 21
14443: PUSH
14444: LD_INT 2
14446: PUSH
14447: EMPTY
14448: LIST
14449: LIST
14450: PUSH
14451: LD_INT 33
14453: PUSH
14454: LD_INT 3
14456: PUSH
14457: EMPTY
14458: LIST
14459: LIST
14460: PUSH
14461: EMPTY
14462: LIST
14463: LIST
14464: LIST
14465: PUSH
14466: EMPTY
14467: LIST
14468: LIST
14469: LIST
14470: PUSH
14471: EMPTY
14472: LIST
14473: LIST
14474: PPUSH
14475: CALL_OW 69
14479: PUSH
14480: LD_INT 0
14482: EQUAL
14483: AND
14484: IFFALSE 14684
14486: GO 14488
14488: DISABLE
// begin DialogueOn ;
14489: CALL_OW 6
// if IsOK ( Belkov ) then
14493: LD_EXP 66
14497: PPUSH
14498: CALL_OW 302
14502: IFFALSE 14518
// Say ( Belkov , DAmAttackFin-Bel-1 ) else
14504: LD_EXP 66
14508: PPUSH
14509: LD_STRING DAmAttackFin-Bel-1
14511: PPUSH
14512: CALL_OW 88
14516: GO 14541
// if IsOK ( Belkov2 ) then
14518: LD_EXP 67
14522: PPUSH
14523: CALL_OW 302
14527: IFFALSE 14541
// Say ( Belkov2 , DAmAttackFin-Bel-1 ) ;
14529: LD_EXP 67
14533: PPUSH
14534: LD_STRING DAmAttackFin-Bel-1
14536: PPUSH
14537: CALL_OW 88
// if IsOK ( Gnyevko ) then
14541: LD_EXP 69
14545: PPUSH
14546: CALL_OW 302
14550: IFFALSE 14564
// Say ( Gnyevko , DAmAttackFin-Gny-1 ) ;
14552: LD_EXP 69
14556: PPUSH
14557: LD_STRING DAmAttackFin-Gny-1
14559: PPUSH
14560: CALL_OW 88
// if IsOK ( Titov ) then
14564: LD_EXP 62
14568: PPUSH
14569: CALL_OW 302
14573: IFFALSE 14587
// Say ( Titov , DAmAttackFin-Tit-1 ) ;
14575: LD_EXP 62
14579: PPUSH
14580: LD_STRING DAmAttackFin-Tit-1
14582: PPUSH
14583: CALL_OW 88
// if IsOK ( Lipshchin ) then
14587: LD_EXP 64
14591: PPUSH
14592: CALL_OW 302
14596: IFFALSE 14610
// Say ( Lipshchin , DAmAttackFin-Lip-1 ) ;
14598: LD_EXP 64
14602: PPUSH
14603: LD_STRING DAmAttackFin-Lip-1
14605: PPUSH
14606: CALL_OW 88
// if IsOK ( Karamazov ) then
14610: LD_EXP 58
14614: PPUSH
14615: CALL_OW 302
14619: IFFALSE 14633
// Say ( Karamazov , DAmAttackFin-Kar-1 ) ;
14621: LD_EXP 58
14625: PPUSH
14626: LD_STRING DAmAttackFin-Kar-1
14628: PPUSH
14629: CALL_OW 88
// if IsOK ( Oblukov ) then
14633: LD_EXP 74
14637: PPUSH
14638: CALL_OW 302
14642: IFFALSE 14656
// Say ( Oblukov , DAmAttackFin-Obl-1 ) ;
14644: LD_EXP 74
14648: PPUSH
14649: LD_STRING DAmAttackFin-Obl-1
14651: PPUSH
14652: CALL_OW 88
// Say ( Burlak , AmAttackFin-Bur-1 ) ;
14656: LD_EXP 57
14660: PPUSH
14661: LD_STRING AmAttackFin-Bur-1
14663: PPUSH
14664: CALL_OW 88
// SayRadio ( Popov , DAmAttackFin-Pop-1 ) ;
14668: LD_EXP 76
14672: PPUSH
14673: LD_STRING DAmAttackFin-Pop-1
14675: PPUSH
14676: CALL_OW 94
// DialogueOff ;
14680: CALL_OW 7
// end ;
14684: END
// every 0 0$1 trigger buildingsToBuild + ( 3 - GetAmountWeaponsDataBuildOnTurret ( true ) ) = 0 do
14685: LD_EXP 8
14689: PUSH
14690: LD_INT 3
14692: PUSH
14693: LD_INT 1
14695: PPUSH
14696: CALL 6690 0 1
14700: MINUS
14701: PLUS
14702: PUSH
14703: LD_INT 0
14705: EQUAL
14706: IFFALSE 14718
14708: GO 14710
14710: DISABLE
// ChangeMissionObjectives ( MBuildingsDone ) ;
14711: LD_STRING MBuildingsDone
14713: PPUSH
14714: CALL_OW 337
14718: END
// every 0 0$1 trigger GetAmountWeaponsDataBuildOnVehicle ( false ) = 0 do
14719: LD_INT 0
14721: PPUSH
14722: CALL 6800 0 1
14726: PUSH
14727: LD_INT 0
14729: EQUAL
14730: IFFALSE 14742
14732: GO 14734
14734: DISABLE
// ChangeMissionObjectives ( MWeaponsDone ) ;
14735: LD_STRING MWeaponsDone
14737: PPUSH
14738: CALL_OW 337
14742: END
// every 0 0$1 trigger techsToResearch = 0 do
14743: LD_EXP 9
14747: PUSH
14748: LD_INT 0
14750: EQUAL
14751: IFFALSE 14763
14753: GO 14755
14755: DISABLE
// ChangeMissionObjectives ( MTechnoDone ) ;
14756: LD_STRING MTechnoDone
14758: PPUSH
14759: CALL_OW 337
14763: END
// every 0 0$1 trigger americansAttack and not FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_type , unit_human ] , [ f_and , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ] ] ) do
14764: LD_EXP 26
14768: PUSH
14769: LD_INT 22
14771: PUSH
14772: LD_INT 1
14774: PUSH
14775: EMPTY
14776: LIST
14777: LIST
14778: PUSH
14779: LD_INT 2
14781: PUSH
14782: LD_INT 21
14784: PUSH
14785: LD_INT 1
14787: PUSH
14788: EMPTY
14789: LIST
14790: LIST
14791: PUSH
14792: LD_INT 1
14794: PUSH
14795: LD_INT 21
14797: PUSH
14798: LD_INT 2
14800: PUSH
14801: EMPTY
14802: LIST
14803: LIST
14804: PUSH
14805: LD_INT 33
14807: PUSH
14808: LD_INT 3
14810: PUSH
14811: EMPTY
14812: LIST
14813: LIST
14814: PUSH
14815: EMPTY
14816: LIST
14817: LIST
14818: LIST
14819: PUSH
14820: EMPTY
14821: LIST
14822: LIST
14823: LIST
14824: PUSH
14825: EMPTY
14826: LIST
14827: LIST
14828: PPUSH
14829: CALL_OW 69
14833: NOT
14834: AND
14835: IFFALSE 14847
14837: GO 14839
14839: DISABLE
// ChangeMissionObjectives ( MEnemyDone ) ;
14840: LD_STRING MEnemyDone
14842: PPUSH
14843: CALL_OW 337
14847: END
// every 0 0$1 trigger ( buildingsToBuild + ( 3 - GetAmountWeaponsDataBuildOnTurret ( true ) ) ) = 0 and GetAmountWeaponsDataBuildOnVehicle ( false ) = 0 and techsToResearch = 0 and FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] ] ) = 0 and FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_type , unit_human ] , [ f_and , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ] ] ) = 0 and Masha and IsOK ( Masha [ 1 ] ) and buildCompVehicle and testedTeleport do
14848: LD_EXP 8
14852: PUSH
14853: LD_INT 3
14855: PUSH
14856: LD_INT 1
14858: PPUSH
14859: CALL 6690 0 1
14863: MINUS
14864: PLUS
14865: PUSH
14866: LD_INT 0
14868: EQUAL
14869: PUSH
14870: LD_INT 0
14872: PPUSH
14873: CALL 6800 0 1
14877: PUSH
14878: LD_INT 0
14880: EQUAL
14881: AND
14882: PUSH
14883: LD_EXP 9
14887: PUSH
14888: LD_INT 0
14890: EQUAL
14891: AND
14892: PUSH
14893: LD_INT 22
14895: PUSH
14896: LD_INT 8
14898: PUSH
14899: EMPTY
14900: LIST
14901: LIST
14902: PUSH
14903: LD_INT 21
14905: PUSH
14906: LD_INT 1
14908: PUSH
14909: EMPTY
14910: LIST
14911: LIST
14912: PUSH
14913: EMPTY
14914: LIST
14915: LIST
14916: PPUSH
14917: CALL_OW 69
14921: PUSH
14922: LD_INT 0
14924: EQUAL
14925: AND
14926: PUSH
14927: LD_INT 22
14929: PUSH
14930: LD_INT 1
14932: PUSH
14933: EMPTY
14934: LIST
14935: LIST
14936: PUSH
14937: LD_INT 2
14939: PUSH
14940: LD_INT 21
14942: PUSH
14943: LD_INT 1
14945: PUSH
14946: EMPTY
14947: LIST
14948: LIST
14949: PUSH
14950: LD_INT 1
14952: PUSH
14953: LD_INT 21
14955: PUSH
14956: LD_INT 2
14958: PUSH
14959: EMPTY
14960: LIST
14961: LIST
14962: PUSH
14963: LD_INT 33
14965: PUSH
14966: LD_INT 3
14968: PUSH
14969: EMPTY
14970: LIST
14971: LIST
14972: PUSH
14973: EMPTY
14974: LIST
14975: LIST
14976: LIST
14977: PUSH
14978: EMPTY
14979: LIST
14980: LIST
14981: LIST
14982: PUSH
14983: EMPTY
14984: LIST
14985: LIST
14986: PPUSH
14987: CALL_OW 69
14991: PUSH
14992: LD_INT 0
14994: EQUAL
14995: AND
14996: PUSH
14997: LD_EXP 4
15001: AND
15002: PUSH
15003: LD_EXP 4
15007: PUSH
15008: LD_INT 1
15010: ARRAY
15011: PPUSH
15012: CALL_OW 302
15016: AND
15017: PUSH
15018: LD_EXP 37
15022: AND
15023: PUSH
15024: LD_EXP 39
15028: AND
15029: IFFALSE 15038
15031: GO 15033
15033: DISABLE
// begin FinishMission ;
15034: CALL 15243 0 0
// end ;
15038: END
// every 0 0$1 do var unit ;
15039: GO 15041
15041: DISABLE
15042: LD_INT 0
15044: PPUSH
// begin case allowExitFromMap of 1 :
15045: LD_EXP 18
15049: PUSH
15050: LD_INT 1
15052: DOUBLE
15053: EQUAL
15054: IFTRUE 15058
15056: GO 15086
15058: POP
// RemoveUnits ( FilterUnitsInArea ( ExitMapArea , [ [ f_side , 6 ] ] ) ) ; 3 :
15059: LD_INT 8
15061: PPUSH
15062: LD_INT 22
15064: PUSH
15065: LD_INT 6
15067: PUSH
15068: EMPTY
15069: LIST
15070: LIST
15071: PUSH
15072: EMPTY
15073: LIST
15074: PPUSH
15075: CALL_OW 70
15079: PPUSH
15080: CALL 6526 0 1
15084: GO 15209
15086: LD_INT 3
15088: DOUBLE
15089: EQUAL
15090: IFTRUE 15094
15092: GO 15122
15094: POP
// RemoveUnits ( FilterUnitsInArea ( KurtExitMapArea , [ [ f_side , 8 ] ] ) ) ; 4 :
15095: LD_INT 11
15097: PPUSH
15098: LD_INT 22
15100: PUSH
15101: LD_INT 8
15103: PUSH
15104: EMPTY
15105: LIST
15106: LIST
15107: PUSH
15108: EMPTY
15109: LIST
15110: PPUSH
15111: CALL_OW 70
15115: PPUSH
15116: CALL 6526 0 1
15120: GO 15209
15122: LD_INT 4
15124: DOUBLE
15125: EQUAL
15126: IFTRUE 15130
15128: GO 15208
15130: POP
// begin RemoveUnits ( FilterUnitsInArea ( ExitMapArea , [ [ f_side , 8 ] ] ) ) ;
15131: LD_INT 8
15133: PPUSH
15134: LD_INT 22
15136: PUSH
15137: LD_INT 8
15139: PUSH
15140: EMPTY
15141: LIST
15142: LIST
15143: PUSH
15144: EMPTY
15145: LIST
15146: PPUSH
15147: CALL_OW 70
15151: PPUSH
15152: CALL 6526 0 1
// RemoveUnits ( FilterUnitsInArea ( KurtExitMapArea , [ [ f_side , 8 ] ] ) ) ;
15156: LD_INT 11
15158: PPUSH
15159: LD_INT 22
15161: PUSH
15162: LD_INT 8
15164: PUSH
15165: EMPTY
15166: LIST
15167: LIST
15168: PUSH
15169: EMPTY
15170: LIST
15171: PPUSH
15172: CALL_OW 70
15176: PPUSH
15177: CALL 6526 0 1
// RemoveUnits ( FilterUnitsInArea ( ExitMapArea , [ [ f_side , 2 ] ] ) ) ;
15181: LD_INT 8
15183: PPUSH
15184: LD_INT 22
15186: PUSH
15187: LD_INT 2
15189: PUSH
15190: EMPTY
15191: LIST
15192: LIST
15193: PUSH
15194: EMPTY
15195: LIST
15196: PPUSH
15197: CALL_OW 70
15201: PPUSH
15202: CALL 6526 0 1
// end ; end ;
15206: GO 15209
15208: POP
// enable ;
15209: ENABLE
// end ; end_of_file
15210: PPOPN 1
15212: END
// export function Lose_Burlak ; begin
15213: LD_INT 0
15215: PPUSH
// YouLost ( Burlak ) ;
15216: LD_STRING Burlak
15218: PPUSH
15219: CALL_OW 104
// end ;
15223: LD_VAR 0 1
15227: RET
// export function Lost_AttackAlly ; begin
15228: LD_INT 0
15230: PPUSH
// YouLost ( SelfAttack ) ;
15231: LD_STRING SelfAttack
15233: PPUSH
15234: CALL_OW 104
// end ; end_of_file
15238: LD_VAR 0 1
15242: RET
// export function FinishMission ; begin
15243: LD_INT 0
15245: PPUSH
// SetRewards ;
15246: CALL 15267 0 0
// SavePlayerCharacters ;
15250: CALL 15528 0 0
// SaveGlobalVariables ;
15254: CALL 16078 0 0
// YouWin ;
15258: CALL_OW 103
// end ;
15262: LD_VAR 0 1
15266: RET
// function SetRewards ; begin
15267: LD_INT 0
15269: PPUSH
// AddMedal ( ArtisticImpression , 1 ) ;
15270: LD_STRING ArtisticImpression
15272: PPUSH
15273: LD_INT 1
15275: PPUSH
15276: CALL_OW 101
// if not HeikeCaptured then
15280: LD_EXP 1
15284: NOT
15285: IFFALSE 15319
// begin if speedMedalTime >= 0 0$00 then
15287: LD_EXP 52
15291: PUSH
15292: LD_INT 0
15294: GREATEREQUAL
15295: IFFALSE 15309
// AddMedal ( Speed , 1 ) else
15297: LD_STRING Speed
15299: PPUSH
15300: LD_INT 1
15302: PPUSH
15303: CALL_OW 101
15307: GO 15319
// AddMedal ( Speed , 1 ) ;
15309: LD_STRING Speed
15311: PPUSH
15312: LD_INT 1
15314: PPUSH
15315: CALL_OW 101
// end ; if lostUnits then
15319: LD_EXP 40
15323: IFFALSE 15338
// begin AddMedal ( FavouriteCommander , - 1 ) ;
15325: LD_STRING FavouriteCommander
15327: PPUSH
15328: LD_INT 1
15330: NEG
15331: PPUSH
15332: CALL_OW 101
// end else
15336: GO 15430
// begin case BurlakRespect of 0 :
15338: LD_EXP 30
15342: PUSH
15343: LD_INT 0
15345: DOUBLE
15346: EQUAL
15347: IFTRUE 15351
15349: GO 15365
15351: POP
// AddMedal ( FavouriteCommander , - 2 ) ; 1 :
15352: LD_STRING FavouriteCommander
15354: PPUSH
15355: LD_INT 2
15357: NEG
15358: PPUSH
15359: CALL_OW 101
15363: GO 15430
15365: LD_INT 1
15367: DOUBLE
15368: EQUAL
15369: IFTRUE 15373
15371: GO 15387
15373: POP
// AddMedal ( FavouriteCommander , - 3 ) ; 2 :
15374: LD_STRING FavouriteCommander
15376: PPUSH
15377: LD_INT 3
15379: NEG
15380: PPUSH
15381: CALL_OW 101
15385: GO 15430
15387: LD_INT 2
15389: DOUBLE
15390: EQUAL
15391: IFTRUE 15395
15393: GO 15408
15395: POP
// AddMedal ( FavouriteCommander , 1 ) ; 3 :
15396: LD_STRING FavouriteCommander
15398: PPUSH
15399: LD_INT 1
15401: PPUSH
15402: CALL_OW 101
15406: GO 15430
15408: LD_INT 3
15410: DOUBLE
15411: EQUAL
15412: IFTRUE 15416
15414: GO 15429
15416: POP
// AddMedal ( FavouriteCommander , 1 ) ; end ;
15417: LD_STRING FavouriteCommander
15419: PPUSH
15420: LD_INT 1
15422: PPUSH
15423: CALL_OW 101
15427: GO 15430
15429: POP
// end ; if HeikeCaptured then
15430: LD_EXP 1
15434: IFFALSE 15465
// begin if buildArabBarrack then
15436: LD_EXP 38
15440: IFFALSE 15454
// AddMedal ( ArabBarracks , 1 ) else
15442: LD_STRING ArabBarracks
15444: PPUSH
15445: LD_INT 1
15447: PPUSH
15448: CALL_OW 101
15452: GO 15465
// AddMedal ( ArabBarracks , - 1 ) ;
15454: LD_STRING ArabBarracks
15456: PPUSH
15457: LD_INT 1
15459: NEG
15460: PPUSH
15461: CALL_OW 101
// end ; GiveMedals ( Main1 ) ;
15465: LD_STRING Main1
15467: PPUSH
15468: CALL_OW 102
// RewardPeople ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_nation , nation_russian ] , [ f_ok ] ] ) ) ;
15472: LD_INT 22
15474: PUSH
15475: LD_INT 3
15477: PUSH
15478: EMPTY
15479: LIST
15480: LIST
15481: PUSH
15482: LD_INT 21
15484: PUSH
15485: LD_INT 1
15487: PUSH
15488: EMPTY
15489: LIST
15490: LIST
15491: PUSH
15492: LD_INT 23
15494: PUSH
15495: LD_INT 3
15497: PUSH
15498: EMPTY
15499: LIST
15500: LIST
15501: PUSH
15502: LD_INT 50
15504: PUSH
15505: EMPTY
15506: LIST
15507: PUSH
15508: EMPTY
15509: LIST
15510: LIST
15511: LIST
15512: LIST
15513: PPUSH
15514: CALL_OW 69
15518: PPUSH
15519: CALL_OW 43
// end ;
15523: LD_VAR 0 1
15527: RET
// function SavePlayerCharacters ; var randomsToSave ; begin
15528: LD_INT 0
15530: PPUSH
15531: PPUSH
// ExtSaveCharacter ( Burlak , Burlak , 3 ) ;
15532: LD_EXP 57
15536: PPUSH
15537: LD_STRING Burlak
15539: PPUSH
15540: LD_INT 3
15542: PPUSH
15543: CALL 6048 0 3
// ExtSaveCharacter ( Karamazov , Karamazov , 3 ) ;
15547: LD_EXP 58
15551: PPUSH
15552: LD_STRING Karamazov
15554: PPUSH
15555: LD_INT 3
15557: PPUSH
15558: CALL 6048 0 3
// ExtSaveCharacter ( Petrovova , Petrovova , 3 ) ;
15562: LD_EXP 59
15566: PPUSH
15567: LD_STRING Petrovova
15569: PPUSH
15570: LD_INT 3
15572: PPUSH
15573: CALL 6048 0 3
// ExtSaveCharacter ( Gleb , Gleb , 3 ) ;
15577: LD_EXP 60
15581: PPUSH
15582: LD_STRING Gleb
15584: PPUSH
15585: LD_INT 3
15587: PPUSH
15588: CALL 6048 0 3
// ExtSaveCharacter ( Petrosyan , Petrosyan , 3 ) ;
15592: LD_EXP 61
15596: PPUSH
15597: LD_STRING Petrosyan
15599: PPUSH
15600: LD_INT 3
15602: PPUSH
15603: CALL 6048 0 3
// ExtSaveCharacter ( Dolgov , Dolgov , 3 ) ;
15607: LD_EXP 63
15611: PPUSH
15612: LD_STRING Dolgov
15614: PPUSH
15615: LD_INT 3
15617: PPUSH
15618: CALL 6048 0 3
// ExtSaveCharacter ( Lipshchin , Lipshchin , 3 ) ;
15622: LD_EXP 64
15626: PPUSH
15627: LD_STRING Lipshchin
15629: PPUSH
15630: LD_INT 3
15632: PPUSH
15633: CALL 6048 0 3
// ExtSaveCharacter ( Titov , Titov , 3 ) ;
15637: LD_EXP 62
15641: PPUSH
15642: LD_STRING Titov
15644: PPUSH
15645: LD_INT 3
15647: PPUSH
15648: CALL 6048 0 3
// ExtSaveCharacter ( Kirilenkova , Kirilenkova , 3 ) ;
15652: LD_EXP 65
15656: PPUSH
15657: LD_STRING Kirilenkova
15659: PPUSH
15660: LD_INT 3
15662: PPUSH
15663: CALL 6048 0 3
// ExtSaveCharacter ( Belkov , Belkov , 3 ) ;
15667: LD_EXP 66
15671: PPUSH
15672: LD_STRING Belkov
15674: PPUSH
15675: LD_INT 3
15677: PPUSH
15678: CALL 6048 0 3
// ExtSaveCharacter ( Belkov2 , Belkov2 , 3 ) ;
15682: LD_EXP 67
15686: PPUSH
15687: LD_STRING Belkov2
15689: PPUSH
15690: LD_INT 3
15692: PPUSH
15693: CALL 6048 0 3
// ExtSaveCharacter ( Xavier , Xavier , 3 ) ;
15697: LD_EXP 68
15701: PPUSH
15702: LD_STRING Xavier
15704: PPUSH
15705: LD_INT 3
15707: PPUSH
15708: CALL 6048 0 3
// ExtSaveCharacter ( Kozlov , Kozlov , 3 ) ;
15712: LD_EXP 73
15716: PPUSH
15717: LD_STRING Kozlov
15719: PPUSH
15720: LD_INT 3
15722: PPUSH
15723: CALL 6048 0 3
// ExtSaveCharacter ( Oblukov , Oblukov , 3 ) ;
15727: LD_EXP 74
15731: PPUSH
15732: LD_STRING Oblukov
15734: PPUSH
15735: LD_INT 3
15737: PPUSH
15738: CALL 6048 0 3
// ExtSaveCharacter ( Kapitsova , Kapitsova , 3 ) ;
15742: LD_EXP 75
15746: PPUSH
15747: LD_STRING Kapitsova
15749: PPUSH
15750: LD_INT 3
15752: PPUSH
15753: CALL 6048 0 3
// ExtSaveCharacter ( Gnyevko , Gnyevko , 3 ) ;
15757: LD_EXP 69
15761: PPUSH
15762: LD_STRING Gnyevko
15764: PPUSH
15765: LD_INT 3
15767: PPUSH
15768: CALL 6048 0 3
// ExtSaveCharacter ( Kovalyuk , Kovalyuk , 3 ) ;
15772: LD_EXP 70
15776: PPUSH
15777: LD_STRING Kovalyuk
15779: PPUSH
15780: LD_INT 3
15782: PPUSH
15783: CALL 6048 0 3
// ExtSaveCharacter ( Scholtze , Scholtze , 3 ) ;
15787: LD_EXP 71
15791: PPUSH
15792: LD_STRING Scholtze
15794: PPUSH
15795: LD_INT 3
15797: PPUSH
15798: CALL 6048 0 3
// ExtSaveCharacter ( Kuzmov , Kuzmov , 3 ) ;
15802: LD_EXP 72
15806: PPUSH
15807: LD_STRING Kuzmov
15809: PPUSH
15810: LD_INT 3
15812: PPUSH
15813: CALL 6048 0 3
// ExtSaveCharacters ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_or , [ f_class , class_apeman ] , [ f_class , class_apeman_engineer ] , [ f_class , class_apeman_soldier ] ] ] ) , other_apemans , 3 ) ;
15817: LD_INT 22
15819: PUSH
15820: LD_INT 3
15822: PUSH
15823: EMPTY
15824: LIST
15825: LIST
15826: PUSH
15827: LD_INT 21
15829: PUSH
15830: LD_INT 1
15832: PUSH
15833: EMPTY
15834: LIST
15835: LIST
15836: PUSH
15837: LD_INT 2
15839: PUSH
15840: LD_INT 25
15842: PUSH
15843: LD_INT 12
15845: PUSH
15846: EMPTY
15847: LIST
15848: LIST
15849: PUSH
15850: LD_INT 25
15852: PUSH
15853: LD_INT 16
15855: PUSH
15856: EMPTY
15857: LIST
15858: LIST
15859: PUSH
15860: LD_INT 25
15862: PUSH
15863: LD_INT 15
15865: PUSH
15866: EMPTY
15867: LIST
15868: LIST
15869: PUSH
15870: EMPTY
15871: LIST
15872: LIST
15873: LIST
15874: LIST
15875: PUSH
15876: EMPTY
15877: LIST
15878: LIST
15879: LIST
15880: PPUSH
15881: CALL_OW 69
15885: PPUSH
15886: LD_STRING other_apemans
15888: PPUSH
15889: LD_INT 3
15891: PPUSH
15892: CALL 6105 0 3
// randomsToSave = FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_nation , nation_russian ] ] ) diff [ Burlak , Karamazov , Petrovova , Gleb , Petrosyan , Titov , Dolgov , Lipshchin , Kirilenkova , Belkov , Belkov2 , Xavier , Gnyevko , Kovalyuk , Scholtze , Kuzmov , Kozlov , Oblukov , Kapitsova ] ;
15896: LD_ADDR_VAR 0 2
15900: PUSH
15901: LD_INT 22
15903: PUSH
15904: LD_INT 3
15906: PUSH
15907: EMPTY
15908: LIST
15909: LIST
15910: PUSH
15911: LD_INT 21
15913: PUSH
15914: LD_INT 1
15916: PUSH
15917: EMPTY
15918: LIST
15919: LIST
15920: PUSH
15921: LD_INT 23
15923: PUSH
15924: LD_INT 3
15926: PUSH
15927: EMPTY
15928: LIST
15929: LIST
15930: PUSH
15931: EMPTY
15932: LIST
15933: LIST
15934: LIST
15935: PPUSH
15936: CALL_OW 69
15940: PUSH
15941: LD_EXP 57
15945: PUSH
15946: LD_EXP 58
15950: PUSH
15951: LD_EXP 59
15955: PUSH
15956: LD_EXP 60
15960: PUSH
15961: LD_EXP 61
15965: PUSH
15966: LD_EXP 62
15970: PUSH
15971: LD_EXP 63
15975: PUSH
15976: LD_EXP 64
15980: PUSH
15981: LD_EXP 65
15985: PUSH
15986: LD_EXP 66
15990: PUSH
15991: LD_EXP 67
15995: PUSH
15996: LD_EXP 68
16000: PUSH
16001: LD_EXP 69
16005: PUSH
16006: LD_EXP 70
16010: PUSH
16011: LD_EXP 71
16015: PUSH
16016: LD_EXP 72
16020: PUSH
16021: LD_EXP 73
16025: PUSH
16026: LD_EXP 74
16030: PUSH
16031: LD_EXP 75
16035: PUSH
16036: EMPTY
16037: LIST
16038: LIST
16039: LIST
16040: LIST
16041: LIST
16042: LIST
16043: LIST
16044: LIST
16045: LIST
16046: LIST
16047: LIST
16048: LIST
16049: LIST
16050: LIST
16051: LIST
16052: LIST
16053: LIST
16054: LIST
16055: LIST
16056: DIFF
16057: ST_TO_ADDR
// ExtSaveCharacters ( randomsToSave , other_survivors , 3 ) ;
16058: LD_VAR 0 2
16062: PPUSH
16063: LD_STRING other_survivors
16065: PPUSH
16066: LD_INT 3
16068: PPUSH
16069: CALL 6105 0 3
// end ;
16073: LD_VAR 0 1
16077: RET
// function SaveGlobalVariables ; begin
16078: LD_INT 0
16080: PPUSH
// SaveBase ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_building ] ] ) , 08_TrockyBase_1 ) ;
16081: LD_INT 22
16083: PUSH
16084: LD_INT 3
16086: PUSH
16087: EMPTY
16088: LIST
16089: LIST
16090: PUSH
16091: LD_INT 21
16093: PUSH
16094: LD_INT 3
16096: PUSH
16097: EMPTY
16098: LIST
16099: LIST
16100: PUSH
16101: EMPTY
16102: LIST
16103: LIST
16104: PPUSH
16105: CALL_OW 69
16109: PPUSH
16110: LD_STRING 08_TrockyBase_1
16112: PPUSH
16113: CALL 8484 0 2
// SaveVariable ( coopWithGensher , 08_CoopWithGensher_2 ) ;
16117: LD_EXP 2
16121: PPUSH
16122: LD_STRING 08_CoopWithGensher_2
16124: PPUSH
16125: CALL_OW 39
// SaveVariable ( HeikeStatus , 08_HeikeStatus_3 ) ;
16129: LD_EXP 3
16133: PPUSH
16134: LD_STRING 08_HeikeStatus_3
16136: PPUSH
16137: CALL_OW 39
// SaveVariable ( Masha , 08_Masha_4 ) ;
16141: LD_EXP 4
16145: PPUSH
16146: LD_STRING 08_Masha_4
16148: PPUSH
16149: CALL_OW 39
// end ; end_of_file
16153: LD_VAR 0 1
16157: RET
// export function CustomEvent ( event ) ; begin
16158: LD_INT 0
16160: PPUSH
// end ;
16161: LD_VAR 0 2
16165: RET
// on BuildingComplete ( building ) do begin if GetBType ( building ) in buildingsToBuild and GetNation ( building ) = nation_russian then
16166: LD_VAR 0 1
16170: PPUSH
16171: CALL_OW 266
16175: PUSH
16176: LD_EXP 8
16180: IN
16181: PUSH
16182: LD_VAR 0 1
16186: PPUSH
16187: CALL_OW 248
16191: PUSH
16192: LD_INT 3
16194: EQUAL
16195: AND
16196: IFFALSE 16219
// buildingsToBuild = buildingsToBuild diff GetBType ( building ) ;
16198: LD_ADDR_EXP 8
16202: PUSH
16203: LD_EXP 8
16207: PUSH
16208: LD_VAR 0 1
16212: PPUSH
16213: CALL_OW 266
16217: DIFF
16218: ST_TO_ADDR
// if GetBType ( building ) = b_depot then
16219: LD_VAR 0 1
16223: PPUSH
16224: CALL_OW 266
16228: PUSH
16229: LD_INT 0
16231: EQUAL
16232: IFFALSE 16283
// begin SetBName ( building , trockij ) ;
16234: LD_VAR 0 1
16238: PPUSH
16239: LD_STRING trockij
16241: PPUSH
16242: CALL_OW 500
// if not dial_BuildDepotBlocker and HeikeCaptured then
16246: LD_EXP 5
16250: NOT
16251: PUSH
16252: LD_EXP 1
16256: AND
16257: IFFALSE 16283
// Dial_EscortHeike ( GetX ( building ) , GetY ( building ) ) ;
16259: LD_VAR 0 1
16263: PPUSH
16264: CALL_OW 250
16268: PPUSH
16269: LD_VAR 0 1
16273: PPUSH
16274: CALL_OW 251
16278: PPUSH
16279: CALL 9149 0 2
// end ; end ;
16283: PPOPN 1
16285: END
// on UpgradeComplete ( building ) do begin if GetBType ( building ) in buildingsToBuild and GetNation ( building ) = nation_russian then
16286: LD_VAR 0 1
16290: PPUSH
16291: CALL_OW 266
16295: PUSH
16296: LD_EXP 8
16300: IN
16301: PUSH
16302: LD_VAR 0 1
16306: PPUSH
16307: CALL_OW 248
16311: PUSH
16312: LD_INT 3
16314: EQUAL
16315: AND
16316: IFFALSE 16339
// buildingsToBuild = buildingsToBuild diff GetBType ( building ) ;
16318: LD_ADDR_EXP 8
16322: PUSH
16323: LD_EXP 8
16327: PUSH
16328: LD_VAR 0 1
16332: PPUSH
16333: CALL_OW 266
16337: DIFF
16338: ST_TO_ADDR
// if GetBType ( building ) = b_barracks and GetNation ( building ) = 2 and not dial_BuildArBarrackBlocker then
16339: LD_VAR 0 1
16343: PPUSH
16344: CALL_OW 266
16348: PUSH
16349: LD_INT 5
16351: EQUAL
16352: PUSH
16353: LD_VAR 0 1
16357: PPUSH
16358: CALL_OW 248
16362: PUSH
16363: LD_INT 2
16365: EQUAL
16366: AND
16367: PUSH
16368: LD_EXP 6
16372: NOT
16373: AND
16374: IFFALSE 16380
// Dial_UpgradeArmoury ;
16376: CALL 9960 0 0
// end ;
16380: PPOPN 1
16382: END
// on ResearchComplete ( research , building ) do begin if research in techsToResearch then
16383: LD_VAR 0 1
16387: PUSH
16388: LD_EXP 9
16392: IN
16393: IFFALSE 16411
// techsToResearch = techsToResearch diff research ;
16395: LD_ADDR_EXP 9
16399: PUSH
16400: LD_EXP 9
16404: PUSH
16405: LD_VAR 0 1
16409: DIFF
16410: ST_TO_ADDR
// if research = tech_LimTeleport then
16411: LD_VAR 0 1
16415: PUSH
16416: LD_INT 37
16418: EQUAL
16419: IFFALSE 16425
// Dial_TeleportTechResearched ;
16421: CALL 13805 0 0
// if research = tech_AdvAI then
16425: LD_VAR 0 1
16429: PUSH
16430: LD_INT 27
16432: EQUAL
16433: IFFALSE 16439
// Dial_ComputerTechResearched ;
16435: CALL 13674 0 0
// end ;
16439: PPOPN 2
16441: END
// on EnterVehicle ( vehicle , human ) do begin if not canChooseMashaVehicle then
16442: LD_EXP 36
16446: NOT
16447: IFFALSE 16451
// exit ;
16449: GO 16618
// wait ( 0 0$1 ) ;
16451: LD_INT 35
16453: PPUSH
16454: CALL_OW 67
// if GetSide ( vehicle ) = 3 and human = Burlak and GetNation ( vehicle ) = nation_russian and GetWeapon ( vehicle ) in [ ru_heavy_machine_gun , ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher ] then
16458: LD_VAR 0 1
16462: PPUSH
16463: CALL_OW 255
16467: PUSH
16468: LD_INT 3
16470: EQUAL
16471: PUSH
16472: LD_VAR 0 2
16476: PUSH
16477: LD_EXP 57
16481: EQUAL
16482: AND
16483: PUSH
16484: LD_VAR 0 1
16488: PPUSH
16489: CALL_OW 248
16493: PUSH
16494: LD_INT 3
16496: EQUAL
16497: AND
16498: PUSH
16499: LD_VAR 0 1
16503: PPUSH
16504: CALL_OW 264
16508: PUSH
16509: LD_INT 42
16511: PUSH
16512: LD_INT 43
16514: PUSH
16515: LD_INT 44
16517: PUSH
16518: LD_INT 46
16520: PUSH
16521: LD_INT 45
16523: PUSH
16524: EMPTY
16525: LIST
16526: LIST
16527: LIST
16528: LIST
16529: LIST
16530: IN
16531: AND
16532: IFFALSE 16618
// begin if Masha then
16534: LD_EXP 4
16538: IFFALSE 16558
// if Masha [ 1 ] = vehicle then
16540: LD_EXP 4
16544: PUSH
16545: LD_INT 1
16547: ARRAY
16548: PUSH
16549: LD_VAR 0 1
16553: EQUAL
16554: IFFALSE 16558
// exit ;
16556: GO 16618
// if firstMashaQuery then
16558: LD_EXP 35
16562: IFFALSE 16596
// begin firstMashaQuery = false ;
16564: LD_ADDR_EXP 35
16568: PUSH
16569: LD_INT 0
16571: ST_TO_ADDR
// if Query ( QMashaQuery ) = 1 then
16572: LD_STRING QMashaQuery
16574: PPUSH
16575: CALL_OW 97
16579: PUSH
16580: LD_INT 1
16582: EQUAL
16583: IFFALSE 16594
// SetMashaData ( vehicle ) ;
16585: LD_VAR 0 1
16589: PPUSH
16590: CALL 8378 0 1
// end else
16594: GO 16618
// begin if Query ( QMashaQuery2 ) = 1 then
16596: LD_STRING QMashaQuery2
16598: PPUSH
16599: CALL_OW 97
16603: PUSH
16604: LD_INT 1
16606: EQUAL
16607: IFFALSE 16618
// SetMashaData ( vehicle ) ;
16609: LD_VAR 0 1
16613: PPUSH
16614: CALL 8378 0 1
// end ; end ; end ;
16618: PPOPN 2
16620: END
// on UnitDestroyed ( unit ) do begin if Masha then
16621: LD_EXP 4
16625: IFFALSE 16650
// if unit = Masha [ 1 ] then
16627: LD_VAR 0 1
16631: PUSH
16632: LD_EXP 4
16636: PUSH
16637: LD_INT 1
16639: ARRAY
16640: EQUAL
16641: IFFALSE 16650
// Masha = [ ] ;
16643: LD_ADDR_EXP 4
16647: PUSH
16648: EMPTY
16649: ST_TO_ADDR
// if unit = Burlak then
16650: LD_VAR 0 1
16654: PUSH
16655: LD_EXP 57
16659: EQUAL
16660: IFFALSE 16666
// Lose_Burlak ;
16662: CALL 15213 0 0
// if GetType ( unit ) = unit_human and GetNation ( unit ) = nation_russian then
16666: LD_VAR 0 1
16670: PPUSH
16671: CALL_OW 247
16675: PUSH
16676: LD_INT 1
16678: EQUAL
16679: PUSH
16680: LD_VAR 0 1
16684: PPUSH
16685: CALL_OW 248
16689: PUSH
16690: LD_INT 3
16692: EQUAL
16693: AND
16694: IFFALSE 16710
// lostUnits = lostUnits + 1 ;
16696: LD_ADDR_EXP 40
16700: PUSH
16701: LD_EXP 40
16705: PUSH
16706: LD_INT 1
16708: PLUS
16709: ST_TO_ADDR
// end ;
16710: PPOPN 1
16712: END
// on UnitGoesToRed ( unit ) do begin if GetType ( unit ) = unit_vehicle and GetNation ( unit ) = nation_russian and GetTech ( tech_LimTeleport , 3 ) = state_researched and not testedTeleport then
16713: LD_VAR 0 1
16717: PPUSH
16718: CALL_OW 247
16722: PUSH
16723: LD_INT 2
16725: EQUAL
16726: PUSH
16727: LD_VAR 0 1
16731: PPUSH
16732: CALL_OW 248
16736: PUSH
16737: LD_INT 3
16739: EQUAL
16740: AND
16741: PUSH
16742: LD_INT 37
16744: PPUSH
16745: LD_INT 3
16747: PPUSH
16748: CALL_OW 321
16752: PUSH
16753: LD_INT 2
16755: EQUAL
16756: AND
16757: PUSH
16758: LD_EXP 39
16762: NOT
16763: AND
16764: IFFALSE 16781
// begin testedTeleport = true ;
16766: LD_ADDR_EXP 39
16770: PUSH
16771: LD_INT 1
16773: ST_TO_ADDR
// ChangeMissionObjectives ( MTeleDone ) ;
16774: LD_STRING MTeleDone
16776: PPUSH
16777: CALL_OW 337
// end ; if unit = Heike then
16781: LD_VAR 0 1
16785: PUSH
16786: LD_EXP 79
16790: EQUAL
16791: IFFALSE 16834
// begin DialogueOn ;
16793: CALL_OW 6
// CenterNowOnUnits ( Heike ) ;
16797: LD_EXP 79
16801: PPUSH
16802: CALL_OW 87
// ForceSay ( Heike , DHeikeKilled-Hke-1 ) ;
16806: LD_EXP 79
16810: PPUSH
16811: LD_STRING DHeikeKilled-Hke-1
16813: PPUSH
16814: CALL_OW 91
// DialogueOff ;
16818: CALL_OW 7
// SetLives ( Heike , 0 ) ;
16822: LD_EXP 79
16826: PPUSH
16827: LD_INT 0
16829: PPUSH
16830: CALL_OW 234
// end ; end ;
16834: PPOPN 1
16836: END
// on Contact ( side1 , side2 ) do begin if side1 = 3 and side2 = 6 then
16837: LD_VAR 0 1
16841: PUSH
16842: LD_INT 3
16844: EQUAL
16845: PUSH
16846: LD_VAR 0 2
16850: PUSH
16851: LD_INT 6
16853: EQUAL
16854: AND
16855: IFFALSE 16861
// Lost_AttackAlly ;
16857: CALL 15228 0 0
// if side1 = 3 and side2 = 2 then
16861: LD_VAR 0 1
16865: PUSH
16866: LD_INT 3
16868: EQUAL
16869: PUSH
16870: LD_VAR 0 2
16874: PUSH
16875: LD_INT 2
16877: EQUAL
16878: AND
16879: IFFALSE 16885
// Dial_AttackGensher ;
16881: CALL 10916 0 0
// if side1 = 3 and side2 = 5 then
16885: LD_VAR 0 1
16889: PUSH
16890: LD_INT 3
16892: EQUAL
16893: PUSH
16894: LD_VAR 0 2
16898: PUSH
16899: LD_INT 5
16901: EQUAL
16902: AND
16903: IFFALSE 16947
// begin SetAttitude ( 3 , 5 , att_enemy , true ) ;
16905: LD_INT 3
16907: PPUSH
16908: LD_INT 5
16910: PPUSH
16911: LD_INT 2
16913: PPUSH
16914: LD_INT 1
16916: PPUSH
16917: CALL_OW 80
// if acceptKurtOffert and not GetSide ( Kurt ) = 2 then
16921: LD_EXP 19
16925: PUSH
16926: LD_EXP 80
16930: PPUSH
16931: CALL_OW 255
16935: PUSH
16936: LD_INT 2
16938: EQUAL
16939: NOT
16940: AND
16941: IFFALSE 16947
// Dial_BetrayedKurt1 ;
16943: CALL 11465 0 0
// end ; if side1 = 3 and side2 = 8 and GetAttitude ( 3 , 8 ) = att_neutral then
16947: LD_VAR 0 1
16951: PUSH
16952: LD_INT 3
16954: EQUAL
16955: PUSH
16956: LD_VAR 0 2
16960: PUSH
16961: LD_INT 8
16963: EQUAL
16964: AND
16965: PUSH
16966: LD_INT 3
16968: PPUSH
16969: LD_INT 8
16971: PPUSH
16972: CALL_OW 81
16976: PUSH
16977: LD_INT 0
16979: EQUAL
16980: AND
16981: IFFALSE 16993
// begin if acceptKurtOffert then
16983: LD_EXP 19
16987: IFFALSE 16993
// Dial_BetrayedKurt2 ;
16989: CALL 11551 0 0
// end ; end ;
16993: PPOPN 2
16995: END
// on VehicleConstructed ( vehicle , building ) do begin SetWeaponDataBuild ( GetWeapon ( vehicle ) , false ) ;
16996: LD_VAR 0 1
17000: PPUSH
17001: CALL_OW 264
17005: PPUSH
17006: LD_INT 0
17008: PPUSH
17009: CALL 6886 0 2
// if GetControl ( vehicle ) = control_computer and not buildCompVehicle then
17013: LD_VAR 0 1
17017: PPUSH
17018: CALL_OW 263
17022: PUSH
17023: LD_INT 3
17025: EQUAL
17026: PUSH
17027: LD_EXP 37
17031: NOT
17032: AND
17033: IFFALSE 17050
// begin buildCompVehicle = true ;
17035: LD_ADDR_EXP 37
17039: PUSH
17040: LD_INT 1
17042: ST_TO_ADDR
// ChangeMissionObjectives ( MAIDone ) ;
17043: LD_STRING MAIDone
17045: PPUSH
17046: CALL_OW 337
// end ; end ;
17050: PPOPN 2
17052: END
// on WeaponPlaced ( building , factory ) do begin SetWeaponDataBuild ( GetBWeapon ( building ) , true ) ;
17053: LD_VAR 0 1
17057: PPUSH
17058: CALL_OW 269
17062: PPUSH
17063: LD_INT 1
17065: PPUSH
17066: CALL 6886 0 2
// end ;
17070: PPOPN 2
17072: END
// on Command ( comandid ) do var i ;
17073: LD_INT 0
17075: PPUSH
// begin if IsOK ( KurtEng ) and GetSide ( KurtEng ) = 3 then
17076: LD_EXP 82
17080: PPUSH
17081: CALL_OW 302
17085: PUSH
17086: LD_EXP 82
17090: PPUSH
17091: CALL_OW 255
17095: PUSH
17096: LD_INT 3
17098: EQUAL
17099: AND
17100: IFFALSE 17309
// if GetTaskList ( KurtEng ) then
17102: LD_EXP 82
17106: PPUSH
17107: CALL_OW 437
17111: IFFALSE 17309
// begin for i := 1 to ( GetTaskList ( KurtEng ) ) do
17113: LD_ADDR_VAR 0 2
17117: PUSH
17118: DOUBLE
17119: LD_INT 1
17121: DEC
17122: ST_TO_ADDR
17123: LD_EXP 82
17127: PPUSH
17128: CALL_OW 437
17132: PUSH
17133: FOR_TO
17134: IFFALSE 17307
// begin if ( GetTaskList ( KurtEng ) [ i ] [ 1 ] in [ F , H , M , U , V , a , h , u , v , ~ , ^ , > , + , ; , 4 , { ] ) or ( GetTaskList ( KurtEng ) [ i ] [ 1 ] = B and GetTaskList ( KurtEng ) [ i ] [ 5 ] = 36 ) then
17136: LD_EXP 82
17140: PPUSH
17141: CALL_OW 437
17145: PUSH
17146: LD_VAR 0 2
17150: ARRAY
17151: PUSH
17152: LD_INT 1
17154: ARRAY
17155: PUSH
17156: LD_STRING F
17158: PUSH
17159: LD_STRING H
17161: PUSH
17162: LD_STRING M
17164: PUSH
17165: LD_STRING U
17167: PUSH
17168: LD_STRING V
17170: PUSH
17171: LD_STRING a
17173: PUSH
17174: LD_STRING h
17176: PUSH
17177: LD_STRING u
17179: PUSH
17180: LD_STRING v
17182: PUSH
17183: LD_STRING ~
17185: PUSH
17186: LD_STRING ^
17188: PUSH
17189: LD_STRING >
17191: PUSH
17192: LD_STRING +
17194: PUSH
17195: LD_STRING ;
17197: PUSH
17198: LD_STRING 4
17200: PUSH
17201: LD_STRING {
17203: PUSH
17204: EMPTY
17205: LIST
17206: LIST
17207: LIST
17208: LIST
17209: LIST
17210: LIST
17211: LIST
17212: LIST
17213: LIST
17214: LIST
17215: LIST
17216: LIST
17217: LIST
17218: LIST
17219: LIST
17220: LIST
17221: IN
17222: PUSH
17223: LD_EXP 82
17227: PPUSH
17228: CALL_OW 437
17232: PUSH
17233: LD_VAR 0 2
17237: ARRAY
17238: PUSH
17239: LD_INT 1
17241: ARRAY
17242: PUSH
17243: LD_STRING B
17245: EQUAL
17246: PUSH
17247: LD_EXP 82
17251: PPUSH
17252: CALL_OW 437
17256: PUSH
17257: LD_VAR 0 2
17261: ARRAY
17262: PUSH
17263: LD_INT 5
17265: ARRAY
17266: PUSH
17267: LD_INT 36
17269: EQUAL
17270: AND
17271: OR
17272: IFFALSE 17276
// else
17274: GO 17305
// begin RemoveTasks ( KurtEng ) ;
17276: LD_EXP 82
17280: PPUSH
17281: CALL_OW 493
// DialogueOn ;
17285: CALL_OW 6
// Say ( Kurt , DMercRefuseBuild-Kurt-1 ) ;
17289: LD_EXP 80
17293: PPUSH
17294: LD_STRING DMercRefuseBuild-Kurt-1
17296: PPUSH
17297: CALL_OW 88
// DialogueOff ;
17301: CALL_OW 7
// end ; end ;
17305: GO 17133
17307: POP
17308: POP
// end ; end ; end_of_file
17309: PPOPN 2
17311: END
// every 0 0$01 do var timer , cratesSpawned ;
17312: GO 17314
17314: DISABLE
17315: LD_INT 0
17317: PPUSH
17318: PPUSH
// begin timer := 1 1$30 ;
17319: LD_ADDR_VAR 0 1
17323: PUSH
17324: LD_INT 3150
17326: ST_TO_ADDR
// repeat wait ( timer ) ;
17327: LD_VAR 0 1
17331: PPUSH
17332: CALL_OW 67
// if cratesSpawned >= 6 and cratesSpawned < 18 then
17336: LD_VAR 0 2
17340: PUSH
17341: LD_INT 6
17343: GREATEREQUAL
17344: PUSH
17345: LD_VAR 0 2
17349: PUSH
17350: LD_INT 18
17352: LESS
17353: AND
17354: IFFALSE 17370
// timer := timer + 0 0$3 ;
17356: LD_ADDR_VAR 0 1
17360: PUSH
17361: LD_VAR 0 1
17365: PUSH
17366: LD_INT 105
17368: PLUS
17369: ST_TO_ADDR
// if cratesSpawned >= 18 then
17370: LD_VAR 0 2
17374: PUSH
17375: LD_INT 18
17377: GREATEREQUAL
17378: IFFALSE 17394
// timer := timer + 0 0$9 ;
17380: LD_ADDR_VAR 0 1
17384: PUSH
17385: LD_VAR 0 1
17389: PUSH
17390: LD_INT 315
17392: PLUS
17393: ST_TO_ADDR
// if timer > 3 3$00 then
17394: LD_VAR 0 1
17398: PUSH
17399: LD_INT 6300
17401: GREATER
17402: IFFALSE 17412
// timer := 0 0$50 ;
17404: LD_ADDR_VAR 0 1
17408: PUSH
17409: LD_INT 1750
17411: ST_TO_ADDR
// CreateCratesArea ( rand ( 3 , 5 ) , CratesSpawnArea , true ) ;
17412: LD_INT 3
17414: PPUSH
17415: LD_INT 5
17417: PPUSH
17418: CALL_OW 12
17422: PPUSH
17423: LD_INT 15
17425: PPUSH
17426: LD_INT 1
17428: PPUSH
17429: CALL_OW 55
// cratesSpawned = cratesSpawned + 1 ;
17433: LD_ADDR_VAR 0 2
17437: PUSH
17438: LD_VAR 0 2
17442: PUSH
17443: LD_INT 1
17445: PLUS
17446: ST_TO_ADDR
// until false ;
17447: LD_INT 0
17449: IFFALSE 17327
// end ; end_of_file
17451: PPOPN 2
17453: END
// every 0 0$1 do
17454: GO 17456
17456: DISABLE
// begin enable ;
17457: ENABLE
// end ;
17458: END
// every 0 0$1 do var building , playerBuildings , playerBuildingsBType ;
17459: GO 17461
17461: DISABLE
17462: LD_INT 0
17464: PPUSH
17465: PPUSH
17466: PPUSH
// begin playerBuildings = FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_building ] , [ f_nation , nation_russian ] ] ) ;
17467: LD_ADDR_VAR 0 2
17471: PUSH
17472: LD_INT 22
17474: PUSH
17475: LD_INT 3
17477: PUSH
17478: EMPTY
17479: LIST
17480: LIST
17481: PUSH
17482: LD_INT 21
17484: PUSH
17485: LD_INT 3
17487: PUSH
17488: EMPTY
17489: LIST
17490: LIST
17491: PUSH
17492: LD_INT 23
17494: PUSH
17495: LD_INT 3
17497: PUSH
17498: EMPTY
17499: LIST
17500: LIST
17501: PUSH
17502: EMPTY
17503: LIST
17504: LIST
17505: LIST
17506: PPUSH
17507: CALL_OW 69
17511: ST_TO_ADDR
// playerBuildingsBType = [ ] ;
17512: LD_ADDR_VAR 0 3
17516: PUSH
17517: EMPTY
17518: ST_TO_ADDR
// for building in playerBuildings do
17519: LD_ADDR_VAR 0 1
17523: PUSH
17524: LD_VAR 0 2
17528: PUSH
17529: FOR_IN
17530: IFFALSE 17555
// playerBuildingsBType = playerBuildingsBType ^ GetBType ( building ) ;
17532: LD_ADDR_VAR 0 3
17536: PUSH
17537: LD_VAR 0 3
17541: PUSH
17542: LD_VAR 0 1
17546: PPUSH
17547: CALL_OW 266
17551: ADD
17552: ST_TO_ADDR
17553: GO 17529
17555: POP
17556: POP
// for building in allBuildings do
17557: LD_ADDR_VAR 0 1
17561: PUSH
17562: LD_EXP 13
17566: PUSH
17567: FOR_IN
17568: IFFALSE 17614
// if not building in playerBuildingsBType and not building in buildingsToBuild then
17570: LD_VAR 0 1
17574: PUSH
17575: LD_VAR 0 3
17579: IN
17580: NOT
17581: PUSH
17582: LD_VAR 0 1
17586: PUSH
17587: LD_EXP 8
17591: IN
17592: NOT
17593: AND
17594: IFFALSE 17612
// buildingsToBuild = buildingsToBuild ^ building ;
17596: LD_ADDR_EXP 8
17600: PUSH
17601: LD_EXP 8
17605: PUSH
17606: LD_VAR 0 1
17610: ADD
17611: ST_TO_ADDR
17612: GO 17567
17614: POP
17615: POP
// enable ;
17616: ENABLE
// end ;
17617: PPOPN 3
17619: END
// every 0 0$1 trigger legionOffertCountdown do
17620: LD_EXP 33
17624: IFFALSE 17644
17626: GO 17628
17628: DISABLE
// begin legionOffertTime = legionOffertTime - 0 0$01 ;
17629: LD_ADDR_EXP 34
17633: PUSH
17634: LD_EXP 34
17638: PUSH
17639: LD_INT 35
17641: MINUS
17642: ST_TO_ADDR
// enable ;
17643: ENABLE
// end ;
17644: END
// every 0 0$1 trigger KurtWaitingForFreeHeike do
17645: LD_EXP 23
17649: IFFALSE 17683
17651: GO 17653
17653: DISABLE
// begin timeToFreeHeike = timeToFreeHeike - 0 0$01 ;
17654: LD_ADDR_EXP 54
17658: PUSH
17659: LD_EXP 54
17663: PUSH
17664: LD_INT 35
17666: MINUS
17667: ST_TO_ADDR
// if timeToFreeHeike <= 0 0$00 then
17668: LD_EXP 54
17672: PUSH
17673: LD_INT 0
17675: LESSEQUAL
17676: IFFALSE 17682
// Dial_PlayerDontSendHeike ;
17678: CALL 11413 0 0
// enable ;
17682: ENABLE
// end ;
17683: END
// every 0 0$1 trigger KurtWaitingForBuildBarrack and GetSide ( KurtEng ) = 3 do
17684: LD_EXP 24
17688: PUSH
17689: LD_EXP 82
17693: PPUSH
17694: CALL_OW 255
17698: PUSH
17699: LD_INT 3
17701: EQUAL
17702: AND
17703: IFFALSE 17776
17705: GO 17707
17707: DISABLE
// begin timeToBuildArBarrack = timeToBuildArBarrack - 0 0$01 ;
17708: LD_ADDR_EXP 55
17712: PUSH
17713: LD_EXP 55
17717: PUSH
17718: LD_INT 35
17720: MINUS
17721: ST_TO_ADDR
// if timeToBuildArBarrack <= 0 0$00 then
17722: LD_EXP 55
17726: PUSH
17727: LD_INT 0
17729: LESSEQUAL
17730: IFFALSE 17775
// begin Dial_BetrayedKurt1 ;
17732: CALL 11465 0 0
// wait ( 2 2$0 ) ;
17736: LD_INT 4200
17738: PPUSH
17739: CALL_OW 67
// SetAttitude ( 3 , 8 , att_enemy , true ) ;
17743: LD_INT 3
17745: PPUSH
17746: LD_INT 8
17748: PPUSH
17749: LD_INT 2
17751: PPUSH
17752: LD_INT 1
17754: PPUSH
17755: CALL_OW 80
// KurtAttack = true ;
17759: LD_ADDR_EXP 25
17763: PUSH
17764: LD_INT 1
17766: ST_TO_ADDR
// KurtWaitingForBuildBarrack = false ;
17767: LD_ADDR_EXP 24
17771: PUSH
17772: LD_INT 0
17774: ST_TO_ADDR
// end ; enable ;
17775: ENABLE
// end ; end_of_file
17776: END
// export currentAmWave , currentArWave ; every 0 0$1 trigger americansAttack do var i ;
17777: LD_EXP 26
17781: IFFALSE 17927
17783: GO 17785
17785: DISABLE
17786: LD_INT 0
17788: PPUSH
// begin currentAmWave = 0 ;
17789: LD_ADDR_EXP 85
17793: PUSH
17794: LD_INT 0
17796: ST_TO_ADDR
// wait ( firstAttackDelay ) ;
17797: LD_EXP 49
17801: PPUSH
17802: CALL_OW 67
// for i := 1 to americansAttackWaves do
17806: LD_ADDR_VAR 0 1
17810: PUSH
17811: DOUBLE
17812: LD_INT 1
17814: DEC
17815: ST_TO_ADDR
17816: LD_EXP 48
17820: PUSH
17821: FOR_TO
17822: IFFALSE 17925
// begin SpawnAmAttackTeam ;
17824: CALL 3214 0 0
// currentAmWave = currentAmWave + 1 ;
17828: LD_ADDR_EXP 85
17832: PUSH
17833: LD_EXP 85
17837: PUSH
17838: LD_INT 1
17840: PLUS
17841: ST_TO_ADDR
// if currentAmWave = 1 then
17842: LD_EXP 85
17846: PUSH
17847: LD_INT 1
17849: EQUAL
17850: IFFALSE 17914
// begin if paidLegionOffert then
17852: LD_EXP 32
17856: IFFALSE 17895
// begin Say ( Burlak , DAmAttackStart-Bur-1 ) ;
17858: LD_EXP 57
17862: PPUSH
17863: LD_STRING DAmAttackStart-Bur-1
17865: PPUSH
17866: CALL_OW 88
// if IsOK ( Gleb ) then
17870: LD_EXP 60
17874: PPUSH
17875: CALL_OW 302
17879: IFFALSE 17893
// Say ( Gleb , DAmAttackStart-Glb-1 ) ;
17881: LD_EXP 60
17885: PPUSH
17886: LD_STRING DAmAttackStart-Glb-1
17888: PPUSH
17889: CALL_OW 88
// end else
17893: GO 17907
// Say ( Burlak , DAmAttackStart-Bur-2 ) ;
17895: LD_EXP 57
17899: PPUSH
17900: LD_STRING DAmAttackStart-Bur-2
17902: PPUSH
17903: CALL_OW 88
// ChangeMissionObjectives ( MEnemy ) ;
17907: LD_STRING MEnemy
17909: PPUSH
17910: CALL_OW 337
// end ; wait ( waveCooldown ) ;
17914: LD_EXP 50
17918: PPUSH
17919: CALL_OW 67
// end ;
17923: GO 17821
17925: POP
17926: POP
// end ;
17927: PPOPN 1
17929: END
// every 0 0$1 trigger currentAmWave = 1 do
17930: LD_EXP 85
17934: PUSH
17935: LD_INT 1
17937: EQUAL
17938: IFFALSE 18027
17940: GO 17942
17942: DISABLE
// Attack ( [ 0 , amAttackTeam , [ [ 115 , 42 ] , [ 51 , 67 ] ] , [ 0 , 0 , 0 , 1 , 1 , 1 , 0 , 0 , 1 , 0 ] ] ) ;
17943: LD_INT 0
17945: PUSH
17946: LD_EXP 78
17950: PUSH
17951: LD_INT 115
17953: PUSH
17954: LD_INT 42
17956: PUSH
17957: EMPTY
17958: LIST
17959: LIST
17960: PUSH
17961: LD_INT 51
17963: PUSH
17964: LD_INT 67
17966: PUSH
17967: EMPTY
17968: LIST
17969: LIST
17970: PUSH
17971: EMPTY
17972: LIST
17973: LIST
17974: PUSH
17975: LD_INT 0
17977: PUSH
17978: LD_INT 0
17980: PUSH
17981: LD_INT 0
17983: PUSH
17984: LD_INT 1
17986: PUSH
17987: LD_INT 1
17989: PUSH
17990: LD_INT 1
17992: PUSH
17993: LD_INT 0
17995: PUSH
17996: LD_INT 0
17998: PUSH
17999: LD_INT 1
18001: PUSH
18002: LD_INT 0
18004: PUSH
18005: EMPTY
18006: LIST
18007: LIST
18008: LIST
18009: LIST
18010: LIST
18011: LIST
18012: LIST
18013: LIST
18014: LIST
18015: LIST
18016: PUSH
18017: EMPTY
18018: LIST
18019: LIST
18020: LIST
18021: LIST
18022: PPUSH
18023: CALL 78615 0 1
18027: END
// every 0 0$1 trigger currentAmWave = 2 do
18028: LD_EXP 85
18032: PUSH
18033: LD_INT 2
18035: EQUAL
18036: IFFALSE 18125
18038: GO 18040
18040: DISABLE
// Attack ( [ 0 , amAttackTeam , [ [ 115 , 42 ] , [ 51 , 67 ] ] , [ 0 , 0 , 0 , 1 , 1 , 1 , 0 , 0 , 1 , 0 ] ] ) ;
18041: LD_INT 0
18043: PUSH
18044: LD_EXP 78
18048: PUSH
18049: LD_INT 115
18051: PUSH
18052: LD_INT 42
18054: PUSH
18055: EMPTY
18056: LIST
18057: LIST
18058: PUSH
18059: LD_INT 51
18061: PUSH
18062: LD_INT 67
18064: PUSH
18065: EMPTY
18066: LIST
18067: LIST
18068: PUSH
18069: EMPTY
18070: LIST
18071: LIST
18072: PUSH
18073: LD_INT 0
18075: PUSH
18076: LD_INT 0
18078: PUSH
18079: LD_INT 0
18081: PUSH
18082: LD_INT 1
18084: PUSH
18085: LD_INT 1
18087: PUSH
18088: LD_INT 1
18090: PUSH
18091: LD_INT 0
18093: PUSH
18094: LD_INT 0
18096: PUSH
18097: LD_INT 1
18099: PUSH
18100: LD_INT 0
18102: PUSH
18103: EMPTY
18104: LIST
18105: LIST
18106: LIST
18107: LIST
18108: LIST
18109: LIST
18110: LIST
18111: LIST
18112: LIST
18113: LIST
18114: PUSH
18115: EMPTY
18116: LIST
18117: LIST
18118: LIST
18119: LIST
18120: PPUSH
18121: CALL 78615 0 1
18125: END
// every 0 0$1 trigger currentAmWave = 3 do
18126: LD_EXP 85
18130: PUSH
18131: LD_INT 3
18133: EQUAL
18134: IFFALSE 18223
18136: GO 18138
18138: DISABLE
// Attack ( [ 0 , amAttackTeam , [ [ 115 , 42 ] , [ 51 , 67 ] ] , [ 0 , 0 , 0 , 1 , 1 , 1 , 0 , 0 , 1 , 0 ] ] ) ;
18139: LD_INT 0
18141: PUSH
18142: LD_EXP 78
18146: PUSH
18147: LD_INT 115
18149: PUSH
18150: LD_INT 42
18152: PUSH
18153: EMPTY
18154: LIST
18155: LIST
18156: PUSH
18157: LD_INT 51
18159: PUSH
18160: LD_INT 67
18162: PUSH
18163: EMPTY
18164: LIST
18165: LIST
18166: PUSH
18167: EMPTY
18168: LIST
18169: LIST
18170: PUSH
18171: LD_INT 0
18173: PUSH
18174: LD_INT 0
18176: PUSH
18177: LD_INT 0
18179: PUSH
18180: LD_INT 1
18182: PUSH
18183: LD_INT 1
18185: PUSH
18186: LD_INT 1
18188: PUSH
18189: LD_INT 0
18191: PUSH
18192: LD_INT 0
18194: PUSH
18195: LD_INT 1
18197: PUSH
18198: LD_INT 0
18200: PUSH
18201: EMPTY
18202: LIST
18203: LIST
18204: LIST
18205: LIST
18206: LIST
18207: LIST
18208: LIST
18209: LIST
18210: LIST
18211: LIST
18212: PUSH
18213: EMPTY
18214: LIST
18215: LIST
18216: LIST
18217: LIST
18218: PPUSH
18219: CALL 78615 0 1
18223: END
// every 0 0$1 trigger KurtAttack do var i ;
18224: LD_EXP 25
18228: IFFALSE 18349
18230: GO 18232
18232: DISABLE
18233: LD_INT 0
18235: PPUSH
// begin currentArWave = 0 ;
18236: LD_ADDR_EXP 86
18240: PUSH
18241: LD_INT 0
18243: ST_TO_ADDR
// wait ( firstAttackDelay ) ;
18244: LD_EXP 49
18248: PPUSH
18249: CALL_OW 67
// for i := 1 to KurtAttackWaves do
18253: LD_ADDR_VAR 0 1
18257: PUSH
18258: DOUBLE
18259: LD_INT 1
18261: DEC
18262: ST_TO_ADDR
18263: LD_EXP 47
18267: PUSH
18268: FOR_TO
18269: IFFALSE 18347
// begin if KurtAttack and IsOK ( Heike ) then
18271: LD_EXP 25
18275: PUSH
18276: LD_EXP 79
18280: PPUSH
18281: CALL_OW 302
18285: AND
18286: IFFALSE 18345
// begin SpawnArAttackTeam ;
18288: CALL 4359 0 0
// currentArWave = currentArWave + 1 ;
18292: LD_ADDR_EXP 86
18296: PUSH
18297: LD_EXP 86
18301: PUSH
18302: LD_INT 1
18304: PLUS
18305: ST_TO_ADDR
// if currentArWave = 2 then
18306: LD_EXP 86
18310: PUSH
18311: LD_INT 2
18313: EQUAL
18314: IFFALSE 18336
// begin SayRadio ( Kurt , DMercAttack-Kurt-1 ) ;
18316: LD_EXP 80
18320: PPUSH
18321: LD_STRING DMercAttack-Kurt-1
18323: PPUSH
18324: CALL_OW 94
// canSendHeike = true ;
18328: LD_ADDR_EXP 28
18332: PUSH
18333: LD_INT 1
18335: ST_TO_ADDR
// end ; wait ( waveCooldown ) ;
18336: LD_EXP 50
18340: PPUSH
18341: CALL_OW 67
// end ; end ;
18345: GO 18268
18347: POP
18348: POP
// end ;
18349: PPOPN 1
18351: END
// every 0 0$1 trigger currentArWave = 1 do
18352: LD_EXP 86
18356: PUSH
18357: LD_INT 1
18359: EQUAL
18360: IFFALSE 18449
18362: GO 18364
18364: DISABLE
// Attack ( [ 0 , arAttackTeam , [ [ 115 , 42 ] , [ 51 , 67 ] ] , [ 0 , 0 , 0 , 1 , 1 , 1 , 0 , 0 , 1 , 0 ] ] ) ;
18365: LD_INT 0
18367: PUSH
18368: LD_EXP 84
18372: PUSH
18373: LD_INT 115
18375: PUSH
18376: LD_INT 42
18378: PUSH
18379: EMPTY
18380: LIST
18381: LIST
18382: PUSH
18383: LD_INT 51
18385: PUSH
18386: LD_INT 67
18388: PUSH
18389: EMPTY
18390: LIST
18391: LIST
18392: PUSH
18393: EMPTY
18394: LIST
18395: LIST
18396: PUSH
18397: LD_INT 0
18399: PUSH
18400: LD_INT 0
18402: PUSH
18403: LD_INT 0
18405: PUSH
18406: LD_INT 1
18408: PUSH
18409: LD_INT 1
18411: PUSH
18412: LD_INT 1
18414: PUSH
18415: LD_INT 0
18417: PUSH
18418: LD_INT 0
18420: PUSH
18421: LD_INT 1
18423: PUSH
18424: LD_INT 0
18426: PUSH
18427: EMPTY
18428: LIST
18429: LIST
18430: LIST
18431: LIST
18432: LIST
18433: LIST
18434: LIST
18435: LIST
18436: LIST
18437: LIST
18438: PUSH
18439: EMPTY
18440: LIST
18441: LIST
18442: LIST
18443: LIST
18444: PPUSH
18445: CALL 78615 0 1
18449: END
// every 0 0$1 trigger currentArWave = 2 do
18450: LD_EXP 86
18454: PUSH
18455: LD_INT 2
18457: EQUAL
18458: IFFALSE 18547
18460: GO 18462
18462: DISABLE
// Attack ( [ 0 , arAttackTeam , [ [ 115 , 42 ] , [ 51 , 67 ] ] , [ 0 , 0 , 0 , 1 , 1 , 1 , 0 , 0 , 1 , 0 ] ] ) ;
18463: LD_INT 0
18465: PUSH
18466: LD_EXP 84
18470: PUSH
18471: LD_INT 115
18473: PUSH
18474: LD_INT 42
18476: PUSH
18477: EMPTY
18478: LIST
18479: LIST
18480: PUSH
18481: LD_INT 51
18483: PUSH
18484: LD_INT 67
18486: PUSH
18487: EMPTY
18488: LIST
18489: LIST
18490: PUSH
18491: EMPTY
18492: LIST
18493: LIST
18494: PUSH
18495: LD_INT 0
18497: PUSH
18498: LD_INT 0
18500: PUSH
18501: LD_INT 0
18503: PUSH
18504: LD_INT 1
18506: PUSH
18507: LD_INT 1
18509: PUSH
18510: LD_INT 1
18512: PUSH
18513: LD_INT 0
18515: PUSH
18516: LD_INT 0
18518: PUSH
18519: LD_INT 1
18521: PUSH
18522: LD_INT 0
18524: PUSH
18525: EMPTY
18526: LIST
18527: LIST
18528: LIST
18529: LIST
18530: LIST
18531: LIST
18532: LIST
18533: LIST
18534: LIST
18535: LIST
18536: PUSH
18537: EMPTY
18538: LIST
18539: LIST
18540: LIST
18541: LIST
18542: PPUSH
18543: CALL 78615 0 1
18547: END
// every 0 0$1 trigger currentArWave = 3 do
18548: LD_EXP 86
18552: PUSH
18553: LD_INT 3
18555: EQUAL
18556: IFFALSE 18645
18558: GO 18560
18560: DISABLE
// Attack ( [ 0 , arAttackTeam , [ [ 115 , 42 ] , [ 51 , 67 ] ] , [ 0 , 0 , 0 , 1 , 1 , 1 , 0 , 0 , 1 , 0 ] ] ) ;
18561: LD_INT 0
18563: PUSH
18564: LD_EXP 84
18568: PUSH
18569: LD_INT 115
18571: PUSH
18572: LD_INT 42
18574: PUSH
18575: EMPTY
18576: LIST
18577: LIST
18578: PUSH
18579: LD_INT 51
18581: PUSH
18582: LD_INT 67
18584: PUSH
18585: EMPTY
18586: LIST
18587: LIST
18588: PUSH
18589: EMPTY
18590: LIST
18591: LIST
18592: PUSH
18593: LD_INT 0
18595: PUSH
18596: LD_INT 0
18598: PUSH
18599: LD_INT 0
18601: PUSH
18602: LD_INT 1
18604: PUSH
18605: LD_INT 1
18607: PUSH
18608: LD_INT 1
18610: PUSH
18611: LD_INT 0
18613: PUSH
18614: LD_INT 0
18616: PUSH
18617: LD_INT 1
18619: PUSH
18620: LD_INT 0
18622: PUSH
18623: EMPTY
18624: LIST
18625: LIST
18626: LIST
18627: LIST
18628: LIST
18629: LIST
18630: LIST
18631: LIST
18632: LIST
18633: LIST
18634: PUSH
18635: EMPTY
18636: LIST
18637: LIST
18638: LIST
18639: LIST
18640: PPUSH
18641: CALL 78615 0 1
18645: END
// every 0 0$1 trigger currentArWave = 4 do
18646: LD_EXP 86
18650: PUSH
18651: LD_INT 4
18653: EQUAL
18654: IFFALSE 18743
18656: GO 18658
18658: DISABLE
// Attack ( [ 0 , arAttackTeam , [ [ 115 , 42 ] , [ 51 , 67 ] ] , [ 0 , 0 , 0 , 1 , 1 , 1 , 0 , 0 , 1 , 0 ] ] ) ;
18659: LD_INT 0
18661: PUSH
18662: LD_EXP 84
18666: PUSH
18667: LD_INT 115
18669: PUSH
18670: LD_INT 42
18672: PUSH
18673: EMPTY
18674: LIST
18675: LIST
18676: PUSH
18677: LD_INT 51
18679: PUSH
18680: LD_INT 67
18682: PUSH
18683: EMPTY
18684: LIST
18685: LIST
18686: PUSH
18687: EMPTY
18688: LIST
18689: LIST
18690: PUSH
18691: LD_INT 0
18693: PUSH
18694: LD_INT 0
18696: PUSH
18697: LD_INT 0
18699: PUSH
18700: LD_INT 1
18702: PUSH
18703: LD_INT 1
18705: PUSH
18706: LD_INT 1
18708: PUSH
18709: LD_INT 0
18711: PUSH
18712: LD_INT 0
18714: PUSH
18715: LD_INT 1
18717: PUSH
18718: LD_INT 0
18720: PUSH
18721: EMPTY
18722: LIST
18723: LIST
18724: LIST
18725: LIST
18726: LIST
18727: LIST
18728: LIST
18729: LIST
18730: LIST
18731: LIST
18732: PUSH
18733: EMPTY
18734: LIST
18735: LIST
18736: LIST
18737: LIST
18738: PPUSH
18739: CALL 78615 0 1
18743: END
// every 0 0$1 trigger currentArWave = 5 do
18744: LD_EXP 86
18748: PUSH
18749: LD_INT 5
18751: EQUAL
18752: IFFALSE 18841
18754: GO 18756
18756: DISABLE
// Attack ( [ 0 , arAttackTeam , [ [ 115 , 42 ] , [ 51 , 67 ] ] , [ 0 , 0 , 0 , 1 , 1 , 1 , 0 , 0 , 1 , 0 ] ] ) ; end_of_file
18757: LD_INT 0
18759: PUSH
18760: LD_EXP 84
18764: PUSH
18765: LD_INT 115
18767: PUSH
18768: LD_INT 42
18770: PUSH
18771: EMPTY
18772: LIST
18773: LIST
18774: PUSH
18775: LD_INT 51
18777: PUSH
18778: LD_INT 67
18780: PUSH
18781: EMPTY
18782: LIST
18783: LIST
18784: PUSH
18785: EMPTY
18786: LIST
18787: LIST
18788: PUSH
18789: LD_INT 0
18791: PUSH
18792: LD_INT 0
18794: PUSH
18795: LD_INT 0
18797: PUSH
18798: LD_INT 1
18800: PUSH
18801: LD_INT 1
18803: PUSH
18804: LD_INT 1
18806: PUSH
18807: LD_INT 0
18809: PUSH
18810: LD_INT 0
18812: PUSH
18813: LD_INT 1
18815: PUSH
18816: LD_INT 0
18818: PUSH
18819: EMPTY
18820: LIST
18821: LIST
18822: LIST
18823: LIST
18824: LIST
18825: LIST
18826: LIST
18827: LIST
18828: LIST
18829: LIST
18830: PUSH
18831: EMPTY
18832: LIST
18833: LIST
18834: LIST
18835: LIST
18836: PPUSH
18837: CALL 78615 0 1
18841: END
// every 0 0$1 do var arVehs , arVeh , nearPlayerUnit ;
18842: GO 18844
18844: DISABLE
18845: LD_INT 0
18847: PPUSH
18848: PPUSH
18849: PPUSH
// begin enable ;
18850: ENABLE
// arVehs = FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_vehicle ] , [ f_empty ] ] ) ;
18851: LD_ADDR_VAR 0 1
18855: PUSH
18856: LD_INT 22
18858: PUSH
18859: LD_INT 8
18861: PUSH
18862: EMPTY
18863: LIST
18864: LIST
18865: PUSH
18866: LD_INT 21
18868: PUSH
18869: LD_INT 2
18871: PUSH
18872: EMPTY
18873: LIST
18874: LIST
18875: PUSH
18876: LD_INT 58
18878: PUSH
18879: EMPTY
18880: LIST
18881: PUSH
18882: EMPTY
18883: LIST
18884: LIST
18885: LIST
18886: PPUSH
18887: CALL_OW 69
18891: ST_TO_ADDR
// if not arVehs or not GetAttitude ( 3 , 8 ) = att_enemy then
18892: LD_VAR 0 1
18896: NOT
18897: PUSH
18898: LD_INT 3
18900: PPUSH
18901: LD_INT 8
18903: PPUSH
18904: CALL_OW 81
18908: PUSH
18909: LD_INT 2
18911: EQUAL
18912: NOT
18913: OR
18914: IFFALSE 18918
// exit ;
18916: GO 19008
// for arVeh in arVehs do
18918: LD_ADDR_VAR 0 2
18922: PUSH
18923: LD_VAR 0 1
18927: PUSH
18928: FOR_IN
18929: IFFALSE 19006
// begin nearPlayerUnit = NearestUnitToUnit ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) , arVeh ) ;
18931: LD_ADDR_VAR 0 3
18935: PUSH
18936: LD_INT 22
18938: PUSH
18939: LD_INT 3
18941: PUSH
18942: EMPTY
18943: LIST
18944: LIST
18945: PUSH
18946: LD_INT 21
18948: PUSH
18949: LD_INT 1
18951: PUSH
18952: EMPTY
18953: LIST
18954: LIST
18955: PUSH
18956: EMPTY
18957: LIST
18958: LIST
18959: PPUSH
18960: CALL_OW 69
18964: PPUSH
18965: LD_VAR 0 2
18969: PPUSH
18970: CALL_OW 74
18974: ST_TO_ADDR
// if GetDistUnits ( nearPlayerUnit , arVeh ) <= 2 then
18975: LD_VAR 0 3
18979: PPUSH
18980: LD_VAR 0 2
18984: PPUSH
18985: CALL_OW 296
18989: PUSH
18990: LD_INT 2
18992: LESSEQUAL
18993: IFFALSE 19004
// ComSelfDestruction ( arVeh ) ;
18995: LD_VAR 0 2
18999: PPUSH
19000: CALL_OW 577
// end ;
19004: GO 18928
19006: POP
19007: POP
// end ;
19008: PPOPN 3
19010: END
// every 0 0$1 trigger forceStopKurtAttack do
19011: LD_EXP 27
19015: IFFALSE 19081
19017: GO 19019
19019: DISABLE
// begin KurtAttack = false ;
19020: LD_ADDR_EXP 25
19024: PUSH
19025: LD_INT 0
19027: ST_TO_ADDR
// allowExitFromMap = 4 ;
19028: LD_ADDR_EXP 18
19032: PUSH
19033: LD_INT 4
19035: ST_TO_ADDR
// SetAttitude ( 3 , 8 , att_friend , true ) ;
19036: LD_INT 3
19038: PPUSH
19039: LD_INT 8
19041: PPUSH
19042: LD_INT 1
19044: PPUSH
19045: LD_INT 1
19047: PPUSH
19048: CALL_OW 80
// arAttackTeam = [ ] ;
19052: LD_ADDR_EXP 84
19056: PUSH
19057: EMPTY
19058: ST_TO_ADDR
// ComMoveToArea ( FilterAllUnits ( [ f_side , 8 ] ) , KurtExitMapArea ) ;
19059: LD_INT 22
19061: PUSH
19062: LD_INT 8
19064: PUSH
19065: EMPTY
19066: LIST
19067: LIST
19068: PPUSH
19069: CALL_OW 69
19073: PPUSH
19074: LD_INT 11
19076: PPUSH
19077: CALL_OW 113
// end ; end_of_file end_of_file
19081: END
// every 0 0$01 do var timer , cratesSpawned ;
19082: GO 19084
19084: DISABLE
19085: LD_INT 0
19087: PPUSH
19088: PPUSH
// begin timer := 1 1$30 ;
19089: LD_ADDR_VAR 0 1
19093: PUSH
19094: LD_INT 3150
19096: ST_TO_ADDR
// repeat wait ( timer ) ;
19097: LD_VAR 0 1
19101: PPUSH
19102: CALL_OW 67
// if cratesSpawned >= 6 and cratesSpawned < 18 then
19106: LD_VAR 0 2
19110: PUSH
19111: LD_INT 6
19113: GREATEREQUAL
19114: PUSH
19115: LD_VAR 0 2
19119: PUSH
19120: LD_INT 18
19122: LESS
19123: AND
19124: IFFALSE 19140
// timer := timer + 0 0$3 ;
19126: LD_ADDR_VAR 0 1
19130: PUSH
19131: LD_VAR 0 1
19135: PUSH
19136: LD_INT 105
19138: PLUS
19139: ST_TO_ADDR
// if cratesSpawned >= 18 then
19140: LD_VAR 0 2
19144: PUSH
19145: LD_INT 18
19147: GREATEREQUAL
19148: IFFALSE 19164
// timer := timer + 0 0$9 ;
19150: LD_ADDR_VAR 0 1
19154: PUSH
19155: LD_VAR 0 1
19159: PUSH
19160: LD_INT 315
19162: PLUS
19163: ST_TO_ADDR
// if timer > 3 3$00 then
19164: LD_VAR 0 1
19168: PUSH
19169: LD_INT 6300
19171: GREATER
19172: IFFALSE 19182
// timer := 0 0$50 ;
19174: LD_ADDR_VAR 0 1
19178: PUSH
19179: LD_INT 1750
19181: ST_TO_ADDR
// CreateCratesArea ( rand ( 3 , 5 ) , CratesSpawnArea , true ) ;
19182: LD_INT 3
19184: PPUSH
19185: LD_INT 5
19187: PPUSH
19188: CALL_OW 12
19192: PPUSH
19193: LD_INT 15
19195: PPUSH
19196: LD_INT 1
19198: PPUSH
19199: CALL_OW 55
// cratesSpawned = cratesSpawned + 1 ;
19203: LD_ADDR_VAR 0 2
19207: PUSH
19208: LD_VAR 0 2
19212: PUSH
19213: LD_INT 1
19215: PLUS
19216: ST_TO_ADDR
// until false ;
19217: LD_INT 0
19219: IFFALSE 19097
// end ; end_of_file
19221: PPOPN 2
19223: END
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
19224: LD_INT 0
19226: PPUSH
19227: PPUSH
// if exist_mode then
19228: LD_VAR 0 2
19232: IFFALSE 19257
// unit := CreateCharacter ( prefix & ident ) else
19234: LD_ADDR_VAR 0 5
19238: PUSH
19239: LD_VAR 0 3
19243: PUSH
19244: LD_VAR 0 1
19248: STR
19249: PPUSH
19250: CALL_OW 34
19254: ST_TO_ADDR
19255: GO 19272
// unit := NewCharacter ( ident ) ;
19257: LD_ADDR_VAR 0 5
19261: PUSH
19262: LD_VAR 0 1
19266: PPUSH
19267: CALL_OW 25
19271: ST_TO_ADDR
// result := unit ;
19272: LD_ADDR_VAR 0 4
19276: PUSH
19277: LD_VAR 0 5
19281: ST_TO_ADDR
// end ;
19282: LD_VAR 0 4
19286: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
19287: LD_INT 0
19289: PPUSH
19290: PPUSH
// if not side or not nation then
19291: LD_VAR 0 1
19295: NOT
19296: PUSH
19297: LD_VAR 0 2
19301: NOT
19302: OR
19303: IFFALSE 19307
// exit ;
19305: GO 20075
// case nation of nation_american :
19307: LD_VAR 0 2
19311: PUSH
19312: LD_INT 1
19314: DOUBLE
19315: EQUAL
19316: IFTRUE 19320
19318: GO 19534
19320: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 86 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 , 82 , 83 , 84 , 85 , 86 ] ; nation_arabian :
19321: LD_ADDR_VAR 0 4
19325: PUSH
19326: LD_INT 35
19328: PUSH
19329: LD_INT 45
19331: PUSH
19332: LD_INT 46
19334: PUSH
19335: LD_INT 47
19337: PUSH
19338: LD_INT 82
19340: PUSH
19341: LD_INT 83
19343: PUSH
19344: LD_INT 84
19346: PUSH
19347: LD_INT 85
19349: PUSH
19350: LD_INT 86
19352: PUSH
19353: LD_INT 1
19355: PUSH
19356: LD_INT 2
19358: PUSH
19359: LD_INT 6
19361: PUSH
19362: LD_INT 15
19364: PUSH
19365: LD_INT 16
19367: PUSH
19368: LD_INT 7
19370: PUSH
19371: LD_INT 12
19373: PUSH
19374: LD_INT 13
19376: PUSH
19377: LD_INT 10
19379: PUSH
19380: LD_INT 14
19382: PUSH
19383: LD_INT 20
19385: PUSH
19386: LD_INT 21
19388: PUSH
19389: LD_INT 22
19391: PUSH
19392: LD_INT 25
19394: PUSH
19395: LD_INT 32
19397: PUSH
19398: LD_INT 27
19400: PUSH
19401: LD_INT 36
19403: PUSH
19404: LD_INT 69
19406: PUSH
19407: LD_INT 39
19409: PUSH
19410: LD_INT 34
19412: PUSH
19413: LD_INT 40
19415: PUSH
19416: LD_INT 48
19418: PUSH
19419: LD_INT 49
19421: PUSH
19422: LD_INT 50
19424: PUSH
19425: LD_INT 51
19427: PUSH
19428: LD_INT 52
19430: PUSH
19431: LD_INT 53
19433: PUSH
19434: LD_INT 54
19436: PUSH
19437: LD_INT 55
19439: PUSH
19440: LD_INT 56
19442: PUSH
19443: LD_INT 57
19445: PUSH
19446: LD_INT 58
19448: PUSH
19449: LD_INT 59
19451: PUSH
19452: LD_INT 60
19454: PUSH
19455: LD_INT 61
19457: PUSH
19458: LD_INT 62
19460: PUSH
19461: LD_INT 80
19463: PUSH
19464: LD_INT 82
19466: PUSH
19467: LD_INT 83
19469: PUSH
19470: LD_INT 84
19472: PUSH
19473: LD_INT 85
19475: PUSH
19476: LD_INT 86
19478: PUSH
19479: EMPTY
19480: LIST
19481: LIST
19482: LIST
19483: LIST
19484: LIST
19485: LIST
19486: LIST
19487: LIST
19488: LIST
19489: LIST
19490: LIST
19491: LIST
19492: LIST
19493: LIST
19494: LIST
19495: LIST
19496: LIST
19497: LIST
19498: LIST
19499: LIST
19500: LIST
19501: LIST
19502: LIST
19503: LIST
19504: LIST
19505: LIST
19506: LIST
19507: LIST
19508: LIST
19509: LIST
19510: LIST
19511: LIST
19512: LIST
19513: LIST
19514: LIST
19515: LIST
19516: LIST
19517: LIST
19518: LIST
19519: LIST
19520: LIST
19521: LIST
19522: LIST
19523: LIST
19524: LIST
19525: LIST
19526: LIST
19527: LIST
19528: LIST
19529: LIST
19530: LIST
19531: ST_TO_ADDR
19532: GO 19999
19534: LD_INT 2
19536: DOUBLE
19537: EQUAL
19538: IFTRUE 19542
19540: GO 19768
19542: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 87 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 , 82 , 83 , 84 , 85 , 87 , 88 ] ; nation_russian :
19543: LD_ADDR_VAR 0 4
19547: PUSH
19548: LD_INT 35
19550: PUSH
19551: LD_INT 45
19553: PUSH
19554: LD_INT 46
19556: PUSH
19557: LD_INT 47
19559: PUSH
19560: LD_INT 82
19562: PUSH
19563: LD_INT 83
19565: PUSH
19566: LD_INT 84
19568: PUSH
19569: LD_INT 85
19571: PUSH
19572: LD_INT 87
19574: PUSH
19575: LD_INT 70
19577: PUSH
19578: LD_INT 1
19580: PUSH
19581: LD_INT 11
19583: PUSH
19584: LD_INT 3
19586: PUSH
19587: LD_INT 4
19589: PUSH
19590: LD_INT 5
19592: PUSH
19593: LD_INT 6
19595: PUSH
19596: LD_INT 15
19598: PUSH
19599: LD_INT 18
19601: PUSH
19602: LD_INT 7
19604: PUSH
19605: LD_INT 17
19607: PUSH
19608: LD_INT 8
19610: PUSH
19611: LD_INT 20
19613: PUSH
19614: LD_INT 21
19616: PUSH
19617: LD_INT 22
19619: PUSH
19620: LD_INT 72
19622: PUSH
19623: LD_INT 26
19625: PUSH
19626: LD_INT 69
19628: PUSH
19629: LD_INT 39
19631: PUSH
19632: LD_INT 40
19634: PUSH
19635: LD_INT 41
19637: PUSH
19638: LD_INT 42
19640: PUSH
19641: LD_INT 43
19643: PUSH
19644: LD_INT 48
19646: PUSH
19647: LD_INT 49
19649: PUSH
19650: LD_INT 50
19652: PUSH
19653: LD_INT 51
19655: PUSH
19656: LD_INT 52
19658: PUSH
19659: LD_INT 53
19661: PUSH
19662: LD_INT 54
19664: PUSH
19665: LD_INT 55
19667: PUSH
19668: LD_INT 56
19670: PUSH
19671: LD_INT 60
19673: PUSH
19674: LD_INT 61
19676: PUSH
19677: LD_INT 62
19679: PUSH
19680: LD_INT 66
19682: PUSH
19683: LD_INT 67
19685: PUSH
19686: LD_INT 68
19688: PUSH
19689: LD_INT 81
19691: PUSH
19692: LD_INT 82
19694: PUSH
19695: LD_INT 83
19697: PUSH
19698: LD_INT 84
19700: PUSH
19701: LD_INT 85
19703: PUSH
19704: LD_INT 87
19706: PUSH
19707: LD_INT 88
19709: PUSH
19710: EMPTY
19711: LIST
19712: LIST
19713: LIST
19714: LIST
19715: LIST
19716: LIST
19717: LIST
19718: LIST
19719: LIST
19720: LIST
19721: LIST
19722: LIST
19723: LIST
19724: LIST
19725: LIST
19726: LIST
19727: LIST
19728: LIST
19729: LIST
19730: LIST
19731: LIST
19732: LIST
19733: LIST
19734: LIST
19735: LIST
19736: LIST
19737: LIST
19738: LIST
19739: LIST
19740: LIST
19741: LIST
19742: LIST
19743: LIST
19744: LIST
19745: LIST
19746: LIST
19747: LIST
19748: LIST
19749: LIST
19750: LIST
19751: LIST
19752: LIST
19753: LIST
19754: LIST
19755: LIST
19756: LIST
19757: LIST
19758: LIST
19759: LIST
19760: LIST
19761: LIST
19762: LIST
19763: LIST
19764: LIST
19765: ST_TO_ADDR
19766: GO 19999
19768: LD_INT 3
19770: DOUBLE
19771: EQUAL
19772: IFTRUE 19776
19774: GO 19998
19776: POP
// result := [ 46 , 47 , 1 , 2 , 82 , 83 , 84 , 85 , 86 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 , 82 , 83 , 84 , 85 , 86 ] ; end ;
19777: LD_ADDR_VAR 0 4
19781: PUSH
19782: LD_INT 46
19784: PUSH
19785: LD_INT 47
19787: PUSH
19788: LD_INT 1
19790: PUSH
19791: LD_INT 2
19793: PUSH
19794: LD_INT 82
19796: PUSH
19797: LD_INT 83
19799: PUSH
19800: LD_INT 84
19802: PUSH
19803: LD_INT 85
19805: PUSH
19806: LD_INT 86
19808: PUSH
19809: LD_INT 11
19811: PUSH
19812: LD_INT 9
19814: PUSH
19815: LD_INT 20
19817: PUSH
19818: LD_INT 19
19820: PUSH
19821: LD_INT 21
19823: PUSH
19824: LD_INT 24
19826: PUSH
19827: LD_INT 22
19829: PUSH
19830: LD_INT 25
19832: PUSH
19833: LD_INT 28
19835: PUSH
19836: LD_INT 29
19838: PUSH
19839: LD_INT 30
19841: PUSH
19842: LD_INT 31
19844: PUSH
19845: LD_INT 37
19847: PUSH
19848: LD_INT 38
19850: PUSH
19851: LD_INT 32
19853: PUSH
19854: LD_INT 27
19856: PUSH
19857: LD_INT 33
19859: PUSH
19860: LD_INT 69
19862: PUSH
19863: LD_INT 39
19865: PUSH
19866: LD_INT 34
19868: PUSH
19869: LD_INT 40
19871: PUSH
19872: LD_INT 71
19874: PUSH
19875: LD_INT 23
19877: PUSH
19878: LD_INT 44
19880: PUSH
19881: LD_INT 48
19883: PUSH
19884: LD_INT 49
19886: PUSH
19887: LD_INT 50
19889: PUSH
19890: LD_INT 51
19892: PUSH
19893: LD_INT 52
19895: PUSH
19896: LD_INT 53
19898: PUSH
19899: LD_INT 54
19901: PUSH
19902: LD_INT 55
19904: PUSH
19905: LD_INT 56
19907: PUSH
19908: LD_INT 57
19910: PUSH
19911: LD_INT 58
19913: PUSH
19914: LD_INT 59
19916: PUSH
19917: LD_INT 63
19919: PUSH
19920: LD_INT 64
19922: PUSH
19923: LD_INT 65
19925: PUSH
19926: LD_INT 82
19928: PUSH
19929: LD_INT 83
19931: PUSH
19932: LD_INT 84
19934: PUSH
19935: LD_INT 85
19937: PUSH
19938: LD_INT 86
19940: PUSH
19941: EMPTY
19942: LIST
19943: LIST
19944: LIST
19945: LIST
19946: LIST
19947: LIST
19948: LIST
19949: LIST
19950: LIST
19951: LIST
19952: LIST
19953: LIST
19954: LIST
19955: LIST
19956: LIST
19957: LIST
19958: LIST
19959: LIST
19960: LIST
19961: LIST
19962: LIST
19963: LIST
19964: LIST
19965: LIST
19966: LIST
19967: LIST
19968: LIST
19969: LIST
19970: LIST
19971: LIST
19972: LIST
19973: LIST
19974: LIST
19975: LIST
19976: LIST
19977: LIST
19978: LIST
19979: LIST
19980: LIST
19981: LIST
19982: LIST
19983: LIST
19984: LIST
19985: LIST
19986: LIST
19987: LIST
19988: LIST
19989: LIST
19990: LIST
19991: LIST
19992: LIST
19993: LIST
19994: LIST
19995: ST_TO_ADDR
19996: GO 19999
19998: POP
// if state > - 1 and state < 3 then
19999: LD_VAR 0 3
20003: PUSH
20004: LD_INT 1
20006: NEG
20007: GREATER
20008: PUSH
20009: LD_VAR 0 3
20013: PUSH
20014: LD_INT 3
20016: LESS
20017: AND
20018: IFFALSE 20075
// for i in result do
20020: LD_ADDR_VAR 0 5
20024: PUSH
20025: LD_VAR 0 4
20029: PUSH
20030: FOR_IN
20031: IFFALSE 20073
// if GetTech ( i , side ) <> state then
20033: LD_VAR 0 5
20037: PPUSH
20038: LD_VAR 0 1
20042: PPUSH
20043: CALL_OW 321
20047: PUSH
20048: LD_VAR 0 3
20052: NONEQUAL
20053: IFFALSE 20071
// result := result diff i ;
20055: LD_ADDR_VAR 0 4
20059: PUSH
20060: LD_VAR 0 4
20064: PUSH
20065: LD_VAR 0 5
20069: DIFF
20070: ST_TO_ADDR
20071: GO 20030
20073: POP
20074: POP
// end ;
20075: LD_VAR 0 4
20079: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
20080: LD_INT 0
20082: PPUSH
20083: PPUSH
20084: PPUSH
// result := true ;
20085: LD_ADDR_VAR 0 3
20089: PUSH
20090: LD_INT 1
20092: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
20093: LD_ADDR_VAR 0 5
20097: PUSH
20098: LD_VAR 0 2
20102: PPUSH
20103: CALL_OW 480
20107: ST_TO_ADDR
// if not tmp then
20108: LD_VAR 0 5
20112: NOT
20113: IFFALSE 20117
// exit ;
20115: GO 20166
// for i in tmp do
20117: LD_ADDR_VAR 0 4
20121: PUSH
20122: LD_VAR 0 5
20126: PUSH
20127: FOR_IN
20128: IFFALSE 20164
// if GetTech ( i , side ) <> state_researched then
20130: LD_VAR 0 4
20134: PPUSH
20135: LD_VAR 0 1
20139: PPUSH
20140: CALL_OW 321
20144: PUSH
20145: LD_INT 2
20147: NONEQUAL
20148: IFFALSE 20162
// begin result := false ;
20150: LD_ADDR_VAR 0 3
20154: PUSH
20155: LD_INT 0
20157: ST_TO_ADDR
// exit ;
20158: POP
20159: POP
20160: GO 20166
// end ;
20162: GO 20127
20164: POP
20165: POP
// end ;
20166: LD_VAR 0 3
20170: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
20171: LD_INT 0
20173: PPUSH
20174: PPUSH
20175: PPUSH
20176: PPUSH
20177: PPUSH
20178: PPUSH
20179: PPUSH
20180: PPUSH
20181: PPUSH
20182: PPUSH
20183: PPUSH
20184: PPUSH
20185: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
20186: LD_VAR 0 1
20190: NOT
20191: PUSH
20192: LD_VAR 0 1
20196: PPUSH
20197: CALL_OW 257
20201: PUSH
20202: LD_INT 9
20204: NONEQUAL
20205: OR
20206: IFFALSE 20210
// exit ;
20208: GO 20783
// side := GetSide ( unit ) ;
20210: LD_ADDR_VAR 0 9
20214: PUSH
20215: LD_VAR 0 1
20219: PPUSH
20220: CALL_OW 255
20224: ST_TO_ADDR
// tech_space := tech_spacanom ;
20225: LD_ADDR_VAR 0 12
20229: PUSH
20230: LD_INT 29
20232: ST_TO_ADDR
// tech_time := tech_taurad ;
20233: LD_ADDR_VAR 0 13
20237: PUSH
20238: LD_INT 28
20240: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
20241: LD_ADDR_VAR 0 11
20245: PUSH
20246: LD_VAR 0 1
20250: PPUSH
20251: CALL_OW 310
20255: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
20256: LD_VAR 0 11
20260: PPUSH
20261: CALL_OW 247
20265: PUSH
20266: LD_INT 2
20268: EQUAL
20269: IFFALSE 20273
// exit ;
20271: GO 20783
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
20273: LD_ADDR_VAR 0 8
20277: PUSH
20278: LD_INT 81
20280: PUSH
20281: LD_VAR 0 9
20285: PUSH
20286: EMPTY
20287: LIST
20288: LIST
20289: PUSH
20290: LD_INT 3
20292: PUSH
20293: LD_INT 21
20295: PUSH
20296: LD_INT 3
20298: PUSH
20299: EMPTY
20300: LIST
20301: LIST
20302: PUSH
20303: EMPTY
20304: LIST
20305: LIST
20306: PUSH
20307: EMPTY
20308: LIST
20309: LIST
20310: PPUSH
20311: CALL_OW 69
20315: ST_TO_ADDR
// if not tmp then
20316: LD_VAR 0 8
20320: NOT
20321: IFFALSE 20325
// exit ;
20323: GO 20783
// if in_unit then
20325: LD_VAR 0 11
20329: IFFALSE 20353
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
20331: LD_ADDR_VAR 0 10
20335: PUSH
20336: LD_VAR 0 8
20340: PPUSH
20341: LD_VAR 0 11
20345: PPUSH
20346: CALL_OW 74
20350: ST_TO_ADDR
20351: GO 20373
// enemy := NearestUnitToUnit ( tmp , unit ) ;
20353: LD_ADDR_VAR 0 10
20357: PUSH
20358: LD_VAR 0 8
20362: PPUSH
20363: LD_VAR 0 1
20367: PPUSH
20368: CALL_OW 74
20372: ST_TO_ADDR
// if not enemy then
20373: LD_VAR 0 10
20377: NOT
20378: IFFALSE 20382
// exit ;
20380: GO 20783
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
20382: LD_VAR 0 11
20386: PUSH
20387: LD_VAR 0 11
20391: PPUSH
20392: LD_VAR 0 10
20396: PPUSH
20397: CALL_OW 296
20401: PUSH
20402: LD_INT 13
20404: GREATER
20405: AND
20406: PUSH
20407: LD_VAR 0 1
20411: PPUSH
20412: LD_VAR 0 10
20416: PPUSH
20417: CALL_OW 296
20421: PUSH
20422: LD_INT 12
20424: GREATER
20425: OR
20426: IFFALSE 20430
// exit ;
20428: GO 20783
// missile := [ 1 ] ;
20430: LD_ADDR_VAR 0 14
20434: PUSH
20435: LD_INT 1
20437: PUSH
20438: EMPTY
20439: LIST
20440: ST_TO_ADDR
// if Researched ( side , tech_space ) then
20441: LD_VAR 0 9
20445: PPUSH
20446: LD_VAR 0 12
20450: PPUSH
20451: CALL_OW 325
20455: IFFALSE 20484
// missile := Insert ( missile , missile + 1 , 2 ) ;
20457: LD_ADDR_VAR 0 14
20461: PUSH
20462: LD_VAR 0 14
20466: PPUSH
20467: LD_VAR 0 14
20471: PUSH
20472: LD_INT 1
20474: PLUS
20475: PPUSH
20476: LD_INT 2
20478: PPUSH
20479: CALL_OW 2
20483: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
20484: LD_VAR 0 9
20488: PPUSH
20489: LD_VAR 0 13
20493: PPUSH
20494: CALL_OW 325
20498: PUSH
20499: LD_VAR 0 10
20503: PPUSH
20504: CALL_OW 255
20508: PPUSH
20509: LD_VAR 0 13
20513: PPUSH
20514: CALL_OW 325
20518: NOT
20519: AND
20520: IFFALSE 20549
// missile := Insert ( missile , missile + 1 , 3 ) ;
20522: LD_ADDR_VAR 0 14
20526: PUSH
20527: LD_VAR 0 14
20531: PPUSH
20532: LD_VAR 0 14
20536: PUSH
20537: LD_INT 1
20539: PLUS
20540: PPUSH
20541: LD_INT 3
20543: PPUSH
20544: CALL_OW 2
20548: ST_TO_ADDR
// if missile < 2 then
20549: LD_VAR 0 14
20553: PUSH
20554: LD_INT 2
20556: LESS
20557: IFFALSE 20561
// exit ;
20559: GO 20783
// x := GetX ( enemy ) ;
20561: LD_ADDR_VAR 0 4
20565: PUSH
20566: LD_VAR 0 10
20570: PPUSH
20571: CALL_OW 250
20575: ST_TO_ADDR
// y := GetY ( enemy ) ;
20576: LD_ADDR_VAR 0 5
20580: PUSH
20581: LD_VAR 0 10
20585: PPUSH
20586: CALL_OW 251
20590: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
20591: LD_ADDR_VAR 0 6
20595: PUSH
20596: LD_VAR 0 4
20600: PUSH
20601: LD_INT 1
20603: NEG
20604: PPUSH
20605: LD_INT 1
20607: PPUSH
20608: CALL_OW 12
20612: PLUS
20613: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
20614: LD_ADDR_VAR 0 7
20618: PUSH
20619: LD_VAR 0 5
20623: PUSH
20624: LD_INT 1
20626: NEG
20627: PPUSH
20628: LD_INT 1
20630: PPUSH
20631: CALL_OW 12
20635: PLUS
20636: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
20637: LD_VAR 0 6
20641: PPUSH
20642: LD_VAR 0 7
20646: PPUSH
20647: CALL_OW 488
20651: NOT
20652: IFFALSE 20674
// begin _x := x ;
20654: LD_ADDR_VAR 0 6
20658: PUSH
20659: LD_VAR 0 4
20663: ST_TO_ADDR
// _y := y ;
20664: LD_ADDR_VAR 0 7
20668: PUSH
20669: LD_VAR 0 5
20673: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
20674: LD_ADDR_VAR 0 3
20678: PUSH
20679: LD_INT 1
20681: PPUSH
20682: LD_VAR 0 14
20686: PPUSH
20687: CALL_OW 12
20691: ST_TO_ADDR
// case i of 1 :
20692: LD_VAR 0 3
20696: PUSH
20697: LD_INT 1
20699: DOUBLE
20700: EQUAL
20701: IFTRUE 20705
20703: GO 20722
20705: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
20706: LD_VAR 0 1
20710: PPUSH
20711: LD_VAR 0 10
20715: PPUSH
20716: CALL_OW 115
20720: GO 20783
20722: LD_INT 2
20724: DOUBLE
20725: EQUAL
20726: IFTRUE 20730
20728: GO 20752
20730: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
20731: LD_VAR 0 1
20735: PPUSH
20736: LD_VAR 0 6
20740: PPUSH
20741: LD_VAR 0 7
20745: PPUSH
20746: CALL_OW 153
20750: GO 20783
20752: LD_INT 3
20754: DOUBLE
20755: EQUAL
20756: IFTRUE 20760
20758: GO 20782
20760: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
20761: LD_VAR 0 1
20765: PPUSH
20766: LD_VAR 0 6
20770: PPUSH
20771: LD_VAR 0 7
20775: PPUSH
20776: CALL_OW 154
20780: GO 20783
20782: POP
// end ;
20783: LD_VAR 0 2
20787: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
20788: LD_INT 0
20790: PPUSH
20791: PPUSH
20792: PPUSH
20793: PPUSH
20794: PPUSH
20795: PPUSH
// if not unit or not building then
20796: LD_VAR 0 1
20800: NOT
20801: PUSH
20802: LD_VAR 0 2
20806: NOT
20807: OR
20808: IFFALSE 20812
// exit ;
20810: GO 20970
// x := GetX ( building ) ;
20812: LD_ADDR_VAR 0 5
20816: PUSH
20817: LD_VAR 0 2
20821: PPUSH
20822: CALL_OW 250
20826: ST_TO_ADDR
// y := GetY ( building ) ;
20827: LD_ADDR_VAR 0 6
20831: PUSH
20832: LD_VAR 0 2
20836: PPUSH
20837: CALL_OW 251
20841: ST_TO_ADDR
// for i = 0 to 5 do
20842: LD_ADDR_VAR 0 4
20846: PUSH
20847: DOUBLE
20848: LD_INT 0
20850: DEC
20851: ST_TO_ADDR
20852: LD_INT 5
20854: PUSH
20855: FOR_TO
20856: IFFALSE 20968
// begin _x := ShiftX ( x , i , 3 ) ;
20858: LD_ADDR_VAR 0 7
20862: PUSH
20863: LD_VAR 0 5
20867: PPUSH
20868: LD_VAR 0 4
20872: PPUSH
20873: LD_INT 3
20875: PPUSH
20876: CALL_OW 272
20880: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
20881: LD_ADDR_VAR 0 8
20885: PUSH
20886: LD_VAR 0 6
20890: PPUSH
20891: LD_VAR 0 4
20895: PPUSH
20896: LD_INT 3
20898: PPUSH
20899: CALL_OW 273
20903: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
20904: LD_VAR 0 7
20908: PPUSH
20909: LD_VAR 0 8
20913: PPUSH
20914: CALL_OW 488
20918: NOT
20919: IFFALSE 20923
// continue ;
20921: GO 20855
// if HexInfo ( _x , _y ) = 0 then
20923: LD_VAR 0 7
20927: PPUSH
20928: LD_VAR 0 8
20932: PPUSH
20933: CALL_OW 428
20937: PUSH
20938: LD_INT 0
20940: EQUAL
20941: IFFALSE 20966
// begin ComMoveXY ( unit , _x , _y ) ;
20943: LD_VAR 0 1
20947: PPUSH
20948: LD_VAR 0 7
20952: PPUSH
20953: LD_VAR 0 8
20957: PPUSH
20958: CALL_OW 111
// exit ;
20962: POP
20963: POP
20964: GO 20970
// end ; end ;
20966: GO 20855
20968: POP
20969: POP
// end ;
20970: LD_VAR 0 3
20974: RET
// export function ScanBase ( side , base_area ) ; begin
20975: LD_INT 0
20977: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
20978: LD_ADDR_VAR 0 3
20982: PUSH
20983: LD_VAR 0 2
20987: PPUSH
20988: LD_INT 81
20990: PUSH
20991: LD_VAR 0 1
20995: PUSH
20996: EMPTY
20997: LIST
20998: LIST
20999: PPUSH
21000: CALL_OW 70
21004: ST_TO_ADDR
// end ;
21005: LD_VAR 0 3
21009: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
21010: LD_INT 0
21012: PPUSH
21013: PPUSH
21014: PPUSH
21015: PPUSH
// result := false ;
21016: LD_ADDR_VAR 0 2
21020: PUSH
21021: LD_INT 0
21023: ST_TO_ADDR
// side := GetSide ( unit ) ;
21024: LD_ADDR_VAR 0 3
21028: PUSH
21029: LD_VAR 0 1
21033: PPUSH
21034: CALL_OW 255
21038: ST_TO_ADDR
// nat := GetNation ( unit ) ;
21039: LD_ADDR_VAR 0 4
21043: PUSH
21044: LD_VAR 0 1
21048: PPUSH
21049: CALL_OW 248
21053: ST_TO_ADDR
// case nat of 1 :
21054: LD_VAR 0 4
21058: PUSH
21059: LD_INT 1
21061: DOUBLE
21062: EQUAL
21063: IFTRUE 21067
21065: GO 21078
21067: POP
// tech := tech_lassight ; 2 :
21068: LD_ADDR_VAR 0 5
21072: PUSH
21073: LD_INT 12
21075: ST_TO_ADDR
21076: GO 21117
21078: LD_INT 2
21080: DOUBLE
21081: EQUAL
21082: IFTRUE 21086
21084: GO 21097
21086: POP
// tech := tech_mortar ; 3 :
21087: LD_ADDR_VAR 0 5
21091: PUSH
21092: LD_INT 41
21094: ST_TO_ADDR
21095: GO 21117
21097: LD_INT 3
21099: DOUBLE
21100: EQUAL
21101: IFTRUE 21105
21103: GO 21116
21105: POP
// tech := tech_bazooka ; end ;
21106: LD_ADDR_VAR 0 5
21110: PUSH
21111: LD_INT 44
21113: ST_TO_ADDR
21114: GO 21117
21116: POP
// if Researched ( side , tech ) then
21117: LD_VAR 0 3
21121: PPUSH
21122: LD_VAR 0 5
21126: PPUSH
21127: CALL_OW 325
21131: IFFALSE 21158
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
21133: LD_ADDR_VAR 0 2
21137: PUSH
21138: LD_INT 5
21140: PUSH
21141: LD_INT 8
21143: PUSH
21144: LD_INT 9
21146: PUSH
21147: EMPTY
21148: LIST
21149: LIST
21150: LIST
21151: PUSH
21152: LD_VAR 0 4
21156: ARRAY
21157: ST_TO_ADDR
// end ;
21158: LD_VAR 0 2
21162: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
21163: LD_INT 0
21165: PPUSH
21166: PPUSH
21167: PPUSH
// if not mines then
21168: LD_VAR 0 2
21172: NOT
21173: IFFALSE 21177
// exit ;
21175: GO 21321
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
21177: LD_ADDR_VAR 0 5
21181: PUSH
21182: LD_INT 81
21184: PUSH
21185: LD_VAR 0 1
21189: PUSH
21190: EMPTY
21191: LIST
21192: LIST
21193: PUSH
21194: LD_INT 3
21196: PUSH
21197: LD_INT 21
21199: PUSH
21200: LD_INT 3
21202: PUSH
21203: EMPTY
21204: LIST
21205: LIST
21206: PUSH
21207: EMPTY
21208: LIST
21209: LIST
21210: PUSH
21211: EMPTY
21212: LIST
21213: LIST
21214: PPUSH
21215: CALL_OW 69
21219: ST_TO_ADDR
// for i in mines do
21220: LD_ADDR_VAR 0 4
21224: PUSH
21225: LD_VAR 0 2
21229: PUSH
21230: FOR_IN
21231: IFFALSE 21319
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
21233: LD_VAR 0 4
21237: PUSH
21238: LD_INT 1
21240: ARRAY
21241: PPUSH
21242: LD_VAR 0 4
21246: PUSH
21247: LD_INT 2
21249: ARRAY
21250: PPUSH
21251: CALL_OW 458
21255: NOT
21256: IFFALSE 21260
// continue ;
21258: GO 21230
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
21260: LD_VAR 0 4
21264: PUSH
21265: LD_INT 1
21267: ARRAY
21268: PPUSH
21269: LD_VAR 0 4
21273: PUSH
21274: LD_INT 2
21276: ARRAY
21277: PPUSH
21278: CALL_OW 428
21282: PUSH
21283: LD_VAR 0 5
21287: IN
21288: IFFALSE 21317
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
21290: LD_VAR 0 4
21294: PUSH
21295: LD_INT 1
21297: ARRAY
21298: PPUSH
21299: LD_VAR 0 4
21303: PUSH
21304: LD_INT 2
21306: ARRAY
21307: PPUSH
21308: LD_VAR 0 1
21312: PPUSH
21313: CALL_OW 456
// end ;
21317: GO 21230
21319: POP
21320: POP
// end ;
21321: LD_VAR 0 3
21325: RET
// export function Count ( array ) ; var i ; begin
21326: LD_INT 0
21328: PPUSH
21329: PPUSH
// result := 0 ;
21330: LD_ADDR_VAR 0 2
21334: PUSH
21335: LD_INT 0
21337: ST_TO_ADDR
// for i in array do
21338: LD_ADDR_VAR 0 3
21342: PUSH
21343: LD_VAR 0 1
21347: PUSH
21348: FOR_IN
21349: IFFALSE 21373
// if i then
21351: LD_VAR 0 3
21355: IFFALSE 21371
// result := result + 1 ;
21357: LD_ADDR_VAR 0 2
21361: PUSH
21362: LD_VAR 0 2
21366: PUSH
21367: LD_INT 1
21369: PLUS
21370: ST_TO_ADDR
21371: GO 21348
21373: POP
21374: POP
// end ;
21375: LD_VAR 0 2
21379: RET
// export function IsEmpty ( building ) ; begin
21380: LD_INT 0
21382: PPUSH
// if not building then
21383: LD_VAR 0 1
21387: NOT
21388: IFFALSE 21392
// exit ;
21390: GO 21435
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
21392: LD_ADDR_VAR 0 2
21396: PUSH
21397: LD_VAR 0 1
21401: PUSH
21402: LD_INT 22
21404: PUSH
21405: LD_VAR 0 1
21409: PPUSH
21410: CALL_OW 255
21414: PUSH
21415: EMPTY
21416: LIST
21417: LIST
21418: PUSH
21419: LD_INT 58
21421: PUSH
21422: EMPTY
21423: LIST
21424: PUSH
21425: EMPTY
21426: LIST
21427: LIST
21428: PPUSH
21429: CALL_OW 69
21433: IN
21434: ST_TO_ADDR
// end ;
21435: LD_VAR 0 2
21439: RET
// export function IsNotFull ( building ) ; begin
21440: LD_INT 0
21442: PPUSH
// if not building then
21443: LD_VAR 0 1
21447: NOT
21448: IFFALSE 21452
// exit ;
21450: GO 21471
// result := UnitsInside ( building ) < 6 ;
21452: LD_ADDR_VAR 0 2
21456: PUSH
21457: LD_VAR 0 1
21461: PPUSH
21462: CALL_OW 313
21466: PUSH
21467: LD_INT 6
21469: LESS
21470: ST_TO_ADDR
// end ;
21471: LD_VAR 0 2
21475: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
21476: LD_INT 0
21478: PPUSH
21479: PPUSH
21480: PPUSH
21481: PPUSH
// tmp := [ ] ;
21482: LD_ADDR_VAR 0 3
21486: PUSH
21487: EMPTY
21488: ST_TO_ADDR
// list := [ ] ;
21489: LD_ADDR_VAR 0 5
21493: PUSH
21494: EMPTY
21495: ST_TO_ADDR
// for i = 16 to 25 do
21496: LD_ADDR_VAR 0 4
21500: PUSH
21501: DOUBLE
21502: LD_INT 16
21504: DEC
21505: ST_TO_ADDR
21506: LD_INT 25
21508: PUSH
21509: FOR_TO
21510: IFFALSE 21583
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
21512: LD_ADDR_VAR 0 3
21516: PUSH
21517: LD_VAR 0 3
21521: PUSH
21522: LD_INT 22
21524: PUSH
21525: LD_VAR 0 1
21529: PPUSH
21530: CALL_OW 255
21534: PUSH
21535: EMPTY
21536: LIST
21537: LIST
21538: PUSH
21539: LD_INT 91
21541: PUSH
21542: LD_VAR 0 1
21546: PUSH
21547: LD_INT 6
21549: PUSH
21550: EMPTY
21551: LIST
21552: LIST
21553: LIST
21554: PUSH
21555: LD_INT 30
21557: PUSH
21558: LD_VAR 0 4
21562: PUSH
21563: EMPTY
21564: LIST
21565: LIST
21566: PUSH
21567: EMPTY
21568: LIST
21569: LIST
21570: LIST
21571: PUSH
21572: EMPTY
21573: LIST
21574: PPUSH
21575: CALL_OW 69
21579: ADD
21580: ST_TO_ADDR
21581: GO 21509
21583: POP
21584: POP
// for i = 1 to tmp do
21585: LD_ADDR_VAR 0 4
21589: PUSH
21590: DOUBLE
21591: LD_INT 1
21593: DEC
21594: ST_TO_ADDR
21595: LD_VAR 0 3
21599: PUSH
21600: FOR_TO
21601: IFFALSE 21689
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
21603: LD_ADDR_VAR 0 5
21607: PUSH
21608: LD_VAR 0 5
21612: PUSH
21613: LD_VAR 0 3
21617: PUSH
21618: LD_VAR 0 4
21622: ARRAY
21623: PPUSH
21624: CALL_OW 266
21628: PUSH
21629: LD_VAR 0 3
21633: PUSH
21634: LD_VAR 0 4
21638: ARRAY
21639: PPUSH
21640: CALL_OW 250
21644: PUSH
21645: LD_VAR 0 3
21649: PUSH
21650: LD_VAR 0 4
21654: ARRAY
21655: PPUSH
21656: CALL_OW 251
21660: PUSH
21661: LD_VAR 0 3
21665: PUSH
21666: LD_VAR 0 4
21670: ARRAY
21671: PPUSH
21672: CALL_OW 254
21676: PUSH
21677: EMPTY
21678: LIST
21679: LIST
21680: LIST
21681: LIST
21682: PUSH
21683: EMPTY
21684: LIST
21685: ADD
21686: ST_TO_ADDR
21687: GO 21600
21689: POP
21690: POP
// result := list ;
21691: LD_ADDR_VAR 0 2
21695: PUSH
21696: LD_VAR 0 5
21700: ST_TO_ADDR
// end ;
21701: LD_VAR 0 2
21705: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
21706: LD_INT 0
21708: PPUSH
21709: PPUSH
21710: PPUSH
21711: PPUSH
21712: PPUSH
21713: PPUSH
21714: PPUSH
// if not factory then
21715: LD_VAR 0 1
21719: NOT
21720: IFFALSE 21724
// exit ;
21722: GO 22317
// if control = control_apeman then
21724: LD_VAR 0 4
21728: PUSH
21729: LD_INT 5
21731: EQUAL
21732: IFFALSE 21841
// begin tmp := UnitsInside ( factory ) ;
21734: LD_ADDR_VAR 0 8
21738: PUSH
21739: LD_VAR 0 1
21743: PPUSH
21744: CALL_OW 313
21748: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
21749: LD_VAR 0 8
21753: PPUSH
21754: LD_INT 25
21756: PUSH
21757: LD_INT 12
21759: PUSH
21760: EMPTY
21761: LIST
21762: LIST
21763: PPUSH
21764: CALL_OW 72
21768: NOT
21769: IFFALSE 21779
// control := control_manual ;
21771: LD_ADDR_VAR 0 4
21775: PUSH
21776: LD_INT 1
21778: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
21779: LD_ADDR_VAR 0 8
21783: PUSH
21784: LD_VAR 0 1
21788: PPUSH
21789: CALL 21476 0 1
21793: ST_TO_ADDR
// if tmp then
21794: LD_VAR 0 8
21798: IFFALSE 21841
// begin for i in tmp do
21800: LD_ADDR_VAR 0 7
21804: PUSH
21805: LD_VAR 0 8
21809: PUSH
21810: FOR_IN
21811: IFFALSE 21839
// if i [ 1 ] = b_ext_radio then
21813: LD_VAR 0 7
21817: PUSH
21818: LD_INT 1
21820: ARRAY
21821: PUSH
21822: LD_INT 22
21824: EQUAL
21825: IFFALSE 21837
// begin control := control_remote ;
21827: LD_ADDR_VAR 0 4
21831: PUSH
21832: LD_INT 2
21834: ST_TO_ADDR
// break ;
21835: GO 21839
// end ;
21837: GO 21810
21839: POP
21840: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
21841: LD_VAR 0 1
21845: PPUSH
21846: LD_VAR 0 2
21850: PPUSH
21851: LD_VAR 0 3
21855: PPUSH
21856: LD_VAR 0 4
21860: PPUSH
21861: LD_VAR 0 5
21865: PPUSH
21866: CALL_OW 448
21870: IFFALSE 21905
// begin result := [ chassis , engine , control , weapon ] ;
21872: LD_ADDR_VAR 0 6
21876: PUSH
21877: LD_VAR 0 2
21881: PUSH
21882: LD_VAR 0 3
21886: PUSH
21887: LD_VAR 0 4
21891: PUSH
21892: LD_VAR 0 5
21896: PUSH
21897: EMPTY
21898: LIST
21899: LIST
21900: LIST
21901: LIST
21902: ST_TO_ADDR
// exit ;
21903: GO 22317
// end ; _chassis := AvailableChassisList ( factory ) ;
21905: LD_ADDR_VAR 0 9
21909: PUSH
21910: LD_VAR 0 1
21914: PPUSH
21915: CALL_OW 475
21919: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
21920: LD_ADDR_VAR 0 11
21924: PUSH
21925: LD_VAR 0 1
21929: PPUSH
21930: CALL_OW 476
21934: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
21935: LD_ADDR_VAR 0 12
21939: PUSH
21940: LD_VAR 0 1
21944: PPUSH
21945: CALL_OW 477
21949: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
21950: LD_ADDR_VAR 0 10
21954: PUSH
21955: LD_VAR 0 1
21959: PPUSH
21960: CALL_OW 478
21964: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
21965: LD_VAR 0 9
21969: NOT
21970: PUSH
21971: LD_VAR 0 11
21975: NOT
21976: OR
21977: PUSH
21978: LD_VAR 0 12
21982: NOT
21983: OR
21984: PUSH
21985: LD_VAR 0 10
21989: NOT
21990: OR
21991: IFFALSE 22026
// begin result := [ chassis , engine , control , weapon ] ;
21993: LD_ADDR_VAR 0 6
21997: PUSH
21998: LD_VAR 0 2
22002: PUSH
22003: LD_VAR 0 3
22007: PUSH
22008: LD_VAR 0 4
22012: PUSH
22013: LD_VAR 0 5
22017: PUSH
22018: EMPTY
22019: LIST
22020: LIST
22021: LIST
22022: LIST
22023: ST_TO_ADDR
// exit ;
22024: GO 22317
// end ; if not chassis in _chassis then
22026: LD_VAR 0 2
22030: PUSH
22031: LD_VAR 0 9
22035: IN
22036: NOT
22037: IFFALSE 22063
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
22039: LD_ADDR_VAR 0 2
22043: PUSH
22044: LD_VAR 0 9
22048: PUSH
22049: LD_INT 1
22051: PPUSH
22052: LD_VAR 0 9
22056: PPUSH
22057: CALL_OW 12
22061: ARRAY
22062: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
22063: LD_VAR 0 2
22067: PPUSH
22068: LD_VAR 0 3
22072: PPUSH
22073: CALL 22322 0 2
22077: NOT
22078: IFFALSE 22137
// repeat engine := _engine [ 1 ] ;
22080: LD_ADDR_VAR 0 3
22084: PUSH
22085: LD_VAR 0 11
22089: PUSH
22090: LD_INT 1
22092: ARRAY
22093: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
22094: LD_ADDR_VAR 0 11
22098: PUSH
22099: LD_VAR 0 11
22103: PPUSH
22104: LD_INT 1
22106: PPUSH
22107: CALL_OW 3
22111: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
22112: LD_VAR 0 2
22116: PPUSH
22117: LD_VAR 0 3
22121: PPUSH
22122: CALL 22322 0 2
22126: PUSH
22127: LD_VAR 0 11
22131: PUSH
22132: EMPTY
22133: EQUAL
22134: OR
22135: IFFALSE 22080
// if not control in _control then
22137: LD_VAR 0 4
22141: PUSH
22142: LD_VAR 0 12
22146: IN
22147: NOT
22148: IFFALSE 22174
// control := _control [ rand ( 1 , _control ) ] ;
22150: LD_ADDR_VAR 0 4
22154: PUSH
22155: LD_VAR 0 12
22159: PUSH
22160: LD_INT 1
22162: PPUSH
22163: LD_VAR 0 12
22167: PPUSH
22168: CALL_OW 12
22172: ARRAY
22173: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
22174: LD_VAR 0 2
22178: PPUSH
22179: LD_VAR 0 5
22183: PPUSH
22184: CALL 22542 0 2
22188: NOT
22189: IFFALSE 22248
// repeat weapon := _weapon [ 1 ] ;
22191: LD_ADDR_VAR 0 5
22195: PUSH
22196: LD_VAR 0 10
22200: PUSH
22201: LD_INT 1
22203: ARRAY
22204: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
22205: LD_ADDR_VAR 0 10
22209: PUSH
22210: LD_VAR 0 10
22214: PPUSH
22215: LD_INT 1
22217: PPUSH
22218: CALL_OW 3
22222: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
22223: LD_VAR 0 2
22227: PPUSH
22228: LD_VAR 0 5
22232: PPUSH
22233: CALL 22542 0 2
22237: PUSH
22238: LD_VAR 0 10
22242: PUSH
22243: EMPTY
22244: EQUAL
22245: OR
22246: IFFALSE 22191
// result := [ ] ;
22248: LD_ADDR_VAR 0 6
22252: PUSH
22253: EMPTY
22254: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
22255: LD_VAR 0 1
22259: PPUSH
22260: LD_VAR 0 2
22264: PPUSH
22265: LD_VAR 0 3
22269: PPUSH
22270: LD_VAR 0 4
22274: PPUSH
22275: LD_VAR 0 5
22279: PPUSH
22280: CALL_OW 448
22284: IFFALSE 22317
// result := [ chassis , engine , control , weapon ] ;
22286: LD_ADDR_VAR 0 6
22290: PUSH
22291: LD_VAR 0 2
22295: PUSH
22296: LD_VAR 0 3
22300: PUSH
22301: LD_VAR 0 4
22305: PUSH
22306: LD_VAR 0 5
22310: PUSH
22311: EMPTY
22312: LIST
22313: LIST
22314: LIST
22315: LIST
22316: ST_TO_ADDR
// end ;
22317: LD_VAR 0 6
22321: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
22322: LD_INT 0
22324: PPUSH
// if not chassis or not engine then
22325: LD_VAR 0 1
22329: NOT
22330: PUSH
22331: LD_VAR 0 2
22335: NOT
22336: OR
22337: IFFALSE 22341
// exit ;
22339: GO 22537
// case engine of engine_solar :
22341: LD_VAR 0 2
22345: PUSH
22346: LD_INT 2
22348: DOUBLE
22349: EQUAL
22350: IFTRUE 22354
22352: GO 22392
22354: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
22355: LD_ADDR_VAR 0 3
22359: PUSH
22360: LD_INT 11
22362: PUSH
22363: LD_INT 12
22365: PUSH
22366: LD_INT 13
22368: PUSH
22369: LD_INT 14
22371: PUSH
22372: LD_INT 1
22374: PUSH
22375: LD_INT 2
22377: PUSH
22378: LD_INT 3
22380: PUSH
22381: EMPTY
22382: LIST
22383: LIST
22384: LIST
22385: LIST
22386: LIST
22387: LIST
22388: LIST
22389: ST_TO_ADDR
22390: GO 22521
22392: LD_INT 1
22394: DOUBLE
22395: EQUAL
22396: IFTRUE 22400
22398: GO 22462
22400: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
22401: LD_ADDR_VAR 0 3
22405: PUSH
22406: LD_INT 11
22408: PUSH
22409: LD_INT 12
22411: PUSH
22412: LD_INT 13
22414: PUSH
22415: LD_INT 14
22417: PUSH
22418: LD_INT 1
22420: PUSH
22421: LD_INT 2
22423: PUSH
22424: LD_INT 3
22426: PUSH
22427: LD_INT 4
22429: PUSH
22430: LD_INT 5
22432: PUSH
22433: LD_INT 21
22435: PUSH
22436: LD_INT 23
22438: PUSH
22439: LD_INT 22
22441: PUSH
22442: LD_INT 24
22444: PUSH
22445: EMPTY
22446: LIST
22447: LIST
22448: LIST
22449: LIST
22450: LIST
22451: LIST
22452: LIST
22453: LIST
22454: LIST
22455: LIST
22456: LIST
22457: LIST
22458: LIST
22459: ST_TO_ADDR
22460: GO 22521
22462: LD_INT 3
22464: DOUBLE
22465: EQUAL
22466: IFTRUE 22470
22468: GO 22520
22470: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
22471: LD_ADDR_VAR 0 3
22475: PUSH
22476: LD_INT 13
22478: PUSH
22479: LD_INT 14
22481: PUSH
22482: LD_INT 2
22484: PUSH
22485: LD_INT 3
22487: PUSH
22488: LD_INT 4
22490: PUSH
22491: LD_INT 5
22493: PUSH
22494: LD_INT 21
22496: PUSH
22497: LD_INT 22
22499: PUSH
22500: LD_INT 23
22502: PUSH
22503: LD_INT 24
22505: PUSH
22506: EMPTY
22507: LIST
22508: LIST
22509: LIST
22510: LIST
22511: LIST
22512: LIST
22513: LIST
22514: LIST
22515: LIST
22516: LIST
22517: ST_TO_ADDR
22518: GO 22521
22520: POP
// result := ( chassis in result ) ;
22521: LD_ADDR_VAR 0 3
22525: PUSH
22526: LD_VAR 0 1
22530: PUSH
22531: LD_VAR 0 3
22535: IN
22536: ST_TO_ADDR
// end ;
22537: LD_VAR 0 3
22541: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
22542: LD_INT 0
22544: PPUSH
// if not chassis or not weapon then
22545: LD_VAR 0 1
22549: NOT
22550: PUSH
22551: LD_VAR 0 2
22555: NOT
22556: OR
22557: IFFALSE 22561
// exit ;
22559: GO 23623
// case weapon of us_machine_gun :
22561: LD_VAR 0 2
22565: PUSH
22566: LD_INT 2
22568: DOUBLE
22569: EQUAL
22570: IFTRUE 22574
22572: GO 22604
22574: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
22575: LD_ADDR_VAR 0 3
22579: PUSH
22580: LD_INT 1
22582: PUSH
22583: LD_INT 2
22585: PUSH
22586: LD_INT 3
22588: PUSH
22589: LD_INT 4
22591: PUSH
22592: LD_INT 5
22594: PUSH
22595: EMPTY
22596: LIST
22597: LIST
22598: LIST
22599: LIST
22600: LIST
22601: ST_TO_ADDR
22602: GO 23607
22604: LD_INT 3
22606: DOUBLE
22607: EQUAL
22608: IFTRUE 22612
22610: GO 22642
22612: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
22613: LD_ADDR_VAR 0 3
22617: PUSH
22618: LD_INT 1
22620: PUSH
22621: LD_INT 2
22623: PUSH
22624: LD_INT 3
22626: PUSH
22627: LD_INT 4
22629: PUSH
22630: LD_INT 5
22632: PUSH
22633: EMPTY
22634: LIST
22635: LIST
22636: LIST
22637: LIST
22638: LIST
22639: ST_TO_ADDR
22640: GO 23607
22642: LD_INT 11
22644: DOUBLE
22645: EQUAL
22646: IFTRUE 22650
22648: GO 22680
22650: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
22651: LD_ADDR_VAR 0 3
22655: PUSH
22656: LD_INT 1
22658: PUSH
22659: LD_INT 2
22661: PUSH
22662: LD_INT 3
22664: PUSH
22665: LD_INT 4
22667: PUSH
22668: LD_INT 5
22670: PUSH
22671: EMPTY
22672: LIST
22673: LIST
22674: LIST
22675: LIST
22676: LIST
22677: ST_TO_ADDR
22678: GO 23607
22680: LD_INT 4
22682: DOUBLE
22683: EQUAL
22684: IFTRUE 22688
22686: GO 22714
22688: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
22689: LD_ADDR_VAR 0 3
22693: PUSH
22694: LD_INT 2
22696: PUSH
22697: LD_INT 3
22699: PUSH
22700: LD_INT 4
22702: PUSH
22703: LD_INT 5
22705: PUSH
22706: EMPTY
22707: LIST
22708: LIST
22709: LIST
22710: LIST
22711: ST_TO_ADDR
22712: GO 23607
22714: LD_INT 5
22716: DOUBLE
22717: EQUAL
22718: IFTRUE 22722
22720: GO 22748
22722: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
22723: LD_ADDR_VAR 0 3
22727: PUSH
22728: LD_INT 2
22730: PUSH
22731: LD_INT 3
22733: PUSH
22734: LD_INT 4
22736: PUSH
22737: LD_INT 5
22739: PUSH
22740: EMPTY
22741: LIST
22742: LIST
22743: LIST
22744: LIST
22745: ST_TO_ADDR
22746: GO 23607
22748: LD_INT 9
22750: DOUBLE
22751: EQUAL
22752: IFTRUE 22756
22754: GO 22782
22756: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
22757: LD_ADDR_VAR 0 3
22761: PUSH
22762: LD_INT 2
22764: PUSH
22765: LD_INT 3
22767: PUSH
22768: LD_INT 4
22770: PUSH
22771: LD_INT 5
22773: PUSH
22774: EMPTY
22775: LIST
22776: LIST
22777: LIST
22778: LIST
22779: ST_TO_ADDR
22780: GO 23607
22782: LD_INT 7
22784: DOUBLE
22785: EQUAL
22786: IFTRUE 22790
22788: GO 22816
22790: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
22791: LD_ADDR_VAR 0 3
22795: PUSH
22796: LD_INT 2
22798: PUSH
22799: LD_INT 3
22801: PUSH
22802: LD_INT 4
22804: PUSH
22805: LD_INT 5
22807: PUSH
22808: EMPTY
22809: LIST
22810: LIST
22811: LIST
22812: LIST
22813: ST_TO_ADDR
22814: GO 23607
22816: LD_INT 12
22818: DOUBLE
22819: EQUAL
22820: IFTRUE 22824
22822: GO 22850
22824: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
22825: LD_ADDR_VAR 0 3
22829: PUSH
22830: LD_INT 2
22832: PUSH
22833: LD_INT 3
22835: PUSH
22836: LD_INT 4
22838: PUSH
22839: LD_INT 5
22841: PUSH
22842: EMPTY
22843: LIST
22844: LIST
22845: LIST
22846: LIST
22847: ST_TO_ADDR
22848: GO 23607
22850: LD_INT 13
22852: DOUBLE
22853: EQUAL
22854: IFTRUE 22858
22856: GO 22884
22858: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
22859: LD_ADDR_VAR 0 3
22863: PUSH
22864: LD_INT 2
22866: PUSH
22867: LD_INT 3
22869: PUSH
22870: LD_INT 4
22872: PUSH
22873: LD_INT 5
22875: PUSH
22876: EMPTY
22877: LIST
22878: LIST
22879: LIST
22880: LIST
22881: ST_TO_ADDR
22882: GO 23607
22884: LD_INT 14
22886: DOUBLE
22887: EQUAL
22888: IFTRUE 22892
22890: GO 22910
22892: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
22893: LD_ADDR_VAR 0 3
22897: PUSH
22898: LD_INT 4
22900: PUSH
22901: LD_INT 5
22903: PUSH
22904: EMPTY
22905: LIST
22906: LIST
22907: ST_TO_ADDR
22908: GO 23607
22910: LD_INT 6
22912: DOUBLE
22913: EQUAL
22914: IFTRUE 22918
22916: GO 22936
22918: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
22919: LD_ADDR_VAR 0 3
22923: PUSH
22924: LD_INT 4
22926: PUSH
22927: LD_INT 5
22929: PUSH
22930: EMPTY
22931: LIST
22932: LIST
22933: ST_TO_ADDR
22934: GO 23607
22936: LD_INT 10
22938: DOUBLE
22939: EQUAL
22940: IFTRUE 22944
22942: GO 22962
22944: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
22945: LD_ADDR_VAR 0 3
22949: PUSH
22950: LD_INT 4
22952: PUSH
22953: LD_INT 5
22955: PUSH
22956: EMPTY
22957: LIST
22958: LIST
22959: ST_TO_ADDR
22960: GO 23607
22962: LD_INT 22
22964: DOUBLE
22965: EQUAL
22966: IFTRUE 22970
22968: GO 22996
22970: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
22971: LD_ADDR_VAR 0 3
22975: PUSH
22976: LD_INT 11
22978: PUSH
22979: LD_INT 12
22981: PUSH
22982: LD_INT 13
22984: PUSH
22985: LD_INT 14
22987: PUSH
22988: EMPTY
22989: LIST
22990: LIST
22991: LIST
22992: LIST
22993: ST_TO_ADDR
22994: GO 23607
22996: LD_INT 23
22998: DOUBLE
22999: EQUAL
23000: IFTRUE 23004
23002: GO 23030
23004: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
23005: LD_ADDR_VAR 0 3
23009: PUSH
23010: LD_INT 11
23012: PUSH
23013: LD_INT 12
23015: PUSH
23016: LD_INT 13
23018: PUSH
23019: LD_INT 14
23021: PUSH
23022: EMPTY
23023: LIST
23024: LIST
23025: LIST
23026: LIST
23027: ST_TO_ADDR
23028: GO 23607
23030: LD_INT 24
23032: DOUBLE
23033: EQUAL
23034: IFTRUE 23038
23036: GO 23064
23038: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
23039: LD_ADDR_VAR 0 3
23043: PUSH
23044: LD_INT 11
23046: PUSH
23047: LD_INT 12
23049: PUSH
23050: LD_INT 13
23052: PUSH
23053: LD_INT 14
23055: PUSH
23056: EMPTY
23057: LIST
23058: LIST
23059: LIST
23060: LIST
23061: ST_TO_ADDR
23062: GO 23607
23064: LD_INT 30
23066: DOUBLE
23067: EQUAL
23068: IFTRUE 23072
23070: GO 23098
23072: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
23073: LD_ADDR_VAR 0 3
23077: PUSH
23078: LD_INT 11
23080: PUSH
23081: LD_INT 12
23083: PUSH
23084: LD_INT 13
23086: PUSH
23087: LD_INT 14
23089: PUSH
23090: EMPTY
23091: LIST
23092: LIST
23093: LIST
23094: LIST
23095: ST_TO_ADDR
23096: GO 23607
23098: LD_INT 25
23100: DOUBLE
23101: EQUAL
23102: IFTRUE 23106
23104: GO 23124
23106: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
23107: LD_ADDR_VAR 0 3
23111: PUSH
23112: LD_INT 13
23114: PUSH
23115: LD_INT 14
23117: PUSH
23118: EMPTY
23119: LIST
23120: LIST
23121: ST_TO_ADDR
23122: GO 23607
23124: LD_INT 27
23126: DOUBLE
23127: EQUAL
23128: IFTRUE 23132
23130: GO 23150
23132: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_mortar :
23133: LD_ADDR_VAR 0 3
23137: PUSH
23138: LD_INT 13
23140: PUSH
23141: LD_INT 14
23143: PUSH
23144: EMPTY
23145: LIST
23146: LIST
23147: ST_TO_ADDR
23148: GO 23607
23150: LD_EXP 161
23154: DOUBLE
23155: EQUAL
23156: IFTRUE 23160
23158: GO 23186
23160: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
23161: LD_ADDR_VAR 0 3
23165: PUSH
23166: LD_INT 11
23168: PUSH
23169: LD_INT 12
23171: PUSH
23172: LD_INT 13
23174: PUSH
23175: LD_INT 14
23177: PUSH
23178: EMPTY
23179: LIST
23180: LIST
23181: LIST
23182: LIST
23183: ST_TO_ADDR
23184: GO 23607
23186: LD_INT 28
23188: DOUBLE
23189: EQUAL
23190: IFTRUE 23194
23192: GO 23212
23194: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
23195: LD_ADDR_VAR 0 3
23199: PUSH
23200: LD_INT 13
23202: PUSH
23203: LD_INT 14
23205: PUSH
23206: EMPTY
23207: LIST
23208: LIST
23209: ST_TO_ADDR
23210: GO 23607
23212: LD_INT 29
23214: DOUBLE
23215: EQUAL
23216: IFTRUE 23220
23218: GO 23238
23220: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
23221: LD_ADDR_VAR 0 3
23225: PUSH
23226: LD_INT 13
23228: PUSH
23229: LD_INT 14
23231: PUSH
23232: EMPTY
23233: LIST
23234: LIST
23235: ST_TO_ADDR
23236: GO 23607
23238: LD_INT 31
23240: DOUBLE
23241: EQUAL
23242: IFTRUE 23246
23244: GO 23264
23246: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
23247: LD_ADDR_VAR 0 3
23251: PUSH
23252: LD_INT 13
23254: PUSH
23255: LD_INT 14
23257: PUSH
23258: EMPTY
23259: LIST
23260: LIST
23261: ST_TO_ADDR
23262: GO 23607
23264: LD_INT 26
23266: DOUBLE
23267: EQUAL
23268: IFTRUE 23272
23270: GO 23290
23272: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
23273: LD_ADDR_VAR 0 3
23277: PUSH
23278: LD_INT 13
23280: PUSH
23281: LD_INT 14
23283: PUSH
23284: EMPTY
23285: LIST
23286: LIST
23287: ST_TO_ADDR
23288: GO 23607
23290: LD_INT 42
23292: DOUBLE
23293: EQUAL
23294: IFTRUE 23298
23296: GO 23324
23298: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
23299: LD_ADDR_VAR 0 3
23303: PUSH
23304: LD_INT 21
23306: PUSH
23307: LD_INT 22
23309: PUSH
23310: LD_INT 23
23312: PUSH
23313: LD_INT 24
23315: PUSH
23316: EMPTY
23317: LIST
23318: LIST
23319: LIST
23320: LIST
23321: ST_TO_ADDR
23322: GO 23607
23324: LD_INT 43
23326: DOUBLE
23327: EQUAL
23328: IFTRUE 23332
23330: GO 23358
23332: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
23333: LD_ADDR_VAR 0 3
23337: PUSH
23338: LD_INT 21
23340: PUSH
23341: LD_INT 22
23343: PUSH
23344: LD_INT 23
23346: PUSH
23347: LD_INT 24
23349: PUSH
23350: EMPTY
23351: LIST
23352: LIST
23353: LIST
23354: LIST
23355: ST_TO_ADDR
23356: GO 23607
23358: LD_INT 44
23360: DOUBLE
23361: EQUAL
23362: IFTRUE 23366
23364: GO 23392
23366: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
23367: LD_ADDR_VAR 0 3
23371: PUSH
23372: LD_INT 21
23374: PUSH
23375: LD_INT 22
23377: PUSH
23378: LD_INT 23
23380: PUSH
23381: LD_INT 24
23383: PUSH
23384: EMPTY
23385: LIST
23386: LIST
23387: LIST
23388: LIST
23389: ST_TO_ADDR
23390: GO 23607
23392: LD_INT 45
23394: DOUBLE
23395: EQUAL
23396: IFTRUE 23400
23398: GO 23426
23400: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
23401: LD_ADDR_VAR 0 3
23405: PUSH
23406: LD_INT 21
23408: PUSH
23409: LD_INT 22
23411: PUSH
23412: LD_INT 23
23414: PUSH
23415: LD_INT 24
23417: PUSH
23418: EMPTY
23419: LIST
23420: LIST
23421: LIST
23422: LIST
23423: ST_TO_ADDR
23424: GO 23607
23426: LD_INT 49
23428: DOUBLE
23429: EQUAL
23430: IFTRUE 23434
23432: GO 23460
23434: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
23435: LD_ADDR_VAR 0 3
23439: PUSH
23440: LD_INT 21
23442: PUSH
23443: LD_INT 22
23445: PUSH
23446: LD_INT 23
23448: PUSH
23449: LD_INT 24
23451: PUSH
23452: EMPTY
23453: LIST
23454: LIST
23455: LIST
23456: LIST
23457: ST_TO_ADDR
23458: GO 23607
23460: LD_INT 51
23462: DOUBLE
23463: EQUAL
23464: IFTRUE 23468
23466: GO 23494
23468: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
23469: LD_ADDR_VAR 0 3
23473: PUSH
23474: LD_INT 21
23476: PUSH
23477: LD_INT 22
23479: PUSH
23480: LD_INT 23
23482: PUSH
23483: LD_INT 24
23485: PUSH
23486: EMPTY
23487: LIST
23488: LIST
23489: LIST
23490: LIST
23491: ST_TO_ADDR
23492: GO 23607
23494: LD_INT 52
23496: DOUBLE
23497: EQUAL
23498: IFTRUE 23502
23500: GO 23528
23502: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
23503: LD_ADDR_VAR 0 3
23507: PUSH
23508: LD_INT 21
23510: PUSH
23511: LD_INT 22
23513: PUSH
23514: LD_INT 23
23516: PUSH
23517: LD_INT 24
23519: PUSH
23520: EMPTY
23521: LIST
23522: LIST
23523: LIST
23524: LIST
23525: ST_TO_ADDR
23526: GO 23607
23528: LD_INT 53
23530: DOUBLE
23531: EQUAL
23532: IFTRUE 23536
23534: GO 23554
23536: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
23537: LD_ADDR_VAR 0 3
23541: PUSH
23542: LD_INT 23
23544: PUSH
23545: LD_INT 24
23547: PUSH
23548: EMPTY
23549: LIST
23550: LIST
23551: ST_TO_ADDR
23552: GO 23607
23554: LD_INT 46
23556: DOUBLE
23557: EQUAL
23558: IFTRUE 23562
23560: GO 23580
23562: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
23563: LD_ADDR_VAR 0 3
23567: PUSH
23568: LD_INT 23
23570: PUSH
23571: LD_INT 24
23573: PUSH
23574: EMPTY
23575: LIST
23576: LIST
23577: ST_TO_ADDR
23578: GO 23607
23580: LD_INT 47
23582: DOUBLE
23583: EQUAL
23584: IFTRUE 23588
23586: GO 23606
23588: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
23589: LD_ADDR_VAR 0 3
23593: PUSH
23594: LD_INT 23
23596: PUSH
23597: LD_INT 24
23599: PUSH
23600: EMPTY
23601: LIST
23602: LIST
23603: ST_TO_ADDR
23604: GO 23607
23606: POP
// result := ( chassis in result ) ;
23607: LD_ADDR_VAR 0 3
23611: PUSH
23612: LD_VAR 0 1
23616: PUSH
23617: LD_VAR 0 3
23621: IN
23622: ST_TO_ADDR
// end ;
23623: LD_VAR 0 3
23627: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
23628: LD_INT 0
23630: PPUSH
23631: PPUSH
23632: PPUSH
23633: PPUSH
23634: PPUSH
23635: PPUSH
23636: PPUSH
// result := array ;
23637: LD_ADDR_VAR 0 5
23641: PUSH
23642: LD_VAR 0 1
23646: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
23647: LD_VAR 0 1
23651: NOT
23652: PUSH
23653: LD_VAR 0 2
23657: NOT
23658: OR
23659: PUSH
23660: LD_VAR 0 3
23664: NOT
23665: OR
23666: PUSH
23667: LD_VAR 0 2
23671: PUSH
23672: LD_VAR 0 1
23676: GREATER
23677: OR
23678: PUSH
23679: LD_VAR 0 3
23683: PUSH
23684: LD_VAR 0 1
23688: GREATER
23689: OR
23690: IFFALSE 23694
// exit ;
23692: GO 23990
// if direction then
23694: LD_VAR 0 4
23698: IFFALSE 23762
// begin d := 1 ;
23700: LD_ADDR_VAR 0 9
23704: PUSH
23705: LD_INT 1
23707: ST_TO_ADDR
// if i_from > i_to then
23708: LD_VAR 0 2
23712: PUSH
23713: LD_VAR 0 3
23717: GREATER
23718: IFFALSE 23744
// length := ( array - i_from ) + i_to else
23720: LD_ADDR_VAR 0 11
23724: PUSH
23725: LD_VAR 0 1
23729: PUSH
23730: LD_VAR 0 2
23734: MINUS
23735: PUSH
23736: LD_VAR 0 3
23740: PLUS
23741: ST_TO_ADDR
23742: GO 23760
// length := i_to - i_from ;
23744: LD_ADDR_VAR 0 11
23748: PUSH
23749: LD_VAR 0 3
23753: PUSH
23754: LD_VAR 0 2
23758: MINUS
23759: ST_TO_ADDR
// end else
23760: GO 23823
// begin d := - 1 ;
23762: LD_ADDR_VAR 0 9
23766: PUSH
23767: LD_INT 1
23769: NEG
23770: ST_TO_ADDR
// if i_from > i_to then
23771: LD_VAR 0 2
23775: PUSH
23776: LD_VAR 0 3
23780: GREATER
23781: IFFALSE 23801
// length := i_from - i_to else
23783: LD_ADDR_VAR 0 11
23787: PUSH
23788: LD_VAR 0 2
23792: PUSH
23793: LD_VAR 0 3
23797: MINUS
23798: ST_TO_ADDR
23799: GO 23823
// length := ( array - i_to ) + i_from ;
23801: LD_ADDR_VAR 0 11
23805: PUSH
23806: LD_VAR 0 1
23810: PUSH
23811: LD_VAR 0 3
23815: MINUS
23816: PUSH
23817: LD_VAR 0 2
23821: PLUS
23822: ST_TO_ADDR
// end ; if not length then
23823: LD_VAR 0 11
23827: NOT
23828: IFFALSE 23832
// exit ;
23830: GO 23990
// tmp := array ;
23832: LD_ADDR_VAR 0 10
23836: PUSH
23837: LD_VAR 0 1
23841: ST_TO_ADDR
// for i = 1 to length do
23842: LD_ADDR_VAR 0 6
23846: PUSH
23847: DOUBLE
23848: LD_INT 1
23850: DEC
23851: ST_TO_ADDR
23852: LD_VAR 0 11
23856: PUSH
23857: FOR_TO
23858: IFFALSE 23978
// begin for j = 1 to array do
23860: LD_ADDR_VAR 0 7
23864: PUSH
23865: DOUBLE
23866: LD_INT 1
23868: DEC
23869: ST_TO_ADDR
23870: LD_VAR 0 1
23874: PUSH
23875: FOR_TO
23876: IFFALSE 23964
// begin k := j + d ;
23878: LD_ADDR_VAR 0 8
23882: PUSH
23883: LD_VAR 0 7
23887: PUSH
23888: LD_VAR 0 9
23892: PLUS
23893: ST_TO_ADDR
// if k > array then
23894: LD_VAR 0 8
23898: PUSH
23899: LD_VAR 0 1
23903: GREATER
23904: IFFALSE 23914
// k := 1 ;
23906: LD_ADDR_VAR 0 8
23910: PUSH
23911: LD_INT 1
23913: ST_TO_ADDR
// if not k then
23914: LD_VAR 0 8
23918: NOT
23919: IFFALSE 23931
// k := array ;
23921: LD_ADDR_VAR 0 8
23925: PUSH
23926: LD_VAR 0 1
23930: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
23931: LD_ADDR_VAR 0 10
23935: PUSH
23936: LD_VAR 0 10
23940: PPUSH
23941: LD_VAR 0 8
23945: PPUSH
23946: LD_VAR 0 1
23950: PUSH
23951: LD_VAR 0 7
23955: ARRAY
23956: PPUSH
23957: CALL_OW 1
23961: ST_TO_ADDR
// end ;
23962: GO 23875
23964: POP
23965: POP
// array := tmp ;
23966: LD_ADDR_VAR 0 1
23970: PUSH
23971: LD_VAR 0 10
23975: ST_TO_ADDR
// end ;
23976: GO 23857
23978: POP
23979: POP
// result := array ;
23980: LD_ADDR_VAR 0 5
23984: PUSH
23985: LD_VAR 0 1
23989: ST_TO_ADDR
// end ;
23990: LD_VAR 0 5
23994: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
23995: LD_INT 0
23997: PPUSH
23998: PPUSH
// result := 0 ;
23999: LD_ADDR_VAR 0 3
24003: PUSH
24004: LD_INT 0
24006: ST_TO_ADDR
// if not array or not value in array then
24007: LD_VAR 0 1
24011: NOT
24012: PUSH
24013: LD_VAR 0 2
24017: PUSH
24018: LD_VAR 0 1
24022: IN
24023: NOT
24024: OR
24025: IFFALSE 24029
// exit ;
24027: GO 24083
// for i = 1 to array do
24029: LD_ADDR_VAR 0 4
24033: PUSH
24034: DOUBLE
24035: LD_INT 1
24037: DEC
24038: ST_TO_ADDR
24039: LD_VAR 0 1
24043: PUSH
24044: FOR_TO
24045: IFFALSE 24081
// if value = array [ i ] then
24047: LD_VAR 0 2
24051: PUSH
24052: LD_VAR 0 1
24056: PUSH
24057: LD_VAR 0 4
24061: ARRAY
24062: EQUAL
24063: IFFALSE 24079
// begin result := i ;
24065: LD_ADDR_VAR 0 3
24069: PUSH
24070: LD_VAR 0 4
24074: ST_TO_ADDR
// exit ;
24075: POP
24076: POP
24077: GO 24083
// end ;
24079: GO 24044
24081: POP
24082: POP
// end ;
24083: LD_VAR 0 3
24087: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
24088: LD_INT 0
24090: PPUSH
// vc_chassis := chassis ;
24091: LD_ADDR_OWVAR 37
24095: PUSH
24096: LD_VAR 0 1
24100: ST_TO_ADDR
// vc_engine := engine ;
24101: LD_ADDR_OWVAR 39
24105: PUSH
24106: LD_VAR 0 2
24110: ST_TO_ADDR
// vc_control := control ;
24111: LD_ADDR_OWVAR 38
24115: PUSH
24116: LD_VAR 0 3
24120: ST_TO_ADDR
// vc_weapon := weapon ;
24121: LD_ADDR_OWVAR 40
24125: PUSH
24126: LD_VAR 0 4
24130: ST_TO_ADDR
// vc_fuel_battery := fuel ;
24131: LD_ADDR_OWVAR 41
24135: PUSH
24136: LD_VAR 0 5
24140: ST_TO_ADDR
// end ;
24141: LD_VAR 0 6
24145: RET
// export function WantPlant ( unit ) ; var task ; begin
24146: LD_INT 0
24148: PPUSH
24149: PPUSH
// result := false ;
24150: LD_ADDR_VAR 0 2
24154: PUSH
24155: LD_INT 0
24157: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
24158: LD_ADDR_VAR 0 3
24162: PUSH
24163: LD_VAR 0 1
24167: PPUSH
24168: CALL_OW 437
24172: ST_TO_ADDR
// if task then
24173: LD_VAR 0 3
24177: IFFALSE 24205
// if task [ 1 ] [ 1 ] = p then
24179: LD_VAR 0 3
24183: PUSH
24184: LD_INT 1
24186: ARRAY
24187: PUSH
24188: LD_INT 1
24190: ARRAY
24191: PUSH
24192: LD_STRING p
24194: EQUAL
24195: IFFALSE 24205
// result := true ;
24197: LD_ADDR_VAR 0 2
24201: PUSH
24202: LD_INT 1
24204: ST_TO_ADDR
// end ;
24205: LD_VAR 0 2
24209: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
24210: LD_INT 0
24212: PPUSH
24213: PPUSH
24214: PPUSH
24215: PPUSH
// if pos < 1 then
24216: LD_VAR 0 2
24220: PUSH
24221: LD_INT 1
24223: LESS
24224: IFFALSE 24228
// exit ;
24226: GO 24531
// if pos = 1 then
24228: LD_VAR 0 2
24232: PUSH
24233: LD_INT 1
24235: EQUAL
24236: IFFALSE 24269
// result := Replace ( arr , pos [ 1 ] , value ) else
24238: LD_ADDR_VAR 0 4
24242: PUSH
24243: LD_VAR 0 1
24247: PPUSH
24248: LD_VAR 0 2
24252: PUSH
24253: LD_INT 1
24255: ARRAY
24256: PPUSH
24257: LD_VAR 0 3
24261: PPUSH
24262: CALL_OW 1
24266: ST_TO_ADDR
24267: GO 24531
// begin tmp := arr ;
24269: LD_ADDR_VAR 0 6
24273: PUSH
24274: LD_VAR 0 1
24278: ST_TO_ADDR
// s_arr := [ tmp ] ;
24279: LD_ADDR_VAR 0 7
24283: PUSH
24284: LD_VAR 0 6
24288: PUSH
24289: EMPTY
24290: LIST
24291: ST_TO_ADDR
// for i = 1 to pos - 1 do
24292: LD_ADDR_VAR 0 5
24296: PUSH
24297: DOUBLE
24298: LD_INT 1
24300: DEC
24301: ST_TO_ADDR
24302: LD_VAR 0 2
24306: PUSH
24307: LD_INT 1
24309: MINUS
24310: PUSH
24311: FOR_TO
24312: IFFALSE 24357
// begin tmp := tmp [ pos [ i ] ] ;
24314: LD_ADDR_VAR 0 6
24318: PUSH
24319: LD_VAR 0 6
24323: PUSH
24324: LD_VAR 0 2
24328: PUSH
24329: LD_VAR 0 5
24333: ARRAY
24334: ARRAY
24335: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
24336: LD_ADDR_VAR 0 7
24340: PUSH
24341: LD_VAR 0 7
24345: PUSH
24346: LD_VAR 0 6
24350: PUSH
24351: EMPTY
24352: LIST
24353: ADD
24354: ST_TO_ADDR
// end ;
24355: GO 24311
24357: POP
24358: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
24359: LD_ADDR_VAR 0 6
24363: PUSH
24364: LD_VAR 0 6
24368: PPUSH
24369: LD_VAR 0 2
24373: PUSH
24374: LD_VAR 0 2
24378: ARRAY
24379: PPUSH
24380: LD_VAR 0 3
24384: PPUSH
24385: CALL_OW 1
24389: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
24390: LD_ADDR_VAR 0 7
24394: PUSH
24395: LD_VAR 0 7
24399: PPUSH
24400: LD_VAR 0 7
24404: PPUSH
24405: LD_VAR 0 6
24409: PPUSH
24410: CALL_OW 1
24414: ST_TO_ADDR
// for i = s_arr downto 2 do
24415: LD_ADDR_VAR 0 5
24419: PUSH
24420: DOUBLE
24421: LD_VAR 0 7
24425: INC
24426: ST_TO_ADDR
24427: LD_INT 2
24429: PUSH
24430: FOR_DOWNTO
24431: IFFALSE 24515
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
24433: LD_ADDR_VAR 0 6
24437: PUSH
24438: LD_VAR 0 7
24442: PUSH
24443: LD_VAR 0 5
24447: PUSH
24448: LD_INT 1
24450: MINUS
24451: ARRAY
24452: PPUSH
24453: LD_VAR 0 2
24457: PUSH
24458: LD_VAR 0 5
24462: PUSH
24463: LD_INT 1
24465: MINUS
24466: ARRAY
24467: PPUSH
24468: LD_VAR 0 7
24472: PUSH
24473: LD_VAR 0 5
24477: ARRAY
24478: PPUSH
24479: CALL_OW 1
24483: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
24484: LD_ADDR_VAR 0 7
24488: PUSH
24489: LD_VAR 0 7
24493: PPUSH
24494: LD_VAR 0 5
24498: PUSH
24499: LD_INT 1
24501: MINUS
24502: PPUSH
24503: LD_VAR 0 6
24507: PPUSH
24508: CALL_OW 1
24512: ST_TO_ADDR
// end ;
24513: GO 24430
24515: POP
24516: POP
// result := s_arr [ 1 ] ;
24517: LD_ADDR_VAR 0 4
24521: PUSH
24522: LD_VAR 0 7
24526: PUSH
24527: LD_INT 1
24529: ARRAY
24530: ST_TO_ADDR
// end ; end ;
24531: LD_VAR 0 4
24535: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
24536: LD_INT 0
24538: PPUSH
24539: PPUSH
// if not list then
24540: LD_VAR 0 1
24544: NOT
24545: IFFALSE 24549
// exit ;
24547: GO 24640
// i := list [ pos1 ] ;
24549: LD_ADDR_VAR 0 5
24553: PUSH
24554: LD_VAR 0 1
24558: PUSH
24559: LD_VAR 0 2
24563: ARRAY
24564: ST_TO_ADDR
// if not i then
24565: LD_VAR 0 5
24569: NOT
24570: IFFALSE 24574
// exit ;
24572: GO 24640
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
24574: LD_ADDR_VAR 0 1
24578: PUSH
24579: LD_VAR 0 1
24583: PPUSH
24584: LD_VAR 0 2
24588: PPUSH
24589: LD_VAR 0 1
24593: PUSH
24594: LD_VAR 0 3
24598: ARRAY
24599: PPUSH
24600: CALL_OW 1
24604: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
24605: LD_ADDR_VAR 0 1
24609: PUSH
24610: LD_VAR 0 1
24614: PPUSH
24615: LD_VAR 0 3
24619: PPUSH
24620: LD_VAR 0 5
24624: PPUSH
24625: CALL_OW 1
24629: ST_TO_ADDR
// result := list ;
24630: LD_ADDR_VAR 0 4
24634: PUSH
24635: LD_VAR 0 1
24639: ST_TO_ADDR
// end ;
24640: LD_VAR 0 4
24644: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
24645: LD_INT 0
24647: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
24648: LD_ADDR_VAR 0 5
24652: PUSH
24653: LD_VAR 0 1
24657: PPUSH
24658: CALL_OW 250
24662: PPUSH
24663: LD_VAR 0 1
24667: PPUSH
24668: CALL_OW 251
24672: PPUSH
24673: LD_VAR 0 2
24677: PPUSH
24678: LD_VAR 0 3
24682: PPUSH
24683: LD_VAR 0 4
24687: PPUSH
24688: CALL 24698 0 5
24692: ST_TO_ADDR
// end ;
24693: LD_VAR 0 5
24697: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
24698: LD_INT 0
24700: PPUSH
24701: PPUSH
24702: PPUSH
24703: PPUSH
// if not list then
24704: LD_VAR 0 3
24708: NOT
24709: IFFALSE 24713
// exit ;
24711: GO 25101
// result := [ ] ;
24713: LD_ADDR_VAR 0 6
24717: PUSH
24718: EMPTY
24719: ST_TO_ADDR
// for i in list do
24720: LD_ADDR_VAR 0 7
24724: PUSH
24725: LD_VAR 0 3
24729: PUSH
24730: FOR_IN
24731: IFFALSE 24933
// begin tmp := GetDistUnitXY ( i , x , y ) ;
24733: LD_ADDR_VAR 0 9
24737: PUSH
24738: LD_VAR 0 7
24742: PPUSH
24743: LD_VAR 0 1
24747: PPUSH
24748: LD_VAR 0 2
24752: PPUSH
24753: CALL_OW 297
24757: ST_TO_ADDR
// if not result then
24758: LD_VAR 0 6
24762: NOT
24763: IFFALSE 24789
// result := [ [ i , tmp ] ] else
24765: LD_ADDR_VAR 0 6
24769: PUSH
24770: LD_VAR 0 7
24774: PUSH
24775: LD_VAR 0 9
24779: PUSH
24780: EMPTY
24781: LIST
24782: LIST
24783: PUSH
24784: EMPTY
24785: LIST
24786: ST_TO_ADDR
24787: GO 24931
// begin if result [ result ] [ 2 ] < tmp then
24789: LD_VAR 0 6
24793: PUSH
24794: LD_VAR 0 6
24798: ARRAY
24799: PUSH
24800: LD_INT 2
24802: ARRAY
24803: PUSH
24804: LD_VAR 0 9
24808: LESS
24809: IFFALSE 24851
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
24811: LD_ADDR_VAR 0 6
24815: PUSH
24816: LD_VAR 0 6
24820: PPUSH
24821: LD_VAR 0 6
24825: PUSH
24826: LD_INT 1
24828: PLUS
24829: PPUSH
24830: LD_VAR 0 7
24834: PUSH
24835: LD_VAR 0 9
24839: PUSH
24840: EMPTY
24841: LIST
24842: LIST
24843: PPUSH
24844: CALL_OW 2
24848: ST_TO_ADDR
24849: GO 24931
// for j = 1 to result do
24851: LD_ADDR_VAR 0 8
24855: PUSH
24856: DOUBLE
24857: LD_INT 1
24859: DEC
24860: ST_TO_ADDR
24861: LD_VAR 0 6
24865: PUSH
24866: FOR_TO
24867: IFFALSE 24929
// begin if tmp < result [ j ] [ 2 ] then
24869: LD_VAR 0 9
24873: PUSH
24874: LD_VAR 0 6
24878: PUSH
24879: LD_VAR 0 8
24883: ARRAY
24884: PUSH
24885: LD_INT 2
24887: ARRAY
24888: LESS
24889: IFFALSE 24927
// begin result := Insert ( result , j , [ i , tmp ] ) ;
24891: LD_ADDR_VAR 0 6
24895: PUSH
24896: LD_VAR 0 6
24900: PPUSH
24901: LD_VAR 0 8
24905: PPUSH
24906: LD_VAR 0 7
24910: PUSH
24911: LD_VAR 0 9
24915: PUSH
24916: EMPTY
24917: LIST
24918: LIST
24919: PPUSH
24920: CALL_OW 2
24924: ST_TO_ADDR
// break ;
24925: GO 24929
// end ; end ;
24927: GO 24866
24929: POP
24930: POP
// end ; end ;
24931: GO 24730
24933: POP
24934: POP
// if result and not asc then
24935: LD_VAR 0 6
24939: PUSH
24940: LD_VAR 0 4
24944: NOT
24945: AND
24946: IFFALSE 25021
// begin tmp := result ;
24948: LD_ADDR_VAR 0 9
24952: PUSH
24953: LD_VAR 0 6
24957: ST_TO_ADDR
// for i = tmp downto 1 do
24958: LD_ADDR_VAR 0 7
24962: PUSH
24963: DOUBLE
24964: LD_VAR 0 9
24968: INC
24969: ST_TO_ADDR
24970: LD_INT 1
24972: PUSH
24973: FOR_DOWNTO
24974: IFFALSE 25019
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
24976: LD_ADDR_VAR 0 6
24980: PUSH
24981: LD_VAR 0 6
24985: PPUSH
24986: LD_VAR 0 9
24990: PUSH
24991: LD_VAR 0 7
24995: MINUS
24996: PUSH
24997: LD_INT 1
24999: PLUS
25000: PPUSH
25001: LD_VAR 0 9
25005: PUSH
25006: LD_VAR 0 7
25010: ARRAY
25011: PPUSH
25012: CALL_OW 1
25016: ST_TO_ADDR
25017: GO 24973
25019: POP
25020: POP
// end ; tmp := [ ] ;
25021: LD_ADDR_VAR 0 9
25025: PUSH
25026: EMPTY
25027: ST_TO_ADDR
// if mode then
25028: LD_VAR 0 5
25032: IFFALSE 25101
// begin for i = 1 to result do
25034: LD_ADDR_VAR 0 7
25038: PUSH
25039: DOUBLE
25040: LD_INT 1
25042: DEC
25043: ST_TO_ADDR
25044: LD_VAR 0 6
25048: PUSH
25049: FOR_TO
25050: IFFALSE 25089
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
25052: LD_ADDR_VAR 0 9
25056: PUSH
25057: LD_VAR 0 9
25061: PPUSH
25062: LD_VAR 0 7
25066: PPUSH
25067: LD_VAR 0 6
25071: PUSH
25072: LD_VAR 0 7
25076: ARRAY
25077: PUSH
25078: LD_INT 1
25080: ARRAY
25081: PPUSH
25082: CALL_OW 1
25086: ST_TO_ADDR
25087: GO 25049
25089: POP
25090: POP
// result := tmp ;
25091: LD_ADDR_VAR 0 6
25095: PUSH
25096: LD_VAR 0 9
25100: ST_TO_ADDR
// end ; end ;
25101: LD_VAR 0 6
25105: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
25106: LD_INT 0
25108: PPUSH
25109: PPUSH
25110: PPUSH
25111: PPUSH
25112: PPUSH
25113: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
25114: LD_ADDR_VAR 0 5
25118: PUSH
25119: LD_INT 0
25121: PUSH
25122: LD_INT 0
25124: PUSH
25125: LD_INT 0
25127: PUSH
25128: EMPTY
25129: PUSH
25130: EMPTY
25131: LIST
25132: LIST
25133: LIST
25134: LIST
25135: ST_TO_ADDR
// if not x or not y then
25136: LD_VAR 0 2
25140: NOT
25141: PUSH
25142: LD_VAR 0 3
25146: NOT
25147: OR
25148: IFFALSE 25152
// exit ;
25150: GO 26804
// if not range then
25152: LD_VAR 0 4
25156: NOT
25157: IFFALSE 25167
// range := 10 ;
25159: LD_ADDR_VAR 0 4
25163: PUSH
25164: LD_INT 10
25166: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
25167: LD_ADDR_VAR 0 8
25171: PUSH
25172: LD_INT 81
25174: PUSH
25175: LD_VAR 0 1
25179: PUSH
25180: EMPTY
25181: LIST
25182: LIST
25183: PUSH
25184: LD_INT 92
25186: PUSH
25187: LD_VAR 0 2
25191: PUSH
25192: LD_VAR 0 3
25196: PUSH
25197: LD_VAR 0 4
25201: PUSH
25202: EMPTY
25203: LIST
25204: LIST
25205: LIST
25206: LIST
25207: PUSH
25208: LD_INT 3
25210: PUSH
25211: LD_INT 21
25213: PUSH
25214: LD_INT 3
25216: PUSH
25217: EMPTY
25218: LIST
25219: LIST
25220: PUSH
25221: EMPTY
25222: LIST
25223: LIST
25224: PUSH
25225: EMPTY
25226: LIST
25227: LIST
25228: LIST
25229: PPUSH
25230: CALL_OW 69
25234: ST_TO_ADDR
// if not tmp then
25235: LD_VAR 0 8
25239: NOT
25240: IFFALSE 25244
// exit ;
25242: GO 26804
// for i in tmp do
25244: LD_ADDR_VAR 0 6
25248: PUSH
25249: LD_VAR 0 8
25253: PUSH
25254: FOR_IN
25255: IFFALSE 26779
// begin points := [ 0 , 0 , 0 ] ;
25257: LD_ADDR_VAR 0 9
25261: PUSH
25262: LD_INT 0
25264: PUSH
25265: LD_INT 0
25267: PUSH
25268: LD_INT 0
25270: PUSH
25271: EMPTY
25272: LIST
25273: LIST
25274: LIST
25275: ST_TO_ADDR
// bpoints := 1 ;
25276: LD_ADDR_VAR 0 10
25280: PUSH
25281: LD_INT 1
25283: ST_TO_ADDR
// case GetType ( i ) of unit_human :
25284: LD_VAR 0 6
25288: PPUSH
25289: CALL_OW 247
25293: PUSH
25294: LD_INT 1
25296: DOUBLE
25297: EQUAL
25298: IFTRUE 25302
25300: GO 25880
25302: POP
// begin if GetClass ( i ) = 1 then
25303: LD_VAR 0 6
25307: PPUSH
25308: CALL_OW 257
25312: PUSH
25313: LD_INT 1
25315: EQUAL
25316: IFFALSE 25337
// points := [ 10 , 5 , 3 ] ;
25318: LD_ADDR_VAR 0 9
25322: PUSH
25323: LD_INT 10
25325: PUSH
25326: LD_INT 5
25328: PUSH
25329: LD_INT 3
25331: PUSH
25332: EMPTY
25333: LIST
25334: LIST
25335: LIST
25336: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
25337: LD_VAR 0 6
25341: PPUSH
25342: CALL_OW 257
25346: PUSH
25347: LD_INT 2
25349: PUSH
25350: LD_INT 3
25352: PUSH
25353: LD_INT 4
25355: PUSH
25356: EMPTY
25357: LIST
25358: LIST
25359: LIST
25360: IN
25361: IFFALSE 25382
// points := [ 3 , 2 , 1 ] ;
25363: LD_ADDR_VAR 0 9
25367: PUSH
25368: LD_INT 3
25370: PUSH
25371: LD_INT 2
25373: PUSH
25374: LD_INT 1
25376: PUSH
25377: EMPTY
25378: LIST
25379: LIST
25380: LIST
25381: ST_TO_ADDR
// if GetClass ( i ) = 5 then
25382: LD_VAR 0 6
25386: PPUSH
25387: CALL_OW 257
25391: PUSH
25392: LD_INT 5
25394: EQUAL
25395: IFFALSE 25416
// points := [ 130 , 5 , 2 ] ;
25397: LD_ADDR_VAR 0 9
25401: PUSH
25402: LD_INT 130
25404: PUSH
25405: LD_INT 5
25407: PUSH
25408: LD_INT 2
25410: PUSH
25411: EMPTY
25412: LIST
25413: LIST
25414: LIST
25415: ST_TO_ADDR
// if GetClass ( i ) = 8 then
25416: LD_VAR 0 6
25420: PPUSH
25421: CALL_OW 257
25425: PUSH
25426: LD_INT 8
25428: EQUAL
25429: IFFALSE 25450
// points := [ 35 , 35 , 30 ] ;
25431: LD_ADDR_VAR 0 9
25435: PUSH
25436: LD_INT 35
25438: PUSH
25439: LD_INT 35
25441: PUSH
25442: LD_INT 30
25444: PUSH
25445: EMPTY
25446: LIST
25447: LIST
25448: LIST
25449: ST_TO_ADDR
// if GetClass ( i ) = 9 then
25450: LD_VAR 0 6
25454: PPUSH
25455: CALL_OW 257
25459: PUSH
25460: LD_INT 9
25462: EQUAL
25463: IFFALSE 25484
// points := [ 20 , 55 , 40 ] ;
25465: LD_ADDR_VAR 0 9
25469: PUSH
25470: LD_INT 20
25472: PUSH
25473: LD_INT 55
25475: PUSH
25476: LD_INT 40
25478: PUSH
25479: EMPTY
25480: LIST
25481: LIST
25482: LIST
25483: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
25484: LD_VAR 0 6
25488: PPUSH
25489: CALL_OW 257
25493: PUSH
25494: LD_INT 12
25496: PUSH
25497: LD_INT 16
25499: PUSH
25500: EMPTY
25501: LIST
25502: LIST
25503: IN
25504: IFFALSE 25525
// points := [ 5 , 3 , 2 ] ;
25506: LD_ADDR_VAR 0 9
25510: PUSH
25511: LD_INT 5
25513: PUSH
25514: LD_INT 3
25516: PUSH
25517: LD_INT 2
25519: PUSH
25520: EMPTY
25521: LIST
25522: LIST
25523: LIST
25524: ST_TO_ADDR
// if GetClass ( i ) = 17 then
25525: LD_VAR 0 6
25529: PPUSH
25530: CALL_OW 257
25534: PUSH
25535: LD_INT 17
25537: EQUAL
25538: IFFALSE 25559
// points := [ 100 , 50 , 75 ] ;
25540: LD_ADDR_VAR 0 9
25544: PUSH
25545: LD_INT 100
25547: PUSH
25548: LD_INT 50
25550: PUSH
25551: LD_INT 75
25553: PUSH
25554: EMPTY
25555: LIST
25556: LIST
25557: LIST
25558: ST_TO_ADDR
// if GetClass ( i ) = 15 then
25559: LD_VAR 0 6
25563: PPUSH
25564: CALL_OW 257
25568: PUSH
25569: LD_INT 15
25571: EQUAL
25572: IFFALSE 25593
// points := [ 10 , 5 , 3 ] ;
25574: LD_ADDR_VAR 0 9
25578: PUSH
25579: LD_INT 10
25581: PUSH
25582: LD_INT 5
25584: PUSH
25585: LD_INT 3
25587: PUSH
25588: EMPTY
25589: LIST
25590: LIST
25591: LIST
25592: ST_TO_ADDR
// if GetClass ( i ) = 14 then
25593: LD_VAR 0 6
25597: PPUSH
25598: CALL_OW 257
25602: PUSH
25603: LD_INT 14
25605: EQUAL
25606: IFFALSE 25627
// points := [ 10 , 0 , 0 ] ;
25608: LD_ADDR_VAR 0 9
25612: PUSH
25613: LD_INT 10
25615: PUSH
25616: LD_INT 0
25618: PUSH
25619: LD_INT 0
25621: PUSH
25622: EMPTY
25623: LIST
25624: LIST
25625: LIST
25626: ST_TO_ADDR
// if GetClass ( i ) = 11 then
25627: LD_VAR 0 6
25631: PPUSH
25632: CALL_OW 257
25636: PUSH
25637: LD_INT 11
25639: EQUAL
25640: IFFALSE 25661
// points := [ 30 , 10 , 5 ] ;
25642: LD_ADDR_VAR 0 9
25646: PUSH
25647: LD_INT 30
25649: PUSH
25650: LD_INT 10
25652: PUSH
25653: LD_INT 5
25655: PUSH
25656: EMPTY
25657: LIST
25658: LIST
25659: LIST
25660: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
25661: LD_VAR 0 1
25665: PPUSH
25666: LD_INT 5
25668: PPUSH
25669: CALL_OW 321
25673: PUSH
25674: LD_INT 2
25676: EQUAL
25677: IFFALSE 25694
// bpoints := bpoints * 1.8 ;
25679: LD_ADDR_VAR 0 10
25683: PUSH
25684: LD_VAR 0 10
25688: PUSH
25689: LD_REAL  1.80000000000000E+0000
25692: MUL
25693: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
25694: LD_VAR 0 6
25698: PPUSH
25699: CALL_OW 257
25703: PUSH
25704: LD_INT 1
25706: PUSH
25707: LD_INT 2
25709: PUSH
25710: LD_INT 3
25712: PUSH
25713: LD_INT 4
25715: PUSH
25716: EMPTY
25717: LIST
25718: LIST
25719: LIST
25720: LIST
25721: IN
25722: PUSH
25723: LD_VAR 0 1
25727: PPUSH
25728: LD_INT 51
25730: PPUSH
25731: CALL_OW 321
25735: PUSH
25736: LD_INT 2
25738: EQUAL
25739: AND
25740: IFFALSE 25757
// bpoints := bpoints * 1.2 ;
25742: LD_ADDR_VAR 0 10
25746: PUSH
25747: LD_VAR 0 10
25751: PUSH
25752: LD_REAL  1.20000000000000E+0000
25755: MUL
25756: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
25757: LD_VAR 0 6
25761: PPUSH
25762: CALL_OW 257
25766: PUSH
25767: LD_INT 5
25769: PUSH
25770: LD_INT 7
25772: PUSH
25773: LD_INT 9
25775: PUSH
25776: EMPTY
25777: LIST
25778: LIST
25779: LIST
25780: IN
25781: PUSH
25782: LD_VAR 0 1
25786: PPUSH
25787: LD_INT 52
25789: PPUSH
25790: CALL_OW 321
25794: PUSH
25795: LD_INT 2
25797: EQUAL
25798: AND
25799: IFFALSE 25816
// bpoints := bpoints * 1.5 ;
25801: LD_ADDR_VAR 0 10
25805: PUSH
25806: LD_VAR 0 10
25810: PUSH
25811: LD_REAL  1.50000000000000E+0000
25814: MUL
25815: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
25816: LD_VAR 0 1
25820: PPUSH
25821: LD_INT 66
25823: PPUSH
25824: CALL_OW 321
25828: PUSH
25829: LD_INT 2
25831: EQUAL
25832: IFFALSE 25849
// bpoints := bpoints * 1.1 ;
25834: LD_ADDR_VAR 0 10
25838: PUSH
25839: LD_VAR 0 10
25843: PUSH
25844: LD_REAL  1.10000000000000E+0000
25847: MUL
25848: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
25849: LD_ADDR_VAR 0 10
25853: PUSH
25854: LD_VAR 0 10
25858: PUSH
25859: LD_VAR 0 6
25863: PPUSH
25864: LD_INT 1
25866: PPUSH
25867: CALL_OW 259
25871: PUSH
25872: LD_REAL  1.15000000000000E+0000
25875: MUL
25876: MUL
25877: ST_TO_ADDR
// end ; unit_vehicle :
25878: GO 26708
25880: LD_INT 2
25882: DOUBLE
25883: EQUAL
25884: IFTRUE 25888
25886: GO 26696
25888: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
25889: LD_VAR 0 6
25893: PPUSH
25894: CALL_OW 264
25898: PUSH
25899: LD_INT 2
25901: PUSH
25902: LD_INT 42
25904: PUSH
25905: LD_INT 24
25907: PUSH
25908: EMPTY
25909: LIST
25910: LIST
25911: LIST
25912: IN
25913: IFFALSE 25934
// points := [ 25 , 5 , 3 ] ;
25915: LD_ADDR_VAR 0 9
25919: PUSH
25920: LD_INT 25
25922: PUSH
25923: LD_INT 5
25925: PUSH
25926: LD_INT 3
25928: PUSH
25929: EMPTY
25930: LIST
25931: LIST
25932: LIST
25933: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
25934: LD_VAR 0 6
25938: PPUSH
25939: CALL_OW 264
25943: PUSH
25944: LD_INT 4
25946: PUSH
25947: LD_INT 43
25949: PUSH
25950: LD_INT 25
25952: PUSH
25953: EMPTY
25954: LIST
25955: LIST
25956: LIST
25957: IN
25958: IFFALSE 25979
// points := [ 40 , 15 , 5 ] ;
25960: LD_ADDR_VAR 0 9
25964: PUSH
25965: LD_INT 40
25967: PUSH
25968: LD_INT 15
25970: PUSH
25971: LD_INT 5
25973: PUSH
25974: EMPTY
25975: LIST
25976: LIST
25977: LIST
25978: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
25979: LD_VAR 0 6
25983: PPUSH
25984: CALL_OW 264
25988: PUSH
25989: LD_INT 3
25991: PUSH
25992: LD_INT 23
25994: PUSH
25995: EMPTY
25996: LIST
25997: LIST
25998: IN
25999: IFFALSE 26020
// points := [ 7 , 25 , 8 ] ;
26001: LD_ADDR_VAR 0 9
26005: PUSH
26006: LD_INT 7
26008: PUSH
26009: LD_INT 25
26011: PUSH
26012: LD_INT 8
26014: PUSH
26015: EMPTY
26016: LIST
26017: LIST
26018: LIST
26019: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
26020: LD_VAR 0 6
26024: PPUSH
26025: CALL_OW 264
26029: PUSH
26030: LD_INT 5
26032: PUSH
26033: LD_INT 27
26035: PUSH
26036: LD_INT 44
26038: PUSH
26039: EMPTY
26040: LIST
26041: LIST
26042: LIST
26043: IN
26044: IFFALSE 26065
// points := [ 14 , 50 , 16 ] ;
26046: LD_ADDR_VAR 0 9
26050: PUSH
26051: LD_INT 14
26053: PUSH
26054: LD_INT 50
26056: PUSH
26057: LD_INT 16
26059: PUSH
26060: EMPTY
26061: LIST
26062: LIST
26063: LIST
26064: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
26065: LD_VAR 0 6
26069: PPUSH
26070: CALL_OW 264
26074: PUSH
26075: LD_INT 6
26077: PUSH
26078: LD_INT 46
26080: PUSH
26081: EMPTY
26082: LIST
26083: LIST
26084: IN
26085: IFFALSE 26106
// points := [ 32 , 120 , 70 ] ;
26087: LD_ADDR_VAR 0 9
26091: PUSH
26092: LD_INT 32
26094: PUSH
26095: LD_INT 120
26097: PUSH
26098: LD_INT 70
26100: PUSH
26101: EMPTY
26102: LIST
26103: LIST
26104: LIST
26105: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher , ar_mortar ] then
26106: LD_VAR 0 6
26110: PPUSH
26111: CALL_OW 264
26115: PUSH
26116: LD_INT 7
26118: PUSH
26119: LD_INT 28
26121: PUSH
26122: LD_INT 45
26124: PUSH
26125: LD_EXP 161
26129: PUSH
26130: EMPTY
26131: LIST
26132: LIST
26133: LIST
26134: LIST
26135: IN
26136: IFFALSE 26157
// points := [ 35 , 20 , 45 ] ;
26138: LD_ADDR_VAR 0 9
26142: PUSH
26143: LD_INT 35
26145: PUSH
26146: LD_INT 20
26148: PUSH
26149: LD_INT 45
26151: PUSH
26152: EMPTY
26153: LIST
26154: LIST
26155: LIST
26156: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
26157: LD_VAR 0 6
26161: PPUSH
26162: CALL_OW 264
26166: PUSH
26167: LD_INT 47
26169: PUSH
26170: EMPTY
26171: LIST
26172: IN
26173: IFFALSE 26194
// points := [ 67 , 45 , 75 ] ;
26175: LD_ADDR_VAR 0 9
26179: PUSH
26180: LD_INT 67
26182: PUSH
26183: LD_INT 45
26185: PUSH
26186: LD_INT 75
26188: PUSH
26189: EMPTY
26190: LIST
26191: LIST
26192: LIST
26193: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
26194: LD_VAR 0 6
26198: PPUSH
26199: CALL_OW 264
26203: PUSH
26204: LD_INT 26
26206: PUSH
26207: EMPTY
26208: LIST
26209: IN
26210: IFFALSE 26231
// points := [ 120 , 30 , 80 ] ;
26212: LD_ADDR_VAR 0 9
26216: PUSH
26217: LD_INT 120
26219: PUSH
26220: LD_INT 30
26222: PUSH
26223: LD_INT 80
26225: PUSH
26226: EMPTY
26227: LIST
26228: LIST
26229: LIST
26230: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
26231: LD_VAR 0 6
26235: PPUSH
26236: CALL_OW 264
26240: PUSH
26241: LD_INT 22
26243: PUSH
26244: EMPTY
26245: LIST
26246: IN
26247: IFFALSE 26268
// points := [ 40 , 1 , 1 ] ;
26249: LD_ADDR_VAR 0 9
26253: PUSH
26254: LD_INT 40
26256: PUSH
26257: LD_INT 1
26259: PUSH
26260: LD_INT 1
26262: PUSH
26263: EMPTY
26264: LIST
26265: LIST
26266: LIST
26267: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
26268: LD_VAR 0 6
26272: PPUSH
26273: CALL_OW 264
26277: PUSH
26278: LD_INT 29
26280: PUSH
26281: EMPTY
26282: LIST
26283: IN
26284: IFFALSE 26305
// points := [ 70 , 200 , 400 ] ;
26286: LD_ADDR_VAR 0 9
26290: PUSH
26291: LD_INT 70
26293: PUSH
26294: LD_INT 200
26296: PUSH
26297: LD_INT 400
26299: PUSH
26300: EMPTY
26301: LIST
26302: LIST
26303: LIST
26304: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
26305: LD_VAR 0 6
26309: PPUSH
26310: CALL_OW 264
26314: PUSH
26315: LD_INT 14
26317: PUSH
26318: LD_INT 53
26320: PUSH
26321: EMPTY
26322: LIST
26323: LIST
26324: IN
26325: IFFALSE 26346
// points := [ 40 , 10 , 20 ] ;
26327: LD_ADDR_VAR 0 9
26331: PUSH
26332: LD_INT 40
26334: PUSH
26335: LD_INT 10
26337: PUSH
26338: LD_INT 20
26340: PUSH
26341: EMPTY
26342: LIST
26343: LIST
26344: LIST
26345: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
26346: LD_VAR 0 6
26350: PPUSH
26351: CALL_OW 264
26355: PUSH
26356: LD_INT 9
26358: PUSH
26359: EMPTY
26360: LIST
26361: IN
26362: IFFALSE 26383
// points := [ 5 , 70 , 20 ] ;
26364: LD_ADDR_VAR 0 9
26368: PUSH
26369: LD_INT 5
26371: PUSH
26372: LD_INT 70
26374: PUSH
26375: LD_INT 20
26377: PUSH
26378: EMPTY
26379: LIST
26380: LIST
26381: LIST
26382: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
26383: LD_VAR 0 6
26387: PPUSH
26388: CALL_OW 264
26392: PUSH
26393: LD_INT 10
26395: PUSH
26396: EMPTY
26397: LIST
26398: IN
26399: IFFALSE 26420
// points := [ 35 , 110 , 70 ] ;
26401: LD_ADDR_VAR 0 9
26405: PUSH
26406: LD_INT 35
26408: PUSH
26409: LD_INT 110
26411: PUSH
26412: LD_INT 70
26414: PUSH
26415: EMPTY
26416: LIST
26417: LIST
26418: LIST
26419: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
26420: LD_VAR 0 6
26424: PPUSH
26425: CALL_OW 265
26429: PUSH
26430: LD_INT 25
26432: EQUAL
26433: IFFALSE 26454
// points := [ 80 , 65 , 100 ] ;
26435: LD_ADDR_VAR 0 9
26439: PUSH
26440: LD_INT 80
26442: PUSH
26443: LD_INT 65
26445: PUSH
26446: LD_INT 100
26448: PUSH
26449: EMPTY
26450: LIST
26451: LIST
26452: LIST
26453: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
26454: LD_VAR 0 6
26458: PPUSH
26459: CALL_OW 263
26463: PUSH
26464: LD_INT 1
26466: EQUAL
26467: IFFALSE 26502
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
26469: LD_ADDR_VAR 0 10
26473: PUSH
26474: LD_VAR 0 10
26478: PUSH
26479: LD_VAR 0 6
26483: PPUSH
26484: CALL_OW 311
26488: PPUSH
26489: LD_INT 3
26491: PPUSH
26492: CALL_OW 259
26496: PUSH
26497: LD_INT 4
26499: MUL
26500: MUL
26501: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
26502: LD_VAR 0 6
26506: PPUSH
26507: CALL_OW 263
26511: PUSH
26512: LD_INT 2
26514: EQUAL
26515: IFFALSE 26566
// begin j := IsControledBy ( i ) ;
26517: LD_ADDR_VAR 0 7
26521: PUSH
26522: LD_VAR 0 6
26526: PPUSH
26527: CALL_OW 312
26531: ST_TO_ADDR
// if j then
26532: LD_VAR 0 7
26536: IFFALSE 26566
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
26538: LD_ADDR_VAR 0 10
26542: PUSH
26543: LD_VAR 0 10
26547: PUSH
26548: LD_VAR 0 7
26552: PPUSH
26553: LD_INT 3
26555: PPUSH
26556: CALL_OW 259
26560: PUSH
26561: LD_INT 3
26563: MUL
26564: MUL
26565: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
26566: LD_VAR 0 6
26570: PPUSH
26571: CALL_OW 264
26575: PUSH
26576: LD_INT 5
26578: PUSH
26579: LD_INT 6
26581: PUSH
26582: LD_INT 46
26584: PUSH
26585: LD_INT 44
26587: PUSH
26588: LD_INT 47
26590: PUSH
26591: LD_INT 45
26593: PUSH
26594: LD_INT 28
26596: PUSH
26597: LD_INT 7
26599: PUSH
26600: LD_INT 27
26602: PUSH
26603: LD_INT 29
26605: PUSH
26606: EMPTY
26607: LIST
26608: LIST
26609: LIST
26610: LIST
26611: LIST
26612: LIST
26613: LIST
26614: LIST
26615: LIST
26616: LIST
26617: IN
26618: PUSH
26619: LD_VAR 0 1
26623: PPUSH
26624: LD_INT 52
26626: PPUSH
26627: CALL_OW 321
26631: PUSH
26632: LD_INT 2
26634: EQUAL
26635: AND
26636: IFFALSE 26653
// bpoints := bpoints * 1.2 ;
26638: LD_ADDR_VAR 0 10
26642: PUSH
26643: LD_VAR 0 10
26647: PUSH
26648: LD_REAL  1.20000000000000E+0000
26651: MUL
26652: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
26653: LD_VAR 0 6
26657: PPUSH
26658: CALL_OW 264
26662: PUSH
26663: LD_INT 6
26665: PUSH
26666: LD_INT 46
26668: PUSH
26669: LD_INT 47
26671: PUSH
26672: EMPTY
26673: LIST
26674: LIST
26675: LIST
26676: IN
26677: IFFALSE 26694
// bpoints := bpoints * 1.2 ;
26679: LD_ADDR_VAR 0 10
26683: PUSH
26684: LD_VAR 0 10
26688: PUSH
26689: LD_REAL  1.20000000000000E+0000
26692: MUL
26693: ST_TO_ADDR
// end ; unit_building :
26694: GO 26708
26696: LD_INT 3
26698: DOUBLE
26699: EQUAL
26700: IFTRUE 26704
26702: GO 26707
26704: POP
// ; end ;
26705: GO 26708
26707: POP
// for j = 1 to 3 do
26708: LD_ADDR_VAR 0 7
26712: PUSH
26713: DOUBLE
26714: LD_INT 1
26716: DEC
26717: ST_TO_ADDR
26718: LD_INT 3
26720: PUSH
26721: FOR_TO
26722: IFFALSE 26775
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
26724: LD_ADDR_VAR 0 5
26728: PUSH
26729: LD_VAR 0 5
26733: PPUSH
26734: LD_VAR 0 7
26738: PPUSH
26739: LD_VAR 0 5
26743: PUSH
26744: LD_VAR 0 7
26748: ARRAY
26749: PUSH
26750: LD_VAR 0 9
26754: PUSH
26755: LD_VAR 0 7
26759: ARRAY
26760: PUSH
26761: LD_VAR 0 10
26765: MUL
26766: PLUS
26767: PPUSH
26768: CALL_OW 1
26772: ST_TO_ADDR
26773: GO 26721
26775: POP
26776: POP
// end ;
26777: GO 25254
26779: POP
26780: POP
// result := Replace ( result , 4 , tmp ) ;
26781: LD_ADDR_VAR 0 5
26785: PUSH
26786: LD_VAR 0 5
26790: PPUSH
26791: LD_INT 4
26793: PPUSH
26794: LD_VAR 0 8
26798: PPUSH
26799: CALL_OW 1
26803: ST_TO_ADDR
// end ;
26804: LD_VAR 0 5
26808: RET
// export function DangerAtRange ( unit , range ) ; begin
26809: LD_INT 0
26811: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
26812: LD_ADDR_VAR 0 3
26816: PUSH
26817: LD_VAR 0 1
26821: PPUSH
26822: CALL_OW 255
26826: PPUSH
26827: LD_VAR 0 1
26831: PPUSH
26832: CALL_OW 250
26836: PPUSH
26837: LD_VAR 0 1
26841: PPUSH
26842: CALL_OW 251
26846: PPUSH
26847: LD_VAR 0 2
26851: PPUSH
26852: CALL 25106 0 4
26856: ST_TO_ADDR
// end ;
26857: LD_VAR 0 3
26861: RET
// export function DangerInArea ( side , area ) ; begin
26862: LD_INT 0
26864: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
26865: LD_ADDR_VAR 0 3
26869: PUSH
26870: LD_VAR 0 2
26874: PPUSH
26875: LD_INT 81
26877: PUSH
26878: LD_VAR 0 1
26882: PUSH
26883: EMPTY
26884: LIST
26885: LIST
26886: PPUSH
26887: CALL_OW 70
26891: ST_TO_ADDR
// end ;
26892: LD_VAR 0 3
26896: RET
// export function IsExtension ( b ) ; begin
26897: LD_INT 0
26899: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
26900: LD_ADDR_VAR 0 2
26904: PUSH
26905: LD_VAR 0 1
26909: PUSH
26910: LD_INT 23
26912: PUSH
26913: LD_INT 20
26915: PUSH
26916: LD_INT 22
26918: PUSH
26919: LD_INT 17
26921: PUSH
26922: LD_INT 24
26924: PUSH
26925: LD_INT 21
26927: PUSH
26928: LD_INT 19
26930: PUSH
26931: LD_INT 16
26933: PUSH
26934: LD_INT 25
26936: PUSH
26937: LD_INT 18
26939: PUSH
26940: EMPTY
26941: LIST
26942: LIST
26943: LIST
26944: LIST
26945: LIST
26946: LIST
26947: LIST
26948: LIST
26949: LIST
26950: LIST
26951: IN
26952: ST_TO_ADDR
// end ;
26953: LD_VAR 0 2
26957: RET
// export function GetBaseBuildings ( base , area , checkLink ) ; var tmp , i ; begin
26958: LD_INT 0
26960: PPUSH
26961: PPUSH
26962: PPUSH
// result := [ ] ;
26963: LD_ADDR_VAR 0 4
26967: PUSH
26968: EMPTY
26969: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
26970: LD_ADDR_VAR 0 5
26974: PUSH
26975: LD_VAR 0 2
26979: PPUSH
26980: LD_INT 21
26982: PUSH
26983: LD_INT 3
26985: PUSH
26986: EMPTY
26987: LIST
26988: LIST
26989: PPUSH
26990: CALL_OW 70
26994: ST_TO_ADDR
// if not tmp then
26995: LD_VAR 0 5
26999: NOT
27000: IFFALSE 27004
// exit ;
27002: GO 27068
// if checkLink then
27004: LD_VAR 0 3
27008: IFFALSE 27058
// begin for i in tmp do
27010: LD_ADDR_VAR 0 6
27014: PUSH
27015: LD_VAR 0 5
27019: PUSH
27020: FOR_IN
27021: IFFALSE 27056
// if GetBase ( i ) <> base then
27023: LD_VAR 0 6
27027: PPUSH
27028: CALL_OW 274
27032: PUSH
27033: LD_VAR 0 1
27037: NONEQUAL
27038: IFFALSE 27054
// ComLinkToBase ( base , i ) ;
27040: LD_VAR 0 1
27044: PPUSH
27045: LD_VAR 0 6
27049: PPUSH
27050: CALL_OW 169
27054: GO 27020
27056: POP
27057: POP
// end ; result := tmp ;
27058: LD_ADDR_VAR 0 4
27062: PUSH
27063: LD_VAR 0 5
27067: ST_TO_ADDR
// end ;
27068: LD_VAR 0 4
27072: RET
// export function ComComplete ( units , b ) ; var i ; begin
27073: LD_INT 0
27075: PPUSH
27076: PPUSH
// if not units then
27077: LD_VAR 0 1
27081: NOT
27082: IFFALSE 27086
// exit ;
27084: GO 27176
// for i in units do
27086: LD_ADDR_VAR 0 4
27090: PUSH
27091: LD_VAR 0 1
27095: PUSH
27096: FOR_IN
27097: IFFALSE 27174
// if BuildingStatus ( b ) = bs_build then
27099: LD_VAR 0 2
27103: PPUSH
27104: CALL_OW 461
27108: PUSH
27109: LD_INT 1
27111: EQUAL
27112: IFFALSE 27172
// SetTaskList ( i , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
27114: LD_VAR 0 4
27118: PPUSH
27119: LD_STRING h
27121: PUSH
27122: LD_VAR 0 2
27126: PPUSH
27127: CALL_OW 250
27131: PUSH
27132: LD_VAR 0 2
27136: PPUSH
27137: CALL_OW 251
27141: PUSH
27142: LD_VAR 0 2
27146: PUSH
27147: LD_INT 0
27149: PUSH
27150: LD_INT 0
27152: PUSH
27153: LD_INT 0
27155: PUSH
27156: EMPTY
27157: LIST
27158: LIST
27159: LIST
27160: LIST
27161: LIST
27162: LIST
27163: LIST
27164: PUSH
27165: EMPTY
27166: LIST
27167: PPUSH
27168: CALL_OW 446
27172: GO 27096
27174: POP
27175: POP
// end ;
27176: LD_VAR 0 3
27180: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
27181: LD_INT 0
27183: PPUSH
27184: PPUSH
27185: PPUSH
27186: PPUSH
27187: PPUSH
27188: PPUSH
// if not vehicle or GetControl ( vehicle ) <> control_remote then
27189: LD_VAR 0 1
27193: NOT
27194: PUSH
27195: LD_VAR 0 1
27199: PPUSH
27200: CALL_OW 263
27204: PUSH
27205: LD_INT 2
27207: NONEQUAL
27208: OR
27209: IFFALSE 27213
// exit ;
27211: GO 27529
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
27213: LD_ADDR_VAR 0 6
27217: PUSH
27218: LD_INT 22
27220: PUSH
27221: LD_VAR 0 1
27225: PPUSH
27226: CALL_OW 255
27230: PUSH
27231: EMPTY
27232: LIST
27233: LIST
27234: PUSH
27235: LD_INT 2
27237: PUSH
27238: LD_INT 30
27240: PUSH
27241: LD_INT 36
27243: PUSH
27244: EMPTY
27245: LIST
27246: LIST
27247: PUSH
27248: LD_INT 34
27250: PUSH
27251: LD_INT 31
27253: PUSH
27254: EMPTY
27255: LIST
27256: LIST
27257: PUSH
27258: EMPTY
27259: LIST
27260: LIST
27261: LIST
27262: PUSH
27263: EMPTY
27264: LIST
27265: LIST
27266: PPUSH
27267: CALL_OW 69
27271: ST_TO_ADDR
// if not tmp then
27272: LD_VAR 0 6
27276: NOT
27277: IFFALSE 27281
// exit ;
27279: GO 27529
// result := [ ] ;
27281: LD_ADDR_VAR 0 2
27285: PUSH
27286: EMPTY
27287: ST_TO_ADDR
// for i in tmp do
27288: LD_ADDR_VAR 0 3
27292: PUSH
27293: LD_VAR 0 6
27297: PUSH
27298: FOR_IN
27299: IFFALSE 27370
// begin t := UnitsInside ( i ) ;
27301: LD_ADDR_VAR 0 4
27305: PUSH
27306: LD_VAR 0 3
27310: PPUSH
27311: CALL_OW 313
27315: ST_TO_ADDR
// if t then
27316: LD_VAR 0 4
27320: IFFALSE 27368
// for j in t do
27322: LD_ADDR_VAR 0 7
27326: PUSH
27327: LD_VAR 0 4
27331: PUSH
27332: FOR_IN
27333: IFFALSE 27366
// result := Replace ( result , result + 1 , j ) ;
27335: LD_ADDR_VAR 0 2
27339: PUSH
27340: LD_VAR 0 2
27344: PPUSH
27345: LD_VAR 0 2
27349: PUSH
27350: LD_INT 1
27352: PLUS
27353: PPUSH
27354: LD_VAR 0 7
27358: PPUSH
27359: CALL_OW 1
27363: ST_TO_ADDR
27364: GO 27332
27366: POP
27367: POP
// end ;
27368: GO 27298
27370: POP
27371: POP
// if not result then
27372: LD_VAR 0 2
27376: NOT
27377: IFFALSE 27381
// exit ;
27379: GO 27529
// mech := result [ 1 ] ;
27381: LD_ADDR_VAR 0 5
27385: PUSH
27386: LD_VAR 0 2
27390: PUSH
27391: LD_INT 1
27393: ARRAY
27394: ST_TO_ADDR
// if result > 1 then
27395: LD_VAR 0 2
27399: PUSH
27400: LD_INT 1
27402: GREATER
27403: IFFALSE 27515
// begin for i = 2 to result do
27405: LD_ADDR_VAR 0 3
27409: PUSH
27410: DOUBLE
27411: LD_INT 2
27413: DEC
27414: ST_TO_ADDR
27415: LD_VAR 0 2
27419: PUSH
27420: FOR_TO
27421: IFFALSE 27513
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
27423: LD_ADDR_VAR 0 4
27427: PUSH
27428: LD_VAR 0 2
27432: PUSH
27433: LD_VAR 0 3
27437: ARRAY
27438: PPUSH
27439: LD_INT 3
27441: PPUSH
27442: CALL_OW 259
27446: PUSH
27447: LD_VAR 0 2
27451: PUSH
27452: LD_VAR 0 3
27456: ARRAY
27457: PPUSH
27458: CALL_OW 432
27462: MINUS
27463: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
27464: LD_VAR 0 4
27468: PUSH
27469: LD_VAR 0 5
27473: PPUSH
27474: LD_INT 3
27476: PPUSH
27477: CALL_OW 259
27481: PUSH
27482: LD_VAR 0 5
27486: PPUSH
27487: CALL_OW 432
27491: MINUS
27492: GREATEREQUAL
27493: IFFALSE 27511
// mech := result [ i ] ;
27495: LD_ADDR_VAR 0 5
27499: PUSH
27500: LD_VAR 0 2
27504: PUSH
27505: LD_VAR 0 3
27509: ARRAY
27510: ST_TO_ADDR
// end ;
27511: GO 27420
27513: POP
27514: POP
// end ; ComLinkTo ( vehicle , mech ) ;
27515: LD_VAR 0 1
27519: PPUSH
27520: LD_VAR 0 5
27524: PPUSH
27525: CALL_OW 135
// end ;
27529: LD_VAR 0 2
27533: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
27534: LD_INT 0
27536: PPUSH
27537: PPUSH
27538: PPUSH
27539: PPUSH
27540: PPUSH
27541: PPUSH
27542: PPUSH
27543: PPUSH
27544: PPUSH
27545: PPUSH
27546: PPUSH
27547: PPUSH
27548: PPUSH
// result := [ ] ;
27549: LD_ADDR_VAR 0 7
27553: PUSH
27554: EMPTY
27555: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
27556: LD_VAR 0 1
27560: PPUSH
27561: CALL_OW 266
27565: PUSH
27566: LD_INT 0
27568: PUSH
27569: LD_INT 1
27571: PUSH
27572: EMPTY
27573: LIST
27574: LIST
27575: IN
27576: NOT
27577: IFFALSE 27581
// exit ;
27579: GO 29215
// if name then
27581: LD_VAR 0 3
27585: IFFALSE 27601
// SetBName ( base_dep , name ) ;
27587: LD_VAR 0 1
27591: PPUSH
27592: LD_VAR 0 3
27596: PPUSH
27597: CALL_OW 500
// base := GetBase ( base_dep ) ;
27601: LD_ADDR_VAR 0 15
27605: PUSH
27606: LD_VAR 0 1
27610: PPUSH
27611: CALL_OW 274
27615: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
27616: LD_ADDR_VAR 0 16
27620: PUSH
27621: LD_VAR 0 1
27625: PPUSH
27626: CALL_OW 255
27630: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
27631: LD_ADDR_VAR 0 17
27635: PUSH
27636: LD_VAR 0 1
27640: PPUSH
27641: CALL_OW 248
27645: ST_TO_ADDR
// if sources then
27646: LD_VAR 0 5
27650: IFFALSE 27697
// for i = 1 to 3 do
27652: LD_ADDR_VAR 0 8
27656: PUSH
27657: DOUBLE
27658: LD_INT 1
27660: DEC
27661: ST_TO_ADDR
27662: LD_INT 3
27664: PUSH
27665: FOR_TO
27666: IFFALSE 27695
// AddResourceType ( base , i , sources [ i ] ) ;
27668: LD_VAR 0 15
27672: PPUSH
27673: LD_VAR 0 8
27677: PPUSH
27678: LD_VAR 0 5
27682: PUSH
27683: LD_VAR 0 8
27687: ARRAY
27688: PPUSH
27689: CALL_OW 276
27693: GO 27665
27695: POP
27696: POP
// buildings := GetBaseBuildings ( base , area , true ) ;
27697: LD_ADDR_VAR 0 18
27701: PUSH
27702: LD_VAR 0 15
27706: PPUSH
27707: LD_VAR 0 2
27711: PPUSH
27712: LD_INT 1
27714: PPUSH
27715: CALL 26958 0 3
27719: ST_TO_ADDR
// InitHc ;
27720: CALL_OW 19
// InitUc ;
27724: CALL_OW 18
// uc_side := side ;
27728: LD_ADDR_OWVAR 20
27732: PUSH
27733: LD_VAR 0 16
27737: ST_TO_ADDR
// uc_nation := nation ;
27738: LD_ADDR_OWVAR 21
27742: PUSH
27743: LD_VAR 0 17
27747: ST_TO_ADDR
// if buildings then
27748: LD_VAR 0 18
27752: IFFALSE 29074
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
27754: LD_ADDR_VAR 0 19
27758: PUSH
27759: LD_VAR 0 18
27763: PPUSH
27764: LD_INT 2
27766: PUSH
27767: LD_INT 30
27769: PUSH
27770: LD_INT 29
27772: PUSH
27773: EMPTY
27774: LIST
27775: LIST
27776: PUSH
27777: LD_INT 30
27779: PUSH
27780: LD_INT 30
27782: PUSH
27783: EMPTY
27784: LIST
27785: LIST
27786: PUSH
27787: EMPTY
27788: LIST
27789: LIST
27790: LIST
27791: PPUSH
27792: CALL_OW 72
27796: ST_TO_ADDR
// if tmp then
27797: LD_VAR 0 19
27801: IFFALSE 27849
// for i in tmp do
27803: LD_ADDR_VAR 0 8
27807: PUSH
27808: LD_VAR 0 19
27812: PUSH
27813: FOR_IN
27814: IFFALSE 27847
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
27816: LD_VAR 0 8
27820: PPUSH
27821: CALL_OW 250
27825: PPUSH
27826: LD_VAR 0 8
27830: PPUSH
27831: CALL_OW 251
27835: PPUSH
27836: LD_VAR 0 16
27840: PPUSH
27841: CALL_OW 441
27845: GO 27813
27847: POP
27848: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
27849: LD_VAR 0 18
27853: PPUSH
27854: LD_INT 2
27856: PUSH
27857: LD_INT 30
27859: PUSH
27860: LD_INT 32
27862: PUSH
27863: EMPTY
27864: LIST
27865: LIST
27866: PUSH
27867: LD_INT 30
27869: PUSH
27870: LD_INT 33
27872: PUSH
27873: EMPTY
27874: LIST
27875: LIST
27876: PUSH
27877: EMPTY
27878: LIST
27879: LIST
27880: LIST
27881: PPUSH
27882: CALL_OW 72
27886: IFFALSE 27974
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
27888: LD_ADDR_VAR 0 8
27892: PUSH
27893: LD_VAR 0 18
27897: PPUSH
27898: LD_INT 2
27900: PUSH
27901: LD_INT 30
27903: PUSH
27904: LD_INT 32
27906: PUSH
27907: EMPTY
27908: LIST
27909: LIST
27910: PUSH
27911: LD_INT 30
27913: PUSH
27914: LD_INT 33
27916: PUSH
27917: EMPTY
27918: LIST
27919: LIST
27920: PUSH
27921: EMPTY
27922: LIST
27923: LIST
27924: LIST
27925: PPUSH
27926: CALL_OW 72
27930: PUSH
27931: FOR_IN
27932: IFFALSE 27972
// begin if not GetBWeapon ( i ) then
27934: LD_VAR 0 8
27938: PPUSH
27939: CALL_OW 269
27943: NOT
27944: IFFALSE 27970
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
27946: LD_VAR 0 8
27950: PPUSH
27951: LD_VAR 0 8
27955: PPUSH
27956: LD_VAR 0 2
27960: PPUSH
27961: CALL 29220 0 2
27965: PPUSH
27966: CALL_OW 431
// end ;
27970: GO 27931
27972: POP
27973: POP
// end ; for i = 1 to personel do
27974: LD_ADDR_VAR 0 8
27978: PUSH
27979: DOUBLE
27980: LD_INT 1
27982: DEC
27983: ST_TO_ADDR
27984: LD_VAR 0 6
27988: PUSH
27989: FOR_TO
27990: IFFALSE 29054
// begin if i > 4 then
27992: LD_VAR 0 8
27996: PUSH
27997: LD_INT 4
27999: GREATER
28000: IFFALSE 28004
// break ;
28002: GO 29054
// case i of 1 :
28004: LD_VAR 0 8
28008: PUSH
28009: LD_INT 1
28011: DOUBLE
28012: EQUAL
28013: IFTRUE 28017
28015: GO 28097
28017: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
28018: LD_ADDR_VAR 0 12
28022: PUSH
28023: LD_VAR 0 18
28027: PPUSH
28028: LD_INT 22
28030: PUSH
28031: LD_VAR 0 16
28035: PUSH
28036: EMPTY
28037: LIST
28038: LIST
28039: PUSH
28040: LD_INT 58
28042: PUSH
28043: EMPTY
28044: LIST
28045: PUSH
28046: LD_INT 2
28048: PUSH
28049: LD_INT 30
28051: PUSH
28052: LD_INT 32
28054: PUSH
28055: EMPTY
28056: LIST
28057: LIST
28058: PUSH
28059: LD_INT 30
28061: PUSH
28062: LD_INT 4
28064: PUSH
28065: EMPTY
28066: LIST
28067: LIST
28068: PUSH
28069: LD_INT 30
28071: PUSH
28072: LD_INT 5
28074: PUSH
28075: EMPTY
28076: LIST
28077: LIST
28078: PUSH
28079: EMPTY
28080: LIST
28081: LIST
28082: LIST
28083: LIST
28084: PUSH
28085: EMPTY
28086: LIST
28087: LIST
28088: LIST
28089: PPUSH
28090: CALL_OW 72
28094: ST_TO_ADDR
28095: GO 28319
28097: LD_INT 2
28099: DOUBLE
28100: EQUAL
28101: IFTRUE 28105
28103: GO 28167
28105: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
28106: LD_ADDR_VAR 0 12
28110: PUSH
28111: LD_VAR 0 18
28115: PPUSH
28116: LD_INT 22
28118: PUSH
28119: LD_VAR 0 16
28123: PUSH
28124: EMPTY
28125: LIST
28126: LIST
28127: PUSH
28128: LD_INT 2
28130: PUSH
28131: LD_INT 30
28133: PUSH
28134: LD_INT 0
28136: PUSH
28137: EMPTY
28138: LIST
28139: LIST
28140: PUSH
28141: LD_INT 30
28143: PUSH
28144: LD_INT 1
28146: PUSH
28147: EMPTY
28148: LIST
28149: LIST
28150: PUSH
28151: EMPTY
28152: LIST
28153: LIST
28154: LIST
28155: PUSH
28156: EMPTY
28157: LIST
28158: LIST
28159: PPUSH
28160: CALL_OW 72
28164: ST_TO_ADDR
28165: GO 28319
28167: LD_INT 3
28169: DOUBLE
28170: EQUAL
28171: IFTRUE 28175
28173: GO 28237
28175: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
28176: LD_ADDR_VAR 0 12
28180: PUSH
28181: LD_VAR 0 18
28185: PPUSH
28186: LD_INT 22
28188: PUSH
28189: LD_VAR 0 16
28193: PUSH
28194: EMPTY
28195: LIST
28196: LIST
28197: PUSH
28198: LD_INT 2
28200: PUSH
28201: LD_INT 30
28203: PUSH
28204: LD_INT 2
28206: PUSH
28207: EMPTY
28208: LIST
28209: LIST
28210: PUSH
28211: LD_INT 30
28213: PUSH
28214: LD_INT 3
28216: PUSH
28217: EMPTY
28218: LIST
28219: LIST
28220: PUSH
28221: EMPTY
28222: LIST
28223: LIST
28224: LIST
28225: PUSH
28226: EMPTY
28227: LIST
28228: LIST
28229: PPUSH
28230: CALL_OW 72
28234: ST_TO_ADDR
28235: GO 28319
28237: LD_INT 4
28239: DOUBLE
28240: EQUAL
28241: IFTRUE 28245
28243: GO 28318
28245: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
28246: LD_ADDR_VAR 0 12
28250: PUSH
28251: LD_VAR 0 18
28255: PPUSH
28256: LD_INT 22
28258: PUSH
28259: LD_VAR 0 16
28263: PUSH
28264: EMPTY
28265: LIST
28266: LIST
28267: PUSH
28268: LD_INT 2
28270: PUSH
28271: LD_INT 30
28273: PUSH
28274: LD_INT 6
28276: PUSH
28277: EMPTY
28278: LIST
28279: LIST
28280: PUSH
28281: LD_INT 30
28283: PUSH
28284: LD_INT 7
28286: PUSH
28287: EMPTY
28288: LIST
28289: LIST
28290: PUSH
28291: LD_INT 30
28293: PUSH
28294: LD_INT 8
28296: PUSH
28297: EMPTY
28298: LIST
28299: LIST
28300: PUSH
28301: EMPTY
28302: LIST
28303: LIST
28304: LIST
28305: LIST
28306: PUSH
28307: EMPTY
28308: LIST
28309: LIST
28310: PPUSH
28311: CALL_OW 72
28315: ST_TO_ADDR
28316: GO 28319
28318: POP
// if i = 1 then
28319: LD_VAR 0 8
28323: PUSH
28324: LD_INT 1
28326: EQUAL
28327: IFFALSE 28438
// begin tmp := [ ] ;
28329: LD_ADDR_VAR 0 19
28333: PUSH
28334: EMPTY
28335: ST_TO_ADDR
// for j in f do
28336: LD_ADDR_VAR 0 9
28340: PUSH
28341: LD_VAR 0 12
28345: PUSH
28346: FOR_IN
28347: IFFALSE 28420
// if GetBType ( j ) = b_bunker then
28349: LD_VAR 0 9
28353: PPUSH
28354: CALL_OW 266
28358: PUSH
28359: LD_INT 32
28361: EQUAL
28362: IFFALSE 28389
// tmp := Insert ( tmp , 1 , j ) else
28364: LD_ADDR_VAR 0 19
28368: PUSH
28369: LD_VAR 0 19
28373: PPUSH
28374: LD_INT 1
28376: PPUSH
28377: LD_VAR 0 9
28381: PPUSH
28382: CALL_OW 2
28386: ST_TO_ADDR
28387: GO 28418
// tmp := Insert ( tmp , tmp + 1 , j ) ;
28389: LD_ADDR_VAR 0 19
28393: PUSH
28394: LD_VAR 0 19
28398: PPUSH
28399: LD_VAR 0 19
28403: PUSH
28404: LD_INT 1
28406: PLUS
28407: PPUSH
28408: LD_VAR 0 9
28412: PPUSH
28413: CALL_OW 2
28417: ST_TO_ADDR
28418: GO 28346
28420: POP
28421: POP
// if tmp then
28422: LD_VAR 0 19
28426: IFFALSE 28438
// f := tmp ;
28428: LD_ADDR_VAR 0 12
28432: PUSH
28433: LD_VAR 0 19
28437: ST_TO_ADDR
// end ; x := personel [ i ] ;
28438: LD_ADDR_VAR 0 13
28442: PUSH
28443: LD_VAR 0 6
28447: PUSH
28448: LD_VAR 0 8
28452: ARRAY
28453: ST_TO_ADDR
// if x = - 1 then
28454: LD_VAR 0 13
28458: PUSH
28459: LD_INT 1
28461: NEG
28462: EQUAL
28463: IFFALSE 28672
// begin for j in f do
28465: LD_ADDR_VAR 0 9
28469: PUSH
28470: LD_VAR 0 12
28474: PUSH
28475: FOR_IN
28476: IFFALSE 28668
// repeat InitHc ;
28478: CALL_OW 19
// if GetBType ( j ) = b_barracks then
28482: LD_VAR 0 9
28486: PPUSH
28487: CALL_OW 266
28491: PUSH
28492: LD_INT 5
28494: EQUAL
28495: IFFALSE 28565
// begin if UnitsInside ( j ) < 3 then
28497: LD_VAR 0 9
28501: PPUSH
28502: CALL_OW 313
28506: PUSH
28507: LD_INT 3
28509: LESS
28510: IFFALSE 28546
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
28512: LD_INT 0
28514: PPUSH
28515: LD_INT 5
28517: PUSH
28518: LD_INT 8
28520: PUSH
28521: LD_INT 9
28523: PUSH
28524: EMPTY
28525: LIST
28526: LIST
28527: LIST
28528: PUSH
28529: LD_VAR 0 17
28533: ARRAY
28534: PPUSH
28535: LD_VAR 0 4
28539: PPUSH
28540: CALL_OW 380
28544: GO 28563
// PrepareHuman ( false , i , skill ) ;
28546: LD_INT 0
28548: PPUSH
28549: LD_VAR 0 8
28553: PPUSH
28554: LD_VAR 0 4
28558: PPUSH
28559: CALL_OW 380
// end else
28563: GO 28582
// PrepareHuman ( false , i , skill ) ;
28565: LD_INT 0
28567: PPUSH
28568: LD_VAR 0 8
28572: PPUSH
28573: LD_VAR 0 4
28577: PPUSH
28578: CALL_OW 380
// un := CreateHuman ;
28582: LD_ADDR_VAR 0 14
28586: PUSH
28587: CALL_OW 44
28591: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
28592: LD_ADDR_VAR 0 7
28596: PUSH
28597: LD_VAR 0 7
28601: PPUSH
28602: LD_INT 1
28604: PPUSH
28605: LD_VAR 0 14
28609: PPUSH
28610: CALL_OW 2
28614: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
28615: LD_VAR 0 14
28619: PPUSH
28620: LD_VAR 0 9
28624: PPUSH
28625: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
28629: LD_VAR 0 9
28633: PPUSH
28634: CALL_OW 313
28638: PUSH
28639: LD_INT 6
28641: EQUAL
28642: PUSH
28643: LD_VAR 0 9
28647: PPUSH
28648: CALL_OW 266
28652: PUSH
28653: LD_INT 32
28655: PUSH
28656: LD_INT 31
28658: PUSH
28659: EMPTY
28660: LIST
28661: LIST
28662: IN
28663: OR
28664: IFFALSE 28478
28666: GO 28475
28668: POP
28669: POP
// end else
28670: GO 29052
// for j = 1 to x do
28672: LD_ADDR_VAR 0 9
28676: PUSH
28677: DOUBLE
28678: LD_INT 1
28680: DEC
28681: ST_TO_ADDR
28682: LD_VAR 0 13
28686: PUSH
28687: FOR_TO
28688: IFFALSE 29050
// begin InitHc ;
28690: CALL_OW 19
// if not f then
28694: LD_VAR 0 12
28698: NOT
28699: IFFALSE 28788
// begin PrepareHuman ( false , i , skill ) ;
28701: LD_INT 0
28703: PPUSH
28704: LD_VAR 0 8
28708: PPUSH
28709: LD_VAR 0 4
28713: PPUSH
28714: CALL_OW 380
// un := CreateHuman ;
28718: LD_ADDR_VAR 0 14
28722: PUSH
28723: CALL_OW 44
28727: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
28728: LD_ADDR_VAR 0 7
28732: PUSH
28733: LD_VAR 0 7
28737: PPUSH
28738: LD_INT 1
28740: PPUSH
28741: LD_VAR 0 14
28745: PPUSH
28746: CALL_OW 2
28750: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
28751: LD_VAR 0 14
28755: PPUSH
28756: LD_VAR 0 1
28760: PPUSH
28761: CALL_OW 250
28765: PPUSH
28766: LD_VAR 0 1
28770: PPUSH
28771: CALL_OW 251
28775: PPUSH
28776: LD_INT 10
28778: PPUSH
28779: LD_INT 0
28781: PPUSH
28782: CALL_OW 50
// continue ;
28786: GO 28687
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
28788: LD_VAR 0 12
28792: PUSH
28793: LD_INT 1
28795: ARRAY
28796: PPUSH
28797: CALL_OW 313
28801: PUSH
28802: LD_VAR 0 12
28806: PUSH
28807: LD_INT 1
28809: ARRAY
28810: PPUSH
28811: CALL_OW 266
28815: PUSH
28816: LD_INT 32
28818: PUSH
28819: LD_INT 31
28821: PUSH
28822: EMPTY
28823: LIST
28824: LIST
28825: IN
28826: AND
28827: PUSH
28828: LD_VAR 0 12
28832: PUSH
28833: LD_INT 1
28835: ARRAY
28836: PPUSH
28837: CALL_OW 313
28841: PUSH
28842: LD_INT 6
28844: EQUAL
28845: OR
28846: IFFALSE 28866
// f := Delete ( f , 1 ) ;
28848: LD_ADDR_VAR 0 12
28852: PUSH
28853: LD_VAR 0 12
28857: PPUSH
28858: LD_INT 1
28860: PPUSH
28861: CALL_OW 3
28865: ST_TO_ADDR
// if not f then
28866: LD_VAR 0 12
28870: NOT
28871: IFFALSE 28889
// begin x := x + 2 ;
28873: LD_ADDR_VAR 0 13
28877: PUSH
28878: LD_VAR 0 13
28882: PUSH
28883: LD_INT 2
28885: PLUS
28886: ST_TO_ADDR
// continue ;
28887: GO 28687
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
28889: LD_VAR 0 12
28893: PUSH
28894: LD_INT 1
28896: ARRAY
28897: PPUSH
28898: CALL_OW 266
28902: PUSH
28903: LD_INT 5
28905: EQUAL
28906: IFFALSE 28980
// begin if UnitsInside ( f [ 1 ] ) < 3 then
28908: LD_VAR 0 12
28912: PUSH
28913: LD_INT 1
28915: ARRAY
28916: PPUSH
28917: CALL_OW 313
28921: PUSH
28922: LD_INT 3
28924: LESS
28925: IFFALSE 28961
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
28927: LD_INT 0
28929: PPUSH
28930: LD_INT 5
28932: PUSH
28933: LD_INT 8
28935: PUSH
28936: LD_INT 9
28938: PUSH
28939: EMPTY
28940: LIST
28941: LIST
28942: LIST
28943: PUSH
28944: LD_VAR 0 17
28948: ARRAY
28949: PPUSH
28950: LD_VAR 0 4
28954: PPUSH
28955: CALL_OW 380
28959: GO 28978
// PrepareHuman ( false , i , skill ) ;
28961: LD_INT 0
28963: PPUSH
28964: LD_VAR 0 8
28968: PPUSH
28969: LD_VAR 0 4
28973: PPUSH
28974: CALL_OW 380
// end else
28978: GO 28997
// PrepareHuman ( false , i , skill ) ;
28980: LD_INT 0
28982: PPUSH
28983: LD_VAR 0 8
28987: PPUSH
28988: LD_VAR 0 4
28992: PPUSH
28993: CALL_OW 380
// un := CreateHuman ;
28997: LD_ADDR_VAR 0 14
29001: PUSH
29002: CALL_OW 44
29006: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
29007: LD_ADDR_VAR 0 7
29011: PUSH
29012: LD_VAR 0 7
29016: PPUSH
29017: LD_INT 1
29019: PPUSH
29020: LD_VAR 0 14
29024: PPUSH
29025: CALL_OW 2
29029: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
29030: LD_VAR 0 14
29034: PPUSH
29035: LD_VAR 0 12
29039: PUSH
29040: LD_INT 1
29042: ARRAY
29043: PPUSH
29044: CALL_OW 52
// end ;
29048: GO 28687
29050: POP
29051: POP
// end ;
29052: GO 27989
29054: POP
29055: POP
// result := result ^ buildings ;
29056: LD_ADDR_VAR 0 7
29060: PUSH
29061: LD_VAR 0 7
29065: PUSH
29066: LD_VAR 0 18
29070: ADD
29071: ST_TO_ADDR
// end else
29072: GO 29215
// begin for i = 1 to personel do
29074: LD_ADDR_VAR 0 8
29078: PUSH
29079: DOUBLE
29080: LD_INT 1
29082: DEC
29083: ST_TO_ADDR
29084: LD_VAR 0 6
29088: PUSH
29089: FOR_TO
29090: IFFALSE 29213
// begin if i > 4 then
29092: LD_VAR 0 8
29096: PUSH
29097: LD_INT 4
29099: GREATER
29100: IFFALSE 29104
// break ;
29102: GO 29213
// x := personel [ i ] ;
29104: LD_ADDR_VAR 0 13
29108: PUSH
29109: LD_VAR 0 6
29113: PUSH
29114: LD_VAR 0 8
29118: ARRAY
29119: ST_TO_ADDR
// if x = - 1 then
29120: LD_VAR 0 13
29124: PUSH
29125: LD_INT 1
29127: NEG
29128: EQUAL
29129: IFFALSE 29133
// continue ;
29131: GO 29089
// PrepareHuman ( false , i , skill ) ;
29133: LD_INT 0
29135: PPUSH
29136: LD_VAR 0 8
29140: PPUSH
29141: LD_VAR 0 4
29145: PPUSH
29146: CALL_OW 380
// un := CreateHuman ;
29150: LD_ADDR_VAR 0 14
29154: PUSH
29155: CALL_OW 44
29159: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
29160: LD_VAR 0 14
29164: PPUSH
29165: LD_VAR 0 1
29169: PPUSH
29170: CALL_OW 250
29174: PPUSH
29175: LD_VAR 0 1
29179: PPUSH
29180: CALL_OW 251
29184: PPUSH
29185: LD_INT 10
29187: PPUSH
29188: LD_INT 0
29190: PPUSH
29191: CALL_OW 50
// result := result ^ un ;
29195: LD_ADDR_VAR 0 7
29199: PUSH
29200: LD_VAR 0 7
29204: PUSH
29205: LD_VAR 0 14
29209: ADD
29210: ST_TO_ADDR
// end ;
29211: GO 29089
29213: POP
29214: POP
// end ; end ;
29215: LD_VAR 0 7
29219: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
29220: LD_INT 0
29222: PPUSH
29223: PPUSH
29224: PPUSH
29225: PPUSH
29226: PPUSH
29227: PPUSH
29228: PPUSH
29229: PPUSH
29230: PPUSH
29231: PPUSH
29232: PPUSH
29233: PPUSH
29234: PPUSH
29235: PPUSH
29236: PPUSH
29237: PPUSH
// result := false ;
29238: LD_ADDR_VAR 0 3
29242: PUSH
29243: LD_INT 0
29245: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
29246: LD_VAR 0 1
29250: NOT
29251: PUSH
29252: LD_VAR 0 1
29256: PPUSH
29257: CALL_OW 266
29261: PUSH
29262: LD_INT 32
29264: PUSH
29265: LD_INT 33
29267: PUSH
29268: EMPTY
29269: LIST
29270: LIST
29271: IN
29272: NOT
29273: OR
29274: IFFALSE 29278
// exit ;
29276: GO 30387
// nat := GetNation ( tower ) ;
29278: LD_ADDR_VAR 0 12
29282: PUSH
29283: LD_VAR 0 1
29287: PPUSH
29288: CALL_OW 248
29292: ST_TO_ADDR
// side := GetSide ( tower ) ;
29293: LD_ADDR_VAR 0 16
29297: PUSH
29298: LD_VAR 0 1
29302: PPUSH
29303: CALL_OW 255
29307: ST_TO_ADDR
// x := GetX ( tower ) ;
29308: LD_ADDR_VAR 0 10
29312: PUSH
29313: LD_VAR 0 1
29317: PPUSH
29318: CALL_OW 250
29322: ST_TO_ADDR
// y := GetY ( tower ) ;
29323: LD_ADDR_VAR 0 11
29327: PUSH
29328: LD_VAR 0 1
29332: PPUSH
29333: CALL_OW 251
29337: ST_TO_ADDR
// if not x or not y then
29338: LD_VAR 0 10
29342: NOT
29343: PUSH
29344: LD_VAR 0 11
29348: NOT
29349: OR
29350: IFFALSE 29354
// exit ;
29352: GO 30387
// weapon := 0 ;
29354: LD_ADDR_VAR 0 18
29358: PUSH
29359: LD_INT 0
29361: ST_TO_ADDR
// fac_list := [ ] ;
29362: LD_ADDR_VAR 0 17
29366: PUSH
29367: EMPTY
29368: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area , false ) , [ f_btype , b_factory ] ) ;
29369: LD_ADDR_VAR 0 6
29373: PUSH
29374: LD_VAR 0 1
29378: PPUSH
29379: CALL_OW 274
29383: PPUSH
29384: LD_VAR 0 2
29388: PPUSH
29389: LD_INT 0
29391: PPUSH
29392: CALL 26958 0 3
29396: PPUSH
29397: LD_INT 30
29399: PUSH
29400: LD_INT 3
29402: PUSH
29403: EMPTY
29404: LIST
29405: LIST
29406: PPUSH
29407: CALL_OW 72
29411: ST_TO_ADDR
// if not factories then
29412: LD_VAR 0 6
29416: NOT
29417: IFFALSE 29421
// exit ;
29419: GO 30387
// for i in factories do
29421: LD_ADDR_VAR 0 8
29425: PUSH
29426: LD_VAR 0 6
29430: PUSH
29431: FOR_IN
29432: IFFALSE 29457
// fac_list := fac_list union AvailableWeaponList ( i ) ;
29434: LD_ADDR_VAR 0 17
29438: PUSH
29439: LD_VAR 0 17
29443: PUSH
29444: LD_VAR 0 8
29448: PPUSH
29449: CALL_OW 478
29453: UNION
29454: ST_TO_ADDR
29455: GO 29431
29457: POP
29458: POP
// if not fac_list then
29459: LD_VAR 0 17
29463: NOT
29464: IFFALSE 29468
// exit ;
29466: GO 30387
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
29468: LD_ADDR_VAR 0 5
29472: PUSH
29473: LD_INT 4
29475: PUSH
29476: LD_INT 5
29478: PUSH
29479: LD_INT 9
29481: PUSH
29482: LD_INT 10
29484: PUSH
29485: LD_INT 6
29487: PUSH
29488: LD_INT 7
29490: PUSH
29491: LD_INT 11
29493: PUSH
29494: EMPTY
29495: LIST
29496: LIST
29497: LIST
29498: LIST
29499: LIST
29500: LIST
29501: LIST
29502: PUSH
29503: LD_INT 27
29505: PUSH
29506: LD_INT 28
29508: PUSH
29509: LD_INT 26
29511: PUSH
29512: LD_INT 30
29514: PUSH
29515: EMPTY
29516: LIST
29517: LIST
29518: LIST
29519: LIST
29520: PUSH
29521: LD_INT 43
29523: PUSH
29524: LD_INT 44
29526: PUSH
29527: LD_INT 46
29529: PUSH
29530: LD_INT 45
29532: PUSH
29533: LD_INT 47
29535: PUSH
29536: LD_INT 49
29538: PUSH
29539: EMPTY
29540: LIST
29541: LIST
29542: LIST
29543: LIST
29544: LIST
29545: LIST
29546: PUSH
29547: EMPTY
29548: LIST
29549: LIST
29550: LIST
29551: PUSH
29552: LD_VAR 0 12
29556: ARRAY
29557: ST_TO_ADDR
// list := list isect fac_list ;
29558: LD_ADDR_VAR 0 5
29562: PUSH
29563: LD_VAR 0 5
29567: PUSH
29568: LD_VAR 0 17
29572: ISECT
29573: ST_TO_ADDR
// if not list then
29574: LD_VAR 0 5
29578: NOT
29579: IFFALSE 29583
// exit ;
29581: GO 30387
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
29583: LD_VAR 0 12
29587: PUSH
29588: LD_INT 3
29590: EQUAL
29591: PUSH
29592: LD_INT 49
29594: PUSH
29595: LD_VAR 0 5
29599: IN
29600: AND
29601: PUSH
29602: LD_INT 31
29604: PPUSH
29605: LD_VAR 0 16
29609: PPUSH
29610: CALL_OW 321
29614: PUSH
29615: LD_INT 2
29617: EQUAL
29618: AND
29619: IFFALSE 29679
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
29621: LD_INT 22
29623: PUSH
29624: LD_VAR 0 16
29628: PUSH
29629: EMPTY
29630: LIST
29631: LIST
29632: PUSH
29633: LD_INT 35
29635: PUSH
29636: LD_INT 49
29638: PUSH
29639: EMPTY
29640: LIST
29641: LIST
29642: PUSH
29643: LD_INT 91
29645: PUSH
29646: LD_VAR 0 1
29650: PUSH
29651: LD_INT 10
29653: PUSH
29654: EMPTY
29655: LIST
29656: LIST
29657: LIST
29658: PUSH
29659: EMPTY
29660: LIST
29661: LIST
29662: LIST
29663: PPUSH
29664: CALL_OW 69
29668: NOT
29669: IFFALSE 29679
// weapon := ru_time_lapser ;
29671: LD_ADDR_VAR 0 18
29675: PUSH
29676: LD_INT 49
29678: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
29679: LD_VAR 0 12
29683: PUSH
29684: LD_INT 1
29686: PUSH
29687: LD_INT 2
29689: PUSH
29690: EMPTY
29691: LIST
29692: LIST
29693: IN
29694: PUSH
29695: LD_INT 11
29697: PUSH
29698: LD_VAR 0 5
29702: IN
29703: PUSH
29704: LD_INT 30
29706: PUSH
29707: LD_VAR 0 5
29711: IN
29712: OR
29713: AND
29714: PUSH
29715: LD_INT 6
29717: PPUSH
29718: LD_VAR 0 16
29722: PPUSH
29723: CALL_OW 321
29727: PUSH
29728: LD_INT 2
29730: EQUAL
29731: AND
29732: IFFALSE 29897
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
29734: LD_INT 22
29736: PUSH
29737: LD_VAR 0 16
29741: PUSH
29742: EMPTY
29743: LIST
29744: LIST
29745: PUSH
29746: LD_INT 2
29748: PUSH
29749: LD_INT 35
29751: PUSH
29752: LD_INT 11
29754: PUSH
29755: EMPTY
29756: LIST
29757: LIST
29758: PUSH
29759: LD_INT 35
29761: PUSH
29762: LD_INT 30
29764: PUSH
29765: EMPTY
29766: LIST
29767: LIST
29768: PUSH
29769: EMPTY
29770: LIST
29771: LIST
29772: LIST
29773: PUSH
29774: LD_INT 91
29776: PUSH
29777: LD_VAR 0 1
29781: PUSH
29782: LD_INT 18
29784: PUSH
29785: EMPTY
29786: LIST
29787: LIST
29788: LIST
29789: PUSH
29790: EMPTY
29791: LIST
29792: LIST
29793: LIST
29794: PPUSH
29795: CALL_OW 69
29799: NOT
29800: PUSH
29801: LD_INT 22
29803: PUSH
29804: LD_VAR 0 16
29808: PUSH
29809: EMPTY
29810: LIST
29811: LIST
29812: PUSH
29813: LD_INT 2
29815: PUSH
29816: LD_INT 30
29818: PUSH
29819: LD_INT 32
29821: PUSH
29822: EMPTY
29823: LIST
29824: LIST
29825: PUSH
29826: LD_INT 30
29828: PUSH
29829: LD_INT 33
29831: PUSH
29832: EMPTY
29833: LIST
29834: LIST
29835: PUSH
29836: EMPTY
29837: LIST
29838: LIST
29839: LIST
29840: PUSH
29841: LD_INT 91
29843: PUSH
29844: LD_VAR 0 1
29848: PUSH
29849: LD_INT 12
29851: PUSH
29852: EMPTY
29853: LIST
29854: LIST
29855: LIST
29856: PUSH
29857: EMPTY
29858: LIST
29859: LIST
29860: LIST
29861: PUSH
29862: EMPTY
29863: LIST
29864: PPUSH
29865: CALL_OW 69
29869: PUSH
29870: LD_INT 2
29872: GREATER
29873: AND
29874: IFFALSE 29897
// weapon := [ us_radar , ar_radar ] [ nat ] ;
29876: LD_ADDR_VAR 0 18
29880: PUSH
29881: LD_INT 11
29883: PUSH
29884: LD_INT 30
29886: PUSH
29887: EMPTY
29888: LIST
29889: LIST
29890: PUSH
29891: LD_VAR 0 12
29895: ARRAY
29896: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
29897: LD_VAR 0 18
29901: NOT
29902: PUSH
29903: LD_INT 40
29905: PPUSH
29906: LD_VAR 0 16
29910: PPUSH
29911: CALL_OW 321
29915: PUSH
29916: LD_INT 2
29918: EQUAL
29919: AND
29920: PUSH
29921: LD_INT 7
29923: PUSH
29924: LD_VAR 0 5
29928: IN
29929: PUSH
29930: LD_INT 28
29932: PUSH
29933: LD_VAR 0 5
29937: IN
29938: OR
29939: PUSH
29940: LD_INT 45
29942: PUSH
29943: LD_VAR 0 5
29947: IN
29948: OR
29949: AND
29950: IFFALSE 30204
// begin hex := GetHexInfo ( x , y ) ;
29952: LD_ADDR_VAR 0 4
29956: PUSH
29957: LD_VAR 0 10
29961: PPUSH
29962: LD_VAR 0 11
29966: PPUSH
29967: CALL_OW 546
29971: ST_TO_ADDR
// if hex [ 1 ] then
29972: LD_VAR 0 4
29976: PUSH
29977: LD_INT 1
29979: ARRAY
29980: IFFALSE 29984
// exit ;
29982: GO 30387
// height := hex [ 2 ] ;
29984: LD_ADDR_VAR 0 15
29988: PUSH
29989: LD_VAR 0 4
29993: PUSH
29994: LD_INT 2
29996: ARRAY
29997: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
29998: LD_ADDR_VAR 0 14
30002: PUSH
30003: LD_INT 0
30005: PUSH
30006: LD_INT 2
30008: PUSH
30009: LD_INT 3
30011: PUSH
30012: LD_INT 5
30014: PUSH
30015: EMPTY
30016: LIST
30017: LIST
30018: LIST
30019: LIST
30020: ST_TO_ADDR
// for i in tmp do
30021: LD_ADDR_VAR 0 8
30025: PUSH
30026: LD_VAR 0 14
30030: PUSH
30031: FOR_IN
30032: IFFALSE 30202
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
30034: LD_ADDR_VAR 0 9
30038: PUSH
30039: LD_VAR 0 10
30043: PPUSH
30044: LD_VAR 0 8
30048: PPUSH
30049: LD_INT 5
30051: PPUSH
30052: CALL_OW 272
30056: PUSH
30057: LD_VAR 0 11
30061: PPUSH
30062: LD_VAR 0 8
30066: PPUSH
30067: LD_INT 5
30069: PPUSH
30070: CALL_OW 273
30074: PUSH
30075: EMPTY
30076: LIST
30077: LIST
30078: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
30079: LD_VAR 0 9
30083: PUSH
30084: LD_INT 1
30086: ARRAY
30087: PPUSH
30088: LD_VAR 0 9
30092: PUSH
30093: LD_INT 2
30095: ARRAY
30096: PPUSH
30097: CALL_OW 488
30101: IFFALSE 30200
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
30103: LD_ADDR_VAR 0 4
30107: PUSH
30108: LD_VAR 0 9
30112: PUSH
30113: LD_INT 1
30115: ARRAY
30116: PPUSH
30117: LD_VAR 0 9
30121: PUSH
30122: LD_INT 2
30124: ARRAY
30125: PPUSH
30126: CALL_OW 546
30130: ST_TO_ADDR
// if hex [ 1 ] then
30131: LD_VAR 0 4
30135: PUSH
30136: LD_INT 1
30138: ARRAY
30139: IFFALSE 30143
// continue ;
30141: GO 30031
// h := hex [ 2 ] ;
30143: LD_ADDR_VAR 0 13
30147: PUSH
30148: LD_VAR 0 4
30152: PUSH
30153: LD_INT 2
30155: ARRAY
30156: ST_TO_ADDR
// if h + 7 < height then
30157: LD_VAR 0 13
30161: PUSH
30162: LD_INT 7
30164: PLUS
30165: PUSH
30166: LD_VAR 0 15
30170: LESS
30171: IFFALSE 30200
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
30173: LD_ADDR_VAR 0 18
30177: PUSH
30178: LD_INT 7
30180: PUSH
30181: LD_INT 28
30183: PUSH
30184: LD_INT 45
30186: PUSH
30187: EMPTY
30188: LIST
30189: LIST
30190: LIST
30191: PUSH
30192: LD_VAR 0 12
30196: ARRAY
30197: ST_TO_ADDR
// break ;
30198: GO 30202
// end ; end ; end ;
30200: GO 30031
30202: POP
30203: POP
// end ; if not weapon then
30204: LD_VAR 0 18
30208: NOT
30209: IFFALSE 30269
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
30211: LD_ADDR_VAR 0 5
30215: PUSH
30216: LD_VAR 0 5
30220: PUSH
30221: LD_INT 11
30223: PUSH
30224: LD_INT 30
30226: PUSH
30227: LD_INT 49
30229: PUSH
30230: EMPTY
30231: LIST
30232: LIST
30233: LIST
30234: DIFF
30235: ST_TO_ADDR
// if not list then
30236: LD_VAR 0 5
30240: NOT
30241: IFFALSE 30245
// exit ;
30243: GO 30387
// weapon := list [ rand ( 1 , list ) ] ;
30245: LD_ADDR_VAR 0 18
30249: PUSH
30250: LD_VAR 0 5
30254: PUSH
30255: LD_INT 1
30257: PPUSH
30258: LD_VAR 0 5
30262: PPUSH
30263: CALL_OW 12
30267: ARRAY
30268: ST_TO_ADDR
// end ; if weapon then
30269: LD_VAR 0 18
30273: IFFALSE 30387
// begin tmp := CostOfWeapon ( weapon ) ;
30275: LD_ADDR_VAR 0 14
30279: PUSH
30280: LD_VAR 0 18
30284: PPUSH
30285: CALL_OW 451
30289: ST_TO_ADDR
// j := GetBase ( tower ) ;
30290: LD_ADDR_VAR 0 9
30294: PUSH
30295: LD_VAR 0 1
30299: PPUSH
30300: CALL_OW 274
30304: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
30305: LD_VAR 0 9
30309: PPUSH
30310: LD_INT 1
30312: PPUSH
30313: CALL_OW 275
30317: PUSH
30318: LD_VAR 0 14
30322: PUSH
30323: LD_INT 1
30325: ARRAY
30326: GREATEREQUAL
30327: PUSH
30328: LD_VAR 0 9
30332: PPUSH
30333: LD_INT 2
30335: PPUSH
30336: CALL_OW 275
30340: PUSH
30341: LD_VAR 0 14
30345: PUSH
30346: LD_INT 2
30348: ARRAY
30349: GREATEREQUAL
30350: AND
30351: PUSH
30352: LD_VAR 0 9
30356: PPUSH
30357: LD_INT 3
30359: PPUSH
30360: CALL_OW 275
30364: PUSH
30365: LD_VAR 0 14
30369: PUSH
30370: LD_INT 3
30372: ARRAY
30373: GREATEREQUAL
30374: AND
30375: IFFALSE 30387
// result := weapon ;
30377: LD_ADDR_VAR 0 3
30381: PUSH
30382: LD_VAR 0 18
30386: ST_TO_ADDR
// end ; end ;
30387: LD_VAR 0 3
30391: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
30392: LD_INT 0
30394: PPUSH
30395: PPUSH
// result := true ;
30396: LD_ADDR_VAR 0 3
30400: PUSH
30401: LD_INT 1
30403: ST_TO_ADDR
// if array1 = array2 then
30404: LD_VAR 0 1
30408: PUSH
30409: LD_VAR 0 2
30413: EQUAL
30414: IFFALSE 30474
// begin for i = 1 to array1 do
30416: LD_ADDR_VAR 0 4
30420: PUSH
30421: DOUBLE
30422: LD_INT 1
30424: DEC
30425: ST_TO_ADDR
30426: LD_VAR 0 1
30430: PUSH
30431: FOR_TO
30432: IFFALSE 30470
// if array1 [ i ] <> array2 [ i ] then
30434: LD_VAR 0 1
30438: PUSH
30439: LD_VAR 0 4
30443: ARRAY
30444: PUSH
30445: LD_VAR 0 2
30449: PUSH
30450: LD_VAR 0 4
30454: ARRAY
30455: NONEQUAL
30456: IFFALSE 30468
// begin result := false ;
30458: LD_ADDR_VAR 0 3
30462: PUSH
30463: LD_INT 0
30465: ST_TO_ADDR
// break ;
30466: GO 30470
// end ;
30468: GO 30431
30470: POP
30471: POP
// end else
30472: GO 30482
// result := false ;
30474: LD_ADDR_VAR 0 3
30478: PUSH
30479: LD_INT 0
30481: ST_TO_ADDR
// end ;
30482: LD_VAR 0 3
30486: RET
// export function CompareArrayValues ( array1 , array2 ) ; var i ; begin
30487: LD_INT 0
30489: PPUSH
30490: PPUSH
// if not array1 or not array2 then
30491: LD_VAR 0 1
30495: NOT
30496: PUSH
30497: LD_VAR 0 2
30501: NOT
30502: OR
30503: IFFALSE 30507
// exit ;
30505: GO 30571
// result := true ;
30507: LD_ADDR_VAR 0 3
30511: PUSH
30512: LD_INT 1
30514: ST_TO_ADDR
// for i = 1 to array1 do
30515: LD_ADDR_VAR 0 4
30519: PUSH
30520: DOUBLE
30521: LD_INT 1
30523: DEC
30524: ST_TO_ADDR
30525: LD_VAR 0 1
30529: PUSH
30530: FOR_TO
30531: IFFALSE 30569
// if array1 [ i ] <> array2 [ i ] then
30533: LD_VAR 0 1
30537: PUSH
30538: LD_VAR 0 4
30542: ARRAY
30543: PUSH
30544: LD_VAR 0 2
30548: PUSH
30549: LD_VAR 0 4
30553: ARRAY
30554: NONEQUAL
30555: IFFALSE 30567
// begin result := false ;
30557: LD_ADDR_VAR 0 3
30561: PUSH
30562: LD_INT 0
30564: ST_TO_ADDR
// break ;
30565: GO 30569
// end ;
30567: GO 30530
30569: POP
30570: POP
// end ;
30571: LD_VAR 0 3
30575: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
30576: LD_INT 0
30578: PPUSH
30579: PPUSH
30580: PPUSH
// pom := GetBase ( fac ) ;
30581: LD_ADDR_VAR 0 5
30585: PUSH
30586: LD_VAR 0 1
30590: PPUSH
30591: CALL_OW 274
30595: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
30596: LD_ADDR_VAR 0 4
30600: PUSH
30601: LD_VAR 0 2
30605: PUSH
30606: LD_INT 1
30608: ARRAY
30609: PPUSH
30610: LD_VAR 0 2
30614: PUSH
30615: LD_INT 2
30617: ARRAY
30618: PPUSH
30619: LD_VAR 0 2
30623: PUSH
30624: LD_INT 3
30626: ARRAY
30627: PPUSH
30628: LD_VAR 0 2
30632: PUSH
30633: LD_INT 4
30635: ARRAY
30636: PPUSH
30637: CALL_OW 449
30641: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
30642: LD_ADDR_VAR 0 3
30646: PUSH
30647: LD_VAR 0 5
30651: PPUSH
30652: LD_INT 1
30654: PPUSH
30655: CALL_OW 275
30659: PUSH
30660: LD_VAR 0 4
30664: PUSH
30665: LD_INT 1
30667: ARRAY
30668: GREATEREQUAL
30669: PUSH
30670: LD_VAR 0 5
30674: PPUSH
30675: LD_INT 2
30677: PPUSH
30678: CALL_OW 275
30682: PUSH
30683: LD_VAR 0 4
30687: PUSH
30688: LD_INT 2
30690: ARRAY
30691: GREATEREQUAL
30692: AND
30693: PUSH
30694: LD_VAR 0 5
30698: PPUSH
30699: LD_INT 3
30701: PPUSH
30702: CALL_OW 275
30706: PUSH
30707: LD_VAR 0 4
30711: PUSH
30712: LD_INT 3
30714: ARRAY
30715: GREATEREQUAL
30716: AND
30717: ST_TO_ADDR
// end ;
30718: LD_VAR 0 3
30722: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
30723: LD_INT 0
30725: PPUSH
30726: PPUSH
30727: PPUSH
30728: PPUSH
// pom := GetBase ( building ) ;
30729: LD_ADDR_VAR 0 3
30733: PUSH
30734: LD_VAR 0 1
30738: PPUSH
30739: CALL_OW 274
30743: ST_TO_ADDR
// if not pom then
30744: LD_VAR 0 3
30748: NOT
30749: IFFALSE 30753
// exit ;
30751: GO 30923
// btype := GetBType ( building ) ;
30753: LD_ADDR_VAR 0 5
30757: PUSH
30758: LD_VAR 0 1
30762: PPUSH
30763: CALL_OW 266
30767: ST_TO_ADDR
// if btype = b_armoury then
30768: LD_VAR 0 5
30772: PUSH
30773: LD_INT 4
30775: EQUAL
30776: IFFALSE 30786
// btype := b_barracks ;
30778: LD_ADDR_VAR 0 5
30782: PUSH
30783: LD_INT 5
30785: ST_TO_ADDR
// if btype = b_depot then
30786: LD_VAR 0 5
30790: PUSH
30791: LD_INT 0
30793: EQUAL
30794: IFFALSE 30804
// btype := b_warehouse ;
30796: LD_ADDR_VAR 0 5
30800: PUSH
30801: LD_INT 1
30803: ST_TO_ADDR
// if btype = b_workshop then
30804: LD_VAR 0 5
30808: PUSH
30809: LD_INT 2
30811: EQUAL
30812: IFFALSE 30822
// btype := b_factory ;
30814: LD_ADDR_VAR 0 5
30818: PUSH
30819: LD_INT 3
30821: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
30822: LD_ADDR_VAR 0 4
30826: PUSH
30827: LD_VAR 0 5
30831: PPUSH
30832: LD_VAR 0 1
30836: PPUSH
30837: CALL_OW 248
30841: PPUSH
30842: CALL_OW 450
30846: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
30847: LD_ADDR_VAR 0 2
30851: PUSH
30852: LD_VAR 0 3
30856: PPUSH
30857: LD_INT 1
30859: PPUSH
30860: CALL_OW 275
30864: PUSH
30865: LD_VAR 0 4
30869: PUSH
30870: LD_INT 1
30872: ARRAY
30873: GREATEREQUAL
30874: PUSH
30875: LD_VAR 0 3
30879: PPUSH
30880: LD_INT 2
30882: PPUSH
30883: CALL_OW 275
30887: PUSH
30888: LD_VAR 0 4
30892: PUSH
30893: LD_INT 2
30895: ARRAY
30896: GREATEREQUAL
30897: AND
30898: PUSH
30899: LD_VAR 0 3
30903: PPUSH
30904: LD_INT 3
30906: PPUSH
30907: CALL_OW 275
30911: PUSH
30912: LD_VAR 0 4
30916: PUSH
30917: LD_INT 3
30919: ARRAY
30920: GREATEREQUAL
30921: AND
30922: ST_TO_ADDR
// end ;
30923: LD_VAR 0 2
30927: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
30928: LD_INT 0
30930: PPUSH
30931: PPUSH
30932: PPUSH
// pom := GetBase ( building ) ;
30933: LD_ADDR_VAR 0 4
30937: PUSH
30938: LD_VAR 0 1
30942: PPUSH
30943: CALL_OW 274
30947: ST_TO_ADDR
// if not pom then
30948: LD_VAR 0 4
30952: NOT
30953: IFFALSE 30957
// exit ;
30955: GO 31058
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
30957: LD_ADDR_VAR 0 5
30961: PUSH
30962: LD_VAR 0 2
30966: PPUSH
30967: LD_VAR 0 1
30971: PPUSH
30972: CALL_OW 248
30976: PPUSH
30977: CALL_OW 450
30981: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
30982: LD_ADDR_VAR 0 3
30986: PUSH
30987: LD_VAR 0 4
30991: PPUSH
30992: LD_INT 1
30994: PPUSH
30995: CALL_OW 275
30999: PUSH
31000: LD_VAR 0 5
31004: PUSH
31005: LD_INT 1
31007: ARRAY
31008: GREATEREQUAL
31009: PUSH
31010: LD_VAR 0 4
31014: PPUSH
31015: LD_INT 2
31017: PPUSH
31018: CALL_OW 275
31022: PUSH
31023: LD_VAR 0 5
31027: PUSH
31028: LD_INT 2
31030: ARRAY
31031: GREATEREQUAL
31032: AND
31033: PUSH
31034: LD_VAR 0 4
31038: PPUSH
31039: LD_INT 3
31041: PPUSH
31042: CALL_OW 275
31046: PUSH
31047: LD_VAR 0 5
31051: PUSH
31052: LD_INT 3
31054: ARRAY
31055: GREATEREQUAL
31056: AND
31057: ST_TO_ADDR
// end ;
31058: LD_VAR 0 3
31062: RET
// export function TryClearPlaceForBuilding ( btype , x , y , d , buildings , cleaners , parking ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep , driver ; begin
31063: LD_INT 0
31065: PPUSH
31066: PPUSH
31067: PPUSH
31068: PPUSH
31069: PPUSH
31070: PPUSH
31071: PPUSH
31072: PPUSH
31073: PPUSH
31074: PPUSH
31075: PPUSH
// result := false ;
31076: LD_ADDR_VAR 0 8
31080: PUSH
31081: LD_INT 0
31083: ST_TO_ADDR
// if not buildings or not btype or not x or not y then
31084: LD_VAR 0 5
31088: NOT
31089: PUSH
31090: LD_VAR 0 1
31094: NOT
31095: OR
31096: PUSH
31097: LD_VAR 0 2
31101: NOT
31102: OR
31103: PUSH
31104: LD_VAR 0 3
31108: NOT
31109: OR
31110: IFFALSE 31114
// exit ;
31112: GO 31928
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( buildings [ 1 ] ) , 0 ) ;
31114: LD_ADDR_VAR 0 14
31118: PUSH
31119: LD_VAR 0 1
31123: PPUSH
31124: LD_VAR 0 2
31128: PPUSH
31129: LD_VAR 0 3
31133: PPUSH
31134: LD_VAR 0 4
31138: PPUSH
31139: LD_VAR 0 5
31143: PUSH
31144: LD_INT 1
31146: ARRAY
31147: PPUSH
31148: CALL_OW 248
31152: PPUSH
31153: LD_INT 0
31155: PPUSH
31156: CALL 33165 0 6
31160: ST_TO_ADDR
// if not hexes then
31161: LD_VAR 0 14
31165: NOT
31166: IFFALSE 31170
// exit ;
31168: GO 31928
// dep := UnitFilter ( buildings , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
31170: LD_ADDR_VAR 0 17
31174: PUSH
31175: LD_VAR 0 5
31179: PPUSH
31180: LD_INT 22
31182: PUSH
31183: LD_VAR 0 13
31187: PPUSH
31188: CALL_OW 255
31192: PUSH
31193: EMPTY
31194: LIST
31195: LIST
31196: PUSH
31197: LD_INT 2
31199: PUSH
31200: LD_INT 30
31202: PUSH
31203: LD_INT 0
31205: PUSH
31206: EMPTY
31207: LIST
31208: LIST
31209: PUSH
31210: LD_INT 30
31212: PUSH
31213: LD_INT 1
31215: PUSH
31216: EMPTY
31217: LIST
31218: LIST
31219: PUSH
31220: EMPTY
31221: LIST
31222: LIST
31223: LIST
31224: PUSH
31225: EMPTY
31226: LIST
31227: LIST
31228: PPUSH
31229: CALL_OW 72
31233: ST_TO_ADDR
// for i = 1 to hexes do
31234: LD_ADDR_VAR 0 9
31238: PUSH
31239: DOUBLE
31240: LD_INT 1
31242: DEC
31243: ST_TO_ADDR
31244: LD_VAR 0 14
31248: PUSH
31249: FOR_TO
31250: IFFALSE 31926
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
31252: LD_ADDR_VAR 0 13
31256: PUSH
31257: LD_VAR 0 14
31261: PUSH
31262: LD_VAR 0 9
31266: ARRAY
31267: PUSH
31268: LD_INT 1
31270: ARRAY
31271: PPUSH
31272: LD_VAR 0 14
31276: PUSH
31277: LD_VAR 0 9
31281: ARRAY
31282: PUSH
31283: LD_INT 2
31285: ARRAY
31286: PPUSH
31287: CALL_OW 428
31291: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
31292: LD_VAR 0 14
31296: PUSH
31297: LD_VAR 0 9
31301: ARRAY
31302: PUSH
31303: LD_INT 1
31305: ARRAY
31306: PPUSH
31307: LD_VAR 0 14
31311: PUSH
31312: LD_VAR 0 9
31316: ARRAY
31317: PUSH
31318: LD_INT 2
31320: ARRAY
31321: PPUSH
31322: CALL_OW 351
31326: PUSH
31327: LD_VAR 0 14
31331: PUSH
31332: LD_VAR 0 9
31336: ARRAY
31337: PUSH
31338: LD_INT 1
31340: ARRAY
31341: PPUSH
31342: LD_VAR 0 14
31346: PUSH
31347: LD_VAR 0 9
31351: ARRAY
31352: PUSH
31353: LD_INT 2
31355: ARRAY
31356: PPUSH
31357: CALL_OW 488
31361: NOT
31362: OR
31363: PUSH
31364: LD_VAR 0 13
31368: PPUSH
31369: CALL_OW 247
31373: PUSH
31374: LD_INT 3
31376: EQUAL
31377: OR
31378: IFFALSE 31384
// exit ;
31380: POP
31381: POP
31382: GO 31928
// if not tmp then
31384: LD_VAR 0 13
31388: NOT
31389: IFFALSE 31393
// continue ;
31391: GO 31249
// result := true ;
31393: LD_ADDR_VAR 0 8
31397: PUSH
31398: LD_INT 1
31400: ST_TO_ADDR
// if cleaners and GetType ( tmp ) = unit_vehicle and GetControl ( tmp ) = control_manual then
31401: LD_VAR 0 6
31405: PUSH
31406: LD_VAR 0 13
31410: PPUSH
31411: CALL_OW 247
31415: PUSH
31416: LD_INT 2
31418: EQUAL
31419: AND
31420: PUSH
31421: LD_VAR 0 13
31425: PPUSH
31426: CALL_OW 263
31430: PUSH
31431: LD_INT 1
31433: EQUAL
31434: AND
31435: IFFALSE 31599
// begin if IsDrivenBy ( tmp ) then
31437: LD_VAR 0 13
31441: PPUSH
31442: CALL_OW 311
31446: IFFALSE 31450
// continue ;
31448: GO 31249
// if UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) then
31450: LD_VAR 0 6
31454: PPUSH
31455: LD_INT 3
31457: PUSH
31458: LD_INT 60
31460: PUSH
31461: EMPTY
31462: LIST
31463: PUSH
31464: EMPTY
31465: LIST
31466: LIST
31467: PUSH
31468: LD_INT 3
31470: PUSH
31471: LD_INT 55
31473: PUSH
31474: EMPTY
31475: LIST
31476: PUSH
31477: EMPTY
31478: LIST
31479: LIST
31480: PUSH
31481: EMPTY
31482: LIST
31483: LIST
31484: PPUSH
31485: CALL_OW 72
31489: IFFALSE 31597
// begin driver := UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) [ 1 ] ;
31491: LD_ADDR_VAR 0 18
31495: PUSH
31496: LD_VAR 0 6
31500: PPUSH
31501: LD_INT 3
31503: PUSH
31504: LD_INT 60
31506: PUSH
31507: EMPTY
31508: LIST
31509: PUSH
31510: EMPTY
31511: LIST
31512: LIST
31513: PUSH
31514: LD_INT 3
31516: PUSH
31517: LD_INT 55
31519: PUSH
31520: EMPTY
31521: LIST
31522: PUSH
31523: EMPTY
31524: LIST
31525: LIST
31526: PUSH
31527: EMPTY
31528: LIST
31529: LIST
31530: PPUSH
31531: CALL_OW 72
31535: PUSH
31536: LD_INT 1
31538: ARRAY
31539: ST_TO_ADDR
// if IsInUnit ( driver ) then
31540: LD_VAR 0 18
31544: PPUSH
31545: CALL_OW 310
31549: IFFALSE 31560
// ComExit ( driver ) ;
31551: LD_VAR 0 18
31555: PPUSH
31556: CALL 56349 0 1
// AddComEnterUnit ( driver , tmp ) ;
31560: LD_VAR 0 18
31564: PPUSH
31565: LD_VAR 0 13
31569: PPUSH
31570: CALL_OW 180
// AddComMoveToArea ( driver , parking ) ;
31574: LD_VAR 0 18
31578: PPUSH
31579: LD_VAR 0 7
31583: PPUSH
31584: CALL_OW 173
// AddComExitVehicle ( driver ) ;
31588: LD_VAR 0 18
31592: PPUSH
31593: CALL_OW 181
// end ; continue ;
31597: GO 31249
// end ; if not cleaners or not tmp in cleaners then
31599: LD_VAR 0 6
31603: NOT
31604: PUSH
31605: LD_VAR 0 13
31609: PUSH
31610: LD_VAR 0 6
31614: IN
31615: NOT
31616: OR
31617: IFFALSE 31924
// begin if dep then
31619: LD_VAR 0 17
31623: IFFALSE 31759
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
31625: LD_ADDR_VAR 0 16
31629: PUSH
31630: LD_VAR 0 17
31634: PUSH
31635: LD_INT 1
31637: ARRAY
31638: PPUSH
31639: CALL_OW 250
31643: PPUSH
31644: LD_VAR 0 17
31648: PUSH
31649: LD_INT 1
31651: ARRAY
31652: PPUSH
31653: CALL_OW 254
31657: PPUSH
31658: LD_INT 5
31660: PPUSH
31661: CALL_OW 272
31665: PUSH
31666: LD_VAR 0 17
31670: PUSH
31671: LD_INT 1
31673: ARRAY
31674: PPUSH
31675: CALL_OW 251
31679: PPUSH
31680: LD_VAR 0 17
31684: PUSH
31685: LD_INT 1
31687: ARRAY
31688: PPUSH
31689: CALL_OW 254
31693: PPUSH
31694: LD_INT 5
31696: PPUSH
31697: CALL_OW 273
31701: PUSH
31702: EMPTY
31703: LIST
31704: LIST
31705: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
31706: LD_VAR 0 16
31710: PUSH
31711: LD_INT 1
31713: ARRAY
31714: PPUSH
31715: LD_VAR 0 16
31719: PUSH
31720: LD_INT 2
31722: ARRAY
31723: PPUSH
31724: CALL_OW 488
31728: IFFALSE 31759
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
31730: LD_VAR 0 13
31734: PPUSH
31735: LD_VAR 0 16
31739: PUSH
31740: LD_INT 1
31742: ARRAY
31743: PPUSH
31744: LD_VAR 0 16
31748: PUSH
31749: LD_INT 2
31751: ARRAY
31752: PPUSH
31753: CALL_OW 111
// continue ;
31757: GO 31249
// end ; end ; r := GetDir ( tmp ) ;
31759: LD_ADDR_VAR 0 15
31763: PUSH
31764: LD_VAR 0 13
31768: PPUSH
31769: CALL_OW 254
31773: ST_TO_ADDR
// if r = 5 then
31774: LD_VAR 0 15
31778: PUSH
31779: LD_INT 5
31781: EQUAL
31782: IFFALSE 31792
// r := 0 ;
31784: LD_ADDR_VAR 0 15
31788: PUSH
31789: LD_INT 0
31791: ST_TO_ADDR
// for j = r to 5 do
31792: LD_ADDR_VAR 0 10
31796: PUSH
31797: DOUBLE
31798: LD_VAR 0 15
31802: DEC
31803: ST_TO_ADDR
31804: LD_INT 5
31806: PUSH
31807: FOR_TO
31808: IFFALSE 31922
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
31810: LD_ADDR_VAR 0 11
31814: PUSH
31815: LD_VAR 0 13
31819: PPUSH
31820: CALL_OW 250
31824: PPUSH
31825: LD_VAR 0 10
31829: PPUSH
31830: LD_INT 2
31832: PPUSH
31833: CALL_OW 272
31837: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
31838: LD_ADDR_VAR 0 12
31842: PUSH
31843: LD_VAR 0 13
31847: PPUSH
31848: CALL_OW 251
31852: PPUSH
31853: LD_VAR 0 10
31857: PPUSH
31858: LD_INT 2
31860: PPUSH
31861: CALL_OW 273
31865: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
31866: LD_VAR 0 11
31870: PPUSH
31871: LD_VAR 0 12
31875: PPUSH
31876: CALL_OW 488
31880: PUSH
31881: LD_VAR 0 11
31885: PPUSH
31886: LD_VAR 0 12
31890: PPUSH
31891: CALL_OW 428
31895: NOT
31896: AND
31897: IFFALSE 31920
// begin ComMoveXY ( tmp , _x , _y ) ;
31899: LD_VAR 0 13
31903: PPUSH
31904: LD_VAR 0 11
31908: PPUSH
31909: LD_VAR 0 12
31913: PPUSH
31914: CALL_OW 111
// break ;
31918: GO 31922
// end ; end ;
31920: GO 31807
31922: POP
31923: POP
// end ; end ;
31924: GO 31249
31926: POP
31927: POP
// end ;
31928: LD_VAR 0 8
31932: RET
// export function BuildingTechInvented ( side , btype ) ; begin
31933: LD_INT 0
31935: PPUSH
// result := true ;
31936: LD_ADDR_VAR 0 3
31940: PUSH
31941: LD_INT 1
31943: ST_TO_ADDR
// case btype of b_ext_computer , b_turret :
31944: LD_VAR 0 2
31948: PUSH
31949: LD_INT 24
31951: DOUBLE
31952: EQUAL
31953: IFTRUE 31963
31955: LD_INT 33
31957: DOUBLE
31958: EQUAL
31959: IFTRUE 31963
31961: GO 31988
31963: POP
// result := ( GetTech ( tech_ai , side ) = state_researched ) ; b_ext_radar :
31964: LD_ADDR_VAR 0 3
31968: PUSH
31969: LD_INT 32
31971: PPUSH
31972: LD_VAR 0 1
31976: PPUSH
31977: CALL_OW 321
31981: PUSH
31982: LD_INT 2
31984: EQUAL
31985: ST_TO_ADDR
31986: GO 32308
31988: LD_INT 20
31990: DOUBLE
31991: EQUAL
31992: IFTRUE 31996
31994: GO 32021
31996: POP
// result := ( GetTech ( tech_radar , side ) = state_researched ) ; b_ext_radio , b_control_tower :
31997: LD_ADDR_VAR 0 3
32001: PUSH
32002: LD_INT 6
32004: PPUSH
32005: LD_VAR 0 1
32009: PPUSH
32010: CALL_OW 321
32014: PUSH
32015: LD_INT 2
32017: EQUAL
32018: ST_TO_ADDR
32019: GO 32308
32021: LD_INT 22
32023: DOUBLE
32024: EQUAL
32025: IFTRUE 32035
32027: LD_INT 36
32029: DOUBLE
32030: EQUAL
32031: IFTRUE 32035
32033: GO 32060
32035: POP
// result := ( GetTech ( tech_remcont , side ) = state_researched ) ; b_siberite_mine :
32036: LD_ADDR_VAR 0 3
32040: PUSH
32041: LD_INT 15
32043: PPUSH
32044: LD_VAR 0 1
32048: PPUSH
32049: CALL_OW 321
32053: PUSH
32054: LD_INT 2
32056: EQUAL
32057: ST_TO_ADDR
32058: GO 32308
32060: LD_INT 30
32062: DOUBLE
32063: EQUAL
32064: IFTRUE 32068
32066: GO 32093
32068: POP
// result := ( GetTech ( tech_sibdet , side ) = state_researched ) ; b_siberite_power , b_ext_siberium :
32069: LD_ADDR_VAR 0 3
32073: PUSH
32074: LD_INT 20
32076: PPUSH
32077: LD_VAR 0 1
32081: PPUSH
32082: CALL_OW 321
32086: PUSH
32087: LD_INT 2
32089: EQUAL
32090: ST_TO_ADDR
32091: GO 32308
32093: LD_INT 28
32095: DOUBLE
32096: EQUAL
32097: IFTRUE 32107
32099: LD_INT 21
32101: DOUBLE
32102: EQUAL
32103: IFTRUE 32107
32105: GO 32132
32107: POP
// result := ( GetTech ( tech_sibpow , side ) = state_researched ) ; b_ext_track :
32108: LD_ADDR_VAR 0 3
32112: PUSH
32113: LD_INT 21
32115: PPUSH
32116: LD_VAR 0 1
32120: PPUSH
32121: CALL_OW 321
32125: PUSH
32126: LD_INT 2
32128: EQUAL
32129: ST_TO_ADDR
32130: GO 32308
32132: LD_INT 16
32134: DOUBLE
32135: EQUAL
32136: IFTRUE 32140
32138: GO 32167
32140: POP
// result := ( GetTech ( tech_track , side ) = state_researched ) ; b_ext_noncombat , b_ext_stitch :
32141: LD_ADDR_VAR 0 3
32145: PUSH
32146: LD_EXP 168
32150: PPUSH
32151: LD_VAR 0 1
32155: PPUSH
32156: CALL_OW 321
32160: PUSH
32161: LD_INT 2
32163: EQUAL
32164: ST_TO_ADDR
32165: GO 32308
32167: LD_INT 19
32169: DOUBLE
32170: EQUAL
32171: IFTRUE 32181
32173: LD_INT 23
32175: DOUBLE
32176: EQUAL
32177: IFTRUE 32181
32179: GO 32208
32181: POP
// result := ( GetTech ( tech_cargo , side ) = state_researched ) ; b_ext_gun :
32182: LD_ADDR_VAR 0 3
32186: PUSH
32187: LD_EXP 167
32191: PPUSH
32192: LD_VAR 0 1
32196: PPUSH
32197: CALL_OW 321
32201: PUSH
32202: LD_INT 2
32204: EQUAL
32205: ST_TO_ADDR
32206: GO 32308
32208: LD_INT 17
32210: DOUBLE
32211: EQUAL
32212: IFTRUE 32216
32214: GO 32241
32216: POP
// result := ( GetTech ( tech_gun , side ) = state_researched ) ; b_ext_rocket :
32217: LD_ADDR_VAR 0 3
32221: PUSH
32222: LD_INT 39
32224: PPUSH
32225: LD_VAR 0 1
32229: PPUSH
32230: CALL_OW 321
32234: PUSH
32235: LD_INT 2
32237: EQUAL
32238: ST_TO_ADDR
32239: GO 32308
32241: LD_INT 18
32243: DOUBLE
32244: EQUAL
32245: IFTRUE 32249
32247: GO 32274
32249: POP
// result := ( GetTech ( tech_rocket , side ) = state_researched ) ; b_solar_power :
32250: LD_ADDR_VAR 0 3
32254: PUSH
32255: LD_INT 40
32257: PPUSH
32258: LD_VAR 0 1
32262: PPUSH
32263: CALL_OW 321
32267: PUSH
32268: LD_INT 2
32270: EQUAL
32271: ST_TO_ADDR
32272: GO 32308
32274: LD_INT 27
32276: DOUBLE
32277: EQUAL
32278: IFTRUE 32282
32280: GO 32307
32282: POP
// result := ( GetTech ( tech_solpow , side ) = state_researched ) ; end ;
32283: LD_ADDR_VAR 0 3
32287: PUSH
32288: LD_INT 35
32290: PPUSH
32291: LD_VAR 0 1
32295: PPUSH
32296: CALL_OW 321
32300: PUSH
32301: LD_INT 2
32303: EQUAL
32304: ST_TO_ADDR
32305: GO 32308
32307: POP
// end ;
32308: LD_VAR 0 3
32312: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex , tech ; begin
32313: LD_INT 0
32315: PPUSH
32316: PPUSH
32317: PPUSH
32318: PPUSH
32319: PPUSH
32320: PPUSH
32321: PPUSH
32322: PPUSH
32323: PPUSH
32324: PPUSH
32325: PPUSH
// result := false ;
32326: LD_ADDR_VAR 0 6
32330: PUSH
32331: LD_INT 0
32333: ST_TO_ADDR
// if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
32334: LD_VAR 0 1
32338: NOT
32339: PUSH
32340: LD_VAR 0 1
32344: PPUSH
32345: CALL_OW 266
32349: PUSH
32350: LD_INT 0
32352: PUSH
32353: LD_INT 1
32355: PUSH
32356: EMPTY
32357: LIST
32358: LIST
32359: IN
32360: NOT
32361: OR
32362: PUSH
32363: LD_VAR 0 2
32367: NOT
32368: OR
32369: PUSH
32370: LD_VAR 0 5
32374: PUSH
32375: LD_INT 0
32377: PUSH
32378: LD_INT 1
32380: PUSH
32381: LD_INT 2
32383: PUSH
32384: LD_INT 3
32386: PUSH
32387: LD_INT 4
32389: PUSH
32390: LD_INT 5
32392: PUSH
32393: EMPTY
32394: LIST
32395: LIST
32396: LIST
32397: LIST
32398: LIST
32399: LIST
32400: IN
32401: NOT
32402: OR
32403: PUSH
32404: LD_VAR 0 3
32408: PPUSH
32409: LD_VAR 0 4
32413: PPUSH
32414: CALL_OW 488
32418: NOT
32419: OR
32420: IFFALSE 32424
// exit ;
32422: GO 33160
// side := GetSide ( depot ) ;
32424: LD_ADDR_VAR 0 9
32428: PUSH
32429: LD_VAR 0 1
32433: PPUSH
32434: CALL_OW 255
32438: ST_TO_ADDR
// if not BuildingTechInvented ( side , btype ) then
32439: LD_VAR 0 9
32443: PPUSH
32444: LD_VAR 0 2
32448: PPUSH
32449: CALL 31933 0 2
32453: NOT
32454: IFFALSE 32458
// exit ;
32456: GO 33160
// pom := GetBase ( depot ) ;
32458: LD_ADDR_VAR 0 10
32462: PUSH
32463: LD_VAR 0 1
32467: PPUSH
32468: CALL_OW 274
32472: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
32473: LD_ADDR_VAR 0 11
32477: PUSH
32478: LD_VAR 0 2
32482: PPUSH
32483: LD_VAR 0 1
32487: PPUSH
32488: CALL_OW 248
32492: PPUSH
32493: CALL_OW 450
32497: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
32498: LD_VAR 0 10
32502: PPUSH
32503: LD_INT 1
32505: PPUSH
32506: CALL_OW 275
32510: PUSH
32511: LD_VAR 0 11
32515: PUSH
32516: LD_INT 1
32518: ARRAY
32519: GREATEREQUAL
32520: PUSH
32521: LD_VAR 0 10
32525: PPUSH
32526: LD_INT 2
32528: PPUSH
32529: CALL_OW 275
32533: PUSH
32534: LD_VAR 0 11
32538: PUSH
32539: LD_INT 2
32541: ARRAY
32542: GREATEREQUAL
32543: AND
32544: PUSH
32545: LD_VAR 0 10
32549: PPUSH
32550: LD_INT 3
32552: PPUSH
32553: CALL_OW 275
32557: PUSH
32558: LD_VAR 0 11
32562: PUSH
32563: LD_INT 3
32565: ARRAY
32566: GREATEREQUAL
32567: AND
32568: NOT
32569: IFFALSE 32573
// exit ;
32571: GO 33160
// if GetBType ( depot ) = b_depot then
32573: LD_VAR 0 1
32577: PPUSH
32578: CALL_OW 266
32582: PUSH
32583: LD_INT 0
32585: EQUAL
32586: IFFALSE 32598
// dist := 28 else
32588: LD_ADDR_VAR 0 14
32592: PUSH
32593: LD_INT 28
32595: ST_TO_ADDR
32596: GO 32606
// dist := 36 ;
32598: LD_ADDR_VAR 0 14
32602: PUSH
32603: LD_INT 36
32605: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
32606: LD_VAR 0 1
32610: PPUSH
32611: LD_VAR 0 3
32615: PPUSH
32616: LD_VAR 0 4
32620: PPUSH
32621: CALL_OW 297
32625: PUSH
32626: LD_VAR 0 14
32630: GREATER
32631: IFFALSE 32635
// exit ;
32633: GO 33160
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
32635: LD_ADDR_VAR 0 12
32639: PUSH
32640: LD_VAR 0 2
32644: PPUSH
32645: LD_VAR 0 3
32649: PPUSH
32650: LD_VAR 0 4
32654: PPUSH
32655: LD_VAR 0 5
32659: PPUSH
32660: LD_VAR 0 1
32664: PPUSH
32665: CALL_OW 248
32669: PPUSH
32670: LD_INT 0
32672: PPUSH
32673: CALL 33165 0 6
32677: ST_TO_ADDR
// if not hexes then
32678: LD_VAR 0 12
32682: NOT
32683: IFFALSE 32687
// exit ;
32685: GO 33160
// hex := GetHexInfo ( x , y ) ;
32687: LD_ADDR_VAR 0 15
32691: PUSH
32692: LD_VAR 0 3
32696: PPUSH
32697: LD_VAR 0 4
32701: PPUSH
32702: CALL_OW 546
32706: ST_TO_ADDR
// if hex [ 1 ] then
32707: LD_VAR 0 15
32711: PUSH
32712: LD_INT 1
32714: ARRAY
32715: IFFALSE 32719
// exit ;
32717: GO 33160
// height := hex [ 2 ] ;
32719: LD_ADDR_VAR 0 13
32723: PUSH
32724: LD_VAR 0 15
32728: PUSH
32729: LD_INT 2
32731: ARRAY
32732: ST_TO_ADDR
// for i = 1 to hexes do
32733: LD_ADDR_VAR 0 7
32737: PUSH
32738: DOUBLE
32739: LD_INT 1
32741: DEC
32742: ST_TO_ADDR
32743: LD_VAR 0 12
32747: PUSH
32748: FOR_TO
32749: IFFALSE 33079
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
32751: LD_VAR 0 12
32755: PUSH
32756: LD_VAR 0 7
32760: ARRAY
32761: PUSH
32762: LD_INT 1
32764: ARRAY
32765: PPUSH
32766: LD_VAR 0 12
32770: PUSH
32771: LD_VAR 0 7
32775: ARRAY
32776: PUSH
32777: LD_INT 2
32779: ARRAY
32780: PPUSH
32781: CALL_OW 488
32785: NOT
32786: PUSH
32787: LD_VAR 0 12
32791: PUSH
32792: LD_VAR 0 7
32796: ARRAY
32797: PUSH
32798: LD_INT 1
32800: ARRAY
32801: PPUSH
32802: LD_VAR 0 12
32806: PUSH
32807: LD_VAR 0 7
32811: ARRAY
32812: PUSH
32813: LD_INT 2
32815: ARRAY
32816: PPUSH
32817: CALL_OW 428
32821: PUSH
32822: LD_INT 0
32824: GREATER
32825: OR
32826: PUSH
32827: LD_VAR 0 12
32831: PUSH
32832: LD_VAR 0 7
32836: ARRAY
32837: PUSH
32838: LD_INT 1
32840: ARRAY
32841: PPUSH
32842: LD_VAR 0 12
32846: PUSH
32847: LD_VAR 0 7
32851: ARRAY
32852: PUSH
32853: LD_INT 2
32855: ARRAY
32856: PPUSH
32857: CALL_OW 351
32861: OR
32862: IFFALSE 32868
// exit ;
32864: POP
32865: POP
32866: GO 33160
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
32868: LD_ADDR_VAR 0 8
32872: PUSH
32873: LD_VAR 0 12
32877: PUSH
32878: LD_VAR 0 7
32882: ARRAY
32883: PUSH
32884: LD_INT 1
32886: ARRAY
32887: PPUSH
32888: LD_VAR 0 12
32892: PUSH
32893: LD_VAR 0 7
32897: ARRAY
32898: PUSH
32899: LD_INT 2
32901: ARRAY
32902: PPUSH
32903: CALL_OW 546
32907: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
32908: LD_VAR 0 8
32912: PUSH
32913: LD_INT 1
32915: ARRAY
32916: PUSH
32917: LD_VAR 0 8
32921: PUSH
32922: LD_INT 2
32924: ARRAY
32925: PUSH
32926: LD_VAR 0 13
32930: PUSH
32931: LD_INT 2
32933: PLUS
32934: GREATER
32935: OR
32936: PUSH
32937: LD_VAR 0 8
32941: PUSH
32942: LD_INT 2
32944: ARRAY
32945: PUSH
32946: LD_VAR 0 13
32950: PUSH
32951: LD_INT 2
32953: MINUS
32954: LESS
32955: OR
32956: PUSH
32957: LD_VAR 0 8
32961: PUSH
32962: LD_INT 3
32964: ARRAY
32965: PUSH
32966: LD_INT 0
32968: PUSH
32969: LD_INT 8
32971: PUSH
32972: LD_INT 9
32974: PUSH
32975: LD_INT 10
32977: PUSH
32978: LD_INT 11
32980: PUSH
32981: LD_INT 12
32983: PUSH
32984: LD_INT 13
32986: PUSH
32987: LD_INT 16
32989: PUSH
32990: LD_INT 17
32992: PUSH
32993: LD_INT 18
32995: PUSH
32996: LD_INT 19
32998: PUSH
32999: LD_INT 20
33001: PUSH
33002: LD_INT 21
33004: PUSH
33005: EMPTY
33006: LIST
33007: LIST
33008: LIST
33009: LIST
33010: LIST
33011: LIST
33012: LIST
33013: LIST
33014: LIST
33015: LIST
33016: LIST
33017: LIST
33018: LIST
33019: IN
33020: NOT
33021: OR
33022: PUSH
33023: LD_VAR 0 8
33027: PUSH
33028: LD_INT 5
33030: ARRAY
33031: NOT
33032: OR
33033: PUSH
33034: LD_VAR 0 8
33038: PUSH
33039: LD_INT 6
33041: ARRAY
33042: PUSH
33043: LD_INT 1
33045: PUSH
33046: LD_INT 2
33048: PUSH
33049: LD_INT 7
33051: PUSH
33052: LD_INT 9
33054: PUSH
33055: LD_INT 10
33057: PUSH
33058: LD_INT 11
33060: PUSH
33061: EMPTY
33062: LIST
33063: LIST
33064: LIST
33065: LIST
33066: LIST
33067: LIST
33068: IN
33069: NOT
33070: OR
33071: IFFALSE 33077
// exit ;
33073: POP
33074: POP
33075: GO 33160
// end ;
33077: GO 32748
33079: POP
33080: POP
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
33081: LD_VAR 0 9
33085: PPUSH
33086: LD_VAR 0 3
33090: PPUSH
33091: LD_VAR 0 4
33095: PPUSH
33096: LD_INT 20
33098: PPUSH
33099: CALL 25106 0 4
33103: PUSH
33104: LD_INT 4
33106: ARRAY
33107: IFFALSE 33111
// exit ;
33109: GO 33160
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
33111: LD_VAR 0 2
33115: PUSH
33116: LD_INT 29
33118: PUSH
33119: LD_INT 30
33121: PUSH
33122: EMPTY
33123: LIST
33124: LIST
33125: IN
33126: PUSH
33127: LD_VAR 0 3
33131: PPUSH
33132: LD_VAR 0 4
33136: PPUSH
33137: LD_VAR 0 9
33141: PPUSH
33142: CALL_OW 440
33146: NOT
33147: AND
33148: IFFALSE 33152
// exit ;
33150: GO 33160
// result := true ;
33152: LD_ADDR_VAR 0 6
33156: PUSH
33157: LD_INT 1
33159: ST_TO_ADDR
// end ;
33160: LD_VAR 0 6
33164: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 , fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 , fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ; var fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 , fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ; var fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 , fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ; var fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 , fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ; begin
33165: LD_INT 0
33167: PPUSH
33168: PPUSH
33169: PPUSH
33170: PPUSH
33171: PPUSH
33172: PPUSH
33173: PPUSH
33174: PPUSH
33175: PPUSH
33176: PPUSH
33177: PPUSH
33178: PPUSH
33179: PPUSH
33180: PPUSH
33181: PPUSH
33182: PPUSH
33183: PPUSH
33184: PPUSH
33185: PPUSH
33186: PPUSH
33187: PPUSH
33188: PPUSH
33189: PPUSH
33190: PPUSH
33191: PPUSH
33192: PPUSH
33193: PPUSH
33194: PPUSH
33195: PPUSH
33196: PPUSH
33197: PPUSH
33198: PPUSH
33199: PPUSH
33200: PPUSH
33201: PPUSH
33202: PPUSH
33203: PPUSH
33204: PPUSH
33205: PPUSH
33206: PPUSH
33207: PPUSH
33208: PPUSH
33209: PPUSH
33210: PPUSH
33211: PPUSH
33212: PPUSH
33213: PPUSH
33214: PPUSH
33215: PPUSH
33216: PPUSH
33217: PPUSH
33218: PPUSH
33219: PPUSH
33220: PPUSH
33221: PPUSH
33222: PPUSH
33223: PPUSH
33224: PPUSH
// result = [ ] ;
33225: LD_ADDR_VAR 0 7
33229: PUSH
33230: EMPTY
33231: ST_TO_ADDR
// temp_list = [ ] ;
33232: LD_ADDR_VAR 0 9
33236: PUSH
33237: EMPTY
33238: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
33239: LD_VAR 0 4
33243: PUSH
33244: LD_INT 0
33246: PUSH
33247: LD_INT 1
33249: PUSH
33250: LD_INT 2
33252: PUSH
33253: LD_INT 3
33255: PUSH
33256: LD_INT 4
33258: PUSH
33259: LD_INT 5
33261: PUSH
33262: EMPTY
33263: LIST
33264: LIST
33265: LIST
33266: LIST
33267: LIST
33268: LIST
33269: IN
33270: NOT
33271: PUSH
33272: LD_VAR 0 1
33276: PUSH
33277: LD_INT 0
33279: PUSH
33280: LD_INT 1
33282: PUSH
33283: EMPTY
33284: LIST
33285: LIST
33286: IN
33287: PUSH
33288: LD_VAR 0 5
33292: PUSH
33293: LD_INT 1
33295: PUSH
33296: LD_INT 2
33298: PUSH
33299: LD_INT 3
33301: PUSH
33302: EMPTY
33303: LIST
33304: LIST
33305: LIST
33306: IN
33307: NOT
33308: AND
33309: OR
33310: IFFALSE 33314
// exit ;
33312: GO 51705
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
33314: LD_VAR 0 1
33318: PUSH
33319: LD_INT 6
33321: PUSH
33322: LD_INT 7
33324: PUSH
33325: LD_INT 8
33327: PUSH
33328: LD_INT 13
33330: PUSH
33331: LD_INT 12
33333: PUSH
33334: LD_INT 15
33336: PUSH
33337: LD_INT 11
33339: PUSH
33340: LD_INT 14
33342: PUSH
33343: LD_INT 10
33345: PUSH
33346: EMPTY
33347: LIST
33348: LIST
33349: LIST
33350: LIST
33351: LIST
33352: LIST
33353: LIST
33354: LIST
33355: LIST
33356: IN
33357: IFFALSE 33367
// btype = b_lab ;
33359: LD_ADDR_VAR 0 1
33363: PUSH
33364: LD_INT 6
33366: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
33367: LD_VAR 0 6
33371: PUSH
33372: LD_INT 0
33374: PUSH
33375: LD_INT 1
33377: PUSH
33378: LD_INT 2
33380: PUSH
33381: EMPTY
33382: LIST
33383: LIST
33384: LIST
33385: IN
33386: NOT
33387: PUSH
33388: LD_VAR 0 1
33392: PUSH
33393: LD_INT 0
33395: PUSH
33396: LD_INT 1
33398: PUSH
33399: LD_INT 2
33401: PUSH
33402: LD_INT 3
33404: PUSH
33405: LD_INT 6
33407: PUSH
33408: LD_INT 36
33410: PUSH
33411: LD_INT 4
33413: PUSH
33414: LD_INT 5
33416: PUSH
33417: LD_INT 31
33419: PUSH
33420: LD_INT 32
33422: PUSH
33423: LD_INT 33
33425: PUSH
33426: EMPTY
33427: LIST
33428: LIST
33429: LIST
33430: LIST
33431: LIST
33432: LIST
33433: LIST
33434: LIST
33435: LIST
33436: LIST
33437: LIST
33438: IN
33439: NOT
33440: PUSH
33441: LD_VAR 0 6
33445: PUSH
33446: LD_INT 1
33448: EQUAL
33449: AND
33450: OR
33451: PUSH
33452: LD_VAR 0 1
33456: PUSH
33457: LD_INT 2
33459: PUSH
33460: LD_INT 3
33462: PUSH
33463: EMPTY
33464: LIST
33465: LIST
33466: IN
33467: NOT
33468: PUSH
33469: LD_VAR 0 6
33473: PUSH
33474: LD_INT 2
33476: EQUAL
33477: AND
33478: OR
33479: IFFALSE 33489
// mode = 0 ;
33481: LD_ADDR_VAR 0 6
33485: PUSH
33486: LD_INT 0
33488: ST_TO_ADDR
// case mode of 0 :
33489: LD_VAR 0 6
33493: PUSH
33494: LD_INT 0
33496: DOUBLE
33497: EQUAL
33498: IFTRUE 33502
33500: GO 44955
33502: POP
// begin fDepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
33503: LD_ADDR_VAR 0 11
33507: PUSH
33508: LD_INT 0
33510: PUSH
33511: LD_INT 0
33513: PUSH
33514: EMPTY
33515: LIST
33516: LIST
33517: PUSH
33518: LD_INT 0
33520: PUSH
33521: LD_INT 1
33523: NEG
33524: PUSH
33525: EMPTY
33526: LIST
33527: LIST
33528: PUSH
33529: LD_INT 1
33531: PUSH
33532: LD_INT 0
33534: PUSH
33535: EMPTY
33536: LIST
33537: LIST
33538: PUSH
33539: LD_INT 1
33541: PUSH
33542: LD_INT 1
33544: PUSH
33545: EMPTY
33546: LIST
33547: LIST
33548: PUSH
33549: LD_INT 0
33551: PUSH
33552: LD_INT 1
33554: PUSH
33555: EMPTY
33556: LIST
33557: LIST
33558: PUSH
33559: LD_INT 1
33561: NEG
33562: PUSH
33563: LD_INT 0
33565: PUSH
33566: EMPTY
33567: LIST
33568: LIST
33569: PUSH
33570: LD_INT 1
33572: NEG
33573: PUSH
33574: LD_INT 1
33576: NEG
33577: PUSH
33578: EMPTY
33579: LIST
33580: LIST
33581: PUSH
33582: LD_INT 1
33584: NEG
33585: PUSH
33586: LD_INT 2
33588: NEG
33589: PUSH
33590: EMPTY
33591: LIST
33592: LIST
33593: PUSH
33594: LD_INT 0
33596: PUSH
33597: LD_INT 2
33599: NEG
33600: PUSH
33601: EMPTY
33602: LIST
33603: LIST
33604: PUSH
33605: LD_INT 1
33607: PUSH
33608: LD_INT 1
33610: NEG
33611: PUSH
33612: EMPTY
33613: LIST
33614: LIST
33615: PUSH
33616: LD_INT 1
33618: PUSH
33619: LD_INT 2
33621: PUSH
33622: EMPTY
33623: LIST
33624: LIST
33625: PUSH
33626: LD_INT 0
33628: PUSH
33629: LD_INT 2
33631: PUSH
33632: EMPTY
33633: LIST
33634: LIST
33635: PUSH
33636: LD_INT 1
33638: NEG
33639: PUSH
33640: LD_INT 1
33642: PUSH
33643: EMPTY
33644: LIST
33645: LIST
33646: PUSH
33647: LD_INT 1
33649: PUSH
33650: LD_INT 3
33652: PUSH
33653: EMPTY
33654: LIST
33655: LIST
33656: PUSH
33657: LD_INT 0
33659: PUSH
33660: LD_INT 3
33662: PUSH
33663: EMPTY
33664: LIST
33665: LIST
33666: PUSH
33667: LD_INT 1
33669: NEG
33670: PUSH
33671: LD_INT 2
33673: PUSH
33674: EMPTY
33675: LIST
33676: LIST
33677: PUSH
33678: EMPTY
33679: LIST
33680: LIST
33681: LIST
33682: LIST
33683: LIST
33684: LIST
33685: LIST
33686: LIST
33687: LIST
33688: LIST
33689: LIST
33690: LIST
33691: LIST
33692: LIST
33693: LIST
33694: LIST
33695: ST_TO_ADDR
// fDepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
33696: LD_ADDR_VAR 0 12
33700: PUSH
33701: LD_INT 0
33703: PUSH
33704: LD_INT 0
33706: PUSH
33707: EMPTY
33708: LIST
33709: LIST
33710: PUSH
33711: LD_INT 0
33713: PUSH
33714: LD_INT 1
33716: NEG
33717: PUSH
33718: EMPTY
33719: LIST
33720: LIST
33721: PUSH
33722: LD_INT 1
33724: PUSH
33725: LD_INT 0
33727: PUSH
33728: EMPTY
33729: LIST
33730: LIST
33731: PUSH
33732: LD_INT 1
33734: PUSH
33735: LD_INT 1
33737: PUSH
33738: EMPTY
33739: LIST
33740: LIST
33741: PUSH
33742: LD_INT 0
33744: PUSH
33745: LD_INT 1
33747: PUSH
33748: EMPTY
33749: LIST
33750: LIST
33751: PUSH
33752: LD_INT 1
33754: NEG
33755: PUSH
33756: LD_INT 0
33758: PUSH
33759: EMPTY
33760: LIST
33761: LIST
33762: PUSH
33763: LD_INT 1
33765: NEG
33766: PUSH
33767: LD_INT 1
33769: NEG
33770: PUSH
33771: EMPTY
33772: LIST
33773: LIST
33774: PUSH
33775: LD_INT 1
33777: PUSH
33778: LD_INT 1
33780: NEG
33781: PUSH
33782: EMPTY
33783: LIST
33784: LIST
33785: PUSH
33786: LD_INT 2
33788: PUSH
33789: LD_INT 0
33791: PUSH
33792: EMPTY
33793: LIST
33794: LIST
33795: PUSH
33796: LD_INT 2
33798: PUSH
33799: LD_INT 1
33801: PUSH
33802: EMPTY
33803: LIST
33804: LIST
33805: PUSH
33806: LD_INT 1
33808: NEG
33809: PUSH
33810: LD_INT 1
33812: PUSH
33813: EMPTY
33814: LIST
33815: LIST
33816: PUSH
33817: LD_INT 2
33819: NEG
33820: PUSH
33821: LD_INT 0
33823: PUSH
33824: EMPTY
33825: LIST
33826: LIST
33827: PUSH
33828: LD_INT 2
33830: NEG
33831: PUSH
33832: LD_INT 1
33834: NEG
33835: PUSH
33836: EMPTY
33837: LIST
33838: LIST
33839: PUSH
33840: LD_INT 2
33842: NEG
33843: PUSH
33844: LD_INT 1
33846: PUSH
33847: EMPTY
33848: LIST
33849: LIST
33850: PUSH
33851: LD_INT 3
33853: NEG
33854: PUSH
33855: LD_INT 0
33857: PUSH
33858: EMPTY
33859: LIST
33860: LIST
33861: PUSH
33862: LD_INT 3
33864: NEG
33865: PUSH
33866: LD_INT 1
33868: NEG
33869: PUSH
33870: EMPTY
33871: LIST
33872: LIST
33873: PUSH
33874: EMPTY
33875: LIST
33876: LIST
33877: LIST
33878: LIST
33879: LIST
33880: LIST
33881: LIST
33882: LIST
33883: LIST
33884: LIST
33885: LIST
33886: LIST
33887: LIST
33888: LIST
33889: LIST
33890: LIST
33891: ST_TO_ADDR
// fDepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
33892: LD_ADDR_VAR 0 13
33896: PUSH
33897: LD_INT 0
33899: PUSH
33900: LD_INT 0
33902: PUSH
33903: EMPTY
33904: LIST
33905: LIST
33906: PUSH
33907: LD_INT 0
33909: PUSH
33910: LD_INT 1
33912: NEG
33913: PUSH
33914: EMPTY
33915: LIST
33916: LIST
33917: PUSH
33918: LD_INT 1
33920: PUSH
33921: LD_INT 0
33923: PUSH
33924: EMPTY
33925: LIST
33926: LIST
33927: PUSH
33928: LD_INT 1
33930: PUSH
33931: LD_INT 1
33933: PUSH
33934: EMPTY
33935: LIST
33936: LIST
33937: PUSH
33938: LD_INT 0
33940: PUSH
33941: LD_INT 1
33943: PUSH
33944: EMPTY
33945: LIST
33946: LIST
33947: PUSH
33948: LD_INT 1
33950: NEG
33951: PUSH
33952: LD_INT 0
33954: PUSH
33955: EMPTY
33956: LIST
33957: LIST
33958: PUSH
33959: LD_INT 1
33961: NEG
33962: PUSH
33963: LD_INT 1
33965: NEG
33966: PUSH
33967: EMPTY
33968: LIST
33969: LIST
33970: PUSH
33971: LD_INT 1
33973: NEG
33974: PUSH
33975: LD_INT 2
33977: NEG
33978: PUSH
33979: EMPTY
33980: LIST
33981: LIST
33982: PUSH
33983: LD_INT 2
33985: PUSH
33986: LD_INT 1
33988: PUSH
33989: EMPTY
33990: LIST
33991: LIST
33992: PUSH
33993: LD_INT 2
33995: PUSH
33996: LD_INT 2
33998: PUSH
33999: EMPTY
34000: LIST
34001: LIST
34002: PUSH
34003: LD_INT 1
34005: PUSH
34006: LD_INT 2
34008: PUSH
34009: EMPTY
34010: LIST
34011: LIST
34012: PUSH
34013: LD_INT 2
34015: NEG
34016: PUSH
34017: LD_INT 1
34019: NEG
34020: PUSH
34021: EMPTY
34022: LIST
34023: LIST
34024: PUSH
34025: LD_INT 2
34027: NEG
34028: PUSH
34029: LD_INT 2
34031: NEG
34032: PUSH
34033: EMPTY
34034: LIST
34035: LIST
34036: PUSH
34037: LD_INT 2
34039: NEG
34040: PUSH
34041: LD_INT 3
34043: NEG
34044: PUSH
34045: EMPTY
34046: LIST
34047: LIST
34048: PUSH
34049: LD_INT 3
34051: NEG
34052: PUSH
34053: LD_INT 2
34055: NEG
34056: PUSH
34057: EMPTY
34058: LIST
34059: LIST
34060: PUSH
34061: LD_INT 3
34063: NEG
34064: PUSH
34065: LD_INT 3
34067: NEG
34068: PUSH
34069: EMPTY
34070: LIST
34071: LIST
34072: PUSH
34073: EMPTY
34074: LIST
34075: LIST
34076: LIST
34077: LIST
34078: LIST
34079: LIST
34080: LIST
34081: LIST
34082: LIST
34083: LIST
34084: LIST
34085: LIST
34086: LIST
34087: LIST
34088: LIST
34089: LIST
34090: ST_TO_ADDR
// fDepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
34091: LD_ADDR_VAR 0 14
34095: PUSH
34096: LD_INT 0
34098: PUSH
34099: LD_INT 0
34101: PUSH
34102: EMPTY
34103: LIST
34104: LIST
34105: PUSH
34106: LD_INT 0
34108: PUSH
34109: LD_INT 1
34111: NEG
34112: PUSH
34113: EMPTY
34114: LIST
34115: LIST
34116: PUSH
34117: LD_INT 1
34119: PUSH
34120: LD_INT 0
34122: PUSH
34123: EMPTY
34124: LIST
34125: LIST
34126: PUSH
34127: LD_INT 1
34129: PUSH
34130: LD_INT 1
34132: PUSH
34133: EMPTY
34134: LIST
34135: LIST
34136: PUSH
34137: LD_INT 0
34139: PUSH
34140: LD_INT 1
34142: PUSH
34143: EMPTY
34144: LIST
34145: LIST
34146: PUSH
34147: LD_INT 1
34149: NEG
34150: PUSH
34151: LD_INT 0
34153: PUSH
34154: EMPTY
34155: LIST
34156: LIST
34157: PUSH
34158: LD_INT 1
34160: NEG
34161: PUSH
34162: LD_INT 1
34164: NEG
34165: PUSH
34166: EMPTY
34167: LIST
34168: LIST
34169: PUSH
34170: LD_INT 1
34172: NEG
34173: PUSH
34174: LD_INT 2
34176: NEG
34177: PUSH
34178: EMPTY
34179: LIST
34180: LIST
34181: PUSH
34182: LD_INT 0
34184: PUSH
34185: LD_INT 2
34187: NEG
34188: PUSH
34189: EMPTY
34190: LIST
34191: LIST
34192: PUSH
34193: LD_INT 1
34195: PUSH
34196: LD_INT 1
34198: NEG
34199: PUSH
34200: EMPTY
34201: LIST
34202: LIST
34203: PUSH
34204: LD_INT 1
34206: PUSH
34207: LD_INT 2
34209: PUSH
34210: EMPTY
34211: LIST
34212: LIST
34213: PUSH
34214: LD_INT 0
34216: PUSH
34217: LD_INT 2
34219: PUSH
34220: EMPTY
34221: LIST
34222: LIST
34223: PUSH
34224: LD_INT 1
34226: NEG
34227: PUSH
34228: LD_INT 1
34230: PUSH
34231: EMPTY
34232: LIST
34233: LIST
34234: PUSH
34235: LD_INT 1
34237: NEG
34238: PUSH
34239: LD_INT 3
34241: NEG
34242: PUSH
34243: EMPTY
34244: LIST
34245: LIST
34246: PUSH
34247: LD_INT 0
34249: PUSH
34250: LD_INT 3
34252: NEG
34253: PUSH
34254: EMPTY
34255: LIST
34256: LIST
34257: PUSH
34258: LD_INT 1
34260: PUSH
34261: LD_INT 2
34263: NEG
34264: PUSH
34265: EMPTY
34266: LIST
34267: LIST
34268: PUSH
34269: EMPTY
34270: LIST
34271: LIST
34272: LIST
34273: LIST
34274: LIST
34275: LIST
34276: LIST
34277: LIST
34278: LIST
34279: LIST
34280: LIST
34281: LIST
34282: LIST
34283: LIST
34284: LIST
34285: LIST
34286: ST_TO_ADDR
// fDepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
34287: LD_ADDR_VAR 0 15
34291: PUSH
34292: LD_INT 0
34294: PUSH
34295: LD_INT 0
34297: PUSH
34298: EMPTY
34299: LIST
34300: LIST
34301: PUSH
34302: LD_INT 0
34304: PUSH
34305: LD_INT 1
34307: NEG
34308: PUSH
34309: EMPTY
34310: LIST
34311: LIST
34312: PUSH
34313: LD_INT 1
34315: PUSH
34316: LD_INT 0
34318: PUSH
34319: EMPTY
34320: LIST
34321: LIST
34322: PUSH
34323: LD_INT 1
34325: PUSH
34326: LD_INT 1
34328: PUSH
34329: EMPTY
34330: LIST
34331: LIST
34332: PUSH
34333: LD_INT 0
34335: PUSH
34336: LD_INT 1
34338: PUSH
34339: EMPTY
34340: LIST
34341: LIST
34342: PUSH
34343: LD_INT 1
34345: NEG
34346: PUSH
34347: LD_INT 0
34349: PUSH
34350: EMPTY
34351: LIST
34352: LIST
34353: PUSH
34354: LD_INT 1
34356: NEG
34357: PUSH
34358: LD_INT 1
34360: NEG
34361: PUSH
34362: EMPTY
34363: LIST
34364: LIST
34365: PUSH
34366: LD_INT 1
34368: PUSH
34369: LD_INT 1
34371: NEG
34372: PUSH
34373: EMPTY
34374: LIST
34375: LIST
34376: PUSH
34377: LD_INT 2
34379: PUSH
34380: LD_INT 0
34382: PUSH
34383: EMPTY
34384: LIST
34385: LIST
34386: PUSH
34387: LD_INT 2
34389: PUSH
34390: LD_INT 1
34392: PUSH
34393: EMPTY
34394: LIST
34395: LIST
34396: PUSH
34397: LD_INT 1
34399: NEG
34400: PUSH
34401: LD_INT 1
34403: PUSH
34404: EMPTY
34405: LIST
34406: LIST
34407: PUSH
34408: LD_INT 2
34410: NEG
34411: PUSH
34412: LD_INT 0
34414: PUSH
34415: EMPTY
34416: LIST
34417: LIST
34418: PUSH
34419: LD_INT 2
34421: NEG
34422: PUSH
34423: LD_INT 1
34425: NEG
34426: PUSH
34427: EMPTY
34428: LIST
34429: LIST
34430: PUSH
34431: LD_INT 2
34433: PUSH
34434: LD_INT 1
34436: NEG
34437: PUSH
34438: EMPTY
34439: LIST
34440: LIST
34441: PUSH
34442: LD_INT 3
34444: PUSH
34445: LD_INT 0
34447: PUSH
34448: EMPTY
34449: LIST
34450: LIST
34451: PUSH
34452: LD_INT 3
34454: PUSH
34455: LD_INT 1
34457: PUSH
34458: EMPTY
34459: LIST
34460: LIST
34461: PUSH
34462: EMPTY
34463: LIST
34464: LIST
34465: LIST
34466: LIST
34467: LIST
34468: LIST
34469: LIST
34470: LIST
34471: LIST
34472: LIST
34473: LIST
34474: LIST
34475: LIST
34476: LIST
34477: LIST
34478: LIST
34479: ST_TO_ADDR
// fDepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
34480: LD_ADDR_VAR 0 16
34484: PUSH
34485: LD_INT 0
34487: PUSH
34488: LD_INT 0
34490: PUSH
34491: EMPTY
34492: LIST
34493: LIST
34494: PUSH
34495: LD_INT 0
34497: PUSH
34498: LD_INT 1
34500: NEG
34501: PUSH
34502: EMPTY
34503: LIST
34504: LIST
34505: PUSH
34506: LD_INT 1
34508: PUSH
34509: LD_INT 0
34511: PUSH
34512: EMPTY
34513: LIST
34514: LIST
34515: PUSH
34516: LD_INT 1
34518: PUSH
34519: LD_INT 1
34521: PUSH
34522: EMPTY
34523: LIST
34524: LIST
34525: PUSH
34526: LD_INT 0
34528: PUSH
34529: LD_INT 1
34531: PUSH
34532: EMPTY
34533: LIST
34534: LIST
34535: PUSH
34536: LD_INT 1
34538: NEG
34539: PUSH
34540: LD_INT 0
34542: PUSH
34543: EMPTY
34544: LIST
34545: LIST
34546: PUSH
34547: LD_INT 1
34549: NEG
34550: PUSH
34551: LD_INT 1
34553: NEG
34554: PUSH
34555: EMPTY
34556: LIST
34557: LIST
34558: PUSH
34559: LD_INT 1
34561: NEG
34562: PUSH
34563: LD_INT 2
34565: NEG
34566: PUSH
34567: EMPTY
34568: LIST
34569: LIST
34570: PUSH
34571: LD_INT 2
34573: PUSH
34574: LD_INT 1
34576: PUSH
34577: EMPTY
34578: LIST
34579: LIST
34580: PUSH
34581: LD_INT 2
34583: PUSH
34584: LD_INT 2
34586: PUSH
34587: EMPTY
34588: LIST
34589: LIST
34590: PUSH
34591: LD_INT 1
34593: PUSH
34594: LD_INT 2
34596: PUSH
34597: EMPTY
34598: LIST
34599: LIST
34600: PUSH
34601: LD_INT 2
34603: NEG
34604: PUSH
34605: LD_INT 1
34607: NEG
34608: PUSH
34609: EMPTY
34610: LIST
34611: LIST
34612: PUSH
34613: LD_INT 2
34615: NEG
34616: PUSH
34617: LD_INT 2
34619: NEG
34620: PUSH
34621: EMPTY
34622: LIST
34623: LIST
34624: PUSH
34625: LD_INT 3
34627: PUSH
34628: LD_INT 2
34630: PUSH
34631: EMPTY
34632: LIST
34633: LIST
34634: PUSH
34635: LD_INT 3
34637: PUSH
34638: LD_INT 3
34640: PUSH
34641: EMPTY
34642: LIST
34643: LIST
34644: PUSH
34645: LD_INT 2
34647: PUSH
34648: LD_INT 3
34650: PUSH
34651: EMPTY
34652: LIST
34653: LIST
34654: PUSH
34655: EMPTY
34656: LIST
34657: LIST
34658: LIST
34659: LIST
34660: LIST
34661: LIST
34662: LIST
34663: LIST
34664: LIST
34665: LIST
34666: LIST
34667: LIST
34668: LIST
34669: LIST
34670: LIST
34671: LIST
34672: ST_TO_ADDR
// fDepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
34673: LD_ADDR_VAR 0 17
34677: PUSH
34678: LD_INT 0
34680: PUSH
34681: LD_INT 0
34683: PUSH
34684: EMPTY
34685: LIST
34686: LIST
34687: PUSH
34688: LD_INT 0
34690: PUSH
34691: LD_INT 1
34693: NEG
34694: PUSH
34695: EMPTY
34696: LIST
34697: LIST
34698: PUSH
34699: LD_INT 1
34701: PUSH
34702: LD_INT 0
34704: PUSH
34705: EMPTY
34706: LIST
34707: LIST
34708: PUSH
34709: LD_INT 1
34711: PUSH
34712: LD_INT 1
34714: PUSH
34715: EMPTY
34716: LIST
34717: LIST
34718: PUSH
34719: LD_INT 0
34721: PUSH
34722: LD_INT 1
34724: PUSH
34725: EMPTY
34726: LIST
34727: LIST
34728: PUSH
34729: LD_INT 1
34731: NEG
34732: PUSH
34733: LD_INT 0
34735: PUSH
34736: EMPTY
34737: LIST
34738: LIST
34739: PUSH
34740: LD_INT 1
34742: NEG
34743: PUSH
34744: LD_INT 1
34746: NEG
34747: PUSH
34748: EMPTY
34749: LIST
34750: LIST
34751: PUSH
34752: LD_INT 1
34754: NEG
34755: PUSH
34756: LD_INT 2
34758: NEG
34759: PUSH
34760: EMPTY
34761: LIST
34762: LIST
34763: PUSH
34764: LD_INT 0
34766: PUSH
34767: LD_INT 2
34769: NEG
34770: PUSH
34771: EMPTY
34772: LIST
34773: LIST
34774: PUSH
34775: LD_INT 1
34777: PUSH
34778: LD_INT 1
34780: NEG
34781: PUSH
34782: EMPTY
34783: LIST
34784: LIST
34785: PUSH
34786: LD_INT 2
34788: PUSH
34789: LD_INT 0
34791: PUSH
34792: EMPTY
34793: LIST
34794: LIST
34795: PUSH
34796: LD_INT 2
34798: PUSH
34799: LD_INT 1
34801: PUSH
34802: EMPTY
34803: LIST
34804: LIST
34805: PUSH
34806: LD_INT 2
34808: PUSH
34809: LD_INT 2
34811: PUSH
34812: EMPTY
34813: LIST
34814: LIST
34815: PUSH
34816: LD_INT 1
34818: PUSH
34819: LD_INT 2
34821: PUSH
34822: EMPTY
34823: LIST
34824: LIST
34825: PUSH
34826: LD_INT 0
34828: PUSH
34829: LD_INT 2
34831: PUSH
34832: EMPTY
34833: LIST
34834: LIST
34835: PUSH
34836: LD_INT 1
34838: NEG
34839: PUSH
34840: LD_INT 1
34842: PUSH
34843: EMPTY
34844: LIST
34845: LIST
34846: PUSH
34847: LD_INT 2
34849: NEG
34850: PUSH
34851: LD_INT 0
34853: PUSH
34854: EMPTY
34855: LIST
34856: LIST
34857: PUSH
34858: LD_INT 2
34860: NEG
34861: PUSH
34862: LD_INT 1
34864: NEG
34865: PUSH
34866: EMPTY
34867: LIST
34868: LIST
34869: PUSH
34870: LD_INT 2
34872: NEG
34873: PUSH
34874: LD_INT 2
34876: NEG
34877: PUSH
34878: EMPTY
34879: LIST
34880: LIST
34881: PUSH
34882: EMPTY
34883: LIST
34884: LIST
34885: LIST
34886: LIST
34887: LIST
34888: LIST
34889: LIST
34890: LIST
34891: LIST
34892: LIST
34893: LIST
34894: LIST
34895: LIST
34896: LIST
34897: LIST
34898: LIST
34899: LIST
34900: LIST
34901: LIST
34902: ST_TO_ADDR
// fDepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
34903: LD_ADDR_VAR 0 18
34907: PUSH
34908: LD_INT 0
34910: PUSH
34911: LD_INT 0
34913: PUSH
34914: EMPTY
34915: LIST
34916: LIST
34917: PUSH
34918: LD_INT 0
34920: PUSH
34921: LD_INT 1
34923: NEG
34924: PUSH
34925: EMPTY
34926: LIST
34927: LIST
34928: PUSH
34929: LD_INT 1
34931: PUSH
34932: LD_INT 0
34934: PUSH
34935: EMPTY
34936: LIST
34937: LIST
34938: PUSH
34939: LD_INT 1
34941: PUSH
34942: LD_INT 1
34944: PUSH
34945: EMPTY
34946: LIST
34947: LIST
34948: PUSH
34949: LD_INT 0
34951: PUSH
34952: LD_INT 1
34954: PUSH
34955: EMPTY
34956: LIST
34957: LIST
34958: PUSH
34959: LD_INT 1
34961: NEG
34962: PUSH
34963: LD_INT 0
34965: PUSH
34966: EMPTY
34967: LIST
34968: LIST
34969: PUSH
34970: LD_INT 1
34972: NEG
34973: PUSH
34974: LD_INT 1
34976: NEG
34977: PUSH
34978: EMPTY
34979: LIST
34980: LIST
34981: PUSH
34982: LD_INT 1
34984: NEG
34985: PUSH
34986: LD_INT 2
34988: NEG
34989: PUSH
34990: EMPTY
34991: LIST
34992: LIST
34993: PUSH
34994: LD_INT 0
34996: PUSH
34997: LD_INT 2
34999: NEG
35000: PUSH
35001: EMPTY
35002: LIST
35003: LIST
35004: PUSH
35005: LD_INT 1
35007: PUSH
35008: LD_INT 1
35010: NEG
35011: PUSH
35012: EMPTY
35013: LIST
35014: LIST
35015: PUSH
35016: LD_INT 2
35018: PUSH
35019: LD_INT 0
35021: PUSH
35022: EMPTY
35023: LIST
35024: LIST
35025: PUSH
35026: LD_INT 2
35028: PUSH
35029: LD_INT 1
35031: PUSH
35032: EMPTY
35033: LIST
35034: LIST
35035: PUSH
35036: LD_INT 2
35038: PUSH
35039: LD_INT 2
35041: PUSH
35042: EMPTY
35043: LIST
35044: LIST
35045: PUSH
35046: LD_INT 1
35048: PUSH
35049: LD_INT 2
35051: PUSH
35052: EMPTY
35053: LIST
35054: LIST
35055: PUSH
35056: LD_INT 0
35058: PUSH
35059: LD_INT 2
35061: PUSH
35062: EMPTY
35063: LIST
35064: LIST
35065: PUSH
35066: LD_INT 1
35068: NEG
35069: PUSH
35070: LD_INT 1
35072: PUSH
35073: EMPTY
35074: LIST
35075: LIST
35076: PUSH
35077: LD_INT 2
35079: NEG
35080: PUSH
35081: LD_INT 0
35083: PUSH
35084: EMPTY
35085: LIST
35086: LIST
35087: PUSH
35088: LD_INT 2
35090: NEG
35091: PUSH
35092: LD_INT 1
35094: NEG
35095: PUSH
35096: EMPTY
35097: LIST
35098: LIST
35099: PUSH
35100: LD_INT 2
35102: NEG
35103: PUSH
35104: LD_INT 2
35106: NEG
35107: PUSH
35108: EMPTY
35109: LIST
35110: LIST
35111: PUSH
35112: EMPTY
35113: LIST
35114: LIST
35115: LIST
35116: LIST
35117: LIST
35118: LIST
35119: LIST
35120: LIST
35121: LIST
35122: LIST
35123: LIST
35124: LIST
35125: LIST
35126: LIST
35127: LIST
35128: LIST
35129: LIST
35130: LIST
35131: LIST
35132: ST_TO_ADDR
// fDepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
35133: LD_ADDR_VAR 0 19
35137: PUSH
35138: LD_INT 0
35140: PUSH
35141: LD_INT 0
35143: PUSH
35144: EMPTY
35145: LIST
35146: LIST
35147: PUSH
35148: LD_INT 0
35150: PUSH
35151: LD_INT 1
35153: NEG
35154: PUSH
35155: EMPTY
35156: LIST
35157: LIST
35158: PUSH
35159: LD_INT 1
35161: PUSH
35162: LD_INT 0
35164: PUSH
35165: EMPTY
35166: LIST
35167: LIST
35168: PUSH
35169: LD_INT 1
35171: PUSH
35172: LD_INT 1
35174: PUSH
35175: EMPTY
35176: LIST
35177: LIST
35178: PUSH
35179: LD_INT 0
35181: PUSH
35182: LD_INT 1
35184: PUSH
35185: EMPTY
35186: LIST
35187: LIST
35188: PUSH
35189: LD_INT 1
35191: NEG
35192: PUSH
35193: LD_INT 0
35195: PUSH
35196: EMPTY
35197: LIST
35198: LIST
35199: PUSH
35200: LD_INT 1
35202: NEG
35203: PUSH
35204: LD_INT 1
35206: NEG
35207: PUSH
35208: EMPTY
35209: LIST
35210: LIST
35211: PUSH
35212: LD_INT 1
35214: NEG
35215: PUSH
35216: LD_INT 2
35218: NEG
35219: PUSH
35220: EMPTY
35221: LIST
35222: LIST
35223: PUSH
35224: LD_INT 0
35226: PUSH
35227: LD_INT 2
35229: NEG
35230: PUSH
35231: EMPTY
35232: LIST
35233: LIST
35234: PUSH
35235: LD_INT 1
35237: PUSH
35238: LD_INT 1
35240: NEG
35241: PUSH
35242: EMPTY
35243: LIST
35244: LIST
35245: PUSH
35246: LD_INT 2
35248: PUSH
35249: LD_INT 0
35251: PUSH
35252: EMPTY
35253: LIST
35254: LIST
35255: PUSH
35256: LD_INT 2
35258: PUSH
35259: LD_INT 1
35261: PUSH
35262: EMPTY
35263: LIST
35264: LIST
35265: PUSH
35266: LD_INT 2
35268: PUSH
35269: LD_INT 2
35271: PUSH
35272: EMPTY
35273: LIST
35274: LIST
35275: PUSH
35276: LD_INT 1
35278: PUSH
35279: LD_INT 2
35281: PUSH
35282: EMPTY
35283: LIST
35284: LIST
35285: PUSH
35286: LD_INT 0
35288: PUSH
35289: LD_INT 2
35291: PUSH
35292: EMPTY
35293: LIST
35294: LIST
35295: PUSH
35296: LD_INT 1
35298: NEG
35299: PUSH
35300: LD_INT 1
35302: PUSH
35303: EMPTY
35304: LIST
35305: LIST
35306: PUSH
35307: LD_INT 2
35309: NEG
35310: PUSH
35311: LD_INT 0
35313: PUSH
35314: EMPTY
35315: LIST
35316: LIST
35317: PUSH
35318: LD_INT 2
35320: NEG
35321: PUSH
35322: LD_INT 1
35324: NEG
35325: PUSH
35326: EMPTY
35327: LIST
35328: LIST
35329: PUSH
35330: LD_INT 2
35332: NEG
35333: PUSH
35334: LD_INT 2
35336: NEG
35337: PUSH
35338: EMPTY
35339: LIST
35340: LIST
35341: PUSH
35342: EMPTY
35343: LIST
35344: LIST
35345: LIST
35346: LIST
35347: LIST
35348: LIST
35349: LIST
35350: LIST
35351: LIST
35352: LIST
35353: LIST
35354: LIST
35355: LIST
35356: LIST
35357: LIST
35358: LIST
35359: LIST
35360: LIST
35361: LIST
35362: ST_TO_ADDR
// fDepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
35363: LD_ADDR_VAR 0 20
35367: PUSH
35368: LD_INT 0
35370: PUSH
35371: LD_INT 0
35373: PUSH
35374: EMPTY
35375: LIST
35376: LIST
35377: PUSH
35378: LD_INT 0
35380: PUSH
35381: LD_INT 1
35383: NEG
35384: PUSH
35385: EMPTY
35386: LIST
35387: LIST
35388: PUSH
35389: LD_INT 1
35391: PUSH
35392: LD_INT 0
35394: PUSH
35395: EMPTY
35396: LIST
35397: LIST
35398: PUSH
35399: LD_INT 1
35401: PUSH
35402: LD_INT 1
35404: PUSH
35405: EMPTY
35406: LIST
35407: LIST
35408: PUSH
35409: LD_INT 0
35411: PUSH
35412: LD_INT 1
35414: PUSH
35415: EMPTY
35416: LIST
35417: LIST
35418: PUSH
35419: LD_INT 1
35421: NEG
35422: PUSH
35423: LD_INT 0
35425: PUSH
35426: EMPTY
35427: LIST
35428: LIST
35429: PUSH
35430: LD_INT 1
35432: NEG
35433: PUSH
35434: LD_INT 1
35436: NEG
35437: PUSH
35438: EMPTY
35439: LIST
35440: LIST
35441: PUSH
35442: LD_INT 1
35444: NEG
35445: PUSH
35446: LD_INT 2
35448: NEG
35449: PUSH
35450: EMPTY
35451: LIST
35452: LIST
35453: PUSH
35454: LD_INT 0
35456: PUSH
35457: LD_INT 2
35459: NEG
35460: PUSH
35461: EMPTY
35462: LIST
35463: LIST
35464: PUSH
35465: LD_INT 1
35467: PUSH
35468: LD_INT 1
35470: NEG
35471: PUSH
35472: EMPTY
35473: LIST
35474: LIST
35475: PUSH
35476: LD_INT 2
35478: PUSH
35479: LD_INT 0
35481: PUSH
35482: EMPTY
35483: LIST
35484: LIST
35485: PUSH
35486: LD_INT 2
35488: PUSH
35489: LD_INT 1
35491: PUSH
35492: EMPTY
35493: LIST
35494: LIST
35495: PUSH
35496: LD_INT 2
35498: PUSH
35499: LD_INT 2
35501: PUSH
35502: EMPTY
35503: LIST
35504: LIST
35505: PUSH
35506: LD_INT 1
35508: PUSH
35509: LD_INT 2
35511: PUSH
35512: EMPTY
35513: LIST
35514: LIST
35515: PUSH
35516: LD_INT 0
35518: PUSH
35519: LD_INT 2
35521: PUSH
35522: EMPTY
35523: LIST
35524: LIST
35525: PUSH
35526: LD_INT 1
35528: NEG
35529: PUSH
35530: LD_INT 1
35532: PUSH
35533: EMPTY
35534: LIST
35535: LIST
35536: PUSH
35537: LD_INT 2
35539: NEG
35540: PUSH
35541: LD_INT 0
35543: PUSH
35544: EMPTY
35545: LIST
35546: LIST
35547: PUSH
35548: LD_INT 2
35550: NEG
35551: PUSH
35552: LD_INT 1
35554: NEG
35555: PUSH
35556: EMPTY
35557: LIST
35558: LIST
35559: PUSH
35560: LD_INT 2
35562: NEG
35563: PUSH
35564: LD_INT 2
35566: NEG
35567: PUSH
35568: EMPTY
35569: LIST
35570: LIST
35571: PUSH
35572: EMPTY
35573: LIST
35574: LIST
35575: LIST
35576: LIST
35577: LIST
35578: LIST
35579: LIST
35580: LIST
35581: LIST
35582: LIST
35583: LIST
35584: LIST
35585: LIST
35586: LIST
35587: LIST
35588: LIST
35589: LIST
35590: LIST
35591: LIST
35592: ST_TO_ADDR
// fDepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
35593: LD_ADDR_VAR 0 21
35597: PUSH
35598: LD_INT 0
35600: PUSH
35601: LD_INT 0
35603: PUSH
35604: EMPTY
35605: LIST
35606: LIST
35607: PUSH
35608: LD_INT 0
35610: PUSH
35611: LD_INT 1
35613: NEG
35614: PUSH
35615: EMPTY
35616: LIST
35617: LIST
35618: PUSH
35619: LD_INT 1
35621: PUSH
35622: LD_INT 0
35624: PUSH
35625: EMPTY
35626: LIST
35627: LIST
35628: PUSH
35629: LD_INT 1
35631: PUSH
35632: LD_INT 1
35634: PUSH
35635: EMPTY
35636: LIST
35637: LIST
35638: PUSH
35639: LD_INT 0
35641: PUSH
35642: LD_INT 1
35644: PUSH
35645: EMPTY
35646: LIST
35647: LIST
35648: PUSH
35649: LD_INT 1
35651: NEG
35652: PUSH
35653: LD_INT 0
35655: PUSH
35656: EMPTY
35657: LIST
35658: LIST
35659: PUSH
35660: LD_INT 1
35662: NEG
35663: PUSH
35664: LD_INT 1
35666: NEG
35667: PUSH
35668: EMPTY
35669: LIST
35670: LIST
35671: PUSH
35672: LD_INT 1
35674: NEG
35675: PUSH
35676: LD_INT 2
35678: NEG
35679: PUSH
35680: EMPTY
35681: LIST
35682: LIST
35683: PUSH
35684: LD_INT 0
35686: PUSH
35687: LD_INT 2
35689: NEG
35690: PUSH
35691: EMPTY
35692: LIST
35693: LIST
35694: PUSH
35695: LD_INT 1
35697: PUSH
35698: LD_INT 1
35700: NEG
35701: PUSH
35702: EMPTY
35703: LIST
35704: LIST
35705: PUSH
35706: LD_INT 2
35708: PUSH
35709: LD_INT 0
35711: PUSH
35712: EMPTY
35713: LIST
35714: LIST
35715: PUSH
35716: LD_INT 2
35718: PUSH
35719: LD_INT 1
35721: PUSH
35722: EMPTY
35723: LIST
35724: LIST
35725: PUSH
35726: LD_INT 2
35728: PUSH
35729: LD_INT 2
35731: PUSH
35732: EMPTY
35733: LIST
35734: LIST
35735: PUSH
35736: LD_INT 1
35738: PUSH
35739: LD_INT 2
35741: PUSH
35742: EMPTY
35743: LIST
35744: LIST
35745: PUSH
35746: LD_INT 0
35748: PUSH
35749: LD_INT 2
35751: PUSH
35752: EMPTY
35753: LIST
35754: LIST
35755: PUSH
35756: LD_INT 1
35758: NEG
35759: PUSH
35760: LD_INT 1
35762: PUSH
35763: EMPTY
35764: LIST
35765: LIST
35766: PUSH
35767: LD_INT 2
35769: NEG
35770: PUSH
35771: LD_INT 0
35773: PUSH
35774: EMPTY
35775: LIST
35776: LIST
35777: PUSH
35778: LD_INT 2
35780: NEG
35781: PUSH
35782: LD_INT 1
35784: NEG
35785: PUSH
35786: EMPTY
35787: LIST
35788: LIST
35789: PUSH
35790: LD_INT 2
35792: NEG
35793: PUSH
35794: LD_INT 2
35796: NEG
35797: PUSH
35798: EMPTY
35799: LIST
35800: LIST
35801: PUSH
35802: EMPTY
35803: LIST
35804: LIST
35805: LIST
35806: LIST
35807: LIST
35808: LIST
35809: LIST
35810: LIST
35811: LIST
35812: LIST
35813: LIST
35814: LIST
35815: LIST
35816: LIST
35817: LIST
35818: LIST
35819: LIST
35820: LIST
35821: LIST
35822: ST_TO_ADDR
// fDepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
35823: LD_ADDR_VAR 0 22
35827: PUSH
35828: LD_INT 0
35830: PUSH
35831: LD_INT 0
35833: PUSH
35834: EMPTY
35835: LIST
35836: LIST
35837: PUSH
35838: LD_INT 0
35840: PUSH
35841: LD_INT 1
35843: NEG
35844: PUSH
35845: EMPTY
35846: LIST
35847: LIST
35848: PUSH
35849: LD_INT 1
35851: PUSH
35852: LD_INT 0
35854: PUSH
35855: EMPTY
35856: LIST
35857: LIST
35858: PUSH
35859: LD_INT 1
35861: PUSH
35862: LD_INT 1
35864: PUSH
35865: EMPTY
35866: LIST
35867: LIST
35868: PUSH
35869: LD_INT 0
35871: PUSH
35872: LD_INT 1
35874: PUSH
35875: EMPTY
35876: LIST
35877: LIST
35878: PUSH
35879: LD_INT 1
35881: NEG
35882: PUSH
35883: LD_INT 0
35885: PUSH
35886: EMPTY
35887: LIST
35888: LIST
35889: PUSH
35890: LD_INT 1
35892: NEG
35893: PUSH
35894: LD_INT 1
35896: NEG
35897: PUSH
35898: EMPTY
35899: LIST
35900: LIST
35901: PUSH
35902: LD_INT 1
35904: NEG
35905: PUSH
35906: LD_INT 2
35908: NEG
35909: PUSH
35910: EMPTY
35911: LIST
35912: LIST
35913: PUSH
35914: LD_INT 0
35916: PUSH
35917: LD_INT 2
35919: NEG
35920: PUSH
35921: EMPTY
35922: LIST
35923: LIST
35924: PUSH
35925: LD_INT 1
35927: PUSH
35928: LD_INT 1
35930: NEG
35931: PUSH
35932: EMPTY
35933: LIST
35934: LIST
35935: PUSH
35936: LD_INT 2
35938: PUSH
35939: LD_INT 0
35941: PUSH
35942: EMPTY
35943: LIST
35944: LIST
35945: PUSH
35946: LD_INT 2
35948: PUSH
35949: LD_INT 1
35951: PUSH
35952: EMPTY
35953: LIST
35954: LIST
35955: PUSH
35956: LD_INT 2
35958: PUSH
35959: LD_INT 2
35961: PUSH
35962: EMPTY
35963: LIST
35964: LIST
35965: PUSH
35966: LD_INT 1
35968: PUSH
35969: LD_INT 2
35971: PUSH
35972: EMPTY
35973: LIST
35974: LIST
35975: PUSH
35976: LD_INT 0
35978: PUSH
35979: LD_INT 2
35981: PUSH
35982: EMPTY
35983: LIST
35984: LIST
35985: PUSH
35986: LD_INT 1
35988: NEG
35989: PUSH
35990: LD_INT 1
35992: PUSH
35993: EMPTY
35994: LIST
35995: LIST
35996: PUSH
35997: LD_INT 2
35999: NEG
36000: PUSH
36001: LD_INT 0
36003: PUSH
36004: EMPTY
36005: LIST
36006: LIST
36007: PUSH
36008: LD_INT 2
36010: NEG
36011: PUSH
36012: LD_INT 1
36014: NEG
36015: PUSH
36016: EMPTY
36017: LIST
36018: LIST
36019: PUSH
36020: LD_INT 2
36022: NEG
36023: PUSH
36024: LD_INT 2
36026: NEG
36027: PUSH
36028: EMPTY
36029: LIST
36030: LIST
36031: PUSH
36032: EMPTY
36033: LIST
36034: LIST
36035: LIST
36036: LIST
36037: LIST
36038: LIST
36039: LIST
36040: LIST
36041: LIST
36042: LIST
36043: LIST
36044: LIST
36045: LIST
36046: LIST
36047: LIST
36048: LIST
36049: LIST
36050: LIST
36051: LIST
36052: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
36053: LD_ADDR_VAR 0 23
36057: PUSH
36058: LD_INT 0
36060: PUSH
36061: LD_INT 0
36063: PUSH
36064: EMPTY
36065: LIST
36066: LIST
36067: PUSH
36068: LD_INT 0
36070: PUSH
36071: LD_INT 1
36073: NEG
36074: PUSH
36075: EMPTY
36076: LIST
36077: LIST
36078: PUSH
36079: LD_INT 1
36081: PUSH
36082: LD_INT 0
36084: PUSH
36085: EMPTY
36086: LIST
36087: LIST
36088: PUSH
36089: LD_INT 1
36091: PUSH
36092: LD_INT 1
36094: PUSH
36095: EMPTY
36096: LIST
36097: LIST
36098: PUSH
36099: LD_INT 0
36101: PUSH
36102: LD_INT 1
36104: PUSH
36105: EMPTY
36106: LIST
36107: LIST
36108: PUSH
36109: LD_INT 1
36111: NEG
36112: PUSH
36113: LD_INT 0
36115: PUSH
36116: EMPTY
36117: LIST
36118: LIST
36119: PUSH
36120: LD_INT 1
36122: NEG
36123: PUSH
36124: LD_INT 1
36126: NEG
36127: PUSH
36128: EMPTY
36129: LIST
36130: LIST
36131: PUSH
36132: LD_INT 1
36134: NEG
36135: PUSH
36136: LD_INT 2
36138: NEG
36139: PUSH
36140: EMPTY
36141: LIST
36142: LIST
36143: PUSH
36144: LD_INT 0
36146: PUSH
36147: LD_INT 2
36149: NEG
36150: PUSH
36151: EMPTY
36152: LIST
36153: LIST
36154: PUSH
36155: LD_INT 1
36157: PUSH
36158: LD_INT 1
36160: NEG
36161: PUSH
36162: EMPTY
36163: LIST
36164: LIST
36165: PUSH
36166: LD_INT 2
36168: PUSH
36169: LD_INT 0
36171: PUSH
36172: EMPTY
36173: LIST
36174: LIST
36175: PUSH
36176: LD_INT 2
36178: PUSH
36179: LD_INT 1
36181: PUSH
36182: EMPTY
36183: LIST
36184: LIST
36185: PUSH
36186: LD_INT 2
36188: PUSH
36189: LD_INT 2
36191: PUSH
36192: EMPTY
36193: LIST
36194: LIST
36195: PUSH
36196: LD_INT 1
36198: PUSH
36199: LD_INT 2
36201: PUSH
36202: EMPTY
36203: LIST
36204: LIST
36205: PUSH
36206: LD_INT 0
36208: PUSH
36209: LD_INT 2
36211: PUSH
36212: EMPTY
36213: LIST
36214: LIST
36215: PUSH
36216: LD_INT 1
36218: NEG
36219: PUSH
36220: LD_INT 1
36222: PUSH
36223: EMPTY
36224: LIST
36225: LIST
36226: PUSH
36227: LD_INT 2
36229: NEG
36230: PUSH
36231: LD_INT 0
36233: PUSH
36234: EMPTY
36235: LIST
36236: LIST
36237: PUSH
36238: LD_INT 2
36240: NEG
36241: PUSH
36242: LD_INT 1
36244: NEG
36245: PUSH
36246: EMPTY
36247: LIST
36248: LIST
36249: PUSH
36250: LD_INT 2
36252: NEG
36253: PUSH
36254: LD_INT 2
36256: NEG
36257: PUSH
36258: EMPTY
36259: LIST
36260: LIST
36261: PUSH
36262: LD_INT 2
36264: NEG
36265: PUSH
36266: LD_INT 3
36268: NEG
36269: PUSH
36270: EMPTY
36271: LIST
36272: LIST
36273: PUSH
36274: LD_INT 1
36276: NEG
36277: PUSH
36278: LD_INT 3
36280: NEG
36281: PUSH
36282: EMPTY
36283: LIST
36284: LIST
36285: PUSH
36286: LD_INT 1
36288: PUSH
36289: LD_INT 2
36291: NEG
36292: PUSH
36293: EMPTY
36294: LIST
36295: LIST
36296: PUSH
36297: LD_INT 2
36299: PUSH
36300: LD_INT 1
36302: NEG
36303: PUSH
36304: EMPTY
36305: LIST
36306: LIST
36307: PUSH
36308: EMPTY
36309: LIST
36310: LIST
36311: LIST
36312: LIST
36313: LIST
36314: LIST
36315: LIST
36316: LIST
36317: LIST
36318: LIST
36319: LIST
36320: LIST
36321: LIST
36322: LIST
36323: LIST
36324: LIST
36325: LIST
36326: LIST
36327: LIST
36328: LIST
36329: LIST
36330: LIST
36331: LIST
36332: ST_TO_ADDR
// fDepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
36333: LD_ADDR_VAR 0 24
36337: PUSH
36338: LD_INT 0
36340: PUSH
36341: LD_INT 0
36343: PUSH
36344: EMPTY
36345: LIST
36346: LIST
36347: PUSH
36348: LD_INT 0
36350: PUSH
36351: LD_INT 1
36353: NEG
36354: PUSH
36355: EMPTY
36356: LIST
36357: LIST
36358: PUSH
36359: LD_INT 1
36361: PUSH
36362: LD_INT 0
36364: PUSH
36365: EMPTY
36366: LIST
36367: LIST
36368: PUSH
36369: LD_INT 1
36371: PUSH
36372: LD_INT 1
36374: PUSH
36375: EMPTY
36376: LIST
36377: LIST
36378: PUSH
36379: LD_INT 0
36381: PUSH
36382: LD_INT 1
36384: PUSH
36385: EMPTY
36386: LIST
36387: LIST
36388: PUSH
36389: LD_INT 1
36391: NEG
36392: PUSH
36393: LD_INT 0
36395: PUSH
36396: EMPTY
36397: LIST
36398: LIST
36399: PUSH
36400: LD_INT 1
36402: NEG
36403: PUSH
36404: LD_INT 1
36406: NEG
36407: PUSH
36408: EMPTY
36409: LIST
36410: LIST
36411: PUSH
36412: LD_INT 1
36414: NEG
36415: PUSH
36416: LD_INT 2
36418: NEG
36419: PUSH
36420: EMPTY
36421: LIST
36422: LIST
36423: PUSH
36424: LD_INT 0
36426: PUSH
36427: LD_INT 2
36429: NEG
36430: PUSH
36431: EMPTY
36432: LIST
36433: LIST
36434: PUSH
36435: LD_INT 1
36437: PUSH
36438: LD_INT 1
36440: NEG
36441: PUSH
36442: EMPTY
36443: LIST
36444: LIST
36445: PUSH
36446: LD_INT 2
36448: PUSH
36449: LD_INT 0
36451: PUSH
36452: EMPTY
36453: LIST
36454: LIST
36455: PUSH
36456: LD_INT 2
36458: PUSH
36459: LD_INT 1
36461: PUSH
36462: EMPTY
36463: LIST
36464: LIST
36465: PUSH
36466: LD_INT 2
36468: PUSH
36469: LD_INT 2
36471: PUSH
36472: EMPTY
36473: LIST
36474: LIST
36475: PUSH
36476: LD_INT 1
36478: PUSH
36479: LD_INT 2
36481: PUSH
36482: EMPTY
36483: LIST
36484: LIST
36485: PUSH
36486: LD_INT 0
36488: PUSH
36489: LD_INT 2
36491: PUSH
36492: EMPTY
36493: LIST
36494: LIST
36495: PUSH
36496: LD_INT 1
36498: NEG
36499: PUSH
36500: LD_INT 1
36502: PUSH
36503: EMPTY
36504: LIST
36505: LIST
36506: PUSH
36507: LD_INT 2
36509: NEG
36510: PUSH
36511: LD_INT 0
36513: PUSH
36514: EMPTY
36515: LIST
36516: LIST
36517: PUSH
36518: LD_INT 2
36520: NEG
36521: PUSH
36522: LD_INT 1
36524: NEG
36525: PUSH
36526: EMPTY
36527: LIST
36528: LIST
36529: PUSH
36530: LD_INT 2
36532: NEG
36533: PUSH
36534: LD_INT 2
36536: NEG
36537: PUSH
36538: EMPTY
36539: LIST
36540: LIST
36541: PUSH
36542: LD_INT 1
36544: PUSH
36545: LD_INT 2
36547: NEG
36548: PUSH
36549: EMPTY
36550: LIST
36551: LIST
36552: PUSH
36553: LD_INT 2
36555: PUSH
36556: LD_INT 1
36558: NEG
36559: PUSH
36560: EMPTY
36561: LIST
36562: LIST
36563: PUSH
36564: LD_INT 3
36566: PUSH
36567: LD_INT 1
36569: PUSH
36570: EMPTY
36571: LIST
36572: LIST
36573: PUSH
36574: LD_INT 3
36576: PUSH
36577: LD_INT 2
36579: PUSH
36580: EMPTY
36581: LIST
36582: LIST
36583: PUSH
36584: EMPTY
36585: LIST
36586: LIST
36587: LIST
36588: LIST
36589: LIST
36590: LIST
36591: LIST
36592: LIST
36593: LIST
36594: LIST
36595: LIST
36596: LIST
36597: LIST
36598: LIST
36599: LIST
36600: LIST
36601: LIST
36602: LIST
36603: LIST
36604: LIST
36605: LIST
36606: LIST
36607: LIST
36608: ST_TO_ADDR
// fDepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
36609: LD_ADDR_VAR 0 25
36613: PUSH
36614: LD_INT 0
36616: PUSH
36617: LD_INT 0
36619: PUSH
36620: EMPTY
36621: LIST
36622: LIST
36623: PUSH
36624: LD_INT 0
36626: PUSH
36627: LD_INT 1
36629: NEG
36630: PUSH
36631: EMPTY
36632: LIST
36633: LIST
36634: PUSH
36635: LD_INT 1
36637: PUSH
36638: LD_INT 0
36640: PUSH
36641: EMPTY
36642: LIST
36643: LIST
36644: PUSH
36645: LD_INT 1
36647: PUSH
36648: LD_INT 1
36650: PUSH
36651: EMPTY
36652: LIST
36653: LIST
36654: PUSH
36655: LD_INT 0
36657: PUSH
36658: LD_INT 1
36660: PUSH
36661: EMPTY
36662: LIST
36663: LIST
36664: PUSH
36665: LD_INT 1
36667: NEG
36668: PUSH
36669: LD_INT 0
36671: PUSH
36672: EMPTY
36673: LIST
36674: LIST
36675: PUSH
36676: LD_INT 1
36678: NEG
36679: PUSH
36680: LD_INT 1
36682: NEG
36683: PUSH
36684: EMPTY
36685: LIST
36686: LIST
36687: PUSH
36688: LD_INT 1
36690: NEG
36691: PUSH
36692: LD_INT 2
36694: NEG
36695: PUSH
36696: EMPTY
36697: LIST
36698: LIST
36699: PUSH
36700: LD_INT 0
36702: PUSH
36703: LD_INT 2
36705: NEG
36706: PUSH
36707: EMPTY
36708: LIST
36709: LIST
36710: PUSH
36711: LD_INT 1
36713: PUSH
36714: LD_INT 1
36716: NEG
36717: PUSH
36718: EMPTY
36719: LIST
36720: LIST
36721: PUSH
36722: LD_INT 2
36724: PUSH
36725: LD_INT 0
36727: PUSH
36728: EMPTY
36729: LIST
36730: LIST
36731: PUSH
36732: LD_INT 2
36734: PUSH
36735: LD_INT 1
36737: PUSH
36738: EMPTY
36739: LIST
36740: LIST
36741: PUSH
36742: LD_INT 2
36744: PUSH
36745: LD_INT 2
36747: PUSH
36748: EMPTY
36749: LIST
36750: LIST
36751: PUSH
36752: LD_INT 1
36754: PUSH
36755: LD_INT 2
36757: PUSH
36758: EMPTY
36759: LIST
36760: LIST
36761: PUSH
36762: LD_INT 0
36764: PUSH
36765: LD_INT 2
36767: PUSH
36768: EMPTY
36769: LIST
36770: LIST
36771: PUSH
36772: LD_INT 1
36774: NEG
36775: PUSH
36776: LD_INT 1
36778: PUSH
36779: EMPTY
36780: LIST
36781: LIST
36782: PUSH
36783: LD_INT 2
36785: NEG
36786: PUSH
36787: LD_INT 0
36789: PUSH
36790: EMPTY
36791: LIST
36792: LIST
36793: PUSH
36794: LD_INT 2
36796: NEG
36797: PUSH
36798: LD_INT 1
36800: NEG
36801: PUSH
36802: EMPTY
36803: LIST
36804: LIST
36805: PUSH
36806: LD_INT 2
36808: NEG
36809: PUSH
36810: LD_INT 2
36812: NEG
36813: PUSH
36814: EMPTY
36815: LIST
36816: LIST
36817: PUSH
36818: LD_INT 3
36820: PUSH
36821: LD_INT 1
36823: PUSH
36824: EMPTY
36825: LIST
36826: LIST
36827: PUSH
36828: LD_INT 3
36830: PUSH
36831: LD_INT 2
36833: PUSH
36834: EMPTY
36835: LIST
36836: LIST
36837: PUSH
36838: LD_INT 2
36840: PUSH
36841: LD_INT 3
36843: PUSH
36844: EMPTY
36845: LIST
36846: LIST
36847: PUSH
36848: LD_INT 1
36850: PUSH
36851: LD_INT 3
36853: PUSH
36854: EMPTY
36855: LIST
36856: LIST
36857: PUSH
36858: EMPTY
36859: LIST
36860: LIST
36861: LIST
36862: LIST
36863: LIST
36864: LIST
36865: LIST
36866: LIST
36867: LIST
36868: LIST
36869: LIST
36870: LIST
36871: LIST
36872: LIST
36873: LIST
36874: LIST
36875: LIST
36876: LIST
36877: LIST
36878: LIST
36879: LIST
36880: LIST
36881: LIST
36882: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
36883: LD_ADDR_VAR 0 26
36887: PUSH
36888: LD_INT 0
36890: PUSH
36891: LD_INT 0
36893: PUSH
36894: EMPTY
36895: LIST
36896: LIST
36897: PUSH
36898: LD_INT 0
36900: PUSH
36901: LD_INT 1
36903: NEG
36904: PUSH
36905: EMPTY
36906: LIST
36907: LIST
36908: PUSH
36909: LD_INT 1
36911: PUSH
36912: LD_INT 0
36914: PUSH
36915: EMPTY
36916: LIST
36917: LIST
36918: PUSH
36919: LD_INT 1
36921: PUSH
36922: LD_INT 1
36924: PUSH
36925: EMPTY
36926: LIST
36927: LIST
36928: PUSH
36929: LD_INT 0
36931: PUSH
36932: LD_INT 1
36934: PUSH
36935: EMPTY
36936: LIST
36937: LIST
36938: PUSH
36939: LD_INT 1
36941: NEG
36942: PUSH
36943: LD_INT 0
36945: PUSH
36946: EMPTY
36947: LIST
36948: LIST
36949: PUSH
36950: LD_INT 1
36952: NEG
36953: PUSH
36954: LD_INT 1
36956: NEG
36957: PUSH
36958: EMPTY
36959: LIST
36960: LIST
36961: PUSH
36962: LD_INT 1
36964: NEG
36965: PUSH
36966: LD_INT 2
36968: NEG
36969: PUSH
36970: EMPTY
36971: LIST
36972: LIST
36973: PUSH
36974: LD_INT 0
36976: PUSH
36977: LD_INT 2
36979: NEG
36980: PUSH
36981: EMPTY
36982: LIST
36983: LIST
36984: PUSH
36985: LD_INT 1
36987: PUSH
36988: LD_INT 1
36990: NEG
36991: PUSH
36992: EMPTY
36993: LIST
36994: LIST
36995: PUSH
36996: LD_INT 2
36998: PUSH
36999: LD_INT 0
37001: PUSH
37002: EMPTY
37003: LIST
37004: LIST
37005: PUSH
37006: LD_INT 2
37008: PUSH
37009: LD_INT 1
37011: PUSH
37012: EMPTY
37013: LIST
37014: LIST
37015: PUSH
37016: LD_INT 2
37018: PUSH
37019: LD_INT 2
37021: PUSH
37022: EMPTY
37023: LIST
37024: LIST
37025: PUSH
37026: LD_INT 1
37028: PUSH
37029: LD_INT 2
37031: PUSH
37032: EMPTY
37033: LIST
37034: LIST
37035: PUSH
37036: LD_INT 0
37038: PUSH
37039: LD_INT 2
37041: PUSH
37042: EMPTY
37043: LIST
37044: LIST
37045: PUSH
37046: LD_INT 1
37048: NEG
37049: PUSH
37050: LD_INT 1
37052: PUSH
37053: EMPTY
37054: LIST
37055: LIST
37056: PUSH
37057: LD_INT 2
37059: NEG
37060: PUSH
37061: LD_INT 0
37063: PUSH
37064: EMPTY
37065: LIST
37066: LIST
37067: PUSH
37068: LD_INT 2
37070: NEG
37071: PUSH
37072: LD_INT 1
37074: NEG
37075: PUSH
37076: EMPTY
37077: LIST
37078: LIST
37079: PUSH
37080: LD_INT 2
37082: NEG
37083: PUSH
37084: LD_INT 2
37086: NEG
37087: PUSH
37088: EMPTY
37089: LIST
37090: LIST
37091: PUSH
37092: LD_INT 2
37094: PUSH
37095: LD_INT 3
37097: PUSH
37098: EMPTY
37099: LIST
37100: LIST
37101: PUSH
37102: LD_INT 1
37104: PUSH
37105: LD_INT 3
37107: PUSH
37108: EMPTY
37109: LIST
37110: LIST
37111: PUSH
37112: LD_INT 1
37114: NEG
37115: PUSH
37116: LD_INT 2
37118: PUSH
37119: EMPTY
37120: LIST
37121: LIST
37122: PUSH
37123: LD_INT 2
37125: NEG
37126: PUSH
37127: LD_INT 1
37129: PUSH
37130: EMPTY
37131: LIST
37132: LIST
37133: PUSH
37134: EMPTY
37135: LIST
37136: LIST
37137: LIST
37138: LIST
37139: LIST
37140: LIST
37141: LIST
37142: LIST
37143: LIST
37144: LIST
37145: LIST
37146: LIST
37147: LIST
37148: LIST
37149: LIST
37150: LIST
37151: LIST
37152: LIST
37153: LIST
37154: LIST
37155: LIST
37156: LIST
37157: LIST
37158: ST_TO_ADDR
// fDepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
37159: LD_ADDR_VAR 0 27
37163: PUSH
37164: LD_INT 0
37166: PUSH
37167: LD_INT 0
37169: PUSH
37170: EMPTY
37171: LIST
37172: LIST
37173: PUSH
37174: LD_INT 0
37176: PUSH
37177: LD_INT 1
37179: NEG
37180: PUSH
37181: EMPTY
37182: LIST
37183: LIST
37184: PUSH
37185: LD_INT 1
37187: PUSH
37188: LD_INT 0
37190: PUSH
37191: EMPTY
37192: LIST
37193: LIST
37194: PUSH
37195: LD_INT 1
37197: PUSH
37198: LD_INT 1
37200: PUSH
37201: EMPTY
37202: LIST
37203: LIST
37204: PUSH
37205: LD_INT 0
37207: PUSH
37208: LD_INT 1
37210: PUSH
37211: EMPTY
37212: LIST
37213: LIST
37214: PUSH
37215: LD_INT 1
37217: NEG
37218: PUSH
37219: LD_INT 0
37221: PUSH
37222: EMPTY
37223: LIST
37224: LIST
37225: PUSH
37226: LD_INT 1
37228: NEG
37229: PUSH
37230: LD_INT 1
37232: NEG
37233: PUSH
37234: EMPTY
37235: LIST
37236: LIST
37237: PUSH
37238: LD_INT 1
37240: NEG
37241: PUSH
37242: LD_INT 2
37244: NEG
37245: PUSH
37246: EMPTY
37247: LIST
37248: LIST
37249: PUSH
37250: LD_INT 0
37252: PUSH
37253: LD_INT 2
37255: NEG
37256: PUSH
37257: EMPTY
37258: LIST
37259: LIST
37260: PUSH
37261: LD_INT 1
37263: PUSH
37264: LD_INT 1
37266: NEG
37267: PUSH
37268: EMPTY
37269: LIST
37270: LIST
37271: PUSH
37272: LD_INT 2
37274: PUSH
37275: LD_INT 0
37277: PUSH
37278: EMPTY
37279: LIST
37280: LIST
37281: PUSH
37282: LD_INT 2
37284: PUSH
37285: LD_INT 1
37287: PUSH
37288: EMPTY
37289: LIST
37290: LIST
37291: PUSH
37292: LD_INT 2
37294: PUSH
37295: LD_INT 2
37297: PUSH
37298: EMPTY
37299: LIST
37300: LIST
37301: PUSH
37302: LD_INT 1
37304: PUSH
37305: LD_INT 2
37307: PUSH
37308: EMPTY
37309: LIST
37310: LIST
37311: PUSH
37312: LD_INT 0
37314: PUSH
37315: LD_INT 2
37317: PUSH
37318: EMPTY
37319: LIST
37320: LIST
37321: PUSH
37322: LD_INT 1
37324: NEG
37325: PUSH
37326: LD_INT 1
37328: PUSH
37329: EMPTY
37330: LIST
37331: LIST
37332: PUSH
37333: LD_INT 2
37335: NEG
37336: PUSH
37337: LD_INT 0
37339: PUSH
37340: EMPTY
37341: LIST
37342: LIST
37343: PUSH
37344: LD_INT 2
37346: NEG
37347: PUSH
37348: LD_INT 1
37350: NEG
37351: PUSH
37352: EMPTY
37353: LIST
37354: LIST
37355: PUSH
37356: LD_INT 2
37358: NEG
37359: PUSH
37360: LD_INT 2
37362: NEG
37363: PUSH
37364: EMPTY
37365: LIST
37366: LIST
37367: PUSH
37368: LD_INT 1
37370: NEG
37371: PUSH
37372: LD_INT 2
37374: PUSH
37375: EMPTY
37376: LIST
37377: LIST
37378: PUSH
37379: LD_INT 2
37381: NEG
37382: PUSH
37383: LD_INT 1
37385: PUSH
37386: EMPTY
37387: LIST
37388: LIST
37389: PUSH
37390: LD_INT 3
37392: NEG
37393: PUSH
37394: LD_INT 1
37396: NEG
37397: PUSH
37398: EMPTY
37399: LIST
37400: LIST
37401: PUSH
37402: LD_INT 3
37404: NEG
37405: PUSH
37406: LD_INT 2
37408: NEG
37409: PUSH
37410: EMPTY
37411: LIST
37412: LIST
37413: PUSH
37414: EMPTY
37415: LIST
37416: LIST
37417: LIST
37418: LIST
37419: LIST
37420: LIST
37421: LIST
37422: LIST
37423: LIST
37424: LIST
37425: LIST
37426: LIST
37427: LIST
37428: LIST
37429: LIST
37430: LIST
37431: LIST
37432: LIST
37433: LIST
37434: LIST
37435: LIST
37436: LIST
37437: LIST
37438: ST_TO_ADDR
// fDepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
37439: LD_ADDR_VAR 0 28
37443: PUSH
37444: LD_INT 0
37446: PUSH
37447: LD_INT 0
37449: PUSH
37450: EMPTY
37451: LIST
37452: LIST
37453: PUSH
37454: LD_INT 0
37456: PUSH
37457: LD_INT 1
37459: NEG
37460: PUSH
37461: EMPTY
37462: LIST
37463: LIST
37464: PUSH
37465: LD_INT 1
37467: PUSH
37468: LD_INT 0
37470: PUSH
37471: EMPTY
37472: LIST
37473: LIST
37474: PUSH
37475: LD_INT 1
37477: PUSH
37478: LD_INT 1
37480: PUSH
37481: EMPTY
37482: LIST
37483: LIST
37484: PUSH
37485: LD_INT 0
37487: PUSH
37488: LD_INT 1
37490: PUSH
37491: EMPTY
37492: LIST
37493: LIST
37494: PUSH
37495: LD_INT 1
37497: NEG
37498: PUSH
37499: LD_INT 0
37501: PUSH
37502: EMPTY
37503: LIST
37504: LIST
37505: PUSH
37506: LD_INT 1
37508: NEG
37509: PUSH
37510: LD_INT 1
37512: NEG
37513: PUSH
37514: EMPTY
37515: LIST
37516: LIST
37517: PUSH
37518: LD_INT 1
37520: NEG
37521: PUSH
37522: LD_INT 2
37524: NEG
37525: PUSH
37526: EMPTY
37527: LIST
37528: LIST
37529: PUSH
37530: LD_INT 0
37532: PUSH
37533: LD_INT 2
37535: NEG
37536: PUSH
37537: EMPTY
37538: LIST
37539: LIST
37540: PUSH
37541: LD_INT 1
37543: PUSH
37544: LD_INT 1
37546: NEG
37547: PUSH
37548: EMPTY
37549: LIST
37550: LIST
37551: PUSH
37552: LD_INT 2
37554: PUSH
37555: LD_INT 0
37557: PUSH
37558: EMPTY
37559: LIST
37560: LIST
37561: PUSH
37562: LD_INT 2
37564: PUSH
37565: LD_INT 1
37567: PUSH
37568: EMPTY
37569: LIST
37570: LIST
37571: PUSH
37572: LD_INT 2
37574: PUSH
37575: LD_INT 2
37577: PUSH
37578: EMPTY
37579: LIST
37580: LIST
37581: PUSH
37582: LD_INT 1
37584: PUSH
37585: LD_INT 2
37587: PUSH
37588: EMPTY
37589: LIST
37590: LIST
37591: PUSH
37592: LD_INT 0
37594: PUSH
37595: LD_INT 2
37597: PUSH
37598: EMPTY
37599: LIST
37600: LIST
37601: PUSH
37602: LD_INT 1
37604: NEG
37605: PUSH
37606: LD_INT 1
37608: PUSH
37609: EMPTY
37610: LIST
37611: LIST
37612: PUSH
37613: LD_INT 2
37615: NEG
37616: PUSH
37617: LD_INT 0
37619: PUSH
37620: EMPTY
37621: LIST
37622: LIST
37623: PUSH
37624: LD_INT 2
37626: NEG
37627: PUSH
37628: LD_INT 1
37630: NEG
37631: PUSH
37632: EMPTY
37633: LIST
37634: LIST
37635: PUSH
37636: LD_INT 2
37638: NEG
37639: PUSH
37640: LD_INT 2
37642: NEG
37643: PUSH
37644: EMPTY
37645: LIST
37646: LIST
37647: PUSH
37648: LD_INT 2
37650: NEG
37651: PUSH
37652: LD_INT 3
37654: NEG
37655: PUSH
37656: EMPTY
37657: LIST
37658: LIST
37659: PUSH
37660: LD_INT 1
37662: NEG
37663: PUSH
37664: LD_INT 3
37666: NEG
37667: PUSH
37668: EMPTY
37669: LIST
37670: LIST
37671: PUSH
37672: LD_INT 3
37674: NEG
37675: PUSH
37676: LD_INT 1
37678: NEG
37679: PUSH
37680: EMPTY
37681: LIST
37682: LIST
37683: PUSH
37684: LD_INT 3
37686: NEG
37687: PUSH
37688: LD_INT 2
37690: NEG
37691: PUSH
37692: EMPTY
37693: LIST
37694: LIST
37695: PUSH
37696: EMPTY
37697: LIST
37698: LIST
37699: LIST
37700: LIST
37701: LIST
37702: LIST
37703: LIST
37704: LIST
37705: LIST
37706: LIST
37707: LIST
37708: LIST
37709: LIST
37710: LIST
37711: LIST
37712: LIST
37713: LIST
37714: LIST
37715: LIST
37716: LIST
37717: LIST
37718: LIST
37719: LIST
37720: ST_TO_ADDR
// fFactory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
37721: LD_ADDR_VAR 0 29
37725: PUSH
37726: LD_INT 0
37728: PUSH
37729: LD_INT 0
37731: PUSH
37732: EMPTY
37733: LIST
37734: LIST
37735: PUSH
37736: LD_INT 0
37738: PUSH
37739: LD_INT 1
37741: NEG
37742: PUSH
37743: EMPTY
37744: LIST
37745: LIST
37746: PUSH
37747: LD_INT 1
37749: PUSH
37750: LD_INT 0
37752: PUSH
37753: EMPTY
37754: LIST
37755: LIST
37756: PUSH
37757: LD_INT 1
37759: PUSH
37760: LD_INT 1
37762: PUSH
37763: EMPTY
37764: LIST
37765: LIST
37766: PUSH
37767: LD_INT 0
37769: PUSH
37770: LD_INT 1
37772: PUSH
37773: EMPTY
37774: LIST
37775: LIST
37776: PUSH
37777: LD_INT 1
37779: NEG
37780: PUSH
37781: LD_INT 0
37783: PUSH
37784: EMPTY
37785: LIST
37786: LIST
37787: PUSH
37788: LD_INT 1
37790: NEG
37791: PUSH
37792: LD_INT 1
37794: NEG
37795: PUSH
37796: EMPTY
37797: LIST
37798: LIST
37799: PUSH
37800: LD_INT 1
37802: NEG
37803: PUSH
37804: LD_INT 2
37806: NEG
37807: PUSH
37808: EMPTY
37809: LIST
37810: LIST
37811: PUSH
37812: LD_INT 0
37814: PUSH
37815: LD_INT 2
37817: NEG
37818: PUSH
37819: EMPTY
37820: LIST
37821: LIST
37822: PUSH
37823: LD_INT 1
37825: PUSH
37826: LD_INT 1
37828: NEG
37829: PUSH
37830: EMPTY
37831: LIST
37832: LIST
37833: PUSH
37834: LD_INT 2
37836: PUSH
37837: LD_INT 0
37839: PUSH
37840: EMPTY
37841: LIST
37842: LIST
37843: PUSH
37844: LD_INT 2
37846: PUSH
37847: LD_INT 1
37849: PUSH
37850: EMPTY
37851: LIST
37852: LIST
37853: PUSH
37854: LD_INT 1
37856: PUSH
37857: LD_INT 2
37859: PUSH
37860: EMPTY
37861: LIST
37862: LIST
37863: PUSH
37864: LD_INT 0
37866: PUSH
37867: LD_INT 2
37869: PUSH
37870: EMPTY
37871: LIST
37872: LIST
37873: PUSH
37874: LD_INT 1
37876: NEG
37877: PUSH
37878: LD_INT 1
37880: PUSH
37881: EMPTY
37882: LIST
37883: LIST
37884: PUSH
37885: LD_INT 2
37887: NEG
37888: PUSH
37889: LD_INT 1
37891: NEG
37892: PUSH
37893: EMPTY
37894: LIST
37895: LIST
37896: PUSH
37897: LD_INT 2
37899: NEG
37900: PUSH
37901: LD_INT 2
37903: NEG
37904: PUSH
37905: EMPTY
37906: LIST
37907: LIST
37908: PUSH
37909: LD_INT 2
37911: NEG
37912: PUSH
37913: LD_INT 3
37915: NEG
37916: PUSH
37917: EMPTY
37918: LIST
37919: LIST
37920: PUSH
37921: LD_INT 2
37923: PUSH
37924: LD_INT 1
37926: NEG
37927: PUSH
37928: EMPTY
37929: LIST
37930: LIST
37931: PUSH
37932: LD_INT 3
37934: PUSH
37935: LD_INT 1
37937: PUSH
37938: EMPTY
37939: LIST
37940: LIST
37941: PUSH
37942: LD_INT 1
37944: PUSH
37945: LD_INT 3
37947: PUSH
37948: EMPTY
37949: LIST
37950: LIST
37951: PUSH
37952: LD_INT 1
37954: NEG
37955: PUSH
37956: LD_INT 2
37958: PUSH
37959: EMPTY
37960: LIST
37961: LIST
37962: PUSH
37963: LD_INT 3
37965: NEG
37966: PUSH
37967: LD_INT 2
37969: NEG
37970: PUSH
37971: EMPTY
37972: LIST
37973: LIST
37974: PUSH
37975: EMPTY
37976: LIST
37977: LIST
37978: LIST
37979: LIST
37980: LIST
37981: LIST
37982: LIST
37983: LIST
37984: LIST
37985: LIST
37986: LIST
37987: LIST
37988: LIST
37989: LIST
37990: LIST
37991: LIST
37992: LIST
37993: LIST
37994: LIST
37995: LIST
37996: LIST
37997: LIST
37998: LIST
37999: ST_TO_ADDR
// fFactory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
38000: LD_ADDR_VAR 0 30
38004: PUSH
38005: LD_INT 0
38007: PUSH
38008: LD_INT 0
38010: PUSH
38011: EMPTY
38012: LIST
38013: LIST
38014: PUSH
38015: LD_INT 0
38017: PUSH
38018: LD_INT 1
38020: NEG
38021: PUSH
38022: EMPTY
38023: LIST
38024: LIST
38025: PUSH
38026: LD_INT 1
38028: PUSH
38029: LD_INT 0
38031: PUSH
38032: EMPTY
38033: LIST
38034: LIST
38035: PUSH
38036: LD_INT 1
38038: PUSH
38039: LD_INT 1
38041: PUSH
38042: EMPTY
38043: LIST
38044: LIST
38045: PUSH
38046: LD_INT 0
38048: PUSH
38049: LD_INT 1
38051: PUSH
38052: EMPTY
38053: LIST
38054: LIST
38055: PUSH
38056: LD_INT 1
38058: NEG
38059: PUSH
38060: LD_INT 0
38062: PUSH
38063: EMPTY
38064: LIST
38065: LIST
38066: PUSH
38067: LD_INT 1
38069: NEG
38070: PUSH
38071: LD_INT 1
38073: NEG
38074: PUSH
38075: EMPTY
38076: LIST
38077: LIST
38078: PUSH
38079: LD_INT 1
38081: NEG
38082: PUSH
38083: LD_INT 2
38085: NEG
38086: PUSH
38087: EMPTY
38088: LIST
38089: LIST
38090: PUSH
38091: LD_INT 0
38093: PUSH
38094: LD_INT 2
38096: NEG
38097: PUSH
38098: EMPTY
38099: LIST
38100: LIST
38101: PUSH
38102: LD_INT 1
38104: PUSH
38105: LD_INT 1
38107: NEG
38108: PUSH
38109: EMPTY
38110: LIST
38111: LIST
38112: PUSH
38113: LD_INT 2
38115: PUSH
38116: LD_INT 0
38118: PUSH
38119: EMPTY
38120: LIST
38121: LIST
38122: PUSH
38123: LD_INT 2
38125: PUSH
38126: LD_INT 1
38128: PUSH
38129: EMPTY
38130: LIST
38131: LIST
38132: PUSH
38133: LD_INT 2
38135: PUSH
38136: LD_INT 2
38138: PUSH
38139: EMPTY
38140: LIST
38141: LIST
38142: PUSH
38143: LD_INT 1
38145: PUSH
38146: LD_INT 2
38148: PUSH
38149: EMPTY
38150: LIST
38151: LIST
38152: PUSH
38153: LD_INT 1
38155: NEG
38156: PUSH
38157: LD_INT 1
38159: PUSH
38160: EMPTY
38161: LIST
38162: LIST
38163: PUSH
38164: LD_INT 2
38166: NEG
38167: PUSH
38168: LD_INT 0
38170: PUSH
38171: EMPTY
38172: LIST
38173: LIST
38174: PUSH
38175: LD_INT 2
38177: NEG
38178: PUSH
38179: LD_INT 1
38181: NEG
38182: PUSH
38183: EMPTY
38184: LIST
38185: LIST
38186: PUSH
38187: LD_INT 1
38189: NEG
38190: PUSH
38191: LD_INT 3
38193: NEG
38194: PUSH
38195: EMPTY
38196: LIST
38197: LIST
38198: PUSH
38199: LD_INT 1
38201: PUSH
38202: LD_INT 2
38204: NEG
38205: PUSH
38206: EMPTY
38207: LIST
38208: LIST
38209: PUSH
38210: LD_INT 3
38212: PUSH
38213: LD_INT 2
38215: PUSH
38216: EMPTY
38217: LIST
38218: LIST
38219: PUSH
38220: LD_INT 2
38222: PUSH
38223: LD_INT 3
38225: PUSH
38226: EMPTY
38227: LIST
38228: LIST
38229: PUSH
38230: LD_INT 2
38232: NEG
38233: PUSH
38234: LD_INT 1
38236: PUSH
38237: EMPTY
38238: LIST
38239: LIST
38240: PUSH
38241: LD_INT 3
38243: NEG
38244: PUSH
38245: LD_INT 1
38247: NEG
38248: PUSH
38249: EMPTY
38250: LIST
38251: LIST
38252: PUSH
38253: EMPTY
38254: LIST
38255: LIST
38256: LIST
38257: LIST
38258: LIST
38259: LIST
38260: LIST
38261: LIST
38262: LIST
38263: LIST
38264: LIST
38265: LIST
38266: LIST
38267: LIST
38268: LIST
38269: LIST
38270: LIST
38271: LIST
38272: LIST
38273: LIST
38274: LIST
38275: LIST
38276: LIST
38277: ST_TO_ADDR
// fFactory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
38278: LD_ADDR_VAR 0 31
38282: PUSH
38283: LD_INT 0
38285: PUSH
38286: LD_INT 0
38288: PUSH
38289: EMPTY
38290: LIST
38291: LIST
38292: PUSH
38293: LD_INT 0
38295: PUSH
38296: LD_INT 1
38298: NEG
38299: PUSH
38300: EMPTY
38301: LIST
38302: LIST
38303: PUSH
38304: LD_INT 1
38306: PUSH
38307: LD_INT 0
38309: PUSH
38310: EMPTY
38311: LIST
38312: LIST
38313: PUSH
38314: LD_INT 1
38316: PUSH
38317: LD_INT 1
38319: PUSH
38320: EMPTY
38321: LIST
38322: LIST
38323: PUSH
38324: LD_INT 0
38326: PUSH
38327: LD_INT 1
38329: PUSH
38330: EMPTY
38331: LIST
38332: LIST
38333: PUSH
38334: LD_INT 1
38336: NEG
38337: PUSH
38338: LD_INT 0
38340: PUSH
38341: EMPTY
38342: LIST
38343: LIST
38344: PUSH
38345: LD_INT 1
38347: NEG
38348: PUSH
38349: LD_INT 1
38351: NEG
38352: PUSH
38353: EMPTY
38354: LIST
38355: LIST
38356: PUSH
38357: LD_INT 1
38359: NEG
38360: PUSH
38361: LD_INT 2
38363: NEG
38364: PUSH
38365: EMPTY
38366: LIST
38367: LIST
38368: PUSH
38369: LD_INT 1
38371: PUSH
38372: LD_INT 1
38374: NEG
38375: PUSH
38376: EMPTY
38377: LIST
38378: LIST
38379: PUSH
38380: LD_INT 2
38382: PUSH
38383: LD_INT 0
38385: PUSH
38386: EMPTY
38387: LIST
38388: LIST
38389: PUSH
38390: LD_INT 2
38392: PUSH
38393: LD_INT 1
38395: PUSH
38396: EMPTY
38397: LIST
38398: LIST
38399: PUSH
38400: LD_INT 2
38402: PUSH
38403: LD_INT 2
38405: PUSH
38406: EMPTY
38407: LIST
38408: LIST
38409: PUSH
38410: LD_INT 1
38412: PUSH
38413: LD_INT 2
38415: PUSH
38416: EMPTY
38417: LIST
38418: LIST
38419: PUSH
38420: LD_INT 0
38422: PUSH
38423: LD_INT 2
38425: PUSH
38426: EMPTY
38427: LIST
38428: LIST
38429: PUSH
38430: LD_INT 1
38432: NEG
38433: PUSH
38434: LD_INT 1
38436: PUSH
38437: EMPTY
38438: LIST
38439: LIST
38440: PUSH
38441: LD_INT 2
38443: NEG
38444: PUSH
38445: LD_INT 1
38447: NEG
38448: PUSH
38449: EMPTY
38450: LIST
38451: LIST
38452: PUSH
38453: LD_INT 2
38455: NEG
38456: PUSH
38457: LD_INT 2
38459: NEG
38460: PUSH
38461: EMPTY
38462: LIST
38463: LIST
38464: PUSH
38465: LD_INT 2
38467: NEG
38468: PUSH
38469: LD_INT 3
38471: NEG
38472: PUSH
38473: EMPTY
38474: LIST
38475: LIST
38476: PUSH
38477: LD_INT 2
38479: PUSH
38480: LD_INT 1
38482: NEG
38483: PUSH
38484: EMPTY
38485: LIST
38486: LIST
38487: PUSH
38488: LD_INT 3
38490: PUSH
38491: LD_INT 1
38493: PUSH
38494: EMPTY
38495: LIST
38496: LIST
38497: PUSH
38498: LD_INT 1
38500: PUSH
38501: LD_INT 3
38503: PUSH
38504: EMPTY
38505: LIST
38506: LIST
38507: PUSH
38508: LD_INT 1
38510: NEG
38511: PUSH
38512: LD_INT 2
38514: PUSH
38515: EMPTY
38516: LIST
38517: LIST
38518: PUSH
38519: LD_INT 3
38521: NEG
38522: PUSH
38523: LD_INT 2
38525: NEG
38526: PUSH
38527: EMPTY
38528: LIST
38529: LIST
38530: PUSH
38531: EMPTY
38532: LIST
38533: LIST
38534: LIST
38535: LIST
38536: LIST
38537: LIST
38538: LIST
38539: LIST
38540: LIST
38541: LIST
38542: LIST
38543: LIST
38544: LIST
38545: LIST
38546: LIST
38547: LIST
38548: LIST
38549: LIST
38550: LIST
38551: LIST
38552: LIST
38553: LIST
38554: LIST
38555: ST_TO_ADDR
// fFactory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
38556: LD_ADDR_VAR 0 32
38560: PUSH
38561: LD_INT 0
38563: PUSH
38564: LD_INT 0
38566: PUSH
38567: EMPTY
38568: LIST
38569: LIST
38570: PUSH
38571: LD_INT 0
38573: PUSH
38574: LD_INT 1
38576: NEG
38577: PUSH
38578: EMPTY
38579: LIST
38580: LIST
38581: PUSH
38582: LD_INT 1
38584: PUSH
38585: LD_INT 0
38587: PUSH
38588: EMPTY
38589: LIST
38590: LIST
38591: PUSH
38592: LD_INT 1
38594: PUSH
38595: LD_INT 1
38597: PUSH
38598: EMPTY
38599: LIST
38600: LIST
38601: PUSH
38602: LD_INT 0
38604: PUSH
38605: LD_INT 1
38607: PUSH
38608: EMPTY
38609: LIST
38610: LIST
38611: PUSH
38612: LD_INT 1
38614: NEG
38615: PUSH
38616: LD_INT 0
38618: PUSH
38619: EMPTY
38620: LIST
38621: LIST
38622: PUSH
38623: LD_INT 1
38625: NEG
38626: PUSH
38627: LD_INT 1
38629: NEG
38630: PUSH
38631: EMPTY
38632: LIST
38633: LIST
38634: PUSH
38635: LD_INT 1
38637: NEG
38638: PUSH
38639: LD_INT 2
38641: NEG
38642: PUSH
38643: EMPTY
38644: LIST
38645: LIST
38646: PUSH
38647: LD_INT 0
38649: PUSH
38650: LD_INT 2
38652: NEG
38653: PUSH
38654: EMPTY
38655: LIST
38656: LIST
38657: PUSH
38658: LD_INT 1
38660: PUSH
38661: LD_INT 1
38663: NEG
38664: PUSH
38665: EMPTY
38666: LIST
38667: LIST
38668: PUSH
38669: LD_INT 2
38671: PUSH
38672: LD_INT 1
38674: PUSH
38675: EMPTY
38676: LIST
38677: LIST
38678: PUSH
38679: LD_INT 2
38681: PUSH
38682: LD_INT 2
38684: PUSH
38685: EMPTY
38686: LIST
38687: LIST
38688: PUSH
38689: LD_INT 1
38691: PUSH
38692: LD_INT 2
38694: PUSH
38695: EMPTY
38696: LIST
38697: LIST
38698: PUSH
38699: LD_INT 0
38701: PUSH
38702: LD_INT 2
38704: PUSH
38705: EMPTY
38706: LIST
38707: LIST
38708: PUSH
38709: LD_INT 1
38711: NEG
38712: PUSH
38713: LD_INT 1
38715: PUSH
38716: EMPTY
38717: LIST
38718: LIST
38719: PUSH
38720: LD_INT 2
38722: NEG
38723: PUSH
38724: LD_INT 0
38726: PUSH
38727: EMPTY
38728: LIST
38729: LIST
38730: PUSH
38731: LD_INT 2
38733: NEG
38734: PUSH
38735: LD_INT 1
38737: NEG
38738: PUSH
38739: EMPTY
38740: LIST
38741: LIST
38742: PUSH
38743: LD_INT 1
38745: NEG
38746: PUSH
38747: LD_INT 3
38749: NEG
38750: PUSH
38751: EMPTY
38752: LIST
38753: LIST
38754: PUSH
38755: LD_INT 1
38757: PUSH
38758: LD_INT 2
38760: NEG
38761: PUSH
38762: EMPTY
38763: LIST
38764: LIST
38765: PUSH
38766: LD_INT 3
38768: PUSH
38769: LD_INT 2
38771: PUSH
38772: EMPTY
38773: LIST
38774: LIST
38775: PUSH
38776: LD_INT 2
38778: PUSH
38779: LD_INT 3
38781: PUSH
38782: EMPTY
38783: LIST
38784: LIST
38785: PUSH
38786: LD_INT 2
38788: NEG
38789: PUSH
38790: LD_INT 1
38792: PUSH
38793: EMPTY
38794: LIST
38795: LIST
38796: PUSH
38797: LD_INT 3
38799: NEG
38800: PUSH
38801: LD_INT 1
38803: NEG
38804: PUSH
38805: EMPTY
38806: LIST
38807: LIST
38808: PUSH
38809: EMPTY
38810: LIST
38811: LIST
38812: LIST
38813: LIST
38814: LIST
38815: LIST
38816: LIST
38817: LIST
38818: LIST
38819: LIST
38820: LIST
38821: LIST
38822: LIST
38823: LIST
38824: LIST
38825: LIST
38826: LIST
38827: LIST
38828: LIST
38829: LIST
38830: LIST
38831: LIST
38832: LIST
38833: ST_TO_ADDR
// fFactory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
38834: LD_ADDR_VAR 0 33
38838: PUSH
38839: LD_INT 0
38841: PUSH
38842: LD_INT 0
38844: PUSH
38845: EMPTY
38846: LIST
38847: LIST
38848: PUSH
38849: LD_INT 0
38851: PUSH
38852: LD_INT 1
38854: NEG
38855: PUSH
38856: EMPTY
38857: LIST
38858: LIST
38859: PUSH
38860: LD_INT 1
38862: PUSH
38863: LD_INT 0
38865: PUSH
38866: EMPTY
38867: LIST
38868: LIST
38869: PUSH
38870: LD_INT 1
38872: PUSH
38873: LD_INT 1
38875: PUSH
38876: EMPTY
38877: LIST
38878: LIST
38879: PUSH
38880: LD_INT 0
38882: PUSH
38883: LD_INT 1
38885: PUSH
38886: EMPTY
38887: LIST
38888: LIST
38889: PUSH
38890: LD_INT 1
38892: NEG
38893: PUSH
38894: LD_INT 0
38896: PUSH
38897: EMPTY
38898: LIST
38899: LIST
38900: PUSH
38901: LD_INT 1
38903: NEG
38904: PUSH
38905: LD_INT 1
38907: NEG
38908: PUSH
38909: EMPTY
38910: LIST
38911: LIST
38912: PUSH
38913: LD_INT 1
38915: NEG
38916: PUSH
38917: LD_INT 2
38919: NEG
38920: PUSH
38921: EMPTY
38922: LIST
38923: LIST
38924: PUSH
38925: LD_INT 1
38927: PUSH
38928: LD_INT 1
38930: NEG
38931: PUSH
38932: EMPTY
38933: LIST
38934: LIST
38935: PUSH
38936: LD_INT 2
38938: PUSH
38939: LD_INT 0
38941: PUSH
38942: EMPTY
38943: LIST
38944: LIST
38945: PUSH
38946: LD_INT 2
38948: PUSH
38949: LD_INT 1
38951: PUSH
38952: EMPTY
38953: LIST
38954: LIST
38955: PUSH
38956: LD_INT 1
38958: PUSH
38959: LD_INT 2
38961: PUSH
38962: EMPTY
38963: LIST
38964: LIST
38965: PUSH
38966: LD_INT 0
38968: PUSH
38969: LD_INT 2
38971: PUSH
38972: EMPTY
38973: LIST
38974: LIST
38975: PUSH
38976: LD_INT 1
38978: NEG
38979: PUSH
38980: LD_INT 1
38982: PUSH
38983: EMPTY
38984: LIST
38985: LIST
38986: PUSH
38987: LD_INT 2
38989: NEG
38990: PUSH
38991: LD_INT 0
38993: PUSH
38994: EMPTY
38995: LIST
38996: LIST
38997: PUSH
38998: LD_INT 2
39000: NEG
39001: PUSH
39002: LD_INT 1
39004: NEG
39005: PUSH
39006: EMPTY
39007: LIST
39008: LIST
39009: PUSH
39010: LD_INT 2
39012: NEG
39013: PUSH
39014: LD_INT 2
39016: NEG
39017: PUSH
39018: EMPTY
39019: LIST
39020: LIST
39021: PUSH
39022: LD_INT 2
39024: NEG
39025: PUSH
39026: LD_INT 3
39028: NEG
39029: PUSH
39030: EMPTY
39031: LIST
39032: LIST
39033: PUSH
39034: LD_INT 2
39036: PUSH
39037: LD_INT 1
39039: NEG
39040: PUSH
39041: EMPTY
39042: LIST
39043: LIST
39044: PUSH
39045: LD_INT 3
39047: PUSH
39048: LD_INT 1
39050: PUSH
39051: EMPTY
39052: LIST
39053: LIST
39054: PUSH
39055: LD_INT 1
39057: PUSH
39058: LD_INT 3
39060: PUSH
39061: EMPTY
39062: LIST
39063: LIST
39064: PUSH
39065: LD_INT 1
39067: NEG
39068: PUSH
39069: LD_INT 2
39071: PUSH
39072: EMPTY
39073: LIST
39074: LIST
39075: PUSH
39076: LD_INT 3
39078: NEG
39079: PUSH
39080: LD_INT 2
39082: NEG
39083: PUSH
39084: EMPTY
39085: LIST
39086: LIST
39087: PUSH
39088: EMPTY
39089: LIST
39090: LIST
39091: LIST
39092: LIST
39093: LIST
39094: LIST
39095: LIST
39096: LIST
39097: LIST
39098: LIST
39099: LIST
39100: LIST
39101: LIST
39102: LIST
39103: LIST
39104: LIST
39105: LIST
39106: LIST
39107: LIST
39108: LIST
39109: LIST
39110: LIST
39111: LIST
39112: ST_TO_ADDR
// fFactory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
39113: LD_ADDR_VAR 0 34
39117: PUSH
39118: LD_INT 0
39120: PUSH
39121: LD_INT 0
39123: PUSH
39124: EMPTY
39125: LIST
39126: LIST
39127: PUSH
39128: LD_INT 0
39130: PUSH
39131: LD_INT 1
39133: NEG
39134: PUSH
39135: EMPTY
39136: LIST
39137: LIST
39138: PUSH
39139: LD_INT 1
39141: PUSH
39142: LD_INT 0
39144: PUSH
39145: EMPTY
39146: LIST
39147: LIST
39148: PUSH
39149: LD_INT 1
39151: PUSH
39152: LD_INT 1
39154: PUSH
39155: EMPTY
39156: LIST
39157: LIST
39158: PUSH
39159: LD_INT 0
39161: PUSH
39162: LD_INT 1
39164: PUSH
39165: EMPTY
39166: LIST
39167: LIST
39168: PUSH
39169: LD_INT 1
39171: NEG
39172: PUSH
39173: LD_INT 0
39175: PUSH
39176: EMPTY
39177: LIST
39178: LIST
39179: PUSH
39180: LD_INT 1
39182: NEG
39183: PUSH
39184: LD_INT 1
39186: NEG
39187: PUSH
39188: EMPTY
39189: LIST
39190: LIST
39191: PUSH
39192: LD_INT 1
39194: NEG
39195: PUSH
39196: LD_INT 2
39198: NEG
39199: PUSH
39200: EMPTY
39201: LIST
39202: LIST
39203: PUSH
39204: LD_INT 0
39206: PUSH
39207: LD_INT 2
39209: NEG
39210: PUSH
39211: EMPTY
39212: LIST
39213: LIST
39214: PUSH
39215: LD_INT 1
39217: PUSH
39218: LD_INT 1
39220: NEG
39221: PUSH
39222: EMPTY
39223: LIST
39224: LIST
39225: PUSH
39226: LD_INT 2
39228: PUSH
39229: LD_INT 1
39231: PUSH
39232: EMPTY
39233: LIST
39234: LIST
39235: PUSH
39236: LD_INT 2
39238: PUSH
39239: LD_INT 2
39241: PUSH
39242: EMPTY
39243: LIST
39244: LIST
39245: PUSH
39246: LD_INT 1
39248: PUSH
39249: LD_INT 2
39251: PUSH
39252: EMPTY
39253: LIST
39254: LIST
39255: PUSH
39256: LD_INT 1
39258: NEG
39259: PUSH
39260: LD_INT 1
39262: PUSH
39263: EMPTY
39264: LIST
39265: LIST
39266: PUSH
39267: LD_INT 2
39269: NEG
39270: PUSH
39271: LD_INT 0
39273: PUSH
39274: EMPTY
39275: LIST
39276: LIST
39277: PUSH
39278: LD_INT 2
39280: NEG
39281: PUSH
39282: LD_INT 1
39284: NEG
39285: PUSH
39286: EMPTY
39287: LIST
39288: LIST
39289: PUSH
39290: LD_INT 2
39292: NEG
39293: PUSH
39294: LD_INT 2
39296: NEG
39297: PUSH
39298: EMPTY
39299: LIST
39300: LIST
39301: PUSH
39302: LD_INT 1
39304: NEG
39305: PUSH
39306: LD_INT 3
39308: NEG
39309: PUSH
39310: EMPTY
39311: LIST
39312: LIST
39313: PUSH
39314: LD_INT 1
39316: PUSH
39317: LD_INT 2
39319: NEG
39320: PUSH
39321: EMPTY
39322: LIST
39323: LIST
39324: PUSH
39325: LD_INT 3
39327: PUSH
39328: LD_INT 2
39330: PUSH
39331: EMPTY
39332: LIST
39333: LIST
39334: PUSH
39335: LD_INT 2
39337: PUSH
39338: LD_INT 3
39340: PUSH
39341: EMPTY
39342: LIST
39343: LIST
39344: PUSH
39345: LD_INT 2
39347: NEG
39348: PUSH
39349: LD_INT 1
39351: PUSH
39352: EMPTY
39353: LIST
39354: LIST
39355: PUSH
39356: LD_INT 3
39358: NEG
39359: PUSH
39360: LD_INT 1
39362: NEG
39363: PUSH
39364: EMPTY
39365: LIST
39366: LIST
39367: PUSH
39368: EMPTY
39369: LIST
39370: LIST
39371: LIST
39372: LIST
39373: LIST
39374: LIST
39375: LIST
39376: LIST
39377: LIST
39378: LIST
39379: LIST
39380: LIST
39381: LIST
39382: LIST
39383: LIST
39384: LIST
39385: LIST
39386: LIST
39387: LIST
39388: LIST
39389: LIST
39390: LIST
39391: LIST
39392: ST_TO_ADDR
// fExt0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
39393: LD_ADDR_VAR 0 35
39397: PUSH
39398: LD_INT 0
39400: PUSH
39401: LD_INT 0
39403: PUSH
39404: EMPTY
39405: LIST
39406: LIST
39407: PUSH
39408: LD_INT 0
39410: PUSH
39411: LD_INT 1
39413: NEG
39414: PUSH
39415: EMPTY
39416: LIST
39417: LIST
39418: PUSH
39419: LD_INT 1
39421: PUSH
39422: LD_INT 0
39424: PUSH
39425: EMPTY
39426: LIST
39427: LIST
39428: PUSH
39429: LD_INT 1
39431: PUSH
39432: LD_INT 1
39434: PUSH
39435: EMPTY
39436: LIST
39437: LIST
39438: PUSH
39439: LD_INT 0
39441: PUSH
39442: LD_INT 1
39444: PUSH
39445: EMPTY
39446: LIST
39447: LIST
39448: PUSH
39449: LD_INT 1
39451: NEG
39452: PUSH
39453: LD_INT 0
39455: PUSH
39456: EMPTY
39457: LIST
39458: LIST
39459: PUSH
39460: LD_INT 1
39462: NEG
39463: PUSH
39464: LD_INT 1
39466: NEG
39467: PUSH
39468: EMPTY
39469: LIST
39470: LIST
39471: PUSH
39472: LD_INT 2
39474: PUSH
39475: LD_INT 1
39477: PUSH
39478: EMPTY
39479: LIST
39480: LIST
39481: PUSH
39482: LD_INT 2
39484: NEG
39485: PUSH
39486: LD_INT 1
39488: NEG
39489: PUSH
39490: EMPTY
39491: LIST
39492: LIST
39493: PUSH
39494: EMPTY
39495: LIST
39496: LIST
39497: LIST
39498: LIST
39499: LIST
39500: LIST
39501: LIST
39502: LIST
39503: LIST
39504: ST_TO_ADDR
// fExt1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
39505: LD_ADDR_VAR 0 36
39509: PUSH
39510: LD_INT 0
39512: PUSH
39513: LD_INT 0
39515: PUSH
39516: EMPTY
39517: LIST
39518: LIST
39519: PUSH
39520: LD_INT 0
39522: PUSH
39523: LD_INT 1
39525: NEG
39526: PUSH
39527: EMPTY
39528: LIST
39529: LIST
39530: PUSH
39531: LD_INT 1
39533: PUSH
39534: LD_INT 0
39536: PUSH
39537: EMPTY
39538: LIST
39539: LIST
39540: PUSH
39541: LD_INT 1
39543: PUSH
39544: LD_INT 1
39546: PUSH
39547: EMPTY
39548: LIST
39549: LIST
39550: PUSH
39551: LD_INT 0
39553: PUSH
39554: LD_INT 1
39556: PUSH
39557: EMPTY
39558: LIST
39559: LIST
39560: PUSH
39561: LD_INT 1
39563: NEG
39564: PUSH
39565: LD_INT 0
39567: PUSH
39568: EMPTY
39569: LIST
39570: LIST
39571: PUSH
39572: LD_INT 1
39574: NEG
39575: PUSH
39576: LD_INT 1
39578: NEG
39579: PUSH
39580: EMPTY
39581: LIST
39582: LIST
39583: PUSH
39584: LD_INT 1
39586: NEG
39587: PUSH
39588: LD_INT 2
39590: NEG
39591: PUSH
39592: EMPTY
39593: LIST
39594: LIST
39595: PUSH
39596: LD_INT 1
39598: PUSH
39599: LD_INT 2
39601: PUSH
39602: EMPTY
39603: LIST
39604: LIST
39605: PUSH
39606: EMPTY
39607: LIST
39608: LIST
39609: LIST
39610: LIST
39611: LIST
39612: LIST
39613: LIST
39614: LIST
39615: LIST
39616: ST_TO_ADDR
// fExt2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
39617: LD_ADDR_VAR 0 37
39621: PUSH
39622: LD_INT 0
39624: PUSH
39625: LD_INT 0
39627: PUSH
39628: EMPTY
39629: LIST
39630: LIST
39631: PUSH
39632: LD_INT 0
39634: PUSH
39635: LD_INT 1
39637: NEG
39638: PUSH
39639: EMPTY
39640: LIST
39641: LIST
39642: PUSH
39643: LD_INT 1
39645: PUSH
39646: LD_INT 0
39648: PUSH
39649: EMPTY
39650: LIST
39651: LIST
39652: PUSH
39653: LD_INT 1
39655: PUSH
39656: LD_INT 1
39658: PUSH
39659: EMPTY
39660: LIST
39661: LIST
39662: PUSH
39663: LD_INT 0
39665: PUSH
39666: LD_INT 1
39668: PUSH
39669: EMPTY
39670: LIST
39671: LIST
39672: PUSH
39673: LD_INT 1
39675: NEG
39676: PUSH
39677: LD_INT 0
39679: PUSH
39680: EMPTY
39681: LIST
39682: LIST
39683: PUSH
39684: LD_INT 1
39686: NEG
39687: PUSH
39688: LD_INT 1
39690: NEG
39691: PUSH
39692: EMPTY
39693: LIST
39694: LIST
39695: PUSH
39696: LD_INT 1
39698: PUSH
39699: LD_INT 1
39701: NEG
39702: PUSH
39703: EMPTY
39704: LIST
39705: LIST
39706: PUSH
39707: LD_INT 1
39709: NEG
39710: PUSH
39711: LD_INT 1
39713: PUSH
39714: EMPTY
39715: LIST
39716: LIST
39717: PUSH
39718: EMPTY
39719: LIST
39720: LIST
39721: LIST
39722: LIST
39723: LIST
39724: LIST
39725: LIST
39726: LIST
39727: LIST
39728: ST_TO_ADDR
// fExt3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
39729: LD_ADDR_VAR 0 38
39733: PUSH
39734: LD_INT 0
39736: PUSH
39737: LD_INT 0
39739: PUSH
39740: EMPTY
39741: LIST
39742: LIST
39743: PUSH
39744: LD_INT 0
39746: PUSH
39747: LD_INT 1
39749: NEG
39750: PUSH
39751: EMPTY
39752: LIST
39753: LIST
39754: PUSH
39755: LD_INT 1
39757: PUSH
39758: LD_INT 0
39760: PUSH
39761: EMPTY
39762: LIST
39763: LIST
39764: PUSH
39765: LD_INT 1
39767: PUSH
39768: LD_INT 1
39770: PUSH
39771: EMPTY
39772: LIST
39773: LIST
39774: PUSH
39775: LD_INT 0
39777: PUSH
39778: LD_INT 1
39780: PUSH
39781: EMPTY
39782: LIST
39783: LIST
39784: PUSH
39785: LD_INT 1
39787: NEG
39788: PUSH
39789: LD_INT 0
39791: PUSH
39792: EMPTY
39793: LIST
39794: LIST
39795: PUSH
39796: LD_INT 1
39798: NEG
39799: PUSH
39800: LD_INT 1
39802: NEG
39803: PUSH
39804: EMPTY
39805: LIST
39806: LIST
39807: PUSH
39808: LD_INT 2
39810: PUSH
39811: LD_INT 1
39813: PUSH
39814: EMPTY
39815: LIST
39816: LIST
39817: PUSH
39818: LD_INT 2
39820: NEG
39821: PUSH
39822: LD_INT 1
39824: NEG
39825: PUSH
39826: EMPTY
39827: LIST
39828: LIST
39829: PUSH
39830: EMPTY
39831: LIST
39832: LIST
39833: LIST
39834: LIST
39835: LIST
39836: LIST
39837: LIST
39838: LIST
39839: LIST
39840: ST_TO_ADDR
// fExt4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
39841: LD_ADDR_VAR 0 39
39845: PUSH
39846: LD_INT 0
39848: PUSH
39849: LD_INT 0
39851: PUSH
39852: EMPTY
39853: LIST
39854: LIST
39855: PUSH
39856: LD_INT 0
39858: PUSH
39859: LD_INT 1
39861: NEG
39862: PUSH
39863: EMPTY
39864: LIST
39865: LIST
39866: PUSH
39867: LD_INT 1
39869: PUSH
39870: LD_INT 0
39872: PUSH
39873: EMPTY
39874: LIST
39875: LIST
39876: PUSH
39877: LD_INT 1
39879: PUSH
39880: LD_INT 1
39882: PUSH
39883: EMPTY
39884: LIST
39885: LIST
39886: PUSH
39887: LD_INT 0
39889: PUSH
39890: LD_INT 1
39892: PUSH
39893: EMPTY
39894: LIST
39895: LIST
39896: PUSH
39897: LD_INT 1
39899: NEG
39900: PUSH
39901: LD_INT 0
39903: PUSH
39904: EMPTY
39905: LIST
39906: LIST
39907: PUSH
39908: LD_INT 1
39910: NEG
39911: PUSH
39912: LD_INT 1
39914: NEG
39915: PUSH
39916: EMPTY
39917: LIST
39918: LIST
39919: PUSH
39920: LD_INT 1
39922: NEG
39923: PUSH
39924: LD_INT 2
39926: NEG
39927: PUSH
39928: EMPTY
39929: LIST
39930: LIST
39931: PUSH
39932: LD_INT 1
39934: PUSH
39935: LD_INT 2
39937: PUSH
39938: EMPTY
39939: LIST
39940: LIST
39941: PUSH
39942: EMPTY
39943: LIST
39944: LIST
39945: LIST
39946: LIST
39947: LIST
39948: LIST
39949: LIST
39950: LIST
39951: LIST
39952: ST_TO_ADDR
// fExt5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
39953: LD_ADDR_VAR 0 40
39957: PUSH
39958: LD_INT 0
39960: PUSH
39961: LD_INT 0
39963: PUSH
39964: EMPTY
39965: LIST
39966: LIST
39967: PUSH
39968: LD_INT 0
39970: PUSH
39971: LD_INT 1
39973: NEG
39974: PUSH
39975: EMPTY
39976: LIST
39977: LIST
39978: PUSH
39979: LD_INT 1
39981: PUSH
39982: LD_INT 0
39984: PUSH
39985: EMPTY
39986: LIST
39987: LIST
39988: PUSH
39989: LD_INT 1
39991: PUSH
39992: LD_INT 1
39994: PUSH
39995: EMPTY
39996: LIST
39997: LIST
39998: PUSH
39999: LD_INT 0
40001: PUSH
40002: LD_INT 1
40004: PUSH
40005: EMPTY
40006: LIST
40007: LIST
40008: PUSH
40009: LD_INT 1
40011: NEG
40012: PUSH
40013: LD_INT 0
40015: PUSH
40016: EMPTY
40017: LIST
40018: LIST
40019: PUSH
40020: LD_INT 1
40022: NEG
40023: PUSH
40024: LD_INT 1
40026: NEG
40027: PUSH
40028: EMPTY
40029: LIST
40030: LIST
40031: PUSH
40032: LD_INT 1
40034: PUSH
40035: LD_INT 1
40037: NEG
40038: PUSH
40039: EMPTY
40040: LIST
40041: LIST
40042: PUSH
40043: LD_INT 1
40045: NEG
40046: PUSH
40047: LD_INT 1
40049: PUSH
40050: EMPTY
40051: LIST
40052: LIST
40053: PUSH
40054: EMPTY
40055: LIST
40056: LIST
40057: LIST
40058: LIST
40059: LIST
40060: LIST
40061: LIST
40062: LIST
40063: LIST
40064: ST_TO_ADDR
// fLab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
40065: LD_ADDR_VAR 0 41
40069: PUSH
40070: LD_INT 0
40072: PUSH
40073: LD_INT 0
40075: PUSH
40076: EMPTY
40077: LIST
40078: LIST
40079: PUSH
40080: LD_INT 0
40082: PUSH
40083: LD_INT 1
40085: NEG
40086: PUSH
40087: EMPTY
40088: LIST
40089: LIST
40090: PUSH
40091: LD_INT 1
40093: PUSH
40094: LD_INT 0
40096: PUSH
40097: EMPTY
40098: LIST
40099: LIST
40100: PUSH
40101: LD_INT 1
40103: PUSH
40104: LD_INT 1
40106: PUSH
40107: EMPTY
40108: LIST
40109: LIST
40110: PUSH
40111: LD_INT 0
40113: PUSH
40114: LD_INT 1
40116: PUSH
40117: EMPTY
40118: LIST
40119: LIST
40120: PUSH
40121: LD_INT 1
40123: NEG
40124: PUSH
40125: LD_INT 0
40127: PUSH
40128: EMPTY
40129: LIST
40130: LIST
40131: PUSH
40132: LD_INT 1
40134: NEG
40135: PUSH
40136: LD_INT 1
40138: NEG
40139: PUSH
40140: EMPTY
40141: LIST
40142: LIST
40143: PUSH
40144: LD_INT 1
40146: NEG
40147: PUSH
40148: LD_INT 2
40150: NEG
40151: PUSH
40152: EMPTY
40153: LIST
40154: LIST
40155: PUSH
40156: LD_INT 1
40158: PUSH
40159: LD_INT 1
40161: NEG
40162: PUSH
40163: EMPTY
40164: LIST
40165: LIST
40166: PUSH
40167: LD_INT 2
40169: PUSH
40170: LD_INT 0
40172: PUSH
40173: EMPTY
40174: LIST
40175: LIST
40176: PUSH
40177: LD_INT 2
40179: PUSH
40180: LD_INT 1
40182: PUSH
40183: EMPTY
40184: LIST
40185: LIST
40186: PUSH
40187: LD_INT 2
40189: PUSH
40190: LD_INT 2
40192: PUSH
40193: EMPTY
40194: LIST
40195: LIST
40196: PUSH
40197: LD_INT 1
40199: PUSH
40200: LD_INT 2
40202: PUSH
40203: EMPTY
40204: LIST
40205: LIST
40206: PUSH
40207: LD_INT 1
40209: NEG
40210: PUSH
40211: LD_INT 1
40213: PUSH
40214: EMPTY
40215: LIST
40216: LIST
40217: PUSH
40218: LD_INT 2
40220: NEG
40221: PUSH
40222: LD_INT 0
40224: PUSH
40225: EMPTY
40226: LIST
40227: LIST
40228: PUSH
40229: LD_INT 2
40231: NEG
40232: PUSH
40233: LD_INT 1
40235: NEG
40236: PUSH
40237: EMPTY
40238: LIST
40239: LIST
40240: PUSH
40241: LD_INT 2
40243: NEG
40244: PUSH
40245: LD_INT 2
40247: NEG
40248: PUSH
40249: EMPTY
40250: LIST
40251: LIST
40252: PUSH
40253: LD_INT 2
40255: NEG
40256: PUSH
40257: LD_INT 3
40259: NEG
40260: PUSH
40261: EMPTY
40262: LIST
40263: LIST
40264: PUSH
40265: LD_INT 2
40267: PUSH
40268: LD_INT 1
40270: NEG
40271: PUSH
40272: EMPTY
40273: LIST
40274: LIST
40275: PUSH
40276: LD_INT 3
40278: PUSH
40279: LD_INT 0
40281: PUSH
40282: EMPTY
40283: LIST
40284: LIST
40285: PUSH
40286: LD_INT 3
40288: PUSH
40289: LD_INT 1
40291: PUSH
40292: EMPTY
40293: LIST
40294: LIST
40295: PUSH
40296: LD_INT 3
40298: PUSH
40299: LD_INT 2
40301: PUSH
40302: EMPTY
40303: LIST
40304: LIST
40305: PUSH
40306: LD_INT 3
40308: PUSH
40309: LD_INT 3
40311: PUSH
40312: EMPTY
40313: LIST
40314: LIST
40315: PUSH
40316: LD_INT 2
40318: PUSH
40319: LD_INT 3
40321: PUSH
40322: EMPTY
40323: LIST
40324: LIST
40325: PUSH
40326: LD_INT 2
40328: NEG
40329: PUSH
40330: LD_INT 1
40332: PUSH
40333: EMPTY
40334: LIST
40335: LIST
40336: PUSH
40337: LD_INT 3
40339: NEG
40340: PUSH
40341: LD_INT 0
40343: PUSH
40344: EMPTY
40345: LIST
40346: LIST
40347: PUSH
40348: LD_INT 3
40350: NEG
40351: PUSH
40352: LD_INT 1
40354: NEG
40355: PUSH
40356: EMPTY
40357: LIST
40358: LIST
40359: PUSH
40360: LD_INT 3
40362: NEG
40363: PUSH
40364: LD_INT 2
40366: NEG
40367: PUSH
40368: EMPTY
40369: LIST
40370: LIST
40371: PUSH
40372: LD_INT 3
40374: NEG
40375: PUSH
40376: LD_INT 3
40378: NEG
40379: PUSH
40380: EMPTY
40381: LIST
40382: LIST
40383: PUSH
40384: EMPTY
40385: LIST
40386: LIST
40387: LIST
40388: LIST
40389: LIST
40390: LIST
40391: LIST
40392: LIST
40393: LIST
40394: LIST
40395: LIST
40396: LIST
40397: LIST
40398: LIST
40399: LIST
40400: LIST
40401: LIST
40402: LIST
40403: LIST
40404: LIST
40405: LIST
40406: LIST
40407: LIST
40408: LIST
40409: LIST
40410: LIST
40411: LIST
40412: LIST
40413: LIST
40414: ST_TO_ADDR
// fLab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
40415: LD_ADDR_VAR 0 42
40419: PUSH
40420: LD_INT 0
40422: PUSH
40423: LD_INT 0
40425: PUSH
40426: EMPTY
40427: LIST
40428: LIST
40429: PUSH
40430: LD_INT 0
40432: PUSH
40433: LD_INT 1
40435: NEG
40436: PUSH
40437: EMPTY
40438: LIST
40439: LIST
40440: PUSH
40441: LD_INT 1
40443: PUSH
40444: LD_INT 0
40446: PUSH
40447: EMPTY
40448: LIST
40449: LIST
40450: PUSH
40451: LD_INT 1
40453: PUSH
40454: LD_INT 1
40456: PUSH
40457: EMPTY
40458: LIST
40459: LIST
40460: PUSH
40461: LD_INT 0
40463: PUSH
40464: LD_INT 1
40466: PUSH
40467: EMPTY
40468: LIST
40469: LIST
40470: PUSH
40471: LD_INT 1
40473: NEG
40474: PUSH
40475: LD_INT 0
40477: PUSH
40478: EMPTY
40479: LIST
40480: LIST
40481: PUSH
40482: LD_INT 1
40484: NEG
40485: PUSH
40486: LD_INT 1
40488: NEG
40489: PUSH
40490: EMPTY
40491: LIST
40492: LIST
40493: PUSH
40494: LD_INT 1
40496: NEG
40497: PUSH
40498: LD_INT 2
40500: NEG
40501: PUSH
40502: EMPTY
40503: LIST
40504: LIST
40505: PUSH
40506: LD_INT 0
40508: PUSH
40509: LD_INT 2
40511: NEG
40512: PUSH
40513: EMPTY
40514: LIST
40515: LIST
40516: PUSH
40517: LD_INT 1
40519: PUSH
40520: LD_INT 1
40522: NEG
40523: PUSH
40524: EMPTY
40525: LIST
40526: LIST
40527: PUSH
40528: LD_INT 2
40530: PUSH
40531: LD_INT 1
40533: PUSH
40534: EMPTY
40535: LIST
40536: LIST
40537: PUSH
40538: LD_INT 2
40540: PUSH
40541: LD_INT 2
40543: PUSH
40544: EMPTY
40545: LIST
40546: LIST
40547: PUSH
40548: LD_INT 1
40550: PUSH
40551: LD_INT 2
40553: PUSH
40554: EMPTY
40555: LIST
40556: LIST
40557: PUSH
40558: LD_INT 0
40560: PUSH
40561: LD_INT 2
40563: PUSH
40564: EMPTY
40565: LIST
40566: LIST
40567: PUSH
40568: LD_INT 1
40570: NEG
40571: PUSH
40572: LD_INT 1
40574: PUSH
40575: EMPTY
40576: LIST
40577: LIST
40578: PUSH
40579: LD_INT 2
40581: NEG
40582: PUSH
40583: LD_INT 1
40585: NEG
40586: PUSH
40587: EMPTY
40588: LIST
40589: LIST
40590: PUSH
40591: LD_INT 2
40593: NEG
40594: PUSH
40595: LD_INT 2
40597: NEG
40598: PUSH
40599: EMPTY
40600: LIST
40601: LIST
40602: PUSH
40603: LD_INT 2
40605: NEG
40606: PUSH
40607: LD_INT 3
40609: NEG
40610: PUSH
40611: EMPTY
40612: LIST
40613: LIST
40614: PUSH
40615: LD_INT 1
40617: NEG
40618: PUSH
40619: LD_INT 3
40621: NEG
40622: PUSH
40623: EMPTY
40624: LIST
40625: LIST
40626: PUSH
40627: LD_INT 0
40629: PUSH
40630: LD_INT 3
40632: NEG
40633: PUSH
40634: EMPTY
40635: LIST
40636: LIST
40637: PUSH
40638: LD_INT 1
40640: PUSH
40641: LD_INT 2
40643: NEG
40644: PUSH
40645: EMPTY
40646: LIST
40647: LIST
40648: PUSH
40649: LD_INT 3
40651: PUSH
40652: LD_INT 2
40654: PUSH
40655: EMPTY
40656: LIST
40657: LIST
40658: PUSH
40659: LD_INT 3
40661: PUSH
40662: LD_INT 3
40664: PUSH
40665: EMPTY
40666: LIST
40667: LIST
40668: PUSH
40669: LD_INT 2
40671: PUSH
40672: LD_INT 3
40674: PUSH
40675: EMPTY
40676: LIST
40677: LIST
40678: PUSH
40679: LD_INT 1
40681: PUSH
40682: LD_INT 3
40684: PUSH
40685: EMPTY
40686: LIST
40687: LIST
40688: PUSH
40689: LD_INT 0
40691: PUSH
40692: LD_INT 3
40694: PUSH
40695: EMPTY
40696: LIST
40697: LIST
40698: PUSH
40699: LD_INT 1
40701: NEG
40702: PUSH
40703: LD_INT 2
40705: PUSH
40706: EMPTY
40707: LIST
40708: LIST
40709: PUSH
40710: LD_INT 3
40712: NEG
40713: PUSH
40714: LD_INT 2
40716: NEG
40717: PUSH
40718: EMPTY
40719: LIST
40720: LIST
40721: PUSH
40722: LD_INT 3
40724: NEG
40725: PUSH
40726: LD_INT 3
40728: NEG
40729: PUSH
40730: EMPTY
40731: LIST
40732: LIST
40733: PUSH
40734: EMPTY
40735: LIST
40736: LIST
40737: LIST
40738: LIST
40739: LIST
40740: LIST
40741: LIST
40742: LIST
40743: LIST
40744: LIST
40745: LIST
40746: LIST
40747: LIST
40748: LIST
40749: LIST
40750: LIST
40751: LIST
40752: LIST
40753: LIST
40754: LIST
40755: LIST
40756: LIST
40757: LIST
40758: LIST
40759: LIST
40760: LIST
40761: LIST
40762: LIST
40763: LIST
40764: ST_TO_ADDR
// fLab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
40765: LD_ADDR_VAR 0 43
40769: PUSH
40770: LD_INT 0
40772: PUSH
40773: LD_INT 0
40775: PUSH
40776: EMPTY
40777: LIST
40778: LIST
40779: PUSH
40780: LD_INT 0
40782: PUSH
40783: LD_INT 1
40785: NEG
40786: PUSH
40787: EMPTY
40788: LIST
40789: LIST
40790: PUSH
40791: LD_INT 1
40793: PUSH
40794: LD_INT 0
40796: PUSH
40797: EMPTY
40798: LIST
40799: LIST
40800: PUSH
40801: LD_INT 1
40803: PUSH
40804: LD_INT 1
40806: PUSH
40807: EMPTY
40808: LIST
40809: LIST
40810: PUSH
40811: LD_INT 0
40813: PUSH
40814: LD_INT 1
40816: PUSH
40817: EMPTY
40818: LIST
40819: LIST
40820: PUSH
40821: LD_INT 1
40823: NEG
40824: PUSH
40825: LD_INT 0
40827: PUSH
40828: EMPTY
40829: LIST
40830: LIST
40831: PUSH
40832: LD_INT 1
40834: NEG
40835: PUSH
40836: LD_INT 1
40838: NEG
40839: PUSH
40840: EMPTY
40841: LIST
40842: LIST
40843: PUSH
40844: LD_INT 1
40846: NEG
40847: PUSH
40848: LD_INT 2
40850: NEG
40851: PUSH
40852: EMPTY
40853: LIST
40854: LIST
40855: PUSH
40856: LD_INT 0
40858: PUSH
40859: LD_INT 2
40861: NEG
40862: PUSH
40863: EMPTY
40864: LIST
40865: LIST
40866: PUSH
40867: LD_INT 1
40869: PUSH
40870: LD_INT 1
40872: NEG
40873: PUSH
40874: EMPTY
40875: LIST
40876: LIST
40877: PUSH
40878: LD_INT 2
40880: PUSH
40881: LD_INT 0
40883: PUSH
40884: EMPTY
40885: LIST
40886: LIST
40887: PUSH
40888: LD_INT 2
40890: PUSH
40891: LD_INT 1
40893: PUSH
40894: EMPTY
40895: LIST
40896: LIST
40897: PUSH
40898: LD_INT 1
40900: PUSH
40901: LD_INT 2
40903: PUSH
40904: EMPTY
40905: LIST
40906: LIST
40907: PUSH
40908: LD_INT 0
40910: PUSH
40911: LD_INT 2
40913: PUSH
40914: EMPTY
40915: LIST
40916: LIST
40917: PUSH
40918: LD_INT 1
40920: NEG
40921: PUSH
40922: LD_INT 1
40924: PUSH
40925: EMPTY
40926: LIST
40927: LIST
40928: PUSH
40929: LD_INT 2
40931: NEG
40932: PUSH
40933: LD_INT 0
40935: PUSH
40936: EMPTY
40937: LIST
40938: LIST
40939: PUSH
40940: LD_INT 2
40942: NEG
40943: PUSH
40944: LD_INT 1
40946: NEG
40947: PUSH
40948: EMPTY
40949: LIST
40950: LIST
40951: PUSH
40952: LD_INT 1
40954: NEG
40955: PUSH
40956: LD_INT 3
40958: NEG
40959: PUSH
40960: EMPTY
40961: LIST
40962: LIST
40963: PUSH
40964: LD_INT 0
40966: PUSH
40967: LD_INT 3
40969: NEG
40970: PUSH
40971: EMPTY
40972: LIST
40973: LIST
40974: PUSH
40975: LD_INT 1
40977: PUSH
40978: LD_INT 2
40980: NEG
40981: PUSH
40982: EMPTY
40983: LIST
40984: LIST
40985: PUSH
40986: LD_INT 2
40988: PUSH
40989: LD_INT 1
40991: NEG
40992: PUSH
40993: EMPTY
40994: LIST
40995: LIST
40996: PUSH
40997: LD_INT 3
40999: PUSH
41000: LD_INT 0
41002: PUSH
41003: EMPTY
41004: LIST
41005: LIST
41006: PUSH
41007: LD_INT 3
41009: PUSH
41010: LD_INT 1
41012: PUSH
41013: EMPTY
41014: LIST
41015: LIST
41016: PUSH
41017: LD_INT 1
41019: PUSH
41020: LD_INT 3
41022: PUSH
41023: EMPTY
41024: LIST
41025: LIST
41026: PUSH
41027: LD_INT 0
41029: PUSH
41030: LD_INT 3
41032: PUSH
41033: EMPTY
41034: LIST
41035: LIST
41036: PUSH
41037: LD_INT 1
41039: NEG
41040: PUSH
41041: LD_INT 2
41043: PUSH
41044: EMPTY
41045: LIST
41046: LIST
41047: PUSH
41048: LD_INT 2
41050: NEG
41051: PUSH
41052: LD_INT 1
41054: PUSH
41055: EMPTY
41056: LIST
41057: LIST
41058: PUSH
41059: LD_INT 3
41061: NEG
41062: PUSH
41063: LD_INT 0
41065: PUSH
41066: EMPTY
41067: LIST
41068: LIST
41069: PUSH
41070: LD_INT 3
41072: NEG
41073: PUSH
41074: LD_INT 1
41076: NEG
41077: PUSH
41078: EMPTY
41079: LIST
41080: LIST
41081: PUSH
41082: EMPTY
41083: LIST
41084: LIST
41085: LIST
41086: LIST
41087: LIST
41088: LIST
41089: LIST
41090: LIST
41091: LIST
41092: LIST
41093: LIST
41094: LIST
41095: LIST
41096: LIST
41097: LIST
41098: LIST
41099: LIST
41100: LIST
41101: LIST
41102: LIST
41103: LIST
41104: LIST
41105: LIST
41106: LIST
41107: LIST
41108: LIST
41109: LIST
41110: LIST
41111: LIST
41112: ST_TO_ADDR
// fLab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
41113: LD_ADDR_VAR 0 44
41117: PUSH
41118: LD_INT 0
41120: PUSH
41121: LD_INT 0
41123: PUSH
41124: EMPTY
41125: LIST
41126: LIST
41127: PUSH
41128: LD_INT 0
41130: PUSH
41131: LD_INT 1
41133: NEG
41134: PUSH
41135: EMPTY
41136: LIST
41137: LIST
41138: PUSH
41139: LD_INT 1
41141: PUSH
41142: LD_INT 0
41144: PUSH
41145: EMPTY
41146: LIST
41147: LIST
41148: PUSH
41149: LD_INT 1
41151: PUSH
41152: LD_INT 1
41154: PUSH
41155: EMPTY
41156: LIST
41157: LIST
41158: PUSH
41159: LD_INT 0
41161: PUSH
41162: LD_INT 1
41164: PUSH
41165: EMPTY
41166: LIST
41167: LIST
41168: PUSH
41169: LD_INT 1
41171: NEG
41172: PUSH
41173: LD_INT 0
41175: PUSH
41176: EMPTY
41177: LIST
41178: LIST
41179: PUSH
41180: LD_INT 1
41182: NEG
41183: PUSH
41184: LD_INT 1
41186: NEG
41187: PUSH
41188: EMPTY
41189: LIST
41190: LIST
41191: PUSH
41192: LD_INT 1
41194: NEG
41195: PUSH
41196: LD_INT 2
41198: NEG
41199: PUSH
41200: EMPTY
41201: LIST
41202: LIST
41203: PUSH
41204: LD_INT 1
41206: PUSH
41207: LD_INT 1
41209: NEG
41210: PUSH
41211: EMPTY
41212: LIST
41213: LIST
41214: PUSH
41215: LD_INT 2
41217: PUSH
41218: LD_INT 0
41220: PUSH
41221: EMPTY
41222: LIST
41223: LIST
41224: PUSH
41225: LD_INT 2
41227: PUSH
41228: LD_INT 1
41230: PUSH
41231: EMPTY
41232: LIST
41233: LIST
41234: PUSH
41235: LD_INT 2
41237: PUSH
41238: LD_INT 2
41240: PUSH
41241: EMPTY
41242: LIST
41243: LIST
41244: PUSH
41245: LD_INT 1
41247: PUSH
41248: LD_INT 2
41250: PUSH
41251: EMPTY
41252: LIST
41253: LIST
41254: PUSH
41255: LD_INT 1
41257: NEG
41258: PUSH
41259: LD_INT 1
41261: PUSH
41262: EMPTY
41263: LIST
41264: LIST
41265: PUSH
41266: LD_INT 2
41268: NEG
41269: PUSH
41270: LD_INT 0
41272: PUSH
41273: EMPTY
41274: LIST
41275: LIST
41276: PUSH
41277: LD_INT 2
41279: NEG
41280: PUSH
41281: LD_INT 1
41283: NEG
41284: PUSH
41285: EMPTY
41286: LIST
41287: LIST
41288: PUSH
41289: LD_INT 2
41291: NEG
41292: PUSH
41293: LD_INT 2
41295: NEG
41296: PUSH
41297: EMPTY
41298: LIST
41299: LIST
41300: PUSH
41301: LD_INT 2
41303: NEG
41304: PUSH
41305: LD_INT 3
41307: NEG
41308: PUSH
41309: EMPTY
41310: LIST
41311: LIST
41312: PUSH
41313: LD_INT 2
41315: PUSH
41316: LD_INT 1
41318: NEG
41319: PUSH
41320: EMPTY
41321: LIST
41322: LIST
41323: PUSH
41324: LD_INT 3
41326: PUSH
41327: LD_INT 0
41329: PUSH
41330: EMPTY
41331: LIST
41332: LIST
41333: PUSH
41334: LD_INT 3
41336: PUSH
41337: LD_INT 1
41339: PUSH
41340: EMPTY
41341: LIST
41342: LIST
41343: PUSH
41344: LD_INT 3
41346: PUSH
41347: LD_INT 2
41349: PUSH
41350: EMPTY
41351: LIST
41352: LIST
41353: PUSH
41354: LD_INT 3
41356: PUSH
41357: LD_INT 3
41359: PUSH
41360: EMPTY
41361: LIST
41362: LIST
41363: PUSH
41364: LD_INT 2
41366: PUSH
41367: LD_INT 3
41369: PUSH
41370: EMPTY
41371: LIST
41372: LIST
41373: PUSH
41374: LD_INT 2
41376: NEG
41377: PUSH
41378: LD_INT 1
41380: PUSH
41381: EMPTY
41382: LIST
41383: LIST
41384: PUSH
41385: LD_INT 3
41387: NEG
41388: PUSH
41389: LD_INT 0
41391: PUSH
41392: EMPTY
41393: LIST
41394: LIST
41395: PUSH
41396: LD_INT 3
41398: NEG
41399: PUSH
41400: LD_INT 1
41402: NEG
41403: PUSH
41404: EMPTY
41405: LIST
41406: LIST
41407: PUSH
41408: LD_INT 3
41410: NEG
41411: PUSH
41412: LD_INT 2
41414: NEG
41415: PUSH
41416: EMPTY
41417: LIST
41418: LIST
41419: PUSH
41420: LD_INT 3
41422: NEG
41423: PUSH
41424: LD_INT 3
41426: NEG
41427: PUSH
41428: EMPTY
41429: LIST
41430: LIST
41431: PUSH
41432: EMPTY
41433: LIST
41434: LIST
41435: LIST
41436: LIST
41437: LIST
41438: LIST
41439: LIST
41440: LIST
41441: LIST
41442: LIST
41443: LIST
41444: LIST
41445: LIST
41446: LIST
41447: LIST
41448: LIST
41449: LIST
41450: LIST
41451: LIST
41452: LIST
41453: LIST
41454: LIST
41455: LIST
41456: LIST
41457: LIST
41458: LIST
41459: LIST
41460: LIST
41461: LIST
41462: ST_TO_ADDR
// fLab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
41463: LD_ADDR_VAR 0 45
41467: PUSH
41468: LD_INT 0
41470: PUSH
41471: LD_INT 0
41473: PUSH
41474: EMPTY
41475: LIST
41476: LIST
41477: PUSH
41478: LD_INT 0
41480: PUSH
41481: LD_INT 1
41483: NEG
41484: PUSH
41485: EMPTY
41486: LIST
41487: LIST
41488: PUSH
41489: LD_INT 1
41491: PUSH
41492: LD_INT 0
41494: PUSH
41495: EMPTY
41496: LIST
41497: LIST
41498: PUSH
41499: LD_INT 1
41501: PUSH
41502: LD_INT 1
41504: PUSH
41505: EMPTY
41506: LIST
41507: LIST
41508: PUSH
41509: LD_INT 0
41511: PUSH
41512: LD_INT 1
41514: PUSH
41515: EMPTY
41516: LIST
41517: LIST
41518: PUSH
41519: LD_INT 1
41521: NEG
41522: PUSH
41523: LD_INT 0
41525: PUSH
41526: EMPTY
41527: LIST
41528: LIST
41529: PUSH
41530: LD_INT 1
41532: NEG
41533: PUSH
41534: LD_INT 1
41536: NEG
41537: PUSH
41538: EMPTY
41539: LIST
41540: LIST
41541: PUSH
41542: LD_INT 1
41544: NEG
41545: PUSH
41546: LD_INT 2
41548: NEG
41549: PUSH
41550: EMPTY
41551: LIST
41552: LIST
41553: PUSH
41554: LD_INT 0
41556: PUSH
41557: LD_INT 2
41559: NEG
41560: PUSH
41561: EMPTY
41562: LIST
41563: LIST
41564: PUSH
41565: LD_INT 1
41567: PUSH
41568: LD_INT 1
41570: NEG
41571: PUSH
41572: EMPTY
41573: LIST
41574: LIST
41575: PUSH
41576: LD_INT 2
41578: PUSH
41579: LD_INT 1
41581: PUSH
41582: EMPTY
41583: LIST
41584: LIST
41585: PUSH
41586: LD_INT 2
41588: PUSH
41589: LD_INT 2
41591: PUSH
41592: EMPTY
41593: LIST
41594: LIST
41595: PUSH
41596: LD_INT 1
41598: PUSH
41599: LD_INT 2
41601: PUSH
41602: EMPTY
41603: LIST
41604: LIST
41605: PUSH
41606: LD_INT 0
41608: PUSH
41609: LD_INT 2
41611: PUSH
41612: EMPTY
41613: LIST
41614: LIST
41615: PUSH
41616: LD_INT 1
41618: NEG
41619: PUSH
41620: LD_INT 1
41622: PUSH
41623: EMPTY
41624: LIST
41625: LIST
41626: PUSH
41627: LD_INT 2
41629: NEG
41630: PUSH
41631: LD_INT 1
41633: NEG
41634: PUSH
41635: EMPTY
41636: LIST
41637: LIST
41638: PUSH
41639: LD_INT 2
41641: NEG
41642: PUSH
41643: LD_INT 2
41645: NEG
41646: PUSH
41647: EMPTY
41648: LIST
41649: LIST
41650: PUSH
41651: LD_INT 2
41653: NEG
41654: PUSH
41655: LD_INT 3
41657: NEG
41658: PUSH
41659: EMPTY
41660: LIST
41661: LIST
41662: PUSH
41663: LD_INT 1
41665: NEG
41666: PUSH
41667: LD_INT 3
41669: NEG
41670: PUSH
41671: EMPTY
41672: LIST
41673: LIST
41674: PUSH
41675: LD_INT 0
41677: PUSH
41678: LD_INT 3
41680: NEG
41681: PUSH
41682: EMPTY
41683: LIST
41684: LIST
41685: PUSH
41686: LD_INT 1
41688: PUSH
41689: LD_INT 2
41691: NEG
41692: PUSH
41693: EMPTY
41694: LIST
41695: LIST
41696: PUSH
41697: LD_INT 3
41699: PUSH
41700: LD_INT 2
41702: PUSH
41703: EMPTY
41704: LIST
41705: LIST
41706: PUSH
41707: LD_INT 3
41709: PUSH
41710: LD_INT 3
41712: PUSH
41713: EMPTY
41714: LIST
41715: LIST
41716: PUSH
41717: LD_INT 2
41719: PUSH
41720: LD_INT 3
41722: PUSH
41723: EMPTY
41724: LIST
41725: LIST
41726: PUSH
41727: LD_INT 1
41729: PUSH
41730: LD_INT 3
41732: PUSH
41733: EMPTY
41734: LIST
41735: LIST
41736: PUSH
41737: LD_INT 0
41739: PUSH
41740: LD_INT 3
41742: PUSH
41743: EMPTY
41744: LIST
41745: LIST
41746: PUSH
41747: LD_INT 1
41749: NEG
41750: PUSH
41751: LD_INT 2
41753: PUSH
41754: EMPTY
41755: LIST
41756: LIST
41757: PUSH
41758: LD_INT 3
41760: NEG
41761: PUSH
41762: LD_INT 2
41764: NEG
41765: PUSH
41766: EMPTY
41767: LIST
41768: LIST
41769: PUSH
41770: LD_INT 3
41772: NEG
41773: PUSH
41774: LD_INT 3
41776: NEG
41777: PUSH
41778: EMPTY
41779: LIST
41780: LIST
41781: PUSH
41782: EMPTY
41783: LIST
41784: LIST
41785: LIST
41786: LIST
41787: LIST
41788: LIST
41789: LIST
41790: LIST
41791: LIST
41792: LIST
41793: LIST
41794: LIST
41795: LIST
41796: LIST
41797: LIST
41798: LIST
41799: LIST
41800: LIST
41801: LIST
41802: LIST
41803: LIST
41804: LIST
41805: LIST
41806: LIST
41807: LIST
41808: LIST
41809: LIST
41810: LIST
41811: LIST
41812: ST_TO_ADDR
// fLab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
41813: LD_ADDR_VAR 0 46
41817: PUSH
41818: LD_INT 0
41820: PUSH
41821: LD_INT 0
41823: PUSH
41824: EMPTY
41825: LIST
41826: LIST
41827: PUSH
41828: LD_INT 0
41830: PUSH
41831: LD_INT 1
41833: NEG
41834: PUSH
41835: EMPTY
41836: LIST
41837: LIST
41838: PUSH
41839: LD_INT 1
41841: PUSH
41842: LD_INT 0
41844: PUSH
41845: EMPTY
41846: LIST
41847: LIST
41848: PUSH
41849: LD_INT 1
41851: PUSH
41852: LD_INT 1
41854: PUSH
41855: EMPTY
41856: LIST
41857: LIST
41858: PUSH
41859: LD_INT 0
41861: PUSH
41862: LD_INT 1
41864: PUSH
41865: EMPTY
41866: LIST
41867: LIST
41868: PUSH
41869: LD_INT 1
41871: NEG
41872: PUSH
41873: LD_INT 0
41875: PUSH
41876: EMPTY
41877: LIST
41878: LIST
41879: PUSH
41880: LD_INT 1
41882: NEG
41883: PUSH
41884: LD_INT 1
41886: NEG
41887: PUSH
41888: EMPTY
41889: LIST
41890: LIST
41891: PUSH
41892: LD_INT 1
41894: NEG
41895: PUSH
41896: LD_INT 2
41898: NEG
41899: PUSH
41900: EMPTY
41901: LIST
41902: LIST
41903: PUSH
41904: LD_INT 0
41906: PUSH
41907: LD_INT 2
41909: NEG
41910: PUSH
41911: EMPTY
41912: LIST
41913: LIST
41914: PUSH
41915: LD_INT 1
41917: PUSH
41918: LD_INT 1
41920: NEG
41921: PUSH
41922: EMPTY
41923: LIST
41924: LIST
41925: PUSH
41926: LD_INT 2
41928: PUSH
41929: LD_INT 0
41931: PUSH
41932: EMPTY
41933: LIST
41934: LIST
41935: PUSH
41936: LD_INT 2
41938: PUSH
41939: LD_INT 1
41941: PUSH
41942: EMPTY
41943: LIST
41944: LIST
41945: PUSH
41946: LD_INT 1
41948: PUSH
41949: LD_INT 2
41951: PUSH
41952: EMPTY
41953: LIST
41954: LIST
41955: PUSH
41956: LD_INT 0
41958: PUSH
41959: LD_INT 2
41961: PUSH
41962: EMPTY
41963: LIST
41964: LIST
41965: PUSH
41966: LD_INT 1
41968: NEG
41969: PUSH
41970: LD_INT 1
41972: PUSH
41973: EMPTY
41974: LIST
41975: LIST
41976: PUSH
41977: LD_INT 2
41979: NEG
41980: PUSH
41981: LD_INT 0
41983: PUSH
41984: EMPTY
41985: LIST
41986: LIST
41987: PUSH
41988: LD_INT 2
41990: NEG
41991: PUSH
41992: LD_INT 1
41994: NEG
41995: PUSH
41996: EMPTY
41997: LIST
41998: LIST
41999: PUSH
42000: LD_INT 1
42002: NEG
42003: PUSH
42004: LD_INT 3
42006: NEG
42007: PUSH
42008: EMPTY
42009: LIST
42010: LIST
42011: PUSH
42012: LD_INT 0
42014: PUSH
42015: LD_INT 3
42017: NEG
42018: PUSH
42019: EMPTY
42020: LIST
42021: LIST
42022: PUSH
42023: LD_INT 1
42025: PUSH
42026: LD_INT 2
42028: NEG
42029: PUSH
42030: EMPTY
42031: LIST
42032: LIST
42033: PUSH
42034: LD_INT 2
42036: PUSH
42037: LD_INT 1
42039: NEG
42040: PUSH
42041: EMPTY
42042: LIST
42043: LIST
42044: PUSH
42045: LD_INT 3
42047: PUSH
42048: LD_INT 0
42050: PUSH
42051: EMPTY
42052: LIST
42053: LIST
42054: PUSH
42055: LD_INT 3
42057: PUSH
42058: LD_INT 1
42060: PUSH
42061: EMPTY
42062: LIST
42063: LIST
42064: PUSH
42065: LD_INT 1
42067: PUSH
42068: LD_INT 3
42070: PUSH
42071: EMPTY
42072: LIST
42073: LIST
42074: PUSH
42075: LD_INT 0
42077: PUSH
42078: LD_INT 3
42080: PUSH
42081: EMPTY
42082: LIST
42083: LIST
42084: PUSH
42085: LD_INT 1
42087: NEG
42088: PUSH
42089: LD_INT 2
42091: PUSH
42092: EMPTY
42093: LIST
42094: LIST
42095: PUSH
42096: LD_INT 2
42098: NEG
42099: PUSH
42100: LD_INT 1
42102: PUSH
42103: EMPTY
42104: LIST
42105: LIST
42106: PUSH
42107: LD_INT 3
42109: NEG
42110: PUSH
42111: LD_INT 0
42113: PUSH
42114: EMPTY
42115: LIST
42116: LIST
42117: PUSH
42118: LD_INT 3
42120: NEG
42121: PUSH
42122: LD_INT 1
42124: NEG
42125: PUSH
42126: EMPTY
42127: LIST
42128: LIST
42129: PUSH
42130: EMPTY
42131: LIST
42132: LIST
42133: LIST
42134: LIST
42135: LIST
42136: LIST
42137: LIST
42138: LIST
42139: LIST
42140: LIST
42141: LIST
42142: LIST
42143: LIST
42144: LIST
42145: LIST
42146: LIST
42147: LIST
42148: LIST
42149: LIST
42150: LIST
42151: LIST
42152: LIST
42153: LIST
42154: LIST
42155: LIST
42156: LIST
42157: LIST
42158: LIST
42159: LIST
42160: ST_TO_ADDR
// fControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
42161: LD_ADDR_VAR 0 47
42165: PUSH
42166: LD_INT 0
42168: PUSH
42169: LD_INT 0
42171: PUSH
42172: EMPTY
42173: LIST
42174: LIST
42175: PUSH
42176: LD_INT 0
42178: PUSH
42179: LD_INT 1
42181: NEG
42182: PUSH
42183: EMPTY
42184: LIST
42185: LIST
42186: PUSH
42187: LD_INT 1
42189: PUSH
42190: LD_INT 0
42192: PUSH
42193: EMPTY
42194: LIST
42195: LIST
42196: PUSH
42197: LD_INT 1
42199: PUSH
42200: LD_INT 1
42202: PUSH
42203: EMPTY
42204: LIST
42205: LIST
42206: PUSH
42207: LD_INT 0
42209: PUSH
42210: LD_INT 1
42212: PUSH
42213: EMPTY
42214: LIST
42215: LIST
42216: PUSH
42217: LD_INT 1
42219: NEG
42220: PUSH
42221: LD_INT 0
42223: PUSH
42224: EMPTY
42225: LIST
42226: LIST
42227: PUSH
42228: LD_INT 1
42230: NEG
42231: PUSH
42232: LD_INT 1
42234: NEG
42235: PUSH
42236: EMPTY
42237: LIST
42238: LIST
42239: PUSH
42240: LD_INT 1
42242: NEG
42243: PUSH
42244: LD_INT 2
42246: NEG
42247: PUSH
42248: EMPTY
42249: LIST
42250: LIST
42251: PUSH
42252: LD_INT 0
42254: PUSH
42255: LD_INT 2
42257: NEG
42258: PUSH
42259: EMPTY
42260: LIST
42261: LIST
42262: PUSH
42263: LD_INT 1
42265: PUSH
42266: LD_INT 1
42268: NEG
42269: PUSH
42270: EMPTY
42271: LIST
42272: LIST
42273: PUSH
42274: LD_INT 2
42276: NEG
42277: PUSH
42278: LD_INT 1
42280: NEG
42281: PUSH
42282: EMPTY
42283: LIST
42284: LIST
42285: PUSH
42286: LD_INT 2
42288: NEG
42289: PUSH
42290: LD_INT 2
42292: NEG
42293: PUSH
42294: EMPTY
42295: LIST
42296: LIST
42297: PUSH
42298: EMPTY
42299: LIST
42300: LIST
42301: LIST
42302: LIST
42303: LIST
42304: LIST
42305: LIST
42306: LIST
42307: LIST
42308: LIST
42309: LIST
42310: LIST
42311: ST_TO_ADDR
// fControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
42312: LD_ADDR_VAR 0 48
42316: PUSH
42317: LD_INT 0
42319: PUSH
42320: LD_INT 0
42322: PUSH
42323: EMPTY
42324: LIST
42325: LIST
42326: PUSH
42327: LD_INT 0
42329: PUSH
42330: LD_INT 1
42332: NEG
42333: PUSH
42334: EMPTY
42335: LIST
42336: LIST
42337: PUSH
42338: LD_INT 1
42340: PUSH
42341: LD_INT 0
42343: PUSH
42344: EMPTY
42345: LIST
42346: LIST
42347: PUSH
42348: LD_INT 1
42350: PUSH
42351: LD_INT 1
42353: PUSH
42354: EMPTY
42355: LIST
42356: LIST
42357: PUSH
42358: LD_INT 0
42360: PUSH
42361: LD_INT 1
42363: PUSH
42364: EMPTY
42365: LIST
42366: LIST
42367: PUSH
42368: LD_INT 1
42370: NEG
42371: PUSH
42372: LD_INT 0
42374: PUSH
42375: EMPTY
42376: LIST
42377: LIST
42378: PUSH
42379: LD_INT 1
42381: NEG
42382: PUSH
42383: LD_INT 1
42385: NEG
42386: PUSH
42387: EMPTY
42388: LIST
42389: LIST
42390: PUSH
42391: LD_INT 1
42393: NEG
42394: PUSH
42395: LD_INT 2
42397: NEG
42398: PUSH
42399: EMPTY
42400: LIST
42401: LIST
42402: PUSH
42403: LD_INT 0
42405: PUSH
42406: LD_INT 2
42408: NEG
42409: PUSH
42410: EMPTY
42411: LIST
42412: LIST
42413: PUSH
42414: LD_INT 1
42416: PUSH
42417: LD_INT 1
42419: NEG
42420: PUSH
42421: EMPTY
42422: LIST
42423: LIST
42424: PUSH
42425: LD_INT 2
42427: PUSH
42428: LD_INT 0
42430: PUSH
42431: EMPTY
42432: LIST
42433: LIST
42434: PUSH
42435: LD_INT 2
42437: PUSH
42438: LD_INT 1
42440: PUSH
42441: EMPTY
42442: LIST
42443: LIST
42444: PUSH
42445: EMPTY
42446: LIST
42447: LIST
42448: LIST
42449: LIST
42450: LIST
42451: LIST
42452: LIST
42453: LIST
42454: LIST
42455: LIST
42456: LIST
42457: LIST
42458: ST_TO_ADDR
// fControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
42459: LD_ADDR_VAR 0 49
42463: PUSH
42464: LD_INT 0
42466: PUSH
42467: LD_INT 0
42469: PUSH
42470: EMPTY
42471: LIST
42472: LIST
42473: PUSH
42474: LD_INT 0
42476: PUSH
42477: LD_INT 1
42479: NEG
42480: PUSH
42481: EMPTY
42482: LIST
42483: LIST
42484: PUSH
42485: LD_INT 1
42487: PUSH
42488: LD_INT 0
42490: PUSH
42491: EMPTY
42492: LIST
42493: LIST
42494: PUSH
42495: LD_INT 1
42497: PUSH
42498: LD_INT 1
42500: PUSH
42501: EMPTY
42502: LIST
42503: LIST
42504: PUSH
42505: LD_INT 0
42507: PUSH
42508: LD_INT 1
42510: PUSH
42511: EMPTY
42512: LIST
42513: LIST
42514: PUSH
42515: LD_INT 1
42517: NEG
42518: PUSH
42519: LD_INT 0
42521: PUSH
42522: EMPTY
42523: LIST
42524: LIST
42525: PUSH
42526: LD_INT 1
42528: NEG
42529: PUSH
42530: LD_INT 1
42532: NEG
42533: PUSH
42534: EMPTY
42535: LIST
42536: LIST
42537: PUSH
42538: LD_INT 1
42540: PUSH
42541: LD_INT 1
42543: NEG
42544: PUSH
42545: EMPTY
42546: LIST
42547: LIST
42548: PUSH
42549: LD_INT 2
42551: PUSH
42552: LD_INT 0
42554: PUSH
42555: EMPTY
42556: LIST
42557: LIST
42558: PUSH
42559: LD_INT 2
42561: PUSH
42562: LD_INT 1
42564: PUSH
42565: EMPTY
42566: LIST
42567: LIST
42568: PUSH
42569: LD_INT 2
42571: PUSH
42572: LD_INT 2
42574: PUSH
42575: EMPTY
42576: LIST
42577: LIST
42578: PUSH
42579: LD_INT 1
42581: PUSH
42582: LD_INT 2
42584: PUSH
42585: EMPTY
42586: LIST
42587: LIST
42588: PUSH
42589: EMPTY
42590: LIST
42591: LIST
42592: LIST
42593: LIST
42594: LIST
42595: LIST
42596: LIST
42597: LIST
42598: LIST
42599: LIST
42600: LIST
42601: LIST
42602: ST_TO_ADDR
// fControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
42603: LD_ADDR_VAR 0 50
42607: PUSH
42608: LD_INT 0
42610: PUSH
42611: LD_INT 0
42613: PUSH
42614: EMPTY
42615: LIST
42616: LIST
42617: PUSH
42618: LD_INT 0
42620: PUSH
42621: LD_INT 1
42623: NEG
42624: PUSH
42625: EMPTY
42626: LIST
42627: LIST
42628: PUSH
42629: LD_INT 1
42631: PUSH
42632: LD_INT 0
42634: PUSH
42635: EMPTY
42636: LIST
42637: LIST
42638: PUSH
42639: LD_INT 1
42641: PUSH
42642: LD_INT 1
42644: PUSH
42645: EMPTY
42646: LIST
42647: LIST
42648: PUSH
42649: LD_INT 0
42651: PUSH
42652: LD_INT 1
42654: PUSH
42655: EMPTY
42656: LIST
42657: LIST
42658: PUSH
42659: LD_INT 1
42661: NEG
42662: PUSH
42663: LD_INT 0
42665: PUSH
42666: EMPTY
42667: LIST
42668: LIST
42669: PUSH
42670: LD_INT 1
42672: NEG
42673: PUSH
42674: LD_INT 1
42676: NEG
42677: PUSH
42678: EMPTY
42679: LIST
42680: LIST
42681: PUSH
42682: LD_INT 2
42684: PUSH
42685: LD_INT 1
42687: PUSH
42688: EMPTY
42689: LIST
42690: LIST
42691: PUSH
42692: LD_INT 2
42694: PUSH
42695: LD_INT 2
42697: PUSH
42698: EMPTY
42699: LIST
42700: LIST
42701: PUSH
42702: LD_INT 1
42704: PUSH
42705: LD_INT 2
42707: PUSH
42708: EMPTY
42709: LIST
42710: LIST
42711: PUSH
42712: LD_INT 0
42714: PUSH
42715: LD_INT 2
42717: PUSH
42718: EMPTY
42719: LIST
42720: LIST
42721: PUSH
42722: LD_INT 1
42724: NEG
42725: PUSH
42726: LD_INT 1
42728: PUSH
42729: EMPTY
42730: LIST
42731: LIST
42732: PUSH
42733: EMPTY
42734: LIST
42735: LIST
42736: LIST
42737: LIST
42738: LIST
42739: LIST
42740: LIST
42741: LIST
42742: LIST
42743: LIST
42744: LIST
42745: LIST
42746: ST_TO_ADDR
// fControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
42747: LD_ADDR_VAR 0 51
42751: PUSH
42752: LD_INT 0
42754: PUSH
42755: LD_INT 0
42757: PUSH
42758: EMPTY
42759: LIST
42760: LIST
42761: PUSH
42762: LD_INT 0
42764: PUSH
42765: LD_INT 1
42767: NEG
42768: PUSH
42769: EMPTY
42770: LIST
42771: LIST
42772: PUSH
42773: LD_INT 1
42775: PUSH
42776: LD_INT 0
42778: PUSH
42779: EMPTY
42780: LIST
42781: LIST
42782: PUSH
42783: LD_INT 1
42785: PUSH
42786: LD_INT 1
42788: PUSH
42789: EMPTY
42790: LIST
42791: LIST
42792: PUSH
42793: LD_INT 0
42795: PUSH
42796: LD_INT 1
42798: PUSH
42799: EMPTY
42800: LIST
42801: LIST
42802: PUSH
42803: LD_INT 1
42805: NEG
42806: PUSH
42807: LD_INT 0
42809: PUSH
42810: EMPTY
42811: LIST
42812: LIST
42813: PUSH
42814: LD_INT 1
42816: NEG
42817: PUSH
42818: LD_INT 1
42820: NEG
42821: PUSH
42822: EMPTY
42823: LIST
42824: LIST
42825: PUSH
42826: LD_INT 1
42828: PUSH
42829: LD_INT 2
42831: PUSH
42832: EMPTY
42833: LIST
42834: LIST
42835: PUSH
42836: LD_INT 0
42838: PUSH
42839: LD_INT 2
42841: PUSH
42842: EMPTY
42843: LIST
42844: LIST
42845: PUSH
42846: LD_INT 1
42848: NEG
42849: PUSH
42850: LD_INT 1
42852: PUSH
42853: EMPTY
42854: LIST
42855: LIST
42856: PUSH
42857: LD_INT 2
42859: NEG
42860: PUSH
42861: LD_INT 0
42863: PUSH
42864: EMPTY
42865: LIST
42866: LIST
42867: PUSH
42868: LD_INT 2
42870: NEG
42871: PUSH
42872: LD_INT 1
42874: NEG
42875: PUSH
42876: EMPTY
42877: LIST
42878: LIST
42879: PUSH
42880: EMPTY
42881: LIST
42882: LIST
42883: LIST
42884: LIST
42885: LIST
42886: LIST
42887: LIST
42888: LIST
42889: LIST
42890: LIST
42891: LIST
42892: LIST
42893: ST_TO_ADDR
// fControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
42894: LD_ADDR_VAR 0 52
42898: PUSH
42899: LD_INT 0
42901: PUSH
42902: LD_INT 0
42904: PUSH
42905: EMPTY
42906: LIST
42907: LIST
42908: PUSH
42909: LD_INT 0
42911: PUSH
42912: LD_INT 1
42914: NEG
42915: PUSH
42916: EMPTY
42917: LIST
42918: LIST
42919: PUSH
42920: LD_INT 1
42922: PUSH
42923: LD_INT 0
42925: PUSH
42926: EMPTY
42927: LIST
42928: LIST
42929: PUSH
42930: LD_INT 1
42932: PUSH
42933: LD_INT 1
42935: PUSH
42936: EMPTY
42937: LIST
42938: LIST
42939: PUSH
42940: LD_INT 0
42942: PUSH
42943: LD_INT 1
42945: PUSH
42946: EMPTY
42947: LIST
42948: LIST
42949: PUSH
42950: LD_INT 1
42952: NEG
42953: PUSH
42954: LD_INT 0
42956: PUSH
42957: EMPTY
42958: LIST
42959: LIST
42960: PUSH
42961: LD_INT 1
42963: NEG
42964: PUSH
42965: LD_INT 1
42967: NEG
42968: PUSH
42969: EMPTY
42970: LIST
42971: LIST
42972: PUSH
42973: LD_INT 1
42975: NEG
42976: PUSH
42977: LD_INT 2
42979: NEG
42980: PUSH
42981: EMPTY
42982: LIST
42983: LIST
42984: PUSH
42985: LD_INT 1
42987: NEG
42988: PUSH
42989: LD_INT 1
42991: PUSH
42992: EMPTY
42993: LIST
42994: LIST
42995: PUSH
42996: LD_INT 2
42998: NEG
42999: PUSH
43000: LD_INT 0
43002: PUSH
43003: EMPTY
43004: LIST
43005: LIST
43006: PUSH
43007: LD_INT 2
43009: NEG
43010: PUSH
43011: LD_INT 1
43013: NEG
43014: PUSH
43015: EMPTY
43016: LIST
43017: LIST
43018: PUSH
43019: LD_INT 2
43021: NEG
43022: PUSH
43023: LD_INT 2
43025: NEG
43026: PUSH
43027: EMPTY
43028: LIST
43029: LIST
43030: PUSH
43031: EMPTY
43032: LIST
43033: LIST
43034: LIST
43035: LIST
43036: LIST
43037: LIST
43038: LIST
43039: LIST
43040: LIST
43041: LIST
43042: LIST
43043: LIST
43044: ST_TO_ADDR
// fBarracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
43045: LD_ADDR_VAR 0 53
43049: PUSH
43050: LD_INT 0
43052: PUSH
43053: LD_INT 0
43055: PUSH
43056: EMPTY
43057: LIST
43058: LIST
43059: PUSH
43060: LD_INT 0
43062: PUSH
43063: LD_INT 1
43065: NEG
43066: PUSH
43067: EMPTY
43068: LIST
43069: LIST
43070: PUSH
43071: LD_INT 1
43073: PUSH
43074: LD_INT 0
43076: PUSH
43077: EMPTY
43078: LIST
43079: LIST
43080: PUSH
43081: LD_INT 1
43083: PUSH
43084: LD_INT 1
43086: PUSH
43087: EMPTY
43088: LIST
43089: LIST
43090: PUSH
43091: LD_INT 0
43093: PUSH
43094: LD_INT 1
43096: PUSH
43097: EMPTY
43098: LIST
43099: LIST
43100: PUSH
43101: LD_INT 1
43103: NEG
43104: PUSH
43105: LD_INT 0
43107: PUSH
43108: EMPTY
43109: LIST
43110: LIST
43111: PUSH
43112: LD_INT 1
43114: NEG
43115: PUSH
43116: LD_INT 1
43118: NEG
43119: PUSH
43120: EMPTY
43121: LIST
43122: LIST
43123: PUSH
43124: LD_INT 1
43126: NEG
43127: PUSH
43128: LD_INT 2
43130: NEG
43131: PUSH
43132: EMPTY
43133: LIST
43134: LIST
43135: PUSH
43136: LD_INT 0
43138: PUSH
43139: LD_INT 2
43141: NEG
43142: PUSH
43143: EMPTY
43144: LIST
43145: LIST
43146: PUSH
43147: LD_INT 1
43149: PUSH
43150: LD_INT 1
43152: NEG
43153: PUSH
43154: EMPTY
43155: LIST
43156: LIST
43157: PUSH
43158: LD_INT 2
43160: PUSH
43161: LD_INT 0
43163: PUSH
43164: EMPTY
43165: LIST
43166: LIST
43167: PUSH
43168: LD_INT 2
43170: PUSH
43171: LD_INT 1
43173: PUSH
43174: EMPTY
43175: LIST
43176: LIST
43177: PUSH
43178: LD_INT 2
43180: PUSH
43181: LD_INT 2
43183: PUSH
43184: EMPTY
43185: LIST
43186: LIST
43187: PUSH
43188: LD_INT 1
43190: PUSH
43191: LD_INT 2
43193: PUSH
43194: EMPTY
43195: LIST
43196: LIST
43197: PUSH
43198: LD_INT 0
43200: PUSH
43201: LD_INT 2
43203: PUSH
43204: EMPTY
43205: LIST
43206: LIST
43207: PUSH
43208: LD_INT 1
43210: NEG
43211: PUSH
43212: LD_INT 1
43214: PUSH
43215: EMPTY
43216: LIST
43217: LIST
43218: PUSH
43219: LD_INT 2
43221: NEG
43222: PUSH
43223: LD_INT 0
43225: PUSH
43226: EMPTY
43227: LIST
43228: LIST
43229: PUSH
43230: LD_INT 2
43232: NEG
43233: PUSH
43234: LD_INT 1
43236: NEG
43237: PUSH
43238: EMPTY
43239: LIST
43240: LIST
43241: PUSH
43242: LD_INT 2
43244: NEG
43245: PUSH
43246: LD_INT 2
43248: NEG
43249: PUSH
43250: EMPTY
43251: LIST
43252: LIST
43253: PUSH
43254: EMPTY
43255: LIST
43256: LIST
43257: LIST
43258: LIST
43259: LIST
43260: LIST
43261: LIST
43262: LIST
43263: LIST
43264: LIST
43265: LIST
43266: LIST
43267: LIST
43268: LIST
43269: LIST
43270: LIST
43271: LIST
43272: LIST
43273: LIST
43274: ST_TO_ADDR
// fBarracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
43275: LD_ADDR_VAR 0 54
43279: PUSH
43280: LD_INT 0
43282: PUSH
43283: LD_INT 0
43285: PUSH
43286: EMPTY
43287: LIST
43288: LIST
43289: PUSH
43290: LD_INT 0
43292: PUSH
43293: LD_INT 1
43295: NEG
43296: PUSH
43297: EMPTY
43298: LIST
43299: LIST
43300: PUSH
43301: LD_INT 1
43303: PUSH
43304: LD_INT 0
43306: PUSH
43307: EMPTY
43308: LIST
43309: LIST
43310: PUSH
43311: LD_INT 1
43313: PUSH
43314: LD_INT 1
43316: PUSH
43317: EMPTY
43318: LIST
43319: LIST
43320: PUSH
43321: LD_INT 0
43323: PUSH
43324: LD_INT 1
43326: PUSH
43327: EMPTY
43328: LIST
43329: LIST
43330: PUSH
43331: LD_INT 1
43333: NEG
43334: PUSH
43335: LD_INT 0
43337: PUSH
43338: EMPTY
43339: LIST
43340: LIST
43341: PUSH
43342: LD_INT 1
43344: NEG
43345: PUSH
43346: LD_INT 1
43348: NEG
43349: PUSH
43350: EMPTY
43351: LIST
43352: LIST
43353: PUSH
43354: LD_INT 1
43356: NEG
43357: PUSH
43358: LD_INT 2
43360: NEG
43361: PUSH
43362: EMPTY
43363: LIST
43364: LIST
43365: PUSH
43366: LD_INT 0
43368: PUSH
43369: LD_INT 2
43371: NEG
43372: PUSH
43373: EMPTY
43374: LIST
43375: LIST
43376: PUSH
43377: LD_INT 1
43379: PUSH
43380: LD_INT 1
43382: NEG
43383: PUSH
43384: EMPTY
43385: LIST
43386: LIST
43387: PUSH
43388: LD_INT 2
43390: PUSH
43391: LD_INT 0
43393: PUSH
43394: EMPTY
43395: LIST
43396: LIST
43397: PUSH
43398: LD_INT 2
43400: PUSH
43401: LD_INT 1
43403: PUSH
43404: EMPTY
43405: LIST
43406: LIST
43407: PUSH
43408: LD_INT 2
43410: PUSH
43411: LD_INT 2
43413: PUSH
43414: EMPTY
43415: LIST
43416: LIST
43417: PUSH
43418: LD_INT 1
43420: PUSH
43421: LD_INT 2
43423: PUSH
43424: EMPTY
43425: LIST
43426: LIST
43427: PUSH
43428: LD_INT 0
43430: PUSH
43431: LD_INT 2
43433: PUSH
43434: EMPTY
43435: LIST
43436: LIST
43437: PUSH
43438: LD_INT 1
43440: NEG
43441: PUSH
43442: LD_INT 1
43444: PUSH
43445: EMPTY
43446: LIST
43447: LIST
43448: PUSH
43449: LD_INT 2
43451: NEG
43452: PUSH
43453: LD_INT 0
43455: PUSH
43456: EMPTY
43457: LIST
43458: LIST
43459: PUSH
43460: LD_INT 2
43462: NEG
43463: PUSH
43464: LD_INT 1
43466: NEG
43467: PUSH
43468: EMPTY
43469: LIST
43470: LIST
43471: PUSH
43472: LD_INT 2
43474: NEG
43475: PUSH
43476: LD_INT 2
43478: NEG
43479: PUSH
43480: EMPTY
43481: LIST
43482: LIST
43483: PUSH
43484: EMPTY
43485: LIST
43486: LIST
43487: LIST
43488: LIST
43489: LIST
43490: LIST
43491: LIST
43492: LIST
43493: LIST
43494: LIST
43495: LIST
43496: LIST
43497: LIST
43498: LIST
43499: LIST
43500: LIST
43501: LIST
43502: LIST
43503: LIST
43504: ST_TO_ADDR
// fBarracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
43505: LD_ADDR_VAR 0 55
43509: PUSH
43510: LD_INT 0
43512: PUSH
43513: LD_INT 0
43515: PUSH
43516: EMPTY
43517: LIST
43518: LIST
43519: PUSH
43520: LD_INT 0
43522: PUSH
43523: LD_INT 1
43525: NEG
43526: PUSH
43527: EMPTY
43528: LIST
43529: LIST
43530: PUSH
43531: LD_INT 1
43533: PUSH
43534: LD_INT 0
43536: PUSH
43537: EMPTY
43538: LIST
43539: LIST
43540: PUSH
43541: LD_INT 1
43543: PUSH
43544: LD_INT 1
43546: PUSH
43547: EMPTY
43548: LIST
43549: LIST
43550: PUSH
43551: LD_INT 0
43553: PUSH
43554: LD_INT 1
43556: PUSH
43557: EMPTY
43558: LIST
43559: LIST
43560: PUSH
43561: LD_INT 1
43563: NEG
43564: PUSH
43565: LD_INT 0
43567: PUSH
43568: EMPTY
43569: LIST
43570: LIST
43571: PUSH
43572: LD_INT 1
43574: NEG
43575: PUSH
43576: LD_INT 1
43578: NEG
43579: PUSH
43580: EMPTY
43581: LIST
43582: LIST
43583: PUSH
43584: LD_INT 1
43586: NEG
43587: PUSH
43588: LD_INT 2
43590: NEG
43591: PUSH
43592: EMPTY
43593: LIST
43594: LIST
43595: PUSH
43596: LD_INT 0
43598: PUSH
43599: LD_INT 2
43601: NEG
43602: PUSH
43603: EMPTY
43604: LIST
43605: LIST
43606: PUSH
43607: LD_INT 1
43609: PUSH
43610: LD_INT 1
43612: NEG
43613: PUSH
43614: EMPTY
43615: LIST
43616: LIST
43617: PUSH
43618: LD_INT 2
43620: PUSH
43621: LD_INT 0
43623: PUSH
43624: EMPTY
43625: LIST
43626: LIST
43627: PUSH
43628: LD_INT 2
43630: PUSH
43631: LD_INT 1
43633: PUSH
43634: EMPTY
43635: LIST
43636: LIST
43637: PUSH
43638: LD_INT 2
43640: PUSH
43641: LD_INT 2
43643: PUSH
43644: EMPTY
43645: LIST
43646: LIST
43647: PUSH
43648: LD_INT 1
43650: PUSH
43651: LD_INT 2
43653: PUSH
43654: EMPTY
43655: LIST
43656: LIST
43657: PUSH
43658: LD_INT 0
43660: PUSH
43661: LD_INT 2
43663: PUSH
43664: EMPTY
43665: LIST
43666: LIST
43667: PUSH
43668: LD_INT 1
43670: NEG
43671: PUSH
43672: LD_INT 1
43674: PUSH
43675: EMPTY
43676: LIST
43677: LIST
43678: PUSH
43679: LD_INT 2
43681: NEG
43682: PUSH
43683: LD_INT 0
43685: PUSH
43686: EMPTY
43687: LIST
43688: LIST
43689: PUSH
43690: LD_INT 2
43692: NEG
43693: PUSH
43694: LD_INT 1
43696: NEG
43697: PUSH
43698: EMPTY
43699: LIST
43700: LIST
43701: PUSH
43702: LD_INT 2
43704: NEG
43705: PUSH
43706: LD_INT 2
43708: NEG
43709: PUSH
43710: EMPTY
43711: LIST
43712: LIST
43713: PUSH
43714: EMPTY
43715: LIST
43716: LIST
43717: LIST
43718: LIST
43719: LIST
43720: LIST
43721: LIST
43722: LIST
43723: LIST
43724: LIST
43725: LIST
43726: LIST
43727: LIST
43728: LIST
43729: LIST
43730: LIST
43731: LIST
43732: LIST
43733: LIST
43734: ST_TO_ADDR
// fBarracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
43735: LD_ADDR_VAR 0 56
43739: PUSH
43740: LD_INT 0
43742: PUSH
43743: LD_INT 0
43745: PUSH
43746: EMPTY
43747: LIST
43748: LIST
43749: PUSH
43750: LD_INT 0
43752: PUSH
43753: LD_INT 1
43755: NEG
43756: PUSH
43757: EMPTY
43758: LIST
43759: LIST
43760: PUSH
43761: LD_INT 1
43763: PUSH
43764: LD_INT 0
43766: PUSH
43767: EMPTY
43768: LIST
43769: LIST
43770: PUSH
43771: LD_INT 1
43773: PUSH
43774: LD_INT 1
43776: PUSH
43777: EMPTY
43778: LIST
43779: LIST
43780: PUSH
43781: LD_INT 0
43783: PUSH
43784: LD_INT 1
43786: PUSH
43787: EMPTY
43788: LIST
43789: LIST
43790: PUSH
43791: LD_INT 1
43793: NEG
43794: PUSH
43795: LD_INT 0
43797: PUSH
43798: EMPTY
43799: LIST
43800: LIST
43801: PUSH
43802: LD_INT 1
43804: NEG
43805: PUSH
43806: LD_INT 1
43808: NEG
43809: PUSH
43810: EMPTY
43811: LIST
43812: LIST
43813: PUSH
43814: LD_INT 1
43816: NEG
43817: PUSH
43818: LD_INT 2
43820: NEG
43821: PUSH
43822: EMPTY
43823: LIST
43824: LIST
43825: PUSH
43826: LD_INT 0
43828: PUSH
43829: LD_INT 2
43831: NEG
43832: PUSH
43833: EMPTY
43834: LIST
43835: LIST
43836: PUSH
43837: LD_INT 1
43839: PUSH
43840: LD_INT 1
43842: NEG
43843: PUSH
43844: EMPTY
43845: LIST
43846: LIST
43847: PUSH
43848: LD_INT 2
43850: PUSH
43851: LD_INT 0
43853: PUSH
43854: EMPTY
43855: LIST
43856: LIST
43857: PUSH
43858: LD_INT 2
43860: PUSH
43861: LD_INT 1
43863: PUSH
43864: EMPTY
43865: LIST
43866: LIST
43867: PUSH
43868: LD_INT 2
43870: PUSH
43871: LD_INT 2
43873: PUSH
43874: EMPTY
43875: LIST
43876: LIST
43877: PUSH
43878: LD_INT 1
43880: PUSH
43881: LD_INT 2
43883: PUSH
43884: EMPTY
43885: LIST
43886: LIST
43887: PUSH
43888: LD_INT 0
43890: PUSH
43891: LD_INT 2
43893: PUSH
43894: EMPTY
43895: LIST
43896: LIST
43897: PUSH
43898: LD_INT 1
43900: NEG
43901: PUSH
43902: LD_INT 1
43904: PUSH
43905: EMPTY
43906: LIST
43907: LIST
43908: PUSH
43909: LD_INT 2
43911: NEG
43912: PUSH
43913: LD_INT 0
43915: PUSH
43916: EMPTY
43917: LIST
43918: LIST
43919: PUSH
43920: LD_INT 2
43922: NEG
43923: PUSH
43924: LD_INT 1
43926: NEG
43927: PUSH
43928: EMPTY
43929: LIST
43930: LIST
43931: PUSH
43932: LD_INT 2
43934: NEG
43935: PUSH
43936: LD_INT 2
43938: NEG
43939: PUSH
43940: EMPTY
43941: LIST
43942: LIST
43943: PUSH
43944: EMPTY
43945: LIST
43946: LIST
43947: LIST
43948: LIST
43949: LIST
43950: LIST
43951: LIST
43952: LIST
43953: LIST
43954: LIST
43955: LIST
43956: LIST
43957: LIST
43958: LIST
43959: LIST
43960: LIST
43961: LIST
43962: LIST
43963: LIST
43964: ST_TO_ADDR
// fBarracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
43965: LD_ADDR_VAR 0 57
43969: PUSH
43970: LD_INT 0
43972: PUSH
43973: LD_INT 0
43975: PUSH
43976: EMPTY
43977: LIST
43978: LIST
43979: PUSH
43980: LD_INT 0
43982: PUSH
43983: LD_INT 1
43985: NEG
43986: PUSH
43987: EMPTY
43988: LIST
43989: LIST
43990: PUSH
43991: LD_INT 1
43993: PUSH
43994: LD_INT 0
43996: PUSH
43997: EMPTY
43998: LIST
43999: LIST
44000: PUSH
44001: LD_INT 1
44003: PUSH
44004: LD_INT 1
44006: PUSH
44007: EMPTY
44008: LIST
44009: LIST
44010: PUSH
44011: LD_INT 0
44013: PUSH
44014: LD_INT 1
44016: PUSH
44017: EMPTY
44018: LIST
44019: LIST
44020: PUSH
44021: LD_INT 1
44023: NEG
44024: PUSH
44025: LD_INT 0
44027: PUSH
44028: EMPTY
44029: LIST
44030: LIST
44031: PUSH
44032: LD_INT 1
44034: NEG
44035: PUSH
44036: LD_INT 1
44038: NEG
44039: PUSH
44040: EMPTY
44041: LIST
44042: LIST
44043: PUSH
44044: LD_INT 1
44046: NEG
44047: PUSH
44048: LD_INT 2
44050: NEG
44051: PUSH
44052: EMPTY
44053: LIST
44054: LIST
44055: PUSH
44056: LD_INT 0
44058: PUSH
44059: LD_INT 2
44061: NEG
44062: PUSH
44063: EMPTY
44064: LIST
44065: LIST
44066: PUSH
44067: LD_INT 1
44069: PUSH
44070: LD_INT 1
44072: NEG
44073: PUSH
44074: EMPTY
44075: LIST
44076: LIST
44077: PUSH
44078: LD_INT 2
44080: PUSH
44081: LD_INT 0
44083: PUSH
44084: EMPTY
44085: LIST
44086: LIST
44087: PUSH
44088: LD_INT 2
44090: PUSH
44091: LD_INT 1
44093: PUSH
44094: EMPTY
44095: LIST
44096: LIST
44097: PUSH
44098: LD_INT 2
44100: PUSH
44101: LD_INT 2
44103: PUSH
44104: EMPTY
44105: LIST
44106: LIST
44107: PUSH
44108: LD_INT 1
44110: PUSH
44111: LD_INT 2
44113: PUSH
44114: EMPTY
44115: LIST
44116: LIST
44117: PUSH
44118: LD_INT 0
44120: PUSH
44121: LD_INT 2
44123: PUSH
44124: EMPTY
44125: LIST
44126: LIST
44127: PUSH
44128: LD_INT 1
44130: NEG
44131: PUSH
44132: LD_INT 1
44134: PUSH
44135: EMPTY
44136: LIST
44137: LIST
44138: PUSH
44139: LD_INT 2
44141: NEG
44142: PUSH
44143: LD_INT 0
44145: PUSH
44146: EMPTY
44147: LIST
44148: LIST
44149: PUSH
44150: LD_INT 2
44152: NEG
44153: PUSH
44154: LD_INT 1
44156: NEG
44157: PUSH
44158: EMPTY
44159: LIST
44160: LIST
44161: PUSH
44162: LD_INT 2
44164: NEG
44165: PUSH
44166: LD_INT 2
44168: NEG
44169: PUSH
44170: EMPTY
44171: LIST
44172: LIST
44173: PUSH
44174: EMPTY
44175: LIST
44176: LIST
44177: LIST
44178: LIST
44179: LIST
44180: LIST
44181: LIST
44182: LIST
44183: LIST
44184: LIST
44185: LIST
44186: LIST
44187: LIST
44188: LIST
44189: LIST
44190: LIST
44191: LIST
44192: LIST
44193: LIST
44194: ST_TO_ADDR
// fBarracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
44195: LD_ADDR_VAR 0 58
44199: PUSH
44200: LD_INT 0
44202: PUSH
44203: LD_INT 0
44205: PUSH
44206: EMPTY
44207: LIST
44208: LIST
44209: PUSH
44210: LD_INT 0
44212: PUSH
44213: LD_INT 1
44215: NEG
44216: PUSH
44217: EMPTY
44218: LIST
44219: LIST
44220: PUSH
44221: LD_INT 1
44223: PUSH
44224: LD_INT 0
44226: PUSH
44227: EMPTY
44228: LIST
44229: LIST
44230: PUSH
44231: LD_INT 1
44233: PUSH
44234: LD_INT 1
44236: PUSH
44237: EMPTY
44238: LIST
44239: LIST
44240: PUSH
44241: LD_INT 0
44243: PUSH
44244: LD_INT 1
44246: PUSH
44247: EMPTY
44248: LIST
44249: LIST
44250: PUSH
44251: LD_INT 1
44253: NEG
44254: PUSH
44255: LD_INT 0
44257: PUSH
44258: EMPTY
44259: LIST
44260: LIST
44261: PUSH
44262: LD_INT 1
44264: NEG
44265: PUSH
44266: LD_INT 1
44268: NEG
44269: PUSH
44270: EMPTY
44271: LIST
44272: LIST
44273: PUSH
44274: LD_INT 1
44276: NEG
44277: PUSH
44278: LD_INT 2
44280: NEG
44281: PUSH
44282: EMPTY
44283: LIST
44284: LIST
44285: PUSH
44286: LD_INT 0
44288: PUSH
44289: LD_INT 2
44291: NEG
44292: PUSH
44293: EMPTY
44294: LIST
44295: LIST
44296: PUSH
44297: LD_INT 1
44299: PUSH
44300: LD_INT 1
44302: NEG
44303: PUSH
44304: EMPTY
44305: LIST
44306: LIST
44307: PUSH
44308: LD_INT 2
44310: PUSH
44311: LD_INT 0
44313: PUSH
44314: EMPTY
44315: LIST
44316: LIST
44317: PUSH
44318: LD_INT 2
44320: PUSH
44321: LD_INT 1
44323: PUSH
44324: EMPTY
44325: LIST
44326: LIST
44327: PUSH
44328: LD_INT 2
44330: PUSH
44331: LD_INT 2
44333: PUSH
44334: EMPTY
44335: LIST
44336: LIST
44337: PUSH
44338: LD_INT 1
44340: PUSH
44341: LD_INT 2
44343: PUSH
44344: EMPTY
44345: LIST
44346: LIST
44347: PUSH
44348: LD_INT 0
44350: PUSH
44351: LD_INT 2
44353: PUSH
44354: EMPTY
44355: LIST
44356: LIST
44357: PUSH
44358: LD_INT 1
44360: NEG
44361: PUSH
44362: LD_INT 1
44364: PUSH
44365: EMPTY
44366: LIST
44367: LIST
44368: PUSH
44369: LD_INT 2
44371: NEG
44372: PUSH
44373: LD_INT 0
44375: PUSH
44376: EMPTY
44377: LIST
44378: LIST
44379: PUSH
44380: LD_INT 2
44382: NEG
44383: PUSH
44384: LD_INT 1
44386: NEG
44387: PUSH
44388: EMPTY
44389: LIST
44390: LIST
44391: PUSH
44392: LD_INT 2
44394: NEG
44395: PUSH
44396: LD_INT 2
44398: NEG
44399: PUSH
44400: EMPTY
44401: LIST
44402: LIST
44403: PUSH
44404: EMPTY
44405: LIST
44406: LIST
44407: LIST
44408: LIST
44409: LIST
44410: LIST
44411: LIST
44412: LIST
44413: LIST
44414: LIST
44415: LIST
44416: LIST
44417: LIST
44418: LIST
44419: LIST
44420: LIST
44421: LIST
44422: LIST
44423: LIST
44424: ST_TO_ADDR
// fBunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
44425: LD_ADDR_VAR 0 59
44429: PUSH
44430: LD_INT 0
44432: PUSH
44433: LD_INT 0
44435: PUSH
44436: EMPTY
44437: LIST
44438: LIST
44439: PUSH
44440: LD_INT 0
44442: PUSH
44443: LD_INT 1
44445: NEG
44446: PUSH
44447: EMPTY
44448: LIST
44449: LIST
44450: PUSH
44451: LD_INT 1
44453: PUSH
44454: LD_INT 0
44456: PUSH
44457: EMPTY
44458: LIST
44459: LIST
44460: PUSH
44461: LD_INT 1
44463: PUSH
44464: LD_INT 1
44466: PUSH
44467: EMPTY
44468: LIST
44469: LIST
44470: PUSH
44471: LD_INT 0
44473: PUSH
44474: LD_INT 1
44476: PUSH
44477: EMPTY
44478: LIST
44479: LIST
44480: PUSH
44481: LD_INT 1
44483: NEG
44484: PUSH
44485: LD_INT 0
44487: PUSH
44488: EMPTY
44489: LIST
44490: LIST
44491: PUSH
44492: LD_INT 1
44494: NEG
44495: PUSH
44496: LD_INT 1
44498: NEG
44499: PUSH
44500: EMPTY
44501: LIST
44502: LIST
44503: PUSH
44504: EMPTY
44505: LIST
44506: LIST
44507: LIST
44508: LIST
44509: LIST
44510: LIST
44511: LIST
44512: ST_TO_ADDR
// fBunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
44513: LD_ADDR_VAR 0 60
44517: PUSH
44518: LD_INT 0
44520: PUSH
44521: LD_INT 0
44523: PUSH
44524: EMPTY
44525: LIST
44526: LIST
44527: PUSH
44528: LD_INT 0
44530: PUSH
44531: LD_INT 1
44533: NEG
44534: PUSH
44535: EMPTY
44536: LIST
44537: LIST
44538: PUSH
44539: LD_INT 1
44541: PUSH
44542: LD_INT 0
44544: PUSH
44545: EMPTY
44546: LIST
44547: LIST
44548: PUSH
44549: LD_INT 1
44551: PUSH
44552: LD_INT 1
44554: PUSH
44555: EMPTY
44556: LIST
44557: LIST
44558: PUSH
44559: LD_INT 0
44561: PUSH
44562: LD_INT 1
44564: PUSH
44565: EMPTY
44566: LIST
44567: LIST
44568: PUSH
44569: LD_INT 1
44571: NEG
44572: PUSH
44573: LD_INT 0
44575: PUSH
44576: EMPTY
44577: LIST
44578: LIST
44579: PUSH
44580: LD_INT 1
44582: NEG
44583: PUSH
44584: LD_INT 1
44586: NEG
44587: PUSH
44588: EMPTY
44589: LIST
44590: LIST
44591: PUSH
44592: EMPTY
44593: LIST
44594: LIST
44595: LIST
44596: LIST
44597: LIST
44598: LIST
44599: LIST
44600: ST_TO_ADDR
// fBunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
44601: LD_ADDR_VAR 0 61
44605: PUSH
44606: LD_INT 0
44608: PUSH
44609: LD_INT 0
44611: PUSH
44612: EMPTY
44613: LIST
44614: LIST
44615: PUSH
44616: LD_INT 0
44618: PUSH
44619: LD_INT 1
44621: NEG
44622: PUSH
44623: EMPTY
44624: LIST
44625: LIST
44626: PUSH
44627: LD_INT 1
44629: PUSH
44630: LD_INT 0
44632: PUSH
44633: EMPTY
44634: LIST
44635: LIST
44636: PUSH
44637: LD_INT 1
44639: PUSH
44640: LD_INT 1
44642: PUSH
44643: EMPTY
44644: LIST
44645: LIST
44646: PUSH
44647: LD_INT 0
44649: PUSH
44650: LD_INT 1
44652: PUSH
44653: EMPTY
44654: LIST
44655: LIST
44656: PUSH
44657: LD_INT 1
44659: NEG
44660: PUSH
44661: LD_INT 0
44663: PUSH
44664: EMPTY
44665: LIST
44666: LIST
44667: PUSH
44668: LD_INT 1
44670: NEG
44671: PUSH
44672: LD_INT 1
44674: NEG
44675: PUSH
44676: EMPTY
44677: LIST
44678: LIST
44679: PUSH
44680: EMPTY
44681: LIST
44682: LIST
44683: LIST
44684: LIST
44685: LIST
44686: LIST
44687: LIST
44688: ST_TO_ADDR
// fBunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
44689: LD_ADDR_VAR 0 62
44693: PUSH
44694: LD_INT 0
44696: PUSH
44697: LD_INT 0
44699: PUSH
44700: EMPTY
44701: LIST
44702: LIST
44703: PUSH
44704: LD_INT 0
44706: PUSH
44707: LD_INT 1
44709: NEG
44710: PUSH
44711: EMPTY
44712: LIST
44713: LIST
44714: PUSH
44715: LD_INT 1
44717: PUSH
44718: LD_INT 0
44720: PUSH
44721: EMPTY
44722: LIST
44723: LIST
44724: PUSH
44725: LD_INT 1
44727: PUSH
44728: LD_INT 1
44730: PUSH
44731: EMPTY
44732: LIST
44733: LIST
44734: PUSH
44735: LD_INT 0
44737: PUSH
44738: LD_INT 1
44740: PUSH
44741: EMPTY
44742: LIST
44743: LIST
44744: PUSH
44745: LD_INT 1
44747: NEG
44748: PUSH
44749: LD_INT 0
44751: PUSH
44752: EMPTY
44753: LIST
44754: LIST
44755: PUSH
44756: LD_INT 1
44758: NEG
44759: PUSH
44760: LD_INT 1
44762: NEG
44763: PUSH
44764: EMPTY
44765: LIST
44766: LIST
44767: PUSH
44768: EMPTY
44769: LIST
44770: LIST
44771: LIST
44772: LIST
44773: LIST
44774: LIST
44775: LIST
44776: ST_TO_ADDR
// fBunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
44777: LD_ADDR_VAR 0 63
44781: PUSH
44782: LD_INT 0
44784: PUSH
44785: LD_INT 0
44787: PUSH
44788: EMPTY
44789: LIST
44790: LIST
44791: PUSH
44792: LD_INT 0
44794: PUSH
44795: LD_INT 1
44797: NEG
44798: PUSH
44799: EMPTY
44800: LIST
44801: LIST
44802: PUSH
44803: LD_INT 1
44805: PUSH
44806: LD_INT 0
44808: PUSH
44809: EMPTY
44810: LIST
44811: LIST
44812: PUSH
44813: LD_INT 1
44815: PUSH
44816: LD_INT 1
44818: PUSH
44819: EMPTY
44820: LIST
44821: LIST
44822: PUSH
44823: LD_INT 0
44825: PUSH
44826: LD_INT 1
44828: PUSH
44829: EMPTY
44830: LIST
44831: LIST
44832: PUSH
44833: LD_INT 1
44835: NEG
44836: PUSH
44837: LD_INT 0
44839: PUSH
44840: EMPTY
44841: LIST
44842: LIST
44843: PUSH
44844: LD_INT 1
44846: NEG
44847: PUSH
44848: LD_INT 1
44850: NEG
44851: PUSH
44852: EMPTY
44853: LIST
44854: LIST
44855: PUSH
44856: EMPTY
44857: LIST
44858: LIST
44859: LIST
44860: LIST
44861: LIST
44862: LIST
44863: LIST
44864: ST_TO_ADDR
// fBunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
44865: LD_ADDR_VAR 0 64
44869: PUSH
44870: LD_INT 0
44872: PUSH
44873: LD_INT 0
44875: PUSH
44876: EMPTY
44877: LIST
44878: LIST
44879: PUSH
44880: LD_INT 0
44882: PUSH
44883: LD_INT 1
44885: NEG
44886: PUSH
44887: EMPTY
44888: LIST
44889: LIST
44890: PUSH
44891: LD_INT 1
44893: PUSH
44894: LD_INT 0
44896: PUSH
44897: EMPTY
44898: LIST
44899: LIST
44900: PUSH
44901: LD_INT 1
44903: PUSH
44904: LD_INT 1
44906: PUSH
44907: EMPTY
44908: LIST
44909: LIST
44910: PUSH
44911: LD_INT 0
44913: PUSH
44914: LD_INT 1
44916: PUSH
44917: EMPTY
44918: LIST
44919: LIST
44920: PUSH
44921: LD_INT 1
44923: NEG
44924: PUSH
44925: LD_INT 0
44927: PUSH
44928: EMPTY
44929: LIST
44930: LIST
44931: PUSH
44932: LD_INT 1
44934: NEG
44935: PUSH
44936: LD_INT 1
44938: NEG
44939: PUSH
44940: EMPTY
44941: LIST
44942: LIST
44943: PUSH
44944: EMPTY
44945: LIST
44946: LIST
44947: LIST
44948: LIST
44949: LIST
44950: LIST
44951: LIST
44952: ST_TO_ADDR
// end ; 1 :
44953: GO 50850
44955: LD_INT 1
44957: DOUBLE
44958: EQUAL
44959: IFTRUE 44963
44961: GO 47586
44963: POP
// begin fDepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
44964: LD_ADDR_VAR 0 11
44968: PUSH
44969: LD_INT 1
44971: NEG
44972: PUSH
44973: LD_INT 3
44975: NEG
44976: PUSH
44977: EMPTY
44978: LIST
44979: LIST
44980: PUSH
44981: LD_INT 0
44983: PUSH
44984: LD_INT 3
44986: NEG
44987: PUSH
44988: EMPTY
44989: LIST
44990: LIST
44991: PUSH
44992: LD_INT 1
44994: PUSH
44995: LD_INT 2
44997: NEG
44998: PUSH
44999: EMPTY
45000: LIST
45001: LIST
45002: PUSH
45003: EMPTY
45004: LIST
45005: LIST
45006: LIST
45007: ST_TO_ADDR
// fDepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
45008: LD_ADDR_VAR 0 12
45012: PUSH
45013: LD_INT 2
45015: PUSH
45016: LD_INT 1
45018: NEG
45019: PUSH
45020: EMPTY
45021: LIST
45022: LIST
45023: PUSH
45024: LD_INT 3
45026: PUSH
45027: LD_INT 0
45029: PUSH
45030: EMPTY
45031: LIST
45032: LIST
45033: PUSH
45034: LD_INT 3
45036: PUSH
45037: LD_INT 1
45039: PUSH
45040: EMPTY
45041: LIST
45042: LIST
45043: PUSH
45044: EMPTY
45045: LIST
45046: LIST
45047: LIST
45048: ST_TO_ADDR
// fDepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
45049: LD_ADDR_VAR 0 13
45053: PUSH
45054: LD_INT 3
45056: PUSH
45057: LD_INT 2
45059: PUSH
45060: EMPTY
45061: LIST
45062: LIST
45063: PUSH
45064: LD_INT 3
45066: PUSH
45067: LD_INT 3
45069: PUSH
45070: EMPTY
45071: LIST
45072: LIST
45073: PUSH
45074: LD_INT 2
45076: PUSH
45077: LD_INT 3
45079: PUSH
45080: EMPTY
45081: LIST
45082: LIST
45083: PUSH
45084: EMPTY
45085: LIST
45086: LIST
45087: LIST
45088: ST_TO_ADDR
// fDepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
45089: LD_ADDR_VAR 0 14
45093: PUSH
45094: LD_INT 1
45096: PUSH
45097: LD_INT 3
45099: PUSH
45100: EMPTY
45101: LIST
45102: LIST
45103: PUSH
45104: LD_INT 0
45106: PUSH
45107: LD_INT 3
45109: PUSH
45110: EMPTY
45111: LIST
45112: LIST
45113: PUSH
45114: LD_INT 1
45116: NEG
45117: PUSH
45118: LD_INT 2
45120: PUSH
45121: EMPTY
45122: LIST
45123: LIST
45124: PUSH
45125: EMPTY
45126: LIST
45127: LIST
45128: LIST
45129: ST_TO_ADDR
// fDepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
45130: LD_ADDR_VAR 0 15
45134: PUSH
45135: LD_INT 2
45137: NEG
45138: PUSH
45139: LD_INT 1
45141: PUSH
45142: EMPTY
45143: LIST
45144: LIST
45145: PUSH
45146: LD_INT 3
45148: NEG
45149: PUSH
45150: LD_INT 0
45152: PUSH
45153: EMPTY
45154: LIST
45155: LIST
45156: PUSH
45157: LD_INT 3
45159: NEG
45160: PUSH
45161: LD_INT 1
45163: NEG
45164: PUSH
45165: EMPTY
45166: LIST
45167: LIST
45168: PUSH
45169: EMPTY
45170: LIST
45171: LIST
45172: LIST
45173: ST_TO_ADDR
// fDepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
45174: LD_ADDR_VAR 0 16
45178: PUSH
45179: LD_INT 2
45181: NEG
45182: PUSH
45183: LD_INT 3
45185: NEG
45186: PUSH
45187: EMPTY
45188: LIST
45189: LIST
45190: PUSH
45191: LD_INT 3
45193: NEG
45194: PUSH
45195: LD_INT 2
45197: NEG
45198: PUSH
45199: EMPTY
45200: LIST
45201: LIST
45202: PUSH
45203: LD_INT 3
45205: NEG
45206: PUSH
45207: LD_INT 3
45209: NEG
45210: PUSH
45211: EMPTY
45212: LIST
45213: LIST
45214: PUSH
45215: EMPTY
45216: LIST
45217: LIST
45218: LIST
45219: ST_TO_ADDR
// fDepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
45220: LD_ADDR_VAR 0 17
45224: PUSH
45225: LD_INT 1
45227: NEG
45228: PUSH
45229: LD_INT 3
45231: NEG
45232: PUSH
45233: EMPTY
45234: LIST
45235: LIST
45236: PUSH
45237: LD_INT 0
45239: PUSH
45240: LD_INT 3
45242: NEG
45243: PUSH
45244: EMPTY
45245: LIST
45246: LIST
45247: PUSH
45248: LD_INT 1
45250: PUSH
45251: LD_INT 2
45253: NEG
45254: PUSH
45255: EMPTY
45256: LIST
45257: LIST
45258: PUSH
45259: EMPTY
45260: LIST
45261: LIST
45262: LIST
45263: ST_TO_ADDR
// fDepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
45264: LD_ADDR_VAR 0 18
45268: PUSH
45269: LD_INT 2
45271: PUSH
45272: LD_INT 1
45274: NEG
45275: PUSH
45276: EMPTY
45277: LIST
45278: LIST
45279: PUSH
45280: LD_INT 3
45282: PUSH
45283: LD_INT 0
45285: PUSH
45286: EMPTY
45287: LIST
45288: LIST
45289: PUSH
45290: LD_INT 3
45292: PUSH
45293: LD_INT 1
45295: PUSH
45296: EMPTY
45297: LIST
45298: LIST
45299: PUSH
45300: EMPTY
45301: LIST
45302: LIST
45303: LIST
45304: ST_TO_ADDR
// fDepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
45305: LD_ADDR_VAR 0 19
45309: PUSH
45310: LD_INT 3
45312: PUSH
45313: LD_INT 2
45315: PUSH
45316: EMPTY
45317: LIST
45318: LIST
45319: PUSH
45320: LD_INT 3
45322: PUSH
45323: LD_INT 3
45325: PUSH
45326: EMPTY
45327: LIST
45328: LIST
45329: PUSH
45330: LD_INT 2
45332: PUSH
45333: LD_INT 3
45335: PUSH
45336: EMPTY
45337: LIST
45338: LIST
45339: PUSH
45340: EMPTY
45341: LIST
45342: LIST
45343: LIST
45344: ST_TO_ADDR
// fDepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
45345: LD_ADDR_VAR 0 20
45349: PUSH
45350: LD_INT 1
45352: PUSH
45353: LD_INT 3
45355: PUSH
45356: EMPTY
45357: LIST
45358: LIST
45359: PUSH
45360: LD_INT 0
45362: PUSH
45363: LD_INT 3
45365: PUSH
45366: EMPTY
45367: LIST
45368: LIST
45369: PUSH
45370: LD_INT 1
45372: NEG
45373: PUSH
45374: LD_INT 2
45376: PUSH
45377: EMPTY
45378: LIST
45379: LIST
45380: PUSH
45381: EMPTY
45382: LIST
45383: LIST
45384: LIST
45385: ST_TO_ADDR
// fDepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
45386: LD_ADDR_VAR 0 21
45390: PUSH
45391: LD_INT 2
45393: NEG
45394: PUSH
45395: LD_INT 1
45397: PUSH
45398: EMPTY
45399: LIST
45400: LIST
45401: PUSH
45402: LD_INT 3
45404: NEG
45405: PUSH
45406: LD_INT 0
45408: PUSH
45409: EMPTY
45410: LIST
45411: LIST
45412: PUSH
45413: LD_INT 3
45415: NEG
45416: PUSH
45417: LD_INT 1
45419: NEG
45420: PUSH
45421: EMPTY
45422: LIST
45423: LIST
45424: PUSH
45425: EMPTY
45426: LIST
45427: LIST
45428: LIST
45429: ST_TO_ADDR
// fDepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
45430: LD_ADDR_VAR 0 22
45434: PUSH
45435: LD_INT 2
45437: NEG
45438: PUSH
45439: LD_INT 3
45441: NEG
45442: PUSH
45443: EMPTY
45444: LIST
45445: LIST
45446: PUSH
45447: LD_INT 3
45449: NEG
45450: PUSH
45451: LD_INT 2
45453: NEG
45454: PUSH
45455: EMPTY
45456: LIST
45457: LIST
45458: PUSH
45459: LD_INT 3
45461: NEG
45462: PUSH
45463: LD_INT 3
45465: NEG
45466: PUSH
45467: EMPTY
45468: LIST
45469: LIST
45470: PUSH
45471: EMPTY
45472: LIST
45473: LIST
45474: LIST
45475: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
45476: LD_ADDR_VAR 0 23
45480: PUSH
45481: LD_INT 0
45483: PUSH
45484: LD_INT 3
45486: NEG
45487: PUSH
45488: EMPTY
45489: LIST
45490: LIST
45491: PUSH
45492: LD_INT 1
45494: NEG
45495: PUSH
45496: LD_INT 4
45498: NEG
45499: PUSH
45500: EMPTY
45501: LIST
45502: LIST
45503: PUSH
45504: LD_INT 1
45506: PUSH
45507: LD_INT 3
45509: NEG
45510: PUSH
45511: EMPTY
45512: LIST
45513: LIST
45514: PUSH
45515: EMPTY
45516: LIST
45517: LIST
45518: LIST
45519: ST_TO_ADDR
// fDepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
45520: LD_ADDR_VAR 0 24
45524: PUSH
45525: LD_INT 3
45527: PUSH
45528: LD_INT 0
45530: PUSH
45531: EMPTY
45532: LIST
45533: LIST
45534: PUSH
45535: LD_INT 3
45537: PUSH
45538: LD_INT 1
45540: NEG
45541: PUSH
45542: EMPTY
45543: LIST
45544: LIST
45545: PUSH
45546: LD_INT 4
45548: PUSH
45549: LD_INT 1
45551: PUSH
45552: EMPTY
45553: LIST
45554: LIST
45555: PUSH
45556: EMPTY
45557: LIST
45558: LIST
45559: LIST
45560: ST_TO_ADDR
// fDepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
45561: LD_ADDR_VAR 0 25
45565: PUSH
45566: LD_INT 3
45568: PUSH
45569: LD_INT 3
45571: PUSH
45572: EMPTY
45573: LIST
45574: LIST
45575: PUSH
45576: LD_INT 4
45578: PUSH
45579: LD_INT 3
45581: PUSH
45582: EMPTY
45583: LIST
45584: LIST
45585: PUSH
45586: LD_INT 3
45588: PUSH
45589: LD_INT 4
45591: PUSH
45592: EMPTY
45593: LIST
45594: LIST
45595: PUSH
45596: EMPTY
45597: LIST
45598: LIST
45599: LIST
45600: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
45601: LD_ADDR_VAR 0 26
45605: PUSH
45606: LD_INT 0
45608: PUSH
45609: LD_INT 3
45611: PUSH
45612: EMPTY
45613: LIST
45614: LIST
45615: PUSH
45616: LD_INT 1
45618: PUSH
45619: LD_INT 4
45621: PUSH
45622: EMPTY
45623: LIST
45624: LIST
45625: PUSH
45626: LD_INT 1
45628: NEG
45629: PUSH
45630: LD_INT 3
45632: PUSH
45633: EMPTY
45634: LIST
45635: LIST
45636: PUSH
45637: EMPTY
45638: LIST
45639: LIST
45640: LIST
45641: ST_TO_ADDR
// fDepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
45642: LD_ADDR_VAR 0 27
45646: PUSH
45647: LD_INT 3
45649: NEG
45650: PUSH
45651: LD_INT 0
45653: PUSH
45654: EMPTY
45655: LIST
45656: LIST
45657: PUSH
45658: LD_INT 3
45660: NEG
45661: PUSH
45662: LD_INT 1
45664: PUSH
45665: EMPTY
45666: LIST
45667: LIST
45668: PUSH
45669: LD_INT 4
45671: NEG
45672: PUSH
45673: LD_INT 1
45675: NEG
45676: PUSH
45677: EMPTY
45678: LIST
45679: LIST
45680: PUSH
45681: EMPTY
45682: LIST
45683: LIST
45684: LIST
45685: ST_TO_ADDR
// fDepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
45686: LD_ADDR_VAR 0 28
45690: PUSH
45691: LD_INT 3
45693: NEG
45694: PUSH
45695: LD_INT 3
45697: NEG
45698: PUSH
45699: EMPTY
45700: LIST
45701: LIST
45702: PUSH
45703: LD_INT 3
45705: NEG
45706: PUSH
45707: LD_INT 4
45709: NEG
45710: PUSH
45711: EMPTY
45712: LIST
45713: LIST
45714: PUSH
45715: LD_INT 4
45717: NEG
45718: PUSH
45719: LD_INT 3
45721: NEG
45722: PUSH
45723: EMPTY
45724: LIST
45725: LIST
45726: PUSH
45727: EMPTY
45728: LIST
45729: LIST
45730: LIST
45731: ST_TO_ADDR
// fFactory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
45732: LD_ADDR_VAR 0 29
45736: PUSH
45737: LD_INT 1
45739: NEG
45740: PUSH
45741: LD_INT 3
45743: NEG
45744: PUSH
45745: EMPTY
45746: LIST
45747: LIST
45748: PUSH
45749: LD_INT 0
45751: PUSH
45752: LD_INT 3
45754: NEG
45755: PUSH
45756: EMPTY
45757: LIST
45758: LIST
45759: PUSH
45760: LD_INT 1
45762: PUSH
45763: LD_INT 2
45765: NEG
45766: PUSH
45767: EMPTY
45768: LIST
45769: LIST
45770: PUSH
45771: LD_INT 1
45773: NEG
45774: PUSH
45775: LD_INT 4
45777: NEG
45778: PUSH
45779: EMPTY
45780: LIST
45781: LIST
45782: PUSH
45783: LD_INT 0
45785: PUSH
45786: LD_INT 4
45788: NEG
45789: PUSH
45790: EMPTY
45791: LIST
45792: LIST
45793: PUSH
45794: LD_INT 1
45796: PUSH
45797: LD_INT 3
45799: NEG
45800: PUSH
45801: EMPTY
45802: LIST
45803: LIST
45804: PUSH
45805: LD_INT 1
45807: NEG
45808: PUSH
45809: LD_INT 5
45811: NEG
45812: PUSH
45813: EMPTY
45814: LIST
45815: LIST
45816: PUSH
45817: LD_INT 0
45819: PUSH
45820: LD_INT 5
45822: NEG
45823: PUSH
45824: EMPTY
45825: LIST
45826: LIST
45827: PUSH
45828: LD_INT 1
45830: PUSH
45831: LD_INT 4
45833: NEG
45834: PUSH
45835: EMPTY
45836: LIST
45837: LIST
45838: PUSH
45839: LD_INT 1
45841: NEG
45842: PUSH
45843: LD_INT 6
45845: NEG
45846: PUSH
45847: EMPTY
45848: LIST
45849: LIST
45850: PUSH
45851: LD_INT 0
45853: PUSH
45854: LD_INT 6
45856: NEG
45857: PUSH
45858: EMPTY
45859: LIST
45860: LIST
45861: PUSH
45862: LD_INT 1
45864: PUSH
45865: LD_INT 5
45867: NEG
45868: PUSH
45869: EMPTY
45870: LIST
45871: LIST
45872: PUSH
45873: EMPTY
45874: LIST
45875: LIST
45876: LIST
45877: LIST
45878: LIST
45879: LIST
45880: LIST
45881: LIST
45882: LIST
45883: LIST
45884: LIST
45885: LIST
45886: ST_TO_ADDR
// fFactory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
45887: LD_ADDR_VAR 0 30
45891: PUSH
45892: LD_INT 2
45894: PUSH
45895: LD_INT 1
45897: NEG
45898: PUSH
45899: EMPTY
45900: LIST
45901: LIST
45902: PUSH
45903: LD_INT 3
45905: PUSH
45906: LD_INT 0
45908: PUSH
45909: EMPTY
45910: LIST
45911: LIST
45912: PUSH
45913: LD_INT 3
45915: PUSH
45916: LD_INT 1
45918: PUSH
45919: EMPTY
45920: LIST
45921: LIST
45922: PUSH
45923: LD_INT 3
45925: PUSH
45926: LD_INT 1
45928: NEG
45929: PUSH
45930: EMPTY
45931: LIST
45932: LIST
45933: PUSH
45934: LD_INT 4
45936: PUSH
45937: LD_INT 0
45939: PUSH
45940: EMPTY
45941: LIST
45942: LIST
45943: PUSH
45944: LD_INT 4
45946: PUSH
45947: LD_INT 1
45949: PUSH
45950: EMPTY
45951: LIST
45952: LIST
45953: PUSH
45954: LD_INT 4
45956: PUSH
45957: LD_INT 1
45959: NEG
45960: PUSH
45961: EMPTY
45962: LIST
45963: LIST
45964: PUSH
45965: LD_INT 5
45967: PUSH
45968: LD_INT 0
45970: PUSH
45971: EMPTY
45972: LIST
45973: LIST
45974: PUSH
45975: LD_INT 5
45977: PUSH
45978: LD_INT 1
45980: PUSH
45981: EMPTY
45982: LIST
45983: LIST
45984: PUSH
45985: LD_INT 5
45987: PUSH
45988: LD_INT 1
45990: NEG
45991: PUSH
45992: EMPTY
45993: LIST
45994: LIST
45995: PUSH
45996: LD_INT 6
45998: PUSH
45999: LD_INT 0
46001: PUSH
46002: EMPTY
46003: LIST
46004: LIST
46005: PUSH
46006: LD_INT 6
46008: PUSH
46009: LD_INT 1
46011: PUSH
46012: EMPTY
46013: LIST
46014: LIST
46015: PUSH
46016: EMPTY
46017: LIST
46018: LIST
46019: LIST
46020: LIST
46021: LIST
46022: LIST
46023: LIST
46024: LIST
46025: LIST
46026: LIST
46027: LIST
46028: LIST
46029: ST_TO_ADDR
// fFactory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
46030: LD_ADDR_VAR 0 31
46034: PUSH
46035: LD_INT 3
46037: PUSH
46038: LD_INT 2
46040: PUSH
46041: EMPTY
46042: LIST
46043: LIST
46044: PUSH
46045: LD_INT 3
46047: PUSH
46048: LD_INT 3
46050: PUSH
46051: EMPTY
46052: LIST
46053: LIST
46054: PUSH
46055: LD_INT 2
46057: PUSH
46058: LD_INT 3
46060: PUSH
46061: EMPTY
46062: LIST
46063: LIST
46064: PUSH
46065: LD_INT 4
46067: PUSH
46068: LD_INT 3
46070: PUSH
46071: EMPTY
46072: LIST
46073: LIST
46074: PUSH
46075: LD_INT 4
46077: PUSH
46078: LD_INT 4
46080: PUSH
46081: EMPTY
46082: LIST
46083: LIST
46084: PUSH
46085: LD_INT 3
46087: PUSH
46088: LD_INT 4
46090: PUSH
46091: EMPTY
46092: LIST
46093: LIST
46094: PUSH
46095: LD_INT 5
46097: PUSH
46098: LD_INT 4
46100: PUSH
46101: EMPTY
46102: LIST
46103: LIST
46104: PUSH
46105: LD_INT 5
46107: PUSH
46108: LD_INT 5
46110: PUSH
46111: EMPTY
46112: LIST
46113: LIST
46114: PUSH
46115: LD_INT 4
46117: PUSH
46118: LD_INT 5
46120: PUSH
46121: EMPTY
46122: LIST
46123: LIST
46124: PUSH
46125: LD_INT 6
46127: PUSH
46128: LD_INT 5
46130: PUSH
46131: EMPTY
46132: LIST
46133: LIST
46134: PUSH
46135: LD_INT 6
46137: PUSH
46138: LD_INT 6
46140: PUSH
46141: EMPTY
46142: LIST
46143: LIST
46144: PUSH
46145: LD_INT 5
46147: PUSH
46148: LD_INT 6
46150: PUSH
46151: EMPTY
46152: LIST
46153: LIST
46154: PUSH
46155: EMPTY
46156: LIST
46157: LIST
46158: LIST
46159: LIST
46160: LIST
46161: LIST
46162: LIST
46163: LIST
46164: LIST
46165: LIST
46166: LIST
46167: LIST
46168: ST_TO_ADDR
// fFactory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
46169: LD_ADDR_VAR 0 32
46173: PUSH
46174: LD_INT 1
46176: PUSH
46177: LD_INT 3
46179: PUSH
46180: EMPTY
46181: LIST
46182: LIST
46183: PUSH
46184: LD_INT 0
46186: PUSH
46187: LD_INT 3
46189: PUSH
46190: EMPTY
46191: LIST
46192: LIST
46193: PUSH
46194: LD_INT 1
46196: NEG
46197: PUSH
46198: LD_INT 2
46200: PUSH
46201: EMPTY
46202: LIST
46203: LIST
46204: PUSH
46205: LD_INT 1
46207: PUSH
46208: LD_INT 4
46210: PUSH
46211: EMPTY
46212: LIST
46213: LIST
46214: PUSH
46215: LD_INT 0
46217: PUSH
46218: LD_INT 4
46220: PUSH
46221: EMPTY
46222: LIST
46223: LIST
46224: PUSH
46225: LD_INT 1
46227: NEG
46228: PUSH
46229: LD_INT 3
46231: PUSH
46232: EMPTY
46233: LIST
46234: LIST
46235: PUSH
46236: LD_INT 1
46238: PUSH
46239: LD_INT 5
46241: PUSH
46242: EMPTY
46243: LIST
46244: LIST
46245: PUSH
46246: LD_INT 0
46248: PUSH
46249: LD_INT 5
46251: PUSH
46252: EMPTY
46253: LIST
46254: LIST
46255: PUSH
46256: LD_INT 1
46258: NEG
46259: PUSH
46260: LD_INT 4
46262: PUSH
46263: EMPTY
46264: LIST
46265: LIST
46266: PUSH
46267: LD_INT 1
46269: PUSH
46270: LD_INT 6
46272: PUSH
46273: EMPTY
46274: LIST
46275: LIST
46276: PUSH
46277: LD_INT 0
46279: PUSH
46280: LD_INT 6
46282: PUSH
46283: EMPTY
46284: LIST
46285: LIST
46286: PUSH
46287: LD_INT 1
46289: NEG
46290: PUSH
46291: LD_INT 5
46293: PUSH
46294: EMPTY
46295: LIST
46296: LIST
46297: PUSH
46298: EMPTY
46299: LIST
46300: LIST
46301: LIST
46302: LIST
46303: LIST
46304: LIST
46305: LIST
46306: LIST
46307: LIST
46308: LIST
46309: LIST
46310: LIST
46311: ST_TO_ADDR
// fFactory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
46312: LD_ADDR_VAR 0 33
46316: PUSH
46317: LD_INT 2
46319: NEG
46320: PUSH
46321: LD_INT 1
46323: PUSH
46324: EMPTY
46325: LIST
46326: LIST
46327: PUSH
46328: LD_INT 3
46330: NEG
46331: PUSH
46332: LD_INT 0
46334: PUSH
46335: EMPTY
46336: LIST
46337: LIST
46338: PUSH
46339: LD_INT 3
46341: NEG
46342: PUSH
46343: LD_INT 1
46345: NEG
46346: PUSH
46347: EMPTY
46348: LIST
46349: LIST
46350: PUSH
46351: LD_INT 3
46353: NEG
46354: PUSH
46355: LD_INT 1
46357: PUSH
46358: EMPTY
46359: LIST
46360: LIST
46361: PUSH
46362: LD_INT 4
46364: NEG
46365: PUSH
46366: LD_INT 0
46368: PUSH
46369: EMPTY
46370: LIST
46371: LIST
46372: PUSH
46373: LD_INT 4
46375: NEG
46376: PUSH
46377: LD_INT 1
46379: NEG
46380: PUSH
46381: EMPTY
46382: LIST
46383: LIST
46384: PUSH
46385: LD_INT 4
46387: NEG
46388: PUSH
46389: LD_INT 1
46391: PUSH
46392: EMPTY
46393: LIST
46394: LIST
46395: PUSH
46396: LD_INT 5
46398: NEG
46399: PUSH
46400: LD_INT 0
46402: PUSH
46403: EMPTY
46404: LIST
46405: LIST
46406: PUSH
46407: LD_INT 5
46409: NEG
46410: PUSH
46411: LD_INT 1
46413: NEG
46414: PUSH
46415: EMPTY
46416: LIST
46417: LIST
46418: PUSH
46419: LD_INT 5
46421: NEG
46422: PUSH
46423: LD_INT 1
46425: PUSH
46426: EMPTY
46427: LIST
46428: LIST
46429: PUSH
46430: LD_INT 6
46432: NEG
46433: PUSH
46434: LD_INT 0
46436: PUSH
46437: EMPTY
46438: LIST
46439: LIST
46440: PUSH
46441: LD_INT 6
46443: NEG
46444: PUSH
46445: LD_INT 1
46447: NEG
46448: PUSH
46449: EMPTY
46450: LIST
46451: LIST
46452: PUSH
46453: EMPTY
46454: LIST
46455: LIST
46456: LIST
46457: LIST
46458: LIST
46459: LIST
46460: LIST
46461: LIST
46462: LIST
46463: LIST
46464: LIST
46465: LIST
46466: ST_TO_ADDR
// fFactory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
46467: LD_ADDR_VAR 0 34
46471: PUSH
46472: LD_INT 2
46474: NEG
46475: PUSH
46476: LD_INT 3
46478: NEG
46479: PUSH
46480: EMPTY
46481: LIST
46482: LIST
46483: PUSH
46484: LD_INT 3
46486: NEG
46487: PUSH
46488: LD_INT 2
46490: NEG
46491: PUSH
46492: EMPTY
46493: LIST
46494: LIST
46495: PUSH
46496: LD_INT 3
46498: NEG
46499: PUSH
46500: LD_INT 3
46502: NEG
46503: PUSH
46504: EMPTY
46505: LIST
46506: LIST
46507: PUSH
46508: LD_INT 3
46510: NEG
46511: PUSH
46512: LD_INT 4
46514: NEG
46515: PUSH
46516: EMPTY
46517: LIST
46518: LIST
46519: PUSH
46520: LD_INT 4
46522: NEG
46523: PUSH
46524: LD_INT 3
46526: NEG
46527: PUSH
46528: EMPTY
46529: LIST
46530: LIST
46531: PUSH
46532: LD_INT 4
46534: NEG
46535: PUSH
46536: LD_INT 4
46538: NEG
46539: PUSH
46540: EMPTY
46541: LIST
46542: LIST
46543: PUSH
46544: LD_INT 4
46546: NEG
46547: PUSH
46548: LD_INT 5
46550: NEG
46551: PUSH
46552: EMPTY
46553: LIST
46554: LIST
46555: PUSH
46556: LD_INT 5
46558: NEG
46559: PUSH
46560: LD_INT 4
46562: NEG
46563: PUSH
46564: EMPTY
46565: LIST
46566: LIST
46567: PUSH
46568: LD_INT 5
46570: NEG
46571: PUSH
46572: LD_INT 5
46574: NEG
46575: PUSH
46576: EMPTY
46577: LIST
46578: LIST
46579: PUSH
46580: LD_INT 5
46582: NEG
46583: PUSH
46584: LD_INT 6
46586: NEG
46587: PUSH
46588: EMPTY
46589: LIST
46590: LIST
46591: PUSH
46592: LD_INT 6
46594: NEG
46595: PUSH
46596: LD_INT 5
46598: NEG
46599: PUSH
46600: EMPTY
46601: LIST
46602: LIST
46603: PUSH
46604: LD_INT 6
46606: NEG
46607: PUSH
46608: LD_INT 6
46610: NEG
46611: PUSH
46612: EMPTY
46613: LIST
46614: LIST
46615: PUSH
46616: EMPTY
46617: LIST
46618: LIST
46619: LIST
46620: LIST
46621: LIST
46622: LIST
46623: LIST
46624: LIST
46625: LIST
46626: LIST
46627: LIST
46628: LIST
46629: ST_TO_ADDR
// fLab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
46630: LD_ADDR_VAR 0 41
46634: PUSH
46635: LD_INT 0
46637: PUSH
46638: LD_INT 2
46640: NEG
46641: PUSH
46642: EMPTY
46643: LIST
46644: LIST
46645: PUSH
46646: LD_INT 1
46648: NEG
46649: PUSH
46650: LD_INT 3
46652: NEG
46653: PUSH
46654: EMPTY
46655: LIST
46656: LIST
46657: PUSH
46658: LD_INT 1
46660: PUSH
46661: LD_INT 2
46663: NEG
46664: PUSH
46665: EMPTY
46666: LIST
46667: LIST
46668: PUSH
46669: EMPTY
46670: LIST
46671: LIST
46672: LIST
46673: ST_TO_ADDR
// fLab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
46674: LD_ADDR_VAR 0 42
46678: PUSH
46679: LD_INT 2
46681: PUSH
46682: LD_INT 0
46684: PUSH
46685: EMPTY
46686: LIST
46687: LIST
46688: PUSH
46689: LD_INT 2
46691: PUSH
46692: LD_INT 1
46694: NEG
46695: PUSH
46696: EMPTY
46697: LIST
46698: LIST
46699: PUSH
46700: LD_INT 3
46702: PUSH
46703: LD_INT 1
46705: PUSH
46706: EMPTY
46707: LIST
46708: LIST
46709: PUSH
46710: EMPTY
46711: LIST
46712: LIST
46713: LIST
46714: ST_TO_ADDR
// fLab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
46715: LD_ADDR_VAR 0 43
46719: PUSH
46720: LD_INT 2
46722: PUSH
46723: LD_INT 2
46725: PUSH
46726: EMPTY
46727: LIST
46728: LIST
46729: PUSH
46730: LD_INT 3
46732: PUSH
46733: LD_INT 2
46735: PUSH
46736: EMPTY
46737: LIST
46738: LIST
46739: PUSH
46740: LD_INT 2
46742: PUSH
46743: LD_INT 3
46745: PUSH
46746: EMPTY
46747: LIST
46748: LIST
46749: PUSH
46750: EMPTY
46751: LIST
46752: LIST
46753: LIST
46754: ST_TO_ADDR
// fLab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
46755: LD_ADDR_VAR 0 44
46759: PUSH
46760: LD_INT 0
46762: PUSH
46763: LD_INT 2
46765: PUSH
46766: EMPTY
46767: LIST
46768: LIST
46769: PUSH
46770: LD_INT 1
46772: PUSH
46773: LD_INT 3
46775: PUSH
46776: EMPTY
46777: LIST
46778: LIST
46779: PUSH
46780: LD_INT 1
46782: NEG
46783: PUSH
46784: LD_INT 2
46786: PUSH
46787: EMPTY
46788: LIST
46789: LIST
46790: PUSH
46791: EMPTY
46792: LIST
46793: LIST
46794: LIST
46795: ST_TO_ADDR
// fLab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
46796: LD_ADDR_VAR 0 45
46800: PUSH
46801: LD_INT 2
46803: NEG
46804: PUSH
46805: LD_INT 0
46807: PUSH
46808: EMPTY
46809: LIST
46810: LIST
46811: PUSH
46812: LD_INT 2
46814: NEG
46815: PUSH
46816: LD_INT 1
46818: PUSH
46819: EMPTY
46820: LIST
46821: LIST
46822: PUSH
46823: LD_INT 3
46825: NEG
46826: PUSH
46827: LD_INT 1
46829: NEG
46830: PUSH
46831: EMPTY
46832: LIST
46833: LIST
46834: PUSH
46835: EMPTY
46836: LIST
46837: LIST
46838: LIST
46839: ST_TO_ADDR
// fLab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
46840: LD_ADDR_VAR 0 46
46844: PUSH
46845: LD_INT 2
46847: NEG
46848: PUSH
46849: LD_INT 2
46851: NEG
46852: PUSH
46853: EMPTY
46854: LIST
46855: LIST
46856: PUSH
46857: LD_INT 2
46859: NEG
46860: PUSH
46861: LD_INT 3
46863: NEG
46864: PUSH
46865: EMPTY
46866: LIST
46867: LIST
46868: PUSH
46869: LD_INT 3
46871: NEG
46872: PUSH
46873: LD_INT 2
46875: NEG
46876: PUSH
46877: EMPTY
46878: LIST
46879: LIST
46880: PUSH
46881: EMPTY
46882: LIST
46883: LIST
46884: LIST
46885: ST_TO_ADDR
// fControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
46886: LD_ADDR_VAR 0 47
46890: PUSH
46891: LD_INT 2
46893: NEG
46894: PUSH
46895: LD_INT 3
46897: NEG
46898: PUSH
46899: EMPTY
46900: LIST
46901: LIST
46902: PUSH
46903: LD_INT 1
46905: NEG
46906: PUSH
46907: LD_INT 3
46909: NEG
46910: PUSH
46911: EMPTY
46912: LIST
46913: LIST
46914: PUSH
46915: EMPTY
46916: LIST
46917: LIST
46918: ST_TO_ADDR
// fControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
46919: LD_ADDR_VAR 0 48
46923: PUSH
46924: LD_INT 1
46926: PUSH
46927: LD_INT 2
46929: NEG
46930: PUSH
46931: EMPTY
46932: LIST
46933: LIST
46934: PUSH
46935: LD_INT 2
46937: PUSH
46938: LD_INT 1
46940: NEG
46941: PUSH
46942: EMPTY
46943: LIST
46944: LIST
46945: PUSH
46946: EMPTY
46947: LIST
46948: LIST
46949: ST_TO_ADDR
// fControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
46950: LD_ADDR_VAR 0 49
46954: PUSH
46955: LD_INT 3
46957: PUSH
46958: LD_INT 1
46960: PUSH
46961: EMPTY
46962: LIST
46963: LIST
46964: PUSH
46965: LD_INT 3
46967: PUSH
46968: LD_INT 2
46970: PUSH
46971: EMPTY
46972: LIST
46973: LIST
46974: PUSH
46975: EMPTY
46976: LIST
46977: LIST
46978: ST_TO_ADDR
// fControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
46979: LD_ADDR_VAR 0 50
46983: PUSH
46984: LD_INT 2
46986: PUSH
46987: LD_INT 3
46989: PUSH
46990: EMPTY
46991: LIST
46992: LIST
46993: PUSH
46994: LD_INT 1
46996: PUSH
46997: LD_INT 3
46999: PUSH
47000: EMPTY
47001: LIST
47002: LIST
47003: PUSH
47004: EMPTY
47005: LIST
47006: LIST
47007: ST_TO_ADDR
// fControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
47008: LD_ADDR_VAR 0 51
47012: PUSH
47013: LD_INT 1
47015: NEG
47016: PUSH
47017: LD_INT 2
47019: PUSH
47020: EMPTY
47021: LIST
47022: LIST
47023: PUSH
47024: LD_INT 2
47026: NEG
47027: PUSH
47028: LD_INT 1
47030: PUSH
47031: EMPTY
47032: LIST
47033: LIST
47034: PUSH
47035: EMPTY
47036: LIST
47037: LIST
47038: ST_TO_ADDR
// fControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
47039: LD_ADDR_VAR 0 52
47043: PUSH
47044: LD_INT 3
47046: NEG
47047: PUSH
47048: LD_INT 1
47050: NEG
47051: PUSH
47052: EMPTY
47053: LIST
47054: LIST
47055: PUSH
47056: LD_INT 3
47058: NEG
47059: PUSH
47060: LD_INT 2
47062: NEG
47063: PUSH
47064: EMPTY
47065: LIST
47066: LIST
47067: PUSH
47068: EMPTY
47069: LIST
47070: LIST
47071: ST_TO_ADDR
// fBarracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
47072: LD_ADDR_VAR 0 53
47076: PUSH
47077: LD_INT 1
47079: NEG
47080: PUSH
47081: LD_INT 3
47083: NEG
47084: PUSH
47085: EMPTY
47086: LIST
47087: LIST
47088: PUSH
47089: LD_INT 0
47091: PUSH
47092: LD_INT 3
47094: NEG
47095: PUSH
47096: EMPTY
47097: LIST
47098: LIST
47099: PUSH
47100: LD_INT 1
47102: PUSH
47103: LD_INT 2
47105: NEG
47106: PUSH
47107: EMPTY
47108: LIST
47109: LIST
47110: PUSH
47111: EMPTY
47112: LIST
47113: LIST
47114: LIST
47115: ST_TO_ADDR
// fBarracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
47116: LD_ADDR_VAR 0 54
47120: PUSH
47121: LD_INT 2
47123: PUSH
47124: LD_INT 1
47126: NEG
47127: PUSH
47128: EMPTY
47129: LIST
47130: LIST
47131: PUSH
47132: LD_INT 3
47134: PUSH
47135: LD_INT 0
47137: PUSH
47138: EMPTY
47139: LIST
47140: LIST
47141: PUSH
47142: LD_INT 3
47144: PUSH
47145: LD_INT 1
47147: PUSH
47148: EMPTY
47149: LIST
47150: LIST
47151: PUSH
47152: EMPTY
47153: LIST
47154: LIST
47155: LIST
47156: ST_TO_ADDR
// fBarracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
47157: LD_ADDR_VAR 0 55
47161: PUSH
47162: LD_INT 3
47164: PUSH
47165: LD_INT 2
47167: PUSH
47168: EMPTY
47169: LIST
47170: LIST
47171: PUSH
47172: LD_INT 3
47174: PUSH
47175: LD_INT 3
47177: PUSH
47178: EMPTY
47179: LIST
47180: LIST
47181: PUSH
47182: LD_INT 2
47184: PUSH
47185: LD_INT 3
47187: PUSH
47188: EMPTY
47189: LIST
47190: LIST
47191: PUSH
47192: EMPTY
47193: LIST
47194: LIST
47195: LIST
47196: ST_TO_ADDR
// fBarracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
47197: LD_ADDR_VAR 0 56
47201: PUSH
47202: LD_INT 1
47204: PUSH
47205: LD_INT 3
47207: PUSH
47208: EMPTY
47209: LIST
47210: LIST
47211: PUSH
47212: LD_INT 0
47214: PUSH
47215: LD_INT 3
47217: PUSH
47218: EMPTY
47219: LIST
47220: LIST
47221: PUSH
47222: LD_INT 1
47224: NEG
47225: PUSH
47226: LD_INT 2
47228: PUSH
47229: EMPTY
47230: LIST
47231: LIST
47232: PUSH
47233: EMPTY
47234: LIST
47235: LIST
47236: LIST
47237: ST_TO_ADDR
// fBarracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
47238: LD_ADDR_VAR 0 57
47242: PUSH
47243: LD_INT 2
47245: NEG
47246: PUSH
47247: LD_INT 1
47249: PUSH
47250: EMPTY
47251: LIST
47252: LIST
47253: PUSH
47254: LD_INT 3
47256: NEG
47257: PUSH
47258: LD_INT 0
47260: PUSH
47261: EMPTY
47262: LIST
47263: LIST
47264: PUSH
47265: LD_INT 3
47267: NEG
47268: PUSH
47269: LD_INT 1
47271: NEG
47272: PUSH
47273: EMPTY
47274: LIST
47275: LIST
47276: PUSH
47277: EMPTY
47278: LIST
47279: LIST
47280: LIST
47281: ST_TO_ADDR
// fBarracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
47282: LD_ADDR_VAR 0 58
47286: PUSH
47287: LD_INT 2
47289: NEG
47290: PUSH
47291: LD_INT 3
47293: NEG
47294: PUSH
47295: EMPTY
47296: LIST
47297: LIST
47298: PUSH
47299: LD_INT 3
47301: NEG
47302: PUSH
47303: LD_INT 2
47305: NEG
47306: PUSH
47307: EMPTY
47308: LIST
47309: LIST
47310: PUSH
47311: LD_INT 3
47313: NEG
47314: PUSH
47315: LD_INT 3
47317: NEG
47318: PUSH
47319: EMPTY
47320: LIST
47321: LIST
47322: PUSH
47323: EMPTY
47324: LIST
47325: LIST
47326: LIST
47327: ST_TO_ADDR
// fBunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
47328: LD_ADDR_VAR 0 59
47332: PUSH
47333: LD_INT 1
47335: NEG
47336: PUSH
47337: LD_INT 2
47339: NEG
47340: PUSH
47341: EMPTY
47342: LIST
47343: LIST
47344: PUSH
47345: LD_INT 0
47347: PUSH
47348: LD_INT 2
47350: NEG
47351: PUSH
47352: EMPTY
47353: LIST
47354: LIST
47355: PUSH
47356: LD_INT 1
47358: PUSH
47359: LD_INT 1
47361: NEG
47362: PUSH
47363: EMPTY
47364: LIST
47365: LIST
47366: PUSH
47367: EMPTY
47368: LIST
47369: LIST
47370: LIST
47371: ST_TO_ADDR
// fBunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
47372: LD_ADDR_VAR 0 60
47376: PUSH
47377: LD_INT 1
47379: PUSH
47380: LD_INT 1
47382: NEG
47383: PUSH
47384: EMPTY
47385: LIST
47386: LIST
47387: PUSH
47388: LD_INT 2
47390: PUSH
47391: LD_INT 0
47393: PUSH
47394: EMPTY
47395: LIST
47396: LIST
47397: PUSH
47398: LD_INT 2
47400: PUSH
47401: LD_INT 1
47403: PUSH
47404: EMPTY
47405: LIST
47406: LIST
47407: PUSH
47408: EMPTY
47409: LIST
47410: LIST
47411: LIST
47412: ST_TO_ADDR
// fBunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
47413: LD_ADDR_VAR 0 61
47417: PUSH
47418: LD_INT 2
47420: PUSH
47421: LD_INT 1
47423: PUSH
47424: EMPTY
47425: LIST
47426: LIST
47427: PUSH
47428: LD_INT 2
47430: PUSH
47431: LD_INT 2
47433: PUSH
47434: EMPTY
47435: LIST
47436: LIST
47437: PUSH
47438: LD_INT 1
47440: PUSH
47441: LD_INT 2
47443: PUSH
47444: EMPTY
47445: LIST
47446: LIST
47447: PUSH
47448: EMPTY
47449: LIST
47450: LIST
47451: LIST
47452: ST_TO_ADDR
// fBunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
47453: LD_ADDR_VAR 0 62
47457: PUSH
47458: LD_INT 1
47460: PUSH
47461: LD_INT 2
47463: PUSH
47464: EMPTY
47465: LIST
47466: LIST
47467: PUSH
47468: LD_INT 0
47470: PUSH
47471: LD_INT 2
47473: PUSH
47474: EMPTY
47475: LIST
47476: LIST
47477: PUSH
47478: LD_INT 1
47480: NEG
47481: PUSH
47482: LD_INT 1
47484: PUSH
47485: EMPTY
47486: LIST
47487: LIST
47488: PUSH
47489: EMPTY
47490: LIST
47491: LIST
47492: LIST
47493: ST_TO_ADDR
// fBunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
47494: LD_ADDR_VAR 0 63
47498: PUSH
47499: LD_INT 1
47501: NEG
47502: PUSH
47503: LD_INT 1
47505: PUSH
47506: EMPTY
47507: LIST
47508: LIST
47509: PUSH
47510: LD_INT 2
47512: NEG
47513: PUSH
47514: LD_INT 0
47516: PUSH
47517: EMPTY
47518: LIST
47519: LIST
47520: PUSH
47521: LD_INT 2
47523: NEG
47524: PUSH
47525: LD_INT 1
47527: NEG
47528: PUSH
47529: EMPTY
47530: LIST
47531: LIST
47532: PUSH
47533: EMPTY
47534: LIST
47535: LIST
47536: LIST
47537: ST_TO_ADDR
// fBunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
47538: LD_ADDR_VAR 0 64
47542: PUSH
47543: LD_INT 1
47545: NEG
47546: PUSH
47547: LD_INT 2
47549: NEG
47550: PUSH
47551: EMPTY
47552: LIST
47553: LIST
47554: PUSH
47555: LD_INT 2
47557: NEG
47558: PUSH
47559: LD_INT 1
47561: NEG
47562: PUSH
47563: EMPTY
47564: LIST
47565: LIST
47566: PUSH
47567: LD_INT 2
47569: NEG
47570: PUSH
47571: LD_INT 2
47573: NEG
47574: PUSH
47575: EMPTY
47576: LIST
47577: LIST
47578: PUSH
47579: EMPTY
47580: LIST
47581: LIST
47582: LIST
47583: ST_TO_ADDR
// end ; 2 :
47584: GO 50850
47586: LD_INT 2
47588: DOUBLE
47589: EQUAL
47590: IFTRUE 47594
47592: GO 50849
47594: POP
// begin fFactory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
47595: LD_ADDR_VAR 0 29
47599: PUSH
47600: LD_INT 4
47602: PUSH
47603: LD_INT 0
47605: PUSH
47606: EMPTY
47607: LIST
47608: LIST
47609: PUSH
47610: LD_INT 4
47612: PUSH
47613: LD_INT 1
47615: NEG
47616: PUSH
47617: EMPTY
47618: LIST
47619: LIST
47620: PUSH
47621: LD_INT 5
47623: PUSH
47624: LD_INT 0
47626: PUSH
47627: EMPTY
47628: LIST
47629: LIST
47630: PUSH
47631: LD_INT 5
47633: PUSH
47634: LD_INT 1
47636: PUSH
47637: EMPTY
47638: LIST
47639: LIST
47640: PUSH
47641: LD_INT 4
47643: PUSH
47644: LD_INT 1
47646: PUSH
47647: EMPTY
47648: LIST
47649: LIST
47650: PUSH
47651: LD_INT 3
47653: PUSH
47654: LD_INT 0
47656: PUSH
47657: EMPTY
47658: LIST
47659: LIST
47660: PUSH
47661: LD_INT 3
47663: PUSH
47664: LD_INT 1
47666: NEG
47667: PUSH
47668: EMPTY
47669: LIST
47670: LIST
47671: PUSH
47672: LD_INT 3
47674: PUSH
47675: LD_INT 2
47677: NEG
47678: PUSH
47679: EMPTY
47680: LIST
47681: LIST
47682: PUSH
47683: LD_INT 5
47685: PUSH
47686: LD_INT 2
47688: PUSH
47689: EMPTY
47690: LIST
47691: LIST
47692: PUSH
47693: LD_INT 3
47695: PUSH
47696: LD_INT 3
47698: PUSH
47699: EMPTY
47700: LIST
47701: LIST
47702: PUSH
47703: LD_INT 3
47705: PUSH
47706: LD_INT 2
47708: PUSH
47709: EMPTY
47710: LIST
47711: LIST
47712: PUSH
47713: LD_INT 4
47715: PUSH
47716: LD_INT 3
47718: PUSH
47719: EMPTY
47720: LIST
47721: LIST
47722: PUSH
47723: LD_INT 4
47725: PUSH
47726: LD_INT 4
47728: PUSH
47729: EMPTY
47730: LIST
47731: LIST
47732: PUSH
47733: LD_INT 3
47735: PUSH
47736: LD_INT 4
47738: PUSH
47739: EMPTY
47740: LIST
47741: LIST
47742: PUSH
47743: LD_INT 2
47745: PUSH
47746: LD_INT 3
47748: PUSH
47749: EMPTY
47750: LIST
47751: LIST
47752: PUSH
47753: LD_INT 2
47755: PUSH
47756: LD_INT 2
47758: PUSH
47759: EMPTY
47760: LIST
47761: LIST
47762: PUSH
47763: LD_INT 4
47765: PUSH
47766: LD_INT 2
47768: PUSH
47769: EMPTY
47770: LIST
47771: LIST
47772: PUSH
47773: LD_INT 2
47775: PUSH
47776: LD_INT 4
47778: PUSH
47779: EMPTY
47780: LIST
47781: LIST
47782: PUSH
47783: LD_INT 0
47785: PUSH
47786: LD_INT 4
47788: PUSH
47789: EMPTY
47790: LIST
47791: LIST
47792: PUSH
47793: LD_INT 0
47795: PUSH
47796: LD_INT 3
47798: PUSH
47799: EMPTY
47800: LIST
47801: LIST
47802: PUSH
47803: LD_INT 1
47805: PUSH
47806: LD_INT 4
47808: PUSH
47809: EMPTY
47810: LIST
47811: LIST
47812: PUSH
47813: LD_INT 1
47815: PUSH
47816: LD_INT 5
47818: PUSH
47819: EMPTY
47820: LIST
47821: LIST
47822: PUSH
47823: LD_INT 0
47825: PUSH
47826: LD_INT 5
47828: PUSH
47829: EMPTY
47830: LIST
47831: LIST
47832: PUSH
47833: LD_INT 1
47835: NEG
47836: PUSH
47837: LD_INT 4
47839: PUSH
47840: EMPTY
47841: LIST
47842: LIST
47843: PUSH
47844: LD_INT 1
47846: NEG
47847: PUSH
47848: LD_INT 3
47850: PUSH
47851: EMPTY
47852: LIST
47853: LIST
47854: PUSH
47855: LD_INT 2
47857: PUSH
47858: LD_INT 5
47860: PUSH
47861: EMPTY
47862: LIST
47863: LIST
47864: PUSH
47865: LD_INT 2
47867: NEG
47868: PUSH
47869: LD_INT 3
47871: PUSH
47872: EMPTY
47873: LIST
47874: LIST
47875: PUSH
47876: LD_INT 3
47878: NEG
47879: PUSH
47880: LD_INT 0
47882: PUSH
47883: EMPTY
47884: LIST
47885: LIST
47886: PUSH
47887: LD_INT 3
47889: NEG
47890: PUSH
47891: LD_INT 1
47893: NEG
47894: PUSH
47895: EMPTY
47896: LIST
47897: LIST
47898: PUSH
47899: LD_INT 2
47901: NEG
47902: PUSH
47903: LD_INT 0
47905: PUSH
47906: EMPTY
47907: LIST
47908: LIST
47909: PUSH
47910: LD_INT 2
47912: NEG
47913: PUSH
47914: LD_INT 1
47916: PUSH
47917: EMPTY
47918: LIST
47919: LIST
47920: PUSH
47921: LD_INT 3
47923: NEG
47924: PUSH
47925: LD_INT 1
47927: PUSH
47928: EMPTY
47929: LIST
47930: LIST
47931: PUSH
47932: LD_INT 4
47934: NEG
47935: PUSH
47936: LD_INT 0
47938: PUSH
47939: EMPTY
47940: LIST
47941: LIST
47942: PUSH
47943: LD_INT 4
47945: NEG
47946: PUSH
47947: LD_INT 1
47949: NEG
47950: PUSH
47951: EMPTY
47952: LIST
47953: LIST
47954: PUSH
47955: LD_INT 4
47957: NEG
47958: PUSH
47959: LD_INT 2
47961: NEG
47962: PUSH
47963: EMPTY
47964: LIST
47965: LIST
47966: PUSH
47967: LD_INT 2
47969: NEG
47970: PUSH
47971: LD_INT 2
47973: PUSH
47974: EMPTY
47975: LIST
47976: LIST
47977: PUSH
47978: LD_INT 4
47980: NEG
47981: PUSH
47982: LD_INT 4
47984: NEG
47985: PUSH
47986: EMPTY
47987: LIST
47988: LIST
47989: PUSH
47990: LD_INT 4
47992: NEG
47993: PUSH
47994: LD_INT 5
47996: NEG
47997: PUSH
47998: EMPTY
47999: LIST
48000: LIST
48001: PUSH
48002: LD_INT 3
48004: NEG
48005: PUSH
48006: LD_INT 4
48008: NEG
48009: PUSH
48010: EMPTY
48011: LIST
48012: LIST
48013: PUSH
48014: LD_INT 3
48016: NEG
48017: PUSH
48018: LD_INT 3
48020: NEG
48021: PUSH
48022: EMPTY
48023: LIST
48024: LIST
48025: PUSH
48026: LD_INT 4
48028: NEG
48029: PUSH
48030: LD_INT 3
48032: NEG
48033: PUSH
48034: EMPTY
48035: LIST
48036: LIST
48037: PUSH
48038: LD_INT 5
48040: NEG
48041: PUSH
48042: LD_INT 4
48044: NEG
48045: PUSH
48046: EMPTY
48047: LIST
48048: LIST
48049: PUSH
48050: LD_INT 5
48052: NEG
48053: PUSH
48054: LD_INT 5
48056: NEG
48057: PUSH
48058: EMPTY
48059: LIST
48060: LIST
48061: PUSH
48062: LD_INT 3
48064: NEG
48065: PUSH
48066: LD_INT 5
48068: NEG
48069: PUSH
48070: EMPTY
48071: LIST
48072: LIST
48073: PUSH
48074: LD_INT 5
48076: NEG
48077: PUSH
48078: LD_INT 3
48080: NEG
48081: PUSH
48082: EMPTY
48083: LIST
48084: LIST
48085: PUSH
48086: EMPTY
48087: LIST
48088: LIST
48089: LIST
48090: LIST
48091: LIST
48092: LIST
48093: LIST
48094: LIST
48095: LIST
48096: LIST
48097: LIST
48098: LIST
48099: LIST
48100: LIST
48101: LIST
48102: LIST
48103: LIST
48104: LIST
48105: LIST
48106: LIST
48107: LIST
48108: LIST
48109: LIST
48110: LIST
48111: LIST
48112: LIST
48113: LIST
48114: LIST
48115: LIST
48116: LIST
48117: LIST
48118: LIST
48119: LIST
48120: LIST
48121: LIST
48122: LIST
48123: LIST
48124: LIST
48125: LIST
48126: LIST
48127: LIST
48128: LIST
48129: LIST
48130: LIST
48131: LIST
48132: ST_TO_ADDR
// fFactory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
48133: LD_ADDR_VAR 0 30
48137: PUSH
48138: LD_INT 4
48140: PUSH
48141: LD_INT 4
48143: PUSH
48144: EMPTY
48145: LIST
48146: LIST
48147: PUSH
48148: LD_INT 4
48150: PUSH
48151: LD_INT 3
48153: PUSH
48154: EMPTY
48155: LIST
48156: LIST
48157: PUSH
48158: LD_INT 5
48160: PUSH
48161: LD_INT 4
48163: PUSH
48164: EMPTY
48165: LIST
48166: LIST
48167: PUSH
48168: LD_INT 5
48170: PUSH
48171: LD_INT 5
48173: PUSH
48174: EMPTY
48175: LIST
48176: LIST
48177: PUSH
48178: LD_INT 4
48180: PUSH
48181: LD_INT 5
48183: PUSH
48184: EMPTY
48185: LIST
48186: LIST
48187: PUSH
48188: LD_INT 3
48190: PUSH
48191: LD_INT 4
48193: PUSH
48194: EMPTY
48195: LIST
48196: LIST
48197: PUSH
48198: LD_INT 3
48200: PUSH
48201: LD_INT 3
48203: PUSH
48204: EMPTY
48205: LIST
48206: LIST
48207: PUSH
48208: LD_INT 5
48210: PUSH
48211: LD_INT 3
48213: PUSH
48214: EMPTY
48215: LIST
48216: LIST
48217: PUSH
48218: LD_INT 3
48220: PUSH
48221: LD_INT 5
48223: PUSH
48224: EMPTY
48225: LIST
48226: LIST
48227: PUSH
48228: LD_INT 0
48230: PUSH
48231: LD_INT 3
48233: PUSH
48234: EMPTY
48235: LIST
48236: LIST
48237: PUSH
48238: LD_INT 0
48240: PUSH
48241: LD_INT 2
48243: PUSH
48244: EMPTY
48245: LIST
48246: LIST
48247: PUSH
48248: LD_INT 1
48250: PUSH
48251: LD_INT 3
48253: PUSH
48254: EMPTY
48255: LIST
48256: LIST
48257: PUSH
48258: LD_INT 1
48260: PUSH
48261: LD_INT 4
48263: PUSH
48264: EMPTY
48265: LIST
48266: LIST
48267: PUSH
48268: LD_INT 0
48270: PUSH
48271: LD_INT 4
48273: PUSH
48274: EMPTY
48275: LIST
48276: LIST
48277: PUSH
48278: LD_INT 1
48280: NEG
48281: PUSH
48282: LD_INT 3
48284: PUSH
48285: EMPTY
48286: LIST
48287: LIST
48288: PUSH
48289: LD_INT 1
48291: NEG
48292: PUSH
48293: LD_INT 2
48295: PUSH
48296: EMPTY
48297: LIST
48298: LIST
48299: PUSH
48300: LD_INT 2
48302: PUSH
48303: LD_INT 4
48305: PUSH
48306: EMPTY
48307: LIST
48308: LIST
48309: PUSH
48310: LD_INT 2
48312: NEG
48313: PUSH
48314: LD_INT 2
48316: PUSH
48317: EMPTY
48318: LIST
48319: LIST
48320: PUSH
48321: LD_INT 4
48323: NEG
48324: PUSH
48325: LD_INT 0
48327: PUSH
48328: EMPTY
48329: LIST
48330: LIST
48331: PUSH
48332: LD_INT 4
48334: NEG
48335: PUSH
48336: LD_INT 1
48338: NEG
48339: PUSH
48340: EMPTY
48341: LIST
48342: LIST
48343: PUSH
48344: LD_INT 3
48346: NEG
48347: PUSH
48348: LD_INT 0
48350: PUSH
48351: EMPTY
48352: LIST
48353: LIST
48354: PUSH
48355: LD_INT 3
48357: NEG
48358: PUSH
48359: LD_INT 1
48361: PUSH
48362: EMPTY
48363: LIST
48364: LIST
48365: PUSH
48366: LD_INT 4
48368: NEG
48369: PUSH
48370: LD_INT 1
48372: PUSH
48373: EMPTY
48374: LIST
48375: LIST
48376: PUSH
48377: LD_INT 5
48379: NEG
48380: PUSH
48381: LD_INT 0
48383: PUSH
48384: EMPTY
48385: LIST
48386: LIST
48387: PUSH
48388: LD_INT 5
48390: NEG
48391: PUSH
48392: LD_INT 1
48394: NEG
48395: PUSH
48396: EMPTY
48397: LIST
48398: LIST
48399: PUSH
48400: LD_INT 5
48402: NEG
48403: PUSH
48404: LD_INT 2
48406: NEG
48407: PUSH
48408: EMPTY
48409: LIST
48410: LIST
48411: PUSH
48412: LD_INT 3
48414: NEG
48415: PUSH
48416: LD_INT 2
48418: PUSH
48419: EMPTY
48420: LIST
48421: LIST
48422: PUSH
48423: LD_INT 3
48425: NEG
48426: PUSH
48427: LD_INT 3
48429: NEG
48430: PUSH
48431: EMPTY
48432: LIST
48433: LIST
48434: PUSH
48435: LD_INT 3
48437: NEG
48438: PUSH
48439: LD_INT 4
48441: NEG
48442: PUSH
48443: EMPTY
48444: LIST
48445: LIST
48446: PUSH
48447: LD_INT 2
48449: NEG
48450: PUSH
48451: LD_INT 3
48453: NEG
48454: PUSH
48455: EMPTY
48456: LIST
48457: LIST
48458: PUSH
48459: LD_INT 2
48461: NEG
48462: PUSH
48463: LD_INT 2
48465: NEG
48466: PUSH
48467: EMPTY
48468: LIST
48469: LIST
48470: PUSH
48471: LD_INT 3
48473: NEG
48474: PUSH
48475: LD_INT 2
48477: NEG
48478: PUSH
48479: EMPTY
48480: LIST
48481: LIST
48482: PUSH
48483: LD_INT 4
48485: NEG
48486: PUSH
48487: LD_INT 3
48489: NEG
48490: PUSH
48491: EMPTY
48492: LIST
48493: LIST
48494: PUSH
48495: LD_INT 4
48497: NEG
48498: PUSH
48499: LD_INT 4
48501: NEG
48502: PUSH
48503: EMPTY
48504: LIST
48505: LIST
48506: PUSH
48507: LD_INT 2
48509: NEG
48510: PUSH
48511: LD_INT 4
48513: NEG
48514: PUSH
48515: EMPTY
48516: LIST
48517: LIST
48518: PUSH
48519: LD_INT 4
48521: NEG
48522: PUSH
48523: LD_INT 2
48525: NEG
48526: PUSH
48527: EMPTY
48528: LIST
48529: LIST
48530: PUSH
48531: LD_INT 0
48533: PUSH
48534: LD_INT 4
48536: NEG
48537: PUSH
48538: EMPTY
48539: LIST
48540: LIST
48541: PUSH
48542: LD_INT 0
48544: PUSH
48545: LD_INT 5
48547: NEG
48548: PUSH
48549: EMPTY
48550: LIST
48551: LIST
48552: PUSH
48553: LD_INT 1
48555: PUSH
48556: LD_INT 4
48558: NEG
48559: PUSH
48560: EMPTY
48561: LIST
48562: LIST
48563: PUSH
48564: LD_INT 1
48566: PUSH
48567: LD_INT 3
48569: NEG
48570: PUSH
48571: EMPTY
48572: LIST
48573: LIST
48574: PUSH
48575: LD_INT 0
48577: PUSH
48578: LD_INT 3
48580: NEG
48581: PUSH
48582: EMPTY
48583: LIST
48584: LIST
48585: PUSH
48586: LD_INT 1
48588: NEG
48589: PUSH
48590: LD_INT 4
48592: NEG
48593: PUSH
48594: EMPTY
48595: LIST
48596: LIST
48597: PUSH
48598: LD_INT 1
48600: NEG
48601: PUSH
48602: LD_INT 5
48604: NEG
48605: PUSH
48606: EMPTY
48607: LIST
48608: LIST
48609: PUSH
48610: LD_INT 2
48612: PUSH
48613: LD_INT 3
48615: NEG
48616: PUSH
48617: EMPTY
48618: LIST
48619: LIST
48620: PUSH
48621: LD_INT 2
48623: NEG
48624: PUSH
48625: LD_INT 5
48627: NEG
48628: PUSH
48629: EMPTY
48630: LIST
48631: LIST
48632: PUSH
48633: EMPTY
48634: LIST
48635: LIST
48636: LIST
48637: LIST
48638: LIST
48639: LIST
48640: LIST
48641: LIST
48642: LIST
48643: LIST
48644: LIST
48645: LIST
48646: LIST
48647: LIST
48648: LIST
48649: LIST
48650: LIST
48651: LIST
48652: LIST
48653: LIST
48654: LIST
48655: LIST
48656: LIST
48657: LIST
48658: LIST
48659: LIST
48660: LIST
48661: LIST
48662: LIST
48663: LIST
48664: LIST
48665: LIST
48666: LIST
48667: LIST
48668: LIST
48669: LIST
48670: LIST
48671: LIST
48672: LIST
48673: LIST
48674: LIST
48675: LIST
48676: LIST
48677: LIST
48678: LIST
48679: ST_TO_ADDR
// fFactory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
48680: LD_ADDR_VAR 0 31
48684: PUSH
48685: LD_INT 0
48687: PUSH
48688: LD_INT 4
48690: PUSH
48691: EMPTY
48692: LIST
48693: LIST
48694: PUSH
48695: LD_INT 0
48697: PUSH
48698: LD_INT 3
48700: PUSH
48701: EMPTY
48702: LIST
48703: LIST
48704: PUSH
48705: LD_INT 1
48707: PUSH
48708: LD_INT 4
48710: PUSH
48711: EMPTY
48712: LIST
48713: LIST
48714: PUSH
48715: LD_INT 1
48717: PUSH
48718: LD_INT 5
48720: PUSH
48721: EMPTY
48722: LIST
48723: LIST
48724: PUSH
48725: LD_INT 0
48727: PUSH
48728: LD_INT 5
48730: PUSH
48731: EMPTY
48732: LIST
48733: LIST
48734: PUSH
48735: LD_INT 1
48737: NEG
48738: PUSH
48739: LD_INT 4
48741: PUSH
48742: EMPTY
48743: LIST
48744: LIST
48745: PUSH
48746: LD_INT 1
48748: NEG
48749: PUSH
48750: LD_INT 3
48752: PUSH
48753: EMPTY
48754: LIST
48755: LIST
48756: PUSH
48757: LD_INT 2
48759: PUSH
48760: LD_INT 5
48762: PUSH
48763: EMPTY
48764: LIST
48765: LIST
48766: PUSH
48767: LD_INT 2
48769: NEG
48770: PUSH
48771: LD_INT 3
48773: PUSH
48774: EMPTY
48775: LIST
48776: LIST
48777: PUSH
48778: LD_INT 3
48780: NEG
48781: PUSH
48782: LD_INT 0
48784: PUSH
48785: EMPTY
48786: LIST
48787: LIST
48788: PUSH
48789: LD_INT 3
48791: NEG
48792: PUSH
48793: LD_INT 1
48795: NEG
48796: PUSH
48797: EMPTY
48798: LIST
48799: LIST
48800: PUSH
48801: LD_INT 2
48803: NEG
48804: PUSH
48805: LD_INT 0
48807: PUSH
48808: EMPTY
48809: LIST
48810: LIST
48811: PUSH
48812: LD_INT 2
48814: NEG
48815: PUSH
48816: LD_INT 1
48818: PUSH
48819: EMPTY
48820: LIST
48821: LIST
48822: PUSH
48823: LD_INT 3
48825: NEG
48826: PUSH
48827: LD_INT 1
48829: PUSH
48830: EMPTY
48831: LIST
48832: LIST
48833: PUSH
48834: LD_INT 4
48836: NEG
48837: PUSH
48838: LD_INT 0
48840: PUSH
48841: EMPTY
48842: LIST
48843: LIST
48844: PUSH
48845: LD_INT 4
48847: NEG
48848: PUSH
48849: LD_INT 1
48851: NEG
48852: PUSH
48853: EMPTY
48854: LIST
48855: LIST
48856: PUSH
48857: LD_INT 4
48859: NEG
48860: PUSH
48861: LD_INT 2
48863: NEG
48864: PUSH
48865: EMPTY
48866: LIST
48867: LIST
48868: PUSH
48869: LD_INT 2
48871: NEG
48872: PUSH
48873: LD_INT 2
48875: PUSH
48876: EMPTY
48877: LIST
48878: LIST
48879: PUSH
48880: LD_INT 4
48882: NEG
48883: PUSH
48884: LD_INT 4
48886: NEG
48887: PUSH
48888: EMPTY
48889: LIST
48890: LIST
48891: PUSH
48892: LD_INT 4
48894: NEG
48895: PUSH
48896: LD_INT 5
48898: NEG
48899: PUSH
48900: EMPTY
48901: LIST
48902: LIST
48903: PUSH
48904: LD_INT 3
48906: NEG
48907: PUSH
48908: LD_INT 4
48910: NEG
48911: PUSH
48912: EMPTY
48913: LIST
48914: LIST
48915: PUSH
48916: LD_INT 3
48918: NEG
48919: PUSH
48920: LD_INT 3
48922: NEG
48923: PUSH
48924: EMPTY
48925: LIST
48926: LIST
48927: PUSH
48928: LD_INT 4
48930: NEG
48931: PUSH
48932: LD_INT 3
48934: NEG
48935: PUSH
48936: EMPTY
48937: LIST
48938: LIST
48939: PUSH
48940: LD_INT 5
48942: NEG
48943: PUSH
48944: LD_INT 4
48946: NEG
48947: PUSH
48948: EMPTY
48949: LIST
48950: LIST
48951: PUSH
48952: LD_INT 5
48954: NEG
48955: PUSH
48956: LD_INT 5
48958: NEG
48959: PUSH
48960: EMPTY
48961: LIST
48962: LIST
48963: PUSH
48964: LD_INT 3
48966: NEG
48967: PUSH
48968: LD_INT 5
48970: NEG
48971: PUSH
48972: EMPTY
48973: LIST
48974: LIST
48975: PUSH
48976: LD_INT 5
48978: NEG
48979: PUSH
48980: LD_INT 3
48982: NEG
48983: PUSH
48984: EMPTY
48985: LIST
48986: LIST
48987: PUSH
48988: LD_INT 0
48990: PUSH
48991: LD_INT 3
48993: NEG
48994: PUSH
48995: EMPTY
48996: LIST
48997: LIST
48998: PUSH
48999: LD_INT 0
49001: PUSH
49002: LD_INT 4
49004: NEG
49005: PUSH
49006: EMPTY
49007: LIST
49008: LIST
49009: PUSH
49010: LD_INT 1
49012: PUSH
49013: LD_INT 3
49015: NEG
49016: PUSH
49017: EMPTY
49018: LIST
49019: LIST
49020: PUSH
49021: LD_INT 1
49023: PUSH
49024: LD_INT 2
49026: NEG
49027: PUSH
49028: EMPTY
49029: LIST
49030: LIST
49031: PUSH
49032: LD_INT 0
49034: PUSH
49035: LD_INT 2
49037: NEG
49038: PUSH
49039: EMPTY
49040: LIST
49041: LIST
49042: PUSH
49043: LD_INT 1
49045: NEG
49046: PUSH
49047: LD_INT 3
49049: NEG
49050: PUSH
49051: EMPTY
49052: LIST
49053: LIST
49054: PUSH
49055: LD_INT 1
49057: NEG
49058: PUSH
49059: LD_INT 4
49061: NEG
49062: PUSH
49063: EMPTY
49064: LIST
49065: LIST
49066: PUSH
49067: LD_INT 2
49069: PUSH
49070: LD_INT 2
49072: NEG
49073: PUSH
49074: EMPTY
49075: LIST
49076: LIST
49077: PUSH
49078: LD_INT 2
49080: NEG
49081: PUSH
49082: LD_INT 4
49084: NEG
49085: PUSH
49086: EMPTY
49087: LIST
49088: LIST
49089: PUSH
49090: LD_INT 4
49092: PUSH
49093: LD_INT 0
49095: PUSH
49096: EMPTY
49097: LIST
49098: LIST
49099: PUSH
49100: LD_INT 4
49102: PUSH
49103: LD_INT 1
49105: NEG
49106: PUSH
49107: EMPTY
49108: LIST
49109: LIST
49110: PUSH
49111: LD_INT 5
49113: PUSH
49114: LD_INT 0
49116: PUSH
49117: EMPTY
49118: LIST
49119: LIST
49120: PUSH
49121: LD_INT 5
49123: PUSH
49124: LD_INT 1
49126: PUSH
49127: EMPTY
49128: LIST
49129: LIST
49130: PUSH
49131: LD_INT 4
49133: PUSH
49134: LD_INT 1
49136: PUSH
49137: EMPTY
49138: LIST
49139: LIST
49140: PUSH
49141: LD_INT 3
49143: PUSH
49144: LD_INT 0
49146: PUSH
49147: EMPTY
49148: LIST
49149: LIST
49150: PUSH
49151: LD_INT 3
49153: PUSH
49154: LD_INT 1
49156: NEG
49157: PUSH
49158: EMPTY
49159: LIST
49160: LIST
49161: PUSH
49162: LD_INT 3
49164: PUSH
49165: LD_INT 2
49167: NEG
49168: PUSH
49169: EMPTY
49170: LIST
49171: LIST
49172: PUSH
49173: LD_INT 5
49175: PUSH
49176: LD_INT 2
49178: PUSH
49179: EMPTY
49180: LIST
49181: LIST
49182: PUSH
49183: EMPTY
49184: LIST
49185: LIST
49186: LIST
49187: LIST
49188: LIST
49189: LIST
49190: LIST
49191: LIST
49192: LIST
49193: LIST
49194: LIST
49195: LIST
49196: LIST
49197: LIST
49198: LIST
49199: LIST
49200: LIST
49201: LIST
49202: LIST
49203: LIST
49204: LIST
49205: LIST
49206: LIST
49207: LIST
49208: LIST
49209: LIST
49210: LIST
49211: LIST
49212: LIST
49213: LIST
49214: LIST
49215: LIST
49216: LIST
49217: LIST
49218: LIST
49219: LIST
49220: LIST
49221: LIST
49222: LIST
49223: LIST
49224: LIST
49225: LIST
49226: LIST
49227: LIST
49228: LIST
49229: ST_TO_ADDR
// fFactory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
49230: LD_ADDR_VAR 0 32
49234: PUSH
49235: LD_INT 4
49237: NEG
49238: PUSH
49239: LD_INT 0
49241: PUSH
49242: EMPTY
49243: LIST
49244: LIST
49245: PUSH
49246: LD_INT 4
49248: NEG
49249: PUSH
49250: LD_INT 1
49252: NEG
49253: PUSH
49254: EMPTY
49255: LIST
49256: LIST
49257: PUSH
49258: LD_INT 3
49260: NEG
49261: PUSH
49262: LD_INT 0
49264: PUSH
49265: EMPTY
49266: LIST
49267: LIST
49268: PUSH
49269: LD_INT 3
49271: NEG
49272: PUSH
49273: LD_INT 1
49275: PUSH
49276: EMPTY
49277: LIST
49278: LIST
49279: PUSH
49280: LD_INT 4
49282: NEG
49283: PUSH
49284: LD_INT 1
49286: PUSH
49287: EMPTY
49288: LIST
49289: LIST
49290: PUSH
49291: LD_INT 5
49293: NEG
49294: PUSH
49295: LD_INT 0
49297: PUSH
49298: EMPTY
49299: LIST
49300: LIST
49301: PUSH
49302: LD_INT 5
49304: NEG
49305: PUSH
49306: LD_INT 1
49308: NEG
49309: PUSH
49310: EMPTY
49311: LIST
49312: LIST
49313: PUSH
49314: LD_INT 5
49316: NEG
49317: PUSH
49318: LD_INT 2
49320: NEG
49321: PUSH
49322: EMPTY
49323: LIST
49324: LIST
49325: PUSH
49326: LD_INT 3
49328: NEG
49329: PUSH
49330: LD_INT 2
49332: PUSH
49333: EMPTY
49334: LIST
49335: LIST
49336: PUSH
49337: LD_INT 3
49339: NEG
49340: PUSH
49341: LD_INT 3
49343: NEG
49344: PUSH
49345: EMPTY
49346: LIST
49347: LIST
49348: PUSH
49349: LD_INT 3
49351: NEG
49352: PUSH
49353: LD_INT 4
49355: NEG
49356: PUSH
49357: EMPTY
49358: LIST
49359: LIST
49360: PUSH
49361: LD_INT 2
49363: NEG
49364: PUSH
49365: LD_INT 3
49367: NEG
49368: PUSH
49369: EMPTY
49370: LIST
49371: LIST
49372: PUSH
49373: LD_INT 2
49375: NEG
49376: PUSH
49377: LD_INT 2
49379: NEG
49380: PUSH
49381: EMPTY
49382: LIST
49383: LIST
49384: PUSH
49385: LD_INT 3
49387: NEG
49388: PUSH
49389: LD_INT 2
49391: NEG
49392: PUSH
49393: EMPTY
49394: LIST
49395: LIST
49396: PUSH
49397: LD_INT 4
49399: NEG
49400: PUSH
49401: LD_INT 3
49403: NEG
49404: PUSH
49405: EMPTY
49406: LIST
49407: LIST
49408: PUSH
49409: LD_INT 4
49411: NEG
49412: PUSH
49413: LD_INT 4
49415: NEG
49416: PUSH
49417: EMPTY
49418: LIST
49419: LIST
49420: PUSH
49421: LD_INT 2
49423: NEG
49424: PUSH
49425: LD_INT 4
49427: NEG
49428: PUSH
49429: EMPTY
49430: LIST
49431: LIST
49432: PUSH
49433: LD_INT 4
49435: NEG
49436: PUSH
49437: LD_INT 2
49439: NEG
49440: PUSH
49441: EMPTY
49442: LIST
49443: LIST
49444: PUSH
49445: LD_INT 0
49447: PUSH
49448: LD_INT 4
49450: NEG
49451: PUSH
49452: EMPTY
49453: LIST
49454: LIST
49455: PUSH
49456: LD_INT 0
49458: PUSH
49459: LD_INT 5
49461: NEG
49462: PUSH
49463: EMPTY
49464: LIST
49465: LIST
49466: PUSH
49467: LD_INT 1
49469: PUSH
49470: LD_INT 4
49472: NEG
49473: PUSH
49474: EMPTY
49475: LIST
49476: LIST
49477: PUSH
49478: LD_INT 1
49480: PUSH
49481: LD_INT 3
49483: NEG
49484: PUSH
49485: EMPTY
49486: LIST
49487: LIST
49488: PUSH
49489: LD_INT 0
49491: PUSH
49492: LD_INT 3
49494: NEG
49495: PUSH
49496: EMPTY
49497: LIST
49498: LIST
49499: PUSH
49500: LD_INT 1
49502: NEG
49503: PUSH
49504: LD_INT 4
49506: NEG
49507: PUSH
49508: EMPTY
49509: LIST
49510: LIST
49511: PUSH
49512: LD_INT 1
49514: NEG
49515: PUSH
49516: LD_INT 5
49518: NEG
49519: PUSH
49520: EMPTY
49521: LIST
49522: LIST
49523: PUSH
49524: LD_INT 2
49526: PUSH
49527: LD_INT 3
49529: NEG
49530: PUSH
49531: EMPTY
49532: LIST
49533: LIST
49534: PUSH
49535: LD_INT 2
49537: NEG
49538: PUSH
49539: LD_INT 5
49541: NEG
49542: PUSH
49543: EMPTY
49544: LIST
49545: LIST
49546: PUSH
49547: LD_INT 3
49549: PUSH
49550: LD_INT 0
49552: PUSH
49553: EMPTY
49554: LIST
49555: LIST
49556: PUSH
49557: LD_INT 3
49559: PUSH
49560: LD_INT 1
49562: NEG
49563: PUSH
49564: EMPTY
49565: LIST
49566: LIST
49567: PUSH
49568: LD_INT 4
49570: PUSH
49571: LD_INT 0
49573: PUSH
49574: EMPTY
49575: LIST
49576: LIST
49577: PUSH
49578: LD_INT 4
49580: PUSH
49581: LD_INT 1
49583: PUSH
49584: EMPTY
49585: LIST
49586: LIST
49587: PUSH
49588: LD_INT 3
49590: PUSH
49591: LD_INT 1
49593: PUSH
49594: EMPTY
49595: LIST
49596: LIST
49597: PUSH
49598: LD_INT 2
49600: PUSH
49601: LD_INT 0
49603: PUSH
49604: EMPTY
49605: LIST
49606: LIST
49607: PUSH
49608: LD_INT 2
49610: PUSH
49611: LD_INT 1
49613: NEG
49614: PUSH
49615: EMPTY
49616: LIST
49617: LIST
49618: PUSH
49619: LD_INT 2
49621: PUSH
49622: LD_INT 2
49624: NEG
49625: PUSH
49626: EMPTY
49627: LIST
49628: LIST
49629: PUSH
49630: LD_INT 4
49632: PUSH
49633: LD_INT 2
49635: PUSH
49636: EMPTY
49637: LIST
49638: LIST
49639: PUSH
49640: LD_INT 4
49642: PUSH
49643: LD_INT 4
49645: PUSH
49646: EMPTY
49647: LIST
49648: LIST
49649: PUSH
49650: LD_INT 4
49652: PUSH
49653: LD_INT 3
49655: PUSH
49656: EMPTY
49657: LIST
49658: LIST
49659: PUSH
49660: LD_INT 5
49662: PUSH
49663: LD_INT 4
49665: PUSH
49666: EMPTY
49667: LIST
49668: LIST
49669: PUSH
49670: LD_INT 5
49672: PUSH
49673: LD_INT 5
49675: PUSH
49676: EMPTY
49677: LIST
49678: LIST
49679: PUSH
49680: LD_INT 4
49682: PUSH
49683: LD_INT 5
49685: PUSH
49686: EMPTY
49687: LIST
49688: LIST
49689: PUSH
49690: LD_INT 3
49692: PUSH
49693: LD_INT 4
49695: PUSH
49696: EMPTY
49697: LIST
49698: LIST
49699: PUSH
49700: LD_INT 3
49702: PUSH
49703: LD_INT 3
49705: PUSH
49706: EMPTY
49707: LIST
49708: LIST
49709: PUSH
49710: LD_INT 5
49712: PUSH
49713: LD_INT 3
49715: PUSH
49716: EMPTY
49717: LIST
49718: LIST
49719: PUSH
49720: LD_INT 3
49722: PUSH
49723: LD_INT 5
49725: PUSH
49726: EMPTY
49727: LIST
49728: LIST
49729: PUSH
49730: EMPTY
49731: LIST
49732: LIST
49733: LIST
49734: LIST
49735: LIST
49736: LIST
49737: LIST
49738: LIST
49739: LIST
49740: LIST
49741: LIST
49742: LIST
49743: LIST
49744: LIST
49745: LIST
49746: LIST
49747: LIST
49748: LIST
49749: LIST
49750: LIST
49751: LIST
49752: LIST
49753: LIST
49754: LIST
49755: LIST
49756: LIST
49757: LIST
49758: LIST
49759: LIST
49760: LIST
49761: LIST
49762: LIST
49763: LIST
49764: LIST
49765: LIST
49766: LIST
49767: LIST
49768: LIST
49769: LIST
49770: LIST
49771: LIST
49772: LIST
49773: LIST
49774: LIST
49775: LIST
49776: ST_TO_ADDR
// fFactory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
49777: LD_ADDR_VAR 0 33
49781: PUSH
49782: LD_INT 4
49784: NEG
49785: PUSH
49786: LD_INT 4
49788: NEG
49789: PUSH
49790: EMPTY
49791: LIST
49792: LIST
49793: PUSH
49794: LD_INT 4
49796: NEG
49797: PUSH
49798: LD_INT 5
49800: NEG
49801: PUSH
49802: EMPTY
49803: LIST
49804: LIST
49805: PUSH
49806: LD_INT 3
49808: NEG
49809: PUSH
49810: LD_INT 4
49812: NEG
49813: PUSH
49814: EMPTY
49815: LIST
49816: LIST
49817: PUSH
49818: LD_INT 3
49820: NEG
49821: PUSH
49822: LD_INT 3
49824: NEG
49825: PUSH
49826: EMPTY
49827: LIST
49828: LIST
49829: PUSH
49830: LD_INT 4
49832: NEG
49833: PUSH
49834: LD_INT 3
49836: NEG
49837: PUSH
49838: EMPTY
49839: LIST
49840: LIST
49841: PUSH
49842: LD_INT 5
49844: NEG
49845: PUSH
49846: LD_INT 4
49848: NEG
49849: PUSH
49850: EMPTY
49851: LIST
49852: LIST
49853: PUSH
49854: LD_INT 5
49856: NEG
49857: PUSH
49858: LD_INT 5
49860: NEG
49861: PUSH
49862: EMPTY
49863: LIST
49864: LIST
49865: PUSH
49866: LD_INT 3
49868: NEG
49869: PUSH
49870: LD_INT 5
49872: NEG
49873: PUSH
49874: EMPTY
49875: LIST
49876: LIST
49877: PUSH
49878: LD_INT 5
49880: NEG
49881: PUSH
49882: LD_INT 3
49884: NEG
49885: PUSH
49886: EMPTY
49887: LIST
49888: LIST
49889: PUSH
49890: LD_INT 0
49892: PUSH
49893: LD_INT 3
49895: NEG
49896: PUSH
49897: EMPTY
49898: LIST
49899: LIST
49900: PUSH
49901: LD_INT 0
49903: PUSH
49904: LD_INT 4
49906: NEG
49907: PUSH
49908: EMPTY
49909: LIST
49910: LIST
49911: PUSH
49912: LD_INT 1
49914: PUSH
49915: LD_INT 3
49917: NEG
49918: PUSH
49919: EMPTY
49920: LIST
49921: LIST
49922: PUSH
49923: LD_INT 1
49925: PUSH
49926: LD_INT 2
49928: NEG
49929: PUSH
49930: EMPTY
49931: LIST
49932: LIST
49933: PUSH
49934: LD_INT 0
49936: PUSH
49937: LD_INT 2
49939: NEG
49940: PUSH
49941: EMPTY
49942: LIST
49943: LIST
49944: PUSH
49945: LD_INT 1
49947: NEG
49948: PUSH
49949: LD_INT 3
49951: NEG
49952: PUSH
49953: EMPTY
49954: LIST
49955: LIST
49956: PUSH
49957: LD_INT 1
49959: NEG
49960: PUSH
49961: LD_INT 4
49963: NEG
49964: PUSH
49965: EMPTY
49966: LIST
49967: LIST
49968: PUSH
49969: LD_INT 2
49971: PUSH
49972: LD_INT 2
49974: NEG
49975: PUSH
49976: EMPTY
49977: LIST
49978: LIST
49979: PUSH
49980: LD_INT 2
49982: NEG
49983: PUSH
49984: LD_INT 4
49986: NEG
49987: PUSH
49988: EMPTY
49989: LIST
49990: LIST
49991: PUSH
49992: LD_INT 4
49994: PUSH
49995: LD_INT 0
49997: PUSH
49998: EMPTY
49999: LIST
50000: LIST
50001: PUSH
50002: LD_INT 4
50004: PUSH
50005: LD_INT 1
50007: NEG
50008: PUSH
50009: EMPTY
50010: LIST
50011: LIST
50012: PUSH
50013: LD_INT 5
50015: PUSH
50016: LD_INT 0
50018: PUSH
50019: EMPTY
50020: LIST
50021: LIST
50022: PUSH
50023: LD_INT 5
50025: PUSH
50026: LD_INT 1
50028: PUSH
50029: EMPTY
50030: LIST
50031: LIST
50032: PUSH
50033: LD_INT 4
50035: PUSH
50036: LD_INT 1
50038: PUSH
50039: EMPTY
50040: LIST
50041: LIST
50042: PUSH
50043: LD_INT 3
50045: PUSH
50046: LD_INT 0
50048: PUSH
50049: EMPTY
50050: LIST
50051: LIST
50052: PUSH
50053: LD_INT 3
50055: PUSH
50056: LD_INT 1
50058: NEG
50059: PUSH
50060: EMPTY
50061: LIST
50062: LIST
50063: PUSH
50064: LD_INT 3
50066: PUSH
50067: LD_INT 2
50069: NEG
50070: PUSH
50071: EMPTY
50072: LIST
50073: LIST
50074: PUSH
50075: LD_INT 5
50077: PUSH
50078: LD_INT 2
50080: PUSH
50081: EMPTY
50082: LIST
50083: LIST
50084: PUSH
50085: LD_INT 3
50087: PUSH
50088: LD_INT 3
50090: PUSH
50091: EMPTY
50092: LIST
50093: LIST
50094: PUSH
50095: LD_INT 3
50097: PUSH
50098: LD_INT 2
50100: PUSH
50101: EMPTY
50102: LIST
50103: LIST
50104: PUSH
50105: LD_INT 4
50107: PUSH
50108: LD_INT 3
50110: PUSH
50111: EMPTY
50112: LIST
50113: LIST
50114: PUSH
50115: LD_INT 4
50117: PUSH
50118: LD_INT 4
50120: PUSH
50121: EMPTY
50122: LIST
50123: LIST
50124: PUSH
50125: LD_INT 3
50127: PUSH
50128: LD_INT 4
50130: PUSH
50131: EMPTY
50132: LIST
50133: LIST
50134: PUSH
50135: LD_INT 2
50137: PUSH
50138: LD_INT 3
50140: PUSH
50141: EMPTY
50142: LIST
50143: LIST
50144: PUSH
50145: LD_INT 2
50147: PUSH
50148: LD_INT 2
50150: PUSH
50151: EMPTY
50152: LIST
50153: LIST
50154: PUSH
50155: LD_INT 4
50157: PUSH
50158: LD_INT 2
50160: PUSH
50161: EMPTY
50162: LIST
50163: LIST
50164: PUSH
50165: LD_INT 2
50167: PUSH
50168: LD_INT 4
50170: PUSH
50171: EMPTY
50172: LIST
50173: LIST
50174: PUSH
50175: LD_INT 0
50177: PUSH
50178: LD_INT 4
50180: PUSH
50181: EMPTY
50182: LIST
50183: LIST
50184: PUSH
50185: LD_INT 0
50187: PUSH
50188: LD_INT 3
50190: PUSH
50191: EMPTY
50192: LIST
50193: LIST
50194: PUSH
50195: LD_INT 1
50197: PUSH
50198: LD_INT 4
50200: PUSH
50201: EMPTY
50202: LIST
50203: LIST
50204: PUSH
50205: LD_INT 1
50207: PUSH
50208: LD_INT 5
50210: PUSH
50211: EMPTY
50212: LIST
50213: LIST
50214: PUSH
50215: LD_INT 0
50217: PUSH
50218: LD_INT 5
50220: PUSH
50221: EMPTY
50222: LIST
50223: LIST
50224: PUSH
50225: LD_INT 1
50227: NEG
50228: PUSH
50229: LD_INT 4
50231: PUSH
50232: EMPTY
50233: LIST
50234: LIST
50235: PUSH
50236: LD_INT 1
50238: NEG
50239: PUSH
50240: LD_INT 3
50242: PUSH
50243: EMPTY
50244: LIST
50245: LIST
50246: PUSH
50247: LD_INT 2
50249: PUSH
50250: LD_INT 5
50252: PUSH
50253: EMPTY
50254: LIST
50255: LIST
50256: PUSH
50257: LD_INT 2
50259: NEG
50260: PUSH
50261: LD_INT 3
50263: PUSH
50264: EMPTY
50265: LIST
50266: LIST
50267: PUSH
50268: EMPTY
50269: LIST
50270: LIST
50271: LIST
50272: LIST
50273: LIST
50274: LIST
50275: LIST
50276: LIST
50277: LIST
50278: LIST
50279: LIST
50280: LIST
50281: LIST
50282: LIST
50283: LIST
50284: LIST
50285: LIST
50286: LIST
50287: LIST
50288: LIST
50289: LIST
50290: LIST
50291: LIST
50292: LIST
50293: LIST
50294: LIST
50295: LIST
50296: LIST
50297: LIST
50298: LIST
50299: LIST
50300: LIST
50301: LIST
50302: LIST
50303: LIST
50304: LIST
50305: LIST
50306: LIST
50307: LIST
50308: LIST
50309: LIST
50310: LIST
50311: LIST
50312: LIST
50313: LIST
50314: ST_TO_ADDR
// fFactory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
50315: LD_ADDR_VAR 0 34
50319: PUSH
50320: LD_INT 0
50322: PUSH
50323: LD_INT 4
50325: NEG
50326: PUSH
50327: EMPTY
50328: LIST
50329: LIST
50330: PUSH
50331: LD_INT 0
50333: PUSH
50334: LD_INT 5
50336: NEG
50337: PUSH
50338: EMPTY
50339: LIST
50340: LIST
50341: PUSH
50342: LD_INT 1
50344: PUSH
50345: LD_INT 4
50347: NEG
50348: PUSH
50349: EMPTY
50350: LIST
50351: LIST
50352: PUSH
50353: LD_INT 1
50355: PUSH
50356: LD_INT 3
50358: NEG
50359: PUSH
50360: EMPTY
50361: LIST
50362: LIST
50363: PUSH
50364: LD_INT 0
50366: PUSH
50367: LD_INT 3
50369: NEG
50370: PUSH
50371: EMPTY
50372: LIST
50373: LIST
50374: PUSH
50375: LD_INT 1
50377: NEG
50378: PUSH
50379: LD_INT 4
50381: NEG
50382: PUSH
50383: EMPTY
50384: LIST
50385: LIST
50386: PUSH
50387: LD_INT 1
50389: NEG
50390: PUSH
50391: LD_INT 5
50393: NEG
50394: PUSH
50395: EMPTY
50396: LIST
50397: LIST
50398: PUSH
50399: LD_INT 2
50401: PUSH
50402: LD_INT 3
50404: NEG
50405: PUSH
50406: EMPTY
50407: LIST
50408: LIST
50409: PUSH
50410: LD_INT 2
50412: NEG
50413: PUSH
50414: LD_INT 5
50416: NEG
50417: PUSH
50418: EMPTY
50419: LIST
50420: LIST
50421: PUSH
50422: LD_INT 3
50424: PUSH
50425: LD_INT 0
50427: PUSH
50428: EMPTY
50429: LIST
50430: LIST
50431: PUSH
50432: LD_INT 3
50434: PUSH
50435: LD_INT 1
50437: NEG
50438: PUSH
50439: EMPTY
50440: LIST
50441: LIST
50442: PUSH
50443: LD_INT 4
50445: PUSH
50446: LD_INT 0
50448: PUSH
50449: EMPTY
50450: LIST
50451: LIST
50452: PUSH
50453: LD_INT 4
50455: PUSH
50456: LD_INT 1
50458: PUSH
50459: EMPTY
50460: LIST
50461: LIST
50462: PUSH
50463: LD_INT 3
50465: PUSH
50466: LD_INT 1
50468: PUSH
50469: EMPTY
50470: LIST
50471: LIST
50472: PUSH
50473: LD_INT 2
50475: PUSH
50476: LD_INT 0
50478: PUSH
50479: EMPTY
50480: LIST
50481: LIST
50482: PUSH
50483: LD_INT 2
50485: PUSH
50486: LD_INT 1
50488: NEG
50489: PUSH
50490: EMPTY
50491: LIST
50492: LIST
50493: PUSH
50494: LD_INT 2
50496: PUSH
50497: LD_INT 2
50499: NEG
50500: PUSH
50501: EMPTY
50502: LIST
50503: LIST
50504: PUSH
50505: LD_INT 4
50507: PUSH
50508: LD_INT 2
50510: PUSH
50511: EMPTY
50512: LIST
50513: LIST
50514: PUSH
50515: LD_INT 4
50517: PUSH
50518: LD_INT 4
50520: PUSH
50521: EMPTY
50522: LIST
50523: LIST
50524: PUSH
50525: LD_INT 4
50527: PUSH
50528: LD_INT 3
50530: PUSH
50531: EMPTY
50532: LIST
50533: LIST
50534: PUSH
50535: LD_INT 5
50537: PUSH
50538: LD_INT 4
50540: PUSH
50541: EMPTY
50542: LIST
50543: LIST
50544: PUSH
50545: LD_INT 5
50547: PUSH
50548: LD_INT 5
50550: PUSH
50551: EMPTY
50552: LIST
50553: LIST
50554: PUSH
50555: LD_INT 4
50557: PUSH
50558: LD_INT 5
50560: PUSH
50561: EMPTY
50562: LIST
50563: LIST
50564: PUSH
50565: LD_INT 3
50567: PUSH
50568: LD_INT 4
50570: PUSH
50571: EMPTY
50572: LIST
50573: LIST
50574: PUSH
50575: LD_INT 3
50577: PUSH
50578: LD_INT 3
50580: PUSH
50581: EMPTY
50582: LIST
50583: LIST
50584: PUSH
50585: LD_INT 5
50587: PUSH
50588: LD_INT 3
50590: PUSH
50591: EMPTY
50592: LIST
50593: LIST
50594: PUSH
50595: LD_INT 3
50597: PUSH
50598: LD_INT 5
50600: PUSH
50601: EMPTY
50602: LIST
50603: LIST
50604: PUSH
50605: LD_INT 0
50607: PUSH
50608: LD_INT 3
50610: PUSH
50611: EMPTY
50612: LIST
50613: LIST
50614: PUSH
50615: LD_INT 0
50617: PUSH
50618: LD_INT 2
50620: PUSH
50621: EMPTY
50622: LIST
50623: LIST
50624: PUSH
50625: LD_INT 1
50627: PUSH
50628: LD_INT 3
50630: PUSH
50631: EMPTY
50632: LIST
50633: LIST
50634: PUSH
50635: LD_INT 1
50637: PUSH
50638: LD_INT 4
50640: PUSH
50641: EMPTY
50642: LIST
50643: LIST
50644: PUSH
50645: LD_INT 0
50647: PUSH
50648: LD_INT 4
50650: PUSH
50651: EMPTY
50652: LIST
50653: LIST
50654: PUSH
50655: LD_INT 1
50657: NEG
50658: PUSH
50659: LD_INT 3
50661: PUSH
50662: EMPTY
50663: LIST
50664: LIST
50665: PUSH
50666: LD_INT 1
50668: NEG
50669: PUSH
50670: LD_INT 2
50672: PUSH
50673: EMPTY
50674: LIST
50675: LIST
50676: PUSH
50677: LD_INT 2
50679: PUSH
50680: LD_INT 4
50682: PUSH
50683: EMPTY
50684: LIST
50685: LIST
50686: PUSH
50687: LD_INT 2
50689: NEG
50690: PUSH
50691: LD_INT 2
50693: PUSH
50694: EMPTY
50695: LIST
50696: LIST
50697: PUSH
50698: LD_INT 4
50700: NEG
50701: PUSH
50702: LD_INT 0
50704: PUSH
50705: EMPTY
50706: LIST
50707: LIST
50708: PUSH
50709: LD_INT 4
50711: NEG
50712: PUSH
50713: LD_INT 1
50715: NEG
50716: PUSH
50717: EMPTY
50718: LIST
50719: LIST
50720: PUSH
50721: LD_INT 3
50723: NEG
50724: PUSH
50725: LD_INT 0
50727: PUSH
50728: EMPTY
50729: LIST
50730: LIST
50731: PUSH
50732: LD_INT 3
50734: NEG
50735: PUSH
50736: LD_INT 1
50738: PUSH
50739: EMPTY
50740: LIST
50741: LIST
50742: PUSH
50743: LD_INT 4
50745: NEG
50746: PUSH
50747: LD_INT 1
50749: PUSH
50750: EMPTY
50751: LIST
50752: LIST
50753: PUSH
50754: LD_INT 5
50756: NEG
50757: PUSH
50758: LD_INT 0
50760: PUSH
50761: EMPTY
50762: LIST
50763: LIST
50764: PUSH
50765: LD_INT 5
50767: NEG
50768: PUSH
50769: LD_INT 1
50771: NEG
50772: PUSH
50773: EMPTY
50774: LIST
50775: LIST
50776: PUSH
50777: LD_INT 5
50779: NEG
50780: PUSH
50781: LD_INT 2
50783: NEG
50784: PUSH
50785: EMPTY
50786: LIST
50787: LIST
50788: PUSH
50789: LD_INT 3
50791: NEG
50792: PUSH
50793: LD_INT 2
50795: PUSH
50796: EMPTY
50797: LIST
50798: LIST
50799: PUSH
50800: EMPTY
50801: LIST
50802: LIST
50803: LIST
50804: LIST
50805: LIST
50806: LIST
50807: LIST
50808: LIST
50809: LIST
50810: LIST
50811: LIST
50812: LIST
50813: LIST
50814: LIST
50815: LIST
50816: LIST
50817: LIST
50818: LIST
50819: LIST
50820: LIST
50821: LIST
50822: LIST
50823: LIST
50824: LIST
50825: LIST
50826: LIST
50827: LIST
50828: LIST
50829: LIST
50830: LIST
50831: LIST
50832: LIST
50833: LIST
50834: LIST
50835: LIST
50836: LIST
50837: LIST
50838: LIST
50839: LIST
50840: LIST
50841: LIST
50842: LIST
50843: LIST
50844: LIST
50845: LIST
50846: ST_TO_ADDR
// end ; end ;
50847: GO 50850
50849: POP
// case btype of b_depot , b_warehouse :
50850: LD_VAR 0 1
50854: PUSH
50855: LD_INT 0
50857: DOUBLE
50858: EQUAL
50859: IFTRUE 50869
50861: LD_INT 1
50863: DOUBLE
50864: EQUAL
50865: IFTRUE 50869
50867: GO 51070
50869: POP
// case nation of nation_american :
50870: LD_VAR 0 5
50874: PUSH
50875: LD_INT 1
50877: DOUBLE
50878: EQUAL
50879: IFTRUE 50883
50881: GO 50939
50883: POP
// temp_list = [ fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 ] [ dir + 1 ] ; nation_arabian :
50884: LD_ADDR_VAR 0 9
50888: PUSH
50889: LD_VAR 0 11
50893: PUSH
50894: LD_VAR 0 12
50898: PUSH
50899: LD_VAR 0 13
50903: PUSH
50904: LD_VAR 0 14
50908: PUSH
50909: LD_VAR 0 15
50913: PUSH
50914: LD_VAR 0 16
50918: PUSH
50919: EMPTY
50920: LIST
50921: LIST
50922: LIST
50923: LIST
50924: LIST
50925: LIST
50926: PUSH
50927: LD_VAR 0 4
50931: PUSH
50932: LD_INT 1
50934: PLUS
50935: ARRAY
50936: ST_TO_ADDR
50937: GO 51068
50939: LD_INT 2
50941: DOUBLE
50942: EQUAL
50943: IFTRUE 50947
50945: GO 51003
50947: POP
// temp_list = [ fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 ] [ dir + 1 ] ; nation_russian :
50948: LD_ADDR_VAR 0 9
50952: PUSH
50953: LD_VAR 0 17
50957: PUSH
50958: LD_VAR 0 18
50962: PUSH
50963: LD_VAR 0 19
50967: PUSH
50968: LD_VAR 0 20
50972: PUSH
50973: LD_VAR 0 21
50977: PUSH
50978: LD_VAR 0 22
50982: PUSH
50983: EMPTY
50984: LIST
50985: LIST
50986: LIST
50987: LIST
50988: LIST
50989: LIST
50990: PUSH
50991: LD_VAR 0 4
50995: PUSH
50996: LD_INT 1
50998: PLUS
50999: ARRAY
51000: ST_TO_ADDR
51001: GO 51068
51003: LD_INT 3
51005: DOUBLE
51006: EQUAL
51007: IFTRUE 51011
51009: GO 51067
51011: POP
// temp_list = [ fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
51012: LD_ADDR_VAR 0 9
51016: PUSH
51017: LD_VAR 0 23
51021: PUSH
51022: LD_VAR 0 24
51026: PUSH
51027: LD_VAR 0 25
51031: PUSH
51032: LD_VAR 0 26
51036: PUSH
51037: LD_VAR 0 27
51041: PUSH
51042: LD_VAR 0 28
51046: PUSH
51047: EMPTY
51048: LIST
51049: LIST
51050: LIST
51051: LIST
51052: LIST
51053: LIST
51054: PUSH
51055: LD_VAR 0 4
51059: PUSH
51060: LD_INT 1
51062: PLUS
51063: ARRAY
51064: ST_TO_ADDR
51065: GO 51068
51067: POP
51068: GO 51623
51070: LD_INT 2
51072: DOUBLE
51073: EQUAL
51074: IFTRUE 51084
51076: LD_INT 3
51078: DOUBLE
51079: EQUAL
51080: IFTRUE 51084
51082: GO 51140
51084: POP
// temp_list = [ fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
51085: LD_ADDR_VAR 0 9
51089: PUSH
51090: LD_VAR 0 29
51094: PUSH
51095: LD_VAR 0 30
51099: PUSH
51100: LD_VAR 0 31
51104: PUSH
51105: LD_VAR 0 32
51109: PUSH
51110: LD_VAR 0 33
51114: PUSH
51115: LD_VAR 0 34
51119: PUSH
51120: EMPTY
51121: LIST
51122: LIST
51123: LIST
51124: LIST
51125: LIST
51126: LIST
51127: PUSH
51128: LD_VAR 0 4
51132: PUSH
51133: LD_INT 1
51135: PLUS
51136: ARRAY
51137: ST_TO_ADDR
51138: GO 51623
51140: LD_INT 16
51142: DOUBLE
51143: EQUAL
51144: IFTRUE 51202
51146: LD_INT 17
51148: DOUBLE
51149: EQUAL
51150: IFTRUE 51202
51152: LD_INT 18
51154: DOUBLE
51155: EQUAL
51156: IFTRUE 51202
51158: LD_INT 19
51160: DOUBLE
51161: EQUAL
51162: IFTRUE 51202
51164: LD_INT 22
51166: DOUBLE
51167: EQUAL
51168: IFTRUE 51202
51170: LD_INT 20
51172: DOUBLE
51173: EQUAL
51174: IFTRUE 51202
51176: LD_INT 21
51178: DOUBLE
51179: EQUAL
51180: IFTRUE 51202
51182: LD_INT 23
51184: DOUBLE
51185: EQUAL
51186: IFTRUE 51202
51188: LD_INT 24
51190: DOUBLE
51191: EQUAL
51192: IFTRUE 51202
51194: LD_INT 25
51196: DOUBLE
51197: EQUAL
51198: IFTRUE 51202
51200: GO 51258
51202: POP
// temp_list = [ fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
51203: LD_ADDR_VAR 0 9
51207: PUSH
51208: LD_VAR 0 35
51212: PUSH
51213: LD_VAR 0 36
51217: PUSH
51218: LD_VAR 0 37
51222: PUSH
51223: LD_VAR 0 38
51227: PUSH
51228: LD_VAR 0 39
51232: PUSH
51233: LD_VAR 0 40
51237: PUSH
51238: EMPTY
51239: LIST
51240: LIST
51241: LIST
51242: LIST
51243: LIST
51244: LIST
51245: PUSH
51246: LD_VAR 0 4
51250: PUSH
51251: LD_INT 1
51253: PLUS
51254: ARRAY
51255: ST_TO_ADDR
51256: GO 51623
51258: LD_INT 6
51260: DOUBLE
51261: EQUAL
51262: IFTRUE 51314
51264: LD_INT 7
51266: DOUBLE
51267: EQUAL
51268: IFTRUE 51314
51270: LD_INT 8
51272: DOUBLE
51273: EQUAL
51274: IFTRUE 51314
51276: LD_INT 13
51278: DOUBLE
51279: EQUAL
51280: IFTRUE 51314
51282: LD_INT 12
51284: DOUBLE
51285: EQUAL
51286: IFTRUE 51314
51288: LD_INT 15
51290: DOUBLE
51291: EQUAL
51292: IFTRUE 51314
51294: LD_INT 11
51296: DOUBLE
51297: EQUAL
51298: IFTRUE 51314
51300: LD_INT 14
51302: DOUBLE
51303: EQUAL
51304: IFTRUE 51314
51306: LD_INT 10
51308: DOUBLE
51309: EQUAL
51310: IFTRUE 51314
51312: GO 51370
51314: POP
// temp_list = [ fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 ] [ dir + 1 ] ; b_control_tower :
51315: LD_ADDR_VAR 0 9
51319: PUSH
51320: LD_VAR 0 41
51324: PUSH
51325: LD_VAR 0 42
51329: PUSH
51330: LD_VAR 0 43
51334: PUSH
51335: LD_VAR 0 44
51339: PUSH
51340: LD_VAR 0 45
51344: PUSH
51345: LD_VAR 0 46
51349: PUSH
51350: EMPTY
51351: LIST
51352: LIST
51353: LIST
51354: LIST
51355: LIST
51356: LIST
51357: PUSH
51358: LD_VAR 0 4
51362: PUSH
51363: LD_INT 1
51365: PLUS
51366: ARRAY
51367: ST_TO_ADDR
51368: GO 51623
51370: LD_INT 36
51372: DOUBLE
51373: EQUAL
51374: IFTRUE 51378
51376: GO 51434
51378: POP
// temp_list = [ fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
51379: LD_ADDR_VAR 0 9
51383: PUSH
51384: LD_VAR 0 47
51388: PUSH
51389: LD_VAR 0 48
51393: PUSH
51394: LD_VAR 0 49
51398: PUSH
51399: LD_VAR 0 50
51403: PUSH
51404: LD_VAR 0 51
51408: PUSH
51409: LD_VAR 0 52
51413: PUSH
51414: EMPTY
51415: LIST
51416: LIST
51417: LIST
51418: LIST
51419: LIST
51420: LIST
51421: PUSH
51422: LD_VAR 0 4
51426: PUSH
51427: LD_INT 1
51429: PLUS
51430: ARRAY
51431: ST_TO_ADDR
51432: GO 51623
51434: LD_INT 4
51436: DOUBLE
51437: EQUAL
51438: IFTRUE 51460
51440: LD_INT 5
51442: DOUBLE
51443: EQUAL
51444: IFTRUE 51460
51446: LD_INT 34
51448: DOUBLE
51449: EQUAL
51450: IFTRUE 51460
51452: LD_INT 37
51454: DOUBLE
51455: EQUAL
51456: IFTRUE 51460
51458: GO 51516
51460: POP
// temp_list = [ fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
51461: LD_ADDR_VAR 0 9
51465: PUSH
51466: LD_VAR 0 53
51470: PUSH
51471: LD_VAR 0 54
51475: PUSH
51476: LD_VAR 0 55
51480: PUSH
51481: LD_VAR 0 56
51485: PUSH
51486: LD_VAR 0 57
51490: PUSH
51491: LD_VAR 0 58
51495: PUSH
51496: EMPTY
51497: LIST
51498: LIST
51499: LIST
51500: LIST
51501: LIST
51502: LIST
51503: PUSH
51504: LD_VAR 0 4
51508: PUSH
51509: LD_INT 1
51511: PLUS
51512: ARRAY
51513: ST_TO_ADDR
51514: GO 51623
51516: LD_INT 31
51518: DOUBLE
51519: EQUAL
51520: IFTRUE 51566
51522: LD_INT 32
51524: DOUBLE
51525: EQUAL
51526: IFTRUE 51566
51528: LD_INT 33
51530: DOUBLE
51531: EQUAL
51532: IFTRUE 51566
51534: LD_INT 27
51536: DOUBLE
51537: EQUAL
51538: IFTRUE 51566
51540: LD_INT 26
51542: DOUBLE
51543: EQUAL
51544: IFTRUE 51566
51546: LD_INT 28
51548: DOUBLE
51549: EQUAL
51550: IFTRUE 51566
51552: LD_INT 29
51554: DOUBLE
51555: EQUAL
51556: IFTRUE 51566
51558: LD_INT 30
51560: DOUBLE
51561: EQUAL
51562: IFTRUE 51566
51564: GO 51622
51566: POP
// temp_list = [ fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ] [ dir + 1 ] ; end ;
51567: LD_ADDR_VAR 0 9
51571: PUSH
51572: LD_VAR 0 59
51576: PUSH
51577: LD_VAR 0 60
51581: PUSH
51582: LD_VAR 0 61
51586: PUSH
51587: LD_VAR 0 62
51591: PUSH
51592: LD_VAR 0 63
51596: PUSH
51597: LD_VAR 0 64
51601: PUSH
51602: EMPTY
51603: LIST
51604: LIST
51605: LIST
51606: LIST
51607: LIST
51608: LIST
51609: PUSH
51610: LD_VAR 0 4
51614: PUSH
51615: LD_INT 1
51617: PLUS
51618: ARRAY
51619: ST_TO_ADDR
51620: GO 51623
51622: POP
// temp_list2 = [ ] ;
51623: LD_ADDR_VAR 0 10
51627: PUSH
51628: EMPTY
51629: ST_TO_ADDR
// for i in temp_list do
51630: LD_ADDR_VAR 0 8
51634: PUSH
51635: LD_VAR 0 9
51639: PUSH
51640: FOR_IN
51641: IFFALSE 51693
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
51643: LD_ADDR_VAR 0 10
51647: PUSH
51648: LD_VAR 0 10
51652: PUSH
51653: LD_VAR 0 8
51657: PUSH
51658: LD_INT 1
51660: ARRAY
51661: PUSH
51662: LD_VAR 0 2
51666: PLUS
51667: PUSH
51668: LD_VAR 0 8
51672: PUSH
51673: LD_INT 2
51675: ARRAY
51676: PUSH
51677: LD_VAR 0 3
51681: PLUS
51682: PUSH
51683: EMPTY
51684: LIST
51685: LIST
51686: PUSH
51687: EMPTY
51688: LIST
51689: ADD
51690: ST_TO_ADDR
51691: GO 51640
51693: POP
51694: POP
// result = temp_list2 ;
51695: LD_ADDR_VAR 0 7
51699: PUSH
51700: LD_VAR 0 10
51704: ST_TO_ADDR
// end ;
51705: LD_VAR 0 7
51709: RET
// export function EnemyInRange ( unit , dist ) ; begin
51710: LD_INT 0
51712: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
51713: LD_ADDR_VAR 0 3
51717: PUSH
51718: LD_VAR 0 1
51722: PPUSH
51723: CALL_OW 255
51727: PPUSH
51728: LD_VAR 0 1
51732: PPUSH
51733: CALL_OW 250
51737: PPUSH
51738: LD_VAR 0 1
51742: PPUSH
51743: CALL_OW 251
51747: PPUSH
51748: LD_VAR 0 2
51752: PPUSH
51753: CALL 25106 0 4
51757: PUSH
51758: LD_INT 4
51760: ARRAY
51761: ST_TO_ADDR
// end ;
51762: LD_VAR 0 3
51766: RET
// export function PlayerSeeMe ( unit ) ; begin
51767: LD_INT 0
51769: PPUSH
// result := See ( your_side , unit ) ;
51770: LD_ADDR_VAR 0 2
51774: PUSH
51775: LD_OWVAR 2
51779: PPUSH
51780: LD_VAR 0 1
51784: PPUSH
51785: CALL_OW 292
51789: ST_TO_ADDR
// end ;
51790: LD_VAR 0 2
51794: RET
// export function ReverseDir ( unit ) ; begin
51795: LD_INT 0
51797: PPUSH
// if not unit then
51798: LD_VAR 0 1
51802: NOT
51803: IFFALSE 51807
// exit ;
51805: GO 51830
// result := ( GetDir ( unit ) + 3 ) mod 6 ;
51807: LD_ADDR_VAR 0 2
51811: PUSH
51812: LD_VAR 0 1
51816: PPUSH
51817: CALL_OW 254
51821: PUSH
51822: LD_INT 3
51824: PLUS
51825: PUSH
51826: LD_INT 6
51828: MOD
51829: ST_TO_ADDR
// end ;
51830: LD_VAR 0 2
51834: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tmp , hex ; begin
51835: LD_INT 0
51837: PPUSH
51838: PPUSH
51839: PPUSH
51840: PPUSH
51841: PPUSH
// if not hexes then
51842: LD_VAR 0 2
51846: NOT
51847: IFFALSE 51851
// exit ;
51849: GO 51999
// dist := 9999 ;
51851: LD_ADDR_VAR 0 5
51855: PUSH
51856: LD_INT 9999
51858: ST_TO_ADDR
// for i = 1 to hexes do
51859: LD_ADDR_VAR 0 4
51863: PUSH
51864: DOUBLE
51865: LD_INT 1
51867: DEC
51868: ST_TO_ADDR
51869: LD_VAR 0 2
51873: PUSH
51874: FOR_TO
51875: IFFALSE 51987
// begin if GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) < dist then
51877: LD_VAR 0 1
51881: PPUSH
51882: LD_VAR 0 2
51886: PUSH
51887: LD_VAR 0 4
51891: ARRAY
51892: PUSH
51893: LD_INT 1
51895: ARRAY
51896: PPUSH
51897: LD_VAR 0 2
51901: PUSH
51902: LD_VAR 0 4
51906: ARRAY
51907: PUSH
51908: LD_INT 2
51910: ARRAY
51911: PPUSH
51912: CALL_OW 297
51916: PUSH
51917: LD_VAR 0 5
51921: LESS
51922: IFFALSE 51985
// begin hex := hexes [ i ] ;
51924: LD_ADDR_VAR 0 7
51928: PUSH
51929: LD_VAR 0 2
51933: PUSH
51934: LD_VAR 0 4
51938: ARRAY
51939: ST_TO_ADDR
// dist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
51940: LD_ADDR_VAR 0 5
51944: PUSH
51945: LD_VAR 0 1
51949: PPUSH
51950: LD_VAR 0 2
51954: PUSH
51955: LD_VAR 0 4
51959: ARRAY
51960: PUSH
51961: LD_INT 1
51963: ARRAY
51964: PPUSH
51965: LD_VAR 0 2
51969: PUSH
51970: LD_VAR 0 4
51974: ARRAY
51975: PUSH
51976: LD_INT 2
51978: ARRAY
51979: PPUSH
51980: CALL_OW 297
51984: ST_TO_ADDR
// end ; end ;
51985: GO 51874
51987: POP
51988: POP
// result := hex ;
51989: LD_ADDR_VAR 0 3
51993: PUSH
51994: LD_VAR 0 7
51998: ST_TO_ADDR
// end ;
51999: LD_VAR 0 3
52003: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
52004: LD_INT 0
52006: PPUSH
52007: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
52008: LD_VAR 0 1
52012: NOT
52013: PUSH
52014: LD_VAR 0 1
52018: PUSH
52019: LD_INT 21
52021: PUSH
52022: LD_INT 2
52024: PUSH
52025: EMPTY
52026: LIST
52027: LIST
52028: PUSH
52029: LD_INT 23
52031: PUSH
52032: LD_INT 2
52034: PUSH
52035: EMPTY
52036: LIST
52037: LIST
52038: PUSH
52039: EMPTY
52040: LIST
52041: LIST
52042: PPUSH
52043: CALL_OW 69
52047: IN
52048: NOT
52049: OR
52050: IFFALSE 52054
// exit ;
52052: GO 52101
// for i = 1 to 3 do
52054: LD_ADDR_VAR 0 3
52058: PUSH
52059: DOUBLE
52060: LD_INT 1
52062: DEC
52063: ST_TO_ADDR
52064: LD_INT 3
52066: PUSH
52067: FOR_TO
52068: IFFALSE 52099
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
52070: LD_VAR 0 1
52074: PPUSH
52075: CALL_OW 250
52079: PPUSH
52080: LD_VAR 0 1
52084: PPUSH
52085: CALL_OW 251
52089: PPUSH
52090: LD_INT 1
52092: PPUSH
52093: CALL_OW 453
52097: GO 52067
52099: POP
52100: POP
// end ;
52101: LD_VAR 0 2
52105: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
52106: LD_INT 0
52108: PPUSH
52109: PPUSH
52110: PPUSH
52111: PPUSH
52112: PPUSH
52113: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
52114: LD_VAR 0 1
52118: NOT
52119: PUSH
52120: LD_VAR 0 2
52124: NOT
52125: OR
52126: PUSH
52127: LD_VAR 0 1
52131: PPUSH
52132: CALL_OW 314
52136: OR
52137: IFFALSE 52141
// exit ;
52139: GO 52582
// x := GetX ( enemy_unit ) ;
52141: LD_ADDR_VAR 0 7
52145: PUSH
52146: LD_VAR 0 2
52150: PPUSH
52151: CALL_OW 250
52155: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
52156: LD_ADDR_VAR 0 8
52160: PUSH
52161: LD_VAR 0 2
52165: PPUSH
52166: CALL_OW 251
52170: ST_TO_ADDR
// if not x or not y then
52171: LD_VAR 0 7
52175: NOT
52176: PUSH
52177: LD_VAR 0 8
52181: NOT
52182: OR
52183: IFFALSE 52187
// exit ;
52185: GO 52582
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
52187: LD_ADDR_VAR 0 6
52191: PUSH
52192: LD_VAR 0 7
52196: PPUSH
52197: LD_INT 0
52199: PPUSH
52200: LD_INT 4
52202: PPUSH
52203: CALL_OW 272
52207: PUSH
52208: LD_VAR 0 8
52212: PPUSH
52213: LD_INT 0
52215: PPUSH
52216: LD_INT 4
52218: PPUSH
52219: CALL_OW 273
52223: PUSH
52224: EMPTY
52225: LIST
52226: LIST
52227: PUSH
52228: LD_VAR 0 7
52232: PPUSH
52233: LD_INT 1
52235: PPUSH
52236: LD_INT 4
52238: PPUSH
52239: CALL_OW 272
52243: PUSH
52244: LD_VAR 0 8
52248: PPUSH
52249: LD_INT 1
52251: PPUSH
52252: LD_INT 4
52254: PPUSH
52255: CALL_OW 273
52259: PUSH
52260: EMPTY
52261: LIST
52262: LIST
52263: PUSH
52264: LD_VAR 0 7
52268: PPUSH
52269: LD_INT 2
52271: PPUSH
52272: LD_INT 4
52274: PPUSH
52275: CALL_OW 272
52279: PUSH
52280: LD_VAR 0 8
52284: PPUSH
52285: LD_INT 2
52287: PPUSH
52288: LD_INT 4
52290: PPUSH
52291: CALL_OW 273
52295: PUSH
52296: EMPTY
52297: LIST
52298: LIST
52299: PUSH
52300: LD_VAR 0 7
52304: PPUSH
52305: LD_INT 3
52307: PPUSH
52308: LD_INT 4
52310: PPUSH
52311: CALL_OW 272
52315: PUSH
52316: LD_VAR 0 8
52320: PPUSH
52321: LD_INT 3
52323: PPUSH
52324: LD_INT 4
52326: PPUSH
52327: CALL_OW 273
52331: PUSH
52332: EMPTY
52333: LIST
52334: LIST
52335: PUSH
52336: LD_VAR 0 7
52340: PPUSH
52341: LD_INT 4
52343: PPUSH
52344: LD_INT 4
52346: PPUSH
52347: CALL_OW 272
52351: PUSH
52352: LD_VAR 0 8
52356: PPUSH
52357: LD_INT 4
52359: PPUSH
52360: LD_INT 4
52362: PPUSH
52363: CALL_OW 273
52367: PUSH
52368: EMPTY
52369: LIST
52370: LIST
52371: PUSH
52372: LD_VAR 0 7
52376: PPUSH
52377: LD_INT 5
52379: PPUSH
52380: LD_INT 4
52382: PPUSH
52383: CALL_OW 272
52387: PUSH
52388: LD_VAR 0 8
52392: PPUSH
52393: LD_INT 5
52395: PPUSH
52396: LD_INT 4
52398: PPUSH
52399: CALL_OW 273
52403: PUSH
52404: EMPTY
52405: LIST
52406: LIST
52407: PUSH
52408: EMPTY
52409: LIST
52410: LIST
52411: LIST
52412: LIST
52413: LIST
52414: LIST
52415: ST_TO_ADDR
// for i = tmp downto 1 do
52416: LD_ADDR_VAR 0 4
52420: PUSH
52421: DOUBLE
52422: LD_VAR 0 6
52426: INC
52427: ST_TO_ADDR
52428: LD_INT 1
52430: PUSH
52431: FOR_DOWNTO
52432: IFFALSE 52533
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
52434: LD_VAR 0 6
52438: PUSH
52439: LD_VAR 0 4
52443: ARRAY
52444: PUSH
52445: LD_INT 1
52447: ARRAY
52448: PPUSH
52449: LD_VAR 0 6
52453: PUSH
52454: LD_VAR 0 4
52458: ARRAY
52459: PUSH
52460: LD_INT 2
52462: ARRAY
52463: PPUSH
52464: CALL_OW 488
52468: NOT
52469: PUSH
52470: LD_VAR 0 6
52474: PUSH
52475: LD_VAR 0 4
52479: ARRAY
52480: PUSH
52481: LD_INT 1
52483: ARRAY
52484: PPUSH
52485: LD_VAR 0 6
52489: PUSH
52490: LD_VAR 0 4
52494: ARRAY
52495: PUSH
52496: LD_INT 2
52498: ARRAY
52499: PPUSH
52500: CALL_OW 428
52504: PUSH
52505: LD_INT 0
52507: NONEQUAL
52508: OR
52509: IFFALSE 52531
// tmp := Delete ( tmp , i ) ;
52511: LD_ADDR_VAR 0 6
52515: PUSH
52516: LD_VAR 0 6
52520: PPUSH
52521: LD_VAR 0 4
52525: PPUSH
52526: CALL_OW 3
52530: ST_TO_ADDR
52531: GO 52431
52533: POP
52534: POP
// j := GetClosestHex ( unit , tmp ) ;
52535: LD_ADDR_VAR 0 5
52539: PUSH
52540: LD_VAR 0 1
52544: PPUSH
52545: LD_VAR 0 6
52549: PPUSH
52550: CALL 51835 0 2
52554: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
52555: LD_VAR 0 1
52559: PPUSH
52560: LD_VAR 0 5
52564: PUSH
52565: LD_INT 1
52567: ARRAY
52568: PPUSH
52569: LD_VAR 0 5
52573: PUSH
52574: LD_INT 2
52576: ARRAY
52577: PPUSH
52578: CALL_OW 111
// end ;
52582: LD_VAR 0 3
52586: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
52587: LD_INT 0
52589: PPUSH
52590: PPUSH
52591: PPUSH
// uc_side = 0 ;
52592: LD_ADDR_OWVAR 20
52596: PUSH
52597: LD_INT 0
52599: ST_TO_ADDR
// uc_nation = 0 ;
52600: LD_ADDR_OWVAR 21
52604: PUSH
52605: LD_INT 0
52607: ST_TO_ADDR
// InitHc_All ( ) ;
52608: CALL_OW 584
// InitVc ;
52612: CALL_OW 20
// if mastodonts then
52616: LD_VAR 0 6
52620: IFFALSE 52687
// for i = 1 to mastodonts do
52622: LD_ADDR_VAR 0 11
52626: PUSH
52627: DOUBLE
52628: LD_INT 1
52630: DEC
52631: ST_TO_ADDR
52632: LD_VAR 0 6
52636: PUSH
52637: FOR_TO
52638: IFFALSE 52685
// begin vc_chassis := 31 ;
52640: LD_ADDR_OWVAR 37
52644: PUSH
52645: LD_INT 31
52647: ST_TO_ADDR
// vc_control := control_rider ;
52648: LD_ADDR_OWVAR 38
52652: PUSH
52653: LD_INT 4
52655: ST_TO_ADDR
// animal := CreateVehicle ;
52656: LD_ADDR_VAR 0 12
52660: PUSH
52661: CALL_OW 45
52665: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
52666: LD_VAR 0 12
52670: PPUSH
52671: LD_VAR 0 8
52675: PPUSH
52676: LD_INT 0
52678: PPUSH
52679: CALL 54875 0 3
// end ;
52683: GO 52637
52685: POP
52686: POP
// if horses then
52687: LD_VAR 0 5
52691: IFFALSE 52758
// for i = 1 to horses do
52693: LD_ADDR_VAR 0 11
52697: PUSH
52698: DOUBLE
52699: LD_INT 1
52701: DEC
52702: ST_TO_ADDR
52703: LD_VAR 0 5
52707: PUSH
52708: FOR_TO
52709: IFFALSE 52756
// begin hc_class := 21 ;
52711: LD_ADDR_OWVAR 28
52715: PUSH
52716: LD_INT 21
52718: ST_TO_ADDR
// hc_gallery :=  ;
52719: LD_ADDR_OWVAR 33
52723: PUSH
52724: LD_STRING 
52726: ST_TO_ADDR
// animal := CreateHuman ;
52727: LD_ADDR_VAR 0 12
52731: PUSH
52732: CALL_OW 44
52736: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
52737: LD_VAR 0 12
52741: PPUSH
52742: LD_VAR 0 8
52746: PPUSH
52747: LD_INT 0
52749: PPUSH
52750: CALL 54875 0 3
// end ;
52754: GO 52708
52756: POP
52757: POP
// if birds then
52758: LD_VAR 0 1
52762: IFFALSE 52829
// for i = 1 to birds do
52764: LD_ADDR_VAR 0 11
52768: PUSH
52769: DOUBLE
52770: LD_INT 1
52772: DEC
52773: ST_TO_ADDR
52774: LD_VAR 0 1
52778: PUSH
52779: FOR_TO
52780: IFFALSE 52827
// begin hc_class = 18 ;
52782: LD_ADDR_OWVAR 28
52786: PUSH
52787: LD_INT 18
52789: ST_TO_ADDR
// hc_gallery =  ;
52790: LD_ADDR_OWVAR 33
52794: PUSH
52795: LD_STRING 
52797: ST_TO_ADDR
// animal := CreateHuman ;
52798: LD_ADDR_VAR 0 12
52802: PUSH
52803: CALL_OW 44
52807: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
52808: LD_VAR 0 12
52812: PPUSH
52813: LD_VAR 0 8
52817: PPUSH
52818: LD_INT 0
52820: PPUSH
52821: CALL 54875 0 3
// end ;
52825: GO 52779
52827: POP
52828: POP
// if tigers then
52829: LD_VAR 0 2
52833: IFFALSE 52917
// for i = 1 to tigers do
52835: LD_ADDR_VAR 0 11
52839: PUSH
52840: DOUBLE
52841: LD_INT 1
52843: DEC
52844: ST_TO_ADDR
52845: LD_VAR 0 2
52849: PUSH
52850: FOR_TO
52851: IFFALSE 52915
// begin hc_class = class_tiger ;
52853: LD_ADDR_OWVAR 28
52857: PUSH
52858: LD_INT 14
52860: ST_TO_ADDR
// hc_gallery =  ;
52861: LD_ADDR_OWVAR 33
52865: PUSH
52866: LD_STRING 
52868: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
52869: LD_ADDR_OWVAR 35
52873: PUSH
52874: LD_INT 7
52876: NEG
52877: PPUSH
52878: LD_INT 7
52880: PPUSH
52881: CALL_OW 12
52885: ST_TO_ADDR
// animal := CreateHuman ;
52886: LD_ADDR_VAR 0 12
52890: PUSH
52891: CALL_OW 44
52895: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
52896: LD_VAR 0 12
52900: PPUSH
52901: LD_VAR 0 8
52905: PPUSH
52906: LD_INT 0
52908: PPUSH
52909: CALL 54875 0 3
// end ;
52913: GO 52850
52915: POP
52916: POP
// if apemans then
52917: LD_VAR 0 3
52921: IFFALSE 53044
// for i = 1 to apemans do
52923: LD_ADDR_VAR 0 11
52927: PUSH
52928: DOUBLE
52929: LD_INT 1
52931: DEC
52932: ST_TO_ADDR
52933: LD_VAR 0 3
52937: PUSH
52938: FOR_TO
52939: IFFALSE 53042
// begin hc_class = class_apeman ;
52941: LD_ADDR_OWVAR 28
52945: PUSH
52946: LD_INT 12
52948: ST_TO_ADDR
// hc_gallery =  ;
52949: LD_ADDR_OWVAR 33
52953: PUSH
52954: LD_STRING 
52956: ST_TO_ADDR
// hc_agressivity = rand ( - 2 , 2 ) ;
52957: LD_ADDR_OWVAR 35
52961: PUSH
52962: LD_INT 2
52964: NEG
52965: PPUSH
52966: LD_INT 2
52968: PPUSH
52969: CALL_OW 12
52973: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
52974: LD_ADDR_OWVAR 31
52978: PUSH
52979: LD_INT 1
52981: PPUSH
52982: LD_INT 3
52984: PPUSH
52985: CALL_OW 12
52989: PUSH
52990: LD_INT 1
52992: PPUSH
52993: LD_INT 3
52995: PPUSH
52996: CALL_OW 12
53000: PUSH
53001: LD_INT 0
53003: PUSH
53004: LD_INT 0
53006: PUSH
53007: EMPTY
53008: LIST
53009: LIST
53010: LIST
53011: LIST
53012: ST_TO_ADDR
// animal := CreateHuman ;
53013: LD_ADDR_VAR 0 12
53017: PUSH
53018: CALL_OW 44
53022: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
53023: LD_VAR 0 12
53027: PPUSH
53028: LD_VAR 0 8
53032: PPUSH
53033: LD_INT 0
53035: PPUSH
53036: CALL 54875 0 3
// end ;
53040: GO 52938
53042: POP
53043: POP
// if enchidnas then
53044: LD_VAR 0 4
53048: IFFALSE 53115
// for i = 1 to enchidnas do
53050: LD_ADDR_VAR 0 11
53054: PUSH
53055: DOUBLE
53056: LD_INT 1
53058: DEC
53059: ST_TO_ADDR
53060: LD_VAR 0 4
53064: PUSH
53065: FOR_TO
53066: IFFALSE 53113
// begin hc_class = 13 ;
53068: LD_ADDR_OWVAR 28
53072: PUSH
53073: LD_INT 13
53075: ST_TO_ADDR
// hc_gallery =  ;
53076: LD_ADDR_OWVAR 33
53080: PUSH
53081: LD_STRING 
53083: ST_TO_ADDR
// animal := CreateHuman ;
53084: LD_ADDR_VAR 0 12
53088: PUSH
53089: CALL_OW 44
53093: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
53094: LD_VAR 0 12
53098: PPUSH
53099: LD_VAR 0 8
53103: PPUSH
53104: LD_INT 0
53106: PPUSH
53107: CALL 54875 0 3
// end ;
53111: GO 53065
53113: POP
53114: POP
// if fishes then
53115: LD_VAR 0 7
53119: IFFALSE 53186
// for i = 1 to fishes do
53121: LD_ADDR_VAR 0 11
53125: PUSH
53126: DOUBLE
53127: LD_INT 1
53129: DEC
53130: ST_TO_ADDR
53131: LD_VAR 0 7
53135: PUSH
53136: FOR_TO
53137: IFFALSE 53184
// begin hc_class = 20 ;
53139: LD_ADDR_OWVAR 28
53143: PUSH
53144: LD_INT 20
53146: ST_TO_ADDR
// hc_gallery =  ;
53147: LD_ADDR_OWVAR 33
53151: PUSH
53152: LD_STRING 
53154: ST_TO_ADDR
// animal := CreateHuman ;
53155: LD_ADDR_VAR 0 12
53159: PUSH
53160: CALL_OW 44
53164: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
53165: LD_VAR 0 12
53169: PPUSH
53170: LD_VAR 0 9
53174: PPUSH
53175: LD_INT 0
53177: PPUSH
53178: CALL 54875 0 3
// end ;
53182: GO 53136
53184: POP
53185: POP
// end ;
53186: LD_VAR 0 10
53190: RET
// export function WantHeal ( sci , unit ) ; begin
53191: LD_INT 0
53193: PPUSH
// if GetTaskList ( sci ) > 0 then
53194: LD_VAR 0 1
53198: PPUSH
53199: CALL_OW 437
53203: PUSH
53204: LD_INT 0
53206: GREATER
53207: IFFALSE 53277
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
53209: LD_VAR 0 1
53213: PPUSH
53214: CALL_OW 437
53218: PUSH
53219: LD_INT 1
53221: ARRAY
53222: PUSH
53223: LD_INT 1
53225: ARRAY
53226: PUSH
53227: LD_STRING l
53229: EQUAL
53230: PUSH
53231: LD_VAR 0 1
53235: PPUSH
53236: CALL_OW 437
53240: PUSH
53241: LD_INT 1
53243: ARRAY
53244: PUSH
53245: LD_INT 4
53247: ARRAY
53248: PUSH
53249: LD_VAR 0 2
53253: EQUAL
53254: AND
53255: IFFALSE 53267
// result := true else
53257: LD_ADDR_VAR 0 3
53261: PUSH
53262: LD_INT 1
53264: ST_TO_ADDR
53265: GO 53275
// result := false ;
53267: LD_ADDR_VAR 0 3
53271: PUSH
53272: LD_INT 0
53274: ST_TO_ADDR
// end else
53275: GO 53285
// result := false ;
53277: LD_ADDR_VAR 0 3
53281: PUSH
53282: LD_INT 0
53284: ST_TO_ADDR
// end ;
53285: LD_VAR 0 3
53289: RET
// export function HealTarget ( sci ) ; begin
53290: LD_INT 0
53292: PPUSH
// if not sci then
53293: LD_VAR 0 1
53297: NOT
53298: IFFALSE 53302
// exit ;
53300: GO 53367
// result := 0 ;
53302: LD_ADDR_VAR 0 2
53306: PUSH
53307: LD_INT 0
53309: ST_TO_ADDR
// if GetTaskList ( sci ) then
53310: LD_VAR 0 1
53314: PPUSH
53315: CALL_OW 437
53319: IFFALSE 53367
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
53321: LD_VAR 0 1
53325: PPUSH
53326: CALL_OW 437
53330: PUSH
53331: LD_INT 1
53333: ARRAY
53334: PUSH
53335: LD_INT 1
53337: ARRAY
53338: PUSH
53339: LD_STRING l
53341: EQUAL
53342: IFFALSE 53367
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
53344: LD_ADDR_VAR 0 2
53348: PUSH
53349: LD_VAR 0 1
53353: PPUSH
53354: CALL_OW 437
53358: PUSH
53359: LD_INT 1
53361: ARRAY
53362: PUSH
53363: LD_INT 4
53365: ARRAY
53366: ST_TO_ADDR
// end ;
53367: LD_VAR 0 2
53371: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
53372: LD_INT 0
53374: PPUSH
53375: PPUSH
53376: PPUSH
53377: PPUSH
// if not base_units then
53378: LD_VAR 0 1
53382: NOT
53383: IFFALSE 53387
// exit ;
53385: GO 53474
// result := false ;
53387: LD_ADDR_VAR 0 2
53391: PUSH
53392: LD_INT 0
53394: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
53395: LD_ADDR_VAR 0 5
53399: PUSH
53400: LD_VAR 0 1
53404: PPUSH
53405: LD_INT 21
53407: PUSH
53408: LD_INT 3
53410: PUSH
53411: EMPTY
53412: LIST
53413: LIST
53414: PPUSH
53415: CALL_OW 72
53419: ST_TO_ADDR
// if not tmp then
53420: LD_VAR 0 5
53424: NOT
53425: IFFALSE 53429
// exit ;
53427: GO 53474
// for i in tmp do
53429: LD_ADDR_VAR 0 3
53433: PUSH
53434: LD_VAR 0 5
53438: PUSH
53439: FOR_IN
53440: IFFALSE 53472
// begin result := EnemyInRange ( i , 22 ) ;
53442: LD_ADDR_VAR 0 2
53446: PUSH
53447: LD_VAR 0 3
53451: PPUSH
53452: LD_INT 22
53454: PPUSH
53455: CALL 51710 0 2
53459: ST_TO_ADDR
// if result then
53460: LD_VAR 0 2
53464: IFFALSE 53470
// exit ;
53466: POP
53467: POP
53468: GO 53474
// end ;
53470: GO 53439
53472: POP
53473: POP
// end ;
53474: LD_VAR 0 2
53478: RET
// export function FilterByTag ( units , tag ) ; var i ; begin
53479: LD_INT 0
53481: PPUSH
53482: PPUSH
// if not units then
53483: LD_VAR 0 1
53487: NOT
53488: IFFALSE 53492
// exit ;
53490: GO 53562
// result := [ ] ;
53492: LD_ADDR_VAR 0 3
53496: PUSH
53497: EMPTY
53498: ST_TO_ADDR
// for i in units do
53499: LD_ADDR_VAR 0 4
53503: PUSH
53504: LD_VAR 0 1
53508: PUSH
53509: FOR_IN
53510: IFFALSE 53560
// if GetTag ( i ) = tag then
53512: LD_VAR 0 4
53516: PPUSH
53517: CALL_OW 110
53521: PUSH
53522: LD_VAR 0 2
53526: EQUAL
53527: IFFALSE 53558
// result := Replace ( result , result + 1 , i ) ;
53529: LD_ADDR_VAR 0 3
53533: PUSH
53534: LD_VAR 0 3
53538: PPUSH
53539: LD_VAR 0 3
53543: PUSH
53544: LD_INT 1
53546: PLUS
53547: PPUSH
53548: LD_VAR 0 4
53552: PPUSH
53553: CALL_OW 1
53557: ST_TO_ADDR
53558: GO 53509
53560: POP
53561: POP
// end ;
53562: LD_VAR 0 3
53566: RET
// export function IsDriver ( un ) ; begin
53567: LD_INT 0
53569: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
53570: LD_ADDR_VAR 0 2
53574: PUSH
53575: LD_VAR 0 1
53579: PUSH
53580: LD_INT 55
53582: PUSH
53583: EMPTY
53584: LIST
53585: PPUSH
53586: CALL_OW 69
53590: IN
53591: ST_TO_ADDR
// end ;
53592: LD_VAR 0 2
53596: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
53597: LD_INT 0
53599: PPUSH
53600: PPUSH
// list := [ ] ;
53601: LD_ADDR_VAR 0 5
53605: PUSH
53606: EMPTY
53607: ST_TO_ADDR
// case d of 0 :
53608: LD_VAR 0 3
53612: PUSH
53613: LD_INT 0
53615: DOUBLE
53616: EQUAL
53617: IFTRUE 53621
53619: GO 53754
53621: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
53622: LD_ADDR_VAR 0 5
53626: PUSH
53627: LD_VAR 0 1
53631: PUSH
53632: LD_INT 4
53634: MINUS
53635: PUSH
53636: LD_VAR 0 2
53640: PUSH
53641: LD_INT 4
53643: MINUS
53644: PUSH
53645: LD_INT 2
53647: PUSH
53648: EMPTY
53649: LIST
53650: LIST
53651: LIST
53652: PUSH
53653: LD_VAR 0 1
53657: PUSH
53658: LD_INT 3
53660: MINUS
53661: PUSH
53662: LD_VAR 0 2
53666: PUSH
53667: LD_INT 1
53669: PUSH
53670: EMPTY
53671: LIST
53672: LIST
53673: LIST
53674: PUSH
53675: LD_VAR 0 1
53679: PUSH
53680: LD_INT 4
53682: PLUS
53683: PUSH
53684: LD_VAR 0 2
53688: PUSH
53689: LD_INT 4
53691: PUSH
53692: EMPTY
53693: LIST
53694: LIST
53695: LIST
53696: PUSH
53697: LD_VAR 0 1
53701: PUSH
53702: LD_INT 3
53704: PLUS
53705: PUSH
53706: LD_VAR 0 2
53710: PUSH
53711: LD_INT 3
53713: PLUS
53714: PUSH
53715: LD_INT 5
53717: PUSH
53718: EMPTY
53719: LIST
53720: LIST
53721: LIST
53722: PUSH
53723: LD_VAR 0 1
53727: PUSH
53728: LD_VAR 0 2
53732: PUSH
53733: LD_INT 4
53735: PLUS
53736: PUSH
53737: LD_INT 0
53739: PUSH
53740: EMPTY
53741: LIST
53742: LIST
53743: LIST
53744: PUSH
53745: EMPTY
53746: LIST
53747: LIST
53748: LIST
53749: LIST
53750: LIST
53751: ST_TO_ADDR
// end ; 1 :
53752: GO 54452
53754: LD_INT 1
53756: DOUBLE
53757: EQUAL
53758: IFTRUE 53762
53760: GO 53895
53762: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
53763: LD_ADDR_VAR 0 5
53767: PUSH
53768: LD_VAR 0 1
53772: PUSH
53773: LD_VAR 0 2
53777: PUSH
53778: LD_INT 4
53780: MINUS
53781: PUSH
53782: LD_INT 3
53784: PUSH
53785: EMPTY
53786: LIST
53787: LIST
53788: LIST
53789: PUSH
53790: LD_VAR 0 1
53794: PUSH
53795: LD_INT 3
53797: MINUS
53798: PUSH
53799: LD_VAR 0 2
53803: PUSH
53804: LD_INT 3
53806: MINUS
53807: PUSH
53808: LD_INT 2
53810: PUSH
53811: EMPTY
53812: LIST
53813: LIST
53814: LIST
53815: PUSH
53816: LD_VAR 0 1
53820: PUSH
53821: LD_INT 4
53823: MINUS
53824: PUSH
53825: LD_VAR 0 2
53829: PUSH
53830: LD_INT 1
53832: PUSH
53833: EMPTY
53834: LIST
53835: LIST
53836: LIST
53837: PUSH
53838: LD_VAR 0 1
53842: PUSH
53843: LD_VAR 0 2
53847: PUSH
53848: LD_INT 3
53850: PLUS
53851: PUSH
53852: LD_INT 0
53854: PUSH
53855: EMPTY
53856: LIST
53857: LIST
53858: LIST
53859: PUSH
53860: LD_VAR 0 1
53864: PUSH
53865: LD_INT 4
53867: PLUS
53868: PUSH
53869: LD_VAR 0 2
53873: PUSH
53874: LD_INT 4
53876: PLUS
53877: PUSH
53878: LD_INT 5
53880: PUSH
53881: EMPTY
53882: LIST
53883: LIST
53884: LIST
53885: PUSH
53886: EMPTY
53887: LIST
53888: LIST
53889: LIST
53890: LIST
53891: LIST
53892: ST_TO_ADDR
// end ; 2 :
53893: GO 54452
53895: LD_INT 2
53897: DOUBLE
53898: EQUAL
53899: IFTRUE 53903
53901: GO 54032
53903: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
53904: LD_ADDR_VAR 0 5
53908: PUSH
53909: LD_VAR 0 1
53913: PUSH
53914: LD_VAR 0 2
53918: PUSH
53919: LD_INT 3
53921: MINUS
53922: PUSH
53923: LD_INT 3
53925: PUSH
53926: EMPTY
53927: LIST
53928: LIST
53929: LIST
53930: PUSH
53931: LD_VAR 0 1
53935: PUSH
53936: LD_INT 4
53938: PLUS
53939: PUSH
53940: LD_VAR 0 2
53944: PUSH
53945: LD_INT 4
53947: PUSH
53948: EMPTY
53949: LIST
53950: LIST
53951: LIST
53952: PUSH
53953: LD_VAR 0 1
53957: PUSH
53958: LD_VAR 0 2
53962: PUSH
53963: LD_INT 4
53965: PLUS
53966: PUSH
53967: LD_INT 0
53969: PUSH
53970: EMPTY
53971: LIST
53972: LIST
53973: LIST
53974: PUSH
53975: LD_VAR 0 1
53979: PUSH
53980: LD_INT 3
53982: MINUS
53983: PUSH
53984: LD_VAR 0 2
53988: PUSH
53989: LD_INT 1
53991: PUSH
53992: EMPTY
53993: LIST
53994: LIST
53995: LIST
53996: PUSH
53997: LD_VAR 0 1
54001: PUSH
54002: LD_INT 4
54004: MINUS
54005: PUSH
54006: LD_VAR 0 2
54010: PUSH
54011: LD_INT 4
54013: MINUS
54014: PUSH
54015: LD_INT 2
54017: PUSH
54018: EMPTY
54019: LIST
54020: LIST
54021: LIST
54022: PUSH
54023: EMPTY
54024: LIST
54025: LIST
54026: LIST
54027: LIST
54028: LIST
54029: ST_TO_ADDR
// end ; 3 :
54030: GO 54452
54032: LD_INT 3
54034: DOUBLE
54035: EQUAL
54036: IFTRUE 54040
54038: GO 54173
54040: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
54041: LD_ADDR_VAR 0 5
54045: PUSH
54046: LD_VAR 0 1
54050: PUSH
54051: LD_INT 3
54053: PLUS
54054: PUSH
54055: LD_VAR 0 2
54059: PUSH
54060: LD_INT 4
54062: PUSH
54063: EMPTY
54064: LIST
54065: LIST
54066: LIST
54067: PUSH
54068: LD_VAR 0 1
54072: PUSH
54073: LD_INT 4
54075: PLUS
54076: PUSH
54077: LD_VAR 0 2
54081: PUSH
54082: LD_INT 4
54084: PLUS
54085: PUSH
54086: LD_INT 5
54088: PUSH
54089: EMPTY
54090: LIST
54091: LIST
54092: LIST
54093: PUSH
54094: LD_VAR 0 1
54098: PUSH
54099: LD_INT 4
54101: MINUS
54102: PUSH
54103: LD_VAR 0 2
54107: PUSH
54108: LD_INT 1
54110: PUSH
54111: EMPTY
54112: LIST
54113: LIST
54114: LIST
54115: PUSH
54116: LD_VAR 0 1
54120: PUSH
54121: LD_VAR 0 2
54125: PUSH
54126: LD_INT 4
54128: MINUS
54129: PUSH
54130: LD_INT 3
54132: PUSH
54133: EMPTY
54134: LIST
54135: LIST
54136: LIST
54137: PUSH
54138: LD_VAR 0 1
54142: PUSH
54143: LD_INT 3
54145: MINUS
54146: PUSH
54147: LD_VAR 0 2
54151: PUSH
54152: LD_INT 3
54154: MINUS
54155: PUSH
54156: LD_INT 2
54158: PUSH
54159: EMPTY
54160: LIST
54161: LIST
54162: LIST
54163: PUSH
54164: EMPTY
54165: LIST
54166: LIST
54167: LIST
54168: LIST
54169: LIST
54170: ST_TO_ADDR
// end ; 4 :
54171: GO 54452
54173: LD_INT 4
54175: DOUBLE
54176: EQUAL
54177: IFTRUE 54181
54179: GO 54314
54181: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
54182: LD_ADDR_VAR 0 5
54186: PUSH
54187: LD_VAR 0 1
54191: PUSH
54192: LD_VAR 0 2
54196: PUSH
54197: LD_INT 4
54199: PLUS
54200: PUSH
54201: LD_INT 0
54203: PUSH
54204: EMPTY
54205: LIST
54206: LIST
54207: LIST
54208: PUSH
54209: LD_VAR 0 1
54213: PUSH
54214: LD_INT 3
54216: PLUS
54217: PUSH
54218: LD_VAR 0 2
54222: PUSH
54223: LD_INT 3
54225: PLUS
54226: PUSH
54227: LD_INT 5
54229: PUSH
54230: EMPTY
54231: LIST
54232: LIST
54233: LIST
54234: PUSH
54235: LD_VAR 0 1
54239: PUSH
54240: LD_INT 4
54242: PLUS
54243: PUSH
54244: LD_VAR 0 2
54248: PUSH
54249: LD_INT 4
54251: PUSH
54252: EMPTY
54253: LIST
54254: LIST
54255: LIST
54256: PUSH
54257: LD_VAR 0 1
54261: PUSH
54262: LD_VAR 0 2
54266: PUSH
54267: LD_INT 3
54269: MINUS
54270: PUSH
54271: LD_INT 3
54273: PUSH
54274: EMPTY
54275: LIST
54276: LIST
54277: LIST
54278: PUSH
54279: LD_VAR 0 1
54283: PUSH
54284: LD_INT 4
54286: MINUS
54287: PUSH
54288: LD_VAR 0 2
54292: PUSH
54293: LD_INT 4
54295: MINUS
54296: PUSH
54297: LD_INT 2
54299: PUSH
54300: EMPTY
54301: LIST
54302: LIST
54303: LIST
54304: PUSH
54305: EMPTY
54306: LIST
54307: LIST
54308: LIST
54309: LIST
54310: LIST
54311: ST_TO_ADDR
// end ; 5 :
54312: GO 54452
54314: LD_INT 5
54316: DOUBLE
54317: EQUAL
54318: IFTRUE 54322
54320: GO 54451
54322: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
54323: LD_ADDR_VAR 0 5
54327: PUSH
54328: LD_VAR 0 1
54332: PUSH
54333: LD_INT 4
54335: MINUS
54336: PUSH
54337: LD_VAR 0 2
54341: PUSH
54342: LD_INT 1
54344: PUSH
54345: EMPTY
54346: LIST
54347: LIST
54348: LIST
54349: PUSH
54350: LD_VAR 0 1
54354: PUSH
54355: LD_VAR 0 2
54359: PUSH
54360: LD_INT 4
54362: MINUS
54363: PUSH
54364: LD_INT 3
54366: PUSH
54367: EMPTY
54368: LIST
54369: LIST
54370: LIST
54371: PUSH
54372: LD_VAR 0 1
54376: PUSH
54377: LD_INT 4
54379: PLUS
54380: PUSH
54381: LD_VAR 0 2
54385: PUSH
54386: LD_INT 4
54388: PLUS
54389: PUSH
54390: LD_INT 5
54392: PUSH
54393: EMPTY
54394: LIST
54395: LIST
54396: LIST
54397: PUSH
54398: LD_VAR 0 1
54402: PUSH
54403: LD_INT 3
54405: PLUS
54406: PUSH
54407: LD_VAR 0 2
54411: PUSH
54412: LD_INT 4
54414: PUSH
54415: EMPTY
54416: LIST
54417: LIST
54418: LIST
54419: PUSH
54420: LD_VAR 0 1
54424: PUSH
54425: LD_VAR 0 2
54429: PUSH
54430: LD_INT 3
54432: PLUS
54433: PUSH
54434: LD_INT 0
54436: PUSH
54437: EMPTY
54438: LIST
54439: LIST
54440: LIST
54441: PUSH
54442: EMPTY
54443: LIST
54444: LIST
54445: LIST
54446: LIST
54447: LIST
54448: ST_TO_ADDR
// end ; end ;
54449: GO 54452
54451: POP
// result := list ;
54452: LD_ADDR_VAR 0 4
54456: PUSH
54457: LD_VAR 0 5
54461: ST_TO_ADDR
// end ;
54462: LD_VAR 0 4
54466: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
54467: LD_INT 0
54469: PPUSH
54470: PPUSH
54471: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
54472: LD_VAR 0 1
54476: NOT
54477: PUSH
54478: LD_VAR 0 2
54482: PUSH
54483: LD_INT 1
54485: PUSH
54486: LD_INT 2
54488: PUSH
54489: LD_INT 3
54491: PUSH
54492: LD_INT 4
54494: PUSH
54495: EMPTY
54496: LIST
54497: LIST
54498: LIST
54499: LIST
54500: IN
54501: NOT
54502: OR
54503: IFFALSE 54507
// exit ;
54505: GO 54599
// tmp := [ ] ;
54507: LD_ADDR_VAR 0 5
54511: PUSH
54512: EMPTY
54513: ST_TO_ADDR
// for i in units do
54514: LD_ADDR_VAR 0 4
54518: PUSH
54519: LD_VAR 0 1
54523: PUSH
54524: FOR_IN
54525: IFFALSE 54568
// tmp := Insert ( tmp , tmp + 1 , GetSkill ( i , class ) ) ;
54527: LD_ADDR_VAR 0 5
54531: PUSH
54532: LD_VAR 0 5
54536: PPUSH
54537: LD_VAR 0 5
54541: PUSH
54542: LD_INT 1
54544: PLUS
54545: PPUSH
54546: LD_VAR 0 4
54550: PPUSH
54551: LD_VAR 0 2
54555: PPUSH
54556: CALL_OW 259
54560: PPUSH
54561: CALL_OW 2
54565: ST_TO_ADDR
54566: GO 54524
54568: POP
54569: POP
// if not tmp then
54570: LD_VAR 0 5
54574: NOT
54575: IFFALSE 54579
// exit ;
54577: GO 54599
// result := SortListByListDesc ( units , tmp ) ;
54579: LD_ADDR_VAR 0 3
54583: PUSH
54584: LD_VAR 0 1
54588: PPUSH
54589: LD_VAR 0 5
54593: PPUSH
54594: CALL_OW 77
54598: ST_TO_ADDR
// end ;
54599: LD_VAR 0 3
54603: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
54604: LD_INT 0
54606: PPUSH
54607: PPUSH
54608: PPUSH
// result := false ;
54609: LD_ADDR_VAR 0 3
54613: PUSH
54614: LD_INT 0
54616: ST_TO_ADDR
// x := GetX ( building ) ;
54617: LD_ADDR_VAR 0 4
54621: PUSH
54622: LD_VAR 0 2
54626: PPUSH
54627: CALL_OW 250
54631: ST_TO_ADDR
// y := GetY ( building ) ;
54632: LD_ADDR_VAR 0 5
54636: PUSH
54637: LD_VAR 0 2
54641: PPUSH
54642: CALL_OW 251
54646: ST_TO_ADDR
// if not building or not x or not y then
54647: LD_VAR 0 2
54651: NOT
54652: PUSH
54653: LD_VAR 0 4
54657: NOT
54658: OR
54659: PUSH
54660: LD_VAR 0 5
54664: NOT
54665: OR
54666: IFFALSE 54670
// exit ;
54668: GO 54762
// if GetTaskList ( unit ) then
54670: LD_VAR 0 1
54674: PPUSH
54675: CALL_OW 437
54679: IFFALSE 54762
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
54681: LD_STRING e
54683: PUSH
54684: LD_VAR 0 1
54688: PPUSH
54689: CALL_OW 437
54693: PUSH
54694: LD_INT 1
54696: ARRAY
54697: PUSH
54698: LD_INT 1
54700: ARRAY
54701: EQUAL
54702: PUSH
54703: LD_VAR 0 4
54707: PUSH
54708: LD_VAR 0 1
54712: PPUSH
54713: CALL_OW 437
54717: PUSH
54718: LD_INT 1
54720: ARRAY
54721: PUSH
54722: LD_INT 2
54724: ARRAY
54725: EQUAL
54726: AND
54727: PUSH
54728: LD_VAR 0 5
54732: PUSH
54733: LD_VAR 0 1
54737: PPUSH
54738: CALL_OW 437
54742: PUSH
54743: LD_INT 1
54745: ARRAY
54746: PUSH
54747: LD_INT 3
54749: ARRAY
54750: EQUAL
54751: AND
54752: IFFALSE 54762
// result := true end ;
54754: LD_ADDR_VAR 0 3
54758: PUSH
54759: LD_INT 1
54761: ST_TO_ADDR
// end ;
54762: LD_VAR 0 3
54766: RET
// export function UnitGoingToXY ( unit , x , y ) ; begin
54767: LD_INT 0
54769: PPUSH
// result := false ;
54770: LD_ADDR_VAR 0 4
54774: PUSH
54775: LD_INT 0
54777: ST_TO_ADDR
// if GetTaskList ( unit ) then
54778: LD_VAR 0 1
54782: PPUSH
54783: CALL_OW 437
54787: IFFALSE 54870
// begin if M = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
54789: LD_STRING M
54791: PUSH
54792: LD_VAR 0 1
54796: PPUSH
54797: CALL_OW 437
54801: PUSH
54802: LD_INT 1
54804: ARRAY
54805: PUSH
54806: LD_INT 1
54808: ARRAY
54809: EQUAL
54810: PUSH
54811: LD_VAR 0 2
54815: PUSH
54816: LD_VAR 0 1
54820: PPUSH
54821: CALL_OW 437
54825: PUSH
54826: LD_INT 1
54828: ARRAY
54829: PUSH
54830: LD_INT 2
54832: ARRAY
54833: EQUAL
54834: AND
54835: PUSH
54836: LD_VAR 0 3
54840: PUSH
54841: LD_VAR 0 1
54845: PPUSH
54846: CALL_OW 437
54850: PUSH
54851: LD_INT 1
54853: ARRAY
54854: PUSH
54855: LD_INT 3
54857: ARRAY
54858: EQUAL
54859: AND
54860: IFFALSE 54870
// result := true ;
54862: LD_ADDR_VAR 0 4
54866: PUSH
54867: LD_INT 1
54869: ST_TO_ADDR
// end ; end ;
54870: LD_VAR 0 4
54874: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
54875: LD_INT 0
54877: PPUSH
54878: PPUSH
54879: PPUSH
54880: PPUSH
// if not unit or not area then
54881: LD_VAR 0 1
54885: NOT
54886: PUSH
54887: LD_VAR 0 2
54891: NOT
54892: OR
54893: IFFALSE 54897
// exit ;
54895: GO 55061
// tmp := AreaToList ( area , i ) ;
54897: LD_ADDR_VAR 0 6
54901: PUSH
54902: LD_VAR 0 2
54906: PPUSH
54907: LD_VAR 0 5
54911: PPUSH
54912: CALL_OW 517
54916: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
54917: LD_ADDR_VAR 0 5
54921: PUSH
54922: DOUBLE
54923: LD_INT 1
54925: DEC
54926: ST_TO_ADDR
54927: LD_VAR 0 6
54931: PUSH
54932: LD_INT 1
54934: ARRAY
54935: PUSH
54936: FOR_TO
54937: IFFALSE 55059
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
54939: LD_ADDR_VAR 0 7
54943: PUSH
54944: LD_VAR 0 6
54948: PUSH
54949: LD_INT 1
54951: ARRAY
54952: PUSH
54953: LD_VAR 0 5
54957: ARRAY
54958: PUSH
54959: LD_VAR 0 6
54963: PUSH
54964: LD_INT 2
54966: ARRAY
54967: PUSH
54968: LD_VAR 0 5
54972: ARRAY
54973: PUSH
54974: EMPTY
54975: LIST
54976: LIST
54977: ST_TO_ADDR
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
54978: LD_VAR 0 7
54982: PUSH
54983: LD_INT 1
54985: ARRAY
54986: PPUSH
54987: LD_VAR 0 7
54991: PUSH
54992: LD_INT 2
54994: ARRAY
54995: PPUSH
54996: CALL_OW 428
55000: PUSH
55001: LD_INT 0
55003: EQUAL
55004: IFFALSE 55057
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
55006: LD_VAR 0 1
55010: PPUSH
55011: LD_VAR 0 7
55015: PUSH
55016: LD_INT 1
55018: ARRAY
55019: PPUSH
55020: LD_VAR 0 7
55024: PUSH
55025: LD_INT 2
55027: ARRAY
55028: PPUSH
55029: LD_VAR 0 3
55033: PPUSH
55034: CALL_OW 48
// result := IsPlaced ( unit ) ;
55038: LD_ADDR_VAR 0 4
55042: PUSH
55043: LD_VAR 0 1
55047: PPUSH
55048: CALL_OW 305
55052: ST_TO_ADDR
// exit ;
55053: POP
55054: POP
55055: GO 55061
// end ; end ;
55057: GO 54936
55059: POP
55060: POP
// end ;
55061: LD_VAR 0 4
55065: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
55066: LD_INT 0
55068: PPUSH
55069: PPUSH
55070: PPUSH
// if not side or side > 8 then
55071: LD_VAR 0 1
55075: NOT
55076: PUSH
55077: LD_VAR 0 1
55081: PUSH
55082: LD_INT 8
55084: GREATER
55085: OR
55086: IFFALSE 55090
// exit ;
55088: GO 55277
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
55090: LD_ADDR_VAR 0 4
55094: PUSH
55095: LD_INT 22
55097: PUSH
55098: LD_VAR 0 1
55102: PUSH
55103: EMPTY
55104: LIST
55105: LIST
55106: PUSH
55107: LD_INT 21
55109: PUSH
55110: LD_INT 3
55112: PUSH
55113: EMPTY
55114: LIST
55115: LIST
55116: PUSH
55117: EMPTY
55118: LIST
55119: LIST
55120: PPUSH
55121: CALL_OW 69
55125: ST_TO_ADDR
// if not tmp then
55126: LD_VAR 0 4
55130: NOT
55131: IFFALSE 55135
// exit ;
55133: GO 55277
// enable_addtolog := true ;
55135: LD_ADDR_OWVAR 81
55139: PUSH
55140: LD_INT 1
55142: ST_TO_ADDR
// AddToLog ( [ ) ;
55143: LD_STRING [
55145: PPUSH
55146: CALL_OW 561
// for i in tmp do
55150: LD_ADDR_VAR 0 3
55154: PUSH
55155: LD_VAR 0 4
55159: PUSH
55160: FOR_IN
55161: IFFALSE 55268
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
55163: LD_STRING [
55165: PUSH
55166: LD_VAR 0 3
55170: PPUSH
55171: CALL_OW 266
55175: STR
55176: PUSH
55177: LD_STRING , 
55179: STR
55180: PUSH
55181: LD_VAR 0 3
55185: PPUSH
55186: CALL_OW 250
55190: STR
55191: PUSH
55192: LD_STRING , 
55194: STR
55195: PUSH
55196: LD_VAR 0 3
55200: PPUSH
55201: CALL_OW 251
55205: STR
55206: PUSH
55207: LD_STRING , 
55209: STR
55210: PUSH
55211: LD_VAR 0 3
55215: PPUSH
55216: CALL_OW 254
55220: STR
55221: PUSH
55222: LD_STRING , 
55224: STR
55225: PUSH
55226: LD_VAR 0 3
55230: PPUSH
55231: LD_INT 1
55233: PPUSH
55234: CALL_OW 268
55238: STR
55239: PUSH
55240: LD_STRING , 
55242: STR
55243: PUSH
55244: LD_VAR 0 3
55248: PPUSH
55249: LD_INT 2
55251: PPUSH
55252: CALL_OW 268
55256: STR
55257: PUSH
55258: LD_STRING ],
55260: STR
55261: PPUSH
55262: CALL_OW 561
// end ;
55266: GO 55160
55268: POP
55269: POP
// AddToLog ( ]; ) ;
55270: LD_STRING ];
55272: PPUSH
55273: CALL_OW 561
// end ;
55277: LD_VAR 0 2
55281: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
55282: LD_INT 0
55284: PPUSH
55285: PPUSH
55286: PPUSH
55287: PPUSH
55288: PPUSH
// if not area or not rate or not max then
55289: LD_VAR 0 1
55293: NOT
55294: PUSH
55295: LD_VAR 0 2
55299: NOT
55300: OR
55301: PUSH
55302: LD_VAR 0 4
55306: NOT
55307: OR
55308: IFFALSE 55312
// exit ;
55310: GO 55504
// while 1 do
55312: LD_INT 1
55314: IFFALSE 55504
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
55316: LD_ADDR_VAR 0 9
55320: PUSH
55321: LD_VAR 0 1
55325: PPUSH
55326: LD_INT 1
55328: PPUSH
55329: CALL_OW 287
55333: PUSH
55334: LD_INT 10
55336: MUL
55337: ST_TO_ADDR
// r := rate / 10 ;
55338: LD_ADDR_VAR 0 7
55342: PUSH
55343: LD_VAR 0 2
55347: PUSH
55348: LD_INT 10
55350: DIVREAL
55351: ST_TO_ADDR
// time := 1 1$00 ;
55352: LD_ADDR_VAR 0 8
55356: PUSH
55357: LD_INT 2100
55359: ST_TO_ADDR
// if amount < min then
55360: LD_VAR 0 9
55364: PUSH
55365: LD_VAR 0 3
55369: LESS
55370: IFFALSE 55388
// r := r * 2 else
55372: LD_ADDR_VAR 0 7
55376: PUSH
55377: LD_VAR 0 7
55381: PUSH
55382: LD_INT 2
55384: MUL
55385: ST_TO_ADDR
55386: GO 55414
// if amount > max then
55388: LD_VAR 0 9
55392: PUSH
55393: LD_VAR 0 4
55397: GREATER
55398: IFFALSE 55414
// r := r / 2 ;
55400: LD_ADDR_VAR 0 7
55404: PUSH
55405: LD_VAR 0 7
55409: PUSH
55410: LD_INT 2
55412: DIVREAL
55413: ST_TO_ADDR
// time := time / r ;
55414: LD_ADDR_VAR 0 8
55418: PUSH
55419: LD_VAR 0 8
55423: PUSH
55424: LD_VAR 0 7
55428: DIVREAL
55429: ST_TO_ADDR
// if time < 0 then
55430: LD_VAR 0 8
55434: PUSH
55435: LD_INT 0
55437: LESS
55438: IFFALSE 55455
// time := time * - 1 ;
55440: LD_ADDR_VAR 0 8
55444: PUSH
55445: LD_VAR 0 8
55449: PUSH
55450: LD_INT 1
55452: NEG
55453: MUL
55454: ST_TO_ADDR
// wait ( time ) ;
55455: LD_VAR 0 8
55459: PPUSH
55460: CALL_OW 67
// wait ( rand ( 0 0$01 , 0 0$25 ) ) ;
55464: LD_INT 35
55466: PPUSH
55467: LD_INT 875
55469: PPUSH
55470: CALL_OW 12
55474: PPUSH
55475: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
55479: LD_INT 1
55481: PPUSH
55482: LD_INT 5
55484: PPUSH
55485: CALL_OW 12
55489: PPUSH
55490: LD_VAR 0 1
55494: PPUSH
55495: LD_INT 1
55497: PPUSH
55498: CALL_OW 55
// end ;
55502: GO 55312
// end ;
55504: LD_VAR 0 5
55508: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
55509: LD_INT 0
55511: PPUSH
55512: PPUSH
55513: PPUSH
55514: PPUSH
55515: PPUSH
55516: PPUSH
55517: PPUSH
55518: PPUSH
// if not turrets or not factories then
55519: LD_VAR 0 1
55523: NOT
55524: PUSH
55525: LD_VAR 0 2
55529: NOT
55530: OR
55531: IFFALSE 55535
// exit ;
55533: GO 55842
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
55535: LD_ADDR_VAR 0 10
55539: PUSH
55540: LD_INT 5
55542: PUSH
55543: LD_INT 6
55545: PUSH
55546: EMPTY
55547: LIST
55548: LIST
55549: PUSH
55550: LD_INT 2
55552: PUSH
55553: LD_INT 4
55555: PUSH
55556: EMPTY
55557: LIST
55558: LIST
55559: PUSH
55560: LD_INT 3
55562: PUSH
55563: LD_INT 5
55565: PUSH
55566: EMPTY
55567: LIST
55568: LIST
55569: PUSH
55570: EMPTY
55571: LIST
55572: LIST
55573: LIST
55574: PUSH
55575: LD_INT 24
55577: PUSH
55578: LD_INT 25
55580: PUSH
55581: EMPTY
55582: LIST
55583: LIST
55584: PUSH
55585: LD_INT 23
55587: PUSH
55588: LD_INT 27
55590: PUSH
55591: EMPTY
55592: LIST
55593: LIST
55594: PUSH
55595: EMPTY
55596: LIST
55597: LIST
55598: PUSH
55599: LD_INT 42
55601: PUSH
55602: LD_INT 43
55604: PUSH
55605: EMPTY
55606: LIST
55607: LIST
55608: PUSH
55609: LD_INT 44
55611: PUSH
55612: LD_INT 46
55614: PUSH
55615: EMPTY
55616: LIST
55617: LIST
55618: PUSH
55619: LD_INT 45
55621: PUSH
55622: LD_INT 47
55624: PUSH
55625: EMPTY
55626: LIST
55627: LIST
55628: PUSH
55629: EMPTY
55630: LIST
55631: LIST
55632: LIST
55633: PUSH
55634: EMPTY
55635: LIST
55636: LIST
55637: LIST
55638: ST_TO_ADDR
// result := [ ] ;
55639: LD_ADDR_VAR 0 3
55643: PUSH
55644: EMPTY
55645: ST_TO_ADDR
// for i in turrets do
55646: LD_ADDR_VAR 0 4
55650: PUSH
55651: LD_VAR 0 1
55655: PUSH
55656: FOR_IN
55657: IFFALSE 55840
// begin nat := GetNation ( i ) ;
55659: LD_ADDR_VAR 0 7
55663: PUSH
55664: LD_VAR 0 4
55668: PPUSH
55669: CALL_OW 248
55673: ST_TO_ADDR
// weapon := 0 ;
55674: LD_ADDR_VAR 0 8
55678: PUSH
55679: LD_INT 0
55681: ST_TO_ADDR
// if not nat then
55682: LD_VAR 0 7
55686: NOT
55687: IFFALSE 55691
// continue ;
55689: GO 55656
// for j in list [ nat ] do
55691: LD_ADDR_VAR 0 5
55695: PUSH
55696: LD_VAR 0 10
55700: PUSH
55701: LD_VAR 0 7
55705: ARRAY
55706: PUSH
55707: FOR_IN
55708: IFFALSE 55749
// if GetBWeapon ( i ) = j [ 1 ] then
55710: LD_VAR 0 4
55714: PPUSH
55715: CALL_OW 269
55719: PUSH
55720: LD_VAR 0 5
55724: PUSH
55725: LD_INT 1
55727: ARRAY
55728: EQUAL
55729: IFFALSE 55747
// begin weapon := j [ 2 ] ;
55731: LD_ADDR_VAR 0 8
55735: PUSH
55736: LD_VAR 0 5
55740: PUSH
55741: LD_INT 2
55743: ARRAY
55744: ST_TO_ADDR
// break ;
55745: GO 55749
// end ;
55747: GO 55707
55749: POP
55750: POP
// if not weapon then
55751: LD_VAR 0 8
55755: NOT
55756: IFFALSE 55760
// continue ;
55758: GO 55656
// for k in factories do
55760: LD_ADDR_VAR 0 6
55764: PUSH
55765: LD_VAR 0 2
55769: PUSH
55770: FOR_IN
55771: IFFALSE 55836
// begin weapons := AvailableWeaponList ( k ) ;
55773: LD_ADDR_VAR 0 9
55777: PUSH
55778: LD_VAR 0 6
55782: PPUSH
55783: CALL_OW 478
55787: ST_TO_ADDR
// if not weapons then
55788: LD_VAR 0 9
55792: NOT
55793: IFFALSE 55797
// continue ;
55795: GO 55770
// if weapon in weapons then
55797: LD_VAR 0 8
55801: PUSH
55802: LD_VAR 0 9
55806: IN
55807: IFFALSE 55834
// begin result := [ i , weapon ] ;
55809: LD_ADDR_VAR 0 3
55813: PUSH
55814: LD_VAR 0 4
55818: PUSH
55819: LD_VAR 0 8
55823: PUSH
55824: EMPTY
55825: LIST
55826: LIST
55827: ST_TO_ADDR
// exit ;
55828: POP
55829: POP
55830: POP
55831: POP
55832: GO 55842
// end ; end ;
55834: GO 55770
55836: POP
55837: POP
// end ;
55838: GO 55656
55840: POP
55841: POP
// end ;
55842: LD_VAR 0 3
55846: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
55847: LD_INT 0
55849: PPUSH
// if not side or side > 8 then
55850: LD_VAR 0 3
55854: NOT
55855: PUSH
55856: LD_VAR 0 3
55860: PUSH
55861: LD_INT 8
55863: GREATER
55864: OR
55865: IFFALSE 55869
// exit ;
55867: GO 55928
// if not range then
55869: LD_VAR 0 4
55873: NOT
55874: IFFALSE 55885
// range := - 12 ;
55876: LD_ADDR_VAR 0 4
55880: PUSH
55881: LD_INT 12
55883: NEG
55884: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
55885: LD_VAR 0 1
55889: PPUSH
55890: LD_VAR 0 2
55894: PPUSH
55895: LD_VAR 0 3
55899: PPUSH
55900: LD_VAR 0 4
55904: PPUSH
55905: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
55909: LD_VAR 0 1
55913: PPUSH
55914: LD_VAR 0 2
55918: PPUSH
55919: LD_VAR 0 3
55923: PPUSH
55924: CALL_OW 331
// end ;
55928: LD_VAR 0 5
55932: RET
// export function Video ( mode ) ; begin
55933: LD_INT 0
55935: PPUSH
// ingame_video = mode ;
55936: LD_ADDR_OWVAR 52
55940: PUSH
55941: LD_VAR 0 1
55945: ST_TO_ADDR
// interface_hidden = mode ;
55946: LD_ADDR_OWVAR 54
55950: PUSH
55951: LD_VAR 0 1
55955: ST_TO_ADDR
// end ;
55956: LD_VAR 0 2
55960: RET
// export function Join ( array , element ) ; begin
55961: LD_INT 0
55963: PPUSH
// result := Replace ( array , array + 1 , element ) ;
55964: LD_ADDR_VAR 0 3
55968: PUSH
55969: LD_VAR 0 1
55973: PPUSH
55974: LD_VAR 0 1
55978: PUSH
55979: LD_INT 1
55981: PLUS
55982: PPUSH
55983: LD_VAR 0 2
55987: PPUSH
55988: CALL_OW 1
55992: ST_TO_ADDR
// end ;
55993: LD_VAR 0 3
55997: RET
// export function JoinUnion ( array , element ) ; begin
55998: LD_INT 0
56000: PPUSH
// result := array union element ;
56001: LD_ADDR_VAR 0 3
56005: PUSH
56006: LD_VAR 0 1
56010: PUSH
56011: LD_VAR 0 2
56015: UNION
56016: ST_TO_ADDR
// end ;
56017: LD_VAR 0 3
56021: RET
// export function GetBehemoths ( side ) ; begin
56022: LD_INT 0
56024: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , 25 ] ] ) ;
56025: LD_ADDR_VAR 0 2
56029: PUSH
56030: LD_INT 22
56032: PUSH
56033: LD_VAR 0 1
56037: PUSH
56038: EMPTY
56039: LIST
56040: LIST
56041: PUSH
56042: LD_INT 31
56044: PUSH
56045: LD_INT 25
56047: PUSH
56048: EMPTY
56049: LIST
56050: LIST
56051: PUSH
56052: EMPTY
56053: LIST
56054: LIST
56055: PPUSH
56056: CALL_OW 69
56060: ST_TO_ADDR
// end ;
56061: LD_VAR 0 2
56065: RET
// export function Shuffle ( array ) ; var i , index ; begin
56066: LD_INT 0
56068: PPUSH
56069: PPUSH
56070: PPUSH
// result := [ ] ;
56071: LD_ADDR_VAR 0 2
56075: PUSH
56076: EMPTY
56077: ST_TO_ADDR
// if not array then
56078: LD_VAR 0 1
56082: NOT
56083: IFFALSE 56087
// exit ;
56085: GO 56186
// Randomize ;
56087: CALL_OW 10
// for i = array downto 1 do
56091: LD_ADDR_VAR 0 3
56095: PUSH
56096: DOUBLE
56097: LD_VAR 0 1
56101: INC
56102: ST_TO_ADDR
56103: LD_INT 1
56105: PUSH
56106: FOR_DOWNTO
56107: IFFALSE 56184
// begin index := rand ( 1 , array ) ;
56109: LD_ADDR_VAR 0 4
56113: PUSH
56114: LD_INT 1
56116: PPUSH
56117: LD_VAR 0 1
56121: PPUSH
56122: CALL_OW 12
56126: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
56127: LD_ADDR_VAR 0 2
56131: PUSH
56132: LD_VAR 0 2
56136: PPUSH
56137: LD_VAR 0 2
56141: PUSH
56142: LD_INT 1
56144: PLUS
56145: PPUSH
56146: LD_VAR 0 1
56150: PUSH
56151: LD_VAR 0 4
56155: ARRAY
56156: PPUSH
56157: CALL_OW 2
56161: ST_TO_ADDR
// array := Delete ( array , index ) ;
56162: LD_ADDR_VAR 0 1
56166: PUSH
56167: LD_VAR 0 1
56171: PPUSH
56172: LD_VAR 0 4
56176: PPUSH
56177: CALL_OW 3
56181: ST_TO_ADDR
// end ;
56182: GO 56106
56184: POP
56185: POP
// end ;
56186: LD_VAR 0 2
56190: RET
// export function GetBaseMaterials ( base ) ; begin
56191: LD_INT 0
56193: PPUSH
// result := [ 0 , 0 , 0 ] ;
56194: LD_ADDR_VAR 0 2
56198: PUSH
56199: LD_INT 0
56201: PUSH
56202: LD_INT 0
56204: PUSH
56205: LD_INT 0
56207: PUSH
56208: EMPTY
56209: LIST
56210: LIST
56211: LIST
56212: ST_TO_ADDR
// if not base then
56213: LD_VAR 0 1
56217: NOT
56218: IFFALSE 56222
// exit ;
56220: GO 56271
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
56222: LD_ADDR_VAR 0 2
56226: PUSH
56227: LD_VAR 0 1
56231: PPUSH
56232: LD_INT 1
56234: PPUSH
56235: CALL_OW 275
56239: PUSH
56240: LD_VAR 0 1
56244: PPUSH
56245: LD_INT 2
56247: PPUSH
56248: CALL_OW 275
56252: PUSH
56253: LD_VAR 0 1
56257: PPUSH
56258: LD_INT 3
56260: PPUSH
56261: CALL_OW 275
56265: PUSH
56266: EMPTY
56267: LIST
56268: LIST
56269: LIST
56270: ST_TO_ADDR
// end ;
56271: LD_VAR 0 2
56275: RET
// export function ShrinkArray ( array , size ) ; var i ; begin
56276: LD_INT 0
56278: PPUSH
56279: PPUSH
// result := array ;
56280: LD_ADDR_VAR 0 3
56284: PUSH
56285: LD_VAR 0 1
56289: ST_TO_ADDR
// if size > 0 then
56290: LD_VAR 0 2
56294: PUSH
56295: LD_INT 0
56297: GREATER
56298: IFFALSE 56344
// for i := array downto size do
56300: LD_ADDR_VAR 0 4
56304: PUSH
56305: DOUBLE
56306: LD_VAR 0 1
56310: INC
56311: ST_TO_ADDR
56312: LD_VAR 0 2
56316: PUSH
56317: FOR_DOWNTO
56318: IFFALSE 56342
// result := Delete ( result , result ) ;
56320: LD_ADDR_VAR 0 3
56324: PUSH
56325: LD_VAR 0 3
56329: PPUSH
56330: LD_VAR 0 3
56334: PPUSH
56335: CALL_OW 3
56339: ST_TO_ADDR
56340: GO 56317
56342: POP
56343: POP
// end ;
56344: LD_VAR 0 3
56348: RET
// export function ComExit ( unit ) ; var tmp ; begin
56349: LD_INT 0
56351: PPUSH
56352: PPUSH
// if not IsInUnit ( unit ) then
56353: LD_VAR 0 1
56357: PPUSH
56358: CALL_OW 310
56362: NOT
56363: IFFALSE 56367
// exit ;
56365: GO 56427
// tmp := IsInUnit ( unit ) ;
56367: LD_ADDR_VAR 0 3
56371: PUSH
56372: LD_VAR 0 1
56376: PPUSH
56377: CALL_OW 310
56381: ST_TO_ADDR
// if GetType ( tmp ) = unit_vehicle then
56382: LD_VAR 0 3
56386: PPUSH
56387: CALL_OW 247
56391: PUSH
56392: LD_INT 2
56394: EQUAL
56395: IFFALSE 56408
// ComExitVehicle ( unit ) else
56397: LD_VAR 0 1
56401: PPUSH
56402: CALL_OW 121
56406: GO 56417
// ComExitBuilding ( unit ) ;
56408: LD_VAR 0 1
56412: PPUSH
56413: CALL_OW 122
// result := tmp ;
56417: LD_ADDR_VAR 0 2
56421: PUSH
56422: LD_VAR 0 3
56426: ST_TO_ADDR
// end ;
56427: LD_VAR 0 2
56431: RET
// export function ComExitAll ( units ) ; var i ; begin
56432: LD_INT 0
56434: PPUSH
56435: PPUSH
// if not units then
56436: LD_VAR 0 1
56440: NOT
56441: IFFALSE 56445
// exit ;
56443: GO 56471
// for i in units do
56445: LD_ADDR_VAR 0 3
56449: PUSH
56450: LD_VAR 0 1
56454: PUSH
56455: FOR_IN
56456: IFFALSE 56469
// ComExit ( i ) ;
56458: LD_VAR 0 3
56462: PPUSH
56463: CALL 56349 0 1
56467: GO 56455
56469: POP
56470: POP
// end ;
56471: LD_VAR 0 2
56475: RET
// export function ResetHc ; begin
56476: LD_INT 0
56478: PPUSH
// InitHc ;
56479: CALL_OW 19
// hc_importance := 0 ;
56483: LD_ADDR_OWVAR 32
56487: PUSH
56488: LD_INT 0
56490: ST_TO_ADDR
// end ;
56491: LD_VAR 0 1
56495: RET
// export function PointBetweenXY ( x1 , y1 , x2 , y2 ) ; var _x , _y ; begin
56496: LD_INT 0
56498: PPUSH
56499: PPUSH
56500: PPUSH
// _x := ( x1 + x2 ) div 2 ;
56501: LD_ADDR_VAR 0 6
56505: PUSH
56506: LD_VAR 0 1
56510: PUSH
56511: LD_VAR 0 3
56515: PLUS
56516: PUSH
56517: LD_INT 2
56519: DIV
56520: ST_TO_ADDR
// if _x < 0 then
56521: LD_VAR 0 6
56525: PUSH
56526: LD_INT 0
56528: LESS
56529: IFFALSE 56546
// _x := _x * - 1 ;
56531: LD_ADDR_VAR 0 6
56535: PUSH
56536: LD_VAR 0 6
56540: PUSH
56541: LD_INT 1
56543: NEG
56544: MUL
56545: ST_TO_ADDR
// _y := ( y1 + y2 ) div 2 ;
56546: LD_ADDR_VAR 0 7
56550: PUSH
56551: LD_VAR 0 2
56555: PUSH
56556: LD_VAR 0 4
56560: PLUS
56561: PUSH
56562: LD_INT 2
56564: DIV
56565: ST_TO_ADDR
// if _y < 0 then
56566: LD_VAR 0 7
56570: PUSH
56571: LD_INT 0
56573: LESS
56574: IFFALSE 56591
// _y := _y * - 1 ;
56576: LD_ADDR_VAR 0 7
56580: PUSH
56581: LD_VAR 0 7
56585: PUSH
56586: LD_INT 1
56588: NEG
56589: MUL
56590: ST_TO_ADDR
// result := [ _x , _y ] ;
56591: LD_ADDR_VAR 0 5
56595: PUSH
56596: LD_VAR 0 6
56600: PUSH
56601: LD_VAR 0 7
56605: PUSH
56606: EMPTY
56607: LIST
56608: LIST
56609: ST_TO_ADDR
// end ;
56610: LD_VAR 0 5
56614: RET
// export function NotGoToAreaUnit ( unit , area , goAway ) ; var x , y , task ; begin
56615: LD_INT 0
56617: PPUSH
56618: PPUSH
56619: PPUSH
56620: PPUSH
// task := GetTaskList ( unit ) ;
56621: LD_ADDR_VAR 0 7
56625: PUSH
56626: LD_VAR 0 1
56630: PPUSH
56631: CALL_OW 437
56635: ST_TO_ADDR
// if not task and not IsInArea ( unit , area ) then
56636: LD_VAR 0 7
56640: NOT
56641: PUSH
56642: LD_VAR 0 1
56646: PPUSH
56647: LD_VAR 0 2
56651: PPUSH
56652: CALL_OW 308
56656: NOT
56657: AND
56658: IFFALSE 56662
// exit ;
56660: GO 56780
// if IsInArea ( unit , area ) then
56662: LD_VAR 0 1
56666: PPUSH
56667: LD_VAR 0 2
56671: PPUSH
56672: CALL_OW 308
56676: IFFALSE 56694
// begin ComMoveToArea ( unit , goAway ) ;
56678: LD_VAR 0 1
56682: PPUSH
56683: LD_VAR 0 3
56687: PPUSH
56688: CALL_OW 113
// exit ;
56692: GO 56780
// end ; if task [ 1 ] [ 1 ] <> M then
56694: LD_VAR 0 7
56698: PUSH
56699: LD_INT 1
56701: ARRAY
56702: PUSH
56703: LD_INT 1
56705: ARRAY
56706: PUSH
56707: LD_STRING M
56709: NONEQUAL
56710: IFFALSE 56714
// exit ;
56712: GO 56780
// x := task [ 1 ] [ 2 ] ;
56714: LD_ADDR_VAR 0 5
56718: PUSH
56719: LD_VAR 0 7
56723: PUSH
56724: LD_INT 1
56726: ARRAY
56727: PUSH
56728: LD_INT 2
56730: ARRAY
56731: ST_TO_ADDR
// y := task [ 1 ] [ 3 ] ;
56732: LD_ADDR_VAR 0 6
56736: PUSH
56737: LD_VAR 0 7
56741: PUSH
56742: LD_INT 1
56744: ARRAY
56745: PUSH
56746: LD_INT 3
56748: ARRAY
56749: ST_TO_ADDR
// if InArea ( x , y , area ) then
56750: LD_VAR 0 5
56754: PPUSH
56755: LD_VAR 0 6
56759: PPUSH
56760: LD_VAR 0 2
56764: PPUSH
56765: CALL_OW 309
56769: IFFALSE 56780
// ComStop ( unit ) ;
56771: LD_VAR 0 1
56775: PPUSH
56776: CALL_OW 141
// end ;
56780: LD_VAR 0 4
56784: RET
// export function Abs ( value ) ; begin
56785: LD_INT 0
56787: PPUSH
// result := value ;
56788: LD_ADDR_VAR 0 2
56792: PUSH
56793: LD_VAR 0 1
56797: ST_TO_ADDR
// if value < 0 then
56798: LD_VAR 0 1
56802: PUSH
56803: LD_INT 0
56805: LESS
56806: IFFALSE 56823
// result := value * - 1 ;
56808: LD_ADDR_VAR 0 2
56812: PUSH
56813: LD_VAR 0 1
56817: PUSH
56818: LD_INT 1
56820: NEG
56821: MUL
56822: ST_TO_ADDR
// end ;
56823: LD_VAR 0 2
56827: RET
// export function ComMoveToNearbyEntrance ( unit , building ) ; var x , _x , y , _y , d , r , i ; begin
56828: LD_INT 0
56830: PPUSH
56831: PPUSH
56832: PPUSH
56833: PPUSH
56834: PPUSH
56835: PPUSH
56836: PPUSH
56837: PPUSH
// if not unit or not building then
56838: LD_VAR 0 1
56842: NOT
56843: PUSH
56844: LD_VAR 0 2
56848: NOT
56849: OR
56850: IFFALSE 56854
// exit ;
56852: GO 57080
// x := GetX ( building ) ;
56854: LD_ADDR_VAR 0 4
56858: PUSH
56859: LD_VAR 0 2
56863: PPUSH
56864: CALL_OW 250
56868: ST_TO_ADDR
// y := GetY ( building ) ;
56869: LD_ADDR_VAR 0 6
56873: PUSH
56874: LD_VAR 0 2
56878: PPUSH
56879: CALL_OW 251
56883: ST_TO_ADDR
// d := GetDir ( building ) ;
56884: LD_ADDR_VAR 0 8
56888: PUSH
56889: LD_VAR 0 2
56893: PPUSH
56894: CALL_OW 254
56898: ST_TO_ADDR
// r := 4 ;
56899: LD_ADDR_VAR 0 9
56903: PUSH
56904: LD_INT 4
56906: ST_TO_ADDR
// for i := 1 to 5 do
56907: LD_ADDR_VAR 0 10
56911: PUSH
56912: DOUBLE
56913: LD_INT 1
56915: DEC
56916: ST_TO_ADDR
56917: LD_INT 5
56919: PUSH
56920: FOR_TO
56921: IFFALSE 57078
// begin _x := ShiftX ( x , d , r + i ) ;
56923: LD_ADDR_VAR 0 5
56927: PUSH
56928: LD_VAR 0 4
56932: PPUSH
56933: LD_VAR 0 8
56937: PPUSH
56938: LD_VAR 0 9
56942: PUSH
56943: LD_VAR 0 10
56947: PLUS
56948: PPUSH
56949: CALL_OW 272
56953: ST_TO_ADDR
// _y := ShiftY ( y , d , r + i ) ;
56954: LD_ADDR_VAR 0 7
56958: PUSH
56959: LD_VAR 0 6
56963: PPUSH
56964: LD_VAR 0 8
56968: PPUSH
56969: LD_VAR 0 9
56973: PUSH
56974: LD_VAR 0 10
56978: PLUS
56979: PPUSH
56980: CALL_OW 273
56984: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not GetType ( HexInfo ( _x , _y ) ) in [ unit_building , unit_vehicle ] then
56985: LD_VAR 0 5
56989: PPUSH
56990: LD_VAR 0 7
56994: PPUSH
56995: CALL_OW 488
56999: PUSH
57000: LD_VAR 0 5
57004: PPUSH
57005: LD_VAR 0 7
57009: PPUSH
57010: CALL_OW 428
57014: PPUSH
57015: CALL_OW 247
57019: PUSH
57020: LD_INT 3
57022: PUSH
57023: LD_INT 2
57025: PUSH
57026: EMPTY
57027: LIST
57028: LIST
57029: IN
57030: NOT
57031: AND
57032: IFFALSE 57076
// begin ComMoveXY ( unit , _x , _y ) ;
57034: LD_VAR 0 1
57038: PPUSH
57039: LD_VAR 0 5
57043: PPUSH
57044: LD_VAR 0 7
57048: PPUSH
57049: CALL_OW 111
// result := [ _x , _y ] ;
57053: LD_ADDR_VAR 0 3
57057: PUSH
57058: LD_VAR 0 5
57062: PUSH
57063: LD_VAR 0 7
57067: PUSH
57068: EMPTY
57069: LIST
57070: LIST
57071: ST_TO_ADDR
// exit ;
57072: POP
57073: POP
57074: GO 57080
// end ; end ;
57076: GO 56920
57078: POP
57079: POP
// end ;
57080: LD_VAR 0 3
57084: RET
// export function SideAttackedSide ( side1 , side2 ) ; var i , un ; begin
57085: LD_INT 0
57087: PPUSH
57088: PPUSH
57089: PPUSH
// result := 0 ;
57090: LD_ADDR_VAR 0 3
57094: PUSH
57095: LD_INT 0
57097: ST_TO_ADDR
// if side1 < 0 or side1 > 8 or side2 < 0 or side2 > 8 then
57098: LD_VAR 0 1
57102: PUSH
57103: LD_INT 0
57105: LESS
57106: PUSH
57107: LD_VAR 0 1
57111: PUSH
57112: LD_INT 8
57114: GREATER
57115: OR
57116: PUSH
57117: LD_VAR 0 2
57121: PUSH
57122: LD_INT 0
57124: LESS
57125: OR
57126: PUSH
57127: LD_VAR 0 2
57131: PUSH
57132: LD_INT 8
57134: GREATER
57135: OR
57136: IFFALSE 57140
// exit ;
57138: GO 57215
// for i in FilterAllUnits ( [ f_side , side2 ] ) do
57140: LD_ADDR_VAR 0 4
57144: PUSH
57145: LD_INT 22
57147: PUSH
57148: LD_VAR 0 2
57152: PUSH
57153: EMPTY
57154: LIST
57155: LIST
57156: PPUSH
57157: CALL_OW 69
57161: PUSH
57162: FOR_IN
57163: IFFALSE 57213
// begin un := UnitShoot ( i ) ;
57165: LD_ADDR_VAR 0 5
57169: PUSH
57170: LD_VAR 0 4
57174: PPUSH
57175: CALL_OW 504
57179: ST_TO_ADDR
// if GetSide ( un ) = side1 then
57180: LD_VAR 0 5
57184: PPUSH
57185: CALL_OW 255
57189: PUSH
57190: LD_VAR 0 1
57194: EQUAL
57195: IFFALSE 57211
// begin result := un ;
57197: LD_ADDR_VAR 0 3
57201: PUSH
57202: LD_VAR 0 5
57206: ST_TO_ADDR
// exit ;
57207: POP
57208: POP
57209: GO 57215
// end ; end ;
57211: GO 57162
57213: POP
57214: POP
// end ;
57215: LD_VAR 0 3
57219: RET
// export function GetCargoBay ( units ) ; begin
57220: LD_INT 0
57222: PPUSH
// result := UnitFilter ( units , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ) ;
57223: LD_ADDR_VAR 0 2
57227: PUSH
57228: LD_VAR 0 1
57232: PPUSH
57233: LD_INT 2
57235: PUSH
57236: LD_INT 34
57238: PUSH
57239: LD_INT 12
57241: PUSH
57242: EMPTY
57243: LIST
57244: LIST
57245: PUSH
57246: LD_INT 34
57248: PUSH
57249: LD_INT 51
57251: PUSH
57252: EMPTY
57253: LIST
57254: LIST
57255: PUSH
57256: LD_INT 34
57258: PUSH
57259: LD_INT 32
57261: PUSH
57262: EMPTY
57263: LIST
57264: LIST
57265: PUSH
57266: LD_INT 34
57268: PUSH
57269: LD_EXP 157
57273: PUSH
57274: EMPTY
57275: LIST
57276: LIST
57277: PUSH
57278: EMPTY
57279: LIST
57280: LIST
57281: LIST
57282: LIST
57283: LIST
57284: PPUSH
57285: CALL_OW 72
57289: ST_TO_ADDR
// end ;
57290: LD_VAR 0 2
57294: RET
// export function Negate ( value ) ; begin
57295: LD_INT 0
57297: PPUSH
// result := not value ;
57298: LD_ADDR_VAR 0 2
57302: PUSH
57303: LD_VAR 0 1
57307: NOT
57308: ST_TO_ADDR
// end ;
57309: LD_VAR 0 2
57313: RET
// export function Inc ( value ) ; begin
57314: LD_INT 0
57316: PPUSH
// result := value + 1 ;
57317: LD_ADDR_VAR 0 2
57321: PUSH
57322: LD_VAR 0 1
57326: PUSH
57327: LD_INT 1
57329: PLUS
57330: ST_TO_ADDR
// end ;
57331: LD_VAR 0 2
57335: RET
// export function Dec ( value ) ; begin
57336: LD_INT 0
57338: PPUSH
// result := value - 1 ;
57339: LD_ADDR_VAR 0 2
57343: PUSH
57344: LD_VAR 0 1
57348: PUSH
57349: LD_INT 1
57351: MINUS
57352: ST_TO_ADDR
// end ;
57353: LD_VAR 0 2
57357: RET
// export function GetDirFromHex ( x1 , y1 , x2 , y2 ) ; var i , _x , _y , tmp , distance , centerDist , centerPoint ; begin
57358: LD_INT 0
57360: PPUSH
57361: PPUSH
57362: PPUSH
57363: PPUSH
57364: PPUSH
57365: PPUSH
57366: PPUSH
57367: PPUSH
// if not ValidHex ( x1 , y1 ) or not ValidHex ( x2 , y2 ) then
57368: LD_VAR 0 1
57372: PPUSH
57373: LD_VAR 0 2
57377: PPUSH
57378: CALL_OW 488
57382: NOT
57383: PUSH
57384: LD_VAR 0 3
57388: PPUSH
57389: LD_VAR 0 4
57393: PPUSH
57394: CALL_OW 488
57398: NOT
57399: OR
57400: IFFALSE 57413
// begin result := - 1 ;
57402: LD_ADDR_VAR 0 5
57406: PUSH
57407: LD_INT 1
57409: NEG
57410: ST_TO_ADDR
// exit ;
57411: GO 57648
// end ; centerPoint := PointBetweenXY ( x1 , y1 , x2 , y2 ) ;
57413: LD_ADDR_VAR 0 12
57417: PUSH
57418: LD_VAR 0 1
57422: PPUSH
57423: LD_VAR 0 2
57427: PPUSH
57428: LD_VAR 0 3
57432: PPUSH
57433: LD_VAR 0 4
57437: PPUSH
57438: CALL 56496 0 4
57442: ST_TO_ADDR
// centerDist := GetDistXY ( x1 , y1 , centerPoint [ 1 ] , centerPoint [ 2 ] ) ;
57443: LD_ADDR_VAR 0 11
57447: PUSH
57448: LD_VAR 0 1
57452: PPUSH
57453: LD_VAR 0 2
57457: PPUSH
57458: LD_VAR 0 12
57462: PUSH
57463: LD_INT 1
57465: ARRAY
57466: PPUSH
57467: LD_VAR 0 12
57471: PUSH
57472: LD_INT 2
57474: ARRAY
57475: PPUSH
57476: CALL_OW 298
57480: ST_TO_ADDR
// distance := 9999 ;
57481: LD_ADDR_VAR 0 10
57485: PUSH
57486: LD_INT 9999
57488: ST_TO_ADDR
// for i := 0 to 5 do
57489: LD_ADDR_VAR 0 6
57493: PUSH
57494: DOUBLE
57495: LD_INT 0
57497: DEC
57498: ST_TO_ADDR
57499: LD_INT 5
57501: PUSH
57502: FOR_TO
57503: IFFALSE 57646
// begin _x := ShiftX ( x1 , i , centerDist ) ;
57505: LD_ADDR_VAR 0 7
57509: PUSH
57510: LD_VAR 0 1
57514: PPUSH
57515: LD_VAR 0 6
57519: PPUSH
57520: LD_VAR 0 11
57524: PPUSH
57525: CALL_OW 272
57529: ST_TO_ADDR
// _y := ShiftY ( y1 , i , centerDist ) ;
57530: LD_ADDR_VAR 0 8
57534: PUSH
57535: LD_VAR 0 2
57539: PPUSH
57540: LD_VAR 0 6
57544: PPUSH
57545: LD_VAR 0 11
57549: PPUSH
57550: CALL_OW 273
57554: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
57555: LD_VAR 0 7
57559: PPUSH
57560: LD_VAR 0 8
57564: PPUSH
57565: CALL_OW 488
57569: NOT
57570: IFFALSE 57574
// continue ;
57572: GO 57502
// tmp := GetDistXY ( centerPoint [ 1 ] , centerPoint [ 2 ] , _x , _y ) ;
57574: LD_ADDR_VAR 0 9
57578: PUSH
57579: LD_VAR 0 12
57583: PUSH
57584: LD_INT 1
57586: ARRAY
57587: PPUSH
57588: LD_VAR 0 12
57592: PUSH
57593: LD_INT 2
57595: ARRAY
57596: PPUSH
57597: LD_VAR 0 7
57601: PPUSH
57602: LD_VAR 0 8
57606: PPUSH
57607: CALL_OW 298
57611: ST_TO_ADDR
// if tmp < distance then
57612: LD_VAR 0 9
57616: PUSH
57617: LD_VAR 0 10
57621: LESS
57622: IFFALSE 57644
// begin result := i ;
57624: LD_ADDR_VAR 0 5
57628: PUSH
57629: LD_VAR 0 6
57633: ST_TO_ADDR
// distance := tmp ;
57634: LD_ADDR_VAR 0 10
57638: PUSH
57639: LD_VAR 0 9
57643: ST_TO_ADDR
// end ; end ;
57644: GO 57502
57646: POP
57647: POP
// end ;
57648: LD_VAR 0 5
57652: RET
// export function ComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
57653: LD_INT 0
57655: PPUSH
57656: PPUSH
// if not driver or not IsInUnit ( driver ) then
57657: LD_VAR 0 1
57661: NOT
57662: PUSH
57663: LD_VAR 0 1
57667: PPUSH
57668: CALL_OW 310
57672: NOT
57673: OR
57674: IFFALSE 57678
// exit ;
57676: GO 57768
// vehicle := IsInUnit ( driver ) ;
57678: LD_ADDR_VAR 0 3
57682: PUSH
57683: LD_VAR 0 1
57687: PPUSH
57688: CALL_OW 310
57692: ST_TO_ADDR
// SetTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
57693: LD_VAR 0 1
57697: PPUSH
57698: LD_STRING \
57700: PUSH
57701: LD_INT 0
57703: PUSH
57704: LD_INT 0
57706: PUSH
57707: LD_INT 0
57709: PUSH
57710: LD_INT 0
57712: PUSH
57713: LD_INT 0
57715: PUSH
57716: LD_INT 0
57718: PUSH
57719: EMPTY
57720: LIST
57721: LIST
57722: LIST
57723: LIST
57724: LIST
57725: LIST
57726: LIST
57727: PUSH
57728: LD_STRING E
57730: PUSH
57731: LD_INT 0
57733: PUSH
57734: LD_INT 0
57736: PUSH
57737: LD_VAR 0 3
57741: PUSH
57742: LD_INT 0
57744: PUSH
57745: LD_INT 0
57747: PUSH
57748: LD_INT 0
57750: PUSH
57751: EMPTY
57752: LIST
57753: LIST
57754: LIST
57755: LIST
57756: LIST
57757: LIST
57758: LIST
57759: PUSH
57760: EMPTY
57761: LIST
57762: LIST
57763: PPUSH
57764: CALL_OW 446
// end ;
57768: LD_VAR 0 2
57772: RET
// export function AddComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
57773: LD_INT 0
57775: PPUSH
57776: PPUSH
// if not driver or not IsInUnit ( driver ) then
57777: LD_VAR 0 1
57781: NOT
57782: PUSH
57783: LD_VAR 0 1
57787: PPUSH
57788: CALL_OW 310
57792: NOT
57793: OR
57794: IFFALSE 57798
// exit ;
57796: GO 57888
// vehicle := IsInUnit ( driver ) ;
57798: LD_ADDR_VAR 0 3
57802: PUSH
57803: LD_VAR 0 1
57807: PPUSH
57808: CALL_OW 310
57812: ST_TO_ADDR
// AddTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
57813: LD_VAR 0 1
57817: PPUSH
57818: LD_STRING \
57820: PUSH
57821: LD_INT 0
57823: PUSH
57824: LD_INT 0
57826: PUSH
57827: LD_INT 0
57829: PUSH
57830: LD_INT 0
57832: PUSH
57833: LD_INT 0
57835: PUSH
57836: LD_INT 0
57838: PUSH
57839: EMPTY
57840: LIST
57841: LIST
57842: LIST
57843: LIST
57844: LIST
57845: LIST
57846: LIST
57847: PUSH
57848: LD_STRING E
57850: PUSH
57851: LD_INT 0
57853: PUSH
57854: LD_INT 0
57856: PUSH
57857: LD_VAR 0 3
57861: PUSH
57862: LD_INT 0
57864: PUSH
57865: LD_INT 0
57867: PUSH
57868: LD_INT 0
57870: PUSH
57871: EMPTY
57872: LIST
57873: LIST
57874: LIST
57875: LIST
57876: LIST
57877: LIST
57878: LIST
57879: PUSH
57880: EMPTY
57881: LIST
57882: LIST
57883: PPUSH
57884: CALL_OW 447
// end ;
57888: LD_VAR 0 2
57892: RET
// export function SortByHealth ( units , asc ) ; var i , tmp ; begin
57893: LD_INT 0
57895: PPUSH
57896: PPUSH
57897: PPUSH
// tmp := [ ] ;
57898: LD_ADDR_VAR 0 5
57902: PUSH
57903: EMPTY
57904: ST_TO_ADDR
// for i in units do
57905: LD_ADDR_VAR 0 4
57909: PUSH
57910: LD_VAR 0 1
57914: PUSH
57915: FOR_IN
57916: IFFALSE 57954
// tmp := Insert ( tmp , tmp + 1 , GetLives ( i ) ) ;
57918: LD_ADDR_VAR 0 5
57922: PUSH
57923: LD_VAR 0 5
57927: PPUSH
57928: LD_VAR 0 5
57932: PUSH
57933: LD_INT 1
57935: PLUS
57936: PPUSH
57937: LD_VAR 0 4
57941: PPUSH
57942: CALL_OW 256
57946: PPUSH
57947: CALL_OW 2
57951: ST_TO_ADDR
57952: GO 57915
57954: POP
57955: POP
// if not tmp then
57956: LD_VAR 0 5
57960: NOT
57961: IFFALSE 57965
// exit ;
57963: GO 58013
// if asc then
57965: LD_VAR 0 2
57969: IFFALSE 57993
// result := SortListByListAsc ( units , tmp ) else
57971: LD_ADDR_VAR 0 3
57975: PUSH
57976: LD_VAR 0 1
57980: PPUSH
57981: LD_VAR 0 5
57985: PPUSH
57986: CALL_OW 76
57990: ST_TO_ADDR
57991: GO 58013
// result := SortListByListDesc ( units , tmp ) ;
57993: LD_ADDR_VAR 0 3
57997: PUSH
57998: LD_VAR 0 1
58002: PPUSH
58003: LD_VAR 0 5
58007: PPUSH
58008: CALL_OW 77
58012: ST_TO_ADDR
// end ;
58013: LD_VAR 0 3
58017: RET
// export function WantToRepairVehicle ( mech , vehicle ) ; var task ; begin
58018: LD_INT 0
58020: PPUSH
58021: PPUSH
// task := GetTaskList ( mech ) ;
58022: LD_ADDR_VAR 0 4
58026: PUSH
58027: LD_VAR 0 1
58031: PPUSH
58032: CALL_OW 437
58036: ST_TO_ADDR
// if not task then
58037: LD_VAR 0 4
58041: NOT
58042: IFFALSE 58046
// exit ;
58044: GO 58088
// result := task [ 1 ] [ 1 ] = r and task [ 1 ] [ 4 ] = vehicle ;
58046: LD_ADDR_VAR 0 3
58050: PUSH
58051: LD_VAR 0 4
58055: PUSH
58056: LD_INT 1
58058: ARRAY
58059: PUSH
58060: LD_INT 1
58062: ARRAY
58063: PUSH
58064: LD_STRING r
58066: EQUAL
58067: PUSH
58068: LD_VAR 0 4
58072: PUSH
58073: LD_INT 1
58075: ARRAY
58076: PUSH
58077: LD_INT 4
58079: ARRAY
58080: PUSH
58081: LD_VAR 0 2
58085: EQUAL
58086: AND
58087: ST_TO_ADDR
// end ;
58088: LD_VAR 0 3
58092: RET
// export function PlaceUnitXYD ( unit , x , y , d , mode ) ; begin
58093: LD_INT 0
58095: PPUSH
// SetDir ( unit , d ) ;
58096: LD_VAR 0 1
58100: PPUSH
58101: LD_VAR 0 4
58105: PPUSH
58106: CALL_OW 233
// PlaceUnitXY ( unit , x , y , mode ) ;
58110: LD_VAR 0 1
58114: PPUSH
58115: LD_VAR 0 2
58119: PPUSH
58120: LD_VAR 0 3
58124: PPUSH
58125: LD_VAR 0 5
58129: PPUSH
58130: CALL_OW 48
// end ;
58134: LD_VAR 0 6
58138: RET
// export function ToNaturalNumber ( number ) ; begin
58139: LD_INT 0
58141: PPUSH
// result := number div 1 ;
58142: LD_ADDR_VAR 0 2
58146: PUSH
58147: LD_VAR 0 1
58151: PUSH
58152: LD_INT 1
58154: DIV
58155: ST_TO_ADDR
// if number < 0 then
58156: LD_VAR 0 1
58160: PUSH
58161: LD_INT 0
58163: LESS
58164: IFFALSE 58174
// result := 0 ;
58166: LD_ADDR_VAR 0 2
58170: PUSH
58171: LD_INT 0
58173: ST_TO_ADDR
// end ;
58174: LD_VAR 0 2
58178: RET
// export function SortByClass ( units , class ) ; var un ; begin
58179: LD_INT 0
58181: PPUSH
58182: PPUSH
// if not units or not class then
58183: LD_VAR 0 1
58187: NOT
58188: PUSH
58189: LD_VAR 0 2
58193: NOT
58194: OR
58195: IFFALSE 58199
// exit ;
58197: GO 58294
// result := [ ] ;
58199: LD_ADDR_VAR 0 3
58203: PUSH
58204: EMPTY
58205: ST_TO_ADDR
// for un in units do
58206: LD_ADDR_VAR 0 4
58210: PUSH
58211: LD_VAR 0 1
58215: PUSH
58216: FOR_IN
58217: IFFALSE 58292
// if GetClass ( un ) = class then
58219: LD_VAR 0 4
58223: PPUSH
58224: CALL_OW 257
58228: PUSH
58229: LD_VAR 0 2
58233: EQUAL
58234: IFFALSE 58261
// result := Insert ( result , 1 , un ) else
58236: LD_ADDR_VAR 0 3
58240: PUSH
58241: LD_VAR 0 3
58245: PPUSH
58246: LD_INT 1
58248: PPUSH
58249: LD_VAR 0 4
58253: PPUSH
58254: CALL_OW 2
58258: ST_TO_ADDR
58259: GO 58290
// result := Replace ( result , result + 1 , un ) ;
58261: LD_ADDR_VAR 0 3
58265: PUSH
58266: LD_VAR 0 3
58270: PPUSH
58271: LD_VAR 0 3
58275: PUSH
58276: LD_INT 1
58278: PLUS
58279: PPUSH
58280: LD_VAR 0 4
58284: PPUSH
58285: CALL_OW 1
58289: ST_TO_ADDR
58290: GO 58216
58292: POP
58293: POP
// end ;
58294: LD_VAR 0 3
58298: RET
// export function GetCratesNearbyXY ( x , y , r ) ; var _x , _y , min_y , min_x , max_x , max_y ; begin
58299: LD_INT 0
58301: PPUSH
58302: PPUSH
58303: PPUSH
58304: PPUSH
58305: PPUSH
58306: PPUSH
58307: PPUSH
// result := [ ] ;
58308: LD_ADDR_VAR 0 4
58312: PUSH
58313: EMPTY
58314: ST_TO_ADDR
// if x - r < 0 then
58315: LD_VAR 0 1
58319: PUSH
58320: LD_VAR 0 3
58324: MINUS
58325: PUSH
58326: LD_INT 0
58328: LESS
58329: IFFALSE 58341
// min_x := 0 else
58331: LD_ADDR_VAR 0 8
58335: PUSH
58336: LD_INT 0
58338: ST_TO_ADDR
58339: GO 58357
// min_x := x - r ;
58341: LD_ADDR_VAR 0 8
58345: PUSH
58346: LD_VAR 0 1
58350: PUSH
58351: LD_VAR 0 3
58355: MINUS
58356: ST_TO_ADDR
// if y - r < 0 then
58357: LD_VAR 0 2
58361: PUSH
58362: LD_VAR 0 3
58366: MINUS
58367: PUSH
58368: LD_INT 0
58370: LESS
58371: IFFALSE 58383
// min_y := 0 else
58373: LD_ADDR_VAR 0 7
58377: PUSH
58378: LD_INT 0
58380: ST_TO_ADDR
58381: GO 58399
// min_y := y - r ;
58383: LD_ADDR_VAR 0 7
58387: PUSH
58388: LD_VAR 0 2
58392: PUSH
58393: LD_VAR 0 3
58397: MINUS
58398: ST_TO_ADDR
// max_x := x + r ;
58399: LD_ADDR_VAR 0 9
58403: PUSH
58404: LD_VAR 0 1
58408: PUSH
58409: LD_VAR 0 3
58413: PLUS
58414: ST_TO_ADDR
// max_y := y + r ;
58415: LD_ADDR_VAR 0 10
58419: PUSH
58420: LD_VAR 0 2
58424: PUSH
58425: LD_VAR 0 3
58429: PLUS
58430: ST_TO_ADDR
// for _x = min_x to max_x do
58431: LD_ADDR_VAR 0 5
58435: PUSH
58436: DOUBLE
58437: LD_VAR 0 8
58441: DEC
58442: ST_TO_ADDR
58443: LD_VAR 0 9
58447: PUSH
58448: FOR_TO
58449: IFFALSE 58550
// for _y = min_y to max_y do
58451: LD_ADDR_VAR 0 6
58455: PUSH
58456: DOUBLE
58457: LD_VAR 0 7
58461: DEC
58462: ST_TO_ADDR
58463: LD_VAR 0 10
58467: PUSH
58468: FOR_TO
58469: IFFALSE 58546
// begin if not ValidHex ( _x , _y ) then
58471: LD_VAR 0 5
58475: PPUSH
58476: LD_VAR 0 6
58480: PPUSH
58481: CALL_OW 488
58485: NOT
58486: IFFALSE 58490
// continue ;
58488: GO 58468
// if GetResourceTypeXY ( _x , _y ) then
58490: LD_VAR 0 5
58494: PPUSH
58495: LD_VAR 0 6
58499: PPUSH
58500: CALL_OW 283
58504: IFFALSE 58544
// result := Replace ( result , result + 1 , [ _x , _y ] ) ;
58506: LD_ADDR_VAR 0 4
58510: PUSH
58511: LD_VAR 0 4
58515: PPUSH
58516: LD_VAR 0 4
58520: PUSH
58521: LD_INT 1
58523: PLUS
58524: PPUSH
58525: LD_VAR 0 5
58529: PUSH
58530: LD_VAR 0 6
58534: PUSH
58535: EMPTY
58536: LIST
58537: LIST
58538: PPUSH
58539: CALL_OW 1
58543: ST_TO_ADDR
// end ;
58544: GO 58468
58546: POP
58547: POP
58548: GO 58448
58550: POP
58551: POP
// end ;
58552: LD_VAR 0 4
58556: RET
// export function AgressiveMove ( units , path ) ; var i , enemy , nearEnemy , cr , side , tag , ignoreCratesWeapon ; begin
58557: LD_INT 0
58559: PPUSH
58560: PPUSH
58561: PPUSH
58562: PPUSH
58563: PPUSH
58564: PPUSH
58565: PPUSH
58566: PPUSH
// if not units then
58567: LD_VAR 0 1
58571: NOT
58572: IFFALSE 58576
// exit ;
58574: GO 59001
// result := UnitFilter ( units , [ f_ok ] ) ;
58576: LD_ADDR_VAR 0 3
58580: PUSH
58581: LD_VAR 0 1
58585: PPUSH
58586: LD_INT 50
58588: PUSH
58589: EMPTY
58590: LIST
58591: PPUSH
58592: CALL_OW 72
58596: ST_TO_ADDR
// side := GetSide ( units [ 1 ] ) ;
58597: LD_ADDR_VAR 0 8
58601: PUSH
58602: LD_VAR 0 1
58606: PUSH
58607: LD_INT 1
58609: ARRAY
58610: PPUSH
58611: CALL_OW 255
58615: ST_TO_ADDR
// ignoreCratesWeapon := [ ar_selfpropelled_bomb , ar_bio_bomb ] ;
58616: LD_ADDR_VAR 0 10
58620: PUSH
58621: LD_INT 29
58623: PUSH
58624: LD_EXP 160
58628: PUSH
58629: EMPTY
58630: LIST
58631: LIST
58632: ST_TO_ADDR
// if not result then
58633: LD_VAR 0 3
58637: NOT
58638: IFFALSE 58642
// exit ;
58640: GO 59001
// enemy := FilterAllUnits ( [ f_enemy , side ] ) ;
58642: LD_ADDR_VAR 0 5
58646: PUSH
58647: LD_INT 81
58649: PUSH
58650: LD_VAR 0 8
58654: PUSH
58655: EMPTY
58656: LIST
58657: LIST
58658: PPUSH
58659: CALL_OW 69
58663: ST_TO_ADDR
// for i in result do
58664: LD_ADDR_VAR 0 4
58668: PUSH
58669: LD_VAR 0 3
58673: PUSH
58674: FOR_IN
58675: IFFALSE 58999
// begin tag := GetTag ( i ) + 1 ;
58677: LD_ADDR_VAR 0 9
58681: PUSH
58682: LD_VAR 0 4
58686: PPUSH
58687: CALL_OW 110
58691: PUSH
58692: LD_INT 1
58694: PLUS
58695: ST_TO_ADDR
// cr := GetCratesNearbyXY ( GetX ( i ) , GetY ( i ) , 6 ) ;
58696: LD_ADDR_VAR 0 7
58700: PUSH
58701: LD_VAR 0 4
58705: PPUSH
58706: CALL_OW 250
58710: PPUSH
58711: LD_VAR 0 4
58715: PPUSH
58716: CALL_OW 251
58720: PPUSH
58721: LD_INT 6
58723: PPUSH
58724: CALL 58299 0 3
58728: ST_TO_ADDR
// if cr and not GetWeapon ( i ) in ignoreCratesWeapon then
58729: LD_VAR 0 7
58733: PUSH
58734: LD_VAR 0 4
58738: PPUSH
58739: CALL_OW 264
58743: PUSH
58744: LD_VAR 0 10
58748: IN
58749: NOT
58750: AND
58751: IFFALSE 58790
// ComAttackPlace ( i , cr [ 1 ] [ 1 ] , cr [ 1 ] [ 2 ] ) else
58753: LD_VAR 0 4
58757: PPUSH
58758: LD_VAR 0 7
58762: PUSH
58763: LD_INT 1
58765: ARRAY
58766: PUSH
58767: LD_INT 1
58769: ARRAY
58770: PPUSH
58771: LD_VAR 0 7
58775: PUSH
58776: LD_INT 1
58778: ARRAY
58779: PUSH
58780: LD_INT 2
58782: ARRAY
58783: PPUSH
58784: CALL_OW 116
58788: GO 58997
// if path > tag then
58790: LD_VAR 0 2
58794: PUSH
58795: LD_VAR 0 9
58799: GREATER
58800: IFFALSE 58967
// begin nearEnemy := UnitFilter ( enemy , [ f_dist , i , 12 ] ) ;
58802: LD_ADDR_VAR 0 6
58806: PUSH
58807: LD_VAR 0 5
58811: PPUSH
58812: LD_INT 91
58814: PUSH
58815: LD_VAR 0 4
58819: PUSH
58820: LD_INT 12
58822: PUSH
58823: EMPTY
58824: LIST
58825: LIST
58826: LIST
58827: PPUSH
58828: CALL_OW 72
58832: ST_TO_ADDR
// if nearEnemy then
58833: LD_VAR 0 6
58837: IFFALSE 58865
// ComAttackUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) else
58839: LD_VAR 0 4
58843: PPUSH
58844: LD_VAR 0 6
58848: PPUSH
58849: LD_VAR 0 4
58853: PPUSH
58854: CALL_OW 74
58858: PPUSH
58859: CALL_OW 115
58863: GO 58965
// if GetDistUnitXY ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) > 6 then
58865: LD_VAR 0 4
58869: PPUSH
58870: LD_VAR 0 2
58874: PUSH
58875: LD_VAR 0 9
58879: ARRAY
58880: PUSH
58881: LD_INT 1
58883: ARRAY
58884: PPUSH
58885: LD_VAR 0 2
58889: PUSH
58890: LD_VAR 0 9
58894: ARRAY
58895: PUSH
58896: LD_INT 2
58898: ARRAY
58899: PPUSH
58900: CALL_OW 297
58904: PUSH
58905: LD_INT 6
58907: GREATER
58908: IFFALSE 58951
// ComAgressiveMove ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) else
58910: LD_VAR 0 4
58914: PPUSH
58915: LD_VAR 0 2
58919: PUSH
58920: LD_VAR 0 9
58924: ARRAY
58925: PUSH
58926: LD_INT 1
58928: ARRAY
58929: PPUSH
58930: LD_VAR 0 2
58934: PUSH
58935: LD_VAR 0 9
58939: ARRAY
58940: PUSH
58941: LD_INT 2
58943: ARRAY
58944: PPUSH
58945: CALL_OW 114
58949: GO 58965
// SetTag ( i , tag ) ;
58951: LD_VAR 0 4
58955: PPUSH
58956: LD_VAR 0 9
58960: PPUSH
58961: CALL_OW 109
// end else
58965: GO 58997
// if enemy then
58967: LD_VAR 0 5
58971: IFFALSE 58997
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
58973: LD_VAR 0 4
58977: PPUSH
58978: LD_VAR 0 5
58982: PPUSH
58983: LD_VAR 0 4
58987: PPUSH
58988: CALL_OW 74
58992: PPUSH
58993: CALL_OW 115
// end ;
58997: GO 58674
58999: POP
59000: POP
// end ;
59001: LD_VAR 0 3
59005: RET
// export function ComLookAtDir ( unit , direction ) ; var x , y ; begin
59006: LD_INT 0
59008: PPUSH
59009: PPUSH
59010: PPUSH
// if not unit or IsInUnit ( unit ) then
59011: LD_VAR 0 1
59015: NOT
59016: PUSH
59017: LD_VAR 0 1
59021: PPUSH
59022: CALL_OW 310
59026: OR
59027: IFFALSE 59031
// exit ;
59029: GO 59122
// x := ShiftX ( GetX ( unit ) , direction , 1 ) ;
59031: LD_ADDR_VAR 0 4
59035: PUSH
59036: LD_VAR 0 1
59040: PPUSH
59041: CALL_OW 250
59045: PPUSH
59046: LD_VAR 0 2
59050: PPUSH
59051: LD_INT 1
59053: PPUSH
59054: CALL_OW 272
59058: ST_TO_ADDR
// y := ShiftY ( GetY ( unit ) , direction , 1 ) ;
59059: LD_ADDR_VAR 0 5
59063: PUSH
59064: LD_VAR 0 1
59068: PPUSH
59069: CALL_OW 251
59073: PPUSH
59074: LD_VAR 0 2
59078: PPUSH
59079: LD_INT 1
59081: PPUSH
59082: CALL_OW 273
59086: ST_TO_ADDR
// if ValidHex ( x , y ) then
59087: LD_VAR 0 4
59091: PPUSH
59092: LD_VAR 0 5
59096: PPUSH
59097: CALL_OW 488
59101: IFFALSE 59122
// ComTurnXY ( unit , x , y ) ;
59103: LD_VAR 0 1
59107: PPUSH
59108: LD_VAR 0 4
59112: PPUSH
59113: LD_VAR 0 5
59117: PPUSH
59118: CALL_OW 118
// end ;
59122: LD_VAR 0 3
59126: RET
// export function SeeUnits ( side , units ) ; var i ; begin
59127: LD_INT 0
59129: PPUSH
59130: PPUSH
// result := false ;
59131: LD_ADDR_VAR 0 3
59135: PUSH
59136: LD_INT 0
59138: ST_TO_ADDR
// if not units then
59139: LD_VAR 0 2
59143: NOT
59144: IFFALSE 59148
// exit ;
59146: GO 59193
// for i in units do
59148: LD_ADDR_VAR 0 4
59152: PUSH
59153: LD_VAR 0 2
59157: PUSH
59158: FOR_IN
59159: IFFALSE 59191
// if See ( side , i ) then
59161: LD_VAR 0 1
59165: PPUSH
59166: LD_VAR 0 4
59170: PPUSH
59171: CALL_OW 292
59175: IFFALSE 59189
// begin result := true ;
59177: LD_ADDR_VAR 0 3
59181: PUSH
59182: LD_INT 1
59184: ST_TO_ADDR
// exit ;
59185: POP
59186: POP
59187: GO 59193
// end ;
59189: GO 59158
59191: POP
59192: POP
// end ;
59193: LD_VAR 0 3
59197: RET
// export function GetNearestPoint ( unit , points ) ; var i , dist , tmpDist ; begin
59198: LD_INT 0
59200: PPUSH
59201: PPUSH
59202: PPUSH
59203: PPUSH
// if not unit or not points then
59204: LD_VAR 0 1
59208: NOT
59209: PUSH
59210: LD_VAR 0 2
59214: NOT
59215: OR
59216: IFFALSE 59220
// exit ;
59218: GO 59310
// dist := 99999 ;
59220: LD_ADDR_VAR 0 5
59224: PUSH
59225: LD_INT 99999
59227: ST_TO_ADDR
// for i in points do
59228: LD_ADDR_VAR 0 4
59232: PUSH
59233: LD_VAR 0 2
59237: PUSH
59238: FOR_IN
59239: IFFALSE 59308
// begin tmpDist := GetDistUnitXY ( unit , i [ 1 ] , i [ 2 ] ) ;
59241: LD_ADDR_VAR 0 6
59245: PUSH
59246: LD_VAR 0 1
59250: PPUSH
59251: LD_VAR 0 4
59255: PUSH
59256: LD_INT 1
59258: ARRAY
59259: PPUSH
59260: LD_VAR 0 4
59264: PUSH
59265: LD_INT 2
59267: ARRAY
59268: PPUSH
59269: CALL_OW 297
59273: ST_TO_ADDR
// if tmpDist < dist then
59274: LD_VAR 0 6
59278: PUSH
59279: LD_VAR 0 5
59283: LESS
59284: IFFALSE 59306
// begin result := i ;
59286: LD_ADDR_VAR 0 3
59290: PUSH
59291: LD_VAR 0 4
59295: ST_TO_ADDR
// dist := tmpDist ;
59296: LD_ADDR_VAR 0 5
59300: PUSH
59301: LD_VAR 0 6
59305: ST_TO_ADDR
// end ; end ;
59306: GO 59238
59308: POP
59309: POP
// end ; end_of_file
59310: LD_VAR 0 3
59314: RET
// export function SOS_UnitDestroyed ( un ) ; var i , eff , side ; begin
59315: LD_INT 0
59317: PPUSH
59318: PPUSH
59319: PPUSH
59320: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
59321: LD_VAR 0 1
59325: PPUSH
59326: CALL_OW 264
59330: PUSH
59331: LD_EXP 160
59335: EQUAL
59336: IFFALSE 59408
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
59338: LD_INT 68
59340: PPUSH
59341: LD_VAR 0 1
59345: PPUSH
59346: CALL_OW 255
59350: PPUSH
59351: CALL_OW 321
59355: PUSH
59356: LD_INT 2
59358: EQUAL
59359: IFFALSE 59371
// eff := 70 else
59361: LD_ADDR_VAR 0 4
59365: PUSH
59366: LD_INT 70
59368: ST_TO_ADDR
59369: GO 59379
// eff := 30 ;
59371: LD_ADDR_VAR 0 4
59375: PUSH
59376: LD_INT 30
59378: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
59379: LD_VAR 0 1
59383: PPUSH
59384: CALL_OW 250
59388: PPUSH
59389: LD_VAR 0 1
59393: PPUSH
59394: CALL_OW 251
59398: PPUSH
59399: LD_VAR 0 4
59403: PPUSH
59404: CALL_OW 495
// end ; end ;
59408: LD_VAR 0 2
59412: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
59413: LD_INT 0
59415: PPUSH
// end ;
59416: LD_VAR 0 4
59420: RET
// export function SOS_Command ( cmd ) ; begin
59421: LD_INT 0
59423: PPUSH
// end ;
59424: LD_VAR 0 2
59428: RET
// export function SOS_CommandUnitXY ( cmd , un , target , x , y ) ; begin
59429: LD_INT 0
59431: PPUSH
// end ;
59432: LD_VAR 0 6
59436: RET
// export function SOS_VehicleConstructed ( vehicle , factory ) ; var driver ; begin
59437: LD_INT 0
59439: PPUSH
59440: PPUSH
// if not vehicle or not factory then
59441: LD_VAR 0 1
59445: NOT
59446: PUSH
59447: LD_VAR 0 2
59451: NOT
59452: OR
59453: IFFALSE 59457
// exit ;
59455: GO 59688
// if factoryWaypoints >= factory then
59457: LD_EXP 87
59461: PUSH
59462: LD_VAR 0 2
59466: GREATEREQUAL
59467: IFFALSE 59688
// if factoryWaypoints [ factory ] then
59469: LD_EXP 87
59473: PUSH
59474: LD_VAR 0 2
59478: ARRAY
59479: IFFALSE 59688
// begin if GetControl ( vehicle ) = control_manual then
59481: LD_VAR 0 1
59485: PPUSH
59486: CALL_OW 263
59490: PUSH
59491: LD_INT 1
59493: EQUAL
59494: IFFALSE 59575
// begin driver := IsDrivenBy ( vehicle ) ;
59496: LD_ADDR_VAR 0 4
59500: PUSH
59501: LD_VAR 0 1
59505: PPUSH
59506: CALL_OW 311
59510: ST_TO_ADDR
// AddComMoveXY ( driver , factoryWaypoints [ factory ] [ 1 ] , factoryWaypoints [ factory ] [ 2 ] ) ;
59511: LD_VAR 0 4
59515: PPUSH
59516: LD_EXP 87
59520: PUSH
59521: LD_VAR 0 2
59525: ARRAY
59526: PUSH
59527: LD_INT 1
59529: ARRAY
59530: PPUSH
59531: LD_EXP 87
59535: PUSH
59536: LD_VAR 0 2
59540: ARRAY
59541: PUSH
59542: LD_INT 2
59544: ARRAY
59545: PPUSH
59546: CALL_OW 171
// AddComExitVehicle ( driver ) ;
59550: LD_VAR 0 4
59554: PPUSH
59555: CALL_OW 181
// AddComEnterUnit ( driver , factory ) ;
59559: LD_VAR 0 4
59563: PPUSH
59564: LD_VAR 0 2
59568: PPUSH
59569: CALL_OW 180
// end else
59573: GO 59688
// if GetControl ( vehicle ) = control_remote then
59575: LD_VAR 0 1
59579: PPUSH
59580: CALL_OW 263
59584: PUSH
59585: LD_INT 2
59587: EQUAL
59588: IFFALSE 59649
// begin wait ( 0 0$2 ) ;
59590: LD_INT 70
59592: PPUSH
59593: CALL_OW 67
// if Connect ( vehicle ) then
59597: LD_VAR 0 1
59601: PPUSH
59602: CALL 27181 0 1
59606: IFFALSE 59647
// AddComMoveXY ( vehicle , factoryWaypoints [ factory ] [ 1 ] , factoryWaypoints [ factory ] [ 2 ] ) ;
59608: LD_VAR 0 1
59612: PPUSH
59613: LD_EXP 87
59617: PUSH
59618: LD_VAR 0 2
59622: ARRAY
59623: PUSH
59624: LD_INT 1
59626: ARRAY
59627: PPUSH
59628: LD_EXP 87
59632: PUSH
59633: LD_VAR 0 2
59637: ARRAY
59638: PUSH
59639: LD_INT 2
59641: ARRAY
59642: PPUSH
59643: CALL_OW 171
// end else
59647: GO 59688
// AddComMoveXY ( vehicle , factoryWaypoints [ factory ] [ 1 ] , factoryWaypoints [ factory ] [ 2 ] ) ;
59649: LD_VAR 0 1
59653: PPUSH
59654: LD_EXP 87
59658: PUSH
59659: LD_VAR 0 2
59663: ARRAY
59664: PUSH
59665: LD_INT 1
59667: ARRAY
59668: PPUSH
59669: LD_EXP 87
59673: PUSH
59674: LD_VAR 0 2
59678: ARRAY
59679: PUSH
59680: LD_INT 2
59682: ARRAY
59683: PPUSH
59684: CALL_OW 171
// end ; end ;
59688: LD_VAR 0 3
59692: RET
// export function SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; begin
59693: LD_INT 0
59695: PPUSH
// if cmd = 250 and GetWeapon ( unit ) = ar_miner then
59696: LD_VAR 0 1
59700: PUSH
59701: LD_INT 250
59703: EQUAL
59704: PUSH
59705: LD_VAR 0 2
59709: PPUSH
59710: CALL_OW 264
59714: PUSH
59715: LD_EXP 163
59719: EQUAL
59720: AND
59721: IFFALSE 59742
// MinerPlaceMine ( unit , x , y ) ;
59723: LD_VAR 0 2
59727: PPUSH
59728: LD_VAR 0 4
59732: PPUSH
59733: LD_VAR 0 5
59737: PPUSH
59738: CALL 62470 0 3
// if cmd = 251 and GetWeapon ( unit ) = ar_miner then
59742: LD_VAR 0 1
59746: PUSH
59747: LD_INT 251
59749: EQUAL
59750: PUSH
59751: LD_VAR 0 2
59755: PPUSH
59756: CALL_OW 264
59760: PUSH
59761: LD_EXP 163
59765: EQUAL
59766: AND
59767: IFFALSE 59788
// MinerDetonateMine ( unit , x , y ) ;
59769: LD_VAR 0 2
59773: PPUSH
59774: LD_VAR 0 4
59778: PPUSH
59779: LD_VAR 0 5
59783: PPUSH
59784: CALL 62747 0 3
// if cmd = 252 and GetWeapon ( unit ) = ar_miner then
59788: LD_VAR 0 1
59792: PUSH
59793: LD_INT 252
59795: EQUAL
59796: PUSH
59797: LD_VAR 0 2
59801: PPUSH
59802: CALL_OW 264
59806: PUSH
59807: LD_EXP 163
59811: EQUAL
59812: AND
59813: IFFALSE 59834
// MinerCreateMinefield ( unit , x , y ) ;
59815: LD_VAR 0 2
59819: PPUSH
59820: LD_VAR 0 4
59824: PPUSH
59825: LD_VAR 0 5
59829: PPUSH
59830: CALL 63164 0 3
// if cmd = 253 and GetClass ( unit ) = class_sniper then
59834: LD_VAR 0 1
59838: PUSH
59839: LD_INT 253
59841: EQUAL
59842: PUSH
59843: LD_VAR 0 2
59847: PPUSH
59848: CALL_OW 257
59852: PUSH
59853: LD_INT 5
59855: EQUAL
59856: AND
59857: IFFALSE 59878
// ComBinocular ( unit , x , y ) ;
59859: LD_VAR 0 2
59863: PPUSH
59864: LD_VAR 0 4
59868: PPUSH
59869: LD_VAR 0 5
59873: PPUSH
59874: CALL 63535 0 3
// if cmd = 254 and GetWeapon ( unit ) = us_hack and GetControl ( selectedUnit ) = control_computer then
59878: LD_VAR 0 1
59882: PUSH
59883: LD_INT 254
59885: EQUAL
59886: PUSH
59887: LD_VAR 0 2
59891: PPUSH
59892: CALL_OW 264
59896: PUSH
59897: LD_EXP 158
59901: EQUAL
59902: AND
59903: PUSH
59904: LD_VAR 0 3
59908: PPUSH
59909: CALL_OW 263
59913: PUSH
59914: LD_INT 3
59916: EQUAL
59917: AND
59918: IFFALSE 59934
// HackDestroyVehicle ( unit , selectedUnit ) ;
59920: LD_VAR 0 2
59924: PPUSH
59925: LD_VAR 0 3
59929: PPUSH
59930: CALL 61830 0 2
// if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
59934: LD_VAR 0 1
59938: PUSH
59939: LD_INT 255
59941: EQUAL
59942: PUSH
59943: LD_VAR 0 2
59947: PPUSH
59948: CALL_OW 264
59952: PUSH
59953: LD_INT 14
59955: PUSH
59956: LD_INT 53
59958: PUSH
59959: EMPTY
59960: LIST
59961: LIST
59962: IN
59963: AND
59964: PUSH
59965: LD_VAR 0 4
59969: PPUSH
59970: LD_VAR 0 5
59974: PPUSH
59975: CALL_OW 488
59979: AND
59980: IFFALSE 60004
// CutTreeXYR ( unit , x , y , 12 ) ;
59982: LD_VAR 0 2
59986: PPUSH
59987: LD_VAR 0 4
59991: PPUSH
59992: LD_VAR 0 5
59996: PPUSH
59997: LD_INT 12
59999: PPUSH
60000: CALL 60396 0 4
// if cmd = 256 then
60004: LD_VAR 0 1
60008: PUSH
60009: LD_INT 256
60011: EQUAL
60012: IFFALSE 60033
// SetFactoryWaypoint ( unit , x , y ) ;
60014: LD_VAR 0 2
60018: PPUSH
60019: LD_VAR 0 4
60023: PPUSH
60024: LD_VAR 0 5
60028: PPUSH
60029: CALL 60038 0 3
// end ;
60033: LD_VAR 0 6
60037: RET
// export factoryWaypoints ; export function SetFactoryWaypoint ( factory , x , y ) ; var i ; begin
60038: LD_INT 0
60040: PPUSH
60041: PPUSH
// if not factory or not ValidHex ( x , y ) or ( GetBType ( factory ) <> b_factory and not GetType ( factory ) = unit_human ) then
60042: LD_VAR 0 1
60046: NOT
60047: PUSH
60048: LD_VAR 0 2
60052: PPUSH
60053: LD_VAR 0 3
60057: PPUSH
60058: CALL_OW 488
60062: NOT
60063: OR
60064: PUSH
60065: LD_VAR 0 1
60069: PPUSH
60070: CALL_OW 266
60074: PUSH
60075: LD_INT 3
60077: NONEQUAL
60078: PUSH
60079: LD_VAR 0 1
60083: PPUSH
60084: CALL_OW 247
60088: PUSH
60089: LD_INT 1
60091: EQUAL
60092: NOT
60093: AND
60094: OR
60095: IFFALSE 60099
// exit ;
60097: GO 60248
// if GetType ( factory ) = unit_human then
60099: LD_VAR 0 1
60103: PPUSH
60104: CALL_OW 247
60108: PUSH
60109: LD_INT 1
60111: EQUAL
60112: IFFALSE 60129
// factory := IsInUnit ( factory ) ;
60114: LD_ADDR_VAR 0 1
60118: PUSH
60119: LD_VAR 0 1
60123: PPUSH
60124: CALL_OW 310
60128: ST_TO_ADDR
// if GetBType ( factory ) <> b_factory then
60129: LD_VAR 0 1
60133: PPUSH
60134: CALL_OW 266
60138: PUSH
60139: LD_INT 3
60141: NONEQUAL
60142: IFFALSE 60146
// exit ;
60144: GO 60248
// if HexInfo ( x , y ) = factory then
60146: LD_VAR 0 2
60150: PPUSH
60151: LD_VAR 0 3
60155: PPUSH
60156: CALL_OW 428
60160: PUSH
60161: LD_VAR 0 1
60165: EQUAL
60166: IFFALSE 60193
// factoryWaypoints := Replace ( factoryWaypoints , factory , 0 ) else
60168: LD_ADDR_EXP 87
60172: PUSH
60173: LD_EXP 87
60177: PPUSH
60178: LD_VAR 0 1
60182: PPUSH
60183: LD_INT 0
60185: PPUSH
60186: CALL_OW 1
60190: ST_TO_ADDR
60191: GO 60244
// factoryWaypoints := Replace ( factoryWaypoints , factory , [ GetSide ( factory ) , factory , x , y ] ) ;
60193: LD_ADDR_EXP 87
60197: PUSH
60198: LD_EXP 87
60202: PPUSH
60203: LD_VAR 0 1
60207: PPUSH
60208: LD_VAR 0 1
60212: PPUSH
60213: CALL_OW 255
60217: PUSH
60218: LD_VAR 0 1
60222: PUSH
60223: LD_VAR 0 2
60227: PUSH
60228: LD_VAR 0 3
60232: PUSH
60233: EMPTY
60234: LIST
60235: LIST
60236: LIST
60237: LIST
60238: PPUSH
60239: CALL_OW 1
60243: ST_TO_ADDR
// UpdateFactoryWaypoints ;
60244: CALL 60253 0 0
// end ;
60248: LD_VAR 0 4
60252: RET
// export function UpdateFactoryWaypoints ( ) ; var i ; begin
60253: LD_INT 0
60255: PPUSH
60256: PPUSH
// ToLua ( resetFactoryWaypoint(); ) ;
60257: LD_STRING resetFactoryWaypoint();
60259: PPUSH
60260: CALL_OW 559
// if factoryWaypoints then
60264: LD_EXP 87
60268: IFFALSE 60391
// begin for i := 1 to factoryWaypoints do
60270: LD_ADDR_VAR 0 2
60274: PUSH
60275: DOUBLE
60276: LD_INT 1
60278: DEC
60279: ST_TO_ADDR
60280: LD_EXP 87
60284: PUSH
60285: FOR_TO
60286: IFFALSE 60389
// if factoryWaypoints [ i ] then
60288: LD_EXP 87
60292: PUSH
60293: LD_VAR 0 2
60297: ARRAY
60298: IFFALSE 60387
// ToLua ( setFactoryWaypointXY( & factoryWaypoints [ i ] [ 1 ] & , & factoryWaypoints [ i ] [ 2 ] & , & factoryWaypoints [ i ] [ 3 ] & , & factoryWaypoints [ i ] [ 4 ] & ) ) ;
60300: LD_STRING setFactoryWaypointXY(
60302: PUSH
60303: LD_EXP 87
60307: PUSH
60308: LD_VAR 0 2
60312: ARRAY
60313: PUSH
60314: LD_INT 1
60316: ARRAY
60317: STR
60318: PUSH
60319: LD_STRING ,
60321: STR
60322: PUSH
60323: LD_EXP 87
60327: PUSH
60328: LD_VAR 0 2
60332: ARRAY
60333: PUSH
60334: LD_INT 2
60336: ARRAY
60337: STR
60338: PUSH
60339: LD_STRING ,
60341: STR
60342: PUSH
60343: LD_EXP 87
60347: PUSH
60348: LD_VAR 0 2
60352: ARRAY
60353: PUSH
60354: LD_INT 3
60356: ARRAY
60357: STR
60358: PUSH
60359: LD_STRING ,
60361: STR
60362: PUSH
60363: LD_EXP 87
60367: PUSH
60368: LD_VAR 0 2
60372: ARRAY
60373: PUSH
60374: LD_INT 4
60376: ARRAY
60377: STR
60378: PUSH
60379: LD_STRING )
60381: STR
60382: PPUSH
60383: CALL_OW 559
60387: GO 60285
60389: POP
60390: POP
// end ; end ;
60391: LD_VAR 0 1
60395: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
60396: LD_INT 0
60398: PPUSH
60399: PPUSH
60400: PPUSH
60401: PPUSH
60402: PPUSH
60403: PPUSH
60404: PPUSH
60405: PPUSH
60406: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
60407: LD_VAR 0 1
60411: NOT
60412: PUSH
60413: LD_VAR 0 2
60417: PPUSH
60418: LD_VAR 0 3
60422: PPUSH
60423: CALL_OW 488
60427: NOT
60428: OR
60429: PUSH
60430: LD_VAR 0 4
60434: NOT
60435: OR
60436: IFFALSE 60440
// exit ;
60438: GO 60780
// list := [ ] ;
60440: LD_ADDR_VAR 0 13
60444: PUSH
60445: EMPTY
60446: ST_TO_ADDR
// if x - r < 0 then
60447: LD_VAR 0 2
60451: PUSH
60452: LD_VAR 0 4
60456: MINUS
60457: PUSH
60458: LD_INT 0
60460: LESS
60461: IFFALSE 60473
// min_x := 0 else
60463: LD_ADDR_VAR 0 7
60467: PUSH
60468: LD_INT 0
60470: ST_TO_ADDR
60471: GO 60489
// min_x := x - r ;
60473: LD_ADDR_VAR 0 7
60477: PUSH
60478: LD_VAR 0 2
60482: PUSH
60483: LD_VAR 0 4
60487: MINUS
60488: ST_TO_ADDR
// if y - r < 0 then
60489: LD_VAR 0 3
60493: PUSH
60494: LD_VAR 0 4
60498: MINUS
60499: PUSH
60500: LD_INT 0
60502: LESS
60503: IFFALSE 60515
// min_y := 0 else
60505: LD_ADDR_VAR 0 8
60509: PUSH
60510: LD_INT 0
60512: ST_TO_ADDR
60513: GO 60531
// min_y := y - r ;
60515: LD_ADDR_VAR 0 8
60519: PUSH
60520: LD_VAR 0 3
60524: PUSH
60525: LD_VAR 0 4
60529: MINUS
60530: ST_TO_ADDR
// max_x := x + r ;
60531: LD_ADDR_VAR 0 9
60535: PUSH
60536: LD_VAR 0 2
60540: PUSH
60541: LD_VAR 0 4
60545: PLUS
60546: ST_TO_ADDR
// max_y := y + r ;
60547: LD_ADDR_VAR 0 10
60551: PUSH
60552: LD_VAR 0 3
60556: PUSH
60557: LD_VAR 0 4
60561: PLUS
60562: ST_TO_ADDR
// for _x = min_x to max_x do
60563: LD_ADDR_VAR 0 11
60567: PUSH
60568: DOUBLE
60569: LD_VAR 0 7
60573: DEC
60574: ST_TO_ADDR
60575: LD_VAR 0 9
60579: PUSH
60580: FOR_TO
60581: IFFALSE 60698
// for _y = min_y to max_y do
60583: LD_ADDR_VAR 0 12
60587: PUSH
60588: DOUBLE
60589: LD_VAR 0 8
60593: DEC
60594: ST_TO_ADDR
60595: LD_VAR 0 10
60599: PUSH
60600: FOR_TO
60601: IFFALSE 60694
// begin if not ValidHex ( _x , _y ) then
60603: LD_VAR 0 11
60607: PPUSH
60608: LD_VAR 0 12
60612: PPUSH
60613: CALL_OW 488
60617: NOT
60618: IFFALSE 60622
// continue ;
60620: GO 60600
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
60622: LD_VAR 0 11
60626: PPUSH
60627: LD_VAR 0 12
60631: PPUSH
60632: CALL_OW 351
60636: PUSH
60637: LD_VAR 0 11
60641: PPUSH
60642: LD_VAR 0 12
60646: PPUSH
60647: CALL_OW 554
60651: AND
60652: IFFALSE 60692
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
60654: LD_ADDR_VAR 0 13
60658: PUSH
60659: LD_VAR 0 13
60663: PPUSH
60664: LD_VAR 0 13
60668: PUSH
60669: LD_INT 1
60671: PLUS
60672: PPUSH
60673: LD_VAR 0 11
60677: PUSH
60678: LD_VAR 0 12
60682: PUSH
60683: EMPTY
60684: LIST
60685: LIST
60686: PPUSH
60687: CALL_OW 2
60691: ST_TO_ADDR
// end ;
60692: GO 60600
60694: POP
60695: POP
60696: GO 60580
60698: POP
60699: POP
// if not list then
60700: LD_VAR 0 13
60704: NOT
60705: IFFALSE 60709
// exit ;
60707: GO 60780
// for i in list do
60709: LD_ADDR_VAR 0 6
60713: PUSH
60714: LD_VAR 0 13
60718: PUSH
60719: FOR_IN
60720: IFFALSE 60778
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
60722: LD_VAR 0 1
60726: PPUSH
60727: LD_STRING M
60729: PUSH
60730: LD_VAR 0 6
60734: PUSH
60735: LD_INT 1
60737: ARRAY
60738: PUSH
60739: LD_VAR 0 6
60743: PUSH
60744: LD_INT 2
60746: ARRAY
60747: PUSH
60748: LD_INT 0
60750: PUSH
60751: LD_INT 0
60753: PUSH
60754: LD_INT 0
60756: PUSH
60757: LD_INT 0
60759: PUSH
60760: EMPTY
60761: LIST
60762: LIST
60763: LIST
60764: LIST
60765: LIST
60766: LIST
60767: LIST
60768: PUSH
60769: EMPTY
60770: LIST
60771: PPUSH
60772: CALL_OW 447
60776: GO 60719
60778: POP
60779: POP
// end ;
60780: LD_VAR 0 5
60784: RET
// export initHack , hackTanks , hackTanksCaptured , hackLimit , hackDist , hackCounter ; every 0 0$1 trigger not initHack do
60785: LD_EXP 88
60789: NOT
60790: IFFALSE 60840
60792: GO 60794
60794: DISABLE
// begin initHack := true ;
60795: LD_ADDR_EXP 88
60799: PUSH
60800: LD_INT 1
60802: ST_TO_ADDR
// hackTanks := [ ] ;
60803: LD_ADDR_EXP 89
60807: PUSH
60808: EMPTY
60809: ST_TO_ADDR
// hackTanksCaptured := [ ] ;
60810: LD_ADDR_EXP 90
60814: PUSH
60815: EMPTY
60816: ST_TO_ADDR
// hackLimit := 3 ;
60817: LD_ADDR_EXP 91
60821: PUSH
60822: LD_INT 3
60824: ST_TO_ADDR
// hackDist := 12 ;
60825: LD_ADDR_EXP 92
60829: PUSH
60830: LD_INT 12
60832: ST_TO_ADDR
// hackCounter := [ ] ;
60833: LD_ADDR_EXP 93
60837: PUSH
60838: EMPTY
60839: ST_TO_ADDR
// end ;
60840: END
// every 0 0$1 trigger initHack and FilterAllUnits ( [ f_weapon , us_hack ] ) do var i , tmp ;
60841: LD_EXP 88
60845: PUSH
60846: LD_INT 34
60848: PUSH
60849: LD_EXP 158
60853: PUSH
60854: EMPTY
60855: LIST
60856: LIST
60857: PPUSH
60858: CALL_OW 69
60862: AND
60863: IFFALSE 61118
60865: GO 60867
60867: DISABLE
60868: LD_INT 0
60870: PPUSH
60871: PPUSH
// begin enable ;
60872: ENABLE
// for i in FilterAllUnits ( [ f_weapon , us_hack ] ) do
60873: LD_ADDR_VAR 0 1
60877: PUSH
60878: LD_INT 34
60880: PUSH
60881: LD_EXP 158
60885: PUSH
60886: EMPTY
60887: LIST
60888: LIST
60889: PPUSH
60890: CALL_OW 69
60894: PUSH
60895: FOR_IN
60896: IFFALSE 61116
// begin if not i in hackTanks then
60898: LD_VAR 0 1
60902: PUSH
60903: LD_EXP 89
60907: IN
60908: NOT
60909: IFFALSE 60992
// begin hackTanks := Replace ( hackTanks , hackTanks + 1 , i ) ;
60911: LD_ADDR_EXP 89
60915: PUSH
60916: LD_EXP 89
60920: PPUSH
60921: LD_EXP 89
60925: PUSH
60926: LD_INT 1
60928: PLUS
60929: PPUSH
60930: LD_VAR 0 1
60934: PPUSH
60935: CALL_OW 1
60939: ST_TO_ADDR
// hackTanksCaptured := Replace ( hackTanksCaptured , hackTanksCaptured + 1 , [ ] ) ;
60940: LD_ADDR_EXP 90
60944: PUSH
60945: LD_EXP 90
60949: PPUSH
60950: LD_EXP 90
60954: PUSH
60955: LD_INT 1
60957: PLUS
60958: PPUSH
60959: EMPTY
60960: PPUSH
60961: CALL_OW 1
60965: ST_TO_ADDR
// hackCounter := Replace ( hackCounter , hackCounter + 1 , [ ] ) ;
60966: LD_ADDR_EXP 93
60970: PUSH
60971: LD_EXP 93
60975: PPUSH
60976: LD_EXP 93
60980: PUSH
60981: LD_INT 1
60983: PLUS
60984: PPUSH
60985: EMPTY
60986: PPUSH
60987: CALL_OW 1
60991: ST_TO_ADDR
// end ; if not IsOk ( i ) then
60992: LD_VAR 0 1
60996: PPUSH
60997: CALL_OW 302
61001: NOT
61002: IFFALSE 61015
// begin HackUnlinkAll ( i ) ;
61004: LD_VAR 0 1
61008: PPUSH
61009: CALL 61121 0 1
// continue ;
61013: GO 60895
// end ; HackCheckCapturedStatus ( i ) ;
61015: LD_VAR 0 1
61019: PPUSH
61020: CALL 61564 0 1
// tmp := FilterAllUnits ( [ [ f_enemy , GetSide ( i ) ] , [ f_control , control_computer ] , [ f_dist , i , hackDist ] , [ f_ok ] ] ) ;
61024: LD_ADDR_VAR 0 2
61028: PUSH
61029: LD_INT 81
61031: PUSH
61032: LD_VAR 0 1
61036: PPUSH
61037: CALL_OW 255
61041: PUSH
61042: EMPTY
61043: LIST
61044: LIST
61045: PUSH
61046: LD_INT 33
61048: PUSH
61049: LD_INT 3
61051: PUSH
61052: EMPTY
61053: LIST
61054: LIST
61055: PUSH
61056: LD_INT 91
61058: PUSH
61059: LD_VAR 0 1
61063: PUSH
61064: LD_EXP 92
61068: PUSH
61069: EMPTY
61070: LIST
61071: LIST
61072: LIST
61073: PUSH
61074: LD_INT 50
61076: PUSH
61077: EMPTY
61078: LIST
61079: PUSH
61080: EMPTY
61081: LIST
61082: LIST
61083: LIST
61084: LIST
61085: PPUSH
61086: CALL_OW 69
61090: ST_TO_ADDR
// if not tmp then
61091: LD_VAR 0 2
61095: NOT
61096: IFFALSE 61100
// continue ;
61098: GO 60895
// HackLink ( i , tmp ) ;
61100: LD_VAR 0 1
61104: PPUSH
61105: LD_VAR 0 2
61109: PPUSH
61110: CALL 61257 0 2
// end ;
61114: GO 60895
61116: POP
61117: POP
// end ;
61118: PPOPN 2
61120: END
// function HackUnlinkAll ( hack ) ; var i , index ; begin
61121: LD_INT 0
61123: PPUSH
61124: PPUSH
61125: PPUSH
// if not hack in hackTanks then
61126: LD_VAR 0 1
61130: PUSH
61131: LD_EXP 89
61135: IN
61136: NOT
61137: IFFALSE 61141
// exit ;
61139: GO 61252
// index := GetElementIndex ( hackTanks , hack ) ;
61141: LD_ADDR_VAR 0 4
61145: PUSH
61146: LD_EXP 89
61150: PPUSH
61151: LD_VAR 0 1
61155: PPUSH
61156: CALL 23995 0 2
61160: ST_TO_ADDR
// if hackTanksCaptured [ index ] then
61161: LD_EXP 90
61165: PUSH
61166: LD_VAR 0 4
61170: ARRAY
61171: IFFALSE 61252
// begin for i in hackTanksCaptured [ index ] do
61173: LD_ADDR_VAR 0 3
61177: PUSH
61178: LD_EXP 90
61182: PUSH
61183: LD_VAR 0 4
61187: ARRAY
61188: PUSH
61189: FOR_IN
61190: IFFALSE 61216
// SetSide ( i [ 1 ] , i [ 2 ] ) ;
61192: LD_VAR 0 3
61196: PUSH
61197: LD_INT 1
61199: ARRAY
61200: PPUSH
61201: LD_VAR 0 3
61205: PUSH
61206: LD_INT 2
61208: ARRAY
61209: PPUSH
61210: CALL_OW 235
61214: GO 61189
61216: POP
61217: POP
// hackTanksCaptured := Replace ( hackTanksCaptured , index , [ ] ) ;
61218: LD_ADDR_EXP 90
61222: PUSH
61223: LD_EXP 90
61227: PPUSH
61228: LD_VAR 0 4
61232: PPUSH
61233: EMPTY
61234: PPUSH
61235: CALL_OW 1
61239: ST_TO_ADDR
// SetUnitDisplayNumber ( hack , 0 ) ;
61240: LD_VAR 0 1
61244: PPUSH
61245: LD_INT 0
61247: PPUSH
61248: CALL_OW 505
// end ; end ;
61252: LD_VAR 0 2
61256: RET
// function HackLink ( hack , vehicles ) ; var i , index ; begin
61257: LD_INT 0
61259: PPUSH
61260: PPUSH
61261: PPUSH
// if not hack in hackTanks or not vehicles then
61262: LD_VAR 0 1
61266: PUSH
61267: LD_EXP 89
61271: IN
61272: NOT
61273: PUSH
61274: LD_VAR 0 2
61278: NOT
61279: OR
61280: IFFALSE 61284
// exit ;
61282: GO 61559
// vehicles := SortByDistanceUnit ( hack , vehicles , true , true ) ;
61284: LD_ADDR_VAR 0 2
61288: PUSH
61289: LD_VAR 0 1
61293: PPUSH
61294: LD_VAR 0 2
61298: PPUSH
61299: LD_INT 1
61301: PPUSH
61302: LD_INT 1
61304: PPUSH
61305: CALL 24645 0 4
61309: ST_TO_ADDR
// index := GetElementIndex ( hackTanks , hack ) ;
61310: LD_ADDR_VAR 0 5
61314: PUSH
61315: LD_EXP 89
61319: PPUSH
61320: LD_VAR 0 1
61324: PPUSH
61325: CALL 23995 0 2
61329: ST_TO_ADDR
// if hackTanksCaptured [ index ] < hackLimit then
61330: LD_EXP 90
61334: PUSH
61335: LD_VAR 0 5
61339: ARRAY
61340: PUSH
61341: LD_EXP 91
61345: LESS
61346: IFFALSE 61535
// begin for i := 1 to vehicles do
61348: LD_ADDR_VAR 0 4
61352: PUSH
61353: DOUBLE
61354: LD_INT 1
61356: DEC
61357: ST_TO_ADDR
61358: LD_VAR 0 2
61362: PUSH
61363: FOR_TO
61364: IFFALSE 61533
// begin if hackTanksCaptured [ index ] = hackLimit then
61366: LD_EXP 90
61370: PUSH
61371: LD_VAR 0 5
61375: ARRAY
61376: PUSH
61377: LD_EXP 91
61381: EQUAL
61382: IFFALSE 61386
// break ;
61384: GO 61533
// hackCounter := Replace ( hackCounter , index , hackCounter [ index ] + 1 ) ;
61386: LD_ADDR_EXP 93
61390: PUSH
61391: LD_EXP 93
61395: PPUSH
61396: LD_VAR 0 5
61400: PPUSH
61401: LD_EXP 93
61405: PUSH
61406: LD_VAR 0 5
61410: ARRAY
61411: PUSH
61412: LD_INT 1
61414: PLUS
61415: PPUSH
61416: CALL_OW 1
61420: ST_TO_ADDR
// hackTanksCaptured := ReplaceIn ( hackTanksCaptured , [ index , hackTanksCaptured [ index ] + 1 ] , [ vehicles [ i ] , GetSide ( vehicles [ i ] ) ] ) ;
61421: LD_ADDR_EXP 90
61425: PUSH
61426: LD_EXP 90
61430: PPUSH
61431: LD_VAR 0 5
61435: PUSH
61436: LD_EXP 90
61440: PUSH
61441: LD_VAR 0 5
61445: ARRAY
61446: PUSH
61447: LD_INT 1
61449: PLUS
61450: PUSH
61451: EMPTY
61452: LIST
61453: LIST
61454: PPUSH
61455: LD_VAR 0 2
61459: PUSH
61460: LD_VAR 0 4
61464: ARRAY
61465: PUSH
61466: LD_VAR 0 2
61470: PUSH
61471: LD_VAR 0 4
61475: ARRAY
61476: PPUSH
61477: CALL_OW 255
61481: PUSH
61482: EMPTY
61483: LIST
61484: LIST
61485: PPUSH
61486: CALL 24210 0 3
61490: ST_TO_ADDR
// SetSide ( vehicles [ i ] , GetSide ( hack ) ) ;
61491: LD_VAR 0 2
61495: PUSH
61496: LD_VAR 0 4
61500: ARRAY
61501: PPUSH
61502: LD_VAR 0 1
61506: PPUSH
61507: CALL_OW 255
61511: PPUSH
61512: CALL_OW 235
// ComStop ( vehicles [ i ] ) ;
61516: LD_VAR 0 2
61520: PUSH
61521: LD_VAR 0 4
61525: ARRAY
61526: PPUSH
61527: CALL_OW 141
// end ;
61531: GO 61363
61533: POP
61534: POP
// end ; SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
61535: LD_VAR 0 1
61539: PPUSH
61540: LD_EXP 90
61544: PUSH
61545: LD_VAR 0 5
61549: ARRAY
61550: PUSH
61551: LD_INT 0
61553: PLUS
61554: PPUSH
61555: CALL_OW 505
// end ;
61559: LD_VAR 0 3
61563: RET
// function HackCheckCapturedStatus ( hack ) ; var i , index , tmp ; begin
61564: LD_INT 0
61566: PPUSH
61567: PPUSH
61568: PPUSH
61569: PPUSH
// if not hack in hackTanks then
61570: LD_VAR 0 1
61574: PUSH
61575: LD_EXP 89
61579: IN
61580: NOT
61581: IFFALSE 61585
// exit ;
61583: GO 61825
// index := GetElementIndex ( hackTanks , hack ) ;
61585: LD_ADDR_VAR 0 4
61589: PUSH
61590: LD_EXP 89
61594: PPUSH
61595: LD_VAR 0 1
61599: PPUSH
61600: CALL 23995 0 2
61604: ST_TO_ADDR
// for i := hackTanksCaptured [ index ] downto 1 do
61605: LD_ADDR_VAR 0 3
61609: PUSH
61610: DOUBLE
61611: LD_EXP 90
61615: PUSH
61616: LD_VAR 0 4
61620: ARRAY
61621: INC
61622: ST_TO_ADDR
61623: LD_INT 1
61625: PUSH
61626: FOR_DOWNTO
61627: IFFALSE 61799
// begin tmp := hackTanksCaptured [ index ] [ i ] ;
61629: LD_ADDR_VAR 0 5
61633: PUSH
61634: LD_EXP 90
61638: PUSH
61639: LD_VAR 0 4
61643: ARRAY
61644: PUSH
61645: LD_VAR 0 3
61649: ARRAY
61650: ST_TO_ADDR
// if not IsOk ( tmp [ 1 ] ) or GetSide ( tmp [ 1 ] ) <> GetSide ( hack ) then
61651: LD_VAR 0 5
61655: PUSH
61656: LD_INT 1
61658: ARRAY
61659: PPUSH
61660: CALL_OW 302
61664: NOT
61665: PUSH
61666: LD_VAR 0 5
61670: PUSH
61671: LD_INT 1
61673: ARRAY
61674: PPUSH
61675: CALL_OW 255
61679: PUSH
61680: LD_VAR 0 1
61684: PPUSH
61685: CALL_OW 255
61689: NONEQUAL
61690: OR
61691: IFFALSE 61797
// begin if IsPlaced ( tmp [ 1 ] ) and GetSide ( tmp [ 1 ] ) = GetSide ( hack ) then
61693: LD_VAR 0 5
61697: PUSH
61698: LD_INT 1
61700: ARRAY
61701: PPUSH
61702: CALL_OW 305
61706: PUSH
61707: LD_VAR 0 5
61711: PUSH
61712: LD_INT 1
61714: ARRAY
61715: PPUSH
61716: CALL_OW 255
61720: PUSH
61721: LD_VAR 0 1
61725: PPUSH
61726: CALL_OW 255
61730: EQUAL
61731: AND
61732: IFFALSE 61756
// SetSide ( tmp [ 1 ] , tmp [ 2 ] ) ;
61734: LD_VAR 0 5
61738: PUSH
61739: LD_INT 1
61741: ARRAY
61742: PPUSH
61743: LD_VAR 0 5
61747: PUSH
61748: LD_INT 2
61750: ARRAY
61751: PPUSH
61752: CALL_OW 235
// hackTanksCaptured := Replace ( hackTanksCaptured , index , Delete ( hackTanksCaptured [ index ] , i ) ) ;
61756: LD_ADDR_EXP 90
61760: PUSH
61761: LD_EXP 90
61765: PPUSH
61766: LD_VAR 0 4
61770: PPUSH
61771: LD_EXP 90
61775: PUSH
61776: LD_VAR 0 4
61780: ARRAY
61781: PPUSH
61782: LD_VAR 0 3
61786: PPUSH
61787: CALL_OW 3
61791: PPUSH
61792: CALL_OW 1
61796: ST_TO_ADDR
// end ; end ;
61797: GO 61626
61799: POP
61800: POP
// SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
61801: LD_VAR 0 1
61805: PPUSH
61806: LD_EXP 90
61810: PUSH
61811: LD_VAR 0 4
61815: ARRAY
61816: PUSH
61817: LD_INT 0
61819: PLUS
61820: PPUSH
61821: CALL_OW 505
// end ;
61825: LD_VAR 0 2
61829: RET
// export function HackDestroyVehicle ( hack , vehicle ) ; var i , index , tmp ; begin
61830: LD_INT 0
61832: PPUSH
61833: PPUSH
61834: PPUSH
61835: PPUSH
// if not hack in hackTanks then
61836: LD_VAR 0 1
61840: PUSH
61841: LD_EXP 89
61845: IN
61846: NOT
61847: IFFALSE 61851
// exit ;
61849: GO 61936
// index := GetElementIndex ( hackTanks , hack ) ;
61851: LD_ADDR_VAR 0 5
61855: PUSH
61856: LD_EXP 89
61860: PPUSH
61861: LD_VAR 0 1
61865: PPUSH
61866: CALL 23995 0 2
61870: ST_TO_ADDR
// for i := 1 to hackTanksCaptured [ index ] do
61871: LD_ADDR_VAR 0 4
61875: PUSH
61876: DOUBLE
61877: LD_INT 1
61879: DEC
61880: ST_TO_ADDR
61881: LD_EXP 90
61885: PUSH
61886: LD_VAR 0 5
61890: ARRAY
61891: PUSH
61892: FOR_TO
61893: IFFALSE 61934
// if hackTanksCaptured [ index ] [ i ] [ 1 ] = vehicle then
61895: LD_EXP 90
61899: PUSH
61900: LD_VAR 0 5
61904: ARRAY
61905: PUSH
61906: LD_VAR 0 4
61910: ARRAY
61911: PUSH
61912: LD_INT 1
61914: ARRAY
61915: PUSH
61916: LD_VAR 0 2
61920: EQUAL
61921: IFFALSE 61932
// KillUnit ( vehicle ) ;
61923: LD_VAR 0 2
61927: PPUSH
61928: CALL_OW 66
61932: GO 61892
61934: POP
61935: POP
// end ;
61936: LD_VAR 0 3
61940: RET
// export initMiner , minersList , minerMinesList , minesLimitPerVehicle ; every 0 0$1 trigger not initMiner do
61941: LD_EXP 94
61945: NOT
61946: IFFALSE 61981
61948: GO 61950
61950: DISABLE
// begin initMiner := true ;
61951: LD_ADDR_EXP 94
61955: PUSH
61956: LD_INT 1
61958: ST_TO_ADDR
// minersList := [ ] ;
61959: LD_ADDR_EXP 95
61963: PUSH
61964: EMPTY
61965: ST_TO_ADDR
// minerMinesList := [ ] ;
61966: LD_ADDR_EXP 96
61970: PUSH
61971: EMPTY
61972: ST_TO_ADDR
// minesLimitPerVehicle := 5 ;
61973: LD_ADDR_EXP 97
61977: PUSH
61978: LD_INT 5
61980: ST_TO_ADDR
// end ;
61981: END
// every 0 0$1 trigger initMiner and FilterAllUnits ( [ f_weapon , ar_miner ] ) do var i , j , side , tmp ;
61982: LD_EXP 94
61986: PUSH
61987: LD_INT 34
61989: PUSH
61990: LD_EXP 163
61994: PUSH
61995: EMPTY
61996: LIST
61997: LIST
61998: PPUSH
61999: CALL_OW 69
62003: AND
62004: IFFALSE 62467
62006: GO 62008
62008: DISABLE
62009: LD_INT 0
62011: PPUSH
62012: PPUSH
62013: PPUSH
62014: PPUSH
// begin enable ;
62015: ENABLE
// for i in FilterAllUnits ( [ f_weapon , ar_miner ] ) do
62016: LD_ADDR_VAR 0 1
62020: PUSH
62021: LD_INT 34
62023: PUSH
62024: LD_EXP 163
62028: PUSH
62029: EMPTY
62030: LIST
62031: LIST
62032: PPUSH
62033: CALL_OW 69
62037: PUSH
62038: FOR_IN
62039: IFFALSE 62111
// begin if not i in minersList then
62041: LD_VAR 0 1
62045: PUSH
62046: LD_EXP 95
62050: IN
62051: NOT
62052: IFFALSE 62109
// begin minersList := Replace ( minersList , minersList + 1 , i ) ;
62054: LD_ADDR_EXP 95
62058: PUSH
62059: LD_EXP 95
62063: PPUSH
62064: LD_EXP 95
62068: PUSH
62069: LD_INT 1
62071: PLUS
62072: PPUSH
62073: LD_VAR 0 1
62077: PPUSH
62078: CALL_OW 1
62082: ST_TO_ADDR
// minerMinesList := Replace ( minerMinesList , minerMinesList + 1 , [ ] ) ;
62083: LD_ADDR_EXP 96
62087: PUSH
62088: LD_EXP 96
62092: PPUSH
62093: LD_EXP 96
62097: PUSH
62098: LD_INT 1
62100: PLUS
62101: PPUSH
62102: EMPTY
62103: PPUSH
62104: CALL_OW 1
62108: ST_TO_ADDR
// end end ;
62109: GO 62038
62111: POP
62112: POP
// for i := minerMinesList downto 1 do
62113: LD_ADDR_VAR 0 1
62117: PUSH
62118: DOUBLE
62119: LD_EXP 96
62123: INC
62124: ST_TO_ADDR
62125: LD_INT 1
62127: PUSH
62128: FOR_DOWNTO
62129: IFFALSE 62465
// begin if IsLive ( minersList [ i ] ) then
62131: LD_EXP 95
62135: PUSH
62136: LD_VAR 0 1
62140: ARRAY
62141: PPUSH
62142: CALL_OW 300
62146: IFFALSE 62174
// SetUnitDisplayNumber ( minersList [ i ] , minerMinesList [ i ] ) ;
62148: LD_EXP 95
62152: PUSH
62153: LD_VAR 0 1
62157: ARRAY
62158: PPUSH
62159: LD_EXP 96
62163: PUSH
62164: LD_VAR 0 1
62168: ARRAY
62169: PPUSH
62170: CALL_OW 505
// if not minerMinesList [ i ] then
62174: LD_EXP 96
62178: PUSH
62179: LD_VAR 0 1
62183: ARRAY
62184: NOT
62185: IFFALSE 62189
// continue ;
62187: GO 62128
// for j := minerMinesList [ i ] downto 1 do
62189: LD_ADDR_VAR 0 2
62193: PUSH
62194: DOUBLE
62195: LD_EXP 96
62199: PUSH
62200: LD_VAR 0 1
62204: ARRAY
62205: INC
62206: ST_TO_ADDR
62207: LD_INT 1
62209: PUSH
62210: FOR_DOWNTO
62211: IFFALSE 62461
// begin side := GetSide ( minersList [ i ] ) ;
62213: LD_ADDR_VAR 0 3
62217: PUSH
62218: LD_EXP 95
62222: PUSH
62223: LD_VAR 0 1
62227: ARRAY
62228: PPUSH
62229: CALL_OW 255
62233: ST_TO_ADDR
// tmp := HexInfo ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) ;
62234: LD_ADDR_VAR 0 4
62238: PUSH
62239: LD_EXP 96
62243: PUSH
62244: LD_VAR 0 1
62248: ARRAY
62249: PUSH
62250: LD_VAR 0 2
62254: ARRAY
62255: PUSH
62256: LD_INT 1
62258: ARRAY
62259: PPUSH
62260: LD_EXP 96
62264: PUSH
62265: LD_VAR 0 1
62269: ARRAY
62270: PUSH
62271: LD_VAR 0 2
62275: ARRAY
62276: PUSH
62277: LD_INT 2
62279: ARRAY
62280: PPUSH
62281: CALL_OW 428
62285: ST_TO_ADDR
// if not tmp then
62286: LD_VAR 0 4
62290: NOT
62291: IFFALSE 62295
// continue ;
62293: GO 62210
// if tmp in FilterAllUnits ( [ f_enemy , side ] ) and MineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) then
62295: LD_VAR 0 4
62299: PUSH
62300: LD_INT 81
62302: PUSH
62303: LD_VAR 0 3
62307: PUSH
62308: EMPTY
62309: LIST
62310: LIST
62311: PPUSH
62312: CALL_OW 69
62316: IN
62317: PUSH
62318: LD_EXP 96
62322: PUSH
62323: LD_VAR 0 1
62327: ARRAY
62328: PUSH
62329: LD_VAR 0 2
62333: ARRAY
62334: PUSH
62335: LD_INT 1
62337: ARRAY
62338: PPUSH
62339: LD_EXP 96
62343: PUSH
62344: LD_VAR 0 1
62348: ARRAY
62349: PUSH
62350: LD_VAR 0 2
62354: ARRAY
62355: PUSH
62356: LD_INT 2
62358: ARRAY
62359: PPUSH
62360: CALL_OW 458
62364: AND
62365: IFFALSE 62459
// begin LaunchMineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] , side ) ;
62367: LD_EXP 96
62371: PUSH
62372: LD_VAR 0 1
62376: ARRAY
62377: PUSH
62378: LD_VAR 0 2
62382: ARRAY
62383: PUSH
62384: LD_INT 1
62386: ARRAY
62387: PPUSH
62388: LD_EXP 96
62392: PUSH
62393: LD_VAR 0 1
62397: ARRAY
62398: PUSH
62399: LD_VAR 0 2
62403: ARRAY
62404: PUSH
62405: LD_INT 2
62407: ARRAY
62408: PPUSH
62409: LD_VAR 0 3
62413: PPUSH
62414: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , i , Delete ( minerMinesList [ i ] , j ) ) ;
62418: LD_ADDR_EXP 96
62422: PUSH
62423: LD_EXP 96
62427: PPUSH
62428: LD_VAR 0 1
62432: PPUSH
62433: LD_EXP 96
62437: PUSH
62438: LD_VAR 0 1
62442: ARRAY
62443: PPUSH
62444: LD_VAR 0 2
62448: PPUSH
62449: CALL_OW 3
62453: PPUSH
62454: CALL_OW 1
62458: ST_TO_ADDR
// end ; end ;
62459: GO 62210
62461: POP
62462: POP
// end ;
62463: GO 62128
62465: POP
62466: POP
// end ;
62467: PPOPN 4
62469: END
// export function MinerPlaceMine ( unit , x , y ) ; var index ; begin
62470: LD_INT 0
62472: PPUSH
62473: PPUSH
// result := false ;
62474: LD_ADDR_VAR 0 4
62478: PUSH
62479: LD_INT 0
62481: ST_TO_ADDR
// if not GetWeapon ( unit ) = ar_miner then
62482: LD_VAR 0 1
62486: PPUSH
62487: CALL_OW 264
62491: PUSH
62492: LD_EXP 163
62496: EQUAL
62497: NOT
62498: IFFALSE 62502
// exit ;
62500: GO 62742
// index := GetElementIndex ( minersList , unit ) ;
62502: LD_ADDR_VAR 0 5
62506: PUSH
62507: LD_EXP 95
62511: PPUSH
62512: LD_VAR 0 1
62516: PPUSH
62517: CALL 23995 0 2
62521: ST_TO_ADDR
// if minerMinesList [ index ] >= minesLimitPerVehicle then
62522: LD_EXP 96
62526: PUSH
62527: LD_VAR 0 5
62531: ARRAY
62532: PUSH
62533: LD_EXP 97
62537: GREATEREQUAL
62538: IFFALSE 62542
// exit ;
62540: GO 62742
// ComMoveXY ( unit , x , y ) ;
62542: LD_VAR 0 1
62546: PPUSH
62547: LD_VAR 0 2
62551: PPUSH
62552: LD_VAR 0 3
62556: PPUSH
62557: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
62561: LD_INT 35
62563: PPUSH
62564: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) and HasTask ( unit ) then
62568: LD_VAR 0 1
62572: PPUSH
62573: LD_VAR 0 2
62577: PPUSH
62578: LD_VAR 0 3
62582: PPUSH
62583: CALL 54767 0 3
62587: NOT
62588: PUSH
62589: LD_VAR 0 1
62593: PPUSH
62594: CALL_OW 314
62598: AND
62599: IFFALSE 62603
// exit ;
62601: GO 62742
// until HexInfo ( x , y ) = unit and not HasTask ( unit ) ;
62603: LD_VAR 0 2
62607: PPUSH
62608: LD_VAR 0 3
62612: PPUSH
62613: CALL_OW 428
62617: PUSH
62618: LD_VAR 0 1
62622: EQUAL
62623: PUSH
62624: LD_VAR 0 1
62628: PPUSH
62629: CALL_OW 314
62633: NOT
62634: AND
62635: IFFALSE 62561
// PlaySoundXY ( x , y , PlantMine ) ;
62637: LD_VAR 0 2
62641: PPUSH
62642: LD_VAR 0 3
62646: PPUSH
62647: LD_STRING PlantMine
62649: PPUSH
62650: CALL_OW 366
// PlaceMine ( x , y , GetSide ( unit ) , 0 ) ;
62654: LD_VAR 0 2
62658: PPUSH
62659: LD_VAR 0 3
62663: PPUSH
62664: LD_VAR 0 1
62668: PPUSH
62669: CALL_OW 255
62673: PPUSH
62674: LD_INT 0
62676: PPUSH
62677: CALL_OW 454
// minerMinesList := ReplaceIn ( minerMinesList , [ index , minerMinesList [ index ] + 1 ] , [ x , y ] ) ;
62681: LD_ADDR_EXP 96
62685: PUSH
62686: LD_EXP 96
62690: PPUSH
62691: LD_VAR 0 5
62695: PUSH
62696: LD_EXP 96
62700: PUSH
62701: LD_VAR 0 5
62705: ARRAY
62706: PUSH
62707: LD_INT 1
62709: PLUS
62710: PUSH
62711: EMPTY
62712: LIST
62713: LIST
62714: PPUSH
62715: LD_VAR 0 2
62719: PUSH
62720: LD_VAR 0 3
62724: PUSH
62725: EMPTY
62726: LIST
62727: LIST
62728: PPUSH
62729: CALL 24210 0 3
62733: ST_TO_ADDR
// result := true ;
62734: LD_ADDR_VAR 0 4
62738: PUSH
62739: LD_INT 1
62741: ST_TO_ADDR
// end ;
62742: LD_VAR 0 4
62746: RET
// export function MinerDetonateMine ( unit , x , y ) ; var i , index ; begin
62747: LD_INT 0
62749: PPUSH
62750: PPUSH
62751: PPUSH
// if not unit in minersList then
62752: LD_VAR 0 1
62756: PUSH
62757: LD_EXP 95
62761: IN
62762: NOT
62763: IFFALSE 62767
// exit ;
62765: GO 63159
// index := GetElementIndex ( minersList , unit ) ;
62767: LD_ADDR_VAR 0 6
62771: PUSH
62772: LD_EXP 95
62776: PPUSH
62777: LD_VAR 0 1
62781: PPUSH
62782: CALL 23995 0 2
62786: ST_TO_ADDR
// for i := minerMinesList [ index ] downto 1 do
62787: LD_ADDR_VAR 0 5
62791: PUSH
62792: DOUBLE
62793: LD_EXP 96
62797: PUSH
62798: LD_VAR 0 6
62802: ARRAY
62803: INC
62804: ST_TO_ADDR
62805: LD_INT 1
62807: PUSH
62808: FOR_DOWNTO
62809: IFFALSE 62970
// begin if minerMinesList [ index ] [ i ] [ 1 ] = x and minerMinesList [ index ] [ i ] [ 2 ] = y then
62811: LD_EXP 96
62815: PUSH
62816: LD_VAR 0 6
62820: ARRAY
62821: PUSH
62822: LD_VAR 0 5
62826: ARRAY
62827: PUSH
62828: LD_INT 1
62830: ARRAY
62831: PUSH
62832: LD_VAR 0 2
62836: EQUAL
62837: PUSH
62838: LD_EXP 96
62842: PUSH
62843: LD_VAR 0 6
62847: ARRAY
62848: PUSH
62849: LD_VAR 0 5
62853: ARRAY
62854: PUSH
62855: LD_INT 2
62857: ARRAY
62858: PUSH
62859: LD_VAR 0 3
62863: EQUAL
62864: AND
62865: IFFALSE 62968
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
62867: LD_EXP 96
62871: PUSH
62872: LD_VAR 0 6
62876: ARRAY
62877: PUSH
62878: LD_VAR 0 5
62882: ARRAY
62883: PUSH
62884: LD_INT 1
62886: ARRAY
62887: PPUSH
62888: LD_EXP 96
62892: PUSH
62893: LD_VAR 0 6
62897: ARRAY
62898: PUSH
62899: LD_VAR 0 5
62903: ARRAY
62904: PUSH
62905: LD_INT 2
62907: ARRAY
62908: PPUSH
62909: LD_VAR 0 1
62913: PPUSH
62914: CALL_OW 255
62918: PPUSH
62919: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
62923: LD_ADDR_EXP 96
62927: PUSH
62928: LD_EXP 96
62932: PPUSH
62933: LD_VAR 0 6
62937: PPUSH
62938: LD_EXP 96
62942: PUSH
62943: LD_VAR 0 6
62947: ARRAY
62948: PPUSH
62949: LD_VAR 0 5
62953: PPUSH
62954: CALL_OW 3
62958: PPUSH
62959: CALL_OW 1
62963: ST_TO_ADDR
// exit ;
62964: POP
62965: POP
62966: GO 63159
// end ; end ;
62968: GO 62808
62970: POP
62971: POP
// for i := minerMinesList [ index ] downto 1 do
62972: LD_ADDR_VAR 0 5
62976: PUSH
62977: DOUBLE
62978: LD_EXP 96
62982: PUSH
62983: LD_VAR 0 6
62987: ARRAY
62988: INC
62989: ST_TO_ADDR
62990: LD_INT 1
62992: PUSH
62993: FOR_DOWNTO
62994: IFFALSE 63157
// begin if GetDistXY ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , x , y ) < 6 then
62996: LD_EXP 96
63000: PUSH
63001: LD_VAR 0 6
63005: ARRAY
63006: PUSH
63007: LD_VAR 0 5
63011: ARRAY
63012: PUSH
63013: LD_INT 1
63015: ARRAY
63016: PPUSH
63017: LD_EXP 96
63021: PUSH
63022: LD_VAR 0 6
63026: ARRAY
63027: PUSH
63028: LD_VAR 0 5
63032: ARRAY
63033: PUSH
63034: LD_INT 2
63036: ARRAY
63037: PPUSH
63038: LD_VAR 0 2
63042: PPUSH
63043: LD_VAR 0 3
63047: PPUSH
63048: CALL_OW 298
63052: PUSH
63053: LD_INT 6
63055: LESS
63056: IFFALSE 63155
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
63058: LD_EXP 96
63062: PUSH
63063: LD_VAR 0 6
63067: ARRAY
63068: PUSH
63069: LD_VAR 0 5
63073: ARRAY
63074: PUSH
63075: LD_INT 1
63077: ARRAY
63078: PPUSH
63079: LD_EXP 96
63083: PUSH
63084: LD_VAR 0 6
63088: ARRAY
63089: PUSH
63090: LD_VAR 0 5
63094: ARRAY
63095: PUSH
63096: LD_INT 2
63098: ARRAY
63099: PPUSH
63100: LD_VAR 0 1
63104: PPUSH
63105: CALL_OW 255
63109: PPUSH
63110: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
63114: LD_ADDR_EXP 96
63118: PUSH
63119: LD_EXP 96
63123: PPUSH
63124: LD_VAR 0 6
63128: PPUSH
63129: LD_EXP 96
63133: PUSH
63134: LD_VAR 0 6
63138: ARRAY
63139: PPUSH
63140: LD_VAR 0 5
63144: PPUSH
63145: CALL_OW 3
63149: PPUSH
63150: CALL_OW 1
63154: ST_TO_ADDR
// end ; end ;
63155: GO 62993
63157: POP
63158: POP
// end ;
63159: LD_VAR 0 4
63163: RET
// export function MinerCreateMinefield ( unit , x , y ) ; var i , index , tmp , minesFreeAmount , _x , _y , _d , _r ; begin
63164: LD_INT 0
63166: PPUSH
63167: PPUSH
63168: PPUSH
63169: PPUSH
63170: PPUSH
63171: PPUSH
63172: PPUSH
63173: PPUSH
63174: PPUSH
// if not GetWeapon ( unit ) = ar_miner or not unit in minersList then
63175: LD_VAR 0 1
63179: PPUSH
63180: CALL_OW 264
63184: PUSH
63185: LD_EXP 163
63189: EQUAL
63190: NOT
63191: PUSH
63192: LD_VAR 0 1
63196: PUSH
63197: LD_EXP 95
63201: IN
63202: NOT
63203: OR
63204: IFFALSE 63208
// exit ;
63206: GO 63530
// index := GetElementIndex ( minersList , unit ) ;
63208: LD_ADDR_VAR 0 6
63212: PUSH
63213: LD_EXP 95
63217: PPUSH
63218: LD_VAR 0 1
63222: PPUSH
63223: CALL 23995 0 2
63227: ST_TO_ADDR
// minesFreeAmount := minesLimitPerVehicle - minerMinesList [ index ] ;
63228: LD_ADDR_VAR 0 8
63232: PUSH
63233: LD_EXP 97
63237: PUSH
63238: LD_EXP 96
63242: PUSH
63243: LD_VAR 0 6
63247: ARRAY
63248: MINUS
63249: ST_TO_ADDR
// if not minesFreeAmount then
63250: LD_VAR 0 8
63254: NOT
63255: IFFALSE 63259
// exit ;
63257: GO 63530
// tmp := [ ] ;
63259: LD_ADDR_VAR 0 7
63263: PUSH
63264: EMPTY
63265: ST_TO_ADDR
// for i := 1 to minesFreeAmount do
63266: LD_ADDR_VAR 0 5
63270: PUSH
63271: DOUBLE
63272: LD_INT 1
63274: DEC
63275: ST_TO_ADDR
63276: LD_VAR 0 8
63280: PUSH
63281: FOR_TO
63282: IFFALSE 63477
// begin _d := rand ( 0 , 5 ) ;
63284: LD_ADDR_VAR 0 11
63288: PUSH
63289: LD_INT 0
63291: PPUSH
63292: LD_INT 5
63294: PPUSH
63295: CALL_OW 12
63299: ST_TO_ADDR
// _r := rand ( 2 , 6 ) ;
63300: LD_ADDR_VAR 0 12
63304: PUSH
63305: LD_INT 2
63307: PPUSH
63308: LD_INT 6
63310: PPUSH
63311: CALL_OW 12
63315: ST_TO_ADDR
// _x := ShiftX ( x , _d , _r ) ;
63316: LD_ADDR_VAR 0 9
63320: PUSH
63321: LD_VAR 0 2
63325: PPUSH
63326: LD_VAR 0 11
63330: PPUSH
63331: LD_VAR 0 12
63335: PPUSH
63336: CALL_OW 272
63340: ST_TO_ADDR
// _y := ShiftY ( y , _d , _r ) ;
63341: LD_ADDR_VAR 0 10
63345: PUSH
63346: LD_VAR 0 3
63350: PPUSH
63351: LD_VAR 0 11
63355: PPUSH
63356: LD_VAR 0 12
63360: PPUSH
63361: CALL_OW 273
63365: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not [ _x , _y ] in tmp and not MineAtPos ( _x , _y ) then
63366: LD_VAR 0 9
63370: PPUSH
63371: LD_VAR 0 10
63375: PPUSH
63376: CALL_OW 488
63380: PUSH
63381: LD_VAR 0 9
63385: PUSH
63386: LD_VAR 0 10
63390: PUSH
63391: EMPTY
63392: LIST
63393: LIST
63394: PUSH
63395: LD_VAR 0 7
63399: IN
63400: NOT
63401: AND
63402: PUSH
63403: LD_VAR 0 9
63407: PPUSH
63408: LD_VAR 0 10
63412: PPUSH
63413: CALL_OW 458
63417: NOT
63418: AND
63419: IFFALSE 63461
// tmp := Replace ( tmp , tmp + 1 , [ _x , _y ] ) else
63421: LD_ADDR_VAR 0 7
63425: PUSH
63426: LD_VAR 0 7
63430: PPUSH
63431: LD_VAR 0 7
63435: PUSH
63436: LD_INT 1
63438: PLUS
63439: PPUSH
63440: LD_VAR 0 9
63444: PUSH
63445: LD_VAR 0 10
63449: PUSH
63450: EMPTY
63451: LIST
63452: LIST
63453: PPUSH
63454: CALL_OW 1
63458: ST_TO_ADDR
63459: GO 63475
// i := i - 1 ;
63461: LD_ADDR_VAR 0 5
63465: PUSH
63466: LD_VAR 0 5
63470: PUSH
63471: LD_INT 1
63473: MINUS
63474: ST_TO_ADDR
// end ;
63475: GO 63281
63477: POP
63478: POP
// for i in tmp do
63479: LD_ADDR_VAR 0 5
63483: PUSH
63484: LD_VAR 0 7
63488: PUSH
63489: FOR_IN
63490: IFFALSE 63528
// if not MinerPlaceMine ( unit , i [ 1 ] , i [ 2 ] ) then
63492: LD_VAR 0 1
63496: PPUSH
63497: LD_VAR 0 5
63501: PUSH
63502: LD_INT 1
63504: ARRAY
63505: PPUSH
63506: LD_VAR 0 5
63510: PUSH
63511: LD_INT 2
63513: ARRAY
63514: PPUSH
63515: CALL 62470 0 3
63519: NOT
63520: IFFALSE 63526
// exit ;
63522: POP
63523: POP
63524: GO 63530
63526: GO 63489
63528: POP
63529: POP
// end ;
63530: LD_VAR 0 4
63534: RET
// export function ComBinocular ( unit , x , y ) ; var dist , side , viewRange , _x , _y , _d ; begin
63535: LD_INT 0
63537: PPUSH
63538: PPUSH
63539: PPUSH
63540: PPUSH
63541: PPUSH
63542: PPUSH
63543: PPUSH
// if not GetClass ( unit ) = class_sniper then
63544: LD_VAR 0 1
63548: PPUSH
63549: CALL_OW 257
63553: PUSH
63554: LD_INT 5
63556: EQUAL
63557: NOT
63558: IFFALSE 63562
// exit ;
63560: GO 63950
// dist := 8 ;
63562: LD_ADDR_VAR 0 5
63566: PUSH
63567: LD_INT 8
63569: ST_TO_ADDR
// viewRange := 12 ;
63570: LD_ADDR_VAR 0 7
63574: PUSH
63575: LD_INT 12
63577: ST_TO_ADDR
// side := GetSide ( unit ) ;
63578: LD_ADDR_VAR 0 6
63582: PUSH
63583: LD_VAR 0 1
63587: PPUSH
63588: CALL_OW 255
63592: ST_TO_ADDR
// if GetTech ( tech_opto2 , side ) = state_researched then
63593: LD_INT 61
63595: PPUSH
63596: LD_VAR 0 6
63600: PPUSH
63601: CALL_OW 321
63605: PUSH
63606: LD_INT 2
63608: EQUAL
63609: IFFALSE 63619
// viewRange := 16 ;
63611: LD_ADDR_VAR 0 7
63615: PUSH
63616: LD_INT 16
63618: ST_TO_ADDR
// if GetDistUnitXY ( unit , x , y ) > dist then
63619: LD_VAR 0 1
63623: PPUSH
63624: LD_VAR 0 2
63628: PPUSH
63629: LD_VAR 0 3
63633: PPUSH
63634: CALL_OW 297
63638: PUSH
63639: LD_VAR 0 5
63643: GREATER
63644: IFFALSE 63723
// begin ComMoveXY ( unit , x , y ) ;
63646: LD_VAR 0 1
63650: PPUSH
63651: LD_VAR 0 2
63655: PPUSH
63656: LD_VAR 0 3
63660: PPUSH
63661: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
63665: LD_INT 35
63667: PPUSH
63668: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) then
63672: LD_VAR 0 1
63676: PPUSH
63677: LD_VAR 0 2
63681: PPUSH
63682: LD_VAR 0 3
63686: PPUSH
63687: CALL 54767 0 3
63691: NOT
63692: IFFALSE 63696
// exit ;
63694: GO 63950
// until GetDistUnitXY ( unit , x , y ) < dist ;
63696: LD_VAR 0 1
63700: PPUSH
63701: LD_VAR 0 2
63705: PPUSH
63706: LD_VAR 0 3
63710: PPUSH
63711: CALL_OW 297
63715: PUSH
63716: LD_VAR 0 5
63720: LESS
63721: IFFALSE 63665
// end ; ComTurnXY ( unit , x , y ) ;
63723: LD_VAR 0 1
63727: PPUSH
63728: LD_VAR 0 2
63732: PPUSH
63733: LD_VAR 0 3
63737: PPUSH
63738: CALL_OW 118
// wait ( 5 ) ;
63742: LD_INT 5
63744: PPUSH
63745: CALL_OW 67
// _d := GetDir ( unit ) ;
63749: LD_ADDR_VAR 0 10
63753: PUSH
63754: LD_VAR 0 1
63758: PPUSH
63759: CALL_OW 254
63763: ST_TO_ADDR
// _x := ShiftX ( GetX ( unit ) , _d , dist ) ;
63764: LD_ADDR_VAR 0 8
63768: PUSH
63769: LD_VAR 0 1
63773: PPUSH
63774: CALL_OW 250
63778: PPUSH
63779: LD_VAR 0 10
63783: PPUSH
63784: LD_VAR 0 5
63788: PPUSH
63789: CALL_OW 272
63793: ST_TO_ADDR
// _y := ShiftY ( GetY ( unit ) , _d , dist ) ;
63794: LD_ADDR_VAR 0 9
63798: PUSH
63799: LD_VAR 0 1
63803: PPUSH
63804: CALL_OW 251
63808: PPUSH
63809: LD_VAR 0 10
63813: PPUSH
63814: LD_VAR 0 5
63818: PPUSH
63819: CALL_OW 273
63823: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
63824: LD_VAR 0 8
63828: PPUSH
63829: LD_VAR 0 9
63833: PPUSH
63834: CALL_OW 488
63838: NOT
63839: IFFALSE 63843
// exit ;
63841: GO 63950
// ComAnimCustom ( unit , 1 ) ;
63843: LD_VAR 0 1
63847: PPUSH
63848: LD_INT 1
63850: PPUSH
63851: CALL_OW 592
// PlaceSeeing ( _x , _y , side , viewRange ) ;
63855: LD_VAR 0 8
63859: PPUSH
63860: LD_VAR 0 9
63864: PPUSH
63865: LD_VAR 0 6
63869: PPUSH
63870: LD_VAR 0 7
63874: PPUSH
63875: CALL_OW 330
// repeat wait ( 1 ) ;
63879: LD_INT 1
63881: PPUSH
63882: CALL_OW 67
// until IsIdle ( unit ) or HasTask ( unit ) or not IsOk ( unit ) or IsDead ( unit ) ;
63886: LD_VAR 0 1
63890: PPUSH
63891: CALL_OW 316
63895: PUSH
63896: LD_VAR 0 1
63900: PPUSH
63901: CALL_OW 314
63905: OR
63906: PUSH
63907: LD_VAR 0 1
63911: PPUSH
63912: CALL_OW 302
63916: NOT
63917: OR
63918: PUSH
63919: LD_VAR 0 1
63923: PPUSH
63924: CALL_OW 301
63928: OR
63929: IFFALSE 63879
// RemoveSeeing ( _x , _y , side ) ;
63931: LD_VAR 0 8
63935: PPUSH
63936: LD_VAR 0 9
63940: PPUSH
63941: LD_VAR 0 6
63945: PPUSH
63946: CALL_OW 331
// end ; end_of_file
63950: LD_VAR 0 4
63954: RET
// every 0 0$1 do
63955: GO 63957
63957: DISABLE
// begin enable ;
63958: ENABLE
// ToLua ( updateTimer( & tick & ); ) ;
63959: LD_STRING updateTimer(
63961: PUSH
63962: LD_OWVAR 1
63966: STR
63967: PUSH
63968: LD_STRING );
63970: STR
63971: PPUSH
63972: CALL_OW 559
// end ;
63976: END
// on MapStart ( p ) do begin if streamModeActive then
63977: LD_EXP 98
63981: IFFALSE 63990
// DefineStreamItems ( true ) ;
63983: LD_INT 1
63985: PPUSH
63986: CALL 65638 0 1
// UpdateFactoryWaypoints ( ) ;
63990: CALL 60253 0 0
// end ;
63994: PPOPN 1
63996: END
// export function SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
63997: LD_INT 0
63999: PPUSH
// if p2 = 100 then
64000: LD_VAR 0 2
64004: PUSH
64005: LD_INT 100
64007: EQUAL
64008: IFFALSE 65011
// begin if not StreamModeActive then
64010: LD_EXP 98
64014: NOT
64015: IFFALSE 64025
// StreamModeActive := true ;
64017: LD_ADDR_EXP 98
64021: PUSH
64022: LD_INT 1
64024: ST_TO_ADDR
// if p3 = 0 then
64025: LD_VAR 0 3
64029: PUSH
64030: LD_INT 0
64032: EQUAL
64033: IFFALSE 64039
// InitStreamMode ;
64035: CALL 65174 0 0
// if p3 = 1 then
64039: LD_VAR 0 3
64043: PUSH
64044: LD_INT 1
64046: EQUAL
64047: IFFALSE 64057
// sRocket := true ;
64049: LD_ADDR_EXP 103
64053: PUSH
64054: LD_INT 1
64056: ST_TO_ADDR
// if p3 = 2 then
64057: LD_VAR 0 3
64061: PUSH
64062: LD_INT 2
64064: EQUAL
64065: IFFALSE 64075
// sSpeed := true ;
64067: LD_ADDR_EXP 102
64071: PUSH
64072: LD_INT 1
64074: ST_TO_ADDR
// if p3 = 3 then
64075: LD_VAR 0 3
64079: PUSH
64080: LD_INT 3
64082: EQUAL
64083: IFFALSE 64093
// sEngine := true ;
64085: LD_ADDR_EXP 104
64089: PUSH
64090: LD_INT 1
64092: ST_TO_ADDR
// if p3 = 4 then
64093: LD_VAR 0 3
64097: PUSH
64098: LD_INT 4
64100: EQUAL
64101: IFFALSE 64111
// sSpec := true ;
64103: LD_ADDR_EXP 101
64107: PUSH
64108: LD_INT 1
64110: ST_TO_ADDR
// if p3 = 5 then
64111: LD_VAR 0 3
64115: PUSH
64116: LD_INT 5
64118: EQUAL
64119: IFFALSE 64129
// sLevel := true ;
64121: LD_ADDR_EXP 105
64125: PUSH
64126: LD_INT 1
64128: ST_TO_ADDR
// if p3 = 6 then
64129: LD_VAR 0 3
64133: PUSH
64134: LD_INT 6
64136: EQUAL
64137: IFFALSE 64147
// sArmoury := true ;
64139: LD_ADDR_EXP 106
64143: PUSH
64144: LD_INT 1
64146: ST_TO_ADDR
// if p3 = 7 then
64147: LD_VAR 0 3
64151: PUSH
64152: LD_INT 7
64154: EQUAL
64155: IFFALSE 64165
// sRadar := true ;
64157: LD_ADDR_EXP 107
64161: PUSH
64162: LD_INT 1
64164: ST_TO_ADDR
// if p3 = 8 then
64165: LD_VAR 0 3
64169: PUSH
64170: LD_INT 8
64172: EQUAL
64173: IFFALSE 64183
// sBunker := true ;
64175: LD_ADDR_EXP 108
64179: PUSH
64180: LD_INT 1
64182: ST_TO_ADDR
// if p3 = 9 then
64183: LD_VAR 0 3
64187: PUSH
64188: LD_INT 9
64190: EQUAL
64191: IFFALSE 64201
// sHack := true ;
64193: LD_ADDR_EXP 109
64197: PUSH
64198: LD_INT 1
64200: ST_TO_ADDR
// if p3 = 10 then
64201: LD_VAR 0 3
64205: PUSH
64206: LD_INT 10
64208: EQUAL
64209: IFFALSE 64219
// sFire := true ;
64211: LD_ADDR_EXP 110
64215: PUSH
64216: LD_INT 1
64218: ST_TO_ADDR
// if p3 = 11 then
64219: LD_VAR 0 3
64223: PUSH
64224: LD_INT 11
64226: EQUAL
64227: IFFALSE 64237
// sRefresh := true ;
64229: LD_ADDR_EXP 111
64233: PUSH
64234: LD_INT 1
64236: ST_TO_ADDR
// if p3 = 12 then
64237: LD_VAR 0 3
64241: PUSH
64242: LD_INT 12
64244: EQUAL
64245: IFFALSE 64255
// sExp := true ;
64247: LD_ADDR_EXP 112
64251: PUSH
64252: LD_INT 1
64254: ST_TO_ADDR
// if p3 = 13 then
64255: LD_VAR 0 3
64259: PUSH
64260: LD_INT 13
64262: EQUAL
64263: IFFALSE 64273
// sDepot := true ;
64265: LD_ADDR_EXP 113
64269: PUSH
64270: LD_INT 1
64272: ST_TO_ADDR
// if p3 = 14 then
64273: LD_VAR 0 3
64277: PUSH
64278: LD_INT 14
64280: EQUAL
64281: IFFALSE 64291
// sFlag := true ;
64283: LD_ADDR_EXP 114
64287: PUSH
64288: LD_INT 1
64290: ST_TO_ADDR
// if p3 = 15 then
64291: LD_VAR 0 3
64295: PUSH
64296: LD_INT 15
64298: EQUAL
64299: IFFALSE 64309
// sKamikadze := true ;
64301: LD_ADDR_EXP 122
64305: PUSH
64306: LD_INT 1
64308: ST_TO_ADDR
// if p3 = 16 then
64309: LD_VAR 0 3
64313: PUSH
64314: LD_INT 16
64316: EQUAL
64317: IFFALSE 64327
// sTroll := true ;
64319: LD_ADDR_EXP 123
64323: PUSH
64324: LD_INT 1
64326: ST_TO_ADDR
// if p3 = 17 then
64327: LD_VAR 0 3
64331: PUSH
64332: LD_INT 17
64334: EQUAL
64335: IFFALSE 64345
// sSlow := true ;
64337: LD_ADDR_EXP 124
64341: PUSH
64342: LD_INT 1
64344: ST_TO_ADDR
// if p3 = 18 then
64345: LD_VAR 0 3
64349: PUSH
64350: LD_INT 18
64352: EQUAL
64353: IFFALSE 64363
// sLack := true ;
64355: LD_ADDR_EXP 125
64359: PUSH
64360: LD_INT 1
64362: ST_TO_ADDR
// if p3 = 19 then
64363: LD_VAR 0 3
64367: PUSH
64368: LD_INT 19
64370: EQUAL
64371: IFFALSE 64381
// sTank := true ;
64373: LD_ADDR_EXP 127
64377: PUSH
64378: LD_INT 1
64380: ST_TO_ADDR
// if p3 = 20 then
64381: LD_VAR 0 3
64385: PUSH
64386: LD_INT 20
64388: EQUAL
64389: IFFALSE 64399
// sRemote := true ;
64391: LD_ADDR_EXP 128
64395: PUSH
64396: LD_INT 1
64398: ST_TO_ADDR
// if p3 = 21 then
64399: LD_VAR 0 3
64403: PUSH
64404: LD_INT 21
64406: EQUAL
64407: IFFALSE 64417
// sPowell := true ;
64409: LD_ADDR_EXP 129
64413: PUSH
64414: LD_INT 1
64416: ST_TO_ADDR
// if p3 = 22 then
64417: LD_VAR 0 3
64421: PUSH
64422: LD_INT 22
64424: EQUAL
64425: IFFALSE 64435
// sTeleport := true ;
64427: LD_ADDR_EXP 132
64431: PUSH
64432: LD_INT 1
64434: ST_TO_ADDR
// if p3 = 23 then
64435: LD_VAR 0 3
64439: PUSH
64440: LD_INT 23
64442: EQUAL
64443: IFFALSE 64453
// sOilTower := true ;
64445: LD_ADDR_EXP 134
64449: PUSH
64450: LD_INT 1
64452: ST_TO_ADDR
// if p3 = 24 then
64453: LD_VAR 0 3
64457: PUSH
64458: LD_INT 24
64460: EQUAL
64461: IFFALSE 64471
// sShovel := true ;
64463: LD_ADDR_EXP 135
64467: PUSH
64468: LD_INT 1
64470: ST_TO_ADDR
// if p3 = 25 then
64471: LD_VAR 0 3
64475: PUSH
64476: LD_INT 25
64478: EQUAL
64479: IFFALSE 64489
// sSheik := true ;
64481: LD_ADDR_EXP 136
64485: PUSH
64486: LD_INT 1
64488: ST_TO_ADDR
// if p3 = 26 then
64489: LD_VAR 0 3
64493: PUSH
64494: LD_INT 26
64496: EQUAL
64497: IFFALSE 64507
// sEarthquake := true ;
64499: LD_ADDR_EXP 138
64503: PUSH
64504: LD_INT 1
64506: ST_TO_ADDR
// if p3 = 27 then
64507: LD_VAR 0 3
64511: PUSH
64512: LD_INT 27
64514: EQUAL
64515: IFFALSE 64525
// sAI := true ;
64517: LD_ADDR_EXP 139
64521: PUSH
64522: LD_INT 1
64524: ST_TO_ADDR
// if p3 = 28 then
64525: LD_VAR 0 3
64529: PUSH
64530: LD_INT 28
64532: EQUAL
64533: IFFALSE 64543
// sCargo := true ;
64535: LD_ADDR_EXP 142
64539: PUSH
64540: LD_INT 1
64542: ST_TO_ADDR
// if p3 = 29 then
64543: LD_VAR 0 3
64547: PUSH
64548: LD_INT 29
64550: EQUAL
64551: IFFALSE 64561
// sDLaser := true ;
64553: LD_ADDR_EXP 143
64557: PUSH
64558: LD_INT 1
64560: ST_TO_ADDR
// if p3 = 30 then
64561: LD_VAR 0 3
64565: PUSH
64566: LD_INT 30
64568: EQUAL
64569: IFFALSE 64579
// sExchange := true ;
64571: LD_ADDR_EXP 144
64575: PUSH
64576: LD_INT 1
64578: ST_TO_ADDR
// if p3 = 31 then
64579: LD_VAR 0 3
64583: PUSH
64584: LD_INT 31
64586: EQUAL
64587: IFFALSE 64597
// sFac := true ;
64589: LD_ADDR_EXP 145
64593: PUSH
64594: LD_INT 1
64596: ST_TO_ADDR
// if p3 = 32 then
64597: LD_VAR 0 3
64601: PUSH
64602: LD_INT 32
64604: EQUAL
64605: IFFALSE 64615
// sPower := true ;
64607: LD_ADDR_EXP 146
64611: PUSH
64612: LD_INT 1
64614: ST_TO_ADDR
// if p3 = 33 then
64615: LD_VAR 0 3
64619: PUSH
64620: LD_INT 33
64622: EQUAL
64623: IFFALSE 64633
// sRandom := true ;
64625: LD_ADDR_EXP 147
64629: PUSH
64630: LD_INT 1
64632: ST_TO_ADDR
// if p3 = 34 then
64633: LD_VAR 0 3
64637: PUSH
64638: LD_INT 34
64640: EQUAL
64641: IFFALSE 64651
// sShield := true ;
64643: LD_ADDR_EXP 148
64647: PUSH
64648: LD_INT 1
64650: ST_TO_ADDR
// if p3 = 35 then
64651: LD_VAR 0 3
64655: PUSH
64656: LD_INT 35
64658: EQUAL
64659: IFFALSE 64669
// sTime := true ;
64661: LD_ADDR_EXP 149
64665: PUSH
64666: LD_INT 1
64668: ST_TO_ADDR
// if p3 = 36 then
64669: LD_VAR 0 3
64673: PUSH
64674: LD_INT 36
64676: EQUAL
64677: IFFALSE 64687
// sTools := true ;
64679: LD_ADDR_EXP 150
64683: PUSH
64684: LD_INT 1
64686: ST_TO_ADDR
// if p3 = 101 then
64687: LD_VAR 0 3
64691: PUSH
64692: LD_INT 101
64694: EQUAL
64695: IFFALSE 64705
// sSold := true ;
64697: LD_ADDR_EXP 115
64701: PUSH
64702: LD_INT 1
64704: ST_TO_ADDR
// if p3 = 102 then
64705: LD_VAR 0 3
64709: PUSH
64710: LD_INT 102
64712: EQUAL
64713: IFFALSE 64723
// sDiff := true ;
64715: LD_ADDR_EXP 116
64719: PUSH
64720: LD_INT 1
64722: ST_TO_ADDR
// if p3 = 103 then
64723: LD_VAR 0 3
64727: PUSH
64728: LD_INT 103
64730: EQUAL
64731: IFFALSE 64741
// sFog := true ;
64733: LD_ADDR_EXP 119
64737: PUSH
64738: LD_INT 1
64740: ST_TO_ADDR
// if p3 = 104 then
64741: LD_VAR 0 3
64745: PUSH
64746: LD_INT 104
64748: EQUAL
64749: IFFALSE 64759
// sReset := true ;
64751: LD_ADDR_EXP 120
64755: PUSH
64756: LD_INT 1
64758: ST_TO_ADDR
// if p3 = 105 then
64759: LD_VAR 0 3
64763: PUSH
64764: LD_INT 105
64766: EQUAL
64767: IFFALSE 64777
// sSun := true ;
64769: LD_ADDR_EXP 121
64773: PUSH
64774: LD_INT 1
64776: ST_TO_ADDR
// if p3 = 106 then
64777: LD_VAR 0 3
64781: PUSH
64782: LD_INT 106
64784: EQUAL
64785: IFFALSE 64795
// sTiger := true ;
64787: LD_ADDR_EXP 117
64791: PUSH
64792: LD_INT 1
64794: ST_TO_ADDR
// if p3 = 107 then
64795: LD_VAR 0 3
64799: PUSH
64800: LD_INT 107
64802: EQUAL
64803: IFFALSE 64813
// sBomb := true ;
64805: LD_ADDR_EXP 118
64809: PUSH
64810: LD_INT 1
64812: ST_TO_ADDR
// if p3 = 108 then
64813: LD_VAR 0 3
64817: PUSH
64818: LD_INT 108
64820: EQUAL
64821: IFFALSE 64831
// sWound := true ;
64823: LD_ADDR_EXP 126
64827: PUSH
64828: LD_INT 1
64830: ST_TO_ADDR
// if p3 = 109 then
64831: LD_VAR 0 3
64835: PUSH
64836: LD_INT 109
64838: EQUAL
64839: IFFALSE 64849
// sBetray := true ;
64841: LD_ADDR_EXP 130
64845: PUSH
64846: LD_INT 1
64848: ST_TO_ADDR
// if p3 = 110 then
64849: LD_VAR 0 3
64853: PUSH
64854: LD_INT 110
64856: EQUAL
64857: IFFALSE 64867
// sContamin := true ;
64859: LD_ADDR_EXP 131
64863: PUSH
64864: LD_INT 1
64866: ST_TO_ADDR
// if p3 = 111 then
64867: LD_VAR 0 3
64871: PUSH
64872: LD_INT 111
64874: EQUAL
64875: IFFALSE 64885
// sOil := true ;
64877: LD_ADDR_EXP 133
64881: PUSH
64882: LD_INT 1
64884: ST_TO_ADDR
// if p3 = 112 then
64885: LD_VAR 0 3
64889: PUSH
64890: LD_INT 112
64892: EQUAL
64893: IFFALSE 64903
// sStu := true ;
64895: LD_ADDR_EXP 137
64899: PUSH
64900: LD_INT 1
64902: ST_TO_ADDR
// if p3 = 113 then
64903: LD_VAR 0 3
64907: PUSH
64908: LD_INT 113
64910: EQUAL
64911: IFFALSE 64921
// sBazooka := true ;
64913: LD_ADDR_EXP 140
64917: PUSH
64918: LD_INT 1
64920: ST_TO_ADDR
// if p3 = 114 then
64921: LD_VAR 0 3
64925: PUSH
64926: LD_INT 114
64928: EQUAL
64929: IFFALSE 64939
// sMortar := true ;
64931: LD_ADDR_EXP 141
64935: PUSH
64936: LD_INT 1
64938: ST_TO_ADDR
// if p3 = 115 then
64939: LD_VAR 0 3
64943: PUSH
64944: LD_INT 115
64946: EQUAL
64947: IFFALSE 64957
// sRanger := true ;
64949: LD_ADDR_EXP 151
64953: PUSH
64954: LD_INT 1
64956: ST_TO_ADDR
// if p3 = 116 then
64957: LD_VAR 0 3
64961: PUSH
64962: LD_INT 116
64964: EQUAL
64965: IFFALSE 64975
// sComputer := true ;
64967: LD_ADDR_EXP 152
64971: PUSH
64972: LD_INT 1
64974: ST_TO_ADDR
// if p3 = 117 then
64975: LD_VAR 0 3
64979: PUSH
64980: LD_INT 117
64982: EQUAL
64983: IFFALSE 64993
// s30 := true ;
64985: LD_ADDR_EXP 153
64989: PUSH
64990: LD_INT 1
64992: ST_TO_ADDR
// if p3 = 118 then
64993: LD_VAR 0 3
64997: PUSH
64998: LD_INT 118
65000: EQUAL
65001: IFFALSE 65011
// s60 := true ;
65003: LD_ADDR_EXP 154
65007: PUSH
65008: LD_INT 1
65010: ST_TO_ADDR
// end ; if p2 = 101 then
65011: LD_VAR 0 2
65015: PUSH
65016: LD_INT 101
65018: EQUAL
65019: IFFALSE 65147
// begin case p3 of 1 :
65021: LD_VAR 0 3
65025: PUSH
65026: LD_INT 1
65028: DOUBLE
65029: EQUAL
65030: IFTRUE 65034
65032: GO 65041
65034: POP
// hHackUnlimitedResources ; 2 :
65035: CALL 77245 0 0
65039: GO 65147
65041: LD_INT 2
65043: DOUBLE
65044: EQUAL
65045: IFTRUE 65049
65047: GO 65056
65049: POP
// hHackSetLevel10 ; 3 :
65050: CALL 77378 0 0
65054: GO 65147
65056: LD_INT 3
65058: DOUBLE
65059: EQUAL
65060: IFTRUE 65064
65062: GO 65071
65064: POP
// hHackSetLevel10YourUnits ; 4 :
65065: CALL 77463 0 0
65069: GO 65147
65071: LD_INT 4
65073: DOUBLE
65074: EQUAL
65075: IFTRUE 65079
65077: GO 65086
65079: POP
// hHackInvincible ; 5 :
65080: CALL 77911 0 0
65084: GO 65147
65086: LD_INT 5
65088: DOUBLE
65089: EQUAL
65090: IFTRUE 65094
65092: GO 65101
65094: POP
// hHackInvisible ; 6 :
65095: CALL 78022 0 0
65099: GO 65147
65101: LD_INT 6
65103: DOUBLE
65104: EQUAL
65105: IFTRUE 65109
65107: GO 65116
65109: POP
// hHackChangeYourSide ; 7 :
65110: CALL 78079 0 0
65114: GO 65147
65116: LD_INT 7
65118: DOUBLE
65119: EQUAL
65120: IFTRUE 65124
65122: GO 65131
65124: POP
// hHackChangeUnitSide ; 8 :
65125: CALL 78121 0 0
65129: GO 65147
65131: LD_INT 8
65133: DOUBLE
65134: EQUAL
65135: IFTRUE 65139
65137: GO 65146
65139: POP
// hHackFog ; end ;
65140: CALL 78222 0 0
65144: GO 65147
65146: POP
// end ; end ;
65147: LD_VAR 0 7
65151: RET
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger , sComputer , s30 , s60 ; every 0 0$1 do
65152: GO 65154
65154: DISABLE
// begin ToLua ( initStreamRollete(); ) ;
65155: LD_STRING initStreamRollete();
65157: PPUSH
65158: CALL_OW 559
// InitStreamMode ;
65162: CALL 65174 0 0
// DefineStreamItems ( false ) ;
65166: LD_INT 0
65168: PPUSH
65169: CALL 65638 0 1
// end ;
65173: END
// function InitStreamMode ; begin
65174: LD_INT 0
65176: PPUSH
// streamModeActive := false ;
65177: LD_ADDR_EXP 98
65181: PUSH
65182: LD_INT 0
65184: ST_TO_ADDR
// normalCounter := 36 ;
65185: LD_ADDR_EXP 99
65189: PUSH
65190: LD_INT 36
65192: ST_TO_ADDR
// hardcoreCounter := 18 ;
65193: LD_ADDR_EXP 100
65197: PUSH
65198: LD_INT 18
65200: ST_TO_ADDR
// sRocket := false ;
65201: LD_ADDR_EXP 103
65205: PUSH
65206: LD_INT 0
65208: ST_TO_ADDR
// sSpeed := false ;
65209: LD_ADDR_EXP 102
65213: PUSH
65214: LD_INT 0
65216: ST_TO_ADDR
// sEngine := false ;
65217: LD_ADDR_EXP 104
65221: PUSH
65222: LD_INT 0
65224: ST_TO_ADDR
// sSpec := false ;
65225: LD_ADDR_EXP 101
65229: PUSH
65230: LD_INT 0
65232: ST_TO_ADDR
// sLevel := false ;
65233: LD_ADDR_EXP 105
65237: PUSH
65238: LD_INT 0
65240: ST_TO_ADDR
// sArmoury := false ;
65241: LD_ADDR_EXP 106
65245: PUSH
65246: LD_INT 0
65248: ST_TO_ADDR
// sRadar := false ;
65249: LD_ADDR_EXP 107
65253: PUSH
65254: LD_INT 0
65256: ST_TO_ADDR
// sBunker := false ;
65257: LD_ADDR_EXP 108
65261: PUSH
65262: LD_INT 0
65264: ST_TO_ADDR
// sHack := false ;
65265: LD_ADDR_EXP 109
65269: PUSH
65270: LD_INT 0
65272: ST_TO_ADDR
// sFire := false ;
65273: LD_ADDR_EXP 110
65277: PUSH
65278: LD_INT 0
65280: ST_TO_ADDR
// sRefresh := false ;
65281: LD_ADDR_EXP 111
65285: PUSH
65286: LD_INT 0
65288: ST_TO_ADDR
// sExp := false ;
65289: LD_ADDR_EXP 112
65293: PUSH
65294: LD_INT 0
65296: ST_TO_ADDR
// sDepot := false ;
65297: LD_ADDR_EXP 113
65301: PUSH
65302: LD_INT 0
65304: ST_TO_ADDR
// sFlag := false ;
65305: LD_ADDR_EXP 114
65309: PUSH
65310: LD_INT 0
65312: ST_TO_ADDR
// sKamikadze := false ;
65313: LD_ADDR_EXP 122
65317: PUSH
65318: LD_INT 0
65320: ST_TO_ADDR
// sTroll := false ;
65321: LD_ADDR_EXP 123
65325: PUSH
65326: LD_INT 0
65328: ST_TO_ADDR
// sSlow := false ;
65329: LD_ADDR_EXP 124
65333: PUSH
65334: LD_INT 0
65336: ST_TO_ADDR
// sLack := false ;
65337: LD_ADDR_EXP 125
65341: PUSH
65342: LD_INT 0
65344: ST_TO_ADDR
// sTank := false ;
65345: LD_ADDR_EXP 127
65349: PUSH
65350: LD_INT 0
65352: ST_TO_ADDR
// sRemote := false ;
65353: LD_ADDR_EXP 128
65357: PUSH
65358: LD_INT 0
65360: ST_TO_ADDR
// sPowell := false ;
65361: LD_ADDR_EXP 129
65365: PUSH
65366: LD_INT 0
65368: ST_TO_ADDR
// sTeleport := false ;
65369: LD_ADDR_EXP 132
65373: PUSH
65374: LD_INT 0
65376: ST_TO_ADDR
// sOilTower := false ;
65377: LD_ADDR_EXP 134
65381: PUSH
65382: LD_INT 0
65384: ST_TO_ADDR
// sShovel := false ;
65385: LD_ADDR_EXP 135
65389: PUSH
65390: LD_INT 0
65392: ST_TO_ADDR
// sSheik := false ;
65393: LD_ADDR_EXP 136
65397: PUSH
65398: LD_INT 0
65400: ST_TO_ADDR
// sEarthquake := false ;
65401: LD_ADDR_EXP 138
65405: PUSH
65406: LD_INT 0
65408: ST_TO_ADDR
// sAI := false ;
65409: LD_ADDR_EXP 139
65413: PUSH
65414: LD_INT 0
65416: ST_TO_ADDR
// sCargo := false ;
65417: LD_ADDR_EXP 142
65421: PUSH
65422: LD_INT 0
65424: ST_TO_ADDR
// sDLaser := false ;
65425: LD_ADDR_EXP 143
65429: PUSH
65430: LD_INT 0
65432: ST_TO_ADDR
// sExchange := false ;
65433: LD_ADDR_EXP 144
65437: PUSH
65438: LD_INT 0
65440: ST_TO_ADDR
// sFac := false ;
65441: LD_ADDR_EXP 145
65445: PUSH
65446: LD_INT 0
65448: ST_TO_ADDR
// sPower := false ;
65449: LD_ADDR_EXP 146
65453: PUSH
65454: LD_INT 0
65456: ST_TO_ADDR
// sRandom := false ;
65457: LD_ADDR_EXP 147
65461: PUSH
65462: LD_INT 0
65464: ST_TO_ADDR
// sShield := false ;
65465: LD_ADDR_EXP 148
65469: PUSH
65470: LD_INT 0
65472: ST_TO_ADDR
// sTime := false ;
65473: LD_ADDR_EXP 149
65477: PUSH
65478: LD_INT 0
65480: ST_TO_ADDR
// sTools := false ;
65481: LD_ADDR_EXP 150
65485: PUSH
65486: LD_INT 0
65488: ST_TO_ADDR
// sSold := false ;
65489: LD_ADDR_EXP 115
65493: PUSH
65494: LD_INT 0
65496: ST_TO_ADDR
// sDiff := false ;
65497: LD_ADDR_EXP 116
65501: PUSH
65502: LD_INT 0
65504: ST_TO_ADDR
// sFog := false ;
65505: LD_ADDR_EXP 119
65509: PUSH
65510: LD_INT 0
65512: ST_TO_ADDR
// sReset := false ;
65513: LD_ADDR_EXP 120
65517: PUSH
65518: LD_INT 0
65520: ST_TO_ADDR
// sSun := false ;
65521: LD_ADDR_EXP 121
65525: PUSH
65526: LD_INT 0
65528: ST_TO_ADDR
// sTiger := false ;
65529: LD_ADDR_EXP 117
65533: PUSH
65534: LD_INT 0
65536: ST_TO_ADDR
// sBomb := false ;
65537: LD_ADDR_EXP 118
65541: PUSH
65542: LD_INT 0
65544: ST_TO_ADDR
// sWound := false ;
65545: LD_ADDR_EXP 126
65549: PUSH
65550: LD_INT 0
65552: ST_TO_ADDR
// sBetray := false ;
65553: LD_ADDR_EXP 130
65557: PUSH
65558: LD_INT 0
65560: ST_TO_ADDR
// sContamin := false ;
65561: LD_ADDR_EXP 131
65565: PUSH
65566: LD_INT 0
65568: ST_TO_ADDR
// sOil := false ;
65569: LD_ADDR_EXP 133
65573: PUSH
65574: LD_INT 0
65576: ST_TO_ADDR
// sStu := false ;
65577: LD_ADDR_EXP 137
65581: PUSH
65582: LD_INT 0
65584: ST_TO_ADDR
// sBazooka := false ;
65585: LD_ADDR_EXP 140
65589: PUSH
65590: LD_INT 0
65592: ST_TO_ADDR
// sMortar := false ;
65593: LD_ADDR_EXP 141
65597: PUSH
65598: LD_INT 0
65600: ST_TO_ADDR
// sRanger := false ;
65601: LD_ADDR_EXP 151
65605: PUSH
65606: LD_INT 0
65608: ST_TO_ADDR
// sComputer := false ;
65609: LD_ADDR_EXP 152
65613: PUSH
65614: LD_INT 0
65616: ST_TO_ADDR
// s30 := false ;
65617: LD_ADDR_EXP 153
65621: PUSH
65622: LD_INT 0
65624: ST_TO_ADDR
// s60 := false ;
65625: LD_ADDR_EXP 154
65629: PUSH
65630: LD_INT 0
65632: ST_TO_ADDR
// end ;
65633: LD_VAR 0 1
65637: RET
// function DefineStreamItems ( isGameLoad ) ; var tmp , flags , normal , hardcore , active , i ; begin
65638: LD_INT 0
65640: PPUSH
65641: PPUSH
65642: PPUSH
65643: PPUSH
65644: PPUSH
65645: PPUSH
65646: PPUSH
// result := [ ] ;
65647: LD_ADDR_VAR 0 2
65651: PUSH
65652: EMPTY
65653: ST_TO_ADDR
// if campaign_id = 1 then
65654: LD_OWVAR 69
65658: PUSH
65659: LD_INT 1
65661: EQUAL
65662: IFFALSE 68828
// begin case mission_number of 1 :
65664: LD_OWVAR 70
65668: PUSH
65669: LD_INT 1
65671: DOUBLE
65672: EQUAL
65673: IFTRUE 65677
65675: GO 65753
65677: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 , 116 , 117 , 118 ] ] ; 2 :
65678: LD_ADDR_VAR 0 2
65682: PUSH
65683: LD_INT 2
65685: PUSH
65686: LD_INT 4
65688: PUSH
65689: LD_INT 11
65691: PUSH
65692: LD_INT 12
65694: PUSH
65695: LD_INT 15
65697: PUSH
65698: LD_INT 16
65700: PUSH
65701: LD_INT 22
65703: PUSH
65704: LD_INT 23
65706: PUSH
65707: LD_INT 26
65709: PUSH
65710: EMPTY
65711: LIST
65712: LIST
65713: LIST
65714: LIST
65715: LIST
65716: LIST
65717: LIST
65718: LIST
65719: LIST
65720: PUSH
65721: LD_INT 101
65723: PUSH
65724: LD_INT 102
65726: PUSH
65727: LD_INT 106
65729: PUSH
65730: LD_INT 116
65732: PUSH
65733: LD_INT 117
65735: PUSH
65736: LD_INT 118
65738: PUSH
65739: EMPTY
65740: LIST
65741: LIST
65742: LIST
65743: LIST
65744: LIST
65745: LIST
65746: PUSH
65747: EMPTY
65748: LIST
65749: LIST
65750: ST_TO_ADDR
65751: GO 68826
65753: LD_INT 2
65755: DOUBLE
65756: EQUAL
65757: IFTRUE 65761
65759: GO 65845
65761: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 3 :
65762: LD_ADDR_VAR 0 2
65766: PUSH
65767: LD_INT 2
65769: PUSH
65770: LD_INT 4
65772: PUSH
65773: LD_INT 11
65775: PUSH
65776: LD_INT 12
65778: PUSH
65779: LD_INT 15
65781: PUSH
65782: LD_INT 16
65784: PUSH
65785: LD_INT 22
65787: PUSH
65788: LD_INT 23
65790: PUSH
65791: LD_INT 26
65793: PUSH
65794: EMPTY
65795: LIST
65796: LIST
65797: LIST
65798: LIST
65799: LIST
65800: LIST
65801: LIST
65802: LIST
65803: LIST
65804: PUSH
65805: LD_INT 101
65807: PUSH
65808: LD_INT 102
65810: PUSH
65811: LD_INT 105
65813: PUSH
65814: LD_INT 106
65816: PUSH
65817: LD_INT 108
65819: PUSH
65820: LD_INT 116
65822: PUSH
65823: LD_INT 117
65825: PUSH
65826: LD_INT 118
65828: PUSH
65829: EMPTY
65830: LIST
65831: LIST
65832: LIST
65833: LIST
65834: LIST
65835: LIST
65836: LIST
65837: LIST
65838: PUSH
65839: EMPTY
65840: LIST
65841: LIST
65842: ST_TO_ADDR
65843: GO 68826
65845: LD_INT 3
65847: DOUBLE
65848: EQUAL
65849: IFTRUE 65853
65851: GO 65941
65853: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 4 :
65854: LD_ADDR_VAR 0 2
65858: PUSH
65859: LD_INT 2
65861: PUSH
65862: LD_INT 4
65864: PUSH
65865: LD_INT 5
65867: PUSH
65868: LD_INT 11
65870: PUSH
65871: LD_INT 12
65873: PUSH
65874: LD_INT 15
65876: PUSH
65877: LD_INT 16
65879: PUSH
65880: LD_INT 22
65882: PUSH
65883: LD_INT 26
65885: PUSH
65886: LD_INT 36
65888: PUSH
65889: EMPTY
65890: LIST
65891: LIST
65892: LIST
65893: LIST
65894: LIST
65895: LIST
65896: LIST
65897: LIST
65898: LIST
65899: LIST
65900: PUSH
65901: LD_INT 101
65903: PUSH
65904: LD_INT 102
65906: PUSH
65907: LD_INT 105
65909: PUSH
65910: LD_INT 106
65912: PUSH
65913: LD_INT 108
65915: PUSH
65916: LD_INT 116
65918: PUSH
65919: LD_INT 117
65921: PUSH
65922: LD_INT 118
65924: PUSH
65925: EMPTY
65926: LIST
65927: LIST
65928: LIST
65929: LIST
65930: LIST
65931: LIST
65932: LIST
65933: LIST
65934: PUSH
65935: EMPTY
65936: LIST
65937: LIST
65938: ST_TO_ADDR
65939: GO 68826
65941: LD_INT 4
65943: DOUBLE
65944: EQUAL
65945: IFTRUE 65949
65947: GO 66045
65949: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 5 :
65950: LD_ADDR_VAR 0 2
65954: PUSH
65955: LD_INT 2
65957: PUSH
65958: LD_INT 4
65960: PUSH
65961: LD_INT 5
65963: PUSH
65964: LD_INT 8
65966: PUSH
65967: LD_INT 11
65969: PUSH
65970: LD_INT 12
65972: PUSH
65973: LD_INT 15
65975: PUSH
65976: LD_INT 16
65978: PUSH
65979: LD_INT 22
65981: PUSH
65982: LD_INT 23
65984: PUSH
65985: LD_INT 26
65987: PUSH
65988: LD_INT 36
65990: PUSH
65991: EMPTY
65992: LIST
65993: LIST
65994: LIST
65995: LIST
65996: LIST
65997: LIST
65998: LIST
65999: LIST
66000: LIST
66001: LIST
66002: LIST
66003: LIST
66004: PUSH
66005: LD_INT 101
66007: PUSH
66008: LD_INT 102
66010: PUSH
66011: LD_INT 105
66013: PUSH
66014: LD_INT 106
66016: PUSH
66017: LD_INT 108
66019: PUSH
66020: LD_INT 116
66022: PUSH
66023: LD_INT 117
66025: PUSH
66026: LD_INT 118
66028: PUSH
66029: EMPTY
66030: LIST
66031: LIST
66032: LIST
66033: LIST
66034: LIST
66035: LIST
66036: LIST
66037: LIST
66038: PUSH
66039: EMPTY
66040: LIST
66041: LIST
66042: ST_TO_ADDR
66043: GO 68826
66045: LD_INT 5
66047: DOUBLE
66048: EQUAL
66049: IFTRUE 66053
66051: GO 66165
66053: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 6 :
66054: LD_ADDR_VAR 0 2
66058: PUSH
66059: LD_INT 2
66061: PUSH
66062: LD_INT 4
66064: PUSH
66065: LD_INT 5
66067: PUSH
66068: LD_INT 6
66070: PUSH
66071: LD_INT 8
66073: PUSH
66074: LD_INT 11
66076: PUSH
66077: LD_INT 12
66079: PUSH
66080: LD_INT 15
66082: PUSH
66083: LD_INT 16
66085: PUSH
66086: LD_INT 22
66088: PUSH
66089: LD_INT 23
66091: PUSH
66092: LD_INT 25
66094: PUSH
66095: LD_INT 26
66097: PUSH
66098: LD_INT 36
66100: PUSH
66101: EMPTY
66102: LIST
66103: LIST
66104: LIST
66105: LIST
66106: LIST
66107: LIST
66108: LIST
66109: LIST
66110: LIST
66111: LIST
66112: LIST
66113: LIST
66114: LIST
66115: LIST
66116: PUSH
66117: LD_INT 101
66119: PUSH
66120: LD_INT 102
66122: PUSH
66123: LD_INT 105
66125: PUSH
66126: LD_INT 106
66128: PUSH
66129: LD_INT 108
66131: PUSH
66132: LD_INT 109
66134: PUSH
66135: LD_INT 112
66137: PUSH
66138: LD_INT 116
66140: PUSH
66141: LD_INT 117
66143: PUSH
66144: LD_INT 118
66146: PUSH
66147: EMPTY
66148: LIST
66149: LIST
66150: LIST
66151: LIST
66152: LIST
66153: LIST
66154: LIST
66155: LIST
66156: LIST
66157: LIST
66158: PUSH
66159: EMPTY
66160: LIST
66161: LIST
66162: ST_TO_ADDR
66163: GO 68826
66165: LD_INT 6
66167: DOUBLE
66168: EQUAL
66169: IFTRUE 66173
66171: GO 66305
66173: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 7 :
66174: LD_ADDR_VAR 0 2
66178: PUSH
66179: LD_INT 2
66181: PUSH
66182: LD_INT 4
66184: PUSH
66185: LD_INT 5
66187: PUSH
66188: LD_INT 6
66190: PUSH
66191: LD_INT 8
66193: PUSH
66194: LD_INT 11
66196: PUSH
66197: LD_INT 12
66199: PUSH
66200: LD_INT 15
66202: PUSH
66203: LD_INT 16
66205: PUSH
66206: LD_INT 20
66208: PUSH
66209: LD_INT 21
66211: PUSH
66212: LD_INT 22
66214: PUSH
66215: LD_INT 23
66217: PUSH
66218: LD_INT 25
66220: PUSH
66221: LD_INT 26
66223: PUSH
66224: LD_INT 30
66226: PUSH
66227: LD_INT 31
66229: PUSH
66230: LD_INT 32
66232: PUSH
66233: LD_INT 36
66235: PUSH
66236: EMPTY
66237: LIST
66238: LIST
66239: LIST
66240: LIST
66241: LIST
66242: LIST
66243: LIST
66244: LIST
66245: LIST
66246: LIST
66247: LIST
66248: LIST
66249: LIST
66250: LIST
66251: LIST
66252: LIST
66253: LIST
66254: LIST
66255: LIST
66256: PUSH
66257: LD_INT 101
66259: PUSH
66260: LD_INT 102
66262: PUSH
66263: LD_INT 105
66265: PUSH
66266: LD_INT 106
66268: PUSH
66269: LD_INT 108
66271: PUSH
66272: LD_INT 109
66274: PUSH
66275: LD_INT 112
66277: PUSH
66278: LD_INT 116
66280: PUSH
66281: LD_INT 117
66283: PUSH
66284: LD_INT 118
66286: PUSH
66287: EMPTY
66288: LIST
66289: LIST
66290: LIST
66291: LIST
66292: LIST
66293: LIST
66294: LIST
66295: LIST
66296: LIST
66297: LIST
66298: PUSH
66299: EMPTY
66300: LIST
66301: LIST
66302: ST_TO_ADDR
66303: GO 68826
66305: LD_INT 7
66307: DOUBLE
66308: EQUAL
66309: IFTRUE 66313
66311: GO 66425
66313: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 , 116 , 117 , 118 ] ] ; 8 :
66314: LD_ADDR_VAR 0 2
66318: PUSH
66319: LD_INT 2
66321: PUSH
66322: LD_INT 4
66324: PUSH
66325: LD_INT 5
66327: PUSH
66328: LD_INT 7
66330: PUSH
66331: LD_INT 11
66333: PUSH
66334: LD_INT 12
66336: PUSH
66337: LD_INT 15
66339: PUSH
66340: LD_INT 16
66342: PUSH
66343: LD_INT 20
66345: PUSH
66346: LD_INT 21
66348: PUSH
66349: LD_INT 22
66351: PUSH
66352: LD_INT 23
66354: PUSH
66355: LD_INT 25
66357: PUSH
66358: LD_INT 26
66360: PUSH
66361: EMPTY
66362: LIST
66363: LIST
66364: LIST
66365: LIST
66366: LIST
66367: LIST
66368: LIST
66369: LIST
66370: LIST
66371: LIST
66372: LIST
66373: LIST
66374: LIST
66375: LIST
66376: PUSH
66377: LD_INT 101
66379: PUSH
66380: LD_INT 102
66382: PUSH
66383: LD_INT 103
66385: PUSH
66386: LD_INT 105
66388: PUSH
66389: LD_INT 106
66391: PUSH
66392: LD_INT 108
66394: PUSH
66395: LD_INT 112
66397: PUSH
66398: LD_INT 116
66400: PUSH
66401: LD_INT 117
66403: PUSH
66404: LD_INT 118
66406: PUSH
66407: EMPTY
66408: LIST
66409: LIST
66410: LIST
66411: LIST
66412: LIST
66413: LIST
66414: LIST
66415: LIST
66416: LIST
66417: LIST
66418: PUSH
66419: EMPTY
66420: LIST
66421: LIST
66422: ST_TO_ADDR
66423: GO 68826
66425: LD_INT 8
66427: DOUBLE
66428: EQUAL
66429: IFTRUE 66433
66431: GO 66573
66433: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 9 :
66434: LD_ADDR_VAR 0 2
66438: PUSH
66439: LD_INT 2
66441: PUSH
66442: LD_INT 4
66444: PUSH
66445: LD_INT 5
66447: PUSH
66448: LD_INT 6
66450: PUSH
66451: LD_INT 7
66453: PUSH
66454: LD_INT 8
66456: PUSH
66457: LD_INT 11
66459: PUSH
66460: LD_INT 12
66462: PUSH
66463: LD_INT 15
66465: PUSH
66466: LD_INT 16
66468: PUSH
66469: LD_INT 20
66471: PUSH
66472: LD_INT 21
66474: PUSH
66475: LD_INT 22
66477: PUSH
66478: LD_INT 23
66480: PUSH
66481: LD_INT 25
66483: PUSH
66484: LD_INT 26
66486: PUSH
66487: LD_INT 30
66489: PUSH
66490: LD_INT 31
66492: PUSH
66493: LD_INT 32
66495: PUSH
66496: LD_INT 36
66498: PUSH
66499: EMPTY
66500: LIST
66501: LIST
66502: LIST
66503: LIST
66504: LIST
66505: LIST
66506: LIST
66507: LIST
66508: LIST
66509: LIST
66510: LIST
66511: LIST
66512: LIST
66513: LIST
66514: LIST
66515: LIST
66516: LIST
66517: LIST
66518: LIST
66519: LIST
66520: PUSH
66521: LD_INT 101
66523: PUSH
66524: LD_INT 102
66526: PUSH
66527: LD_INT 103
66529: PUSH
66530: LD_INT 105
66532: PUSH
66533: LD_INT 106
66535: PUSH
66536: LD_INT 108
66538: PUSH
66539: LD_INT 109
66541: PUSH
66542: LD_INT 112
66544: PUSH
66545: LD_INT 116
66547: PUSH
66548: LD_INT 117
66550: PUSH
66551: LD_INT 118
66553: PUSH
66554: EMPTY
66555: LIST
66556: LIST
66557: LIST
66558: LIST
66559: LIST
66560: LIST
66561: LIST
66562: LIST
66563: LIST
66564: LIST
66565: LIST
66566: PUSH
66567: EMPTY
66568: LIST
66569: LIST
66570: ST_TO_ADDR
66571: GO 68826
66573: LD_INT 9
66575: DOUBLE
66576: EQUAL
66577: IFTRUE 66581
66579: GO 66729
66581: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 , 116 , 117 , 118 ] ] ; 10 :
66582: LD_ADDR_VAR 0 2
66586: PUSH
66587: LD_INT 2
66589: PUSH
66590: LD_INT 4
66592: PUSH
66593: LD_INT 5
66595: PUSH
66596: LD_INT 6
66598: PUSH
66599: LD_INT 7
66601: PUSH
66602: LD_INT 8
66604: PUSH
66605: LD_INT 11
66607: PUSH
66608: LD_INT 12
66610: PUSH
66611: LD_INT 15
66613: PUSH
66614: LD_INT 16
66616: PUSH
66617: LD_INT 20
66619: PUSH
66620: LD_INT 21
66622: PUSH
66623: LD_INT 22
66625: PUSH
66626: LD_INT 23
66628: PUSH
66629: LD_INT 25
66631: PUSH
66632: LD_INT 26
66634: PUSH
66635: LD_INT 28
66637: PUSH
66638: LD_INT 30
66640: PUSH
66641: LD_INT 31
66643: PUSH
66644: LD_INT 32
66646: PUSH
66647: LD_INT 36
66649: PUSH
66650: EMPTY
66651: LIST
66652: LIST
66653: LIST
66654: LIST
66655: LIST
66656: LIST
66657: LIST
66658: LIST
66659: LIST
66660: LIST
66661: LIST
66662: LIST
66663: LIST
66664: LIST
66665: LIST
66666: LIST
66667: LIST
66668: LIST
66669: LIST
66670: LIST
66671: LIST
66672: PUSH
66673: LD_INT 101
66675: PUSH
66676: LD_INT 102
66678: PUSH
66679: LD_INT 103
66681: PUSH
66682: LD_INT 105
66684: PUSH
66685: LD_INT 106
66687: PUSH
66688: LD_INT 108
66690: PUSH
66691: LD_INT 109
66693: PUSH
66694: LD_INT 112
66696: PUSH
66697: LD_INT 114
66699: PUSH
66700: LD_INT 116
66702: PUSH
66703: LD_INT 117
66705: PUSH
66706: LD_INT 118
66708: PUSH
66709: EMPTY
66710: LIST
66711: LIST
66712: LIST
66713: LIST
66714: LIST
66715: LIST
66716: LIST
66717: LIST
66718: LIST
66719: LIST
66720: LIST
66721: LIST
66722: PUSH
66723: EMPTY
66724: LIST
66725: LIST
66726: ST_TO_ADDR
66727: GO 68826
66729: LD_INT 10
66731: DOUBLE
66732: EQUAL
66733: IFTRUE 66737
66735: GO 66933
66737: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 11 :
66738: LD_ADDR_VAR 0 2
66742: PUSH
66743: LD_INT 2
66745: PUSH
66746: LD_INT 4
66748: PUSH
66749: LD_INT 5
66751: PUSH
66752: LD_INT 6
66754: PUSH
66755: LD_INT 7
66757: PUSH
66758: LD_INT 8
66760: PUSH
66761: LD_INT 9
66763: PUSH
66764: LD_INT 10
66766: PUSH
66767: LD_INT 11
66769: PUSH
66770: LD_INT 12
66772: PUSH
66773: LD_INT 13
66775: PUSH
66776: LD_INT 14
66778: PUSH
66779: LD_INT 15
66781: PUSH
66782: LD_INT 16
66784: PUSH
66785: LD_INT 17
66787: PUSH
66788: LD_INT 18
66790: PUSH
66791: LD_INT 19
66793: PUSH
66794: LD_INT 20
66796: PUSH
66797: LD_INT 21
66799: PUSH
66800: LD_INT 22
66802: PUSH
66803: LD_INT 23
66805: PUSH
66806: LD_INT 24
66808: PUSH
66809: LD_INT 25
66811: PUSH
66812: LD_INT 26
66814: PUSH
66815: LD_INT 28
66817: PUSH
66818: LD_INT 30
66820: PUSH
66821: LD_INT 31
66823: PUSH
66824: LD_INT 32
66826: PUSH
66827: LD_INT 36
66829: PUSH
66830: EMPTY
66831: LIST
66832: LIST
66833: LIST
66834: LIST
66835: LIST
66836: LIST
66837: LIST
66838: LIST
66839: LIST
66840: LIST
66841: LIST
66842: LIST
66843: LIST
66844: LIST
66845: LIST
66846: LIST
66847: LIST
66848: LIST
66849: LIST
66850: LIST
66851: LIST
66852: LIST
66853: LIST
66854: LIST
66855: LIST
66856: LIST
66857: LIST
66858: LIST
66859: LIST
66860: PUSH
66861: LD_INT 101
66863: PUSH
66864: LD_INT 102
66866: PUSH
66867: LD_INT 103
66869: PUSH
66870: LD_INT 104
66872: PUSH
66873: LD_INT 105
66875: PUSH
66876: LD_INT 106
66878: PUSH
66879: LD_INT 107
66881: PUSH
66882: LD_INT 108
66884: PUSH
66885: LD_INT 109
66887: PUSH
66888: LD_INT 110
66890: PUSH
66891: LD_INT 111
66893: PUSH
66894: LD_INT 112
66896: PUSH
66897: LD_INT 114
66899: PUSH
66900: LD_INT 116
66902: PUSH
66903: LD_INT 117
66905: PUSH
66906: LD_INT 118
66908: PUSH
66909: EMPTY
66910: LIST
66911: LIST
66912: LIST
66913: LIST
66914: LIST
66915: LIST
66916: LIST
66917: LIST
66918: LIST
66919: LIST
66920: LIST
66921: LIST
66922: LIST
66923: LIST
66924: LIST
66925: LIST
66926: PUSH
66927: EMPTY
66928: LIST
66929: LIST
66930: ST_TO_ADDR
66931: GO 68826
66933: LD_INT 11
66935: DOUBLE
66936: EQUAL
66937: IFTRUE 66941
66939: GO 67145
66941: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 12 :
66942: LD_ADDR_VAR 0 2
66946: PUSH
66947: LD_INT 2
66949: PUSH
66950: LD_INT 3
66952: PUSH
66953: LD_INT 4
66955: PUSH
66956: LD_INT 5
66958: PUSH
66959: LD_INT 6
66961: PUSH
66962: LD_INT 7
66964: PUSH
66965: LD_INT 8
66967: PUSH
66968: LD_INT 9
66970: PUSH
66971: LD_INT 10
66973: PUSH
66974: LD_INT 11
66976: PUSH
66977: LD_INT 12
66979: PUSH
66980: LD_INT 13
66982: PUSH
66983: LD_INT 14
66985: PUSH
66986: LD_INT 15
66988: PUSH
66989: LD_INT 16
66991: PUSH
66992: LD_INT 17
66994: PUSH
66995: LD_INT 18
66997: PUSH
66998: LD_INT 19
67000: PUSH
67001: LD_INT 20
67003: PUSH
67004: LD_INT 21
67006: PUSH
67007: LD_INT 22
67009: PUSH
67010: LD_INT 23
67012: PUSH
67013: LD_INT 24
67015: PUSH
67016: LD_INT 25
67018: PUSH
67019: LD_INT 26
67021: PUSH
67022: LD_INT 28
67024: PUSH
67025: LD_INT 30
67027: PUSH
67028: LD_INT 31
67030: PUSH
67031: LD_INT 32
67033: PUSH
67034: LD_INT 34
67036: PUSH
67037: LD_INT 36
67039: PUSH
67040: EMPTY
67041: LIST
67042: LIST
67043: LIST
67044: LIST
67045: LIST
67046: LIST
67047: LIST
67048: LIST
67049: LIST
67050: LIST
67051: LIST
67052: LIST
67053: LIST
67054: LIST
67055: LIST
67056: LIST
67057: LIST
67058: LIST
67059: LIST
67060: LIST
67061: LIST
67062: LIST
67063: LIST
67064: LIST
67065: LIST
67066: LIST
67067: LIST
67068: LIST
67069: LIST
67070: LIST
67071: LIST
67072: PUSH
67073: LD_INT 101
67075: PUSH
67076: LD_INT 102
67078: PUSH
67079: LD_INT 103
67081: PUSH
67082: LD_INT 104
67084: PUSH
67085: LD_INT 105
67087: PUSH
67088: LD_INT 106
67090: PUSH
67091: LD_INT 107
67093: PUSH
67094: LD_INT 108
67096: PUSH
67097: LD_INT 109
67099: PUSH
67100: LD_INT 110
67102: PUSH
67103: LD_INT 111
67105: PUSH
67106: LD_INT 112
67108: PUSH
67109: LD_INT 114
67111: PUSH
67112: LD_INT 116
67114: PUSH
67115: LD_INT 117
67117: PUSH
67118: LD_INT 118
67120: PUSH
67121: EMPTY
67122: LIST
67123: LIST
67124: LIST
67125: LIST
67126: LIST
67127: LIST
67128: LIST
67129: LIST
67130: LIST
67131: LIST
67132: LIST
67133: LIST
67134: LIST
67135: LIST
67136: LIST
67137: LIST
67138: PUSH
67139: EMPTY
67140: LIST
67141: LIST
67142: ST_TO_ADDR
67143: GO 68826
67145: LD_INT 12
67147: DOUBLE
67148: EQUAL
67149: IFTRUE 67153
67151: GO 67373
67153: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 13 :
67154: LD_ADDR_VAR 0 2
67158: PUSH
67159: LD_INT 1
67161: PUSH
67162: LD_INT 2
67164: PUSH
67165: LD_INT 3
67167: PUSH
67168: LD_INT 4
67170: PUSH
67171: LD_INT 5
67173: PUSH
67174: LD_INT 6
67176: PUSH
67177: LD_INT 7
67179: PUSH
67180: LD_INT 8
67182: PUSH
67183: LD_INT 9
67185: PUSH
67186: LD_INT 10
67188: PUSH
67189: LD_INT 11
67191: PUSH
67192: LD_INT 12
67194: PUSH
67195: LD_INT 13
67197: PUSH
67198: LD_INT 14
67200: PUSH
67201: LD_INT 15
67203: PUSH
67204: LD_INT 16
67206: PUSH
67207: LD_INT 17
67209: PUSH
67210: LD_INT 18
67212: PUSH
67213: LD_INT 19
67215: PUSH
67216: LD_INT 20
67218: PUSH
67219: LD_INT 21
67221: PUSH
67222: LD_INT 22
67224: PUSH
67225: LD_INT 23
67227: PUSH
67228: LD_INT 24
67230: PUSH
67231: LD_INT 25
67233: PUSH
67234: LD_INT 26
67236: PUSH
67237: LD_INT 27
67239: PUSH
67240: LD_INT 28
67242: PUSH
67243: LD_INT 30
67245: PUSH
67246: LD_INT 31
67248: PUSH
67249: LD_INT 32
67251: PUSH
67252: LD_INT 33
67254: PUSH
67255: LD_INT 34
67257: PUSH
67258: LD_INT 36
67260: PUSH
67261: EMPTY
67262: LIST
67263: LIST
67264: LIST
67265: LIST
67266: LIST
67267: LIST
67268: LIST
67269: LIST
67270: LIST
67271: LIST
67272: LIST
67273: LIST
67274: LIST
67275: LIST
67276: LIST
67277: LIST
67278: LIST
67279: LIST
67280: LIST
67281: LIST
67282: LIST
67283: LIST
67284: LIST
67285: LIST
67286: LIST
67287: LIST
67288: LIST
67289: LIST
67290: LIST
67291: LIST
67292: LIST
67293: LIST
67294: LIST
67295: LIST
67296: PUSH
67297: LD_INT 101
67299: PUSH
67300: LD_INT 102
67302: PUSH
67303: LD_INT 103
67305: PUSH
67306: LD_INT 104
67308: PUSH
67309: LD_INT 105
67311: PUSH
67312: LD_INT 106
67314: PUSH
67315: LD_INT 107
67317: PUSH
67318: LD_INT 108
67320: PUSH
67321: LD_INT 109
67323: PUSH
67324: LD_INT 110
67326: PUSH
67327: LD_INT 111
67329: PUSH
67330: LD_INT 112
67332: PUSH
67333: LD_INT 113
67335: PUSH
67336: LD_INT 114
67338: PUSH
67339: LD_INT 116
67341: PUSH
67342: LD_INT 117
67344: PUSH
67345: LD_INT 118
67347: PUSH
67348: EMPTY
67349: LIST
67350: LIST
67351: LIST
67352: LIST
67353: LIST
67354: LIST
67355: LIST
67356: LIST
67357: LIST
67358: LIST
67359: LIST
67360: LIST
67361: LIST
67362: LIST
67363: LIST
67364: LIST
67365: LIST
67366: PUSH
67367: EMPTY
67368: LIST
67369: LIST
67370: ST_TO_ADDR
67371: GO 68826
67373: LD_INT 13
67375: DOUBLE
67376: EQUAL
67377: IFTRUE 67381
67379: GO 67589
67381: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 14 :
67382: LD_ADDR_VAR 0 2
67386: PUSH
67387: LD_INT 1
67389: PUSH
67390: LD_INT 2
67392: PUSH
67393: LD_INT 3
67395: PUSH
67396: LD_INT 4
67398: PUSH
67399: LD_INT 5
67401: PUSH
67402: LD_INT 8
67404: PUSH
67405: LD_INT 9
67407: PUSH
67408: LD_INT 10
67410: PUSH
67411: LD_INT 11
67413: PUSH
67414: LD_INT 12
67416: PUSH
67417: LD_INT 14
67419: PUSH
67420: LD_INT 15
67422: PUSH
67423: LD_INT 16
67425: PUSH
67426: LD_INT 17
67428: PUSH
67429: LD_INT 18
67431: PUSH
67432: LD_INT 19
67434: PUSH
67435: LD_INT 20
67437: PUSH
67438: LD_INT 21
67440: PUSH
67441: LD_INT 22
67443: PUSH
67444: LD_INT 23
67446: PUSH
67447: LD_INT 24
67449: PUSH
67450: LD_INT 25
67452: PUSH
67453: LD_INT 26
67455: PUSH
67456: LD_INT 27
67458: PUSH
67459: LD_INT 28
67461: PUSH
67462: LD_INT 30
67464: PUSH
67465: LD_INT 31
67467: PUSH
67468: LD_INT 32
67470: PUSH
67471: LD_INT 33
67473: PUSH
67474: LD_INT 34
67476: PUSH
67477: LD_INT 36
67479: PUSH
67480: EMPTY
67481: LIST
67482: LIST
67483: LIST
67484: LIST
67485: LIST
67486: LIST
67487: LIST
67488: LIST
67489: LIST
67490: LIST
67491: LIST
67492: LIST
67493: LIST
67494: LIST
67495: LIST
67496: LIST
67497: LIST
67498: LIST
67499: LIST
67500: LIST
67501: LIST
67502: LIST
67503: LIST
67504: LIST
67505: LIST
67506: LIST
67507: LIST
67508: LIST
67509: LIST
67510: LIST
67511: LIST
67512: PUSH
67513: LD_INT 101
67515: PUSH
67516: LD_INT 102
67518: PUSH
67519: LD_INT 103
67521: PUSH
67522: LD_INT 104
67524: PUSH
67525: LD_INT 105
67527: PUSH
67528: LD_INT 106
67530: PUSH
67531: LD_INT 107
67533: PUSH
67534: LD_INT 108
67536: PUSH
67537: LD_INT 109
67539: PUSH
67540: LD_INT 110
67542: PUSH
67543: LD_INT 111
67545: PUSH
67546: LD_INT 112
67548: PUSH
67549: LD_INT 113
67551: PUSH
67552: LD_INT 114
67554: PUSH
67555: LD_INT 116
67557: PUSH
67558: LD_INT 117
67560: PUSH
67561: LD_INT 118
67563: PUSH
67564: EMPTY
67565: LIST
67566: LIST
67567: LIST
67568: LIST
67569: LIST
67570: LIST
67571: LIST
67572: LIST
67573: LIST
67574: LIST
67575: LIST
67576: LIST
67577: LIST
67578: LIST
67579: LIST
67580: LIST
67581: LIST
67582: PUSH
67583: EMPTY
67584: LIST
67585: LIST
67586: ST_TO_ADDR
67587: GO 68826
67589: LD_INT 14
67591: DOUBLE
67592: EQUAL
67593: IFTRUE 67597
67595: GO 67821
67597: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 15 :
67598: LD_ADDR_VAR 0 2
67602: PUSH
67603: LD_INT 1
67605: PUSH
67606: LD_INT 2
67608: PUSH
67609: LD_INT 3
67611: PUSH
67612: LD_INT 4
67614: PUSH
67615: LD_INT 5
67617: PUSH
67618: LD_INT 6
67620: PUSH
67621: LD_INT 7
67623: PUSH
67624: LD_INT 8
67626: PUSH
67627: LD_INT 9
67629: PUSH
67630: LD_INT 10
67632: PUSH
67633: LD_INT 11
67635: PUSH
67636: LD_INT 12
67638: PUSH
67639: LD_INT 13
67641: PUSH
67642: LD_INT 14
67644: PUSH
67645: LD_INT 15
67647: PUSH
67648: LD_INT 16
67650: PUSH
67651: LD_INT 17
67653: PUSH
67654: LD_INT 18
67656: PUSH
67657: LD_INT 19
67659: PUSH
67660: LD_INT 20
67662: PUSH
67663: LD_INT 21
67665: PUSH
67666: LD_INT 22
67668: PUSH
67669: LD_INT 23
67671: PUSH
67672: LD_INT 24
67674: PUSH
67675: LD_INT 25
67677: PUSH
67678: LD_INT 26
67680: PUSH
67681: LD_INT 27
67683: PUSH
67684: LD_INT 28
67686: PUSH
67687: LD_INT 29
67689: PUSH
67690: LD_INT 30
67692: PUSH
67693: LD_INT 31
67695: PUSH
67696: LD_INT 32
67698: PUSH
67699: LD_INT 33
67701: PUSH
67702: LD_INT 34
67704: PUSH
67705: LD_INT 36
67707: PUSH
67708: EMPTY
67709: LIST
67710: LIST
67711: LIST
67712: LIST
67713: LIST
67714: LIST
67715: LIST
67716: LIST
67717: LIST
67718: LIST
67719: LIST
67720: LIST
67721: LIST
67722: LIST
67723: LIST
67724: LIST
67725: LIST
67726: LIST
67727: LIST
67728: LIST
67729: LIST
67730: LIST
67731: LIST
67732: LIST
67733: LIST
67734: LIST
67735: LIST
67736: LIST
67737: LIST
67738: LIST
67739: LIST
67740: LIST
67741: LIST
67742: LIST
67743: LIST
67744: PUSH
67745: LD_INT 101
67747: PUSH
67748: LD_INT 102
67750: PUSH
67751: LD_INT 103
67753: PUSH
67754: LD_INT 104
67756: PUSH
67757: LD_INT 105
67759: PUSH
67760: LD_INT 106
67762: PUSH
67763: LD_INT 107
67765: PUSH
67766: LD_INT 108
67768: PUSH
67769: LD_INT 109
67771: PUSH
67772: LD_INT 110
67774: PUSH
67775: LD_INT 111
67777: PUSH
67778: LD_INT 112
67780: PUSH
67781: LD_INT 113
67783: PUSH
67784: LD_INT 114
67786: PUSH
67787: LD_INT 116
67789: PUSH
67790: LD_INT 117
67792: PUSH
67793: LD_INT 118
67795: PUSH
67796: EMPTY
67797: LIST
67798: LIST
67799: LIST
67800: LIST
67801: LIST
67802: LIST
67803: LIST
67804: LIST
67805: LIST
67806: LIST
67807: LIST
67808: LIST
67809: LIST
67810: LIST
67811: LIST
67812: LIST
67813: LIST
67814: PUSH
67815: EMPTY
67816: LIST
67817: LIST
67818: ST_TO_ADDR
67819: GO 68826
67821: LD_INT 15
67823: DOUBLE
67824: EQUAL
67825: IFTRUE 67829
67827: GO 68053
67829: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 16 :
67830: LD_ADDR_VAR 0 2
67834: PUSH
67835: LD_INT 1
67837: PUSH
67838: LD_INT 2
67840: PUSH
67841: LD_INT 3
67843: PUSH
67844: LD_INT 4
67846: PUSH
67847: LD_INT 5
67849: PUSH
67850: LD_INT 6
67852: PUSH
67853: LD_INT 7
67855: PUSH
67856: LD_INT 8
67858: PUSH
67859: LD_INT 9
67861: PUSH
67862: LD_INT 10
67864: PUSH
67865: LD_INT 11
67867: PUSH
67868: LD_INT 12
67870: PUSH
67871: LD_INT 13
67873: PUSH
67874: LD_INT 14
67876: PUSH
67877: LD_INT 15
67879: PUSH
67880: LD_INT 16
67882: PUSH
67883: LD_INT 17
67885: PUSH
67886: LD_INT 18
67888: PUSH
67889: LD_INT 19
67891: PUSH
67892: LD_INT 20
67894: PUSH
67895: LD_INT 21
67897: PUSH
67898: LD_INT 22
67900: PUSH
67901: LD_INT 23
67903: PUSH
67904: LD_INT 24
67906: PUSH
67907: LD_INT 25
67909: PUSH
67910: LD_INT 26
67912: PUSH
67913: LD_INT 27
67915: PUSH
67916: LD_INT 28
67918: PUSH
67919: LD_INT 29
67921: PUSH
67922: LD_INT 30
67924: PUSH
67925: LD_INT 31
67927: PUSH
67928: LD_INT 32
67930: PUSH
67931: LD_INT 33
67933: PUSH
67934: LD_INT 34
67936: PUSH
67937: LD_INT 36
67939: PUSH
67940: EMPTY
67941: LIST
67942: LIST
67943: LIST
67944: LIST
67945: LIST
67946: LIST
67947: LIST
67948: LIST
67949: LIST
67950: LIST
67951: LIST
67952: LIST
67953: LIST
67954: LIST
67955: LIST
67956: LIST
67957: LIST
67958: LIST
67959: LIST
67960: LIST
67961: LIST
67962: LIST
67963: LIST
67964: LIST
67965: LIST
67966: LIST
67967: LIST
67968: LIST
67969: LIST
67970: LIST
67971: LIST
67972: LIST
67973: LIST
67974: LIST
67975: LIST
67976: PUSH
67977: LD_INT 101
67979: PUSH
67980: LD_INT 102
67982: PUSH
67983: LD_INT 103
67985: PUSH
67986: LD_INT 104
67988: PUSH
67989: LD_INT 105
67991: PUSH
67992: LD_INT 106
67994: PUSH
67995: LD_INT 107
67997: PUSH
67998: LD_INT 108
68000: PUSH
68001: LD_INT 109
68003: PUSH
68004: LD_INT 110
68006: PUSH
68007: LD_INT 111
68009: PUSH
68010: LD_INT 112
68012: PUSH
68013: LD_INT 113
68015: PUSH
68016: LD_INT 114
68018: PUSH
68019: LD_INT 116
68021: PUSH
68022: LD_INT 117
68024: PUSH
68025: LD_INT 118
68027: PUSH
68028: EMPTY
68029: LIST
68030: LIST
68031: LIST
68032: LIST
68033: LIST
68034: LIST
68035: LIST
68036: LIST
68037: LIST
68038: LIST
68039: LIST
68040: LIST
68041: LIST
68042: LIST
68043: LIST
68044: LIST
68045: LIST
68046: PUSH
68047: EMPTY
68048: LIST
68049: LIST
68050: ST_TO_ADDR
68051: GO 68826
68053: LD_INT 16
68055: DOUBLE
68056: EQUAL
68057: IFTRUE 68061
68059: GO 68197
68061: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 17 :
68062: LD_ADDR_VAR 0 2
68066: PUSH
68067: LD_INT 2
68069: PUSH
68070: LD_INT 4
68072: PUSH
68073: LD_INT 5
68075: PUSH
68076: LD_INT 7
68078: PUSH
68079: LD_INT 11
68081: PUSH
68082: LD_INT 12
68084: PUSH
68085: LD_INT 15
68087: PUSH
68088: LD_INT 16
68090: PUSH
68091: LD_INT 20
68093: PUSH
68094: LD_INT 21
68096: PUSH
68097: LD_INT 22
68099: PUSH
68100: LD_INT 23
68102: PUSH
68103: LD_INT 25
68105: PUSH
68106: LD_INT 26
68108: PUSH
68109: LD_INT 30
68111: PUSH
68112: LD_INT 31
68114: PUSH
68115: LD_INT 32
68117: PUSH
68118: LD_INT 33
68120: PUSH
68121: LD_INT 34
68123: PUSH
68124: EMPTY
68125: LIST
68126: LIST
68127: LIST
68128: LIST
68129: LIST
68130: LIST
68131: LIST
68132: LIST
68133: LIST
68134: LIST
68135: LIST
68136: LIST
68137: LIST
68138: LIST
68139: LIST
68140: LIST
68141: LIST
68142: LIST
68143: LIST
68144: PUSH
68145: LD_INT 101
68147: PUSH
68148: LD_INT 102
68150: PUSH
68151: LD_INT 103
68153: PUSH
68154: LD_INT 106
68156: PUSH
68157: LD_INT 108
68159: PUSH
68160: LD_INT 112
68162: PUSH
68163: LD_INT 113
68165: PUSH
68166: LD_INT 114
68168: PUSH
68169: LD_INT 116
68171: PUSH
68172: LD_INT 117
68174: PUSH
68175: LD_INT 118
68177: PUSH
68178: EMPTY
68179: LIST
68180: LIST
68181: LIST
68182: LIST
68183: LIST
68184: LIST
68185: LIST
68186: LIST
68187: LIST
68188: LIST
68189: LIST
68190: PUSH
68191: EMPTY
68192: LIST
68193: LIST
68194: ST_TO_ADDR
68195: GO 68826
68197: LD_INT 17
68199: DOUBLE
68200: EQUAL
68201: IFTRUE 68205
68203: GO 68429
68205: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 18 :
68206: LD_ADDR_VAR 0 2
68210: PUSH
68211: LD_INT 1
68213: PUSH
68214: LD_INT 2
68216: PUSH
68217: LD_INT 3
68219: PUSH
68220: LD_INT 4
68222: PUSH
68223: LD_INT 5
68225: PUSH
68226: LD_INT 6
68228: PUSH
68229: LD_INT 7
68231: PUSH
68232: LD_INT 8
68234: PUSH
68235: LD_INT 9
68237: PUSH
68238: LD_INT 10
68240: PUSH
68241: LD_INT 11
68243: PUSH
68244: LD_INT 12
68246: PUSH
68247: LD_INT 13
68249: PUSH
68250: LD_INT 14
68252: PUSH
68253: LD_INT 15
68255: PUSH
68256: LD_INT 16
68258: PUSH
68259: LD_INT 17
68261: PUSH
68262: LD_INT 18
68264: PUSH
68265: LD_INT 19
68267: PUSH
68268: LD_INT 20
68270: PUSH
68271: LD_INT 21
68273: PUSH
68274: LD_INT 22
68276: PUSH
68277: LD_INT 23
68279: PUSH
68280: LD_INT 24
68282: PUSH
68283: LD_INT 25
68285: PUSH
68286: LD_INT 26
68288: PUSH
68289: LD_INT 27
68291: PUSH
68292: LD_INT 28
68294: PUSH
68295: LD_INT 29
68297: PUSH
68298: LD_INT 30
68300: PUSH
68301: LD_INT 31
68303: PUSH
68304: LD_INT 32
68306: PUSH
68307: LD_INT 33
68309: PUSH
68310: LD_INT 34
68312: PUSH
68313: LD_INT 36
68315: PUSH
68316: EMPTY
68317: LIST
68318: LIST
68319: LIST
68320: LIST
68321: LIST
68322: LIST
68323: LIST
68324: LIST
68325: LIST
68326: LIST
68327: LIST
68328: LIST
68329: LIST
68330: LIST
68331: LIST
68332: LIST
68333: LIST
68334: LIST
68335: LIST
68336: LIST
68337: LIST
68338: LIST
68339: LIST
68340: LIST
68341: LIST
68342: LIST
68343: LIST
68344: LIST
68345: LIST
68346: LIST
68347: LIST
68348: LIST
68349: LIST
68350: LIST
68351: LIST
68352: PUSH
68353: LD_INT 101
68355: PUSH
68356: LD_INT 102
68358: PUSH
68359: LD_INT 103
68361: PUSH
68362: LD_INT 104
68364: PUSH
68365: LD_INT 105
68367: PUSH
68368: LD_INT 106
68370: PUSH
68371: LD_INT 107
68373: PUSH
68374: LD_INT 108
68376: PUSH
68377: LD_INT 109
68379: PUSH
68380: LD_INT 110
68382: PUSH
68383: LD_INT 111
68385: PUSH
68386: LD_INT 112
68388: PUSH
68389: LD_INT 113
68391: PUSH
68392: LD_INT 114
68394: PUSH
68395: LD_INT 116
68397: PUSH
68398: LD_INT 117
68400: PUSH
68401: LD_INT 118
68403: PUSH
68404: EMPTY
68405: LIST
68406: LIST
68407: LIST
68408: LIST
68409: LIST
68410: LIST
68411: LIST
68412: LIST
68413: LIST
68414: LIST
68415: LIST
68416: LIST
68417: LIST
68418: LIST
68419: LIST
68420: LIST
68421: LIST
68422: PUSH
68423: EMPTY
68424: LIST
68425: LIST
68426: ST_TO_ADDR
68427: GO 68826
68429: LD_INT 18
68431: DOUBLE
68432: EQUAL
68433: IFTRUE 68437
68435: GO 68585
68437: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; 19 :
68438: LD_ADDR_VAR 0 2
68442: PUSH
68443: LD_INT 2
68445: PUSH
68446: LD_INT 4
68448: PUSH
68449: LD_INT 5
68451: PUSH
68452: LD_INT 7
68454: PUSH
68455: LD_INT 11
68457: PUSH
68458: LD_INT 12
68460: PUSH
68461: LD_INT 15
68463: PUSH
68464: LD_INT 16
68466: PUSH
68467: LD_INT 20
68469: PUSH
68470: LD_INT 21
68472: PUSH
68473: LD_INT 22
68475: PUSH
68476: LD_INT 23
68478: PUSH
68479: LD_INT 25
68481: PUSH
68482: LD_INT 26
68484: PUSH
68485: LD_INT 30
68487: PUSH
68488: LD_INT 31
68490: PUSH
68491: LD_INT 32
68493: PUSH
68494: LD_INT 33
68496: PUSH
68497: LD_INT 34
68499: PUSH
68500: LD_INT 35
68502: PUSH
68503: LD_INT 36
68505: PUSH
68506: EMPTY
68507: LIST
68508: LIST
68509: LIST
68510: LIST
68511: LIST
68512: LIST
68513: LIST
68514: LIST
68515: LIST
68516: LIST
68517: LIST
68518: LIST
68519: LIST
68520: LIST
68521: LIST
68522: LIST
68523: LIST
68524: LIST
68525: LIST
68526: LIST
68527: LIST
68528: PUSH
68529: LD_INT 101
68531: PUSH
68532: LD_INT 102
68534: PUSH
68535: LD_INT 103
68537: PUSH
68538: LD_INT 106
68540: PUSH
68541: LD_INT 108
68543: PUSH
68544: LD_INT 112
68546: PUSH
68547: LD_INT 113
68549: PUSH
68550: LD_INT 114
68552: PUSH
68553: LD_INT 115
68555: PUSH
68556: LD_INT 116
68558: PUSH
68559: LD_INT 117
68561: PUSH
68562: LD_INT 118
68564: PUSH
68565: EMPTY
68566: LIST
68567: LIST
68568: LIST
68569: LIST
68570: LIST
68571: LIST
68572: LIST
68573: LIST
68574: LIST
68575: LIST
68576: LIST
68577: LIST
68578: PUSH
68579: EMPTY
68580: LIST
68581: LIST
68582: ST_TO_ADDR
68583: GO 68826
68585: LD_INT 19
68587: DOUBLE
68588: EQUAL
68589: IFTRUE 68593
68591: GO 68825
68593: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; end ;
68594: LD_ADDR_VAR 0 2
68598: PUSH
68599: LD_INT 1
68601: PUSH
68602: LD_INT 2
68604: PUSH
68605: LD_INT 3
68607: PUSH
68608: LD_INT 4
68610: PUSH
68611: LD_INT 5
68613: PUSH
68614: LD_INT 6
68616: PUSH
68617: LD_INT 7
68619: PUSH
68620: LD_INT 8
68622: PUSH
68623: LD_INT 9
68625: PUSH
68626: LD_INT 10
68628: PUSH
68629: LD_INT 11
68631: PUSH
68632: LD_INT 12
68634: PUSH
68635: LD_INT 13
68637: PUSH
68638: LD_INT 14
68640: PUSH
68641: LD_INT 15
68643: PUSH
68644: LD_INT 16
68646: PUSH
68647: LD_INT 17
68649: PUSH
68650: LD_INT 18
68652: PUSH
68653: LD_INT 19
68655: PUSH
68656: LD_INT 20
68658: PUSH
68659: LD_INT 21
68661: PUSH
68662: LD_INT 22
68664: PUSH
68665: LD_INT 23
68667: PUSH
68668: LD_INT 24
68670: PUSH
68671: LD_INT 25
68673: PUSH
68674: LD_INT 26
68676: PUSH
68677: LD_INT 27
68679: PUSH
68680: LD_INT 28
68682: PUSH
68683: LD_INT 29
68685: PUSH
68686: LD_INT 30
68688: PUSH
68689: LD_INT 31
68691: PUSH
68692: LD_INT 32
68694: PUSH
68695: LD_INT 33
68697: PUSH
68698: LD_INT 34
68700: PUSH
68701: LD_INT 35
68703: PUSH
68704: LD_INT 36
68706: PUSH
68707: EMPTY
68708: LIST
68709: LIST
68710: LIST
68711: LIST
68712: LIST
68713: LIST
68714: LIST
68715: LIST
68716: LIST
68717: LIST
68718: LIST
68719: LIST
68720: LIST
68721: LIST
68722: LIST
68723: LIST
68724: LIST
68725: LIST
68726: LIST
68727: LIST
68728: LIST
68729: LIST
68730: LIST
68731: LIST
68732: LIST
68733: LIST
68734: LIST
68735: LIST
68736: LIST
68737: LIST
68738: LIST
68739: LIST
68740: LIST
68741: LIST
68742: LIST
68743: LIST
68744: PUSH
68745: LD_INT 101
68747: PUSH
68748: LD_INT 102
68750: PUSH
68751: LD_INT 103
68753: PUSH
68754: LD_INT 104
68756: PUSH
68757: LD_INT 105
68759: PUSH
68760: LD_INT 106
68762: PUSH
68763: LD_INT 107
68765: PUSH
68766: LD_INT 108
68768: PUSH
68769: LD_INT 109
68771: PUSH
68772: LD_INT 110
68774: PUSH
68775: LD_INT 111
68777: PUSH
68778: LD_INT 112
68780: PUSH
68781: LD_INT 113
68783: PUSH
68784: LD_INT 114
68786: PUSH
68787: LD_INT 115
68789: PUSH
68790: LD_INT 116
68792: PUSH
68793: LD_INT 117
68795: PUSH
68796: LD_INT 118
68798: PUSH
68799: EMPTY
68800: LIST
68801: LIST
68802: LIST
68803: LIST
68804: LIST
68805: LIST
68806: LIST
68807: LIST
68808: LIST
68809: LIST
68810: LIST
68811: LIST
68812: LIST
68813: LIST
68814: LIST
68815: LIST
68816: LIST
68817: LIST
68818: PUSH
68819: EMPTY
68820: LIST
68821: LIST
68822: ST_TO_ADDR
68823: GO 68826
68825: POP
// end else
68826: GO 69057
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ;
68828: LD_ADDR_VAR 0 2
68832: PUSH
68833: LD_INT 1
68835: PUSH
68836: LD_INT 2
68838: PUSH
68839: LD_INT 3
68841: PUSH
68842: LD_INT 4
68844: PUSH
68845: LD_INT 5
68847: PUSH
68848: LD_INT 6
68850: PUSH
68851: LD_INT 7
68853: PUSH
68854: LD_INT 8
68856: PUSH
68857: LD_INT 9
68859: PUSH
68860: LD_INT 10
68862: PUSH
68863: LD_INT 11
68865: PUSH
68866: LD_INT 12
68868: PUSH
68869: LD_INT 13
68871: PUSH
68872: LD_INT 14
68874: PUSH
68875: LD_INT 15
68877: PUSH
68878: LD_INT 16
68880: PUSH
68881: LD_INT 17
68883: PUSH
68884: LD_INT 18
68886: PUSH
68887: LD_INT 19
68889: PUSH
68890: LD_INT 20
68892: PUSH
68893: LD_INT 21
68895: PUSH
68896: LD_INT 22
68898: PUSH
68899: LD_INT 23
68901: PUSH
68902: LD_INT 24
68904: PUSH
68905: LD_INT 25
68907: PUSH
68908: LD_INT 26
68910: PUSH
68911: LD_INT 27
68913: PUSH
68914: LD_INT 28
68916: PUSH
68917: LD_INT 29
68919: PUSH
68920: LD_INT 30
68922: PUSH
68923: LD_INT 31
68925: PUSH
68926: LD_INT 32
68928: PUSH
68929: LD_INT 33
68931: PUSH
68932: LD_INT 34
68934: PUSH
68935: LD_INT 35
68937: PUSH
68938: LD_INT 36
68940: PUSH
68941: EMPTY
68942: LIST
68943: LIST
68944: LIST
68945: LIST
68946: LIST
68947: LIST
68948: LIST
68949: LIST
68950: LIST
68951: LIST
68952: LIST
68953: LIST
68954: LIST
68955: LIST
68956: LIST
68957: LIST
68958: LIST
68959: LIST
68960: LIST
68961: LIST
68962: LIST
68963: LIST
68964: LIST
68965: LIST
68966: LIST
68967: LIST
68968: LIST
68969: LIST
68970: LIST
68971: LIST
68972: LIST
68973: LIST
68974: LIST
68975: LIST
68976: LIST
68977: LIST
68978: PUSH
68979: LD_INT 101
68981: PUSH
68982: LD_INT 102
68984: PUSH
68985: LD_INT 103
68987: PUSH
68988: LD_INT 104
68990: PUSH
68991: LD_INT 105
68993: PUSH
68994: LD_INT 106
68996: PUSH
68997: LD_INT 107
68999: PUSH
69000: LD_INT 108
69002: PUSH
69003: LD_INT 109
69005: PUSH
69006: LD_INT 110
69008: PUSH
69009: LD_INT 111
69011: PUSH
69012: LD_INT 112
69014: PUSH
69015: LD_INT 113
69017: PUSH
69018: LD_INT 114
69020: PUSH
69021: LD_INT 115
69023: PUSH
69024: LD_INT 116
69026: PUSH
69027: LD_INT 117
69029: PUSH
69030: LD_INT 118
69032: PUSH
69033: EMPTY
69034: LIST
69035: LIST
69036: LIST
69037: LIST
69038: LIST
69039: LIST
69040: LIST
69041: LIST
69042: LIST
69043: LIST
69044: LIST
69045: LIST
69046: LIST
69047: LIST
69048: LIST
69049: LIST
69050: LIST
69051: LIST
69052: PUSH
69053: EMPTY
69054: LIST
69055: LIST
69056: ST_TO_ADDR
// if result then
69057: LD_VAR 0 2
69061: IFFALSE 69847
// begin normal :=  ;
69063: LD_ADDR_VAR 0 5
69067: PUSH
69068: LD_STRING 
69070: ST_TO_ADDR
// hardcore :=  ;
69071: LD_ADDR_VAR 0 6
69075: PUSH
69076: LD_STRING 
69078: ST_TO_ADDR
// active :=  ;
69079: LD_ADDR_VAR 0 7
69083: PUSH
69084: LD_STRING 
69086: ST_TO_ADDR
// for i = 1 to normalCounter do
69087: LD_ADDR_VAR 0 8
69091: PUSH
69092: DOUBLE
69093: LD_INT 1
69095: DEC
69096: ST_TO_ADDR
69097: LD_EXP 99
69101: PUSH
69102: FOR_TO
69103: IFFALSE 69204
// begin tmp := 0 ;
69105: LD_ADDR_VAR 0 3
69109: PUSH
69110: LD_STRING 0
69112: ST_TO_ADDR
// if result [ 1 ] then
69113: LD_VAR 0 2
69117: PUSH
69118: LD_INT 1
69120: ARRAY
69121: IFFALSE 69186
// if result [ 1 ] [ 1 ] = i then
69123: LD_VAR 0 2
69127: PUSH
69128: LD_INT 1
69130: ARRAY
69131: PUSH
69132: LD_INT 1
69134: ARRAY
69135: PUSH
69136: LD_VAR 0 8
69140: EQUAL
69141: IFFALSE 69186
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
69143: LD_ADDR_VAR 0 2
69147: PUSH
69148: LD_VAR 0 2
69152: PPUSH
69153: LD_INT 1
69155: PPUSH
69156: LD_VAR 0 2
69160: PUSH
69161: LD_INT 1
69163: ARRAY
69164: PPUSH
69165: LD_INT 1
69167: PPUSH
69168: CALL_OW 3
69172: PPUSH
69173: CALL_OW 1
69177: ST_TO_ADDR
// tmp := 1 ;
69178: LD_ADDR_VAR 0 3
69182: PUSH
69183: LD_STRING 1
69185: ST_TO_ADDR
// end ; normal := normal & tmp ;
69186: LD_ADDR_VAR 0 5
69190: PUSH
69191: LD_VAR 0 5
69195: PUSH
69196: LD_VAR 0 3
69200: STR
69201: ST_TO_ADDR
// end ;
69202: GO 69102
69204: POP
69205: POP
// for i = 1 to hardcoreCounter do
69206: LD_ADDR_VAR 0 8
69210: PUSH
69211: DOUBLE
69212: LD_INT 1
69214: DEC
69215: ST_TO_ADDR
69216: LD_EXP 100
69220: PUSH
69221: FOR_TO
69222: IFFALSE 69327
// begin tmp := 0 ;
69224: LD_ADDR_VAR 0 3
69228: PUSH
69229: LD_STRING 0
69231: ST_TO_ADDR
// if result [ 2 ] then
69232: LD_VAR 0 2
69236: PUSH
69237: LD_INT 2
69239: ARRAY
69240: IFFALSE 69309
// if result [ 2 ] [ 1 ] = 100 + i then
69242: LD_VAR 0 2
69246: PUSH
69247: LD_INT 2
69249: ARRAY
69250: PUSH
69251: LD_INT 1
69253: ARRAY
69254: PUSH
69255: LD_INT 100
69257: PUSH
69258: LD_VAR 0 8
69262: PLUS
69263: EQUAL
69264: IFFALSE 69309
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
69266: LD_ADDR_VAR 0 2
69270: PUSH
69271: LD_VAR 0 2
69275: PPUSH
69276: LD_INT 2
69278: PPUSH
69279: LD_VAR 0 2
69283: PUSH
69284: LD_INT 2
69286: ARRAY
69287: PPUSH
69288: LD_INT 1
69290: PPUSH
69291: CALL_OW 3
69295: PPUSH
69296: CALL_OW 1
69300: ST_TO_ADDR
// tmp := 1 ;
69301: LD_ADDR_VAR 0 3
69305: PUSH
69306: LD_STRING 1
69308: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
69309: LD_ADDR_VAR 0 6
69313: PUSH
69314: LD_VAR 0 6
69318: PUSH
69319: LD_VAR 0 3
69323: STR
69324: ST_TO_ADDR
// end ;
69325: GO 69221
69327: POP
69328: POP
// if isGameLoad then
69329: LD_VAR 0 1
69333: IFFALSE 69808
// begin flags := [ sRocket , sSpeed , sEngine , sSpec , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sKamikadze , sTroll , sSlow , sLack , sTank , sRemote , sPowell , sTeleport , sOilTower , sShovel , sSheik , sEarthquake , sAI , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sSold , sDiff , sFog , sReset , sSun , sTiger , sBomb , sWound , sBetray , sContamin , sOil , sStu , sBazooka , sMortar , sRanger , sComputer , s30 , s60 ] ;
69335: LD_ADDR_VAR 0 4
69339: PUSH
69340: LD_EXP 103
69344: PUSH
69345: LD_EXP 102
69349: PUSH
69350: LD_EXP 104
69354: PUSH
69355: LD_EXP 101
69359: PUSH
69360: LD_EXP 105
69364: PUSH
69365: LD_EXP 106
69369: PUSH
69370: LD_EXP 107
69374: PUSH
69375: LD_EXP 108
69379: PUSH
69380: LD_EXP 109
69384: PUSH
69385: LD_EXP 110
69389: PUSH
69390: LD_EXP 111
69394: PUSH
69395: LD_EXP 112
69399: PUSH
69400: LD_EXP 113
69404: PUSH
69405: LD_EXP 114
69409: PUSH
69410: LD_EXP 122
69414: PUSH
69415: LD_EXP 123
69419: PUSH
69420: LD_EXP 124
69424: PUSH
69425: LD_EXP 125
69429: PUSH
69430: LD_EXP 127
69434: PUSH
69435: LD_EXP 128
69439: PUSH
69440: LD_EXP 129
69444: PUSH
69445: LD_EXP 132
69449: PUSH
69450: LD_EXP 134
69454: PUSH
69455: LD_EXP 135
69459: PUSH
69460: LD_EXP 136
69464: PUSH
69465: LD_EXP 138
69469: PUSH
69470: LD_EXP 139
69474: PUSH
69475: LD_EXP 142
69479: PUSH
69480: LD_EXP 143
69484: PUSH
69485: LD_EXP 144
69489: PUSH
69490: LD_EXP 145
69494: PUSH
69495: LD_EXP 146
69499: PUSH
69500: LD_EXP 147
69504: PUSH
69505: LD_EXP 148
69509: PUSH
69510: LD_EXP 149
69514: PUSH
69515: LD_EXP 150
69519: PUSH
69520: LD_EXP 115
69524: PUSH
69525: LD_EXP 116
69529: PUSH
69530: LD_EXP 119
69534: PUSH
69535: LD_EXP 120
69539: PUSH
69540: LD_EXP 121
69544: PUSH
69545: LD_EXP 117
69549: PUSH
69550: LD_EXP 118
69554: PUSH
69555: LD_EXP 126
69559: PUSH
69560: LD_EXP 130
69564: PUSH
69565: LD_EXP 131
69569: PUSH
69570: LD_EXP 133
69574: PUSH
69575: LD_EXP 137
69579: PUSH
69580: LD_EXP 140
69584: PUSH
69585: LD_EXP 141
69589: PUSH
69590: LD_EXP 151
69594: PUSH
69595: LD_EXP 152
69599: PUSH
69600: LD_EXP 153
69604: PUSH
69605: LD_EXP 154
69609: PUSH
69610: EMPTY
69611: LIST
69612: LIST
69613: LIST
69614: LIST
69615: LIST
69616: LIST
69617: LIST
69618: LIST
69619: LIST
69620: LIST
69621: LIST
69622: LIST
69623: LIST
69624: LIST
69625: LIST
69626: LIST
69627: LIST
69628: LIST
69629: LIST
69630: LIST
69631: LIST
69632: LIST
69633: LIST
69634: LIST
69635: LIST
69636: LIST
69637: LIST
69638: LIST
69639: LIST
69640: LIST
69641: LIST
69642: LIST
69643: LIST
69644: LIST
69645: LIST
69646: LIST
69647: LIST
69648: LIST
69649: LIST
69650: LIST
69651: LIST
69652: LIST
69653: LIST
69654: LIST
69655: LIST
69656: LIST
69657: LIST
69658: LIST
69659: LIST
69660: LIST
69661: LIST
69662: LIST
69663: LIST
69664: LIST
69665: ST_TO_ADDR
// tmp :=  ;
69666: LD_ADDR_VAR 0 3
69670: PUSH
69671: LD_STRING 
69673: ST_TO_ADDR
// for i = 1 to normalCounter do
69674: LD_ADDR_VAR 0 8
69678: PUSH
69679: DOUBLE
69680: LD_INT 1
69682: DEC
69683: ST_TO_ADDR
69684: LD_EXP 99
69688: PUSH
69689: FOR_TO
69690: IFFALSE 69726
// begin if flags [ i ] then
69692: LD_VAR 0 4
69696: PUSH
69697: LD_VAR 0 8
69701: ARRAY
69702: IFFALSE 69724
// tmp := tmp & i & ; ;
69704: LD_ADDR_VAR 0 3
69708: PUSH
69709: LD_VAR 0 3
69713: PUSH
69714: LD_VAR 0 8
69718: STR
69719: PUSH
69720: LD_STRING ;
69722: STR
69723: ST_TO_ADDR
// end ;
69724: GO 69689
69726: POP
69727: POP
// for i = 1 to hardcoreCounter do
69728: LD_ADDR_VAR 0 8
69732: PUSH
69733: DOUBLE
69734: LD_INT 1
69736: DEC
69737: ST_TO_ADDR
69738: LD_EXP 100
69742: PUSH
69743: FOR_TO
69744: IFFALSE 69790
// begin if flags [ normalCounter + i ] then
69746: LD_VAR 0 4
69750: PUSH
69751: LD_EXP 99
69755: PUSH
69756: LD_VAR 0 8
69760: PLUS
69761: ARRAY
69762: IFFALSE 69788
// tmp := tmp & ( 100 + i ) & ; ;
69764: LD_ADDR_VAR 0 3
69768: PUSH
69769: LD_VAR 0 3
69773: PUSH
69774: LD_INT 100
69776: PUSH
69777: LD_VAR 0 8
69781: PLUS
69782: STR
69783: PUSH
69784: LD_STRING ;
69786: STR
69787: ST_TO_ADDR
// end ;
69788: GO 69743
69790: POP
69791: POP
// if tmp then
69792: LD_VAR 0 3
69796: IFFALSE 69808
// active := tmp ;
69798: LD_ADDR_VAR 0 7
69802: PUSH
69803: LD_VAR 0 3
69807: ST_TO_ADDR
// end ; ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & "," & active & ") ) ;
69808: LD_STRING getStreamItemsFromMission("
69810: PUSH
69811: LD_VAR 0 5
69815: STR
69816: PUSH
69817: LD_STRING ","
69819: STR
69820: PUSH
69821: LD_VAR 0 6
69825: STR
69826: PUSH
69827: LD_STRING ","
69829: STR
69830: PUSH
69831: LD_VAR 0 7
69835: STR
69836: PUSH
69837: LD_STRING ")
69839: STR
69840: PPUSH
69841: CALL_OW 559
// end else
69845: GO 69854
// ToLua ( getStreamItemsFromMission("","","") ) ;
69847: LD_STRING getStreamItemsFromMission("","","")
69849: PPUSH
69850: CALL_OW 559
// end ;
69854: LD_VAR 0 2
69858: RET
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
69859: LD_EXP 98
69863: PUSH
69864: LD_EXP 103
69868: AND
69869: IFFALSE 69993
69871: GO 69873
69873: DISABLE
69874: LD_INT 0
69876: PPUSH
69877: PPUSH
// begin enable ;
69878: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
69879: LD_ADDR_VAR 0 2
69883: PUSH
69884: LD_INT 22
69886: PUSH
69887: LD_OWVAR 2
69891: PUSH
69892: EMPTY
69893: LIST
69894: LIST
69895: PUSH
69896: LD_INT 2
69898: PUSH
69899: LD_INT 34
69901: PUSH
69902: LD_INT 7
69904: PUSH
69905: EMPTY
69906: LIST
69907: LIST
69908: PUSH
69909: LD_INT 34
69911: PUSH
69912: LD_INT 45
69914: PUSH
69915: EMPTY
69916: LIST
69917: LIST
69918: PUSH
69919: LD_INT 34
69921: PUSH
69922: LD_INT 28
69924: PUSH
69925: EMPTY
69926: LIST
69927: LIST
69928: PUSH
69929: LD_INT 34
69931: PUSH
69932: LD_INT 47
69934: PUSH
69935: EMPTY
69936: LIST
69937: LIST
69938: PUSH
69939: EMPTY
69940: LIST
69941: LIST
69942: LIST
69943: LIST
69944: LIST
69945: PUSH
69946: EMPTY
69947: LIST
69948: LIST
69949: PPUSH
69950: CALL_OW 69
69954: ST_TO_ADDR
// if not tmp then
69955: LD_VAR 0 2
69959: NOT
69960: IFFALSE 69964
// exit ;
69962: GO 69993
// for i in tmp do
69964: LD_ADDR_VAR 0 1
69968: PUSH
69969: LD_VAR 0 2
69973: PUSH
69974: FOR_IN
69975: IFFALSE 69991
// begin SetLives ( i , 0 ) ;
69977: LD_VAR 0 1
69981: PPUSH
69982: LD_INT 0
69984: PPUSH
69985: CALL_OW 234
// end ;
69989: GO 69974
69991: POP
69992: POP
// end ;
69993: PPOPN 2
69995: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
69996: LD_EXP 98
70000: PUSH
70001: LD_EXP 104
70005: AND
70006: IFFALSE 70090
70008: GO 70010
70010: DISABLE
70011: LD_INT 0
70013: PPUSH
70014: PPUSH
// begin enable ;
70015: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
70016: LD_ADDR_VAR 0 2
70020: PUSH
70021: LD_INT 22
70023: PUSH
70024: LD_OWVAR 2
70028: PUSH
70029: EMPTY
70030: LIST
70031: LIST
70032: PUSH
70033: LD_INT 32
70035: PUSH
70036: LD_INT 3
70038: PUSH
70039: EMPTY
70040: LIST
70041: LIST
70042: PUSH
70043: EMPTY
70044: LIST
70045: LIST
70046: PPUSH
70047: CALL_OW 69
70051: ST_TO_ADDR
// if not tmp then
70052: LD_VAR 0 2
70056: NOT
70057: IFFALSE 70061
// exit ;
70059: GO 70090
// for i in tmp do
70061: LD_ADDR_VAR 0 1
70065: PUSH
70066: LD_VAR 0 2
70070: PUSH
70071: FOR_IN
70072: IFFALSE 70088
// begin SetLives ( i , 0 ) ;
70074: LD_VAR 0 1
70078: PPUSH
70079: LD_INT 0
70081: PPUSH
70082: CALL_OW 234
// end ;
70086: GO 70071
70088: POP
70089: POP
// end ;
70090: PPOPN 2
70092: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
70093: LD_EXP 98
70097: PUSH
70098: LD_EXP 101
70102: AND
70103: IFFALSE 70196
70105: GO 70107
70107: DISABLE
70108: LD_INT 0
70110: PPUSH
// begin enable ;
70111: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
70112: LD_ADDR_VAR 0 1
70116: PUSH
70117: LD_INT 22
70119: PUSH
70120: LD_OWVAR 2
70124: PUSH
70125: EMPTY
70126: LIST
70127: LIST
70128: PUSH
70129: LD_INT 2
70131: PUSH
70132: LD_INT 25
70134: PUSH
70135: LD_INT 5
70137: PUSH
70138: EMPTY
70139: LIST
70140: LIST
70141: PUSH
70142: LD_INT 25
70144: PUSH
70145: LD_INT 9
70147: PUSH
70148: EMPTY
70149: LIST
70150: LIST
70151: PUSH
70152: LD_INT 25
70154: PUSH
70155: LD_INT 8
70157: PUSH
70158: EMPTY
70159: LIST
70160: LIST
70161: PUSH
70162: EMPTY
70163: LIST
70164: LIST
70165: LIST
70166: LIST
70167: PUSH
70168: EMPTY
70169: LIST
70170: LIST
70171: PPUSH
70172: CALL_OW 69
70176: PUSH
70177: FOR_IN
70178: IFFALSE 70194
// begin SetClass ( i , 1 ) ;
70180: LD_VAR 0 1
70184: PPUSH
70185: LD_INT 1
70187: PPUSH
70188: CALL_OW 336
// end ;
70192: GO 70177
70194: POP
70195: POP
// end ;
70196: PPOPN 1
70198: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
70199: LD_EXP 98
70203: PUSH
70204: LD_EXP 102
70208: AND
70209: PUSH
70210: LD_OWVAR 65
70214: PUSH
70215: LD_INT 7
70217: LESS
70218: AND
70219: IFFALSE 70233
70221: GO 70223
70223: DISABLE
// begin enable ;
70224: ENABLE
// game_speed := 7 ;
70225: LD_ADDR_OWVAR 65
70229: PUSH
70230: LD_INT 7
70232: ST_TO_ADDR
// end ;
70233: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
70234: LD_EXP 98
70238: PUSH
70239: LD_EXP 105
70243: AND
70244: IFFALSE 70446
70246: GO 70248
70248: DISABLE
70249: LD_INT 0
70251: PPUSH
70252: PPUSH
70253: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
70254: LD_ADDR_VAR 0 3
70258: PUSH
70259: LD_INT 81
70261: PUSH
70262: LD_OWVAR 2
70266: PUSH
70267: EMPTY
70268: LIST
70269: LIST
70270: PUSH
70271: LD_INT 21
70273: PUSH
70274: LD_INT 1
70276: PUSH
70277: EMPTY
70278: LIST
70279: LIST
70280: PUSH
70281: EMPTY
70282: LIST
70283: LIST
70284: PPUSH
70285: CALL_OW 69
70289: ST_TO_ADDR
// if not tmp then
70290: LD_VAR 0 3
70294: NOT
70295: IFFALSE 70299
// exit ;
70297: GO 70446
// if tmp > 5 then
70299: LD_VAR 0 3
70303: PUSH
70304: LD_INT 5
70306: GREATER
70307: IFFALSE 70319
// k := 5 else
70309: LD_ADDR_VAR 0 2
70313: PUSH
70314: LD_INT 5
70316: ST_TO_ADDR
70317: GO 70329
// k := tmp ;
70319: LD_ADDR_VAR 0 2
70323: PUSH
70324: LD_VAR 0 3
70328: ST_TO_ADDR
// for i := 1 to k do
70329: LD_ADDR_VAR 0 1
70333: PUSH
70334: DOUBLE
70335: LD_INT 1
70337: DEC
70338: ST_TO_ADDR
70339: LD_VAR 0 2
70343: PUSH
70344: FOR_TO
70345: IFFALSE 70444
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
70347: LD_VAR 0 3
70351: PUSH
70352: LD_VAR 0 1
70356: ARRAY
70357: PPUSH
70358: LD_VAR 0 1
70362: PUSH
70363: LD_INT 4
70365: MOD
70366: PUSH
70367: LD_INT 1
70369: PLUS
70370: PPUSH
70371: CALL_OW 259
70375: PUSH
70376: LD_INT 10
70378: LESS
70379: IFFALSE 70442
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
70381: LD_VAR 0 3
70385: PUSH
70386: LD_VAR 0 1
70390: ARRAY
70391: PPUSH
70392: LD_VAR 0 1
70396: PUSH
70397: LD_INT 4
70399: MOD
70400: PUSH
70401: LD_INT 1
70403: PLUS
70404: PPUSH
70405: LD_VAR 0 3
70409: PUSH
70410: LD_VAR 0 1
70414: ARRAY
70415: PPUSH
70416: LD_VAR 0 1
70420: PUSH
70421: LD_INT 4
70423: MOD
70424: PUSH
70425: LD_INT 1
70427: PLUS
70428: PPUSH
70429: CALL_OW 259
70433: PUSH
70434: LD_INT 1
70436: PLUS
70437: PPUSH
70438: CALL_OW 237
70442: GO 70344
70444: POP
70445: POP
// end ;
70446: PPOPN 3
70448: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
70449: LD_EXP 98
70453: PUSH
70454: LD_EXP 106
70458: AND
70459: IFFALSE 70479
70461: GO 70463
70463: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
70464: LD_INT 4
70466: PPUSH
70467: LD_OWVAR 2
70471: PPUSH
70472: LD_INT 0
70474: PPUSH
70475: CALL_OW 324
70479: END
// every 0 0$1 trigger StreamModeActive and sShovel do
70480: LD_EXP 98
70484: PUSH
70485: LD_EXP 135
70489: AND
70490: IFFALSE 70510
70492: GO 70494
70494: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
70495: LD_INT 19
70497: PPUSH
70498: LD_OWVAR 2
70502: PPUSH
70503: LD_INT 0
70505: PPUSH
70506: CALL_OW 324
70510: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
70511: LD_EXP 98
70515: PUSH
70516: LD_EXP 107
70520: AND
70521: IFFALSE 70623
70523: GO 70525
70525: DISABLE
70526: LD_INT 0
70528: PPUSH
70529: PPUSH
// begin enable ;
70530: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
70531: LD_ADDR_VAR 0 2
70535: PUSH
70536: LD_INT 22
70538: PUSH
70539: LD_OWVAR 2
70543: PUSH
70544: EMPTY
70545: LIST
70546: LIST
70547: PUSH
70548: LD_INT 2
70550: PUSH
70551: LD_INT 34
70553: PUSH
70554: LD_INT 11
70556: PUSH
70557: EMPTY
70558: LIST
70559: LIST
70560: PUSH
70561: LD_INT 34
70563: PUSH
70564: LD_INT 30
70566: PUSH
70567: EMPTY
70568: LIST
70569: LIST
70570: PUSH
70571: EMPTY
70572: LIST
70573: LIST
70574: LIST
70575: PUSH
70576: EMPTY
70577: LIST
70578: LIST
70579: PPUSH
70580: CALL_OW 69
70584: ST_TO_ADDR
// if not tmp then
70585: LD_VAR 0 2
70589: NOT
70590: IFFALSE 70594
// exit ;
70592: GO 70623
// for i in tmp do
70594: LD_ADDR_VAR 0 1
70598: PUSH
70599: LD_VAR 0 2
70603: PUSH
70604: FOR_IN
70605: IFFALSE 70621
// begin SetLives ( i , 0 ) ;
70607: LD_VAR 0 1
70611: PPUSH
70612: LD_INT 0
70614: PPUSH
70615: CALL_OW 234
// end ;
70619: GO 70604
70621: POP
70622: POP
// end ;
70623: PPOPN 2
70625: END
// every 0 0$1 trigger StreamModeActive and sBunker do
70626: LD_EXP 98
70630: PUSH
70631: LD_EXP 108
70635: AND
70636: IFFALSE 70656
70638: GO 70640
70640: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
70641: LD_INT 32
70643: PPUSH
70644: LD_OWVAR 2
70648: PPUSH
70649: LD_INT 0
70651: PPUSH
70652: CALL_OW 324
70656: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
70657: LD_EXP 98
70661: PUSH
70662: LD_EXP 109
70666: AND
70667: IFFALSE 70848
70669: GO 70671
70671: DISABLE
70672: LD_INT 0
70674: PPUSH
70675: PPUSH
70676: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
70677: LD_ADDR_VAR 0 2
70681: PUSH
70682: LD_INT 22
70684: PUSH
70685: LD_OWVAR 2
70689: PUSH
70690: EMPTY
70691: LIST
70692: LIST
70693: PUSH
70694: LD_INT 33
70696: PUSH
70697: LD_INT 3
70699: PUSH
70700: EMPTY
70701: LIST
70702: LIST
70703: PUSH
70704: EMPTY
70705: LIST
70706: LIST
70707: PPUSH
70708: CALL_OW 69
70712: ST_TO_ADDR
// if not tmp then
70713: LD_VAR 0 2
70717: NOT
70718: IFFALSE 70722
// exit ;
70720: GO 70848
// side := 0 ;
70722: LD_ADDR_VAR 0 3
70726: PUSH
70727: LD_INT 0
70729: ST_TO_ADDR
// for i := 1 to 8 do
70730: LD_ADDR_VAR 0 1
70734: PUSH
70735: DOUBLE
70736: LD_INT 1
70738: DEC
70739: ST_TO_ADDR
70740: LD_INT 8
70742: PUSH
70743: FOR_TO
70744: IFFALSE 70792
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
70746: LD_OWVAR 2
70750: PUSH
70751: LD_VAR 0 1
70755: NONEQUAL
70756: PUSH
70757: LD_OWVAR 2
70761: PPUSH
70762: LD_VAR 0 1
70766: PPUSH
70767: CALL_OW 81
70771: PUSH
70772: LD_INT 2
70774: EQUAL
70775: AND
70776: IFFALSE 70790
// begin side := i ;
70778: LD_ADDR_VAR 0 3
70782: PUSH
70783: LD_VAR 0 1
70787: ST_TO_ADDR
// break ;
70788: GO 70792
// end ;
70790: GO 70743
70792: POP
70793: POP
// if not side then
70794: LD_VAR 0 3
70798: NOT
70799: IFFALSE 70803
// exit ;
70801: GO 70848
// for i := 1 to tmp do
70803: LD_ADDR_VAR 0 1
70807: PUSH
70808: DOUBLE
70809: LD_INT 1
70811: DEC
70812: ST_TO_ADDR
70813: LD_VAR 0 2
70817: PUSH
70818: FOR_TO
70819: IFFALSE 70846
// if Prob ( 60 ) then
70821: LD_INT 60
70823: PPUSH
70824: CALL_OW 13
70828: IFFALSE 70844
// SetSide ( i , side ) ;
70830: LD_VAR 0 1
70834: PPUSH
70835: LD_VAR 0 3
70839: PPUSH
70840: CALL_OW 235
70844: GO 70818
70846: POP
70847: POP
// end ;
70848: PPOPN 3
70850: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
70851: LD_EXP 98
70855: PUSH
70856: LD_EXP 111
70860: AND
70861: IFFALSE 70980
70863: GO 70865
70865: DISABLE
70866: LD_INT 0
70868: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
70869: LD_ADDR_VAR 0 1
70873: PUSH
70874: LD_INT 22
70876: PUSH
70877: LD_OWVAR 2
70881: PUSH
70882: EMPTY
70883: LIST
70884: LIST
70885: PUSH
70886: LD_INT 21
70888: PUSH
70889: LD_INT 1
70891: PUSH
70892: EMPTY
70893: LIST
70894: LIST
70895: PUSH
70896: LD_INT 3
70898: PUSH
70899: LD_INT 23
70901: PUSH
70902: LD_INT 0
70904: PUSH
70905: EMPTY
70906: LIST
70907: LIST
70908: PUSH
70909: EMPTY
70910: LIST
70911: LIST
70912: PUSH
70913: EMPTY
70914: LIST
70915: LIST
70916: LIST
70917: PPUSH
70918: CALL_OW 69
70922: PUSH
70923: FOR_IN
70924: IFFALSE 70978
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
70926: LD_VAR 0 1
70930: PPUSH
70931: CALL_OW 257
70935: PUSH
70936: LD_INT 1
70938: PUSH
70939: LD_INT 2
70941: PUSH
70942: LD_INT 3
70944: PUSH
70945: LD_INT 4
70947: PUSH
70948: EMPTY
70949: LIST
70950: LIST
70951: LIST
70952: LIST
70953: IN
70954: IFFALSE 70976
// SetClass ( un , rand ( 1 , 4 ) ) ;
70956: LD_VAR 0 1
70960: PPUSH
70961: LD_INT 1
70963: PPUSH
70964: LD_INT 4
70966: PPUSH
70967: CALL_OW 12
70971: PPUSH
70972: CALL_OW 336
70976: GO 70923
70978: POP
70979: POP
// end ;
70980: PPOPN 1
70982: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
70983: LD_EXP 98
70987: PUSH
70988: LD_EXP 110
70992: AND
70993: IFFALSE 71072
70995: GO 70997
70997: DISABLE
70998: LD_INT 0
71000: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
71001: LD_ADDR_VAR 0 1
71005: PUSH
71006: LD_INT 22
71008: PUSH
71009: LD_OWVAR 2
71013: PUSH
71014: EMPTY
71015: LIST
71016: LIST
71017: PUSH
71018: LD_INT 21
71020: PUSH
71021: LD_INT 3
71023: PUSH
71024: EMPTY
71025: LIST
71026: LIST
71027: PUSH
71028: EMPTY
71029: LIST
71030: LIST
71031: PPUSH
71032: CALL_OW 69
71036: ST_TO_ADDR
// if not tmp then
71037: LD_VAR 0 1
71041: NOT
71042: IFFALSE 71046
// exit ;
71044: GO 71072
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
71046: LD_VAR 0 1
71050: PUSH
71051: LD_INT 1
71053: PPUSH
71054: LD_VAR 0 1
71058: PPUSH
71059: CALL_OW 12
71063: ARRAY
71064: PPUSH
71065: LD_INT 100
71067: PPUSH
71068: CALL_OW 234
// end ;
71072: PPOPN 1
71074: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
71075: LD_EXP 98
71079: PUSH
71080: LD_EXP 112
71084: AND
71085: IFFALSE 71183
71087: GO 71089
71089: DISABLE
71090: LD_INT 0
71092: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
71093: LD_ADDR_VAR 0 1
71097: PUSH
71098: LD_INT 22
71100: PUSH
71101: LD_OWVAR 2
71105: PUSH
71106: EMPTY
71107: LIST
71108: LIST
71109: PUSH
71110: LD_INT 21
71112: PUSH
71113: LD_INT 1
71115: PUSH
71116: EMPTY
71117: LIST
71118: LIST
71119: PUSH
71120: EMPTY
71121: LIST
71122: LIST
71123: PPUSH
71124: CALL_OW 69
71128: ST_TO_ADDR
// if not tmp then
71129: LD_VAR 0 1
71133: NOT
71134: IFFALSE 71138
// exit ;
71136: GO 71183
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
71138: LD_VAR 0 1
71142: PUSH
71143: LD_INT 1
71145: PPUSH
71146: LD_VAR 0 1
71150: PPUSH
71151: CALL_OW 12
71155: ARRAY
71156: PPUSH
71157: LD_INT 1
71159: PPUSH
71160: LD_INT 4
71162: PPUSH
71163: CALL_OW 12
71167: PPUSH
71168: LD_INT 3000
71170: PPUSH
71171: LD_INT 9000
71173: PPUSH
71174: CALL_OW 12
71178: PPUSH
71179: CALL_OW 492
// end ;
71183: PPOPN 1
71185: END
// every 0 0$1 trigger StreamModeActive and sDepot do
71186: LD_EXP 98
71190: PUSH
71191: LD_EXP 113
71195: AND
71196: IFFALSE 71216
71198: GO 71200
71200: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
71201: LD_INT 1
71203: PPUSH
71204: LD_OWVAR 2
71208: PPUSH
71209: LD_INT 0
71211: PPUSH
71212: CALL_OW 324
71216: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
71217: LD_EXP 98
71221: PUSH
71222: LD_EXP 114
71226: AND
71227: IFFALSE 71310
71229: GO 71231
71231: DISABLE
71232: LD_INT 0
71234: PPUSH
71235: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
71236: LD_ADDR_VAR 0 2
71240: PUSH
71241: LD_INT 22
71243: PUSH
71244: LD_OWVAR 2
71248: PUSH
71249: EMPTY
71250: LIST
71251: LIST
71252: PUSH
71253: LD_INT 21
71255: PUSH
71256: LD_INT 3
71258: PUSH
71259: EMPTY
71260: LIST
71261: LIST
71262: PUSH
71263: EMPTY
71264: LIST
71265: LIST
71266: PPUSH
71267: CALL_OW 69
71271: ST_TO_ADDR
// if not tmp then
71272: LD_VAR 0 2
71276: NOT
71277: IFFALSE 71281
// exit ;
71279: GO 71310
// for i in tmp do
71281: LD_ADDR_VAR 0 1
71285: PUSH
71286: LD_VAR 0 2
71290: PUSH
71291: FOR_IN
71292: IFFALSE 71308
// SetBLevel ( i , 10 ) ;
71294: LD_VAR 0 1
71298: PPUSH
71299: LD_INT 10
71301: PPUSH
71302: CALL_OW 241
71306: GO 71291
71308: POP
71309: POP
// end ;
71310: PPOPN 2
71312: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
71313: LD_EXP 98
71317: PUSH
71318: LD_EXP 115
71322: AND
71323: IFFALSE 71434
71325: GO 71327
71327: DISABLE
71328: LD_INT 0
71330: PPUSH
71331: PPUSH
71332: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
71333: LD_ADDR_VAR 0 3
71337: PUSH
71338: LD_INT 22
71340: PUSH
71341: LD_OWVAR 2
71345: PUSH
71346: EMPTY
71347: LIST
71348: LIST
71349: PUSH
71350: LD_INT 25
71352: PUSH
71353: LD_INT 1
71355: PUSH
71356: EMPTY
71357: LIST
71358: LIST
71359: PUSH
71360: EMPTY
71361: LIST
71362: LIST
71363: PPUSH
71364: CALL_OW 69
71368: ST_TO_ADDR
// if not tmp then
71369: LD_VAR 0 3
71373: NOT
71374: IFFALSE 71378
// exit ;
71376: GO 71434
// un := tmp [ rand ( 1 , tmp ) ] ;
71378: LD_ADDR_VAR 0 2
71382: PUSH
71383: LD_VAR 0 3
71387: PUSH
71388: LD_INT 1
71390: PPUSH
71391: LD_VAR 0 3
71395: PPUSH
71396: CALL_OW 12
71400: ARRAY
71401: ST_TO_ADDR
// if Crawls ( un ) then
71402: LD_VAR 0 2
71406: PPUSH
71407: CALL_OW 318
71411: IFFALSE 71422
// ComWalk ( un ) ;
71413: LD_VAR 0 2
71417: PPUSH
71418: CALL_OW 138
// SetClass ( un , class_sniper ) ;
71422: LD_VAR 0 2
71426: PPUSH
71427: LD_INT 5
71429: PPUSH
71430: CALL_OW 336
// end ;
71434: PPOPN 3
71436: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 4 do
71437: LD_EXP 98
71441: PUSH
71442: LD_EXP 116
71446: AND
71447: PUSH
71448: LD_OWVAR 67
71452: PUSH
71453: LD_INT 4
71455: LESS
71456: AND
71457: IFFALSE 71476
71459: GO 71461
71461: DISABLE
// begin Difficulty := Difficulty + 1 ;
71462: LD_ADDR_OWVAR 67
71466: PUSH
71467: LD_OWVAR 67
71471: PUSH
71472: LD_INT 1
71474: PLUS
71475: ST_TO_ADDR
// end ;
71476: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
71477: LD_EXP 98
71481: PUSH
71482: LD_EXP 117
71486: AND
71487: IFFALSE 71590
71489: GO 71491
71491: DISABLE
71492: LD_INT 0
71494: PPUSH
// begin for i := 1 to 5 do
71495: LD_ADDR_VAR 0 1
71499: PUSH
71500: DOUBLE
71501: LD_INT 1
71503: DEC
71504: ST_TO_ADDR
71505: LD_INT 5
71507: PUSH
71508: FOR_TO
71509: IFFALSE 71588
// begin uc_nation := nation_nature ;
71511: LD_ADDR_OWVAR 21
71515: PUSH
71516: LD_INT 0
71518: ST_TO_ADDR
// uc_side := 0 ;
71519: LD_ADDR_OWVAR 20
71523: PUSH
71524: LD_INT 0
71526: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
71527: LD_ADDR_OWVAR 29
71531: PUSH
71532: LD_INT 12
71534: PUSH
71535: LD_INT 12
71537: PUSH
71538: EMPTY
71539: LIST
71540: LIST
71541: ST_TO_ADDR
// hc_agressivity := 20 ;
71542: LD_ADDR_OWVAR 35
71546: PUSH
71547: LD_INT 20
71549: ST_TO_ADDR
// hc_class := class_tiger ;
71550: LD_ADDR_OWVAR 28
71554: PUSH
71555: LD_INT 14
71557: ST_TO_ADDR
// hc_gallery :=  ;
71558: LD_ADDR_OWVAR 33
71562: PUSH
71563: LD_STRING 
71565: ST_TO_ADDR
// hc_name :=  ;
71566: LD_ADDR_OWVAR 26
71570: PUSH
71571: LD_STRING 
71573: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
71574: CALL_OW 44
71578: PPUSH
71579: LD_INT 0
71581: PPUSH
71582: CALL_OW 51
// end ;
71586: GO 71508
71588: POP
71589: POP
// end ;
71590: PPOPN 1
71592: END
// every 0 0$1 trigger StreamModeActive and sBomb do
71593: LD_EXP 98
71597: PUSH
71598: LD_EXP 118
71602: AND
71603: IFFALSE 71612
71605: GO 71607
71607: DISABLE
// StreamSibBomb ;
71608: CALL 71613 0 0
71612: END
// export function StreamSibBomb ; var i , x , y ; begin
71613: LD_INT 0
71615: PPUSH
71616: PPUSH
71617: PPUSH
71618: PPUSH
// result := false ;
71619: LD_ADDR_VAR 0 1
71623: PUSH
71624: LD_INT 0
71626: ST_TO_ADDR
// for i := 1 to 16 do
71627: LD_ADDR_VAR 0 2
71631: PUSH
71632: DOUBLE
71633: LD_INT 1
71635: DEC
71636: ST_TO_ADDR
71637: LD_INT 16
71639: PUSH
71640: FOR_TO
71641: IFFALSE 71840
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
71643: LD_ADDR_VAR 0 3
71647: PUSH
71648: LD_INT 10
71650: PUSH
71651: LD_INT 20
71653: PUSH
71654: LD_INT 30
71656: PUSH
71657: LD_INT 40
71659: PUSH
71660: LD_INT 50
71662: PUSH
71663: LD_INT 60
71665: PUSH
71666: LD_INT 70
71668: PUSH
71669: LD_INT 80
71671: PUSH
71672: LD_INT 90
71674: PUSH
71675: LD_INT 100
71677: PUSH
71678: LD_INT 110
71680: PUSH
71681: LD_INT 120
71683: PUSH
71684: LD_INT 130
71686: PUSH
71687: LD_INT 140
71689: PUSH
71690: LD_INT 150
71692: PUSH
71693: EMPTY
71694: LIST
71695: LIST
71696: LIST
71697: LIST
71698: LIST
71699: LIST
71700: LIST
71701: LIST
71702: LIST
71703: LIST
71704: LIST
71705: LIST
71706: LIST
71707: LIST
71708: LIST
71709: PUSH
71710: LD_INT 1
71712: PPUSH
71713: LD_INT 15
71715: PPUSH
71716: CALL_OW 12
71720: ARRAY
71721: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
71722: LD_ADDR_VAR 0 4
71726: PUSH
71727: LD_INT 10
71729: PUSH
71730: LD_INT 20
71732: PUSH
71733: LD_INT 30
71735: PUSH
71736: LD_INT 40
71738: PUSH
71739: LD_INT 50
71741: PUSH
71742: LD_INT 60
71744: PUSH
71745: LD_INT 70
71747: PUSH
71748: LD_INT 80
71750: PUSH
71751: LD_INT 90
71753: PUSH
71754: LD_INT 100
71756: PUSH
71757: LD_INT 110
71759: PUSH
71760: LD_INT 120
71762: PUSH
71763: LD_INT 130
71765: PUSH
71766: LD_INT 140
71768: PUSH
71769: LD_INT 150
71771: PUSH
71772: EMPTY
71773: LIST
71774: LIST
71775: LIST
71776: LIST
71777: LIST
71778: LIST
71779: LIST
71780: LIST
71781: LIST
71782: LIST
71783: LIST
71784: LIST
71785: LIST
71786: LIST
71787: LIST
71788: PUSH
71789: LD_INT 1
71791: PPUSH
71792: LD_INT 15
71794: PPUSH
71795: CALL_OW 12
71799: ARRAY
71800: ST_TO_ADDR
// if ValidHex ( x , y ) then
71801: LD_VAR 0 3
71805: PPUSH
71806: LD_VAR 0 4
71810: PPUSH
71811: CALL_OW 488
71815: IFFALSE 71838
// begin result := [ x , y ] ;
71817: LD_ADDR_VAR 0 1
71821: PUSH
71822: LD_VAR 0 3
71826: PUSH
71827: LD_VAR 0 4
71831: PUSH
71832: EMPTY
71833: LIST
71834: LIST
71835: ST_TO_ADDR
// break ;
71836: GO 71840
// end ; end ;
71838: GO 71640
71840: POP
71841: POP
// if result then
71842: LD_VAR 0 1
71846: IFFALSE 71906
// begin ToLua ( playSibBomb() ) ;
71848: LD_STRING playSibBomb()
71850: PPUSH
71851: CALL_OW 559
// wait ( 0 0$14 ) ;
71855: LD_INT 490
71857: PPUSH
71858: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
71862: LD_VAR 0 1
71866: PUSH
71867: LD_INT 1
71869: ARRAY
71870: PPUSH
71871: LD_VAR 0 1
71875: PUSH
71876: LD_INT 2
71878: ARRAY
71879: PPUSH
71880: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
71884: LD_VAR 0 1
71888: PUSH
71889: LD_INT 1
71891: ARRAY
71892: PPUSH
71893: LD_VAR 0 1
71897: PUSH
71898: LD_INT 2
71900: ARRAY
71901: PPUSH
71902: CALL_OW 429
// end ; end ;
71906: LD_VAR 0 1
71910: RET
// every 0 0$1 trigger StreamModeActive and sReset do
71911: LD_EXP 98
71915: PUSH
71916: LD_EXP 120
71920: AND
71921: IFFALSE 71933
71923: GO 71925
71925: DISABLE
// YouLost (  ) ;
71926: LD_STRING 
71928: PPUSH
71929: CALL_OW 104
71933: END
// every 0 0$1 trigger StreamModeActive and sFog do
71934: LD_EXP 98
71938: PUSH
71939: LD_EXP 119
71943: AND
71944: IFFALSE 71958
71946: GO 71948
71948: DISABLE
// FogOff ( your_side ) ;
71949: LD_OWVAR 2
71953: PPUSH
71954: CALL_OW 344
71958: END
// every 0 0$1 trigger StreamModeActive and sSun do
71959: LD_EXP 98
71963: PUSH
71964: LD_EXP 121
71968: AND
71969: IFFALSE 71997
71971: GO 71973
71973: DISABLE
// begin solar_recharge_percent := 0 ;
71974: LD_ADDR_OWVAR 79
71978: PUSH
71979: LD_INT 0
71981: ST_TO_ADDR
// wait ( 5 5$00 ) ;
71982: LD_INT 10500
71984: PPUSH
71985: CALL_OW 67
// solar_recharge_percent := 100 ;
71989: LD_ADDR_OWVAR 79
71993: PUSH
71994: LD_INT 100
71996: ST_TO_ADDR
// end ;
71997: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
71998: LD_EXP 98
72002: PUSH
72003: LD_EXP 122
72007: AND
72008: IFFALSE 72247
72010: GO 72012
72012: DISABLE
72013: LD_INT 0
72015: PPUSH
72016: PPUSH
72017: PPUSH
// begin tmp := [ ] ;
72018: LD_ADDR_VAR 0 3
72022: PUSH
72023: EMPTY
72024: ST_TO_ADDR
// for i := 1 to 6 do
72025: LD_ADDR_VAR 0 1
72029: PUSH
72030: DOUBLE
72031: LD_INT 1
72033: DEC
72034: ST_TO_ADDR
72035: LD_INT 6
72037: PUSH
72038: FOR_TO
72039: IFFALSE 72144
// begin uc_nation := nation_nature ;
72041: LD_ADDR_OWVAR 21
72045: PUSH
72046: LD_INT 0
72048: ST_TO_ADDR
// uc_side := 0 ;
72049: LD_ADDR_OWVAR 20
72053: PUSH
72054: LD_INT 0
72056: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
72057: LD_ADDR_OWVAR 29
72061: PUSH
72062: LD_INT 12
72064: PUSH
72065: LD_INT 12
72067: PUSH
72068: EMPTY
72069: LIST
72070: LIST
72071: ST_TO_ADDR
// hc_agressivity := 20 ;
72072: LD_ADDR_OWVAR 35
72076: PUSH
72077: LD_INT 20
72079: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
72080: LD_ADDR_OWVAR 28
72084: PUSH
72085: LD_INT 17
72087: ST_TO_ADDR
// hc_gallery :=  ;
72088: LD_ADDR_OWVAR 33
72092: PUSH
72093: LD_STRING 
72095: ST_TO_ADDR
// hc_name :=  ;
72096: LD_ADDR_OWVAR 26
72100: PUSH
72101: LD_STRING 
72103: ST_TO_ADDR
// un := CreateHuman ;
72104: LD_ADDR_VAR 0 2
72108: PUSH
72109: CALL_OW 44
72113: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
72114: LD_VAR 0 2
72118: PPUSH
72119: LD_INT 1
72121: PPUSH
72122: CALL_OW 51
// tmp := tmp ^ un ;
72126: LD_ADDR_VAR 0 3
72130: PUSH
72131: LD_VAR 0 3
72135: PUSH
72136: LD_VAR 0 2
72140: ADD
72141: ST_TO_ADDR
// end ;
72142: GO 72038
72144: POP
72145: POP
// repeat wait ( 0 0$1 ) ;
72146: LD_INT 35
72148: PPUSH
72149: CALL_OW 67
// for un in tmp do
72153: LD_ADDR_VAR 0 2
72157: PUSH
72158: LD_VAR 0 3
72162: PUSH
72163: FOR_IN
72164: IFFALSE 72238
// begin if IsDead ( un ) then
72166: LD_VAR 0 2
72170: PPUSH
72171: CALL_OW 301
72175: IFFALSE 72195
// begin tmp := tmp diff un ;
72177: LD_ADDR_VAR 0 3
72181: PUSH
72182: LD_VAR 0 3
72186: PUSH
72187: LD_VAR 0 2
72191: DIFF
72192: ST_TO_ADDR
// continue ;
72193: GO 72163
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
72195: LD_VAR 0 2
72199: PPUSH
72200: LD_INT 3
72202: PUSH
72203: LD_INT 22
72205: PUSH
72206: LD_INT 0
72208: PUSH
72209: EMPTY
72210: LIST
72211: LIST
72212: PUSH
72213: EMPTY
72214: LIST
72215: LIST
72216: PPUSH
72217: CALL_OW 69
72221: PPUSH
72222: LD_VAR 0 2
72226: PPUSH
72227: CALL_OW 74
72231: PPUSH
72232: CALL_OW 115
// end ;
72236: GO 72163
72238: POP
72239: POP
// until not tmp ;
72240: LD_VAR 0 3
72244: NOT
72245: IFFALSE 72146
// end ;
72247: PPOPN 3
72249: END
// every 0 0$1 trigger StreamModeActive and sTroll do
72250: LD_EXP 98
72254: PUSH
72255: LD_EXP 123
72259: AND
72260: IFFALSE 72314
72262: GO 72264
72264: DISABLE
// begin ToLua ( displayTroll(); ) ;
72265: LD_STRING displayTroll();
72267: PPUSH
72268: CALL_OW 559
// wait ( 3 3$00 ) ;
72272: LD_INT 6300
72274: PPUSH
72275: CALL_OW 67
// ToLua ( hideTroll(); ) ;
72279: LD_STRING hideTroll();
72281: PPUSH
72282: CALL_OW 559
// wait ( 1 1$00 ) ;
72286: LD_INT 2100
72288: PPUSH
72289: CALL_OW 67
// ToLua ( displayTroll(); ) ;
72293: LD_STRING displayTroll();
72295: PPUSH
72296: CALL_OW 559
// wait ( 1 1$00 ) ;
72300: LD_INT 2100
72302: PPUSH
72303: CALL_OW 67
// ToLua ( hideTroll(); ) ;
72307: LD_STRING hideTroll();
72309: PPUSH
72310: CALL_OW 559
// end ;
72314: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
72315: LD_EXP 98
72319: PUSH
72320: LD_EXP 124
72324: AND
72325: IFFALSE 72388
72327: GO 72329
72329: DISABLE
72330: LD_INT 0
72332: PPUSH
// begin p := 0 ;
72333: LD_ADDR_VAR 0 1
72337: PUSH
72338: LD_INT 0
72340: ST_TO_ADDR
// repeat game_speed := 1 ;
72341: LD_ADDR_OWVAR 65
72345: PUSH
72346: LD_INT 1
72348: ST_TO_ADDR
// wait ( 0 0$1 ) ;
72349: LD_INT 35
72351: PPUSH
72352: CALL_OW 67
// p := p + 1 ;
72356: LD_ADDR_VAR 0 1
72360: PUSH
72361: LD_VAR 0 1
72365: PUSH
72366: LD_INT 1
72368: PLUS
72369: ST_TO_ADDR
// until p >= 60 ;
72370: LD_VAR 0 1
72374: PUSH
72375: LD_INT 60
72377: GREATEREQUAL
72378: IFFALSE 72341
// game_speed := 4 ;
72380: LD_ADDR_OWVAR 65
72384: PUSH
72385: LD_INT 4
72387: ST_TO_ADDR
// end ;
72388: PPOPN 1
72390: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
72391: LD_EXP 98
72395: PUSH
72396: LD_EXP 125
72400: AND
72401: IFFALSE 72547
72403: GO 72405
72405: DISABLE
72406: LD_INT 0
72408: PPUSH
72409: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
72410: LD_ADDR_VAR 0 1
72414: PUSH
72415: LD_INT 22
72417: PUSH
72418: LD_OWVAR 2
72422: PUSH
72423: EMPTY
72424: LIST
72425: LIST
72426: PUSH
72427: LD_INT 2
72429: PUSH
72430: LD_INT 30
72432: PUSH
72433: LD_INT 0
72435: PUSH
72436: EMPTY
72437: LIST
72438: LIST
72439: PUSH
72440: LD_INT 30
72442: PUSH
72443: LD_INT 1
72445: PUSH
72446: EMPTY
72447: LIST
72448: LIST
72449: PUSH
72450: EMPTY
72451: LIST
72452: LIST
72453: LIST
72454: PUSH
72455: EMPTY
72456: LIST
72457: LIST
72458: PPUSH
72459: CALL_OW 69
72463: ST_TO_ADDR
// if not depot then
72464: LD_VAR 0 1
72468: NOT
72469: IFFALSE 72473
// exit ;
72471: GO 72547
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
72473: LD_ADDR_VAR 0 2
72477: PUSH
72478: LD_VAR 0 1
72482: PUSH
72483: LD_INT 1
72485: PPUSH
72486: LD_VAR 0 1
72490: PPUSH
72491: CALL_OW 12
72495: ARRAY
72496: PPUSH
72497: CALL_OW 274
72501: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
72502: LD_VAR 0 2
72506: PPUSH
72507: LD_INT 1
72509: PPUSH
72510: LD_INT 0
72512: PPUSH
72513: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
72517: LD_VAR 0 2
72521: PPUSH
72522: LD_INT 2
72524: PPUSH
72525: LD_INT 0
72527: PPUSH
72528: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
72532: LD_VAR 0 2
72536: PPUSH
72537: LD_INT 3
72539: PPUSH
72540: LD_INT 0
72542: PPUSH
72543: CALL_OW 277
// end ;
72547: PPOPN 2
72549: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
72550: LD_EXP 98
72554: PUSH
72555: LD_EXP 126
72559: AND
72560: IFFALSE 72657
72562: GO 72564
72564: DISABLE
72565: LD_INT 0
72567: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
72568: LD_ADDR_VAR 0 1
72572: PUSH
72573: LD_INT 22
72575: PUSH
72576: LD_OWVAR 2
72580: PUSH
72581: EMPTY
72582: LIST
72583: LIST
72584: PUSH
72585: LD_INT 21
72587: PUSH
72588: LD_INT 1
72590: PUSH
72591: EMPTY
72592: LIST
72593: LIST
72594: PUSH
72595: LD_INT 3
72597: PUSH
72598: LD_INT 23
72600: PUSH
72601: LD_INT 0
72603: PUSH
72604: EMPTY
72605: LIST
72606: LIST
72607: PUSH
72608: EMPTY
72609: LIST
72610: LIST
72611: PUSH
72612: EMPTY
72613: LIST
72614: LIST
72615: LIST
72616: PPUSH
72617: CALL_OW 69
72621: ST_TO_ADDR
// if not tmp then
72622: LD_VAR 0 1
72626: NOT
72627: IFFALSE 72631
// exit ;
72629: GO 72657
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
72631: LD_VAR 0 1
72635: PUSH
72636: LD_INT 1
72638: PPUSH
72639: LD_VAR 0 1
72643: PPUSH
72644: CALL_OW 12
72648: ARRAY
72649: PPUSH
72650: LD_INT 200
72652: PPUSH
72653: CALL_OW 234
// end ;
72657: PPOPN 1
72659: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
72660: LD_EXP 98
72664: PUSH
72665: LD_EXP 127
72669: AND
72670: IFFALSE 72749
72672: GO 72674
72674: DISABLE
72675: LD_INT 0
72677: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
72678: LD_ADDR_VAR 0 1
72682: PUSH
72683: LD_INT 22
72685: PUSH
72686: LD_OWVAR 2
72690: PUSH
72691: EMPTY
72692: LIST
72693: LIST
72694: PUSH
72695: LD_INT 21
72697: PUSH
72698: LD_INT 2
72700: PUSH
72701: EMPTY
72702: LIST
72703: LIST
72704: PUSH
72705: EMPTY
72706: LIST
72707: LIST
72708: PPUSH
72709: CALL_OW 69
72713: ST_TO_ADDR
// if not tmp then
72714: LD_VAR 0 1
72718: NOT
72719: IFFALSE 72723
// exit ;
72721: GO 72749
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
72723: LD_VAR 0 1
72727: PUSH
72728: LD_INT 1
72730: PPUSH
72731: LD_VAR 0 1
72735: PPUSH
72736: CALL_OW 12
72740: ARRAY
72741: PPUSH
72742: LD_INT 60
72744: PPUSH
72745: CALL_OW 234
// end ;
72749: PPOPN 1
72751: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
72752: LD_EXP 98
72756: PUSH
72757: LD_EXP 128
72761: AND
72762: IFFALSE 72861
72764: GO 72766
72766: DISABLE
72767: LD_INT 0
72769: PPUSH
72770: PPUSH
// begin enable ;
72771: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
72772: LD_ADDR_VAR 0 1
72776: PUSH
72777: LD_INT 22
72779: PUSH
72780: LD_OWVAR 2
72784: PUSH
72785: EMPTY
72786: LIST
72787: LIST
72788: PUSH
72789: LD_INT 61
72791: PUSH
72792: EMPTY
72793: LIST
72794: PUSH
72795: LD_INT 33
72797: PUSH
72798: LD_INT 2
72800: PUSH
72801: EMPTY
72802: LIST
72803: LIST
72804: PUSH
72805: EMPTY
72806: LIST
72807: LIST
72808: LIST
72809: PPUSH
72810: CALL_OW 69
72814: ST_TO_ADDR
// if not tmp then
72815: LD_VAR 0 1
72819: NOT
72820: IFFALSE 72824
// exit ;
72822: GO 72861
// for i in tmp do
72824: LD_ADDR_VAR 0 2
72828: PUSH
72829: LD_VAR 0 1
72833: PUSH
72834: FOR_IN
72835: IFFALSE 72859
// if IsControledBy ( i ) then
72837: LD_VAR 0 2
72841: PPUSH
72842: CALL_OW 312
72846: IFFALSE 72857
// ComUnlink ( i ) ;
72848: LD_VAR 0 2
72852: PPUSH
72853: CALL_OW 136
72857: GO 72834
72859: POP
72860: POP
// end ;
72861: PPOPN 2
72863: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
72864: LD_EXP 98
72868: PUSH
72869: LD_EXP 129
72873: AND
72874: IFFALSE 73014
72876: GO 72878
72878: DISABLE
72879: LD_INT 0
72881: PPUSH
72882: PPUSH
// begin ToLua ( displayPowell(); ) ;
72883: LD_STRING displayPowell();
72885: PPUSH
72886: CALL_OW 559
// uc_side := 0 ;
72890: LD_ADDR_OWVAR 20
72894: PUSH
72895: LD_INT 0
72897: ST_TO_ADDR
// uc_nation := 2 ;
72898: LD_ADDR_OWVAR 21
72902: PUSH
72903: LD_INT 2
72905: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
72906: LD_ADDR_OWVAR 37
72910: PUSH
72911: LD_INT 14
72913: ST_TO_ADDR
// vc_engine := engine_siberite ;
72914: LD_ADDR_OWVAR 39
72918: PUSH
72919: LD_INT 3
72921: ST_TO_ADDR
// vc_control := control_apeman ;
72922: LD_ADDR_OWVAR 38
72926: PUSH
72927: LD_INT 5
72929: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
72930: LD_ADDR_OWVAR 40
72934: PUSH
72935: LD_INT 29
72937: ST_TO_ADDR
// un := CreateVehicle ;
72938: LD_ADDR_VAR 0 2
72942: PUSH
72943: CALL_OW 45
72947: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
72948: LD_VAR 0 2
72952: PPUSH
72953: LD_INT 1
72955: PPUSH
72956: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
72960: LD_INT 35
72962: PPUSH
72963: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
72967: LD_VAR 0 2
72971: PPUSH
72972: LD_INT 22
72974: PUSH
72975: LD_OWVAR 2
72979: PUSH
72980: EMPTY
72981: LIST
72982: LIST
72983: PPUSH
72984: CALL_OW 69
72988: PPUSH
72989: LD_VAR 0 2
72993: PPUSH
72994: CALL_OW 74
72998: PPUSH
72999: CALL_OW 115
// until IsDead ( un ) ;
73003: LD_VAR 0 2
73007: PPUSH
73008: CALL_OW 301
73012: IFFALSE 72960
// end ;
73014: PPOPN 2
73016: END
// every 0 0$1 trigger StreamModeActive and sStu do
73017: LD_EXP 98
73021: PUSH
73022: LD_EXP 137
73026: AND
73027: IFFALSE 73043
73029: GO 73031
73031: DISABLE
// begin ToLua ( displayStucuk(); ) ;
73032: LD_STRING displayStucuk();
73034: PPUSH
73035: CALL_OW 559
// ResetFog ;
73039: CALL_OW 335
// end ;
73043: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
73044: LD_EXP 98
73048: PUSH
73049: LD_EXP 130
73053: AND
73054: IFFALSE 73195
73056: GO 73058
73058: DISABLE
73059: LD_INT 0
73061: PPUSH
73062: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
73063: LD_ADDR_VAR 0 2
73067: PUSH
73068: LD_INT 22
73070: PUSH
73071: LD_OWVAR 2
73075: PUSH
73076: EMPTY
73077: LIST
73078: LIST
73079: PUSH
73080: LD_INT 21
73082: PUSH
73083: LD_INT 1
73085: PUSH
73086: EMPTY
73087: LIST
73088: LIST
73089: PUSH
73090: EMPTY
73091: LIST
73092: LIST
73093: PPUSH
73094: CALL_OW 69
73098: ST_TO_ADDR
// if not tmp then
73099: LD_VAR 0 2
73103: NOT
73104: IFFALSE 73108
// exit ;
73106: GO 73195
// un := tmp [ rand ( 1 , tmp ) ] ;
73108: LD_ADDR_VAR 0 1
73112: PUSH
73113: LD_VAR 0 2
73117: PUSH
73118: LD_INT 1
73120: PPUSH
73121: LD_VAR 0 2
73125: PPUSH
73126: CALL_OW 12
73130: ARRAY
73131: ST_TO_ADDR
// SetSide ( un , 0 ) ;
73132: LD_VAR 0 1
73136: PPUSH
73137: LD_INT 0
73139: PPUSH
73140: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
73144: LD_VAR 0 1
73148: PPUSH
73149: LD_OWVAR 3
73153: PUSH
73154: LD_VAR 0 1
73158: DIFF
73159: PPUSH
73160: LD_VAR 0 1
73164: PPUSH
73165: CALL_OW 74
73169: PPUSH
73170: CALL_OW 115
// wait ( 0 0$20 ) ;
73174: LD_INT 700
73176: PPUSH
73177: CALL_OW 67
// SetSide ( un , your_side ) ;
73181: LD_VAR 0 1
73185: PPUSH
73186: LD_OWVAR 2
73190: PPUSH
73191: CALL_OW 235
// end ;
73195: PPOPN 2
73197: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
73198: LD_EXP 98
73202: PUSH
73203: LD_EXP 131
73207: AND
73208: IFFALSE 73314
73210: GO 73212
73212: DISABLE
73213: LD_INT 0
73215: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
73216: LD_ADDR_VAR 0 1
73220: PUSH
73221: LD_INT 22
73223: PUSH
73224: LD_OWVAR 2
73228: PUSH
73229: EMPTY
73230: LIST
73231: LIST
73232: PUSH
73233: LD_INT 2
73235: PUSH
73236: LD_INT 30
73238: PUSH
73239: LD_INT 0
73241: PUSH
73242: EMPTY
73243: LIST
73244: LIST
73245: PUSH
73246: LD_INT 30
73248: PUSH
73249: LD_INT 1
73251: PUSH
73252: EMPTY
73253: LIST
73254: LIST
73255: PUSH
73256: EMPTY
73257: LIST
73258: LIST
73259: LIST
73260: PUSH
73261: EMPTY
73262: LIST
73263: LIST
73264: PPUSH
73265: CALL_OW 69
73269: ST_TO_ADDR
// if not depot then
73270: LD_VAR 0 1
73274: NOT
73275: IFFALSE 73279
// exit ;
73277: GO 73314
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
73279: LD_VAR 0 1
73283: PUSH
73284: LD_INT 1
73286: ARRAY
73287: PPUSH
73288: CALL_OW 250
73292: PPUSH
73293: LD_VAR 0 1
73297: PUSH
73298: LD_INT 1
73300: ARRAY
73301: PPUSH
73302: CALL_OW 251
73306: PPUSH
73307: LD_INT 70
73309: PPUSH
73310: CALL_OW 495
// end ;
73314: PPOPN 1
73316: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
73317: LD_EXP 98
73321: PUSH
73322: LD_EXP 132
73326: AND
73327: IFFALSE 73538
73329: GO 73331
73331: DISABLE
73332: LD_INT 0
73334: PPUSH
73335: PPUSH
73336: PPUSH
73337: PPUSH
73338: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
73339: LD_ADDR_VAR 0 5
73343: PUSH
73344: LD_INT 22
73346: PUSH
73347: LD_OWVAR 2
73351: PUSH
73352: EMPTY
73353: LIST
73354: LIST
73355: PUSH
73356: LD_INT 21
73358: PUSH
73359: LD_INT 1
73361: PUSH
73362: EMPTY
73363: LIST
73364: LIST
73365: PUSH
73366: EMPTY
73367: LIST
73368: LIST
73369: PPUSH
73370: CALL_OW 69
73374: ST_TO_ADDR
// if not tmp then
73375: LD_VAR 0 5
73379: NOT
73380: IFFALSE 73384
// exit ;
73382: GO 73538
// for i in tmp do
73384: LD_ADDR_VAR 0 1
73388: PUSH
73389: LD_VAR 0 5
73393: PUSH
73394: FOR_IN
73395: IFFALSE 73536
// begin d := rand ( 0 , 5 ) ;
73397: LD_ADDR_VAR 0 4
73401: PUSH
73402: LD_INT 0
73404: PPUSH
73405: LD_INT 5
73407: PPUSH
73408: CALL_OW 12
73412: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
73413: LD_ADDR_VAR 0 2
73417: PUSH
73418: LD_VAR 0 1
73422: PPUSH
73423: CALL_OW 250
73427: PPUSH
73428: LD_VAR 0 4
73432: PPUSH
73433: LD_INT 3
73435: PPUSH
73436: LD_INT 12
73438: PPUSH
73439: CALL_OW 12
73443: PPUSH
73444: CALL_OW 272
73448: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
73449: LD_ADDR_VAR 0 3
73453: PUSH
73454: LD_VAR 0 1
73458: PPUSH
73459: CALL_OW 251
73463: PPUSH
73464: LD_VAR 0 4
73468: PPUSH
73469: LD_INT 3
73471: PPUSH
73472: LD_INT 12
73474: PPUSH
73475: CALL_OW 12
73479: PPUSH
73480: CALL_OW 273
73484: ST_TO_ADDR
// if ValidHex ( x , y ) then
73485: LD_VAR 0 2
73489: PPUSH
73490: LD_VAR 0 3
73494: PPUSH
73495: CALL_OW 488
73499: IFFALSE 73534
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
73501: LD_VAR 0 1
73505: PPUSH
73506: LD_VAR 0 2
73510: PPUSH
73511: LD_VAR 0 3
73515: PPUSH
73516: LD_INT 3
73518: PPUSH
73519: LD_INT 6
73521: PPUSH
73522: CALL_OW 12
73526: PPUSH
73527: LD_INT 1
73529: PPUSH
73530: CALL_OW 483
// end ;
73534: GO 73394
73536: POP
73537: POP
// end ;
73538: PPOPN 5
73540: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
73541: LD_EXP 98
73545: PUSH
73546: LD_EXP 133
73550: AND
73551: IFFALSE 73645
73553: GO 73555
73555: DISABLE
73556: LD_INT 0
73558: PPUSH
73559: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
73560: LD_ADDR_VAR 0 2
73564: PUSH
73565: LD_INT 22
73567: PUSH
73568: LD_OWVAR 2
73572: PUSH
73573: EMPTY
73574: LIST
73575: LIST
73576: PUSH
73577: LD_INT 32
73579: PUSH
73580: LD_INT 1
73582: PUSH
73583: EMPTY
73584: LIST
73585: LIST
73586: PUSH
73587: LD_INT 21
73589: PUSH
73590: LD_INT 2
73592: PUSH
73593: EMPTY
73594: LIST
73595: LIST
73596: PUSH
73597: EMPTY
73598: LIST
73599: LIST
73600: LIST
73601: PPUSH
73602: CALL_OW 69
73606: ST_TO_ADDR
// if not tmp then
73607: LD_VAR 0 2
73611: NOT
73612: IFFALSE 73616
// exit ;
73614: GO 73645
// for i in tmp do
73616: LD_ADDR_VAR 0 1
73620: PUSH
73621: LD_VAR 0 2
73625: PUSH
73626: FOR_IN
73627: IFFALSE 73643
// SetFuel ( i , 0 ) ;
73629: LD_VAR 0 1
73633: PPUSH
73634: LD_INT 0
73636: PPUSH
73637: CALL_OW 240
73641: GO 73626
73643: POP
73644: POP
// end ;
73645: PPOPN 2
73647: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
73648: LD_EXP 98
73652: PUSH
73653: LD_EXP 134
73657: AND
73658: IFFALSE 73724
73660: GO 73662
73662: DISABLE
73663: LD_INT 0
73665: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
73666: LD_ADDR_VAR 0 1
73670: PUSH
73671: LD_INT 22
73673: PUSH
73674: LD_OWVAR 2
73678: PUSH
73679: EMPTY
73680: LIST
73681: LIST
73682: PUSH
73683: LD_INT 30
73685: PUSH
73686: LD_INT 29
73688: PUSH
73689: EMPTY
73690: LIST
73691: LIST
73692: PUSH
73693: EMPTY
73694: LIST
73695: LIST
73696: PPUSH
73697: CALL_OW 69
73701: ST_TO_ADDR
// if not tmp then
73702: LD_VAR 0 1
73706: NOT
73707: IFFALSE 73711
// exit ;
73709: GO 73724
// DestroyUnit ( tmp [ 1 ] ) ;
73711: LD_VAR 0 1
73715: PUSH
73716: LD_INT 1
73718: ARRAY
73719: PPUSH
73720: CALL_OW 65
// end ;
73724: PPOPN 1
73726: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
73727: LD_EXP 98
73731: PUSH
73732: LD_EXP 136
73736: AND
73737: IFFALSE 73866
73739: GO 73741
73741: DISABLE
73742: LD_INT 0
73744: PPUSH
// begin uc_side := 0 ;
73745: LD_ADDR_OWVAR 20
73749: PUSH
73750: LD_INT 0
73752: ST_TO_ADDR
// uc_nation := nation_arabian ;
73753: LD_ADDR_OWVAR 21
73757: PUSH
73758: LD_INT 2
73760: ST_TO_ADDR
// hc_gallery :=  ;
73761: LD_ADDR_OWVAR 33
73765: PUSH
73766: LD_STRING 
73768: ST_TO_ADDR
// hc_name :=  ;
73769: LD_ADDR_OWVAR 26
73773: PUSH
73774: LD_STRING 
73776: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
73777: LD_INT 1
73779: PPUSH
73780: LD_INT 11
73782: PPUSH
73783: LD_INT 10
73785: PPUSH
73786: CALL_OW 380
// un := CreateHuman ;
73790: LD_ADDR_VAR 0 1
73794: PUSH
73795: CALL_OW 44
73799: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
73800: LD_VAR 0 1
73804: PPUSH
73805: LD_INT 1
73807: PPUSH
73808: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
73812: LD_INT 35
73814: PPUSH
73815: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
73819: LD_VAR 0 1
73823: PPUSH
73824: LD_INT 22
73826: PUSH
73827: LD_OWVAR 2
73831: PUSH
73832: EMPTY
73833: LIST
73834: LIST
73835: PPUSH
73836: CALL_OW 69
73840: PPUSH
73841: LD_VAR 0 1
73845: PPUSH
73846: CALL_OW 74
73850: PPUSH
73851: CALL_OW 115
// until IsDead ( un ) ;
73855: LD_VAR 0 1
73859: PPUSH
73860: CALL_OW 301
73864: IFFALSE 73812
// end ;
73866: PPOPN 1
73868: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
73869: LD_EXP 98
73873: PUSH
73874: LD_EXP 138
73878: AND
73879: IFFALSE 73891
73881: GO 73883
73883: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
73884: LD_STRING earthquake(getX(game), 0, 32)
73886: PPUSH
73887: CALL_OW 559
73891: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
73892: LD_EXP 98
73896: PUSH
73897: LD_EXP 139
73901: AND
73902: IFFALSE 73993
73904: GO 73906
73906: DISABLE
73907: LD_INT 0
73909: PPUSH
// begin enable ;
73910: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
73911: LD_ADDR_VAR 0 1
73915: PUSH
73916: LD_INT 22
73918: PUSH
73919: LD_OWVAR 2
73923: PUSH
73924: EMPTY
73925: LIST
73926: LIST
73927: PUSH
73928: LD_INT 21
73930: PUSH
73931: LD_INT 2
73933: PUSH
73934: EMPTY
73935: LIST
73936: LIST
73937: PUSH
73938: LD_INT 33
73940: PUSH
73941: LD_INT 3
73943: PUSH
73944: EMPTY
73945: LIST
73946: LIST
73947: PUSH
73948: EMPTY
73949: LIST
73950: LIST
73951: LIST
73952: PPUSH
73953: CALL_OW 69
73957: ST_TO_ADDR
// if not tmp then
73958: LD_VAR 0 1
73962: NOT
73963: IFFALSE 73967
// exit ;
73965: GO 73993
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
73967: LD_VAR 0 1
73971: PUSH
73972: LD_INT 1
73974: PPUSH
73975: LD_VAR 0 1
73979: PPUSH
73980: CALL_OW 12
73984: ARRAY
73985: PPUSH
73986: LD_INT 1
73988: PPUSH
73989: CALL_OW 234
// end ;
73993: PPOPN 1
73995: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
73996: LD_EXP 98
74000: PUSH
74001: LD_EXP 140
74005: AND
74006: IFFALSE 74147
74008: GO 74010
74010: DISABLE
74011: LD_INT 0
74013: PPUSH
74014: PPUSH
74015: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
74016: LD_ADDR_VAR 0 3
74020: PUSH
74021: LD_INT 22
74023: PUSH
74024: LD_OWVAR 2
74028: PUSH
74029: EMPTY
74030: LIST
74031: LIST
74032: PUSH
74033: LD_INT 25
74035: PUSH
74036: LD_INT 1
74038: PUSH
74039: EMPTY
74040: LIST
74041: LIST
74042: PUSH
74043: EMPTY
74044: LIST
74045: LIST
74046: PPUSH
74047: CALL_OW 69
74051: ST_TO_ADDR
// if not tmp then
74052: LD_VAR 0 3
74056: NOT
74057: IFFALSE 74061
// exit ;
74059: GO 74147
// un := tmp [ rand ( 1 , tmp ) ] ;
74061: LD_ADDR_VAR 0 2
74065: PUSH
74066: LD_VAR 0 3
74070: PUSH
74071: LD_INT 1
74073: PPUSH
74074: LD_VAR 0 3
74078: PPUSH
74079: CALL_OW 12
74083: ARRAY
74084: ST_TO_ADDR
// if Crawls ( un ) then
74085: LD_VAR 0 2
74089: PPUSH
74090: CALL_OW 318
74094: IFFALSE 74105
// ComWalk ( un ) ;
74096: LD_VAR 0 2
74100: PPUSH
74101: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
74105: LD_VAR 0 2
74109: PPUSH
74110: LD_INT 9
74112: PPUSH
74113: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
74117: LD_INT 28
74119: PPUSH
74120: LD_OWVAR 2
74124: PPUSH
74125: LD_INT 2
74127: PPUSH
74128: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
74132: LD_INT 29
74134: PPUSH
74135: LD_OWVAR 2
74139: PPUSH
74140: LD_INT 2
74142: PPUSH
74143: CALL_OW 322
// end ;
74147: PPOPN 3
74149: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
74150: LD_EXP 98
74154: PUSH
74155: LD_EXP 141
74159: AND
74160: IFFALSE 74271
74162: GO 74164
74164: DISABLE
74165: LD_INT 0
74167: PPUSH
74168: PPUSH
74169: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
74170: LD_ADDR_VAR 0 3
74174: PUSH
74175: LD_INT 22
74177: PUSH
74178: LD_OWVAR 2
74182: PUSH
74183: EMPTY
74184: LIST
74185: LIST
74186: PUSH
74187: LD_INT 25
74189: PUSH
74190: LD_INT 1
74192: PUSH
74193: EMPTY
74194: LIST
74195: LIST
74196: PUSH
74197: EMPTY
74198: LIST
74199: LIST
74200: PPUSH
74201: CALL_OW 69
74205: ST_TO_ADDR
// if not tmp then
74206: LD_VAR 0 3
74210: NOT
74211: IFFALSE 74215
// exit ;
74213: GO 74271
// un := tmp [ rand ( 1 , tmp ) ] ;
74215: LD_ADDR_VAR 0 2
74219: PUSH
74220: LD_VAR 0 3
74224: PUSH
74225: LD_INT 1
74227: PPUSH
74228: LD_VAR 0 3
74232: PPUSH
74233: CALL_OW 12
74237: ARRAY
74238: ST_TO_ADDR
// if Crawls ( un ) then
74239: LD_VAR 0 2
74243: PPUSH
74244: CALL_OW 318
74248: IFFALSE 74259
// ComWalk ( un ) ;
74250: LD_VAR 0 2
74254: PPUSH
74255: CALL_OW 138
// SetClass ( un , class_mortar ) ;
74259: LD_VAR 0 2
74263: PPUSH
74264: LD_INT 8
74266: PPUSH
74267: CALL_OW 336
// end ;
74271: PPOPN 3
74273: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
74274: LD_EXP 98
74278: PUSH
74279: LD_EXP 142
74283: AND
74284: IFFALSE 74428
74286: GO 74288
74288: DISABLE
74289: LD_INT 0
74291: PPUSH
74292: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
74293: LD_ADDR_VAR 0 2
74297: PUSH
74298: LD_INT 22
74300: PUSH
74301: LD_OWVAR 2
74305: PUSH
74306: EMPTY
74307: LIST
74308: LIST
74309: PUSH
74310: LD_INT 21
74312: PUSH
74313: LD_INT 2
74315: PUSH
74316: EMPTY
74317: LIST
74318: LIST
74319: PUSH
74320: LD_INT 2
74322: PUSH
74323: LD_INT 34
74325: PUSH
74326: LD_INT 12
74328: PUSH
74329: EMPTY
74330: LIST
74331: LIST
74332: PUSH
74333: LD_INT 34
74335: PUSH
74336: LD_INT 51
74338: PUSH
74339: EMPTY
74340: LIST
74341: LIST
74342: PUSH
74343: LD_INT 34
74345: PUSH
74346: LD_INT 32
74348: PUSH
74349: EMPTY
74350: LIST
74351: LIST
74352: PUSH
74353: EMPTY
74354: LIST
74355: LIST
74356: LIST
74357: LIST
74358: PUSH
74359: EMPTY
74360: LIST
74361: LIST
74362: LIST
74363: PPUSH
74364: CALL_OW 69
74368: ST_TO_ADDR
// if not tmp then
74369: LD_VAR 0 2
74373: NOT
74374: IFFALSE 74378
// exit ;
74376: GO 74428
// for i in tmp do
74378: LD_ADDR_VAR 0 1
74382: PUSH
74383: LD_VAR 0 2
74387: PUSH
74388: FOR_IN
74389: IFFALSE 74426
// if GetCargo ( i , mat_artifact ) = 0 then
74391: LD_VAR 0 1
74395: PPUSH
74396: LD_INT 4
74398: PPUSH
74399: CALL_OW 289
74403: PUSH
74404: LD_INT 0
74406: EQUAL
74407: IFFALSE 74424
// SetCargo ( i , mat_siberit , 100 ) ;
74409: LD_VAR 0 1
74413: PPUSH
74414: LD_INT 3
74416: PPUSH
74417: LD_INT 100
74419: PPUSH
74420: CALL_OW 290
74424: GO 74388
74426: POP
74427: POP
// end ;
74428: PPOPN 2
74430: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
74431: LD_EXP 98
74435: PUSH
74436: LD_EXP 143
74440: AND
74441: IFFALSE 74624
74443: GO 74445
74445: DISABLE
74446: LD_INT 0
74448: PPUSH
74449: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
74450: LD_ADDR_VAR 0 2
74454: PUSH
74455: LD_INT 22
74457: PUSH
74458: LD_OWVAR 2
74462: PUSH
74463: EMPTY
74464: LIST
74465: LIST
74466: PPUSH
74467: CALL_OW 69
74471: ST_TO_ADDR
// if not tmp then
74472: LD_VAR 0 2
74476: NOT
74477: IFFALSE 74481
// exit ;
74479: GO 74624
// for i := 1 to 2 do
74481: LD_ADDR_VAR 0 1
74485: PUSH
74486: DOUBLE
74487: LD_INT 1
74489: DEC
74490: ST_TO_ADDR
74491: LD_INT 2
74493: PUSH
74494: FOR_TO
74495: IFFALSE 74622
// begin uc_side := your_side ;
74497: LD_ADDR_OWVAR 20
74501: PUSH
74502: LD_OWVAR 2
74506: ST_TO_ADDR
// uc_nation := nation_american ;
74507: LD_ADDR_OWVAR 21
74511: PUSH
74512: LD_INT 1
74514: ST_TO_ADDR
// vc_chassis := us_morphling ;
74515: LD_ADDR_OWVAR 37
74519: PUSH
74520: LD_INT 5
74522: ST_TO_ADDR
// vc_engine := engine_siberite ;
74523: LD_ADDR_OWVAR 39
74527: PUSH
74528: LD_INT 3
74530: ST_TO_ADDR
// vc_control := control_computer ;
74531: LD_ADDR_OWVAR 38
74535: PUSH
74536: LD_INT 3
74538: ST_TO_ADDR
// vc_weapon := us_double_laser ;
74539: LD_ADDR_OWVAR 40
74543: PUSH
74544: LD_INT 10
74546: ST_TO_ADDR
// if not IsInUnit ( tmp [ 1 ] ) then
74547: LD_VAR 0 2
74551: PUSH
74552: LD_INT 1
74554: ARRAY
74555: PPUSH
74556: CALL_OW 310
74560: NOT
74561: IFFALSE 74608
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) else
74563: CALL_OW 45
74567: PPUSH
74568: LD_VAR 0 2
74572: PUSH
74573: LD_INT 1
74575: ARRAY
74576: PPUSH
74577: CALL_OW 250
74581: PPUSH
74582: LD_VAR 0 2
74586: PUSH
74587: LD_INT 1
74589: ARRAY
74590: PPUSH
74591: CALL_OW 251
74595: PPUSH
74596: LD_INT 12
74598: PPUSH
74599: LD_INT 1
74601: PPUSH
74602: CALL_OW 50
74606: GO 74620
// PlaceUnitAnywhere ( CreateVehicle , true ) ;
74608: CALL_OW 45
74612: PPUSH
74613: LD_INT 1
74615: PPUSH
74616: CALL_OW 51
// end ;
74620: GO 74494
74622: POP
74623: POP
// end ;
74624: PPOPN 2
74626: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
74627: LD_EXP 98
74631: PUSH
74632: LD_EXP 144
74636: AND
74637: IFFALSE 74859
74639: GO 74641
74641: DISABLE
74642: LD_INT 0
74644: PPUSH
74645: PPUSH
74646: PPUSH
74647: PPUSH
74648: PPUSH
74649: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
74650: LD_ADDR_VAR 0 6
74654: PUSH
74655: LD_INT 22
74657: PUSH
74658: LD_OWVAR 2
74662: PUSH
74663: EMPTY
74664: LIST
74665: LIST
74666: PUSH
74667: LD_INT 21
74669: PUSH
74670: LD_INT 1
74672: PUSH
74673: EMPTY
74674: LIST
74675: LIST
74676: PUSH
74677: LD_INT 3
74679: PUSH
74680: LD_INT 23
74682: PUSH
74683: LD_INT 0
74685: PUSH
74686: EMPTY
74687: LIST
74688: LIST
74689: PUSH
74690: EMPTY
74691: LIST
74692: LIST
74693: PUSH
74694: EMPTY
74695: LIST
74696: LIST
74697: LIST
74698: PPUSH
74699: CALL_OW 69
74703: ST_TO_ADDR
// if not tmp then
74704: LD_VAR 0 6
74708: NOT
74709: IFFALSE 74713
// exit ;
74711: GO 74859
// s1 := rand ( 1 , 4 ) ;
74713: LD_ADDR_VAR 0 2
74717: PUSH
74718: LD_INT 1
74720: PPUSH
74721: LD_INT 4
74723: PPUSH
74724: CALL_OW 12
74728: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
74729: LD_ADDR_VAR 0 4
74733: PUSH
74734: LD_VAR 0 6
74738: PUSH
74739: LD_INT 1
74741: ARRAY
74742: PPUSH
74743: LD_VAR 0 2
74747: PPUSH
74748: CALL_OW 259
74752: ST_TO_ADDR
// if s1 = 1 then
74753: LD_VAR 0 2
74757: PUSH
74758: LD_INT 1
74760: EQUAL
74761: IFFALSE 74781
// s2 := rand ( 2 , 4 ) else
74763: LD_ADDR_VAR 0 3
74767: PUSH
74768: LD_INT 2
74770: PPUSH
74771: LD_INT 4
74773: PPUSH
74774: CALL_OW 12
74778: ST_TO_ADDR
74779: GO 74789
// s2 := 1 ;
74781: LD_ADDR_VAR 0 3
74785: PUSH
74786: LD_INT 1
74788: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
74789: LD_ADDR_VAR 0 5
74793: PUSH
74794: LD_VAR 0 6
74798: PUSH
74799: LD_INT 1
74801: ARRAY
74802: PPUSH
74803: LD_VAR 0 3
74807: PPUSH
74808: CALL_OW 259
74812: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
74813: LD_VAR 0 6
74817: PUSH
74818: LD_INT 1
74820: ARRAY
74821: PPUSH
74822: LD_VAR 0 2
74826: PPUSH
74827: LD_VAR 0 5
74831: PPUSH
74832: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
74836: LD_VAR 0 6
74840: PUSH
74841: LD_INT 1
74843: ARRAY
74844: PPUSH
74845: LD_VAR 0 3
74849: PPUSH
74850: LD_VAR 0 4
74854: PPUSH
74855: CALL_OW 237
// end ;
74859: PPOPN 6
74861: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
74862: LD_EXP 98
74866: PUSH
74867: LD_EXP 145
74871: AND
74872: IFFALSE 74951
74874: GO 74876
74876: DISABLE
74877: LD_INT 0
74879: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
74880: LD_ADDR_VAR 0 1
74884: PUSH
74885: LD_INT 22
74887: PUSH
74888: LD_OWVAR 2
74892: PUSH
74893: EMPTY
74894: LIST
74895: LIST
74896: PUSH
74897: LD_INT 30
74899: PUSH
74900: LD_INT 3
74902: PUSH
74903: EMPTY
74904: LIST
74905: LIST
74906: PUSH
74907: EMPTY
74908: LIST
74909: LIST
74910: PPUSH
74911: CALL_OW 69
74915: ST_TO_ADDR
// if not tmp then
74916: LD_VAR 0 1
74920: NOT
74921: IFFALSE 74925
// exit ;
74923: GO 74951
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
74925: LD_VAR 0 1
74929: PUSH
74930: LD_INT 1
74932: PPUSH
74933: LD_VAR 0 1
74937: PPUSH
74938: CALL_OW 12
74942: ARRAY
74943: PPUSH
74944: LD_INT 1
74946: PPUSH
74947: CALL_OW 234
// end ;
74951: PPOPN 1
74953: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
74954: LD_EXP 98
74958: PUSH
74959: LD_EXP 146
74963: AND
74964: IFFALSE 75076
74966: GO 74968
74968: DISABLE
74969: LD_INT 0
74971: PPUSH
74972: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
74973: LD_ADDR_VAR 0 2
74977: PUSH
74978: LD_INT 22
74980: PUSH
74981: LD_OWVAR 2
74985: PUSH
74986: EMPTY
74987: LIST
74988: LIST
74989: PUSH
74990: LD_INT 2
74992: PUSH
74993: LD_INT 30
74995: PUSH
74996: LD_INT 27
74998: PUSH
74999: EMPTY
75000: LIST
75001: LIST
75002: PUSH
75003: LD_INT 30
75005: PUSH
75006: LD_INT 26
75008: PUSH
75009: EMPTY
75010: LIST
75011: LIST
75012: PUSH
75013: LD_INT 30
75015: PUSH
75016: LD_INT 28
75018: PUSH
75019: EMPTY
75020: LIST
75021: LIST
75022: PUSH
75023: EMPTY
75024: LIST
75025: LIST
75026: LIST
75027: LIST
75028: PUSH
75029: EMPTY
75030: LIST
75031: LIST
75032: PPUSH
75033: CALL_OW 69
75037: ST_TO_ADDR
// if not tmp then
75038: LD_VAR 0 2
75042: NOT
75043: IFFALSE 75047
// exit ;
75045: GO 75076
// for i in tmp do
75047: LD_ADDR_VAR 0 1
75051: PUSH
75052: LD_VAR 0 2
75056: PUSH
75057: FOR_IN
75058: IFFALSE 75074
// SetLives ( i , 1 ) ;
75060: LD_VAR 0 1
75064: PPUSH
75065: LD_INT 1
75067: PPUSH
75068: CALL_OW 234
75072: GO 75057
75074: POP
75075: POP
// end ;
75076: PPOPN 2
75078: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
75079: LD_EXP 98
75083: PUSH
75084: LD_EXP 147
75088: AND
75089: IFFALSE 75376
75091: GO 75093
75093: DISABLE
75094: LD_INT 0
75096: PPUSH
75097: PPUSH
75098: PPUSH
// begin i := rand ( 1 , 7 ) ;
75099: LD_ADDR_VAR 0 1
75103: PUSH
75104: LD_INT 1
75106: PPUSH
75107: LD_INT 7
75109: PPUSH
75110: CALL_OW 12
75114: ST_TO_ADDR
// case i of 1 :
75115: LD_VAR 0 1
75119: PUSH
75120: LD_INT 1
75122: DOUBLE
75123: EQUAL
75124: IFTRUE 75128
75126: GO 75138
75128: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
75129: LD_STRING earthquake(getX(game), 0, 32)
75131: PPUSH
75132: CALL_OW 559
75136: GO 75376
75138: LD_INT 2
75140: DOUBLE
75141: EQUAL
75142: IFTRUE 75146
75144: GO 75160
75146: POP
// begin ToLua ( displayStucuk(); ) ;
75147: LD_STRING displayStucuk();
75149: PPUSH
75150: CALL_OW 559
// ResetFog ;
75154: CALL_OW 335
// end ; 3 :
75158: GO 75376
75160: LD_INT 3
75162: DOUBLE
75163: EQUAL
75164: IFTRUE 75168
75166: GO 75272
75168: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
75169: LD_ADDR_VAR 0 2
75173: PUSH
75174: LD_INT 22
75176: PUSH
75177: LD_OWVAR 2
75181: PUSH
75182: EMPTY
75183: LIST
75184: LIST
75185: PUSH
75186: LD_INT 25
75188: PUSH
75189: LD_INT 1
75191: PUSH
75192: EMPTY
75193: LIST
75194: LIST
75195: PUSH
75196: EMPTY
75197: LIST
75198: LIST
75199: PPUSH
75200: CALL_OW 69
75204: ST_TO_ADDR
// if not tmp then
75205: LD_VAR 0 2
75209: NOT
75210: IFFALSE 75214
// exit ;
75212: GO 75376
// un := tmp [ rand ( 1 , tmp ) ] ;
75214: LD_ADDR_VAR 0 3
75218: PUSH
75219: LD_VAR 0 2
75223: PUSH
75224: LD_INT 1
75226: PPUSH
75227: LD_VAR 0 2
75231: PPUSH
75232: CALL_OW 12
75236: ARRAY
75237: ST_TO_ADDR
// if Crawls ( un ) then
75238: LD_VAR 0 3
75242: PPUSH
75243: CALL_OW 318
75247: IFFALSE 75258
// ComWalk ( un ) ;
75249: LD_VAR 0 3
75253: PPUSH
75254: CALL_OW 138
// SetClass ( un , class_mortar ) ;
75258: LD_VAR 0 3
75262: PPUSH
75263: LD_INT 8
75265: PPUSH
75266: CALL_OW 336
// end ; 4 :
75270: GO 75376
75272: LD_INT 4
75274: DOUBLE
75275: EQUAL
75276: IFTRUE 75280
75278: GO 75354
75280: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
75281: LD_ADDR_VAR 0 2
75285: PUSH
75286: LD_INT 22
75288: PUSH
75289: LD_OWVAR 2
75293: PUSH
75294: EMPTY
75295: LIST
75296: LIST
75297: PUSH
75298: LD_INT 30
75300: PUSH
75301: LD_INT 29
75303: PUSH
75304: EMPTY
75305: LIST
75306: LIST
75307: PUSH
75308: EMPTY
75309: LIST
75310: LIST
75311: PPUSH
75312: CALL_OW 69
75316: ST_TO_ADDR
// if not tmp then
75317: LD_VAR 0 2
75321: NOT
75322: IFFALSE 75326
// exit ;
75324: GO 75376
// CenterNowOnUnits ( tmp [ 1 ] ) ;
75326: LD_VAR 0 2
75330: PUSH
75331: LD_INT 1
75333: ARRAY
75334: PPUSH
75335: CALL_OW 87
// DestroyUnit ( tmp [ 1 ] ) ;
75339: LD_VAR 0 2
75343: PUSH
75344: LD_INT 1
75346: ARRAY
75347: PPUSH
75348: CALL_OW 65
// end ; 5 .. 7 :
75352: GO 75376
75354: LD_INT 5
75356: DOUBLE
75357: GREATEREQUAL
75358: IFFALSE 75366
75360: LD_INT 7
75362: DOUBLE
75363: LESSEQUAL
75364: IFTRUE 75368
75366: GO 75375
75368: POP
// StreamSibBomb ; end ;
75369: CALL 71613 0 0
75373: GO 75376
75375: POP
// end ;
75376: PPOPN 3
75378: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
75379: LD_EXP 98
75383: PUSH
75384: LD_EXP 148
75388: AND
75389: IFFALSE 75545
75391: GO 75393
75393: DISABLE
75394: LD_INT 0
75396: PPUSH
75397: PPUSH
75398: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
75399: LD_ADDR_VAR 0 2
75403: PUSH
75404: LD_INT 81
75406: PUSH
75407: LD_OWVAR 2
75411: PUSH
75412: EMPTY
75413: LIST
75414: LIST
75415: PUSH
75416: LD_INT 2
75418: PUSH
75419: LD_INT 21
75421: PUSH
75422: LD_INT 1
75424: PUSH
75425: EMPTY
75426: LIST
75427: LIST
75428: PUSH
75429: LD_INT 21
75431: PUSH
75432: LD_INT 2
75434: PUSH
75435: EMPTY
75436: LIST
75437: LIST
75438: PUSH
75439: EMPTY
75440: LIST
75441: LIST
75442: LIST
75443: PUSH
75444: EMPTY
75445: LIST
75446: LIST
75447: PPUSH
75448: CALL_OW 69
75452: ST_TO_ADDR
// if not tmp then
75453: LD_VAR 0 2
75457: NOT
75458: IFFALSE 75462
// exit ;
75460: GO 75545
// p := 0 ;
75462: LD_ADDR_VAR 0 3
75466: PUSH
75467: LD_INT 0
75469: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
75470: LD_INT 35
75472: PPUSH
75473: CALL_OW 67
// p := p + 1 ;
75477: LD_ADDR_VAR 0 3
75481: PUSH
75482: LD_VAR 0 3
75486: PUSH
75487: LD_INT 1
75489: PLUS
75490: ST_TO_ADDR
// for i in tmp do
75491: LD_ADDR_VAR 0 1
75495: PUSH
75496: LD_VAR 0 2
75500: PUSH
75501: FOR_IN
75502: IFFALSE 75533
// if GetLives ( i ) < 1000 then
75504: LD_VAR 0 1
75508: PPUSH
75509: CALL_OW 256
75513: PUSH
75514: LD_INT 1000
75516: LESS
75517: IFFALSE 75531
// SetLives ( i , 1000 ) ;
75519: LD_VAR 0 1
75523: PPUSH
75524: LD_INT 1000
75526: PPUSH
75527: CALL_OW 234
75531: GO 75501
75533: POP
75534: POP
// until p > 20 ;
75535: LD_VAR 0 3
75539: PUSH
75540: LD_INT 20
75542: GREATER
75543: IFFALSE 75470
// end ;
75545: PPOPN 3
75547: END
// every 0 0$1 trigger StreamModeActive and sTime do
75548: LD_EXP 98
75552: PUSH
75553: LD_EXP 149
75557: AND
75558: IFFALSE 75593
75560: GO 75562
75562: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
75563: LD_INT 28
75565: PPUSH
75566: LD_OWVAR 2
75570: PPUSH
75571: LD_INT 2
75573: PPUSH
75574: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
75578: LD_INT 30
75580: PPUSH
75581: LD_OWVAR 2
75585: PPUSH
75586: LD_INT 2
75588: PPUSH
75589: CALL_OW 322
// end ;
75593: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
75594: LD_EXP 98
75598: PUSH
75599: LD_EXP 150
75603: AND
75604: IFFALSE 75725
75606: GO 75608
75608: DISABLE
75609: LD_INT 0
75611: PPUSH
75612: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
75613: LD_ADDR_VAR 0 2
75617: PUSH
75618: LD_INT 22
75620: PUSH
75621: LD_OWVAR 2
75625: PUSH
75626: EMPTY
75627: LIST
75628: LIST
75629: PUSH
75630: LD_INT 21
75632: PUSH
75633: LD_INT 1
75635: PUSH
75636: EMPTY
75637: LIST
75638: LIST
75639: PUSH
75640: LD_INT 3
75642: PUSH
75643: LD_INT 23
75645: PUSH
75646: LD_INT 0
75648: PUSH
75649: EMPTY
75650: LIST
75651: LIST
75652: PUSH
75653: EMPTY
75654: LIST
75655: LIST
75656: PUSH
75657: EMPTY
75658: LIST
75659: LIST
75660: LIST
75661: PPUSH
75662: CALL_OW 69
75666: ST_TO_ADDR
// if not tmp then
75667: LD_VAR 0 2
75671: NOT
75672: IFFALSE 75676
// exit ;
75674: GO 75725
// for i in tmp do
75676: LD_ADDR_VAR 0 1
75680: PUSH
75681: LD_VAR 0 2
75685: PUSH
75686: FOR_IN
75687: IFFALSE 75723
// begin if Crawls ( i ) then
75689: LD_VAR 0 1
75693: PPUSH
75694: CALL_OW 318
75698: IFFALSE 75709
// ComWalk ( i ) ;
75700: LD_VAR 0 1
75704: PPUSH
75705: CALL_OW 138
// SetClass ( i , 2 ) ;
75709: LD_VAR 0 1
75713: PPUSH
75714: LD_INT 2
75716: PPUSH
75717: CALL_OW 336
// end ;
75721: GO 75686
75723: POP
75724: POP
// end ;
75725: PPOPN 2
75727: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
75728: LD_EXP 98
75732: PUSH
75733: LD_EXP 151
75737: AND
75738: IFFALSE 76026
75740: GO 75742
75742: DISABLE
75743: LD_INT 0
75745: PPUSH
75746: PPUSH
75747: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
75748: LD_OWVAR 2
75752: PPUSH
75753: LD_INT 9
75755: PPUSH
75756: LD_INT 1
75758: PPUSH
75759: LD_INT 1
75761: PPUSH
75762: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
75766: LD_INT 9
75768: PPUSH
75769: LD_OWVAR 2
75773: PPUSH
75774: CALL_OW 343
// uc_side := 9 ;
75778: LD_ADDR_OWVAR 20
75782: PUSH
75783: LD_INT 9
75785: ST_TO_ADDR
// uc_nation := 2 ;
75786: LD_ADDR_OWVAR 21
75790: PUSH
75791: LD_INT 2
75793: ST_TO_ADDR
// hc_name := Dark Warrior ;
75794: LD_ADDR_OWVAR 26
75798: PUSH
75799: LD_STRING Dark Warrior
75801: ST_TO_ADDR
// hc_gallery :=  ;
75802: LD_ADDR_OWVAR 33
75806: PUSH
75807: LD_STRING 
75809: ST_TO_ADDR
// hc_noskilllimit := true ;
75810: LD_ADDR_OWVAR 76
75814: PUSH
75815: LD_INT 1
75817: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
75818: LD_ADDR_OWVAR 31
75822: PUSH
75823: LD_INT 30
75825: PUSH
75826: LD_INT 30
75828: PUSH
75829: LD_INT 30
75831: PUSH
75832: LD_INT 30
75834: PUSH
75835: EMPTY
75836: LIST
75837: LIST
75838: LIST
75839: LIST
75840: ST_TO_ADDR
// un := CreateHuman ;
75841: LD_ADDR_VAR 0 3
75845: PUSH
75846: CALL_OW 44
75850: ST_TO_ADDR
// hc_noskilllimit := false ;
75851: LD_ADDR_OWVAR 76
75855: PUSH
75856: LD_INT 0
75858: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
75859: LD_VAR 0 3
75863: PPUSH
75864: LD_INT 1
75866: PPUSH
75867: CALL_OW 51
// ToLua ( playRanger() ) ;
75871: LD_STRING playRanger()
75873: PPUSH
75874: CALL_OW 559
// p := 0 ;
75878: LD_ADDR_VAR 0 2
75882: PUSH
75883: LD_INT 0
75885: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
75886: LD_INT 35
75888: PPUSH
75889: CALL_OW 67
// p := p + 1 ;
75893: LD_ADDR_VAR 0 2
75897: PUSH
75898: LD_VAR 0 2
75902: PUSH
75903: LD_INT 1
75905: PLUS
75906: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
75907: LD_VAR 0 3
75911: PPUSH
75912: CALL_OW 256
75916: PUSH
75917: LD_INT 1000
75919: LESS
75920: IFFALSE 75934
// SetLives ( un , 1000 ) ;
75922: LD_VAR 0 3
75926: PPUSH
75927: LD_INT 1000
75929: PPUSH
75930: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
75934: LD_VAR 0 3
75938: PPUSH
75939: LD_INT 81
75941: PUSH
75942: LD_OWVAR 2
75946: PUSH
75947: EMPTY
75948: LIST
75949: LIST
75950: PUSH
75951: LD_INT 91
75953: PUSH
75954: LD_VAR 0 3
75958: PUSH
75959: LD_INT 30
75961: PUSH
75962: EMPTY
75963: LIST
75964: LIST
75965: LIST
75966: PUSH
75967: EMPTY
75968: LIST
75969: LIST
75970: PPUSH
75971: CALL_OW 69
75975: PPUSH
75976: LD_VAR 0 3
75980: PPUSH
75981: CALL_OW 74
75985: PPUSH
75986: CALL_OW 115
// until p > 80 or IsDead ( un ) ;
75990: LD_VAR 0 2
75994: PUSH
75995: LD_INT 80
75997: GREATER
75998: PUSH
75999: LD_VAR 0 3
76003: PPUSH
76004: CALL_OW 301
76008: OR
76009: IFFALSE 75886
// if un then
76011: LD_VAR 0 3
76015: IFFALSE 76026
// RemoveUnit ( un ) ;
76017: LD_VAR 0 3
76021: PPUSH
76022: CALL_OW 64
// end ;
76026: PPOPN 3
76028: END
// every 0 0$1 trigger sComputer do var i , tmp , j ;
76029: LD_EXP 152
76033: IFFALSE 76149
76035: GO 76037
76037: DISABLE
76038: LD_INT 0
76040: PPUSH
76041: PPUSH
76042: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
76043: LD_ADDR_VAR 0 2
76047: PUSH
76048: LD_INT 81
76050: PUSH
76051: LD_OWVAR 2
76055: PUSH
76056: EMPTY
76057: LIST
76058: LIST
76059: PUSH
76060: LD_INT 21
76062: PUSH
76063: LD_INT 1
76065: PUSH
76066: EMPTY
76067: LIST
76068: LIST
76069: PUSH
76070: EMPTY
76071: LIST
76072: LIST
76073: PPUSH
76074: CALL_OW 69
76078: ST_TO_ADDR
// ToLua ( playComputer() ) ;
76079: LD_STRING playComputer()
76081: PPUSH
76082: CALL_OW 559
// if not tmp then
76086: LD_VAR 0 2
76090: NOT
76091: IFFALSE 76095
// exit ;
76093: GO 76149
// for i in tmp do
76095: LD_ADDR_VAR 0 1
76099: PUSH
76100: LD_VAR 0 2
76104: PUSH
76105: FOR_IN
76106: IFFALSE 76147
// for j := 1 to 4 do
76108: LD_ADDR_VAR 0 3
76112: PUSH
76113: DOUBLE
76114: LD_INT 1
76116: DEC
76117: ST_TO_ADDR
76118: LD_INT 4
76120: PUSH
76121: FOR_TO
76122: IFFALSE 76143
// SetSkill ( i , j , 10 ) ;
76124: LD_VAR 0 1
76128: PPUSH
76129: LD_VAR 0 3
76133: PPUSH
76134: LD_INT 10
76136: PPUSH
76137: CALL_OW 237
76141: GO 76121
76143: POP
76144: POP
76145: GO 76105
76147: POP
76148: POP
// end ;
76149: PPOPN 3
76151: END
// every 0 0$1 trigger s30 do var i , tmp ;
76152: LD_EXP 153
76156: IFFALSE 76225
76158: GO 76160
76160: DISABLE
76161: LD_INT 0
76163: PPUSH
76164: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
76165: LD_ADDR_VAR 0 2
76169: PUSH
76170: LD_INT 22
76172: PUSH
76173: LD_OWVAR 2
76177: PUSH
76178: EMPTY
76179: LIST
76180: LIST
76181: PPUSH
76182: CALL_OW 69
76186: ST_TO_ADDR
// if not tmp then
76187: LD_VAR 0 2
76191: NOT
76192: IFFALSE 76196
// exit ;
76194: GO 76225
// for i in tmp do
76196: LD_ADDR_VAR 0 1
76200: PUSH
76201: LD_VAR 0 2
76205: PUSH
76206: FOR_IN
76207: IFFALSE 76223
// SetLives ( i , 300 ) ;
76209: LD_VAR 0 1
76213: PPUSH
76214: LD_INT 300
76216: PPUSH
76217: CALL_OW 234
76221: GO 76206
76223: POP
76224: POP
// end ;
76225: PPOPN 2
76227: END
// every 0 0$1 trigger s60 do var i , tmp ;
76228: LD_EXP 154
76232: IFFALSE 76301
76234: GO 76236
76236: DISABLE
76237: LD_INT 0
76239: PPUSH
76240: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
76241: LD_ADDR_VAR 0 2
76245: PUSH
76246: LD_INT 22
76248: PUSH
76249: LD_OWVAR 2
76253: PUSH
76254: EMPTY
76255: LIST
76256: LIST
76257: PPUSH
76258: CALL_OW 69
76262: ST_TO_ADDR
// if not tmp then
76263: LD_VAR 0 2
76267: NOT
76268: IFFALSE 76272
// exit ;
76270: GO 76301
// for i in tmp do
76272: LD_ADDR_VAR 0 1
76276: PUSH
76277: LD_VAR 0 2
76281: PUSH
76282: FOR_IN
76283: IFFALSE 76299
// SetLives ( i , 600 ) ;
76285: LD_VAR 0 1
76289: PPUSH
76290: LD_INT 600
76292: PPUSH
76293: CALL_OW 234
76297: GO 76282
76299: POP
76300: POP
// end ;
76301: PPOPN 2
76303: END
// export function SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
76304: LD_INT 0
76306: PPUSH
// case cmd of 301 :
76307: LD_VAR 0 1
76311: PUSH
76312: LD_INT 301
76314: DOUBLE
76315: EQUAL
76316: IFTRUE 76320
76318: GO 76352
76320: POP
// hHackSpawnHuman ( p1 , p2 , p3 , x , y ) ; 302 :
76321: LD_VAR 0 6
76325: PPUSH
76326: LD_VAR 0 7
76330: PPUSH
76331: LD_VAR 0 8
76335: PPUSH
76336: LD_VAR 0 4
76340: PPUSH
76341: LD_VAR 0 5
76345: PPUSH
76346: CALL 77553 0 5
76350: GO 76473
76352: LD_INT 302
76354: DOUBLE
76355: EQUAL
76356: IFTRUE 76360
76358: GO 76397
76360: POP
// hHackSpawnVehicle ( p1 , p2 , p3 , p4 , x , y ) ; 303 :
76361: LD_VAR 0 6
76365: PPUSH
76366: LD_VAR 0 7
76370: PPUSH
76371: LD_VAR 0 8
76375: PPUSH
76376: LD_VAR 0 9
76380: PPUSH
76381: LD_VAR 0 4
76385: PPUSH
76386: LD_VAR 0 5
76390: PPUSH
76391: CALL 77644 0 6
76395: GO 76473
76397: LD_INT 303
76399: DOUBLE
76400: EQUAL
76401: IFTRUE 76405
76403: GO 76442
76405: POP
// hHackSpawnBuilding ( p1 , p2 , p3 , p4 , x , y ) ; 304 :
76406: LD_VAR 0 6
76410: PPUSH
76411: LD_VAR 0 7
76415: PPUSH
76416: LD_VAR 0 8
76420: PPUSH
76421: LD_VAR 0 9
76425: PPUSH
76426: LD_VAR 0 4
76430: PPUSH
76431: LD_VAR 0 5
76435: PPUSH
76436: CALL 76478 0 6
76440: GO 76473
76442: LD_INT 304
76444: DOUBLE
76445: EQUAL
76446: IFTRUE 76450
76448: GO 76472
76450: POP
// hHackTeleport ( unit , x , y ) ; end ;
76451: LD_VAR 0 2
76455: PPUSH
76456: LD_VAR 0 4
76460: PPUSH
76461: LD_VAR 0 5
76465: PPUSH
76466: CALL 78237 0 3
76470: GO 76473
76472: POP
// end ;
76473: LD_VAR 0 12
76477: RET
// export function hHackSpawnBuilding ( nation , btype , dir , weapon , x , y ) ; var b ; begin
76478: LD_INT 0
76480: PPUSH
76481: PPUSH
// if nation < 1 or nation > 3 or HexInfo ( x , y ) then
76482: LD_VAR 0 1
76486: PUSH
76487: LD_INT 1
76489: LESS
76490: PUSH
76491: LD_VAR 0 1
76495: PUSH
76496: LD_INT 3
76498: GREATER
76499: OR
76500: PUSH
76501: LD_VAR 0 5
76505: PPUSH
76506: LD_VAR 0 6
76510: PPUSH
76511: CALL_OW 428
76515: OR
76516: IFFALSE 76520
// exit ;
76518: GO 77240
// uc_side := your_side ;
76520: LD_ADDR_OWVAR 20
76524: PUSH
76525: LD_OWVAR 2
76529: ST_TO_ADDR
// uc_nation := nation ;
76530: LD_ADDR_OWVAR 21
76534: PUSH
76535: LD_VAR 0 1
76539: ST_TO_ADDR
// bc_level = 1 ;
76540: LD_ADDR_OWVAR 43
76544: PUSH
76545: LD_INT 1
76547: ST_TO_ADDR
// case btype of 1 :
76548: LD_VAR 0 2
76552: PUSH
76553: LD_INT 1
76555: DOUBLE
76556: EQUAL
76557: IFTRUE 76561
76559: GO 76572
76561: POP
// bc_type := b_depot ; 2 :
76562: LD_ADDR_OWVAR 42
76566: PUSH
76567: LD_INT 0
76569: ST_TO_ADDR
76570: GO 77184
76572: LD_INT 2
76574: DOUBLE
76575: EQUAL
76576: IFTRUE 76580
76578: GO 76591
76580: POP
// bc_type := b_warehouse ; 3 :
76581: LD_ADDR_OWVAR 42
76585: PUSH
76586: LD_INT 1
76588: ST_TO_ADDR
76589: GO 77184
76591: LD_INT 3
76593: DOUBLE
76594: EQUAL
76595: IFTRUE 76599
76597: GO 76610
76599: POP
// bc_type := b_lab ; 4 .. 9 :
76600: LD_ADDR_OWVAR 42
76604: PUSH
76605: LD_INT 6
76607: ST_TO_ADDR
76608: GO 77184
76610: LD_INT 4
76612: DOUBLE
76613: GREATEREQUAL
76614: IFFALSE 76622
76616: LD_INT 9
76618: DOUBLE
76619: LESSEQUAL
76620: IFTRUE 76624
76622: GO 76676
76624: POP
// begin bc_type := b_lab_half ;
76625: LD_ADDR_OWVAR 42
76629: PUSH
76630: LD_INT 7
76632: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_opto , b_lab_spacetime , b_lab_biological ] [ btype - 3 ] ;
76633: LD_ADDR_OWVAR 44
76637: PUSH
76638: LD_INT 10
76640: PUSH
76641: LD_INT 11
76643: PUSH
76644: LD_INT 12
76646: PUSH
76647: LD_INT 15
76649: PUSH
76650: LD_INT 14
76652: PUSH
76653: LD_INT 13
76655: PUSH
76656: EMPTY
76657: LIST
76658: LIST
76659: LIST
76660: LIST
76661: LIST
76662: LIST
76663: PUSH
76664: LD_VAR 0 2
76668: PUSH
76669: LD_INT 3
76671: MINUS
76672: ARRAY
76673: ST_TO_ADDR
// end ; 10 .. 13 :
76674: GO 77184
76676: LD_INT 10
76678: DOUBLE
76679: GREATEREQUAL
76680: IFFALSE 76688
76682: LD_INT 13
76684: DOUBLE
76685: LESSEQUAL
76686: IFTRUE 76690
76688: GO 76767
76690: POP
// begin bc_type := b_lab_full ;
76691: LD_ADDR_OWVAR 42
76695: PUSH
76696: LD_INT 8
76698: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_computer , b_lab_spacetime , b_lab_biological ] [ btype - 9 ] ;
76699: LD_ADDR_OWVAR 44
76703: PUSH
76704: LD_INT 10
76706: PUSH
76707: LD_INT 12
76709: PUSH
76710: LD_INT 14
76712: PUSH
76713: LD_INT 13
76715: PUSH
76716: EMPTY
76717: LIST
76718: LIST
76719: LIST
76720: LIST
76721: PUSH
76722: LD_VAR 0 2
76726: PUSH
76727: LD_INT 9
76729: MINUS
76730: ARRAY
76731: ST_TO_ADDR
// bc_kind2 := [ b_lab_siberium , b_lab_opto , b_lab_computer , b_lab_opto ] [ btype - 9 ] ;
76732: LD_ADDR_OWVAR 45
76736: PUSH
76737: LD_INT 11
76739: PUSH
76740: LD_INT 15
76742: PUSH
76743: LD_INT 12
76745: PUSH
76746: LD_INT 15
76748: PUSH
76749: EMPTY
76750: LIST
76751: LIST
76752: LIST
76753: LIST
76754: PUSH
76755: LD_VAR 0 2
76759: PUSH
76760: LD_INT 9
76762: MINUS
76763: ARRAY
76764: ST_TO_ADDR
// end ; 14 :
76765: GO 77184
76767: LD_INT 14
76769: DOUBLE
76770: EQUAL
76771: IFTRUE 76775
76773: GO 76786
76775: POP
// bc_type := b_workshop ; 15 :
76776: LD_ADDR_OWVAR 42
76780: PUSH
76781: LD_INT 2
76783: ST_TO_ADDR
76784: GO 77184
76786: LD_INT 15
76788: DOUBLE
76789: EQUAL
76790: IFTRUE 76794
76792: GO 76805
76794: POP
// bc_type := b_factory ; 16 :
76795: LD_ADDR_OWVAR 42
76799: PUSH
76800: LD_INT 3
76802: ST_TO_ADDR
76803: GO 77184
76805: LD_INT 16
76807: DOUBLE
76808: EQUAL
76809: IFTRUE 76813
76811: GO 76824
76813: POP
// bc_type := b_ext_gun ; 17 :
76814: LD_ADDR_OWVAR 42
76818: PUSH
76819: LD_INT 17
76821: ST_TO_ADDR
76822: GO 77184
76824: LD_INT 17
76826: DOUBLE
76827: EQUAL
76828: IFTRUE 76832
76830: GO 76860
76832: POP
// bc_type := [ b_ext_noncombat , b_ext_stitch , b_ext_noncombat ] [ nation ] ; 18 :
76833: LD_ADDR_OWVAR 42
76837: PUSH
76838: LD_INT 19
76840: PUSH
76841: LD_INT 23
76843: PUSH
76844: LD_INT 19
76846: PUSH
76847: EMPTY
76848: LIST
76849: LIST
76850: LIST
76851: PUSH
76852: LD_VAR 0 1
76856: ARRAY
76857: ST_TO_ADDR
76858: GO 77184
76860: LD_INT 18
76862: DOUBLE
76863: EQUAL
76864: IFTRUE 76868
76866: GO 76879
76868: POP
// bc_type := b_ext_radar ; 19 :
76869: LD_ADDR_OWVAR 42
76873: PUSH
76874: LD_INT 20
76876: ST_TO_ADDR
76877: GO 77184
76879: LD_INT 19
76881: DOUBLE
76882: EQUAL
76883: IFTRUE 76887
76885: GO 76898
76887: POP
// bc_type := b_ext_radio ; 20 :
76888: LD_ADDR_OWVAR 42
76892: PUSH
76893: LD_INT 22
76895: ST_TO_ADDR
76896: GO 77184
76898: LD_INT 20
76900: DOUBLE
76901: EQUAL
76902: IFTRUE 76906
76904: GO 76917
76906: POP
// bc_type := b_ext_siberium ; 21 :
76907: LD_ADDR_OWVAR 42
76911: PUSH
76912: LD_INT 21
76914: ST_TO_ADDR
76915: GO 77184
76917: LD_INT 21
76919: DOUBLE
76920: EQUAL
76921: IFTRUE 76925
76923: GO 76936
76925: POP
// bc_type := b_ext_computer ; 22 :
76926: LD_ADDR_OWVAR 42
76930: PUSH
76931: LD_INT 24
76933: ST_TO_ADDR
76934: GO 77184
76936: LD_INT 22
76938: DOUBLE
76939: EQUAL
76940: IFTRUE 76944
76942: GO 76955
76944: POP
// bc_type := b_ext_track ; 23 :
76945: LD_ADDR_OWVAR 42
76949: PUSH
76950: LD_INT 16
76952: ST_TO_ADDR
76953: GO 77184
76955: LD_INT 23
76957: DOUBLE
76958: EQUAL
76959: IFTRUE 76963
76961: GO 76974
76963: POP
// bc_type := b_ext_laser ; 24 :
76964: LD_ADDR_OWVAR 42
76968: PUSH
76969: LD_INT 25
76971: ST_TO_ADDR
76972: GO 77184
76974: LD_INT 24
76976: DOUBLE
76977: EQUAL
76978: IFTRUE 76982
76980: GO 76993
76982: POP
// bc_type := b_control_tower ; 25 :
76983: LD_ADDR_OWVAR 42
76987: PUSH
76988: LD_INT 36
76990: ST_TO_ADDR
76991: GO 77184
76993: LD_INT 25
76995: DOUBLE
76996: EQUAL
76997: IFTRUE 77001
76999: GO 77012
77001: POP
// bc_type := b_breastwork ; 26 :
77002: LD_ADDR_OWVAR 42
77006: PUSH
77007: LD_INT 31
77009: ST_TO_ADDR
77010: GO 77184
77012: LD_INT 26
77014: DOUBLE
77015: EQUAL
77016: IFTRUE 77020
77018: GO 77031
77020: POP
// bc_type := b_bunker ; 27 :
77021: LD_ADDR_OWVAR 42
77025: PUSH
77026: LD_INT 32
77028: ST_TO_ADDR
77029: GO 77184
77031: LD_INT 27
77033: DOUBLE
77034: EQUAL
77035: IFTRUE 77039
77037: GO 77050
77039: POP
// bc_type := b_turret ; 28 :
77040: LD_ADDR_OWVAR 42
77044: PUSH
77045: LD_INT 33
77047: ST_TO_ADDR
77048: GO 77184
77050: LD_INT 28
77052: DOUBLE
77053: EQUAL
77054: IFTRUE 77058
77056: GO 77069
77058: POP
// bc_type := b_armoury ; 29 :
77059: LD_ADDR_OWVAR 42
77063: PUSH
77064: LD_INT 4
77066: ST_TO_ADDR
77067: GO 77184
77069: LD_INT 29
77071: DOUBLE
77072: EQUAL
77073: IFTRUE 77077
77075: GO 77088
77077: POP
// bc_type := b_barracks ; 30 :
77078: LD_ADDR_OWVAR 42
77082: PUSH
77083: LD_INT 5
77085: ST_TO_ADDR
77086: GO 77184
77088: LD_INT 30
77090: DOUBLE
77091: EQUAL
77092: IFTRUE 77096
77094: GO 77107
77096: POP
// bc_type := b_solar_power ; 31 :
77097: LD_ADDR_OWVAR 42
77101: PUSH
77102: LD_INT 27
77104: ST_TO_ADDR
77105: GO 77184
77107: LD_INT 31
77109: DOUBLE
77110: EQUAL
77111: IFTRUE 77115
77113: GO 77126
77115: POP
// bc_type := b_oil_power ; 32 :
77116: LD_ADDR_OWVAR 42
77120: PUSH
77121: LD_INT 26
77123: ST_TO_ADDR
77124: GO 77184
77126: LD_INT 32
77128: DOUBLE
77129: EQUAL
77130: IFTRUE 77134
77132: GO 77145
77134: POP
// bc_type := b_siberite_power ; 33 :
77135: LD_ADDR_OWVAR 42
77139: PUSH
77140: LD_INT 28
77142: ST_TO_ADDR
77143: GO 77184
77145: LD_INT 33
77147: DOUBLE
77148: EQUAL
77149: IFTRUE 77153
77151: GO 77164
77153: POP
// bc_type := b_oil_mine ; 34 :
77154: LD_ADDR_OWVAR 42
77158: PUSH
77159: LD_INT 29
77161: ST_TO_ADDR
77162: GO 77184
77164: LD_INT 34
77166: DOUBLE
77167: EQUAL
77168: IFTRUE 77172
77170: GO 77183
77172: POP
// bc_type := b_siberite_mine ; end ;
77173: LD_ADDR_OWVAR 42
77177: PUSH
77178: LD_INT 30
77180: ST_TO_ADDR
77181: GO 77184
77183: POP
// b := CreateAndPlaceBuildingXYD ( x , y , dir ) ;
77184: LD_ADDR_VAR 0 8
77188: PUSH
77189: LD_VAR 0 5
77193: PPUSH
77194: LD_VAR 0 6
77198: PPUSH
77199: LD_VAR 0 3
77203: PPUSH
77204: CALL_OW 47
77208: ST_TO_ADDR
// if bc_type in [ b_bunker , b_turret ] then
77209: LD_OWVAR 42
77213: PUSH
77214: LD_INT 32
77216: PUSH
77217: LD_INT 33
77219: PUSH
77220: EMPTY
77221: LIST
77222: LIST
77223: IN
77224: IFFALSE 77240
// PlaceWeaponTurret ( b , weapon ) ;
77226: LD_VAR 0 8
77230: PPUSH
77231: LD_VAR 0 4
77235: PPUSH
77236: CALL_OW 431
// end ;
77240: LD_VAR 0 7
77244: RET
// export function hHackUnlimitedResources ; var i , j , tmp ; begin
77245: LD_INT 0
77247: PPUSH
77248: PPUSH
77249: PPUSH
77250: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
77251: LD_ADDR_VAR 0 4
77255: PUSH
77256: LD_INT 22
77258: PUSH
77259: LD_OWVAR 2
77263: PUSH
77264: EMPTY
77265: LIST
77266: LIST
77267: PUSH
77268: LD_INT 2
77270: PUSH
77271: LD_INT 30
77273: PUSH
77274: LD_INT 0
77276: PUSH
77277: EMPTY
77278: LIST
77279: LIST
77280: PUSH
77281: LD_INT 30
77283: PUSH
77284: LD_INT 1
77286: PUSH
77287: EMPTY
77288: LIST
77289: LIST
77290: PUSH
77291: EMPTY
77292: LIST
77293: LIST
77294: LIST
77295: PUSH
77296: EMPTY
77297: LIST
77298: LIST
77299: PPUSH
77300: CALL_OW 69
77304: ST_TO_ADDR
// if not tmp then
77305: LD_VAR 0 4
77309: NOT
77310: IFFALSE 77314
// exit ;
77312: GO 77373
// for i in tmp do
77314: LD_ADDR_VAR 0 2
77318: PUSH
77319: LD_VAR 0 4
77323: PUSH
77324: FOR_IN
77325: IFFALSE 77371
// for j = 1 to 3 do
77327: LD_ADDR_VAR 0 3
77331: PUSH
77332: DOUBLE
77333: LD_INT 1
77335: DEC
77336: ST_TO_ADDR
77337: LD_INT 3
77339: PUSH
77340: FOR_TO
77341: IFFALSE 77367
// SetResourceType ( GetBase ( i ) , j , 99999 ) ;
77343: LD_VAR 0 2
77347: PPUSH
77348: CALL_OW 274
77352: PPUSH
77353: LD_VAR 0 3
77357: PPUSH
77358: LD_INT 99999
77360: PPUSH
77361: CALL_OW 277
77365: GO 77340
77367: POP
77368: POP
77369: GO 77324
77371: POP
77372: POP
// end ;
77373: LD_VAR 0 1
77377: RET
// export function hHackSetLevel10 ; var i , j ; begin
77378: LD_INT 0
77380: PPUSH
77381: PPUSH
77382: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
77383: LD_ADDR_VAR 0 2
77387: PUSH
77388: LD_INT 21
77390: PUSH
77391: LD_INT 1
77393: PUSH
77394: EMPTY
77395: LIST
77396: LIST
77397: PPUSH
77398: CALL_OW 69
77402: PUSH
77403: FOR_IN
77404: IFFALSE 77456
// if IsSelected ( i ) then
77406: LD_VAR 0 2
77410: PPUSH
77411: CALL_OW 306
77415: IFFALSE 77454
// begin for j := 1 to 4 do
77417: LD_ADDR_VAR 0 3
77421: PUSH
77422: DOUBLE
77423: LD_INT 1
77425: DEC
77426: ST_TO_ADDR
77427: LD_INT 4
77429: PUSH
77430: FOR_TO
77431: IFFALSE 77452
// SetSkill ( i , j , 10 ) ;
77433: LD_VAR 0 2
77437: PPUSH
77438: LD_VAR 0 3
77442: PPUSH
77443: LD_INT 10
77445: PPUSH
77446: CALL_OW 237
77450: GO 77430
77452: POP
77453: POP
// end ;
77454: GO 77403
77456: POP
77457: POP
// end ;
77458: LD_VAR 0 1
77462: RET
// export function hHackSetLevel10YourUnits ; var i , j ; begin
77463: LD_INT 0
77465: PPUSH
77466: PPUSH
77467: PPUSH
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) do
77468: LD_ADDR_VAR 0 2
77472: PUSH
77473: LD_INT 22
77475: PUSH
77476: LD_OWVAR 2
77480: PUSH
77481: EMPTY
77482: LIST
77483: LIST
77484: PUSH
77485: LD_INT 21
77487: PUSH
77488: LD_INT 1
77490: PUSH
77491: EMPTY
77492: LIST
77493: LIST
77494: PUSH
77495: EMPTY
77496: LIST
77497: LIST
77498: PPUSH
77499: CALL_OW 69
77503: PUSH
77504: FOR_IN
77505: IFFALSE 77546
// begin for j := 1 to 4 do
77507: LD_ADDR_VAR 0 3
77511: PUSH
77512: DOUBLE
77513: LD_INT 1
77515: DEC
77516: ST_TO_ADDR
77517: LD_INT 4
77519: PUSH
77520: FOR_TO
77521: IFFALSE 77542
// SetSkill ( i , j , 10 ) ;
77523: LD_VAR 0 2
77527: PPUSH
77528: LD_VAR 0 3
77532: PPUSH
77533: LD_INT 10
77535: PPUSH
77536: CALL_OW 237
77540: GO 77520
77542: POP
77543: POP
// end ;
77544: GO 77504
77546: POP
77547: POP
// end ;
77548: LD_VAR 0 1
77552: RET
// export function hHackSpawnHuman ( nation , class , skill , x , y ) ; begin
77553: LD_INT 0
77555: PPUSH
// uc_side := your_side ;
77556: LD_ADDR_OWVAR 20
77560: PUSH
77561: LD_OWVAR 2
77565: ST_TO_ADDR
// uc_nation := nation ;
77566: LD_ADDR_OWVAR 21
77570: PUSH
77571: LD_VAR 0 1
77575: ST_TO_ADDR
// InitHc ;
77576: CALL_OW 19
// PrepareHuman ( false , class , skill ) ;
77580: LD_INT 0
77582: PPUSH
77583: LD_VAR 0 2
77587: PPUSH
77588: LD_VAR 0 3
77592: PPUSH
77593: CALL_OW 380
// if HexInfo ( x , y ) = 0 then
77597: LD_VAR 0 4
77601: PPUSH
77602: LD_VAR 0 5
77606: PPUSH
77607: CALL_OW 428
77611: PUSH
77612: LD_INT 0
77614: EQUAL
77615: IFFALSE 77639
// PlaceUnitXY ( CreateHuman , x , y , true ) ;
77617: CALL_OW 44
77621: PPUSH
77622: LD_VAR 0 4
77626: PPUSH
77627: LD_VAR 0 5
77631: PPUSH
77632: LD_INT 1
77634: PPUSH
77635: CALL_OW 48
// end ;
77639: LD_VAR 0 6
77643: RET
// export function hHackSpawnVehicle ( chassis , engine , control , weapon , x , y ) ; var un ; begin
77644: LD_INT 0
77646: PPUSH
77647: PPUSH
// uc_side := your_side ;
77648: LD_ADDR_OWVAR 20
77652: PUSH
77653: LD_OWVAR 2
77657: ST_TO_ADDR
// if chassis in [ 1 , 2 , 3 , 4 , 5 ] then
77658: LD_VAR 0 1
77662: PUSH
77663: LD_INT 1
77665: PUSH
77666: LD_INT 2
77668: PUSH
77669: LD_INT 3
77671: PUSH
77672: LD_INT 4
77674: PUSH
77675: LD_INT 5
77677: PUSH
77678: EMPTY
77679: LIST
77680: LIST
77681: LIST
77682: LIST
77683: LIST
77684: IN
77685: IFFALSE 77697
// uc_nation := nation_american else
77687: LD_ADDR_OWVAR 21
77691: PUSH
77692: LD_INT 1
77694: ST_TO_ADDR
77695: GO 77740
// if chassis in [ 11 , 12 , 13 , 14 ] then
77697: LD_VAR 0 1
77701: PUSH
77702: LD_INT 11
77704: PUSH
77705: LD_INT 12
77707: PUSH
77708: LD_INT 13
77710: PUSH
77711: LD_INT 14
77713: PUSH
77714: EMPTY
77715: LIST
77716: LIST
77717: LIST
77718: LIST
77719: IN
77720: IFFALSE 77732
// uc_nation := nation_arabian else
77722: LD_ADDR_OWVAR 21
77726: PUSH
77727: LD_INT 2
77729: ST_TO_ADDR
77730: GO 77740
// uc_nation := nation_russian ;
77732: LD_ADDR_OWVAR 21
77736: PUSH
77737: LD_INT 3
77739: ST_TO_ADDR
// vc_chassis := chassis ;
77740: LD_ADDR_OWVAR 37
77744: PUSH
77745: LD_VAR 0 1
77749: ST_TO_ADDR
// vc_engine := engine ;
77750: LD_ADDR_OWVAR 39
77754: PUSH
77755: LD_VAR 0 2
77759: ST_TO_ADDR
// vc_control := control ;
77760: LD_ADDR_OWVAR 38
77764: PUSH
77765: LD_VAR 0 3
77769: ST_TO_ADDR
// vc_weapon := weapon ;
77770: LD_ADDR_OWVAR 40
77774: PUSH
77775: LD_VAR 0 4
77779: ST_TO_ADDR
// un := CreateVehicle ;
77780: LD_ADDR_VAR 0 8
77784: PUSH
77785: CALL_OW 45
77789: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
77790: LD_VAR 0 8
77794: PPUSH
77795: LD_INT 0
77797: PPUSH
77798: LD_INT 5
77800: PPUSH
77801: CALL_OW 12
77805: PPUSH
77806: CALL_OW 233
// PlaceUnitXY ( un , x , y , true ) ;
77810: LD_VAR 0 8
77814: PPUSH
77815: LD_VAR 0 5
77819: PPUSH
77820: LD_VAR 0 6
77824: PPUSH
77825: LD_INT 1
77827: PPUSH
77828: CALL_OW 48
// end ;
77832: LD_VAR 0 7
77836: RET
// export hInvincible ; every 1 do
77837: GO 77839
77839: DISABLE
// hInvincible := [ ] ;
77840: LD_ADDR_EXP 155
77844: PUSH
77845: EMPTY
77846: ST_TO_ADDR
77847: END
// every 10 do var i ;
77848: GO 77850
77850: DISABLE
77851: LD_INT 0
77853: PPUSH
// begin enable ;
77854: ENABLE
// if not hInvincible then
77855: LD_EXP 155
77859: NOT
77860: IFFALSE 77864
// exit ;
77862: GO 77908
// for i in hInvincible do
77864: LD_ADDR_VAR 0 1
77868: PUSH
77869: LD_EXP 155
77873: PUSH
77874: FOR_IN
77875: IFFALSE 77906
// if GetLives ( i ) < 1000 then
77877: LD_VAR 0 1
77881: PPUSH
77882: CALL_OW 256
77886: PUSH
77887: LD_INT 1000
77889: LESS
77890: IFFALSE 77904
// SetLives ( i , 1000 ) ;
77892: LD_VAR 0 1
77896: PPUSH
77897: LD_INT 1000
77899: PPUSH
77900: CALL_OW 234
77904: GO 77874
77906: POP
77907: POP
// end ;
77908: PPOPN 1
77910: END
// export function hHackInvincible ; var i ; begin
77911: LD_INT 0
77913: PPUSH
77914: PPUSH
// for i in FilterAllUnits ( [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ) do
77915: LD_ADDR_VAR 0 2
77919: PUSH
77920: LD_INT 2
77922: PUSH
77923: LD_INT 21
77925: PUSH
77926: LD_INT 1
77928: PUSH
77929: EMPTY
77930: LIST
77931: LIST
77932: PUSH
77933: LD_INT 21
77935: PUSH
77936: LD_INT 2
77938: PUSH
77939: EMPTY
77940: LIST
77941: LIST
77942: PUSH
77943: EMPTY
77944: LIST
77945: LIST
77946: LIST
77947: PPUSH
77948: CALL_OW 69
77952: PUSH
77953: FOR_IN
77954: IFFALSE 78015
// if IsSelected ( i ) then
77956: LD_VAR 0 2
77960: PPUSH
77961: CALL_OW 306
77965: IFFALSE 78013
// begin if i in hInvincible then
77967: LD_VAR 0 2
77971: PUSH
77972: LD_EXP 155
77976: IN
77977: IFFALSE 77997
// hInvincible := hInvincible diff i else
77979: LD_ADDR_EXP 155
77983: PUSH
77984: LD_EXP 155
77988: PUSH
77989: LD_VAR 0 2
77993: DIFF
77994: ST_TO_ADDR
77995: GO 78013
// hInvincible := hInvincible union i ;
77997: LD_ADDR_EXP 155
78001: PUSH
78002: LD_EXP 155
78006: PUSH
78007: LD_VAR 0 2
78011: UNION
78012: ST_TO_ADDR
// end ;
78013: GO 77953
78015: POP
78016: POP
// end ;
78017: LD_VAR 0 1
78021: RET
// export function hHackInvisible ; var i , j ; begin
78022: LD_INT 0
78024: PPUSH
78025: PPUSH
78026: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
78027: LD_ADDR_VAR 0 2
78031: PUSH
78032: LD_INT 21
78034: PUSH
78035: LD_INT 1
78037: PUSH
78038: EMPTY
78039: LIST
78040: LIST
78041: PPUSH
78042: CALL_OW 69
78046: PUSH
78047: FOR_IN
78048: IFFALSE 78072
// if IsSelected ( i ) then
78050: LD_VAR 0 2
78054: PPUSH
78055: CALL_OW 306
78059: IFFALSE 78070
// ComForceInvisible ( i ) ;
78061: LD_VAR 0 2
78065: PPUSH
78066: CALL_OW 496
78070: GO 78047
78072: POP
78073: POP
// end ;
78074: LD_VAR 0 1
78078: RET
// export function hHackChangeYourSide ; begin
78079: LD_INT 0
78081: PPUSH
// if your_side = 8 then
78082: LD_OWVAR 2
78086: PUSH
78087: LD_INT 8
78089: EQUAL
78090: IFFALSE 78102
// your_side := 0 else
78092: LD_ADDR_OWVAR 2
78096: PUSH
78097: LD_INT 0
78099: ST_TO_ADDR
78100: GO 78116
// your_side := your_side + 1 ;
78102: LD_ADDR_OWVAR 2
78106: PUSH
78107: LD_OWVAR 2
78111: PUSH
78112: LD_INT 1
78114: PLUS
78115: ST_TO_ADDR
// end ;
78116: LD_VAR 0 1
78120: RET
// export function hHackChangeUnitSide ; var i , j ; begin
78121: LD_INT 0
78123: PPUSH
78124: PPUSH
78125: PPUSH
// for i in all_units do
78126: LD_ADDR_VAR 0 2
78130: PUSH
78131: LD_OWVAR 3
78135: PUSH
78136: FOR_IN
78137: IFFALSE 78215
// if IsSelected ( i ) then
78139: LD_VAR 0 2
78143: PPUSH
78144: CALL_OW 306
78148: IFFALSE 78213
// begin j := GetSide ( i ) ;
78150: LD_ADDR_VAR 0 3
78154: PUSH
78155: LD_VAR 0 2
78159: PPUSH
78160: CALL_OW 255
78164: ST_TO_ADDR
// if j = 8 then
78165: LD_VAR 0 3
78169: PUSH
78170: LD_INT 8
78172: EQUAL
78173: IFFALSE 78185
// j := 0 else
78175: LD_ADDR_VAR 0 3
78179: PUSH
78180: LD_INT 0
78182: ST_TO_ADDR
78183: GO 78199
// j := j + 1 ;
78185: LD_ADDR_VAR 0 3
78189: PUSH
78190: LD_VAR 0 3
78194: PUSH
78195: LD_INT 1
78197: PLUS
78198: ST_TO_ADDR
// SetSide ( i , j ) ;
78199: LD_VAR 0 2
78203: PPUSH
78204: LD_VAR 0 3
78208: PPUSH
78209: CALL_OW 235
// end ;
78213: GO 78136
78215: POP
78216: POP
// end ;
78217: LD_VAR 0 1
78221: RET
// export function hHackFog ; begin
78222: LD_INT 0
78224: PPUSH
// FogOff ( true ) ;
78225: LD_INT 1
78227: PPUSH
78228: CALL_OW 344
// end ;
78232: LD_VAR 0 1
78236: RET
// export function hHackTeleport ( unit , x , y ) ; begin
78237: LD_INT 0
78239: PPUSH
// TeleportUnit ( unit , x , y , 1 , true ) ;
78240: LD_VAR 0 1
78244: PPUSH
78245: LD_VAR 0 2
78249: PPUSH
78250: LD_VAR 0 3
78254: PPUSH
78255: LD_INT 1
78257: PPUSH
78258: LD_INT 1
78260: PPUSH
78261: CALL_OW 483
// CenterOnXY ( x , y ) ;
78265: LD_VAR 0 2
78269: PPUSH
78270: LD_VAR 0 3
78274: PPUSH
78275: CALL_OW 84
// end ; end_of_file
78279: LD_VAR 0 4
78283: RET
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb , ar_mortar , ar_crane , ar_miner ; export tech_Artillery , tech_RadMat , tech_BasicTools , tech_Cargo , tech_Track , tech_Crane , tech_Bulldozer , tech_Hovercraft , tech_MultiBarrels ; export class_mastodont , class_horse ; export function InitGlobalVariables ; begin
78284: LD_INT 0
78286: PPUSH
// ar_miner := 81 ;
78287: LD_ADDR_EXP 163
78291: PUSH
78292: LD_INT 81
78294: ST_TO_ADDR
// ar_crane := 88 ;
78295: LD_ADDR_EXP 162
78299: PUSH
78300: LD_INT 88
78302: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
78303: LD_ADDR_EXP 157
78307: PUSH
78308: LD_INT 89
78310: ST_TO_ADDR
// us_hack := 99 ;
78311: LD_ADDR_EXP 158
78315: PUSH
78316: LD_INT 99
78318: ST_TO_ADDR
// us_artillery := 97 ;
78319: LD_ADDR_EXP 159
78323: PUSH
78324: LD_INT 97
78326: ST_TO_ADDR
// ar_bio_bomb := 91 ;
78327: LD_ADDR_EXP 160
78331: PUSH
78332: LD_INT 91
78334: ST_TO_ADDR
// ar_mortar := 92 ;
78335: LD_ADDR_EXP 161
78339: PUSH
78340: LD_INT 92
78342: ST_TO_ADDR
// ru_radar := 98 ;
78343: LD_ADDR_EXP 156
78347: PUSH
78348: LD_INT 98
78350: ST_TO_ADDR
// tech_Artillery := 80 ;
78351: LD_ADDR_EXP 164
78355: PUSH
78356: LD_INT 80
78358: ST_TO_ADDR
// tech_RadMat := 81 ;
78359: LD_ADDR_EXP 165
78363: PUSH
78364: LD_INT 81
78366: ST_TO_ADDR
// tech_BasicTools := 82 ;
78367: LD_ADDR_EXP 166
78371: PUSH
78372: LD_INT 82
78374: ST_TO_ADDR
// tech_Cargo := 83 ;
78375: LD_ADDR_EXP 167
78379: PUSH
78380: LD_INT 83
78382: ST_TO_ADDR
// tech_Track := 84 ;
78383: LD_ADDR_EXP 168
78387: PUSH
78388: LD_INT 84
78390: ST_TO_ADDR
// tech_Crane := 85 ;
78391: LD_ADDR_EXP 169
78395: PUSH
78396: LD_INT 85
78398: ST_TO_ADDR
// tech_Bulldozer := 86 ;
78399: LD_ADDR_EXP 170
78403: PUSH
78404: LD_INT 86
78406: ST_TO_ADDR
// tech_Hovercraft := 87 ;
78407: LD_ADDR_EXP 171
78411: PUSH
78412: LD_INT 87
78414: ST_TO_ADDR
// tech_MultiBarrels := 88 ;
78415: LD_ADDR_EXP 172
78419: PUSH
78420: LD_INT 88
78422: ST_TO_ADDR
// class_mastodont := 31 ;
78423: LD_ADDR_EXP 173
78427: PUSH
78428: LD_INT 31
78430: ST_TO_ADDR
// class_horse := 21 ;
78431: LD_ADDR_EXP 174
78435: PUSH
78436: LD_INT 21
78438: ST_TO_ADDR
// end ;
78439: LD_VAR 0 1
78443: RET
// every 1 do
78444: GO 78446
78446: DISABLE
// InitGlobalVariables ; end_of_file
78447: CALL 78284 0 0
78451: END
// on TargetableSAIL ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) do begin case cmd of 200 .. 299 :
78452: LD_VAR 0 1
78456: PUSH
78457: LD_INT 200
78459: DOUBLE
78460: GREATEREQUAL
78461: IFFALSE 78469
78463: LD_INT 299
78465: DOUBLE
78466: LESSEQUAL
78467: IFTRUE 78471
78469: GO 78503
78471: POP
// SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; 300 .. 399 :
78472: LD_VAR 0 1
78476: PPUSH
78477: LD_VAR 0 2
78481: PPUSH
78482: LD_VAR 0 3
78486: PPUSH
78487: LD_VAR 0 4
78491: PPUSH
78492: LD_VAR 0 5
78496: PPUSH
78497: CALL 59693 0 5
78501: GO 78580
78503: LD_INT 300
78505: DOUBLE
78506: GREATEREQUAL
78507: IFFALSE 78515
78509: LD_INT 399
78511: DOUBLE
78512: LESSEQUAL
78513: IFTRUE 78517
78515: GO 78579
78517: POP
// SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; end ;
78518: LD_VAR 0 1
78522: PPUSH
78523: LD_VAR 0 2
78527: PPUSH
78528: LD_VAR 0 3
78532: PPUSH
78533: LD_VAR 0 4
78537: PPUSH
78538: LD_VAR 0 5
78542: PPUSH
78543: LD_VAR 0 6
78547: PPUSH
78548: LD_VAR 0 7
78552: PPUSH
78553: LD_VAR 0 8
78557: PPUSH
78558: LD_VAR 0 9
78562: PPUSH
78563: LD_VAR 0 10
78567: PPUSH
78568: LD_VAR 0 11
78572: PPUSH
78573: CALL 76304 0 11
78577: GO 78580
78579: POP
// end ;
78580: PPOPN 11
78582: END
// on CommandUnitXY ( cmd , un , target , x , y ) do begin SOS_CommandUnitXY ( cmd , un , target , x , y ) ;
78583: LD_VAR 0 1
78587: PPUSH
78588: LD_VAR 0 2
78592: PPUSH
78593: LD_VAR 0 3
78597: PPUSH
78598: LD_VAR 0 4
78602: PPUSH
78603: LD_VAR 0 5
78607: PPUSH
78608: CALL 59429 0 5
// end ; end_of_file
78612: PPOPN 5
78614: END
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
78615: LD_INT 0
78617: PPUSH
78618: PPUSH
78619: PPUSH
78620: PPUSH
78621: PPUSH
78622: PPUSH
78623: PPUSH
78624: PPUSH
78625: PPUSH
78626: PPUSH
78627: PPUSH
78628: PPUSH
78629: PPUSH
78630: PPUSH
78631: PPUSH
78632: PPUSH
78633: PPUSH
78634: PPUSH
78635: PPUSH
78636: PPUSH
78637: PPUSH
78638: PPUSH
78639: PPUSH
78640: PPUSH
78641: PPUSH
78642: PPUSH
78643: PPUSH
78644: PPUSH
78645: PPUSH
78646: PPUSH
78647: PPUSH
78648: PPUSH
78649: PPUSH
78650: PPUSH
// if not list then
78651: LD_VAR 0 1
78655: NOT
78656: IFFALSE 78660
// exit ;
78658: GO 83319
// base := list [ 1 ] ;
78660: LD_ADDR_VAR 0 3
78664: PUSH
78665: LD_VAR 0 1
78669: PUSH
78670: LD_INT 1
78672: ARRAY
78673: ST_TO_ADDR
// group := list [ 2 ] ;
78674: LD_ADDR_VAR 0 4
78678: PUSH
78679: LD_VAR 0 1
78683: PUSH
78684: LD_INT 2
78686: ARRAY
78687: ST_TO_ADDR
// path := list [ 3 ] ;
78688: LD_ADDR_VAR 0 5
78692: PUSH
78693: LD_VAR 0 1
78697: PUSH
78698: LD_INT 3
78700: ARRAY
78701: ST_TO_ADDR
// flags := list [ 4 ] ;
78702: LD_ADDR_VAR 0 6
78706: PUSH
78707: LD_VAR 0 1
78711: PUSH
78712: LD_INT 4
78714: ARRAY
78715: ST_TO_ADDR
// mined := [ ] ;
78716: LD_ADDR_VAR 0 27
78720: PUSH
78721: EMPTY
78722: ST_TO_ADDR
// bombed := [ ] ;
78723: LD_ADDR_VAR 0 28
78727: PUSH
78728: EMPTY
78729: ST_TO_ADDR
// healers := [ ] ;
78730: LD_ADDR_VAR 0 31
78734: PUSH
78735: EMPTY
78736: ST_TO_ADDR
// to_heal := [ ] ;
78737: LD_ADDR_VAR 0 30
78741: PUSH
78742: EMPTY
78743: ST_TO_ADDR
// repairs := [ ] ;
78744: LD_ADDR_VAR 0 33
78748: PUSH
78749: EMPTY
78750: ST_TO_ADDR
// to_repair := [ ] ;
78751: LD_ADDR_VAR 0 32
78755: PUSH
78756: EMPTY
78757: ST_TO_ADDR
// if not group or not path then
78758: LD_VAR 0 4
78762: NOT
78763: PUSH
78764: LD_VAR 0 5
78768: NOT
78769: OR
78770: IFFALSE 78774
// exit ;
78772: GO 83319
// side := GetSide ( group [ 1 ] ) ;
78774: LD_ADDR_VAR 0 35
78778: PUSH
78779: LD_VAR 0 4
78783: PUSH
78784: LD_INT 1
78786: ARRAY
78787: PPUSH
78788: CALL_OW 255
78792: ST_TO_ADDR
// if flags then
78793: LD_VAR 0 6
78797: IFFALSE 78941
// begin f_ignore_area := flags [ 1 ] ;
78799: LD_ADDR_VAR 0 17
78803: PUSH
78804: LD_VAR 0 6
78808: PUSH
78809: LD_INT 1
78811: ARRAY
78812: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
78813: LD_ADDR_VAR 0 18
78817: PUSH
78818: LD_VAR 0 6
78822: PUSH
78823: LD_INT 2
78825: ARRAY
78826: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
78827: LD_ADDR_VAR 0 19
78831: PUSH
78832: LD_VAR 0 6
78836: PUSH
78837: LD_INT 3
78839: ARRAY
78840: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
78841: LD_ADDR_VAR 0 20
78845: PUSH
78846: LD_VAR 0 6
78850: PUSH
78851: LD_INT 4
78853: ARRAY
78854: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
78855: LD_ADDR_VAR 0 21
78859: PUSH
78860: LD_VAR 0 6
78864: PUSH
78865: LD_INT 5
78867: ARRAY
78868: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
78869: LD_ADDR_VAR 0 22
78873: PUSH
78874: LD_VAR 0 6
78878: PUSH
78879: LD_INT 6
78881: ARRAY
78882: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
78883: LD_ADDR_VAR 0 23
78887: PUSH
78888: LD_VAR 0 6
78892: PUSH
78893: LD_INT 7
78895: ARRAY
78896: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
78897: LD_ADDR_VAR 0 24
78901: PUSH
78902: LD_VAR 0 6
78906: PUSH
78907: LD_INT 8
78909: ARRAY
78910: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
78911: LD_ADDR_VAR 0 25
78915: PUSH
78916: LD_VAR 0 6
78920: PUSH
78921: LD_INT 9
78923: ARRAY
78924: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
78925: LD_ADDR_VAR 0 26
78929: PUSH
78930: LD_VAR 0 6
78934: PUSH
78935: LD_INT 10
78937: ARRAY
78938: ST_TO_ADDR
// end else
78939: GO 79021
// begin f_ignore_area := false ;
78941: LD_ADDR_VAR 0 17
78945: PUSH
78946: LD_INT 0
78948: ST_TO_ADDR
// f_capture := false ;
78949: LD_ADDR_VAR 0 18
78953: PUSH
78954: LD_INT 0
78956: ST_TO_ADDR
// f_ignore_civ := false ;
78957: LD_ADDR_VAR 0 19
78961: PUSH
78962: LD_INT 0
78964: ST_TO_ADDR
// f_murder := false ;
78965: LD_ADDR_VAR 0 20
78969: PUSH
78970: LD_INT 0
78972: ST_TO_ADDR
// f_mines := false ;
78973: LD_ADDR_VAR 0 21
78977: PUSH
78978: LD_INT 0
78980: ST_TO_ADDR
// f_repair := false ;
78981: LD_ADDR_VAR 0 22
78985: PUSH
78986: LD_INT 0
78988: ST_TO_ADDR
// f_heal := false ;
78989: LD_ADDR_VAR 0 23
78993: PUSH
78994: LD_INT 0
78996: ST_TO_ADDR
// f_spacetime := false ;
78997: LD_ADDR_VAR 0 24
79001: PUSH
79002: LD_INT 0
79004: ST_TO_ADDR
// f_attack_depot := false ;
79005: LD_ADDR_VAR 0 25
79009: PUSH
79010: LD_INT 0
79012: ST_TO_ADDR
// f_crawl := false ;
79013: LD_ADDR_VAR 0 26
79017: PUSH
79018: LD_INT 0
79020: ST_TO_ADDR
// end ; if f_heal then
79021: LD_VAR 0 23
79025: IFFALSE 79052
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
79027: LD_ADDR_VAR 0 31
79031: PUSH
79032: LD_VAR 0 4
79036: PPUSH
79037: LD_INT 25
79039: PUSH
79040: LD_INT 4
79042: PUSH
79043: EMPTY
79044: LIST
79045: LIST
79046: PPUSH
79047: CALL_OW 72
79051: ST_TO_ADDR
// if f_repair then
79052: LD_VAR 0 22
79056: IFFALSE 79083
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
79058: LD_ADDR_VAR 0 33
79062: PUSH
79063: LD_VAR 0 4
79067: PPUSH
79068: LD_INT 25
79070: PUSH
79071: LD_INT 3
79073: PUSH
79074: EMPTY
79075: LIST
79076: LIST
79077: PPUSH
79078: CALL_OW 72
79082: ST_TO_ADDR
// units_path := [ ] ;
79083: LD_ADDR_VAR 0 16
79087: PUSH
79088: EMPTY
79089: ST_TO_ADDR
// for i = 1 to group do
79090: LD_ADDR_VAR 0 7
79094: PUSH
79095: DOUBLE
79096: LD_INT 1
79098: DEC
79099: ST_TO_ADDR
79100: LD_VAR 0 4
79104: PUSH
79105: FOR_TO
79106: IFFALSE 79135
// units_path := Replace ( units_path , i , path ) ;
79108: LD_ADDR_VAR 0 16
79112: PUSH
79113: LD_VAR 0 16
79117: PPUSH
79118: LD_VAR 0 7
79122: PPUSH
79123: LD_VAR 0 5
79127: PPUSH
79128: CALL_OW 1
79132: ST_TO_ADDR
79133: GO 79105
79135: POP
79136: POP
// repeat for i = group downto 1 do
79137: LD_ADDR_VAR 0 7
79141: PUSH
79142: DOUBLE
79143: LD_VAR 0 4
79147: INC
79148: ST_TO_ADDR
79149: LD_INT 1
79151: PUSH
79152: FOR_DOWNTO
79153: IFFALSE 83275
// begin wait ( 5 ) ;
79155: LD_INT 5
79157: PPUSH
79158: CALL_OW 67
// tmp := [ ] ;
79162: LD_ADDR_VAR 0 14
79166: PUSH
79167: EMPTY
79168: ST_TO_ADDR
// attacking := false ;
79169: LD_ADDR_VAR 0 29
79173: PUSH
79174: LD_INT 0
79176: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
79177: LD_VAR 0 4
79181: PUSH
79182: LD_VAR 0 7
79186: ARRAY
79187: PPUSH
79188: CALL_OW 301
79192: PUSH
79193: LD_VAR 0 4
79197: PUSH
79198: LD_VAR 0 7
79202: ARRAY
79203: NOT
79204: OR
79205: IFFALSE 79314
// begin if GetType ( group [ i ] ) = unit_human then
79207: LD_VAR 0 4
79211: PUSH
79212: LD_VAR 0 7
79216: ARRAY
79217: PPUSH
79218: CALL_OW 247
79222: PUSH
79223: LD_INT 1
79225: EQUAL
79226: IFFALSE 79272
// begin to_heal := to_heal diff group [ i ] ;
79228: LD_ADDR_VAR 0 30
79232: PUSH
79233: LD_VAR 0 30
79237: PUSH
79238: LD_VAR 0 4
79242: PUSH
79243: LD_VAR 0 7
79247: ARRAY
79248: DIFF
79249: ST_TO_ADDR
// healers := healers diff group [ i ] ;
79250: LD_ADDR_VAR 0 31
79254: PUSH
79255: LD_VAR 0 31
79259: PUSH
79260: LD_VAR 0 4
79264: PUSH
79265: LD_VAR 0 7
79269: ARRAY
79270: DIFF
79271: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
79272: LD_ADDR_VAR 0 4
79276: PUSH
79277: LD_VAR 0 4
79281: PPUSH
79282: LD_VAR 0 7
79286: PPUSH
79287: CALL_OW 3
79291: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
79292: LD_ADDR_VAR 0 16
79296: PUSH
79297: LD_VAR 0 16
79301: PPUSH
79302: LD_VAR 0 7
79306: PPUSH
79307: CALL_OW 3
79311: ST_TO_ADDR
// continue ;
79312: GO 79152
// end ; if f_repair then
79314: LD_VAR 0 22
79318: IFFALSE 79807
// begin if GetType ( group [ i ] ) = unit_vehicle then
79320: LD_VAR 0 4
79324: PUSH
79325: LD_VAR 0 7
79329: ARRAY
79330: PPUSH
79331: CALL_OW 247
79335: PUSH
79336: LD_INT 2
79338: EQUAL
79339: IFFALSE 79529
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
79341: LD_VAR 0 4
79345: PUSH
79346: LD_VAR 0 7
79350: ARRAY
79351: PPUSH
79352: CALL_OW 256
79356: PUSH
79357: LD_INT 700
79359: LESS
79360: PUSH
79361: LD_VAR 0 4
79365: PUSH
79366: LD_VAR 0 7
79370: ARRAY
79371: PUSH
79372: LD_VAR 0 32
79376: IN
79377: NOT
79378: AND
79379: IFFALSE 79403
// to_repair := to_repair union group [ i ] ;
79381: LD_ADDR_VAR 0 32
79385: PUSH
79386: LD_VAR 0 32
79390: PUSH
79391: LD_VAR 0 4
79395: PUSH
79396: LD_VAR 0 7
79400: ARRAY
79401: UNION
79402: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
79403: LD_VAR 0 4
79407: PUSH
79408: LD_VAR 0 7
79412: ARRAY
79413: PPUSH
79414: CALL_OW 256
79418: PUSH
79419: LD_INT 1000
79421: EQUAL
79422: PUSH
79423: LD_VAR 0 4
79427: PUSH
79428: LD_VAR 0 7
79432: ARRAY
79433: PUSH
79434: LD_VAR 0 32
79438: IN
79439: AND
79440: IFFALSE 79464
// to_repair := to_repair diff group [ i ] ;
79442: LD_ADDR_VAR 0 32
79446: PUSH
79447: LD_VAR 0 32
79451: PUSH
79452: LD_VAR 0 4
79456: PUSH
79457: LD_VAR 0 7
79461: ARRAY
79462: DIFF
79463: ST_TO_ADDR
// if group [ i ] in to_repair then
79464: LD_VAR 0 4
79468: PUSH
79469: LD_VAR 0 7
79473: ARRAY
79474: PUSH
79475: LD_VAR 0 32
79479: IN
79480: IFFALSE 79527
// begin if not IsInArea ( group [ i ] , f_repair ) then
79482: LD_VAR 0 4
79486: PUSH
79487: LD_VAR 0 7
79491: ARRAY
79492: PPUSH
79493: LD_VAR 0 22
79497: PPUSH
79498: CALL_OW 308
79502: NOT
79503: IFFALSE 79525
// ComMoveToArea ( group [ i ] , f_repair ) ;
79505: LD_VAR 0 4
79509: PUSH
79510: LD_VAR 0 7
79514: ARRAY
79515: PPUSH
79516: LD_VAR 0 22
79520: PPUSH
79521: CALL_OW 113
// continue ;
79525: GO 79152
// end ; end else
79527: GO 79807
// if group [ i ] in repairs then
79529: LD_VAR 0 4
79533: PUSH
79534: LD_VAR 0 7
79538: ARRAY
79539: PUSH
79540: LD_VAR 0 33
79544: IN
79545: IFFALSE 79807
// begin if IsInUnit ( group [ i ] ) then
79547: LD_VAR 0 4
79551: PUSH
79552: LD_VAR 0 7
79556: ARRAY
79557: PPUSH
79558: CALL_OW 310
79562: IFFALSE 79630
// begin z := IsInUnit ( group [ i ] ) ;
79564: LD_ADDR_VAR 0 13
79568: PUSH
79569: LD_VAR 0 4
79573: PUSH
79574: LD_VAR 0 7
79578: ARRAY
79579: PPUSH
79580: CALL_OW 310
79584: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
79585: LD_VAR 0 13
79589: PUSH
79590: LD_VAR 0 32
79594: IN
79595: PUSH
79596: LD_VAR 0 13
79600: PPUSH
79601: LD_VAR 0 22
79605: PPUSH
79606: CALL_OW 308
79610: AND
79611: IFFALSE 79628
// ComExitVehicle ( group [ i ] ) ;
79613: LD_VAR 0 4
79617: PUSH
79618: LD_VAR 0 7
79622: ARRAY
79623: PPUSH
79624: CALL_OW 121
// end else
79628: GO 79807
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
79630: LD_ADDR_VAR 0 13
79634: PUSH
79635: LD_VAR 0 4
79639: PPUSH
79640: LD_INT 95
79642: PUSH
79643: LD_VAR 0 22
79647: PUSH
79648: EMPTY
79649: LIST
79650: LIST
79651: PUSH
79652: LD_INT 58
79654: PUSH
79655: EMPTY
79656: LIST
79657: PUSH
79658: EMPTY
79659: LIST
79660: LIST
79661: PPUSH
79662: CALL_OW 72
79666: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
79667: LD_VAR 0 4
79671: PUSH
79672: LD_VAR 0 7
79676: ARRAY
79677: PPUSH
79678: CALL_OW 314
79682: NOT
79683: IFFALSE 79805
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
79685: LD_ADDR_VAR 0 10
79689: PUSH
79690: LD_VAR 0 13
79694: PPUSH
79695: LD_VAR 0 4
79699: PUSH
79700: LD_VAR 0 7
79704: ARRAY
79705: PPUSH
79706: CALL_OW 74
79710: ST_TO_ADDR
// if not x then
79711: LD_VAR 0 10
79715: NOT
79716: IFFALSE 79720
// continue ;
79718: GO 79152
// if GetLives ( x ) < 1000 then
79720: LD_VAR 0 10
79724: PPUSH
79725: CALL_OW 256
79729: PUSH
79730: LD_INT 1000
79732: LESS
79733: IFFALSE 79757
// ComRepairVehicle ( group [ i ] , x ) else
79735: LD_VAR 0 4
79739: PUSH
79740: LD_VAR 0 7
79744: ARRAY
79745: PPUSH
79746: LD_VAR 0 10
79750: PPUSH
79751: CALL_OW 129
79755: GO 79805
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
79757: LD_VAR 0 23
79761: PUSH
79762: LD_VAR 0 4
79766: PUSH
79767: LD_VAR 0 7
79771: ARRAY
79772: PPUSH
79773: CALL_OW 256
79777: PUSH
79778: LD_INT 1000
79780: LESS
79781: AND
79782: NOT
79783: IFFALSE 79805
// ComEnterUnit ( group [ i ] , x ) ;
79785: LD_VAR 0 4
79789: PUSH
79790: LD_VAR 0 7
79794: ARRAY
79795: PPUSH
79796: LD_VAR 0 10
79800: PPUSH
79801: CALL_OW 120
// end ; continue ;
79805: GO 79152
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
79807: LD_VAR 0 23
79811: PUSH
79812: LD_VAR 0 4
79816: PUSH
79817: LD_VAR 0 7
79821: ARRAY
79822: PPUSH
79823: CALL_OW 247
79827: PUSH
79828: LD_INT 1
79830: EQUAL
79831: AND
79832: IFFALSE 80310
// begin if group [ i ] in healers then
79834: LD_VAR 0 4
79838: PUSH
79839: LD_VAR 0 7
79843: ARRAY
79844: PUSH
79845: LD_VAR 0 31
79849: IN
79850: IFFALSE 80123
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
79852: LD_VAR 0 4
79856: PUSH
79857: LD_VAR 0 7
79861: ARRAY
79862: PPUSH
79863: LD_VAR 0 23
79867: PPUSH
79868: CALL_OW 308
79872: NOT
79873: PUSH
79874: LD_VAR 0 4
79878: PUSH
79879: LD_VAR 0 7
79883: ARRAY
79884: PPUSH
79885: CALL_OW 314
79889: NOT
79890: AND
79891: IFFALSE 79915
// ComMoveToArea ( group [ i ] , f_heal ) else
79893: LD_VAR 0 4
79897: PUSH
79898: LD_VAR 0 7
79902: ARRAY
79903: PPUSH
79904: LD_VAR 0 23
79908: PPUSH
79909: CALL_OW 113
79913: GO 80121
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
79915: LD_VAR 0 4
79919: PUSH
79920: LD_VAR 0 7
79924: ARRAY
79925: PPUSH
79926: CALL 53290 0 1
79930: PPUSH
79931: CALL_OW 256
79935: PUSH
79936: LD_INT 1000
79938: EQUAL
79939: IFFALSE 79958
// ComStop ( group [ i ] ) else
79941: LD_VAR 0 4
79945: PUSH
79946: LD_VAR 0 7
79950: ARRAY
79951: PPUSH
79952: CALL_OW 141
79956: GO 80121
// if not HasTask ( group [ i ] ) and to_heal then
79958: LD_VAR 0 4
79962: PUSH
79963: LD_VAR 0 7
79967: ARRAY
79968: PPUSH
79969: CALL_OW 314
79973: NOT
79974: PUSH
79975: LD_VAR 0 30
79979: AND
79980: IFFALSE 80121
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
79982: LD_ADDR_VAR 0 13
79986: PUSH
79987: LD_VAR 0 30
79991: PPUSH
79992: LD_INT 3
79994: PUSH
79995: LD_INT 54
79997: PUSH
79998: EMPTY
79999: LIST
80000: PUSH
80001: EMPTY
80002: LIST
80003: LIST
80004: PPUSH
80005: CALL_OW 72
80009: PPUSH
80010: LD_VAR 0 4
80014: PUSH
80015: LD_VAR 0 7
80019: ARRAY
80020: PPUSH
80021: CALL_OW 74
80025: ST_TO_ADDR
// if z then
80026: LD_VAR 0 13
80030: IFFALSE 80121
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
80032: LD_INT 91
80034: PUSH
80035: LD_VAR 0 13
80039: PUSH
80040: LD_INT 10
80042: PUSH
80043: EMPTY
80044: LIST
80045: LIST
80046: LIST
80047: PUSH
80048: LD_INT 81
80050: PUSH
80051: LD_VAR 0 13
80055: PPUSH
80056: CALL_OW 255
80060: PUSH
80061: EMPTY
80062: LIST
80063: LIST
80064: PUSH
80065: EMPTY
80066: LIST
80067: LIST
80068: PPUSH
80069: CALL_OW 69
80073: PUSH
80074: LD_INT 0
80076: EQUAL
80077: IFFALSE 80101
// ComHeal ( group [ i ] , z ) else
80079: LD_VAR 0 4
80083: PUSH
80084: LD_VAR 0 7
80088: ARRAY
80089: PPUSH
80090: LD_VAR 0 13
80094: PPUSH
80095: CALL_OW 128
80099: GO 80121
// ComMoveToArea ( group [ i ] , f_heal ) ;
80101: LD_VAR 0 4
80105: PUSH
80106: LD_VAR 0 7
80110: ARRAY
80111: PPUSH
80112: LD_VAR 0 23
80116: PPUSH
80117: CALL_OW 113
// end ; continue ;
80121: GO 79152
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
80123: LD_VAR 0 4
80127: PUSH
80128: LD_VAR 0 7
80132: ARRAY
80133: PPUSH
80134: CALL_OW 256
80138: PUSH
80139: LD_INT 700
80141: LESS
80142: PUSH
80143: LD_VAR 0 4
80147: PUSH
80148: LD_VAR 0 7
80152: ARRAY
80153: PUSH
80154: LD_VAR 0 30
80158: IN
80159: NOT
80160: AND
80161: IFFALSE 80185
// to_heal := to_heal union group [ i ] ;
80163: LD_ADDR_VAR 0 30
80167: PUSH
80168: LD_VAR 0 30
80172: PUSH
80173: LD_VAR 0 4
80177: PUSH
80178: LD_VAR 0 7
80182: ARRAY
80183: UNION
80184: ST_TO_ADDR
// if group [ i ] in to_heal then
80185: LD_VAR 0 4
80189: PUSH
80190: LD_VAR 0 7
80194: ARRAY
80195: PUSH
80196: LD_VAR 0 30
80200: IN
80201: IFFALSE 80310
// begin if GetLives ( group [ i ] ) = 1000 then
80203: LD_VAR 0 4
80207: PUSH
80208: LD_VAR 0 7
80212: ARRAY
80213: PPUSH
80214: CALL_OW 256
80218: PUSH
80219: LD_INT 1000
80221: EQUAL
80222: IFFALSE 80248
// to_heal := to_heal diff group [ i ] else
80224: LD_ADDR_VAR 0 30
80228: PUSH
80229: LD_VAR 0 30
80233: PUSH
80234: LD_VAR 0 4
80238: PUSH
80239: LD_VAR 0 7
80243: ARRAY
80244: DIFF
80245: ST_TO_ADDR
80246: GO 80310
// begin if not IsInArea ( group [ i ] , to_heal ) then
80248: LD_VAR 0 4
80252: PUSH
80253: LD_VAR 0 7
80257: ARRAY
80258: PPUSH
80259: LD_VAR 0 30
80263: PPUSH
80264: CALL_OW 308
80268: NOT
80269: IFFALSE 80293
// ComMoveToArea ( group [ i ] , f_heal ) else
80271: LD_VAR 0 4
80275: PUSH
80276: LD_VAR 0 7
80280: ARRAY
80281: PPUSH
80282: LD_VAR 0 23
80286: PPUSH
80287: CALL_OW 113
80291: GO 80308
// ComHold ( group [ i ] ) ;
80293: LD_VAR 0 4
80297: PUSH
80298: LD_VAR 0 7
80302: ARRAY
80303: PPUSH
80304: CALL_OW 140
// continue ;
80308: GO 79152
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
80310: LD_VAR 0 4
80314: PUSH
80315: LD_VAR 0 7
80319: ARRAY
80320: PPUSH
80321: LD_INT 10
80323: PPUSH
80324: CALL 51710 0 2
80328: NOT
80329: PUSH
80330: LD_VAR 0 16
80334: PUSH
80335: LD_VAR 0 7
80339: ARRAY
80340: PUSH
80341: EMPTY
80342: EQUAL
80343: NOT
80344: AND
80345: IFFALSE 80611
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
80347: LD_VAR 0 4
80351: PUSH
80352: LD_VAR 0 7
80356: ARRAY
80357: PPUSH
80358: CALL_OW 262
80362: PUSH
80363: LD_INT 1
80365: PUSH
80366: LD_INT 2
80368: PUSH
80369: EMPTY
80370: LIST
80371: LIST
80372: IN
80373: IFFALSE 80414
// if GetFuel ( group [ i ] ) < 10 then
80375: LD_VAR 0 4
80379: PUSH
80380: LD_VAR 0 7
80384: ARRAY
80385: PPUSH
80386: CALL_OW 261
80390: PUSH
80391: LD_INT 10
80393: LESS
80394: IFFALSE 80414
// SetFuel ( group [ i ] , 12 ) ;
80396: LD_VAR 0 4
80400: PUSH
80401: LD_VAR 0 7
80405: ARRAY
80406: PPUSH
80407: LD_INT 12
80409: PPUSH
80410: CALL_OW 240
// if units_path [ i ] then
80414: LD_VAR 0 16
80418: PUSH
80419: LD_VAR 0 7
80423: ARRAY
80424: IFFALSE 80609
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
80426: LD_VAR 0 4
80430: PUSH
80431: LD_VAR 0 7
80435: ARRAY
80436: PPUSH
80437: LD_VAR 0 16
80441: PUSH
80442: LD_VAR 0 7
80446: ARRAY
80447: PUSH
80448: LD_INT 1
80450: ARRAY
80451: PUSH
80452: LD_INT 1
80454: ARRAY
80455: PPUSH
80456: LD_VAR 0 16
80460: PUSH
80461: LD_VAR 0 7
80465: ARRAY
80466: PUSH
80467: LD_INT 1
80469: ARRAY
80470: PUSH
80471: LD_INT 2
80473: ARRAY
80474: PPUSH
80475: CALL_OW 297
80479: PUSH
80480: LD_INT 6
80482: GREATER
80483: IFFALSE 80558
// begin if not HasTask ( group [ i ] ) then
80485: LD_VAR 0 4
80489: PUSH
80490: LD_VAR 0 7
80494: ARRAY
80495: PPUSH
80496: CALL_OW 314
80500: NOT
80501: IFFALSE 80556
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
80503: LD_VAR 0 4
80507: PUSH
80508: LD_VAR 0 7
80512: ARRAY
80513: PPUSH
80514: LD_VAR 0 16
80518: PUSH
80519: LD_VAR 0 7
80523: ARRAY
80524: PUSH
80525: LD_INT 1
80527: ARRAY
80528: PUSH
80529: LD_INT 1
80531: ARRAY
80532: PPUSH
80533: LD_VAR 0 16
80537: PUSH
80538: LD_VAR 0 7
80542: ARRAY
80543: PUSH
80544: LD_INT 1
80546: ARRAY
80547: PUSH
80548: LD_INT 2
80550: ARRAY
80551: PPUSH
80552: CALL_OW 114
// end else
80556: GO 80609
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
80558: LD_ADDR_VAR 0 15
80562: PUSH
80563: LD_VAR 0 16
80567: PUSH
80568: LD_VAR 0 7
80572: ARRAY
80573: PPUSH
80574: LD_INT 1
80576: PPUSH
80577: CALL_OW 3
80581: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
80582: LD_ADDR_VAR 0 16
80586: PUSH
80587: LD_VAR 0 16
80591: PPUSH
80592: LD_VAR 0 7
80596: PPUSH
80597: LD_VAR 0 15
80601: PPUSH
80602: CALL_OW 1
80606: ST_TO_ADDR
// continue ;
80607: GO 79152
// end ; end ; end else
80609: GO 83273
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
80611: LD_ADDR_VAR 0 14
80615: PUSH
80616: LD_INT 81
80618: PUSH
80619: LD_VAR 0 4
80623: PUSH
80624: LD_VAR 0 7
80628: ARRAY
80629: PPUSH
80630: CALL_OW 255
80634: PUSH
80635: EMPTY
80636: LIST
80637: LIST
80638: PPUSH
80639: CALL_OW 69
80643: ST_TO_ADDR
// if not tmp then
80644: LD_VAR 0 14
80648: NOT
80649: IFFALSE 80653
// continue ;
80651: GO 79152
// if f_ignore_area then
80653: LD_VAR 0 17
80657: IFFALSE 80745
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
80659: LD_ADDR_VAR 0 15
80663: PUSH
80664: LD_VAR 0 14
80668: PPUSH
80669: LD_INT 3
80671: PUSH
80672: LD_INT 92
80674: PUSH
80675: LD_VAR 0 17
80679: PUSH
80680: LD_INT 1
80682: ARRAY
80683: PUSH
80684: LD_VAR 0 17
80688: PUSH
80689: LD_INT 2
80691: ARRAY
80692: PUSH
80693: LD_VAR 0 17
80697: PUSH
80698: LD_INT 3
80700: ARRAY
80701: PUSH
80702: EMPTY
80703: LIST
80704: LIST
80705: LIST
80706: LIST
80707: PUSH
80708: EMPTY
80709: LIST
80710: LIST
80711: PPUSH
80712: CALL_OW 72
80716: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
80717: LD_VAR 0 14
80721: PUSH
80722: LD_VAR 0 15
80726: DIFF
80727: IFFALSE 80745
// tmp := tmp diff tmp2 ;
80729: LD_ADDR_VAR 0 14
80733: PUSH
80734: LD_VAR 0 14
80738: PUSH
80739: LD_VAR 0 15
80743: DIFF
80744: ST_TO_ADDR
// end ; if not f_murder then
80745: LD_VAR 0 20
80749: NOT
80750: IFFALSE 80808
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
80752: LD_ADDR_VAR 0 15
80756: PUSH
80757: LD_VAR 0 14
80761: PPUSH
80762: LD_INT 3
80764: PUSH
80765: LD_INT 50
80767: PUSH
80768: EMPTY
80769: LIST
80770: PUSH
80771: EMPTY
80772: LIST
80773: LIST
80774: PPUSH
80775: CALL_OW 72
80779: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
80780: LD_VAR 0 14
80784: PUSH
80785: LD_VAR 0 15
80789: DIFF
80790: IFFALSE 80808
// tmp := tmp diff tmp2 ;
80792: LD_ADDR_VAR 0 14
80796: PUSH
80797: LD_VAR 0 14
80801: PUSH
80802: LD_VAR 0 15
80806: DIFF
80807: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
80808: LD_ADDR_VAR 0 14
80812: PUSH
80813: LD_VAR 0 4
80817: PUSH
80818: LD_VAR 0 7
80822: ARRAY
80823: PPUSH
80824: LD_VAR 0 14
80828: PPUSH
80829: LD_INT 1
80831: PPUSH
80832: LD_INT 1
80834: PPUSH
80835: CALL 24645 0 4
80839: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
80840: LD_VAR 0 4
80844: PUSH
80845: LD_VAR 0 7
80849: ARRAY
80850: PPUSH
80851: CALL_OW 257
80855: PUSH
80856: LD_INT 1
80858: EQUAL
80859: IFFALSE 81307
// begin if WantPlant ( group [ i ] ) then
80861: LD_VAR 0 4
80865: PUSH
80866: LD_VAR 0 7
80870: ARRAY
80871: PPUSH
80872: CALL 24146 0 1
80876: IFFALSE 80880
// continue ;
80878: GO 79152
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
80880: LD_VAR 0 18
80884: PUSH
80885: LD_VAR 0 4
80889: PUSH
80890: LD_VAR 0 7
80894: ARRAY
80895: PPUSH
80896: CALL_OW 310
80900: NOT
80901: AND
80902: PUSH
80903: LD_VAR 0 14
80907: PUSH
80908: LD_INT 1
80910: ARRAY
80911: PUSH
80912: LD_VAR 0 14
80916: PPUSH
80917: LD_INT 21
80919: PUSH
80920: LD_INT 2
80922: PUSH
80923: EMPTY
80924: LIST
80925: LIST
80926: PUSH
80927: LD_INT 58
80929: PUSH
80930: EMPTY
80931: LIST
80932: PUSH
80933: EMPTY
80934: LIST
80935: LIST
80936: PPUSH
80937: CALL_OW 72
80941: IN
80942: AND
80943: IFFALSE 80979
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
80945: LD_VAR 0 4
80949: PUSH
80950: LD_VAR 0 7
80954: ARRAY
80955: PPUSH
80956: LD_VAR 0 14
80960: PUSH
80961: LD_INT 1
80963: ARRAY
80964: PPUSH
80965: CALL_OW 120
// attacking := true ;
80969: LD_ADDR_VAR 0 29
80973: PUSH
80974: LD_INT 1
80976: ST_TO_ADDR
// continue ;
80977: GO 79152
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
80979: LD_VAR 0 26
80983: PUSH
80984: LD_VAR 0 4
80988: PUSH
80989: LD_VAR 0 7
80993: ARRAY
80994: PPUSH
80995: CALL_OW 257
80999: PUSH
81000: LD_INT 1
81002: EQUAL
81003: AND
81004: PUSH
81005: LD_VAR 0 4
81009: PUSH
81010: LD_VAR 0 7
81014: ARRAY
81015: PPUSH
81016: CALL_OW 256
81020: PUSH
81021: LD_INT 800
81023: LESS
81024: AND
81025: PUSH
81026: LD_VAR 0 4
81030: PUSH
81031: LD_VAR 0 7
81035: ARRAY
81036: PPUSH
81037: CALL_OW 318
81041: NOT
81042: AND
81043: IFFALSE 81060
// ComCrawl ( group [ i ] ) ;
81045: LD_VAR 0 4
81049: PUSH
81050: LD_VAR 0 7
81054: ARRAY
81055: PPUSH
81056: CALL_OW 137
// if f_mines then
81060: LD_VAR 0 21
81064: IFFALSE 81307
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
81066: LD_VAR 0 14
81070: PUSH
81071: LD_INT 1
81073: ARRAY
81074: PPUSH
81075: CALL_OW 247
81079: PUSH
81080: LD_INT 3
81082: EQUAL
81083: PUSH
81084: LD_VAR 0 14
81088: PUSH
81089: LD_INT 1
81091: ARRAY
81092: PUSH
81093: LD_VAR 0 27
81097: IN
81098: NOT
81099: AND
81100: IFFALSE 81307
// begin x := GetX ( tmp [ 1 ] ) ;
81102: LD_ADDR_VAR 0 10
81106: PUSH
81107: LD_VAR 0 14
81111: PUSH
81112: LD_INT 1
81114: ARRAY
81115: PPUSH
81116: CALL_OW 250
81120: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
81121: LD_ADDR_VAR 0 11
81125: PUSH
81126: LD_VAR 0 14
81130: PUSH
81131: LD_INT 1
81133: ARRAY
81134: PPUSH
81135: CALL_OW 251
81139: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
81140: LD_ADDR_VAR 0 12
81144: PUSH
81145: LD_VAR 0 4
81149: PUSH
81150: LD_VAR 0 7
81154: ARRAY
81155: PPUSH
81156: CALL 51795 0 1
81160: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
81161: LD_VAR 0 4
81165: PUSH
81166: LD_VAR 0 7
81170: ARRAY
81171: PPUSH
81172: LD_VAR 0 10
81176: PPUSH
81177: LD_VAR 0 11
81181: PPUSH
81182: LD_VAR 0 14
81186: PUSH
81187: LD_INT 1
81189: ARRAY
81190: PPUSH
81191: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
81195: LD_VAR 0 4
81199: PUSH
81200: LD_VAR 0 7
81204: ARRAY
81205: PPUSH
81206: LD_VAR 0 10
81210: PPUSH
81211: LD_VAR 0 12
81215: PPUSH
81216: LD_INT 7
81218: PPUSH
81219: CALL_OW 272
81223: PPUSH
81224: LD_VAR 0 11
81228: PPUSH
81229: LD_VAR 0 12
81233: PPUSH
81234: LD_INT 7
81236: PPUSH
81237: CALL_OW 273
81241: PPUSH
81242: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
81246: LD_VAR 0 4
81250: PUSH
81251: LD_VAR 0 7
81255: ARRAY
81256: PPUSH
81257: LD_INT 71
81259: PPUSH
81260: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
81264: LD_ADDR_VAR 0 27
81268: PUSH
81269: LD_VAR 0 27
81273: PPUSH
81274: LD_VAR 0 27
81278: PUSH
81279: LD_INT 1
81281: PLUS
81282: PPUSH
81283: LD_VAR 0 14
81287: PUSH
81288: LD_INT 1
81290: ARRAY
81291: PPUSH
81292: CALL_OW 1
81296: ST_TO_ADDR
// attacking := true ;
81297: LD_ADDR_VAR 0 29
81301: PUSH
81302: LD_INT 1
81304: ST_TO_ADDR
// continue ;
81305: GO 79152
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
81307: LD_VAR 0 4
81311: PUSH
81312: LD_VAR 0 7
81316: ARRAY
81317: PPUSH
81318: CALL_OW 257
81322: PUSH
81323: LD_INT 17
81325: EQUAL
81326: PUSH
81327: LD_VAR 0 4
81331: PUSH
81332: LD_VAR 0 7
81336: ARRAY
81337: PPUSH
81338: CALL_OW 110
81342: PUSH
81343: LD_INT 71
81345: EQUAL
81346: NOT
81347: AND
81348: IFFALSE 81494
// begin attacking := false ;
81350: LD_ADDR_VAR 0 29
81354: PUSH
81355: LD_INT 0
81357: ST_TO_ADDR
// k := 5 ;
81358: LD_ADDR_VAR 0 9
81362: PUSH
81363: LD_INT 5
81365: ST_TO_ADDR
// if tmp < k then
81366: LD_VAR 0 14
81370: PUSH
81371: LD_VAR 0 9
81375: LESS
81376: IFFALSE 81388
// k := tmp ;
81378: LD_ADDR_VAR 0 9
81382: PUSH
81383: LD_VAR 0 14
81387: ST_TO_ADDR
// for j = 1 to k do
81388: LD_ADDR_VAR 0 8
81392: PUSH
81393: DOUBLE
81394: LD_INT 1
81396: DEC
81397: ST_TO_ADDR
81398: LD_VAR 0 9
81402: PUSH
81403: FOR_TO
81404: IFFALSE 81492
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
81406: LD_VAR 0 14
81410: PUSH
81411: LD_VAR 0 8
81415: ARRAY
81416: PUSH
81417: LD_VAR 0 14
81421: PPUSH
81422: LD_INT 58
81424: PUSH
81425: EMPTY
81426: LIST
81427: PPUSH
81428: CALL_OW 72
81432: IN
81433: NOT
81434: IFFALSE 81490
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
81436: LD_VAR 0 4
81440: PUSH
81441: LD_VAR 0 7
81445: ARRAY
81446: PPUSH
81447: LD_VAR 0 14
81451: PUSH
81452: LD_VAR 0 8
81456: ARRAY
81457: PPUSH
81458: CALL_OW 115
// attacking := true ;
81462: LD_ADDR_VAR 0 29
81466: PUSH
81467: LD_INT 1
81469: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
81470: LD_VAR 0 4
81474: PUSH
81475: LD_VAR 0 7
81479: ARRAY
81480: PPUSH
81481: LD_INT 71
81483: PPUSH
81484: CALL_OW 109
// continue ;
81488: GO 81403
// end ; end ;
81490: GO 81403
81492: POP
81493: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
81494: LD_VAR 0 4
81498: PUSH
81499: LD_VAR 0 7
81503: ARRAY
81504: PPUSH
81505: CALL_OW 257
81509: PUSH
81510: LD_INT 8
81512: EQUAL
81513: PUSH
81514: LD_VAR 0 4
81518: PUSH
81519: LD_VAR 0 7
81523: ARRAY
81524: PPUSH
81525: CALL_OW 264
81529: PUSH
81530: LD_INT 28
81532: PUSH
81533: LD_INT 45
81535: PUSH
81536: LD_INT 7
81538: PUSH
81539: LD_INT 47
81541: PUSH
81542: EMPTY
81543: LIST
81544: LIST
81545: LIST
81546: LIST
81547: IN
81548: OR
81549: IFFALSE 81805
// begin attacking := false ;
81551: LD_ADDR_VAR 0 29
81555: PUSH
81556: LD_INT 0
81558: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
81559: LD_VAR 0 14
81563: PUSH
81564: LD_INT 1
81566: ARRAY
81567: PPUSH
81568: CALL_OW 266
81572: PUSH
81573: LD_INT 32
81575: PUSH
81576: LD_INT 31
81578: PUSH
81579: LD_INT 33
81581: PUSH
81582: LD_INT 4
81584: PUSH
81585: LD_INT 5
81587: PUSH
81588: EMPTY
81589: LIST
81590: LIST
81591: LIST
81592: LIST
81593: LIST
81594: IN
81595: IFFALSE 81781
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
81597: LD_ADDR_VAR 0 9
81601: PUSH
81602: LD_VAR 0 14
81606: PUSH
81607: LD_INT 1
81609: ARRAY
81610: PPUSH
81611: CALL_OW 266
81615: PPUSH
81616: LD_VAR 0 14
81620: PUSH
81621: LD_INT 1
81623: ARRAY
81624: PPUSH
81625: CALL_OW 250
81629: PPUSH
81630: LD_VAR 0 14
81634: PUSH
81635: LD_INT 1
81637: ARRAY
81638: PPUSH
81639: CALL_OW 251
81643: PPUSH
81644: LD_VAR 0 14
81648: PUSH
81649: LD_INT 1
81651: ARRAY
81652: PPUSH
81653: CALL_OW 254
81657: PPUSH
81658: LD_VAR 0 14
81662: PUSH
81663: LD_INT 1
81665: ARRAY
81666: PPUSH
81667: CALL_OW 248
81671: PPUSH
81672: LD_INT 0
81674: PPUSH
81675: CALL 33165 0 6
81679: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
81680: LD_ADDR_VAR 0 8
81684: PUSH
81685: LD_VAR 0 4
81689: PUSH
81690: LD_VAR 0 7
81694: ARRAY
81695: PPUSH
81696: LD_VAR 0 9
81700: PPUSH
81701: CALL 51835 0 2
81705: ST_TO_ADDR
// if j then
81706: LD_VAR 0 8
81710: IFFALSE 81779
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
81712: LD_VAR 0 8
81716: PUSH
81717: LD_INT 1
81719: ARRAY
81720: PPUSH
81721: LD_VAR 0 8
81725: PUSH
81726: LD_INT 2
81728: ARRAY
81729: PPUSH
81730: CALL_OW 488
81734: IFFALSE 81779
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
81736: LD_VAR 0 4
81740: PUSH
81741: LD_VAR 0 7
81745: ARRAY
81746: PPUSH
81747: LD_VAR 0 8
81751: PUSH
81752: LD_INT 1
81754: ARRAY
81755: PPUSH
81756: LD_VAR 0 8
81760: PUSH
81761: LD_INT 2
81763: ARRAY
81764: PPUSH
81765: CALL_OW 116
// attacking := true ;
81769: LD_ADDR_VAR 0 29
81773: PUSH
81774: LD_INT 1
81776: ST_TO_ADDR
// continue ;
81777: GO 79152
// end ; end else
81779: GO 81805
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
81781: LD_VAR 0 4
81785: PUSH
81786: LD_VAR 0 7
81790: ARRAY
81791: PPUSH
81792: LD_VAR 0 14
81796: PUSH
81797: LD_INT 1
81799: ARRAY
81800: PPUSH
81801: CALL_OW 115
// end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
81805: LD_VAR 0 4
81809: PUSH
81810: LD_VAR 0 7
81814: ARRAY
81815: PPUSH
81816: CALL_OW 265
81820: PUSH
81821: LD_INT 11
81823: EQUAL
81824: IFFALSE 82102
// begin k := 10 ;
81826: LD_ADDR_VAR 0 9
81830: PUSH
81831: LD_INT 10
81833: ST_TO_ADDR
// x := 0 ;
81834: LD_ADDR_VAR 0 10
81838: PUSH
81839: LD_INT 0
81841: ST_TO_ADDR
// if tmp < k then
81842: LD_VAR 0 14
81846: PUSH
81847: LD_VAR 0 9
81851: LESS
81852: IFFALSE 81864
// k := tmp ;
81854: LD_ADDR_VAR 0 9
81858: PUSH
81859: LD_VAR 0 14
81863: ST_TO_ADDR
// for j = k downto 1 do
81864: LD_ADDR_VAR 0 8
81868: PUSH
81869: DOUBLE
81870: LD_VAR 0 9
81874: INC
81875: ST_TO_ADDR
81876: LD_INT 1
81878: PUSH
81879: FOR_DOWNTO
81880: IFFALSE 81955
// begin if GetType ( tmp [ j ] ) = unit_human then
81882: LD_VAR 0 14
81886: PUSH
81887: LD_VAR 0 8
81891: ARRAY
81892: PPUSH
81893: CALL_OW 247
81897: PUSH
81898: LD_INT 1
81900: EQUAL
81901: IFFALSE 81953
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
81903: LD_VAR 0 4
81907: PUSH
81908: LD_VAR 0 7
81912: ARRAY
81913: PPUSH
81914: LD_VAR 0 14
81918: PUSH
81919: LD_VAR 0 8
81923: ARRAY
81924: PPUSH
81925: CALL 52106 0 2
// x := tmp [ j ] ;
81929: LD_ADDR_VAR 0 10
81933: PUSH
81934: LD_VAR 0 14
81938: PUSH
81939: LD_VAR 0 8
81943: ARRAY
81944: ST_TO_ADDR
// attacking := true ;
81945: LD_ADDR_VAR 0 29
81949: PUSH
81950: LD_INT 1
81952: ST_TO_ADDR
// end ; end ;
81953: GO 81879
81955: POP
81956: POP
// if not x then
81957: LD_VAR 0 10
81961: NOT
81962: IFFALSE 82102
// begin attacking := true ;
81964: LD_ADDR_VAR 0 29
81968: PUSH
81969: LD_INT 1
81971: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
81972: LD_VAR 0 4
81976: PUSH
81977: LD_VAR 0 7
81981: ARRAY
81982: PPUSH
81983: CALL_OW 250
81987: PPUSH
81988: LD_VAR 0 4
81992: PUSH
81993: LD_VAR 0 7
81997: ARRAY
81998: PPUSH
81999: CALL_OW 251
82003: PPUSH
82004: CALL_OW 546
82008: PUSH
82009: LD_INT 2
82011: ARRAY
82012: PUSH
82013: LD_VAR 0 14
82017: PUSH
82018: LD_INT 1
82020: ARRAY
82021: PPUSH
82022: CALL_OW 250
82026: PPUSH
82027: LD_VAR 0 14
82031: PUSH
82032: LD_INT 1
82034: ARRAY
82035: PPUSH
82036: CALL_OW 251
82040: PPUSH
82041: CALL_OW 546
82045: PUSH
82046: LD_INT 2
82048: ARRAY
82049: EQUAL
82050: IFFALSE 82078
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
82052: LD_VAR 0 4
82056: PUSH
82057: LD_VAR 0 7
82061: ARRAY
82062: PPUSH
82063: LD_VAR 0 14
82067: PUSH
82068: LD_INT 1
82070: ARRAY
82071: PPUSH
82072: CALL 52106 0 2
82076: GO 82102
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
82078: LD_VAR 0 4
82082: PUSH
82083: LD_VAR 0 7
82087: ARRAY
82088: PPUSH
82089: LD_VAR 0 14
82093: PUSH
82094: LD_INT 1
82096: ARRAY
82097: PPUSH
82098: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
82102: LD_VAR 0 4
82106: PUSH
82107: LD_VAR 0 7
82111: ARRAY
82112: PPUSH
82113: CALL_OW 264
82117: PUSH
82118: LD_INT 29
82120: EQUAL
82121: IFFALSE 82487
// begin if WantsToAttack ( group [ i ] ) in bombed then
82123: LD_VAR 0 4
82127: PUSH
82128: LD_VAR 0 7
82132: ARRAY
82133: PPUSH
82134: CALL_OW 319
82138: PUSH
82139: LD_VAR 0 28
82143: IN
82144: IFFALSE 82148
// continue ;
82146: GO 79152
// k := 8 ;
82148: LD_ADDR_VAR 0 9
82152: PUSH
82153: LD_INT 8
82155: ST_TO_ADDR
// x := 0 ;
82156: LD_ADDR_VAR 0 10
82160: PUSH
82161: LD_INT 0
82163: ST_TO_ADDR
// if tmp < k then
82164: LD_VAR 0 14
82168: PUSH
82169: LD_VAR 0 9
82173: LESS
82174: IFFALSE 82186
// k := tmp ;
82176: LD_ADDR_VAR 0 9
82180: PUSH
82181: LD_VAR 0 14
82185: ST_TO_ADDR
// for j = 1 to k do
82186: LD_ADDR_VAR 0 8
82190: PUSH
82191: DOUBLE
82192: LD_INT 1
82194: DEC
82195: ST_TO_ADDR
82196: LD_VAR 0 9
82200: PUSH
82201: FOR_TO
82202: IFFALSE 82334
// begin if GetType ( tmp [ j ] ) = unit_building then
82204: LD_VAR 0 14
82208: PUSH
82209: LD_VAR 0 8
82213: ARRAY
82214: PPUSH
82215: CALL_OW 247
82219: PUSH
82220: LD_INT 3
82222: EQUAL
82223: IFFALSE 82332
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
82225: LD_VAR 0 14
82229: PUSH
82230: LD_VAR 0 8
82234: ARRAY
82235: PUSH
82236: LD_VAR 0 28
82240: IN
82241: NOT
82242: PUSH
82243: LD_VAR 0 14
82247: PUSH
82248: LD_VAR 0 8
82252: ARRAY
82253: PPUSH
82254: CALL_OW 313
82258: AND
82259: IFFALSE 82332
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
82261: LD_VAR 0 4
82265: PUSH
82266: LD_VAR 0 7
82270: ARRAY
82271: PPUSH
82272: LD_VAR 0 14
82276: PUSH
82277: LD_VAR 0 8
82281: ARRAY
82282: PPUSH
82283: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
82287: LD_ADDR_VAR 0 28
82291: PUSH
82292: LD_VAR 0 28
82296: PPUSH
82297: LD_VAR 0 28
82301: PUSH
82302: LD_INT 1
82304: PLUS
82305: PPUSH
82306: LD_VAR 0 14
82310: PUSH
82311: LD_VAR 0 8
82315: ARRAY
82316: PPUSH
82317: CALL_OW 1
82321: ST_TO_ADDR
// attacking := true ;
82322: LD_ADDR_VAR 0 29
82326: PUSH
82327: LD_INT 1
82329: ST_TO_ADDR
// break ;
82330: GO 82334
// end ; end ;
82332: GO 82201
82334: POP
82335: POP
// if not attacking and f_attack_depot then
82336: LD_VAR 0 29
82340: NOT
82341: PUSH
82342: LD_VAR 0 25
82346: AND
82347: IFFALSE 82442
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
82349: LD_ADDR_VAR 0 13
82353: PUSH
82354: LD_VAR 0 14
82358: PPUSH
82359: LD_INT 2
82361: PUSH
82362: LD_INT 30
82364: PUSH
82365: LD_INT 0
82367: PUSH
82368: EMPTY
82369: LIST
82370: LIST
82371: PUSH
82372: LD_INT 30
82374: PUSH
82375: LD_INT 1
82377: PUSH
82378: EMPTY
82379: LIST
82380: LIST
82381: PUSH
82382: EMPTY
82383: LIST
82384: LIST
82385: LIST
82386: PPUSH
82387: CALL_OW 72
82391: ST_TO_ADDR
// if z then
82392: LD_VAR 0 13
82396: IFFALSE 82442
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
82398: LD_VAR 0 4
82402: PUSH
82403: LD_VAR 0 7
82407: ARRAY
82408: PPUSH
82409: LD_VAR 0 13
82413: PPUSH
82414: LD_VAR 0 4
82418: PUSH
82419: LD_VAR 0 7
82423: ARRAY
82424: PPUSH
82425: CALL_OW 74
82429: PPUSH
82430: CALL_OW 115
// attacking := true ;
82434: LD_ADDR_VAR 0 29
82438: PUSH
82439: LD_INT 1
82441: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
82442: LD_VAR 0 4
82446: PUSH
82447: LD_VAR 0 7
82451: ARRAY
82452: PPUSH
82453: CALL_OW 256
82457: PUSH
82458: LD_INT 500
82460: LESS
82461: IFFALSE 82487
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
82463: LD_VAR 0 4
82467: PUSH
82468: LD_VAR 0 7
82472: ARRAY
82473: PPUSH
82474: LD_VAR 0 14
82478: PUSH
82479: LD_INT 1
82481: ARRAY
82482: PPUSH
82483: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
82487: LD_VAR 0 4
82491: PUSH
82492: LD_VAR 0 7
82496: ARRAY
82497: PPUSH
82498: CALL_OW 264
82502: PUSH
82503: LD_INT 49
82505: EQUAL
82506: IFFALSE 82627
// begin if not HasTask ( group [ i ] ) then
82508: LD_VAR 0 4
82512: PUSH
82513: LD_VAR 0 7
82517: ARRAY
82518: PPUSH
82519: CALL_OW 314
82523: NOT
82524: IFFALSE 82627
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
82526: LD_ADDR_VAR 0 9
82530: PUSH
82531: LD_INT 81
82533: PUSH
82534: LD_VAR 0 4
82538: PUSH
82539: LD_VAR 0 7
82543: ARRAY
82544: PPUSH
82545: CALL_OW 255
82549: PUSH
82550: EMPTY
82551: LIST
82552: LIST
82553: PPUSH
82554: CALL_OW 69
82558: PPUSH
82559: LD_VAR 0 4
82563: PUSH
82564: LD_VAR 0 7
82568: ARRAY
82569: PPUSH
82570: CALL_OW 74
82574: ST_TO_ADDR
// if k then
82575: LD_VAR 0 9
82579: IFFALSE 82627
// if GetDistUnits ( group [ i ] , k ) > 10 then
82581: LD_VAR 0 4
82585: PUSH
82586: LD_VAR 0 7
82590: ARRAY
82591: PPUSH
82592: LD_VAR 0 9
82596: PPUSH
82597: CALL_OW 296
82601: PUSH
82602: LD_INT 10
82604: GREATER
82605: IFFALSE 82627
// ComMoveUnit ( group [ i ] , k ) ;
82607: LD_VAR 0 4
82611: PUSH
82612: LD_VAR 0 7
82616: ARRAY
82617: PPUSH
82618: LD_VAR 0 9
82622: PPUSH
82623: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
82627: LD_VAR 0 4
82631: PUSH
82632: LD_VAR 0 7
82636: ARRAY
82637: PPUSH
82638: CALL_OW 256
82642: PUSH
82643: LD_INT 250
82645: LESS
82646: PUSH
82647: LD_VAR 0 4
82651: PUSH
82652: LD_VAR 0 7
82656: ARRAY
82657: PUSH
82658: LD_INT 21
82660: PUSH
82661: LD_INT 2
82663: PUSH
82664: EMPTY
82665: LIST
82666: LIST
82667: PUSH
82668: LD_INT 23
82670: PUSH
82671: LD_INT 2
82673: PUSH
82674: EMPTY
82675: LIST
82676: LIST
82677: PUSH
82678: EMPTY
82679: LIST
82680: LIST
82681: PPUSH
82682: CALL_OW 69
82686: IN
82687: AND
82688: IFFALSE 82813
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
82690: LD_ADDR_VAR 0 9
82694: PUSH
82695: LD_OWVAR 3
82699: PUSH
82700: LD_VAR 0 4
82704: PUSH
82705: LD_VAR 0 7
82709: ARRAY
82710: DIFF
82711: PPUSH
82712: LD_VAR 0 4
82716: PUSH
82717: LD_VAR 0 7
82721: ARRAY
82722: PPUSH
82723: CALL_OW 74
82727: ST_TO_ADDR
// if not k then
82728: LD_VAR 0 9
82732: NOT
82733: IFFALSE 82737
// continue ;
82735: GO 79152
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
82737: LD_VAR 0 9
82741: PUSH
82742: LD_INT 81
82744: PUSH
82745: LD_VAR 0 4
82749: PUSH
82750: LD_VAR 0 7
82754: ARRAY
82755: PPUSH
82756: CALL_OW 255
82760: PUSH
82761: EMPTY
82762: LIST
82763: LIST
82764: PPUSH
82765: CALL_OW 69
82769: IN
82770: PUSH
82771: LD_VAR 0 9
82775: PPUSH
82776: LD_VAR 0 4
82780: PUSH
82781: LD_VAR 0 7
82785: ARRAY
82786: PPUSH
82787: CALL_OW 296
82791: PUSH
82792: LD_INT 5
82794: LESS
82795: AND
82796: IFFALSE 82813
// ComAutodestruct ( group [ i ] ) ;
82798: LD_VAR 0 4
82802: PUSH
82803: LD_VAR 0 7
82807: ARRAY
82808: PPUSH
82809: CALL 52004 0 1
// end ; if f_attack_depot then
82813: LD_VAR 0 25
82817: IFFALSE 82929
// begin k := 6 ;
82819: LD_ADDR_VAR 0 9
82823: PUSH
82824: LD_INT 6
82826: ST_TO_ADDR
// if tmp < k then
82827: LD_VAR 0 14
82831: PUSH
82832: LD_VAR 0 9
82836: LESS
82837: IFFALSE 82849
// k := tmp ;
82839: LD_ADDR_VAR 0 9
82843: PUSH
82844: LD_VAR 0 14
82848: ST_TO_ADDR
// for j = 1 to k do
82849: LD_ADDR_VAR 0 8
82853: PUSH
82854: DOUBLE
82855: LD_INT 1
82857: DEC
82858: ST_TO_ADDR
82859: LD_VAR 0 9
82863: PUSH
82864: FOR_TO
82865: IFFALSE 82927
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
82867: LD_VAR 0 8
82871: PPUSH
82872: CALL_OW 266
82876: PUSH
82877: LD_INT 0
82879: PUSH
82880: LD_INT 1
82882: PUSH
82883: EMPTY
82884: LIST
82885: LIST
82886: IN
82887: IFFALSE 82925
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
82889: LD_VAR 0 4
82893: PUSH
82894: LD_VAR 0 7
82898: ARRAY
82899: PPUSH
82900: LD_VAR 0 14
82904: PUSH
82905: LD_VAR 0 8
82909: ARRAY
82910: PPUSH
82911: CALL_OW 115
// attacking := true ;
82915: LD_ADDR_VAR 0 29
82919: PUSH
82920: LD_INT 1
82922: ST_TO_ADDR
// break ;
82923: GO 82927
// end ;
82925: GO 82864
82927: POP
82928: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
82929: LD_VAR 0 4
82933: PUSH
82934: LD_VAR 0 7
82938: ARRAY
82939: PPUSH
82940: CALL_OW 302
82944: PUSH
82945: LD_VAR 0 29
82949: NOT
82950: AND
82951: IFFALSE 83273
// begin if GetTag ( group [ i ] ) = 71 then
82953: LD_VAR 0 4
82957: PUSH
82958: LD_VAR 0 7
82962: ARRAY
82963: PPUSH
82964: CALL_OW 110
82968: PUSH
82969: LD_INT 71
82971: EQUAL
82972: IFFALSE 83013
// begin if HasTask ( group [ i ] ) then
82974: LD_VAR 0 4
82978: PUSH
82979: LD_VAR 0 7
82983: ARRAY
82984: PPUSH
82985: CALL_OW 314
82989: IFFALSE 82995
// continue else
82991: GO 79152
82993: GO 83013
// SetTag ( group [ i ] , 0 ) ;
82995: LD_VAR 0 4
82999: PUSH
83000: LD_VAR 0 7
83004: ARRAY
83005: PPUSH
83006: LD_INT 0
83008: PPUSH
83009: CALL_OW 109
// end ; k := 8 ;
83013: LD_ADDR_VAR 0 9
83017: PUSH
83018: LD_INT 8
83020: ST_TO_ADDR
// x := 0 ;
83021: LD_ADDR_VAR 0 10
83025: PUSH
83026: LD_INT 0
83028: ST_TO_ADDR
// if tmp < k then
83029: LD_VAR 0 14
83033: PUSH
83034: LD_VAR 0 9
83038: LESS
83039: IFFALSE 83051
// k := tmp ;
83041: LD_ADDR_VAR 0 9
83045: PUSH
83046: LD_VAR 0 14
83050: ST_TO_ADDR
// for j = 1 to k do
83051: LD_ADDR_VAR 0 8
83055: PUSH
83056: DOUBLE
83057: LD_INT 1
83059: DEC
83060: ST_TO_ADDR
83061: LD_VAR 0 9
83065: PUSH
83066: FOR_TO
83067: IFFALSE 83165
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
83069: LD_VAR 0 14
83073: PUSH
83074: LD_VAR 0 8
83078: ARRAY
83079: PPUSH
83080: CALL_OW 247
83084: PUSH
83085: LD_INT 1
83087: EQUAL
83088: PUSH
83089: LD_VAR 0 14
83093: PUSH
83094: LD_VAR 0 8
83098: ARRAY
83099: PPUSH
83100: CALL_OW 256
83104: PUSH
83105: LD_INT 250
83107: LESS
83108: PUSH
83109: LD_VAR 0 20
83113: AND
83114: PUSH
83115: LD_VAR 0 20
83119: NOT
83120: PUSH
83121: LD_VAR 0 14
83125: PUSH
83126: LD_VAR 0 8
83130: ARRAY
83131: PPUSH
83132: CALL_OW 256
83136: PUSH
83137: LD_INT 250
83139: GREATEREQUAL
83140: AND
83141: OR
83142: AND
83143: IFFALSE 83163
// begin x := tmp [ j ] ;
83145: LD_ADDR_VAR 0 10
83149: PUSH
83150: LD_VAR 0 14
83154: PUSH
83155: LD_VAR 0 8
83159: ARRAY
83160: ST_TO_ADDR
// break ;
83161: GO 83165
// end ;
83163: GO 83066
83165: POP
83166: POP
// if x then
83167: LD_VAR 0 10
83171: IFFALSE 83195
// ComAttackUnit ( group [ i ] , x ) else
83173: LD_VAR 0 4
83177: PUSH
83178: LD_VAR 0 7
83182: ARRAY
83183: PPUSH
83184: LD_VAR 0 10
83188: PPUSH
83189: CALL_OW 115
83193: GO 83219
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
83195: LD_VAR 0 4
83199: PUSH
83200: LD_VAR 0 7
83204: ARRAY
83205: PPUSH
83206: LD_VAR 0 14
83210: PUSH
83211: LD_INT 1
83213: ARRAY
83214: PPUSH
83215: CALL_OW 115
// if not HasTask ( group [ i ] ) then
83219: LD_VAR 0 4
83223: PUSH
83224: LD_VAR 0 7
83228: ARRAY
83229: PPUSH
83230: CALL_OW 314
83234: NOT
83235: IFFALSE 83273
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
83237: LD_VAR 0 4
83241: PUSH
83242: LD_VAR 0 7
83246: ARRAY
83247: PPUSH
83248: LD_VAR 0 14
83252: PPUSH
83253: LD_VAR 0 4
83257: PUSH
83258: LD_VAR 0 7
83262: ARRAY
83263: PPUSH
83264: CALL_OW 74
83268: PPUSH
83269: CALL_OW 115
// end ; end ; end ;
83273: GO 79152
83275: POP
83276: POP
// wait ( 0 0$2 ) ;
83277: LD_INT 70
83279: PPUSH
83280: CALL_OW 67
// until not group or group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
83284: LD_VAR 0 4
83288: NOT
83289: PUSH
83290: LD_VAR 0 4
83294: PUSH
83295: EMPTY
83296: EQUAL
83297: OR
83298: PUSH
83299: LD_INT 81
83301: PUSH
83302: LD_VAR 0 35
83306: PUSH
83307: EMPTY
83308: LIST
83309: LIST
83310: PPUSH
83311: CALL_OW 69
83315: NOT
83316: OR
83317: IFFALSE 79137
// end ;
83319: LD_VAR 0 2
83323: RET
// export function BasicDefend ( base , solds ) ; var enemy , e , side , i , hex ; begin
83324: LD_INT 0
83326: PPUSH
83327: PPUSH
83328: PPUSH
83329: PPUSH
83330: PPUSH
83331: PPUSH
// if not base or not mc_bases [ base ] or not solds then
83332: LD_VAR 0 1
83336: NOT
83337: PUSH
83338: LD_EXP 177
83342: PUSH
83343: LD_VAR 0 1
83347: ARRAY
83348: NOT
83349: OR
83350: PUSH
83351: LD_VAR 0 2
83355: NOT
83356: OR
83357: IFFALSE 83361
// exit ;
83359: GO 83915
// side := mc_sides [ base ] ;
83361: LD_ADDR_VAR 0 6
83365: PUSH
83366: LD_EXP 203
83370: PUSH
83371: LD_VAR 0 1
83375: ARRAY
83376: ST_TO_ADDR
// if not side then
83377: LD_VAR 0 6
83381: NOT
83382: IFFALSE 83386
// exit ;
83384: GO 83915
// for i in solds do
83386: LD_ADDR_VAR 0 7
83390: PUSH
83391: LD_VAR 0 2
83395: PUSH
83396: FOR_IN
83397: IFFALSE 83458
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
83399: LD_VAR 0 7
83403: PPUSH
83404: CALL_OW 310
83408: PPUSH
83409: CALL_OW 266
83413: PUSH
83414: LD_INT 32
83416: PUSH
83417: LD_INT 31
83419: PUSH
83420: EMPTY
83421: LIST
83422: LIST
83423: IN
83424: IFFALSE 83444
// solds := solds diff i else
83426: LD_ADDR_VAR 0 2
83430: PUSH
83431: LD_VAR 0 2
83435: PUSH
83436: LD_VAR 0 7
83440: DIFF
83441: ST_TO_ADDR
83442: GO 83456
// SetTag ( i , 18 ) ;
83444: LD_VAR 0 7
83448: PPUSH
83449: LD_INT 18
83451: PPUSH
83452: CALL_OW 109
83456: GO 83396
83458: POP
83459: POP
// if not solds then
83460: LD_VAR 0 2
83464: NOT
83465: IFFALSE 83469
// exit ;
83467: GO 83915
// repeat wait ( 0 0$2 ) ;
83469: LD_INT 70
83471: PPUSH
83472: CALL_OW 67
// enemy := mc_scan [ base ] ;
83476: LD_ADDR_VAR 0 4
83480: PUSH
83481: LD_EXP 200
83485: PUSH
83486: LD_VAR 0 1
83490: ARRAY
83491: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
83492: LD_EXP 177
83496: PUSH
83497: LD_VAR 0 1
83501: ARRAY
83502: NOT
83503: PUSH
83504: LD_EXP 177
83508: PUSH
83509: LD_VAR 0 1
83513: ARRAY
83514: PUSH
83515: EMPTY
83516: EQUAL
83517: OR
83518: IFFALSE 83555
// begin for i in solds do
83520: LD_ADDR_VAR 0 7
83524: PUSH
83525: LD_VAR 0 2
83529: PUSH
83530: FOR_IN
83531: IFFALSE 83544
// ComStop ( i ) ;
83533: LD_VAR 0 7
83537: PPUSH
83538: CALL_OW 141
83542: GO 83530
83544: POP
83545: POP
// solds := [ ] ;
83546: LD_ADDR_VAR 0 2
83550: PUSH
83551: EMPTY
83552: ST_TO_ADDR
// exit ;
83553: GO 83915
// end ; for i in solds do
83555: LD_ADDR_VAR 0 7
83559: PUSH
83560: LD_VAR 0 2
83564: PUSH
83565: FOR_IN
83566: IFFALSE 83887
// begin if IsInUnit ( i ) then
83568: LD_VAR 0 7
83572: PPUSH
83573: CALL_OW 310
83577: IFFALSE 83588
// ComExitBuilding ( i ) ;
83579: LD_VAR 0 7
83583: PPUSH
83584: CALL_OW 122
// if GetLives ( i ) > 500 then
83588: LD_VAR 0 7
83592: PPUSH
83593: CALL_OW 256
83597: PUSH
83598: LD_INT 500
83600: GREATER
83601: IFFALSE 83654
// begin e := NearestUnitToUnit ( enemy , i ) ;
83603: LD_ADDR_VAR 0 5
83607: PUSH
83608: LD_VAR 0 4
83612: PPUSH
83613: LD_VAR 0 7
83617: PPUSH
83618: CALL_OW 74
83622: ST_TO_ADDR
// ComAgressiveMove ( i , GetX ( e ) , GetY ( e ) ) ;
83623: LD_VAR 0 7
83627: PPUSH
83628: LD_VAR 0 5
83632: PPUSH
83633: CALL_OW 250
83637: PPUSH
83638: LD_VAR 0 5
83642: PPUSH
83643: CALL_OW 251
83647: PPUSH
83648: CALL_OW 114
// end else
83652: GO 83885
// if GetDistUnits ( i , NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ) > 10 then
83654: LD_VAR 0 7
83658: PPUSH
83659: LD_EXP 177
83663: PUSH
83664: LD_VAR 0 1
83668: ARRAY
83669: PPUSH
83670: LD_INT 2
83672: PUSH
83673: LD_INT 30
83675: PUSH
83676: LD_INT 0
83678: PUSH
83679: EMPTY
83680: LIST
83681: LIST
83682: PUSH
83683: LD_INT 30
83685: PUSH
83686: LD_INT 1
83688: PUSH
83689: EMPTY
83690: LIST
83691: LIST
83692: PUSH
83693: LD_INT 30
83695: PUSH
83696: LD_INT 6
83698: PUSH
83699: EMPTY
83700: LIST
83701: LIST
83702: PUSH
83703: EMPTY
83704: LIST
83705: LIST
83706: LIST
83707: LIST
83708: PPUSH
83709: CALL_OW 72
83713: PPUSH
83714: LD_VAR 0 7
83718: PPUSH
83719: CALL_OW 74
83723: PPUSH
83724: CALL_OW 296
83728: PUSH
83729: LD_INT 10
83731: GREATER
83732: IFFALSE 83885
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
83734: LD_ADDR_VAR 0 8
83738: PUSH
83739: LD_EXP 177
83743: PUSH
83744: LD_VAR 0 1
83748: ARRAY
83749: PPUSH
83750: LD_INT 2
83752: PUSH
83753: LD_INT 30
83755: PUSH
83756: LD_INT 0
83758: PUSH
83759: EMPTY
83760: LIST
83761: LIST
83762: PUSH
83763: LD_INT 30
83765: PUSH
83766: LD_INT 1
83768: PUSH
83769: EMPTY
83770: LIST
83771: LIST
83772: PUSH
83773: LD_INT 30
83775: PUSH
83776: LD_INT 6
83778: PUSH
83779: EMPTY
83780: LIST
83781: LIST
83782: PUSH
83783: EMPTY
83784: LIST
83785: LIST
83786: LIST
83787: LIST
83788: PPUSH
83789: CALL_OW 72
83793: PPUSH
83794: LD_VAR 0 7
83798: PPUSH
83799: CALL_OW 74
83803: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
83804: LD_VAR 0 7
83808: PPUSH
83809: LD_VAR 0 8
83813: PPUSH
83814: CALL_OW 250
83818: PPUSH
83819: LD_INT 3
83821: PPUSH
83822: LD_INT 5
83824: PPUSH
83825: CALL_OW 272
83829: PPUSH
83830: LD_VAR 0 8
83834: PPUSH
83835: CALL_OW 251
83839: PPUSH
83840: LD_INT 3
83842: PPUSH
83843: LD_INT 5
83845: PPUSH
83846: CALL_OW 273
83850: PPUSH
83851: CALL_OW 111
// SetTag ( i , 0 ) ;
83855: LD_VAR 0 7
83859: PPUSH
83860: LD_INT 0
83862: PPUSH
83863: CALL_OW 109
// solds := solds diff i ;
83867: LD_ADDR_VAR 0 2
83871: PUSH
83872: LD_VAR 0 2
83876: PUSH
83877: LD_VAR 0 7
83881: DIFF
83882: ST_TO_ADDR
// continue ;
83883: GO 83565
// end ; end ;
83885: GO 83565
83887: POP
83888: POP
// until not solds or not enemy ;
83889: LD_VAR 0 2
83893: NOT
83894: PUSH
83895: LD_VAR 0 4
83899: NOT
83900: OR
83901: IFFALSE 83469
// MC_Reset ( base , 18 ) ;
83903: LD_VAR 0 1
83907: PPUSH
83908: LD_INT 18
83910: PPUSH
83911: CALL 90070 0 2
// end ;
83915: LD_VAR 0 3
83919: RET
// export function Defend ( base , defenders ) ; var i , j , x , depot , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend , class , enemy ; begin
83920: LD_INT 0
83922: PPUSH
83923: PPUSH
83924: PPUSH
83925: PPUSH
83926: PPUSH
83927: PPUSH
83928: PPUSH
83929: PPUSH
83930: PPUSH
83931: PPUSH
83932: PPUSH
83933: PPUSH
83934: PPUSH
83935: PPUSH
83936: PPUSH
83937: PPUSH
83938: PPUSH
83939: PPUSH
83940: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
83941: LD_ADDR_VAR 0 12
83945: PUSH
83946: LD_EXP 177
83950: PUSH
83951: LD_VAR 0 1
83955: ARRAY
83956: PPUSH
83957: LD_INT 25
83959: PUSH
83960: LD_INT 3
83962: PUSH
83963: EMPTY
83964: LIST
83965: LIST
83966: PPUSH
83967: CALL_OW 72
83971: ST_TO_ADDR
// if mc_remote_driver [ base ] then
83972: LD_EXP 217
83976: PUSH
83977: LD_VAR 0 1
83981: ARRAY
83982: IFFALSE 84006
// mechs := mechs diff mc_remote_driver [ base ] ;
83984: LD_ADDR_VAR 0 12
83988: PUSH
83989: LD_VAR 0 12
83993: PUSH
83994: LD_EXP 217
83998: PUSH
83999: LD_VAR 0 1
84003: ARRAY
84004: DIFF
84005: ST_TO_ADDR
// for i in mechs do
84006: LD_ADDR_VAR 0 4
84010: PUSH
84011: LD_VAR 0 12
84015: PUSH
84016: FOR_IN
84017: IFFALSE 84052
// if GetTag ( i ) > 0 then
84019: LD_VAR 0 4
84023: PPUSH
84024: CALL_OW 110
84028: PUSH
84029: LD_INT 0
84031: GREATER
84032: IFFALSE 84050
// mechs := mechs diff i ;
84034: LD_ADDR_VAR 0 12
84038: PUSH
84039: LD_VAR 0 12
84043: PUSH
84044: LD_VAR 0 4
84048: DIFF
84049: ST_TO_ADDR
84050: GO 84016
84052: POP
84053: POP
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
84054: LD_ADDR_VAR 0 8
84058: PUSH
84059: LD_EXP 177
84063: PUSH
84064: LD_VAR 0 1
84068: ARRAY
84069: PPUSH
84070: LD_INT 2
84072: PUSH
84073: LD_INT 25
84075: PUSH
84076: LD_INT 1
84078: PUSH
84079: EMPTY
84080: LIST
84081: LIST
84082: PUSH
84083: LD_INT 25
84085: PUSH
84086: LD_INT 5
84088: PUSH
84089: EMPTY
84090: LIST
84091: LIST
84092: PUSH
84093: LD_INT 25
84095: PUSH
84096: LD_INT 8
84098: PUSH
84099: EMPTY
84100: LIST
84101: LIST
84102: PUSH
84103: LD_INT 25
84105: PUSH
84106: LD_INT 9
84108: PUSH
84109: EMPTY
84110: LIST
84111: LIST
84112: PUSH
84113: EMPTY
84114: LIST
84115: LIST
84116: LIST
84117: LIST
84118: LIST
84119: PPUSH
84120: CALL_OW 72
84124: ST_TO_ADDR
// if not defenders and not solds then
84125: LD_VAR 0 2
84129: NOT
84130: PUSH
84131: LD_VAR 0 8
84135: NOT
84136: AND
84137: IFFALSE 84141
// exit ;
84139: GO 85911
// depot_under_attack := false ;
84141: LD_ADDR_VAR 0 16
84145: PUSH
84146: LD_INT 0
84148: ST_TO_ADDR
// sold_defenders := [ ] ;
84149: LD_ADDR_VAR 0 17
84153: PUSH
84154: EMPTY
84155: ST_TO_ADDR
// if mechs then
84156: LD_VAR 0 12
84160: IFFALSE 84313
// for i in UnitFilter ( defenders , [ f_type , unit_vehicle ] ) do
84162: LD_ADDR_VAR 0 4
84166: PUSH
84167: LD_VAR 0 2
84171: PPUSH
84172: LD_INT 21
84174: PUSH
84175: LD_INT 2
84177: PUSH
84178: EMPTY
84179: LIST
84180: LIST
84181: PPUSH
84182: CALL_OW 72
84186: PUSH
84187: FOR_IN
84188: IFFALSE 84311
// begin if GetTag ( i ) <> 20 then
84190: LD_VAR 0 4
84194: PPUSH
84195: CALL_OW 110
84199: PUSH
84200: LD_INT 20
84202: NONEQUAL
84203: IFFALSE 84217
// SetTag ( i , 20 ) ;
84205: LD_VAR 0 4
84209: PPUSH
84210: LD_INT 20
84212: PPUSH
84213: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) then
84217: LD_VAR 0 4
84221: PPUSH
84222: CALL_OW 263
84226: PUSH
84227: LD_INT 1
84229: EQUAL
84230: PUSH
84231: LD_VAR 0 4
84235: PPUSH
84236: CALL_OW 311
84240: NOT
84241: AND
84242: IFFALSE 84309
// begin un := mechs [ 1 ] ;
84244: LD_ADDR_VAR 0 10
84248: PUSH
84249: LD_VAR 0 12
84253: PUSH
84254: LD_INT 1
84256: ARRAY
84257: ST_TO_ADDR
// ComExit ( un ) ;
84258: LD_VAR 0 10
84262: PPUSH
84263: CALL 56349 0 1
// AddComEnterUnit ( un , i ) ;
84267: LD_VAR 0 10
84271: PPUSH
84272: LD_VAR 0 4
84276: PPUSH
84277: CALL_OW 180
// SetTag ( un , 19 ) ;
84281: LD_VAR 0 10
84285: PPUSH
84286: LD_INT 19
84288: PPUSH
84289: CALL_OW 109
// mechs := mechs diff un ;
84293: LD_ADDR_VAR 0 12
84297: PUSH
84298: LD_VAR 0 12
84302: PUSH
84303: LD_VAR 0 10
84307: DIFF
84308: ST_TO_ADDR
// end ; end ;
84309: GO 84187
84311: POP
84312: POP
// if solds then
84313: LD_VAR 0 8
84317: IFFALSE 84376
// for i in solds do
84319: LD_ADDR_VAR 0 4
84323: PUSH
84324: LD_VAR 0 8
84328: PUSH
84329: FOR_IN
84330: IFFALSE 84374
// if not GetTag ( i ) then
84332: LD_VAR 0 4
84336: PPUSH
84337: CALL_OW 110
84341: NOT
84342: IFFALSE 84372
// begin defenders := defenders union i ;
84344: LD_ADDR_VAR 0 2
84348: PUSH
84349: LD_VAR 0 2
84353: PUSH
84354: LD_VAR 0 4
84358: UNION
84359: ST_TO_ADDR
// SetTag ( i , 18 ) ;
84360: LD_VAR 0 4
84364: PPUSH
84365: LD_INT 18
84367: PPUSH
84368: CALL_OW 109
// end ;
84372: GO 84329
84374: POP
84375: POP
// repeat wait ( 0 0$2 ) ;
84376: LD_INT 70
84378: PPUSH
84379: CALL_OW 67
// enemy := mc_scan [ base ] ;
84383: LD_ADDR_VAR 0 21
84387: PUSH
84388: LD_EXP 200
84392: PUSH
84393: LD_VAR 0 1
84397: ARRAY
84398: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
84399: LD_EXP 177
84403: PUSH
84404: LD_VAR 0 1
84408: ARRAY
84409: NOT
84410: PUSH
84411: LD_EXP 177
84415: PUSH
84416: LD_VAR 0 1
84420: ARRAY
84421: PUSH
84422: EMPTY
84423: EQUAL
84424: OR
84425: IFFALSE 84462
// begin for i in defenders do
84427: LD_ADDR_VAR 0 4
84431: PUSH
84432: LD_VAR 0 2
84436: PUSH
84437: FOR_IN
84438: IFFALSE 84451
// ComStop ( i ) ;
84440: LD_VAR 0 4
84444: PPUSH
84445: CALL_OW 141
84449: GO 84437
84451: POP
84452: POP
// defenders := [ ] ;
84453: LD_ADDR_VAR 0 2
84457: PUSH
84458: EMPTY
84459: ST_TO_ADDR
// exit ;
84460: GO 85911
// end ; for i in defenders do
84462: LD_ADDR_VAR 0 4
84466: PUSH
84467: LD_VAR 0 2
84471: PUSH
84472: FOR_IN
84473: IFFALSE 85371
// begin e := NearestUnitToUnit ( enemy , i ) ;
84475: LD_ADDR_VAR 0 13
84479: PUSH
84480: LD_VAR 0 21
84484: PPUSH
84485: LD_VAR 0 4
84489: PPUSH
84490: CALL_OW 74
84494: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
84495: LD_ADDR_VAR 0 7
84499: PUSH
84500: LD_EXP 177
84504: PUSH
84505: LD_VAR 0 1
84509: ARRAY
84510: PPUSH
84511: LD_INT 2
84513: PUSH
84514: LD_INT 30
84516: PUSH
84517: LD_INT 0
84519: PUSH
84520: EMPTY
84521: LIST
84522: LIST
84523: PUSH
84524: LD_INT 30
84526: PUSH
84527: LD_INT 1
84529: PUSH
84530: EMPTY
84531: LIST
84532: LIST
84533: PUSH
84534: EMPTY
84535: LIST
84536: LIST
84537: LIST
84538: PPUSH
84539: CALL_OW 72
84543: ST_TO_ADDR
// depot_under_attack := ( not depot or UnitFilter ( depot , [ f_not , [ f_lives , 600 ] ] ) ) ;
84544: LD_ADDR_VAR 0 16
84548: PUSH
84549: LD_VAR 0 7
84553: NOT
84554: PUSH
84555: LD_VAR 0 7
84559: PPUSH
84560: LD_INT 3
84562: PUSH
84563: LD_INT 24
84565: PUSH
84566: LD_INT 600
84568: PUSH
84569: EMPTY
84570: LIST
84571: LIST
84572: PUSH
84573: EMPTY
84574: LIST
84575: LIST
84576: PPUSH
84577: CALL_OW 72
84581: OR
84582: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
84583: LD_VAR 0 4
84587: PPUSH
84588: CALL_OW 247
84592: PUSH
84593: LD_INT 2
84595: DOUBLE
84596: EQUAL
84597: IFTRUE 84601
84599: GO 84997
84601: POP
// begin if GetLives ( i ) = 1000 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
84602: LD_VAR 0 4
84606: PPUSH
84607: CALL_OW 256
84611: PUSH
84612: LD_INT 1000
84614: EQUAL
84615: PUSH
84616: LD_VAR 0 4
84620: PPUSH
84621: LD_VAR 0 13
84625: PPUSH
84626: CALL_OW 296
84630: PUSH
84631: LD_INT 40
84633: LESS
84634: PUSH
84635: LD_VAR 0 13
84639: PPUSH
84640: LD_EXP 202
84644: PUSH
84645: LD_VAR 0 1
84649: ARRAY
84650: PPUSH
84651: CALL_OW 308
84655: OR
84656: AND
84657: IFFALSE 84779
// begin if GetEngine ( i ) = engine_combustion and GetFuel ( i ) < 30 and depot then
84659: LD_VAR 0 4
84663: PPUSH
84664: CALL_OW 262
84668: PUSH
84669: LD_INT 1
84671: EQUAL
84672: PUSH
84673: LD_VAR 0 4
84677: PPUSH
84678: CALL_OW 261
84682: PUSH
84683: LD_INT 30
84685: LESS
84686: AND
84687: PUSH
84688: LD_VAR 0 7
84692: AND
84693: IFFALSE 84763
// begin ComMoveUnit ( i , NearestUnitToUnit ( depot , i ) ) ;
84695: LD_VAR 0 4
84699: PPUSH
84700: LD_VAR 0 7
84704: PPUSH
84705: LD_VAR 0 4
84709: PPUSH
84710: CALL_OW 74
84714: PPUSH
84715: CALL_OW 112
// if GetDistUnits ( i , NearestUnitToUnit ( depot , i ) ) < 6 then
84719: LD_VAR 0 4
84723: PPUSH
84724: LD_VAR 0 7
84728: PPUSH
84729: LD_VAR 0 4
84733: PPUSH
84734: CALL_OW 74
84738: PPUSH
84739: CALL_OW 296
84743: PUSH
84744: LD_INT 6
84746: LESS
84747: IFFALSE 84761
// SetFuel ( i , 100 ) ;
84749: LD_VAR 0 4
84753: PPUSH
84754: LD_INT 100
84756: PPUSH
84757: CALL_OW 240
// end else
84761: GO 84777
// ComAttackUnit ( i , e ) ;
84763: LD_VAR 0 4
84767: PPUSH
84768: LD_VAR 0 13
84772: PPUSH
84773: CALL_OW 115
// end else
84777: GO 84880
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
84779: LD_VAR 0 13
84783: PPUSH
84784: LD_EXP 202
84788: PUSH
84789: LD_VAR 0 1
84793: ARRAY
84794: PPUSH
84795: CALL_OW 308
84799: NOT
84800: PUSH
84801: LD_VAR 0 4
84805: PPUSH
84806: LD_VAR 0 13
84810: PPUSH
84811: CALL_OW 296
84815: PUSH
84816: LD_INT 40
84818: GREATEREQUAL
84819: AND
84820: PUSH
84821: LD_VAR 0 4
84825: PPUSH
84826: CALL_OW 256
84830: PUSH
84831: LD_INT 650
84833: LESSEQUAL
84834: OR
84835: PUSH
84836: LD_VAR 0 4
84840: PPUSH
84841: LD_EXP 201
84845: PUSH
84846: LD_VAR 0 1
84850: ARRAY
84851: PPUSH
84852: CALL_OW 308
84856: NOT
84857: AND
84858: IFFALSE 84880
// ComMoveToArea ( i , mc_parking [ base ] ) ;
84860: LD_VAR 0 4
84864: PPUSH
84865: LD_EXP 201
84869: PUSH
84870: LD_VAR 0 1
84874: ARRAY
84875: PPUSH
84876: CALL_OW 113
// if GetLives ( i ) < 1000 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
84880: LD_VAR 0 4
84884: PPUSH
84885: CALL_OW 256
84889: PUSH
84890: LD_INT 1000
84892: LESS
84893: PUSH
84894: LD_VAR 0 4
84898: PPUSH
84899: CALL_OW 263
84903: PUSH
84904: LD_INT 1
84906: EQUAL
84907: AND
84908: PUSH
84909: LD_VAR 0 4
84913: PPUSH
84914: CALL_OW 311
84918: AND
84919: PUSH
84920: LD_VAR 0 4
84924: PPUSH
84925: LD_EXP 201
84929: PUSH
84930: LD_VAR 0 1
84934: ARRAY
84935: PPUSH
84936: CALL_OW 308
84940: AND
84941: IFFALSE 84995
// begin mech := IsDrivenBy ( i ) ;
84943: LD_ADDR_VAR 0 9
84947: PUSH
84948: LD_VAR 0 4
84952: PPUSH
84953: CALL_OW 311
84957: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
84958: LD_VAR 0 9
84962: PPUSH
84963: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
84967: LD_VAR 0 9
84971: PPUSH
84972: LD_VAR 0 4
84976: PPUSH
84977: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
84981: LD_VAR 0 9
84985: PPUSH
84986: LD_VAR 0 4
84990: PPUSH
84991: CALL_OW 180
// end ; end ; unit_human :
84995: GO 85342
84997: LD_INT 1
84999: DOUBLE
85000: EQUAL
85001: IFTRUE 85005
85003: GO 85341
85005: POP
// begin b := IsInUnit ( i ) ;
85006: LD_ADDR_VAR 0 18
85010: PUSH
85011: LD_VAR 0 4
85015: PPUSH
85016: CALL_OW 310
85020: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
85021: LD_ADDR_VAR 0 19
85025: PUSH
85026: LD_VAR 0 18
85030: NOT
85031: PUSH
85032: LD_VAR 0 18
85036: PPUSH
85037: CALL_OW 266
85041: PUSH
85042: LD_INT 32
85044: PUSH
85045: LD_INT 31
85047: PUSH
85048: EMPTY
85049: LIST
85050: LIST
85051: IN
85052: OR
85053: ST_TO_ADDR
// if GetBType ( b ) = b_barracks and GetClass ( i ) in [ 1 , 2 , 3 , 4 ] then
85054: LD_VAR 0 18
85058: PPUSH
85059: CALL_OW 266
85063: PUSH
85064: LD_INT 5
85066: EQUAL
85067: PUSH
85068: LD_VAR 0 4
85072: PPUSH
85073: CALL_OW 257
85077: PUSH
85078: LD_INT 1
85080: PUSH
85081: LD_INT 2
85083: PUSH
85084: LD_INT 3
85086: PUSH
85087: LD_INT 4
85089: PUSH
85090: EMPTY
85091: LIST
85092: LIST
85093: LIST
85094: LIST
85095: IN
85096: AND
85097: IFFALSE 85134
// begin class := AllowSpecClass ( i ) ;
85099: LD_ADDR_VAR 0 20
85103: PUSH
85104: LD_VAR 0 4
85108: PPUSH
85109: CALL 21010 0 1
85113: ST_TO_ADDR
// if class then
85114: LD_VAR 0 20
85118: IFFALSE 85134
// ComChangeProfession ( i , class ) ;
85120: LD_VAR 0 4
85124: PPUSH
85125: LD_VAR 0 20
85129: PPUSH
85130: CALL_OW 123
// end ; if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
85134: LD_VAR 0 16
85138: PUSH
85139: LD_VAR 0 2
85143: PPUSH
85144: LD_INT 21
85146: PUSH
85147: LD_INT 2
85149: PUSH
85150: EMPTY
85151: LIST
85152: LIST
85153: PPUSH
85154: CALL_OW 72
85158: PUSH
85159: LD_INT 1
85161: LESSEQUAL
85162: OR
85163: PUSH
85164: LD_VAR 0 19
85168: AND
85169: PUSH
85170: LD_VAR 0 4
85174: PUSH
85175: LD_VAR 0 17
85179: IN
85180: NOT
85181: AND
85182: IFFALSE 85275
// begin if b then
85184: LD_VAR 0 18
85188: IFFALSE 85237
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
85190: LD_VAR 0 18
85194: PPUSH
85195: LD_VAR 0 21
85199: PPUSH
85200: LD_VAR 0 18
85204: PPUSH
85205: CALL_OW 74
85209: PPUSH
85210: CALL_OW 296
85214: PUSH
85215: LD_INT 10
85217: LESS
85218: PUSH
85219: LD_VAR 0 18
85223: PPUSH
85224: CALL_OW 461
85228: PUSH
85229: LD_INT 7
85231: NONEQUAL
85232: AND
85233: IFFALSE 85237
// continue ;
85235: GO 84472
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
85237: LD_ADDR_VAR 0 17
85241: PUSH
85242: LD_VAR 0 17
85246: PPUSH
85247: LD_VAR 0 17
85251: PUSH
85252: LD_INT 1
85254: PLUS
85255: PPUSH
85256: LD_VAR 0 4
85260: PPUSH
85261: CALL_OW 1
85265: ST_TO_ADDR
// ComExitBuilding ( i ) ;
85266: LD_VAR 0 4
85270: PPUSH
85271: CALL_OW 122
// end ; if sold_defenders then
85275: LD_VAR 0 17
85279: IFFALSE 85339
// if i in sold_defenders then
85281: LD_VAR 0 4
85285: PUSH
85286: LD_VAR 0 17
85290: IN
85291: IFFALSE 85339
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
85293: LD_VAR 0 4
85297: PPUSH
85298: CALL_OW 314
85302: NOT
85303: PUSH
85304: LD_VAR 0 4
85308: PPUSH
85309: LD_VAR 0 13
85313: PPUSH
85314: CALL_OW 296
85318: PUSH
85319: LD_INT 30
85321: LESS
85322: AND
85323: IFFALSE 85339
// ComAttackUnit ( i , e ) ;
85325: LD_VAR 0 4
85329: PPUSH
85330: LD_VAR 0 13
85334: PPUSH
85335: CALL_OW 115
// end ; end ; end ;
85339: GO 85342
85341: POP
// if IsDead ( i ) then
85342: LD_VAR 0 4
85346: PPUSH
85347: CALL_OW 301
85351: IFFALSE 85369
// defenders := defenders diff i ;
85353: LD_ADDR_VAR 0 2
85357: PUSH
85358: LD_VAR 0 2
85362: PUSH
85363: LD_VAR 0 4
85367: DIFF
85368: ST_TO_ADDR
// end ;
85369: GO 84472
85371: POP
85372: POP
// until not enemy or not defenders or not mc_bases [ base ] ;
85373: LD_VAR 0 21
85377: NOT
85378: PUSH
85379: LD_VAR 0 2
85383: NOT
85384: OR
85385: PUSH
85386: LD_EXP 177
85390: PUSH
85391: LD_VAR 0 1
85395: ARRAY
85396: NOT
85397: OR
85398: IFFALSE 84376
// MC_Reset ( base , 18 ) ;
85400: LD_VAR 0 1
85404: PPUSH
85405: LD_INT 18
85407: PPUSH
85408: CALL 90070 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
85412: LD_ADDR_VAR 0 2
85416: PUSH
85417: LD_VAR 0 2
85421: PUSH
85422: LD_VAR 0 2
85426: PPUSH
85427: LD_INT 2
85429: PUSH
85430: LD_INT 25
85432: PUSH
85433: LD_INT 1
85435: PUSH
85436: EMPTY
85437: LIST
85438: LIST
85439: PUSH
85440: LD_INT 25
85442: PUSH
85443: LD_INT 5
85445: PUSH
85446: EMPTY
85447: LIST
85448: LIST
85449: PUSH
85450: LD_INT 25
85452: PUSH
85453: LD_INT 8
85455: PUSH
85456: EMPTY
85457: LIST
85458: LIST
85459: PUSH
85460: LD_INT 25
85462: PUSH
85463: LD_INT 9
85465: PUSH
85466: EMPTY
85467: LIST
85468: LIST
85469: PUSH
85470: EMPTY
85471: LIST
85472: LIST
85473: LIST
85474: LIST
85475: LIST
85476: PPUSH
85477: CALL_OW 72
85481: DIFF
85482: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
85483: LD_VAR 0 21
85487: NOT
85488: PUSH
85489: LD_VAR 0 2
85493: PPUSH
85494: LD_INT 21
85496: PUSH
85497: LD_INT 2
85499: PUSH
85500: EMPTY
85501: LIST
85502: LIST
85503: PPUSH
85504: CALL_OW 72
85508: AND
85509: IFFALSE 85847
// begin tmp := FilterByTag ( defenders , 19 ) ;
85511: LD_ADDR_VAR 0 11
85515: PUSH
85516: LD_VAR 0 2
85520: PPUSH
85521: LD_INT 19
85523: PPUSH
85524: CALL 53479 0 2
85528: ST_TO_ADDR
// if tmp then
85529: LD_VAR 0 11
85533: IFFALSE 85603
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
85535: LD_ADDR_VAR 0 11
85539: PUSH
85540: LD_VAR 0 11
85544: PPUSH
85545: LD_INT 25
85547: PUSH
85548: LD_INT 3
85550: PUSH
85551: EMPTY
85552: LIST
85553: LIST
85554: PPUSH
85555: CALL_OW 72
85559: ST_TO_ADDR
// if tmp then
85560: LD_VAR 0 11
85564: IFFALSE 85603
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
85566: LD_ADDR_EXP 189
85570: PUSH
85571: LD_EXP 189
85575: PPUSH
85576: LD_VAR 0 1
85580: PPUSH
85581: LD_EXP 189
85585: PUSH
85586: LD_VAR 0 1
85590: ARRAY
85591: PUSH
85592: LD_VAR 0 11
85596: UNION
85597: PPUSH
85598: CALL_OW 1
85602: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
85603: LD_VAR 0 1
85607: PPUSH
85608: LD_INT 19
85610: PPUSH
85611: CALL 90070 0 2
// repeat wait ( 0 0$1 ) ;
85615: LD_INT 35
85617: PPUSH
85618: CALL_OW 67
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
85622: LD_EXP 177
85626: PUSH
85627: LD_VAR 0 1
85631: ARRAY
85632: NOT
85633: PUSH
85634: LD_EXP 177
85638: PUSH
85639: LD_VAR 0 1
85643: ARRAY
85644: PUSH
85645: EMPTY
85646: EQUAL
85647: OR
85648: IFFALSE 85685
// begin for i in defenders do
85650: LD_ADDR_VAR 0 4
85654: PUSH
85655: LD_VAR 0 2
85659: PUSH
85660: FOR_IN
85661: IFFALSE 85674
// ComStop ( i ) ;
85663: LD_VAR 0 4
85667: PPUSH
85668: CALL_OW 141
85672: GO 85660
85674: POP
85675: POP
// defenders := [ ] ;
85676: LD_ADDR_VAR 0 2
85680: PUSH
85681: EMPTY
85682: ST_TO_ADDR
// exit ;
85683: GO 85911
// end ; for i in defenders do
85685: LD_ADDR_VAR 0 4
85689: PUSH
85690: LD_VAR 0 2
85694: PUSH
85695: FOR_IN
85696: IFFALSE 85785
// begin if not IsInArea ( i , mc_parking [ base ] ) then
85698: LD_VAR 0 4
85702: PPUSH
85703: LD_EXP 201
85707: PUSH
85708: LD_VAR 0 1
85712: ARRAY
85713: PPUSH
85714: CALL_OW 308
85718: NOT
85719: IFFALSE 85743
// ComMoveToArea ( i , mc_parking [ base ] ) else
85721: LD_VAR 0 4
85725: PPUSH
85726: LD_EXP 201
85730: PUSH
85731: LD_VAR 0 1
85735: ARRAY
85736: PPUSH
85737: CALL_OW 113
85741: GO 85783
// if GetControl ( i ) = control_manual then
85743: LD_VAR 0 4
85747: PPUSH
85748: CALL_OW 263
85752: PUSH
85753: LD_INT 1
85755: EQUAL
85756: IFFALSE 85783
// if IsDrivenBy ( i ) then
85758: LD_VAR 0 4
85762: PPUSH
85763: CALL_OW 311
85767: IFFALSE 85783
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
85769: LD_VAR 0 4
85773: PPUSH
85774: CALL_OW 311
85778: PPUSH
85779: CALL_OW 121
// end ;
85783: GO 85695
85785: POP
85786: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] or not mc_bases [ base ] ;
85787: LD_VAR 0 2
85791: PPUSH
85792: LD_INT 95
85794: PUSH
85795: LD_EXP 201
85799: PUSH
85800: LD_VAR 0 1
85804: ARRAY
85805: PUSH
85806: EMPTY
85807: LIST
85808: LIST
85809: PPUSH
85810: CALL_OW 72
85814: PUSH
85815: LD_VAR 0 2
85819: EQUAL
85820: PUSH
85821: LD_EXP 200
85825: PUSH
85826: LD_VAR 0 1
85830: ARRAY
85831: OR
85832: PUSH
85833: LD_EXP 177
85837: PUSH
85838: LD_VAR 0 1
85842: ARRAY
85843: NOT
85844: OR
85845: IFFALSE 85615
// end ; mc_defender := Replace ( mc_defender , base , UnitFilter ( defenders , [ f_type , unit_vehicle ] ) ) ;
85847: LD_ADDR_EXP 199
85851: PUSH
85852: LD_EXP 199
85856: PPUSH
85857: LD_VAR 0 1
85861: PPUSH
85862: LD_VAR 0 2
85866: PPUSH
85867: LD_INT 21
85869: PUSH
85870: LD_INT 2
85872: PUSH
85873: EMPTY
85874: LIST
85875: LIST
85876: PPUSH
85877: CALL_OW 72
85881: PPUSH
85882: CALL_OW 1
85886: ST_TO_ADDR
// MC_Reset ( base , 19 ) ;
85887: LD_VAR 0 1
85891: PPUSH
85892: LD_INT 19
85894: PPUSH
85895: CALL 90070 0 2
// MC_Reset ( base , 20 ) ;
85899: LD_VAR 0 1
85903: PPUSH
85904: LD_INT 20
85906: PPUSH
85907: CALL 90070 0 2
// end ; end_of_file
85911: LD_VAR 0 3
85915: RET
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use , mc_is_defending ; export function InitMacro ; var i ; begin
85916: LD_INT 0
85918: PPUSH
85919: PPUSH
// skirmish := false ;
85920: LD_ADDR_EXP 175
85924: PUSH
85925: LD_INT 0
85927: ST_TO_ADDR
// debug_mc := false ;
85928: LD_ADDR_EXP 176
85932: PUSH
85933: LD_INT 0
85935: ST_TO_ADDR
// mc_bases := [ ] ;
85936: LD_ADDR_EXP 177
85940: PUSH
85941: EMPTY
85942: ST_TO_ADDR
// mc_sides := [ ] ;
85943: LD_ADDR_EXP 203
85947: PUSH
85948: EMPTY
85949: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
85950: LD_ADDR_EXP 178
85954: PUSH
85955: EMPTY
85956: ST_TO_ADDR
// mc_building_repairs := [ ] ;
85957: LD_ADDR_EXP 179
85961: PUSH
85962: EMPTY
85963: ST_TO_ADDR
// mc_need_heal := [ ] ;
85964: LD_ADDR_EXP 180
85968: PUSH
85969: EMPTY
85970: ST_TO_ADDR
// mc_healers := [ ] ;
85971: LD_ADDR_EXP 181
85975: PUSH
85976: EMPTY
85977: ST_TO_ADDR
// mc_build_list := [ ] ;
85978: LD_ADDR_EXP 182
85982: PUSH
85983: EMPTY
85984: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
85985: LD_ADDR_EXP 209
85989: PUSH
85990: EMPTY
85991: ST_TO_ADDR
// mc_builders := [ ] ;
85992: LD_ADDR_EXP 183
85996: PUSH
85997: EMPTY
85998: ST_TO_ADDR
// mc_construct_list := [ ] ;
85999: LD_ADDR_EXP 184
86003: PUSH
86004: EMPTY
86005: ST_TO_ADDR
// mc_turret_list := [ ] ;
86006: LD_ADDR_EXP 185
86010: PUSH
86011: EMPTY
86012: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
86013: LD_ADDR_EXP 186
86017: PUSH
86018: EMPTY
86019: ST_TO_ADDR
// mc_miners := [ ] ;
86020: LD_ADDR_EXP 191
86024: PUSH
86025: EMPTY
86026: ST_TO_ADDR
// mc_mines := [ ] ;
86027: LD_ADDR_EXP 190
86031: PUSH
86032: EMPTY
86033: ST_TO_ADDR
// mc_minefields := [ ] ;
86034: LD_ADDR_EXP 192
86038: PUSH
86039: EMPTY
86040: ST_TO_ADDR
// mc_crates := [ ] ;
86041: LD_ADDR_EXP 193
86045: PUSH
86046: EMPTY
86047: ST_TO_ADDR
// mc_crates_collector := [ ] ;
86048: LD_ADDR_EXP 194
86052: PUSH
86053: EMPTY
86054: ST_TO_ADDR
// mc_crates_area := [ ] ;
86055: LD_ADDR_EXP 195
86059: PUSH
86060: EMPTY
86061: ST_TO_ADDR
// mc_vehicles := [ ] ;
86062: LD_ADDR_EXP 196
86066: PUSH
86067: EMPTY
86068: ST_TO_ADDR
// mc_attack := [ ] ;
86069: LD_ADDR_EXP 197
86073: PUSH
86074: EMPTY
86075: ST_TO_ADDR
// mc_produce := [ ] ;
86076: LD_ADDR_EXP 198
86080: PUSH
86081: EMPTY
86082: ST_TO_ADDR
// mc_defender := [ ] ;
86083: LD_ADDR_EXP 199
86087: PUSH
86088: EMPTY
86089: ST_TO_ADDR
// mc_parking := [ ] ;
86090: LD_ADDR_EXP 201
86094: PUSH
86095: EMPTY
86096: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
86097: LD_ADDR_EXP 187
86101: PUSH
86102: EMPTY
86103: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
86104: LD_ADDR_EXP 189
86108: PUSH
86109: EMPTY
86110: ST_TO_ADDR
// mc_scan := [ ] ;
86111: LD_ADDR_EXP 200
86115: PUSH
86116: EMPTY
86117: ST_TO_ADDR
// mc_scan_area := [ ] ;
86118: LD_ADDR_EXP 202
86122: PUSH
86123: EMPTY
86124: ST_TO_ADDR
// mc_tech := [ ] ;
86125: LD_ADDR_EXP 204
86129: PUSH
86130: EMPTY
86131: ST_TO_ADDR
// mc_class := [ ] ;
86132: LD_ADDR_EXP 218
86136: PUSH
86137: EMPTY
86138: ST_TO_ADDR
// mc_class_case_use := [ ] ;
86139: LD_ADDR_EXP 219
86143: PUSH
86144: EMPTY
86145: ST_TO_ADDR
// mc_is_defending := [ ] ;
86146: LD_ADDR_EXP 220
86150: PUSH
86151: EMPTY
86152: ST_TO_ADDR
// end ;
86153: LD_VAR 0 1
86157: RET
// export function MC_Kill ( base ) ; begin
86158: LD_INT 0
86160: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
86161: LD_ADDR_EXP 177
86165: PUSH
86166: LD_EXP 177
86170: PPUSH
86171: LD_VAR 0 1
86175: PPUSH
86176: EMPTY
86177: PPUSH
86178: CALL_OW 1
86182: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
86183: LD_ADDR_EXP 178
86187: PUSH
86188: LD_EXP 178
86192: PPUSH
86193: LD_VAR 0 1
86197: PPUSH
86198: EMPTY
86199: PPUSH
86200: CALL_OW 1
86204: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
86205: LD_ADDR_EXP 179
86209: PUSH
86210: LD_EXP 179
86214: PPUSH
86215: LD_VAR 0 1
86219: PPUSH
86220: EMPTY
86221: PPUSH
86222: CALL_OW 1
86226: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
86227: LD_ADDR_EXP 180
86231: PUSH
86232: LD_EXP 180
86236: PPUSH
86237: LD_VAR 0 1
86241: PPUSH
86242: EMPTY
86243: PPUSH
86244: CALL_OW 1
86248: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
86249: LD_ADDR_EXP 181
86253: PUSH
86254: LD_EXP 181
86258: PPUSH
86259: LD_VAR 0 1
86263: PPUSH
86264: EMPTY
86265: PPUSH
86266: CALL_OW 1
86270: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
86271: LD_ADDR_EXP 182
86275: PUSH
86276: LD_EXP 182
86280: PPUSH
86281: LD_VAR 0 1
86285: PPUSH
86286: EMPTY
86287: PPUSH
86288: CALL_OW 1
86292: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
86293: LD_ADDR_EXP 183
86297: PUSH
86298: LD_EXP 183
86302: PPUSH
86303: LD_VAR 0 1
86307: PPUSH
86308: EMPTY
86309: PPUSH
86310: CALL_OW 1
86314: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
86315: LD_ADDR_EXP 184
86319: PUSH
86320: LD_EXP 184
86324: PPUSH
86325: LD_VAR 0 1
86329: PPUSH
86330: EMPTY
86331: PPUSH
86332: CALL_OW 1
86336: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
86337: LD_ADDR_EXP 185
86341: PUSH
86342: LD_EXP 185
86346: PPUSH
86347: LD_VAR 0 1
86351: PPUSH
86352: EMPTY
86353: PPUSH
86354: CALL_OW 1
86358: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
86359: LD_ADDR_EXP 186
86363: PUSH
86364: LD_EXP 186
86368: PPUSH
86369: LD_VAR 0 1
86373: PPUSH
86374: EMPTY
86375: PPUSH
86376: CALL_OW 1
86380: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
86381: LD_ADDR_EXP 187
86385: PUSH
86386: LD_EXP 187
86390: PPUSH
86391: LD_VAR 0 1
86395: PPUSH
86396: EMPTY
86397: PPUSH
86398: CALL_OW 1
86402: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
86403: LD_ADDR_EXP 188
86407: PUSH
86408: LD_EXP 188
86412: PPUSH
86413: LD_VAR 0 1
86417: PPUSH
86418: LD_INT 0
86420: PPUSH
86421: CALL_OW 1
86425: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
86426: LD_ADDR_EXP 189
86430: PUSH
86431: LD_EXP 189
86435: PPUSH
86436: LD_VAR 0 1
86440: PPUSH
86441: EMPTY
86442: PPUSH
86443: CALL_OW 1
86447: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
86448: LD_ADDR_EXP 190
86452: PUSH
86453: LD_EXP 190
86457: PPUSH
86458: LD_VAR 0 1
86462: PPUSH
86463: EMPTY
86464: PPUSH
86465: CALL_OW 1
86469: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
86470: LD_ADDR_EXP 191
86474: PUSH
86475: LD_EXP 191
86479: PPUSH
86480: LD_VAR 0 1
86484: PPUSH
86485: EMPTY
86486: PPUSH
86487: CALL_OW 1
86491: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
86492: LD_ADDR_EXP 192
86496: PUSH
86497: LD_EXP 192
86501: PPUSH
86502: LD_VAR 0 1
86506: PPUSH
86507: EMPTY
86508: PPUSH
86509: CALL_OW 1
86513: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
86514: LD_ADDR_EXP 193
86518: PUSH
86519: LD_EXP 193
86523: PPUSH
86524: LD_VAR 0 1
86528: PPUSH
86529: EMPTY
86530: PPUSH
86531: CALL_OW 1
86535: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
86536: LD_ADDR_EXP 194
86540: PUSH
86541: LD_EXP 194
86545: PPUSH
86546: LD_VAR 0 1
86550: PPUSH
86551: EMPTY
86552: PPUSH
86553: CALL_OW 1
86557: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
86558: LD_ADDR_EXP 195
86562: PUSH
86563: LD_EXP 195
86567: PPUSH
86568: LD_VAR 0 1
86572: PPUSH
86573: EMPTY
86574: PPUSH
86575: CALL_OW 1
86579: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
86580: LD_ADDR_EXP 196
86584: PUSH
86585: LD_EXP 196
86589: PPUSH
86590: LD_VAR 0 1
86594: PPUSH
86595: EMPTY
86596: PPUSH
86597: CALL_OW 1
86601: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
86602: LD_ADDR_EXP 197
86606: PUSH
86607: LD_EXP 197
86611: PPUSH
86612: LD_VAR 0 1
86616: PPUSH
86617: EMPTY
86618: PPUSH
86619: CALL_OW 1
86623: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
86624: LD_ADDR_EXP 198
86628: PUSH
86629: LD_EXP 198
86633: PPUSH
86634: LD_VAR 0 1
86638: PPUSH
86639: EMPTY
86640: PPUSH
86641: CALL_OW 1
86645: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
86646: LD_ADDR_EXP 199
86650: PUSH
86651: LD_EXP 199
86655: PPUSH
86656: LD_VAR 0 1
86660: PPUSH
86661: EMPTY
86662: PPUSH
86663: CALL_OW 1
86667: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
86668: LD_ADDR_EXP 200
86672: PUSH
86673: LD_EXP 200
86677: PPUSH
86678: LD_VAR 0 1
86682: PPUSH
86683: EMPTY
86684: PPUSH
86685: CALL_OW 1
86689: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
86690: LD_ADDR_EXP 201
86694: PUSH
86695: LD_EXP 201
86699: PPUSH
86700: LD_VAR 0 1
86704: PPUSH
86705: EMPTY
86706: PPUSH
86707: CALL_OW 1
86711: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
86712: LD_ADDR_EXP 202
86716: PUSH
86717: LD_EXP 202
86721: PPUSH
86722: LD_VAR 0 1
86726: PPUSH
86727: EMPTY
86728: PPUSH
86729: CALL_OW 1
86733: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
86734: LD_ADDR_EXP 204
86738: PUSH
86739: LD_EXP 204
86743: PPUSH
86744: LD_VAR 0 1
86748: PPUSH
86749: EMPTY
86750: PPUSH
86751: CALL_OW 1
86755: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
86756: LD_ADDR_EXP 206
86760: PUSH
86761: LD_EXP 206
86765: PPUSH
86766: LD_VAR 0 1
86770: PPUSH
86771: EMPTY
86772: PPUSH
86773: CALL_OW 1
86777: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
86778: LD_ADDR_EXP 207
86782: PUSH
86783: LD_EXP 207
86787: PPUSH
86788: LD_VAR 0 1
86792: PPUSH
86793: EMPTY
86794: PPUSH
86795: CALL_OW 1
86799: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
86800: LD_ADDR_EXP 208
86804: PUSH
86805: LD_EXP 208
86809: PPUSH
86810: LD_VAR 0 1
86814: PPUSH
86815: EMPTY
86816: PPUSH
86817: CALL_OW 1
86821: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
86822: LD_ADDR_EXP 209
86826: PUSH
86827: LD_EXP 209
86831: PPUSH
86832: LD_VAR 0 1
86836: PPUSH
86837: EMPTY
86838: PPUSH
86839: CALL_OW 1
86843: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
86844: LD_ADDR_EXP 210
86848: PUSH
86849: LD_EXP 210
86853: PPUSH
86854: LD_VAR 0 1
86858: PPUSH
86859: EMPTY
86860: PPUSH
86861: CALL_OW 1
86865: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
86866: LD_ADDR_EXP 211
86870: PUSH
86871: LD_EXP 211
86875: PPUSH
86876: LD_VAR 0 1
86880: PPUSH
86881: EMPTY
86882: PPUSH
86883: CALL_OW 1
86887: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
86888: LD_ADDR_EXP 212
86892: PUSH
86893: LD_EXP 212
86897: PPUSH
86898: LD_VAR 0 1
86902: PPUSH
86903: EMPTY
86904: PPUSH
86905: CALL_OW 1
86909: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
86910: LD_ADDR_EXP 213
86914: PUSH
86915: LD_EXP 213
86919: PPUSH
86920: LD_VAR 0 1
86924: PPUSH
86925: EMPTY
86926: PPUSH
86927: CALL_OW 1
86931: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
86932: LD_ADDR_EXP 214
86936: PUSH
86937: LD_EXP 214
86941: PPUSH
86942: LD_VAR 0 1
86946: PPUSH
86947: EMPTY
86948: PPUSH
86949: CALL_OW 1
86953: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
86954: LD_ADDR_EXP 215
86958: PUSH
86959: LD_EXP 215
86963: PPUSH
86964: LD_VAR 0 1
86968: PPUSH
86969: EMPTY
86970: PPUSH
86971: CALL_OW 1
86975: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
86976: LD_ADDR_EXP 216
86980: PUSH
86981: LD_EXP 216
86985: PPUSH
86986: LD_VAR 0 1
86990: PPUSH
86991: EMPTY
86992: PPUSH
86993: CALL_OW 1
86997: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
86998: LD_ADDR_EXP 217
87002: PUSH
87003: LD_EXP 217
87007: PPUSH
87008: LD_VAR 0 1
87012: PPUSH
87013: EMPTY
87014: PPUSH
87015: CALL_OW 1
87019: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
87020: LD_ADDR_EXP 218
87024: PUSH
87025: LD_EXP 218
87029: PPUSH
87030: LD_VAR 0 1
87034: PPUSH
87035: EMPTY
87036: PPUSH
87037: CALL_OW 1
87041: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
87042: LD_ADDR_EXP 219
87046: PUSH
87047: LD_EXP 219
87051: PPUSH
87052: LD_VAR 0 1
87056: PPUSH
87057: LD_INT 0
87059: PPUSH
87060: CALL_OW 1
87064: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
87065: LD_ADDR_EXP 220
87069: PUSH
87070: LD_EXP 220
87074: PPUSH
87075: LD_VAR 0 1
87079: PPUSH
87080: LD_INT 0
87082: PPUSH
87083: CALL_OW 1
87087: ST_TO_ADDR
// end ;
87088: LD_VAR 0 2
87092: RET
// export function MC_Add ( side , units ) ; var base ; begin
87093: LD_INT 0
87095: PPUSH
87096: PPUSH
// base := mc_bases + 1 ;
87097: LD_ADDR_VAR 0 4
87101: PUSH
87102: LD_EXP 177
87106: PUSH
87107: LD_INT 1
87109: PLUS
87110: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
87111: LD_ADDR_EXP 203
87115: PUSH
87116: LD_EXP 203
87120: PPUSH
87121: LD_VAR 0 4
87125: PPUSH
87126: LD_VAR 0 1
87130: PPUSH
87131: CALL_OW 1
87135: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
87136: LD_ADDR_EXP 177
87140: PUSH
87141: LD_EXP 177
87145: PPUSH
87146: LD_VAR 0 4
87150: PPUSH
87151: LD_VAR 0 2
87155: PPUSH
87156: CALL_OW 1
87160: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
87161: LD_ADDR_EXP 178
87165: PUSH
87166: LD_EXP 178
87170: PPUSH
87171: LD_VAR 0 4
87175: PPUSH
87176: EMPTY
87177: PPUSH
87178: CALL_OW 1
87182: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
87183: LD_ADDR_EXP 179
87187: PUSH
87188: LD_EXP 179
87192: PPUSH
87193: LD_VAR 0 4
87197: PPUSH
87198: EMPTY
87199: PPUSH
87200: CALL_OW 1
87204: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
87205: LD_ADDR_EXP 180
87209: PUSH
87210: LD_EXP 180
87214: PPUSH
87215: LD_VAR 0 4
87219: PPUSH
87220: EMPTY
87221: PPUSH
87222: CALL_OW 1
87226: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
87227: LD_ADDR_EXP 181
87231: PUSH
87232: LD_EXP 181
87236: PPUSH
87237: LD_VAR 0 4
87241: PPUSH
87242: EMPTY
87243: PPUSH
87244: CALL_OW 1
87248: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
87249: LD_ADDR_EXP 182
87253: PUSH
87254: LD_EXP 182
87258: PPUSH
87259: LD_VAR 0 4
87263: PPUSH
87264: EMPTY
87265: PPUSH
87266: CALL_OW 1
87270: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
87271: LD_ADDR_EXP 183
87275: PUSH
87276: LD_EXP 183
87280: PPUSH
87281: LD_VAR 0 4
87285: PPUSH
87286: EMPTY
87287: PPUSH
87288: CALL_OW 1
87292: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
87293: LD_ADDR_EXP 184
87297: PUSH
87298: LD_EXP 184
87302: PPUSH
87303: LD_VAR 0 4
87307: PPUSH
87308: EMPTY
87309: PPUSH
87310: CALL_OW 1
87314: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
87315: LD_ADDR_EXP 185
87319: PUSH
87320: LD_EXP 185
87324: PPUSH
87325: LD_VAR 0 4
87329: PPUSH
87330: EMPTY
87331: PPUSH
87332: CALL_OW 1
87336: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
87337: LD_ADDR_EXP 186
87341: PUSH
87342: LD_EXP 186
87346: PPUSH
87347: LD_VAR 0 4
87351: PPUSH
87352: EMPTY
87353: PPUSH
87354: CALL_OW 1
87358: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
87359: LD_ADDR_EXP 187
87363: PUSH
87364: LD_EXP 187
87368: PPUSH
87369: LD_VAR 0 4
87373: PPUSH
87374: EMPTY
87375: PPUSH
87376: CALL_OW 1
87380: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
87381: LD_ADDR_EXP 188
87385: PUSH
87386: LD_EXP 188
87390: PPUSH
87391: LD_VAR 0 4
87395: PPUSH
87396: LD_INT 0
87398: PPUSH
87399: CALL_OW 1
87403: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
87404: LD_ADDR_EXP 189
87408: PUSH
87409: LD_EXP 189
87413: PPUSH
87414: LD_VAR 0 4
87418: PPUSH
87419: EMPTY
87420: PPUSH
87421: CALL_OW 1
87425: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
87426: LD_ADDR_EXP 190
87430: PUSH
87431: LD_EXP 190
87435: PPUSH
87436: LD_VAR 0 4
87440: PPUSH
87441: EMPTY
87442: PPUSH
87443: CALL_OW 1
87447: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
87448: LD_ADDR_EXP 191
87452: PUSH
87453: LD_EXP 191
87457: PPUSH
87458: LD_VAR 0 4
87462: PPUSH
87463: EMPTY
87464: PPUSH
87465: CALL_OW 1
87469: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
87470: LD_ADDR_EXP 192
87474: PUSH
87475: LD_EXP 192
87479: PPUSH
87480: LD_VAR 0 4
87484: PPUSH
87485: EMPTY
87486: PPUSH
87487: CALL_OW 1
87491: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
87492: LD_ADDR_EXP 193
87496: PUSH
87497: LD_EXP 193
87501: PPUSH
87502: LD_VAR 0 4
87506: PPUSH
87507: EMPTY
87508: PPUSH
87509: CALL_OW 1
87513: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
87514: LD_ADDR_EXP 194
87518: PUSH
87519: LD_EXP 194
87523: PPUSH
87524: LD_VAR 0 4
87528: PPUSH
87529: EMPTY
87530: PPUSH
87531: CALL_OW 1
87535: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
87536: LD_ADDR_EXP 195
87540: PUSH
87541: LD_EXP 195
87545: PPUSH
87546: LD_VAR 0 4
87550: PPUSH
87551: EMPTY
87552: PPUSH
87553: CALL_OW 1
87557: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
87558: LD_ADDR_EXP 196
87562: PUSH
87563: LD_EXP 196
87567: PPUSH
87568: LD_VAR 0 4
87572: PPUSH
87573: EMPTY
87574: PPUSH
87575: CALL_OW 1
87579: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
87580: LD_ADDR_EXP 197
87584: PUSH
87585: LD_EXP 197
87589: PPUSH
87590: LD_VAR 0 4
87594: PPUSH
87595: EMPTY
87596: PPUSH
87597: CALL_OW 1
87601: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
87602: LD_ADDR_EXP 198
87606: PUSH
87607: LD_EXP 198
87611: PPUSH
87612: LD_VAR 0 4
87616: PPUSH
87617: EMPTY
87618: PPUSH
87619: CALL_OW 1
87623: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
87624: LD_ADDR_EXP 199
87628: PUSH
87629: LD_EXP 199
87633: PPUSH
87634: LD_VAR 0 4
87638: PPUSH
87639: EMPTY
87640: PPUSH
87641: CALL_OW 1
87645: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
87646: LD_ADDR_EXP 200
87650: PUSH
87651: LD_EXP 200
87655: PPUSH
87656: LD_VAR 0 4
87660: PPUSH
87661: EMPTY
87662: PPUSH
87663: CALL_OW 1
87667: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
87668: LD_ADDR_EXP 201
87672: PUSH
87673: LD_EXP 201
87677: PPUSH
87678: LD_VAR 0 4
87682: PPUSH
87683: EMPTY
87684: PPUSH
87685: CALL_OW 1
87689: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
87690: LD_ADDR_EXP 202
87694: PUSH
87695: LD_EXP 202
87699: PPUSH
87700: LD_VAR 0 4
87704: PPUSH
87705: EMPTY
87706: PPUSH
87707: CALL_OW 1
87711: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
87712: LD_ADDR_EXP 204
87716: PUSH
87717: LD_EXP 204
87721: PPUSH
87722: LD_VAR 0 4
87726: PPUSH
87727: EMPTY
87728: PPUSH
87729: CALL_OW 1
87733: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
87734: LD_ADDR_EXP 206
87738: PUSH
87739: LD_EXP 206
87743: PPUSH
87744: LD_VAR 0 4
87748: PPUSH
87749: EMPTY
87750: PPUSH
87751: CALL_OW 1
87755: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
87756: LD_ADDR_EXP 207
87760: PUSH
87761: LD_EXP 207
87765: PPUSH
87766: LD_VAR 0 4
87770: PPUSH
87771: EMPTY
87772: PPUSH
87773: CALL_OW 1
87777: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
87778: LD_ADDR_EXP 208
87782: PUSH
87783: LD_EXP 208
87787: PPUSH
87788: LD_VAR 0 4
87792: PPUSH
87793: EMPTY
87794: PPUSH
87795: CALL_OW 1
87799: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
87800: LD_ADDR_EXP 209
87804: PUSH
87805: LD_EXP 209
87809: PPUSH
87810: LD_VAR 0 4
87814: PPUSH
87815: EMPTY
87816: PPUSH
87817: CALL_OW 1
87821: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
87822: LD_ADDR_EXP 210
87826: PUSH
87827: LD_EXP 210
87831: PPUSH
87832: LD_VAR 0 4
87836: PPUSH
87837: EMPTY
87838: PPUSH
87839: CALL_OW 1
87843: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
87844: LD_ADDR_EXP 211
87848: PUSH
87849: LD_EXP 211
87853: PPUSH
87854: LD_VAR 0 4
87858: PPUSH
87859: EMPTY
87860: PPUSH
87861: CALL_OW 1
87865: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
87866: LD_ADDR_EXP 212
87870: PUSH
87871: LD_EXP 212
87875: PPUSH
87876: LD_VAR 0 4
87880: PPUSH
87881: EMPTY
87882: PPUSH
87883: CALL_OW 1
87887: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
87888: LD_ADDR_EXP 213
87892: PUSH
87893: LD_EXP 213
87897: PPUSH
87898: LD_VAR 0 4
87902: PPUSH
87903: EMPTY
87904: PPUSH
87905: CALL_OW 1
87909: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
87910: LD_ADDR_EXP 214
87914: PUSH
87915: LD_EXP 214
87919: PPUSH
87920: LD_VAR 0 4
87924: PPUSH
87925: EMPTY
87926: PPUSH
87927: CALL_OW 1
87931: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
87932: LD_ADDR_EXP 215
87936: PUSH
87937: LD_EXP 215
87941: PPUSH
87942: LD_VAR 0 4
87946: PPUSH
87947: EMPTY
87948: PPUSH
87949: CALL_OW 1
87953: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
87954: LD_ADDR_EXP 216
87958: PUSH
87959: LD_EXP 216
87963: PPUSH
87964: LD_VAR 0 4
87968: PPUSH
87969: EMPTY
87970: PPUSH
87971: CALL_OW 1
87975: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
87976: LD_ADDR_EXP 217
87980: PUSH
87981: LD_EXP 217
87985: PPUSH
87986: LD_VAR 0 4
87990: PPUSH
87991: EMPTY
87992: PPUSH
87993: CALL_OW 1
87997: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
87998: LD_ADDR_EXP 218
88002: PUSH
88003: LD_EXP 218
88007: PPUSH
88008: LD_VAR 0 4
88012: PPUSH
88013: EMPTY
88014: PPUSH
88015: CALL_OW 1
88019: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
88020: LD_ADDR_EXP 219
88024: PUSH
88025: LD_EXP 219
88029: PPUSH
88030: LD_VAR 0 4
88034: PPUSH
88035: LD_INT 0
88037: PPUSH
88038: CALL_OW 1
88042: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
88043: LD_ADDR_EXP 220
88047: PUSH
88048: LD_EXP 220
88052: PPUSH
88053: LD_VAR 0 4
88057: PPUSH
88058: LD_INT 0
88060: PPUSH
88061: CALL_OW 1
88065: ST_TO_ADDR
// result := base ;
88066: LD_ADDR_VAR 0 3
88070: PUSH
88071: LD_VAR 0 4
88075: ST_TO_ADDR
// end ;
88076: LD_VAR 0 3
88080: RET
// export function MC_Start ( ) ; var i ; begin
88081: LD_INT 0
88083: PPUSH
88084: PPUSH
// for i = 1 to mc_bases do
88085: LD_ADDR_VAR 0 2
88089: PUSH
88090: DOUBLE
88091: LD_INT 1
88093: DEC
88094: ST_TO_ADDR
88095: LD_EXP 177
88099: PUSH
88100: FOR_TO
88101: IFFALSE 89201
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
88103: LD_ADDR_EXP 177
88107: PUSH
88108: LD_EXP 177
88112: PPUSH
88113: LD_VAR 0 2
88117: PPUSH
88118: LD_EXP 177
88122: PUSH
88123: LD_VAR 0 2
88127: ARRAY
88128: PUSH
88129: LD_INT 0
88131: DIFF
88132: PPUSH
88133: CALL_OW 1
88137: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
88138: LD_ADDR_EXP 178
88142: PUSH
88143: LD_EXP 178
88147: PPUSH
88148: LD_VAR 0 2
88152: PPUSH
88153: EMPTY
88154: PPUSH
88155: CALL_OW 1
88159: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
88160: LD_ADDR_EXP 179
88164: PUSH
88165: LD_EXP 179
88169: PPUSH
88170: LD_VAR 0 2
88174: PPUSH
88175: EMPTY
88176: PPUSH
88177: CALL_OW 1
88181: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
88182: LD_ADDR_EXP 180
88186: PUSH
88187: LD_EXP 180
88191: PPUSH
88192: LD_VAR 0 2
88196: PPUSH
88197: EMPTY
88198: PPUSH
88199: CALL_OW 1
88203: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
88204: LD_ADDR_EXP 181
88208: PUSH
88209: LD_EXP 181
88213: PPUSH
88214: LD_VAR 0 2
88218: PPUSH
88219: EMPTY
88220: PUSH
88221: EMPTY
88222: PUSH
88223: EMPTY
88224: LIST
88225: LIST
88226: PPUSH
88227: CALL_OW 1
88231: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
88232: LD_ADDR_EXP 182
88236: PUSH
88237: LD_EXP 182
88241: PPUSH
88242: LD_VAR 0 2
88246: PPUSH
88247: EMPTY
88248: PPUSH
88249: CALL_OW 1
88253: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
88254: LD_ADDR_EXP 209
88258: PUSH
88259: LD_EXP 209
88263: PPUSH
88264: LD_VAR 0 2
88268: PPUSH
88269: EMPTY
88270: PPUSH
88271: CALL_OW 1
88275: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
88276: LD_ADDR_EXP 183
88280: PUSH
88281: LD_EXP 183
88285: PPUSH
88286: LD_VAR 0 2
88290: PPUSH
88291: EMPTY
88292: PPUSH
88293: CALL_OW 1
88297: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
88298: LD_ADDR_EXP 184
88302: PUSH
88303: LD_EXP 184
88307: PPUSH
88308: LD_VAR 0 2
88312: PPUSH
88313: EMPTY
88314: PPUSH
88315: CALL_OW 1
88319: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
88320: LD_ADDR_EXP 185
88324: PUSH
88325: LD_EXP 185
88329: PPUSH
88330: LD_VAR 0 2
88334: PPUSH
88335: LD_EXP 177
88339: PUSH
88340: LD_VAR 0 2
88344: ARRAY
88345: PPUSH
88346: LD_INT 2
88348: PUSH
88349: LD_INT 30
88351: PUSH
88352: LD_INT 32
88354: PUSH
88355: EMPTY
88356: LIST
88357: LIST
88358: PUSH
88359: LD_INT 30
88361: PUSH
88362: LD_INT 33
88364: PUSH
88365: EMPTY
88366: LIST
88367: LIST
88368: PUSH
88369: EMPTY
88370: LIST
88371: LIST
88372: LIST
88373: PPUSH
88374: CALL_OW 72
88378: PPUSH
88379: CALL_OW 1
88383: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
88384: LD_ADDR_EXP 186
88388: PUSH
88389: LD_EXP 186
88393: PPUSH
88394: LD_VAR 0 2
88398: PPUSH
88399: LD_EXP 177
88403: PUSH
88404: LD_VAR 0 2
88408: ARRAY
88409: PPUSH
88410: LD_INT 2
88412: PUSH
88413: LD_INT 30
88415: PUSH
88416: LD_INT 32
88418: PUSH
88419: EMPTY
88420: LIST
88421: LIST
88422: PUSH
88423: LD_INT 30
88425: PUSH
88426: LD_INT 31
88428: PUSH
88429: EMPTY
88430: LIST
88431: LIST
88432: PUSH
88433: EMPTY
88434: LIST
88435: LIST
88436: LIST
88437: PUSH
88438: LD_INT 58
88440: PUSH
88441: EMPTY
88442: LIST
88443: PUSH
88444: EMPTY
88445: LIST
88446: LIST
88447: PPUSH
88448: CALL_OW 72
88452: PPUSH
88453: CALL_OW 1
88457: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
88458: LD_ADDR_EXP 187
88462: PUSH
88463: LD_EXP 187
88467: PPUSH
88468: LD_VAR 0 2
88472: PPUSH
88473: EMPTY
88474: PPUSH
88475: CALL_OW 1
88479: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
88480: LD_ADDR_EXP 191
88484: PUSH
88485: LD_EXP 191
88489: PPUSH
88490: LD_VAR 0 2
88494: PPUSH
88495: EMPTY
88496: PPUSH
88497: CALL_OW 1
88501: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
88502: LD_ADDR_EXP 190
88506: PUSH
88507: LD_EXP 190
88511: PPUSH
88512: LD_VAR 0 2
88516: PPUSH
88517: EMPTY
88518: PPUSH
88519: CALL_OW 1
88523: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
88524: LD_ADDR_EXP 192
88528: PUSH
88529: LD_EXP 192
88533: PPUSH
88534: LD_VAR 0 2
88538: PPUSH
88539: EMPTY
88540: PPUSH
88541: CALL_OW 1
88545: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
88546: LD_ADDR_EXP 193
88550: PUSH
88551: LD_EXP 193
88555: PPUSH
88556: LD_VAR 0 2
88560: PPUSH
88561: EMPTY
88562: PPUSH
88563: CALL_OW 1
88567: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
88568: LD_ADDR_EXP 194
88572: PUSH
88573: LD_EXP 194
88577: PPUSH
88578: LD_VAR 0 2
88582: PPUSH
88583: EMPTY
88584: PPUSH
88585: CALL_OW 1
88589: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
88590: LD_ADDR_EXP 195
88594: PUSH
88595: LD_EXP 195
88599: PPUSH
88600: LD_VAR 0 2
88604: PPUSH
88605: EMPTY
88606: PPUSH
88607: CALL_OW 1
88611: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
88612: LD_ADDR_EXP 196
88616: PUSH
88617: LD_EXP 196
88621: PPUSH
88622: LD_VAR 0 2
88626: PPUSH
88627: EMPTY
88628: PPUSH
88629: CALL_OW 1
88633: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
88634: LD_ADDR_EXP 197
88638: PUSH
88639: LD_EXP 197
88643: PPUSH
88644: LD_VAR 0 2
88648: PPUSH
88649: EMPTY
88650: PPUSH
88651: CALL_OW 1
88655: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
88656: LD_ADDR_EXP 198
88660: PUSH
88661: LD_EXP 198
88665: PPUSH
88666: LD_VAR 0 2
88670: PPUSH
88671: EMPTY
88672: PPUSH
88673: CALL_OW 1
88677: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
88678: LD_ADDR_EXP 199
88682: PUSH
88683: LD_EXP 199
88687: PPUSH
88688: LD_VAR 0 2
88692: PPUSH
88693: EMPTY
88694: PPUSH
88695: CALL_OW 1
88699: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
88700: LD_ADDR_EXP 188
88704: PUSH
88705: LD_EXP 188
88709: PPUSH
88710: LD_VAR 0 2
88714: PPUSH
88715: LD_INT 0
88717: PPUSH
88718: CALL_OW 1
88722: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
88723: LD_ADDR_EXP 201
88727: PUSH
88728: LD_EXP 201
88732: PPUSH
88733: LD_VAR 0 2
88737: PPUSH
88738: LD_INT 0
88740: PPUSH
88741: CALL_OW 1
88745: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
88746: LD_ADDR_EXP 189
88750: PUSH
88751: LD_EXP 189
88755: PPUSH
88756: LD_VAR 0 2
88760: PPUSH
88761: EMPTY
88762: PPUSH
88763: CALL_OW 1
88767: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
88768: LD_ADDR_EXP 200
88772: PUSH
88773: LD_EXP 200
88777: PPUSH
88778: LD_VAR 0 2
88782: PPUSH
88783: LD_INT 0
88785: PPUSH
88786: CALL_OW 1
88790: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
88791: LD_ADDR_EXP 202
88795: PUSH
88796: LD_EXP 202
88800: PPUSH
88801: LD_VAR 0 2
88805: PPUSH
88806: EMPTY
88807: PPUSH
88808: CALL_OW 1
88812: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
88813: LD_ADDR_EXP 205
88817: PUSH
88818: LD_EXP 205
88822: PPUSH
88823: LD_VAR 0 2
88827: PPUSH
88828: LD_INT 0
88830: PPUSH
88831: CALL_OW 1
88835: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
88836: LD_ADDR_EXP 206
88840: PUSH
88841: LD_EXP 206
88845: PPUSH
88846: LD_VAR 0 2
88850: PPUSH
88851: EMPTY
88852: PPUSH
88853: CALL_OW 1
88857: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
88858: LD_ADDR_EXP 207
88862: PUSH
88863: LD_EXP 207
88867: PPUSH
88868: LD_VAR 0 2
88872: PPUSH
88873: EMPTY
88874: PPUSH
88875: CALL_OW 1
88879: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
88880: LD_ADDR_EXP 208
88884: PUSH
88885: LD_EXP 208
88889: PPUSH
88890: LD_VAR 0 2
88894: PPUSH
88895: EMPTY
88896: PPUSH
88897: CALL_OW 1
88901: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
88902: LD_ADDR_EXP 210
88906: PUSH
88907: LD_EXP 210
88911: PPUSH
88912: LD_VAR 0 2
88916: PPUSH
88917: LD_EXP 177
88921: PUSH
88922: LD_VAR 0 2
88926: ARRAY
88927: PPUSH
88928: LD_INT 2
88930: PUSH
88931: LD_INT 30
88933: PUSH
88934: LD_INT 6
88936: PUSH
88937: EMPTY
88938: LIST
88939: LIST
88940: PUSH
88941: LD_INT 30
88943: PUSH
88944: LD_INT 7
88946: PUSH
88947: EMPTY
88948: LIST
88949: LIST
88950: PUSH
88951: LD_INT 30
88953: PUSH
88954: LD_INT 8
88956: PUSH
88957: EMPTY
88958: LIST
88959: LIST
88960: PUSH
88961: EMPTY
88962: LIST
88963: LIST
88964: LIST
88965: LIST
88966: PPUSH
88967: CALL_OW 72
88971: PPUSH
88972: CALL_OW 1
88976: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
88977: LD_ADDR_EXP 211
88981: PUSH
88982: LD_EXP 211
88986: PPUSH
88987: LD_VAR 0 2
88991: PPUSH
88992: EMPTY
88993: PPUSH
88994: CALL_OW 1
88998: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
88999: LD_ADDR_EXP 212
89003: PUSH
89004: LD_EXP 212
89008: PPUSH
89009: LD_VAR 0 2
89013: PPUSH
89014: EMPTY
89015: PPUSH
89016: CALL_OW 1
89020: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
89021: LD_ADDR_EXP 213
89025: PUSH
89026: LD_EXP 213
89030: PPUSH
89031: LD_VAR 0 2
89035: PPUSH
89036: EMPTY
89037: PPUSH
89038: CALL_OW 1
89042: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
89043: LD_ADDR_EXP 214
89047: PUSH
89048: LD_EXP 214
89052: PPUSH
89053: LD_VAR 0 2
89057: PPUSH
89058: EMPTY
89059: PPUSH
89060: CALL_OW 1
89064: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
89065: LD_ADDR_EXP 215
89069: PUSH
89070: LD_EXP 215
89074: PPUSH
89075: LD_VAR 0 2
89079: PPUSH
89080: EMPTY
89081: PPUSH
89082: CALL_OW 1
89086: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
89087: LD_ADDR_EXP 216
89091: PUSH
89092: LD_EXP 216
89096: PPUSH
89097: LD_VAR 0 2
89101: PPUSH
89102: EMPTY
89103: PPUSH
89104: CALL_OW 1
89108: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
89109: LD_ADDR_EXP 217
89113: PUSH
89114: LD_EXP 217
89118: PPUSH
89119: LD_VAR 0 2
89123: PPUSH
89124: EMPTY
89125: PPUSH
89126: CALL_OW 1
89130: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
89131: LD_ADDR_EXP 218
89135: PUSH
89136: LD_EXP 218
89140: PPUSH
89141: LD_VAR 0 2
89145: PPUSH
89146: EMPTY
89147: PPUSH
89148: CALL_OW 1
89152: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
89153: LD_ADDR_EXP 219
89157: PUSH
89158: LD_EXP 219
89162: PPUSH
89163: LD_VAR 0 2
89167: PPUSH
89168: LD_INT 0
89170: PPUSH
89171: CALL_OW 1
89175: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , i , false ) ;
89176: LD_ADDR_EXP 220
89180: PUSH
89181: LD_EXP 220
89185: PPUSH
89186: LD_VAR 0 2
89190: PPUSH
89191: LD_INT 0
89193: PPUSH
89194: CALL_OW 1
89198: ST_TO_ADDR
// end ;
89199: GO 88100
89201: POP
89202: POP
// MC_InitSides ( ) ;
89203: CALL 89489 0 0
// MC_InitResearch ( ) ;
89207: CALL 89228 0 0
// CustomInitMacro ( ) ;
89211: CALL 350 0 0
// skirmish := true ;
89215: LD_ADDR_EXP 175
89219: PUSH
89220: LD_INT 1
89222: ST_TO_ADDR
// end ;
89223: LD_VAR 0 1
89227: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
89228: LD_INT 0
89230: PPUSH
89231: PPUSH
89232: PPUSH
89233: PPUSH
89234: PPUSH
89235: PPUSH
// if not mc_bases then
89236: LD_EXP 177
89240: NOT
89241: IFFALSE 89245
// exit ;
89243: GO 89484
// for i = 1 to 8 do
89245: LD_ADDR_VAR 0 2
89249: PUSH
89250: DOUBLE
89251: LD_INT 1
89253: DEC
89254: ST_TO_ADDR
89255: LD_INT 8
89257: PUSH
89258: FOR_TO
89259: IFFALSE 89285
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
89261: LD_ADDR_EXP 204
89265: PUSH
89266: LD_EXP 204
89270: PPUSH
89271: LD_VAR 0 2
89275: PPUSH
89276: EMPTY
89277: PPUSH
89278: CALL_OW 1
89282: ST_TO_ADDR
89283: GO 89258
89285: POP
89286: POP
// tmp := [ ] ;
89287: LD_ADDR_VAR 0 5
89291: PUSH
89292: EMPTY
89293: ST_TO_ADDR
// for i = 1 to mc_sides do
89294: LD_ADDR_VAR 0 2
89298: PUSH
89299: DOUBLE
89300: LD_INT 1
89302: DEC
89303: ST_TO_ADDR
89304: LD_EXP 203
89308: PUSH
89309: FOR_TO
89310: IFFALSE 89368
// if not mc_sides [ i ] in tmp then
89312: LD_EXP 203
89316: PUSH
89317: LD_VAR 0 2
89321: ARRAY
89322: PUSH
89323: LD_VAR 0 5
89327: IN
89328: NOT
89329: IFFALSE 89366
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
89331: LD_ADDR_VAR 0 5
89335: PUSH
89336: LD_VAR 0 5
89340: PPUSH
89341: LD_VAR 0 5
89345: PUSH
89346: LD_INT 1
89348: PLUS
89349: PPUSH
89350: LD_EXP 203
89354: PUSH
89355: LD_VAR 0 2
89359: ARRAY
89360: PPUSH
89361: CALL_OW 2
89365: ST_TO_ADDR
89366: GO 89309
89368: POP
89369: POP
// if not tmp then
89370: LD_VAR 0 5
89374: NOT
89375: IFFALSE 89379
// exit ;
89377: GO 89484
// for j in tmp do
89379: LD_ADDR_VAR 0 3
89383: PUSH
89384: LD_VAR 0 5
89388: PUSH
89389: FOR_IN
89390: IFFALSE 89482
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
89392: LD_ADDR_VAR 0 6
89396: PUSH
89397: LD_INT 22
89399: PUSH
89400: LD_VAR 0 3
89404: PUSH
89405: EMPTY
89406: LIST
89407: LIST
89408: PPUSH
89409: CALL_OW 69
89413: ST_TO_ADDR
// if not un then
89414: LD_VAR 0 6
89418: NOT
89419: IFFALSE 89423
// continue ;
89421: GO 89389
// nation := GetNation ( un [ 1 ] ) ;
89423: LD_ADDR_VAR 0 4
89427: PUSH
89428: LD_VAR 0 6
89432: PUSH
89433: LD_INT 1
89435: ARRAY
89436: PPUSH
89437: CALL_OW 248
89441: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
89442: LD_ADDR_EXP 204
89446: PUSH
89447: LD_EXP 204
89451: PPUSH
89452: LD_VAR 0 3
89456: PPUSH
89457: LD_VAR 0 3
89461: PPUSH
89462: LD_VAR 0 4
89466: PPUSH
89467: LD_INT 1
89469: PPUSH
89470: CALL 19287 0 3
89474: PPUSH
89475: CALL_OW 1
89479: ST_TO_ADDR
// end ;
89480: GO 89389
89482: POP
89483: POP
// end ;
89484: LD_VAR 0 1
89488: RET
// export function MC_InitSides ( ) ; var i ; begin
89489: LD_INT 0
89491: PPUSH
89492: PPUSH
// if not mc_bases then
89493: LD_EXP 177
89497: NOT
89498: IFFALSE 89502
// exit ;
89500: GO 89576
// for i = 1 to mc_bases do
89502: LD_ADDR_VAR 0 2
89506: PUSH
89507: DOUBLE
89508: LD_INT 1
89510: DEC
89511: ST_TO_ADDR
89512: LD_EXP 177
89516: PUSH
89517: FOR_TO
89518: IFFALSE 89574
// if mc_bases [ i ] then
89520: LD_EXP 177
89524: PUSH
89525: LD_VAR 0 2
89529: ARRAY
89530: IFFALSE 89572
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
89532: LD_ADDR_EXP 203
89536: PUSH
89537: LD_EXP 203
89541: PPUSH
89542: LD_VAR 0 2
89546: PPUSH
89547: LD_EXP 177
89551: PUSH
89552: LD_VAR 0 2
89556: ARRAY
89557: PUSH
89558: LD_INT 1
89560: ARRAY
89561: PPUSH
89562: CALL_OW 255
89566: PPUSH
89567: CALL_OW 1
89571: ST_TO_ADDR
89572: GO 89517
89574: POP
89575: POP
// end ;
89576: LD_VAR 0 1
89580: RET
// every 0 0$03 trigger skirmish do
89581: LD_EXP 175
89585: IFFALSE 89739
89587: GO 89589
89589: DISABLE
// begin enable ;
89590: ENABLE
// MC_CheckBuildings ( ) ;
89591: CALL 94237 0 0
// MC_CheckPeopleLife ( ) ;
89595: CALL 94398 0 0
// RaiseSailEvent ( 100 ) ;
89599: LD_INT 100
89601: PPUSH
89602: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
89606: LD_INT 103
89608: PPUSH
89609: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
89613: LD_INT 104
89615: PPUSH
89616: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
89620: LD_INT 105
89622: PPUSH
89623: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
89627: LD_INT 106
89629: PPUSH
89630: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
89634: LD_INT 107
89636: PPUSH
89637: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
89641: LD_INT 108
89643: PPUSH
89644: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
89648: LD_INT 109
89650: PPUSH
89651: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
89655: LD_INT 110
89657: PPUSH
89658: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
89662: LD_INT 111
89664: PPUSH
89665: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
89669: LD_INT 112
89671: PPUSH
89672: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
89676: LD_INT 113
89678: PPUSH
89679: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
89683: LD_INT 120
89685: PPUSH
89686: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
89690: LD_INT 121
89692: PPUSH
89693: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
89697: LD_INT 122
89699: PPUSH
89700: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
89704: LD_INT 123
89706: PPUSH
89707: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
89711: LD_INT 124
89713: PPUSH
89714: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
89718: LD_INT 125
89720: PPUSH
89721: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
89725: LD_INT 126
89727: PPUSH
89728: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
89732: LD_INT 200
89734: PPUSH
89735: CALL_OW 427
// end ;
89739: END
// on SailEvent ( event ) do begin if event < 100 then
89740: LD_VAR 0 1
89744: PUSH
89745: LD_INT 100
89747: LESS
89748: IFFALSE 89759
// CustomEvent ( event ) ;
89750: LD_VAR 0 1
89754: PPUSH
89755: CALL 16158 0 1
// if event = 100 then
89759: LD_VAR 0 1
89763: PUSH
89764: LD_INT 100
89766: EQUAL
89767: IFFALSE 89773
// MC_ClassManager ( ) ;
89769: CALL 90165 0 0
// if event = 101 then
89773: LD_VAR 0 1
89777: PUSH
89778: LD_INT 101
89780: EQUAL
89781: IFFALSE 89787
// MC_RepairBuildings ( ) ;
89783: CALL 94983 0 0
// if event = 102 then
89787: LD_VAR 0 1
89791: PUSH
89792: LD_INT 102
89794: EQUAL
89795: IFFALSE 89801
// MC_Heal ( ) ;
89797: CALL 95890 0 0
// if event = 103 then
89801: LD_VAR 0 1
89805: PUSH
89806: LD_INT 103
89808: EQUAL
89809: IFFALSE 89815
// MC_Build ( ) ;
89811: CALL 96312 0 0
// if event = 104 then
89815: LD_VAR 0 1
89819: PUSH
89820: LD_INT 104
89822: EQUAL
89823: IFFALSE 89829
// MC_TurretWeapon ( ) ;
89825: CALL 97953 0 0
// if event = 105 then
89829: LD_VAR 0 1
89833: PUSH
89834: LD_INT 105
89836: EQUAL
89837: IFFALSE 89843
// MC_BuildUpgrade ( ) ;
89839: CALL 97504 0 0
// if event = 106 then
89843: LD_VAR 0 1
89847: PUSH
89848: LD_INT 106
89850: EQUAL
89851: IFFALSE 89857
// MC_PlantMines ( ) ;
89853: CALL 98383 0 0
// if event = 107 then
89857: LD_VAR 0 1
89861: PUSH
89862: LD_INT 107
89864: EQUAL
89865: IFFALSE 89871
// MC_CollectCrates ( ) ;
89867: CALL 99174 0 0
// if event = 108 then
89871: LD_VAR 0 1
89875: PUSH
89876: LD_INT 108
89878: EQUAL
89879: IFFALSE 89885
// MC_LinkRemoteControl ( ) ;
89881: CALL 101024 0 0
// if event = 109 then
89885: LD_VAR 0 1
89889: PUSH
89890: LD_INT 109
89892: EQUAL
89893: IFFALSE 89899
// MC_ProduceVehicle ( ) ;
89895: CALL 101205 0 0
// if event = 110 then
89899: LD_VAR 0 1
89903: PUSH
89904: LD_INT 110
89906: EQUAL
89907: IFFALSE 89913
// MC_SendAttack ( ) ;
89909: CALL 101671 0 0
// if event = 111 then
89913: LD_VAR 0 1
89917: PUSH
89918: LD_INT 111
89920: EQUAL
89921: IFFALSE 89927
// MC_Defend ( ) ;
89923: CALL 101779 0 0
// if event = 112 then
89927: LD_VAR 0 1
89931: PUSH
89932: LD_INT 112
89934: EQUAL
89935: IFFALSE 89941
// MC_Research ( ) ;
89937: CALL 102659 0 0
// if event = 113 then
89941: LD_VAR 0 1
89945: PUSH
89946: LD_INT 113
89948: EQUAL
89949: IFFALSE 89955
// MC_MinesTrigger ( ) ;
89951: CALL 103773 0 0
// if event = 120 then
89955: LD_VAR 0 1
89959: PUSH
89960: LD_INT 120
89962: EQUAL
89963: IFFALSE 89969
// MC_RepairVehicle ( ) ;
89965: CALL 103872 0 0
// if event = 121 then
89969: LD_VAR 0 1
89973: PUSH
89974: LD_INT 121
89976: EQUAL
89977: IFFALSE 89983
// MC_TameApe ( ) ;
89979: CALL 104613 0 0
// if event = 122 then
89983: LD_VAR 0 1
89987: PUSH
89988: LD_INT 122
89990: EQUAL
89991: IFFALSE 89997
// MC_ChangeApeClass ( ) ;
89993: CALL 105442 0 0
// if event = 123 then
89997: LD_VAR 0 1
90001: PUSH
90002: LD_INT 123
90004: EQUAL
90005: IFFALSE 90011
// MC_Bazooka ( ) ;
90007: CALL 106092 0 0
// if event = 124 then
90011: LD_VAR 0 1
90015: PUSH
90016: LD_INT 124
90018: EQUAL
90019: IFFALSE 90025
// MC_TeleportExit ( ) ;
90021: CALL 106290 0 0
// if event = 125 then
90025: LD_VAR 0 1
90029: PUSH
90030: LD_INT 125
90032: EQUAL
90033: IFFALSE 90039
// MC_Deposits ( ) ;
90035: CALL 106937 0 0
// if event = 126 then
90039: LD_VAR 0 1
90043: PUSH
90044: LD_INT 126
90046: EQUAL
90047: IFFALSE 90053
// MC_RemoteDriver ( ) ;
90049: CALL 107562 0 0
// if event = 200 then
90053: LD_VAR 0 1
90057: PUSH
90058: LD_INT 200
90060: EQUAL
90061: IFFALSE 90067
// MC_Idle ( ) ;
90063: CALL 109511 0 0
// end ;
90067: PPOPN 1
90069: END
// export function MC_Reset ( base , tag ) ; var i ; begin
90070: LD_INT 0
90072: PPUSH
90073: PPUSH
// if not mc_bases [ base ] or not tag then
90074: LD_EXP 177
90078: PUSH
90079: LD_VAR 0 1
90083: ARRAY
90084: NOT
90085: PUSH
90086: LD_VAR 0 2
90090: NOT
90091: OR
90092: IFFALSE 90096
// exit ;
90094: GO 90160
// for i in mc_bases [ base ] union mc_ape [ base ] do
90096: LD_ADDR_VAR 0 4
90100: PUSH
90101: LD_EXP 177
90105: PUSH
90106: LD_VAR 0 1
90110: ARRAY
90111: PUSH
90112: LD_EXP 206
90116: PUSH
90117: LD_VAR 0 1
90121: ARRAY
90122: UNION
90123: PUSH
90124: FOR_IN
90125: IFFALSE 90158
// if GetTag ( i ) = tag then
90127: LD_VAR 0 4
90131: PPUSH
90132: CALL_OW 110
90136: PUSH
90137: LD_VAR 0 2
90141: EQUAL
90142: IFFALSE 90156
// SetTag ( i , 0 ) ;
90144: LD_VAR 0 4
90148: PPUSH
90149: LD_INT 0
90151: PPUSH
90152: CALL_OW 109
90156: GO 90124
90158: POP
90159: POP
// end ;
90160: LD_VAR 0 3
90164: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
90165: LD_INT 0
90167: PPUSH
90168: PPUSH
90169: PPUSH
90170: PPUSH
90171: PPUSH
90172: PPUSH
90173: PPUSH
90174: PPUSH
// if not mc_bases then
90175: LD_EXP 177
90179: NOT
90180: IFFALSE 90184
// exit ;
90182: GO 90642
// for i = 1 to mc_bases do
90184: LD_ADDR_VAR 0 2
90188: PUSH
90189: DOUBLE
90190: LD_INT 1
90192: DEC
90193: ST_TO_ADDR
90194: LD_EXP 177
90198: PUSH
90199: FOR_TO
90200: IFFALSE 90640
// begin tmp := MC_ClassCheckReq ( i ) ;
90202: LD_ADDR_VAR 0 4
90206: PUSH
90207: LD_VAR 0 2
90211: PPUSH
90212: CALL 90647 0 1
90216: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
90217: LD_ADDR_EXP 218
90221: PUSH
90222: LD_EXP 218
90226: PPUSH
90227: LD_VAR 0 2
90231: PPUSH
90232: LD_VAR 0 4
90236: PPUSH
90237: CALL_OW 1
90241: ST_TO_ADDR
// if not tmp then
90242: LD_VAR 0 4
90246: NOT
90247: IFFALSE 90251
// continue ;
90249: GO 90199
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
90251: LD_ADDR_VAR 0 6
90255: PUSH
90256: LD_EXP 177
90260: PUSH
90261: LD_VAR 0 2
90265: ARRAY
90266: PPUSH
90267: LD_INT 2
90269: PUSH
90270: LD_INT 30
90272: PUSH
90273: LD_INT 4
90275: PUSH
90276: EMPTY
90277: LIST
90278: LIST
90279: PUSH
90280: LD_INT 30
90282: PUSH
90283: LD_INT 5
90285: PUSH
90286: EMPTY
90287: LIST
90288: LIST
90289: PUSH
90290: EMPTY
90291: LIST
90292: LIST
90293: LIST
90294: PPUSH
90295: CALL_OW 72
90299: PUSH
90300: LD_EXP 177
90304: PUSH
90305: LD_VAR 0 2
90309: ARRAY
90310: PPUSH
90311: LD_INT 2
90313: PUSH
90314: LD_INT 30
90316: PUSH
90317: LD_INT 0
90319: PUSH
90320: EMPTY
90321: LIST
90322: LIST
90323: PUSH
90324: LD_INT 30
90326: PUSH
90327: LD_INT 1
90329: PUSH
90330: EMPTY
90331: LIST
90332: LIST
90333: PUSH
90334: EMPTY
90335: LIST
90336: LIST
90337: LIST
90338: PPUSH
90339: CALL_OW 72
90343: PUSH
90344: LD_EXP 177
90348: PUSH
90349: LD_VAR 0 2
90353: ARRAY
90354: PPUSH
90355: LD_INT 30
90357: PUSH
90358: LD_INT 3
90360: PUSH
90361: EMPTY
90362: LIST
90363: LIST
90364: PPUSH
90365: CALL_OW 72
90369: PUSH
90370: LD_EXP 177
90374: PUSH
90375: LD_VAR 0 2
90379: ARRAY
90380: PPUSH
90381: LD_INT 2
90383: PUSH
90384: LD_INT 30
90386: PUSH
90387: LD_INT 6
90389: PUSH
90390: EMPTY
90391: LIST
90392: LIST
90393: PUSH
90394: LD_INT 30
90396: PUSH
90397: LD_INT 7
90399: PUSH
90400: EMPTY
90401: LIST
90402: LIST
90403: PUSH
90404: LD_INT 30
90406: PUSH
90407: LD_INT 8
90409: PUSH
90410: EMPTY
90411: LIST
90412: LIST
90413: PUSH
90414: EMPTY
90415: LIST
90416: LIST
90417: LIST
90418: LIST
90419: PPUSH
90420: CALL_OW 72
90424: PUSH
90425: EMPTY
90426: LIST
90427: LIST
90428: LIST
90429: LIST
90430: ST_TO_ADDR
// for j = 1 to 4 do
90431: LD_ADDR_VAR 0 3
90435: PUSH
90436: DOUBLE
90437: LD_INT 1
90439: DEC
90440: ST_TO_ADDR
90441: LD_INT 4
90443: PUSH
90444: FOR_TO
90445: IFFALSE 90636
// begin if not tmp [ j ] then
90447: LD_VAR 0 4
90451: PUSH
90452: LD_VAR 0 3
90456: ARRAY
90457: NOT
90458: IFFALSE 90462
// continue ;
90460: GO 90444
// for p in tmp [ j ] do
90462: LD_ADDR_VAR 0 5
90466: PUSH
90467: LD_VAR 0 4
90471: PUSH
90472: LD_VAR 0 3
90476: ARRAY
90477: PUSH
90478: FOR_IN
90479: IFFALSE 90632
// begin if not b [ j ] then
90481: LD_VAR 0 6
90485: PUSH
90486: LD_VAR 0 3
90490: ARRAY
90491: NOT
90492: IFFALSE 90496
// break ;
90494: GO 90632
// e := 0 ;
90496: LD_ADDR_VAR 0 7
90500: PUSH
90501: LD_INT 0
90503: ST_TO_ADDR
// for k in b [ j ] do
90504: LD_ADDR_VAR 0 8
90508: PUSH
90509: LD_VAR 0 6
90513: PUSH
90514: LD_VAR 0 3
90518: ARRAY
90519: PUSH
90520: FOR_IN
90521: IFFALSE 90548
// if IsNotFull ( k ) then
90523: LD_VAR 0 8
90527: PPUSH
90528: CALL 21440 0 1
90532: IFFALSE 90546
// begin e := k ;
90534: LD_ADDR_VAR 0 7
90538: PUSH
90539: LD_VAR 0 8
90543: ST_TO_ADDR
// break ;
90544: GO 90548
// end ;
90546: GO 90520
90548: POP
90549: POP
// if e and not UnitGoingToBuilding ( p , e ) then
90550: LD_VAR 0 7
90554: PUSH
90555: LD_VAR 0 5
90559: PPUSH
90560: LD_VAR 0 7
90564: PPUSH
90565: CALL 54604 0 2
90569: NOT
90570: AND
90571: IFFALSE 90630
// begin if IsInUnit ( p ) then
90573: LD_VAR 0 5
90577: PPUSH
90578: CALL_OW 310
90582: IFFALSE 90593
// ComExitBuilding ( p ) ;
90584: LD_VAR 0 5
90588: PPUSH
90589: CALL_OW 122
// ComEnterUnit ( p , e ) ;
90593: LD_VAR 0 5
90597: PPUSH
90598: LD_VAR 0 7
90602: PPUSH
90603: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
90607: LD_VAR 0 5
90611: PPUSH
90612: LD_VAR 0 3
90616: PPUSH
90617: CALL_OW 183
// AddComExitBuilding ( p ) ;
90621: LD_VAR 0 5
90625: PPUSH
90626: CALL_OW 182
// end ; end ;
90630: GO 90478
90632: POP
90633: POP
// end ;
90634: GO 90444
90636: POP
90637: POP
// end ;
90638: GO 90199
90640: POP
90641: POP
// end ;
90642: LD_VAR 0 1
90646: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
90647: LD_INT 0
90649: PPUSH
90650: PPUSH
90651: PPUSH
90652: PPUSH
90653: PPUSH
90654: PPUSH
90655: PPUSH
90656: PPUSH
90657: PPUSH
90658: PPUSH
90659: PPUSH
90660: PPUSH
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
90661: LD_VAR 0 1
90665: NOT
90666: PUSH
90667: LD_EXP 177
90671: PUSH
90672: LD_VAR 0 1
90676: ARRAY
90677: NOT
90678: OR
90679: PUSH
90680: LD_EXP 177
90684: PUSH
90685: LD_VAR 0 1
90689: ARRAY
90690: PPUSH
90691: LD_INT 2
90693: PUSH
90694: LD_INT 30
90696: PUSH
90697: LD_INT 0
90699: PUSH
90700: EMPTY
90701: LIST
90702: LIST
90703: PUSH
90704: LD_INT 30
90706: PUSH
90707: LD_INT 1
90709: PUSH
90710: EMPTY
90711: LIST
90712: LIST
90713: PUSH
90714: EMPTY
90715: LIST
90716: LIST
90717: LIST
90718: PPUSH
90719: CALL_OW 72
90723: NOT
90724: OR
90725: IFFALSE 90729
// exit ;
90727: GO 94232
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
90729: LD_ADDR_VAR 0 4
90733: PUSH
90734: LD_EXP 177
90738: PUSH
90739: LD_VAR 0 1
90743: ARRAY
90744: PPUSH
90745: LD_INT 2
90747: PUSH
90748: LD_INT 25
90750: PUSH
90751: LD_INT 1
90753: PUSH
90754: EMPTY
90755: LIST
90756: LIST
90757: PUSH
90758: LD_INT 25
90760: PUSH
90761: LD_INT 2
90763: PUSH
90764: EMPTY
90765: LIST
90766: LIST
90767: PUSH
90768: LD_INT 25
90770: PUSH
90771: LD_INT 3
90773: PUSH
90774: EMPTY
90775: LIST
90776: LIST
90777: PUSH
90778: LD_INT 25
90780: PUSH
90781: LD_INT 4
90783: PUSH
90784: EMPTY
90785: LIST
90786: LIST
90787: PUSH
90788: LD_INT 25
90790: PUSH
90791: LD_INT 5
90793: PUSH
90794: EMPTY
90795: LIST
90796: LIST
90797: PUSH
90798: LD_INT 25
90800: PUSH
90801: LD_INT 8
90803: PUSH
90804: EMPTY
90805: LIST
90806: LIST
90807: PUSH
90808: LD_INT 25
90810: PUSH
90811: LD_INT 9
90813: PUSH
90814: EMPTY
90815: LIST
90816: LIST
90817: PUSH
90818: EMPTY
90819: LIST
90820: LIST
90821: LIST
90822: LIST
90823: LIST
90824: LIST
90825: LIST
90826: LIST
90827: PPUSH
90828: CALL_OW 72
90832: ST_TO_ADDR
// if not tmp then
90833: LD_VAR 0 4
90837: NOT
90838: IFFALSE 90842
// exit ;
90840: GO 94232
// for i in tmp do
90842: LD_ADDR_VAR 0 3
90846: PUSH
90847: LD_VAR 0 4
90851: PUSH
90852: FOR_IN
90853: IFFALSE 90884
// if GetTag ( i ) then
90855: LD_VAR 0 3
90859: PPUSH
90860: CALL_OW 110
90864: IFFALSE 90882
// tmp := tmp diff i ;
90866: LD_ADDR_VAR 0 4
90870: PUSH
90871: LD_VAR 0 4
90875: PUSH
90876: LD_VAR 0 3
90880: DIFF
90881: ST_TO_ADDR
90882: GO 90852
90884: POP
90885: POP
// if not tmp then
90886: LD_VAR 0 4
90890: NOT
90891: IFFALSE 90895
// exit ;
90893: GO 94232
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
90895: LD_ADDR_VAR 0 5
90899: PUSH
90900: LD_EXP 177
90904: PUSH
90905: LD_VAR 0 1
90909: ARRAY
90910: PPUSH
90911: LD_INT 2
90913: PUSH
90914: LD_INT 25
90916: PUSH
90917: LD_INT 1
90919: PUSH
90920: EMPTY
90921: LIST
90922: LIST
90923: PUSH
90924: LD_INT 25
90926: PUSH
90927: LD_INT 5
90929: PUSH
90930: EMPTY
90931: LIST
90932: LIST
90933: PUSH
90934: LD_INT 25
90936: PUSH
90937: LD_INT 8
90939: PUSH
90940: EMPTY
90941: LIST
90942: LIST
90943: PUSH
90944: LD_INT 25
90946: PUSH
90947: LD_INT 9
90949: PUSH
90950: EMPTY
90951: LIST
90952: LIST
90953: PUSH
90954: EMPTY
90955: LIST
90956: LIST
90957: LIST
90958: LIST
90959: LIST
90960: PPUSH
90961: CALL_OW 72
90965: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
90966: LD_ADDR_VAR 0 6
90970: PUSH
90971: LD_EXP 177
90975: PUSH
90976: LD_VAR 0 1
90980: ARRAY
90981: PPUSH
90982: LD_INT 25
90984: PUSH
90985: LD_INT 2
90987: PUSH
90988: EMPTY
90989: LIST
90990: LIST
90991: PPUSH
90992: CALL_OW 72
90996: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
90997: LD_ADDR_VAR 0 7
91001: PUSH
91002: LD_EXP 177
91006: PUSH
91007: LD_VAR 0 1
91011: ARRAY
91012: PPUSH
91013: LD_INT 25
91015: PUSH
91016: LD_INT 3
91018: PUSH
91019: EMPTY
91020: LIST
91021: LIST
91022: PPUSH
91023: CALL_OW 72
91027: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
91028: LD_ADDR_VAR 0 8
91032: PUSH
91033: LD_EXP 177
91037: PUSH
91038: LD_VAR 0 1
91042: ARRAY
91043: PPUSH
91044: LD_INT 25
91046: PUSH
91047: LD_INT 4
91049: PUSH
91050: EMPTY
91051: LIST
91052: LIST
91053: PUSH
91054: LD_INT 24
91056: PUSH
91057: LD_INT 251
91059: PUSH
91060: EMPTY
91061: LIST
91062: LIST
91063: PUSH
91064: EMPTY
91065: LIST
91066: LIST
91067: PPUSH
91068: CALL_OW 72
91072: ST_TO_ADDR
// if mc_is_defending [ base ] then
91073: LD_EXP 220
91077: PUSH
91078: LD_VAR 0 1
91082: ARRAY
91083: IFFALSE 91544
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
91085: LD_ADDR_EXP 219
91089: PUSH
91090: LD_EXP 219
91094: PPUSH
91095: LD_VAR 0 1
91099: PPUSH
91100: LD_INT 4
91102: PPUSH
91103: CALL_OW 1
91107: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
91108: LD_ADDR_VAR 0 12
91112: PUSH
91113: LD_EXP 177
91117: PUSH
91118: LD_VAR 0 1
91122: ARRAY
91123: PPUSH
91124: LD_INT 2
91126: PUSH
91127: LD_INT 30
91129: PUSH
91130: LD_INT 4
91132: PUSH
91133: EMPTY
91134: LIST
91135: LIST
91136: PUSH
91137: LD_INT 30
91139: PUSH
91140: LD_INT 5
91142: PUSH
91143: EMPTY
91144: LIST
91145: LIST
91146: PUSH
91147: EMPTY
91148: LIST
91149: LIST
91150: LIST
91151: PPUSH
91152: CALL_OW 72
91156: ST_TO_ADDR
// if not b then
91157: LD_VAR 0 12
91161: NOT
91162: IFFALSE 91166
// exit ;
91164: GO 94232
// p := [ ] ;
91166: LD_ADDR_VAR 0 11
91170: PUSH
91171: EMPTY
91172: ST_TO_ADDR
// if sci >= 2 then
91173: LD_VAR 0 8
91177: PUSH
91178: LD_INT 2
91180: GREATEREQUAL
91181: IFFALSE 91212
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
91183: LD_ADDR_VAR 0 8
91187: PUSH
91188: LD_VAR 0 8
91192: PUSH
91193: LD_INT 1
91195: ARRAY
91196: PUSH
91197: LD_VAR 0 8
91201: PUSH
91202: LD_INT 2
91204: ARRAY
91205: PUSH
91206: EMPTY
91207: LIST
91208: LIST
91209: ST_TO_ADDR
91210: GO 91273
// if sci = 1 then
91212: LD_VAR 0 8
91216: PUSH
91217: LD_INT 1
91219: EQUAL
91220: IFFALSE 91241
// sci := [ sci [ 1 ] ] else
91222: LD_ADDR_VAR 0 8
91226: PUSH
91227: LD_VAR 0 8
91231: PUSH
91232: LD_INT 1
91234: ARRAY
91235: PUSH
91236: EMPTY
91237: LIST
91238: ST_TO_ADDR
91239: GO 91273
// if sci = 0 then
91241: LD_VAR 0 8
91245: PUSH
91246: LD_INT 0
91248: EQUAL
91249: IFFALSE 91273
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
91251: LD_ADDR_VAR 0 11
91255: PUSH
91256: LD_VAR 0 4
91260: PPUSH
91261: LD_INT 4
91263: PPUSH
91264: CALL 54467 0 2
91268: PUSH
91269: LD_INT 1
91271: ARRAY
91272: ST_TO_ADDR
// if eng > 4 then
91273: LD_VAR 0 6
91277: PUSH
91278: LD_INT 4
91280: GREATER
91281: IFFALSE 91327
// for i = eng downto 4 do
91283: LD_ADDR_VAR 0 3
91287: PUSH
91288: DOUBLE
91289: LD_VAR 0 6
91293: INC
91294: ST_TO_ADDR
91295: LD_INT 4
91297: PUSH
91298: FOR_DOWNTO
91299: IFFALSE 91325
// eng := eng diff eng [ i ] ;
91301: LD_ADDR_VAR 0 6
91305: PUSH
91306: LD_VAR 0 6
91310: PUSH
91311: LD_VAR 0 6
91315: PUSH
91316: LD_VAR 0 3
91320: ARRAY
91321: DIFF
91322: ST_TO_ADDR
91323: GO 91298
91325: POP
91326: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
91327: LD_ADDR_VAR 0 4
91331: PUSH
91332: LD_VAR 0 4
91336: PUSH
91337: LD_VAR 0 5
91341: PUSH
91342: LD_VAR 0 6
91346: UNION
91347: PUSH
91348: LD_VAR 0 7
91352: UNION
91353: PUSH
91354: LD_VAR 0 8
91358: UNION
91359: DIFF
91360: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
91361: LD_ADDR_VAR 0 13
91365: PUSH
91366: LD_EXP 177
91370: PUSH
91371: LD_VAR 0 1
91375: ARRAY
91376: PPUSH
91377: LD_INT 2
91379: PUSH
91380: LD_INT 30
91382: PUSH
91383: LD_INT 32
91385: PUSH
91386: EMPTY
91387: LIST
91388: LIST
91389: PUSH
91390: LD_INT 30
91392: PUSH
91393: LD_INT 31
91395: PUSH
91396: EMPTY
91397: LIST
91398: LIST
91399: PUSH
91400: EMPTY
91401: LIST
91402: LIST
91403: LIST
91404: PPUSH
91405: CALL_OW 72
91409: PUSH
91410: LD_EXP 177
91414: PUSH
91415: LD_VAR 0 1
91419: ARRAY
91420: PPUSH
91421: LD_INT 2
91423: PUSH
91424: LD_INT 30
91426: PUSH
91427: LD_INT 4
91429: PUSH
91430: EMPTY
91431: LIST
91432: LIST
91433: PUSH
91434: LD_INT 30
91436: PUSH
91437: LD_INT 5
91439: PUSH
91440: EMPTY
91441: LIST
91442: LIST
91443: PUSH
91444: EMPTY
91445: LIST
91446: LIST
91447: LIST
91448: PPUSH
91449: CALL_OW 72
91453: PUSH
91454: LD_INT 6
91456: MUL
91457: PLUS
91458: ST_TO_ADDR
// if bcount < tmp then
91459: LD_VAR 0 13
91463: PUSH
91464: LD_VAR 0 4
91468: LESS
91469: IFFALSE 91515
// for i = tmp downto bcount do
91471: LD_ADDR_VAR 0 3
91475: PUSH
91476: DOUBLE
91477: LD_VAR 0 4
91481: INC
91482: ST_TO_ADDR
91483: LD_VAR 0 13
91487: PUSH
91488: FOR_DOWNTO
91489: IFFALSE 91513
// tmp := Delete ( tmp , tmp ) ;
91491: LD_ADDR_VAR 0 4
91495: PUSH
91496: LD_VAR 0 4
91500: PPUSH
91501: LD_VAR 0 4
91505: PPUSH
91506: CALL_OW 3
91510: ST_TO_ADDR
91511: GO 91488
91513: POP
91514: POP
// result := [ tmp , 0 , 0 , p ] ;
91515: LD_ADDR_VAR 0 2
91519: PUSH
91520: LD_VAR 0 4
91524: PUSH
91525: LD_INT 0
91527: PUSH
91528: LD_INT 0
91530: PUSH
91531: LD_VAR 0 11
91535: PUSH
91536: EMPTY
91537: LIST
91538: LIST
91539: LIST
91540: LIST
91541: ST_TO_ADDR
// exit ;
91542: GO 94232
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
91544: LD_EXP 177
91548: PUSH
91549: LD_VAR 0 1
91553: ARRAY
91554: PPUSH
91555: LD_INT 2
91557: PUSH
91558: LD_INT 30
91560: PUSH
91561: LD_INT 6
91563: PUSH
91564: EMPTY
91565: LIST
91566: LIST
91567: PUSH
91568: LD_INT 30
91570: PUSH
91571: LD_INT 7
91573: PUSH
91574: EMPTY
91575: LIST
91576: LIST
91577: PUSH
91578: LD_INT 30
91580: PUSH
91581: LD_INT 8
91583: PUSH
91584: EMPTY
91585: LIST
91586: LIST
91587: PUSH
91588: EMPTY
91589: LIST
91590: LIST
91591: LIST
91592: LIST
91593: PPUSH
91594: CALL_OW 72
91598: NOT
91599: PUSH
91600: LD_EXP 177
91604: PUSH
91605: LD_VAR 0 1
91609: ARRAY
91610: PPUSH
91611: LD_INT 30
91613: PUSH
91614: LD_INT 3
91616: PUSH
91617: EMPTY
91618: LIST
91619: LIST
91620: PPUSH
91621: CALL_OW 72
91625: NOT
91626: AND
91627: IFFALSE 91699
// begin if eng = tmp then
91629: LD_VAR 0 6
91633: PUSH
91634: LD_VAR 0 4
91638: EQUAL
91639: IFFALSE 91643
// exit ;
91641: GO 94232
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
91643: LD_ADDR_EXP 219
91647: PUSH
91648: LD_EXP 219
91652: PPUSH
91653: LD_VAR 0 1
91657: PPUSH
91658: LD_INT 1
91660: PPUSH
91661: CALL_OW 1
91665: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
91666: LD_ADDR_VAR 0 2
91670: PUSH
91671: LD_INT 0
91673: PUSH
91674: LD_VAR 0 4
91678: PUSH
91679: LD_VAR 0 6
91683: DIFF
91684: PUSH
91685: LD_INT 0
91687: PUSH
91688: LD_INT 0
91690: PUSH
91691: EMPTY
91692: LIST
91693: LIST
91694: LIST
91695: LIST
91696: ST_TO_ADDR
// exit ;
91697: GO 94232
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
91699: LD_EXP 204
91703: PUSH
91704: LD_EXP 203
91708: PUSH
91709: LD_VAR 0 1
91713: ARRAY
91714: ARRAY
91715: PUSH
91716: LD_EXP 177
91720: PUSH
91721: LD_VAR 0 1
91725: ARRAY
91726: PPUSH
91727: LD_INT 2
91729: PUSH
91730: LD_INT 30
91732: PUSH
91733: LD_INT 6
91735: PUSH
91736: EMPTY
91737: LIST
91738: LIST
91739: PUSH
91740: LD_INT 30
91742: PUSH
91743: LD_INT 7
91745: PUSH
91746: EMPTY
91747: LIST
91748: LIST
91749: PUSH
91750: LD_INT 30
91752: PUSH
91753: LD_INT 8
91755: PUSH
91756: EMPTY
91757: LIST
91758: LIST
91759: PUSH
91760: EMPTY
91761: LIST
91762: LIST
91763: LIST
91764: LIST
91765: PPUSH
91766: CALL_OW 72
91770: AND
91771: PUSH
91772: LD_EXP 177
91776: PUSH
91777: LD_VAR 0 1
91781: ARRAY
91782: PPUSH
91783: LD_INT 30
91785: PUSH
91786: LD_INT 3
91788: PUSH
91789: EMPTY
91790: LIST
91791: LIST
91792: PPUSH
91793: CALL_OW 72
91797: NOT
91798: AND
91799: IFFALSE 92013
// begin if sci >= 6 then
91801: LD_VAR 0 8
91805: PUSH
91806: LD_INT 6
91808: GREATEREQUAL
91809: IFFALSE 91813
// exit ;
91811: GO 94232
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
91813: LD_ADDR_EXP 219
91817: PUSH
91818: LD_EXP 219
91822: PPUSH
91823: LD_VAR 0 1
91827: PPUSH
91828: LD_INT 2
91830: PPUSH
91831: CALL_OW 1
91835: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
91836: LD_ADDR_VAR 0 9
91840: PUSH
91841: LD_VAR 0 4
91845: PUSH
91846: LD_VAR 0 8
91850: DIFF
91851: PPUSH
91852: LD_INT 4
91854: PPUSH
91855: CALL 54467 0 2
91859: ST_TO_ADDR
// p := [ ] ;
91860: LD_ADDR_VAR 0 11
91864: PUSH
91865: EMPTY
91866: ST_TO_ADDR
// if sci < 6 and sort > 6 then
91867: LD_VAR 0 8
91871: PUSH
91872: LD_INT 6
91874: LESS
91875: PUSH
91876: LD_VAR 0 9
91880: PUSH
91881: LD_INT 6
91883: GREATER
91884: AND
91885: IFFALSE 91966
// begin for i = 1 to 6 - sci do
91887: LD_ADDR_VAR 0 3
91891: PUSH
91892: DOUBLE
91893: LD_INT 1
91895: DEC
91896: ST_TO_ADDR
91897: LD_INT 6
91899: PUSH
91900: LD_VAR 0 8
91904: MINUS
91905: PUSH
91906: FOR_TO
91907: IFFALSE 91962
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
91909: LD_ADDR_VAR 0 11
91913: PUSH
91914: LD_VAR 0 11
91918: PPUSH
91919: LD_VAR 0 11
91923: PUSH
91924: LD_INT 1
91926: PLUS
91927: PPUSH
91928: LD_VAR 0 9
91932: PUSH
91933: LD_INT 1
91935: ARRAY
91936: PPUSH
91937: CALL_OW 2
91941: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
91942: LD_ADDR_VAR 0 9
91946: PUSH
91947: LD_VAR 0 9
91951: PPUSH
91952: LD_INT 1
91954: PPUSH
91955: CALL_OW 3
91959: ST_TO_ADDR
// end ;
91960: GO 91906
91962: POP
91963: POP
// end else
91964: GO 91986
// if sort then
91966: LD_VAR 0 9
91970: IFFALSE 91986
// p := sort [ 1 ] ;
91972: LD_ADDR_VAR 0 11
91976: PUSH
91977: LD_VAR 0 9
91981: PUSH
91982: LD_INT 1
91984: ARRAY
91985: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
91986: LD_ADDR_VAR 0 2
91990: PUSH
91991: LD_INT 0
91993: PUSH
91994: LD_INT 0
91996: PUSH
91997: LD_INT 0
91999: PUSH
92000: LD_VAR 0 11
92004: PUSH
92005: EMPTY
92006: LIST
92007: LIST
92008: LIST
92009: LIST
92010: ST_TO_ADDR
// exit ;
92011: GO 94232
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
92013: LD_EXP 204
92017: PUSH
92018: LD_EXP 203
92022: PUSH
92023: LD_VAR 0 1
92027: ARRAY
92028: ARRAY
92029: PUSH
92030: LD_EXP 177
92034: PUSH
92035: LD_VAR 0 1
92039: ARRAY
92040: PPUSH
92041: LD_INT 2
92043: PUSH
92044: LD_INT 30
92046: PUSH
92047: LD_INT 6
92049: PUSH
92050: EMPTY
92051: LIST
92052: LIST
92053: PUSH
92054: LD_INT 30
92056: PUSH
92057: LD_INT 7
92059: PUSH
92060: EMPTY
92061: LIST
92062: LIST
92063: PUSH
92064: LD_INT 30
92066: PUSH
92067: LD_INT 8
92069: PUSH
92070: EMPTY
92071: LIST
92072: LIST
92073: PUSH
92074: EMPTY
92075: LIST
92076: LIST
92077: LIST
92078: LIST
92079: PPUSH
92080: CALL_OW 72
92084: AND
92085: PUSH
92086: LD_EXP 177
92090: PUSH
92091: LD_VAR 0 1
92095: ARRAY
92096: PPUSH
92097: LD_INT 30
92099: PUSH
92100: LD_INT 3
92102: PUSH
92103: EMPTY
92104: LIST
92105: LIST
92106: PPUSH
92107: CALL_OW 72
92111: AND
92112: IFFALSE 92846
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
92114: LD_ADDR_EXP 219
92118: PUSH
92119: LD_EXP 219
92123: PPUSH
92124: LD_VAR 0 1
92128: PPUSH
92129: LD_INT 3
92131: PPUSH
92132: CALL_OW 1
92136: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
92137: LD_ADDR_VAR 0 2
92141: PUSH
92142: LD_INT 0
92144: PUSH
92145: LD_INT 0
92147: PUSH
92148: LD_INT 0
92150: PUSH
92151: LD_INT 0
92153: PUSH
92154: EMPTY
92155: LIST
92156: LIST
92157: LIST
92158: LIST
92159: ST_TO_ADDR
// if not eng then
92160: LD_VAR 0 6
92164: NOT
92165: IFFALSE 92228
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
92167: LD_ADDR_VAR 0 11
92171: PUSH
92172: LD_VAR 0 4
92176: PPUSH
92177: LD_INT 2
92179: PPUSH
92180: CALL 54467 0 2
92184: PUSH
92185: LD_INT 1
92187: ARRAY
92188: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
92189: LD_ADDR_VAR 0 2
92193: PUSH
92194: LD_VAR 0 2
92198: PPUSH
92199: LD_INT 2
92201: PPUSH
92202: LD_VAR 0 11
92206: PPUSH
92207: CALL_OW 1
92211: ST_TO_ADDR
// tmp := tmp diff p ;
92212: LD_ADDR_VAR 0 4
92216: PUSH
92217: LD_VAR 0 4
92221: PUSH
92222: LD_VAR 0 11
92226: DIFF
92227: ST_TO_ADDR
// end ; if tmp and sci < 6 then
92228: LD_VAR 0 4
92232: PUSH
92233: LD_VAR 0 8
92237: PUSH
92238: LD_INT 6
92240: LESS
92241: AND
92242: IFFALSE 92430
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
92244: LD_ADDR_VAR 0 9
92248: PUSH
92249: LD_VAR 0 4
92253: PUSH
92254: LD_VAR 0 8
92258: PUSH
92259: LD_VAR 0 7
92263: UNION
92264: DIFF
92265: PPUSH
92266: LD_INT 4
92268: PPUSH
92269: CALL 54467 0 2
92273: ST_TO_ADDR
// p := [ ] ;
92274: LD_ADDR_VAR 0 11
92278: PUSH
92279: EMPTY
92280: ST_TO_ADDR
// if sort then
92281: LD_VAR 0 9
92285: IFFALSE 92401
// for i = 1 to 6 - sci do
92287: LD_ADDR_VAR 0 3
92291: PUSH
92292: DOUBLE
92293: LD_INT 1
92295: DEC
92296: ST_TO_ADDR
92297: LD_INT 6
92299: PUSH
92300: LD_VAR 0 8
92304: MINUS
92305: PUSH
92306: FOR_TO
92307: IFFALSE 92399
// begin if i = sort then
92309: LD_VAR 0 3
92313: PUSH
92314: LD_VAR 0 9
92318: EQUAL
92319: IFFALSE 92323
// break ;
92321: GO 92399
// if GetClass ( i ) = 4 then
92323: LD_VAR 0 3
92327: PPUSH
92328: CALL_OW 257
92332: PUSH
92333: LD_INT 4
92335: EQUAL
92336: IFFALSE 92340
// continue ;
92338: GO 92306
// p := Insert ( p , p + 1 , sort [ i ] ) ;
92340: LD_ADDR_VAR 0 11
92344: PUSH
92345: LD_VAR 0 11
92349: PPUSH
92350: LD_VAR 0 11
92354: PUSH
92355: LD_INT 1
92357: PLUS
92358: PPUSH
92359: LD_VAR 0 9
92363: PUSH
92364: LD_VAR 0 3
92368: ARRAY
92369: PPUSH
92370: CALL_OW 2
92374: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
92375: LD_ADDR_VAR 0 4
92379: PUSH
92380: LD_VAR 0 4
92384: PUSH
92385: LD_VAR 0 9
92389: PUSH
92390: LD_VAR 0 3
92394: ARRAY
92395: DIFF
92396: ST_TO_ADDR
// end ;
92397: GO 92306
92399: POP
92400: POP
// if p then
92401: LD_VAR 0 11
92405: IFFALSE 92430
// result := Replace ( result , 4 , p ) ;
92407: LD_ADDR_VAR 0 2
92411: PUSH
92412: LD_VAR 0 2
92416: PPUSH
92417: LD_INT 4
92419: PPUSH
92420: LD_VAR 0 11
92424: PPUSH
92425: CALL_OW 1
92429: ST_TO_ADDR
// end ; if tmp and mech < 6 then
92430: LD_VAR 0 4
92434: PUSH
92435: LD_VAR 0 7
92439: PUSH
92440: LD_INT 6
92442: LESS
92443: AND
92444: IFFALSE 92632
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
92446: LD_ADDR_VAR 0 9
92450: PUSH
92451: LD_VAR 0 4
92455: PUSH
92456: LD_VAR 0 8
92460: PUSH
92461: LD_VAR 0 7
92465: UNION
92466: DIFF
92467: PPUSH
92468: LD_INT 3
92470: PPUSH
92471: CALL 54467 0 2
92475: ST_TO_ADDR
// p := [ ] ;
92476: LD_ADDR_VAR 0 11
92480: PUSH
92481: EMPTY
92482: ST_TO_ADDR
// if sort then
92483: LD_VAR 0 9
92487: IFFALSE 92603
// for i = 1 to 6 - mech do
92489: LD_ADDR_VAR 0 3
92493: PUSH
92494: DOUBLE
92495: LD_INT 1
92497: DEC
92498: ST_TO_ADDR
92499: LD_INT 6
92501: PUSH
92502: LD_VAR 0 7
92506: MINUS
92507: PUSH
92508: FOR_TO
92509: IFFALSE 92601
// begin if i = sort then
92511: LD_VAR 0 3
92515: PUSH
92516: LD_VAR 0 9
92520: EQUAL
92521: IFFALSE 92525
// break ;
92523: GO 92601
// if GetClass ( i ) = 3 then
92525: LD_VAR 0 3
92529: PPUSH
92530: CALL_OW 257
92534: PUSH
92535: LD_INT 3
92537: EQUAL
92538: IFFALSE 92542
// continue ;
92540: GO 92508
// p := Insert ( p , p + 1 , sort [ i ] ) ;
92542: LD_ADDR_VAR 0 11
92546: PUSH
92547: LD_VAR 0 11
92551: PPUSH
92552: LD_VAR 0 11
92556: PUSH
92557: LD_INT 1
92559: PLUS
92560: PPUSH
92561: LD_VAR 0 9
92565: PUSH
92566: LD_VAR 0 3
92570: ARRAY
92571: PPUSH
92572: CALL_OW 2
92576: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
92577: LD_ADDR_VAR 0 4
92581: PUSH
92582: LD_VAR 0 4
92586: PUSH
92587: LD_VAR 0 9
92591: PUSH
92592: LD_VAR 0 3
92596: ARRAY
92597: DIFF
92598: ST_TO_ADDR
// end ;
92599: GO 92508
92601: POP
92602: POP
// if p then
92603: LD_VAR 0 11
92607: IFFALSE 92632
// result := Replace ( result , 3 , p ) ;
92609: LD_ADDR_VAR 0 2
92613: PUSH
92614: LD_VAR 0 2
92618: PPUSH
92619: LD_INT 3
92621: PPUSH
92622: LD_VAR 0 11
92626: PPUSH
92627: CALL_OW 1
92631: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
92632: LD_VAR 0 4
92636: PUSH
92637: LD_INT 6
92639: GREATER
92640: PUSH
92641: LD_VAR 0 6
92645: PUSH
92646: LD_INT 6
92648: LESS
92649: AND
92650: IFFALSE 92844
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
92652: LD_ADDR_VAR 0 9
92656: PUSH
92657: LD_VAR 0 4
92661: PUSH
92662: LD_VAR 0 8
92666: PUSH
92667: LD_VAR 0 7
92671: UNION
92672: PUSH
92673: LD_VAR 0 6
92677: UNION
92678: DIFF
92679: PPUSH
92680: LD_INT 2
92682: PPUSH
92683: CALL 54467 0 2
92687: ST_TO_ADDR
// p := [ ] ;
92688: LD_ADDR_VAR 0 11
92692: PUSH
92693: EMPTY
92694: ST_TO_ADDR
// if sort then
92695: LD_VAR 0 9
92699: IFFALSE 92815
// for i = 1 to 6 - eng do
92701: LD_ADDR_VAR 0 3
92705: PUSH
92706: DOUBLE
92707: LD_INT 1
92709: DEC
92710: ST_TO_ADDR
92711: LD_INT 6
92713: PUSH
92714: LD_VAR 0 6
92718: MINUS
92719: PUSH
92720: FOR_TO
92721: IFFALSE 92813
// begin if i = sort then
92723: LD_VAR 0 3
92727: PUSH
92728: LD_VAR 0 9
92732: EQUAL
92733: IFFALSE 92737
// break ;
92735: GO 92813
// if GetClass ( i ) = 2 then
92737: LD_VAR 0 3
92741: PPUSH
92742: CALL_OW 257
92746: PUSH
92747: LD_INT 2
92749: EQUAL
92750: IFFALSE 92754
// continue ;
92752: GO 92720
// p := Insert ( p , p + 1 , sort [ i ] ) ;
92754: LD_ADDR_VAR 0 11
92758: PUSH
92759: LD_VAR 0 11
92763: PPUSH
92764: LD_VAR 0 11
92768: PUSH
92769: LD_INT 1
92771: PLUS
92772: PPUSH
92773: LD_VAR 0 9
92777: PUSH
92778: LD_VAR 0 3
92782: ARRAY
92783: PPUSH
92784: CALL_OW 2
92788: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
92789: LD_ADDR_VAR 0 4
92793: PUSH
92794: LD_VAR 0 4
92798: PUSH
92799: LD_VAR 0 9
92803: PUSH
92804: LD_VAR 0 3
92808: ARRAY
92809: DIFF
92810: ST_TO_ADDR
// end ;
92811: GO 92720
92813: POP
92814: POP
// if p then
92815: LD_VAR 0 11
92819: IFFALSE 92844
// result := Replace ( result , 2 , p ) ;
92821: LD_ADDR_VAR 0 2
92825: PUSH
92826: LD_VAR 0 2
92830: PPUSH
92831: LD_INT 2
92833: PPUSH
92834: LD_VAR 0 11
92838: PPUSH
92839: CALL_OW 1
92843: ST_TO_ADDR
// end ; exit ;
92844: GO 94232
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
92846: LD_EXP 204
92850: PUSH
92851: LD_EXP 203
92855: PUSH
92856: LD_VAR 0 1
92860: ARRAY
92861: ARRAY
92862: NOT
92863: PUSH
92864: LD_EXP 177
92868: PUSH
92869: LD_VAR 0 1
92873: ARRAY
92874: PPUSH
92875: LD_INT 30
92877: PUSH
92878: LD_INT 3
92880: PUSH
92881: EMPTY
92882: LIST
92883: LIST
92884: PPUSH
92885: CALL_OW 72
92889: AND
92890: PUSH
92891: LD_EXP 182
92895: PUSH
92896: LD_VAR 0 1
92900: ARRAY
92901: AND
92902: IFFALSE 93510
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
92904: LD_ADDR_EXP 219
92908: PUSH
92909: LD_EXP 219
92913: PPUSH
92914: LD_VAR 0 1
92918: PPUSH
92919: LD_INT 5
92921: PPUSH
92922: CALL_OW 1
92926: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
92927: LD_ADDR_VAR 0 2
92931: PUSH
92932: LD_INT 0
92934: PUSH
92935: LD_INT 0
92937: PUSH
92938: LD_INT 0
92940: PUSH
92941: LD_INT 0
92943: PUSH
92944: EMPTY
92945: LIST
92946: LIST
92947: LIST
92948: LIST
92949: ST_TO_ADDR
// if sci > 1 then
92950: LD_VAR 0 8
92954: PUSH
92955: LD_INT 1
92957: GREATER
92958: IFFALSE 92986
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
92960: LD_ADDR_VAR 0 4
92964: PUSH
92965: LD_VAR 0 4
92969: PUSH
92970: LD_VAR 0 8
92974: PUSH
92975: LD_VAR 0 8
92979: PUSH
92980: LD_INT 1
92982: ARRAY
92983: DIFF
92984: DIFF
92985: ST_TO_ADDR
// if tmp and not sci then
92986: LD_VAR 0 4
92990: PUSH
92991: LD_VAR 0 8
92995: NOT
92996: AND
92997: IFFALSE 93066
// begin sort := SortBySkill ( tmp , 4 ) ;
92999: LD_ADDR_VAR 0 9
93003: PUSH
93004: LD_VAR 0 4
93008: PPUSH
93009: LD_INT 4
93011: PPUSH
93012: CALL 54467 0 2
93016: ST_TO_ADDR
// if sort then
93017: LD_VAR 0 9
93021: IFFALSE 93037
// p := sort [ 1 ] ;
93023: LD_ADDR_VAR 0 11
93027: PUSH
93028: LD_VAR 0 9
93032: PUSH
93033: LD_INT 1
93035: ARRAY
93036: ST_TO_ADDR
// if p then
93037: LD_VAR 0 11
93041: IFFALSE 93066
// result := Replace ( result , 4 , p ) ;
93043: LD_ADDR_VAR 0 2
93047: PUSH
93048: LD_VAR 0 2
93052: PPUSH
93053: LD_INT 4
93055: PPUSH
93056: LD_VAR 0 11
93060: PPUSH
93061: CALL_OW 1
93065: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
93066: LD_ADDR_VAR 0 4
93070: PUSH
93071: LD_VAR 0 4
93075: PUSH
93076: LD_VAR 0 7
93080: DIFF
93081: ST_TO_ADDR
// if tmp and mech < 6 then
93082: LD_VAR 0 4
93086: PUSH
93087: LD_VAR 0 7
93091: PUSH
93092: LD_INT 6
93094: LESS
93095: AND
93096: IFFALSE 93284
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
93098: LD_ADDR_VAR 0 9
93102: PUSH
93103: LD_VAR 0 4
93107: PUSH
93108: LD_VAR 0 8
93112: PUSH
93113: LD_VAR 0 7
93117: UNION
93118: DIFF
93119: PPUSH
93120: LD_INT 3
93122: PPUSH
93123: CALL 54467 0 2
93127: ST_TO_ADDR
// p := [ ] ;
93128: LD_ADDR_VAR 0 11
93132: PUSH
93133: EMPTY
93134: ST_TO_ADDR
// if sort then
93135: LD_VAR 0 9
93139: IFFALSE 93255
// for i = 1 to 6 - mech do
93141: LD_ADDR_VAR 0 3
93145: PUSH
93146: DOUBLE
93147: LD_INT 1
93149: DEC
93150: ST_TO_ADDR
93151: LD_INT 6
93153: PUSH
93154: LD_VAR 0 7
93158: MINUS
93159: PUSH
93160: FOR_TO
93161: IFFALSE 93253
// begin if i = sort then
93163: LD_VAR 0 3
93167: PUSH
93168: LD_VAR 0 9
93172: EQUAL
93173: IFFALSE 93177
// break ;
93175: GO 93253
// if GetClass ( i ) = 3 then
93177: LD_VAR 0 3
93181: PPUSH
93182: CALL_OW 257
93186: PUSH
93187: LD_INT 3
93189: EQUAL
93190: IFFALSE 93194
// continue ;
93192: GO 93160
// p := Insert ( p , p + 1 , sort [ i ] ) ;
93194: LD_ADDR_VAR 0 11
93198: PUSH
93199: LD_VAR 0 11
93203: PPUSH
93204: LD_VAR 0 11
93208: PUSH
93209: LD_INT 1
93211: PLUS
93212: PPUSH
93213: LD_VAR 0 9
93217: PUSH
93218: LD_VAR 0 3
93222: ARRAY
93223: PPUSH
93224: CALL_OW 2
93228: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
93229: LD_ADDR_VAR 0 4
93233: PUSH
93234: LD_VAR 0 4
93238: PUSH
93239: LD_VAR 0 9
93243: PUSH
93244: LD_VAR 0 3
93248: ARRAY
93249: DIFF
93250: ST_TO_ADDR
// end ;
93251: GO 93160
93253: POP
93254: POP
// if p then
93255: LD_VAR 0 11
93259: IFFALSE 93284
// result := Replace ( result , 3 , p ) ;
93261: LD_ADDR_VAR 0 2
93265: PUSH
93266: LD_VAR 0 2
93270: PPUSH
93271: LD_INT 3
93273: PPUSH
93274: LD_VAR 0 11
93278: PPUSH
93279: CALL_OW 1
93283: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
93284: LD_ADDR_VAR 0 4
93288: PUSH
93289: LD_VAR 0 4
93293: PUSH
93294: LD_VAR 0 6
93298: DIFF
93299: ST_TO_ADDR
// if tmp and eng < 6 then
93300: LD_VAR 0 4
93304: PUSH
93305: LD_VAR 0 6
93309: PUSH
93310: LD_INT 6
93312: LESS
93313: AND
93314: IFFALSE 93508
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
93316: LD_ADDR_VAR 0 9
93320: PUSH
93321: LD_VAR 0 4
93325: PUSH
93326: LD_VAR 0 8
93330: PUSH
93331: LD_VAR 0 7
93335: UNION
93336: PUSH
93337: LD_VAR 0 6
93341: UNION
93342: DIFF
93343: PPUSH
93344: LD_INT 2
93346: PPUSH
93347: CALL 54467 0 2
93351: ST_TO_ADDR
// p := [ ] ;
93352: LD_ADDR_VAR 0 11
93356: PUSH
93357: EMPTY
93358: ST_TO_ADDR
// if sort then
93359: LD_VAR 0 9
93363: IFFALSE 93479
// for i = 1 to 6 - eng do
93365: LD_ADDR_VAR 0 3
93369: PUSH
93370: DOUBLE
93371: LD_INT 1
93373: DEC
93374: ST_TO_ADDR
93375: LD_INT 6
93377: PUSH
93378: LD_VAR 0 6
93382: MINUS
93383: PUSH
93384: FOR_TO
93385: IFFALSE 93477
// begin if i = sort then
93387: LD_VAR 0 3
93391: PUSH
93392: LD_VAR 0 9
93396: EQUAL
93397: IFFALSE 93401
// break ;
93399: GO 93477
// if GetClass ( i ) = 2 then
93401: LD_VAR 0 3
93405: PPUSH
93406: CALL_OW 257
93410: PUSH
93411: LD_INT 2
93413: EQUAL
93414: IFFALSE 93418
// continue ;
93416: GO 93384
// p := Insert ( p , p + 1 , sort [ i ] ) ;
93418: LD_ADDR_VAR 0 11
93422: PUSH
93423: LD_VAR 0 11
93427: PPUSH
93428: LD_VAR 0 11
93432: PUSH
93433: LD_INT 1
93435: PLUS
93436: PPUSH
93437: LD_VAR 0 9
93441: PUSH
93442: LD_VAR 0 3
93446: ARRAY
93447: PPUSH
93448: CALL_OW 2
93452: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
93453: LD_ADDR_VAR 0 4
93457: PUSH
93458: LD_VAR 0 4
93462: PUSH
93463: LD_VAR 0 9
93467: PUSH
93468: LD_VAR 0 3
93472: ARRAY
93473: DIFF
93474: ST_TO_ADDR
// end ;
93475: GO 93384
93477: POP
93478: POP
// if p then
93479: LD_VAR 0 11
93483: IFFALSE 93508
// result := Replace ( result , 2 , p ) ;
93485: LD_ADDR_VAR 0 2
93489: PUSH
93490: LD_VAR 0 2
93494: PPUSH
93495: LD_INT 2
93497: PPUSH
93498: LD_VAR 0 11
93502: PPUSH
93503: CALL_OW 1
93507: ST_TO_ADDR
// end ; exit ;
93508: GO 94232
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
93510: LD_EXP 204
93514: PUSH
93515: LD_EXP 203
93519: PUSH
93520: LD_VAR 0 1
93524: ARRAY
93525: ARRAY
93526: NOT
93527: PUSH
93528: LD_EXP 177
93532: PUSH
93533: LD_VAR 0 1
93537: ARRAY
93538: PPUSH
93539: LD_INT 30
93541: PUSH
93542: LD_INT 3
93544: PUSH
93545: EMPTY
93546: LIST
93547: LIST
93548: PPUSH
93549: CALL_OW 72
93553: AND
93554: PUSH
93555: LD_EXP 182
93559: PUSH
93560: LD_VAR 0 1
93564: ARRAY
93565: NOT
93566: AND
93567: IFFALSE 94232
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
93569: LD_ADDR_EXP 219
93573: PUSH
93574: LD_EXP 219
93578: PPUSH
93579: LD_VAR 0 1
93583: PPUSH
93584: LD_INT 6
93586: PPUSH
93587: CALL_OW 1
93591: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
93592: LD_ADDR_VAR 0 2
93596: PUSH
93597: LD_INT 0
93599: PUSH
93600: LD_INT 0
93602: PUSH
93603: LD_INT 0
93605: PUSH
93606: LD_INT 0
93608: PUSH
93609: EMPTY
93610: LIST
93611: LIST
93612: LIST
93613: LIST
93614: ST_TO_ADDR
// if sci >= 1 then
93615: LD_VAR 0 8
93619: PUSH
93620: LD_INT 1
93622: GREATEREQUAL
93623: IFFALSE 93645
// tmp := tmp diff sci [ 1 ] ;
93625: LD_ADDR_VAR 0 4
93629: PUSH
93630: LD_VAR 0 4
93634: PUSH
93635: LD_VAR 0 8
93639: PUSH
93640: LD_INT 1
93642: ARRAY
93643: DIFF
93644: ST_TO_ADDR
// if tmp and not sci then
93645: LD_VAR 0 4
93649: PUSH
93650: LD_VAR 0 8
93654: NOT
93655: AND
93656: IFFALSE 93725
// begin sort := SortBySkill ( tmp , 4 ) ;
93658: LD_ADDR_VAR 0 9
93662: PUSH
93663: LD_VAR 0 4
93667: PPUSH
93668: LD_INT 4
93670: PPUSH
93671: CALL 54467 0 2
93675: ST_TO_ADDR
// if sort then
93676: LD_VAR 0 9
93680: IFFALSE 93696
// p := sort [ 1 ] ;
93682: LD_ADDR_VAR 0 11
93686: PUSH
93687: LD_VAR 0 9
93691: PUSH
93692: LD_INT 1
93694: ARRAY
93695: ST_TO_ADDR
// if p then
93696: LD_VAR 0 11
93700: IFFALSE 93725
// result := Replace ( result , 4 , p ) ;
93702: LD_ADDR_VAR 0 2
93706: PUSH
93707: LD_VAR 0 2
93711: PPUSH
93712: LD_INT 4
93714: PPUSH
93715: LD_VAR 0 11
93719: PPUSH
93720: CALL_OW 1
93724: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
93725: LD_ADDR_VAR 0 4
93729: PUSH
93730: LD_VAR 0 4
93734: PUSH
93735: LD_VAR 0 7
93739: DIFF
93740: ST_TO_ADDR
// if tmp and mech < 6 then
93741: LD_VAR 0 4
93745: PUSH
93746: LD_VAR 0 7
93750: PUSH
93751: LD_INT 6
93753: LESS
93754: AND
93755: IFFALSE 93937
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
93757: LD_ADDR_VAR 0 9
93761: PUSH
93762: LD_VAR 0 4
93766: PUSH
93767: LD_VAR 0 7
93771: DIFF
93772: PPUSH
93773: LD_INT 3
93775: PPUSH
93776: CALL 54467 0 2
93780: ST_TO_ADDR
// p := [ ] ;
93781: LD_ADDR_VAR 0 11
93785: PUSH
93786: EMPTY
93787: ST_TO_ADDR
// if sort then
93788: LD_VAR 0 9
93792: IFFALSE 93908
// for i = 1 to 6 - mech do
93794: LD_ADDR_VAR 0 3
93798: PUSH
93799: DOUBLE
93800: LD_INT 1
93802: DEC
93803: ST_TO_ADDR
93804: LD_INT 6
93806: PUSH
93807: LD_VAR 0 7
93811: MINUS
93812: PUSH
93813: FOR_TO
93814: IFFALSE 93906
// begin if i = sort then
93816: LD_VAR 0 3
93820: PUSH
93821: LD_VAR 0 9
93825: EQUAL
93826: IFFALSE 93830
// break ;
93828: GO 93906
// if GetClass ( i ) = 3 then
93830: LD_VAR 0 3
93834: PPUSH
93835: CALL_OW 257
93839: PUSH
93840: LD_INT 3
93842: EQUAL
93843: IFFALSE 93847
// continue ;
93845: GO 93813
// p := Insert ( p , p + 1 , sort [ i ] ) ;
93847: LD_ADDR_VAR 0 11
93851: PUSH
93852: LD_VAR 0 11
93856: PPUSH
93857: LD_VAR 0 11
93861: PUSH
93862: LD_INT 1
93864: PLUS
93865: PPUSH
93866: LD_VAR 0 9
93870: PUSH
93871: LD_VAR 0 3
93875: ARRAY
93876: PPUSH
93877: CALL_OW 2
93881: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
93882: LD_ADDR_VAR 0 4
93886: PUSH
93887: LD_VAR 0 4
93891: PUSH
93892: LD_VAR 0 9
93896: PUSH
93897: LD_VAR 0 3
93901: ARRAY
93902: DIFF
93903: ST_TO_ADDR
// end ;
93904: GO 93813
93906: POP
93907: POP
// if p then
93908: LD_VAR 0 11
93912: IFFALSE 93937
// result := Replace ( result , 3 , p ) ;
93914: LD_ADDR_VAR 0 2
93918: PUSH
93919: LD_VAR 0 2
93923: PPUSH
93924: LD_INT 3
93926: PPUSH
93927: LD_VAR 0 11
93931: PPUSH
93932: CALL_OW 1
93936: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
93937: LD_ADDR_VAR 0 4
93941: PUSH
93942: LD_VAR 0 4
93946: PUSH
93947: LD_VAR 0 6
93951: DIFF
93952: ST_TO_ADDR
// if tmp and eng < 4 then
93953: LD_VAR 0 4
93957: PUSH
93958: LD_VAR 0 6
93962: PUSH
93963: LD_INT 4
93965: LESS
93966: AND
93967: IFFALSE 94157
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
93969: LD_ADDR_VAR 0 9
93973: PUSH
93974: LD_VAR 0 4
93978: PUSH
93979: LD_VAR 0 7
93983: PUSH
93984: LD_VAR 0 6
93988: UNION
93989: DIFF
93990: PPUSH
93991: LD_INT 2
93993: PPUSH
93994: CALL 54467 0 2
93998: ST_TO_ADDR
// p := [ ] ;
93999: LD_ADDR_VAR 0 11
94003: PUSH
94004: EMPTY
94005: ST_TO_ADDR
// if sort then
94006: LD_VAR 0 9
94010: IFFALSE 94126
// for i = 1 to 4 - eng do
94012: LD_ADDR_VAR 0 3
94016: PUSH
94017: DOUBLE
94018: LD_INT 1
94020: DEC
94021: ST_TO_ADDR
94022: LD_INT 4
94024: PUSH
94025: LD_VAR 0 6
94029: MINUS
94030: PUSH
94031: FOR_TO
94032: IFFALSE 94124
// begin if i = sort then
94034: LD_VAR 0 3
94038: PUSH
94039: LD_VAR 0 9
94043: EQUAL
94044: IFFALSE 94048
// break ;
94046: GO 94124
// if GetClass ( i ) = 2 then
94048: LD_VAR 0 3
94052: PPUSH
94053: CALL_OW 257
94057: PUSH
94058: LD_INT 2
94060: EQUAL
94061: IFFALSE 94065
// continue ;
94063: GO 94031
// p := Insert ( p , p + 1 , sort [ i ] ) ;
94065: LD_ADDR_VAR 0 11
94069: PUSH
94070: LD_VAR 0 11
94074: PPUSH
94075: LD_VAR 0 11
94079: PUSH
94080: LD_INT 1
94082: PLUS
94083: PPUSH
94084: LD_VAR 0 9
94088: PUSH
94089: LD_VAR 0 3
94093: ARRAY
94094: PPUSH
94095: CALL_OW 2
94099: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
94100: LD_ADDR_VAR 0 4
94104: PUSH
94105: LD_VAR 0 4
94109: PUSH
94110: LD_VAR 0 9
94114: PUSH
94115: LD_VAR 0 3
94119: ARRAY
94120: DIFF
94121: ST_TO_ADDR
// end ;
94122: GO 94031
94124: POP
94125: POP
// if p then
94126: LD_VAR 0 11
94130: IFFALSE 94155
// result := Replace ( result , 2 , p ) ;
94132: LD_ADDR_VAR 0 2
94136: PUSH
94137: LD_VAR 0 2
94141: PPUSH
94142: LD_INT 2
94144: PPUSH
94145: LD_VAR 0 11
94149: PPUSH
94150: CALL_OW 1
94154: ST_TO_ADDR
// end else
94155: GO 94201
// for i = eng downto 5 do
94157: LD_ADDR_VAR 0 3
94161: PUSH
94162: DOUBLE
94163: LD_VAR 0 6
94167: INC
94168: ST_TO_ADDR
94169: LD_INT 5
94171: PUSH
94172: FOR_DOWNTO
94173: IFFALSE 94199
// tmp := tmp union eng [ i ] ;
94175: LD_ADDR_VAR 0 4
94179: PUSH
94180: LD_VAR 0 4
94184: PUSH
94185: LD_VAR 0 6
94189: PUSH
94190: LD_VAR 0 3
94194: ARRAY
94195: UNION
94196: ST_TO_ADDR
94197: GO 94172
94199: POP
94200: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
94201: LD_ADDR_VAR 0 2
94205: PUSH
94206: LD_VAR 0 2
94210: PPUSH
94211: LD_INT 1
94213: PPUSH
94214: LD_VAR 0 4
94218: PUSH
94219: LD_VAR 0 5
94223: DIFF
94224: PPUSH
94225: CALL_OW 1
94229: ST_TO_ADDR
// exit ;
94230: GO 94232
// end ; end ;
94232: LD_VAR 0 2
94236: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
94237: LD_INT 0
94239: PPUSH
94240: PPUSH
94241: PPUSH
// if not mc_bases then
94242: LD_EXP 177
94246: NOT
94247: IFFALSE 94251
// exit ;
94249: GO 94393
// for i = 1 to mc_bases do
94251: LD_ADDR_VAR 0 2
94255: PUSH
94256: DOUBLE
94257: LD_INT 1
94259: DEC
94260: ST_TO_ADDR
94261: LD_EXP 177
94265: PUSH
94266: FOR_TO
94267: IFFALSE 94384
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
94269: LD_ADDR_VAR 0 3
94273: PUSH
94274: LD_EXP 177
94278: PUSH
94279: LD_VAR 0 2
94283: ARRAY
94284: PPUSH
94285: LD_INT 21
94287: PUSH
94288: LD_INT 3
94290: PUSH
94291: EMPTY
94292: LIST
94293: LIST
94294: PUSH
94295: LD_INT 3
94297: PUSH
94298: LD_INT 2
94300: PUSH
94301: LD_INT 30
94303: PUSH
94304: LD_INT 29
94306: PUSH
94307: EMPTY
94308: LIST
94309: LIST
94310: PUSH
94311: LD_INT 30
94313: PUSH
94314: LD_INT 30
94316: PUSH
94317: EMPTY
94318: LIST
94319: LIST
94320: PUSH
94321: EMPTY
94322: LIST
94323: LIST
94324: LIST
94325: PUSH
94326: EMPTY
94327: LIST
94328: LIST
94329: PUSH
94330: LD_INT 3
94332: PUSH
94333: LD_INT 24
94335: PUSH
94336: LD_INT 1000
94338: PUSH
94339: EMPTY
94340: LIST
94341: LIST
94342: PUSH
94343: EMPTY
94344: LIST
94345: LIST
94346: PUSH
94347: EMPTY
94348: LIST
94349: LIST
94350: LIST
94351: PPUSH
94352: CALL_OW 72
94356: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
94357: LD_ADDR_EXP 178
94361: PUSH
94362: LD_EXP 178
94366: PPUSH
94367: LD_VAR 0 2
94371: PPUSH
94372: LD_VAR 0 3
94376: PPUSH
94377: CALL_OW 1
94381: ST_TO_ADDR
// end ;
94382: GO 94266
94384: POP
94385: POP
// RaiseSailEvent ( 101 ) ;
94386: LD_INT 101
94388: PPUSH
94389: CALL_OW 427
// end ;
94393: LD_VAR 0 1
94397: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
94398: LD_INT 0
94400: PPUSH
94401: PPUSH
94402: PPUSH
94403: PPUSH
94404: PPUSH
94405: PPUSH
94406: PPUSH
// if not mc_bases then
94407: LD_EXP 177
94411: NOT
94412: IFFALSE 94416
// exit ;
94414: GO 94978
// for i = 1 to mc_bases do
94416: LD_ADDR_VAR 0 2
94420: PUSH
94421: DOUBLE
94422: LD_INT 1
94424: DEC
94425: ST_TO_ADDR
94426: LD_EXP 177
94430: PUSH
94431: FOR_TO
94432: IFFALSE 94969
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 1000 ] ] ] ] ) ;
94434: LD_ADDR_VAR 0 5
94438: PUSH
94439: LD_EXP 177
94443: PUSH
94444: LD_VAR 0 2
94448: ARRAY
94449: PUSH
94450: LD_EXP 206
94454: PUSH
94455: LD_VAR 0 2
94459: ARRAY
94460: UNION
94461: PPUSH
94462: LD_INT 21
94464: PUSH
94465: LD_INT 1
94467: PUSH
94468: EMPTY
94469: LIST
94470: LIST
94471: PUSH
94472: LD_INT 1
94474: PUSH
94475: LD_INT 3
94477: PUSH
94478: LD_INT 54
94480: PUSH
94481: EMPTY
94482: LIST
94483: PUSH
94484: EMPTY
94485: LIST
94486: LIST
94487: PUSH
94488: LD_INT 3
94490: PUSH
94491: LD_INT 24
94493: PUSH
94494: LD_INT 1000
94496: PUSH
94497: EMPTY
94498: LIST
94499: LIST
94500: PUSH
94501: EMPTY
94502: LIST
94503: LIST
94504: PUSH
94505: EMPTY
94506: LIST
94507: LIST
94508: LIST
94509: PUSH
94510: EMPTY
94511: LIST
94512: LIST
94513: PPUSH
94514: CALL_OW 72
94518: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
94519: LD_ADDR_VAR 0 6
94523: PUSH
94524: LD_EXP 177
94528: PUSH
94529: LD_VAR 0 2
94533: ARRAY
94534: PPUSH
94535: LD_INT 21
94537: PUSH
94538: LD_INT 1
94540: PUSH
94541: EMPTY
94542: LIST
94543: LIST
94544: PUSH
94545: LD_INT 1
94547: PUSH
94548: LD_INT 3
94550: PUSH
94551: LD_INT 54
94553: PUSH
94554: EMPTY
94555: LIST
94556: PUSH
94557: EMPTY
94558: LIST
94559: LIST
94560: PUSH
94561: LD_INT 3
94563: PUSH
94564: LD_INT 24
94566: PUSH
94567: LD_INT 250
94569: PUSH
94570: EMPTY
94571: LIST
94572: LIST
94573: PUSH
94574: EMPTY
94575: LIST
94576: LIST
94577: PUSH
94578: EMPTY
94579: LIST
94580: LIST
94581: LIST
94582: PUSH
94583: EMPTY
94584: LIST
94585: LIST
94586: PPUSH
94587: CALL_OW 72
94591: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
94592: LD_ADDR_VAR 0 7
94596: PUSH
94597: LD_VAR 0 5
94601: PUSH
94602: LD_VAR 0 6
94606: DIFF
94607: ST_TO_ADDR
// if not need_heal_1 then
94608: LD_VAR 0 6
94612: NOT
94613: IFFALSE 94646
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
94615: LD_ADDR_EXP 180
94619: PUSH
94620: LD_EXP 180
94624: PPUSH
94625: LD_VAR 0 2
94629: PUSH
94630: LD_INT 1
94632: PUSH
94633: EMPTY
94634: LIST
94635: LIST
94636: PPUSH
94637: EMPTY
94638: PPUSH
94639: CALL 24210 0 3
94643: ST_TO_ADDR
94644: GO 94716
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
94646: LD_ADDR_EXP 180
94650: PUSH
94651: LD_EXP 180
94655: PPUSH
94656: LD_VAR 0 2
94660: PUSH
94661: LD_INT 1
94663: PUSH
94664: EMPTY
94665: LIST
94666: LIST
94667: PPUSH
94668: LD_EXP 180
94672: PUSH
94673: LD_VAR 0 2
94677: ARRAY
94678: PUSH
94679: LD_INT 1
94681: ARRAY
94682: PPUSH
94683: LD_INT 3
94685: PUSH
94686: LD_INT 24
94688: PUSH
94689: LD_INT 1000
94691: PUSH
94692: EMPTY
94693: LIST
94694: LIST
94695: PUSH
94696: EMPTY
94697: LIST
94698: LIST
94699: PPUSH
94700: CALL_OW 72
94704: PUSH
94705: LD_VAR 0 6
94709: UNION
94710: PPUSH
94711: CALL 24210 0 3
94715: ST_TO_ADDR
// if not need_heal_2 then
94716: LD_VAR 0 7
94720: NOT
94721: IFFALSE 94754
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
94723: LD_ADDR_EXP 180
94727: PUSH
94728: LD_EXP 180
94732: PPUSH
94733: LD_VAR 0 2
94737: PUSH
94738: LD_INT 2
94740: PUSH
94741: EMPTY
94742: LIST
94743: LIST
94744: PPUSH
94745: EMPTY
94746: PPUSH
94747: CALL 24210 0 3
94751: ST_TO_ADDR
94752: GO 94786
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
94754: LD_ADDR_EXP 180
94758: PUSH
94759: LD_EXP 180
94763: PPUSH
94764: LD_VAR 0 2
94768: PUSH
94769: LD_INT 2
94771: PUSH
94772: EMPTY
94773: LIST
94774: LIST
94775: PPUSH
94776: LD_VAR 0 7
94780: PPUSH
94781: CALL 24210 0 3
94785: ST_TO_ADDR
// if need_heal_2 then
94786: LD_VAR 0 7
94790: IFFALSE 94951
// for j in need_heal_2 do
94792: LD_ADDR_VAR 0 3
94796: PUSH
94797: LD_VAR 0 7
94801: PUSH
94802: FOR_IN
94803: IFFALSE 94949
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
94805: LD_ADDR_VAR 0 5
94809: PUSH
94810: LD_EXP 177
94814: PUSH
94815: LD_VAR 0 2
94819: ARRAY
94820: PPUSH
94821: LD_INT 2
94823: PUSH
94824: LD_INT 30
94826: PUSH
94827: LD_INT 6
94829: PUSH
94830: EMPTY
94831: LIST
94832: LIST
94833: PUSH
94834: LD_INT 30
94836: PUSH
94837: LD_INT 7
94839: PUSH
94840: EMPTY
94841: LIST
94842: LIST
94843: PUSH
94844: LD_INT 30
94846: PUSH
94847: LD_INT 8
94849: PUSH
94850: EMPTY
94851: LIST
94852: LIST
94853: PUSH
94854: LD_INT 30
94856: PUSH
94857: LD_INT 0
94859: PUSH
94860: EMPTY
94861: LIST
94862: LIST
94863: PUSH
94864: LD_INT 30
94866: PUSH
94867: LD_INT 1
94869: PUSH
94870: EMPTY
94871: LIST
94872: LIST
94873: PUSH
94874: EMPTY
94875: LIST
94876: LIST
94877: LIST
94878: LIST
94879: LIST
94880: LIST
94881: PPUSH
94882: CALL_OW 72
94886: ST_TO_ADDR
// if tmp then
94887: LD_VAR 0 5
94891: IFFALSE 94947
// begin k := NearestUnitToUnit ( tmp , j ) ;
94893: LD_ADDR_VAR 0 4
94897: PUSH
94898: LD_VAR 0 5
94902: PPUSH
94903: LD_VAR 0 3
94907: PPUSH
94908: CALL_OW 74
94912: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 5 then
94913: LD_VAR 0 3
94917: PPUSH
94918: LD_VAR 0 4
94922: PPUSH
94923: CALL_OW 296
94927: PUSH
94928: LD_INT 5
94930: GREATER
94931: IFFALSE 94947
// ComMoveToNearbyEntrance ( j , k ) ;
94933: LD_VAR 0 3
94937: PPUSH
94938: LD_VAR 0 4
94942: PPUSH
94943: CALL 56828 0 2
// end ; end ;
94947: GO 94802
94949: POP
94950: POP
// if not need_heal_1 and not need_heal_2 then
94951: LD_VAR 0 6
94955: NOT
94956: PUSH
94957: LD_VAR 0 7
94961: NOT
94962: AND
94963: IFFALSE 94967
// continue ;
94965: GO 94431
// end ;
94967: GO 94431
94969: POP
94970: POP
// RaiseSailEvent ( 102 ) ;
94971: LD_INT 102
94973: PPUSH
94974: CALL_OW 427
// end ;
94978: LD_VAR 0 1
94982: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes , to_repair_tmp , to_repair ; begin
94983: LD_INT 0
94985: PPUSH
94986: PPUSH
94987: PPUSH
94988: PPUSH
94989: PPUSH
94990: PPUSH
94991: PPUSH
94992: PPUSH
// if not mc_bases then
94993: LD_EXP 177
94997: NOT
94998: IFFALSE 95002
// exit ;
95000: GO 95885
// for i = 1 to mc_bases do
95002: LD_ADDR_VAR 0 2
95006: PUSH
95007: DOUBLE
95008: LD_INT 1
95010: DEC
95011: ST_TO_ADDR
95012: LD_EXP 177
95016: PUSH
95017: FOR_TO
95018: IFFALSE 95883
// begin if not mc_building_need_repair [ i ] then
95020: LD_EXP 178
95024: PUSH
95025: LD_VAR 0 2
95029: ARRAY
95030: NOT
95031: IFFALSE 95218
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ] ) ;
95033: LD_ADDR_VAR 0 6
95037: PUSH
95038: LD_EXP 196
95042: PUSH
95043: LD_VAR 0 2
95047: ARRAY
95048: PPUSH
95049: LD_INT 3
95051: PUSH
95052: LD_INT 24
95054: PUSH
95055: LD_INT 1000
95057: PUSH
95058: EMPTY
95059: LIST
95060: LIST
95061: PUSH
95062: EMPTY
95063: LIST
95064: LIST
95065: PUSH
95066: LD_INT 2
95068: PUSH
95069: LD_INT 34
95071: PUSH
95072: LD_INT 13
95074: PUSH
95075: EMPTY
95076: LIST
95077: LIST
95078: PUSH
95079: LD_INT 34
95081: PUSH
95082: LD_INT 52
95084: PUSH
95085: EMPTY
95086: LIST
95087: LIST
95088: PUSH
95089: LD_INT 34
95091: PUSH
95092: LD_EXP 162
95096: PUSH
95097: EMPTY
95098: LIST
95099: LIST
95100: PUSH
95101: EMPTY
95102: LIST
95103: LIST
95104: LIST
95105: LIST
95106: PUSH
95107: EMPTY
95108: LIST
95109: LIST
95110: PPUSH
95111: CALL_OW 72
95115: ST_TO_ADDR
// if cranes then
95116: LD_VAR 0 6
95120: IFFALSE 95182
// for j in cranes do
95122: LD_ADDR_VAR 0 3
95126: PUSH
95127: LD_VAR 0 6
95131: PUSH
95132: FOR_IN
95133: IFFALSE 95180
// if not IsInArea ( j , mc_parking [ i ] ) then
95135: LD_VAR 0 3
95139: PPUSH
95140: LD_EXP 201
95144: PUSH
95145: LD_VAR 0 2
95149: ARRAY
95150: PPUSH
95151: CALL_OW 308
95155: NOT
95156: IFFALSE 95178
// ComMoveToArea ( j , mc_parking [ i ] ) ;
95158: LD_VAR 0 3
95162: PPUSH
95163: LD_EXP 201
95167: PUSH
95168: LD_VAR 0 2
95172: ARRAY
95173: PPUSH
95174: CALL_OW 113
95178: GO 95132
95180: POP
95181: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
95182: LD_ADDR_EXP 179
95186: PUSH
95187: LD_EXP 179
95191: PPUSH
95192: LD_VAR 0 2
95196: PPUSH
95197: EMPTY
95198: PPUSH
95199: CALL_OW 1
95203: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
95204: LD_VAR 0 2
95208: PPUSH
95209: LD_INT 101
95211: PPUSH
95212: CALL 90070 0 2
// continue ;
95216: GO 95017
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
95218: LD_ADDR_EXP 183
95222: PUSH
95223: LD_EXP 183
95227: PPUSH
95228: LD_VAR 0 2
95232: PPUSH
95233: EMPTY
95234: PPUSH
95235: CALL_OW 1
95239: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
95240: LD_VAR 0 2
95244: PPUSH
95245: LD_INT 103
95247: PPUSH
95248: CALL 90070 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) ;
95252: LD_ADDR_VAR 0 5
95256: PUSH
95257: LD_EXP 177
95261: PUSH
95262: LD_VAR 0 2
95266: ARRAY
95267: PUSH
95268: LD_EXP 206
95272: PUSH
95273: LD_VAR 0 2
95277: ARRAY
95278: UNION
95279: PPUSH
95280: LD_INT 2
95282: PUSH
95283: LD_INT 25
95285: PUSH
95286: LD_INT 2
95288: PUSH
95289: EMPTY
95290: LIST
95291: LIST
95292: PUSH
95293: LD_INT 25
95295: PUSH
95296: LD_INT 16
95298: PUSH
95299: EMPTY
95300: LIST
95301: LIST
95302: PUSH
95303: EMPTY
95304: LIST
95305: LIST
95306: LIST
95307: PUSH
95308: EMPTY
95309: LIST
95310: PPUSH
95311: CALL_OW 72
95315: ST_TO_ADDR
// if mc_need_heal [ i ] then
95316: LD_EXP 180
95320: PUSH
95321: LD_VAR 0 2
95325: ARRAY
95326: IFFALSE 95370
// tmp := tmp diff ( mc_need_heal [ i ] [ 1 ] union mc_need_heal [ i ] [ 2 ] ) ;
95328: LD_ADDR_VAR 0 5
95332: PUSH
95333: LD_VAR 0 5
95337: PUSH
95338: LD_EXP 180
95342: PUSH
95343: LD_VAR 0 2
95347: ARRAY
95348: PUSH
95349: LD_INT 1
95351: ARRAY
95352: PUSH
95353: LD_EXP 180
95357: PUSH
95358: LD_VAR 0 2
95362: ARRAY
95363: PUSH
95364: LD_INT 2
95366: ARRAY
95367: UNION
95368: DIFF
95369: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ) ;
95370: LD_ADDR_VAR 0 6
95374: PUSH
95375: LD_EXP 196
95379: PUSH
95380: LD_VAR 0 2
95384: ARRAY
95385: PPUSH
95386: LD_INT 2
95388: PUSH
95389: LD_INT 34
95391: PUSH
95392: LD_INT 13
95394: PUSH
95395: EMPTY
95396: LIST
95397: LIST
95398: PUSH
95399: LD_INT 34
95401: PUSH
95402: LD_INT 52
95404: PUSH
95405: EMPTY
95406: LIST
95407: LIST
95408: PUSH
95409: LD_INT 34
95411: PUSH
95412: LD_EXP 162
95416: PUSH
95417: EMPTY
95418: LIST
95419: LIST
95420: PUSH
95421: EMPTY
95422: LIST
95423: LIST
95424: LIST
95425: LIST
95426: PPUSH
95427: CALL_OW 72
95431: ST_TO_ADDR
// if cranes then
95432: LD_VAR 0 6
95436: IFFALSE 95572
// begin for j in cranes do
95438: LD_ADDR_VAR 0 3
95442: PUSH
95443: LD_VAR 0 6
95447: PUSH
95448: FOR_IN
95449: IFFALSE 95570
// begin if GetLives ( j ) = 1000 and not HasTask ( j ) then
95451: LD_VAR 0 3
95455: PPUSH
95456: CALL_OW 256
95460: PUSH
95461: LD_INT 1000
95463: EQUAL
95464: PUSH
95465: LD_VAR 0 3
95469: PPUSH
95470: CALL_OW 314
95474: NOT
95475: AND
95476: IFFALSE 95510
// ComRepairBuilding ( j , NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ) else
95478: LD_VAR 0 3
95482: PPUSH
95483: LD_EXP 178
95487: PUSH
95488: LD_VAR 0 2
95492: ARRAY
95493: PPUSH
95494: LD_VAR 0 3
95498: PPUSH
95499: CALL_OW 74
95503: PPUSH
95504: CALL_OW 130
95508: GO 95568
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
95510: LD_VAR 0 3
95514: PPUSH
95515: CALL_OW 256
95519: PUSH
95520: LD_INT 500
95522: LESS
95523: PUSH
95524: LD_VAR 0 3
95528: PPUSH
95529: LD_EXP 201
95533: PUSH
95534: LD_VAR 0 2
95538: ARRAY
95539: PPUSH
95540: CALL_OW 308
95544: NOT
95545: AND
95546: IFFALSE 95568
// ComMoveToArea ( j , mc_parking [ i ] ) ;
95548: LD_VAR 0 3
95552: PPUSH
95553: LD_EXP 201
95557: PUSH
95558: LD_VAR 0 2
95562: ARRAY
95563: PPUSH
95564: CALL_OW 113
// end ;
95568: GO 95448
95570: POP
95571: POP
// end ; if tmp > 3 then
95572: LD_VAR 0 5
95576: PUSH
95577: LD_INT 3
95579: GREATER
95580: IFFALSE 95600
// tmp := ShrinkArray ( tmp , 4 ) ;
95582: LD_ADDR_VAR 0 5
95586: PUSH
95587: LD_VAR 0 5
95591: PPUSH
95592: LD_INT 4
95594: PPUSH
95595: CALL 56276 0 2
95599: ST_TO_ADDR
// if not tmp then
95600: LD_VAR 0 5
95604: NOT
95605: IFFALSE 95609
// continue ;
95607: GO 95017
// for j in tmp do
95609: LD_ADDR_VAR 0 3
95613: PUSH
95614: LD_VAR 0 5
95618: PUSH
95619: FOR_IN
95620: IFFALSE 95879
// begin if IsInUnit ( j ) then
95622: LD_VAR 0 3
95626: PPUSH
95627: CALL_OW 310
95631: IFFALSE 95642
// ComExitBuilding ( j ) ;
95633: LD_VAR 0 3
95637: PPUSH
95638: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
95642: LD_VAR 0 3
95646: PUSH
95647: LD_EXP 179
95651: PUSH
95652: LD_VAR 0 2
95656: ARRAY
95657: IN
95658: NOT
95659: IFFALSE 95717
// begin SetTag ( j , 101 ) ;
95661: LD_VAR 0 3
95665: PPUSH
95666: LD_INT 101
95668: PPUSH
95669: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
95673: LD_ADDR_EXP 179
95677: PUSH
95678: LD_EXP 179
95682: PPUSH
95683: LD_VAR 0 2
95687: PUSH
95688: LD_EXP 179
95692: PUSH
95693: LD_VAR 0 2
95697: ARRAY
95698: PUSH
95699: LD_INT 1
95701: PLUS
95702: PUSH
95703: EMPTY
95704: LIST
95705: LIST
95706: PPUSH
95707: LD_VAR 0 3
95711: PPUSH
95712: CALL 24210 0 3
95716: ST_TO_ADDR
// end ; wait ( 1 ) ;
95717: LD_INT 1
95719: PPUSH
95720: CALL_OW 67
// to_repair_tmp := mc_building_need_repair [ i ] ;
95724: LD_ADDR_VAR 0 7
95728: PUSH
95729: LD_EXP 178
95733: PUSH
95734: LD_VAR 0 2
95738: ARRAY
95739: ST_TO_ADDR
// if mc_scan [ i ] then
95740: LD_EXP 200
95744: PUSH
95745: LD_VAR 0 2
95749: ARRAY
95750: IFFALSE 95812
// to_repair_tmp := UnitFilter ( mc_building_need_repair [ i ] , [ f_not , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_breastwork ] ] ) ;
95752: LD_ADDR_VAR 0 7
95756: PUSH
95757: LD_EXP 178
95761: PUSH
95762: LD_VAR 0 2
95766: ARRAY
95767: PPUSH
95768: LD_INT 3
95770: PUSH
95771: LD_INT 30
95773: PUSH
95774: LD_INT 32
95776: PUSH
95777: EMPTY
95778: LIST
95779: LIST
95780: PUSH
95781: LD_INT 30
95783: PUSH
95784: LD_INT 33
95786: PUSH
95787: EMPTY
95788: LIST
95789: LIST
95790: PUSH
95791: LD_INT 30
95793: PUSH
95794: LD_INT 31
95796: PUSH
95797: EMPTY
95798: LIST
95799: LIST
95800: PUSH
95801: EMPTY
95802: LIST
95803: LIST
95804: LIST
95805: LIST
95806: PPUSH
95807: CALL_OW 72
95811: ST_TO_ADDR
// if not to_repair_tmp then
95812: LD_VAR 0 7
95816: NOT
95817: IFFALSE 95821
// continue ;
95819: GO 95619
// to_repair := NearestUnitToUnit ( to_repair_tmp , j ) ;
95821: LD_ADDR_VAR 0 8
95825: PUSH
95826: LD_VAR 0 7
95830: PPUSH
95831: LD_VAR 0 3
95835: PPUSH
95836: CALL_OW 74
95840: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 10 then
95841: LD_VAR 0 8
95845: PPUSH
95846: LD_INT 16
95848: PPUSH
95849: CALL 26809 0 2
95853: PUSH
95854: LD_INT 4
95856: ARRAY
95857: PUSH
95858: LD_INT 10
95860: LESS
95861: IFFALSE 95877
// ComRepairBuilding ( j , to_repair ) ;
95863: LD_VAR 0 3
95867: PPUSH
95868: LD_VAR 0 8
95872: PPUSH
95873: CALL_OW 130
// end ;
95877: GO 95619
95879: POP
95880: POP
// end ;
95881: GO 95017
95883: POP
95884: POP
// end ;
95885: LD_VAR 0 1
95889: RET
// export function MC_Heal ; var i , j , tmp ; begin
95890: LD_INT 0
95892: PPUSH
95893: PPUSH
95894: PPUSH
95895: PPUSH
// if not mc_bases then
95896: LD_EXP 177
95900: NOT
95901: IFFALSE 95905
// exit ;
95903: GO 96307
// for i = 1 to mc_bases do
95905: LD_ADDR_VAR 0 2
95909: PUSH
95910: DOUBLE
95911: LD_INT 1
95913: DEC
95914: ST_TO_ADDR
95915: LD_EXP 177
95919: PUSH
95920: FOR_TO
95921: IFFALSE 96305
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
95923: LD_EXP 180
95927: PUSH
95928: LD_VAR 0 2
95932: ARRAY
95933: PUSH
95934: LD_INT 1
95936: ARRAY
95937: NOT
95938: PUSH
95939: LD_EXP 180
95943: PUSH
95944: LD_VAR 0 2
95948: ARRAY
95949: PUSH
95950: LD_INT 2
95952: ARRAY
95953: NOT
95954: AND
95955: IFFALSE 95993
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
95957: LD_ADDR_EXP 181
95961: PUSH
95962: LD_EXP 181
95966: PPUSH
95967: LD_VAR 0 2
95971: PPUSH
95972: EMPTY
95973: PPUSH
95974: CALL_OW 1
95978: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
95979: LD_VAR 0 2
95983: PPUSH
95984: LD_INT 102
95986: PPUSH
95987: CALL 90070 0 2
// continue ;
95991: GO 95920
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
95993: LD_ADDR_VAR 0 4
95997: PUSH
95998: LD_EXP 177
96002: PUSH
96003: LD_VAR 0 2
96007: ARRAY
96008: PPUSH
96009: LD_INT 25
96011: PUSH
96012: LD_INT 4
96014: PUSH
96015: EMPTY
96016: LIST
96017: LIST
96018: PPUSH
96019: CALL_OW 72
96023: ST_TO_ADDR
// if not tmp then
96024: LD_VAR 0 4
96028: NOT
96029: IFFALSE 96033
// continue ;
96031: GO 95920
// if mc_taming [ i ] then
96033: LD_EXP 208
96037: PUSH
96038: LD_VAR 0 2
96042: ARRAY
96043: IFFALSE 96067
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
96045: LD_ADDR_EXP 208
96049: PUSH
96050: LD_EXP 208
96054: PPUSH
96055: LD_VAR 0 2
96059: PPUSH
96060: EMPTY
96061: PPUSH
96062: CALL_OW 1
96066: ST_TO_ADDR
// for j in tmp do
96067: LD_ADDR_VAR 0 3
96071: PUSH
96072: LD_VAR 0 4
96076: PUSH
96077: FOR_IN
96078: IFFALSE 96301
// begin if IsInUnit ( j ) then
96080: LD_VAR 0 3
96084: PPUSH
96085: CALL_OW 310
96089: IFFALSE 96100
// ComExitBuilding ( j ) ;
96091: LD_VAR 0 3
96095: PPUSH
96096: CALL_OW 122
// if not j in mc_healers [ i ] then
96100: LD_VAR 0 3
96104: PUSH
96105: LD_EXP 181
96109: PUSH
96110: LD_VAR 0 2
96114: ARRAY
96115: IN
96116: NOT
96117: IFFALSE 96163
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
96119: LD_ADDR_EXP 181
96123: PUSH
96124: LD_EXP 181
96128: PPUSH
96129: LD_VAR 0 2
96133: PUSH
96134: LD_EXP 181
96138: PUSH
96139: LD_VAR 0 2
96143: ARRAY
96144: PUSH
96145: LD_INT 1
96147: PLUS
96148: PUSH
96149: EMPTY
96150: LIST
96151: LIST
96152: PPUSH
96153: LD_VAR 0 3
96157: PPUSH
96158: CALL 24210 0 3
96162: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
96163: LD_VAR 0 3
96167: PPUSH
96168: CALL_OW 110
96172: PUSH
96173: LD_INT 102
96175: NONEQUAL
96176: IFFALSE 96190
// SetTag ( j , 102 ) ;
96178: LD_VAR 0 3
96182: PPUSH
96183: LD_INT 102
96185: PPUSH
96186: CALL_OW 109
// Wait ( 3 ) ;
96190: LD_INT 3
96192: PPUSH
96193: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
96197: LD_EXP 180
96201: PUSH
96202: LD_VAR 0 2
96206: ARRAY
96207: PUSH
96208: LD_INT 1
96210: ARRAY
96211: IFFALSE 96243
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
96213: LD_VAR 0 3
96217: PPUSH
96218: LD_EXP 180
96222: PUSH
96223: LD_VAR 0 2
96227: ARRAY
96228: PUSH
96229: LD_INT 1
96231: ARRAY
96232: PUSH
96233: LD_INT 1
96235: ARRAY
96236: PPUSH
96237: CALL_OW 128
96241: GO 96299
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
96243: LD_VAR 0 3
96247: PPUSH
96248: CALL_OW 314
96252: NOT
96253: PUSH
96254: LD_EXP 180
96258: PUSH
96259: LD_VAR 0 2
96263: ARRAY
96264: PUSH
96265: LD_INT 2
96267: ARRAY
96268: AND
96269: IFFALSE 96299
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
96271: LD_VAR 0 3
96275: PPUSH
96276: LD_EXP 180
96280: PUSH
96281: LD_VAR 0 2
96285: ARRAY
96286: PUSH
96287: LD_INT 2
96289: ARRAY
96290: PUSH
96291: LD_INT 1
96293: ARRAY
96294: PPUSH
96295: CALL_OW 128
// end ;
96299: GO 96077
96301: POP
96302: POP
// end ;
96303: GO 95920
96305: POP
96306: POP
// end ;
96307: LD_VAR 0 1
96311: RET
// export function MC_Build ( ) ; var i , j , tmp , depot ; begin
96312: LD_INT 0
96314: PPUSH
96315: PPUSH
96316: PPUSH
96317: PPUSH
96318: PPUSH
// if not mc_bases then
96319: LD_EXP 177
96323: NOT
96324: IFFALSE 96328
// exit ;
96326: GO 97499
// for i = 1 to mc_bases do
96328: LD_ADDR_VAR 0 2
96332: PUSH
96333: DOUBLE
96334: LD_INT 1
96336: DEC
96337: ST_TO_ADDR
96338: LD_EXP 177
96342: PUSH
96343: FOR_TO
96344: IFFALSE 97497
// begin if mc_scan [ i ] then
96346: LD_EXP 200
96350: PUSH
96351: LD_VAR 0 2
96355: ARRAY
96356: IFFALSE 96360
// continue ;
96358: GO 96343
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
96360: LD_EXP 182
96364: PUSH
96365: LD_VAR 0 2
96369: ARRAY
96370: NOT
96371: PUSH
96372: LD_EXP 184
96376: PUSH
96377: LD_VAR 0 2
96381: ARRAY
96382: NOT
96383: AND
96384: PUSH
96385: LD_EXP 183
96389: PUSH
96390: LD_VAR 0 2
96394: ARRAY
96395: AND
96396: IFFALSE 96434
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
96398: LD_ADDR_EXP 183
96402: PUSH
96403: LD_EXP 183
96407: PPUSH
96408: LD_VAR 0 2
96412: PPUSH
96413: EMPTY
96414: PPUSH
96415: CALL_OW 1
96419: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
96420: LD_VAR 0 2
96424: PPUSH
96425: LD_INT 103
96427: PPUSH
96428: CALL 90070 0 2
// continue ;
96432: GO 96343
// end ; if mc_construct_list [ i ] then
96434: LD_EXP 184
96438: PUSH
96439: LD_VAR 0 2
96443: ARRAY
96444: IFFALSE 96664
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
96446: LD_ADDR_VAR 0 4
96450: PUSH
96451: LD_EXP 177
96455: PUSH
96456: LD_VAR 0 2
96460: ARRAY
96461: PPUSH
96462: LD_INT 25
96464: PUSH
96465: LD_INT 2
96467: PUSH
96468: EMPTY
96469: LIST
96470: LIST
96471: PPUSH
96472: CALL_OW 72
96476: PUSH
96477: LD_EXP 179
96481: PUSH
96482: LD_VAR 0 2
96486: ARRAY
96487: DIFF
96488: ST_TO_ADDR
// if not tmp then
96489: LD_VAR 0 4
96493: NOT
96494: IFFALSE 96498
// continue ;
96496: GO 96343
// for j in tmp do
96498: LD_ADDR_VAR 0 3
96502: PUSH
96503: LD_VAR 0 4
96507: PUSH
96508: FOR_IN
96509: IFFALSE 96660
// begin if not mc_builders [ i ] then
96511: LD_EXP 183
96515: PUSH
96516: LD_VAR 0 2
96520: ARRAY
96521: NOT
96522: IFFALSE 96580
// begin SetTag ( j , 103 ) ;
96524: LD_VAR 0 3
96528: PPUSH
96529: LD_INT 103
96531: PPUSH
96532: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
96536: LD_ADDR_EXP 183
96540: PUSH
96541: LD_EXP 183
96545: PPUSH
96546: LD_VAR 0 2
96550: PUSH
96551: LD_EXP 183
96555: PUSH
96556: LD_VAR 0 2
96560: ARRAY
96561: PUSH
96562: LD_INT 1
96564: PLUS
96565: PUSH
96566: EMPTY
96567: LIST
96568: LIST
96569: PPUSH
96570: LD_VAR 0 3
96574: PPUSH
96575: CALL 24210 0 3
96579: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
96580: LD_VAR 0 3
96584: PPUSH
96585: CALL_OW 310
96589: IFFALSE 96600
// ComExitBuilding ( j ) ;
96591: LD_VAR 0 3
96595: PPUSH
96596: CALL_OW 122
// wait ( 3 ) ;
96600: LD_INT 3
96602: PPUSH
96603: CALL_OW 67
// if not mc_construct_list [ i ] then
96607: LD_EXP 184
96611: PUSH
96612: LD_VAR 0 2
96616: ARRAY
96617: NOT
96618: IFFALSE 96622
// break ;
96620: GO 96660
// if not HasTask ( j ) then
96622: LD_VAR 0 3
96626: PPUSH
96627: CALL_OW 314
96631: NOT
96632: IFFALSE 96658
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
96634: LD_VAR 0 3
96638: PPUSH
96639: LD_EXP 184
96643: PUSH
96644: LD_VAR 0 2
96648: ARRAY
96649: PUSH
96650: LD_INT 1
96652: ARRAY
96653: PPUSH
96654: CALL 27073 0 2
// end ;
96658: GO 96508
96660: POP
96661: POP
// end else
96662: GO 97495
// if mc_build_list [ i ] then
96664: LD_EXP 182
96668: PUSH
96669: LD_VAR 0 2
96673: ARRAY
96674: IFFALSE 97495
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
96676: LD_ADDR_VAR 0 5
96680: PUSH
96681: LD_EXP 177
96685: PUSH
96686: LD_VAR 0 2
96690: ARRAY
96691: PPUSH
96692: LD_INT 2
96694: PUSH
96695: LD_INT 30
96697: PUSH
96698: LD_INT 0
96700: PUSH
96701: EMPTY
96702: LIST
96703: LIST
96704: PUSH
96705: LD_INT 30
96707: PUSH
96708: LD_INT 1
96710: PUSH
96711: EMPTY
96712: LIST
96713: LIST
96714: PUSH
96715: EMPTY
96716: LIST
96717: LIST
96718: LIST
96719: PPUSH
96720: CALL_OW 72
96724: ST_TO_ADDR
// if depot then
96725: LD_VAR 0 5
96729: IFFALSE 96747
// depot := depot [ 1 ] else
96731: LD_ADDR_VAR 0 5
96735: PUSH
96736: LD_VAR 0 5
96740: PUSH
96741: LD_INT 1
96743: ARRAY
96744: ST_TO_ADDR
96745: GO 96755
// depot := 0 ;
96747: LD_ADDR_VAR 0 5
96751: PUSH
96752: LD_INT 0
96754: ST_TO_ADDR
// if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
96755: LD_EXP 182
96759: PUSH
96760: LD_VAR 0 2
96764: ARRAY
96765: PUSH
96766: LD_INT 1
96768: ARRAY
96769: PUSH
96770: LD_INT 1
96772: ARRAY
96773: PPUSH
96774: CALL 26897 0 1
96778: PUSH
96779: LD_EXP 177
96783: PUSH
96784: LD_VAR 0 2
96788: ARRAY
96789: PPUSH
96790: LD_INT 2
96792: PUSH
96793: LD_INT 30
96795: PUSH
96796: LD_INT 2
96798: PUSH
96799: EMPTY
96800: LIST
96801: LIST
96802: PUSH
96803: LD_INT 30
96805: PUSH
96806: LD_INT 3
96808: PUSH
96809: EMPTY
96810: LIST
96811: LIST
96812: PUSH
96813: EMPTY
96814: LIST
96815: LIST
96816: LIST
96817: PPUSH
96818: CALL_OW 72
96822: NOT
96823: AND
96824: IFFALSE 96929
// begin for j = 1 to mc_build_list [ i ] do
96826: LD_ADDR_VAR 0 3
96830: PUSH
96831: DOUBLE
96832: LD_INT 1
96834: DEC
96835: ST_TO_ADDR
96836: LD_EXP 182
96840: PUSH
96841: LD_VAR 0 2
96845: ARRAY
96846: PUSH
96847: FOR_TO
96848: IFFALSE 96927
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
96850: LD_EXP 182
96854: PUSH
96855: LD_VAR 0 2
96859: ARRAY
96860: PUSH
96861: LD_VAR 0 3
96865: ARRAY
96866: PUSH
96867: LD_INT 1
96869: ARRAY
96870: PUSH
96871: LD_INT 2
96873: EQUAL
96874: IFFALSE 96925
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
96876: LD_ADDR_EXP 182
96880: PUSH
96881: LD_EXP 182
96885: PPUSH
96886: LD_VAR 0 2
96890: PPUSH
96891: LD_EXP 182
96895: PUSH
96896: LD_VAR 0 2
96900: ARRAY
96901: PPUSH
96902: LD_VAR 0 3
96906: PPUSH
96907: LD_INT 1
96909: PPUSH
96910: LD_INT 0
96912: PPUSH
96913: CALL 23628 0 4
96917: PPUSH
96918: CALL_OW 1
96922: ST_TO_ADDR
// break ;
96923: GO 96927
// end ;
96925: GO 96847
96927: POP
96928: POP
// end ; if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or ( depot and CanBeBuilt ( depot , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ) then
96929: LD_EXP 182
96933: PUSH
96934: LD_VAR 0 2
96938: ARRAY
96939: PUSH
96940: LD_INT 1
96942: ARRAY
96943: PUSH
96944: LD_INT 1
96946: ARRAY
96947: PUSH
96948: LD_INT 0
96950: EQUAL
96951: PUSH
96952: LD_VAR 0 5
96956: PUSH
96957: LD_VAR 0 5
96961: PPUSH
96962: LD_EXP 182
96966: PUSH
96967: LD_VAR 0 2
96971: ARRAY
96972: PUSH
96973: LD_INT 1
96975: ARRAY
96976: PUSH
96977: LD_INT 1
96979: ARRAY
96980: PPUSH
96981: LD_EXP 182
96985: PUSH
96986: LD_VAR 0 2
96990: ARRAY
96991: PUSH
96992: LD_INT 1
96994: ARRAY
96995: PUSH
96996: LD_INT 2
96998: ARRAY
96999: PPUSH
97000: LD_EXP 182
97004: PUSH
97005: LD_VAR 0 2
97009: ARRAY
97010: PUSH
97011: LD_INT 1
97013: ARRAY
97014: PUSH
97015: LD_INT 3
97017: ARRAY
97018: PPUSH
97019: LD_EXP 182
97023: PUSH
97024: LD_VAR 0 2
97028: ARRAY
97029: PUSH
97030: LD_INT 1
97032: ARRAY
97033: PUSH
97034: LD_INT 4
97036: ARRAY
97037: PPUSH
97038: CALL 32313 0 5
97042: AND
97043: OR
97044: IFFALSE 97325
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
97046: LD_ADDR_VAR 0 4
97050: PUSH
97051: LD_EXP 177
97055: PUSH
97056: LD_VAR 0 2
97060: ARRAY
97061: PPUSH
97062: LD_INT 25
97064: PUSH
97065: LD_INT 2
97067: PUSH
97068: EMPTY
97069: LIST
97070: LIST
97071: PPUSH
97072: CALL_OW 72
97076: PUSH
97077: LD_EXP 179
97081: PUSH
97082: LD_VAR 0 2
97086: ARRAY
97087: DIFF
97088: ST_TO_ADDR
// if not tmp then
97089: LD_VAR 0 4
97093: NOT
97094: IFFALSE 97098
// continue ;
97096: GO 96343
// for j in tmp do
97098: LD_ADDR_VAR 0 3
97102: PUSH
97103: LD_VAR 0 4
97107: PUSH
97108: FOR_IN
97109: IFFALSE 97321
// begin if not mc_builders [ i ] then
97111: LD_EXP 183
97115: PUSH
97116: LD_VAR 0 2
97120: ARRAY
97121: NOT
97122: IFFALSE 97180
// begin SetTag ( j , 103 ) ;
97124: LD_VAR 0 3
97128: PPUSH
97129: LD_INT 103
97131: PPUSH
97132: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
97136: LD_ADDR_EXP 183
97140: PUSH
97141: LD_EXP 183
97145: PPUSH
97146: LD_VAR 0 2
97150: PUSH
97151: LD_EXP 183
97155: PUSH
97156: LD_VAR 0 2
97160: ARRAY
97161: PUSH
97162: LD_INT 1
97164: PLUS
97165: PUSH
97166: EMPTY
97167: LIST
97168: LIST
97169: PPUSH
97170: LD_VAR 0 3
97174: PPUSH
97175: CALL 24210 0 3
97179: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
97180: LD_VAR 0 3
97184: PPUSH
97185: CALL_OW 310
97189: IFFALSE 97200
// ComExitBuilding ( j ) ;
97191: LD_VAR 0 3
97195: PPUSH
97196: CALL_OW 122
// wait ( 3 ) ;
97200: LD_INT 3
97202: PPUSH
97203: CALL_OW 67
// if not mc_build_list [ i ] then
97207: LD_EXP 182
97211: PUSH
97212: LD_VAR 0 2
97216: ARRAY
97217: NOT
97218: IFFALSE 97222
// break ;
97220: GO 97321
// if not HasTask ( j ) then
97222: LD_VAR 0 3
97226: PPUSH
97227: CALL_OW 314
97231: NOT
97232: IFFALSE 97319
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
97234: LD_VAR 0 3
97238: PPUSH
97239: LD_EXP 182
97243: PUSH
97244: LD_VAR 0 2
97248: ARRAY
97249: PUSH
97250: LD_INT 1
97252: ARRAY
97253: PUSH
97254: LD_INT 1
97256: ARRAY
97257: PPUSH
97258: LD_EXP 182
97262: PUSH
97263: LD_VAR 0 2
97267: ARRAY
97268: PUSH
97269: LD_INT 1
97271: ARRAY
97272: PUSH
97273: LD_INT 2
97275: ARRAY
97276: PPUSH
97277: LD_EXP 182
97281: PUSH
97282: LD_VAR 0 2
97286: ARRAY
97287: PUSH
97288: LD_INT 1
97290: ARRAY
97291: PUSH
97292: LD_INT 3
97294: ARRAY
97295: PPUSH
97296: LD_EXP 182
97300: PUSH
97301: LD_VAR 0 2
97305: ARRAY
97306: PUSH
97307: LD_INT 1
97309: ARRAY
97310: PUSH
97311: LD_INT 4
97313: ARRAY
97314: PPUSH
97315: CALL_OW 145
// end ;
97319: GO 97108
97321: POP
97322: POP
// end else
97323: GO 97495
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] , UnitFilter ( mc_bases [ i ] , [ f_type , unit_building ] ) , [ ] ) then
97325: LD_EXP 177
97329: PUSH
97330: LD_VAR 0 2
97334: ARRAY
97335: PPUSH
97336: LD_EXP 182
97340: PUSH
97341: LD_VAR 0 2
97345: ARRAY
97346: PUSH
97347: LD_INT 1
97349: ARRAY
97350: PUSH
97351: LD_INT 1
97353: ARRAY
97354: PPUSH
97355: LD_EXP 182
97359: PUSH
97360: LD_VAR 0 2
97364: ARRAY
97365: PUSH
97366: LD_INT 1
97368: ARRAY
97369: PUSH
97370: LD_INT 2
97372: ARRAY
97373: PPUSH
97374: LD_EXP 182
97378: PUSH
97379: LD_VAR 0 2
97383: ARRAY
97384: PUSH
97385: LD_INT 1
97387: ARRAY
97388: PUSH
97389: LD_INT 3
97391: ARRAY
97392: PPUSH
97393: LD_EXP 182
97397: PUSH
97398: LD_VAR 0 2
97402: ARRAY
97403: PUSH
97404: LD_INT 1
97406: ARRAY
97407: PUSH
97408: LD_INT 4
97410: ARRAY
97411: PPUSH
97412: LD_EXP 177
97416: PUSH
97417: LD_VAR 0 2
97421: ARRAY
97422: PPUSH
97423: LD_INT 21
97425: PUSH
97426: LD_INT 3
97428: PUSH
97429: EMPTY
97430: LIST
97431: LIST
97432: PPUSH
97433: CALL_OW 72
97437: PPUSH
97438: EMPTY
97439: PPUSH
97440: CALL 31063 0 7
97444: NOT
97445: IFFALSE 97495
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
97447: LD_ADDR_EXP 182
97451: PUSH
97452: LD_EXP 182
97456: PPUSH
97457: LD_VAR 0 2
97461: PPUSH
97462: LD_EXP 182
97466: PUSH
97467: LD_VAR 0 2
97471: ARRAY
97472: PPUSH
97473: LD_INT 1
97475: PPUSH
97476: LD_INT 1
97478: NEG
97479: PPUSH
97480: LD_INT 0
97482: PPUSH
97483: CALL 23628 0 4
97487: PPUSH
97488: CALL_OW 1
97492: ST_TO_ADDR
// continue ;
97493: GO 96343
// end ; end ; end ;
97495: GO 96343
97497: POP
97498: POP
// end ;
97499: LD_VAR 0 1
97503: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
97504: LD_INT 0
97506: PPUSH
97507: PPUSH
97508: PPUSH
97509: PPUSH
97510: PPUSH
97511: PPUSH
// if not mc_bases then
97512: LD_EXP 177
97516: NOT
97517: IFFALSE 97521
// exit ;
97519: GO 97948
// for i = 1 to mc_bases do
97521: LD_ADDR_VAR 0 2
97525: PUSH
97526: DOUBLE
97527: LD_INT 1
97529: DEC
97530: ST_TO_ADDR
97531: LD_EXP 177
97535: PUSH
97536: FOR_TO
97537: IFFALSE 97946
// begin tmp := mc_build_upgrade [ i ] ;
97539: LD_ADDR_VAR 0 4
97543: PUSH
97544: LD_EXP 209
97548: PUSH
97549: LD_VAR 0 2
97553: ARRAY
97554: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
97555: LD_ADDR_VAR 0 6
97559: PUSH
97560: LD_EXP 210
97564: PUSH
97565: LD_VAR 0 2
97569: ARRAY
97570: PPUSH
97571: LD_INT 2
97573: PUSH
97574: LD_INT 30
97576: PUSH
97577: LD_INT 6
97579: PUSH
97580: EMPTY
97581: LIST
97582: LIST
97583: PUSH
97584: LD_INT 30
97586: PUSH
97587: LD_INT 7
97589: PUSH
97590: EMPTY
97591: LIST
97592: LIST
97593: PUSH
97594: EMPTY
97595: LIST
97596: LIST
97597: LIST
97598: PPUSH
97599: CALL_OW 72
97603: ST_TO_ADDR
// if not tmp and not lab then
97604: LD_VAR 0 4
97608: NOT
97609: PUSH
97610: LD_VAR 0 6
97614: NOT
97615: AND
97616: IFFALSE 97620
// continue ;
97618: GO 97536
// if tmp then
97620: LD_VAR 0 4
97624: IFFALSE 97744
// for j in tmp do
97626: LD_ADDR_VAR 0 3
97630: PUSH
97631: LD_VAR 0 4
97635: PUSH
97636: FOR_IN
97637: IFFALSE 97742
// begin if UpgradeCost ( j ) then
97639: LD_VAR 0 3
97643: PPUSH
97644: CALL 30723 0 1
97648: IFFALSE 97740
// begin ComUpgrade ( j ) ;
97650: LD_VAR 0 3
97654: PPUSH
97655: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
97659: LD_ADDR_EXP 209
97663: PUSH
97664: LD_EXP 209
97668: PPUSH
97669: LD_VAR 0 2
97673: PPUSH
97674: LD_EXP 209
97678: PUSH
97679: LD_VAR 0 2
97683: ARRAY
97684: PUSH
97685: LD_VAR 0 3
97689: DIFF
97690: PPUSH
97691: CALL_OW 1
97695: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
97696: LD_ADDR_EXP 184
97700: PUSH
97701: LD_EXP 184
97705: PPUSH
97706: LD_VAR 0 2
97710: PUSH
97711: LD_EXP 184
97715: PUSH
97716: LD_VAR 0 2
97720: ARRAY
97721: PUSH
97722: LD_INT 1
97724: PLUS
97725: PUSH
97726: EMPTY
97727: LIST
97728: LIST
97729: PPUSH
97730: LD_VAR 0 3
97734: PPUSH
97735: CALL 24210 0 3
97739: ST_TO_ADDR
// end ; end ;
97740: GO 97636
97742: POP
97743: POP
// if not lab or not mc_lab_upgrade [ i ] then
97744: LD_VAR 0 6
97748: NOT
97749: PUSH
97750: LD_EXP 211
97754: PUSH
97755: LD_VAR 0 2
97759: ARRAY
97760: NOT
97761: OR
97762: IFFALSE 97766
// continue ;
97764: GO 97536
// for j in lab do
97766: LD_ADDR_VAR 0 3
97770: PUSH
97771: LD_VAR 0 6
97775: PUSH
97776: FOR_IN
97777: IFFALSE 97942
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
97779: LD_VAR 0 3
97783: PPUSH
97784: CALL_OW 266
97788: PUSH
97789: LD_INT 6
97791: PUSH
97792: LD_INT 7
97794: PUSH
97795: EMPTY
97796: LIST
97797: LIST
97798: IN
97799: PUSH
97800: LD_VAR 0 3
97804: PPUSH
97805: CALL_OW 461
97809: PUSH
97810: LD_INT 1
97812: NONEQUAL
97813: AND
97814: IFFALSE 97940
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
97816: LD_VAR 0 3
97820: PPUSH
97821: LD_EXP 211
97825: PUSH
97826: LD_VAR 0 2
97830: ARRAY
97831: PUSH
97832: LD_INT 1
97834: ARRAY
97835: PPUSH
97836: CALL 30928 0 2
97840: IFFALSE 97940
// begin ComCancel ( j ) ;
97842: LD_VAR 0 3
97846: PPUSH
97847: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
97851: LD_VAR 0 3
97855: PPUSH
97856: LD_EXP 211
97860: PUSH
97861: LD_VAR 0 2
97865: ARRAY
97866: PUSH
97867: LD_INT 1
97869: ARRAY
97870: PPUSH
97871: CALL_OW 207
// if not j in mc_construct_list [ i ] then
97875: LD_VAR 0 3
97879: PUSH
97880: LD_EXP 184
97884: PUSH
97885: LD_VAR 0 2
97889: ARRAY
97890: IN
97891: NOT
97892: IFFALSE 97938
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
97894: LD_ADDR_EXP 184
97898: PUSH
97899: LD_EXP 184
97903: PPUSH
97904: LD_VAR 0 2
97908: PUSH
97909: LD_EXP 184
97913: PUSH
97914: LD_VAR 0 2
97918: ARRAY
97919: PUSH
97920: LD_INT 1
97922: PLUS
97923: PUSH
97924: EMPTY
97925: LIST
97926: LIST
97927: PPUSH
97928: LD_VAR 0 3
97932: PPUSH
97933: CALL 24210 0 3
97937: ST_TO_ADDR
// break ;
97938: GO 97942
// end ; end ; end ;
97940: GO 97776
97942: POP
97943: POP
// end ;
97944: GO 97536
97946: POP
97947: POP
// end ;
97948: LD_VAR 0 1
97952: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
97953: LD_INT 0
97955: PPUSH
97956: PPUSH
97957: PPUSH
97958: PPUSH
97959: PPUSH
97960: PPUSH
97961: PPUSH
97962: PPUSH
97963: PPUSH
// if not mc_bases then
97964: LD_EXP 177
97968: NOT
97969: IFFALSE 97973
// exit ;
97971: GO 98378
// for i = 1 to mc_bases do
97973: LD_ADDR_VAR 0 2
97977: PUSH
97978: DOUBLE
97979: LD_INT 1
97981: DEC
97982: ST_TO_ADDR
97983: LD_EXP 177
97987: PUSH
97988: FOR_TO
97989: IFFALSE 98376
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
97991: LD_EXP 185
97995: PUSH
97996: LD_VAR 0 2
98000: ARRAY
98001: NOT
98002: PUSH
98003: LD_EXP 177
98007: PUSH
98008: LD_VAR 0 2
98012: ARRAY
98013: PPUSH
98014: LD_INT 30
98016: PUSH
98017: LD_INT 3
98019: PUSH
98020: EMPTY
98021: LIST
98022: LIST
98023: PPUSH
98024: CALL_OW 72
98028: NOT
98029: OR
98030: IFFALSE 98034
// continue ;
98032: GO 97988
// busy := false ;
98034: LD_ADDR_VAR 0 8
98038: PUSH
98039: LD_INT 0
98041: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
98042: LD_ADDR_VAR 0 4
98046: PUSH
98047: LD_EXP 177
98051: PUSH
98052: LD_VAR 0 2
98056: ARRAY
98057: PPUSH
98058: LD_INT 30
98060: PUSH
98061: LD_INT 3
98063: PUSH
98064: EMPTY
98065: LIST
98066: LIST
98067: PPUSH
98068: CALL_OW 72
98072: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
98073: LD_ADDR_VAR 0 6
98077: PUSH
98078: LD_EXP 185
98082: PUSH
98083: LD_VAR 0 2
98087: ARRAY
98088: PPUSH
98089: LD_INT 2
98091: PUSH
98092: LD_INT 30
98094: PUSH
98095: LD_INT 32
98097: PUSH
98098: EMPTY
98099: LIST
98100: LIST
98101: PUSH
98102: LD_INT 30
98104: PUSH
98105: LD_INT 33
98107: PUSH
98108: EMPTY
98109: LIST
98110: LIST
98111: PUSH
98112: EMPTY
98113: LIST
98114: LIST
98115: LIST
98116: PPUSH
98117: CALL_OW 72
98121: ST_TO_ADDR
// if not t then
98122: LD_VAR 0 6
98126: NOT
98127: IFFALSE 98131
// continue ;
98129: GO 97988
// for j in tmp do
98131: LD_ADDR_VAR 0 3
98135: PUSH
98136: LD_VAR 0 4
98140: PUSH
98141: FOR_IN
98142: IFFALSE 98172
// if not BuildingStatus ( j ) = bs_idle then
98144: LD_VAR 0 3
98148: PPUSH
98149: CALL_OW 461
98153: PUSH
98154: LD_INT 2
98156: EQUAL
98157: NOT
98158: IFFALSE 98170
// begin busy := true ;
98160: LD_ADDR_VAR 0 8
98164: PUSH
98165: LD_INT 1
98167: ST_TO_ADDR
// break ;
98168: GO 98172
// end ;
98170: GO 98141
98172: POP
98173: POP
// if busy then
98174: LD_VAR 0 8
98178: IFFALSE 98182
// continue ;
98180: GO 97988
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
98182: LD_ADDR_VAR 0 7
98186: PUSH
98187: LD_VAR 0 6
98191: PPUSH
98192: LD_INT 35
98194: PUSH
98195: LD_INT 0
98197: PUSH
98198: EMPTY
98199: LIST
98200: LIST
98201: PPUSH
98202: CALL_OW 72
98206: ST_TO_ADDR
// if tw then
98207: LD_VAR 0 7
98211: IFFALSE 98288
// begin tw := tw [ 1 ] ;
98213: LD_ADDR_VAR 0 7
98217: PUSH
98218: LD_VAR 0 7
98222: PUSH
98223: LD_INT 1
98225: ARRAY
98226: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
98227: LD_ADDR_VAR 0 9
98231: PUSH
98232: LD_VAR 0 7
98236: PPUSH
98237: LD_EXP 202
98241: PUSH
98242: LD_VAR 0 2
98246: ARRAY
98247: PPUSH
98248: CALL 29220 0 2
98252: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
98253: LD_EXP 216
98257: PUSH
98258: LD_VAR 0 2
98262: ARRAY
98263: IFFALSE 98286
// if not weapon in mc_allowed_tower_weapons [ i ] then
98265: LD_VAR 0 9
98269: PUSH
98270: LD_EXP 216
98274: PUSH
98275: LD_VAR 0 2
98279: ARRAY
98280: IN
98281: NOT
98282: IFFALSE 98286
// continue ;
98284: GO 97988
// end else
98286: GO 98351
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
98288: LD_ADDR_VAR 0 5
98292: PUSH
98293: LD_EXP 185
98297: PUSH
98298: LD_VAR 0 2
98302: ARRAY
98303: PPUSH
98304: LD_VAR 0 4
98308: PPUSH
98309: CALL 55509 0 2
98313: ST_TO_ADDR
// if not tmp2 then
98314: LD_VAR 0 5
98318: NOT
98319: IFFALSE 98323
// continue ;
98321: GO 97988
// tw := tmp2 [ 1 ] ;
98323: LD_ADDR_VAR 0 7
98327: PUSH
98328: LD_VAR 0 5
98332: PUSH
98333: LD_INT 1
98335: ARRAY
98336: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
98337: LD_ADDR_VAR 0 9
98341: PUSH
98342: LD_VAR 0 5
98346: PUSH
98347: LD_INT 2
98349: ARRAY
98350: ST_TO_ADDR
// end ; if not weapon then
98351: LD_VAR 0 9
98355: NOT
98356: IFFALSE 98360
// continue ;
98358: GO 97988
// ComPlaceWeapon ( tw , weapon ) ;
98360: LD_VAR 0 7
98364: PPUSH
98365: LD_VAR 0 9
98369: PPUSH
98370: CALL_OW 148
// end ;
98374: GO 97988
98376: POP
98377: POP
// end ;
98378: LD_VAR 0 1
98382: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list , r ; begin
98383: LD_INT 0
98385: PPUSH
98386: PPUSH
98387: PPUSH
98388: PPUSH
98389: PPUSH
98390: PPUSH
98391: PPUSH
// if not mc_bases then
98392: LD_EXP 177
98396: NOT
98397: IFFALSE 98401
// exit ;
98399: GO 99169
// for i = 1 to mc_bases do
98401: LD_ADDR_VAR 0 2
98405: PUSH
98406: DOUBLE
98407: LD_INT 1
98409: DEC
98410: ST_TO_ADDR
98411: LD_EXP 177
98415: PUSH
98416: FOR_TO
98417: IFFALSE 99167
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] or mc_scan [ i ] then
98419: LD_EXP 190
98423: PUSH
98424: LD_VAR 0 2
98428: ARRAY
98429: NOT
98430: PUSH
98431: LD_EXP 190
98435: PUSH
98436: LD_VAR 0 2
98440: ARRAY
98441: PUSH
98442: LD_EXP 191
98446: PUSH
98447: LD_VAR 0 2
98451: ARRAY
98452: EQUAL
98453: OR
98454: PUSH
98455: LD_EXP 200
98459: PUSH
98460: LD_VAR 0 2
98464: ARRAY
98465: OR
98466: IFFALSE 98470
// continue ;
98468: GO 98416
// if mc_miners [ i ] then
98470: LD_EXP 191
98474: PUSH
98475: LD_VAR 0 2
98479: ARRAY
98480: IFFALSE 98854
// begin for j = mc_miners [ i ] downto 1 do
98482: LD_ADDR_VAR 0 3
98486: PUSH
98487: DOUBLE
98488: LD_EXP 191
98492: PUSH
98493: LD_VAR 0 2
98497: ARRAY
98498: INC
98499: ST_TO_ADDR
98500: LD_INT 1
98502: PUSH
98503: FOR_DOWNTO
98504: IFFALSE 98852
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
98506: LD_EXP 191
98510: PUSH
98511: LD_VAR 0 2
98515: ARRAY
98516: PUSH
98517: LD_VAR 0 3
98521: ARRAY
98522: PPUSH
98523: CALL_OW 301
98527: PUSH
98528: LD_EXP 191
98532: PUSH
98533: LD_VAR 0 2
98537: ARRAY
98538: PUSH
98539: LD_VAR 0 3
98543: ARRAY
98544: PPUSH
98545: CALL_OW 257
98549: PUSH
98550: LD_INT 1
98552: NONEQUAL
98553: OR
98554: IFFALSE 98617
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
98556: LD_ADDR_VAR 0 5
98560: PUSH
98561: LD_EXP 191
98565: PUSH
98566: LD_VAR 0 2
98570: ARRAY
98571: PUSH
98572: LD_EXP 191
98576: PUSH
98577: LD_VAR 0 2
98581: ARRAY
98582: PUSH
98583: LD_VAR 0 3
98587: ARRAY
98588: DIFF
98589: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
98590: LD_ADDR_EXP 191
98594: PUSH
98595: LD_EXP 191
98599: PPUSH
98600: LD_VAR 0 2
98604: PPUSH
98605: LD_VAR 0 5
98609: PPUSH
98610: CALL_OW 1
98614: ST_TO_ADDR
// continue ;
98615: GO 98503
// end ; if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and not HasTask ( mc_miners [ i ] [ j ] ) then
98617: LD_EXP 191
98621: PUSH
98622: LD_VAR 0 2
98626: ARRAY
98627: PUSH
98628: LD_VAR 0 3
98632: ARRAY
98633: PPUSH
98634: CALL_OW 257
98638: PUSH
98639: LD_INT 1
98641: EQUAL
98642: PUSH
98643: LD_EXP 191
98647: PUSH
98648: LD_VAR 0 2
98652: ARRAY
98653: PUSH
98654: LD_VAR 0 3
98658: ARRAY
98659: PPUSH
98660: CALL_OW 459
98664: NOT
98665: AND
98666: PUSH
98667: LD_EXP 191
98671: PUSH
98672: LD_VAR 0 2
98676: ARRAY
98677: PUSH
98678: LD_VAR 0 3
98682: ARRAY
98683: PPUSH
98684: CALL_OW 314
98688: NOT
98689: AND
98690: IFFALSE 98850
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
98692: LD_EXP 191
98696: PUSH
98697: LD_VAR 0 2
98701: ARRAY
98702: PUSH
98703: LD_VAR 0 3
98707: ARRAY
98708: PPUSH
98709: CALL_OW 310
98713: IFFALSE 98736
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
98715: LD_EXP 191
98719: PUSH
98720: LD_VAR 0 2
98724: ARRAY
98725: PUSH
98726: LD_VAR 0 3
98730: ARRAY
98731: PPUSH
98732: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
98736: LD_EXP 191
98740: PUSH
98741: LD_VAR 0 2
98745: ARRAY
98746: PUSH
98747: LD_VAR 0 3
98751: ARRAY
98752: PPUSH
98753: CALL_OW 314
98757: NOT
98758: IFFALSE 98850
// begin r := rand ( 1 , mc_mines [ i ] ) ;
98760: LD_ADDR_VAR 0 7
98764: PUSH
98765: LD_INT 1
98767: PPUSH
98768: LD_EXP 190
98772: PUSH
98773: LD_VAR 0 2
98777: ARRAY
98778: PPUSH
98779: CALL_OW 12
98783: ST_TO_ADDR
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ r ] [ 1 ] , mc_mines [ i ] [ r ] [ 2 ] , 0 ) ;
98784: LD_EXP 191
98788: PUSH
98789: LD_VAR 0 2
98793: ARRAY
98794: PUSH
98795: LD_VAR 0 3
98799: ARRAY
98800: PPUSH
98801: LD_EXP 190
98805: PUSH
98806: LD_VAR 0 2
98810: ARRAY
98811: PUSH
98812: LD_VAR 0 7
98816: ARRAY
98817: PUSH
98818: LD_INT 1
98820: ARRAY
98821: PPUSH
98822: LD_EXP 190
98826: PUSH
98827: LD_VAR 0 2
98831: ARRAY
98832: PUSH
98833: LD_VAR 0 7
98837: ARRAY
98838: PUSH
98839: LD_INT 2
98841: ARRAY
98842: PPUSH
98843: LD_INT 0
98845: PPUSH
98846: CALL_OW 193
// end ; end ; end ;
98850: GO 98503
98852: POP
98853: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
98854: LD_ADDR_VAR 0 5
98858: PUSH
98859: LD_EXP 177
98863: PUSH
98864: LD_VAR 0 2
98868: ARRAY
98869: PPUSH
98870: LD_INT 2
98872: PUSH
98873: LD_INT 30
98875: PUSH
98876: LD_INT 4
98878: PUSH
98879: EMPTY
98880: LIST
98881: LIST
98882: PUSH
98883: LD_INT 30
98885: PUSH
98886: LD_INT 5
98888: PUSH
98889: EMPTY
98890: LIST
98891: LIST
98892: PUSH
98893: LD_INT 30
98895: PUSH
98896: LD_INT 32
98898: PUSH
98899: EMPTY
98900: LIST
98901: LIST
98902: PUSH
98903: EMPTY
98904: LIST
98905: LIST
98906: LIST
98907: LIST
98908: PPUSH
98909: CALL_OW 72
98913: ST_TO_ADDR
// if not tmp then
98914: LD_VAR 0 5
98918: NOT
98919: IFFALSE 98923
// continue ;
98921: GO 98416
// list := [ ] ;
98923: LD_ADDR_VAR 0 6
98927: PUSH
98928: EMPTY
98929: ST_TO_ADDR
// for j in tmp do
98930: LD_ADDR_VAR 0 3
98934: PUSH
98935: LD_VAR 0 5
98939: PUSH
98940: FOR_IN
98941: IFFALSE 99010
// begin for k in UnitsInside ( j ) do
98943: LD_ADDR_VAR 0 4
98947: PUSH
98948: LD_VAR 0 3
98952: PPUSH
98953: CALL_OW 313
98957: PUSH
98958: FOR_IN
98959: IFFALSE 99006
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
98961: LD_VAR 0 4
98965: PPUSH
98966: CALL_OW 257
98970: PUSH
98971: LD_INT 1
98973: EQUAL
98974: PUSH
98975: LD_VAR 0 4
98979: PPUSH
98980: CALL_OW 459
98984: NOT
98985: AND
98986: IFFALSE 99004
// list := list ^ k ;
98988: LD_ADDR_VAR 0 6
98992: PUSH
98993: LD_VAR 0 6
98997: PUSH
98998: LD_VAR 0 4
99002: ADD
99003: ST_TO_ADDR
99004: GO 98958
99006: POP
99007: POP
// end ;
99008: GO 98940
99010: POP
99011: POP
// list := list diff mc_miners [ i ] ;
99012: LD_ADDR_VAR 0 6
99016: PUSH
99017: LD_VAR 0 6
99021: PUSH
99022: LD_EXP 191
99026: PUSH
99027: LD_VAR 0 2
99031: ARRAY
99032: DIFF
99033: ST_TO_ADDR
// if not list then
99034: LD_VAR 0 6
99038: NOT
99039: IFFALSE 99043
// continue ;
99041: GO 98416
// k := mc_mines [ i ] - mc_miners [ i ] ;
99043: LD_ADDR_VAR 0 4
99047: PUSH
99048: LD_EXP 190
99052: PUSH
99053: LD_VAR 0 2
99057: ARRAY
99058: PUSH
99059: LD_EXP 191
99063: PUSH
99064: LD_VAR 0 2
99068: ARRAY
99069: MINUS
99070: ST_TO_ADDR
// if k > list then
99071: LD_VAR 0 4
99075: PUSH
99076: LD_VAR 0 6
99080: GREATER
99081: IFFALSE 99093
// k := list ;
99083: LD_ADDR_VAR 0 4
99087: PUSH
99088: LD_VAR 0 6
99092: ST_TO_ADDR
// for j = 1 to k do
99093: LD_ADDR_VAR 0 3
99097: PUSH
99098: DOUBLE
99099: LD_INT 1
99101: DEC
99102: ST_TO_ADDR
99103: LD_VAR 0 4
99107: PUSH
99108: FOR_TO
99109: IFFALSE 99163
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
99111: LD_ADDR_EXP 191
99115: PUSH
99116: LD_EXP 191
99120: PPUSH
99121: LD_VAR 0 2
99125: PUSH
99126: LD_EXP 191
99130: PUSH
99131: LD_VAR 0 2
99135: ARRAY
99136: PUSH
99137: LD_INT 1
99139: PLUS
99140: PUSH
99141: EMPTY
99142: LIST
99143: LIST
99144: PPUSH
99145: LD_VAR 0 6
99149: PUSH
99150: LD_VAR 0 3
99154: ARRAY
99155: PPUSH
99156: CALL 24210 0 3
99160: ST_TO_ADDR
99161: GO 99108
99163: POP
99164: POP
// end ;
99165: GO 98416
99167: POP
99168: POP
// end ;
99169: LD_VAR 0 1
99173: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , side , target , cargo , depot , fac , components ; begin
99174: LD_INT 0
99176: PPUSH
99177: PPUSH
99178: PPUSH
99179: PPUSH
99180: PPUSH
99181: PPUSH
99182: PPUSH
99183: PPUSH
99184: PPUSH
99185: PPUSH
99186: PPUSH
// if not mc_bases then
99187: LD_EXP 177
99191: NOT
99192: IFFALSE 99196
// exit ;
99194: GO 101019
// for i = 1 to mc_bases do
99196: LD_ADDR_VAR 0 2
99200: PUSH
99201: DOUBLE
99202: LD_INT 1
99204: DEC
99205: ST_TO_ADDR
99206: LD_EXP 177
99210: PUSH
99211: FOR_TO
99212: IFFALSE 101017
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
99214: LD_EXP 177
99218: PUSH
99219: LD_VAR 0 2
99223: ARRAY
99224: NOT
99225: PUSH
99226: LD_EXP 184
99230: PUSH
99231: LD_VAR 0 2
99235: ARRAY
99236: OR
99237: IFFALSE 99241
// continue ;
99239: GO 99211
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
99241: LD_EXP 193
99245: PUSH
99246: LD_VAR 0 2
99250: ARRAY
99251: NOT
99252: PUSH
99253: LD_EXP 194
99257: PUSH
99258: LD_VAR 0 2
99262: ARRAY
99263: AND
99264: IFFALSE 99302
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
99266: LD_ADDR_EXP 194
99270: PUSH
99271: LD_EXP 194
99275: PPUSH
99276: LD_VAR 0 2
99280: PPUSH
99281: EMPTY
99282: PPUSH
99283: CALL_OW 1
99287: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
99288: LD_VAR 0 2
99292: PPUSH
99293: LD_INT 107
99295: PPUSH
99296: CALL 90070 0 2
// continue ;
99300: GO 99211
// end ; target := [ ] ;
99302: LD_ADDR_VAR 0 7
99306: PUSH
99307: EMPTY
99308: ST_TO_ADDR
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
99309: LD_ADDR_VAR 0 6
99313: PUSH
99314: LD_EXP 177
99318: PUSH
99319: LD_VAR 0 2
99323: ARRAY
99324: PUSH
99325: LD_INT 1
99327: ARRAY
99328: PPUSH
99329: CALL_OW 255
99333: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
99334: LD_ADDR_VAR 0 9
99338: PUSH
99339: LD_EXP 177
99343: PUSH
99344: LD_VAR 0 2
99348: ARRAY
99349: PPUSH
99350: LD_INT 2
99352: PUSH
99353: LD_INT 30
99355: PUSH
99356: LD_INT 0
99358: PUSH
99359: EMPTY
99360: LIST
99361: LIST
99362: PUSH
99363: LD_INT 30
99365: PUSH
99366: LD_INT 1
99368: PUSH
99369: EMPTY
99370: LIST
99371: LIST
99372: PUSH
99373: EMPTY
99374: LIST
99375: LIST
99376: LIST
99377: PPUSH
99378: CALL_OW 72
99382: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
99383: LD_ADDR_VAR 0 3
99387: PUSH
99388: DOUBLE
99389: LD_EXP 193
99393: PUSH
99394: LD_VAR 0 2
99398: ARRAY
99399: INC
99400: ST_TO_ADDR
99401: LD_INT 1
99403: PUSH
99404: FOR_DOWNTO
99405: IFFALSE 99650
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
99407: LD_EXP 193
99411: PUSH
99412: LD_VAR 0 2
99416: ARRAY
99417: PUSH
99418: LD_VAR 0 3
99422: ARRAY
99423: PUSH
99424: LD_INT 2
99426: ARRAY
99427: PPUSH
99428: LD_EXP 193
99432: PUSH
99433: LD_VAR 0 2
99437: ARRAY
99438: PUSH
99439: LD_VAR 0 3
99443: ARRAY
99444: PUSH
99445: LD_INT 3
99447: ARRAY
99448: PPUSH
99449: CALL_OW 488
99453: PUSH
99454: LD_EXP 193
99458: PUSH
99459: LD_VAR 0 2
99463: ARRAY
99464: PUSH
99465: LD_VAR 0 3
99469: ARRAY
99470: PUSH
99471: LD_INT 2
99473: ARRAY
99474: PPUSH
99475: LD_EXP 193
99479: PUSH
99480: LD_VAR 0 2
99484: ARRAY
99485: PUSH
99486: LD_VAR 0 3
99490: ARRAY
99491: PUSH
99492: LD_INT 3
99494: ARRAY
99495: PPUSH
99496: CALL_OW 284
99500: PUSH
99501: LD_INT 0
99503: EQUAL
99504: AND
99505: IFFALSE 99560
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
99507: LD_ADDR_VAR 0 5
99511: PUSH
99512: LD_EXP 193
99516: PUSH
99517: LD_VAR 0 2
99521: ARRAY
99522: PPUSH
99523: LD_VAR 0 3
99527: PPUSH
99528: CALL_OW 3
99532: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
99533: LD_ADDR_EXP 193
99537: PUSH
99538: LD_EXP 193
99542: PPUSH
99543: LD_VAR 0 2
99547: PPUSH
99548: LD_VAR 0 5
99552: PPUSH
99553: CALL_OW 1
99557: ST_TO_ADDR
// continue ;
99558: GO 99404
// end ; if DangerAtRangeXY ( side , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
99560: LD_VAR 0 6
99564: PPUSH
99565: LD_EXP 193
99569: PUSH
99570: LD_VAR 0 2
99574: ARRAY
99575: PUSH
99576: LD_VAR 0 3
99580: ARRAY
99581: PUSH
99582: LD_INT 2
99584: ARRAY
99585: PPUSH
99586: LD_EXP 193
99590: PUSH
99591: LD_VAR 0 2
99595: ARRAY
99596: PUSH
99597: LD_VAR 0 3
99601: ARRAY
99602: PUSH
99603: LD_INT 3
99605: ARRAY
99606: PPUSH
99607: LD_INT 30
99609: PPUSH
99610: CALL 25106 0 4
99614: PUSH
99615: LD_INT 4
99617: ARRAY
99618: PUSH
99619: LD_INT 0
99621: EQUAL
99622: IFFALSE 99648
// begin target := mc_crates [ i ] [ j ] ;
99624: LD_ADDR_VAR 0 7
99628: PUSH
99629: LD_EXP 193
99633: PUSH
99634: LD_VAR 0 2
99638: ARRAY
99639: PUSH
99640: LD_VAR 0 3
99644: ARRAY
99645: ST_TO_ADDR
// break ;
99646: GO 99650
// end ; end ;
99648: GO 99404
99650: POP
99651: POP
// if not target then
99652: LD_VAR 0 7
99656: NOT
99657: IFFALSE 99661
// continue ;
99659: GO 99211
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
99661: LD_ADDR_VAR 0 8
99665: PUSH
99666: LD_EXP 196
99670: PUSH
99671: LD_VAR 0 2
99675: ARRAY
99676: PPUSH
99677: LD_INT 2
99679: PUSH
99680: LD_INT 3
99682: PUSH
99683: LD_INT 58
99685: PUSH
99686: EMPTY
99687: LIST
99688: PUSH
99689: EMPTY
99690: LIST
99691: LIST
99692: PUSH
99693: LD_INT 61
99695: PUSH
99696: EMPTY
99697: LIST
99698: PUSH
99699: LD_INT 33
99701: PUSH
99702: LD_INT 5
99704: PUSH
99705: EMPTY
99706: LIST
99707: LIST
99708: PUSH
99709: LD_INT 33
99711: PUSH
99712: LD_INT 3
99714: PUSH
99715: EMPTY
99716: LIST
99717: LIST
99718: PUSH
99719: EMPTY
99720: LIST
99721: LIST
99722: LIST
99723: LIST
99724: LIST
99725: PUSH
99726: LD_INT 2
99728: PUSH
99729: LD_INT 34
99731: PUSH
99732: LD_INT 32
99734: PUSH
99735: EMPTY
99736: LIST
99737: LIST
99738: PUSH
99739: LD_INT 34
99741: PUSH
99742: LD_INT 51
99744: PUSH
99745: EMPTY
99746: LIST
99747: LIST
99748: PUSH
99749: LD_INT 34
99751: PUSH
99752: LD_INT 12
99754: PUSH
99755: EMPTY
99756: LIST
99757: LIST
99758: PUSH
99759: EMPTY
99760: LIST
99761: LIST
99762: LIST
99763: LIST
99764: PUSH
99765: EMPTY
99766: LIST
99767: LIST
99768: PPUSH
99769: CALL_OW 72
99773: ST_TO_ADDR
// if not cargo then
99774: LD_VAR 0 8
99778: NOT
99779: IFFALSE 100485
// begin if mc_crates_collector [ i ] < 5 then
99781: LD_EXP 194
99785: PUSH
99786: LD_VAR 0 2
99790: ARRAY
99791: PUSH
99792: LD_INT 5
99794: LESS
99795: IFFALSE 100161
// begin if mc_ape [ i ] then
99797: LD_EXP 206
99801: PUSH
99802: LD_VAR 0 2
99806: ARRAY
99807: IFFALSE 99854
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
99809: LD_ADDR_VAR 0 5
99813: PUSH
99814: LD_EXP 206
99818: PUSH
99819: LD_VAR 0 2
99823: ARRAY
99824: PPUSH
99825: LD_INT 25
99827: PUSH
99828: LD_INT 16
99830: PUSH
99831: EMPTY
99832: LIST
99833: LIST
99834: PUSH
99835: LD_INT 24
99837: PUSH
99838: LD_INT 750
99840: PUSH
99841: EMPTY
99842: LIST
99843: LIST
99844: PUSH
99845: EMPTY
99846: LIST
99847: LIST
99848: PPUSH
99849: CALL_OW 72
99853: ST_TO_ADDR
// if not tmp then
99854: LD_VAR 0 5
99858: NOT
99859: IFFALSE 99906
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
99861: LD_ADDR_VAR 0 5
99865: PUSH
99866: LD_EXP 177
99870: PUSH
99871: LD_VAR 0 2
99875: ARRAY
99876: PPUSH
99877: LD_INT 25
99879: PUSH
99880: LD_INT 2
99882: PUSH
99883: EMPTY
99884: LIST
99885: LIST
99886: PUSH
99887: LD_INT 24
99889: PUSH
99890: LD_INT 750
99892: PUSH
99893: EMPTY
99894: LIST
99895: LIST
99896: PUSH
99897: EMPTY
99898: LIST
99899: LIST
99900: PPUSH
99901: CALL_OW 72
99905: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
99906: LD_EXP 206
99910: PUSH
99911: LD_VAR 0 2
99915: ARRAY
99916: PUSH
99917: LD_EXP 177
99921: PUSH
99922: LD_VAR 0 2
99926: ARRAY
99927: PPUSH
99928: LD_INT 25
99930: PUSH
99931: LD_INT 2
99933: PUSH
99934: EMPTY
99935: LIST
99936: LIST
99937: PUSH
99938: LD_INT 24
99940: PUSH
99941: LD_INT 750
99943: PUSH
99944: EMPTY
99945: LIST
99946: LIST
99947: PUSH
99948: EMPTY
99949: LIST
99950: LIST
99951: PPUSH
99952: CALL_OW 72
99956: AND
99957: PUSH
99958: LD_VAR 0 5
99962: PUSH
99963: LD_INT 5
99965: LESS
99966: AND
99967: IFFALSE 100049
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
99969: LD_ADDR_VAR 0 3
99973: PUSH
99974: LD_EXP 177
99978: PUSH
99979: LD_VAR 0 2
99983: ARRAY
99984: PPUSH
99985: LD_INT 25
99987: PUSH
99988: LD_INT 2
99990: PUSH
99991: EMPTY
99992: LIST
99993: LIST
99994: PUSH
99995: LD_INT 24
99997: PUSH
99998: LD_INT 750
100000: PUSH
100001: EMPTY
100002: LIST
100003: LIST
100004: PUSH
100005: EMPTY
100006: LIST
100007: LIST
100008: PPUSH
100009: CALL_OW 72
100013: PUSH
100014: FOR_IN
100015: IFFALSE 100047
// begin tmp := tmp union j ;
100017: LD_ADDR_VAR 0 5
100021: PUSH
100022: LD_VAR 0 5
100026: PUSH
100027: LD_VAR 0 3
100031: UNION
100032: ST_TO_ADDR
// if tmp >= 5 then
100033: LD_VAR 0 5
100037: PUSH
100038: LD_INT 5
100040: GREATEREQUAL
100041: IFFALSE 100045
// break ;
100043: GO 100047
// end ;
100045: GO 100014
100047: POP
100048: POP
// end ; if not tmp then
100049: LD_VAR 0 5
100053: NOT
100054: IFFALSE 100058
// continue ;
100056: GO 99211
// for j in tmp do
100058: LD_ADDR_VAR 0 3
100062: PUSH
100063: LD_VAR 0 5
100067: PUSH
100068: FOR_IN
100069: IFFALSE 100159
// if not GetTag ( j ) then
100071: LD_VAR 0 3
100075: PPUSH
100076: CALL_OW 110
100080: NOT
100081: IFFALSE 100157
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
100083: LD_ADDR_EXP 194
100087: PUSH
100088: LD_EXP 194
100092: PPUSH
100093: LD_VAR 0 2
100097: PUSH
100098: LD_EXP 194
100102: PUSH
100103: LD_VAR 0 2
100107: ARRAY
100108: PUSH
100109: LD_INT 1
100111: PLUS
100112: PUSH
100113: EMPTY
100114: LIST
100115: LIST
100116: PPUSH
100117: LD_VAR 0 3
100121: PPUSH
100122: CALL 24210 0 3
100126: ST_TO_ADDR
// SetTag ( j , 107 ) ;
100127: LD_VAR 0 3
100131: PPUSH
100132: LD_INT 107
100134: PPUSH
100135: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
100139: LD_EXP 194
100143: PUSH
100144: LD_VAR 0 2
100148: ARRAY
100149: PUSH
100150: LD_INT 5
100152: GREATEREQUAL
100153: IFFALSE 100157
// break ;
100155: GO 100159
// end ;
100157: GO 100068
100159: POP
100160: POP
// end ; if mc_crates_collector [ i ] and target then
100161: LD_EXP 194
100165: PUSH
100166: LD_VAR 0 2
100170: ARRAY
100171: PUSH
100172: LD_VAR 0 7
100176: AND
100177: IFFALSE 100483
// begin if mc_crates_collector [ i ] < target [ 1 ] then
100179: LD_EXP 194
100183: PUSH
100184: LD_VAR 0 2
100188: ARRAY
100189: PUSH
100190: LD_VAR 0 7
100194: PUSH
100195: LD_INT 1
100197: ARRAY
100198: LESS
100199: IFFALSE 100219
// tmp := mc_crates_collector [ i ] else
100201: LD_ADDR_VAR 0 5
100205: PUSH
100206: LD_EXP 194
100210: PUSH
100211: LD_VAR 0 2
100215: ARRAY
100216: ST_TO_ADDR
100217: GO 100233
// tmp := target [ 1 ] ;
100219: LD_ADDR_VAR 0 5
100223: PUSH
100224: LD_VAR 0 7
100228: PUSH
100229: LD_INT 1
100231: ARRAY
100232: ST_TO_ADDR
// k := 0 ;
100233: LD_ADDR_VAR 0 4
100237: PUSH
100238: LD_INT 0
100240: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
100241: LD_ADDR_VAR 0 3
100245: PUSH
100246: LD_EXP 194
100250: PUSH
100251: LD_VAR 0 2
100255: ARRAY
100256: PUSH
100257: FOR_IN
100258: IFFALSE 100481
// begin k := k + 1 ;
100260: LD_ADDR_VAR 0 4
100264: PUSH
100265: LD_VAR 0 4
100269: PUSH
100270: LD_INT 1
100272: PLUS
100273: ST_TO_ADDR
// if k > tmp then
100274: LD_VAR 0 4
100278: PUSH
100279: LD_VAR 0 5
100283: GREATER
100284: IFFALSE 100288
// break ;
100286: GO 100481
// if not GetClass ( j ) in [ 2 , 16 ] then
100288: LD_VAR 0 3
100292: PPUSH
100293: CALL_OW 257
100297: PUSH
100298: LD_INT 2
100300: PUSH
100301: LD_INT 16
100303: PUSH
100304: EMPTY
100305: LIST
100306: LIST
100307: IN
100308: NOT
100309: IFFALSE 100362
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
100311: LD_ADDR_EXP 194
100315: PUSH
100316: LD_EXP 194
100320: PPUSH
100321: LD_VAR 0 2
100325: PPUSH
100326: LD_EXP 194
100330: PUSH
100331: LD_VAR 0 2
100335: ARRAY
100336: PUSH
100337: LD_VAR 0 3
100341: DIFF
100342: PPUSH
100343: CALL_OW 1
100347: ST_TO_ADDR
// SetTag ( j , 0 ) ;
100348: LD_VAR 0 3
100352: PPUSH
100353: LD_INT 0
100355: PPUSH
100356: CALL_OW 109
// continue ;
100360: GO 100257
// end ; if IsInUnit ( j ) then
100362: LD_VAR 0 3
100366: PPUSH
100367: CALL_OW 310
100371: IFFALSE 100382
// ComExitBuilding ( j ) ;
100373: LD_VAR 0 3
100377: PPUSH
100378: CALL_OW 122
// wait ( 3 ) ;
100382: LD_INT 3
100384: PPUSH
100385: CALL_OW 67
// if HasTask ( j ) and DangerAtRangeXY ( side , target [ 2 ] , target [ 3 ] , 30 ) [ 4 ] then
100389: LD_VAR 0 3
100393: PPUSH
100394: CALL_OW 314
100398: PUSH
100399: LD_VAR 0 6
100403: PPUSH
100404: LD_VAR 0 7
100408: PUSH
100409: LD_INT 2
100411: ARRAY
100412: PPUSH
100413: LD_VAR 0 7
100417: PUSH
100418: LD_INT 3
100420: ARRAY
100421: PPUSH
100422: LD_INT 30
100424: PPUSH
100425: CALL 25106 0 4
100429: PUSH
100430: LD_INT 4
100432: ARRAY
100433: AND
100434: IFFALSE 100452
// ComStandNearbyBuilding ( j , depot ) else
100436: LD_VAR 0 3
100440: PPUSH
100441: LD_VAR 0 9
100445: PPUSH
100446: CALL 20788 0 2
100450: GO 100479
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
100452: LD_VAR 0 3
100456: PPUSH
100457: LD_VAR 0 7
100461: PUSH
100462: LD_INT 2
100464: ARRAY
100465: PPUSH
100466: LD_VAR 0 7
100470: PUSH
100471: LD_INT 3
100473: ARRAY
100474: PPUSH
100475: CALL_OW 117
// end ;
100479: GO 100257
100481: POP
100482: POP
// end ; end else
100483: GO 101015
// begin for j in cargo do
100485: LD_ADDR_VAR 0 3
100489: PUSH
100490: LD_VAR 0 8
100494: PUSH
100495: FOR_IN
100496: IFFALSE 101013
// begin if GetTag ( j ) <> 0 then
100498: LD_VAR 0 3
100502: PPUSH
100503: CALL_OW 110
100507: PUSH
100508: LD_INT 0
100510: NONEQUAL
100511: IFFALSE 100515
// continue ;
100513: GO 100495
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
100515: LD_VAR 0 3
100519: PPUSH
100520: CALL_OW 256
100524: PUSH
100525: LD_INT 1000
100527: LESS
100528: PUSH
100529: LD_VAR 0 3
100533: PPUSH
100534: LD_EXP 201
100538: PUSH
100539: LD_VAR 0 2
100543: ARRAY
100544: PPUSH
100545: CALL_OW 308
100549: NOT
100550: AND
100551: IFFALSE 100573
// ComMoveToArea ( j , mc_parking [ i ] ) ;
100553: LD_VAR 0 3
100557: PPUSH
100558: LD_EXP 201
100562: PUSH
100563: LD_VAR 0 2
100567: ARRAY
100568: PPUSH
100569: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
100573: LD_VAR 0 3
100577: PPUSH
100578: CALL_OW 256
100582: PUSH
100583: LD_INT 1000
100585: LESS
100586: PUSH
100587: LD_VAR 0 3
100591: PPUSH
100592: LD_EXP 201
100596: PUSH
100597: LD_VAR 0 2
100601: ARRAY
100602: PPUSH
100603: CALL_OW 308
100607: AND
100608: IFFALSE 100612
// continue ;
100610: GO 100495
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
100612: LD_VAR 0 3
100616: PPUSH
100617: CALL_OW 262
100621: PUSH
100622: LD_INT 2
100624: EQUAL
100625: PUSH
100626: LD_VAR 0 3
100630: PPUSH
100631: CALL_OW 261
100635: PUSH
100636: LD_INT 15
100638: LESS
100639: AND
100640: IFFALSE 100644
// continue ;
100642: GO 100495
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
100644: LD_VAR 0 3
100648: PPUSH
100649: CALL_OW 262
100653: PUSH
100654: LD_INT 1
100656: EQUAL
100657: PUSH
100658: LD_VAR 0 3
100662: PPUSH
100663: CALL_OW 261
100667: PUSH
100668: LD_INT 10
100670: LESS
100671: AND
100672: IFFALSE 100952
// begin if not depot then
100674: LD_VAR 0 9
100678: NOT
100679: IFFALSE 100683
// continue ;
100681: GO 100495
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
100683: LD_VAR 0 3
100687: PPUSH
100688: LD_VAR 0 9
100692: PPUSH
100693: LD_VAR 0 3
100697: PPUSH
100698: CALL_OW 74
100702: PPUSH
100703: CALL_OW 296
100707: PUSH
100708: LD_INT 6
100710: LESS
100711: IFFALSE 100727
// SetFuel ( j , 100 ) else
100713: LD_VAR 0 3
100717: PPUSH
100718: LD_INT 100
100720: PPUSH
100721: CALL_OW 240
100725: GO 100952
// if GetFuel ( j ) = 0 then
100727: LD_VAR 0 3
100731: PPUSH
100732: CALL_OW 261
100736: PUSH
100737: LD_INT 0
100739: EQUAL
100740: IFFALSE 100952
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
100742: LD_ADDR_EXP 196
100746: PUSH
100747: LD_EXP 196
100751: PPUSH
100752: LD_VAR 0 2
100756: PPUSH
100757: LD_EXP 196
100761: PUSH
100762: LD_VAR 0 2
100766: ARRAY
100767: PUSH
100768: LD_VAR 0 3
100772: DIFF
100773: PPUSH
100774: CALL_OW 1
100778: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
100779: LD_VAR 0 3
100783: PPUSH
100784: CALL_OW 263
100788: PUSH
100789: LD_INT 1
100791: EQUAL
100792: IFFALSE 100808
// ComExitVehicle ( IsInUnit ( j ) ) ;
100794: LD_VAR 0 3
100798: PPUSH
100799: CALL_OW 310
100803: PPUSH
100804: CALL_OW 121
// if GetControl ( j ) = control_remote then
100808: LD_VAR 0 3
100812: PPUSH
100813: CALL_OW 263
100817: PUSH
100818: LD_INT 2
100820: EQUAL
100821: IFFALSE 100832
// ComUnlink ( j ) ;
100823: LD_VAR 0 3
100827: PPUSH
100828: CALL_OW 136
// fac := MC_GetBuildings ( i , b_factory ) ;
100832: LD_ADDR_VAR 0 10
100836: PUSH
100837: LD_VAR 0 2
100841: PPUSH
100842: LD_INT 3
100844: PPUSH
100845: CALL 110591 0 2
100849: ST_TO_ADDR
// if fac then
100850: LD_VAR 0 10
100854: IFFALSE 100950
// begin for k in fac do
100856: LD_ADDR_VAR 0 4
100860: PUSH
100861: LD_VAR 0 10
100865: PUSH
100866: FOR_IN
100867: IFFALSE 100948
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
100869: LD_ADDR_VAR 0 11
100873: PUSH
100874: LD_VAR 0 10
100878: PPUSH
100879: LD_VAR 0 3
100883: PPUSH
100884: CALL_OW 265
100888: PPUSH
100889: LD_VAR 0 3
100893: PPUSH
100894: CALL_OW 262
100898: PPUSH
100899: LD_VAR 0 3
100903: PPUSH
100904: CALL_OW 263
100908: PPUSH
100909: LD_VAR 0 3
100913: PPUSH
100914: CALL_OW 264
100918: PPUSH
100919: CALL 21706 0 5
100923: ST_TO_ADDR
// if components then
100924: LD_VAR 0 11
100928: IFFALSE 100946
// begin MC_InsertProduceList ( i , components ) ;
100930: LD_VAR 0 2
100934: PPUSH
100935: LD_VAR 0 11
100939: PPUSH
100940: CALL 110136 0 2
// break ;
100944: GO 100948
// end ; end ;
100946: GO 100866
100948: POP
100949: POP
// end ; continue ;
100950: GO 100495
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
100952: LD_VAR 0 3
100956: PPUSH
100957: LD_INT 1
100959: PPUSH
100960: CALL_OW 289
100964: PUSH
100965: LD_INT 100
100967: LESS
100968: PUSH
100969: LD_VAR 0 3
100973: PPUSH
100974: CALL_OW 314
100978: NOT
100979: AND
100980: IFFALSE 101009
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
100982: LD_VAR 0 3
100986: PPUSH
100987: LD_VAR 0 7
100991: PUSH
100992: LD_INT 2
100994: ARRAY
100995: PPUSH
100996: LD_VAR 0 7
101000: PUSH
101001: LD_INT 3
101003: ARRAY
101004: PPUSH
101005: CALL_OW 117
// break ;
101009: GO 101013
// end ;
101011: GO 100495
101013: POP
101014: POP
// end ; end ;
101015: GO 99211
101017: POP
101018: POP
// end ;
101019: LD_VAR 0 1
101023: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
101024: LD_INT 0
101026: PPUSH
101027: PPUSH
101028: PPUSH
101029: PPUSH
// if not mc_bases then
101030: LD_EXP 177
101034: NOT
101035: IFFALSE 101039
// exit ;
101037: GO 101200
// for i = 1 to mc_bases do
101039: LD_ADDR_VAR 0 2
101043: PUSH
101044: DOUBLE
101045: LD_INT 1
101047: DEC
101048: ST_TO_ADDR
101049: LD_EXP 177
101053: PUSH
101054: FOR_TO
101055: IFFALSE 101198
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
101057: LD_ADDR_VAR 0 4
101061: PUSH
101062: LD_EXP 196
101066: PUSH
101067: LD_VAR 0 2
101071: ARRAY
101072: PUSH
101073: LD_EXP 199
101077: PUSH
101078: LD_VAR 0 2
101082: ARRAY
101083: UNION
101084: PPUSH
101085: LD_INT 33
101087: PUSH
101088: LD_INT 2
101090: PUSH
101091: EMPTY
101092: LIST
101093: LIST
101094: PPUSH
101095: CALL_OW 72
101099: ST_TO_ADDR
// if tmp then
101100: LD_VAR 0 4
101104: IFFALSE 101196
// for j in tmp do
101106: LD_ADDR_VAR 0 3
101110: PUSH
101111: LD_VAR 0 4
101115: PUSH
101116: FOR_IN
101117: IFFALSE 101194
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
101119: LD_VAR 0 3
101123: PPUSH
101124: CALL_OW 312
101128: NOT
101129: PUSH
101130: LD_VAR 0 3
101134: PPUSH
101135: CALL_OW 256
101139: PUSH
101140: LD_INT 250
101142: GREATEREQUAL
101143: AND
101144: IFFALSE 101157
// Connect ( j ) else
101146: LD_VAR 0 3
101150: PPUSH
101151: CALL 27181 0 1
101155: GO 101192
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
101157: LD_VAR 0 3
101161: PPUSH
101162: CALL_OW 256
101166: PUSH
101167: LD_INT 250
101169: LESS
101170: PUSH
101171: LD_VAR 0 3
101175: PPUSH
101176: CALL_OW 312
101180: AND
101181: IFFALSE 101192
// ComUnlink ( j ) ;
101183: LD_VAR 0 3
101187: PPUSH
101188: CALL_OW 136
101192: GO 101116
101194: POP
101195: POP
// end ;
101196: GO 101054
101198: POP
101199: POP
// end ;
101200: LD_VAR 0 1
101204: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
101205: LD_INT 0
101207: PPUSH
101208: PPUSH
101209: PPUSH
101210: PPUSH
101211: PPUSH
// if not mc_bases then
101212: LD_EXP 177
101216: NOT
101217: IFFALSE 101221
// exit ;
101219: GO 101666
// for i = 1 to mc_bases do
101221: LD_ADDR_VAR 0 2
101225: PUSH
101226: DOUBLE
101227: LD_INT 1
101229: DEC
101230: ST_TO_ADDR
101231: LD_EXP 177
101235: PUSH
101236: FOR_TO
101237: IFFALSE 101664
// begin if not mc_produce [ i ] then
101239: LD_EXP 198
101243: PUSH
101244: LD_VAR 0 2
101248: ARRAY
101249: NOT
101250: IFFALSE 101254
// continue ;
101252: GO 101236
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
101254: LD_ADDR_VAR 0 5
101258: PUSH
101259: LD_EXP 177
101263: PUSH
101264: LD_VAR 0 2
101268: ARRAY
101269: PPUSH
101270: LD_INT 30
101272: PUSH
101273: LD_INT 3
101275: PUSH
101276: EMPTY
101277: LIST
101278: LIST
101279: PPUSH
101280: CALL_OW 72
101284: ST_TO_ADDR
// if not fac then
101285: LD_VAR 0 5
101289: NOT
101290: IFFALSE 101294
// continue ;
101292: GO 101236
// for j in fac do
101294: LD_ADDR_VAR 0 3
101298: PUSH
101299: LD_VAR 0 5
101303: PUSH
101304: FOR_IN
101305: IFFALSE 101660
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
101307: LD_VAR 0 3
101311: PPUSH
101312: CALL_OW 461
101316: PUSH
101317: LD_INT 2
101319: NONEQUAL
101320: PUSH
101321: LD_VAR 0 3
101325: PPUSH
101326: LD_INT 15
101328: PPUSH
101329: CALL 26809 0 2
101333: PUSH
101334: LD_INT 4
101336: ARRAY
101337: OR
101338: IFFALSE 101342
// continue ;
101340: GO 101304
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
101342: LD_VAR 0 3
101346: PPUSH
101347: LD_EXP 198
101351: PUSH
101352: LD_VAR 0 2
101356: ARRAY
101357: PUSH
101358: LD_INT 1
101360: ARRAY
101361: PUSH
101362: LD_INT 1
101364: ARRAY
101365: PPUSH
101366: LD_EXP 198
101370: PUSH
101371: LD_VAR 0 2
101375: ARRAY
101376: PUSH
101377: LD_INT 1
101379: ARRAY
101380: PUSH
101381: LD_INT 2
101383: ARRAY
101384: PPUSH
101385: LD_EXP 198
101389: PUSH
101390: LD_VAR 0 2
101394: ARRAY
101395: PUSH
101396: LD_INT 1
101398: ARRAY
101399: PUSH
101400: LD_INT 3
101402: ARRAY
101403: PPUSH
101404: LD_EXP 198
101408: PUSH
101409: LD_VAR 0 2
101413: ARRAY
101414: PUSH
101415: LD_INT 1
101417: ARRAY
101418: PUSH
101419: LD_INT 4
101421: ARRAY
101422: PPUSH
101423: CALL_OW 448
101427: PUSH
101428: LD_VAR 0 3
101432: PPUSH
101433: LD_EXP 198
101437: PUSH
101438: LD_VAR 0 2
101442: ARRAY
101443: PUSH
101444: LD_INT 1
101446: ARRAY
101447: PUSH
101448: LD_INT 1
101450: ARRAY
101451: PUSH
101452: LD_EXP 198
101456: PUSH
101457: LD_VAR 0 2
101461: ARRAY
101462: PUSH
101463: LD_INT 1
101465: ARRAY
101466: PUSH
101467: LD_INT 2
101469: ARRAY
101470: PUSH
101471: LD_EXP 198
101475: PUSH
101476: LD_VAR 0 2
101480: ARRAY
101481: PUSH
101482: LD_INT 1
101484: ARRAY
101485: PUSH
101486: LD_INT 3
101488: ARRAY
101489: PUSH
101490: LD_EXP 198
101494: PUSH
101495: LD_VAR 0 2
101499: ARRAY
101500: PUSH
101501: LD_INT 1
101503: ARRAY
101504: PUSH
101505: LD_INT 4
101507: ARRAY
101508: PUSH
101509: EMPTY
101510: LIST
101511: LIST
101512: LIST
101513: LIST
101514: PPUSH
101515: CALL 30576 0 2
101519: AND
101520: IFFALSE 101658
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
101522: LD_VAR 0 3
101526: PPUSH
101527: LD_EXP 198
101531: PUSH
101532: LD_VAR 0 2
101536: ARRAY
101537: PUSH
101538: LD_INT 1
101540: ARRAY
101541: PUSH
101542: LD_INT 1
101544: ARRAY
101545: PPUSH
101546: LD_EXP 198
101550: PUSH
101551: LD_VAR 0 2
101555: ARRAY
101556: PUSH
101557: LD_INT 1
101559: ARRAY
101560: PUSH
101561: LD_INT 2
101563: ARRAY
101564: PPUSH
101565: LD_EXP 198
101569: PUSH
101570: LD_VAR 0 2
101574: ARRAY
101575: PUSH
101576: LD_INT 1
101578: ARRAY
101579: PUSH
101580: LD_INT 3
101582: ARRAY
101583: PPUSH
101584: LD_EXP 198
101588: PUSH
101589: LD_VAR 0 2
101593: ARRAY
101594: PUSH
101595: LD_INT 1
101597: ARRAY
101598: PUSH
101599: LD_INT 4
101601: ARRAY
101602: PPUSH
101603: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
101607: LD_ADDR_VAR 0 4
101611: PUSH
101612: LD_EXP 198
101616: PUSH
101617: LD_VAR 0 2
101621: ARRAY
101622: PPUSH
101623: LD_INT 1
101625: PPUSH
101626: CALL_OW 3
101630: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
101631: LD_ADDR_EXP 198
101635: PUSH
101636: LD_EXP 198
101640: PPUSH
101641: LD_VAR 0 2
101645: PPUSH
101646: LD_VAR 0 4
101650: PPUSH
101651: CALL_OW 1
101655: ST_TO_ADDR
// break ;
101656: GO 101660
// end ; end ;
101658: GO 101304
101660: POP
101661: POP
// end ;
101662: GO 101236
101664: POP
101665: POP
// end ;
101666: LD_VAR 0 1
101670: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
101671: LD_INT 0
101673: PPUSH
101674: PPUSH
101675: PPUSH
// if not mc_bases then
101676: LD_EXP 177
101680: NOT
101681: IFFALSE 101685
// exit ;
101683: GO 101774
// for i = 1 to mc_bases do
101685: LD_ADDR_VAR 0 2
101689: PUSH
101690: DOUBLE
101691: LD_INT 1
101693: DEC
101694: ST_TO_ADDR
101695: LD_EXP 177
101699: PUSH
101700: FOR_TO
101701: IFFALSE 101772
// begin if mc_attack [ i ] then
101703: LD_EXP 197
101707: PUSH
101708: LD_VAR 0 2
101712: ARRAY
101713: IFFALSE 101770
// begin tmp := mc_attack [ i ] [ 1 ] ;
101715: LD_ADDR_VAR 0 3
101719: PUSH
101720: LD_EXP 197
101724: PUSH
101725: LD_VAR 0 2
101729: ARRAY
101730: PUSH
101731: LD_INT 1
101733: ARRAY
101734: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
101735: LD_ADDR_EXP 197
101739: PUSH
101740: LD_EXP 197
101744: PPUSH
101745: LD_VAR 0 2
101749: PPUSH
101750: EMPTY
101751: PPUSH
101752: CALL_OW 1
101756: ST_TO_ADDR
// Attack ( tmp ) ;
101757: LD_VAR 0 3
101761: PPUSH
101762: CALL 78615 0 1
// exit ;
101766: POP
101767: POP
101768: GO 101774
// end ; end ;
101770: GO 101700
101772: POP
101773: POP
// end ;
101774: LD_VAR 0 1
101778: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
101779: LD_INT 0
101781: PPUSH
101782: PPUSH
101783: PPUSH
101784: PPUSH
101785: PPUSH
101786: PPUSH
101787: PPUSH
// if not mc_bases then
101788: LD_EXP 177
101792: NOT
101793: IFFALSE 101797
// exit ;
101795: GO 102654
// for i = 1 to mc_bases do
101797: LD_ADDR_VAR 0 2
101801: PUSH
101802: DOUBLE
101803: LD_INT 1
101805: DEC
101806: ST_TO_ADDR
101807: LD_EXP 177
101811: PUSH
101812: FOR_TO
101813: IFFALSE 102652
// begin if not mc_bases [ i ] then
101815: LD_EXP 177
101819: PUSH
101820: LD_VAR 0 2
101824: ARRAY
101825: NOT
101826: IFFALSE 101830
// continue ;
101828: GO 101812
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
101830: LD_ADDR_VAR 0 7
101834: PUSH
101835: LD_EXP 177
101839: PUSH
101840: LD_VAR 0 2
101844: ARRAY
101845: PUSH
101846: LD_INT 1
101848: ARRAY
101849: PPUSH
101850: CALL 21010 0 1
101854: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
101855: LD_ADDR_EXP 200
101859: PUSH
101860: LD_EXP 200
101864: PPUSH
101865: LD_VAR 0 2
101869: PPUSH
101870: LD_EXP 177
101874: PUSH
101875: LD_VAR 0 2
101879: ARRAY
101880: PUSH
101881: LD_INT 1
101883: ARRAY
101884: PPUSH
101885: CALL_OW 255
101889: PPUSH
101890: LD_EXP 202
101894: PUSH
101895: LD_VAR 0 2
101899: ARRAY
101900: PPUSH
101901: CALL 20975 0 2
101905: PPUSH
101906: CALL_OW 1
101910: ST_TO_ADDR
// if not mc_scan [ i ] then
101911: LD_EXP 200
101915: PUSH
101916: LD_VAR 0 2
101920: ARRAY
101921: NOT
101922: IFFALSE 102100
// begin mc_is_defending := Replace ( mc_is_defending , i , false ) ;
101924: LD_ADDR_EXP 220
101928: PUSH
101929: LD_EXP 220
101933: PPUSH
101934: LD_VAR 0 2
101938: PPUSH
101939: LD_INT 0
101941: PPUSH
101942: CALL_OW 1
101946: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
101947: LD_ADDR_VAR 0 4
101951: PUSH
101952: LD_EXP 177
101956: PUSH
101957: LD_VAR 0 2
101961: ARRAY
101962: PPUSH
101963: LD_INT 2
101965: PUSH
101966: LD_INT 25
101968: PUSH
101969: LD_INT 5
101971: PUSH
101972: EMPTY
101973: LIST
101974: LIST
101975: PUSH
101976: LD_INT 25
101978: PUSH
101979: LD_INT 8
101981: PUSH
101982: EMPTY
101983: LIST
101984: LIST
101985: PUSH
101986: LD_INT 25
101988: PUSH
101989: LD_INT 9
101991: PUSH
101992: EMPTY
101993: LIST
101994: LIST
101995: PUSH
101996: EMPTY
101997: LIST
101998: LIST
101999: LIST
102000: LIST
102001: PPUSH
102002: CALL_OW 72
102006: ST_TO_ADDR
// if not tmp then
102007: LD_VAR 0 4
102011: NOT
102012: IFFALSE 102016
// continue ;
102014: GO 101812
// for j in tmp do
102016: LD_ADDR_VAR 0 3
102020: PUSH
102021: LD_VAR 0 4
102025: PUSH
102026: FOR_IN
102027: IFFALSE 102098
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
102029: LD_VAR 0 3
102033: PPUSH
102034: CALL_OW 310
102038: PPUSH
102039: CALL_OW 266
102043: PUSH
102044: LD_INT 5
102046: EQUAL
102047: PUSH
102048: LD_VAR 0 3
102052: PPUSH
102053: CALL_OW 257
102057: PUSH
102058: LD_INT 1
102060: EQUAL
102061: AND
102062: PUSH
102063: LD_VAR 0 3
102067: PPUSH
102068: CALL_OW 459
102072: NOT
102073: AND
102074: PUSH
102075: LD_VAR 0 7
102079: AND
102080: IFFALSE 102096
// ComChangeProfession ( j , class ) ;
102082: LD_VAR 0 3
102086: PPUSH
102087: LD_VAR 0 7
102091: PPUSH
102092: CALL_OW 123
102096: GO 102026
102098: POP
102099: POP
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and not mc_defender [ i ] and ( UnitFilter ( mc_bases [ i ] , [ [ f_ok ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) < 4 or UnitFilter ( mc_bases [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ) then
102100: LD_EXP 200
102104: PUSH
102105: LD_VAR 0 2
102109: ARRAY
102110: PUSH
102111: LD_EXP 220
102115: PUSH
102116: LD_VAR 0 2
102120: ARRAY
102121: NOT
102122: AND
102123: PUSH
102124: LD_EXP 199
102128: PUSH
102129: LD_VAR 0 2
102133: ARRAY
102134: NOT
102135: AND
102136: PUSH
102137: LD_EXP 177
102141: PUSH
102142: LD_VAR 0 2
102146: ARRAY
102147: PPUSH
102148: LD_INT 50
102150: PUSH
102151: EMPTY
102152: LIST
102153: PUSH
102154: LD_INT 2
102156: PUSH
102157: LD_INT 30
102159: PUSH
102160: LD_INT 32
102162: PUSH
102163: EMPTY
102164: LIST
102165: LIST
102166: PUSH
102167: LD_INT 30
102169: PUSH
102170: LD_INT 33
102172: PUSH
102173: EMPTY
102174: LIST
102175: LIST
102176: PUSH
102177: LD_INT 30
102179: PUSH
102180: LD_INT 4
102182: PUSH
102183: EMPTY
102184: LIST
102185: LIST
102186: PUSH
102187: LD_INT 30
102189: PUSH
102190: LD_INT 5
102192: PUSH
102193: EMPTY
102194: LIST
102195: LIST
102196: PUSH
102197: EMPTY
102198: LIST
102199: LIST
102200: LIST
102201: LIST
102202: LIST
102203: PUSH
102204: EMPTY
102205: LIST
102206: LIST
102207: PPUSH
102208: CALL_OW 72
102212: PUSH
102213: LD_INT 4
102215: LESS
102216: PUSH
102217: LD_EXP 177
102221: PUSH
102222: LD_VAR 0 2
102226: ARRAY
102227: PPUSH
102228: LD_INT 3
102230: PUSH
102231: LD_INT 24
102233: PUSH
102234: LD_INT 1000
102236: PUSH
102237: EMPTY
102238: LIST
102239: LIST
102240: PUSH
102241: EMPTY
102242: LIST
102243: LIST
102244: PUSH
102245: LD_INT 2
102247: PUSH
102248: LD_INT 30
102250: PUSH
102251: LD_INT 0
102253: PUSH
102254: EMPTY
102255: LIST
102256: LIST
102257: PUSH
102258: LD_INT 30
102260: PUSH
102261: LD_INT 1
102263: PUSH
102264: EMPTY
102265: LIST
102266: LIST
102267: PUSH
102268: EMPTY
102269: LIST
102270: LIST
102271: LIST
102272: PUSH
102273: EMPTY
102274: LIST
102275: LIST
102276: PPUSH
102277: CALL_OW 72
102281: OR
102282: AND
102283: IFFALSE 102534
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
102285: LD_ADDR_EXP 220
102289: PUSH
102290: LD_EXP 220
102294: PPUSH
102295: LD_VAR 0 2
102299: PPUSH
102300: LD_INT 1
102302: PPUSH
102303: CALL_OW 1
102307: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
102308: LD_ADDR_VAR 0 4
102312: PUSH
102313: LD_EXP 177
102317: PUSH
102318: LD_VAR 0 2
102322: ARRAY
102323: PPUSH
102324: LD_INT 2
102326: PUSH
102327: LD_INT 25
102329: PUSH
102330: LD_INT 1
102332: PUSH
102333: EMPTY
102334: LIST
102335: LIST
102336: PUSH
102337: LD_INT 25
102339: PUSH
102340: LD_INT 5
102342: PUSH
102343: EMPTY
102344: LIST
102345: LIST
102346: PUSH
102347: LD_INT 25
102349: PUSH
102350: LD_INT 8
102352: PUSH
102353: EMPTY
102354: LIST
102355: LIST
102356: PUSH
102357: LD_INT 25
102359: PUSH
102360: LD_INT 9
102362: PUSH
102363: EMPTY
102364: LIST
102365: LIST
102366: PUSH
102367: EMPTY
102368: LIST
102369: LIST
102370: LIST
102371: LIST
102372: LIST
102373: PPUSH
102374: CALL_OW 72
102378: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
102379: LD_ADDR_VAR 0 4
102383: PUSH
102384: LD_VAR 0 4
102388: PUSH
102389: LD_VAR 0 4
102393: PPUSH
102394: LD_INT 18
102396: PPUSH
102397: CALL 53479 0 2
102401: DIFF
102402: ST_TO_ADDR
// if not tmp and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
102403: LD_VAR 0 4
102407: NOT
102408: PUSH
102409: LD_EXP 177
102413: PUSH
102414: LD_VAR 0 2
102418: ARRAY
102419: PPUSH
102420: LD_INT 2
102422: PUSH
102423: LD_INT 30
102425: PUSH
102426: LD_INT 4
102428: PUSH
102429: EMPTY
102430: LIST
102431: LIST
102432: PUSH
102433: LD_INT 30
102435: PUSH
102436: LD_INT 5
102438: PUSH
102439: EMPTY
102440: LIST
102441: LIST
102442: PUSH
102443: EMPTY
102444: LIST
102445: LIST
102446: LIST
102447: PPUSH
102448: CALL_OW 72
102452: NOT
102453: AND
102454: IFFALSE 102516
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ) ;
102456: LD_ADDR_VAR 0 4
102460: PUSH
102461: LD_EXP 177
102465: PUSH
102466: LD_VAR 0 2
102470: ARRAY
102471: PPUSH
102472: LD_INT 2
102474: PUSH
102475: LD_INT 25
102477: PUSH
102478: LD_INT 2
102480: PUSH
102481: EMPTY
102482: LIST
102483: LIST
102484: PUSH
102485: LD_INT 25
102487: PUSH
102488: LD_INT 3
102490: PUSH
102491: EMPTY
102492: LIST
102493: LIST
102494: PUSH
102495: LD_INT 25
102497: PUSH
102498: LD_INT 4
102500: PUSH
102501: EMPTY
102502: LIST
102503: LIST
102504: PUSH
102505: EMPTY
102506: LIST
102507: LIST
102508: LIST
102509: LIST
102510: PPUSH
102511: CALL_OW 72
102515: ST_TO_ADDR
// BasicDefend ( i , tmp ) ;
102516: LD_VAR 0 2
102520: PPUSH
102521: LD_VAR 0 4
102525: PPUSH
102526: CALL 83324 0 2
// exit ;
102530: POP
102531: POP
102532: GO 102654
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and mc_defender [ i ] then
102534: LD_EXP 200
102538: PUSH
102539: LD_VAR 0 2
102543: ARRAY
102544: PUSH
102545: LD_EXP 220
102549: PUSH
102550: LD_VAR 0 2
102554: ARRAY
102555: NOT
102556: AND
102557: PUSH
102558: LD_EXP 199
102562: PUSH
102563: LD_VAR 0 2
102567: ARRAY
102568: AND
102569: IFFALSE 102650
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
102571: LD_ADDR_EXP 220
102575: PUSH
102576: LD_EXP 220
102580: PPUSH
102581: LD_VAR 0 2
102585: PPUSH
102586: LD_INT 1
102588: PPUSH
102589: CALL_OW 1
102593: ST_TO_ADDR
// tmp := mc_defender [ i ] ;
102594: LD_ADDR_VAR 0 4
102598: PUSH
102599: LD_EXP 199
102603: PUSH
102604: LD_VAR 0 2
102608: ARRAY
102609: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
102610: LD_ADDR_EXP 199
102614: PUSH
102615: LD_EXP 199
102619: PPUSH
102620: LD_VAR 0 2
102624: PPUSH
102625: EMPTY
102626: PPUSH
102627: CALL_OW 1
102631: ST_TO_ADDR
// Defend ( i , tmp ) ;
102632: LD_VAR 0 2
102636: PPUSH
102637: LD_VAR 0 4
102641: PPUSH
102642: CALL 83920 0 2
// exit ;
102646: POP
102647: POP
102648: GO 102654
// end ; end ;
102650: GO 101812
102652: POP
102653: POP
// end ;
102654: LD_VAR 0 1
102658: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
102659: LD_INT 0
102661: PPUSH
102662: PPUSH
102663: PPUSH
102664: PPUSH
102665: PPUSH
102666: PPUSH
102667: PPUSH
102668: PPUSH
102669: PPUSH
102670: PPUSH
102671: PPUSH
// if not mc_bases then
102672: LD_EXP 177
102676: NOT
102677: IFFALSE 102681
// exit ;
102679: GO 103768
// for i = 1 to mc_bases do
102681: LD_ADDR_VAR 0 2
102685: PUSH
102686: DOUBLE
102687: LD_INT 1
102689: DEC
102690: ST_TO_ADDR
102691: LD_EXP 177
102695: PUSH
102696: FOR_TO
102697: IFFALSE 103766
// begin tmp := mc_lab [ i ] ;
102699: LD_ADDR_VAR 0 6
102703: PUSH
102704: LD_EXP 210
102708: PUSH
102709: LD_VAR 0 2
102713: ARRAY
102714: ST_TO_ADDR
// if not tmp then
102715: LD_VAR 0 6
102719: NOT
102720: IFFALSE 102724
// continue ;
102722: GO 102696
// idle_lab := 0 ;
102724: LD_ADDR_VAR 0 11
102728: PUSH
102729: LD_INT 0
102731: ST_TO_ADDR
// for j in tmp do
102732: LD_ADDR_VAR 0 3
102736: PUSH
102737: LD_VAR 0 6
102741: PUSH
102742: FOR_IN
102743: IFFALSE 103762
// begin researching := false ;
102745: LD_ADDR_VAR 0 10
102749: PUSH
102750: LD_INT 0
102752: ST_TO_ADDR
// side := GetSide ( j ) ;
102753: LD_ADDR_VAR 0 4
102757: PUSH
102758: LD_VAR 0 3
102762: PPUSH
102763: CALL_OW 255
102767: ST_TO_ADDR
// if not mc_tech [ side ] then
102768: LD_EXP 204
102772: PUSH
102773: LD_VAR 0 4
102777: ARRAY
102778: NOT
102779: IFFALSE 102783
// continue ;
102781: GO 102742
// if BuildingStatus ( j ) = bs_idle then
102783: LD_VAR 0 3
102787: PPUSH
102788: CALL_OW 461
102792: PUSH
102793: LD_INT 2
102795: EQUAL
102796: IFFALSE 102984
// begin if idle_lab and UnitsInside ( j ) < 6 then
102798: LD_VAR 0 11
102802: PUSH
102803: LD_VAR 0 3
102807: PPUSH
102808: CALL_OW 313
102812: PUSH
102813: LD_INT 6
102815: LESS
102816: AND
102817: IFFALSE 102888
// begin tmp2 := UnitsInside ( idle_lab ) ;
102819: LD_ADDR_VAR 0 9
102823: PUSH
102824: LD_VAR 0 11
102828: PPUSH
102829: CALL_OW 313
102833: ST_TO_ADDR
// if tmp2 then
102834: LD_VAR 0 9
102838: IFFALSE 102880
// for x in tmp2 do
102840: LD_ADDR_VAR 0 7
102844: PUSH
102845: LD_VAR 0 9
102849: PUSH
102850: FOR_IN
102851: IFFALSE 102878
// begin ComExitBuilding ( x ) ;
102853: LD_VAR 0 7
102857: PPUSH
102858: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
102862: LD_VAR 0 7
102866: PPUSH
102867: LD_VAR 0 3
102871: PPUSH
102872: CALL_OW 180
// end ;
102876: GO 102850
102878: POP
102879: POP
// idle_lab := 0 ;
102880: LD_ADDR_VAR 0 11
102884: PUSH
102885: LD_INT 0
102887: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
102888: LD_ADDR_VAR 0 5
102892: PUSH
102893: LD_EXP 204
102897: PUSH
102898: LD_VAR 0 4
102902: ARRAY
102903: PUSH
102904: FOR_IN
102905: IFFALSE 102965
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
102907: LD_VAR 0 3
102911: PPUSH
102912: LD_VAR 0 5
102916: PPUSH
102917: CALL_OW 430
102921: PUSH
102922: LD_VAR 0 4
102926: PPUSH
102927: LD_VAR 0 5
102931: PPUSH
102932: CALL 20080 0 2
102936: AND
102937: IFFALSE 102963
// begin researching := true ;
102939: LD_ADDR_VAR 0 10
102943: PUSH
102944: LD_INT 1
102946: ST_TO_ADDR
// ComResearch ( j , t ) ;
102947: LD_VAR 0 3
102951: PPUSH
102952: LD_VAR 0 5
102956: PPUSH
102957: CALL_OW 124
// break ;
102961: GO 102965
// end ;
102963: GO 102904
102965: POP
102966: POP
// if not researching then
102967: LD_VAR 0 10
102971: NOT
102972: IFFALSE 102984
// idle_lab := j ;
102974: LD_ADDR_VAR 0 11
102978: PUSH
102979: LD_VAR 0 3
102983: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
102984: LD_VAR 0 3
102988: PPUSH
102989: CALL_OW 461
102993: PUSH
102994: LD_INT 10
102996: EQUAL
102997: IFFALSE 103585
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
102999: LD_EXP 206
103003: PUSH
103004: LD_VAR 0 2
103008: ARRAY
103009: NOT
103010: PUSH
103011: LD_EXP 207
103015: PUSH
103016: LD_VAR 0 2
103020: ARRAY
103021: NOT
103022: AND
103023: PUSH
103024: LD_EXP 204
103028: PUSH
103029: LD_VAR 0 4
103033: ARRAY
103034: PUSH
103035: LD_INT 1
103037: GREATER
103038: AND
103039: IFFALSE 103170
// begin ComCancel ( j ) ;
103041: LD_VAR 0 3
103045: PPUSH
103046: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
103050: LD_ADDR_EXP 204
103054: PUSH
103055: LD_EXP 204
103059: PPUSH
103060: LD_VAR 0 4
103064: PPUSH
103065: LD_EXP 204
103069: PUSH
103070: LD_VAR 0 4
103074: ARRAY
103075: PPUSH
103076: LD_EXP 204
103080: PUSH
103081: LD_VAR 0 4
103085: ARRAY
103086: PUSH
103087: LD_INT 1
103089: MINUS
103090: PPUSH
103091: LD_EXP 204
103095: PUSH
103096: LD_VAR 0 4
103100: ARRAY
103101: PPUSH
103102: LD_INT 0
103104: PPUSH
103105: CALL 23628 0 4
103109: PPUSH
103110: CALL_OW 1
103114: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
103115: LD_ADDR_EXP 204
103119: PUSH
103120: LD_EXP 204
103124: PPUSH
103125: LD_VAR 0 4
103129: PPUSH
103130: LD_EXP 204
103134: PUSH
103135: LD_VAR 0 4
103139: ARRAY
103140: PPUSH
103141: LD_EXP 204
103145: PUSH
103146: LD_VAR 0 4
103150: ARRAY
103151: PPUSH
103152: LD_INT 1
103154: PPUSH
103155: LD_INT 0
103157: PPUSH
103158: CALL 23628 0 4
103162: PPUSH
103163: CALL_OW 1
103167: ST_TO_ADDR
// continue ;
103168: GO 102742
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
103170: LD_EXP 206
103174: PUSH
103175: LD_VAR 0 2
103179: ARRAY
103180: PUSH
103181: LD_EXP 207
103185: PUSH
103186: LD_VAR 0 2
103190: ARRAY
103191: NOT
103192: AND
103193: IFFALSE 103320
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
103195: LD_ADDR_EXP 207
103199: PUSH
103200: LD_EXP 207
103204: PPUSH
103205: LD_VAR 0 2
103209: PUSH
103210: LD_EXP 207
103214: PUSH
103215: LD_VAR 0 2
103219: ARRAY
103220: PUSH
103221: LD_INT 1
103223: PLUS
103224: PUSH
103225: EMPTY
103226: LIST
103227: LIST
103228: PPUSH
103229: LD_EXP 206
103233: PUSH
103234: LD_VAR 0 2
103238: ARRAY
103239: PUSH
103240: LD_INT 1
103242: ARRAY
103243: PPUSH
103244: CALL 24210 0 3
103248: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
103249: LD_EXP 206
103253: PUSH
103254: LD_VAR 0 2
103258: ARRAY
103259: PUSH
103260: LD_INT 1
103262: ARRAY
103263: PPUSH
103264: LD_INT 112
103266: PPUSH
103267: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
103271: LD_ADDR_VAR 0 9
103275: PUSH
103276: LD_EXP 206
103280: PUSH
103281: LD_VAR 0 2
103285: ARRAY
103286: PPUSH
103287: LD_INT 1
103289: PPUSH
103290: CALL_OW 3
103294: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
103295: LD_ADDR_EXP 206
103299: PUSH
103300: LD_EXP 206
103304: PPUSH
103305: LD_VAR 0 2
103309: PPUSH
103310: LD_VAR 0 9
103314: PPUSH
103315: CALL_OW 1
103319: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
103320: LD_EXP 206
103324: PUSH
103325: LD_VAR 0 2
103329: ARRAY
103330: PUSH
103331: LD_EXP 207
103335: PUSH
103336: LD_VAR 0 2
103340: ARRAY
103341: AND
103342: PUSH
103343: LD_EXP 207
103347: PUSH
103348: LD_VAR 0 2
103352: ARRAY
103353: PUSH
103354: LD_INT 1
103356: ARRAY
103357: PPUSH
103358: CALL_OW 310
103362: NOT
103363: AND
103364: PUSH
103365: LD_VAR 0 3
103369: PPUSH
103370: CALL_OW 313
103374: PUSH
103375: LD_INT 6
103377: EQUAL
103378: AND
103379: IFFALSE 103435
// begin tmp2 := UnitsInside ( j ) ;
103381: LD_ADDR_VAR 0 9
103385: PUSH
103386: LD_VAR 0 3
103390: PPUSH
103391: CALL_OW 313
103395: ST_TO_ADDR
// if tmp2 = 6 then
103396: LD_VAR 0 9
103400: PUSH
103401: LD_INT 6
103403: EQUAL
103404: IFFALSE 103435
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
103406: LD_VAR 0 9
103410: PUSH
103411: LD_INT 1
103413: ARRAY
103414: PPUSH
103415: LD_INT 112
103417: PPUSH
103418: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
103422: LD_VAR 0 9
103426: PUSH
103427: LD_INT 1
103429: ARRAY
103430: PPUSH
103431: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
103435: LD_EXP 207
103439: PUSH
103440: LD_VAR 0 2
103444: ARRAY
103445: PUSH
103446: LD_EXP 207
103450: PUSH
103451: LD_VAR 0 2
103455: ARRAY
103456: PUSH
103457: LD_INT 1
103459: ARRAY
103460: PPUSH
103461: CALL_OW 314
103465: NOT
103466: AND
103467: PUSH
103468: LD_EXP 207
103472: PUSH
103473: LD_VAR 0 2
103477: ARRAY
103478: PUSH
103479: LD_INT 1
103481: ARRAY
103482: PPUSH
103483: CALL_OW 310
103487: NOT
103488: AND
103489: IFFALSE 103515
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
103491: LD_EXP 207
103495: PUSH
103496: LD_VAR 0 2
103500: ARRAY
103501: PUSH
103502: LD_INT 1
103504: ARRAY
103505: PPUSH
103506: LD_VAR 0 3
103510: PPUSH
103511: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
103515: LD_EXP 207
103519: PUSH
103520: LD_VAR 0 2
103524: ARRAY
103525: PUSH
103526: LD_INT 1
103528: ARRAY
103529: PPUSH
103530: CALL_OW 310
103534: PUSH
103535: LD_EXP 207
103539: PUSH
103540: LD_VAR 0 2
103544: ARRAY
103545: PUSH
103546: LD_INT 1
103548: ARRAY
103549: PPUSH
103550: CALL_OW 310
103554: PPUSH
103555: CALL_OW 461
103559: PUSH
103560: LD_INT 3
103562: NONEQUAL
103563: AND
103564: IFFALSE 103585
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
103566: LD_EXP 207
103570: PUSH
103571: LD_VAR 0 2
103575: ARRAY
103576: PUSH
103577: LD_INT 1
103579: ARRAY
103580: PPUSH
103581: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
103585: LD_VAR 0 3
103589: PPUSH
103590: CALL_OW 461
103594: PUSH
103595: LD_INT 6
103597: EQUAL
103598: PUSH
103599: LD_VAR 0 6
103603: PUSH
103604: LD_INT 1
103606: GREATER
103607: AND
103608: IFFALSE 103760
// begin sci := [ ] ;
103610: LD_ADDR_VAR 0 8
103614: PUSH
103615: EMPTY
103616: ST_TO_ADDR
// for x in ( tmp diff j ) do
103617: LD_ADDR_VAR 0 7
103621: PUSH
103622: LD_VAR 0 6
103626: PUSH
103627: LD_VAR 0 3
103631: DIFF
103632: PUSH
103633: FOR_IN
103634: IFFALSE 103686
// begin if sci = 6 then
103636: LD_VAR 0 8
103640: PUSH
103641: LD_INT 6
103643: EQUAL
103644: IFFALSE 103648
// break ;
103646: GO 103686
// if BuildingStatus ( x ) = bs_idle then
103648: LD_VAR 0 7
103652: PPUSH
103653: CALL_OW 461
103657: PUSH
103658: LD_INT 2
103660: EQUAL
103661: IFFALSE 103684
// sci := sci ^ UnitsInside ( x ) ;
103663: LD_ADDR_VAR 0 8
103667: PUSH
103668: LD_VAR 0 8
103672: PUSH
103673: LD_VAR 0 7
103677: PPUSH
103678: CALL_OW 313
103682: ADD
103683: ST_TO_ADDR
// end ;
103684: GO 103633
103686: POP
103687: POP
// if not sci then
103688: LD_VAR 0 8
103692: NOT
103693: IFFALSE 103697
// continue ;
103695: GO 102742
// for x in sci do
103697: LD_ADDR_VAR 0 7
103701: PUSH
103702: LD_VAR 0 8
103706: PUSH
103707: FOR_IN
103708: IFFALSE 103758
// if IsInUnit ( x ) and not HasTask ( x ) then
103710: LD_VAR 0 7
103714: PPUSH
103715: CALL_OW 310
103719: PUSH
103720: LD_VAR 0 7
103724: PPUSH
103725: CALL_OW 314
103729: NOT
103730: AND
103731: IFFALSE 103756
// begin ComExitBuilding ( x ) ;
103733: LD_VAR 0 7
103737: PPUSH
103738: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
103742: LD_VAR 0 7
103746: PPUSH
103747: LD_VAR 0 3
103751: PPUSH
103752: CALL_OW 180
// end ;
103756: GO 103707
103758: POP
103759: POP
// end ; end ;
103760: GO 102742
103762: POP
103763: POP
// end ;
103764: GO 102696
103766: POP
103767: POP
// end ;
103768: LD_VAR 0 1
103772: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
103773: LD_INT 0
103775: PPUSH
103776: PPUSH
// if not mc_bases then
103777: LD_EXP 177
103781: NOT
103782: IFFALSE 103786
// exit ;
103784: GO 103867
// for i = 1 to mc_bases do
103786: LD_ADDR_VAR 0 2
103790: PUSH
103791: DOUBLE
103792: LD_INT 1
103794: DEC
103795: ST_TO_ADDR
103796: LD_EXP 177
103800: PUSH
103801: FOR_TO
103802: IFFALSE 103865
// if mc_mines [ i ] and mc_miners [ i ] then
103804: LD_EXP 190
103808: PUSH
103809: LD_VAR 0 2
103813: ARRAY
103814: PUSH
103815: LD_EXP 191
103819: PUSH
103820: LD_VAR 0 2
103824: ARRAY
103825: AND
103826: IFFALSE 103863
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
103828: LD_EXP 191
103832: PUSH
103833: LD_VAR 0 2
103837: ARRAY
103838: PUSH
103839: LD_INT 1
103841: ARRAY
103842: PPUSH
103843: CALL_OW 255
103847: PPUSH
103848: LD_EXP 190
103852: PUSH
103853: LD_VAR 0 2
103857: ARRAY
103858: PPUSH
103859: CALL 21163 0 2
103863: GO 103801
103865: POP
103866: POP
// end ;
103867: LD_VAR 0 1
103871: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
103872: LD_INT 0
103874: PPUSH
103875: PPUSH
103876: PPUSH
103877: PPUSH
103878: PPUSH
103879: PPUSH
103880: PPUSH
103881: PPUSH
// if not mc_bases or not mc_parking then
103882: LD_EXP 177
103886: NOT
103887: PUSH
103888: LD_EXP 201
103892: NOT
103893: OR
103894: IFFALSE 103898
// exit ;
103896: GO 104608
// for i = 1 to mc_bases do
103898: LD_ADDR_VAR 0 2
103902: PUSH
103903: DOUBLE
103904: LD_INT 1
103906: DEC
103907: ST_TO_ADDR
103908: LD_EXP 177
103912: PUSH
103913: FOR_TO
103914: IFFALSE 104606
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
103916: LD_EXP 177
103920: PUSH
103921: LD_VAR 0 2
103925: ARRAY
103926: NOT
103927: PUSH
103928: LD_EXP 201
103932: PUSH
103933: LD_VAR 0 2
103937: ARRAY
103938: NOT
103939: OR
103940: IFFALSE 103944
// continue ;
103942: GO 103913
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
103944: LD_ADDR_VAR 0 5
103948: PUSH
103949: LD_EXP 177
103953: PUSH
103954: LD_VAR 0 2
103958: ARRAY
103959: PUSH
103960: LD_INT 1
103962: ARRAY
103963: PPUSH
103964: CALL_OW 255
103968: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
103969: LD_ADDR_VAR 0 6
103973: PUSH
103974: LD_EXP 177
103978: PUSH
103979: LD_VAR 0 2
103983: ARRAY
103984: PPUSH
103985: LD_INT 30
103987: PUSH
103988: LD_INT 3
103990: PUSH
103991: EMPTY
103992: LIST
103993: LIST
103994: PPUSH
103995: CALL_OW 72
103999: ST_TO_ADDR
// if not fac then
104000: LD_VAR 0 6
104004: NOT
104005: IFFALSE 104056
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
104007: LD_ADDR_VAR 0 6
104011: PUSH
104012: LD_EXP 177
104016: PUSH
104017: LD_VAR 0 2
104021: ARRAY
104022: PPUSH
104023: LD_INT 2
104025: PUSH
104026: LD_INT 30
104028: PUSH
104029: LD_INT 0
104031: PUSH
104032: EMPTY
104033: LIST
104034: LIST
104035: PUSH
104036: LD_INT 30
104038: PUSH
104039: LD_INT 1
104041: PUSH
104042: EMPTY
104043: LIST
104044: LIST
104045: PUSH
104046: EMPTY
104047: LIST
104048: LIST
104049: LIST
104050: PPUSH
104051: CALL_OW 72
104055: ST_TO_ADDR
// if not fac then
104056: LD_VAR 0 6
104060: NOT
104061: IFFALSE 104065
// continue ;
104063: GO 103913
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
104065: LD_ADDR_VAR 0 7
104069: PUSH
104070: LD_EXP 201
104074: PUSH
104075: LD_VAR 0 2
104079: ARRAY
104080: PPUSH
104081: LD_INT 22
104083: PUSH
104084: LD_VAR 0 5
104088: PUSH
104089: EMPTY
104090: LIST
104091: LIST
104092: PUSH
104093: LD_INT 21
104095: PUSH
104096: LD_INT 2
104098: PUSH
104099: EMPTY
104100: LIST
104101: LIST
104102: PUSH
104103: LD_INT 3
104105: PUSH
104106: LD_INT 24
104108: PUSH
104109: LD_INT 1000
104111: PUSH
104112: EMPTY
104113: LIST
104114: LIST
104115: PUSH
104116: EMPTY
104117: LIST
104118: LIST
104119: PUSH
104120: EMPTY
104121: LIST
104122: LIST
104123: LIST
104124: PPUSH
104125: CALL_OW 70
104129: ST_TO_ADDR
// for j in fac do
104130: LD_ADDR_VAR 0 3
104134: PUSH
104135: LD_VAR 0 6
104139: PUSH
104140: FOR_IN
104141: IFFALSE 104222
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
104143: LD_ADDR_VAR 0 7
104147: PUSH
104148: LD_VAR 0 7
104152: PUSH
104153: LD_INT 22
104155: PUSH
104156: LD_VAR 0 5
104160: PUSH
104161: EMPTY
104162: LIST
104163: LIST
104164: PUSH
104165: LD_INT 91
104167: PUSH
104168: LD_VAR 0 3
104172: PUSH
104173: LD_INT 15
104175: PUSH
104176: EMPTY
104177: LIST
104178: LIST
104179: LIST
104180: PUSH
104181: LD_INT 21
104183: PUSH
104184: LD_INT 2
104186: PUSH
104187: EMPTY
104188: LIST
104189: LIST
104190: PUSH
104191: LD_INT 3
104193: PUSH
104194: LD_INT 24
104196: PUSH
104197: LD_INT 1000
104199: PUSH
104200: EMPTY
104201: LIST
104202: LIST
104203: PUSH
104204: EMPTY
104205: LIST
104206: LIST
104207: PUSH
104208: EMPTY
104209: LIST
104210: LIST
104211: LIST
104212: LIST
104213: PPUSH
104214: CALL_OW 69
104218: UNION
104219: ST_TO_ADDR
104220: GO 104140
104222: POP
104223: POP
// if not vehs then
104224: LD_VAR 0 7
104228: NOT
104229: IFFALSE 104255
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
104231: LD_ADDR_EXP 189
104235: PUSH
104236: LD_EXP 189
104240: PPUSH
104241: LD_VAR 0 2
104245: PPUSH
104246: EMPTY
104247: PPUSH
104248: CALL_OW 1
104252: ST_TO_ADDR
// continue ;
104253: GO 103913
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
104255: LD_ADDR_VAR 0 8
104259: PUSH
104260: LD_EXP 177
104264: PUSH
104265: LD_VAR 0 2
104269: ARRAY
104270: PPUSH
104271: LD_INT 30
104273: PUSH
104274: LD_INT 3
104276: PUSH
104277: EMPTY
104278: LIST
104279: LIST
104280: PPUSH
104281: CALL_OW 72
104285: ST_TO_ADDR
// if tmp then
104286: LD_VAR 0 8
104290: IFFALSE 104393
// begin for j in tmp do
104292: LD_ADDR_VAR 0 3
104296: PUSH
104297: LD_VAR 0 8
104301: PUSH
104302: FOR_IN
104303: IFFALSE 104391
// for k in UnitsInside ( j ) do
104305: LD_ADDR_VAR 0 4
104309: PUSH
104310: LD_VAR 0 3
104314: PPUSH
104315: CALL_OW 313
104319: PUSH
104320: FOR_IN
104321: IFFALSE 104387
// if k then
104323: LD_VAR 0 4
104327: IFFALSE 104385
// if not k in mc_repair_vehicle [ i ] then
104329: LD_VAR 0 4
104333: PUSH
104334: LD_EXP 189
104338: PUSH
104339: LD_VAR 0 2
104343: ARRAY
104344: IN
104345: NOT
104346: IFFALSE 104385
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
104348: LD_ADDR_EXP 189
104352: PUSH
104353: LD_EXP 189
104357: PPUSH
104358: LD_VAR 0 2
104362: PPUSH
104363: LD_EXP 189
104367: PUSH
104368: LD_VAR 0 2
104372: ARRAY
104373: PUSH
104374: LD_VAR 0 4
104378: UNION
104379: PPUSH
104380: CALL_OW 1
104384: ST_TO_ADDR
104385: GO 104320
104387: POP
104388: POP
104389: GO 104302
104391: POP
104392: POP
// end ; if not mc_repair_vehicle [ i ] then
104393: LD_EXP 189
104397: PUSH
104398: LD_VAR 0 2
104402: ARRAY
104403: NOT
104404: IFFALSE 104408
// continue ;
104406: GO 103913
// for j in mc_repair_vehicle [ i ] do
104408: LD_ADDR_VAR 0 3
104412: PUSH
104413: LD_EXP 189
104417: PUSH
104418: LD_VAR 0 2
104422: ARRAY
104423: PUSH
104424: FOR_IN
104425: IFFALSE 104602
// begin if GetClass ( j ) <> 3 then
104427: LD_VAR 0 3
104431: PPUSH
104432: CALL_OW 257
104436: PUSH
104437: LD_INT 3
104439: NONEQUAL
104440: IFFALSE 104481
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
104442: LD_ADDR_EXP 189
104446: PUSH
104447: LD_EXP 189
104451: PPUSH
104452: LD_VAR 0 2
104456: PPUSH
104457: LD_EXP 189
104461: PUSH
104462: LD_VAR 0 2
104466: ARRAY
104467: PUSH
104468: LD_VAR 0 3
104472: DIFF
104473: PPUSH
104474: CALL_OW 1
104478: ST_TO_ADDR
// continue ;
104479: GO 104424
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
104481: LD_VAR 0 3
104485: PPUSH
104486: CALL_OW 311
104490: NOT
104491: PUSH
104492: LD_VAR 0 3
104496: PUSH
104497: LD_EXP 180
104501: PUSH
104502: LD_VAR 0 2
104506: ARRAY
104507: PUSH
104508: LD_INT 1
104510: ARRAY
104511: IN
104512: NOT
104513: AND
104514: PUSH
104515: LD_VAR 0 3
104519: PUSH
104520: LD_EXP 180
104524: PUSH
104525: LD_VAR 0 2
104529: ARRAY
104530: PUSH
104531: LD_INT 2
104533: ARRAY
104534: IN
104535: NOT
104536: AND
104537: IFFALSE 104600
// begin if IsInUnit ( j ) then
104539: LD_VAR 0 3
104543: PPUSH
104544: CALL_OW 310
104548: IFFALSE 104561
// ComExitBuilding ( j ) else
104550: LD_VAR 0 3
104554: PPUSH
104555: CALL_OW 122
104559: GO 104600
// if not WantToRepairVehicle ( j , vehs [ 1 ] ) then
104561: LD_VAR 0 3
104565: PPUSH
104566: LD_VAR 0 7
104570: PUSH
104571: LD_INT 1
104573: ARRAY
104574: PPUSH
104575: CALL 58018 0 2
104579: NOT
104580: IFFALSE 104600
// ComRepairVehicle ( j , vehs [ 1 ] ) ;
104582: LD_VAR 0 3
104586: PPUSH
104587: LD_VAR 0 7
104591: PUSH
104592: LD_INT 1
104594: ARRAY
104595: PPUSH
104596: CALL_OW 129
// end ; end ;
104600: GO 104424
104602: POP
104603: POP
// end ;
104604: GO 103913
104606: POP
104607: POP
// end ;
104608: LD_VAR 0 1
104612: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
104613: LD_INT 0
104615: PPUSH
104616: PPUSH
104617: PPUSH
104618: PPUSH
104619: PPUSH
104620: PPUSH
104621: PPUSH
104622: PPUSH
104623: PPUSH
104624: PPUSH
104625: PPUSH
// if not mc_bases then
104626: LD_EXP 177
104630: NOT
104631: IFFALSE 104635
// exit ;
104633: GO 105437
// for i = 1 to mc_bases do
104635: LD_ADDR_VAR 0 2
104639: PUSH
104640: DOUBLE
104641: LD_INT 1
104643: DEC
104644: ST_TO_ADDR
104645: LD_EXP 177
104649: PUSH
104650: FOR_TO
104651: IFFALSE 105435
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
104653: LD_EXP 205
104657: PUSH
104658: LD_VAR 0 2
104662: ARRAY
104663: NOT
104664: PUSH
104665: LD_EXP 180
104669: PUSH
104670: LD_VAR 0 2
104674: ARRAY
104675: PUSH
104676: LD_INT 1
104678: ARRAY
104679: OR
104680: PUSH
104681: LD_EXP 180
104685: PUSH
104686: LD_VAR 0 2
104690: ARRAY
104691: PUSH
104692: LD_INT 2
104694: ARRAY
104695: OR
104696: PUSH
104697: LD_EXP 203
104701: PUSH
104702: LD_VAR 0 2
104706: ARRAY
104707: PPUSH
104708: LD_INT 1
104710: PPUSH
104711: CALL_OW 325
104715: NOT
104716: OR
104717: PUSH
104718: LD_EXP 200
104722: PUSH
104723: LD_VAR 0 2
104727: ARRAY
104728: OR
104729: IFFALSE 104733
// continue ;
104731: GO 104650
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
104733: LD_ADDR_VAR 0 8
104737: PUSH
104738: LD_EXP 177
104742: PUSH
104743: LD_VAR 0 2
104747: ARRAY
104748: PPUSH
104749: LD_INT 25
104751: PUSH
104752: LD_INT 4
104754: PUSH
104755: EMPTY
104756: LIST
104757: LIST
104758: PUSH
104759: LD_INT 50
104761: PUSH
104762: EMPTY
104763: LIST
104764: PUSH
104765: LD_INT 3
104767: PUSH
104768: LD_INT 60
104770: PUSH
104771: EMPTY
104772: LIST
104773: PUSH
104774: EMPTY
104775: LIST
104776: LIST
104777: PUSH
104778: EMPTY
104779: LIST
104780: LIST
104781: LIST
104782: PPUSH
104783: CALL_OW 72
104787: PUSH
104788: LD_EXP 181
104792: PUSH
104793: LD_VAR 0 2
104797: ARRAY
104798: DIFF
104799: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
104800: LD_ADDR_VAR 0 9
104804: PUSH
104805: LD_EXP 177
104809: PUSH
104810: LD_VAR 0 2
104814: ARRAY
104815: PPUSH
104816: LD_INT 2
104818: PUSH
104819: LD_INT 30
104821: PUSH
104822: LD_INT 0
104824: PUSH
104825: EMPTY
104826: LIST
104827: LIST
104828: PUSH
104829: LD_INT 30
104831: PUSH
104832: LD_INT 1
104834: PUSH
104835: EMPTY
104836: LIST
104837: LIST
104838: PUSH
104839: EMPTY
104840: LIST
104841: LIST
104842: LIST
104843: PPUSH
104844: CALL_OW 72
104848: ST_TO_ADDR
// if not tmp or not dep then
104849: LD_VAR 0 8
104853: NOT
104854: PUSH
104855: LD_VAR 0 9
104859: NOT
104860: OR
104861: IFFALSE 104865
// continue ;
104863: GO 104650
// side := GetSide ( tmp [ 1 ] ) ;
104865: LD_ADDR_VAR 0 11
104869: PUSH
104870: LD_VAR 0 8
104874: PUSH
104875: LD_INT 1
104877: ARRAY
104878: PPUSH
104879: CALL_OW 255
104883: ST_TO_ADDR
// dep := dep [ 1 ] ;
104884: LD_ADDR_VAR 0 9
104888: PUSH
104889: LD_VAR 0 9
104893: PUSH
104894: LD_INT 1
104896: ARRAY
104897: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
104898: LD_ADDR_VAR 0 7
104902: PUSH
104903: LD_EXP 205
104907: PUSH
104908: LD_VAR 0 2
104912: ARRAY
104913: PPUSH
104914: LD_INT 22
104916: PUSH
104917: LD_INT 0
104919: PUSH
104920: EMPTY
104921: LIST
104922: LIST
104923: PUSH
104924: LD_INT 25
104926: PUSH
104927: LD_INT 12
104929: PUSH
104930: EMPTY
104931: LIST
104932: LIST
104933: PUSH
104934: EMPTY
104935: LIST
104936: LIST
104937: PPUSH
104938: CALL_OW 70
104942: PUSH
104943: LD_INT 22
104945: PUSH
104946: LD_INT 0
104948: PUSH
104949: EMPTY
104950: LIST
104951: LIST
104952: PUSH
104953: LD_INT 25
104955: PUSH
104956: LD_INT 12
104958: PUSH
104959: EMPTY
104960: LIST
104961: LIST
104962: PUSH
104963: LD_INT 91
104965: PUSH
104966: LD_VAR 0 9
104970: PUSH
104971: LD_INT 20
104973: PUSH
104974: EMPTY
104975: LIST
104976: LIST
104977: LIST
104978: PUSH
104979: EMPTY
104980: LIST
104981: LIST
104982: LIST
104983: PPUSH
104984: CALL_OW 69
104988: UNION
104989: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
104990: LD_ADDR_VAR 0 10
104994: PUSH
104995: LD_EXP 205
104999: PUSH
105000: LD_VAR 0 2
105004: ARRAY
105005: PPUSH
105006: LD_INT 81
105008: PUSH
105009: LD_VAR 0 11
105013: PUSH
105014: EMPTY
105015: LIST
105016: LIST
105017: PPUSH
105018: CALL_OW 70
105022: ST_TO_ADDR
// if not apes or danger_at_area then
105023: LD_VAR 0 7
105027: NOT
105028: PUSH
105029: LD_VAR 0 10
105033: OR
105034: IFFALSE 105084
// begin if mc_taming [ i ] then
105036: LD_EXP 208
105040: PUSH
105041: LD_VAR 0 2
105045: ARRAY
105046: IFFALSE 105082
// begin MC_Reset ( i , 121 ) ;
105048: LD_VAR 0 2
105052: PPUSH
105053: LD_INT 121
105055: PPUSH
105056: CALL 90070 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
105060: LD_ADDR_EXP 208
105064: PUSH
105065: LD_EXP 208
105069: PPUSH
105070: LD_VAR 0 2
105074: PPUSH
105075: EMPTY
105076: PPUSH
105077: CALL_OW 1
105081: ST_TO_ADDR
// end ; continue ;
105082: GO 104650
// end ; for j in tmp do
105084: LD_ADDR_VAR 0 3
105088: PUSH
105089: LD_VAR 0 8
105093: PUSH
105094: FOR_IN
105095: IFFALSE 105431
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
105097: LD_VAR 0 3
105101: PUSH
105102: LD_EXP 208
105106: PUSH
105107: LD_VAR 0 2
105111: ARRAY
105112: IN
105113: NOT
105114: PUSH
105115: LD_EXP 208
105119: PUSH
105120: LD_VAR 0 2
105124: ARRAY
105125: PUSH
105126: LD_INT 3
105128: LESS
105129: AND
105130: IFFALSE 105188
// begin SetTag ( j , 121 ) ;
105132: LD_VAR 0 3
105136: PPUSH
105137: LD_INT 121
105139: PPUSH
105140: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
105144: LD_ADDR_EXP 208
105148: PUSH
105149: LD_EXP 208
105153: PPUSH
105154: LD_VAR 0 2
105158: PUSH
105159: LD_EXP 208
105163: PUSH
105164: LD_VAR 0 2
105168: ARRAY
105169: PUSH
105170: LD_INT 1
105172: PLUS
105173: PUSH
105174: EMPTY
105175: LIST
105176: LIST
105177: PPUSH
105178: LD_VAR 0 3
105182: PPUSH
105183: CALL 24210 0 3
105187: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
105188: LD_VAR 0 3
105192: PUSH
105193: LD_EXP 208
105197: PUSH
105198: LD_VAR 0 2
105202: ARRAY
105203: IN
105204: IFFALSE 105429
// begin if GetClass ( j ) <> 4 then
105206: LD_VAR 0 3
105210: PPUSH
105211: CALL_OW 257
105215: PUSH
105216: LD_INT 4
105218: NONEQUAL
105219: IFFALSE 105272
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
105221: LD_ADDR_EXP 208
105225: PUSH
105226: LD_EXP 208
105230: PPUSH
105231: LD_VAR 0 2
105235: PPUSH
105236: LD_EXP 208
105240: PUSH
105241: LD_VAR 0 2
105245: ARRAY
105246: PUSH
105247: LD_VAR 0 3
105251: DIFF
105252: PPUSH
105253: CALL_OW 1
105257: ST_TO_ADDR
// SetTag ( j , 0 ) ;
105258: LD_VAR 0 3
105262: PPUSH
105263: LD_INT 0
105265: PPUSH
105266: CALL_OW 109
// continue ;
105270: GO 105094
// end ; if IsInUnit ( j ) then
105272: LD_VAR 0 3
105276: PPUSH
105277: CALL_OW 310
105281: IFFALSE 105292
// ComExitBuilding ( j ) ;
105283: LD_VAR 0 3
105287: PPUSH
105288: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
105292: LD_ADDR_VAR 0 6
105296: PUSH
105297: LD_VAR 0 7
105301: PPUSH
105302: LD_VAR 0 3
105306: PPUSH
105307: CALL_OW 74
105311: ST_TO_ADDR
// if not ape then
105312: LD_VAR 0 6
105316: NOT
105317: IFFALSE 105321
// break ;
105319: GO 105431
// x := GetX ( ape ) ;
105321: LD_ADDR_VAR 0 4
105325: PUSH
105326: LD_VAR 0 6
105330: PPUSH
105331: CALL_OW 250
105335: ST_TO_ADDR
// y := GetY ( ape ) ;
105336: LD_ADDR_VAR 0 5
105340: PUSH
105341: LD_VAR 0 6
105345: PPUSH
105346: CALL_OW 251
105350: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
105351: LD_VAR 0 4
105355: PPUSH
105356: LD_VAR 0 5
105360: PPUSH
105361: CALL_OW 488
105365: NOT
105366: PUSH
105367: LD_VAR 0 11
105371: PPUSH
105372: LD_VAR 0 4
105376: PPUSH
105377: LD_VAR 0 5
105381: PPUSH
105382: LD_INT 20
105384: PPUSH
105385: CALL 25106 0 4
105389: PUSH
105390: LD_INT 4
105392: ARRAY
105393: OR
105394: IFFALSE 105398
// break ;
105396: GO 105431
// if not HasTask ( j ) then
105398: LD_VAR 0 3
105402: PPUSH
105403: CALL_OW 314
105407: NOT
105408: IFFALSE 105429
// ComTameXY ( j , x , y ) ;
105410: LD_VAR 0 3
105414: PPUSH
105415: LD_VAR 0 4
105419: PPUSH
105420: LD_VAR 0 5
105424: PPUSH
105425: CALL_OW 131
// end ; end ;
105429: GO 105094
105431: POP
105432: POP
// end ;
105433: GO 104650
105435: POP
105436: POP
// end ;
105437: LD_VAR 0 1
105441: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
105442: LD_INT 0
105444: PPUSH
105445: PPUSH
105446: PPUSH
105447: PPUSH
105448: PPUSH
105449: PPUSH
105450: PPUSH
105451: PPUSH
// if not mc_bases then
105452: LD_EXP 177
105456: NOT
105457: IFFALSE 105461
// exit ;
105459: GO 106087
// for i = 1 to mc_bases do
105461: LD_ADDR_VAR 0 2
105465: PUSH
105466: DOUBLE
105467: LD_INT 1
105469: DEC
105470: ST_TO_ADDR
105471: LD_EXP 177
105475: PUSH
105476: FOR_TO
105477: IFFALSE 106085
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
105479: LD_EXP 206
105483: PUSH
105484: LD_VAR 0 2
105488: ARRAY
105489: NOT
105490: PUSH
105491: LD_EXP 206
105495: PUSH
105496: LD_VAR 0 2
105500: ARRAY
105501: PPUSH
105502: LD_INT 25
105504: PUSH
105505: LD_INT 12
105507: PUSH
105508: EMPTY
105509: LIST
105510: LIST
105511: PPUSH
105512: CALL_OW 72
105516: NOT
105517: OR
105518: IFFALSE 105522
// continue ;
105520: GO 105476
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
105522: LD_ADDR_VAR 0 5
105526: PUSH
105527: LD_EXP 206
105531: PUSH
105532: LD_VAR 0 2
105536: ARRAY
105537: PUSH
105538: LD_INT 1
105540: ARRAY
105541: PPUSH
105542: CALL_OW 255
105546: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
105547: LD_VAR 0 5
105551: PPUSH
105552: LD_INT 2
105554: PPUSH
105555: CALL_OW 325
105559: IFFALSE 105812
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
105561: LD_ADDR_VAR 0 4
105565: PUSH
105566: LD_EXP 206
105570: PUSH
105571: LD_VAR 0 2
105575: ARRAY
105576: PPUSH
105577: LD_INT 25
105579: PUSH
105580: LD_INT 16
105582: PUSH
105583: EMPTY
105584: LIST
105585: LIST
105586: PPUSH
105587: CALL_OW 72
105591: ST_TO_ADDR
// if tmp < 6 then
105592: LD_VAR 0 4
105596: PUSH
105597: LD_INT 6
105599: LESS
105600: IFFALSE 105812
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
105602: LD_ADDR_VAR 0 6
105606: PUSH
105607: LD_EXP 177
105611: PUSH
105612: LD_VAR 0 2
105616: ARRAY
105617: PPUSH
105618: LD_INT 2
105620: PUSH
105621: LD_INT 30
105623: PUSH
105624: LD_INT 0
105626: PUSH
105627: EMPTY
105628: LIST
105629: LIST
105630: PUSH
105631: LD_INT 30
105633: PUSH
105634: LD_INT 1
105636: PUSH
105637: EMPTY
105638: LIST
105639: LIST
105640: PUSH
105641: EMPTY
105642: LIST
105643: LIST
105644: LIST
105645: PPUSH
105646: CALL_OW 72
105650: ST_TO_ADDR
// if depot then
105651: LD_VAR 0 6
105655: IFFALSE 105812
// begin selected := 0 ;
105657: LD_ADDR_VAR 0 7
105661: PUSH
105662: LD_INT 0
105664: ST_TO_ADDR
// for j in depot do
105665: LD_ADDR_VAR 0 3
105669: PUSH
105670: LD_VAR 0 6
105674: PUSH
105675: FOR_IN
105676: IFFALSE 105707
// begin if UnitsInside ( j ) < 6 then
105678: LD_VAR 0 3
105682: PPUSH
105683: CALL_OW 313
105687: PUSH
105688: LD_INT 6
105690: LESS
105691: IFFALSE 105705
// begin selected := j ;
105693: LD_ADDR_VAR 0 7
105697: PUSH
105698: LD_VAR 0 3
105702: ST_TO_ADDR
// break ;
105703: GO 105707
// end ; end ;
105705: GO 105675
105707: POP
105708: POP
// if selected then
105709: LD_VAR 0 7
105713: IFFALSE 105812
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
105715: LD_ADDR_VAR 0 3
105719: PUSH
105720: LD_EXP 206
105724: PUSH
105725: LD_VAR 0 2
105729: ARRAY
105730: PPUSH
105731: LD_INT 25
105733: PUSH
105734: LD_INT 12
105736: PUSH
105737: EMPTY
105738: LIST
105739: LIST
105740: PPUSH
105741: CALL_OW 72
105745: PUSH
105746: FOR_IN
105747: IFFALSE 105810
// if not HasTask ( j ) then
105749: LD_VAR 0 3
105753: PPUSH
105754: CALL_OW 314
105758: NOT
105759: IFFALSE 105808
// begin if not IsInUnit ( j ) then
105761: LD_VAR 0 3
105765: PPUSH
105766: CALL_OW 310
105770: NOT
105771: IFFALSE 105787
// ComEnterUnit ( j , selected ) ;
105773: LD_VAR 0 3
105777: PPUSH
105778: LD_VAR 0 7
105782: PPUSH
105783: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
105787: LD_VAR 0 3
105791: PPUSH
105792: LD_INT 16
105794: PPUSH
105795: CALL_OW 183
// AddComExitBuilding ( j ) ;
105799: LD_VAR 0 3
105803: PPUSH
105804: CALL_OW 182
// end ;
105808: GO 105746
105810: POP
105811: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
105812: LD_VAR 0 5
105816: PPUSH
105817: LD_INT 11
105819: PPUSH
105820: CALL_OW 325
105824: IFFALSE 106083
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
105826: LD_ADDR_VAR 0 4
105830: PUSH
105831: LD_EXP 206
105835: PUSH
105836: LD_VAR 0 2
105840: ARRAY
105841: PPUSH
105842: LD_INT 25
105844: PUSH
105845: LD_INT 16
105847: PUSH
105848: EMPTY
105849: LIST
105850: LIST
105851: PPUSH
105852: CALL_OW 72
105856: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
105857: LD_VAR 0 4
105861: PUSH
105862: LD_INT 6
105864: GREATEREQUAL
105865: PUSH
105866: LD_VAR 0 5
105870: PPUSH
105871: LD_INT 2
105873: PPUSH
105874: CALL_OW 325
105878: NOT
105879: OR
105880: IFFALSE 106083
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
105882: LD_ADDR_VAR 0 8
105886: PUSH
105887: LD_EXP 177
105891: PUSH
105892: LD_VAR 0 2
105896: ARRAY
105897: PPUSH
105898: LD_INT 2
105900: PUSH
105901: LD_INT 30
105903: PUSH
105904: LD_INT 4
105906: PUSH
105907: EMPTY
105908: LIST
105909: LIST
105910: PUSH
105911: LD_INT 30
105913: PUSH
105914: LD_INT 5
105916: PUSH
105917: EMPTY
105918: LIST
105919: LIST
105920: PUSH
105921: EMPTY
105922: LIST
105923: LIST
105924: LIST
105925: PPUSH
105926: CALL_OW 72
105930: ST_TO_ADDR
// if barracks then
105931: LD_VAR 0 8
105935: IFFALSE 106083
// begin selected := 0 ;
105937: LD_ADDR_VAR 0 7
105941: PUSH
105942: LD_INT 0
105944: ST_TO_ADDR
// for j in barracks do
105945: LD_ADDR_VAR 0 3
105949: PUSH
105950: LD_VAR 0 8
105954: PUSH
105955: FOR_IN
105956: IFFALSE 105987
// begin if UnitsInside ( j ) < 6 then
105958: LD_VAR 0 3
105962: PPUSH
105963: CALL_OW 313
105967: PUSH
105968: LD_INT 6
105970: LESS
105971: IFFALSE 105985
// begin selected := j ;
105973: LD_ADDR_VAR 0 7
105977: PUSH
105978: LD_VAR 0 3
105982: ST_TO_ADDR
// break ;
105983: GO 105987
// end ; end ;
105985: GO 105955
105987: POP
105988: POP
// if selected then
105989: LD_VAR 0 7
105993: IFFALSE 106083
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
105995: LD_ADDR_VAR 0 3
105999: PUSH
106000: LD_EXP 206
106004: PUSH
106005: LD_VAR 0 2
106009: ARRAY
106010: PPUSH
106011: LD_INT 25
106013: PUSH
106014: LD_INT 12
106016: PUSH
106017: EMPTY
106018: LIST
106019: LIST
106020: PPUSH
106021: CALL_OW 72
106025: PUSH
106026: FOR_IN
106027: IFFALSE 106081
// if not IsInUnit ( j ) and not HasTask ( j ) then
106029: LD_VAR 0 3
106033: PPUSH
106034: CALL_OW 310
106038: NOT
106039: PUSH
106040: LD_VAR 0 3
106044: PPUSH
106045: CALL_OW 314
106049: NOT
106050: AND
106051: IFFALSE 106079
// begin ComEnterUnit ( j , selected ) ;
106053: LD_VAR 0 3
106057: PPUSH
106058: LD_VAR 0 7
106062: PPUSH
106063: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
106067: LD_VAR 0 3
106071: PPUSH
106072: LD_INT 15
106074: PPUSH
106075: CALL_OW 183
// end ;
106079: GO 106026
106081: POP
106082: POP
// end ; end ; end ; end ; end ;
106083: GO 105476
106085: POP
106086: POP
// end ;
106087: LD_VAR 0 1
106091: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
106092: LD_INT 0
106094: PPUSH
106095: PPUSH
106096: PPUSH
106097: PPUSH
// if not mc_bases then
106098: LD_EXP 177
106102: NOT
106103: IFFALSE 106107
// exit ;
106105: GO 106285
// for i = 1 to mc_bases do
106107: LD_ADDR_VAR 0 2
106111: PUSH
106112: DOUBLE
106113: LD_INT 1
106115: DEC
106116: ST_TO_ADDR
106117: LD_EXP 177
106121: PUSH
106122: FOR_TO
106123: IFFALSE 106283
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
106125: LD_ADDR_VAR 0 4
106129: PUSH
106130: LD_EXP 177
106134: PUSH
106135: LD_VAR 0 2
106139: ARRAY
106140: PPUSH
106141: LD_INT 25
106143: PUSH
106144: LD_INT 9
106146: PUSH
106147: EMPTY
106148: LIST
106149: LIST
106150: PPUSH
106151: CALL_OW 72
106155: ST_TO_ADDR
// if not tmp then
106156: LD_VAR 0 4
106160: NOT
106161: IFFALSE 106165
// continue ;
106163: GO 106122
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
106165: LD_EXP 203
106169: PUSH
106170: LD_VAR 0 2
106174: ARRAY
106175: PPUSH
106176: LD_INT 29
106178: PPUSH
106179: CALL_OW 325
106183: NOT
106184: PUSH
106185: LD_EXP 203
106189: PUSH
106190: LD_VAR 0 2
106194: ARRAY
106195: PPUSH
106196: LD_INT 28
106198: PPUSH
106199: CALL_OW 325
106203: NOT
106204: AND
106205: IFFALSE 106209
// continue ;
106207: GO 106122
// for j in tmp do
106209: LD_ADDR_VAR 0 3
106213: PUSH
106214: LD_VAR 0 4
106218: PUSH
106219: FOR_IN
106220: IFFALSE 106279
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
106222: LD_VAR 0 3
106226: PUSH
106227: LD_EXP 180
106231: PUSH
106232: LD_VAR 0 2
106236: ARRAY
106237: PUSH
106238: LD_INT 1
106240: ARRAY
106241: IN
106242: NOT
106243: PUSH
106244: LD_VAR 0 3
106248: PUSH
106249: LD_EXP 180
106253: PUSH
106254: LD_VAR 0 2
106258: ARRAY
106259: PUSH
106260: LD_INT 2
106262: ARRAY
106263: IN
106264: NOT
106265: AND
106266: IFFALSE 106277
// ComSpaceTimeShoot ( j ) ;
106268: LD_VAR 0 3
106272: PPUSH
106273: CALL 20171 0 1
106277: GO 106219
106279: POP
106280: POP
// end ;
106281: GO 106122
106283: POP
106284: POP
// end ;
106285: LD_VAR 0 1
106289: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
106290: LD_INT 0
106292: PPUSH
106293: PPUSH
106294: PPUSH
106295: PPUSH
106296: PPUSH
106297: PPUSH
106298: PPUSH
106299: PPUSH
106300: PPUSH
// if not mc_bases then
106301: LD_EXP 177
106305: NOT
106306: IFFALSE 106310
// exit ;
106308: GO 106932
// for i = 1 to mc_bases do
106310: LD_ADDR_VAR 0 2
106314: PUSH
106315: DOUBLE
106316: LD_INT 1
106318: DEC
106319: ST_TO_ADDR
106320: LD_EXP 177
106324: PUSH
106325: FOR_TO
106326: IFFALSE 106930
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
106328: LD_EXP 212
106332: PUSH
106333: LD_VAR 0 2
106337: ARRAY
106338: NOT
106339: PUSH
106340: LD_INT 38
106342: PPUSH
106343: LD_EXP 203
106347: PUSH
106348: LD_VAR 0 2
106352: ARRAY
106353: PPUSH
106354: CALL_OW 321
106358: PUSH
106359: LD_INT 2
106361: NONEQUAL
106362: OR
106363: IFFALSE 106367
// continue ;
106365: GO 106325
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
106367: LD_ADDR_VAR 0 8
106371: PUSH
106372: LD_EXP 177
106376: PUSH
106377: LD_VAR 0 2
106381: ARRAY
106382: PPUSH
106383: LD_INT 30
106385: PUSH
106386: LD_INT 34
106388: PUSH
106389: EMPTY
106390: LIST
106391: LIST
106392: PPUSH
106393: CALL_OW 72
106397: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
106398: LD_ADDR_VAR 0 9
106402: PUSH
106403: LD_EXP 177
106407: PUSH
106408: LD_VAR 0 2
106412: ARRAY
106413: PPUSH
106414: LD_INT 25
106416: PUSH
106417: LD_INT 4
106419: PUSH
106420: EMPTY
106421: LIST
106422: LIST
106423: PPUSH
106424: CALL_OW 72
106428: PPUSH
106429: LD_INT 0
106431: PPUSH
106432: CALL 53479 0 2
106436: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
106437: LD_VAR 0 9
106441: NOT
106442: PUSH
106443: LD_VAR 0 8
106447: NOT
106448: OR
106449: PUSH
106450: LD_EXP 177
106454: PUSH
106455: LD_VAR 0 2
106459: ARRAY
106460: PPUSH
106461: LD_INT 124
106463: PPUSH
106464: CALL 53479 0 2
106468: OR
106469: IFFALSE 106473
// continue ;
106471: GO 106325
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
106473: LD_EXP 213
106477: PUSH
106478: LD_VAR 0 2
106482: ARRAY
106483: PUSH
106484: LD_EXP 212
106488: PUSH
106489: LD_VAR 0 2
106493: ARRAY
106494: LESS
106495: PUSH
106496: LD_EXP 213
106500: PUSH
106501: LD_VAR 0 2
106505: ARRAY
106506: PUSH
106507: LD_VAR 0 8
106511: LESS
106512: AND
106513: IFFALSE 106928
// begin tmp := sci [ 1 ] ;
106515: LD_ADDR_VAR 0 7
106519: PUSH
106520: LD_VAR 0 9
106524: PUSH
106525: LD_INT 1
106527: ARRAY
106528: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
106529: LD_VAR 0 7
106533: PPUSH
106534: LD_INT 124
106536: PPUSH
106537: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
106541: LD_ADDR_VAR 0 3
106545: PUSH
106546: DOUBLE
106547: LD_EXP 212
106551: PUSH
106552: LD_VAR 0 2
106556: ARRAY
106557: INC
106558: ST_TO_ADDR
106559: LD_EXP 212
106563: PUSH
106564: LD_VAR 0 2
106568: ARRAY
106569: PUSH
106570: FOR_DOWNTO
106571: IFFALSE 106914
// begin if IsInUnit ( tmp ) then
106573: LD_VAR 0 7
106577: PPUSH
106578: CALL_OW 310
106582: IFFALSE 106593
// ComExitBuilding ( tmp ) ;
106584: LD_VAR 0 7
106588: PPUSH
106589: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
106593: LD_INT 35
106595: PPUSH
106596: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
106600: LD_VAR 0 7
106604: PPUSH
106605: CALL_OW 310
106609: NOT
106610: PUSH
106611: LD_VAR 0 7
106615: PPUSH
106616: CALL_OW 314
106620: NOT
106621: AND
106622: IFFALSE 106593
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
106624: LD_ADDR_VAR 0 6
106628: PUSH
106629: LD_VAR 0 7
106633: PPUSH
106634: CALL_OW 250
106638: PUSH
106639: LD_VAR 0 7
106643: PPUSH
106644: CALL_OW 251
106648: PUSH
106649: EMPTY
106650: LIST
106651: LIST
106652: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
106653: LD_INT 35
106655: PPUSH
106656: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
106660: LD_ADDR_VAR 0 4
106664: PUSH
106665: LD_EXP 212
106669: PUSH
106670: LD_VAR 0 2
106674: ARRAY
106675: PUSH
106676: LD_VAR 0 3
106680: ARRAY
106681: PUSH
106682: LD_INT 1
106684: ARRAY
106685: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
106686: LD_ADDR_VAR 0 5
106690: PUSH
106691: LD_EXP 212
106695: PUSH
106696: LD_VAR 0 2
106700: ARRAY
106701: PUSH
106702: LD_VAR 0 3
106706: ARRAY
106707: PUSH
106708: LD_INT 2
106710: ARRAY
106711: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
106712: LD_VAR 0 7
106716: PPUSH
106717: LD_INT 10
106719: PPUSH
106720: CALL 26809 0 2
106724: PUSH
106725: LD_INT 4
106727: ARRAY
106728: IFFALSE 106766
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
106730: LD_VAR 0 7
106734: PPUSH
106735: LD_VAR 0 6
106739: PUSH
106740: LD_INT 1
106742: ARRAY
106743: PPUSH
106744: LD_VAR 0 6
106748: PUSH
106749: LD_INT 2
106751: ARRAY
106752: PPUSH
106753: CALL_OW 111
// wait ( 0 0$10 ) ;
106757: LD_INT 350
106759: PPUSH
106760: CALL_OW 67
// end else
106764: GO 106792
// begin ComMoveXY ( tmp , x , y ) ;
106766: LD_VAR 0 7
106770: PPUSH
106771: LD_VAR 0 4
106775: PPUSH
106776: LD_VAR 0 5
106780: PPUSH
106781: CALL_OW 111
// wait ( 0 0$3 ) ;
106785: LD_INT 105
106787: PPUSH
106788: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
106792: LD_VAR 0 7
106796: PPUSH
106797: LD_VAR 0 4
106801: PPUSH
106802: LD_VAR 0 5
106806: PPUSH
106807: CALL_OW 307
106811: IFFALSE 106653
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
106813: LD_VAR 0 7
106817: PPUSH
106818: LD_VAR 0 4
106822: PPUSH
106823: LD_VAR 0 5
106827: PPUSH
106828: LD_VAR 0 8
106832: PUSH
106833: LD_VAR 0 3
106837: ARRAY
106838: PPUSH
106839: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
106843: LD_INT 35
106845: PPUSH
106846: CALL_OW 67
// until not HasTask ( tmp ) ;
106850: LD_VAR 0 7
106854: PPUSH
106855: CALL_OW 314
106859: NOT
106860: IFFALSE 106843
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
106862: LD_ADDR_EXP 213
106866: PUSH
106867: LD_EXP 213
106871: PPUSH
106872: LD_VAR 0 2
106876: PUSH
106877: LD_EXP 213
106881: PUSH
106882: LD_VAR 0 2
106886: ARRAY
106887: PUSH
106888: LD_INT 1
106890: PLUS
106891: PUSH
106892: EMPTY
106893: LIST
106894: LIST
106895: PPUSH
106896: LD_VAR 0 8
106900: PUSH
106901: LD_VAR 0 3
106905: ARRAY
106906: PPUSH
106907: CALL 24210 0 3
106911: ST_TO_ADDR
// end ;
106912: GO 106570
106914: POP
106915: POP
// MC_Reset ( i , 124 ) ;
106916: LD_VAR 0 2
106920: PPUSH
106921: LD_INT 124
106923: PPUSH
106924: CALL 90070 0 2
// end ; end ;
106928: GO 106325
106930: POP
106931: POP
// end ;
106932: LD_VAR 0 1
106936: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
106937: LD_INT 0
106939: PPUSH
106940: PPUSH
106941: PPUSH
// if not mc_bases then
106942: LD_EXP 177
106946: NOT
106947: IFFALSE 106951
// exit ;
106949: GO 107557
// for i = 1 to mc_bases do
106951: LD_ADDR_VAR 0 2
106955: PUSH
106956: DOUBLE
106957: LD_INT 1
106959: DEC
106960: ST_TO_ADDR
106961: LD_EXP 177
106965: PUSH
106966: FOR_TO
106967: IFFALSE 107555
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
106969: LD_ADDR_VAR 0 3
106973: PUSH
106974: LD_EXP 177
106978: PUSH
106979: LD_VAR 0 2
106983: ARRAY
106984: PPUSH
106985: LD_INT 25
106987: PUSH
106988: LD_INT 4
106990: PUSH
106991: EMPTY
106992: LIST
106993: LIST
106994: PPUSH
106995: CALL_OW 72
106999: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
107000: LD_VAR 0 3
107004: NOT
107005: PUSH
107006: LD_EXP 214
107010: PUSH
107011: LD_VAR 0 2
107015: ARRAY
107016: NOT
107017: OR
107018: PUSH
107019: LD_EXP 177
107023: PUSH
107024: LD_VAR 0 2
107028: ARRAY
107029: PPUSH
107030: LD_INT 2
107032: PUSH
107033: LD_INT 30
107035: PUSH
107036: LD_INT 0
107038: PUSH
107039: EMPTY
107040: LIST
107041: LIST
107042: PUSH
107043: LD_INT 30
107045: PUSH
107046: LD_INT 1
107048: PUSH
107049: EMPTY
107050: LIST
107051: LIST
107052: PUSH
107053: EMPTY
107054: LIST
107055: LIST
107056: LIST
107057: PPUSH
107058: CALL_OW 72
107062: NOT
107063: OR
107064: IFFALSE 107114
// begin if mc_deposits_finder [ i ] then
107066: LD_EXP 215
107070: PUSH
107071: LD_VAR 0 2
107075: ARRAY
107076: IFFALSE 107112
// begin MC_Reset ( i , 125 ) ;
107078: LD_VAR 0 2
107082: PPUSH
107083: LD_INT 125
107085: PPUSH
107086: CALL 90070 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
107090: LD_ADDR_EXP 215
107094: PUSH
107095: LD_EXP 215
107099: PPUSH
107100: LD_VAR 0 2
107104: PPUSH
107105: EMPTY
107106: PPUSH
107107: CALL_OW 1
107111: ST_TO_ADDR
// end ; continue ;
107112: GO 106966
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
107114: LD_EXP 214
107118: PUSH
107119: LD_VAR 0 2
107123: ARRAY
107124: PUSH
107125: LD_INT 1
107127: ARRAY
107128: PUSH
107129: LD_INT 3
107131: ARRAY
107132: PUSH
107133: LD_INT 1
107135: EQUAL
107136: PUSH
107137: LD_INT 20
107139: PPUSH
107140: LD_EXP 203
107144: PUSH
107145: LD_VAR 0 2
107149: ARRAY
107150: PPUSH
107151: CALL_OW 321
107155: PUSH
107156: LD_INT 2
107158: NONEQUAL
107159: AND
107160: IFFALSE 107210
// begin if mc_deposits_finder [ i ] then
107162: LD_EXP 215
107166: PUSH
107167: LD_VAR 0 2
107171: ARRAY
107172: IFFALSE 107208
// begin MC_Reset ( i , 125 ) ;
107174: LD_VAR 0 2
107178: PPUSH
107179: LD_INT 125
107181: PPUSH
107182: CALL 90070 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
107186: LD_ADDR_EXP 215
107190: PUSH
107191: LD_EXP 215
107195: PPUSH
107196: LD_VAR 0 2
107200: PPUSH
107201: EMPTY
107202: PPUSH
107203: CALL_OW 1
107207: ST_TO_ADDR
// end ; continue ;
107208: GO 106966
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
107210: LD_EXP 214
107214: PUSH
107215: LD_VAR 0 2
107219: ARRAY
107220: PUSH
107221: LD_INT 1
107223: ARRAY
107224: PUSH
107225: LD_INT 1
107227: ARRAY
107228: PPUSH
107229: LD_EXP 214
107233: PUSH
107234: LD_VAR 0 2
107238: ARRAY
107239: PUSH
107240: LD_INT 1
107242: ARRAY
107243: PUSH
107244: LD_INT 2
107246: ARRAY
107247: PPUSH
107248: LD_EXP 203
107252: PUSH
107253: LD_VAR 0 2
107257: ARRAY
107258: PPUSH
107259: CALL_OW 440
107263: IFFALSE 107306
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
107265: LD_ADDR_EXP 214
107269: PUSH
107270: LD_EXP 214
107274: PPUSH
107275: LD_VAR 0 2
107279: PPUSH
107280: LD_EXP 214
107284: PUSH
107285: LD_VAR 0 2
107289: ARRAY
107290: PPUSH
107291: LD_INT 1
107293: PPUSH
107294: CALL_OW 3
107298: PPUSH
107299: CALL_OW 1
107303: ST_TO_ADDR
107304: GO 107553
// begin if not mc_deposits_finder [ i ] then
107306: LD_EXP 215
107310: PUSH
107311: LD_VAR 0 2
107315: ARRAY
107316: NOT
107317: IFFALSE 107369
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
107319: LD_ADDR_EXP 215
107323: PUSH
107324: LD_EXP 215
107328: PPUSH
107329: LD_VAR 0 2
107333: PPUSH
107334: LD_VAR 0 3
107338: PUSH
107339: LD_INT 1
107341: ARRAY
107342: PUSH
107343: EMPTY
107344: LIST
107345: PPUSH
107346: CALL_OW 1
107350: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
107351: LD_VAR 0 3
107355: PUSH
107356: LD_INT 1
107358: ARRAY
107359: PPUSH
107360: LD_INT 125
107362: PPUSH
107363: CALL_OW 109
// end else
107367: GO 107553
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
107369: LD_EXP 215
107373: PUSH
107374: LD_VAR 0 2
107378: ARRAY
107379: PUSH
107380: LD_INT 1
107382: ARRAY
107383: PPUSH
107384: CALL_OW 310
107388: IFFALSE 107411
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
107390: LD_EXP 215
107394: PUSH
107395: LD_VAR 0 2
107399: ARRAY
107400: PUSH
107401: LD_INT 1
107403: ARRAY
107404: PPUSH
107405: CALL_OW 122
107409: GO 107553
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
107411: LD_EXP 215
107415: PUSH
107416: LD_VAR 0 2
107420: ARRAY
107421: PUSH
107422: LD_INT 1
107424: ARRAY
107425: PPUSH
107426: CALL_OW 314
107430: NOT
107431: PUSH
107432: LD_EXP 215
107436: PUSH
107437: LD_VAR 0 2
107441: ARRAY
107442: PUSH
107443: LD_INT 1
107445: ARRAY
107446: PPUSH
107447: LD_EXP 214
107451: PUSH
107452: LD_VAR 0 2
107456: ARRAY
107457: PUSH
107458: LD_INT 1
107460: ARRAY
107461: PUSH
107462: LD_INT 1
107464: ARRAY
107465: PPUSH
107466: LD_EXP 214
107470: PUSH
107471: LD_VAR 0 2
107475: ARRAY
107476: PUSH
107477: LD_INT 1
107479: ARRAY
107480: PUSH
107481: LD_INT 2
107483: ARRAY
107484: PPUSH
107485: CALL_OW 297
107489: PUSH
107490: LD_INT 6
107492: GREATER
107493: AND
107494: IFFALSE 107553
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
107496: LD_EXP 215
107500: PUSH
107501: LD_VAR 0 2
107505: ARRAY
107506: PUSH
107507: LD_INT 1
107509: ARRAY
107510: PPUSH
107511: LD_EXP 214
107515: PUSH
107516: LD_VAR 0 2
107520: ARRAY
107521: PUSH
107522: LD_INT 1
107524: ARRAY
107525: PUSH
107526: LD_INT 1
107528: ARRAY
107529: PPUSH
107530: LD_EXP 214
107534: PUSH
107535: LD_VAR 0 2
107539: ARRAY
107540: PUSH
107541: LD_INT 1
107543: ARRAY
107544: PUSH
107545: LD_INT 2
107547: ARRAY
107548: PPUSH
107549: CALL_OW 111
// end ; end ; end ;
107553: GO 106966
107555: POP
107556: POP
// end ;
107557: LD_VAR 0 1
107561: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
107562: LD_INT 0
107564: PPUSH
107565: PPUSH
107566: PPUSH
107567: PPUSH
107568: PPUSH
107569: PPUSH
107570: PPUSH
107571: PPUSH
107572: PPUSH
107573: PPUSH
107574: PPUSH
// if not mc_bases then
107575: LD_EXP 177
107579: NOT
107580: IFFALSE 107584
// exit ;
107582: GO 108524
// for i = 1 to mc_bases do
107584: LD_ADDR_VAR 0 2
107588: PUSH
107589: DOUBLE
107590: LD_INT 1
107592: DEC
107593: ST_TO_ADDR
107594: LD_EXP 177
107598: PUSH
107599: FOR_TO
107600: IFFALSE 108522
// begin if not mc_bases [ i ] or mc_scan [ i ] then
107602: LD_EXP 177
107606: PUSH
107607: LD_VAR 0 2
107611: ARRAY
107612: NOT
107613: PUSH
107614: LD_EXP 200
107618: PUSH
107619: LD_VAR 0 2
107623: ARRAY
107624: OR
107625: IFFALSE 107629
// continue ;
107627: GO 107599
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
107629: LD_ADDR_VAR 0 7
107633: PUSH
107634: LD_EXP 177
107638: PUSH
107639: LD_VAR 0 2
107643: ARRAY
107644: PUSH
107645: LD_INT 1
107647: ARRAY
107648: PPUSH
107649: CALL_OW 248
107653: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
107654: LD_VAR 0 7
107658: PUSH
107659: LD_INT 3
107661: EQUAL
107662: PUSH
107663: LD_EXP 196
107667: PUSH
107668: LD_VAR 0 2
107672: ARRAY
107673: PUSH
107674: LD_EXP 199
107678: PUSH
107679: LD_VAR 0 2
107683: ARRAY
107684: UNION
107685: PPUSH
107686: LD_INT 33
107688: PUSH
107689: LD_INT 2
107691: PUSH
107692: EMPTY
107693: LIST
107694: LIST
107695: PPUSH
107696: CALL_OW 72
107700: NOT
107701: OR
107702: IFFALSE 107706
// continue ;
107704: GO 107599
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
107706: LD_ADDR_VAR 0 9
107710: PUSH
107711: LD_EXP 177
107715: PUSH
107716: LD_VAR 0 2
107720: ARRAY
107721: PPUSH
107722: LD_INT 30
107724: PUSH
107725: LD_INT 36
107727: PUSH
107728: EMPTY
107729: LIST
107730: LIST
107731: PPUSH
107732: CALL_OW 72
107736: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
107737: LD_ADDR_VAR 0 10
107741: PUSH
107742: LD_EXP 196
107746: PUSH
107747: LD_VAR 0 2
107751: ARRAY
107752: PPUSH
107753: LD_INT 34
107755: PUSH
107756: LD_INT 31
107758: PUSH
107759: EMPTY
107760: LIST
107761: LIST
107762: PPUSH
107763: CALL_OW 72
107767: ST_TO_ADDR
// if not cts and not mcts then
107768: LD_VAR 0 9
107772: NOT
107773: PUSH
107774: LD_VAR 0 10
107778: NOT
107779: AND
107780: IFFALSE 107784
// continue ;
107782: GO 107599
// x := cts ;
107784: LD_ADDR_VAR 0 11
107788: PUSH
107789: LD_VAR 0 9
107793: ST_TO_ADDR
// if not x then
107794: LD_VAR 0 11
107798: NOT
107799: IFFALSE 107811
// x := mcts ;
107801: LD_ADDR_VAR 0 11
107805: PUSH
107806: LD_VAR 0 10
107810: ST_TO_ADDR
// if not x then
107811: LD_VAR 0 11
107815: NOT
107816: IFFALSE 107820
// continue ;
107818: GO 107599
// if mc_remote_driver [ i ] then
107820: LD_EXP 217
107824: PUSH
107825: LD_VAR 0 2
107829: ARRAY
107830: IFFALSE 108217
// for j in mc_remote_driver [ i ] do
107832: LD_ADDR_VAR 0 3
107836: PUSH
107837: LD_EXP 217
107841: PUSH
107842: LD_VAR 0 2
107846: ARRAY
107847: PUSH
107848: FOR_IN
107849: IFFALSE 108215
// begin if GetClass ( j ) <> 3 then
107851: LD_VAR 0 3
107855: PPUSH
107856: CALL_OW 257
107860: PUSH
107861: LD_INT 3
107863: NONEQUAL
107864: IFFALSE 107917
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
107866: LD_ADDR_EXP 217
107870: PUSH
107871: LD_EXP 217
107875: PPUSH
107876: LD_VAR 0 2
107880: PPUSH
107881: LD_EXP 217
107885: PUSH
107886: LD_VAR 0 2
107890: ARRAY
107891: PUSH
107892: LD_VAR 0 3
107896: DIFF
107897: PPUSH
107898: CALL_OW 1
107902: ST_TO_ADDR
// SetTag ( j , 0 ) ;
107903: LD_VAR 0 3
107907: PPUSH
107908: LD_INT 0
107910: PPUSH
107911: CALL_OW 109
// continue ;
107915: GO 107848
// end ; if UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) and not IsDriver ( j ) then
107917: LD_EXP 196
107921: PUSH
107922: LD_VAR 0 2
107926: ARRAY
107927: PPUSH
107928: LD_INT 34
107930: PUSH
107931: LD_INT 31
107933: PUSH
107934: EMPTY
107935: LIST
107936: LIST
107937: PUSH
107938: LD_INT 58
107940: PUSH
107941: EMPTY
107942: LIST
107943: PUSH
107944: EMPTY
107945: LIST
107946: LIST
107947: PPUSH
107948: CALL_OW 72
107952: PUSH
107953: LD_VAR 0 3
107957: PPUSH
107958: CALL 53567 0 1
107962: NOT
107963: AND
107964: IFFALSE 108035
// begin if IsInUnit ( j ) then
107966: LD_VAR 0 3
107970: PPUSH
107971: CALL_OW 310
107975: IFFALSE 107986
// ComExitBuilding ( j ) ;
107977: LD_VAR 0 3
107981: PPUSH
107982: CALL_OW 122
// AddComEnterUnit ( j , UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) [ 1 ] ) ;
107986: LD_VAR 0 3
107990: PPUSH
107991: LD_EXP 196
107995: PUSH
107996: LD_VAR 0 2
108000: ARRAY
108001: PPUSH
108002: LD_INT 34
108004: PUSH
108005: LD_INT 31
108007: PUSH
108008: EMPTY
108009: LIST
108010: LIST
108011: PUSH
108012: LD_INT 58
108014: PUSH
108015: EMPTY
108016: LIST
108017: PUSH
108018: EMPTY
108019: LIST
108020: LIST
108021: PPUSH
108022: CALL_OW 72
108026: PUSH
108027: LD_INT 1
108029: ARRAY
108030: PPUSH
108031: CALL_OW 180
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
108035: LD_VAR 0 3
108039: PPUSH
108040: CALL_OW 310
108044: NOT
108045: PUSH
108046: LD_VAR 0 3
108050: PPUSH
108051: CALL_OW 310
108055: PPUSH
108056: CALL_OW 266
108060: PUSH
108061: LD_INT 36
108063: NONEQUAL
108064: PUSH
108065: LD_VAR 0 3
108069: PPUSH
108070: CALL 53567 0 1
108074: NOT
108075: AND
108076: OR
108077: IFFALSE 108213
// begin if IsInUnit ( j ) then
108079: LD_VAR 0 3
108083: PPUSH
108084: CALL_OW 310
108088: IFFALSE 108099
// ComExitBuilding ( j ) ;
108090: LD_VAR 0 3
108094: PPUSH
108095: CALL_OW 122
// ct := 0 ;
108099: LD_ADDR_VAR 0 8
108103: PUSH
108104: LD_INT 0
108106: ST_TO_ADDR
// for k in x do
108107: LD_ADDR_VAR 0 4
108111: PUSH
108112: LD_VAR 0 11
108116: PUSH
108117: FOR_IN
108118: IFFALSE 108191
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
108120: LD_VAR 0 4
108124: PPUSH
108125: CALL_OW 264
108129: PUSH
108130: LD_INT 31
108132: EQUAL
108133: PUSH
108134: LD_VAR 0 4
108138: PPUSH
108139: CALL_OW 311
108143: NOT
108144: AND
108145: PUSH
108146: LD_VAR 0 4
108150: PPUSH
108151: CALL_OW 266
108155: PUSH
108156: LD_INT 36
108158: EQUAL
108159: PUSH
108160: LD_VAR 0 4
108164: PPUSH
108165: CALL_OW 313
108169: PUSH
108170: LD_INT 3
108172: LESS
108173: AND
108174: OR
108175: IFFALSE 108189
// begin ct := k ;
108177: LD_ADDR_VAR 0 8
108181: PUSH
108182: LD_VAR 0 4
108186: ST_TO_ADDR
// break ;
108187: GO 108191
// end ;
108189: GO 108117
108191: POP
108192: POP
// if ct then
108193: LD_VAR 0 8
108197: IFFALSE 108213
// ComEnterUnit ( j , ct ) ;
108199: LD_VAR 0 3
108203: PPUSH
108204: LD_VAR 0 8
108208: PPUSH
108209: CALL_OW 120
// end ; end ;
108213: GO 107848
108215: POP
108216: POP
// places := 0 ;
108217: LD_ADDR_VAR 0 5
108221: PUSH
108222: LD_INT 0
108224: ST_TO_ADDR
// for j = 1 to x do
108225: LD_ADDR_VAR 0 3
108229: PUSH
108230: DOUBLE
108231: LD_INT 1
108233: DEC
108234: ST_TO_ADDR
108235: LD_VAR 0 11
108239: PUSH
108240: FOR_TO
108241: IFFALSE 108317
// if GetWeapon ( x [ j ] ) = ar_control_tower then
108243: LD_VAR 0 11
108247: PUSH
108248: LD_VAR 0 3
108252: ARRAY
108253: PPUSH
108254: CALL_OW 264
108258: PUSH
108259: LD_INT 31
108261: EQUAL
108262: IFFALSE 108280
// places := places + 1 else
108264: LD_ADDR_VAR 0 5
108268: PUSH
108269: LD_VAR 0 5
108273: PUSH
108274: LD_INT 1
108276: PLUS
108277: ST_TO_ADDR
108278: GO 108315
// if GetBType ( x [ j ] ) = b_control_tower then
108280: LD_VAR 0 11
108284: PUSH
108285: LD_VAR 0 3
108289: ARRAY
108290: PPUSH
108291: CALL_OW 266
108295: PUSH
108296: LD_INT 36
108298: EQUAL
108299: IFFALSE 108315
// places := places + 3 ;
108301: LD_ADDR_VAR 0 5
108305: PUSH
108306: LD_VAR 0 5
108310: PUSH
108311: LD_INT 3
108313: PLUS
108314: ST_TO_ADDR
108315: GO 108240
108317: POP
108318: POP
// if places = 0 or places <= mc_remote_driver [ i ] then
108319: LD_VAR 0 5
108323: PUSH
108324: LD_INT 0
108326: EQUAL
108327: PUSH
108328: LD_VAR 0 5
108332: PUSH
108333: LD_EXP 217
108337: PUSH
108338: LD_VAR 0 2
108342: ARRAY
108343: LESSEQUAL
108344: OR
108345: IFFALSE 108349
// continue ;
108347: GO 107599
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
108349: LD_ADDR_VAR 0 6
108353: PUSH
108354: LD_EXP 177
108358: PUSH
108359: LD_VAR 0 2
108363: ARRAY
108364: PPUSH
108365: LD_INT 25
108367: PUSH
108368: LD_INT 3
108370: PUSH
108371: EMPTY
108372: LIST
108373: LIST
108374: PPUSH
108375: CALL_OW 72
108379: PUSH
108380: LD_EXP 217
108384: PUSH
108385: LD_VAR 0 2
108389: ARRAY
108390: DIFF
108391: PPUSH
108392: LD_INT 3
108394: PPUSH
108395: CALL 54467 0 2
108399: ST_TO_ADDR
// for j in tmp do
108400: LD_ADDR_VAR 0 3
108404: PUSH
108405: LD_VAR 0 6
108409: PUSH
108410: FOR_IN
108411: IFFALSE 108446
// if GetTag ( j ) > 0 then
108413: LD_VAR 0 3
108417: PPUSH
108418: CALL_OW 110
108422: PUSH
108423: LD_INT 0
108425: GREATER
108426: IFFALSE 108444
// tmp := tmp diff j ;
108428: LD_ADDR_VAR 0 6
108432: PUSH
108433: LD_VAR 0 6
108437: PUSH
108438: LD_VAR 0 3
108442: DIFF
108443: ST_TO_ADDR
108444: GO 108410
108446: POP
108447: POP
// if not tmp then
108448: LD_VAR 0 6
108452: NOT
108453: IFFALSE 108457
// continue ;
108455: GO 107599
// if places then
108457: LD_VAR 0 5
108461: IFFALSE 108520
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
108463: LD_ADDR_EXP 217
108467: PUSH
108468: LD_EXP 217
108472: PPUSH
108473: LD_VAR 0 2
108477: PPUSH
108478: LD_EXP 217
108482: PUSH
108483: LD_VAR 0 2
108487: ARRAY
108488: PUSH
108489: LD_VAR 0 6
108493: PUSH
108494: LD_INT 1
108496: ARRAY
108497: UNION
108498: PPUSH
108499: CALL_OW 1
108503: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
108504: LD_VAR 0 6
108508: PUSH
108509: LD_INT 1
108511: ARRAY
108512: PPUSH
108513: LD_INT 126
108515: PPUSH
108516: CALL_OW 109
// end ; end ;
108520: GO 107599
108522: POP
108523: POP
// end ;
108524: LD_VAR 0 1
108528: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
108529: LD_INT 0
108531: PPUSH
108532: PPUSH
108533: PPUSH
108534: PPUSH
108535: PPUSH
108536: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
108537: LD_VAR 0 1
108541: NOT
108542: PUSH
108543: LD_VAR 0 2
108547: NOT
108548: OR
108549: PUSH
108550: LD_VAR 0 3
108554: NOT
108555: OR
108556: PUSH
108557: LD_VAR 0 4
108561: PUSH
108562: LD_INT 1
108564: PUSH
108565: LD_INT 2
108567: PUSH
108568: LD_INT 3
108570: PUSH
108571: LD_INT 4
108573: PUSH
108574: LD_INT 5
108576: PUSH
108577: LD_INT 8
108579: PUSH
108580: LD_INT 9
108582: PUSH
108583: LD_INT 15
108585: PUSH
108586: LD_INT 16
108588: PUSH
108589: EMPTY
108590: LIST
108591: LIST
108592: LIST
108593: LIST
108594: LIST
108595: LIST
108596: LIST
108597: LIST
108598: LIST
108599: IN
108600: NOT
108601: OR
108602: IFFALSE 108606
// exit ;
108604: GO 109506
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
108606: LD_ADDR_VAR 0 2
108610: PUSH
108611: LD_VAR 0 2
108615: PPUSH
108616: LD_INT 21
108618: PUSH
108619: LD_INT 3
108621: PUSH
108622: EMPTY
108623: LIST
108624: LIST
108625: PUSH
108626: LD_INT 24
108628: PUSH
108629: LD_INT 250
108631: PUSH
108632: EMPTY
108633: LIST
108634: LIST
108635: PUSH
108636: EMPTY
108637: LIST
108638: LIST
108639: PPUSH
108640: CALL_OW 72
108644: ST_TO_ADDR
// case class of 1 , 15 :
108645: LD_VAR 0 4
108649: PUSH
108650: LD_INT 1
108652: DOUBLE
108653: EQUAL
108654: IFTRUE 108664
108656: LD_INT 15
108658: DOUBLE
108659: EQUAL
108660: IFTRUE 108664
108662: GO 108749
108664: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
108665: LD_ADDR_VAR 0 8
108669: PUSH
108670: LD_VAR 0 2
108674: PPUSH
108675: LD_INT 2
108677: PUSH
108678: LD_INT 30
108680: PUSH
108681: LD_INT 32
108683: PUSH
108684: EMPTY
108685: LIST
108686: LIST
108687: PUSH
108688: LD_INT 30
108690: PUSH
108691: LD_INT 31
108693: PUSH
108694: EMPTY
108695: LIST
108696: LIST
108697: PUSH
108698: EMPTY
108699: LIST
108700: LIST
108701: LIST
108702: PPUSH
108703: CALL_OW 72
108707: PUSH
108708: LD_VAR 0 2
108712: PPUSH
108713: LD_INT 2
108715: PUSH
108716: LD_INT 30
108718: PUSH
108719: LD_INT 4
108721: PUSH
108722: EMPTY
108723: LIST
108724: LIST
108725: PUSH
108726: LD_INT 30
108728: PUSH
108729: LD_INT 5
108731: PUSH
108732: EMPTY
108733: LIST
108734: LIST
108735: PUSH
108736: EMPTY
108737: LIST
108738: LIST
108739: LIST
108740: PPUSH
108741: CALL_OW 72
108745: ADD
108746: ST_TO_ADDR
108747: GO 108995
108749: LD_INT 2
108751: DOUBLE
108752: EQUAL
108753: IFTRUE 108763
108755: LD_INT 16
108757: DOUBLE
108758: EQUAL
108759: IFTRUE 108763
108761: GO 108809
108763: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
108764: LD_ADDR_VAR 0 8
108768: PUSH
108769: LD_VAR 0 2
108773: PPUSH
108774: LD_INT 2
108776: PUSH
108777: LD_INT 30
108779: PUSH
108780: LD_INT 0
108782: PUSH
108783: EMPTY
108784: LIST
108785: LIST
108786: PUSH
108787: LD_INT 30
108789: PUSH
108790: LD_INT 1
108792: PUSH
108793: EMPTY
108794: LIST
108795: LIST
108796: PUSH
108797: EMPTY
108798: LIST
108799: LIST
108800: LIST
108801: PPUSH
108802: CALL_OW 72
108806: ST_TO_ADDR
108807: GO 108995
108809: LD_INT 3
108811: DOUBLE
108812: EQUAL
108813: IFTRUE 108817
108815: GO 108863
108817: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
108818: LD_ADDR_VAR 0 8
108822: PUSH
108823: LD_VAR 0 2
108827: PPUSH
108828: LD_INT 2
108830: PUSH
108831: LD_INT 30
108833: PUSH
108834: LD_INT 2
108836: PUSH
108837: EMPTY
108838: LIST
108839: LIST
108840: PUSH
108841: LD_INT 30
108843: PUSH
108844: LD_INT 3
108846: PUSH
108847: EMPTY
108848: LIST
108849: LIST
108850: PUSH
108851: EMPTY
108852: LIST
108853: LIST
108854: LIST
108855: PPUSH
108856: CALL_OW 72
108860: ST_TO_ADDR
108861: GO 108995
108863: LD_INT 4
108865: DOUBLE
108866: EQUAL
108867: IFTRUE 108871
108869: GO 108928
108871: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
108872: LD_ADDR_VAR 0 8
108876: PUSH
108877: LD_VAR 0 2
108881: PPUSH
108882: LD_INT 2
108884: PUSH
108885: LD_INT 30
108887: PUSH
108888: LD_INT 6
108890: PUSH
108891: EMPTY
108892: LIST
108893: LIST
108894: PUSH
108895: LD_INT 30
108897: PUSH
108898: LD_INT 7
108900: PUSH
108901: EMPTY
108902: LIST
108903: LIST
108904: PUSH
108905: LD_INT 30
108907: PUSH
108908: LD_INT 8
108910: PUSH
108911: EMPTY
108912: LIST
108913: LIST
108914: PUSH
108915: EMPTY
108916: LIST
108917: LIST
108918: LIST
108919: LIST
108920: PPUSH
108921: CALL_OW 72
108925: ST_TO_ADDR
108926: GO 108995
108928: LD_INT 5
108930: DOUBLE
108931: EQUAL
108932: IFTRUE 108948
108934: LD_INT 8
108936: DOUBLE
108937: EQUAL
108938: IFTRUE 108948
108940: LD_INT 9
108942: DOUBLE
108943: EQUAL
108944: IFTRUE 108948
108946: GO 108994
108948: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
108949: LD_ADDR_VAR 0 8
108953: PUSH
108954: LD_VAR 0 2
108958: PPUSH
108959: LD_INT 2
108961: PUSH
108962: LD_INT 30
108964: PUSH
108965: LD_INT 4
108967: PUSH
108968: EMPTY
108969: LIST
108970: LIST
108971: PUSH
108972: LD_INT 30
108974: PUSH
108975: LD_INT 5
108977: PUSH
108978: EMPTY
108979: LIST
108980: LIST
108981: PUSH
108982: EMPTY
108983: LIST
108984: LIST
108985: LIST
108986: PPUSH
108987: CALL_OW 72
108991: ST_TO_ADDR
108992: GO 108995
108994: POP
// if not tmp then
108995: LD_VAR 0 8
108999: NOT
109000: IFFALSE 109004
// exit ;
109002: GO 109506
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
109004: LD_VAR 0 4
109008: PUSH
109009: LD_INT 1
109011: PUSH
109012: LD_INT 15
109014: PUSH
109015: EMPTY
109016: LIST
109017: LIST
109018: IN
109019: PUSH
109020: LD_EXP 186
109024: PUSH
109025: LD_VAR 0 1
109029: ARRAY
109030: AND
109031: IFFALSE 109187
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
109033: LD_ADDR_VAR 0 9
109037: PUSH
109038: LD_EXP 186
109042: PUSH
109043: LD_VAR 0 1
109047: ARRAY
109048: PUSH
109049: LD_INT 1
109051: ARRAY
109052: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
109053: LD_VAR 0 9
109057: PUSH
109058: LD_EXP 187
109062: PUSH
109063: LD_VAR 0 1
109067: ARRAY
109068: IN
109069: NOT
109070: IFFALSE 109185
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
109072: LD_ADDR_EXP 187
109076: PUSH
109077: LD_EXP 187
109081: PPUSH
109082: LD_VAR 0 1
109086: PUSH
109087: LD_EXP 187
109091: PUSH
109092: LD_VAR 0 1
109096: ARRAY
109097: PUSH
109098: LD_INT 1
109100: PLUS
109101: PUSH
109102: EMPTY
109103: LIST
109104: LIST
109105: PPUSH
109106: LD_VAR 0 9
109110: PPUSH
109111: CALL 24210 0 3
109115: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
109116: LD_ADDR_EXP 186
109120: PUSH
109121: LD_EXP 186
109125: PPUSH
109126: LD_VAR 0 1
109130: PPUSH
109131: LD_EXP 186
109135: PUSH
109136: LD_VAR 0 1
109140: ARRAY
109141: PUSH
109142: LD_VAR 0 9
109146: DIFF
109147: PPUSH
109148: CALL_OW 1
109152: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
109153: LD_VAR 0 3
109157: PPUSH
109158: LD_EXP 187
109162: PUSH
109163: LD_VAR 0 1
109167: ARRAY
109168: PUSH
109169: LD_EXP 187
109173: PUSH
109174: LD_VAR 0 1
109178: ARRAY
109179: ARRAY
109180: PPUSH
109181: CALL_OW 120
// end ; exit ;
109185: GO 109506
// end ; if tmp > 1 then
109187: LD_VAR 0 8
109191: PUSH
109192: LD_INT 1
109194: GREATER
109195: IFFALSE 109299
// for i = 2 to tmp do
109197: LD_ADDR_VAR 0 6
109201: PUSH
109202: DOUBLE
109203: LD_INT 2
109205: DEC
109206: ST_TO_ADDR
109207: LD_VAR 0 8
109211: PUSH
109212: FOR_TO
109213: IFFALSE 109297
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
109215: LD_VAR 0 8
109219: PUSH
109220: LD_VAR 0 6
109224: ARRAY
109225: PPUSH
109226: CALL_OW 461
109230: PUSH
109231: LD_INT 6
109233: EQUAL
109234: IFFALSE 109295
// begin x := tmp [ i ] ;
109236: LD_ADDR_VAR 0 9
109240: PUSH
109241: LD_VAR 0 8
109245: PUSH
109246: LD_VAR 0 6
109250: ARRAY
109251: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
109252: LD_ADDR_VAR 0 8
109256: PUSH
109257: LD_VAR 0 8
109261: PPUSH
109262: LD_VAR 0 6
109266: PPUSH
109267: CALL_OW 3
109271: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
109272: LD_ADDR_VAR 0 8
109276: PUSH
109277: LD_VAR 0 8
109281: PPUSH
109282: LD_INT 1
109284: PPUSH
109285: LD_VAR 0 9
109289: PPUSH
109290: CALL_OW 2
109294: ST_TO_ADDR
// end ;
109295: GO 109212
109297: POP
109298: POP
// for i in tmp do
109299: LD_ADDR_VAR 0 6
109303: PUSH
109304: LD_VAR 0 8
109308: PUSH
109309: FOR_IN
109310: IFFALSE 109379
// begin if ( UnitsInside ( i ) < 6 and not GetBType ( i ) in [ b_breastwork , b_bunker ] ) or UnitsInside ( i ) = 0 then
109312: LD_VAR 0 6
109316: PPUSH
109317: CALL_OW 313
109321: PUSH
109322: LD_INT 6
109324: LESS
109325: PUSH
109326: LD_VAR 0 6
109330: PPUSH
109331: CALL_OW 266
109335: PUSH
109336: LD_INT 31
109338: PUSH
109339: LD_INT 32
109341: PUSH
109342: EMPTY
109343: LIST
109344: LIST
109345: IN
109346: NOT
109347: AND
109348: PUSH
109349: LD_VAR 0 6
109353: PPUSH
109354: CALL_OW 313
109358: PUSH
109359: LD_INT 0
109361: EQUAL
109362: OR
109363: IFFALSE 109377
// begin j := i ;
109365: LD_ADDR_VAR 0 7
109369: PUSH
109370: LD_VAR 0 6
109374: ST_TO_ADDR
// break ;
109375: GO 109379
// end ; end ;
109377: GO 109309
109379: POP
109380: POP
// if j then
109381: LD_VAR 0 7
109385: IFFALSE 109403
// ComEnterUnit ( unit , j ) else
109387: LD_VAR 0 3
109391: PPUSH
109392: LD_VAR 0 7
109396: PPUSH
109397: CALL_OW 120
109401: GO 109506
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
109403: LD_ADDR_VAR 0 10
109407: PUSH
109408: LD_VAR 0 2
109412: PPUSH
109413: LD_INT 2
109415: PUSH
109416: LD_INT 30
109418: PUSH
109419: LD_INT 0
109421: PUSH
109422: EMPTY
109423: LIST
109424: LIST
109425: PUSH
109426: LD_INT 30
109428: PUSH
109429: LD_INT 1
109431: PUSH
109432: EMPTY
109433: LIST
109434: LIST
109435: PUSH
109436: EMPTY
109437: LIST
109438: LIST
109439: LIST
109440: PPUSH
109441: CALL_OW 72
109445: ST_TO_ADDR
// if depot then
109446: LD_VAR 0 10
109450: IFFALSE 109506
// begin depot := NearestUnitToUnit ( depot , unit ) ;
109452: LD_ADDR_VAR 0 10
109456: PUSH
109457: LD_VAR 0 10
109461: PPUSH
109462: LD_VAR 0 3
109466: PPUSH
109467: CALL_OW 74
109471: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
109472: LD_VAR 0 3
109476: PPUSH
109477: LD_VAR 0 10
109481: PPUSH
109482: CALL_OW 296
109486: PUSH
109487: LD_INT 10
109489: GREATER
109490: IFFALSE 109506
// ComStandNearbyBuilding ( unit , depot ) ;
109492: LD_VAR 0 3
109496: PPUSH
109497: LD_VAR 0 10
109501: PPUSH
109502: CALL 20788 0 2
// end ; end ; end ;
109506: LD_VAR 0 5
109510: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
109511: LD_INT 0
109513: PPUSH
109514: PPUSH
109515: PPUSH
109516: PPUSH
// if not mc_bases then
109517: LD_EXP 177
109521: NOT
109522: IFFALSE 109526
// exit ;
109524: GO 109765
// for i = 1 to mc_bases do
109526: LD_ADDR_VAR 0 2
109530: PUSH
109531: DOUBLE
109532: LD_INT 1
109534: DEC
109535: ST_TO_ADDR
109536: LD_EXP 177
109540: PUSH
109541: FOR_TO
109542: IFFALSE 109763
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
109544: LD_ADDR_VAR 0 4
109548: PUSH
109549: LD_EXP 177
109553: PUSH
109554: LD_VAR 0 2
109558: ARRAY
109559: PPUSH
109560: LD_INT 21
109562: PUSH
109563: LD_INT 1
109565: PUSH
109566: EMPTY
109567: LIST
109568: LIST
109569: PPUSH
109570: CALL_OW 72
109574: PUSH
109575: LD_EXP 206
109579: PUSH
109580: LD_VAR 0 2
109584: ARRAY
109585: UNION
109586: ST_TO_ADDR
// if not tmp then
109587: LD_VAR 0 4
109591: NOT
109592: IFFALSE 109596
// continue ;
109594: GO 109541
// for j in tmp do
109596: LD_ADDR_VAR 0 3
109600: PUSH
109601: LD_VAR 0 4
109605: PUSH
109606: FOR_IN
109607: IFFALSE 109759
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
109609: LD_VAR 0 3
109613: PPUSH
109614: CALL_OW 110
109618: NOT
109619: PUSH
109620: LD_VAR 0 3
109624: PPUSH
109625: CALL_OW 314
109629: NOT
109630: AND
109631: PUSH
109632: LD_VAR 0 3
109636: PPUSH
109637: CALL_OW 311
109641: NOT
109642: AND
109643: PUSH
109644: LD_VAR 0 3
109648: PPUSH
109649: CALL_OW 310
109653: NOT
109654: AND
109655: PUSH
109656: LD_VAR 0 3
109660: PUSH
109661: LD_EXP 180
109665: PUSH
109666: LD_VAR 0 2
109670: ARRAY
109671: PUSH
109672: LD_INT 1
109674: ARRAY
109675: IN
109676: NOT
109677: AND
109678: PUSH
109679: LD_VAR 0 3
109683: PUSH
109684: LD_EXP 180
109688: PUSH
109689: LD_VAR 0 2
109693: ARRAY
109694: PUSH
109695: LD_INT 2
109697: ARRAY
109698: IN
109699: NOT
109700: AND
109701: PUSH
109702: LD_VAR 0 3
109706: PUSH
109707: LD_EXP 189
109711: PUSH
109712: LD_VAR 0 2
109716: ARRAY
109717: IN
109718: NOT
109719: AND
109720: IFFALSE 109757
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
109722: LD_VAR 0 2
109726: PPUSH
109727: LD_EXP 177
109731: PUSH
109732: LD_VAR 0 2
109736: ARRAY
109737: PPUSH
109738: LD_VAR 0 3
109742: PPUSH
109743: LD_VAR 0 3
109747: PPUSH
109748: CALL_OW 257
109752: PPUSH
109753: CALL 108529 0 4
// end ;
109757: GO 109606
109759: POP
109760: POP
// end ;
109761: GO 109541
109763: POP
109764: POP
// end ;
109765: LD_VAR 0 1
109769: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , x , j ; begin
109770: LD_INT 0
109772: PPUSH
109773: PPUSH
109774: PPUSH
109775: PPUSH
109776: PPUSH
109777: PPUSH
// if not mc_bases [ base ] then
109778: LD_EXP 177
109782: PUSH
109783: LD_VAR 0 1
109787: ARRAY
109788: NOT
109789: IFFALSE 109793
// exit ;
109791: GO 109975
// tmp := [ ] ;
109793: LD_ADDR_VAR 0 6
109797: PUSH
109798: EMPTY
109799: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
109800: LD_ADDR_VAR 0 7
109804: PUSH
109805: LD_VAR 0 3
109809: PPUSH
109810: LD_INT 0
109812: PPUSH
109813: CALL_OW 517
109817: ST_TO_ADDR
// if not list then
109818: LD_VAR 0 7
109822: NOT
109823: IFFALSE 109827
// exit ;
109825: GO 109975
// for i = 1 to amount do
109827: LD_ADDR_VAR 0 5
109831: PUSH
109832: DOUBLE
109833: LD_INT 1
109835: DEC
109836: ST_TO_ADDR
109837: LD_VAR 0 2
109841: PUSH
109842: FOR_TO
109843: IFFALSE 109923
// begin x := rand ( 1 , list [ 1 ] ) ;
109845: LD_ADDR_VAR 0 8
109849: PUSH
109850: LD_INT 1
109852: PPUSH
109853: LD_VAR 0 7
109857: PUSH
109858: LD_INT 1
109860: ARRAY
109861: PPUSH
109862: CALL_OW 12
109866: ST_TO_ADDR
// tmp := Replace ( tmp , i , [ list [ 1 ] [ x ] , list [ 2 ] [ x ] ] ) ;
109867: LD_ADDR_VAR 0 6
109871: PUSH
109872: LD_VAR 0 6
109876: PPUSH
109877: LD_VAR 0 5
109881: PPUSH
109882: LD_VAR 0 7
109886: PUSH
109887: LD_INT 1
109889: ARRAY
109890: PUSH
109891: LD_VAR 0 8
109895: ARRAY
109896: PUSH
109897: LD_VAR 0 7
109901: PUSH
109902: LD_INT 2
109904: ARRAY
109905: PUSH
109906: LD_VAR 0 8
109910: ARRAY
109911: PUSH
109912: EMPTY
109913: LIST
109914: LIST
109915: PPUSH
109916: CALL_OW 1
109920: ST_TO_ADDR
// end ;
109921: GO 109842
109923: POP
109924: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
109925: LD_ADDR_EXP 190
109929: PUSH
109930: LD_EXP 190
109934: PPUSH
109935: LD_VAR 0 1
109939: PPUSH
109940: LD_VAR 0 6
109944: PPUSH
109945: CALL_OW 1
109949: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
109950: LD_ADDR_EXP 192
109954: PUSH
109955: LD_EXP 192
109959: PPUSH
109960: LD_VAR 0 1
109964: PPUSH
109965: LD_VAR 0 3
109969: PPUSH
109970: CALL_OW 1
109974: ST_TO_ADDR
// end ;
109975: LD_VAR 0 4
109979: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
109980: LD_INT 0
109982: PPUSH
// if not mc_bases [ base ] then
109983: LD_EXP 177
109987: PUSH
109988: LD_VAR 0 1
109992: ARRAY
109993: NOT
109994: IFFALSE 109998
// exit ;
109996: GO 110023
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
109998: LD_ADDR_EXP 182
110002: PUSH
110003: LD_EXP 182
110007: PPUSH
110008: LD_VAR 0 1
110012: PPUSH
110013: LD_VAR 0 2
110017: PPUSH
110018: CALL_OW 1
110022: ST_TO_ADDR
// end ;
110023: LD_VAR 0 3
110027: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
110028: LD_INT 0
110030: PPUSH
// if not mc_bases [ base ] then
110031: LD_EXP 177
110035: PUSH
110036: LD_VAR 0 1
110040: ARRAY
110041: NOT
110042: IFFALSE 110046
// exit ;
110044: GO 110083
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
110046: LD_ADDR_EXP 182
110050: PUSH
110051: LD_EXP 182
110055: PPUSH
110056: LD_VAR 0 1
110060: PPUSH
110061: LD_EXP 182
110065: PUSH
110066: LD_VAR 0 1
110070: ARRAY
110071: PUSH
110072: LD_VAR 0 2
110076: UNION
110077: PPUSH
110078: CALL_OW 1
110082: ST_TO_ADDR
// end ;
110083: LD_VAR 0 3
110087: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
110088: LD_INT 0
110090: PPUSH
// if not mc_bases [ base ] then
110091: LD_EXP 177
110095: PUSH
110096: LD_VAR 0 1
110100: ARRAY
110101: NOT
110102: IFFALSE 110106
// exit ;
110104: GO 110131
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
110106: LD_ADDR_EXP 198
110110: PUSH
110111: LD_EXP 198
110115: PPUSH
110116: LD_VAR 0 1
110120: PPUSH
110121: LD_VAR 0 2
110125: PPUSH
110126: CALL_OW 1
110130: ST_TO_ADDR
// end ;
110131: LD_VAR 0 3
110135: RET
// export function MC_InsertProduceList ( base , components ) ; begin
110136: LD_INT 0
110138: PPUSH
// if not mc_bases [ base ] then
110139: LD_EXP 177
110143: PUSH
110144: LD_VAR 0 1
110148: ARRAY
110149: NOT
110150: IFFALSE 110154
// exit ;
110152: GO 110191
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
110154: LD_ADDR_EXP 198
110158: PUSH
110159: LD_EXP 198
110163: PPUSH
110164: LD_VAR 0 1
110168: PPUSH
110169: LD_EXP 198
110173: PUSH
110174: LD_VAR 0 1
110178: ARRAY
110179: PUSH
110180: LD_VAR 0 2
110184: ADD
110185: PPUSH
110186: CALL_OW 1
110190: ST_TO_ADDR
// end ;
110191: LD_VAR 0 3
110195: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
110196: LD_INT 0
110198: PPUSH
// if not mc_bases [ base ] then
110199: LD_EXP 177
110203: PUSH
110204: LD_VAR 0 1
110208: ARRAY
110209: NOT
110210: IFFALSE 110214
// exit ;
110212: GO 110268
// mc_defender := Replace ( mc_defender , base , deflist ) ;
110214: LD_ADDR_EXP 199
110218: PUSH
110219: LD_EXP 199
110223: PPUSH
110224: LD_VAR 0 1
110228: PPUSH
110229: LD_VAR 0 2
110233: PPUSH
110234: CALL_OW 1
110238: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
110239: LD_ADDR_EXP 188
110243: PUSH
110244: LD_EXP 188
110248: PPUSH
110249: LD_VAR 0 1
110253: PPUSH
110254: LD_VAR 0 2
110258: PUSH
110259: LD_INT 0
110261: PLUS
110262: PPUSH
110263: CALL_OW 1
110267: ST_TO_ADDR
// end ;
110268: LD_VAR 0 3
110272: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
110273: LD_INT 0
110275: PPUSH
// if not mc_bases [ base ] then
110276: LD_EXP 177
110280: PUSH
110281: LD_VAR 0 1
110285: ARRAY
110286: NOT
110287: IFFALSE 110291
// exit ;
110289: GO 110316
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
110291: LD_ADDR_EXP 188
110295: PUSH
110296: LD_EXP 188
110300: PPUSH
110301: LD_VAR 0 1
110305: PPUSH
110306: LD_VAR 0 2
110310: PPUSH
110311: CALL_OW 1
110315: ST_TO_ADDR
// end ;
110316: LD_VAR 0 3
110320: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
110321: LD_INT 0
110323: PPUSH
110324: PPUSH
110325: PPUSH
110326: PPUSH
// if not mc_bases [ base ] then
110327: LD_EXP 177
110331: PUSH
110332: LD_VAR 0 1
110336: ARRAY
110337: NOT
110338: IFFALSE 110342
// exit ;
110340: GO 110407
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
110342: LD_ADDR_EXP 197
110346: PUSH
110347: LD_EXP 197
110351: PPUSH
110352: LD_VAR 0 1
110356: PUSH
110357: LD_EXP 197
110361: PUSH
110362: LD_VAR 0 1
110366: ARRAY
110367: PUSH
110368: LD_INT 1
110370: PLUS
110371: PUSH
110372: EMPTY
110373: LIST
110374: LIST
110375: PPUSH
110376: LD_VAR 0 1
110380: PUSH
110381: LD_VAR 0 2
110385: PUSH
110386: LD_VAR 0 3
110390: PUSH
110391: LD_VAR 0 4
110395: PUSH
110396: EMPTY
110397: LIST
110398: LIST
110399: LIST
110400: LIST
110401: PPUSH
110402: CALL 24210 0 3
110406: ST_TO_ADDR
// end ;
110407: LD_VAR 0 5
110411: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
110412: LD_INT 0
110414: PPUSH
// if not mc_bases [ base ] then
110415: LD_EXP 177
110419: PUSH
110420: LD_VAR 0 1
110424: ARRAY
110425: NOT
110426: IFFALSE 110430
// exit ;
110428: GO 110455
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
110430: LD_ADDR_EXP 214
110434: PUSH
110435: LD_EXP 214
110439: PPUSH
110440: LD_VAR 0 1
110444: PPUSH
110445: LD_VAR 0 2
110449: PPUSH
110450: CALL_OW 1
110454: ST_TO_ADDR
// end ;
110455: LD_VAR 0 3
110459: RET
// export function MC_GetMinesField ( base ) ; begin
110460: LD_INT 0
110462: PPUSH
// result := mc_mines [ base ] ;
110463: LD_ADDR_VAR 0 2
110467: PUSH
110468: LD_EXP 190
110472: PUSH
110473: LD_VAR 0 1
110477: ARRAY
110478: ST_TO_ADDR
// end ;
110479: LD_VAR 0 2
110483: RET
// export function MC_GetProduceList ( base ) ; begin
110484: LD_INT 0
110486: PPUSH
// result := mc_produce [ base ] ;
110487: LD_ADDR_VAR 0 2
110491: PUSH
110492: LD_EXP 198
110496: PUSH
110497: LD_VAR 0 1
110501: ARRAY
110502: ST_TO_ADDR
// end ;
110503: LD_VAR 0 2
110507: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
110508: LD_INT 0
110510: PPUSH
110511: PPUSH
// if not mc_bases then
110512: LD_EXP 177
110516: NOT
110517: IFFALSE 110521
// exit ;
110519: GO 110586
// if mc_bases [ base ] then
110521: LD_EXP 177
110525: PUSH
110526: LD_VAR 0 1
110530: ARRAY
110531: IFFALSE 110586
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
110533: LD_ADDR_VAR 0 3
110537: PUSH
110538: LD_EXP 177
110542: PUSH
110543: LD_VAR 0 1
110547: ARRAY
110548: PPUSH
110549: LD_INT 30
110551: PUSH
110552: LD_VAR 0 2
110556: PUSH
110557: EMPTY
110558: LIST
110559: LIST
110560: PPUSH
110561: CALL_OW 72
110565: ST_TO_ADDR
// if result then
110566: LD_VAR 0 3
110570: IFFALSE 110586
// result := result [ 1 ] ;
110572: LD_ADDR_VAR 0 3
110576: PUSH
110577: LD_VAR 0 3
110581: PUSH
110582: LD_INT 1
110584: ARRAY
110585: ST_TO_ADDR
// end ; end ;
110586: LD_VAR 0 3
110590: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
110591: LD_INT 0
110593: PPUSH
110594: PPUSH
// if not mc_bases then
110595: LD_EXP 177
110599: NOT
110600: IFFALSE 110604
// exit ;
110602: GO 110649
// if mc_bases [ base ] then
110604: LD_EXP 177
110608: PUSH
110609: LD_VAR 0 1
110613: ARRAY
110614: IFFALSE 110649
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
110616: LD_ADDR_VAR 0 3
110620: PUSH
110621: LD_EXP 177
110625: PUSH
110626: LD_VAR 0 1
110630: ARRAY
110631: PPUSH
110632: LD_INT 30
110634: PUSH
110635: LD_VAR 0 2
110639: PUSH
110640: EMPTY
110641: LIST
110642: LIST
110643: PPUSH
110644: CALL_OW 72
110648: ST_TO_ADDR
// end ;
110649: LD_VAR 0 3
110653: RET
// export function MC_SetTame ( base , area ) ; begin
110654: LD_INT 0
110656: PPUSH
// if not mc_bases or not base then
110657: LD_EXP 177
110661: NOT
110662: PUSH
110663: LD_VAR 0 1
110667: NOT
110668: OR
110669: IFFALSE 110673
// exit ;
110671: GO 110698
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
110673: LD_ADDR_EXP 205
110677: PUSH
110678: LD_EXP 205
110682: PPUSH
110683: LD_VAR 0 1
110687: PPUSH
110688: LD_VAR 0 2
110692: PPUSH
110693: CALL_OW 1
110697: ST_TO_ADDR
// end ;
110698: LD_VAR 0 3
110702: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
110703: LD_INT 0
110705: PPUSH
110706: PPUSH
// if not mc_bases or not base then
110707: LD_EXP 177
110711: NOT
110712: PUSH
110713: LD_VAR 0 1
110717: NOT
110718: OR
110719: IFFALSE 110723
// exit ;
110721: GO 110825
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
110723: LD_ADDR_VAR 0 4
110727: PUSH
110728: LD_EXP 177
110732: PUSH
110733: LD_VAR 0 1
110737: ARRAY
110738: PPUSH
110739: LD_INT 30
110741: PUSH
110742: LD_VAR 0 2
110746: PUSH
110747: EMPTY
110748: LIST
110749: LIST
110750: PPUSH
110751: CALL_OW 72
110755: ST_TO_ADDR
// if not tmp then
110756: LD_VAR 0 4
110760: NOT
110761: IFFALSE 110765
// exit ;
110763: GO 110825
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
110765: LD_ADDR_EXP 209
110769: PUSH
110770: LD_EXP 209
110774: PPUSH
110775: LD_VAR 0 1
110779: PPUSH
110780: LD_EXP 209
110784: PUSH
110785: LD_VAR 0 1
110789: ARRAY
110790: PPUSH
110791: LD_EXP 209
110795: PUSH
110796: LD_VAR 0 1
110800: ARRAY
110801: PUSH
110802: LD_INT 1
110804: PLUS
110805: PPUSH
110806: LD_VAR 0 4
110810: PUSH
110811: LD_INT 1
110813: ARRAY
110814: PPUSH
110815: CALL_OW 2
110819: PPUSH
110820: CALL_OW 1
110824: ST_TO_ADDR
// end ;
110825: LD_VAR 0 3
110829: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
110830: LD_INT 0
110832: PPUSH
110833: PPUSH
// if not mc_bases or not base or not kinds then
110834: LD_EXP 177
110838: NOT
110839: PUSH
110840: LD_VAR 0 1
110844: NOT
110845: OR
110846: PUSH
110847: LD_VAR 0 2
110851: NOT
110852: OR
110853: IFFALSE 110857
// exit ;
110855: GO 110918
// for i in kinds do
110857: LD_ADDR_VAR 0 4
110861: PUSH
110862: LD_VAR 0 2
110866: PUSH
110867: FOR_IN
110868: IFFALSE 110916
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
110870: LD_ADDR_EXP 211
110874: PUSH
110875: LD_EXP 211
110879: PPUSH
110880: LD_VAR 0 1
110884: PUSH
110885: LD_EXP 211
110889: PUSH
110890: LD_VAR 0 1
110894: ARRAY
110895: PUSH
110896: LD_INT 1
110898: PLUS
110899: PUSH
110900: EMPTY
110901: LIST
110902: LIST
110903: PPUSH
110904: LD_VAR 0 4
110908: PPUSH
110909: CALL 24210 0 3
110913: ST_TO_ADDR
110914: GO 110867
110916: POP
110917: POP
// end ;
110918: LD_VAR 0 3
110922: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
110923: LD_INT 0
110925: PPUSH
// if not mc_bases or not base or not areas then
110926: LD_EXP 177
110930: NOT
110931: PUSH
110932: LD_VAR 0 1
110936: NOT
110937: OR
110938: PUSH
110939: LD_VAR 0 2
110943: NOT
110944: OR
110945: IFFALSE 110949
// exit ;
110947: GO 110974
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
110949: LD_ADDR_EXP 195
110953: PUSH
110954: LD_EXP 195
110958: PPUSH
110959: LD_VAR 0 1
110963: PPUSH
110964: LD_VAR 0 2
110968: PPUSH
110969: CALL_OW 1
110973: ST_TO_ADDR
// end ;
110974: LD_VAR 0 3
110978: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
110979: LD_INT 0
110981: PPUSH
// if not mc_bases or not base or not teleports_exit then
110982: LD_EXP 177
110986: NOT
110987: PUSH
110988: LD_VAR 0 1
110992: NOT
110993: OR
110994: PUSH
110995: LD_VAR 0 2
110999: NOT
111000: OR
111001: IFFALSE 111005
// exit ;
111003: GO 111030
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
111005: LD_ADDR_EXP 212
111009: PUSH
111010: LD_EXP 212
111014: PPUSH
111015: LD_VAR 0 1
111019: PPUSH
111020: LD_VAR 0 2
111024: PPUSH
111025: CALL_OW 1
111029: ST_TO_ADDR
// end ;
111030: LD_VAR 0 3
111034: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
111035: LD_INT 0
111037: PPUSH
111038: PPUSH
111039: PPUSH
// if not mc_bases or not base or not ext_list then
111040: LD_EXP 177
111044: NOT
111045: PUSH
111046: LD_VAR 0 1
111050: NOT
111051: OR
111052: PUSH
111053: LD_VAR 0 5
111057: NOT
111058: OR
111059: IFFALSE 111063
// exit ;
111061: GO 111236
// tmp := GetFacExtXYD ( x , y , d ) ;
111063: LD_ADDR_VAR 0 8
111067: PUSH
111068: LD_VAR 0 2
111072: PPUSH
111073: LD_VAR 0 3
111077: PPUSH
111078: LD_VAR 0 4
111082: PPUSH
111083: CALL 53597 0 3
111087: ST_TO_ADDR
// if not tmp then
111088: LD_VAR 0 8
111092: NOT
111093: IFFALSE 111097
// exit ;
111095: GO 111236
// for i in tmp do
111097: LD_ADDR_VAR 0 7
111101: PUSH
111102: LD_VAR 0 8
111106: PUSH
111107: FOR_IN
111108: IFFALSE 111234
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
111110: LD_ADDR_EXP 182
111114: PUSH
111115: LD_EXP 182
111119: PPUSH
111120: LD_VAR 0 1
111124: PPUSH
111125: LD_EXP 182
111129: PUSH
111130: LD_VAR 0 1
111134: ARRAY
111135: PPUSH
111136: LD_EXP 182
111140: PUSH
111141: LD_VAR 0 1
111145: ARRAY
111146: PUSH
111147: LD_INT 1
111149: PLUS
111150: PPUSH
111151: LD_VAR 0 5
111155: PUSH
111156: LD_INT 1
111158: ARRAY
111159: PUSH
111160: LD_VAR 0 7
111164: PUSH
111165: LD_INT 1
111167: ARRAY
111168: PUSH
111169: LD_VAR 0 7
111173: PUSH
111174: LD_INT 2
111176: ARRAY
111177: PUSH
111178: LD_VAR 0 7
111182: PUSH
111183: LD_INT 3
111185: ARRAY
111186: PUSH
111187: EMPTY
111188: LIST
111189: LIST
111190: LIST
111191: LIST
111192: PPUSH
111193: CALL_OW 2
111197: PPUSH
111198: CALL_OW 1
111202: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
111203: LD_ADDR_VAR 0 5
111207: PUSH
111208: LD_VAR 0 5
111212: PPUSH
111213: LD_INT 1
111215: PPUSH
111216: CALL_OW 3
111220: ST_TO_ADDR
// if not ext_list then
111221: LD_VAR 0 5
111225: NOT
111226: IFFALSE 111232
// exit ;
111228: POP
111229: POP
111230: GO 111236
// end ;
111232: GO 111107
111234: POP
111235: POP
// end ;
111236: LD_VAR 0 6
111240: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
111241: LD_INT 0
111243: PPUSH
// if not mc_bases or not base or not weapon_list then
111244: LD_EXP 177
111248: NOT
111249: PUSH
111250: LD_VAR 0 1
111254: NOT
111255: OR
111256: PUSH
111257: LD_VAR 0 2
111261: NOT
111262: OR
111263: IFFALSE 111267
// exit ;
111265: GO 111292
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
111267: LD_ADDR_EXP 216
111271: PUSH
111272: LD_EXP 216
111276: PPUSH
111277: LD_VAR 0 1
111281: PPUSH
111282: LD_VAR 0 2
111286: PPUSH
111287: CALL_OW 1
111291: ST_TO_ADDR
// end ;
111292: LD_VAR 0 3
111296: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
111297: LD_INT 0
111299: PPUSH
// if not mc_bases or not base or not tech_list then
111300: LD_EXP 177
111304: NOT
111305: PUSH
111306: LD_VAR 0 1
111310: NOT
111311: OR
111312: PUSH
111313: LD_VAR 0 2
111317: NOT
111318: OR
111319: IFFALSE 111323
// exit ;
111321: GO 111348
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
111323: LD_ADDR_EXP 204
111327: PUSH
111328: LD_EXP 204
111332: PPUSH
111333: LD_VAR 0 1
111337: PPUSH
111338: LD_VAR 0 2
111342: PPUSH
111343: CALL_OW 1
111347: ST_TO_ADDR
// end ;
111348: LD_VAR 0 3
111352: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
111353: LD_INT 0
111355: PPUSH
// if not mc_bases or not parking_area or not base then
111356: LD_EXP 177
111360: NOT
111361: PUSH
111362: LD_VAR 0 2
111366: NOT
111367: OR
111368: PUSH
111369: LD_VAR 0 1
111373: NOT
111374: OR
111375: IFFALSE 111379
// exit ;
111377: GO 111404
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
111379: LD_ADDR_EXP 201
111383: PUSH
111384: LD_EXP 201
111388: PPUSH
111389: LD_VAR 0 1
111393: PPUSH
111394: LD_VAR 0 2
111398: PPUSH
111399: CALL_OW 1
111403: ST_TO_ADDR
// end ;
111404: LD_VAR 0 3
111408: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
111409: LD_INT 0
111411: PPUSH
// if not mc_bases or not base or not scan_area then
111412: LD_EXP 177
111416: NOT
111417: PUSH
111418: LD_VAR 0 1
111422: NOT
111423: OR
111424: PUSH
111425: LD_VAR 0 2
111429: NOT
111430: OR
111431: IFFALSE 111435
// exit ;
111433: GO 111460
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
111435: LD_ADDR_EXP 202
111439: PUSH
111440: LD_EXP 202
111444: PPUSH
111445: LD_VAR 0 1
111449: PPUSH
111450: LD_VAR 0 2
111454: PPUSH
111455: CALL_OW 1
111459: ST_TO_ADDR
// end ;
111460: LD_VAR 0 3
111464: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
111465: LD_INT 0
111467: PPUSH
111468: PPUSH
// if not mc_bases or not base then
111469: LD_EXP 177
111473: NOT
111474: PUSH
111475: LD_VAR 0 1
111479: NOT
111480: OR
111481: IFFALSE 111485
// exit ;
111483: GO 111549
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
111485: LD_ADDR_VAR 0 3
111489: PUSH
111490: LD_INT 1
111492: PUSH
111493: LD_INT 2
111495: PUSH
111496: LD_INT 3
111498: PUSH
111499: LD_INT 4
111501: PUSH
111502: LD_INT 11
111504: PUSH
111505: EMPTY
111506: LIST
111507: LIST
111508: LIST
111509: LIST
111510: LIST
111511: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
111512: LD_ADDR_EXP 204
111516: PUSH
111517: LD_EXP 204
111521: PPUSH
111522: LD_VAR 0 1
111526: PPUSH
111527: LD_EXP 204
111531: PUSH
111532: LD_VAR 0 1
111536: ARRAY
111537: PUSH
111538: LD_VAR 0 3
111542: DIFF
111543: PPUSH
111544: CALL_OW 1
111548: ST_TO_ADDR
// end ;
111549: LD_VAR 0 2
111553: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
111554: LD_INT 0
111556: PPUSH
// result := mc_vehicles [ base ] ;
111557: LD_ADDR_VAR 0 3
111561: PUSH
111562: LD_EXP 196
111566: PUSH
111567: LD_VAR 0 1
111571: ARRAY
111572: ST_TO_ADDR
// if onlyCombat then
111573: LD_VAR 0 2
111577: IFFALSE 111755
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
111579: LD_ADDR_VAR 0 3
111583: PUSH
111584: LD_VAR 0 3
111588: PUSH
111589: LD_VAR 0 3
111593: PPUSH
111594: LD_INT 2
111596: PUSH
111597: LD_INT 34
111599: PUSH
111600: LD_INT 12
111602: PUSH
111603: EMPTY
111604: LIST
111605: LIST
111606: PUSH
111607: LD_INT 34
111609: PUSH
111610: LD_INT 51
111612: PUSH
111613: EMPTY
111614: LIST
111615: LIST
111616: PUSH
111617: LD_INT 34
111619: PUSH
111620: LD_EXP 157
111624: PUSH
111625: EMPTY
111626: LIST
111627: LIST
111628: PUSH
111629: LD_INT 34
111631: PUSH
111632: LD_INT 32
111634: PUSH
111635: EMPTY
111636: LIST
111637: LIST
111638: PUSH
111639: LD_INT 34
111641: PUSH
111642: LD_INT 13
111644: PUSH
111645: EMPTY
111646: LIST
111647: LIST
111648: PUSH
111649: LD_INT 34
111651: PUSH
111652: LD_INT 52
111654: PUSH
111655: EMPTY
111656: LIST
111657: LIST
111658: PUSH
111659: LD_INT 34
111661: PUSH
111662: LD_EXP 162
111666: PUSH
111667: EMPTY
111668: LIST
111669: LIST
111670: PUSH
111671: LD_INT 34
111673: PUSH
111674: LD_INT 14
111676: PUSH
111677: EMPTY
111678: LIST
111679: LIST
111680: PUSH
111681: LD_INT 34
111683: PUSH
111684: LD_INT 53
111686: PUSH
111687: EMPTY
111688: LIST
111689: LIST
111690: PUSH
111691: LD_INT 34
111693: PUSH
111694: LD_EXP 156
111698: PUSH
111699: EMPTY
111700: LIST
111701: LIST
111702: PUSH
111703: LD_INT 34
111705: PUSH
111706: LD_INT 31
111708: PUSH
111709: EMPTY
111710: LIST
111711: LIST
111712: PUSH
111713: LD_INT 34
111715: PUSH
111716: LD_INT 48
111718: PUSH
111719: EMPTY
111720: LIST
111721: LIST
111722: PUSH
111723: LD_INT 34
111725: PUSH
111726: LD_INT 8
111728: PUSH
111729: EMPTY
111730: LIST
111731: LIST
111732: PUSH
111733: EMPTY
111734: LIST
111735: LIST
111736: LIST
111737: LIST
111738: LIST
111739: LIST
111740: LIST
111741: LIST
111742: LIST
111743: LIST
111744: LIST
111745: LIST
111746: LIST
111747: LIST
111748: PPUSH
111749: CALL_OW 72
111753: DIFF
111754: ST_TO_ADDR
// end ; end_of_file
111755: LD_VAR 0 3
111759: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
111760: LD_INT 0
111762: PPUSH
111763: PPUSH
111764: PPUSH
// if not mc_bases or not skirmish then
111765: LD_EXP 177
111769: NOT
111770: PUSH
111771: LD_EXP 175
111775: NOT
111776: OR
111777: IFFALSE 111781
// exit ;
111779: GO 111946
// for i = 1 to mc_bases do
111781: LD_ADDR_VAR 0 4
111785: PUSH
111786: DOUBLE
111787: LD_INT 1
111789: DEC
111790: ST_TO_ADDR
111791: LD_EXP 177
111795: PUSH
111796: FOR_TO
111797: IFFALSE 111944
// begin if sci in mc_bases [ i ] then
111799: LD_VAR 0 2
111803: PUSH
111804: LD_EXP 177
111808: PUSH
111809: LD_VAR 0 4
111813: ARRAY
111814: IN
111815: IFFALSE 111942
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
111817: LD_ADDR_EXP 206
111821: PUSH
111822: LD_EXP 206
111826: PPUSH
111827: LD_VAR 0 4
111831: PUSH
111832: LD_EXP 206
111836: PUSH
111837: LD_VAR 0 4
111841: ARRAY
111842: PUSH
111843: LD_INT 1
111845: PLUS
111846: PUSH
111847: EMPTY
111848: LIST
111849: LIST
111850: PPUSH
111851: LD_VAR 0 1
111855: PPUSH
111856: CALL 24210 0 3
111860: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
111861: LD_ADDR_VAR 0 5
111865: PUSH
111866: LD_EXP 177
111870: PUSH
111871: LD_VAR 0 4
111875: ARRAY
111876: PPUSH
111877: LD_INT 2
111879: PUSH
111880: LD_INT 30
111882: PUSH
111883: LD_INT 0
111885: PUSH
111886: EMPTY
111887: LIST
111888: LIST
111889: PUSH
111890: LD_INT 30
111892: PUSH
111893: LD_INT 1
111895: PUSH
111896: EMPTY
111897: LIST
111898: LIST
111899: PUSH
111900: EMPTY
111901: LIST
111902: LIST
111903: LIST
111904: PPUSH
111905: CALL_OW 72
111909: PPUSH
111910: LD_VAR 0 1
111914: PPUSH
111915: CALL_OW 74
111919: ST_TO_ADDR
// if tmp then
111920: LD_VAR 0 5
111924: IFFALSE 111940
// ComStandNearbyBuilding ( ape , tmp ) ;
111926: LD_VAR 0 1
111930: PPUSH
111931: LD_VAR 0 5
111935: PPUSH
111936: CALL 20788 0 2
// break ;
111940: GO 111944
// end ; end ;
111942: GO 111796
111944: POP
111945: POP
// end ;
111946: LD_VAR 0 3
111950: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
111951: LD_INT 0
111953: PPUSH
111954: PPUSH
111955: PPUSH
// if not mc_bases or not skirmish then
111956: LD_EXP 177
111960: NOT
111961: PUSH
111962: LD_EXP 175
111966: NOT
111967: OR
111968: IFFALSE 111972
// exit ;
111970: GO 112061
// for i = 1 to mc_bases do
111972: LD_ADDR_VAR 0 4
111976: PUSH
111977: DOUBLE
111978: LD_INT 1
111980: DEC
111981: ST_TO_ADDR
111982: LD_EXP 177
111986: PUSH
111987: FOR_TO
111988: IFFALSE 112059
// begin if building in mc_busy_turret_list [ i ] then
111990: LD_VAR 0 1
111994: PUSH
111995: LD_EXP 187
111999: PUSH
112000: LD_VAR 0 4
112004: ARRAY
112005: IN
112006: IFFALSE 112057
// begin tmp := mc_busy_turret_list [ i ] diff building ;
112008: LD_ADDR_VAR 0 5
112012: PUSH
112013: LD_EXP 187
112017: PUSH
112018: LD_VAR 0 4
112022: ARRAY
112023: PUSH
112024: LD_VAR 0 1
112028: DIFF
112029: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
112030: LD_ADDR_EXP 187
112034: PUSH
112035: LD_EXP 187
112039: PPUSH
112040: LD_VAR 0 4
112044: PPUSH
112045: LD_VAR 0 5
112049: PPUSH
112050: CALL_OW 1
112054: ST_TO_ADDR
// break ;
112055: GO 112059
// end ; end ;
112057: GO 111987
112059: POP
112060: POP
// end ;
112061: LD_VAR 0 3
112065: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
112066: LD_INT 0
112068: PPUSH
112069: PPUSH
112070: PPUSH
// if not mc_bases or not skirmish then
112071: LD_EXP 177
112075: NOT
112076: PUSH
112077: LD_EXP 175
112081: NOT
112082: OR
112083: IFFALSE 112087
// exit ;
112085: GO 112286
// for i = 1 to mc_bases do
112087: LD_ADDR_VAR 0 5
112091: PUSH
112092: DOUBLE
112093: LD_INT 1
112095: DEC
112096: ST_TO_ADDR
112097: LD_EXP 177
112101: PUSH
112102: FOR_TO
112103: IFFALSE 112284
// if building in mc_bases [ i ] then
112105: LD_VAR 0 1
112109: PUSH
112110: LD_EXP 177
112114: PUSH
112115: LD_VAR 0 5
112119: ARRAY
112120: IN
112121: IFFALSE 112282
// begin tmp := mc_bases [ i ] diff building ;
112123: LD_ADDR_VAR 0 6
112127: PUSH
112128: LD_EXP 177
112132: PUSH
112133: LD_VAR 0 5
112137: ARRAY
112138: PUSH
112139: LD_VAR 0 1
112143: DIFF
112144: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
112145: LD_ADDR_EXP 177
112149: PUSH
112150: LD_EXP 177
112154: PPUSH
112155: LD_VAR 0 5
112159: PPUSH
112160: LD_VAR 0 6
112164: PPUSH
112165: CALL_OW 1
112169: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
112170: LD_VAR 0 1
112174: PUSH
112175: LD_EXP 185
112179: PUSH
112180: LD_VAR 0 5
112184: ARRAY
112185: IN
112186: IFFALSE 112225
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
112188: LD_ADDR_EXP 185
112192: PUSH
112193: LD_EXP 185
112197: PPUSH
112198: LD_VAR 0 5
112202: PPUSH
112203: LD_EXP 185
112207: PUSH
112208: LD_VAR 0 5
112212: ARRAY
112213: PUSH
112214: LD_VAR 0 1
112218: DIFF
112219: PPUSH
112220: CALL_OW 1
112224: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
112225: LD_VAR 0 1
112229: PUSH
112230: LD_EXP 186
112234: PUSH
112235: LD_VAR 0 5
112239: ARRAY
112240: IN
112241: IFFALSE 112280
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
112243: LD_ADDR_EXP 186
112247: PUSH
112248: LD_EXP 186
112252: PPUSH
112253: LD_VAR 0 5
112257: PPUSH
112258: LD_EXP 186
112262: PUSH
112263: LD_VAR 0 5
112267: ARRAY
112268: PUSH
112269: LD_VAR 0 1
112273: DIFF
112274: PPUSH
112275: CALL_OW 1
112279: ST_TO_ADDR
// break ;
112280: GO 112284
// end ;
112282: GO 112102
112284: POP
112285: POP
// end ;
112286: LD_VAR 0 4
112290: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
112291: LD_INT 0
112293: PPUSH
112294: PPUSH
112295: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
112296: LD_EXP 177
112300: NOT
112301: PUSH
112302: LD_EXP 175
112306: NOT
112307: OR
112308: PUSH
112309: LD_VAR 0 3
112313: PUSH
112314: LD_EXP 203
112318: IN
112319: NOT
112320: OR
112321: IFFALSE 112325
// exit ;
112323: GO 112448
// for i = 1 to mc_vehicles do
112325: LD_ADDR_VAR 0 6
112329: PUSH
112330: DOUBLE
112331: LD_INT 1
112333: DEC
112334: ST_TO_ADDR
112335: LD_EXP 196
112339: PUSH
112340: FOR_TO
112341: IFFALSE 112446
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
112343: LD_VAR 0 2
112347: PUSH
112348: LD_EXP 196
112352: PUSH
112353: LD_VAR 0 6
112357: ARRAY
112358: IN
112359: PUSH
112360: LD_VAR 0 1
112364: PUSH
112365: LD_EXP 196
112369: PUSH
112370: LD_VAR 0 6
112374: ARRAY
112375: IN
112376: OR
112377: IFFALSE 112444
// begin tmp := mc_vehicles [ i ] diff old ;
112379: LD_ADDR_VAR 0 7
112383: PUSH
112384: LD_EXP 196
112388: PUSH
112389: LD_VAR 0 6
112393: ARRAY
112394: PUSH
112395: LD_VAR 0 2
112399: DIFF
112400: ST_TO_ADDR
// tmp := tmp diff new ;
112401: LD_ADDR_VAR 0 7
112405: PUSH
112406: LD_VAR 0 7
112410: PUSH
112411: LD_VAR 0 1
112415: DIFF
112416: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
112417: LD_ADDR_EXP 196
112421: PUSH
112422: LD_EXP 196
112426: PPUSH
112427: LD_VAR 0 6
112431: PPUSH
112432: LD_VAR 0 7
112436: PPUSH
112437: CALL_OW 1
112441: ST_TO_ADDR
// break ;
112442: GO 112446
// end ;
112444: GO 112340
112446: POP
112447: POP
// end ;
112448: LD_VAR 0 5
112452: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
112453: LD_INT 0
112455: PPUSH
112456: PPUSH
112457: PPUSH
112458: PPUSH
// if not mc_bases or not skirmish then
112459: LD_EXP 177
112463: NOT
112464: PUSH
112465: LD_EXP 175
112469: NOT
112470: OR
112471: IFFALSE 112475
// exit ;
112473: GO 112867
// side := GetSide ( vehicle ) ;
112475: LD_ADDR_VAR 0 5
112479: PUSH
112480: LD_VAR 0 1
112484: PPUSH
112485: CALL_OW 255
112489: ST_TO_ADDR
// for i = 1 to mc_bases do
112490: LD_ADDR_VAR 0 4
112494: PUSH
112495: DOUBLE
112496: LD_INT 1
112498: DEC
112499: ST_TO_ADDR
112500: LD_EXP 177
112504: PUSH
112505: FOR_TO
112506: IFFALSE 112865
// begin if factory in mc_bases [ i ] then
112508: LD_VAR 0 2
112512: PUSH
112513: LD_EXP 177
112517: PUSH
112518: LD_VAR 0 4
112522: ARRAY
112523: IN
112524: IFFALSE 112863
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ar_crane , ru_siberium_rocket , us_siberium_rocket ] then
112526: LD_EXP 199
112530: PUSH
112531: LD_VAR 0 4
112535: ARRAY
112536: PUSH
112537: LD_EXP 188
112541: PUSH
112542: LD_VAR 0 4
112546: ARRAY
112547: LESS
112548: PUSH
112549: LD_VAR 0 1
112553: PPUSH
112554: CALL_OW 264
112558: PUSH
112559: LD_INT 31
112561: PUSH
112562: LD_INT 32
112564: PUSH
112565: LD_INT 51
112567: PUSH
112568: LD_EXP 157
112572: PUSH
112573: LD_INT 12
112575: PUSH
112576: LD_INT 30
112578: PUSH
112579: LD_EXP 156
112583: PUSH
112584: LD_INT 11
112586: PUSH
112587: LD_INT 53
112589: PUSH
112590: LD_INT 14
112592: PUSH
112593: LD_EXP 160
112597: PUSH
112598: LD_INT 29
112600: PUSH
112601: LD_EXP 158
112605: PUSH
112606: LD_INT 13
112608: PUSH
112609: LD_INT 52
112611: PUSH
112612: LD_EXP 162
112616: PUSH
112617: LD_INT 48
112619: PUSH
112620: LD_INT 8
112622: PUSH
112623: EMPTY
112624: LIST
112625: LIST
112626: LIST
112627: LIST
112628: LIST
112629: LIST
112630: LIST
112631: LIST
112632: LIST
112633: LIST
112634: LIST
112635: LIST
112636: LIST
112637: LIST
112638: LIST
112639: LIST
112640: LIST
112641: LIST
112642: IN
112643: NOT
112644: AND
112645: IFFALSE 112693
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
112647: LD_ADDR_EXP 199
112651: PUSH
112652: LD_EXP 199
112656: PPUSH
112657: LD_VAR 0 4
112661: PUSH
112662: LD_EXP 199
112666: PUSH
112667: LD_VAR 0 4
112671: ARRAY
112672: PUSH
112673: LD_INT 1
112675: PLUS
112676: PUSH
112677: EMPTY
112678: LIST
112679: LIST
112680: PPUSH
112681: LD_VAR 0 1
112685: PPUSH
112686: CALL 24210 0 3
112690: ST_TO_ADDR
112691: GO 112737
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
112693: LD_ADDR_EXP 196
112697: PUSH
112698: LD_EXP 196
112702: PPUSH
112703: LD_VAR 0 4
112707: PUSH
112708: LD_EXP 196
112712: PUSH
112713: LD_VAR 0 4
112717: ARRAY
112718: PUSH
112719: LD_INT 1
112721: PLUS
112722: PUSH
112723: EMPTY
112724: LIST
112725: LIST
112726: PPUSH
112727: LD_VAR 0 1
112731: PPUSH
112732: CALL 24210 0 3
112736: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
112737: LD_VAR 0 1
112741: PPUSH
112742: CALL_OW 263
112746: PUSH
112747: LD_INT 2
112749: EQUAL
112750: IFFALSE 112779
// begin repeat wait ( 0 0$3 ) ;
112752: LD_INT 105
112754: PPUSH
112755: CALL_OW 67
// Connect ( vehicle ) ;
112759: LD_VAR 0 1
112763: PPUSH
112764: CALL 27181 0 1
// until IsControledBy ( vehicle ) ;
112768: LD_VAR 0 1
112772: PPUSH
112773: CALL_OW 312
112777: IFFALSE 112752
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
112779: LD_VAR 0 1
112783: PPUSH
112784: LD_EXP 201
112788: PUSH
112789: LD_VAR 0 4
112793: ARRAY
112794: PPUSH
112795: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
112799: LD_VAR 0 1
112803: PPUSH
112804: CALL_OW 263
112808: PUSH
112809: LD_INT 1
112811: NONEQUAL
112812: IFFALSE 112816
// break ;
112814: GO 112865
// repeat wait ( 0 0$1 ) ;
112816: LD_INT 35
112818: PPUSH
112819: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
112823: LD_VAR 0 1
112827: PPUSH
112828: LD_EXP 201
112832: PUSH
112833: LD_VAR 0 4
112837: ARRAY
112838: PPUSH
112839: CALL_OW 308
112843: IFFALSE 112816
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
112845: LD_VAR 0 1
112849: PPUSH
112850: CALL_OW 311
112854: PPUSH
112855: CALL_OW 121
// exit ;
112859: POP
112860: POP
112861: GO 112867
// end ; end ;
112863: GO 112505
112865: POP
112866: POP
// end ;
112867: LD_VAR 0 3
112871: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
112872: LD_INT 0
112874: PPUSH
112875: PPUSH
112876: PPUSH
112877: PPUSH
// if not mc_bases or not skirmish then
112878: LD_EXP 177
112882: NOT
112883: PUSH
112884: LD_EXP 175
112888: NOT
112889: OR
112890: IFFALSE 112894
// exit ;
112892: GO 113247
// repeat wait ( 0 0$1 ) ;
112894: LD_INT 35
112896: PPUSH
112897: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
112901: LD_VAR 0 2
112905: PPUSH
112906: LD_VAR 0 3
112910: PPUSH
112911: CALL_OW 284
112915: IFFALSE 112894
// if GetResourceTypeXY ( x , y ) = mat_artefact then
112917: LD_VAR 0 2
112921: PPUSH
112922: LD_VAR 0 3
112926: PPUSH
112927: CALL_OW 283
112931: PUSH
112932: LD_INT 4
112934: EQUAL
112935: IFFALSE 112939
// exit ;
112937: GO 113247
// for i = 1 to mc_bases do
112939: LD_ADDR_VAR 0 7
112943: PUSH
112944: DOUBLE
112945: LD_INT 1
112947: DEC
112948: ST_TO_ADDR
112949: LD_EXP 177
112953: PUSH
112954: FOR_TO
112955: IFFALSE 113245
// begin if mc_crates_area [ i ] then
112957: LD_EXP 195
112961: PUSH
112962: LD_VAR 0 7
112966: ARRAY
112967: IFFALSE 113078
// for j in mc_crates_area [ i ] do
112969: LD_ADDR_VAR 0 8
112973: PUSH
112974: LD_EXP 195
112978: PUSH
112979: LD_VAR 0 7
112983: ARRAY
112984: PUSH
112985: FOR_IN
112986: IFFALSE 113076
// if InArea ( x , y , j ) then
112988: LD_VAR 0 2
112992: PPUSH
112993: LD_VAR 0 3
112997: PPUSH
112998: LD_VAR 0 8
113002: PPUSH
113003: CALL_OW 309
113007: IFFALSE 113074
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
113009: LD_ADDR_EXP 193
113013: PUSH
113014: LD_EXP 193
113018: PPUSH
113019: LD_VAR 0 7
113023: PUSH
113024: LD_EXP 193
113028: PUSH
113029: LD_VAR 0 7
113033: ARRAY
113034: PUSH
113035: LD_INT 1
113037: PLUS
113038: PUSH
113039: EMPTY
113040: LIST
113041: LIST
113042: PPUSH
113043: LD_VAR 0 4
113047: PUSH
113048: LD_VAR 0 2
113052: PUSH
113053: LD_VAR 0 3
113057: PUSH
113058: EMPTY
113059: LIST
113060: LIST
113061: LIST
113062: PPUSH
113063: CALL 24210 0 3
113067: ST_TO_ADDR
// exit ;
113068: POP
113069: POP
113070: POP
113071: POP
113072: GO 113247
// end ;
113074: GO 112985
113076: POP
113077: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
113078: LD_ADDR_VAR 0 9
113082: PUSH
113083: LD_EXP 177
113087: PUSH
113088: LD_VAR 0 7
113092: ARRAY
113093: PPUSH
113094: LD_INT 2
113096: PUSH
113097: LD_INT 30
113099: PUSH
113100: LD_INT 0
113102: PUSH
113103: EMPTY
113104: LIST
113105: LIST
113106: PUSH
113107: LD_INT 30
113109: PUSH
113110: LD_INT 1
113112: PUSH
113113: EMPTY
113114: LIST
113115: LIST
113116: PUSH
113117: EMPTY
113118: LIST
113119: LIST
113120: LIST
113121: PPUSH
113122: CALL_OW 72
113126: ST_TO_ADDR
// if not depot then
113127: LD_VAR 0 9
113131: NOT
113132: IFFALSE 113136
// continue ;
113134: GO 112954
// for j in depot do
113136: LD_ADDR_VAR 0 8
113140: PUSH
113141: LD_VAR 0 9
113145: PUSH
113146: FOR_IN
113147: IFFALSE 113241
// if GetDistUnitXY ( j , x , y ) < 30 then
113149: LD_VAR 0 8
113153: PPUSH
113154: LD_VAR 0 2
113158: PPUSH
113159: LD_VAR 0 3
113163: PPUSH
113164: CALL_OW 297
113168: PUSH
113169: LD_INT 30
113171: LESS
113172: IFFALSE 113239
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
113174: LD_ADDR_EXP 193
113178: PUSH
113179: LD_EXP 193
113183: PPUSH
113184: LD_VAR 0 7
113188: PUSH
113189: LD_EXP 193
113193: PUSH
113194: LD_VAR 0 7
113198: ARRAY
113199: PUSH
113200: LD_INT 1
113202: PLUS
113203: PUSH
113204: EMPTY
113205: LIST
113206: LIST
113207: PPUSH
113208: LD_VAR 0 4
113212: PUSH
113213: LD_VAR 0 2
113217: PUSH
113218: LD_VAR 0 3
113222: PUSH
113223: EMPTY
113224: LIST
113225: LIST
113226: LIST
113227: PPUSH
113228: CALL 24210 0 3
113232: ST_TO_ADDR
// exit ;
113233: POP
113234: POP
113235: POP
113236: POP
113237: GO 113247
// end ;
113239: GO 113146
113241: POP
113242: POP
// end ;
113243: GO 112954
113245: POP
113246: POP
// end ;
113247: LD_VAR 0 6
113251: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
113252: LD_INT 0
113254: PPUSH
113255: PPUSH
113256: PPUSH
113257: PPUSH
// if not mc_bases or not skirmish then
113258: LD_EXP 177
113262: NOT
113263: PUSH
113264: LD_EXP 175
113268: NOT
113269: OR
113270: IFFALSE 113274
// exit ;
113272: GO 113551
// side := GetSide ( lab ) ;
113274: LD_ADDR_VAR 0 4
113278: PUSH
113279: LD_VAR 0 2
113283: PPUSH
113284: CALL_OW 255
113288: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
113289: LD_VAR 0 4
113293: PUSH
113294: LD_EXP 203
113298: IN
113299: NOT
113300: PUSH
113301: LD_EXP 204
113305: NOT
113306: OR
113307: PUSH
113308: LD_EXP 177
113312: NOT
113313: OR
113314: IFFALSE 113318
// exit ;
113316: GO 113551
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
113318: LD_ADDR_EXP 204
113322: PUSH
113323: LD_EXP 204
113327: PPUSH
113328: LD_VAR 0 4
113332: PPUSH
113333: LD_EXP 204
113337: PUSH
113338: LD_VAR 0 4
113342: ARRAY
113343: PUSH
113344: LD_VAR 0 1
113348: DIFF
113349: PPUSH
113350: CALL_OW 1
113354: ST_TO_ADDR
// for i = 1 to mc_bases do
113355: LD_ADDR_VAR 0 5
113359: PUSH
113360: DOUBLE
113361: LD_INT 1
113363: DEC
113364: ST_TO_ADDR
113365: LD_EXP 177
113369: PUSH
113370: FOR_TO
113371: IFFALSE 113549
// begin if lab in mc_bases [ i ] then
113373: LD_VAR 0 2
113377: PUSH
113378: LD_EXP 177
113382: PUSH
113383: LD_VAR 0 5
113387: ARRAY
113388: IN
113389: IFFALSE 113547
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
113391: LD_VAR 0 1
113395: PUSH
113396: LD_INT 11
113398: PUSH
113399: LD_INT 4
113401: PUSH
113402: LD_INT 3
113404: PUSH
113405: LD_INT 2
113407: PUSH
113408: EMPTY
113409: LIST
113410: LIST
113411: LIST
113412: LIST
113413: IN
113414: PUSH
113415: LD_EXP 207
113419: PUSH
113420: LD_VAR 0 5
113424: ARRAY
113425: AND
113426: IFFALSE 113547
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
113428: LD_ADDR_VAR 0 6
113432: PUSH
113433: LD_EXP 207
113437: PUSH
113438: LD_VAR 0 5
113442: ARRAY
113443: PUSH
113444: LD_INT 1
113446: ARRAY
113447: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
113448: LD_ADDR_EXP 207
113452: PUSH
113453: LD_EXP 207
113457: PPUSH
113458: LD_VAR 0 5
113462: PPUSH
113463: EMPTY
113464: PPUSH
113465: CALL_OW 1
113469: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
113470: LD_VAR 0 6
113474: PPUSH
113475: LD_INT 0
113477: PPUSH
113478: CALL_OW 109
// ComExitBuilding ( tmp ) ;
113482: LD_VAR 0 6
113486: PPUSH
113487: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
113491: LD_ADDR_EXP 206
113495: PUSH
113496: LD_EXP 206
113500: PPUSH
113501: LD_VAR 0 5
113505: PPUSH
113506: LD_EXP 206
113510: PUSH
113511: LD_VAR 0 5
113515: ARRAY
113516: PPUSH
113517: LD_INT 1
113519: PPUSH
113520: LD_VAR 0 6
113524: PPUSH
113525: CALL_OW 2
113529: PPUSH
113530: CALL_OW 1
113534: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
113535: LD_VAR 0 5
113539: PPUSH
113540: LD_INT 112
113542: PPUSH
113543: CALL 90070 0 2
// end ; end ; end ;
113547: GO 113370
113549: POP
113550: POP
// end ;
113551: LD_VAR 0 3
113555: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
113556: LD_INT 0
113558: PPUSH
113559: PPUSH
113560: PPUSH
113561: PPUSH
113562: PPUSH
113563: PPUSH
113564: PPUSH
113565: PPUSH
// if not mc_bases or not skirmish then
113566: LD_EXP 177
113570: NOT
113571: PUSH
113572: LD_EXP 175
113576: NOT
113577: OR
113578: IFFALSE 113582
// exit ;
113580: GO 114953
// for i = 1 to mc_bases do
113582: LD_ADDR_VAR 0 3
113586: PUSH
113587: DOUBLE
113588: LD_INT 1
113590: DEC
113591: ST_TO_ADDR
113592: LD_EXP 177
113596: PUSH
113597: FOR_TO
113598: IFFALSE 114951
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
113600: LD_VAR 0 1
113604: PUSH
113605: LD_EXP 177
113609: PUSH
113610: LD_VAR 0 3
113614: ARRAY
113615: IN
113616: PUSH
113617: LD_VAR 0 1
113621: PUSH
113622: LD_EXP 184
113626: PUSH
113627: LD_VAR 0 3
113631: ARRAY
113632: IN
113633: OR
113634: PUSH
113635: LD_VAR 0 1
113639: PUSH
113640: LD_EXP 199
113644: PUSH
113645: LD_VAR 0 3
113649: ARRAY
113650: IN
113651: OR
113652: PUSH
113653: LD_VAR 0 1
113657: PUSH
113658: LD_EXP 196
113662: PUSH
113663: LD_VAR 0 3
113667: ARRAY
113668: IN
113669: OR
113670: PUSH
113671: LD_VAR 0 1
113675: PUSH
113676: LD_EXP 206
113680: PUSH
113681: LD_VAR 0 3
113685: ARRAY
113686: IN
113687: OR
113688: PUSH
113689: LD_VAR 0 1
113693: PUSH
113694: LD_EXP 207
113698: PUSH
113699: LD_VAR 0 3
113703: ARRAY
113704: IN
113705: OR
113706: IFFALSE 114949
// begin if un in mc_ape [ i ] then
113708: LD_VAR 0 1
113712: PUSH
113713: LD_EXP 206
113717: PUSH
113718: LD_VAR 0 3
113722: ARRAY
113723: IN
113724: IFFALSE 113763
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
113726: LD_ADDR_EXP 206
113730: PUSH
113731: LD_EXP 206
113735: PPUSH
113736: LD_VAR 0 3
113740: PPUSH
113741: LD_EXP 206
113745: PUSH
113746: LD_VAR 0 3
113750: ARRAY
113751: PUSH
113752: LD_VAR 0 1
113756: DIFF
113757: PPUSH
113758: CALL_OW 1
113762: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
113763: LD_VAR 0 1
113767: PUSH
113768: LD_EXP 207
113772: PUSH
113773: LD_VAR 0 3
113777: ARRAY
113778: IN
113779: IFFALSE 113803
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
113781: LD_ADDR_EXP 207
113785: PUSH
113786: LD_EXP 207
113790: PPUSH
113791: LD_VAR 0 3
113795: PPUSH
113796: EMPTY
113797: PPUSH
113798: CALL_OW 1
113802: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane , ar_control_tower ] ) then
113803: LD_VAR 0 1
113807: PPUSH
113808: CALL_OW 247
113812: PUSH
113813: LD_INT 2
113815: EQUAL
113816: PUSH
113817: LD_VAR 0 1
113821: PPUSH
113822: CALL_OW 110
113826: PUSH
113827: LD_INT 20
113829: EQUAL
113830: PUSH
113831: LD_VAR 0 1
113835: PUSH
113836: LD_EXP 199
113840: PUSH
113841: LD_VAR 0 3
113845: ARRAY
113846: IN
113847: OR
113848: PUSH
113849: LD_VAR 0 1
113853: PPUSH
113854: CALL_OW 264
113858: PUSH
113859: LD_INT 12
113861: PUSH
113862: LD_INT 51
113864: PUSH
113865: LD_EXP 157
113869: PUSH
113870: LD_INT 32
113872: PUSH
113873: LD_INT 13
113875: PUSH
113876: LD_INT 52
113878: PUSH
113879: LD_INT 31
113881: PUSH
113882: EMPTY
113883: LIST
113884: LIST
113885: LIST
113886: LIST
113887: LIST
113888: LIST
113889: LIST
113890: IN
113891: OR
113892: AND
113893: IFFALSE 114201
// begin if un in mc_defender [ i ] then
113895: LD_VAR 0 1
113899: PUSH
113900: LD_EXP 199
113904: PUSH
113905: LD_VAR 0 3
113909: ARRAY
113910: IN
113911: IFFALSE 113950
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
113913: LD_ADDR_EXP 199
113917: PUSH
113918: LD_EXP 199
113922: PPUSH
113923: LD_VAR 0 3
113927: PPUSH
113928: LD_EXP 199
113932: PUSH
113933: LD_VAR 0 3
113937: ARRAY
113938: PUSH
113939: LD_VAR 0 1
113943: DIFF
113944: PPUSH
113945: CALL_OW 1
113949: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
113950: LD_ADDR_VAR 0 8
113954: PUSH
113955: LD_VAR 0 3
113959: PPUSH
113960: LD_INT 3
113962: PPUSH
113963: CALL 110591 0 2
113967: ST_TO_ADDR
// if fac then
113968: LD_VAR 0 8
113972: IFFALSE 114201
// begin for j in fac do
113974: LD_ADDR_VAR 0 4
113978: PUSH
113979: LD_VAR 0 8
113983: PUSH
113984: FOR_IN
113985: IFFALSE 114199
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
113987: LD_ADDR_VAR 0 9
113991: PUSH
113992: LD_VAR 0 8
113996: PPUSH
113997: LD_VAR 0 1
114001: PPUSH
114002: CALL_OW 265
114006: PPUSH
114007: LD_VAR 0 1
114011: PPUSH
114012: CALL_OW 262
114016: PPUSH
114017: LD_VAR 0 1
114021: PPUSH
114022: CALL_OW 263
114026: PPUSH
114027: LD_VAR 0 1
114031: PPUSH
114032: CALL_OW 264
114036: PPUSH
114037: CALL 21706 0 5
114041: ST_TO_ADDR
// if components then
114042: LD_VAR 0 9
114046: IFFALSE 114197
// begin if GetWeapon ( un ) = ar_control_tower then
114048: LD_VAR 0 1
114052: PPUSH
114053: CALL_OW 264
114057: PUSH
114058: LD_INT 31
114060: EQUAL
114061: IFFALSE 114178
// begin SetTag ( IsDrivenBy ( un ) , 0 ) ;
114063: LD_VAR 0 1
114067: PPUSH
114068: CALL_OW 311
114072: PPUSH
114073: LD_INT 0
114075: PPUSH
114076: CALL_OW 109
// mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff IsDrivenBy ( un ) ) ;
114080: LD_ADDR_EXP 217
114084: PUSH
114085: LD_EXP 217
114089: PPUSH
114090: LD_VAR 0 3
114094: PPUSH
114095: LD_EXP 217
114099: PUSH
114100: LD_VAR 0 3
114104: ARRAY
114105: PUSH
114106: LD_VAR 0 1
114110: PPUSH
114111: CALL_OW 311
114115: DIFF
114116: PPUSH
114117: CALL_OW 1
114121: ST_TO_ADDR
// tmp := Insert ( mc_produce [ i ] , 1 , components ) ;
114122: LD_ADDR_VAR 0 7
114126: PUSH
114127: LD_EXP 198
114131: PUSH
114132: LD_VAR 0 3
114136: ARRAY
114137: PPUSH
114138: LD_INT 1
114140: PPUSH
114141: LD_VAR 0 9
114145: PPUSH
114146: CALL_OW 2
114150: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
114151: LD_ADDR_EXP 198
114155: PUSH
114156: LD_EXP 198
114160: PPUSH
114161: LD_VAR 0 3
114165: PPUSH
114166: LD_VAR 0 7
114170: PPUSH
114171: CALL_OW 1
114175: ST_TO_ADDR
// end else
114176: GO 114195
// MC_InsertProduceList ( i , [ components ] ) ;
114178: LD_VAR 0 3
114182: PPUSH
114183: LD_VAR 0 9
114187: PUSH
114188: EMPTY
114189: LIST
114190: PPUSH
114191: CALL 110136 0 2
// break ;
114195: GO 114199
// end ; end ;
114197: GO 113984
114199: POP
114200: POP
// end ; end ; if GetType ( un ) = unit_building then
114201: LD_VAR 0 1
114205: PPUSH
114206: CALL_OW 247
114210: PUSH
114211: LD_INT 3
114213: EQUAL
114214: IFFALSE 114617
// begin btype := GetBType ( un ) ;
114216: LD_ADDR_VAR 0 5
114220: PUSH
114221: LD_VAR 0 1
114225: PPUSH
114226: CALL_OW 266
114230: ST_TO_ADDR
// if btype in [ b_oil_mine , b_siberite_mine ] then
114231: LD_VAR 0 5
114235: PUSH
114236: LD_INT 29
114238: PUSH
114239: LD_INT 30
114241: PUSH
114242: EMPTY
114243: LIST
114244: LIST
114245: IN
114246: IFFALSE 114319
// begin if not GetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) then
114248: LD_VAR 0 1
114252: PPUSH
114253: CALL_OW 250
114257: PPUSH
114258: LD_VAR 0 1
114262: PPUSH
114263: CALL_OW 251
114267: PPUSH
114268: LD_VAR 0 1
114272: PPUSH
114273: CALL_OW 255
114277: PPUSH
114278: CALL_OW 440
114282: NOT
114283: IFFALSE 114319
// SetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) ;
114285: LD_VAR 0 1
114289: PPUSH
114290: CALL_OW 250
114294: PPUSH
114295: LD_VAR 0 1
114299: PPUSH
114300: CALL_OW 251
114304: PPUSH
114305: LD_VAR 0 1
114309: PPUSH
114310: CALL_OW 255
114314: PPUSH
114315: CALL_OW 441
// end ; if btype = b_warehouse then
114319: LD_VAR 0 5
114323: PUSH
114324: LD_INT 1
114326: EQUAL
114327: IFFALSE 114345
// begin btype := b_depot ;
114329: LD_ADDR_VAR 0 5
114333: PUSH
114334: LD_INT 0
114336: ST_TO_ADDR
// pos := 1 ;
114337: LD_ADDR_VAR 0 6
114341: PUSH
114342: LD_INT 1
114344: ST_TO_ADDR
// end ; if btype = b_factory then
114345: LD_VAR 0 5
114349: PUSH
114350: LD_INT 3
114352: EQUAL
114353: IFFALSE 114371
// begin btype := b_workshop ;
114355: LD_ADDR_VAR 0 5
114359: PUSH
114360: LD_INT 2
114362: ST_TO_ADDR
// pos := 1 ;
114363: LD_ADDR_VAR 0 6
114367: PUSH
114368: LD_INT 1
114370: ST_TO_ADDR
// end ; if btype = b_barracks then
114371: LD_VAR 0 5
114375: PUSH
114376: LD_INT 5
114378: EQUAL
114379: IFFALSE 114389
// btype := b_armoury ;
114381: LD_ADDR_VAR 0 5
114385: PUSH
114386: LD_INT 4
114388: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
114389: LD_VAR 0 5
114393: PUSH
114394: LD_INT 7
114396: PUSH
114397: LD_INT 8
114399: PUSH
114400: EMPTY
114401: LIST
114402: LIST
114403: IN
114404: IFFALSE 114414
// btype := b_lab ;
114406: LD_ADDR_VAR 0 5
114410: PUSH
114411: LD_INT 6
114413: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
114414: LD_ADDR_EXP 182
114418: PUSH
114419: LD_EXP 182
114423: PPUSH
114424: LD_VAR 0 3
114428: PUSH
114429: LD_EXP 182
114433: PUSH
114434: LD_VAR 0 3
114438: ARRAY
114439: PUSH
114440: LD_INT 1
114442: PLUS
114443: PUSH
114444: EMPTY
114445: LIST
114446: LIST
114447: PPUSH
114448: LD_VAR 0 5
114452: PUSH
114453: LD_VAR 0 1
114457: PPUSH
114458: CALL_OW 250
114462: PUSH
114463: LD_VAR 0 1
114467: PPUSH
114468: CALL_OW 251
114472: PUSH
114473: LD_VAR 0 1
114477: PPUSH
114478: CALL_OW 254
114482: PUSH
114483: EMPTY
114484: LIST
114485: LIST
114486: LIST
114487: LIST
114488: PPUSH
114489: CALL 24210 0 3
114493: ST_TO_ADDR
// if pos = 1 then
114494: LD_VAR 0 6
114498: PUSH
114499: LD_INT 1
114501: EQUAL
114502: IFFALSE 114617
// begin tmp := mc_build_list [ i ] ;
114504: LD_ADDR_VAR 0 7
114508: PUSH
114509: LD_EXP 182
114513: PUSH
114514: LD_VAR 0 3
114518: ARRAY
114519: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
114520: LD_VAR 0 7
114524: PPUSH
114525: LD_INT 2
114527: PUSH
114528: LD_INT 30
114530: PUSH
114531: LD_INT 0
114533: PUSH
114534: EMPTY
114535: LIST
114536: LIST
114537: PUSH
114538: LD_INT 30
114540: PUSH
114541: LD_INT 1
114543: PUSH
114544: EMPTY
114545: LIST
114546: LIST
114547: PUSH
114548: EMPTY
114549: LIST
114550: LIST
114551: LIST
114552: PPUSH
114553: CALL_OW 72
114557: IFFALSE 114567
// pos := 2 ;
114559: LD_ADDR_VAR 0 6
114563: PUSH
114564: LD_INT 2
114566: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
114567: LD_ADDR_VAR 0 7
114571: PUSH
114572: LD_VAR 0 7
114576: PPUSH
114577: LD_VAR 0 6
114581: PPUSH
114582: LD_VAR 0 7
114586: PPUSH
114587: CALL 24536 0 3
114591: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
114592: LD_ADDR_EXP 182
114596: PUSH
114597: LD_EXP 182
114601: PPUSH
114602: LD_VAR 0 3
114606: PPUSH
114607: LD_VAR 0 7
114611: PPUSH
114612: CALL_OW 1
114616: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
114617: LD_VAR 0 1
114621: PUSH
114622: LD_EXP 177
114626: PUSH
114627: LD_VAR 0 3
114631: ARRAY
114632: IN
114633: IFFALSE 114672
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
114635: LD_ADDR_EXP 177
114639: PUSH
114640: LD_EXP 177
114644: PPUSH
114645: LD_VAR 0 3
114649: PPUSH
114650: LD_EXP 177
114654: PUSH
114655: LD_VAR 0 3
114659: ARRAY
114660: PUSH
114661: LD_VAR 0 1
114665: DIFF
114666: PPUSH
114667: CALL_OW 1
114671: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
114672: LD_VAR 0 1
114676: PUSH
114677: LD_EXP 184
114681: PUSH
114682: LD_VAR 0 3
114686: ARRAY
114687: IN
114688: IFFALSE 114727
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
114690: LD_ADDR_EXP 184
114694: PUSH
114695: LD_EXP 184
114699: PPUSH
114700: LD_VAR 0 3
114704: PPUSH
114705: LD_EXP 184
114709: PUSH
114710: LD_VAR 0 3
114714: ARRAY
114715: PUSH
114716: LD_VAR 0 1
114720: DIFF
114721: PPUSH
114722: CALL_OW 1
114726: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
114727: LD_VAR 0 1
114731: PUSH
114732: LD_EXP 196
114736: PUSH
114737: LD_VAR 0 3
114741: ARRAY
114742: IN
114743: IFFALSE 114782
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
114745: LD_ADDR_EXP 196
114749: PUSH
114750: LD_EXP 196
114754: PPUSH
114755: LD_VAR 0 3
114759: PPUSH
114760: LD_EXP 196
114764: PUSH
114765: LD_VAR 0 3
114769: ARRAY
114770: PUSH
114771: LD_VAR 0 1
114775: DIFF
114776: PPUSH
114777: CALL_OW 1
114781: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
114782: LD_VAR 0 1
114786: PUSH
114787: LD_EXP 199
114791: PUSH
114792: LD_VAR 0 3
114796: ARRAY
114797: IN
114798: IFFALSE 114837
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
114800: LD_ADDR_EXP 199
114804: PUSH
114805: LD_EXP 199
114809: PPUSH
114810: LD_VAR 0 3
114814: PPUSH
114815: LD_EXP 199
114819: PUSH
114820: LD_VAR 0 3
114824: ARRAY
114825: PUSH
114826: LD_VAR 0 1
114830: DIFF
114831: PPUSH
114832: CALL_OW 1
114836: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
114837: LD_VAR 0 1
114841: PUSH
114842: LD_EXP 186
114846: PUSH
114847: LD_VAR 0 3
114851: ARRAY
114852: IN
114853: IFFALSE 114892
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
114855: LD_ADDR_EXP 186
114859: PUSH
114860: LD_EXP 186
114864: PPUSH
114865: LD_VAR 0 3
114869: PPUSH
114870: LD_EXP 186
114874: PUSH
114875: LD_VAR 0 3
114879: ARRAY
114880: PUSH
114881: LD_VAR 0 1
114885: DIFF
114886: PPUSH
114887: CALL_OW 1
114891: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
114892: LD_VAR 0 1
114896: PUSH
114897: LD_EXP 185
114901: PUSH
114902: LD_VAR 0 3
114906: ARRAY
114907: IN
114908: IFFALSE 114947
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
114910: LD_ADDR_EXP 185
114914: PUSH
114915: LD_EXP 185
114919: PPUSH
114920: LD_VAR 0 3
114924: PPUSH
114925: LD_EXP 185
114929: PUSH
114930: LD_VAR 0 3
114934: ARRAY
114935: PUSH
114936: LD_VAR 0 1
114940: DIFF
114941: PPUSH
114942: CALL_OW 1
114946: ST_TO_ADDR
// end ; break ;
114947: GO 114951
// end ;
114949: GO 113597
114951: POP
114952: POP
// end ;
114953: LD_VAR 0 2
114957: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
114958: LD_INT 0
114960: PPUSH
114961: PPUSH
114962: PPUSH
// if not mc_bases or not skirmish then
114963: LD_EXP 177
114967: NOT
114968: PUSH
114969: LD_EXP 175
114973: NOT
114974: OR
114975: IFFALSE 114979
// exit ;
114977: GO 115194
// for i = 1 to mc_bases do
114979: LD_ADDR_VAR 0 3
114983: PUSH
114984: DOUBLE
114985: LD_INT 1
114987: DEC
114988: ST_TO_ADDR
114989: LD_EXP 177
114993: PUSH
114994: FOR_TO
114995: IFFALSE 115192
// begin if building in mc_construct_list [ i ] then
114997: LD_VAR 0 1
115001: PUSH
115002: LD_EXP 184
115006: PUSH
115007: LD_VAR 0 3
115011: ARRAY
115012: IN
115013: IFFALSE 115190
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
115015: LD_ADDR_EXP 184
115019: PUSH
115020: LD_EXP 184
115024: PPUSH
115025: LD_VAR 0 3
115029: PPUSH
115030: LD_EXP 184
115034: PUSH
115035: LD_VAR 0 3
115039: ARRAY
115040: PUSH
115041: LD_VAR 0 1
115045: DIFF
115046: PPUSH
115047: CALL_OW 1
115051: ST_TO_ADDR
// if building in mc_lab [ i ] then
115052: LD_VAR 0 1
115056: PUSH
115057: LD_EXP 210
115061: PUSH
115062: LD_VAR 0 3
115066: ARRAY
115067: IN
115068: IFFALSE 115123
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
115070: LD_ADDR_EXP 211
115074: PUSH
115075: LD_EXP 211
115079: PPUSH
115080: LD_VAR 0 3
115084: PPUSH
115085: LD_EXP 211
115089: PUSH
115090: LD_VAR 0 3
115094: ARRAY
115095: PPUSH
115096: LD_INT 1
115098: PPUSH
115099: LD_EXP 211
115103: PUSH
115104: LD_VAR 0 3
115108: ARRAY
115109: PPUSH
115110: LD_INT 0
115112: PPUSH
115113: CALL 23628 0 4
115117: PPUSH
115118: CALL_OW 1
115122: ST_TO_ADDR
// if not building in mc_bases [ i ] then
115123: LD_VAR 0 1
115127: PUSH
115128: LD_EXP 177
115132: PUSH
115133: LD_VAR 0 3
115137: ARRAY
115138: IN
115139: NOT
115140: IFFALSE 115186
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
115142: LD_ADDR_EXP 177
115146: PUSH
115147: LD_EXP 177
115151: PPUSH
115152: LD_VAR 0 3
115156: PUSH
115157: LD_EXP 177
115161: PUSH
115162: LD_VAR 0 3
115166: ARRAY
115167: PUSH
115168: LD_INT 1
115170: PLUS
115171: PUSH
115172: EMPTY
115173: LIST
115174: LIST
115175: PPUSH
115176: LD_VAR 0 1
115180: PPUSH
115181: CALL 24210 0 3
115185: ST_TO_ADDR
// exit ;
115186: POP
115187: POP
115188: GO 115194
// end ; end ;
115190: GO 114994
115192: POP
115193: POP
// end ;
115194: LD_VAR 0 2
115198: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
115199: LD_INT 0
115201: PPUSH
115202: PPUSH
115203: PPUSH
115204: PPUSH
115205: PPUSH
115206: PPUSH
115207: PPUSH
// if not mc_bases or not skirmish then
115208: LD_EXP 177
115212: NOT
115213: PUSH
115214: LD_EXP 175
115218: NOT
115219: OR
115220: IFFALSE 115224
// exit ;
115222: GO 115885
// for i = 1 to mc_bases do
115224: LD_ADDR_VAR 0 3
115228: PUSH
115229: DOUBLE
115230: LD_INT 1
115232: DEC
115233: ST_TO_ADDR
115234: LD_EXP 177
115238: PUSH
115239: FOR_TO
115240: IFFALSE 115883
// begin if building in mc_construct_list [ i ] then
115242: LD_VAR 0 1
115246: PUSH
115247: LD_EXP 184
115251: PUSH
115252: LD_VAR 0 3
115256: ARRAY
115257: IN
115258: IFFALSE 115881
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
115260: LD_ADDR_EXP 184
115264: PUSH
115265: LD_EXP 184
115269: PPUSH
115270: LD_VAR 0 3
115274: PPUSH
115275: LD_EXP 184
115279: PUSH
115280: LD_VAR 0 3
115284: ARRAY
115285: PUSH
115286: LD_VAR 0 1
115290: DIFF
115291: PPUSH
115292: CALL_OW 1
115296: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
115297: LD_ADDR_EXP 177
115301: PUSH
115302: LD_EXP 177
115306: PPUSH
115307: LD_VAR 0 3
115311: PUSH
115312: LD_EXP 177
115316: PUSH
115317: LD_VAR 0 3
115321: ARRAY
115322: PUSH
115323: LD_INT 1
115325: PLUS
115326: PUSH
115327: EMPTY
115328: LIST
115329: LIST
115330: PPUSH
115331: LD_VAR 0 1
115335: PPUSH
115336: CALL 24210 0 3
115340: ST_TO_ADDR
// btype := GetBType ( building ) ;
115341: LD_ADDR_VAR 0 5
115345: PUSH
115346: LD_VAR 0 1
115350: PPUSH
115351: CALL_OW 266
115355: ST_TO_ADDR
// side := GetSide ( building ) ;
115356: LD_ADDR_VAR 0 8
115360: PUSH
115361: LD_VAR 0 1
115365: PPUSH
115366: CALL_OW 255
115370: ST_TO_ADDR
// if btype = b_lab then
115371: LD_VAR 0 5
115375: PUSH
115376: LD_INT 6
115378: EQUAL
115379: IFFALSE 115429
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
115381: LD_ADDR_EXP 210
115385: PUSH
115386: LD_EXP 210
115390: PPUSH
115391: LD_VAR 0 3
115395: PUSH
115396: LD_EXP 210
115400: PUSH
115401: LD_VAR 0 3
115405: ARRAY
115406: PUSH
115407: LD_INT 1
115409: PLUS
115410: PUSH
115411: EMPTY
115412: LIST
115413: LIST
115414: PPUSH
115415: LD_VAR 0 1
115419: PPUSH
115420: CALL 24210 0 3
115424: ST_TO_ADDR
// exit ;
115425: POP
115426: POP
115427: GO 115885
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
115429: LD_VAR 0 5
115433: PUSH
115434: LD_INT 0
115436: PUSH
115437: LD_INT 2
115439: PUSH
115440: LD_INT 4
115442: PUSH
115443: EMPTY
115444: LIST
115445: LIST
115446: LIST
115447: IN
115448: IFFALSE 115572
// begin if btype = b_armoury then
115450: LD_VAR 0 5
115454: PUSH
115455: LD_INT 4
115457: EQUAL
115458: IFFALSE 115468
// btype := b_barracks ;
115460: LD_ADDR_VAR 0 5
115464: PUSH
115465: LD_INT 5
115467: ST_TO_ADDR
// if btype = b_depot then
115468: LD_VAR 0 5
115472: PUSH
115473: LD_INT 0
115475: EQUAL
115476: IFFALSE 115486
// btype := b_warehouse ;
115478: LD_ADDR_VAR 0 5
115482: PUSH
115483: LD_INT 1
115485: ST_TO_ADDR
// if btype = b_workshop then
115486: LD_VAR 0 5
115490: PUSH
115491: LD_INT 2
115493: EQUAL
115494: IFFALSE 115504
// btype := b_factory ;
115496: LD_ADDR_VAR 0 5
115500: PUSH
115501: LD_INT 3
115503: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
115504: LD_VAR 0 5
115508: PPUSH
115509: LD_VAR 0 8
115513: PPUSH
115514: CALL_OW 323
115518: PUSH
115519: LD_INT 1
115521: EQUAL
115522: IFFALSE 115568
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
115524: LD_ADDR_EXP 209
115528: PUSH
115529: LD_EXP 209
115533: PPUSH
115534: LD_VAR 0 3
115538: PUSH
115539: LD_EXP 209
115543: PUSH
115544: LD_VAR 0 3
115548: ARRAY
115549: PUSH
115550: LD_INT 1
115552: PLUS
115553: PUSH
115554: EMPTY
115555: LIST
115556: LIST
115557: PPUSH
115558: LD_VAR 0 1
115562: PPUSH
115563: CALL 24210 0 3
115567: ST_TO_ADDR
// exit ;
115568: POP
115569: POP
115570: GO 115885
// end ; if btype in [ b_bunker , b_turret ] then
115572: LD_VAR 0 5
115576: PUSH
115577: LD_INT 32
115579: PUSH
115580: LD_INT 33
115582: PUSH
115583: EMPTY
115584: LIST
115585: LIST
115586: IN
115587: IFFALSE 115877
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
115589: LD_ADDR_EXP 185
115593: PUSH
115594: LD_EXP 185
115598: PPUSH
115599: LD_VAR 0 3
115603: PUSH
115604: LD_EXP 185
115608: PUSH
115609: LD_VAR 0 3
115613: ARRAY
115614: PUSH
115615: LD_INT 1
115617: PLUS
115618: PUSH
115619: EMPTY
115620: LIST
115621: LIST
115622: PPUSH
115623: LD_VAR 0 1
115627: PPUSH
115628: CALL 24210 0 3
115632: ST_TO_ADDR
// if btype = b_bunker then
115633: LD_VAR 0 5
115637: PUSH
115638: LD_INT 32
115640: EQUAL
115641: IFFALSE 115877
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
115643: LD_ADDR_EXP 186
115647: PUSH
115648: LD_EXP 186
115652: PPUSH
115653: LD_VAR 0 3
115657: PUSH
115658: LD_EXP 186
115662: PUSH
115663: LD_VAR 0 3
115667: ARRAY
115668: PUSH
115669: LD_INT 1
115671: PLUS
115672: PUSH
115673: EMPTY
115674: LIST
115675: LIST
115676: PPUSH
115677: LD_VAR 0 1
115681: PPUSH
115682: CALL 24210 0 3
115686: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
115687: LD_ADDR_VAR 0 6
115691: PUSH
115692: LD_EXP 177
115696: PUSH
115697: LD_VAR 0 3
115701: ARRAY
115702: PPUSH
115703: LD_INT 25
115705: PUSH
115706: LD_INT 1
115708: PUSH
115709: EMPTY
115710: LIST
115711: LIST
115712: PUSH
115713: LD_INT 3
115715: PUSH
115716: LD_INT 54
115718: PUSH
115719: EMPTY
115720: LIST
115721: PUSH
115722: EMPTY
115723: LIST
115724: LIST
115725: PUSH
115726: EMPTY
115727: LIST
115728: LIST
115729: PPUSH
115730: CALL_OW 72
115734: ST_TO_ADDR
// if tmp then
115735: LD_VAR 0 6
115739: IFFALSE 115745
// exit ;
115741: POP
115742: POP
115743: GO 115885
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
115745: LD_ADDR_VAR 0 6
115749: PUSH
115750: LD_EXP 177
115754: PUSH
115755: LD_VAR 0 3
115759: ARRAY
115760: PPUSH
115761: LD_INT 2
115763: PUSH
115764: LD_INT 30
115766: PUSH
115767: LD_INT 4
115769: PUSH
115770: EMPTY
115771: LIST
115772: LIST
115773: PUSH
115774: LD_INT 30
115776: PUSH
115777: LD_INT 5
115779: PUSH
115780: EMPTY
115781: LIST
115782: LIST
115783: PUSH
115784: EMPTY
115785: LIST
115786: LIST
115787: LIST
115788: PPUSH
115789: CALL_OW 72
115793: ST_TO_ADDR
// if not tmp then
115794: LD_VAR 0 6
115798: NOT
115799: IFFALSE 115805
// exit ;
115801: POP
115802: POP
115803: GO 115885
// for j in tmp do
115805: LD_ADDR_VAR 0 4
115809: PUSH
115810: LD_VAR 0 6
115814: PUSH
115815: FOR_IN
115816: IFFALSE 115875
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
115818: LD_ADDR_VAR 0 7
115822: PUSH
115823: LD_VAR 0 4
115827: PPUSH
115828: CALL_OW 313
115832: PPUSH
115833: LD_INT 25
115835: PUSH
115836: LD_INT 1
115838: PUSH
115839: EMPTY
115840: LIST
115841: LIST
115842: PPUSH
115843: CALL_OW 72
115847: ST_TO_ADDR
// if units then
115848: LD_VAR 0 7
115852: IFFALSE 115873
// begin ComExitBuilding ( units [ 1 ] ) ;
115854: LD_VAR 0 7
115858: PUSH
115859: LD_INT 1
115861: ARRAY
115862: PPUSH
115863: CALL_OW 122
// exit ;
115867: POP
115868: POP
115869: POP
115870: POP
115871: GO 115885
// end ; end ;
115873: GO 115815
115875: POP
115876: POP
// end ; end ; exit ;
115877: POP
115878: POP
115879: GO 115885
// end ; end ;
115881: GO 115239
115883: POP
115884: POP
// end ;
115885: LD_VAR 0 2
115889: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
115890: LD_INT 0
115892: PPUSH
115893: PPUSH
115894: PPUSH
115895: PPUSH
115896: PPUSH
115897: PPUSH
115898: PPUSH
// if not mc_bases or not skirmish then
115899: LD_EXP 177
115903: NOT
115904: PUSH
115905: LD_EXP 175
115909: NOT
115910: OR
115911: IFFALSE 115915
// exit ;
115913: GO 116180
// btype := GetBType ( building ) ;
115915: LD_ADDR_VAR 0 6
115919: PUSH
115920: LD_VAR 0 1
115924: PPUSH
115925: CALL_OW 266
115929: ST_TO_ADDR
// x := GetX ( building ) ;
115930: LD_ADDR_VAR 0 7
115934: PUSH
115935: LD_VAR 0 1
115939: PPUSH
115940: CALL_OW 250
115944: ST_TO_ADDR
// y := GetY ( building ) ;
115945: LD_ADDR_VAR 0 8
115949: PUSH
115950: LD_VAR 0 1
115954: PPUSH
115955: CALL_OW 251
115959: ST_TO_ADDR
// d := GetDir ( building ) ;
115960: LD_ADDR_VAR 0 9
115964: PUSH
115965: LD_VAR 0 1
115969: PPUSH
115970: CALL_OW 254
115974: ST_TO_ADDR
// for i = 1 to mc_bases do
115975: LD_ADDR_VAR 0 4
115979: PUSH
115980: DOUBLE
115981: LD_INT 1
115983: DEC
115984: ST_TO_ADDR
115985: LD_EXP 177
115989: PUSH
115990: FOR_TO
115991: IFFALSE 116178
// begin if not mc_build_list [ i ] then
115993: LD_EXP 182
115997: PUSH
115998: LD_VAR 0 4
116002: ARRAY
116003: NOT
116004: IFFALSE 116008
// continue ;
116006: GO 115990
// for j := 1 to mc_build_list [ i ] do
116008: LD_ADDR_VAR 0 5
116012: PUSH
116013: DOUBLE
116014: LD_INT 1
116016: DEC
116017: ST_TO_ADDR
116018: LD_EXP 182
116022: PUSH
116023: LD_VAR 0 4
116027: ARRAY
116028: PUSH
116029: FOR_TO
116030: IFFALSE 116174
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ j ] ) then
116032: LD_VAR 0 6
116036: PUSH
116037: LD_VAR 0 7
116041: PUSH
116042: LD_VAR 0 8
116046: PUSH
116047: LD_VAR 0 9
116051: PUSH
116052: EMPTY
116053: LIST
116054: LIST
116055: LIST
116056: LIST
116057: PPUSH
116058: LD_EXP 182
116062: PUSH
116063: LD_VAR 0 4
116067: ARRAY
116068: PUSH
116069: LD_VAR 0 5
116073: ARRAY
116074: PPUSH
116075: CALL 30392 0 2
116079: IFFALSE 116172
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , j ) ) ;
116081: LD_ADDR_EXP 182
116085: PUSH
116086: LD_EXP 182
116090: PPUSH
116091: LD_VAR 0 4
116095: PPUSH
116096: LD_EXP 182
116100: PUSH
116101: LD_VAR 0 4
116105: ARRAY
116106: PPUSH
116107: LD_VAR 0 5
116111: PPUSH
116112: CALL_OW 3
116116: PPUSH
116117: CALL_OW 1
116121: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
116122: LD_ADDR_EXP 184
116126: PUSH
116127: LD_EXP 184
116131: PPUSH
116132: LD_VAR 0 4
116136: PUSH
116137: LD_EXP 184
116141: PUSH
116142: LD_VAR 0 4
116146: ARRAY
116147: PUSH
116148: LD_INT 1
116150: PLUS
116151: PUSH
116152: EMPTY
116153: LIST
116154: LIST
116155: PPUSH
116156: LD_VAR 0 1
116160: PPUSH
116161: CALL 24210 0 3
116165: ST_TO_ADDR
// exit ;
116166: POP
116167: POP
116168: POP
116169: POP
116170: GO 116180
// end ;
116172: GO 116029
116174: POP
116175: POP
// end ;
116176: GO 115990
116178: POP
116179: POP
// end ;
116180: LD_VAR 0 3
116184: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
116185: LD_INT 0
116187: PPUSH
116188: PPUSH
116189: PPUSH
// if not mc_bases or not skirmish then
116190: LD_EXP 177
116194: NOT
116195: PUSH
116196: LD_EXP 175
116200: NOT
116201: OR
116202: IFFALSE 116206
// exit ;
116204: GO 116396
// for i = 1 to mc_bases do
116206: LD_ADDR_VAR 0 4
116210: PUSH
116211: DOUBLE
116212: LD_INT 1
116214: DEC
116215: ST_TO_ADDR
116216: LD_EXP 177
116220: PUSH
116221: FOR_TO
116222: IFFALSE 116309
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
116224: LD_VAR 0 1
116228: PUSH
116229: LD_EXP 185
116233: PUSH
116234: LD_VAR 0 4
116238: ARRAY
116239: IN
116240: PUSH
116241: LD_VAR 0 1
116245: PUSH
116246: LD_EXP 186
116250: PUSH
116251: LD_VAR 0 4
116255: ARRAY
116256: IN
116257: NOT
116258: AND
116259: IFFALSE 116307
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
116261: LD_ADDR_EXP 186
116265: PUSH
116266: LD_EXP 186
116270: PPUSH
116271: LD_VAR 0 4
116275: PUSH
116276: LD_EXP 186
116280: PUSH
116281: LD_VAR 0 4
116285: ARRAY
116286: PUSH
116287: LD_INT 1
116289: PLUS
116290: PUSH
116291: EMPTY
116292: LIST
116293: LIST
116294: PPUSH
116295: LD_VAR 0 1
116299: PPUSH
116300: CALL 24210 0 3
116304: ST_TO_ADDR
// break ;
116305: GO 116309
// end ; end ;
116307: GO 116221
116309: POP
116310: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
116311: LD_VAR 0 1
116315: PPUSH
116316: CALL_OW 257
116320: PUSH
116321: LD_EXP 203
116325: IN
116326: PUSH
116327: LD_VAR 0 1
116331: PPUSH
116332: CALL_OW 266
116336: PUSH
116337: LD_INT 5
116339: EQUAL
116340: AND
116341: PUSH
116342: LD_VAR 0 2
116346: PPUSH
116347: CALL_OW 110
116351: PUSH
116352: LD_INT 18
116354: NONEQUAL
116355: AND
116356: IFFALSE 116396
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
116358: LD_VAR 0 2
116362: PPUSH
116363: CALL_OW 257
116367: PUSH
116368: LD_INT 5
116370: PUSH
116371: LD_INT 8
116373: PUSH
116374: LD_INT 9
116376: PUSH
116377: EMPTY
116378: LIST
116379: LIST
116380: LIST
116381: IN
116382: IFFALSE 116396
// SetClass ( unit , 1 ) ;
116384: LD_VAR 0 2
116388: PPUSH
116389: LD_INT 1
116391: PPUSH
116392: CALL_OW 336
// end ;
116396: LD_VAR 0 3
116400: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
116401: LD_INT 0
116403: PPUSH
116404: PPUSH
// if not mc_bases or not skirmish then
116405: LD_EXP 177
116409: NOT
116410: PUSH
116411: LD_EXP 175
116415: NOT
116416: OR
116417: IFFALSE 116421
// exit ;
116419: GO 116537
// if GetLives ( abandoned_vehicle ) > 250 then
116421: LD_VAR 0 2
116425: PPUSH
116426: CALL_OW 256
116430: PUSH
116431: LD_INT 250
116433: GREATER
116434: IFFALSE 116438
// exit ;
116436: GO 116537
// for i = 1 to mc_bases do
116438: LD_ADDR_VAR 0 6
116442: PUSH
116443: DOUBLE
116444: LD_INT 1
116446: DEC
116447: ST_TO_ADDR
116448: LD_EXP 177
116452: PUSH
116453: FOR_TO
116454: IFFALSE 116535
// begin if driver in mc_bases [ i ] then
116456: LD_VAR 0 1
116460: PUSH
116461: LD_EXP 177
116465: PUSH
116466: LD_VAR 0 6
116470: ARRAY
116471: IN
116472: IFFALSE 116533
// begin ComMoveToNearbyEntrance ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
116474: LD_VAR 0 1
116478: PPUSH
116479: LD_EXP 177
116483: PUSH
116484: LD_VAR 0 6
116488: ARRAY
116489: PPUSH
116490: LD_INT 2
116492: PUSH
116493: LD_INT 30
116495: PUSH
116496: LD_INT 0
116498: PUSH
116499: EMPTY
116500: LIST
116501: LIST
116502: PUSH
116503: LD_INT 30
116505: PUSH
116506: LD_INT 1
116508: PUSH
116509: EMPTY
116510: LIST
116511: LIST
116512: PUSH
116513: EMPTY
116514: LIST
116515: LIST
116516: LIST
116517: PPUSH
116518: CALL_OW 72
116522: PUSH
116523: LD_INT 1
116525: ARRAY
116526: PPUSH
116527: CALL 56828 0 2
// break ;
116531: GO 116535
// end ; end ;
116533: GO 116453
116535: POP
116536: POP
// end ;
116537: LD_VAR 0 5
116541: RET
