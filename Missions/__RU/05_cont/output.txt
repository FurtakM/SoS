// export you , americans , arabians , neutral , you2 ; export rulive , apemans ; export DefendLast ; export action_was_fast , breaked_trough ; export Stevens_killed ; export wait_while ; export mcdef_difficulty ; export depot ; export mezera_mezi_minami ; export pocet_min ; export breaketrough_time ; export first_attack ; export sol , mor , sci , mec , eng , rmec ; export cargo , scout , attack , defence , remote ; export to_defence , to_attack , to_scout , to_cargo , to_remote ; export vodni_utok , normal1_utok , normal2_utok , normal3_utok , normal4_utok ; export fact1 , dep1 , lab1 ; export fort ; export ape_agress ; export first_apeman_tamed ; export dialogy , canlost , debug ; export StevensStayInBase , StevensInDepot ; starting begin dialogy := true ;
   0: LD_ADDR_EXP 46
   4: PUSH
   5: LD_INT 1
   7: ST_TO_ADDR
// canlost := true ;
   8: LD_ADDR_EXP 47
  12: PUSH
  13: LD_INT 1
  15: ST_TO_ADDR
// debug := false ;
  16: LD_ADDR_EXP 48
  20: PUSH
  21: LD_INT 0
  23: ST_TO_ADDR
// disable ( 99 ) ;
  24: LD_INT 99
  26: DISABLE_MARKED
// stevens_killed := false ;
  27: LD_ADDR_EXP 11
  31: PUSH
  32: LD_INT 0
  34: ST_TO_ADDR
// StevensStayInBase = 0 ;
  35: LD_ADDR_EXP 49
  39: PUSH
  40: LD_INT 0
  42: ST_TO_ADDR
// StevensInDepot := false ;
  43: LD_ADDR_EXP 50
  47: PUSH
  48: LD_INT 0
  50: ST_TO_ADDR
// RemoveUnit ( Mastodon ) ;
  51: LD_INT 1
  53: PPUSH
  54: CALL_OW 64
// set_sides ;
  58: CALL 261 0 0
// set_difficulty ;
  62: CALL 104 0 0
// load_chars ;
  66: CALL 836 0 0
// place_apes ;
  70: CALL 1533 0 0
// place_in_ru_cars ;
  74: CALL 1194 0 0
// place_ru_cars ( ru_place2 ) ;
  78: LD_INT 18
  80: PPUSH
  81: CALL 1813 0 1
// create_arabs_scout ;
  85: CALL 19947 0 0
// if dialogy then
  89: LD_EXP 46
  93: IFFALSE 99
// DIntro ;
  95: CALL 2712 0 0
// place_arabs_base ;
  99: CALL 10327 0 0
// end ;
 103: END
// function set_difficulty ; begin
 104: LD_INT 0
 106: PPUSH
// mcdef_difficulty := [ 170 , 200 , 130 ] [ difficulty ] ;
 107: LD_ADDR_EXP 13
 111: PUSH
 112: LD_INT 170
 114: PUSH
 115: LD_INT 200
 117: PUSH
 118: LD_INT 130
 120: PUSH
 121: EMPTY
 122: LIST
 123: LIST
 124: LIST
 125: PUSH
 126: LD_OWVAR 67
 130: ARRAY
 131: ST_TO_ADDR
// breaketrough_time := [ 72 72$0 , 55 55$0 , 35 35$0 ] [ difficulty ] ;
 132: LD_ADDR_EXP 17
 136: PUSH
 137: LD_INT 151200
 139: PUSH
 140: LD_INT 115500
 142: PUSH
 143: LD_INT 73500
 145: PUSH
 146: EMPTY
 147: LIST
 148: LIST
 149: LIST
 150: PUSH
 151: LD_OWVAR 67
 155: ARRAY
 156: ST_TO_ADDR
// mezera_mezi_minami := [ 4 4$0 , 2 2$0 , 1 1$0 ] [ difficulty ] ;
 157: LD_ADDR_EXP 15
 161: PUSH
 162: LD_INT 8400
 164: PUSH
 165: LD_INT 4200
 167: PUSH
 168: LD_INT 2100
 170: PUSH
 171: EMPTY
 172: LIST
 173: LIST
 174: LIST
 175: PUSH
 176: LD_OWVAR 67
 180: ARRAY
 181: ST_TO_ADDR
// pocet_min := [ 1 , 2 , 3 ] [ difficulty ] ;
 182: LD_ADDR_EXP 16
 186: PUSH
 187: LD_INT 1
 189: PUSH
 190: LD_INT 2
 192: PUSH
 193: LD_INT 3
 195: PUSH
 196: EMPTY
 197: LIST
 198: LIST
 199: LIST
 200: PUSH
 201: LD_OWVAR 67
 205: ARRAY
 206: ST_TO_ADDR
// ape_agress := [ [ - 15 , - 10 ] , [ - 2 , 2 ] , [ 1 , 10 ] ] [ difficulty ] ;
 207: LD_ADDR_EXP 44
 211: PUSH
 212: LD_INT 15
 214: NEG
 215: PUSH
 216: LD_INT 10
 218: NEG
 219: PUSH
 220: EMPTY
 221: LIST
 222: LIST
 223: PUSH
 224: LD_INT 2
 226: NEG
 227: PUSH
 228: LD_INT 2
 230: PUSH
 231: EMPTY
 232: LIST
 233: LIST
 234: PUSH
 235: LD_INT 1
 237: PUSH
 238: LD_INT 10
 240: PUSH
 241: EMPTY
 242: LIST
 243: LIST
 244: PUSH
 245: EMPTY
 246: LIST
 247: LIST
 248: LIST
 249: PUSH
 250: LD_OWVAR 67
 254: ARRAY
 255: ST_TO_ADDR
// end ;
 256: LD_VAR 0 1
 260: RET
// function set_sides ; begin
 261: LD_INT 0
 263: PPUSH
// you := 3 ;
 264: LD_ADDR_EXP 1
 268: PUSH
 269: LD_INT 3
 271: ST_TO_ADDR
// you2 := 6 ;
 272: LD_ADDR_EXP 5
 276: PUSH
 277: LD_INT 6
 279: ST_TO_ADDR
// americans := 1 ;
 280: LD_ADDR_EXP 2
 284: PUSH
 285: LD_INT 1
 287: ST_TO_ADDR
// arabians := 2 ;
 288: LD_ADDR_EXP 3
 292: PUSH
 293: LD_INT 2
 295: ST_TO_ADDR
// neutral := 0 ;
 296: LD_ADDR_EXP 4
 300: PUSH
 301: LD_INT 0
 303: ST_TO_ADDR
// end ;
 304: LD_VAR 0 1
 308: RET
// export function Vyhra ; begin
 309: LD_INT 0
 311: PPUSH
// set_medals ;
 312: CALL 382 0 0
// GiveMedals ( Main ) ;
 316: LD_STRING Main
 318: PPUSH
 319: CALL_OW 102
// RewardPeople ( FilterAllUnits ( [ [ f_side , you ] , [ f_type , unit_human ] , [ f_nation , nation_russian ] ] ) ) ;
 323: LD_INT 22
 325: PUSH
 326: LD_EXP 1
 330: PUSH
 331: EMPTY
 332: LIST
 333: LIST
 334: PUSH
 335: LD_INT 21
 337: PUSH
 338: LD_INT 1
 340: PUSH
 341: EMPTY
 342: LIST
 343: LIST
 344: PUSH
 345: LD_INT 23
 347: PUSH
 348: LD_INT 3
 350: PUSH
 351: EMPTY
 352: LIST
 353: LIST
 354: PUSH
 355: EMPTY
 356: LIST
 357: LIST
 358: LIST
 359: PPUSH
 360: CALL_OW 69
 364: PPUSH
 365: CALL_OW 43
// Save ;
 369: CALL 2028 0 0
// YouWin ;
 373: CALL_OW 103
// end ;
 377: LD_VAR 0 1
 381: RET
// export function set_medals ; var medal1 , medal2 , medal3 ; begin
 382: LD_INT 0
 384: PPUSH
 385: PPUSH
 386: PPUSH
 387: PPUSH
// medal1 := action_was_fast > 0 ;
 388: LD_ADDR_VAR 0 2
 392: PUSH
 393: LD_EXP 9
 397: PUSH
 398: LD_INT 0
 400: GREATER
 401: ST_TO_ADDR
// medal2 := first_apeman_tamed > 0 ;
 402: LD_ADDR_VAR 0 3
 406: PUSH
 407: LD_EXP 45
 411: PUSH
 412: LD_INT 0
 414: GREATER
 415: ST_TO_ADDR
// medal3 := IsDead ( Omar ) ;
 416: LD_ADDR_VAR 0 4
 420: PUSH
 421: LD_EXP 62
 425: PPUSH
 426: CALL_OW 301
 430: ST_TO_ADDR
// SA_EndMission ( 3 , 5 , medal1 , medal2 , medal3 ) ;
 431: LD_INT 3
 433: PPUSH
 434: LD_INT 5
 436: PPUSH
 437: LD_VAR 0 2
 441: PPUSH
 442: LD_VAR 0 3
 446: PPUSH
 447: LD_VAR 0 4
 451: PPUSH
 452: CALL 25941 0 5
// AddMedal ( Time , action_was_fast ) ;
 456: LD_STRING Time
 458: PPUSH
 459: LD_EXP 9
 463: PPUSH
 464: CALL_OW 101
// if first_apeman_tamed then
 468: LD_EXP 45
 472: IFFALSE 486
// AddMedal ( Apemen , 1 ) else
 474: LD_STRING Apemen
 476: PPUSH
 477: LD_INT 1
 479: PPUSH
 480: CALL_OW 101
 484: GO 528
// begin if GetTech ( tech_ApeLang , you ) = state_researched then
 486: LD_INT 1
 488: PPUSH
 489: LD_EXP 1
 493: PPUSH
 494: CALL_OW 321
 498: PUSH
 499: LD_INT 2
 501: EQUAL
 502: IFFALSE 517
// AddMedal ( Apemen , - 1 ) else
 504: LD_STRING Apemen
 506: PPUSH
 507: LD_INT 1
 509: NEG
 510: PPUSH
 511: CALL_OW 101
 515: GO 528
// AddMedal ( Apemen , - 2 ) ;
 517: LD_STRING Apemen
 519: PPUSH
 520: LD_INT 2
 522: NEG
 523: PPUSH
 524: CALL_OW 101
// end ; AddMedal ( Abdul , IsDead ( Omar ) ) ;
 528: LD_STRING Abdul
 530: PPUSH
 531: LD_EXP 62
 535: PPUSH
 536: CALL_OW 301
 540: PPUSH
 541: CALL_OW 101
// end ;
 545: LD_VAR 0 1
 549: RET
// every 0 0$7 trigger FilterAllUnits ( [ [ f_side , you ] , [ f_type , unit_human ] , [ f_nation , nation_russian ] ] ) < 6 do
 550: LD_INT 22
 552: PUSH
 553: LD_EXP 1
 557: PUSH
 558: EMPTY
 559: LIST
 560: LIST
 561: PUSH
 562: LD_INT 21
 564: PUSH
 565: LD_INT 1
 567: PUSH
 568: EMPTY
 569: LIST
 570: LIST
 571: PUSH
 572: LD_INT 23
 574: PUSH
 575: LD_INT 3
 577: PUSH
 578: EMPTY
 579: LIST
 580: LIST
 581: PUSH
 582: EMPTY
 583: LIST
 584: LIST
 585: LIST
 586: PPUSH
 587: CALL_OW 69
 591: PUSH
 592: LD_INT 6
 594: LESS
 595: IFFALSE 613
 597: GO 599
 599: DISABLE
// begin if canlost then
 600: LD_EXP 47
 604: IFFALSE 613
// YouLost ( Survive ) ;
 606: LD_STRING Survive
 608: PPUSH
 609: CALL_OW 104
// end ;
 613: END
// every 0 0$1 do
 614: GO 616
 616: DISABLE
// begin if debug then
 617: LD_EXP 48
 621: IFFALSE 834
// display_strings := [ [ cas:  & ( tick div 1 1$0 ) & : & ( ( tick mod 1 1$0 ) div 0 0$1 ) ] , [ mines , mines ] , [ crates , crates ] , [ attack , attack ] , [ defence , defence ] , [ sol , sol ] , [ mor , mor ] , [ eng , eng ] , [ mec , mec ] , [ sci , sci ] , [ brk_cars , brk_cars ] , [ opravit , opravit ] , [ stavi , stavi ] , [ todef1 , todef1 ] ] ;
 623: LD_ADDR_OWVAR 47
 627: PUSH
 628: LD_STRING cas: 
 630: PUSH
 631: LD_OWVAR 1
 635: PUSH
 636: LD_INT 2100
 638: DIV
 639: STR
 640: PUSH
 641: LD_STRING :
 643: STR
 644: PUSH
 645: LD_OWVAR 1
 649: PUSH
 650: LD_INT 2100
 652: MOD
 653: PUSH
 654: LD_INT 35
 656: DIV
 657: STR
 658: PUSH
 659: EMPTY
 660: LIST
 661: PUSH
 662: LD_STRING mines
 664: PUSH
 665: LD_EXP 73
 669: PUSH
 670: EMPTY
 671: LIST
 672: LIST
 673: PUSH
 674: LD_STRING crates
 676: PUSH
 677: LD_EXP 86
 681: PUSH
 682: EMPTY
 683: LIST
 684: LIST
 685: PUSH
 686: LD_STRING attack
 688: PUSH
 689: LD_EXP 27
 693: PUSH
 694: EMPTY
 695: LIST
 696: LIST
 697: PUSH
 698: LD_STRING defence
 700: PUSH
 701: LD_EXP 28
 705: PUSH
 706: EMPTY
 707: LIST
 708: LIST
 709: PUSH
 710: LD_STRING sol
 712: PUSH
 713: LD_EXP 19
 717: PUSH
 718: EMPTY
 719: LIST
 720: LIST
 721: PUSH
 722: LD_STRING mor
 724: PUSH
 725: LD_EXP 20
 729: PUSH
 730: EMPTY
 731: LIST
 732: LIST
 733: PUSH
 734: LD_STRING eng
 736: PUSH
 737: LD_EXP 23
 741: PUSH
 742: EMPTY
 743: LIST
 744: LIST
 745: PUSH
 746: LD_STRING mec
 748: PUSH
 749: LD_EXP 22
 753: PUSH
 754: EMPTY
 755: LIST
 756: LIST
 757: PUSH
 758: LD_STRING sci
 760: PUSH
 761: LD_EXP 21
 765: PUSH
 766: EMPTY
 767: LIST
 768: LIST
 769: PUSH
 770: LD_STRING brk_cars
 772: PUSH
 773: LD_EXP 75
 777: PUSH
 778: EMPTY
 779: LIST
 780: LIST
 781: PUSH
 782: LD_STRING opravit
 784: PUSH
 785: LD_EXP 74
 789: PUSH
 790: EMPTY
 791: LIST
 792: LIST
 793: PUSH
 794: LD_STRING stavi
 796: PUSH
 797: LD_EXP 69
 801: PUSH
 802: EMPTY
 803: LIST
 804: LIST
 805: PUSH
 806: LD_STRING todef1
 808: PUSH
 809: LD_EXP 84
 813: PUSH
 814: EMPTY
 815: LIST
 816: LIST
 817: PUSH
 818: EMPTY
 819: LIST
 820: LIST
 821: LIST
 822: LIST
 823: LIST
 824: LIST
 825: LIST
 826: LIST
 827: LIST
 828: LIST
 829: LIST
 830: LIST
 831: LIST
 832: LIST
 833: ST_TO_ADDR
// enable ;
 834: ENABLE
// end ; end_of_file
 835: END
// export Burlak , Platonov , Karamazov , Petrovova , Gleb , Petrosyan , Titov , Dolgov , Lipshchin , Stevens , Heike , Omar ; export used , ru_cars ; export function load_chars ; var i ; begin
 836: LD_INT 0
 838: PPUSH
 839: PPUSH
// InitUc ;
 840: CALL_OW 18
// InitHc ;
 844: CALL_OW 19
// uc_side := you ;
 848: LD_ADDR_OWVAR 20
 852: PUSH
 853: LD_EXP 1
 857: ST_TO_ADDR
// uc_nation := nation_russian ;
 858: LD_ADDR_OWVAR 21
 862: PUSH
 863: LD_INT 3
 865: ST_TO_ADDR
// Platonov := MyCreateCharacter ( Platonov , class_soldier , true ) ;
 866: LD_ADDR_EXP 52
 870: PUSH
 871: LD_STRING Platonov
 873: PPUSH
 874: LD_INT 1
 876: PPUSH
 877: LD_INT 1
 879: PPUSH
 880: CALL 1856 0 3
 884: ST_TO_ADDR
// Burlak := MyCreateCharacter ( Burlak , class_mechanic , false ) ;
 885: LD_ADDR_EXP 51
 889: PUSH
 890: LD_STRING Burlak
 892: PPUSH
 893: LD_INT 3
 895: PPUSH
 896: LD_INT 0
 898: PPUSH
 899: CALL 1856 0 3
 903: ST_TO_ADDR
// Titov := MyCreateCharacter ( Titov , class_soldier , true ) ;
 904: LD_ADDR_EXP 57
 908: PUSH
 909: LD_STRING Titov
 911: PPUSH
 912: LD_INT 1
 914: PPUSH
 915: LD_INT 1
 917: PPUSH
 918: CALL 1856 0 3
 922: ST_TO_ADDR
// Dolgov := MyCreateCharacter ( Dolgov , class_scientistic , true ) ;
 923: LD_ADDR_EXP 58
 927: PUSH
 928: LD_STRING Dolgov
 930: PPUSH
 931: LD_INT 4
 933: PPUSH
 934: LD_INT 1
 936: PPUSH
 937: CALL 1856 0 3
 941: ST_TO_ADDR
// Lipshchin := MyCreateCharacter ( Lipshchin , class_soldier , true ) ;
 942: LD_ADDR_EXP 59
 946: PUSH
 947: LD_STRING Lipshchin
 949: PPUSH
 950: LD_INT 1
 952: PPUSH
 953: LD_INT 1
 955: PPUSH
 956: CALL 1856 0 3
 960: ST_TO_ADDR
// Karamazov := MyCreateCharacter ( Karamazov , class_engineer , true ) ;
 961: LD_ADDR_EXP 53
 965: PUSH
 966: LD_STRING Karamazov
 968: PPUSH
 969: LD_INT 2
 971: PPUSH
 972: LD_INT 1
 974: PPUSH
 975: CALL 1856 0 3
 979: ST_TO_ADDR
// Petrovova := MyCreateCharacter ( Petrovova , class_soldier , true ) ;
 980: LD_ADDR_EXP 54
 984: PUSH
 985: LD_STRING Petrovova
 987: PPUSH
 988: LD_INT 1
 990: PPUSH
 991: LD_INT 1
 993: PPUSH
 994: CALL 1856 0 3
 998: ST_TO_ADDR
// Gleb := MyCreateCharacter ( Gleb , class_soldier , true ) ;
 999: LD_ADDR_EXP 55
1003: PUSH
1004: LD_STRING Gleb
1006: PPUSH
1007: LD_INT 1
1009: PPUSH
1010: LD_INT 1
1012: PPUSH
1013: CALL 1856 0 3
1017: ST_TO_ADDR
// Petrosyan := MyCreateCharacter ( Petrosyan , class_scientistic , true ) ;
1018: LD_ADDR_EXP 56
1022: PUSH
1023: LD_STRING Petrosyan
1025: PPUSH
1026: LD_INT 4
1028: PPUSH
1029: LD_INT 1
1031: PPUSH
1032: CALL 1856 0 3
1036: ST_TO_ADDR
// used := [ Burlak , Lipshchin , Titov , Dolgov , Karamazov , Petrovova , Gleb , Petrosyan ] diff 0 ;
1037: LD_ADDR_EXP 63
1041: PUSH
1042: LD_EXP 51
1046: PUSH
1047: LD_EXP 59
1051: PUSH
1052: LD_EXP 57
1056: PUSH
1057: LD_EXP 58
1061: PUSH
1062: LD_EXP 53
1066: PUSH
1067: LD_EXP 54
1071: PUSH
1072: LD_EXP 55
1076: PUSH
1077: LD_EXP 56
1081: PUSH
1082: EMPTY
1083: LIST
1084: LIST
1085: LIST
1086: LIST
1087: LIST
1088: LIST
1089: LIST
1090: LIST
1091: PUSH
1092: LD_INT 0
1094: DIFF
1095: ST_TO_ADDR
// uc_side := americans ;
1096: LD_ADDR_OWVAR 20
1100: PUSH
1101: LD_EXP 2
1105: ST_TO_ADDR
// uc_nation := nation_american ;
1106: LD_ADDR_OWVAR 21
1110: PUSH
1111: LD_INT 1
1113: ST_TO_ADDR
// Stevens := MyCreateCharacter ( Stevens , class_scientistic , true ) ;
1114: LD_ADDR_EXP 60
1118: PUSH
1119: LD_STRING Stevens
1121: PPUSH
1122: LD_INT 4
1124: PPUSH
1125: LD_INT 1
1127: PPUSH
1128: CALL 1856 0 3
1132: ST_TO_ADDR
// uc_side := arabians ;
1133: LD_ADDR_OWVAR 20
1137: PUSH
1138: LD_EXP 3
1142: ST_TO_ADDR
// uc_nation := nation_arabian ;
1143: LD_ADDR_OWVAR 21
1147: PUSH
1148: LD_INT 2
1150: ST_TO_ADDR
// Heike := MyCreateCharacter ( Heike , class_soldier , true ) ;
1151: LD_ADDR_EXP 61
1155: PUSH
1156: LD_STRING Heike
1158: PPUSH
1159: LD_INT 1
1161: PPUSH
1162: LD_INT 1
1164: PPUSH
1165: CALL 1856 0 3
1169: ST_TO_ADDR
// Omar := MyCreateCharacter ( Omar , class_desert_warior , true ) ;
1170: LD_ADDR_EXP 62
1174: PUSH
1175: LD_STRING Omar
1177: PPUSH
1178: LD_INT 11
1180: PPUSH
1181: LD_INT 1
1183: PPUSH
1184: CALL 1856 0 3
1188: ST_TO_ADDR
// end ;
1189: LD_VAR 0 1
1193: RET
// export function place_in_ru_cars ; var cars , car , i ; begin
1194: LD_INT 0
1196: PPUSH
1197: PPUSH
1198: PPUSH
1199: PPUSH
// cars := [ [ ru_medium_tracked , ru_heavy_machine_gun ] , [ ru_medium_tracked , ru_heavy_machine_gun ] , [ ru_medium_tracked , ru_heavy_machine_gun ] , [ ru_medium_tracked , ru_heavy_machine_gun ] , [ ru_medium_tracked , ru_heavy_machine_gun ] , [ ru_medium_tracked , ru_heavy_machine_gun ] , [ ru_medium_tracked , ru_heavy_machine_gun ] , [ ru_medium_tracked , ru_heavy_machine_gun ] ] ;
1200: LD_ADDR_VAR 0 2
1204: PUSH
1205: LD_INT 22
1207: PUSH
1208: LD_INT 42
1210: PUSH
1211: EMPTY
1212: LIST
1213: LIST
1214: PUSH
1215: LD_INT 22
1217: PUSH
1218: LD_INT 42
1220: PUSH
1221: EMPTY
1222: LIST
1223: LIST
1224: PUSH
1225: LD_INT 22
1227: PUSH
1228: LD_INT 42
1230: PUSH
1231: EMPTY
1232: LIST
1233: LIST
1234: PUSH
1235: LD_INT 22
1237: PUSH
1238: LD_INT 42
1240: PUSH
1241: EMPTY
1242: LIST
1243: LIST
1244: PUSH
1245: LD_INT 22
1247: PUSH
1248: LD_INT 42
1250: PUSH
1251: EMPTY
1252: LIST
1253: LIST
1254: PUSH
1255: LD_INT 22
1257: PUSH
1258: LD_INT 42
1260: PUSH
1261: EMPTY
1262: LIST
1263: LIST
1264: PUSH
1265: LD_INT 22
1267: PUSH
1268: LD_INT 42
1270: PUSH
1271: EMPTY
1272: LIST
1273: LIST
1274: PUSH
1275: LD_INT 22
1277: PUSH
1278: LD_INT 42
1280: PUSH
1281: EMPTY
1282: LIST
1283: LIST
1284: PUSH
1285: EMPTY
1286: LIST
1287: LIST
1288: LIST
1289: LIST
1290: LIST
1291: LIST
1292: LIST
1293: LIST
1294: ST_TO_ADDR
// InitUc ;
1295: CALL_OW 18
// InitVc ;
1299: CALL_OW 20
// vc_control := control_manual ;
1303: LD_ADDR_OWVAR 38
1307: PUSH
1308: LD_INT 1
1310: ST_TO_ADDR
// vc_engine := engine_combustion ;
1311: LD_ADDR_OWVAR 39
1315: PUSH
1316: LD_INT 1
1318: ST_TO_ADDR
// uc_side := you ;
1319: LD_ADDR_OWVAR 20
1323: PUSH
1324: LD_EXP 1
1328: ST_TO_ADDR
// uc_nation := nation_russian ;
1329: LD_ADDR_OWVAR 21
1333: PUSH
1334: LD_INT 3
1336: ST_TO_ADDR
// ru_cars := [ ] ;
1337: LD_ADDR_EXP 64
1341: PUSH
1342: EMPTY
1343: ST_TO_ADDR
// for i := 1 to 8 do
1344: LD_ADDR_VAR 0 4
1348: PUSH
1349: DOUBLE
1350: LD_INT 1
1352: DEC
1353: ST_TO_ADDR
1354: LD_INT 8
1356: PUSH
1357: FOR_TO
1358: IFFALSE 1526
// begin vc_chassis := cars [ i ] [ 1 ] ;
1360: LD_ADDR_OWVAR 37
1364: PUSH
1365: LD_VAR 0 2
1369: PUSH
1370: LD_VAR 0 4
1374: ARRAY
1375: PUSH
1376: LD_INT 1
1378: ARRAY
1379: ST_TO_ADDR
// vc_weapon := cars [ i ] [ 2 ] ;
1380: LD_ADDR_OWVAR 40
1384: PUSH
1385: LD_VAR 0 2
1389: PUSH
1390: LD_VAR 0 4
1394: ARRAY
1395: PUSH
1396: LD_INT 2
1398: ARRAY
1399: ST_TO_ADDR
// uc_direction := Rand ( 3 , 4 ) ;
1400: LD_ADDR_OWVAR 24
1404: PUSH
1405: LD_INT 3
1407: PPUSH
1408: LD_INT 4
1410: PPUSH
1411: CALL_OW 12
1415: ST_TO_ADDR
// vc_fuel_battery := Rand ( 25 , 40 ) ;
1416: LD_ADDR_OWVAR 41
1420: PUSH
1421: LD_INT 25
1423: PPUSH
1424: LD_INT 40
1426: PPUSH
1427: CALL_OW 12
1431: ST_TO_ADDR
// car := CreateVehicle ;
1432: LD_ADDR_VAR 0 3
1436: PUSH
1437: CALL_OW 45
1441: ST_TO_ADDR
// ru_cars := ru_cars ^ car ;
1442: LD_ADDR_EXP 64
1446: PUSH
1447: LD_EXP 64
1451: PUSH
1452: LD_VAR 0 3
1456: ADD
1457: ST_TO_ADDR
// PlaceHumanInUnit ( used [ i ] , car ) ;
1458: LD_EXP 63
1462: PUSH
1463: LD_VAR 0 4
1467: ARRAY
1468: PPUSH
1469: LD_VAR 0 3
1473: PPUSH
1474: CALL_OW 52
// SetLives ( car , Rand ( 251 , 800 ) ) ;
1478: LD_VAR 0 3
1482: PPUSH
1483: LD_INT 251
1485: PPUSH
1486: LD_INT 800
1488: PPUSH
1489: CALL_OW 12
1493: PPUSH
1494: CALL_OW 234
// SetLives ( used [ i ] , Rand ( 900 , 1000 ) ) ;
1498: LD_EXP 63
1502: PUSH
1503: LD_VAR 0 4
1507: ARRAY
1508: PPUSH
1509: LD_INT 900
1511: PPUSH
1512: LD_INT 1000
1514: PPUSH
1515: CALL_OW 12
1519: PPUSH
1520: CALL_OW 234
// end ;
1524: GO 1357
1526: POP
1527: POP
// end ;
1528: LD_VAR 0 1
1532: RET
// export function place_apes ; var o1 , o2 , o3 , o4 ; begin
1533: LD_INT 0
1535: PPUSH
1536: PPUSH
1537: PPUSH
1538: PPUSH
1539: PPUSH
// InitHc ;
1540: CALL_OW 19
// InitUc ;
1544: CALL_OW 18
// uc_side := 0 ;
1548: LD_ADDR_OWVAR 20
1552: PUSH
1553: LD_INT 0
1555: ST_TO_ADDR
// uc_nation := nation_nature ;
1556: LD_ADDR_OWVAR 21
1560: PUSH
1561: LD_INT 0
1563: ST_TO_ADDR
// hc_class := class_apeman ;
1564: LD_ADDR_OWVAR 28
1568: PUSH
1569: LD_INT 12
1571: ST_TO_ADDR
// hc_agressivity := Rand ( ape_agress [ 1 ] , ape_agress [ 2 ] ) ;
1572: LD_ADDR_OWVAR 35
1576: PUSH
1577: LD_EXP 44
1581: PUSH
1582: LD_INT 1
1584: ARRAY
1585: PPUSH
1586: LD_EXP 44
1590: PUSH
1591: LD_INT 2
1593: ARRAY
1594: PPUSH
1595: CALL_OW 12
1599: ST_TO_ADDR
// o1 := CreateHuman ;
1600: LD_ADDR_VAR 0 2
1604: PUSH
1605: CALL_OW 44
1609: ST_TO_ADDR
// hc_agressivity := Rand ( ape_agress [ 1 ] , ape_agress [ 2 ] ) ;
1610: LD_ADDR_OWVAR 35
1614: PUSH
1615: LD_EXP 44
1619: PUSH
1620: LD_INT 1
1622: ARRAY
1623: PPUSH
1624: LD_EXP 44
1628: PUSH
1629: LD_INT 2
1631: ARRAY
1632: PPUSH
1633: CALL_OW 12
1637: ST_TO_ADDR
// o2 := CreateHuman ;
1638: LD_ADDR_VAR 0 3
1642: PUSH
1643: CALL_OW 44
1647: ST_TO_ADDR
// hc_agressivity := - 5 ;
1648: LD_ADDR_OWVAR 35
1652: PUSH
1653: LD_INT 5
1655: NEG
1656: ST_TO_ADDR
// o3 := CreateHuman ;
1657: LD_ADDR_VAR 0 4
1661: PUSH
1662: CALL_OW 44
1666: ST_TO_ADDR
// hc_agressivity := Rand ( ape_agress [ 1 ] , ape_agress [ 2 ] ) ;
1667: LD_ADDR_OWVAR 35
1671: PUSH
1672: LD_EXP 44
1676: PUSH
1677: LD_INT 1
1679: ARRAY
1680: PPUSH
1681: LD_EXP 44
1685: PUSH
1686: LD_INT 2
1688: ARRAY
1689: PPUSH
1690: CALL_OW 12
1694: ST_TO_ADDR
// o4 := CreateHuman ;
1695: LD_ADDR_VAR 0 5
1699: PUSH
1700: CALL_OW 44
1704: ST_TO_ADDR
// PlaceUnitXY ( o1 , 10 , 14 , false ) ;
1705: LD_VAR 0 2
1709: PPUSH
1710: LD_INT 10
1712: PPUSH
1713: LD_INT 14
1715: PPUSH
1716: LD_INT 0
1718: PPUSH
1719: CALL_OW 48
// PlaceUnitXY ( o2 , 17 , 22 , false ) ;
1723: LD_VAR 0 3
1727: PPUSH
1728: LD_INT 17
1730: PPUSH
1731: LD_INT 22
1733: PPUSH
1734: LD_INT 0
1736: PPUSH
1737: CALL_OW 48
// PlaceUnitXY ( o3 , 16 , 11 , false ) ;
1741: LD_VAR 0 4
1745: PPUSH
1746: LD_INT 16
1748: PPUSH
1749: LD_INT 11
1751: PPUSH
1752: LD_INT 0
1754: PPUSH
1755: CALL_OW 48
// PlaceUnitXY ( o4 , 84 , 7 , false ) ;
1759: LD_VAR 0 5
1763: PPUSH
1764: LD_INT 84
1766: PPUSH
1767: LD_INT 7
1769: PPUSH
1770: LD_INT 0
1772: PPUSH
1773: CALL_OW 48
// apemans := [ o1 , o2 , o3 , o4 ] ;
1777: LD_ADDR_EXP 7
1781: PUSH
1782: LD_VAR 0 2
1786: PUSH
1787: LD_VAR 0 3
1791: PUSH
1792: LD_VAR 0 4
1796: PUSH
1797: LD_VAR 0 5
1801: PUSH
1802: EMPTY
1803: LIST
1804: LIST
1805: LIST
1806: LIST
1807: ST_TO_ADDR
// end ;
1808: LD_VAR 0 1
1812: RET
// export function place_ru_cars ( area ) ; var i ; begin
1813: LD_INT 0
1815: PPUSH
1816: PPUSH
// for i in ru_cars do
1817: LD_ADDR_VAR 0 3
1821: PUSH
1822: LD_EXP 64
1826: PUSH
1827: FOR_IN
1828: IFFALSE 1849
// PlaceUnitArea ( i , area , false ) ;
1830: LD_VAR 0 3
1834: PPUSH
1835: LD_VAR 0 1
1839: PPUSH
1840: LD_INT 0
1842: PPUSH
1843: CALL_OW 49
1847: GO 1827
1849: POP
1850: POP
// end ;
1851: LD_VAR 0 2
1855: RET
// function MyCreateCharacter ( name , unclass , new ) ; begin
1856: LD_INT 0
1858: PPUSH
// if new or TestCharacters ( name ) then
1859: LD_VAR 0 3
1863: PUSH
1864: LD_VAR 0 1
1868: PPUSH
1869: CALL_OW 28
1873: OR
1874: IFFALSE 1957
// begin if new then
1876: LD_VAR 0 3
1880: IFFALSE 1899
// result := NewCharacter ( name ) else
1882: LD_ADDR_VAR 0 4
1886: PUSH
1887: LD_VAR 0 1
1891: PPUSH
1892: CALL_OW 25
1896: ST_TO_ADDR
1897: GO 1935
// begin if CheckCharacterSet ( name ) then
1899: LD_VAR 0 1
1903: PPUSH
1904: CALL_OW 29
1908: IFFALSE 1927
// result := CreateCharacter ( name ) else
1910: LD_ADDR_VAR 0 4
1914: PUSH
1915: LD_VAR 0 1
1919: PPUSH
1920: CALL_OW 34
1924: ST_TO_ADDR
1925: GO 1935
// result := 0 ;
1927: LD_ADDR_VAR 0 4
1931: PUSH
1932: LD_INT 0
1934: ST_TO_ADDR
// end ; if unclass then
1935: LD_VAR 0 2
1939: IFFALSE 1955
// SetClass ( result , unclass ) ;
1941: LD_VAR 0 4
1945: PPUSH
1946: LD_VAR 0 2
1950: PPUSH
1951: CALL_OW 336
// end else
1955: GO 2023
// begin Msg ( Chybi  & name & ! ) ;
1957: LD_STRING Chybi 
1959: PUSH
1960: LD_VAR 0 1
1964: STR
1965: PUSH
1966: LD_STRING !
1968: STR
1969: PPUSH
1970: CALL_OW 100
// hc_name := name ;
1974: LD_ADDR_OWVAR 26
1978: PUSH
1979: LD_VAR 0 1
1983: ST_TO_ADDR
// PrepareHuman ( sex_male , 0 , 3 ) ;
1984: LD_INT 1
1986: PPUSH
1987: LD_INT 0
1989: PPUSH
1990: LD_INT 3
1992: PPUSH
1993: CALL_OW 380
// if unclass then
1997: LD_VAR 0 2
2001: IFFALSE 2013
// hc_class := unclass ;
2003: LD_ADDR_OWVAR 28
2007: PUSH
2008: LD_VAR 0 2
2012: ST_TO_ADDR
// result := CreateHuman ;
2013: LD_ADDR_VAR 0 4
2017: PUSH
2018: CALL_OW 44
2022: ST_TO_ADDR
// end ; end ;
2023: LD_VAR 0 4
2027: RET
// export function Save ; var cars , i , cargotype ; begin
2028: LD_INT 0
2030: PPUSH
2031: PPUSH
2032: PPUSH
2033: PPUSH
// if not IsDead ( Omar ) then
2034: LD_EXP 62
2038: PPUSH
2039: CALL_OW 301
2043: NOT
2044: IFFALSE 2058
// SaveCharacters ( Omar , Omar ) ;
2046: LD_EXP 62
2050: PPUSH
2051: LD_STRING Omar
2053: PPUSH
2054: CALL_OW 38
// SaveCharacters ( Burlak , Burlak ) ;
2058: LD_EXP 51
2062: PPUSH
2063: LD_STRING Burlak
2065: PPUSH
2066: CALL_OW 38
// if not IsInUnit ( Titov ) then
2070: LD_EXP 57
2074: PPUSH
2075: CALL_OW 310
2079: NOT
2080: IFFALSE 2094
// SetLives ( Titov , 0 ) ;
2082: LD_EXP 57
2086: PPUSH
2087: LD_INT 0
2089: PPUSH
2090: CALL_OW 234
// if not IsInUnit ( Dolgov ) then
2094: LD_EXP 58
2098: PPUSH
2099: CALL_OW 310
2103: NOT
2104: IFFALSE 2118
// SetLives ( Dolgov , 0 ) ;
2106: LD_EXP 58
2110: PPUSH
2111: LD_INT 0
2113: PPUSH
2114: CALL_OW 234
// if not IsInUnit ( Lipshchin ) then
2118: LD_EXP 59
2122: PPUSH
2123: CALL_OW 310
2127: NOT
2128: IFFALSE 2142
// SetLives ( Lipshchin , 0 ) ;
2130: LD_EXP 59
2134: PPUSH
2135: LD_INT 0
2137: PPUSH
2138: CALL_OW 234
// if not IsInUnit ( Karamazov ) then
2142: LD_EXP 53
2146: PPUSH
2147: CALL_OW 310
2151: NOT
2152: IFFALSE 2166
// SetLives ( Karamazov , 0 ) ;
2154: LD_EXP 53
2158: PPUSH
2159: LD_INT 0
2161: PPUSH
2162: CALL_OW 234
// if not IsInUnit ( Petrovova ) then
2166: LD_EXP 54
2170: PPUSH
2171: CALL_OW 310
2175: NOT
2176: IFFALSE 2190
// SetLives ( Petrovova , 0 ) ;
2178: LD_EXP 54
2182: PPUSH
2183: LD_INT 0
2185: PPUSH
2186: CALL_OW 234
// if not IsInUnit ( Gleb ) then
2190: LD_EXP 55
2194: PPUSH
2195: CALL_OW 310
2199: NOT
2200: IFFALSE 2214
// SetLives ( Gleb , 0 ) ;
2202: LD_EXP 55
2206: PPUSH
2207: LD_INT 0
2209: PPUSH
2210: CALL_OW 234
// if not IsInUnit ( Petrosyan ) then
2214: LD_EXP 56
2218: PPUSH
2219: CALL_OW 310
2223: NOT
2224: IFFALSE 2238
// SetLives ( Petrosyan , 0 ) ;
2226: LD_EXP 56
2230: PPUSH
2231: LD_INT 0
2233: PPUSH
2234: CALL_OW 234
// if Titov then
2238: LD_EXP 57
2242: IFFALSE 2256
// SaveCharacters ( Titov , Titov ) ;
2244: LD_EXP 57
2248: PPUSH
2249: LD_STRING Titov
2251: PPUSH
2252: CALL_OW 38
// if Dolgov then
2256: LD_EXP 58
2260: IFFALSE 2274
// SaveCharacters ( Dolgov , Dolgov ) ;
2262: LD_EXP 58
2266: PPUSH
2267: LD_STRING Dolgov
2269: PPUSH
2270: CALL_OW 38
// if Lipshchin then
2274: LD_EXP 59
2278: IFFALSE 2292
// SaveCharacters ( Lipshchin , Lipshchin ) ;
2280: LD_EXP 59
2284: PPUSH
2285: LD_STRING Lipshchin
2287: PPUSH
2288: CALL_OW 38
// if Karamazov then
2292: LD_EXP 53
2296: IFFALSE 2310
// SaveCharacters ( Karamazov , Karamazov ) ;
2298: LD_EXP 53
2302: PPUSH
2303: LD_STRING Karamazov
2305: PPUSH
2306: CALL_OW 38
// if Petrovova then
2310: LD_EXP 54
2314: IFFALSE 2328
// SaveCharacters ( Petrovova , Petrovova ) ;
2316: LD_EXP 54
2320: PPUSH
2321: LD_STRING Petrovova
2323: PPUSH
2324: CALL_OW 38
// if Gleb then
2328: LD_EXP 55
2332: IFFALSE 2346
// SaveCharacters ( Gleb , Gleb ) ;
2334: LD_EXP 55
2338: PPUSH
2339: LD_STRING Gleb
2341: PPUSH
2342: CALL_OW 38
// if Petrosyan then
2346: LD_EXP 56
2350: IFFALSE 2364
// SaveCharacters ( Petrosyan , Petrosyan ) ;
2352: LD_EXP 56
2356: PPUSH
2357: LD_STRING Petrosyan
2359: PPUSH
2360: CALL_OW 38
// SaveVariable ( Stevens_killed , StevensKilled ) ;
2364: LD_EXP 11
2368: PPUSH
2369: LD_STRING StevensKilled
2371: PPUSH
2372: CALL_OW 39
// SaveVariable ( action_was_fast , OvesyenkoTime ) ;
2376: LD_EXP 9
2380: PPUSH
2381: LD_STRING OvesyenkoTime
2383: PPUSH
2384: CALL_OW 39
// SaveVariable ( IsDead ( Omar ) , OmarKilled ) ;
2388: LD_EXP 62
2392: PPUSH
2393: CALL_OW 301
2397: PPUSH
2398: LD_STRING OmarKilled
2400: PPUSH
2401: CALL_OW 39
// cars := [ ] ;
2405: LD_ADDR_VAR 0 2
2409: PUSH
2410: EMPTY
2411: ST_TO_ADDR
// for i in FilterUnitsInArea ( exit_rus , [ [ f_side , you ] , [ f_type , unit_vehicle ] ] ) do
2412: LD_ADDR_VAR 0 3
2416: PUSH
2417: LD_INT 22
2419: PPUSH
2420: LD_INT 22
2422: PUSH
2423: LD_EXP 1
2427: PUSH
2428: EMPTY
2429: LIST
2430: LIST
2431: PUSH
2432: LD_INT 21
2434: PUSH
2435: LD_INT 2
2437: PUSH
2438: EMPTY
2439: LIST
2440: LIST
2441: PUSH
2442: EMPTY
2443: LIST
2444: LIST
2445: PPUSH
2446: CALL_OW 70
2450: PUSH
2451: FOR_IN
2452: IFFALSE 2542
// begin cargotype := GetCargoType ( i ) ;
2454: LD_ADDR_VAR 0 4
2458: PUSH
2459: LD_VAR 0 3
2463: PPUSH
2464: CALL_OW 288
2468: ST_TO_ADDR
// cars := cars ^ [ [ GetChassis ( i ) , GetWeapon ( i ) , GetNation ( i ) , cargotype , GetCargo ( i , cargotype ) ] ] ;
2469: LD_ADDR_VAR 0 2
2473: PUSH
2474: LD_VAR 0 2
2478: PUSH
2479: LD_VAR 0 3
2483: PPUSH
2484: CALL_OW 265
2488: PUSH
2489: LD_VAR 0 3
2493: PPUSH
2494: CALL_OW 264
2498: PUSH
2499: LD_VAR 0 3
2503: PPUSH
2504: CALL_OW 248
2508: PUSH
2509: LD_VAR 0 4
2513: PUSH
2514: LD_VAR 0 3
2518: PPUSH
2519: LD_VAR 0 4
2523: PPUSH
2524: CALL_OW 289
2528: PUSH
2529: EMPTY
2530: LIST
2531: LIST
2532: LIST
2533: LIST
2534: LIST
2535: PUSH
2536: EMPTY
2537: LIST
2538: ADD
2539: ST_TO_ADDR
// end ;
2540: GO 2451
2542: POP
2543: POP
// SaveVariable ( cars , cars_ru_6 ) ;
2544: LD_VAR 0 2
2548: PPUSH
2549: LD_STRING cars_ru_6
2551: PPUSH
2552: CALL_OW 39
// end ; end_of_file
2556: LD_VAR 0 1
2560: RET
// var Bur , Pla , Kar , Ptr , Glb , Pty , Huck , Tit , Lip , Dol ; var donttalk ; function set_shorts ; begin
2561: LD_INT 0
2563: PPUSH
// Bur := Burlak ;
2564: LD_ADDR_LOC 1
2568: PUSH
2569: LD_EXP 51
2573: ST_TO_ADDR
// Dol := Dolgov ;
2574: LD_ADDR_LOC 10
2578: PUSH
2579: LD_EXP 58
2583: ST_TO_ADDR
// Lip := Lipshchin ;
2584: LD_ADDR_LOC 9
2588: PUSH
2589: LD_EXP 59
2593: ST_TO_ADDR
// Tit := Titov ;
2594: LD_ADDR_LOC 8
2598: PUSH
2599: LD_EXP 57
2603: ST_TO_ADDR
// Pla := Platonov ;
2604: LD_ADDR_LOC 2
2608: PUSH
2609: LD_EXP 52
2613: ST_TO_ADDR
// Kar := Karamazov ;
2614: LD_ADDR_LOC 3
2618: PUSH
2619: LD_EXP 53
2623: ST_TO_ADDR
// Ptr := Petrovova ;
2624: LD_ADDR_LOC 4
2628: PUSH
2629: LD_EXP 54
2633: ST_TO_ADDR
// Glb := Gleb ;
2634: LD_ADDR_LOC 5
2638: PUSH
2639: LD_EXP 55
2643: ST_TO_ADDR
// Pty := Petrosyan ;
2644: LD_ADDR_LOC 6
2648: PUSH
2649: LD_EXP 56
2653: ST_TO_ADDR
// Huck := Stevens ;
2654: LD_ADDR_LOC 7
2658: PUSH
2659: LD_EXP 60
2663: ST_TO_ADDR
// donttalk := used diff [ Burlak , Karamazov , Petrovova , Gleb , Petrosyan ] ;
2664: LD_ADDR_LOC 11
2668: PUSH
2669: LD_EXP 63
2673: PUSH
2674: LD_EXP 51
2678: PUSH
2679: LD_EXP 53
2683: PUSH
2684: LD_EXP 54
2688: PUSH
2689: LD_EXP 55
2693: PUSH
2694: LD_EXP 56
2698: PUSH
2699: EMPTY
2700: LIST
2701: LIST
2702: LIST
2703: LIST
2704: LIST
2705: DIFF
2706: ST_TO_ADDR
// end ;
2707: LD_VAR 0 1
2711: RET
// export function DIntro ; var pos , auta , i , hex , rcars ; begin
2712: LD_INT 0
2714: PPUSH
2715: PPUSH
2716: PPUSH
2717: PPUSH
2718: PPUSH
2719: PPUSH
// pos := [ [ 50 , 39 ] , [ 46 , 42 ] , [ 40 , 50 ] , [ 48 , 57 ] , [ 49 , 59 ] , [ 55 , 70 ] , [ 55 , 73 ] , [ 70 , 86 ] , [ 69 , 83 ] ] ;
2720: LD_ADDR_VAR 0 2
2724: PUSH
2725: LD_INT 50
2727: PUSH
2728: LD_INT 39
2730: PUSH
2731: EMPTY
2732: LIST
2733: LIST
2734: PUSH
2735: LD_INT 46
2737: PUSH
2738: LD_INT 42
2740: PUSH
2741: EMPTY
2742: LIST
2743: LIST
2744: PUSH
2745: LD_INT 40
2747: PUSH
2748: LD_INT 50
2750: PUSH
2751: EMPTY
2752: LIST
2753: LIST
2754: PUSH
2755: LD_INT 48
2757: PUSH
2758: LD_INT 57
2760: PUSH
2761: EMPTY
2762: LIST
2763: LIST
2764: PUSH
2765: LD_INT 49
2767: PUSH
2768: LD_INT 59
2770: PUSH
2771: EMPTY
2772: LIST
2773: LIST
2774: PUSH
2775: LD_INT 55
2777: PUSH
2778: LD_INT 70
2780: PUSH
2781: EMPTY
2782: LIST
2783: LIST
2784: PUSH
2785: LD_INT 55
2787: PUSH
2788: LD_INT 73
2790: PUSH
2791: EMPTY
2792: LIST
2793: LIST
2794: PUSH
2795: LD_INT 70
2797: PUSH
2798: LD_INT 86
2800: PUSH
2801: EMPTY
2802: LIST
2803: LIST
2804: PUSH
2805: LD_INT 69
2807: PUSH
2808: LD_INT 83
2810: PUSH
2811: EMPTY
2812: LIST
2813: LIST
2814: PUSH
2815: EMPTY
2816: LIST
2817: LIST
2818: LIST
2819: LIST
2820: LIST
2821: LIST
2822: LIST
2823: LIST
2824: LIST
2825: ST_TO_ADDR
// set_shorts ;
2826: CALL 2561 0 0
// InGameOn ;
2830: CALL_OW 8
// place_ru_cars ( ru_place2 ) ;
2834: LD_INT 18
2836: PPUSH
2837: CALL 1813 0 1
// RevealFogArea ( you , co_vidi ) ;
2841: LD_EXP 1
2845: PPUSH
2846: LD_INT 19
2848: PPUSH
2849: CALL_OW 332
// auta := FilterAllUnits ( [ [ f_side , you ] , [ f_type , unit_vehicle ] ] ) ;
2853: LD_ADDR_VAR 0 3
2857: PUSH
2858: LD_INT 22
2860: PUSH
2861: LD_EXP 1
2865: PUSH
2866: EMPTY
2867: LIST
2868: LIST
2869: PUSH
2870: LD_INT 21
2872: PUSH
2873: LD_INT 2
2875: PUSH
2876: EMPTY
2877: LIST
2878: LIST
2879: PUSH
2880: EMPTY
2881: LIST
2882: LIST
2883: PPUSH
2884: CALL_OW 69
2888: ST_TO_ADDR
// ComMoveToArea ( auta , ru_dojezd ) ;
2889: LD_VAR 0 3
2893: PPUSH
2894: LD_INT 3
2896: PPUSH
2897: CALL_OW 113
// wait ( 0 0$0.1 ) ;
2901: LD_INT 4
2903: PPUSH
2904: CALL_OW 67
// CenterNowOnUnits ( IsInUnit ( Bur ) ) ;
2908: LD_LOC 1
2912: PPUSH
2913: CALL_OW 310
2917: PPUSH
2918: CALL_OW 87
// while FilterUnitsInArea ( ru_dojezd , [ [ f_side , you ] , [ f_type , unit_vehicle ] ] ) < 5 do
2922: LD_INT 3
2924: PPUSH
2925: LD_INT 22
2927: PUSH
2928: LD_EXP 1
2932: PUSH
2933: EMPTY
2934: LIST
2935: LIST
2936: PUSH
2937: LD_INT 21
2939: PUSH
2940: LD_INT 2
2942: PUSH
2943: EMPTY
2944: LIST
2945: LIST
2946: PUSH
2947: EMPTY
2948: LIST
2949: LIST
2950: PPUSH
2951: CALL_OW 70
2955: PUSH
2956: LD_INT 5
2958: LESS
2959: IFFALSE 2984
// begin wait ( 0 0$1 ) ;
2961: LD_INT 35
2963: PPUSH
2964: CALL_OW 67
// CenterOnUnits ( IsInUnit ( Bur ) ) ;
2968: LD_LOC 1
2972: PPUSH
2973: CALL_OW 310
2977: PPUSH
2978: CALL_OW 85
// end ;
2982: GO 2922
// DStart ;
2984: CALL 2997 0 0
// InGameOff ;
2988: CALL_OW 9
// end ;
2992: LD_VAR 0 1
2996: RET
// export function DStart ; begin
2997: LD_INT 0
2999: PPUSH
// DialogueOn ;
3000: CALL_OW 6
// ComStop ( FilterAllUnits ( [ [ f_side , you ] ] ) ) ;
3004: LD_INT 22
3006: PUSH
3007: LD_EXP 1
3011: PUSH
3012: EMPTY
3013: LIST
3014: LIST
3015: PUSH
3016: EMPTY
3017: LIST
3018: PPUSH
3019: CALL_OW 69
3023: PPUSH
3024: CALL_OW 141
// wait ( 0 0$0.5 ) ;
3028: LD_INT 18
3030: PPUSH
3031: CALL_OW 67
// Say ( Bur , DStart-Bur-1 ) ;
3035: LD_LOC 1
3039: PPUSH
3040: LD_STRING DStart-Bur-1
3042: PPUSH
3043: CALL_OW 88
// SayRadio ( Pla , DStart-Pla-1 ) ;
3047: LD_LOC 2
3051: PPUSH
3052: LD_STRING DStart-Pla-1
3054: PPUSH
3055: CALL_OW 94
// Say ( Bur , DStart-Bur-2 ) ;
3059: LD_LOC 1
3063: PPUSH
3064: LD_STRING DStart-Bur-2
3066: PPUSH
3067: CALL_OW 88
// SayRadio ( Pla , DStart-Pla-2 ) ;
3071: LD_LOC 2
3075: PPUSH
3076: LD_STRING DStart-Pla-2
3078: PPUSH
3079: CALL_OW 94
// SaveForQuickRestart ;
3083: CALL_OW 22
// DialogueOff ;
3087: CALL_OW 7
// ChangeMissionObjectives ( MBegin ) ;
3091: LD_STRING MBegin
3093: PPUSH
3094: CALL_OW 337
// SetAreaMapShow ( exit_rus , 1 ) ;
3098: LD_INT 22
3100: PPUSH
3101: LD_INT 1
3103: PPUSH
3104: CALL_OW 424
// end ;
3108: LD_VAR 0 1
3112: RET
// every 0 0$0.1 trigger dialogy do
3113: LD_EXP 46
3117: IFFALSE 3126
3119: GO 3121
3121: DISABLE
// begin DDoubts ;
3122: CALL 3127 0 0
// end ;
3126: END
// function DDoubts ; var who ; begin
3127: LD_INT 0
3129: PPUSH
3130: PPUSH
// who := WhoSayAny ( donttalk , you , sex_male , 0 , 0 ) ;
3131: LD_ADDR_VAR 0 2
3135: PUSH
3136: LD_LOC 11
3140: PPUSH
3141: LD_EXP 1
3145: PPUSH
3146: LD_INT 1
3148: PPUSH
3149: LD_INT 0
3151: PPUSH
3152: LD_INT 0
3154: PPUSH
3155: CALL 23773 0 5
3159: ST_TO_ADDR
// if not who then
3160: LD_VAR 0 2
3164: NOT
3165: IFFALSE 3177
// who := Bur ;
3167: LD_ADDR_VAR 0 2
3171: PUSH
3172: LD_LOC 1
3176: ST_TO_ADDR
// if IsLive ( Kar ) or IsLive ( Ptr ) then
3177: LD_LOC 3
3181: PPUSH
3182: CALL_OW 300
3186: PUSH
3187: LD_LOC 4
3191: PPUSH
3192: CALL_OW 300
3196: OR
3197: IFFALSE 3283
// begin DialogueOn ;
3199: CALL_OW 6
// Say ( Kar , DDoubts-Kar-1 ) ;
3203: LD_LOC 3
3207: PPUSH
3208: LD_STRING DDoubts-Kar-1
3210: PPUSH
3211: CALL_OW 88
// Say ( Ptr , DDoubts-Ptr-1 ) ;
3215: LD_LOC 4
3219: PPUSH
3220: LD_STRING DDoubts-Ptr-1
3222: PPUSH
3223: CALL_OW 88
// Say ( who , DDoubts-Bur-1 ) ;
3227: LD_VAR 0 2
3231: PPUSH
3232: LD_STRING DDoubts-Bur-1
3234: PPUSH
3235: CALL_OW 88
// if Say ( Kar , DDoubts-Kar-2 ) then
3239: LD_LOC 3
3243: PPUSH
3244: LD_STRING DDoubts-Kar-2
3246: PPUSH
3247: CALL_OW 88
3251: IFFALSE 3279
// if Say ( Glb , DDoubts-Glb-2 ) then
3253: LD_LOC 5
3257: PPUSH
3258: LD_STRING DDoubts-Glb-2
3260: PPUSH
3261: CALL_OW 88
3265: IFFALSE 3279
// Say ( Bur , DDoubts-Bur-2 ) ;
3267: LD_LOC 1
3271: PPUSH
3272: LD_STRING DDoubts-Bur-2
3274: PPUSH
3275: CALL_OW 88
// DialogueOff ;
3279: CALL_OW 7
// end ; end ;
3283: LD_VAR 0 1
3287: RET
// every 0 0$5 trigger dialogy and ( SeeArea ( you , vidi_je ) or See_any ( you , fort ) ) do
3288: LD_EXP 46
3292: PUSH
3293: LD_EXP 1
3297: PPUSH
3298: LD_INT 24
3300: PPUSH
3301: CALL_OW 294
3305: PUSH
3306: LD_EXP 1
3310: PPUSH
3311: LD_EXP 43
3315: PPUSH
3316: CALL 23974 0 2
3320: OR
3321: AND
3322: IFFALSE 3335
3324: GO 3326
3326: DISABLE
// begin DArabs ;
3327: CALL 3336 0 0
// DSurrender ;
3331: CALL 3458 0 0
// end ;
3335: END
// export function DArabs ; var who ; begin
3336: LD_INT 0
3338: PPUSH
3339: PPUSH
// SetAttitude ( you , arabians , att_enemy , true ) ;
3340: LD_EXP 1
3344: PPUSH
3345: LD_EXP 3
3349: PPUSH
3350: LD_INT 2
3352: PPUSH
3353: LD_INT 1
3355: PPUSH
3356: CALL_OW 80
// who := WhoSayAny ( donttalk , you , sex_male , 0 , 0 ) ;
3360: LD_ADDR_VAR 0 2
3364: PUSH
3365: LD_LOC 11
3369: PPUSH
3370: LD_EXP 1
3374: PPUSH
3375: LD_INT 1
3377: PPUSH
3378: LD_INT 0
3380: PPUSH
3381: LD_INT 0
3383: PPUSH
3384: CALL 23773 0 5
3388: ST_TO_ADDR
// DialogueOn ;
3389: CALL_OW 6
// Say ( who , DArabs-RSol1-1 ) ;
3393: LD_VAR 0 2
3397: PPUSH
3398: LD_STRING DArabs-RSol1-1
3400: PPUSH
3401: CALL_OW 88
// Say ( Kar , DArabs-Kar-1 ) ;
3405: LD_LOC 3
3409: PPUSH
3410: LD_STRING DArabs-Kar-1
3412: PPUSH
3413: CALL_OW 88
// Say ( Bur , DArabs-Bur-1 ) ;
3417: LD_LOC 1
3421: PPUSH
3422: LD_STRING DArabs-Bur-1
3424: PPUSH
3425: CALL_OW 88
// SayRadio ( Pla , DArabs-Pla-1 ) ;
3429: LD_LOC 2
3433: PPUSH
3434: LD_STRING DArabs-Pla-1
3436: PPUSH
3437: CALL_OW 94
// DialogueOff ;
3441: CALL_OW 7
// DefendLast := true ;
3445: LD_ADDR_EXP 8
3449: PUSH
3450: LD_INT 1
3452: ST_TO_ADDR
// end ;
3453: LD_VAR 0 1
3457: RET
// function DSurrender ; var qr ; begin
3458: LD_INT 0
3460: PPUSH
3461: PPUSH
// DialogueOn ;
3462: CALL_OW 6
// Say ( Omar , DSurrender-Omar-1 ) ;
3466: LD_EXP 62
3470: PPUSH
3471: LD_STRING DSurrender-Omar-1
3473: PPUSH
3474: CALL_OW 88
// qr := Query ( QSurrender ) ;
3478: LD_ADDR_VAR 0 2
3482: PUSH
3483: LD_STRING QSurrender
3485: PPUSH
3486: CALL_OW 97
3490: ST_TO_ADDR
// case qr of 1 :
3491: LD_VAR 0 2
3495: PUSH
3496: LD_INT 1
3498: DOUBLE
3499: EQUAL
3500: IFTRUE 3504
3502: GO 3511
3504: POP
// DQrSurrender_1 ; 2 :
3505: CALL 3551 0 0
3509: GO 3542
3511: LD_INT 2
3513: DOUBLE
3514: EQUAL
3515: IFTRUE 3519
3517: GO 3526
3519: POP
// DQrSurrender_2 ; 3 :
3520: CALL 3578 0 0
3524: GO 3542
3526: LD_INT 3
3528: DOUBLE
3529: EQUAL
3530: IFTRUE 3534
3532: GO 3541
3534: POP
// DQrSurrender_3 ; end ;
3535: CALL 3606 0 0
3539: GO 3542
3541: POP
// DialogueOff ;
3542: CALL_OW 7
// end ;
3546: LD_VAR 0 1
3550: RET
// function DQrSurrender_1 ; begin
3551: LD_INT 0
3553: PPUSH
// Say ( Bur , DQrSurrender#1-Bur-1 ) ;
3554: LD_LOC 1
3558: PPUSH
3559: LD_STRING DQrSurrender#1-Bur-1
3561: PPUSH
3562: CALL_OW 88
// YouLost ( Surrender ) ;
3566: LD_STRING Surrender
3568: PPUSH
3569: CALL_OW 104
// end ;
3573: LD_VAR 0 1
3577: RET
// function DQrSurrender_2 ; begin
3578: LD_INT 0
3580: PPUSH
// Say ( Bur , DQrSurrender#2-Bur-1 ) ;
3581: LD_LOC 1
3585: PPUSH
3586: LD_STRING DQrSurrender#2-Bur-1
3588: PPUSH
3589: CALL_OW 88
// wait_while := true ;
3593: LD_ADDR_EXP 12
3597: PUSH
3598: LD_INT 1
3600: ST_TO_ADDR
// end ;
3601: LD_VAR 0 1
3605: RET
// function DQrSurrender_3 ; begin
3606: LD_INT 0
3608: PPUSH
// Say ( Bur , DQrSurrender#3-Bur-1 ) ;
3609: LD_LOC 1
3613: PPUSH
3614: LD_STRING DQrSurrender#3-Bur-1
3616: PPUSH
3617: CALL_OW 88
// end ;
3621: LD_VAR 0 1
3625: RET
// every 0 0$1 trigger dialogy and ( FilterUnitsInArea ( enter_other_side , [ [ f_sex , sex_male ] , [ f_side , you ] , [ f_nation , nation_russian ] ] ) ) do var b ;
3626: LD_EXP 46
3630: PUSH
3631: LD_INT 8
3633: PPUSH
3634: LD_INT 26
3636: PUSH
3637: LD_INT 1
3639: PUSH
3640: EMPTY
3641: LIST
3642: LIST
3643: PUSH
3644: LD_INT 22
3646: PUSH
3647: LD_EXP 1
3651: PUSH
3652: EMPTY
3653: LIST
3654: LIST
3655: PUSH
3656: LD_INT 23
3658: PUSH
3659: LD_INT 3
3661: PUSH
3662: EMPTY
3663: LIST
3664: LIST
3665: PUSH
3666: EMPTY
3667: LIST
3668: LIST
3669: LIST
3670: PPUSH
3671: CALL_OW 70
3675: AND
3676: IFFALSE 3762
3678: GO 3680
3680: DISABLE
3681: LD_INT 0
3683: PPUSH
// begin b := donttalk isect FilterUnitsInArea ( enter_other_side , [ [ f_sex , sex_male ] , [ f_side , you ] , [ f_nation , nation_russian ] ] ) ;
3684: LD_ADDR_VAR 0 1
3688: PUSH
3689: LD_LOC 11
3693: PUSH
3694: LD_INT 8
3696: PPUSH
3697: LD_INT 26
3699: PUSH
3700: LD_INT 1
3702: PUSH
3703: EMPTY
3704: LIST
3705: LIST
3706: PUSH
3707: LD_INT 22
3709: PUSH
3710: LD_EXP 1
3714: PUSH
3715: EMPTY
3716: LIST
3717: LIST
3718: PUSH
3719: LD_INT 23
3721: PUSH
3722: LD_INT 3
3724: PUSH
3725: EMPTY
3726: LIST
3727: LIST
3728: PUSH
3729: EMPTY
3730: LIST
3731: LIST
3732: LIST
3733: PPUSH
3734: CALL_OW 70
3738: ISECT
3739: ST_TO_ADDR
// if b then
3740: LD_VAR 0 1
3744: IFFALSE 3761
// DShipments ( b [ 1 ] ) else
3746: LD_VAR 0 1
3750: PUSH
3751: LD_INT 1
3753: ARRAY
3754: PPUSH
3755: CALL 3765 0 1
3759: GO 3762
// enable ;
3761: ENABLE
// end ;
3762: PPOPN 1
3764: END
// function DShipments ( who ) ; begin
3765: LD_INT 0
3767: PPUSH
// CreateCratesArea ( 5 , second_crate , true ) ;
3768: LD_INT 5
3770: PPUSH
3771: LD_INT 7
3773: PPUSH
3774: LD_INT 1
3776: PPUSH
3777: CALL_OW 55
// wait ( 0 0$6 ) ;
3781: LD_INT 210
3783: PPUSH
3784: CALL_OW 67
// DialogueOn ;
3788: CALL_OW 6
// if Say ( who , DShipments-RSol1-1 ) then
3792: LD_VAR 0 1
3796: PPUSH
3797: LD_STRING DShipments-RSol1-1
3799: PPUSH
3800: CALL_OW 88
3804: IFFALSE 3832
// if Say ( Bur , DShipments-Bur-1 ) then
3806: LD_LOC 1
3810: PPUSH
3811: LD_STRING DShipments-Bur-1
3813: PPUSH
3814: CALL_OW 88
3818: IFFALSE 3832
// Say ( who , DShipments-RSol1-2 ) ;
3820: LD_VAR 0 1
3824: PPUSH
3825: LD_STRING DShipments-RSol1-2
3827: PPUSH
3828: CALL_OW 88
// DialogueOff ;
3832: CALL_OW 7
// end ;
3836: LD_VAR 0 2
3840: RET
// every 0 0$3 + 0 0$2 trigger dialogy and ( FilterUnitsInArea ( enter_near_road , [ [ f_sex , sex_male ] , [ f_side , you ] , [ f_nation , nation_russian ] ] ) ) do var b ;
3841: LD_EXP 46
3845: PUSH
3846: LD_INT 9
3848: PPUSH
3849: LD_INT 26
3851: PUSH
3852: LD_INT 1
3854: PUSH
3855: EMPTY
3856: LIST
3857: LIST
3858: PUSH
3859: LD_INT 22
3861: PUSH
3862: LD_EXP 1
3866: PUSH
3867: EMPTY
3868: LIST
3869: LIST
3870: PUSH
3871: LD_INT 23
3873: PUSH
3874: LD_INT 3
3876: PUSH
3877: EMPTY
3878: LIST
3879: LIST
3880: PUSH
3881: EMPTY
3882: LIST
3883: LIST
3884: LIST
3885: PPUSH
3886: CALL_OW 70
3890: AND
3891: IFFALSE 3977
3893: GO 3895
3895: DISABLE
3896: LD_INT 0
3898: PPUSH
// begin b := donttalk isect FilterUnitsInArea ( enter_other_side , [ [ f_sex , sex_male ] , [ f_side , you ] , [ f_nation , nation_russian ] ] ) ;
3899: LD_ADDR_VAR 0 1
3903: PUSH
3904: LD_LOC 11
3908: PUSH
3909: LD_INT 8
3911: PPUSH
3912: LD_INT 26
3914: PUSH
3915: LD_INT 1
3917: PUSH
3918: EMPTY
3919: LIST
3920: LIST
3921: PUSH
3922: LD_INT 22
3924: PUSH
3925: LD_EXP 1
3929: PUSH
3930: EMPTY
3931: LIST
3932: LIST
3933: PUSH
3934: LD_INT 23
3936: PUSH
3937: LD_INT 3
3939: PUSH
3940: EMPTY
3941: LIST
3942: LIST
3943: PUSH
3944: EMPTY
3945: LIST
3946: LIST
3947: LIST
3948: PPUSH
3949: CALL_OW 70
3953: ISECT
3954: ST_TO_ADDR
// if b then
3955: LD_VAR 0 1
3959: IFFALSE 3976
// DRoad ( b [ 1 ] ) else
3961: LD_VAR 0 1
3965: PUSH
3966: LD_INT 1
3968: ARRAY
3969: PPUSH
3970: CALL 3980 0 1
3974: GO 3977
// enable ;
3976: ENABLE
// end ;
3977: PPOPN 1
3979: END
// function DRoad ( who ) ; begin
3980: LD_INT 0
3982: PPUSH
// if who <> Burlak then
3983: LD_VAR 0 1
3987: PUSH
3988: LD_EXP 51
3992: NONEQUAL
3993: IFFALSE 4034
// begin DialogueOn ;
3995: CALL_OW 6
// Say ( who , DRoad-RSol1-1 ) ;
3999: LD_VAR 0 1
4003: PPUSH
4004: LD_STRING DRoad-RSol1-1
4006: PPUSH
4007: CALL_OW 88
// if not breaked_trough then
4011: LD_EXP 10
4015: NOT
4016: IFFALSE 4030
// Say ( who , DRoad-RSol1-1a ) ;
4018: LD_VAR 0 1
4022: PPUSH
4023: LD_STRING DRoad-RSol1-1a
4025: PPUSH
4026: CALL_OW 88
// DialogueOff ;
4030: CALL_OW 7
// end ; end ;
4034: LD_VAR 0 2
4038: RET
// every 0 0$3 + 0 0$2 trigger dialogy and see_any ( you , UnitFilter ( apemans , [ [ f_side , neutral ] ] ) ) do var a ;
4039: LD_EXP 46
4043: PUSH
4044: LD_EXP 1
4048: PPUSH
4049: LD_EXP 7
4053: PPUSH
4054: LD_INT 22
4056: PUSH
4057: LD_EXP 4
4061: PUSH
4062: EMPTY
4063: LIST
4064: LIST
4065: PUSH
4066: EMPTY
4067: LIST
4068: PPUSH
4069: CALL_OW 72
4073: PPUSH
4074: CALL 23974 0 2
4078: AND
4079: IFFALSE 4261
4081: GO 4083
4083: DISABLE
4084: LD_INT 0
4086: PPUSH
// begin a := ( FilterAllUnits ( [ [ f_side , you ] , [ f_see , neutral ] ] ) isect donttalk ) ^ Burlak ;
4087: LD_ADDR_VAR 0 1
4091: PUSH
4092: LD_INT 22
4094: PUSH
4095: LD_EXP 1
4099: PUSH
4100: EMPTY
4101: LIST
4102: LIST
4103: PUSH
4104: LD_INT 101
4106: PUSH
4107: LD_EXP 4
4111: PUSH
4112: EMPTY
4113: LIST
4114: LIST
4115: PUSH
4116: EMPTY
4117: LIST
4118: LIST
4119: PPUSH
4120: CALL_OW 69
4124: PUSH
4125: LD_LOC 11
4129: ISECT
4130: PUSH
4131: LD_EXP 51
4135: ADD
4136: ST_TO_ADDR
// if a then
4137: LD_VAR 0 1
4141: IFFALSE 4260
// begin if not GetTech ( tech_ApeLang , you ) = state_researched then
4143: LD_INT 1
4145: PPUSH
4146: LD_EXP 1
4150: PPUSH
4151: CALL_OW 321
4155: PUSH
4156: LD_INT 2
4158: EQUAL
4159: NOT
4160: IFFALSE 4258
// begin DApeSpot ( a [ Rand ( 1 , a ) ] ) ;
4162: LD_VAR 0 1
4166: PUSH
4167: LD_INT 1
4169: PPUSH
4170: LD_VAR 0 1
4174: PPUSH
4175: CALL_OW 12
4179: ARRAY
4180: PPUSH
4181: CALL 4264 0 1
// wait ( 2 2$0 ) ;
4185: LD_INT 4200
4187: PPUSH
4188: CALL_OW 67
// if not FilterAllUnits ( [ [ f_side , you ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) then
4192: LD_INT 22
4194: PUSH
4195: LD_EXP 1
4199: PUSH
4200: EMPTY
4201: LIST
4202: LIST
4203: PUSH
4204: LD_INT 2
4206: PUSH
4207: LD_INT 30
4209: PUSH
4210: LD_INT 6
4212: PUSH
4213: EMPTY
4214: LIST
4215: LIST
4216: PUSH
4217: LD_INT 30
4219: PUSH
4220: LD_INT 7
4222: PUSH
4223: EMPTY
4224: LIST
4225: LIST
4226: PUSH
4227: LD_INT 30
4229: PUSH
4230: LD_INT 8
4232: PUSH
4233: EMPTY
4234: LIST
4235: LIST
4236: PUSH
4237: EMPTY
4238: LIST
4239: LIST
4240: LIST
4241: LIST
4242: PUSH
4243: EMPTY
4244: LIST
4245: LIST
4246: PPUSH
4247: CALL_OW 69
4251: NOT
4252: IFFALSE 4258
// DApeLab ;
4254: CALL 4487 0 0
// end ; end else
4258: GO 4261
// enable ;
4260: ENABLE
// end ;
4261: PPOPN 1
4263: END
// function DApeSpot ( who ) ; var Sci1 ; begin
4264: LD_INT 0
4266: PPUSH
4267: PPUSH
// Sci1 := Pty ;
4268: LD_ADDR_VAR 0 3
4272: PUSH
4273: LD_LOC 6
4277: ST_TO_ADDR
// if not IsLive ( Pty ) then
4278: LD_LOC 6
4282: PPUSH
4283: CALL_OW 300
4287: NOT
4288: IFFALSE 4319
// Sci1 := WhoSayAny ( donttalk , you , sex_male , class_scientistic , 0 ) ;
4290: LD_ADDR_VAR 0 3
4294: PUSH
4295: LD_LOC 11
4299: PPUSH
4300: LD_EXP 1
4304: PPUSH
4305: LD_INT 1
4307: PPUSH
4308: LD_INT 4
4310: PPUSH
4311: LD_INT 0
4313: PPUSH
4314: CALL 23773 0 5
4318: ST_TO_ADDR
// DialogueOn ;
4319: CALL_OW 6
// if who = Bur then
4323: LD_VAR 0 1
4327: PUSH
4328: LD_LOC 1
4332: EQUAL
4333: IFFALSE 4349
// Say ( Bur , DApeSpot-Bur-1a ) else
4335: LD_LOC 1
4339: PPUSH
4340: LD_STRING DApeSpot-Bur-1a
4342: PPUSH
4343: CALL_OW 88
4347: GO 4373
// begin Say ( Bur , DApeSpot-Bur-1 ) ;
4349: LD_LOC 1
4353: PPUSH
4354: LD_STRING DApeSpot-Bur-1
4356: PPUSH
4357: CALL_OW 88
// Say ( who , DApeSpot-RSol1-1 ) ;
4361: LD_VAR 0 1
4365: PPUSH
4366: LD_STRING DApeSpot-RSol1-1
4368: PPUSH
4369: CALL_OW 88
// end ; if Sci1 then
4373: LD_VAR 0 3
4377: IFFALSE 4478
// begin Say ( Sci1 , DApeSpot-Pty-1 ) ;
4379: LD_VAR 0 3
4383: PPUSH
4384: LD_STRING DApeSpot-Pty-1
4386: PPUSH
4387: CALL_OW 88
// if FilterAllUnits ( [ [ f_side , you ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) then
4391: LD_INT 22
4393: PUSH
4394: LD_EXP 1
4398: PUSH
4399: EMPTY
4400: LIST
4401: LIST
4402: PUSH
4403: LD_INT 2
4405: PUSH
4406: LD_INT 30
4408: PUSH
4409: LD_INT 6
4411: PUSH
4412: EMPTY
4413: LIST
4414: LIST
4415: PUSH
4416: LD_INT 30
4418: PUSH
4419: LD_INT 7
4421: PUSH
4422: EMPTY
4423: LIST
4424: LIST
4425: PUSH
4426: LD_INT 30
4428: PUSH
4429: LD_INT 8
4431: PUSH
4432: EMPTY
4433: LIST
4434: LIST
4435: PUSH
4436: EMPTY
4437: LIST
4438: LIST
4439: LIST
4440: LIST
4441: PUSH
4442: EMPTY
4443: LIST
4444: LIST
4445: PPUSH
4446: CALL_OW 69
4450: IFFALSE 4466
// Say ( Sci1 , DApeSpot-Pty-1a ) else
4452: LD_VAR 0 3
4456: PPUSH
4457: LD_STRING DApeSpot-Pty-1a
4459: PPUSH
4460: CALL_OW 88
4464: GO 4478
// Say ( Sci1 , DApeSpot-Pty-1b ) ;
4466: LD_VAR 0 3
4470: PPUSH
4471: LD_STRING DApeSpot-Pty-1b
4473: PPUSH
4474: CALL_OW 88
// end ; DialogueOff ;
4478: CALL_OW 7
// end ;
4482: LD_VAR 0 2
4486: RET
// function DApeLab ; var Sci1 ; begin
4487: LD_INT 0
4489: PPUSH
4490: PPUSH
// Sci1 := Pty ;
4491: LD_ADDR_VAR 0 2
4495: PUSH
4496: LD_LOC 6
4500: ST_TO_ADDR
// if not IsLive ( Pty ) then
4501: LD_LOC 6
4505: PPUSH
4506: CALL_OW 300
4510: NOT
4511: IFFALSE 4542
// Sci1 := WhoSayAny ( donttalk , you , sex_male , class_scientistic , 0 ) ;
4513: LD_ADDR_VAR 0 2
4517: PUSH
4518: LD_LOC 11
4522: PPUSH
4523: LD_EXP 1
4527: PPUSH
4528: LD_INT 1
4530: PPUSH
4531: LD_INT 4
4533: PPUSH
4534: LD_INT 0
4536: PPUSH
4537: CALL 23773 0 5
4541: ST_TO_ADDR
// if Sci1 then
4542: LD_VAR 0 2
4546: IFFALSE 4568
// begin DialogueOn ;
4548: CALL_OW 6
// Say ( Sci1 , DApeLab-Pty-1 ) ;
4552: LD_VAR 0 2
4556: PPUSH
4557: LD_STRING DApeLab-Pty-1
4559: PPUSH
4560: CALL_OW 88
// DialogueOff ;
4564: CALL_OW 7
// end ; end ;
4568: LD_VAR 0 1
4572: RET
// export function DApeLangCompl ; var Sci1 ; begin
4573: LD_INT 0
4575: PPUSH
4576: PPUSH
// Sci1 := Pty ;
4577: LD_ADDR_VAR 0 2
4581: PUSH
4582: LD_LOC 6
4586: ST_TO_ADDR
// if not IsLive ( Pty ) then
4587: LD_LOC 6
4591: PPUSH
4592: CALL_OW 300
4596: NOT
4597: IFFALSE 4628
// Sci1 := WhoSayAny ( donttalk , you , sex_male , class_scientistic , 0 ) ;
4599: LD_ADDR_VAR 0 2
4603: PUSH
4604: LD_LOC 11
4608: PPUSH
4609: LD_EXP 1
4613: PPUSH
4614: LD_INT 1
4616: PPUSH
4617: LD_INT 4
4619: PPUSH
4620: LD_INT 0
4622: PPUSH
4623: CALL 23773 0 5
4627: ST_TO_ADDR
// if Sci1 then
4628: LD_VAR 0 2
4632: IFFALSE 4726
// begin DialogueOn ;
4634: CALL_OW 6
// Say ( Sci1 , DApeLangCompl-Pty-1 ) ;
4638: LD_VAR 0 2
4642: PPUSH
4643: LD_STRING DApeLangCompl-Pty-1
4645: PPUSH
4646: CALL_OW 88
// Say ( Bur , DApeLangCompl-Bur-1 ) ;
4650: LD_LOC 1
4654: PPUSH
4655: LD_STRING DApeLangCompl-Bur-1
4657: PPUSH
4658: CALL_OW 88
// Say ( Sci1 , DApeLangCompl-Pty-2 ) ;
4662: LD_VAR 0 2
4666: PPUSH
4667: LD_STRING DApeLangCompl-Pty-2
4669: PPUSH
4670: CALL_OW 88
// Say ( Bur , DApeLangCompl-Bur-2 ) ;
4674: LD_LOC 1
4678: PPUSH
4679: LD_STRING DApeLangCompl-Bur-2
4681: PPUSH
4682: CALL_OW 88
// Say ( Sci1 , DApeLangCompl-Pty-3 ) ;
4686: LD_VAR 0 2
4690: PPUSH
4691: LD_STRING DApeLangCompl-Pty-3
4693: PPUSH
4694: CALL_OW 88
// Say ( Bur , DApeLangCompl-Bur-3 ) ;
4698: LD_LOC 1
4702: PPUSH
4703: LD_STRING DApeLangCompl-Bur-3
4705: PPUSH
4706: CALL_OW 88
// Say ( Sci1 , DApeLangCompl-Pty-4 ) ;
4710: LD_VAR 0 2
4714: PPUSH
4715: LD_STRING DApeLangCompl-Pty-4
4717: PPUSH
4718: CALL_OW 88
// DialogueOff ;
4722: CALL_OW 7
// end ; MyHint ( ApemenTaming ) ;
4726: LD_STRING ApemenTaming
4728: PPUSH
4729: CALL 25694 0 1
// end ;
4733: LD_VAR 0 1
4737: RET
// export function DApeTame ; var Sci1 ; begin
4738: LD_INT 0
4740: PPUSH
4741: PPUSH
// first_apeman_tamed := true ;
4742: LD_ADDR_EXP 45
4746: PUSH
4747: LD_INT 1
4749: ST_TO_ADDR
// Sci1 := Pty ;
4750: LD_ADDR_VAR 0 2
4754: PUSH
4755: LD_LOC 6
4759: ST_TO_ADDR
// if not IsLive ( Pty ) then
4760: LD_LOC 6
4764: PPUSH
4765: CALL_OW 300
4769: NOT
4770: IFFALSE 4801
// Sci1 := WhoSayAny ( donttalk , you , sex_male , class_scientistic , 0 ) ;
4772: LD_ADDR_VAR 0 2
4776: PUSH
4777: LD_LOC 11
4781: PPUSH
4782: LD_EXP 1
4786: PPUSH
4787: LD_INT 1
4789: PPUSH
4790: LD_INT 4
4792: PPUSH
4793: LD_INT 0
4795: PPUSH
4796: CALL 23773 0 5
4800: ST_TO_ADDR
// if Sci1 then
4801: LD_VAR 0 2
4805: IFFALSE 4839
// begin DialogueOn ;
4807: CALL_OW 6
// Say ( Sci1 , DApeTame-Sci1-1 ) ;
4811: LD_VAR 0 2
4815: PPUSH
4816: LD_STRING DApeTame-Sci1-1
4818: PPUSH
4819: CALL_OW 88
// Say ( Bur , DApeTame-Bur-1 ) ;
4823: LD_LOC 1
4827: PPUSH
4828: LD_STRING DApeTame-Bur-1
4830: PPUSH
4831: CALL_OW 88
// DialogueOff ;
4835: CALL_OW 7
// end ; end ;
4839: LD_VAR 0 1
4843: RET
// function ApemansInLabs ; var labs , i , inlabs ; begin
4844: LD_INT 0
4846: PPUSH
4847: PPUSH
4848: PPUSH
4849: PPUSH
// inlabs := [ ] ;
4850: LD_ADDR_VAR 0 4
4854: PUSH
4855: EMPTY
4856: ST_TO_ADDR
// labs := FilterAllUnits ( [ [ f_side , you ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ;
4857: LD_ADDR_VAR 0 2
4861: PUSH
4862: LD_INT 22
4864: PUSH
4865: LD_EXP 1
4869: PUSH
4870: EMPTY
4871: LIST
4872: LIST
4873: PUSH
4874: LD_INT 2
4876: PUSH
4877: LD_INT 30
4879: PUSH
4880: LD_INT 6
4882: PUSH
4883: EMPTY
4884: LIST
4885: LIST
4886: PUSH
4887: LD_INT 30
4889: PUSH
4890: LD_INT 7
4892: PUSH
4893: EMPTY
4894: LIST
4895: LIST
4896: PUSH
4897: LD_INT 30
4899: PUSH
4900: LD_INT 8
4902: PUSH
4903: EMPTY
4904: LIST
4905: LIST
4906: PUSH
4907: EMPTY
4908: LIST
4909: LIST
4910: LIST
4911: LIST
4912: PUSH
4913: EMPTY
4914: LIST
4915: LIST
4916: PPUSH
4917: CALL_OW 69
4921: ST_TO_ADDR
// for i in labs do
4922: LD_ADDR_VAR 0 3
4926: PUSH
4927: LD_VAR 0 2
4931: PUSH
4932: FOR_IN
4933: IFFALSE 4958
// inlabs := inlabs ^ UnitsInside ( i ) ;
4935: LD_ADDR_VAR 0 4
4939: PUSH
4940: LD_VAR 0 4
4944: PUSH
4945: LD_VAR 0 3
4949: PPUSH
4950: CALL_OW 313
4954: ADD
4955: ST_TO_ADDR
4956: GO 4932
4958: POP
4959: POP
// result := UnitFilter ( inlabs , [ [ f_nation , nation_nature ] ] ) ;
4960: LD_ADDR_VAR 0 1
4964: PUSH
4965: LD_VAR 0 4
4969: PPUSH
4970: LD_INT 23
4972: PUSH
4973: LD_INT 0
4975: PUSH
4976: EMPTY
4977: LIST
4978: LIST
4979: PUSH
4980: EMPTY
4981: LIST
4982: PPUSH
4983: CALL_OW 72
4987: ST_TO_ADDR
// end ;
4988: LD_VAR 0 1
4992: RET
// every 0 0$3 trigger dialogy and ApemansInLabs do
4993: LD_EXP 46
4997: PUSH
4998: CALL 4844 0 0
5002: AND
5003: IFFALSE 5012
5005: GO 5007
5007: DISABLE
// begin DApeWorkSol ;
5008: CALL 5013 0 0
// end ;
5012: END
// function DApeWorkSol ; var Sci1 ; begin
5013: LD_INT 0
5015: PPUSH
5016: PPUSH
// Sci1 := Pty ;
5017: LD_ADDR_VAR 0 2
5021: PUSH
5022: LD_LOC 6
5026: ST_TO_ADDR
// if not IsLive ( Pty ) then
5027: LD_LOC 6
5031: PPUSH
5032: CALL_OW 300
5036: NOT
5037: IFFALSE 5068
// Sci1 := WhoSayAny ( donttalk , you , sex_male , class_scientistic , 0 ) ;
5039: LD_ADDR_VAR 0 2
5043: PUSH
5044: LD_LOC 11
5048: PPUSH
5049: LD_EXP 1
5053: PPUSH
5054: LD_INT 1
5056: PPUSH
5057: LD_INT 4
5059: PPUSH
5060: LD_INT 0
5062: PPUSH
5063: CALL 23773 0 5
5067: ST_TO_ADDR
// if Sci1 then
5068: LD_VAR 0 2
5072: IFFALSE 5127
// begin DialogueOn ;
5074: CALL_OW 6
// Say ( Bur , DApeWorkSol-Bur-1 ) ;
5078: LD_LOC 1
5082: PPUSH
5083: LD_STRING DApeWorkSol-Bur-1
5085: PPUSH
5086: CALL_OW 88
// if Say ( Sci1 , DApeWorkSol-Pty-1 ) then
5090: LD_VAR 0 2
5094: PPUSH
5095: LD_STRING DApeWorkSol-Pty-1
5097: PPUSH
5098: CALL_OW 88
5102: IFFALSE 5116
// Say ( Bur , DApeWorkSol-Bur-2 ) ;
5104: LD_LOC 1
5108: PPUSH
5109: LD_STRING DApeWorkSol-Bur-2
5111: PPUSH
5112: CALL_OW 88
// MyHint ( ApemenUsing ) ;
5116: LD_STRING ApemenUsing
5118: PPUSH
5119: CALL 25694 0 1
// DialogueOff ;
5123: CALL_OW 7
// end ; end ;
5127: LD_VAR 0 1
5131: RET
// export function DApeWorkCompl ; var Sci1 ; begin
5132: LD_INT 0
5134: PPUSH
5135: PPUSH
// first_apeman_tamed := true ;
5136: LD_ADDR_EXP 45
5140: PUSH
5141: LD_INT 1
5143: ST_TO_ADDR
// Sci1 := Pty ;
5144: LD_ADDR_VAR 0 2
5148: PUSH
5149: LD_LOC 6
5153: ST_TO_ADDR
// if not IsLive ( Pty ) then
5154: LD_LOC 6
5158: PPUSH
5159: CALL_OW 300
5163: NOT
5164: IFFALSE 5195
// Sci1 := WhoSayAny ( donttalk , you , sex_male , class_scientistic , 0 ) ;
5166: LD_ADDR_VAR 0 2
5170: PUSH
5171: LD_LOC 11
5175: PPUSH
5176: LD_EXP 1
5180: PPUSH
5181: LD_INT 1
5183: PPUSH
5184: LD_INT 4
5186: PPUSH
5187: LD_INT 0
5189: PPUSH
5190: CALL 23773 0 5
5194: ST_TO_ADDR
// if Sci1 then
5195: LD_VAR 0 2
5199: IFFALSE 5235
// begin DialogueOn ;
5201: CALL_OW 6
// if Say ( Sci1 , DApeWorkCompl-Pty-1 ) then
5205: LD_VAR 0 2
5209: PPUSH
5210: LD_STRING DApeWorkCompl-Pty-1
5212: PPUSH
5213: CALL_OW 88
5217: IFFALSE 5231
// Say ( Bur , DApeWorkCompl-Bur-1 ) ;
5219: LD_LOC 1
5223: PPUSH
5224: LD_STRING DApeWorkCompl-Bur-1
5226: PPUSH
5227: CALL_OW 88
// DialogueOff ;
5231: CALL_OW 7
// end ; end ;
5235: LD_VAR 0 1
5239: RET
// export function DApeSolCompl ; var Sci1 ; begin
5240: LD_INT 0
5242: PPUSH
5243: PPUSH
// Sci1 := Pty ;
5244: LD_ADDR_VAR 0 2
5248: PUSH
5249: LD_LOC 6
5253: ST_TO_ADDR
// if not IsLive ( Pty ) then
5254: LD_LOC 6
5258: PPUSH
5259: CALL_OW 300
5263: NOT
5264: IFFALSE 5295
// Sci1 := WhoSayAny ( donttalk , you , sex_male , class_scientistic , 0 ) ;
5266: LD_ADDR_VAR 0 2
5270: PUSH
5271: LD_LOC 11
5275: PPUSH
5276: LD_EXP 1
5280: PPUSH
5281: LD_INT 1
5283: PPUSH
5284: LD_INT 4
5286: PPUSH
5287: LD_INT 0
5289: PPUSH
5290: CALL 23773 0 5
5294: ST_TO_ADDR
// if Sci1 then
5295: LD_VAR 0 2
5299: IFFALSE 5335
// begin DialogueOn ;
5301: CALL_OW 6
// if Say ( Sci1 , DApeSolCompl-Pty-1 ) then
5305: LD_VAR 0 2
5309: PPUSH
5310: LD_STRING DApeSolCompl-Pty-1
5312: PPUSH
5313: CALL_OW 88
5317: IFFALSE 5331
// Say ( Bur , DApeSolCompl-Bur-1 ) ;
5319: LD_LOC 1
5323: PPUSH
5324: LD_STRING DApeSolCompl-Bur-1
5326: PPUSH
5327: CALL_OW 88
// DialogueOff ;
5331: CALL_OW 7
// end ; end ;
5335: LD_VAR 0 1
5339: RET
// every 0 0$5 + 0 0$4 trigger dialogy and not byl_stevens and depot and ( FilterUnitsInArea ( apemans_site , [ [ f_side , you ] , [ f_nation , nation_russian ] ] ) diff [ Burlak , Petrovova , Gleb ] ) do var tmp ;
5340: LD_EXP 46
5344: PUSH
5345: LD_EXP 67
5349: NOT
5350: AND
5351: PUSH
5352: LD_EXP 14
5356: AND
5357: PUSH
5358: LD_INT 10
5360: PPUSH
5361: LD_INT 22
5363: PUSH
5364: LD_EXP 1
5368: PUSH
5369: EMPTY
5370: LIST
5371: LIST
5372: PUSH
5373: LD_INT 23
5375: PUSH
5376: LD_INT 3
5378: PUSH
5379: EMPTY
5380: LIST
5381: LIST
5382: PUSH
5383: EMPTY
5384: LIST
5385: LIST
5386: PPUSH
5387: CALL_OW 70
5391: PUSH
5392: LD_EXP 51
5396: PUSH
5397: LD_EXP 54
5401: PUSH
5402: LD_EXP 55
5406: PUSH
5407: EMPTY
5408: LIST
5409: LIST
5410: LIST
5411: DIFF
5412: AND
5413: IFFALSE 5650
5415: GO 5417
5417: DISABLE
5418: LD_INT 0
5420: PPUSH
// begin if IsDead ( Pty ) then
5421: LD_LOC 6
5425: PPUSH
5426: CALL_OW 301
5430: IFFALSE 5442
// Pty := Dol ;
5432: LD_ADDR_LOC 6
5436: PUSH
5437: LD_LOC 10
5441: ST_TO_ADDR
// if IsDead ( Pty ) then
5442: LD_LOC 6
5446: PPUSH
5447: CALL_OW 301
5451: IFFALSE 5463
// Pty := Kar ;
5453: LD_ADDR_LOC 6
5457: PUSH
5458: LD_LOC 3
5462: ST_TO_ADDR
// if Pty in FilterUnitsInArea ( apemans_site , [ [ f_side , you ] , [ f_nation , nation_russian ] ] ) then
5463: LD_LOC 6
5467: PUSH
5468: LD_INT 10
5470: PPUSH
5471: LD_INT 22
5473: PUSH
5474: LD_EXP 1
5478: PUSH
5479: EMPTY
5480: LIST
5481: LIST
5482: PUSH
5483: LD_INT 23
5485: PUSH
5486: LD_INT 3
5488: PUSH
5489: EMPTY
5490: LIST
5491: LIST
5492: PUSH
5493: EMPTY
5494: LIST
5495: LIST
5496: PPUSH
5497: CALL_OW 70
5501: IN
5502: IFFALSE 5515
// DStevens ( Pty ) else
5504: LD_LOC 6
5508: PPUSH
5509: CALL 5864 0 1
5513: GO 5650
// begin tmp := FilterUnitsInArea ( apemans_site , [ [ f_side , you ] , [ f_nation , nation_russian ] , [ f_sex , sex_male ] ] ) diff Burlak ;
5515: LD_ADDR_VAR 0 1
5519: PUSH
5520: LD_INT 10
5522: PPUSH
5523: LD_INT 22
5525: PUSH
5526: LD_EXP 1
5530: PUSH
5531: EMPTY
5532: LIST
5533: LIST
5534: PUSH
5535: LD_INT 23
5537: PUSH
5538: LD_INT 3
5540: PUSH
5541: EMPTY
5542: LIST
5543: LIST
5544: PUSH
5545: LD_INT 26
5547: PUSH
5548: LD_INT 1
5550: PUSH
5551: EMPTY
5552: LIST
5553: LIST
5554: PUSH
5555: EMPTY
5556: LIST
5557: LIST
5558: LIST
5559: PPUSH
5560: CALL_OW 70
5564: PUSH
5565: LD_EXP 51
5569: DIFF
5570: ST_TO_ADDR
// if not tmp then
5571: LD_VAR 0 1
5575: NOT
5576: IFFALSE 5631
// tmp := FilterAllUnits ( [ [ f_side , you ] , [ f_nation , nation_russian ] , [ f_sex , sex_male ] ] ) diff Burlak ;
5578: LD_ADDR_VAR 0 1
5582: PUSH
5583: LD_INT 22
5585: PUSH
5586: LD_EXP 1
5590: PUSH
5591: EMPTY
5592: LIST
5593: LIST
5594: PUSH
5595: LD_INT 23
5597: PUSH
5598: LD_INT 3
5600: PUSH
5601: EMPTY
5602: LIST
5603: LIST
5604: PUSH
5605: LD_INT 26
5607: PUSH
5608: LD_INT 1
5610: PUSH
5611: EMPTY
5612: LIST
5613: LIST
5614: PUSH
5615: EMPTY
5616: LIST
5617: LIST
5618: LIST
5619: PPUSH
5620: CALL_OW 69
5624: PUSH
5625: LD_EXP 51
5629: DIFF
5630: ST_TO_ADDR
// if tmp then
5631: LD_VAR 0 1
5635: IFFALSE 5650
// DStevens ( tmp [ 1 ] ) ;
5637: LD_VAR 0 1
5641: PUSH
5642: LD_INT 1
5644: ARRAY
5645: PPUSH
5646: CALL 5864 0 1
// end ; end ;
5650: PPOPN 1
5652: END
// every 0 0$5 + 0 0$4 trigger dialogy and not byl_stevens and ( FilterUnitsInArea ( uz_jedou_dolem , [ [ f_side , you ] , [ f_type , unit_vehicle ] ] ) > 3 ) do
5653: LD_EXP 46
5657: PUSH
5658: LD_EXP 67
5662: NOT
5663: AND
5664: PUSH
5665: LD_INT 28
5667: PPUSH
5668: LD_INT 22
5670: PUSH
5671: LD_EXP 1
5675: PUSH
5676: EMPTY
5677: LIST
5678: LIST
5679: PUSH
5680: LD_INT 21
5682: PUSH
5683: LD_INT 2
5685: PUSH
5686: EMPTY
5687: LIST
5688: LIST
5689: PUSH
5690: EMPTY
5691: LIST
5692: LIST
5693: PPUSH
5694: CALL_OW 70
5698: PUSH
5699: LD_INT 3
5701: GREATER
5702: AND
5703: IFFALSE 5863
5705: GO 5707
5707: DISABLE
// begin if IsDead ( Pty ) then
5708: LD_LOC 6
5712: PPUSH
5713: CALL_OW 301
5717: IFFALSE 5729
// Pty := Dol ;
5719: LD_ADDR_LOC 6
5723: PUSH
5724: LD_LOC 10
5728: ST_TO_ADDR
// if IsDead ( Pty ) then
5729: LD_LOC 6
5733: PPUSH
5734: CALL_OW 301
5738: IFFALSE 5750
// Pty := Kar ;
5740: LD_ADDR_LOC 6
5744: PUSH
5745: LD_LOC 3
5749: ST_TO_ADDR
// vespod := true ;
5750: LD_ADDR_EXP 65
5754: PUSH
5755: LD_INT 1
5757: ST_TO_ADDR
// if Pty in FilterUnitsInArea ( uz_jedou_dolem , [ [ f_side , you ] , [ f_nation , nation_russian ] ] ) then
5758: LD_LOC 6
5762: PUSH
5763: LD_INT 28
5765: PPUSH
5766: LD_INT 22
5768: PUSH
5769: LD_EXP 1
5773: PUSH
5774: EMPTY
5775: LIST
5776: LIST
5777: PUSH
5778: LD_INT 23
5780: PUSH
5781: LD_INT 3
5783: PUSH
5784: EMPTY
5785: LIST
5786: LIST
5787: PUSH
5788: EMPTY
5789: LIST
5790: LIST
5791: PPUSH
5792: CALL_OW 70
5796: IN
5797: IFFALSE 5810
// DStevens ( Pty ) else
5799: LD_LOC 6
5803: PPUSH
5804: CALL 5864 0 1
5808: GO 5863
// DStevens ( FilterUnitsInArea ( uz_jedou_dolem , [ [ f_side , you ] , [ f_nation , nation_russian ] , [ f_sex , sex_male ] ] ) [ 1 ] ) ;
5810: LD_INT 28
5812: PPUSH
5813: LD_INT 22
5815: PUSH
5816: LD_EXP 1
5820: PUSH
5821: EMPTY
5822: LIST
5823: LIST
5824: PUSH
5825: LD_INT 23
5827: PUSH
5828: LD_INT 3
5830: PUSH
5831: EMPTY
5832: LIST
5833: LIST
5834: PUSH
5835: LD_INT 26
5837: PUSH
5838: LD_INT 1
5840: PUSH
5841: EMPTY
5842: LIST
5843: LIST
5844: PUSH
5845: EMPTY
5846: LIST
5847: LIST
5848: LIST
5849: PPUSH
5850: CALL_OW 70
5854: PUSH
5855: LD_INT 1
5857: ARRAY
5858: PPUSH
5859: CALL 5864 0 1
// end ;
5863: END
// export vespod , vespod2 , byl_stevens ; function DStevens ( who ) ; begin
5864: LD_INT 0
5866: PPUSH
// if not vespod then
5867: LD_EXP 65
5871: NOT
5872: IFFALSE 5891
// PlaceUnitArea ( Huck , stv_site , true ) else
5874: LD_LOC 7
5878: PPUSH
5879: LD_INT 12
5881: PPUSH
5882: LD_INT 1
5884: PPUSH
5885: CALL_OW 49
5889: GO 5906
// PlaceUnitArea ( Huck , stv_site2 , true ) ;
5891: LD_LOC 7
5895: PPUSH
5896: LD_INT 29
5898: PPUSH
5899: LD_INT 1
5901: PPUSH
5902: CALL_OW 49
// wait ( 0 0$4 ) ;
5906: LD_INT 140
5908: PPUSH
5909: CALL_OW 67
// ComStop ( who ) ;
5913: LD_VAR 0 1
5917: PPUSH
5918: CALL_OW 141
// ComTurnUnit ( who , huck ) ;
5922: LD_VAR 0 1
5926: PPUSH
5927: LD_LOC 7
5931: PPUSH
5932: CALL_OW 119
// ComTurnUnit ( huck , who ) ;
5936: LD_LOC 7
5940: PPUSH
5941: LD_VAR 0 1
5945: PPUSH
5946: CALL_OW 119
// CenterNowOnUnits ( huck ) ;
5950: LD_LOC 7
5954: PPUSH
5955: CALL_OW 87
// Stevens_killed := true ;
5959: LD_ADDR_EXP 11
5963: PUSH
5964: LD_INT 1
5966: ST_TO_ADDR
// wait ( 0 0$1 ) ;
5967: LD_INT 35
5969: PPUSH
5970: CALL_OW 67
// DialogueOn ;
5974: CALL_OW 6
// if IsDead ( Pty ) then
5978: LD_LOC 6
5982: PPUSH
5983: CALL_OW 301
5987: IFFALSE 5999
// Pty := Dol ;
5989: LD_ADDR_LOC 6
5993: PUSH
5994: LD_LOC 10
5998: ST_TO_ADDR
// if IsDead ( Pty ) then
5999: LD_LOC 6
6003: PPUSH
6004: CALL_OW 301
6008: IFFALSE 6020
// Pty := Kar ;
6010: LD_ADDR_LOC 6
6014: PUSH
6015: LD_LOC 3
6019: ST_TO_ADDR
// if IsOk ( Pty ) then
6020: LD_LOC 6
6024: PPUSH
6025: CALL_OW 302
6029: IFFALSE 6410
// begin if who = Pty then
6031: LD_VAR 0 1
6035: PUSH
6036: LD_LOC 6
6040: EQUAL
6041: IFFALSE 6145
// begin SetAttitude ( you , americans , att_enemy , false ) ;
6043: LD_EXP 1
6047: PPUSH
6048: LD_EXP 2
6052: PPUSH
6053: LD_INT 2
6055: PPUSH
6056: LD_INT 0
6058: PPUSH
6059: CALL_OW 80
// DialogueOff ;
6063: CALL_OW 7
// while GetLives ( huck ) > 940 do
6067: LD_LOC 7
6071: PPUSH
6072: CALL_OW 256
6076: PUSH
6077: LD_INT 940
6079: GREATER
6080: IFFALSE 6091
// Wait ( 0 0$0.5 ) ;
6082: LD_INT 18
6084: PPUSH
6085: CALL_OW 67
6089: GO 6067
// SetAttitude ( you , americans , att_neutral , true ) ;
6091: LD_EXP 1
6095: PPUSH
6096: LD_EXP 2
6100: PPUSH
6101: LD_INT 0
6103: PPUSH
6104: LD_INT 1
6106: PPUSH
6107: CALL_OW 80
// ComStop ( who ) ;
6111: LD_VAR 0 1
6115: PPUSH
6116: CALL_OW 141
// Wait ( 0 0$0.1 ) ;
6120: LD_INT 4
6122: PPUSH
6123: CALL_OW 67
// DialogueOn ;
6127: CALL_OW 6
// Say ( Huck , DStevens-Huck-1 ) ;
6131: LD_LOC 7
6135: PPUSH
6136: LD_STRING DStevens-Huck-1
6138: PPUSH
6139: CALL_OW 88
// end else
6143: GO 6276
// begin Say ( who , DStevens-RSol1-1 ) ;
6145: LD_VAR 0 1
6149: PPUSH
6150: LD_STRING DStevens-RSol1-1
6152: PPUSH
6153: CALL_OW 88
// DialogueOff ;
6157: CALL_OW 7
// Wait ( 0 0$0.7 ) ;
6161: LD_INT 24
6163: PPUSH
6164: CALL_OW 67
// SetAttitude ( you , americans , att_enemy , false ) ;
6168: LD_EXP 1
6172: PPUSH
6173: LD_EXP 2
6177: PPUSH
6178: LD_INT 2
6180: PPUSH
6181: LD_INT 0
6183: PPUSH
6184: CALL_OW 80
// while GetLives ( huck ) > 940 do
6188: LD_LOC 7
6192: PPUSH
6193: CALL_OW 256
6197: PUSH
6198: LD_INT 940
6200: GREATER
6201: IFFALSE 6212
// Wait ( 0 0$0.5 ) ;
6203: LD_INT 18
6205: PPUSH
6206: CALL_OW 67
6210: GO 6188
// SetAttitude ( you , americans , att_neutral , true ) ;
6212: LD_EXP 1
6216: PPUSH
6217: LD_EXP 2
6221: PPUSH
6222: LD_INT 0
6224: PPUSH
6225: LD_INT 1
6227: PPUSH
6228: CALL_OW 80
// ComStop ( who ) ;
6232: LD_VAR 0 1
6236: PPUSH
6237: CALL_OW 141
// Wait ( 0 0$0.1 ) ;
6241: LD_INT 4
6243: PPUSH
6244: CALL_OW 67
// DialogueOn ;
6248: CALL_OW 6
// Say ( Huck , DStevens-Huck-1 ) ;
6252: LD_LOC 7
6256: PPUSH
6257: LD_STRING DStevens-Huck-1
6259: PPUSH
6260: CALL_OW 88
// Say ( Pty , DStevens-Pty-1 ) ;
6264: LD_LOC 6
6268: PPUSH
6269: LD_STRING DStevens-Pty-1
6271: PPUSH
6272: CALL_OW 88
// end ; Say ( Pty , DStevens-Pty-1a ) ;
6276: LD_LOC 6
6280: PPUSH
6281: LD_STRING DStevens-Pty-1a
6283: PPUSH
6284: CALL_OW 88
// Say ( Huck , DStevens-Huck-2 ) ;
6288: LD_LOC 7
6292: PPUSH
6293: LD_STRING DStevens-Huck-2
6295: PPUSH
6296: CALL_OW 88
// Say ( Pty , DStevens-Pty-2 ) ;
6300: LD_LOC 6
6304: PPUSH
6305: LD_STRING DStevens-Pty-2
6307: PPUSH
6308: CALL_OW 88
// Say ( Huck , DStevens-Huck-3 ) ;
6312: LD_LOC 7
6316: PPUSH
6317: LD_STRING DStevens-Huck-3
6319: PPUSH
6320: CALL_OW 88
// Say ( Pty , DStevens-Pty-3 ) ;
6324: LD_LOC 6
6328: PPUSH
6329: LD_STRING DStevens-Pty-3
6331: PPUSH
6332: CALL_OW 88
// Say ( Huck , DStevens-Huck-4 ) ;
6336: LD_LOC 7
6340: PPUSH
6341: LD_STRING DStevens-Huck-4
6343: PPUSH
6344: CALL_OW 88
// Say ( Pty , DStevens-Pty-4 ) ;
6348: LD_LOC 6
6352: PPUSH
6353: LD_STRING DStevens-Pty-4
6355: PPUSH
6356: CALL_OW 88
// SetAttitude ( you , americans , att_friend , true ) ;
6360: LD_EXP 1
6364: PPUSH
6365: LD_EXP 2
6369: PPUSH
6370: LD_INT 1
6372: PPUSH
6373: LD_INT 1
6375: PPUSH
6376: CALL_OW 80
// SetSide ( huck , you2 ) ;
6380: LD_LOC 7
6384: PPUSH
6385: LD_EXP 5
6389: PPUSH
6390: CALL_OW 235
// ComMoveUnit ( huck , who ) ;
6394: LD_LOC 7
6398: PPUSH
6399: LD_VAR 0 1
6403: PPUSH
6404: CALL_OW 112
// end else
6408: GO 6442
// begin Say ( who , DStevens-RSol1-1 ) ;
6410: LD_VAR 0 1
6414: PPUSH
6415: LD_STRING DStevens-RSol1-1
6417: PPUSH
6418: CALL_OW 88
// SetAttitude ( you , americans , att_enemy , true ) ;
6422: LD_EXP 1
6426: PPUSH
6427: LD_EXP 2
6431: PPUSH
6432: LD_INT 2
6434: PPUSH
6435: LD_INT 1
6437: PPUSH
6438: CALL_OW 80
// end ; byl_stevens := true ;
6442: LD_ADDR_EXP 67
6446: PUSH
6447: LD_INT 1
6449: ST_TO_ADDR
// DialogueOff ;
6450: CALL_OW 7
// end ;
6454: LD_VAR 0 2
6458: RET
// var stv_depot ; every 1 trigger GetSide ( Huck ) = 3 or GetSide ( Huck ) = 6 do
6459: LD_LOC 7
6463: PPUSH
6464: CALL_OW 255
6468: PUSH
6469: LD_INT 3
6471: EQUAL
6472: PUSH
6473: LD_LOC 7
6477: PPUSH
6478: CALL_OW 255
6482: PUSH
6483: LD_INT 6
6485: EQUAL
6486: OR
6487: IFFALSE 6521
6489: GO 6491
6491: DISABLE
// begin if not GetClass ( Huck ) = 4 then
6492: LD_LOC 7
6496: PPUSH
6497: CALL_OW 257
6501: PUSH
6502: LD_INT 4
6504: EQUAL
6505: NOT
6506: IFFALSE 6520
// SetClass ( Huck , 4 ) ;
6508: LD_LOC 7
6512: PPUSH
6513: LD_INT 4
6515: PPUSH
6516: CALL_OW 336
// enable ;
6520: ENABLE
// end ;
6521: END
// function HumansInDepots ; var labs , i , inlabs ; begin
6522: LD_INT 0
6524: PPUSH
6525: PPUSH
6526: PPUSH
6527: PPUSH
// inlabs := [ ] ;
6528: LD_ADDR_VAR 0 4
6532: PUSH
6533: EMPTY
6534: ST_TO_ADDR
// labs := FilterAllUnits ( [ [ f_side , you ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
6535: LD_ADDR_VAR 0 2
6539: PUSH
6540: LD_INT 22
6542: PUSH
6543: LD_EXP 1
6547: PUSH
6548: EMPTY
6549: LIST
6550: LIST
6551: PUSH
6552: LD_INT 2
6554: PUSH
6555: LD_INT 30
6557: PUSH
6558: LD_INT 0
6560: PUSH
6561: EMPTY
6562: LIST
6563: LIST
6564: PUSH
6565: LD_INT 30
6567: PUSH
6568: LD_INT 1
6570: PUSH
6571: EMPTY
6572: LIST
6573: LIST
6574: PUSH
6575: EMPTY
6576: LIST
6577: LIST
6578: LIST
6579: PUSH
6580: EMPTY
6581: LIST
6582: LIST
6583: PPUSH
6584: CALL_OW 69
6588: ST_TO_ADDR
// for i in labs do
6589: LD_ADDR_VAR 0 3
6593: PUSH
6594: LD_VAR 0 2
6598: PUSH
6599: FOR_IN
6600: IFFALSE 6625
// inlabs := inlabs ^ UnitsInside ( i ) ;
6602: LD_ADDR_VAR 0 4
6606: PUSH
6607: LD_VAR 0 4
6611: PUSH
6612: LD_VAR 0 3
6616: PPUSH
6617: CALL_OW 313
6621: ADD
6622: ST_TO_ADDR
6623: GO 6599
6625: POP
6626: POP
// result := inlabs ;
6627: LD_ADDR_VAR 0 1
6631: PUSH
6632: LD_VAR 0 4
6636: ST_TO_ADDR
// end ;
6637: LD_VAR 0 1
6641: RET
// every 0 0$5 + 0 0$3 trigger dialogy and byl_stevens and ( not vespod and ( IsInArea ( Huck , stred ) ) or GetDistUnits ( Burlak , Huck ) < 13 ) do
6642: LD_EXP 46
6646: PUSH
6647: LD_EXP 67
6651: AND
6652: PUSH
6653: LD_EXP 65
6657: NOT
6658: PUSH
6659: LD_LOC 7
6663: PPUSH
6664: LD_INT 11
6666: PPUSH
6667: CALL_OW 308
6671: AND
6672: PUSH
6673: LD_EXP 51
6677: PPUSH
6678: LD_LOC 7
6682: PPUSH
6683: CALL_OW 296
6687: PUSH
6688: LD_INT 13
6690: LESS
6691: OR
6692: AND
6693: IFFALSE 6766
6695: GO 6697
6697: DISABLE
// begin if IsDead ( Pty ) then
6698: LD_LOC 6
6702: PPUSH
6703: CALL_OW 301
6707: IFFALSE 6719
// Pty := Dol ;
6709: LD_ADDR_LOC 6
6713: PUSH
6714: LD_LOC 10
6718: ST_TO_ADDR
// if IsDead ( Pty ) then
6719: LD_LOC 6
6723: PPUSH
6724: CALL_OW 301
6728: IFFALSE 6740
// Pty := Kar ;
6730: LD_ADDR_LOC 6
6734: PUSH
6735: LD_LOC 3
6739: ST_TO_ADDR
// if IsLive ( Pty ) and IsLive ( Huck ) then
6740: LD_LOC 6
6744: PPUSH
6745: CALL_OW 300
6749: PUSH
6750: LD_LOC 7
6754: PPUSH
6755: CALL_OW 300
6759: AND
6760: IFFALSE 6766
// DStevensBurlak ;
6762: CALL 6767 0 0
// end ;
6766: END
// function DStevensBurlak ; var qr , tmp_depot ; begin
6767: LD_INT 0
6769: PPUSH
6770: PPUSH
6771: PPUSH
// DialogueOn ;
6772: CALL_OW 6
// Say ( Pty , DStevensBurlak-Pty-1 ) ;
6776: LD_LOC 6
6780: PPUSH
6781: LD_STRING DStevensBurlak-Pty-1
6783: PPUSH
6784: CALL_OW 88
// Say ( Bur , DStevensBurlak-Bur-1 ) ;
6788: LD_LOC 1
6792: PPUSH
6793: LD_STRING DStevensBurlak-Bur-1
6795: PPUSH
6796: CALL_OW 88
// Say ( Pty , DStevensBurlak-Pty-2 ) ;
6800: LD_LOC 6
6804: PPUSH
6805: LD_STRING DStevensBurlak-Pty-2
6807: PPUSH
6808: CALL_OW 88
// qr := Query ( QKill ) ;
6812: LD_ADDR_VAR 0 2
6816: PUSH
6817: LD_STRING QKill
6819: PPUSH
6820: CALL_OW 97
6824: ST_TO_ADDR
// if qr = 1 then
6825: LD_VAR 0 2
6829: PUSH
6830: LD_INT 1
6832: EQUAL
6833: IFFALSE 6904
// begin Say ( Bur , DKill-1-Bur-1 ) ;
6835: LD_LOC 1
6839: PPUSH
6840: LD_STRING DKill-1-Bur-1
6842: PPUSH
6843: CALL_OW 88
// SetSide ( Huck , americans ) ;
6847: LD_LOC 7
6851: PPUSH
6852: LD_EXP 2
6856: PPUSH
6857: CALL_OW 235
// SetAttitude ( you , americans , att_enemy , true ) ;
6861: LD_EXP 1
6865: PPUSH
6866: LD_EXP 2
6870: PPUSH
6871: LD_INT 2
6873: PPUSH
6874: LD_INT 1
6876: PPUSH
6877: CALL_OW 80
// if IsLive ( Glb ) then
6881: LD_LOC 5
6885: PPUSH
6886: CALL_OW 300
6890: IFFALSE 6904
// Say ( Glb , DKill-1-Glb-1 ) ;
6892: LD_LOC 5
6896: PPUSH
6897: LD_STRING DKill-1-Glb-1
6899: PPUSH
6900: CALL_OW 88
// end ; if qr = 2 then
6904: LD_VAR 0 2
6908: PUSH
6909: LD_INT 2
6911: EQUAL
6912: IFFALSE 6965
// begin Say ( Bur , DKill-2-Bur-1 ) ;
6914: LD_LOC 1
6918: PPUSH
6919: LD_STRING DKill-2-Bur-1
6921: PPUSH
6922: CALL_OW 88
// Say ( Pty , DKill-2-Pty-1 ) ;
6926: LD_LOC 6
6930: PPUSH
6931: LD_STRING DKill-2-Pty-1
6933: PPUSH
6934: CALL_OW 88
// if not vespod then
6938: LD_EXP 65
6942: NOT
6943: IFFALSE 6957
// Say ( Bur , DKill-2-Bur-2 ) ;
6945: LD_LOC 1
6949: PPUSH
6950: LD_STRING DKill-2-Bur-2
6952: PPUSH
6953: CALL_OW 88
// StevensStayInBase = 1 ;
6957: LD_ADDR_EXP 49
6961: PUSH
6962: LD_INT 1
6964: ST_TO_ADDR
// end ; DialogueOff ;
6965: CALL_OW 7
// if not vespod and qr = 2 then
6969: LD_EXP 65
6973: NOT
6974: PUSH
6975: LD_VAR 0 2
6979: PUSH
6980: LD_INT 2
6982: EQUAL
6983: AND
6984: IFFALSE 7170
// begin while not tmp_depot do
6986: LD_VAR 0 3
6990: NOT
6991: IFFALSE 7067
// begin tmp_depot := FilterAllUnits ( [ [ f_side , you ] , [ f_ok ] , [ f_or , [ f_btype , b_warehouse ] , [ f_btype , b_depot ] ] ] ) [ 1 ] ;
6993: LD_ADDR_VAR 0 3
6997: PUSH
6998: LD_INT 22
7000: PUSH
7001: LD_EXP 1
7005: PUSH
7006: EMPTY
7007: LIST
7008: LIST
7009: PUSH
7010: LD_INT 50
7012: PUSH
7013: EMPTY
7014: LIST
7015: PUSH
7016: LD_INT 2
7018: PUSH
7019: LD_INT 30
7021: PUSH
7022: LD_INT 1
7024: PUSH
7025: EMPTY
7026: LIST
7027: LIST
7028: PUSH
7029: LD_INT 30
7031: PUSH
7032: LD_INT 0
7034: PUSH
7035: EMPTY
7036: LIST
7037: LIST
7038: PUSH
7039: EMPTY
7040: LIST
7041: LIST
7042: LIST
7043: PUSH
7044: EMPTY
7045: LIST
7046: LIST
7047: LIST
7048: PPUSH
7049: CALL_OW 69
7053: PUSH
7054: LD_INT 1
7056: ARRAY
7057: ST_TO_ADDR
// Wait ( 0 0$1 ) ;
7058: LD_INT 35
7060: PPUSH
7061: CALL_OW 67
// end ;
7065: GO 6986
// while GetDistUnits ( Huck , tmp_depot ) > 5 do
7067: LD_LOC 7
7071: PPUSH
7072: LD_VAR 0 3
7076: PPUSH
7077: CALL_OW 296
7081: PUSH
7082: LD_INT 5
7084: GREATER
7085: IFFALSE 7110
// begin ComMoveUnit ( Huck , tmp_depot ) ;
7087: LD_LOC 7
7091: PPUSH
7092: LD_VAR 0 3
7096: PPUSH
7097: CALL_OW 112
// Wait ( 0 0$0.1 ) ;
7101: LD_INT 4
7103: PPUSH
7104: CALL_OW 67
// end ;
7108: GO 7067
// SetSide ( Huck , you ) ;
7110: LD_LOC 7
7114: PPUSH
7115: LD_EXP 1
7119: PPUSH
7120: CALL_OW 235
// while not ( huck in HumansInDepots ) do
7124: LD_LOC 7
7128: PUSH
7129: CALL 6522 0 0
7133: IN
7134: NOT
7135: IFFALSE 7160
// begin ComMoveUnit ( Huck , tmp_depot ) ;
7137: LD_LOC 7
7141: PPUSH
7142: LD_VAR 0 3
7146: PPUSH
7147: CALL_OW 112
// Wait ( 0 0$0.1 ) ;
7151: LD_INT 4
7153: PPUSH
7154: CALL_OW 67
// end ;
7158: GO 7124
// stv_depot := tmp_depot ;
7160: LD_ADDR_LOC 12
7164: PUSH
7165: LD_VAR 0 3
7169: ST_TO_ADDR
// end ; if vespod and qr = 2 then
7170: LD_EXP 65
7174: PUSH
7175: LD_VAR 0 2
7179: PUSH
7180: LD_INT 2
7182: EQUAL
7183: AND
7184: IFFALSE 7209
// begin DialogueOn ;
7186: CALL_OW 6
// DWait ( 0 0$4.5 ) ;
7190: LD_INT 158
7192: PPUSH
7193: CALL_OW 68
// DialogueOff ;
7197: CALL_OW 7
// vespod2 := true ;
7201: LD_ADDR_EXP 66
7205: PUSH
7206: LD_INT 1
7208: ST_TO_ADDR
// end ; if qr = 1 then
7209: LD_VAR 0 2
7213: PUSH
7214: LD_INT 1
7216: EQUAL
7217: IFFALSE 7266
// begin while not IsInArea ( huck , stv_exit ) do
7219: LD_LOC 7
7223: PPUSH
7224: LD_INT 21
7226: PPUSH
7227: CALL_OW 308
7231: NOT
7232: IFFALSE 7257
// begin ComMoveToArea ( Huck , stv_exit ) ;
7234: LD_LOC 7
7238: PPUSH
7239: LD_INT 21
7241: PPUSH
7242: CALL_OW 113
// DU_wait ( Huck ) ;
7246: LD_LOC 7
7250: PPUSH
7251: CALL 22231 0 1
// end ;
7255: GO 7219
// RemoveUnit ( Huck ) ;
7257: LD_LOC 7
7261: PPUSH
7262: CALL_OW 64
// end ; end ;
7266: LD_VAR 0 1
7270: RET
// function DQrKillAgain_1 ; begin
7271: LD_INT 0
7273: PPUSH
// DialogueOn ;
7274: CALL_OW 6
// Say ( Bur , DQrKillAgain#1-Bur-1 ) ;
7278: LD_LOC 1
7282: PPUSH
7283: LD_STRING DQrKillAgain#1-Bur-1
7285: PPUSH
7286: CALL_OW 88
// DialogueOff ;
7290: CALL_OW 7
// SetSide ( Huck , americans ) ;
7294: LD_LOC 7
7298: PPUSH
7299: LD_EXP 2
7303: PPUSH
7304: CALL_OW 235
// SetAttitude ( you , americans , att_enemy , true ) ;
7308: LD_EXP 1
7312: PPUSH
7313: LD_EXP 2
7317: PPUSH
7318: LD_INT 2
7320: PPUSH
7321: LD_INT 1
7323: PPUSH
7324: CALL_OW 80
// Stevens_Killed := true ;
7328: LD_ADDR_EXP 11
7332: PUSH
7333: LD_INT 1
7335: ST_TO_ADDR
// stv_depot := 0 ;
7336: LD_ADDR_LOC 12
7340: PUSH
7341: LD_INT 0
7343: ST_TO_ADDR
// end ;
7344: LD_VAR 0 1
7348: RET
// function DQrKillAgain_2 ; begin
7349: LD_INT 0
7351: PPUSH
// DialogueOn ;
7352: CALL_OW 6
// Say ( Bur , DQrKillAgain#2-Bur-1 ) ;
7356: LD_LOC 1
7360: PPUSH
7361: LD_STRING DQrKillAgain#2-Bur-1
7363: PPUSH
7364: CALL_OW 88
// DialogueOff ;
7368: CALL_OW 7
// stv_depot := 0 ;
7372: LD_ADDR_LOC 12
7376: PUSH
7377: LD_INT 0
7379: ST_TO_ADDR
// SetSide ( Huck , americans ) ;
7380: LD_LOC 7
7384: PPUSH
7385: LD_EXP 2
7389: PPUSH
7390: CALL_OW 235
// ComMoveToArea ( Huck , Stv_exit ) ;
7394: LD_LOC 7
7398: PPUSH
7399: LD_INT 21
7401: PPUSH
7402: CALL_OW 113
// while not ( IsInArea ( Huck , stv_exit ) ) do
7406: LD_LOC 7
7410: PPUSH
7411: LD_INT 21
7413: PPUSH
7414: CALL_OW 308
7418: NOT
7419: IFFALSE 7430
// wait ( 0 0$1 ) ;
7421: LD_INT 35
7423: PPUSH
7424: CALL_OW 67
7428: GO 7406
// RemoveUnit ( Huck ) ;
7430: LD_LOC 7
7434: PPUSH
7435: CALL_OW 64
// end ;
7439: LD_VAR 0 1
7443: RET
// function DQrKillAgain_3 ; var tmp_depot ; begin
7444: LD_INT 0
7446: PPUSH
7447: PPUSH
// DialogueOn ;
7448: CALL_OW 6
// Say ( Bur , DQrKillAgain#2-Bur-1a ) ;
7452: LD_LOC 1
7456: PPUSH
7457: LD_STRING DQrKillAgain#2-Bur-1a
7459: PPUSH
7460: CALL_OW 88
// DialogueOff ;
7464: CALL_OW 7
// SetSide ( Huck , you2 ) ;
7468: LD_LOC 7
7472: PPUSH
7473: LD_EXP 5
7477: PPUSH
7478: CALL_OW 235
// tmp_depot = FilterAllUnits ( [ [ f_side , you ] , [ f_ok ] , [ f_or , [ f_btype , b_warehouse ] , [ f_btype , b_depot ] ] ] ) ;
7482: LD_ADDR_VAR 0 2
7486: PUSH
7487: LD_INT 22
7489: PUSH
7490: LD_EXP 1
7494: PUSH
7495: EMPTY
7496: LIST
7497: LIST
7498: PUSH
7499: LD_INT 50
7501: PUSH
7502: EMPTY
7503: LIST
7504: PUSH
7505: LD_INT 2
7507: PUSH
7508: LD_INT 30
7510: PUSH
7511: LD_INT 1
7513: PUSH
7514: EMPTY
7515: LIST
7516: LIST
7517: PUSH
7518: LD_INT 30
7520: PUSH
7521: LD_INT 0
7523: PUSH
7524: EMPTY
7525: LIST
7526: LIST
7527: PUSH
7528: EMPTY
7529: LIST
7530: LIST
7531: LIST
7532: PUSH
7533: EMPTY
7534: LIST
7535: LIST
7536: LIST
7537: PPUSH
7538: CALL_OW 69
7542: ST_TO_ADDR
// if tmp_depot = 0 then
7543: LD_VAR 0 2
7547: PUSH
7548: LD_INT 0
7550: EQUAL
7551: IFFALSE 7677
// repeat wait ( 0 0$1 ) ;
7553: LD_INT 35
7555: PPUSH
7556: CALL_OW 67
// tmp_depot = FilterAllUnits ( [ [ f_side , you ] , [ f_ok ] , [ f_or , [ f_btype , b_warehouse ] , [ f_btype , b_depot ] ] ] ) ;
7560: LD_ADDR_VAR 0 2
7564: PUSH
7565: LD_INT 22
7567: PUSH
7568: LD_EXP 1
7572: PUSH
7573: EMPTY
7574: LIST
7575: LIST
7576: PUSH
7577: LD_INT 50
7579: PUSH
7580: EMPTY
7581: LIST
7582: PUSH
7583: LD_INT 2
7585: PUSH
7586: LD_INT 30
7588: PUSH
7589: LD_INT 1
7591: PUSH
7592: EMPTY
7593: LIST
7594: LIST
7595: PUSH
7596: LD_INT 30
7598: PUSH
7599: LD_INT 0
7601: PUSH
7602: EMPTY
7603: LIST
7604: LIST
7605: PUSH
7606: EMPTY
7607: LIST
7608: LIST
7609: LIST
7610: PUSH
7611: EMPTY
7612: LIST
7613: LIST
7614: LIST
7615: PPUSH
7616: CALL_OW 69
7620: ST_TO_ADDR
// if IsInUnit ( Bur ) then
7621: LD_LOC 1
7625: PPUSH
7626: CALL_OW 310
7630: IFFALSE 7653
// ComMoveUnit ( Huck , IsInUnit ( Bur ) ) else
7632: LD_LOC 7
7636: PPUSH
7637: LD_LOC 1
7641: PPUSH
7642: CALL_OW 310
7646: PPUSH
7647: CALL_OW 112
7651: GO 7667
// ComMoveUnit ( Huck , Bur ) ;
7653: LD_LOC 7
7657: PPUSH
7658: LD_LOC 1
7662: PPUSH
7663: CALL_OW 112
// until tmp_depot > 0 ;
7667: LD_VAR 0 2
7671: PUSH
7672: LD_INT 0
7674: GREATER
7675: IFFALSE 7553
// if tmp_depot > 0 then
7677: LD_VAR 0 2
7681: PUSH
7682: LD_INT 0
7684: GREATER
7685: IFFALSE 7991
// begin repeat tmp_depot = FilterAllUnits ( [ [ f_side , you ] , [ f_ok ] , [ f_or , [ f_btype , b_warehouse ] , [ f_btype , b_depot ] ] ] ) ;
7687: LD_ADDR_VAR 0 2
7691: PUSH
7692: LD_INT 22
7694: PUSH
7695: LD_EXP 1
7699: PUSH
7700: EMPTY
7701: LIST
7702: LIST
7703: PUSH
7704: LD_INT 50
7706: PUSH
7707: EMPTY
7708: LIST
7709: PUSH
7710: LD_INT 2
7712: PUSH
7713: LD_INT 30
7715: PUSH
7716: LD_INT 1
7718: PUSH
7719: EMPTY
7720: LIST
7721: LIST
7722: PUSH
7723: LD_INT 30
7725: PUSH
7726: LD_INT 0
7728: PUSH
7729: EMPTY
7730: LIST
7731: LIST
7732: PUSH
7733: EMPTY
7734: LIST
7735: LIST
7736: LIST
7737: PUSH
7738: EMPTY
7739: LIST
7740: LIST
7741: LIST
7742: PPUSH
7743: CALL_OW 69
7747: ST_TO_ADDR
// wait ( 0 0$1 ) ;
7748: LD_INT 35
7750: PPUSH
7751: CALL_OW 67
// ComMoveUnit ( Huck , tmp_depot [ 1 ] ) ;
7755: LD_LOC 7
7759: PPUSH
7760: LD_VAR 0 2
7764: PUSH
7765: LD_INT 1
7767: ARRAY
7768: PPUSH
7769: CALL_OW 112
// until GetDistUnits ( Huck , tmp_depot [ 1 ] ) < 5 or tmp_depot = 0 ;
7773: LD_LOC 7
7777: PPUSH
7778: LD_VAR 0 2
7782: PUSH
7783: LD_INT 1
7785: ARRAY
7786: PPUSH
7787: CALL_OW 296
7791: PUSH
7792: LD_INT 5
7794: LESS
7795: PUSH
7796: LD_VAR 0 2
7800: PUSH
7801: LD_INT 0
7803: EQUAL
7804: OR
7805: IFFALSE 7687
// if tmp_depot = 0 then
7807: LD_VAR 0 2
7811: PUSH
7812: LD_INT 0
7814: EQUAL
7815: IFFALSE 7941
// repeat wait ( 0 0$1 ) ;
7817: LD_INT 35
7819: PPUSH
7820: CALL_OW 67
// tmp_depot = FilterAllUnits ( [ [ f_side , you ] , [ f_ok ] , [ f_or , [ f_btype , b_warehouse ] , [ f_btype , b_depot ] ] ] ) ;
7824: LD_ADDR_VAR 0 2
7828: PUSH
7829: LD_INT 22
7831: PUSH
7832: LD_EXP 1
7836: PUSH
7837: EMPTY
7838: LIST
7839: LIST
7840: PUSH
7841: LD_INT 50
7843: PUSH
7844: EMPTY
7845: LIST
7846: PUSH
7847: LD_INT 2
7849: PUSH
7850: LD_INT 30
7852: PUSH
7853: LD_INT 1
7855: PUSH
7856: EMPTY
7857: LIST
7858: LIST
7859: PUSH
7860: LD_INT 30
7862: PUSH
7863: LD_INT 0
7865: PUSH
7866: EMPTY
7867: LIST
7868: LIST
7869: PUSH
7870: EMPTY
7871: LIST
7872: LIST
7873: LIST
7874: PUSH
7875: EMPTY
7876: LIST
7877: LIST
7878: LIST
7879: PPUSH
7880: CALL_OW 69
7884: ST_TO_ADDR
// if IsInUnit ( Bur ) then
7885: LD_LOC 1
7889: PPUSH
7890: CALL_OW 310
7894: IFFALSE 7917
// ComMoveUnit ( Huck , IsInUnit ( Bur ) ) else
7896: LD_LOC 7
7900: PPUSH
7901: LD_LOC 1
7905: PPUSH
7906: CALL_OW 310
7910: PPUSH
7911: CALL_OW 112
7915: GO 7931
// ComMoveUnit ( Huck , Bur ) ;
7917: LD_LOC 7
7921: PPUSH
7922: LD_LOC 1
7926: PPUSH
7927: CALL_OW 112
// until tmp_depot > 0 ;
7931: LD_VAR 0 2
7935: PUSH
7936: LD_INT 0
7938: GREATER
7939: IFFALSE 7817
// SetSide ( Huck , you ) ;
7941: LD_LOC 7
7945: PPUSH
7946: LD_EXP 1
7950: PPUSH
7951: CALL_OW 235
// repeat wait ( 0 0$0.1 ) ;
7955: LD_INT 4
7957: PPUSH
7958: CALL_OW 67
// ComEnterUnit ( Huck , tmp_depot [ 1 ] ) ;
7962: LD_LOC 7
7966: PPUSH
7967: LD_VAR 0 2
7971: PUSH
7972: LD_INT 1
7974: ARRAY
7975: PPUSH
7976: CALL_OW 120
// until IsInUnit ( Huck ) ;
7980: LD_LOC 7
7984: PPUSH
7985: CALL_OW 310
7989: IFFALSE 7955
// end ; end ;
7991: LD_VAR 0 1
7995: RET
// every 1 trigger IsInUnit ( Huck ) do
7996: LD_LOC 7
8000: PPUSH
8001: CALL_OW 310
8005: IFFALSE 8018
8007: GO 8009
8009: DISABLE
// StevensInDepot := true ;
8010: LD_ADDR_EXP 50
8014: PUSH
8015: LD_INT 1
8017: ST_TO_ADDR
8018: END
// every 0 0$3 trigger dialogy and byl_stevens and StevensInDepot and IsOK ( Huck ) and GetSide ( Huck ) = 3 and StevensStayInBase = 1 and not IsInUnit ( Huck ) do var qr ;
8019: LD_EXP 46
8023: PUSH
8024: LD_EXP 67
8028: AND
8029: PUSH
8030: LD_EXP 50
8034: AND
8035: PUSH
8036: LD_LOC 7
8040: PPUSH
8041: CALL_OW 302
8045: AND
8046: PUSH
8047: LD_LOC 7
8051: PPUSH
8052: CALL_OW 255
8056: PUSH
8057: LD_INT 3
8059: EQUAL
8060: AND
8061: PUSH
8062: LD_EXP 49
8066: PUSH
8067: LD_INT 1
8069: EQUAL
8070: AND
8071: PUSH
8072: LD_LOC 7
8076: PPUSH
8077: CALL_OW 310
8081: NOT
8082: AND
8083: IFFALSE 8239
8085: GO 8087
8087: DISABLE
8088: LD_INT 0
8090: PPUSH
// begin DialogueOn ;
8091: CALL_OW 6
// Stevens_killed := false ;
8095: LD_ADDR_EXP 11
8099: PUSH
8100: LD_INT 0
8102: ST_TO_ADDR
// Say ( Bur , DRelease-Bur-1 ) ;
8103: LD_LOC 1
8107: PPUSH
8108: LD_STRING DRelease-Bur-1
8110: PPUSH
8111: CALL_OW 88
// DialogueOff ;
8115: CALL_OW 7
// if vespod then
8119: LD_EXP 65
8123: IFFALSE 8150
// qr := SelectiveQuery ( QKillAgain , [ 1 , 2 ] ) else
8125: LD_ADDR_VAR 0 1
8129: PUSH
8130: LD_STRING QKillAgain
8132: PPUSH
8133: LD_INT 1
8135: PUSH
8136: LD_INT 2
8138: PUSH
8139: EMPTY
8140: LIST
8141: LIST
8142: PPUSH
8143: CALL_OW 98
8147: ST_TO_ADDR
8148: GO 8177
// qr := SelectiveQuery ( QKillAgain , [ 1 , 2 , 3 ] ) ;
8150: LD_ADDR_VAR 0 1
8154: PUSH
8155: LD_STRING QKillAgain
8157: PPUSH
8158: LD_INT 1
8160: PUSH
8161: LD_INT 2
8163: PUSH
8164: LD_INT 3
8166: PUSH
8167: EMPTY
8168: LIST
8169: LIST
8170: LIST
8171: PPUSH
8172: CALL_OW 98
8176: ST_TO_ADDR
// case qr of 1 :
8177: LD_VAR 0 1
8181: PUSH
8182: LD_INT 1
8184: DOUBLE
8185: EQUAL
8186: IFTRUE 8190
8188: GO 8197
8190: POP
// DQrKillAgain_1 ; 2 :
8191: CALL 7271 0 0
8195: GO 8228
8197: LD_INT 2
8199: DOUBLE
8200: EQUAL
8201: IFTRUE 8205
8203: GO 8212
8205: POP
// DQrKillAgain_2 ; 3 :
8206: CALL 7349 0 0
8210: GO 8228
8212: LD_INT 3
8214: DOUBLE
8215: EQUAL
8216: IFTRUE 8220
8218: GO 8227
8220: POP
// DQrKillAgain_3 ; end ;
8221: CALL 7444 0 0
8225: GO 8228
8227: POP
// if qr = 3 then
8228: LD_VAR 0 1
8232: PUSH
8233: LD_INT 3
8235: EQUAL
8236: IFFALSE 8239
// enable ;
8238: ENABLE
// end ;
8239: PPOPN 1
8241: END
// function DStevensLeftBehind ; var r , Sol1 ; begin
8242: LD_INT 0
8244: PPUSH
8245: PPUSH
8246: PPUSH
// DialogueOn ;
8247: CALL_OW 6
// Sol1 := WhoSayAny ( donttalk , you , sex_male , 0 , 0 ) ;
8251: LD_ADDR_VAR 0 3
8255: PUSH
8256: LD_LOC 11
8260: PPUSH
8261: LD_EXP 1
8265: PPUSH
8266: LD_INT 1
8268: PPUSH
8269: LD_INT 0
8271: PPUSH
8272: LD_INT 0
8274: PPUSH
8275: CALL 23773 0 5
8279: ST_TO_ADDR
// if IsOk ( Pty ) then
8280: LD_LOC 6
8284: PPUSH
8285: CALL_OW 302
8289: IFFALSE 8311
// r := Say ( Pty , DStevensLeftBehind-Pty-1 ) else
8291: LD_ADDR_VAR 0 2
8295: PUSH
8296: LD_LOC 6
8300: PPUSH
8301: LD_STRING DStevensLeftBehind-Pty-1
8303: PPUSH
8304: CALL_OW 88
8308: ST_TO_ADDR
8309: GO 8329
// r := Say ( Sol1 , DStevensLeftBehind-RSol1-1 ) ;
8311: LD_ADDR_VAR 0 2
8315: PUSH
8316: LD_VAR 0 3
8320: PPUSH
8321: LD_STRING DStevensLeftBehind-RSol1-1
8323: PPUSH
8324: CALL_OW 88
8328: ST_TO_ADDR
// if r then
8329: LD_VAR 0 2
8333: IFFALSE 8347
// Say ( Bur , DStevensLeftBehind-Bur-1 ) ;
8335: LD_LOC 1
8339: PPUSH
8340: LD_STRING DStevensLeftBehind-Bur-1
8342: PPUSH
8343: CALL_OW 88
// Stevens_Killed := true ;
8347: LD_ADDR_EXP 11
8351: PUSH
8352: LD_INT 1
8354: ST_TO_ADDR
// DialogueOff ;
8355: CALL_OW 7
// end ;
8359: LD_VAR 0 1
8363: RET
// var was_sheikh_obj ; every 0 0$1 trigger dialogy and See ( you , Mastodon ) do var a ;
8364: LD_EXP 46
8368: PUSH
8369: LD_EXP 1
8373: PPUSH
8374: LD_INT 1
8376: PPUSH
8377: CALL_OW 292
8381: AND
8382: IFFALSE 8469
8384: GO 8386
8386: DISABLE
8387: LD_INT 0
8389: PPUSH
// begin if not was_sheikh_obj then
8390: LD_LOC 13
8394: NOT
8395: IFFALSE 8412
// begin ChangeMissionObjectives ( MAddSheikh ) ;
8397: LD_STRING MAddSheikh
8399: PPUSH
8400: CALL_OW 337
// was_sheikh_obj := true ;
8404: LD_ADDR_LOC 13
8408: PUSH
8409: LD_INT 1
8411: ST_TO_ADDR
// end ; a := NearestUnitToUnit ( UnitFilter ( donttalk , [ f_sex , sex_male ] ) ^ Burlak , Mastodon ) ;
8412: LD_ADDR_VAR 0 1
8416: PUSH
8417: LD_LOC 11
8421: PPUSH
8422: LD_INT 26
8424: PUSH
8425: LD_INT 1
8427: PUSH
8428: EMPTY
8429: LIST
8430: LIST
8431: PPUSH
8432: CALL_OW 72
8436: PUSH
8437: LD_EXP 51
8441: ADD
8442: PPUSH
8443: LD_INT 1
8445: PPUSH
8446: CALL_OW 74
8450: ST_TO_ADDR
// if a then
8451: LD_VAR 0 1
8455: IFFALSE 8468
// DMastodon ( a ) else
8457: LD_VAR 0 1
8461: PPUSH
8462: CALL 8472 0 1
8466: GO 8469
// enable ;
8468: ENABLE
// end ;
8469: PPOPN 1
8471: END
// function DMastodon ( who ) ; begin
8472: LD_INT 0
8474: PPUSH
// DialogueOn ;
8475: CALL_OW 6
// if who = Bur then
8479: LD_VAR 0 1
8483: PUSH
8484: LD_LOC 1
8488: EQUAL
8489: IFFALSE 8505
// Say ( who , DMastodon-Bur-1 ) else
8491: LD_VAR 0 1
8495: PPUSH
8496: LD_STRING DMastodon-Bur-1
8498: PPUSH
8499: CALL_OW 88
8503: GO 8517
// Say ( who , DMastodon-RSol1-1 ) ;
8505: LD_VAR 0 1
8509: PPUSH
8510: LD_STRING DMastodon-RSol1-1
8512: PPUSH
8513: CALL_OW 88
// Say ( Glb , DMastodon-Glb-1 ) ;
8517: LD_LOC 5
8521: PPUSH
8522: LD_STRING DMastodon-Glb-1
8524: PPUSH
8525: CALL_OW 88
// DialogueOff ;
8529: CALL_OW 7
// end ;
8533: LD_VAR 0 2
8537: RET
// every 0 0$1 trigger dialogy and IsDead ( Omar ) do
8538: LD_EXP 46
8542: PUSH
8543: LD_EXP 62
8547: PPUSH
8548: CALL_OW 301
8552: AND
8553: IFFALSE 8569
8555: GO 8557
8557: DISABLE
// begin DOmar ;
8558: CALL 8570 0 0
// ChangeMissionObjectives ( MOutSheikh ) ;
8562: LD_STRING MOutSheikh
8564: PPUSH
8565: CALL_OW 337
// end ;
8569: END
// function DOmar ; var who , mytick ; begin
8570: LD_INT 0
8572: PPUSH
8573: PPUSH
8574: PPUSH
// who := WhoSayAny ( donttalk , you , sex_male , class_soldier , 0 ) ;
8575: LD_ADDR_VAR 0 2
8579: PUSH
8580: LD_LOC 11
8584: PPUSH
8585: LD_EXP 1
8589: PPUSH
8590: LD_INT 1
8592: PPUSH
8593: LD_INT 1
8595: PPUSH
8596: LD_INT 0
8598: PPUSH
8599: CALL 23773 0 5
8603: ST_TO_ADDR
// DialogueOn ;
8604: CALL_OW 6
// if IsLive ( Kar ) then
8608: LD_LOC 3
8612: PPUSH
8613: CALL_OW 300
8617: IFFALSE 8631
// Say ( Kar , DOmar-Kar-1 ) ;
8619: LD_LOC 3
8623: PPUSH
8624: LD_STRING DOmar-Kar-1
8626: PPUSH
8627: CALL_OW 88
// if IsLive ( Ptr ) then
8631: LD_LOC 4
8635: PPUSH
8636: CALL_OW 300
8640: IFFALSE 8654
// Say ( Ptr , DOmar-Ptr-1 ) ;
8642: LD_LOC 4
8646: PPUSH
8647: LD_STRING DOmar-Ptr-1
8649: PPUSH
8650: CALL_OW 88
// if not IsLive ( Kar ) and not IsLive ( Ptr ) then
8654: LD_LOC 3
8658: PPUSH
8659: CALL_OW 300
8663: NOT
8664: PUSH
8665: LD_LOC 4
8669: PPUSH
8670: CALL_OW 300
8674: NOT
8675: AND
8676: IFFALSE 8690
// Say ( who , DOmar-RSol1-1 ) ;
8678: LD_VAR 0 2
8682: PPUSH
8683: LD_STRING DOmar-RSol1-1
8685: PPUSH
8686: CALL_OW 88
// if SayRadio ( Heike , DOmar-Hke-1 ) then
8690: LD_EXP 61
8694: PPUSH
8695: LD_STRING DOmar-Hke-1
8697: PPUSH
8698: CALL_OW 94
8702: IFFALSE 8716
// Say ( Bur , DOmar-Bur-1 ) ;
8704: LD_LOC 1
8708: PPUSH
8709: LD_STRING DOmar-Bur-1
8711: PPUSH
8712: CALL_OW 88
// DialogueOff ;
8716: CALL_OW 7
// end ;
8720: LD_VAR 0 1
8724: RET
// every 0 0$1 + 0 0$3.5 trigger dialogy do var i , arForces ;
8725: LD_EXP 46
8729: IFFALSE 8876
8731: GO 8733
8733: DISABLE
8734: LD_INT 0
8736: PPUSH
8737: PPUSH
// begin enable ;
8738: ENABLE
// arForces = FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) ;
8739: LD_ADDR_VAR 0 2
8743: PUSH
8744: LD_INT 22
8746: PUSH
8747: LD_INT 2
8749: PUSH
8750: EMPTY
8751: LIST
8752: LIST
8753: PUSH
8754: LD_INT 21
8756: PUSH
8757: LD_INT 1
8759: PUSH
8760: EMPTY
8761: LIST
8762: LIST
8763: PUSH
8764: EMPTY
8765: LIST
8766: LIST
8767: PPUSH
8768: CALL_OW 69
8772: ST_TO_ADDR
// for i in UnitsInside ( FilterUnitsInArea ( RoadArea , [ [ f_side , 2 ] , [ f_type , unit_vehicle ] ] ) ) do
8773: LD_ADDR_VAR 0 1
8777: PUSH
8778: LD_INT 32
8780: PPUSH
8781: LD_INT 22
8783: PUSH
8784: LD_INT 2
8786: PUSH
8787: EMPTY
8788: LIST
8789: LIST
8790: PUSH
8791: LD_INT 21
8793: PUSH
8794: LD_INT 2
8796: PUSH
8797: EMPTY
8798: LIST
8799: LIST
8800: PUSH
8801: EMPTY
8802: LIST
8803: LIST
8804: PPUSH
8805: CALL_OW 70
8809: PPUSH
8810: CALL_OW 313
8814: PUSH
8815: FOR_IN
8816: IFFALSE 8836
// arForces = arForces diff i ;
8818: LD_ADDR_VAR 0 2
8822: PUSH
8823: LD_VAR 0 2
8827: PUSH
8828: LD_VAR 0 1
8832: DIFF
8833: ST_TO_ADDR
8834: GO 8815
8836: POP
8837: POP
// if arForces <= 4 and ( IsDead ( Omar ) or not IsPlaced ( Omar ) ) then
8838: LD_VAR 0 2
8842: PUSH
8843: LD_INT 4
8845: LESSEQUAL
8846: PUSH
8847: LD_EXP 62
8851: PPUSH
8852: CALL_OW 301
8856: PUSH
8857: LD_EXP 62
8861: PPUSH
8862: CALL_OW 305
8866: NOT
8867: OR
8868: AND
8869: IFFALSE 8876
// begin disable ;
8871: DISABLE
// DBreaktrough ;
8872: CALL 8879 0 0
// end ; end ;
8876: PPOPN 2
8878: END
// function DBreaktrough ; begin
8879: LD_INT 0
8881: PPUSH
// if tick <= breaketrough_time then
8882: LD_OWVAR 1
8886: PUSH
8887: LD_EXP 17
8891: LESSEQUAL
8892: IFFALSE 8902
// action_was_fast := true ;
8894: LD_ADDR_EXP 9
8898: PUSH
8899: LD_INT 1
8901: ST_TO_ADDR
// breaked_trough := true ;
8902: LD_ADDR_EXP 10
8906: PUSH
8907: LD_INT 1
8909: ST_TO_ADDR
// DialogueOn ;
8910: CALL_OW 6
// Say ( Ptr , DBreakthrough-Ptr-1 ) ;
8914: LD_LOC 4
8918: PPUSH
8919: LD_STRING DBreakthrough-Ptr-1
8921: PPUSH
8922: CALL_OW 88
// Say ( Bur , DBreakthrough-Bur-1 ) ;
8926: LD_LOC 1
8930: PPUSH
8931: LD_STRING DBreakthrough-Bur-1
8933: PPUSH
8934: CALL_OW 88
// SayRadio ( Pla , DBreakthrough-Pla-1 ) ;
8938: LD_LOC 2
8942: PPUSH
8943: LD_STRING DBreakthrough-Pla-1
8945: PPUSH
8946: CALL_OW 94
// if action_was_fast then
8950: LD_EXP 9
8954: IFFALSE 8970
// SayRadio ( Pla , DBreakthrough-Pla-1a ) else
8956: LD_LOC 2
8960: PPUSH
8961: LD_STRING DBreakthrough-Pla-1a
8963: PPUSH
8964: CALL_OW 94
8968: GO 8982
// SayRadio ( Pla , DBreakthrough-Pla-1b ) ;
8970: LD_LOC 2
8974: PPUSH
8975: LD_STRING DBreakthrough-Pla-1b
8977: PPUSH
8978: CALL_OW 94
// if FilterAllUnits ( [ [ f_side , you ] , [ f_nation , nation_russian ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) then
8982: LD_INT 22
8984: PUSH
8985: LD_EXP 1
8989: PUSH
8990: EMPTY
8991: LIST
8992: LIST
8993: PUSH
8994: LD_INT 23
8996: PUSH
8997: LD_INT 3
8999: PUSH
9000: EMPTY
9001: LIST
9002: LIST
9003: PUSH
9004: LD_INT 2
9006: PUSH
9007: LD_INT 30
9009: PUSH
9010: LD_INT 6
9012: PUSH
9013: EMPTY
9014: LIST
9015: LIST
9016: PUSH
9017: LD_INT 30
9019: PUSH
9020: LD_INT 7
9022: PUSH
9023: EMPTY
9024: LIST
9025: LIST
9026: PUSH
9027: LD_INT 30
9029: PUSH
9030: LD_INT 8
9032: PUSH
9033: EMPTY
9034: LIST
9035: LIST
9036: PUSH
9037: EMPTY
9038: LIST
9039: LIST
9040: LIST
9041: LIST
9042: PUSH
9043: EMPTY
9044: LIST
9045: LIST
9046: LIST
9047: PPUSH
9048: CALL_OW 69
9052: IFFALSE 9081
// begin SayRadio ( Pla , DBreakthrough-Pla-1c ) ;
9054: LD_LOC 2
9058: PPUSH
9059: LD_STRING DBreakthrough-Pla-1c
9061: PPUSH
9062: CALL_OW 94
// ChangeMissionObjectives ( MAddLab ) ;
9066: LD_STRING MAddLab
9068: PPUSH
9069: CALL_OW 337
// znicit_lab := true ;
9073: LD_ADDR_EXP 68
9077: PUSH
9078: LD_INT 1
9080: ST_TO_ADDR
// end ; if byl_stevens and IsLive ( Huck ) and stv_depot then
9081: LD_EXP 67
9085: PUSH
9086: LD_LOC 7
9090: PPUSH
9091: CALL_OW 300
9095: AND
9096: PUSH
9097: LD_LOC 12
9101: AND
9102: IFFALSE 9108
// DStevensLeftBehind ;
9104: CALL 8242 0 0
// DialogueOff ;
9108: CALL_OW 7
// end ;
9112: LD_VAR 0 1
9116: RET
// export znicit_lab ; every 0 0$3 trigger znicit_lab and not FilterAllUnits ( [ [ f_side , you ] , [ f_nation , nation_russian ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) do
9117: LD_EXP 68
9121: PUSH
9122: LD_INT 22
9124: PUSH
9125: LD_EXP 1
9129: PUSH
9130: EMPTY
9131: LIST
9132: LIST
9133: PUSH
9134: LD_INT 23
9136: PUSH
9137: LD_INT 3
9139: PUSH
9140: EMPTY
9141: LIST
9142: LIST
9143: PUSH
9144: LD_INT 2
9146: PUSH
9147: LD_INT 30
9149: PUSH
9150: LD_INT 6
9152: PUSH
9153: EMPTY
9154: LIST
9155: LIST
9156: PUSH
9157: LD_INT 30
9159: PUSH
9160: LD_INT 7
9162: PUSH
9163: EMPTY
9164: LIST
9165: LIST
9166: PUSH
9167: LD_INT 30
9169: PUSH
9170: LD_INT 8
9172: PUSH
9173: EMPTY
9174: LIST
9175: LIST
9176: PUSH
9177: EMPTY
9178: LIST
9179: LIST
9180: LIST
9181: LIST
9182: PUSH
9183: EMPTY
9184: LIST
9185: LIST
9186: LIST
9187: PPUSH
9188: CALL_OW 69
9192: NOT
9193: AND
9194: IFFALSE 9206
9196: GO 9198
9198: DISABLE
// begin ChangeMissionObjectives ( MOutLab ) ;
9199: LD_STRING MOutLab
9201: PPUSH
9202: CALL_OW 337
// end ;
9206: END
// every 0 0$5 + 0 0$0.5 trigger dialogy and breaked_trough and FilterUnitsInArea ( enter_near_road , [ [ f_side , you ] ] ) and See_any ( you , [ ArScout1 , ArScout2 , ArScout3 ] ) do
9207: LD_EXP 46
9211: PUSH
9212: LD_EXP 10
9216: AND
9217: PUSH
9218: LD_INT 9
9220: PPUSH
9221: LD_INT 22
9223: PUSH
9224: LD_EXP 1
9228: PUSH
9229: EMPTY
9230: LIST
9231: LIST
9232: PUSH
9233: EMPTY
9234: LIST
9235: PPUSH
9236: CALL_OW 70
9240: AND
9241: PUSH
9242: LD_EXP 1
9246: PPUSH
9247: LD_EXP 77
9251: PUSH
9252: LD_EXP 78
9256: PUSH
9257: LD_EXP 79
9261: PUSH
9262: EMPTY
9263: LIST
9264: LIST
9265: LIST
9266: PPUSH
9267: CALL 23974 0 2
9271: AND
9272: IFFALSE 9281
9274: GO 9276
9276: DISABLE
// begin DPatrol ;
9277: CALL 9282 0 0
// end ;
9281: END
// function DPatrol ; var RSol1 ; begin
9282: LD_INT 0
9284: PPUSH
9285: PPUSH
// RSol1 := WhoSayAny ( donttalk , you , sex_male , 0 , 0 ) ;
9286: LD_ADDR_VAR 0 2
9290: PUSH
9291: LD_LOC 11
9295: PPUSH
9296: LD_EXP 1
9300: PPUSH
9301: LD_INT 1
9303: PPUSH
9304: LD_INT 0
9306: PPUSH
9307: LD_INT 0
9309: PPUSH
9310: CALL 23773 0 5
9314: ST_TO_ADDR
// DialogueOn ;
9315: CALL_OW 6
// if IsLive ( Kar ) then
9319: LD_LOC 3
9323: PPUSH
9324: CALL_OW 300
9328: IFFALSE 9342
// Say ( Kar , DPatrol-Kar-1 ) ;
9330: LD_LOC 3
9334: PPUSH
9335: LD_STRING DPatrol-Kar-1
9337: PPUSH
9338: CALL_OW 88
// if IsLive ( Ptr ) then
9342: LD_LOC 4
9346: PPUSH
9347: CALL_OW 300
9351: IFFALSE 9365
// Say ( Ptr , DPatrol-Ptr-1 ) ;
9353: LD_LOC 4
9357: PPUSH
9358: LD_STRING DPatrol-Ptr-1
9360: PPUSH
9361: CALL_OW 88
// if not IsLive ( Kar ) and not IsLive ( Ptr ) then
9365: LD_LOC 3
9369: PPUSH
9370: CALL_OW 300
9374: NOT
9375: PUSH
9376: LD_LOC 4
9380: PPUSH
9381: CALL_OW 300
9385: NOT
9386: AND
9387: IFFALSE 9401
// Say ( RSol1 , DPatrol-RSol1-1 ) ;
9389: LD_VAR 0 2
9393: PPUSH
9394: LD_STRING DPatrol-RSol1-1
9396: PPUSH
9397: CALL_OW 88
// Say ( Bur , DPatrol-Bur-1 ) ;
9401: LD_LOC 1
9405: PPUSH
9406: LD_STRING DPatrol-Bur-1
9408: PPUSH
9409: CALL_OW 88
// DialogueOff ;
9413: CALL_OW 7
// end ;
9417: LD_VAR 0 1
9421: RET
// var used1 , used2 ; function TestEnd ; var lidi_in , lidi_in_cars , lidi_all , i ; begin
9422: LD_INT 0
9424: PPUSH
9425: PPUSH
9426: PPUSH
9427: PPUSH
9428: PPUSH
// lidi_in_cars = [ ] ;
9429: LD_ADDR_VAR 0 3
9433: PUSH
9434: EMPTY
9435: ST_TO_ADDR
// lidi_in := FilterHumansInArea ( exit_rus , [ [ f_side , you ] , [ f_nation , nation_russian ] , [ f_type , unit_human ] ] ) ;
9436: LD_ADDR_VAR 0 2
9440: PUSH
9441: LD_INT 22
9443: PPUSH
9444: LD_INT 22
9446: PUSH
9447: LD_EXP 1
9451: PUSH
9452: EMPTY
9453: LIST
9454: LIST
9455: PUSH
9456: LD_INT 23
9458: PUSH
9459: LD_INT 3
9461: PUSH
9462: EMPTY
9463: LIST
9464: LIST
9465: PUSH
9466: LD_INT 21
9468: PUSH
9469: LD_INT 1
9471: PUSH
9472: EMPTY
9473: LIST
9474: LIST
9475: PUSH
9476: EMPTY
9477: LIST
9478: LIST
9479: LIST
9480: PPUSH
9481: CALL 24058 0 2
9485: ST_TO_ADDR
// for i in lidi_in do
9486: LD_ADDR_VAR 0 5
9490: PUSH
9491: LD_VAR 0 2
9495: PUSH
9496: FOR_IN
9497: IFFALSE 9540
// if GetType ( IsInUnit ( i ) ) = unit_vehicle then
9499: LD_VAR 0 5
9503: PPUSH
9504: CALL_OW 310
9508: PPUSH
9509: CALL_OW 247
9513: PUSH
9514: LD_INT 2
9516: EQUAL
9517: IFFALSE 9538
// begin lidi_in_cars := lidi_in_cars ^ [ i ] ;
9519: LD_ADDR_VAR 0 3
9523: PUSH
9524: LD_VAR 0 3
9528: PUSH
9529: LD_VAR 0 5
9533: PUSH
9534: EMPTY
9535: LIST
9536: ADD
9537: ST_TO_ADDR
// end ;
9538: GO 9496
9540: POP
9541: POP
// result := 0 ;
9542: LD_ADDR_VAR 0 1
9546: PUSH
9547: LD_INT 0
9549: ST_TO_ADDR
// if ( lidi_in >= 6 ) and ( IsInArea ( IsInUnit ( Bur ) , exit_rus ) ) then
9550: LD_VAR 0 2
9554: PUSH
9555: LD_INT 6
9557: GREATEREQUAL
9558: PUSH
9559: LD_LOC 1
9563: PPUSH
9564: CALL_OW 310
9568: PPUSH
9569: LD_INT 22
9571: PPUSH
9572: CALL_OW 308
9576: AND
9577: IFFALSE 9729
// begin lidi_all := FilterAllUnits ( [ [ f_side , you ] , [ f_nation , nation_russian ] , [ f_type , unit_human ] ] ) ;
9579: LD_ADDR_VAR 0 4
9583: PUSH
9584: LD_INT 22
9586: PUSH
9587: LD_EXP 1
9591: PUSH
9592: EMPTY
9593: LIST
9594: LIST
9595: PUSH
9596: LD_INT 23
9598: PUSH
9599: LD_INT 3
9601: PUSH
9602: EMPTY
9603: LIST
9604: LIST
9605: PUSH
9606: LD_INT 21
9608: PUSH
9609: LD_INT 1
9611: PUSH
9612: EMPTY
9613: LIST
9614: LIST
9615: PUSH
9616: EMPTY
9617: LIST
9618: LIST
9619: LIST
9620: PPUSH
9621: CALL_OW 69
9625: ST_TO_ADDR
// if lidi_in_cars >= 6 then
9626: LD_VAR 0 3
9630: PUSH
9631: LD_INT 6
9633: GREATEREQUAL
9634: IFFALSE 9694
// begin if ( lidi_all + 0 ) > ( lidi_in_cars + 0 ) then
9636: LD_VAR 0 4
9640: PUSH
9641: LD_INT 0
9643: PLUS
9644: PUSH
9645: LD_VAR 0 3
9649: PUSH
9650: LD_INT 0
9652: PLUS
9653: GREATER
9654: IFFALSE 9664
// begin result := 2 ;
9656: LD_ADDR_VAR 0 1
9660: PUSH
9661: LD_INT 2
9663: ST_TO_ADDR
// end ; if ( lidi_all + 0 ) <= ( lidi_in_cars + 0 ) then
9664: LD_VAR 0 4
9668: PUSH
9669: LD_INT 0
9671: PLUS
9672: PUSH
9673: LD_VAR 0 3
9677: PUSH
9678: LD_INT 0
9680: PLUS
9681: LESSEQUAL
9682: IFFALSE 9692
// result := 3 ;
9684: LD_ADDR_VAR 0 1
9688: PUSH
9689: LD_INT 3
9691: ST_TO_ADDR
// end else
9692: GO 9729
// begin if not used1 and ( lidi_in + 0 ) > ( lidi_in_cars + 0 ) then
9694: LD_LOC 14
9698: NOT
9699: PUSH
9700: LD_VAR 0 2
9704: PUSH
9705: LD_INT 0
9707: PLUS
9708: PUSH
9709: LD_VAR 0 3
9713: PUSH
9714: LD_INT 0
9716: PLUS
9717: GREATER
9718: AND
9719: IFFALSE 9729
// begin result := 1 ;
9721: LD_ADDR_VAR 0 1
9725: PUSH
9726: LD_INT 1
9728: ST_TO_ADDR
// end ; end ; end ; end ;
9729: LD_VAR 0 1
9733: RET
// every 0 0$2 do var qr ;
9734: GO 9736
9736: DISABLE
9737: LD_INT 0
9739: PPUSH
// begin case TestEnd of 0 :
9740: CALL 9422 0 0
9744: PUSH
9745: LD_INT 0
9747: DOUBLE
9748: EQUAL
9749: IFTRUE 9753
9751: GO 9764
9753: POP
// begin end_the_mission_allowed := false ;
9754: LD_ADDR_OWVAR 57
9758: PUSH
9759: LD_INT 0
9761: ST_TO_ADDR
// end ; 1 :
9762: GO 9895
9764: LD_INT 1
9766: DOUBLE
9767: EQUAL
9768: IFTRUE 9772
9770: GO 9811
9772: POP
// begin end_the_mission_allowed := false ;
9773: LD_ADDR_OWVAR 57
9777: PUSH
9778: LD_INT 0
9780: ST_TO_ADDR
// if not used1 then
9781: LD_LOC 14
9785: NOT
9786: IFFALSE 9809
// begin qr := Query ( Qvehicles ) ;
9788: LD_ADDR_VAR 0 1
9792: PUSH
9793: LD_STRING Qvehicles
9795: PPUSH
9796: CALL_OW 97
9800: ST_TO_ADDR
// used1 := true ;
9801: LD_ADDR_LOC 14
9805: PUSH
9806: LD_INT 1
9808: ST_TO_ADDR
// end ; end ; 2 :
9809: GO 9895
9811: LD_INT 2
9813: DOUBLE
9814: EQUAL
9815: IFTRUE 9819
9817: GO 9879
9819: POP
// begin end_the_mission_allowed := true ;
9820: LD_ADDR_OWVAR 57
9824: PUSH
9825: LD_INT 1
9827: ST_TO_ADDR
// if not used2 then
9828: LD_LOC 15
9832: NOT
9833: IFFALSE 9877
// begin ChangeMissionObjectives ( MOutDefend ) ;
9835: LD_STRING MOutDefend
9837: PPUSH
9838: CALL_OW 337
// qr := Query ( QEndMission ) ;
9842: LD_ADDR_VAR 0 1
9846: PUSH
9847: LD_STRING QEndMission
9849: PPUSH
9850: CALL_OW 97
9854: ST_TO_ADDR
// used2 := true ;
9855: LD_ADDR_LOC 15
9859: PUSH
9860: LD_INT 1
9862: ST_TO_ADDR
// if qr = 1 then
9863: LD_VAR 0 1
9867: PUSH
9868: LD_INT 1
9870: EQUAL
9871: IFFALSE 9877
// Vyhra ;
9873: CALL 309 0 0
// end ; end ; 3 :
9877: GO 9895
9879: LD_INT 3
9881: DOUBLE
9882: EQUAL
9883: IFTRUE 9887
9885: GO 9894
9887: POP
// begin Vyhra ;
9888: CALL 309 0 0
// end ; end ;
9892: GO 9895
9894: POP
// enable ;
9895: ENABLE
// end ;
9896: PPOPN 1
9898: END
// every 0 0$2 trigger IsInUnit ( Omar ) = mastodon do
9899: LD_EXP 62
9903: PPUSH
9904: CALL_OW 310
9908: PUSH
9909: LD_INT 1
9911: EQUAL
9912: IFFALSE 9929
9914: GO 9916
9916: DISABLE
// begin ComCarabine ( Omar ) ;
9917: LD_EXP 62
9921: PPUSH
9922: CALL_OW 162
// enable ( 99 ) ;
9926: LD_INT 99
9928: ENABLE_MARKED
// end ;
9929: END
// every 0 0$2 trigger not IsInUnit ( Omar ) = mastodon marked 99 do var mytick ;
9930: LD_EXP 62
9934: PPUSH
9935: CALL_OW 310
9939: PUSH
9940: LD_INT 1
9942: EQUAL
9943: NOT
9944: IFFALSE 10124
9946: GO 9948
9948: DISABLE
9949: LD_INT 0
9951: PPUSH
// begin ComSabre ( Omar ) ;
9952: LD_EXP 62
9956: PPUSH
9957: CALL_OW 163
// wait ( 0 0$1 ) ;
9961: LD_INT 35
9963: PPUSH
9964: CALL_OW 67
// mytick := tick + 0 0$5 ;
9968: LD_ADDR_VAR 0 1
9972: PUSH
9973: LD_OWVAR 1
9977: PUSH
9978: LD_INT 175
9980: PLUS
9981: ST_TO_ADDR
// while not IsInArea ( Omar , omar_exit ) and tick < mytick do
9982: LD_EXP 62
9986: PPUSH
9987: LD_INT 26
9989: PPUSH
9990: CALL_OW 308
9994: NOT
9995: PUSH
9996: LD_OWVAR 1
10000: PUSH
10001: LD_VAR 0 1
10005: LESS
10006: AND
10007: IFFALSE 10032
// begin ComMoveToArea ( Omar , omar_exit ) ;
10009: LD_EXP 62
10013: PPUSH
10014: LD_INT 26
10016: PPUSH
10017: CALL_OW 113
// DU_wait ( Omar ) ;
10021: LD_EXP 62
10025: PPUSH
10026: CALL 22231 0 1
// end ;
10030: GO 9982
// ComStop ( Omar ) ;
10032: LD_EXP 62
10036: PPUSH
10037: CALL_OW 141
// wait ( [ 4 4$30 , 2 2$15 , 0 0$30 ] [ difficulty ] ) ;
10041: LD_INT 9450
10043: PUSH
10044: LD_INT 4725
10046: PUSH
10047: LD_INT 1050
10049: PUSH
10050: EMPTY
10051: LIST
10052: LIST
10053: LIST
10054: PUSH
10055: LD_OWVAR 67
10059: ARRAY
10060: PPUSH
10061: CALL_OW 67
// while not IsInArea ( Omar , omar_exit ) and tick < mytick do
10065: LD_EXP 62
10069: PPUSH
10070: LD_INT 26
10072: PPUSH
10073: CALL_OW 308
10077: NOT
10078: PUSH
10079: LD_OWVAR 1
10083: PUSH
10084: LD_VAR 0 1
10088: LESS
10089: AND
10090: IFFALSE 10115
// begin ComMoveToArea ( Omar , omar_exit ) ;
10092: LD_EXP 62
10096: PPUSH
10097: LD_INT 26
10099: PPUSH
10100: CALL_OW 113
// DU_wait ( Omar ) ;
10104: LD_EXP 62
10108: PPUSH
10109: CALL 22231 0 1
// end ;
10113: GO 10065
// RemoveUnit ( Omar ) ;
10115: LD_EXP 62
10119: PPUSH
10120: CALL_OW 64
// end ; end_of_file
10124: PPOPN 1
10126: END
// var builds1 , builds2 , builds3 , builds4 , builds5 , builds6 , builds7 , builds8 ; export stavi ; var arabs_init ; var arabs ; var upgrade ; every 0 0$5 do var a ;
10127: GO 10129
10129: DISABLE
10130: LD_INT 0
10132: PPUSH
// begin a := sol ;
10133: LD_ADDR_VAR 0 1
10137: PUSH
10138: LD_EXP 19
10142: ST_TO_ADDR
// sol := UnitFilter ( a , [ [ f_class , class_soldier ] ] ) ;
10143: LD_ADDR_EXP 19
10147: PUSH
10148: LD_VAR 0 1
10152: PPUSH
10153: LD_INT 25
10155: PUSH
10156: LD_INT 1
10158: PUSH
10159: EMPTY
10160: LIST
10161: LIST
10162: PUSH
10163: EMPTY
10164: LIST
10165: PPUSH
10166: CALL_OW 72
10170: ST_TO_ADDR
// mor := UnitFilter ( a , [ [ f_class , class_mortar ] ] ) ;
10171: LD_ADDR_EXP 20
10175: PUSH
10176: LD_VAR 0 1
10180: PPUSH
10181: LD_INT 25
10183: PUSH
10184: LD_INT 8
10186: PUSH
10187: EMPTY
10188: LIST
10189: LIST
10190: PUSH
10191: EMPTY
10192: LIST
10193: PPUSH
10194: CALL_OW 72
10198: ST_TO_ADDR
// enable ;
10199: ENABLE
// end ;
10200: PPOPN 1
10202: END
// every 30 30$0 do var a , i ;
10203: GO 10205
10205: DISABLE
10206: LD_INT 0
10208: PPUSH
10209: PPUSH
// begin InitUc ;
10210: CALL_OW 18
// InitHc ;
10214: CALL_OW 19
// uc_nation := nation_arabian ;
10218: LD_ADDR_OWVAR 21
10222: PUSH
10223: LD_INT 2
10225: ST_TO_ADDR
// uc_side := arabians ;
10226: LD_ADDR_OWVAR 20
10230: PUSH
10231: LD_EXP 3
10235: ST_TO_ADDR
// for i := 1 to 2 + difficulty do
10236: LD_ADDR_VAR 0 2
10240: PUSH
10241: DOUBLE
10242: LD_INT 1
10244: DEC
10245: ST_TO_ADDR
10246: LD_INT 2
10248: PUSH
10249: LD_OWVAR 67
10253: PLUS
10254: PUSH
10255: FOR_TO
10256: IFFALSE 10322
// begin a := CreateHuman ;
10258: LD_ADDR_VAR 0 1
10262: PUSH
10263: CALL_OW 44
10267: ST_TO_ADDR
// PlaceUnitXYR ( a , 148 , 58 , 5 , false ) ;
10268: LD_VAR 0 1
10272: PPUSH
10273: LD_INT 148
10275: PPUSH
10276: LD_INT 58
10278: PPUSH
10279: LD_INT 5
10281: PPUSH
10282: LD_INT 0
10284: PPUSH
10285: CALL_OW 50
// ComMoveXY ( a , 134 , 68 ) ;
10289: LD_VAR 0 1
10293: PPUSH
10294: LD_INT 134
10296: PPUSH
10297: LD_INT 68
10299: PPUSH
10300: CALL_OW 111
// sol := sol ^ a ;
10304: LD_ADDR_EXP 19
10308: PUSH
10309: LD_EXP 19
10313: PUSH
10314: LD_VAR 0 1
10318: ADD
10319: ST_TO_ADDR
// end ;
10320: GO 10255
10322: POP
10323: POP
// end ;
10324: PPOPN 2
10326: END
// export function place_arabs_base ; begin
10327: LD_INT 0
10329: PPUSH
// upgrade := 10 ;
10330: LD_ADDR_LOC 26
10334: PUSH
10335: LD_INT 10
10337: ST_TO_ADDR
// arabs_init := [ [ [ 2 , class_engineer , 4 ] , [ 1 , class_scientistic , 4 ] , [ 8 , class_soldier , 3 ] , [ 0 , class_mortar , 2 ] , [ 3 , class_mechanic , 3 ] ] , [ [ 2 , class_engineer , 5 ] , [ 1 , class_scientistic , 4 ] , [ 8 , class_soldier , 4 ] , [ 1 , class_mortar , 3 ] , [ 3 , class_mechanic , 4 ] ] , [ [ 2 , class_engineer , 6 ] , [ 1 , class_scientistic , 4 ] , [ 8 , class_soldier , 6 ] , [ 2 , class_mortar , 5 ] , [ 3 , class_mechanic , 6 ] ] ] [ difficulty ] ;
10338: LD_ADDR_LOC 24
10342: PUSH
10343: LD_INT 2
10345: PUSH
10346: LD_INT 2
10348: PUSH
10349: LD_INT 4
10351: PUSH
10352: EMPTY
10353: LIST
10354: LIST
10355: LIST
10356: PUSH
10357: LD_INT 1
10359: PUSH
10360: LD_INT 4
10362: PUSH
10363: LD_INT 4
10365: PUSH
10366: EMPTY
10367: LIST
10368: LIST
10369: LIST
10370: PUSH
10371: LD_INT 8
10373: PUSH
10374: LD_INT 1
10376: PUSH
10377: LD_INT 3
10379: PUSH
10380: EMPTY
10381: LIST
10382: LIST
10383: LIST
10384: PUSH
10385: LD_INT 0
10387: PUSH
10388: LD_INT 8
10390: PUSH
10391: LD_INT 2
10393: PUSH
10394: EMPTY
10395: LIST
10396: LIST
10397: LIST
10398: PUSH
10399: LD_INT 3
10401: PUSH
10402: LD_INT 3
10404: PUSH
10405: LD_INT 3
10407: PUSH
10408: EMPTY
10409: LIST
10410: LIST
10411: LIST
10412: PUSH
10413: EMPTY
10414: LIST
10415: LIST
10416: LIST
10417: LIST
10418: LIST
10419: PUSH
10420: LD_INT 2
10422: PUSH
10423: LD_INT 2
10425: PUSH
10426: LD_INT 5
10428: PUSH
10429: EMPTY
10430: LIST
10431: LIST
10432: LIST
10433: PUSH
10434: LD_INT 1
10436: PUSH
10437: LD_INT 4
10439: PUSH
10440: LD_INT 4
10442: PUSH
10443: EMPTY
10444: LIST
10445: LIST
10446: LIST
10447: PUSH
10448: LD_INT 8
10450: PUSH
10451: LD_INT 1
10453: PUSH
10454: LD_INT 4
10456: PUSH
10457: EMPTY
10458: LIST
10459: LIST
10460: LIST
10461: PUSH
10462: LD_INT 1
10464: PUSH
10465: LD_INT 8
10467: PUSH
10468: LD_INT 3
10470: PUSH
10471: EMPTY
10472: LIST
10473: LIST
10474: LIST
10475: PUSH
10476: LD_INT 3
10478: PUSH
10479: LD_INT 3
10481: PUSH
10482: LD_INT 4
10484: PUSH
10485: EMPTY
10486: LIST
10487: LIST
10488: LIST
10489: PUSH
10490: EMPTY
10491: LIST
10492: LIST
10493: LIST
10494: LIST
10495: LIST
10496: PUSH
10497: LD_INT 2
10499: PUSH
10500: LD_INT 2
10502: PUSH
10503: LD_INT 6
10505: PUSH
10506: EMPTY
10507: LIST
10508: LIST
10509: LIST
10510: PUSH
10511: LD_INT 1
10513: PUSH
10514: LD_INT 4
10516: PUSH
10517: LD_INT 4
10519: PUSH
10520: EMPTY
10521: LIST
10522: LIST
10523: LIST
10524: PUSH
10525: LD_INT 8
10527: PUSH
10528: LD_INT 1
10530: PUSH
10531: LD_INT 6
10533: PUSH
10534: EMPTY
10535: LIST
10536: LIST
10537: LIST
10538: PUSH
10539: LD_INT 2
10541: PUSH
10542: LD_INT 8
10544: PUSH
10545: LD_INT 5
10547: PUSH
10548: EMPTY
10549: LIST
10550: LIST
10551: LIST
10552: PUSH
10553: LD_INT 3
10555: PUSH
10556: LD_INT 3
10558: PUSH
10559: LD_INT 6
10561: PUSH
10562: EMPTY
10563: LIST
10564: LIST
10565: LIST
10566: PUSH
10567: EMPTY
10568: LIST
10569: LIST
10570: LIST
10571: LIST
10572: LIST
10573: PUSH
10574: EMPTY
10575: LIST
10576: LIST
10577: LIST
10578: PUSH
10579: LD_OWVAR 67
10583: ARRAY
10584: ST_TO_ADDR
// builds1 := [ [ 124 , 60 , 2 , b_depot ] , [ 118 , 63 , 1 , b_breastwork ] , [ 120 , 66 , 1 , b_breastwork ] , [ 123 , 73 , 1 , b_breastwork ] ] ;
10585: LD_ADDR_LOC 16
10589: PUSH
10590: LD_INT 124
10592: PUSH
10593: LD_INT 60
10595: PUSH
10596: LD_INT 2
10598: PUSH
10599: LD_INT 0
10601: PUSH
10602: EMPTY
10603: LIST
10604: LIST
10605: LIST
10606: LIST
10607: PUSH
10608: LD_INT 118
10610: PUSH
10611: LD_INT 63
10613: PUSH
10614: LD_INT 1
10616: PUSH
10617: LD_INT 31
10619: PUSH
10620: EMPTY
10621: LIST
10622: LIST
10623: LIST
10624: LIST
10625: PUSH
10626: LD_INT 120
10628: PUSH
10629: LD_INT 66
10631: PUSH
10632: LD_INT 1
10634: PUSH
10635: LD_INT 31
10637: PUSH
10638: EMPTY
10639: LIST
10640: LIST
10641: LIST
10642: LIST
10643: PUSH
10644: LD_INT 123
10646: PUSH
10647: LD_INT 73
10649: PUSH
10650: LD_INT 1
10652: PUSH
10653: LD_INT 31
10655: PUSH
10656: EMPTY
10657: LIST
10658: LIST
10659: LIST
10660: LIST
10661: PUSH
10662: EMPTY
10663: LIST
10664: LIST
10665: LIST
10666: LIST
10667: ST_TO_ADDR
// builds2 := [ [ 129 , 74 , 2 , b_armoury ] , [ 131 , 51 , 2 , b_oil_mine ] , [ 138 , 78 , 5 , b_lab ] ] ;
10668: LD_ADDR_LOC 17
10672: PUSH
10673: LD_INT 129
10675: PUSH
10676: LD_INT 74
10678: PUSH
10679: LD_INT 2
10681: PUSH
10682: LD_INT 4
10684: PUSH
10685: EMPTY
10686: LIST
10687: LIST
10688: LIST
10689: LIST
10690: PUSH
10691: LD_INT 131
10693: PUSH
10694: LD_INT 51
10696: PUSH
10697: LD_INT 2
10699: PUSH
10700: LD_INT 29
10702: PUSH
10703: EMPTY
10704: LIST
10705: LIST
10706: LIST
10707: LIST
10708: PUSH
10709: LD_INT 138
10711: PUSH
10712: LD_INT 78
10714: PUSH
10715: LD_INT 5
10717: PUSH
10718: LD_INT 6
10720: PUSH
10721: EMPTY
10722: LIST
10723: LIST
10724: LIST
10725: LIST
10726: PUSH
10727: EMPTY
10728: LIST
10729: LIST
10730: LIST
10731: ST_TO_ADDR
// builds3 := [ [ 137 , 63 , 4 , b_workshop ] , [ 137 , 63 , upgrade , b_workshop ] , [ 137 , 60 , 3 , b_ext_stitch ] , [ 128 , 53 , 1 , b_oil_power ] , [ 140 , 66 , 5 , b_ext_track ] ] ;
10732: LD_ADDR_LOC 18
10736: PUSH
10737: LD_INT 137
10739: PUSH
10740: LD_INT 63
10742: PUSH
10743: LD_INT 4
10745: PUSH
10746: LD_INT 2
10748: PUSH
10749: EMPTY
10750: LIST
10751: LIST
10752: LIST
10753: LIST
10754: PUSH
10755: LD_INT 137
10757: PUSH
10758: LD_INT 63
10760: PUSH
10761: LD_LOC 26
10765: PUSH
10766: LD_INT 2
10768: PUSH
10769: EMPTY
10770: LIST
10771: LIST
10772: LIST
10773: LIST
10774: PUSH
10775: LD_INT 137
10777: PUSH
10778: LD_INT 60
10780: PUSH
10781: LD_INT 3
10783: PUSH
10784: LD_INT 23
10786: PUSH
10787: EMPTY
10788: LIST
10789: LIST
10790: LIST
10791: LIST
10792: PUSH
10793: LD_INT 128
10795: PUSH
10796: LD_INT 53
10798: PUSH
10799: LD_INT 1
10801: PUSH
10802: LD_INT 26
10804: PUSH
10805: EMPTY
10806: LIST
10807: LIST
10808: LIST
10809: LIST
10810: PUSH
10811: LD_INT 140
10813: PUSH
10814: LD_INT 66
10816: PUSH
10817: LD_INT 5
10819: PUSH
10820: LD_INT 16
10822: PUSH
10823: EMPTY
10824: LIST
10825: LIST
10826: LIST
10827: LIST
10828: PUSH
10829: EMPTY
10830: LIST
10831: LIST
10832: LIST
10833: LIST
10834: LIST
10835: ST_TO_ADDR
// builds4 := [ [ 128 , 56 , 1 , b_oil_power ] , [ 138 , 78 , upgrade , b_lab , b_lab_weapon ] ] ;
10836: LD_ADDR_LOC 19
10840: PUSH
10841: LD_INT 128
10843: PUSH
10844: LD_INT 56
10846: PUSH
10847: LD_INT 1
10849: PUSH
10850: LD_INT 26
10852: PUSH
10853: EMPTY
10854: LIST
10855: LIST
10856: LIST
10857: LIST
10858: PUSH
10859: LD_INT 138
10861: PUSH
10862: LD_INT 78
10864: PUSH
10865: LD_LOC 26
10869: PUSH
10870: LD_INT 6
10872: PUSH
10873: LD_INT 10
10875: PUSH
10876: EMPTY
10877: LIST
10878: LIST
10879: LIST
10880: LIST
10881: LIST
10882: PUSH
10883: EMPTY
10884: LIST
10885: LIST
10886: ST_TO_ADDR
// builds5 := [ [ 141 , 63 , 4 , b_ext_gun ] ] ;
10887: LD_ADDR_LOC 20
10891: PUSH
10892: LD_INT 141
10894: PUSH
10895: LD_INT 63
10897: PUSH
10898: LD_INT 4
10900: PUSH
10901: LD_INT 17
10903: PUSH
10904: EMPTY
10905: LIST
10906: LIST
10907: LIST
10908: LIST
10909: PUSH
10910: EMPTY
10911: LIST
10912: ST_TO_ADDR
// builds6 := [ [ 129 , 74 , upgrade , b_armoury ] ] ;
10913: LD_ADDR_LOC 21
10917: PUSH
10918: LD_INT 129
10920: PUSH
10921: LD_INT 74
10923: PUSH
10924: LD_LOC 26
10928: PUSH
10929: LD_INT 4
10931: PUSH
10932: EMPTY
10933: LIST
10934: LIST
10935: LIST
10936: LIST
10937: PUSH
10938: EMPTY
10939: LIST
10940: ST_TO_ADDR
// builds7 := [ [ 138 , 78 , upgrade , b_lab , b_lab_opto ] , [ 118 , 61 , upgrade , b_breastwork , ar_gun ] , [ 120 , 66 , upgrade , b_breastwork , ar_gun ] , [ 123 , 73 , upgrade , b_breastwork , ar_gun ] , [ 124 , 60 , upgrade , b_depot ] ] ;
10941: LD_ADDR_LOC 22
10945: PUSH
10946: LD_INT 138
10948: PUSH
10949: LD_INT 78
10951: PUSH
10952: LD_LOC 26
10956: PUSH
10957: LD_INT 6
10959: PUSH
10960: LD_INT 15
10962: PUSH
10963: EMPTY
10964: LIST
10965: LIST
10966: LIST
10967: LIST
10968: LIST
10969: PUSH
10970: LD_INT 118
10972: PUSH
10973: LD_INT 61
10975: PUSH
10976: LD_LOC 26
10980: PUSH
10981: LD_INT 31
10983: PUSH
10984: LD_INT 27
10986: PUSH
10987: EMPTY
10988: LIST
10989: LIST
10990: LIST
10991: LIST
10992: LIST
10993: PUSH
10994: LD_INT 120
10996: PUSH
10997: LD_INT 66
10999: PUSH
11000: LD_LOC 26
11004: PUSH
11005: LD_INT 31
11007: PUSH
11008: LD_INT 27
11010: PUSH
11011: EMPTY
11012: LIST
11013: LIST
11014: LIST
11015: LIST
11016: LIST
11017: PUSH
11018: LD_INT 123
11020: PUSH
11021: LD_INT 73
11023: PUSH
11024: LD_LOC 26
11028: PUSH
11029: LD_INT 31
11031: PUSH
11032: LD_INT 27
11034: PUSH
11035: EMPTY
11036: LIST
11037: LIST
11038: LIST
11039: LIST
11040: LIST
11041: PUSH
11042: LD_INT 124
11044: PUSH
11045: LD_INT 60
11047: PUSH
11048: LD_LOC 26
11052: PUSH
11053: LD_INT 0
11055: PUSH
11056: EMPTY
11057: LIST
11058: LIST
11059: LIST
11060: LIST
11061: PUSH
11062: EMPTY
11063: LIST
11064: LIST
11065: LIST
11066: LIST
11067: LIST
11068: ST_TO_ADDR
// builds8 := [ [ 137 , 67 , 0 , b_ext_radar ] ] ;
11069: LD_ADDR_LOC 23
11073: PUSH
11074: LD_INT 137
11076: PUSH
11077: LD_INT 67
11079: PUSH
11080: LD_INT 0
11082: PUSH
11083: LD_INT 20
11085: PUSH
11086: EMPTY
11087: LIST
11088: LIST
11089: LIST
11090: LIST
11091: PUSH
11092: EMPTY
11093: LIST
11094: ST_TO_ADDR
// place_base ( builds1 ) ;
11095: LD_LOC 16
11099: PPUSH
11100: CALL 11222 0 1
// place_arabs ;
11104: CALL 11428 0 0
// end ;
11108: LD_VAR 0 1
11112: RET
// every 0 0$5 do
11113: GO 11115
11115: DISABLE
// begin build_base ( builds2 ) ;
11116: LD_LOC 17
11120: PPUSH
11121: CALL 11648 0 1
// wait ( 0 0$40 ) ;
11125: LD_INT 1400
11127: PPUSH
11128: CALL_OW 67
// build_base ( builds3 ) ;
11132: LD_LOC 18
11136: PPUSH
11137: CALL 11648 0 1
// wait ( 2 2$0 ) ;
11141: LD_INT 4200
11143: PPUSH
11144: CALL_OW 67
// build_base ( builds4 ) ;
11148: LD_LOC 19
11152: PPUSH
11153: CALL 11648 0 1
// wait ( 3 3$0 ) ;
11157: LD_INT 6300
11159: PPUSH
11160: CALL_OW 67
// build_base ( builds5 ) ;
11164: LD_LOC 20
11168: PPUSH
11169: CALL 11648 0 1
// wait ( 10 10$0 ) ;
11173: LD_INT 21000
11175: PPUSH
11176: CALL_OW 67
// build_base ( builds6 ) ;
11180: LD_LOC 21
11184: PPUSH
11185: CALL 11648 0 1
// wait ( 10 10$0 ) ;
11189: LD_INT 21000
11191: PPUSH
11192: CALL_OW 67
// build_base ( builds7 ) ;
11196: LD_LOC 22
11200: PPUSH
11201: CALL 11648 0 1
// wait ( 5 5$0 ) ;
11205: LD_INT 10500
11207: PPUSH
11208: CALL_OW 67
// build_base ( builds8 ) ;
11212: LD_LOC 23
11216: PPUSH
11217: CALL 11648 0 1
// end ;
11221: END
// function place_base ( builds ) ; var i , base ; begin
11222: LD_INT 0
11224: PPUSH
11225: PPUSH
11226: PPUSH
// InitUc ;
11227: CALL_OW 18
// InitBc ;
11231: CALL_OW 21
// uc_side := arabians ;
11235: LD_ADDR_OWVAR 20
11239: PUSH
11240: LD_EXP 3
11244: ST_TO_ADDR
// uc_nation := nation_arabian ;
11245: LD_ADDR_OWVAR 21
11249: PUSH
11250: LD_INT 2
11252: ST_TO_ADDR
// for i in builds do
11253: LD_ADDR_VAR 0 3
11257: PUSH
11258: LD_VAR 0 1
11262: PUSH
11263: FOR_IN
11264: IFFALSE 11362
// begin bc_type := i [ 4 ] ;
11266: LD_ADDR_OWVAR 42
11270: PUSH
11271: LD_VAR 0 3
11275: PUSH
11276: LD_INT 4
11278: ARRAY
11279: ST_TO_ADDR
// if bc_type in [ b_lab , b_lab_half , b_lab_full ] then
11280: LD_OWVAR 42
11284: PUSH
11285: LD_INT 6
11287: PUSH
11288: LD_INT 7
11290: PUSH
11291: LD_INT 8
11293: PUSH
11294: EMPTY
11295: LIST
11296: LIST
11297: LIST
11298: IN
11299: IFFALSE 11329
// begin bc_kind1 := i [ 5 ] ;
11301: LD_ADDR_OWVAR 44
11305: PUSH
11306: LD_VAR 0 3
11310: PUSH
11311: LD_INT 5
11313: ARRAY
11314: ST_TO_ADDR
// bc_kind2 := i [ 6 ] ;
11315: LD_ADDR_OWVAR 45
11319: PUSH
11320: LD_VAR 0 3
11324: PUSH
11325: LD_INT 6
11327: ARRAY
11328: ST_TO_ADDR
// end ; CreateAndPlaceBuildingXYD ( i [ 1 ] , i [ 2 ] , i [ 3 ] ) ;
11329: LD_VAR 0 3
11333: PUSH
11334: LD_INT 1
11336: ARRAY
11337: PPUSH
11338: LD_VAR 0 3
11342: PUSH
11343: LD_INT 2
11345: ARRAY
11346: PPUSH
11347: LD_VAR 0 3
11351: PUSH
11352: LD_INT 3
11354: ARRAY
11355: PPUSH
11356: CALL_OW 47
// end ;
11360: GO 11263
11362: POP
11363: POP
// base := GetBase ( FilterAllUnits ( [ f_btype , b_depot ] ) [ 1 ] ) ;
11364: LD_ADDR_VAR 0 4
11368: PUSH
11369: LD_INT 30
11371: PUSH
11372: LD_INT 0
11374: PUSH
11375: EMPTY
11376: LIST
11377: LIST
11378: PPUSH
11379: CALL_OW 69
11383: PUSH
11384: LD_INT 1
11386: ARRAY
11387: PPUSH
11388: CALL_OW 274
11392: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 450 ) ;
11393: LD_VAR 0 4
11397: PPUSH
11398: LD_INT 1
11400: PPUSH
11401: LD_INT 450
11403: PPUSH
11404: CALL_OW 277
// SetResourceType ( base , mat_oil , 200 ) ;
11408: LD_VAR 0 4
11412: PPUSH
11413: LD_INT 2
11415: PPUSH
11416: LD_INT 200
11418: PPUSH
11419: CALL_OW 277
// end ;
11423: LD_VAR 0 2
11427: RET
// function place_arabs ; var i , j ; begin
11428: LD_INT 0
11430: PPUSH
11431: PPUSH
11432: PPUSH
// InitUc ;
11433: CALL_OW 18
// InitHc ;
11437: CALL_OW 19
// uc_side := arabians ;
11441: LD_ADDR_OWVAR 20
11445: PUSH
11446: LD_EXP 3
11450: ST_TO_ADDR
// uc_nation := nation_arabian ;
11451: LD_ADDR_OWVAR 21
11455: PUSH
11456: LD_INT 2
11458: ST_TO_ADDR
// PlaceUnitXY ( Mastodon , 130 , 67 , false ) ;
11459: LD_INT 1
11461: PPUSH
11462: LD_INT 130
11464: PPUSH
11465: LD_INT 67
11467: PPUSH
11468: LD_INT 0
11470: PPUSH
11471: CALL_OW 48
// PlaceUnitXYR ( Omar , GetX ( Mastodon ) , GetY ( Mastodon ) , 5 , false ) ;
11475: LD_EXP 62
11479: PPUSH
11480: LD_INT 1
11482: PPUSH
11483: CALL_OW 250
11487: PPUSH
11488: LD_INT 1
11490: PPUSH
11491: CALL_OW 251
11495: PPUSH
11496: LD_INT 5
11498: PPUSH
11499: LD_INT 0
11501: PPUSH
11502: CALL_OW 50
// ComCarabine ( Omar ) ;
11506: LD_EXP 62
11510: PPUSH
11511: CALL_OW 162
// AddComEnterUnit ( Omar , Mastodon ) ;
11515: LD_EXP 62
11519: PPUSH
11520: LD_INT 1
11522: PPUSH
11523: CALL_OW 180
// for i in arabs_init do
11527: LD_ADDR_VAR 0 2
11531: PUSH
11532: LD_LOC 24
11536: PUSH
11537: FOR_IN
11538: IFFALSE 11609
// begin PrepareHuman ( 0 , i [ 2 ] , i [ 3 ] ) ;
11540: LD_INT 0
11542: PPUSH
11543: LD_VAR 0 2
11547: PUSH
11548: LD_INT 2
11550: ARRAY
11551: PPUSH
11552: LD_VAR 0 2
11556: PUSH
11557: LD_INT 3
11559: ARRAY
11560: PPUSH
11561: CALL_OW 380
// for j := 1 to i [ 1 ] do
11565: LD_ADDR_VAR 0 3
11569: PUSH
11570: DOUBLE
11571: LD_INT 1
11573: DEC
11574: ST_TO_ADDR
11575: LD_VAR 0 2
11579: PUSH
11580: LD_INT 1
11582: ARRAY
11583: PUSH
11584: FOR_TO
11585: IFFALSE 11605
// begin arabs := arabs ^ CreateHuman ;
11587: LD_ADDR_LOC 25
11591: PUSH
11592: LD_LOC 25
11596: PUSH
11597: CALL_OW 44
11601: ADD
11602: ST_TO_ADDR
// end ;
11603: GO 11584
11605: POP
11606: POP
// end ;
11607: GO 11537
11609: POP
11610: POP
// for i in arabs do
11611: LD_ADDR_VAR 0 2
11615: PUSH
11616: LD_LOC 25
11620: PUSH
11621: FOR_IN
11622: IFFALSE 11641
// PlaceUnitArea ( i , ar_place , false ) ;
11624: LD_VAR 0 2
11628: PPUSH
11629: LD_INT 4
11631: PPUSH
11632: LD_INT 0
11634: PPUSH
11635: CALL_OW 49
11639: GO 11621
11641: POP
11642: POP
// end ;
11643: LD_VAR 0 1
11647: RET
// function build_base ( builds ) ; var i , a , tmp_eng , eng2 ; begin
11648: LD_INT 0
11650: PPUSH
11651: PPUSH
11652: PPUSH
11653: PPUSH
11654: PPUSH
// while not eng do
11655: LD_EXP 23
11659: NOT
11660: IFFALSE 11671
// wait ( 0 0$5 ) ;
11662: LD_INT 175
11664: PPUSH
11665: CALL_OW 67
11669: GO 11655
// eng2 := eng ;
11671: LD_ADDR_VAR 0 6
11675: PUSH
11676: LD_EXP 23
11680: ST_TO_ADDR
// tmp_eng := eng2 ;
11681: LD_ADDR_VAR 0 5
11685: PUSH
11686: LD_VAR 0 6
11690: ST_TO_ADDR
// eng := [ ] ;
11691: LD_ADDR_EXP 23
11695: PUSH
11696: EMPTY
11697: ST_TO_ADDR
// for i in builds do
11698: LD_ADDR_VAR 0 3
11702: PUSH
11703: LD_VAR 0 1
11707: PUSH
11708: FOR_IN
11709: IFFALSE 12110
// begin ComExitBuilding ( tmp_eng ) ;
11711: LD_VAR 0 5
11715: PPUSH
11716: CALL_OW 122
// while not BuildingsInProgress ( arabians ) do
11720: LD_EXP 3
11724: PPUSH
11725: CALL_OW 345
11729: NOT
11730: IFFALSE 12055
// begin tmp_eng := eng2 diff DU_units ;
11732: LD_ADDR_VAR 0 5
11736: PUSH
11737: LD_VAR 0 6
11741: PUSH
11742: LD_EXP 83
11746: DIFF
11747: ST_TO_ADDR
// if i [ 3 ] = upgrade then
11748: LD_VAR 0 3
11752: PUSH
11753: LD_INT 3
11755: ARRAY
11756: PUSH
11757: LD_LOC 26
11761: EQUAL
11762: IFFALSE 11983
// begin if i [ 4 ] in [ b_lab , b_lab_half ] then
11764: LD_VAR 0 3
11768: PUSH
11769: LD_INT 4
11771: ARRAY
11772: PUSH
11773: LD_INT 6
11775: PUSH
11776: LD_INT 7
11778: PUSH
11779: EMPTY
11780: LIST
11781: LIST
11782: IN
11783: IFFALSE 11859
// begin AddComUpgradeLab ( get_build ( i [ 1 ] , i [ 2 ] , i [ 4 ] ) , i [ 5 ] ) ;
11785: LD_VAR 0 3
11789: PUSH
11790: LD_INT 1
11792: ARRAY
11793: PPUSH
11794: LD_VAR 0 3
11798: PUSH
11799: LD_INT 2
11801: ARRAY
11802: PPUSH
11803: LD_VAR 0 3
11807: PUSH
11808: LD_INT 4
11810: ARRAY
11811: PPUSH
11812: CALL 12133 0 3
11816: PPUSH
11817: LD_VAR 0 3
11821: PUSH
11822: LD_INT 5
11824: ARRAY
11825: PPUSH
11826: CALL_OW 207
// AddComMoveXY ( tmp_eng , i [ 1 ] , i [ 2 ] ) ;
11830: LD_VAR 0 5
11834: PPUSH
11835: LD_VAR 0 3
11839: PUSH
11840: LD_INT 1
11842: ARRAY
11843: PPUSH
11844: LD_VAR 0 3
11848: PUSH
11849: LD_INT 2
11851: ARRAY
11852: PPUSH
11853: CALL_OW 171
// end else
11857: GO 11981
// begin AddComUpgrade ( get_build ( i [ 1 ] , i [ 2 ] , i [ 4 ] ) ) ;
11859: LD_VAR 0 3
11863: PUSH
11864: LD_INT 1
11866: ARRAY
11867: PPUSH
11868: LD_VAR 0 3
11872: PUSH
11873: LD_INT 2
11875: ARRAY
11876: PPUSH
11877: LD_VAR 0 3
11881: PUSH
11882: LD_INT 4
11884: ARRAY
11885: PPUSH
11886: CALL 12133 0 3
11890: PPUSH
11891: CALL_OW 206
// if i [ 4 ] = b_breastwork then
11895: LD_VAR 0 3
11899: PUSH
11900: LD_INT 4
11902: ARRAY
11903: PUSH
11904: LD_INT 31
11906: EQUAL
11907: IFFALSE 11954
// AddComPlaceWeapon ( get_build ( i [ 1 ] , i [ 2 ] , i [ 4 ] ) , i [ 5 ] ) ;
11909: LD_VAR 0 3
11913: PUSH
11914: LD_INT 1
11916: ARRAY
11917: PPUSH
11918: LD_VAR 0 3
11922: PUSH
11923: LD_INT 2
11925: ARRAY
11926: PPUSH
11927: LD_VAR 0 3
11931: PUSH
11932: LD_INT 4
11934: ARRAY
11935: PPUSH
11936: CALL 12133 0 3
11940: PPUSH
11941: LD_VAR 0 3
11945: PUSH
11946: LD_INT 5
11948: ARRAY
11949: PPUSH
11950: CALL_OW 208
// AddComMoveXY ( tmp_eng , i [ 1 ] , i [ 2 ] ) ;
11954: LD_VAR 0 5
11958: PPUSH
11959: LD_VAR 0 3
11963: PUSH
11964: LD_INT 1
11966: ARRAY
11967: PPUSH
11968: LD_VAR 0 3
11972: PUSH
11973: LD_INT 2
11975: ARRAY
11976: PPUSH
11977: CALL_OW 171
// end ; end else
11981: GO 12046
// begin AddComBuild ( UnitFilter ( tmp_eng , [ f_not , [ f_hastask ] ] ) , i [ 4 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ) ;
11983: LD_VAR 0 5
11987: PPUSH
11988: LD_INT 3
11990: PUSH
11991: LD_INT 60
11993: PUSH
11994: EMPTY
11995: LIST
11996: PUSH
11997: EMPTY
11998: LIST
11999: LIST
12000: PPUSH
12001: CALL_OW 72
12005: PPUSH
12006: LD_VAR 0 3
12010: PUSH
12011: LD_INT 4
12013: ARRAY
12014: PPUSH
12015: LD_VAR 0 3
12019: PUSH
12020: LD_INT 1
12022: ARRAY
12023: PPUSH
12024: LD_VAR 0 3
12028: PUSH
12029: LD_INT 2
12031: ARRAY
12032: PPUSH
12033: LD_VAR 0 3
12037: PUSH
12038: LD_INT 3
12040: ARRAY
12041: PPUSH
12042: CALL_OW 205
// end ; wait ( 0 0$5 ) ;
12046: LD_INT 175
12048: PPUSH
12049: CALL_OW 67
// end ;
12053: GO 11720
// stavi := i ;
12055: LD_ADDR_EXP 69
12059: PUSH
12060: LD_VAR 0 3
12064: ST_TO_ADDR
// while BuildingsInProgress ( arabians ) do
12065: LD_EXP 3
12069: PPUSH
12070: CALL_OW 345
12074: IFFALSE 12085
// wait ( 0 0$1 ) ;
12076: LD_INT 35
12078: PPUSH
12079: CALL_OW 67
12083: GO 12065
// stavi := [ ] ;
12085: LD_ADDR_EXP 69
12089: PUSH
12090: EMPTY
12091: ST_TO_ADDR
// ComStop ( tmp_eng ) ;
12092: LD_VAR 0 5
12096: PPUSH
12097: CALL_OW 141
// wait ( 0 0$1 ) ;
12101: LD_INT 35
12103: PPUSH
12104: CALL_OW 67
// end ;
12108: GO 11708
12110: POP
12111: POP
// eng := eng union eng2 ;
12112: LD_ADDR_EXP 23
12116: PUSH
12117: LD_EXP 23
12121: PUSH
12122: LD_VAR 0 6
12126: UNION
12127: ST_TO_ADDR
// end ;
12128: LD_VAR 0 2
12132: RET
// function get_build ( x , y , btype ) ; var blds , i ; begin
12133: LD_INT 0
12135: PPUSH
12136: PPUSH
12137: PPUSH
// blds := FilterAllUnits ( [ f_btype , btype ] ) ;
12138: LD_ADDR_VAR 0 5
12142: PUSH
12143: LD_INT 30
12145: PUSH
12146: LD_VAR 0 3
12150: PUSH
12151: EMPTY
12152: LIST
12153: LIST
12154: PPUSH
12155: CALL_OW 69
12159: ST_TO_ADDR
// for i in blds do
12160: LD_ADDR_VAR 0 6
12164: PUSH
12165: LD_VAR 0 5
12169: PUSH
12170: FOR_IN
12171: IFFALSE 12211
// if GetX ( i ) = x and GetY ( i ) = y then
12173: LD_VAR 0 6
12177: PPUSH
12178: CALL_OW 250
12182: PUSH
12183: LD_VAR 0 1
12187: EQUAL
12188: PUSH
12189: LD_VAR 0 6
12193: PPUSH
12194: CALL_OW 251
12198: PUSH
12199: LD_VAR 0 2
12203: EQUAL
12204: AND
12205: IFFALSE 12209
// break ;
12207: GO 12211
12209: GO 12170
12211: POP
12212: POP
// if GetX ( i ) = x and GetY ( i ) = y then
12213: LD_VAR 0 6
12217: PPUSH
12218: CALL_OW 250
12222: PUSH
12223: LD_VAR 0 1
12227: EQUAL
12228: PUSH
12229: LD_VAR 0 6
12233: PPUSH
12234: CALL_OW 251
12238: PUSH
12239: LD_VAR 0 2
12243: EQUAL
12244: AND
12245: IFFALSE 12259
// result := i else
12247: LD_ADDR_VAR 0 4
12251: PUSH
12252: LD_VAR 0 6
12256: ST_TO_ADDR
12257: GO 12267
// result := 0 ;
12259: LD_ADDR_VAR 0 4
12263: PUSH
12264: LD_INT 0
12266: ST_TO_ADDR
// end ;
12267: LD_VAR 0 4
12271: RET
// export function get_stavari ; begin
12272: LD_INT 0
12274: PPUSH
// result := get_x_best ( arabs_init [ 1 ] [ 1 ] , skill_engineering , class_engineer ) diff Omar ;
12275: LD_ADDR_VAR 0 1
12279: PUSH
12280: LD_LOC 24
12284: PUSH
12285: LD_INT 1
12287: ARRAY
12288: PUSH
12289: LD_INT 1
12291: ARRAY
12292: PPUSH
12293: LD_INT 2
12295: PPUSH
12296: LD_INT 2
12298: PPUSH
12299: CALL 23504 0 3
12303: PUSH
12304: LD_EXP 62
12308: DIFF
12309: ST_TO_ADDR
// end ; end_of_file
12310: LD_VAR 0 1
12314: RET
// export under_attack ; function full_forts ; var kdo , empty , i , a , uz_in ; begin
12315: LD_INT 0
12317: PPUSH
12318: PPUSH
12319: PPUSH
12320: PPUSH
12321: PPUSH
12322: PPUSH
// empty := [ ] ;
12323: LD_ADDR_VAR 0 3
12327: PUSH
12328: EMPTY
12329: ST_TO_ADDR
// uz_in := [ ] ;
12330: LD_ADDR_VAR 0 6
12334: PUSH
12335: EMPTY
12336: ST_TO_ADDR
// kdo := get_x_best ( 0 , skill_combat , class_mortar ) ^ get_x_best ( 0 , skill_combat , class_soldier ) ;
12337: LD_ADDR_VAR 0 2
12341: PUSH
12342: LD_INT 0
12344: PPUSH
12345: LD_INT 1
12347: PPUSH
12348: LD_INT 8
12350: PPUSH
12351: CALL 23504 0 3
12355: PUSH
12356: LD_INT 0
12358: PPUSH
12359: LD_INT 1
12361: PPUSH
12362: LD_INT 1
12364: PPUSH
12365: CALL 23504 0 3
12369: ADD
12370: ST_TO_ADDR
// for i in fort do
12371: LD_ADDR_VAR 0 4
12375: PUSH
12376: LD_EXP 43
12380: PUSH
12381: FOR_IN
12382: IFFALSE 12458
// begin if not UnitsInside ( i ) then
12384: LD_VAR 0 4
12388: PPUSH
12389: CALL_OW 313
12393: NOT
12394: IFFALSE 12414
// begin empty := empty ^ i ;
12396: LD_ADDR_VAR 0 3
12400: PUSH
12401: LD_VAR 0 3
12405: PUSH
12406: LD_VAR 0 4
12410: ADD
12411: ST_TO_ADDR
// end else
12412: GO 12456
// begin kdo := kdo diff UnitsInside ( i ) ;
12414: LD_ADDR_VAR 0 2
12418: PUSH
12419: LD_VAR 0 2
12423: PUSH
12424: LD_VAR 0 4
12428: PPUSH
12429: CALL_OW 313
12433: DIFF
12434: ST_TO_ADDR
// uz_in := uz_in ^ UnitsInside ( i ) ;
12435: LD_ADDR_VAR 0 6
12439: PUSH
12440: LD_VAR 0 6
12444: PUSH
12445: LD_VAR 0 4
12449: PPUSH
12450: CALL_OW 313
12454: ADD
12455: ST_TO_ADDR
// end ; end ;
12456: GO 12381
12458: POP
12459: POP
// if kdo < empty then
12460: LD_VAR 0 2
12464: PUSH
12465: LD_VAR 0 3
12469: LESS
12470: IFFALSE 12482
// kdo := kdo ;
12472: LD_ADDR_VAR 0 2
12476: PUSH
12477: LD_VAR 0 2
12481: ST_TO_ADDR
// if kdo < empty then
12482: LD_VAR 0 2
12486: PUSH
12487: LD_VAR 0 3
12491: LESS
12492: IFFALSE 12510
// a := ( kdo + 0 ) else
12494: LD_ADDR_VAR 0 5
12498: PUSH
12499: LD_VAR 0 2
12503: PUSH
12504: LD_INT 0
12506: PLUS
12507: ST_TO_ADDR
12508: GO 12524
// a := ( empty + 0 ) ;
12510: LD_ADDR_VAR 0 5
12514: PUSH
12515: LD_VAR 0 3
12519: PUSH
12520: LD_INT 0
12522: PLUS
12523: ST_TO_ADDR
// for i := 1 to a do
12524: LD_ADDR_VAR 0 4
12528: PUSH
12529: DOUBLE
12530: LD_INT 1
12532: DEC
12533: ST_TO_ADDR
12534: LD_VAR 0 5
12538: PUSH
12539: FOR_TO
12540: IFFALSE 12654
// begin ComStop ( kdo [ i ] ) ;
12542: LD_VAR 0 2
12546: PUSH
12547: LD_VAR 0 4
12551: ARRAY
12552: PPUSH
12553: CALL_OW 141
// if IsInUnit ( kdo [ i ] ) then
12557: LD_VAR 0 2
12561: PUSH
12562: LD_VAR 0 4
12566: ARRAY
12567: PPUSH
12568: CALL_OW 310
12572: IFFALSE 12604
// begin AddComExitBuilding ( kdo [ i ] ) ;
12574: LD_VAR 0 2
12578: PUSH
12579: LD_VAR 0 4
12583: ARRAY
12584: PPUSH
12585: CALL_OW 182
// AddComExitVehicle ( kdo [ i ] ) ;
12589: LD_VAR 0 2
12593: PUSH
12594: LD_VAR 0 4
12598: ARRAY
12599: PPUSH
12600: CALL_OW 181
// end ; AddComEnterUnit ( kdo [ i ] , empty [ i ] ) ;
12604: LD_VAR 0 2
12608: PUSH
12609: LD_VAR 0 4
12613: ARRAY
12614: PPUSH
12615: LD_VAR 0 3
12619: PUSH
12620: LD_VAR 0 4
12624: ARRAY
12625: PPUSH
12626: CALL_OW 180
// uz_in := uz_in ^ kdo [ i ] ;
12630: LD_ADDR_VAR 0 6
12634: PUSH
12635: LD_VAR 0 6
12639: PUSH
12640: LD_VAR 0 2
12644: PUSH
12645: LD_VAR 0 4
12649: ARRAY
12650: ADD
12651: ST_TO_ADDR
// end ;
12652: GO 12539
12654: POP
12655: POP
// empty := [ ] ;
12656: LD_ADDR_VAR 0 3
12660: PUSH
12661: EMPTY
12662: ST_TO_ADDR
// kdo := get_x_best ( 0 , skill_mechanical , class_soldier ) diff uz_in ;
12663: LD_ADDR_VAR 0 2
12667: PUSH
12668: LD_INT 0
12670: PPUSH
12671: LD_INT 3
12673: PPUSH
12674: LD_INT 1
12676: PPUSH
12677: CALL 23504 0 3
12681: PUSH
12682: LD_VAR 0 6
12686: DIFF
12687: ST_TO_ADDR
// for i in defence diff Mastodon do
12688: LD_ADDR_VAR 0 4
12692: PUSH
12693: LD_EXP 28
12697: PUSH
12698: LD_INT 1
12700: DIFF
12701: PUSH
12702: FOR_IN
12703: IFFALSE 12758
// begin if not UnitsInside ( i ) then
12705: LD_VAR 0 4
12709: PPUSH
12710: CALL_OW 313
12714: NOT
12715: IFFALSE 12735
// begin empty := empty ^ i ;
12717: LD_ADDR_VAR 0 3
12721: PUSH
12722: LD_VAR 0 3
12726: PUSH
12727: LD_VAR 0 4
12731: ADD
12732: ST_TO_ADDR
// end else
12733: GO 12756
// kdo := kdo diff UnitsInside ( i ) ;
12735: LD_ADDR_VAR 0 2
12739: PUSH
12740: LD_VAR 0 2
12744: PUSH
12745: LD_VAR 0 4
12749: PPUSH
12750: CALL_OW 313
12754: DIFF
12755: ST_TO_ADDR
// end ;
12756: GO 12702
12758: POP
12759: POP
// if kdo < empty then
12760: LD_VAR 0 2
12764: PUSH
12765: LD_VAR 0 3
12769: LESS
12770: IFFALSE 12782
// kdo := kdo ;
12772: LD_ADDR_VAR 0 2
12776: PUSH
12777: LD_VAR 0 2
12781: ST_TO_ADDR
// if kdo < empty then
12782: LD_VAR 0 2
12786: PUSH
12787: LD_VAR 0 3
12791: LESS
12792: IFFALSE 12810
// a := ( kdo + 0 ) else
12794: LD_ADDR_VAR 0 5
12798: PUSH
12799: LD_VAR 0 2
12803: PUSH
12804: LD_INT 0
12806: PLUS
12807: ST_TO_ADDR
12808: GO 12824
// a := ( empty + 0 ) ;
12810: LD_ADDR_VAR 0 5
12814: PUSH
12815: LD_VAR 0 3
12819: PUSH
12820: LD_INT 0
12822: PLUS
12823: ST_TO_ADDR
// for i := 1 to a do
12824: LD_ADDR_VAR 0 4
12828: PUSH
12829: DOUBLE
12830: LD_INT 1
12832: DEC
12833: ST_TO_ADDR
12834: LD_VAR 0 5
12838: PUSH
12839: FOR_TO
12840: IFFALSE 12932
// begin ComStop ( kdo [ i ] ) ;
12842: LD_VAR 0 2
12846: PUSH
12847: LD_VAR 0 4
12851: ARRAY
12852: PPUSH
12853: CALL_OW 141
// if IsInUnit ( kdo [ i ] ) then
12857: LD_VAR 0 2
12861: PUSH
12862: LD_VAR 0 4
12866: ARRAY
12867: PPUSH
12868: CALL_OW 310
12872: IFFALSE 12904
// begin AddComExitBuilding ( kdo [ i ] ) ;
12874: LD_VAR 0 2
12878: PUSH
12879: LD_VAR 0 4
12883: ARRAY
12884: PPUSH
12885: CALL_OW 182
// AddComExitVehicle ( kdo [ i ] ) ;
12889: LD_VAR 0 2
12893: PUSH
12894: LD_VAR 0 4
12898: ARRAY
12899: PPUSH
12900: CALL_OW 181
// end ; AddComEnterUnit ( kdo [ i ] , empty [ i ] ) ;
12904: LD_VAR 0 2
12908: PUSH
12909: LD_VAR 0 4
12913: ARRAY
12914: PPUSH
12915: LD_VAR 0 3
12919: PUSH
12920: LD_VAR 0 4
12924: ARRAY
12925: PPUSH
12926: CALL_OW 180
// end ;
12930: GO 12839
12932: POP
12933: POP
// enable ;
12934: ENABLE
// end ;
12935: LD_VAR 0 1
12939: RET
// every 0 0$2 trigger FilterUnitsInArea ( near_base , [ f_side , you ] ) do var uns , a ;
12940: LD_INT 13
12942: PPUSH
12943: LD_INT 22
12945: PUSH
12946: LD_EXP 1
12950: PUSH
12951: EMPTY
12952: LIST
12953: LIST
12954: PPUSH
12955: CALL_OW 70
12959: IFFALSE 12977
12961: GO 12963
12963: DISABLE
12964: LD_INT 0
12966: PPUSH
12967: PPUSH
// begin under_attack := true ;
12968: LD_ADDR_EXP 70
12972: PUSH
12973: LD_INT 1
12975: ST_TO_ADDR
// enable ;
12976: ENABLE
// end ;
12977: PPOPN 2
12979: END
// every 0 0$10 trigger not FilterUnitsInArea ( near_base , [ f_side , you ] ) do
12980: LD_INT 13
12982: PPUSH
12983: LD_INT 22
12985: PUSH
12986: LD_EXP 1
12990: PUSH
12991: EMPTY
12992: LIST
12993: LIST
12994: PPUSH
12995: CALL_OW 70
12999: NOT
13000: IFFALSE 13014
13002: GO 13004
13004: DISABLE
// begin under_attack := false ;
13005: LD_ADDR_EXP 70
13009: PUSH
13010: LD_INT 0
13012: ST_TO_ADDR
// enable ;
13013: ENABLE
// end ;
13014: END
// every 0 0$10 trigger defence do
13015: LD_EXP 28
13019: IFFALSE 13057
13021: GO 13023
13023: DISABLE
// begin ComMoveXY ( defence [ 1 ] , 121 , 69 ) ;
13024: LD_EXP 28
13028: PUSH
13029: LD_INT 1
13031: ARRAY
13032: PPUSH
13033: LD_INT 121
13035: PPUSH
13036: LD_INT 69
13038: PPUSH
13039: CALL_OW 111
// AddComStand ( defence [ 1 ] ) ;
13043: LD_EXP 28
13047: PUSH
13048: LD_INT 1
13050: ARRAY
13051: PPUSH
13052: CALL_OW 225
// enable ;
13056: ENABLE
// end ;
13057: END
// every 0 0$5 + 0 0$2 marked 50 do
13058: GO 13060
13060: DISABLE
// begin full_forts ;
13061: CALL 12315 0 0
// enable ;
13065: ENABLE
// end ;
13066: END
// every 0 0$5.0 do var i ;
13067: GO 13069
13069: DISABLE
13070: LD_INT 0
13072: PPUSH
// begin if fact1 then
13073: LD_EXP 40
13077: IFFALSE 13136
// for i in mec do
13079: LD_ADDR_VAR 0 1
13083: PUSH
13084: LD_EXP 22
13088: PUSH
13089: FOR_IN
13090: IFFALSE 13134
// begin if IsIdle ( i ) or not IsInArea ( i , near_base ) then
13092: LD_VAR 0 1
13096: PPUSH
13097: CALL_OW 316
13101: PUSH
13102: LD_VAR 0 1
13106: PPUSH
13107: LD_INT 13
13109: PPUSH
13110: CALL_OW 308
13114: NOT
13115: OR
13116: IFFALSE 13132
// ComEnterUnit ( i , fact1 ) ;
13118: LD_VAR 0 1
13122: PPUSH
13123: LD_EXP 40
13127: PPUSH
13128: CALL_OW 120
// end ;
13132: GO 13089
13134: POP
13135: POP
// enable ;
13136: ENABLE
// end ;
13137: PPOPN 1
13139: END
// every 0 0$5.0 do var i ;
13140: GO 13142
13142: DISABLE
13143: LD_INT 0
13145: PPUSH
// begin if dep1 then
13146: LD_EXP 41
13150: IFFALSE 13238
// if under_attack then
13152: LD_EXP 70
13156: IFFALSE 13229
// for i in eng do
13158: LD_ADDR_VAR 0 1
13162: PUSH
13163: LD_EXP 23
13167: PUSH
13168: FOR_IN
13169: IFFALSE 13225
// begin if IsIdle ( i ) or ( not IsInArea ( i , near_base ) and not IsInUnit ( i ) ) then
13171: LD_VAR 0 1
13175: PPUSH
13176: CALL_OW 316
13180: PUSH
13181: LD_VAR 0 1
13185: PPUSH
13186: LD_INT 13
13188: PPUSH
13189: CALL_OW 308
13193: NOT
13194: PUSH
13195: LD_VAR 0 1
13199: PPUSH
13200: CALL_OW 310
13204: NOT
13205: AND
13206: OR
13207: IFFALSE 13223
// ComEnterUnit ( i , dep1 ) ;
13209: LD_VAR 0 1
13213: PPUSH
13214: LD_EXP 41
13218: PPUSH
13219: CALL_OW 120
// end else
13223: GO 13168
13225: POP
13226: POP
13227: GO 13238
// ComExitBuilding ( dep1 ) ;
13229: LD_EXP 41
13233: PPUSH
13234: CALL_OW 122
// enable ;
13238: ENABLE
// end ;
13239: PPOPN 1
13241: END
// every 0 0$5.0 do var i ;
13242: GO 13244
13244: DISABLE
13245: LD_INT 0
13247: PPUSH
// begin if lab1 then
13248: LD_EXP 42
13252: IFFALSE 13296
// for i in sci do
13254: LD_ADDR_VAR 0 1
13258: PUSH
13259: LD_EXP 21
13263: PUSH
13264: FOR_IN
13265: IFFALSE 13294
// begin if IsIdle ( i ) then
13267: LD_VAR 0 1
13271: PPUSH
13272: CALL_OW 316
13276: IFFALSE 13292
// ComEnterUnit ( i , lab1 ) ;
13278: LD_VAR 0 1
13282: PPUSH
13283: LD_EXP 42
13287: PPUSH
13288: CALL_OW 120
// end ;
13292: GO 13264
13294: POP
13295: POP
// enable ;
13296: ENABLE
// end ;
13297: PPOPN 1
13299: END
// every 0 0$1 do var a ;
13300: GO 13302
13302: DISABLE
13303: LD_INT 0
13305: PPUSH
// begin enable ;
13306: ENABLE
// end ; end_of_file
13307: PPOPN 1
13309: END
// every 0 0$2 do var temp1 , people , cars ;
13310: GO 13312
13312: DISABLE
13313: LD_INT 0
13315: PPUSH
13316: PPUSH
13317: PPUSH
// begin vodni_utok := 6000 ;
13318: LD_ADDR_EXP 35
13322: PUSH
13323: LD_INT 6000
13325: ST_TO_ADDR
// normal1_utok := 6001 ;
13326: LD_ADDR_EXP 36
13330: PUSH
13331: LD_INT 6001
13333: ST_TO_ADDR
// normal2_utok := 6002 ;
13334: LD_ADDR_EXP 37
13338: PUSH
13339: LD_INT 6002
13341: ST_TO_ADDR
// normal3_utok := 6003 ;
13342: LD_ADDR_EXP 38
13346: PUSH
13347: LD_INT 6003
13349: ST_TO_ADDR
// normal4_utok := 6004 ;
13350: LD_ADDR_EXP 39
13354: PUSH
13355: LD_INT 6004
13357: ST_TO_ADDR
// apemans := FilterAllUnits ( [ [ f_nation , nation_nature ] ] ) ;
13358: LD_ADDR_EXP 7
13362: PUSH
13363: LD_INT 23
13365: PUSH
13366: LD_INT 0
13368: PUSH
13369: EMPTY
13370: LIST
13371: LIST
13372: PUSH
13373: EMPTY
13374: LIST
13375: PPUSH
13376: CALL_OW 69
13380: ST_TO_ADDR
// to_defence := false ;
13381: LD_ADDR_EXP 30
13385: PUSH
13386: LD_INT 0
13388: ST_TO_ADDR
// to_remote := false ;
13389: LD_ADDR_EXP 34
13393: PUSH
13394: LD_INT 0
13396: ST_TO_ADDR
// to_attack := false ;
13397: LD_ADDR_EXP 31
13401: PUSH
13402: LD_INT 0
13404: ST_TO_ADDR
// to_cargo := false ;
13405: LD_ADDR_EXP 33
13409: PUSH
13410: LD_INT 0
13412: ST_TO_ADDR
// to_scout := false ;
13413: LD_ADDR_EXP 32
13417: PUSH
13418: LD_INT 0
13420: ST_TO_ADDR
// temp1 := FilterAllUnits ( [ [ f_side , arabians ] ] ) ;
13421: LD_ADDR_VAR 0 1
13425: PUSH
13426: LD_INT 22
13428: PUSH
13429: LD_EXP 3
13433: PUSH
13434: EMPTY
13435: LIST
13436: LIST
13437: PUSH
13438: EMPTY
13439: LIST
13440: PPUSH
13441: CALL_OW 69
13445: ST_TO_ADDR
// ComRemember ( temp1 ) ;
13446: LD_VAR 0 1
13450: PPUSH
13451: CALL_OW 143
// people := UnitFilter ( temp1 , [ [ f_type , unit_human ] ] ) ;
13455: LD_ADDR_VAR 0 2
13459: PUSH
13460: LD_VAR 0 1
13464: PPUSH
13465: LD_INT 21
13467: PUSH
13468: LD_INT 1
13470: PUSH
13471: EMPTY
13472: LIST
13473: LIST
13474: PUSH
13475: EMPTY
13476: LIST
13477: PPUSH
13478: CALL_OW 72
13482: ST_TO_ADDR
// sol := UnitFilter ( people , [ [ f_class , class_soldier ] ] ) ;
13483: LD_ADDR_EXP 19
13487: PUSH
13488: LD_VAR 0 2
13492: PPUSH
13493: LD_INT 25
13495: PUSH
13496: LD_INT 1
13498: PUSH
13499: EMPTY
13500: LIST
13501: LIST
13502: PUSH
13503: EMPTY
13504: LIST
13505: PPUSH
13506: CALL_OW 72
13510: ST_TO_ADDR
// sci := UnitFilter ( people , [ [ f_class , class_scientistic ] ] ) ;
13511: LD_ADDR_EXP 21
13515: PUSH
13516: LD_VAR 0 2
13520: PPUSH
13521: LD_INT 25
13523: PUSH
13524: LD_INT 4
13526: PUSH
13527: EMPTY
13528: LIST
13529: LIST
13530: PUSH
13531: EMPTY
13532: LIST
13533: PPUSH
13534: CALL_OW 72
13538: ST_TO_ADDR
// mor := UnitFilter ( people , [ [ f_class , class_mortar ] ] ) ;
13539: LD_ADDR_EXP 20
13543: PUSH
13544: LD_VAR 0 2
13548: PPUSH
13549: LD_INT 25
13551: PUSH
13552: LD_INT 8
13554: PUSH
13555: EMPTY
13556: LIST
13557: LIST
13558: PUSH
13559: EMPTY
13560: LIST
13561: PPUSH
13562: CALL_OW 72
13566: ST_TO_ADDR
// mec := UnitFilter ( people , [ [ f_class , class_mechanic ] ] ) ;
13567: LD_ADDR_EXP 22
13571: PUSH
13572: LD_VAR 0 2
13576: PPUSH
13577: LD_INT 25
13579: PUSH
13580: LD_INT 3
13582: PUSH
13583: EMPTY
13584: LIST
13585: LIST
13586: PUSH
13587: EMPTY
13588: LIST
13589: PPUSH
13590: CALL_OW 72
13594: ST_TO_ADDR
// eng := UnitFilter ( people , [ [ f_class , class_engineer ] ] ) ;
13595: LD_ADDR_EXP 23
13599: PUSH
13600: LD_VAR 0 2
13604: PPUSH
13605: LD_INT 25
13607: PUSH
13608: LD_INT 2
13610: PUSH
13611: EMPTY
13612: LIST
13613: LIST
13614: PUSH
13615: EMPTY
13616: LIST
13617: PPUSH
13618: CALL_OW 72
13622: ST_TO_ADDR
// cars := UnitFilter ( temp1 , [ [ f_type , unit_vehicle ] ] ) ;
13623: LD_ADDR_VAR 0 3
13627: PUSH
13628: LD_VAR 0 1
13632: PPUSH
13633: LD_INT 21
13635: PUSH
13636: LD_INT 2
13638: PUSH
13639: EMPTY
13640: LIST
13641: LIST
13642: PUSH
13643: EMPTY
13644: LIST
13645: PPUSH
13646: CALL_OW 72
13650: ST_TO_ADDR
// cargo := [ ] ;
13651: LD_ADDR_EXP 25
13655: PUSH
13656: EMPTY
13657: ST_TO_ADDR
// scout := [ ] ;
13658: LD_ADDR_EXP 26
13662: PUSH
13663: EMPTY
13664: ST_TO_ADDR
// defence := [ Mastodon ] ;
13665: LD_ADDR_EXP 28
13669: PUSH
13670: LD_INT 1
13672: PUSH
13673: EMPTY
13674: LIST
13675: ST_TO_ADDR
// attack := [ ] ;
13676: LD_ADDR_EXP 27
13680: PUSH
13681: EMPTY
13682: ST_TO_ADDR
// fort := UnitFilter ( temp1 , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ] ) ;
13683: LD_ADDR_EXP 43
13687: PUSH
13688: LD_VAR 0 1
13692: PPUSH
13693: LD_INT 2
13695: PUSH
13696: LD_INT 30
13698: PUSH
13699: LD_INT 32
13701: PUSH
13702: EMPTY
13703: LIST
13704: LIST
13705: PUSH
13706: LD_INT 30
13708: PUSH
13709: LD_INT 31
13711: PUSH
13712: EMPTY
13713: LIST
13714: LIST
13715: PUSH
13716: EMPTY
13717: LIST
13718: LIST
13719: LIST
13720: PUSH
13721: EMPTY
13722: LIST
13723: PPUSH
13724: CALL_OW 72
13728: ST_TO_ADDR
// dep1 := UnitFilter ( temp1 , [ [ f_btype , b_depot ] ] ) [ 1 ] + 0 ;
13729: LD_ADDR_EXP 41
13733: PUSH
13734: LD_VAR 0 1
13738: PPUSH
13739: LD_INT 30
13741: PUSH
13742: LD_INT 0
13744: PUSH
13745: EMPTY
13746: LIST
13747: LIST
13748: PUSH
13749: EMPTY
13750: LIST
13751: PPUSH
13752: CALL_OW 72
13756: PUSH
13757: LD_INT 1
13759: ARRAY
13760: PUSH
13761: LD_INT 0
13763: PLUS
13764: ST_TO_ADDR
// end ;
13765: PPOPN 3
13767: END
// var zasek_cargo ; every 0 0$50 trigger cargo do var j , pojedou , new ;
13768: LD_EXP 25
13772: IFFALSE 14145
13774: GO 13776
13776: DISABLE
13777: LD_INT 0
13779: PPUSH
13780: PPUSH
13781: PPUSH
// begin uc_side := arabians ;
13782: LD_ADDR_OWVAR 20
13786: PUSH
13787: LD_EXP 3
13791: ST_TO_ADDR
// uc_nation := nation_arabian ;
13792: LD_ADDR_OWVAR 21
13796: PUSH
13797: LD_INT 2
13799: ST_TO_ADDR
// PrepareEngineer ( 0 , 2 ) ;
13800: LD_INT 0
13802: PPUSH
13803: LD_INT 2
13805: PPUSH
13806: CALL_OW 382
// SetFuel ( cargo , 100 ) ;
13810: LD_EXP 25
13814: PPUSH
13815: LD_INT 100
13817: PPUSH
13818: CALL_OW 240
// if not HasTask ( Cargo [ 1 ] ) and GetLives ( Cargo [ 1 ] ) >= 900 and crates >= 2 then
13822: LD_EXP 25
13826: PUSH
13827: LD_INT 1
13829: ARRAY
13830: PPUSH
13831: CALL_OW 314
13835: NOT
13836: PUSH
13837: LD_EXP 25
13841: PUSH
13842: LD_INT 1
13844: ARRAY
13845: PPUSH
13846: CALL_OW 256
13850: PUSH
13851: LD_INT 900
13853: GREATEREQUAL
13854: AND
13855: PUSH
13856: LD_EXP 86
13860: PUSH
13861: LD_INT 2
13863: GREATEREQUAL
13864: AND
13865: IFFALSE 14144
// begin new := [ ] ;
13867: LD_ADDR_VAR 0 3
13871: PUSH
13872: EMPTY
13873: ST_TO_ADDR
// pojedou := find_drivers ( cargo [ 1 ] , eng ^ sol ^ sci ^ mec , false ) ;
13874: LD_ADDR_VAR 0 2
13878: PUSH
13879: LD_EXP 25
13883: PUSH
13884: LD_INT 1
13886: ARRAY
13887: PPUSH
13888: LD_EXP 23
13892: PUSH
13893: LD_EXP 19
13897: ADD
13898: PUSH
13899: LD_EXP 21
13903: ADD
13904: PUSH
13905: LD_EXP 22
13909: ADD
13910: PPUSH
13911: LD_INT 0
13913: PPUSH
13914: CALL 24202 0 3
13918: ST_TO_ADDR
// wait_for_drivers ( pojedou , 0 0$25 ) ;
13919: LD_VAR 0 2
13923: PPUSH
13924: LD_INT 875
13926: PPUSH
13927: CALL 24534 0 2
// if IsDrivenBy ( cargo [ 1 ] ) then
13931: LD_EXP 25
13935: PUSH
13936: LD_INT 1
13938: ARRAY
13939: PPUSH
13940: CALL_OW 311
13944: IFFALSE 13956
// zasek_cargo := 1 else
13946: LD_ADDR_LOC 27
13950: PUSH
13951: LD_INT 1
13953: ST_TO_ADDR
13954: GO 13970
// zasek_cargo := zasek_cargo + 1 ;
13956: LD_ADDR_LOC 27
13960: PUSH
13961: LD_LOC 27
13965: PUSH
13966: LD_INT 1
13968: PLUS
13969: ST_TO_ADDR
// if zasek_cargo > 5 then
13970: LD_LOC 27
13974: PUSH
13975: LD_INT 5
13977: GREATER
13978: IFFALSE 13998
// PlaceHumanInUnit ( CreateHuman , cargo [ 1 ] ) ;
13980: CALL_OW 44
13984: PPUSH
13985: LD_EXP 25
13989: PUSH
13990: LD_INT 1
13992: ARRAY
13993: PPUSH
13994: CALL_OW 52
// for j := 1 to 2 do
13998: LD_ADDR_VAR 0 1
14002: PUSH
14003: DOUBLE
14004: LD_INT 1
14006: DEC
14007: ST_TO_ADDR
14008: LD_INT 2
14010: PUSH
14011: FOR_TO
14012: IFFALSE 14055
// begin AddComCollect ( pojedou , crates [ j ] [ 1 ] , crates [ j ] [ 2 ] ) ;
14014: LD_VAR 0 2
14018: PPUSH
14019: LD_EXP 86
14023: PUSH
14024: LD_VAR 0 1
14028: ARRAY
14029: PUSH
14030: LD_INT 1
14032: ARRAY
14033: PPUSH
14034: LD_EXP 86
14038: PUSH
14039: LD_VAR 0 1
14043: ARRAY
14044: PUSH
14045: LD_INT 2
14047: ARRAY
14048: PPUSH
14049: CALL_OW 177
// end ;
14053: GO 14011
14055: POP
14056: POP
// if crates >= 3 then
14057: LD_EXP 86
14061: PUSH
14062: LD_INT 3
14064: GREATEREQUAL
14065: IFFALSE 14114
// for j := 3 to crates do
14067: LD_ADDR_VAR 0 1
14071: PUSH
14072: DOUBLE
14073: LD_INT 3
14075: DEC
14076: ST_TO_ADDR
14077: LD_EXP 86
14081: PUSH
14082: FOR_TO
14083: IFFALSE 14112
// begin new := new ^ [ crates [ j ] ] ;
14085: LD_ADDR_VAR 0 3
14089: PUSH
14090: LD_VAR 0 3
14094: PUSH
14095: LD_EXP 86
14099: PUSH
14100: LD_VAR 0 1
14104: ARRAY
14105: PUSH
14106: EMPTY
14107: LIST
14108: ADD
14109: ST_TO_ADDR
// end ;
14110: GO 14082
14112: POP
14113: POP
// crates := new ;
14114: LD_ADDR_EXP 86
14118: PUSH
14119: LD_VAR 0 3
14123: ST_TO_ADDR
// if dep1 then
14124: LD_EXP 41
14128: IFFALSE 14144
// AddComMoveUnit ( pojedou , dep1 ) ;
14130: LD_VAR 0 2
14134: PPUSH
14135: LD_EXP 41
14139: PPUSH
14140: CALL_OW 172
// end ; enable ;
14144: ENABLE
// end ;
14145: PPOPN 3
14147: END
// every 0 0$30 do var a ;
14148: GO 14150
14150: DISABLE
14151: LD_INT 0
14153: PPUSH
// begin a := GetResourceType ( Getbase ( dep1 ) , mat_cans ) ;
14154: LD_ADDR_VAR 0 1
14158: PUSH
14159: LD_EXP 41
14163: PPUSH
14164: CALL_OW 274
14168: PPUSH
14169: LD_INT 1
14171: PPUSH
14172: CALL_OW 275
14176: ST_TO_ADDR
// if a < 100 then
14177: LD_VAR 0 1
14181: PUSH
14182: LD_INT 100
14184: LESS
14185: IFFALSE 14213
// SetResourceType ( Getbase ( dep1 ) , mat_cans , a + 100 ) ;
14187: LD_EXP 41
14191: PPUSH
14192: CALL_OW 274
14196: PPUSH
14197: LD_INT 1
14199: PPUSH
14200: LD_VAR 0 1
14204: PUSH
14205: LD_INT 100
14207: PLUS
14208: PPUSH
14209: CALL_OW 277
// a := GetResourceType ( Getbase ( dep1 ) , mat_oil ) ;
14213: LD_ADDR_VAR 0 1
14217: PUSH
14218: LD_EXP 41
14222: PPUSH
14223: CALL_OW 274
14227: PPUSH
14228: LD_INT 2
14230: PPUSH
14231: CALL_OW 275
14235: ST_TO_ADDR
// if a < 100 then
14236: LD_VAR 0 1
14240: PUSH
14241: LD_INT 100
14243: LESS
14244: IFFALSE 14272
// SetResourceType ( Getbase ( dep1 ) , mat_oil , a + 100 ) ;
14246: LD_EXP 41
14250: PPUSH
14251: CALL_OW 274
14255: PPUSH
14256: LD_INT 2
14258: PPUSH
14259: LD_VAR 0 1
14263: PUSH
14264: LD_INT 100
14266: PLUS
14267: PPUSH
14268: CALL_OW 277
// enable ;
14272: ENABLE
// end ;
14273: PPOPN 1
14275: END
// every 0 0$15 trigger IsOk ( fact1 ) and IsIdle ( fact1 ) and ( ( defence + attack ) < ( 5 + difficulty * 2 ) ) do var a , ec , cm , ac , podvozky , ovladani , def_pod , att_pod , tmec ;
14276: LD_EXP 40
14280: PPUSH
14281: CALL_OW 302
14285: PUSH
14286: LD_EXP 40
14290: PPUSH
14291: CALL_OW 316
14295: AND
14296: PUSH
14297: LD_EXP 28
14301: PUSH
14302: LD_EXP 27
14306: PLUS
14307: PUSH
14308: LD_INT 5
14310: PUSH
14311: LD_OWVAR 67
14315: PUSH
14316: LD_INT 2
14318: MUL
14319: PLUS
14320: LESS
14321: AND
14322: IFFALSE 15633
14324: GO 14326
14326: DISABLE
14327: LD_INT 0
14329: PPUSH
14330: PPUSH
14331: PPUSH
14332: PPUSH
14333: PPUSH
14334: PPUSH
14335: PPUSH
14336: PPUSH
14337: PPUSH
// begin ec := engine_combustion ;
14338: LD_ADDR_VAR 0 2
14342: PUSH
14343: LD_INT 1
14345: ST_TO_ADDR
// cm := control_manual ;
14346: LD_ADDR_VAR 0 3
14350: PUSH
14351: LD_INT 1
14353: ST_TO_ADDR
// podvozky := AvailableChassisList ( fact1 ) ;
14354: LD_ADDR_VAR 0 5
14358: PUSH
14359: LD_EXP 40
14363: PPUSH
14364: CALL_OW 475
14368: ST_TO_ADDR
// ovladani := AvailableControlList ( fact1 ) ;
14369: LD_ADDR_VAR 0 6
14373: PUSH
14374: LD_EXP 40
14378: PPUSH
14379: CALL_OW 477
14383: ST_TO_ADDR
// if control_remote in ovladani then
14384: LD_INT 2
14386: PUSH
14387: LD_VAR 0 6
14391: IN
14392: IFFALSE 14404
// ac := control_remote else
14394: LD_ADDR_VAR 0 4
14398: PUSH
14399: LD_INT 2
14401: ST_TO_ADDR
14402: GO 14414
// ac := cm ;
14404: LD_ADDR_VAR 0 4
14408: PUSH
14409: LD_VAR 0 3
14413: ST_TO_ADDR
// att_pod := ar_half_tracked ;
14414: LD_ADDR_VAR 0 8
14418: PUSH
14419: LD_INT 14
14421: ST_TO_ADDR
// case true of ar_half_tracked in podvozky :
14422: LD_INT 1
14424: PUSH
14425: LD_INT 14
14427: PUSH
14428: LD_VAR 0 5
14432: IN
14433: DOUBLE
14434: EQUAL
14435: IFTRUE 14439
14437: GO 14450
14439: POP
// def_pod := ar_half_tracked ; ar_medium_trike in podvozky :
14440: LD_ADDR_VAR 0 7
14444: PUSH
14445: LD_INT 14
14447: ST_TO_ADDR
14448: GO 14476
14450: LD_INT 13
14452: PUSH
14453: LD_VAR 0 5
14457: IN
14458: DOUBLE
14459: EQUAL
14460: IFTRUE 14464
14462: GO 14475
14464: POP
// def_pod := ar_medium_trike ; end ;
14465: LD_ADDR_VAR 0 7
14469: PUSH
14470: LD_INT 13
14472: ST_TO_ADDR
14473: GO 14476
14475: POP
// tmec := UnitFilter ( mec , [ [ f_outside ] ] ) ;
14476: LD_ADDR_VAR 0 9
14480: PUSH
14481: LD_EXP 22
14485: PPUSH
14486: LD_INT 56
14488: PUSH
14489: EMPTY
14490: LIST
14491: PUSH
14492: EMPTY
14493: LIST
14494: PPUSH
14495: CALL_OW 72
14499: ST_TO_ADDR
// while tmec do
14500: LD_VAR 0 9
14504: IFFALSE 14564
// begin ComExitVehicle ( tmec ) ;
14506: LD_VAR 0 9
14510: PPUSH
14511: CALL_OW 121
// AddComEnterUnit ( tmec , fact1 ) ;
14515: LD_VAR 0 9
14519: PPUSH
14520: LD_EXP 40
14524: PPUSH
14525: CALL_OW 180
// DU_wait ( tmec ) ;
14529: LD_VAR 0 9
14533: PPUSH
14534: CALL 22231 0 1
// tmec := UnitFilter ( mec , [ [ f_outside ] ] ) ;
14538: LD_ADDR_VAR 0 9
14542: PUSH
14543: LD_EXP 22
14547: PPUSH
14548: LD_INT 56
14550: PUSH
14551: EMPTY
14552: LIST
14553: PUSH
14554: EMPTY
14555: LIST
14556: PPUSH
14557: CALL_OW 72
14561: ST_TO_ADDR
// end ;
14562: GO 14500
// case true of cargo < 1 and CanBeConstructed ( fact1 , ar_medium_trike , ec , cm , ar_cargo_bay ) :
14564: LD_INT 1
14566: PUSH
14567: LD_EXP 25
14571: PUSH
14572: LD_INT 1
14574: LESS
14575: PUSH
14576: LD_EXP 40
14580: PPUSH
14581: LD_INT 13
14583: PPUSH
14584: LD_VAR 0 2
14588: PPUSH
14589: LD_VAR 0 3
14593: PPUSH
14594: LD_INT 32
14596: PPUSH
14597: CALL_OW 448
14601: AND
14602: DOUBLE
14603: EQUAL
14604: IFTRUE 14608
14606: GO 14646
14608: POP
// begin ComConstruct ( fact1 , def_pod , ec , cm , ar_cargo_bay ) ;
14609: LD_EXP 40
14613: PPUSH
14614: LD_VAR 0 7
14618: PPUSH
14619: LD_VAR 0 2
14623: PPUSH
14624: LD_VAR 0 3
14628: PPUSH
14629: LD_INT 32
14631: PPUSH
14632: CALL_OW 125
// to_cargo := true ;
14636: LD_ADDR_EXP 33
14640: PUSH
14641: LD_INT 1
14643: ST_TO_ADDR
// end ; defence >= 1 and defence < 3 and CanBeConstructed ( fact1 , def_pod , ec , cm , ar_gun ) :
14644: GO 15632
14646: LD_EXP 28
14650: PUSH
14651: LD_INT 1
14653: GREATEREQUAL
14654: PUSH
14655: LD_EXP 28
14659: PUSH
14660: LD_INT 3
14662: LESS
14663: AND
14664: PUSH
14665: LD_EXP 40
14669: PPUSH
14670: LD_VAR 0 7
14674: PPUSH
14675: LD_VAR 0 2
14679: PPUSH
14680: LD_VAR 0 3
14684: PPUSH
14685: LD_INT 27
14687: PPUSH
14688: CALL_OW 448
14692: AND
14693: DOUBLE
14694: EQUAL
14695: IFTRUE 14699
14697: GO 14737
14699: POP
// begin ComConstruct ( fact1 , def_pod , ec , cm , ar_gun ) ;
14700: LD_EXP 40
14704: PPUSH
14705: LD_VAR 0 7
14709: PPUSH
14710: LD_VAR 0 2
14714: PPUSH
14715: LD_VAR 0 3
14719: PPUSH
14720: LD_INT 27
14722: PPUSH
14723: CALL_OW 125
// to_defence := true ;
14727: LD_ADDR_EXP 30
14731: PUSH
14732: LD_INT 1
14734: ST_TO_ADDR
// end ; defence >= 2 and defence < 3 and CanBeConstructed ( fact1 , def_pod , ec , cm , ar_gatling_gun ) :
14735: GO 15632
14737: LD_EXP 28
14741: PUSH
14742: LD_INT 2
14744: GREATEREQUAL
14745: PUSH
14746: LD_EXP 28
14750: PUSH
14751: LD_INT 3
14753: LESS
14754: AND
14755: PUSH
14756: LD_EXP 40
14760: PPUSH
14761: LD_VAR 0 7
14765: PPUSH
14766: LD_VAR 0 2
14770: PPUSH
14771: LD_VAR 0 3
14775: PPUSH
14776: LD_INT 25
14778: PPUSH
14779: CALL_OW 448
14783: AND
14784: DOUBLE
14785: EQUAL
14786: IFTRUE 14790
14788: GO 14828
14790: POP
// begin ComConstruct ( fact1 , def_pod , ec , cm , ar_gatling_gun ) ;
14791: LD_EXP 40
14795: PPUSH
14796: LD_VAR 0 7
14800: PPUSH
14801: LD_VAR 0 2
14805: PPUSH
14806: LD_VAR 0 3
14810: PPUSH
14811: LD_INT 25
14813: PPUSH
14814: CALL_OW 125
// to_defence := true ;
14818: LD_ADDR_EXP 30
14822: PUSH
14823: LD_INT 1
14825: ST_TO_ADDR
// end ; defence < 2 and CanBeConstructed ( fact1 , def_pod , ec , cm , ar_flame_thrower ) :
14826: GO 15632
14828: LD_EXP 28
14832: PUSH
14833: LD_INT 2
14835: LESS
14836: PUSH
14837: LD_EXP 40
14841: PPUSH
14842: LD_VAR 0 7
14846: PPUSH
14847: LD_VAR 0 2
14851: PPUSH
14852: LD_VAR 0 3
14856: PPUSH
14857: LD_INT 26
14859: PPUSH
14860: CALL_OW 448
14864: AND
14865: DOUBLE
14866: EQUAL
14867: IFTRUE 14871
14869: GO 14909
14871: POP
// begin ComConstruct ( fact1 , def_pod , ec , cm , ar_flame_thrower ) ;
14872: LD_EXP 40
14876: PPUSH
14877: LD_VAR 0 7
14881: PPUSH
14882: LD_VAR 0 2
14886: PPUSH
14887: LD_VAR 0 3
14891: PPUSH
14892: LD_INT 26
14894: PPUSH
14895: CALL_OW 125
// to_defence := true ;
14899: LD_ADDR_EXP 30
14903: PUSH
14904: LD_INT 1
14906: ST_TO_ADDR
// end ; remote < 1 and CanBeConstructed ( fact1 , ar_medium_trike , ec , cm , ar_control_tower ) :
14907: GO 15632
14909: LD_EXP 29
14913: PUSH
14914: LD_INT 1
14916: LESS
14917: PUSH
14918: LD_EXP 40
14922: PPUSH
14923: LD_INT 13
14925: PPUSH
14926: LD_VAR 0 2
14930: PPUSH
14931: LD_VAR 0 3
14935: PPUSH
14936: LD_INT 31
14938: PPUSH
14939: CALL_OW 448
14943: AND
14944: DOUBLE
14945: EQUAL
14946: IFTRUE 14950
14948: GO 14986
14950: POP
// begin ComConstruct ( fact1 , ar_medium_trike , ec , cm , ar_control_tower ) ;
14951: LD_EXP 40
14955: PPUSH
14956: LD_INT 13
14958: PPUSH
14959: LD_VAR 0 2
14963: PPUSH
14964: LD_VAR 0 3
14968: PPUSH
14969: LD_INT 31
14971: PPUSH
14972: CALL_OW 125
// to_remote := true ;
14976: LD_ADDR_EXP 34
14980: PUSH
14981: LD_INT 1
14983: ST_TO_ADDR
// end ; tick < 20 20$0 and attack < 3 and CanBeConstructed ( fact1 , ar_hovercraft , ec , ac , ar_light_gun ) :
14984: GO 15632
14986: LD_OWVAR 1
14990: PUSH
14991: LD_INT 42000
14993: LESS
14994: PUSH
14995: LD_EXP 27
14999: PUSH
15000: LD_INT 3
15002: LESS
15003: AND
15004: PUSH
15005: LD_EXP 40
15009: PPUSH
15010: LD_INT 11
15012: PPUSH
15013: LD_VAR 0 2
15017: PPUSH
15018: LD_VAR 0 4
15022: PPUSH
15023: LD_INT 23
15025: PPUSH
15026: CALL_OW 448
15030: AND
15031: DOUBLE
15032: EQUAL
15033: IFTRUE 15037
15035: GO 15073
15037: POP
// begin ComConstruct ( fact1 , ar_hovercraft , ec , ac , ar_light_gun ) ;
15038: LD_EXP 40
15042: PPUSH
15043: LD_INT 11
15045: PPUSH
15046: LD_VAR 0 2
15050: PPUSH
15051: LD_VAR 0 4
15055: PPUSH
15056: LD_INT 23
15058: PPUSH
15059: CALL_OW 125
// to_attack := true ;
15063: LD_ADDR_EXP 31
15067: PUSH
15068: LD_INT 1
15070: ST_TO_ADDR
// end ; tick < 20 20$0 and attack < 3 and CanBeConstructed ( fact1 , att_pod , ec , ac , ar_gatling_gun ) :
15071: GO 15632
15073: LD_OWVAR 1
15077: PUSH
15078: LD_INT 42000
15080: LESS
15081: PUSH
15082: LD_EXP 27
15086: PUSH
15087: LD_INT 3
15089: LESS
15090: AND
15091: PUSH
15092: LD_EXP 40
15096: PPUSH
15097: LD_VAR 0 8
15101: PPUSH
15102: LD_VAR 0 2
15106: PPUSH
15107: LD_VAR 0 4
15111: PPUSH
15112: LD_INT 25
15114: PPUSH
15115: CALL_OW 448
15119: AND
15120: DOUBLE
15121: EQUAL
15122: IFTRUE 15126
15124: GO 15164
15126: POP
// begin ComConstruct ( fact1 , att_pod , ec , ac , ar_gatling_gun ) ;
15127: LD_EXP 40
15131: PPUSH
15132: LD_VAR 0 8
15136: PPUSH
15137: LD_VAR 0 2
15141: PPUSH
15142: LD_VAR 0 4
15146: PPUSH
15147: LD_INT 25
15149: PPUSH
15150: CALL_OW 125
// to_attack := true ;
15154: LD_ADDR_EXP 31
15158: PUSH
15159: LD_INT 1
15161: ST_TO_ADDR
// end ; tick < 10 10$0 and attack < 3 and CanBeConstructed ( fact1 , ar_hovercraft , ec , ac , ar_double_machine_gun ) :
15162: GO 15632
15164: LD_OWVAR 1
15168: PUSH
15169: LD_INT 21000
15171: LESS
15172: PUSH
15173: LD_EXP 27
15177: PUSH
15178: LD_INT 3
15180: LESS
15181: AND
15182: PUSH
15183: LD_EXP 40
15187: PPUSH
15188: LD_INT 11
15190: PPUSH
15191: LD_VAR 0 2
15195: PPUSH
15196: LD_VAR 0 4
15200: PPUSH
15201: LD_INT 24
15203: PPUSH
15204: CALL_OW 448
15208: AND
15209: DOUBLE
15210: EQUAL
15211: IFTRUE 15215
15213: GO 15251
15215: POP
// begin ComConstruct ( fact1 , ar_hovercraft , ec , ac , ar_double_machine_gun ) ;
15216: LD_EXP 40
15220: PPUSH
15221: LD_INT 11
15223: PPUSH
15224: LD_VAR 0 2
15228: PPUSH
15229: LD_VAR 0 4
15233: PPUSH
15234: LD_INT 24
15236: PPUSH
15237: CALL_OW 125
// to_attack := true ;
15241: LD_ADDR_EXP 31
15245: PUSH
15246: LD_INT 1
15248: ST_TO_ADDR
// end ; tick > 20 20$0 and tick < 40 40$0 and attack < 2 and CanBeConstructed ( fact1 , att_pod , ec , ac , ar_gun ) :
15249: GO 15632
15251: LD_OWVAR 1
15255: PUSH
15256: LD_INT 42000
15258: GREATER
15259: PUSH
15260: LD_OWVAR 1
15264: PUSH
15265: LD_INT 84000
15267: LESS
15268: AND
15269: PUSH
15270: LD_EXP 27
15274: PUSH
15275: LD_INT 2
15277: LESS
15278: AND
15279: PUSH
15280: LD_EXP 40
15284: PPUSH
15285: LD_VAR 0 8
15289: PPUSH
15290: LD_VAR 0 2
15294: PPUSH
15295: LD_VAR 0 4
15299: PPUSH
15300: LD_INT 27
15302: PPUSH
15303: CALL_OW 448
15307: AND
15308: DOUBLE
15309: EQUAL
15310: IFTRUE 15314
15312: GO 15352
15314: POP
// begin ComConstruct ( fact1 , att_pod , ec , ac , ar_gun ) ;
15315: LD_EXP 40
15319: PPUSH
15320: LD_VAR 0 8
15324: PPUSH
15325: LD_VAR 0 2
15329: PPUSH
15330: LD_VAR 0 4
15334: PPUSH
15335: LD_INT 27
15337: PPUSH
15338: CALL_OW 125
// to_attack := true ;
15342: LD_ADDR_EXP 31
15346: PUSH
15347: LD_INT 1
15349: ST_TO_ADDR
// end ; tick > 20 20$0 and tick < 40 40$0 and attack < 3 and CanBeConstructed ( fact1 , att_pod , ec , ac , ar_gatling_gun ) :
15350: GO 15632
15352: LD_OWVAR 1
15356: PUSH
15357: LD_INT 42000
15359: GREATER
15360: PUSH
15361: LD_OWVAR 1
15365: PUSH
15366: LD_INT 84000
15368: LESS
15369: AND
15370: PUSH
15371: LD_EXP 27
15375: PUSH
15376: LD_INT 3
15378: LESS
15379: AND
15380: PUSH
15381: LD_EXP 40
15385: PPUSH
15386: LD_VAR 0 8
15390: PPUSH
15391: LD_VAR 0 2
15395: PPUSH
15396: LD_VAR 0 4
15400: PPUSH
15401: LD_INT 25
15403: PPUSH
15404: CALL_OW 448
15408: AND
15409: DOUBLE
15410: EQUAL
15411: IFTRUE 15415
15413: GO 15453
15415: POP
// begin ComConstruct ( fact1 , att_pod , ec , ac , ar_gatling_gun ) ;
15416: LD_EXP 40
15420: PPUSH
15421: LD_VAR 0 8
15425: PPUSH
15426: LD_VAR 0 2
15430: PPUSH
15431: LD_VAR 0 4
15435: PPUSH
15436: LD_INT 25
15438: PPUSH
15439: CALL_OW 125
// to_attack := true ;
15443: LD_ADDR_EXP 31
15447: PUSH
15448: LD_INT 1
15450: ST_TO_ADDR
// end ; tick > 40 40$0 and attack < 2 and CanBeConstructed ( fact1 , ar_hovercraft , ec , ac , ar_light_gun ) :
15451: GO 15632
15453: LD_OWVAR 1
15457: PUSH
15458: LD_INT 84000
15460: GREATER
15461: PUSH
15462: LD_EXP 27
15466: PUSH
15467: LD_INT 2
15469: LESS
15470: AND
15471: PUSH
15472: LD_EXP 40
15476: PPUSH
15477: LD_INT 11
15479: PPUSH
15480: LD_VAR 0 2
15484: PPUSH
15485: LD_VAR 0 4
15489: PPUSH
15490: LD_INT 23
15492: PPUSH
15493: CALL_OW 448
15497: AND
15498: DOUBLE
15499: EQUAL
15500: IFTRUE 15504
15502: GO 15540
15504: POP
// begin ComConstruct ( fact1 , ar_hovercraft , ec , ac , ar_light_gun ) ;
15505: LD_EXP 40
15509: PPUSH
15510: LD_INT 11
15512: PPUSH
15513: LD_VAR 0 2
15517: PPUSH
15518: LD_VAR 0 4
15522: PPUSH
15523: LD_INT 23
15525: PPUSH
15526: CALL_OW 125
// to_attack := true ;
15530: LD_ADDR_EXP 31
15534: PUSH
15535: LD_INT 1
15537: ST_TO_ADDR
// end ; tick > 40 40$0 and attack < 4 and CanBeConstructed ( fact1 , att_pod , ec , ac , ar_gun ) :
15538: GO 15632
15540: LD_OWVAR 1
15544: PUSH
15545: LD_INT 84000
15547: GREATER
15548: PUSH
15549: LD_EXP 27
15553: PUSH
15554: LD_INT 4
15556: LESS
15557: AND
15558: PUSH
15559: LD_EXP 40
15563: PPUSH
15564: LD_VAR 0 8
15568: PPUSH
15569: LD_VAR 0 2
15573: PPUSH
15574: LD_VAR 0 4
15578: PPUSH
15579: LD_INT 27
15581: PPUSH
15582: CALL_OW 448
15586: AND
15587: DOUBLE
15588: EQUAL
15589: IFTRUE 15593
15591: GO 15631
15593: POP
// begin ComConstruct ( fact1 , att_pod , ec , ac , ar_gun ) ;
15594: LD_EXP 40
15598: PPUSH
15599: LD_VAR 0 8
15603: PPUSH
15604: LD_VAR 0 2
15608: PPUSH
15609: LD_VAR 0 4
15613: PPUSH
15614: LD_INT 27
15616: PPUSH
15617: CALL_OW 125
// to_attack := true ;
15621: LD_ADDR_EXP 31
15625: PUSH
15626: LD_INT 1
15628: ST_TO_ADDR
// end ; end ;
15629: GO 15632
15631: POP
// enable ;
15632: ENABLE
// end ;
15633: PPOPN 9
15635: END
// export hover , zbytek ; every 0 0$10 trigger ( ( attack diff brk_cars ) >= 2 ) do var pouzit ;
15636: LD_EXP 27
15640: PUSH
15641: LD_EXP 75
15645: DIFF
15646: PUSH
15647: LD_INT 2
15649: GREATEREQUAL
15650: IFFALSE 15899
15652: GO 15654
15654: DISABLE
15655: LD_INT 0
15657: PPUSH
// begin SetAttitude ( you , arabians , att_enemy , true ) ;
15658: LD_EXP 1
15662: PPUSH
15663: LD_EXP 3
15667: PPUSH
15668: LD_INT 2
15670: PPUSH
15671: LD_INT 1
15673: PPUSH
15674: CALL_OW 80
// first_attack := true ;
15678: LD_ADDR_EXP 18
15682: PUSH
15683: LD_INT 1
15685: ST_TO_ADDR
// pouzit := UnitFilter ( attack diff brk_cars , [ f_not , [ f_hastask ] ] ) ;
15686: LD_ADDR_VAR 0 1
15690: PUSH
15691: LD_EXP 27
15695: PUSH
15696: LD_EXP 75
15700: DIFF
15701: PPUSH
15702: LD_INT 3
15704: PUSH
15705: LD_INT 60
15707: PUSH
15708: EMPTY
15709: LIST
15710: PUSH
15711: EMPTY
15712: LIST
15713: LIST
15714: PPUSH
15715: CALL_OW 72
15719: ST_TO_ADDR
// hover := UnitFilter ( pouzit , [ [ f_chassis , ar_hovercraft ] ] ) ;
15720: LD_ADDR_EXP 71
15724: PUSH
15725: LD_VAR 0 1
15729: PPUSH
15730: LD_INT 31
15732: PUSH
15733: LD_INT 11
15735: PUSH
15736: EMPTY
15737: LIST
15738: LIST
15739: PUSH
15740: EMPTY
15741: LIST
15742: PPUSH
15743: CALL_OW 72
15747: ST_TO_ADDR
// zbytek := pouzit diff hover ;
15748: LD_ADDR_EXP 72
15752: PUSH
15753: LD_VAR 0 1
15757: PUSH
15758: LD_EXP 71
15762: DIFF
15763: ST_TO_ADDR
// if wait_while then
15764: LD_EXP 12
15768: IFFALSE 15785
// begin wait ( 3 3$0 ) ;
15770: LD_INT 6300
15772: PPUSH
15773: CALL_OW 67
// wait_while := false ;
15777: LD_ADDR_EXP 12
15781: PUSH
15782: LD_INT 0
15784: ST_TO_ADDR
// end ; if hover then
15785: LD_EXP 71
15789: IFFALSE 15800
// RaiseSailEvent ( vodni_utok ) ;
15791: LD_EXP 35
15795: PPUSH
15796: CALL_OW 427
// if zbytek then
15800: LD_EXP 72
15804: IFFALSE 15898
// case Rand ( 1 , 2 ) of 1 :
15806: LD_INT 1
15808: PPUSH
15809: LD_INT 2
15811: PPUSH
15812: CALL_OW 12
15816: PUSH
15817: LD_INT 1
15819: DOUBLE
15820: EQUAL
15821: IFTRUE 15825
15823: GO 15837
15825: POP
// RaiseSailEvent ( normal1_utok ) ; 2 :
15826: LD_EXP 36
15830: PPUSH
15831: CALL_OW 427
15835: GO 15898
15837: LD_INT 2
15839: DOUBLE
15840: EQUAL
15841: IFTRUE 15845
15843: GO 15857
15845: POP
// RaiseSailEvent ( normal2_utok ) ; 1 :
15846: LD_EXP 37
15850: PPUSH
15851: CALL_OW 427
15855: GO 15898
15857: LD_INT 1
15859: DOUBLE
15860: EQUAL
15861: IFTRUE 15865
15863: GO 15877
15865: POP
// RaiseSailEvent ( normal3_utok ) ; 2 :
15866: LD_EXP 38
15870: PPUSH
15871: CALL_OW 427
15875: GO 15898
15877: LD_INT 2
15879: DOUBLE
15880: EQUAL
15881: IFTRUE 15885
15883: GO 15897
15885: POP
// RaiseSailEvent ( normal4_utok ) ; end ;
15886: LD_EXP 39
15890: PPUSH
15891: CALL_OW 427
15895: GO 15898
15897: POP
// enable ;
15898: ENABLE
// end ;
15899: PPOPN 1
15901: END
// every 0 0$3 trigger remote do var i ;
15902: LD_EXP 29
15906: IFFALSE 16010
15908: GO 15910
15910: DISABLE
15911: LD_INT 0
15913: PPUSH
// begin if mec then
15914: LD_EXP 22
15918: IFFALSE 16009
// for i in remote do
15920: LD_ADDR_VAR 0 1
15924: PUSH
15925: LD_EXP 29
15929: PUSH
15930: FOR_IN
15931: IFFALSE 16007
// if not UnitsInside ( i ) then
15933: LD_VAR 0 1
15937: PPUSH
15938: CALL_OW 313
15942: NOT
15943: IFFALSE 16005
// begin if not rmec then
15945: LD_EXP 24
15949: NOT
15950: IFFALSE 15966
// rmec := mec [ 1 ] ;
15952: LD_ADDR_EXP 24
15956: PUSH
15957: LD_EXP 22
15961: PUSH
15962: LD_INT 1
15964: ARRAY
15965: ST_TO_ADDR
// ComExitVehicle ( rmec ) ;
15966: LD_EXP 24
15970: PPUSH
15971: CALL_OW 121
// AddComEnterUnit ( rmec , i ) ;
15975: LD_EXP 24
15979: PPUSH
15980: LD_VAR 0 1
15984: PPUSH
15985: CALL_OW 180
// mec := mec diff rmec ;
15989: LD_ADDR_EXP 22
15993: PUSH
15994: LD_EXP 22
15998: PUSH
15999: LD_EXP 24
16003: DIFF
16004: ST_TO_ADDR
// end ;
16005: GO 15930
16007: POP
16008: POP
// enable ;
16009: ENABLE
// end ;
16010: PPOPN 1
16012: END
// every 0 0$3 trigger not remote do
16013: LD_EXP 29
16017: NOT
16018: IFFALSE 16040
16020: GO 16022
16022: DISABLE
// begin mec := mec union rmec ;
16023: LD_ADDR_EXP 22
16027: PUSH
16028: LD_EXP 22
16032: PUSH
16033: LD_EXP 24
16037: UNION
16038: ST_TO_ADDR
// enable ;
16039: ENABLE
// end ;
16040: END
// every 0 0$3 trigger UnitFilter ( attack , [ f_not , [ f_linked ] ] ) do var i ;
16041: LD_EXP 27
16045: PPUSH
16046: LD_INT 3
16048: PUSH
16049: LD_INT 61
16051: PUSH
16052: EMPTY
16053: LIST
16054: PUSH
16055: EMPTY
16056: LIST
16057: LIST
16058: PPUSH
16059: CALL_OW 72
16063: IFFALSE 16104
16065: GO 16067
16067: DISABLE
16068: LD_INT 0
16070: PPUSH
// begin ComLinkTo ( UnitFilter ( attack , [ f_not , [ f_linked ] ] ) , rmec ) ;
16071: LD_EXP 27
16075: PPUSH
16076: LD_INT 3
16078: PUSH
16079: LD_INT 61
16081: PUSH
16082: EMPTY
16083: LIST
16084: PUSH
16085: EMPTY
16086: LIST
16087: LIST
16088: PPUSH
16089: CALL_OW 72
16093: PPUSH
16094: LD_EXP 24
16098: PPUSH
16099: CALL_OW 135
// enable ;
16103: ENABLE
// end ;
16104: PPOPN 1
16106: END
// export function f_vodni_utok ; var path , i ; begin
16107: LD_INT 0
16109: PPUSH
16110: PPUSH
16111: PPUSH
// path := [ [ 177 , 126 ] , [ 149 , 114 ] , [ 117 , 87 ] , [ 107 , 99 ] , [ 81 , 98 ] , [ 60 , 86 ] , [ 49 , 72 ] , [ 37 , 43 ] , [ 54 , 29 ] , [ 62 , 27 ] , [ 54 , 29 ] , [ 37 , 43 ] , [ 49 , 72 ] , [ 60 , 86 ] , [ 81 , 98 ] , [ 107 , 99 ] , [ 117 , 87 ] , [ 149 , 114 ] , [ 177 , 126 ] ] ;
16112: LD_ADDR_VAR 0 2
16116: PUSH
16117: LD_INT 177
16119: PUSH
16120: LD_INT 126
16122: PUSH
16123: EMPTY
16124: LIST
16125: LIST
16126: PUSH
16127: LD_INT 149
16129: PUSH
16130: LD_INT 114
16132: PUSH
16133: EMPTY
16134: LIST
16135: LIST
16136: PUSH
16137: LD_INT 117
16139: PUSH
16140: LD_INT 87
16142: PUSH
16143: EMPTY
16144: LIST
16145: LIST
16146: PUSH
16147: LD_INT 107
16149: PUSH
16150: LD_INT 99
16152: PUSH
16153: EMPTY
16154: LIST
16155: LIST
16156: PUSH
16157: LD_INT 81
16159: PUSH
16160: LD_INT 98
16162: PUSH
16163: EMPTY
16164: LIST
16165: LIST
16166: PUSH
16167: LD_INT 60
16169: PUSH
16170: LD_INT 86
16172: PUSH
16173: EMPTY
16174: LIST
16175: LIST
16176: PUSH
16177: LD_INT 49
16179: PUSH
16180: LD_INT 72
16182: PUSH
16183: EMPTY
16184: LIST
16185: LIST
16186: PUSH
16187: LD_INT 37
16189: PUSH
16190: LD_INT 43
16192: PUSH
16193: EMPTY
16194: LIST
16195: LIST
16196: PUSH
16197: LD_INT 54
16199: PUSH
16200: LD_INT 29
16202: PUSH
16203: EMPTY
16204: LIST
16205: LIST
16206: PUSH
16207: LD_INT 62
16209: PUSH
16210: LD_INT 27
16212: PUSH
16213: EMPTY
16214: LIST
16215: LIST
16216: PUSH
16217: LD_INT 54
16219: PUSH
16220: LD_INT 29
16222: PUSH
16223: EMPTY
16224: LIST
16225: LIST
16226: PUSH
16227: LD_INT 37
16229: PUSH
16230: LD_INT 43
16232: PUSH
16233: EMPTY
16234: LIST
16235: LIST
16236: PUSH
16237: LD_INT 49
16239: PUSH
16240: LD_INT 72
16242: PUSH
16243: EMPTY
16244: LIST
16245: LIST
16246: PUSH
16247: LD_INT 60
16249: PUSH
16250: LD_INT 86
16252: PUSH
16253: EMPTY
16254: LIST
16255: LIST
16256: PUSH
16257: LD_INT 81
16259: PUSH
16260: LD_INT 98
16262: PUSH
16263: EMPTY
16264: LIST
16265: LIST
16266: PUSH
16267: LD_INT 107
16269: PUSH
16270: LD_INT 99
16272: PUSH
16273: EMPTY
16274: LIST
16275: LIST
16276: PUSH
16277: LD_INT 117
16279: PUSH
16280: LD_INT 87
16282: PUSH
16283: EMPTY
16284: LIST
16285: LIST
16286: PUSH
16287: LD_INT 149
16289: PUSH
16290: LD_INT 114
16292: PUSH
16293: EMPTY
16294: LIST
16295: LIST
16296: PUSH
16297: LD_INT 177
16299: PUSH
16300: LD_INT 126
16302: PUSH
16303: EMPTY
16304: LIST
16305: LIST
16306: PUSH
16307: EMPTY
16308: LIST
16309: LIST
16310: LIST
16311: LIST
16312: LIST
16313: LIST
16314: LIST
16315: LIST
16316: LIST
16317: LIST
16318: LIST
16319: LIST
16320: LIST
16321: LIST
16322: LIST
16323: LIST
16324: LIST
16325: LIST
16326: LIST
16327: ST_TO_ADDR
// find_and_wait ( UnitFilter ( hover , [ [ f_control , control_manual ] ] ) , sol , false , false , 0 0$50 ) ;
16328: LD_EXP 71
16332: PPUSH
16333: LD_INT 33
16335: PUSH
16336: LD_INT 1
16338: PUSH
16339: EMPTY
16340: LIST
16341: LIST
16342: PUSH
16343: EMPTY
16344: LIST
16345: PPUSH
16346: CALL_OW 72
16350: PPUSH
16351: LD_EXP 19
16355: PPUSH
16356: LD_INT 0
16358: PPUSH
16359: LD_INT 0
16361: PPUSH
16362: LD_INT 1750
16364: PPUSH
16365: CALL 24634 0 5
// find_and_wait_r ( UnitFilter ( hover , [ [ f_control , control_remote ] ] ) , remote , 0 0$50 ) ;
16369: LD_EXP 71
16373: PPUSH
16374: LD_INT 33
16376: PUSH
16377: LD_INT 2
16379: PUSH
16380: EMPTY
16381: LIST
16382: LIST
16383: PUSH
16384: EMPTY
16385: LIST
16386: PPUSH
16387: CALL_OW 72
16391: PPUSH
16392: LD_EXP 29
16396: PPUSH
16397: LD_INT 1750
16399: PPUSH
16400: CALL 25334 0 3
// for i in path do
16404: LD_ADDR_VAR 0 3
16408: PUSH
16409: LD_VAR 0 2
16413: PUSH
16414: FOR_IN
16415: IFFALSE 16490
// AddComAgressiveMove ( hover , Rand ( i [ 1 ] - 1 , i [ 1 ] + 1 ) , Rand ( i [ 2 ] - 1 , i [ 2 ] + 1 ) ) ;
16417: LD_EXP 71
16421: PPUSH
16422: LD_VAR 0 3
16426: PUSH
16427: LD_INT 1
16429: ARRAY
16430: PUSH
16431: LD_INT 1
16433: MINUS
16434: PPUSH
16435: LD_VAR 0 3
16439: PUSH
16440: LD_INT 1
16442: ARRAY
16443: PUSH
16444: LD_INT 1
16446: PLUS
16447: PPUSH
16448: CALL_OW 12
16452: PPUSH
16453: LD_VAR 0 3
16457: PUSH
16458: LD_INT 2
16460: ARRAY
16461: PUSH
16462: LD_INT 1
16464: MINUS
16465: PPUSH
16466: LD_VAR 0 3
16470: PUSH
16471: LD_INT 2
16473: ARRAY
16474: PUSH
16475: LD_INT 1
16477: PLUS
16478: PPUSH
16479: CALL_OW 12
16483: PPUSH
16484: CALL_OW 174
16488: GO 16414
16490: POP
16491: POP
// end ;
16492: LD_VAR 0 1
16496: RET
// export function f_normal1_utok ; var path , i ; begin
16497: LD_INT 0
16499: PPUSH
16500: PPUSH
16501: PPUSH
// path := [ [ 102 , 68 ] , [ 96 , 67 ] , [ 73 , 55 ] , [ 69 , 77 ] , [ 59 , 54 ] ] ;
16502: LD_ADDR_VAR 0 2
16506: PUSH
16507: LD_INT 102
16509: PUSH
16510: LD_INT 68
16512: PUSH
16513: EMPTY
16514: LIST
16515: LIST
16516: PUSH
16517: LD_INT 96
16519: PUSH
16520: LD_INT 67
16522: PUSH
16523: EMPTY
16524: LIST
16525: LIST
16526: PUSH
16527: LD_INT 73
16529: PUSH
16530: LD_INT 55
16532: PUSH
16533: EMPTY
16534: LIST
16535: LIST
16536: PUSH
16537: LD_INT 69
16539: PUSH
16540: LD_INT 77
16542: PUSH
16543: EMPTY
16544: LIST
16545: LIST
16546: PUSH
16547: LD_INT 59
16549: PUSH
16550: LD_INT 54
16552: PUSH
16553: EMPTY
16554: LIST
16555: LIST
16556: PUSH
16557: EMPTY
16558: LIST
16559: LIST
16560: LIST
16561: LIST
16562: LIST
16563: ST_TO_ADDR
// find_and_wait ( UnitFilter ( zbytek , [ [ f_control , control_manual ] ] ) , sol , false , false , 0 0$50 ) ;
16564: LD_EXP 72
16568: PPUSH
16569: LD_INT 33
16571: PUSH
16572: LD_INT 1
16574: PUSH
16575: EMPTY
16576: LIST
16577: LIST
16578: PUSH
16579: EMPTY
16580: LIST
16581: PPUSH
16582: CALL_OW 72
16586: PPUSH
16587: LD_EXP 19
16591: PPUSH
16592: LD_INT 0
16594: PPUSH
16595: LD_INT 0
16597: PPUSH
16598: LD_INT 1750
16600: PPUSH
16601: CALL 24634 0 5
// find_and_wait_r ( UnitFilter ( zbytek , [ [ f_control , control_remote ] ] ) , remote , 0 0$50 ) ;
16605: LD_EXP 72
16609: PPUSH
16610: LD_INT 33
16612: PUSH
16613: LD_INT 2
16615: PUSH
16616: EMPTY
16617: LIST
16618: LIST
16619: PUSH
16620: EMPTY
16621: LIST
16622: PPUSH
16623: CALL_OW 72
16627: PPUSH
16628: LD_EXP 29
16632: PPUSH
16633: LD_INT 1750
16635: PPUSH
16636: CALL 25334 0 3
// for i in path do
16640: LD_ADDR_VAR 0 3
16644: PUSH
16645: LD_VAR 0 2
16649: PUSH
16650: FOR_IN
16651: IFFALSE 16726
// AddComAgressiveMove ( zbytek , Rand ( i [ 1 ] - 4 , i [ 1 ] + 4 ) , Rand ( i [ 2 ] - 4 , i [ 2 ] + 4 ) ) ;
16653: LD_EXP 72
16657: PPUSH
16658: LD_VAR 0 3
16662: PUSH
16663: LD_INT 1
16665: ARRAY
16666: PUSH
16667: LD_INT 4
16669: MINUS
16670: PPUSH
16671: LD_VAR 0 3
16675: PUSH
16676: LD_INT 1
16678: ARRAY
16679: PUSH
16680: LD_INT 4
16682: PLUS
16683: PPUSH
16684: CALL_OW 12
16688: PPUSH
16689: LD_VAR 0 3
16693: PUSH
16694: LD_INT 2
16696: ARRAY
16697: PUSH
16698: LD_INT 4
16700: MINUS
16701: PPUSH
16702: LD_VAR 0 3
16706: PUSH
16707: LD_INT 2
16709: ARRAY
16710: PUSH
16711: LD_INT 4
16713: PLUS
16714: PPUSH
16715: CALL_OW 12
16719: PPUSH
16720: CALL_OW 174
16724: GO 16650
16726: POP
16727: POP
// end ;
16728: LD_VAR 0 1
16732: RET
// export function f_normal2_utok ; var path , i ; begin
16733: LD_INT 0
16735: PPUSH
16736: PPUSH
16737: PPUSH
// path := [ [ 91 , 61 ] , [ 79 , 79 ] , [ 57 , 61 ] , [ 68 , 48 ] , [ 64 , 94 ] ] ;
16738: LD_ADDR_VAR 0 2
16742: PUSH
16743: LD_INT 91
16745: PUSH
16746: LD_INT 61
16748: PUSH
16749: EMPTY
16750: LIST
16751: LIST
16752: PUSH
16753: LD_INT 79
16755: PUSH
16756: LD_INT 79
16758: PUSH
16759: EMPTY
16760: LIST
16761: LIST
16762: PUSH
16763: LD_INT 57
16765: PUSH
16766: LD_INT 61
16768: PUSH
16769: EMPTY
16770: LIST
16771: LIST
16772: PUSH
16773: LD_INT 68
16775: PUSH
16776: LD_INT 48
16778: PUSH
16779: EMPTY
16780: LIST
16781: LIST
16782: PUSH
16783: LD_INT 64
16785: PUSH
16786: LD_INT 94
16788: PUSH
16789: EMPTY
16790: LIST
16791: LIST
16792: PUSH
16793: EMPTY
16794: LIST
16795: LIST
16796: LIST
16797: LIST
16798: LIST
16799: ST_TO_ADDR
// find_and_wait ( UnitFilter ( zbytek , [ [ f_control , control_manual ] ] ) , sol , false , false , 0 0$50 ) ;
16800: LD_EXP 72
16804: PPUSH
16805: LD_INT 33
16807: PUSH
16808: LD_INT 1
16810: PUSH
16811: EMPTY
16812: LIST
16813: LIST
16814: PUSH
16815: EMPTY
16816: LIST
16817: PPUSH
16818: CALL_OW 72
16822: PPUSH
16823: LD_EXP 19
16827: PPUSH
16828: LD_INT 0
16830: PPUSH
16831: LD_INT 0
16833: PPUSH
16834: LD_INT 1750
16836: PPUSH
16837: CALL 24634 0 5
// find_and_wait_r ( UnitFilter ( zbytek , [ [ f_control , control_remote ] ] ) , remote , 0 0$50 ) ;
16841: LD_EXP 72
16845: PPUSH
16846: LD_INT 33
16848: PUSH
16849: LD_INT 2
16851: PUSH
16852: EMPTY
16853: LIST
16854: LIST
16855: PUSH
16856: EMPTY
16857: LIST
16858: PPUSH
16859: CALL_OW 72
16863: PPUSH
16864: LD_EXP 29
16868: PPUSH
16869: LD_INT 1750
16871: PPUSH
16872: CALL 25334 0 3
// for i in path do
16876: LD_ADDR_VAR 0 3
16880: PUSH
16881: LD_VAR 0 2
16885: PUSH
16886: FOR_IN
16887: IFFALSE 16962
// AddComAgressiveMove ( zbytek , Rand ( i [ 1 ] - 4 , i [ 1 ] + 4 ) , Rand ( i [ 2 ] - 4 , i [ 2 ] + 4 ) ) ;
16889: LD_EXP 72
16893: PPUSH
16894: LD_VAR 0 3
16898: PUSH
16899: LD_INT 1
16901: ARRAY
16902: PUSH
16903: LD_INT 4
16905: MINUS
16906: PPUSH
16907: LD_VAR 0 3
16911: PUSH
16912: LD_INT 1
16914: ARRAY
16915: PUSH
16916: LD_INT 4
16918: PLUS
16919: PPUSH
16920: CALL_OW 12
16924: PPUSH
16925: LD_VAR 0 3
16929: PUSH
16930: LD_INT 2
16932: ARRAY
16933: PUSH
16934: LD_INT 4
16936: MINUS
16937: PPUSH
16938: LD_VAR 0 3
16942: PUSH
16943: LD_INT 2
16945: ARRAY
16946: PUSH
16947: LD_INT 4
16949: PLUS
16950: PPUSH
16951: CALL_OW 12
16955: PPUSH
16956: CALL_OW 174
16960: GO 16886
16962: POP
16963: POP
// end ;
16964: LD_VAR 0 1
16968: RET
// export function f_normal3_utok ; var path , i ; begin
16969: LD_INT 0
16971: PPUSH
16972: PPUSH
16973: PPUSH
// path := [ [ 114 , 67 ] , [ 108 , 67 ] , [ 102 , 66 ] , [ 94 , 65 ] , [ 95 , 79 ] , [ 91 , 89 ] , [ 81 , 93 ] , [ 71 , 83 ] , [ 61 , 75 ] , [ 52 , 58 ] , [ 67 , 71 ] , [ 70 , 59 ] , [ 65 , 49 ] , [ 51 , 45 ] , [ 65 , 40 ] , [ 92 , 67 ] ] ;
16974: LD_ADDR_VAR 0 2
16978: PUSH
16979: LD_INT 114
16981: PUSH
16982: LD_INT 67
16984: PUSH
16985: EMPTY
16986: LIST
16987: LIST
16988: PUSH
16989: LD_INT 108
16991: PUSH
16992: LD_INT 67
16994: PUSH
16995: EMPTY
16996: LIST
16997: LIST
16998: PUSH
16999: LD_INT 102
17001: PUSH
17002: LD_INT 66
17004: PUSH
17005: EMPTY
17006: LIST
17007: LIST
17008: PUSH
17009: LD_INT 94
17011: PUSH
17012: LD_INT 65
17014: PUSH
17015: EMPTY
17016: LIST
17017: LIST
17018: PUSH
17019: LD_INT 95
17021: PUSH
17022: LD_INT 79
17024: PUSH
17025: EMPTY
17026: LIST
17027: LIST
17028: PUSH
17029: LD_INT 91
17031: PUSH
17032: LD_INT 89
17034: PUSH
17035: EMPTY
17036: LIST
17037: LIST
17038: PUSH
17039: LD_INT 81
17041: PUSH
17042: LD_INT 93
17044: PUSH
17045: EMPTY
17046: LIST
17047: LIST
17048: PUSH
17049: LD_INT 71
17051: PUSH
17052: LD_INT 83
17054: PUSH
17055: EMPTY
17056: LIST
17057: LIST
17058: PUSH
17059: LD_INT 61
17061: PUSH
17062: LD_INT 75
17064: PUSH
17065: EMPTY
17066: LIST
17067: LIST
17068: PUSH
17069: LD_INT 52
17071: PUSH
17072: LD_INT 58
17074: PUSH
17075: EMPTY
17076: LIST
17077: LIST
17078: PUSH
17079: LD_INT 67
17081: PUSH
17082: LD_INT 71
17084: PUSH
17085: EMPTY
17086: LIST
17087: LIST
17088: PUSH
17089: LD_INT 70
17091: PUSH
17092: LD_INT 59
17094: PUSH
17095: EMPTY
17096: LIST
17097: LIST
17098: PUSH
17099: LD_INT 65
17101: PUSH
17102: LD_INT 49
17104: PUSH
17105: EMPTY
17106: LIST
17107: LIST
17108: PUSH
17109: LD_INT 51
17111: PUSH
17112: LD_INT 45
17114: PUSH
17115: EMPTY
17116: LIST
17117: LIST
17118: PUSH
17119: LD_INT 65
17121: PUSH
17122: LD_INT 40
17124: PUSH
17125: EMPTY
17126: LIST
17127: LIST
17128: PUSH
17129: LD_INT 92
17131: PUSH
17132: LD_INT 67
17134: PUSH
17135: EMPTY
17136: LIST
17137: LIST
17138: PUSH
17139: EMPTY
17140: LIST
17141: LIST
17142: LIST
17143: LIST
17144: LIST
17145: LIST
17146: LIST
17147: LIST
17148: LIST
17149: LIST
17150: LIST
17151: LIST
17152: LIST
17153: LIST
17154: LIST
17155: LIST
17156: ST_TO_ADDR
// find_and_wait ( UnitFilter ( zbytek , [ [ f_control , control_manual ] ] ) , sol , false , false , 0 0$50 ) ;
17157: LD_EXP 72
17161: PPUSH
17162: LD_INT 33
17164: PUSH
17165: LD_INT 1
17167: PUSH
17168: EMPTY
17169: LIST
17170: LIST
17171: PUSH
17172: EMPTY
17173: LIST
17174: PPUSH
17175: CALL_OW 72
17179: PPUSH
17180: LD_EXP 19
17184: PPUSH
17185: LD_INT 0
17187: PPUSH
17188: LD_INT 0
17190: PPUSH
17191: LD_INT 1750
17193: PPUSH
17194: CALL 24634 0 5
// find_and_wait_r ( UnitFilter ( zbytek , [ [ f_control , control_remote ] ] ) , remote , 0 0$50 ) ;
17198: LD_EXP 72
17202: PPUSH
17203: LD_INT 33
17205: PUSH
17206: LD_INT 2
17208: PUSH
17209: EMPTY
17210: LIST
17211: LIST
17212: PUSH
17213: EMPTY
17214: LIST
17215: PPUSH
17216: CALL_OW 72
17220: PPUSH
17221: LD_EXP 29
17225: PPUSH
17226: LD_INT 1750
17228: PPUSH
17229: CALL 25334 0 3
// for i in path do
17233: LD_ADDR_VAR 0 3
17237: PUSH
17238: LD_VAR 0 2
17242: PUSH
17243: FOR_IN
17244: IFFALSE 17319
// AddComAgressiveMove ( zbytek , Rand ( i [ 1 ] - 4 , i [ 1 ] + 4 ) , Rand ( i [ 2 ] - 4 , i [ 2 ] + 4 ) ) ;
17246: LD_EXP 72
17250: PPUSH
17251: LD_VAR 0 3
17255: PUSH
17256: LD_INT 1
17258: ARRAY
17259: PUSH
17260: LD_INT 4
17262: MINUS
17263: PPUSH
17264: LD_VAR 0 3
17268: PUSH
17269: LD_INT 1
17271: ARRAY
17272: PUSH
17273: LD_INT 4
17275: PLUS
17276: PPUSH
17277: CALL_OW 12
17281: PPUSH
17282: LD_VAR 0 3
17286: PUSH
17287: LD_INT 2
17289: ARRAY
17290: PUSH
17291: LD_INT 4
17293: MINUS
17294: PPUSH
17295: LD_VAR 0 3
17299: PUSH
17300: LD_INT 2
17302: ARRAY
17303: PUSH
17304: LD_INT 4
17306: PLUS
17307: PPUSH
17308: CALL_OW 12
17312: PPUSH
17313: CALL_OW 174
17317: GO 17243
17319: POP
17320: POP
// end ;
17321: LD_VAR 0 1
17325: RET
// export function f_normal4_utok ; var path , i ; begin
17326: LD_INT 0
17328: PPUSH
17329: PPUSH
17330: PPUSH
// path := [ [ 112 , 68 ] , [ 98 , 67 ] , [ 80 , 61 ] , [ 72 , 61 ] , [ 62 , 60 ] , [ 61 , 50 ] , [ 49 , 38 ] , [ 52 , 48 ] , [ 62 , 62 ] , [ 66 , 78 ] , [ 74 , 80 ] ] ;
17331: LD_ADDR_VAR 0 2
17335: PUSH
17336: LD_INT 112
17338: PUSH
17339: LD_INT 68
17341: PUSH
17342: EMPTY
17343: LIST
17344: LIST
17345: PUSH
17346: LD_INT 98
17348: PUSH
17349: LD_INT 67
17351: PUSH
17352: EMPTY
17353: LIST
17354: LIST
17355: PUSH
17356: LD_INT 80
17358: PUSH
17359: LD_INT 61
17361: PUSH
17362: EMPTY
17363: LIST
17364: LIST
17365: PUSH
17366: LD_INT 72
17368: PUSH
17369: LD_INT 61
17371: PUSH
17372: EMPTY
17373: LIST
17374: LIST
17375: PUSH
17376: LD_INT 62
17378: PUSH
17379: LD_INT 60
17381: PUSH
17382: EMPTY
17383: LIST
17384: LIST
17385: PUSH
17386: LD_INT 61
17388: PUSH
17389: LD_INT 50
17391: PUSH
17392: EMPTY
17393: LIST
17394: LIST
17395: PUSH
17396: LD_INT 49
17398: PUSH
17399: LD_INT 38
17401: PUSH
17402: EMPTY
17403: LIST
17404: LIST
17405: PUSH
17406: LD_INT 52
17408: PUSH
17409: LD_INT 48
17411: PUSH
17412: EMPTY
17413: LIST
17414: LIST
17415: PUSH
17416: LD_INT 62
17418: PUSH
17419: LD_INT 62
17421: PUSH
17422: EMPTY
17423: LIST
17424: LIST
17425: PUSH
17426: LD_INT 66
17428: PUSH
17429: LD_INT 78
17431: PUSH
17432: EMPTY
17433: LIST
17434: LIST
17435: PUSH
17436: LD_INT 74
17438: PUSH
17439: LD_INT 80
17441: PUSH
17442: EMPTY
17443: LIST
17444: LIST
17445: PUSH
17446: EMPTY
17447: LIST
17448: LIST
17449: LIST
17450: LIST
17451: LIST
17452: LIST
17453: LIST
17454: LIST
17455: LIST
17456: LIST
17457: LIST
17458: ST_TO_ADDR
// find_and_wait ( UnitFilter ( zbytek , [ [ f_control , control_manual ] ] ) , sol , false , false , 0 0$50 ) ;
17459: LD_EXP 72
17463: PPUSH
17464: LD_INT 33
17466: PUSH
17467: LD_INT 1
17469: PUSH
17470: EMPTY
17471: LIST
17472: LIST
17473: PUSH
17474: EMPTY
17475: LIST
17476: PPUSH
17477: CALL_OW 72
17481: PPUSH
17482: LD_EXP 19
17486: PPUSH
17487: LD_INT 0
17489: PPUSH
17490: LD_INT 0
17492: PPUSH
17493: LD_INT 1750
17495: PPUSH
17496: CALL 24634 0 5
// find_and_wait_r ( UnitFilter ( zbytek , [ [ f_control , control_remote ] ] ) , remote , 0 0$50 ) ;
17500: LD_EXP 72
17504: PPUSH
17505: LD_INT 33
17507: PUSH
17508: LD_INT 2
17510: PUSH
17511: EMPTY
17512: LIST
17513: LIST
17514: PUSH
17515: EMPTY
17516: LIST
17517: PPUSH
17518: CALL_OW 72
17522: PPUSH
17523: LD_EXP 29
17527: PPUSH
17528: LD_INT 1750
17530: PPUSH
17531: CALL 25334 0 3
// for i in path do
17535: LD_ADDR_VAR 0 3
17539: PUSH
17540: LD_VAR 0 2
17544: PUSH
17545: FOR_IN
17546: IFFALSE 17621
// AddComAgressiveMove ( zbytek , Rand ( i [ 1 ] - 4 , i [ 1 ] + 4 ) , Rand ( i [ 2 ] - 4 , i [ 2 ] + 4 ) ) ;
17548: LD_EXP 72
17552: PPUSH
17553: LD_VAR 0 3
17557: PUSH
17558: LD_INT 1
17560: ARRAY
17561: PUSH
17562: LD_INT 4
17564: MINUS
17565: PPUSH
17566: LD_VAR 0 3
17570: PUSH
17571: LD_INT 1
17573: ARRAY
17574: PUSH
17575: LD_INT 4
17577: PLUS
17578: PPUSH
17579: CALL_OW 12
17583: PPUSH
17584: LD_VAR 0 3
17588: PUSH
17589: LD_INT 2
17591: ARRAY
17592: PUSH
17593: LD_INT 4
17595: MINUS
17596: PPUSH
17597: LD_VAR 0 3
17601: PUSH
17602: LD_INT 2
17604: ARRAY
17605: PUSH
17606: LD_INT 4
17608: PLUS
17609: PPUSH
17610: CALL_OW 12
17614: PPUSH
17615: CALL_OW 174
17619: GO 17545
17621: POP
17622: POP
// end ;
17623: LD_VAR 0 1
17627: RET
// export mines ; every 0 0$1 do var i ;
17628: GO 17630
17630: DISABLE
17631: LD_INT 0
17633: PPUSH
// begin mines := [ ] ;
17634: LD_ADDR_EXP 73
17638: PUSH
17639: EMPTY
17640: ST_TO_ADDR
// sol := UnitFilter ( sol , [ [ f_alive ] ] ) ;
17641: LD_ADDR_EXP 19
17645: PUSH
17646: LD_EXP 19
17650: PPUSH
17651: LD_INT 51
17653: PUSH
17654: EMPTY
17655: LIST
17656: PUSH
17657: EMPTY
17658: LIST
17659: PPUSH
17660: CALL_OW 72
17664: ST_TO_ADDR
// for i in sol do
17665: LD_ADDR_VAR 0 1
17669: PUSH
17670: LD_EXP 19
17674: PUSH
17675: FOR_IN
17676: IFFALSE 17710
// if MineOfUnit ( i ) then
17678: LD_VAR 0 1
17682: PPUSH
17683: CALL_OW 459
17687: IFFALSE 17708
// mines := mines ^ [ i ] ;
17689: LD_ADDR_EXP 73
17693: PUSH
17694: LD_EXP 73
17698: PUSH
17699: LD_VAR 0 1
17703: PUSH
17704: EMPTY
17705: LIST
17706: ADD
17707: ST_TO_ADDR
17708: GO 17675
17710: POP
17711: POP
// enable ;
17712: ENABLE
// end ;
17713: PPOPN 1
17715: END
// every 0 0$30 trigger mines < pocet_min do var i , a , s ;
17716: LD_EXP 73
17720: PUSH
17721: LD_EXP 16
17725: LESS
17726: IFFALSE 17867
17728: GO 17730
17730: DISABLE
17731: LD_INT 0
17733: PPUSH
17734: PPUSH
17735: PPUSH
// begin s := UnitFilter ( sol , [ [ f_outside ] ] ) ;
17736: LD_ADDR_VAR 0 3
17740: PUSH
17741: LD_EXP 19
17745: PPUSH
17746: LD_INT 56
17748: PUSH
17749: EMPTY
17750: LIST
17751: PUSH
17752: EMPTY
17753: LIST
17754: PPUSH
17755: CALL_OW 72
17759: ST_TO_ADDR
// if s then
17760: LD_VAR 0 3
17764: IFFALSE 17866
// begin i := s [ Rand ( 1 , s ) ] ;
17766: LD_ADDR_VAR 0 1
17770: PUSH
17771: LD_VAR 0 3
17775: PUSH
17776: LD_INT 1
17778: PPUSH
17779: LD_VAR 0 3
17783: PPUSH
17784: CALL_OW 12
17788: ARRAY
17789: ST_TO_ADDR
// if not MineOfUnit ( i ) then
17790: LD_VAR 0 1
17794: PPUSH
17795: CALL_OW 459
17799: NOT
17800: IFFALSE 17866
// begin ComRemember ( i ) ;
17802: LD_VAR 0 1
17806: PPUSH
17807: CALL_OW 143
// a := RandHexArea ( miny , false ) ;
17811: LD_ADDR_VAR 0 2
17815: PUSH
17816: LD_INT 25
17818: PPUSH
17819: LD_INT 0
17821: PPUSH
17822: CALL_OW 16
17826: ST_TO_ADDR
// AddComPlaceRemoteCharge ( i , a [ 1 ] , a [ 2 ] , 0 ) ;
17827: LD_VAR 0 1
17831: PPUSH
17832: LD_VAR 0 2
17836: PUSH
17837: LD_INT 1
17839: ARRAY
17840: PPUSH
17841: LD_VAR 0 2
17845: PUSH
17846: LD_INT 2
17848: ARRAY
17849: PPUSH
17850: LD_INT 0
17852: PPUSH
17853: CALL_OW 193
// AddComReturn ( i ) ;
17857: LD_VAR 0 1
17861: PPUSH
17862: CALL_OW 204
// end ; end ; enable ;
17866: ENABLE
// end ;
17867: PPOPN 3
17869: END
// every 0 0$2 trigger mines and FilterUnitsInArea ( miny , [ [ f_side , you ] ] ) and ( FilterUnitsInArea ( miny , [ [ f_side , arabians ] ] ) < 2 ) do
17870: LD_EXP 73
17874: PUSH
17875: LD_INT 25
17877: PPUSH
17878: LD_INT 22
17880: PUSH
17881: LD_EXP 1
17885: PUSH
17886: EMPTY
17887: LIST
17888: LIST
17889: PUSH
17890: EMPTY
17891: LIST
17892: PPUSH
17893: CALL_OW 70
17897: AND
17898: PUSH
17899: LD_INT 25
17901: PPUSH
17902: LD_INT 22
17904: PUSH
17905: LD_EXP 3
17909: PUSH
17910: EMPTY
17911: LIST
17912: LIST
17913: PUSH
17914: EMPTY
17915: LIST
17916: PPUSH
17917: CALL_OW 70
17921: PUSH
17922: LD_INT 2
17924: LESS
17925: AND
17926: IFFALSE 17977
17928: GO 17930
17930: DISABLE
// begin ComFireExplosives ( mines [ 1 ] ) ;
17931: LD_EXP 73
17935: PUSH
17936: LD_INT 1
17938: ARRAY
17939: PPUSH
17940: CALL_OW 134
// mines := mines diff [ mines [ 1 ] ] ;
17944: LD_ADDR_EXP 73
17948: PUSH
17949: LD_EXP 73
17953: PUSH
17954: LD_EXP 73
17958: PUSH
17959: LD_INT 1
17961: ARRAY
17962: PUSH
17963: EMPTY
17964: LIST
17965: DIFF
17966: ST_TO_ADDR
// wait ( mezera_mezi_minami ) ;
17967: LD_EXP 15
17971: PPUSH
17972: CALL_OW 67
// enable ;
17976: ENABLE
// end ; end_of_file
17977: END
// export opravit ; every 0 0$1 do var set_fuel , fuel ;
17978: GO 17980
17980: DISABLE
17981: LD_INT 0
17983: PPUSH
17984: PPUSH
// begin for set_fuel in FilterUnitsInArea ( near_base , [ [ f_type , unit_vehicle ] , [ f_side , arabians ] ] ) do
17985: LD_ADDR_VAR 0 1
17989: PUSH
17990: LD_INT 13
17992: PPUSH
17993: LD_INT 21
17995: PUSH
17996: LD_INT 2
17998: PUSH
17999: EMPTY
18000: LIST
18001: LIST
18002: PUSH
18003: LD_INT 22
18005: PUSH
18006: LD_EXP 3
18010: PUSH
18011: EMPTY
18012: LIST
18013: LIST
18014: PUSH
18015: EMPTY
18016: LIST
18017: LIST
18018: PPUSH
18019: CALL_OW 70
18023: PUSH
18024: FOR_IN
18025: IFFALSE 18066
// begin fuel := GetFuel ( set_fuel ) ;
18027: LD_ADDR_VAR 0 2
18031: PUSH
18032: LD_VAR 0 1
18036: PPUSH
18037: CALL_OW 261
18041: ST_TO_ADDR
// if fuel < 100 then
18042: LD_VAR 0 2
18046: PUSH
18047: LD_INT 100
18049: LESS
18050: IFFALSE 18064
// SetFuel ( set_fuel , 100 ) ;
18052: LD_VAR 0 1
18056: PPUSH
18057: LD_INT 100
18059: PPUSH
18060: CALL_OW 240
// end ;
18064: GO 18024
18066: POP
18067: POP
// enable ;
18068: ENABLE
// end ;
18069: PPOPN 2
18071: END
// every 0 0$10 + 0 0$8 do var zivoty , i ;
18072: GO 18074
18074: DISABLE
18075: LD_INT 0
18077: PPUSH
18078: PPUSH
// begin opravit := [ ] ;
18079: LD_ADDR_EXP 74
18083: PUSH
18084: EMPTY
18085: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , arabians ] , [ f_type , unit_building ] ] ) do
18086: LD_ADDR_VAR 0 2
18090: PUSH
18091: LD_INT 22
18093: PUSH
18094: LD_EXP 3
18098: PUSH
18099: EMPTY
18100: LIST
18101: LIST
18102: PUSH
18103: LD_INT 21
18105: PUSH
18106: LD_INT 3
18108: PUSH
18109: EMPTY
18110: LIST
18111: LIST
18112: PUSH
18113: EMPTY
18114: LIST
18115: LIST
18116: PPUSH
18117: CALL_OW 69
18121: PUSH
18122: FOR_IN
18123: IFFALSE 18179
// begin if GetLives ( i ) < 950 then
18125: LD_VAR 0 2
18129: PPUSH
18130: CALL_OW 256
18134: PUSH
18135: LD_INT 950
18137: LESS
18138: IFFALSE 18177
// begin opravit := opravit ^ i ;
18140: LD_ADDR_EXP 74
18144: PUSH
18145: LD_EXP 74
18149: PUSH
18150: LD_VAR 0 2
18154: ADD
18155: ST_TO_ADDR
// zivoty := zivoty ^ GetLives ( i ) ;
18156: LD_ADDR_VAR 0 1
18160: PUSH
18161: LD_VAR 0 1
18165: PUSH
18166: LD_VAR 0 2
18170: PPUSH
18171: CALL_OW 256
18175: ADD
18176: ST_TO_ADDR
// end ; end ;
18177: GO 18122
18179: POP
18180: POP
// opravit := SortListByListAsc ( opravit , zivoty ) ;
18181: LD_ADDR_EXP 74
18185: PUSH
18186: LD_EXP 74
18190: PPUSH
18191: LD_VAR 0 1
18195: PPUSH
18196: CALL_OW 76
18200: ST_TO_ADDR
// enable ;
18201: ENABLE
// end ;
18202: PPOPN 2
18204: END
// every 0 0$20 trigger opravit do var tmp_eng ;
18205: LD_EXP 74
18209: IFFALSE 18301
18211: GO 18213
18213: DISABLE
18214: LD_INT 0
18216: PPUSH
// begin while not eng do
18217: LD_EXP 23
18221: NOT
18222: IFFALSE 18233
// wait ( 0 0$5 ) ;
18224: LD_INT 175
18226: PPUSH
18227: CALL_OW 67
18231: GO 18217
// tmp_eng := eng ;
18233: LD_ADDR_VAR 0 1
18237: PUSH
18238: LD_EXP 23
18242: ST_TO_ADDR
// eng := [ ] ;
18243: LD_ADDR_EXP 23
18247: PUSH
18248: EMPTY
18249: ST_TO_ADDR
// ComExitBuilding ( tmp_eng ) ;
18250: LD_VAR 0 1
18254: PPUSH
18255: CALL_OW 122
// AddComRepairBuilding ( tmp_eng , opravit [ 1 ] ) ;
18259: LD_VAR 0 1
18263: PPUSH
18264: LD_EXP 74
18268: PUSH
18269: LD_INT 1
18271: ARRAY
18272: PPUSH
18273: CALL_OW 190
// wait ( 0 0$19.9 ) ;
18277: LD_INT 696
18279: PPUSH
18280: CALL_OW 67
// eng := eng union tmp_eng ;
18284: LD_ADDR_EXP 23
18288: PUSH
18289: LD_EXP 23
18293: PUSH
18294: LD_VAR 0 1
18298: UNION
18299: ST_TO_ADDR
// enable ;
18300: ENABLE
// end ;
18301: PPOPN 1
18303: END
// every 0 0$10 trigger stavi do var tmp_eng , tmp_sci ;
18304: LD_EXP 69
18308: IFFALSE 18432
18310: GO 18312
18312: DISABLE
18313: LD_INT 0
18315: PPUSH
18316: PPUSH
// begin tmp_eng := eng ;
18317: LD_ADDR_VAR 0 1
18321: PUSH
18322: LD_EXP 23
18326: ST_TO_ADDR
// eng := [ ] ;
18327: LD_ADDR_EXP 23
18331: PUSH
18332: EMPTY
18333: ST_TO_ADDR
// tmp_sci := sci ;
18334: LD_ADDR_VAR 0 2
18338: PUSH
18339: LD_EXP 21
18343: ST_TO_ADDR
// sci := [ ] ;
18344: LD_ADDR_EXP 21
18348: PUSH
18349: EMPTY
18350: ST_TO_ADDR
// ComExitBuilding ( tmp_eng ^ tmp_sci ) ;
18351: LD_VAR 0 1
18355: PUSH
18356: LD_VAR 0 2
18360: ADD
18361: PPUSH
18362: CALL_OW 122
// AddComMoveXY ( tmp_eng ^ tmp_sci , stavi [ 1 ] , stavi [ 2 ] ) ;
18366: LD_VAR 0 1
18370: PUSH
18371: LD_VAR 0 2
18375: ADD
18376: PPUSH
18377: LD_EXP 69
18381: PUSH
18382: LD_INT 1
18384: ARRAY
18385: PPUSH
18386: LD_EXP 69
18390: PUSH
18391: LD_INT 2
18393: ARRAY
18394: PPUSH
18395: CALL_OW 171
// eng := eng union tmp_eng ;
18399: LD_ADDR_EXP 23
18403: PUSH
18404: LD_EXP 23
18408: PUSH
18409: LD_VAR 0 1
18413: UNION
18414: ST_TO_ADDR
// sci := sci union tmp_sci ;
18415: LD_ADDR_EXP 21
18419: PUSH
18420: LD_EXP 21
18424: PUSH
18425: LD_VAR 0 2
18429: UNION
18430: ST_TO_ADDR
// enable ;
18431: ENABLE
// end ;
18432: PPOPN 2
18434: END
// export brk_cars ; every 0 0$1 do var zivoty , i ;
18435: GO 18437
18437: DISABLE
18438: LD_INT 0
18440: PPUSH
18441: PPUSH
// begin for i in attack do
18442: LD_ADDR_VAR 0 2
18446: PUSH
18447: LD_EXP 27
18451: PUSH
18452: FOR_IN
18453: IFFALSE 18566
// begin if GetLives ( i ) < 600 or GetFuel ( i ) < 30 then
18455: LD_VAR 0 2
18459: PPUSH
18460: CALL_OW 256
18464: PUSH
18465: LD_INT 600
18467: LESS
18468: PUSH
18469: LD_VAR 0 2
18473: PPUSH
18474: CALL_OW 261
18478: PUSH
18479: LD_INT 30
18481: LESS
18482: OR
18483: IFFALSE 18518
// begin ComMoveXY ( i , 141 , 72 ) ;
18485: LD_VAR 0 2
18489: PPUSH
18490: LD_INT 141
18492: PPUSH
18493: LD_INT 72
18495: PPUSH
18496: CALL_OW 111
// brk_cars := brk_cars union i ;
18500: LD_ADDR_EXP 75
18504: PUSH
18505: LD_EXP 75
18509: PUSH
18510: LD_VAR 0 2
18514: UNION
18515: ST_TO_ADDR
// end else
18516: GO 18564
// if GetLives ( i ) > 995 and GetFuel ( i ) > 99 then
18518: LD_VAR 0 2
18522: PPUSH
18523: CALL_OW 256
18527: PUSH
18528: LD_INT 995
18530: GREATER
18531: PUSH
18532: LD_VAR 0 2
18536: PPUSH
18537: CALL_OW 261
18541: PUSH
18542: LD_INT 99
18544: GREATER
18545: AND
18546: IFFALSE 18564
// brk_cars := brk_cars diff i ;
18548: LD_ADDR_EXP 75
18552: PUSH
18553: LD_EXP 75
18557: PUSH
18558: LD_VAR 0 2
18562: DIFF
18563: ST_TO_ADDR
// end ;
18564: GO 18452
18566: POP
18567: POP
// enable ;
18568: ENABLE
// end ;
18569: PPOPN 2
18571: END
// every 0 0$10 do var zivoty , i ;
18572: GO 18574
18574: DISABLE
18575: LD_INT 0
18577: PPUSH
18578: PPUSH
// begin for i in ( defence diff mastodon ) do
18579: LD_ADDR_VAR 0 2
18583: PUSH
18584: LD_EXP 28
18588: PUSH
18589: LD_INT 1
18591: DIFF
18592: PUSH
18593: FOR_IN
18594: IFFALSE 18707
// begin if GetLives ( i ) < 400 and GetFuel ( i ) < 15 then
18596: LD_VAR 0 2
18600: PPUSH
18601: CALL_OW 256
18605: PUSH
18606: LD_INT 400
18608: LESS
18609: PUSH
18610: LD_VAR 0 2
18614: PPUSH
18615: CALL_OW 261
18619: PUSH
18620: LD_INT 15
18622: LESS
18623: AND
18624: IFFALSE 18659
// begin ComMoveXY ( i , 141 , 72 ) ;
18626: LD_VAR 0 2
18630: PPUSH
18631: LD_INT 141
18633: PPUSH
18634: LD_INT 72
18636: PPUSH
18637: CALL_OW 111
// brk_cars := brk_cars union i ;
18641: LD_ADDR_EXP 75
18645: PUSH
18646: LD_EXP 75
18650: PUSH
18651: LD_VAR 0 2
18655: UNION
18656: ST_TO_ADDR
// end else
18657: GO 18705
// if GetLives ( i ) > 995 and GetFuel ( i ) > 99 then
18659: LD_VAR 0 2
18663: PPUSH
18664: CALL_OW 256
18668: PUSH
18669: LD_INT 995
18671: GREATER
18672: PUSH
18673: LD_VAR 0 2
18677: PPUSH
18678: CALL_OW 261
18682: PUSH
18683: LD_INT 99
18685: GREATER
18686: AND
18687: IFFALSE 18705
// brk_cars := brk_cars diff i ;
18689: LD_ADDR_EXP 75
18693: PUSH
18694: LD_EXP 75
18698: PUSH
18699: LD_VAR 0 2
18703: DIFF
18704: ST_TO_ADDR
// end ;
18705: GO 18593
18707: POP
18708: POP
// enable ;
18709: ENABLE
// end ;
18710: PPOPN 2
18712: END
// every 0 0$5 do var zivoty , i ;
18713: GO 18715
18715: DISABLE
18716: LD_INT 0
18718: PPUSH
18719: PPUSH
// begin for i in cargo do
18720: LD_ADDR_VAR 0 2
18724: PUSH
18725: LD_EXP 25
18729: PUSH
18730: FOR_IN
18731: IFFALSE 18814
// begin if GetLives ( i ) < 800 then
18733: LD_VAR 0 2
18737: PPUSH
18738: CALL_OW 256
18742: PUSH
18743: LD_INT 800
18745: LESS
18746: IFFALSE 18781
// begin ComMoveXY ( i , 141 , 72 ) ;
18748: LD_VAR 0 2
18752: PPUSH
18753: LD_INT 141
18755: PPUSH
18756: LD_INT 72
18758: PPUSH
18759: CALL_OW 111
// brk_cars := brk_cars union i ;
18763: LD_ADDR_EXP 75
18767: PUSH
18768: LD_EXP 75
18772: PUSH
18773: LD_VAR 0 2
18777: UNION
18778: ST_TO_ADDR
// end else
18779: GO 18812
// if GetLives ( i ) > 995 then
18781: LD_VAR 0 2
18785: PPUSH
18786: CALL_OW 256
18790: PUSH
18791: LD_INT 995
18793: GREATER
18794: IFFALSE 18812
// brk_cars := brk_cars diff i ;
18796: LD_ADDR_EXP 75
18800: PUSH
18801: LD_EXP 75
18805: PUSH
18806: LD_VAR 0 2
18810: DIFF
18811: ST_TO_ADDR
// end ;
18812: GO 18730
18814: POP
18815: POP
// enable ;
18816: ENABLE
// end ;
18817: PPOPN 2
18819: END
// export rep_cars ; every 0 0$10 do var zivoty , i , tmp_mec , nejhorsi , mytick ;
18820: GO 18822
18822: DISABLE
18823: LD_INT 0
18825: PPUSH
18826: PPUSH
18827: PPUSH
18828: PPUSH
18829: PPUSH
// begin rep_cars := [ ] ;
18830: LD_ADDR_EXP 76
18834: PUSH
18835: EMPTY
18836: ST_TO_ADDR
// zivoty := [ ] ;
18837: LD_ADDR_VAR 0 1
18841: PUSH
18842: EMPTY
18843: ST_TO_ADDR
// for i in UnitFilter ( attack ^ ( defence diff mastodon ) ^ cargo , [ [ f_distxy , 141 , 72 , 20 ] ] ) do
18844: LD_ADDR_VAR 0 2
18848: PUSH
18849: LD_EXP 27
18853: PUSH
18854: LD_EXP 28
18858: PUSH
18859: LD_INT 1
18861: DIFF
18862: ADD
18863: PUSH
18864: LD_EXP 25
18868: ADD
18869: PPUSH
18870: LD_INT 92
18872: PUSH
18873: LD_INT 141
18875: PUSH
18876: LD_INT 72
18878: PUSH
18879: LD_INT 20
18881: PUSH
18882: EMPTY
18883: LIST
18884: LIST
18885: LIST
18886: LIST
18887: PUSH
18888: EMPTY
18889: LIST
18890: PPUSH
18891: CALL_OW 72
18895: PUSH
18896: FOR_IN
18897: IFFALSE 18953
// begin if GetLives ( i ) < 1000 then
18899: LD_VAR 0 2
18903: PPUSH
18904: CALL_OW 256
18908: PUSH
18909: LD_INT 1000
18911: LESS
18912: IFFALSE 18951
// begin rep_cars := rep_cars ^ i ;
18914: LD_ADDR_EXP 76
18918: PUSH
18919: LD_EXP 76
18923: PUSH
18924: LD_VAR 0 2
18928: ADD
18929: ST_TO_ADDR
// zivoty := zivoty ^ GetLives ( i ) ;
18930: LD_ADDR_VAR 0 1
18934: PUSH
18935: LD_VAR 0 1
18939: PUSH
18940: LD_VAR 0 2
18944: PPUSH
18945: CALL_OW 256
18949: ADD
18950: ST_TO_ADDR
// end ; end ;
18951: GO 18896
18953: POP
18954: POP
// if rep_cars then
18955: LD_EXP 76
18959: IFFALSE 19087
// begin nejhorsi := WorstFromListByList ( rep_cars , zivoty ) ;
18961: LD_ADDR_VAR 0 4
18965: PUSH
18966: LD_EXP 76
18970: PPUSH
18971: LD_VAR 0 1
18975: PPUSH
18976: CALL_OW 78
18980: ST_TO_ADDR
// tmp_mec := mec ;
18981: LD_ADDR_VAR 0 3
18985: PUSH
18986: LD_EXP 22
18990: ST_TO_ADDR
// mec := [ ] ;
18991: LD_ADDR_EXP 22
18995: PUSH
18996: EMPTY
18997: ST_TO_ADDR
// ComExitBuilding ( tmp_mec ) ;
18998: LD_VAR 0 3
19002: PPUSH
19003: CALL_OW 122
// AddComRepairVehicle ( tmp_mec , nejhorsi ) ;
19007: LD_VAR 0 3
19011: PPUSH
19012: LD_VAR 0 4
19016: PPUSH
19017: CALL_OW 189
// mytick := tick + 0 0$9.9 ;
19021: LD_ADDR_VAR 0 5
19025: PUSH
19026: LD_OWVAR 1
19030: PUSH
19031: LD_INT 347
19033: PLUS
19034: ST_TO_ADDR
// while mytick > tick and GetLives ( nejhorsi ) < 1000 do
19035: LD_VAR 0 5
19039: PUSH
19040: LD_OWVAR 1
19044: GREATER
19045: PUSH
19046: LD_VAR 0 4
19050: PPUSH
19051: CALL_OW 256
19055: PUSH
19056: LD_INT 1000
19058: LESS
19059: AND
19060: IFFALSE 19071
// wait ( 0 0$1 ) ;
19062: LD_INT 35
19064: PPUSH
19065: CALL_OW 67
19069: GO 19035
// mec := mec union tmp_mec ;
19071: LD_ADDR_EXP 22
19075: PUSH
19076: LD_EXP 22
19080: PUSH
19081: LD_VAR 0 3
19085: UNION
19086: ST_TO_ADDR
// end ; enable ;
19087: ENABLE
// end ; end_of_file
19088: PPOPN 5
19090: END
// every 3 3$12 trigger vsichni_gone do
19091: CALL 19383 0 0
19095: IFFALSE 19238
19097: GO 19099
19099: DISABLE
// begin create_arabs_scout ;
19100: CALL 19947 0 0
// SetFuel ( [ ArScout1 , ArScout2 , ArScout3 ] , 100 ) ;
19104: LD_EXP 77
19108: PUSH
19109: LD_EXP 78
19113: PUSH
19114: LD_EXP 79
19118: PUSH
19119: EMPTY
19120: LIST
19121: LIST
19122: LIST
19123: PPUSH
19124: LD_INT 100
19126: PPUSH
19127: CALL_OW 240
// PlaceUnitArea ( ArScout1 , ar_in_area , false ) ;
19131: LD_EXP 77
19135: PPUSH
19136: LD_INT 2
19138: PPUSH
19139: LD_INT 0
19141: PPUSH
19142: CALL_OW 49
// if difficulty >= 2 then
19146: LD_OWVAR 67
19150: PUSH
19151: LD_INT 2
19153: GREATEREQUAL
19154: IFFALSE 19171
// PlaceUnitArea ( ArScout2 , ar_in_area , false ) ;
19156: LD_EXP 78
19160: PPUSH
19161: LD_INT 2
19163: PPUSH
19164: LD_INT 0
19166: PPUSH
19167: CALL_OW 49
// if difficulty >= 3 then
19171: LD_OWVAR 67
19175: PUSH
19176: LD_INT 3
19178: GREATEREQUAL
19179: IFFALSE 19196
// PlaceUnitArea ( ArScout3 , ar_in_area , false ) ;
19181: LD_EXP 79
19185: PPUSH
19186: LD_INT 2
19188: PPUSH
19189: LD_INT 0
19191: PPUSH
19192: CALL_OW 49
// RaiseSailEvent ( 5001 ) ;
19196: LD_INT 5001
19198: PPUSH
19199: CALL_OW 427
// if difficulty >= 2 then
19203: LD_OWVAR 67
19207: PUSH
19208: LD_INT 2
19210: GREATEREQUAL
19211: IFFALSE 19220
// RaiseSailEvent ( 5002 ) ;
19213: LD_INT 5002
19215: PPUSH
19216: CALL_OW 427
// if difficulty >= 3 then
19220: LD_OWVAR 67
19224: PUSH
19225: LD_INT 3
19227: GREATEREQUAL
19228: IFFALSE 19237
// RaiseSailEvent ( 5003 ) ;
19230: LD_INT 5003
19232: PPUSH
19233: CALL_OW 427
// enable ;
19237: ENABLE
// end ;
19238: END
// every 3 3$12 + 1 1$0 trigger vsichni_gone do
19239: CALL 19383 0 0
19243: IFFALSE 19382
19245: GO 19247
19247: DISABLE
// begin SetFuel ( [ ArScout1 , ArScout2 , ArScout3 ] , 100 ) ;
19248: LD_EXP 77
19252: PUSH
19253: LD_EXP 78
19257: PUSH
19258: LD_EXP 79
19262: PUSH
19263: EMPTY
19264: LIST
19265: LIST
19266: LIST
19267: PPUSH
19268: LD_INT 100
19270: PPUSH
19271: CALL_OW 240
// PlaceUnitArea ( ArScout1 , exit_area , false ) ;
19275: LD_EXP 77
19279: PPUSH
19280: LD_INT 1
19282: PPUSH
19283: LD_INT 0
19285: PPUSH
19286: CALL_OW 49
// if difficulty >= 2 then
19290: LD_OWVAR 67
19294: PUSH
19295: LD_INT 2
19297: GREATEREQUAL
19298: IFFALSE 19315
// PlaceUnitArea ( ArScout2 , exit_area , false ) ;
19300: LD_EXP 78
19304: PPUSH
19305: LD_INT 1
19307: PPUSH
19308: LD_INT 0
19310: PPUSH
19311: CALL_OW 49
// if difficulty >= 3 then
19315: LD_OWVAR 67
19319: PUSH
19320: LD_INT 3
19322: GREATEREQUAL
19323: IFFALSE 19340
// PlaceUnitArea ( ArScout3 , exit_area , false ) ;
19325: LD_EXP 79
19329: PPUSH
19330: LD_INT 1
19332: PPUSH
19333: LD_INT 0
19335: PPUSH
19336: CALL_OW 49
// RaiseSailEvent ( 5051 ) ;
19340: LD_INT 5051
19342: PPUSH
19343: CALL_OW 427
// if difficulty >= 2 then
19347: LD_OWVAR 67
19351: PUSH
19352: LD_INT 2
19354: GREATEREQUAL
19355: IFFALSE 19364
// RaiseSailEvent ( 5052 ) ;
19357: LD_INT 5052
19359: PPUSH
19360: CALL_OW 427
// if difficulty >= 3 then
19364: LD_OWVAR 67
19368: PUSH
19369: LD_INT 3
19371: GREATEREQUAL
19372: IFFALSE 19381
// RaiseSailEvent ( 5053 ) ;
19374: LD_INT 5053
19376: PPUSH
19377: CALL_OW 427
// enable ;
19381: ENABLE
// end ;
19382: END
// export function vsichni_gone ; begin
19383: LD_INT 0
19385: PPUSH
// result := false ;
19386: LD_ADDR_VAR 0 1
19390: PUSH
19391: LD_INT 0
19393: ST_TO_ADDR
// if not UnitFilter ( [ ArScout1 , ArScout2 , ArScout3 ] , [ [ f_ok ] ] ) then
19394: LD_EXP 77
19398: PUSH
19399: LD_EXP 78
19403: PUSH
19404: LD_EXP 79
19408: PUSH
19409: EMPTY
19410: LIST
19411: LIST
19412: LIST
19413: PPUSH
19414: LD_INT 50
19416: PUSH
19417: EMPTY
19418: LIST
19419: PUSH
19420: EMPTY
19421: LIST
19422: PPUSH
19423: CALL_OW 72
19427: NOT
19428: IFFALSE 19438
// result := true ;
19430: LD_ADDR_VAR 0 1
19434: PUSH
19435: LD_INT 1
19437: ST_TO_ADDR
// end ;
19438: LD_VAR 0 1
19442: RET
// export function f_arcar1_in ; begin
19443: LD_INT 0
19445: PPUSH
// while not IsInArea ( ArScout1 , exit_area ) do
19446: LD_EXP 77
19450: PPUSH
19451: LD_INT 1
19453: PPUSH
19454: CALL_OW 308
19458: NOT
19459: IFFALSE 19513
// begin if IsIdle ( arscout1 ) then
19461: LD_EXP 77
19465: PPUSH
19466: CALL_OW 316
19470: IFFALSE 19502
// begin ComAgressiveMove ( ArScout1 , 127 , 135 ) ;
19472: LD_EXP 77
19476: PPUSH
19477: LD_INT 127
19479: PPUSH
19480: LD_INT 135
19482: PPUSH
19483: CALL_OW 114
// AddComAgressiveMove ( ArScout1 , 70 , 134 ) ;
19487: LD_EXP 77
19491: PPUSH
19492: LD_INT 70
19494: PPUSH
19495: LD_INT 134
19497: PPUSH
19498: CALL_OW 174
// end ; DU_wait ( ArScout1 ) ;
19502: LD_EXP 77
19506: PPUSH
19507: CALL 22231 0 1
// end ;
19511: GO 19446
// RemoveUnit ( ArScout1 ) ;
19513: LD_EXP 77
19517: PPUSH
19518: CALL_OW 64
// end ;
19522: LD_VAR 0 1
19526: RET
// export function f_arcar2_in ; begin
19527: LD_INT 0
19529: PPUSH
// while not IsInArea ( ArScout2 , exit_area ) do
19530: LD_EXP 78
19534: PPUSH
19535: LD_INT 1
19537: PPUSH
19538: CALL_OW 308
19542: NOT
19543: IFFALSE 19597
// begin if IsIdle ( arscout2 ) then
19545: LD_EXP 78
19549: PPUSH
19550: CALL_OW 316
19554: IFFALSE 19586
// begin ComAgressiveMove ( ArScout2 , 127 , 135 ) ;
19556: LD_EXP 78
19560: PPUSH
19561: LD_INT 127
19563: PPUSH
19564: LD_INT 135
19566: PPUSH
19567: CALL_OW 114
// AddComAgressiveMove ( ArScout2 , 70 , 134 ) ;
19571: LD_EXP 78
19575: PPUSH
19576: LD_INT 70
19578: PPUSH
19579: LD_INT 134
19581: PPUSH
19582: CALL_OW 174
// end ; DU_wait ( ArScout2 ) ;
19586: LD_EXP 78
19590: PPUSH
19591: CALL 22231 0 1
// end ;
19595: GO 19530
// RemoveUnit ( ArScout2 ) ;
19597: LD_EXP 78
19601: PPUSH
19602: CALL_OW 64
// end ;
19606: LD_VAR 0 1
19610: RET
// export function f_arcar3_in ; begin
19611: LD_INT 0
19613: PPUSH
// while not IsInArea ( ArScout3 , exit_area ) do
19614: LD_EXP 79
19618: PPUSH
19619: LD_INT 1
19621: PPUSH
19622: CALL_OW 308
19626: NOT
19627: IFFALSE 19681
// begin if IsIdle ( arscout3 ) then
19629: LD_EXP 79
19633: PPUSH
19634: CALL_OW 316
19638: IFFALSE 19670
// begin ComAgressiveMove ( ArScout3 , 127 , 135 ) ;
19640: LD_EXP 79
19644: PPUSH
19645: LD_INT 127
19647: PPUSH
19648: LD_INT 135
19650: PPUSH
19651: CALL_OW 114
// AddComAgressiveMove ( ArScout3 , 70 , 134 ) ;
19655: LD_EXP 79
19659: PPUSH
19660: LD_INT 70
19662: PPUSH
19663: LD_INT 134
19665: PPUSH
19666: CALL_OW 174
// end ; DU_wait ( ArScout3 ) ;
19670: LD_EXP 79
19674: PPUSH
19675: CALL 22231 0 1
// end ;
19679: GO 19614
// RemoveUnit ( ArScout3 ) ;
19681: LD_EXP 79
19685: PPUSH
19686: CALL_OW 64
// end ;
19690: LD_VAR 0 1
19694: RET
// export function f_arcar1_exit ; begin
19695: LD_INT 0
19697: PPUSH
// while not IsInArea ( ArScout1 , ar_in_area ) do
19698: LD_EXP 77
19702: PPUSH
19703: LD_INT 2
19705: PPUSH
19706: CALL_OW 308
19710: NOT
19711: IFFALSE 19765
// begin if IsIdle ( arscout1 ) then
19713: LD_EXP 77
19717: PPUSH
19718: CALL_OW 316
19722: IFFALSE 19754
// begin ComAgressiveMove ( ArScout1 , 127 , 135 ) ;
19724: LD_EXP 77
19728: PPUSH
19729: LD_INT 127
19731: PPUSH
19732: LD_INT 135
19734: PPUSH
19735: CALL_OW 114
// AddComAgressiveMove ( ArScout1 , 185 , 134 ) ;
19739: LD_EXP 77
19743: PPUSH
19744: LD_INT 185
19746: PPUSH
19747: LD_INT 134
19749: PPUSH
19750: CALL_OW 174
// end ; DU_wait ( ArScout1 ) ;
19754: LD_EXP 77
19758: PPUSH
19759: CALL 22231 0 1
// end ;
19763: GO 19698
// RemoveUnit ( ArScout1 ) ;
19765: LD_EXP 77
19769: PPUSH
19770: CALL_OW 64
// end ;
19774: LD_VAR 0 1
19778: RET
// export function f_arcar2_exit ; begin
19779: LD_INT 0
19781: PPUSH
// while not IsInArea ( ArScout2 , ar_in_area ) do
19782: LD_EXP 78
19786: PPUSH
19787: LD_INT 2
19789: PPUSH
19790: CALL_OW 308
19794: NOT
19795: IFFALSE 19849
// begin if IsIdle ( arscout2 ) then
19797: LD_EXP 78
19801: PPUSH
19802: CALL_OW 316
19806: IFFALSE 19838
// begin ComAgressiveMove ( ArScout2 , 127 , 135 ) ;
19808: LD_EXP 78
19812: PPUSH
19813: LD_INT 127
19815: PPUSH
19816: LD_INT 135
19818: PPUSH
19819: CALL_OW 114
// AddComAgressiveMove ( ArScout2 , 185 , 134 ) ;
19823: LD_EXP 78
19827: PPUSH
19828: LD_INT 185
19830: PPUSH
19831: LD_INT 134
19833: PPUSH
19834: CALL_OW 174
// end ; DU_wait ( ArScout2 ) ;
19838: LD_EXP 78
19842: PPUSH
19843: CALL 22231 0 1
// end ;
19847: GO 19782
// RemoveUnit ( ArScout2 ) ;
19849: LD_EXP 78
19853: PPUSH
19854: CALL_OW 64
// end ;
19858: LD_VAR 0 1
19862: RET
// export function f_arcar3_exit ; begin
19863: LD_INT 0
19865: PPUSH
// while not IsInArea ( ArScout3 , ar_in_area ) do
19866: LD_EXP 79
19870: PPUSH
19871: LD_INT 2
19873: PPUSH
19874: CALL_OW 308
19878: NOT
19879: IFFALSE 19933
// begin if IsIdle ( arscout3 ) then
19881: LD_EXP 79
19885: PPUSH
19886: CALL_OW 316
19890: IFFALSE 19922
// begin ComAgressiveMove ( ArScout3 , 127 , 135 ) ;
19892: LD_EXP 79
19896: PPUSH
19897: LD_INT 127
19899: PPUSH
19900: LD_INT 135
19902: PPUSH
19903: CALL_OW 114
// AddComAgressiveMove ( ArScout3 , 185 , 134 ) ;
19907: LD_EXP 79
19911: PPUSH
19912: LD_INT 185
19914: PPUSH
19915: LD_INT 134
19917: PPUSH
19918: CALL_OW 174
// end ; DU_wait ( ArScout3 ) ;
19922: LD_EXP 79
19926: PPUSH
19927: CALL 22231 0 1
// end ;
19931: GO 19866
// RemoveUnit ( ArScout3 ) ;
19933: LD_EXP 79
19937: PPUSH
19938: CALL_OW 64
// end ;
19942: LD_VAR 0 1
19946: RET
// export ArScout1 , ArScout2 , ArScout3 , ArSc1 , ArSc2 , ArSc3 ; export function create_arabs_scout ; begin
19947: LD_INT 0
19949: PPUSH
// InitUc ;
19950: CALL_OW 18
// InitVc ;
19954: CALL_OW 20
// uc_side := arabians ;
19958: LD_ADDR_OWVAR 20
19962: PUSH
19963: LD_EXP 3
19967: ST_TO_ADDR
// uc_nation := nation_arabian ;
19968: LD_ADDR_OWVAR 21
19972: PUSH
19973: LD_INT 2
19975: ST_TO_ADDR
// uc_direction := 4 ;
19976: LD_ADDR_OWVAR 24
19980: PUSH
19981: LD_INT 4
19983: ST_TO_ADDR
// vc_control := control_manual ;
19984: LD_ADDR_OWVAR 38
19988: PUSH
19989: LD_INT 1
19991: ST_TO_ADDR
// vc_engine := engine_combustion ;
19992: LD_ADDR_OWVAR 39
19996: PUSH
19997: LD_INT 1
19999: ST_TO_ADDR
// vc_fuel_battery := 100 ;
20000: LD_ADDR_OWVAR 41
20004: PUSH
20005: LD_INT 100
20007: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
20008: LD_ADDR_OWVAR 37
20012: PUSH
20013: LD_INT 14
20015: ST_TO_ADDR
// vc_weapon := ar_flame_thrower ;
20016: LD_ADDR_OWVAR 40
20020: PUSH
20021: LD_INT 26
20023: ST_TO_ADDR
// if not ArScout1 or IsDead ( ArScout1 ) then
20024: LD_EXP 77
20028: NOT
20029: PUSH
20030: LD_EXP 77
20034: PPUSH
20035: CALL_OW 301
20039: OR
20040: IFFALSE 20052
// ArScout1 := CreateVehicle ;
20042: LD_ADDR_EXP 77
20046: PUSH
20047: CALL_OW 45
20051: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
20052: LD_ADDR_OWVAR 37
20056: PUSH
20057: LD_INT 14
20059: ST_TO_ADDR
// vc_weapon := ar_gatling_gun ;
20060: LD_ADDR_OWVAR 40
20064: PUSH
20065: LD_INT 25
20067: ST_TO_ADDR
// if not ArScout2 or IsDead ( ArScout2 ) then
20068: LD_EXP 78
20072: NOT
20073: PUSH
20074: LD_EXP 78
20078: PPUSH
20079: CALL_OW 301
20083: OR
20084: IFFALSE 20096
// ArScout2 := CreateVehicle ;
20086: LD_ADDR_EXP 78
20090: PUSH
20091: CALL_OW 45
20095: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
20096: LD_ADDR_OWVAR 37
20100: PUSH
20101: LD_INT 14
20103: ST_TO_ADDR
// vc_weapon := ar_gatling_gun ;
20104: LD_ADDR_OWVAR 40
20108: PUSH
20109: LD_INT 25
20111: ST_TO_ADDR
// if not ArScout3 or IsDead ( ArScout3 ) then
20112: LD_EXP 79
20116: NOT
20117: PUSH
20118: LD_EXP 79
20122: PPUSH
20123: CALL_OW 301
20127: OR
20128: IFFALSE 20140
// ArScout3 := CreateVehicle ;
20130: LD_ADDR_EXP 79
20134: PUSH
20135: CALL_OW 45
20139: ST_TO_ADDR
// InitHc ;
20140: CALL_OW 19
// PrepareMechanic ( 0 , 5 ) ;
20144: LD_INT 0
20146: PPUSH
20147: LD_INT 5
20149: PPUSH
20150: CALL_OW 383
// if not ArSc1 or IsDead ( ArSc1 ) then
20154: LD_EXP 80
20158: NOT
20159: PUSH
20160: LD_EXP 80
20164: PPUSH
20165: CALL_OW 301
20169: OR
20170: IFFALSE 20182
// ArSc1 := CreateHuman ;
20172: LD_ADDR_EXP 80
20176: PUSH
20177: CALL_OW 44
20181: ST_TO_ADDR
// if not ArSc2 or IsDead ( ArSc2 ) then
20182: LD_EXP 81
20186: NOT
20187: PUSH
20188: LD_EXP 81
20192: PPUSH
20193: CALL_OW 301
20197: OR
20198: IFFALSE 20210
// ArSc2 := CreateHuman ;
20200: LD_ADDR_EXP 81
20204: PUSH
20205: CALL_OW 44
20209: ST_TO_ADDR
// if not ArSc3 or IsDead ( ArSc3 ) then
20210: LD_EXP 82
20214: NOT
20215: PUSH
20216: LD_EXP 82
20220: PPUSH
20221: CALL_OW 301
20225: OR
20226: IFFALSE 20238
// ArSc3 := CreateHuman ;
20228: LD_ADDR_EXP 82
20232: PUSH
20233: CALL_OW 44
20237: ST_TO_ADDR
// PlaceHumanInUnit ( ArSc1 , ArScout1 ) ;
20238: LD_EXP 80
20242: PPUSH
20243: LD_EXP 77
20247: PPUSH
20248: CALL_OW 52
// PlaceHumanInUnit ( ArSc2 , ArScout2 ) ;
20252: LD_EXP 81
20256: PPUSH
20257: LD_EXP 78
20261: PPUSH
20262: CALL_OW 52
// PlaceHumanInUnit ( ArSc3 , ArScout3 ) ;
20266: LD_EXP 82
20270: PPUSH
20271: LD_EXP 79
20275: PPUSH
20276: CALL_OW 52
// end ; end_of_file
20280: LD_VAR 0 1
20284: RET
// on UnitDestroyed ( un ) do begin if un = Stevens then
20285: LD_VAR 0 1
20289: PUSH
20290: LD_EXP 60
20294: EQUAL
20295: IFFALSE 20316
// begin SA_KillStevens ;
20297: CALL 25926 0 0
// if not Stevens_killed then
20301: LD_EXP 11
20305: NOT
20306: IFFALSE 20316
// Stevens_killed := true ;
20308: LD_ADDR_EXP 11
20312: PUSH
20313: LD_INT 1
20315: ST_TO_ADDR
// end ; if un in rulive then
20316: LD_VAR 0 1
20320: PUSH
20321: LD_EXP 6
20325: IN
20326: IFFALSE 20344
// rulive := rulive diff un ;
20328: LD_ADDR_EXP 6
20332: PUSH
20333: LD_EXP 6
20337: PUSH
20338: LD_VAR 0 1
20342: DIFF
20343: ST_TO_ADDR
// if un in apemans then
20344: LD_VAR 0 1
20348: PUSH
20349: LD_EXP 7
20353: IN
20354: IFFALSE 20372
// apemans := apemans diff un ;
20356: LD_ADDR_EXP 7
20360: PUSH
20361: LD_EXP 7
20365: PUSH
20366: LD_VAR 0 1
20370: DIFF
20371: ST_TO_ADDR
// if un = Burlak then
20372: LD_VAR 0 1
20376: PUSH
20377: LD_EXP 51
20381: EQUAL
20382: IFFALSE 20397
// if canlost then
20384: LD_EXP 47
20388: IFFALSE 20397
// YouLost ( Burlak ) ;
20390: LD_STRING Burlak
20392: PPUSH
20393: CALL_OW 104
// if un = depot then
20397: LD_VAR 0 1
20401: PUSH
20402: LD_EXP 14
20406: EQUAL
20407: IFFALSE 20417
// depot := 0 ;
20409: LD_ADDR_EXP 14
20413: PUSH
20414: LD_INT 0
20416: ST_TO_ADDR
// defence := defence diff un ;
20417: LD_ADDR_EXP 28
20421: PUSH
20422: LD_EXP 28
20426: PUSH
20427: LD_VAR 0 1
20431: DIFF
20432: ST_TO_ADDR
// cargo := cargo diff un ;
20433: LD_ADDR_EXP 25
20437: PUSH
20438: LD_EXP 25
20442: PUSH
20443: LD_VAR 0 1
20447: DIFF
20448: ST_TO_ADDR
// attack := attack diff un ;
20449: LD_ADDR_EXP 27
20453: PUSH
20454: LD_EXP 27
20458: PUSH
20459: LD_VAR 0 1
20463: DIFF
20464: ST_TO_ADDR
// scout := scout diff un ;
20465: LD_ADDR_EXP 26
20469: PUSH
20470: LD_EXP 26
20474: PUSH
20475: LD_VAR 0 1
20479: DIFF
20480: ST_TO_ADDR
// remote := remote diff un ;
20481: LD_ADDR_EXP 29
20485: PUSH
20486: LD_EXP 29
20490: PUSH
20491: LD_VAR 0 1
20495: DIFF
20496: ST_TO_ADDR
// brk_cars := brk_cars diff un ;
20497: LD_ADDR_EXP 75
20501: PUSH
20502: LD_EXP 75
20506: PUSH
20507: LD_VAR 0 1
20511: DIFF
20512: ST_TO_ADDR
// rep_cars := rep_cars diff un ;
20513: LD_ADDR_EXP 76
20517: PUSH
20518: LD_EXP 76
20522: PUSH
20523: LD_VAR 0 1
20527: DIFF
20528: ST_TO_ADDR
// opravit := opravit diff un ;
20529: LD_ADDR_EXP 74
20533: PUSH
20534: LD_EXP 74
20538: PUSH
20539: LD_VAR 0 1
20543: DIFF
20544: ST_TO_ADDR
// sol := sol diff un ;
20545: LD_ADDR_EXP 19
20549: PUSH
20550: LD_EXP 19
20554: PUSH
20555: LD_VAR 0 1
20559: DIFF
20560: ST_TO_ADDR
// eng := eng diff un ;
20561: LD_ADDR_EXP 23
20565: PUSH
20566: LD_EXP 23
20570: PUSH
20571: LD_VAR 0 1
20575: DIFF
20576: ST_TO_ADDR
// mec := mec diff un ;
20577: LD_ADDR_EXP 22
20581: PUSH
20582: LD_EXP 22
20586: PUSH
20587: LD_VAR 0 1
20591: DIFF
20592: ST_TO_ADDR
// sci := sci diff un ;
20593: LD_ADDR_EXP 21
20597: PUSH
20598: LD_EXP 21
20602: PUSH
20603: LD_VAR 0 1
20607: DIFF
20608: ST_TO_ADDR
// mor := mor diff un ;
20609: LD_ADDR_EXP 20
20613: PUSH
20614: LD_EXP 20
20618: PUSH
20619: LD_VAR 0 1
20623: DIFF
20624: ST_TO_ADDR
// case un of dep1 :
20625: LD_VAR 0 1
20629: PUSH
20630: LD_EXP 41
20634: DOUBLE
20635: EQUAL
20636: IFTRUE 20640
20638: GO 20651
20640: POP
// dep1 := 0 ; lab1 :
20641: LD_ADDR_EXP 41
20645: PUSH
20646: LD_INT 0
20648: ST_TO_ADDR
20649: GO 20694
20651: LD_EXP 42
20655: DOUBLE
20656: EQUAL
20657: IFTRUE 20661
20659: GO 20672
20661: POP
// lab1 := 0 ; fact1 :
20662: LD_ADDR_EXP 42
20666: PUSH
20667: LD_INT 0
20669: ST_TO_ADDR
20670: GO 20694
20672: LD_EXP 40
20676: DOUBLE
20677: EQUAL
20678: IFTRUE 20682
20680: GO 20693
20682: POP
// fact1 := 0 ; end ;
20683: LD_ADDR_EXP 40
20687: PUSH
20688: LD_INT 0
20690: ST_TO_ADDR
20691: GO 20694
20693: POP
// fort := fort diff un ;
20694: LD_ADDR_EXP 43
20698: PUSH
20699: LD_EXP 43
20703: PUSH
20704: LD_VAR 0 1
20708: DIFF
20709: ST_TO_ADDR
// end ;
20710: PPOPN 1
20712: END
// on ApemanTamed ( ape , sci ) do begin MyHint ( ApemenUsing ) ;
20713: LD_STRING ApemenUsing
20715: PPUSH
20716: CALL 25694 0 1
// apemans := apemans diff ape ;
20720: LD_ADDR_EXP 7
20724: PUSH
20725: LD_EXP 7
20729: PUSH
20730: LD_VAR 0 1
20734: DIFF
20735: ST_TO_ADDR
// if not first_apeman_tamed then
20736: LD_EXP 45
20740: NOT
20741: IFFALSE 20747
// DApeTame ;
20743: CALL 4738 0 0
// end ;
20747: PPOPN 2
20749: END
// on ResearchComplete ( tech , lab ) do begin if GetSide ( lab ) = you then
20750: LD_VAR 0 2
20754: PPUSH
20755: CALL_OW 255
20759: PUSH
20760: LD_EXP 1
20764: EQUAL
20765: IFFALSE 20834
// begin if tech = tech_ApeLang then
20767: LD_VAR 0 1
20771: PUSH
20772: LD_INT 1
20774: EQUAL
20775: IFFALSE 20794
// begin MyHint ( ApemenTaming ) ;
20777: LD_STRING ApemenTaming
20779: PPUSH
20780: CALL 25694 0 1
// if dialogy then
20784: LD_EXP 46
20788: IFFALSE 20794
// DApeLangCompl ;
20790: CALL 4573 0 0
// end ; if tech = tech_ApePsych then
20794: LD_VAR 0 1
20798: PUSH
20799: LD_INT 2
20801: EQUAL
20802: IFFALSE 20814
// begin if dialogy then
20804: LD_EXP 46
20808: IFFALSE 20814
// DApeWorkCompl ;
20810: CALL 5132 0 0
// end ; if tech = tech_ApeAgres then
20814: LD_VAR 0 1
20818: PUSH
20819: LD_INT 11
20821: EQUAL
20822: IFFALSE 20834
// begin if dialogy then
20824: LD_EXP 46
20828: IFFALSE 20834
// DApeSolCompl ;
20830: CALL 5240 0 0
// end ; end ; end ;
20834: PPOPN 2
20836: END
// on BuildingComplete ( build ) do begin if GetSide ( build ) = you then
20837: LD_VAR 0 1
20841: PPUSH
20842: CALL_OW 255
20846: PUSH
20847: LD_EXP 1
20851: EQUAL
20852: IFFALSE 20888
// begin if not depot and GetBType ( build ) = b_depot then
20854: LD_EXP 14
20858: NOT
20859: PUSH
20860: LD_VAR 0 1
20864: PPUSH
20865: CALL_OW 266
20869: PUSH
20870: LD_INT 0
20872: EQUAL
20873: AND
20874: IFFALSE 20886
// depot := build ;
20876: LD_ADDR_EXP 14
20880: PUSH
20881: LD_VAR 0 1
20885: ST_TO_ADDR
// end else
20886: GO 21049
// begin if GetBType ( build ) in [ b_depot , b_warehouse ] then
20888: LD_VAR 0 1
20892: PPUSH
20893: CALL_OW 266
20897: PUSH
20898: LD_INT 0
20900: PUSH
20901: LD_INT 1
20903: PUSH
20904: EMPTY
20905: LIST
20906: LIST
20907: IN
20908: IFFALSE 20924
// dep1 := build + 0 ;
20910: LD_ADDR_EXP 41
20914: PUSH
20915: LD_VAR 0 1
20919: PUSH
20920: LD_INT 0
20922: PLUS
20923: ST_TO_ADDR
// if GetBType ( build ) in [ b_workshop , b_factory ] then
20924: LD_VAR 0 1
20928: PPUSH
20929: CALL_OW 266
20933: PUSH
20934: LD_INT 2
20936: PUSH
20937: LD_INT 3
20939: PUSH
20940: EMPTY
20941: LIST
20942: LIST
20943: IN
20944: IFFALSE 20960
// fact1 := build + 0 ;
20946: LD_ADDR_EXP 40
20950: PUSH
20951: LD_VAR 0 1
20955: PUSH
20956: LD_INT 0
20958: PLUS
20959: ST_TO_ADDR
// if GetBType ( build ) in [ b_lab , b_lab_half , b_lab_full ] then
20960: LD_VAR 0 1
20964: PPUSH
20965: CALL_OW 266
20969: PUSH
20970: LD_INT 6
20972: PUSH
20973: LD_INT 7
20975: PUSH
20976: LD_INT 8
20978: PUSH
20979: EMPTY
20980: LIST
20981: LIST
20982: LIST
20983: IN
20984: IFFALSE 21000
// lab1 := build + 0 ;
20986: LD_ADDR_EXP 42
20990: PUSH
20991: LD_VAR 0 1
20995: PUSH
20996: LD_INT 0
20998: PLUS
20999: ST_TO_ADDR
// if GetBType ( build ) in [ b_breastwork , b_bunker , b_armoury , b_barracks ] then
21000: LD_VAR 0 1
21004: PPUSH
21005: CALL_OW 266
21009: PUSH
21010: LD_INT 31
21012: PUSH
21013: LD_INT 32
21015: PUSH
21016: LD_INT 4
21018: PUSH
21019: LD_INT 5
21021: PUSH
21022: EMPTY
21023: LIST
21024: LIST
21025: LIST
21026: LIST
21027: IN
21028: IFFALSE 21049
// fort := fort ^ [ build ] ;
21030: LD_ADDR_EXP 43
21034: PUSH
21035: LD_EXP 43
21039: PUSH
21040: LD_VAR 0 1
21044: PUSH
21045: EMPTY
21046: LIST
21047: ADD
21048: ST_TO_ADDR
// end ; end ;
21049: PPOPN 1
21051: END
// on UpgradeComplete ( build ) do var ar , i ;
21052: LD_INT 0
21054: PPUSH
21055: PPUSH
// begin if GetSide ( build ) = arabians then
21056: LD_VAR 0 1
21060: PPUSH
21061: CALL_OW 255
21065: PUSH
21066: LD_EXP 3
21070: EQUAL
21071: IFFALSE 21209
// begin if GetBType ( build ) = b_barracks then
21073: LD_VAR 0 1
21077: PPUSH
21078: CALL_OW 266
21082: PUSH
21083: LD_INT 5
21085: EQUAL
21086: IFFALSE 21209
// begin sol := sol diff ar ;
21088: LD_ADDR_EXP 19
21092: PUSH
21093: LD_EXP 19
21097: PUSH
21098: LD_VAR 0 2
21102: DIFF
21103: ST_TO_ADDR
// mor := mor diff ar ;
21104: LD_ADDR_EXP 20
21108: PUSH
21109: LD_EXP 20
21113: PUSH
21114: LD_VAR 0 2
21118: DIFF
21119: ST_TO_ADDR
// for i in fort do
21120: LD_ADDR_VAR 0 3
21124: PUSH
21125: LD_EXP 43
21129: PUSH
21130: FOR_IN
21131: IFFALSE 21156
// ar := ar ^ UnitsInside ( i ) ;
21133: LD_ADDR_VAR 0 2
21137: PUSH
21138: LD_VAR 0 2
21142: PUSH
21143: LD_VAR 0 3
21147: PPUSH
21148: CALL_OW 313
21152: ADD
21153: ST_TO_ADDR
21154: GO 21130
21156: POP
21157: POP
// ComEnterUnit ( ar , build ) ;
21158: LD_VAR 0 2
21162: PPUSH
21163: LD_VAR 0 1
21167: PPUSH
21168: CALL_OW 120
// AddComChangeProfession ( ar , class_mortar ) ;
21172: LD_VAR 0 2
21176: PPUSH
21177: LD_INT 8
21179: PPUSH
21180: CALL_OW 183
// AddComExitBuilding ( ar ) ;
21184: LD_VAR 0 2
21188: PPUSH
21189: CALL_OW 182
// sol := sol union ar ;
21193: LD_ADDR_EXP 19
21197: PUSH
21198: LD_EXP 19
21202: PUSH
21203: LD_VAR 0 2
21207: UNION
21208: ST_TO_ADDR
// end ; end ; if Getside ( build ) = you then
21209: LD_VAR 0 1
21213: PPUSH
21214: CALL_OW 255
21218: PUSH
21219: LD_EXP 1
21223: EQUAL
21224: IFFALSE 21248
// begin if GetBType ( build ) = b_factory then
21226: LD_VAR 0 1
21230: PPUSH
21231: CALL_OW 266
21235: PUSH
21236: LD_INT 3
21238: EQUAL
21239: IFFALSE 21248
// begin MyHint ( Tracks ) ;
21241: LD_STRING Tracks
21243: PPUSH
21244: CALL 25694 0 1
// end ; end ; end ;
21248: PPOPN 3
21250: END
// on VehicleCaptured ( vehnew , vehold , origside , hum ) do begin if origside = arabians then
21251: LD_VAR 0 3
21255: PUSH
21256: LD_EXP 3
21260: EQUAL
21261: IFFALSE 21375
// begin defence := defence diff vehold ;
21263: LD_ADDR_EXP 28
21267: PUSH
21268: LD_EXP 28
21272: PUSH
21273: LD_VAR 0 2
21277: DIFF
21278: ST_TO_ADDR
// cargo := cargo diff vehold ;
21279: LD_ADDR_EXP 25
21283: PUSH
21284: LD_EXP 25
21288: PUSH
21289: LD_VAR 0 2
21293: DIFF
21294: ST_TO_ADDR
// attack := attack diff vehold ;
21295: LD_ADDR_EXP 27
21299: PUSH
21300: LD_EXP 27
21304: PUSH
21305: LD_VAR 0 2
21309: DIFF
21310: ST_TO_ADDR
// scout := scout diff vehold ;
21311: LD_ADDR_EXP 26
21315: PUSH
21316: LD_EXP 26
21320: PUSH
21321: LD_VAR 0 2
21325: DIFF
21326: ST_TO_ADDR
// remote := remote diff vehold ;
21327: LD_ADDR_EXP 29
21331: PUSH
21332: LD_EXP 29
21336: PUSH
21337: LD_VAR 0 2
21341: DIFF
21342: ST_TO_ADDR
// brk_cars := brk_cars diff vehold ;
21343: LD_ADDR_EXP 75
21347: PUSH
21348: LD_EXP 75
21352: PUSH
21353: LD_VAR 0 2
21357: DIFF
21358: ST_TO_ADDR
// rep_cars := rep_cars diff vehold ;
21359: LD_ADDR_EXP 76
21363: PUSH
21364: LD_EXP 76
21368: PUSH
21369: LD_VAR 0 2
21373: DIFF
21374: ST_TO_ADDR
// end ; end ;
21375: PPOPN 4
21377: END
// on BuildingCaptured ( build , origside , eng ) do begin opravit := opravit diff build ;
21378: LD_ADDR_EXP 74
21382: PUSH
21383: LD_EXP 74
21387: PUSH
21388: LD_VAR 0 1
21392: DIFF
21393: ST_TO_ADDR
// case build of dep1 :
21394: LD_VAR 0 1
21398: PUSH
21399: LD_EXP 41
21403: DOUBLE
21404: EQUAL
21405: IFTRUE 21409
21407: GO 21420
21409: POP
// dep1 := 0 ; lab1 :
21410: LD_ADDR_EXP 41
21414: PUSH
21415: LD_INT 0
21417: ST_TO_ADDR
21418: GO 21463
21420: LD_EXP 42
21424: DOUBLE
21425: EQUAL
21426: IFTRUE 21430
21428: GO 21441
21430: POP
// lab1 := 0 ; fact1 :
21431: LD_ADDR_EXP 42
21435: PUSH
21436: LD_INT 0
21438: ST_TO_ADDR
21439: GO 21463
21441: LD_EXP 40
21445: DOUBLE
21446: EQUAL
21447: IFTRUE 21451
21449: GO 21462
21451: POP
// fact1 := 0 ; end ;
21452: LD_ADDR_EXP 40
21456: PUSH
21457: LD_INT 0
21459: ST_TO_ADDR
21460: GO 21463
21462: POP
// fort := fort diff build ;
21463: LD_ADDR_EXP 43
21467: PUSH
21468: LD_EXP 43
21472: PUSH
21473: LD_VAR 0 1
21477: DIFF
21478: ST_TO_ADDR
// end ;
21479: PPOPN 3
21481: END
// on VehicleConstructed ( veh , fact ) do var i , sc , a , mt ;
21482: LD_INT 0
21484: PPUSH
21485: PPUSH
21486: PPUSH
21487: PPUSH
// begin if GetSide ( fact ) = arabians then
21488: LD_VAR 0 2
21492: PPUSH
21493: CALL_OW 255
21497: PUSH
21498: LD_EXP 3
21502: EQUAL
21503: IFFALSE 21906
// begin if to_defence then
21505: LD_EXP 30
21509: IFFALSE 21527
// begin defence := defence union veh ;
21511: LD_ADDR_EXP 28
21515: PUSH
21516: LD_EXP 28
21520: PUSH
21521: LD_VAR 0 1
21525: UNION
21526: ST_TO_ADDR
// end ; if to_remote then
21527: LD_EXP 34
21531: IFFALSE 21549
// begin remote := remote union veh ;
21533: LD_ADDR_EXP 29
21537: PUSH
21538: LD_EXP 29
21542: PUSH
21543: LD_VAR 0 1
21547: UNION
21548: ST_TO_ADDR
// end ; if to_cargo then
21549: LD_EXP 33
21553: IFFALSE 21571
// begin cargo := cargo union veh ;
21555: LD_ADDR_EXP 25
21559: PUSH
21560: LD_EXP 25
21564: PUSH
21565: LD_VAR 0 1
21569: UNION
21570: ST_TO_ADDR
// end ; if to_attack then
21571: LD_EXP 31
21575: IFFALSE 21593
// begin attack := attack union veh ;
21577: LD_ADDR_EXP 27
21581: PUSH
21582: LD_EXP 27
21586: PUSH
21587: LD_VAR 0 1
21591: UNION
21592: ST_TO_ADDR
// end ; if to_scout then
21593: LD_EXP 32
21597: IFFALSE 21615
// begin scout := scout union veh ;
21599: LD_ADDR_EXP 26
21603: PUSH
21604: LD_EXP 26
21608: PUSH
21609: LD_VAR 0 1
21613: UNION
21614: ST_TO_ADDR
// end ; to_remote := false ;
21615: LD_ADDR_EXP 34
21619: PUSH
21620: LD_INT 0
21622: ST_TO_ADDR
// to_cargo := false ;
21623: LD_ADDR_EXP 33
21627: PUSH
21628: LD_INT 0
21630: ST_TO_ADDR
// to_scout := false ;
21631: LD_ADDR_EXP 32
21635: PUSH
21636: LD_INT 0
21638: ST_TO_ADDR
// to_attack := false ;
21639: LD_ADDR_EXP 31
21643: PUSH
21644: LD_INT 0
21646: ST_TO_ADDR
// to_defence := false ;
21647: LD_ADDR_EXP 30
21651: PUSH
21652: LD_INT 0
21654: ST_TO_ADDR
// if GetControl ( veh ) = control_remote then
21655: LD_VAR 0 1
21659: PPUSH
21660: CALL_OW 263
21664: PUSH
21665: LD_INT 2
21667: EQUAL
21668: IFFALSE 21684
// ComLinkTo ( veh , rmec ) ;
21670: LD_VAR 0 1
21674: PPUSH
21675: LD_EXP 24
21679: PPUSH
21680: CALL_OW 135
// mt := tick + 0 0$7 ;
21684: LD_ADDR_VAR 0 6
21688: PUSH
21689: LD_OWVAR 1
21693: PUSH
21694: LD_INT 245
21696: PLUS
21697: ST_TO_ADDR
// if veh in defence then
21698: LD_VAR 0 1
21702: PUSH
21703: LD_EXP 28
21707: IN
21708: IFFALSE 21760
// begin ComMoveToArea ( veh , for_cars_defence ) ;
21710: LD_VAR 0 1
21714: PPUSH
21715: LD_INT 17
21717: PPUSH
21718: CALL_OW 113
// while not IsInArea ( veh , for_cars_defence ) and mt > tick do
21722: LD_VAR 0 1
21726: PPUSH
21727: LD_INT 17
21729: PPUSH
21730: CALL_OW 308
21734: NOT
21735: PUSH
21736: LD_VAR 0 6
21740: PUSH
21741: LD_OWVAR 1
21745: GREATER
21746: AND
21747: IFFALSE 21758
// wait ( 0 0$1 ) ;
21749: LD_INT 35
21751: PPUSH
21752: CALL_OW 67
21756: GO 21722
// end else
21758: GO 21808
// begin ComMoveToArea ( veh , for_cars ) ;
21760: LD_VAR 0 1
21764: PPUSH
21765: LD_INT 14
21767: PPUSH
21768: CALL_OW 113
// while not IsInArea ( veh , for_cars ) and mt > tick do
21772: LD_VAR 0 1
21776: PPUSH
21777: LD_INT 14
21779: PPUSH
21780: CALL_OW 308
21784: NOT
21785: PUSH
21786: LD_VAR 0 6
21790: PUSH
21791: LD_OWVAR 1
21795: GREATER
21796: AND
21797: IFFALSE 21808
// wait ( 0 0$1 ) ;
21799: LD_INT 35
21801: PPUSH
21802: CALL_OW 67
21806: GO 21772
// end ; a := UnitsInside ( veh ) ;
21808: LD_ADDR_VAR 0 5
21812: PUSH
21813: LD_VAR 0 1
21817: PPUSH
21818: CALL_OW 313
21822: ST_TO_ADDR
// ComRemember ( veh ) ;
21823: LD_VAR 0 1
21827: PPUSH
21828: CALL_OW 143
// ComExitVehicle ( a ) ;
21832: LD_VAR 0 5
21836: PPUSH
21837: CALL_OW 121
// AddComEnterUnit ( a , fact1 ) ;
21841: LD_VAR 0 5
21845: PPUSH
21846: LD_EXP 40
21850: PPUSH
21851: CALL_OW 180
// if GetWeapon ( veh ) <> ar_radar then
21855: LD_VAR 0 1
21859: PPUSH
21860: CALL_OW 264
21864: PUSH
21865: LD_INT 30
21867: NONEQUAL
21868: IFFALSE 21889
// find_drivers ( veh , sol , false ) else
21870: LD_VAR 0 1
21874: PPUSH
21875: LD_EXP 19
21879: PPUSH
21880: LD_INT 0
21882: PPUSH
21883: CALL 24202 0 3
21887: GO 21906
// find_drivers ( veh , mec , true ) ;
21889: LD_VAR 0 1
21893: PPUSH
21894: LD_EXP 22
21898: PPUSH
21899: LD_INT 1
21901: PPUSH
21902: CALL 24202 0 3
// end ; end ;
21906: PPOPN 6
21908: END
// on SailEvent ( num ) do begin case num of vodni_utok :
21909: LD_VAR 0 1
21913: PUSH
21914: LD_EXP 35
21918: DOUBLE
21919: EQUAL
21920: IFTRUE 21924
21922: GO 21931
21924: POP
// begin f_vodni_utok ;
21925: CALL 16107 0 0
// end ; normal1_utok :
21929: GO 22090
21931: LD_EXP 36
21935: DOUBLE
21936: EQUAL
21937: IFTRUE 21941
21939: GO 21948
21941: POP
// begin f_normal1_utok ;
21942: CALL 16497 0 0
// end ; normal2_utok :
21946: GO 22090
21948: LD_EXP 37
21952: DOUBLE
21953: EQUAL
21954: IFTRUE 21958
21956: GO 21965
21958: POP
// begin f_normal2_utok ;
21959: CALL 16733 0 0
// end ; normal3_utok :
21963: GO 22090
21965: LD_EXP 38
21969: DOUBLE
21970: EQUAL
21971: IFTRUE 21975
21973: GO 21982
21975: POP
// begin f_normal3_utok ;
21976: CALL 16969 0 0
// end ; normal4_utok :
21980: GO 22090
21982: LD_EXP 39
21986: DOUBLE
21987: EQUAL
21988: IFTRUE 21992
21990: GO 21999
21992: POP
// begin f_normal4_utok ;
21993: CALL 17326 0 0
// end ; 5001 :
21997: GO 22090
21999: LD_INT 5001
22001: DOUBLE
22002: EQUAL
22003: IFTRUE 22007
22005: GO 22014
22007: POP
// begin f_arcar1_in ;
22008: CALL 19443 0 0
// end ; 5002 :
22012: GO 22090
22014: LD_INT 5002
22016: DOUBLE
22017: EQUAL
22018: IFTRUE 22022
22020: GO 22029
22022: POP
// begin f_arcar2_in ;
22023: CALL 19527 0 0
// end ; 5003 :
22027: GO 22090
22029: LD_INT 5003
22031: DOUBLE
22032: EQUAL
22033: IFTRUE 22037
22035: GO 22044
22037: POP
// begin f_arcar3_in ;
22038: CALL 19611 0 0
// end ; 5051 :
22042: GO 22090
22044: LD_INT 5051
22046: DOUBLE
22047: EQUAL
22048: IFTRUE 22052
22050: GO 22059
22052: POP
// begin f_arcar1_exit ;
22053: CALL 19695 0 0
// end ; 5052 :
22057: GO 22090
22059: LD_INT 5052
22061: DOUBLE
22062: EQUAL
22063: IFTRUE 22067
22065: GO 22074
22067: POP
// begin f_arcar2_exit ;
22068: CALL 19779 0 0
// end ; 5053 :
22072: GO 22090
22074: LD_INT 5053
22076: DOUBLE
22077: EQUAL
22078: IFTRUE 22082
22080: GO 22089
22082: POP
// begin f_arcar3_exit ;
22083: CALL 19863 0 0
// end ; end ;
22087: GO 22090
22089: POP
// end ;
22090: PPOPN 1
22092: END
// export DU_units ; on DestinationUnreachable ( un ) do begin DU_units := DU_units union un ;
22093: LD_ADDR_EXP 83
22097: PUSH
22098: LD_EXP 83
22102: PUSH
22103: LD_VAR 0 1
22107: UNION
22108: ST_TO_ADDR
// SetTag ( un + 10000 , 2 ) ;
22109: LD_VAR 0 1
22113: PUSH
22114: LD_INT 10000
22116: PLUS
22117: PPUSH
22118: LD_INT 2
22120: PPUSH
22121: CALL_OW 109
// end ;
22125: PPOPN 1
22127: END
// every 0 0$2 trigger DU_units do var i , a ;
22128: LD_EXP 83
22132: IFFALSE 22228
22134: GO 22136
22136: DISABLE
22137: LD_INT 0
22139: PPUSH
22140: PPUSH
// begin for i in DU_units do
22141: LD_ADDR_VAR 0 1
22145: PUSH
22146: LD_EXP 83
22150: PUSH
22151: FOR_IN
22152: IFFALSE 22225
// begin a := GetTag ( i + 10000 ) ;
22154: LD_ADDR_VAR 0 2
22158: PUSH
22159: LD_VAR 0 1
22163: PUSH
22164: LD_INT 10000
22166: PLUS
22167: PPUSH
22168: CALL_OW 110
22172: ST_TO_ADDR
// if a = 0 then
22173: LD_VAR 0 2
22177: PUSH
22178: LD_INT 0
22180: EQUAL
22181: IFFALSE 22201
// DU_units := DU_units diff i else
22183: LD_ADDR_EXP 83
22187: PUSH
22188: LD_EXP 83
22192: PUSH
22193: LD_VAR 0 1
22197: DIFF
22198: ST_TO_ADDR
22199: GO 22223
// SetTag ( i + 10000 , a - 1 ) ;
22201: LD_VAR 0 1
22205: PUSH
22206: LD_INT 10000
22208: PLUS
22209: PPUSH
22210: LD_VAR 0 2
22214: PUSH
22215: LD_INT 1
22217: MINUS
22218: PPUSH
22219: CALL_OW 109
// end ;
22223: GO 22151
22225: POP
22226: POP
// enable ;
22227: ENABLE
// end ;
22228: PPOPN 2
22230: END
// export function DU_wait ( un ) ; begin
22231: LD_INT 0
22233: PPUSH
// wait ( 0 0$1 ) ;
22234: LD_INT 35
22236: PPUSH
22237: CALL_OW 67
// while un in DU_units do
22241: LD_VAR 0 1
22245: PUSH
22246: LD_EXP 83
22250: IN
22251: IFFALSE 22262
// wait ( 0 0$1 ) ;
22253: LD_INT 35
22255: PPUSH
22256: CALL_OW 67
22260: GO 22241
// end ; end_of_file
22262: LD_VAR 0 2
22266: RET
// var rDef1 , rDef2 ; var idDef1 , idDef2 ; export toDef1 , toDef2 ; every 0 0$1 do
22267: GO 22269
22269: DISABLE
// begin todef1 := fort ^ attack ^ defence ^ mor ^ sol ^ sci ^ mec ^ eng ;
22270: LD_ADDR_EXP 84
22274: PUSH
22275: LD_EXP 43
22279: PUSH
22280: LD_EXP 27
22284: ADD
22285: PUSH
22286: LD_EXP 28
22290: ADD
22291: PUSH
22292: LD_EXP 20
22296: ADD
22297: PUSH
22298: LD_EXP 19
22302: ADD
22303: PUSH
22304: LD_EXP 21
22308: ADD
22309: PUSH
22310: LD_EXP 22
22314: ADD
22315: PUSH
22316: LD_EXP 23
22320: ADD
22321: ST_TO_ADDR
// rDef1 := McRegistry ( arabians , [ [ mc_reg_refresh_time , 0 0$2 ] , [ mc_reg_area_to_guard , def_base ] , [ mc_reg_area_to_protect , def_base ] ] ) ;
22322: LD_ADDR_LOC 28
22326: PUSH
22327: LD_EXP 3
22331: PPUSH
22332: LD_INT 1
22334: PUSH
22335: LD_INT 70
22337: PUSH
22338: EMPTY
22339: LIST
22340: LIST
22341: PUSH
22342: LD_INT 2
22344: PUSH
22345: LD_INT 23
22347: PUSH
22348: EMPTY
22349: LIST
22350: LIST
22351: PUSH
22352: LD_INT 3
22354: PUSH
22355: LD_INT 23
22357: PUSH
22358: EMPTY
22359: LIST
22360: LIST
22361: PUSH
22362: EMPTY
22363: LIST
22364: LIST
22365: LIST
22366: PPUSH
22367: CALL_OW 399
22371: ST_TO_ADDR
// idDef1 := McDefend ( 10 , rDef1 , toDef1 , [ mc_def_advantage , mcdef_difficulty ] ) ;
22372: LD_ADDR_LOC 30
22376: PUSH
22377: LD_INT 10
22379: PPUSH
22380: LD_LOC 28
22384: PPUSH
22385: LD_EXP 84
22389: PPUSH
22390: LD_INT 1
22392: PUSH
22393: LD_EXP 13
22397: PUSH
22398: EMPTY
22399: LIST
22400: LIST
22401: PPUSH
22402: CALL_OW 401
22406: ST_TO_ADDR
// end ;
22407: END
// every 0 0$2 do
22408: GO 22410
22410: DISABLE
// begin todef1 := fort ^ attack ^ defence ^ mor ^ sol ;
22411: LD_ADDR_EXP 84
22415: PUSH
22416: LD_EXP 43
22420: PUSH
22421: LD_EXP 27
22425: ADD
22426: PUSH
22427: LD_EXP 28
22431: ADD
22432: PUSH
22433: LD_EXP 20
22437: ADD
22438: PUSH
22439: LD_EXP 19
22443: ADD
22444: ST_TO_ADDR
// AddMcUnits ( idDef1 , todef1 diff GetMcUnits ( idDef1 ) ) ;
22445: LD_LOC 30
22449: PPUSH
22450: LD_EXP 84
22454: PUSH
22455: LD_LOC 30
22459: PPUSH
22460: CALL_OW 389
22464: DIFF
22465: PPUSH
22466: CALL_OW 390
// RemoveMcUnits ( idDef1 , GetMcUnits ( idDef1 ) diff todef1 ) ;
22470: LD_LOC 30
22474: PPUSH
22475: LD_LOC 30
22479: PPUSH
22480: CALL_OW 389
22484: PUSH
22485: LD_EXP 84
22489: DIFF
22490: PPUSH
22491: CALL_OW 391
// enable ;
22495: ENABLE
// end ; end_of_file
22496: END
// var objevovani_zasilek ; var ar_objevovani_zasilek ; export crates ; every 0 0$0.1 do
22497: GO 22499
22499: DISABLE
// begin SetResourceVisibility ( 131 , 51 , arabians ) ;
22500: LD_INT 131
22502: PPUSH
22503: LD_INT 51
22505: PPUSH
22506: LD_EXP 3
22510: PPUSH
22511: CALL_OW 441
// case difficulty of 1 :
22515: LD_OWVAR 67
22519: PUSH
22520: LD_INT 1
22522: DOUBLE
22523: EQUAL
22524: IFTRUE 22528
22526: GO 22626
22528: POP
// objevovani_zasilek := [ 3 , 6 , 4 , 4 , 1 , 4 , 2 , 2 , 3 , 5 , 0 , 2 , 3 , 5 , 1 , 2 , 1 , 2 , 1 , 2 , 1 , 2 ] ; 2 :
22529: LD_ADDR_LOC 32
22533: PUSH
22534: LD_INT 3
22536: PUSH
22537: LD_INT 6
22539: PUSH
22540: LD_INT 4
22542: PUSH
22543: LD_INT 4
22545: PUSH
22546: LD_INT 1
22548: PUSH
22549: LD_INT 4
22551: PUSH
22552: LD_INT 2
22554: PUSH
22555: LD_INT 2
22557: PUSH
22558: LD_INT 3
22560: PUSH
22561: LD_INT 5
22563: PUSH
22564: LD_INT 0
22566: PUSH
22567: LD_INT 2
22569: PUSH
22570: LD_INT 3
22572: PUSH
22573: LD_INT 5
22575: PUSH
22576: LD_INT 1
22578: PUSH
22579: LD_INT 2
22581: PUSH
22582: LD_INT 1
22584: PUSH
22585: LD_INT 2
22587: PUSH
22588: LD_INT 1
22590: PUSH
22591: LD_INT 2
22593: PUSH
22594: LD_INT 1
22596: PUSH
22597: LD_INT 2
22599: PUSH
22600: EMPTY
22601: LIST
22602: LIST
22603: LIST
22604: LIST
22605: LIST
22606: LIST
22607: LIST
22608: LIST
22609: LIST
22610: LIST
22611: LIST
22612: LIST
22613: LIST
22614: LIST
22615: LIST
22616: LIST
22617: LIST
22618: LIST
22619: LIST
22620: LIST
22621: LIST
22622: LIST
22623: ST_TO_ADDR
22624: GO 22839
22626: LD_INT 2
22628: DOUBLE
22629: EQUAL
22630: IFTRUE 22634
22632: GO 22732
22634: POP
// objevovani_zasilek := [ 2 , 5 , 3 , 2 , 1 , 3 , 2 , 2 , 3 , 4 , 0 , 2 , 3 , 4 , 0 , 2 , 0 , 2 , 0 , 2 , 0 , 2 ] ; 3 :
22635: LD_ADDR_LOC 32
22639: PUSH
22640: LD_INT 2
22642: PUSH
22643: LD_INT 5
22645: PUSH
22646: LD_INT 3
22648: PUSH
22649: LD_INT 2
22651: PUSH
22652: LD_INT 1
22654: PUSH
22655: LD_INT 3
22657: PUSH
22658: LD_INT 2
22660: PUSH
22661: LD_INT 2
22663: PUSH
22664: LD_INT 3
22666: PUSH
22667: LD_INT 4
22669: PUSH
22670: LD_INT 0
22672: PUSH
22673: LD_INT 2
22675: PUSH
22676: LD_INT 3
22678: PUSH
22679: LD_INT 4
22681: PUSH
22682: LD_INT 0
22684: PUSH
22685: LD_INT 2
22687: PUSH
22688: LD_INT 0
22690: PUSH
22691: LD_INT 2
22693: PUSH
22694: LD_INT 0
22696: PUSH
22697: LD_INT 2
22699: PUSH
22700: LD_INT 0
22702: PUSH
22703: LD_INT 2
22705: PUSH
22706: EMPTY
22707: LIST
22708: LIST
22709: LIST
22710: LIST
22711: LIST
22712: LIST
22713: LIST
22714: LIST
22715: LIST
22716: LIST
22717: LIST
22718: LIST
22719: LIST
22720: LIST
22721: LIST
22722: LIST
22723: LIST
22724: LIST
22725: LIST
22726: LIST
22727: LIST
22728: LIST
22729: ST_TO_ADDR
22730: GO 22839
22732: LD_INT 3
22734: DOUBLE
22735: EQUAL
22736: IFTRUE 22740
22738: GO 22838
22740: POP
// objevovani_zasilek := [ 2 , 4 , 2 , 2 , 0 , 3 , 1 , 2 , 3 , 3 , 0 , 2 , 3 , 2 , 0 , 2 , 0 , 2 , 0 , 2 , 0 , 2 ] ; end ;
22741: LD_ADDR_LOC 32
22745: PUSH
22746: LD_INT 2
22748: PUSH
22749: LD_INT 4
22751: PUSH
22752: LD_INT 2
22754: PUSH
22755: LD_INT 2
22757: PUSH
22758: LD_INT 0
22760: PUSH
22761: LD_INT 3
22763: PUSH
22764: LD_INT 1
22766: PUSH
22767: LD_INT 2
22769: PUSH
22770: LD_INT 3
22772: PUSH
22773: LD_INT 3
22775: PUSH
22776: LD_INT 0
22778: PUSH
22779: LD_INT 2
22781: PUSH
22782: LD_INT 3
22784: PUSH
22785: LD_INT 2
22787: PUSH
22788: LD_INT 0
22790: PUSH
22791: LD_INT 2
22793: PUSH
22794: LD_INT 0
22796: PUSH
22797: LD_INT 2
22799: PUSH
22800: LD_INT 0
22802: PUSH
22803: LD_INT 2
22805: PUSH
22806: LD_INT 0
22808: PUSH
22809: LD_INT 2
22811: PUSH
22812: EMPTY
22813: LIST
22814: LIST
22815: LIST
22816: LIST
22817: LIST
22818: LIST
22819: LIST
22820: LIST
22821: LIST
22822: LIST
22823: LIST
22824: LIST
22825: LIST
22826: LIST
22827: LIST
22828: LIST
22829: LIST
22830: LIST
22831: LIST
22832: LIST
22833: LIST
22834: LIST
22835: ST_TO_ADDR
22836: GO 22839
22838: POP
// ar_objevovani_zasilek := [ 5 , 6 , 4 , 4 , 2 , 5 , 2 , 4 , 6 , 5 , 2 , 4 , 6 , 5 , 5 , 4 , 5 , 2 , 9 , 8 , 6 , 5 ] ;
22839: LD_ADDR_LOC 33
22843: PUSH
22844: LD_INT 5
22846: PUSH
22847: LD_INT 6
22849: PUSH
22850: LD_INT 4
22852: PUSH
22853: LD_INT 4
22855: PUSH
22856: LD_INT 2
22858: PUSH
22859: LD_INT 5
22861: PUSH
22862: LD_INT 2
22864: PUSH
22865: LD_INT 4
22867: PUSH
22868: LD_INT 6
22870: PUSH
22871: LD_INT 5
22873: PUSH
22874: LD_INT 2
22876: PUSH
22877: LD_INT 4
22879: PUSH
22880: LD_INT 6
22882: PUSH
22883: LD_INT 5
22885: PUSH
22886: LD_INT 5
22888: PUSH
22889: LD_INT 4
22891: PUSH
22892: LD_INT 5
22894: PUSH
22895: LD_INT 2
22897: PUSH
22898: LD_INT 9
22900: PUSH
22901: LD_INT 8
22903: PUSH
22904: LD_INT 6
22906: PUSH
22907: LD_INT 5
22909: PUSH
22910: EMPTY
22911: LIST
22912: LIST
22913: LIST
22914: LIST
22915: LIST
22916: LIST
22917: LIST
22918: LIST
22919: LIST
22920: LIST
22921: LIST
22922: LIST
22923: LIST
22924: LIST
22925: LIST
22926: LIST
22927: LIST
22928: LIST
22929: LIST
22930: LIST
22931: LIST
22932: LIST
22933: ST_TO_ADDR
// Randomize ;
22934: CALL_OW 10
// end ;
22938: END
// every 0 0$10 do
22939: GO 22941
22941: DISABLE
// begin Randomize ;
22942: CALL_OW 10
// enable ;
22946: ENABLE
// end ;
22947: END
// every 15 15$0 do
22948: GO 22950
22950: DISABLE
// begin CreateCratesArea ( 4 , other_crates , true ) ;
22951: LD_INT 4
22953: PPUSH
22954: LD_INT 27
22956: PPUSH
22957: LD_INT 1
22959: PPUSH
22960: CALL_OW 55
// end ;
22964: END
// every 23 23$0 do
22965: GO 22967
22967: DISABLE
// begin CreateCratesArea ( 5 , other_crates , true ) ;
22968: LD_INT 5
22970: PPUSH
22971: LD_INT 27
22973: PPUSH
22974: LD_INT 1
22976: PPUSH
22977: CALL_OW 55
// end ;
22981: END
// every 37 37$0 do
22982: GO 22984
22984: DISABLE
// begin CreateCratesArea ( 5 , other_crates , true ) ;
22985: LD_INT 5
22987: PPUSH
22988: LD_INT 27
22990: PPUSH
22991: LD_INT 1
22993: PPUSH
22994: CALL_OW 55
// end ;
22998: END
// every 47 47$0 do
22999: GO 23001
23001: DISABLE
// begin CreateCratesArea ( 5 , other_crates , true ) ;
23002: LD_INT 5
23004: PPUSH
23005: LD_INT 27
23007: PPUSH
23008: LD_INT 1
23010: PPUSH
23011: CALL_OW 55
// end ;
23015: END
// every 0 0$5 do var a , i ;
23016: GO 23018
23018: DISABLE
23019: LD_INT 0
23021: PPUSH
23022: PPUSH
// begin crates := [ ] ;
23023: LD_ADDR_EXP 86
23027: PUSH
23028: EMPTY
23029: ST_TO_ADDR
// a := GetListOfCratesInArea ( ar_crates_site ) ;
23030: LD_ADDR_VAR 0 1
23034: PUSH
23035: LD_INT 16
23037: PPUSH
23038: CALL_OW 435
23042: ST_TO_ADDR
// for i := 1 to ( a div 2 ) do
23043: LD_ADDR_VAR 0 2
23047: PUSH
23048: DOUBLE
23049: LD_INT 1
23051: DEC
23052: ST_TO_ADDR
23053: LD_VAR 0 1
23057: PUSH
23058: LD_INT 2
23060: DIV
23061: PUSH
23062: FOR_TO
23063: IFFALSE 23119
// crates := crates ^ [ [ a [ i * 2 - 1 ] , a [ i * 2 ] ] ] ;
23065: LD_ADDR_EXP 86
23069: PUSH
23070: LD_EXP 86
23074: PUSH
23075: LD_VAR 0 1
23079: PUSH
23080: LD_VAR 0 2
23084: PUSH
23085: LD_INT 2
23087: MUL
23088: PUSH
23089: LD_INT 1
23091: MINUS
23092: ARRAY
23093: PUSH
23094: LD_VAR 0 1
23098: PUSH
23099: LD_VAR 0 2
23103: PUSH
23104: LD_INT 2
23106: MUL
23107: ARRAY
23108: PUSH
23109: EMPTY
23110: LIST
23111: LIST
23112: PUSH
23113: EMPTY
23114: LIST
23115: ADD
23116: ST_TO_ADDR
23117: GO 23062
23119: POP
23120: POP
// enable ;
23121: ENABLE
// end ;
23122: PPOPN 2
23124: END
// every 0 0$1 do
23125: GO 23127
23127: DISABLE
// begin Wait ( Rand ( 3 , 7 ) * 0 0$1 ) ;
23128: LD_INT 3
23130: PPUSH
23131: LD_INT 7
23133: PPUSH
23134: CALL_OW 12
23138: PUSH
23139: LD_INT 35
23141: MUL
23142: PPUSH
23143: CALL_OW 67
// CreateCratesArea ( 2 , first_crate , true ) ;
23147: LD_INT 2
23149: PPUSH
23150: LD_INT 6
23152: PPUSH
23153: LD_INT 1
23155: PPUSH
23156: CALL_OW 55
// Wait ( Rand ( 3 , 7 ) * 0 0$1 ) ;
23160: LD_INT 3
23162: PPUSH
23163: LD_INT 7
23165: PPUSH
23166: CALL_OW 12
23170: PUSH
23171: LD_INT 35
23173: MUL
23174: PPUSH
23175: CALL_OW 67
// CreateCratesArea ( 2 , second_crate , true ) ;
23179: LD_INT 2
23181: PPUSH
23182: LD_INT 7
23184: PPUSH
23185: LD_INT 1
23187: PPUSH
23188: CALL_OW 55
// end ;
23192: END
// every 0 0$5 do
23193: GO 23195
23195: DISABLE
// begin objev ( objevovani_zasilek , crates_site ) ;
23196: LD_LOC 32
23200: PPUSH
23201: LD_INT 5
23203: PPUSH
23204: CALL 23259 0 2
// end ;
23208: END
// every 0 0$5 do
23209: GO 23211
23211: DISABLE
// begin objev ( ar_objevovani_zasilek , ar_crates_site ) ;
23212: LD_LOC 33
23216: PPUSH
23217: LD_INT 16
23219: PPUSH
23220: CALL 23259 0 2
// end ;
23224: END
// every 5 5$0 + 0 0$5 do
23225: GO 23227
23227: DISABLE
// begin objev ( objevovani_zasilek , crates_site ) ;
23228: LD_LOC 32
23232: PPUSH
23233: LD_INT 5
23235: PPUSH
23236: CALL 23259 0 2
// enable ;
23240: ENABLE
// end ;
23241: END
// every 5 5$0 + 0 0$5 do
23242: GO 23244
23244: DISABLE
// begin objev ( ar_objevovani_zasilek , ar_crates_site ) ;
23245: LD_LOC 33
23249: PPUSH
23250: LD_INT 16
23252: PPUSH
23253: CALL 23259 0 2
// enable ;
23257: ENABLE
// end ;
23258: END
// function objev ( zasilky , area ) ; var x , w , i , hex , cek , cek2 , last , min5 ; begin
23259: LD_INT 0
23261: PPUSH
23262: PPUSH
23263: PPUSH
23264: PPUSH
23265: PPUSH
23266: PPUSH
23267: PPUSH
23268: PPUSH
23269: PPUSH
// min5 := ( tick div 5 5$0 ) + 1 ;
23270: LD_ADDR_VAR 0 11
23274: PUSH
23275: LD_OWVAR 1
23279: PUSH
23280: LD_INT 10500
23282: DIV
23283: PUSH
23284: LD_INT 1
23286: PLUS
23287: ST_TO_ADDR
// cek := [ ] ;
23288: LD_ADDR_VAR 0 8
23292: PUSH
23293: EMPTY
23294: ST_TO_ADDR
// cek2 := [ ] ;
23295: LD_ADDR_VAR 0 9
23299: PUSH
23300: EMPTY
23301: ST_TO_ADDR
// last := 0 ;
23302: LD_ADDR_VAR 0 10
23306: PUSH
23307: LD_INT 0
23309: ST_TO_ADDR
// x := zasilky [ min5 ] ;
23310: LD_ADDR_VAR 0 4
23314: PUSH
23315: LD_VAR 0 1
23319: PUSH
23320: LD_VAR 0 11
23324: ARRAY
23325: ST_TO_ADDR
// for i := 1 to x do
23326: LD_ADDR_VAR 0 6
23330: PUSH
23331: DOUBLE
23332: LD_INT 1
23334: DEC
23335: ST_TO_ADDR
23336: LD_VAR 0 4
23340: PUSH
23341: FOR_TO
23342: IFFALSE 23368
// cek := cek ^ Rand ( 0 0$15 , 5 5$0 ) ;
23344: LD_ADDR_VAR 0 8
23348: PUSH
23349: LD_VAR 0 8
23353: PUSH
23354: LD_INT 525
23356: PPUSH
23357: LD_INT 10500
23359: PPUSH
23360: CALL_OW 12
23364: ADD
23365: ST_TO_ADDR
23366: GO 23341
23368: POP
23369: POP
// cek := SortListByListAsc ( cek , cek ) ;
23370: LD_ADDR_VAR 0 8
23374: PUSH
23375: LD_VAR 0 8
23379: PPUSH
23380: LD_VAR 0 8
23384: PPUSH
23385: CALL_OW 76
23389: ST_TO_ADDR
// for i in cek do
23390: LD_ADDR_VAR 0 6
23394: PUSH
23395: LD_VAR 0 8
23399: PUSH
23400: FOR_IN
23401: IFFALSE 23437
// begin cek2 := cek2 ^ i - last ;
23403: LD_ADDR_VAR 0 9
23407: PUSH
23408: LD_VAR 0 9
23412: PUSH
23413: LD_VAR 0 6
23417: PUSH
23418: LD_VAR 0 10
23422: MINUS
23423: ADD
23424: ST_TO_ADDR
// last := i ;
23425: LD_ADDR_VAR 0 10
23429: PUSH
23430: LD_VAR 0 6
23434: ST_TO_ADDR
// end ;
23435: GO 23400
23437: POP
23438: POP
// for i := 1 to x do
23439: LD_ADDR_VAR 0 6
23443: PUSH
23444: DOUBLE
23445: LD_INT 1
23447: DEC
23448: ST_TO_ADDR
23449: LD_VAR 0 4
23453: PUSH
23454: FOR_TO
23455: IFFALSE 23497
// begin CreateCratesArea ( Rand ( 4 , 5 ) , area , true ) ;
23457: LD_INT 4
23459: PPUSH
23460: LD_INT 5
23462: PPUSH
23463: CALL_OW 12
23467: PPUSH
23468: LD_VAR 0 2
23472: PPUSH
23473: LD_INT 1
23475: PPUSH
23476: CALL_OW 55
// Wait ( cek2 [ i ] ) ;
23480: LD_VAR 0 9
23484: PUSH
23485: LD_VAR 0 6
23489: ARRAY
23490: PPUSH
23491: CALL_OW 67
// end ;
23495: GO 23454
23497: POP
23498: POP
// end ; end_of_file
23499: LD_VAR 0 3
23503: RET
// export function get_x_best ( num , skill , mclass ) ; var i , lidi , skills ; begin
23504: LD_INT 0
23506: PPUSH
23507: PPUSH
23508: PPUSH
23509: PPUSH
// if mclass then
23510: LD_VAR 0 3
23514: IFFALSE 23567
// lidi := FilterAllUnits ( [ [ f_side , arabians ] , [ f_type , unit_human ] , [ f_class , mclass ] ] ) else
23516: LD_ADDR_VAR 0 6
23520: PUSH
23521: LD_INT 22
23523: PUSH
23524: LD_EXP 3
23528: PUSH
23529: EMPTY
23530: LIST
23531: LIST
23532: PUSH
23533: LD_INT 21
23535: PUSH
23536: LD_INT 1
23538: PUSH
23539: EMPTY
23540: LIST
23541: LIST
23542: PUSH
23543: LD_INT 25
23545: PUSH
23546: LD_VAR 0 3
23550: PUSH
23551: EMPTY
23552: LIST
23553: LIST
23554: PUSH
23555: EMPTY
23556: LIST
23557: LIST
23558: LIST
23559: PPUSH
23560: CALL_OW 69
23564: ST_TO_ADDR
23565: GO 23603
// lidi := FilterAllUnits ( [ [ f_side , arabians ] , [ f_type , unit_human ] ] ) ;
23567: LD_ADDR_VAR 0 6
23571: PUSH
23572: LD_INT 22
23574: PUSH
23575: LD_EXP 3
23579: PUSH
23580: EMPTY
23581: LIST
23582: LIST
23583: PUSH
23584: LD_INT 21
23586: PUSH
23587: LD_INT 1
23589: PUSH
23590: EMPTY
23591: LIST
23592: LIST
23593: PUSH
23594: EMPTY
23595: LIST
23596: LIST
23597: PPUSH
23598: CALL_OW 69
23602: ST_TO_ADDR
// skills := [ ] ;
23603: LD_ADDR_VAR 0 7
23607: PUSH
23608: EMPTY
23609: ST_TO_ADDR
// result := [ ] ;
23610: LD_ADDR_VAR 0 4
23614: PUSH
23615: EMPTY
23616: ST_TO_ADDR
// for i in lidi do
23617: LD_ADDR_VAR 0 5
23621: PUSH
23622: LD_VAR 0 6
23626: PUSH
23627: FOR_IN
23628: IFFALSE 23658
// skills := skills ^ GetSkill ( i , skill ) ;
23630: LD_ADDR_VAR 0 7
23634: PUSH
23635: LD_VAR 0 7
23639: PUSH
23640: LD_VAR 0 5
23644: PPUSH
23645: LD_VAR 0 2
23649: PPUSH
23650: CALL_OW 259
23654: ADD
23655: ST_TO_ADDR
23656: GO 23627
23658: POP
23659: POP
// SortListByListDesc ( lidi , skills ) ;
23660: LD_VAR 0 6
23664: PPUSH
23665: LD_VAR 0 7
23669: PPUSH
23670: CALL_OW 77
// if num = 0 then
23674: LD_VAR 0 1
23678: PUSH
23679: LD_INT 0
23681: EQUAL
23682: IFFALSE 23698
// num := ( lidi + 0 ) ;
23684: LD_ADDR_VAR 0 1
23688: PUSH
23689: LD_VAR 0 6
23693: PUSH
23694: LD_INT 0
23696: PLUS
23697: ST_TO_ADDR
// if num > lidi then
23698: LD_VAR 0 1
23702: PUSH
23703: LD_VAR 0 6
23707: GREATER
23708: IFFALSE 23724
// num := lidi + 0 ;
23710: LD_ADDR_VAR 0 1
23714: PUSH
23715: LD_VAR 0 6
23719: PUSH
23720: LD_INT 0
23722: PLUS
23723: ST_TO_ADDR
// for i := 1 to num do
23724: LD_ADDR_VAR 0 5
23728: PUSH
23729: DOUBLE
23730: LD_INT 1
23732: DEC
23733: ST_TO_ADDR
23734: LD_VAR 0 1
23738: PUSH
23739: FOR_TO
23740: IFFALSE 23766
// result := result ^ lidi [ i ] ;
23742: LD_ADDR_VAR 0 4
23746: PUSH
23747: LD_VAR 0 4
23751: PUSH
23752: LD_VAR 0 6
23756: PUSH
23757: LD_VAR 0 5
23761: ARRAY
23762: ADD
23763: ST_TO_ADDR
23764: GO 23739
23766: POP
23767: POP
// end ;
23768: LD_VAR 0 4
23772: RET
// export function WhoSayAny ( lidi , side , sex , Hclass , index ) ; begin
23773: LD_INT 0
23775: PPUSH
// lidi := UnitFilter ( lidi , [ [ f_alive ] , [ f_type , unit_human ] , [ f_side , side ] , f_not , [ f_nation , nation_nature ] ] ) ;
23776: LD_ADDR_VAR 0 1
23780: PUSH
23781: LD_VAR 0 1
23785: PPUSH
23786: LD_INT 51
23788: PUSH
23789: EMPTY
23790: LIST
23791: PUSH
23792: LD_INT 21
23794: PUSH
23795: LD_INT 1
23797: PUSH
23798: EMPTY
23799: LIST
23800: LIST
23801: PUSH
23802: LD_INT 22
23804: PUSH
23805: LD_VAR 0 2
23809: PUSH
23810: EMPTY
23811: LIST
23812: LIST
23813: PUSH
23814: LD_INT 3
23816: PUSH
23817: LD_INT 23
23819: PUSH
23820: LD_INT 0
23822: PUSH
23823: EMPTY
23824: LIST
23825: LIST
23826: PUSH
23827: EMPTY
23828: LIST
23829: LIST
23830: LIST
23831: LIST
23832: LIST
23833: PPUSH
23834: CALL_OW 72
23838: ST_TO_ADDR
// if sex <> 0 then
23839: LD_VAR 0 3
23843: PUSH
23844: LD_INT 0
23846: NONEQUAL
23847: IFFALSE 23876
// lidi := UnitFilter ( lidi , [ f_sex , sex ] ) ;
23849: LD_ADDR_VAR 0 1
23853: PUSH
23854: LD_VAR 0 1
23858: PPUSH
23859: LD_INT 26
23861: PUSH
23862: LD_VAR 0 3
23866: PUSH
23867: EMPTY
23868: LIST
23869: LIST
23870: PPUSH
23871: CALL_OW 72
23875: ST_TO_ADDR
// if Hclass <> 0 then
23876: LD_VAR 0 4
23880: PUSH
23881: LD_INT 0
23883: NONEQUAL
23884: IFFALSE 23913
// lidi := UnitFilter ( lidi , [ f_class , Hclass ] ) ;
23886: LD_ADDR_VAR 0 1
23890: PUSH
23891: LD_VAR 0 1
23895: PPUSH
23896: LD_INT 25
23898: PUSH
23899: LD_VAR 0 4
23903: PUSH
23904: EMPTY
23905: LIST
23906: LIST
23907: PPUSH
23908: CALL_OW 72
23912: ST_TO_ADDR
// if index <= 0 then
23913: LD_VAR 0 5
23917: PUSH
23918: LD_INT 0
23920: LESSEQUAL
23921: IFFALSE 23931
// index := 1 ;
23923: LD_ADDR_VAR 0 5
23927: PUSH
23928: LD_INT 1
23930: ST_TO_ADDR
// if lidi >= index then
23931: LD_VAR 0 1
23935: PUSH
23936: LD_VAR 0 5
23940: GREATEREQUAL
23941: IFFALSE 23961
// result := lidi [ index ] else
23943: LD_ADDR_VAR 0 6
23947: PUSH
23948: LD_VAR 0 1
23952: PUSH
23953: LD_VAR 0 5
23957: ARRAY
23958: ST_TO_ADDR
23959: GO 23969
// result := 0 ;
23961: LD_ADDR_VAR 0 6
23965: PUSH
23966: LD_INT 0
23968: ST_TO_ADDR
// end ;
23969: LD_VAR 0 6
23973: RET
// export function see_any ( strana , sez ) ; var i ; begin
23974: LD_INT 0
23976: PPUSH
23977: PPUSH
// result := [ ] ;
23978: LD_ADDR_VAR 0 3
23982: PUSH
23983: EMPTY
23984: ST_TO_ADDR
// for i in sez do
23985: LD_ADDR_VAR 0 4
23989: PUSH
23990: LD_VAR 0 2
23994: PUSH
23995: FOR_IN
23996: IFFALSE 24035
// if See ( strana , i ) then
23998: LD_VAR 0 1
24002: PPUSH
24003: LD_VAR 0 4
24007: PPUSH
24008: CALL_OW 292
24012: IFFALSE 24033
// begin result := result ^ [ i ] ;
24014: LD_ADDR_VAR 0 3
24018: PUSH
24019: LD_VAR 0 3
24023: PUSH
24024: LD_VAR 0 4
24028: PUSH
24029: EMPTY
24030: LIST
24031: ADD
24032: ST_TO_ADDR
// end ;
24033: GO 23995
24035: POP
24036: POP
// ; end ;
24037: LD_VAR 0 3
24041: RET
// export function TalkOn ; begin
24042: LD_INT 0
24044: PPUSH
// end ;
24045: LD_VAR 0 1
24049: RET
// export function TalkOff ; begin
24050: LD_INT 0
24052: PPUSH
// end ;
24053: LD_VAR 0 1
24057: RET
// export function FilterHumansInArea ( area , filter ) ; var inbase , i ; begin
24058: LD_INT 0
24060: PPUSH
24061: PPUSH
24062: PPUSH
// result := [ ] ;
24063: LD_ADDR_VAR 0 3
24067: PUSH
24068: EMPTY
24069: ST_TO_ADDR
// inbase := FilterUnitsInArea ( area , [ ] ) ;
24070: LD_ADDR_VAR 0 4
24074: PUSH
24075: LD_VAR 0 1
24079: PPUSH
24080: EMPTY
24081: PPUSH
24082: CALL_OW 70
24086: ST_TO_ADDR
// for i in inbase do
24087: LD_ADDR_VAR 0 5
24091: PUSH
24092: LD_VAR 0 4
24096: PUSH
24097: FOR_IN
24098: IFFALSE 24171
// begin if GetType ( i ) = unit_building or GetType ( i ) = unit_vehicle then
24100: LD_VAR 0 5
24104: PPUSH
24105: CALL_OW 247
24109: PUSH
24110: LD_INT 3
24112: EQUAL
24113: PUSH
24114: LD_VAR 0 5
24118: PPUSH
24119: CALL_OW 247
24123: PUSH
24124: LD_INT 2
24126: EQUAL
24127: OR
24128: IFFALSE 24153
// begin result := result ^ UnitsInside ( i ) ;
24130: LD_ADDR_VAR 0 3
24134: PUSH
24135: LD_VAR 0 3
24139: PUSH
24140: LD_VAR 0 5
24144: PPUSH
24145: CALL_OW 313
24149: ADD
24150: ST_TO_ADDR
// end else
24151: GO 24169
// begin result := result ^ i ;
24153: LD_ADDR_VAR 0 3
24157: PUSH
24158: LD_VAR 0 3
24162: PUSH
24163: LD_VAR 0 5
24167: ADD
24168: ST_TO_ADDR
// end ; end ;
24169: GO 24097
24171: POP
24172: POP
// result := UnitFilter ( result diff 0 , filter ) ;
24173: LD_ADDR_VAR 0 3
24177: PUSH
24178: LD_VAR 0 3
24182: PUSH
24183: LD_INT 0
24185: DIFF
24186: PPUSH
24187: LD_VAR 0 2
24191: PPUSH
24192: CALL_OW 72
24196: ST_TO_ADDR
// end ;
24197: LD_VAR 0 3
24201: RET
// export function find_drivers ( cars , drivers , take_out ) ; var empty , free , i , konec ; begin
24202: LD_INT 0
24204: PPUSH
24205: PPUSH
24206: PPUSH
24207: PPUSH
24208: PPUSH
// cars := UnitFilter ( cars , [ f_alive ] ) ;
24209: LD_ADDR_VAR 0 1
24213: PUSH
24214: LD_VAR 0 1
24218: PPUSH
24219: LD_INT 51
24221: PUSH
24222: EMPTY
24223: LIST
24224: PPUSH
24225: CALL_OW 72
24229: ST_TO_ADDR
// if take_out then
24230: LD_VAR 0 3
24234: IFFALSE 24262
// drivers := UnitFilter ( drivers , [ [ f_alive ] ] ) else
24236: LD_ADDR_VAR 0 2
24240: PUSH
24241: LD_VAR 0 2
24245: PPUSH
24246: LD_INT 51
24248: PUSH
24249: EMPTY
24250: LIST
24251: PUSH
24252: EMPTY
24253: LIST
24254: PPUSH
24255: CALL_OW 72
24259: ST_TO_ADDR
24260: GO 24293
// drivers := UnitFilter ( drivers , [ [ f_alive ] , [ f_outside ] ] ) ;
24262: LD_ADDR_VAR 0 2
24266: PUSH
24267: LD_VAR 0 2
24271: PPUSH
24272: LD_INT 51
24274: PUSH
24275: EMPTY
24276: LIST
24277: PUSH
24278: LD_INT 56
24280: PUSH
24281: EMPTY
24282: LIST
24283: PUSH
24284: EMPTY
24285: LIST
24286: LIST
24287: PPUSH
24288: CALL_OW 72
24292: ST_TO_ADDR
// empty := [ ] ;
24293: LD_ADDR_VAR 0 5
24297: PUSH
24298: EMPTY
24299: ST_TO_ADDR
// free := [ ] ;
24300: LD_ADDR_VAR 0 6
24304: PUSH
24305: EMPTY
24306: ST_TO_ADDR
// for i in cars do
24307: LD_ADDR_VAR 0 7
24311: PUSH
24312: LD_VAR 0 1
24316: PUSH
24317: FOR_IN
24318: IFFALSE 24353
// if not IsDrivenBy ( i ) then
24320: LD_VAR 0 7
24324: PPUSH
24325: CALL_OW 311
24329: NOT
24330: IFFALSE 24351
// empty := empty ^ [ i ] ;
24332: LD_ADDR_VAR 0 5
24336: PUSH
24337: LD_VAR 0 5
24341: PUSH
24342: LD_VAR 0 7
24346: PUSH
24347: EMPTY
24348: LIST
24349: ADD
24350: ST_TO_ADDR
24351: GO 24317
24353: POP
24354: POP
// for i in drivers do
24355: LD_ADDR_VAR 0 7
24359: PUSH
24360: LD_VAR 0 2
24364: PUSH
24365: FOR_IN
24366: IFFALSE 24407
// if not ( IsInUnit ( i ) in cars ) then
24368: LD_VAR 0 7
24372: PPUSH
24373: CALL_OW 310
24377: PUSH
24378: LD_VAR 0 1
24382: IN
24383: NOT
24384: IFFALSE 24405
// free := free ^ [ i ] ;
24386: LD_ADDR_VAR 0 6
24390: PUSH
24391: LD_VAR 0 6
24395: PUSH
24396: LD_VAR 0 7
24400: PUSH
24401: EMPTY
24402: LIST
24403: ADD
24404: ST_TO_ADDR
24405: GO 24365
24407: POP
24408: POP
// if empty <= free then
24409: LD_VAR 0 5
24413: PUSH
24414: LD_VAR 0 6
24418: LESSEQUAL
24419: IFFALSE 24433
// konec := empty else
24421: LD_ADDR_VAR 0 8
24425: PUSH
24426: LD_VAR 0 5
24430: ST_TO_ADDR
24431: GO 24443
// konec := free ;
24433: LD_ADDR_VAR 0 8
24437: PUSH
24438: LD_VAR 0 6
24442: ST_TO_ADDR
// result := cars diff empty ;
24443: LD_ADDR_VAR 0 4
24447: PUSH
24448: LD_VAR 0 1
24452: PUSH
24453: LD_VAR 0 5
24457: DIFF
24458: ST_TO_ADDR
// for i := 1 to konec do
24459: LD_ADDR_VAR 0 7
24463: PUSH
24464: DOUBLE
24465: LD_INT 1
24467: DEC
24468: ST_TO_ADDR
24469: LD_VAR 0 8
24473: PUSH
24474: FOR_TO
24475: IFFALSE 24527
// begin ComEnterUnit ( free [ i ] , empty [ i ] ) ;
24477: LD_VAR 0 6
24481: PUSH
24482: LD_VAR 0 7
24486: ARRAY
24487: PPUSH
24488: LD_VAR 0 5
24492: PUSH
24493: LD_VAR 0 7
24497: ARRAY
24498: PPUSH
24499: CALL_OW 120
// result := result ^ empty [ i ] ;
24503: LD_ADDR_VAR 0 4
24507: PUSH
24508: LD_VAR 0 4
24512: PUSH
24513: LD_VAR 0 5
24517: PUSH
24518: LD_VAR 0 7
24522: ARRAY
24523: ADD
24524: ST_TO_ADDR
// end ;
24525: GO 24474
24527: POP
24528: POP
// end ;
24529: LD_VAR 0 4
24533: RET
// export function wait_for_drivers ( cars , cas ) ; var i , vsichni_ready , pockat ; begin
24534: LD_INT 0
24536: PPUSH
24537: PPUSH
24538: PPUSH
24539: PPUSH
// pockat := tick + cas ;
24540: LD_ADDR_VAR 0 6
24544: PUSH
24545: LD_OWVAR 1
24549: PUSH
24550: LD_VAR 0 2
24554: PLUS
24555: ST_TO_ADDR
// while not vsichni_ready and tick < pockat do
24556: LD_VAR 0 5
24560: NOT
24561: PUSH
24562: LD_OWVAR 1
24566: PUSH
24567: LD_VAR 0 6
24571: LESS
24572: AND
24573: IFFALSE 24629
// begin vsichni_ready := true ;
24575: LD_ADDR_VAR 0 5
24579: PUSH
24580: LD_INT 1
24582: ST_TO_ADDR
// for i in cars do
24583: LD_ADDR_VAR 0 4
24587: PUSH
24588: LD_VAR 0 1
24592: PUSH
24593: FOR_IN
24594: IFFALSE 24618
// if not IsDrivenBy ( i ) then
24596: LD_VAR 0 4
24600: PPUSH
24601: CALL_OW 311
24605: NOT
24606: IFFALSE 24616
// vsichni_ready := false ;
24608: LD_ADDR_VAR 0 5
24612: PUSH
24613: LD_INT 0
24615: ST_TO_ADDR
24616: GO 24593
24618: POP
24619: POP
// wait ( 0 0$1.0 ) ;
24620: LD_INT 35
24622: PPUSH
24623: CALL_OW 67
// end ;
24627: GO 24556
// end ;
24629: LD_VAR 0 3
24633: RET
// export function find_and_wait ( cars , drivers , take_out , change , cas ) ; var empty , full , free , i , konec , mytick ; begin
24634: LD_INT 0
24636: PPUSH
24637: PPUSH
24638: PPUSH
24639: PPUSH
24640: PPUSH
24641: PPUSH
24642: PPUSH
// mytick := tick + cas ;
24643: LD_ADDR_VAR 0 12
24647: PUSH
24648: LD_OWVAR 1
24652: PUSH
24653: LD_VAR 0 5
24657: PLUS
24658: ST_TO_ADDR
// cars := UnitFilter ( cars , [ [ f_alive ] ] ) ;
24659: LD_ADDR_VAR 0 1
24663: PUSH
24664: LD_VAR 0 1
24668: PPUSH
24669: LD_INT 51
24671: PUSH
24672: EMPTY
24673: LIST
24674: PUSH
24675: EMPTY
24676: LIST
24677: PPUSH
24678: CALL_OW 72
24682: ST_TO_ADDR
// drivers := UnitFilter ( drivers , [ [ f_alive ] , [ f_outside ] ] ) ;
24683: LD_ADDR_VAR 0 2
24687: PUSH
24688: LD_VAR 0 2
24692: PPUSH
24693: LD_INT 51
24695: PUSH
24696: EMPTY
24697: LIST
24698: PUSH
24699: LD_INT 56
24701: PUSH
24702: EMPTY
24703: LIST
24704: PUSH
24705: EMPTY
24706: LIST
24707: LIST
24708: PPUSH
24709: CALL_OW 72
24713: ST_TO_ADDR
// if take_out then
24714: LD_VAR 0 3
24718: IFFALSE 24759
// drivers := drivers ^ UnitFilter ( drivers , [ [ f_alive ] , [ f_inside ] ] ) else
24720: LD_ADDR_VAR 0 2
24724: PUSH
24725: LD_VAR 0 2
24729: PUSH
24730: LD_VAR 0 2
24734: PPUSH
24735: LD_INT 51
24737: PUSH
24738: EMPTY
24739: LIST
24740: PUSH
24741: LD_INT 54
24743: PUSH
24744: EMPTY
24745: LIST
24746: PUSH
24747: EMPTY
24748: LIST
24749: LIST
24750: PPUSH
24751: CALL_OW 72
24755: ADD
24756: ST_TO_ADDR
24757: GO 24790
// empty := UnitFilter ( cars , [ [ f_empty ] , [ f_alive ] ] ) ;
24759: LD_ADDR_VAR 0 7
24763: PUSH
24764: LD_VAR 0 1
24768: PPUSH
24769: LD_INT 58
24771: PUSH
24772: EMPTY
24773: LIST
24774: PUSH
24775: LD_INT 51
24777: PUSH
24778: EMPTY
24779: LIST
24780: PUSH
24781: EMPTY
24782: LIST
24783: LIST
24784: PPUSH
24785: CALL_OW 72
24789: ST_TO_ADDR
// repeat full := UnitFilter ( cars , [ [ f_occupied ] , [ f_alive ] ] ) ;
24790: LD_ADDR_VAR 0 8
24794: PUSH
24795: LD_VAR 0 1
24799: PPUSH
24800: LD_INT 59
24802: PUSH
24803: EMPTY
24804: LIST
24805: PUSH
24806: LD_INT 51
24808: PUSH
24809: EMPTY
24810: LIST
24811: PUSH
24812: EMPTY
24813: LIST
24814: LIST
24815: PPUSH
24816: CALL_OW 72
24820: ST_TO_ADDR
// if change then
24821: LD_VAR 0 4
24825: IFFALSE 24847
// ComExitVehicle ( inside_units ( full ) diff drivers ) ;
24827: LD_VAR 0 8
24831: PPUSH
24832: CALL 25582 0 1
24836: PUSH
24837: LD_VAR 0 2
24841: DIFF
24842: PPUSH
24843: CALL_OW 121
// for i in drivers do
24847: LD_ADDR_VAR 0 10
24851: PUSH
24852: LD_VAR 0 2
24856: PUSH
24857: FOR_IN
24858: IFFALSE 24920
// if not ( IsInUnit ( i ) in cars ) then
24860: LD_VAR 0 10
24864: PPUSH
24865: CALL_OW 310
24869: PUSH
24870: LD_VAR 0 1
24874: IN
24875: NOT
24876: IFFALSE 24918
// if GetType ( IsInUnit ( i ) ) = unit_vehicle then
24878: LD_VAR 0 10
24882: PPUSH
24883: CALL_OW 310
24887: PPUSH
24888: CALL_OW 247
24892: PUSH
24893: LD_INT 2
24895: EQUAL
24896: IFFALSE 24909
// ComExitVehicle ( i ) else
24898: LD_VAR 0 10
24902: PPUSH
24903: CALL_OW 121
24907: GO 24918
// ComExitBuilding ( i ) ;
24909: LD_VAR 0 10
24913: PPUSH
24914: CALL_OW 122
24918: GO 24857
24920: POP
24921: POP
// free := UnitFilter ( drivers , [ [ f_outside ] , [ f_alive ] ] ) ;
24922: LD_ADDR_VAR 0 9
24926: PUSH
24927: LD_VAR 0 2
24931: PPUSH
24932: LD_INT 56
24934: PUSH
24935: EMPTY
24936: LIST
24937: PUSH
24938: LD_INT 51
24940: PUSH
24941: EMPTY
24942: LIST
24943: PUSH
24944: EMPTY
24945: LIST
24946: LIST
24947: PPUSH
24948: CALL_OW 72
24952: ST_TO_ADDR
// i := 1 ;
24953: LD_ADDR_VAR 0 10
24957: PUSH
24958: LD_INT 1
24960: ST_TO_ADDR
// while i <= free and i <= empty do
24961: LD_VAR 0 10
24965: PUSH
24966: LD_VAR 0 9
24970: LESSEQUAL
24971: PUSH
24972: LD_VAR 0 10
24976: PUSH
24977: LD_VAR 0 7
24981: LESSEQUAL
24982: AND
24983: IFFALSE 25046
// begin if not free [ i ] in DU_units then
24985: LD_VAR 0 9
24989: PUSH
24990: LD_VAR 0 10
24994: ARRAY
24995: PUSH
24996: LD_EXP 83
25000: IN
25001: NOT
25002: IFFALSE 25030
// ComEnterUnit ( free [ i ] , empty [ i ] ) ;
25004: LD_VAR 0 9
25008: PUSH
25009: LD_VAR 0 10
25013: ARRAY
25014: PPUSH
25015: LD_VAR 0 7
25019: PUSH
25020: LD_VAR 0 10
25024: ARRAY
25025: PPUSH
25026: CALL_OW 120
// i := i + 1 ;
25030: LD_ADDR_VAR 0 10
25034: PUSH
25035: LD_VAR 0 10
25039: PUSH
25040: LD_INT 1
25042: PLUS
25043: ST_TO_ADDR
// end ;
25044: GO 24961
// wait ( 0 0$1 ) ;
25046: LD_INT 35
25048: PPUSH
25049: CALL_OW 67
// empty := UnitFilter ( cars , [ [ f_empty ] , [ f_alive ] ] ) ;
25053: LD_ADDR_VAR 0 7
25057: PUSH
25058: LD_VAR 0 1
25062: PPUSH
25063: LD_INT 58
25065: PUSH
25066: EMPTY
25067: LIST
25068: PUSH
25069: LD_INT 51
25071: PUSH
25072: EMPTY
25073: LIST
25074: PUSH
25075: EMPTY
25076: LIST
25077: LIST
25078: PPUSH
25079: CALL_OW 72
25083: ST_TO_ADDR
// until not empty or tick > mytick ;
25084: LD_VAR 0 7
25088: NOT
25089: PUSH
25090: LD_OWVAR 1
25094: PUSH
25095: LD_VAR 0 12
25099: GREATER
25100: OR
25101: IFFALSE 24790
// end ;
25103: LD_VAR 0 6
25107: RET
// export function find_remotes ( cars , mechs , remotes ) ; var cas , i ; begin
25108: LD_INT 0
25110: PPUSH
25111: PPUSH
25112: PPUSH
// while remotes > mechs do
25113: LD_VAR 0 3
25117: PUSH
25118: LD_VAR 0 2
25122: GREATER
25123: IFFALSE 25139
// delete ( remotes , 1 ) ;
25125: LD_VAR 0 3
25129: PPUSH
25130: LD_INT 1
25132: PPUSH
25133: CALL_OW 3
25137: GO 25113
// for i := 1 to remotes do
25139: LD_ADDR_VAR 0 6
25143: PUSH
25144: DOUBLE
25145: LD_INT 1
25147: DEC
25148: ST_TO_ADDR
25149: LD_VAR 0 3
25153: PUSH
25154: FOR_TO
25155: IFFALSE 25185
// ComEnterUnit ( mechs [ i ] , remotes [ i ] ) ;
25157: LD_VAR 0 2
25161: PUSH
25162: LD_VAR 0 6
25166: ARRAY
25167: PPUSH
25168: LD_VAR 0 3
25172: PUSH
25173: LD_VAR 0 6
25177: ARRAY
25178: PPUSH
25179: CALL_OW 120
25183: GO 25154
25185: POP
25186: POP
// end ;
25187: LD_VAR 0 4
25191: RET
// export function wait_for_remotes ( cars , remotes , cas ) ; var c , unlinked , i ; begin
25192: LD_INT 0
25194: PPUSH
25195: PPUSH
25196: PPUSH
25197: PPUSH
// c := tick + cas ;
25198: LD_ADDR_VAR 0 5
25202: PUSH
25203: LD_OWVAR 1
25207: PUSH
25208: LD_VAR 0 3
25212: PLUS
25213: ST_TO_ADDR
// while tick < c and ( not ( inside_units ( remotes ) + 0 ) = remotes ) do
25214: LD_OWVAR 1
25218: PUSH
25219: LD_VAR 0 5
25223: LESS
25224: PUSH
25225: LD_VAR 0 2
25229: PPUSH
25230: CALL 25582 0 1
25234: PUSH
25235: LD_INT 0
25237: PLUS
25238: PUSH
25239: LD_VAR 0 2
25243: EQUAL
25244: NOT
25245: AND
25246: IFFALSE 25257
// wait ( 0 0$1 ) ;
25248: LD_INT 35
25250: PPUSH
25251: CALL_OW 67
25255: GO 25214
// unlinked := cars ;
25257: LD_ADDR_VAR 0 6
25261: PUSH
25262: LD_VAR 0 1
25266: ST_TO_ADDR
// for i in remotes do
25267: LD_ADDR_VAR 0 7
25271: PUSH
25272: LD_VAR 0 2
25276: PUSH
25277: FOR_IN
25278: IFFALSE 25327
// begin ComLinkTo ( unlinked , UnitsInside ( i ) ) ;
25280: LD_VAR 0 6
25284: PPUSH
25285: LD_VAR 0 7
25289: PPUSH
25290: CALL_OW 313
25294: PPUSH
25295: CALL_OW 135
// unlinked := unlinked diff UnitsLinked ( UnitsInside ( i ) ) ;
25299: LD_ADDR_VAR 0 6
25303: PUSH
25304: LD_VAR 0 6
25308: PUSH
25309: LD_VAR 0 7
25313: PPUSH
25314: CALL_OW 313
25318: PPUSH
25319: CALL_OW 432
25323: DIFF
25324: ST_TO_ADDR
// end ;
25325: GO 25277
25327: POP
25328: POP
// end ;
25329: LD_VAR 0 4
25333: RET
// export function find_and_wait_r ( cars , remote , cas ) ; var linked , unlinked , i , konec , mytick , rmecs , max ; begin
25334: LD_INT 0
25336: PPUSH
25337: PPUSH
25338: PPUSH
25339: PPUSH
25340: PPUSH
25341: PPUSH
25342: PPUSH
25343: PPUSH
// mytick := tick + cas ;
25344: LD_ADDR_VAR 0 9
25348: PUSH
25349: LD_OWVAR 1
25353: PUSH
25354: LD_VAR 0 3
25358: PLUS
25359: ST_TO_ADDR
// rmecs := inside_units ( remote ) ;
25360: LD_ADDR_VAR 0 10
25364: PUSH
25365: LD_VAR 0 2
25369: PPUSH
25370: CALL 25582 0 1
25374: ST_TO_ADDR
// max := 0 ;
25375: LD_ADDR_VAR 0 11
25379: PUSH
25380: LD_INT 0
25382: ST_TO_ADDR
// for i in rmecs do
25383: LD_ADDR_VAR 0 7
25387: PUSH
25388: LD_VAR 0 10
25392: PUSH
25393: FOR_IN
25394: IFFALSE 25422
// max := max + GetSkill ( i , skill_mechanical ) ;
25396: LD_ADDR_VAR 0 11
25400: PUSH
25401: LD_VAR 0 11
25405: PUSH
25406: LD_VAR 0 7
25410: PPUSH
25411: LD_INT 3
25413: PPUSH
25414: CALL_OW 259
25418: PLUS
25419: ST_TO_ADDR
25420: GO 25393
25422: POP
25423: POP
// while mytick < tick and ( unlinked or linked < max or max = 0 ) do
25424: LD_VAR 0 9
25428: PUSH
25429: LD_OWVAR 1
25433: LESS
25434: PUSH
25435: LD_VAR 0 6
25439: PUSH
25440: LD_VAR 0 5
25444: PUSH
25445: LD_VAR 0 11
25449: LESS
25450: OR
25451: PUSH
25452: LD_VAR 0 11
25456: PUSH
25457: LD_INT 0
25459: EQUAL
25460: OR
25461: AND
25462: IFFALSE 25577
// begin rmecs := inside_units ( remote ) ;
25464: LD_ADDR_VAR 0 10
25468: PUSH
25469: LD_VAR 0 2
25473: PPUSH
25474: CALL 25582 0 1
25478: ST_TO_ADDR
// max := 0 ;
25479: LD_ADDR_VAR 0 11
25483: PUSH
25484: LD_INT 0
25486: ST_TO_ADDR
// for i in rmecs do
25487: LD_ADDR_VAR 0 7
25491: PUSH
25492: LD_VAR 0 10
25496: PUSH
25497: FOR_IN
25498: IFFALSE 25526
// max := max + GetSkill ( i , skill_mechanical ) ;
25500: LD_ADDR_VAR 0 11
25504: PUSH
25505: LD_VAR 0 11
25509: PUSH
25510: LD_VAR 0 7
25514: PPUSH
25515: LD_INT 3
25517: PPUSH
25518: CALL_OW 259
25522: PLUS
25523: ST_TO_ADDR
25524: GO 25497
25526: POP
25527: POP
// linked := UnitFilter ( cars , [ [ f_linked ] ] ) ;
25528: LD_ADDR_VAR 0 5
25532: PUSH
25533: LD_VAR 0 1
25537: PPUSH
25538: LD_INT 61
25540: PUSH
25541: EMPTY
25542: LIST
25543: PUSH
25544: EMPTY
25545: LIST
25546: PPUSH
25547: CALL_OW 72
25551: ST_TO_ADDR
// unlinked := linked diff unlinked ;
25552: LD_ADDR_VAR 0 6
25556: PUSH
25557: LD_VAR 0 5
25561: PUSH
25562: LD_VAR 0 6
25566: DIFF
25567: ST_TO_ADDR
// wait ( 0 0$1 ) ;
25568: LD_INT 35
25570: PPUSH
25571: CALL_OW 67
// end ;
25575: GO 25424
// end ;
25577: LD_VAR 0 4
25581: RET
// export function inside_units ( uns ) ; var i ; begin
25582: LD_INT 0
25584: PPUSH
25585: PPUSH
// result := [ ] ;
25586: LD_ADDR_VAR 0 2
25590: PUSH
25591: EMPTY
25592: ST_TO_ADDR
// for i in uns do
25593: LD_ADDR_VAR 0 3
25597: PUSH
25598: LD_VAR 0 1
25602: PUSH
25603: FOR_IN
25604: IFFALSE 25629
// result := result ^ UnitsInside ( i ) ;
25606: LD_ADDR_VAR 0 2
25610: PUSH
25611: LD_VAR 0 2
25615: PUSH
25616: LD_VAR 0 3
25620: PPUSH
25621: CALL_OW 313
25625: ADD
25626: ST_TO_ADDR
25627: GO 25603
25629: POP
25630: POP
// end ;
25631: LD_VAR 0 2
25635: RET
// export function add ( list , list1 ) ; begin
25636: LD_INT 0
25638: PPUSH
// if list = 0 then
25639: LD_VAR 0 1
25643: PUSH
25644: LD_INT 0
25646: EQUAL
25647: IFFALSE 25656
// list := [ ] ;
25649: LD_ADDR_VAR 0 1
25653: PUSH
25654: EMPTY
25655: ST_TO_ADDR
// if list1 = 0 then
25656: LD_VAR 0 2
25660: PUSH
25661: LD_INT 0
25663: EQUAL
25664: IFFALSE 25673
// list1 := [ ] ;
25666: LD_ADDR_VAR 0 2
25670: PUSH
25671: EMPTY
25672: ST_TO_ADDR
// result := list ^ list1 ;
25673: LD_ADDR_VAR 0 3
25677: PUSH
25678: LD_VAR 0 1
25682: PUSH
25683: LD_VAR 0 2
25687: ADD
25688: ST_TO_ADDR
// end ;
25689: LD_VAR 0 3
25693: RET
// export hinty_co_byli ; export function MyHint ( ident ) ; begin
25694: LD_INT 0
25696: PPUSH
// if not hinty_co_byli then
25697: LD_EXP 87
25701: NOT
25702: IFFALSE 25711
// hinty_co_byli := [ ] ;
25704: LD_ADDR_EXP 87
25708: PUSH
25709: EMPTY
25710: ST_TO_ADDR
// if not ( ident in hinty_co_byli ) then
25711: LD_VAR 0 1
25715: PUSH
25716: LD_EXP 87
25720: IN
25721: NOT
25722: IFFALSE 25749
// begin hinty_co_byli := hinty_co_byli ^ ident ;
25724: LD_ADDR_EXP 87
25728: PUSH
25729: LD_EXP 87
25733: PUSH
25734: LD_VAR 0 1
25738: ADD
25739: ST_TO_ADDR
// Hint ( ident ) ;
25740: LD_VAR 0 1
25744: PPUSH
25745: CALL_OW 339
// end ; end ; end_of_file
25749: LD_VAR 0 2
25753: RET
// every 0 0$2 + 0 0$0.1 do
25754: GO 25756
25756: DISABLE
// begin if FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_class , class_apeman ] , [ f_class , class_apeman_engineer ] , [ f_class , class_apeman_soldier ] , [ f_class , class_apeman_kamikaze ] ] ] ) > FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_not , [ f_or , [ f_class , class_apeman ] , [ f_class , class_apeman_engineer ] , [ f_class , class_apeman_soldier ] , [ f_class , class_apeman_kamikaze ] ] ] ] ) then
25757: LD_INT 22
25759: PUSH
25760: LD_INT 3
25762: PUSH
25763: EMPTY
25764: LIST
25765: LIST
25766: PUSH
25767: LD_INT 2
25769: PUSH
25770: LD_INT 25
25772: PUSH
25773: LD_INT 12
25775: PUSH
25776: EMPTY
25777: LIST
25778: LIST
25779: PUSH
25780: LD_INT 25
25782: PUSH
25783: LD_INT 16
25785: PUSH
25786: EMPTY
25787: LIST
25788: LIST
25789: PUSH
25790: LD_INT 25
25792: PUSH
25793: LD_INT 15
25795: PUSH
25796: EMPTY
25797: LIST
25798: LIST
25799: PUSH
25800: LD_INT 25
25802: PUSH
25803: LD_INT 17
25805: PUSH
25806: EMPTY
25807: LIST
25808: LIST
25809: PUSH
25810: EMPTY
25811: LIST
25812: LIST
25813: LIST
25814: LIST
25815: LIST
25816: PUSH
25817: EMPTY
25818: LIST
25819: LIST
25820: PPUSH
25821: CALL_OW 69
25825: PUSH
25826: LD_INT 22
25828: PUSH
25829: LD_INT 3
25831: PUSH
25832: EMPTY
25833: LIST
25834: LIST
25835: PUSH
25836: LD_INT 21
25838: PUSH
25839: LD_INT 1
25841: PUSH
25842: EMPTY
25843: LIST
25844: LIST
25845: PUSH
25846: LD_INT 3
25848: PUSH
25849: LD_INT 2
25851: PUSH
25852: LD_INT 25
25854: PUSH
25855: LD_INT 12
25857: PUSH
25858: EMPTY
25859: LIST
25860: LIST
25861: PUSH
25862: LD_INT 25
25864: PUSH
25865: LD_INT 16
25867: PUSH
25868: EMPTY
25869: LIST
25870: LIST
25871: PUSH
25872: LD_INT 25
25874: PUSH
25875: LD_INT 15
25877: PUSH
25878: EMPTY
25879: LIST
25880: LIST
25881: PUSH
25882: LD_INT 25
25884: PUSH
25885: LD_INT 17
25887: PUSH
25888: EMPTY
25889: LIST
25890: LIST
25891: PUSH
25892: EMPTY
25893: LIST
25894: LIST
25895: LIST
25896: LIST
25897: LIST
25898: PUSH
25899: EMPTY
25900: LIST
25901: LIST
25902: PUSH
25903: EMPTY
25904: LIST
25905: LIST
25906: LIST
25907: PPUSH
25908: CALL_OW 69
25912: GREATER
25913: IFFALSE 25924
// begin SetAchievement ( ACH_POTA ) ;
25915: LD_STRING ACH_POTA
25917: PPUSH
25918: CALL_OW 543
// exit ;
25922: GO 25925
// end ; enable ;
25924: ENABLE
// end ;
25925: END
// export function SA_KillStevens ; begin
25926: LD_INT 0
25928: PPUSH
// SetAchievement ( ACH_SNI ) ;
25929: LD_STRING ACH_SNI
25931: PPUSH
25932: CALL_OW 543
// end ; end_of_file
25936: LD_VAR 0 1
25940: RET
// export function SA_EndMission ( campaignNumber , missionNumber , medal1 , medal2 , medal3 ) ; var achiv ; begin
25941: LD_INT 0
25943: PPUSH
25944: PPUSH
// if not missionNumber then
25945: LD_VAR 0 2
25949: NOT
25950: IFFALSE 25954
// exit ;
25952: GO 26084
// achiv := false ;
25954: LD_ADDR_VAR 0 7
25958: PUSH
25959: LD_INT 0
25961: ST_TO_ADDR
// case campaignNumber of 1 :
25962: LD_VAR 0 1
25966: PUSH
25967: LD_INT 1
25969: DOUBLE
25970: EQUAL
25971: IFTRUE 25975
25973: GO 25986
25975: POP
// achiv := ACH_GOTA ; 2 :
25976: LD_ADDR_VAR 0 7
25980: PUSH
25981: LD_STRING ACH_GOTA
25983: ST_TO_ADDR
25984: GO 26036
25986: LD_INT 2
25988: DOUBLE
25989: EQUAL
25990: IFTRUE 25994
25992: GO 25997
25994: POP
// ; 3 :
25995: GO 26036
25997: LD_INT 3
25999: DOUBLE
26000: EQUAL
26001: IFTRUE 26005
26003: GO 26016
26005: POP
// achiv := ACH_MOTSU ; 4 :
26006: LD_ADDR_VAR 0 7
26010: PUSH
26011: LD_STRING ACH_MOTSU
26013: ST_TO_ADDR
26014: GO 26036
26016: LD_INT 4
26018: DOUBLE
26019: EQUAL
26020: IFTRUE 26024
26022: GO 26035
26024: POP
// achiv := ACH_LOP ; end ;
26025: LD_ADDR_VAR 0 7
26029: PUSH
26030: LD_STRING ACH_LOP
26032: ST_TO_ADDR
26033: GO 26036
26035: POP
// if Difficulty = 3 and achiv and medal1 and medal2 and medal3 then
26036: LD_OWVAR 67
26040: PUSH
26041: LD_INT 3
26043: EQUAL
26044: PUSH
26045: LD_VAR 0 7
26049: AND
26050: PUSH
26051: LD_VAR 0 3
26055: AND
26056: PUSH
26057: LD_VAR 0 4
26061: AND
26062: PUSH
26063: LD_VAR 0 5
26067: AND
26068: IFFALSE 26084
// SetAchievementEX ( achiv , missionNumber ) ;
26070: LD_VAR 0 7
26074: PPUSH
26075: LD_VAR 0 2
26079: PPUSH
26080: CALL_OW 564
// end ;
26084: LD_VAR 0 6
26088: RET
// export function SA_BehemothConstructed ; begin
26089: LD_INT 0
26091: PPUSH
// SetAchievement ( ACH_SMC ) ;
26092: LD_STRING ACH_SMC
26094: PPUSH
26095: CALL_OW 543
// end ;
26099: LD_VAR 0 1
26103: RET
