// starting begin InitMission ;
   0: CALL 5 0 0
// end ;
   4: END
// export omarStatus ; export tanksFromIntro ; export counter_test ; function InitMission ; begin
   5: LD_INT 0
   7: PPUSH
// ResetFog ;
   8: CALL_OW 335
// RandomizeAll ;
  12: CALL_OW 11
// InGameOn ;
  16: CALL_OW 8
// InitMapConfig ;
  20: CALL 72 0 0
// omarStatus = 0 ;
  24: LD_ADDR_EXP 1
  28: PUSH
  29: LD_INT 0
  31: ST_TO_ADDR
// tanksFromIntro = LoadVariable ( 05_TanksIntro_1 , [ ] ) ;
  32: LD_ADDR_EXP 2
  36: PUSH
  37: LD_STRING 05_TanksIntro_1
  39: PPUSH
  40: EMPTY
  41: PPUSH
  42: CALL_OW 30
  46: ST_TO_ADDR
// counter_test = 0 0$00 ;
  47: LD_ADDR_EXP 3
  51: PUSH
  52: LD_INT 0
  54: ST_TO_ADDR
// PrepareRussians ;
  55: CALL 595 0 0
// Nef_PrepareNature ;
  59: CALL 2042 0 0
// MissionIntro ;
  63: CALL 1342 0 0
// end ; end_of_file
  67: LD_VAR 0 1
  71: RET
// export function InitMapConfig ; begin
  72: LD_INT 0
  74: PPUSH
// BaseMapConfig ;
  75: CALL 88 0 0
// MissionMapConfig ;
  79: CALL 190 0 0
// end ;
  83: LD_VAR 0 1
  87: RET
// export animalsAmount , animalsStats , animalsAgression , missionPrefix , previousMissionPrefix , debugMode ; function BaseMapConfig ; begin
  88: LD_INT 0
  90: PPUSH
// animalsAmount = [ 4 , 3 , 1 , 0 , 0 ] ;
  91: LD_ADDR_EXP 4
  95: PUSH
  96: LD_INT 4
  98: PUSH
  99: LD_INT 3
 101: PUSH
 102: LD_INT 1
 104: PUSH
 105: LD_INT 0
 107: PUSH
 108: LD_INT 0
 110: PUSH
 111: EMPTY
 112: LIST
 113: LIST
 114: LIST
 115: LIST
 116: LIST
 117: ST_TO_ADDR
// animalsStats = [ 2 , 2 , 2 , 2 ] ;
 118: LD_ADDR_EXP 5
 122: PUSH
 123: LD_INT 2
 125: PUSH
 126: LD_INT 2
 128: PUSH
 129: LD_INT 2
 131: PUSH
 132: LD_INT 2
 134: PUSH
 135: EMPTY
 136: LIST
 137: LIST
 138: LIST
 139: LIST
 140: ST_TO_ADDR
// animalsAgression = [ rand ( - 5 , 5 ) ] ;
 141: LD_ADDR_EXP 6
 145: PUSH
 146: LD_INT 5
 148: NEG
 149: PPUSH
 150: LD_INT 5
 152: PPUSH
 153: CALL_OW 12
 157: PUSH
 158: EMPTY
 159: LIST
 160: ST_TO_ADDR
// debugMode = 0 ;
 161: LD_ADDR_EXP 9
 165: PUSH
 166: LD_INT 0
 168: ST_TO_ADDR
// missionPrefix = 05_ ;
 169: LD_ADDR_EXP 7
 173: PUSH
 174: LD_STRING 05_
 176: ST_TO_ADDR
// previousMissionPrefix = 04_ ;
 177: LD_ADDR_EXP 8
 181: PUSH
 182: LD_STRING 04_
 184: ST_TO_ADDR
// end ;
 185: LD_VAR 0 1
 189: RET
// export enemySkillLevel , arabBreakthrough ; function MissionMapConfig ; begin
 190: LD_INT 0
 192: PPUSH
// enemySkillLevel = [ 1 , 2 , 3 ] [ Difficulty ] ;
 193: LD_ADDR_EXP 10
 197: PUSH
 198: LD_INT 1
 200: PUSH
 201: LD_INT 2
 203: PUSH
 204: LD_INT 3
 206: PUSH
 207: EMPTY
 208: LIST
 209: LIST
 210: LIST
 211: PUSH
 212: LD_OWVAR 67
 216: ARRAY
 217: ST_TO_ADDR
// arabBreakthrough = [ 100 100$0 , 100 100$0 , 100 100$0 ] ;
 218: LD_ADDR_EXP 11
 222: PUSH
 223: LD_INT 210000
 225: PUSH
 226: LD_INT 210000
 228: PUSH
 229: LD_INT 210000
 231: PUSH
 232: EMPTY
 233: LIST
 234: LIST
 235: LIST
 236: ST_TO_ADDR
// end ;
 237: LD_VAR 0 1
 241: RET
// every 0 0$1 trigger debugMode do var i ;
 242: LD_EXP 9
 246: IFFALSE 592
 248: GO 250
 250: DISABLE
 251: LD_INT 0
 253: PPUSH
// begin enable ;
 254: ENABLE
// Display_strings = [ #Ru03-1 , counter_test ] ;
 255: LD_ADDR_OWVAR 47
 259: PUSH
 260: LD_STRING #Ru03-1
 262: PUSH
 263: LD_EXP 3
 267: PUSH
 268: EMPTY
 269: LIST
 270: LIST
 271: ST_TO_ADDR
// counter_test = counter_test + 0 0$01 ;
 272: LD_ADDR_EXP 3
 276: PUSH
 277: LD_EXP 3
 281: PUSH
 282: LD_INT 35
 284: PLUS
 285: ST_TO_ADDR
// FogOff ( your_side ) ;
 286: LD_OWVAR 2
 290: PPUSH
 291: CALL_OW 344
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) do
 295: LD_ADDR_VAR 0 1
 299: PUSH
 300: LD_INT 22
 302: PUSH
 303: LD_OWVAR 2
 307: PUSH
 308: EMPTY
 309: LIST
 310: LIST
 311: PUSH
 312: LD_INT 2
 314: PUSH
 315: LD_INT 21
 317: PUSH
 318: LD_INT 1
 320: PUSH
 321: EMPTY
 322: LIST
 323: LIST
 324: PUSH
 325: LD_INT 21
 327: PUSH
 328: LD_INT 2
 330: PUSH
 331: EMPTY
 332: LIST
 333: LIST
 334: PUSH
 335: EMPTY
 336: LIST
 337: LIST
 338: LIST
 339: PUSH
 340: EMPTY
 341: LIST
 342: LIST
 343: PPUSH
 344: CALL_OW 69
 348: PUSH
 349: FOR_IN
 350: IFFALSE 366
// SetLives ( i , 1000 ) ;
 352: LD_VAR 0 1
 356: PPUSH
 357: LD_INT 1000
 359: PPUSH
 360: CALL_OW 234
 364: GO 349
 366: POP
 367: POP
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) do
 368: LD_ADDR_VAR 0 1
 372: PUSH
 373: LD_INT 22
 375: PUSH
 376: LD_OWVAR 2
 380: PUSH
 381: EMPTY
 382: LIST
 383: LIST
 384: PUSH
 385: LD_INT 21
 387: PUSH
 388: LD_INT 1
 390: PUSH
 391: EMPTY
 392: LIST
 393: LIST
 394: PUSH
 395: EMPTY
 396: LIST
 397: LIST
 398: PPUSH
 399: CALL_OW 69
 403: PUSH
 404: FOR_IN
 405: IFFALSE 469
// begin SetSkill ( i , skill_combat , 10 ) ;
 407: LD_VAR 0 1
 411: PPUSH
 412: LD_INT 1
 414: PPUSH
 415: LD_INT 10
 417: PPUSH
 418: CALL_OW 237
// SetSkill ( i , skill_engineering , 10 ) ;
 422: LD_VAR 0 1
 426: PPUSH
 427: LD_INT 2
 429: PPUSH
 430: LD_INT 10
 432: PPUSH
 433: CALL_OW 237
// SetSkill ( i , skill_mechanical , 10 ) ;
 437: LD_VAR 0 1
 441: PPUSH
 442: LD_INT 3
 444: PPUSH
 445: LD_INT 10
 447: PPUSH
 448: CALL_OW 237
// SetSkill ( i , skill_scientistic , 10 ) ;
 452: LD_VAR 0 1
 456: PPUSH
 457: LD_INT 4
 459: PPUSH
 460: LD_INT 10
 462: PPUSH
 463: CALL_OW 237
// end ;
 467: GO 404
 469: POP
 470: POP
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) do
 471: LD_ADDR_VAR 0 1
 475: PUSH
 476: LD_INT 22
 478: PUSH
 479: LD_OWVAR 2
 483: PUSH
 484: EMPTY
 485: LIST
 486: LIST
 487: PUSH
 488: LD_INT 2
 490: PUSH
 491: LD_INT 30
 493: PUSH
 494: LD_INT 0
 496: PUSH
 497: EMPTY
 498: LIST
 499: LIST
 500: PUSH
 501: LD_INT 30
 503: PUSH
 504: LD_INT 1
 506: PUSH
 507: EMPTY
 508: LIST
 509: LIST
 510: PUSH
 511: EMPTY
 512: LIST
 513: LIST
 514: LIST
 515: PUSH
 516: EMPTY
 517: LIST
 518: LIST
 519: PPUSH
 520: CALL_OW 69
 524: PUSH
 525: FOR_IN
 526: IFFALSE 590
// begin SetResourceType ( GetBase ( i ) , mat_cans , 9999 ) ;
 528: LD_VAR 0 1
 532: PPUSH
 533: CALL_OW 274
 537: PPUSH
 538: LD_INT 1
 540: PPUSH
 541: LD_INT 9999
 543: PPUSH
 544: CALL_OW 277
// SetResourceType ( GetBase ( i ) , mat_oil , 9999 ) ;
 548: LD_VAR 0 1
 552: PPUSH
 553: CALL_OW 274
 557: PPUSH
 558: LD_INT 2
 560: PPUSH
 561: LD_INT 9999
 563: PPUSH
 564: CALL_OW 277
// SetResourceType ( GetBase ( i ) , mat_siberit , 9999 ) ;
 568: LD_VAR 0 1
 572: PPUSH
 573: CALL_OW 274
 577: PPUSH
 578: LD_INT 3
 580: PPUSH
 581: LD_INT 9999
 583: PPUSH
 584: CALL_OW 277
// end ;
 588: GO 525
 590: POP
 591: POP
// end ; end_of_file
 592: PPOPN 1
 594: END
// export Burlak , Karamazov , Petrovova , Gleb , Petrosyan , Titov , Dolgov , Lipshchin ; export Platonov ; export ruCars ; export function PrepareRussians ; begin
 595: LD_INT 0
 597: PPUSH
// PrepareHeroes ;
 598: CALL 607 0 0
// end ;
 602: LD_VAR 0 1
 606: RET
// function PrepareHeroes ; var i , car ; begin
 607: LD_INT 0
 609: PPUSH
 610: PPUSH
 611: PPUSH
// ruCars = [ ] ;
 612: LD_ADDR_EXP 21
 616: PUSH
 617: EMPTY
 618: ST_TO_ADDR
// uc_side = 3 ;
 619: LD_ADDR_OWVAR 20
 623: PUSH
 624: LD_INT 3
 626: ST_TO_ADDR
// uc_nation = 3 ;
 627: LD_ADDR_OWVAR 21
 631: PUSH
 632: LD_INT 3
 634: ST_TO_ADDR
// Burlak := PrepareUnitExt ( Burlak , true , class_mechanic ) ;
 635: LD_ADDR_EXP 12
 639: PUSH
 640: LD_STRING Burlak
 642: PPUSH
 643: LD_INT 1
 645: PPUSH
 646: LD_INT 3
 648: PPUSH
 649: CALL 1760 0 3
 653: ST_TO_ADDR
// Titov := PrepareUnitExt ( Titov , false , class_soldier ) ;
 654: LD_ADDR_EXP 17
 658: PUSH
 659: LD_STRING Titov
 661: PPUSH
 662: LD_INT 0
 664: PPUSH
 665: LD_INT 1
 667: PPUSH
 668: CALL 1760 0 3
 672: ST_TO_ADDR
// Dolgov := PrepareUnitExt ( Dolgov , false , class_scientistic ) ;
 673: LD_ADDR_EXP 18
 677: PUSH
 678: LD_STRING Dolgov
 680: PPUSH
 681: LD_INT 0
 683: PPUSH
 684: LD_INT 4
 686: PPUSH
 687: CALL 1760 0 3
 691: ST_TO_ADDR
// Lipshchin := PrepareUnitExt ( Lipshchin , false , class_soldier ) ;
 692: LD_ADDR_EXP 19
 696: PUSH
 697: LD_STRING Lipshchin
 699: PPUSH
 700: LD_INT 0
 702: PPUSH
 703: LD_INT 1
 705: PPUSH
 706: CALL 1760 0 3
 710: ST_TO_ADDR
// Karamazov := PrepareUnitExt ( Karamazov , false , class_engineer ) ;
 711: LD_ADDR_EXP 13
 715: PUSH
 716: LD_STRING Karamazov
 718: PPUSH
 719: LD_INT 0
 721: PPUSH
 722: LD_INT 2
 724: PPUSH
 725: CALL 1760 0 3
 729: ST_TO_ADDR
// Petrovova := PrepareUnitExt ( Petrovova , false , class_soldier ) ;
 730: LD_ADDR_EXP 14
 734: PUSH
 735: LD_STRING Petrovova
 737: PPUSH
 738: LD_INT 0
 740: PPUSH
 741: LD_INT 1
 743: PPUSH
 744: CALL 1760 0 3
 748: ST_TO_ADDR
// Gleb := PrepareUnitExt ( Gleb , false , class_soldier ) ;
 749: LD_ADDR_EXP 15
 753: PUSH
 754: LD_STRING Gleb
 756: PPUSH
 757: LD_INT 0
 759: PPUSH
 760: LD_INT 1
 762: PPUSH
 763: CALL 1760 0 3
 767: ST_TO_ADDR
// Petrosyan := PrepareUnitExt ( Petrosyan , false , class_scientistic ) ;
 768: LD_ADDR_EXP 16
 772: PUSH
 773: LD_STRING Petrosyan
 775: PPUSH
 776: LD_INT 0
 778: PPUSH
 779: LD_INT 4
 781: PPUSH
 782: CALL 1760 0 3
 786: ST_TO_ADDR
// Platonov = PrepareUnitExt ( Platonov , false , 0 ) ;
 787: LD_ADDR_EXP 20
 791: PUSH
 792: LD_STRING Platonov
 794: PPUSH
 795: LD_INT 0
 797: PPUSH
 798: LD_INT 0
 800: PPUSH
 801: CALL 1760 0 3
 805: ST_TO_ADDR
// for i := 1 to TanksFromIntro do
 806: LD_ADDR_VAR 0 2
 810: PUSH
 811: DOUBLE
 812: LD_INT 1
 814: DEC
 815: ST_TO_ADDR
 816: LD_EXP 2
 820: PUSH
 821: FOR_TO
 822: IFFALSE 1200
// begin vc_chassis := TanksFromIntro [ i ] [ 1 ] ;
 824: LD_ADDR_OWVAR 37
 828: PUSH
 829: LD_EXP 2
 833: PUSH
 834: LD_VAR 0 2
 838: ARRAY
 839: PUSH
 840: LD_INT 1
 842: ARRAY
 843: ST_TO_ADDR
// vc_engine = TanksFromIntro [ i ] [ 2 ] ;
 844: LD_ADDR_OWVAR 39
 848: PUSH
 849: LD_EXP 2
 853: PUSH
 854: LD_VAR 0 2
 858: ARRAY
 859: PUSH
 860: LD_INT 2
 862: ARRAY
 863: ST_TO_ADDR
// vc_control = TanksFromIntro [ i ] [ 3 ] ;
 864: LD_ADDR_OWVAR 38
 868: PUSH
 869: LD_EXP 2
 873: PUSH
 874: LD_VAR 0 2
 878: ARRAY
 879: PUSH
 880: LD_INT 3
 882: ARRAY
 883: ST_TO_ADDR
// vc_weapon := TanksFromIntro [ i ] [ 4 ] ;
 884: LD_ADDR_OWVAR 40
 888: PUSH
 889: LD_EXP 2
 893: PUSH
 894: LD_VAR 0 2
 898: ARRAY
 899: PUSH
 900: LD_INT 4
 902: ARRAY
 903: ST_TO_ADDR
// uc_direction := Rand ( 3 , 4 ) ;
 904: LD_ADDR_OWVAR 24
 908: PUSH
 909: LD_INT 3
 911: PPUSH
 912: LD_INT 4
 914: PPUSH
 915: CALL_OW 12
 919: ST_TO_ADDR
// vc_fuel_battery := Rand ( 25 , 40 ) ;
 920: LD_ADDR_OWVAR 41
 924: PUSH
 925: LD_INT 25
 927: PPUSH
 928: LD_INT 40
 930: PPUSH
 931: CALL_OW 12
 935: ST_TO_ADDR
// car := CreateVehicle ;
 936: LD_ADDR_VAR 0 3
 940: PUSH
 941: CALL_OW 45
 945: ST_TO_ADDR
// ruCars := ruCars ^ car ;
 946: LD_ADDR_EXP 21
 950: PUSH
 951: LD_EXP 21
 955: PUSH
 956: LD_VAR 0 3
 960: ADD
 961: ST_TO_ADDR
// case TanksFromIntro [ i ] [ 5 ] of Bur :
 962: LD_EXP 2
 966: PUSH
 967: LD_VAR 0 2
 971: ARRAY
 972: PUSH
 973: LD_INT 5
 975: ARRAY
 976: PUSH
 977: LD_STRING Bur
 979: DOUBLE
 980: EQUAL
 981: IFTRUE 985
 983: GO 1002
 985: POP
// PlaceHumanInUnit ( Burlak , car ) ; Kar :
 986: LD_EXP 12
 990: PPUSH
 991: LD_VAR 0 3
 995: PPUSH
 996: CALL_OW 52
1000: GO 1178
1002: LD_STRING Kar
1004: DOUBLE
1005: EQUAL
1006: IFTRUE 1010
1008: GO 1027
1010: POP
// PlaceHumanInUnit ( Karamazov , car ) ; Ptr :
1011: LD_EXP 13
1015: PPUSH
1016: LD_VAR 0 3
1020: PPUSH
1021: CALL_OW 52
1025: GO 1178
1027: LD_STRING Ptr
1029: DOUBLE
1030: EQUAL
1031: IFTRUE 1035
1033: GO 1052
1035: POP
// PlaceHumanInUnit ( Petrovova , car ) ; Glb :
1036: LD_EXP 14
1040: PPUSH
1041: LD_VAR 0 3
1045: PPUSH
1046: CALL_OW 52
1050: GO 1178
1052: LD_STRING Glb
1054: DOUBLE
1055: EQUAL
1056: IFTRUE 1060
1058: GO 1077
1060: POP
// PlaceHumanInUnit ( Gleb , car ) ; Pet :
1061: LD_EXP 15
1065: PPUSH
1066: LD_VAR 0 3
1070: PPUSH
1071: CALL_OW 52
1075: GO 1178
1077: LD_STRING Pet
1079: DOUBLE
1080: EQUAL
1081: IFTRUE 1085
1083: GO 1102
1085: POP
// PlaceHumanInUnit ( Petrosyan , car ) ; Dol :
1086: LD_EXP 16
1090: PPUSH
1091: LD_VAR 0 3
1095: PPUSH
1096: CALL_OW 52
1100: GO 1178
1102: LD_STRING Dol
1104: DOUBLE
1105: EQUAL
1106: IFTRUE 1110
1108: GO 1127
1110: POP
// PlaceHumanInUnit ( Dolgov , car ) ; Lip :
1111: LD_EXP 18
1115: PPUSH
1116: LD_VAR 0 3
1120: PPUSH
1121: CALL_OW 52
1125: GO 1178
1127: LD_STRING Lip
1129: DOUBLE
1130: EQUAL
1131: IFTRUE 1135
1133: GO 1152
1135: POP
// PlaceHumanInUnit ( Lipshchin , car ) ; Tit :
1136: LD_EXP 19
1140: PPUSH
1141: LD_VAR 0 3
1145: PPUSH
1146: CALL_OW 52
1150: GO 1178
1152: LD_STRING Tit
1154: DOUBLE
1155: EQUAL
1156: IFTRUE 1160
1158: GO 1177
1160: POP
// PlaceHumanInUnit ( Titov , car ) ; end ;
1161: LD_EXP 17
1165: PPUSH
1166: LD_VAR 0 3
1170: PPUSH
1171: CALL_OW 52
1175: GO 1178
1177: POP
// SetLives ( car , Rand ( 251 , 800 ) ) ;
1178: LD_VAR 0 3
1182: PPUSH
1183: LD_INT 251
1185: PPUSH
1186: LD_INT 800
1188: PPUSH
1189: CALL_OW 12
1193: PPUSH
1194: CALL_OW 234
// end ;
1198: GO 821
1200: POP
1201: POP
// for i in ruCars do
1202: LD_ADDR_VAR 0 2
1206: PUSH
1207: LD_EXP 21
1211: PUSH
1212: FOR_IN
1213: IFFALSE 1232
// PlaceUnitArea ( i , ru_place2 , false ) ;
1215: LD_VAR 0 2
1219: PPUSH
1220: LD_INT 18
1222: PPUSH
1223: LD_INT 0
1225: PPUSH
1226: CALL_OW 49
1230: GO 1212
1232: POP
1233: POP
// RevealFogArea ( 3 , co_vidi ) ;
1234: LD_INT 3
1236: PPUSH
1237: LD_INT 19
1239: PPUSH
1240: CALL_OW 332
// ComMoveToArea ( ruCars , ru_dojezd ) ;
1244: LD_EXP 21
1248: PPUSH
1249: LD_INT 3
1251: PPUSH
1252: CALL_OW 113
// wait ( 0 0$0.1 ) ;
1256: LD_INT 4
1258: PPUSH
1259: CALL_OW 67
// CenterNowOnUnits ( IsInUnit ( Burlak ) ) ;
1263: LD_EXP 12
1267: PPUSH
1268: CALL_OW 310
1272: PPUSH
1273: CALL_OW 87
// while FilterUnitsInArea ( ru_dojezd , [ [ f_side , 3 ] , [ f_type , unit_vehicle ] ] ) < 5 do
1277: LD_INT 3
1279: PPUSH
1280: LD_INT 22
1282: PUSH
1283: LD_INT 3
1285: PUSH
1286: EMPTY
1287: LIST
1288: LIST
1289: PUSH
1290: LD_INT 21
1292: PUSH
1293: LD_INT 2
1295: PUSH
1296: EMPTY
1297: LIST
1298: LIST
1299: PUSH
1300: EMPTY
1301: LIST
1302: LIST
1303: PPUSH
1304: CALL_OW 70
1308: PUSH
1309: LD_INT 5
1311: LESS
1312: IFFALSE 1337
// begin wait ( 0 0$1 ) ;
1314: LD_INT 35
1316: PPUSH
1317: CALL_OW 67
// CenterOnUnits ( IsInUnit ( Burlak ) ) ;
1321: LD_EXP 12
1325: PPUSH
1326: CALL_OW 310
1330: PPUSH
1331: CALL_OW 85
// end ;
1335: GO 1277
// end ; end_of_file end_of_file
1337: LD_VAR 0 1
1341: RET
// export function MissionIntro ; var unit , meetPositions , x ; begin
1342: LD_INT 0
1344: PPUSH
1345: PPUSH
1346: PPUSH
1347: PPUSH
// meetPositions = [ [ 66 , 87 ] , [ 66 , 86 ] , [ 67 , 86 ] , [ 69 , 87 ] , [ 70 , 88 ] , [ 71 , 89 ] , [ 72 , 90 ] , [ 72 , 91 ] ] ;
1348: LD_ADDR_VAR 0 3
1352: PUSH
1353: LD_INT 66
1355: PUSH
1356: LD_INT 87
1358: PUSH
1359: EMPTY
1360: LIST
1361: LIST
1362: PUSH
1363: LD_INT 66
1365: PUSH
1366: LD_INT 86
1368: PUSH
1369: EMPTY
1370: LIST
1371: LIST
1372: PUSH
1373: LD_INT 67
1375: PUSH
1376: LD_INT 86
1378: PUSH
1379: EMPTY
1380: LIST
1381: LIST
1382: PUSH
1383: LD_INT 69
1385: PUSH
1386: LD_INT 87
1388: PUSH
1389: EMPTY
1390: LIST
1391: LIST
1392: PUSH
1393: LD_INT 70
1395: PUSH
1396: LD_INT 88
1398: PUSH
1399: EMPTY
1400: LIST
1401: LIST
1402: PUSH
1403: LD_INT 71
1405: PUSH
1406: LD_INT 89
1408: PUSH
1409: EMPTY
1410: LIST
1411: LIST
1412: PUSH
1413: LD_INT 72
1415: PUSH
1416: LD_INT 90
1418: PUSH
1419: EMPTY
1420: LIST
1421: LIST
1422: PUSH
1423: LD_INT 72
1425: PUSH
1426: LD_INT 91
1428: PUSH
1429: EMPTY
1430: LIST
1431: LIST
1432: PUSH
1433: EMPTY
1434: LIST
1435: LIST
1436: LIST
1437: LIST
1438: LIST
1439: LIST
1440: LIST
1441: LIST
1442: ST_TO_ADDR
// wait ( 0 0$8 ) ;
1443: LD_INT 280
1445: PPUSH
1446: CALL_OW 67
// Say ( Burlak , DStart-Bur-1 ) ;
1450: LD_EXP 12
1454: PPUSH
1455: LD_STRING DStart-Bur-1
1457: PPUSH
1458: CALL_OW 88
// SayRadio ( Platonov , DStart-Pla-1 ) ;
1462: LD_EXP 20
1466: PPUSH
1467: LD_STRING DStart-Pla-1
1469: PPUSH
1470: CALL_OW 94
// Say ( Burlak , DStart-Bur-2 ) ;
1474: LD_EXP 12
1478: PPUSH
1479: LD_STRING DStart-Bur-2
1481: PPUSH
1482: CALL_OW 88
// SayRadio ( Platonov , DStart-Pla-2 ) ;
1486: LD_EXP 20
1490: PPUSH
1491: LD_STRING DStart-Pla-2
1493: PPUSH
1494: CALL_OW 94
// x = 0 ;
1498: LD_ADDR_VAR 0 4
1502: PUSH
1503: LD_INT 0
1505: ST_TO_ADDR
// for unit in FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) do
1506: LD_ADDR_VAR 0 2
1510: PUSH
1511: LD_INT 22
1513: PUSH
1514: LD_INT 3
1516: PUSH
1517: EMPTY
1518: LIST
1519: LIST
1520: PUSH
1521: LD_INT 21
1523: PUSH
1524: LD_INT 1
1526: PUSH
1527: EMPTY
1528: LIST
1529: LIST
1530: PUSH
1531: EMPTY
1532: LIST
1533: LIST
1534: PPUSH
1535: CALL_OW 69
1539: PUSH
1540: FOR_IN
1541: IFFALSE 1629
// begin ComExitVehicle ( unit ) ;
1543: LD_VAR 0 2
1547: PPUSH
1548: CALL_OW 121
// wait ( 0 0$1 ) ;
1552: LD_INT 35
1554: PPUSH
1555: CALL_OW 67
// AddComMoveXY ( unit , meetPositions [ x ] [ 1 ] , meetPositions [ x ] [ 2 ] ) ;
1559: LD_VAR 0 2
1563: PPUSH
1564: LD_VAR 0 3
1568: PUSH
1569: LD_VAR 0 4
1573: ARRAY
1574: PUSH
1575: LD_INT 1
1577: ARRAY
1578: PPUSH
1579: LD_VAR 0 3
1583: PUSH
1584: LD_VAR 0 4
1588: ARRAY
1589: PUSH
1590: LD_INT 2
1592: ARRAY
1593: PPUSH
1594: CALL_OW 171
// AddComTurnXY ( unit , 69 , 96 ) ;
1598: LD_VAR 0 2
1602: PPUSH
1603: LD_INT 69
1605: PPUSH
1606: LD_INT 96
1608: PPUSH
1609: CALL_OW 178
// x = x + 1 ;
1613: LD_ADDR_VAR 0 4
1617: PUSH
1618: LD_VAR 0 4
1622: PUSH
1623: LD_INT 1
1625: PLUS
1626: ST_TO_ADDR
// end ;
1627: GO 1540
1629: POP
1630: POP
// repeat CenterNowOnUnits ( Burlak ) ;
1631: LD_EXP 12
1635: PPUSH
1636: CALL_OW 87
// wait ( 10 ) ;
1640: LD_INT 10
1642: PPUSH
1643: CALL_OW 67
// until GetDistUnitXY ( Burlak , 70 , 90 ) < 7 ;
1647: LD_EXP 12
1651: PPUSH
1652: LD_INT 70
1654: PPUSH
1655: LD_INT 90
1657: PPUSH
1658: CALL_OW 297
1662: PUSH
1663: LD_INT 7
1665: LESS
1666: IFFALSE 1631
// Say ( Karamazov , DDoubts-Kar-1 ) ;
1668: LD_EXP 13
1672: PPUSH
1673: LD_STRING DDoubts-Kar-1
1675: PPUSH
1676: CALL_OW 88
// Say ( Petrovova , DDoubts-Ptr-1 ) ;
1680: LD_EXP 14
1684: PPUSH
1685: LD_STRING DDoubts-Ptr-1
1687: PPUSH
1688: CALL_OW 88
// Say ( Lipshchin , DDoubts-Bur-1 ) ;
1692: LD_EXP 19
1696: PPUSH
1697: LD_STRING DDoubts-Bur-1
1699: PPUSH
1700: CALL_OW 88
// Say ( Karamazov , DDoubts-Kar-2 ) ;
1704: LD_EXP 13
1708: PPUSH
1709: LD_STRING DDoubts-Kar-2
1711: PPUSH
1712: CALL_OW 88
// Say ( Gleb , DDoubts-Glb-2 ) ;
1716: LD_EXP 15
1720: PPUSH
1721: LD_STRING DDoubts-Glb-2
1723: PPUSH
1724: CALL_OW 88
// Say ( Burlak , DDoubts-Bur-2 ) ;
1728: LD_EXP 12
1732: PPUSH
1733: LD_STRING DDoubts-Bur-2
1735: PPUSH
1736: CALL_OW 88
// InGameOff ;
1740: CALL_OW 9
// ChangeMissionObjectives ( MBegin ) ;
1744: LD_STRING MBegin
1746: PPUSH
1747: CALL_OW 337
// SaveForQuickRestart ;
1751: CALL_OW 22
// end ; end_of_file
1755: LD_VAR 0 1
1759: RET
// export function PrepareUnitExt ( ident , exist_mode , class ) ; var unit ; begin
1760: LD_INT 0
1762: PPUSH
1763: PPUSH
// if exist_mode then
1764: LD_VAR 0 2
1768: IFFALSE 1793
// unit := CreateCharacter ( previousMissionPrefix & ident ) else
1770: LD_ADDR_VAR 0 5
1774: PUSH
1775: LD_EXP 8
1779: PUSH
1780: LD_VAR 0 1
1784: STR
1785: PPUSH
1786: CALL_OW 34
1790: ST_TO_ADDR
1791: GO 1808
// unit := NewCharacter ( ident ) ;
1793: LD_ADDR_VAR 0 5
1797: PUSH
1798: LD_VAR 0 1
1802: PPUSH
1803: CALL_OW 25
1807: ST_TO_ADDR
// if class then
1808: LD_VAR 0 3
1812: IFFALSE 1828
// SetClass ( unit , class ) ;
1814: LD_VAR 0 5
1818: PPUSH
1819: LD_VAR 0 3
1823: PPUSH
1824: CALL_OW 336
// result := unit ;
1828: LD_ADDR_VAR 0 4
1832: PUSH
1833: LD_VAR 0 5
1837: ST_TO_ADDR
// end ;
1838: LD_VAR 0 4
1842: RET
// export function ExtSaveCharacter ( character , characterStringID , side ) ; begin
1843: LD_INT 0
1845: PPUSH
// if GetSide ( character ) = side and IsOK ( character ) then
1846: LD_VAR 0 1
1850: PPUSH
1851: CALL_OW 255
1855: PUSH
1856: LD_VAR 0 3
1860: EQUAL
1861: PUSH
1862: LD_VAR 0 1
1866: PPUSH
1867: CALL_OW 302
1871: AND
1872: IFFALSE 1894
// SaveCharacters ( character , missionPrefix & characterStringID ) ;
1874: LD_VAR 0 1
1878: PPUSH
1879: LD_EXP 7
1883: PUSH
1884: LD_VAR 0 2
1888: STR
1889: PPUSH
1890: CALL_OW 38
// end ;
1894: LD_VAR 0 4
1898: RET
// export function ExtSaveCharacters ( characters , charactersStringID , side ) ; var unit , resultCharactersToSave ; begin
1899: LD_INT 0
1901: PPUSH
1902: PPUSH
1903: PPUSH
// resultCharactersToSave = [ ] ;
1904: LD_ADDR_VAR 0 6
1908: PUSH
1909: EMPTY
1910: ST_TO_ADDR
// for unit in characters do
1911: LD_ADDR_VAR 0 5
1915: PUSH
1916: LD_VAR 0 1
1920: PUSH
1921: FOR_IN
1922: IFFALSE 1970
// if GetSide ( unit ) = side and IsOK ( unit ) then
1924: LD_VAR 0 5
1928: PPUSH
1929: CALL_OW 255
1933: PUSH
1934: LD_VAR 0 3
1938: EQUAL
1939: PUSH
1940: LD_VAR 0 5
1944: PPUSH
1945: CALL_OW 302
1949: AND
1950: IFFALSE 1968
// resultCharactersToSave = resultCharactersToSave ^ unit ;
1952: LD_ADDR_VAR 0 6
1956: PUSH
1957: LD_VAR 0 6
1961: PUSH
1962: LD_VAR 0 5
1966: ADD
1967: ST_TO_ADDR
1968: GO 1921
1970: POP
1971: POP
// SaveCharacters ( resultCharactersToSave , missionPrefix & charactersStringID ) ;
1972: LD_VAR 0 6
1976: PPUSH
1977: LD_EXP 7
1981: PUSH
1982: LD_VAR 0 2
1986: STR
1987: PPUSH
1988: CALL_OW 38
// end ; end_of_file
1992: LD_VAR 0 4
1996: RET
// on BuildingComplete ( building ) do begin if GetSide ( building ) = 3 and GetBType ( building ) = b_depot then
1997: LD_VAR 0 1
2001: PPUSH
2002: CALL_OW 255
2006: PUSH
2007: LD_INT 3
2009: EQUAL
2010: PUSH
2011: LD_VAR 0 1
2015: PPUSH
2016: CALL_OW 266
2020: PUSH
2021: LD_INT 0
2023: EQUAL
2024: AND
2025: IFFALSE 2039
// SetBname ( building , bukharin ) ;
2027: LD_VAR 0 1
2031: PPUSH
2032: LD_STRING bukharin
2034: PPUSH
2035: CALL_OW 500
// end ; end_of_file end_of_file end_of_file end_of_file
2039: PPOPN 1
2041: END
// export function Nef_PrepareNature ; var i , un ; begin
2042: LD_INT 0
2044: PPUSH
2045: PPUSH
2046: PPUSH
// for i := 1 to animalsAmount [ 1 ] do
2047: LD_ADDR_VAR 0 2
2051: PUSH
2052: DOUBLE
2053: LD_INT 1
2055: DEC
2056: ST_TO_ADDR
2057: LD_EXP 4
2061: PUSH
2062: LD_INT 1
2064: ARRAY
2065: PUSH
2066: FOR_TO
2067: IFFALSE 2177
// begin uc_side = 0 ;
2069: LD_ADDR_OWVAR 20
2073: PUSH
2074: LD_INT 0
2076: ST_TO_ADDR
// uc_nation = nation_nature ;
2077: LD_ADDR_OWVAR 21
2081: PUSH
2082: LD_INT 0
2084: ST_TO_ADDR
// hc_class = class_apeman ;
2085: LD_ADDR_OWVAR 28
2089: PUSH
2090: LD_INT 12
2092: ST_TO_ADDR
// hc_skills = [ animalsStats [ 1 ] , animalsStats [ 2 ] , animalsStats [ 3 ] , animalsStats [ 4 ] ] ;
2093: LD_ADDR_OWVAR 31
2097: PUSH
2098: LD_EXP 5
2102: PUSH
2103: LD_INT 1
2105: ARRAY
2106: PUSH
2107: LD_EXP 5
2111: PUSH
2112: LD_INT 2
2114: ARRAY
2115: PUSH
2116: LD_EXP 5
2120: PUSH
2121: LD_INT 3
2123: ARRAY
2124: PUSH
2125: LD_EXP 5
2129: PUSH
2130: LD_INT 4
2132: ARRAY
2133: PUSH
2134: EMPTY
2135: LIST
2136: LIST
2137: LIST
2138: LIST
2139: ST_TO_ADDR
// hc_agressivity = animalsAgression ;
2140: LD_ADDR_OWVAR 35
2144: PUSH
2145: LD_EXP 6
2149: ST_TO_ADDR
// un = CreateHuman ;
2150: LD_ADDR_VAR 0 3
2154: PUSH
2155: CALL_OW 44
2159: ST_TO_ADDR
// PlaceUnitArea ( un , NatureArea , false ) ;
2160: LD_VAR 0 3
2164: PPUSH
2165: LD_INT 33
2167: PPUSH
2168: LD_INT 0
2170: PPUSH
2171: CALL_OW 49
// end ;
2175: GO 2066
2177: POP
2178: POP
// for i := 1 to animalsAmount [ 2 ] do
2179: LD_ADDR_VAR 0 2
2183: PUSH
2184: DOUBLE
2185: LD_INT 1
2187: DEC
2188: ST_TO_ADDR
2189: LD_EXP 4
2193: PUSH
2194: LD_INT 2
2196: ARRAY
2197: PUSH
2198: FOR_TO
2199: IFFALSE 2309
// begin uc_side = 0 ;
2201: LD_ADDR_OWVAR 20
2205: PUSH
2206: LD_INT 0
2208: ST_TO_ADDR
// uc_nation = nation_nature ;
2209: LD_ADDR_OWVAR 21
2213: PUSH
2214: LD_INT 0
2216: ST_TO_ADDR
// hc_class = class_phororhacos ;
2217: LD_ADDR_OWVAR 28
2221: PUSH
2222: LD_INT 18
2224: ST_TO_ADDR
// hc_skills = [ animalsStats [ 1 ] , animalsStats [ 2 ] , animalsStats [ 3 ] , animalsStats [ 4 ] ] ;
2225: LD_ADDR_OWVAR 31
2229: PUSH
2230: LD_EXP 5
2234: PUSH
2235: LD_INT 1
2237: ARRAY
2238: PUSH
2239: LD_EXP 5
2243: PUSH
2244: LD_INT 2
2246: ARRAY
2247: PUSH
2248: LD_EXP 5
2252: PUSH
2253: LD_INT 3
2255: ARRAY
2256: PUSH
2257: LD_EXP 5
2261: PUSH
2262: LD_INT 4
2264: ARRAY
2265: PUSH
2266: EMPTY
2267: LIST
2268: LIST
2269: LIST
2270: LIST
2271: ST_TO_ADDR
// hc_agressivity = animalsAgression ;
2272: LD_ADDR_OWVAR 35
2276: PUSH
2277: LD_EXP 6
2281: ST_TO_ADDR
// un = CreateHuman ;
2282: LD_ADDR_VAR 0 3
2286: PUSH
2287: CALL_OW 44
2291: ST_TO_ADDR
// PlaceUnitArea ( un , NatureArea , false ) ;
2292: LD_VAR 0 3
2296: PPUSH
2297: LD_INT 33
2299: PPUSH
2300: LD_INT 0
2302: PPUSH
2303: CALL_OW 49
// end ;
2307: GO 2198
2309: POP
2310: POP
// for i := 1 to animalsAmount [ 3 ] do
2311: LD_ADDR_VAR 0 2
2315: PUSH
2316: DOUBLE
2317: LD_INT 1
2319: DEC
2320: ST_TO_ADDR
2321: LD_EXP 4
2325: PUSH
2326: LD_INT 3
2328: ARRAY
2329: PUSH
2330: FOR_TO
2331: IFFALSE 2441
// begin uc_side = 0 ;
2333: LD_ADDR_OWVAR 20
2337: PUSH
2338: LD_INT 0
2340: ST_TO_ADDR
// uc_nation = nation_nature ;
2341: LD_ADDR_OWVAR 21
2345: PUSH
2346: LD_INT 0
2348: ST_TO_ADDR
// hc_class = class_tiger ;
2349: LD_ADDR_OWVAR 28
2353: PUSH
2354: LD_INT 14
2356: ST_TO_ADDR
// hc_skills = [ animalsStats [ 1 ] , animalsStats [ 2 ] , animalsStats [ 3 ] , animalsStats [ 4 ] ] ;
2357: LD_ADDR_OWVAR 31
2361: PUSH
2362: LD_EXP 5
2366: PUSH
2367: LD_INT 1
2369: ARRAY
2370: PUSH
2371: LD_EXP 5
2375: PUSH
2376: LD_INT 2
2378: ARRAY
2379: PUSH
2380: LD_EXP 5
2384: PUSH
2385: LD_INT 3
2387: ARRAY
2388: PUSH
2389: LD_EXP 5
2393: PUSH
2394: LD_INT 4
2396: ARRAY
2397: PUSH
2398: EMPTY
2399: LIST
2400: LIST
2401: LIST
2402: LIST
2403: ST_TO_ADDR
// hc_agressivity = animalsAgression ;
2404: LD_ADDR_OWVAR 35
2408: PUSH
2409: LD_EXP 6
2413: ST_TO_ADDR
// un = CreateHuman ;
2414: LD_ADDR_VAR 0 3
2418: PUSH
2419: CALL_OW 44
2423: ST_TO_ADDR
// PlaceUnitArea ( un , NatureArea , false ) ;
2424: LD_VAR 0 3
2428: PPUSH
2429: LD_INT 33
2431: PPUSH
2432: LD_INT 0
2434: PPUSH
2435: CALL_OW 49
// end ;
2439: GO 2330
2441: POP
2442: POP
// for i := 1 to animalsAmount [ 4 ] do
2443: LD_ADDR_VAR 0 2
2447: PUSH
2448: DOUBLE
2449: LD_INT 1
2451: DEC
2452: ST_TO_ADDR
2453: LD_EXP 4
2457: PUSH
2458: LD_INT 4
2460: ARRAY
2461: PUSH
2462: FOR_TO
2463: IFFALSE 2573
// begin uc_side = 0 ;
2465: LD_ADDR_OWVAR 20
2469: PUSH
2470: LD_INT 0
2472: ST_TO_ADDR
// uc_nation = nation_nature ;
2473: LD_ADDR_OWVAR 21
2477: PUSH
2478: LD_INT 0
2480: ST_TO_ADDR
// hc_class = 21 ;
2481: LD_ADDR_OWVAR 28
2485: PUSH
2486: LD_INT 21
2488: ST_TO_ADDR
// hc_skills = [ animalsStats [ 1 ] , animalsStats [ 2 ] , animalsStats [ 3 ] , animalsStats [ 4 ] ] ;
2489: LD_ADDR_OWVAR 31
2493: PUSH
2494: LD_EXP 5
2498: PUSH
2499: LD_INT 1
2501: ARRAY
2502: PUSH
2503: LD_EXP 5
2507: PUSH
2508: LD_INT 2
2510: ARRAY
2511: PUSH
2512: LD_EXP 5
2516: PUSH
2517: LD_INT 3
2519: ARRAY
2520: PUSH
2521: LD_EXP 5
2525: PUSH
2526: LD_INT 4
2528: ARRAY
2529: PUSH
2530: EMPTY
2531: LIST
2532: LIST
2533: LIST
2534: LIST
2535: ST_TO_ADDR
// hc_agressivity = animalsAgression ;
2536: LD_ADDR_OWVAR 35
2540: PUSH
2541: LD_EXP 6
2545: ST_TO_ADDR
// un = CreateHuman ;
2546: LD_ADDR_VAR 0 3
2550: PUSH
2551: CALL_OW 44
2555: ST_TO_ADDR
// PlaceUnitArea ( un , NatureArea , false ) ;
2556: LD_VAR 0 3
2560: PPUSH
2561: LD_INT 33
2563: PPUSH
2564: LD_INT 0
2566: PPUSH
2567: CALL_OW 49
// end ;
2571: GO 2462
2573: POP
2574: POP
// for i := 1 to animalsAmount [ 5 ] do
2575: LD_ADDR_VAR 0 2
2579: PUSH
2580: DOUBLE
2581: LD_INT 1
2583: DEC
2584: ST_TO_ADDR
2585: LD_EXP 4
2589: PUSH
2590: LD_INT 5
2592: ARRAY
2593: PUSH
2594: FOR_TO
2595: IFFALSE 2656
// begin uc_side = 0 ;
2597: LD_ADDR_OWVAR 20
2601: PUSH
2602: LD_INT 0
2604: ST_TO_ADDR
// uc_nation = nation_nature ;
2605: LD_ADDR_OWVAR 21
2609: PUSH
2610: LD_INT 0
2612: ST_TO_ADDR
// vc_chassis := 31 ;
2613: LD_ADDR_OWVAR 37
2617: PUSH
2618: LD_INT 31
2620: ST_TO_ADDR
// vc_control := control_rider ;
2621: LD_ADDR_OWVAR 38
2625: PUSH
2626: LD_INT 4
2628: ST_TO_ADDR
// un := CreateVehicle ;
2629: LD_ADDR_VAR 0 3
2633: PUSH
2634: CALL_OW 45
2638: ST_TO_ADDR
// PlaceUnitArea ( un , NatureArea , false ) ;
2639: LD_VAR 0 3
2643: PPUSH
2644: LD_INT 33
2646: PPUSH
2647: LD_INT 0
2649: PPUSH
2650: CALL_OW 49
// end ;
2654: GO 2594
2656: POP
2657: POP
// end ; end_of_file
2658: LD_VAR 0 1
2662: RET
// export function SA_EndMission ( campaignNumber , missionNumber , medal1 , medal2 , medal3 ) ; var achiv ; begin
2663: LD_INT 0
2665: PPUSH
2666: PPUSH
// if not missionNumber then
2667: LD_VAR 0 2
2671: NOT
2672: IFFALSE 2676
// exit ;
2674: GO 2806
// achiv := false ;
2676: LD_ADDR_VAR 0 7
2680: PUSH
2681: LD_INT 0
2683: ST_TO_ADDR
// case campaignNumber of 1 :
2684: LD_VAR 0 1
2688: PUSH
2689: LD_INT 1
2691: DOUBLE
2692: EQUAL
2693: IFTRUE 2697
2695: GO 2708
2697: POP
// achiv := ACH_GOTA ; 2 :
2698: LD_ADDR_VAR 0 7
2702: PUSH
2703: LD_STRING ACH_GOTA
2705: ST_TO_ADDR
2706: GO 2758
2708: LD_INT 2
2710: DOUBLE
2711: EQUAL
2712: IFTRUE 2716
2714: GO 2719
2716: POP
// ; 3 :
2717: GO 2758
2719: LD_INT 3
2721: DOUBLE
2722: EQUAL
2723: IFTRUE 2727
2725: GO 2738
2727: POP
// achiv := ACH_MOTSU ; 4 :
2728: LD_ADDR_VAR 0 7
2732: PUSH
2733: LD_STRING ACH_MOTSU
2735: ST_TO_ADDR
2736: GO 2758
2738: LD_INT 4
2740: DOUBLE
2741: EQUAL
2742: IFTRUE 2746
2744: GO 2757
2746: POP
// achiv := ACH_LOP ; end ;
2747: LD_ADDR_VAR 0 7
2751: PUSH
2752: LD_STRING ACH_LOP
2754: ST_TO_ADDR
2755: GO 2758
2757: POP
// if Difficulty = 3 and achiv and medal1 and medal2 and medal3 then
2758: LD_OWVAR 67
2762: PUSH
2763: LD_INT 3
2765: EQUAL
2766: PUSH
2767: LD_VAR 0 7
2771: AND
2772: PUSH
2773: LD_VAR 0 3
2777: AND
2778: PUSH
2779: LD_VAR 0 4
2783: AND
2784: PUSH
2785: LD_VAR 0 5
2789: AND
2790: IFFALSE 2806
// SetAchievementEX ( achiv , missionNumber ) ;
2792: LD_VAR 0 7
2796: PPUSH
2797: LD_VAR 0 2
2801: PPUSH
2802: CALL_OW 564
// end ;
2806: LD_VAR 0 6
2810: RET
// export function SA_BehemothConstructed ; begin
2811: LD_INT 0
2813: PPUSH
// SetAchievement ( ACH_SMC ) ;
2814: LD_STRING ACH_SMC
2816: PPUSH
2817: CALL_OW 543
// end ;
2821: LD_VAR 0 1
2825: RET
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin case p2 of 1 :
2826: LD_VAR 0 2
2830: PUSH
2831: LD_INT 1
2833: DOUBLE
2834: EQUAL
2835: IFTRUE 2839
2837: GO 2846
2839: POP
// HackUnlimitedResources ; 2 :
2840: CALL 3030 0 0
2844: GO 3027
2846: LD_INT 2
2848: DOUBLE
2849: EQUAL
2850: IFTRUE 2854
2852: GO 2861
2854: POP
// HackSetLevel10 ; 3 :
2855: CALL 3163 0 0
2859: GO 3027
2861: LD_INT 3
2863: DOUBLE
2864: EQUAL
2865: IFTRUE 2869
2867: GO 2876
2869: POP
// HackSetLevel10YourUnits ; 4 :
2870: CALL 3248 0 0
2874: GO 3027
2876: LD_INT 4
2878: DOUBLE
2879: EQUAL
2880: IFTRUE 2884
2882: GO 2906
2884: POP
// HackSpawnHuman ( p3 , p4 , p5 ) ; 5 :
2885: LD_VAR 0 3
2889: PPUSH
2890: LD_VAR 0 4
2894: PPUSH
2895: LD_VAR 0 5
2899: PPUSH
2900: CALL 3338 0 3
2904: GO 3027
2906: LD_INT 5
2908: DOUBLE
2909: EQUAL
2910: IFTRUE 2914
2912: GO 2921
2914: POP
// HackSpawnVehicle ; 6 :
2915: CALL 3399 0 0
2919: GO 3027
2921: LD_INT 6
2923: DOUBLE
2924: EQUAL
2925: IFTRUE 2929
2927: GO 2936
2929: POP
// HackInvincible ; 7 :
2930: CALL 3945 0 0
2934: GO 3027
2936: LD_INT 7
2938: DOUBLE
2939: EQUAL
2940: IFTRUE 2944
2942: GO 2951
2944: POP
// HackInvisible ; 8 :
2945: CALL 4056 0 0
2949: GO 3027
2951: LD_INT 8
2953: DOUBLE
2954: EQUAL
2955: IFTRUE 2959
2957: GO 2966
2959: POP
// HackChangeYourSide ; 9 :
2960: CALL 4113 0 0
2964: GO 3027
2966: LD_INT 9
2968: DOUBLE
2969: EQUAL
2970: IFTRUE 2974
2972: GO 2981
2974: POP
// HackChangeUnitSide ; 10 :
2975: CALL 4155 0 0
2979: GO 3027
2981: LD_INT 10
2983: DOUBLE
2984: EQUAL
2985: IFTRUE 2989
2987: GO 2996
2989: POP
// HackFog ; 11 :
2990: CALL 4256 0 0
2994: GO 3027
2996: LD_INT 11
2998: DOUBLE
2999: EQUAL
3000: IFTRUE 3004
3002: GO 3011
3004: POP
// HackApeman ; 12 :
3005: CALL 4271 0 0
3009: GO 3027
3011: LD_INT 12
3013: DOUBLE
3014: EQUAL
3015: IFTRUE 3019
3017: GO 3026
3019: POP
// HackBoom ; end ;
3020: CALL 4356 0 0
3024: GO 3027
3026: POP
// end ;
3027: PPOPN 6
3029: END
// export function HackUnlimitedResources ; var i , j , tmp ; begin
3030: LD_INT 0
3032: PPUSH
3033: PPUSH
3034: PPUSH
3035: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
3036: LD_ADDR_VAR 0 4
3040: PUSH
3041: LD_INT 22
3043: PUSH
3044: LD_OWVAR 2
3048: PUSH
3049: EMPTY
3050: LIST
3051: LIST
3052: PUSH
3053: LD_INT 2
3055: PUSH
3056: LD_INT 30
3058: PUSH
3059: LD_INT 0
3061: PUSH
3062: EMPTY
3063: LIST
3064: LIST
3065: PUSH
3066: LD_INT 30
3068: PUSH
3069: LD_INT 1
3071: PUSH
3072: EMPTY
3073: LIST
3074: LIST
3075: PUSH
3076: EMPTY
3077: LIST
3078: LIST
3079: LIST
3080: PUSH
3081: EMPTY
3082: LIST
3083: LIST
3084: PPUSH
3085: CALL_OW 69
3089: ST_TO_ADDR
// if not tmp then
3090: LD_VAR 0 4
3094: NOT
3095: IFFALSE 3099
// exit ;
3097: GO 3158
// for i in tmp do
3099: LD_ADDR_VAR 0 2
3103: PUSH
3104: LD_VAR 0 4
3108: PUSH
3109: FOR_IN
3110: IFFALSE 3156
// for j = 1 to 3 do
3112: LD_ADDR_VAR 0 3
3116: PUSH
3117: DOUBLE
3118: LD_INT 1
3120: DEC
3121: ST_TO_ADDR
3122: LD_INT 3
3124: PUSH
3125: FOR_TO
3126: IFFALSE 3152
// SetResourceType ( GetBase ( i ) , j , 99999 ) ;
3128: LD_VAR 0 2
3132: PPUSH
3133: CALL_OW 274
3137: PPUSH
3138: LD_VAR 0 3
3142: PPUSH
3143: LD_INT 99999
3145: PPUSH
3146: CALL_OW 277
3150: GO 3125
3152: POP
3153: POP
3154: GO 3109
3156: POP
3157: POP
// end ;
3158: LD_VAR 0 1
3162: RET
// export function HackSetLevel10 ; var i , j ; begin
3163: LD_INT 0
3165: PPUSH
3166: PPUSH
3167: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
3168: LD_ADDR_VAR 0 2
3172: PUSH
3173: LD_INT 21
3175: PUSH
3176: LD_INT 1
3178: PUSH
3179: EMPTY
3180: LIST
3181: LIST
3182: PPUSH
3183: CALL_OW 69
3187: PUSH
3188: FOR_IN
3189: IFFALSE 3241
// if IsSelected ( i ) then
3191: LD_VAR 0 2
3195: PPUSH
3196: CALL_OW 306
3200: IFFALSE 3239
// begin for j := 1 to 4 do
3202: LD_ADDR_VAR 0 3
3206: PUSH
3207: DOUBLE
3208: LD_INT 1
3210: DEC
3211: ST_TO_ADDR
3212: LD_INT 4
3214: PUSH
3215: FOR_TO
3216: IFFALSE 3237
// SetSkill ( i , j , 10 ) ;
3218: LD_VAR 0 2
3222: PPUSH
3223: LD_VAR 0 3
3227: PPUSH
3228: LD_INT 10
3230: PPUSH
3231: CALL_OW 237
3235: GO 3215
3237: POP
3238: POP
// end ;
3239: GO 3188
3241: POP
3242: POP
// end ;
3243: LD_VAR 0 1
3247: RET
// export function HackSetLevel10YourUnits ; var i , j ; begin
3248: LD_INT 0
3250: PPUSH
3251: PPUSH
3252: PPUSH
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) do
3253: LD_ADDR_VAR 0 2
3257: PUSH
3258: LD_INT 22
3260: PUSH
3261: LD_OWVAR 2
3265: PUSH
3266: EMPTY
3267: LIST
3268: LIST
3269: PUSH
3270: LD_INT 21
3272: PUSH
3273: LD_INT 1
3275: PUSH
3276: EMPTY
3277: LIST
3278: LIST
3279: PUSH
3280: EMPTY
3281: LIST
3282: LIST
3283: PPUSH
3284: CALL_OW 69
3288: PUSH
3289: FOR_IN
3290: IFFALSE 3331
// begin for j := 1 to 4 do
3292: LD_ADDR_VAR 0 3
3296: PUSH
3297: DOUBLE
3298: LD_INT 1
3300: DEC
3301: ST_TO_ADDR
3302: LD_INT 4
3304: PUSH
3305: FOR_TO
3306: IFFALSE 3327
// SetSkill ( i , j , 10 ) ;
3308: LD_VAR 0 2
3312: PPUSH
3313: LD_VAR 0 3
3317: PPUSH
3318: LD_INT 10
3320: PPUSH
3321: CALL_OW 237
3325: GO 3305
3327: POP
3328: POP
// end ;
3329: GO 3289
3331: POP
3332: POP
// end ;
3333: LD_VAR 0 1
3337: RET
// export function HackSpawnHuman ( nation , class , skill ) ; begin
3338: LD_INT 0
3340: PPUSH
// uc_side := your_side ;
3341: LD_ADDR_OWVAR 20
3345: PUSH
3346: LD_OWVAR 2
3350: ST_TO_ADDR
// uc_nation := nation ;
3351: LD_ADDR_OWVAR 21
3355: PUSH
3356: LD_VAR 0 1
3360: ST_TO_ADDR
// InitHc ;
3361: CALL_OW 19
// PrepareHuman ( false , class , skill ) ;
3365: LD_INT 0
3367: PPUSH
3368: LD_VAR 0 2
3372: PPUSH
3373: LD_VAR 0 3
3377: PPUSH
3378: CALL_OW 380
// PlaceUnitAnywhere ( CreateHuman , true ) ;
3382: CALL_OW 44
3386: PPUSH
3387: LD_INT 1
3389: PPUSH
3390: CALL_OW 51
// end ;
3394: LD_VAR 0 4
3398: RET
// export function HackSpawnVehicle ; begin
3399: LD_INT 0
3401: PPUSH
// uc_side := your_side ;
3402: LD_ADDR_OWVAR 20
3406: PUSH
3407: LD_OWVAR 2
3411: ST_TO_ADDR
// uc_nation := rand ( 1 , 3 ) ;
3412: LD_ADDR_OWVAR 21
3416: PUSH
3417: LD_INT 1
3419: PPUSH
3420: LD_INT 3
3422: PPUSH
3423: CALL_OW 12
3427: ST_TO_ADDR
// InitVc ;
3428: CALL_OW 20
// case uc_nation of 1 :
3432: LD_OWVAR 21
3436: PUSH
3437: LD_INT 1
3439: DOUBLE
3440: EQUAL
3441: IFTRUE 3445
3443: GO 3589
3445: POP
// begin vc_chassis := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] [ rand ( 1 , 5 ) ] ;
3446: LD_ADDR_OWVAR 37
3450: PUSH
3451: LD_INT 1
3453: PUSH
3454: LD_INT 2
3456: PUSH
3457: LD_INT 3
3459: PUSH
3460: LD_INT 4
3462: PUSH
3463: LD_INT 5
3465: PUSH
3466: EMPTY
3467: LIST
3468: LIST
3469: LIST
3470: LIST
3471: LIST
3472: PUSH
3473: LD_INT 1
3475: PPUSH
3476: LD_INT 5
3478: PPUSH
3479: CALL_OW 12
3483: ARRAY
3484: ST_TO_ADDR
// vc_engine := rand ( 1 , 3 ) ;
3485: LD_ADDR_OWVAR 39
3489: PUSH
3490: LD_INT 1
3492: PPUSH
3493: LD_INT 3
3495: PPUSH
3496: CALL_OW 12
3500: ST_TO_ADDR
// vc_control := [ control_manual , control_remote , control_computer ] [ rand ( 1 , 3 ) ] ;
3501: LD_ADDR_OWVAR 38
3505: PUSH
3506: LD_INT 1
3508: PUSH
3509: LD_INT 2
3511: PUSH
3512: LD_INT 3
3514: PUSH
3515: EMPTY
3516: LIST
3517: LIST
3518: LIST
3519: PUSH
3520: LD_INT 1
3522: PPUSH
3523: LD_INT 3
3525: PPUSH
3526: CALL_OW 12
3530: ARRAY
3531: ST_TO_ADDR
// vc_weapon := [ us_machine_gun , us_gatling_gun , us_double_gun , us_light_gun , us_rocket_launcher , us_siberium_rocket , us_laser , us_double_laser , us_heavy_gun ] [ rand ( 1 , 9 ) ] ;
3532: LD_ADDR_OWVAR 40
3536: PUSH
3537: LD_INT 2
3539: PUSH
3540: LD_INT 4
3542: PUSH
3543: LD_INT 5
3545: PUSH
3546: LD_INT 3
3548: PUSH
3549: LD_INT 7
3551: PUSH
3552: LD_INT 8
3554: PUSH
3555: LD_INT 9
3557: PUSH
3558: LD_INT 10
3560: PUSH
3561: LD_INT 6
3563: PUSH
3564: EMPTY
3565: LIST
3566: LIST
3567: LIST
3568: LIST
3569: LIST
3570: LIST
3571: LIST
3572: LIST
3573: LIST
3574: PUSH
3575: LD_INT 1
3577: PPUSH
3578: LD_INT 9
3580: PPUSH
3581: CALL_OW 12
3585: ARRAY
3586: ST_TO_ADDR
// end ; 2 :
3587: GO 3854
3589: LD_INT 2
3591: DOUBLE
3592: EQUAL
3593: IFTRUE 3597
3595: GO 3721
3597: POP
// begin vc_chassis := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] [ rand ( 1 , 4 ) ] ;
3598: LD_ADDR_OWVAR 37
3602: PUSH
3603: LD_INT 11
3605: PUSH
3606: LD_INT 12
3608: PUSH
3609: LD_INT 13
3611: PUSH
3612: LD_INT 14
3614: PUSH
3615: EMPTY
3616: LIST
3617: LIST
3618: LIST
3619: LIST
3620: PUSH
3621: LD_INT 1
3623: PPUSH
3624: LD_INT 4
3626: PPUSH
3627: CALL_OW 12
3631: ARRAY
3632: ST_TO_ADDR
// vc_engine := rand ( 1 , 3 ) ;
3633: LD_ADDR_OWVAR 39
3637: PUSH
3638: LD_INT 1
3640: PPUSH
3641: LD_INT 3
3643: PPUSH
3644: CALL_OW 12
3648: ST_TO_ADDR
// vc_control := [ control_manual , control_remote , control_apeman ] [ rand ( 1 , 3 ) ] ;
3649: LD_ADDR_OWVAR 38
3653: PUSH
3654: LD_INT 1
3656: PUSH
3657: LD_INT 2
3659: PUSH
3660: LD_INT 5
3662: PUSH
3663: EMPTY
3664: LIST
3665: LIST
3666: LIST
3667: PUSH
3668: LD_INT 1
3670: PPUSH
3671: LD_INT 3
3673: PPUSH
3674: CALL_OW 12
3678: ARRAY
3679: ST_TO_ADDR
// vc_weapon := [ ar_double_machine_gun , ar_flame_thrower , ar_gun , ar_rocket_launcher , ar_selfpropelled_bomb ] [ rand ( 1 , 5 ) ] ;
3680: LD_ADDR_OWVAR 40
3684: PUSH
3685: LD_INT 24
3687: PUSH
3688: LD_INT 26
3690: PUSH
3691: LD_INT 27
3693: PUSH
3694: LD_INT 28
3696: PUSH
3697: LD_INT 29
3699: PUSH
3700: EMPTY
3701: LIST
3702: LIST
3703: LIST
3704: LIST
3705: LIST
3706: PUSH
3707: LD_INT 1
3709: PPUSH
3710: LD_INT 5
3712: PPUSH
3713: CALL_OW 12
3717: ARRAY
3718: ST_TO_ADDR
// end ; 3 :
3719: GO 3854
3721: LD_INT 3
3723: DOUBLE
3724: EQUAL
3725: IFTRUE 3729
3727: GO 3853
3729: POP
// begin vc_chassis := [ ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] [ rand ( 1 , 4 ) ] ;
3730: LD_ADDR_OWVAR 37
3734: PUSH
3735: LD_INT 21
3737: PUSH
3738: LD_INT 23
3740: PUSH
3741: LD_INT 22
3743: PUSH
3744: LD_INT 24
3746: PUSH
3747: EMPTY
3748: LIST
3749: LIST
3750: LIST
3751: LIST
3752: PUSH
3753: LD_INT 1
3755: PPUSH
3756: LD_INT 4
3758: PPUSH
3759: CALL_OW 12
3763: ARRAY
3764: ST_TO_ADDR
// vc_engine := rand ( 1 , 3 ) ;
3765: LD_ADDR_OWVAR 39
3769: PUSH
3770: LD_INT 1
3772: PPUSH
3773: LD_INT 3
3775: PPUSH
3776: CALL_OW 12
3780: ST_TO_ADDR
// vc_control := [ control_manual , control_computer ] [ rand ( 1 , 2 ) ] ;
3781: LD_ADDR_OWVAR 38
3785: PUSH
3786: LD_INT 1
3788: PUSH
3789: LD_INT 3
3791: PUSH
3792: EMPTY
3793: LIST
3794: LIST
3795: PUSH
3796: LD_INT 1
3798: PPUSH
3799: LD_INT 2
3801: PPUSH
3802: CALL_OW 12
3806: ARRAY
3807: ST_TO_ADDR
// vc_weapon := [ ru_heavy_machine_gun , ru_gatling_gun , ru_gun , ru_heavy_gun , ru_siberium_rocket , ru_rocket ] [ rand ( 1 , 6 ) ] ;
3808: LD_ADDR_OWVAR 40
3812: PUSH
3813: LD_INT 42
3815: PUSH
3816: LD_INT 43
3818: PUSH
3819: LD_INT 44
3821: PUSH
3822: LD_INT 46
3824: PUSH
3825: LD_INT 48
3827: PUSH
3828: LD_INT 47
3830: PUSH
3831: EMPTY
3832: LIST
3833: LIST
3834: LIST
3835: LIST
3836: LIST
3837: LIST
3838: PUSH
3839: LD_INT 1
3841: PPUSH
3842: LD_INT 6
3844: PPUSH
3845: CALL_OW 12
3849: ARRAY
3850: ST_TO_ADDR
// end ; end ;
3851: GO 3854
3853: POP
// PlaceUnitAnywhere ( CreateVehicle , true ) ;
3854: CALL_OW 45
3858: PPUSH
3859: LD_INT 1
3861: PPUSH
3862: CALL_OW 51
// end ;
3866: LD_VAR 0 1
3870: RET
// export invincible ; every 1 do
3871: GO 3873
3873: DISABLE
// invincible := [ ] ;
3874: LD_ADDR_EXP 22
3878: PUSH
3879: EMPTY
3880: ST_TO_ADDR
3881: END
// every 10 do var i ;
3882: GO 3884
3884: DISABLE
3885: LD_INT 0
3887: PPUSH
// begin enable ;
3888: ENABLE
// if not invincible then
3889: LD_EXP 22
3893: NOT
3894: IFFALSE 3898
// exit ;
3896: GO 3942
// for i in invincible do
3898: LD_ADDR_VAR 0 1
3902: PUSH
3903: LD_EXP 22
3907: PUSH
3908: FOR_IN
3909: IFFALSE 3940
// if GetLives ( i ) < 1000 then
3911: LD_VAR 0 1
3915: PPUSH
3916: CALL_OW 256
3920: PUSH
3921: LD_INT 1000
3923: LESS
3924: IFFALSE 3938
// SetLives ( i , 1000 ) ;
3926: LD_VAR 0 1
3930: PPUSH
3931: LD_INT 1000
3933: PPUSH
3934: CALL_OW 234
3938: GO 3908
3940: POP
3941: POP
// end ;
3942: PPOPN 1
3944: END
// export function HackInvincible ; var i ; begin
3945: LD_INT 0
3947: PPUSH
3948: PPUSH
// for i in FilterAllUnits ( [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ) do
3949: LD_ADDR_VAR 0 2
3953: PUSH
3954: LD_INT 2
3956: PUSH
3957: LD_INT 21
3959: PUSH
3960: LD_INT 1
3962: PUSH
3963: EMPTY
3964: LIST
3965: LIST
3966: PUSH
3967: LD_INT 21
3969: PUSH
3970: LD_INT 2
3972: PUSH
3973: EMPTY
3974: LIST
3975: LIST
3976: PUSH
3977: EMPTY
3978: LIST
3979: LIST
3980: LIST
3981: PPUSH
3982: CALL_OW 69
3986: PUSH
3987: FOR_IN
3988: IFFALSE 4049
// if IsSelected ( i ) then
3990: LD_VAR 0 2
3994: PPUSH
3995: CALL_OW 306
3999: IFFALSE 4047
// begin if i in invincible then
4001: LD_VAR 0 2
4005: PUSH
4006: LD_EXP 22
4010: IN
4011: IFFALSE 4031
// invincible := invincible diff i else
4013: LD_ADDR_EXP 22
4017: PUSH
4018: LD_EXP 22
4022: PUSH
4023: LD_VAR 0 2
4027: DIFF
4028: ST_TO_ADDR
4029: GO 4047
// invincible := invincible union i ;
4031: LD_ADDR_EXP 22
4035: PUSH
4036: LD_EXP 22
4040: PUSH
4041: LD_VAR 0 2
4045: UNION
4046: ST_TO_ADDR
// end ;
4047: GO 3987
4049: POP
4050: POP
// end ;
4051: LD_VAR 0 1
4055: RET
// export function HackInvisible ; var i , j ; begin
4056: LD_INT 0
4058: PPUSH
4059: PPUSH
4060: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
4061: LD_ADDR_VAR 0 2
4065: PUSH
4066: LD_INT 21
4068: PUSH
4069: LD_INT 1
4071: PUSH
4072: EMPTY
4073: LIST
4074: LIST
4075: PPUSH
4076: CALL_OW 69
4080: PUSH
4081: FOR_IN
4082: IFFALSE 4106
// if IsSelected ( i ) then
4084: LD_VAR 0 2
4088: PPUSH
4089: CALL_OW 306
4093: IFFALSE 4104
// begin ComForceInvisible ( i ) ;
4095: LD_VAR 0 2
4099: PPUSH
4100: CALL_OW 496
// end ;
4104: GO 4081
4106: POP
4107: POP
// end ;
4108: LD_VAR 0 1
4112: RET
// export function HackChangeYourSide ; begin
4113: LD_INT 0
4115: PPUSH
// if your_side = 8 then
4116: LD_OWVAR 2
4120: PUSH
4121: LD_INT 8
4123: EQUAL
4124: IFFALSE 4136
// your_side := 0 else
4126: LD_ADDR_OWVAR 2
4130: PUSH
4131: LD_INT 0
4133: ST_TO_ADDR
4134: GO 4150
// your_side := your_side + 1 ;
4136: LD_ADDR_OWVAR 2
4140: PUSH
4141: LD_OWVAR 2
4145: PUSH
4146: LD_INT 1
4148: PLUS
4149: ST_TO_ADDR
// end ;
4150: LD_VAR 0 1
4154: RET
// export function HackChangeUnitSide ; var i , j ; begin
4155: LD_INT 0
4157: PPUSH
4158: PPUSH
4159: PPUSH
// for i in all_units do
4160: LD_ADDR_VAR 0 2
4164: PUSH
4165: LD_OWVAR 3
4169: PUSH
4170: FOR_IN
4171: IFFALSE 4249
// if IsSelected ( i ) then
4173: LD_VAR 0 2
4177: PPUSH
4178: CALL_OW 306
4182: IFFALSE 4247
// begin j := GetSide ( i ) ;
4184: LD_ADDR_VAR 0 3
4188: PUSH
4189: LD_VAR 0 2
4193: PPUSH
4194: CALL_OW 255
4198: ST_TO_ADDR
// if j = 8 then
4199: LD_VAR 0 3
4203: PUSH
4204: LD_INT 8
4206: EQUAL
4207: IFFALSE 4219
// j := 0 else
4209: LD_ADDR_VAR 0 3
4213: PUSH
4214: LD_INT 0
4216: ST_TO_ADDR
4217: GO 4233
// j := j + 1 ;
4219: LD_ADDR_VAR 0 3
4223: PUSH
4224: LD_VAR 0 3
4228: PUSH
4229: LD_INT 1
4231: PLUS
4232: ST_TO_ADDR
// SetSide ( i , j ) ;
4233: LD_VAR 0 2
4237: PPUSH
4238: LD_VAR 0 3
4242: PPUSH
4243: CALL_OW 235
// end ;
4247: GO 4170
4249: POP
4250: POP
// end ;
4251: LD_VAR 0 1
4255: RET
// export function HackFog ; begin
4256: LD_INT 0
4258: PPUSH
// FogOff ( true ) ;
4259: LD_INT 1
4261: PPUSH
4262: CALL_OW 344
// end ;
4266: LD_VAR 0 1
4270: RET
// export function HackApeman ; begin
4271: LD_INT 0
4273: PPUSH
// uc_side := your_side ;
4274: LD_ADDR_OWVAR 20
4278: PUSH
4279: LD_OWVAR 2
4283: ST_TO_ADDR
// uc_nation := 0 ;
4284: LD_ADDR_OWVAR 21
4288: PUSH
4289: LD_INT 0
4291: ST_TO_ADDR
// hc_name :=  ;
4292: LD_ADDR_OWVAR 26
4296: PUSH
4297: LD_STRING 
4299: ST_TO_ADDR
// hc_gallery :=  ;
4300: LD_ADDR_OWVAR 33
4304: PUSH
4305: LD_STRING 
4307: ST_TO_ADDR
// hc_skills := [ 0 , 0 , 0 , 0 ] ;
4308: LD_ADDR_OWVAR 31
4312: PUSH
4313: LD_INT 0
4315: PUSH
4316: LD_INT 0
4318: PUSH
4319: LD_INT 0
4321: PUSH
4322: LD_INT 0
4324: PUSH
4325: EMPTY
4326: LIST
4327: LIST
4328: LIST
4329: LIST
4330: ST_TO_ADDR
// hc_class := class_apeman ;
4331: LD_ADDR_OWVAR 28
4335: PUSH
4336: LD_INT 12
4338: ST_TO_ADDR
// PlaceUnitAnywhere ( CreateHuman , true ) ;
4339: CALL_OW 44
4343: PPUSH
4344: LD_INT 1
4346: PPUSH
4347: CALL_OW 51
// end ;
4351: LD_VAR 0 1
4355: RET
// export function HackBoom ; begin
4356: LD_INT 0
4358: PPUSH
// uc_side := your_side ;
4359: LD_ADDR_OWVAR 20
4363: PUSH
4364: LD_OWVAR 2
4368: ST_TO_ADDR
// uc_nation := 1 ;
4369: LD_ADDR_OWVAR 21
4373: PUSH
4374: LD_INT 1
4376: ST_TO_ADDR
// vc_chassis := us_morphling ;
4377: LD_ADDR_OWVAR 37
4381: PUSH
4382: LD_INT 5
4384: ST_TO_ADDR
// vc_engine := engine_siberite ;
4385: LD_ADDR_OWVAR 39
4389: PUSH
4390: LD_INT 3
4392: ST_TO_ADDR
// vc_control := control_computer ;
4393: LD_ADDR_OWVAR 38
4397: PUSH
4398: LD_INT 3
4400: ST_TO_ADDR
// vc_weapon := us_siberium_rocket ;
4401: LD_ADDR_OWVAR 40
4405: PUSH
4406: LD_INT 8
4408: ST_TO_ADDR
// PlaceUnitAnywhere ( CreateVehicle , true ) ;
4409: CALL_OW 45
4413: PPUSH
4414: LD_INT 1
4416: PPUSH
4417: CALL_OW 51
// end ;
4421: LD_VAR 0 1
4425: RET
