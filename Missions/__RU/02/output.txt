// starting begin InitMission ;
   0: CALL 5 0 0
// end ;
   4: END
// export playerVehicles ; export beriaBase ; export kirovBase ; export meetBelkovBrother ; export platonovOpinion ; export belkovReturn ; export meetPlatonov ; export labConstructed , workshopConstructed , engineResearched , canBuildSameBuilding ; export constructedFirstVehicle , firstVeh ; export vehicleForKurin ; export backToBeria1 , backToBeria2 ; export construcMoreVehicles , constructedVehiclesCounter ; export canExitBase , canExploreMap ; export spawnCrates ; export canRemoveBelkovUnits , removedBelkovUntis , immortalBelkovTeam , immortalVehLive ; export kirovConstructedBunkers ; export activateAMAI , activateBelkovAI ; export sawLeftBunker , sawRightBunker ; export dialogAttackLeftBunkers , dialogAttackRightBunkers , dialogLoopBlocker ; export playerGetSupport ; export saveBelkovDecision ; export saveBelkovObjective , belkovSaved ; export captureBelkovVehicle ; export raportForPlatonov , medalForGetSupport ; export northMapExplored ; export initiative ; export lostComradesCounter ; export achievement_ConstructVehicles ; function InitMission ; begin
   5: LD_INT 0
   7: PPUSH
// ResetFog ;
   8: CALL_OW 335
// RandomizeAll ;
  12: CALL_OW 11
// InGameOn ;
  16: CALL_OW 8
// InitMapConfig ;
  20: CALL 373 0 0
// PrepareRussian ;
  24: CALL 1112 0 0
// PrepareNature ;
  28: CALL 16511 0 0
// playerVehicles = [ ] ;
  32: LD_ADDR_EXP 1
  36: PUSH
  37: EMPTY
  38: ST_TO_ADDR
// beriaBase = [ ] ;
  39: LD_ADDR_EXP 2
  43: PUSH
  44: EMPTY
  45: ST_TO_ADDR
// kirovBase = [ ] ;
  46: LD_ADDR_EXP 3
  50: PUSH
  51: EMPTY
  52: ST_TO_ADDR
// meetBelkovBrother = false ;
  53: LD_ADDR_EXP 4
  57: PUSH
  58: LD_INT 0
  60: ST_TO_ADDR
// platonovOpinion = - 1 ;
  61: LD_ADDR_EXP 5
  65: PUSH
  66: LD_INT 1
  68: NEG
  69: ST_TO_ADDR
// belkovReturn = TestCharacters ( 01_Belkov ) ;
  70: LD_ADDR_EXP 6
  74: PUSH
  75: LD_STRING 01_Belkov
  77: PPUSH
  78: CALL_OW 28
  82: ST_TO_ADDR
// meetPlatonov = false ;
  83: LD_ADDR_EXP 7
  87: PUSH
  88: LD_INT 0
  90: ST_TO_ADDR
// labConstructed = false ;
  91: LD_ADDR_EXP 8
  95: PUSH
  96: LD_INT 0
  98: ST_TO_ADDR
// workshopConstructed = false ;
  99: LD_ADDR_EXP 9
 103: PUSH
 104: LD_INT 0
 106: ST_TO_ADDR
// engineResearched = false ;
 107: LD_ADDR_EXP 10
 111: PUSH
 112: LD_INT 0
 114: ST_TO_ADDR
// canBuildSameBuilding = false ;
 115: LD_ADDR_EXP 11
 119: PUSH
 120: LD_INT 0
 122: ST_TO_ADDR
// constructedFirstVehicle = false ;
 123: LD_ADDR_EXP 12
 127: PUSH
 128: LD_INT 0
 130: ST_TO_ADDR
// vehicleForKurin = false ;
 131: LD_ADDR_EXP 14
 135: PUSH
 136: LD_INT 0
 138: ST_TO_ADDR
// backToBeria1 = false ;
 139: LD_ADDR_EXP 15
 143: PUSH
 144: LD_INT 0
 146: ST_TO_ADDR
// backToBeria2 = false ;
 147: LD_ADDR_EXP 16
 151: PUSH
 152: LD_INT 0
 154: ST_TO_ADDR
// construcMoreVehicles = false ;
 155: LD_ADDR_EXP 17
 159: PUSH
 160: LD_INT 0
 162: ST_TO_ADDR
// constructedVehiclesCounter = 0 ;
 163: LD_ADDR_EXP 18
 167: PUSH
 168: LD_INT 0
 170: ST_TO_ADDR
// spawnCrates = false ;
 171: LD_ADDR_EXP 21
 175: PUSH
 176: LD_INT 0
 178: ST_TO_ADDR
// canRemoveBelkovUnits = false ;
 179: LD_ADDR_EXP 22
 183: PUSH
 184: LD_INT 0
 186: ST_TO_ADDR
// removedBelkovUntis = 0 ;
 187: LD_ADDR_EXP 23
 191: PUSH
 192: LD_INT 0
 194: ST_TO_ADDR
// immortalBelkovTeam = false ;
 195: LD_ADDR_EXP 24
 199: PUSH
 200: LD_INT 0
 202: ST_TO_ADDR
// immortalVehLive = 1000 ;
 203: LD_ADDR_EXP 25
 207: PUSH
 208: LD_INT 1000
 210: ST_TO_ADDR
// canExitBase = true ;
 211: LD_ADDR_EXP 19
 215: PUSH
 216: LD_INT 1
 218: ST_TO_ADDR
// canExploreMap = false ;
 219: LD_ADDR_EXP 20
 223: PUSH
 224: LD_INT 0
 226: ST_TO_ADDR
// sawLeftBunker = false ;
 227: LD_ADDR_EXP 29
 231: PUSH
 232: LD_INT 0
 234: ST_TO_ADDR
// sawRightBunker = false ;
 235: LD_ADDR_EXP 30
 239: PUSH
 240: LD_INT 0
 242: ST_TO_ADDR
// dialogLoopBlocker = false ;
 243: LD_ADDR_EXP 33
 247: PUSH
 248: LD_INT 0
 250: ST_TO_ADDR
// dialogAttackLeftBunkers = false ;
 251: LD_ADDR_EXP 31
 255: PUSH
 256: LD_INT 0
 258: ST_TO_ADDR
// dialogAttackRightBunkers = false ;
 259: LD_ADDR_EXP 32
 263: PUSH
 264: LD_INT 0
 266: ST_TO_ADDR
// playerGetSupport = false ;
 267: LD_ADDR_EXP 34
 271: PUSH
 272: LD_INT 0
 274: ST_TO_ADDR
// captureBelkovVehicle = false ;
 275: LD_ADDR_EXP 38
 279: PUSH
 280: LD_INT 0
 282: ST_TO_ADDR
// saveBelkovObjective = false ;
 283: LD_ADDR_EXP 36
 287: PUSH
 288: LD_INT 0
 290: ST_TO_ADDR
// medalForGetSupport = true ;
 291: LD_ADDR_EXP 40
 295: PUSH
 296: LD_INT 1
 298: ST_TO_ADDR
// raportForPlatonov = - 1 ;
 299: LD_ADDR_EXP 39
 303: PUSH
 304: LD_INT 1
 306: NEG
 307: ST_TO_ADDR
// initiative = 0 ;
 308: LD_ADDR_EXP 42
 312: PUSH
 313: LD_INT 0
 315: ST_TO_ADDR
// lostComradesCounter = 0 ;
 316: LD_ADDR_EXP 43
 320: PUSH
 321: LD_INT 0
 323: ST_TO_ADDR
// northMapExplored = false ;
 324: LD_ADDR_EXP 41
 328: PUSH
 329: LD_INT 0
 331: ST_TO_ADDR
// kirovConstructedBunkers = 0 ;
 332: LD_ADDR_EXP 26
 336: PUSH
 337: LD_INT 0
 339: ST_TO_ADDR
// activateAMAI = false ;
 340: LD_ADDR_EXP 27
 344: PUSH
 345: LD_INT 0
 347: ST_TO_ADDR
// activateBelkovAI = false ;
 348: LD_ADDR_EXP 28
 352: PUSH
 353: LD_INT 0
 355: ST_TO_ADDR
// achievement_ConstructVehicles = 0 ;
 356: LD_ADDR_EXP 44
 360: PUSH
 361: LD_INT 0
 363: ST_TO_ADDR
// MissionIntro ;
 364: CALL 6871 0 0
// end ; end_of_file
 368: LD_VAR 0 1
 372: RET
// export function InitMapConfig ; begin
 373: LD_INT 0
 375: PPUSH
// BaseMapConfig ;
 376: CALL 389 0 0
// MissionMapConfig ;
 380: CALL 475 0 0
// end ;
 384: LD_VAR 0 1
 388: RET
// export animalsAmount , animalsStats , animalsAgression , missionPrefix , previousMissionPrefix , debugMode ; function BaseMapConfig ; begin
 389: LD_INT 0
 391: PPUSH
// animalsAmount = [ 2 , 4 , 1 , 0 ] ;
 392: LD_ADDR_EXP 45
 396: PUSH
 397: LD_INT 2
 399: PUSH
 400: LD_INT 4
 402: PUSH
 403: LD_INT 1
 405: PUSH
 406: LD_INT 0
 408: PUSH
 409: EMPTY
 410: LIST
 411: LIST
 412: LIST
 413: LIST
 414: ST_TO_ADDR
// animalsStats = [ 2 , 2 , 2 , 2 ] ;
 415: LD_ADDR_EXP 46
 419: PUSH
 420: LD_INT 2
 422: PUSH
 423: LD_INT 2
 425: PUSH
 426: LD_INT 2
 428: PUSH
 429: LD_INT 2
 431: PUSH
 432: EMPTY
 433: LIST
 434: LIST
 435: LIST
 436: LIST
 437: ST_TO_ADDR
// animalsAgression = 0 ;
 438: LD_ADDR_EXP 47
 442: PUSH
 443: LD_INT 0
 445: ST_TO_ADDR
// debugMode = 0 ;
 446: LD_ADDR_EXP 50
 450: PUSH
 451: LD_INT 0
 453: ST_TO_ADDR
// missionPrefix = 02_ ;
 454: LD_ADDR_EXP 48
 458: PUSH
 459: LD_STRING 02_
 461: ST_TO_ADDR
// previousMissionPrefix = 01_ ;
 462: LD_ADDR_EXP 49
 466: PUSH
 467: LD_STRING 01_
 469: ST_TO_ADDR
// end ;
 470: LD_VAR 0 1
 474: RET
// export kirovAmountPeople ; export meetWithKurinPositions , meetWithPlatonovPositions ; export labCratesRefund , workshopCratesRefund , oilPowerCratesRefund , armouryCratesRefund , bunkerCratesRefund ; export enemySkillLevel ; export trapAmountPeople ; export belkovAttackTime ; function MissionMapConfig ; begin
 475: LD_INT 0
 477: PPUSH
// meetWithKurinPositions = [ [ 162 , 107 ] , [ 162 , 108 ] , [ 163 , 109 ] , [ 163 , 110 ] , [ 162 , 109 ] , [ 161 , 107 ] , [ 161 , 106 ] ] ;
 478: LD_ADDR_EXP 52
 482: PUSH
 483: LD_INT 162
 485: PUSH
 486: LD_INT 107
 488: PUSH
 489: EMPTY
 490: LIST
 491: LIST
 492: PUSH
 493: LD_INT 162
 495: PUSH
 496: LD_INT 108
 498: PUSH
 499: EMPTY
 500: LIST
 501: LIST
 502: PUSH
 503: LD_INT 163
 505: PUSH
 506: LD_INT 109
 508: PUSH
 509: EMPTY
 510: LIST
 511: LIST
 512: PUSH
 513: LD_INT 163
 515: PUSH
 516: LD_INT 110
 518: PUSH
 519: EMPTY
 520: LIST
 521: LIST
 522: PUSH
 523: LD_INT 162
 525: PUSH
 526: LD_INT 109
 528: PUSH
 529: EMPTY
 530: LIST
 531: LIST
 532: PUSH
 533: LD_INT 161
 535: PUSH
 536: LD_INT 107
 538: PUSH
 539: EMPTY
 540: LIST
 541: LIST
 542: PUSH
 543: LD_INT 161
 545: PUSH
 546: LD_INT 106
 548: PUSH
 549: EMPTY
 550: LIST
 551: LIST
 552: PUSH
 553: EMPTY
 554: LIST
 555: LIST
 556: LIST
 557: LIST
 558: LIST
 559: LIST
 560: LIST
 561: ST_TO_ADDR
// meetWithPlatonovPositions = [ [ 113 , 96 ] , [ 114 , 97 ] , [ 114 , 98 ] ] ;
 562: LD_ADDR_EXP 53
 566: PUSH
 567: LD_INT 113
 569: PUSH
 570: LD_INT 96
 572: PUSH
 573: EMPTY
 574: LIST
 575: LIST
 576: PUSH
 577: LD_INT 114
 579: PUSH
 580: LD_INT 97
 582: PUSH
 583: EMPTY
 584: LIST
 585: LIST
 586: PUSH
 587: LD_INT 114
 589: PUSH
 590: LD_INT 98
 592: PUSH
 593: EMPTY
 594: LIST
 595: LIST
 596: PUSH
 597: EMPTY
 598: LIST
 599: LIST
 600: LIST
 601: ST_TO_ADDR
// kirovAmountPeople = [ 10 , 1 , 2 , 1 ] ;
 602: LD_ADDR_EXP 51
 606: PUSH
 607: LD_INT 10
 609: PUSH
 610: LD_INT 1
 612: PUSH
 613: LD_INT 2
 615: PUSH
 616: LD_INT 1
 618: PUSH
 619: EMPTY
 620: LIST
 621: LIST
 622: LIST
 623: LIST
 624: ST_TO_ADDR
// labCratesRefund = 20 ;
 625: LD_ADDR_EXP 54
 629: PUSH
 630: LD_INT 20
 632: ST_TO_ADDR
// workshopCratesRefund = 40 ;
 633: LD_ADDR_EXP 55
 637: PUSH
 638: LD_INT 40
 640: ST_TO_ADDR
// oilPowerCratesRefund = 20 ;
 641: LD_ADDR_EXP 56
 645: PUSH
 646: LD_INT 20
 648: ST_TO_ADDR
// armouryCratesRefund = 30 ;
 649: LD_ADDR_EXP 57
 653: PUSH
 654: LD_INT 30
 656: ST_TO_ADDR
// bunkerCratesRefund = 10 ;
 657: LD_ADDR_EXP 58
 661: PUSH
 662: LD_INT 10
 664: ST_TO_ADDR
// enemySkillLevel = [ 1 , 2 , 2 ] [ Difficulty ] ;
 665: LD_ADDR_EXP 59
 669: PUSH
 670: LD_INT 1
 672: PUSH
 673: LD_INT 2
 675: PUSH
 676: LD_INT 2
 678: PUSH
 679: EMPTY
 680: LIST
 681: LIST
 682: LIST
 683: PUSH
 684: LD_OWVAR 67
 688: ARRAY
 689: ST_TO_ADDR
// trapAmountPeople = [ [ 3 , 2 , 1 , 1 ] , [ 3 , 2 , 1 , 1 ] , [ 3 , 2 , 1 , 1 ] ] [ Difficulty ] ;
 690: LD_ADDR_EXP 60
 694: PUSH
 695: LD_INT 3
 697: PUSH
 698: LD_INT 2
 700: PUSH
 701: LD_INT 1
 703: PUSH
 704: LD_INT 1
 706: PUSH
 707: EMPTY
 708: LIST
 709: LIST
 710: LIST
 711: LIST
 712: PUSH
 713: LD_INT 3
 715: PUSH
 716: LD_INT 2
 718: PUSH
 719: LD_INT 1
 721: PUSH
 722: LD_INT 1
 724: PUSH
 725: EMPTY
 726: LIST
 727: LIST
 728: LIST
 729: LIST
 730: PUSH
 731: LD_INT 3
 733: PUSH
 734: LD_INT 2
 736: PUSH
 737: LD_INT 1
 739: PUSH
 740: LD_INT 1
 742: PUSH
 743: EMPTY
 744: LIST
 745: LIST
 746: LIST
 747: LIST
 748: PUSH
 749: EMPTY
 750: LIST
 751: LIST
 752: LIST
 753: PUSH
 754: LD_OWVAR 67
 758: ARRAY
 759: ST_TO_ADDR
// belkovAttackTime = [ 10 10$0 , 8 8$0 , 6 6$0 ] [ Difficulty ] ;
 760: LD_ADDR_EXP 61
 764: PUSH
 765: LD_INT 21000
 767: PUSH
 768: LD_INT 16800
 770: PUSH
 771: LD_INT 12600
 773: PUSH
 774: EMPTY
 775: LIST
 776: LIST
 777: LIST
 778: PUSH
 779: LD_OWVAR 67
 783: ARRAY
 784: ST_TO_ADDR
// end ;
 785: LD_VAR 0 1
 789: RET
// every 0 0$1 trigger debugMode do var i ;
 790: LD_EXP 50
 794: IFFALSE 1109
 796: GO 798
 798: DISABLE
 799: LD_INT 0
 801: PPUSH
// begin enable ;
 802: ENABLE
// FogOff ( your_side ) ;
 803: LD_OWVAR 2
 807: PPUSH
 808: CALL_OW 344
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) do
 812: LD_ADDR_VAR 0 1
 816: PUSH
 817: LD_INT 22
 819: PUSH
 820: LD_OWVAR 2
 824: PUSH
 825: EMPTY
 826: LIST
 827: LIST
 828: PUSH
 829: LD_INT 2
 831: PUSH
 832: LD_INT 21
 834: PUSH
 835: LD_INT 1
 837: PUSH
 838: EMPTY
 839: LIST
 840: LIST
 841: PUSH
 842: LD_INT 21
 844: PUSH
 845: LD_INT 2
 847: PUSH
 848: EMPTY
 849: LIST
 850: LIST
 851: PUSH
 852: EMPTY
 853: LIST
 854: LIST
 855: LIST
 856: PUSH
 857: EMPTY
 858: LIST
 859: LIST
 860: PPUSH
 861: CALL_OW 69
 865: PUSH
 866: FOR_IN
 867: IFFALSE 883
// SetLives ( i , 1000 ) ;
 869: LD_VAR 0 1
 873: PPUSH
 874: LD_INT 1000
 876: PPUSH
 877: CALL_OW 234
 881: GO 866
 883: POP
 884: POP
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) do
 885: LD_ADDR_VAR 0 1
 889: PUSH
 890: LD_INT 22
 892: PUSH
 893: LD_OWVAR 2
 897: PUSH
 898: EMPTY
 899: LIST
 900: LIST
 901: PUSH
 902: LD_INT 21
 904: PUSH
 905: LD_INT 1
 907: PUSH
 908: EMPTY
 909: LIST
 910: LIST
 911: PUSH
 912: EMPTY
 913: LIST
 914: LIST
 915: PPUSH
 916: CALL_OW 69
 920: PUSH
 921: FOR_IN
 922: IFFALSE 986
// begin SetSkill ( i , skill_combat , 10 ) ;
 924: LD_VAR 0 1
 928: PPUSH
 929: LD_INT 1
 931: PPUSH
 932: LD_INT 10
 934: PPUSH
 935: CALL_OW 237
// SetSkill ( i , skill_engineering , 10 ) ;
 939: LD_VAR 0 1
 943: PPUSH
 944: LD_INT 2
 946: PPUSH
 947: LD_INT 10
 949: PPUSH
 950: CALL_OW 237
// SetSkill ( i , skill_mechanical , 10 ) ;
 954: LD_VAR 0 1
 958: PPUSH
 959: LD_INT 3
 961: PPUSH
 962: LD_INT 10
 964: PPUSH
 965: CALL_OW 237
// SetSkill ( i , skill_scientistic , 10 ) ;
 969: LD_VAR 0 1
 973: PPUSH
 974: LD_INT 4
 976: PPUSH
 977: LD_INT 10
 979: PPUSH
 980: CALL_OW 237
// end ;
 984: GO 921
 986: POP
 987: POP
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) do
 988: LD_ADDR_VAR 0 1
 992: PUSH
 993: LD_INT 22
 995: PUSH
 996: LD_OWVAR 2
1000: PUSH
1001: EMPTY
1002: LIST
1003: LIST
1004: PUSH
1005: LD_INT 2
1007: PUSH
1008: LD_INT 30
1010: PUSH
1011: LD_INT 0
1013: PUSH
1014: EMPTY
1015: LIST
1016: LIST
1017: PUSH
1018: LD_INT 30
1020: PUSH
1021: LD_INT 1
1023: PUSH
1024: EMPTY
1025: LIST
1026: LIST
1027: PUSH
1028: EMPTY
1029: LIST
1030: LIST
1031: LIST
1032: PUSH
1033: EMPTY
1034: LIST
1035: LIST
1036: PPUSH
1037: CALL_OW 69
1041: PUSH
1042: FOR_IN
1043: IFFALSE 1107
// begin SetResourceType ( GetBase ( i ) , mat_cans , 9999 ) ;
1045: LD_VAR 0 1
1049: PPUSH
1050: CALL_OW 274
1054: PPUSH
1055: LD_INT 1
1057: PPUSH
1058: LD_INT 9999
1060: PPUSH
1061: CALL_OW 277
// SetResourceType ( GetBase ( i ) , mat_oil , 9999 ) ;
1065: LD_VAR 0 1
1069: PPUSH
1070: CALL_OW 274
1074: PPUSH
1075: LD_INT 2
1077: PPUSH
1078: LD_INT 9999
1080: PPUSH
1081: CALL_OW 277
// SetResourceType ( GetBase ( i ) , mat_siberit , 9999 ) ;
1085: LD_VAR 0 1
1089: PPUSH
1090: CALL_OW 274
1094: PPUSH
1095: LD_INT 3
1097: PPUSH
1098: LD_INT 9999
1100: PPUSH
1101: CALL_OW 277
// end ;
1105: GO 1042
1107: POP
1108: POP
// end ; end_of_file
1109: PPOPN 1
1111: END
// export Burlak , Gnyevko , Belkov , Kirilenkova ; export other_survivors ; export Kurin , Belkov2 , otherKirovUnits ; export Kovalyuk , randomMech ; export kirovVehicle ; export belkovTeam ; export removedBelkovUntisSaved ; export removedBelkovVehicleSaved ; export Platonov , platSoldiers ; export Kuklajs , Benko ; export function PrepareRussian ; begin
1112: LD_INT 0
1114: PPUSH
// PrepareCharactersFromPreviousMission ;
1115: CALL 1534 0 0
// PrepareKirovBase ;
1119: CALL 1729 0 0
// PrepareBeriaBase ;
1123: CALL 2494 0 0
// end ;
1127: LD_VAR 0 1
1131: RET
// export function PrepareBelkovReturnTeam ; var unit , others , tmp ; begin
1132: LD_INT 0
1134: PPUSH
1135: PPUSH
1136: PPUSH
1137: PPUSH
// belkovTeam = [ ] ;
1138: LD_ADDR_EXP 73
1142: PUSH
1143: EMPTY
1144: ST_TO_ADDR
// uc_side = 6 ;
1145: LD_ADDR_OWVAR 20
1149: PUSH
1150: LD_INT 6
1152: ST_TO_ADDR
// uc_nation = nation_russian ;
1153: LD_ADDR_OWVAR 21
1157: PUSH
1158: LD_INT 3
1160: ST_TO_ADDR
// vc_chassis = removedBelkovVehicleSaved [ 1 ] ;
1161: LD_ADDR_OWVAR 37
1165: PUSH
1166: LD_EXP 75
1170: PUSH
1171: LD_INT 1
1173: ARRAY
1174: ST_TO_ADDR
// vc_engine = removedBelkovVehicleSaved [ 2 ] ;
1175: LD_ADDR_OWVAR 39
1179: PUSH
1180: LD_EXP 75
1184: PUSH
1185: LD_INT 2
1187: ARRAY
1188: ST_TO_ADDR
// vc_control = removedBelkovVehicleSaved [ 3 ] ;
1189: LD_ADDR_OWVAR 38
1193: PUSH
1194: LD_EXP 75
1198: PUSH
1199: LD_INT 3
1201: ARRAY
1202: ST_TO_ADDR
// vc_weapon = removedBelkovVehicleSaved [ 4 ] ;
1203: LD_ADDR_OWVAR 40
1207: PUSH
1208: LD_EXP 75
1212: PUSH
1213: LD_INT 4
1215: ARRAY
1216: ST_TO_ADDR
// vc_fuel_battery = removedBelkovVehicleSaved [ 5 ] ;
1217: LD_ADDR_OWVAR 41
1221: PUSH
1222: LD_EXP 75
1226: PUSH
1227: LD_INT 5
1229: ARRAY
1230: ST_TO_ADDR
// kirovVehicle = CreateVehicle ;
1231: LD_ADDR_EXP 72
1235: PUSH
1236: CALL_OW 45
1240: ST_TO_ADDR
// SetDir ( kirovVehicle , 3 ) ;
1241: LD_EXP 72
1245: PPUSH
1246: LD_INT 3
1248: PPUSH
1249: CALL_OW 233
// PlaceUnitArea ( kirovVehicle , BelkovReturnArea , false ) ;
1253: LD_EXP 72
1257: PPUSH
1258: LD_INT 11
1260: PPUSH
1261: LD_INT 0
1263: PPUSH
1264: CALL_OW 49
// belkovTeam = belkovTeam ^ kirovVehicle ;
1268: LD_ADDR_EXP 73
1272: PUSH
1273: LD_EXP 73
1277: PUSH
1278: LD_EXP 72
1282: ADD
1283: ST_TO_ADDR
// if TestCharacters ( 02_TmpBelkov ) then
1284: LD_STRING 02_TmpBelkov
1286: PPUSH
1287: CALL_OW 28
1291: IFFALSE 1336
// begin Belkov = CreateCharacter ( 02_TmpBelkov ) ;
1293: LD_ADDR_EXP 64
1297: PUSH
1298: LD_STRING 02_TmpBelkov
1300: PPUSH
1301: CALL_OW 34
1305: ST_TO_ADDR
// PlaceHumanInUnit ( Belkov , kirovVehicle ) ;
1306: LD_EXP 64
1310: PPUSH
1311: LD_EXP 72
1315: PPUSH
1316: CALL_OW 52
// belkovTeam = belkovTeam ^ Belkov ;
1320: LD_ADDR_EXP 73
1324: PUSH
1325: LD_EXP 73
1329: PUSH
1330: LD_EXP 64
1334: ADD
1335: ST_TO_ADDR
// end ; if TestCharacters ( 02_TmpBelkov2 ) then
1336: LD_STRING 02_TmpBelkov2
1338: PPUSH
1339: CALL_OW 28
1343: IFFALSE 1415
// begin Belkov2 = CreateCharacter ( 02_TmpBelkov2 ) ;
1345: LD_ADDR_EXP 68
1349: PUSH
1350: LD_STRING 02_TmpBelkov2
1352: PPUSH
1353: CALL_OW 34
1357: ST_TO_ADDR
// if not TestCharacters ( 02_TmpBelkov ) then
1358: LD_STRING 02_TmpBelkov
1360: PPUSH
1361: CALL_OW 28
1365: NOT
1366: IFFALSE 1384
// PlaceHumanInUnit ( Belkov2 , kirovVehicle ) else
1368: LD_EXP 68
1372: PPUSH
1373: LD_EXP 72
1377: PPUSH
1378: CALL_OW 52
1382: GO 1399
// PlaceUnitArea ( Belkov2 , BelkovReturnArea , false ) ;
1384: LD_EXP 68
1388: PPUSH
1389: LD_INT 11
1391: PPUSH
1392: LD_INT 0
1394: PPUSH
1395: CALL_OW 49
// belkovTeam = belkovTeam ^ Belkov2 ;
1399: LD_ADDR_EXP 73
1403: PUSH
1404: LD_EXP 73
1408: PUSH
1409: LD_EXP 68
1413: ADD
1414: ST_TO_ADDR
// end ; if TestCharacters ( 02_TmpKirilenkova ) then
1415: LD_STRING 02_TmpKirilenkova
1417: PPUSH
1418: CALL_OW 28
1422: IFFALSE 1468
// begin Kirilenkova = CreateCharacter ( 02_TmpKirilenkova ) ;
1424: LD_ADDR_EXP 65
1428: PUSH
1429: LD_STRING 02_TmpKirilenkova
1431: PPUSH
1432: CALL_OW 34
1436: ST_TO_ADDR
// PlaceUnitArea ( Kirilenkova , BelkovReturnArea , false ) ;
1437: LD_EXP 65
1441: PPUSH
1442: LD_INT 11
1444: PPUSH
1445: LD_INT 0
1447: PPUSH
1448: CALL_OW 49
// belkovTeam = belkovTeam ^ Kirilenkova ;
1452: LD_ADDR_EXP 73
1456: PUSH
1457: LD_EXP 73
1461: PUSH
1462: LD_EXP 65
1466: ADD
1467: ST_TO_ADDR
// end ; others = CreateCharacterSet ( 02_TmpBelkovTeam ) ;
1468: LD_ADDR_VAR 0 3
1472: PUSH
1473: LD_STRING 02_TmpBelkovTeam
1475: PPUSH
1476: CALL_OW 31
1480: ST_TO_ADDR
// for unit in others do
1481: LD_ADDR_VAR 0 2
1485: PUSH
1486: LD_VAR 0 3
1490: PUSH
1491: FOR_IN
1492: IFFALSE 1527
// begin PlaceUnitArea ( unit , BelkovReturnArea , false ) ;
1494: LD_VAR 0 2
1498: PPUSH
1499: LD_INT 11
1501: PPUSH
1502: LD_INT 0
1504: PPUSH
1505: CALL_OW 49
// belkovTeam = belkovTeam ^ unit ;
1509: LD_ADDR_EXP 73
1513: PUSH
1514: LD_EXP 73
1518: PUSH
1519: LD_VAR 0 2
1523: ADD
1524: ST_TO_ADDR
// end ;
1525: GO 1491
1527: POP
1528: POP
// end ;
1529: LD_VAR 0 1
1533: RET
// function PrepareCharactersFromPreviousMission ; var i ; begin
1534: LD_INT 0
1536: PPUSH
1537: PPUSH
// uc_side = 3 ;
1538: LD_ADDR_OWVAR 20
1542: PUSH
1543: LD_INT 3
1545: ST_TO_ADDR
// Burlak = PrepareUnit ( Burlak , true ) ;
1546: LD_ADDR_EXP 62
1550: PUSH
1551: LD_STRING Burlak
1553: PPUSH
1554: LD_INT 1
1556: PPUSH
1557: CALL 4030 0 2
1561: ST_TO_ADDR
// Gnyevko = PrepareUnit ( Gnyevko , true ) ;
1562: LD_ADDR_EXP 63
1566: PUSH
1567: LD_STRING Gnyevko
1569: PPUSH
1570: LD_INT 1
1572: PPUSH
1573: CALL 4030 0 2
1577: ST_TO_ADDR
// Belkov = PrepareUnit ( Belkov , true ) ;
1578: LD_ADDR_EXP 64
1582: PUSH
1583: LD_STRING Belkov
1585: PPUSH
1586: LD_INT 1
1588: PPUSH
1589: CALL 4030 0 2
1593: ST_TO_ADDR
// Kirilenkova = PrepareUnit ( Kirilenkova , true ) ;
1594: LD_ADDR_EXP 65
1598: PUSH
1599: LD_STRING Kirilenkova
1601: PPUSH
1602: LD_INT 1
1604: PPUSH
1605: CALL 4030 0 2
1609: ST_TO_ADDR
// PlaceUnitArea ( Burlak , BurlakSpawnArea , false ) ;
1610: LD_EXP 62
1614: PPUSH
1615: LD_INT 5
1617: PPUSH
1618: LD_INT 0
1620: PPUSH
1621: CALL_OW 49
// PlaceUnitArea ( Gnyevko , BurlakTeamSpawnArea , false ) ;
1625: LD_EXP 63
1629: PPUSH
1630: LD_INT 3
1632: PPUSH
1633: LD_INT 0
1635: PPUSH
1636: CALL_OW 49
// PlaceUnitArea ( Belkov , BurlakTeamSpawnArea , false ) ;
1640: LD_EXP 64
1644: PPUSH
1645: LD_INT 3
1647: PPUSH
1648: LD_INT 0
1650: PPUSH
1651: CALL_OW 49
// PlaceUnitArea ( Kirilenkova , BurlakTeamSpawnArea , false ) ;
1655: LD_EXP 65
1659: PPUSH
1660: LD_INT 3
1662: PPUSH
1663: LD_INT 0
1665: PPUSH
1666: CALL_OW 49
// CenterNowOnUnits ( Burlak ) ;
1670: LD_EXP 62
1674: PPUSH
1675: CALL_OW 87
// other_survivors = CreateCharacterSet ( 01_other_survivors ) ;
1679: LD_ADDR_EXP 66
1683: PUSH
1684: LD_STRING 01_other_survivors
1686: PPUSH
1687: CALL_OW 31
1691: ST_TO_ADDR
// for i in other_survivors do
1692: LD_ADDR_VAR 0 2
1696: PUSH
1697: LD_EXP 66
1701: PUSH
1702: FOR_IN
1703: IFFALSE 1722
// PlaceUnitArea ( i , BurlakTeamSpawnArea , false ) ;
1705: LD_VAR 0 2
1709: PPUSH
1710: LD_INT 3
1712: PPUSH
1713: LD_INT 0
1715: PPUSH
1716: CALL_OW 49
1720: GO 1702
1722: POP
1723: POP
// end ;
1724: LD_VAR 0 1
1728: RET
// function PrepareKirovBase ; var i , un ; begin
1729: LD_INT 0
1731: PPUSH
1732: PPUSH
1733: PPUSH
// SetBName ( kirov , kirov ) ;
1734: LD_INT 71
1736: PPUSH
1737: LD_STRING kirov
1739: PPUSH
1740: CALL_OW 500
// uc_side = 6 ;
1744: LD_ADDR_OWVAR 20
1748: PUSH
1749: LD_INT 6
1751: ST_TO_ADDR
// uc_nation = 3 ;
1752: LD_ADDR_OWVAR 21
1756: PUSH
1757: LD_INT 3
1759: ST_TO_ADDR
// hc_gallery =  ;
1760: LD_ADDR_OWVAR 33
1764: PUSH
1765: LD_STRING 
1767: ST_TO_ADDR
// hc_name =  ;
1768: LD_ADDR_OWVAR 26
1772: PUSH
1773: LD_STRING 
1775: ST_TO_ADDR
// Kurin = PrepareUnit ( Kurin , false ) ;
1776: LD_ADDR_EXP 67
1780: PUSH
1781: LD_STRING Kurin
1783: PPUSH
1784: LD_INT 0
1786: PPUSH
1787: CALL 4030 0 2
1791: ST_TO_ADDR
// Kovalyuk = PrepareUnit ( Kovalyuk , false ) ;
1792: LD_ADDR_EXP 70
1796: PUSH
1797: LD_STRING Kovalyuk
1799: PPUSH
1800: LD_INT 0
1802: PPUSH
1803: CALL 4030 0 2
1807: ST_TO_ADDR
// Belkov2 = PrepareUnit ( Belkov2 , false ) ;
1808: LD_ADDR_EXP 68
1812: PUSH
1813: LD_STRING Belkov2
1815: PPUSH
1816: LD_INT 0
1818: PPUSH
1819: CALL 4030 0 2
1823: ST_TO_ADDR
// PlaceUnitArea ( Kurin , KurinSpawnArea , false ) ;
1824: LD_EXP 67
1828: PPUSH
1829: LD_INT 4
1831: PPUSH
1832: LD_INT 0
1834: PPUSH
1835: CALL_OW 49
// PlaceUnitXYR ( Kovalyuk , 161 , 108 , 6 , false ) ;
1839: LD_EXP 70
1843: PPUSH
1844: LD_INT 161
1846: PPUSH
1847: LD_INT 108
1849: PPUSH
1850: LD_INT 6
1852: PPUSH
1853: LD_INT 0
1855: PPUSH
1856: CALL_OW 50
// ComHold ( Kurin ) ;
1860: LD_EXP 67
1864: PPUSH
1865: CALL_OW 140
// otherKirovUnits = [ ] ;
1869: LD_ADDR_EXP 69
1873: PUSH
1874: EMPTY
1875: ST_TO_ADDR
// kirovAmountPeople = Replace ( kirovAmountPeople , 1 , kirovAmountPeople [ 1 ] - UnitFilter ( other_survivors , [ f_class , class_soldier ] ) ) ;
1876: LD_ADDR_EXP 51
1880: PUSH
1881: LD_EXP 51
1885: PPUSH
1886: LD_INT 1
1888: PPUSH
1889: LD_EXP 51
1893: PUSH
1894: LD_INT 1
1896: ARRAY
1897: PUSH
1898: LD_EXP 66
1902: PPUSH
1903: LD_INT 25
1905: PUSH
1906: LD_INT 1
1908: PUSH
1909: EMPTY
1910: LIST
1911: LIST
1912: PPUSH
1913: CALL_OW 72
1917: MINUS
1918: PPUSH
1919: CALL_OW 1
1923: ST_TO_ADDR
// for i := 1 to kirovAmountPeople [ 1 ] do
1924: LD_ADDR_VAR 0 2
1928: PUSH
1929: DOUBLE
1930: LD_INT 1
1932: DEC
1933: ST_TO_ADDR
1934: LD_EXP 51
1938: PUSH
1939: LD_INT 1
1941: ARRAY
1942: PUSH
1943: FOR_TO
1944: IFFALSE 2123
// begin PrepareHuman ( false , 1 , rand ( 1 , 3 ) ) ;
1946: LD_INT 0
1948: PPUSH
1949: LD_INT 1
1951: PPUSH
1952: LD_INT 1
1954: PPUSH
1955: LD_INT 3
1957: PPUSH
1958: CALL_OW 12
1962: PPUSH
1963: CALL_OW 380
// un = CreateHuman ;
1967: LD_ADDR_VAR 0 3
1971: PUSH
1972: CALL_OW 44
1976: ST_TO_ADDR
// otherKirovUnits = otherKirovUnits ^ un ;
1977: LD_ADDR_EXP 69
1981: PUSH
1982: LD_EXP 69
1986: PUSH
1987: LD_VAR 0 3
1991: ADD
1992: ST_TO_ADDR
// if FilterUnitsInArea ( KirovBaseArea , [ [ f_side , 6 ] , [ f_type , unit_building ] , [ f_btype , b_breastwork ] , [ f_empty ] ] ) then
1993: LD_INT 9
1995: PPUSH
1996: LD_INT 22
1998: PUSH
1999: LD_INT 6
2001: PUSH
2002: EMPTY
2003: LIST
2004: LIST
2005: PUSH
2006: LD_INT 21
2008: PUSH
2009: LD_INT 3
2011: PUSH
2012: EMPTY
2013: LIST
2014: LIST
2015: PUSH
2016: LD_INT 30
2018: PUSH
2019: LD_INT 31
2021: PUSH
2022: EMPTY
2023: LIST
2024: LIST
2025: PUSH
2026: LD_INT 58
2028: PUSH
2029: EMPTY
2030: LIST
2031: PUSH
2032: EMPTY
2033: LIST
2034: LIST
2035: LIST
2036: LIST
2037: PPUSH
2038: CALL_OW 70
2042: IFFALSE 2109
// PlaceSolBun ( un , FilterUnitsInArea ( KirovBaseArea , [ [ f_side , 6 ] , [ f_type , unit_building ] , [ f_btype , b_breastwork ] , [ f_empty ] ] ) [ 1 ] ) else
2044: LD_VAR 0 3
2048: PPUSH
2049: LD_INT 9
2051: PPUSH
2052: LD_INT 22
2054: PUSH
2055: LD_INT 6
2057: PUSH
2058: EMPTY
2059: LIST
2060: LIST
2061: PUSH
2062: LD_INT 21
2064: PUSH
2065: LD_INT 3
2067: PUSH
2068: EMPTY
2069: LIST
2070: LIST
2071: PUSH
2072: LD_INT 30
2074: PUSH
2075: LD_INT 31
2077: PUSH
2078: EMPTY
2079: LIST
2080: LIST
2081: PUSH
2082: LD_INT 58
2084: PUSH
2085: EMPTY
2086: LIST
2087: PUSH
2088: EMPTY
2089: LIST
2090: LIST
2091: LIST
2092: LIST
2093: PPUSH
2094: CALL_OW 70
2098: PUSH
2099: LD_INT 1
2101: ARRAY
2102: PPUSH
2103: CALL 5269 0 2
2107: GO 2121
// PlaceHumanInUnit ( un , ru2_arm2 ) ;
2109: LD_VAR 0 3
2113: PPUSH
2114: LD_INT 209
2116: PPUSH
2117: CALL_OW 52
// end ;
2121: GO 1943
2123: POP
2124: POP
// PrepareHuman ( false , 1 , rand ( 1 , 3 ) ) ;
2125: LD_INT 0
2127: PPUSH
2128: LD_INT 1
2130: PPUSH
2131: LD_INT 1
2133: PPUSH
2134: LD_INT 3
2136: PPUSH
2137: CALL_OW 12
2141: PPUSH
2142: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , ru2_arm2 ) ;
2146: CALL_OW 44
2150: PPUSH
2151: LD_INT 209
2153: PPUSH
2154: CALL_OW 52
// for i := 1 to kirovAmountPeople [ 2 ] do
2158: LD_ADDR_VAR 0 2
2162: PUSH
2163: DOUBLE
2164: LD_INT 1
2166: DEC
2167: ST_TO_ADDR
2168: LD_EXP 51
2172: PUSH
2173: LD_INT 2
2175: ARRAY
2176: PUSH
2177: FOR_TO
2178: IFFALSE 2241
// begin PrepareHuman ( false , 2 , rand ( 1 , 3 ) ) ;
2180: LD_INT 0
2182: PPUSH
2183: LD_INT 2
2185: PPUSH
2186: LD_INT 1
2188: PPUSH
2189: LD_INT 3
2191: PPUSH
2192: CALL_OW 12
2196: PPUSH
2197: CALL_OW 380
// un = CreateHuman ;
2201: LD_ADDR_VAR 0 3
2205: PUSH
2206: CALL_OW 44
2210: ST_TO_ADDR
// otherKirovUnits = otherKirovUnits ^ un ;
2211: LD_ADDR_EXP 69
2215: PUSH
2216: LD_EXP 69
2220: PUSH
2221: LD_VAR 0 3
2225: ADD
2226: ST_TO_ADDR
// PlaceHumanInUnit ( un , kirov ) ;
2227: LD_VAR 0 3
2231: PPUSH
2232: LD_INT 71
2234: PPUSH
2235: CALL_OW 52
// end ;
2239: GO 2177
2241: POP
2242: POP
// for i := 1 to kirovAmountPeople [ 3 ] do
2243: LD_ADDR_VAR 0 2
2247: PUSH
2248: DOUBLE
2249: LD_INT 1
2251: DEC
2252: ST_TO_ADDR
2253: LD_EXP 51
2257: PUSH
2258: LD_INT 3
2260: ARRAY
2261: PUSH
2262: FOR_TO
2263: IFFALSE 2326
// begin PrepareHuman ( false , 3 , rand ( 1 , 3 ) ) ;
2265: LD_INT 0
2267: PPUSH
2268: LD_INT 3
2270: PPUSH
2271: LD_INT 1
2273: PPUSH
2274: LD_INT 3
2276: PPUSH
2277: CALL_OW 12
2281: PPUSH
2282: CALL_OW 380
// un = CreateHuman ;
2286: LD_ADDR_VAR 0 3
2290: PUSH
2291: CALL_OW 44
2295: ST_TO_ADDR
// otherKirovUnits = otherKirovUnits ^ un ;
2296: LD_ADDR_EXP 69
2300: PUSH
2301: LD_EXP 69
2305: PUSH
2306: LD_VAR 0 3
2310: ADD
2311: ST_TO_ADDR
// PlaceHumanInUnit ( un , kirov ) ;
2312: LD_VAR 0 3
2316: PPUSH
2317: LD_INT 71
2319: PPUSH
2320: CALL_OW 52
// end ;
2324: GO 2262
2326: POP
2327: POP
// for i := 1 to kirovAmountPeople [ 4 ] do
2328: LD_ADDR_VAR 0 2
2332: PUSH
2333: DOUBLE
2334: LD_INT 1
2336: DEC
2337: ST_TO_ADDR
2338: LD_EXP 51
2342: PUSH
2343: LD_INT 4
2345: ARRAY
2346: PUSH
2347: FOR_TO
2348: IFFALSE 2411
// begin PrepareHuman ( false , 4 , rand ( 1 , 3 ) ) ;
2350: LD_INT 0
2352: PPUSH
2353: LD_INT 4
2355: PPUSH
2356: LD_INT 1
2358: PPUSH
2359: LD_INT 3
2361: PPUSH
2362: CALL_OW 12
2366: PPUSH
2367: CALL_OW 380
// un = CreateHuman ;
2371: LD_ADDR_VAR 0 3
2375: PUSH
2376: CALL_OW 44
2380: ST_TO_ADDR
// otherKirovUnits = otherKirovUnits ^ un ;
2381: LD_ADDR_EXP 69
2385: PUSH
2386: LD_EXP 69
2390: PUSH
2391: LD_VAR 0 3
2395: ADD
2396: ST_TO_ADDR
// PlaceHumanInUnit ( un , ru_lab ) ;
2397: LD_VAR 0 3
2401: PPUSH
2402: LD_INT 83
2404: PPUSH
2405: CALL_OW 52
// end ;
2409: GO 2347
2411: POP
2412: POP
// ResAllTechs ( 6 , ru_lab , 3 ) ;
2413: LD_INT 6
2415: PPUSH
2416: LD_INT 83
2418: PPUSH
2419: LD_INT 3
2421: PPUSH
2422: CALL 4882 0 3
// if not TestCharacters ( 01_Gnyevko ) then
2426: LD_STRING 01_Gnyevko
2428: PPUSH
2429: CALL_OW 28
2433: NOT
2434: IFFALSE 2477
// begin PrepareMechanic ( sex_male , 3 ) ;
2436: LD_INT 1
2438: PPUSH
2439: LD_INT 3
2441: PPUSH
2442: CALL_OW 383
// randomMech = CreateHuman ;
2446: LD_ADDR_EXP 71
2450: PUSH
2451: CALL_OW 44
2455: ST_TO_ADDR
// PlaceUnitXYR ( randomMech , 161 , 108 , 6 , false ) ;
2456: LD_EXP 71
2460: PPUSH
2461: LD_INT 161
2463: PPUSH
2464: LD_INT 108
2466: PPUSH
2467: LD_INT 6
2469: PPUSH
2470: LD_INT 0
2472: PPUSH
2473: CALL_OW 50
// end ; PlaceHumanInUnit ( Belkov2 , ru2_arm1 ) ;
2477: LD_EXP 68
2481: PPUSH
2482: LD_INT 95
2484: PPUSH
2485: CALL_OW 52
// end ;
2489: LD_VAR 0 1
2493: RET
// function PrepareBeriaBase ; var i , un , unitsTemp , bunker ; begin
2494: LD_INT 0
2496: PPUSH
2497: PPUSH
2498: PPUSH
2499: PPUSH
2500: PPUSH
// SetBName ( beria , beria ) ;
2501: LD_INT 106
2503: PPUSH
2504: LD_STRING beria
2506: PPUSH
2507: CALL_OW 500
// uc_side = 6 ;
2511: LD_ADDR_OWVAR 20
2515: PUSH
2516: LD_INT 6
2518: ST_TO_ADDR
// uc_nation = 3 ;
2519: LD_ADDR_OWVAR 21
2523: PUSH
2524: LD_INT 3
2526: ST_TO_ADDR
// Platonov = PrepareUnit ( Platonov , false ) ;
2527: LD_ADDR_EXP 76
2531: PUSH
2532: LD_STRING Platonov
2534: PPUSH
2535: LD_INT 0
2537: PPUSH
2538: CALL 4030 0 2
2542: ST_TO_ADDR
// PlaceUnitXY ( Platonov , 112 , 97 , false ) ;
2543: LD_EXP 76
2547: PPUSH
2548: LD_INT 112
2550: PPUSH
2551: LD_INT 97
2553: PPUSH
2554: LD_INT 0
2556: PPUSH
2557: CALL_OW 48
// ComHold ( Platonov ) ;
2561: LD_EXP 76
2565: PPUSH
2566: CALL_OW 140
// platSoldiers = [ ] ;
2570: LD_ADDR_EXP 77
2574: PUSH
2575: EMPTY
2576: ST_TO_ADDR
// unitsTemp = [ ] ;
2577: LD_ADDR_VAR 0 4
2581: PUSH
2582: EMPTY
2583: ST_TO_ADDR
// Kuklajs = PrepareUnit ( Kuklajs , false ) ;
2584: LD_ADDR_EXP 78
2588: PUSH
2589: LD_STRING Kuklajs
2591: PPUSH
2592: LD_INT 0
2594: PPUSH
2595: CALL 4030 0 2
2599: ST_TO_ADDR
// platSoldiers = platSoldiers ^ Kuklajs ;
2600: LD_ADDR_EXP 77
2604: PUSH
2605: LD_EXP 77
2609: PUSH
2610: LD_EXP 78
2614: ADD
2615: ST_TO_ADDR
// PlaceUnitXYR ( Kuklajs , 110 , 97 , 6 , false ) ;
2616: LD_EXP 78
2620: PPUSH
2621: LD_INT 110
2623: PPUSH
2624: LD_INT 97
2626: PPUSH
2627: LD_INT 6
2629: PPUSH
2630: LD_INT 0
2632: PPUSH
2633: CALL_OW 50
// Benko = PrepareUnit ( Benko , false ) ;
2637: LD_ADDR_EXP 79
2641: PUSH
2642: LD_STRING Benko
2644: PPUSH
2645: LD_INT 0
2647: PPUSH
2648: CALL 4030 0 2
2652: ST_TO_ADDR
// platSoldiers = platSoldiers ^ Benko ;
2653: LD_ADDR_EXP 77
2657: PUSH
2658: LD_EXP 77
2662: PUSH
2663: LD_EXP 79
2667: ADD
2668: ST_TO_ADDR
// unitsTemp = unitsTemp ^ Benko ;
2669: LD_ADDR_VAR 0 4
2673: PUSH
2674: LD_VAR 0 4
2678: PUSH
2679: LD_EXP 79
2683: ADD
2684: ST_TO_ADDR
// for i := 1 to 2 do
2685: LD_ADDR_VAR 0 2
2689: PUSH
2690: DOUBLE
2691: LD_INT 1
2693: DEC
2694: ST_TO_ADDR
2695: LD_INT 2
2697: PUSH
2698: FOR_TO
2699: IFFALSE 2766
// begin PrepareHuman ( false , 1 , rand ( 1 , 3 ) ) ;
2701: LD_INT 0
2703: PPUSH
2704: LD_INT 1
2706: PPUSH
2707: LD_INT 1
2709: PPUSH
2710: LD_INT 3
2712: PPUSH
2713: CALL_OW 12
2717: PPUSH
2718: CALL_OW 380
// un = CreateHuman ;
2722: LD_ADDR_VAR 0 3
2726: PUSH
2727: CALL_OW 44
2731: ST_TO_ADDR
// platSoldiers = platSoldiers ^ un ;
2732: LD_ADDR_EXP 77
2736: PUSH
2737: LD_EXP 77
2741: PUSH
2742: LD_VAR 0 3
2746: ADD
2747: ST_TO_ADDR
// unitsTemp = unitsTemp ^ un ;
2748: LD_ADDR_VAR 0 4
2752: PUSH
2753: LD_VAR 0 4
2757: PUSH
2758: LD_VAR 0 3
2762: ADD
2763: ST_TO_ADDR
// end ;
2764: GO 2698
2766: POP
2767: POP
// for i := 1 to unitsTemp do
2768: LD_ADDR_VAR 0 2
2772: PUSH
2773: DOUBLE
2774: LD_INT 1
2776: DEC
2777: ST_TO_ADDR
2778: LD_VAR 0 4
2782: PUSH
2783: FOR_TO
2784: IFFALSE 2872
// begin bunker = FilterUnitsInArea ( BeriaBaseArea , [ [ f_side , 6 ] , [ f_btype , b_breastwork ] ] ) [ i ] ;
2786: LD_ADDR_VAR 0 5
2790: PUSH
2791: LD_INT 8
2793: PPUSH
2794: LD_INT 22
2796: PUSH
2797: LD_INT 6
2799: PUSH
2800: EMPTY
2801: LIST
2802: LIST
2803: PUSH
2804: LD_INT 30
2806: PUSH
2807: LD_INT 31
2809: PUSH
2810: EMPTY
2811: LIST
2812: LIST
2813: PUSH
2814: EMPTY
2815: LIST
2816: LIST
2817: PPUSH
2818: CALL_OW 70
2822: PUSH
2823: LD_VAR 0 2
2827: ARRAY
2828: ST_TO_ADDR
// PlaceUnitXYR ( unitsTemp [ i ] , GetX ( bunker ) , GetY ( bunker ) , 2 , false ) ;
2829: LD_VAR 0 4
2833: PUSH
2834: LD_VAR 0 2
2838: ARRAY
2839: PPUSH
2840: LD_VAR 0 5
2844: PPUSH
2845: CALL_OW 250
2849: PPUSH
2850: LD_VAR 0 5
2854: PPUSH
2855: CALL_OW 251
2859: PPUSH
2860: LD_INT 2
2862: PPUSH
2863: LD_INT 0
2865: PPUSH
2866: CALL_OW 50
// end ;
2870: GO 2783
2872: POP
2873: POP
// end ; end_of_file
2874: LD_VAR 0 1
2878: RET
// export trapCommander ; export trapTeam ; export leftBunkers , rightBunkers ; export amLeftDepot , amRightDepot ; export amLeftEngs , amRightEngs ; export amVeh , amMech ; export function PrepareAmerican ; begin
2879: LD_INT 0
2881: PPUSH
// PrepareTrap ;
2882: CALL 2895 0 0
// PrepareBunkiers ;
2886: CALL 3485 0 0
// end ;
2890: LD_VAR 0 1
2894: RET
// function PrepareTrap ; var i , un ; begin
2895: LD_INT 0
2897: PPUSH
2898: PPUSH
2899: PPUSH
// trapTeam = [ ] ;
2900: LD_ADDR_EXP 81
2904: PUSH
2905: EMPTY
2906: ST_TO_ADDR
// uc_nation = 1 ;
2907: LD_ADDR_OWVAR 21
2911: PUSH
2912: LD_INT 1
2914: ST_TO_ADDR
// uc_side = 1 ;
2915: LD_ADDR_OWVAR 20
2919: PUSH
2920: LD_INT 1
2922: ST_TO_ADDR
// hc_gallery =  ;
2923: LD_ADDR_OWVAR 33
2927: PUSH
2928: LD_STRING 
2930: ST_TO_ADDR
// hc_name =  ;
2931: LD_ADDR_OWVAR 26
2935: PUSH
2936: LD_STRING 
2938: ST_TO_ADDR
// hc_importance = 100 ;
2939: LD_ADDR_OWVAR 32
2943: PUSH
2944: LD_INT 100
2946: ST_TO_ADDR
// PrepareHuman ( sex_male , 1 , enemySkillLevel + 1 ) ;
2947: LD_INT 1
2949: PPUSH
2950: LD_INT 1
2952: PPUSH
2953: LD_EXP 59
2957: PUSH
2958: LD_INT 1
2960: PLUS
2961: PPUSH
2962: CALL_OW 380
// trapCommander = CreateHuman ;
2966: LD_ADDR_EXP 80
2970: PUSH
2971: CALL_OW 44
2975: ST_TO_ADDR
// PlaceUnitArea ( trapCommander , AmCommanderSpawn , false ) ;
2976: LD_EXP 80
2980: PPUSH
2981: LD_INT 13
2983: PPUSH
2984: LD_INT 0
2986: PPUSH
2987: CALL_OW 49
// ComCrawl ( trapCommander ) ;
2991: LD_EXP 80
2995: PPUSH
2996: CALL_OW 137
// trapTeam = trapTeam ^ trapCommander ;
3000: LD_ADDR_EXP 81
3004: PUSH
3005: LD_EXP 81
3009: PUSH
3010: LD_EXP 80
3014: ADD
3015: ST_TO_ADDR
// hc_importance = 0 ;
3016: LD_ADDR_OWVAR 32
3020: PUSH
3021: LD_INT 0
3023: ST_TO_ADDR
// for i := 1 to trapAmountPeople [ 1 ] do
3024: LD_ADDR_VAR 0 2
3028: PUSH
3029: DOUBLE
3030: LD_INT 1
3032: DEC
3033: ST_TO_ADDR
3034: LD_EXP 60
3038: PUSH
3039: LD_INT 1
3041: ARRAY
3042: PUSH
3043: FOR_TO
3044: IFFALSE 3136
// begin hc_name =  ;
3046: LD_ADDR_OWVAR 26
3050: PUSH
3051: LD_STRING 
3053: ST_TO_ADDR
// PrepareHuman ( false , 1 , enemySkillLevel ) ;
3054: LD_INT 0
3056: PPUSH
3057: LD_INT 1
3059: PPUSH
3060: LD_EXP 59
3064: PPUSH
3065: CALL_OW 380
// un = CreateHuman ;
3069: LD_ADDR_VAR 0 3
3073: PUSH
3074: CALL_OW 44
3078: ST_TO_ADDR
// PlaceUnitArea ( un , AmTrapSpawn1 , false ) ;
3079: LD_VAR 0 3
3083: PPUSH
3084: LD_INT 12
3086: PPUSH
3087: LD_INT 0
3089: PPUSH
3090: CALL_OW 49
// ComCrawl ( un ) ;
3094: LD_VAR 0 3
3098: PPUSH
3099: CALL_OW 137
// AddComTurnXY ( un , 116 , 21 ) ;
3103: LD_VAR 0 3
3107: PPUSH
3108: LD_INT 116
3110: PPUSH
3111: LD_INT 21
3113: PPUSH
3114: CALL_OW 178
// trapTeam = trapTeam ^ un ;
3118: LD_ADDR_EXP 81
3122: PUSH
3123: LD_EXP 81
3127: PUSH
3128: LD_VAR 0 3
3132: ADD
3133: ST_TO_ADDR
// end ;
3134: GO 3043
3136: POP
3137: POP
// for i := 1 to trapAmountPeople [ 2 ] do
3138: LD_ADDR_VAR 0 2
3142: PUSH
3143: DOUBLE
3144: LD_INT 1
3146: DEC
3147: ST_TO_ADDR
3148: LD_EXP 60
3152: PUSH
3153: LD_INT 2
3155: ARRAY
3156: PUSH
3157: FOR_TO
3158: IFFALSE 3250
// begin hc_name =  ;
3160: LD_ADDR_OWVAR 26
3164: PUSH
3165: LD_STRING 
3167: ST_TO_ADDR
// PrepareHuman ( false , 1 , enemySkillLevel ) ;
3168: LD_INT 0
3170: PPUSH
3171: LD_INT 1
3173: PPUSH
3174: LD_EXP 59
3178: PPUSH
3179: CALL_OW 380
// un = CreateHuman ;
3183: LD_ADDR_VAR 0 3
3187: PUSH
3188: CALL_OW 44
3192: ST_TO_ADDR
// PlaceUnitArea ( un , AmTrapSpawn2 , false ) ;
3193: LD_VAR 0 3
3197: PPUSH
3198: LD_INT 14
3200: PPUSH
3201: LD_INT 0
3203: PPUSH
3204: CALL_OW 49
// ComCrawl ( un ) ;
3208: LD_VAR 0 3
3212: PPUSH
3213: CALL_OW 137
// AddComTurnXY ( un , 116 , 21 ) ;
3217: LD_VAR 0 3
3221: PPUSH
3222: LD_INT 116
3224: PPUSH
3225: LD_INT 21
3227: PPUSH
3228: CALL_OW 178
// trapTeam = trapTeam ^ un ;
3232: LD_ADDR_EXP 81
3236: PUSH
3237: LD_EXP 81
3241: PUSH
3242: LD_VAR 0 3
3246: ADD
3247: ST_TO_ADDR
// end ;
3248: GO 3157
3250: POP
3251: POP
// for i := 1 to trapAmountPeople [ 3 ] do
3252: LD_ADDR_VAR 0 2
3256: PUSH
3257: DOUBLE
3258: LD_INT 1
3260: DEC
3261: ST_TO_ADDR
3262: LD_EXP 60
3266: PUSH
3267: LD_INT 3
3269: ARRAY
3270: PUSH
3271: FOR_TO
3272: IFFALSE 3364
// begin hc_name =  ;
3274: LD_ADDR_OWVAR 26
3278: PUSH
3279: LD_STRING 
3281: ST_TO_ADDR
// PrepareHuman ( false , 1 , enemySkillLevel ) ;
3282: LD_INT 0
3284: PPUSH
3285: LD_INT 1
3287: PPUSH
3288: LD_EXP 59
3292: PPUSH
3293: CALL_OW 380
// un = CreateHuman ;
3297: LD_ADDR_VAR 0 3
3301: PUSH
3302: CALL_OW 44
3306: ST_TO_ADDR
// PlaceUnitArea ( un , AmTrapSpawn3 , false ) ;
3307: LD_VAR 0 3
3311: PPUSH
3312: LD_INT 23
3314: PPUSH
3315: LD_INT 0
3317: PPUSH
3318: CALL_OW 49
// ComCrawl ( un ) ;
3322: LD_VAR 0 3
3326: PPUSH
3327: CALL_OW 137
// AddComTurnXY ( un , 109 , 8 ) ;
3331: LD_VAR 0 3
3335: PPUSH
3336: LD_INT 109
3338: PPUSH
3339: LD_INT 8
3341: PPUSH
3342: CALL_OW 178
// trapTeam = trapTeam ^ un ;
3346: LD_ADDR_EXP 81
3350: PUSH
3351: LD_EXP 81
3355: PUSH
3356: LD_VAR 0 3
3360: ADD
3361: ST_TO_ADDR
// end ;
3362: GO 3271
3364: POP
3365: POP
// for i := 1 to trapAmountPeople [ 4 ] do
3366: LD_ADDR_VAR 0 2
3370: PUSH
3371: DOUBLE
3372: LD_INT 1
3374: DEC
3375: ST_TO_ADDR
3376: LD_EXP 60
3380: PUSH
3381: LD_INT 4
3383: ARRAY
3384: PUSH
3385: FOR_TO
3386: IFFALSE 3478
// begin hc_name =  ;
3388: LD_ADDR_OWVAR 26
3392: PUSH
3393: LD_STRING 
3395: ST_TO_ADDR
// PrepareHuman ( false , 1 , enemySkillLevel ) ;
3396: LD_INT 0
3398: PPUSH
3399: LD_INT 1
3401: PPUSH
3402: LD_EXP 59
3406: PPUSH
3407: CALL_OW 380
// un = CreateHuman ;
3411: LD_ADDR_VAR 0 3
3415: PUSH
3416: CALL_OW 44
3420: ST_TO_ADDR
// PlaceUnitArea ( un , AmTrapSpawn4 , false ) ;
3421: LD_VAR 0 3
3425: PPUSH
3426: LD_INT 24
3428: PPUSH
3429: LD_INT 0
3431: PPUSH
3432: CALL_OW 49
// ComCrawl ( un ) ;
3436: LD_VAR 0 3
3440: PPUSH
3441: CALL_OW 137
// AddComTurnXY ( un , 109 , 8 ) ;
3445: LD_VAR 0 3
3449: PPUSH
3450: LD_INT 109
3452: PPUSH
3453: LD_INT 8
3455: PPUSH
3456: CALL_OW 178
// trapTeam = trapTeam ^ un ;
3460: LD_ADDR_EXP 81
3464: PUSH
3465: LD_EXP 81
3469: PUSH
3470: LD_VAR 0 3
3474: ADD
3475: ST_TO_ADDR
// end ;
3476: GO 3385
3478: POP
3479: POP
// end ;
3480: LD_VAR 0 1
3484: RET
// function PrepareBunkiers ; var i , un , bunker ; begin
3485: LD_INT 0
3487: PPUSH
3488: PPUSH
3489: PPUSH
3490: PPUSH
// uc_side = 1 ;
3491: LD_ADDR_OWVAR 20
3495: PUSH
3496: LD_INT 1
3498: ST_TO_ADDR
// uc_nation = nation_american ;
3499: LD_ADDR_OWVAR 21
3503: PUSH
3504: LD_INT 1
3506: ST_TO_ADDR
// bc_level = 1 ;
3507: LD_ADDR_OWVAR 43
3511: PUSH
3512: LD_INT 1
3514: ST_TO_ADDR
// bc_type = b_breastwork ;
3515: LD_ADDR_OWVAR 42
3519: PUSH
3520: LD_INT 31
3522: ST_TO_ADDR
// bunker = CreateAndPlaceBuildingXYD ( 104 , 59 , 4 ) ;
3523: LD_ADDR_VAR 0 4
3527: PUSH
3528: LD_INT 104
3530: PPUSH
3531: LD_INT 59
3533: PPUSH
3534: LD_INT 4
3536: PPUSH
3537: CALL_OW 47
3541: ST_TO_ADDR
// leftBunkers = leftBunkers ^ bunker ;
3542: LD_ADDR_EXP 82
3546: PUSH
3547: LD_EXP 82
3551: PUSH
3552: LD_VAR 0 4
3556: ADD
3557: ST_TO_ADDR
// PrepareSolBun ( enemySkillLevel , bunker ) ;
3558: LD_EXP 59
3562: PPUSH
3563: LD_VAR 0 4
3567: PPUSH
3568: CALL 5123 0 2
// bunker = CreateAndPlaceBuildingXYD ( 101 , 55 , 4 ) ;
3572: LD_ADDR_VAR 0 4
3576: PUSH
3577: LD_INT 101
3579: PPUSH
3580: LD_INT 55
3582: PPUSH
3583: LD_INT 4
3585: PPUSH
3586: CALL_OW 47
3590: ST_TO_ADDR
// leftBunkers = leftBunkers ^ bunker ;
3591: LD_ADDR_EXP 82
3595: PUSH
3596: LD_EXP 82
3600: PUSH
3601: LD_VAR 0 4
3605: ADD
3606: ST_TO_ADDR
// PrepareSolBun ( enemySkillLevel , bunker ) ;
3607: LD_EXP 59
3611: PPUSH
3612: LD_VAR 0 4
3616: PPUSH
3617: CALL 5123 0 2
// bunker = CreateAndPlaceBuildingXYD ( 132 , 62 , 1 ) ;
3621: LD_ADDR_VAR 0 4
3625: PUSH
3626: LD_INT 132
3628: PPUSH
3629: LD_INT 62
3631: PPUSH
3632: LD_INT 1
3634: PPUSH
3635: CALL_OW 47
3639: ST_TO_ADDR
// rightBunkers = rightBunkers ^ bunker ;
3640: LD_ADDR_EXP 83
3644: PUSH
3645: LD_EXP 83
3649: PUSH
3650: LD_VAR 0 4
3654: ADD
3655: ST_TO_ADDR
// PrepareSolBun ( enemySkillLevel , bunker ) ;
3656: LD_EXP 59
3660: PPUSH
3661: LD_VAR 0 4
3665: PPUSH
3666: CALL 5123 0 2
// bunker = CreateAndPlaceBuildingXYD ( 134 , 66 , 1 ) ;
3670: LD_ADDR_VAR 0 4
3674: PUSH
3675: LD_INT 134
3677: PPUSH
3678: LD_INT 66
3680: PPUSH
3681: LD_INT 1
3683: PPUSH
3684: CALL_OW 47
3688: ST_TO_ADDR
// rightBunkers = rightBunkers ^ bunker ;
3689: LD_ADDR_EXP 83
3693: PUSH
3694: LD_EXP 83
3698: PUSH
3699: LD_VAR 0 4
3703: ADD
3704: ST_TO_ADDR
// PrepareSolBun ( enemySkillLevel , bunker ) ;
3705: LD_EXP 59
3709: PPUSH
3710: LD_VAR 0 4
3714: PPUSH
3715: CALL 5123 0 2
// bc_type = b_depot ;
3719: LD_ADDR_OWVAR 42
3723: PUSH
3724: LD_INT 0
3726: ST_TO_ADDR
// amLeftDepot = CreateAndPlaceBuildingXYD ( 92 , 51 , 2 ) ;
3727: LD_ADDR_EXP 84
3731: PUSH
3732: LD_INT 92
3734: PPUSH
3735: LD_INT 51
3737: PPUSH
3738: LD_INT 2
3740: PPUSH
3741: CALL_OW 47
3745: ST_TO_ADDR
// amRightDepot = am_dep1 ;
3746: LD_ADDR_EXP 85
3750: PUSH
3751: LD_INT 193
3753: ST_TO_ADDR
// amLeftEngs = [ ] ;
3754: LD_ADDR_EXP 86
3758: PUSH
3759: EMPTY
3760: ST_TO_ADDR
// for i := 1 to [ 1 , 1 , rand ( 1 , 2 ) ] [ Difficulty ] do
3761: LD_ADDR_VAR 0 2
3765: PUSH
3766: DOUBLE
3767: LD_INT 1
3769: DEC
3770: ST_TO_ADDR
3771: LD_INT 1
3773: PUSH
3774: LD_INT 1
3776: PUSH
3777: LD_INT 1
3779: PPUSH
3780: LD_INT 2
3782: PPUSH
3783: CALL_OW 12
3787: PUSH
3788: EMPTY
3789: LIST
3790: LIST
3791: LIST
3792: PUSH
3793: LD_OWVAR 67
3797: ARRAY
3798: PUSH
3799: FOR_TO
3800: IFFALSE 3891
// begin uc_nation = 1 ;
3802: LD_ADDR_OWVAR 21
3806: PUSH
3807: LD_INT 1
3809: ST_TO_ADDR
// uc_side = 1 ;
3810: LD_ADDR_OWVAR 20
3814: PUSH
3815: LD_INT 1
3817: ST_TO_ADDR
// hc_gallery =  ;
3818: LD_ADDR_OWVAR 33
3822: PUSH
3823: LD_STRING 
3825: ST_TO_ADDR
// hc_name =  ;
3826: LD_ADDR_OWVAR 26
3830: PUSH
3831: LD_STRING 
3833: ST_TO_ADDR
// PrepareHuman ( false , 2 , enemySkillLevel ) ;
3834: LD_INT 0
3836: PPUSH
3837: LD_INT 2
3839: PPUSH
3840: LD_EXP 59
3844: PPUSH
3845: CALL_OW 380
// un = CreateHuman ;
3849: LD_ADDR_VAR 0 3
3853: PUSH
3854: CALL_OW 44
3858: ST_TO_ADDR
// amLeftEngs = amLeftEngs ^ un ;
3859: LD_ADDR_EXP 86
3863: PUSH
3864: LD_EXP 86
3868: PUSH
3869: LD_VAR 0 3
3873: ADD
3874: ST_TO_ADDR
// PlaceHumanInUnit ( un , amLeftDepot ) ;
3875: LD_VAR 0 3
3879: PPUSH
3880: LD_EXP 84
3884: PPUSH
3885: CALL_OW 52
// end ;
3889: GO 3799
3891: POP
3892: POP
// if Difficulty = 3 then
3893: LD_OWVAR 67
3897: PUSH
3898: LD_INT 3
3900: EQUAL
3901: IFFALSE 4025
// begin amRightEngs = [ ] ;
3903: LD_ADDR_EXP 87
3907: PUSH
3908: EMPTY
3909: ST_TO_ADDR
// for i := 1 to rand ( 1 , 2 ) do
3910: LD_ADDR_VAR 0 2
3914: PUSH
3915: DOUBLE
3916: LD_INT 1
3918: DEC
3919: ST_TO_ADDR
3920: LD_INT 1
3922: PPUSH
3923: LD_INT 2
3925: PPUSH
3926: CALL_OW 12
3930: PUSH
3931: FOR_TO
3932: IFFALSE 4023
// begin uc_nation = 1 ;
3934: LD_ADDR_OWVAR 21
3938: PUSH
3939: LD_INT 1
3941: ST_TO_ADDR
// uc_side = 1 ;
3942: LD_ADDR_OWVAR 20
3946: PUSH
3947: LD_INT 1
3949: ST_TO_ADDR
// hc_gallery =  ;
3950: LD_ADDR_OWVAR 33
3954: PUSH
3955: LD_STRING 
3957: ST_TO_ADDR
// hc_name =  ;
3958: LD_ADDR_OWVAR 26
3962: PUSH
3963: LD_STRING 
3965: ST_TO_ADDR
// PrepareHuman ( false , 2 , enemySkillLevel ) ;
3966: LD_INT 0
3968: PPUSH
3969: LD_INT 2
3971: PPUSH
3972: LD_EXP 59
3976: PPUSH
3977: CALL_OW 380
// un = CreateHuman ;
3981: LD_ADDR_VAR 0 3
3985: PUSH
3986: CALL_OW 44
3990: ST_TO_ADDR
// amRightEngs = amRightEngs ^ un ;
3991: LD_ADDR_EXP 87
3995: PUSH
3996: LD_EXP 87
4000: PUSH
4001: LD_VAR 0 3
4005: ADD
4006: ST_TO_ADDR
// PlaceHumanInUnit ( un , amRightDepot ) ;
4007: LD_VAR 0 3
4011: PPUSH
4012: LD_EXP 85
4016: PPUSH
4017: CALL_OW 52
// end ;
4021: GO 3931
4023: POP
4024: POP
// end ; end ; end_of_file
4025: LD_VAR 0 1
4029: RET
// export function PrepareUnit ( ident , exist_mode ) ; var unit ; begin
4030: LD_INT 0
4032: PPUSH
4033: PPUSH
// if exist_mode then
4034: LD_VAR 0 2
4038: IFFALSE 4063
// unit := CreateCharacter ( previousMissionPrefix & ident ) else
4040: LD_ADDR_VAR 0 4
4044: PUSH
4045: LD_EXP 49
4049: PUSH
4050: LD_VAR 0 1
4054: STR
4055: PPUSH
4056: CALL_OW 34
4060: ST_TO_ADDR
4061: GO 4078
// unit := NewCharacter ( ident ) ;
4063: LD_ADDR_VAR 0 4
4067: PUSH
4068: LD_VAR 0 1
4072: PPUSH
4073: CALL_OW 25
4077: ST_TO_ADDR
// result := unit ;
4078: LD_ADDR_VAR 0 3
4082: PUSH
4083: LD_VAR 0 4
4087: ST_TO_ADDR
// end ;
4088: LD_VAR 0 3
4092: RET
// export function DialogRandom ( characters , dialogMID , dialogFID , radio ) ; var i , speaker ; begin
4093: LD_INT 0
4095: PPUSH
4096: PPUSH
4097: PPUSH
// characters := characters diff [ Burlak , Gnyevko , Belkov , Kirilenkova ] ;
4098: LD_ADDR_VAR 0 1
4102: PUSH
4103: LD_VAR 0 1
4107: PUSH
4108: LD_EXP 62
4112: PUSH
4113: LD_EXP 63
4117: PUSH
4118: LD_EXP 64
4122: PUSH
4123: LD_EXP 65
4127: PUSH
4128: EMPTY
4129: LIST
4130: LIST
4131: LIST
4132: LIST
4133: DIFF
4134: ST_TO_ADDR
// speaker := characters [ rand ( 1 , characters ) ] ;
4135: LD_ADDR_VAR 0 7
4139: PUSH
4140: LD_VAR 0 1
4144: PUSH
4145: LD_INT 1
4147: PPUSH
4148: LD_VAR 0 1
4152: PPUSH
4153: CALL_OW 12
4157: ARRAY
4158: ST_TO_ADDR
// if radio then
4159: LD_VAR 0 4
4163: IFFALSE 4212
// begin if GetSex ( speaker ) = sex_male then
4165: LD_VAR 0 7
4169: PPUSH
4170: CALL_OW 258
4174: PUSH
4175: LD_INT 1
4177: EQUAL
4178: IFFALSE 4196
// SayRadio ( speaker , dialogMID ) else
4180: LD_VAR 0 7
4184: PPUSH
4185: LD_VAR 0 2
4189: PPUSH
4190: CALL_OW 94
4194: GO 4210
// SayRadio ( speaker , dialogFID ) ;
4196: LD_VAR 0 7
4200: PPUSH
4201: LD_VAR 0 3
4205: PPUSH
4206: CALL_OW 94
// end else
4210: GO 4257
// begin if GetSex ( speaker ) = sex_male then
4212: LD_VAR 0 7
4216: PPUSH
4217: CALL_OW 258
4221: PUSH
4222: LD_INT 1
4224: EQUAL
4225: IFFALSE 4243
// Say ( speaker , dialogMID ) else
4227: LD_VAR 0 7
4231: PPUSH
4232: LD_VAR 0 2
4236: PPUSH
4237: CALL_OW 88
4241: GO 4257
// Say ( speaker , dialogFID ) ;
4243: LD_VAR 0 7
4247: PPUSH
4248: LD_VAR 0 3
4252: PPUSH
4253: CALL_OW 88
// end ; result := speaker ;
4257: LD_ADDR_VAR 0 5
4261: PUSH
4262: LD_VAR 0 7
4266: ST_TO_ADDR
// end ;
4267: LD_VAR 0 5
4271: RET
// export function ExtSaveCharacter ( character , characterStringID , side ) ; begin
4272: LD_INT 0
4274: PPUSH
// if GetSide ( character ) = side and IsOK ( character ) then
4275: LD_VAR 0 1
4279: PPUSH
4280: CALL_OW 255
4284: PUSH
4285: LD_VAR 0 3
4289: EQUAL
4290: PUSH
4291: LD_VAR 0 1
4295: PPUSH
4296: CALL_OW 302
4300: AND
4301: IFFALSE 4323
// SaveCharacters ( character , missionPrefix & characterStringID ) ;
4303: LD_VAR 0 1
4307: PPUSH
4308: LD_EXP 48
4312: PUSH
4313: LD_VAR 0 2
4317: STR
4318: PPUSH
4319: CALL_OW 38
// end ;
4323: LD_VAR 0 4
4327: RET
// export function ExtSaveCharacters ( characters , charactersStringID , side ) ; var unit , resultCharactersToSave ; begin
4328: LD_INT 0
4330: PPUSH
4331: PPUSH
4332: PPUSH
// resultCharactersToSave = [ ] ;
4333: LD_ADDR_VAR 0 6
4337: PUSH
4338: EMPTY
4339: ST_TO_ADDR
// for unit in characters do
4340: LD_ADDR_VAR 0 5
4344: PUSH
4345: LD_VAR 0 1
4349: PUSH
4350: FOR_IN
4351: IFFALSE 4399
// if GetSide ( unit ) = side and IsOK ( unit ) then
4353: LD_VAR 0 5
4357: PPUSH
4358: CALL_OW 255
4362: PUSH
4363: LD_VAR 0 3
4367: EQUAL
4368: PUSH
4369: LD_VAR 0 5
4373: PPUSH
4374: CALL_OW 302
4378: AND
4379: IFFALSE 4397
// resultCharactersToSave = resultCharactersToSave ^ unit ;
4381: LD_ADDR_VAR 0 6
4385: PUSH
4386: LD_VAR 0 6
4390: PUSH
4391: LD_VAR 0 5
4395: ADD
4396: ST_TO_ADDR
4397: GO 4350
4399: POP
4400: POP
// SaveCharacters ( resultCharactersToSave , missionPrefix & charactersStringID ) ;
4401: LD_VAR 0 6
4405: PPUSH
4406: LD_EXP 48
4410: PUSH
4411: LD_VAR 0 2
4415: STR
4416: PPUSH
4417: CALL_OW 38
// end ;
4421: LD_VAR 0 4
4425: RET
// export function Question1 ( q ) ; var dec , q1 ; begin
4426: LD_INT 0
4428: PPUSH
4429: PPUSH
4430: PPUSH
// dec = SelectiveQuery ( QMoreInfo , q ) ;
4431: LD_ADDR_VAR 0 3
4435: PUSH
4436: LD_STRING QMoreInfo
4438: PPUSH
4439: LD_VAR 0 1
4443: PPUSH
4444: CALL_OW 98
4448: ST_TO_ADDR
// case dec of 1 :
4449: LD_VAR 0 3
4453: PUSH
4454: LD_INT 1
4456: DOUBLE
4457: EQUAL
4458: IFTRUE 4462
4460: GO 4522
4462: POP
// begin Say ( Burlak , D2a-Bur-1 ) ;
4463: LD_EXP 62
4467: PPUSH
4468: LD_STRING D2a-Bur-1
4470: PPUSH
4471: CALL_OW 88
// Say ( Platonov , D2a-Pla-1 ) ;
4475: LD_EXP 76
4479: PPUSH
4480: LD_STRING D2a-Pla-1
4482: PPUSH
4483: CALL_OW 88
// q1 = q diff 1 ;
4487: LD_ADDR_VAR 0 4
4491: PUSH
4492: LD_VAR 0 1
4496: PUSH
4497: LD_INT 1
4499: DIFF
4500: ST_TO_ADDR
// if q1 >= 2 then
4501: LD_VAR 0 4
4505: PUSH
4506: LD_INT 2
4508: GREATEREQUAL
4509: IFFALSE 4520
// Question1 ( q1 ) ;
4511: LD_VAR 0 4
4515: PPUSH
4516: CALL 4426 0 1
// end ; 2 :
4520: GO 4659
4522: LD_INT 2
4524: DOUBLE
4525: EQUAL
4526: IFTRUE 4530
4528: GO 4590
4530: POP
// begin Say ( Burlak , D2b-Bur-1 ) ;
4531: LD_EXP 62
4535: PPUSH
4536: LD_STRING D2b-Bur-1
4538: PPUSH
4539: CALL_OW 88
// Say ( Platonov , D2b-Pla-1 ) ;
4543: LD_EXP 76
4547: PPUSH
4548: LD_STRING D2b-Pla-1
4550: PPUSH
4551: CALL_OW 88
// q1 = q diff 2 ;
4555: LD_ADDR_VAR 0 4
4559: PUSH
4560: LD_VAR 0 1
4564: PUSH
4565: LD_INT 2
4567: DIFF
4568: ST_TO_ADDR
// if q1 >= 2 then
4569: LD_VAR 0 4
4573: PUSH
4574: LD_INT 2
4576: GREATEREQUAL
4577: IFFALSE 4588
// Question1 ( q1 ) ;
4579: LD_VAR 0 4
4583: PPUSH
4584: CALL 4426 0 1
// end ; 3 :
4588: GO 4659
4590: LD_INT 3
4592: DOUBLE
4593: EQUAL
4594: IFTRUE 4598
4596: GO 4658
4598: POP
// begin Say ( Burlak , D2c-Bur-1 ) ;
4599: LD_EXP 62
4603: PPUSH
4604: LD_STRING D2c-Bur-1
4606: PPUSH
4607: CALL_OW 88
// Say ( Platonov , D2c-Pla-1 ) ;
4611: LD_EXP 76
4615: PPUSH
4616: LD_STRING D2c-Pla-1
4618: PPUSH
4619: CALL_OW 88
// q1 = q diff 3 ;
4623: LD_ADDR_VAR 0 4
4627: PUSH
4628: LD_VAR 0 1
4632: PUSH
4633: LD_INT 3
4635: DIFF
4636: ST_TO_ADDR
// if q1 >= 2 then
4637: LD_VAR 0 4
4641: PUSH
4642: LD_INT 2
4644: GREATEREQUAL
4645: IFFALSE 4656
// Question1 ( q1 ) ;
4647: LD_VAR 0 4
4651: PPUSH
4652: CALL 4426 0 1
// end ; end ;
4656: GO 4659
4658: POP
// end ;
4659: LD_VAR 0 2
4663: RET
// export function ExtAddComRefuel ( engineer , depot , vehicle ) ; var taskList ; begin
4664: LD_INT 0
4666: PPUSH
4667: PPUSH
// if not IsOK ( engineer ) or not IsOK ( depot ) or not IsOK ( vehicle ) or GetFuel ( vehicle ) = 100 or not GetBType ( depot ) in [ b_depot , b_warehouse ] then
4668: LD_VAR 0 1
4672: PPUSH
4673: CALL_OW 302
4677: NOT
4678: PUSH
4679: LD_VAR 0 2
4683: PPUSH
4684: CALL_OW 302
4688: NOT
4689: OR
4690: PUSH
4691: LD_VAR 0 3
4695: PPUSH
4696: CALL_OW 302
4700: NOT
4701: OR
4702: PUSH
4703: LD_VAR 0 3
4707: PPUSH
4708: CALL_OW 261
4712: PUSH
4713: LD_INT 100
4715: EQUAL
4716: OR
4717: PUSH
4718: LD_VAR 0 2
4722: PPUSH
4723: CALL_OW 266
4727: PUSH
4728: LD_INT 0
4730: PUSH
4731: LD_INT 1
4733: PUSH
4734: EMPTY
4735: LIST
4736: LIST
4737: IN
4738: NOT
4739: OR
4740: IFFALSE 4744
// exit ;
4742: GO 4877
// AddComTransport ( engineer , depot , mat_oil ) ;
4744: LD_VAR 0 1
4748: PPUSH
4749: LD_VAR 0 2
4753: PPUSH
4754: LD_INT 2
4756: PPUSH
4757: CALL_OW 211
// repeat wait ( 0 0$01 ) ;
4761: LD_INT 35
4763: PPUSH
4764: CALL_OW 67
// until Carry ( engineer ) ;
4768: LD_VAR 0 1
4772: PPUSH
4773: CALL_OW 281
4777: IFFALSE 4761
// RemoveTasks ( engineer ) ;
4779: LD_VAR 0 1
4783: PPUSH
4784: CALL_OW 493
// SetTaskList ( engineer , [ [ O , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
4788: LD_VAR 0 1
4792: PPUSH
4793: LD_STRING O
4795: PUSH
4796: LD_INT 0
4798: PUSH
4799: LD_INT 0
4801: PUSH
4802: LD_VAR 0 3
4806: PUSH
4807: LD_INT 0
4809: PUSH
4810: LD_INT 0
4812: PUSH
4813: LD_INT 0
4815: PUSH
4816: EMPTY
4817: LIST
4818: LIST
4819: LIST
4820: LIST
4821: LIST
4822: LIST
4823: LIST
4824: PUSH
4825: EMPTY
4826: LIST
4827: PPUSH
4828: CALL_OW 446
// repeat wait ( 0 0$01 ) ;
4832: LD_INT 35
4834: PPUSH
4835: CALL_OW 67
// until not Carry ( engineer ) ;
4839: LD_VAR 0 1
4843: PPUSH
4844: CALL_OW 281
4848: NOT
4849: IFFALSE 4832
// SetFuel ( vehicle , 100 ) ;
4851: LD_VAR 0 3
4855: PPUSH
4856: LD_INT 100
4858: PPUSH
4859: CALL_OW 240
// AddComEnterUnit ( engineer , depot ) ;
4863: LD_VAR 0 1
4867: PPUSH
4868: LD_VAR 0 2
4872: PPUSH
4873: CALL_OW 180
// end ;
4877: LD_VAR 0 4
4881: RET
// export function ResAllTechs ( side , lab , nation ) ; var i , tech , cout , ru_tech_list ; begin
4882: LD_INT 0
4884: PPUSH
4885: PPUSH
4886: PPUSH
4887: PPUSH
4888: PPUSH
// ru_tech_list := [ 48 , 49 , 50 , 20 , 1 , 51 , 52 , 69 , 39 , 34 , 40 , 53 , 71 , 57 , 58 , 44 , 32 , 27 , 23 , 33 , 59 , 54 , 55 , 56 , 63 , 64 , 65 , 30 , 31 , 21 , 22 , 25 ] ;
4889: LD_ADDR_VAR 0 8
4893: PUSH
4894: LD_INT 48
4896: PUSH
4897: LD_INT 49
4899: PUSH
4900: LD_INT 50
4902: PUSH
4903: LD_INT 20
4905: PUSH
4906: LD_INT 1
4908: PUSH
4909: LD_INT 51
4911: PUSH
4912: LD_INT 52
4914: PUSH
4915: LD_INT 69
4917: PUSH
4918: LD_INT 39
4920: PUSH
4921: LD_INT 34
4923: PUSH
4924: LD_INT 40
4926: PUSH
4927: LD_INT 53
4929: PUSH
4930: LD_INT 71
4932: PUSH
4933: LD_INT 57
4935: PUSH
4936: LD_INT 58
4938: PUSH
4939: LD_INT 44
4941: PUSH
4942: LD_INT 32
4944: PUSH
4945: LD_INT 27
4947: PUSH
4948: LD_INT 23
4950: PUSH
4951: LD_INT 33
4953: PUSH
4954: LD_INT 59
4956: PUSH
4957: LD_INT 54
4959: PUSH
4960: LD_INT 55
4962: PUSH
4963: LD_INT 56
4965: PUSH
4966: LD_INT 63
4968: PUSH
4969: LD_INT 64
4971: PUSH
4972: LD_INT 65
4974: PUSH
4975: LD_INT 30
4977: PUSH
4978: LD_INT 31
4980: PUSH
4981: LD_INT 21
4983: PUSH
4984: LD_INT 22
4986: PUSH
4987: LD_INT 25
4989: PUSH
4990: EMPTY
4991: LIST
4992: LIST
4993: LIST
4994: LIST
4995: LIST
4996: LIST
4997: LIST
4998: LIST
4999: LIST
5000: LIST
5001: LIST
5002: LIST
5003: LIST
5004: LIST
5005: LIST
5006: LIST
5007: LIST
5008: LIST
5009: LIST
5010: LIST
5011: LIST
5012: LIST
5013: LIST
5014: LIST
5015: LIST
5016: LIST
5017: LIST
5018: LIST
5019: LIST
5020: LIST
5021: LIST
5022: LIST
5023: ST_TO_ADDR
// for i = 1 to ru_tech_list do
5024: LD_ADDR_VAR 0 5
5028: PUSH
5029: DOUBLE
5030: LD_INT 1
5032: DEC
5033: ST_TO_ADDR
5034: LD_VAR 0 8
5038: PUSH
5039: FOR_TO
5040: IFFALSE 5116
// if GetTech ( ru_tech_list [ i ] , side ) = state_enabled and TechNationAvailable ( ru_tech_list [ i ] , nation ) = true then
5042: LD_VAR 0 8
5046: PUSH
5047: LD_VAR 0 5
5051: ARRAY
5052: PPUSH
5053: LD_VAR 0 1
5057: PPUSH
5058: CALL_OW 321
5062: PUSH
5063: LD_INT 1
5065: EQUAL
5066: PUSH
5067: LD_VAR 0 8
5071: PUSH
5072: LD_VAR 0 5
5076: ARRAY
5077: PPUSH
5078: LD_VAR 0 3
5082: PPUSH
5083: CALL_OW 482
5087: PUSH
5088: LD_INT 1
5090: EQUAL
5091: AND
5092: IFFALSE 5114
// AddComResearch ( lab , ru_tech_list [ i ] ) ;
5094: LD_VAR 0 2
5098: PPUSH
5099: LD_VAR 0 8
5103: PUSH
5104: LD_VAR 0 5
5108: ARRAY
5109: PPUSH
5110: CALL_OW 184
5114: GO 5039
5116: POP
5117: POP
// end ;
5118: LD_VAR 0 4
5122: RET
// export function PrepareSolBun ( skill , b ) ; var un , dir ; begin
5123: LD_INT 0
5125: PPUSH
5126: PPUSH
5127: PPUSH
// uc_side := GetSide ( b ) ;
5128: LD_ADDR_OWVAR 20
5132: PUSH
5133: LD_VAR 0 2
5137: PPUSH
5138: CALL_OW 255
5142: ST_TO_ADDR
// uc_nation := GetNation ( b ) ;
5143: LD_ADDR_OWVAR 21
5147: PUSH
5148: LD_VAR 0 2
5152: PPUSH
5153: CALL_OW 248
5157: ST_TO_ADDR
// PrepareHuman ( false , 1 , skill ) ;
5158: LD_INT 0
5160: PPUSH
5161: LD_INT 1
5163: PPUSH
5164: LD_VAR 0 1
5168: PPUSH
5169: CALL_OW 380
// un = CreateHuman ;
5173: LD_ADDR_VAR 0 4
5177: PUSH
5178: CALL_OW 44
5182: ST_TO_ADDR
// dir := GetDir ( b ) - 3 ;
5183: LD_ADDR_VAR 0 5
5187: PUSH
5188: LD_VAR 0 2
5192: PPUSH
5193: CALL_OW 254
5197: PUSH
5198: LD_INT 3
5200: MINUS
5201: ST_TO_ADDR
// if dir < 0 then
5202: LD_VAR 0 5
5206: PUSH
5207: LD_INT 0
5209: LESS
5210: IFFALSE 5226
// dir := 6 + dir ;
5212: LD_ADDR_VAR 0 5
5216: PUSH
5217: LD_INT 6
5219: PUSH
5220: LD_VAR 0 5
5224: PLUS
5225: ST_TO_ADDR
// SetDir ( un , dir ) ;
5226: LD_VAR 0 4
5230: PPUSH
5231: LD_VAR 0 5
5235: PPUSH
5236: CALL_OW 233
// PlaceHumanInUnit ( un , b ) ;
5240: LD_VAR 0 4
5244: PPUSH
5245: LD_VAR 0 2
5249: PPUSH
5250: CALL_OW 52
// result = un ;
5254: LD_ADDR_VAR 0 3
5258: PUSH
5259: LD_VAR 0 4
5263: ST_TO_ADDR
// end ;
5264: LD_VAR 0 3
5268: RET
// export function PlaceSolBun ( un , b ) ; var dir ; begin
5269: LD_INT 0
5271: PPUSH
5272: PPUSH
// dir := GetDir ( b ) - 3 ;
5273: LD_ADDR_VAR 0 4
5277: PUSH
5278: LD_VAR 0 2
5282: PPUSH
5283: CALL_OW 254
5287: PUSH
5288: LD_INT 3
5290: MINUS
5291: ST_TO_ADDR
// if dir < 0 then
5292: LD_VAR 0 4
5296: PUSH
5297: LD_INT 0
5299: LESS
5300: IFFALSE 5316
// dir := 6 + dir ;
5302: LD_ADDR_VAR 0 4
5306: PUSH
5307: LD_INT 6
5309: PUSH
5310: LD_VAR 0 4
5314: PLUS
5315: ST_TO_ADDR
// SetDir ( un , dir ) ;
5316: LD_VAR 0 1
5320: PPUSH
5321: LD_VAR 0 4
5325: PPUSH
5326: CALL_OW 233
// PlaceHumanInUnit ( un , b ) ;
5330: LD_VAR 0 1
5334: PPUSH
5335: LD_VAR 0 2
5339: PPUSH
5340: CALL_OW 52
// result = un ;
5344: LD_ADDR_VAR 0 3
5348: PUSH
5349: LD_VAR 0 1
5353: ST_TO_ADDR
// end ;
5354: LD_VAR 0 3
5358: RET
// export function SaveVehicles ( vehicles , ident ) ; var i , tmp ; begin
5359: LD_INT 0
5361: PPUSH
5362: PPUSH
5363: PPUSH
// tmp = [ ] ;
5364: LD_ADDR_VAR 0 5
5368: PUSH
5369: EMPTY
5370: ST_TO_ADDR
// if not vehicles then
5371: LD_VAR 0 1
5375: NOT
5376: IFFALSE 5380
// exit ;
5378: GO 5497
// for i in vehicles do
5380: LD_ADDR_VAR 0 4
5384: PUSH
5385: LD_VAR 0 1
5389: PUSH
5390: FOR_IN
5391: IFFALSE 5481
// tmp := Insert ( tmp , 1 , [ GetChassis ( i ) , GetEngine ( i ) , GetControl ( i ) , GetWeapon ( i ) , GetFuel ( i ) , GetLives ( i ) ] ) ;
5393: LD_ADDR_VAR 0 5
5397: PUSH
5398: LD_VAR 0 5
5402: PPUSH
5403: LD_INT 1
5405: PPUSH
5406: LD_VAR 0 4
5410: PPUSH
5411: CALL_OW 265
5415: PUSH
5416: LD_VAR 0 4
5420: PPUSH
5421: CALL_OW 262
5425: PUSH
5426: LD_VAR 0 4
5430: PPUSH
5431: CALL_OW 263
5435: PUSH
5436: LD_VAR 0 4
5440: PPUSH
5441: CALL_OW 264
5445: PUSH
5446: LD_VAR 0 4
5450: PPUSH
5451: CALL_OW 261
5455: PUSH
5456: LD_VAR 0 4
5460: PPUSH
5461: CALL_OW 256
5465: PUSH
5466: EMPTY
5467: LIST
5468: LIST
5469: LIST
5470: LIST
5471: LIST
5472: LIST
5473: PPUSH
5474: CALL_OW 2
5478: ST_TO_ADDR
5479: GO 5390
5481: POP
5482: POP
// SaveVariable ( tmp , ident ) ;
5483: LD_VAR 0 5
5487: PPUSH
5488: LD_VAR 0 2
5492: PPUSH
5493: CALL_OW 39
// end ;
5497: LD_VAR 0 3
5501: RET
// export function SaveBase ( buildings , ident ) ; var i , buildingsToSave ; begin
5502: LD_INT 0
5504: PPUSH
5505: PPUSH
5506: PPUSH
// buildingsToSave = [ ] ;
5507: LD_ADDR_VAR 0 5
5511: PUSH
5512: EMPTY
5513: ST_TO_ADDR
// if not buildings then
5514: LD_VAR 0 1
5518: NOT
5519: IFFALSE 5523
// exit ;
5521: GO 6098
// for i in buildings do
5523: LD_ADDR_VAR 0 4
5527: PUSH
5528: LD_VAR 0 1
5532: PUSH
5533: FOR_IN
5534: IFFALSE 6082
// begin if GetBType ( i ) in [ b_lab , b_lab_half , b_lab_full ] then
5536: LD_VAR 0 4
5540: PPUSH
5541: CALL_OW 266
5545: PUSH
5546: LD_INT 6
5548: PUSH
5549: LD_INT 7
5551: PUSH
5552: LD_INT 8
5554: PUSH
5555: EMPTY
5556: LIST
5557: LIST
5558: LIST
5559: IN
5560: IFFALSE 5685
// buildingsToSave = buildingsToSave ^ [ [ GetBType ( i ) , GetX ( i ) , GetY ( i ) , GetDir ( i ) , GetBLevel ( i ) , GetNation ( i ) , GetLives ( i ) , GetLabKind ( i , 1 ) , GetLabKind ( i , 2 ) ] ] else
5562: LD_ADDR_VAR 0 5
5566: PUSH
5567: LD_VAR 0 5
5571: PUSH
5572: LD_VAR 0 4
5576: PPUSH
5577: CALL_OW 266
5581: PUSH
5582: LD_VAR 0 4
5586: PPUSH
5587: CALL_OW 250
5591: PUSH
5592: LD_VAR 0 4
5596: PPUSH
5597: CALL_OW 251
5601: PUSH
5602: LD_VAR 0 4
5606: PPUSH
5607: CALL_OW 254
5611: PUSH
5612: LD_VAR 0 4
5616: PPUSH
5617: CALL_OW 267
5621: PUSH
5622: LD_VAR 0 4
5626: PPUSH
5627: CALL_OW 248
5631: PUSH
5632: LD_VAR 0 4
5636: PPUSH
5637: CALL_OW 256
5641: PUSH
5642: LD_VAR 0 4
5646: PPUSH
5647: LD_INT 1
5649: PPUSH
5650: CALL_OW 268
5654: PUSH
5655: LD_VAR 0 4
5659: PPUSH
5660: LD_INT 2
5662: PPUSH
5663: CALL_OW 268
5667: PUSH
5668: EMPTY
5669: LIST
5670: LIST
5671: LIST
5672: LIST
5673: LIST
5674: LIST
5675: LIST
5676: LIST
5677: LIST
5678: PUSH
5679: EMPTY
5680: LIST
5681: ADD
5682: ST_TO_ADDR
5683: GO 6080
// if GetBType ( i ) in [ b_bunker , b_turret ] then
5685: LD_VAR 0 4
5689: PPUSH
5690: CALL_OW 266
5694: PUSH
5695: LD_INT 32
5697: PUSH
5698: LD_INT 33
5700: PUSH
5701: EMPTY
5702: LIST
5703: LIST
5704: IN
5705: IFFALSE 5813
// buildingsToSave = buildingsToSave ^ [ [ GetBType ( i ) , GetX ( i ) , GetY ( i ) , GetDir ( i ) , GetBLevel ( i ) , GetNation ( i ) , GetLives ( i ) , GetBWeapon ( i ) ] ] else
5707: LD_ADDR_VAR 0 5
5711: PUSH
5712: LD_VAR 0 5
5716: PUSH
5717: LD_VAR 0 4
5721: PPUSH
5722: CALL_OW 266
5726: PUSH
5727: LD_VAR 0 4
5731: PPUSH
5732: CALL_OW 250
5736: PUSH
5737: LD_VAR 0 4
5741: PPUSH
5742: CALL_OW 251
5746: PUSH
5747: LD_VAR 0 4
5751: PPUSH
5752: CALL_OW 254
5756: PUSH
5757: LD_VAR 0 4
5761: PPUSH
5762: CALL_OW 267
5766: PUSH
5767: LD_VAR 0 4
5771: PPUSH
5772: CALL_OW 248
5776: PUSH
5777: LD_VAR 0 4
5781: PPUSH
5782: CALL_OW 256
5786: PUSH
5787: LD_VAR 0 4
5791: PPUSH
5792: CALL_OW 269
5796: PUSH
5797: EMPTY
5798: LIST
5799: LIST
5800: LIST
5801: LIST
5802: LIST
5803: LIST
5804: LIST
5805: LIST
5806: PUSH
5807: EMPTY
5808: LIST
5809: ADD
5810: ST_TO_ADDR
5811: GO 6080
// if GetBType ( i ) in [ b_depot , b_warehouse ] then
5813: LD_VAR 0 4
5817: PPUSH
5818: CALL_OW 266
5822: PUSH
5823: LD_INT 0
5825: PUSH
5826: LD_INT 1
5828: PUSH
5829: EMPTY
5830: LIST
5831: LIST
5832: IN
5833: IFFALSE 5987
// buildingsToSave = buildingsToSave ^ [ [ GetBType ( i ) , GetX ( i ) , GetY ( i ) , GetDir ( i ) , GetBLevel ( i ) , GetNation ( i ) , GetLives ( i ) , GetResourceType ( GetBase ( i ) , mat_cans ) , GetResourceType ( GetBase ( i ) , mat_oil ) , GetResourceType ( GetBase ( i ) , mat_siberit ) ] ] else
5835: LD_ADDR_VAR 0 5
5839: PUSH
5840: LD_VAR 0 5
5844: PUSH
5845: LD_VAR 0 4
5849: PPUSH
5850: CALL_OW 266
5854: PUSH
5855: LD_VAR 0 4
5859: PPUSH
5860: CALL_OW 250
5864: PUSH
5865: LD_VAR 0 4
5869: PPUSH
5870: CALL_OW 251
5874: PUSH
5875: LD_VAR 0 4
5879: PPUSH
5880: CALL_OW 254
5884: PUSH
5885: LD_VAR 0 4
5889: PPUSH
5890: CALL_OW 267
5894: PUSH
5895: LD_VAR 0 4
5899: PPUSH
5900: CALL_OW 248
5904: PUSH
5905: LD_VAR 0 4
5909: PPUSH
5910: CALL_OW 256
5914: PUSH
5915: LD_VAR 0 4
5919: PPUSH
5920: CALL_OW 274
5924: PPUSH
5925: LD_INT 1
5927: PPUSH
5928: CALL_OW 275
5932: PUSH
5933: LD_VAR 0 4
5937: PPUSH
5938: CALL_OW 274
5942: PPUSH
5943: LD_INT 2
5945: PPUSH
5946: CALL_OW 275
5950: PUSH
5951: LD_VAR 0 4
5955: PPUSH
5956: CALL_OW 274
5960: PPUSH
5961: LD_INT 3
5963: PPUSH
5964: CALL_OW 275
5968: PUSH
5969: EMPTY
5970: LIST
5971: LIST
5972: LIST
5973: LIST
5974: LIST
5975: LIST
5976: LIST
5977: LIST
5978: LIST
5979: LIST
5980: PUSH
5981: EMPTY
5982: LIST
5983: ADD
5984: ST_TO_ADDR
5985: GO 6080
// buildingsToSave = buildingsToSave ^ [ [ GetBType ( i ) , GetX ( i ) , GetY ( i ) , GetDir ( i ) , GetBLevel ( i ) , GetNation ( i ) , GetLives ( i ) ] ] ;
5987: LD_ADDR_VAR 0 5
5991: PUSH
5992: LD_VAR 0 5
5996: PUSH
5997: LD_VAR 0 4
6001: PPUSH
6002: CALL_OW 266
6006: PUSH
6007: LD_VAR 0 4
6011: PPUSH
6012: CALL_OW 250
6016: PUSH
6017: LD_VAR 0 4
6021: PPUSH
6022: CALL_OW 251
6026: PUSH
6027: LD_VAR 0 4
6031: PPUSH
6032: CALL_OW 254
6036: PUSH
6037: LD_VAR 0 4
6041: PPUSH
6042: CALL_OW 267
6046: PUSH
6047: LD_VAR 0 4
6051: PPUSH
6052: CALL_OW 248
6056: PUSH
6057: LD_VAR 0 4
6061: PPUSH
6062: CALL_OW 256
6066: PUSH
6067: EMPTY
6068: LIST
6069: LIST
6070: LIST
6071: LIST
6072: LIST
6073: LIST
6074: LIST
6075: PUSH
6076: EMPTY
6077: LIST
6078: ADD
6079: ST_TO_ADDR
// end ;
6080: GO 5533
6082: POP
6083: POP
// SaveVariable ( buildingsToSave , ident ) ;
6084: LD_VAR 0 5
6088: PPUSH
6089: LD_VAR 0 2
6093: PPUSH
6094: CALL_OW 39
// end ;
6098: LD_VAR 0 3
6102: RET
// export function CreateBelkovTeam ; var i , unit , restRandSolds , tmp ; begin
6103: LD_INT 0
6105: PPUSH
6106: PPUSH
6107: PPUSH
6108: PPUSH
6109: PPUSH
// belkovTeam = [ ] ;
6110: LD_ADDR_EXP 73
6114: PUSH
6115: EMPTY
6116: ST_TO_ADDR
// if belkovReturn then
6117: LD_EXP 6
6121: IFFALSE 6139
// belkovTeam = belkovTeam ^ Belkov ;
6123: LD_ADDR_EXP 73
6127: PUSH
6128: LD_EXP 73
6132: PUSH
6133: LD_EXP 64
6137: ADD
6138: ST_TO_ADDR
// belkovTeam = belkovTeam ^ Belkov2 ;
6139: LD_ADDR_EXP 73
6143: PUSH
6144: LD_EXP 73
6148: PUSH
6149: LD_EXP 68
6153: ADD
6154: ST_TO_ADDR
// for unit in other_survivors do
6155: LD_ADDR_VAR 0 3
6159: PUSH
6160: LD_EXP 66
6164: PUSH
6165: FOR_IN
6166: IFFALSE 6207
// if IsOK ( unit ) and belkovTeam < 5 then
6168: LD_VAR 0 3
6172: PPUSH
6173: CALL_OW 302
6177: PUSH
6178: LD_EXP 73
6182: PUSH
6183: LD_INT 5
6185: LESS
6186: AND
6187: IFFALSE 6205
// belkovTeam = belkovTeam ^ unit ;
6189: LD_ADDR_EXP 73
6193: PUSH
6194: LD_EXP 73
6198: PUSH
6199: LD_VAR 0 3
6203: ADD
6204: ST_TO_ADDR
6205: GO 6165
6207: POP
6208: POP
// if belkovTeam < 5 then
6209: LD_EXP 73
6213: PUSH
6214: LD_INT 5
6216: LESS
6217: IFFALSE 6343
// begin restRandSolds = 5 - belkovTeam ;
6219: LD_ADDR_VAR 0 4
6223: PUSH
6224: LD_INT 5
6226: PUSH
6227: LD_EXP 73
6231: MINUS
6232: ST_TO_ADDR
// for i := 1 to restRandSolds do
6233: LD_ADDR_VAR 0 2
6237: PUSH
6238: DOUBLE
6239: LD_INT 1
6241: DEC
6242: ST_TO_ADDR
6243: LD_VAR 0 4
6247: PUSH
6248: FOR_TO
6249: IFFALSE 6341
// for unit in UnitFilter ( otherKirovUnits , [ [ f_class , class_soldier ] ] ) diff Kurin do
6251: LD_ADDR_VAR 0 3
6255: PUSH
6256: LD_EXP 69
6260: PPUSH
6261: LD_INT 25
6263: PUSH
6264: LD_INT 1
6266: PUSH
6267: EMPTY
6268: LIST
6269: LIST
6270: PUSH
6271: EMPTY
6272: LIST
6273: PPUSH
6274: CALL_OW 72
6278: PUSH
6279: LD_EXP 67
6283: DIFF
6284: PUSH
6285: FOR_IN
6286: IFFALSE 6337
// if not unit in belkovTeam then
6288: LD_VAR 0 3
6292: PUSH
6293: LD_EXP 73
6297: IN
6298: NOT
6299: IFFALSE 6335
// begin belkovTeam = belkovTeam ^ unit ;
6301: LD_ADDR_EXP 73
6305: PUSH
6306: LD_EXP 73
6310: PUSH
6311: LD_VAR 0 3
6315: ADD
6316: ST_TO_ADDR
// otherKirovUnits = otherKirovUnits diff unit ;
6317: LD_ADDR_EXP 69
6321: PUSH
6322: LD_EXP 69
6326: PUSH
6327: LD_VAR 0 3
6331: DIFF
6332: ST_TO_ADDR
// break ;
6333: GO 6337
// end ;
6335: GO 6285
6337: POP
6338: POP
6339: GO 6248
6341: POP
6342: POP
// end ; tmp = belkovTeam diff Belkov ;
6343: LD_ADDR_VAR 0 5
6347: PUSH
6348: LD_EXP 73
6352: PUSH
6353: LD_EXP 64
6357: DIFF
6358: ST_TO_ADDR
// if tmp < 4 then
6359: LD_VAR 0 5
6363: PUSH
6364: LD_INT 4
6366: LESS
6367: IFFALSE 6451
// begin for i := 1 to 4 - tmp do
6369: LD_ADDR_VAR 0 2
6373: PUSH
6374: DOUBLE
6375: LD_INT 1
6377: DEC
6378: ST_TO_ADDR
6379: LD_INT 4
6381: PUSH
6382: LD_VAR 0 5
6386: MINUS
6387: PUSH
6388: FOR_TO
6389: IFFALSE 6449
// begin PrepareSoldier ( false , rand ( 1 , 2 ) ) ;
6391: LD_INT 0
6393: PPUSH
6394: LD_INT 1
6396: PPUSH
6397: LD_INT 2
6399: PPUSH
6400: CALL_OW 12
6404: PPUSH
6405: CALL_OW 381
// unit = CreateHuman ;
6409: LD_ADDR_VAR 0 3
6413: PUSH
6414: CALL_OW 44
6418: ST_TO_ADDR
// belkovTeam = belkovTeam ^ unit ;
6419: LD_ADDR_EXP 73
6423: PUSH
6424: LD_EXP 73
6428: PUSH
6429: LD_VAR 0 3
6433: ADD
6434: ST_TO_ADDR
// PlaceHumanInUnit ( unit , ru2_arm2 ) ;
6435: LD_VAR 0 3
6439: PPUSH
6440: LD_INT 209
6442: PPUSH
6443: CALL_OW 52
// end ;
6447: GO 6388
6449: POP
6450: POP
// end ; if TestCharacters ( 01_Kirilenkova ) then
6451: LD_STRING 01_Kirilenkova
6453: PPUSH
6454: CALL_OW 28
6458: IFFALSE 6478
// belkovTeam = belkovTeam ^ Kirilenkova else
6460: LD_ADDR_EXP 73
6464: PUSH
6465: LD_EXP 73
6469: PUSH
6470: LD_EXP 65
6474: ADD
6475: ST_TO_ADDR
6476: GO 6554
// begin belkovTeam = belkovTeam ^ UnitFilter ( otherKirovUnits , [ [ f_class , class_scientistic ] ] ) [ 1 ] ;
6478: LD_ADDR_EXP 73
6482: PUSH
6483: LD_EXP 73
6487: PUSH
6488: LD_EXP 69
6492: PPUSH
6493: LD_INT 25
6495: PUSH
6496: LD_INT 4
6498: PUSH
6499: EMPTY
6500: LIST
6501: LIST
6502: PUSH
6503: EMPTY
6504: LIST
6505: PPUSH
6506: CALL_OW 72
6510: PUSH
6511: LD_INT 1
6513: ARRAY
6514: ADD
6515: ST_TO_ADDR
// otherKirovUnits = otherKirovUnits diff UnitFilter ( otherKirovUnits , [ [ f_class , class_scientistic ] ] ) [ 1 ] ;
6516: LD_ADDR_EXP 69
6520: PUSH
6521: LD_EXP 69
6525: PUSH
6526: LD_EXP 69
6530: PPUSH
6531: LD_INT 25
6533: PUSH
6534: LD_INT 4
6536: PUSH
6537: EMPTY
6538: LIST
6539: LIST
6540: PUSH
6541: EMPTY
6542: LIST
6543: PPUSH
6544: CALL_OW 72
6548: PUSH
6549: LD_INT 1
6551: ARRAY
6552: DIFF
6553: ST_TO_ADDR
// end ; end ;
6554: LD_VAR 0 1
6558: RET
// export function PlatonovSendSupport ; var soldsOk ; begin
6559: LD_INT 0
6561: PPUSH
6562: PPUSH
// if not Kuklajs or not IsOK ( Kuklajs ) then
6563: LD_EXP 78
6567: NOT
6568: PUSH
6569: LD_EXP 78
6573: PPUSH
6574: CALL_OW 302
6578: NOT
6579: OR
6580: IFFALSE 6683
// begin soldsOk = UnitFilter ( platSoldiers , [ f_ok ] ) diff Benko ;
6582: LD_ADDR_VAR 0 2
6586: PUSH
6587: LD_EXP 77
6591: PPUSH
6592: LD_INT 50
6594: PUSH
6595: EMPTY
6596: LIST
6597: PPUSH
6598: CALL_OW 72
6602: PUSH
6603: LD_EXP 79
6607: DIFF
6608: ST_TO_ADDR
// if soldsOK then
6609: LD_VAR 0 2
6613: IFFALSE 6683
// begin ComExitBuilding ( soldsOK [ 1 ] ) ;
6615: LD_VAR 0 2
6619: PUSH
6620: LD_INT 1
6622: ARRAY
6623: PPUSH
6624: CALL_OW 122
// AddComMoveXY ( soldsOK [ 1 ] , 112 , 96 ) ;
6628: LD_VAR 0 2
6632: PUSH
6633: LD_INT 1
6635: ARRAY
6636: PPUSH
6637: LD_INT 112
6639: PPUSH
6640: LD_INT 96
6642: PPUSH
6643: CALL_OW 171
// SetSide ( soldsOK [ 1 ] , 3 ) ;
6647: LD_VAR 0 2
6651: PUSH
6652: LD_INT 1
6654: ARRAY
6655: PPUSH
6656: LD_INT 3
6658: PPUSH
6659: CALL_OW 235
// platSoldiers = platSoldiers diff soldsOK [ 1 ] ;
6663: LD_ADDR_EXP 77
6667: PUSH
6668: LD_EXP 77
6672: PUSH
6673: LD_VAR 0 2
6677: PUSH
6678: LD_INT 1
6680: ARRAY
6681: DIFF
6682: ST_TO_ADDR
// end ; end ; if not Benko or not IsOK ( Benko ) then
6683: LD_EXP 79
6687: NOT
6688: PUSH
6689: LD_EXP 79
6693: PPUSH
6694: CALL_OW 302
6698: NOT
6699: OR
6700: IFFALSE 6803
// begin soldsOk = UnitFilter ( platSoldiers , [ f_ok ] ) diff Kuklajs ;
6702: LD_ADDR_VAR 0 2
6706: PUSH
6707: LD_EXP 77
6711: PPUSH
6712: LD_INT 50
6714: PUSH
6715: EMPTY
6716: LIST
6717: PPUSH
6718: CALL_OW 72
6722: PUSH
6723: LD_EXP 78
6727: DIFF
6728: ST_TO_ADDR
// if soldsOK then
6729: LD_VAR 0 2
6733: IFFALSE 6803
// begin ComExitBuilding ( soldsOK [ 1 ] ) ;
6735: LD_VAR 0 2
6739: PUSH
6740: LD_INT 1
6742: ARRAY
6743: PPUSH
6744: CALL_OW 122
// AddComMoveXY ( soldsOK [ 1 ] , 112 , 96 ) ;
6748: LD_VAR 0 2
6752: PUSH
6753: LD_INT 1
6755: ARRAY
6756: PPUSH
6757: LD_INT 112
6759: PPUSH
6760: LD_INT 96
6762: PPUSH
6763: CALL_OW 171
// SetSide ( soldsOK [ 1 ] , 3 ) ;
6767: LD_VAR 0 2
6771: PUSH
6772: LD_INT 1
6774: ARRAY
6775: PPUSH
6776: LD_INT 3
6778: PPUSH
6779: CALL_OW 235
// platSoldiers = platSoldiers diff soldsOK [ 1 ] ;
6783: LD_ADDR_EXP 77
6787: PUSH
6788: LD_EXP 77
6792: PUSH
6793: LD_VAR 0 2
6797: PUSH
6798: LD_INT 1
6800: ARRAY
6801: DIFF
6802: ST_TO_ADDR
// end ; end ; ComExitBuilding ( [ Kuklajs , Benko ] ) ;
6803: LD_EXP 78
6807: PUSH
6808: LD_EXP 79
6812: PUSH
6813: EMPTY
6814: LIST
6815: LIST
6816: PPUSH
6817: CALL_OW 122
// AddComMoveXY ( [ Kuklajs , Benko ] , 112 , 96 ) ;
6821: LD_EXP 78
6825: PUSH
6826: LD_EXP 79
6830: PUSH
6831: EMPTY
6832: LIST
6833: LIST
6834: PPUSH
6835: LD_INT 112
6837: PPUSH
6838: LD_INT 96
6840: PPUSH
6841: CALL_OW 171
// SetSide ( [ Kuklajs , Benko ] , 3 ) ;
6845: LD_EXP 78
6849: PUSH
6850: LD_EXP 79
6854: PUSH
6855: EMPTY
6856: LIST
6857: LIST
6858: PPUSH
6859: LD_INT 3
6861: PPUSH
6862: CALL_OW 235
// end ; end_of_file
6866: LD_VAR 0 1
6870: RET
// export function MissionIntro ; var yourSolds , nearUnit ; var i ; begin
6871: LD_INT 0
6873: PPUSH
6874: PPUSH
6875: PPUSH
6876: PPUSH
// CenterNowOnUnits ( Burlak ) ;
6877: LD_EXP 62
6881: PPUSH
6882: CALL_OW 87
// ComMoveXY ( Burlak , 163 , 108 ) ;
6886: LD_EXP 62
6890: PPUSH
6891: LD_INT 163
6893: PPUSH
6894: LD_INT 108
6896: PPUSH
6897: CALL_OW 111
// AddComTurnUnit ( Burlak , Kurin ) ;
6901: LD_EXP 62
6905: PPUSH
6906: LD_EXP 67
6910: PPUSH
6911: CALL_OW 179
// yourSolds = FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) diff Burlak ;
6915: LD_ADDR_VAR 0 2
6919: PUSH
6920: LD_INT 22
6922: PUSH
6923: LD_INT 3
6925: PUSH
6926: EMPTY
6927: LIST
6928: LIST
6929: PUSH
6930: LD_INT 21
6932: PUSH
6933: LD_INT 1
6935: PUSH
6936: EMPTY
6937: LIST
6938: LIST
6939: PUSH
6940: EMPTY
6941: LIST
6942: LIST
6943: PPUSH
6944: CALL_OW 69
6948: PUSH
6949: LD_EXP 62
6953: DIFF
6954: ST_TO_ADDR
// for i := 1 to meetWithKurinPositions do
6955: LD_ADDR_VAR 0 4
6959: PUSH
6960: DOUBLE
6961: LD_INT 1
6963: DEC
6964: ST_TO_ADDR
6965: LD_EXP 52
6969: PUSH
6970: FOR_TO
6971: IFFALSE 7089
// begin nearUnit = NearestUnitToXY ( yourSolds , meetWithKurinPositions [ i ] [ 1 ] , meetWithKurinPositions [ i ] [ 2 ] ) ;
6973: LD_ADDR_VAR 0 3
6977: PUSH
6978: LD_VAR 0 2
6982: PPUSH
6983: LD_EXP 52
6987: PUSH
6988: LD_VAR 0 4
6992: ARRAY
6993: PUSH
6994: LD_INT 1
6996: ARRAY
6997: PPUSH
6998: LD_EXP 52
7002: PUSH
7003: LD_VAR 0 4
7007: ARRAY
7008: PUSH
7009: LD_INT 2
7011: ARRAY
7012: PPUSH
7013: CALL_OW 73
7017: ST_TO_ADDR
// ComMoveXY ( nearUnit , meetWithKurinPositions [ i ] [ 1 ] , meetWithKurinPositions [ i ] [ 2 ] ) ;
7018: LD_VAR 0 3
7022: PPUSH
7023: LD_EXP 52
7027: PUSH
7028: LD_VAR 0 4
7032: ARRAY
7033: PUSH
7034: LD_INT 1
7036: ARRAY
7037: PPUSH
7038: LD_EXP 52
7042: PUSH
7043: LD_VAR 0 4
7047: ARRAY
7048: PUSH
7049: LD_INT 2
7051: ARRAY
7052: PPUSH
7053: CALL_OW 111
// AddComTurnUnit ( nearUnit , Kurin ) ;
7057: LD_VAR 0 3
7061: PPUSH
7062: LD_EXP 67
7066: PPUSH
7067: CALL_OW 179
// yourSolds = yourSolds diff nearUnit ;
7071: LD_ADDR_VAR 0 2
7075: PUSH
7076: LD_VAR 0 2
7080: PUSH
7081: LD_VAR 0 3
7085: DIFF
7086: ST_TO_ADDR
// end ;
7087: GO 6970
7089: POP
7090: POP
// repeat CenterNowOnUnits ( Burlak ) ;
7091: LD_EXP 62
7095: PPUSH
7096: CALL_OW 87
// wait ( 0 0$1 ) ;
7100: LD_INT 35
7102: PPUSH
7103: CALL_OW 67
// until GetDistUnits ( Burlak , Kurin ) < 4 ;
7107: LD_EXP 62
7111: PPUSH
7112: LD_EXP 67
7116: PPUSH
7117: CALL_OW 296
7121: PUSH
7122: LD_INT 4
7124: LESS
7125: IFFALSE 7091
// CenterNowOnUnits ( [ Burlak , Kurin ] ) ;
7127: LD_EXP 62
7131: PUSH
7132: LD_EXP 67
7136: PUSH
7137: EMPTY
7138: LIST
7139: LIST
7140: PPUSH
7141: CALL_OW 87
// ComTurnUnit ( Kurin , Burlak ) ;
7145: LD_EXP 67
7149: PPUSH
7150: LD_EXP 62
7154: PPUSH
7155: CALL_OW 119
// Say ( Kurin , D1-Kur-1 ) ;
7159: LD_EXP 67
7163: PPUSH
7164: LD_STRING D1-Kur-1
7166: PPUSH
7167: CALL_OW 88
// Say ( Burlak , D1-Bur-1 ) ;
7171: LD_EXP 62
7175: PPUSH
7176: LD_STRING D1-Bur-1
7178: PPUSH
7179: CALL_OW 88
// Say ( Kurin , D1-Kur-2 ) ;
7183: LD_EXP 67
7187: PPUSH
7188: LD_STRING D1-Kur-2
7190: PPUSH
7191: CALL_OW 88
// Say ( Burlak , D1-Bur-2 ) ;
7195: LD_EXP 62
7199: PPUSH
7200: LD_STRING D1-Bur-2
7202: PPUSH
7203: CALL_OW 88
// Say ( Kurin , D1-Kur-3 ) ;
7207: LD_EXP 67
7211: PPUSH
7212: LD_STRING D1-Kur-3
7214: PPUSH
7215: CALL_OW 88
// if IsOK ( Gnyevko ) then
7219: LD_EXP 63
7223: PPUSH
7224: CALL_OW 302
7228: IFFALSE 7242
// Say ( Kurin , D1-Kur-3a ) ;
7230: LD_EXP 67
7234: PPUSH
7235: LD_STRING D1-Kur-3a
7237: PPUSH
7238: CALL_OW 88
// InGameOff ;
7242: CALL_OW 9
// SetSide ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) diff [ Burlak , Gnyevko ] , 6 ) ;
7246: LD_INT 22
7248: PUSH
7249: LD_INT 3
7251: PUSH
7252: EMPTY
7253: LIST
7254: LIST
7255: PUSH
7256: LD_INT 21
7258: PUSH
7259: LD_INT 1
7261: PUSH
7262: EMPTY
7263: LIST
7264: LIST
7265: PUSH
7266: EMPTY
7267: LIST
7268: LIST
7269: PPUSH
7270: CALL_OW 69
7274: PUSH
7275: LD_EXP 62
7279: PUSH
7280: LD_EXP 63
7284: PUSH
7285: EMPTY
7286: LIST
7287: LIST
7288: DIFF
7289: PPUSH
7290: LD_INT 6
7292: PPUSH
7293: CALL_OW 235
// SetSide ( Kovalyuk , 3 ) ;
7297: LD_EXP 70
7301: PPUSH
7302: LD_INT 3
7304: PPUSH
7305: CALL_OW 235
// ComFree ( FilterUnitsInArea ( KirovBaseArea , [ [ f_side , 6 ] , [ f_type , unit_human ] ] ) diff Kurin ) ;
7309: LD_INT 9
7311: PPUSH
7312: LD_INT 22
7314: PUSH
7315: LD_INT 6
7317: PUSH
7318: EMPTY
7319: LIST
7320: LIST
7321: PUSH
7322: LD_INT 21
7324: PUSH
7325: LD_INT 1
7327: PUSH
7328: EMPTY
7329: LIST
7330: LIST
7331: PUSH
7332: EMPTY
7333: LIST
7334: LIST
7335: PPUSH
7336: CALL_OW 70
7340: PUSH
7341: LD_EXP 67
7345: DIFF
7346: PPUSH
7347: CALL_OW 139
// ComEnterUnit ( other_survivors , ru2_arm1 ) ;
7351: LD_EXP 66
7355: PPUSH
7356: LD_INT 95
7358: PPUSH
7359: CALL_OW 120
// ComEnterUnit ( Belkov , ru2_arm1 ) ;
7363: LD_EXP 64
7367: PPUSH
7368: LD_INT 95
7370: PPUSH
7371: CALL_OW 120
// if IsPlaced ( Kirilenkova ) then
7375: LD_EXP 65
7379: PPUSH
7380: CALL_OW 305
7384: IFFALSE 7398
// ComEnterUnit ( Kirilenkova , ru_lab ) ;
7386: LD_EXP 65
7390: PPUSH
7391: LD_INT 83
7393: PPUSH
7394: CALL_OW 120
// if not TestCharacters ( 01_Gnyevko ) then
7398: LD_STRING 01_Gnyevko
7400: PPUSH
7401: CALL_OW 28
7405: NOT
7406: IFFALSE 7420
// SetSide ( randomMech , 3 ) ;
7408: LD_EXP 71
7412: PPUSH
7413: LD_INT 3
7415: PPUSH
7416: CALL_OW 235
// ChangeMissionObjectives ( M1 ) ;
7420: LD_STRING M1
7422: PPUSH
7423: CALL_OW 337
// HideArea ( 3 , AllMapArea ) ;
7427: LD_INT 3
7429: PPUSH
7430: LD_INT 6
7432: PPUSH
7433: CALL_OW 333
// ShowArea ( 3 , VisibleMapPartArea ) ;
7437: LD_INT 3
7439: PPUSH
7440: LD_INT 7
7442: PPUSH
7443: CALL_OW 334
// HideArea ( 6 , AllMapArea ) ;
7447: LD_INT 6
7449: PPUSH
7450: LD_INT 6
7452: PPUSH
7453: CALL_OW 333
// ShowArea ( 6 , VisibleMapPartArea ) ;
7457: LD_INT 6
7459: PPUSH
7460: LD_INT 7
7462: PPUSH
7463: CALL_OW 334
// SaveForQuickRestart ;
7467: CALL_OW 22
// ComEnterUnit ( other_survivors , ru2_arm1 ) ;
7471: LD_EXP 66
7475: PPUSH
7476: LD_INT 95
7478: PPUSH
7479: CALL_OW 120
// ComEnterUnit ( Belkov , ru2_arm1 ) ;
7483: LD_EXP 64
7487: PPUSH
7488: LD_INT 95
7490: PPUSH
7491: CALL_OW 120
// if IsPlaced ( Kirilenkova ) then
7495: LD_EXP 65
7499: PPUSH
7500: CALL_OW 305
7504: IFFALSE 7518
// ComEnterUnit ( Kirilenkova , ru_lab ) ;
7506: LD_EXP 65
7510: PPUSH
7511: LD_INT 83
7513: PPUSH
7514: CALL_OW 120
// end ;
7518: LD_VAR 0 1
7522: RET
// every 1 trigger not canExploreMap and FilterUnitsInArea ( NorthMoveLimitArea , [ [ f_side , 3 ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) > 0 do var unit ;
7523: LD_EXP 20
7527: NOT
7528: PUSH
7529: LD_INT 20
7531: PPUSH
7532: LD_INT 22
7534: PUSH
7535: LD_INT 3
7537: PUSH
7538: EMPTY
7539: LIST
7540: LIST
7541: PUSH
7542: LD_INT 2
7544: PUSH
7545: LD_INT 21
7547: PUSH
7548: LD_INT 1
7550: PUSH
7551: EMPTY
7552: LIST
7553: LIST
7554: PUSH
7555: LD_INT 21
7557: PUSH
7558: LD_INT 2
7560: PUSH
7561: EMPTY
7562: LIST
7563: LIST
7564: PUSH
7565: EMPTY
7566: LIST
7567: LIST
7568: LIST
7569: PUSH
7570: EMPTY
7571: LIST
7572: LIST
7573: PPUSH
7574: CALL_OW 70
7578: PUSH
7579: LD_INT 0
7581: GREATER
7582: AND
7583: IFFALSE 7957
7585: GO 7587
7587: DISABLE
7588: LD_INT 0
7590: PPUSH
// begin enable ;
7591: ENABLE
// for unit in FilterUnitsInArea ( NorthMoveLimitArea , [ [ f_side , 3 ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) do
7592: LD_ADDR_VAR 0 1
7596: PUSH
7597: LD_INT 20
7599: PPUSH
7600: LD_INT 22
7602: PUSH
7603: LD_INT 3
7605: PUSH
7606: EMPTY
7607: LIST
7608: LIST
7609: PUSH
7610: LD_INT 2
7612: PUSH
7613: LD_INT 21
7615: PUSH
7616: LD_INT 1
7618: PUSH
7619: EMPTY
7620: LIST
7621: LIST
7622: PUSH
7623: LD_INT 21
7625: PUSH
7626: LD_INT 2
7628: PUSH
7629: EMPTY
7630: LIST
7631: LIST
7632: PUSH
7633: EMPTY
7634: LIST
7635: LIST
7636: LIST
7637: PUSH
7638: EMPTY
7639: LIST
7640: LIST
7641: PPUSH
7642: CALL_OW 70
7646: PUSH
7647: FOR_IN
7648: IFFALSE 7934
// begin ComMoveXY ( unit , GetX ( unit ) , GetY ( unit ) + 5 ) ;
7650: LD_VAR 0 1
7654: PPUSH
7655: LD_VAR 0 1
7659: PPUSH
7660: CALL_OW 250
7664: PPUSH
7665: LD_VAR 0 1
7669: PPUSH
7670: CALL_OW 251
7674: PUSH
7675: LD_INT 5
7677: PLUS
7678: PPUSH
7679: CALL_OW 111
// if not meetPlatonov and not dialogLoopBlocker then
7683: LD_EXP 7
7687: NOT
7688: PUSH
7689: LD_EXP 33
7693: NOT
7694: AND
7695: IFFALSE 7758
// begin if unit <> Burlak and IsOk ( Kovalyuk ) then
7697: LD_VAR 0 1
7701: PUSH
7702: LD_EXP 62
7706: NONEQUAL
7707: PUSH
7708: LD_EXP 70
7712: PPUSH
7713: CALL_OW 302
7717: AND
7718: IFFALSE 7732
// Say ( Kovalyuk , D1b-Kov-1 ) ;
7720: LD_EXP 70
7724: PPUSH
7725: LD_STRING D1b-Kov-1
7727: PPUSH
7728: CALL_OW 88
// if unit = Burlak then
7732: LD_VAR 0 1
7736: PUSH
7737: LD_EXP 62
7741: EQUAL
7742: IFFALSE 7756
// Say ( Burlak , D1b-Bur-1 ) ;
7744: LD_EXP 62
7748: PPUSH
7749: LD_STRING D1b-Bur-1
7751: PPUSH
7752: CALL_OW 88
// end else
7756: GO 7777
// if not dialogLoopBlocker then
7758: LD_EXP 33
7762: NOT
7763: IFFALSE 7777
// Say ( Platonov , D8-Pla-1 ) ;
7765: LD_EXP 76
7769: PPUSH
7770: LD_STRING D8-Pla-1
7772: PPUSH
7773: CALL_OW 88
// if not dialogLoopBlocker then
7777: LD_EXP 33
7781: NOT
7782: IFFALSE 7792
// dialogLoopBlocker = true ;
7784: LD_ADDR_EXP 33
7788: PUSH
7789: LD_INT 1
7791: ST_TO_ADDR
// repeat ComMoveXY ( FilterUnitsInArea ( NorthMoveLimitArea , [ [ f_side , 3 ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) , GetX ( unit ) , GetY ( unit ) + 5 ) ;
7792: LD_INT 20
7794: PPUSH
7795: LD_INT 22
7797: PUSH
7798: LD_INT 3
7800: PUSH
7801: EMPTY
7802: LIST
7803: LIST
7804: PUSH
7805: LD_INT 2
7807: PUSH
7808: LD_INT 21
7810: PUSH
7811: LD_INT 1
7813: PUSH
7814: EMPTY
7815: LIST
7816: LIST
7817: PUSH
7818: LD_INT 21
7820: PUSH
7821: LD_INT 2
7823: PUSH
7824: EMPTY
7825: LIST
7826: LIST
7827: PUSH
7828: EMPTY
7829: LIST
7830: LIST
7831: LIST
7832: PUSH
7833: EMPTY
7834: LIST
7835: LIST
7836: PPUSH
7837: CALL_OW 70
7841: PPUSH
7842: LD_VAR 0 1
7846: PPUSH
7847: CALL_OW 250
7851: PPUSH
7852: LD_VAR 0 1
7856: PPUSH
7857: CALL_OW 251
7861: PUSH
7862: LD_INT 5
7864: PLUS
7865: PPUSH
7866: CALL_OW 111
// wait ( 0 0$1 ) ;
7870: LD_INT 35
7872: PPUSH
7873: CALL_OW 67
// until FilterUnitsInArea ( NorthMoveLimitArea , [ [ f_side , 3 ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) = 0 ;
7877: LD_INT 20
7879: PPUSH
7880: LD_INT 22
7882: PUSH
7883: LD_INT 3
7885: PUSH
7886: EMPTY
7887: LIST
7888: LIST
7889: PUSH
7890: LD_INT 2
7892: PUSH
7893: LD_INT 21
7895: PUSH
7896: LD_INT 1
7898: PUSH
7899: EMPTY
7900: LIST
7901: LIST
7902: PUSH
7903: LD_INT 21
7905: PUSH
7906: LD_INT 2
7908: PUSH
7909: EMPTY
7910: LIST
7911: LIST
7912: PUSH
7913: EMPTY
7914: LIST
7915: LIST
7916: LIST
7917: PUSH
7918: EMPTY
7919: LIST
7920: LIST
7921: PPUSH
7922: CALL_OW 70
7926: PUSH
7927: LD_INT 0
7929: EQUAL
7930: IFFALSE 7792
// end ;
7932: GO 7647
7934: POP
7935: POP
// if dialogLoopBlocker then
7936: LD_EXP 33
7940: IFFALSE 7957
// begin wait ( 0 0$5 ) ;
7942: LD_INT 175
7944: PPUSH
7945: CALL_OW 67
// dialogLoopBlocker = false ;
7949: LD_ADDR_EXP 33
7953: PUSH
7954: LD_INT 0
7956: ST_TO_ADDR
// end ; end ;
7957: PPOPN 1
7959: END
// every 1 trigger not canExitBase and FilterUnitsExceptArea ( BeriaBaseArea , [ [ f_side , 3 ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) > 0 do var unit ;
7960: LD_EXP 19
7964: NOT
7965: PUSH
7966: LD_INT 8
7968: PPUSH
7969: LD_INT 22
7971: PUSH
7972: LD_INT 3
7974: PUSH
7975: EMPTY
7976: LIST
7977: LIST
7978: PUSH
7979: LD_INT 2
7981: PUSH
7982: LD_INT 21
7984: PUSH
7985: LD_INT 1
7987: PUSH
7988: EMPTY
7989: LIST
7990: LIST
7991: PUSH
7992: LD_INT 21
7994: PUSH
7995: LD_INT 2
7997: PUSH
7998: EMPTY
7999: LIST
8000: LIST
8001: PUSH
8002: EMPTY
8003: LIST
8004: LIST
8005: LIST
8006: PUSH
8007: EMPTY
8008: LIST
8009: LIST
8010: PPUSH
8011: CALL_OW 71
8015: PUSH
8016: LD_INT 0
8018: GREATER
8019: AND
8020: IFFALSE 8155
8022: GO 8024
8024: DISABLE
8025: LD_INT 0
8027: PPUSH
// begin enable ;
8028: ENABLE
// for unit in FilterUnitsExceptArea ( BeriaBaseArea , [ [ f_side , 3 ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) do
8029: LD_ADDR_VAR 0 1
8033: PUSH
8034: LD_INT 8
8036: PPUSH
8037: LD_INT 22
8039: PUSH
8040: LD_INT 3
8042: PUSH
8043: EMPTY
8044: LIST
8045: LIST
8046: PUSH
8047: LD_INT 2
8049: PUSH
8050: LD_INT 21
8052: PUSH
8053: LD_INT 1
8055: PUSH
8056: EMPTY
8057: LIST
8058: LIST
8059: PUSH
8060: LD_INT 21
8062: PUSH
8063: LD_INT 2
8065: PUSH
8066: EMPTY
8067: LIST
8068: LIST
8069: PUSH
8070: EMPTY
8071: LIST
8072: LIST
8073: LIST
8074: PUSH
8075: EMPTY
8076: LIST
8077: LIST
8078: PPUSH
8079: CALL_OW 71
8083: PUSH
8084: FOR_IN
8085: IFFALSE 8138
// begin ComMoveXY ( unit , 114 , 98 ) ;
8087: LD_VAR 0 1
8091: PPUSH
8092: LD_INT 114
8094: PPUSH
8095: LD_INT 98
8097: PPUSH
8098: CALL_OW 111
// if dialogLoopBlocker then
8102: LD_EXP 33
8106: IFFALSE 8112
// exit ;
8108: POP
8109: POP
8110: GO 8155
// dialogLoopBlocker = true ;
8112: LD_ADDR_EXP 33
8116: PUSH
8117: LD_INT 1
8119: ST_TO_ADDR
// Say ( Platonov , D8-Pla-1 ) ;
8120: LD_EXP 76
8124: PPUSH
8125: LD_STRING D8-Pla-1
8127: PPUSH
8128: CALL_OW 88
// exit ;
8132: POP
8133: POP
8134: GO 8155
// end ;
8136: GO 8084
8138: POP
8139: POP
// wait ( 0 0$5 ) ;
8140: LD_INT 175
8142: PPUSH
8143: CALL_OW 67
// dialogLoopBlocker = false ;
8147: LD_ADDR_EXP 33
8151: PUSH
8152: LD_INT 0
8154: ST_TO_ADDR
// end ;
8155: PPOPN 1
8157: END
// every 1 1$30 trigger not meetPlatonov and FilterUnitsInArea ( KirovBaseArea , [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) > 0 do
8158: LD_EXP 7
8162: NOT
8163: PUSH
8164: LD_INT 9
8166: PPUSH
8167: LD_INT 22
8169: PUSH
8170: LD_INT 3
8172: PUSH
8173: EMPTY
8174: LIST
8175: LIST
8176: PUSH
8177: LD_INT 21
8179: PUSH
8180: LD_INT 1
8182: PUSH
8183: EMPTY
8184: LIST
8185: LIST
8186: PUSH
8187: EMPTY
8188: LIST
8189: LIST
8190: PPUSH
8191: CALL_OW 70
8195: PUSH
8196: LD_INT 0
8198: GREATER
8199: AND
8200: IFFALSE 8217
8202: GO 8204
8204: DISABLE
// Say ( Kurin , D1a-Kur-1 ) ;
8205: LD_EXP 67
8209: PPUSH
8210: LD_STRING D1a-Kur-1
8212: PPUSH
8213: CALL_OW 88
8217: END
// every 0 0$1 trigger not meetPlatonov and IsOK ( Burlak ) and FilterUnitsInArea ( MeetBeriaBaseArea , [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) > 0 do var i , unit , yourUnits , randomMaleSoldiers , nearRandom ;
8218: LD_EXP 7
8222: NOT
8223: PUSH
8224: LD_EXP 62
8228: PPUSH
8229: CALL_OW 302
8233: AND
8234: PUSH
8235: LD_INT 29
8237: PPUSH
8238: LD_INT 22
8240: PUSH
8241: LD_INT 3
8243: PUSH
8244: EMPTY
8245: LIST
8246: LIST
8247: PUSH
8248: LD_INT 21
8250: PUSH
8251: LD_INT 1
8253: PUSH
8254: EMPTY
8255: LIST
8256: LIST
8257: PUSH
8258: EMPTY
8259: LIST
8260: LIST
8261: PPUSH
8262: CALL_OW 70
8266: PUSH
8267: LD_INT 0
8269: GREATER
8270: AND
8271: IFFALSE 8898
8273: GO 8275
8275: DISABLE
8276: LD_INT 0
8278: PPUSH
8279: PPUSH
8280: PPUSH
8281: PPUSH
8282: PPUSH
// begin enable ;
8283: ENABLE
// for unit in FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) do
8284: LD_ADDR_VAR 0 2
8288: PUSH
8289: LD_INT 22
8291: PUSH
8292: LD_INT 3
8294: PUSH
8295: EMPTY
8296: LIST
8297: LIST
8298: PUSH
8299: LD_INT 21
8301: PUSH
8302: LD_INT 1
8304: PUSH
8305: EMPTY
8306: LIST
8307: LIST
8308: PUSH
8309: EMPTY
8310: LIST
8311: LIST
8312: PPUSH
8313: CALL_OW 69
8317: PUSH
8318: FOR_IN
8319: IFFALSE 8896
// if See ( 6 , unit ) then
8321: LD_INT 6
8323: PPUSH
8324: LD_VAR 0 2
8328: PPUSH
8329: CALL_OW 292
8333: IFFALSE 8894
// begin meetPlatonov = true ;
8335: LD_ADDR_EXP 7
8339: PUSH
8340: LD_INT 1
8342: ST_TO_ADDR
// InGameOn ;
8343: CALL_OW 8
// DialogueOn ;
8347: CALL_OW 6
// randomMaleSoldiers = UnitFilter ( platSoldiers , [ f_sex , sex_male ] ) ;
8351: LD_ADDR_VAR 0 4
8355: PUSH
8356: LD_EXP 77
8360: PPUSH
8361: LD_INT 26
8363: PUSH
8364: LD_INT 1
8366: PUSH
8367: EMPTY
8368: LIST
8369: LIST
8370: PPUSH
8371: CALL_OW 72
8375: ST_TO_ADDR
// randomMaleSoldiers = randomMaleSoldiers ^ FilterUnitsInArea ( BeriaBaseArea , [ [ f_side , 6 ] , [ f_type , unit_building ] , [ f_btype , b_breastwork ] , [ f_not , [ f_empty ] ] ] ) ;
8376: LD_ADDR_VAR 0 4
8380: PUSH
8381: LD_VAR 0 4
8385: PUSH
8386: LD_INT 8
8388: PPUSH
8389: LD_INT 22
8391: PUSH
8392: LD_INT 6
8394: PUSH
8395: EMPTY
8396: LIST
8397: LIST
8398: PUSH
8399: LD_INT 21
8401: PUSH
8402: LD_INT 3
8404: PUSH
8405: EMPTY
8406: LIST
8407: LIST
8408: PUSH
8409: LD_INT 30
8411: PUSH
8412: LD_INT 31
8414: PUSH
8415: EMPTY
8416: LIST
8417: LIST
8418: PUSH
8419: LD_INT 3
8421: PUSH
8422: LD_INT 58
8424: PUSH
8425: EMPTY
8426: LIST
8427: PUSH
8428: EMPTY
8429: LIST
8430: LIST
8431: PUSH
8432: EMPTY
8433: LIST
8434: LIST
8435: LIST
8436: LIST
8437: PPUSH
8438: CALL_OW 70
8442: ADD
8443: ST_TO_ADDR
// nearRandom = NearestUnitToUnit ( randomMaleSoldiers , unit ) ;
8444: LD_ADDR_VAR 0 5
8448: PUSH
8449: LD_VAR 0 4
8453: PPUSH
8454: LD_VAR 0 2
8458: PPUSH
8459: CALL_OW 74
8463: ST_TO_ADDR
// if GetType ( nearRandom ) = unit_building then
8464: LD_VAR 0 5
8468: PPUSH
8469: CALL_OW 247
8473: PUSH
8474: LD_INT 3
8476: EQUAL
8477: IFFALSE 8498
// nearRandom = UnitsInside ( nearRandom ) [ 1 ] ;
8479: LD_ADDR_VAR 0 5
8483: PUSH
8484: LD_VAR 0 5
8488: PPUSH
8489: CALL_OW 313
8493: PUSH
8494: LD_INT 1
8496: ARRAY
8497: ST_TO_ADDR
// DialogRandom ( nearRandom , D2-RSol1-1 ,  , false ) ;
8498: LD_VAR 0 5
8502: PPUSH
8503: LD_STRING D2-RSol1-1
8505: PPUSH
8506: LD_STRING 
8508: PPUSH
8509: LD_INT 0
8511: PPUSH
8512: CALL 4093 0 4
// Say ( Burlak , D2-Bur-1 ) ;
8516: LD_EXP 62
8520: PPUSH
8521: LD_STRING D2-Bur-1
8523: PPUSH
8524: CALL_OW 88
// Say ( nearRandom , D2-RSol1-2 ) ;
8528: LD_VAR 0 5
8532: PPUSH
8533: LD_STRING D2-RSol1-2
8535: PPUSH
8536: CALL_OW 88
// DialogueOff ;
8540: CALL_OW 7
// yourUnits = FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_ok ] ] ) ;
8544: LD_ADDR_VAR 0 3
8548: PUSH
8549: LD_INT 22
8551: PUSH
8552: LD_INT 3
8554: PUSH
8555: EMPTY
8556: LIST
8557: LIST
8558: PUSH
8559: LD_INT 21
8561: PUSH
8562: LD_INT 1
8564: PUSH
8565: EMPTY
8566: LIST
8567: LIST
8568: PUSH
8569: LD_INT 50
8571: PUSH
8572: EMPTY
8573: LIST
8574: PUSH
8575: EMPTY
8576: LIST
8577: LIST
8578: LIST
8579: PPUSH
8580: CALL_OW 69
8584: ST_TO_ADDR
// for i := 1 to yourUnits do
8585: LD_ADDR_VAR 0 1
8589: PUSH
8590: DOUBLE
8591: LD_INT 1
8593: DEC
8594: ST_TO_ADDR
8595: LD_VAR 0 3
8599: PUSH
8600: FOR_TO
8601: IFFALSE 8670
// begin ComMoveXY ( yourUnits [ i ] , meetWithPlatonovPositions [ i ] [ 1 ] , meetWithPlatonovPositions [ i ] [ 2 ] ) ;
8603: LD_VAR 0 3
8607: PUSH
8608: LD_VAR 0 1
8612: ARRAY
8613: PPUSH
8614: LD_EXP 53
8618: PUSH
8619: LD_VAR 0 1
8623: ARRAY
8624: PUSH
8625: LD_INT 1
8627: ARRAY
8628: PPUSH
8629: LD_EXP 53
8633: PUSH
8634: LD_VAR 0 1
8638: ARRAY
8639: PUSH
8640: LD_INT 2
8642: ARRAY
8643: PPUSH
8644: CALL_OW 111
// AddComTurnUnit ( yourUnits [ i ] , Platonov ) ;
8648: LD_VAR 0 3
8652: PUSH
8653: LD_VAR 0 1
8657: ARRAY
8658: PPUSH
8659: LD_EXP 76
8663: PPUSH
8664: CALL_OW 179
// end ;
8668: GO 8600
8670: POP
8671: POP
// repeat CenterNowOnUnits ( Burlak ) ;
8672: LD_EXP 62
8676: PPUSH
8677: CALL_OW 87
// wait ( 0 0$1 ) ;
8681: LD_INT 35
8683: PPUSH
8684: CALL_OW 67
// until GetDistUnits ( Burlak , Platonov ) < 4 ;
8688: LD_EXP 62
8692: PPUSH
8693: LD_EXP 76
8697: PPUSH
8698: CALL_OW 296
8702: PUSH
8703: LD_INT 4
8705: LESS
8706: IFFALSE 8672
// ComTurnUnit ( Platonov , Burlak ) ;
8708: LD_EXP 76
8712: PPUSH
8713: LD_EXP 62
8717: PPUSH
8718: CALL_OW 119
// Say ( Platonov , D2-Pla-2 ) ;
8722: LD_EXP 76
8726: PPUSH
8727: LD_STRING D2-Pla-2
8729: PPUSH
8730: CALL_OW 88
// Say ( Burlak , D2-Bur-2 ) ;
8734: LD_EXP 62
8738: PPUSH
8739: LD_STRING D2-Bur-2
8741: PPUSH
8742: CALL_OW 88
// Say ( Platonov , D2-Pla-3 ) ;
8746: LD_EXP 76
8750: PPUSH
8751: LD_STRING D2-Pla-3
8753: PPUSH
8754: CALL_OW 88
// Say ( Burlak , D2-Bur-3 ) ;
8758: LD_EXP 62
8762: PPUSH
8763: LD_STRING D2-Bur-3
8765: PPUSH
8766: CALL_OW 88
// Say ( Platonov , D2-Pla-4 ) ;
8770: LD_EXP 76
8774: PPUSH
8775: LD_STRING D2-Pla-4
8777: PPUSH
8778: CALL_OW 88
// Say ( Burlak , D2-Bur-4 ) ;
8782: LD_EXP 62
8786: PPUSH
8787: LD_STRING D2-Bur-4
8789: PPUSH
8790: CALL_OW 88
// Say ( Platonov , D2-Pla-5 ) ;
8794: LD_EXP 76
8798: PPUSH
8799: LD_STRING D2-Pla-5
8801: PPUSH
8802: CALL_OW 88
// Question1 ( [ 1 , 2 , 3 , 4 ] ) ;
8806: LD_INT 1
8808: PUSH
8809: LD_INT 2
8811: PUSH
8812: LD_INT 3
8814: PUSH
8815: LD_INT 4
8817: PUSH
8818: EMPTY
8819: LIST
8820: LIST
8821: LIST
8822: LIST
8823: PPUSH
8824: CALL 4426 0 1
// Say ( Platonov , D3-Pla-1 ) ;
8828: LD_EXP 76
8832: PPUSH
8833: LD_STRING D3-Pla-1
8835: PPUSH
8836: CALL_OW 88
// Say ( Burlak , D3-Bur-1 ) ;
8840: LD_EXP 62
8844: PPUSH
8845: LD_STRING D3-Bur-1
8847: PPUSH
8848: CALL_OW 88
// InGameOff ;
8852: CALL_OW 9
// ChangeMissionObjectives ( M2a ) ;
8856: LD_STRING M2a
8858: PPUSH
8859: CALL_OW 337
// ComFree ( Platonov ) ;
8863: LD_EXP 76
8867: PPUSH
8868: CALL_OW 139
// SetSide ( beria , 3 ) ;
8872: LD_INT 106
8874: PPUSH
8875: LD_INT 3
8877: PPUSH
8878: CALL_OW 235
// canExitBase = false ;
8882: LD_ADDR_EXP 19
8886: PUSH
8887: LD_INT 0
8889: ST_TO_ADDR
// exit ;
8890: POP
8891: POP
8892: GO 8898
// end ;
8894: GO 8318
8896: POP
8897: POP
// end ;
8898: PPOPN 5
8900: END
// export function Dial_LabConstructed ; begin
8901: LD_INT 0
8903: PPUSH
// labConstructed = true ;
8904: LD_ADDR_EXP 8
8908: PUSH
8909: LD_INT 1
8911: ST_TO_ADDR
// DialogueOn ;
8912: CALL_OW 6
// Say ( Burlak , D5a-Bur-1 ) ;
8916: LD_EXP 62
8920: PPUSH
8921: LD_STRING D5a-Bur-1
8923: PPUSH
8924: CALL_OW 88
// if workshopConstructed then
8928: LD_EXP 9
8932: IFFALSE 8948
// Say ( Platonov , D5a-Pla-1 ) else
8934: LD_EXP 76
8938: PPUSH
8939: LD_STRING D5a-Pla-1
8941: PPUSH
8942: CALL_OW 88
8946: GO 8960
// Say ( Platonov , D5a-Pla-1a ) ;
8948: LD_EXP 76
8952: PPUSH
8953: LD_STRING D5a-Pla-1a
8955: PPUSH
8956: CALL_OW 88
// DialogueOff ;
8960: CALL_OW 7
// ChangeMissionObjectives ( M2b ) ;
8964: LD_STRING M2b
8966: PPUSH
8967: CALL_OW 337
// end ;
8971: LD_VAR 0 1
8975: RET
// export function Dial_WorkshopConstructed ; begin
8976: LD_INT 0
8978: PPUSH
// workshopConstructed = true ;
8979: LD_ADDR_EXP 9
8983: PUSH
8984: LD_INT 1
8986: ST_TO_ADDR
// DialogueOn ;
8987: CALL_OW 6
// Say ( Burlak , D5b-Bur-1 ) ;
8991: LD_EXP 62
8995: PPUSH
8996: LD_STRING D5b-Bur-1
8998: PPUSH
8999: CALL_OW 88
// if labConstructed then
9003: LD_EXP 8
9007: IFFALSE 9023
// Say ( Platonov , D5b-Pla-1 ) else
9009: LD_EXP 76
9013: PPUSH
9014: LD_STRING D5b-Pla-1
9016: PPUSH
9017: CALL_OW 88
9021: GO 9035
// Say ( Platonov , D5b-Pla-1a ) ;
9023: LD_EXP 76
9027: PPUSH
9028: LD_STRING D5b-Pla-1a
9030: PPUSH
9031: CALL_OW 88
// DialogueOff ;
9035: CALL_OW 7
// ChangeMissionObjectives ( M2c ) ;
9039: LD_STRING M2c
9041: PPUSH
9042: CALL_OW 337
// end ;
9046: LD_VAR 0 1
9050: RET
// export function Dial_StopConstructAgainSameBuilding ( building ) ; begin
9051: LD_INT 0
9053: PPUSH
// wait ( 0 0$1 ) ;
9054: LD_INT 35
9056: PPUSH
9057: CALL_OW 67
// CenterNowOnUnits ( building ) ;
9061: LD_VAR 0 1
9065: PPUSH
9066: CALL_OW 87
// ComStop ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) ) ;
9070: LD_INT 22
9072: PUSH
9073: LD_INT 3
9075: PUSH
9076: EMPTY
9077: LIST
9078: LIST
9079: PUSH
9080: LD_INT 21
9082: PUSH
9083: LD_INT 1
9085: PUSH
9086: EMPTY
9087: LIST
9088: LIST
9089: PUSH
9090: EMPTY
9091: LIST
9092: LIST
9093: PPUSH
9094: CALL_OW 69
9098: PPUSH
9099: CALL_OW 141
// DialogueOn ;
9103: CALL_OW 6
// Say ( Platonov , D6-Pla-1 ) ;
9107: LD_EXP 76
9111: PPUSH
9112: LD_STRING D6-Pla-1
9114: PPUSH
9115: CALL_OW 88
// Say ( Burlak , D6-Bur-1 ) ;
9119: LD_EXP 62
9123: PPUSH
9124: LD_STRING D6-Bur-1
9126: PPUSH
9127: CALL_OW 88
// DialogueOff ;
9131: CALL_OW 7
// case GetBType ( building ) of b_lab :
9135: LD_VAR 0 1
9139: PPUSH
9140: CALL_OW 266
9144: PUSH
9145: LD_INT 6
9147: DOUBLE
9148: EQUAL
9149: IFTRUE 9153
9151: GO 9193
9153: POP
// SetResourceType ( GetBase ( beria ) , mat_cans , GetResourceType ( GetBase ( beria ) , mat_cans ) + labCratesRefund ) ; b_workshop :
9154: LD_INT 106
9156: PPUSH
9157: CALL_OW 274
9161: PPUSH
9162: LD_INT 1
9164: PPUSH
9165: LD_INT 106
9167: PPUSH
9168: CALL_OW 274
9172: PPUSH
9173: LD_INT 1
9175: PPUSH
9176: CALL_OW 275
9180: PUSH
9181: LD_EXP 54
9185: PLUS
9186: PPUSH
9187: CALL_OW 277
9191: GO 9386
9193: LD_INT 2
9195: DOUBLE
9196: EQUAL
9197: IFTRUE 9201
9199: GO 9241
9201: POP
// SetResourceType ( GetBase ( beria ) , mat_cans , GetResourceType ( GetBase ( beria ) , mat_cans ) + workshopCratesRefund ) ; b_oil_power :
9202: LD_INT 106
9204: PPUSH
9205: CALL_OW 274
9209: PPUSH
9210: LD_INT 1
9212: PPUSH
9213: LD_INT 106
9215: PPUSH
9216: CALL_OW 274
9220: PPUSH
9221: LD_INT 1
9223: PPUSH
9224: CALL_OW 275
9228: PUSH
9229: LD_EXP 55
9233: PLUS
9234: PPUSH
9235: CALL_OW 277
9239: GO 9386
9241: LD_INT 26
9243: DOUBLE
9244: EQUAL
9245: IFTRUE 9249
9247: GO 9289
9249: POP
// SetResourceType ( GetBase ( beria ) , mat_cans , GetResourceType ( GetBase ( beria ) , mat_cans ) + oilPowerCratesRefund ) ; b_armoury :
9250: LD_INT 106
9252: PPUSH
9253: CALL_OW 274
9257: PPUSH
9258: LD_INT 1
9260: PPUSH
9261: LD_INT 106
9263: PPUSH
9264: CALL_OW 274
9268: PPUSH
9269: LD_INT 1
9271: PPUSH
9272: CALL_OW 275
9276: PUSH
9277: LD_EXP 56
9281: PLUS
9282: PPUSH
9283: CALL_OW 277
9287: GO 9386
9289: LD_INT 4
9291: DOUBLE
9292: EQUAL
9293: IFTRUE 9297
9295: GO 9337
9297: POP
// SetResourceType ( GetBase ( beria ) , mat_cans , GetResourceType ( GetBase ( beria ) , mat_cans ) + armouryCratesRefund ) ; b_breastwork :
9298: LD_INT 106
9300: PPUSH
9301: CALL_OW 274
9305: PPUSH
9306: LD_INT 1
9308: PPUSH
9309: LD_INT 106
9311: PPUSH
9312: CALL_OW 274
9316: PPUSH
9317: LD_INT 1
9319: PPUSH
9320: CALL_OW 275
9324: PUSH
9325: LD_EXP 57
9329: PLUS
9330: PPUSH
9331: CALL_OW 277
9335: GO 9386
9337: LD_INT 31
9339: DOUBLE
9340: EQUAL
9341: IFTRUE 9345
9343: GO 9385
9345: POP
// SetResourceType ( GetBase ( beria ) , mat_cans , GetResourceType ( GetBase ( beria ) , mat_cans ) + bunkerCratesRefund ) ; end ;
9346: LD_INT 106
9348: PPUSH
9349: CALL_OW 274
9353: PPUSH
9354: LD_INT 1
9356: PPUSH
9357: LD_INT 106
9359: PPUSH
9360: CALL_OW 274
9364: PPUSH
9365: LD_INT 1
9367: PPUSH
9368: CALL_OW 275
9372: PUSH
9373: LD_EXP 58
9377: PLUS
9378: PPUSH
9379: CALL_OW 277
9383: GO 9386
9385: POP
// RemoveUnit ( building ) ;
9386: LD_VAR 0 1
9390: PPUSH
9391: CALL_OW 64
// end ;
9395: LD_VAR 0 2
9399: RET
// every 0 0$2 trigger workshopConstructed and labConstructed do
9400: LD_EXP 9
9404: PUSH
9405: LD_EXP 8
9409: AND
9410: IFFALSE 9519
9412: GO 9414
9414: DISABLE
// begin DialogueOn ;
9415: CALL_OW 6
// if engineResearched then
9419: LD_EXP 10
9423: IFFALSE 9451
// begin Say ( Burlak , D7b-Bur-1 ) ;
9425: LD_EXP 62
9429: PPUSH
9430: LD_STRING D7b-Bur-1
9432: PPUSH
9433: CALL_OW 88
// Say ( Platonov , D7b-Pla-1 ) ;
9437: LD_EXP 76
9441: PPUSH
9442: LD_STRING D7b-Pla-1
9444: PPUSH
9445: CALL_OW 88
// end else
9449: GO 9475
// begin Say ( Burlak , D7a-Bur-1 ) ;
9451: LD_EXP 62
9455: PPUSH
9456: LD_STRING D7a-Bur-1
9458: PPUSH
9459: CALL_OW 88
// Say ( Platonov , D7a-Pla-1 ) ;
9463: LD_EXP 76
9467: PPUSH
9468: LD_STRING D7a-Pla-1
9470: PPUSH
9471: CALL_OW 88
// end ; DialogueOff ;
9475: CALL_OW 7
// ChangeMissionObjectives ( M2 ) ;
9479: LD_STRING M2
9481: PPUSH
9482: CALL_OW 337
// CreateCratesXYR ( 3 , GetX ( Platonov ) , GetY ( Platonov ) , 5 , true ) ;
9486: LD_INT 3
9488: PPUSH
9489: LD_EXP 76
9493: PPUSH
9494: CALL_OW 250
9498: PPUSH
9499: LD_EXP 76
9503: PPUSH
9504: CALL_OW 251
9508: PPUSH
9509: LD_INT 5
9511: PPUSH
9512: LD_INT 1
9514: PPUSH
9515: CALL_OW 56
// end ;
9519: END
// export function Dial_NewCrates ( x , y ) ; begin
9520: LD_INT 0
9522: PPUSH
// wait ( 0 0$18 ) ;
9523: LD_INT 630
9525: PPUSH
9526: CALL_OW 67
// if not spawnCrates then
9530: LD_EXP 21
9534: NOT
9535: IFFALSE 9539
// exit ;
9537: GO 9570
// ComMoveXY ( Platonov , x , y ) ;
9539: LD_EXP 76
9543: PPUSH
9544: LD_VAR 0 1
9548: PPUSH
9549: LD_VAR 0 2
9553: PPUSH
9554: CALL_OW 111
// Say ( Platonov , D4-Pla-1 ) ;
9558: LD_EXP 76
9562: PPUSH
9563: LD_STRING D4-Pla-1
9565: PPUSH
9566: CALL_OW 88
// end ;
9570: LD_VAR 0 3
9574: RET
// export function Dial_FirstVehConstructed ( factory ) ; begin
9575: LD_INT 0
9577: PPUSH
// firstVeh = FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_vehicle ] ] ) [ 1 ] ;
9578: LD_ADDR_EXP 13
9582: PUSH
9583: LD_INT 22
9585: PUSH
9586: LD_INT 3
9588: PUSH
9589: EMPTY
9590: LIST
9591: LIST
9592: PUSH
9593: LD_INT 21
9595: PUSH
9596: LD_INT 2
9598: PUSH
9599: EMPTY
9600: LIST
9601: LIST
9602: PUSH
9603: EMPTY
9604: LIST
9605: LIST
9606: PPUSH
9607: CALL_OW 69
9611: PUSH
9612: LD_INT 1
9614: ARRAY
9615: ST_TO_ADDR
// constructedFirstVehicle = true ;
9616: LD_ADDR_EXP 12
9620: PUSH
9621: LD_INT 1
9623: ST_TO_ADDR
// InGameOn ;
9624: CALL_OW 8
// CenterNowOnUnits ( factory ) ;
9628: LD_VAR 0 1
9632: PPUSH
9633: CALL_OW 87
// wait ( 0 0$3 ) ;
9637: LD_INT 105
9639: PPUSH
9640: CALL_OW 67
// Say ( Burlak , D9-Bur-1 ) ;
9644: LD_EXP 62
9648: PPUSH
9649: LD_STRING D9-Bur-1
9651: PPUSH
9652: CALL_OW 88
// ComMoveXY ( Platonov , GetX ( firstVeh ) , GetY ( firstVeh ) ) ;
9656: LD_EXP 76
9660: PPUSH
9661: LD_EXP 13
9665: PPUSH
9666: CALL_OW 250
9670: PPUSH
9671: LD_EXP 13
9675: PPUSH
9676: CALL_OW 251
9680: PPUSH
9681: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
9685: LD_INT 35
9687: PPUSH
9688: CALL_OW 67
// until GetDistUnits ( Platonov , firstVeh ) < 4 ;
9692: LD_EXP 76
9696: PPUSH
9697: LD_EXP 13
9701: PPUSH
9702: CALL_OW 296
9706: PUSH
9707: LD_INT 4
9709: LESS
9710: IFFALSE 9685
// ComTurnUnit ( Platonov , firstVeh ) ;
9712: LD_EXP 76
9716: PPUSH
9717: LD_EXP 13
9721: PPUSH
9722: CALL_OW 119
// Say ( Platonov , D9-Pla-1 ) ;
9726: LD_EXP 76
9730: PPUSH
9731: LD_STRING D9-Pla-1
9733: PPUSH
9734: CALL_OW 88
// InGameOff ;
9738: CALL_OW 9
// ChangeMissionObjectives ( M3 ) ;
9742: LD_STRING M3
9744: PPUSH
9745: CALL_OW 337
// canExitBase = true ;
9749: LD_ADDR_EXP 19
9753: PUSH
9754: LD_INT 1
9756: ST_TO_ADDR
// ComMoveXY ( Platonov , 112 , 97 ) ;
9757: LD_EXP 76
9761: PPUSH
9762: LD_INT 112
9764: PPUSH
9765: LD_INT 97
9767: PPUSH
9768: CALL_OW 111
// end ;
9772: LD_VAR 0 2
9776: RET
// every 0 0$1 trigger IsInArea ( firstVeh , KirovBaseArea ) and not vehicleForKurin do var i , eng , mech ;
9777: LD_EXP 13
9781: PPUSH
9782: LD_INT 9
9784: PPUSH
9785: CALL_OW 308
9789: PUSH
9790: LD_EXP 14
9794: NOT
9795: AND
9796: IFFALSE 10650
9798: GO 9800
9800: DISABLE
9801: LD_INT 0
9803: PPUSH
9804: PPUSH
9805: PPUSH
// begin vehicleForKurin = true ;
9806: LD_ADDR_EXP 14
9810: PUSH
9811: LD_INT 1
9813: ST_TO_ADDR
// eng = UnitFilter ( otherKirovUnits , [ f_class , class_engineer ] ) [ 1 ] ;
9814: LD_ADDR_VAR 0 2
9818: PUSH
9819: LD_EXP 69
9823: PPUSH
9824: LD_INT 25
9826: PUSH
9827: LD_INT 2
9829: PUSH
9830: EMPTY
9831: LIST
9832: LIST
9833: PPUSH
9834: CALL_OW 72
9838: PUSH
9839: LD_INT 1
9841: ARRAY
9842: ST_TO_ADDR
// mech = UnitFilter ( otherKirovUnits , [ f_class , class_mechanic ] ) [ 1 ] ;
9843: LD_ADDR_VAR 0 3
9847: PUSH
9848: LD_EXP 69
9852: PPUSH
9853: LD_INT 25
9855: PUSH
9856: LD_INT 3
9858: PUSH
9859: EMPTY
9860: LIST
9861: LIST
9862: PPUSH
9863: CALL_OW 72
9867: PUSH
9868: LD_INT 1
9870: ARRAY
9871: ST_TO_ADDR
// InGameOn ;
9872: CALL_OW 8
// CenterNowOnUnits ( Kurin ) ;
9876: LD_EXP 67
9880: PPUSH
9881: CALL_OW 87
// ComMoveXY ( firstVeh , GetX ( Kurin ) , GetY ( Kurin ) ) ;
9885: LD_EXP 13
9889: PPUSH
9890: LD_EXP 67
9894: PPUSH
9895: CALL_OW 250
9899: PPUSH
9900: LD_EXP 67
9904: PPUSH
9905: CALL_OW 251
9909: PPUSH
9910: CALL_OW 111
// Say ( Kurin , D10-Kur-1 ) ;
9914: LD_EXP 67
9918: PPUSH
9919: LD_STRING D10-Kur-1
9921: PPUSH
9922: CALL_OW 88
// repeat wait ( 0 0$1 ) ;
9926: LD_INT 35
9928: PPUSH
9929: CALL_OW 67
// ComMoveXY ( firstVeh , GetX ( Kurin ) , GetY ( Kurin ) ) ;
9933: LD_EXP 13
9937: PPUSH
9938: LD_EXP 67
9942: PPUSH
9943: CALL_OW 250
9947: PPUSH
9948: LD_EXP 67
9952: PPUSH
9953: CALL_OW 251
9957: PPUSH
9958: CALL_OW 111
// until GetDistUnits ( firstVeh , Kurin ) < 9 ;
9962: LD_EXP 13
9966: PPUSH
9967: LD_EXP 67
9971: PPUSH
9972: CALL_OW 296
9976: PUSH
9977: LD_INT 9
9979: LESS
9980: IFFALSE 9926
// ComExitVehicle ( UnitsInside ( firstVeh ) ) ;
9982: LD_EXP 13
9986: PPUSH
9987: CALL_OW 313
9991: PPUSH
9992: CALL_OW 121
// wait ( 0 0$1 ) ;
9996: LD_INT 35
9998: PPUSH
9999: CALL_OW 67
// if GetLives ( firstVeh ) < 1000 then
10003: LD_EXP 13
10007: PPUSH
10008: CALL_OW 256
10012: PUSH
10013: LD_INT 1000
10015: LESS
10016: IFFALSE 10048
// begin ComExitBuilding ( mech ) ;
10018: LD_VAR 0 3
10022: PPUSH
10023: CALL_OW 122
// wait ( 0 0$1 ) ;
10027: LD_INT 35
10029: PPUSH
10030: CALL_OW 67
// AddComRepairVehicle ( mech , firstVeh ) ;
10034: LD_VAR 0 3
10038: PPUSH
10039: LD_EXP 13
10043: PPUSH
10044: CALL_OW 189
// end ; if GetFuel ( firstVeh ) < 90 then
10048: LD_EXP 13
10052: PPUSH
10053: CALL_OW 261
10057: PUSH
10058: LD_INT 90
10060: LESS
10061: IFFALSE 10096
// begin ComExitBuilding ( eng ) ;
10063: LD_VAR 0 2
10067: PPUSH
10068: CALL_OW 122
// wait ( 0 0$1 ) ;
10072: LD_INT 35
10074: PPUSH
10075: CALL_OW 67
// ExtAddComRefuel ( eng , kirov , firstVeh ) ;
10079: LD_VAR 0 2
10083: PPUSH
10084: LD_INT 71
10086: PPUSH
10087: LD_EXP 13
10091: PPUSH
10092: CALL 4664 0 3
// end ; repeat wait ( 0 0$1 ) ;
10096: LD_INT 35
10098: PPUSH
10099: CALL_OW 67
// until GetLives ( firstVeh ) = 1000 and GetFuel ( firstVeh ) > 90 ;
10103: LD_EXP 13
10107: PPUSH
10108: CALL_OW 256
10112: PUSH
10113: LD_INT 1000
10115: EQUAL
10116: PUSH
10117: LD_EXP 13
10121: PPUSH
10122: CALL_OW 261
10126: PUSH
10127: LD_INT 90
10129: GREATER
10130: AND
10131: IFFALSE 10096
// if UnitsInside ( firstVeh ) then
10133: LD_EXP 13
10137: PPUSH
10138: CALL_OW 313
10142: IFFALSE 10162
// ComExitVehicle ( UnitsInside ( firstVeh ) [ 1 ] ) ;
10144: LD_EXP 13
10148: PPUSH
10149: CALL_OW 313
10153: PUSH
10154: LD_INT 1
10156: ARRAY
10157: PPUSH
10158: CALL_OW 121
// ComEnterUnit ( eng , kirov ) ;
10162: LD_VAR 0 2
10166: PPUSH
10167: LD_INT 71
10169: PPUSH
10170: CALL_OW 120
// SetSide ( firstVeh , 6 ) ;
10174: LD_EXP 13
10178: PPUSH
10179: LD_INT 6
10181: PPUSH
10182: CALL_OW 235
// if belkovReturn then
10186: LD_EXP 6
10190: IFFALSE 10276
// begin if IsInUnit ( Belkov ) then
10192: LD_EXP 64
10196: PPUSH
10197: CALL_OW 310
10201: IFFALSE 10212
// ComExitBuilding ( Belkov ) ;
10203: LD_EXP 64
10207: PPUSH
10208: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
10212: LD_INT 35
10214: PPUSH
10215: CALL_OW 67
// AddComEnterUnit ( Belkov , firstVeh ) ;
10219: LD_EXP 64
10223: PPUSH
10224: LD_EXP 13
10228: PPUSH
10229: CALL_OW 180
// until IsInUnit ( Belkov ) = firstVeh ;
10233: LD_EXP 64
10237: PPUSH
10238: CALL_OW 310
10242: PUSH
10243: LD_EXP 13
10247: EQUAL
10248: IFFALSE 10212
// Say ( Belkov , D10-Bel-1 ) ;
10250: LD_EXP 64
10254: PPUSH
10255: LD_STRING D10-Bel-1
10257: PPUSH
10258: CALL_OW 88
// Say ( Kurin , D10-Kur-2 ) ;
10262: LD_EXP 67
10266: PPUSH
10267: LD_STRING D10-Kur-2
10269: PPUSH
10270: CALL_OW 88
// end else
10274: GO 10402
// begin if IsInUnit ( Belkov2 ) then
10276: LD_EXP 68
10280: PPUSH
10281: CALL_OW 310
10285: IFFALSE 10296
// ComExitBuilding ( Belkov2 ) ;
10287: LD_EXP 68
10291: PPUSH
10292: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
10296: LD_INT 35
10298: PPUSH
10299: CALL_OW 67
// AddComEnterUnit ( Belkov2 , firstVeh ) ;
10303: LD_EXP 68
10307: PPUSH
10308: LD_EXP 13
10312: PPUSH
10313: CALL_OW 180
// until IsInUnit ( Belkov2 ) = firstVeh ;
10317: LD_EXP 68
10321: PPUSH
10322: CALL_OW 310
10326: PUSH
10327: LD_EXP 13
10331: EQUAL
10332: IFFALSE 10296
// meetBelkovBrother = true ;
10334: LD_ADDR_EXP 4
10338: PUSH
10339: LD_INT 1
10341: ST_TO_ADDR
// Say ( Belkov2 , D10-Bel-1 ) ;
10342: LD_EXP 68
10346: PPUSH
10347: LD_STRING D10-Bel-1
10349: PPUSH
10350: CALL_OW 88
// Say ( Burlak , D10-Bur-1 ) ;
10354: LD_EXP 62
10358: PPUSH
10359: LD_STRING D10-Bur-1
10361: PPUSH
10362: CALL_OW 88
// Say ( Belkov2 , D10-Bel-2 ) ;
10366: LD_EXP 68
10370: PPUSH
10371: LD_STRING D10-Bel-2
10373: PPUSH
10374: CALL_OW 88
// Say ( Burlak , D10-Bur-2 ) ;
10378: LD_EXP 62
10382: PPUSH
10383: LD_STRING D10-Bur-2
10385: PPUSH
10386: CALL_OW 88
// Say ( Kurin , D10-Kur-2a ) ;
10390: LD_EXP 67
10394: PPUSH
10395: LD_STRING D10-Kur-2a
10397: PPUSH
10398: CALL_OW 88
// end ; removedBelkovUntisSaved = [ ] ;
10402: LD_ADDR_EXP 74
10406: PUSH
10407: EMPTY
10408: ST_TO_ADDR
// removedBelkovVehicleSaved = [ ] ;
10409: LD_ADDR_EXP 75
10413: PUSH
10414: EMPTY
10415: ST_TO_ADDR
// canRemoveBelkovUnits = true ;
10416: LD_ADDR_EXP 22
10420: PUSH
10421: LD_INT 1
10423: ST_TO_ADDR
// CreateBelkovTeam ;
10424: CALL 6103 0 0
// ComExitBuilding ( belkovTeam ) ;
10428: LD_EXP 73
10432: PPUSH
10433: CALL_OW 122
// wait ( 0 0$1 ) ;
10437: LD_INT 35
10439: PPUSH
10440: CALL_OW 67
// kirovVehicle = FilterAllUnits ( [ [ f_side , 6 ] , [ f_type , unit_vehicle ] ] ) [ 1 ] ;
10444: LD_ADDR_EXP 72
10448: PUSH
10449: LD_INT 22
10451: PUSH
10452: LD_INT 6
10454: PUSH
10455: EMPTY
10456: LIST
10457: LIST
10458: PUSH
10459: LD_INT 21
10461: PUSH
10462: LD_INT 2
10464: PUSH
10465: EMPTY
10466: LIST
10467: LIST
10468: PUSH
10469: EMPTY
10470: LIST
10471: LIST
10472: PPUSH
10473: CALL_OW 69
10477: PUSH
10478: LD_INT 1
10480: ARRAY
10481: ST_TO_ADDR
// belkovTeam = belkovTeam ^ kirovVehicle ;
10482: LD_ADDR_EXP 73
10486: PUSH
10487: LD_EXP 73
10491: PUSH
10492: LD_EXP 72
10496: ADD
10497: ST_TO_ADDR
// ComMoveXY ( belkovTeam , 147 , 102 ) ;
10498: LD_EXP 73
10502: PPUSH
10503: LD_INT 147
10505: PPUSH
10506: LD_INT 102
10508: PPUSH
10509: CALL_OW 111
// AddComMoveXY ( belkovTeam , 133 , 94 ) ;
10513: LD_EXP 73
10517: PPUSH
10518: LD_INT 133
10520: PPUSH
10521: LD_INT 94
10523: PPUSH
10524: CALL_OW 171
// AddComMoveXY ( belkovTeam , 123 , 74 ) ;
10528: LD_EXP 73
10532: PPUSH
10533: LD_INT 123
10535: PPUSH
10536: LD_INT 74
10538: PPUSH
10539: CALL_OW 171
// AddComMoveXY ( belkovTeam , 111 , 48 ) ;
10543: LD_EXP 73
10547: PPUSH
10548: LD_INT 111
10550: PPUSH
10551: LD_INT 48
10553: PPUSH
10554: CALL_OW 171
// AddComMoveXY ( belkovTeam , 122 , 43 ) ;
10558: LD_EXP 73
10562: PPUSH
10563: LD_INT 122
10565: PPUSH
10566: LD_INT 43
10568: PPUSH
10569: CALL_OW 171
// AddComMoveXY ( belkovTeam , 129 , 32 ) ;
10573: LD_EXP 73
10577: PPUSH
10578: LD_INT 129
10580: PPUSH
10581: LD_INT 32
10583: PPUSH
10584: CALL_OW 171
// AddComMoveXY ( belkovTeam , 132 , 22 ) ;
10588: LD_EXP 73
10592: PPUSH
10593: LD_INT 132
10595: PPUSH
10596: LD_INT 22
10598: PPUSH
10599: CALL_OW 171
// wait ( 0 0$8 ) ;
10603: LD_INT 280
10605: PPUSH
10606: CALL_OW 67
// CenterNowOnUnits ( Kurin ) ;
10610: LD_EXP 67
10614: PPUSH
10615: CALL_OW 87
// Say ( Kurin , D10-Kur-2b ) ;
10619: LD_EXP 67
10623: PPUSH
10624: LD_STRING D10-Kur-2b
10626: PPUSH
10627: CALL_OW 88
// InGameOff ;
10631: CALL_OW 9
// ChangeMissionObjectives ( M4 ) ;
10635: LD_STRING M4
10637: PPUSH
10638: CALL_OW 337
// backToBeria1 = true ;
10642: LD_ADDR_EXP 15
10646: PUSH
10647: LD_INT 1
10649: ST_TO_ADDR
// end ;
10650: PPOPN 3
10652: END
// every 0 0$1 trigger FilterUnitsInArea ( KirovBaseArea , [ [ f_side , 3 ] , [ f_type , unit_vehicle ] ] ) and vehicleForKurin do
10653: LD_INT 9
10655: PPUSH
10656: LD_INT 22
10658: PUSH
10659: LD_INT 3
10661: PUSH
10662: EMPTY
10663: LIST
10664: LIST
10665: PUSH
10666: LD_INT 21
10668: PUSH
10669: LD_INT 2
10671: PUSH
10672: EMPTY
10673: LIST
10674: LIST
10675: PUSH
10676: EMPTY
10677: LIST
10678: LIST
10679: PPUSH
10680: CALL_OW 70
10684: PUSH
10685: LD_EXP 14
10689: AND
10690: IFFALSE 10707
10692: GO 10694
10694: DISABLE
// Say ( Kurin , D1a-Kur-1a ) ;
10695: LD_EXP 67
10699: PPUSH
10700: LD_STRING D1a-Kur-1a
10702: PPUSH
10703: CALL_OW 88
10707: END
// every 1 trigger canRemoveBelkovUnits do var unit , driver ;
10708: LD_EXP 22
10712: IFFALSE 11115
10714: GO 10716
10716: DISABLE
10717: LD_INT 0
10719: PPUSH
10720: PPUSH
// begin enable ;
10721: ENABLE
// if FilterUnitsInArea ( BelkovExitArea , [ f_side , 6 ] ) = 0 then
10722: LD_INT 10
10724: PPUSH
10725: LD_INT 22
10727: PUSH
10728: LD_INT 6
10730: PUSH
10731: EMPTY
10732: LIST
10733: LIST
10734: PPUSH
10735: CALL_OW 70
10739: PUSH
10740: LD_INT 0
10742: EQUAL
10743: IFFALSE 10747
// exit ;
10745: GO 11115
// for unit in FilterUnitsInArea ( BelkovExitArea , [ f_side , 6 ] ) do
10747: LD_ADDR_VAR 0 1
10751: PUSH
10752: LD_INT 10
10754: PPUSH
10755: LD_INT 22
10757: PUSH
10758: LD_INT 6
10760: PUSH
10761: EMPTY
10762: LIST
10763: LIST
10764: PPUSH
10765: CALL_OW 70
10769: PUSH
10770: FOR_IN
10771: IFFALSE 11101
// begin if GetType ( unit ) = unit_human and ( not unit = Belkov and not unit = Belkov2 and not unit = Kirilenkova ) then
10773: LD_VAR 0 1
10777: PPUSH
10778: CALL_OW 247
10782: PUSH
10783: LD_INT 1
10785: EQUAL
10786: PUSH
10787: LD_VAR 0 1
10791: PUSH
10792: LD_EXP 64
10796: EQUAL
10797: NOT
10798: PUSH
10799: LD_VAR 0 1
10803: PUSH
10804: LD_EXP 68
10808: EQUAL
10809: NOT
10810: AND
10811: PUSH
10812: LD_VAR 0 1
10816: PUSH
10817: LD_EXP 65
10821: EQUAL
10822: NOT
10823: AND
10824: AND
10825: IFFALSE 10866
// begin removedBelkovUntis = removedBelkovUntis + 1 ;
10827: LD_ADDR_EXP 23
10831: PUSH
10832: LD_EXP 23
10836: PUSH
10837: LD_INT 1
10839: PLUS
10840: ST_TO_ADDR
// removedBelkovUntisSaved = removedBelkovUntisSaved ^ unit ;
10841: LD_ADDR_EXP 74
10845: PUSH
10846: LD_EXP 74
10850: PUSH
10851: LD_VAR 0 1
10855: ADD
10856: ST_TO_ADDR
// RemoveUnit ( unit ) ;
10857: LD_VAR 0 1
10861: PPUSH
10862: CALL_OW 64
// end ; if unit = Kirilenkova then
10866: LD_VAR 0 1
10870: PUSH
10871: LD_EXP 65
10875: EQUAL
10876: IFFALSE 10899
// begin SaveCharacters ( Kirilenkova , 02_TmpKirilenkova ) ;
10878: LD_EXP 65
10882: PPUSH
10883: LD_STRING 02_TmpKirilenkova
10885: PPUSH
10886: CALL_OW 38
// RemoveUnit ( unit ) ;
10890: LD_VAR 0 1
10894: PPUSH
10895: CALL_OW 64
// end ; if unit = Belkov2 then
10899: LD_VAR 0 1
10903: PUSH
10904: LD_EXP 68
10908: EQUAL
10909: IFFALSE 10932
// begin SaveCharacters ( Belkov2 , 02_TmpBelkov2 ) ;
10911: LD_EXP 68
10915: PPUSH
10916: LD_STRING 02_TmpBelkov2
10918: PPUSH
10919: CALL_OW 38
// RemoveUnit ( unit ) ;
10923: LD_VAR 0 1
10927: PPUSH
10928: CALL_OW 64
// end ; if GetType ( unit ) = unit_vehicle then
10932: LD_VAR 0 1
10936: PPUSH
10937: CALL_OW 247
10941: PUSH
10942: LD_INT 2
10944: EQUAL
10945: IFFALSE 11099
// begin driver = UnitsInside ( unit ) ;
10947: LD_ADDR_VAR 0 2
10951: PUSH
10952: LD_VAR 0 1
10956: PPUSH
10957: CALL_OW 313
10961: ST_TO_ADDR
// if driver [ 1 ] = Belkov then
10962: LD_VAR 0 2
10966: PUSH
10967: LD_INT 1
10969: ARRAY
10970: PUSH
10971: LD_EXP 64
10975: EQUAL
10976: IFFALSE 11001
// begin SaveCharacters ( Belkov , 02_TmpBelkov ) ;
10978: LD_EXP 64
10982: PPUSH
10983: LD_STRING 02_TmpBelkov
10985: PPUSH
10986: CALL_OW 38
// RemoveUnit ( unit ) ;
10990: LD_VAR 0 1
10994: PPUSH
10995: CALL_OW 64
// end else
10999: GO 11022
// begin SaveCharacters ( Belkov2 , 02_TmpBelkov2 ) ;
11001: LD_EXP 68
11005: PPUSH
11006: LD_STRING 02_TmpBelkov2
11008: PPUSH
11009: CALL_OW 38
// RemoveUnit ( unit ) ;
11013: LD_VAR 0 1
11017: PPUSH
11018: CALL_OW 64
// end ; removedBelkovVehicleSaved = removedBelkovVehicleSaved ^ [ GetChassis ( unit ) , GetEngine ( unit ) , GetControl ( unit ) , GetWeapon ( unit ) , GetFuel ( unit ) ] ;
11022: LD_ADDR_EXP 75
11026: PUSH
11027: LD_EXP 75
11031: PUSH
11032: LD_VAR 0 1
11036: PPUSH
11037: CALL_OW 265
11041: PUSH
11042: LD_VAR 0 1
11046: PPUSH
11047: CALL_OW 262
11051: PUSH
11052: LD_VAR 0 1
11056: PPUSH
11057: CALL_OW 263
11061: PUSH
11062: LD_VAR 0 1
11066: PPUSH
11067: CALL_OW 264
11071: PUSH
11072: LD_VAR 0 1
11076: PPUSH
11077: CALL_OW 261
11081: PUSH
11082: EMPTY
11083: LIST
11084: LIST
11085: LIST
11086: LIST
11087: LIST
11088: ADD
11089: ST_TO_ADDR
// RemoveUnit ( unit ) ;
11090: LD_VAR 0 1
11094: PPUSH
11095: CALL_OW 64
// end ; end ;
11099: GO 10770
11101: POP
11102: POP
// SaveCharacters ( removedBelkovUntisSaved , 02_TmpBelkovTeam ) ;
11103: LD_EXP 74
11107: PPUSH
11108: LD_STRING 02_TmpBelkovTeam
11110: PPUSH
11111: CALL_OW 38
// end ;
11115: PPOPN 2
11117: END
// every 0 0$1 trigger FilterUnitsExceptArea ( BeriaBaseArea , [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) = 0 and backToBeria1 do var engs ;
11118: LD_INT 8
11120: PPUSH
11121: LD_INT 22
11123: PUSH
11124: LD_INT 3
11126: PUSH
11127: EMPTY
11128: LIST
11129: LIST
11130: PUSH
11131: LD_INT 21
11133: PUSH
11134: LD_INT 1
11136: PUSH
11137: EMPTY
11138: LIST
11139: LIST
11140: PUSH
11141: EMPTY
11142: LIST
11143: LIST
11144: PPUSH
11145: CALL_OW 71
11149: PUSH
11150: LD_INT 0
11152: EQUAL
11153: PUSH
11154: LD_EXP 15
11158: AND
11159: IFFALSE 11366
11161: GO 11163
11163: DISABLE
11164: LD_INT 0
11166: PPUSH
// begin engs = UnitFilter ( otherKirovUnits , [ f_class , class_engineer ] ) ;
11167: LD_ADDR_VAR 0 1
11171: PUSH
11172: LD_EXP 69
11176: PPUSH
11177: LD_INT 25
11179: PUSH
11180: LD_INT 2
11182: PUSH
11183: EMPTY
11184: LIST
11185: LIST
11186: PPUSH
11187: CALL_OW 72
11191: ST_TO_ADDR
// backToBeria1 = false ;
11192: LD_ADDR_EXP 15
11196: PUSH
11197: LD_INT 0
11199: ST_TO_ADDR
// canExitBase = false ;
11200: LD_ADDR_EXP 19
11204: PUSH
11205: LD_INT 0
11207: ST_TO_ADDR
// Say ( Platonov , D11-Pla-1 ) ;
11208: LD_EXP 76
11212: PPUSH
11213: LD_STRING D11-Pla-1
11215: PPUSH
11216: CALL_OW 88
// if FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) > 1 then
11220: LD_INT 22
11222: PUSH
11223: LD_INT 3
11225: PUSH
11226: EMPTY
11227: LIST
11228: LIST
11229: PUSH
11230: LD_INT 21
11232: PUSH
11233: LD_INT 1
11235: PUSH
11236: EMPTY
11237: LIST
11238: LIST
11239: PUSH
11240: EMPTY
11241: LIST
11242: LIST
11243: PPUSH
11244: CALL_OW 69
11248: PUSH
11249: LD_INT 1
11251: GREATER
11252: IFFALSE 11268
// Say ( Burlak , D11-Bur-1a ) else
11254: LD_EXP 62
11258: PPUSH
11259: LD_STRING D11-Bur-1a
11261: PPUSH
11262: CALL_OW 88
11266: GO 11280
// Say ( Burlak , D11-Bur-1 ) ;
11268: LD_EXP 62
11272: PPUSH
11273: LD_STRING D11-Bur-1
11275: PPUSH
11276: CALL_OW 88
// ChangeMissionObjectives ( M5 ) ;
11280: LD_STRING M5
11282: PPUSH
11283: CALL_OW 337
// CreateCratesArea ( rand ( 1 , 5 ) , CratesArea , true ) ;
11287: LD_INT 1
11289: PPUSH
11290: LD_INT 5
11292: PPUSH
11293: CALL_OW 12
11297: PPUSH
11298: LD_INT 26
11300: PPUSH
11301: LD_INT 1
11303: PPUSH
11304: CALL_OW 55
// construcMoreVehicles = true ;
11308: LD_ADDR_EXP 17
11312: PUSH
11313: LD_INT 1
11315: ST_TO_ADDR
// spawnCrates = true ;
11316: LD_ADDR_EXP 21
11320: PUSH
11321: LD_INT 1
11323: ST_TO_ADDR
// AddComExitBuilding ( engs ) ;
11324: LD_VAR 0 1
11328: PPUSH
11329: CALL_OW 182
// AddComBuild ( engs , b_workshop , 159 , 112 , 0 ) ;
11333: LD_VAR 0 1
11337: PPUSH
11338: LD_INT 2
11340: PPUSH
11341: LD_INT 159
11343: PPUSH
11344: LD_INT 112
11346: PPUSH
11347: LD_INT 0
11349: PPUSH
11350: CALL_OW 205
// AddComEnterUnit ( engs , kirov ) ;
11354: LD_VAR 0 1
11358: PPUSH
11359: LD_INT 71
11361: PPUSH
11362: CALL_OW 180
// end ;
11366: PPOPN 1
11368: END
// every 0 0$1 trigger constructedVehiclesCounter >= FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) do var tmpBelkov , nearRuUnit ;
11369: LD_EXP 18
11373: PUSH
11374: LD_INT 22
11376: PUSH
11377: LD_INT 3
11379: PUSH
11380: EMPTY
11381: LIST
11382: LIST
11383: PUSH
11384: LD_INT 21
11386: PUSH
11387: LD_INT 1
11389: PUSH
11390: EMPTY
11391: LIST
11392: LIST
11393: PUSH
11394: EMPTY
11395: LIST
11396: LIST
11397: PPUSH
11398: CALL_OW 69
11402: GREATEREQUAL
11403: IFFALSE 12531
11405: GO 11407
11407: DISABLE
11408: LD_INT 0
11410: PPUSH
11411: PPUSH
// begin canRemoveBelkovUnits = false ;
11412: LD_ADDR_EXP 22
11416: PUSH
11417: LD_INT 0
11419: ST_TO_ADDR
// spawnCrates = false ;
11420: LD_ADDR_EXP 21
11424: PUSH
11425: LD_INT 0
11427: ST_TO_ADDR
// ComStop ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ) ;
11428: LD_INT 22
11430: PUSH
11431: LD_INT 3
11433: PUSH
11434: EMPTY
11435: LIST
11436: LIST
11437: PUSH
11438: LD_INT 2
11440: PUSH
11441: LD_INT 21
11443: PUSH
11444: LD_INT 1
11446: PUSH
11447: EMPTY
11448: LIST
11449: LIST
11450: PUSH
11451: LD_INT 21
11453: PUSH
11454: LD_INT 2
11456: PUSH
11457: EMPTY
11458: LIST
11459: LIST
11460: PUSH
11461: EMPTY
11462: LIST
11463: LIST
11464: LIST
11465: PUSH
11466: EMPTY
11467: LIST
11468: LIST
11469: PPUSH
11470: CALL_OW 69
11474: PPUSH
11475: CALL_OW 141
// InGameOn ;
11479: CALL_OW 8
// CenterOnUnits ( Platonov ) ;
11483: LD_EXP 76
11487: PPUSH
11488: CALL_OW 85
// DialogueOn ;
11492: CALL_OW 6
// Say ( Burlak , D12-Bur-1 ) ;
11496: LD_EXP 62
11500: PPUSH
11501: LD_STRING D12-Bur-1
11503: PPUSH
11504: CALL_OW 88
// Say ( Platonov , D12-Pla-1 ) ;
11508: LD_EXP 76
11512: PPUSH
11513: LD_STRING D12-Pla-1
11515: PPUSH
11516: CALL_OW 88
// Say ( Burlak , D12-Bur-2 ) ;
11520: LD_EXP 62
11524: PPUSH
11525: LD_STRING D12-Bur-2
11527: PPUSH
11528: CALL_OW 88
// Say ( Platonov , D12-Pla-2 ) ;
11532: LD_EXP 76
11536: PPUSH
11537: LD_STRING D12-Pla-2
11539: PPUSH
11540: CALL_OW 88
// Say ( Burlak , D12-Bur-3 ) ;
11544: LD_EXP 62
11548: PPUSH
11549: LD_STRING D12-Bur-3
11551: PPUSH
11552: CALL_OW 88
// Say ( Platonov , D12-Pla-3 ) ;
11556: LD_EXP 76
11560: PPUSH
11561: LD_STRING D12-Pla-3
11563: PPUSH
11564: CALL_OW 88
// DialogueOff ;
11568: CALL_OW 7
// SetAttitude ( 6 , 1 , att_friend , true ) ;
11572: LD_INT 6
11574: PPUSH
11575: LD_INT 1
11577: PPUSH
11578: LD_INT 1
11580: PPUSH
11581: LD_INT 1
11583: PPUSH
11584: CALL_OW 80
// PrepareAmerican ;
11588: CALL 2879 0 0
// PrepareBelkovReturnTeam ;
11592: CALL 1132 0 0
// if IsOK ( Belkov ) then
11596: LD_EXP 64
11600: PPUSH
11601: CALL_OW 302
11605: IFFALSE 11619
// tmpBelkov = Belkov else
11607: LD_ADDR_VAR 0 1
11611: PUSH
11612: LD_EXP 64
11616: ST_TO_ADDR
11617: GO 11629
// tmpBelkov = Belkov2 ;
11619: LD_ADDR_VAR 0 1
11623: PUSH
11624: LD_EXP 68
11628: ST_TO_ADDR
// CenterNowOnUnits ( kirovVehicle ) ;
11629: LD_EXP 72
11633: PPUSH
11634: CALL_OW 87
// SayRadio ( trapCommander , D13-Sol1-1 ) ;
11638: LD_EXP 80
11642: PPUSH
11643: LD_STRING D13-Sol1-1
11645: PPUSH
11646: CALL_OW 94
// SayRadio ( tmpBelkov , D13-Bel-1 ) ;
11650: LD_VAR 0 1
11654: PPUSH
11655: LD_STRING D13-Bel-1
11657: PPUSH
11658: CALL_OW 94
// SayRadio ( Kurin , D13-Kur-1 ) ;
11662: LD_EXP 67
11666: PPUSH
11667: LD_STRING D13-Kur-1
11669: PPUSH
11670: CALL_OW 94
// SayRadio ( tmpBelkov , D13-Bel-2 ) ;
11674: LD_VAR 0 1
11678: PPUSH
11679: LD_STRING D13-Bel-2
11681: PPUSH
11682: CALL_OW 94
// ComMoveXY ( belkovTeam , 121 , 29 ) ;
11686: LD_EXP 73
11690: PPUSH
11691: LD_INT 121
11693: PPUSH
11694: LD_INT 29
11696: PPUSH
11697: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
11701: LD_INT 35
11703: PPUSH
11704: CALL_OW 67
// CenterNowOnUnits ( kirovVehicle ) ;
11708: LD_EXP 72
11712: PPUSH
11713: CALL_OW 87
// nearRuUnit = NearestUnitToUnit ( UnitFilter ( belkovTeam , [ [ f_type , unit_human ] , [ f_outside ] ] ) , kirovVehicle ) ;
11717: LD_ADDR_VAR 0 2
11721: PUSH
11722: LD_EXP 73
11726: PPUSH
11727: LD_INT 21
11729: PUSH
11730: LD_INT 1
11732: PUSH
11733: EMPTY
11734: LIST
11735: LIST
11736: PUSH
11737: LD_INT 56
11739: PUSH
11740: EMPTY
11741: LIST
11742: PUSH
11743: EMPTY
11744: LIST
11745: LIST
11746: PPUSH
11747: CALL_OW 72
11751: PPUSH
11752: LD_EXP 72
11756: PPUSH
11757: CALL_OW 74
11761: ST_TO_ADDR
// if GetDistUnits ( kirovVehicle , nearRuUnit ) < 5 then
11762: LD_EXP 72
11766: PPUSH
11767: LD_VAR 0 2
11771: PPUSH
11772: CALL_OW 296
11776: PUSH
11777: LD_INT 5
11779: LESS
11780: IFFALSE 11793
// ComStop ( kirovVehicle ) else
11782: LD_EXP 72
11786: PPUSH
11787: CALL_OW 141
11791: GO 11808
// ComMoveXY ( belkovTeam , 121 , 29 ) ;
11793: LD_EXP 73
11797: PPUSH
11798: LD_INT 121
11800: PPUSH
11801: LD_INT 29
11803: PPUSH
11804: CALL_OW 111
// until GetDistUnits ( NearestUnitToUnit ( belkovTeam , trapCommander ) , trapCommander ) < 5 ;
11808: LD_EXP 73
11812: PPUSH
11813: LD_EXP 80
11817: PPUSH
11818: CALL_OW 74
11822: PPUSH
11823: LD_EXP 80
11827: PPUSH
11828: CALL_OW 296
11832: PUSH
11833: LD_INT 5
11835: LESS
11836: IFFALSE 11701
// CenterNowOnUnits ( [ kirovVehicle , trapCommander ] ) ;
11838: LD_EXP 72
11842: PUSH
11843: LD_EXP 80
11847: PUSH
11848: EMPTY
11849: LIST
11850: LIST
11851: PPUSH
11852: CALL_OW 87
// ComWalk ( trapTeam ) ;
11856: LD_EXP 81
11860: PPUSH
11861: CALL_OW 138
// AddComTurnUnit ( trapTeam , kirovVehicle ) ;
11865: LD_EXP 81
11869: PPUSH
11870: LD_EXP 72
11874: PPUSH
11875: CALL_OW 179
// ComStop ( belkovTeam ) ;
11879: LD_EXP 73
11883: PPUSH
11884: CALL_OW 141
// AddComTurnUnit ( belkovTeam , trapCommander ) ;
11888: LD_EXP 73
11892: PPUSH
11893: LD_EXP 80
11897: PPUSH
11898: CALL_OW 179
// AddComMoveXY ( FilterUnitsInArea ( TrapNorthGroupArea , [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) , 111 , 13 ) ;
11902: LD_INT 25
11904: PPUSH
11905: LD_INT 22
11907: PUSH
11908: LD_INT 1
11910: PUSH
11911: EMPTY
11912: LIST
11913: LIST
11914: PUSH
11915: LD_INT 21
11917: PUSH
11918: LD_INT 1
11920: PUSH
11921: EMPTY
11922: LIST
11923: LIST
11924: PUSH
11925: EMPTY
11926: LIST
11927: LIST
11928: PPUSH
11929: CALL_OW 70
11933: PPUSH
11934: LD_INT 111
11936: PPUSH
11937: LD_INT 13
11939: PPUSH
11940: CALL_OW 171
// music_class = music_combat ;
11944: LD_ADDR_OWVAR 72
11948: PUSH
11949: LD_INT 1
11951: ST_TO_ADDR
// wait ( 0 0$1 ) ;
11952: LD_INT 35
11954: PPUSH
11955: CALL_OW 67
// DialogueOn ;
11959: CALL_OW 6
// Say ( trapCommander , D14-Sol1-1 ) ;
11963: LD_EXP 80
11967: PPUSH
11968: LD_STRING D14-Sol1-1
11970: PPUSH
11971: CALL_OW 88
// Say ( tmpBelkov , D14-Bel-1 ) ;
11975: LD_VAR 0 1
11979: PPUSH
11980: LD_STRING D14-Bel-1
11982: PPUSH
11983: CALL_OW 88
// DialogueOff ;
11987: CALL_OW 7
// immortalBelkovTeam = true ;
11991: LD_ADDR_EXP 24
11995: PUSH
11996: LD_INT 1
11998: ST_TO_ADDR
// SetAttitude ( 6 , 1 , att_enemy , true ) ;
11999: LD_INT 6
12001: PPUSH
12002: LD_INT 1
12004: PPUSH
12005: LD_INT 2
12007: PPUSH
12008: LD_INT 1
12010: PPUSH
12011: CALL_OW 80
// ComMoveXY ( belkovTeam , 107 , 5 ) ;
12015: LD_EXP 73
12019: PPUSH
12020: LD_INT 107
12022: PPUSH
12023: LD_INT 5
12025: PPUSH
12026: CALL_OW 111
// ComMoveXY ( kirovVehicle , 107 , 5 ) ;
12030: LD_EXP 72
12034: PPUSH
12035: LD_INT 107
12037: PPUSH
12038: LD_INT 5
12040: PPUSH
12041: CALL_OW 111
// wait ( 0 0$2 ) ;
12045: LD_INT 70
12047: PPUSH
12048: CALL_OW 67
// ComMoveXY ( belkovTeam , 101 , 19 ) ;
12052: LD_EXP 73
12056: PPUSH
12057: LD_INT 101
12059: PPUSH
12060: LD_INT 19
12062: PPUSH
12063: CALL_OW 111
// ComMoveXY ( kirovVehicle , 101 , 19 ) ;
12067: LD_EXP 72
12071: PPUSH
12072: LD_INT 101
12074: PPUSH
12075: LD_INT 19
12077: PPUSH
12078: CALL_OW 111
// wait ( 0 0$2 ) ;
12082: LD_INT 70
12084: PPUSH
12085: CALL_OW 67
// immortalVehLive = 400 ;
12089: LD_ADDR_EXP 25
12093: PUSH
12094: LD_INT 400
12096: ST_TO_ADDR
// SetLives ( kirovVehicle , 500 ) ;
12097: LD_EXP 72
12101: PPUSH
12102: LD_INT 500
12104: PPUSH
12105: CALL_OW 234
// wait ( 0 0$3 ) ;
12109: LD_INT 105
12111: PPUSH
12112: CALL_OW 67
// ComExitVehicle ( tmpBelkov ) ;
12116: LD_VAR 0 1
12120: PPUSH
12121: CALL_OW 121
// wait ( 0 0$1 ) ;
12125: LD_INT 35
12127: PPUSH
12128: CALL_OW 67
// ComEnterUnit ( trapCommander , kirovVehicle ) ;
12132: LD_EXP 80
12136: PPUSH
12137: LD_EXP 72
12141: PPUSH
12142: CALL_OW 120
// AddComHold ( trapTeam ) ;
12146: LD_EXP 81
12150: PPUSH
12151: CALL_OW 200
// ComMoveXY ( belkovTeam , 88 , 18 ) ;
12155: LD_EXP 73
12159: PPUSH
12160: LD_INT 88
12162: PPUSH
12163: LD_INT 18
12165: PPUSH
12166: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
12170: LD_INT 35
12172: PPUSH
12173: CALL_OW 67
// CenterNowOnUnits ( tmpBelkov ) ;
12177: LD_VAR 0 1
12181: PPUSH
12182: CALL_OW 87
// until IsInArea ( tmpBelkov , BelkovRetreatArea ) ;
12186: LD_VAR 0 1
12190: PPUSH
12191: LD_INT 15
12193: PPUSH
12194: CALL_OW 308
12198: IFFALSE 12170
// amVeh = FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_vehicle ] ] ) [ 1 ] ;
12200: LD_ADDR_EXP 88
12204: PUSH
12205: LD_INT 22
12207: PUSH
12208: LD_INT 1
12210: PUSH
12211: EMPTY
12212: LIST
12213: LIST
12214: PUSH
12215: LD_INT 21
12217: PUSH
12218: LD_INT 2
12220: PUSH
12221: EMPTY
12222: LIST
12223: LIST
12224: PUSH
12225: EMPTY
12226: LIST
12227: LIST
12228: PPUSH
12229: CALL_OW 69
12233: PUSH
12234: LD_INT 1
12236: ARRAY
12237: ST_TO_ADDR
// ComMoveXY ( FilterUnitsInArea ( NearHillArea , [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) , 113 , 29 ) ;
12238: LD_INT 28
12240: PPUSH
12241: LD_INT 22
12243: PUSH
12244: LD_INT 1
12246: PUSH
12247: EMPTY
12248: LIST
12249: LIST
12250: PUSH
12251: LD_INT 21
12253: PUSH
12254: LD_INT 1
12256: PUSH
12257: EMPTY
12258: LIST
12259: LIST
12260: PUSH
12261: EMPTY
12262: LIST
12263: LIST
12264: PPUSH
12265: CALL_OW 70
12269: PPUSH
12270: LD_INT 113
12272: PPUSH
12273: LD_INT 29
12275: PPUSH
12276: CALL_OW 111
// ComMoveXY ( amVeh , 118 , 25 ) ;
12280: LD_EXP 88
12284: PPUSH
12285: LD_INT 118
12287: PPUSH
12288: LD_INT 25
12290: PPUSH
12291: CALL_OW 111
// SayRadio ( tmpBelkov , D14-Bel-1a ) ;
12295: LD_VAR 0 1
12299: PPUSH
12300: LD_STRING D14-Bel-1a
12302: PPUSH
12303: CALL_OW 94
// SayRadio ( Kurin , D14-Kur-1 ) ;
12307: LD_EXP 67
12311: PPUSH
12312: LD_STRING D14-Kur-1
12314: PPUSH
12315: CALL_OW 94
// SayRadio ( tmpBelkov , D14-Bel-2 ) ;
12319: LD_VAR 0 1
12323: PPUSH
12324: LD_STRING D14-Bel-2
12326: PPUSH
12327: CALL_OW 94
// SayRadio ( Kurin , D14-Kur-2 ) ;
12331: LD_EXP 67
12335: PPUSH
12336: LD_STRING D14-Kur-2
12338: PPUSH
12339: CALL_OW 94
// CenterOnUnits ( Platonov ) ;
12343: LD_EXP 76
12347: PPUSH
12348: CALL_OW 85
// wait ( 0 0$2 ) ;
12352: LD_INT 70
12354: PPUSH
12355: CALL_OW 67
// Say ( Burlak , D14a-Bur-1 ) ;
12359: LD_EXP 62
12363: PPUSH
12364: LD_STRING D14a-Bur-1
12366: PPUSH
12367: CALL_OW 88
// Say ( Platonov , D14a-Pla-1 ) ;
12371: LD_EXP 76
12375: PPUSH
12376: LD_STRING D14a-Pla-1
12378: PPUSH
12379: CALL_OW 88
// Say ( Burlak , D14a-Bur-2 ) ;
12383: LD_EXP 62
12387: PPUSH
12388: LD_STRING D14a-Bur-2
12390: PPUSH
12391: CALL_OW 88
// Say ( Platonov , D14a-Pla-2 ) ;
12395: LD_EXP 76
12399: PPUSH
12400: LD_STRING D14a-Pla-2
12402: PPUSH
12403: CALL_OW 88
// Say ( Burlak , D14a-Bur-3 ) ;
12407: LD_EXP 62
12411: PPUSH
12412: LD_STRING D14a-Bur-3
12414: PPUSH
12415: CALL_OW 88
// Say ( Platonov , D14a-Pla-3 ) ;
12419: LD_EXP 76
12423: PPUSH
12424: LD_STRING D14a-Pla-3
12426: PPUSH
12427: CALL_OW 88
// Say ( Burlak , D14a-Bur-4 ) ;
12431: LD_EXP 62
12435: PPUSH
12436: LD_STRING D14a-Bur-4
12438: PPUSH
12439: CALL_OW 88
// Say ( Platonov , D14a-Pla-4 ) ;
12443: LD_EXP 76
12447: PPUSH
12448: LD_STRING D14a-Pla-4
12450: PPUSH
12451: CALL_OW 88
// InGameOff ;
12455: CALL_OW 9
// immortalBelkovTeam = false ;
12459: LD_ADDR_EXP 24
12463: PUSH
12464: LD_INT 0
12466: ST_TO_ADDR
// activateAMAI = true ;
12467: LD_ADDR_EXP 27
12471: PUSH
12472: LD_INT 1
12474: ST_TO_ADDR
// canExitBase = true ;
12475: LD_ADDR_EXP 19
12479: PUSH
12480: LD_INT 1
12482: ST_TO_ADDR
// canExploreMap = true ;
12483: LD_ADDR_EXP 20
12487: PUSH
12488: LD_INT 1
12490: ST_TO_ADDR
// construcMoreVehicles = false ;
12491: LD_ADDR_EXP 17
12495: PUSH
12496: LD_INT 0
12498: ST_TO_ADDR
// activateBelkovAI = true ;
12499: LD_ADDR_EXP 28
12503: PUSH
12504: LD_INT 1
12506: ST_TO_ADDR
// ChangeMissionObjectives ( M6 ) ;
12507: LD_STRING M6
12509: PPUSH
12510: CALL_OW 337
// music_class = 0 ;
12514: LD_ADDR_OWVAR 72
12518: PUSH
12519: LD_INT 0
12521: ST_TO_ADDR
// ComFree ( trapTeam ) ;
12522: LD_EXP 81
12526: PPUSH
12527: CALL_OW 139
// end ;
12531: PPOPN 2
12533: END
// every 0 0$1 trigger GetDistUnitXY ( amVeh , 118 , 25 ) < 6 do
12534: LD_EXP 88
12538: PPUSH
12539: LD_INT 118
12541: PPUSH
12542: LD_INT 25
12544: PPUSH
12545: CALL_OW 297
12549: PUSH
12550: LD_INT 6
12552: LESS
12553: IFFALSE 12648
12555: GO 12557
12557: DISABLE
// begin ComExitVehicle ( trapCommander ) ;
12558: LD_EXP 80
12562: PPUSH
12563: CALL_OW 121
// uc_side = 1 ;
12567: LD_ADDR_OWVAR 20
12571: PUSH
12572: LD_INT 1
12574: ST_TO_ADDR
// uc_nation = 1 ;
12575: LD_ADDR_OWVAR 21
12579: PUSH
12580: LD_INT 1
12582: ST_TO_ADDR
// PrepareMechanic ( 0 , enemySkillLevel ) ;
12583: LD_INT 0
12585: PPUSH
12586: LD_EXP 59
12590: PPUSH
12591: CALL_OW 383
// amMech = CreateHuman ;
12595: LD_ADDR_EXP 89
12599: PUSH
12600: CALL_OW 44
12604: ST_TO_ADDR
// PlaceUnitArea ( amMech , AmMechSpawnArea , false ) ;
12605: LD_EXP 89
12609: PPUSH
12610: LD_INT 27
12612: PPUSH
12613: LD_INT 0
12615: PPUSH
12616: CALL_OW 49
// ComRepairVehicle ( amMech , amVeh ) ;
12620: LD_EXP 89
12624: PPUSH
12625: LD_EXP 88
12629: PPUSH
12630: CALL_OW 129
// AddComEnterUnit ( amMech , amVeh ) ;
12634: LD_EXP 89
12638: PPUSH
12639: LD_EXP 88
12643: PPUSH
12644: CALL_OW 180
// end ;
12648: END
// every 0 0$1 trigger IsOK ( amMech ) and FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_vehicle ] , [ f_ok ] ] ) do var nearUnit ;
12649: LD_EXP 89
12653: PPUSH
12654: CALL_OW 302
12658: PUSH
12659: LD_INT 22
12661: PUSH
12662: LD_INT 1
12664: PUSH
12665: EMPTY
12666: LIST
12667: LIST
12668: PUSH
12669: LD_INT 21
12671: PUSH
12672: LD_INT 2
12674: PUSH
12675: EMPTY
12676: LIST
12677: LIST
12678: PUSH
12679: LD_INT 50
12681: PUSH
12682: EMPTY
12683: LIST
12684: PUSH
12685: EMPTY
12686: LIST
12687: LIST
12688: LIST
12689: PPUSH
12690: CALL_OW 69
12694: AND
12695: IFFALSE 12948
12697: GO 12699
12699: DISABLE
12700: LD_INT 0
12702: PPUSH
// begin enable ;
12703: ENABLE
// nearUnit = NearestUnitToUnit ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) , amMech ) ;
12704: LD_ADDR_VAR 0 1
12708: PUSH
12709: LD_INT 22
12711: PUSH
12712: LD_INT 3
12714: PUSH
12715: EMPTY
12716: LIST
12717: LIST
12718: PUSH
12719: LD_INT 2
12721: PUSH
12722: LD_INT 21
12724: PUSH
12725: LD_INT 1
12727: PUSH
12728: EMPTY
12729: LIST
12730: LIST
12731: PUSH
12732: LD_INT 21
12734: PUSH
12735: LD_INT 2
12737: PUSH
12738: EMPTY
12739: LIST
12740: LIST
12741: PUSH
12742: EMPTY
12743: LIST
12744: LIST
12745: LIST
12746: PUSH
12747: EMPTY
12748: LIST
12749: LIST
12750: PPUSH
12751: CALL_OW 69
12755: PPUSH
12756: LD_EXP 89
12760: PPUSH
12761: CALL_OW 74
12765: ST_TO_ADDR
// if GetDistUnits ( nearUnit , amMech ) < 13 then
12766: LD_VAR 0 1
12770: PPUSH
12771: LD_EXP 89
12775: PPUSH
12776: CALL_OW 296
12780: PUSH
12781: LD_INT 13
12783: LESS
12784: IFFALSE 12837
// ComEnterUnit ( amMech , FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_vehicle ] , [ f_ok ] ] ) [ 1 ] ) else
12786: LD_EXP 89
12790: PPUSH
12791: LD_INT 22
12793: PUSH
12794: LD_INT 1
12796: PUSH
12797: EMPTY
12798: LIST
12799: LIST
12800: PUSH
12801: LD_INT 21
12803: PUSH
12804: LD_INT 2
12806: PUSH
12807: EMPTY
12808: LIST
12809: LIST
12810: PUSH
12811: LD_INT 50
12813: PUSH
12814: EMPTY
12815: LIST
12816: PUSH
12817: EMPTY
12818: LIST
12819: LIST
12820: LIST
12821: PPUSH
12822: CALL_OW 69
12826: PUSH
12827: LD_INT 1
12829: ARRAY
12830: PPUSH
12831: CALL_OW 120
12835: GO 12948
// begin if GetLives ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_vehicle ] , [ f_ok ] ] ) [ 1 ] ) = 1000 and not IsInUnit ( amMech ) then
12837: LD_INT 22
12839: PUSH
12840: LD_INT 1
12842: PUSH
12843: EMPTY
12844: LIST
12845: LIST
12846: PUSH
12847: LD_INT 21
12849: PUSH
12850: LD_INT 2
12852: PUSH
12853: EMPTY
12854: LIST
12855: LIST
12856: PUSH
12857: LD_INT 50
12859: PUSH
12860: EMPTY
12861: LIST
12862: PUSH
12863: EMPTY
12864: LIST
12865: LIST
12866: LIST
12867: PPUSH
12868: CALL_OW 69
12872: PUSH
12873: LD_INT 1
12875: ARRAY
12876: PPUSH
12877: CALL_OW 256
12881: PUSH
12882: LD_INT 1000
12884: EQUAL
12885: PUSH
12886: LD_EXP 89
12890: PPUSH
12891: CALL_OW 310
12895: NOT
12896: AND
12897: IFFALSE 12948
// ComEnterUnit ( amMech , FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_vehicle ] , [ f_ok ] ] ) [ 1 ] ) ;
12899: LD_EXP 89
12903: PPUSH
12904: LD_INT 22
12906: PUSH
12907: LD_INT 1
12909: PUSH
12910: EMPTY
12911: LIST
12912: LIST
12913: PUSH
12914: LD_INT 21
12916: PUSH
12917: LD_INT 2
12919: PUSH
12920: EMPTY
12921: LIST
12922: LIST
12923: PUSH
12924: LD_INT 50
12926: PUSH
12927: EMPTY
12928: LIST
12929: PUSH
12930: EMPTY
12931: LIST
12932: LIST
12933: LIST
12934: PPUSH
12935: CALL_OW 69
12939: PUSH
12940: LD_INT 1
12942: ARRAY
12943: PPUSH
12944: CALL_OW 120
// end ; end ;
12948: PPOPN 1
12950: END
// every 0 0$1 trigger immortalBelkovTeam do
12951: LD_EXP 24
12955: IFFALSE 13042
12957: GO 12959
12959: DISABLE
// begin enable ;
12960: ENABLE
// SetLives ( UnitFilter ( belkovTeam , [ f_type , unit_human ] ) , 1000 ) ;
12961: LD_EXP 73
12965: PPUSH
12966: LD_INT 21
12968: PUSH
12969: LD_INT 1
12971: PUSH
12972: EMPTY
12973: LIST
12974: LIST
12975: PPUSH
12976: CALL_OW 72
12980: PPUSH
12981: LD_INT 1000
12983: PPUSH
12984: CALL_OW 234
// if UnitFilter ( belkovTeam , [ f_type , unit_vehicle ] ) then
12988: LD_EXP 73
12992: PPUSH
12993: LD_INT 21
12995: PUSH
12996: LD_INT 2
12998: PUSH
12999: EMPTY
13000: LIST
13001: LIST
13002: PPUSH
13003: CALL_OW 72
13007: IFFALSE 13042
// SetLives ( UnitFilter ( belkovTeam , [ f_type , unit_vehicle ] ) [ 1 ] , immortalVehLive ) ;
13009: LD_EXP 73
13013: PPUSH
13014: LD_INT 21
13016: PUSH
13017: LD_INT 2
13019: PUSH
13020: EMPTY
13021: LIST
13022: LIST
13023: PPUSH
13024: CALL_OW 72
13028: PUSH
13029: LD_INT 1
13031: ARRAY
13032: PPUSH
13033: LD_EXP 25
13037: PPUSH
13038: CALL_OW 234
// end ;
13042: END
// every 0 0$1 trigger canExploreMap and not belkovSaved and belkovAttackTime > 0 0$00 do
13043: LD_EXP 20
13047: PUSH
13048: LD_EXP 37
13052: NOT
13053: AND
13054: PUSH
13055: LD_EXP 61
13059: PUSH
13060: LD_INT 0
13062: GREATER
13063: AND
13064: IFFALSE 13084
13066: GO 13068
13068: DISABLE
// begin enable ;
13069: ENABLE
// belkovAttackTime = belkovAttackTime - 0 0$01 ;
13070: LD_ADDR_EXP 61
13074: PUSH
13075: LD_EXP 61
13079: PUSH
13080: LD_INT 35
13082: MINUS
13083: ST_TO_ADDR
// end ;
13084: END
// every 0 0$15 trigger canExploreMap do var i , tmp ;
13085: LD_EXP 20
13089: IFFALSE 13173
13091: GO 13093
13093: DISABLE
13094: LD_INT 0
13096: PPUSH
13097: PPUSH
// begin tmp = trapTeam ;
13098: LD_ADDR_VAR 0 2
13102: PUSH
13103: LD_EXP 81
13107: ST_TO_ADDR
// tmp = tmp diff trapCommander ;
13108: LD_ADDR_VAR 0 2
13112: PUSH
13113: LD_VAR 0 2
13117: PUSH
13118: LD_EXP 80
13122: DIFF
13123: ST_TO_ADDR
// for i := 1 to rand ( 2 , 3 ) do
13124: LD_ADDR_VAR 0 1
13128: PUSH
13129: DOUBLE
13130: LD_INT 1
13132: DEC
13133: ST_TO_ADDR
13134: LD_INT 2
13136: PPUSH
13137: LD_INT 3
13139: PPUSH
13140: CALL_OW 12
13144: PUSH
13145: FOR_TO
13146: IFFALSE 13171
// ComAgressiveMove ( tmp [ i ] , 87 , 18 ) ;
13148: LD_VAR 0 2
13152: PUSH
13153: LD_VAR 0 1
13157: ARRAY
13158: PPUSH
13159: LD_INT 87
13161: PPUSH
13162: LD_INT 18
13164: PPUSH
13165: CALL_OW 114
13169: GO 13145
13171: POP
13172: POP
// end ;
13173: PPOPN 2
13175: END
// every 0 0$1 trigger belkovAttackTime < 0 0$02 and trapTeam do
13176: LD_EXP 61
13180: PUSH
13181: LD_INT 70
13183: LESS
13184: PUSH
13185: LD_EXP 81
13189: AND
13190: IFFALSE 13219
13192: GO 13194
13194: DISABLE
// begin enable ;
13195: ENABLE
// activateBelkovAI = false ;
13196: LD_ADDR_EXP 28
13200: PUSH
13201: LD_INT 0
13203: ST_TO_ADDR
// ComAgressiveMove ( belkovTeam , 120 , 28 ) ;
13204: LD_EXP 73
13208: PPUSH
13209: LD_INT 120
13211: PPUSH
13212: LD_INT 28
13214: PPUSH
13215: CALL_OW 114
// end ;
13219: END
// every 0 0$1 trigger ( not sawLeftBunker or not sawRightBunker ) and canExploreMap do var bunker ;
13220: LD_EXP 29
13224: NOT
13225: PUSH
13226: LD_EXP 30
13230: NOT
13231: OR
13232: PUSH
13233: LD_EXP 20
13237: AND
13238: IFFALSE 13700
13240: GO 13242
13242: DISABLE
13243: LD_INT 0
13245: PPUSH
// begin enable ;
13246: ENABLE
// for bunker in FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_building ] , [ f_btype , b_breastwork ] ] ) do
13247: LD_ADDR_VAR 0 1
13251: PUSH
13252: LD_INT 22
13254: PUSH
13255: LD_INT 1
13257: PUSH
13258: EMPTY
13259: LIST
13260: LIST
13261: PUSH
13262: LD_INT 21
13264: PUSH
13265: LD_INT 3
13267: PUSH
13268: EMPTY
13269: LIST
13270: LIST
13271: PUSH
13272: LD_INT 30
13274: PUSH
13275: LD_INT 31
13277: PUSH
13278: EMPTY
13279: LIST
13280: LIST
13281: PUSH
13282: EMPTY
13283: LIST
13284: LIST
13285: LIST
13286: PPUSH
13287: CALL_OW 69
13291: PUSH
13292: FOR_IN
13293: IFFALSE 13698
// begin if See ( 3 , bunker ) then
13295: LD_INT 3
13297: PPUSH
13298: LD_VAR 0 1
13302: PPUSH
13303: CALL_OW 292
13307: IFFALSE 13696
// begin if bunker in leftBunkers and not sawLeftBunker and not FilterUnitsInArea ( WeakPositionArea , [ [ f_side , 3 ] ] ) then
13309: LD_VAR 0 1
13313: PUSH
13314: LD_EXP 82
13318: IN
13319: PUSH
13320: LD_EXP 29
13324: NOT
13325: AND
13326: PUSH
13327: LD_INT 18
13329: PPUSH
13330: LD_INT 22
13332: PUSH
13333: LD_INT 3
13335: PUSH
13336: EMPTY
13337: LIST
13338: LIST
13339: PUSH
13340: EMPTY
13341: LIST
13342: PPUSH
13343: CALL_OW 70
13347: NOT
13348: AND
13349: IFFALSE 13542
// begin sawLeftBunker = true ;
13351: LD_ADDR_EXP 29
13355: PUSH
13356: LD_INT 1
13358: ST_TO_ADDR
// CenterOnUnits ( bunker ) ;
13359: LD_VAR 0 1
13363: PPUSH
13364: CALL_OW 85
// DialogueOn ;
13368: CALL_OW 6
// Say ( Burlak , D15-Bur-1 ) ;
13372: LD_EXP 62
13376: PPUSH
13377: LD_STRING D15-Bur-1
13379: PPUSH
13380: CALL_OW 88
// if IsOK ( Gnyevko ) or IsOK ( Kovalyuk ) then
13384: LD_EXP 63
13388: PPUSH
13389: CALL_OW 302
13393: PUSH
13394: LD_EXP 70
13398: PPUSH
13399: CALL_OW 302
13403: OR
13404: IFFALSE 13499
// begin if IsOK ( Gnyevko ) then
13406: LD_EXP 63
13410: PPUSH
13411: CALL_OW 302
13415: IFFALSE 13429
// Say ( Gnyevko , D15-Gny-1 ) ;
13417: LD_EXP 63
13421: PPUSH
13422: LD_STRING D15-Gny-1
13424: PPUSH
13425: CALL_OW 88
// if IsOK ( Kovalyuk ) then
13429: LD_EXP 70
13433: PPUSH
13434: CALL_OW 302
13438: IFFALSE 13452
// Say ( Kovalyuk , D15-Kov-1 ) ;
13440: LD_EXP 70
13444: PPUSH
13445: LD_STRING D15-Kov-1
13447: PPUSH
13448: CALL_OW 88
// Say ( Burlak , D15-Bur-2 ) ;
13452: LD_EXP 62
13456: PPUSH
13457: LD_STRING D15-Bur-2
13459: PPUSH
13460: CALL_OW 88
// if IsOK ( Kovalyuk ) then
13464: LD_EXP 70
13468: PPUSH
13469: CALL_OW 302
13473: IFFALSE 13487
// Say ( Kovalyuk , D15-Kov-2 ) ;
13475: LD_EXP 70
13479: PPUSH
13480: LD_STRING D15-Kov-2
13482: PPUSH
13483: CALL_OW 88
// Say ( Burlak , D15-Bur-3 ) ;
13487: LD_EXP 62
13491: PPUSH
13492: LD_STRING D15-Bur-3
13494: PPUSH
13495: CALL_OW 88
// end ; DialogueOff ;
13499: CALL_OW 7
// if raportForPlatonov = 2 then
13503: LD_EXP 39
13507: PUSH
13508: LD_INT 2
13510: EQUAL
13511: IFFALSE 13523
// raportForPlatonov = 1 else
13513: LD_ADDR_EXP 39
13517: PUSH
13518: LD_INT 1
13520: ST_TO_ADDR
13521: GO 13531
// raportForPlatonov = 3 ;
13523: LD_ADDR_EXP 39
13527: PUSH
13528: LD_INT 3
13530: ST_TO_ADDR
// ChangeMissionObjectives ( M7 ) ;
13531: LD_STRING M7
13533: PPUSH
13534: CALL_OW 337
// exit ;
13538: POP
13539: POP
13540: GO 13700
// end ; if bunker in rightBunkers and not sawRightBunker then
13542: LD_VAR 0 1
13546: PUSH
13547: LD_EXP 83
13551: IN
13552: PUSH
13553: LD_EXP 30
13557: NOT
13558: AND
13559: IFFALSE 13696
// begin sawRightBunker = true ;
13561: LD_ADDR_EXP 30
13565: PUSH
13566: LD_INT 1
13568: ST_TO_ADDR
// CenterOnUnits ( bunker ) ;
13569: LD_VAR 0 1
13573: PPUSH
13574: CALL_OW 85
// DialogueOn ;
13578: CALL_OW 6
// if IsOK ( Kovalyuk ) then
13582: LD_EXP 70
13586: PPUSH
13587: CALL_OW 302
13591: IFFALSE 13660
// begin if sawLeftBunker then
13593: LD_EXP 29
13597: IFFALSE 13613
// Say ( Kovalyuk , D16-Kov-1a ) else
13599: LD_EXP 70
13603: PPUSH
13604: LD_STRING D16-Kov-1a
13606: PPUSH
13607: CALL_OW 88
13611: GO 13625
// Say ( Kovalyuk , D16-Kov-1 ) ;
13613: LD_EXP 70
13617: PPUSH
13618: LD_STRING D16-Kov-1
13620: PPUSH
13621: CALL_OW 88
// Say ( Burlak , D16-Bur-1 ) ;
13625: LD_EXP 62
13629: PPUSH
13630: LD_STRING D16-Bur-1
13632: PPUSH
13633: CALL_OW 88
// if IsOK ( Gnyevko ) then
13637: LD_EXP 63
13641: PPUSH
13642: CALL_OW 302
13646: IFFALSE 13660
// Say ( Gnyevko , D16-Gny-1 ) ;
13648: LD_EXP 63
13652: PPUSH
13653: LD_STRING D16-Gny-1
13655: PPUSH
13656: CALL_OW 88
// end ; DialogueOff ;
13660: CALL_OW 7
// if raportForPlatonov = 3 then
13664: LD_EXP 39
13668: PUSH
13669: LD_INT 3
13671: EQUAL
13672: IFFALSE 13684
// raportForPlatonov = 1 else
13674: LD_ADDR_EXP 39
13678: PUSH
13679: LD_INT 1
13681: ST_TO_ADDR
13682: GO 13692
// raportForPlatonov = 2 ;
13684: LD_ADDR_EXP 39
13688: PUSH
13689: LD_INT 2
13691: ST_TO_ADDR
// exit ;
13692: POP
13693: POP
13694: GO 13700
// end ; end ; end ;
13696: GO 13292
13698: POP
13699: POP
// end ;
13700: PPOPN 1
13702: END
// every 0 0$2 trigger not dialogAttackRightBunkers and rightBunkers and canExploreMap and ( IsOK ( Kovalyuk ) or IsOK ( Gnyevko ) ) do var unit ;
13703: LD_EXP 32
13707: NOT
13708: PUSH
13709: LD_EXP 83
13713: AND
13714: PUSH
13715: LD_EXP 20
13719: AND
13720: PUSH
13721: LD_EXP 70
13725: PPUSH
13726: CALL_OW 302
13730: PUSH
13731: LD_EXP 63
13735: PPUSH
13736: CALL_OW 302
13740: OR
13741: AND
13742: IFFALSE 13930
13744: GO 13746
13746: DISABLE
13747: LD_INT 0
13749: PPUSH
// begin enable ;
13750: ENABLE
// for unit in FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) do
13751: LD_ADDR_VAR 0 1
13755: PUSH
13756: LD_INT 22
13758: PUSH
13759: LD_INT 3
13761: PUSH
13762: EMPTY
13763: LIST
13764: LIST
13765: PUSH
13766: LD_INT 2
13768: PUSH
13769: LD_INT 21
13771: PUSH
13772: LD_INT 1
13774: PUSH
13775: EMPTY
13776: LIST
13777: LIST
13778: PUSH
13779: LD_INT 21
13781: PUSH
13782: LD_INT 2
13784: PUSH
13785: EMPTY
13786: LIST
13787: LIST
13788: PUSH
13789: EMPTY
13790: LIST
13791: LIST
13792: LIST
13793: PUSH
13794: EMPTY
13795: LIST
13796: LIST
13797: PPUSH
13798: CALL_OW 69
13802: PUSH
13803: FOR_IN
13804: IFFALSE 13928
// begin if Attacks ( unit ) = rightBunkers [ 1 ] or Attacks ( unit ) = rightBunkers [ 2 ] then
13806: LD_VAR 0 1
13810: PPUSH
13811: CALL_OW 320
13815: PUSH
13816: LD_EXP 83
13820: PUSH
13821: LD_INT 1
13823: ARRAY
13824: EQUAL
13825: PUSH
13826: LD_VAR 0 1
13830: PPUSH
13831: CALL_OW 320
13835: PUSH
13836: LD_EXP 83
13840: PUSH
13841: LD_INT 2
13843: ARRAY
13844: EQUAL
13845: OR
13846: IFFALSE 13926
// begin dialogAttackRightBunkers = true ;
13848: LD_ADDR_EXP 32
13852: PUSH
13853: LD_INT 1
13855: ST_TO_ADDR
// DialogueOn ;
13856: CALL_OW 6
// if IsOK ( Gnyevko ) then
13860: LD_EXP 63
13864: PPUSH
13865: CALL_OW 302
13869: IFFALSE 13883
// Say ( Gnyevko , D16A-Gny-1 ) ;
13871: LD_EXP 63
13875: PPUSH
13876: LD_STRING D16A-Gny-1
13878: PPUSH
13879: CALL_OW 88
// if IsOK ( Kovalyuk ) then
13883: LD_EXP 70
13887: PPUSH
13888: CALL_OW 302
13892: IFFALSE 13906
// Say ( Kovalyuk , D16A-Kov-1 ) ;
13894: LD_EXP 70
13898: PPUSH
13899: LD_STRING D16A-Kov-1
13901: PPUSH
13902: CALL_OW 88
// Say ( Burlak , D16A-Bur-1 ) ;
13906: LD_EXP 62
13910: PPUSH
13911: LD_STRING D16A-Bur-1
13913: PPUSH
13914: CALL_OW 88
// DialogueOff ;
13918: CALL_OW 7
// exit ;
13922: POP
13923: POP
13924: GO 13930
// end ; end ;
13926: GO 13803
13928: POP
13929: POP
// end ;
13930: PPOPN 1
13932: END
// every 0 0$3 trigger FilterUnitsInArea ( WeakPositionArea , [ [ f_side , 3 ] ] ) and not sawLeftBunker do var decsToChoose ;
13933: LD_INT 18
13935: PPUSH
13936: LD_INT 22
13938: PUSH
13939: LD_INT 3
13941: PUSH
13942: EMPTY
13943: LIST
13944: LIST
13945: PUSH
13946: EMPTY
13947: LIST
13948: PPUSH
13949: CALL_OW 70
13953: PUSH
13954: LD_EXP 29
13958: NOT
13959: AND
13960: IFFALSE 14343
13962: GO 13964
13964: DISABLE
13965: LD_INT 0
13967: PPUSH
// begin sawLeftBunker = true ;
13968: LD_ADDR_EXP 29
13972: PUSH
13973: LD_INT 1
13975: ST_TO_ADDR
// if playerGetSupport then
13976: LD_EXP 34
13980: IFFALSE 13999
// decsToChoose = [ 1 , 3 ] else
13982: LD_ADDR_VAR 0 1
13986: PUSH
13987: LD_INT 1
13989: PUSH
13990: LD_INT 3
13992: PUSH
13993: EMPTY
13994: LIST
13995: LIST
13996: ST_TO_ADDR
13997: GO 14018
// decsToChoose = [ 1 , 2 , 3 ] ;
13999: LD_ADDR_VAR 0 1
14003: PUSH
14004: LD_INT 1
14006: PUSH
14007: LD_INT 2
14009: PUSH
14010: LD_INT 3
14012: PUSH
14013: EMPTY
14014: LIST
14015: LIST
14016: LIST
14017: ST_TO_ADDR
// case SelectiveQuery ( QAttackBw , decsToChoose ) of 1 :
14018: LD_STRING QAttackBw
14020: PPUSH
14021: LD_VAR 0 1
14025: PPUSH
14026: CALL_OW 98
14030: PUSH
14031: LD_INT 1
14033: DOUBLE
14034: EQUAL
14035: IFTRUE 14039
14037: GO 14132
14039: POP
// begin DialogueOn ;
14040: CALL_OW 6
// Say ( Burlak , D17-Bur-1 ) ;
14044: LD_EXP 62
14048: PPUSH
14049: LD_STRING D17-Bur-1
14051: PPUSH
14052: CALL_OW 88
// SayRadio ( Platonov , D17-Pla-1 ) ;
14056: LD_EXP 76
14060: PPUSH
14061: LD_STRING D17-Pla-1
14063: PPUSH
14064: CALL_OW 94
// Say ( Burlak , D17-Bur-2 ) ;
14068: LD_EXP 62
14072: PPUSH
14073: LD_STRING D17-Bur-2
14075: PPUSH
14076: CALL_OW 88
// SayRadio ( Platonov , D17-Pla-2 ) ;
14080: LD_EXP 76
14084: PPUSH
14085: LD_STRING D17-Pla-2
14087: PPUSH
14088: CALL_OW 94
// DialogueOff ;
14092: CALL_OW 7
// if not ( initiative in [ 2 , 3 ] ) then
14096: LD_EXP 42
14100: PUSH
14101: LD_INT 2
14103: PUSH
14104: LD_INT 3
14106: PUSH
14107: EMPTY
14108: LIST
14109: LIST
14110: IN
14111: NOT
14112: IFFALSE 14130
// begin initiative = 1 ;
14114: LD_ADDR_EXP 42
14118: PUSH
14119: LD_INT 1
14121: ST_TO_ADDR
// platonovOpinion = 2 ;
14122: LD_ADDR_EXP 5
14126: PUSH
14127: LD_INT 2
14129: ST_TO_ADDR
// end ; end ; 2 :
14130: GO 14273
14132: LD_INT 2
14134: DOUBLE
14135: EQUAL
14136: IFTRUE 14140
14138: GO 14245
14140: POP
// begin DialogueOn ;
14141: CALL_OW 6
// Say ( Burlak , D18-Bur-1 ) ;
14145: LD_EXP 62
14149: PPUSH
14150: LD_STRING D18-Bur-1
14152: PPUSH
14153: CALL_OW 88
// SayRadio ( Platonov , D18-Pla-1 ) ;
14157: LD_EXP 76
14161: PPUSH
14162: LD_STRING D18-Pla-1
14164: PPUSH
14165: CALL_OW 94
// Say ( Burlak , D18-Bur-2 ) ;
14169: LD_EXP 62
14173: PPUSH
14174: LD_STRING D18-Bur-2
14176: PPUSH
14177: CALL_OW 88
// SayRadio ( Platonov , D18-Pla-2 ) ;
14181: LD_EXP 76
14185: PPUSH
14186: LD_STRING D18-Pla-2
14188: PPUSH
14189: CALL_OW 94
// DialogueOff ;
14193: CALL_OW 7
// playerGetSupport = true ;
14197: LD_ADDR_EXP 34
14201: PUSH
14202: LD_INT 1
14204: ST_TO_ADDR
// medalForGetSupport = false ;
14205: LD_ADDR_EXP 40
14209: PUSH
14210: LD_INT 0
14212: ST_TO_ADDR
// PlatonovSendSupport ;
14213: CALL 6559 0 0
// if initiative <> 3 then
14217: LD_EXP 42
14221: PUSH
14222: LD_INT 3
14224: NONEQUAL
14225: IFFALSE 14243
// begin initiative = 1 ;
14227: LD_ADDR_EXP 42
14231: PUSH
14232: LD_INT 1
14234: ST_TO_ADDR
// platonovOpinion = 2 ;
14235: LD_ADDR_EXP 5
14239: PUSH
14240: LD_INT 2
14242: ST_TO_ADDR
// end ; end ; 3 :
14243: GO 14273
14245: LD_INT 3
14247: DOUBLE
14248: EQUAL
14249: IFTRUE 14253
14251: GO 14272
14253: POP
// begin initiative = 3 ;
14254: LD_ADDR_EXP 42
14258: PUSH
14259: LD_INT 3
14261: ST_TO_ADDR
// platonovOpinion = 0 ;
14262: LD_ADDR_EXP 5
14266: PUSH
14267: LD_INT 0
14269: ST_TO_ADDR
// end ; end ;
14270: GO 14273
14272: POP
// if IsOK ( Gnyevko ) then
14273: LD_EXP 63
14277: PPUSH
14278: CALL_OW 302
14282: IFFALSE 14308
// begin Say ( Gnyevko , D19-Gny-1 ) ;
14284: LD_EXP 63
14288: PPUSH
14289: LD_STRING D19-Gny-1
14291: PPUSH
14292: CALL_OW 88
// Say ( Burlak , D19-Bur-1 ) ;
14296: LD_EXP 62
14300: PPUSH
14301: LD_STRING D19-Bur-1
14303: PPUSH
14304: CALL_OW 88
// end ; if IsOK ( Kovalyuk ) then
14308: LD_EXP 70
14312: PPUSH
14313: CALL_OW 302
14317: IFFALSE 14343
// begin Say ( Kovalyuk , D19-Kov-1 ) ;
14319: LD_EXP 70
14323: PPUSH
14324: LD_STRING D19-Kov-1
14326: PPUSH
14327: CALL_OW 88
// Say ( Burlak , D19-Bur-2 ) ;
14331: LD_EXP 62
14335: PPUSH
14336: LD_STRING D19-Bur-2
14338: PPUSH
14339: CALL_OW 88
// end ; end ;
14343: PPOPN 1
14345: END
// every 0 0$2 trigger not dialogAttackLeftBunkers and leftBunkers and canExploreMap and FilterUnitsInArea ( WeakPositionArea , [ [ f_side , 3 ] ] ) = 0 and ( IsOK ( Kovalyuk ) or IsOK ( Gnyevko ) ) do var unit ;
14346: LD_EXP 31
14350: NOT
14351: PUSH
14352: LD_EXP 82
14356: AND
14357: PUSH
14358: LD_EXP 20
14362: AND
14363: PUSH
14364: LD_INT 18
14366: PPUSH
14367: LD_INT 22
14369: PUSH
14370: LD_INT 3
14372: PUSH
14373: EMPTY
14374: LIST
14375: LIST
14376: PUSH
14377: EMPTY
14378: LIST
14379: PPUSH
14380: CALL_OW 70
14384: PUSH
14385: LD_INT 0
14387: EQUAL
14388: AND
14389: PUSH
14390: LD_EXP 70
14394: PPUSH
14395: CALL_OW 302
14399: PUSH
14400: LD_EXP 63
14404: PPUSH
14405: CALL_OW 302
14409: OR
14410: AND
14411: IFFALSE 14599
14413: GO 14415
14415: DISABLE
14416: LD_INT 0
14418: PPUSH
// begin enable ;
14419: ENABLE
// for unit in FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) do
14420: LD_ADDR_VAR 0 1
14424: PUSH
14425: LD_INT 22
14427: PUSH
14428: LD_INT 3
14430: PUSH
14431: EMPTY
14432: LIST
14433: LIST
14434: PUSH
14435: LD_INT 2
14437: PUSH
14438: LD_INT 21
14440: PUSH
14441: LD_INT 1
14443: PUSH
14444: EMPTY
14445: LIST
14446: LIST
14447: PUSH
14448: LD_INT 21
14450: PUSH
14451: LD_INT 2
14453: PUSH
14454: EMPTY
14455: LIST
14456: LIST
14457: PUSH
14458: EMPTY
14459: LIST
14460: LIST
14461: LIST
14462: PUSH
14463: EMPTY
14464: LIST
14465: LIST
14466: PPUSH
14467: CALL_OW 69
14471: PUSH
14472: FOR_IN
14473: IFFALSE 14597
// begin if Attacks ( unit ) = leftBunkers [ 1 ] or Attacks ( unit ) = leftBunkers [ 2 ] then
14475: LD_VAR 0 1
14479: PPUSH
14480: CALL_OW 320
14484: PUSH
14485: LD_EXP 82
14489: PUSH
14490: LD_INT 1
14492: ARRAY
14493: EQUAL
14494: PUSH
14495: LD_VAR 0 1
14499: PPUSH
14500: CALL_OW 320
14504: PUSH
14505: LD_EXP 82
14509: PUSH
14510: LD_INT 2
14512: ARRAY
14513: EQUAL
14514: OR
14515: IFFALSE 14595
// begin dialogAttackLeftBunkers = true ;
14517: LD_ADDR_EXP 31
14521: PUSH
14522: LD_INT 1
14524: ST_TO_ADDR
// DialogueOn ;
14525: CALL_OW 6
// if IsOK ( Gnyevko ) then
14529: LD_EXP 63
14533: PPUSH
14534: CALL_OW 302
14538: IFFALSE 14552
// Say ( Gnyevko , D19A-Gny-1 ) ;
14540: LD_EXP 63
14544: PPUSH
14545: LD_STRING D19A-Gny-1
14547: PPUSH
14548: CALL_OW 88
// if IsOK ( Kovalyuk ) then
14552: LD_EXP 70
14556: PPUSH
14557: CALL_OW 302
14561: IFFALSE 14575
// Say ( Kovalyuk , D19A-Kov-1 ) ;
14563: LD_EXP 70
14567: PPUSH
14568: LD_STRING D19A-Kov-1
14570: PPUSH
14571: CALL_OW 88
// Say ( Burlak , D16A-Bur-1 ) ;
14575: LD_EXP 62
14579: PPUSH
14580: LD_STRING D16A-Bur-1
14582: PPUSH
14583: CALL_OW 88
// DialogueOff ;
14587: CALL_OW 7
// exit ;
14591: POP
14592: POP
14593: GO 14599
// end ; end ;
14595: GO 14472
14597: POP
14598: POP
// end ;
14599: PPOPN 1
14601: END
// every 0 0$1 trigger ( not leftBunkers or FilterUnitsInArea ( LeftHillArea , [ [ f_side , 1 ] , [ f_type , unit_building ] , [ f_btype , b_breastwork ] , [ f_ok ] ] ) = 0 ) and canExploreMap do
14602: LD_EXP 82
14606: NOT
14607: PUSH
14608: LD_INT 17
14610: PPUSH
14611: LD_INT 22
14613: PUSH
14614: LD_INT 1
14616: PUSH
14617: EMPTY
14618: LIST
14619: LIST
14620: PUSH
14621: LD_INT 21
14623: PUSH
14624: LD_INT 3
14626: PUSH
14627: EMPTY
14628: LIST
14629: LIST
14630: PUSH
14631: LD_INT 30
14633: PUSH
14634: LD_INT 31
14636: PUSH
14637: EMPTY
14638: LIST
14639: LIST
14640: PUSH
14641: LD_INT 50
14643: PUSH
14644: EMPTY
14645: LIST
14646: PUSH
14647: EMPTY
14648: LIST
14649: LIST
14650: LIST
14651: LIST
14652: PPUSH
14653: CALL_OW 70
14657: PUSH
14658: LD_INT 0
14660: EQUAL
14661: OR
14662: PUSH
14663: LD_EXP 20
14667: AND
14668: IFFALSE 14719
14670: GO 14672
14672: DISABLE
// begin leftBunkers = [ ] ;
14673: LD_ADDR_EXP 82
14677: PUSH
14678: EMPTY
14679: ST_TO_ADDR
// DialogueOn ;
14680: CALL_OW 6
// Say ( Burlak , D20-Bur-1 ) ;
14684: LD_EXP 62
14688: PPUSH
14689: LD_STRING D20-Bur-1
14691: PPUSH
14692: CALL_OW 88
// Say ( Platonov , D20-Pla-1 ) ;
14696: LD_EXP 76
14700: PPUSH
14701: LD_STRING D20-Pla-1
14703: PPUSH
14704: CALL_OW 88
// DialogueOff ;
14708: CALL_OW 7
// ChangeMissionObjectives ( M8 ) ;
14712: LD_STRING M8
14714: PPUSH
14715: CALL_OW 337
// end ;
14719: END
// every 0 0$1 trigger ( not rightBunkers or FilterUnitsInArea ( rightHillArea , [ [ f_side , 1 ] , [ f_type , unit_building ] , [ f_btype , b_breastwork ] , [ f_ok ] ] ) = 0 ) and canExploreMap do
14720: LD_EXP 83
14724: NOT
14725: PUSH
14726: LD_INT 16
14728: PPUSH
14729: LD_INT 22
14731: PUSH
14732: LD_INT 1
14734: PUSH
14735: EMPTY
14736: LIST
14737: LIST
14738: PUSH
14739: LD_INT 21
14741: PUSH
14742: LD_INT 3
14744: PUSH
14745: EMPTY
14746: LIST
14747: LIST
14748: PUSH
14749: LD_INT 30
14751: PUSH
14752: LD_INT 31
14754: PUSH
14755: EMPTY
14756: LIST
14757: LIST
14758: PUSH
14759: LD_INT 50
14761: PUSH
14762: EMPTY
14763: LIST
14764: PUSH
14765: EMPTY
14766: LIST
14767: LIST
14768: LIST
14769: LIST
14770: PPUSH
14771: CALL_OW 70
14775: PUSH
14776: LD_INT 0
14778: EQUAL
14779: OR
14780: PUSH
14781: LD_EXP 20
14785: AND
14786: IFFALSE 14830
14788: GO 14790
14790: DISABLE
// begin rightBunkers = [ ] ;
14791: LD_ADDR_EXP 83
14795: PUSH
14796: EMPTY
14797: ST_TO_ADDR
// DialogueOn ;
14798: CALL_OW 6
// Say ( Burlak , D20a-Bur-1 ) ;
14802: LD_EXP 62
14806: PPUSH
14807: LD_STRING D20a-Bur-1
14809: PPUSH
14810: CALL_OW 88
// Say ( Platonov , D20a-Pla-1 ) ;
14814: LD_EXP 76
14818: PPUSH
14819: LD_STRING D20a-Pla-1
14821: PPUSH
14822: CALL_OW 88
// DialogueOff ;
14826: CALL_OW 7
// end ;
14830: END
// every 0 0$1 trigger not saveBelkovDecision and belkovTeam do var yourUnit , trapUnit , decsToChoose ;
14831: LD_EXP 35
14835: NOT
14836: PUSH
14837: LD_EXP 73
14841: AND
14842: IFFALSE 15337
14844: GO 14846
14846: DISABLE
14847: LD_INT 0
14849: PPUSH
14850: PPUSH
14851: PPUSH
// begin enable ;
14852: ENABLE
// for yourUnit in FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) do
14853: LD_ADDR_VAR 0 1
14857: PUSH
14858: LD_INT 22
14860: PUSH
14861: LD_INT 3
14863: PUSH
14864: EMPTY
14865: LIST
14866: LIST
14867: PUSH
14868: LD_INT 2
14870: PUSH
14871: LD_INT 21
14873: PUSH
14874: LD_INT 1
14876: PUSH
14877: EMPTY
14878: LIST
14879: LIST
14880: PUSH
14881: LD_INT 21
14883: PUSH
14884: LD_INT 2
14886: PUSH
14887: EMPTY
14888: LIST
14889: LIST
14890: PUSH
14891: EMPTY
14892: LIST
14893: LIST
14894: LIST
14895: PUSH
14896: EMPTY
14897: LIST
14898: LIST
14899: PPUSH
14900: CALL_OW 69
14904: PUSH
14905: FOR_IN
14906: IFFALSE 15335
// for trapUnit in trapTeam do
14908: LD_ADDR_VAR 0 2
14912: PUSH
14913: LD_EXP 81
14917: PUSH
14918: FOR_IN
14919: IFFALSE 15331
// if GetDistUnits ( yourUnit , trapUnit ) < 16 then
14921: LD_VAR 0 1
14925: PPUSH
14926: LD_VAR 0 2
14930: PPUSH
14931: CALL_OW 296
14935: PUSH
14936: LD_INT 16
14938: LESS
14939: IFFALSE 15329
// begin saveBelkovDecision = true ;
14941: LD_ADDR_EXP 35
14945: PUSH
14946: LD_INT 1
14948: ST_TO_ADDR
// if playerGetSupport then
14949: LD_EXP 34
14953: IFFALSE 14972
// decsToChoose = [ 1 , 3 ] else
14955: LD_ADDR_VAR 0 3
14959: PUSH
14960: LD_INT 1
14962: PUSH
14963: LD_INT 3
14965: PUSH
14966: EMPTY
14967: LIST
14968: LIST
14969: ST_TO_ADDR
14970: GO 14991
// decsToChoose = [ 1 , 2 , 3 ] ;
14972: LD_ADDR_VAR 0 3
14976: PUSH
14977: LD_INT 1
14979: PUSH
14980: LD_INT 2
14982: PUSH
14983: LD_INT 3
14985: PUSH
14986: EMPTY
14987: LIST
14988: LIST
14989: LIST
14990: ST_TO_ADDR
// case SelectiveQuery ( QAttackAm , decsToChoose ) of 1 :
14991: LD_STRING QAttackAm
14993: PPUSH
14994: LD_VAR 0 3
14998: PPUSH
14999: CALL_OW 98
15003: PUSH
15004: LD_INT 1
15006: DOUBLE
15007: EQUAL
15008: IFTRUE 15012
15010: GO 15081
15012: POP
// begin DialogueOn ;
15013: CALL_OW 6
// Say ( Burlak , D21-Bur-1 ) ;
15017: LD_EXP 62
15021: PPUSH
15022: LD_STRING D21-Bur-1
15024: PPUSH
15025: CALL_OW 88
// SayRadio ( Platonov , D21-Pla-1 ) ;
15029: LD_EXP 76
15033: PPUSH
15034: LD_STRING D21-Pla-1
15036: PPUSH
15037: CALL_OW 94
// DialogueOff ;
15041: CALL_OW 7
// if not ( initiative in [ 2 , 3 ] ) then
15045: LD_EXP 42
15049: PUSH
15050: LD_INT 2
15052: PUSH
15053: LD_INT 3
15055: PUSH
15056: EMPTY
15057: LIST
15058: LIST
15059: IN
15060: NOT
15061: IFFALSE 15079
// begin initiative = 1 ;
15063: LD_ADDR_EXP 42
15067: PUSH
15068: LD_INT 1
15070: ST_TO_ADDR
// platonovOpinion = 2 ;
15071: LD_ADDR_EXP 5
15075: PUSH
15076: LD_INT 2
15078: ST_TO_ADDR
// end ; end ; 2 :
15079: GO 15273
15081: LD_INT 2
15083: DOUBLE
15084: EQUAL
15085: IFTRUE 15089
15087: GO 15245
15089: POP
// begin DialogueOn ;
15090: CALL_OW 6
// Say ( Burlak , D22-Bur-1 ) ;
15094: LD_EXP 62
15098: PPUSH
15099: LD_STRING D22-Bur-1
15101: PPUSH
15102: CALL_OW 88
// if playerGetSupport and ( leftBunkers = 0 or rightBunkers = 0 ) then
15106: LD_EXP 34
15110: PUSH
15111: LD_EXP 82
15115: PUSH
15116: LD_INT 0
15118: EQUAL
15119: PUSH
15120: LD_EXP 83
15124: PUSH
15125: LD_INT 0
15127: EQUAL
15128: OR
15129: AND
15130: IFFALSE 15144
// Say ( Platonov , D22-Pla-1b ) ;
15132: LD_EXP 76
15136: PPUSH
15137: LD_STRING D22-Pla-1b
15139: PPUSH
15140: CALL_OW 88
// if playerGetSupport and ( leftBunkers or rightBunkers ) then
15144: LD_EXP 34
15148: PUSH
15149: LD_EXP 82
15153: PUSH
15154: LD_EXP 83
15158: OR
15159: AND
15160: IFFALSE 15174
// Say ( Platonov , D22-Pla-1a ) ;
15162: LD_EXP 76
15166: PPUSH
15167: LD_STRING D22-Pla-1a
15169: PPUSH
15170: CALL_OW 88
// if not playerGetSupport then
15174: LD_EXP 34
15178: NOT
15179: IFFALSE 15213
// begin Say ( Platonov , D22-Pla-1 ) ;
15181: LD_EXP 76
15185: PPUSH
15186: LD_STRING D22-Pla-1
15188: PPUSH
15189: CALL_OW 88
// playerGetSupport = true ;
15193: LD_ADDR_EXP 34
15197: PUSH
15198: LD_INT 1
15200: ST_TO_ADDR
// medalForGetSupport = false ;
15201: LD_ADDR_EXP 40
15205: PUSH
15206: LD_INT 0
15208: ST_TO_ADDR
// PlatonovSendSupport ;
15209: CALL 6559 0 0
// end ; DialogueOff ;
15213: CALL_OW 7
// if initiative <> 3 then
15217: LD_EXP 42
15221: PUSH
15222: LD_INT 3
15224: NONEQUAL
15225: IFFALSE 15243
// begin initiative = 2 ;
15227: LD_ADDR_EXP 42
15231: PUSH
15232: LD_INT 2
15234: ST_TO_ADDR
// platonovOpinion = 1 ;
15235: LD_ADDR_EXP 5
15239: PUSH
15240: LD_INT 1
15242: ST_TO_ADDR
// end ; end ; 3 :
15243: GO 15273
15245: LD_INT 3
15247: DOUBLE
15248: EQUAL
15249: IFTRUE 15253
15251: GO 15272
15253: POP
// begin initiative = 3 ;
15254: LD_ADDR_EXP 42
15258: PUSH
15259: LD_INT 3
15261: ST_TO_ADDR
// platonovOpinion = 0 ;
15262: LD_ADDR_EXP 5
15266: PUSH
15267: LD_INT 0
15269: ST_TO_ADDR
// end ; end ;
15270: GO 15273
15272: POP
// if IsOK ( Gnyevko ) then
15273: LD_EXP 63
15277: PPUSH
15278: CALL_OW 302
15282: IFFALSE 15308
// begin Say ( Gnyevko , D23-Gny-1 ) ;
15284: LD_EXP 63
15288: PPUSH
15289: LD_STRING D23-Gny-1
15291: PPUSH
15292: CALL_OW 88
// Say ( Burlak , D23-Bur-1 ) ;
15296: LD_EXP 62
15300: PPUSH
15301: LD_STRING D23-Bur-1
15303: PPUSH
15304: CALL_OW 88
// end ; saveBelkovObjective = true ;
15308: LD_ADDR_EXP 36
15312: PUSH
15313: LD_INT 1
15315: ST_TO_ADDR
// ChangeMissionObjectives ( M9 ) ;
15316: LD_STRING M9
15318: PPUSH
15319: CALL_OW 337
// exit ;
15323: POP
15324: POP
15325: POP
15326: POP
15327: GO 15337
// end ;
15329: GO 14918
15331: POP
15332: POP
15333: GO 14905
15335: POP
15336: POP
// end ;
15337: PPOPN 3
15339: END
// every 0 0$1 trigger canExploreMap and not trapTeam and not belkovSaved do
15340: LD_EXP 20
15344: PUSH
15345: LD_EXP 81
15349: NOT
15350: AND
15351: PUSH
15352: LD_EXP 37
15356: NOT
15357: AND
15358: IFFALSE 15398
15360: GO 15362
15362: DISABLE
// begin belkovSaved = true ;
15363: LD_ADDR_EXP 37
15367: PUSH
15368: LD_INT 1
15370: ST_TO_ADDR
// activateBelkovAI = false ;
15371: LD_ADDR_EXP 28
15375: PUSH
15376: LD_INT 0
15378: ST_TO_ADDR
// SetSide ( belkovTeam , 3 ) ;
15379: LD_EXP 73
15383: PPUSH
15384: LD_INT 3
15386: PPUSH
15387: CALL_OW 235
// ChangeMissionObjectives ( M9a ) ;
15391: LD_STRING M9a
15393: PPUSH
15394: CALL_OW 337
// end ;
15398: END
// every 0 0$1 trigger saveBelkovDecision and ( IsDead ( Belkov ) or IsDead ( Belkov2 ) and ( GetSide ( Belkov ) = 6 or GetSide ( Belkov2 ) = 6 ) ) do
15399: LD_EXP 35
15403: PUSH
15404: LD_EXP 64
15408: PPUSH
15409: CALL_OW 301
15413: PUSH
15414: LD_EXP 68
15418: PPUSH
15419: CALL_OW 301
15423: PUSH
15424: LD_EXP 64
15428: PPUSH
15429: CALL_OW 255
15433: PUSH
15434: LD_INT 6
15436: EQUAL
15437: PUSH
15438: LD_EXP 68
15442: PPUSH
15443: CALL_OW 255
15447: PUSH
15448: LD_INT 6
15450: EQUAL
15451: OR
15452: AND
15453: OR
15454: AND
15455: IFFALSE 15475
15457: GO 15459
15459: DISABLE
// begin ChangeMissionObjectives ( M9a ) ;
15460: LD_STRING M9a
15462: PPUSH
15463: CALL_OW 337
// saveBelkovObjective = false ;
15467: LD_ADDR_EXP 36
15471: PUSH
15472: LD_INT 0
15474: ST_TO_ADDR
// end ;
15475: END
// every 0 0$5 trigger belkovSaved and ( ( GetDistUnits ( Burlak , Belkov ) < 14 and belkovReturn ) or ( GetDistUnits ( Burlak , Belkov2 ) < 14 and not belkovReturn ) ) do
15476: LD_EXP 37
15480: PUSH
15481: LD_EXP 62
15485: PPUSH
15486: LD_EXP 64
15490: PPUSH
15491: CALL_OW 296
15495: PUSH
15496: LD_INT 14
15498: LESS
15499: PUSH
15500: LD_EXP 6
15504: AND
15505: PUSH
15506: LD_EXP 62
15510: PPUSH
15511: LD_EXP 68
15515: PPUSH
15516: CALL_OW 296
15520: PUSH
15521: LD_INT 14
15523: LESS
15524: PUSH
15525: LD_EXP 6
15529: NOT
15530: AND
15531: OR
15532: AND
15533: IFFALSE 15829
15535: GO 15537
15537: DISABLE
// begin InGameOn ;
15538: CALL_OW 8
// if IsOk ( Belkov ) and belkovReturn then
15542: LD_EXP 64
15546: PPUSH
15547: CALL_OW 302
15551: PUSH
15552: LD_EXP 6
15556: AND
15557: IFFALSE 15653
// begin CenterNowOnUnits ( [ Burlak , Belkov ] ) ;
15559: LD_EXP 62
15563: PUSH
15564: LD_EXP 64
15568: PUSH
15569: EMPTY
15570: LIST
15571: LIST
15572: PPUSH
15573: CALL_OW 87
// ComTurnUnit ( Burlak , Belkov ) ;
15577: LD_EXP 62
15581: PPUSH
15582: LD_EXP 64
15586: PPUSH
15587: CALL_OW 119
// ComTurnUnit ( Belkov , Burlak ) ;
15591: LD_EXP 64
15595: PPUSH
15596: LD_EXP 62
15600: PPUSH
15601: CALL_OW 119
// Say ( Belkov , D24-Bel-1 ) ;
15605: LD_EXP 64
15609: PPUSH
15610: LD_STRING D24-Bel-1
15612: PPUSH
15613: CALL_OW 88
// Say ( Burlak , D24-Bur-1 ) ;
15617: LD_EXP 62
15621: PPUSH
15622: LD_STRING D24-Bur-1
15624: PPUSH
15625: CALL_OW 88
// Say ( Belkov , D24-Bel-2 ) ;
15629: LD_EXP 64
15633: PPUSH
15634: LD_STRING D24-Bel-2
15636: PPUSH
15637: CALL_OW 88
// Say ( Burlak , D24-Bur-2 ) ;
15641: LD_EXP 62
15645: PPUSH
15646: LD_STRING D24-Bur-2
15648: PPUSH
15649: CALL_OW 88
// end ; if IsOk ( Belkov2 ) and not belkovReturn then
15653: LD_EXP 68
15657: PPUSH
15658: CALL_OW 302
15662: PUSH
15663: LD_EXP 6
15667: NOT
15668: AND
15669: IFFALSE 15777
// begin CenterNowOnUnits ( [ Burlak , Belkov2 ] ) ;
15671: LD_EXP 62
15675: PUSH
15676: LD_EXP 68
15680: PUSH
15681: EMPTY
15682: LIST
15683: LIST
15684: PPUSH
15685: CALL_OW 87
// ComTurnUnit ( Burlak , Belkov2 ) ;
15689: LD_EXP 62
15693: PPUSH
15694: LD_EXP 68
15698: PPUSH
15699: CALL_OW 119
// ComTurnUnit ( Belkov2 , Burlak ) ;
15703: LD_EXP 68
15707: PPUSH
15708: LD_EXP 62
15712: PPUSH
15713: CALL_OW 119
// Say ( Belkov2 , D24-Bel-1 ) ;
15717: LD_EXP 68
15721: PPUSH
15722: LD_STRING D24-Bel-1
15724: PPUSH
15725: CALL_OW 88
// Say ( Burlak , D24-Bur-1 ) ;
15729: LD_EXP 62
15733: PPUSH
15734: LD_STRING D24-Bur-1
15736: PPUSH
15737: CALL_OW 88
// Say ( Burlak , D24-Bur-1a ) ;
15741: LD_EXP 62
15745: PPUSH
15746: LD_STRING D24-Bur-1a
15748: PPUSH
15749: CALL_OW 88
// Say ( Belkov2 , D24-Bel-2 ) ;
15753: LD_EXP 68
15757: PPUSH
15758: LD_STRING D24-Bel-2
15760: PPUSH
15761: CALL_OW 88
// Say ( Burlak , D24-Bur-2 ) ;
15765: LD_EXP 62
15769: PPUSH
15770: LD_STRING D24-Bur-2
15772: PPUSH
15773: CALL_OW 88
// end ; if captureBelkovVehicle then
15777: LD_EXP 38
15781: IFFALSE 15795
// Say ( Burlak , D24-Bur-2a ) ;
15783: LD_EXP 62
15787: PPUSH
15788: LD_STRING D24-Bur-2a
15790: PPUSH
15791: CALL_OW 88
// SayRadio ( Platonov , D24-Pla-2 ) ;
15795: LD_EXP 76
15799: PPUSH
15800: LD_STRING D24-Pla-2
15802: PPUSH
15803: CALL_OW 94
// if leftBunkers then
15807: LD_EXP 82
15811: IFFALSE 15825
// SayRadio ( Platonov , D24-Pla-2a ) ;
15813: LD_EXP 76
15817: PPUSH
15818: LD_STRING D24-Pla-2a
15820: PPUSH
15821: CALL_OW 94
// InGameOff ;
15825: CALL_OW 9
// end ;
15829: END
// every 0 0$1 trigger FilterUnitsInArea ( TrackDialogArea , [ [ f_side , 3 ] , [ f_type , unit_vehicle ] ] ) and ( IsOk ( Kovalyuk ) or IsOK ( Gnyevko ) ) do
15830: LD_INT 22
15832: PPUSH
15833: LD_INT 22
15835: PUSH
15836: LD_INT 3
15838: PUSH
15839: EMPTY
15840: LIST
15841: LIST
15842: PUSH
15843: LD_INT 21
15845: PUSH
15846: LD_INT 2
15848: PUSH
15849: EMPTY
15850: LIST
15851: LIST
15852: PUSH
15853: EMPTY
15854: LIST
15855: LIST
15856: PPUSH
15857: CALL_OW 70
15861: PUSH
15862: LD_EXP 70
15866: PPUSH
15867: CALL_OW 302
15871: PUSH
15872: LD_EXP 63
15876: PPUSH
15877: CALL_OW 302
15881: OR
15882: AND
15883: IFFALSE 15966
15885: GO 15887
15887: DISABLE
// begin DialogueOn ;
15888: CALL_OW 6
// Say ( Burlak , D26-Bur-1 ) ;
15892: LD_EXP 62
15896: PPUSH
15897: LD_STRING D26-Bur-1
15899: PPUSH
15900: CALL_OW 88
// if IsOk ( Kovalyuk ) then
15904: LD_EXP 70
15908: PPUSH
15909: CALL_OW 302
15913: IFFALSE 15927
// Say ( Kovalyuk , D26-Kov-1 ) ;
15915: LD_EXP 70
15919: PPUSH
15920: LD_STRING D26-Kov-1
15922: PPUSH
15923: CALL_OW 88
// if IsOk ( Gnyevko ) then
15927: LD_EXP 63
15931: PPUSH
15932: CALL_OW 302
15936: IFFALSE 15950
// Say ( Gnyevko , D26-Gny-1 ) ;
15938: LD_EXP 63
15942: PPUSH
15943: LD_STRING D26-Gny-1
15945: PPUSH
15946: CALL_OW 88
// Say ( Burlak , D26-Bur-2 ) ;
15950: LD_EXP 62
15954: PPUSH
15955: LD_STRING D26-Bur-2
15957: PPUSH
15958: CALL_OW 88
// DialogueOff ;
15962: CALL_OW 7
// end ;
15966: END
// every 0 0$1 trigger canExploreMap and ( not IsInArea ( Burlak , BeriaBaseArea ) and not IsInArea ( IsInUnit ( IsInUnit ( Burlak ) ) , BeriaBaseArea ) ) and raportForPlatonov = - 1 do
15967: LD_EXP 20
15971: PUSH
15972: LD_EXP 62
15976: PPUSH
15977: LD_INT 8
15979: PPUSH
15980: CALL_OW 308
15984: NOT
15985: PUSH
15986: LD_EXP 62
15990: PPUSH
15991: CALL_OW 310
15995: PPUSH
15996: CALL_OW 310
16000: PPUSH
16001: LD_INT 8
16003: PPUSH
16004: CALL_OW 308
16008: NOT
16009: AND
16010: AND
16011: PUSH
16012: LD_EXP 39
16016: PUSH
16017: LD_INT 1
16019: NEG
16020: EQUAL
16021: AND
16022: IFFALSE 16036
16024: GO 16026
16026: DISABLE
// begin enable ;
16027: ENABLE
// raportForPlatonov = 0 ;
16028: LD_ADDR_EXP 39
16032: PUSH
16033: LD_INT 0
16035: ST_TO_ADDR
// end ;
16036: END
// every 0 0$1 trigger canExploreMap and raportForPlatonov >= 0 and not backToBeria2 and ( IsInArea ( Burlak , BeriaBaseArea ) or IsInArea ( IsInUnit ( IsInUnit ( Burlak ) ) , BeriaBaseArea ) and not backToBeria2 ) do
16037: LD_EXP 20
16041: PUSH
16042: LD_EXP 39
16046: PUSH
16047: LD_INT 0
16049: GREATEREQUAL
16050: AND
16051: PUSH
16052: LD_EXP 16
16056: NOT
16057: AND
16058: PUSH
16059: LD_EXP 62
16063: PPUSH
16064: LD_INT 8
16066: PPUSH
16067: CALL_OW 308
16071: PUSH
16072: LD_EXP 62
16076: PPUSH
16077: CALL_OW 310
16081: PPUSH
16082: CALL_OW 310
16086: PPUSH
16087: LD_INT 8
16089: PPUSH
16090: CALL_OW 308
16094: PUSH
16095: LD_EXP 16
16099: NOT
16100: AND
16101: OR
16102: AND
16103: IFFALSE 16394
16105: GO 16107
16107: DISABLE
// begin enable ;
16108: ENABLE
// DialogueOn ;
16109: CALL_OW 6
// case raportForPlatonov of 0 :
16113: LD_EXP 39
16117: PUSH
16118: LD_INT 0
16120: DOUBLE
16121: EQUAL
16122: IFTRUE 16126
16124: GO 16153
16126: POP
// begin Say ( Platonov , D25a-Pla-1 ) ;
16127: LD_EXP 76
16131: PPUSH
16132: LD_STRING D25a-Pla-1
16134: PPUSH
16135: CALL_OW 88
// Say ( Burlak , D25a-Bur-1 ) ;
16139: LD_EXP 62
16143: PPUSH
16144: LD_STRING D25a-Bur-1
16146: PPUSH
16147: CALL_OW 88
// end ; 1 :
16151: GO 16369
16153: LD_INT 1
16155: DOUBLE
16156: EQUAL
16157: IFTRUE 16161
16159: GO 16224
16161: POP
// begin Say ( Platonov , D25-Pla-1 ) ;
16162: LD_EXP 76
16166: PPUSH
16167: LD_STRING D25-Pla-1
16169: PPUSH
16170: CALL_OW 88
// Say ( Burlak , D25-Bur-1 ) ;
16174: LD_EXP 62
16178: PPUSH
16179: LD_STRING D25-Bur-1
16181: PPUSH
16182: CALL_OW 88
// Say ( Burlak , D25b-Bur-1 ) ;
16186: LD_EXP 62
16190: PPUSH
16191: LD_STRING D25b-Bur-1
16193: PPUSH
16194: CALL_OW 88
// Say ( Platonov , D25b-Pla-1 ) ;
16198: LD_EXP 76
16202: PPUSH
16203: LD_STRING D25b-Pla-1
16205: PPUSH
16206: CALL_OW 88
// playerGetSupport = true ;
16210: LD_ADDR_EXP 34
16214: PUSH
16215: LD_INT 1
16217: ST_TO_ADDR
// PlatonovSendSupport ;
16218: CALL 6559 0 0
// end ; 2 :
16222: GO 16369
16224: LD_INT 2
16226: DOUBLE
16227: EQUAL
16228: IFTRUE 16232
16230: GO 16278
16232: POP
// begin Say ( Platonov , D25-Pla-1 ) ;
16233: LD_EXP 76
16237: PPUSH
16238: LD_STRING D25-Pla-1
16240: PPUSH
16241: CALL_OW 88
// Say ( Burlak , D25-Bur-1a ) ;
16245: LD_EXP 62
16249: PPUSH
16250: LD_STRING D25-Bur-1a
16252: PPUSH
16253: CALL_OW 88
// if not sawLeftBunker then
16257: LD_EXP 29
16261: NOT
16262: IFFALSE 16276
// Say ( Platonov , D25c-Pla-1 ) ;
16264: LD_EXP 76
16268: PPUSH
16269: LD_STRING D25c-Pla-1
16271: PPUSH
16272: CALL_OW 88
// end ; 3 :
16276: GO 16369
16278: LD_INT 3
16280: DOUBLE
16281: EQUAL
16282: IFTRUE 16286
16284: GO 16368
16286: POP
// begin Say ( Platonov , D25-Pla-1 ) ;
16287: LD_EXP 76
16291: PPUSH
16292: LD_STRING D25-Pla-1
16294: PPUSH
16295: CALL_OW 88
// Say ( Burlak , D25a-Bur-1b ) ;
16299: LD_EXP 62
16303: PPUSH
16304: LD_STRING D25a-Bur-1b
16306: PPUSH
16307: CALL_OW 88
// Say ( Burlak , D25b-Bur-1 ) ;
16311: LD_EXP 62
16315: PPUSH
16316: LD_STRING D25b-Bur-1
16318: PPUSH
16319: CALL_OW 88
// Say ( Platonov , D25b-Pla-1 ) ;
16323: LD_EXP 76
16327: PPUSH
16328: LD_STRING D25b-Pla-1
16330: PPUSH
16331: CALL_OW 88
// playerGetSupport = true ;
16335: LD_ADDR_EXP 34
16339: PUSH
16340: LD_INT 1
16342: ST_TO_ADDR
// PlatonovSendSupport ;
16343: CALL 6559 0 0
// if not sawRightBunker then
16347: LD_EXP 30
16351: NOT
16352: IFFALSE 16366
// Say ( Platonov , D25c-Pla-1 ) ;
16354: LD_EXP 76
16358: PPUSH
16359: LD_STRING D25c-Pla-1
16361: PPUSH
16362: CALL_OW 88
// end ; end ;
16366: GO 16369
16368: POP
// raportForPlatonov = - 1 ;
16369: LD_ADDR_EXP 39
16373: PUSH
16374: LD_INT 1
16376: NEG
16377: ST_TO_ADDR
// Say ( Platonov , D25c-Pla-1a ) ;
16378: LD_EXP 76
16382: PPUSH
16383: LD_STRING D25c-Pla-1a
16385: PPUSH
16386: CALL_OW 88
// DialogueOff ;
16390: CALL_OW 7
// end ;
16394: END
// every 0 0$1 trigger FilterUnitsInArea ( NorthArea , [ [ f_side , 3 ] ] ) > 0 do
16395: LD_INT 19
16397: PPUSH
16398: LD_INT 22
16400: PUSH
16401: LD_INT 3
16403: PUSH
16404: EMPTY
16405: LIST
16406: LIST
16407: PUSH
16408: EMPTY
16409: LIST
16410: PPUSH
16411: CALL_OW 70
16415: PUSH
16416: LD_INT 0
16418: GREATER
16419: IFFALSE 16439
16421: GO 16423
16423: DISABLE
// begin northMapExplored = true ;
16424: LD_ADDR_EXP 41
16428: PUSH
16429: LD_INT 1
16431: ST_TO_ADDR
// ChangeMissionObjectives ( M10 ) ;
16432: LD_STRING M10
16434: PPUSH
16435: CALL_OW 337
// end ;
16439: END
// every 0 0$1 trigger not leftBunkers and northMapExplored and ( belkovSaved or not saveBelkovObjective ) do
16440: LD_EXP 82
16444: NOT
16445: PUSH
16446: LD_EXP 41
16450: AND
16451: PUSH
16452: LD_EXP 37
16456: PUSH
16457: LD_EXP 36
16461: NOT
16462: OR
16463: AND
16464: IFFALSE 16484
16466: GO 16468
16468: DISABLE
// begin backToBeria2 = true ;
16469: LD_ADDR_EXP 16
16473: PUSH
16474: LD_INT 1
16476: ST_TO_ADDR
// ChangeMissionObjectives ( M10a ) ;
16477: LD_STRING M10a
16479: PPUSH
16480: CALL_OW 337
// end ;
16484: END
// every 0 0$1 do
16485: GO 16487
16487: DISABLE
// begin enable ;
16488: ENABLE
// SetLives ( [ Kurin , Platonov ] , 1000 ) ;
16489: LD_EXP 67
16493: PUSH
16494: LD_EXP 76
16498: PUSH
16499: EMPTY
16500: LIST
16501: LIST
16502: PPUSH
16503: LD_INT 1000
16505: PPUSH
16506: CALL_OW 234
// end ; end_of_file
16510: END
// export function PrepareNature ; var i , un ; begin
16511: LD_INT 0
16513: PPUSH
16514: PPUSH
16515: PPUSH
// for i := 1 to animalsAmount [ 1 ] do
16516: LD_ADDR_VAR 0 2
16520: PUSH
16521: DOUBLE
16522: LD_INT 1
16524: DEC
16525: ST_TO_ADDR
16526: LD_EXP 45
16530: PUSH
16531: LD_INT 1
16533: ARRAY
16534: PUSH
16535: FOR_TO
16536: IFFALSE 16646
// begin uc_side = 0 ;
16538: LD_ADDR_OWVAR 20
16542: PUSH
16543: LD_INT 0
16545: ST_TO_ADDR
// uc_nation = nation_nature ;
16546: LD_ADDR_OWVAR 21
16550: PUSH
16551: LD_INT 0
16553: ST_TO_ADDR
// hc_class = class_apeman ;
16554: LD_ADDR_OWVAR 28
16558: PUSH
16559: LD_INT 12
16561: ST_TO_ADDR
// hc_skills = [ animalsStats [ 1 ] , animalsStats [ 2 ] , animalsStats [ 3 ] , animalsStats [ 4 ] ] ;
16562: LD_ADDR_OWVAR 31
16566: PUSH
16567: LD_EXP 46
16571: PUSH
16572: LD_INT 1
16574: ARRAY
16575: PUSH
16576: LD_EXP 46
16580: PUSH
16581: LD_INT 2
16583: ARRAY
16584: PUSH
16585: LD_EXP 46
16589: PUSH
16590: LD_INT 3
16592: ARRAY
16593: PUSH
16594: LD_EXP 46
16598: PUSH
16599: LD_INT 4
16601: ARRAY
16602: PUSH
16603: EMPTY
16604: LIST
16605: LIST
16606: LIST
16607: LIST
16608: ST_TO_ADDR
// hc_agressivity = animalsAgression ;
16609: LD_ADDR_OWVAR 35
16613: PUSH
16614: LD_EXP 47
16618: ST_TO_ADDR
// un = CreateHuman ;
16619: LD_ADDR_VAR 0 3
16623: PUSH
16624: CALL_OW 44
16628: ST_TO_ADDR
// PlaceUnitArea ( un , NatureArea , false ) ;
16629: LD_VAR 0 3
16633: PPUSH
16634: LD_INT 21
16636: PPUSH
16637: LD_INT 0
16639: PPUSH
16640: CALL_OW 49
// end ;
16644: GO 16535
16646: POP
16647: POP
// for i := 1 to animalsAmount [ 2 ] do
16648: LD_ADDR_VAR 0 2
16652: PUSH
16653: DOUBLE
16654: LD_INT 1
16656: DEC
16657: ST_TO_ADDR
16658: LD_EXP 45
16662: PUSH
16663: LD_INT 2
16665: ARRAY
16666: PUSH
16667: FOR_TO
16668: IFFALSE 16778
// begin uc_side = 0 ;
16670: LD_ADDR_OWVAR 20
16674: PUSH
16675: LD_INT 0
16677: ST_TO_ADDR
// uc_nation = nation_nature ;
16678: LD_ADDR_OWVAR 21
16682: PUSH
16683: LD_INT 0
16685: ST_TO_ADDR
// hc_class = class_phororhacos ;
16686: LD_ADDR_OWVAR 28
16690: PUSH
16691: LD_INT 18
16693: ST_TO_ADDR
// hc_skills = [ animalsStats [ 1 ] , animalsStats [ 2 ] , animalsStats [ 3 ] , animalsStats [ 4 ] ] ;
16694: LD_ADDR_OWVAR 31
16698: PUSH
16699: LD_EXP 46
16703: PUSH
16704: LD_INT 1
16706: ARRAY
16707: PUSH
16708: LD_EXP 46
16712: PUSH
16713: LD_INT 2
16715: ARRAY
16716: PUSH
16717: LD_EXP 46
16721: PUSH
16722: LD_INT 3
16724: ARRAY
16725: PUSH
16726: LD_EXP 46
16730: PUSH
16731: LD_INT 4
16733: ARRAY
16734: PUSH
16735: EMPTY
16736: LIST
16737: LIST
16738: LIST
16739: LIST
16740: ST_TO_ADDR
// hc_agressivity = animalsAgression ;
16741: LD_ADDR_OWVAR 35
16745: PUSH
16746: LD_EXP 47
16750: ST_TO_ADDR
// un = CreateHuman ;
16751: LD_ADDR_VAR 0 3
16755: PUSH
16756: CALL_OW 44
16760: ST_TO_ADDR
// PlaceUnitArea ( un , NatureArea , false ) ;
16761: LD_VAR 0 3
16765: PPUSH
16766: LD_INT 21
16768: PPUSH
16769: LD_INT 0
16771: PPUSH
16772: CALL_OW 49
// end ;
16776: GO 16667
16778: POP
16779: POP
// for i := 1 to animalsAmount [ 3 ] do
16780: LD_ADDR_VAR 0 2
16784: PUSH
16785: DOUBLE
16786: LD_INT 1
16788: DEC
16789: ST_TO_ADDR
16790: LD_EXP 45
16794: PUSH
16795: LD_INT 3
16797: ARRAY
16798: PUSH
16799: FOR_TO
16800: IFFALSE 16910
// begin uc_side = 0 ;
16802: LD_ADDR_OWVAR 20
16806: PUSH
16807: LD_INT 0
16809: ST_TO_ADDR
// uc_nation = nation_nature ;
16810: LD_ADDR_OWVAR 21
16814: PUSH
16815: LD_INT 0
16817: ST_TO_ADDR
// hc_class = class_tiger ;
16818: LD_ADDR_OWVAR 28
16822: PUSH
16823: LD_INT 14
16825: ST_TO_ADDR
// hc_skills = [ animalsStats [ 1 ] , animalsStats [ 2 ] , animalsStats [ 3 ] , animalsStats [ 4 ] ] ;
16826: LD_ADDR_OWVAR 31
16830: PUSH
16831: LD_EXP 46
16835: PUSH
16836: LD_INT 1
16838: ARRAY
16839: PUSH
16840: LD_EXP 46
16844: PUSH
16845: LD_INT 2
16847: ARRAY
16848: PUSH
16849: LD_EXP 46
16853: PUSH
16854: LD_INT 3
16856: ARRAY
16857: PUSH
16858: LD_EXP 46
16862: PUSH
16863: LD_INT 4
16865: ARRAY
16866: PUSH
16867: EMPTY
16868: LIST
16869: LIST
16870: LIST
16871: LIST
16872: ST_TO_ADDR
// hc_agressivity = animalsAgression ;
16873: LD_ADDR_OWVAR 35
16877: PUSH
16878: LD_EXP 47
16882: ST_TO_ADDR
// un = CreateHuman ;
16883: LD_ADDR_VAR 0 3
16887: PUSH
16888: CALL_OW 44
16892: ST_TO_ADDR
// PlaceUnitArea ( un , NatureArea , false ) ;
16893: LD_VAR 0 3
16897: PPUSH
16898: LD_INT 21
16900: PPUSH
16901: LD_INT 0
16903: PPUSH
16904: CALL_OW 49
// end ;
16908: GO 16799
16910: POP
16911: POP
// for i := 1 to animalsAmount [ 4 ] do
16912: LD_ADDR_VAR 0 2
16916: PUSH
16917: DOUBLE
16918: LD_INT 1
16920: DEC
16921: ST_TO_ADDR
16922: LD_EXP 45
16926: PUSH
16927: LD_INT 4
16929: ARRAY
16930: PUSH
16931: FOR_TO
16932: IFFALSE 17042
// begin uc_side = 0 ;
16934: LD_ADDR_OWVAR 20
16938: PUSH
16939: LD_INT 0
16941: ST_TO_ADDR
// uc_nation = nation_nature ;
16942: LD_ADDR_OWVAR 21
16946: PUSH
16947: LD_INT 0
16949: ST_TO_ADDR
// hc_class = 21 ;
16950: LD_ADDR_OWVAR 28
16954: PUSH
16955: LD_INT 21
16957: ST_TO_ADDR
// hc_skills = [ animalsStats [ 1 ] , animalsStats [ 2 ] , animalsStats [ 3 ] , animalsStats [ 4 ] ] ;
16958: LD_ADDR_OWVAR 31
16962: PUSH
16963: LD_EXP 46
16967: PUSH
16968: LD_INT 1
16970: ARRAY
16971: PUSH
16972: LD_EXP 46
16976: PUSH
16977: LD_INT 2
16979: ARRAY
16980: PUSH
16981: LD_EXP 46
16985: PUSH
16986: LD_INT 3
16988: ARRAY
16989: PUSH
16990: LD_EXP 46
16994: PUSH
16995: LD_INT 4
16997: ARRAY
16998: PUSH
16999: EMPTY
17000: LIST
17001: LIST
17002: LIST
17003: LIST
17004: ST_TO_ADDR
// hc_agressivity = animalsAgression ;
17005: LD_ADDR_OWVAR 35
17009: PUSH
17010: LD_EXP 47
17014: ST_TO_ADDR
// un = CreateHuman ;
17015: LD_ADDR_VAR 0 3
17019: PUSH
17020: CALL_OW 44
17024: ST_TO_ADDR
// PlaceUnitArea ( un , NatureArea , false ) ;
17025: LD_VAR 0 3
17029: PPUSH
17030: LD_INT 21
17032: PPUSH
17033: LD_INT 0
17035: PPUSH
17036: CALL_OW 49
// end ;
17040: GO 16931
17042: POP
17043: POP
// end ; end_of_file
17044: LD_VAR 0 1
17048: RET
// every 0 0$1 trigger spawnCrates do var i , unit , carryCratesEngs , playerEngs , spawnNextCrates ;
17049: LD_EXP 21
17053: IFFALSE 17282
17055: GO 17057
17057: DISABLE
17058: LD_INT 0
17060: PPUSH
17061: PPUSH
17062: PPUSH
17063: PPUSH
17064: PPUSH
// begin repeat playerEngs = FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_class , class_engineer ] ] ) ;
17065: LD_ADDR_VAR 0 4
17069: PUSH
17070: LD_INT 22
17072: PUSH
17073: LD_INT 3
17075: PUSH
17076: EMPTY
17077: LIST
17078: LIST
17079: PUSH
17080: LD_INT 21
17082: PUSH
17083: LD_INT 1
17085: PUSH
17086: EMPTY
17087: LIST
17088: LIST
17089: PUSH
17090: LD_INT 25
17092: PUSH
17093: LD_INT 2
17095: PUSH
17096: EMPTY
17097: LIST
17098: LIST
17099: PUSH
17100: EMPTY
17101: LIST
17102: LIST
17103: LIST
17104: PPUSH
17105: CALL_OW 69
17109: ST_TO_ADDR
// wait ( 0 0$20 ) ;
17110: LD_INT 700
17112: PPUSH
17113: CALL_OW 67
// carryCratesEngs = 0 ;
17117: LD_ADDR_VAR 0 3
17121: PUSH
17122: LD_INT 0
17124: ST_TO_ADDR
// for unit in playerEngs do
17125: LD_ADDR_VAR 0 2
17129: PUSH
17130: LD_VAR 0 4
17134: PUSH
17135: FOR_IN
17136: IFFALSE 17164
// carryCratesEngs = carryCratesEngs + GetCargo ( unit , mat_cans ) ;
17138: LD_ADDR_VAR 0 3
17142: PUSH
17143: LD_VAR 0 3
17147: PUSH
17148: LD_VAR 0 2
17152: PPUSH
17153: LD_INT 1
17155: PPUSH
17156: CALL_OW 289
17160: PLUS
17161: ST_TO_ADDR
17162: GO 17135
17164: POP
17165: POP
// if GetResourceType ( GetBase ( beria ) , mat_cans ) < 50 and ( GetResourceArea ( beriaBaseArea , mat_cans ) * 10 ) + GetResourceType ( GetBase ( beria ) , mat_cans ) + carryCratesEngs < 50 then
17166: LD_INT 106
17168: PPUSH
17169: CALL_OW 274
17173: PPUSH
17174: LD_INT 1
17176: PPUSH
17177: CALL_OW 275
17181: PUSH
17182: LD_INT 50
17184: LESS
17185: PUSH
17186: LD_INT 8
17188: PPUSH
17189: LD_INT 1
17191: PPUSH
17192: CALL_OW 287
17196: PUSH
17197: LD_INT 10
17199: MUL
17200: PUSH
17201: LD_INT 106
17203: PPUSH
17204: CALL_OW 274
17208: PPUSH
17209: LD_INT 1
17211: PPUSH
17212: CALL_OW 275
17216: PLUS
17217: PUSH
17218: LD_VAR 0 3
17222: PLUS
17223: PUSH
17224: LD_INT 50
17226: LESS
17227: AND
17228: IFFALSE 17240
// spawnNextCrates = true else
17230: LD_ADDR_VAR 0 5
17234: PUSH
17235: LD_INT 1
17237: ST_TO_ADDR
17238: GO 17248
// spawnNextCrates = false ;
17240: LD_ADDR_VAR 0 5
17244: PUSH
17245: LD_INT 0
17247: ST_TO_ADDR
// if spawnNextCrates then
17248: LD_VAR 0 5
17252: IFFALSE 17275
// CreateCratesArea ( rand ( 1 , 5 ) , CratesArea , true ) ;
17254: LD_INT 1
17256: PPUSH
17257: LD_INT 5
17259: PPUSH
17260: CALL_OW 12
17264: PPUSH
17265: LD_INT 26
17267: PPUSH
17268: LD_INT 1
17270: PPUSH
17271: CALL_OW 55
// until not spawnCrates ;
17275: LD_EXP 21
17279: NOT
17280: IFFALSE 17065
// end ; end_of_file
17282: PPOPN 5
17284: END
// on BuildingStarted ( building , builder ) do begin if GetBType ( building ) = b_lab and FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_lab ] ] ) > 1 and not canBuildSameBuilding then
17285: LD_VAR 0 1
17289: PPUSH
17290: CALL_OW 266
17294: PUSH
17295: LD_INT 6
17297: EQUAL
17298: PUSH
17299: LD_INT 22
17301: PUSH
17302: LD_INT 3
17304: PUSH
17305: EMPTY
17306: LIST
17307: LIST
17308: PUSH
17309: LD_INT 30
17311: PUSH
17312: LD_INT 6
17314: PUSH
17315: EMPTY
17316: LIST
17317: LIST
17318: PUSH
17319: EMPTY
17320: LIST
17321: LIST
17322: PPUSH
17323: CALL_OW 69
17327: PUSH
17328: LD_INT 1
17330: GREATER
17331: AND
17332: PUSH
17333: LD_EXP 11
17337: NOT
17338: AND
17339: IFFALSE 17350
// Dial_StopConstructAgainSameBuilding ( building ) ;
17341: LD_VAR 0 1
17345: PPUSH
17346: CALL 9051 0 1
// if GetBType ( building ) = b_workshop and FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_workshop ] ] ) > 1 and not canBuildSameBuilding then
17350: LD_VAR 0 1
17354: PPUSH
17355: CALL_OW 266
17359: PUSH
17360: LD_INT 2
17362: EQUAL
17363: PUSH
17364: LD_INT 22
17366: PUSH
17367: LD_INT 3
17369: PUSH
17370: EMPTY
17371: LIST
17372: LIST
17373: PUSH
17374: LD_INT 30
17376: PUSH
17377: LD_INT 2
17379: PUSH
17380: EMPTY
17381: LIST
17382: LIST
17383: PUSH
17384: EMPTY
17385: LIST
17386: LIST
17387: PPUSH
17388: CALL_OW 69
17392: PUSH
17393: LD_INT 1
17395: GREATER
17396: AND
17397: PUSH
17398: LD_EXP 11
17402: NOT
17403: AND
17404: IFFALSE 17415
// Dial_StopConstructAgainSameBuilding ( building ) ;
17406: LD_VAR 0 1
17410: PPUSH
17411: CALL 9051 0 1
// if GetSide ( building ) = 3 and GetBType ( building ) in [ b_oil_power , b_armoury , b_breastwork ] and IsInArea ( building , BeriaBaseArea ) then
17415: LD_VAR 0 1
17419: PPUSH
17420: CALL_OW 255
17424: PUSH
17425: LD_INT 3
17427: EQUAL
17428: PUSH
17429: LD_VAR 0 1
17433: PPUSH
17434: CALL_OW 266
17438: PUSH
17439: LD_INT 26
17441: PUSH
17442: LD_INT 4
17444: PUSH
17445: LD_INT 31
17447: PUSH
17448: EMPTY
17449: LIST
17450: LIST
17451: LIST
17452: IN
17453: AND
17454: PUSH
17455: LD_VAR 0 1
17459: PPUSH
17460: LD_INT 8
17462: PPUSH
17463: CALL_OW 308
17467: AND
17468: IFFALSE 17479
// Dial_StopConstructAgainSameBuilding ( building ) ;
17470: LD_VAR 0 1
17474: PPUSH
17475: CALL 9051 0 1
// end ;
17479: PPOPN 2
17481: END
// on BuildingComplete ( building ) do var sold , platSold ;
17482: LD_INT 0
17484: PPUSH
17485: PPUSH
// begin if GetSide ( building ) = 3 and GetBType ( building ) = b_lab and not labConstructed then
17486: LD_VAR 0 1
17490: PPUSH
17491: CALL_OW 255
17495: PUSH
17496: LD_INT 3
17498: EQUAL
17499: PUSH
17500: LD_VAR 0 1
17504: PPUSH
17505: CALL_OW 266
17509: PUSH
17510: LD_INT 6
17512: EQUAL
17513: AND
17514: PUSH
17515: LD_EXP 8
17519: NOT
17520: AND
17521: IFFALSE 17527
// Dial_LabConstructed ;
17523: CALL 8901 0 0
// if GetSide ( building ) = 3 and GetBType ( building ) = b_workshop and not workshopConstructed then
17527: LD_VAR 0 1
17531: PPUSH
17532: CALL_OW 255
17536: PUSH
17537: LD_INT 3
17539: EQUAL
17540: PUSH
17541: LD_VAR 0 1
17545: PPUSH
17546: CALL_OW 266
17550: PUSH
17551: LD_INT 2
17553: EQUAL
17554: AND
17555: PUSH
17556: LD_EXP 9
17560: NOT
17561: AND
17562: IFFALSE 17568
// Dial_WorkshopConstructed ;
17564: CALL 8976 0 0
// if GetSide ( building ) = 6 then
17568: LD_VAR 0 1
17572: PPUSH
17573: CALL_OW 255
17577: PUSH
17578: LD_INT 6
17580: EQUAL
17581: IFFALSE 17792
// begin if GetBType ( building ) = b_breastwork and IsInArea ( building , KirovBaseArea ) then
17583: LD_VAR 0 1
17587: PPUSH
17588: CALL_OW 266
17592: PUSH
17593: LD_INT 31
17595: EQUAL
17596: PUSH
17597: LD_VAR 0 1
17601: PPUSH
17602: LD_INT 9
17604: PPUSH
17605: CALL_OW 308
17609: AND
17610: IFFALSE 17661
// begin if UnitsInside ( ru2_arm2 ) then
17612: LD_INT 209
17614: PPUSH
17615: CALL_OW 313
17619: IFFALSE 17661
// begin sold = UnitsInside ( ru2_arm2 ) [ 1 ] ;
17621: LD_ADDR_VAR 0 2
17625: PUSH
17626: LD_INT 209
17628: PPUSH
17629: CALL_OW 313
17633: PUSH
17634: LD_INT 1
17636: ARRAY
17637: ST_TO_ADDR
// ComExitBuilding ( sold ) ;
17638: LD_VAR 0 2
17642: PPUSH
17643: CALL_OW 122
// AddComEnterUnit ( sold , building ) ;
17647: LD_VAR 0 2
17651: PPUSH
17652: LD_VAR 0 1
17656: PPUSH
17657: CALL_OW 180
// end ; end ; if GetBType ( building ) = b_breastwork and IsInArea ( building , BeriaBaseArea ) then
17661: LD_VAR 0 1
17665: PPUSH
17666: CALL_OW 266
17670: PUSH
17671: LD_INT 31
17673: EQUAL
17674: PUSH
17675: LD_VAR 0 1
17679: PPUSH
17680: LD_INT 8
17682: PPUSH
17683: CALL_OW 308
17687: AND
17688: IFFALSE 17724
// begin sold = NearestUnitToUnit ( platSoldiers , building ) ;
17690: LD_ADDR_VAR 0 2
17694: PUSH
17695: LD_EXP 77
17699: PPUSH
17700: LD_VAR 0 1
17704: PPUSH
17705: CALL_OW 74
17709: ST_TO_ADDR
// ComEnterUnit ( sold , building ) ;
17710: LD_VAR 0 2
17714: PPUSH
17715: LD_VAR 0 1
17719: PPUSH
17720: CALL_OW 120
// end ; if GetBType ( building ) = b_workshop then
17724: LD_VAR 0 1
17728: PPUSH
17729: CALL_OW 266
17733: PUSH
17734: LD_INT 2
17736: EQUAL
17737: IFFALSE 17792
// begin ComExitBuilding ( UnitFilter ( otherKirovUnits , [ f_class , class_mechanic ] ) ) ;
17739: LD_EXP 69
17743: PPUSH
17744: LD_INT 25
17746: PUSH
17747: LD_INT 3
17749: PUSH
17750: EMPTY
17751: LIST
17752: LIST
17753: PPUSH
17754: CALL_OW 72
17758: PPUSH
17759: CALL_OW 122
// AddComEnterUnit ( UnitFilter ( otherKirovUnits , [ f_class , class_mechanic ] ) , building ) ;
17763: LD_EXP 69
17767: PPUSH
17768: LD_INT 25
17770: PUSH
17771: LD_INT 3
17773: PUSH
17774: EMPTY
17775: LIST
17776: LIST
17777: PPUSH
17778: CALL_OW 72
17782: PPUSH
17783: LD_VAR 0 1
17787: PPUSH
17788: CALL_OW 180
// end ; end ; end ;
17792: PPOPN 3
17794: END
// on ResearchComplete ( tech , building ) do begin if tech = tech_oilEng and GetSide ( building ) = 3 then
17795: LD_VAR 0 1
17799: PUSH
17800: LD_INT 47
17802: EQUAL
17803: PUSH
17804: LD_VAR 0 2
17808: PPUSH
17809: CALL_OW 255
17813: PUSH
17814: LD_INT 3
17816: EQUAL
17817: AND
17818: IFFALSE 17828
// engineResearched = true ;
17820: LD_ADDR_EXP 10
17824: PUSH
17825: LD_INT 1
17827: ST_TO_ADDR
// if tech = tech_Tech1 then
17828: LD_VAR 0 1
17832: PUSH
17833: LD_INT 48
17835: EQUAL
17836: IFFALSE 17858
// begin wait ( 0 0$5 ) ;
17838: LD_INT 175
17840: PPUSH
17841: CALL_OW 67
// SetSpecResearch ( ru_lab , 1500 , false ) ;
17845: LD_INT 83
17847: PPUSH
17848: LD_INT 1500
17850: PPUSH
17851: LD_INT 0
17853: PPUSH
17854: CALL_OW 486
// end ; end ;
17858: PPOPN 2
17860: END
// on VehicleConstructed ( vehicle , factory ) do begin if GetSide ( factory ) = your_side and IsOK ( factory ) and not constructedFirstVehicle and not construcMoreVehicles then
17861: LD_VAR 0 2
17865: PPUSH
17866: CALL_OW 255
17870: PUSH
17871: LD_OWVAR 2
17875: EQUAL
17876: PUSH
17877: LD_VAR 0 2
17881: PPUSH
17882: CALL_OW 302
17886: AND
17887: PUSH
17888: LD_EXP 12
17892: NOT
17893: AND
17894: PUSH
17895: LD_EXP 17
17899: NOT
17900: AND
17901: IFFALSE 17912
// Dial_FirstVehConstructed ( factory ) ;
17903: LD_VAR 0 2
17907: PPUSH
17908: CALL 9575 0 1
// if GetSide ( factory ) = your_side and not vehicleForKurin and not IsOK ( firstVeh ) then
17912: LD_VAR 0 2
17916: PPUSH
17917: CALL_OW 255
17921: PUSH
17922: LD_OWVAR 2
17926: EQUAL
17927: PUSH
17928: LD_EXP 14
17932: NOT
17933: AND
17934: PUSH
17935: LD_EXP 13
17939: PPUSH
17940: CALL_OW 302
17944: NOT
17945: AND
17946: IFFALSE 17958
// firstVeh = vehicle ;
17948: LD_ADDR_EXP 13
17952: PUSH
17953: LD_VAR 0 1
17957: ST_TO_ADDR
// if GetSide ( factory ) = your_side and IsOK ( factory ) and construcMoreVehicles then
17958: LD_VAR 0 2
17962: PPUSH
17963: CALL_OW 255
17967: PUSH
17968: LD_OWVAR 2
17972: EQUAL
17973: PUSH
17974: LD_VAR 0 2
17978: PPUSH
17979: CALL_OW 302
17983: AND
17984: PUSH
17985: LD_EXP 17
17989: AND
17990: IFFALSE 18006
// constructedVehiclesCounter = constructedVehiclesCounter + 1 ;
17992: LD_ADDR_EXP 18
17996: PUSH
17997: LD_EXP 18
18001: PUSH
18002: LD_INT 1
18004: PLUS
18005: ST_TO_ADDR
// if GetSide ( factory ) = your_side and GetNation ( factory ) = nation_russian then
18006: LD_VAR 0 2
18010: PPUSH
18011: CALL_OW 255
18015: PUSH
18016: LD_OWVAR 2
18020: EQUAL
18021: PUSH
18022: LD_VAR 0 2
18026: PPUSH
18027: CALL_OW 248
18031: PUSH
18032: LD_INT 3
18034: EQUAL
18035: AND
18036: IFFALSE 18052
// achievement_ConstructVehicles = achievement_ConstructVehicles + 1 ;
18038: LD_ADDR_EXP 44
18042: PUSH
18043: LD_EXP 44
18047: PUSH
18048: LD_INT 1
18050: PLUS
18051: ST_TO_ADDR
// end ;
18052: PPOPN 2
18054: END
// on CrateSpawn ( unit , x , y , amount , mode ) do begin if not canExitBase and mode = true then
18055: LD_EXP 19
18059: NOT
18060: PUSH
18061: LD_VAR 0 5
18065: PUSH
18066: LD_INT 1
18068: EQUAL
18069: AND
18070: IFFALSE 18086
// Dial_NewCrates ( x , y ) ;
18072: LD_VAR 0 2
18076: PPUSH
18077: LD_VAR 0 3
18081: PPUSH
18082: CALL 9520 0 2
// end ;
18086: PPOPN 5
18088: END
// on Command ( com ) do var i , j , temp , order , destiny ;
18089: LD_INT 0
18091: PPUSH
18092: PPUSH
18093: PPUSH
18094: PPUSH
18095: PPUSH
// begin for i in FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) do
18096: LD_ADDR_VAR 0 2
18100: PUSH
18101: LD_INT 22
18103: PUSH
18104: LD_INT 3
18106: PUSH
18107: EMPTY
18108: LIST
18109: LIST
18110: PUSH
18111: LD_INT 21
18113: PUSH
18114: LD_INT 1
18116: PUSH
18117: EMPTY
18118: LIST
18119: LIST
18120: PUSH
18121: EMPTY
18122: LIST
18123: LIST
18124: PPUSH
18125: CALL_OW 69
18129: PUSH
18130: FOR_IN
18131: IFFALSE 18324
// if GetTaskList ( i ) > 0 then
18133: LD_VAR 0 2
18137: PPUSH
18138: CALL_OW 437
18142: PUSH
18143: LD_INT 0
18145: GREATER
18146: IFFALSE 18322
// for j = 1 to GetTaskList ( i ) do
18148: LD_ADDR_VAR 0 3
18152: PUSH
18153: DOUBLE
18154: LD_INT 1
18156: DEC
18157: ST_TO_ADDR
18158: LD_VAR 0 2
18162: PPUSH
18163: CALL_OW 437
18167: PUSH
18168: FOR_TO
18169: IFFALSE 18320
// begin temp = GetTaskList ( i ) [ j ] [ 4 ] ;
18171: LD_ADDR_VAR 0 4
18175: PUSH
18176: LD_VAR 0 2
18180: PPUSH
18181: CALL_OW 437
18185: PUSH
18186: LD_VAR 0 3
18190: ARRAY
18191: PUSH
18192: LD_INT 4
18194: ARRAY
18195: ST_TO_ADDR
// if temp = kirov or ( GetSide ( temp ) = 6 and GetTaskList ( i ) [ j ] [ 1 ] = e and GetType ( temp ) = unit_vehicle ) then
18196: LD_VAR 0 4
18200: PUSH
18201: LD_INT 71
18203: EQUAL
18204: PUSH
18205: LD_VAR 0 4
18209: PPUSH
18210: CALL_OW 255
18214: PUSH
18215: LD_INT 6
18217: EQUAL
18218: PUSH
18219: LD_VAR 0 2
18223: PPUSH
18224: CALL_OW 437
18228: PUSH
18229: LD_VAR 0 3
18233: ARRAY
18234: PUSH
18235: LD_INT 1
18237: ARRAY
18238: PUSH
18239: LD_STRING e
18241: EQUAL
18242: AND
18243: PUSH
18244: LD_VAR 0 4
18248: PPUSH
18249: CALL_OW 247
18253: PUSH
18254: LD_INT 2
18256: EQUAL
18257: AND
18258: OR
18259: IFFALSE 18272
// SetTaskList ( i , [ ] ) ;
18261: LD_VAR 0 2
18265: PPUSH
18266: EMPTY
18267: PPUSH
18268: CALL_OW 446
// if temp = beria and GetTaskList ( i ) [ j ] [ 1 ] = Y then
18272: LD_VAR 0 4
18276: PUSH
18277: LD_INT 106
18279: EQUAL
18280: PUSH
18281: LD_VAR 0 2
18285: PPUSH
18286: CALL_OW 437
18290: PUSH
18291: LD_VAR 0 3
18295: ARRAY
18296: PUSH
18297: LD_INT 1
18299: ARRAY
18300: PUSH
18301: LD_STRING Y
18303: EQUAL
18304: AND
18305: IFFALSE 18318
// SetTaskList ( i , [ ] ) ;
18307: LD_VAR 0 2
18311: PPUSH
18312: EMPTY
18313: PPUSH
18314: CALL_OW 446
// end ;
18318: GO 18168
18320: POP
18321: POP
18322: GO 18130
18324: POP
18325: POP
// end ;
18326: PPOPN 6
18328: END
// on UnitDestroyed ( unit ) do begin if GetSide ( unit ) = 1 and GetType ( unit ) = unit_human then
18329: LD_VAR 0 1
18333: PPUSH
18334: CALL_OW 255
18338: PUSH
18339: LD_INT 1
18341: EQUAL
18342: PUSH
18343: LD_VAR 0 1
18347: PPUSH
18348: CALL_OW 247
18352: PUSH
18353: LD_INT 1
18355: EQUAL
18356: AND
18357: IFFALSE 18415
// begin if unit in amLeftEngs then
18359: LD_VAR 0 1
18363: PUSH
18364: LD_EXP 86
18368: IN
18369: IFFALSE 18387
// amLeftEngs = amLeftEngs diff unit ;
18371: LD_ADDR_EXP 86
18375: PUSH
18376: LD_EXP 86
18380: PUSH
18381: LD_VAR 0 1
18385: DIFF
18386: ST_TO_ADDR
// if unit in amRightEngs then
18387: LD_VAR 0 1
18391: PUSH
18392: LD_EXP 87
18396: IN
18397: IFFALSE 18415
// amRightEngs = amRightEngs diff unit ;
18399: LD_ADDR_EXP 87
18403: PUSH
18404: LD_EXP 87
18408: PUSH
18409: LD_VAR 0 1
18413: DIFF
18414: ST_TO_ADDR
// end ; if GetSide ( unit ) = 6 and GetType ( unit ) = unit_human then
18415: LD_VAR 0 1
18419: PPUSH
18420: CALL_OW 255
18424: PUSH
18425: LD_INT 6
18427: EQUAL
18428: PUSH
18429: LD_VAR 0 1
18433: PPUSH
18434: CALL_OW 247
18438: PUSH
18439: LD_INT 1
18441: EQUAL
18442: AND
18443: IFFALSE 18473
// if unit in belkovTeam then
18445: LD_VAR 0 1
18449: PUSH
18450: LD_EXP 73
18454: IN
18455: IFFALSE 18473
// belkovTeam = belkovTeam diff unit ;
18457: LD_ADDR_EXP 73
18461: PUSH
18462: LD_EXP 73
18466: PUSH
18467: LD_VAR 0 1
18471: DIFF
18472: ST_TO_ADDR
// if GetSide ( unit ) = 3 and GetType ( unit ) = unit_human then
18473: LD_VAR 0 1
18477: PPUSH
18478: CALL_OW 255
18482: PUSH
18483: LD_INT 3
18485: EQUAL
18486: PUSH
18487: LD_VAR 0 1
18491: PPUSH
18492: CALL_OW 247
18496: PUSH
18497: LD_INT 1
18499: EQUAL
18500: AND
18501: IFFALSE 18517
// lostComradesCounter = lostComradesCounter + 1 ;
18503: LD_ADDR_EXP 43
18507: PUSH
18508: LD_EXP 43
18512: PUSH
18513: LD_INT 1
18515: PLUS
18516: ST_TO_ADDR
// if unit = Burlak then
18517: LD_VAR 0 1
18521: PUSH
18522: LD_EXP 62
18526: EQUAL
18527: IFFALSE 18533
// BurlakIsDead ;
18529: CALL 19844 0 0
// if unit = Beria then
18533: LD_VAR 0 1
18537: PUSH
18538: LD_INT 106
18540: EQUAL
18541: IFFALSE 18547
// BaseDestroyed ;
18543: CALL 19874 0 0
// if unit in platSoldiers then
18547: LD_VAR 0 1
18551: PUSH
18552: LD_EXP 77
18556: IN
18557: IFFALSE 18575
// platSoldiers = platSoldiers diff unit ;
18559: LD_ADDR_EXP 77
18563: PUSH
18564: LD_EXP 77
18568: PUSH
18569: LD_VAR 0 1
18573: DIFF
18574: ST_TO_ADDR
// end ;
18575: PPOPN 1
18577: END
// on UnitGoesToRed ( unit ) do begin if GetSide ( unit ) = 1 and GetType ( unit ) = unit_building then
18578: LD_VAR 0 1
18582: PPUSH
18583: CALL_OW 255
18587: PUSH
18588: LD_INT 1
18590: EQUAL
18591: PUSH
18592: LD_VAR 0 1
18596: PPUSH
18597: CALL_OW 247
18601: PUSH
18602: LD_INT 3
18604: EQUAL
18605: AND
18606: IFFALSE 18664
// begin if unit in leftBunkers then
18608: LD_VAR 0 1
18612: PUSH
18613: LD_EXP 82
18617: IN
18618: IFFALSE 18636
// leftBunkers = leftBunkers diff unit ;
18620: LD_ADDR_EXP 82
18624: PUSH
18625: LD_EXP 82
18629: PUSH
18630: LD_VAR 0 1
18634: DIFF
18635: ST_TO_ADDR
// if unit in rightBunkers then
18636: LD_VAR 0 1
18640: PUSH
18641: LD_EXP 83
18645: IN
18646: IFFALSE 18664
// rightBunkers = rightBunkers diff unit ;
18648: LD_ADDR_EXP 83
18652: PUSH
18653: LD_EXP 83
18657: PUSH
18658: LD_VAR 0 1
18662: DIFF
18663: ST_TO_ADDR
// end ; if GetSide ( unit ) = 1 and GetType ( unit ) = unit_human then
18664: LD_VAR 0 1
18668: PPUSH
18669: CALL_OW 255
18673: PUSH
18674: LD_INT 1
18676: EQUAL
18677: PUSH
18678: LD_VAR 0 1
18682: PPUSH
18683: CALL_OW 247
18687: PUSH
18688: LD_INT 1
18690: EQUAL
18691: AND
18692: IFFALSE 18722
// if unit in trapTeam then
18694: LD_VAR 0 1
18698: PUSH
18699: LD_EXP 81
18703: IN
18704: IFFALSE 18722
// trapTeam = trapTeam diff unit ;
18706: LD_ADDR_EXP 81
18710: PUSH
18711: LD_EXP 81
18715: PUSH
18716: LD_VAR 0 1
18720: DIFF
18721: ST_TO_ADDR
// end ;
18722: PPOPN 1
18724: END
// on VehicleCaptured ( new_vehicle , old_vehicle , original_side , human ) do begin if original_side = 1 then
18725: LD_VAR 0 3
18729: PUSH
18730: LD_INT 1
18732: EQUAL
18733: IFFALSE 18743
// captureBelkovVehicle = true ;
18735: LD_ADDR_EXP 38
18739: PUSH
18740: LD_INT 1
18742: ST_TO_ADDR
// if original_side = 6 then
18743: LD_VAR 0 3
18747: PUSH
18748: LD_INT 6
18750: EQUAL
18751: IFFALSE 18795
// begin ComMoveXY ( [ new_vehicle , old_vehicle ] , 118 , 25 ) ;
18753: LD_VAR 0 1
18757: PUSH
18758: LD_VAR 0 2
18762: PUSH
18763: EMPTY
18764: LIST
18765: LIST
18766: PPUSH
18767: LD_INT 118
18769: PPUSH
18770: LD_INT 25
18772: PPUSH
18773: CALL_OW 111
// ComFree ( [ new_vehicle , old_vehicle ] ) ;
18777: LD_VAR 0 1
18781: PUSH
18782: LD_VAR 0 2
18786: PUSH
18787: EMPTY
18788: LIST
18789: LIST
18790: PPUSH
18791: CALL_OW 139
// end ; end ;
18795: PPOPN 4
18797: END
// on Contact ( side1 , side2 ) do begin if side1 = 3 and side2 = 6 then
18798: LD_VAR 0 1
18802: PUSH
18803: LD_INT 3
18805: EQUAL
18806: PUSH
18807: LD_VAR 0 2
18811: PUSH
18812: LD_INT 6
18814: EQUAL
18815: AND
18816: IFFALSE 18822
// AttackComrades ;
18818: CALL 19859 0 0
// end ;
18822: PPOPN 2
18824: END
// on BuildingCaptured ( building , side , human ) do begin if side = 6 then
18825: LD_VAR 0 2
18829: PUSH
18830: LD_INT 6
18832: EQUAL
18833: IFFALSE 18847
// SetSide ( building , 3 ) ;
18835: LD_VAR 0 1
18839: PPUSH
18840: LD_INT 3
18842: PPUSH
18843: CALL_OW 235
// end ; end_of_file
18847: PPOPN 3
18849: END
// every 0 0$5 trigger backToBeria2 and FilterUnitsExceptArea ( BeriaBaseArea , [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) = 0 do
18850: LD_EXP 16
18854: PUSH
18855: LD_INT 8
18857: PPUSH
18858: LD_INT 22
18860: PUSH
18861: LD_INT 3
18863: PUSH
18864: EMPTY
18865: LIST
18866: LIST
18867: PUSH
18868: LD_INT 21
18870: PUSH
18871: LD_INT 1
18873: PUSH
18874: EMPTY
18875: LIST
18876: LIST
18877: PUSH
18878: EMPTY
18879: LIST
18880: LIST
18881: PPUSH
18882: CALL_OW 71
18886: PUSH
18887: LD_INT 0
18889: EQUAL
18890: AND
18891: IFFALSE 18992
18893: GO 18895
18895: DISABLE
// begin enable ;
18896: ENABLE
// if not saveBelkovObjective and ( IsOk ( Belkov ) or IsOk ( Belkov2 ) ) then
18897: LD_EXP 36
18901: NOT
18902: PUSH
18903: LD_EXP 64
18907: PPUSH
18908: CALL_OW 302
18912: PUSH
18913: LD_EXP 68
18917: PPUSH
18918: CALL_OW 302
18922: OR
18923: AND
18924: IFFALSE 18971
// begin case Query ( QContMission ) of 1 :
18926: LD_STRING QContMission
18928: PPUSH
18929: CALL_OW 97
18933: PUSH
18934: LD_INT 1
18936: DOUBLE
18937: EQUAL
18938: IFTRUE 18942
18940: GO 18949
18942: POP
// begin FinishMission ;
18943: CALL 18993 0 0
// end ; 2 :
18947: GO 18969
18949: LD_INT 2
18951: DOUBLE
18952: EQUAL
18953: IFTRUE 18957
18955: GO 18968
18957: POP
// begin saveBelkovObjective = true ;
18958: LD_ADDR_EXP 36
18962: PUSH
18963: LD_INT 1
18965: ST_TO_ADDR
// end ; end ;
18966: GO 18969
18968: POP
// end else
18969: GO 18982
// if not belkovSaved then
18971: LD_EXP 37
18975: NOT
18976: IFFALSE 18982
// FinishMission ;
18978: CALL 18993 0 0
// if belkovSaved then
18982: LD_EXP 37
18986: IFFALSE 18992
// FinishMission ;
18988: CALL 18993 0 0
// end ;
18992: END
// function FinishMission ; begin
18993: LD_INT 0
18995: PPUSH
// SetRewards ;
18996: CALL 19017 0 0
// SavePlayerCharacters ;
19000: CALL 19307 0 0
// SaveGlobalVariables ;
19004: CALL 19524 0 0
// YouWin ;
19008: CALL_OW 103
// end ;
19012: LD_VAR 0 1
19016: RET
// function SetRewards ; begin
19017: LD_INT 0
19019: PPUSH
// case initiative of 1 :
19020: LD_EXP 42
19024: PUSH
19025: LD_INT 1
19027: DOUBLE
19028: EQUAL
19029: IFTRUE 19033
19031: GO 19046
19033: POP
// AddMedal ( Initiative , 1 ) ; 2 :
19034: LD_STRING Initiative
19036: PPUSH
19037: LD_INT 1
19039: PPUSH
19040: CALL_OW 101
19044: GO 19091
19046: LD_INT 2
19048: DOUBLE
19049: EQUAL
19050: IFTRUE 19054
19052: GO 19068
19054: POP
// AddMedal ( Initiative , - 2 ) ; 3 :
19055: LD_STRING Initiative
19057: PPUSH
19058: LD_INT 2
19060: NEG
19061: PPUSH
19062: CALL_OW 101
19066: GO 19091
19068: LD_INT 3
19070: DOUBLE
19071: EQUAL
19072: IFTRUE 19076
19074: GO 19090
19076: POP
// AddMedal ( Initiative , - 1 ) ; end ;
19077: LD_STRING Initiative
19079: PPUSH
19080: LD_INT 1
19082: NEG
19083: PPUSH
19084: CALL_OW 101
19088: GO 19091
19090: POP
// if belkovSaved and ( IsOK ( Belkov ) or IsOK ( Belkov2 ) ) then
19091: LD_EXP 37
19095: PUSH
19096: LD_EXP 64
19100: PPUSH
19101: CALL_OW 302
19105: PUSH
19106: LD_EXP 68
19110: PPUSH
19111: CALL_OW 302
19115: OR
19116: AND
19117: IFFALSE 19129
// AddMedal ( Belkov , 1 ) ;
19119: LD_STRING Belkov
19121: PPUSH
19122: LD_INT 1
19124: PPUSH
19125: CALL_OW 101
// if not belkovSaved and not saveBelkovObjective then
19129: LD_EXP 37
19133: NOT
19134: PUSH
19135: LD_EXP 36
19139: NOT
19140: AND
19141: IFFALSE 19154
// AddMedal ( Belkov , - 1 ) ;
19143: LD_STRING Belkov
19145: PPUSH
19146: LD_INT 1
19148: NEG
19149: PPUSH
19150: CALL_OW 101
// if not belkovSaved and saveBelkovObjective then
19154: LD_EXP 37
19158: NOT
19159: PUSH
19160: LD_EXP 36
19164: AND
19165: IFFALSE 19178
// AddMedal ( Belkov , - 2 ) ;
19167: LD_STRING Belkov
19169: PPUSH
19170: LD_INT 2
19172: NEG
19173: PPUSH
19174: CALL_OW 101
// if belkovSaved and ( belkovReturn and IsDead ( Belkov ) ) or ( not belkovReturn and IsDead ( Belkov2 ) ) then
19178: LD_EXP 37
19182: PUSH
19183: LD_EXP 6
19187: PUSH
19188: LD_EXP 64
19192: PPUSH
19193: CALL_OW 301
19197: AND
19198: AND
19199: PUSH
19200: LD_EXP 6
19204: NOT
19205: PUSH
19206: LD_EXP 68
19210: PPUSH
19211: CALL_OW 301
19215: AND
19216: OR
19217: IFFALSE 19230
// AddMedal ( Belkov , - 2 ) ;
19219: LD_STRING Belkov
19221: PPUSH
19222: LD_INT 2
19224: NEG
19225: PPUSH
19226: CALL_OW 101
// if lostComradesCounter = 0 then
19230: LD_EXP 43
19234: PUSH
19235: LD_INT 0
19237: EQUAL
19238: IFFALSE 19252
// AddMedal ( NoLosses , 1 ) else
19240: LD_STRING NoLosses
19242: PPUSH
19243: LD_INT 1
19245: PPUSH
19246: CALL_OW 101
19250: GO 19262
// AddMedal ( NoLosses , 0 ) ;
19252: LD_STRING NoLosses
19254: PPUSH
19255: LD_INT 0
19257: PPUSH
19258: CALL_OW 101
// GiveMedals ( Main ) ;
19262: LD_STRING Main
19264: PPUSH
19265: CALL_OW 102
// RewardPeople ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) ) ;
19269: LD_INT 22
19271: PUSH
19272: LD_INT 3
19274: PUSH
19275: EMPTY
19276: LIST
19277: LIST
19278: PUSH
19279: LD_INT 21
19281: PUSH
19282: LD_INT 1
19284: PUSH
19285: EMPTY
19286: LIST
19287: LIST
19288: PUSH
19289: EMPTY
19290: LIST
19291: LIST
19292: PPUSH
19293: CALL_OW 69
19297: PPUSH
19298: CALL_OW 43
// end ;
19302: LD_VAR 0 1
19306: RET
// function SavePlayerCharacters ; var othersYour ; begin
19307: LD_INT 0
19309: PPUSH
19310: PPUSH
// ExtSaveCharacter ( Burlak , Burlak , 3 ) ;
19311: LD_EXP 62
19315: PPUSH
19316: LD_STRING Burlak
19318: PPUSH
19319: LD_INT 3
19321: PPUSH
19322: CALL 4272 0 3
// ExtSaveCharacter ( Gnyevko , Gnyevko , 3 ) ;
19326: LD_EXP 63
19330: PPUSH
19331: LD_STRING Gnyevko
19333: PPUSH
19334: LD_INT 3
19336: PPUSH
19337: CALL 4272 0 3
// ExtSaveCharacter ( Kovalyuk , Kovalyuk , 3 ) ;
19341: LD_EXP 70
19345: PPUSH
19346: LD_STRING Kovalyuk
19348: PPUSH
19349: LD_INT 3
19351: PPUSH
19352: CALL 4272 0 3
// ExtSaveCharacter ( Belkov , Belkov , 3 ) ;
19356: LD_EXP 64
19360: PPUSH
19361: LD_STRING Belkov
19363: PPUSH
19364: LD_INT 3
19366: PPUSH
19367: CALL 4272 0 3
// ExtSaveCharacter ( Belkov2 , Belkov2 , 3 ) ;
19371: LD_EXP 68
19375: PPUSH
19376: LD_STRING Belkov2
19378: PPUSH
19379: LD_INT 3
19381: PPUSH
19382: CALL 4272 0 3
// ExtSaveCharacter ( Kirilenkova , Kirilenkova , 3 ) ;
19386: LD_EXP 65
19390: PPUSH
19391: LD_STRING Kirilenkova
19393: PPUSH
19394: LD_INT 3
19396: PPUSH
19397: CALL 4272 0 3
// othersYour = FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) diff [ Burlak , Gnyevko , Belkov , Belkov2 , Kovalyuk , Kirilenkova ] ;
19401: LD_ADDR_VAR 0 2
19405: PUSH
19406: LD_INT 22
19408: PUSH
19409: LD_INT 3
19411: PUSH
19412: EMPTY
19413: LIST
19414: LIST
19415: PUSH
19416: LD_INT 21
19418: PUSH
19419: LD_INT 1
19421: PUSH
19422: EMPTY
19423: LIST
19424: LIST
19425: PUSH
19426: EMPTY
19427: LIST
19428: LIST
19429: PPUSH
19430: CALL_OW 69
19434: PUSH
19435: LD_EXP 62
19439: PUSH
19440: LD_EXP 63
19444: PUSH
19445: LD_EXP 64
19449: PUSH
19450: LD_EXP 68
19454: PUSH
19455: LD_EXP 70
19459: PUSH
19460: LD_EXP 65
19464: PUSH
19465: EMPTY
19466: LIST
19467: LIST
19468: LIST
19469: LIST
19470: LIST
19471: LIST
19472: DIFF
19473: ST_TO_ADDR
// ExtSaveCharacters ( othersYour , other_survivors , 3 ) ;
19474: LD_VAR 0 2
19478: PPUSH
19479: LD_STRING other_survivors
19481: PPUSH
19482: LD_INT 3
19484: PPUSH
19485: CALL 4328 0 3
// ExtSaveCharacters ( platSoldiers , other_beria , 6 ) ;
19489: LD_EXP 77
19493: PPUSH
19494: LD_STRING other_beria
19496: PPUSH
19497: LD_INT 6
19499: PPUSH
19500: CALL 4328 0 3
// ExtSaveCharacters ( otherKirovUnits , other_kirov , 6 ) ;
19504: LD_EXP 69
19508: PPUSH
19509: LD_STRING other_kirov
19511: PPUSH
19512: LD_INT 6
19514: PPUSH
19515: CALL 4328 0 3
// end ;
19519: LD_VAR 0 1
19523: RET
// function SaveGlobalVariables ; var vehicles ; begin
19524: LD_INT 0
19526: PPUSH
19527: PPUSH
// vehicles = FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_vehicle ] , [ f_ok ] ] ) ;
19528: LD_ADDR_VAR 0 2
19532: PUSH
19533: LD_INT 22
19535: PUSH
19536: LD_INT 3
19538: PUSH
19539: EMPTY
19540: LIST
19541: LIST
19542: PUSH
19543: LD_INT 21
19545: PUSH
19546: LD_INT 2
19548: PUSH
19549: EMPTY
19550: LIST
19551: LIST
19552: PUSH
19553: LD_INT 50
19555: PUSH
19556: EMPTY
19557: LIST
19558: PUSH
19559: EMPTY
19560: LIST
19561: LIST
19562: LIST
19563: PPUSH
19564: CALL_OW 69
19568: ST_TO_ADDR
// if vehicles then
19569: LD_VAR 0 2
19573: IFFALSE 19587
// SaveVehicles ( vehicles , 02_Vehicles_1 ) ;
19575: LD_VAR 0 2
19579: PPUSH
19580: LD_STRING 02_Vehicles_1
19582: PPUSH
19583: CALL 5359 0 2
// SaveBase ( FilterUnitsInArea ( BeriaBaseArea , [ [ f_type , unit_building ] ] ) , 02_BeriaBase_2 ) ;
19587: LD_INT 8
19589: PPUSH
19590: LD_INT 21
19592: PUSH
19593: LD_INT 3
19595: PUSH
19596: EMPTY
19597: LIST
19598: LIST
19599: PUSH
19600: EMPTY
19601: LIST
19602: PPUSH
19603: CALL_OW 70
19607: PPUSH
19608: LD_STRING 02_BeriaBase_2
19610: PPUSH
19611: CALL 5502 0 2
// SaveBase ( FilterUnitsInArea ( KirovBaseArea , [ [ f_side , 6 ] , [ f_type , unit_building ] ] ) , 02_KirovBase_3 ) ;
19615: LD_INT 9
19617: PPUSH
19618: LD_INT 22
19620: PUSH
19621: LD_INT 6
19623: PUSH
19624: EMPTY
19625: LIST
19626: LIST
19627: PUSH
19628: LD_INT 21
19630: PUSH
19631: LD_INT 3
19633: PUSH
19634: EMPTY
19635: LIST
19636: LIST
19637: PUSH
19638: EMPTY
19639: LIST
19640: LIST
19641: PPUSH
19642: CALL_OW 70
19646: PPUSH
19647: LD_STRING 02_KirovBase_3
19649: PPUSH
19650: CALL 5502 0 2
// SaveBase ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_building ] , [ f_ok ] , [ f_not , [ f_inarea , BeriaBaseArea ] ] ] ) , 02_OtherBuildings_4 ) ;
19654: LD_INT 22
19656: PUSH
19657: LD_INT 3
19659: PUSH
19660: EMPTY
19661: LIST
19662: LIST
19663: PUSH
19664: LD_INT 21
19666: PUSH
19667: LD_INT 3
19669: PUSH
19670: EMPTY
19671: LIST
19672: LIST
19673: PUSH
19674: LD_INT 50
19676: PUSH
19677: EMPTY
19678: LIST
19679: PUSH
19680: LD_INT 3
19682: PUSH
19683: LD_INT 95
19685: PUSH
19686: LD_INT 8
19688: PUSH
19689: EMPTY
19690: LIST
19691: LIST
19692: PUSH
19693: EMPTY
19694: LIST
19695: LIST
19696: PUSH
19697: EMPTY
19698: LIST
19699: LIST
19700: LIST
19701: LIST
19702: PPUSH
19703: CALL_OW 69
19707: PPUSH
19708: LD_STRING 02_OtherBuildings_4
19710: PPUSH
19711: CALL 5502 0 2
// SaveBase ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_building ] , [ f_ok ] , [ f_nation , nation_american ] ] ) , 02_AmericanBuildings_5 ) ;
19715: LD_INT 22
19717: PUSH
19718: LD_INT 1
19720: PUSH
19721: EMPTY
19722: LIST
19723: LIST
19724: PUSH
19725: LD_INT 21
19727: PUSH
19728: LD_INT 3
19730: PUSH
19731: EMPTY
19732: LIST
19733: LIST
19734: PUSH
19735: LD_INT 50
19737: PUSH
19738: EMPTY
19739: LIST
19740: PUSH
19741: LD_INT 23
19743: PUSH
19744: LD_INT 1
19746: PUSH
19747: EMPTY
19748: LIST
19749: LIST
19750: PUSH
19751: EMPTY
19752: LIST
19753: LIST
19754: LIST
19755: LIST
19756: PPUSH
19757: CALL_OW 69
19761: PPUSH
19762: LD_STRING 02_AmericanBuildings_5
19764: PPUSH
19765: CALL 5502 0 2
// SaveVariable ( meetBelkovBrother , 02_MeetBelkovBrother_6 ) ;
19769: LD_EXP 4
19773: PPUSH
19774: LD_STRING 02_MeetBelkovBrother_6
19776: PPUSH
19777: CALL_OW 39
// SaveVariable ( GetResourceType ( GetBase ( beria ) , mat_cans ) , 02_BeriaResourceCrates_7 ) ;
19781: LD_INT 106
19783: PPUSH
19784: CALL_OW 274
19788: PPUSH
19789: LD_INT 1
19791: PPUSH
19792: CALL_OW 275
19796: PPUSH
19797: LD_STRING 02_BeriaResourceCrates_7
19799: PPUSH
19800: CALL_OW 39
// SaveVariable ( GetResourceType ( GetBase ( beria ) , mat_oil ) , 02_BeriaResourceOil_8 ) ;
19804: LD_INT 106
19806: PPUSH
19807: CALL_OW 274
19811: PPUSH
19812: LD_INT 2
19814: PPUSH
19815: CALL_OW 275
19819: PPUSH
19820: LD_STRING 02_BeriaResourceOil_8
19822: PPUSH
19823: CALL_OW 39
// SaveVariable ( platonovOpinion , 02_PlatonovOpinion_9 ) ;
19827: LD_EXP 5
19831: PPUSH
19832: LD_STRING 02_PlatonovOpinion_9
19834: PPUSH
19835: CALL_OW 39
// end ; end_of_file
19839: LD_VAR 0 1
19843: RET
// export function BurlakIsDead ; begin
19844: LD_INT 0
19846: PPUSH
// YouLost ( Burlak ) ;
19847: LD_STRING Burlak
19849: PPUSH
19850: CALL_OW 104
// end ;
19854: LD_VAR 0 1
19858: RET
// export function AttackComrades ; begin
19859: LD_INT 0
19861: PPUSH
// YouLost ( SelfAttack ) ;
19862: LD_STRING SelfAttack
19864: PPUSH
19865: CALL_OW 104
// end ;
19869: LD_VAR 0 1
19873: RET
// export function BaseDestroyed ; begin
19874: LD_INT 0
19876: PPUSH
// YouLost ( Base ) ;
19877: LD_STRING Base
19879: PPUSH
19880: CALL_OW 104
// end ; end_of_file
19884: LD_VAR 0 1
19888: RET
// every 0 0$1 do var engs ;
19889: GO 19891
19891: DISABLE
19892: LD_INT 0
19894: PPUSH
// begin engs = UnitFilter ( otherKirovUnits , [ f_class , class_engineer ] ) ;
19895: LD_ADDR_VAR 0 1
19899: PUSH
19900: LD_EXP 69
19904: PPUSH
19905: LD_INT 25
19907: PUSH
19908: LD_INT 2
19910: PUSH
19911: EMPTY
19912: LIST
19913: LIST
19914: PPUSH
19915: CALL_OW 72
19919: ST_TO_ADDR
// ComExitBuilding ( engs ) ;
19920: LD_VAR 0 1
19924: PPUSH
19925: CALL_OW 122
// wait ( 0 0$1 ) ;
19929: LD_INT 35
19931: PPUSH
19932: CALL_OW 67
// AddComBuild ( engs , b_breastwork , 146 , 107 , 1 ) ;
19936: LD_VAR 0 1
19940: PPUSH
19941: LD_INT 31
19943: PPUSH
19944: LD_INT 146
19946: PPUSH
19947: LD_INT 107
19949: PPUSH
19950: LD_INT 1
19952: PPUSH
19953: CALL_OW 205
// AddComBuild ( engs , b_breastwork , 176 , 123 , 5 ) ;
19957: LD_VAR 0 1
19961: PPUSH
19962: LD_INT 31
19964: PPUSH
19965: LD_INT 176
19967: PPUSH
19968: LD_INT 123
19970: PPUSH
19971: LD_INT 5
19973: PPUSH
19974: CALL_OW 205
// AddComBuild ( engs , b_breastwork , 170 , 102 , 4 ) ;
19978: LD_VAR 0 1
19982: PPUSH
19983: LD_INT 31
19985: PPUSH
19986: LD_INT 170
19988: PPUSH
19989: LD_INT 102
19991: PPUSH
19992: LD_INT 4
19994: PPUSH
19995: CALL_OW 205
// AddComBuild ( engs , b_breastwork , 173 , 105 , 4 ) ;
19999: LD_VAR 0 1
20003: PPUSH
20004: LD_INT 31
20006: PPUSH
20007: LD_INT 173
20009: PPUSH
20010: LD_INT 105
20012: PPUSH
20013: LD_INT 4
20015: PPUSH
20016: CALL_OW 205
// AddComEnterUnit ( engs , kirov ) ;
20020: LD_VAR 0 1
20024: PPUSH
20025: LD_INT 71
20027: PPUSH
20028: CALL_OW 180
// end ;
20032: PPOPN 1
20034: END
// every 0 0$1 trigger activateAMAI do
20035: LD_EXP 27
20039: IFFALSE 20063
20041: GO 20043
20043: DISABLE
// begin enable ;
20044: ENABLE
// RepairDamageLeftBunkers ;
20045: CALL 20064 0 0
// if Difficulty = 3 then
20049: LD_OWVAR 67
20053: PUSH
20054: LD_INT 3
20056: EQUAL
20057: IFFALSE 20063
// RepairDamageRightBunkers ;
20059: CALL 20272 0 0
// end ;
20063: END
// function RepairDamageLeftBunkers ; var eng , bunker ; begin
20064: LD_INT 0
20066: PPUSH
20067: PPUSH
20068: PPUSH
// if not amLeftEngs or FilterUnitsInArea ( LeftHillArea , [ [ f_side , 1 ] , [ f_type , unit_building ] , [ f_btype , b_breastwork ] , [ f_not , [ f_lives , 1000 ] ] ] ) = 0 then
20069: LD_EXP 86
20073: NOT
20074: PUSH
20075: LD_INT 17
20077: PPUSH
20078: LD_INT 22
20080: PUSH
20081: LD_INT 1
20083: PUSH
20084: EMPTY
20085: LIST
20086: LIST
20087: PUSH
20088: LD_INT 21
20090: PUSH
20091: LD_INT 3
20093: PUSH
20094: EMPTY
20095: LIST
20096: LIST
20097: PUSH
20098: LD_INT 30
20100: PUSH
20101: LD_INT 31
20103: PUSH
20104: EMPTY
20105: LIST
20106: LIST
20107: PUSH
20108: LD_INT 3
20110: PUSH
20111: LD_INT 24
20113: PUSH
20114: LD_INT 1000
20116: PUSH
20117: EMPTY
20118: LIST
20119: LIST
20120: PUSH
20121: EMPTY
20122: LIST
20123: LIST
20124: PUSH
20125: EMPTY
20126: LIST
20127: LIST
20128: LIST
20129: LIST
20130: PPUSH
20131: CALL_OW 70
20135: PUSH
20136: LD_INT 0
20138: EQUAL
20139: OR
20140: IFFALSE 20144
// exit ;
20142: GO 20267
// ComExitBuilding ( UnitFilter ( amLeftEngs , [ f_not , [ f_hastask ] ] ) ) ;
20144: LD_EXP 86
20148: PPUSH
20149: LD_INT 3
20151: PUSH
20152: LD_INT 60
20154: PUSH
20155: EMPTY
20156: LIST
20157: PUSH
20158: EMPTY
20159: LIST
20160: LIST
20161: PPUSH
20162: CALL_OW 72
20166: PPUSH
20167: CALL_OW 122
// for bunker in leftBunkers do
20171: LD_ADDR_VAR 0 3
20175: PUSH
20176: LD_EXP 82
20180: PUSH
20181: FOR_IN
20182: IFFALSE 20233
// if GetLives ( bunker ) < 1000 then
20184: LD_VAR 0 3
20188: PPUSH
20189: CALL_OW 256
20193: PUSH
20194: LD_INT 1000
20196: LESS
20197: IFFALSE 20231
// AddComRepairBuilding ( UnitFilter ( amLeftEngs , [ f_not , [ f_hastask ] ] ) , bunker ) ;
20199: LD_EXP 86
20203: PPUSH
20204: LD_INT 3
20206: PUSH
20207: LD_INT 60
20209: PUSH
20210: EMPTY
20211: LIST
20212: PUSH
20213: EMPTY
20214: LIST
20215: LIST
20216: PPUSH
20217: CALL_OW 72
20221: PPUSH
20222: LD_VAR 0 3
20226: PPUSH
20227: CALL_OW 190
20231: GO 20181
20233: POP
20234: POP
// AddComEnterUnit ( UnitFilter ( amLeftEngs , [ f_not , [ f_hastask ] ] ) , amLeftDepot ) ;
20235: LD_EXP 86
20239: PPUSH
20240: LD_INT 3
20242: PUSH
20243: LD_INT 60
20245: PUSH
20246: EMPTY
20247: LIST
20248: PUSH
20249: EMPTY
20250: LIST
20251: LIST
20252: PPUSH
20253: CALL_OW 72
20257: PPUSH
20258: LD_EXP 84
20262: PPUSH
20263: CALL_OW 180
// end ;
20267: LD_VAR 0 1
20271: RET
// function RepairDamageRightBunkers ; var eng , bunker ; begin
20272: LD_INT 0
20274: PPUSH
20275: PPUSH
20276: PPUSH
// if not amRightEngs or FilterUnitsInArea ( RightHillArea , [ [ f_side , 1 ] , [ f_type , unit_building ] , [ f_btype , b_breastwork ] , [ f_not , [ f_lives , 1000 ] ] ] ) = 0 then
20277: LD_EXP 87
20281: NOT
20282: PUSH
20283: LD_INT 16
20285: PPUSH
20286: LD_INT 22
20288: PUSH
20289: LD_INT 1
20291: PUSH
20292: EMPTY
20293: LIST
20294: LIST
20295: PUSH
20296: LD_INT 21
20298: PUSH
20299: LD_INT 3
20301: PUSH
20302: EMPTY
20303: LIST
20304: LIST
20305: PUSH
20306: LD_INT 30
20308: PUSH
20309: LD_INT 31
20311: PUSH
20312: EMPTY
20313: LIST
20314: LIST
20315: PUSH
20316: LD_INT 3
20318: PUSH
20319: LD_INT 24
20321: PUSH
20322: LD_INT 1000
20324: PUSH
20325: EMPTY
20326: LIST
20327: LIST
20328: PUSH
20329: EMPTY
20330: LIST
20331: LIST
20332: PUSH
20333: EMPTY
20334: LIST
20335: LIST
20336: LIST
20337: LIST
20338: PPUSH
20339: CALL_OW 70
20343: PUSH
20344: LD_INT 0
20346: EQUAL
20347: OR
20348: IFFALSE 20352
// exit ;
20350: GO 20475
// ComExitBuilding ( UnitFilter ( amRightEngs , [ f_not , [ f_hastask ] ] ) ) ;
20352: LD_EXP 87
20356: PPUSH
20357: LD_INT 3
20359: PUSH
20360: LD_INT 60
20362: PUSH
20363: EMPTY
20364: LIST
20365: PUSH
20366: EMPTY
20367: LIST
20368: LIST
20369: PPUSH
20370: CALL_OW 72
20374: PPUSH
20375: CALL_OW 122
// for bunker in rightBunkers do
20379: LD_ADDR_VAR 0 3
20383: PUSH
20384: LD_EXP 83
20388: PUSH
20389: FOR_IN
20390: IFFALSE 20441
// if GetLives ( bunker ) < 1000 then
20392: LD_VAR 0 3
20396: PPUSH
20397: CALL_OW 256
20401: PUSH
20402: LD_INT 1000
20404: LESS
20405: IFFALSE 20439
// AddComRepairBuilding ( UnitFilter ( amRightEngs , [ f_not , [ f_hastask ] ] ) , bunker ) ;
20407: LD_EXP 87
20411: PPUSH
20412: LD_INT 3
20414: PUSH
20415: LD_INT 60
20417: PUSH
20418: EMPTY
20419: LIST
20420: PUSH
20421: EMPTY
20422: LIST
20423: LIST
20424: PPUSH
20425: CALL_OW 72
20429: PPUSH
20430: LD_VAR 0 3
20434: PPUSH
20435: CALL_OW 190
20439: GO 20389
20441: POP
20442: POP
// AddComEnterUnit ( UnitFilter ( amRightEngs , [ f_not , [ f_hastask ] ] ) , amRightDepot ) ;
20443: LD_EXP 87
20447: PPUSH
20448: LD_INT 3
20450: PUSH
20451: LD_INT 60
20453: PUSH
20454: EMPTY
20455: LIST
20456: PUSH
20457: EMPTY
20458: LIST
20459: LIST
20460: PPUSH
20461: CALL_OW 72
20465: PPUSH
20466: LD_EXP 85
20470: PPUSH
20471: CALL_OW 180
// end ;
20475: LD_VAR 0 1
20479: RET
// every 0 0$1 trigger activateBelkovAI and belkovTeam do var unit , med , damaged ;
20480: LD_EXP 28
20484: PUSH
20485: LD_EXP 73
20489: AND
20490: IFFALSE 20627
20492: GO 20494
20494: DISABLE
20495: LD_INT 0
20497: PPUSH
20498: PPUSH
20499: PPUSH
// begin enable ;
20500: ENABLE
// med = UnitFilter ( belkovTeam , [ f_class , class_scientistic ] ) ;
20501: LD_ADDR_VAR 0 2
20505: PUSH
20506: LD_EXP 73
20510: PPUSH
20511: LD_INT 25
20513: PUSH
20514: LD_INT 4
20516: PUSH
20517: EMPTY
20518: LIST
20519: LIST
20520: PPUSH
20521: CALL_OW 72
20525: ST_TO_ADDR
// damaged = UnitFilter ( belkovTeam , [ f_not , [ f_lives , 650 ] ] ) ;
20526: LD_ADDR_VAR 0 3
20530: PUSH
20531: LD_EXP 73
20535: PPUSH
20536: LD_INT 3
20538: PUSH
20539: LD_INT 24
20541: PUSH
20542: LD_INT 650
20544: PUSH
20545: EMPTY
20546: LIST
20547: LIST
20548: PUSH
20549: EMPTY
20550: LIST
20551: LIST
20552: PPUSH
20553: CALL_OW 72
20557: ST_TO_ADDR
// if not damaged and med then
20558: LD_VAR 0 3
20562: NOT
20563: PUSH
20564: LD_VAR 0 2
20568: AND
20569: IFFALSE 20588
// ComMoveXY ( med , 83 , 17 ) else
20571: LD_VAR 0 2
20575: PPUSH
20576: LD_INT 83
20578: PPUSH
20579: LD_INT 17
20581: PPUSH
20582: CALL_OW 111
20586: GO 20627
// if med then
20588: LD_VAR 0 2
20592: IFFALSE 20627
// begin ComMoveXY ( damaged , 83 , 17 ) ;
20594: LD_VAR 0 3
20598: PPUSH
20599: LD_INT 83
20601: PPUSH
20602: LD_INT 17
20604: PPUSH
20605: CALL_OW 111
// ComHeal ( med , damaged [ 1 ] ) ;
20609: LD_VAR 0 2
20613: PPUSH
20614: LD_VAR 0 3
20618: PUSH
20619: LD_INT 1
20621: ARRAY
20622: PPUSH
20623: CALL_OW 128
// end ; end ; end_of_file
20627: PPOPN 3
20629: END
// every 1 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_nation , nation_american ] , [ f_btype , b_depot ] ] ) = 2 do
20630: LD_INT 22
20632: PUSH
20633: LD_INT 3
20635: PUSH
20636: EMPTY
20637: LIST
20638: LIST
20639: PUSH
20640: LD_INT 23
20642: PUSH
20643: LD_INT 1
20645: PUSH
20646: EMPTY
20647: LIST
20648: LIST
20649: PUSH
20650: LD_INT 30
20652: PUSH
20653: LD_INT 0
20655: PUSH
20656: EMPTY
20657: LIST
20658: LIST
20659: PUSH
20660: EMPTY
20661: LIST
20662: LIST
20663: LIST
20664: PPUSH
20665: CALL_OW 69
20669: PUSH
20670: LD_INT 2
20672: EQUAL
20673: IFFALSE 20685
20675: GO 20677
20677: DISABLE
// SetAchievement ( ACH_DEPOT ) ;
20678: LD_STRING ACH_DEPOT
20680: PPUSH
20681: CALL_OW 543
20685: END
// every 1 trigger achievement_ConstructVehicles = 5 do
20686: LD_EXP 44
20690: PUSH
20691: LD_INT 5
20693: EQUAL
20694: IFFALSE 20706
20696: GO 20698
20698: DISABLE
// SetAchievement ( ACH_WORKSHOP ) ;
20699: LD_STRING ACH_WORKSHOP
20701: PPUSH
20702: CALL_OW 543
20706: END
// every 1 trigger captureBelkovVehicle do
20707: LD_EXP 38
20711: IFFALSE 20723
20713: GO 20715
20715: DISABLE
// SetAchievement ( ACH_RETAKE ) ; end_of_file
20716: LD_STRING ACH_RETAKE
20718: PPUSH
20719: CALL_OW 543
20723: END
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin if p2 = 100 then
20724: LD_VAR 0 2
20728: PUSH
20729: LD_INT 100
20731: EQUAL
20732: IFFALSE 21681
// begin if not StreamModeActive then
20734: LD_EXP 90
20738: NOT
20739: IFFALSE 20749
// StreamModeActive := true ;
20741: LD_ADDR_EXP 90
20745: PUSH
20746: LD_INT 1
20748: ST_TO_ADDR
// if p3 = 0 then
20749: LD_VAR 0 3
20753: PUSH
20754: LD_INT 0
20756: EQUAL
20757: IFFALSE 20763
// InitStreamMode ;
20759: CALL 21914 0 0
// if p3 = 1 then
20763: LD_VAR 0 3
20767: PUSH
20768: LD_INT 1
20770: EQUAL
20771: IFFALSE 20781
// sRocket := true ;
20773: LD_ADDR_EXP 95
20777: PUSH
20778: LD_INT 1
20780: ST_TO_ADDR
// if p3 = 2 then
20781: LD_VAR 0 3
20785: PUSH
20786: LD_INT 2
20788: EQUAL
20789: IFFALSE 20799
// sSpeed := true ;
20791: LD_ADDR_EXP 94
20795: PUSH
20796: LD_INT 1
20798: ST_TO_ADDR
// if p3 = 3 then
20799: LD_VAR 0 3
20803: PUSH
20804: LD_INT 3
20806: EQUAL
20807: IFFALSE 20817
// sEngine := true ;
20809: LD_ADDR_EXP 96
20813: PUSH
20814: LD_INT 1
20816: ST_TO_ADDR
// if p3 = 4 then
20817: LD_VAR 0 3
20821: PUSH
20822: LD_INT 4
20824: EQUAL
20825: IFFALSE 20835
// sSpec := true ;
20827: LD_ADDR_EXP 93
20831: PUSH
20832: LD_INT 1
20834: ST_TO_ADDR
// if p3 = 5 then
20835: LD_VAR 0 3
20839: PUSH
20840: LD_INT 5
20842: EQUAL
20843: IFFALSE 20853
// sLevel := true ;
20845: LD_ADDR_EXP 97
20849: PUSH
20850: LD_INT 1
20852: ST_TO_ADDR
// if p3 = 6 then
20853: LD_VAR 0 3
20857: PUSH
20858: LD_INT 6
20860: EQUAL
20861: IFFALSE 20871
// sArmoury := true ;
20863: LD_ADDR_EXP 98
20867: PUSH
20868: LD_INT 1
20870: ST_TO_ADDR
// if p3 = 7 then
20871: LD_VAR 0 3
20875: PUSH
20876: LD_INT 7
20878: EQUAL
20879: IFFALSE 20889
// sRadar := true ;
20881: LD_ADDR_EXP 99
20885: PUSH
20886: LD_INT 1
20888: ST_TO_ADDR
// if p3 = 8 then
20889: LD_VAR 0 3
20893: PUSH
20894: LD_INT 8
20896: EQUAL
20897: IFFALSE 20907
// sBunker := true ;
20899: LD_ADDR_EXP 100
20903: PUSH
20904: LD_INT 1
20906: ST_TO_ADDR
// if p3 = 9 then
20907: LD_VAR 0 3
20911: PUSH
20912: LD_INT 9
20914: EQUAL
20915: IFFALSE 20925
// sHack := true ;
20917: LD_ADDR_EXP 101
20921: PUSH
20922: LD_INT 1
20924: ST_TO_ADDR
// if p3 = 10 then
20925: LD_VAR 0 3
20929: PUSH
20930: LD_INT 10
20932: EQUAL
20933: IFFALSE 20943
// sFire := true ;
20935: LD_ADDR_EXP 102
20939: PUSH
20940: LD_INT 1
20942: ST_TO_ADDR
// if p3 = 11 then
20943: LD_VAR 0 3
20947: PUSH
20948: LD_INT 11
20950: EQUAL
20951: IFFALSE 20961
// sRefresh := true ;
20953: LD_ADDR_EXP 103
20957: PUSH
20958: LD_INT 1
20960: ST_TO_ADDR
// if p3 = 12 then
20961: LD_VAR 0 3
20965: PUSH
20966: LD_INT 12
20968: EQUAL
20969: IFFALSE 20979
// sExp := true ;
20971: LD_ADDR_EXP 104
20975: PUSH
20976: LD_INT 1
20978: ST_TO_ADDR
// if p3 = 13 then
20979: LD_VAR 0 3
20983: PUSH
20984: LD_INT 13
20986: EQUAL
20987: IFFALSE 20997
// sDepot := true ;
20989: LD_ADDR_EXP 105
20993: PUSH
20994: LD_INT 1
20996: ST_TO_ADDR
// if p3 = 14 then
20997: LD_VAR 0 3
21001: PUSH
21002: LD_INT 14
21004: EQUAL
21005: IFFALSE 21015
// sFlag := true ;
21007: LD_ADDR_EXP 106
21011: PUSH
21012: LD_INT 1
21014: ST_TO_ADDR
// if p3 = 15 then
21015: LD_VAR 0 3
21019: PUSH
21020: LD_INT 15
21022: EQUAL
21023: IFFALSE 21033
// sKamikadze := true ;
21025: LD_ADDR_EXP 114
21029: PUSH
21030: LD_INT 1
21032: ST_TO_ADDR
// if p3 = 16 then
21033: LD_VAR 0 3
21037: PUSH
21038: LD_INT 16
21040: EQUAL
21041: IFFALSE 21051
// sTroll := true ;
21043: LD_ADDR_EXP 115
21047: PUSH
21048: LD_INT 1
21050: ST_TO_ADDR
// if p3 = 17 then
21051: LD_VAR 0 3
21055: PUSH
21056: LD_INT 17
21058: EQUAL
21059: IFFALSE 21069
// sSlow := true ;
21061: LD_ADDR_EXP 116
21065: PUSH
21066: LD_INT 1
21068: ST_TO_ADDR
// if p3 = 18 then
21069: LD_VAR 0 3
21073: PUSH
21074: LD_INT 18
21076: EQUAL
21077: IFFALSE 21087
// sLack := true ;
21079: LD_ADDR_EXP 117
21083: PUSH
21084: LD_INT 1
21086: ST_TO_ADDR
// if p3 = 19 then
21087: LD_VAR 0 3
21091: PUSH
21092: LD_INT 19
21094: EQUAL
21095: IFFALSE 21105
// sTank := true ;
21097: LD_ADDR_EXP 119
21101: PUSH
21102: LD_INT 1
21104: ST_TO_ADDR
// if p3 = 20 then
21105: LD_VAR 0 3
21109: PUSH
21110: LD_INT 20
21112: EQUAL
21113: IFFALSE 21123
// sRemote := true ;
21115: LD_ADDR_EXP 120
21119: PUSH
21120: LD_INT 1
21122: ST_TO_ADDR
// if p3 = 21 then
21123: LD_VAR 0 3
21127: PUSH
21128: LD_INT 21
21130: EQUAL
21131: IFFALSE 21141
// sPowell := true ;
21133: LD_ADDR_EXP 121
21137: PUSH
21138: LD_INT 1
21140: ST_TO_ADDR
// if p3 = 22 then
21141: LD_VAR 0 3
21145: PUSH
21146: LD_INT 22
21148: EQUAL
21149: IFFALSE 21159
// sTeleport := true ;
21151: LD_ADDR_EXP 124
21155: PUSH
21156: LD_INT 1
21158: ST_TO_ADDR
// if p3 = 23 then
21159: LD_VAR 0 3
21163: PUSH
21164: LD_INT 23
21166: EQUAL
21167: IFFALSE 21177
// sOilTower := true ;
21169: LD_ADDR_EXP 126
21173: PUSH
21174: LD_INT 1
21176: ST_TO_ADDR
// if p3 = 24 then
21177: LD_VAR 0 3
21181: PUSH
21182: LD_INT 24
21184: EQUAL
21185: IFFALSE 21195
// sShovel := true ;
21187: LD_ADDR_EXP 127
21191: PUSH
21192: LD_INT 1
21194: ST_TO_ADDR
// if p3 = 25 then
21195: LD_VAR 0 3
21199: PUSH
21200: LD_INT 25
21202: EQUAL
21203: IFFALSE 21213
// sSheik := true ;
21205: LD_ADDR_EXP 128
21209: PUSH
21210: LD_INT 1
21212: ST_TO_ADDR
// if p3 = 26 then
21213: LD_VAR 0 3
21217: PUSH
21218: LD_INT 26
21220: EQUAL
21221: IFFALSE 21231
// sEarthquake := true ;
21223: LD_ADDR_EXP 130
21227: PUSH
21228: LD_INT 1
21230: ST_TO_ADDR
// if p3 = 27 then
21231: LD_VAR 0 3
21235: PUSH
21236: LD_INT 27
21238: EQUAL
21239: IFFALSE 21249
// sAI := true ;
21241: LD_ADDR_EXP 131
21245: PUSH
21246: LD_INT 1
21248: ST_TO_ADDR
// if p3 = 28 then
21249: LD_VAR 0 3
21253: PUSH
21254: LD_INT 28
21256: EQUAL
21257: IFFALSE 21267
// sCargo := true ;
21259: LD_ADDR_EXP 134
21263: PUSH
21264: LD_INT 1
21266: ST_TO_ADDR
// if p3 = 29 then
21267: LD_VAR 0 3
21271: PUSH
21272: LD_INT 29
21274: EQUAL
21275: IFFALSE 21285
// sDLaser := true ;
21277: LD_ADDR_EXP 135
21281: PUSH
21282: LD_INT 1
21284: ST_TO_ADDR
// if p3 = 30 then
21285: LD_VAR 0 3
21289: PUSH
21290: LD_INT 30
21292: EQUAL
21293: IFFALSE 21303
// sExchange := true ;
21295: LD_ADDR_EXP 136
21299: PUSH
21300: LD_INT 1
21302: ST_TO_ADDR
// if p3 = 31 then
21303: LD_VAR 0 3
21307: PUSH
21308: LD_INT 31
21310: EQUAL
21311: IFFALSE 21321
// sFac := true ;
21313: LD_ADDR_EXP 137
21317: PUSH
21318: LD_INT 1
21320: ST_TO_ADDR
// if p3 = 32 then
21321: LD_VAR 0 3
21325: PUSH
21326: LD_INT 32
21328: EQUAL
21329: IFFALSE 21339
// sPower := true ;
21331: LD_ADDR_EXP 138
21335: PUSH
21336: LD_INT 1
21338: ST_TO_ADDR
// if p3 = 33 then
21339: LD_VAR 0 3
21343: PUSH
21344: LD_INT 33
21346: EQUAL
21347: IFFALSE 21357
// sRandom := true ;
21349: LD_ADDR_EXP 139
21353: PUSH
21354: LD_INT 1
21356: ST_TO_ADDR
// if p3 = 34 then
21357: LD_VAR 0 3
21361: PUSH
21362: LD_INT 34
21364: EQUAL
21365: IFFALSE 21375
// sShield := true ;
21367: LD_ADDR_EXP 140
21371: PUSH
21372: LD_INT 1
21374: ST_TO_ADDR
// if p3 = 35 then
21375: LD_VAR 0 3
21379: PUSH
21380: LD_INT 35
21382: EQUAL
21383: IFFALSE 21393
// sTime := true ;
21385: LD_ADDR_EXP 141
21389: PUSH
21390: LD_INT 1
21392: ST_TO_ADDR
// if p3 = 36 then
21393: LD_VAR 0 3
21397: PUSH
21398: LD_INT 36
21400: EQUAL
21401: IFFALSE 21411
// sTools := true ;
21403: LD_ADDR_EXP 142
21407: PUSH
21408: LD_INT 1
21410: ST_TO_ADDR
// if p3 = 101 then
21411: LD_VAR 0 3
21415: PUSH
21416: LD_INT 101
21418: EQUAL
21419: IFFALSE 21429
// sSold := true ;
21421: LD_ADDR_EXP 107
21425: PUSH
21426: LD_INT 1
21428: ST_TO_ADDR
// if p3 = 102 then
21429: LD_VAR 0 3
21433: PUSH
21434: LD_INT 102
21436: EQUAL
21437: IFFALSE 21447
// sDiff := true ;
21439: LD_ADDR_EXP 108
21443: PUSH
21444: LD_INT 1
21446: ST_TO_ADDR
// if p3 = 103 then
21447: LD_VAR 0 3
21451: PUSH
21452: LD_INT 103
21454: EQUAL
21455: IFFALSE 21465
// sFog := true ;
21457: LD_ADDR_EXP 111
21461: PUSH
21462: LD_INT 1
21464: ST_TO_ADDR
// if p3 = 104 then
21465: LD_VAR 0 3
21469: PUSH
21470: LD_INT 104
21472: EQUAL
21473: IFFALSE 21483
// sReset := true ;
21475: LD_ADDR_EXP 112
21479: PUSH
21480: LD_INT 1
21482: ST_TO_ADDR
// if p3 = 105 then
21483: LD_VAR 0 3
21487: PUSH
21488: LD_INT 105
21490: EQUAL
21491: IFFALSE 21501
// sSun := true ;
21493: LD_ADDR_EXP 113
21497: PUSH
21498: LD_INT 1
21500: ST_TO_ADDR
// if p3 = 106 then
21501: LD_VAR 0 3
21505: PUSH
21506: LD_INT 106
21508: EQUAL
21509: IFFALSE 21519
// sTiger := true ;
21511: LD_ADDR_EXP 109
21515: PUSH
21516: LD_INT 1
21518: ST_TO_ADDR
// if p3 = 107 then
21519: LD_VAR 0 3
21523: PUSH
21524: LD_INT 107
21526: EQUAL
21527: IFFALSE 21537
// sBomb := true ;
21529: LD_ADDR_EXP 110
21533: PUSH
21534: LD_INT 1
21536: ST_TO_ADDR
// if p3 = 108 then
21537: LD_VAR 0 3
21541: PUSH
21542: LD_INT 108
21544: EQUAL
21545: IFFALSE 21555
// sWound := true ;
21547: LD_ADDR_EXP 118
21551: PUSH
21552: LD_INT 1
21554: ST_TO_ADDR
// if p3 = 109 then
21555: LD_VAR 0 3
21559: PUSH
21560: LD_INT 109
21562: EQUAL
21563: IFFALSE 21573
// sBetray := true ;
21565: LD_ADDR_EXP 122
21569: PUSH
21570: LD_INT 1
21572: ST_TO_ADDR
// if p3 = 110 then
21573: LD_VAR 0 3
21577: PUSH
21578: LD_INT 110
21580: EQUAL
21581: IFFALSE 21591
// sContamin := true ;
21583: LD_ADDR_EXP 123
21587: PUSH
21588: LD_INT 1
21590: ST_TO_ADDR
// if p3 = 111 then
21591: LD_VAR 0 3
21595: PUSH
21596: LD_INT 111
21598: EQUAL
21599: IFFALSE 21609
// sOil := true ;
21601: LD_ADDR_EXP 125
21605: PUSH
21606: LD_INT 1
21608: ST_TO_ADDR
// if p3 = 112 then
21609: LD_VAR 0 3
21613: PUSH
21614: LD_INT 112
21616: EQUAL
21617: IFFALSE 21627
// sStu := true ;
21619: LD_ADDR_EXP 129
21623: PUSH
21624: LD_INT 1
21626: ST_TO_ADDR
// if p3 = 113 then
21627: LD_VAR 0 3
21631: PUSH
21632: LD_INT 113
21634: EQUAL
21635: IFFALSE 21645
// sBazooka := true ;
21637: LD_ADDR_EXP 132
21641: PUSH
21642: LD_INT 1
21644: ST_TO_ADDR
// if p3 = 114 then
21645: LD_VAR 0 3
21649: PUSH
21650: LD_INT 114
21652: EQUAL
21653: IFFALSE 21663
// sMortar := true ;
21655: LD_ADDR_EXP 133
21659: PUSH
21660: LD_INT 1
21662: ST_TO_ADDR
// if p3 = 115 then
21663: LD_VAR 0 3
21667: PUSH
21668: LD_INT 115
21670: EQUAL
21671: IFFALSE 21681
// sRanger := true ;
21673: LD_ADDR_EXP 143
21677: PUSH
21678: LD_INT 1
21680: ST_TO_ADDR
// end ; if p2 = 101 then
21681: LD_VAR 0 2
21685: PUSH
21686: LD_INT 101
21688: EQUAL
21689: IFFALSE 21892
// begin case p3 of 1 :
21691: LD_VAR 0 3
21695: PUSH
21696: LD_INT 1
21698: DOUBLE
21699: EQUAL
21700: IFTRUE 21704
21702: GO 21711
21704: POP
// hHackUnlimitedResources ; 2 :
21705: CALL 31986 0 0
21709: GO 21892
21711: LD_INT 2
21713: DOUBLE
21714: EQUAL
21715: IFTRUE 21719
21717: GO 21726
21719: POP
// hHackSetLevel10 ; 3 :
21720: CALL 32119 0 0
21724: GO 21892
21726: LD_INT 3
21728: DOUBLE
21729: EQUAL
21730: IFTRUE 21734
21732: GO 21741
21734: POP
// hHackSetLevel10YourUnits ; 4 :
21735: CALL 32204 0 0
21739: GO 21892
21741: LD_INT 4
21743: DOUBLE
21744: EQUAL
21745: IFTRUE 21749
21747: GO 21771
21749: POP
// hHackSpawnHuman ( p4 , p5 , p6 ) ; 5 :
21750: LD_VAR 0 4
21754: PPUSH
21755: LD_VAR 0 5
21759: PPUSH
21760: LD_VAR 0 6
21764: PPUSH
21765: CALL 32294 0 3
21769: GO 21892
21771: LD_INT 5
21773: DOUBLE
21774: EQUAL
21775: IFTRUE 21779
21777: GO 21786
21779: POP
// hHackSpawnVehicle ; 6 :
21780: CALL 32355 0 0
21784: GO 21892
21786: LD_INT 6
21788: DOUBLE
21789: EQUAL
21790: IFTRUE 21794
21792: GO 21801
21794: POP
// hHackInvincible ; 7 :
21795: CALL 32901 0 0
21799: GO 21892
21801: LD_INT 7
21803: DOUBLE
21804: EQUAL
21805: IFTRUE 21809
21807: GO 21816
21809: POP
// hHackInvisible ; 8 :
21810: CALL 33012 0 0
21814: GO 21892
21816: LD_INT 8
21818: DOUBLE
21819: EQUAL
21820: IFTRUE 21824
21822: GO 21831
21824: POP
// hHackChangeYourSide ; 9 :
21825: CALL 33069 0 0
21829: GO 21892
21831: LD_INT 9
21833: DOUBLE
21834: EQUAL
21835: IFTRUE 21839
21837: GO 21846
21839: POP
// hHackChangeUnitSide ; 10 :
21840: CALL 33111 0 0
21844: GO 21892
21846: LD_INT 10
21848: DOUBLE
21849: EQUAL
21850: IFTRUE 21854
21852: GO 21861
21854: POP
// hHackFog ; 11 :
21855: CALL 33212 0 0
21859: GO 21892
21861: LD_INT 11
21863: DOUBLE
21864: EQUAL
21865: IFTRUE 21869
21867: GO 21876
21869: POP
// hHackApeman ; 12 :
21870: CALL 33227 0 0
21874: GO 21892
21876: LD_INT 12
21878: DOUBLE
21879: EQUAL
21880: IFTRUE 21884
21882: GO 21891
21884: POP
// hHackBoom ; end ;
21885: CALL 33312 0 0
21889: GO 21892
21891: POP
// end ; end ;
21892: PPOPN 6
21894: END
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger ; every 0 0$1 do
21895: GO 21897
21897: DISABLE
// begin ToLua ( initStreamRollete(); ) ;
21898: LD_STRING initStreamRollete();
21900: PPUSH
21901: CALL_OW 559
// InitStreamMode ;
21905: CALL 21914 0 0
// DefineStreamItems ( ) ;
21909: CALL 22354 0 0
// end ;
21913: END
// function InitStreamMode ; begin
21914: LD_INT 0
21916: PPUSH
// streamModeActive := false ;
21917: LD_ADDR_EXP 90
21921: PUSH
21922: LD_INT 0
21924: ST_TO_ADDR
// normalCounter := 36 ;
21925: LD_ADDR_EXP 91
21929: PUSH
21930: LD_INT 36
21932: ST_TO_ADDR
// hardcoreCounter := 16 ;
21933: LD_ADDR_EXP 92
21937: PUSH
21938: LD_INT 16
21940: ST_TO_ADDR
// sRocket := false ;
21941: LD_ADDR_EXP 95
21945: PUSH
21946: LD_INT 0
21948: ST_TO_ADDR
// sSpeed := false ;
21949: LD_ADDR_EXP 94
21953: PUSH
21954: LD_INT 0
21956: ST_TO_ADDR
// sEngine := false ;
21957: LD_ADDR_EXP 96
21961: PUSH
21962: LD_INT 0
21964: ST_TO_ADDR
// sSpec := false ;
21965: LD_ADDR_EXP 93
21969: PUSH
21970: LD_INT 0
21972: ST_TO_ADDR
// sLevel := false ;
21973: LD_ADDR_EXP 97
21977: PUSH
21978: LD_INT 0
21980: ST_TO_ADDR
// sArmoury := false ;
21981: LD_ADDR_EXP 98
21985: PUSH
21986: LD_INT 0
21988: ST_TO_ADDR
// sRadar := false ;
21989: LD_ADDR_EXP 99
21993: PUSH
21994: LD_INT 0
21996: ST_TO_ADDR
// sBunker := false ;
21997: LD_ADDR_EXP 100
22001: PUSH
22002: LD_INT 0
22004: ST_TO_ADDR
// sHack := false ;
22005: LD_ADDR_EXP 101
22009: PUSH
22010: LD_INT 0
22012: ST_TO_ADDR
// sFire := false ;
22013: LD_ADDR_EXP 102
22017: PUSH
22018: LD_INT 0
22020: ST_TO_ADDR
// sRefresh := false ;
22021: LD_ADDR_EXP 103
22025: PUSH
22026: LD_INT 0
22028: ST_TO_ADDR
// sExp := false ;
22029: LD_ADDR_EXP 104
22033: PUSH
22034: LD_INT 0
22036: ST_TO_ADDR
// sDepot := false ;
22037: LD_ADDR_EXP 105
22041: PUSH
22042: LD_INT 0
22044: ST_TO_ADDR
// sFlag := false ;
22045: LD_ADDR_EXP 106
22049: PUSH
22050: LD_INT 0
22052: ST_TO_ADDR
// sKamikadze := false ;
22053: LD_ADDR_EXP 114
22057: PUSH
22058: LD_INT 0
22060: ST_TO_ADDR
// sTroll := false ;
22061: LD_ADDR_EXP 115
22065: PUSH
22066: LD_INT 0
22068: ST_TO_ADDR
// sSlow := false ;
22069: LD_ADDR_EXP 116
22073: PUSH
22074: LD_INT 0
22076: ST_TO_ADDR
// sLack := false ;
22077: LD_ADDR_EXP 117
22081: PUSH
22082: LD_INT 0
22084: ST_TO_ADDR
// sTank := false ;
22085: LD_ADDR_EXP 119
22089: PUSH
22090: LD_INT 0
22092: ST_TO_ADDR
// sRemote := false ;
22093: LD_ADDR_EXP 120
22097: PUSH
22098: LD_INT 0
22100: ST_TO_ADDR
// sPowell := false ;
22101: LD_ADDR_EXP 121
22105: PUSH
22106: LD_INT 0
22108: ST_TO_ADDR
// sTeleport := false ;
22109: LD_ADDR_EXP 124
22113: PUSH
22114: LD_INT 0
22116: ST_TO_ADDR
// sOilTower := false ;
22117: LD_ADDR_EXP 126
22121: PUSH
22122: LD_INT 0
22124: ST_TO_ADDR
// sShovel := false ;
22125: LD_ADDR_EXP 127
22129: PUSH
22130: LD_INT 0
22132: ST_TO_ADDR
// sSheik := false ;
22133: LD_ADDR_EXP 128
22137: PUSH
22138: LD_INT 0
22140: ST_TO_ADDR
// sEarthquake := false ;
22141: LD_ADDR_EXP 130
22145: PUSH
22146: LD_INT 0
22148: ST_TO_ADDR
// sAI := false ;
22149: LD_ADDR_EXP 131
22153: PUSH
22154: LD_INT 0
22156: ST_TO_ADDR
// sCargo := false ;
22157: LD_ADDR_EXP 134
22161: PUSH
22162: LD_INT 0
22164: ST_TO_ADDR
// sDLaser := false ;
22165: LD_ADDR_EXP 135
22169: PUSH
22170: LD_INT 0
22172: ST_TO_ADDR
// sExchange := false ;
22173: LD_ADDR_EXP 136
22177: PUSH
22178: LD_INT 0
22180: ST_TO_ADDR
// sFac := false ;
22181: LD_ADDR_EXP 137
22185: PUSH
22186: LD_INT 0
22188: ST_TO_ADDR
// sPower := false ;
22189: LD_ADDR_EXP 138
22193: PUSH
22194: LD_INT 0
22196: ST_TO_ADDR
// sRandom := false ;
22197: LD_ADDR_EXP 139
22201: PUSH
22202: LD_INT 0
22204: ST_TO_ADDR
// sShield := false ;
22205: LD_ADDR_EXP 140
22209: PUSH
22210: LD_INT 0
22212: ST_TO_ADDR
// sTime := false ;
22213: LD_ADDR_EXP 141
22217: PUSH
22218: LD_INT 0
22220: ST_TO_ADDR
// sTools := false ;
22221: LD_ADDR_EXP 142
22225: PUSH
22226: LD_INT 0
22228: ST_TO_ADDR
// sSold := false ;
22229: LD_ADDR_EXP 107
22233: PUSH
22234: LD_INT 0
22236: ST_TO_ADDR
// sDiff := false ;
22237: LD_ADDR_EXP 108
22241: PUSH
22242: LD_INT 0
22244: ST_TO_ADDR
// sFog := false ;
22245: LD_ADDR_EXP 111
22249: PUSH
22250: LD_INT 0
22252: ST_TO_ADDR
// sReset := false ;
22253: LD_ADDR_EXP 112
22257: PUSH
22258: LD_INT 0
22260: ST_TO_ADDR
// sSun := false ;
22261: LD_ADDR_EXP 113
22265: PUSH
22266: LD_INT 0
22268: ST_TO_ADDR
// sTiger := false ;
22269: LD_ADDR_EXP 109
22273: PUSH
22274: LD_INT 0
22276: ST_TO_ADDR
// sBomb := false ;
22277: LD_ADDR_EXP 110
22281: PUSH
22282: LD_INT 0
22284: ST_TO_ADDR
// sWound := false ;
22285: LD_ADDR_EXP 118
22289: PUSH
22290: LD_INT 0
22292: ST_TO_ADDR
// sBetray := false ;
22293: LD_ADDR_EXP 122
22297: PUSH
22298: LD_INT 0
22300: ST_TO_ADDR
// sContamin := false ;
22301: LD_ADDR_EXP 123
22305: PUSH
22306: LD_INT 0
22308: ST_TO_ADDR
// sOil := false ;
22309: LD_ADDR_EXP 125
22313: PUSH
22314: LD_INT 0
22316: ST_TO_ADDR
// sStu := false ;
22317: LD_ADDR_EXP 129
22321: PUSH
22322: LD_INT 0
22324: ST_TO_ADDR
// sBazooka := false ;
22325: LD_ADDR_EXP 132
22329: PUSH
22330: LD_INT 0
22332: ST_TO_ADDR
// sMortar := false ;
22333: LD_ADDR_EXP 133
22337: PUSH
22338: LD_INT 0
22340: ST_TO_ADDR
// sRanger := false ;
22341: LD_ADDR_EXP 143
22345: PUSH
22346: LD_INT 0
22348: ST_TO_ADDR
// end ;
22349: LD_VAR 0 1
22353: RET
// function DefineStreamItems ( ) ; var tmp , normal , hardcore , i ; begin
22354: LD_INT 0
22356: PPUSH
22357: PPUSH
22358: PPUSH
22359: PPUSH
22360: PPUSH
// result := [ ] ;
22361: LD_ADDR_VAR 0 1
22365: PUSH
22366: EMPTY
22367: ST_TO_ADDR
// if campaign_id = 1 then
22368: LD_OWVAR 69
22372: PUSH
22373: LD_INT 1
22375: EQUAL
22376: IFFALSE 25314
// begin case mission_number of 1 :
22378: LD_OWVAR 70
22382: PUSH
22383: LD_INT 1
22385: DOUBLE
22386: EQUAL
22387: IFTRUE 22391
22389: GO 22455
22391: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 ] ] ; 2 :
22392: LD_ADDR_VAR 0 1
22396: PUSH
22397: LD_INT 2
22399: PUSH
22400: LD_INT 4
22402: PUSH
22403: LD_INT 11
22405: PUSH
22406: LD_INT 12
22408: PUSH
22409: LD_INT 15
22411: PUSH
22412: LD_INT 16
22414: PUSH
22415: LD_INT 22
22417: PUSH
22418: LD_INT 23
22420: PUSH
22421: LD_INT 26
22423: PUSH
22424: EMPTY
22425: LIST
22426: LIST
22427: LIST
22428: LIST
22429: LIST
22430: LIST
22431: LIST
22432: LIST
22433: LIST
22434: PUSH
22435: LD_INT 101
22437: PUSH
22438: LD_INT 102
22440: PUSH
22441: LD_INT 106
22443: PUSH
22444: EMPTY
22445: LIST
22446: LIST
22447: LIST
22448: PUSH
22449: EMPTY
22450: LIST
22451: LIST
22452: ST_TO_ADDR
22453: GO 25312
22455: LD_INT 2
22457: DOUBLE
22458: EQUAL
22459: IFTRUE 22463
22461: GO 22535
22463: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 3 :
22464: LD_ADDR_VAR 0 1
22468: PUSH
22469: LD_INT 2
22471: PUSH
22472: LD_INT 4
22474: PUSH
22475: LD_INT 11
22477: PUSH
22478: LD_INT 12
22480: PUSH
22481: LD_INT 15
22483: PUSH
22484: LD_INT 16
22486: PUSH
22487: LD_INT 22
22489: PUSH
22490: LD_INT 23
22492: PUSH
22493: LD_INT 26
22495: PUSH
22496: EMPTY
22497: LIST
22498: LIST
22499: LIST
22500: LIST
22501: LIST
22502: LIST
22503: LIST
22504: LIST
22505: LIST
22506: PUSH
22507: LD_INT 101
22509: PUSH
22510: LD_INT 102
22512: PUSH
22513: LD_INT 105
22515: PUSH
22516: LD_INT 106
22518: PUSH
22519: LD_INT 108
22521: PUSH
22522: EMPTY
22523: LIST
22524: LIST
22525: LIST
22526: LIST
22527: LIST
22528: PUSH
22529: EMPTY
22530: LIST
22531: LIST
22532: ST_TO_ADDR
22533: GO 25312
22535: LD_INT 3
22537: DOUBLE
22538: EQUAL
22539: IFTRUE 22543
22541: GO 22619
22543: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 4 :
22544: LD_ADDR_VAR 0 1
22548: PUSH
22549: LD_INT 2
22551: PUSH
22552: LD_INT 4
22554: PUSH
22555: LD_INT 5
22557: PUSH
22558: LD_INT 11
22560: PUSH
22561: LD_INT 12
22563: PUSH
22564: LD_INT 15
22566: PUSH
22567: LD_INT 16
22569: PUSH
22570: LD_INT 22
22572: PUSH
22573: LD_INT 26
22575: PUSH
22576: LD_INT 36
22578: PUSH
22579: EMPTY
22580: LIST
22581: LIST
22582: LIST
22583: LIST
22584: LIST
22585: LIST
22586: LIST
22587: LIST
22588: LIST
22589: LIST
22590: PUSH
22591: LD_INT 101
22593: PUSH
22594: LD_INT 102
22596: PUSH
22597: LD_INT 105
22599: PUSH
22600: LD_INT 106
22602: PUSH
22603: LD_INT 108
22605: PUSH
22606: EMPTY
22607: LIST
22608: LIST
22609: LIST
22610: LIST
22611: LIST
22612: PUSH
22613: EMPTY
22614: LIST
22615: LIST
22616: ST_TO_ADDR
22617: GO 25312
22619: LD_INT 4
22621: DOUBLE
22622: EQUAL
22623: IFTRUE 22627
22625: GO 22711
22627: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 5 :
22628: LD_ADDR_VAR 0 1
22632: PUSH
22633: LD_INT 2
22635: PUSH
22636: LD_INT 4
22638: PUSH
22639: LD_INT 5
22641: PUSH
22642: LD_INT 8
22644: PUSH
22645: LD_INT 11
22647: PUSH
22648: LD_INT 12
22650: PUSH
22651: LD_INT 15
22653: PUSH
22654: LD_INT 16
22656: PUSH
22657: LD_INT 22
22659: PUSH
22660: LD_INT 23
22662: PUSH
22663: LD_INT 26
22665: PUSH
22666: LD_INT 36
22668: PUSH
22669: EMPTY
22670: LIST
22671: LIST
22672: LIST
22673: LIST
22674: LIST
22675: LIST
22676: LIST
22677: LIST
22678: LIST
22679: LIST
22680: LIST
22681: LIST
22682: PUSH
22683: LD_INT 101
22685: PUSH
22686: LD_INT 102
22688: PUSH
22689: LD_INT 105
22691: PUSH
22692: LD_INT 106
22694: PUSH
22695: LD_INT 108
22697: PUSH
22698: EMPTY
22699: LIST
22700: LIST
22701: LIST
22702: LIST
22703: LIST
22704: PUSH
22705: EMPTY
22706: LIST
22707: LIST
22708: ST_TO_ADDR
22709: GO 25312
22711: LD_INT 5
22713: DOUBLE
22714: EQUAL
22715: IFTRUE 22719
22717: GO 22819
22719: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 6 :
22720: LD_ADDR_VAR 0 1
22724: PUSH
22725: LD_INT 2
22727: PUSH
22728: LD_INT 4
22730: PUSH
22731: LD_INT 5
22733: PUSH
22734: LD_INT 6
22736: PUSH
22737: LD_INT 8
22739: PUSH
22740: LD_INT 11
22742: PUSH
22743: LD_INT 12
22745: PUSH
22746: LD_INT 15
22748: PUSH
22749: LD_INT 16
22751: PUSH
22752: LD_INT 22
22754: PUSH
22755: LD_INT 23
22757: PUSH
22758: LD_INT 25
22760: PUSH
22761: LD_INT 26
22763: PUSH
22764: LD_INT 36
22766: PUSH
22767: EMPTY
22768: LIST
22769: LIST
22770: LIST
22771: LIST
22772: LIST
22773: LIST
22774: LIST
22775: LIST
22776: LIST
22777: LIST
22778: LIST
22779: LIST
22780: LIST
22781: LIST
22782: PUSH
22783: LD_INT 101
22785: PUSH
22786: LD_INT 102
22788: PUSH
22789: LD_INT 105
22791: PUSH
22792: LD_INT 106
22794: PUSH
22795: LD_INT 108
22797: PUSH
22798: LD_INT 109
22800: PUSH
22801: LD_INT 112
22803: PUSH
22804: EMPTY
22805: LIST
22806: LIST
22807: LIST
22808: LIST
22809: LIST
22810: LIST
22811: LIST
22812: PUSH
22813: EMPTY
22814: LIST
22815: LIST
22816: ST_TO_ADDR
22817: GO 25312
22819: LD_INT 6
22821: DOUBLE
22822: EQUAL
22823: IFTRUE 22827
22825: GO 22947
22827: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 7 :
22828: LD_ADDR_VAR 0 1
22832: PUSH
22833: LD_INT 2
22835: PUSH
22836: LD_INT 4
22838: PUSH
22839: LD_INT 5
22841: PUSH
22842: LD_INT 6
22844: PUSH
22845: LD_INT 8
22847: PUSH
22848: LD_INT 11
22850: PUSH
22851: LD_INT 12
22853: PUSH
22854: LD_INT 15
22856: PUSH
22857: LD_INT 16
22859: PUSH
22860: LD_INT 20
22862: PUSH
22863: LD_INT 21
22865: PUSH
22866: LD_INT 22
22868: PUSH
22869: LD_INT 23
22871: PUSH
22872: LD_INT 25
22874: PUSH
22875: LD_INT 26
22877: PUSH
22878: LD_INT 30
22880: PUSH
22881: LD_INT 31
22883: PUSH
22884: LD_INT 32
22886: PUSH
22887: LD_INT 36
22889: PUSH
22890: EMPTY
22891: LIST
22892: LIST
22893: LIST
22894: LIST
22895: LIST
22896: LIST
22897: LIST
22898: LIST
22899: LIST
22900: LIST
22901: LIST
22902: LIST
22903: LIST
22904: LIST
22905: LIST
22906: LIST
22907: LIST
22908: LIST
22909: LIST
22910: PUSH
22911: LD_INT 101
22913: PUSH
22914: LD_INT 102
22916: PUSH
22917: LD_INT 105
22919: PUSH
22920: LD_INT 106
22922: PUSH
22923: LD_INT 108
22925: PUSH
22926: LD_INT 109
22928: PUSH
22929: LD_INT 112
22931: PUSH
22932: EMPTY
22933: LIST
22934: LIST
22935: LIST
22936: LIST
22937: LIST
22938: LIST
22939: LIST
22940: PUSH
22941: EMPTY
22942: LIST
22943: LIST
22944: ST_TO_ADDR
22945: GO 25312
22947: LD_INT 7
22949: DOUBLE
22950: EQUAL
22951: IFTRUE 22955
22953: GO 23055
22955: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 ] ] ; 8 :
22956: LD_ADDR_VAR 0 1
22960: PUSH
22961: LD_INT 2
22963: PUSH
22964: LD_INT 4
22966: PUSH
22967: LD_INT 5
22969: PUSH
22970: LD_INT 7
22972: PUSH
22973: LD_INT 11
22975: PUSH
22976: LD_INT 12
22978: PUSH
22979: LD_INT 15
22981: PUSH
22982: LD_INT 16
22984: PUSH
22985: LD_INT 20
22987: PUSH
22988: LD_INT 21
22990: PUSH
22991: LD_INT 22
22993: PUSH
22994: LD_INT 23
22996: PUSH
22997: LD_INT 25
22999: PUSH
23000: LD_INT 26
23002: PUSH
23003: EMPTY
23004: LIST
23005: LIST
23006: LIST
23007: LIST
23008: LIST
23009: LIST
23010: LIST
23011: LIST
23012: LIST
23013: LIST
23014: LIST
23015: LIST
23016: LIST
23017: LIST
23018: PUSH
23019: LD_INT 101
23021: PUSH
23022: LD_INT 102
23024: PUSH
23025: LD_INT 103
23027: PUSH
23028: LD_INT 105
23030: PUSH
23031: LD_INT 106
23033: PUSH
23034: LD_INT 108
23036: PUSH
23037: LD_INT 112
23039: PUSH
23040: EMPTY
23041: LIST
23042: LIST
23043: LIST
23044: LIST
23045: LIST
23046: LIST
23047: LIST
23048: PUSH
23049: EMPTY
23050: LIST
23051: LIST
23052: ST_TO_ADDR
23053: GO 25312
23055: LD_INT 8
23057: DOUBLE
23058: EQUAL
23059: IFTRUE 23063
23061: GO 23191
23063: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 ] ] ; 9 :
23064: LD_ADDR_VAR 0 1
23068: PUSH
23069: LD_INT 2
23071: PUSH
23072: LD_INT 4
23074: PUSH
23075: LD_INT 5
23077: PUSH
23078: LD_INT 6
23080: PUSH
23081: LD_INT 7
23083: PUSH
23084: LD_INT 8
23086: PUSH
23087: LD_INT 11
23089: PUSH
23090: LD_INT 12
23092: PUSH
23093: LD_INT 15
23095: PUSH
23096: LD_INT 16
23098: PUSH
23099: LD_INT 20
23101: PUSH
23102: LD_INT 21
23104: PUSH
23105: LD_INT 22
23107: PUSH
23108: LD_INT 23
23110: PUSH
23111: LD_INT 25
23113: PUSH
23114: LD_INT 26
23116: PUSH
23117: LD_INT 30
23119: PUSH
23120: LD_INT 31
23122: PUSH
23123: LD_INT 32
23125: PUSH
23126: LD_INT 36
23128: PUSH
23129: EMPTY
23130: LIST
23131: LIST
23132: LIST
23133: LIST
23134: LIST
23135: LIST
23136: LIST
23137: LIST
23138: LIST
23139: LIST
23140: LIST
23141: LIST
23142: LIST
23143: LIST
23144: LIST
23145: LIST
23146: LIST
23147: LIST
23148: LIST
23149: LIST
23150: PUSH
23151: LD_INT 101
23153: PUSH
23154: LD_INT 102
23156: PUSH
23157: LD_INT 103
23159: PUSH
23160: LD_INT 105
23162: PUSH
23163: LD_INT 106
23165: PUSH
23166: LD_INT 108
23168: PUSH
23169: LD_INT 109
23171: PUSH
23172: LD_INT 112
23174: PUSH
23175: EMPTY
23176: LIST
23177: LIST
23178: LIST
23179: LIST
23180: LIST
23181: LIST
23182: LIST
23183: LIST
23184: PUSH
23185: EMPTY
23186: LIST
23187: LIST
23188: ST_TO_ADDR
23189: GO 25312
23191: LD_INT 9
23193: DOUBLE
23194: EQUAL
23195: IFTRUE 23199
23197: GO 23335
23199: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 ] ] ; 10 :
23200: LD_ADDR_VAR 0 1
23204: PUSH
23205: LD_INT 2
23207: PUSH
23208: LD_INT 4
23210: PUSH
23211: LD_INT 5
23213: PUSH
23214: LD_INT 6
23216: PUSH
23217: LD_INT 7
23219: PUSH
23220: LD_INT 8
23222: PUSH
23223: LD_INT 11
23225: PUSH
23226: LD_INT 12
23228: PUSH
23229: LD_INT 15
23231: PUSH
23232: LD_INT 16
23234: PUSH
23235: LD_INT 20
23237: PUSH
23238: LD_INT 21
23240: PUSH
23241: LD_INT 22
23243: PUSH
23244: LD_INT 23
23246: PUSH
23247: LD_INT 25
23249: PUSH
23250: LD_INT 26
23252: PUSH
23253: LD_INT 28
23255: PUSH
23256: LD_INT 30
23258: PUSH
23259: LD_INT 31
23261: PUSH
23262: LD_INT 32
23264: PUSH
23265: LD_INT 36
23267: PUSH
23268: EMPTY
23269: LIST
23270: LIST
23271: LIST
23272: LIST
23273: LIST
23274: LIST
23275: LIST
23276: LIST
23277: LIST
23278: LIST
23279: LIST
23280: LIST
23281: LIST
23282: LIST
23283: LIST
23284: LIST
23285: LIST
23286: LIST
23287: LIST
23288: LIST
23289: LIST
23290: PUSH
23291: LD_INT 101
23293: PUSH
23294: LD_INT 102
23296: PUSH
23297: LD_INT 103
23299: PUSH
23300: LD_INT 105
23302: PUSH
23303: LD_INT 106
23305: PUSH
23306: LD_INT 108
23308: PUSH
23309: LD_INT 109
23311: PUSH
23312: LD_INT 112
23314: PUSH
23315: LD_INT 114
23317: PUSH
23318: EMPTY
23319: LIST
23320: LIST
23321: LIST
23322: LIST
23323: LIST
23324: LIST
23325: LIST
23326: LIST
23327: LIST
23328: PUSH
23329: EMPTY
23330: LIST
23331: LIST
23332: ST_TO_ADDR
23333: GO 25312
23335: LD_INT 10
23337: DOUBLE
23338: EQUAL
23339: IFTRUE 23343
23341: GO 23527
23343: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 11 :
23344: LD_ADDR_VAR 0 1
23348: PUSH
23349: LD_INT 2
23351: PUSH
23352: LD_INT 4
23354: PUSH
23355: LD_INT 5
23357: PUSH
23358: LD_INT 6
23360: PUSH
23361: LD_INT 7
23363: PUSH
23364: LD_INT 8
23366: PUSH
23367: LD_INT 9
23369: PUSH
23370: LD_INT 10
23372: PUSH
23373: LD_INT 11
23375: PUSH
23376: LD_INT 12
23378: PUSH
23379: LD_INT 13
23381: PUSH
23382: LD_INT 14
23384: PUSH
23385: LD_INT 15
23387: PUSH
23388: LD_INT 16
23390: PUSH
23391: LD_INT 17
23393: PUSH
23394: LD_INT 18
23396: PUSH
23397: LD_INT 19
23399: PUSH
23400: LD_INT 20
23402: PUSH
23403: LD_INT 21
23405: PUSH
23406: LD_INT 22
23408: PUSH
23409: LD_INT 23
23411: PUSH
23412: LD_INT 24
23414: PUSH
23415: LD_INT 25
23417: PUSH
23418: LD_INT 26
23420: PUSH
23421: LD_INT 28
23423: PUSH
23424: LD_INT 30
23426: PUSH
23427: LD_INT 31
23429: PUSH
23430: LD_INT 32
23432: PUSH
23433: LD_INT 36
23435: PUSH
23436: EMPTY
23437: LIST
23438: LIST
23439: LIST
23440: LIST
23441: LIST
23442: LIST
23443: LIST
23444: LIST
23445: LIST
23446: LIST
23447: LIST
23448: LIST
23449: LIST
23450: LIST
23451: LIST
23452: LIST
23453: LIST
23454: LIST
23455: LIST
23456: LIST
23457: LIST
23458: LIST
23459: LIST
23460: LIST
23461: LIST
23462: LIST
23463: LIST
23464: LIST
23465: LIST
23466: PUSH
23467: LD_INT 101
23469: PUSH
23470: LD_INT 102
23472: PUSH
23473: LD_INT 103
23475: PUSH
23476: LD_INT 104
23478: PUSH
23479: LD_INT 105
23481: PUSH
23482: LD_INT 106
23484: PUSH
23485: LD_INT 107
23487: PUSH
23488: LD_INT 108
23490: PUSH
23491: LD_INT 109
23493: PUSH
23494: LD_INT 110
23496: PUSH
23497: LD_INT 111
23499: PUSH
23500: LD_INT 112
23502: PUSH
23503: LD_INT 114
23505: PUSH
23506: EMPTY
23507: LIST
23508: LIST
23509: LIST
23510: LIST
23511: LIST
23512: LIST
23513: LIST
23514: LIST
23515: LIST
23516: LIST
23517: LIST
23518: LIST
23519: LIST
23520: PUSH
23521: EMPTY
23522: LIST
23523: LIST
23524: ST_TO_ADDR
23525: GO 25312
23527: LD_INT 11
23529: DOUBLE
23530: EQUAL
23531: IFTRUE 23535
23533: GO 23727
23535: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 12 :
23536: LD_ADDR_VAR 0 1
23540: PUSH
23541: LD_INT 2
23543: PUSH
23544: LD_INT 3
23546: PUSH
23547: LD_INT 4
23549: PUSH
23550: LD_INT 5
23552: PUSH
23553: LD_INT 6
23555: PUSH
23556: LD_INT 7
23558: PUSH
23559: LD_INT 8
23561: PUSH
23562: LD_INT 9
23564: PUSH
23565: LD_INT 10
23567: PUSH
23568: LD_INT 11
23570: PUSH
23571: LD_INT 12
23573: PUSH
23574: LD_INT 13
23576: PUSH
23577: LD_INT 14
23579: PUSH
23580: LD_INT 15
23582: PUSH
23583: LD_INT 16
23585: PUSH
23586: LD_INT 17
23588: PUSH
23589: LD_INT 18
23591: PUSH
23592: LD_INT 19
23594: PUSH
23595: LD_INT 20
23597: PUSH
23598: LD_INT 21
23600: PUSH
23601: LD_INT 22
23603: PUSH
23604: LD_INT 23
23606: PUSH
23607: LD_INT 24
23609: PUSH
23610: LD_INT 25
23612: PUSH
23613: LD_INT 26
23615: PUSH
23616: LD_INT 28
23618: PUSH
23619: LD_INT 30
23621: PUSH
23622: LD_INT 31
23624: PUSH
23625: LD_INT 32
23627: PUSH
23628: LD_INT 34
23630: PUSH
23631: LD_INT 36
23633: PUSH
23634: EMPTY
23635: LIST
23636: LIST
23637: LIST
23638: LIST
23639: LIST
23640: LIST
23641: LIST
23642: LIST
23643: LIST
23644: LIST
23645: LIST
23646: LIST
23647: LIST
23648: LIST
23649: LIST
23650: LIST
23651: LIST
23652: LIST
23653: LIST
23654: LIST
23655: LIST
23656: LIST
23657: LIST
23658: LIST
23659: LIST
23660: LIST
23661: LIST
23662: LIST
23663: LIST
23664: LIST
23665: LIST
23666: PUSH
23667: LD_INT 101
23669: PUSH
23670: LD_INT 102
23672: PUSH
23673: LD_INT 103
23675: PUSH
23676: LD_INT 104
23678: PUSH
23679: LD_INT 105
23681: PUSH
23682: LD_INT 106
23684: PUSH
23685: LD_INT 107
23687: PUSH
23688: LD_INT 108
23690: PUSH
23691: LD_INT 109
23693: PUSH
23694: LD_INT 110
23696: PUSH
23697: LD_INT 111
23699: PUSH
23700: LD_INT 112
23702: PUSH
23703: LD_INT 114
23705: PUSH
23706: EMPTY
23707: LIST
23708: LIST
23709: LIST
23710: LIST
23711: LIST
23712: LIST
23713: LIST
23714: LIST
23715: LIST
23716: LIST
23717: LIST
23718: LIST
23719: LIST
23720: PUSH
23721: EMPTY
23722: LIST
23723: LIST
23724: ST_TO_ADDR
23725: GO 25312
23727: LD_INT 12
23729: DOUBLE
23730: EQUAL
23731: IFTRUE 23735
23733: GO 23943
23735: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 13 :
23736: LD_ADDR_VAR 0 1
23740: PUSH
23741: LD_INT 1
23743: PUSH
23744: LD_INT 2
23746: PUSH
23747: LD_INT 3
23749: PUSH
23750: LD_INT 4
23752: PUSH
23753: LD_INT 5
23755: PUSH
23756: LD_INT 6
23758: PUSH
23759: LD_INT 7
23761: PUSH
23762: LD_INT 8
23764: PUSH
23765: LD_INT 9
23767: PUSH
23768: LD_INT 10
23770: PUSH
23771: LD_INT 11
23773: PUSH
23774: LD_INT 12
23776: PUSH
23777: LD_INT 13
23779: PUSH
23780: LD_INT 14
23782: PUSH
23783: LD_INT 15
23785: PUSH
23786: LD_INT 16
23788: PUSH
23789: LD_INT 17
23791: PUSH
23792: LD_INT 18
23794: PUSH
23795: LD_INT 19
23797: PUSH
23798: LD_INT 20
23800: PUSH
23801: LD_INT 21
23803: PUSH
23804: LD_INT 22
23806: PUSH
23807: LD_INT 23
23809: PUSH
23810: LD_INT 24
23812: PUSH
23813: LD_INT 25
23815: PUSH
23816: LD_INT 26
23818: PUSH
23819: LD_INT 27
23821: PUSH
23822: LD_INT 28
23824: PUSH
23825: LD_INT 30
23827: PUSH
23828: LD_INT 31
23830: PUSH
23831: LD_INT 32
23833: PUSH
23834: LD_INT 33
23836: PUSH
23837: LD_INT 34
23839: PUSH
23840: LD_INT 36
23842: PUSH
23843: EMPTY
23844: LIST
23845: LIST
23846: LIST
23847: LIST
23848: LIST
23849: LIST
23850: LIST
23851: LIST
23852: LIST
23853: LIST
23854: LIST
23855: LIST
23856: LIST
23857: LIST
23858: LIST
23859: LIST
23860: LIST
23861: LIST
23862: LIST
23863: LIST
23864: LIST
23865: LIST
23866: LIST
23867: LIST
23868: LIST
23869: LIST
23870: LIST
23871: LIST
23872: LIST
23873: LIST
23874: LIST
23875: LIST
23876: LIST
23877: LIST
23878: PUSH
23879: LD_INT 101
23881: PUSH
23882: LD_INT 102
23884: PUSH
23885: LD_INT 103
23887: PUSH
23888: LD_INT 104
23890: PUSH
23891: LD_INT 105
23893: PUSH
23894: LD_INT 106
23896: PUSH
23897: LD_INT 107
23899: PUSH
23900: LD_INT 108
23902: PUSH
23903: LD_INT 109
23905: PUSH
23906: LD_INT 110
23908: PUSH
23909: LD_INT 111
23911: PUSH
23912: LD_INT 112
23914: PUSH
23915: LD_INT 113
23917: PUSH
23918: LD_INT 114
23920: PUSH
23921: EMPTY
23922: LIST
23923: LIST
23924: LIST
23925: LIST
23926: LIST
23927: LIST
23928: LIST
23929: LIST
23930: LIST
23931: LIST
23932: LIST
23933: LIST
23934: LIST
23935: LIST
23936: PUSH
23937: EMPTY
23938: LIST
23939: LIST
23940: ST_TO_ADDR
23941: GO 25312
23943: LD_INT 13
23945: DOUBLE
23946: EQUAL
23947: IFTRUE 23951
23949: GO 24147
23951: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 14 :
23952: LD_ADDR_VAR 0 1
23956: PUSH
23957: LD_INT 1
23959: PUSH
23960: LD_INT 2
23962: PUSH
23963: LD_INT 3
23965: PUSH
23966: LD_INT 4
23968: PUSH
23969: LD_INT 5
23971: PUSH
23972: LD_INT 8
23974: PUSH
23975: LD_INT 9
23977: PUSH
23978: LD_INT 10
23980: PUSH
23981: LD_INT 11
23983: PUSH
23984: LD_INT 12
23986: PUSH
23987: LD_INT 14
23989: PUSH
23990: LD_INT 15
23992: PUSH
23993: LD_INT 16
23995: PUSH
23996: LD_INT 17
23998: PUSH
23999: LD_INT 18
24001: PUSH
24002: LD_INT 19
24004: PUSH
24005: LD_INT 20
24007: PUSH
24008: LD_INT 21
24010: PUSH
24011: LD_INT 22
24013: PUSH
24014: LD_INT 23
24016: PUSH
24017: LD_INT 24
24019: PUSH
24020: LD_INT 25
24022: PUSH
24023: LD_INT 26
24025: PUSH
24026: LD_INT 27
24028: PUSH
24029: LD_INT 28
24031: PUSH
24032: LD_INT 30
24034: PUSH
24035: LD_INT 31
24037: PUSH
24038: LD_INT 32
24040: PUSH
24041: LD_INT 33
24043: PUSH
24044: LD_INT 34
24046: PUSH
24047: LD_INT 36
24049: PUSH
24050: EMPTY
24051: LIST
24052: LIST
24053: LIST
24054: LIST
24055: LIST
24056: LIST
24057: LIST
24058: LIST
24059: LIST
24060: LIST
24061: LIST
24062: LIST
24063: LIST
24064: LIST
24065: LIST
24066: LIST
24067: LIST
24068: LIST
24069: LIST
24070: LIST
24071: LIST
24072: LIST
24073: LIST
24074: LIST
24075: LIST
24076: LIST
24077: LIST
24078: LIST
24079: LIST
24080: LIST
24081: LIST
24082: PUSH
24083: LD_INT 101
24085: PUSH
24086: LD_INT 102
24088: PUSH
24089: LD_INT 103
24091: PUSH
24092: LD_INT 104
24094: PUSH
24095: LD_INT 105
24097: PUSH
24098: LD_INT 106
24100: PUSH
24101: LD_INT 107
24103: PUSH
24104: LD_INT 108
24106: PUSH
24107: LD_INT 109
24109: PUSH
24110: LD_INT 110
24112: PUSH
24113: LD_INT 111
24115: PUSH
24116: LD_INT 112
24118: PUSH
24119: LD_INT 113
24121: PUSH
24122: LD_INT 114
24124: PUSH
24125: EMPTY
24126: LIST
24127: LIST
24128: LIST
24129: LIST
24130: LIST
24131: LIST
24132: LIST
24133: LIST
24134: LIST
24135: LIST
24136: LIST
24137: LIST
24138: LIST
24139: LIST
24140: PUSH
24141: EMPTY
24142: LIST
24143: LIST
24144: ST_TO_ADDR
24145: GO 25312
24147: LD_INT 14
24149: DOUBLE
24150: EQUAL
24151: IFTRUE 24155
24153: GO 24367
24155: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 15 :
24156: LD_ADDR_VAR 0 1
24160: PUSH
24161: LD_INT 1
24163: PUSH
24164: LD_INT 2
24166: PUSH
24167: LD_INT 3
24169: PUSH
24170: LD_INT 4
24172: PUSH
24173: LD_INT 5
24175: PUSH
24176: LD_INT 6
24178: PUSH
24179: LD_INT 7
24181: PUSH
24182: LD_INT 8
24184: PUSH
24185: LD_INT 9
24187: PUSH
24188: LD_INT 10
24190: PUSH
24191: LD_INT 11
24193: PUSH
24194: LD_INT 12
24196: PUSH
24197: LD_INT 13
24199: PUSH
24200: LD_INT 14
24202: PUSH
24203: LD_INT 15
24205: PUSH
24206: LD_INT 16
24208: PUSH
24209: LD_INT 17
24211: PUSH
24212: LD_INT 18
24214: PUSH
24215: LD_INT 19
24217: PUSH
24218: LD_INT 20
24220: PUSH
24221: LD_INT 21
24223: PUSH
24224: LD_INT 22
24226: PUSH
24227: LD_INT 23
24229: PUSH
24230: LD_INT 24
24232: PUSH
24233: LD_INT 25
24235: PUSH
24236: LD_INT 26
24238: PUSH
24239: LD_INT 27
24241: PUSH
24242: LD_INT 28
24244: PUSH
24245: LD_INT 29
24247: PUSH
24248: LD_INT 30
24250: PUSH
24251: LD_INT 31
24253: PUSH
24254: LD_INT 32
24256: PUSH
24257: LD_INT 33
24259: PUSH
24260: LD_INT 34
24262: PUSH
24263: LD_INT 36
24265: PUSH
24266: EMPTY
24267: LIST
24268: LIST
24269: LIST
24270: LIST
24271: LIST
24272: LIST
24273: LIST
24274: LIST
24275: LIST
24276: LIST
24277: LIST
24278: LIST
24279: LIST
24280: LIST
24281: LIST
24282: LIST
24283: LIST
24284: LIST
24285: LIST
24286: LIST
24287: LIST
24288: LIST
24289: LIST
24290: LIST
24291: LIST
24292: LIST
24293: LIST
24294: LIST
24295: LIST
24296: LIST
24297: LIST
24298: LIST
24299: LIST
24300: LIST
24301: LIST
24302: PUSH
24303: LD_INT 101
24305: PUSH
24306: LD_INT 102
24308: PUSH
24309: LD_INT 103
24311: PUSH
24312: LD_INT 104
24314: PUSH
24315: LD_INT 105
24317: PUSH
24318: LD_INT 106
24320: PUSH
24321: LD_INT 107
24323: PUSH
24324: LD_INT 108
24326: PUSH
24327: LD_INT 109
24329: PUSH
24330: LD_INT 110
24332: PUSH
24333: LD_INT 111
24335: PUSH
24336: LD_INT 112
24338: PUSH
24339: LD_INT 113
24341: PUSH
24342: LD_INT 114
24344: PUSH
24345: EMPTY
24346: LIST
24347: LIST
24348: LIST
24349: LIST
24350: LIST
24351: LIST
24352: LIST
24353: LIST
24354: LIST
24355: LIST
24356: LIST
24357: LIST
24358: LIST
24359: LIST
24360: PUSH
24361: EMPTY
24362: LIST
24363: LIST
24364: ST_TO_ADDR
24365: GO 25312
24367: LD_INT 15
24369: DOUBLE
24370: EQUAL
24371: IFTRUE 24375
24373: GO 24587
24375: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 16 :
24376: LD_ADDR_VAR 0 1
24380: PUSH
24381: LD_INT 1
24383: PUSH
24384: LD_INT 2
24386: PUSH
24387: LD_INT 3
24389: PUSH
24390: LD_INT 4
24392: PUSH
24393: LD_INT 5
24395: PUSH
24396: LD_INT 6
24398: PUSH
24399: LD_INT 7
24401: PUSH
24402: LD_INT 8
24404: PUSH
24405: LD_INT 9
24407: PUSH
24408: LD_INT 10
24410: PUSH
24411: LD_INT 11
24413: PUSH
24414: LD_INT 12
24416: PUSH
24417: LD_INT 13
24419: PUSH
24420: LD_INT 14
24422: PUSH
24423: LD_INT 15
24425: PUSH
24426: LD_INT 16
24428: PUSH
24429: LD_INT 17
24431: PUSH
24432: LD_INT 18
24434: PUSH
24435: LD_INT 19
24437: PUSH
24438: LD_INT 20
24440: PUSH
24441: LD_INT 21
24443: PUSH
24444: LD_INT 22
24446: PUSH
24447: LD_INT 23
24449: PUSH
24450: LD_INT 24
24452: PUSH
24453: LD_INT 25
24455: PUSH
24456: LD_INT 26
24458: PUSH
24459: LD_INT 27
24461: PUSH
24462: LD_INT 28
24464: PUSH
24465: LD_INT 29
24467: PUSH
24468: LD_INT 30
24470: PUSH
24471: LD_INT 31
24473: PUSH
24474: LD_INT 32
24476: PUSH
24477: LD_INT 33
24479: PUSH
24480: LD_INT 34
24482: PUSH
24483: LD_INT 36
24485: PUSH
24486: EMPTY
24487: LIST
24488: LIST
24489: LIST
24490: LIST
24491: LIST
24492: LIST
24493: LIST
24494: LIST
24495: LIST
24496: LIST
24497: LIST
24498: LIST
24499: LIST
24500: LIST
24501: LIST
24502: LIST
24503: LIST
24504: LIST
24505: LIST
24506: LIST
24507: LIST
24508: LIST
24509: LIST
24510: LIST
24511: LIST
24512: LIST
24513: LIST
24514: LIST
24515: LIST
24516: LIST
24517: LIST
24518: LIST
24519: LIST
24520: LIST
24521: LIST
24522: PUSH
24523: LD_INT 101
24525: PUSH
24526: LD_INT 102
24528: PUSH
24529: LD_INT 103
24531: PUSH
24532: LD_INT 104
24534: PUSH
24535: LD_INT 105
24537: PUSH
24538: LD_INT 106
24540: PUSH
24541: LD_INT 107
24543: PUSH
24544: LD_INT 108
24546: PUSH
24547: LD_INT 109
24549: PUSH
24550: LD_INT 110
24552: PUSH
24553: LD_INT 111
24555: PUSH
24556: LD_INT 112
24558: PUSH
24559: LD_INT 113
24561: PUSH
24562: LD_INT 114
24564: PUSH
24565: EMPTY
24566: LIST
24567: LIST
24568: LIST
24569: LIST
24570: LIST
24571: LIST
24572: LIST
24573: LIST
24574: LIST
24575: LIST
24576: LIST
24577: LIST
24578: LIST
24579: LIST
24580: PUSH
24581: EMPTY
24582: LIST
24583: LIST
24584: ST_TO_ADDR
24585: GO 25312
24587: LD_INT 16
24589: DOUBLE
24590: EQUAL
24591: IFTRUE 24595
24593: GO 24719
24595: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 ] ] ; 17 :
24596: LD_ADDR_VAR 0 1
24600: PUSH
24601: LD_INT 2
24603: PUSH
24604: LD_INT 4
24606: PUSH
24607: LD_INT 5
24609: PUSH
24610: LD_INT 7
24612: PUSH
24613: LD_INT 11
24615: PUSH
24616: LD_INT 12
24618: PUSH
24619: LD_INT 15
24621: PUSH
24622: LD_INT 16
24624: PUSH
24625: LD_INT 20
24627: PUSH
24628: LD_INT 21
24630: PUSH
24631: LD_INT 22
24633: PUSH
24634: LD_INT 23
24636: PUSH
24637: LD_INT 25
24639: PUSH
24640: LD_INT 26
24642: PUSH
24643: LD_INT 30
24645: PUSH
24646: LD_INT 31
24648: PUSH
24649: LD_INT 32
24651: PUSH
24652: LD_INT 33
24654: PUSH
24655: LD_INT 34
24657: PUSH
24658: EMPTY
24659: LIST
24660: LIST
24661: LIST
24662: LIST
24663: LIST
24664: LIST
24665: LIST
24666: LIST
24667: LIST
24668: LIST
24669: LIST
24670: LIST
24671: LIST
24672: LIST
24673: LIST
24674: LIST
24675: LIST
24676: LIST
24677: LIST
24678: PUSH
24679: LD_INT 101
24681: PUSH
24682: LD_INT 102
24684: PUSH
24685: LD_INT 103
24687: PUSH
24688: LD_INT 106
24690: PUSH
24691: LD_INT 108
24693: PUSH
24694: LD_INT 112
24696: PUSH
24697: LD_INT 113
24699: PUSH
24700: LD_INT 114
24702: PUSH
24703: EMPTY
24704: LIST
24705: LIST
24706: LIST
24707: LIST
24708: LIST
24709: LIST
24710: LIST
24711: LIST
24712: PUSH
24713: EMPTY
24714: LIST
24715: LIST
24716: ST_TO_ADDR
24717: GO 25312
24719: LD_INT 17
24721: DOUBLE
24722: EQUAL
24723: IFTRUE 24727
24725: GO 24939
24727: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 18 :
24728: LD_ADDR_VAR 0 1
24732: PUSH
24733: LD_INT 1
24735: PUSH
24736: LD_INT 2
24738: PUSH
24739: LD_INT 3
24741: PUSH
24742: LD_INT 4
24744: PUSH
24745: LD_INT 5
24747: PUSH
24748: LD_INT 6
24750: PUSH
24751: LD_INT 7
24753: PUSH
24754: LD_INT 8
24756: PUSH
24757: LD_INT 9
24759: PUSH
24760: LD_INT 10
24762: PUSH
24763: LD_INT 11
24765: PUSH
24766: LD_INT 12
24768: PUSH
24769: LD_INT 13
24771: PUSH
24772: LD_INT 14
24774: PUSH
24775: LD_INT 15
24777: PUSH
24778: LD_INT 16
24780: PUSH
24781: LD_INT 17
24783: PUSH
24784: LD_INT 18
24786: PUSH
24787: LD_INT 19
24789: PUSH
24790: LD_INT 20
24792: PUSH
24793: LD_INT 21
24795: PUSH
24796: LD_INT 22
24798: PUSH
24799: LD_INT 23
24801: PUSH
24802: LD_INT 24
24804: PUSH
24805: LD_INT 25
24807: PUSH
24808: LD_INT 26
24810: PUSH
24811: LD_INT 27
24813: PUSH
24814: LD_INT 28
24816: PUSH
24817: LD_INT 29
24819: PUSH
24820: LD_INT 30
24822: PUSH
24823: LD_INT 31
24825: PUSH
24826: LD_INT 32
24828: PUSH
24829: LD_INT 33
24831: PUSH
24832: LD_INT 34
24834: PUSH
24835: LD_INT 36
24837: PUSH
24838: EMPTY
24839: LIST
24840: LIST
24841: LIST
24842: LIST
24843: LIST
24844: LIST
24845: LIST
24846: LIST
24847: LIST
24848: LIST
24849: LIST
24850: LIST
24851: LIST
24852: LIST
24853: LIST
24854: LIST
24855: LIST
24856: LIST
24857: LIST
24858: LIST
24859: LIST
24860: LIST
24861: LIST
24862: LIST
24863: LIST
24864: LIST
24865: LIST
24866: LIST
24867: LIST
24868: LIST
24869: LIST
24870: LIST
24871: LIST
24872: LIST
24873: LIST
24874: PUSH
24875: LD_INT 101
24877: PUSH
24878: LD_INT 102
24880: PUSH
24881: LD_INT 103
24883: PUSH
24884: LD_INT 104
24886: PUSH
24887: LD_INT 105
24889: PUSH
24890: LD_INT 106
24892: PUSH
24893: LD_INT 107
24895: PUSH
24896: LD_INT 108
24898: PUSH
24899: LD_INT 109
24901: PUSH
24902: LD_INT 110
24904: PUSH
24905: LD_INT 111
24907: PUSH
24908: LD_INT 112
24910: PUSH
24911: LD_INT 113
24913: PUSH
24914: LD_INT 114
24916: PUSH
24917: EMPTY
24918: LIST
24919: LIST
24920: LIST
24921: LIST
24922: LIST
24923: LIST
24924: LIST
24925: LIST
24926: LIST
24927: LIST
24928: LIST
24929: LIST
24930: LIST
24931: LIST
24932: PUSH
24933: EMPTY
24934: LIST
24935: LIST
24936: ST_TO_ADDR
24937: GO 25312
24939: LD_INT 18
24941: DOUBLE
24942: EQUAL
24943: IFTRUE 24947
24945: GO 25083
24947: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 ] ] ; 19 :
24948: LD_ADDR_VAR 0 1
24952: PUSH
24953: LD_INT 2
24955: PUSH
24956: LD_INT 4
24958: PUSH
24959: LD_INT 5
24961: PUSH
24962: LD_INT 7
24964: PUSH
24965: LD_INT 11
24967: PUSH
24968: LD_INT 12
24970: PUSH
24971: LD_INT 15
24973: PUSH
24974: LD_INT 16
24976: PUSH
24977: LD_INT 20
24979: PUSH
24980: LD_INT 21
24982: PUSH
24983: LD_INT 22
24985: PUSH
24986: LD_INT 23
24988: PUSH
24989: LD_INT 25
24991: PUSH
24992: LD_INT 26
24994: PUSH
24995: LD_INT 30
24997: PUSH
24998: LD_INT 31
25000: PUSH
25001: LD_INT 32
25003: PUSH
25004: LD_INT 33
25006: PUSH
25007: LD_INT 34
25009: PUSH
25010: LD_INT 35
25012: PUSH
25013: LD_INT 36
25015: PUSH
25016: EMPTY
25017: LIST
25018: LIST
25019: LIST
25020: LIST
25021: LIST
25022: LIST
25023: LIST
25024: LIST
25025: LIST
25026: LIST
25027: LIST
25028: LIST
25029: LIST
25030: LIST
25031: LIST
25032: LIST
25033: LIST
25034: LIST
25035: LIST
25036: LIST
25037: LIST
25038: PUSH
25039: LD_INT 101
25041: PUSH
25042: LD_INT 102
25044: PUSH
25045: LD_INT 103
25047: PUSH
25048: LD_INT 106
25050: PUSH
25051: LD_INT 108
25053: PUSH
25054: LD_INT 112
25056: PUSH
25057: LD_INT 113
25059: PUSH
25060: LD_INT 114
25062: PUSH
25063: LD_INT 115
25065: PUSH
25066: EMPTY
25067: LIST
25068: LIST
25069: LIST
25070: LIST
25071: LIST
25072: LIST
25073: LIST
25074: LIST
25075: LIST
25076: PUSH
25077: EMPTY
25078: LIST
25079: LIST
25080: ST_TO_ADDR
25081: GO 25312
25083: LD_INT 19
25085: DOUBLE
25086: EQUAL
25087: IFTRUE 25091
25089: GO 25311
25091: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ; end ;
25092: LD_ADDR_VAR 0 1
25096: PUSH
25097: LD_INT 1
25099: PUSH
25100: LD_INT 2
25102: PUSH
25103: LD_INT 3
25105: PUSH
25106: LD_INT 4
25108: PUSH
25109: LD_INT 5
25111: PUSH
25112: LD_INT 6
25114: PUSH
25115: LD_INT 7
25117: PUSH
25118: LD_INT 8
25120: PUSH
25121: LD_INT 9
25123: PUSH
25124: LD_INT 10
25126: PUSH
25127: LD_INT 11
25129: PUSH
25130: LD_INT 12
25132: PUSH
25133: LD_INT 13
25135: PUSH
25136: LD_INT 14
25138: PUSH
25139: LD_INT 15
25141: PUSH
25142: LD_INT 16
25144: PUSH
25145: LD_INT 17
25147: PUSH
25148: LD_INT 18
25150: PUSH
25151: LD_INT 19
25153: PUSH
25154: LD_INT 20
25156: PUSH
25157: LD_INT 21
25159: PUSH
25160: LD_INT 22
25162: PUSH
25163: LD_INT 23
25165: PUSH
25166: LD_INT 24
25168: PUSH
25169: LD_INT 25
25171: PUSH
25172: LD_INT 26
25174: PUSH
25175: LD_INT 27
25177: PUSH
25178: LD_INT 28
25180: PUSH
25181: LD_INT 29
25183: PUSH
25184: LD_INT 30
25186: PUSH
25187: LD_INT 31
25189: PUSH
25190: LD_INT 32
25192: PUSH
25193: LD_INT 33
25195: PUSH
25196: LD_INT 34
25198: PUSH
25199: LD_INT 35
25201: PUSH
25202: LD_INT 36
25204: PUSH
25205: EMPTY
25206: LIST
25207: LIST
25208: LIST
25209: LIST
25210: LIST
25211: LIST
25212: LIST
25213: LIST
25214: LIST
25215: LIST
25216: LIST
25217: LIST
25218: LIST
25219: LIST
25220: LIST
25221: LIST
25222: LIST
25223: LIST
25224: LIST
25225: LIST
25226: LIST
25227: LIST
25228: LIST
25229: LIST
25230: LIST
25231: LIST
25232: LIST
25233: LIST
25234: LIST
25235: LIST
25236: LIST
25237: LIST
25238: LIST
25239: LIST
25240: LIST
25241: LIST
25242: PUSH
25243: LD_INT 101
25245: PUSH
25246: LD_INT 102
25248: PUSH
25249: LD_INT 103
25251: PUSH
25252: LD_INT 104
25254: PUSH
25255: LD_INT 105
25257: PUSH
25258: LD_INT 106
25260: PUSH
25261: LD_INT 107
25263: PUSH
25264: LD_INT 108
25266: PUSH
25267: LD_INT 109
25269: PUSH
25270: LD_INT 110
25272: PUSH
25273: LD_INT 111
25275: PUSH
25276: LD_INT 112
25278: PUSH
25279: LD_INT 113
25281: PUSH
25282: LD_INT 114
25284: PUSH
25285: LD_INT 115
25287: PUSH
25288: EMPTY
25289: LIST
25290: LIST
25291: LIST
25292: LIST
25293: LIST
25294: LIST
25295: LIST
25296: LIST
25297: LIST
25298: LIST
25299: LIST
25300: LIST
25301: LIST
25302: LIST
25303: LIST
25304: PUSH
25305: EMPTY
25306: LIST
25307: LIST
25308: ST_TO_ADDR
25309: GO 25312
25311: POP
// end else
25312: GO 25531
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ;
25314: LD_ADDR_VAR 0 1
25318: PUSH
25319: LD_INT 1
25321: PUSH
25322: LD_INT 2
25324: PUSH
25325: LD_INT 3
25327: PUSH
25328: LD_INT 4
25330: PUSH
25331: LD_INT 5
25333: PUSH
25334: LD_INT 6
25336: PUSH
25337: LD_INT 7
25339: PUSH
25340: LD_INT 8
25342: PUSH
25343: LD_INT 9
25345: PUSH
25346: LD_INT 10
25348: PUSH
25349: LD_INT 11
25351: PUSH
25352: LD_INT 12
25354: PUSH
25355: LD_INT 13
25357: PUSH
25358: LD_INT 14
25360: PUSH
25361: LD_INT 15
25363: PUSH
25364: LD_INT 16
25366: PUSH
25367: LD_INT 17
25369: PUSH
25370: LD_INT 18
25372: PUSH
25373: LD_INT 19
25375: PUSH
25376: LD_INT 20
25378: PUSH
25379: LD_INT 21
25381: PUSH
25382: LD_INT 22
25384: PUSH
25385: LD_INT 23
25387: PUSH
25388: LD_INT 24
25390: PUSH
25391: LD_INT 25
25393: PUSH
25394: LD_INT 26
25396: PUSH
25397: LD_INT 27
25399: PUSH
25400: LD_INT 28
25402: PUSH
25403: LD_INT 29
25405: PUSH
25406: LD_INT 30
25408: PUSH
25409: LD_INT 31
25411: PUSH
25412: LD_INT 32
25414: PUSH
25415: LD_INT 33
25417: PUSH
25418: LD_INT 34
25420: PUSH
25421: LD_INT 35
25423: PUSH
25424: LD_INT 36
25426: PUSH
25427: EMPTY
25428: LIST
25429: LIST
25430: LIST
25431: LIST
25432: LIST
25433: LIST
25434: LIST
25435: LIST
25436: LIST
25437: LIST
25438: LIST
25439: LIST
25440: LIST
25441: LIST
25442: LIST
25443: LIST
25444: LIST
25445: LIST
25446: LIST
25447: LIST
25448: LIST
25449: LIST
25450: LIST
25451: LIST
25452: LIST
25453: LIST
25454: LIST
25455: LIST
25456: LIST
25457: LIST
25458: LIST
25459: LIST
25460: LIST
25461: LIST
25462: LIST
25463: LIST
25464: PUSH
25465: LD_INT 101
25467: PUSH
25468: LD_INT 102
25470: PUSH
25471: LD_INT 103
25473: PUSH
25474: LD_INT 104
25476: PUSH
25477: LD_INT 105
25479: PUSH
25480: LD_INT 106
25482: PUSH
25483: LD_INT 107
25485: PUSH
25486: LD_INT 108
25488: PUSH
25489: LD_INT 109
25491: PUSH
25492: LD_INT 110
25494: PUSH
25495: LD_INT 111
25497: PUSH
25498: LD_INT 112
25500: PUSH
25501: LD_INT 113
25503: PUSH
25504: LD_INT 114
25506: PUSH
25507: LD_INT 115
25509: PUSH
25510: EMPTY
25511: LIST
25512: LIST
25513: LIST
25514: LIST
25515: LIST
25516: LIST
25517: LIST
25518: LIST
25519: LIST
25520: LIST
25521: LIST
25522: LIST
25523: LIST
25524: LIST
25525: LIST
25526: PUSH
25527: EMPTY
25528: LIST
25529: LIST
25530: ST_TO_ADDR
// if result then
25531: LD_VAR 0 1
25535: IFFALSE 25824
// begin normal :=  ;
25537: LD_ADDR_VAR 0 3
25541: PUSH
25542: LD_STRING 
25544: ST_TO_ADDR
// hardcore :=  ;
25545: LD_ADDR_VAR 0 4
25549: PUSH
25550: LD_STRING 
25552: ST_TO_ADDR
// for i = 1 to normalCounter do
25553: LD_ADDR_VAR 0 5
25557: PUSH
25558: DOUBLE
25559: LD_INT 1
25561: DEC
25562: ST_TO_ADDR
25563: LD_EXP 91
25567: PUSH
25568: FOR_TO
25569: IFFALSE 25670
// begin tmp := 0 ;
25571: LD_ADDR_VAR 0 2
25575: PUSH
25576: LD_STRING 0
25578: ST_TO_ADDR
// if result [ 1 ] then
25579: LD_VAR 0 1
25583: PUSH
25584: LD_INT 1
25586: ARRAY
25587: IFFALSE 25652
// if result [ 1 ] [ 1 ] = i then
25589: LD_VAR 0 1
25593: PUSH
25594: LD_INT 1
25596: ARRAY
25597: PUSH
25598: LD_INT 1
25600: ARRAY
25601: PUSH
25602: LD_VAR 0 5
25606: EQUAL
25607: IFFALSE 25652
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
25609: LD_ADDR_VAR 0 1
25613: PUSH
25614: LD_VAR 0 1
25618: PPUSH
25619: LD_INT 1
25621: PPUSH
25622: LD_VAR 0 1
25626: PUSH
25627: LD_INT 1
25629: ARRAY
25630: PPUSH
25631: LD_INT 1
25633: PPUSH
25634: CALL_OW 3
25638: PPUSH
25639: CALL_OW 1
25643: ST_TO_ADDR
// tmp := 1 ;
25644: LD_ADDR_VAR 0 2
25648: PUSH
25649: LD_STRING 1
25651: ST_TO_ADDR
// end ; normal := normal & tmp ;
25652: LD_ADDR_VAR 0 3
25656: PUSH
25657: LD_VAR 0 3
25661: PUSH
25662: LD_VAR 0 2
25666: STR
25667: ST_TO_ADDR
// end ;
25668: GO 25568
25670: POP
25671: POP
// for i = 1 to hardcoreCounter do
25672: LD_ADDR_VAR 0 5
25676: PUSH
25677: DOUBLE
25678: LD_INT 1
25680: DEC
25681: ST_TO_ADDR
25682: LD_EXP 92
25686: PUSH
25687: FOR_TO
25688: IFFALSE 25793
// begin tmp := 0 ;
25690: LD_ADDR_VAR 0 2
25694: PUSH
25695: LD_STRING 0
25697: ST_TO_ADDR
// if result [ 2 ] then
25698: LD_VAR 0 1
25702: PUSH
25703: LD_INT 2
25705: ARRAY
25706: IFFALSE 25775
// if result [ 2 ] [ 1 ] = 100 + i then
25708: LD_VAR 0 1
25712: PUSH
25713: LD_INT 2
25715: ARRAY
25716: PUSH
25717: LD_INT 1
25719: ARRAY
25720: PUSH
25721: LD_INT 100
25723: PUSH
25724: LD_VAR 0 5
25728: PLUS
25729: EQUAL
25730: IFFALSE 25775
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
25732: LD_ADDR_VAR 0 1
25736: PUSH
25737: LD_VAR 0 1
25741: PPUSH
25742: LD_INT 2
25744: PPUSH
25745: LD_VAR 0 1
25749: PUSH
25750: LD_INT 2
25752: ARRAY
25753: PPUSH
25754: LD_INT 1
25756: PPUSH
25757: CALL_OW 3
25761: PPUSH
25762: CALL_OW 1
25766: ST_TO_ADDR
// tmp := 1 ;
25767: LD_ADDR_VAR 0 2
25771: PUSH
25772: LD_STRING 1
25774: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
25775: LD_ADDR_VAR 0 4
25779: PUSH
25780: LD_VAR 0 4
25784: PUSH
25785: LD_VAR 0 2
25789: STR
25790: ST_TO_ADDR
// end ;
25791: GO 25687
25793: POP
25794: POP
// ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & ") ) ;
25795: LD_STRING getStreamItemsFromMission("
25797: PUSH
25798: LD_VAR 0 3
25802: STR
25803: PUSH
25804: LD_STRING ","
25806: STR
25807: PUSH
25808: LD_VAR 0 4
25812: STR
25813: PUSH
25814: LD_STRING ")
25816: STR
25817: PPUSH
25818: CALL_OW 559
// end else
25822: GO 25831
// ToLua ( getStreamItemsFromMission("","") ) ;
25824: LD_STRING getStreamItemsFromMission("","")
25826: PPUSH
25827: CALL_OW 559
// end ;
25831: LD_VAR 0 1
25835: RET
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
25836: LD_EXP 90
25840: PUSH
25841: LD_EXP 95
25845: AND
25846: IFFALSE 25970
25848: GO 25850
25850: DISABLE
25851: LD_INT 0
25853: PPUSH
25854: PPUSH
// begin enable ;
25855: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
25856: LD_ADDR_VAR 0 2
25860: PUSH
25861: LD_INT 22
25863: PUSH
25864: LD_OWVAR 2
25868: PUSH
25869: EMPTY
25870: LIST
25871: LIST
25872: PUSH
25873: LD_INT 2
25875: PUSH
25876: LD_INT 34
25878: PUSH
25879: LD_INT 7
25881: PUSH
25882: EMPTY
25883: LIST
25884: LIST
25885: PUSH
25886: LD_INT 34
25888: PUSH
25889: LD_INT 45
25891: PUSH
25892: EMPTY
25893: LIST
25894: LIST
25895: PUSH
25896: LD_INT 34
25898: PUSH
25899: LD_INT 28
25901: PUSH
25902: EMPTY
25903: LIST
25904: LIST
25905: PUSH
25906: LD_INT 34
25908: PUSH
25909: LD_INT 47
25911: PUSH
25912: EMPTY
25913: LIST
25914: LIST
25915: PUSH
25916: EMPTY
25917: LIST
25918: LIST
25919: LIST
25920: LIST
25921: LIST
25922: PUSH
25923: EMPTY
25924: LIST
25925: LIST
25926: PPUSH
25927: CALL_OW 69
25931: ST_TO_ADDR
// if not tmp then
25932: LD_VAR 0 2
25936: NOT
25937: IFFALSE 25941
// exit ;
25939: GO 25970
// for i in tmp do
25941: LD_ADDR_VAR 0 1
25945: PUSH
25946: LD_VAR 0 2
25950: PUSH
25951: FOR_IN
25952: IFFALSE 25968
// begin SetLives ( i , 0 ) ;
25954: LD_VAR 0 1
25958: PPUSH
25959: LD_INT 0
25961: PPUSH
25962: CALL_OW 234
// end ;
25966: GO 25951
25968: POP
25969: POP
// end ;
25970: PPOPN 2
25972: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
25973: LD_EXP 90
25977: PUSH
25978: LD_EXP 96
25982: AND
25983: IFFALSE 26067
25985: GO 25987
25987: DISABLE
25988: LD_INT 0
25990: PPUSH
25991: PPUSH
// begin enable ;
25992: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
25993: LD_ADDR_VAR 0 2
25997: PUSH
25998: LD_INT 22
26000: PUSH
26001: LD_OWVAR 2
26005: PUSH
26006: EMPTY
26007: LIST
26008: LIST
26009: PUSH
26010: LD_INT 32
26012: PUSH
26013: LD_INT 3
26015: PUSH
26016: EMPTY
26017: LIST
26018: LIST
26019: PUSH
26020: EMPTY
26021: LIST
26022: LIST
26023: PPUSH
26024: CALL_OW 69
26028: ST_TO_ADDR
// if not tmp then
26029: LD_VAR 0 2
26033: NOT
26034: IFFALSE 26038
// exit ;
26036: GO 26067
// for i in tmp do
26038: LD_ADDR_VAR 0 1
26042: PUSH
26043: LD_VAR 0 2
26047: PUSH
26048: FOR_IN
26049: IFFALSE 26065
// begin SetLives ( i , 0 ) ;
26051: LD_VAR 0 1
26055: PPUSH
26056: LD_INT 0
26058: PPUSH
26059: CALL_OW 234
// end ;
26063: GO 26048
26065: POP
26066: POP
// end ;
26067: PPOPN 2
26069: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
26070: LD_EXP 90
26074: PUSH
26075: LD_EXP 93
26079: AND
26080: IFFALSE 26173
26082: GO 26084
26084: DISABLE
26085: LD_INT 0
26087: PPUSH
// begin enable ;
26088: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
26089: LD_ADDR_VAR 0 1
26093: PUSH
26094: LD_INT 22
26096: PUSH
26097: LD_OWVAR 2
26101: PUSH
26102: EMPTY
26103: LIST
26104: LIST
26105: PUSH
26106: LD_INT 2
26108: PUSH
26109: LD_INT 25
26111: PUSH
26112: LD_INT 5
26114: PUSH
26115: EMPTY
26116: LIST
26117: LIST
26118: PUSH
26119: LD_INT 25
26121: PUSH
26122: LD_INT 9
26124: PUSH
26125: EMPTY
26126: LIST
26127: LIST
26128: PUSH
26129: LD_INT 25
26131: PUSH
26132: LD_INT 8
26134: PUSH
26135: EMPTY
26136: LIST
26137: LIST
26138: PUSH
26139: EMPTY
26140: LIST
26141: LIST
26142: LIST
26143: LIST
26144: PUSH
26145: EMPTY
26146: LIST
26147: LIST
26148: PPUSH
26149: CALL_OW 69
26153: PUSH
26154: FOR_IN
26155: IFFALSE 26171
// begin SetClass ( i , 1 ) ;
26157: LD_VAR 0 1
26161: PPUSH
26162: LD_INT 1
26164: PPUSH
26165: CALL_OW 336
// end ;
26169: GO 26154
26171: POP
26172: POP
// end ;
26173: PPOPN 1
26175: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
26176: LD_EXP 90
26180: PUSH
26181: LD_EXP 94
26185: AND
26186: PUSH
26187: LD_OWVAR 65
26191: PUSH
26192: LD_INT 7
26194: LESS
26195: AND
26196: IFFALSE 26210
26198: GO 26200
26200: DISABLE
// begin enable ;
26201: ENABLE
// game_speed := 7 ;
26202: LD_ADDR_OWVAR 65
26206: PUSH
26207: LD_INT 7
26209: ST_TO_ADDR
// end ;
26210: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
26211: LD_EXP 90
26215: PUSH
26216: LD_EXP 97
26220: AND
26221: IFFALSE 26423
26223: GO 26225
26225: DISABLE
26226: LD_INT 0
26228: PPUSH
26229: PPUSH
26230: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
26231: LD_ADDR_VAR 0 3
26235: PUSH
26236: LD_INT 81
26238: PUSH
26239: LD_OWVAR 2
26243: PUSH
26244: EMPTY
26245: LIST
26246: LIST
26247: PUSH
26248: LD_INT 21
26250: PUSH
26251: LD_INT 1
26253: PUSH
26254: EMPTY
26255: LIST
26256: LIST
26257: PUSH
26258: EMPTY
26259: LIST
26260: LIST
26261: PPUSH
26262: CALL_OW 69
26266: ST_TO_ADDR
// if not tmp then
26267: LD_VAR 0 3
26271: NOT
26272: IFFALSE 26276
// exit ;
26274: GO 26423
// if tmp > 5 then
26276: LD_VAR 0 3
26280: PUSH
26281: LD_INT 5
26283: GREATER
26284: IFFALSE 26296
// k := 5 else
26286: LD_ADDR_VAR 0 2
26290: PUSH
26291: LD_INT 5
26293: ST_TO_ADDR
26294: GO 26306
// k := tmp ;
26296: LD_ADDR_VAR 0 2
26300: PUSH
26301: LD_VAR 0 3
26305: ST_TO_ADDR
// for i := 1 to k do
26306: LD_ADDR_VAR 0 1
26310: PUSH
26311: DOUBLE
26312: LD_INT 1
26314: DEC
26315: ST_TO_ADDR
26316: LD_VAR 0 2
26320: PUSH
26321: FOR_TO
26322: IFFALSE 26421
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
26324: LD_VAR 0 3
26328: PUSH
26329: LD_VAR 0 1
26333: ARRAY
26334: PPUSH
26335: LD_VAR 0 1
26339: PUSH
26340: LD_INT 4
26342: MOD
26343: PUSH
26344: LD_INT 1
26346: PLUS
26347: PPUSH
26348: CALL_OW 259
26352: PUSH
26353: LD_INT 10
26355: LESS
26356: IFFALSE 26419
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
26358: LD_VAR 0 3
26362: PUSH
26363: LD_VAR 0 1
26367: ARRAY
26368: PPUSH
26369: LD_VAR 0 1
26373: PUSH
26374: LD_INT 4
26376: MOD
26377: PUSH
26378: LD_INT 1
26380: PLUS
26381: PPUSH
26382: LD_VAR 0 3
26386: PUSH
26387: LD_VAR 0 1
26391: ARRAY
26392: PPUSH
26393: LD_VAR 0 1
26397: PUSH
26398: LD_INT 4
26400: MOD
26401: PUSH
26402: LD_INT 1
26404: PLUS
26405: PPUSH
26406: CALL_OW 259
26410: PUSH
26411: LD_INT 1
26413: PLUS
26414: PPUSH
26415: CALL_OW 237
26419: GO 26321
26421: POP
26422: POP
// end ;
26423: PPOPN 3
26425: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
26426: LD_EXP 90
26430: PUSH
26431: LD_EXP 98
26435: AND
26436: IFFALSE 26456
26438: GO 26440
26440: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
26441: LD_INT 4
26443: PPUSH
26444: LD_OWVAR 2
26448: PPUSH
26449: LD_INT 0
26451: PPUSH
26452: CALL_OW 324
26456: END
// every 0 0$1 trigger StreamModeActive and sShovel do
26457: LD_EXP 90
26461: PUSH
26462: LD_EXP 127
26466: AND
26467: IFFALSE 26487
26469: GO 26471
26471: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
26472: LD_INT 19
26474: PPUSH
26475: LD_OWVAR 2
26479: PPUSH
26480: LD_INT 0
26482: PPUSH
26483: CALL_OW 324
26487: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
26488: LD_EXP 90
26492: PUSH
26493: LD_EXP 99
26497: AND
26498: IFFALSE 26600
26500: GO 26502
26502: DISABLE
26503: LD_INT 0
26505: PPUSH
26506: PPUSH
// begin enable ;
26507: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
26508: LD_ADDR_VAR 0 2
26512: PUSH
26513: LD_INT 22
26515: PUSH
26516: LD_OWVAR 2
26520: PUSH
26521: EMPTY
26522: LIST
26523: LIST
26524: PUSH
26525: LD_INT 2
26527: PUSH
26528: LD_INT 34
26530: PUSH
26531: LD_INT 11
26533: PUSH
26534: EMPTY
26535: LIST
26536: LIST
26537: PUSH
26538: LD_INT 34
26540: PUSH
26541: LD_INT 30
26543: PUSH
26544: EMPTY
26545: LIST
26546: LIST
26547: PUSH
26548: EMPTY
26549: LIST
26550: LIST
26551: LIST
26552: PUSH
26553: EMPTY
26554: LIST
26555: LIST
26556: PPUSH
26557: CALL_OW 69
26561: ST_TO_ADDR
// if not tmp then
26562: LD_VAR 0 2
26566: NOT
26567: IFFALSE 26571
// exit ;
26569: GO 26600
// for i in tmp do
26571: LD_ADDR_VAR 0 1
26575: PUSH
26576: LD_VAR 0 2
26580: PUSH
26581: FOR_IN
26582: IFFALSE 26598
// begin SetLives ( i , 0 ) ;
26584: LD_VAR 0 1
26588: PPUSH
26589: LD_INT 0
26591: PPUSH
26592: CALL_OW 234
// end ;
26596: GO 26581
26598: POP
26599: POP
// end ;
26600: PPOPN 2
26602: END
// every 0 0$1 trigger StreamModeActive and sBunker do
26603: LD_EXP 90
26607: PUSH
26608: LD_EXP 100
26612: AND
26613: IFFALSE 26633
26615: GO 26617
26617: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
26618: LD_INT 32
26620: PPUSH
26621: LD_OWVAR 2
26625: PPUSH
26626: LD_INT 0
26628: PPUSH
26629: CALL_OW 324
26633: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
26634: LD_EXP 90
26638: PUSH
26639: LD_EXP 101
26643: AND
26644: IFFALSE 26825
26646: GO 26648
26648: DISABLE
26649: LD_INT 0
26651: PPUSH
26652: PPUSH
26653: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
26654: LD_ADDR_VAR 0 2
26658: PUSH
26659: LD_INT 22
26661: PUSH
26662: LD_OWVAR 2
26666: PUSH
26667: EMPTY
26668: LIST
26669: LIST
26670: PUSH
26671: LD_INT 33
26673: PUSH
26674: LD_INT 3
26676: PUSH
26677: EMPTY
26678: LIST
26679: LIST
26680: PUSH
26681: EMPTY
26682: LIST
26683: LIST
26684: PPUSH
26685: CALL_OW 69
26689: ST_TO_ADDR
// if not tmp then
26690: LD_VAR 0 2
26694: NOT
26695: IFFALSE 26699
// exit ;
26697: GO 26825
// side := 0 ;
26699: LD_ADDR_VAR 0 3
26703: PUSH
26704: LD_INT 0
26706: ST_TO_ADDR
// for i := 1 to 8 do
26707: LD_ADDR_VAR 0 1
26711: PUSH
26712: DOUBLE
26713: LD_INT 1
26715: DEC
26716: ST_TO_ADDR
26717: LD_INT 8
26719: PUSH
26720: FOR_TO
26721: IFFALSE 26769
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
26723: LD_OWVAR 2
26727: PUSH
26728: LD_VAR 0 1
26732: NONEQUAL
26733: PUSH
26734: LD_OWVAR 2
26738: PPUSH
26739: LD_VAR 0 1
26743: PPUSH
26744: CALL_OW 81
26748: PUSH
26749: LD_INT 2
26751: EQUAL
26752: AND
26753: IFFALSE 26767
// begin side := i ;
26755: LD_ADDR_VAR 0 3
26759: PUSH
26760: LD_VAR 0 1
26764: ST_TO_ADDR
// break ;
26765: GO 26769
// end ;
26767: GO 26720
26769: POP
26770: POP
// if not side then
26771: LD_VAR 0 3
26775: NOT
26776: IFFALSE 26780
// exit ;
26778: GO 26825
// for i := 1 to tmp do
26780: LD_ADDR_VAR 0 1
26784: PUSH
26785: DOUBLE
26786: LD_INT 1
26788: DEC
26789: ST_TO_ADDR
26790: LD_VAR 0 2
26794: PUSH
26795: FOR_TO
26796: IFFALSE 26823
// if Prob ( 60 ) then
26798: LD_INT 60
26800: PPUSH
26801: CALL_OW 13
26805: IFFALSE 26821
// SetSide ( i , side ) ;
26807: LD_VAR 0 1
26811: PPUSH
26812: LD_VAR 0 3
26816: PPUSH
26817: CALL_OW 235
26821: GO 26795
26823: POP
26824: POP
// end ;
26825: PPOPN 3
26827: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
26828: LD_EXP 90
26832: PUSH
26833: LD_EXP 103
26837: AND
26838: IFFALSE 26957
26840: GO 26842
26842: DISABLE
26843: LD_INT 0
26845: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
26846: LD_ADDR_VAR 0 1
26850: PUSH
26851: LD_INT 22
26853: PUSH
26854: LD_OWVAR 2
26858: PUSH
26859: EMPTY
26860: LIST
26861: LIST
26862: PUSH
26863: LD_INT 21
26865: PUSH
26866: LD_INT 1
26868: PUSH
26869: EMPTY
26870: LIST
26871: LIST
26872: PUSH
26873: LD_INT 3
26875: PUSH
26876: LD_INT 23
26878: PUSH
26879: LD_INT 0
26881: PUSH
26882: EMPTY
26883: LIST
26884: LIST
26885: PUSH
26886: EMPTY
26887: LIST
26888: LIST
26889: PUSH
26890: EMPTY
26891: LIST
26892: LIST
26893: LIST
26894: PPUSH
26895: CALL_OW 69
26899: PUSH
26900: FOR_IN
26901: IFFALSE 26955
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
26903: LD_VAR 0 1
26907: PPUSH
26908: CALL_OW 257
26912: PUSH
26913: LD_INT 1
26915: PUSH
26916: LD_INT 2
26918: PUSH
26919: LD_INT 3
26921: PUSH
26922: LD_INT 4
26924: PUSH
26925: EMPTY
26926: LIST
26927: LIST
26928: LIST
26929: LIST
26930: IN
26931: IFFALSE 26953
// SetClass ( un , rand ( 1 , 4 ) ) ;
26933: LD_VAR 0 1
26937: PPUSH
26938: LD_INT 1
26940: PPUSH
26941: LD_INT 4
26943: PPUSH
26944: CALL_OW 12
26948: PPUSH
26949: CALL_OW 336
26953: GO 26900
26955: POP
26956: POP
// end ;
26957: PPOPN 1
26959: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
26960: LD_EXP 90
26964: PUSH
26965: LD_EXP 102
26969: AND
26970: IFFALSE 27049
26972: GO 26974
26974: DISABLE
26975: LD_INT 0
26977: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
26978: LD_ADDR_VAR 0 1
26982: PUSH
26983: LD_INT 22
26985: PUSH
26986: LD_OWVAR 2
26990: PUSH
26991: EMPTY
26992: LIST
26993: LIST
26994: PUSH
26995: LD_INT 21
26997: PUSH
26998: LD_INT 3
27000: PUSH
27001: EMPTY
27002: LIST
27003: LIST
27004: PUSH
27005: EMPTY
27006: LIST
27007: LIST
27008: PPUSH
27009: CALL_OW 69
27013: ST_TO_ADDR
// if not tmp then
27014: LD_VAR 0 1
27018: NOT
27019: IFFALSE 27023
// exit ;
27021: GO 27049
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
27023: LD_VAR 0 1
27027: PUSH
27028: LD_INT 1
27030: PPUSH
27031: LD_VAR 0 1
27035: PPUSH
27036: CALL_OW 12
27040: ARRAY
27041: PPUSH
27042: LD_INT 100
27044: PPUSH
27045: CALL_OW 234
// end ;
27049: PPOPN 1
27051: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
27052: LD_EXP 90
27056: PUSH
27057: LD_EXP 104
27061: AND
27062: IFFALSE 27160
27064: GO 27066
27066: DISABLE
27067: LD_INT 0
27069: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
27070: LD_ADDR_VAR 0 1
27074: PUSH
27075: LD_INT 22
27077: PUSH
27078: LD_OWVAR 2
27082: PUSH
27083: EMPTY
27084: LIST
27085: LIST
27086: PUSH
27087: LD_INT 21
27089: PUSH
27090: LD_INT 1
27092: PUSH
27093: EMPTY
27094: LIST
27095: LIST
27096: PUSH
27097: EMPTY
27098: LIST
27099: LIST
27100: PPUSH
27101: CALL_OW 69
27105: ST_TO_ADDR
// if not tmp then
27106: LD_VAR 0 1
27110: NOT
27111: IFFALSE 27115
// exit ;
27113: GO 27160
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
27115: LD_VAR 0 1
27119: PUSH
27120: LD_INT 1
27122: PPUSH
27123: LD_VAR 0 1
27127: PPUSH
27128: CALL_OW 12
27132: ARRAY
27133: PPUSH
27134: LD_INT 1
27136: PPUSH
27137: LD_INT 4
27139: PPUSH
27140: CALL_OW 12
27144: PPUSH
27145: LD_INT 3000
27147: PPUSH
27148: LD_INT 9000
27150: PPUSH
27151: CALL_OW 12
27155: PPUSH
27156: CALL_OW 492
// end ;
27160: PPOPN 1
27162: END
// every 0 0$1 trigger StreamModeActive and sDepot do
27163: LD_EXP 90
27167: PUSH
27168: LD_EXP 105
27172: AND
27173: IFFALSE 27193
27175: GO 27177
27177: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
27178: LD_INT 1
27180: PPUSH
27181: LD_OWVAR 2
27185: PPUSH
27186: LD_INT 0
27188: PPUSH
27189: CALL_OW 324
27193: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
27194: LD_EXP 90
27198: PUSH
27199: LD_EXP 106
27203: AND
27204: IFFALSE 27287
27206: GO 27208
27208: DISABLE
27209: LD_INT 0
27211: PPUSH
27212: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
27213: LD_ADDR_VAR 0 2
27217: PUSH
27218: LD_INT 22
27220: PUSH
27221: LD_OWVAR 2
27225: PUSH
27226: EMPTY
27227: LIST
27228: LIST
27229: PUSH
27230: LD_INT 21
27232: PUSH
27233: LD_INT 3
27235: PUSH
27236: EMPTY
27237: LIST
27238: LIST
27239: PUSH
27240: EMPTY
27241: LIST
27242: LIST
27243: PPUSH
27244: CALL_OW 69
27248: ST_TO_ADDR
// if not tmp then
27249: LD_VAR 0 2
27253: NOT
27254: IFFALSE 27258
// exit ;
27256: GO 27287
// for i in tmp do
27258: LD_ADDR_VAR 0 1
27262: PUSH
27263: LD_VAR 0 2
27267: PUSH
27268: FOR_IN
27269: IFFALSE 27285
// SetBLevel ( i , 10 ) ;
27271: LD_VAR 0 1
27275: PPUSH
27276: LD_INT 10
27278: PPUSH
27279: CALL_OW 241
27283: GO 27268
27285: POP
27286: POP
// end ;
27287: PPOPN 2
27289: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
27290: LD_EXP 90
27294: PUSH
27295: LD_EXP 107
27299: AND
27300: IFFALSE 27411
27302: GO 27304
27304: DISABLE
27305: LD_INT 0
27307: PPUSH
27308: PPUSH
27309: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
27310: LD_ADDR_VAR 0 3
27314: PUSH
27315: LD_INT 22
27317: PUSH
27318: LD_OWVAR 2
27322: PUSH
27323: EMPTY
27324: LIST
27325: LIST
27326: PUSH
27327: LD_INT 25
27329: PUSH
27330: LD_INT 1
27332: PUSH
27333: EMPTY
27334: LIST
27335: LIST
27336: PUSH
27337: EMPTY
27338: LIST
27339: LIST
27340: PPUSH
27341: CALL_OW 69
27345: ST_TO_ADDR
// if not tmp then
27346: LD_VAR 0 3
27350: NOT
27351: IFFALSE 27355
// exit ;
27353: GO 27411
// un := tmp [ rand ( 1 , tmp ) ] ;
27355: LD_ADDR_VAR 0 2
27359: PUSH
27360: LD_VAR 0 3
27364: PUSH
27365: LD_INT 1
27367: PPUSH
27368: LD_VAR 0 3
27372: PPUSH
27373: CALL_OW 12
27377: ARRAY
27378: ST_TO_ADDR
// if Crawls ( un ) then
27379: LD_VAR 0 2
27383: PPUSH
27384: CALL_OW 318
27388: IFFALSE 27399
// ComWalk ( un ) ;
27390: LD_VAR 0 2
27394: PPUSH
27395: CALL_OW 138
// SetClass ( un , class_sniper ) ;
27399: LD_VAR 0 2
27403: PPUSH
27404: LD_INT 5
27406: PPUSH
27407: CALL_OW 336
// end ;
27411: PPOPN 3
27413: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 3 do
27414: LD_EXP 90
27418: PUSH
27419: LD_EXP 108
27423: AND
27424: PUSH
27425: LD_OWVAR 67
27429: PUSH
27430: LD_INT 3
27432: LESS
27433: AND
27434: IFFALSE 27453
27436: GO 27438
27438: DISABLE
// Difficulty := Difficulty + 1 ;
27439: LD_ADDR_OWVAR 67
27443: PUSH
27444: LD_OWVAR 67
27448: PUSH
27449: LD_INT 1
27451: PLUS
27452: ST_TO_ADDR
27453: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
27454: LD_EXP 90
27458: PUSH
27459: LD_EXP 109
27463: AND
27464: IFFALSE 27567
27466: GO 27468
27468: DISABLE
27469: LD_INT 0
27471: PPUSH
// begin for i := 1 to 5 do
27472: LD_ADDR_VAR 0 1
27476: PUSH
27477: DOUBLE
27478: LD_INT 1
27480: DEC
27481: ST_TO_ADDR
27482: LD_INT 5
27484: PUSH
27485: FOR_TO
27486: IFFALSE 27565
// begin uc_nation := nation_nature ;
27488: LD_ADDR_OWVAR 21
27492: PUSH
27493: LD_INT 0
27495: ST_TO_ADDR
// uc_side := 0 ;
27496: LD_ADDR_OWVAR 20
27500: PUSH
27501: LD_INT 0
27503: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
27504: LD_ADDR_OWVAR 29
27508: PUSH
27509: LD_INT 12
27511: PUSH
27512: LD_INT 12
27514: PUSH
27515: EMPTY
27516: LIST
27517: LIST
27518: ST_TO_ADDR
// hc_agressivity := 20 ;
27519: LD_ADDR_OWVAR 35
27523: PUSH
27524: LD_INT 20
27526: ST_TO_ADDR
// hc_class := class_tiger ;
27527: LD_ADDR_OWVAR 28
27531: PUSH
27532: LD_INT 14
27534: ST_TO_ADDR
// hc_gallery :=  ;
27535: LD_ADDR_OWVAR 33
27539: PUSH
27540: LD_STRING 
27542: ST_TO_ADDR
// hc_name :=  ;
27543: LD_ADDR_OWVAR 26
27547: PUSH
27548: LD_STRING 
27550: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
27551: CALL_OW 44
27555: PPUSH
27556: LD_INT 0
27558: PPUSH
27559: CALL_OW 51
// end ;
27563: GO 27485
27565: POP
27566: POP
// end ;
27567: PPOPN 1
27569: END
// every 0 0$1 trigger StreamModeActive and sBomb do
27570: LD_EXP 90
27574: PUSH
27575: LD_EXP 110
27579: AND
27580: IFFALSE 27589
27582: GO 27584
27584: DISABLE
// StreamSibBomb ;
27585: CALL 27590 0 0
27589: END
// export function StreamSibBomb ; var i , x , y ; begin
27590: LD_INT 0
27592: PPUSH
27593: PPUSH
27594: PPUSH
27595: PPUSH
// result := false ;
27596: LD_ADDR_VAR 0 1
27600: PUSH
27601: LD_INT 0
27603: ST_TO_ADDR
// for i := 1 to 16 do
27604: LD_ADDR_VAR 0 2
27608: PUSH
27609: DOUBLE
27610: LD_INT 1
27612: DEC
27613: ST_TO_ADDR
27614: LD_INT 16
27616: PUSH
27617: FOR_TO
27618: IFFALSE 27817
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
27620: LD_ADDR_VAR 0 3
27624: PUSH
27625: LD_INT 10
27627: PUSH
27628: LD_INT 20
27630: PUSH
27631: LD_INT 30
27633: PUSH
27634: LD_INT 40
27636: PUSH
27637: LD_INT 50
27639: PUSH
27640: LD_INT 60
27642: PUSH
27643: LD_INT 70
27645: PUSH
27646: LD_INT 80
27648: PUSH
27649: LD_INT 90
27651: PUSH
27652: LD_INT 100
27654: PUSH
27655: LD_INT 110
27657: PUSH
27658: LD_INT 120
27660: PUSH
27661: LD_INT 130
27663: PUSH
27664: LD_INT 140
27666: PUSH
27667: LD_INT 150
27669: PUSH
27670: EMPTY
27671: LIST
27672: LIST
27673: LIST
27674: LIST
27675: LIST
27676: LIST
27677: LIST
27678: LIST
27679: LIST
27680: LIST
27681: LIST
27682: LIST
27683: LIST
27684: LIST
27685: LIST
27686: PUSH
27687: LD_INT 1
27689: PPUSH
27690: LD_INT 15
27692: PPUSH
27693: CALL_OW 12
27697: ARRAY
27698: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
27699: LD_ADDR_VAR 0 4
27703: PUSH
27704: LD_INT 10
27706: PUSH
27707: LD_INT 20
27709: PUSH
27710: LD_INT 30
27712: PUSH
27713: LD_INT 40
27715: PUSH
27716: LD_INT 50
27718: PUSH
27719: LD_INT 60
27721: PUSH
27722: LD_INT 70
27724: PUSH
27725: LD_INT 80
27727: PUSH
27728: LD_INT 90
27730: PUSH
27731: LD_INT 100
27733: PUSH
27734: LD_INT 110
27736: PUSH
27737: LD_INT 120
27739: PUSH
27740: LD_INT 130
27742: PUSH
27743: LD_INT 140
27745: PUSH
27746: LD_INT 150
27748: PUSH
27749: EMPTY
27750: LIST
27751: LIST
27752: LIST
27753: LIST
27754: LIST
27755: LIST
27756: LIST
27757: LIST
27758: LIST
27759: LIST
27760: LIST
27761: LIST
27762: LIST
27763: LIST
27764: LIST
27765: PUSH
27766: LD_INT 1
27768: PPUSH
27769: LD_INT 15
27771: PPUSH
27772: CALL_OW 12
27776: ARRAY
27777: ST_TO_ADDR
// if ValidHex ( x , y ) then
27778: LD_VAR 0 3
27782: PPUSH
27783: LD_VAR 0 4
27787: PPUSH
27788: CALL_OW 488
27792: IFFALSE 27815
// begin result := [ x , y ] ;
27794: LD_ADDR_VAR 0 1
27798: PUSH
27799: LD_VAR 0 3
27803: PUSH
27804: LD_VAR 0 4
27808: PUSH
27809: EMPTY
27810: LIST
27811: LIST
27812: ST_TO_ADDR
// break ;
27813: GO 27817
// end ; end ;
27815: GO 27617
27817: POP
27818: POP
// if result then
27819: LD_VAR 0 1
27823: IFFALSE 27883
// begin ToLua ( playSibBomb() ) ;
27825: LD_STRING playSibBomb()
27827: PPUSH
27828: CALL_OW 559
// wait ( 0 0$14 ) ;
27832: LD_INT 490
27834: PPUSH
27835: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
27839: LD_VAR 0 1
27843: PUSH
27844: LD_INT 1
27846: ARRAY
27847: PPUSH
27848: LD_VAR 0 1
27852: PUSH
27853: LD_INT 2
27855: ARRAY
27856: PPUSH
27857: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
27861: LD_VAR 0 1
27865: PUSH
27866: LD_INT 1
27868: ARRAY
27869: PPUSH
27870: LD_VAR 0 1
27874: PUSH
27875: LD_INT 2
27877: ARRAY
27878: PPUSH
27879: CALL_OW 429
// end ; end ;
27883: LD_VAR 0 1
27887: RET
// every 0 0$1 trigger StreamModeActive and sReset do
27888: LD_EXP 90
27892: PUSH
27893: LD_EXP 112
27897: AND
27898: IFFALSE 27910
27900: GO 27902
27902: DISABLE
// YouLost (  ) ;
27903: LD_STRING 
27905: PPUSH
27906: CALL_OW 104
27910: END
// every 0 0$1 trigger StreamModeActive and sFog do
27911: LD_EXP 90
27915: PUSH
27916: LD_EXP 111
27920: AND
27921: IFFALSE 27935
27923: GO 27925
27925: DISABLE
// FogOff ( your_side ) ;
27926: LD_OWVAR 2
27930: PPUSH
27931: CALL_OW 344
27935: END
// every 0 0$1 trigger StreamModeActive and sSun do
27936: LD_EXP 90
27940: PUSH
27941: LD_EXP 113
27945: AND
27946: IFFALSE 27974
27948: GO 27950
27950: DISABLE
// begin solar_recharge_percent := 0 ;
27951: LD_ADDR_OWVAR 79
27955: PUSH
27956: LD_INT 0
27958: ST_TO_ADDR
// wait ( 5 5$00 ) ;
27959: LD_INT 10500
27961: PPUSH
27962: CALL_OW 67
// solar_recharge_percent := 100 ;
27966: LD_ADDR_OWVAR 79
27970: PUSH
27971: LD_INT 100
27973: ST_TO_ADDR
// end ;
27974: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
27975: LD_EXP 90
27979: PUSH
27980: LD_EXP 114
27984: AND
27985: IFFALSE 28224
27987: GO 27989
27989: DISABLE
27990: LD_INT 0
27992: PPUSH
27993: PPUSH
27994: PPUSH
// begin tmp := [ ] ;
27995: LD_ADDR_VAR 0 3
27999: PUSH
28000: EMPTY
28001: ST_TO_ADDR
// for i := 1 to 6 do
28002: LD_ADDR_VAR 0 1
28006: PUSH
28007: DOUBLE
28008: LD_INT 1
28010: DEC
28011: ST_TO_ADDR
28012: LD_INT 6
28014: PUSH
28015: FOR_TO
28016: IFFALSE 28121
// begin uc_nation := nation_nature ;
28018: LD_ADDR_OWVAR 21
28022: PUSH
28023: LD_INT 0
28025: ST_TO_ADDR
// uc_side := 0 ;
28026: LD_ADDR_OWVAR 20
28030: PUSH
28031: LD_INT 0
28033: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
28034: LD_ADDR_OWVAR 29
28038: PUSH
28039: LD_INT 12
28041: PUSH
28042: LD_INT 12
28044: PUSH
28045: EMPTY
28046: LIST
28047: LIST
28048: ST_TO_ADDR
// hc_agressivity := 20 ;
28049: LD_ADDR_OWVAR 35
28053: PUSH
28054: LD_INT 20
28056: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
28057: LD_ADDR_OWVAR 28
28061: PUSH
28062: LD_INT 17
28064: ST_TO_ADDR
// hc_gallery :=  ;
28065: LD_ADDR_OWVAR 33
28069: PUSH
28070: LD_STRING 
28072: ST_TO_ADDR
// hc_name :=  ;
28073: LD_ADDR_OWVAR 26
28077: PUSH
28078: LD_STRING 
28080: ST_TO_ADDR
// un := CreateHuman ;
28081: LD_ADDR_VAR 0 2
28085: PUSH
28086: CALL_OW 44
28090: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
28091: LD_VAR 0 2
28095: PPUSH
28096: LD_INT 1
28098: PPUSH
28099: CALL_OW 51
// tmp := tmp ^ un ;
28103: LD_ADDR_VAR 0 3
28107: PUSH
28108: LD_VAR 0 3
28112: PUSH
28113: LD_VAR 0 2
28117: ADD
28118: ST_TO_ADDR
// end ;
28119: GO 28015
28121: POP
28122: POP
// repeat wait ( 0 0$1 ) ;
28123: LD_INT 35
28125: PPUSH
28126: CALL_OW 67
// for un in tmp do
28130: LD_ADDR_VAR 0 2
28134: PUSH
28135: LD_VAR 0 3
28139: PUSH
28140: FOR_IN
28141: IFFALSE 28215
// begin if IsDead ( un ) then
28143: LD_VAR 0 2
28147: PPUSH
28148: CALL_OW 301
28152: IFFALSE 28172
// begin tmp := tmp diff un ;
28154: LD_ADDR_VAR 0 3
28158: PUSH
28159: LD_VAR 0 3
28163: PUSH
28164: LD_VAR 0 2
28168: DIFF
28169: ST_TO_ADDR
// continue ;
28170: GO 28140
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
28172: LD_VAR 0 2
28176: PPUSH
28177: LD_INT 3
28179: PUSH
28180: LD_INT 22
28182: PUSH
28183: LD_INT 0
28185: PUSH
28186: EMPTY
28187: LIST
28188: LIST
28189: PUSH
28190: EMPTY
28191: LIST
28192: LIST
28193: PPUSH
28194: CALL_OW 69
28198: PPUSH
28199: LD_VAR 0 2
28203: PPUSH
28204: CALL_OW 74
28208: PPUSH
28209: CALL_OW 115
// end ;
28213: GO 28140
28215: POP
28216: POP
// until not tmp ;
28217: LD_VAR 0 3
28221: NOT
28222: IFFALSE 28123
// end ;
28224: PPOPN 3
28226: END
// every 0 0$1 trigger StreamModeActive and sTroll do
28227: LD_EXP 90
28231: PUSH
28232: LD_EXP 115
28236: AND
28237: IFFALSE 28291
28239: GO 28241
28241: DISABLE
// begin ToLua ( displayTroll(); ) ;
28242: LD_STRING displayTroll();
28244: PPUSH
28245: CALL_OW 559
// wait ( 3 3$00 ) ;
28249: LD_INT 6300
28251: PPUSH
28252: CALL_OW 67
// ToLua ( hideTroll(); ) ;
28256: LD_STRING hideTroll();
28258: PPUSH
28259: CALL_OW 559
// wait ( 1 1$00 ) ;
28263: LD_INT 2100
28265: PPUSH
28266: CALL_OW 67
// ToLua ( displayTroll(); ) ;
28270: LD_STRING displayTroll();
28272: PPUSH
28273: CALL_OW 559
// wait ( 1 1$00 ) ;
28277: LD_INT 2100
28279: PPUSH
28280: CALL_OW 67
// ToLua ( hideTroll(); ) ;
28284: LD_STRING hideTroll();
28286: PPUSH
28287: CALL_OW 559
// end ;
28291: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
28292: LD_EXP 90
28296: PUSH
28297: LD_EXP 116
28301: AND
28302: IFFALSE 28365
28304: GO 28306
28306: DISABLE
28307: LD_INT 0
28309: PPUSH
// begin p := 0 ;
28310: LD_ADDR_VAR 0 1
28314: PUSH
28315: LD_INT 0
28317: ST_TO_ADDR
// repeat game_speed := 1 ;
28318: LD_ADDR_OWVAR 65
28322: PUSH
28323: LD_INT 1
28325: ST_TO_ADDR
// wait ( 0 0$1 ) ;
28326: LD_INT 35
28328: PPUSH
28329: CALL_OW 67
// p := p + 1 ;
28333: LD_ADDR_VAR 0 1
28337: PUSH
28338: LD_VAR 0 1
28342: PUSH
28343: LD_INT 1
28345: PLUS
28346: ST_TO_ADDR
// until p >= 60 ;
28347: LD_VAR 0 1
28351: PUSH
28352: LD_INT 60
28354: GREATEREQUAL
28355: IFFALSE 28318
// game_speed := 4 ;
28357: LD_ADDR_OWVAR 65
28361: PUSH
28362: LD_INT 4
28364: ST_TO_ADDR
// end ;
28365: PPOPN 1
28367: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
28368: LD_EXP 90
28372: PUSH
28373: LD_EXP 117
28377: AND
28378: IFFALSE 28524
28380: GO 28382
28382: DISABLE
28383: LD_INT 0
28385: PPUSH
28386: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
28387: LD_ADDR_VAR 0 1
28391: PUSH
28392: LD_INT 22
28394: PUSH
28395: LD_OWVAR 2
28399: PUSH
28400: EMPTY
28401: LIST
28402: LIST
28403: PUSH
28404: LD_INT 2
28406: PUSH
28407: LD_INT 30
28409: PUSH
28410: LD_INT 0
28412: PUSH
28413: EMPTY
28414: LIST
28415: LIST
28416: PUSH
28417: LD_INT 30
28419: PUSH
28420: LD_INT 1
28422: PUSH
28423: EMPTY
28424: LIST
28425: LIST
28426: PUSH
28427: EMPTY
28428: LIST
28429: LIST
28430: LIST
28431: PUSH
28432: EMPTY
28433: LIST
28434: LIST
28435: PPUSH
28436: CALL_OW 69
28440: ST_TO_ADDR
// if not depot then
28441: LD_VAR 0 1
28445: NOT
28446: IFFALSE 28450
// exit ;
28448: GO 28524
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
28450: LD_ADDR_VAR 0 2
28454: PUSH
28455: LD_VAR 0 1
28459: PUSH
28460: LD_INT 1
28462: PPUSH
28463: LD_VAR 0 1
28467: PPUSH
28468: CALL_OW 12
28472: ARRAY
28473: PPUSH
28474: CALL_OW 274
28478: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
28479: LD_VAR 0 2
28483: PPUSH
28484: LD_INT 1
28486: PPUSH
28487: LD_INT 0
28489: PPUSH
28490: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
28494: LD_VAR 0 2
28498: PPUSH
28499: LD_INT 2
28501: PPUSH
28502: LD_INT 0
28504: PPUSH
28505: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
28509: LD_VAR 0 2
28513: PPUSH
28514: LD_INT 3
28516: PPUSH
28517: LD_INT 0
28519: PPUSH
28520: CALL_OW 277
// end ;
28524: PPOPN 2
28526: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
28527: LD_EXP 90
28531: PUSH
28532: LD_EXP 118
28536: AND
28537: IFFALSE 28634
28539: GO 28541
28541: DISABLE
28542: LD_INT 0
28544: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
28545: LD_ADDR_VAR 0 1
28549: PUSH
28550: LD_INT 22
28552: PUSH
28553: LD_OWVAR 2
28557: PUSH
28558: EMPTY
28559: LIST
28560: LIST
28561: PUSH
28562: LD_INT 21
28564: PUSH
28565: LD_INT 1
28567: PUSH
28568: EMPTY
28569: LIST
28570: LIST
28571: PUSH
28572: LD_INT 3
28574: PUSH
28575: LD_INT 23
28577: PUSH
28578: LD_INT 0
28580: PUSH
28581: EMPTY
28582: LIST
28583: LIST
28584: PUSH
28585: EMPTY
28586: LIST
28587: LIST
28588: PUSH
28589: EMPTY
28590: LIST
28591: LIST
28592: LIST
28593: PPUSH
28594: CALL_OW 69
28598: ST_TO_ADDR
// if not tmp then
28599: LD_VAR 0 1
28603: NOT
28604: IFFALSE 28608
// exit ;
28606: GO 28634
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
28608: LD_VAR 0 1
28612: PUSH
28613: LD_INT 1
28615: PPUSH
28616: LD_VAR 0 1
28620: PPUSH
28621: CALL_OW 12
28625: ARRAY
28626: PPUSH
28627: LD_INT 200
28629: PPUSH
28630: CALL_OW 234
// end ;
28634: PPOPN 1
28636: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
28637: LD_EXP 90
28641: PUSH
28642: LD_EXP 119
28646: AND
28647: IFFALSE 28726
28649: GO 28651
28651: DISABLE
28652: LD_INT 0
28654: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
28655: LD_ADDR_VAR 0 1
28659: PUSH
28660: LD_INT 22
28662: PUSH
28663: LD_OWVAR 2
28667: PUSH
28668: EMPTY
28669: LIST
28670: LIST
28671: PUSH
28672: LD_INT 21
28674: PUSH
28675: LD_INT 2
28677: PUSH
28678: EMPTY
28679: LIST
28680: LIST
28681: PUSH
28682: EMPTY
28683: LIST
28684: LIST
28685: PPUSH
28686: CALL_OW 69
28690: ST_TO_ADDR
// if not tmp then
28691: LD_VAR 0 1
28695: NOT
28696: IFFALSE 28700
// exit ;
28698: GO 28726
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
28700: LD_VAR 0 1
28704: PUSH
28705: LD_INT 1
28707: PPUSH
28708: LD_VAR 0 1
28712: PPUSH
28713: CALL_OW 12
28717: ARRAY
28718: PPUSH
28719: LD_INT 60
28721: PPUSH
28722: CALL_OW 234
// end ;
28726: PPOPN 1
28728: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
28729: LD_EXP 90
28733: PUSH
28734: LD_EXP 120
28738: AND
28739: IFFALSE 28838
28741: GO 28743
28743: DISABLE
28744: LD_INT 0
28746: PPUSH
28747: PPUSH
// begin enable ;
28748: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
28749: LD_ADDR_VAR 0 1
28753: PUSH
28754: LD_INT 22
28756: PUSH
28757: LD_OWVAR 2
28761: PUSH
28762: EMPTY
28763: LIST
28764: LIST
28765: PUSH
28766: LD_INT 61
28768: PUSH
28769: EMPTY
28770: LIST
28771: PUSH
28772: LD_INT 33
28774: PUSH
28775: LD_INT 2
28777: PUSH
28778: EMPTY
28779: LIST
28780: LIST
28781: PUSH
28782: EMPTY
28783: LIST
28784: LIST
28785: LIST
28786: PPUSH
28787: CALL_OW 69
28791: ST_TO_ADDR
// if not tmp then
28792: LD_VAR 0 1
28796: NOT
28797: IFFALSE 28801
// exit ;
28799: GO 28838
// for i in tmp do
28801: LD_ADDR_VAR 0 2
28805: PUSH
28806: LD_VAR 0 1
28810: PUSH
28811: FOR_IN
28812: IFFALSE 28836
// if IsControledBy ( i ) then
28814: LD_VAR 0 2
28818: PPUSH
28819: CALL_OW 312
28823: IFFALSE 28834
// ComUnlink ( i ) ;
28825: LD_VAR 0 2
28829: PPUSH
28830: CALL_OW 136
28834: GO 28811
28836: POP
28837: POP
// end ;
28838: PPOPN 2
28840: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
28841: LD_EXP 90
28845: PUSH
28846: LD_EXP 121
28850: AND
28851: IFFALSE 28991
28853: GO 28855
28855: DISABLE
28856: LD_INT 0
28858: PPUSH
28859: PPUSH
// begin ToLua ( displayPowell(); ) ;
28860: LD_STRING displayPowell();
28862: PPUSH
28863: CALL_OW 559
// uc_side := 0 ;
28867: LD_ADDR_OWVAR 20
28871: PUSH
28872: LD_INT 0
28874: ST_TO_ADDR
// uc_nation := 2 ;
28875: LD_ADDR_OWVAR 21
28879: PUSH
28880: LD_INT 2
28882: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
28883: LD_ADDR_OWVAR 37
28887: PUSH
28888: LD_INT 14
28890: ST_TO_ADDR
// vc_engine := engine_siberite ;
28891: LD_ADDR_OWVAR 39
28895: PUSH
28896: LD_INT 3
28898: ST_TO_ADDR
// vc_control := control_apeman ;
28899: LD_ADDR_OWVAR 38
28903: PUSH
28904: LD_INT 5
28906: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
28907: LD_ADDR_OWVAR 40
28911: PUSH
28912: LD_INT 29
28914: ST_TO_ADDR
// un := CreateVehicle ;
28915: LD_ADDR_VAR 0 2
28919: PUSH
28920: CALL_OW 45
28924: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
28925: LD_VAR 0 2
28929: PPUSH
28930: LD_INT 1
28932: PPUSH
28933: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
28937: LD_INT 35
28939: PPUSH
28940: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
28944: LD_VAR 0 2
28948: PPUSH
28949: LD_INT 22
28951: PUSH
28952: LD_OWVAR 2
28956: PUSH
28957: EMPTY
28958: LIST
28959: LIST
28960: PPUSH
28961: CALL_OW 69
28965: PPUSH
28966: LD_VAR 0 2
28970: PPUSH
28971: CALL_OW 74
28975: PPUSH
28976: CALL_OW 115
// until IsDead ( un ) ;
28980: LD_VAR 0 2
28984: PPUSH
28985: CALL_OW 301
28989: IFFALSE 28937
// end ;
28991: PPOPN 2
28993: END
// every 0 0$1 trigger StreamModeActive and sStu do
28994: LD_EXP 90
28998: PUSH
28999: LD_EXP 129
29003: AND
29004: IFFALSE 29020
29006: GO 29008
29008: DISABLE
// begin ToLua ( displayStucuk(); ) ;
29009: LD_STRING displayStucuk();
29011: PPUSH
29012: CALL_OW 559
// ResetFog ;
29016: CALL_OW 335
// end ;
29020: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
29021: LD_EXP 90
29025: PUSH
29026: LD_EXP 122
29030: AND
29031: IFFALSE 29172
29033: GO 29035
29035: DISABLE
29036: LD_INT 0
29038: PPUSH
29039: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
29040: LD_ADDR_VAR 0 2
29044: PUSH
29045: LD_INT 22
29047: PUSH
29048: LD_OWVAR 2
29052: PUSH
29053: EMPTY
29054: LIST
29055: LIST
29056: PUSH
29057: LD_INT 21
29059: PUSH
29060: LD_INT 1
29062: PUSH
29063: EMPTY
29064: LIST
29065: LIST
29066: PUSH
29067: EMPTY
29068: LIST
29069: LIST
29070: PPUSH
29071: CALL_OW 69
29075: ST_TO_ADDR
// if not tmp then
29076: LD_VAR 0 2
29080: NOT
29081: IFFALSE 29085
// exit ;
29083: GO 29172
// un := tmp [ rand ( 1 , tmp ) ] ;
29085: LD_ADDR_VAR 0 1
29089: PUSH
29090: LD_VAR 0 2
29094: PUSH
29095: LD_INT 1
29097: PPUSH
29098: LD_VAR 0 2
29102: PPUSH
29103: CALL_OW 12
29107: ARRAY
29108: ST_TO_ADDR
// SetSide ( un , 0 ) ;
29109: LD_VAR 0 1
29113: PPUSH
29114: LD_INT 0
29116: PPUSH
29117: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
29121: LD_VAR 0 1
29125: PPUSH
29126: LD_OWVAR 3
29130: PUSH
29131: LD_VAR 0 1
29135: DIFF
29136: PPUSH
29137: LD_VAR 0 1
29141: PPUSH
29142: CALL_OW 74
29146: PPUSH
29147: CALL_OW 115
// wait ( 0 0$20 ) ;
29151: LD_INT 700
29153: PPUSH
29154: CALL_OW 67
// SetSide ( un , your_side ) ;
29158: LD_VAR 0 1
29162: PPUSH
29163: LD_OWVAR 2
29167: PPUSH
29168: CALL_OW 235
// end ;
29172: PPOPN 2
29174: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
29175: LD_EXP 90
29179: PUSH
29180: LD_EXP 123
29184: AND
29185: IFFALSE 29291
29187: GO 29189
29189: DISABLE
29190: LD_INT 0
29192: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
29193: LD_ADDR_VAR 0 1
29197: PUSH
29198: LD_INT 22
29200: PUSH
29201: LD_OWVAR 2
29205: PUSH
29206: EMPTY
29207: LIST
29208: LIST
29209: PUSH
29210: LD_INT 2
29212: PUSH
29213: LD_INT 30
29215: PUSH
29216: LD_INT 0
29218: PUSH
29219: EMPTY
29220: LIST
29221: LIST
29222: PUSH
29223: LD_INT 30
29225: PUSH
29226: LD_INT 1
29228: PUSH
29229: EMPTY
29230: LIST
29231: LIST
29232: PUSH
29233: EMPTY
29234: LIST
29235: LIST
29236: LIST
29237: PUSH
29238: EMPTY
29239: LIST
29240: LIST
29241: PPUSH
29242: CALL_OW 69
29246: ST_TO_ADDR
// if not depot then
29247: LD_VAR 0 1
29251: NOT
29252: IFFALSE 29256
// exit ;
29254: GO 29291
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
29256: LD_VAR 0 1
29260: PUSH
29261: LD_INT 1
29263: ARRAY
29264: PPUSH
29265: CALL_OW 250
29269: PPUSH
29270: LD_VAR 0 1
29274: PUSH
29275: LD_INT 1
29277: ARRAY
29278: PPUSH
29279: CALL_OW 251
29283: PPUSH
29284: LD_INT 70
29286: PPUSH
29287: CALL_OW 495
// end ;
29291: PPOPN 1
29293: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
29294: LD_EXP 90
29298: PUSH
29299: LD_EXP 124
29303: AND
29304: IFFALSE 29515
29306: GO 29308
29308: DISABLE
29309: LD_INT 0
29311: PPUSH
29312: PPUSH
29313: PPUSH
29314: PPUSH
29315: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
29316: LD_ADDR_VAR 0 5
29320: PUSH
29321: LD_INT 22
29323: PUSH
29324: LD_OWVAR 2
29328: PUSH
29329: EMPTY
29330: LIST
29331: LIST
29332: PUSH
29333: LD_INT 21
29335: PUSH
29336: LD_INT 1
29338: PUSH
29339: EMPTY
29340: LIST
29341: LIST
29342: PUSH
29343: EMPTY
29344: LIST
29345: LIST
29346: PPUSH
29347: CALL_OW 69
29351: ST_TO_ADDR
// if not tmp then
29352: LD_VAR 0 5
29356: NOT
29357: IFFALSE 29361
// exit ;
29359: GO 29515
// for i in tmp do
29361: LD_ADDR_VAR 0 1
29365: PUSH
29366: LD_VAR 0 5
29370: PUSH
29371: FOR_IN
29372: IFFALSE 29513
// begin d := rand ( 0 , 5 ) ;
29374: LD_ADDR_VAR 0 4
29378: PUSH
29379: LD_INT 0
29381: PPUSH
29382: LD_INT 5
29384: PPUSH
29385: CALL_OW 12
29389: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
29390: LD_ADDR_VAR 0 2
29394: PUSH
29395: LD_VAR 0 1
29399: PPUSH
29400: CALL_OW 250
29404: PPUSH
29405: LD_VAR 0 4
29409: PPUSH
29410: LD_INT 3
29412: PPUSH
29413: LD_INT 12
29415: PPUSH
29416: CALL_OW 12
29420: PPUSH
29421: CALL_OW 272
29425: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
29426: LD_ADDR_VAR 0 3
29430: PUSH
29431: LD_VAR 0 1
29435: PPUSH
29436: CALL_OW 251
29440: PPUSH
29441: LD_VAR 0 4
29445: PPUSH
29446: LD_INT 3
29448: PPUSH
29449: LD_INT 12
29451: PPUSH
29452: CALL_OW 12
29456: PPUSH
29457: CALL_OW 273
29461: ST_TO_ADDR
// if ValidHex ( x , y ) then
29462: LD_VAR 0 2
29466: PPUSH
29467: LD_VAR 0 3
29471: PPUSH
29472: CALL_OW 488
29476: IFFALSE 29511
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
29478: LD_VAR 0 1
29482: PPUSH
29483: LD_VAR 0 2
29487: PPUSH
29488: LD_VAR 0 3
29492: PPUSH
29493: LD_INT 3
29495: PPUSH
29496: LD_INT 6
29498: PPUSH
29499: CALL_OW 12
29503: PPUSH
29504: LD_INT 1
29506: PPUSH
29507: CALL_OW 483
// end ;
29511: GO 29371
29513: POP
29514: POP
// end ;
29515: PPOPN 5
29517: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
29518: LD_EXP 90
29522: PUSH
29523: LD_EXP 125
29527: AND
29528: IFFALSE 29622
29530: GO 29532
29532: DISABLE
29533: LD_INT 0
29535: PPUSH
29536: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
29537: LD_ADDR_VAR 0 2
29541: PUSH
29542: LD_INT 22
29544: PUSH
29545: LD_OWVAR 2
29549: PUSH
29550: EMPTY
29551: LIST
29552: LIST
29553: PUSH
29554: LD_INT 32
29556: PUSH
29557: LD_INT 1
29559: PUSH
29560: EMPTY
29561: LIST
29562: LIST
29563: PUSH
29564: LD_INT 21
29566: PUSH
29567: LD_INT 2
29569: PUSH
29570: EMPTY
29571: LIST
29572: LIST
29573: PUSH
29574: EMPTY
29575: LIST
29576: LIST
29577: LIST
29578: PPUSH
29579: CALL_OW 69
29583: ST_TO_ADDR
// if not tmp then
29584: LD_VAR 0 2
29588: NOT
29589: IFFALSE 29593
// exit ;
29591: GO 29622
// for i in tmp do
29593: LD_ADDR_VAR 0 1
29597: PUSH
29598: LD_VAR 0 2
29602: PUSH
29603: FOR_IN
29604: IFFALSE 29620
// SetFuel ( i , 0 ) ;
29606: LD_VAR 0 1
29610: PPUSH
29611: LD_INT 0
29613: PPUSH
29614: CALL_OW 240
29618: GO 29603
29620: POP
29621: POP
// end ;
29622: PPOPN 2
29624: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
29625: LD_EXP 90
29629: PUSH
29630: LD_EXP 126
29634: AND
29635: IFFALSE 29701
29637: GO 29639
29639: DISABLE
29640: LD_INT 0
29642: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
29643: LD_ADDR_VAR 0 1
29647: PUSH
29648: LD_INT 22
29650: PUSH
29651: LD_OWVAR 2
29655: PUSH
29656: EMPTY
29657: LIST
29658: LIST
29659: PUSH
29660: LD_INT 30
29662: PUSH
29663: LD_INT 29
29665: PUSH
29666: EMPTY
29667: LIST
29668: LIST
29669: PUSH
29670: EMPTY
29671: LIST
29672: LIST
29673: PPUSH
29674: CALL_OW 69
29678: ST_TO_ADDR
// if not tmp then
29679: LD_VAR 0 1
29683: NOT
29684: IFFALSE 29688
// exit ;
29686: GO 29701
// DestroyUnit ( tmp [ 1 ] ) ;
29688: LD_VAR 0 1
29692: PUSH
29693: LD_INT 1
29695: ARRAY
29696: PPUSH
29697: CALL_OW 65
// end ;
29701: PPOPN 1
29703: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
29704: LD_EXP 90
29708: PUSH
29709: LD_EXP 128
29713: AND
29714: IFFALSE 29843
29716: GO 29718
29718: DISABLE
29719: LD_INT 0
29721: PPUSH
// begin uc_side := 0 ;
29722: LD_ADDR_OWVAR 20
29726: PUSH
29727: LD_INT 0
29729: ST_TO_ADDR
// uc_nation := nation_arabian ;
29730: LD_ADDR_OWVAR 21
29734: PUSH
29735: LD_INT 2
29737: ST_TO_ADDR
// hc_gallery :=  ;
29738: LD_ADDR_OWVAR 33
29742: PUSH
29743: LD_STRING 
29745: ST_TO_ADDR
// hc_name :=  ;
29746: LD_ADDR_OWVAR 26
29750: PUSH
29751: LD_STRING 
29753: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
29754: LD_INT 1
29756: PPUSH
29757: LD_INT 11
29759: PPUSH
29760: LD_INT 10
29762: PPUSH
29763: CALL_OW 380
// un := CreateHuman ;
29767: LD_ADDR_VAR 0 1
29771: PUSH
29772: CALL_OW 44
29776: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
29777: LD_VAR 0 1
29781: PPUSH
29782: LD_INT 1
29784: PPUSH
29785: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
29789: LD_INT 35
29791: PPUSH
29792: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
29796: LD_VAR 0 1
29800: PPUSH
29801: LD_INT 22
29803: PUSH
29804: LD_OWVAR 2
29808: PUSH
29809: EMPTY
29810: LIST
29811: LIST
29812: PPUSH
29813: CALL_OW 69
29817: PPUSH
29818: LD_VAR 0 1
29822: PPUSH
29823: CALL_OW 74
29827: PPUSH
29828: CALL_OW 115
// until IsDead ( un ) ;
29832: LD_VAR 0 1
29836: PPUSH
29837: CALL_OW 301
29841: IFFALSE 29789
// end ;
29843: PPOPN 1
29845: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
29846: LD_EXP 90
29850: PUSH
29851: LD_EXP 130
29855: AND
29856: IFFALSE 29868
29858: GO 29860
29860: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
29861: LD_STRING earthquake(getX(game), 0, 32)
29863: PPUSH
29864: CALL_OW 559
29868: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
29869: LD_EXP 90
29873: PUSH
29874: LD_EXP 131
29878: AND
29879: IFFALSE 29970
29881: GO 29883
29883: DISABLE
29884: LD_INT 0
29886: PPUSH
// begin enable ;
29887: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
29888: LD_ADDR_VAR 0 1
29892: PUSH
29893: LD_INT 22
29895: PUSH
29896: LD_OWVAR 2
29900: PUSH
29901: EMPTY
29902: LIST
29903: LIST
29904: PUSH
29905: LD_INT 21
29907: PUSH
29908: LD_INT 2
29910: PUSH
29911: EMPTY
29912: LIST
29913: LIST
29914: PUSH
29915: LD_INT 33
29917: PUSH
29918: LD_INT 3
29920: PUSH
29921: EMPTY
29922: LIST
29923: LIST
29924: PUSH
29925: EMPTY
29926: LIST
29927: LIST
29928: LIST
29929: PPUSH
29930: CALL_OW 69
29934: ST_TO_ADDR
// if not tmp then
29935: LD_VAR 0 1
29939: NOT
29940: IFFALSE 29944
// exit ;
29942: GO 29970
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
29944: LD_VAR 0 1
29948: PUSH
29949: LD_INT 1
29951: PPUSH
29952: LD_VAR 0 1
29956: PPUSH
29957: CALL_OW 12
29961: ARRAY
29962: PPUSH
29963: LD_INT 1
29965: PPUSH
29966: CALL_OW 234
// end ;
29970: PPOPN 1
29972: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
29973: LD_EXP 90
29977: PUSH
29978: LD_EXP 132
29982: AND
29983: IFFALSE 30124
29985: GO 29987
29987: DISABLE
29988: LD_INT 0
29990: PPUSH
29991: PPUSH
29992: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
29993: LD_ADDR_VAR 0 3
29997: PUSH
29998: LD_INT 22
30000: PUSH
30001: LD_OWVAR 2
30005: PUSH
30006: EMPTY
30007: LIST
30008: LIST
30009: PUSH
30010: LD_INT 25
30012: PUSH
30013: LD_INT 1
30015: PUSH
30016: EMPTY
30017: LIST
30018: LIST
30019: PUSH
30020: EMPTY
30021: LIST
30022: LIST
30023: PPUSH
30024: CALL_OW 69
30028: ST_TO_ADDR
// if not tmp then
30029: LD_VAR 0 3
30033: NOT
30034: IFFALSE 30038
// exit ;
30036: GO 30124
// un := tmp [ rand ( 1 , tmp ) ] ;
30038: LD_ADDR_VAR 0 2
30042: PUSH
30043: LD_VAR 0 3
30047: PUSH
30048: LD_INT 1
30050: PPUSH
30051: LD_VAR 0 3
30055: PPUSH
30056: CALL_OW 12
30060: ARRAY
30061: ST_TO_ADDR
// if Crawls ( un ) then
30062: LD_VAR 0 2
30066: PPUSH
30067: CALL_OW 318
30071: IFFALSE 30082
// ComWalk ( un ) ;
30073: LD_VAR 0 2
30077: PPUSH
30078: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
30082: LD_VAR 0 2
30086: PPUSH
30087: LD_INT 9
30089: PPUSH
30090: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
30094: LD_INT 28
30096: PPUSH
30097: LD_OWVAR 2
30101: PPUSH
30102: LD_INT 2
30104: PPUSH
30105: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
30109: LD_INT 29
30111: PPUSH
30112: LD_OWVAR 2
30116: PPUSH
30117: LD_INT 2
30119: PPUSH
30120: CALL_OW 322
// end ;
30124: PPOPN 3
30126: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
30127: LD_EXP 90
30131: PUSH
30132: LD_EXP 133
30136: AND
30137: IFFALSE 30248
30139: GO 30141
30141: DISABLE
30142: LD_INT 0
30144: PPUSH
30145: PPUSH
30146: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
30147: LD_ADDR_VAR 0 3
30151: PUSH
30152: LD_INT 22
30154: PUSH
30155: LD_OWVAR 2
30159: PUSH
30160: EMPTY
30161: LIST
30162: LIST
30163: PUSH
30164: LD_INT 25
30166: PUSH
30167: LD_INT 1
30169: PUSH
30170: EMPTY
30171: LIST
30172: LIST
30173: PUSH
30174: EMPTY
30175: LIST
30176: LIST
30177: PPUSH
30178: CALL_OW 69
30182: ST_TO_ADDR
// if not tmp then
30183: LD_VAR 0 3
30187: NOT
30188: IFFALSE 30192
// exit ;
30190: GO 30248
// un := tmp [ rand ( 1 , tmp ) ] ;
30192: LD_ADDR_VAR 0 2
30196: PUSH
30197: LD_VAR 0 3
30201: PUSH
30202: LD_INT 1
30204: PPUSH
30205: LD_VAR 0 3
30209: PPUSH
30210: CALL_OW 12
30214: ARRAY
30215: ST_TO_ADDR
// if Crawls ( un ) then
30216: LD_VAR 0 2
30220: PPUSH
30221: CALL_OW 318
30225: IFFALSE 30236
// ComWalk ( un ) ;
30227: LD_VAR 0 2
30231: PPUSH
30232: CALL_OW 138
// SetClass ( un , class_mortar ) ;
30236: LD_VAR 0 2
30240: PPUSH
30241: LD_INT 8
30243: PPUSH
30244: CALL_OW 336
// end ;
30248: PPOPN 3
30250: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
30251: LD_EXP 90
30255: PUSH
30256: LD_EXP 134
30260: AND
30261: IFFALSE 30405
30263: GO 30265
30265: DISABLE
30266: LD_INT 0
30268: PPUSH
30269: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
30270: LD_ADDR_VAR 0 2
30274: PUSH
30275: LD_INT 22
30277: PUSH
30278: LD_OWVAR 2
30282: PUSH
30283: EMPTY
30284: LIST
30285: LIST
30286: PUSH
30287: LD_INT 21
30289: PUSH
30290: LD_INT 2
30292: PUSH
30293: EMPTY
30294: LIST
30295: LIST
30296: PUSH
30297: LD_INT 2
30299: PUSH
30300: LD_INT 34
30302: PUSH
30303: LD_INT 12
30305: PUSH
30306: EMPTY
30307: LIST
30308: LIST
30309: PUSH
30310: LD_INT 34
30312: PUSH
30313: LD_INT 51
30315: PUSH
30316: EMPTY
30317: LIST
30318: LIST
30319: PUSH
30320: LD_INT 34
30322: PUSH
30323: LD_INT 32
30325: PUSH
30326: EMPTY
30327: LIST
30328: LIST
30329: PUSH
30330: EMPTY
30331: LIST
30332: LIST
30333: LIST
30334: LIST
30335: PUSH
30336: EMPTY
30337: LIST
30338: LIST
30339: LIST
30340: PPUSH
30341: CALL_OW 69
30345: ST_TO_ADDR
// if not tmp then
30346: LD_VAR 0 2
30350: NOT
30351: IFFALSE 30355
// exit ;
30353: GO 30405
// for i in tmp do
30355: LD_ADDR_VAR 0 1
30359: PUSH
30360: LD_VAR 0 2
30364: PUSH
30365: FOR_IN
30366: IFFALSE 30403
// if GetCargo ( i , mat_artifact ) = 0 then
30368: LD_VAR 0 1
30372: PPUSH
30373: LD_INT 4
30375: PPUSH
30376: CALL_OW 289
30380: PUSH
30381: LD_INT 0
30383: EQUAL
30384: IFFALSE 30401
// SetCargo ( i , mat_siberit , 100 ) ;
30386: LD_VAR 0 1
30390: PPUSH
30391: LD_INT 3
30393: PPUSH
30394: LD_INT 100
30396: PPUSH
30397: CALL_OW 290
30401: GO 30365
30403: POP
30404: POP
// end ;
30405: PPOPN 2
30407: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
30408: LD_EXP 90
30412: PUSH
30413: LD_EXP 135
30417: AND
30418: IFFALSE 30601
30420: GO 30422
30422: DISABLE
30423: LD_INT 0
30425: PPUSH
30426: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
30427: LD_ADDR_VAR 0 2
30431: PUSH
30432: LD_INT 22
30434: PUSH
30435: LD_OWVAR 2
30439: PUSH
30440: EMPTY
30441: LIST
30442: LIST
30443: PPUSH
30444: CALL_OW 69
30448: ST_TO_ADDR
// if not tmp then
30449: LD_VAR 0 2
30453: NOT
30454: IFFALSE 30458
// exit ;
30456: GO 30601
// for i := 1 to 2 do
30458: LD_ADDR_VAR 0 1
30462: PUSH
30463: DOUBLE
30464: LD_INT 1
30466: DEC
30467: ST_TO_ADDR
30468: LD_INT 2
30470: PUSH
30471: FOR_TO
30472: IFFALSE 30599
// begin uc_side := your_side ;
30474: LD_ADDR_OWVAR 20
30478: PUSH
30479: LD_OWVAR 2
30483: ST_TO_ADDR
// uc_nation := nation_american ;
30484: LD_ADDR_OWVAR 21
30488: PUSH
30489: LD_INT 1
30491: ST_TO_ADDR
// vc_chassis := us_morphling ;
30492: LD_ADDR_OWVAR 37
30496: PUSH
30497: LD_INT 5
30499: ST_TO_ADDR
// vc_engine := engine_siberite ;
30500: LD_ADDR_OWVAR 39
30504: PUSH
30505: LD_INT 3
30507: ST_TO_ADDR
// vc_control := control_computer ;
30508: LD_ADDR_OWVAR 38
30512: PUSH
30513: LD_INT 3
30515: ST_TO_ADDR
// vc_weapon := us_double_laser ;
30516: LD_ADDR_OWVAR 40
30520: PUSH
30521: LD_INT 10
30523: ST_TO_ADDR
// if not IsInUnit ( tmp [ 1 ] ) then
30524: LD_VAR 0 2
30528: PUSH
30529: LD_INT 1
30531: ARRAY
30532: PPUSH
30533: CALL_OW 310
30537: NOT
30538: IFFALSE 30585
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) else
30540: CALL_OW 45
30544: PPUSH
30545: LD_VAR 0 2
30549: PUSH
30550: LD_INT 1
30552: ARRAY
30553: PPUSH
30554: CALL_OW 250
30558: PPUSH
30559: LD_VAR 0 2
30563: PUSH
30564: LD_INT 1
30566: ARRAY
30567: PPUSH
30568: CALL_OW 251
30572: PPUSH
30573: LD_INT 12
30575: PPUSH
30576: LD_INT 1
30578: PPUSH
30579: CALL_OW 50
30583: GO 30597
// PlaceUnitAnywhere ( CreateVehicle , true ) ;
30585: CALL_OW 45
30589: PPUSH
30590: LD_INT 1
30592: PPUSH
30593: CALL_OW 51
// end ;
30597: GO 30471
30599: POP
30600: POP
// end ;
30601: PPOPN 2
30603: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
30604: LD_EXP 90
30608: PUSH
30609: LD_EXP 136
30613: AND
30614: IFFALSE 30836
30616: GO 30618
30618: DISABLE
30619: LD_INT 0
30621: PPUSH
30622: PPUSH
30623: PPUSH
30624: PPUSH
30625: PPUSH
30626: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
30627: LD_ADDR_VAR 0 6
30631: PUSH
30632: LD_INT 22
30634: PUSH
30635: LD_OWVAR 2
30639: PUSH
30640: EMPTY
30641: LIST
30642: LIST
30643: PUSH
30644: LD_INT 21
30646: PUSH
30647: LD_INT 1
30649: PUSH
30650: EMPTY
30651: LIST
30652: LIST
30653: PUSH
30654: LD_INT 3
30656: PUSH
30657: LD_INT 23
30659: PUSH
30660: LD_INT 0
30662: PUSH
30663: EMPTY
30664: LIST
30665: LIST
30666: PUSH
30667: EMPTY
30668: LIST
30669: LIST
30670: PUSH
30671: EMPTY
30672: LIST
30673: LIST
30674: LIST
30675: PPUSH
30676: CALL_OW 69
30680: ST_TO_ADDR
// if not tmp then
30681: LD_VAR 0 6
30685: NOT
30686: IFFALSE 30690
// exit ;
30688: GO 30836
// s1 := rand ( 1 , 4 ) ;
30690: LD_ADDR_VAR 0 2
30694: PUSH
30695: LD_INT 1
30697: PPUSH
30698: LD_INT 4
30700: PPUSH
30701: CALL_OW 12
30705: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
30706: LD_ADDR_VAR 0 4
30710: PUSH
30711: LD_VAR 0 6
30715: PUSH
30716: LD_INT 1
30718: ARRAY
30719: PPUSH
30720: LD_VAR 0 2
30724: PPUSH
30725: CALL_OW 259
30729: ST_TO_ADDR
// if s1 = 1 then
30730: LD_VAR 0 2
30734: PUSH
30735: LD_INT 1
30737: EQUAL
30738: IFFALSE 30758
// s2 := rand ( 2 , 4 ) else
30740: LD_ADDR_VAR 0 3
30744: PUSH
30745: LD_INT 2
30747: PPUSH
30748: LD_INT 4
30750: PPUSH
30751: CALL_OW 12
30755: ST_TO_ADDR
30756: GO 30766
// s2 := 1 ;
30758: LD_ADDR_VAR 0 3
30762: PUSH
30763: LD_INT 1
30765: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
30766: LD_ADDR_VAR 0 5
30770: PUSH
30771: LD_VAR 0 6
30775: PUSH
30776: LD_INT 1
30778: ARRAY
30779: PPUSH
30780: LD_VAR 0 3
30784: PPUSH
30785: CALL_OW 259
30789: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
30790: LD_VAR 0 6
30794: PUSH
30795: LD_INT 1
30797: ARRAY
30798: PPUSH
30799: LD_VAR 0 2
30803: PPUSH
30804: LD_VAR 0 5
30808: PPUSH
30809: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
30813: LD_VAR 0 6
30817: PUSH
30818: LD_INT 1
30820: ARRAY
30821: PPUSH
30822: LD_VAR 0 3
30826: PPUSH
30827: LD_VAR 0 4
30831: PPUSH
30832: CALL_OW 237
// end ;
30836: PPOPN 6
30838: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
30839: LD_EXP 90
30843: PUSH
30844: LD_EXP 137
30848: AND
30849: IFFALSE 30928
30851: GO 30853
30853: DISABLE
30854: LD_INT 0
30856: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
30857: LD_ADDR_VAR 0 1
30861: PUSH
30862: LD_INT 22
30864: PUSH
30865: LD_OWVAR 2
30869: PUSH
30870: EMPTY
30871: LIST
30872: LIST
30873: PUSH
30874: LD_INT 30
30876: PUSH
30877: LD_INT 3
30879: PUSH
30880: EMPTY
30881: LIST
30882: LIST
30883: PUSH
30884: EMPTY
30885: LIST
30886: LIST
30887: PPUSH
30888: CALL_OW 69
30892: ST_TO_ADDR
// if not tmp then
30893: LD_VAR 0 1
30897: NOT
30898: IFFALSE 30902
// exit ;
30900: GO 30928
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
30902: LD_VAR 0 1
30906: PUSH
30907: LD_INT 1
30909: PPUSH
30910: LD_VAR 0 1
30914: PPUSH
30915: CALL_OW 12
30919: ARRAY
30920: PPUSH
30921: LD_INT 1
30923: PPUSH
30924: CALL_OW 234
// end ;
30928: PPOPN 1
30930: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
30931: LD_EXP 90
30935: PUSH
30936: LD_EXP 138
30940: AND
30941: IFFALSE 31053
30943: GO 30945
30945: DISABLE
30946: LD_INT 0
30948: PPUSH
30949: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
30950: LD_ADDR_VAR 0 2
30954: PUSH
30955: LD_INT 22
30957: PUSH
30958: LD_OWVAR 2
30962: PUSH
30963: EMPTY
30964: LIST
30965: LIST
30966: PUSH
30967: LD_INT 2
30969: PUSH
30970: LD_INT 30
30972: PUSH
30973: LD_INT 27
30975: PUSH
30976: EMPTY
30977: LIST
30978: LIST
30979: PUSH
30980: LD_INT 30
30982: PUSH
30983: LD_INT 26
30985: PUSH
30986: EMPTY
30987: LIST
30988: LIST
30989: PUSH
30990: LD_INT 30
30992: PUSH
30993: LD_INT 28
30995: PUSH
30996: EMPTY
30997: LIST
30998: LIST
30999: PUSH
31000: EMPTY
31001: LIST
31002: LIST
31003: LIST
31004: LIST
31005: PUSH
31006: EMPTY
31007: LIST
31008: LIST
31009: PPUSH
31010: CALL_OW 69
31014: ST_TO_ADDR
// if not tmp then
31015: LD_VAR 0 2
31019: NOT
31020: IFFALSE 31024
// exit ;
31022: GO 31053
// for i in tmp do
31024: LD_ADDR_VAR 0 1
31028: PUSH
31029: LD_VAR 0 2
31033: PUSH
31034: FOR_IN
31035: IFFALSE 31051
// SetLives ( i , 1 ) ;
31037: LD_VAR 0 1
31041: PPUSH
31042: LD_INT 1
31044: PPUSH
31045: CALL_OW 234
31049: GO 31034
31051: POP
31052: POP
// end ;
31053: PPOPN 2
31055: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
31056: LD_EXP 90
31060: PUSH
31061: LD_EXP 139
31065: AND
31066: IFFALSE 31340
31068: GO 31070
31070: DISABLE
31071: LD_INT 0
31073: PPUSH
31074: PPUSH
31075: PPUSH
// begin i := rand ( 1 , 7 ) ;
31076: LD_ADDR_VAR 0 1
31080: PUSH
31081: LD_INT 1
31083: PPUSH
31084: LD_INT 7
31086: PPUSH
31087: CALL_OW 12
31091: ST_TO_ADDR
// case i of 1 :
31092: LD_VAR 0 1
31096: PUSH
31097: LD_INT 1
31099: DOUBLE
31100: EQUAL
31101: IFTRUE 31105
31103: GO 31115
31105: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
31106: LD_STRING earthquake(getX(game), 0, 32)
31108: PPUSH
31109: CALL_OW 559
31113: GO 31340
31115: LD_INT 2
31117: DOUBLE
31118: EQUAL
31119: IFTRUE 31123
31121: GO 31137
31123: POP
// begin ToLua ( displayStucuk(); ) ;
31124: LD_STRING displayStucuk();
31126: PPUSH
31127: CALL_OW 559
// ResetFog ;
31131: CALL_OW 335
// end ; 3 :
31135: GO 31340
31137: LD_INT 3
31139: DOUBLE
31140: EQUAL
31141: IFTRUE 31145
31143: GO 31249
31145: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
31146: LD_ADDR_VAR 0 2
31150: PUSH
31151: LD_INT 22
31153: PUSH
31154: LD_OWVAR 2
31158: PUSH
31159: EMPTY
31160: LIST
31161: LIST
31162: PUSH
31163: LD_INT 25
31165: PUSH
31166: LD_INT 1
31168: PUSH
31169: EMPTY
31170: LIST
31171: LIST
31172: PUSH
31173: EMPTY
31174: LIST
31175: LIST
31176: PPUSH
31177: CALL_OW 69
31181: ST_TO_ADDR
// if not tmp then
31182: LD_VAR 0 2
31186: NOT
31187: IFFALSE 31191
// exit ;
31189: GO 31340
// un := tmp [ rand ( 1 , tmp ) ] ;
31191: LD_ADDR_VAR 0 3
31195: PUSH
31196: LD_VAR 0 2
31200: PUSH
31201: LD_INT 1
31203: PPUSH
31204: LD_VAR 0 2
31208: PPUSH
31209: CALL_OW 12
31213: ARRAY
31214: ST_TO_ADDR
// if Crawls ( un ) then
31215: LD_VAR 0 3
31219: PPUSH
31220: CALL_OW 318
31224: IFFALSE 31235
// ComWalk ( un ) ;
31226: LD_VAR 0 3
31230: PPUSH
31231: CALL_OW 138
// SetClass ( un , class_mortar ) ;
31235: LD_VAR 0 3
31239: PPUSH
31240: LD_INT 8
31242: PPUSH
31243: CALL_OW 336
// end ; 4 :
31247: GO 31340
31249: LD_INT 4
31251: DOUBLE
31252: EQUAL
31253: IFTRUE 31257
31255: GO 31318
31257: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
31258: LD_ADDR_VAR 0 2
31262: PUSH
31263: LD_INT 22
31265: PUSH
31266: LD_OWVAR 2
31270: PUSH
31271: EMPTY
31272: LIST
31273: LIST
31274: PUSH
31275: LD_INT 30
31277: PUSH
31278: LD_INT 29
31280: PUSH
31281: EMPTY
31282: LIST
31283: LIST
31284: PUSH
31285: EMPTY
31286: LIST
31287: LIST
31288: PPUSH
31289: CALL_OW 69
31293: ST_TO_ADDR
// if not tmp then
31294: LD_VAR 0 2
31298: NOT
31299: IFFALSE 31303
// exit ;
31301: GO 31340
// DestroyUnit ( tmp [ 1 ] ) ;
31303: LD_VAR 0 2
31307: PUSH
31308: LD_INT 1
31310: ARRAY
31311: PPUSH
31312: CALL_OW 65
// end ; 5 .. 7 :
31316: GO 31340
31318: LD_INT 5
31320: DOUBLE
31321: GREATEREQUAL
31322: IFFALSE 31330
31324: LD_INT 7
31326: DOUBLE
31327: LESSEQUAL
31328: IFTRUE 31332
31330: GO 31339
31332: POP
// StreamSibBomb ; end ;
31333: CALL 27590 0 0
31337: GO 31340
31339: POP
// end ;
31340: PPOPN 3
31342: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
31343: LD_EXP 90
31347: PUSH
31348: LD_EXP 140
31352: AND
31353: IFFALSE 31509
31355: GO 31357
31357: DISABLE
31358: LD_INT 0
31360: PPUSH
31361: PPUSH
31362: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
31363: LD_ADDR_VAR 0 2
31367: PUSH
31368: LD_INT 81
31370: PUSH
31371: LD_OWVAR 2
31375: PUSH
31376: EMPTY
31377: LIST
31378: LIST
31379: PUSH
31380: LD_INT 2
31382: PUSH
31383: LD_INT 21
31385: PUSH
31386: LD_INT 1
31388: PUSH
31389: EMPTY
31390: LIST
31391: LIST
31392: PUSH
31393: LD_INT 21
31395: PUSH
31396: LD_INT 2
31398: PUSH
31399: EMPTY
31400: LIST
31401: LIST
31402: PUSH
31403: EMPTY
31404: LIST
31405: LIST
31406: LIST
31407: PUSH
31408: EMPTY
31409: LIST
31410: LIST
31411: PPUSH
31412: CALL_OW 69
31416: ST_TO_ADDR
// if not tmp then
31417: LD_VAR 0 2
31421: NOT
31422: IFFALSE 31426
// exit ;
31424: GO 31509
// p := 0 ;
31426: LD_ADDR_VAR 0 3
31430: PUSH
31431: LD_INT 0
31433: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
31434: LD_INT 35
31436: PPUSH
31437: CALL_OW 67
// p := p + 1 ;
31441: LD_ADDR_VAR 0 3
31445: PUSH
31446: LD_VAR 0 3
31450: PUSH
31451: LD_INT 1
31453: PLUS
31454: ST_TO_ADDR
// for i in tmp do
31455: LD_ADDR_VAR 0 1
31459: PUSH
31460: LD_VAR 0 2
31464: PUSH
31465: FOR_IN
31466: IFFALSE 31497
// if GetLives ( i ) < 1000 then
31468: LD_VAR 0 1
31472: PPUSH
31473: CALL_OW 256
31477: PUSH
31478: LD_INT 1000
31480: LESS
31481: IFFALSE 31495
// SetLives ( i , 1000 ) ;
31483: LD_VAR 0 1
31487: PPUSH
31488: LD_INT 1000
31490: PPUSH
31491: CALL_OW 234
31495: GO 31465
31497: POP
31498: POP
// until p > 20 ;
31499: LD_VAR 0 3
31503: PUSH
31504: LD_INT 20
31506: GREATER
31507: IFFALSE 31434
// end ;
31509: PPOPN 3
31511: END
// every 0 0$1 trigger StreamModeActive and sTime do
31512: LD_EXP 90
31516: PUSH
31517: LD_EXP 141
31521: AND
31522: IFFALSE 31557
31524: GO 31526
31526: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
31527: LD_INT 28
31529: PPUSH
31530: LD_OWVAR 2
31534: PPUSH
31535: LD_INT 2
31537: PPUSH
31538: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
31542: LD_INT 30
31544: PPUSH
31545: LD_OWVAR 2
31549: PPUSH
31550: LD_INT 2
31552: PPUSH
31553: CALL_OW 322
// end ;
31557: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
31558: LD_EXP 90
31562: PUSH
31563: LD_EXP 142
31567: AND
31568: IFFALSE 31689
31570: GO 31572
31572: DISABLE
31573: LD_INT 0
31575: PPUSH
31576: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
31577: LD_ADDR_VAR 0 2
31581: PUSH
31582: LD_INT 22
31584: PUSH
31585: LD_OWVAR 2
31589: PUSH
31590: EMPTY
31591: LIST
31592: LIST
31593: PUSH
31594: LD_INT 21
31596: PUSH
31597: LD_INT 1
31599: PUSH
31600: EMPTY
31601: LIST
31602: LIST
31603: PUSH
31604: LD_INT 3
31606: PUSH
31607: LD_INT 23
31609: PUSH
31610: LD_INT 0
31612: PUSH
31613: EMPTY
31614: LIST
31615: LIST
31616: PUSH
31617: EMPTY
31618: LIST
31619: LIST
31620: PUSH
31621: EMPTY
31622: LIST
31623: LIST
31624: LIST
31625: PPUSH
31626: CALL_OW 69
31630: ST_TO_ADDR
// if not tmp then
31631: LD_VAR 0 2
31635: NOT
31636: IFFALSE 31640
// exit ;
31638: GO 31689
// for i in tmp do
31640: LD_ADDR_VAR 0 1
31644: PUSH
31645: LD_VAR 0 2
31649: PUSH
31650: FOR_IN
31651: IFFALSE 31687
// begin if Crawls ( i ) then
31653: LD_VAR 0 1
31657: PPUSH
31658: CALL_OW 318
31662: IFFALSE 31673
// ComWalk ( i ) ;
31664: LD_VAR 0 1
31668: PPUSH
31669: CALL_OW 138
// SetClass ( i , 2 ) ;
31673: LD_VAR 0 1
31677: PPUSH
31678: LD_INT 2
31680: PPUSH
31681: CALL_OW 336
// end ;
31685: GO 31650
31687: POP
31688: POP
// end ;
31689: PPOPN 2
31691: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
31692: LD_EXP 90
31696: PUSH
31697: LD_EXP 143
31701: AND
31702: IFFALSE 31983
31704: GO 31706
31706: DISABLE
31707: LD_INT 0
31709: PPUSH
31710: PPUSH
31711: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
31712: LD_OWVAR 2
31716: PPUSH
31717: LD_INT 9
31719: PPUSH
31720: LD_INT 1
31722: PPUSH
31723: LD_INT 1
31725: PPUSH
31726: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
31730: LD_INT 9
31732: PPUSH
31733: LD_OWVAR 2
31737: PPUSH
31738: CALL_OW 343
// uc_side := 9 ;
31742: LD_ADDR_OWVAR 20
31746: PUSH
31747: LD_INT 9
31749: ST_TO_ADDR
// uc_nation := 2 ;
31750: LD_ADDR_OWVAR 21
31754: PUSH
31755: LD_INT 2
31757: ST_TO_ADDR
// hc_name := Dark Warrior ;
31758: LD_ADDR_OWVAR 26
31762: PUSH
31763: LD_STRING Dark Warrior
31765: ST_TO_ADDR
// hc_gallery :=  ;
31766: LD_ADDR_OWVAR 33
31770: PUSH
31771: LD_STRING 
31773: ST_TO_ADDR
// hc_noskilllimit := true ;
31774: LD_ADDR_OWVAR 76
31778: PUSH
31779: LD_INT 1
31781: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
31782: LD_ADDR_OWVAR 31
31786: PUSH
31787: LD_INT 30
31789: PUSH
31790: LD_INT 30
31792: PUSH
31793: LD_INT 30
31795: PUSH
31796: LD_INT 30
31798: PUSH
31799: EMPTY
31800: LIST
31801: LIST
31802: LIST
31803: LIST
31804: ST_TO_ADDR
// un := CreateHuman ;
31805: LD_ADDR_VAR 0 3
31809: PUSH
31810: CALL_OW 44
31814: ST_TO_ADDR
// hc_noskilllimit := false ;
31815: LD_ADDR_OWVAR 76
31819: PUSH
31820: LD_INT 0
31822: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
31823: LD_VAR 0 3
31827: PPUSH
31828: LD_INT 1
31830: PPUSH
31831: CALL_OW 51
// p := 0 ;
31835: LD_ADDR_VAR 0 2
31839: PUSH
31840: LD_INT 0
31842: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
31843: LD_INT 35
31845: PPUSH
31846: CALL_OW 67
// p := p + 1 ;
31850: LD_ADDR_VAR 0 2
31854: PUSH
31855: LD_VAR 0 2
31859: PUSH
31860: LD_INT 1
31862: PLUS
31863: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
31864: LD_VAR 0 3
31868: PPUSH
31869: CALL_OW 256
31873: PUSH
31874: LD_INT 1000
31876: LESS
31877: IFFALSE 31891
// SetLives ( un , 1000 ) ;
31879: LD_VAR 0 3
31883: PPUSH
31884: LD_INT 1000
31886: PPUSH
31887: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
31891: LD_VAR 0 3
31895: PPUSH
31896: LD_INT 81
31898: PUSH
31899: LD_OWVAR 2
31903: PUSH
31904: EMPTY
31905: LIST
31906: LIST
31907: PUSH
31908: LD_INT 91
31910: PUSH
31911: LD_VAR 0 3
31915: PUSH
31916: LD_INT 30
31918: PUSH
31919: EMPTY
31920: LIST
31921: LIST
31922: LIST
31923: PUSH
31924: EMPTY
31925: LIST
31926: LIST
31927: PPUSH
31928: CALL_OW 69
31932: PPUSH
31933: LD_VAR 0 3
31937: PPUSH
31938: CALL_OW 74
31942: PPUSH
31943: CALL_OW 115
// until p > 60 or IsDead ( un ) ;
31947: LD_VAR 0 2
31951: PUSH
31952: LD_INT 60
31954: GREATER
31955: PUSH
31956: LD_VAR 0 3
31960: PPUSH
31961: CALL_OW 301
31965: OR
31966: IFFALSE 31843
// if un then
31968: LD_VAR 0 3
31972: IFFALSE 31983
// RemoveUnit ( un ) ;
31974: LD_VAR 0 3
31978: PPUSH
31979: CALL_OW 64
// end ;
31983: PPOPN 3
31985: END
// export function hHackUnlimitedResources ; var i , j , tmp ; begin
31986: LD_INT 0
31988: PPUSH
31989: PPUSH
31990: PPUSH
31991: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
31992: LD_ADDR_VAR 0 4
31996: PUSH
31997: LD_INT 22
31999: PUSH
32000: LD_OWVAR 2
32004: PUSH
32005: EMPTY
32006: LIST
32007: LIST
32008: PUSH
32009: LD_INT 2
32011: PUSH
32012: LD_INT 30
32014: PUSH
32015: LD_INT 0
32017: PUSH
32018: EMPTY
32019: LIST
32020: LIST
32021: PUSH
32022: LD_INT 30
32024: PUSH
32025: LD_INT 1
32027: PUSH
32028: EMPTY
32029: LIST
32030: LIST
32031: PUSH
32032: EMPTY
32033: LIST
32034: LIST
32035: LIST
32036: PUSH
32037: EMPTY
32038: LIST
32039: LIST
32040: PPUSH
32041: CALL_OW 69
32045: ST_TO_ADDR
// if not tmp then
32046: LD_VAR 0 4
32050: NOT
32051: IFFALSE 32055
// exit ;
32053: GO 32114
// for i in tmp do
32055: LD_ADDR_VAR 0 2
32059: PUSH
32060: LD_VAR 0 4
32064: PUSH
32065: FOR_IN
32066: IFFALSE 32112
// for j = 1 to 3 do
32068: LD_ADDR_VAR 0 3
32072: PUSH
32073: DOUBLE
32074: LD_INT 1
32076: DEC
32077: ST_TO_ADDR
32078: LD_INT 3
32080: PUSH
32081: FOR_TO
32082: IFFALSE 32108
// SetResourceType ( GetBase ( i ) , j , 99999 ) ;
32084: LD_VAR 0 2
32088: PPUSH
32089: CALL_OW 274
32093: PPUSH
32094: LD_VAR 0 3
32098: PPUSH
32099: LD_INT 99999
32101: PPUSH
32102: CALL_OW 277
32106: GO 32081
32108: POP
32109: POP
32110: GO 32065
32112: POP
32113: POP
// end ;
32114: LD_VAR 0 1
32118: RET
// export function hHackSetLevel10 ; var i , j ; begin
32119: LD_INT 0
32121: PPUSH
32122: PPUSH
32123: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
32124: LD_ADDR_VAR 0 2
32128: PUSH
32129: LD_INT 21
32131: PUSH
32132: LD_INT 1
32134: PUSH
32135: EMPTY
32136: LIST
32137: LIST
32138: PPUSH
32139: CALL_OW 69
32143: PUSH
32144: FOR_IN
32145: IFFALSE 32197
// if IsSelected ( i ) then
32147: LD_VAR 0 2
32151: PPUSH
32152: CALL_OW 306
32156: IFFALSE 32195
// begin for j := 1 to 4 do
32158: LD_ADDR_VAR 0 3
32162: PUSH
32163: DOUBLE
32164: LD_INT 1
32166: DEC
32167: ST_TO_ADDR
32168: LD_INT 4
32170: PUSH
32171: FOR_TO
32172: IFFALSE 32193
// SetSkill ( i , j , 10 ) ;
32174: LD_VAR 0 2
32178: PPUSH
32179: LD_VAR 0 3
32183: PPUSH
32184: LD_INT 10
32186: PPUSH
32187: CALL_OW 237
32191: GO 32171
32193: POP
32194: POP
// end ;
32195: GO 32144
32197: POP
32198: POP
// end ;
32199: LD_VAR 0 1
32203: RET
// export function hHackSetLevel10YourUnits ; var i , j ; begin
32204: LD_INT 0
32206: PPUSH
32207: PPUSH
32208: PPUSH
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) do
32209: LD_ADDR_VAR 0 2
32213: PUSH
32214: LD_INT 22
32216: PUSH
32217: LD_OWVAR 2
32221: PUSH
32222: EMPTY
32223: LIST
32224: LIST
32225: PUSH
32226: LD_INT 21
32228: PUSH
32229: LD_INT 1
32231: PUSH
32232: EMPTY
32233: LIST
32234: LIST
32235: PUSH
32236: EMPTY
32237: LIST
32238: LIST
32239: PPUSH
32240: CALL_OW 69
32244: PUSH
32245: FOR_IN
32246: IFFALSE 32287
// begin for j := 1 to 4 do
32248: LD_ADDR_VAR 0 3
32252: PUSH
32253: DOUBLE
32254: LD_INT 1
32256: DEC
32257: ST_TO_ADDR
32258: LD_INT 4
32260: PUSH
32261: FOR_TO
32262: IFFALSE 32283
// SetSkill ( i , j , 10 ) ;
32264: LD_VAR 0 2
32268: PPUSH
32269: LD_VAR 0 3
32273: PPUSH
32274: LD_INT 10
32276: PPUSH
32277: CALL_OW 237
32281: GO 32261
32283: POP
32284: POP
// end ;
32285: GO 32245
32287: POP
32288: POP
// end ;
32289: LD_VAR 0 1
32293: RET
// export function hHackSpawnHuman ( nation , class , skill ) ; begin
32294: LD_INT 0
32296: PPUSH
// uc_side := your_side ;
32297: LD_ADDR_OWVAR 20
32301: PUSH
32302: LD_OWVAR 2
32306: ST_TO_ADDR
// uc_nation := nation ;
32307: LD_ADDR_OWVAR 21
32311: PUSH
32312: LD_VAR 0 1
32316: ST_TO_ADDR
// InitHc ;
32317: CALL_OW 19
// PrepareHuman ( false , class , skill ) ;
32321: LD_INT 0
32323: PPUSH
32324: LD_VAR 0 2
32328: PPUSH
32329: LD_VAR 0 3
32333: PPUSH
32334: CALL_OW 380
// PlaceUnitAnywhere ( CreateHuman , true ) ;
32338: CALL_OW 44
32342: PPUSH
32343: LD_INT 1
32345: PPUSH
32346: CALL_OW 51
// end ;
32350: LD_VAR 0 4
32354: RET
// export function hHackSpawnVehicle ; begin
32355: LD_INT 0
32357: PPUSH
// uc_side := your_side ;
32358: LD_ADDR_OWVAR 20
32362: PUSH
32363: LD_OWVAR 2
32367: ST_TO_ADDR
// uc_nation := rand ( 1 , 3 ) ;
32368: LD_ADDR_OWVAR 21
32372: PUSH
32373: LD_INT 1
32375: PPUSH
32376: LD_INT 3
32378: PPUSH
32379: CALL_OW 12
32383: ST_TO_ADDR
// InitVc ;
32384: CALL_OW 20
// case uc_nation of 1 :
32388: LD_OWVAR 21
32392: PUSH
32393: LD_INT 1
32395: DOUBLE
32396: EQUAL
32397: IFTRUE 32401
32399: GO 32545
32401: POP
// begin vc_chassis := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] [ rand ( 1 , 5 ) ] ;
32402: LD_ADDR_OWVAR 37
32406: PUSH
32407: LD_INT 1
32409: PUSH
32410: LD_INT 2
32412: PUSH
32413: LD_INT 3
32415: PUSH
32416: LD_INT 4
32418: PUSH
32419: LD_INT 5
32421: PUSH
32422: EMPTY
32423: LIST
32424: LIST
32425: LIST
32426: LIST
32427: LIST
32428: PUSH
32429: LD_INT 1
32431: PPUSH
32432: LD_INT 5
32434: PPUSH
32435: CALL_OW 12
32439: ARRAY
32440: ST_TO_ADDR
// vc_engine := rand ( 1 , 3 ) ;
32441: LD_ADDR_OWVAR 39
32445: PUSH
32446: LD_INT 1
32448: PPUSH
32449: LD_INT 3
32451: PPUSH
32452: CALL_OW 12
32456: ST_TO_ADDR
// vc_control := [ control_manual , control_remote , control_computer ] [ rand ( 1 , 3 ) ] ;
32457: LD_ADDR_OWVAR 38
32461: PUSH
32462: LD_INT 1
32464: PUSH
32465: LD_INT 2
32467: PUSH
32468: LD_INT 3
32470: PUSH
32471: EMPTY
32472: LIST
32473: LIST
32474: LIST
32475: PUSH
32476: LD_INT 1
32478: PPUSH
32479: LD_INT 3
32481: PPUSH
32482: CALL_OW 12
32486: ARRAY
32487: ST_TO_ADDR
// vc_weapon := [ us_machine_gun , us_gatling_gun , us_double_gun , us_light_gun , us_rocket_launcher , us_siberium_rocket , us_laser , us_double_laser , us_heavy_gun ] [ rand ( 1 , 9 ) ] ;
32488: LD_ADDR_OWVAR 40
32492: PUSH
32493: LD_INT 2
32495: PUSH
32496: LD_INT 4
32498: PUSH
32499: LD_INT 5
32501: PUSH
32502: LD_INT 3
32504: PUSH
32505: LD_INT 7
32507: PUSH
32508: LD_INT 8
32510: PUSH
32511: LD_INT 9
32513: PUSH
32514: LD_INT 10
32516: PUSH
32517: LD_INT 6
32519: PUSH
32520: EMPTY
32521: LIST
32522: LIST
32523: LIST
32524: LIST
32525: LIST
32526: LIST
32527: LIST
32528: LIST
32529: LIST
32530: PUSH
32531: LD_INT 1
32533: PPUSH
32534: LD_INT 9
32536: PPUSH
32537: CALL_OW 12
32541: ARRAY
32542: ST_TO_ADDR
// end ; 2 :
32543: GO 32810
32545: LD_INT 2
32547: DOUBLE
32548: EQUAL
32549: IFTRUE 32553
32551: GO 32677
32553: POP
// begin vc_chassis := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] [ rand ( 1 , 4 ) ] ;
32554: LD_ADDR_OWVAR 37
32558: PUSH
32559: LD_INT 11
32561: PUSH
32562: LD_INT 12
32564: PUSH
32565: LD_INT 13
32567: PUSH
32568: LD_INT 14
32570: PUSH
32571: EMPTY
32572: LIST
32573: LIST
32574: LIST
32575: LIST
32576: PUSH
32577: LD_INT 1
32579: PPUSH
32580: LD_INT 4
32582: PPUSH
32583: CALL_OW 12
32587: ARRAY
32588: ST_TO_ADDR
// vc_engine := rand ( 1 , 3 ) ;
32589: LD_ADDR_OWVAR 39
32593: PUSH
32594: LD_INT 1
32596: PPUSH
32597: LD_INT 3
32599: PPUSH
32600: CALL_OW 12
32604: ST_TO_ADDR
// vc_control := [ control_manual , control_remote , control_apeman ] [ rand ( 1 , 3 ) ] ;
32605: LD_ADDR_OWVAR 38
32609: PUSH
32610: LD_INT 1
32612: PUSH
32613: LD_INT 2
32615: PUSH
32616: LD_INT 5
32618: PUSH
32619: EMPTY
32620: LIST
32621: LIST
32622: LIST
32623: PUSH
32624: LD_INT 1
32626: PPUSH
32627: LD_INT 3
32629: PPUSH
32630: CALL_OW 12
32634: ARRAY
32635: ST_TO_ADDR
// vc_weapon := [ ar_double_machine_gun , ar_flame_thrower , ar_gun , ar_rocket_launcher , ar_selfpropelled_bomb ] [ rand ( 1 , 5 ) ] ;
32636: LD_ADDR_OWVAR 40
32640: PUSH
32641: LD_INT 24
32643: PUSH
32644: LD_INT 26
32646: PUSH
32647: LD_INT 27
32649: PUSH
32650: LD_INT 28
32652: PUSH
32653: LD_INT 29
32655: PUSH
32656: EMPTY
32657: LIST
32658: LIST
32659: LIST
32660: LIST
32661: LIST
32662: PUSH
32663: LD_INT 1
32665: PPUSH
32666: LD_INT 5
32668: PPUSH
32669: CALL_OW 12
32673: ARRAY
32674: ST_TO_ADDR
// end ; 3 :
32675: GO 32810
32677: LD_INT 3
32679: DOUBLE
32680: EQUAL
32681: IFTRUE 32685
32683: GO 32809
32685: POP
// begin vc_chassis := [ ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] [ rand ( 1 , 4 ) ] ;
32686: LD_ADDR_OWVAR 37
32690: PUSH
32691: LD_INT 21
32693: PUSH
32694: LD_INT 23
32696: PUSH
32697: LD_INT 22
32699: PUSH
32700: LD_INT 24
32702: PUSH
32703: EMPTY
32704: LIST
32705: LIST
32706: LIST
32707: LIST
32708: PUSH
32709: LD_INT 1
32711: PPUSH
32712: LD_INT 4
32714: PPUSH
32715: CALL_OW 12
32719: ARRAY
32720: ST_TO_ADDR
// vc_engine := rand ( 1 , 3 ) ;
32721: LD_ADDR_OWVAR 39
32725: PUSH
32726: LD_INT 1
32728: PPUSH
32729: LD_INT 3
32731: PPUSH
32732: CALL_OW 12
32736: ST_TO_ADDR
// vc_control := [ control_manual , control_computer ] [ rand ( 1 , 2 ) ] ;
32737: LD_ADDR_OWVAR 38
32741: PUSH
32742: LD_INT 1
32744: PUSH
32745: LD_INT 3
32747: PUSH
32748: EMPTY
32749: LIST
32750: LIST
32751: PUSH
32752: LD_INT 1
32754: PPUSH
32755: LD_INT 2
32757: PPUSH
32758: CALL_OW 12
32762: ARRAY
32763: ST_TO_ADDR
// vc_weapon := [ ru_heavy_machine_gun , ru_gatling_gun , ru_gun , ru_heavy_gun , ru_siberium_rocket , ru_rocket ] [ rand ( 1 , 6 ) ] ;
32764: LD_ADDR_OWVAR 40
32768: PUSH
32769: LD_INT 42
32771: PUSH
32772: LD_INT 43
32774: PUSH
32775: LD_INT 44
32777: PUSH
32778: LD_INT 46
32780: PUSH
32781: LD_INT 48
32783: PUSH
32784: LD_INT 47
32786: PUSH
32787: EMPTY
32788: LIST
32789: LIST
32790: LIST
32791: LIST
32792: LIST
32793: LIST
32794: PUSH
32795: LD_INT 1
32797: PPUSH
32798: LD_INT 6
32800: PPUSH
32801: CALL_OW 12
32805: ARRAY
32806: ST_TO_ADDR
// end ; end ;
32807: GO 32810
32809: POP
// PlaceUnitAnywhere ( CreateVehicle , true ) ;
32810: CALL_OW 45
32814: PPUSH
32815: LD_INT 1
32817: PPUSH
32818: CALL_OW 51
// end ;
32822: LD_VAR 0 1
32826: RET
// export hInvincible ; every 1 do
32827: GO 32829
32829: DISABLE
// hInvincible := [ ] ;
32830: LD_ADDR_EXP 144
32834: PUSH
32835: EMPTY
32836: ST_TO_ADDR
32837: END
// every 10 do var i ;
32838: GO 32840
32840: DISABLE
32841: LD_INT 0
32843: PPUSH
// begin enable ;
32844: ENABLE
// if not hInvincible then
32845: LD_EXP 144
32849: NOT
32850: IFFALSE 32854
// exit ;
32852: GO 32898
// for i in hInvincible do
32854: LD_ADDR_VAR 0 1
32858: PUSH
32859: LD_EXP 144
32863: PUSH
32864: FOR_IN
32865: IFFALSE 32896
// if GetLives ( i ) < 1000 then
32867: LD_VAR 0 1
32871: PPUSH
32872: CALL_OW 256
32876: PUSH
32877: LD_INT 1000
32879: LESS
32880: IFFALSE 32894
// SetLives ( i , 1000 ) ;
32882: LD_VAR 0 1
32886: PPUSH
32887: LD_INT 1000
32889: PPUSH
32890: CALL_OW 234
32894: GO 32864
32896: POP
32897: POP
// end ;
32898: PPOPN 1
32900: END
// export function hHackInvincible ; var i ; begin
32901: LD_INT 0
32903: PPUSH
32904: PPUSH
// for i in FilterAllUnits ( [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ) do
32905: LD_ADDR_VAR 0 2
32909: PUSH
32910: LD_INT 2
32912: PUSH
32913: LD_INT 21
32915: PUSH
32916: LD_INT 1
32918: PUSH
32919: EMPTY
32920: LIST
32921: LIST
32922: PUSH
32923: LD_INT 21
32925: PUSH
32926: LD_INT 2
32928: PUSH
32929: EMPTY
32930: LIST
32931: LIST
32932: PUSH
32933: EMPTY
32934: LIST
32935: LIST
32936: LIST
32937: PPUSH
32938: CALL_OW 69
32942: PUSH
32943: FOR_IN
32944: IFFALSE 33005
// if IsSelected ( i ) then
32946: LD_VAR 0 2
32950: PPUSH
32951: CALL_OW 306
32955: IFFALSE 33003
// begin if i in hInvincible then
32957: LD_VAR 0 2
32961: PUSH
32962: LD_EXP 144
32966: IN
32967: IFFALSE 32987
// hInvincible := hInvincible diff i else
32969: LD_ADDR_EXP 144
32973: PUSH
32974: LD_EXP 144
32978: PUSH
32979: LD_VAR 0 2
32983: DIFF
32984: ST_TO_ADDR
32985: GO 33003
// hInvincible := hInvincible union i ;
32987: LD_ADDR_EXP 144
32991: PUSH
32992: LD_EXP 144
32996: PUSH
32997: LD_VAR 0 2
33001: UNION
33002: ST_TO_ADDR
// end ;
33003: GO 32943
33005: POP
33006: POP
// end ;
33007: LD_VAR 0 1
33011: RET
// export function hHackInvisible ; var i , j ; begin
33012: LD_INT 0
33014: PPUSH
33015: PPUSH
33016: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
33017: LD_ADDR_VAR 0 2
33021: PUSH
33022: LD_INT 21
33024: PUSH
33025: LD_INT 1
33027: PUSH
33028: EMPTY
33029: LIST
33030: LIST
33031: PPUSH
33032: CALL_OW 69
33036: PUSH
33037: FOR_IN
33038: IFFALSE 33062
// if IsSelected ( i ) then
33040: LD_VAR 0 2
33044: PPUSH
33045: CALL_OW 306
33049: IFFALSE 33060
// ComForceInvisible ( i ) ;
33051: LD_VAR 0 2
33055: PPUSH
33056: CALL_OW 496
33060: GO 33037
33062: POP
33063: POP
// end ;
33064: LD_VAR 0 1
33068: RET
// export function hHackChangeYourSide ; begin
33069: LD_INT 0
33071: PPUSH
// if your_side = 8 then
33072: LD_OWVAR 2
33076: PUSH
33077: LD_INT 8
33079: EQUAL
33080: IFFALSE 33092
// your_side := 0 else
33082: LD_ADDR_OWVAR 2
33086: PUSH
33087: LD_INT 0
33089: ST_TO_ADDR
33090: GO 33106
// your_side := your_side + 1 ;
33092: LD_ADDR_OWVAR 2
33096: PUSH
33097: LD_OWVAR 2
33101: PUSH
33102: LD_INT 1
33104: PLUS
33105: ST_TO_ADDR
// end ;
33106: LD_VAR 0 1
33110: RET
// export function hHackChangeUnitSide ; var i , j ; begin
33111: LD_INT 0
33113: PPUSH
33114: PPUSH
33115: PPUSH
// for i in all_units do
33116: LD_ADDR_VAR 0 2
33120: PUSH
33121: LD_OWVAR 3
33125: PUSH
33126: FOR_IN
33127: IFFALSE 33205
// if IsSelected ( i ) then
33129: LD_VAR 0 2
33133: PPUSH
33134: CALL_OW 306
33138: IFFALSE 33203
// begin j := GetSide ( i ) ;
33140: LD_ADDR_VAR 0 3
33144: PUSH
33145: LD_VAR 0 2
33149: PPUSH
33150: CALL_OW 255
33154: ST_TO_ADDR
// if j = 8 then
33155: LD_VAR 0 3
33159: PUSH
33160: LD_INT 8
33162: EQUAL
33163: IFFALSE 33175
// j := 0 else
33165: LD_ADDR_VAR 0 3
33169: PUSH
33170: LD_INT 0
33172: ST_TO_ADDR
33173: GO 33189
// j := j + 1 ;
33175: LD_ADDR_VAR 0 3
33179: PUSH
33180: LD_VAR 0 3
33184: PUSH
33185: LD_INT 1
33187: PLUS
33188: ST_TO_ADDR
// SetSide ( i , j ) ;
33189: LD_VAR 0 2
33193: PPUSH
33194: LD_VAR 0 3
33198: PPUSH
33199: CALL_OW 235
// end ;
33203: GO 33126
33205: POP
33206: POP
// end ;
33207: LD_VAR 0 1
33211: RET
// export function hHackFog ; begin
33212: LD_INT 0
33214: PPUSH
// FogOff ( true ) ;
33215: LD_INT 1
33217: PPUSH
33218: CALL_OW 344
// end ;
33222: LD_VAR 0 1
33226: RET
// export function hHackApeman ; begin
33227: LD_INT 0
33229: PPUSH
// uc_side := your_side ;
33230: LD_ADDR_OWVAR 20
33234: PUSH
33235: LD_OWVAR 2
33239: ST_TO_ADDR
// uc_nation := 0 ;
33240: LD_ADDR_OWVAR 21
33244: PUSH
33245: LD_INT 0
33247: ST_TO_ADDR
// hc_name :=  ;
33248: LD_ADDR_OWVAR 26
33252: PUSH
33253: LD_STRING 
33255: ST_TO_ADDR
// hc_gallery :=  ;
33256: LD_ADDR_OWVAR 33
33260: PUSH
33261: LD_STRING 
33263: ST_TO_ADDR
// hc_skills := [ 0 , 0 , 0 , 0 ] ;
33264: LD_ADDR_OWVAR 31
33268: PUSH
33269: LD_INT 0
33271: PUSH
33272: LD_INT 0
33274: PUSH
33275: LD_INT 0
33277: PUSH
33278: LD_INT 0
33280: PUSH
33281: EMPTY
33282: LIST
33283: LIST
33284: LIST
33285: LIST
33286: ST_TO_ADDR
// hc_class := class_apeman ;
33287: LD_ADDR_OWVAR 28
33291: PUSH
33292: LD_INT 12
33294: ST_TO_ADDR
// PlaceUnitAnywhere ( CreateHuman , true ) ;
33295: CALL_OW 44
33299: PPUSH
33300: LD_INT 1
33302: PPUSH
33303: CALL_OW 51
// end ;
33307: LD_VAR 0 1
33311: RET
// export function hHackBoom ; begin
33312: LD_INT 0
33314: PPUSH
// uc_side := your_side ;
33315: LD_ADDR_OWVAR 20
33319: PUSH
33320: LD_OWVAR 2
33324: ST_TO_ADDR
// uc_nation := 1 ;
33325: LD_ADDR_OWVAR 21
33329: PUSH
33330: LD_INT 1
33332: ST_TO_ADDR
// vc_chassis := us_morphling ;
33333: LD_ADDR_OWVAR 37
33337: PUSH
33338: LD_INT 5
33340: ST_TO_ADDR
// vc_engine := engine_siberite ;
33341: LD_ADDR_OWVAR 39
33345: PUSH
33346: LD_INT 3
33348: ST_TO_ADDR
// vc_control := control_computer ;
33349: LD_ADDR_OWVAR 38
33353: PUSH
33354: LD_INT 3
33356: ST_TO_ADDR
// vc_weapon := us_siberium_rocket ;
33357: LD_ADDR_OWVAR 40
33361: PUSH
33362: LD_INT 8
33364: ST_TO_ADDR
// PlaceUnitAnywhere ( CreateVehicle , true ) ;
33365: CALL_OW 45
33369: PPUSH
33370: LD_INT 1
33372: PPUSH
33373: CALL_OW 51
// end ;
33377: LD_VAR 0 1
33381: RET
