// starting begin InitMission ;
   0: NOP4
// end ;
   4: END
// export playerVehicles ; export beriaBase ; export kirovBase ; export meetBelkovBrother ; export platonovOpinion ; export belkovReturn ; export meetPlatonov ; export labConstructed , workshopConstructed , engineResearched , canBuildSameBuilding ; export constructedFirstVehicle , firstVeh ; export vehicleForKurin ; export backToBeria1 , backToBeria2 ; export construcMoreVehicles , constructedVehiclesCounter ; export canExitBase , canExploreMap ; export spawnCrates ; export canRemoveBelkovUnits , removedBelkovUntis , immortalBelkovTeam , immortalVehLive ; export kirovConstructedBunkers ; export activateAMAI , activateBelkovAI ; export sawLeftBunker , sawRightBunker ; export dialogAttackLeftBunkers , dialogAttackRightBunkers , dialogLoopBlocker ; export playerGetSupport ; export saveBelkovDecision ; export saveBelkovObjective , belkovSaved ; export captureBelkovVehicle ; export raportForPlatonov , medalForGetSupport ; export northMapExplored ; export initiative ; export lostComradesCounter ; export achievement_ConstructVehicles ; function InitMission ; begin
   5: LD_INT 0
   7: PPUSH
// ResetFog ;
   8: NOP4
// RandomizeAll ;
  12: NOP4
// InGameOn ;
  16: NOP4
// InitMapConfig ;
  20: NOP4
// PrepareRussian ;
  24: NOP4
// PrepareNature ;
  28: NOP4
// playerVehicles = [ ] ;
  32: NOP4
  36: PUSH
  37: EMPTY
  38: ST_TO_ADDR
// beriaBase = [ ] ;
  39: NOP4
  43: PUSH
  44: EMPTY
  45: ST_TO_ADDR
// kirovBase = [ ] ;
  46: NOP4
  50: PUSH
  51: EMPTY
  52: ST_TO_ADDR
// meetBelkovBrother = false ;
  53: NOP4
  57: PUSH
  58: LD_INT 0
  60: ST_TO_ADDR
// platonovOpinion = - 1 ;
  61: NOP4
  65: PUSH
  66: LD_INT 1
  68: NEG
  69: ST_TO_ADDR
// belkovReturn = TestCharacters ( 01_Belkov ) ;
  70: NOP4
  74: PUSH
  75: LD_STRING 01_Belkov
  77: PPUSH
  78: NOP4
  82: ST_TO_ADDR
// meetPlatonov = false ;
  83: NOP4
  87: PUSH
  88: LD_INT 0
  90: ST_TO_ADDR
// labConstructed = false ;
  91: NOP4
  95: PUSH
  96: LD_INT 0
  98: ST_TO_ADDR
// workshopConstructed = false ;
  99: NOP4
 103: PUSH
 104: LD_INT 0
 106: ST_TO_ADDR
// engineResearched = false ;
 107: NOP4
 111: PUSH
 112: LD_INT 0
 114: ST_TO_ADDR
// canBuildSameBuilding = false ;
 115: NOP4
 119: PUSH
 120: LD_INT 0
 122: ST_TO_ADDR
// constructedFirstVehicle = false ;
 123: NOP4
 127: PUSH
 128: LD_INT 0
 130: ST_TO_ADDR
// vehicleForKurin = false ;
 131: NOP4
 135: PUSH
 136: LD_INT 0
 138: ST_TO_ADDR
// backToBeria1 = false ;
 139: NOP4
 143: PUSH
 144: LD_INT 0
 146: ST_TO_ADDR
// backToBeria2 = false ;
 147: NOP4
 151: PUSH
 152: LD_INT 0
 154: ST_TO_ADDR
// construcMoreVehicles = false ;
 155: NOP4
 159: PUSH
 160: LD_INT 0
 162: ST_TO_ADDR
// constructedVehiclesCounter = 0 ;
 163: NOP4
 167: PUSH
 168: LD_INT 0
 170: ST_TO_ADDR
// spawnCrates = false ;
 171: NOP4
 175: PUSH
 176: LD_INT 0
 178: ST_TO_ADDR
// canRemoveBelkovUnits = false ;
 179: NOP4
 183: PUSH
 184: LD_INT 0
 186: ST_TO_ADDR
// removedBelkovUntis = 0 ;
 187: NOP4
 191: PUSH
 192: LD_INT 0
 194: ST_TO_ADDR
// immortalBelkovTeam = false ;
 195: NOP4
 199: PUSH
 200: LD_INT 0
 202: ST_TO_ADDR
// immortalVehLive = 1000 ;
 203: NOP4
 207: PUSH
 208: LD_INT 1000
 210: ST_TO_ADDR
// canExitBase = true ;
 211: NOP4
 215: PUSH
 216: LD_INT 1
 218: ST_TO_ADDR
// canExploreMap = false ;
 219: NOP4
 223: PUSH
 224: LD_INT 0
 226: ST_TO_ADDR
// sawLeftBunker = false ;
 227: NOP4
 231: PUSH
 232: LD_INT 0
 234: ST_TO_ADDR
// sawRightBunker = false ;
 235: NOP4
 239: PUSH
 240: LD_INT 0
 242: ST_TO_ADDR
// dialogLoopBlocker = false ;
 243: NOP4
 247: PUSH
 248: LD_INT 0
 250: ST_TO_ADDR
// dialogAttackLeftBunkers = false ;
 251: NOP4
 255: PUSH
 256: LD_INT 0
 258: ST_TO_ADDR
// dialogAttackRightBunkers = false ;
 259: NOP4
 263: PUSH
 264: LD_INT 0
 266: ST_TO_ADDR
// playerGetSupport = false ;
 267: NOP4
 271: PUSH
 272: LD_INT 0
 274: ST_TO_ADDR
// captureBelkovVehicle = false ;
 275: NOP4
 279: PUSH
 280: LD_INT 0
 282: ST_TO_ADDR
// saveBelkovObjective = false ;
 283: NOP4
 287: PUSH
 288: LD_INT 0
 290: ST_TO_ADDR
// medalForGetSupport = true ;
 291: NOP4
 295: PUSH
 296: LD_INT 1
 298: ST_TO_ADDR
// raportForPlatonov = - 1 ;
 299: NOP4
 303: PUSH
 304: LD_INT 1
 306: NEG
 307: ST_TO_ADDR
// initiative = 0 ;
 308: NOP4
 312: PUSH
 313: LD_INT 0
 315: ST_TO_ADDR
// lostComradesCounter = 0 ;
 316: NOP4
 320: PUSH
 321: LD_INT 0
 323: ST_TO_ADDR
// northMapExplored = false ;
 324: NOP4
 328: PUSH
 329: LD_INT 0
 331: ST_TO_ADDR
// kirovConstructedBunkers = 0 ;
 332: NOP4
 336: PUSH
 337: LD_INT 0
 339: ST_TO_ADDR
// activateAMAI = false ;
 340: NOP4
 344: PUSH
 345: LD_INT 0
 347: ST_TO_ADDR
// activateBelkovAI = false ;
 348: NOP4
 352: PUSH
 353: LD_INT 0
 355: ST_TO_ADDR
// achievement_ConstructVehicles = 0 ;
 356: NOP4
 360: PUSH
 361: LD_INT 0
 363: ST_TO_ADDR
// MissionIntro ;
 364: NOP4
// end ; end_of_file
 368: LD_VAR 0 1
 372: RET
// export function InitMapConfig ; begin
 373: LD_INT 0
 375: PPUSH
// BaseMapConfig ;
 376: NOP4
// MissionMapConfig ;
 380: NOP4
// end ;
 384: LD_VAR 0 1
 388: RET
// export animalsAmount , animalsStats , animalsAgression , missionPrefix , previousMissionPrefix , debugMode ; function BaseMapConfig ; begin
 389: LD_INT 0
 391: PPUSH
// animalsAmount = [ 2 , 4 , 1 , 0 ] ;
 392: NOP4
 396: PUSH
 397: LD_INT 2
 399: PUSH
 400: LD_INT 4
 402: PUSH
 403: LD_INT 1
 405: PUSH
 406: LD_INT 0
 408: PUSH
 409: EMPTY
 410: LIST
 411: LIST
 412: LIST
 413: LIST
 414: ST_TO_ADDR
// animalsStats = [ 2 , 2 , 2 , 2 ] ;
 415: NOP4
 419: PUSH
 420: LD_INT 2
 422: PUSH
 423: LD_INT 2
 425: PUSH
 426: LD_INT 2
 428: PUSH
 429: LD_INT 2
 431: PUSH
 432: EMPTY
 433: LIST
 434: LIST
 435: LIST
 436: LIST
 437: ST_TO_ADDR
// animalsAgression = 0 ;
 438: NOP4
 442: PUSH
 443: LD_INT 0
 445: ST_TO_ADDR
// debugMode = 0 ;
 446: NOP4
 450: PUSH
 451: LD_INT 0
 453: ST_TO_ADDR
// missionPrefix = 02_ ;
 454: NOP4
 458: PUSH
 459: LD_STRING 02_
 461: ST_TO_ADDR
// previousMissionPrefix = 01_ ;
 462: NOP4
 466: PUSH
 467: LD_STRING 01_
 469: ST_TO_ADDR
// end ;
 470: LD_VAR 0 1
 474: RET
// export kirovAmountPeople ; export meetWithKurinPositions , meetWithPlatonovPositions ; export labCratesRefund , workshopCratesRefund , oilPowerCratesRefund , armouryCratesRefund , bunkerCratesRefund ; export enemySkillLevel ; export trapAmountPeople ; export belkovAttackTime ; function MissionMapConfig ; begin
 475: LD_INT 0
 477: PPUSH
// meetWithKurinPositions = [ [ 162 , 107 ] , [ 162 , 108 ] , [ 163 , 109 ] , [ 163 , 110 ] , [ 162 , 109 ] , [ 161 , 107 ] , [ 161 , 106 ] ] ;
 478: NOP4
 482: PUSH
 483: LD_INT 162
 485: PUSH
 486: LD_INT 107
 488: PUSH
 489: EMPTY
 490: LIST
 491: LIST
 492: PUSH
 493: LD_INT 162
 495: PUSH
 496: LD_INT 108
 498: PUSH
 499: EMPTY
 500: LIST
 501: LIST
 502: PUSH
 503: LD_INT 163
 505: PUSH
 506: LD_INT 109
 508: PUSH
 509: EMPTY
 510: LIST
 511: LIST
 512: PUSH
 513: LD_INT 163
 515: PUSH
 516: LD_INT 110
 518: PUSH
 519: EMPTY
 520: LIST
 521: LIST
 522: PUSH
 523: LD_INT 162
 525: PUSH
 526: LD_INT 109
 528: PUSH
 529: EMPTY
 530: LIST
 531: LIST
 532: PUSH
 533: LD_INT 161
 535: PUSH
 536: LD_INT 107
 538: PUSH
 539: EMPTY
 540: LIST
 541: LIST
 542: PUSH
 543: LD_INT 161
 545: PUSH
 546: LD_INT 106
 548: PUSH
 549: EMPTY
 550: LIST
 551: LIST
 552: PUSH
 553: EMPTY
 554: LIST
 555: LIST
 556: LIST
 557: LIST
 558: LIST
 559: LIST
 560: LIST
 561: ST_TO_ADDR
// meetWithPlatonovPositions = [ [ 113 , 96 ] , [ 114 , 97 ] , [ 114 , 98 ] ] ;
 562: NOP4
 566: PUSH
 567: LD_INT 113
 569: PUSH
 570: LD_INT 96
 572: PUSH
 573: EMPTY
 574: LIST
 575: LIST
 576: PUSH
 577: LD_INT 114
 579: PUSH
 580: LD_INT 97
 582: PUSH
 583: EMPTY
 584: LIST
 585: LIST
 586: PUSH
 587: LD_INT 114
 589: PUSH
 590: LD_INT 98
 592: PUSH
 593: EMPTY
 594: LIST
 595: LIST
 596: PUSH
 597: EMPTY
 598: LIST
 599: LIST
 600: LIST
 601: ST_TO_ADDR
// kirovAmountPeople = [ 10 , 1 , 2 , 1 ] ;
 602: NOP4
 606: PUSH
 607: LD_INT 10
 609: PUSH
 610: LD_INT 1
 612: PUSH
 613: LD_INT 2
 615: PUSH
 616: LD_INT 1
 618: PUSH
 619: EMPTY
 620: LIST
 621: LIST
 622: LIST
 623: LIST
 624: ST_TO_ADDR
// labCratesRefund = 20 ;
 625: NOP4
 629: PUSH
 630: LD_INT 20
 632: ST_TO_ADDR
// workshopCratesRefund = 40 ;
 633: NOP4
 637: PUSH
 638: LD_INT 40
 640: ST_TO_ADDR
// oilPowerCratesRefund = 20 ;
 641: NOP4
 645: PUSH
 646: LD_INT 20
 648: ST_TO_ADDR
// armouryCratesRefund = 30 ;
 649: NOP4
 653: PUSH
 654: LD_INT 30
 656: ST_TO_ADDR
// bunkerCratesRefund = 10 ;
 657: NOP4
 661: PUSH
 662: LD_INT 10
 664: ST_TO_ADDR
// enemySkillLevel = [ 1 , 2 , 2 ] [ Difficulty ] ;
 665: NOP4
 669: PUSH
 670: LD_INT 1
 672: PUSH
 673: LD_INT 2
 675: PUSH
 676: LD_INT 2
 678: PUSH
 679: EMPTY
 680: LIST
 681: LIST
 682: LIST
 683: PUSH
 684: NOP4
 688: ARRAY
 689: ST_TO_ADDR
// trapAmountPeople = [ [ 3 , 2 , 1 , 1 ] , [ 3 , 2 , 1 , 1 ] , [ 3 , 2 , 1 , 1 ] ] [ Difficulty ] ;
 690: NOP4
 694: PUSH
 695: LD_INT 3
 697: PUSH
 698: LD_INT 2
 700: PUSH
 701: LD_INT 1
 703: PUSH
 704: LD_INT 1
 706: PUSH
 707: EMPTY
 708: LIST
 709: LIST
 710: LIST
 711: LIST
 712: PUSH
 713: LD_INT 3
 715: PUSH
 716: LD_INT 2
 718: PUSH
 719: LD_INT 1
 721: PUSH
 722: LD_INT 1
 724: PUSH
 725: EMPTY
 726: LIST
 727: LIST
 728: LIST
 729: LIST
 730: PUSH
 731: LD_INT 3
 733: PUSH
 734: LD_INT 2
 736: PUSH
 737: LD_INT 1
 739: PUSH
 740: LD_INT 1
 742: PUSH
 743: EMPTY
 744: LIST
 745: LIST
 746: LIST
 747: LIST
 748: PUSH
 749: EMPTY
 750: LIST
 751: LIST
 752: LIST
 753: PUSH
 754: NOP4
 758: ARRAY
 759: ST_TO_ADDR
// belkovAttackTime = [ 10 10$0 , 8 8$0 , 6 6$0 ] [ Difficulty ] ;
 760: NOP4
 764: PUSH
 765: LD_INT 21000
 767: PUSH
 768: LD_INT 16800
 770: PUSH
 771: LD_INT 12600
 773: PUSH
 774: EMPTY
 775: LIST
 776: LIST
 777: LIST
 778: PUSH
 779: NOP4
 783: ARRAY
 784: ST_TO_ADDR
// end ;
 785: LD_VAR 0 1
 789: RET
// every 0 0$1 trigger debugMode do var i ;
 790: NOP4
 794: IFFALSE 1109
 796: GO 798
 798: DISABLE
 799: LD_INT 0
 801: PPUSH
// begin enable ;
 802: ENABLE
// FogOff ( your_side ) ;
 803: NOP4
 807: PPUSH
 808: NOP4
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) do
 812: NOP4
 816: PUSH
 817: LD_INT 22
 819: PUSH
 820: NOP4
 824: PUSH
 825: EMPTY
 826: LIST
 827: LIST
 828: PUSH
 829: LD_INT 2
 831: PUSH
 832: LD_INT 21
 834: PUSH
 835: LD_INT 1
 837: PUSH
 838: EMPTY
 839: LIST
 840: LIST
 841: PUSH
 842: LD_INT 21
 844: PUSH
 845: LD_INT 2
 847: PUSH
 848: EMPTY
 849: LIST
 850: LIST
 851: PUSH
 852: EMPTY
 853: LIST
 854: LIST
 855: LIST
 856: PUSH
 857: EMPTY
 858: LIST
 859: LIST
 860: PPUSH
 861: NOP4
 865: PUSH
 866: FOR_IN
 867: IFFALSE 883
// SetLives ( i , 1000 ) ;
 869: NOP4
 873: PPUSH
 874: LD_INT 1000
 876: PPUSH
 877: NOP4
 881: GO 866
 883: POP
 884: POP
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) do
 885: NOP4
 889: PUSH
 890: LD_INT 22
 892: PUSH
 893: NOP4
 897: PUSH
 898: EMPTY
 899: LIST
 900: LIST
 901: PUSH
 902: LD_INT 21
 904: PUSH
 905: LD_INT 1
 907: PUSH
 908: EMPTY
 909: LIST
 910: LIST
 911: PUSH
 912: EMPTY
 913: LIST
 914: LIST
 915: PPUSH
 916: NOP4
 920: PUSH
 921: FOR_IN
 922: IFFALSE 986
// begin SetSkill ( i , skill_combat , 10 ) ;
 924: NOP4
 928: PPUSH
 929: LD_INT 1
 931: PPUSH
 932: LD_INT 10
 934: PPUSH
 935: NOP4
// SetSkill ( i , skill_engineering , 10 ) ;
 939: NOP4
 943: PPUSH
 944: LD_INT 2
 946: PPUSH
 947: LD_INT 10
 949: PPUSH
 950: NOP4
// SetSkill ( i , skill_mechanical , 10 ) ;
 954: NOP4
 958: PPUSH
 959: LD_INT 3
 961: PPUSH
 962: LD_INT 10
 964: PPUSH
 965: NOP4
// SetSkill ( i , skill_scientistic , 10 ) ;
 969: NOP4
 973: PPUSH
 974: LD_INT 4
 976: PPUSH
 977: LD_INT 10
 979: PPUSH
 980: NOP4
// end ;
 984: GO 921
 986: POP
 987: POP
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) do
 988: NOP4
 992: PUSH
 993: LD_INT 22
 995: PUSH
 996: NOP4
1000: PUSH
1001: EMPTY
1002: LIST
1003: LIST
1004: PUSH
1005: LD_INT 2
1007: PUSH
1008: LD_INT 30
1010: PUSH
1011: LD_INT 0
1013: PUSH
1014: EMPTY
1015: LIST
1016: LIST
1017: PUSH
1018: LD_INT 30
1020: PUSH
1021: LD_INT 1
1023: PUSH
1024: EMPTY
1025: LIST
1026: LIST
1027: PUSH
1028: EMPTY
1029: LIST
1030: LIST
1031: LIST
1032: PUSH
1033: EMPTY
1034: LIST
1035: LIST
1036: PPUSH
1037: NOP4
1041: PUSH
1042: FOR_IN
1043: IFFALSE 1107
// begin SetResourceType ( GetBase ( i ) , mat_cans , 9999 ) ;
1045: NOP4
1049: PPUSH
1050: NOP4
1054: PPUSH
1055: LD_INT 1
1057: PPUSH
1058: LD_INT 9999
1060: PPUSH
1061: NOP4
// SetResourceType ( GetBase ( i ) , mat_oil , 9999 ) ;
1065: NOP4
1069: PPUSH
1070: NOP4
1074: PPUSH
1075: LD_INT 2
1077: PPUSH
1078: LD_INT 9999
1080: PPUSH
1081: NOP4
// SetResourceType ( GetBase ( i ) , mat_siberit , 9999 ) ;
1085: NOP4
1089: PPUSH
1090: NOP4
1094: PPUSH
1095: LD_INT 3
1097: PPUSH
1098: LD_INT 9999
1100: PPUSH
1101: NOP4
// end ;
1105: GO 1042
1107: POP
1108: POP
// end ; end_of_file
1109: PPOPN 1
1111: END
// export Burlak , Gnyevko , Belkov , Kirilenkova ; export other_survivors ; export Kurin , Belkov2 , otherKirovUnits ; export Kovalyuk , randomMech ; export kirovVehicle ; export belkovTeam ; export removedBelkovUntisSaved ; export removedBelkovVehicleSaved ; export Platonov , platSoldiers ; export Kuklajs , Benko ; export function PrepareRussian ; begin
1112: LD_INT 0
1114: PPUSH
// PrepareCharactersFromPreviousMission ;
1115: NOP4
// PrepareKirovBase ;
1119: NOP4
// PrepareBeriaBase ;
1123: NOP4
// end ;
1127: LD_VAR 0 1
1131: RET
// export function PrepareBelkovReturnTeam ; var unit , others , tmp ; begin
1132: LD_INT 0
1134: PPUSH
1135: PPUSH
1136: PPUSH
1137: PPUSH
// belkovTeam = [ ] ;
1138: NOP4
1142: PUSH
1143: EMPTY
1144: ST_TO_ADDR
// uc_side = 6 ;
1145: LD_ADDR_OWVAR 20
1149: PUSH
1150: LD_INT 6
1152: ST_TO_ADDR
// uc_nation = nation_russian ;
1153: LD_ADDR_OWVAR 21
1157: PUSH
1158: LD_INT 3
1160: ST_TO_ADDR
// vc_chassis = removedBelkovVehicleSaved [ 1 ] ;
1161: LD_ADDR_OWVAR 37
1165: PUSH
1166: NOP4
1170: PUSH
1171: LD_INT 1
1173: ARRAY
1174: ST_TO_ADDR
// vc_engine = removedBelkovVehicleSaved [ 2 ] ;
1175: LD_ADDR_OWVAR 39
1179: PUSH
1180: NOP4
1184: PUSH
1185: LD_INT 2
1187: ARRAY
1188: ST_TO_ADDR
// vc_control = removedBelkovVehicleSaved [ 3 ] ;
1189: LD_ADDR_OWVAR 38
1193: PUSH
1194: NOP4
1198: PUSH
1199: LD_INT 3
1201: ARRAY
1202: ST_TO_ADDR
// vc_weapon = removedBelkovVehicleSaved [ 4 ] ;
1203: LD_ADDR_OWVAR 40
1207: PUSH
1208: NOP4
1212: PUSH
1213: LD_INT 4
1215: ARRAY
1216: ST_TO_ADDR
// vc_fuel_battery = removedBelkovVehicleSaved [ 5 ] ;
1217: LD_ADDR_OWVAR 41
1221: PUSH
1222: NOP4
1226: PUSH
1227: LD_INT 5
1229: ARRAY
1230: ST_TO_ADDR
// kirovVehicle = CreateVehicle ;
1231: NOP4
1235: PUSH
1236: NOP4
1240: ST_TO_ADDR
// SetDir ( kirovVehicle , 3 ) ;
1241: NOP4
1245: PPUSH
1246: LD_INT 3
1248: PPUSH
1249: NOP4
// PlaceUnitArea ( kirovVehicle , BelkovReturnArea , false ) ;
1253: NOP4
1257: PPUSH
1258: LD_INT 11
1260: PPUSH
1261: LD_INT 0
1263: PPUSH
1264: NOP4
// belkovTeam = belkovTeam ^ kirovVehicle ;
1268: NOP4
1272: PUSH
1273: NOP4
1277: PUSH
1278: NOP4
1282: ADD
1283: ST_TO_ADDR
// if TestCharacters ( 02_TmpBelkov ) then
1284: LD_STRING 02_TmpBelkov
1286: PPUSH
1287: NOP4
1291: IFFALSE 1336
// begin Belkov = CreateCharacter ( 02_TmpBelkov ) ;
1293: NOP4
1297: PUSH
1298: LD_STRING 02_TmpBelkov
1300: PPUSH
1301: NOP4
1305: ST_TO_ADDR
// PlaceHumanInUnit ( Belkov , kirovVehicle ) ;
1306: NOP4
1310: PPUSH
1311: NOP4
1315: PPUSH
1316: NOP4
// belkovTeam = belkovTeam ^ Belkov ;
1320: NOP4
1324: PUSH
1325: NOP4
1329: PUSH
1330: NOP4
1334: ADD
1335: ST_TO_ADDR
// end ; if TestCharacters ( 02_TmpBelkov2 ) then
1336: LD_STRING 02_TmpBelkov2
1338: PPUSH
1339: NOP4
1343: IFFALSE 1415
// begin Belkov2 = CreateCharacter ( 02_TmpBelkov2 ) ;
1345: NOP4
1349: PUSH
1350: LD_STRING 02_TmpBelkov2
1352: PPUSH
1353: NOP4
1357: ST_TO_ADDR
// if not TestCharacters ( 02_TmpBelkov ) then
1358: LD_STRING 02_TmpBelkov
1360: PPUSH
1361: NOP4
1365: NOT
1366: IFFALSE 1384
// PlaceHumanInUnit ( Belkov2 , kirovVehicle ) else
1368: NOP4
1372: PPUSH
1373: NOP4
1377: PPUSH
1378: NOP4
1382: GO 1399
// PlaceUnitArea ( Belkov2 , BelkovReturnArea , false ) ;
1384: NOP4
1388: PPUSH
1389: LD_INT 11
1391: PPUSH
1392: LD_INT 0
1394: PPUSH
1395: NOP4
// belkovTeam = belkovTeam ^ Belkov2 ;
1399: NOP4
1403: PUSH
1404: NOP4
1408: PUSH
1409: NOP4
1413: ADD
1414: ST_TO_ADDR
// end ; if TestCharacters ( 02_TmpKirilenkova ) then
1415: LD_STRING 02_TmpKirilenkova
1417: PPUSH
1418: NOP4
1422: IFFALSE 1468
// begin Kirilenkova = CreateCharacter ( 02_TmpKirilenkova ) ;
1424: NOP4
1428: PUSH
1429: LD_STRING 02_TmpKirilenkova
1431: PPUSH
1432: NOP4
1436: ST_TO_ADDR
// PlaceUnitArea ( Kirilenkova , BelkovReturnArea , false ) ;
1437: NOP4
1441: PPUSH
1442: LD_INT 11
1444: PPUSH
1445: LD_INT 0
1447: PPUSH
1448: NOP4
// belkovTeam = belkovTeam ^ Kirilenkova ;
1452: NOP4
1456: PUSH
1457: NOP4
1461: PUSH
1462: NOP4
1466: ADD
1467: ST_TO_ADDR
// end ; others = CreateCharacterSet ( 02_TmpBelkovTeam ) ;
1468: NOP4
1472: PUSH
1473: LD_STRING 02_TmpBelkovTeam
1475: PPUSH
1476: NOP4
1480: ST_TO_ADDR
// for unit in others do
1481: NOP4
1485: PUSH
1486: NOP4
1490: PUSH
1491: FOR_IN
1492: IFFALSE 1527
// begin PlaceUnitArea ( unit , BelkovReturnArea , false ) ;
1494: NOP4
1498: PPUSH
1499: LD_INT 11
1501: PPUSH
1502: LD_INT 0
1504: PPUSH
1505: NOP4
// belkovTeam = belkovTeam ^ unit ;
1509: NOP4
1513: PUSH
1514: NOP4
1518: PUSH
1519: NOP4
1523: ADD
1524: ST_TO_ADDR
// end ;
1525: GO 1491
1527: POP
1528: POP
// end ;
1529: LD_VAR 0 1
1533: RET
// function PrepareCharactersFromPreviousMission ; var i ; begin
1534: LD_INT 0
1536: PPUSH
1537: PPUSH
// uc_side = 3 ;
1538: LD_ADDR_OWVAR 20
1542: PUSH
1543: LD_INT 3
1545: ST_TO_ADDR
// Burlak = PrepareUnit ( Burlak , true ) ;
1546: NOP4
1550: PUSH
1551: LD_STRING Burlak
1553: PPUSH
1554: LD_INT 1
1556: PPUSH
1557: NOP4
1561: ST_TO_ADDR
// Gnyevko = PrepareUnit ( Gnyevko , true ) ;
1562: NOP4
1566: PUSH
1567: LD_STRING Gnyevko
1569: PPUSH
1570: LD_INT 1
1572: PPUSH
1573: NOP4
1577: ST_TO_ADDR
// Belkov = PrepareUnit ( Belkov , true ) ;
1578: NOP4
1582: PUSH
1583: LD_STRING Belkov
1585: PPUSH
1586: LD_INT 1
1588: PPUSH
1589: NOP4
1593: ST_TO_ADDR
// Kirilenkova = PrepareUnit ( Kirilenkova , true ) ;
1594: NOP4
1598: PUSH
1599: LD_STRING Kirilenkova
1601: PPUSH
1602: LD_INT 1
1604: PPUSH
1605: NOP4
1609: ST_TO_ADDR
// PlaceUnitArea ( Burlak , BurlakSpawnArea , false ) ;
1610: NOP4
1614: PPUSH
1615: LD_INT 5
1617: PPUSH
1618: LD_INT 0
1620: PPUSH
1621: NOP4
// PlaceUnitArea ( Gnyevko , BurlakTeamSpawnArea , false ) ;
1625: NOP4
1629: PPUSH
1630: LD_INT 3
1632: PPUSH
1633: LD_INT 0
1635: PPUSH
1636: NOP4
// PlaceUnitArea ( Belkov , BurlakTeamSpawnArea , false ) ;
1640: NOP4
1644: PPUSH
1645: LD_INT 3
1647: PPUSH
1648: LD_INT 0
1650: PPUSH
1651: NOP4
// PlaceUnitArea ( Kirilenkova , BurlakTeamSpawnArea , false ) ;
1655: NOP4
1659: PPUSH
1660: LD_INT 3
1662: PPUSH
1663: LD_INT 0
1665: PPUSH
1666: NOP4
// CenterNowOnUnits ( Burlak ) ;
1670: NOP4
1674: PPUSH
1675: NOP4
// other_survivors = CreateCharacterSet ( 01_other_survivors ) ;
1679: NOP4
1683: PUSH
1684: LD_STRING 01_other_survivors
1686: PPUSH
1687: NOP4
1691: ST_TO_ADDR
// for i in other_survivors do
1692: NOP4
1696: PUSH
1697: NOP4
1701: PUSH
1702: FOR_IN
1703: IFFALSE 1722
// PlaceUnitArea ( i , BurlakTeamSpawnArea , false ) ;
1705: NOP4
1709: PPUSH
1710: LD_INT 3
1712: PPUSH
1713: LD_INT 0
1715: PPUSH
1716: NOP4
1720: GO 1702
1722: POP
1723: POP
// end ;
1724: LD_VAR 0 1
1728: RET
// function PrepareKirovBase ; var i , un ; begin
1729: LD_INT 0
1731: PPUSH
1732: PPUSH
1733: PPUSH
// SetBName ( kirov , kirov ) ;
1734: LD_INT 71
1736: PPUSH
1737: LD_STRING kirov
1739: PPUSH
1740: NOP4
// uc_side = 6 ;
1744: LD_ADDR_OWVAR 20
1748: PUSH
1749: LD_INT 6
1751: ST_TO_ADDR
// uc_nation = 3 ;
1752: LD_ADDR_OWVAR 21
1756: PUSH
1757: LD_INT 3
1759: ST_TO_ADDR
// hc_gallery =  ;
1760: LD_ADDR_OWVAR 33
1764: PUSH
1765: LD_STRING 
1767: ST_TO_ADDR
// hc_name =  ;
1768: LD_ADDR_OWVAR 26
1772: PUSH
1773: LD_STRING 
1775: ST_TO_ADDR
// Kurin = PrepareUnit ( Kurin , false ) ;
1776: NOP4
1780: PUSH
1781: LD_STRING Kurin
1783: PPUSH
1784: LD_INT 0
1786: PPUSH
1787: NOP4
1791: ST_TO_ADDR
// Kovalyuk = PrepareUnit ( Kovalyuk , false ) ;
1792: NOP4
1796: PUSH
1797: LD_STRING Kovalyuk
1799: PPUSH
1800: LD_INT 0
1802: PPUSH
1803: NOP4
1807: ST_TO_ADDR
// Belkov2 = PrepareUnit ( Belkov2 , false ) ;
1808: NOP4
1812: PUSH
1813: LD_STRING Belkov2
1815: PPUSH
1816: LD_INT 0
1818: PPUSH
1819: NOP4
1823: ST_TO_ADDR
// PlaceUnitArea ( Kurin , KurinSpawnArea , false ) ;
1824: NOP4
1828: PPUSH
1829: LD_INT 4
1831: PPUSH
1832: LD_INT 0
1834: PPUSH
1835: NOP4
// PlaceUnitXYR ( Kovalyuk , 161 , 108 , 6 , false ) ;
1839: NOP4
1843: PPUSH
1844: LD_INT 161
1846: PPUSH
1847: LD_INT 108
1849: PPUSH
1850: LD_INT 6
1852: PPUSH
1853: LD_INT 0
1855: PPUSH
1856: NOP4
// ComHold ( Kurin ) ;
1860: NOP4
1864: PPUSH
1865: NOP4
// otherKirovUnits = [ ] ;
1869: NOP4
1873: PUSH
1874: EMPTY
1875: ST_TO_ADDR
// kirovAmountPeople = Replace ( kirovAmountPeople , 1 , kirovAmountPeople [ 1 ] - UnitFilter ( other_survivors , [ f_class , class_soldier ] ) ) ;
1876: NOP4
1880: PUSH
1881: NOP4
1885: PPUSH
1886: LD_INT 1
1888: PPUSH
1889: NOP4
1893: PUSH
1894: LD_INT 1
1896: ARRAY
1897: PUSH
1898: NOP4
1902: PPUSH
1903: LD_INT 25
1905: PUSH
1906: LD_INT 1
1908: PUSH
1909: EMPTY
1910: LIST
1911: LIST
1912: PPUSH
1913: NOP4
1917: MINUS
1918: PPUSH
1919: NOP4
1923: ST_TO_ADDR
// for i := 1 to kirovAmountPeople [ 1 ] do
1924: NOP4
1928: PUSH
1929: DOUBLE
1930: LD_INT 1
1932: DEC
1933: ST_TO_ADDR
1934: NOP4
1938: PUSH
1939: LD_INT 1
1941: ARRAY
1942: PUSH
1943: FOR_TO
1944: IFFALSE 2123
// begin PrepareHuman ( false , 1 , rand ( 1 , 3 ) ) ;
1946: LD_INT 0
1948: PPUSH
1949: LD_INT 1
1951: PPUSH
1952: LD_INT 1
1954: PPUSH
1955: LD_INT 3
1957: PPUSH
1958: NOP4
1962: PPUSH
1963: NOP4
// un = CreateHuman ;
1967: NOP4
1971: PUSH
1972: NOP4
1976: ST_TO_ADDR
// otherKirovUnits = otherKirovUnits ^ un ;
1977: NOP4
1981: PUSH
1982: NOP4
1986: PUSH
1987: NOP4
1991: ADD
1992: ST_TO_ADDR
// if FilterUnitsInArea ( KirovBaseArea , [ [ f_side , 6 ] , [ f_type , unit_building ] , [ f_btype , b_breastwork ] , [ f_empty ] ] ) then
1993: LD_INT 9
1995: PPUSH
1996: LD_INT 22
1998: PUSH
1999: LD_INT 6
2001: PUSH
2002: EMPTY
2003: LIST
2004: LIST
2005: PUSH
2006: LD_INT 21
2008: PUSH
2009: LD_INT 3
2011: PUSH
2012: EMPTY
2013: LIST
2014: LIST
2015: PUSH
2016: LD_INT 30
2018: PUSH
2019: LD_INT 31
2021: PUSH
2022: EMPTY
2023: LIST
2024: LIST
2025: PUSH
2026: LD_INT 58
2028: PUSH
2029: EMPTY
2030: LIST
2031: PUSH
2032: EMPTY
2033: LIST
2034: LIST
2035: LIST
2036: LIST
2037: PPUSH
2038: NOP4
2042: IFFALSE 2109
// PlaceSolBun ( un , FilterUnitsInArea ( KirovBaseArea , [ [ f_side , 6 ] , [ f_type , unit_building ] , [ f_btype , b_breastwork ] , [ f_empty ] ] ) [ 1 ] ) else
2044: NOP4
2048: PPUSH
2049: LD_INT 9
2051: PPUSH
2052: LD_INT 22
2054: PUSH
2055: LD_INT 6
2057: PUSH
2058: EMPTY
2059: LIST
2060: LIST
2061: PUSH
2062: LD_INT 21
2064: PUSH
2065: LD_INT 3
2067: PUSH
2068: EMPTY
2069: LIST
2070: LIST
2071: PUSH
2072: LD_INT 30
2074: PUSH
2075: LD_INT 31
2077: PUSH
2078: EMPTY
2079: LIST
2080: LIST
2081: PUSH
2082: LD_INT 58
2084: PUSH
2085: EMPTY
2086: LIST
2087: PUSH
2088: EMPTY
2089: LIST
2090: LIST
2091: LIST
2092: LIST
2093: PPUSH
2094: NOP4
2098: PUSH
2099: LD_INT 1
2101: ARRAY
2102: PPUSH
2103: NOP4
2107: GO 2121
// PlaceHumanInUnit ( un , ru2_arm2 ) ;
2109: NOP4
2113: PPUSH
2114: LD_INT 209
2116: PPUSH
2117: NOP4
// end ;
2121: GO 1943
2123: POP
2124: POP
// PrepareHuman ( false , 1 , rand ( 1 , 3 ) ) ;
2125: LD_INT 0
2127: PPUSH
2128: LD_INT 1
2130: PPUSH
2131: LD_INT 1
2133: PPUSH
2134: LD_INT 3
2136: PPUSH
2137: NOP4
2141: PPUSH
2142: NOP4
// PlaceHumanInUnit ( CreateHuman , ru2_arm2 ) ;
2146: NOP4
2150: PPUSH
2151: LD_INT 209
2153: PPUSH
2154: NOP4
// for i := 1 to kirovAmountPeople [ 2 ] do
2158: NOP4
2162: PUSH
2163: DOUBLE
2164: LD_INT 1
2166: DEC
2167: ST_TO_ADDR
2168: NOP4
2172: PUSH
2173: LD_INT 2
2175: ARRAY
2176: PUSH
2177: FOR_TO
2178: IFFALSE 2241
// begin PrepareHuman ( false , 2 , rand ( 1 , 3 ) ) ;
2180: LD_INT 0
2182: PPUSH
2183: LD_INT 2
2185: PPUSH
2186: LD_INT 1
2188: PPUSH
2189: LD_INT 3
2191: PPUSH
2192: NOP4
2196: PPUSH
2197: NOP4
// un = CreateHuman ;
2201: NOP4
2205: PUSH
2206: NOP4
2210: ST_TO_ADDR
// otherKirovUnits = otherKirovUnits ^ un ;
2211: NOP4
2215: PUSH
2216: NOP4
2220: PUSH
2221: NOP4
2225: ADD
2226: ST_TO_ADDR
// PlaceHumanInUnit ( un , kirov ) ;
2227: NOP4
2231: PPUSH
2232: LD_INT 71
2234: PPUSH
2235: NOP4
// end ;
2239: GO 2177
2241: POP
2242: POP
// for i := 1 to kirovAmountPeople [ 3 ] do
2243: NOP4
2247: PUSH
2248: DOUBLE
2249: LD_INT 1
2251: DEC
2252: ST_TO_ADDR
2253: NOP4
2257: PUSH
2258: LD_INT 3
2260: ARRAY
2261: PUSH
2262: FOR_TO
2263: IFFALSE 2326
// begin PrepareHuman ( false , 3 , rand ( 1 , 3 ) ) ;
2265: LD_INT 0
2267: PPUSH
2268: LD_INT 3
2270: PPUSH
2271: LD_INT 1
2273: PPUSH
2274: LD_INT 3
2276: PPUSH
2277: NOP4
2281: PPUSH
2282: NOP4
// un = CreateHuman ;
2286: NOP4
2290: PUSH
2291: NOP4
2295: ST_TO_ADDR
// otherKirovUnits = otherKirovUnits ^ un ;
2296: NOP4
2300: PUSH
2301: NOP4
2305: PUSH
2306: NOP4
2310: ADD
2311: ST_TO_ADDR
// PlaceHumanInUnit ( un , kirov ) ;
2312: NOP4
2316: PPUSH
2317: LD_INT 71
2319: PPUSH
2320: NOP4
// end ;
2324: GO 2262
2326: POP
2327: POP
// for i := 1 to kirovAmountPeople [ 4 ] do
2328: NOP4
2332: PUSH
2333: DOUBLE
2334: LD_INT 1
2336: DEC
2337: ST_TO_ADDR
2338: NOP4
2342: PUSH
2343: LD_INT 4
2345: ARRAY
2346: PUSH
2347: FOR_TO
2348: IFFALSE 2411
// begin PrepareHuman ( false , 4 , rand ( 1 , 3 ) ) ;
2350: LD_INT 0
2352: PPUSH
2353: LD_INT 4
2355: PPUSH
2356: LD_INT 1
2358: PPUSH
2359: LD_INT 3
2361: PPUSH
2362: NOP4
2366: PPUSH
2367: NOP4
// un = CreateHuman ;
2371: NOP4
2375: PUSH
2376: NOP4
2380: ST_TO_ADDR
// otherKirovUnits = otherKirovUnits ^ un ;
2381: NOP4
2385: PUSH
2386: NOP4
2390: PUSH
2391: NOP4
2395: ADD
2396: ST_TO_ADDR
// PlaceHumanInUnit ( un , ru_lab ) ;
2397: NOP4
2401: PPUSH
2402: LD_INT 83
2404: PPUSH
2405: NOP4
// end ;
2409: GO 2347
2411: POP
2412: POP
// ResAllTechs ( 6 , ru_lab , 3 ) ;
2413: LD_INT 6
2415: PPUSH
2416: LD_INT 83
2418: PPUSH
2419: LD_INT 3
2421: PPUSH
2422: NOP4
// if not TestCharacters ( 01_Gnyevko ) then
2426: LD_STRING 01_Gnyevko
2428: PPUSH
2429: NOP4
2433: NOT
2434: IFFALSE 2477
// begin PrepareMechanic ( sex_male , 3 ) ;
2436: LD_INT 1
2438: PPUSH
2439: LD_INT 3
2441: PPUSH
2442: NOP4
// randomMech = CreateHuman ;
2446: NOP4
2450: PUSH
2451: NOP4
2455: ST_TO_ADDR
// PlaceUnitXYR ( randomMech , 161 , 108 , 6 , false ) ;
2456: NOP4
2460: PPUSH
2461: LD_INT 161
2463: PPUSH
2464: LD_INT 108
2466: PPUSH
2467: LD_INT 6
2469: PPUSH
2470: LD_INT 0
2472: PPUSH
2473: NOP4
// end ; PlaceHumanInUnit ( Belkov2 , ru2_arm1 ) ;
2477: NOP4
2481: PPUSH
2482: LD_INT 95
2484: PPUSH
2485: NOP4
// end ;
2489: LD_VAR 0 1
2493: RET
// function PrepareBeriaBase ; var i , un , unitsTemp , bunker ; begin
2494: LD_INT 0
2496: PPUSH
2497: PPUSH
2498: PPUSH
2499: PPUSH
2500: PPUSH
// SetBName ( beria , beria ) ;
2501: LD_INT 106
2503: PPUSH
2504: LD_STRING beria
2506: PPUSH
2507: NOP4
// uc_side = 6 ;
2511: LD_ADDR_OWVAR 20
2515: PUSH
2516: LD_INT 6
2518: ST_TO_ADDR
// uc_nation = 3 ;
2519: LD_ADDR_OWVAR 21
2523: PUSH
2524: LD_INT 3
2526: ST_TO_ADDR
// Platonov = PrepareUnit ( Platonov , false ) ;
2527: NOP4
2531: PUSH
2532: LD_STRING Platonov
2534: PPUSH
2535: LD_INT 0
2537: PPUSH
2538: NOP4
2542: ST_TO_ADDR
// PlaceUnitXY ( Platonov , 112 , 97 , false ) ;
2543: NOP4
2547: PPUSH
2548: LD_INT 112
2550: PPUSH
2551: LD_INT 97
2553: PPUSH
2554: LD_INT 0
2556: PPUSH
2557: NOP4
// ComHold ( Platonov ) ;
2561: NOP4
2565: PPUSH
2566: NOP4
// platSoldiers = [ ] ;
2570: NOP4
2574: PUSH
2575: EMPTY
2576: ST_TO_ADDR
// unitsTemp = [ ] ;
2577: NOP4
2581: PUSH
2582: EMPTY
2583: ST_TO_ADDR
// Kuklajs = PrepareUnit ( Kuklajs , false ) ;
2584: NOP4
2588: PUSH
2589: LD_STRING Kuklajs
2591: PPUSH
2592: LD_INT 0
2594: PPUSH
2595: NOP4
2599: ST_TO_ADDR
// platSoldiers = platSoldiers ^ Kuklajs ;
2600: NOP4
2604: PUSH
2605: NOP4
2609: PUSH
2610: NOP4
2614: ADD
2615: ST_TO_ADDR
// PlaceUnitXYR ( Kuklajs , 110 , 97 , 6 , false ) ;
2616: NOP4
2620: PPUSH
2621: LD_INT 110
2623: PPUSH
2624: LD_INT 97
2626: PPUSH
2627: LD_INT 6
2629: PPUSH
2630: LD_INT 0
2632: PPUSH
2633: NOP4
// Benko = PrepareUnit ( Benko , false ) ;
2637: NOP4
2641: PUSH
2642: LD_STRING Benko
2644: PPUSH
2645: LD_INT 0
2647: PPUSH
2648: NOP4
2652: ST_TO_ADDR
// platSoldiers = platSoldiers ^ Benko ;
2653: NOP4
2657: PUSH
2658: NOP4
2662: PUSH
2663: NOP4
2667: ADD
2668: ST_TO_ADDR
// unitsTemp = unitsTemp ^ Benko ;
2669: NOP4
2673: PUSH
2674: NOP4
2678: PUSH
2679: NOP4
2683: ADD
2684: ST_TO_ADDR
// for i := 1 to 2 do
2685: NOP4
2689: PUSH
2690: DOUBLE
2691: LD_INT 1
2693: DEC
2694: ST_TO_ADDR
2695: LD_INT 2
2697: PUSH
2698: FOR_TO
2699: IFFALSE 2766
// begin PrepareHuman ( false , 1 , rand ( 1 , 3 ) ) ;
2701: LD_INT 0
2703: PPUSH
2704: LD_INT 1
2706: PPUSH
2707: LD_INT 1
2709: PPUSH
2710: LD_INT 3
2712: PPUSH
2713: NOP4
2717: PPUSH
2718: NOP4
// un = CreateHuman ;
2722: NOP4
2726: PUSH
2727: NOP4
2731: ST_TO_ADDR
// platSoldiers = platSoldiers ^ un ;
2732: NOP4
2736: PUSH
2737: NOP4
2741: PUSH
2742: NOP4
2746: ADD
2747: ST_TO_ADDR
// unitsTemp = unitsTemp ^ un ;
2748: NOP4
2752: PUSH
2753: NOP4
2757: PUSH
2758: NOP4
2762: ADD
2763: ST_TO_ADDR
// end ;
2764: GO 2698
2766: POP
2767: POP
// for i := 1 to unitsTemp do
2768: NOP4
2772: PUSH
2773: DOUBLE
2774: LD_INT 1
2776: DEC
2777: ST_TO_ADDR
2778: NOP4
2782: PUSH
2783: FOR_TO
2784: IFFALSE 2872
// begin bunker = FilterUnitsInArea ( BeriaBaseArea , [ [ f_side , 6 ] , [ f_btype , b_breastwork ] ] ) [ i ] ;
2786: NOP4
2790: PUSH
2791: LD_INT 8
2793: PPUSH
2794: LD_INT 22
2796: PUSH
2797: LD_INT 6
2799: PUSH
2800: EMPTY
2801: LIST
2802: LIST
2803: PUSH
2804: LD_INT 30
2806: PUSH
2807: LD_INT 31
2809: PUSH
2810: EMPTY
2811: LIST
2812: LIST
2813: PUSH
2814: EMPTY
2815: LIST
2816: LIST
2817: PPUSH
2818: NOP4
2822: PUSH
2823: NOP4
2827: ARRAY
2828: ST_TO_ADDR
// PlaceUnitXYR ( unitsTemp [ i ] , GetX ( bunker ) , GetY ( bunker ) , 2 , false ) ;
2829: NOP4
2833: PUSH
2834: NOP4
2838: ARRAY
2839: PPUSH
2840: NOP4
2844: PPUSH
2845: NOP4
2849: PPUSH
2850: NOP4
2854: PPUSH
2855: NOP4
2859: PPUSH
2860: LD_INT 2
2862: PPUSH
2863: LD_INT 0
2865: PPUSH
2866: NOP4
// end ;
2870: GO 2783
2872: POP
2873: POP
// end ; end_of_file
2874: LD_VAR 0 1
2878: RET
// export trapCommander ; export trapTeam ; export leftBunkers , rightBunkers ; export amLeftDepot , amRightDepot ; export amLeftEngs , amRightEngs ; export amVeh , amMech ; export function PrepareAmerican ; begin
2879: LD_INT 0
2881: PPUSH
// PrepareTrap ;
2882: NOP4
// PrepareBunkiers ;
2886: NOP4
// end ;
2890: LD_VAR 0 1
2894: RET
// function PrepareTrap ; var i , un ; begin
2895: LD_INT 0
2897: PPUSH
2898: PPUSH
2899: PPUSH
// trapTeam = [ ] ;
2900: NOP4
2904: PUSH
2905: EMPTY
2906: ST_TO_ADDR
// uc_nation = 1 ;
2907: LD_ADDR_OWVAR 21
2911: PUSH
2912: LD_INT 1
2914: ST_TO_ADDR
// uc_side = 1 ;
2915: LD_ADDR_OWVAR 20
2919: PUSH
2920: LD_INT 1
2922: ST_TO_ADDR
// hc_gallery =  ;
2923: LD_ADDR_OWVAR 33
2927: PUSH
2928: LD_STRING 
2930: ST_TO_ADDR
// hc_name =  ;
2931: LD_ADDR_OWVAR 26
2935: PUSH
2936: LD_STRING 
2938: ST_TO_ADDR
// hc_importance = 100 ;
2939: LD_ADDR_OWVAR 32
2943: PUSH
2944: LD_INT 100
2946: ST_TO_ADDR
// PrepareHuman ( sex_male , 1 , enemySkillLevel + 1 ) ;
2947: LD_INT 1
2949: PPUSH
2950: LD_INT 1
2952: PPUSH
2953: NOP4
2957: PUSH
2958: LD_INT 1
2960: PLUS
2961: PPUSH
2962: NOP4
// trapCommander = CreateHuman ;
2966: NOP4
2970: PUSH
2971: NOP4
2975: ST_TO_ADDR
// PlaceUnitArea ( trapCommander , AmCommanderSpawn , false ) ;
2976: NOP4
2980: PPUSH
2981: LD_INT 13
2983: PPUSH
2984: LD_INT 0
2986: PPUSH
2987: NOP4
// ComCrawl ( trapCommander ) ;
2991: NOP4
2995: PPUSH
2996: NOP4
// trapTeam = trapTeam ^ trapCommander ;
3000: NOP4
3004: PUSH
3005: NOP4
3009: PUSH
3010: NOP4
3014: ADD
3015: ST_TO_ADDR
// hc_importance = 0 ;
3016: LD_ADDR_OWVAR 32
3020: PUSH
3021: LD_INT 0
3023: ST_TO_ADDR
// for i := 1 to trapAmountPeople [ 1 ] do
3024: NOP4
3028: PUSH
3029: DOUBLE
3030: LD_INT 1
3032: DEC
3033: ST_TO_ADDR
3034: NOP4
3038: PUSH
3039: LD_INT 1
3041: ARRAY
3042: PUSH
3043: FOR_TO
3044: IFFALSE 3136
// begin hc_name =  ;
3046: LD_ADDR_OWVAR 26
3050: PUSH
3051: LD_STRING 
3053: ST_TO_ADDR
// PrepareHuman ( false , 1 , enemySkillLevel ) ;
3054: LD_INT 0
3056: PPUSH
3057: LD_INT 1
3059: PPUSH
3060: NOP4
3064: PPUSH
3065: NOP4
// un = CreateHuman ;
3069: NOP4
3073: PUSH
3074: NOP4
3078: ST_TO_ADDR
// PlaceUnitArea ( un , AmTrapSpawn1 , false ) ;
3079: NOP4
3083: PPUSH
3084: LD_INT 12
3086: PPUSH
3087: LD_INT 0
3089: PPUSH
3090: NOP4
// ComCrawl ( un ) ;
3094: NOP4
3098: PPUSH
3099: NOP4
// AddComTurnXY ( un , 116 , 21 ) ;
3103: NOP4
3107: PPUSH
3108: LD_INT 116
3110: PPUSH
3111: LD_INT 21
3113: PPUSH
3114: NOP4
// trapTeam = trapTeam ^ un ;
3118: NOP4
3122: PUSH
3123: NOP4
3127: PUSH
3128: NOP4
3132: ADD
3133: ST_TO_ADDR
// end ;
3134: GO 3043
3136: POP
3137: POP
// for i := 1 to trapAmountPeople [ 2 ] do
3138: NOP4
3142: PUSH
3143: DOUBLE
3144: LD_INT 1
3146: DEC
3147: ST_TO_ADDR
3148: NOP4
3152: PUSH
3153: LD_INT 2
3155: ARRAY
3156: PUSH
3157: FOR_TO
3158: IFFALSE 3250
// begin hc_name =  ;
3160: LD_ADDR_OWVAR 26
3164: PUSH
3165: LD_STRING 
3167: ST_TO_ADDR
// PrepareHuman ( false , 1 , enemySkillLevel ) ;
3168: LD_INT 0
3170: PPUSH
3171: LD_INT 1
3173: PPUSH
3174: NOP4
3178: PPUSH
3179: NOP4
// un = CreateHuman ;
3183: NOP4
3187: PUSH
3188: NOP4
3192: ST_TO_ADDR
// PlaceUnitArea ( un , AmTrapSpawn2 , false ) ;
3193: NOP4
3197: PPUSH
3198: LD_INT 14
3200: PPUSH
3201: LD_INT 0
3203: PPUSH
3204: NOP4
// ComCrawl ( un ) ;
3208: NOP4
3212: PPUSH
3213: NOP4
// AddComTurnXY ( un , 116 , 21 ) ;
3217: NOP4
3221: PPUSH
3222: LD_INT 116
3224: PPUSH
3225: LD_INT 21
3227: PPUSH
3228: NOP4
// trapTeam = trapTeam ^ un ;
3232: NOP4
3236: PUSH
3237: NOP4
3241: PUSH
3242: NOP4
3246: ADD
3247: ST_TO_ADDR
// end ;
3248: GO 3157
3250: POP
3251: POP
// for i := 1 to trapAmountPeople [ 3 ] do
3252: NOP4
3256: PUSH
3257: DOUBLE
3258: LD_INT 1
3260: DEC
3261: ST_TO_ADDR
3262: NOP4
3266: PUSH
3267: LD_INT 3
3269: ARRAY
3270: PUSH
3271: FOR_TO
3272: IFFALSE 3364
// begin hc_name =  ;
3274: LD_ADDR_OWVAR 26
3278: PUSH
3279: LD_STRING 
3281: ST_TO_ADDR
// PrepareHuman ( false , 1 , enemySkillLevel ) ;
3282: LD_INT 0
3284: PPUSH
3285: LD_INT 1
3287: PPUSH
3288: NOP4
3292: PPUSH
3293: NOP4
// un = CreateHuman ;
3297: NOP4
3301: PUSH
3302: NOP4
3306: ST_TO_ADDR
// PlaceUnitArea ( un , AmTrapSpawn3 , false ) ;
3307: NOP4
3311: PPUSH
3312: LD_INT 23
3314: PPUSH
3315: LD_INT 0
3317: PPUSH
3318: NOP4
// ComCrawl ( un ) ;
3322: NOP4
3326: PPUSH
3327: NOP4
// AddComTurnXY ( un , 109 , 8 ) ;
3331: NOP4
3335: PPUSH
3336: LD_INT 109
3338: PPUSH
3339: LD_INT 8
3341: PPUSH
3342: NOP4
// trapTeam = trapTeam ^ un ;
3346: NOP4
3350: PUSH
3351: NOP4
3355: PUSH
3356: NOP4
3360: ADD
3361: ST_TO_ADDR
// end ;
3362: GO 3271
3364: POP
3365: POP
// for i := 1 to trapAmountPeople [ 4 ] do
3366: NOP4
3370: PUSH
3371: DOUBLE
3372: LD_INT 1
3374: DEC
3375: ST_TO_ADDR
3376: NOP4
3380: PUSH
3381: LD_INT 4
3383: ARRAY
3384: PUSH
3385: FOR_TO
3386: IFFALSE 3478
// begin hc_name =  ;
3388: LD_ADDR_OWVAR 26
3392: PUSH
3393: LD_STRING 
3395: ST_TO_ADDR
// PrepareHuman ( false , 1 , enemySkillLevel ) ;
3396: LD_INT 0
3398: PPUSH
3399: LD_INT 1
3401: PPUSH
3402: NOP4
3406: PPUSH
3407: NOP4
// un = CreateHuman ;
3411: NOP4
3415: PUSH
3416: NOP4
3420: ST_TO_ADDR
// PlaceUnitArea ( un , AmTrapSpawn4 , false ) ;
3421: NOP4
3425: PPUSH
3426: LD_INT 24
3428: PPUSH
3429: LD_INT 0
3431: PPUSH
3432: NOP4
// ComCrawl ( un ) ;
3436: NOP4
3440: PPUSH
3441: NOP4
// AddComTurnXY ( un , 109 , 8 ) ;
3445: NOP4
3449: PPUSH
3450: LD_INT 109
3452: PPUSH
3453: LD_INT 8
3455: PPUSH
3456: NOP4
// trapTeam = trapTeam ^ un ;
3460: NOP4
3464: PUSH
3465: NOP4
3469: PUSH
3470: NOP4
3474: ADD
3475: ST_TO_ADDR
// end ;
3476: GO 3385
3478: POP
3479: POP
// end ;
3480: LD_VAR 0 1
3484: RET
// function PrepareBunkiers ; var i , un , bunker ; begin
3485: LD_INT 0
3487: PPUSH
3488: PPUSH
3489: PPUSH
3490: PPUSH
// uc_side = 1 ;
3491: LD_ADDR_OWVAR 20
3495: PUSH
3496: LD_INT 1
3498: ST_TO_ADDR
// uc_nation = nation_american ;
3499: LD_ADDR_OWVAR 21
3503: PUSH
3504: LD_INT 1
3506: ST_TO_ADDR
// bc_level = 1 ;
3507: LD_ADDR_OWVAR 43
3511: PUSH
3512: LD_INT 1
3514: ST_TO_ADDR
// bc_type = b_breastwork ;
3515: LD_ADDR_OWVAR 42
3519: PUSH
3520: LD_INT 31
3522: ST_TO_ADDR
// bunker = CreateAndPlaceBuildingXYD ( 104 , 59 , 4 ) ;
3523: NOP4
3527: PUSH
3528: LD_INT 104
3530: PPUSH
3531: LD_INT 59
3533: PPUSH
3534: LD_INT 4
3536: PPUSH
3537: NOP4
3541: ST_TO_ADDR
// leftBunkers = leftBunkers ^ bunker ;
3542: NOP4
3546: PUSH
3547: NOP4
3551: PUSH
3552: NOP4
3556: ADD
3557: ST_TO_ADDR
// PrepareSolBun ( enemySkillLevel , bunker ) ;
3558: NOP4
3562: PPUSH
3563: NOP4
3567: PPUSH
3568: NOP4
// bunker = CreateAndPlaceBuildingXYD ( 101 , 55 , 4 ) ;
3572: NOP4
3576: PUSH
3577: LD_INT 101
3579: PPUSH
3580: LD_INT 55
3582: PPUSH
3583: LD_INT 4
3585: PPUSH
3586: NOP4
3590: ST_TO_ADDR
// leftBunkers = leftBunkers ^ bunker ;
3591: NOP4
3595: PUSH
3596: NOP4
3600: PUSH
3601: NOP4
3605: ADD
3606: ST_TO_ADDR
// PrepareSolBun ( enemySkillLevel , bunker ) ;
3607: NOP4
3611: PPUSH
3612: NOP4
3616: PPUSH
3617: NOP4
// bunker = CreateAndPlaceBuildingXYD ( 132 , 62 , 1 ) ;
3621: NOP4
3625: PUSH
3626: LD_INT 132
3628: PPUSH
3629: LD_INT 62
3631: PPUSH
3632: LD_INT 1
3634: PPUSH
3635: NOP4
3639: ST_TO_ADDR
// rightBunkers = rightBunkers ^ bunker ;
3640: NOP4
3644: PUSH
3645: NOP4
3649: PUSH
3650: NOP4
3654: ADD
3655: ST_TO_ADDR
// PrepareSolBun ( enemySkillLevel , bunker ) ;
3656: NOP4
3660: PPUSH
3661: NOP4
3665: PPUSH
3666: NOP4
// bunker = CreateAndPlaceBuildingXYD ( 134 , 66 , 1 ) ;
3670: NOP4
3674: PUSH
3675: LD_INT 134
3677: PPUSH
3678: LD_INT 66
3680: PPUSH
3681: LD_INT 1
3683: PPUSH
3684: NOP4
3688: ST_TO_ADDR
// rightBunkers = rightBunkers ^ bunker ;
3689: NOP4
3693: PUSH
3694: NOP4
3698: PUSH
3699: NOP4
3703: ADD
3704: ST_TO_ADDR
// PrepareSolBun ( enemySkillLevel , bunker ) ;
3705: NOP4
3709: PPUSH
3710: NOP4
3714: PPUSH
3715: NOP4
// bc_type = b_depot ;
3719: LD_ADDR_OWVAR 42
3723: PUSH
3724: LD_INT 0
3726: ST_TO_ADDR
// amLeftDepot = CreateAndPlaceBuildingXYD ( 92 , 51 , 2 ) ;
3727: NOP4
3731: PUSH
3732: LD_INT 92
3734: PPUSH
3735: LD_INT 51
3737: PPUSH
3738: LD_INT 2
3740: PPUSH
3741: NOP4
3745: ST_TO_ADDR
// amRightDepot = am_dep1 ;
3746: NOP4
3750: PUSH
3751: LD_INT 193
3753: ST_TO_ADDR
// amLeftEngs = [ ] ;
3754: NOP4
3758: PUSH
3759: EMPTY
3760: ST_TO_ADDR
// for i := 1 to [ 1 , 1 , rand ( 1 , 2 ) ] [ Difficulty ] do
3761: NOP4
3765: PUSH
3766: DOUBLE
3767: LD_INT 1
3769: DEC
3770: ST_TO_ADDR
3771: LD_INT 1
3773: PUSH
3774: LD_INT 1
3776: PUSH
3777: LD_INT 1
3779: PPUSH
3780: LD_INT 2
3782: PPUSH
3783: NOP4
3787: PUSH
3788: EMPTY
3789: LIST
3790: LIST
3791: LIST
3792: PUSH
3793: NOP4
3797: ARRAY
3798: PUSH
3799: FOR_TO
3800: IFFALSE 3891
// begin uc_nation = 1 ;
3802: LD_ADDR_OWVAR 21
3806: PUSH
3807: LD_INT 1
3809: ST_TO_ADDR
// uc_side = 1 ;
3810: LD_ADDR_OWVAR 20
3814: PUSH
3815: LD_INT 1
3817: ST_TO_ADDR
// hc_gallery =  ;
3818: LD_ADDR_OWVAR 33
3822: PUSH
3823: LD_STRING 
3825: ST_TO_ADDR
// hc_name =  ;
3826: LD_ADDR_OWVAR 26
3830: PUSH
3831: LD_STRING 
3833: ST_TO_ADDR
// PrepareHuman ( false , 2 , enemySkillLevel ) ;
3834: LD_INT 0
3836: PPUSH
3837: LD_INT 2
3839: PPUSH
3840: NOP4
3844: PPUSH
3845: NOP4
// un = CreateHuman ;
3849: NOP4
3853: PUSH
3854: NOP4
3858: ST_TO_ADDR
// amLeftEngs = amLeftEngs ^ un ;
3859: NOP4
3863: PUSH
3864: NOP4
3868: PUSH
3869: NOP4
3873: ADD
3874: ST_TO_ADDR
// PlaceHumanInUnit ( un , amLeftDepot ) ;
3875: NOP4
3879: PPUSH
3880: NOP4
3884: PPUSH
3885: NOP4
// end ;
3889: GO 3799
3891: POP
3892: POP
// if Difficulty = 3 then
3893: NOP4
3897: PUSH
3898: LD_INT 3
3900: EQUAL
3901: IFFALSE 4025
// begin amRightEngs = [ ] ;
3903: NOP4
3907: PUSH
3908: EMPTY
3909: ST_TO_ADDR
// for i := 1 to rand ( 1 , 2 ) do
3910: NOP4
3914: PUSH
3915: DOUBLE
3916: LD_INT 1
3918: DEC
3919: ST_TO_ADDR
3920: LD_INT 1
3922: PPUSH
3923: LD_INT 2
3925: PPUSH
3926: NOP4
3930: PUSH
3931: FOR_TO
3932: IFFALSE 4023
// begin uc_nation = 1 ;
3934: LD_ADDR_OWVAR 21
3938: PUSH
3939: LD_INT 1
3941: ST_TO_ADDR
// uc_side = 1 ;
3942: LD_ADDR_OWVAR 20
3946: PUSH
3947: LD_INT 1
3949: ST_TO_ADDR
// hc_gallery =  ;
3950: LD_ADDR_OWVAR 33
3954: PUSH
3955: LD_STRING 
3957: ST_TO_ADDR
// hc_name =  ;
3958: LD_ADDR_OWVAR 26
3962: PUSH
3963: LD_STRING 
3965: ST_TO_ADDR
// PrepareHuman ( false , 2 , enemySkillLevel ) ;
3966: LD_INT 0
3968: PPUSH
3969: LD_INT 2
3971: PPUSH
3972: NOP4
3976: PPUSH
3977: NOP4
// un = CreateHuman ;
3981: NOP4
3985: PUSH
3986: NOP4
3990: ST_TO_ADDR
// amRightEngs = amRightEngs ^ un ;
3991: NOP4
3995: PUSH
3996: NOP4
4000: PUSH
4001: NOP4
4005: ADD
4006: ST_TO_ADDR
// PlaceHumanInUnit ( un , amRightDepot ) ;
4007: NOP4
4011: PPUSH
4012: NOP4
4016: PPUSH
4017: NOP4
// end ;
4021: GO 3931
4023: POP
4024: POP
// end ; end ; end_of_file
4025: LD_VAR 0 1
4029: RET
// export function PrepareUnit ( ident , exist_mode ) ; var unit ; begin
4030: LD_INT 0
4032: PPUSH
4033: PPUSH
// if exist_mode then
4034: NOP4
4038: IFFALSE 4063
// unit := CreateCharacter ( previousMissionPrefix & ident ) else
4040: NOP4
4044: PUSH
4045: NOP4
4049: PUSH
4050: NOP4
4054: STR
4055: PPUSH
4056: NOP4
4060: ST_TO_ADDR
4061: GO 4078
// unit := NewCharacter ( ident ) ;
4063: NOP4
4067: PUSH
4068: NOP4
4072: PPUSH
4073: NOP4
4077: ST_TO_ADDR
// result := unit ;
4078: NOP4
4082: PUSH
4083: NOP4
4087: ST_TO_ADDR
// end ;
4088: LD_VAR 0 3
4092: RET
// export function DialogRandom ( characters , dialogMID , dialogFID , radio ) ; var i , speaker ; begin
4093: LD_INT 0
4095: PPUSH
4096: PPUSH
4097: PPUSH
// characters := characters diff [ Burlak , Gnyevko , Belkov , Kirilenkova ] ;
4098: NOP4
4102: PUSH
4103: NOP4
4107: PUSH
4108: NOP4
4112: PUSH
4113: NOP4
4117: PUSH
4118: NOP4
4122: PUSH
4123: NOP4
4127: PUSH
4128: EMPTY
4129: LIST
4130: LIST
4131: LIST
4132: LIST
4133: DIFF
4134: ST_TO_ADDR
// speaker := characters [ rand ( 1 , characters ) ] ;
4135: NOP4
4139: PUSH
4140: NOP4
4144: PUSH
4145: LD_INT 1
4147: PPUSH
4148: NOP4
4152: PPUSH
4153: NOP4
4157: ARRAY
4158: ST_TO_ADDR
// if radio then
4159: NOP4
4163: IFFALSE 4212
// begin if GetSex ( speaker ) = sex_male then
4165: NOP4
4169: PPUSH
4170: NOP4
4174: PUSH
4175: LD_INT 1
4177: EQUAL
4178: IFFALSE 4196
// SayRadio ( speaker , dialogMID ) else
4180: NOP4
4184: PPUSH
4185: NOP4
4189: PPUSH
4190: NOP4
4194: GO 4210
// SayRadio ( speaker , dialogFID ) ;
4196: NOP4
4200: PPUSH
4201: NOP4
4205: PPUSH
4206: NOP4
// end else
4210: GO 4257
// begin if GetSex ( speaker ) = sex_male then
4212: NOP4
4216: PPUSH
4217: NOP4
4221: PUSH
4222: LD_INT 1
4224: EQUAL
4225: IFFALSE 4243
// Say ( speaker , dialogMID ) else
4227: NOP4
4231: PPUSH
4232: NOP4
4236: PPUSH
4237: NOP4
4241: GO 4257
// Say ( speaker , dialogFID ) ;
4243: NOP4
4247: PPUSH
4248: NOP4
4252: PPUSH
4253: NOP4
// end ; result := speaker ;
4257: NOP4
4261: PUSH
4262: NOP4
4266: ST_TO_ADDR
// end ;
4267: LD_VAR 0 5
4271: RET
// export function ExtSaveCharacter ( character , characterStringID , side ) ; begin
4272: LD_INT 0
4274: PPUSH
// if GetSide ( character ) = side and IsOK ( character ) then
4275: NOP4
4279: PPUSH
4280: NOP4
4284: PUSH
4285: NOP4
4289: EQUAL
4290: PUSH
4291: NOP4
4295: PPUSH
4296: NOP4
4300: AND
4301: IFFALSE 4323
// SaveCharacters ( character , missionPrefix & characterStringID ) ;
4303: NOP4
4307: PPUSH
4308: NOP4
4312: PUSH
4313: NOP4
4317: STR
4318: PPUSH
4319: NOP4
// end ;
4323: LD_VAR 0 4
4327: RET
// export function ExtSaveCharacters ( characters , charactersStringID , side ) ; var unit , resultCharactersToSave ; begin
4328: LD_INT 0
4330: PPUSH
4331: PPUSH
4332: PPUSH
// resultCharactersToSave = [ ] ;
4333: NOP4
4337: PUSH
4338: EMPTY
4339: ST_TO_ADDR
// for unit in characters do
4340: NOP4
4344: PUSH
4345: NOP4
4349: PUSH
4350: FOR_IN
4351: IFFALSE 4399
// if GetSide ( unit ) = side and IsOK ( unit ) then
4353: NOP4
4357: PPUSH
4358: NOP4
4362: PUSH
4363: NOP4
4367: EQUAL
4368: PUSH
4369: NOP4
4373: PPUSH
4374: NOP4
4378: AND
4379: IFFALSE 4397
// resultCharactersToSave = resultCharactersToSave ^ unit ;
4381: NOP4
4385: PUSH
4386: NOP4
4390: PUSH
4391: NOP4
4395: ADD
4396: ST_TO_ADDR
4397: GO 4350
4399: POP
4400: POP
// SaveCharacters ( resultCharactersToSave , missionPrefix & charactersStringID ) ;
4401: NOP4
4405: PPUSH
4406: NOP4
4410: PUSH
4411: NOP4
4415: STR
4416: PPUSH
4417: NOP4
// end ;
4421: LD_VAR 0 4
4425: RET
// export function Question1 ( q ) ; var dec , q1 ; begin
4426: LD_INT 0
4428: PPUSH
4429: PPUSH
4430: PPUSH
// dec = SelectiveQuery ( QMoreInfo , q ) ;
4431: NOP4
4435: PUSH
4436: LD_STRING QMoreInfo
4438: PPUSH
4439: NOP4
4443: PPUSH
4444: NOP4
4448: ST_TO_ADDR
// case dec of 1 :
4449: NOP4
4453: PUSH
4454: LD_INT 1
4456: DOUBLE
4457: EQUAL
4458: IFTRUE 4462
4460: GO 4522
4462: POP
// begin Say ( Burlak , D2a-Bur-1 ) ;
4463: NOP4
4467: PPUSH
4468: LD_STRING D2a-Bur-1
4470: PPUSH
4471: NOP4
// Say ( Platonov , D2a-Pla-1 ) ;
4475: NOP4
4479: PPUSH
4480: LD_STRING D2a-Pla-1
4482: PPUSH
4483: NOP4
// q1 = q diff 1 ;
4487: NOP4
4491: PUSH
4492: NOP4
4496: PUSH
4497: LD_INT 1
4499: DIFF
4500: ST_TO_ADDR
// if q1 >= 2 then
4501: NOP4
4505: PUSH
4506: LD_INT 2
4508: GREATEREQUAL
4509: IFFALSE 4520
// Question1 ( q1 ) ;
4511: NOP4
4515: PPUSH
4516: NOP4
// end ; 2 :
4520: GO 4659
4522: LD_INT 2
4524: DOUBLE
4525: EQUAL
4526: IFTRUE 4530
4528: GO 4590
4530: POP
// begin Say ( Burlak , D2b-Bur-1 ) ;
4531: NOP4
4535: PPUSH
4536: LD_STRING D2b-Bur-1
4538: PPUSH
4539: NOP4
// Say ( Platonov , D2b-Pla-1 ) ;
4543: NOP4
4547: PPUSH
4548: LD_STRING D2b-Pla-1
4550: PPUSH
4551: NOP4
// q1 = q diff 2 ;
4555: NOP4
4559: PUSH
4560: NOP4
4564: PUSH
4565: LD_INT 2
4567: DIFF
4568: ST_TO_ADDR
// if q1 >= 2 then
4569: NOP4
4573: PUSH
4574: LD_INT 2
4576: GREATEREQUAL
4577: IFFALSE 4588
// Question1 ( q1 ) ;
4579: NOP4
4583: PPUSH
4584: NOP4
// end ; 3 :
4588: GO 4659
4590: LD_INT 3
4592: DOUBLE
4593: EQUAL
4594: IFTRUE 4598
4596: GO 4658
4598: POP
// begin Say ( Burlak , D2c-Bur-1 ) ;
4599: NOP4
4603: PPUSH
4604: LD_STRING D2c-Bur-1
4606: PPUSH
4607: NOP4
// Say ( Platonov , D2c-Pla-1 ) ;
4611: NOP4
4615: PPUSH
4616: LD_STRING D2c-Pla-1
4618: PPUSH
4619: NOP4
// q1 = q diff 3 ;
4623: NOP4
4627: PUSH
4628: NOP4
4632: PUSH
4633: LD_INT 3
4635: DIFF
4636: ST_TO_ADDR
// if q1 >= 2 then
4637: NOP4
4641: PUSH
4642: LD_INT 2
4644: GREATEREQUAL
4645: IFFALSE 4656
// Question1 ( q1 ) ;
4647: NOP4
4651: PPUSH
4652: NOP4
// end ; end ;
4656: GO 4659
4658: POP
// end ;
4659: LD_VAR 0 2
4663: RET
// export function ExtAddComRefuel ( engineer , depot , vehicle ) ; var taskList ; begin
4664: LD_INT 0
4666: PPUSH
4667: PPUSH
// if not IsOK ( engineer ) or not IsOK ( depot ) or not IsOK ( vehicle ) or GetFuel ( vehicle ) = 100 or not GetBType ( depot ) in [ b_depot , b_warehouse ] then
4668: NOP4
4672: PPUSH
4673: NOP4
4677: NOT
4678: PUSH
4679: NOP4
4683: PPUSH
4684: NOP4
4688: NOT
4689: OR
4690: PUSH
4691: NOP4
4695: PPUSH
4696: NOP4
4700: NOT
4701: OR
4702: PUSH
4703: NOP4
4707: PPUSH
4708: NOP4
4712: PUSH
4713: LD_INT 100
4715: EQUAL
4716: OR
4717: PUSH
4718: NOP4
4722: PPUSH
4723: NOP4
4727: PUSH
4728: LD_INT 0
4730: PUSH
4731: LD_INT 1
4733: PUSH
4734: EMPTY
4735: LIST
4736: LIST
4737: IN
4738: NOT
4739: OR
4740: IFFALSE 4744
// exit ;
4742: GO 4877
// AddComTransport ( engineer , depot , mat_oil ) ;
4744: NOP4
4748: PPUSH
4749: NOP4
4753: PPUSH
4754: LD_INT 2
4756: PPUSH
4757: NOP4
// repeat wait ( 0 0$01 ) ;
4761: LD_INT 35
4763: PPUSH
4764: NOP4
// until Carry ( engineer ) ;
4768: NOP4
4772: PPUSH
4773: NOP4
4777: IFFALSE 4761
// RemoveTasks ( engineer ) ;
4779: NOP4
4783: PPUSH
4784: NOP4
// SetTaskList ( engineer , [ [ O , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
4788: NOP4
4792: PPUSH
4793: LD_STRING O
4795: PUSH
4796: LD_INT 0
4798: PUSH
4799: LD_INT 0
4801: PUSH
4802: NOP4
4806: PUSH
4807: LD_INT 0
4809: PUSH
4810: LD_INT 0
4812: PUSH
4813: LD_INT 0
4815: PUSH
4816: EMPTY
4817: LIST
4818: LIST
4819: LIST
4820: LIST
4821: LIST
4822: LIST
4823: LIST
4824: PUSH
4825: EMPTY
4826: LIST
4827: PPUSH
4828: NOP4
// repeat wait ( 0 0$01 ) ;
4832: LD_INT 35
4834: PPUSH
4835: NOP4
// until not Carry ( engineer ) ;
4839: NOP4
4843: PPUSH
4844: NOP4
4848: NOT
4849: IFFALSE 4832
// SetFuel ( vehicle , 100 ) ;
4851: NOP4
4855: PPUSH
4856: LD_INT 100
4858: PPUSH
4859: NOP4
// AddComEnterUnit ( engineer , depot ) ;
4863: NOP4
4867: PPUSH
4868: NOP4
4872: PPUSH
4873: NOP4
// end ;
4877: LD_VAR 0 4
4881: RET
// export function ResAllTechs ( side , lab , nation ) ; var i , tech , cout , ru_tech_list ; begin
4882: LD_INT 0
4884: PPUSH
4885: PPUSH
4886: PPUSH
4887: PPUSH
4888: PPUSH
// ru_tech_list := [ 48 , 49 , 50 , 20 , 1 , 51 , 52 , 69 , 39 , 34 , 40 , 53 , 71 , 57 , 58 , 44 , 32 , 27 , 23 , 33 , 59 , 54 , 55 , 56 , 63 , 64 , 65 , 30 , 31 , 21 , 22 , 25 ] ;
4889: NOP4
4893: PUSH
4894: LD_INT 48
4896: PUSH
4897: LD_INT 49
4899: PUSH
4900: LD_INT 50
4902: PUSH
4903: LD_INT 20
4905: PUSH
4906: LD_INT 1
4908: PUSH
4909: LD_INT 51
4911: PUSH
4912: LD_INT 52
4914: PUSH
4915: LD_INT 69
4917: PUSH
4918: LD_INT 39
4920: PUSH
4921: LD_INT 34
4923: PUSH
4924: LD_INT 40
4926: PUSH
4927: LD_INT 53
4929: PUSH
4930: LD_INT 71
4932: PUSH
4933: LD_INT 57
4935: PUSH
4936: LD_INT 58
4938: PUSH
4939: LD_INT 44
4941: PUSH
4942: LD_INT 32
4944: PUSH
4945: LD_INT 27
4947: PUSH
4948: LD_INT 23
4950: PUSH
4951: LD_INT 33
4953: PUSH
4954: LD_INT 59
4956: PUSH
4957: LD_INT 54
4959: PUSH
4960: LD_INT 55
4962: PUSH
4963: LD_INT 56
4965: PUSH
4966: LD_INT 63
4968: PUSH
4969: LD_INT 64
4971: PUSH
4972: LD_INT 65
4974: PUSH
4975: LD_INT 30
4977: PUSH
4978: LD_INT 31
4980: PUSH
4981: LD_INT 21
4983: PUSH
4984: LD_INT 22
4986: PUSH
4987: LD_INT 25
4989: PUSH
4990: EMPTY
4991: LIST
4992: LIST
4993: LIST
4994: LIST
4995: LIST
4996: LIST
4997: LIST
4998: LIST
4999: LIST
5000: LIST
5001: LIST
5002: LIST
5003: LIST
5004: LIST
5005: LIST
5006: LIST
5007: LIST
5008: LIST
5009: LIST
5010: LIST
5011: LIST
5012: LIST
5013: LIST
5014: LIST
5015: LIST
5016: LIST
5017: LIST
5018: LIST
5019: LIST
5020: LIST
5021: LIST
5022: LIST
5023: ST_TO_ADDR
// for i = 1 to ru_tech_list do
5024: NOP4
5028: PUSH
5029: DOUBLE
5030: LD_INT 1
5032: DEC
5033: ST_TO_ADDR
5034: NOP4
5038: PUSH
5039: FOR_TO
5040: IFFALSE 5116
// if GetTech ( ru_tech_list [ i ] , side ) = state_enabled and TechNationAvailable ( ru_tech_list [ i ] , nation ) = true then
5042: NOP4
5046: PUSH
5047: NOP4
5051: ARRAY
5052: PPUSH
5053: NOP4
5057: PPUSH
5058: NOP4
5062: PUSH
5063: LD_INT 1
5065: EQUAL
5066: PUSH
5067: NOP4
5071: PUSH
5072: NOP4
5076: ARRAY
5077: PPUSH
5078: NOP4
5082: PPUSH
5083: NOP4
5087: PUSH
5088: LD_INT 1
5090: EQUAL
5091: AND
5092: IFFALSE 5114
// AddComResearch ( lab , ru_tech_list [ i ] ) ;
5094: NOP4
5098: PPUSH
5099: NOP4
5103: PUSH
5104: NOP4
5108: ARRAY
5109: PPUSH
5110: NOP4
5114: GO 5039
5116: POP
5117: POP
// end ;
5118: LD_VAR 0 4
5122: RET
// export function PrepareSolBun ( skill , b ) ; var un , dir ; begin
5123: LD_INT 0
5125: PPUSH
5126: PPUSH
5127: PPUSH
// uc_side := GetSide ( b ) ;
5128: LD_ADDR_OWVAR 20
5132: PUSH
5133: NOP4
5137: PPUSH
5138: NOP4
5142: ST_TO_ADDR
// uc_nation := GetNation ( b ) ;
5143: LD_ADDR_OWVAR 21
5147: PUSH
5148: NOP4
5152: PPUSH
5153: NOP4
5157: ST_TO_ADDR
// PrepareHuman ( false , 1 , skill ) ;
5158: LD_INT 0
5160: PPUSH
5161: LD_INT 1
5163: PPUSH
5164: NOP4
5168: PPUSH
5169: NOP4
// un = CreateHuman ;
5173: NOP4
5177: PUSH
5178: NOP4
5182: ST_TO_ADDR
// dir := GetDir ( b ) - 3 ;
5183: NOP4
5187: PUSH
5188: NOP4
5192: PPUSH
5193: NOP4
5197: PUSH
5198: LD_INT 3
5200: MINUS
5201: ST_TO_ADDR
// if dir < 0 then
5202: NOP4
5206: PUSH
5207: LD_INT 0
5209: LESS
5210: IFFALSE 5226
// dir := 6 + dir ;
5212: NOP4
5216: PUSH
5217: LD_INT 6
5219: PUSH
5220: NOP4
5224: PLUS
5225: ST_TO_ADDR
// SetDir ( un , dir ) ;
5226: NOP4
5230: PPUSH
5231: NOP4
5235: PPUSH
5236: NOP4
// PlaceHumanInUnit ( un , b ) ;
5240: NOP4
5244: PPUSH
5245: NOP4
5249: PPUSH
5250: NOP4
// result = un ;
5254: NOP4
5258: PUSH
5259: NOP4
5263: ST_TO_ADDR
// end ;
5264: LD_VAR 0 3
5268: RET
// export function PlaceSolBun ( un , b ) ; var dir ; begin
5269: LD_INT 0
5271: PPUSH
5272: PPUSH
// dir := GetDir ( b ) - 3 ;
5273: NOP4
5277: PUSH
5278: NOP4
5282: PPUSH
5283: NOP4
5287: PUSH
5288: LD_INT 3
5290: MINUS
5291: ST_TO_ADDR
// if dir < 0 then
5292: NOP4
5296: PUSH
5297: LD_INT 0
5299: LESS
5300: IFFALSE 5316
// dir := 6 + dir ;
5302: NOP4
5306: PUSH
5307: LD_INT 6
5309: PUSH
5310: NOP4
5314: PLUS
5315: ST_TO_ADDR
// SetDir ( un , dir ) ;
5316: NOP4
5320: PPUSH
5321: NOP4
5325: PPUSH
5326: NOP4
// PlaceHumanInUnit ( un , b ) ;
5330: NOP4
5334: PPUSH
5335: NOP4
5339: PPUSH
5340: NOP4
// result = un ;
5344: NOP4
5348: PUSH
5349: NOP4
5353: ST_TO_ADDR
// end ;
5354: LD_VAR 0 3
5358: RET
// export function SaveVehicles ( vehicles , ident ) ; var i , tmp ; begin
5359: LD_INT 0
5361: PPUSH
5362: PPUSH
5363: PPUSH
// tmp = [ ] ;
5364: NOP4
5368: PUSH
5369: EMPTY
5370: ST_TO_ADDR
// if not vehicles then
5371: NOP4
5375: NOT
5376: IFFALSE 5380
// exit ;
5378: GO 5497
// for i in vehicles do
5380: NOP4
5384: PUSH
5385: NOP4
5389: PUSH
5390: FOR_IN
5391: IFFALSE 5481
// tmp := Insert ( tmp , 1 , [ GetChassis ( i ) , GetEngine ( i ) , GetControl ( i ) , GetWeapon ( i ) , GetFuel ( i ) , GetLives ( i ) ] ) ;
5393: NOP4
5397: PUSH
5398: NOP4
5402: PPUSH
5403: LD_INT 1
5405: PPUSH
5406: NOP4
5410: PPUSH
5411: NOP4
5415: PUSH
5416: NOP4
5420: PPUSH
5421: NOP4
5425: PUSH
5426: NOP4
5430: PPUSH
5431: NOP4
5435: PUSH
5436: NOP4
5440: PPUSH
5441: NOP4
5445: PUSH
5446: NOP4
5450: PPUSH
5451: NOP4
5455: PUSH
5456: NOP4
5460: PPUSH
5461: NOP4
5465: PUSH
5466: EMPTY
5467: LIST
5468: LIST
5469: LIST
5470: LIST
5471: LIST
5472: LIST
5473: PPUSH
5474: NOP4
5478: ST_TO_ADDR
5479: GO 5390
5481: POP
5482: POP
// SaveVariable ( tmp , ident ) ;
5483: NOP4
5487: PPUSH
5488: NOP4
5492: PPUSH
5493: NOP4
// end ;
5497: LD_VAR 0 3
5501: RET
// export function SaveBase ( buildings , ident ) ; var i , buildingsToSave ; begin
5502: LD_INT 0
5504: PPUSH
5505: PPUSH
5506: PPUSH
// buildingsToSave = [ ] ;
5507: NOP4
5511: PUSH
5512: EMPTY
5513: ST_TO_ADDR
// if not buildings then
5514: NOP4
5518: NOT
5519: IFFALSE 5523
// exit ;
5521: GO 6098
// for i in buildings do
5523: NOP4
5527: PUSH
5528: NOP4
5532: PUSH
5533: FOR_IN
5534: IFFALSE 6082
// begin if GetBType ( i ) in [ b_lab , b_lab_half , b_lab_full ] then
5536: NOP4
5540: PPUSH
5541: NOP4
5545: PUSH
5546: LD_INT 6
5548: PUSH
5549: LD_INT 7
5551: PUSH
5552: LD_INT 8
5554: PUSH
5555: EMPTY
5556: LIST
5557: LIST
5558: LIST
5559: IN
5560: IFFALSE 5685
// buildingsToSave = buildingsToSave ^ [ [ GetBType ( i ) , GetX ( i ) , GetY ( i ) , GetDir ( i ) , GetBLevel ( i ) , GetNation ( i ) , GetLives ( i ) , GetLabKind ( i , 1 ) , GetLabKind ( i , 2 ) ] ] else
5562: NOP4
5566: PUSH
5567: NOP4
5571: PUSH
5572: NOP4
5576: PPUSH
5577: NOP4
5581: PUSH
5582: NOP4
5586: PPUSH
5587: NOP4
5591: PUSH
5592: NOP4
5596: PPUSH
5597: NOP4
5601: PUSH
5602: NOP4
5606: PPUSH
5607: NOP4
5611: PUSH
5612: NOP4
5616: PPUSH
5617: NOP4
5621: PUSH
5622: NOP4
5626: PPUSH
5627: NOP4
5631: PUSH
5632: NOP4
5636: PPUSH
5637: NOP4
5641: PUSH
5642: NOP4
5646: PPUSH
5647: LD_INT 1
5649: PPUSH
5650: NOP4
5654: PUSH
5655: NOP4
5659: PPUSH
5660: LD_INT 2
5662: PPUSH
5663: NOP4
5667: PUSH
5668: EMPTY
5669: LIST
5670: LIST
5671: LIST
5672: LIST
5673: LIST
5674: LIST
5675: LIST
5676: LIST
5677: LIST
5678: PUSH
5679: EMPTY
5680: LIST
5681: ADD
5682: ST_TO_ADDR
5683: GO 6080
// if GetBType ( i ) in [ b_bunker , b_turret ] then
5685: NOP4
5689: PPUSH
5690: NOP4
5694: PUSH
5695: LD_INT 32
5697: PUSH
5698: LD_INT 33
5700: PUSH
5701: EMPTY
5702: LIST
5703: LIST
5704: IN
5705: IFFALSE 5813
// buildingsToSave = buildingsToSave ^ [ [ GetBType ( i ) , GetX ( i ) , GetY ( i ) , GetDir ( i ) , GetBLevel ( i ) , GetNation ( i ) , GetLives ( i ) , GetBWeapon ( i ) ] ] else
5707: NOP4
5711: PUSH
5712: NOP4
5716: PUSH
5717: NOP4
5721: PPUSH
5722: NOP4
5726: PUSH
5727: NOP4
5731: PPUSH
5732: NOP4
5736: PUSH
5737: NOP4
5741: PPUSH
5742: NOP4
5746: PUSH
5747: NOP4
5751: PPUSH
5752: NOP4
5756: PUSH
5757: NOP4
5761: PPUSH
5762: NOP4
5766: PUSH
5767: NOP4
5771: PPUSH
5772: NOP4
5776: PUSH
5777: NOP4
5781: PPUSH
5782: NOP4
5786: PUSH
5787: NOP4
5791: PPUSH
5792: NOP4
5796: PUSH
5797: EMPTY
5798: LIST
5799: LIST
5800: LIST
5801: LIST
5802: LIST
5803: LIST
5804: LIST
5805: LIST
5806: PUSH
5807: EMPTY
5808: LIST
5809: ADD
5810: ST_TO_ADDR
5811: GO 6080
// if GetBType ( i ) in [ b_depot , b_warehouse ] then
5813: NOP4
5817: PPUSH
5818: NOP4
5822: PUSH
5823: LD_INT 0
5825: PUSH
5826: LD_INT 1
5828: PUSH
5829: EMPTY
5830: LIST
5831: LIST
5832: IN
5833: IFFALSE 5987
// buildingsToSave = buildingsToSave ^ [ [ GetBType ( i ) , GetX ( i ) , GetY ( i ) , GetDir ( i ) , GetBLevel ( i ) , GetNation ( i ) , GetLives ( i ) , GetResourceType ( GetBase ( i ) , mat_cans ) , GetResourceType ( GetBase ( i ) , mat_oil ) , GetResourceType ( GetBase ( i ) , mat_siberit ) ] ] else
5835: NOP4
5839: PUSH
5840: NOP4
5844: PUSH
5845: NOP4
5849: PPUSH
5850: NOP4
5854: PUSH
5855: NOP4
5859: PPUSH
5860: NOP4
5864: PUSH
5865: NOP4
5869: PPUSH
5870: NOP4
5874: PUSH
5875: NOP4
5879: PPUSH
5880: NOP4
5884: PUSH
5885: NOP4
5889: PPUSH
5890: NOP4
5894: PUSH
5895: NOP4
5899: PPUSH
5900: NOP4
5904: PUSH
5905: NOP4
5909: PPUSH
5910: NOP4
5914: PUSH
5915: NOP4
5919: PPUSH
5920: NOP4
5924: PPUSH
5925: LD_INT 1
5927: PPUSH
5928: NOP4
5932: PUSH
5933: NOP4
5937: PPUSH
5938: NOP4
5942: PPUSH
5943: LD_INT 2
5945: PPUSH
5946: NOP4
5950: PUSH
5951: NOP4
5955: PPUSH
5956: NOP4
5960: PPUSH
5961: LD_INT 3
5963: PPUSH
5964: NOP4
5968: PUSH
5969: EMPTY
5970: LIST
5971: LIST
5972: LIST
5973: LIST
5974: LIST
5975: LIST
5976: LIST
5977: LIST
5978: LIST
5979: LIST
5980: PUSH
5981: EMPTY
5982: LIST
5983: ADD
5984: ST_TO_ADDR
5985: GO 6080
// buildingsToSave = buildingsToSave ^ [ [ GetBType ( i ) , GetX ( i ) , GetY ( i ) , GetDir ( i ) , GetBLevel ( i ) , GetNation ( i ) , GetLives ( i ) ] ] ;
5987: NOP4
5991: PUSH
5992: NOP4
5996: PUSH
5997: NOP4
6001: PPUSH
6002: NOP4
6006: PUSH
6007: NOP4
6011: PPUSH
6012: NOP4
6016: PUSH
6017: NOP4
6021: PPUSH
6022: NOP4
6026: PUSH
6027: NOP4
6031: PPUSH
6032: NOP4
6036: PUSH
6037: NOP4
6041: PPUSH
6042: NOP4
6046: PUSH
6047: NOP4
6051: PPUSH
6052: NOP4
6056: PUSH
6057: NOP4
6061: PPUSH
6062: NOP4
6066: PUSH
6067: EMPTY
6068: LIST
6069: LIST
6070: LIST
6071: LIST
6072: LIST
6073: LIST
6074: LIST
6075: PUSH
6076: EMPTY
6077: LIST
6078: ADD
6079: ST_TO_ADDR
// end ;
6080: GO 5533
6082: POP
6083: POP
// SaveVariable ( buildingsToSave , ident ) ;
6084: NOP4
6088: PPUSH
6089: NOP4
6093: PPUSH
6094: NOP4
// end ;
6098: LD_VAR 0 3
6102: RET
// export function CreateBelkovTeam ; var i , unit , restRandSolds , tmp ; begin
6103: LD_INT 0
6105: PPUSH
6106: PPUSH
6107: PPUSH
6108: PPUSH
6109: PPUSH
// belkovTeam = [ ] ;
6110: NOP4
6114: PUSH
6115: EMPTY
6116: ST_TO_ADDR
// if belkovReturn then
6117: NOP4
6121: IFFALSE 6139
// belkovTeam = belkovTeam ^ Belkov ;
6123: NOP4
6127: PUSH
6128: NOP4
6132: PUSH
6133: NOP4
6137: ADD
6138: ST_TO_ADDR
// belkovTeam = belkovTeam ^ Belkov2 ;
6139: NOP4
6143: PUSH
6144: NOP4
6148: PUSH
6149: NOP4
6153: ADD
6154: ST_TO_ADDR
// for unit in other_survivors do
6155: NOP4
6159: PUSH
6160: NOP4
6164: PUSH
6165: FOR_IN
6166: IFFALSE 6207
// if IsOK ( unit ) and belkovTeam < 5 then
6168: NOP4
6172: PPUSH
6173: NOP4
6177: PUSH
6178: NOP4
6182: PUSH
6183: LD_INT 5
6185: LESS
6186: AND
6187: IFFALSE 6205
// belkovTeam = belkovTeam ^ unit ;
6189: NOP4
6193: PUSH
6194: NOP4
6198: PUSH
6199: NOP4
6203: ADD
6204: ST_TO_ADDR
6205: GO 6165
6207: POP
6208: POP
// if belkovTeam < 5 then
6209: NOP4
6213: PUSH
6214: LD_INT 5
6216: LESS
6217: IFFALSE 6343
// begin restRandSolds = 5 - belkovTeam ;
6219: NOP4
6223: PUSH
6224: LD_INT 5
6226: PUSH
6227: NOP4
6231: MINUS
6232: ST_TO_ADDR
// for i := 1 to restRandSolds do
6233: NOP4
6237: PUSH
6238: DOUBLE
6239: LD_INT 1
6241: DEC
6242: ST_TO_ADDR
6243: NOP4
6247: PUSH
6248: FOR_TO
6249: IFFALSE 6341
// for unit in UnitFilter ( otherKirovUnits , [ [ f_class , class_soldier ] ] ) diff Kurin do
6251: NOP4
6255: PUSH
6256: NOP4
6260: PPUSH
6261: LD_INT 25
6263: PUSH
6264: LD_INT 1
6266: PUSH
6267: EMPTY
6268: LIST
6269: LIST
6270: PUSH
6271: EMPTY
6272: LIST
6273: PPUSH
6274: NOP4
6278: PUSH
6279: NOP4
6283: DIFF
6284: PUSH
6285: FOR_IN
6286: IFFALSE 6337
// if not unit in belkovTeam then
6288: NOP4
6292: PUSH
6293: NOP4
6297: IN
6298: NOT
6299: IFFALSE 6335
// begin belkovTeam = belkovTeam ^ unit ;
6301: NOP4
6305: PUSH
6306: NOP4
6310: PUSH
6311: NOP4
6315: ADD
6316: ST_TO_ADDR
// otherKirovUnits = otherKirovUnits diff unit ;
6317: NOP4
6321: PUSH
6322: NOP4
6326: PUSH
6327: NOP4
6331: DIFF
6332: ST_TO_ADDR
// break ;
6333: GO 6337
// end ;
6335: GO 6285
6337: POP
6338: POP
6339: GO 6248
6341: POP
6342: POP
// end ; tmp = belkovTeam diff Belkov ;
6343: NOP4
6347: PUSH
6348: NOP4
6352: PUSH
6353: NOP4
6357: DIFF
6358: ST_TO_ADDR
// if tmp < 4 then
6359: NOP4
6363: PUSH
6364: LD_INT 4
6366: LESS
6367: IFFALSE 6451
// begin for i := 1 to 4 - tmp do
6369: NOP4
6373: PUSH
6374: DOUBLE
6375: LD_INT 1
6377: DEC
6378: ST_TO_ADDR
6379: LD_INT 4
6381: PUSH
6382: NOP4
6386: MINUS
6387: PUSH
6388: FOR_TO
6389: IFFALSE 6449
// begin PrepareSoldier ( false , rand ( 1 , 2 ) ) ;
6391: LD_INT 0
6393: PPUSH
6394: LD_INT 1
6396: PPUSH
6397: LD_INT 2
6399: PPUSH
6400: NOP4
6404: PPUSH
6405: NOP4
// unit = CreateHuman ;
6409: NOP4
6413: PUSH
6414: NOP4
6418: ST_TO_ADDR
// belkovTeam = belkovTeam ^ unit ;
6419: NOP4
6423: PUSH
6424: NOP4
6428: PUSH
6429: NOP4
6433: ADD
6434: ST_TO_ADDR
// PlaceHumanInUnit ( unit , ru2_arm2 ) ;
6435: NOP4
6439: PPUSH
6440: LD_INT 209
6442: PPUSH
6443: NOP4
// end ;
6447: GO 6388
6449: POP
6450: POP
// end ; if TestCharacters ( 01_Kirilenkova ) then
6451: LD_STRING 01_Kirilenkova
6453: PPUSH
6454: NOP4
6458: IFFALSE 6478
// belkovTeam = belkovTeam ^ Kirilenkova else
6460: NOP4
6464: PUSH
6465: NOP4
6469: PUSH
6470: NOP4
6474: ADD
6475: ST_TO_ADDR
6476: GO 6554
// begin belkovTeam = belkovTeam ^ UnitFilter ( otherKirovUnits , [ [ f_class , class_scientistic ] ] ) [ 1 ] ;
6478: NOP4
6482: PUSH
6483: NOP4
6487: PUSH
6488: NOP4
6492: PPUSH
6493: LD_INT 25
6495: PUSH
6496: LD_INT 4
6498: PUSH
6499: EMPTY
6500: LIST
6501: LIST
6502: PUSH
6503: EMPTY
6504: LIST
6505: PPUSH
6506: NOP4
6510: PUSH
6511: LD_INT 1
6513: ARRAY
6514: ADD
6515: ST_TO_ADDR
// otherKirovUnits = otherKirovUnits diff UnitFilter ( otherKirovUnits , [ [ f_class , class_scientistic ] ] ) [ 1 ] ;
6516: NOP4
6520: PUSH
6521: NOP4
6525: PUSH
6526: NOP4
6530: PPUSH
6531: LD_INT 25
6533: PUSH
6534: LD_INT 4
6536: PUSH
6537: EMPTY
6538: LIST
6539: LIST
6540: PUSH
6541: EMPTY
6542: LIST
6543: PPUSH
6544: NOP4
6548: PUSH
6549: LD_INT 1
6551: ARRAY
6552: DIFF
6553: ST_TO_ADDR
// end ; end ;
6554: LD_VAR 0 1
6558: RET
// export function PlatonovSendSupport ; var soldsOk ; begin
6559: LD_INT 0
6561: PPUSH
6562: PPUSH
// if not Kuklajs or not IsOK ( Kuklajs ) then
6563: NOP4
6567: NOT
6568: PUSH
6569: NOP4
6573: PPUSH
6574: NOP4
6578: NOT
6579: OR
6580: IFFALSE 6683
// begin soldsOk = UnitFilter ( platSoldiers , [ f_ok ] ) diff Benko ;
6582: NOP4
6586: PUSH
6587: NOP4
6591: PPUSH
6592: LD_INT 50
6594: PUSH
6595: EMPTY
6596: LIST
6597: PPUSH
6598: NOP4
6602: PUSH
6603: NOP4
6607: DIFF
6608: ST_TO_ADDR
// if soldsOK then
6609: NOP4
6613: IFFALSE 6683
// begin ComExitBuilding ( soldsOK [ 1 ] ) ;
6615: NOP4
6619: PUSH
6620: LD_INT 1
6622: ARRAY
6623: PPUSH
6624: NOP4
// AddComMoveXY ( soldsOK [ 1 ] , 112 , 96 ) ;
6628: NOP4
6632: PUSH
6633: LD_INT 1
6635: ARRAY
6636: PPUSH
6637: LD_INT 112
6639: PPUSH
6640: LD_INT 96
6642: PPUSH
6643: NOP4
// SetSide ( soldsOK [ 1 ] , 3 ) ;
6647: NOP4
6651: PUSH
6652: LD_INT 1
6654: ARRAY
6655: PPUSH
6656: LD_INT 3
6658: PPUSH
6659: NOP4
// platSoldiers = platSoldiers diff soldsOK [ 1 ] ;
6663: NOP4
6667: PUSH
6668: NOP4
6672: PUSH
6673: NOP4
6677: PUSH
6678: LD_INT 1
6680: ARRAY
6681: DIFF
6682: ST_TO_ADDR
// end ; end ; if not Benko or not IsOK ( Benko ) then
6683: NOP4
6687: NOT
6688: PUSH
6689: NOP4
6693: PPUSH
6694: NOP4
6698: NOT
6699: OR
6700: IFFALSE 6803
// begin soldsOk = UnitFilter ( platSoldiers , [ f_ok ] ) diff Kuklajs ;
6702: NOP4
6706: PUSH
6707: NOP4
6711: PPUSH
6712: LD_INT 50
6714: PUSH
6715: EMPTY
6716: LIST
6717: PPUSH
6718: NOP4
6722: PUSH
6723: NOP4
6727: DIFF
6728: ST_TO_ADDR
// if soldsOK then
6729: NOP4
6733: IFFALSE 6803
// begin ComExitBuilding ( soldsOK [ 1 ] ) ;
6735: NOP4
6739: PUSH
6740: LD_INT 1
6742: ARRAY
6743: PPUSH
6744: NOP4
// AddComMoveXY ( soldsOK [ 1 ] , 112 , 96 ) ;
6748: NOP4
6752: PUSH
6753: LD_INT 1
6755: ARRAY
6756: PPUSH
6757: LD_INT 112
6759: PPUSH
6760: LD_INT 96
6762: PPUSH
6763: NOP4
// SetSide ( soldsOK [ 1 ] , 3 ) ;
6767: NOP4
6771: PUSH
6772: LD_INT 1
6774: ARRAY
6775: PPUSH
6776: LD_INT 3
6778: PPUSH
6779: NOP4
// platSoldiers = platSoldiers diff soldsOK [ 1 ] ;
6783: NOP4
6787: PUSH
6788: NOP4
6792: PUSH
6793: NOP4
6797: PUSH
6798: LD_INT 1
6800: ARRAY
6801: DIFF
6802: ST_TO_ADDR
// end ; end ; ComExitBuilding ( [ Kuklajs , Benko ] ) ;
6803: NOP4
6807: PUSH
6808: NOP4
6812: PUSH
6813: EMPTY
6814: LIST
6815: LIST
6816: PPUSH
6817: NOP4
// AddComMoveXY ( [ Kuklajs , Benko ] , 112 , 96 ) ;
6821: NOP4
6825: PUSH
6826: NOP4
6830: PUSH
6831: EMPTY
6832: LIST
6833: LIST
6834: PPUSH
6835: LD_INT 112
6837: PPUSH
6838: LD_INT 96
6840: PPUSH
6841: NOP4
// SetSide ( [ Kuklajs , Benko ] , 3 ) ;
6845: NOP4
6849: PUSH
6850: NOP4
6854: PUSH
6855: EMPTY
6856: LIST
6857: LIST
6858: PPUSH
6859: LD_INT 3
6861: PPUSH
6862: NOP4
// end ; end_of_file
6866: LD_VAR 0 1
6870: RET
// export function MissionIntro ; var yourSolds , nearUnit ; var i ; begin
6871: LD_INT 0
6873: PPUSH
6874: PPUSH
6875: PPUSH
6876: PPUSH
// CenterNowOnUnits ( Burlak ) ;
6877: NOP4
6881: PPUSH
6882: NOP4
// ComMoveXY ( Burlak , 163 , 108 ) ;
6886: NOP4
6890: PPUSH
6891: LD_INT 163
6893: PPUSH
6894: LD_INT 108
6896: PPUSH
6897: NOP4
// AddComTurnUnit ( Burlak , Kurin ) ;
6901: NOP4
6905: PPUSH
6906: NOP4
6910: PPUSH
6911: NOP4
// yourSolds = FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) diff Burlak ;
6915: NOP4
6919: PUSH
6920: LD_INT 22
6922: PUSH
6923: LD_INT 3
6925: PUSH
6926: EMPTY
6927: LIST
6928: LIST
6929: PUSH
6930: LD_INT 21
6932: PUSH
6933: LD_INT 1
6935: PUSH
6936: EMPTY
6937: LIST
6938: LIST
6939: PUSH
6940: EMPTY
6941: LIST
6942: LIST
6943: PPUSH
6944: NOP4
6948: PUSH
6949: NOP4
6953: DIFF
6954: ST_TO_ADDR
// for i := 1 to meetWithKurinPositions do
6955: NOP4
6959: PUSH
6960: DOUBLE
6961: LD_INT 1
6963: DEC
6964: ST_TO_ADDR
6965: NOP4
6969: PUSH
6970: FOR_TO
6971: IFFALSE 7089
// begin nearUnit = NearestUnitToXY ( yourSolds , meetWithKurinPositions [ i ] [ 1 ] , meetWithKurinPositions [ i ] [ 2 ] ) ;
6973: NOP4
6977: PUSH
6978: NOP4
6982: PPUSH
6983: NOP4
6987: PUSH
6988: NOP4
6992: ARRAY
6993: PUSH
6994: LD_INT 1
6996: ARRAY
6997: PPUSH
6998: NOP4
7002: PUSH
7003: NOP4
7007: ARRAY
7008: PUSH
7009: LD_INT 2
7011: ARRAY
7012: PPUSH
7013: NOP4
7017: ST_TO_ADDR
// ComMoveXY ( nearUnit , meetWithKurinPositions [ i ] [ 1 ] , meetWithKurinPositions [ i ] [ 2 ] ) ;
7018: NOP4
7022: PPUSH
7023: NOP4
7027: PUSH
7028: NOP4
7032: ARRAY
7033: PUSH
7034: LD_INT 1
7036: ARRAY
7037: PPUSH
7038: NOP4
7042: PUSH
7043: NOP4
7047: ARRAY
7048: PUSH
7049: LD_INT 2
7051: ARRAY
7052: PPUSH
7053: NOP4
// AddComTurnUnit ( nearUnit , Kurin ) ;
7057: NOP4
7061: PPUSH
7062: NOP4
7066: PPUSH
7067: NOP4
// yourSolds = yourSolds diff nearUnit ;
7071: NOP4
7075: PUSH
7076: NOP4
7080: PUSH
7081: NOP4
7085: DIFF
7086: ST_TO_ADDR
// end ;
7087: GO 6970
7089: POP
7090: POP
// repeat CenterNowOnUnits ( Burlak ) ;
7091: NOP4
7095: PPUSH
7096: NOP4
// wait ( 0 0$1 ) ;
7100: LD_INT 35
7102: PPUSH
7103: NOP4
// until GetDistUnits ( Burlak , Kurin ) < 4 ;
7107: NOP4
7111: PPUSH
7112: NOP4
7116: PPUSH
7117: NOP4
7121: PUSH
7122: LD_INT 4
7124: LESS
7125: IFFALSE 7091
// CenterNowOnUnits ( [ Burlak , Kurin ] ) ;
7127: NOP4
7131: PUSH
7132: NOP4
7136: PUSH
7137: EMPTY
7138: LIST
7139: LIST
7140: PPUSH
7141: NOP4
// ComTurnUnit ( Kurin , Burlak ) ;
7145: NOP4
7149: PPUSH
7150: NOP4
7154: PPUSH
7155: NOP4
// Say ( Kurin , D1-Kur-1 ) ;
7159: NOP4
7163: PPUSH
7164: LD_STRING D1-Kur-1
7166: PPUSH
7167: NOP4
// Say ( Burlak , D1-Bur-1 ) ;
7171: NOP4
7175: PPUSH
7176: LD_STRING D1-Bur-1
7178: PPUSH
7179: NOP4
// Say ( Kurin , D1-Kur-2 ) ;
7183: NOP4
7187: PPUSH
7188: LD_STRING D1-Kur-2
7190: PPUSH
7191: NOP4
// Say ( Burlak , D1-Bur-2 ) ;
7195: NOP4
7199: PPUSH
7200: LD_STRING D1-Bur-2
7202: PPUSH
7203: NOP4
// Say ( Kurin , D1-Kur-3 ) ;
7207: NOP4
7211: PPUSH
7212: LD_STRING D1-Kur-3
7214: PPUSH
7215: NOP4
// if IsOK ( Gnyevko ) then
7219: NOP4
7223: PPUSH
7224: NOP4
7228: IFFALSE 7242
// Say ( Kurin , D1-Kur-3a ) ;
7230: NOP4
7234: PPUSH
7235: LD_STRING D1-Kur-3a
7237: PPUSH
7238: NOP4
// InGameOff ;
7242: NOP4
// SetSide ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) diff [ Burlak , Gnyevko ] , 6 ) ;
7246: LD_INT 22
7248: PUSH
7249: LD_INT 3
7251: PUSH
7252: EMPTY
7253: LIST
7254: LIST
7255: PUSH
7256: LD_INT 21
7258: PUSH
7259: LD_INT 1
7261: PUSH
7262: EMPTY
7263: LIST
7264: LIST
7265: PUSH
7266: EMPTY
7267: LIST
7268: LIST
7269: PPUSH
7270: NOP4
7274: PUSH
7275: NOP4
7279: PUSH
7280: NOP4
7284: PUSH
7285: EMPTY
7286: LIST
7287: LIST
7288: DIFF
7289: PPUSH
7290: LD_INT 6
7292: PPUSH
7293: NOP4
// SetSide ( Kovalyuk , 3 ) ;
7297: NOP4
7301: PPUSH
7302: LD_INT 3
7304: PPUSH
7305: NOP4
// ComFree ( FilterUnitsInArea ( KirovBaseArea , [ [ f_side , 6 ] , [ f_type , unit_human ] ] ) diff Kurin ) ;
7309: LD_INT 9
7311: PPUSH
7312: LD_INT 22
7314: PUSH
7315: LD_INT 6
7317: PUSH
7318: EMPTY
7319: LIST
7320: LIST
7321: PUSH
7322: LD_INT 21
7324: PUSH
7325: LD_INT 1
7327: PUSH
7328: EMPTY
7329: LIST
7330: LIST
7331: PUSH
7332: EMPTY
7333: LIST
7334: LIST
7335: PPUSH
7336: NOP4
7340: PUSH
7341: NOP4
7345: DIFF
7346: PPUSH
7347: NOP4
// ComEnterUnit ( other_survivors , ru2_arm1 ) ;
7351: NOP4
7355: PPUSH
7356: LD_INT 95
7358: PPUSH
7359: NOP4
// ComEnterUnit ( Belkov , ru2_arm1 ) ;
7363: NOP4
7367: PPUSH
7368: LD_INT 95
7370: PPUSH
7371: NOP4
// if IsPlaced ( Kirilenkova ) then
7375: NOP4
7379: PPUSH
7380: NOP4
7384: IFFALSE 7398
// ComEnterUnit ( Kirilenkova , ru_lab ) ;
7386: NOP4
7390: PPUSH
7391: LD_INT 83
7393: PPUSH
7394: NOP4
// if not TestCharacters ( 01_Gnyevko ) then
7398: LD_STRING 01_Gnyevko
7400: PPUSH
7401: NOP4
7405: NOT
7406: IFFALSE 7420
// SetSide ( randomMech , 3 ) ;
7408: NOP4
7412: PPUSH
7413: LD_INT 3
7415: PPUSH
7416: NOP4
// ChangeMissionObjectives ( M1 ) ;
7420: LD_STRING M1
7422: PPUSH
7423: NOP4
// HideArea ( 3 , AllMapArea ) ;
7427: LD_INT 3
7429: PPUSH
7430: LD_INT 6
7432: PPUSH
7433: NOP4
// ShowArea ( 3 , VisibleMapPartArea ) ;
7437: LD_INT 3
7439: PPUSH
7440: LD_INT 7
7442: PPUSH
7443: NOP4
// HideArea ( 6 , AllMapArea ) ;
7447: LD_INT 6
7449: PPUSH
7450: LD_INT 6
7452: PPUSH
7453: NOP4
// ShowArea ( 6 , VisibleMapPartArea ) ;
7457: LD_INT 6
7459: PPUSH
7460: LD_INT 7
7462: PPUSH
7463: NOP4
// SaveForQuickRestart ;
7467: NOP4
// ComEnterUnit ( other_survivors , ru2_arm1 ) ;
7471: NOP4
7475: PPUSH
7476: LD_INT 95
7478: PPUSH
7479: NOP4
// ComEnterUnit ( Belkov , ru2_arm1 ) ;
7483: NOP4
7487: PPUSH
7488: LD_INT 95
7490: PPUSH
7491: NOP4
// if IsPlaced ( Kirilenkova ) then
7495: NOP4
7499: PPUSH
7500: NOP4
7504: IFFALSE 7518
// ComEnterUnit ( Kirilenkova , ru_lab ) ;
7506: NOP4
7510: PPUSH
7511: LD_INT 83
7513: PPUSH
7514: NOP4
// end ;
7518: LD_VAR 0 1
7522: RET
// every 1 trigger not canExploreMap and FilterUnitsInArea ( NorthMoveLimitArea , [ [ f_side , 3 ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) > 0 do var unit ;
7523: NOP4
7527: NOT
7528: PUSH
7529: LD_INT 20
7531: PPUSH
7532: LD_INT 22
7534: PUSH
7535: LD_INT 3
7537: PUSH
7538: EMPTY
7539: LIST
7540: LIST
7541: PUSH
7542: LD_INT 2
7544: PUSH
7545: LD_INT 21
7547: PUSH
7548: LD_INT 1
7550: PUSH
7551: EMPTY
7552: LIST
7553: LIST
7554: PUSH
7555: LD_INT 21
7557: PUSH
7558: LD_INT 2
7560: PUSH
7561: EMPTY
7562: LIST
7563: LIST
7564: PUSH
7565: EMPTY
7566: LIST
7567: LIST
7568: LIST
7569: PUSH
7570: EMPTY
7571: LIST
7572: LIST
7573: PPUSH
7574: NOP4
7578: PUSH
7579: LD_INT 0
7581: GREATER
7582: AND
7583: IFFALSE 7957
7585: GO 7587
7587: DISABLE
7588: LD_INT 0
7590: PPUSH
// begin enable ;
7591: ENABLE
// for unit in FilterUnitsInArea ( NorthMoveLimitArea , [ [ f_side , 3 ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) do
7592: NOP4
7596: PUSH
7597: LD_INT 20
7599: PPUSH
7600: LD_INT 22
7602: PUSH
7603: LD_INT 3
7605: PUSH
7606: EMPTY
7607: LIST
7608: LIST
7609: PUSH
7610: LD_INT 2
7612: PUSH
7613: LD_INT 21
7615: PUSH
7616: LD_INT 1
7618: PUSH
7619: EMPTY
7620: LIST
7621: LIST
7622: PUSH
7623: LD_INT 21
7625: PUSH
7626: LD_INT 2
7628: PUSH
7629: EMPTY
7630: LIST
7631: LIST
7632: PUSH
7633: EMPTY
7634: LIST
7635: LIST
7636: LIST
7637: PUSH
7638: EMPTY
7639: LIST
7640: LIST
7641: PPUSH
7642: NOP4
7646: PUSH
7647: FOR_IN
7648: IFFALSE 7934
// begin ComMoveXY ( unit , GetX ( unit ) , GetY ( unit ) + 5 ) ;
7650: NOP4
7654: PPUSH
7655: NOP4
7659: PPUSH
7660: NOP4
7664: PPUSH
7665: NOP4
7669: PPUSH
7670: NOP4
7674: PUSH
7675: LD_INT 5
7677: PLUS
7678: PPUSH
7679: NOP4
// if not meetPlatonov and not dialogLoopBlocker then
7683: NOP4
7687: NOT
7688: PUSH
7689: NOP4
7693: NOT
7694: AND
7695: IFFALSE 7758
// begin if unit <> Burlak and IsOk ( Kovalyuk ) then
7697: NOP4
7701: PUSH
7702: NOP4
7706: NONEQUAL
7707: PUSH
7708: NOP4
7712: PPUSH
7713: NOP4
7717: AND
7718: IFFALSE 7732
// Say ( Kovalyuk , D1b-Kov-1 ) ;
7720: NOP4
7724: PPUSH
7725: LD_STRING D1b-Kov-1
7727: PPUSH
7728: NOP4
// if unit = Burlak then
7732: NOP4
7736: PUSH
7737: NOP4
7741: EQUAL
7742: IFFALSE 7756
// Say ( Burlak , D1b-Bur-1 ) ;
7744: NOP4
7748: PPUSH
7749: LD_STRING D1b-Bur-1
7751: PPUSH
7752: NOP4
// end else
7756: GO 7777
// if not dialogLoopBlocker then
7758: NOP4
7762: NOT
7763: IFFALSE 7777
// Say ( Platonov , D8-Pla-1 ) ;
7765: NOP4
7769: PPUSH
7770: LD_STRING D8-Pla-1
7772: PPUSH
7773: NOP4
// if not dialogLoopBlocker then
7777: NOP4
7781: NOT
7782: IFFALSE 7792
// dialogLoopBlocker = true ;
7784: NOP4
7788: PUSH
7789: LD_INT 1
7791: ST_TO_ADDR
// repeat ComMoveXY ( FilterUnitsInArea ( NorthMoveLimitArea , [ [ f_side , 3 ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) , GetX ( unit ) , GetY ( unit ) + 5 ) ;
7792: LD_INT 20
7794: PPUSH
7795: LD_INT 22
7797: PUSH
7798: LD_INT 3
7800: PUSH
7801: EMPTY
7802: LIST
7803: LIST
7804: PUSH
7805: LD_INT 2
7807: PUSH
7808: LD_INT 21
7810: PUSH
7811: LD_INT 1
7813: PUSH
7814: EMPTY
7815: LIST
7816: LIST
7817: PUSH
7818: LD_INT 21
7820: PUSH
7821: LD_INT 2
7823: PUSH
7824: EMPTY
7825: LIST
7826: LIST
7827: PUSH
7828: EMPTY
7829: LIST
7830: LIST
7831: LIST
7832: PUSH
7833: EMPTY
7834: LIST
7835: LIST
7836: PPUSH
7837: NOP4
7841: PPUSH
7842: NOP4
7846: PPUSH
7847: NOP4
7851: PPUSH
7852: NOP4
7856: PPUSH
7857: NOP4
7861: PUSH
7862: LD_INT 5
7864: PLUS
7865: PPUSH
7866: NOP4
// wait ( 0 0$1 ) ;
7870: LD_INT 35
7872: PPUSH
7873: NOP4
// until FilterUnitsInArea ( NorthMoveLimitArea , [ [ f_side , 3 ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) = 0 ;
7877: LD_INT 20
7879: PPUSH
7880: LD_INT 22
7882: PUSH
7883: LD_INT 3
7885: PUSH
7886: EMPTY
7887: LIST
7888: LIST
7889: PUSH
7890: LD_INT 2
7892: PUSH
7893: LD_INT 21
7895: PUSH
7896: LD_INT 1
7898: PUSH
7899: EMPTY
7900: LIST
7901: LIST
7902: PUSH
7903: LD_INT 21
7905: PUSH
7906: LD_INT 2
7908: PUSH
7909: EMPTY
7910: LIST
7911: LIST
7912: PUSH
7913: EMPTY
7914: LIST
7915: LIST
7916: LIST
7917: PUSH
7918: EMPTY
7919: LIST
7920: LIST
7921: PPUSH
7922: NOP4
7926: PUSH
7927: LD_INT 0
7929: EQUAL
7930: IFFALSE 7792
// end ;
7932: GO 7647
7934: POP
7935: POP
// if dialogLoopBlocker then
7936: NOP4
7940: IFFALSE 7957
// begin wait ( 0 0$5 ) ;
7942: LD_INT 175
7944: PPUSH
7945: NOP4
// dialogLoopBlocker = false ;
7949: NOP4
7953: PUSH
7954: LD_INT 0
7956: ST_TO_ADDR
// end ; end ;
7957: PPOPN 1
7959: END
// every 1 trigger not canExitBase and FilterUnitsExceptArea ( BeriaBaseArea , [ [ f_side , 3 ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) > 0 do var unit ;
7960: NOP4
7964: NOT
7965: PUSH
7966: LD_INT 8
7968: PPUSH
7969: LD_INT 22
7971: PUSH
7972: LD_INT 3
7974: PUSH
7975: EMPTY
7976: LIST
7977: LIST
7978: PUSH
7979: LD_INT 2
7981: PUSH
7982: LD_INT 21
7984: PUSH
7985: LD_INT 1
7987: PUSH
7988: EMPTY
7989: LIST
7990: LIST
7991: PUSH
7992: LD_INT 21
7994: PUSH
7995: LD_INT 2
7997: PUSH
7998: EMPTY
7999: LIST
8000: LIST
8001: PUSH
8002: EMPTY
8003: LIST
8004: LIST
8005: LIST
8006: PUSH
8007: EMPTY
8008: LIST
8009: LIST
8010: PPUSH
8011: NOP4
8015: PUSH
8016: LD_INT 0
8018: GREATER
8019: AND
8020: IFFALSE 8155
8022: GO 8024
8024: DISABLE
8025: LD_INT 0
8027: PPUSH
// begin enable ;
8028: ENABLE
// for unit in FilterUnitsExceptArea ( BeriaBaseArea , [ [ f_side , 3 ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) do
8029: NOP4
8033: PUSH
8034: LD_INT 8
8036: PPUSH
8037: LD_INT 22
8039: PUSH
8040: LD_INT 3
8042: PUSH
8043: EMPTY
8044: LIST
8045: LIST
8046: PUSH
8047: LD_INT 2
8049: PUSH
8050: LD_INT 21
8052: PUSH
8053: LD_INT 1
8055: PUSH
8056: EMPTY
8057: LIST
8058: LIST
8059: PUSH
8060: LD_INT 21
8062: PUSH
8063: LD_INT 2
8065: PUSH
8066: EMPTY
8067: LIST
8068: LIST
8069: PUSH
8070: EMPTY
8071: LIST
8072: LIST
8073: LIST
8074: PUSH
8075: EMPTY
8076: LIST
8077: LIST
8078: PPUSH
8079: NOP4
8083: PUSH
8084: FOR_IN
8085: IFFALSE 8138
// begin ComMoveXY ( unit , 114 , 98 ) ;
8087: NOP4
8091: PPUSH
8092: LD_INT 114
8094: PPUSH
8095: LD_INT 98
8097: PPUSH
8098: NOP4
// if dialogLoopBlocker then
8102: NOP4
8106: IFFALSE 8112
// exit ;
8108: POP
8109: POP
8110: GO 8155
// dialogLoopBlocker = true ;
8112: NOP4
8116: PUSH
8117: LD_INT 1
8119: ST_TO_ADDR
// Say ( Platonov , D8-Pla-1 ) ;
8120: NOP4
8124: PPUSH
8125: LD_STRING D8-Pla-1
8127: PPUSH
8128: NOP4
// exit ;
8132: POP
8133: POP
8134: GO 8155
// end ;
8136: GO 8084
8138: POP
8139: POP
// wait ( 0 0$5 ) ;
8140: LD_INT 175
8142: PPUSH
8143: NOP4
// dialogLoopBlocker = false ;
8147: NOP4
8151: PUSH
8152: LD_INT 0
8154: ST_TO_ADDR
// end ;
8155: PPOPN 1
8157: END
// every 1 1$30 trigger not meetPlatonov and FilterUnitsInArea ( KirovBaseArea , [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) > 0 do
8158: NOP4
8162: NOT
8163: PUSH
8164: LD_INT 9
8166: PPUSH
8167: LD_INT 22
8169: PUSH
8170: LD_INT 3
8172: PUSH
8173: EMPTY
8174: LIST
8175: LIST
8176: PUSH
8177: LD_INT 21
8179: PUSH
8180: LD_INT 1
8182: PUSH
8183: EMPTY
8184: LIST
8185: LIST
8186: PUSH
8187: EMPTY
8188: LIST
8189: LIST
8190: PPUSH
8191: NOP4
8195: PUSH
8196: LD_INT 0
8198: GREATER
8199: AND
8200: IFFALSE 8217
8202: GO 8204
8204: DISABLE
// Say ( Kurin , D1a-Kur-1 ) ;
8205: NOP4
8209: PPUSH
8210: LD_STRING D1a-Kur-1
8212: PPUSH
8213: NOP4
8217: END
// every 0 0$1 trigger not meetPlatonov and IsOK ( Burlak ) and FilterUnitsInArea ( MeetBeriaBaseArea , [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) > 0 do var i , unit , yourUnits , randomMaleSoldiers , nearRandom ;
8218: NOP4
8222: NOT
8223: PUSH
8224: NOP4
8228: PPUSH
8229: NOP4
8233: AND
8234: PUSH
8235: LD_INT 29
8237: PPUSH
8238: LD_INT 22
8240: PUSH
8241: LD_INT 3
8243: PUSH
8244: EMPTY
8245: LIST
8246: LIST
8247: PUSH
8248: LD_INT 21
8250: PUSH
8251: LD_INT 1
8253: PUSH
8254: EMPTY
8255: LIST
8256: LIST
8257: PUSH
8258: EMPTY
8259: LIST
8260: LIST
8261: PPUSH
8262: NOP4
8266: PUSH
8267: LD_INT 0
8269: GREATER
8270: AND
8271: IFFALSE 8898
8273: GO 8275
8275: DISABLE
8276: LD_INT 0
8278: PPUSH
8279: PPUSH
8280: PPUSH
8281: PPUSH
8282: PPUSH
// begin enable ;
8283: ENABLE
// for unit in FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) do
8284: NOP4
8288: PUSH
8289: LD_INT 22
8291: PUSH
8292: LD_INT 3
8294: PUSH
8295: EMPTY
8296: LIST
8297: LIST
8298: PUSH
8299: LD_INT 21
8301: PUSH
8302: LD_INT 1
8304: PUSH
8305: EMPTY
8306: LIST
8307: LIST
8308: PUSH
8309: EMPTY
8310: LIST
8311: LIST
8312: PPUSH
8313: NOP4
8317: PUSH
8318: FOR_IN
8319: IFFALSE 8896
// if See ( 6 , unit ) then
8321: LD_INT 6
8323: PPUSH
8324: NOP4
8328: PPUSH
8329: NOP4
8333: IFFALSE 8894
// begin meetPlatonov = true ;
8335: NOP4
8339: PUSH
8340: LD_INT 1
8342: ST_TO_ADDR
// InGameOn ;
8343: NOP4
// DialogueOn ;
8347: NOP4
// randomMaleSoldiers = UnitFilter ( platSoldiers , [ f_sex , sex_male ] ) ;
8351: NOP4
8355: PUSH
8356: NOP4
8360: PPUSH
8361: LD_INT 26
8363: PUSH
8364: LD_INT 1
8366: PUSH
8367: EMPTY
8368: LIST
8369: LIST
8370: PPUSH
8371: NOP4
8375: ST_TO_ADDR
// randomMaleSoldiers = randomMaleSoldiers ^ FilterUnitsInArea ( BeriaBaseArea , [ [ f_side , 6 ] , [ f_type , unit_building ] , [ f_btype , b_breastwork ] , [ f_not , [ f_empty ] ] ] ) ;
8376: NOP4
8380: PUSH
8381: NOP4
8385: PUSH
8386: LD_INT 8
8388: PPUSH
8389: LD_INT 22
8391: PUSH
8392: LD_INT 6
8394: PUSH
8395: EMPTY
8396: LIST
8397: LIST
8398: PUSH
8399: LD_INT 21
8401: PUSH
8402: LD_INT 3
8404: PUSH
8405: EMPTY
8406: LIST
8407: LIST
8408: PUSH
8409: LD_INT 30
8411: PUSH
8412: LD_INT 31
8414: PUSH
8415: EMPTY
8416: LIST
8417: LIST
8418: PUSH
8419: LD_INT 3
8421: PUSH
8422: LD_INT 58
8424: PUSH
8425: EMPTY
8426: LIST
8427: PUSH
8428: EMPTY
8429: LIST
8430: LIST
8431: PUSH
8432: EMPTY
8433: LIST
8434: LIST
8435: LIST
8436: LIST
8437: PPUSH
8438: NOP4
8442: ADD
8443: ST_TO_ADDR
// nearRandom = NearestUnitToUnit ( randomMaleSoldiers , unit ) ;
8444: NOP4
8448: PUSH
8449: NOP4
8453: PPUSH
8454: NOP4
8458: PPUSH
8459: NOP4
8463: ST_TO_ADDR
// if GetType ( nearRandom ) = unit_building then
8464: NOP4
8468: PPUSH
8469: NOP4
8473: PUSH
8474: LD_INT 3
8476: EQUAL
8477: IFFALSE 8498
// nearRandom = UnitsInside ( nearRandom ) [ 1 ] ;
8479: NOP4
8483: PUSH
8484: NOP4
8488: PPUSH
8489: NOP4
8493: PUSH
8494: LD_INT 1
8496: ARRAY
8497: ST_TO_ADDR
// DialogRandom ( nearRandom , D2-RSol1-1 ,  , false ) ;
8498: NOP4
8502: PPUSH
8503: LD_STRING D2-RSol1-1
8505: PPUSH
8506: LD_STRING 
8508: PPUSH
8509: LD_INT 0
8511: PPUSH
8512: NOP4
// Say ( Burlak , D2-Bur-1 ) ;
8516: NOP4
8520: PPUSH
8521: LD_STRING D2-Bur-1
8523: PPUSH
8524: NOP4
// Say ( nearRandom , D2-RSol1-2 ) ;
8528: NOP4
8532: PPUSH
8533: LD_STRING D2-RSol1-2
8535: PPUSH
8536: NOP4
// DialogueOff ;
8540: NOP4
// yourUnits = FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_ok ] ] ) ;
8544: NOP4
8548: PUSH
8549: LD_INT 22
8551: PUSH
8552: LD_INT 3
8554: PUSH
8555: EMPTY
8556: LIST
8557: LIST
8558: PUSH
8559: LD_INT 21
8561: PUSH
8562: LD_INT 1
8564: PUSH
8565: EMPTY
8566: LIST
8567: LIST
8568: PUSH
8569: LD_INT 50
8571: PUSH
8572: EMPTY
8573: LIST
8574: PUSH
8575: EMPTY
8576: LIST
8577: LIST
8578: LIST
8579: PPUSH
8580: NOP4
8584: ST_TO_ADDR
// for i := 1 to yourUnits do
8585: NOP4
8589: PUSH
8590: DOUBLE
8591: LD_INT 1
8593: DEC
8594: ST_TO_ADDR
8595: NOP4
8599: PUSH
8600: FOR_TO
8601: IFFALSE 8670
// begin ComMoveXY ( yourUnits [ i ] , meetWithPlatonovPositions [ i ] [ 1 ] , meetWithPlatonovPositions [ i ] [ 2 ] ) ;
8603: NOP4
8607: PUSH
8608: NOP4
8612: ARRAY
8613: PPUSH
8614: NOP4
8618: PUSH
8619: NOP4
8623: ARRAY
8624: PUSH
8625: LD_INT 1
8627: ARRAY
8628: PPUSH
8629: NOP4
8633: PUSH
8634: NOP4
8638: ARRAY
8639: PUSH
8640: LD_INT 2
8642: ARRAY
8643: PPUSH
8644: NOP4
// AddComTurnUnit ( yourUnits [ i ] , Platonov ) ;
8648: NOP4
8652: PUSH
8653: NOP4
8657: ARRAY
8658: PPUSH
8659: NOP4
8663: PPUSH
8664: NOP4
// end ;
8668: GO 8600
8670: POP
8671: POP
// repeat CenterNowOnUnits ( Burlak ) ;
8672: NOP4
8676: PPUSH
8677: NOP4
// wait ( 0 0$1 ) ;
8681: LD_INT 35
8683: PPUSH
8684: NOP4
// until GetDistUnits ( Burlak , Platonov ) < 4 ;
8688: NOP4
8692: PPUSH
8693: NOP4
8697: PPUSH
8698: NOP4
8702: PUSH
8703: LD_INT 4
8705: LESS
8706: IFFALSE 8672
// ComTurnUnit ( Platonov , Burlak ) ;
8708: NOP4
8712: PPUSH
8713: NOP4
8717: PPUSH
8718: NOP4
// Say ( Platonov , D2-Pla-2 ) ;
8722: NOP4
8726: PPUSH
8727: LD_STRING D2-Pla-2
8729: PPUSH
8730: NOP4
// Say ( Burlak , D2-Bur-2 ) ;
8734: NOP4
8738: PPUSH
8739: LD_STRING D2-Bur-2
8741: PPUSH
8742: NOP4
// Say ( Platonov , D2-Pla-3 ) ;
8746: NOP4
8750: PPUSH
8751: LD_STRING D2-Pla-3
8753: PPUSH
8754: NOP4
// Say ( Burlak , D2-Bur-3 ) ;
8758: NOP4
8762: PPUSH
8763: LD_STRING D2-Bur-3
8765: PPUSH
8766: NOP4
// Say ( Platonov , D2-Pla-4 ) ;
8770: NOP4
8774: PPUSH
8775: LD_STRING D2-Pla-4
8777: PPUSH
8778: NOP4
// Say ( Burlak , D2-Bur-4 ) ;
8782: NOP4
8786: PPUSH
8787: LD_STRING D2-Bur-4
8789: PPUSH
8790: NOP4
// Say ( Platonov , D2-Pla-5 ) ;
8794: NOP4
8798: PPUSH
8799: LD_STRING D2-Pla-5
8801: PPUSH
8802: NOP4
// Question1 ( [ 1 , 2 , 3 , 4 ] ) ;
8806: LD_INT 1
8808: PUSH
8809: LD_INT 2
8811: PUSH
8812: LD_INT 3
8814: PUSH
8815: LD_INT 4
8817: PUSH
8818: EMPTY
8819: LIST
8820: LIST
8821: LIST
8822: LIST
8823: PPUSH
8824: NOP4
// Say ( Platonov , D3-Pla-1 ) ;
8828: NOP4
8832: PPUSH
8833: LD_STRING D3-Pla-1
8835: PPUSH
8836: NOP4
// Say ( Burlak , D3-Bur-1 ) ;
8840: NOP4
8844: PPUSH
8845: LD_STRING D3-Bur-1
8847: PPUSH
8848: NOP4
// InGameOff ;
8852: NOP4
// ChangeMissionObjectives ( M2a ) ;
8856: LD_STRING M2a
8858: PPUSH
8859: NOP4
// ComFree ( Platonov ) ;
8863: NOP4
8867: PPUSH
8868: NOP4
// SetSide ( beria , 3 ) ;
8872: LD_INT 106
8874: PPUSH
8875: LD_INT 3
8877: PPUSH
8878: NOP4
// canExitBase = false ;
8882: NOP4
8886: PUSH
8887: LD_INT 0
8889: ST_TO_ADDR
// exit ;
8890: POP
8891: POP
8892: GO 8898
// end ;
8894: GO 8318
8896: POP
8897: POP
// end ;
8898: PPOPN 5
8900: END
// export function Dial_LabConstructed ; begin
8901: LD_INT 0
8903: PPUSH
// labConstructed = true ;
8904: NOP4
8908: PUSH
8909: LD_INT 1
8911: ST_TO_ADDR
// DialogueOn ;
8912: NOP4
// Say ( Burlak , D5a-Bur-1 ) ;
8916: NOP4
8920: PPUSH
8921: LD_STRING D5a-Bur-1
8923: PPUSH
8924: NOP4
// if workshopConstructed then
8928: NOP4
8932: IFFALSE 8948
// Say ( Platonov , D5a-Pla-1 ) else
8934: NOP4
8938: PPUSH
8939: LD_STRING D5a-Pla-1
8941: PPUSH
8942: NOP4
8946: GO 8960
// Say ( Platonov , D5a-Pla-1a ) ;
8948: NOP4
8952: PPUSH
8953: LD_STRING D5a-Pla-1a
8955: PPUSH
8956: NOP4
// DialogueOff ;
8960: NOP4
// ChangeMissionObjectives ( M2b ) ;
8964: LD_STRING M2b
8966: PPUSH
8967: NOP4
// end ;
8971: LD_VAR 0 1
8975: RET
// export function Dial_WorkshopConstructed ; begin
8976: LD_INT 0
8978: PPUSH
// workshopConstructed = true ;
8979: NOP4
8983: PUSH
8984: LD_INT 1
8986: ST_TO_ADDR
// DialogueOn ;
8987: NOP4
// Say ( Burlak , D5b-Bur-1 ) ;
8991: NOP4
8995: PPUSH
8996: LD_STRING D5b-Bur-1
8998: PPUSH
8999: NOP4
// if labConstructed then
9003: NOP4
9007: IFFALSE 9023
// Say ( Platonov , D5b-Pla-1 ) else
9009: NOP4
9013: PPUSH
9014: LD_STRING D5b-Pla-1
9016: PPUSH
9017: NOP4
9021: GO 9035
// Say ( Platonov , D5b-Pla-1a ) ;
9023: NOP4
9027: PPUSH
9028: LD_STRING D5b-Pla-1a
9030: PPUSH
9031: NOP4
// DialogueOff ;
9035: NOP4
// ChangeMissionObjectives ( M2c ) ;
9039: LD_STRING M2c
9041: PPUSH
9042: NOP4
// end ;
9046: LD_VAR 0 1
9050: RET
// export function Dial_StopConstructAgainSameBuilding ( building ) ; begin
9051: LD_INT 0
9053: PPUSH
// wait ( 0 0$1 ) ;
9054: LD_INT 35
9056: PPUSH
9057: NOP4
// CenterNowOnUnits ( building ) ;
9061: NOP4
9065: PPUSH
9066: NOP4
// ComStop ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) ) ;
9070: LD_INT 22
9072: PUSH
9073: LD_INT 3
9075: PUSH
9076: EMPTY
9077: LIST
9078: LIST
9079: PUSH
9080: LD_INT 21
9082: PUSH
9083: LD_INT 1
9085: PUSH
9086: EMPTY
9087: LIST
9088: LIST
9089: PUSH
9090: EMPTY
9091: LIST
9092: LIST
9093: PPUSH
9094: NOP4
9098: PPUSH
9099: NOP4
// DialogueOn ;
9103: NOP4
// Say ( Platonov , D6-Pla-1 ) ;
9107: NOP4
9111: PPUSH
9112: LD_STRING D6-Pla-1
9114: PPUSH
9115: NOP4
// Say ( Burlak , D6-Bur-1 ) ;
9119: NOP4
9123: PPUSH
9124: LD_STRING D6-Bur-1
9126: PPUSH
9127: NOP4
// DialogueOff ;
9131: NOP4
// case GetBType ( building ) of b_lab :
9135: NOP4
9139: PPUSH
9140: NOP4
9144: PUSH
9145: LD_INT 6
9147: DOUBLE
9148: EQUAL
9149: IFTRUE 9153
9151: GO 9193
9153: POP
// SetResourceType ( GetBase ( beria ) , mat_cans , GetResourceType ( GetBase ( beria ) , mat_cans ) + labCratesRefund ) ; b_workshop :
9154: LD_INT 106
9156: PPUSH
9157: NOP4
9161: PPUSH
9162: LD_INT 1
9164: PPUSH
9165: LD_INT 106
9167: PPUSH
9168: NOP4
9172: PPUSH
9173: LD_INT 1
9175: PPUSH
9176: NOP4
9180: PUSH
9181: NOP4
9185: PLUS
9186: PPUSH
9187: NOP4
9191: GO 9386
9193: LD_INT 2
9195: DOUBLE
9196: EQUAL
9197: IFTRUE 9201
9199: GO 9241
9201: POP
// SetResourceType ( GetBase ( beria ) , mat_cans , GetResourceType ( GetBase ( beria ) , mat_cans ) + workshopCratesRefund ) ; b_oil_power :
9202: LD_INT 106
9204: PPUSH
9205: NOP4
9209: PPUSH
9210: LD_INT 1
9212: PPUSH
9213: LD_INT 106
9215: PPUSH
9216: NOP4
9220: PPUSH
9221: LD_INT 1
9223: PPUSH
9224: NOP4
9228: PUSH
9229: NOP4
9233: PLUS
9234: PPUSH
9235: NOP4
9239: GO 9386
9241: LD_INT 26
9243: DOUBLE
9244: EQUAL
9245: IFTRUE 9249
9247: GO 9289
9249: POP
// SetResourceType ( GetBase ( beria ) , mat_cans , GetResourceType ( GetBase ( beria ) , mat_cans ) + oilPowerCratesRefund ) ; b_armoury :
9250: LD_INT 106
9252: PPUSH
9253: NOP4
9257: PPUSH
9258: LD_INT 1
9260: PPUSH
9261: LD_INT 106
9263: PPUSH
9264: NOP4
9268: PPUSH
9269: LD_INT 1
9271: PPUSH
9272: NOP4
9276: PUSH
9277: NOP4
9281: PLUS
9282: PPUSH
9283: NOP4
9287: GO 9386
9289: LD_INT 4
9291: DOUBLE
9292: EQUAL
9293: IFTRUE 9297
9295: GO 9337
9297: POP
// SetResourceType ( GetBase ( beria ) , mat_cans , GetResourceType ( GetBase ( beria ) , mat_cans ) + armouryCratesRefund ) ; b_breastwork :
9298: LD_INT 106
9300: PPUSH
9301: NOP4
9305: PPUSH
9306: LD_INT 1
9308: PPUSH
9309: LD_INT 106
9311: PPUSH
9312: NOP4
9316: PPUSH
9317: LD_INT 1
9319: PPUSH
9320: NOP4
9324: PUSH
9325: NOP4
9329: PLUS
9330: PPUSH
9331: NOP4
9335: GO 9386
9337: LD_INT 31
9339: DOUBLE
9340: EQUAL
9341: IFTRUE 9345
9343: GO 9385
9345: POP
// SetResourceType ( GetBase ( beria ) , mat_cans , GetResourceType ( GetBase ( beria ) , mat_cans ) + bunkerCratesRefund ) ; end ;
9346: LD_INT 106
9348: PPUSH
9349: NOP4
9353: PPUSH
9354: LD_INT 1
9356: PPUSH
9357: LD_INT 106
9359: PPUSH
9360: NOP4
9364: PPUSH
9365: LD_INT 1
9367: PPUSH
9368: NOP4
9372: PUSH
9373: NOP4
9377: PLUS
9378: PPUSH
9379: NOP4
9383: GO 9386
9385: POP
// RemoveUnit ( building ) ;
9386: NOP4
9390: PPUSH
9391: NOP4
// end ;
9395: LD_VAR 0 2
9399: RET
// every 0 0$2 trigger workshopConstructed and labConstructed do
9400: NOP4
9404: PUSH
9405: NOP4
9409: AND
9410: IFFALSE 9519
9412: GO 9414
9414: DISABLE
// begin DialogueOn ;
9415: NOP4
// if engineResearched then
9419: NOP4
9423: IFFALSE 9451
// begin Say ( Burlak , D7b-Bur-1 ) ;
9425: NOP4
9429: PPUSH
9430: LD_STRING D7b-Bur-1
9432: PPUSH
9433: NOP4
// Say ( Platonov , D7b-Pla-1 ) ;
9437: NOP4
9441: PPUSH
9442: LD_STRING D7b-Pla-1
9444: PPUSH
9445: NOP4
// end else
9449: GO 9475
// begin Say ( Burlak , D7a-Bur-1 ) ;
9451: NOP4
9455: PPUSH
9456: LD_STRING D7a-Bur-1
9458: PPUSH
9459: NOP4
// Say ( Platonov , D7a-Pla-1 ) ;
9463: NOP4
9467: PPUSH
9468: LD_STRING D7a-Pla-1
9470: PPUSH
9471: NOP4
// end ; DialogueOff ;
9475: NOP4
// ChangeMissionObjectives ( M2 ) ;
9479: LD_STRING M2
9481: PPUSH
9482: NOP4
// CreateCratesXYR ( 3 , GetX ( Platonov ) , GetY ( Platonov ) , 5 , true ) ;
9486: LD_INT 3
9488: PPUSH
9489: NOP4
9493: PPUSH
9494: NOP4
9498: PPUSH
9499: NOP4
9503: PPUSH
9504: NOP4
9508: PPUSH
9509: LD_INT 5
9511: PPUSH
9512: LD_INT 1
9514: PPUSH
9515: NOP4
// end ;
9519: END
// export function Dial_NewCrates ( x , y ) ; begin
9520: LD_INT 0
9522: PPUSH
// wait ( 0 0$18 ) ;
9523: LD_INT 630
9525: PPUSH
9526: NOP4
// if not spawnCrates then
9530: NOP4
9534: NOT
9535: IFFALSE 9539
// exit ;
9537: GO 9570
// ComMoveXY ( Platonov , x , y ) ;
9539: NOP4
9543: PPUSH
9544: NOP4
9548: PPUSH
9549: NOP4
9553: PPUSH
9554: NOP4
// Say ( Platonov , D4-Pla-1 ) ;
9558: NOP4
9562: PPUSH
9563: LD_STRING D4-Pla-1
9565: PPUSH
9566: NOP4
// end ;
9570: LD_VAR 0 3
9574: RET
// export function Dial_FirstVehConstructed ( factory ) ; begin
9575: LD_INT 0
9577: PPUSH
// firstVeh = FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_vehicle ] ] ) [ 1 ] ;
9578: NOP4
9582: PUSH
9583: LD_INT 22
9585: PUSH
9586: LD_INT 3
9588: PUSH
9589: EMPTY
9590: LIST
9591: LIST
9592: PUSH
9593: LD_INT 21
9595: PUSH
9596: LD_INT 2
9598: PUSH
9599: EMPTY
9600: LIST
9601: LIST
9602: PUSH
9603: EMPTY
9604: LIST
9605: LIST
9606: PPUSH
9607: NOP4
9611: PUSH
9612: LD_INT 1
9614: ARRAY
9615: ST_TO_ADDR
// constructedFirstVehicle = true ;
9616: NOP4
9620: PUSH
9621: LD_INT 1
9623: ST_TO_ADDR
// InGameOn ;
9624: NOP4
// CenterNowOnUnits ( factory ) ;
9628: NOP4
9632: PPUSH
9633: NOP4
// wait ( 0 0$3 ) ;
9637: LD_INT 105
9639: PPUSH
9640: NOP4
// Say ( Burlak , D9-Bur-1 ) ;
9644: NOP4
9648: PPUSH
9649: LD_STRING D9-Bur-1
9651: PPUSH
9652: NOP4
// ComMoveXY ( Platonov , GetX ( firstVeh ) , GetY ( firstVeh ) ) ;
9656: NOP4
9660: PPUSH
9661: NOP4
9665: PPUSH
9666: NOP4
9670: PPUSH
9671: NOP4
9675: PPUSH
9676: NOP4
9680: PPUSH
9681: NOP4
// repeat wait ( 0 0$1 ) ;
9685: LD_INT 35
9687: PPUSH
9688: NOP4
// until GetDistUnits ( Platonov , firstVeh ) < 4 ;
9692: NOP4
9696: PPUSH
9697: NOP4
9701: PPUSH
9702: NOP4
9706: PUSH
9707: LD_INT 4
9709: LESS
9710: IFFALSE 9685
// ComTurnUnit ( Platonov , firstVeh ) ;
9712: NOP4
9716: PPUSH
9717: NOP4
9721: PPUSH
9722: NOP4
// Say ( Platonov , D9-Pla-1 ) ;
9726: NOP4
9730: PPUSH
9731: LD_STRING D9-Pla-1
9733: PPUSH
9734: NOP4
// InGameOff ;
9738: NOP4
// ChangeMissionObjectives ( M3 ) ;
9742: LD_STRING M3
9744: PPUSH
9745: NOP4
// canExitBase = true ;
9749: NOP4
9753: PUSH
9754: LD_INT 1
9756: ST_TO_ADDR
// ComMoveXY ( Platonov , 112 , 97 ) ;
9757: NOP4
9761: PPUSH
9762: LD_INT 112
9764: PPUSH
9765: LD_INT 97
9767: PPUSH
9768: NOP4
// end ;
9772: LD_VAR 0 2
9776: RET
// every 0 0$1 trigger IsInArea ( firstVeh , KirovBaseArea ) and not vehicleForKurin do var i , eng , mech ;
9777: NOP4
9781: PPUSH
9782: LD_INT 9
9784: PPUSH
9785: NOP4
9789: PUSH
9790: NOP4
9794: NOT
9795: AND
9796: IFFALSE 10650
9798: GO 9800
9800: DISABLE
9801: LD_INT 0
9803: PPUSH
9804: PPUSH
9805: PPUSH
// begin vehicleForKurin = true ;
9806: NOP4
9810: PUSH
9811: LD_INT 1
9813: ST_TO_ADDR
// eng = UnitFilter ( otherKirovUnits , [ f_class , class_engineer ] ) [ 1 ] ;
9814: NOP4
9818: PUSH
9819: NOP4
9823: PPUSH
9824: LD_INT 25
9826: PUSH
9827: LD_INT 2
9829: PUSH
9830: EMPTY
9831: LIST
9832: LIST
9833: PPUSH
9834: NOP4
9838: PUSH
9839: LD_INT 1
9841: ARRAY
9842: ST_TO_ADDR
// mech = UnitFilter ( otherKirovUnits , [ f_class , class_mechanic ] ) [ 1 ] ;
9843: NOP4
9847: PUSH
9848: NOP4
9852: PPUSH
9853: LD_INT 25
9855: PUSH
9856: LD_INT 3
9858: PUSH
9859: EMPTY
9860: LIST
9861: LIST
9862: PPUSH
9863: NOP4
9867: PUSH
9868: LD_INT 1
9870: ARRAY
9871: ST_TO_ADDR
// InGameOn ;
9872: NOP4
// CenterNowOnUnits ( Kurin ) ;
9876: NOP4
9880: PPUSH
9881: NOP4
// ComMoveXY ( firstVeh , GetX ( Kurin ) , GetY ( Kurin ) ) ;
9885: NOP4
9889: PPUSH
9890: NOP4
9894: PPUSH
9895: NOP4
9899: PPUSH
9900: NOP4
9904: PPUSH
9905: NOP4
9909: PPUSH
9910: NOP4
// Say ( Kurin , D10-Kur-1 ) ;
9914: NOP4
9918: PPUSH
9919: LD_STRING D10-Kur-1
9921: PPUSH
9922: NOP4
// repeat wait ( 0 0$1 ) ;
9926: LD_INT 35
9928: PPUSH
9929: NOP4
// ComMoveXY ( firstVeh , GetX ( Kurin ) , GetY ( Kurin ) ) ;
9933: NOP4
9937: PPUSH
9938: NOP4
9942: PPUSH
9943: NOP4
9947: PPUSH
9948: NOP4
9952: PPUSH
9953: NOP4
9957: PPUSH
9958: NOP4
// until GetDistUnits ( firstVeh , Kurin ) < 9 ;
9962: NOP4
9966: PPUSH
9967: NOP4
9971: PPUSH
9972: NOP4
9976: PUSH
9977: LD_INT 9
9979: LESS
9980: IFFALSE 9926
// ComExitVehicle ( UnitsInside ( firstVeh ) ) ;
9982: NOP4
9986: PPUSH
9987: NOP4
9991: PPUSH
9992: NOP4
// wait ( 0 0$1 ) ;
9996: LD_INT 35
9998: PPUSH
9999: NOP4
// if GetLives ( firstVeh ) < 1000 then
10003: NOP4
10007: PPUSH
10008: NOP4
10012: PUSH
10013: LD_INT 1000
10015: LESS
10016: IFFALSE 10048
// begin ComExitBuilding ( mech ) ;
10018: NOP4
10022: PPUSH
10023: NOP4
// wait ( 0 0$1 ) ;
10027: LD_INT 35
10029: PPUSH
10030: NOP4
// AddComRepairVehicle ( mech , firstVeh ) ;
10034: NOP4
10038: PPUSH
10039: NOP4
10043: PPUSH
10044: NOP4
// end ; if GetFuel ( firstVeh ) < 90 then
10048: NOP4
10052: PPUSH
10053: NOP4
10057: PUSH
10058: LD_INT 90
10060: LESS
10061: IFFALSE 10096
// begin ComExitBuilding ( eng ) ;
10063: NOP4
10067: PPUSH
10068: NOP4
// wait ( 0 0$1 ) ;
10072: LD_INT 35
10074: PPUSH
10075: NOP4
// ExtAddComRefuel ( eng , kirov , firstVeh ) ;
10079: NOP4
10083: PPUSH
10084: LD_INT 71
10086: PPUSH
10087: NOP4
10091: PPUSH
10092: NOP4
// end ; repeat wait ( 0 0$1 ) ;
10096: LD_INT 35
10098: PPUSH
10099: NOP4
// until GetLives ( firstVeh ) = 1000 and GetFuel ( firstVeh ) > 90 ;
10103: NOP4
10107: PPUSH
10108: NOP4
10112: PUSH
10113: LD_INT 1000
10115: EQUAL
10116: PUSH
10117: NOP4
10121: PPUSH
10122: NOP4
10126: PUSH
10127: LD_INT 90
10129: GREATER
10130: AND
10131: IFFALSE 10096
// if UnitsInside ( firstVeh ) then
10133: NOP4
10137: PPUSH
10138: NOP4
10142: IFFALSE 10162
// ComExitVehicle ( UnitsInside ( firstVeh ) [ 1 ] ) ;
10144: NOP4
10148: PPUSH
10149: NOP4
10153: PUSH
10154: LD_INT 1
10156: ARRAY
10157: PPUSH
10158: NOP4
// ComEnterUnit ( eng , kirov ) ;
10162: NOP4
10166: PPUSH
10167: LD_INT 71
10169: PPUSH
10170: NOP4
// SetSide ( firstVeh , 6 ) ;
10174: NOP4
10178: PPUSH
10179: LD_INT 6
10181: PPUSH
10182: NOP4
// if belkovReturn then
10186: NOP4
10190: IFFALSE 10276
// begin if IsInUnit ( Belkov ) then
10192: NOP4
10196: PPUSH
10197: NOP4
10201: IFFALSE 10212
// ComExitBuilding ( Belkov ) ;
10203: NOP4
10207: PPUSH
10208: NOP4
// repeat wait ( 0 0$1 ) ;
10212: LD_INT 35
10214: PPUSH
10215: NOP4
// AddComEnterUnit ( Belkov , firstVeh ) ;
10219: NOP4
10223: PPUSH
10224: NOP4
10228: PPUSH
10229: NOP4
// until IsInUnit ( Belkov ) = firstVeh ;
10233: NOP4
10237: PPUSH
10238: NOP4
10242: PUSH
10243: NOP4
10247: EQUAL
10248: IFFALSE 10212
// Say ( Belkov , D10-Bel-1 ) ;
10250: NOP4
10254: PPUSH
10255: LD_STRING D10-Bel-1
10257: PPUSH
10258: NOP4
// Say ( Kurin , D10-Kur-2 ) ;
10262: NOP4
10266: PPUSH
10267: LD_STRING D10-Kur-2
10269: PPUSH
10270: NOP4
// end else
10274: GO 10402
// begin if IsInUnit ( Belkov2 ) then
10276: NOP4
10280: PPUSH
10281: NOP4
10285: IFFALSE 10296
// ComExitBuilding ( Belkov2 ) ;
10287: NOP4
10291: PPUSH
10292: NOP4
// repeat wait ( 0 0$1 ) ;
10296: LD_INT 35
10298: PPUSH
10299: NOP4
// AddComEnterUnit ( Belkov2 , firstVeh ) ;
10303: NOP4
10307: PPUSH
10308: NOP4
10312: PPUSH
10313: NOP4
// until IsInUnit ( Belkov2 ) = firstVeh ;
10317: NOP4
10321: PPUSH
10322: NOP4
10326: PUSH
10327: NOP4
10331: EQUAL
10332: IFFALSE 10296
// meetBelkovBrother = true ;
10334: NOP4
10338: PUSH
10339: LD_INT 1
10341: ST_TO_ADDR
// Say ( Belkov2 , D10-Bel-1 ) ;
10342: NOP4
10346: PPUSH
10347: LD_STRING D10-Bel-1
10349: PPUSH
10350: NOP4
// Say ( Burlak , D10-Bur-1 ) ;
10354: NOP4
10358: PPUSH
10359: LD_STRING D10-Bur-1
10361: PPUSH
10362: NOP4
// Say ( Belkov2 , D10-Bel-2 ) ;
10366: NOP4
10370: PPUSH
10371: LD_STRING D10-Bel-2
10373: PPUSH
10374: NOP4
// Say ( Burlak , D10-Bur-2 ) ;
10378: NOP4
10382: PPUSH
10383: LD_STRING D10-Bur-2
10385: PPUSH
10386: NOP4
// Say ( Kurin , D10-Kur-2a ) ;
10390: NOP4
10394: PPUSH
10395: LD_STRING D10-Kur-2a
10397: PPUSH
10398: NOP4
// end ; removedBelkovUntisSaved = [ ] ;
10402: NOP4
10406: PUSH
10407: EMPTY
10408: ST_TO_ADDR
// removedBelkovVehicleSaved = [ ] ;
10409: NOP4
10413: PUSH
10414: EMPTY
10415: ST_TO_ADDR
// canRemoveBelkovUnits = true ;
10416: NOP4
10420: PUSH
10421: LD_INT 1
10423: ST_TO_ADDR
// CreateBelkovTeam ;
10424: NOP4
// ComExitBuilding ( belkovTeam ) ;
10428: NOP4
10432: PPUSH
10433: NOP4
// wait ( 0 0$1 ) ;
10437: LD_INT 35
10439: PPUSH
10440: NOP4
// kirovVehicle = FilterAllUnits ( [ [ f_side , 6 ] , [ f_type , unit_vehicle ] ] ) [ 1 ] ;
10444: NOP4
10448: PUSH
10449: LD_INT 22
10451: PUSH
10452: LD_INT 6
10454: PUSH
10455: EMPTY
10456: LIST
10457: LIST
10458: PUSH
10459: LD_INT 21
10461: PUSH
10462: LD_INT 2
10464: PUSH
10465: EMPTY
10466: LIST
10467: LIST
10468: PUSH
10469: EMPTY
10470: LIST
10471: LIST
10472: PPUSH
10473: NOP4
10477: PUSH
10478: LD_INT 1
10480: ARRAY
10481: ST_TO_ADDR
// belkovTeam = belkovTeam ^ kirovVehicle ;
10482: NOP4
10486: PUSH
10487: NOP4
10491: PUSH
10492: NOP4
10496: ADD
10497: ST_TO_ADDR
// ComMoveXY ( belkovTeam , 147 , 102 ) ;
10498: NOP4
10502: PPUSH
10503: LD_INT 147
10505: PPUSH
10506: LD_INT 102
10508: PPUSH
10509: NOP4
// AddComMoveXY ( belkovTeam , 133 , 94 ) ;
10513: NOP4
10517: PPUSH
10518: LD_INT 133
10520: PPUSH
10521: LD_INT 94
10523: PPUSH
10524: NOP4
// AddComMoveXY ( belkovTeam , 123 , 74 ) ;
10528: NOP4
10532: PPUSH
10533: LD_INT 123
10535: PPUSH
10536: LD_INT 74
10538: PPUSH
10539: NOP4
// AddComMoveXY ( belkovTeam , 111 , 48 ) ;
10543: NOP4
10547: PPUSH
10548: LD_INT 111
10550: PPUSH
10551: LD_INT 48
10553: PPUSH
10554: NOP4
// AddComMoveXY ( belkovTeam , 122 , 43 ) ;
10558: NOP4
10562: PPUSH
10563: LD_INT 122
10565: PPUSH
10566: LD_INT 43
10568: PPUSH
10569: NOP4
// AddComMoveXY ( belkovTeam , 129 , 32 ) ;
10573: NOP4
10577: PPUSH
10578: LD_INT 129
10580: PPUSH
10581: LD_INT 32
10583: PPUSH
10584: NOP4
// AddComMoveXY ( belkovTeam , 132 , 22 ) ;
10588: NOP4
10592: PPUSH
10593: LD_INT 132
10595: PPUSH
10596: LD_INT 22
10598: PPUSH
10599: NOP4
// wait ( 0 0$8 ) ;
10603: LD_INT 280
10605: PPUSH
10606: NOP4
// CenterNowOnUnits ( Kurin ) ;
10610: NOP4
10614: PPUSH
10615: NOP4
// Say ( Kurin , D10-Kur-2b ) ;
10619: NOP4
10623: PPUSH
10624: LD_STRING D10-Kur-2b
10626: PPUSH
10627: NOP4
// InGameOff ;
10631: NOP4
// ChangeMissionObjectives ( M4 ) ;
10635: LD_STRING M4
10637: PPUSH
10638: NOP4
// backToBeria1 = true ;
10642: NOP4
10646: PUSH
10647: LD_INT 1
10649: ST_TO_ADDR
// end ;
10650: PPOPN 3
10652: END
// every 0 0$1 trigger FilterUnitsInArea ( KirovBaseArea , [ [ f_side , 3 ] , [ f_type , unit_vehicle ] ] ) and vehicleForKurin do
10653: LD_INT 9
10655: PPUSH
10656: LD_INT 22
10658: PUSH
10659: LD_INT 3
10661: PUSH
10662: EMPTY
10663: LIST
10664: LIST
10665: PUSH
10666: LD_INT 21
10668: PUSH
10669: LD_INT 2
10671: PUSH
10672: EMPTY
10673: LIST
10674: LIST
10675: PUSH
10676: EMPTY
10677: LIST
10678: LIST
10679: PPUSH
10680: NOP4
10684: PUSH
10685: NOP4
10689: AND
10690: IFFALSE 10707
10692: GO 10694
10694: DISABLE
// Say ( Kurin , D1a-Kur-1a ) ;
10695: NOP4
10699: PPUSH
10700: LD_STRING D1a-Kur-1a
10702: PPUSH
10703: NOP4
10707: END
// every 1 trigger canRemoveBelkovUnits do var unit , driver ;
10708: NOP4
10712: IFFALSE 11115
10714: GO 10716
10716: DISABLE
10717: LD_INT 0
10719: PPUSH
10720: PPUSH
// begin enable ;
10721: ENABLE
// if FilterUnitsInArea ( BelkovExitArea , [ f_side , 6 ] ) = 0 then
10722: LD_INT 10
10724: PPUSH
10725: LD_INT 22
10727: PUSH
10728: LD_INT 6
10730: PUSH
10731: EMPTY
10732: LIST
10733: LIST
10734: PPUSH
10735: NOP4
10739: PUSH
10740: LD_INT 0
10742: EQUAL
10743: IFFALSE 10747
// exit ;
10745: GO 11115
// for unit in FilterUnitsInArea ( BelkovExitArea , [ f_side , 6 ] ) do
10747: NOP4
10751: PUSH
10752: LD_INT 10
10754: PPUSH
10755: LD_INT 22
10757: PUSH
10758: LD_INT 6
10760: PUSH
10761: EMPTY
10762: LIST
10763: LIST
10764: PPUSH
10765: NOP4
10769: PUSH
10770: FOR_IN
10771: IFFALSE 11101
// begin if GetType ( unit ) = unit_human and ( not unit = Belkov and not unit = Belkov2 and not unit = Kirilenkova ) then
10773: NOP4
10777: PPUSH
10778: NOP4
10782: PUSH
10783: LD_INT 1
10785: EQUAL
10786: PUSH
10787: NOP4
10791: PUSH
10792: NOP4
10796: EQUAL
10797: NOT
10798: PUSH
10799: NOP4
10803: PUSH
10804: NOP4
10808: EQUAL
10809: NOT
10810: AND
10811: PUSH
10812: NOP4
10816: PUSH
10817: NOP4
10821: EQUAL
10822: NOT
10823: AND
10824: AND
10825: IFFALSE 10866
// begin removedBelkovUntis = removedBelkovUntis + 1 ;
10827: NOP4
10831: PUSH
10832: NOP4
10836: PUSH
10837: LD_INT 1
10839: PLUS
10840: ST_TO_ADDR
// removedBelkovUntisSaved = removedBelkovUntisSaved ^ unit ;
10841: NOP4
10845: PUSH
10846: NOP4
10850: PUSH
10851: NOP4
10855: ADD
10856: ST_TO_ADDR
// RemoveUnit ( unit ) ;
10857: NOP4
10861: PPUSH
10862: NOP4
// end ; if unit = Kirilenkova then
10866: NOP4
10870: PUSH
10871: NOP4
10875: EQUAL
10876: IFFALSE 10899
// begin SaveCharacters ( Kirilenkova , 02_TmpKirilenkova ) ;
10878: NOP4
10882: PPUSH
10883: LD_STRING 02_TmpKirilenkova
10885: PPUSH
10886: NOP4
// RemoveUnit ( unit ) ;
10890: NOP4
10894: PPUSH
10895: NOP4
// end ; if unit = Belkov2 then
10899: NOP4
10903: PUSH
10904: NOP4
10908: EQUAL
10909: IFFALSE 10932
// begin SaveCharacters ( Belkov2 , 02_TmpBelkov2 ) ;
10911: NOP4
10915: PPUSH
10916: LD_STRING 02_TmpBelkov2
10918: PPUSH
10919: NOP4
// RemoveUnit ( unit ) ;
10923: NOP4
10927: PPUSH
10928: NOP4
// end ; if GetType ( unit ) = unit_vehicle then
10932: NOP4
10936: PPUSH
10937: NOP4
10941: PUSH
10942: LD_INT 2
10944: EQUAL
10945: IFFALSE 11099
// begin driver = UnitsInside ( unit ) ;
10947: NOP4
10951: PUSH
10952: NOP4
10956: PPUSH
10957: NOP4
10961: ST_TO_ADDR
// if driver [ 1 ] = Belkov then
10962: NOP4
10966: PUSH
10967: LD_INT 1
10969: ARRAY
10970: PUSH
10971: NOP4
10975: EQUAL
10976: IFFALSE 11001
// begin SaveCharacters ( Belkov , 02_TmpBelkov ) ;
10978: NOP4
10982: PPUSH
10983: LD_STRING 02_TmpBelkov
10985: PPUSH
10986: NOP4
// RemoveUnit ( unit ) ;
10990: NOP4
10994: PPUSH
10995: NOP4
// end else
10999: GO 11022
// begin SaveCharacters ( Belkov2 , 02_TmpBelkov2 ) ;
11001: NOP4
11005: PPUSH
11006: LD_STRING 02_TmpBelkov2
11008: PPUSH
11009: NOP4
// RemoveUnit ( unit ) ;
11013: NOP4
11017: PPUSH
11018: NOP4
// end ; removedBelkovVehicleSaved = removedBelkovVehicleSaved ^ [ GetChassis ( unit ) , GetEngine ( unit ) , GetControl ( unit ) , GetWeapon ( unit ) , GetFuel ( unit ) ] ;
11022: NOP4
11026: PUSH
11027: NOP4
11031: PUSH
11032: NOP4
11036: PPUSH
11037: NOP4
11041: PUSH
11042: NOP4
11046: PPUSH
11047: NOP4
11051: PUSH
11052: NOP4
11056: PPUSH
11057: NOP4
11061: PUSH
11062: NOP4
11066: PPUSH
11067: NOP4
11071: PUSH
11072: NOP4
11076: PPUSH
11077: NOP4
11081: PUSH
11082: EMPTY
11083: LIST
11084: LIST
11085: LIST
11086: LIST
11087: LIST
11088: ADD
11089: ST_TO_ADDR
// RemoveUnit ( unit ) ;
11090: NOP4
11094: PPUSH
11095: NOP4
// end ; end ;
11099: GO 10770
11101: POP
11102: POP
// SaveCharacters ( removedBelkovUntisSaved , 02_TmpBelkovTeam ) ;
11103: NOP4
11107: PPUSH
11108: LD_STRING 02_TmpBelkovTeam
11110: PPUSH
11111: NOP4
// end ;
11115: PPOPN 2
11117: END
// every 0 0$1 trigger FilterUnitsExceptArea ( BeriaBaseArea , [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) = 0 and backToBeria1 do var engs ;
11118: LD_INT 8
11120: PPUSH
11121: LD_INT 22
11123: PUSH
11124: LD_INT 3
11126: PUSH
11127: EMPTY
11128: LIST
11129: LIST
11130: PUSH
11131: LD_INT 21
11133: PUSH
11134: LD_INT 1
11136: PUSH
11137: EMPTY
11138: LIST
11139: LIST
11140: PUSH
11141: EMPTY
11142: LIST
11143: LIST
11144: PPUSH
11145: NOP4
11149: PUSH
11150: LD_INT 0
11152: EQUAL
11153: PUSH
11154: NOP4
11158: AND
11159: IFFALSE 11366
11161: GO 11163
11163: DISABLE
11164: LD_INT 0
11166: PPUSH
// begin engs = UnitFilter ( otherKirovUnits , [ f_class , class_engineer ] ) ;
11167: NOP4
11171: PUSH
11172: NOP4
11176: PPUSH
11177: LD_INT 25
11179: PUSH
11180: LD_INT 2
11182: PUSH
11183: EMPTY
11184: LIST
11185: LIST
11186: PPUSH
11187: NOP4
11191: ST_TO_ADDR
// backToBeria1 = false ;
11192: NOP4
11196: PUSH
11197: LD_INT 0
11199: ST_TO_ADDR
// canExitBase = false ;
11200: NOP4
11204: PUSH
11205: LD_INT 0
11207: ST_TO_ADDR
// Say ( Platonov , D11-Pla-1 ) ;
11208: NOP4
11212: PPUSH
11213: LD_STRING D11-Pla-1
11215: PPUSH
11216: NOP4
// if FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) > 1 then
11220: LD_INT 22
11222: PUSH
11223: LD_INT 3
11225: PUSH
11226: EMPTY
11227: LIST
11228: LIST
11229: PUSH
11230: LD_INT 21
11232: PUSH
11233: LD_INT 1
11235: PUSH
11236: EMPTY
11237: LIST
11238: LIST
11239: PUSH
11240: EMPTY
11241: LIST
11242: LIST
11243: PPUSH
11244: NOP4
11248: PUSH
11249: LD_INT 1
11251: GREATER
11252: IFFALSE 11268
// Say ( Burlak , D11-Bur-1a ) else
11254: NOP4
11258: PPUSH
11259: LD_STRING D11-Bur-1a
11261: PPUSH
11262: NOP4
11266: GO 11280
// Say ( Burlak , D11-Bur-1 ) ;
11268: NOP4
11272: PPUSH
11273: LD_STRING D11-Bur-1
11275: PPUSH
11276: NOP4
// ChangeMissionObjectives ( M5 ) ;
11280: LD_STRING M5
11282: PPUSH
11283: NOP4
// CreateCratesArea ( rand ( 1 , 5 ) , CratesArea , true ) ;
11287: LD_INT 1
11289: PPUSH
11290: LD_INT 5
11292: PPUSH
11293: NOP4
11297: PPUSH
11298: LD_INT 26
11300: PPUSH
11301: LD_INT 1
11303: PPUSH
11304: NOP4
// construcMoreVehicles = true ;
11308: NOP4
11312: PUSH
11313: LD_INT 1
11315: ST_TO_ADDR
// spawnCrates = true ;
11316: NOP4
11320: PUSH
11321: LD_INT 1
11323: ST_TO_ADDR
// AddComExitBuilding ( engs ) ;
11324: NOP4
11328: PPUSH
11329: NOP4
// AddComBuild ( engs , b_workshop , 159 , 112 , 0 ) ;
11333: NOP4
11337: PPUSH
11338: LD_INT 2
11340: PPUSH
11341: LD_INT 159
11343: PPUSH
11344: LD_INT 112
11346: PPUSH
11347: LD_INT 0
11349: PPUSH
11350: NOP4
// AddComEnterUnit ( engs , kirov ) ;
11354: NOP4
11358: PPUSH
11359: LD_INT 71
11361: PPUSH
11362: NOP4
// end ;
11366: PPOPN 1
11368: END
// every 0 0$1 trigger constructedVehiclesCounter >= FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) do var tmpBelkov , nearRuUnit ;
11369: NOP4
11373: PUSH
11374: LD_INT 22
11376: PUSH
11377: LD_INT 3
11379: PUSH
11380: EMPTY
11381: LIST
11382: LIST
11383: PUSH
11384: LD_INT 21
11386: PUSH
11387: LD_INT 1
11389: PUSH
11390: EMPTY
11391: LIST
11392: LIST
11393: PUSH
11394: EMPTY
11395: LIST
11396: LIST
11397: PPUSH
11398: NOP4
11402: GREATEREQUAL
11403: IFFALSE 12531
11405: GO 11407
11407: DISABLE
11408: LD_INT 0
11410: PPUSH
11411: PPUSH
// begin canRemoveBelkovUnits = false ;
11412: NOP4
11416: PUSH
11417: LD_INT 0
11419: ST_TO_ADDR
// spawnCrates = false ;
11420: NOP4
11424: PUSH
11425: LD_INT 0
11427: ST_TO_ADDR
// ComStop ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ) ;
11428: LD_INT 22
11430: PUSH
11431: LD_INT 3
11433: PUSH
11434: EMPTY
11435: LIST
11436: LIST
11437: PUSH
11438: LD_INT 2
11440: PUSH
11441: LD_INT 21
11443: PUSH
11444: LD_INT 1
11446: PUSH
11447: EMPTY
11448: LIST
11449: LIST
11450: PUSH
11451: LD_INT 21
11453: PUSH
11454: LD_INT 2
11456: PUSH
11457: EMPTY
11458: LIST
11459: LIST
11460: PUSH
11461: EMPTY
11462: LIST
11463: LIST
11464: LIST
11465: PUSH
11466: EMPTY
11467: LIST
11468: LIST
11469: PPUSH
11470: NOP4
11474: PPUSH
11475: NOP4
// InGameOn ;
11479: NOP4
// CenterOnUnits ( Platonov ) ;
11483: NOP4
11487: PPUSH
11488: NOP4
// DialogueOn ;
11492: NOP4
// Say ( Burlak , D12-Bur-1 ) ;
11496: NOP4
11500: PPUSH
11501: LD_STRING D12-Bur-1
11503: PPUSH
11504: NOP4
// Say ( Platonov , D12-Pla-1 ) ;
11508: NOP4
11512: PPUSH
11513: LD_STRING D12-Pla-1
11515: PPUSH
11516: NOP4
// Say ( Burlak , D12-Bur-2 ) ;
11520: NOP4
11524: PPUSH
11525: LD_STRING D12-Bur-2
11527: PPUSH
11528: NOP4
// Say ( Platonov , D12-Pla-2 ) ;
11532: NOP4
11536: PPUSH
11537: LD_STRING D12-Pla-2
11539: PPUSH
11540: NOP4
// Say ( Burlak , D12-Bur-3 ) ;
11544: NOP4
11548: PPUSH
11549: LD_STRING D12-Bur-3
11551: PPUSH
11552: NOP4
// Say ( Platonov , D12-Pla-3 ) ;
11556: NOP4
11560: PPUSH
11561: LD_STRING D12-Pla-3
11563: PPUSH
11564: NOP4
// DialogueOff ;
11568: NOP4
// SetAttitude ( 6 , 1 , att_friend , true ) ;
11572: LD_INT 6
11574: PPUSH
11575: LD_INT 1
11577: PPUSH
11578: LD_INT 1
11580: PPUSH
11581: LD_INT 1
11583: PPUSH
11584: NOP4
// PrepareAmerican ;
11588: NOP4
// PrepareBelkovReturnTeam ;
11592: NOP4
// if IsOK ( Belkov ) then
11596: NOP4
11600: PPUSH
11601: NOP4
11605: IFFALSE 11619
// tmpBelkov = Belkov else
11607: NOP4
11611: PUSH
11612: NOP4
11616: ST_TO_ADDR
11617: GO 11629
// tmpBelkov = Belkov2 ;
11619: NOP4
11623: PUSH
11624: NOP4
11628: ST_TO_ADDR
// CenterNowOnUnits ( kirovVehicle ) ;
11629: NOP4
11633: PPUSH
11634: NOP4
// SayRadio ( trapCommander , D13-Sol1-1 ) ;
11638: NOP4
11642: PPUSH
11643: LD_STRING D13-Sol1-1
11645: PPUSH
11646: NOP4
// SayRadio ( tmpBelkov , D13-Bel-1 ) ;
11650: NOP4
11654: PPUSH
11655: LD_STRING D13-Bel-1
11657: PPUSH
11658: NOP4
// SayRadio ( Kurin , D13-Kur-1 ) ;
11662: NOP4
11666: PPUSH
11667: LD_STRING D13-Kur-1
11669: PPUSH
11670: NOP4
// SayRadio ( tmpBelkov , D13-Bel-2 ) ;
11674: NOP4
11678: PPUSH
11679: LD_STRING D13-Bel-2
11681: PPUSH
11682: NOP4
// ComMoveXY ( belkovTeam , 121 , 29 ) ;
11686: NOP4
11690: PPUSH
11691: LD_INT 121
11693: PPUSH
11694: LD_INT 29
11696: PPUSH
11697: NOP4
// repeat wait ( 0 0$1 ) ;
11701: LD_INT 35
11703: PPUSH
11704: NOP4
// CenterNowOnUnits ( kirovVehicle ) ;
11708: NOP4
11712: PPUSH
11713: NOP4
// nearRuUnit = NearestUnitToUnit ( UnitFilter ( belkovTeam , [ [ f_type , unit_human ] , [ f_outside ] ] ) , kirovVehicle ) ;
11717: NOP4
11721: PUSH
11722: NOP4
11726: PPUSH
11727: LD_INT 21
11729: PUSH
11730: LD_INT 1
11732: PUSH
11733: EMPTY
11734: LIST
11735: LIST
11736: PUSH
11737: LD_INT 56
11739: PUSH
11740: EMPTY
11741: LIST
11742: PUSH
11743: EMPTY
11744: LIST
11745: LIST
11746: PPUSH
11747: NOP4
11751: PPUSH
11752: NOP4
11756: PPUSH
11757: NOP4
11761: ST_TO_ADDR
// if GetDistUnits ( kirovVehicle , nearRuUnit ) < 5 then
11762: NOP4
11766: PPUSH
11767: NOP4
11771: PPUSH
11772: NOP4
11776: PUSH
11777: LD_INT 5
11779: LESS
11780: IFFALSE 11793
// ComStop ( kirovVehicle ) else
11782: NOP4
11786: PPUSH
11787: NOP4
11791: GO 11808
// ComMoveXY ( belkovTeam , 121 , 29 ) ;
11793: NOP4
11797: PPUSH
11798: LD_INT 121
11800: PPUSH
11801: LD_INT 29
11803: PPUSH
11804: NOP4
// until GetDistUnits ( NearestUnitToUnit ( belkovTeam , trapCommander ) , trapCommander ) < 5 ;
11808: NOP4
11812: PPUSH
11813: NOP4
11817: PPUSH
11818: NOP4
11822: PPUSH
11823: NOP4
11827: PPUSH
11828: NOP4
11832: PUSH
11833: LD_INT 5
11835: LESS
11836: IFFALSE 11701
// CenterNowOnUnits ( [ kirovVehicle , trapCommander ] ) ;
11838: NOP4
11842: PUSH
11843: NOP4
11847: PUSH
11848: EMPTY
11849: LIST
11850: LIST
11851: PPUSH
11852: NOP4
// ComWalk ( trapTeam ) ;
11856: NOP4
11860: PPUSH
11861: NOP4
// AddComTurnUnit ( trapTeam , kirovVehicle ) ;
11865: NOP4
11869: PPUSH
11870: NOP4
11874: PPUSH
11875: NOP4
// ComStop ( belkovTeam ) ;
11879: NOP4
11883: PPUSH
11884: NOP4
// AddComTurnUnit ( belkovTeam , trapCommander ) ;
11888: NOP4
11892: PPUSH
11893: NOP4
11897: PPUSH
11898: NOP4
// AddComMoveXY ( FilterUnitsInArea ( TrapNorthGroupArea , [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) , 111 , 13 ) ;
11902: LD_INT 25
11904: PPUSH
11905: LD_INT 22
11907: PUSH
11908: LD_INT 1
11910: PUSH
11911: EMPTY
11912: LIST
11913: LIST
11914: PUSH
11915: LD_INT 21
11917: PUSH
11918: LD_INT 1
11920: PUSH
11921: EMPTY
11922: LIST
11923: LIST
11924: PUSH
11925: EMPTY
11926: LIST
11927: LIST
11928: PPUSH
11929: NOP4
11933: PPUSH
11934: LD_INT 111
11936: PPUSH
11937: LD_INT 13
11939: PPUSH
11940: NOP4
// music_class = music_combat ;
11944: LD_ADDR_OWVAR 72
11948: PUSH
11949: LD_INT 1
11951: ST_TO_ADDR
// wait ( 0 0$1 ) ;
11952: LD_INT 35
11954: PPUSH
11955: NOP4
// DialogueOn ;
11959: NOP4
// Say ( trapCommander , D14-Sol1-1 ) ;
11963: NOP4
11967: PPUSH
11968: LD_STRING D14-Sol1-1
11970: PPUSH
11971: NOP4
// Say ( tmpBelkov , D14-Bel-1 ) ;
11975: NOP4
11979: PPUSH
11980: LD_STRING D14-Bel-1
11982: PPUSH
11983: NOP4
// DialogueOff ;
11987: NOP4
// immortalBelkovTeam = true ;
11991: NOP4
11995: PUSH
11996: LD_INT 1
11998: ST_TO_ADDR
// SetAttitude ( 6 , 1 , att_enemy , true ) ;
11999: LD_INT 6
12001: PPUSH
12002: LD_INT 1
12004: PPUSH
12005: LD_INT 2
12007: PPUSH
12008: LD_INT 1
12010: PPUSH
12011: NOP4
// ComMoveXY ( belkovTeam , 107 , 5 ) ;
12015: NOP4
12019: PPUSH
12020: LD_INT 107
12022: PPUSH
12023: LD_INT 5
12025: PPUSH
12026: NOP4
// ComMoveXY ( kirovVehicle , 107 , 5 ) ;
12030: NOP4
12034: PPUSH
12035: LD_INT 107
12037: PPUSH
12038: LD_INT 5
12040: PPUSH
12041: NOP4
// wait ( 0 0$2 ) ;
12045: LD_INT 70
12047: PPUSH
12048: NOP4
// ComMoveXY ( belkovTeam , 101 , 19 ) ;
12052: NOP4
12056: PPUSH
12057: LD_INT 101
12059: PPUSH
12060: LD_INT 19
12062: PPUSH
12063: NOP4
// ComMoveXY ( kirovVehicle , 101 , 19 ) ;
12067: NOP4
12071: PPUSH
12072: LD_INT 101
12074: PPUSH
12075: LD_INT 19
12077: PPUSH
12078: NOP4
// wait ( 0 0$2 ) ;
12082: LD_INT 70
12084: PPUSH
12085: NOP4
// immortalVehLive = 400 ;
12089: NOP4
12093: PUSH
12094: LD_INT 400
12096: ST_TO_ADDR
// SetLives ( kirovVehicle , 500 ) ;
12097: NOP4
12101: PPUSH
12102: LD_INT 500
12104: PPUSH
12105: NOP4
// wait ( 0 0$3 ) ;
12109: LD_INT 105
12111: PPUSH
12112: NOP4
// ComExitVehicle ( tmpBelkov ) ;
12116: NOP4
12120: PPUSH
12121: NOP4
// wait ( 0 0$1 ) ;
12125: LD_INT 35
12127: PPUSH
12128: NOP4
// ComEnterUnit ( trapCommander , kirovVehicle ) ;
12132: NOP4
12136: PPUSH
12137: NOP4
12141: PPUSH
12142: NOP4
// AddComHold ( trapTeam ) ;
12146: NOP4
12150: PPUSH
12151: NOP4
// ComMoveXY ( belkovTeam , 88 , 18 ) ;
12155: NOP4
12159: PPUSH
12160: LD_INT 88
12162: PPUSH
12163: LD_INT 18
12165: PPUSH
12166: NOP4
// repeat wait ( 0 0$1 ) ;
12170: LD_INT 35
12172: PPUSH
12173: NOP4
// CenterNowOnUnits ( tmpBelkov ) ;
12177: NOP4
12181: PPUSH
12182: NOP4
// until IsInArea ( tmpBelkov , BelkovRetreatArea ) ;
12186: NOP4
12190: PPUSH
12191: LD_INT 15
12193: PPUSH
12194: NOP4
12198: IFFALSE 12170
// amVeh = FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_vehicle ] ] ) [ 1 ] ;
12200: NOP4
12204: PUSH
12205: LD_INT 22
12207: PUSH
12208: LD_INT 1
12210: PUSH
12211: EMPTY
12212: LIST
12213: LIST
12214: PUSH
12215: LD_INT 21
12217: PUSH
12218: LD_INT 2
12220: PUSH
12221: EMPTY
12222: LIST
12223: LIST
12224: PUSH
12225: EMPTY
12226: LIST
12227: LIST
12228: PPUSH
12229: NOP4
12233: PUSH
12234: LD_INT 1
12236: ARRAY
12237: ST_TO_ADDR
// ComMoveXY ( FilterUnitsInArea ( NearHillArea , [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) , 113 , 29 ) ;
12238: LD_INT 28
12240: PPUSH
12241: LD_INT 22
12243: PUSH
12244: LD_INT 1
12246: PUSH
12247: EMPTY
12248: LIST
12249: LIST
12250: PUSH
12251: LD_INT 21
12253: PUSH
12254: LD_INT 1
12256: PUSH
12257: EMPTY
12258: LIST
12259: LIST
12260: PUSH
12261: EMPTY
12262: LIST
12263: LIST
12264: PPUSH
12265: NOP4
12269: PPUSH
12270: LD_INT 113
12272: PPUSH
12273: LD_INT 29
12275: PPUSH
12276: NOP4
// ComMoveXY ( amVeh , 118 , 25 ) ;
12280: NOP4
12284: PPUSH
12285: LD_INT 118
12287: PPUSH
12288: LD_INT 25
12290: PPUSH
12291: NOP4
// SayRadio ( tmpBelkov , D14-Bel-1a ) ;
12295: NOP4
12299: PPUSH
12300: LD_STRING D14-Bel-1a
12302: PPUSH
12303: NOP4
// SayRadio ( Kurin , D14-Kur-1 ) ;
12307: NOP4
12311: PPUSH
12312: LD_STRING D14-Kur-1
12314: PPUSH
12315: NOP4
// SayRadio ( tmpBelkov , D14-Bel-2 ) ;
12319: NOP4
12323: PPUSH
12324: LD_STRING D14-Bel-2
12326: PPUSH
12327: NOP4
// SayRadio ( Kurin , D14-Kur-2 ) ;
12331: NOP4
12335: PPUSH
12336: LD_STRING D14-Kur-2
12338: PPUSH
12339: NOP4
// CenterOnUnits ( Platonov ) ;
12343: NOP4
12347: PPUSH
12348: NOP4
// wait ( 0 0$2 ) ;
12352: LD_INT 70
12354: PPUSH
12355: NOP4
// Say ( Burlak , D14a-Bur-1 ) ;
12359: NOP4
12363: PPUSH
12364: LD_STRING D14a-Bur-1
12366: PPUSH
12367: NOP4
// Say ( Platonov , D14a-Pla-1 ) ;
12371: NOP4
12375: PPUSH
12376: LD_STRING D14a-Pla-1
12378: PPUSH
12379: NOP4
// Say ( Burlak , D14a-Bur-2 ) ;
12383: NOP4
12387: PPUSH
12388: LD_STRING D14a-Bur-2
12390: PPUSH
12391: NOP4
// Say ( Platonov , D14a-Pla-2 ) ;
12395: NOP4
12399: PPUSH
12400: LD_STRING D14a-Pla-2
12402: PPUSH
12403: NOP4
// Say ( Burlak , D14a-Bur-3 ) ;
12407: NOP4
12411: PPUSH
12412: LD_STRING D14a-Bur-3
12414: PPUSH
12415: NOP4
// Say ( Platonov , D14a-Pla-3 ) ;
12419: NOP4
12423: PPUSH
12424: LD_STRING D14a-Pla-3
12426: PPUSH
12427: NOP4
// Say ( Burlak , D14a-Bur-4 ) ;
12431: NOP4
12435: PPUSH
12436: LD_STRING D14a-Bur-4
12438: PPUSH
12439: NOP4
// Say ( Platonov , D14a-Pla-4 ) ;
12443: NOP4
12447: PPUSH
12448: LD_STRING D14a-Pla-4
12450: PPUSH
12451: NOP4
// InGameOff ;
12455: NOP4
// immortalBelkovTeam = false ;
12459: NOP4
12463: PUSH
12464: LD_INT 0
12466: ST_TO_ADDR
// activateAMAI = true ;
12467: NOP4
12471: PUSH
12472: LD_INT 1
12474: ST_TO_ADDR
// canExitBase = true ;
12475: NOP4
12479: PUSH
12480: LD_INT 1
12482: ST_TO_ADDR
// canExploreMap = true ;
12483: NOP4
12487: PUSH
12488: LD_INT 1
12490: ST_TO_ADDR
// construcMoreVehicles = false ;
12491: NOP4
12495: PUSH
12496: LD_INT 0
12498: ST_TO_ADDR
// activateBelkovAI = true ;
12499: NOP4
12503: PUSH
12504: LD_INT 1
12506: ST_TO_ADDR
// ChangeMissionObjectives ( M6 ) ;
12507: LD_STRING M6
12509: PPUSH
12510: NOP4
// music_class = 0 ;
12514: LD_ADDR_OWVAR 72
12518: PUSH
12519: LD_INT 0
12521: ST_TO_ADDR
// ComFree ( trapTeam ) ;
12522: NOP4
12526: PPUSH
12527: NOP4
// end ;
12531: PPOPN 2
12533: END
// every 0 0$1 trigger GetDistUnitXY ( amVeh , 118 , 25 ) < 6 do
12534: NOP4
12538: PPUSH
12539: LD_INT 118
12541: PPUSH
12542: LD_INT 25
12544: PPUSH
12545: NOP4
12549: PUSH
12550: LD_INT 6
12552: LESS
12553: IFFALSE 12648
12555: GO 12557
12557: DISABLE
// begin ComExitVehicle ( trapCommander ) ;
12558: NOP4
12562: PPUSH
12563: NOP4
// uc_side = 1 ;
12567: LD_ADDR_OWVAR 20
12571: PUSH
12572: LD_INT 1
12574: ST_TO_ADDR
// uc_nation = 1 ;
12575: LD_ADDR_OWVAR 21
12579: PUSH
12580: LD_INT 1
12582: ST_TO_ADDR
// PrepareMechanic ( 0 , enemySkillLevel ) ;
12583: LD_INT 0
12585: PPUSH
12586: NOP4
12590: PPUSH
12591: NOP4
// amMech = CreateHuman ;
12595: NOP4
12599: PUSH
12600: NOP4
12604: ST_TO_ADDR
// PlaceUnitArea ( amMech , AmMechSpawnArea , false ) ;
12605: NOP4
12609: PPUSH
12610: LD_INT 27
12612: PPUSH
12613: LD_INT 0
12615: PPUSH
12616: NOP4
// ComRepairVehicle ( amMech , amVeh ) ;
12620: NOP4
12624: PPUSH
12625: NOP4
12629: PPUSH
12630: NOP4
// AddComEnterUnit ( amMech , amVeh ) ;
12634: NOP4
12638: PPUSH
12639: NOP4
12643: PPUSH
12644: NOP4
// end ;
12648: END
// every 0 0$1 trigger IsOK ( amMech ) and FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_vehicle ] , [ f_ok ] ] ) do var nearUnit ;
12649: NOP4
12653: PPUSH
12654: NOP4
12658: PUSH
12659: LD_INT 22
12661: PUSH
12662: LD_INT 1
12664: PUSH
12665: EMPTY
12666: LIST
12667: LIST
12668: PUSH
12669: LD_INT 21
12671: PUSH
12672: LD_INT 2
12674: PUSH
12675: EMPTY
12676: LIST
12677: LIST
12678: PUSH
12679: LD_INT 50
12681: PUSH
12682: EMPTY
12683: LIST
12684: PUSH
12685: EMPTY
12686: LIST
12687: LIST
12688: LIST
12689: PPUSH
12690: NOP4
12694: AND
12695: IFFALSE 12948
12697: GO 12699
12699: DISABLE
12700: LD_INT 0
12702: PPUSH
// begin enable ;
12703: ENABLE
// nearUnit = NearestUnitToUnit ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) , amMech ) ;
12704: NOP4
12708: PUSH
12709: LD_INT 22
12711: PUSH
12712: LD_INT 3
12714: PUSH
12715: EMPTY
12716: LIST
12717: LIST
12718: PUSH
12719: LD_INT 2
12721: PUSH
12722: LD_INT 21
12724: PUSH
12725: LD_INT 1
12727: PUSH
12728: EMPTY
12729: LIST
12730: LIST
12731: PUSH
12732: LD_INT 21
12734: PUSH
12735: LD_INT 2
12737: PUSH
12738: EMPTY
12739: LIST
12740: LIST
12741: PUSH
12742: EMPTY
12743: LIST
12744: LIST
12745: LIST
12746: PUSH
12747: EMPTY
12748: LIST
12749: LIST
12750: PPUSH
12751: NOP4
12755: PPUSH
12756: NOP4
12760: PPUSH
12761: NOP4
12765: ST_TO_ADDR
// if GetDistUnits ( nearUnit , amMech ) < 13 then
12766: NOP4
12770: PPUSH
12771: NOP4
12775: PPUSH
12776: NOP4
12780: PUSH
12781: LD_INT 13
12783: LESS
12784: IFFALSE 12837
// ComEnterUnit ( amMech , FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_vehicle ] , [ f_ok ] ] ) [ 1 ] ) else
12786: NOP4
12790: PPUSH
12791: LD_INT 22
12793: PUSH
12794: LD_INT 1
12796: PUSH
12797: EMPTY
12798: LIST
12799: LIST
12800: PUSH
12801: LD_INT 21
12803: PUSH
12804: LD_INT 2
12806: PUSH
12807: EMPTY
12808: LIST
12809: LIST
12810: PUSH
12811: LD_INT 50
12813: PUSH
12814: EMPTY
12815: LIST
12816: PUSH
12817: EMPTY
12818: LIST
12819: LIST
12820: LIST
12821: PPUSH
12822: NOP4
12826: PUSH
12827: LD_INT 1
12829: ARRAY
12830: PPUSH
12831: NOP4
12835: GO 12948
// begin if GetLives ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_vehicle ] , [ f_ok ] ] ) [ 1 ] ) = 1000 and not IsInUnit ( amMech ) then
12837: LD_INT 22
12839: PUSH
12840: LD_INT 1
12842: PUSH
12843: EMPTY
12844: LIST
12845: LIST
12846: PUSH
12847: LD_INT 21
12849: PUSH
12850: LD_INT 2
12852: PUSH
12853: EMPTY
12854: LIST
12855: LIST
12856: PUSH
12857: LD_INT 50
12859: PUSH
12860: EMPTY
12861: LIST
12862: PUSH
12863: EMPTY
12864: LIST
12865: LIST
12866: LIST
12867: PPUSH
12868: NOP4
12872: PUSH
12873: LD_INT 1
12875: ARRAY
12876: PPUSH
12877: NOP4
12881: PUSH
12882: LD_INT 1000
12884: EQUAL
12885: PUSH
12886: NOP4
12890: PPUSH
12891: NOP4
12895: NOT
12896: AND
12897: IFFALSE 12948
// ComEnterUnit ( amMech , FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_vehicle ] , [ f_ok ] ] ) [ 1 ] ) ;
12899: NOP4
12903: PPUSH
12904: LD_INT 22
12906: PUSH
12907: LD_INT 1
12909: PUSH
12910: EMPTY
12911: LIST
12912: LIST
12913: PUSH
12914: LD_INT 21
12916: PUSH
12917: LD_INT 2
12919: PUSH
12920: EMPTY
12921: LIST
12922: LIST
12923: PUSH
12924: LD_INT 50
12926: PUSH
12927: EMPTY
12928: LIST
12929: PUSH
12930: EMPTY
12931: LIST
12932: LIST
12933: LIST
12934: PPUSH
12935: NOP4
12939: PUSH
12940: LD_INT 1
12942: ARRAY
12943: PPUSH
12944: NOP4
// end ; end ;
12948: PPOPN 1
12950: END
// every 0 0$1 trigger immortalBelkovTeam do
12951: NOP4
12955: IFFALSE 13042
12957: GO 12959
12959: DISABLE
// begin enable ;
12960: ENABLE
// SetLives ( UnitFilter ( belkovTeam , [ f_type , unit_human ] ) , 1000 ) ;
12961: NOP4
12965: PPUSH
12966: LD_INT 21
12968: PUSH
12969: LD_INT 1
12971: PUSH
12972: EMPTY
12973: LIST
12974: LIST
12975: PPUSH
12976: NOP4
12980: PPUSH
12981: LD_INT 1000
12983: PPUSH
12984: NOP4
// if UnitFilter ( belkovTeam , [ f_type , unit_vehicle ] ) then
12988: NOP4
12992: PPUSH
12993: LD_INT 21
12995: PUSH
12996: LD_INT 2
12998: PUSH
12999: EMPTY
13000: LIST
13001: LIST
13002: PPUSH
13003: NOP4
13007: IFFALSE 13042
// SetLives ( UnitFilter ( belkovTeam , [ f_type , unit_vehicle ] ) [ 1 ] , immortalVehLive ) ;
13009: NOP4
13013: PPUSH
13014: LD_INT 21
13016: PUSH
13017: LD_INT 2
13019: PUSH
13020: EMPTY
13021: LIST
13022: LIST
13023: PPUSH
13024: NOP4
13028: PUSH
13029: LD_INT 1
13031: ARRAY
13032: PPUSH
13033: NOP4
13037: PPUSH
13038: NOP4
// end ;
13042: END
// every 0 0$1 trigger canExploreMap and not belkovSaved and belkovAttackTime > 0 0$00 do
13043: NOP4
13047: PUSH
13048: NOP4
13052: NOT
13053: AND
13054: PUSH
13055: NOP4
13059: PUSH
13060: LD_INT 0
13062: GREATER
13063: AND
13064: IFFALSE 13084
13066: GO 13068
13068: DISABLE
// begin enable ;
13069: ENABLE
// belkovAttackTime = belkovAttackTime - 0 0$01 ;
13070: NOP4
13074: PUSH
13075: NOP4
13079: PUSH
13080: LD_INT 35
13082: MINUS
13083: ST_TO_ADDR
// end ;
13084: END
// every 0 0$15 trigger canExploreMap do var i , tmp ;
13085: NOP4
13089: IFFALSE 13173
13091: GO 13093
13093: DISABLE
13094: LD_INT 0
13096: PPUSH
13097: PPUSH
// begin tmp = trapTeam ;
13098: NOP4
13102: PUSH
13103: NOP4
13107: ST_TO_ADDR
// tmp = tmp diff trapCommander ;
13108: NOP4
13112: PUSH
13113: NOP4
13117: PUSH
13118: NOP4
13122: DIFF
13123: ST_TO_ADDR
// for i := 1 to rand ( 2 , 3 ) do
13124: NOP4
13128: PUSH
13129: DOUBLE
13130: LD_INT 1
13132: DEC
13133: ST_TO_ADDR
13134: LD_INT 2
13136: PPUSH
13137: LD_INT 3
13139: PPUSH
13140: NOP4
13144: PUSH
13145: FOR_TO
13146: IFFALSE 13171
// ComAgressiveMove ( tmp [ i ] , 87 , 18 ) ;
13148: NOP4
13152: PUSH
13153: NOP4
13157: ARRAY
13158: PPUSH
13159: LD_INT 87
13161: PPUSH
13162: LD_INT 18
13164: PPUSH
13165: NOP4
13169: GO 13145
13171: POP
13172: POP
// end ;
13173: PPOPN 2
13175: END
// every 0 0$1 trigger belkovAttackTime < 0 0$02 and trapTeam do
13176: NOP4
13180: PUSH
13181: LD_INT 70
13183: LESS
13184: PUSH
13185: NOP4
13189: AND
13190: IFFALSE 13219
13192: GO 13194
13194: DISABLE
// begin enable ;
13195: ENABLE
// activateBelkovAI = false ;
13196: NOP4
13200: PUSH
13201: LD_INT 0
13203: ST_TO_ADDR
// ComAgressiveMove ( belkovTeam , 120 , 28 ) ;
13204: NOP4
13208: PPUSH
13209: LD_INT 120
13211: PPUSH
13212: LD_INT 28
13214: PPUSH
13215: NOP4
// end ;
13219: END
// every 0 0$1 trigger ( not sawLeftBunker or not sawRightBunker ) and canExploreMap do var bunker ;
13220: NOP4
13224: NOT
13225: PUSH
13226: NOP4
13230: NOT
13231: OR
13232: PUSH
13233: NOP4
13237: AND
13238: IFFALSE 13700
13240: GO 13242
13242: DISABLE
13243: LD_INT 0
13245: PPUSH
// begin enable ;
13246: ENABLE
// for bunker in FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_building ] , [ f_btype , b_breastwork ] ] ) do
13247: NOP4
13251: PUSH
13252: LD_INT 22
13254: PUSH
13255: LD_INT 1
13257: PUSH
13258: EMPTY
13259: LIST
13260: LIST
13261: PUSH
13262: LD_INT 21
13264: PUSH
13265: LD_INT 3
13267: PUSH
13268: EMPTY
13269: LIST
13270: LIST
13271: PUSH
13272: LD_INT 30
13274: PUSH
13275: LD_INT 31
13277: PUSH
13278: EMPTY
13279: LIST
13280: LIST
13281: PUSH
13282: EMPTY
13283: LIST
13284: LIST
13285: LIST
13286: PPUSH
13287: NOP4
13291: PUSH
13292: FOR_IN
13293: IFFALSE 13698
// begin if See ( 3 , bunker ) then
13295: LD_INT 3
13297: PPUSH
13298: NOP4
13302: PPUSH
13303: NOP4
13307: IFFALSE 13696
// begin if bunker in leftBunkers and not sawLeftBunker and not FilterUnitsInArea ( WeakPositionArea , [ [ f_side , 3 ] ] ) then
13309: NOP4
13313: PUSH
13314: NOP4
13318: IN
13319: PUSH
13320: NOP4
13324: NOT
13325: AND
13326: PUSH
13327: LD_INT 18
13329: PPUSH
13330: LD_INT 22
13332: PUSH
13333: LD_INT 3
13335: PUSH
13336: EMPTY
13337: LIST
13338: LIST
13339: PUSH
13340: EMPTY
13341: LIST
13342: PPUSH
13343: NOP4
13347: NOT
13348: AND
13349: IFFALSE 13542
// begin sawLeftBunker = true ;
13351: NOP4
13355: PUSH
13356: LD_INT 1
13358: ST_TO_ADDR
// CenterOnUnits ( bunker ) ;
13359: NOP4
13363: PPUSH
13364: NOP4
// DialogueOn ;
13368: NOP4
// Say ( Burlak , D15-Bur-1 ) ;
13372: NOP4
13376: PPUSH
13377: LD_STRING D15-Bur-1
13379: PPUSH
13380: NOP4
// if IsOK ( Gnyevko ) or IsOK ( Kovalyuk ) then
13384: NOP4
13388: PPUSH
13389: NOP4
13393: PUSH
13394: NOP4
13398: PPUSH
13399: NOP4
13403: OR
13404: IFFALSE 13499
// begin if IsOK ( Gnyevko ) then
13406: NOP4
13410: PPUSH
13411: NOP4
13415: IFFALSE 13429
// Say ( Gnyevko , D15-Gny-1 ) ;
13417: NOP4
13421: PPUSH
13422: LD_STRING D15-Gny-1
13424: PPUSH
13425: NOP4
// if IsOK ( Kovalyuk ) then
13429: NOP4
13433: PPUSH
13434: NOP4
13438: IFFALSE 13452
// Say ( Kovalyuk , D15-Kov-1 ) ;
13440: NOP4
13444: PPUSH
13445: LD_STRING D15-Kov-1
13447: PPUSH
13448: NOP4
// Say ( Burlak , D15-Bur-2 ) ;
13452: NOP4
13456: PPUSH
13457: LD_STRING D15-Bur-2
13459: PPUSH
13460: NOP4
// if IsOK ( Kovalyuk ) then
13464: NOP4
13468: PPUSH
13469: NOP4
13473: IFFALSE 13487
// Say ( Kovalyuk , D15-Kov-2 ) ;
13475: NOP4
13479: PPUSH
13480: LD_STRING D15-Kov-2
13482: PPUSH
13483: NOP4
// Say ( Burlak , D15-Bur-3 ) ;
13487: NOP4
13491: PPUSH
13492: LD_STRING D15-Bur-3
13494: PPUSH
13495: NOP4
// end ; DialogueOff ;
13499: NOP4
// if raportForPlatonov = 2 then
13503: NOP4
13507: PUSH
13508: LD_INT 2
13510: EQUAL
13511: IFFALSE 13523
// raportForPlatonov = 1 else
13513: NOP4
13517: PUSH
13518: LD_INT 1
13520: ST_TO_ADDR
13521: GO 13531
// raportForPlatonov = 3 ;
13523: NOP4
13527: PUSH
13528: LD_INT 3
13530: ST_TO_ADDR
// ChangeMissionObjectives ( M7 ) ;
13531: LD_STRING M7
13533: PPUSH
13534: NOP4
// exit ;
13538: POP
13539: POP
13540: GO 13700
// end ; if bunker in rightBunkers and not sawRightBunker then
13542: NOP4
13546: PUSH
13547: NOP4
13551: IN
13552: PUSH
13553: NOP4
13557: NOT
13558: AND
13559: IFFALSE 13696
// begin sawRightBunker = true ;
13561: NOP4
13565: PUSH
13566: LD_INT 1
13568: ST_TO_ADDR
// CenterOnUnits ( bunker ) ;
13569: NOP4
13573: PPUSH
13574: NOP4
// DialogueOn ;
13578: NOP4
// if IsOK ( Kovalyuk ) then
13582: NOP4
13586: PPUSH
13587: NOP4
13591: IFFALSE 13660
// begin if sawLeftBunker then
13593: NOP4
13597: IFFALSE 13613
// Say ( Kovalyuk , D16-Kov-1a ) else
13599: NOP4
13603: PPUSH
13604: LD_STRING D16-Kov-1a
13606: PPUSH
13607: NOP4
13611: GO 13625
// Say ( Kovalyuk , D16-Kov-1 ) ;
13613: NOP4
13617: PPUSH
13618: LD_STRING D16-Kov-1
13620: PPUSH
13621: NOP4
// Say ( Burlak , D16-Bur-1 ) ;
13625: NOP4
13629: PPUSH
13630: LD_STRING D16-Bur-1
13632: PPUSH
13633: NOP4
// if IsOK ( Gnyevko ) then
13637: NOP4
13641: PPUSH
13642: NOP4
13646: IFFALSE 13660
// Say ( Gnyevko , D16-Gny-1 ) ;
13648: NOP4
13652: PPUSH
13653: LD_STRING D16-Gny-1
13655: PPUSH
13656: NOP4
// end ; DialogueOff ;
13660: NOP4
// if raportForPlatonov = 3 then
13664: NOP4
13668: PUSH
13669: LD_INT 3
13671: EQUAL
13672: IFFALSE 13684
// raportForPlatonov = 1 else
13674: NOP4
13678: PUSH
13679: LD_INT 1
13681: ST_TO_ADDR
13682: GO 13692
// raportForPlatonov = 2 ;
13684: NOP4
13688: PUSH
13689: LD_INT 2
13691: ST_TO_ADDR
// exit ;
13692: POP
13693: POP
13694: GO 13700
// end ; end ; end ;
13696: GO 13292
13698: POP
13699: POP
// end ;
13700: PPOPN 1
13702: END
// every 0 0$2 trigger not dialogAttackRightBunkers and rightBunkers and canExploreMap and ( IsOK ( Kovalyuk ) or IsOK ( Gnyevko ) ) do var unit ;
13703: NOP4
13707: NOT
13708: PUSH
13709: NOP4
13713: AND
13714: PUSH
13715: NOP4
13719: AND
13720: PUSH
13721: NOP4
13725: PPUSH
13726: NOP4
13730: PUSH
13731: NOP4
13735: PPUSH
13736: NOP4
13740: OR
13741: AND
13742: IFFALSE 13930
13744: GO 13746
13746: DISABLE
13747: LD_INT 0
13749: PPUSH
// begin enable ;
13750: ENABLE
// for unit in FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) do
13751: NOP4
13755: PUSH
13756: LD_INT 22
13758: PUSH
13759: LD_INT 3
13761: PUSH
13762: EMPTY
13763: LIST
13764: LIST
13765: PUSH
13766: LD_INT 2
13768: PUSH
13769: LD_INT 21
13771: PUSH
13772: LD_INT 1
13774: PUSH
13775: EMPTY
13776: LIST
13777: LIST
13778: PUSH
13779: LD_INT 21
13781: PUSH
13782: LD_INT 2
13784: PUSH
13785: EMPTY
13786: LIST
13787: LIST
13788: PUSH
13789: EMPTY
13790: LIST
13791: LIST
13792: LIST
13793: PUSH
13794: EMPTY
13795: LIST
13796: LIST
13797: PPUSH
13798: NOP4
13802: PUSH
13803: FOR_IN
13804: IFFALSE 13928
// begin if Attacks ( unit ) = rightBunkers [ 1 ] or Attacks ( unit ) = rightBunkers [ 2 ] then
13806: NOP4
13810: PPUSH
13811: NOP4
13815: PUSH
13816: NOP4
13820: PUSH
13821: LD_INT 1
13823: ARRAY
13824: EQUAL
13825: PUSH
13826: NOP4
13830: PPUSH
13831: NOP4
13835: PUSH
13836: NOP4
13840: PUSH
13841: LD_INT 2
13843: ARRAY
13844: EQUAL
13845: OR
13846: IFFALSE 13926
// begin dialogAttackRightBunkers = true ;
13848: NOP4
13852: PUSH
13853: LD_INT 1
13855: ST_TO_ADDR
// DialogueOn ;
13856: NOP4
// if IsOK ( Gnyevko ) then
13860: NOP4
13864: PPUSH
13865: NOP4
13869: IFFALSE 13883
// Say ( Gnyevko , D16A-Gny-1 ) ;
13871: NOP4
13875: PPUSH
13876: LD_STRING D16A-Gny-1
13878: PPUSH
13879: NOP4
// if IsOK ( Kovalyuk ) then
13883: NOP4
13887: PPUSH
13888: NOP4
13892: IFFALSE 13906
// Say ( Kovalyuk , D16A-Kov-1 ) ;
13894: NOP4
13898: PPUSH
13899: LD_STRING D16A-Kov-1
13901: PPUSH
13902: NOP4
// Say ( Burlak , D16A-Bur-1 ) ;
13906: NOP4
13910: PPUSH
13911: LD_STRING D16A-Bur-1
13913: PPUSH
13914: NOP4
// DialogueOff ;
13918: NOP4
// exit ;
13922: POP
13923: POP
13924: GO 13930
// end ; end ;
13926: GO 13803
13928: POP
13929: POP
// end ;
13930: PPOPN 1
13932: END
// every 0 0$3 trigger FilterUnitsInArea ( WeakPositionArea , [ [ f_side , 3 ] ] ) and not sawLeftBunker do var decsToChoose ;
13933: LD_INT 18
13935: PPUSH
13936: LD_INT 22
13938: PUSH
13939: LD_INT 3
13941: PUSH
13942: EMPTY
13943: LIST
13944: LIST
13945: PUSH
13946: EMPTY
13947: LIST
13948: PPUSH
13949: NOP4
13953: PUSH
13954: NOP4
13958: NOT
13959: AND
13960: IFFALSE 14343
13962: GO 13964
13964: DISABLE
13965: LD_INT 0
13967: PPUSH
// begin sawLeftBunker = true ;
13968: NOP4
13972: PUSH
13973: LD_INT 1
13975: ST_TO_ADDR
// if playerGetSupport then
13976: NOP4
13980: IFFALSE 13999
// decsToChoose = [ 1 , 3 ] else
13982: NOP4
13986: PUSH
13987: LD_INT 1
13989: PUSH
13990: LD_INT 3
13992: PUSH
13993: EMPTY
13994: LIST
13995: LIST
13996: ST_TO_ADDR
13997: GO 14018
// decsToChoose = [ 1 , 2 , 3 ] ;
13999: NOP4
14003: PUSH
14004: LD_INT 1
14006: PUSH
14007: LD_INT 2
14009: PUSH
14010: LD_INT 3
14012: PUSH
14013: EMPTY
14014: LIST
14015: LIST
14016: LIST
14017: ST_TO_ADDR
// case SelectiveQuery ( QAttackBw , decsToChoose ) of 1 :
14018: LD_STRING QAttackBw
14020: PPUSH
14021: NOP4
14025: PPUSH
14026: NOP4
14030: PUSH
14031: LD_INT 1
14033: DOUBLE
14034: EQUAL
14035: IFTRUE 14039
14037: GO 14132
14039: POP
// begin DialogueOn ;
14040: NOP4
// Say ( Burlak , D17-Bur-1 ) ;
14044: NOP4
14048: PPUSH
14049: LD_STRING D17-Bur-1
14051: PPUSH
14052: NOP4
// SayRadio ( Platonov , D17-Pla-1 ) ;
14056: NOP4
14060: PPUSH
14061: LD_STRING D17-Pla-1
14063: PPUSH
14064: NOP4
// Say ( Burlak , D17-Bur-2 ) ;
14068: NOP4
14072: PPUSH
14073: LD_STRING D17-Bur-2
14075: PPUSH
14076: NOP4
// SayRadio ( Platonov , D17-Pla-2 ) ;
14080: NOP4
14084: PPUSH
14085: LD_STRING D17-Pla-2
14087: PPUSH
14088: NOP4
// DialogueOff ;
14092: NOP4
// if not ( initiative in [ 2 , 3 ] ) then
14096: NOP4
14100: PUSH
14101: LD_INT 2
14103: PUSH
14104: LD_INT 3
14106: PUSH
14107: EMPTY
14108: LIST
14109: LIST
14110: IN
14111: NOT
14112: IFFALSE 14130
// begin initiative = 1 ;
14114: NOP4
14118: PUSH
14119: LD_INT 1
14121: ST_TO_ADDR
// platonovOpinion = 2 ;
14122: NOP4
14126: PUSH
14127: LD_INT 2
14129: ST_TO_ADDR
// end ; end ; 2 :
14130: GO 14273
14132: LD_INT 2
14134: DOUBLE
14135: EQUAL
14136: IFTRUE 14140
14138: GO 14245
14140: POP
// begin DialogueOn ;
14141: NOP4
// Say ( Burlak , D18-Bur-1 ) ;
14145: NOP4
14149: PPUSH
14150: LD_STRING D18-Bur-1
14152: PPUSH
14153: NOP4
// SayRadio ( Platonov , D18-Pla-1 ) ;
14157: NOP4
14161: PPUSH
14162: LD_STRING D18-Pla-1
14164: PPUSH
14165: NOP4
// Say ( Burlak , D18-Bur-2 ) ;
14169: NOP4
14173: PPUSH
14174: LD_STRING D18-Bur-2
14176: PPUSH
14177: NOP4
// SayRadio ( Platonov , D18-Pla-2 ) ;
14181: NOP4
14185: PPUSH
14186: LD_STRING D18-Pla-2
14188: PPUSH
14189: NOP4
// DialogueOff ;
14193: NOP4
// playerGetSupport = true ;
14197: NOP4
14201: PUSH
14202: LD_INT 1
14204: ST_TO_ADDR
// medalForGetSupport = false ;
14205: NOP4
14209: PUSH
14210: LD_INT 0
14212: ST_TO_ADDR
// PlatonovSendSupport ;
14213: NOP4
// if initiative <> 3 then
14217: NOP4
14221: PUSH
14222: LD_INT 3
14224: NONEQUAL
14225: IFFALSE 14243
// begin initiative = 1 ;
14227: NOP4
14231: PUSH
14232: LD_INT 1
14234: ST_TO_ADDR
// platonovOpinion = 2 ;
14235: NOP4
14239: PUSH
14240: LD_INT 2
14242: ST_TO_ADDR
// end ; end ; 3 :
14243: GO 14273
14245: LD_INT 3
14247: DOUBLE
14248: EQUAL
14249: IFTRUE 14253
14251: GO 14272
14253: POP
// begin initiative = 3 ;
14254: NOP4
14258: PUSH
14259: LD_INT 3
14261: ST_TO_ADDR
// platonovOpinion = 0 ;
14262: NOP4
14266: PUSH
14267: LD_INT 0
14269: ST_TO_ADDR
// end ; end ;
14270: GO 14273
14272: POP
// if IsOK ( Gnyevko ) then
14273: NOP4
14277: PPUSH
14278: NOP4
14282: IFFALSE 14308
// begin Say ( Gnyevko , D19-Gny-1 ) ;
14284: NOP4
14288: PPUSH
14289: LD_STRING D19-Gny-1
14291: PPUSH
14292: NOP4
// Say ( Burlak , D19-Bur-1 ) ;
14296: NOP4
14300: PPUSH
14301: LD_STRING D19-Bur-1
14303: PPUSH
14304: NOP4
// end ; if IsOK ( Kovalyuk ) then
14308: NOP4
14312: PPUSH
14313: NOP4
14317: IFFALSE 14343
// begin Say ( Kovalyuk , D19-Kov-1 ) ;
14319: NOP4
14323: PPUSH
14324: LD_STRING D19-Kov-1
14326: PPUSH
14327: NOP4
// Say ( Burlak , D19-Bur-2 ) ;
14331: NOP4
14335: PPUSH
14336: LD_STRING D19-Bur-2
14338: PPUSH
14339: NOP4
// end ; end ;
14343: PPOPN 1
14345: END
// every 0 0$2 trigger not dialogAttackLeftBunkers and leftBunkers and canExploreMap and FilterUnitsInArea ( WeakPositionArea , [ [ f_side , 3 ] ] ) = 0 and ( IsOK ( Kovalyuk ) or IsOK ( Gnyevko ) ) do var unit ;
14346: NOP4
14350: NOT
14351: PUSH
14352: NOP4
14356: AND
14357: PUSH
14358: NOP4
14362: AND
14363: PUSH
14364: LD_INT 18
14366: PPUSH
14367: LD_INT 22
14369: PUSH
14370: LD_INT 3
14372: PUSH
14373: EMPTY
14374: LIST
14375: LIST
14376: PUSH
14377: EMPTY
14378: LIST
14379: PPUSH
14380: NOP4
14384: PUSH
14385: LD_INT 0
14387: EQUAL
14388: AND
14389: PUSH
14390: NOP4
14394: PPUSH
14395: NOP4
14399: PUSH
14400: NOP4
14404: PPUSH
14405: NOP4
14409: OR
14410: AND
14411: IFFALSE 14599
14413: GO 14415
14415: DISABLE
14416: LD_INT 0
14418: PPUSH
// begin enable ;
14419: ENABLE
// for unit in FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) do
14420: NOP4
14424: PUSH
14425: LD_INT 22
14427: PUSH
14428: LD_INT 3
14430: PUSH
14431: EMPTY
14432: LIST
14433: LIST
14434: PUSH
14435: LD_INT 2
14437: PUSH
14438: LD_INT 21
14440: PUSH
14441: LD_INT 1
14443: PUSH
14444: EMPTY
14445: LIST
14446: LIST
14447: PUSH
14448: LD_INT 21
14450: PUSH
14451: LD_INT 2
14453: PUSH
14454: EMPTY
14455: LIST
14456: LIST
14457: PUSH
14458: EMPTY
14459: LIST
14460: LIST
14461: LIST
14462: PUSH
14463: EMPTY
14464: LIST
14465: LIST
14466: PPUSH
14467: NOP4
14471: PUSH
14472: FOR_IN
14473: IFFALSE 14597
// begin if Attacks ( unit ) = leftBunkers [ 1 ] or Attacks ( unit ) = leftBunkers [ 2 ] then
14475: NOP4
14479: PPUSH
14480: NOP4
14484: PUSH
14485: NOP4
14489: PUSH
14490: LD_INT 1
14492: ARRAY
14493: EQUAL
14494: PUSH
14495: NOP4
14499: PPUSH
14500: NOP4
14504: PUSH
14505: NOP4
14509: PUSH
14510: LD_INT 2
14512: ARRAY
14513: EQUAL
14514: OR
14515: IFFALSE 14595
// begin dialogAttackLeftBunkers = true ;
14517: NOP4
14521: PUSH
14522: LD_INT 1
14524: ST_TO_ADDR
// DialogueOn ;
14525: NOP4
// if IsOK ( Gnyevko ) then
14529: NOP4
14533: PPUSH
14534: NOP4
14538: IFFALSE 14552
// Say ( Gnyevko , D19A-Gny-1 ) ;
14540: NOP4
14544: PPUSH
14545: LD_STRING D19A-Gny-1
14547: PPUSH
14548: NOP4
// if IsOK ( Kovalyuk ) then
14552: NOP4
14556: PPUSH
14557: NOP4
14561: IFFALSE 14575
// Say ( Kovalyuk , D19A-Kov-1 ) ;
14563: NOP4
14567: PPUSH
14568: LD_STRING D19A-Kov-1
14570: PPUSH
14571: NOP4
// Say ( Burlak , D16A-Bur-1 ) ;
14575: NOP4
14579: PPUSH
14580: LD_STRING D16A-Bur-1
14582: PPUSH
14583: NOP4
// DialogueOff ;
14587: NOP4
// exit ;
14591: POP
14592: POP
14593: GO 14599
// end ; end ;
14595: GO 14472
14597: POP
14598: POP
// end ;
14599: PPOPN 1
14601: END
// every 0 0$1 trigger ( not leftBunkers or FilterUnitsInArea ( LeftHillArea , [ [ f_side , 1 ] , [ f_type , unit_building ] , [ f_btype , b_breastwork ] , [ f_ok ] ] ) = 0 ) and canExploreMap do
14602: NOP4
14606: NOT
14607: PUSH
14608: LD_INT 17
14610: PPUSH
14611: LD_INT 22
14613: PUSH
14614: LD_INT 1
14616: PUSH
14617: EMPTY
14618: LIST
14619: LIST
14620: PUSH
14621: LD_INT 21
14623: PUSH
14624: LD_INT 3
14626: PUSH
14627: EMPTY
14628: LIST
14629: LIST
14630: PUSH
14631: LD_INT 30
14633: PUSH
14634: LD_INT 31
14636: PUSH
14637: EMPTY
14638: LIST
14639: LIST
14640: PUSH
14641: LD_INT 50
14643: PUSH
14644: EMPTY
14645: LIST
14646: PUSH
14647: EMPTY
14648: LIST
14649: LIST
14650: LIST
14651: LIST
14652: PPUSH
14653: NOP4
14657: PUSH
14658: LD_INT 0
14660: EQUAL
14661: OR
14662: PUSH
14663: NOP4
14667: AND
14668: IFFALSE 14719
14670: GO 14672
14672: DISABLE
// begin leftBunkers = [ ] ;
14673: NOP4
14677: PUSH
14678: EMPTY
14679: ST_TO_ADDR
// DialogueOn ;
14680: NOP4
// Say ( Burlak , D20-Bur-1 ) ;
14684: NOP4
14688: PPUSH
14689: LD_STRING D20-Bur-1
14691: PPUSH
14692: NOP4
// Say ( Platonov , D20-Pla-1 ) ;
14696: NOP4
14700: PPUSH
14701: LD_STRING D20-Pla-1
14703: PPUSH
14704: NOP4
// DialogueOff ;
14708: NOP4
// ChangeMissionObjectives ( M8 ) ;
14712: LD_STRING M8
14714: PPUSH
14715: NOP4
// end ;
14719: END
// every 0 0$1 trigger ( not rightBunkers or FilterUnitsInArea ( rightHillArea , [ [ f_side , 1 ] , [ f_type , unit_building ] , [ f_btype , b_breastwork ] , [ f_ok ] ] ) = 0 ) and canExploreMap do
14720: NOP4
14724: NOT
14725: PUSH
14726: LD_INT 16
14728: PPUSH
14729: LD_INT 22
14731: PUSH
14732: LD_INT 1
14734: PUSH
14735: EMPTY
14736: LIST
14737: LIST
14738: PUSH
14739: LD_INT 21
14741: PUSH
14742: LD_INT 3
14744: PUSH
14745: EMPTY
14746: LIST
14747: LIST
14748: PUSH
14749: LD_INT 30
14751: PUSH
14752: LD_INT 31
14754: PUSH
14755: EMPTY
14756: LIST
14757: LIST
14758: PUSH
14759: LD_INT 50
14761: PUSH
14762: EMPTY
14763: LIST
14764: PUSH
14765: EMPTY
14766: LIST
14767: LIST
14768: LIST
14769: LIST
14770: PPUSH
14771: NOP4
14775: PUSH
14776: LD_INT 0
14778: EQUAL
14779: OR
14780: PUSH
14781: NOP4
14785: AND
14786: IFFALSE 14830
14788: GO 14790
14790: DISABLE
// begin rightBunkers = [ ] ;
14791: NOP4
14795: PUSH
14796: EMPTY
14797: ST_TO_ADDR
// DialogueOn ;
14798: NOP4
// Say ( Burlak , D20a-Bur-1 ) ;
14802: NOP4
14806: PPUSH
14807: LD_STRING D20a-Bur-1
14809: PPUSH
14810: NOP4
// Say ( Platonov , D20a-Pla-1 ) ;
14814: NOP4
14818: PPUSH
14819: LD_STRING D20a-Pla-1
14821: PPUSH
14822: NOP4
// DialogueOff ;
14826: NOP4
// end ;
14830: END
// every 0 0$1 trigger not saveBelkovDecision and belkovTeam do var yourUnit , trapUnit , decsToChoose ;
14831: NOP4
14835: NOT
14836: PUSH
14837: NOP4
14841: AND
14842: IFFALSE 15337
14844: GO 14846
14846: DISABLE
14847: LD_INT 0
14849: PPUSH
14850: PPUSH
14851: PPUSH
// begin enable ;
14852: ENABLE
// for yourUnit in FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) do
14853: NOP4
14857: PUSH
14858: LD_INT 22
14860: PUSH
14861: LD_INT 3
14863: PUSH
14864: EMPTY
14865: LIST
14866: LIST
14867: PUSH
14868: LD_INT 2
14870: PUSH
14871: LD_INT 21
14873: PUSH
14874: LD_INT 1
14876: PUSH
14877: EMPTY
14878: LIST
14879: LIST
14880: PUSH
14881: LD_INT 21
14883: PUSH
14884: LD_INT 2
14886: PUSH
14887: EMPTY
14888: LIST
14889: LIST
14890: PUSH
14891: EMPTY
14892: LIST
14893: LIST
14894: LIST
14895: PUSH
14896: EMPTY
14897: LIST
14898: LIST
14899: PPUSH
14900: NOP4
14904: PUSH
14905: FOR_IN
14906: IFFALSE 15335
// for trapUnit in trapTeam do
14908: NOP4
14912: PUSH
14913: NOP4
14917: PUSH
14918: FOR_IN
14919: IFFALSE 15331
// if GetDistUnits ( yourUnit , trapUnit ) < 16 then
14921: NOP4
14925: PPUSH
14926: NOP4
14930: PPUSH
14931: NOP4
14935: PUSH
14936: LD_INT 16
14938: LESS
14939: IFFALSE 15329
// begin saveBelkovDecision = true ;
14941: NOP4
14945: PUSH
14946: LD_INT 1
14948: ST_TO_ADDR
// if playerGetSupport then
14949: NOP4
14953: IFFALSE 14972
// decsToChoose = [ 1 , 3 ] else
14955: NOP4
14959: PUSH
14960: LD_INT 1
14962: PUSH
14963: LD_INT 3
14965: PUSH
14966: EMPTY
14967: LIST
14968: LIST
14969: ST_TO_ADDR
14970: GO 14991
// decsToChoose = [ 1 , 2 , 3 ] ;
14972: NOP4
14976: PUSH
14977: LD_INT 1
14979: PUSH
14980: LD_INT 2
14982: PUSH
14983: LD_INT 3
14985: PUSH
14986: EMPTY
14987: LIST
14988: LIST
14989: LIST
14990: ST_TO_ADDR
// case SelectiveQuery ( QAttackAm , decsToChoose ) of 1 :
14991: LD_STRING QAttackAm
14993: PPUSH
14994: NOP4
14998: PPUSH
14999: NOP4
15003: PUSH
15004: LD_INT 1
15006: DOUBLE
15007: EQUAL
15008: IFTRUE 15012
15010: GO 15081
15012: POP
// begin DialogueOn ;
15013: NOP4
// Say ( Burlak , D21-Bur-1 ) ;
15017: NOP4
15021: PPUSH
15022: LD_STRING D21-Bur-1
15024: PPUSH
15025: NOP4
// SayRadio ( Platonov , D21-Pla-1 ) ;
15029: NOP4
15033: PPUSH
15034: LD_STRING D21-Pla-1
15036: PPUSH
15037: NOP4
// DialogueOff ;
15041: NOP4
// if not ( initiative in [ 2 , 3 ] ) then
15045: NOP4
15049: PUSH
15050: LD_INT 2
15052: PUSH
15053: LD_INT 3
15055: PUSH
15056: EMPTY
15057: LIST
15058: LIST
15059: IN
15060: NOT
15061: IFFALSE 15079
// begin initiative = 1 ;
15063: NOP4
15067: PUSH
15068: LD_INT 1
15070: ST_TO_ADDR
// platonovOpinion = 2 ;
15071: NOP4
15075: PUSH
15076: LD_INT 2
15078: ST_TO_ADDR
// end ; end ; 2 :
15079: GO 15273
15081: LD_INT 2
15083: DOUBLE
15084: EQUAL
15085: IFTRUE 15089
15087: GO 15245
15089: POP
// begin DialogueOn ;
15090: NOP4
// Say ( Burlak , D22-Bur-1 ) ;
15094: NOP4
15098: PPUSH
15099: LD_STRING D22-Bur-1
15101: PPUSH
15102: NOP4
// if playerGetSupport and ( leftBunkers = 0 or rightBunkers = 0 ) then
15106: NOP4
15110: PUSH
15111: NOP4
15115: PUSH
15116: LD_INT 0
15118: EQUAL
15119: PUSH
15120: NOP4
15124: PUSH
15125: LD_INT 0
15127: EQUAL
15128: OR
15129: AND
15130: IFFALSE 15144
// Say ( Platonov , D22-Pla-1b ) ;
15132: NOP4
15136: PPUSH
15137: LD_STRING D22-Pla-1b
15139: PPUSH
15140: NOP4
// if playerGetSupport and ( leftBunkers or rightBunkers ) then
15144: NOP4
15148: PUSH
15149: NOP4
15153: PUSH
15154: NOP4
15158: OR
15159: AND
15160: IFFALSE 15174
// Say ( Platonov , D22-Pla-1a ) ;
15162: NOP4
15166: PPUSH
15167: LD_STRING D22-Pla-1a
15169: PPUSH
15170: NOP4
// if not playerGetSupport then
15174: NOP4
15178: NOT
15179: IFFALSE 15213
// begin Say ( Platonov , D22-Pla-1 ) ;
15181: NOP4
15185: PPUSH
15186: LD_STRING D22-Pla-1
15188: PPUSH
15189: NOP4
// playerGetSupport = true ;
15193: NOP4
15197: PUSH
15198: LD_INT 1
15200: ST_TO_ADDR
// medalForGetSupport = false ;
15201: NOP4
15205: PUSH
15206: LD_INT 0
15208: ST_TO_ADDR
// PlatonovSendSupport ;
15209: NOP4
// end ; DialogueOff ;
15213: NOP4
// if initiative <> 3 then
15217: NOP4
15221: PUSH
15222: LD_INT 3
15224: NONEQUAL
15225: IFFALSE 15243
// begin initiative = 2 ;
15227: NOP4
15231: PUSH
15232: LD_INT 2
15234: ST_TO_ADDR
// platonovOpinion = 1 ;
15235: NOP4
15239: PUSH
15240: LD_INT 1
15242: ST_TO_ADDR
// end ; end ; 3 :
15243: GO 15273
15245: LD_INT 3
15247: DOUBLE
15248: EQUAL
15249: IFTRUE 15253
15251: GO 15272
15253: POP
// begin initiative = 3 ;
15254: NOP4
15258: PUSH
15259: LD_INT 3
15261: ST_TO_ADDR
// platonovOpinion = 0 ;
15262: NOP4
15266: PUSH
15267: LD_INT 0
15269: ST_TO_ADDR
// end ; end ;
15270: GO 15273
15272: POP
// if IsOK ( Gnyevko ) then
15273: NOP4
15277: PPUSH
15278: NOP4
15282: IFFALSE 15308
// begin Say ( Gnyevko , D23-Gny-1 ) ;
15284: NOP4
15288: PPUSH
15289: LD_STRING D23-Gny-1
15291: PPUSH
15292: NOP4
// Say ( Burlak , D23-Bur-1 ) ;
15296: NOP4
15300: PPUSH
15301: LD_STRING D23-Bur-1
15303: PPUSH
15304: NOP4
// end ; saveBelkovObjective = true ;
15308: NOP4
15312: PUSH
15313: LD_INT 1
15315: ST_TO_ADDR
// ChangeMissionObjectives ( M9 ) ;
15316: LD_STRING M9
15318: PPUSH
15319: NOP4
// exit ;
15323: POP
15324: POP
15325: POP
15326: POP
15327: GO 15337
// end ;
15329: GO 14918
15331: POP
15332: POP
15333: GO 14905
15335: POP
15336: POP
// end ;
15337: PPOPN 3
15339: END
// every 0 0$1 trigger canExploreMap and not trapTeam and not belkovSaved do
15340: NOP4
15344: PUSH
15345: NOP4
15349: NOT
15350: AND
15351: PUSH
15352: NOP4
15356: NOT
15357: AND
15358: IFFALSE 15398
15360: GO 15362
15362: DISABLE
// begin belkovSaved = true ;
15363: NOP4
15367: PUSH
15368: LD_INT 1
15370: ST_TO_ADDR
// activateBelkovAI = false ;
15371: NOP4
15375: PUSH
15376: LD_INT 0
15378: ST_TO_ADDR
// SetSide ( belkovTeam , 3 ) ;
15379: NOP4
15383: PPUSH
15384: LD_INT 3
15386: PPUSH
15387: NOP4
// ChangeMissionObjectives ( M9a ) ;
15391: LD_STRING M9a
15393: PPUSH
15394: NOP4
// end ;
15398: END
// every 0 0$1 trigger saveBelkovDecision and ( IsDead ( Belkov ) or IsDead ( Belkov2 ) and ( GetSide ( Belkov ) = 6 or GetSide ( Belkov2 ) = 6 ) ) do
15399: NOP4
15403: PUSH
15404: NOP4
15408: PPUSH
15409: NOP4
15413: PUSH
15414: NOP4
15418: PPUSH
15419: NOP4
15423: PUSH
15424: NOP4
15428: PPUSH
15429: NOP4
15433: PUSH
15434: LD_INT 6
15436: EQUAL
15437: PUSH
15438: NOP4
15442: PPUSH
15443: NOP4
15447: PUSH
15448: LD_INT 6
15450: EQUAL
15451: OR
15452: AND
15453: OR
15454: AND
15455: IFFALSE 15475
15457: GO 15459
15459: DISABLE
// begin ChangeMissionObjectives ( M9a ) ;
15460: LD_STRING M9a
15462: PPUSH
15463: NOP4
// saveBelkovObjective = false ;
15467: NOP4
15471: PUSH
15472: LD_INT 0
15474: ST_TO_ADDR
// end ;
15475: END
// every 0 0$5 trigger belkovSaved and ( ( GetDistUnits ( Burlak , Belkov ) < 14 and belkovReturn ) or ( GetDistUnits ( Burlak , Belkov2 ) < 14 and not belkovReturn ) ) do
15476: NOP4
15480: PUSH
15481: NOP4
15485: PPUSH
15486: NOP4
15490: PPUSH
15491: NOP4
15495: PUSH
15496: LD_INT 14
15498: LESS
15499: PUSH
15500: NOP4
15504: AND
15505: PUSH
15506: NOP4
15510: PPUSH
15511: NOP4
15515: PPUSH
15516: NOP4
15520: PUSH
15521: LD_INT 14
15523: LESS
15524: PUSH
15525: NOP4
15529: NOT
15530: AND
15531: OR
15532: AND
15533: IFFALSE 15829
15535: GO 15537
15537: DISABLE
// begin InGameOn ;
15538: NOP4
// if IsOk ( Belkov ) and belkovReturn then
15542: NOP4
15546: PPUSH
15547: NOP4
15551: PUSH
15552: NOP4
15556: AND
15557: IFFALSE 15653
// begin CenterNowOnUnits ( [ Burlak , Belkov ] ) ;
15559: NOP4
15563: PUSH
15564: NOP4
15568: PUSH
15569: EMPTY
15570: LIST
15571: LIST
15572: PPUSH
15573: NOP4
// ComTurnUnit ( Burlak , Belkov ) ;
15577: NOP4
15581: PPUSH
15582: NOP4
15586: PPUSH
15587: NOP4
// ComTurnUnit ( Belkov , Burlak ) ;
15591: NOP4
15595: PPUSH
15596: NOP4
15600: PPUSH
15601: NOP4
// Say ( Belkov , D24-Bel-1 ) ;
15605: NOP4
15609: PPUSH
15610: LD_STRING D24-Bel-1
15612: PPUSH
15613: NOP4
// Say ( Burlak , D24-Bur-1 ) ;
15617: NOP4
15621: PPUSH
15622: LD_STRING D24-Bur-1
15624: PPUSH
15625: NOP4
// Say ( Belkov , D24-Bel-2 ) ;
15629: NOP4
15633: PPUSH
15634: LD_STRING D24-Bel-2
15636: PPUSH
15637: NOP4
// Say ( Burlak , D24-Bur-2 ) ;
15641: NOP4
15645: PPUSH
15646: LD_STRING D24-Bur-2
15648: PPUSH
15649: NOP4
// end ; if IsOk ( Belkov2 ) and not belkovReturn then
15653: NOP4
15657: PPUSH
15658: NOP4
15662: PUSH
15663: NOP4
15667: NOT
15668: AND
15669: IFFALSE 15777
// begin CenterNowOnUnits ( [ Burlak , Belkov2 ] ) ;
15671: NOP4
15675: PUSH
15676: NOP4
15680: PUSH
15681: EMPTY
15682: LIST
15683: LIST
15684: PPUSH
15685: NOP4
// ComTurnUnit ( Burlak , Belkov2 ) ;
15689: NOP4
15693: PPUSH
15694: NOP4
15698: PPUSH
15699: NOP4
// ComTurnUnit ( Belkov2 , Burlak ) ;
15703: NOP4
15707: PPUSH
15708: NOP4
15712: PPUSH
15713: NOP4
// Say ( Belkov2 , D24-Bel-1 ) ;
15717: NOP4
15721: PPUSH
15722: LD_STRING D24-Bel-1
15724: PPUSH
15725: NOP4
// Say ( Burlak , D24-Bur-1 ) ;
15729: NOP4
15733: PPUSH
15734: LD_STRING D24-Bur-1
15736: PPUSH
15737: NOP4
// Say ( Burlak , D24-Bur-1a ) ;
15741: NOP4
15745: PPUSH
15746: LD_STRING D24-Bur-1a
15748: PPUSH
15749: NOP4
// Say ( Belkov2 , D24-Bel-2 ) ;
15753: NOP4
15757: PPUSH
15758: LD_STRING D24-Bel-2
15760: PPUSH
15761: NOP4
// Say ( Burlak , D24-Bur-2 ) ;
15765: NOP4
15769: PPUSH
15770: LD_STRING D24-Bur-2
15772: PPUSH
15773: NOP4
// end ; if captureBelkovVehicle then
15777: NOP4
15781: IFFALSE 15795
// Say ( Burlak , D24-Bur-2a ) ;
15783: NOP4
15787: PPUSH
15788: LD_STRING D24-Bur-2a
15790: PPUSH
15791: NOP4
// SayRadio ( Platonov , D24-Pla-2 ) ;
15795: NOP4
15799: PPUSH
15800: LD_STRING D24-Pla-2
15802: PPUSH
15803: NOP4
// if leftBunkers then
15807: NOP4
15811: IFFALSE 15825
// SayRadio ( Platonov , D24-Pla-2a ) ;
15813: NOP4
15817: PPUSH
15818: LD_STRING D24-Pla-2a
15820: PPUSH
15821: NOP4
// InGameOff ;
15825: NOP4
// end ;
15829: END
// every 0 0$1 trigger FilterUnitsInArea ( TrackDialogArea , [ [ f_side , 3 ] , [ f_type , unit_vehicle ] ] ) and ( IsOk ( Kovalyuk ) or IsOK ( Gnyevko ) ) do
15830: LD_INT 22
15832: PPUSH
15833: LD_INT 22
15835: PUSH
15836: LD_INT 3
15838: PUSH
15839: EMPTY
15840: LIST
15841: LIST
15842: PUSH
15843: LD_INT 21
15845: PUSH
15846: LD_INT 2
15848: PUSH
15849: EMPTY
15850: LIST
15851: LIST
15852: PUSH
15853: EMPTY
15854: LIST
15855: LIST
15856: PPUSH
15857: NOP4
15861: PUSH
15862: NOP4
15866: PPUSH
15867: NOP4
15871: PUSH
15872: NOP4
15876: PPUSH
15877: NOP4
15881: OR
15882: AND
15883: IFFALSE 15966
15885: GO 15887
15887: DISABLE
// begin DialogueOn ;
15888: NOP4
// Say ( Burlak , D26-Bur-1 ) ;
15892: NOP4
15896: PPUSH
15897: LD_STRING D26-Bur-1
15899: PPUSH
15900: NOP4
// if IsOk ( Kovalyuk ) then
15904: NOP4
15908: PPUSH
15909: NOP4
15913: IFFALSE 15927
// Say ( Kovalyuk , D26-Kov-1 ) ;
15915: NOP4
15919: PPUSH
15920: LD_STRING D26-Kov-1
15922: PPUSH
15923: NOP4
// if IsOk ( Gnyevko ) then
15927: NOP4
15931: PPUSH
15932: NOP4
15936: IFFALSE 15950
// Say ( Gnyevko , D26-Gny-1 ) ;
15938: NOP4
15942: PPUSH
15943: LD_STRING D26-Gny-1
15945: PPUSH
15946: NOP4
// Say ( Burlak , D26-Bur-2 ) ;
15950: NOP4
15954: PPUSH
15955: LD_STRING D26-Bur-2
15957: PPUSH
15958: NOP4
// DialogueOff ;
15962: NOP4
// end ;
15966: END
// every 0 0$1 trigger canExploreMap and ( not IsInArea ( Burlak , BeriaBaseArea ) and not IsInArea ( IsInUnit ( IsInUnit ( Burlak ) ) , BeriaBaseArea ) ) and raportForPlatonov = - 1 do
15967: NOP4
15971: PUSH
15972: NOP4
15976: PPUSH
15977: LD_INT 8
15979: PPUSH
15980: NOP4
15984: NOT
15985: PUSH
15986: NOP4
15990: PPUSH
15991: NOP4
15995: PPUSH
15996: NOP4
16000: PPUSH
16001: LD_INT 8
16003: PPUSH
16004: NOP4
16008: NOT
16009: AND
16010: AND
16011: PUSH
16012: NOP4
16016: PUSH
16017: LD_INT 1
16019: NEG
16020: EQUAL
16021: AND
16022: IFFALSE 16036
16024: GO 16026
16026: DISABLE
// begin enable ;
16027: ENABLE
// raportForPlatonov = 0 ;
16028: NOP4
16032: PUSH
16033: LD_INT 0
16035: ST_TO_ADDR
// end ;
16036: END
// every 0 0$1 trigger canExploreMap and raportForPlatonov >= 0 and not backToBeria2 and ( IsInArea ( Burlak , BeriaBaseArea ) or IsInArea ( IsInUnit ( IsInUnit ( Burlak ) ) , BeriaBaseArea ) and not backToBeria2 ) do
16037: NOP4
16041: PUSH
16042: NOP4
16046: PUSH
16047: LD_INT 0
16049: GREATEREQUAL
16050: AND
16051: PUSH
16052: NOP4
16056: NOT
16057: AND
16058: PUSH
16059: NOP4
16063: PPUSH
16064: LD_INT 8
16066: PPUSH
16067: NOP4
16071: PUSH
16072: NOP4
16076: PPUSH
16077: NOP4
16081: PPUSH
16082: NOP4
16086: PPUSH
16087: LD_INT 8
16089: PPUSH
16090: NOP4
16094: PUSH
16095: NOP4
16099: NOT
16100: AND
16101: OR
16102: AND
16103: IFFALSE 16394
16105: GO 16107
16107: DISABLE
// begin enable ;
16108: ENABLE
// DialogueOn ;
16109: NOP4
// case raportForPlatonov of 0 :
16113: NOP4
16117: PUSH
16118: LD_INT 0
16120: DOUBLE
16121: EQUAL
16122: IFTRUE 16126
16124: GO 16153
16126: POP
// begin Say ( Platonov , D25a-Pla-1 ) ;
16127: NOP4
16131: PPUSH
16132: LD_STRING D25a-Pla-1
16134: PPUSH
16135: NOP4
// Say ( Burlak , D25a-Bur-1 ) ;
16139: NOP4
16143: PPUSH
16144: LD_STRING D25a-Bur-1
16146: PPUSH
16147: NOP4
// end ; 1 :
16151: GO 16369
16153: LD_INT 1
16155: DOUBLE
16156: EQUAL
16157: IFTRUE 16161
16159: GO 16224
16161: POP
// begin Say ( Platonov , D25-Pla-1 ) ;
16162: NOP4
16166: PPUSH
16167: LD_STRING D25-Pla-1
16169: PPUSH
16170: NOP4
// Say ( Burlak , D25-Bur-1 ) ;
16174: NOP4
16178: PPUSH
16179: LD_STRING D25-Bur-1
16181: PPUSH
16182: NOP4
// Say ( Burlak , D25b-Bur-1 ) ;
16186: NOP4
16190: PPUSH
16191: LD_STRING D25b-Bur-1
16193: PPUSH
16194: NOP4
// Say ( Platonov , D25b-Pla-1 ) ;
16198: NOP4
16202: PPUSH
16203: LD_STRING D25b-Pla-1
16205: PPUSH
16206: NOP4
// playerGetSupport = true ;
16210: NOP4
16214: PUSH
16215: LD_INT 1
16217: ST_TO_ADDR
// PlatonovSendSupport ;
16218: NOP4
// end ; 2 :
16222: GO 16369
16224: LD_INT 2
16226: DOUBLE
16227: EQUAL
16228: IFTRUE 16232
16230: GO 16278
16232: POP
// begin Say ( Platonov , D25-Pla-1 ) ;
16233: NOP4
16237: PPUSH
16238: LD_STRING D25-Pla-1
16240: PPUSH
16241: NOP4
// Say ( Burlak , D25-Bur-1a ) ;
16245: NOP4
16249: PPUSH
16250: LD_STRING D25-Bur-1a
16252: PPUSH
16253: NOP4
// if not sawLeftBunker then
16257: NOP4
16261: NOT
16262: IFFALSE 16276
// Say ( Platonov , D25c-Pla-1 ) ;
16264: NOP4
16268: PPUSH
16269: LD_STRING D25c-Pla-1
16271: PPUSH
16272: NOP4
// end ; 3 :
16276: GO 16369
16278: LD_INT 3
16280: DOUBLE
16281: EQUAL
16282: IFTRUE 16286
16284: GO 16368
16286: POP
// begin Say ( Platonov , D25-Pla-1 ) ;
16287: NOP4
16291: PPUSH
16292: LD_STRING D25-Pla-1
16294: PPUSH
16295: NOP4
// Say ( Burlak , D25a-Bur-1b ) ;
16299: NOP4
16303: PPUSH
16304: LD_STRING D25a-Bur-1b
16306: PPUSH
16307: NOP4
// Say ( Burlak , D25b-Bur-1 ) ;
16311: NOP4
16315: PPUSH
16316: LD_STRING D25b-Bur-1
16318: PPUSH
16319: NOP4
// Say ( Platonov , D25b-Pla-1 ) ;
16323: NOP4
16327: PPUSH
16328: LD_STRING D25b-Pla-1
16330: PPUSH
16331: NOP4
// playerGetSupport = true ;
16335: NOP4
16339: PUSH
16340: LD_INT 1
16342: ST_TO_ADDR
// PlatonovSendSupport ;
16343: NOP4
// if not sawRightBunker then
16347: NOP4
16351: NOT
16352: IFFALSE 16366
// Say ( Platonov , D25c-Pla-1 ) ;
16354: NOP4
16358: PPUSH
16359: LD_STRING D25c-Pla-1
16361: PPUSH
16362: NOP4
// end ; end ;
16366: GO 16369
16368: POP
// raportForPlatonov = - 1 ;
16369: NOP4
16373: PUSH
16374: LD_INT 1
16376: NEG
16377: ST_TO_ADDR
// Say ( Platonov , D25c-Pla-1a ) ;
16378: NOP4
16382: PPUSH
16383: LD_STRING D25c-Pla-1a
16385: PPUSH
16386: NOP4
// DialogueOff ;
16390: NOP4
// end ;
16394: END
// every 0 0$1 trigger FilterUnitsInArea ( NorthArea , [ [ f_side , 3 ] ] ) > 0 do
16395: LD_INT 19
16397: PPUSH
16398: LD_INT 22
16400: PUSH
16401: LD_INT 3
16403: PUSH
16404: EMPTY
16405: LIST
16406: LIST
16407: PUSH
16408: EMPTY
16409: LIST
16410: PPUSH
16411: NOP4
16415: PUSH
16416: LD_INT 0
16418: GREATER
16419: IFFALSE 16439
16421: GO 16423
16423: DISABLE
// begin northMapExplored = true ;
16424: NOP4
16428: PUSH
16429: LD_INT 1
16431: ST_TO_ADDR
// ChangeMissionObjectives ( M10 ) ;
16432: LD_STRING M10
16434: PPUSH
16435: NOP4
// end ;
16439: END
// every 0 0$1 trigger not leftBunkers and northMapExplored and ( belkovSaved or not saveBelkovObjective ) do
16440: NOP4
16444: NOT
16445: PUSH
16446: NOP4
16450: AND
16451: PUSH
16452: NOP4
16456: PUSH
16457: NOP4
16461: NOT
16462: OR
16463: AND
16464: IFFALSE 16484
16466: GO 16468
16468: DISABLE
// begin backToBeria2 = true ;
16469: NOP4
16473: PUSH
16474: LD_INT 1
16476: ST_TO_ADDR
// ChangeMissionObjectives ( M10a ) ;
16477: LD_STRING M10a
16479: PPUSH
16480: NOP4
// end ;
16484: END
// every 0 0$1 do
16485: GO 16487
16487: DISABLE
// begin enable ;
16488: ENABLE
// SetLives ( [ Kurin , Platonov ] , 1000 ) ;
16489: NOP4
16493: PUSH
16494: NOP4
16498: PUSH
16499: EMPTY
16500: LIST
16501: LIST
16502: PPUSH
16503: LD_INT 1000
16505: PPUSH
16506: NOP4
// end ; end_of_file
16510: END
// export function PrepareNature ; var i , un ; begin
16511: LD_INT 0
16513: PPUSH
16514: PPUSH
16515: PPUSH
// for i := 1 to animalsAmount [ 1 ] do
16516: NOP4
16520: PUSH
16521: DOUBLE
16522: LD_INT 1
16524: DEC
16525: ST_TO_ADDR
16526: NOP4
16530: PUSH
16531: LD_INT 1
16533: ARRAY
16534: PUSH
16535: FOR_TO
16536: IFFALSE 16646
// begin uc_side = 0 ;
16538: LD_ADDR_OWVAR 20
16542: PUSH
16543: LD_INT 0
16545: ST_TO_ADDR
// uc_nation = nation_nature ;
16546: LD_ADDR_OWVAR 21
16550: PUSH
16551: LD_INT 0
16553: ST_TO_ADDR
// hc_class = class_apeman ;
16554: LD_ADDR_OWVAR 28
16558: PUSH
16559: LD_INT 12
16561: ST_TO_ADDR
// hc_skills = [ animalsStats [ 1 ] , animalsStats [ 2 ] , animalsStats [ 3 ] , animalsStats [ 4 ] ] ;
16562: LD_ADDR_OWVAR 31
16566: PUSH
16567: NOP4
16571: PUSH
16572: LD_INT 1
16574: ARRAY
16575: PUSH
16576: NOP4
16580: PUSH
16581: LD_INT 2
16583: ARRAY
16584: PUSH
16585: NOP4
16589: PUSH
16590: LD_INT 3
16592: ARRAY
16593: PUSH
16594: NOP4
16598: PUSH
16599: LD_INT 4
16601: ARRAY
16602: PUSH
16603: EMPTY
16604: LIST
16605: LIST
16606: LIST
16607: LIST
16608: ST_TO_ADDR
// hc_agressivity = animalsAgression ;
16609: LD_ADDR_OWVAR 35
16613: PUSH
16614: NOP4
16618: ST_TO_ADDR
// un = CreateHuman ;
16619: NOP4
16623: PUSH
16624: NOP4
16628: ST_TO_ADDR
// PlaceUnitArea ( un , NatureArea , false ) ;
16629: NOP4
16633: PPUSH
16634: LD_INT 21
16636: PPUSH
16637: LD_INT 0
16639: PPUSH
16640: NOP4
// end ;
16644: GO 16535
16646: POP
16647: POP
// for i := 1 to animalsAmount [ 2 ] do
16648: NOP4
16652: PUSH
16653: DOUBLE
16654: LD_INT 1
16656: DEC
16657: ST_TO_ADDR
16658: NOP4
16662: PUSH
16663: LD_INT 2
16665: ARRAY
16666: PUSH
16667: FOR_TO
16668: IFFALSE 16778
// begin uc_side = 0 ;
16670: LD_ADDR_OWVAR 20
16674: PUSH
16675: LD_INT 0
16677: ST_TO_ADDR
// uc_nation = nation_nature ;
16678: LD_ADDR_OWVAR 21
16682: PUSH
16683: LD_INT 0
16685: ST_TO_ADDR
// hc_class = class_phororhacos ;
16686: LD_ADDR_OWVAR 28
16690: PUSH
16691: LD_INT 18
16693: ST_TO_ADDR
// hc_skills = [ animalsStats [ 1 ] , animalsStats [ 2 ] , animalsStats [ 3 ] , animalsStats [ 4 ] ] ;
16694: LD_ADDR_OWVAR 31
16698: PUSH
16699: NOP4
16703: PUSH
16704: LD_INT 1
16706: ARRAY
16707: PUSH
16708: NOP4
16712: PUSH
16713: LD_INT 2
16715: ARRAY
16716: PUSH
16717: NOP4
16721: PUSH
16722: LD_INT 3
16724: ARRAY
16725: PUSH
16726: NOP4
16730: PUSH
16731: LD_INT 4
16733: ARRAY
16734: PUSH
16735: EMPTY
16736: LIST
16737: LIST
16738: LIST
16739: LIST
16740: ST_TO_ADDR
// hc_agressivity = animalsAgression ;
16741: LD_ADDR_OWVAR 35
16745: PUSH
16746: NOP4
16750: ST_TO_ADDR
// un = CreateHuman ;
16751: NOP4
16755: PUSH
16756: NOP4
16760: ST_TO_ADDR
// PlaceUnitArea ( un , NatureArea , false ) ;
16761: NOP4
16765: PPUSH
16766: LD_INT 21
16768: PPUSH
16769: LD_INT 0
16771: PPUSH
16772: NOP4
// end ;
16776: GO 16667
16778: POP
16779: POP
// for i := 1 to animalsAmount [ 3 ] do
16780: NOP4
16784: PUSH
16785: DOUBLE
16786: LD_INT 1
16788: DEC
16789: ST_TO_ADDR
16790: NOP4
16794: PUSH
16795: LD_INT 3
16797: ARRAY
16798: PUSH
16799: FOR_TO
16800: IFFALSE 16910
// begin uc_side = 0 ;
16802: LD_ADDR_OWVAR 20
16806: PUSH
16807: LD_INT 0
16809: ST_TO_ADDR
// uc_nation = nation_nature ;
16810: LD_ADDR_OWVAR 21
16814: PUSH
16815: LD_INT 0
16817: ST_TO_ADDR
// hc_class = class_tiger ;
16818: LD_ADDR_OWVAR 28
16822: PUSH
16823: LD_INT 14
16825: ST_TO_ADDR
// hc_skills = [ animalsStats [ 1 ] , animalsStats [ 2 ] , animalsStats [ 3 ] , animalsStats [ 4 ] ] ;
16826: LD_ADDR_OWVAR 31
16830: PUSH
16831: NOP4
16835: PUSH
16836: LD_INT 1
16838: ARRAY
16839: PUSH
16840: NOP4
16844: PUSH
16845: LD_INT 2
16847: ARRAY
16848: PUSH
16849: NOP4
16853: PUSH
16854: LD_INT 3
16856: ARRAY
16857: PUSH
16858: NOP4
16862: PUSH
16863: LD_INT 4
16865: ARRAY
16866: PUSH
16867: EMPTY
16868: LIST
16869: LIST
16870: LIST
16871: LIST
16872: ST_TO_ADDR
// hc_agressivity = animalsAgression ;
16873: LD_ADDR_OWVAR 35
16877: PUSH
16878: NOP4
16882: ST_TO_ADDR
// un = CreateHuman ;
16883: NOP4
16887: PUSH
16888: NOP4
16892: ST_TO_ADDR
// PlaceUnitArea ( un , NatureArea , false ) ;
16893: NOP4
16897: PPUSH
16898: LD_INT 21
16900: PPUSH
16901: LD_INT 0
16903: PPUSH
16904: NOP4
// end ;
16908: GO 16799
16910: POP
16911: POP
// for i := 1 to animalsAmount [ 4 ] do
16912: NOP4
16916: PUSH
16917: DOUBLE
16918: LD_INT 1
16920: DEC
16921: ST_TO_ADDR
16922: NOP4
16926: PUSH
16927: LD_INT 4
16929: ARRAY
16930: PUSH
16931: FOR_TO
16932: IFFALSE 17042
// begin uc_side = 0 ;
16934: LD_ADDR_OWVAR 20
16938: PUSH
16939: LD_INT 0
16941: ST_TO_ADDR
// uc_nation = nation_nature ;
16942: LD_ADDR_OWVAR 21
16946: PUSH
16947: LD_INT 0
16949: ST_TO_ADDR
// hc_class = 21 ;
16950: LD_ADDR_OWVAR 28
16954: PUSH
16955: LD_INT 21
16957: ST_TO_ADDR
// hc_skills = [ animalsStats [ 1 ] , animalsStats [ 2 ] , animalsStats [ 3 ] , animalsStats [ 4 ] ] ;
16958: LD_ADDR_OWVAR 31
16962: PUSH
16963: NOP4
16967: PUSH
16968: LD_INT 1
16970: ARRAY
16971: PUSH
16972: NOP4
16976: PUSH
16977: LD_INT 2
16979: ARRAY
16980: PUSH
16981: NOP4
16985: PUSH
16986: LD_INT 3
16988: ARRAY
16989: PUSH
16990: NOP4
16994: PUSH
16995: LD_INT 4
16997: ARRAY
16998: PUSH
16999: EMPTY
17000: LIST
17001: LIST
17002: LIST
17003: LIST
17004: ST_TO_ADDR
// hc_agressivity = animalsAgression ;
17005: LD_ADDR_OWVAR 35
17009: PUSH
17010: NOP4
17014: ST_TO_ADDR
// un = CreateHuman ;
17015: NOP4
17019: PUSH
17020: NOP4
17024: ST_TO_ADDR
// PlaceUnitArea ( un , NatureArea , false ) ;
17025: NOP4
17029: PPUSH
17030: LD_INT 21
17032: PPUSH
17033: LD_INT 0
17035: PPUSH
17036: NOP4
// end ;
17040: GO 16931
17042: POP
17043: POP
// end ; end_of_file
17044: LD_VAR 0 1
17048: RET
// every 0 0$1 trigger spawnCrates do var i , unit , carryCratesEngs , playerEngs , spawnNextCrates ;
17049: NOP4
17053: IFFALSE 17282
17055: GO 17057
17057: DISABLE
17058: LD_INT 0
17060: PPUSH
17061: PPUSH
17062: PPUSH
17063: PPUSH
17064: PPUSH
// begin repeat playerEngs = FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_class , class_engineer ] ] ) ;
17065: NOP4
17069: PUSH
17070: LD_INT 22
17072: PUSH
17073: LD_INT 3
17075: PUSH
17076: EMPTY
17077: LIST
17078: LIST
17079: PUSH
17080: LD_INT 21
17082: PUSH
17083: LD_INT 1
17085: PUSH
17086: EMPTY
17087: LIST
17088: LIST
17089: PUSH
17090: LD_INT 25
17092: PUSH
17093: LD_INT 2
17095: PUSH
17096: EMPTY
17097: LIST
17098: LIST
17099: PUSH
17100: EMPTY
17101: LIST
17102: LIST
17103: LIST
17104: PPUSH
17105: NOP4
17109: ST_TO_ADDR
// wait ( 0 0$20 ) ;
17110: LD_INT 700
17112: PPUSH
17113: NOP4
// carryCratesEngs = 0 ;
17117: NOP4
17121: PUSH
17122: LD_INT 0
17124: ST_TO_ADDR
// for unit in playerEngs do
17125: NOP4
17129: PUSH
17130: NOP4
17134: PUSH
17135: FOR_IN
17136: IFFALSE 17164
// carryCratesEngs = carryCratesEngs + GetCargo ( unit , mat_cans ) ;
17138: NOP4
17142: PUSH
17143: NOP4
17147: PUSH
17148: NOP4
17152: PPUSH
17153: LD_INT 1
17155: PPUSH
17156: NOP4
17160: PLUS
17161: ST_TO_ADDR
17162: GO 17135
17164: POP
17165: POP
// if GetResourceType ( GetBase ( beria ) , mat_cans ) < 50 and ( GetResourceArea ( beriaBaseArea , mat_cans ) * 10 ) + GetResourceType ( GetBase ( beria ) , mat_cans ) + carryCratesEngs < 50 then
17166: LD_INT 106
17168: PPUSH
17169: NOP4
17173: PPUSH
17174: LD_INT 1
17176: PPUSH
17177: NOP4
17181: PUSH
17182: LD_INT 50
17184: LESS
17185: PUSH
17186: LD_INT 8
17188: PPUSH
17189: LD_INT 1
17191: PPUSH
17192: NOP4
17196: PUSH
17197: LD_INT 10
17199: MUL
17200: PUSH
17201: LD_INT 106
17203: PPUSH
17204: NOP4
17208: PPUSH
17209: LD_INT 1
17211: PPUSH
17212: NOP4
17216: PLUS
17217: PUSH
17218: NOP4
17222: PLUS
17223: PUSH
17224: LD_INT 50
17226: LESS
17227: AND
17228: IFFALSE 17240
// spawnNextCrates = true else
17230: NOP4
17234: PUSH
17235: LD_INT 1
17237: ST_TO_ADDR
17238: GO 17248
// spawnNextCrates = false ;
17240: NOP4
17244: PUSH
17245: LD_INT 0
17247: ST_TO_ADDR
// if spawnNextCrates then
17248: NOP4
17252: IFFALSE 17275
// CreateCratesArea ( rand ( 1 , 5 ) , CratesArea , true ) ;
17254: LD_INT 1
17256: PPUSH
17257: LD_INT 5
17259: PPUSH
17260: NOP4
17264: PPUSH
17265: LD_INT 26
17267: PPUSH
17268: LD_INT 1
17270: PPUSH
17271: NOP4
// until not spawnCrates ;
17275: NOP4
17279: NOT
17280: IFFALSE 17065
// end ; end_of_file
17282: PPOPN 5
17284: END
// on BuildingStarted ( building , builder ) do begin if GetBType ( building ) = b_lab and FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_lab ] ] ) > 1 and not canBuildSameBuilding then
17285: NOP4
17289: PPUSH
17290: NOP4
17294: PUSH
17295: LD_INT 6
17297: EQUAL
17298: PUSH
17299: LD_INT 22
17301: PUSH
17302: LD_INT 3
17304: PUSH
17305: EMPTY
17306: LIST
17307: LIST
17308: PUSH
17309: LD_INT 30
17311: PUSH
17312: LD_INT 6
17314: PUSH
17315: EMPTY
17316: LIST
17317: LIST
17318: PUSH
17319: EMPTY
17320: LIST
17321: LIST
17322: PPUSH
17323: NOP4
17327: PUSH
17328: LD_INT 1
17330: GREATER
17331: AND
17332: PUSH
17333: NOP4
17337: NOT
17338: AND
17339: IFFALSE 17350
// Dial_StopConstructAgainSameBuilding ( building ) ;
17341: NOP4
17345: PPUSH
17346: NOP4
// if GetBType ( building ) = b_workshop and FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_workshop ] ] ) > 1 and not canBuildSameBuilding then
17350: NOP4
17354: PPUSH
17355: NOP4
17359: PUSH
17360: LD_INT 2
17362: EQUAL
17363: PUSH
17364: LD_INT 22
17366: PUSH
17367: LD_INT 3
17369: PUSH
17370: EMPTY
17371: LIST
17372: LIST
17373: PUSH
17374: LD_INT 30
17376: PUSH
17377: LD_INT 2
17379: PUSH
17380: EMPTY
17381: LIST
17382: LIST
17383: PUSH
17384: EMPTY
17385: LIST
17386: LIST
17387: PPUSH
17388: NOP4
17392: PUSH
17393: LD_INT 1
17395: GREATER
17396: AND
17397: PUSH
17398: NOP4
17402: NOT
17403: AND
17404: IFFALSE 17415
// Dial_StopConstructAgainSameBuilding ( building ) ;
17406: NOP4
17410: PPUSH
17411: NOP4
// if GetSide ( building ) = 3 and GetBType ( building ) in [ b_oil_power , b_armoury , b_breastwork ] and IsInArea ( building , BeriaBaseArea ) then
17415: NOP4
17419: PPUSH
17420: NOP4
17424: PUSH
17425: LD_INT 3
17427: EQUAL
17428: PUSH
17429: NOP4
17433: PPUSH
17434: NOP4
17438: PUSH
17439: LD_INT 26
17441: PUSH
17442: LD_INT 4
17444: PUSH
17445: LD_INT 31
17447: PUSH
17448: EMPTY
17449: LIST
17450: LIST
17451: LIST
17452: IN
17453: AND
17454: PUSH
17455: NOP4
17459: PPUSH
17460: LD_INT 8
17462: PPUSH
17463: NOP4
17467: AND
17468: IFFALSE 17479
// Dial_StopConstructAgainSameBuilding ( building ) ;
17470: NOP4
17474: PPUSH
17475: NOP4
// end ;
17479: PPOPN 2
17481: END
// on BuildingComplete ( building ) do var sold , platSold ;
17482: LD_INT 0
17484: PPUSH
17485: PPUSH
// begin if GetSide ( building ) = 3 and GetBType ( building ) = b_lab and not labConstructed then
17486: NOP4
17490: PPUSH
17491: NOP4
17495: PUSH
17496: LD_INT 3
17498: EQUAL
17499: PUSH
17500: NOP4
17504: PPUSH
17505: NOP4
17509: PUSH
17510: LD_INT 6
17512: EQUAL
17513: AND
17514: PUSH
17515: NOP4
17519: NOT
17520: AND
17521: IFFALSE 17527
// Dial_LabConstructed ;
17523: NOP4
// if GetSide ( building ) = 3 and GetBType ( building ) = b_workshop and not workshopConstructed then
17527: NOP4
17531: PPUSH
17532: NOP4
17536: PUSH
17537: LD_INT 3
17539: EQUAL
17540: PUSH
17541: NOP4
17545: PPUSH
17546: NOP4
17550: PUSH
17551: LD_INT 2
17553: EQUAL
17554: AND
17555: PUSH
17556: NOP4
17560: NOT
17561: AND
17562: IFFALSE 17568
// Dial_WorkshopConstructed ;
17564: NOP4
// if GetSide ( building ) = 6 then
17568: NOP4
17572: PPUSH
17573: NOP4
17577: PUSH
17578: LD_INT 6
17580: EQUAL
17581: IFFALSE 17792
// begin if GetBType ( building ) = b_breastwork and IsInArea ( building , KirovBaseArea ) then
17583: NOP4
17587: PPUSH
17588: NOP4
17592: PUSH
17593: LD_INT 31
17595: EQUAL
17596: PUSH
17597: NOP4
17601: PPUSH
17602: LD_INT 9
17604: PPUSH
17605: NOP4
17609: AND
17610: IFFALSE 17661
// begin if UnitsInside ( ru2_arm2 ) then
17612: LD_INT 209
17614: PPUSH
17615: NOP4
17619: IFFALSE 17661
// begin sold = UnitsInside ( ru2_arm2 ) [ 1 ] ;
17621: NOP4
17625: PUSH
17626: LD_INT 209
17628: PPUSH
17629: NOP4
17633: PUSH
17634: LD_INT 1
17636: ARRAY
17637: ST_TO_ADDR
// ComExitBuilding ( sold ) ;
17638: NOP4
17642: PPUSH
17643: NOP4
// AddComEnterUnit ( sold , building ) ;
17647: NOP4
17651: PPUSH
17652: NOP4
17656: PPUSH
17657: NOP4
// end ; end ; if GetBType ( building ) = b_breastwork and IsInArea ( building , BeriaBaseArea ) then
17661: NOP4
17665: PPUSH
17666: NOP4
17670: PUSH
17671: LD_INT 31
17673: EQUAL
17674: PUSH
17675: NOP4
17679: PPUSH
17680: LD_INT 8
17682: PPUSH
17683: NOP4
17687: AND
17688: IFFALSE 17724
// begin sold = NearestUnitToUnit ( platSoldiers , building ) ;
17690: NOP4
17694: PUSH
17695: NOP4
17699: PPUSH
17700: NOP4
17704: PPUSH
17705: NOP4
17709: ST_TO_ADDR
// ComEnterUnit ( sold , building ) ;
17710: NOP4
17714: PPUSH
17715: NOP4
17719: PPUSH
17720: NOP4
// end ; if GetBType ( building ) = b_workshop then
17724: NOP4
17728: PPUSH
17729: NOP4
17733: PUSH
17734: LD_INT 2
17736: EQUAL
17737: IFFALSE 17792
// begin ComExitBuilding ( UnitFilter ( otherKirovUnits , [ f_class , class_mechanic ] ) ) ;
17739: NOP4
17743: PPUSH
17744: LD_INT 25
17746: PUSH
17747: LD_INT 3
17749: PUSH
17750: EMPTY
17751: LIST
17752: LIST
17753: PPUSH
17754: NOP4
17758: PPUSH
17759: NOP4
// AddComEnterUnit ( UnitFilter ( otherKirovUnits , [ f_class , class_mechanic ] ) , building ) ;
17763: NOP4
17767: PPUSH
17768: LD_INT 25
17770: PUSH
17771: LD_INT 3
17773: PUSH
17774: EMPTY
17775: LIST
17776: LIST
17777: PPUSH
17778: NOP4
17782: PPUSH
17783: NOP4
17787: PPUSH
17788: NOP4
// end ; end ; end ;
17792: PPOPN 3
17794: END
// on ResearchComplete ( tech , building ) do begin if tech = tech_oilEng and GetSide ( building ) = 3 then
17795: NOP4
17799: PUSH
17800: LD_INT 47
17802: EQUAL
17803: PUSH
17804: NOP4
17808: PPUSH
17809: NOP4
17813: PUSH
17814: LD_INT 3
17816: EQUAL
17817: AND
17818: IFFALSE 17828
// engineResearched = true ;
17820: NOP4
17824: PUSH
17825: LD_INT 1
17827: ST_TO_ADDR
// if tech = tech_Tech1 then
17828: NOP4
17832: PUSH
17833: LD_INT 48
17835: EQUAL
17836: IFFALSE 17858
// begin wait ( 0 0$5 ) ;
17838: LD_INT 175
17840: PPUSH
17841: NOP4
// SetSpecResearch ( ru_lab , 1500 , false ) ;
17845: LD_INT 83
17847: PPUSH
17848: LD_INT 1500
17850: PPUSH
17851: LD_INT 0
17853: PPUSH
17854: NOP4
// end ; end ;
17858: PPOPN 2
17860: END
// on VehicleConstructed ( vehicle , factory ) do begin if GetSide ( factory ) = your_side and IsOK ( factory ) and not constructedFirstVehicle and not construcMoreVehicles then
17861: NOP4
17865: PPUSH
17866: NOP4
17870: PUSH
17871: NOP4
17875: EQUAL
17876: PUSH
17877: NOP4
17881: PPUSH
17882: NOP4
17886: AND
17887: PUSH
17888: NOP4
17892: NOT
17893: AND
17894: PUSH
17895: NOP4
17899: NOT
17900: AND
17901: IFFALSE 17912
// Dial_FirstVehConstructed ( factory ) ;
17903: NOP4
17907: PPUSH
17908: NOP4
// if GetSide ( factory ) = your_side and not vehicleForKurin and not IsOK ( firstVeh ) then
17912: NOP4
17916: PPUSH
17917: NOP4
17921: PUSH
17922: NOP4
17926: EQUAL
17927: PUSH
17928: NOP4
17932: NOT
17933: AND
17934: PUSH
17935: NOP4
17939: PPUSH
17940: NOP4
17944: NOT
17945: AND
17946: IFFALSE 17958
// firstVeh = vehicle ;
17948: NOP4
17952: PUSH
17953: NOP4
17957: ST_TO_ADDR
// if GetSide ( factory ) = your_side and IsOK ( factory ) and construcMoreVehicles then
17958: NOP4
17962: PPUSH
17963: NOP4
17967: PUSH
17968: NOP4
17972: EQUAL
17973: PUSH
17974: NOP4
17978: PPUSH
17979: NOP4
17983: AND
17984: PUSH
17985: NOP4
17989: AND
17990: IFFALSE 18006
// constructedVehiclesCounter = constructedVehiclesCounter + 1 ;
17992: NOP4
17996: PUSH
17997: NOP4
18001: PUSH
18002: LD_INT 1
18004: PLUS
18005: ST_TO_ADDR
// if GetSide ( factory ) = your_side and GetNation ( factory ) = nation_russian then
18006: NOP4
18010: PPUSH
18011: NOP4
18015: PUSH
18016: NOP4
18020: EQUAL
18021: PUSH
18022: NOP4
18026: PPUSH
18027: NOP4
18031: PUSH
18032: LD_INT 3
18034: EQUAL
18035: AND
18036: IFFALSE 18052
// achievement_ConstructVehicles = achievement_ConstructVehicles + 1 ;
18038: NOP4
18042: PUSH
18043: NOP4
18047: PUSH
18048: LD_INT 1
18050: PLUS
18051: ST_TO_ADDR
// end ;
18052: PPOPN 2
18054: END
// on CrateSpawn ( unit , x , y , amount , mode ) do begin if not canExitBase and mode = true then
18055: NOP4
18059: NOT
18060: PUSH
18061: NOP4
18065: PUSH
18066: LD_INT 1
18068: EQUAL
18069: AND
18070: IFFALSE 18086
// Dial_NewCrates ( x , y ) ;
18072: NOP4
18076: PPUSH
18077: NOP4
18081: PPUSH
18082: NOP4
// end ;
18086: PPOPN 5
18088: END
// on Command ( com ) do var i , j , temp , order , destiny ;
18089: LD_INT 0
18091: PPUSH
18092: PPUSH
18093: PPUSH
18094: PPUSH
18095: PPUSH
// begin for i in FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) do
18096: NOP4
18100: PUSH
18101: LD_INT 22
18103: PUSH
18104: LD_INT 3
18106: PUSH
18107: EMPTY
18108: LIST
18109: LIST
18110: PUSH
18111: LD_INT 21
18113: PUSH
18114: LD_INT 1
18116: PUSH
18117: EMPTY
18118: LIST
18119: LIST
18120: PUSH
18121: EMPTY
18122: LIST
18123: LIST
18124: PPUSH
18125: NOP4
18129: PUSH
18130: FOR_IN
18131: IFFALSE 18324
// if GetTaskList ( i ) > 0 then
18133: NOP4
18137: PPUSH
18138: NOP4
18142: PUSH
18143: LD_INT 0
18145: GREATER
18146: IFFALSE 18322
// for j = 1 to GetTaskList ( i ) do
18148: NOP4
18152: PUSH
18153: DOUBLE
18154: LD_INT 1
18156: DEC
18157: ST_TO_ADDR
18158: NOP4
18162: PPUSH
18163: NOP4
18167: PUSH
18168: FOR_TO
18169: IFFALSE 18320
// begin temp = GetTaskList ( i ) [ j ] [ 4 ] ;
18171: NOP4
18175: PUSH
18176: NOP4
18180: PPUSH
18181: NOP4
18185: PUSH
18186: NOP4
18190: ARRAY
18191: PUSH
18192: LD_INT 4
18194: ARRAY
18195: ST_TO_ADDR
// if temp = kirov or ( GetSide ( temp ) = 6 and GetTaskList ( i ) [ j ] [ 1 ] = e and GetType ( temp ) = unit_vehicle ) then
18196: NOP4
18200: PUSH
18201: LD_INT 71
18203: EQUAL
18204: PUSH
18205: NOP4
18209: PPUSH
18210: NOP4
18214: PUSH
18215: LD_INT 6
18217: EQUAL
18218: PUSH
18219: NOP4
18223: PPUSH
18224: NOP4
18228: PUSH
18229: NOP4
18233: ARRAY
18234: PUSH
18235: LD_INT 1
18237: ARRAY
18238: PUSH
18239: LD_STRING e
18241: EQUAL
18242: AND
18243: PUSH
18244: NOP4
18248: PPUSH
18249: NOP4
18253: PUSH
18254: LD_INT 2
18256: EQUAL
18257: AND
18258: OR
18259: IFFALSE 18272
// SetTaskList ( i , [ ] ) ;
18261: NOP4
18265: PPUSH
18266: EMPTY
18267: PPUSH
18268: NOP4
// if temp = beria and GetTaskList ( i ) [ j ] [ 1 ] = Y then
18272: NOP4
18276: PUSH
18277: LD_INT 106
18279: EQUAL
18280: PUSH
18281: NOP4
18285: PPUSH
18286: NOP4
18290: PUSH
18291: NOP4
18295: ARRAY
18296: PUSH
18297: LD_INT 1
18299: ARRAY
18300: PUSH
18301: LD_STRING Y
18303: EQUAL
18304: AND
18305: IFFALSE 18318
// SetTaskList ( i , [ ] ) ;
18307: NOP4
18311: PPUSH
18312: EMPTY
18313: PPUSH
18314: NOP4
// end ;
18318: GO 18168
18320: POP
18321: POP
18322: GO 18130
18324: POP
18325: POP
// end ;
18326: PPOPN 6
18328: END
// on UnitDestroyed ( unit ) do begin if GetSide ( unit ) = 1 and GetType ( unit ) = unit_human then
18329: NOP4
18333: PPUSH
18334: NOP4
18338: PUSH
18339: LD_INT 1
18341: EQUAL
18342: PUSH
18343: NOP4
18347: PPUSH
18348: NOP4
18352: PUSH
18353: LD_INT 1
18355: EQUAL
18356: AND
18357: IFFALSE 18415
// begin if unit in amLeftEngs then
18359: NOP4
18363: PUSH
18364: NOP4
18368: IN
18369: IFFALSE 18387
// amLeftEngs = amLeftEngs diff unit ;
18371: NOP4
18375: PUSH
18376: NOP4
18380: PUSH
18381: NOP4
18385: DIFF
18386: ST_TO_ADDR
// if unit in amRightEngs then
18387: NOP4
18391: PUSH
18392: NOP4
18396: IN
18397: IFFALSE 18415
// amRightEngs = amRightEngs diff unit ;
18399: NOP4
18403: PUSH
18404: NOP4
18408: PUSH
18409: NOP4
18413: DIFF
18414: ST_TO_ADDR
// end ; if GetSide ( unit ) = 6 and GetType ( unit ) = unit_human then
18415: NOP4
18419: PPUSH
18420: NOP4
18424: PUSH
18425: LD_INT 6
18427: EQUAL
18428: PUSH
18429: NOP4
18433: PPUSH
18434: NOP4
18438: PUSH
18439: LD_INT 1
18441: EQUAL
18442: AND
18443: IFFALSE 18473
// if unit in belkovTeam then
18445: NOP4
18449: PUSH
18450: NOP4
18454: IN
18455: IFFALSE 18473
// belkovTeam = belkovTeam diff unit ;
18457: NOP4
18461: PUSH
18462: NOP4
18466: PUSH
18467: NOP4
18471: DIFF
18472: ST_TO_ADDR
// if GetSide ( unit ) = 3 and GetType ( unit ) = unit_human then
18473: NOP4
18477: PPUSH
18478: NOP4
18482: PUSH
18483: LD_INT 3
18485: EQUAL
18486: PUSH
18487: NOP4
18491: PPUSH
18492: NOP4
18496: PUSH
18497: LD_INT 1
18499: EQUAL
18500: AND
18501: IFFALSE 18517
// lostComradesCounter = lostComradesCounter + 1 ;
18503: NOP4
18507: PUSH
18508: NOP4
18512: PUSH
18513: LD_INT 1
18515: PLUS
18516: ST_TO_ADDR
// if unit = Burlak then
18517: NOP4
18521: PUSH
18522: NOP4
18526: EQUAL
18527: IFFALSE 18533
// BurlakIsDead ;
18529: NOP4
// if unit = Beria then
18533: NOP4
18537: PUSH
18538: LD_INT 106
18540: EQUAL
18541: IFFALSE 18547
// BaseDestroyed ;
18543: NOP4
// if unit in platSoldiers then
18547: NOP4
18551: PUSH
18552: NOP4
18556: IN
18557: IFFALSE 18575
// platSoldiers = platSoldiers diff unit ;
18559: NOP4
18563: PUSH
18564: NOP4
18568: PUSH
18569: NOP4
18573: DIFF
18574: ST_TO_ADDR
// end ;
18575: PPOPN 1
18577: END
// on UnitGoesToRed ( unit ) do begin if GetSide ( unit ) = 1 and GetType ( unit ) = unit_building then
18578: NOP4
18582: PPUSH
18583: NOP4
18587: PUSH
18588: LD_INT 1
18590: EQUAL
18591: PUSH
18592: NOP4
18596: PPUSH
18597: NOP4
18601: PUSH
18602: LD_INT 3
18604: EQUAL
18605: AND
18606: IFFALSE 18664
// begin if unit in leftBunkers then
18608: NOP4
18612: PUSH
18613: NOP4
18617: IN
18618: IFFALSE 18636
// leftBunkers = leftBunkers diff unit ;
18620: NOP4
18624: PUSH
18625: NOP4
18629: PUSH
18630: NOP4
18634: DIFF
18635: ST_TO_ADDR
// if unit in rightBunkers then
18636: NOP4
18640: PUSH
18641: NOP4
18645: IN
18646: IFFALSE 18664
// rightBunkers = rightBunkers diff unit ;
18648: NOP4
18652: PUSH
18653: NOP4
18657: PUSH
18658: NOP4
18662: DIFF
18663: ST_TO_ADDR
// end ; if GetSide ( unit ) = 1 and GetType ( unit ) = unit_human then
18664: NOP4
18668: PPUSH
18669: NOP4
18673: PUSH
18674: LD_INT 1
18676: EQUAL
18677: PUSH
18678: NOP4
18682: PPUSH
18683: NOP4
18687: PUSH
18688: LD_INT 1
18690: EQUAL
18691: AND
18692: IFFALSE 18722
// if unit in trapTeam then
18694: NOP4
18698: PUSH
18699: NOP4
18703: IN
18704: IFFALSE 18722
// trapTeam = trapTeam diff unit ;
18706: NOP4
18710: PUSH
18711: NOP4
18715: PUSH
18716: NOP4
18720: DIFF
18721: ST_TO_ADDR
// end ;
18722: PPOPN 1
18724: END
// on VehicleCaptured ( new_vehicle , old_vehicle , original_side , human ) do begin if original_side = 1 then
18725: NOP4
18729: PUSH
18730: LD_INT 1
18732: EQUAL
18733: IFFALSE 18743
// captureBelkovVehicle = true ;
18735: NOP4
18739: PUSH
18740: LD_INT 1
18742: ST_TO_ADDR
// if original_side = 6 then
18743: NOP4
18747: PUSH
18748: LD_INT 6
18750: EQUAL
18751: IFFALSE 18795
// begin ComMoveXY ( [ new_vehicle , old_vehicle ] , 118 , 25 ) ;
18753: NOP4
18757: PUSH
18758: NOP4
18762: PUSH
18763: EMPTY
18764: LIST
18765: LIST
18766: PPUSH
18767: LD_INT 118
18769: PPUSH
18770: LD_INT 25
18772: PPUSH
18773: NOP4
// ComFree ( [ new_vehicle , old_vehicle ] ) ;
18777: NOP4
18781: PUSH
18782: NOP4
18786: PUSH
18787: EMPTY
18788: LIST
18789: LIST
18790: PPUSH
18791: NOP4
// end ; end ;
18795: PPOPN 4
18797: END
// on Contact ( side1 , side2 ) do begin if side1 = 3 and side2 = 6 then
18798: NOP4
18802: PUSH
18803: LD_INT 3
18805: EQUAL
18806: PUSH
18807: NOP4
18811: PUSH
18812: LD_INT 6
18814: EQUAL
18815: AND
18816: IFFALSE 18822
// AttackComrades ;
18818: NOP4
// end ;
18822: PPOPN 2
18824: END
// on BuildingCaptured ( building , side , human ) do begin if side = 6 then
18825: NOP4
18829: PUSH
18830: LD_INT 6
18832: EQUAL
18833: IFFALSE 18847
// SetSide ( building , 3 ) ;
18835: NOP4
18839: PPUSH
18840: LD_INT 3
18842: PPUSH
18843: NOP4
// end ; end_of_file
18847: PPOPN 3
18849: END
// every 0 0$5 trigger backToBeria2 and FilterUnitsExceptArea ( BeriaBaseArea , [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) = 0 do
18850: NOP4
18854: PUSH
18855: LD_INT 8
18857: PPUSH
18858: LD_INT 22
18860: PUSH
18861: LD_INT 3
18863: PUSH
18864: EMPTY
18865: LIST
18866: LIST
18867: PUSH
18868: LD_INT 21
18870: PUSH
18871: LD_INT 1
18873: PUSH
18874: EMPTY
18875: LIST
18876: LIST
18877: PUSH
18878: EMPTY
18879: LIST
18880: LIST
18881: PPUSH
18882: NOP4
18886: PUSH
18887: LD_INT 0
18889: EQUAL
18890: AND
18891: IFFALSE 18992
18893: GO 18895
18895: DISABLE
// begin enable ;
18896: ENABLE
// if not saveBelkovObjective and ( IsOk ( Belkov ) or IsOk ( Belkov2 ) ) then
18897: NOP4
18901: NOT
18902: PUSH
18903: NOP4
18907: PPUSH
18908: NOP4
18912: PUSH
18913: NOP4
18917: PPUSH
18918: NOP4
18922: OR
18923: AND
18924: IFFALSE 18971
// begin case Query ( QContMission ) of 1 :
18926: LD_STRING QContMission
18928: PPUSH
18929: NOP4
18933: PUSH
18934: LD_INT 1
18936: DOUBLE
18937: EQUAL
18938: IFTRUE 18942
18940: GO 18949
18942: POP
// begin FinishMission ;
18943: NOP4
// end ; 2 :
18947: GO 18969
18949: LD_INT 2
18951: DOUBLE
18952: EQUAL
18953: IFTRUE 18957
18955: GO 18968
18957: POP
// begin saveBelkovObjective = true ;
18958: NOP4
18962: PUSH
18963: LD_INT 1
18965: ST_TO_ADDR
// end ; end ;
18966: GO 18969
18968: POP
// end else
18969: GO 18982
// if not belkovSaved then
18971: NOP4
18975: NOT
18976: IFFALSE 18982
// FinishMission ;
18978: NOP4
// if belkovSaved then
18982: NOP4
18986: IFFALSE 18992
// FinishMission ;
18988: NOP4
// end ;
18992: END
// function FinishMission ; begin
18993: LD_INT 0
18995: PPUSH
// SetRewards ;
18996: NOP4
// SavePlayerCharacters ;
19000: NOP4
// SaveGlobalVariables ;
19004: NOP4
// YouWin ;
19008: NOP4
// end ;
19012: LD_VAR 0 1
19016: RET
// function SetRewards ; begin
19017: LD_INT 0
19019: PPUSH
// case initiative of 1 :
19020: NOP4
19024: PUSH
19025: LD_INT 1
19027: DOUBLE
19028: EQUAL
19029: IFTRUE 19033
19031: GO 19046
19033: POP
// AddMedal ( Initiative , 1 ) ; 2 :
19034: LD_STRING Initiative
19036: PPUSH
19037: LD_INT 1
19039: PPUSH
19040: NOP4
19044: GO 19091
19046: LD_INT 2
19048: DOUBLE
19049: EQUAL
19050: IFTRUE 19054
19052: GO 19068
19054: POP
// AddMedal ( Initiative , - 2 ) ; 3 :
19055: LD_STRING Initiative
19057: PPUSH
19058: LD_INT 2
19060: NEG
19061: PPUSH
19062: NOP4
19066: GO 19091
19068: LD_INT 3
19070: DOUBLE
19071: EQUAL
19072: IFTRUE 19076
19074: GO 19090
19076: POP
// AddMedal ( Initiative , - 1 ) ; end ;
19077: LD_STRING Initiative
19079: PPUSH
19080: LD_INT 1
19082: NEG
19083: PPUSH
19084: NOP4
19088: GO 19091
19090: POP
// if belkovSaved and ( IsOK ( Belkov ) or IsOK ( Belkov2 ) ) then
19091: NOP4
19095: PUSH
19096: NOP4
19100: PPUSH
19101: NOP4
19105: PUSH
19106: NOP4
19110: PPUSH
19111: NOP4
19115: OR
19116: AND
19117: IFFALSE 19129
// AddMedal ( Belkov , 1 ) ;
19119: LD_STRING Belkov
19121: PPUSH
19122: LD_INT 1
19124: PPUSH
19125: NOP4
// if not belkovSaved and not saveBelkovObjective then
19129: NOP4
19133: NOT
19134: PUSH
19135: NOP4
19139: NOT
19140: AND
19141: IFFALSE 19154
// AddMedal ( Belkov , - 1 ) ;
19143: LD_STRING Belkov
19145: PPUSH
19146: LD_INT 1
19148: NEG
19149: PPUSH
19150: NOP4
// if not belkovSaved and saveBelkovObjective then
19154: NOP4
19158: NOT
19159: PUSH
19160: NOP4
19164: AND
19165: IFFALSE 19178
// AddMedal ( Belkov , - 2 ) ;
19167: LD_STRING Belkov
19169: PPUSH
19170: LD_INT 2
19172: NEG
19173: PPUSH
19174: NOP4
// if belkovSaved and ( belkovReturn and IsDead ( Belkov ) ) or ( not belkovReturn and IsDead ( Belkov2 ) ) then
19178: NOP4
19182: PUSH
19183: NOP4
19187: PUSH
19188: NOP4
19192: PPUSH
19193: NOP4
19197: AND
19198: AND
19199: PUSH
19200: NOP4
19204: NOT
19205: PUSH
19206: NOP4
19210: PPUSH
19211: NOP4
19215: AND
19216: OR
19217: IFFALSE 19230
// AddMedal ( Belkov , - 2 ) ;
19219: LD_STRING Belkov
19221: PPUSH
19222: LD_INT 2
19224: NEG
19225: PPUSH
19226: NOP4
// if lostComradesCounter = 0 then
19230: NOP4
19234: PUSH
19235: LD_INT 0
19237: EQUAL
19238: IFFALSE 19252
// AddMedal ( NoLosses , 1 ) else
19240: LD_STRING NoLosses
19242: PPUSH
19243: LD_INT 1
19245: PPUSH
19246: NOP4
19250: GO 19262
// AddMedal ( NoLosses , 0 ) ;
19252: LD_STRING NoLosses
19254: PPUSH
19255: LD_INT 0
19257: PPUSH
19258: NOP4
// GiveMedals ( Main ) ;
19262: LD_STRING Main
19264: PPUSH
19265: NOP4
// RewardPeople ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) ) ;
19269: LD_INT 22
19271: PUSH
19272: LD_INT 3
19274: PUSH
19275: EMPTY
19276: LIST
19277: LIST
19278: PUSH
19279: LD_INT 21
19281: PUSH
19282: LD_INT 1
19284: PUSH
19285: EMPTY
19286: LIST
19287: LIST
19288: PUSH
19289: EMPTY
19290: LIST
19291: LIST
19292: PPUSH
19293: NOP4
19297: PPUSH
19298: NOP4
// end ;
19302: LD_VAR 0 1
19306: RET
// function SavePlayerCharacters ; var othersYour ; begin
19307: LD_INT 0
19309: PPUSH
19310: PPUSH
// ExtSaveCharacter ( Burlak , Burlak , 3 ) ;
19311: NOP4
19315: PPUSH
19316: LD_STRING Burlak
19318: PPUSH
19319: LD_INT 3
19321: PPUSH
19322: NOP4
// ExtSaveCharacter ( Gnyevko , Gnyevko , 3 ) ;
19326: NOP4
19330: PPUSH
19331: LD_STRING Gnyevko
19333: PPUSH
19334: LD_INT 3
19336: PPUSH
19337: NOP4
// ExtSaveCharacter ( Kovalyuk , Kovalyuk , 3 ) ;
19341: NOP4
19345: PPUSH
19346: LD_STRING Kovalyuk
19348: PPUSH
19349: LD_INT 3
19351: PPUSH
19352: NOP4
// ExtSaveCharacter ( Belkov , Belkov , 3 ) ;
19356: NOP4
19360: PPUSH
19361: LD_STRING Belkov
19363: PPUSH
19364: LD_INT 3
19366: PPUSH
19367: NOP4
// ExtSaveCharacter ( Belkov2 , Belkov2 , 3 ) ;
19371: NOP4
19375: PPUSH
19376: LD_STRING Belkov2
19378: PPUSH
19379: LD_INT 3
19381: PPUSH
19382: NOP4
// ExtSaveCharacter ( Kirilenkova , Kirilenkova , 3 ) ;
19386: NOP4
19390: PPUSH
19391: LD_STRING Kirilenkova
19393: PPUSH
19394: LD_INT 3
19396: PPUSH
19397: NOP4
// othersYour = FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) diff [ Burlak , Gnyevko , Belkov , Belkov2 , Kovalyuk , Kirilenkova ] ;
19401: NOP4
19405: PUSH
19406: LD_INT 22
19408: PUSH
19409: LD_INT 3
19411: PUSH
19412: EMPTY
19413: LIST
19414: LIST
19415: PUSH
19416: LD_INT 21
19418: PUSH
19419: LD_INT 1
19421: PUSH
19422: EMPTY
19423: LIST
19424: LIST
19425: PUSH
19426: EMPTY
19427: LIST
19428: LIST
19429: PPUSH
19430: NOP4
19434: PUSH
19435: NOP4
19439: PUSH
19440: NOP4
19444: PUSH
19445: NOP4
19449: PUSH
19450: NOP4
19454: PUSH
19455: NOP4
19459: PUSH
19460: NOP4
19464: PUSH
19465: EMPTY
19466: LIST
19467: LIST
19468: LIST
19469: LIST
19470: LIST
19471: LIST
19472: DIFF
19473: ST_TO_ADDR
// ExtSaveCharacters ( othersYour , other_survivors , 3 ) ;
19474: NOP4
19478: PPUSH
19479: LD_STRING other_survivors
19481: PPUSH
19482: LD_INT 3
19484: PPUSH
19485: NOP4
// ExtSaveCharacters ( platSoldiers , other_beria , 6 ) ;
19489: NOP4
19493: PPUSH
19494: LD_STRING other_beria
19496: PPUSH
19497: LD_INT 6
19499: PPUSH
19500: NOP4
// ExtSaveCharacters ( otherKirovUnits , other_kirov , 6 ) ;
19504: NOP4
19508: PPUSH
19509: LD_STRING other_kirov
19511: PPUSH
19512: LD_INT 6
19514: PPUSH
19515: NOP4
// end ;
19519: LD_VAR 0 1
19523: RET
// function SaveGlobalVariables ; var vehicles ; begin
19524: LD_INT 0
19526: PPUSH
19527: PPUSH
// vehicles = FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_vehicle ] , [ f_ok ] ] ) ;
19528: NOP4
19532: PUSH
19533: LD_INT 22
19535: PUSH
19536: LD_INT 3
19538: PUSH
19539: EMPTY
19540: LIST
19541: LIST
19542: PUSH
19543: LD_INT 21
19545: PUSH
19546: LD_INT 2
19548: PUSH
19549: EMPTY
19550: LIST
19551: LIST
19552: PUSH
19553: LD_INT 50
19555: PUSH
19556: EMPTY
19557: LIST
19558: PUSH
19559: EMPTY
19560: LIST
19561: LIST
19562: LIST
19563: PPUSH
19564: NOP4
19568: ST_TO_ADDR
// if vehicles then
19569: NOP4
19573: IFFALSE 19587
// SaveVehicles ( vehicles , 02_Vehicles_1 ) ;
19575: NOP4
19579: PPUSH
19580: LD_STRING 02_Vehicles_1
19582: PPUSH
19583: NOP4
// SaveBase ( FilterUnitsInArea ( BeriaBaseArea , [ [ f_type , unit_building ] ] ) , 02_BeriaBase_2 ) ;
19587: LD_INT 8
19589: PPUSH
19590: LD_INT 21
19592: PUSH
19593: LD_INT 3
19595: PUSH
19596: EMPTY
19597: LIST
19598: LIST
19599: PUSH
19600: EMPTY
19601: LIST
19602: PPUSH
19603: NOP4
19607: PPUSH
19608: LD_STRING 02_BeriaBase_2
19610: PPUSH
19611: NOP4
// SaveBase ( FilterUnitsInArea ( KirovBaseArea , [ [ f_side , 6 ] , [ f_type , unit_building ] ] ) , 02_KirovBase_3 ) ;
19615: LD_INT 9
19617: PPUSH
19618: LD_INT 22
19620: PUSH
19621: LD_INT 6
19623: PUSH
19624: EMPTY
19625: LIST
19626: LIST
19627: PUSH
19628: LD_INT 21
19630: PUSH
19631: LD_INT 3
19633: PUSH
19634: EMPTY
19635: LIST
19636: LIST
19637: PUSH
19638: EMPTY
19639: LIST
19640: LIST
19641: PPUSH
19642: NOP4
19646: PPUSH
19647: LD_STRING 02_KirovBase_3
19649: PPUSH
19650: NOP4
// SaveBase ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_building ] , [ f_ok ] , [ f_not , [ f_inarea , BeriaBaseArea ] ] ] ) , 02_OtherBuildings_4 ) ;
19654: LD_INT 22
19656: PUSH
19657: LD_INT 3
19659: PUSH
19660: EMPTY
19661: LIST
19662: LIST
19663: PUSH
19664: LD_INT 21
19666: PUSH
19667: LD_INT 3
19669: PUSH
19670: EMPTY
19671: LIST
19672: LIST
19673: PUSH
19674: LD_INT 50
19676: PUSH
19677: EMPTY
19678: LIST
19679: PUSH
19680: LD_INT 3
19682: PUSH
19683: LD_INT 95
19685: PUSH
19686: LD_INT 8
19688: PUSH
19689: EMPTY
19690: LIST
19691: LIST
19692: PUSH
19693: EMPTY
19694: LIST
19695: LIST
19696: PUSH
19697: EMPTY
19698: LIST
19699: LIST
19700: LIST
19701: LIST
19702: PPUSH
19703: NOP4
19707: PPUSH
19708: LD_STRING 02_OtherBuildings_4
19710: PPUSH
19711: NOP4
// SaveBase ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_building ] , [ f_ok ] , [ f_nation , nation_american ] ] ) , 02_AmericanBuildings_5 ) ;
19715: LD_INT 22
19717: PUSH
19718: LD_INT 1
19720: PUSH
19721: EMPTY
19722: LIST
19723: LIST
19724: PUSH
19725: LD_INT 21
19727: PUSH
19728: LD_INT 3
19730: PUSH
19731: EMPTY
19732: LIST
19733: LIST
19734: PUSH
19735: LD_INT 50
19737: PUSH
19738: EMPTY
19739: LIST
19740: PUSH
19741: LD_INT 23
19743: PUSH
19744: LD_INT 1
19746: PUSH
19747: EMPTY
19748: LIST
19749: LIST
19750: PUSH
19751: EMPTY
19752: LIST
19753: LIST
19754: LIST
19755: LIST
19756: PPUSH
19757: NOP4
19761: PPUSH
19762: LD_STRING 02_AmericanBuildings_5
19764: PPUSH
19765: NOP4
// SaveVariable ( meetBelkovBrother , 02_MeetBelkovBrother_6 ) ;
19769: NOP4
19773: PPUSH
19774: LD_STRING 02_MeetBelkovBrother_6
19776: PPUSH
19777: NOP4
// SaveVariable ( GetResourceType ( GetBase ( beria ) , mat_cans ) , 02_BeriaResourceCrates_7 ) ;
19781: LD_INT 106
19783: PPUSH
19784: NOP4
19788: PPUSH
19789: LD_INT 1
19791: PPUSH
19792: NOP4
19796: PPUSH
19797: LD_STRING 02_BeriaResourceCrates_7
19799: PPUSH
19800: NOP4
// SaveVariable ( GetResourceType ( GetBase ( beria ) , mat_oil ) , 02_BeriaResourceOil_8 ) ;
19804: LD_INT 106
19806: PPUSH
19807: NOP4
19811: PPUSH
19812: LD_INT 2
19814: PPUSH
19815: NOP4
19819: PPUSH
19820: LD_STRING 02_BeriaResourceOil_8
19822: PPUSH
19823: NOP4
// SaveVariable ( platonovOpinion , 02_PlatonovOpinion_9 ) ;
19827: NOP4
19831: PPUSH
19832: LD_STRING 02_PlatonovOpinion_9
19834: PPUSH
19835: NOP4
// end ; end_of_file
19839: LD_VAR 0 1
19843: RET
// export function BurlakIsDead ; begin
19844: LD_INT 0
19846: PPUSH
// YouLost ( Burlak ) ;
19847: LD_STRING Burlak
19849: PPUSH
19850: NOP4
// end ;
19854: LD_VAR 0 1
19858: RET
// export function AttackComrades ; begin
19859: LD_INT 0
19861: PPUSH
// YouLost ( SelfAttack ) ;
19862: LD_STRING SelfAttack
19864: PPUSH
19865: NOP4
// end ;
19869: LD_VAR 0 1
19873: RET
// export function BaseDestroyed ; begin
19874: LD_INT 0
19876: PPUSH
// YouLost ( Base ) ;
19877: LD_STRING Base
19879: PPUSH
19880: NOP4
// end ; end_of_file
19884: LD_VAR 0 1
19888: RET
// every 0 0$1 do var engs ;
19889: GO 19891
19891: DISABLE
19892: LD_INT 0
19894: PPUSH
// begin engs = UnitFilter ( otherKirovUnits , [ f_class , class_engineer ] ) ;
19895: NOP4
19899: PUSH
19900: NOP4
19904: PPUSH
19905: LD_INT 25
19907: PUSH
19908: LD_INT 2
19910: PUSH
19911: EMPTY
19912: LIST
19913: LIST
19914: PPUSH
19915: NOP4
19919: ST_TO_ADDR
// ComExitBuilding ( engs ) ;
19920: NOP4
19924: PPUSH
19925: NOP4
// wait ( 0 0$1 ) ;
19929: LD_INT 35
19931: PPUSH
19932: NOP4
// AddComBuild ( engs , b_breastwork , 146 , 107 , 1 ) ;
19936: NOP4
19940: PPUSH
19941: LD_INT 31
19943: PPUSH
19944: LD_INT 146
19946: PPUSH
19947: LD_INT 107
19949: PPUSH
19950: LD_INT 1
19952: PPUSH
19953: NOP4
// AddComBuild ( engs , b_breastwork , 176 , 123 , 5 ) ;
19957: NOP4
19961: PPUSH
19962: LD_INT 31
19964: PPUSH
19965: LD_INT 176
19967: PPUSH
19968: LD_INT 123
19970: PPUSH
19971: LD_INT 5
19973: PPUSH
19974: NOP4
// AddComBuild ( engs , b_breastwork , 170 , 102 , 4 ) ;
19978: NOP4
19982: PPUSH
19983: LD_INT 31
19985: PPUSH
19986: LD_INT 170
19988: PPUSH
19989: LD_INT 102
19991: PPUSH
19992: LD_INT 4
19994: PPUSH
19995: NOP4
// AddComBuild ( engs , b_breastwork , 173 , 105 , 4 ) ;
19999: NOP4
20003: PPUSH
20004: LD_INT 31
20006: PPUSH
20007: LD_INT 173
20009: PPUSH
20010: LD_INT 105
20012: PPUSH
20013: LD_INT 4
20015: PPUSH
20016: NOP4
// AddComEnterUnit ( engs , kirov ) ;
20020: NOP4
20024: PPUSH
20025: LD_INT 71
20027: PPUSH
20028: NOP4
// end ;
20032: PPOPN 1
20034: END
// every 0 0$1 trigger activateAMAI do
20035: NOP4
20039: IFFALSE 20063
20041: GO 20043
20043: DISABLE
// begin enable ;
20044: ENABLE
// RepairDamageLeftBunkers ;
20045: NOP4
// if Difficulty = 3 then
20049: NOP4
20053: PUSH
20054: LD_INT 3
20056: EQUAL
20057: IFFALSE 20063
// RepairDamageRightBunkers ;
20059: NOP4
// end ;
20063: END
// function RepairDamageLeftBunkers ; var eng , bunker ; begin
20064: LD_INT 0
20066: PPUSH
20067: PPUSH
20068: PPUSH
// if not amLeftEngs or FilterUnitsInArea ( LeftHillArea , [ [ f_side , 1 ] , [ f_type , unit_building ] , [ f_btype , b_breastwork ] , [ f_not , [ f_lives , 1000 ] ] ] ) = 0 then
20069: NOP4
20073: NOT
20074: PUSH
20075: LD_INT 17
20077: PPUSH
20078: LD_INT 22
20080: PUSH
20081: LD_INT 1
20083: PUSH
20084: EMPTY
20085: LIST
20086: LIST
20087: PUSH
20088: LD_INT 21
20090: PUSH
20091: LD_INT 3
20093: PUSH
20094: EMPTY
20095: LIST
20096: LIST
20097: PUSH
20098: LD_INT 30
20100: PUSH
20101: LD_INT 31
20103: PUSH
20104: EMPTY
20105: LIST
20106: LIST
20107: PUSH
20108: LD_INT 3
20110: PUSH
20111: LD_INT 24
20113: PUSH
20114: LD_INT 1000
20116: PUSH
20117: EMPTY
20118: LIST
20119: LIST
20120: PUSH
20121: EMPTY
20122: LIST
20123: LIST
20124: PUSH
20125: EMPTY
20126: LIST
20127: LIST
20128: LIST
20129: LIST
20130: PPUSH
20131: NOP4
20135: PUSH
20136: LD_INT 0
20138: EQUAL
20139: OR
20140: IFFALSE 20144
// exit ;
20142: GO 20267
// ComExitBuilding ( UnitFilter ( amLeftEngs , [ f_not , [ f_hastask ] ] ) ) ;
20144: NOP4
20148: PPUSH
20149: LD_INT 3
20151: PUSH
20152: LD_INT 60
20154: PUSH
20155: EMPTY
20156: LIST
20157: PUSH
20158: EMPTY
20159: LIST
20160: LIST
20161: PPUSH
20162: NOP4
20166: PPUSH
20167: NOP4
// for bunker in leftBunkers do
20171: NOP4
20175: PUSH
20176: NOP4
20180: PUSH
20181: FOR_IN
20182: IFFALSE 20233
// if GetLives ( bunker ) < 1000 then
20184: NOP4
20188: PPUSH
20189: NOP4
20193: PUSH
20194: LD_INT 1000
20196: LESS
20197: IFFALSE 20231
// AddComRepairBuilding ( UnitFilter ( amLeftEngs , [ f_not , [ f_hastask ] ] ) , bunker ) ;
20199: NOP4
20203: PPUSH
20204: LD_INT 3
20206: PUSH
20207: LD_INT 60
20209: PUSH
20210: EMPTY
20211: LIST
20212: PUSH
20213: EMPTY
20214: LIST
20215: LIST
20216: PPUSH
20217: NOP4
20221: PPUSH
20222: NOP4
20226: PPUSH
20227: NOP4
20231: GO 20181
20233: POP
20234: POP
// AddComEnterUnit ( UnitFilter ( amLeftEngs , [ f_not , [ f_hastask ] ] ) , amLeftDepot ) ;
20235: NOP4
20239: PPUSH
20240: LD_INT 3
20242: PUSH
20243: LD_INT 60
20245: PUSH
20246: EMPTY
20247: LIST
20248: PUSH
20249: EMPTY
20250: LIST
20251: LIST
20252: PPUSH
20253: NOP4
20257: PPUSH
20258: NOP4
20262: PPUSH
20263: NOP4
// end ;
20267: LD_VAR 0 1
20271: RET
// function RepairDamageRightBunkers ; var eng , bunker ; begin
20272: LD_INT 0
20274: PPUSH
20275: PPUSH
20276: PPUSH
// if not amRightEngs or FilterUnitsInArea ( RightHillArea , [ [ f_side , 1 ] , [ f_type , unit_building ] , [ f_btype , b_breastwork ] , [ f_not , [ f_lives , 1000 ] ] ] ) = 0 then
20277: NOP4
20281: NOT
20282: PUSH
20283: LD_INT 16
20285: PPUSH
20286: LD_INT 22
20288: PUSH
20289: LD_INT 1
20291: PUSH
20292: EMPTY
20293: LIST
20294: LIST
20295: PUSH
20296: LD_INT 21
20298: PUSH
20299: LD_INT 3
20301: PUSH
20302: EMPTY
20303: LIST
20304: LIST
20305: PUSH
20306: LD_INT 30
20308: PUSH
20309: LD_INT 31
20311: PUSH
20312: EMPTY
20313: LIST
20314: LIST
20315: PUSH
20316: LD_INT 3
20318: PUSH
20319: LD_INT 24
20321: PUSH
20322: LD_INT 1000
20324: PUSH
20325: EMPTY
20326: LIST
20327: LIST
20328: PUSH
20329: EMPTY
20330: LIST
20331: LIST
20332: PUSH
20333: EMPTY
20334: LIST
20335: LIST
20336: LIST
20337: LIST
20338: PPUSH
20339: NOP4
20343: PUSH
20344: LD_INT 0
20346: EQUAL
20347: OR
20348: IFFALSE 20352
// exit ;
20350: GO 20475
// ComExitBuilding ( UnitFilter ( amRightEngs , [ f_not , [ f_hastask ] ] ) ) ;
20352: NOP4
20356: PPUSH
20357: LD_INT 3
20359: PUSH
20360: LD_INT 60
20362: PUSH
20363: EMPTY
20364: LIST
20365: PUSH
20366: EMPTY
20367: LIST
20368: LIST
20369: PPUSH
20370: NOP4
20374: PPUSH
20375: NOP4
// for bunker in rightBunkers do
20379: NOP4
20383: PUSH
20384: NOP4
20388: PUSH
20389: FOR_IN
20390: IFFALSE 20441
// if GetLives ( bunker ) < 1000 then
20392: NOP4
20396: PPUSH
20397: NOP4
20401: PUSH
20402: LD_INT 1000
20404: LESS
20405: IFFALSE 20439
// AddComRepairBuilding ( UnitFilter ( amRightEngs , [ f_not , [ f_hastask ] ] ) , bunker ) ;
20407: NOP4
20411: PPUSH
20412: LD_INT 3
20414: PUSH
20415: LD_INT 60
20417: PUSH
20418: EMPTY
20419: LIST
20420: PUSH
20421: EMPTY
20422: LIST
20423: LIST
20424: PPUSH
20425: NOP4
20429: PPUSH
20430: NOP4
20434: PPUSH
20435: NOP4
20439: GO 20389
20441: POP
20442: POP
// AddComEnterUnit ( UnitFilter ( amRightEngs , [ f_not , [ f_hastask ] ] ) , amRightDepot ) ;
20443: NOP4
20447: PPUSH
20448: LD_INT 3
20450: PUSH
20451: LD_INT 60
20453: PUSH
20454: EMPTY
20455: LIST
20456: PUSH
20457: EMPTY
20458: LIST
20459: LIST
20460: PPUSH
20461: NOP4
20465: PPUSH
20466: NOP4
20470: PPUSH
20471: NOP4
// end ;
20475: LD_VAR 0 1
20479: RET
// every 0 0$1 trigger activateBelkovAI and belkovTeam do var unit , med , damaged ;
20480: NOP4
20484: PUSH
20485: NOP4
20489: AND
20490: IFFALSE 20627
20492: GO 20494
20494: DISABLE
20495: LD_INT 0
20497: PPUSH
20498: PPUSH
20499: PPUSH
// begin enable ;
20500: ENABLE
// med = UnitFilter ( belkovTeam , [ f_class , class_scientistic ] ) ;
20501: NOP4
20505: PUSH
20506: NOP4
20510: PPUSH
20511: LD_INT 25
20513: PUSH
20514: LD_INT 4
20516: PUSH
20517: EMPTY
20518: LIST
20519: LIST
20520: PPUSH
20521: NOP4
20525: ST_TO_ADDR
// damaged = UnitFilter ( belkovTeam , [ f_not , [ f_lives , 650 ] ] ) ;
20526: NOP4
20530: PUSH
20531: NOP4
20535: PPUSH
20536: LD_INT 3
20538: PUSH
20539: LD_INT 24
20541: PUSH
20542: LD_INT 650
20544: PUSH
20545: EMPTY
20546: LIST
20547: LIST
20548: PUSH
20549: EMPTY
20550: LIST
20551: LIST
20552: PPUSH
20553: NOP4
20557: ST_TO_ADDR
// if not damaged and med then
20558: NOP4
20562: NOT
20563: PUSH
20564: NOP4
20568: AND
20569: IFFALSE 20588
// ComMoveXY ( med , 83 , 17 ) else
20571: NOP4
20575: PPUSH
20576: LD_INT 83
20578: PPUSH
20579: LD_INT 17
20581: PPUSH
20582: NOP4
20586: GO 20627
// if med then
20588: NOP4
20592: IFFALSE 20627
// begin ComMoveXY ( damaged , 83 , 17 ) ;
20594: NOP4
20598: PPUSH
20599: LD_INT 83
20601: PPUSH
20602: LD_INT 17
20604: PPUSH
20605: NOP4
// ComHeal ( med , damaged [ 1 ] ) ;
20609: NOP4
20613: PPUSH
20614: NOP4
20618: PUSH
20619: LD_INT 1
20621: ARRAY
20622: PPUSH
20623: NOP4
// end ; end ; end_of_file
20627: PPOPN 3
20629: END
// every 1 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_nation , nation_american ] , [ f_btype , b_depot ] ] ) = 2 do
20630: LD_INT 22
20632: PUSH
20633: LD_INT 3
20635: PUSH
20636: EMPTY
20637: LIST
20638: LIST
20639: PUSH
20640: LD_INT 23
20642: PUSH
20643: LD_INT 1
20645: PUSH
20646: EMPTY
20647: LIST
20648: LIST
20649: PUSH
20650: LD_INT 30
20652: PUSH
20653: LD_INT 0
20655: PUSH
20656: EMPTY
20657: LIST
20658: LIST
20659: PUSH
20660: EMPTY
20661: LIST
20662: LIST
20663: LIST
20664: PPUSH
20665: NOP4
20669: PUSH
20670: LD_INT 2
20672: EQUAL
20673: IFFALSE 20685
20675: GO 20677
20677: DISABLE
// SetAchievement ( ACH_DEPOT ) ;
20678: LD_STRING ACH_DEPOT
20680: PPUSH
20681: NOP4
20685: END
// every 1 trigger achievement_ConstructVehicles = 5 do
20686: NOP4
20690: PUSH
20691: LD_INT 5
20693: EQUAL
20694: IFFALSE 20706
20696: GO 20698
20698: DISABLE
// SetAchievement ( ACH_WORKSHOP ) ;
20699: LD_STRING ACH_WORKSHOP
20701: PPUSH
20702: NOP4
20706: END
// every 1 trigger captureBelkovVehicle do
20707: NOP4
20711: IFFALSE 20723
20713: GO 20715
20715: DISABLE
// SetAchievement ( ACH_RETAKE ) ; end_of_file
20716: LD_STRING ACH_RETAKE
20718: PPUSH
20719: NOP4
20723: END
// on TargetableSAIL ( cmd , unit , selectedUnit , x , y ) do begin SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ;
20724: NOP4
20728: PPUSH
20729: NOP4
20733: PPUSH
20734: NOP4
20738: PPUSH
20739: NOP4
20743: PPUSH
20744: NOP4
20748: PPUSH
20749: NOP4
// end ;
20753: PPOPN 5
20755: END
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin if p2 = 100 then
20756: NOP4
20760: PUSH
20761: LD_INT 100
20763: EQUAL
20764: IFFALSE 21713
// begin if not StreamModeActive then
20766: NOP4
20770: NOT
20771: IFFALSE 20781
// StreamModeActive := true ;
20773: NOP4
20777: PUSH
20778: LD_INT 1
20780: ST_TO_ADDR
// if p3 = 0 then
20781: NOP4
20785: PUSH
20786: LD_INT 0
20788: EQUAL
20789: IFFALSE 20795
// InitStreamMode ;
20791: NOP4
// if p3 = 1 then
20795: NOP4
20799: PUSH
20800: LD_INT 1
20802: EQUAL
20803: IFFALSE 20813
// sRocket := true ;
20805: NOP4
20809: PUSH
20810: LD_INT 1
20812: ST_TO_ADDR
// if p3 = 2 then
20813: NOP4
20817: PUSH
20818: LD_INT 2
20820: EQUAL
20821: IFFALSE 20831
// sSpeed := true ;
20823: NOP4
20827: PUSH
20828: LD_INT 1
20830: ST_TO_ADDR
// if p3 = 3 then
20831: NOP4
20835: PUSH
20836: LD_INT 3
20838: EQUAL
20839: IFFALSE 20849
// sEngine := true ;
20841: NOP4
20845: PUSH
20846: LD_INT 1
20848: ST_TO_ADDR
// if p3 = 4 then
20849: NOP4
20853: PUSH
20854: LD_INT 4
20856: EQUAL
20857: IFFALSE 20867
// sSpec := true ;
20859: NOP4
20863: PUSH
20864: LD_INT 1
20866: ST_TO_ADDR
// if p3 = 5 then
20867: NOP4
20871: PUSH
20872: LD_INT 5
20874: EQUAL
20875: IFFALSE 20885
// sLevel := true ;
20877: NOP4
20881: PUSH
20882: LD_INT 1
20884: ST_TO_ADDR
// if p3 = 6 then
20885: NOP4
20889: PUSH
20890: LD_INT 6
20892: EQUAL
20893: IFFALSE 20903
// sArmoury := true ;
20895: NOP4
20899: PUSH
20900: LD_INT 1
20902: ST_TO_ADDR
// if p3 = 7 then
20903: NOP4
20907: PUSH
20908: LD_INT 7
20910: EQUAL
20911: IFFALSE 20921
// sRadar := true ;
20913: NOP4
20917: PUSH
20918: LD_INT 1
20920: ST_TO_ADDR
// if p3 = 8 then
20921: NOP4
20925: PUSH
20926: LD_INT 8
20928: EQUAL
20929: IFFALSE 20939
// sBunker := true ;
20931: NOP4
20935: PUSH
20936: LD_INT 1
20938: ST_TO_ADDR
// if p3 = 9 then
20939: NOP4
20943: PUSH
20944: LD_INT 9
20946: EQUAL
20947: IFFALSE 20957
// sHack := true ;
20949: NOP4
20953: PUSH
20954: LD_INT 1
20956: ST_TO_ADDR
// if p3 = 10 then
20957: NOP4
20961: PUSH
20962: LD_INT 10
20964: EQUAL
20965: IFFALSE 20975
// sFire := true ;
20967: NOP4
20971: PUSH
20972: LD_INT 1
20974: ST_TO_ADDR
// if p3 = 11 then
20975: NOP4
20979: PUSH
20980: LD_INT 11
20982: EQUAL
20983: IFFALSE 20993
// sRefresh := true ;
20985: NOP4
20989: PUSH
20990: LD_INT 1
20992: ST_TO_ADDR
// if p3 = 12 then
20993: NOP4
20997: PUSH
20998: LD_INT 12
21000: EQUAL
21001: IFFALSE 21011
// sExp := true ;
21003: NOP4
21007: PUSH
21008: LD_INT 1
21010: ST_TO_ADDR
// if p3 = 13 then
21011: NOP4
21015: PUSH
21016: LD_INT 13
21018: EQUAL
21019: IFFALSE 21029
// sDepot := true ;
21021: NOP4
21025: PUSH
21026: LD_INT 1
21028: ST_TO_ADDR
// if p3 = 14 then
21029: NOP4
21033: PUSH
21034: LD_INT 14
21036: EQUAL
21037: IFFALSE 21047
// sFlag := true ;
21039: NOP4
21043: PUSH
21044: LD_INT 1
21046: ST_TO_ADDR
// if p3 = 15 then
21047: NOP4
21051: PUSH
21052: LD_INT 15
21054: EQUAL
21055: IFFALSE 21065
// sKamikadze := true ;
21057: NOP4
21061: PUSH
21062: LD_INT 1
21064: ST_TO_ADDR
// if p3 = 16 then
21065: NOP4
21069: PUSH
21070: LD_INT 16
21072: EQUAL
21073: IFFALSE 21083
// sTroll := true ;
21075: NOP4
21079: PUSH
21080: LD_INT 1
21082: ST_TO_ADDR
// if p3 = 17 then
21083: NOP4
21087: PUSH
21088: LD_INT 17
21090: EQUAL
21091: IFFALSE 21101
// sSlow := true ;
21093: NOP4
21097: PUSH
21098: LD_INT 1
21100: ST_TO_ADDR
// if p3 = 18 then
21101: NOP4
21105: PUSH
21106: LD_INT 18
21108: EQUAL
21109: IFFALSE 21119
// sLack := true ;
21111: NOP4
21115: PUSH
21116: LD_INT 1
21118: ST_TO_ADDR
// if p3 = 19 then
21119: NOP4
21123: PUSH
21124: LD_INT 19
21126: EQUAL
21127: IFFALSE 21137
// sTank := true ;
21129: NOP4
21133: PUSH
21134: LD_INT 1
21136: ST_TO_ADDR
// if p3 = 20 then
21137: NOP4
21141: PUSH
21142: LD_INT 20
21144: EQUAL
21145: IFFALSE 21155
// sRemote := true ;
21147: NOP4
21151: PUSH
21152: LD_INT 1
21154: ST_TO_ADDR
// if p3 = 21 then
21155: NOP4
21159: PUSH
21160: LD_INT 21
21162: EQUAL
21163: IFFALSE 21173
// sPowell := true ;
21165: NOP4
21169: PUSH
21170: LD_INT 1
21172: ST_TO_ADDR
// if p3 = 22 then
21173: NOP4
21177: PUSH
21178: LD_INT 22
21180: EQUAL
21181: IFFALSE 21191
// sTeleport := true ;
21183: NOP4
21187: PUSH
21188: LD_INT 1
21190: ST_TO_ADDR
// if p3 = 23 then
21191: NOP4
21195: PUSH
21196: LD_INT 23
21198: EQUAL
21199: IFFALSE 21209
// sOilTower := true ;
21201: NOP4
21205: PUSH
21206: LD_INT 1
21208: ST_TO_ADDR
// if p3 = 24 then
21209: NOP4
21213: PUSH
21214: LD_INT 24
21216: EQUAL
21217: IFFALSE 21227
// sShovel := true ;
21219: NOP4
21223: PUSH
21224: LD_INT 1
21226: ST_TO_ADDR
// if p3 = 25 then
21227: NOP4
21231: PUSH
21232: LD_INT 25
21234: EQUAL
21235: IFFALSE 21245
// sSheik := true ;
21237: NOP4
21241: PUSH
21242: LD_INT 1
21244: ST_TO_ADDR
// if p3 = 26 then
21245: NOP4
21249: PUSH
21250: LD_INT 26
21252: EQUAL
21253: IFFALSE 21263
// sEarthquake := true ;
21255: NOP4
21259: PUSH
21260: LD_INT 1
21262: ST_TO_ADDR
// if p3 = 27 then
21263: NOP4
21267: PUSH
21268: LD_INT 27
21270: EQUAL
21271: IFFALSE 21281
// sAI := true ;
21273: NOP4
21277: PUSH
21278: LD_INT 1
21280: ST_TO_ADDR
// if p3 = 28 then
21281: NOP4
21285: PUSH
21286: LD_INT 28
21288: EQUAL
21289: IFFALSE 21299
// sCargo := true ;
21291: NOP4
21295: PUSH
21296: LD_INT 1
21298: ST_TO_ADDR
// if p3 = 29 then
21299: NOP4
21303: PUSH
21304: LD_INT 29
21306: EQUAL
21307: IFFALSE 21317
// sDLaser := true ;
21309: NOP4
21313: PUSH
21314: LD_INT 1
21316: ST_TO_ADDR
// if p3 = 30 then
21317: NOP4
21321: PUSH
21322: LD_INT 30
21324: EQUAL
21325: IFFALSE 21335
// sExchange := true ;
21327: NOP4
21331: PUSH
21332: LD_INT 1
21334: ST_TO_ADDR
// if p3 = 31 then
21335: NOP4
21339: PUSH
21340: LD_INT 31
21342: EQUAL
21343: IFFALSE 21353
// sFac := true ;
21345: NOP4
21349: PUSH
21350: LD_INT 1
21352: ST_TO_ADDR
// if p3 = 32 then
21353: NOP4
21357: PUSH
21358: LD_INT 32
21360: EQUAL
21361: IFFALSE 21371
// sPower := true ;
21363: NOP4
21367: PUSH
21368: LD_INT 1
21370: ST_TO_ADDR
// if p3 = 33 then
21371: NOP4
21375: PUSH
21376: LD_INT 33
21378: EQUAL
21379: IFFALSE 21389
// sRandom := true ;
21381: NOP4
21385: PUSH
21386: LD_INT 1
21388: ST_TO_ADDR
// if p3 = 34 then
21389: NOP4
21393: PUSH
21394: LD_INT 34
21396: EQUAL
21397: IFFALSE 21407
// sShield := true ;
21399: NOP4
21403: PUSH
21404: LD_INT 1
21406: ST_TO_ADDR
// if p3 = 35 then
21407: NOP4
21411: PUSH
21412: LD_INT 35
21414: EQUAL
21415: IFFALSE 21425
// sTime := true ;
21417: NOP4
21421: PUSH
21422: LD_INT 1
21424: ST_TO_ADDR
// if p3 = 36 then
21425: NOP4
21429: PUSH
21430: LD_INT 36
21432: EQUAL
21433: IFFALSE 21443
// sTools := true ;
21435: NOP4
21439: PUSH
21440: LD_INT 1
21442: ST_TO_ADDR
// if p3 = 101 then
21443: NOP4
21447: PUSH
21448: LD_INT 101
21450: EQUAL
21451: IFFALSE 21461
// sSold := true ;
21453: NOP4
21457: PUSH
21458: LD_INT 1
21460: ST_TO_ADDR
// if p3 = 102 then
21461: NOP4
21465: PUSH
21466: LD_INT 102
21468: EQUAL
21469: IFFALSE 21479
// sDiff := true ;
21471: NOP4
21475: PUSH
21476: LD_INT 1
21478: ST_TO_ADDR
// if p3 = 103 then
21479: NOP4
21483: PUSH
21484: LD_INT 103
21486: EQUAL
21487: IFFALSE 21497
// sFog := true ;
21489: NOP4
21493: PUSH
21494: LD_INT 1
21496: ST_TO_ADDR
// if p3 = 104 then
21497: NOP4
21501: PUSH
21502: LD_INT 104
21504: EQUAL
21505: IFFALSE 21515
// sReset := true ;
21507: NOP4
21511: PUSH
21512: LD_INT 1
21514: ST_TO_ADDR
// if p3 = 105 then
21515: NOP4
21519: PUSH
21520: LD_INT 105
21522: EQUAL
21523: IFFALSE 21533
// sSun := true ;
21525: NOP4
21529: PUSH
21530: LD_INT 1
21532: ST_TO_ADDR
// if p3 = 106 then
21533: NOP4
21537: PUSH
21538: LD_INT 106
21540: EQUAL
21541: IFFALSE 21551
// sTiger := true ;
21543: NOP4
21547: PUSH
21548: LD_INT 1
21550: ST_TO_ADDR
// if p3 = 107 then
21551: NOP4
21555: PUSH
21556: LD_INT 107
21558: EQUAL
21559: IFFALSE 21569
// sBomb := true ;
21561: NOP4
21565: PUSH
21566: LD_INT 1
21568: ST_TO_ADDR
// if p3 = 108 then
21569: NOP4
21573: PUSH
21574: LD_INT 108
21576: EQUAL
21577: IFFALSE 21587
// sWound := true ;
21579: NOP4
21583: PUSH
21584: LD_INT 1
21586: ST_TO_ADDR
// if p3 = 109 then
21587: NOP4
21591: PUSH
21592: LD_INT 109
21594: EQUAL
21595: IFFALSE 21605
// sBetray := true ;
21597: NOP4
21601: PUSH
21602: LD_INT 1
21604: ST_TO_ADDR
// if p3 = 110 then
21605: NOP4
21609: PUSH
21610: LD_INT 110
21612: EQUAL
21613: IFFALSE 21623
// sContamin := true ;
21615: NOP4
21619: PUSH
21620: LD_INT 1
21622: ST_TO_ADDR
// if p3 = 111 then
21623: NOP4
21627: PUSH
21628: LD_INT 111
21630: EQUAL
21631: IFFALSE 21641
// sOil := true ;
21633: NOP4
21637: PUSH
21638: LD_INT 1
21640: ST_TO_ADDR
// if p3 = 112 then
21641: NOP4
21645: PUSH
21646: LD_INT 112
21648: EQUAL
21649: IFFALSE 21659
// sStu := true ;
21651: NOP4
21655: PUSH
21656: LD_INT 1
21658: ST_TO_ADDR
// if p3 = 113 then
21659: NOP4
21663: PUSH
21664: LD_INT 113
21666: EQUAL
21667: IFFALSE 21677
// sBazooka := true ;
21669: NOP4
21673: PUSH
21674: LD_INT 1
21676: ST_TO_ADDR
// if p3 = 114 then
21677: NOP4
21681: PUSH
21682: LD_INT 114
21684: EQUAL
21685: IFFALSE 21695
// sMortar := true ;
21687: NOP4
21691: PUSH
21692: LD_INT 1
21694: ST_TO_ADDR
// if p3 = 115 then
21695: NOP4
21699: PUSH
21700: LD_INT 115
21702: EQUAL
21703: IFFALSE 21713
// sRanger := true ;
21705: NOP4
21709: PUSH
21710: LD_INT 1
21712: ST_TO_ADDR
// end ; if p2 = 101 then
21713: NOP4
21717: PUSH
21718: LD_INT 101
21720: EQUAL
21721: IFFALSE 21924
// begin case p3 of 1 :
21723: NOP4
21727: PUSH
21728: LD_INT 1
21730: DOUBLE
21731: EQUAL
21732: IFTRUE 21736
21734: GO 21743
21736: POP
// hHackUnlimitedResources ; 2 :
21737: NOP4
21741: GO 21924
21743: LD_INT 2
21745: DOUBLE
21746: EQUAL
21747: IFTRUE 21751
21749: GO 21758
21751: POP
// hHackSetLevel10 ; 3 :
21752: NOP4
21756: GO 21924
21758: LD_INT 3
21760: DOUBLE
21761: EQUAL
21762: IFTRUE 21766
21764: GO 21773
21766: POP
// hHackSetLevel10YourUnits ; 4 :
21767: NOP4
21771: GO 21924
21773: LD_INT 4
21775: DOUBLE
21776: EQUAL
21777: IFTRUE 21781
21779: GO 21803
21781: POP
// hHackSpawnHuman ( p4 , p5 , p6 ) ; 5 :
21782: NOP4
21786: PPUSH
21787: NOP4
21791: PPUSH
21792: NOP4
21796: PPUSH
21797: NOP4
21801: GO 21924
21803: LD_INT 5
21805: DOUBLE
21806: EQUAL
21807: IFTRUE 21811
21809: GO 21818
21811: POP
// hHackSpawnVehicle ; 6 :
21812: NOP4
21816: GO 21924
21818: LD_INT 6
21820: DOUBLE
21821: EQUAL
21822: IFTRUE 21826
21824: GO 21833
21826: POP
// hHackInvincible ; 7 :
21827: NOP4
21831: GO 21924
21833: LD_INT 7
21835: DOUBLE
21836: EQUAL
21837: IFTRUE 21841
21839: GO 21848
21841: POP
// hHackInvisible ; 8 :
21842: NOP4
21846: GO 21924
21848: LD_INT 8
21850: DOUBLE
21851: EQUAL
21852: IFTRUE 21856
21854: GO 21863
21856: POP
// hHackChangeYourSide ; 9 :
21857: NOP4
21861: GO 21924
21863: LD_INT 9
21865: DOUBLE
21866: EQUAL
21867: IFTRUE 21871
21869: GO 21878
21871: POP
// hHackChangeUnitSide ; 10 :
21872: NOP4
21876: GO 21924
21878: LD_INT 10
21880: DOUBLE
21881: EQUAL
21882: IFTRUE 21886
21884: GO 21893
21886: POP
// hHackFog ; 11 :
21887: NOP4
21891: GO 21924
21893: LD_INT 11
21895: DOUBLE
21896: EQUAL
21897: IFTRUE 21901
21899: GO 21908
21901: POP
// hHackApeman ; 12 :
21902: NOP4
21906: GO 21924
21908: LD_INT 12
21910: DOUBLE
21911: EQUAL
21912: IFTRUE 21916
21914: GO 21923
21916: POP
// hHackBoom ; end ;
21917: NOP4
21921: GO 21924
21923: POP
// end ; end ;
21924: PPOPN 6
21926: END
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger ; every 0 0$1 do
21927: GO 21929
21929: DISABLE
// begin ToLua ( initStreamRollete(); ) ;
21930: LD_STRING initStreamRollete();
21932: PPUSH
21933: NOP4
// InitStreamMode ;
21937: NOP4
// DefineStreamItems ( ) ;
21941: NOP4
// end ;
21945: END
// function InitStreamMode ; begin
21946: LD_INT 0
21948: PPUSH
// streamModeActive := false ;
21949: NOP4
21953: PUSH
21954: LD_INT 0
21956: ST_TO_ADDR
// normalCounter := 36 ;
21957: NOP4
21961: PUSH
21962: LD_INT 36
21964: ST_TO_ADDR
// hardcoreCounter := 16 ;
21965: NOP4
21969: PUSH
21970: LD_INT 16
21972: ST_TO_ADDR
// sRocket := false ;
21973: NOP4
21977: PUSH
21978: LD_INT 0
21980: ST_TO_ADDR
// sSpeed := false ;
21981: NOP4
21985: PUSH
21986: LD_INT 0
21988: ST_TO_ADDR
// sEngine := false ;
21989: NOP4
21993: PUSH
21994: LD_INT 0
21996: ST_TO_ADDR
// sSpec := false ;
21997: NOP4
22001: PUSH
22002: LD_INT 0
22004: ST_TO_ADDR
// sLevel := false ;
22005: NOP4
22009: PUSH
22010: LD_INT 0
22012: ST_TO_ADDR
// sArmoury := false ;
22013: NOP4
22017: PUSH
22018: LD_INT 0
22020: ST_TO_ADDR
// sRadar := false ;
22021: NOP4
22025: PUSH
22026: LD_INT 0
22028: ST_TO_ADDR
// sBunker := false ;
22029: NOP4
22033: PUSH
22034: LD_INT 0
22036: ST_TO_ADDR
// sHack := false ;
22037: NOP4
22041: PUSH
22042: LD_INT 0
22044: ST_TO_ADDR
// sFire := false ;
22045: NOP4
22049: PUSH
22050: LD_INT 0
22052: ST_TO_ADDR
// sRefresh := false ;
22053: NOP4
22057: PUSH
22058: LD_INT 0
22060: ST_TO_ADDR
// sExp := false ;
22061: NOP4
22065: PUSH
22066: LD_INT 0
22068: ST_TO_ADDR
// sDepot := false ;
22069: NOP4
22073: PUSH
22074: LD_INT 0
22076: ST_TO_ADDR
// sFlag := false ;
22077: NOP4
22081: PUSH
22082: LD_INT 0
22084: ST_TO_ADDR
// sKamikadze := false ;
22085: NOP4
22089: PUSH
22090: LD_INT 0
22092: ST_TO_ADDR
// sTroll := false ;
22093: NOP4
22097: PUSH
22098: LD_INT 0
22100: ST_TO_ADDR
// sSlow := false ;
22101: NOP4
22105: PUSH
22106: LD_INT 0
22108: ST_TO_ADDR
// sLack := false ;
22109: NOP4
22113: PUSH
22114: LD_INT 0
22116: ST_TO_ADDR
// sTank := false ;
22117: NOP4
22121: PUSH
22122: LD_INT 0
22124: ST_TO_ADDR
// sRemote := false ;
22125: NOP4
22129: PUSH
22130: LD_INT 0
22132: ST_TO_ADDR
// sPowell := false ;
22133: NOP4
22137: PUSH
22138: LD_INT 0
22140: ST_TO_ADDR
// sTeleport := false ;
22141: NOP4
22145: PUSH
22146: LD_INT 0
22148: ST_TO_ADDR
// sOilTower := false ;
22149: NOP4
22153: PUSH
22154: LD_INT 0
22156: ST_TO_ADDR
// sShovel := false ;
22157: NOP4
22161: PUSH
22162: LD_INT 0
22164: ST_TO_ADDR
// sSheik := false ;
22165: NOP4
22169: PUSH
22170: LD_INT 0
22172: ST_TO_ADDR
// sEarthquake := false ;
22173: NOP4
22177: PUSH
22178: LD_INT 0
22180: ST_TO_ADDR
// sAI := false ;
22181: NOP4
22185: PUSH
22186: LD_INT 0
22188: ST_TO_ADDR
// sCargo := false ;
22189: NOP4
22193: PUSH
22194: LD_INT 0
22196: ST_TO_ADDR
// sDLaser := false ;
22197: NOP4
22201: PUSH
22202: LD_INT 0
22204: ST_TO_ADDR
// sExchange := false ;
22205: NOP4
22209: PUSH
22210: LD_INT 0
22212: ST_TO_ADDR
// sFac := false ;
22213: NOP4
22217: PUSH
22218: LD_INT 0
22220: ST_TO_ADDR
// sPower := false ;
22221: NOP4
22225: PUSH
22226: LD_INT 0
22228: ST_TO_ADDR
// sRandom := false ;
22229: NOP4
22233: PUSH
22234: LD_INT 0
22236: ST_TO_ADDR
// sShield := false ;
22237: NOP4
22241: PUSH
22242: LD_INT 0
22244: ST_TO_ADDR
// sTime := false ;
22245: NOP4
22249: PUSH
22250: LD_INT 0
22252: ST_TO_ADDR
// sTools := false ;
22253: NOP4
22257: PUSH
22258: LD_INT 0
22260: ST_TO_ADDR
// sSold := false ;
22261: NOP4
22265: PUSH
22266: LD_INT 0
22268: ST_TO_ADDR
// sDiff := false ;
22269: NOP4
22273: PUSH
22274: LD_INT 0
22276: ST_TO_ADDR
// sFog := false ;
22277: NOP4
22281: PUSH
22282: LD_INT 0
22284: ST_TO_ADDR
// sReset := false ;
22285: NOP4
22289: PUSH
22290: LD_INT 0
22292: ST_TO_ADDR
// sSun := false ;
22293: NOP4
22297: PUSH
22298: LD_INT 0
22300: ST_TO_ADDR
// sTiger := false ;
22301: NOP4
22305: PUSH
22306: LD_INT 0
22308: ST_TO_ADDR
// sBomb := false ;
22309: NOP4
22313: PUSH
22314: LD_INT 0
22316: ST_TO_ADDR
// sWound := false ;
22317: NOP4
22321: PUSH
22322: LD_INT 0
22324: ST_TO_ADDR
// sBetray := false ;
22325: NOP4
22329: PUSH
22330: LD_INT 0
22332: ST_TO_ADDR
// sContamin := false ;
22333: NOP4
22337: PUSH
22338: LD_INT 0
22340: ST_TO_ADDR
// sOil := false ;
22341: NOP4
22345: PUSH
22346: LD_INT 0
22348: ST_TO_ADDR
// sStu := false ;
22349: NOP4
22353: PUSH
22354: LD_INT 0
22356: ST_TO_ADDR
// sBazooka := false ;
22357: NOP4
22361: PUSH
22362: LD_INT 0
22364: ST_TO_ADDR
// sMortar := false ;
22365: NOP4
22369: PUSH
22370: LD_INT 0
22372: ST_TO_ADDR
// sRanger := false ;
22373: NOP4
22377: PUSH
22378: LD_INT 0
22380: ST_TO_ADDR
// end ;
22381: LD_VAR 0 1
22385: RET
// function DefineStreamItems ( ) ; var tmp , normal , hardcore , i ; begin
22386: LD_INT 0
22388: PPUSH
22389: PPUSH
22390: PPUSH
22391: PPUSH
22392: PPUSH
// result := [ ] ;
22393: NOP4
22397: PUSH
22398: EMPTY
22399: ST_TO_ADDR
// if campaign_id = 1 then
22400: NOP4
22404: PUSH
22405: LD_INT 1
22407: EQUAL
22408: IFFALSE 25346
// begin case mission_number of 1 :
22410: NOP4
22414: PUSH
22415: LD_INT 1
22417: DOUBLE
22418: EQUAL
22419: IFTRUE 22423
22421: GO 22487
22423: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 ] ] ; 2 :
22424: NOP4
22428: PUSH
22429: LD_INT 2
22431: PUSH
22432: LD_INT 4
22434: PUSH
22435: LD_INT 11
22437: PUSH
22438: LD_INT 12
22440: PUSH
22441: LD_INT 15
22443: PUSH
22444: LD_INT 16
22446: PUSH
22447: LD_INT 22
22449: PUSH
22450: LD_INT 23
22452: PUSH
22453: LD_INT 26
22455: PUSH
22456: EMPTY
22457: LIST
22458: LIST
22459: LIST
22460: LIST
22461: LIST
22462: LIST
22463: LIST
22464: LIST
22465: LIST
22466: PUSH
22467: LD_INT 101
22469: PUSH
22470: LD_INT 102
22472: PUSH
22473: LD_INT 106
22475: PUSH
22476: EMPTY
22477: LIST
22478: LIST
22479: LIST
22480: PUSH
22481: EMPTY
22482: LIST
22483: LIST
22484: ST_TO_ADDR
22485: GO 25344
22487: LD_INT 2
22489: DOUBLE
22490: EQUAL
22491: IFTRUE 22495
22493: GO 22567
22495: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 3 :
22496: NOP4
22500: PUSH
22501: LD_INT 2
22503: PUSH
22504: LD_INT 4
22506: PUSH
22507: LD_INT 11
22509: PUSH
22510: LD_INT 12
22512: PUSH
22513: LD_INT 15
22515: PUSH
22516: LD_INT 16
22518: PUSH
22519: LD_INT 22
22521: PUSH
22522: LD_INT 23
22524: PUSH
22525: LD_INT 26
22527: PUSH
22528: EMPTY
22529: LIST
22530: LIST
22531: LIST
22532: LIST
22533: LIST
22534: LIST
22535: LIST
22536: LIST
22537: LIST
22538: PUSH
22539: LD_INT 101
22541: PUSH
22542: LD_INT 102
22544: PUSH
22545: LD_INT 105
22547: PUSH
22548: LD_INT 106
22550: PUSH
22551: LD_INT 108
22553: PUSH
22554: EMPTY
22555: LIST
22556: LIST
22557: LIST
22558: LIST
22559: LIST
22560: PUSH
22561: EMPTY
22562: LIST
22563: LIST
22564: ST_TO_ADDR
22565: GO 25344
22567: LD_INT 3
22569: DOUBLE
22570: EQUAL
22571: IFTRUE 22575
22573: GO 22651
22575: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 4 :
22576: NOP4
22580: PUSH
22581: LD_INT 2
22583: PUSH
22584: LD_INT 4
22586: PUSH
22587: LD_INT 5
22589: PUSH
22590: LD_INT 11
22592: PUSH
22593: LD_INT 12
22595: PUSH
22596: LD_INT 15
22598: PUSH
22599: LD_INT 16
22601: PUSH
22602: LD_INT 22
22604: PUSH
22605: LD_INT 26
22607: PUSH
22608: LD_INT 36
22610: PUSH
22611: EMPTY
22612: LIST
22613: LIST
22614: LIST
22615: LIST
22616: LIST
22617: LIST
22618: LIST
22619: LIST
22620: LIST
22621: LIST
22622: PUSH
22623: LD_INT 101
22625: PUSH
22626: LD_INT 102
22628: PUSH
22629: LD_INT 105
22631: PUSH
22632: LD_INT 106
22634: PUSH
22635: LD_INT 108
22637: PUSH
22638: EMPTY
22639: LIST
22640: LIST
22641: LIST
22642: LIST
22643: LIST
22644: PUSH
22645: EMPTY
22646: LIST
22647: LIST
22648: ST_TO_ADDR
22649: GO 25344
22651: LD_INT 4
22653: DOUBLE
22654: EQUAL
22655: IFTRUE 22659
22657: GO 22743
22659: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 5 :
22660: NOP4
22664: PUSH
22665: LD_INT 2
22667: PUSH
22668: LD_INT 4
22670: PUSH
22671: LD_INT 5
22673: PUSH
22674: LD_INT 8
22676: PUSH
22677: LD_INT 11
22679: PUSH
22680: LD_INT 12
22682: PUSH
22683: LD_INT 15
22685: PUSH
22686: LD_INT 16
22688: PUSH
22689: LD_INT 22
22691: PUSH
22692: LD_INT 23
22694: PUSH
22695: LD_INT 26
22697: PUSH
22698: LD_INT 36
22700: PUSH
22701: EMPTY
22702: LIST
22703: LIST
22704: LIST
22705: LIST
22706: LIST
22707: LIST
22708: LIST
22709: LIST
22710: LIST
22711: LIST
22712: LIST
22713: LIST
22714: PUSH
22715: LD_INT 101
22717: PUSH
22718: LD_INT 102
22720: PUSH
22721: LD_INT 105
22723: PUSH
22724: LD_INT 106
22726: PUSH
22727: LD_INT 108
22729: PUSH
22730: EMPTY
22731: LIST
22732: LIST
22733: LIST
22734: LIST
22735: LIST
22736: PUSH
22737: EMPTY
22738: LIST
22739: LIST
22740: ST_TO_ADDR
22741: GO 25344
22743: LD_INT 5
22745: DOUBLE
22746: EQUAL
22747: IFTRUE 22751
22749: GO 22851
22751: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 6 :
22752: NOP4
22756: PUSH
22757: LD_INT 2
22759: PUSH
22760: LD_INT 4
22762: PUSH
22763: LD_INT 5
22765: PUSH
22766: LD_INT 6
22768: PUSH
22769: LD_INT 8
22771: PUSH
22772: LD_INT 11
22774: PUSH
22775: LD_INT 12
22777: PUSH
22778: LD_INT 15
22780: PUSH
22781: LD_INT 16
22783: PUSH
22784: LD_INT 22
22786: PUSH
22787: LD_INT 23
22789: PUSH
22790: LD_INT 25
22792: PUSH
22793: LD_INT 26
22795: PUSH
22796: LD_INT 36
22798: PUSH
22799: EMPTY
22800: LIST
22801: LIST
22802: LIST
22803: LIST
22804: LIST
22805: LIST
22806: LIST
22807: LIST
22808: LIST
22809: LIST
22810: LIST
22811: LIST
22812: LIST
22813: LIST
22814: PUSH
22815: LD_INT 101
22817: PUSH
22818: LD_INT 102
22820: PUSH
22821: LD_INT 105
22823: PUSH
22824: LD_INT 106
22826: PUSH
22827: LD_INT 108
22829: PUSH
22830: LD_INT 109
22832: PUSH
22833: LD_INT 112
22835: PUSH
22836: EMPTY
22837: LIST
22838: LIST
22839: LIST
22840: LIST
22841: LIST
22842: LIST
22843: LIST
22844: PUSH
22845: EMPTY
22846: LIST
22847: LIST
22848: ST_TO_ADDR
22849: GO 25344
22851: LD_INT 6
22853: DOUBLE
22854: EQUAL
22855: IFTRUE 22859
22857: GO 22979
22859: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 7 :
22860: NOP4
22864: PUSH
22865: LD_INT 2
22867: PUSH
22868: LD_INT 4
22870: PUSH
22871: LD_INT 5
22873: PUSH
22874: LD_INT 6
22876: PUSH
22877: LD_INT 8
22879: PUSH
22880: LD_INT 11
22882: PUSH
22883: LD_INT 12
22885: PUSH
22886: LD_INT 15
22888: PUSH
22889: LD_INT 16
22891: PUSH
22892: LD_INT 20
22894: PUSH
22895: LD_INT 21
22897: PUSH
22898: LD_INT 22
22900: PUSH
22901: LD_INT 23
22903: PUSH
22904: LD_INT 25
22906: PUSH
22907: LD_INT 26
22909: PUSH
22910: LD_INT 30
22912: PUSH
22913: LD_INT 31
22915: PUSH
22916: LD_INT 32
22918: PUSH
22919: LD_INT 36
22921: PUSH
22922: EMPTY
22923: LIST
22924: LIST
22925: LIST
22926: LIST
22927: LIST
22928: LIST
22929: LIST
22930: LIST
22931: LIST
22932: LIST
22933: LIST
22934: LIST
22935: LIST
22936: LIST
22937: LIST
22938: LIST
22939: LIST
22940: LIST
22941: LIST
22942: PUSH
22943: LD_INT 101
22945: PUSH
22946: LD_INT 102
22948: PUSH
22949: LD_INT 105
22951: PUSH
22952: LD_INT 106
22954: PUSH
22955: LD_INT 108
22957: PUSH
22958: LD_INT 109
22960: PUSH
22961: LD_INT 112
22963: PUSH
22964: EMPTY
22965: LIST
22966: LIST
22967: LIST
22968: LIST
22969: LIST
22970: LIST
22971: LIST
22972: PUSH
22973: EMPTY
22974: LIST
22975: LIST
22976: ST_TO_ADDR
22977: GO 25344
22979: LD_INT 7
22981: DOUBLE
22982: EQUAL
22983: IFTRUE 22987
22985: GO 23087
22987: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 ] ] ; 8 :
22988: NOP4
22992: PUSH
22993: LD_INT 2
22995: PUSH
22996: LD_INT 4
22998: PUSH
22999: LD_INT 5
23001: PUSH
23002: LD_INT 7
23004: PUSH
23005: LD_INT 11
23007: PUSH
23008: LD_INT 12
23010: PUSH
23011: LD_INT 15
23013: PUSH
23014: LD_INT 16
23016: PUSH
23017: LD_INT 20
23019: PUSH
23020: LD_INT 21
23022: PUSH
23023: LD_INT 22
23025: PUSH
23026: LD_INT 23
23028: PUSH
23029: LD_INT 25
23031: PUSH
23032: LD_INT 26
23034: PUSH
23035: EMPTY
23036: LIST
23037: LIST
23038: LIST
23039: LIST
23040: LIST
23041: LIST
23042: LIST
23043: LIST
23044: LIST
23045: LIST
23046: LIST
23047: LIST
23048: LIST
23049: LIST
23050: PUSH
23051: LD_INT 101
23053: PUSH
23054: LD_INT 102
23056: PUSH
23057: LD_INT 103
23059: PUSH
23060: LD_INT 105
23062: PUSH
23063: LD_INT 106
23065: PUSH
23066: LD_INT 108
23068: PUSH
23069: LD_INT 112
23071: PUSH
23072: EMPTY
23073: LIST
23074: LIST
23075: LIST
23076: LIST
23077: LIST
23078: LIST
23079: LIST
23080: PUSH
23081: EMPTY
23082: LIST
23083: LIST
23084: ST_TO_ADDR
23085: GO 25344
23087: LD_INT 8
23089: DOUBLE
23090: EQUAL
23091: IFTRUE 23095
23093: GO 23223
23095: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 ] ] ; 9 :
23096: NOP4
23100: PUSH
23101: LD_INT 2
23103: PUSH
23104: LD_INT 4
23106: PUSH
23107: LD_INT 5
23109: PUSH
23110: LD_INT 6
23112: PUSH
23113: LD_INT 7
23115: PUSH
23116: LD_INT 8
23118: PUSH
23119: LD_INT 11
23121: PUSH
23122: LD_INT 12
23124: PUSH
23125: LD_INT 15
23127: PUSH
23128: LD_INT 16
23130: PUSH
23131: LD_INT 20
23133: PUSH
23134: LD_INT 21
23136: PUSH
23137: LD_INT 22
23139: PUSH
23140: LD_INT 23
23142: PUSH
23143: LD_INT 25
23145: PUSH
23146: LD_INT 26
23148: PUSH
23149: LD_INT 30
23151: PUSH
23152: LD_INT 31
23154: PUSH
23155: LD_INT 32
23157: PUSH
23158: LD_INT 36
23160: PUSH
23161: EMPTY
23162: LIST
23163: LIST
23164: LIST
23165: LIST
23166: LIST
23167: LIST
23168: LIST
23169: LIST
23170: LIST
23171: LIST
23172: LIST
23173: LIST
23174: LIST
23175: LIST
23176: LIST
23177: LIST
23178: LIST
23179: LIST
23180: LIST
23181: LIST
23182: PUSH
23183: LD_INT 101
23185: PUSH
23186: LD_INT 102
23188: PUSH
23189: LD_INT 103
23191: PUSH
23192: LD_INT 105
23194: PUSH
23195: LD_INT 106
23197: PUSH
23198: LD_INT 108
23200: PUSH
23201: LD_INT 109
23203: PUSH
23204: LD_INT 112
23206: PUSH
23207: EMPTY
23208: LIST
23209: LIST
23210: LIST
23211: LIST
23212: LIST
23213: LIST
23214: LIST
23215: LIST
23216: PUSH
23217: EMPTY
23218: LIST
23219: LIST
23220: ST_TO_ADDR
23221: GO 25344
23223: LD_INT 9
23225: DOUBLE
23226: EQUAL
23227: IFTRUE 23231
23229: GO 23367
23231: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 ] ] ; 10 :
23232: NOP4
23236: PUSH
23237: LD_INT 2
23239: PUSH
23240: LD_INT 4
23242: PUSH
23243: LD_INT 5
23245: PUSH
23246: LD_INT 6
23248: PUSH
23249: LD_INT 7
23251: PUSH
23252: LD_INT 8
23254: PUSH
23255: LD_INT 11
23257: PUSH
23258: LD_INT 12
23260: PUSH
23261: LD_INT 15
23263: PUSH
23264: LD_INT 16
23266: PUSH
23267: LD_INT 20
23269: PUSH
23270: LD_INT 21
23272: PUSH
23273: LD_INT 22
23275: PUSH
23276: LD_INT 23
23278: PUSH
23279: LD_INT 25
23281: PUSH
23282: LD_INT 26
23284: PUSH
23285: LD_INT 28
23287: PUSH
23288: LD_INT 30
23290: PUSH
23291: LD_INT 31
23293: PUSH
23294: LD_INT 32
23296: PUSH
23297: LD_INT 36
23299: PUSH
23300: EMPTY
23301: LIST
23302: LIST
23303: LIST
23304: LIST
23305: LIST
23306: LIST
23307: LIST
23308: LIST
23309: LIST
23310: LIST
23311: LIST
23312: LIST
23313: LIST
23314: LIST
23315: LIST
23316: LIST
23317: LIST
23318: LIST
23319: LIST
23320: LIST
23321: LIST
23322: PUSH
23323: LD_INT 101
23325: PUSH
23326: LD_INT 102
23328: PUSH
23329: LD_INT 103
23331: PUSH
23332: LD_INT 105
23334: PUSH
23335: LD_INT 106
23337: PUSH
23338: LD_INT 108
23340: PUSH
23341: LD_INT 109
23343: PUSH
23344: LD_INT 112
23346: PUSH
23347: LD_INT 114
23349: PUSH
23350: EMPTY
23351: LIST
23352: LIST
23353: LIST
23354: LIST
23355: LIST
23356: LIST
23357: LIST
23358: LIST
23359: LIST
23360: PUSH
23361: EMPTY
23362: LIST
23363: LIST
23364: ST_TO_ADDR
23365: GO 25344
23367: LD_INT 10
23369: DOUBLE
23370: EQUAL
23371: IFTRUE 23375
23373: GO 23559
23375: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 11 :
23376: NOP4
23380: PUSH
23381: LD_INT 2
23383: PUSH
23384: LD_INT 4
23386: PUSH
23387: LD_INT 5
23389: PUSH
23390: LD_INT 6
23392: PUSH
23393: LD_INT 7
23395: PUSH
23396: LD_INT 8
23398: PUSH
23399: LD_INT 9
23401: PUSH
23402: LD_INT 10
23404: PUSH
23405: LD_INT 11
23407: PUSH
23408: LD_INT 12
23410: PUSH
23411: LD_INT 13
23413: PUSH
23414: LD_INT 14
23416: PUSH
23417: LD_INT 15
23419: PUSH
23420: LD_INT 16
23422: PUSH
23423: LD_INT 17
23425: PUSH
23426: LD_INT 18
23428: PUSH
23429: LD_INT 19
23431: PUSH
23432: LD_INT 20
23434: PUSH
23435: LD_INT 21
23437: PUSH
23438: LD_INT 22
23440: PUSH
23441: LD_INT 23
23443: PUSH
23444: LD_INT 24
23446: PUSH
23447: LD_INT 25
23449: PUSH
23450: LD_INT 26
23452: PUSH
23453: LD_INT 28
23455: PUSH
23456: LD_INT 30
23458: PUSH
23459: LD_INT 31
23461: PUSH
23462: LD_INT 32
23464: PUSH
23465: LD_INT 36
23467: PUSH
23468: EMPTY
23469: LIST
23470: LIST
23471: LIST
23472: LIST
23473: LIST
23474: LIST
23475: LIST
23476: LIST
23477: LIST
23478: LIST
23479: LIST
23480: LIST
23481: LIST
23482: LIST
23483: LIST
23484: LIST
23485: LIST
23486: LIST
23487: LIST
23488: LIST
23489: LIST
23490: LIST
23491: LIST
23492: LIST
23493: LIST
23494: LIST
23495: LIST
23496: LIST
23497: LIST
23498: PUSH
23499: LD_INT 101
23501: PUSH
23502: LD_INT 102
23504: PUSH
23505: LD_INT 103
23507: PUSH
23508: LD_INT 104
23510: PUSH
23511: LD_INT 105
23513: PUSH
23514: LD_INT 106
23516: PUSH
23517: LD_INT 107
23519: PUSH
23520: LD_INT 108
23522: PUSH
23523: LD_INT 109
23525: PUSH
23526: LD_INT 110
23528: PUSH
23529: LD_INT 111
23531: PUSH
23532: LD_INT 112
23534: PUSH
23535: LD_INT 114
23537: PUSH
23538: EMPTY
23539: LIST
23540: LIST
23541: LIST
23542: LIST
23543: LIST
23544: LIST
23545: LIST
23546: LIST
23547: LIST
23548: LIST
23549: LIST
23550: LIST
23551: LIST
23552: PUSH
23553: EMPTY
23554: LIST
23555: LIST
23556: ST_TO_ADDR
23557: GO 25344
23559: LD_INT 11
23561: DOUBLE
23562: EQUAL
23563: IFTRUE 23567
23565: GO 23759
23567: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 12 :
23568: NOP4
23572: PUSH
23573: LD_INT 2
23575: PUSH
23576: LD_INT 3
23578: PUSH
23579: LD_INT 4
23581: PUSH
23582: LD_INT 5
23584: PUSH
23585: LD_INT 6
23587: PUSH
23588: LD_INT 7
23590: PUSH
23591: LD_INT 8
23593: PUSH
23594: LD_INT 9
23596: PUSH
23597: LD_INT 10
23599: PUSH
23600: LD_INT 11
23602: PUSH
23603: LD_INT 12
23605: PUSH
23606: LD_INT 13
23608: PUSH
23609: LD_INT 14
23611: PUSH
23612: LD_INT 15
23614: PUSH
23615: LD_INT 16
23617: PUSH
23618: LD_INT 17
23620: PUSH
23621: LD_INT 18
23623: PUSH
23624: LD_INT 19
23626: PUSH
23627: LD_INT 20
23629: PUSH
23630: LD_INT 21
23632: PUSH
23633: LD_INT 22
23635: PUSH
23636: LD_INT 23
23638: PUSH
23639: LD_INT 24
23641: PUSH
23642: LD_INT 25
23644: PUSH
23645: LD_INT 26
23647: PUSH
23648: LD_INT 28
23650: PUSH
23651: LD_INT 30
23653: PUSH
23654: LD_INT 31
23656: PUSH
23657: LD_INT 32
23659: PUSH
23660: LD_INT 34
23662: PUSH
23663: LD_INT 36
23665: PUSH
23666: EMPTY
23667: LIST
23668: LIST
23669: LIST
23670: LIST
23671: LIST
23672: LIST
23673: LIST
23674: LIST
23675: LIST
23676: LIST
23677: LIST
23678: LIST
23679: LIST
23680: LIST
23681: LIST
23682: LIST
23683: LIST
23684: LIST
23685: LIST
23686: LIST
23687: LIST
23688: LIST
23689: LIST
23690: LIST
23691: LIST
23692: LIST
23693: LIST
23694: LIST
23695: LIST
23696: LIST
23697: LIST
23698: PUSH
23699: LD_INT 101
23701: PUSH
23702: LD_INT 102
23704: PUSH
23705: LD_INT 103
23707: PUSH
23708: LD_INT 104
23710: PUSH
23711: LD_INT 105
23713: PUSH
23714: LD_INT 106
23716: PUSH
23717: LD_INT 107
23719: PUSH
23720: LD_INT 108
23722: PUSH
23723: LD_INT 109
23725: PUSH
23726: LD_INT 110
23728: PUSH
23729: LD_INT 111
23731: PUSH
23732: LD_INT 112
23734: PUSH
23735: LD_INT 114
23737: PUSH
23738: EMPTY
23739: LIST
23740: LIST
23741: LIST
23742: LIST
23743: LIST
23744: LIST
23745: LIST
23746: LIST
23747: LIST
23748: LIST
23749: LIST
23750: LIST
23751: LIST
23752: PUSH
23753: EMPTY
23754: LIST
23755: LIST
23756: ST_TO_ADDR
23757: GO 25344
23759: LD_INT 12
23761: DOUBLE
23762: EQUAL
23763: IFTRUE 23767
23765: GO 23975
23767: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 13 :
23768: NOP4
23772: PUSH
23773: LD_INT 1
23775: PUSH
23776: LD_INT 2
23778: PUSH
23779: LD_INT 3
23781: PUSH
23782: LD_INT 4
23784: PUSH
23785: LD_INT 5
23787: PUSH
23788: LD_INT 6
23790: PUSH
23791: LD_INT 7
23793: PUSH
23794: LD_INT 8
23796: PUSH
23797: LD_INT 9
23799: PUSH
23800: LD_INT 10
23802: PUSH
23803: LD_INT 11
23805: PUSH
23806: LD_INT 12
23808: PUSH
23809: LD_INT 13
23811: PUSH
23812: LD_INT 14
23814: PUSH
23815: LD_INT 15
23817: PUSH
23818: LD_INT 16
23820: PUSH
23821: LD_INT 17
23823: PUSH
23824: LD_INT 18
23826: PUSH
23827: LD_INT 19
23829: PUSH
23830: LD_INT 20
23832: PUSH
23833: LD_INT 21
23835: PUSH
23836: LD_INT 22
23838: PUSH
23839: LD_INT 23
23841: PUSH
23842: LD_INT 24
23844: PUSH
23845: LD_INT 25
23847: PUSH
23848: LD_INT 26
23850: PUSH
23851: LD_INT 27
23853: PUSH
23854: LD_INT 28
23856: PUSH
23857: LD_INT 30
23859: PUSH
23860: LD_INT 31
23862: PUSH
23863: LD_INT 32
23865: PUSH
23866: LD_INT 33
23868: PUSH
23869: LD_INT 34
23871: PUSH
23872: LD_INT 36
23874: PUSH
23875: EMPTY
23876: LIST
23877: LIST
23878: LIST
23879: LIST
23880: LIST
23881: LIST
23882: LIST
23883: LIST
23884: LIST
23885: LIST
23886: LIST
23887: LIST
23888: LIST
23889: LIST
23890: LIST
23891: LIST
23892: LIST
23893: LIST
23894: LIST
23895: LIST
23896: LIST
23897: LIST
23898: LIST
23899: LIST
23900: LIST
23901: LIST
23902: LIST
23903: LIST
23904: LIST
23905: LIST
23906: LIST
23907: LIST
23908: LIST
23909: LIST
23910: PUSH
23911: LD_INT 101
23913: PUSH
23914: LD_INT 102
23916: PUSH
23917: LD_INT 103
23919: PUSH
23920: LD_INT 104
23922: PUSH
23923: LD_INT 105
23925: PUSH
23926: LD_INT 106
23928: PUSH
23929: LD_INT 107
23931: PUSH
23932: LD_INT 108
23934: PUSH
23935: LD_INT 109
23937: PUSH
23938: LD_INT 110
23940: PUSH
23941: LD_INT 111
23943: PUSH
23944: LD_INT 112
23946: PUSH
23947: LD_INT 113
23949: PUSH
23950: LD_INT 114
23952: PUSH
23953: EMPTY
23954: LIST
23955: LIST
23956: LIST
23957: LIST
23958: LIST
23959: LIST
23960: LIST
23961: LIST
23962: LIST
23963: LIST
23964: LIST
23965: LIST
23966: LIST
23967: LIST
23968: PUSH
23969: EMPTY
23970: LIST
23971: LIST
23972: ST_TO_ADDR
23973: GO 25344
23975: LD_INT 13
23977: DOUBLE
23978: EQUAL
23979: IFTRUE 23983
23981: GO 24179
23983: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 14 :
23984: NOP4
23988: PUSH
23989: LD_INT 1
23991: PUSH
23992: LD_INT 2
23994: PUSH
23995: LD_INT 3
23997: PUSH
23998: LD_INT 4
24000: PUSH
24001: LD_INT 5
24003: PUSH
24004: LD_INT 8
24006: PUSH
24007: LD_INT 9
24009: PUSH
24010: LD_INT 10
24012: PUSH
24013: LD_INT 11
24015: PUSH
24016: LD_INT 12
24018: PUSH
24019: LD_INT 14
24021: PUSH
24022: LD_INT 15
24024: PUSH
24025: LD_INT 16
24027: PUSH
24028: LD_INT 17
24030: PUSH
24031: LD_INT 18
24033: PUSH
24034: LD_INT 19
24036: PUSH
24037: LD_INT 20
24039: PUSH
24040: LD_INT 21
24042: PUSH
24043: LD_INT 22
24045: PUSH
24046: LD_INT 23
24048: PUSH
24049: LD_INT 24
24051: PUSH
24052: LD_INT 25
24054: PUSH
24055: LD_INT 26
24057: PUSH
24058: LD_INT 27
24060: PUSH
24061: LD_INT 28
24063: PUSH
24064: LD_INT 30
24066: PUSH
24067: LD_INT 31
24069: PUSH
24070: LD_INT 32
24072: PUSH
24073: LD_INT 33
24075: PUSH
24076: LD_INT 34
24078: PUSH
24079: LD_INT 36
24081: PUSH
24082: EMPTY
24083: LIST
24084: LIST
24085: LIST
24086: LIST
24087: LIST
24088: LIST
24089: LIST
24090: LIST
24091: LIST
24092: LIST
24093: LIST
24094: LIST
24095: LIST
24096: LIST
24097: LIST
24098: LIST
24099: LIST
24100: LIST
24101: LIST
24102: LIST
24103: LIST
24104: LIST
24105: LIST
24106: LIST
24107: LIST
24108: LIST
24109: LIST
24110: LIST
24111: LIST
24112: LIST
24113: LIST
24114: PUSH
24115: LD_INT 101
24117: PUSH
24118: LD_INT 102
24120: PUSH
24121: LD_INT 103
24123: PUSH
24124: LD_INT 104
24126: PUSH
24127: LD_INT 105
24129: PUSH
24130: LD_INT 106
24132: PUSH
24133: LD_INT 107
24135: PUSH
24136: LD_INT 108
24138: PUSH
24139: LD_INT 109
24141: PUSH
24142: LD_INT 110
24144: PUSH
24145: LD_INT 111
24147: PUSH
24148: LD_INT 112
24150: PUSH
24151: LD_INT 113
24153: PUSH
24154: LD_INT 114
24156: PUSH
24157: EMPTY
24158: LIST
24159: LIST
24160: LIST
24161: LIST
24162: LIST
24163: LIST
24164: LIST
24165: LIST
24166: LIST
24167: LIST
24168: LIST
24169: LIST
24170: LIST
24171: LIST
24172: PUSH
24173: EMPTY
24174: LIST
24175: LIST
24176: ST_TO_ADDR
24177: GO 25344
24179: LD_INT 14
24181: DOUBLE
24182: EQUAL
24183: IFTRUE 24187
24185: GO 24399
24187: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 15 :
24188: NOP4
24192: PUSH
24193: LD_INT 1
24195: PUSH
24196: LD_INT 2
24198: PUSH
24199: LD_INT 3
24201: PUSH
24202: LD_INT 4
24204: PUSH
24205: LD_INT 5
24207: PUSH
24208: LD_INT 6
24210: PUSH
24211: LD_INT 7
24213: PUSH
24214: LD_INT 8
24216: PUSH
24217: LD_INT 9
24219: PUSH
24220: LD_INT 10
24222: PUSH
24223: LD_INT 11
24225: PUSH
24226: LD_INT 12
24228: PUSH
24229: LD_INT 13
24231: PUSH
24232: LD_INT 14
24234: PUSH
24235: LD_INT 15
24237: PUSH
24238: LD_INT 16
24240: PUSH
24241: LD_INT 17
24243: PUSH
24244: LD_INT 18
24246: PUSH
24247: LD_INT 19
24249: PUSH
24250: LD_INT 20
24252: PUSH
24253: LD_INT 21
24255: PUSH
24256: LD_INT 22
24258: PUSH
24259: LD_INT 23
24261: PUSH
24262: LD_INT 24
24264: PUSH
24265: LD_INT 25
24267: PUSH
24268: LD_INT 26
24270: PUSH
24271: LD_INT 27
24273: PUSH
24274: LD_INT 28
24276: PUSH
24277: LD_INT 29
24279: PUSH
24280: LD_INT 30
24282: PUSH
24283: LD_INT 31
24285: PUSH
24286: LD_INT 32
24288: PUSH
24289: LD_INT 33
24291: PUSH
24292: LD_INT 34
24294: PUSH
24295: LD_INT 36
24297: PUSH
24298: EMPTY
24299: LIST
24300: LIST
24301: LIST
24302: LIST
24303: LIST
24304: LIST
24305: LIST
24306: LIST
24307: LIST
24308: LIST
24309: LIST
24310: LIST
24311: LIST
24312: LIST
24313: LIST
24314: LIST
24315: LIST
24316: LIST
24317: LIST
24318: LIST
24319: LIST
24320: LIST
24321: LIST
24322: LIST
24323: LIST
24324: LIST
24325: LIST
24326: LIST
24327: LIST
24328: LIST
24329: LIST
24330: LIST
24331: LIST
24332: LIST
24333: LIST
24334: PUSH
24335: LD_INT 101
24337: PUSH
24338: LD_INT 102
24340: PUSH
24341: LD_INT 103
24343: PUSH
24344: LD_INT 104
24346: PUSH
24347: LD_INT 105
24349: PUSH
24350: LD_INT 106
24352: PUSH
24353: LD_INT 107
24355: PUSH
24356: LD_INT 108
24358: PUSH
24359: LD_INT 109
24361: PUSH
24362: LD_INT 110
24364: PUSH
24365: LD_INT 111
24367: PUSH
24368: LD_INT 112
24370: PUSH
24371: LD_INT 113
24373: PUSH
24374: LD_INT 114
24376: PUSH
24377: EMPTY
24378: LIST
24379: LIST
24380: LIST
24381: LIST
24382: LIST
24383: LIST
24384: LIST
24385: LIST
24386: LIST
24387: LIST
24388: LIST
24389: LIST
24390: LIST
24391: LIST
24392: PUSH
24393: EMPTY
24394: LIST
24395: LIST
24396: ST_TO_ADDR
24397: GO 25344
24399: LD_INT 15
24401: DOUBLE
24402: EQUAL
24403: IFTRUE 24407
24405: GO 24619
24407: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 16 :
24408: NOP4
24412: PUSH
24413: LD_INT 1
24415: PUSH
24416: LD_INT 2
24418: PUSH
24419: LD_INT 3
24421: PUSH
24422: LD_INT 4
24424: PUSH
24425: LD_INT 5
24427: PUSH
24428: LD_INT 6
24430: PUSH
24431: LD_INT 7
24433: PUSH
24434: LD_INT 8
24436: PUSH
24437: LD_INT 9
24439: PUSH
24440: LD_INT 10
24442: PUSH
24443: LD_INT 11
24445: PUSH
24446: LD_INT 12
24448: PUSH
24449: LD_INT 13
24451: PUSH
24452: LD_INT 14
24454: PUSH
24455: LD_INT 15
24457: PUSH
24458: LD_INT 16
24460: PUSH
24461: LD_INT 17
24463: PUSH
24464: LD_INT 18
24466: PUSH
24467: LD_INT 19
24469: PUSH
24470: LD_INT 20
24472: PUSH
24473: LD_INT 21
24475: PUSH
24476: LD_INT 22
24478: PUSH
24479: LD_INT 23
24481: PUSH
24482: LD_INT 24
24484: PUSH
24485: LD_INT 25
24487: PUSH
24488: LD_INT 26
24490: PUSH
24491: LD_INT 27
24493: PUSH
24494: LD_INT 28
24496: PUSH
24497: LD_INT 29
24499: PUSH
24500: LD_INT 30
24502: PUSH
24503: LD_INT 31
24505: PUSH
24506: LD_INT 32
24508: PUSH
24509: LD_INT 33
24511: PUSH
24512: LD_INT 34
24514: PUSH
24515: LD_INT 36
24517: PUSH
24518: EMPTY
24519: LIST
24520: LIST
24521: LIST
24522: LIST
24523: LIST
24524: LIST
24525: LIST
24526: LIST
24527: LIST
24528: LIST
24529: LIST
24530: LIST
24531: LIST
24532: LIST
24533: LIST
24534: LIST
24535: LIST
24536: LIST
24537: LIST
24538: LIST
24539: LIST
24540: LIST
24541: LIST
24542: LIST
24543: LIST
24544: LIST
24545: LIST
24546: LIST
24547: LIST
24548: LIST
24549: LIST
24550: LIST
24551: LIST
24552: LIST
24553: LIST
24554: PUSH
24555: LD_INT 101
24557: PUSH
24558: LD_INT 102
24560: PUSH
24561: LD_INT 103
24563: PUSH
24564: LD_INT 104
24566: PUSH
24567: LD_INT 105
24569: PUSH
24570: LD_INT 106
24572: PUSH
24573: LD_INT 107
24575: PUSH
24576: LD_INT 108
24578: PUSH
24579: LD_INT 109
24581: PUSH
24582: LD_INT 110
24584: PUSH
24585: LD_INT 111
24587: PUSH
24588: LD_INT 112
24590: PUSH
24591: LD_INT 113
24593: PUSH
24594: LD_INT 114
24596: PUSH
24597: EMPTY
24598: LIST
24599: LIST
24600: LIST
24601: LIST
24602: LIST
24603: LIST
24604: LIST
24605: LIST
24606: LIST
24607: LIST
24608: LIST
24609: LIST
24610: LIST
24611: LIST
24612: PUSH
24613: EMPTY
24614: LIST
24615: LIST
24616: ST_TO_ADDR
24617: GO 25344
24619: LD_INT 16
24621: DOUBLE
24622: EQUAL
24623: IFTRUE 24627
24625: GO 24751
24627: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 ] ] ; 17 :
24628: NOP4
24632: PUSH
24633: LD_INT 2
24635: PUSH
24636: LD_INT 4
24638: PUSH
24639: LD_INT 5
24641: PUSH
24642: LD_INT 7
24644: PUSH
24645: LD_INT 11
24647: PUSH
24648: LD_INT 12
24650: PUSH
24651: LD_INT 15
24653: PUSH
24654: LD_INT 16
24656: PUSH
24657: LD_INT 20
24659: PUSH
24660: LD_INT 21
24662: PUSH
24663: LD_INT 22
24665: PUSH
24666: LD_INT 23
24668: PUSH
24669: LD_INT 25
24671: PUSH
24672: LD_INT 26
24674: PUSH
24675: LD_INT 30
24677: PUSH
24678: LD_INT 31
24680: PUSH
24681: LD_INT 32
24683: PUSH
24684: LD_INT 33
24686: PUSH
24687: LD_INT 34
24689: PUSH
24690: EMPTY
24691: LIST
24692: LIST
24693: LIST
24694: LIST
24695: LIST
24696: LIST
24697: LIST
24698: LIST
24699: LIST
24700: LIST
24701: LIST
24702: LIST
24703: LIST
24704: LIST
24705: LIST
24706: LIST
24707: LIST
24708: LIST
24709: LIST
24710: PUSH
24711: LD_INT 101
24713: PUSH
24714: LD_INT 102
24716: PUSH
24717: LD_INT 103
24719: PUSH
24720: LD_INT 106
24722: PUSH
24723: LD_INT 108
24725: PUSH
24726: LD_INT 112
24728: PUSH
24729: LD_INT 113
24731: PUSH
24732: LD_INT 114
24734: PUSH
24735: EMPTY
24736: LIST
24737: LIST
24738: LIST
24739: LIST
24740: LIST
24741: LIST
24742: LIST
24743: LIST
24744: PUSH
24745: EMPTY
24746: LIST
24747: LIST
24748: ST_TO_ADDR
24749: GO 25344
24751: LD_INT 17
24753: DOUBLE
24754: EQUAL
24755: IFTRUE 24759
24757: GO 24971
24759: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 18 :
24760: NOP4
24764: PUSH
24765: LD_INT 1
24767: PUSH
24768: LD_INT 2
24770: PUSH
24771: LD_INT 3
24773: PUSH
24774: LD_INT 4
24776: PUSH
24777: LD_INT 5
24779: PUSH
24780: LD_INT 6
24782: PUSH
24783: LD_INT 7
24785: PUSH
24786: LD_INT 8
24788: PUSH
24789: LD_INT 9
24791: PUSH
24792: LD_INT 10
24794: PUSH
24795: LD_INT 11
24797: PUSH
24798: LD_INT 12
24800: PUSH
24801: LD_INT 13
24803: PUSH
24804: LD_INT 14
24806: PUSH
24807: LD_INT 15
24809: PUSH
24810: LD_INT 16
24812: PUSH
24813: LD_INT 17
24815: PUSH
24816: LD_INT 18
24818: PUSH
24819: LD_INT 19
24821: PUSH
24822: LD_INT 20
24824: PUSH
24825: LD_INT 21
24827: PUSH
24828: LD_INT 22
24830: PUSH
24831: LD_INT 23
24833: PUSH
24834: LD_INT 24
24836: PUSH
24837: LD_INT 25
24839: PUSH
24840: LD_INT 26
24842: PUSH
24843: LD_INT 27
24845: PUSH
24846: LD_INT 28
24848: PUSH
24849: LD_INT 29
24851: PUSH
24852: LD_INT 30
24854: PUSH
24855: LD_INT 31
24857: PUSH
24858: LD_INT 32
24860: PUSH
24861: LD_INT 33
24863: PUSH
24864: LD_INT 34
24866: PUSH
24867: LD_INT 36
24869: PUSH
24870: EMPTY
24871: LIST
24872: LIST
24873: LIST
24874: LIST
24875: LIST
24876: LIST
24877: LIST
24878: LIST
24879: LIST
24880: LIST
24881: LIST
24882: LIST
24883: LIST
24884: LIST
24885: LIST
24886: LIST
24887: LIST
24888: LIST
24889: LIST
24890: LIST
24891: LIST
24892: LIST
24893: LIST
24894: LIST
24895: LIST
24896: LIST
24897: LIST
24898: LIST
24899: LIST
24900: LIST
24901: LIST
24902: LIST
24903: LIST
24904: LIST
24905: LIST
24906: PUSH
24907: LD_INT 101
24909: PUSH
24910: LD_INT 102
24912: PUSH
24913: LD_INT 103
24915: PUSH
24916: LD_INT 104
24918: PUSH
24919: LD_INT 105
24921: PUSH
24922: LD_INT 106
24924: PUSH
24925: LD_INT 107
24927: PUSH
24928: LD_INT 108
24930: PUSH
24931: LD_INT 109
24933: PUSH
24934: LD_INT 110
24936: PUSH
24937: LD_INT 111
24939: PUSH
24940: LD_INT 112
24942: PUSH
24943: LD_INT 113
24945: PUSH
24946: LD_INT 114
24948: PUSH
24949: EMPTY
24950: LIST
24951: LIST
24952: LIST
24953: LIST
24954: LIST
24955: LIST
24956: LIST
24957: LIST
24958: LIST
24959: LIST
24960: LIST
24961: LIST
24962: LIST
24963: LIST
24964: PUSH
24965: EMPTY
24966: LIST
24967: LIST
24968: ST_TO_ADDR
24969: GO 25344
24971: LD_INT 18
24973: DOUBLE
24974: EQUAL
24975: IFTRUE 24979
24977: GO 25115
24979: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 ] ] ; 19 :
24980: NOP4
24984: PUSH
24985: LD_INT 2
24987: PUSH
24988: LD_INT 4
24990: PUSH
24991: LD_INT 5
24993: PUSH
24994: LD_INT 7
24996: PUSH
24997: LD_INT 11
24999: PUSH
25000: LD_INT 12
25002: PUSH
25003: LD_INT 15
25005: PUSH
25006: LD_INT 16
25008: PUSH
25009: LD_INT 20
25011: PUSH
25012: LD_INT 21
25014: PUSH
25015: LD_INT 22
25017: PUSH
25018: LD_INT 23
25020: PUSH
25021: LD_INT 25
25023: PUSH
25024: LD_INT 26
25026: PUSH
25027: LD_INT 30
25029: PUSH
25030: LD_INT 31
25032: PUSH
25033: LD_INT 32
25035: PUSH
25036: LD_INT 33
25038: PUSH
25039: LD_INT 34
25041: PUSH
25042: LD_INT 35
25044: PUSH
25045: LD_INT 36
25047: PUSH
25048: EMPTY
25049: LIST
25050: LIST
25051: LIST
25052: LIST
25053: LIST
25054: LIST
25055: LIST
25056: LIST
25057: LIST
25058: LIST
25059: LIST
25060: LIST
25061: LIST
25062: LIST
25063: LIST
25064: LIST
25065: LIST
25066: LIST
25067: LIST
25068: LIST
25069: LIST
25070: PUSH
25071: LD_INT 101
25073: PUSH
25074: LD_INT 102
25076: PUSH
25077: LD_INT 103
25079: PUSH
25080: LD_INT 106
25082: PUSH
25083: LD_INT 108
25085: PUSH
25086: LD_INT 112
25088: PUSH
25089: LD_INT 113
25091: PUSH
25092: LD_INT 114
25094: PUSH
25095: LD_INT 115
25097: PUSH
25098: EMPTY
25099: LIST
25100: LIST
25101: LIST
25102: LIST
25103: LIST
25104: LIST
25105: LIST
25106: LIST
25107: LIST
25108: PUSH
25109: EMPTY
25110: LIST
25111: LIST
25112: ST_TO_ADDR
25113: GO 25344
25115: LD_INT 19
25117: DOUBLE
25118: EQUAL
25119: IFTRUE 25123
25121: GO 25343
25123: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ; end ;
25124: NOP4
25128: PUSH
25129: LD_INT 1
25131: PUSH
25132: LD_INT 2
25134: PUSH
25135: LD_INT 3
25137: PUSH
25138: LD_INT 4
25140: PUSH
25141: LD_INT 5
25143: PUSH
25144: LD_INT 6
25146: PUSH
25147: LD_INT 7
25149: PUSH
25150: LD_INT 8
25152: PUSH
25153: LD_INT 9
25155: PUSH
25156: LD_INT 10
25158: PUSH
25159: LD_INT 11
25161: PUSH
25162: LD_INT 12
25164: PUSH
25165: LD_INT 13
25167: PUSH
25168: LD_INT 14
25170: PUSH
25171: LD_INT 15
25173: PUSH
25174: LD_INT 16
25176: PUSH
25177: LD_INT 17
25179: PUSH
25180: LD_INT 18
25182: PUSH
25183: LD_INT 19
25185: PUSH
25186: LD_INT 20
25188: PUSH
25189: LD_INT 21
25191: PUSH
25192: LD_INT 22
25194: PUSH
25195: LD_INT 23
25197: PUSH
25198: LD_INT 24
25200: PUSH
25201: LD_INT 25
25203: PUSH
25204: LD_INT 26
25206: PUSH
25207: LD_INT 27
25209: PUSH
25210: LD_INT 28
25212: PUSH
25213: LD_INT 29
25215: PUSH
25216: LD_INT 30
25218: PUSH
25219: LD_INT 31
25221: PUSH
25222: LD_INT 32
25224: PUSH
25225: LD_INT 33
25227: PUSH
25228: LD_INT 34
25230: PUSH
25231: LD_INT 35
25233: PUSH
25234: LD_INT 36
25236: PUSH
25237: EMPTY
25238: LIST
25239: LIST
25240: LIST
25241: LIST
25242: LIST
25243: LIST
25244: LIST
25245: LIST
25246: LIST
25247: LIST
25248: LIST
25249: LIST
25250: LIST
25251: LIST
25252: LIST
25253: LIST
25254: LIST
25255: LIST
25256: LIST
25257: LIST
25258: LIST
25259: LIST
25260: LIST
25261: LIST
25262: LIST
25263: LIST
25264: LIST
25265: LIST
25266: LIST
25267: LIST
25268: LIST
25269: LIST
25270: LIST
25271: LIST
25272: LIST
25273: LIST
25274: PUSH
25275: LD_INT 101
25277: PUSH
25278: LD_INT 102
25280: PUSH
25281: LD_INT 103
25283: PUSH
25284: LD_INT 104
25286: PUSH
25287: LD_INT 105
25289: PUSH
25290: LD_INT 106
25292: PUSH
25293: LD_INT 107
25295: PUSH
25296: LD_INT 108
25298: PUSH
25299: LD_INT 109
25301: PUSH
25302: LD_INT 110
25304: PUSH
25305: LD_INT 111
25307: PUSH
25308: LD_INT 112
25310: PUSH
25311: LD_INT 113
25313: PUSH
25314: LD_INT 114
25316: PUSH
25317: LD_INT 115
25319: PUSH
25320: EMPTY
25321: LIST
25322: LIST
25323: LIST
25324: LIST
25325: LIST
25326: LIST
25327: LIST
25328: LIST
25329: LIST
25330: LIST
25331: LIST
25332: LIST
25333: LIST
25334: LIST
25335: LIST
25336: PUSH
25337: EMPTY
25338: LIST
25339: LIST
25340: ST_TO_ADDR
25341: GO 25344
25343: POP
// end else
25344: GO 25563
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ;
25346: NOP4
25350: PUSH
25351: LD_INT 1
25353: PUSH
25354: LD_INT 2
25356: PUSH
25357: LD_INT 3
25359: PUSH
25360: LD_INT 4
25362: PUSH
25363: LD_INT 5
25365: PUSH
25366: LD_INT 6
25368: PUSH
25369: LD_INT 7
25371: PUSH
25372: LD_INT 8
25374: PUSH
25375: LD_INT 9
25377: PUSH
25378: LD_INT 10
25380: PUSH
25381: LD_INT 11
25383: PUSH
25384: LD_INT 12
25386: PUSH
25387: LD_INT 13
25389: PUSH
25390: LD_INT 14
25392: PUSH
25393: LD_INT 15
25395: PUSH
25396: LD_INT 16
25398: PUSH
25399: LD_INT 17
25401: PUSH
25402: LD_INT 18
25404: PUSH
25405: LD_INT 19
25407: PUSH
25408: LD_INT 20
25410: PUSH
25411: LD_INT 21
25413: PUSH
25414: LD_INT 22
25416: PUSH
25417: LD_INT 23
25419: PUSH
25420: LD_INT 24
25422: PUSH
25423: LD_INT 25
25425: PUSH
25426: LD_INT 26
25428: PUSH
25429: LD_INT 27
25431: PUSH
25432: LD_INT 28
25434: PUSH
25435: LD_INT 29
25437: PUSH
25438: LD_INT 30
25440: PUSH
25441: LD_INT 31
25443: PUSH
25444: LD_INT 32
25446: PUSH
25447: LD_INT 33
25449: PUSH
25450: LD_INT 34
25452: PUSH
25453: LD_INT 35
25455: PUSH
25456: LD_INT 36
25458: PUSH
25459: EMPTY
25460: LIST
25461: LIST
25462: LIST
25463: LIST
25464: LIST
25465: LIST
25466: LIST
25467: LIST
25468: LIST
25469: LIST
25470: LIST
25471: LIST
25472: LIST
25473: LIST
25474: LIST
25475: LIST
25476: LIST
25477: LIST
25478: LIST
25479: LIST
25480: LIST
25481: LIST
25482: LIST
25483: LIST
25484: LIST
25485: LIST
25486: LIST
25487: LIST
25488: LIST
25489: LIST
25490: LIST
25491: LIST
25492: LIST
25493: LIST
25494: LIST
25495: LIST
25496: PUSH
25497: LD_INT 101
25499: PUSH
25500: LD_INT 102
25502: PUSH
25503: LD_INT 103
25505: PUSH
25506: LD_INT 104
25508: PUSH
25509: LD_INT 105
25511: PUSH
25512: LD_INT 106
25514: PUSH
25515: LD_INT 107
25517: PUSH
25518: LD_INT 108
25520: PUSH
25521: LD_INT 109
25523: PUSH
25524: LD_INT 110
25526: PUSH
25527: LD_INT 111
25529: PUSH
25530: LD_INT 112
25532: PUSH
25533: LD_INT 113
25535: PUSH
25536: LD_INT 114
25538: PUSH
25539: LD_INT 115
25541: PUSH
25542: EMPTY
25543: LIST
25544: LIST
25545: LIST
25546: LIST
25547: LIST
25548: LIST
25549: LIST
25550: LIST
25551: LIST
25552: LIST
25553: LIST
25554: LIST
25555: LIST
25556: LIST
25557: LIST
25558: PUSH
25559: EMPTY
25560: LIST
25561: LIST
25562: ST_TO_ADDR
// if result then
25563: NOP4
25567: IFFALSE 25856
// begin normal :=  ;
25569: NOP4
25573: PUSH
25574: LD_STRING 
25576: ST_TO_ADDR
// hardcore :=  ;
25577: NOP4
25581: PUSH
25582: LD_STRING 
25584: ST_TO_ADDR
// for i = 1 to normalCounter do
25585: NOP4
25589: PUSH
25590: DOUBLE
25591: LD_INT 1
25593: DEC
25594: ST_TO_ADDR
25595: NOP4
25599: PUSH
25600: FOR_TO
25601: IFFALSE 25702
// begin tmp := 0 ;
25603: NOP4
25607: PUSH
25608: LD_STRING 0
25610: ST_TO_ADDR
// if result [ 1 ] then
25611: NOP4
25615: PUSH
25616: LD_INT 1
25618: ARRAY
25619: IFFALSE 25684
// if result [ 1 ] [ 1 ] = i then
25621: NOP4
25625: PUSH
25626: LD_INT 1
25628: ARRAY
25629: PUSH
25630: LD_INT 1
25632: ARRAY
25633: PUSH
25634: NOP4
25638: EQUAL
25639: IFFALSE 25684
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
25641: NOP4
25645: PUSH
25646: NOP4
25650: PPUSH
25651: LD_INT 1
25653: PPUSH
25654: NOP4
25658: PUSH
25659: LD_INT 1
25661: ARRAY
25662: PPUSH
25663: LD_INT 1
25665: PPUSH
25666: NOP4
25670: PPUSH
25671: NOP4
25675: ST_TO_ADDR
// tmp := 1 ;
25676: NOP4
25680: PUSH
25681: LD_STRING 1
25683: ST_TO_ADDR
// end ; normal := normal & tmp ;
25684: NOP4
25688: PUSH
25689: NOP4
25693: PUSH
25694: NOP4
25698: STR
25699: ST_TO_ADDR
// end ;
25700: GO 25600
25702: POP
25703: POP
// for i = 1 to hardcoreCounter do
25704: NOP4
25708: PUSH
25709: DOUBLE
25710: LD_INT 1
25712: DEC
25713: ST_TO_ADDR
25714: NOP4
25718: PUSH
25719: FOR_TO
25720: IFFALSE 25825
// begin tmp := 0 ;
25722: NOP4
25726: PUSH
25727: LD_STRING 0
25729: ST_TO_ADDR
// if result [ 2 ] then
25730: NOP4
25734: PUSH
25735: LD_INT 2
25737: ARRAY
25738: IFFALSE 25807
// if result [ 2 ] [ 1 ] = 100 + i then
25740: NOP4
25744: PUSH
25745: LD_INT 2
25747: ARRAY
25748: PUSH
25749: LD_INT 1
25751: ARRAY
25752: PUSH
25753: LD_INT 100
25755: PUSH
25756: NOP4
25760: PLUS
25761: EQUAL
25762: IFFALSE 25807
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
25764: NOP4
25768: PUSH
25769: NOP4
25773: PPUSH
25774: LD_INT 2
25776: PPUSH
25777: NOP4
25781: PUSH
25782: LD_INT 2
25784: ARRAY
25785: PPUSH
25786: LD_INT 1
25788: PPUSH
25789: NOP4
25793: PPUSH
25794: NOP4
25798: ST_TO_ADDR
// tmp := 1 ;
25799: NOP4
25803: PUSH
25804: LD_STRING 1
25806: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
25807: NOP4
25811: PUSH
25812: NOP4
25816: PUSH
25817: NOP4
25821: STR
25822: ST_TO_ADDR
// end ;
25823: GO 25719
25825: POP
25826: POP
// ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & ") ) ;
25827: LD_STRING getStreamItemsFromMission("
25829: PUSH
25830: NOP4
25834: STR
25835: PUSH
25836: LD_STRING ","
25838: STR
25839: PUSH
25840: NOP4
25844: STR
25845: PUSH
25846: LD_STRING ")
25848: STR
25849: PPUSH
25850: NOP4
// end else
25854: GO 25863
// ToLua ( getStreamItemsFromMission("","") ) ;
25856: LD_STRING getStreamItemsFromMission("","")
25858: PPUSH
25859: NOP4
// end ;
25863: LD_VAR 0 1
25867: RET
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
25868: NOP4
25872: PUSH
25873: NOP4
25877: AND
25878: IFFALSE 26002
25880: GO 25882
25882: DISABLE
25883: LD_INT 0
25885: PPUSH
25886: PPUSH
// begin enable ;
25887: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
25888: NOP4
25892: PUSH
25893: LD_INT 22
25895: PUSH
25896: NOP4
25900: PUSH
25901: EMPTY
25902: LIST
25903: LIST
25904: PUSH
25905: LD_INT 2
25907: PUSH
25908: LD_INT 34
25910: PUSH
25911: LD_INT 7
25913: PUSH
25914: EMPTY
25915: LIST
25916: LIST
25917: PUSH
25918: LD_INT 34
25920: PUSH
25921: LD_INT 45
25923: PUSH
25924: EMPTY
25925: LIST
25926: LIST
25927: PUSH
25928: LD_INT 34
25930: PUSH
25931: LD_INT 28
25933: PUSH
25934: EMPTY
25935: LIST
25936: LIST
25937: PUSH
25938: LD_INT 34
25940: PUSH
25941: LD_INT 47
25943: PUSH
25944: EMPTY
25945: LIST
25946: LIST
25947: PUSH
25948: EMPTY
25949: LIST
25950: LIST
25951: LIST
25952: LIST
25953: LIST
25954: PUSH
25955: EMPTY
25956: LIST
25957: LIST
25958: PPUSH
25959: NOP4
25963: ST_TO_ADDR
// if not tmp then
25964: NOP4
25968: NOT
25969: IFFALSE 25973
// exit ;
25971: GO 26002
// for i in tmp do
25973: NOP4
25977: PUSH
25978: NOP4
25982: PUSH
25983: FOR_IN
25984: IFFALSE 26000
// begin SetLives ( i , 0 ) ;
25986: NOP4
25990: PPUSH
25991: LD_INT 0
25993: PPUSH
25994: NOP4
// end ;
25998: GO 25983
26000: POP
26001: POP
// end ;
26002: PPOPN 2
26004: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
26005: NOP4
26009: PUSH
26010: NOP4
26014: AND
26015: IFFALSE 26099
26017: GO 26019
26019: DISABLE
26020: LD_INT 0
26022: PPUSH
26023: PPUSH
// begin enable ;
26024: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
26025: NOP4
26029: PUSH
26030: LD_INT 22
26032: PUSH
26033: NOP4
26037: PUSH
26038: EMPTY
26039: LIST
26040: LIST
26041: PUSH
26042: LD_INT 32
26044: PUSH
26045: LD_INT 3
26047: PUSH
26048: EMPTY
26049: LIST
26050: LIST
26051: PUSH
26052: EMPTY
26053: LIST
26054: LIST
26055: PPUSH
26056: NOP4
26060: ST_TO_ADDR
// if not tmp then
26061: NOP4
26065: NOT
26066: IFFALSE 26070
// exit ;
26068: GO 26099
// for i in tmp do
26070: NOP4
26074: PUSH
26075: NOP4
26079: PUSH
26080: FOR_IN
26081: IFFALSE 26097
// begin SetLives ( i , 0 ) ;
26083: NOP4
26087: PPUSH
26088: LD_INT 0
26090: PPUSH
26091: NOP4
// end ;
26095: GO 26080
26097: POP
26098: POP
// end ;
26099: PPOPN 2
26101: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
26102: NOP4
26106: PUSH
26107: NOP4
26111: AND
26112: IFFALSE 26205
26114: GO 26116
26116: DISABLE
26117: LD_INT 0
26119: PPUSH
// begin enable ;
26120: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
26121: NOP4
26125: PUSH
26126: LD_INT 22
26128: PUSH
26129: NOP4
26133: PUSH
26134: EMPTY
26135: LIST
26136: LIST
26137: PUSH
26138: LD_INT 2
26140: PUSH
26141: LD_INT 25
26143: PUSH
26144: LD_INT 5
26146: PUSH
26147: EMPTY
26148: LIST
26149: LIST
26150: PUSH
26151: LD_INT 25
26153: PUSH
26154: LD_INT 9
26156: PUSH
26157: EMPTY
26158: LIST
26159: LIST
26160: PUSH
26161: LD_INT 25
26163: PUSH
26164: LD_INT 8
26166: PUSH
26167: EMPTY
26168: LIST
26169: LIST
26170: PUSH
26171: EMPTY
26172: LIST
26173: LIST
26174: LIST
26175: LIST
26176: PUSH
26177: EMPTY
26178: LIST
26179: LIST
26180: PPUSH
26181: NOP4
26185: PUSH
26186: FOR_IN
26187: IFFALSE 26203
// begin SetClass ( i , 1 ) ;
26189: NOP4
26193: PPUSH
26194: LD_INT 1
26196: PPUSH
26197: NOP4
// end ;
26201: GO 26186
26203: POP
26204: POP
// end ;
26205: PPOPN 1
26207: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
26208: NOP4
26212: PUSH
26213: NOP4
26217: AND
26218: PUSH
26219: NOP4
26223: PUSH
26224: LD_INT 7
26226: LESS
26227: AND
26228: IFFALSE 26242
26230: GO 26232
26232: DISABLE
// begin enable ;
26233: ENABLE
// game_speed := 7 ;
26234: LD_ADDR_OWVAR 65
26238: PUSH
26239: LD_INT 7
26241: ST_TO_ADDR
// end ;
26242: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
26243: NOP4
26247: PUSH
26248: NOP4
26252: AND
26253: IFFALSE 26455
26255: GO 26257
26257: DISABLE
26258: LD_INT 0
26260: PPUSH
26261: PPUSH
26262: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
26263: NOP4
26267: PUSH
26268: LD_INT 81
26270: PUSH
26271: NOP4
26275: PUSH
26276: EMPTY
26277: LIST
26278: LIST
26279: PUSH
26280: LD_INT 21
26282: PUSH
26283: LD_INT 1
26285: PUSH
26286: EMPTY
26287: LIST
26288: LIST
26289: PUSH
26290: EMPTY
26291: LIST
26292: LIST
26293: PPUSH
26294: NOP4
26298: ST_TO_ADDR
// if not tmp then
26299: NOP4
26303: NOT
26304: IFFALSE 26308
// exit ;
26306: GO 26455
// if tmp > 5 then
26308: NOP4
26312: PUSH
26313: LD_INT 5
26315: GREATER
26316: IFFALSE 26328
// k := 5 else
26318: NOP4
26322: PUSH
26323: LD_INT 5
26325: ST_TO_ADDR
26326: GO 26338
// k := tmp ;
26328: NOP4
26332: PUSH
26333: NOP4
26337: ST_TO_ADDR
// for i := 1 to k do
26338: NOP4
26342: PUSH
26343: DOUBLE
26344: LD_INT 1
26346: DEC
26347: ST_TO_ADDR
26348: NOP4
26352: PUSH
26353: FOR_TO
26354: IFFALSE 26453
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
26356: NOP4
26360: PUSH
26361: NOP4
26365: ARRAY
26366: PPUSH
26367: NOP4
26371: PUSH
26372: LD_INT 4
26374: MOD
26375: PUSH
26376: LD_INT 1
26378: PLUS
26379: PPUSH
26380: NOP4
26384: PUSH
26385: LD_INT 10
26387: LESS
26388: IFFALSE 26451
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
26390: NOP4
26394: PUSH
26395: NOP4
26399: ARRAY
26400: PPUSH
26401: NOP4
26405: PUSH
26406: LD_INT 4
26408: MOD
26409: PUSH
26410: LD_INT 1
26412: PLUS
26413: PPUSH
26414: NOP4
26418: PUSH
26419: NOP4
26423: ARRAY
26424: PPUSH
26425: NOP4
26429: PUSH
26430: LD_INT 4
26432: MOD
26433: PUSH
26434: LD_INT 1
26436: PLUS
26437: PPUSH
26438: NOP4
26442: PUSH
26443: LD_INT 1
26445: PLUS
26446: PPUSH
26447: NOP4
26451: GO 26353
26453: POP
26454: POP
// end ;
26455: PPOPN 3
26457: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
26458: NOP4
26462: PUSH
26463: NOP4
26467: AND
26468: IFFALSE 26488
26470: GO 26472
26472: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
26473: LD_INT 4
26475: PPUSH
26476: NOP4
26480: PPUSH
26481: LD_INT 0
26483: PPUSH
26484: NOP4
26488: END
// every 0 0$1 trigger StreamModeActive and sShovel do
26489: NOP4
26493: PUSH
26494: NOP4
26498: AND
26499: IFFALSE 26519
26501: GO 26503
26503: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
26504: LD_INT 19
26506: PPUSH
26507: NOP4
26511: PPUSH
26512: LD_INT 0
26514: PPUSH
26515: NOP4
26519: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
26520: NOP4
26524: PUSH
26525: NOP4
26529: AND
26530: IFFALSE 26632
26532: GO 26534
26534: DISABLE
26535: LD_INT 0
26537: PPUSH
26538: PPUSH
// begin enable ;
26539: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
26540: NOP4
26544: PUSH
26545: LD_INT 22
26547: PUSH
26548: NOP4
26552: PUSH
26553: EMPTY
26554: LIST
26555: LIST
26556: PUSH
26557: LD_INT 2
26559: PUSH
26560: LD_INT 34
26562: PUSH
26563: LD_INT 11
26565: PUSH
26566: EMPTY
26567: LIST
26568: LIST
26569: PUSH
26570: LD_INT 34
26572: PUSH
26573: LD_INT 30
26575: PUSH
26576: EMPTY
26577: LIST
26578: LIST
26579: PUSH
26580: EMPTY
26581: LIST
26582: LIST
26583: LIST
26584: PUSH
26585: EMPTY
26586: LIST
26587: LIST
26588: PPUSH
26589: NOP4
26593: ST_TO_ADDR
// if not tmp then
26594: NOP4
26598: NOT
26599: IFFALSE 26603
// exit ;
26601: GO 26632
// for i in tmp do
26603: NOP4
26607: PUSH
26608: NOP4
26612: PUSH
26613: FOR_IN
26614: IFFALSE 26630
// begin SetLives ( i , 0 ) ;
26616: NOP4
26620: PPUSH
26621: LD_INT 0
26623: PPUSH
26624: NOP4
// end ;
26628: GO 26613
26630: POP
26631: POP
// end ;
26632: PPOPN 2
26634: END
// every 0 0$1 trigger StreamModeActive and sBunker do
26635: NOP4
26639: PUSH
26640: NOP4
26644: AND
26645: IFFALSE 26665
26647: GO 26649
26649: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
26650: LD_INT 32
26652: PPUSH
26653: NOP4
26657: PPUSH
26658: LD_INT 0
26660: PPUSH
26661: NOP4
26665: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
26666: NOP4
26670: PUSH
26671: NOP4
26675: AND
26676: IFFALSE 26857
26678: GO 26680
26680: DISABLE
26681: LD_INT 0
26683: PPUSH
26684: PPUSH
26685: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
26686: NOP4
26690: PUSH
26691: LD_INT 22
26693: PUSH
26694: NOP4
26698: PUSH
26699: EMPTY
26700: LIST
26701: LIST
26702: PUSH
26703: LD_INT 33
26705: PUSH
26706: LD_INT 3
26708: PUSH
26709: EMPTY
26710: LIST
26711: LIST
26712: PUSH
26713: EMPTY
26714: LIST
26715: LIST
26716: PPUSH
26717: NOP4
26721: ST_TO_ADDR
// if not tmp then
26722: NOP4
26726: NOT
26727: IFFALSE 26731
// exit ;
26729: GO 26857
// side := 0 ;
26731: NOP4
26735: PUSH
26736: LD_INT 0
26738: ST_TO_ADDR
// for i := 1 to 8 do
26739: NOP4
26743: PUSH
26744: DOUBLE
26745: LD_INT 1
26747: DEC
26748: ST_TO_ADDR
26749: LD_INT 8
26751: PUSH
26752: FOR_TO
26753: IFFALSE 26801
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
26755: NOP4
26759: PUSH
26760: NOP4
26764: NONEQUAL
26765: PUSH
26766: NOP4
26770: PPUSH
26771: NOP4
26775: PPUSH
26776: NOP4
26780: PUSH
26781: LD_INT 2
26783: EQUAL
26784: AND
26785: IFFALSE 26799
// begin side := i ;
26787: NOP4
26791: PUSH
26792: NOP4
26796: ST_TO_ADDR
// break ;
26797: GO 26801
// end ;
26799: GO 26752
26801: POP
26802: POP
// if not side then
26803: NOP4
26807: NOT
26808: IFFALSE 26812
// exit ;
26810: GO 26857
// for i := 1 to tmp do
26812: NOP4
26816: PUSH
26817: DOUBLE
26818: LD_INT 1
26820: DEC
26821: ST_TO_ADDR
26822: NOP4
26826: PUSH
26827: FOR_TO
26828: IFFALSE 26855
// if Prob ( 60 ) then
26830: LD_INT 60
26832: PPUSH
26833: NOP4
26837: IFFALSE 26853
// SetSide ( i , side ) ;
26839: NOP4
26843: PPUSH
26844: NOP4
26848: PPUSH
26849: NOP4
26853: GO 26827
26855: POP
26856: POP
// end ;
26857: PPOPN 3
26859: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
26860: NOP4
26864: PUSH
26865: NOP4
26869: AND
26870: IFFALSE 26989
26872: GO 26874
26874: DISABLE
26875: LD_INT 0
26877: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
26878: NOP4
26882: PUSH
26883: LD_INT 22
26885: PUSH
26886: NOP4
26890: PUSH
26891: EMPTY
26892: LIST
26893: LIST
26894: PUSH
26895: LD_INT 21
26897: PUSH
26898: LD_INT 1
26900: PUSH
26901: EMPTY
26902: LIST
26903: LIST
26904: PUSH
26905: LD_INT 3
26907: PUSH
26908: LD_INT 23
26910: PUSH
26911: LD_INT 0
26913: PUSH
26914: EMPTY
26915: LIST
26916: LIST
26917: PUSH
26918: EMPTY
26919: LIST
26920: LIST
26921: PUSH
26922: EMPTY
26923: LIST
26924: LIST
26925: LIST
26926: PPUSH
26927: NOP4
26931: PUSH
26932: FOR_IN
26933: IFFALSE 26987
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
26935: NOP4
26939: PPUSH
26940: NOP4
26944: PUSH
26945: LD_INT 1
26947: PUSH
26948: LD_INT 2
26950: PUSH
26951: LD_INT 3
26953: PUSH
26954: LD_INT 4
26956: PUSH
26957: EMPTY
26958: LIST
26959: LIST
26960: LIST
26961: LIST
26962: IN
26963: IFFALSE 26985
// SetClass ( un , rand ( 1 , 4 ) ) ;
26965: NOP4
26969: PPUSH
26970: LD_INT 1
26972: PPUSH
26973: LD_INT 4
26975: PPUSH
26976: NOP4
26980: PPUSH
26981: NOP4
26985: GO 26932
26987: POP
26988: POP
// end ;
26989: PPOPN 1
26991: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
26992: NOP4
26996: PUSH
26997: NOP4
27001: AND
27002: IFFALSE 27081
27004: GO 27006
27006: DISABLE
27007: LD_INT 0
27009: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
27010: NOP4
27014: PUSH
27015: LD_INT 22
27017: PUSH
27018: NOP4
27022: PUSH
27023: EMPTY
27024: LIST
27025: LIST
27026: PUSH
27027: LD_INT 21
27029: PUSH
27030: LD_INT 3
27032: PUSH
27033: EMPTY
27034: LIST
27035: LIST
27036: PUSH
27037: EMPTY
27038: LIST
27039: LIST
27040: PPUSH
27041: NOP4
27045: ST_TO_ADDR
// if not tmp then
27046: NOP4
27050: NOT
27051: IFFALSE 27055
// exit ;
27053: GO 27081
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
27055: NOP4
27059: PUSH
27060: LD_INT 1
27062: PPUSH
27063: NOP4
27067: PPUSH
27068: NOP4
27072: ARRAY
27073: PPUSH
27074: LD_INT 100
27076: PPUSH
27077: NOP4
// end ;
27081: PPOPN 1
27083: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
27084: NOP4
27088: PUSH
27089: NOP4
27093: AND
27094: IFFALSE 27192
27096: GO 27098
27098: DISABLE
27099: LD_INT 0
27101: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
27102: NOP4
27106: PUSH
27107: LD_INT 22
27109: PUSH
27110: NOP4
27114: PUSH
27115: EMPTY
27116: LIST
27117: LIST
27118: PUSH
27119: LD_INT 21
27121: PUSH
27122: LD_INT 1
27124: PUSH
27125: EMPTY
27126: LIST
27127: LIST
27128: PUSH
27129: EMPTY
27130: LIST
27131: LIST
27132: PPUSH
27133: NOP4
27137: ST_TO_ADDR
// if not tmp then
27138: NOP4
27142: NOT
27143: IFFALSE 27147
// exit ;
27145: GO 27192
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
27147: NOP4
27151: PUSH
27152: LD_INT 1
27154: PPUSH
27155: NOP4
27159: PPUSH
27160: NOP4
27164: ARRAY
27165: PPUSH
27166: LD_INT 1
27168: PPUSH
27169: LD_INT 4
27171: PPUSH
27172: NOP4
27176: PPUSH
27177: LD_INT 3000
27179: PPUSH
27180: LD_INT 9000
27182: PPUSH
27183: NOP4
27187: PPUSH
27188: NOP4
// end ;
27192: PPOPN 1
27194: END
// every 0 0$1 trigger StreamModeActive and sDepot do
27195: NOP4
27199: PUSH
27200: NOP4
27204: AND
27205: IFFALSE 27225
27207: GO 27209
27209: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
27210: LD_INT 1
27212: PPUSH
27213: NOP4
27217: PPUSH
27218: LD_INT 0
27220: PPUSH
27221: NOP4
27225: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
27226: NOP4
27230: PUSH
27231: NOP4
27235: AND
27236: IFFALSE 27319
27238: GO 27240
27240: DISABLE
27241: LD_INT 0
27243: PPUSH
27244: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
27245: NOP4
27249: PUSH
27250: LD_INT 22
27252: PUSH
27253: NOP4
27257: PUSH
27258: EMPTY
27259: LIST
27260: LIST
27261: PUSH
27262: LD_INT 21
27264: PUSH
27265: LD_INT 3
27267: PUSH
27268: EMPTY
27269: LIST
27270: LIST
27271: PUSH
27272: EMPTY
27273: LIST
27274: LIST
27275: PPUSH
27276: NOP4
27280: ST_TO_ADDR
// if not tmp then
27281: NOP4
27285: NOT
27286: IFFALSE 27290
// exit ;
27288: GO 27319
// for i in tmp do
27290: NOP4
27294: PUSH
27295: NOP4
27299: PUSH
27300: FOR_IN
27301: IFFALSE 27317
// SetBLevel ( i , 10 ) ;
27303: NOP4
27307: PPUSH
27308: LD_INT 10
27310: PPUSH
27311: NOP4
27315: GO 27300
27317: POP
27318: POP
// end ;
27319: PPOPN 2
27321: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
27322: NOP4
27326: PUSH
27327: NOP4
27331: AND
27332: IFFALSE 27443
27334: GO 27336
27336: DISABLE
27337: LD_INT 0
27339: PPUSH
27340: PPUSH
27341: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
27342: NOP4
27346: PUSH
27347: LD_INT 22
27349: PUSH
27350: NOP4
27354: PUSH
27355: EMPTY
27356: LIST
27357: LIST
27358: PUSH
27359: LD_INT 25
27361: PUSH
27362: LD_INT 1
27364: PUSH
27365: EMPTY
27366: LIST
27367: LIST
27368: PUSH
27369: EMPTY
27370: LIST
27371: LIST
27372: PPUSH
27373: NOP4
27377: ST_TO_ADDR
// if not tmp then
27378: NOP4
27382: NOT
27383: IFFALSE 27387
// exit ;
27385: GO 27443
// un := tmp [ rand ( 1 , tmp ) ] ;
27387: NOP4
27391: PUSH
27392: NOP4
27396: PUSH
27397: LD_INT 1
27399: PPUSH
27400: NOP4
27404: PPUSH
27405: NOP4
27409: ARRAY
27410: ST_TO_ADDR
// if Crawls ( un ) then
27411: NOP4
27415: PPUSH
27416: NOP4
27420: IFFALSE 27431
// ComWalk ( un ) ;
27422: NOP4
27426: PPUSH
27427: NOP4
// SetClass ( un , class_sniper ) ;
27431: NOP4
27435: PPUSH
27436: LD_INT 5
27438: PPUSH
27439: NOP4
// end ;
27443: PPOPN 3
27445: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 3 do
27446: NOP4
27450: PUSH
27451: NOP4
27455: AND
27456: PUSH
27457: NOP4
27461: PUSH
27462: LD_INT 3
27464: LESS
27465: AND
27466: IFFALSE 27485
27468: GO 27470
27470: DISABLE
// Difficulty := Difficulty + 1 ;
27471: LD_ADDR_OWVAR 67
27475: PUSH
27476: NOP4
27480: PUSH
27481: LD_INT 1
27483: PLUS
27484: ST_TO_ADDR
27485: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
27486: NOP4
27490: PUSH
27491: NOP4
27495: AND
27496: IFFALSE 27599
27498: GO 27500
27500: DISABLE
27501: LD_INT 0
27503: PPUSH
// begin for i := 1 to 5 do
27504: NOP4
27508: PUSH
27509: DOUBLE
27510: LD_INT 1
27512: DEC
27513: ST_TO_ADDR
27514: LD_INT 5
27516: PUSH
27517: FOR_TO
27518: IFFALSE 27597
// begin uc_nation := nation_nature ;
27520: LD_ADDR_OWVAR 21
27524: PUSH
27525: LD_INT 0
27527: ST_TO_ADDR
// uc_side := 0 ;
27528: LD_ADDR_OWVAR 20
27532: PUSH
27533: LD_INT 0
27535: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
27536: LD_ADDR_OWVAR 29
27540: PUSH
27541: LD_INT 12
27543: PUSH
27544: LD_INT 12
27546: PUSH
27547: EMPTY
27548: LIST
27549: LIST
27550: ST_TO_ADDR
// hc_agressivity := 20 ;
27551: LD_ADDR_OWVAR 35
27555: PUSH
27556: LD_INT 20
27558: ST_TO_ADDR
// hc_class := class_tiger ;
27559: LD_ADDR_OWVAR 28
27563: PUSH
27564: LD_INT 14
27566: ST_TO_ADDR
// hc_gallery :=  ;
27567: LD_ADDR_OWVAR 33
27571: PUSH
27572: LD_STRING 
27574: ST_TO_ADDR
// hc_name :=  ;
27575: LD_ADDR_OWVAR 26
27579: PUSH
27580: LD_STRING 
27582: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
27583: NOP4
27587: PPUSH
27588: LD_INT 0
27590: PPUSH
27591: NOP4
// end ;
27595: GO 27517
27597: POP
27598: POP
// end ;
27599: PPOPN 1
27601: END
// every 0 0$1 trigger StreamModeActive and sBomb do
27602: NOP4
27606: PUSH
27607: NOP4
27611: AND
27612: IFFALSE 27621
27614: GO 27616
27616: DISABLE
// StreamSibBomb ;
27617: NOP4
27621: END
// export function StreamSibBomb ; var i , x , y ; begin
27622: LD_INT 0
27624: PPUSH
27625: PPUSH
27626: PPUSH
27627: PPUSH
// result := false ;
27628: NOP4
27632: PUSH
27633: LD_INT 0
27635: ST_TO_ADDR
// for i := 1 to 16 do
27636: NOP4
27640: PUSH
27641: DOUBLE
27642: LD_INT 1
27644: DEC
27645: ST_TO_ADDR
27646: LD_INT 16
27648: PUSH
27649: FOR_TO
27650: IFFALSE 27849
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
27652: NOP4
27656: PUSH
27657: LD_INT 10
27659: PUSH
27660: LD_INT 20
27662: PUSH
27663: LD_INT 30
27665: PUSH
27666: LD_INT 40
27668: PUSH
27669: LD_INT 50
27671: PUSH
27672: LD_INT 60
27674: PUSH
27675: LD_INT 70
27677: PUSH
27678: LD_INT 80
27680: PUSH
27681: LD_INT 90
27683: PUSH
27684: LD_INT 100
27686: PUSH
27687: LD_INT 110
27689: PUSH
27690: LD_INT 120
27692: PUSH
27693: LD_INT 130
27695: PUSH
27696: LD_INT 140
27698: PUSH
27699: LD_INT 150
27701: PUSH
27702: EMPTY
27703: LIST
27704: LIST
27705: LIST
27706: LIST
27707: LIST
27708: LIST
27709: LIST
27710: LIST
27711: LIST
27712: LIST
27713: LIST
27714: LIST
27715: LIST
27716: LIST
27717: LIST
27718: PUSH
27719: LD_INT 1
27721: PPUSH
27722: LD_INT 15
27724: PPUSH
27725: NOP4
27729: ARRAY
27730: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
27731: NOP4
27735: PUSH
27736: LD_INT 10
27738: PUSH
27739: LD_INT 20
27741: PUSH
27742: LD_INT 30
27744: PUSH
27745: LD_INT 40
27747: PUSH
27748: LD_INT 50
27750: PUSH
27751: LD_INT 60
27753: PUSH
27754: LD_INT 70
27756: PUSH
27757: LD_INT 80
27759: PUSH
27760: LD_INT 90
27762: PUSH
27763: LD_INT 100
27765: PUSH
27766: LD_INT 110
27768: PUSH
27769: LD_INT 120
27771: PUSH
27772: LD_INT 130
27774: PUSH
27775: LD_INT 140
27777: PUSH
27778: LD_INT 150
27780: PUSH
27781: EMPTY
27782: LIST
27783: LIST
27784: LIST
27785: LIST
27786: LIST
27787: LIST
27788: LIST
27789: LIST
27790: LIST
27791: LIST
27792: LIST
27793: LIST
27794: LIST
27795: LIST
27796: LIST
27797: PUSH
27798: LD_INT 1
27800: PPUSH
27801: LD_INT 15
27803: PPUSH
27804: NOP4
27808: ARRAY
27809: ST_TO_ADDR
// if ValidHex ( x , y ) then
27810: NOP4
27814: PPUSH
27815: NOP4
27819: PPUSH
27820: NOP4
27824: IFFALSE 27847
// begin result := [ x , y ] ;
27826: NOP4
27830: PUSH
27831: NOP4
27835: PUSH
27836: NOP4
27840: PUSH
27841: EMPTY
27842: LIST
27843: LIST
27844: ST_TO_ADDR
// break ;
27845: GO 27849
// end ; end ;
27847: GO 27649
27849: POP
27850: POP
// if result then
27851: NOP4
27855: IFFALSE 27915
// begin ToLua ( playSibBomb() ) ;
27857: LD_STRING playSibBomb()
27859: PPUSH
27860: NOP4
// wait ( 0 0$14 ) ;
27864: LD_INT 490
27866: PPUSH
27867: NOP4
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
27871: NOP4
27875: PUSH
27876: LD_INT 1
27878: ARRAY
27879: PPUSH
27880: NOP4
27884: PUSH
27885: LD_INT 2
27887: ARRAY
27888: PPUSH
27889: NOP4
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
27893: NOP4
27897: PUSH
27898: LD_INT 1
27900: ARRAY
27901: PPUSH
27902: NOP4
27906: PUSH
27907: LD_INT 2
27909: ARRAY
27910: PPUSH
27911: NOP4
// end ; end ;
27915: LD_VAR 0 1
27919: RET
// every 0 0$1 trigger StreamModeActive and sReset do
27920: NOP4
27924: PUSH
27925: NOP4
27929: AND
27930: IFFALSE 27942
27932: GO 27934
27934: DISABLE
// YouLost (  ) ;
27935: LD_STRING 
27937: PPUSH
27938: NOP4
27942: END
// every 0 0$1 trigger StreamModeActive and sFog do
27943: NOP4
27947: PUSH
27948: NOP4
27952: AND
27953: IFFALSE 27967
27955: GO 27957
27957: DISABLE
// FogOff ( your_side ) ;
27958: NOP4
27962: PPUSH
27963: NOP4
27967: END
// every 0 0$1 trigger StreamModeActive and sSun do
27968: NOP4
27972: PUSH
27973: NOP4
27977: AND
27978: IFFALSE 28006
27980: GO 27982
27982: DISABLE
// begin solar_recharge_percent := 0 ;
27983: LD_ADDR_OWVAR 79
27987: PUSH
27988: LD_INT 0
27990: ST_TO_ADDR
// wait ( 5 5$00 ) ;
27991: LD_INT 10500
27993: PPUSH
27994: NOP4
// solar_recharge_percent := 100 ;
27998: LD_ADDR_OWVAR 79
28002: PUSH
28003: LD_INT 100
28005: ST_TO_ADDR
// end ;
28006: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
28007: NOP4
28011: PUSH
28012: NOP4
28016: AND
28017: IFFALSE 28256
28019: GO 28021
28021: DISABLE
28022: LD_INT 0
28024: PPUSH
28025: PPUSH
28026: PPUSH
// begin tmp := [ ] ;
28027: NOP4
28031: PUSH
28032: EMPTY
28033: ST_TO_ADDR
// for i := 1 to 6 do
28034: NOP4
28038: PUSH
28039: DOUBLE
28040: LD_INT 1
28042: DEC
28043: ST_TO_ADDR
28044: LD_INT 6
28046: PUSH
28047: FOR_TO
28048: IFFALSE 28153
// begin uc_nation := nation_nature ;
28050: LD_ADDR_OWVAR 21
28054: PUSH
28055: LD_INT 0
28057: ST_TO_ADDR
// uc_side := 0 ;
28058: LD_ADDR_OWVAR 20
28062: PUSH
28063: LD_INT 0
28065: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
28066: LD_ADDR_OWVAR 29
28070: PUSH
28071: LD_INT 12
28073: PUSH
28074: LD_INT 12
28076: PUSH
28077: EMPTY
28078: LIST
28079: LIST
28080: ST_TO_ADDR
// hc_agressivity := 20 ;
28081: LD_ADDR_OWVAR 35
28085: PUSH
28086: LD_INT 20
28088: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
28089: LD_ADDR_OWVAR 28
28093: PUSH
28094: LD_INT 17
28096: ST_TO_ADDR
// hc_gallery :=  ;
28097: LD_ADDR_OWVAR 33
28101: PUSH
28102: LD_STRING 
28104: ST_TO_ADDR
// hc_name :=  ;
28105: LD_ADDR_OWVAR 26
28109: PUSH
28110: LD_STRING 
28112: ST_TO_ADDR
// un := CreateHuman ;
28113: NOP4
28117: PUSH
28118: NOP4
28122: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
28123: NOP4
28127: PPUSH
28128: LD_INT 1
28130: PPUSH
28131: NOP4
// tmp := tmp ^ un ;
28135: NOP4
28139: PUSH
28140: NOP4
28144: PUSH
28145: NOP4
28149: ADD
28150: ST_TO_ADDR
// end ;
28151: GO 28047
28153: POP
28154: POP
// repeat wait ( 0 0$1 ) ;
28155: LD_INT 35
28157: PPUSH
28158: NOP4
// for un in tmp do
28162: NOP4
28166: PUSH
28167: NOP4
28171: PUSH
28172: FOR_IN
28173: IFFALSE 28247
// begin if IsDead ( un ) then
28175: NOP4
28179: PPUSH
28180: NOP4
28184: IFFALSE 28204
// begin tmp := tmp diff un ;
28186: NOP4
28190: PUSH
28191: NOP4
28195: PUSH
28196: NOP4
28200: DIFF
28201: ST_TO_ADDR
// continue ;
28202: GO 28172
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
28204: NOP4
28208: PPUSH
28209: LD_INT 3
28211: PUSH
28212: LD_INT 22
28214: PUSH
28215: LD_INT 0
28217: PUSH
28218: EMPTY
28219: LIST
28220: LIST
28221: PUSH
28222: EMPTY
28223: LIST
28224: LIST
28225: PPUSH
28226: NOP4
28230: PPUSH
28231: NOP4
28235: PPUSH
28236: NOP4
28240: PPUSH
28241: NOP4
// end ;
28245: GO 28172
28247: POP
28248: POP
// until not tmp ;
28249: NOP4
28253: NOT
28254: IFFALSE 28155
// end ;
28256: PPOPN 3
28258: END
// every 0 0$1 trigger StreamModeActive and sTroll do
28259: NOP4
28263: PUSH
28264: NOP4
28268: AND
28269: IFFALSE 28323
28271: GO 28273
28273: DISABLE
// begin ToLua ( displayTroll(); ) ;
28274: LD_STRING displayTroll();
28276: PPUSH
28277: NOP4
// wait ( 3 3$00 ) ;
28281: LD_INT 6300
28283: PPUSH
28284: NOP4
// ToLua ( hideTroll(); ) ;
28288: LD_STRING hideTroll();
28290: PPUSH
28291: NOP4
// wait ( 1 1$00 ) ;
28295: LD_INT 2100
28297: PPUSH
28298: NOP4
// ToLua ( displayTroll(); ) ;
28302: LD_STRING displayTroll();
28304: PPUSH
28305: NOP4
// wait ( 1 1$00 ) ;
28309: LD_INT 2100
28311: PPUSH
28312: NOP4
// ToLua ( hideTroll(); ) ;
28316: LD_STRING hideTroll();
28318: PPUSH
28319: NOP4
// end ;
28323: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
28324: NOP4
28328: PUSH
28329: NOP4
28333: AND
28334: IFFALSE 28397
28336: GO 28338
28338: DISABLE
28339: LD_INT 0
28341: PPUSH
// begin p := 0 ;
28342: NOP4
28346: PUSH
28347: LD_INT 0
28349: ST_TO_ADDR
// repeat game_speed := 1 ;
28350: LD_ADDR_OWVAR 65
28354: PUSH
28355: LD_INT 1
28357: ST_TO_ADDR
// wait ( 0 0$1 ) ;
28358: LD_INT 35
28360: PPUSH
28361: NOP4
// p := p + 1 ;
28365: NOP4
28369: PUSH
28370: NOP4
28374: PUSH
28375: LD_INT 1
28377: PLUS
28378: ST_TO_ADDR
// until p >= 60 ;
28379: NOP4
28383: PUSH
28384: LD_INT 60
28386: GREATEREQUAL
28387: IFFALSE 28350
// game_speed := 4 ;
28389: LD_ADDR_OWVAR 65
28393: PUSH
28394: LD_INT 4
28396: ST_TO_ADDR
// end ;
28397: PPOPN 1
28399: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
28400: NOP4
28404: PUSH
28405: NOP4
28409: AND
28410: IFFALSE 28556
28412: GO 28414
28414: DISABLE
28415: LD_INT 0
28417: PPUSH
28418: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
28419: NOP4
28423: PUSH
28424: LD_INT 22
28426: PUSH
28427: NOP4
28431: PUSH
28432: EMPTY
28433: LIST
28434: LIST
28435: PUSH
28436: LD_INT 2
28438: PUSH
28439: LD_INT 30
28441: PUSH
28442: LD_INT 0
28444: PUSH
28445: EMPTY
28446: LIST
28447: LIST
28448: PUSH
28449: LD_INT 30
28451: PUSH
28452: LD_INT 1
28454: PUSH
28455: EMPTY
28456: LIST
28457: LIST
28458: PUSH
28459: EMPTY
28460: LIST
28461: LIST
28462: LIST
28463: PUSH
28464: EMPTY
28465: LIST
28466: LIST
28467: PPUSH
28468: NOP4
28472: ST_TO_ADDR
// if not depot then
28473: NOP4
28477: NOT
28478: IFFALSE 28482
// exit ;
28480: GO 28556
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
28482: NOP4
28486: PUSH
28487: NOP4
28491: PUSH
28492: LD_INT 1
28494: PPUSH
28495: NOP4
28499: PPUSH
28500: NOP4
28504: ARRAY
28505: PPUSH
28506: NOP4
28510: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
28511: NOP4
28515: PPUSH
28516: LD_INT 1
28518: PPUSH
28519: LD_INT 0
28521: PPUSH
28522: NOP4
// SetResourceType ( base , mat_oil , 0 ) ;
28526: NOP4
28530: PPUSH
28531: LD_INT 2
28533: PPUSH
28534: LD_INT 0
28536: PPUSH
28537: NOP4
// SetResourceType ( base , mat_siberit , 0 ) ;
28541: NOP4
28545: PPUSH
28546: LD_INT 3
28548: PPUSH
28549: LD_INT 0
28551: PPUSH
28552: NOP4
// end ;
28556: PPOPN 2
28558: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
28559: NOP4
28563: PUSH
28564: NOP4
28568: AND
28569: IFFALSE 28666
28571: GO 28573
28573: DISABLE
28574: LD_INT 0
28576: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
28577: NOP4
28581: PUSH
28582: LD_INT 22
28584: PUSH
28585: NOP4
28589: PUSH
28590: EMPTY
28591: LIST
28592: LIST
28593: PUSH
28594: LD_INT 21
28596: PUSH
28597: LD_INT 1
28599: PUSH
28600: EMPTY
28601: LIST
28602: LIST
28603: PUSH
28604: LD_INT 3
28606: PUSH
28607: LD_INT 23
28609: PUSH
28610: LD_INT 0
28612: PUSH
28613: EMPTY
28614: LIST
28615: LIST
28616: PUSH
28617: EMPTY
28618: LIST
28619: LIST
28620: PUSH
28621: EMPTY
28622: LIST
28623: LIST
28624: LIST
28625: PPUSH
28626: NOP4
28630: ST_TO_ADDR
// if not tmp then
28631: NOP4
28635: NOT
28636: IFFALSE 28640
// exit ;
28638: GO 28666
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
28640: NOP4
28644: PUSH
28645: LD_INT 1
28647: PPUSH
28648: NOP4
28652: PPUSH
28653: NOP4
28657: ARRAY
28658: PPUSH
28659: LD_INT 200
28661: PPUSH
28662: NOP4
// end ;
28666: PPOPN 1
28668: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
28669: NOP4
28673: PUSH
28674: NOP4
28678: AND
28679: IFFALSE 28758
28681: GO 28683
28683: DISABLE
28684: LD_INT 0
28686: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
28687: NOP4
28691: PUSH
28692: LD_INT 22
28694: PUSH
28695: NOP4
28699: PUSH
28700: EMPTY
28701: LIST
28702: LIST
28703: PUSH
28704: LD_INT 21
28706: PUSH
28707: LD_INT 2
28709: PUSH
28710: EMPTY
28711: LIST
28712: LIST
28713: PUSH
28714: EMPTY
28715: LIST
28716: LIST
28717: PPUSH
28718: NOP4
28722: ST_TO_ADDR
// if not tmp then
28723: NOP4
28727: NOT
28728: IFFALSE 28732
// exit ;
28730: GO 28758
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
28732: NOP4
28736: PUSH
28737: LD_INT 1
28739: PPUSH
28740: NOP4
28744: PPUSH
28745: NOP4
28749: ARRAY
28750: PPUSH
28751: LD_INT 60
28753: PPUSH
28754: NOP4
// end ;
28758: PPOPN 1
28760: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
28761: NOP4
28765: PUSH
28766: NOP4
28770: AND
28771: IFFALSE 28870
28773: GO 28775
28775: DISABLE
28776: LD_INT 0
28778: PPUSH
28779: PPUSH
// begin enable ;
28780: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
28781: NOP4
28785: PUSH
28786: LD_INT 22
28788: PUSH
28789: NOP4
28793: PUSH
28794: EMPTY
28795: LIST
28796: LIST
28797: PUSH
28798: LD_INT 61
28800: PUSH
28801: EMPTY
28802: LIST
28803: PUSH
28804: LD_INT 33
28806: PUSH
28807: LD_INT 2
28809: PUSH
28810: EMPTY
28811: LIST
28812: LIST
28813: PUSH
28814: EMPTY
28815: LIST
28816: LIST
28817: LIST
28818: PPUSH
28819: NOP4
28823: ST_TO_ADDR
// if not tmp then
28824: NOP4
28828: NOT
28829: IFFALSE 28833
// exit ;
28831: GO 28870
// for i in tmp do
28833: NOP4
28837: PUSH
28838: NOP4
28842: PUSH
28843: FOR_IN
28844: IFFALSE 28868
// if IsControledBy ( i ) then
28846: NOP4
28850: PPUSH
28851: NOP4
28855: IFFALSE 28866
// ComUnlink ( i ) ;
28857: NOP4
28861: PPUSH
28862: NOP4
28866: GO 28843
28868: POP
28869: POP
// end ;
28870: PPOPN 2
28872: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
28873: NOP4
28877: PUSH
28878: NOP4
28882: AND
28883: IFFALSE 29023
28885: GO 28887
28887: DISABLE
28888: LD_INT 0
28890: PPUSH
28891: PPUSH
// begin ToLua ( displayPowell(); ) ;
28892: LD_STRING displayPowell();
28894: PPUSH
28895: NOP4
// uc_side := 0 ;
28899: LD_ADDR_OWVAR 20
28903: PUSH
28904: LD_INT 0
28906: ST_TO_ADDR
// uc_nation := 2 ;
28907: LD_ADDR_OWVAR 21
28911: PUSH
28912: LD_INT 2
28914: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
28915: LD_ADDR_OWVAR 37
28919: PUSH
28920: LD_INT 14
28922: ST_TO_ADDR
// vc_engine := engine_siberite ;
28923: LD_ADDR_OWVAR 39
28927: PUSH
28928: LD_INT 3
28930: ST_TO_ADDR
// vc_control := control_apeman ;
28931: LD_ADDR_OWVAR 38
28935: PUSH
28936: LD_INT 5
28938: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
28939: LD_ADDR_OWVAR 40
28943: PUSH
28944: LD_INT 29
28946: ST_TO_ADDR
// un := CreateVehicle ;
28947: NOP4
28951: PUSH
28952: NOP4
28956: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
28957: NOP4
28961: PPUSH
28962: LD_INT 1
28964: PPUSH
28965: NOP4
// repeat wait ( 0 0$1 ) ;
28969: LD_INT 35
28971: PPUSH
28972: NOP4
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
28976: NOP4
28980: PPUSH
28981: LD_INT 22
28983: PUSH
28984: NOP4
28988: PUSH
28989: EMPTY
28990: LIST
28991: LIST
28992: PPUSH
28993: NOP4
28997: PPUSH
28998: NOP4
29002: PPUSH
29003: NOP4
29007: PPUSH
29008: NOP4
// until IsDead ( un ) ;
29012: NOP4
29016: PPUSH
29017: NOP4
29021: IFFALSE 28969
// end ;
29023: PPOPN 2
29025: END
// every 0 0$1 trigger StreamModeActive and sStu do
29026: NOP4
29030: PUSH
29031: NOP4
29035: AND
29036: IFFALSE 29052
29038: GO 29040
29040: DISABLE
// begin ToLua ( displayStucuk(); ) ;
29041: LD_STRING displayStucuk();
29043: PPUSH
29044: NOP4
// ResetFog ;
29048: NOP4
// end ;
29052: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
29053: NOP4
29057: PUSH
29058: NOP4
29062: AND
29063: IFFALSE 29204
29065: GO 29067
29067: DISABLE
29068: LD_INT 0
29070: PPUSH
29071: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
29072: NOP4
29076: PUSH
29077: LD_INT 22
29079: PUSH
29080: NOP4
29084: PUSH
29085: EMPTY
29086: LIST
29087: LIST
29088: PUSH
29089: LD_INT 21
29091: PUSH
29092: LD_INT 1
29094: PUSH
29095: EMPTY
29096: LIST
29097: LIST
29098: PUSH
29099: EMPTY
29100: LIST
29101: LIST
29102: PPUSH
29103: NOP4
29107: ST_TO_ADDR
// if not tmp then
29108: NOP4
29112: NOT
29113: IFFALSE 29117
// exit ;
29115: GO 29204
// un := tmp [ rand ( 1 , tmp ) ] ;
29117: NOP4
29121: PUSH
29122: NOP4
29126: PUSH
29127: LD_INT 1
29129: PPUSH
29130: NOP4
29134: PPUSH
29135: NOP4
29139: ARRAY
29140: ST_TO_ADDR
// SetSide ( un , 0 ) ;
29141: NOP4
29145: PPUSH
29146: LD_INT 0
29148: PPUSH
29149: NOP4
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
29153: NOP4
29157: PPUSH
29158: NOP4
29162: PUSH
29163: NOP4
29167: DIFF
29168: PPUSH
29169: NOP4
29173: PPUSH
29174: NOP4
29178: PPUSH
29179: NOP4
// wait ( 0 0$20 ) ;
29183: LD_INT 700
29185: PPUSH
29186: NOP4
// SetSide ( un , your_side ) ;
29190: NOP4
29194: PPUSH
29195: NOP4
29199: PPUSH
29200: NOP4
// end ;
29204: PPOPN 2
29206: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
29207: NOP4
29211: PUSH
29212: NOP4
29216: AND
29217: IFFALSE 29323
29219: GO 29221
29221: DISABLE
29222: LD_INT 0
29224: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
29225: NOP4
29229: PUSH
29230: LD_INT 22
29232: PUSH
29233: NOP4
29237: PUSH
29238: EMPTY
29239: LIST
29240: LIST
29241: PUSH
29242: LD_INT 2
29244: PUSH
29245: LD_INT 30
29247: PUSH
29248: LD_INT 0
29250: PUSH
29251: EMPTY
29252: LIST
29253: LIST
29254: PUSH
29255: LD_INT 30
29257: PUSH
29258: LD_INT 1
29260: PUSH
29261: EMPTY
29262: LIST
29263: LIST
29264: PUSH
29265: EMPTY
29266: LIST
29267: LIST
29268: LIST
29269: PUSH
29270: EMPTY
29271: LIST
29272: LIST
29273: PPUSH
29274: NOP4
29278: ST_TO_ADDR
// if not depot then
29279: NOP4
29283: NOT
29284: IFFALSE 29288
// exit ;
29286: GO 29323
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
29288: NOP4
29292: PUSH
29293: LD_INT 1
29295: ARRAY
29296: PPUSH
29297: NOP4
29301: PPUSH
29302: NOP4
29306: PUSH
29307: LD_INT 1
29309: ARRAY
29310: PPUSH
29311: NOP4
29315: PPUSH
29316: LD_INT 70
29318: PPUSH
29319: NOP4
// end ;
29323: PPOPN 1
29325: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
29326: NOP4
29330: PUSH
29331: NOP4
29335: AND
29336: IFFALSE 29547
29338: GO 29340
29340: DISABLE
29341: LD_INT 0
29343: PPUSH
29344: PPUSH
29345: PPUSH
29346: PPUSH
29347: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
29348: NOP4
29352: PUSH
29353: LD_INT 22
29355: PUSH
29356: NOP4
29360: PUSH
29361: EMPTY
29362: LIST
29363: LIST
29364: PUSH
29365: LD_INT 21
29367: PUSH
29368: LD_INT 1
29370: PUSH
29371: EMPTY
29372: LIST
29373: LIST
29374: PUSH
29375: EMPTY
29376: LIST
29377: LIST
29378: PPUSH
29379: NOP4
29383: ST_TO_ADDR
// if not tmp then
29384: NOP4
29388: NOT
29389: IFFALSE 29393
// exit ;
29391: GO 29547
// for i in tmp do
29393: NOP4
29397: PUSH
29398: NOP4
29402: PUSH
29403: FOR_IN
29404: IFFALSE 29545
// begin d := rand ( 0 , 5 ) ;
29406: NOP4
29410: PUSH
29411: LD_INT 0
29413: PPUSH
29414: LD_INT 5
29416: PPUSH
29417: NOP4
29421: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
29422: NOP4
29426: PUSH
29427: NOP4
29431: PPUSH
29432: NOP4
29436: PPUSH
29437: NOP4
29441: PPUSH
29442: LD_INT 3
29444: PPUSH
29445: LD_INT 12
29447: PPUSH
29448: NOP4
29452: PPUSH
29453: NOP4
29457: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
29458: NOP4
29462: PUSH
29463: NOP4
29467: PPUSH
29468: NOP4
29472: PPUSH
29473: NOP4
29477: PPUSH
29478: LD_INT 3
29480: PPUSH
29481: LD_INT 12
29483: PPUSH
29484: NOP4
29488: PPUSH
29489: NOP4
29493: ST_TO_ADDR
// if ValidHex ( x , y ) then
29494: NOP4
29498: PPUSH
29499: NOP4
29503: PPUSH
29504: NOP4
29508: IFFALSE 29543
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
29510: NOP4
29514: PPUSH
29515: NOP4
29519: PPUSH
29520: NOP4
29524: PPUSH
29525: LD_INT 3
29527: PPUSH
29528: LD_INT 6
29530: PPUSH
29531: NOP4
29535: PPUSH
29536: LD_INT 1
29538: PPUSH
29539: NOP4
// end ;
29543: GO 29403
29545: POP
29546: POP
// end ;
29547: PPOPN 5
29549: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
29550: NOP4
29554: PUSH
29555: NOP4
29559: AND
29560: IFFALSE 29654
29562: GO 29564
29564: DISABLE
29565: LD_INT 0
29567: PPUSH
29568: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
29569: NOP4
29573: PUSH
29574: LD_INT 22
29576: PUSH
29577: NOP4
29581: PUSH
29582: EMPTY
29583: LIST
29584: LIST
29585: PUSH
29586: LD_INT 32
29588: PUSH
29589: LD_INT 1
29591: PUSH
29592: EMPTY
29593: LIST
29594: LIST
29595: PUSH
29596: LD_INT 21
29598: PUSH
29599: LD_INT 2
29601: PUSH
29602: EMPTY
29603: LIST
29604: LIST
29605: PUSH
29606: EMPTY
29607: LIST
29608: LIST
29609: LIST
29610: PPUSH
29611: NOP4
29615: ST_TO_ADDR
// if not tmp then
29616: NOP4
29620: NOT
29621: IFFALSE 29625
// exit ;
29623: GO 29654
// for i in tmp do
29625: NOP4
29629: PUSH
29630: NOP4
29634: PUSH
29635: FOR_IN
29636: IFFALSE 29652
// SetFuel ( i , 0 ) ;
29638: NOP4
29642: PPUSH
29643: LD_INT 0
29645: PPUSH
29646: NOP4
29650: GO 29635
29652: POP
29653: POP
// end ;
29654: PPOPN 2
29656: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
29657: NOP4
29661: PUSH
29662: NOP4
29666: AND
29667: IFFALSE 29733
29669: GO 29671
29671: DISABLE
29672: LD_INT 0
29674: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
29675: NOP4
29679: PUSH
29680: LD_INT 22
29682: PUSH
29683: NOP4
29687: PUSH
29688: EMPTY
29689: LIST
29690: LIST
29691: PUSH
29692: LD_INT 30
29694: PUSH
29695: LD_INT 29
29697: PUSH
29698: EMPTY
29699: LIST
29700: LIST
29701: PUSH
29702: EMPTY
29703: LIST
29704: LIST
29705: PPUSH
29706: NOP4
29710: ST_TO_ADDR
// if not tmp then
29711: NOP4
29715: NOT
29716: IFFALSE 29720
// exit ;
29718: GO 29733
// DestroyUnit ( tmp [ 1 ] ) ;
29720: NOP4
29724: PUSH
29725: LD_INT 1
29727: ARRAY
29728: PPUSH
29729: NOP4
// end ;
29733: PPOPN 1
29735: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
29736: NOP4
29740: PUSH
29741: NOP4
29745: AND
29746: IFFALSE 29875
29748: GO 29750
29750: DISABLE
29751: LD_INT 0
29753: PPUSH
// begin uc_side := 0 ;
29754: LD_ADDR_OWVAR 20
29758: PUSH
29759: LD_INT 0
29761: ST_TO_ADDR
// uc_nation := nation_arabian ;
29762: LD_ADDR_OWVAR 21
29766: PUSH
29767: LD_INT 2
29769: ST_TO_ADDR
// hc_gallery :=  ;
29770: LD_ADDR_OWVAR 33
29774: PUSH
29775: LD_STRING 
29777: ST_TO_ADDR
// hc_name :=  ;
29778: LD_ADDR_OWVAR 26
29782: PUSH
29783: LD_STRING 
29785: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
29786: LD_INT 1
29788: PPUSH
29789: LD_INT 11
29791: PPUSH
29792: LD_INT 10
29794: PPUSH
29795: NOP4
// un := CreateHuman ;
29799: NOP4
29803: PUSH
29804: NOP4
29808: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
29809: NOP4
29813: PPUSH
29814: LD_INT 1
29816: PPUSH
29817: NOP4
// repeat wait ( 0 0$1 ) ;
29821: LD_INT 35
29823: PPUSH
29824: NOP4
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
29828: NOP4
29832: PPUSH
29833: LD_INT 22
29835: PUSH
29836: NOP4
29840: PUSH
29841: EMPTY
29842: LIST
29843: LIST
29844: PPUSH
29845: NOP4
29849: PPUSH
29850: NOP4
29854: PPUSH
29855: NOP4
29859: PPUSH
29860: NOP4
// until IsDead ( un ) ;
29864: NOP4
29868: PPUSH
29869: NOP4
29873: IFFALSE 29821
// end ;
29875: PPOPN 1
29877: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
29878: NOP4
29882: PUSH
29883: NOP4
29887: AND
29888: IFFALSE 29900
29890: GO 29892
29892: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
29893: LD_STRING earthquake(getX(game), 0, 32)
29895: PPUSH
29896: NOP4
29900: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
29901: NOP4
29905: PUSH
29906: NOP4
29910: AND
29911: IFFALSE 30002
29913: GO 29915
29915: DISABLE
29916: LD_INT 0
29918: PPUSH
// begin enable ;
29919: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
29920: NOP4
29924: PUSH
29925: LD_INT 22
29927: PUSH
29928: NOP4
29932: PUSH
29933: EMPTY
29934: LIST
29935: LIST
29936: PUSH
29937: LD_INT 21
29939: PUSH
29940: LD_INT 2
29942: PUSH
29943: EMPTY
29944: LIST
29945: LIST
29946: PUSH
29947: LD_INT 33
29949: PUSH
29950: LD_INT 3
29952: PUSH
29953: EMPTY
29954: LIST
29955: LIST
29956: PUSH
29957: EMPTY
29958: LIST
29959: LIST
29960: LIST
29961: PPUSH
29962: NOP4
29966: ST_TO_ADDR
// if not tmp then
29967: NOP4
29971: NOT
29972: IFFALSE 29976
// exit ;
29974: GO 30002
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
29976: NOP4
29980: PUSH
29981: LD_INT 1
29983: PPUSH
29984: NOP4
29988: PPUSH
29989: NOP4
29993: ARRAY
29994: PPUSH
29995: LD_INT 1
29997: PPUSH
29998: NOP4
// end ;
30002: PPOPN 1
30004: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
30005: NOP4
30009: PUSH
30010: NOP4
30014: AND
30015: IFFALSE 30156
30017: GO 30019
30019: DISABLE
30020: LD_INT 0
30022: PPUSH
30023: PPUSH
30024: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
30025: NOP4
30029: PUSH
30030: LD_INT 22
30032: PUSH
30033: NOP4
30037: PUSH
30038: EMPTY
30039: LIST
30040: LIST
30041: PUSH
30042: LD_INT 25
30044: PUSH
30045: LD_INT 1
30047: PUSH
30048: EMPTY
30049: LIST
30050: LIST
30051: PUSH
30052: EMPTY
30053: LIST
30054: LIST
30055: PPUSH
30056: NOP4
30060: ST_TO_ADDR
// if not tmp then
30061: NOP4
30065: NOT
30066: IFFALSE 30070
// exit ;
30068: GO 30156
// un := tmp [ rand ( 1 , tmp ) ] ;
30070: NOP4
30074: PUSH
30075: NOP4
30079: PUSH
30080: LD_INT 1
30082: PPUSH
30083: NOP4
30087: PPUSH
30088: NOP4
30092: ARRAY
30093: ST_TO_ADDR
// if Crawls ( un ) then
30094: NOP4
30098: PPUSH
30099: NOP4
30103: IFFALSE 30114
// ComWalk ( un ) ;
30105: NOP4
30109: PPUSH
30110: NOP4
// SetClass ( un , class_bazooker ) ;
30114: NOP4
30118: PPUSH
30119: LD_INT 9
30121: PPUSH
30122: NOP4
// SetTech ( tech_tauRad , your_side , state_researched ) ;
30126: LD_INT 28
30128: PPUSH
30129: NOP4
30133: PPUSH
30134: LD_INT 2
30136: PPUSH
30137: NOP4
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
30141: LD_INT 29
30143: PPUSH
30144: NOP4
30148: PPUSH
30149: LD_INT 2
30151: PPUSH
30152: NOP4
// end ;
30156: PPOPN 3
30158: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
30159: NOP4
30163: PUSH
30164: NOP4
30168: AND
30169: IFFALSE 30280
30171: GO 30173
30173: DISABLE
30174: LD_INT 0
30176: PPUSH
30177: PPUSH
30178: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
30179: NOP4
30183: PUSH
30184: LD_INT 22
30186: PUSH
30187: NOP4
30191: PUSH
30192: EMPTY
30193: LIST
30194: LIST
30195: PUSH
30196: LD_INT 25
30198: PUSH
30199: LD_INT 1
30201: PUSH
30202: EMPTY
30203: LIST
30204: LIST
30205: PUSH
30206: EMPTY
30207: LIST
30208: LIST
30209: PPUSH
30210: NOP4
30214: ST_TO_ADDR
// if not tmp then
30215: NOP4
30219: NOT
30220: IFFALSE 30224
// exit ;
30222: GO 30280
// un := tmp [ rand ( 1 , tmp ) ] ;
30224: NOP4
30228: PUSH
30229: NOP4
30233: PUSH
30234: LD_INT 1
30236: PPUSH
30237: NOP4
30241: PPUSH
30242: NOP4
30246: ARRAY
30247: ST_TO_ADDR
// if Crawls ( un ) then
30248: NOP4
30252: PPUSH
30253: NOP4
30257: IFFALSE 30268
// ComWalk ( un ) ;
30259: NOP4
30263: PPUSH
30264: NOP4
// SetClass ( un , class_mortar ) ;
30268: NOP4
30272: PPUSH
30273: LD_INT 8
30275: PPUSH
30276: NOP4
// end ;
30280: PPOPN 3
30282: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
30283: NOP4
30287: PUSH
30288: NOP4
30292: AND
30293: IFFALSE 30437
30295: GO 30297
30297: DISABLE
30298: LD_INT 0
30300: PPUSH
30301: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
30302: NOP4
30306: PUSH
30307: LD_INT 22
30309: PUSH
30310: NOP4
30314: PUSH
30315: EMPTY
30316: LIST
30317: LIST
30318: PUSH
30319: LD_INT 21
30321: PUSH
30322: LD_INT 2
30324: PUSH
30325: EMPTY
30326: LIST
30327: LIST
30328: PUSH
30329: LD_INT 2
30331: PUSH
30332: LD_INT 34
30334: PUSH
30335: LD_INT 12
30337: PUSH
30338: EMPTY
30339: LIST
30340: LIST
30341: PUSH
30342: LD_INT 34
30344: PUSH
30345: LD_INT 51
30347: PUSH
30348: EMPTY
30349: LIST
30350: LIST
30351: PUSH
30352: LD_INT 34
30354: PUSH
30355: LD_INT 32
30357: PUSH
30358: EMPTY
30359: LIST
30360: LIST
30361: PUSH
30362: EMPTY
30363: LIST
30364: LIST
30365: LIST
30366: LIST
30367: PUSH
30368: EMPTY
30369: LIST
30370: LIST
30371: LIST
30372: PPUSH
30373: NOP4
30377: ST_TO_ADDR
// if not tmp then
30378: NOP4
30382: NOT
30383: IFFALSE 30387
// exit ;
30385: GO 30437
// for i in tmp do
30387: NOP4
30391: PUSH
30392: NOP4
30396: PUSH
30397: FOR_IN
30398: IFFALSE 30435
// if GetCargo ( i , mat_artifact ) = 0 then
30400: NOP4
30404: PPUSH
30405: LD_INT 4
30407: PPUSH
30408: NOP4
30412: PUSH
30413: LD_INT 0
30415: EQUAL
30416: IFFALSE 30433
// SetCargo ( i , mat_siberit , 100 ) ;
30418: NOP4
30422: PPUSH
30423: LD_INT 3
30425: PPUSH
30426: LD_INT 100
30428: PPUSH
30429: NOP4
30433: GO 30397
30435: POP
30436: POP
// end ;
30437: PPOPN 2
30439: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
30440: NOP4
30444: PUSH
30445: NOP4
30449: AND
30450: IFFALSE 30633
30452: GO 30454
30454: DISABLE
30455: LD_INT 0
30457: PPUSH
30458: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
30459: NOP4
30463: PUSH
30464: LD_INT 22
30466: PUSH
30467: NOP4
30471: PUSH
30472: EMPTY
30473: LIST
30474: LIST
30475: PPUSH
30476: NOP4
30480: ST_TO_ADDR
// if not tmp then
30481: NOP4
30485: NOT
30486: IFFALSE 30490
// exit ;
30488: GO 30633
// for i := 1 to 2 do
30490: NOP4
30494: PUSH
30495: DOUBLE
30496: LD_INT 1
30498: DEC
30499: ST_TO_ADDR
30500: LD_INT 2
30502: PUSH
30503: FOR_TO
30504: IFFALSE 30631
// begin uc_side := your_side ;
30506: LD_ADDR_OWVAR 20
30510: PUSH
30511: NOP4
30515: ST_TO_ADDR
// uc_nation := nation_american ;
30516: LD_ADDR_OWVAR 21
30520: PUSH
30521: LD_INT 1
30523: ST_TO_ADDR
// vc_chassis := us_morphling ;
30524: LD_ADDR_OWVAR 37
30528: PUSH
30529: LD_INT 5
30531: ST_TO_ADDR
// vc_engine := engine_siberite ;
30532: LD_ADDR_OWVAR 39
30536: PUSH
30537: LD_INT 3
30539: ST_TO_ADDR
// vc_control := control_computer ;
30540: LD_ADDR_OWVAR 38
30544: PUSH
30545: LD_INT 3
30547: ST_TO_ADDR
// vc_weapon := us_double_laser ;
30548: LD_ADDR_OWVAR 40
30552: PUSH
30553: LD_INT 10
30555: ST_TO_ADDR
// if not IsInUnit ( tmp [ 1 ] ) then
30556: NOP4
30560: PUSH
30561: LD_INT 1
30563: ARRAY
30564: PPUSH
30565: NOP4
30569: NOT
30570: IFFALSE 30617
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) else
30572: NOP4
30576: PPUSH
30577: NOP4
30581: PUSH
30582: LD_INT 1
30584: ARRAY
30585: PPUSH
30586: NOP4
30590: PPUSH
30591: NOP4
30595: PUSH
30596: LD_INT 1
30598: ARRAY
30599: PPUSH
30600: NOP4
30604: PPUSH
30605: LD_INT 12
30607: PPUSH
30608: LD_INT 1
30610: PPUSH
30611: NOP4
30615: GO 30629
// PlaceUnitAnywhere ( CreateVehicle , true ) ;
30617: NOP4
30621: PPUSH
30622: LD_INT 1
30624: PPUSH
30625: NOP4
// end ;
30629: GO 30503
30631: POP
30632: POP
// end ;
30633: PPOPN 2
30635: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
30636: NOP4
30640: PUSH
30641: NOP4
30645: AND
30646: IFFALSE 30868
30648: GO 30650
30650: DISABLE
30651: LD_INT 0
30653: PPUSH
30654: PPUSH
30655: PPUSH
30656: PPUSH
30657: PPUSH
30658: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
30659: NOP4
30663: PUSH
30664: LD_INT 22
30666: PUSH
30667: NOP4
30671: PUSH
30672: EMPTY
30673: LIST
30674: LIST
30675: PUSH
30676: LD_INT 21
30678: PUSH
30679: LD_INT 1
30681: PUSH
30682: EMPTY
30683: LIST
30684: LIST
30685: PUSH
30686: LD_INT 3
30688: PUSH
30689: LD_INT 23
30691: PUSH
30692: LD_INT 0
30694: PUSH
30695: EMPTY
30696: LIST
30697: LIST
30698: PUSH
30699: EMPTY
30700: LIST
30701: LIST
30702: PUSH
30703: EMPTY
30704: LIST
30705: LIST
30706: LIST
30707: PPUSH
30708: NOP4
30712: ST_TO_ADDR
// if not tmp then
30713: NOP4
30717: NOT
30718: IFFALSE 30722
// exit ;
30720: GO 30868
// s1 := rand ( 1 , 4 ) ;
30722: NOP4
30726: PUSH
30727: LD_INT 1
30729: PPUSH
30730: LD_INT 4
30732: PPUSH
30733: NOP4
30737: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
30738: NOP4
30742: PUSH
30743: NOP4
30747: PUSH
30748: LD_INT 1
30750: ARRAY
30751: PPUSH
30752: NOP4
30756: PPUSH
30757: NOP4
30761: ST_TO_ADDR
// if s1 = 1 then
30762: NOP4
30766: PUSH
30767: LD_INT 1
30769: EQUAL
30770: IFFALSE 30790
// s2 := rand ( 2 , 4 ) else
30772: NOP4
30776: PUSH
30777: LD_INT 2
30779: PPUSH
30780: LD_INT 4
30782: PPUSH
30783: NOP4
30787: ST_TO_ADDR
30788: GO 30798
// s2 := 1 ;
30790: NOP4
30794: PUSH
30795: LD_INT 1
30797: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
30798: NOP4
30802: PUSH
30803: NOP4
30807: PUSH
30808: LD_INT 1
30810: ARRAY
30811: PPUSH
30812: NOP4
30816: PPUSH
30817: NOP4
30821: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
30822: NOP4
30826: PUSH
30827: LD_INT 1
30829: ARRAY
30830: PPUSH
30831: NOP4
30835: PPUSH
30836: NOP4
30840: PPUSH
30841: NOP4
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
30845: NOP4
30849: PUSH
30850: LD_INT 1
30852: ARRAY
30853: PPUSH
30854: NOP4
30858: PPUSH
30859: NOP4
30863: PPUSH
30864: NOP4
// end ;
30868: PPOPN 6
30870: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
30871: NOP4
30875: PUSH
30876: NOP4
30880: AND
30881: IFFALSE 30960
30883: GO 30885
30885: DISABLE
30886: LD_INT 0
30888: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
30889: NOP4
30893: PUSH
30894: LD_INT 22
30896: PUSH
30897: NOP4
30901: PUSH
30902: EMPTY
30903: LIST
30904: LIST
30905: PUSH
30906: LD_INT 30
30908: PUSH
30909: LD_INT 3
30911: PUSH
30912: EMPTY
30913: LIST
30914: LIST
30915: PUSH
30916: EMPTY
30917: LIST
30918: LIST
30919: PPUSH
30920: NOP4
30924: ST_TO_ADDR
// if not tmp then
30925: NOP4
30929: NOT
30930: IFFALSE 30934
// exit ;
30932: GO 30960
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
30934: NOP4
30938: PUSH
30939: LD_INT 1
30941: PPUSH
30942: NOP4
30946: PPUSH
30947: NOP4
30951: ARRAY
30952: PPUSH
30953: LD_INT 1
30955: PPUSH
30956: NOP4
// end ;
30960: PPOPN 1
30962: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
30963: NOP4
30967: PUSH
30968: NOP4
30972: AND
30973: IFFALSE 31085
30975: GO 30977
30977: DISABLE
30978: LD_INT 0
30980: PPUSH
30981: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
30982: NOP4
30986: PUSH
30987: LD_INT 22
30989: PUSH
30990: NOP4
30994: PUSH
30995: EMPTY
30996: LIST
30997: LIST
30998: PUSH
30999: LD_INT 2
31001: PUSH
31002: LD_INT 30
31004: PUSH
31005: LD_INT 27
31007: PUSH
31008: EMPTY
31009: LIST
31010: LIST
31011: PUSH
31012: LD_INT 30
31014: PUSH
31015: LD_INT 26
31017: PUSH
31018: EMPTY
31019: LIST
31020: LIST
31021: PUSH
31022: LD_INT 30
31024: PUSH
31025: LD_INT 28
31027: PUSH
31028: EMPTY
31029: LIST
31030: LIST
31031: PUSH
31032: EMPTY
31033: LIST
31034: LIST
31035: LIST
31036: LIST
31037: PUSH
31038: EMPTY
31039: LIST
31040: LIST
31041: PPUSH
31042: NOP4
31046: ST_TO_ADDR
// if not tmp then
31047: NOP4
31051: NOT
31052: IFFALSE 31056
// exit ;
31054: GO 31085
// for i in tmp do
31056: NOP4
31060: PUSH
31061: NOP4
31065: PUSH
31066: FOR_IN
31067: IFFALSE 31083
// SetLives ( i , 1 ) ;
31069: NOP4
31073: PPUSH
31074: LD_INT 1
31076: PPUSH
31077: NOP4
31081: GO 31066
31083: POP
31084: POP
// end ;
31085: PPOPN 2
31087: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
31088: NOP4
31092: PUSH
31093: NOP4
31097: AND
31098: IFFALSE 31372
31100: GO 31102
31102: DISABLE
31103: LD_INT 0
31105: PPUSH
31106: PPUSH
31107: PPUSH
// begin i := rand ( 1 , 7 ) ;
31108: NOP4
31112: PUSH
31113: LD_INT 1
31115: PPUSH
31116: LD_INT 7
31118: PPUSH
31119: NOP4
31123: ST_TO_ADDR
// case i of 1 :
31124: NOP4
31128: PUSH
31129: LD_INT 1
31131: DOUBLE
31132: EQUAL
31133: IFTRUE 31137
31135: GO 31147
31137: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
31138: LD_STRING earthquake(getX(game), 0, 32)
31140: PPUSH
31141: NOP4
31145: GO 31372
31147: LD_INT 2
31149: DOUBLE
31150: EQUAL
31151: IFTRUE 31155
31153: GO 31169
31155: POP
// begin ToLua ( displayStucuk(); ) ;
31156: LD_STRING displayStucuk();
31158: PPUSH
31159: NOP4
// ResetFog ;
31163: NOP4
// end ; 3 :
31167: GO 31372
31169: LD_INT 3
31171: DOUBLE
31172: EQUAL
31173: IFTRUE 31177
31175: GO 31281
31177: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
31178: NOP4
31182: PUSH
31183: LD_INT 22
31185: PUSH
31186: NOP4
31190: PUSH
31191: EMPTY
31192: LIST
31193: LIST
31194: PUSH
31195: LD_INT 25
31197: PUSH
31198: LD_INT 1
31200: PUSH
31201: EMPTY
31202: LIST
31203: LIST
31204: PUSH
31205: EMPTY
31206: LIST
31207: LIST
31208: PPUSH
31209: NOP4
31213: ST_TO_ADDR
// if not tmp then
31214: NOP4
31218: NOT
31219: IFFALSE 31223
// exit ;
31221: GO 31372
// un := tmp [ rand ( 1 , tmp ) ] ;
31223: NOP4
31227: PUSH
31228: NOP4
31232: PUSH
31233: LD_INT 1
31235: PPUSH
31236: NOP4
31240: PPUSH
31241: NOP4
31245: ARRAY
31246: ST_TO_ADDR
// if Crawls ( un ) then
31247: NOP4
31251: PPUSH
31252: NOP4
31256: IFFALSE 31267
// ComWalk ( un ) ;
31258: NOP4
31262: PPUSH
31263: NOP4
// SetClass ( un , class_mortar ) ;
31267: NOP4
31271: PPUSH
31272: LD_INT 8
31274: PPUSH
31275: NOP4
// end ; 4 :
31279: GO 31372
31281: LD_INT 4
31283: DOUBLE
31284: EQUAL
31285: IFTRUE 31289
31287: GO 31350
31289: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
31290: NOP4
31294: PUSH
31295: LD_INT 22
31297: PUSH
31298: NOP4
31302: PUSH
31303: EMPTY
31304: LIST
31305: LIST
31306: PUSH
31307: LD_INT 30
31309: PUSH
31310: LD_INT 29
31312: PUSH
31313: EMPTY
31314: LIST
31315: LIST
31316: PUSH
31317: EMPTY
31318: LIST
31319: LIST
31320: PPUSH
31321: NOP4
31325: ST_TO_ADDR
// if not tmp then
31326: NOP4
31330: NOT
31331: IFFALSE 31335
// exit ;
31333: GO 31372
// DestroyUnit ( tmp [ 1 ] ) ;
31335: NOP4
31339: PUSH
31340: LD_INT 1
31342: ARRAY
31343: PPUSH
31344: NOP4
// end ; 5 .. 7 :
31348: GO 31372
31350: LD_INT 5
31352: DOUBLE
31353: GREATEREQUAL
31354: IFFALSE 31362
31356: LD_INT 7
31358: DOUBLE
31359: LESSEQUAL
31360: IFTRUE 31364
31362: GO 31371
31364: POP
// StreamSibBomb ; end ;
31365: NOP4
31369: GO 31372
31371: POP
// end ;
31372: PPOPN 3
31374: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
31375: NOP4
31379: PUSH
31380: NOP4
31384: AND
31385: IFFALSE 31541
31387: GO 31389
31389: DISABLE
31390: LD_INT 0
31392: PPUSH
31393: PPUSH
31394: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
31395: NOP4
31399: PUSH
31400: LD_INT 81
31402: PUSH
31403: NOP4
31407: PUSH
31408: EMPTY
31409: LIST
31410: LIST
31411: PUSH
31412: LD_INT 2
31414: PUSH
31415: LD_INT 21
31417: PUSH
31418: LD_INT 1
31420: PUSH
31421: EMPTY
31422: LIST
31423: LIST
31424: PUSH
31425: LD_INT 21
31427: PUSH
31428: LD_INT 2
31430: PUSH
31431: EMPTY
31432: LIST
31433: LIST
31434: PUSH
31435: EMPTY
31436: LIST
31437: LIST
31438: LIST
31439: PUSH
31440: EMPTY
31441: LIST
31442: LIST
31443: PPUSH
31444: NOP4
31448: ST_TO_ADDR
// if not tmp then
31449: NOP4
31453: NOT
31454: IFFALSE 31458
// exit ;
31456: GO 31541
// p := 0 ;
31458: NOP4
31462: PUSH
31463: LD_INT 0
31465: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
31466: LD_INT 35
31468: PPUSH
31469: NOP4
// p := p + 1 ;
31473: NOP4
31477: PUSH
31478: NOP4
31482: PUSH
31483: LD_INT 1
31485: PLUS
31486: ST_TO_ADDR
// for i in tmp do
31487: NOP4
31491: PUSH
31492: NOP4
31496: PUSH
31497: FOR_IN
31498: IFFALSE 31529
// if GetLives ( i ) < 1000 then
31500: NOP4
31504: PPUSH
31505: NOP4
31509: PUSH
31510: LD_INT 1000
31512: LESS
31513: IFFALSE 31527
// SetLives ( i , 1000 ) ;
31515: NOP4
31519: PPUSH
31520: LD_INT 1000
31522: PPUSH
31523: NOP4
31527: GO 31497
31529: POP
31530: POP
// until p > 20 ;
31531: NOP4
31535: PUSH
31536: LD_INT 20
31538: GREATER
31539: IFFALSE 31466
// end ;
31541: PPOPN 3
31543: END
// every 0 0$1 trigger StreamModeActive and sTime do
31544: NOP4
31548: PUSH
31549: NOP4
31553: AND
31554: IFFALSE 31589
31556: GO 31558
31558: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
31559: LD_INT 28
31561: PPUSH
31562: NOP4
31566: PPUSH
31567: LD_INT 2
31569: PPUSH
31570: NOP4
// SetTech ( tech_tauField , your_side , state_researched ) ;
31574: LD_INT 30
31576: PPUSH
31577: NOP4
31581: PPUSH
31582: LD_INT 2
31584: PPUSH
31585: NOP4
// end ;
31589: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
31590: NOP4
31594: PUSH
31595: NOP4
31599: AND
31600: IFFALSE 31721
31602: GO 31604
31604: DISABLE
31605: LD_INT 0
31607: PPUSH
31608: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
31609: NOP4
31613: PUSH
31614: LD_INT 22
31616: PUSH
31617: NOP4
31621: PUSH
31622: EMPTY
31623: LIST
31624: LIST
31625: PUSH
31626: LD_INT 21
31628: PUSH
31629: LD_INT 1
31631: PUSH
31632: EMPTY
31633: LIST
31634: LIST
31635: PUSH
31636: LD_INT 3
31638: PUSH
31639: LD_INT 23
31641: PUSH
31642: LD_INT 0
31644: PUSH
31645: EMPTY
31646: LIST
31647: LIST
31648: PUSH
31649: EMPTY
31650: LIST
31651: LIST
31652: PUSH
31653: EMPTY
31654: LIST
31655: LIST
31656: LIST
31657: PPUSH
31658: NOP4
31662: ST_TO_ADDR
// if not tmp then
31663: NOP4
31667: NOT
31668: IFFALSE 31672
// exit ;
31670: GO 31721
// for i in tmp do
31672: NOP4
31676: PUSH
31677: NOP4
31681: PUSH
31682: FOR_IN
31683: IFFALSE 31719
// begin if Crawls ( i ) then
31685: NOP4
31689: PPUSH
31690: NOP4
31694: IFFALSE 31705
// ComWalk ( i ) ;
31696: NOP4
31700: PPUSH
31701: NOP4
// SetClass ( i , 2 ) ;
31705: NOP4
31709: PPUSH
31710: LD_INT 2
31712: PPUSH
31713: NOP4
// end ;
31717: GO 31682
31719: POP
31720: POP
// end ;
31721: PPOPN 2
31723: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
31724: NOP4
31728: PUSH
31729: NOP4
31733: AND
31734: IFFALSE 32015
31736: GO 31738
31738: DISABLE
31739: LD_INT 0
31741: PPUSH
31742: PPUSH
31743: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
31744: NOP4
31748: PPUSH
31749: LD_INT 9
31751: PPUSH
31752: LD_INT 1
31754: PPUSH
31755: LD_INT 1
31757: PPUSH
31758: NOP4
// ChangeSideFog ( 9 , your_side ) ;
31762: LD_INT 9
31764: PPUSH
31765: NOP4
31769: PPUSH
31770: NOP4
// uc_side := 9 ;
31774: LD_ADDR_OWVAR 20
31778: PUSH
31779: LD_INT 9
31781: ST_TO_ADDR
// uc_nation := 2 ;
31782: LD_ADDR_OWVAR 21
31786: PUSH
31787: LD_INT 2
31789: ST_TO_ADDR
// hc_name := Dark Warrior ;
31790: LD_ADDR_OWVAR 26
31794: PUSH
31795: LD_STRING Dark Warrior
31797: ST_TO_ADDR
// hc_gallery :=  ;
31798: LD_ADDR_OWVAR 33
31802: PUSH
31803: LD_STRING 
31805: ST_TO_ADDR
// hc_noskilllimit := true ;
31806: LD_ADDR_OWVAR 76
31810: PUSH
31811: LD_INT 1
31813: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
31814: LD_ADDR_OWVAR 31
31818: PUSH
31819: LD_INT 30
31821: PUSH
31822: LD_INT 30
31824: PUSH
31825: LD_INT 30
31827: PUSH
31828: LD_INT 30
31830: PUSH
31831: EMPTY
31832: LIST
31833: LIST
31834: LIST
31835: LIST
31836: ST_TO_ADDR
// un := CreateHuman ;
31837: NOP4
31841: PUSH
31842: NOP4
31846: ST_TO_ADDR
// hc_noskilllimit := false ;
31847: LD_ADDR_OWVAR 76
31851: PUSH
31852: LD_INT 0
31854: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
31855: NOP4
31859: PPUSH
31860: LD_INT 1
31862: PPUSH
31863: NOP4
// p := 0 ;
31867: NOP4
31871: PUSH
31872: LD_INT 0
31874: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
31875: LD_INT 35
31877: PPUSH
31878: NOP4
// p := p + 1 ;
31882: NOP4
31886: PUSH
31887: NOP4
31891: PUSH
31892: LD_INT 1
31894: PLUS
31895: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
31896: NOP4
31900: PPUSH
31901: NOP4
31905: PUSH
31906: LD_INT 1000
31908: LESS
31909: IFFALSE 31923
// SetLives ( un , 1000 ) ;
31911: NOP4
31915: PPUSH
31916: LD_INT 1000
31918: PPUSH
31919: NOP4
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
31923: NOP4
31927: PPUSH
31928: LD_INT 81
31930: PUSH
31931: NOP4
31935: PUSH
31936: EMPTY
31937: LIST
31938: LIST
31939: PUSH
31940: LD_INT 91
31942: PUSH
31943: NOP4
31947: PUSH
31948: LD_INT 30
31950: PUSH
31951: EMPTY
31952: LIST
31953: LIST
31954: LIST
31955: PUSH
31956: EMPTY
31957: LIST
31958: LIST
31959: PPUSH
31960: NOP4
31964: PPUSH
31965: NOP4
31969: PPUSH
31970: NOP4
31974: PPUSH
31975: NOP4
// until p > 60 or IsDead ( un ) ;
31979: NOP4
31983: PUSH
31984: LD_INT 60
31986: GREATER
31987: PUSH
31988: NOP4
31992: PPUSH
31993: NOP4
31997: OR
31998: IFFALSE 31875
// if un then
32000: NOP4
32004: IFFALSE 32015
// RemoveUnit ( un ) ;
32006: NOP4
32010: PPUSH
32011: NOP4
// end ;
32015: PPOPN 3
32017: END
// export function hHackUnlimitedResources ; var i , j , tmp ; begin
32018: LD_INT 0
32020: PPUSH
32021: PPUSH
32022: PPUSH
32023: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
32024: NOP4
32028: PUSH
32029: LD_INT 22
32031: PUSH
32032: NOP4
32036: PUSH
32037: EMPTY
32038: LIST
32039: LIST
32040: PUSH
32041: LD_INT 2
32043: PUSH
32044: LD_INT 30
32046: PUSH
32047: LD_INT 0
32049: PUSH
32050: EMPTY
32051: LIST
32052: LIST
32053: PUSH
32054: LD_INT 30
32056: PUSH
32057: LD_INT 1
32059: PUSH
32060: EMPTY
32061: LIST
32062: LIST
32063: PUSH
32064: EMPTY
32065: LIST
32066: LIST
32067: LIST
32068: PUSH
32069: EMPTY
32070: LIST
32071: LIST
32072: PPUSH
32073: NOP4
32077: ST_TO_ADDR
// if not tmp then
32078: NOP4
32082: NOT
32083: IFFALSE 32087
// exit ;
32085: GO 32146
// for i in tmp do
32087: NOP4
32091: PUSH
32092: NOP4
32096: PUSH
32097: FOR_IN
32098: IFFALSE 32144
// for j = 1 to 3 do
32100: NOP4
32104: PUSH
32105: DOUBLE
32106: LD_INT 1
32108: DEC
32109: ST_TO_ADDR
32110: LD_INT 3
32112: PUSH
32113: FOR_TO
32114: IFFALSE 32140
// SetResourceType ( GetBase ( i ) , j , 99999 ) ;
32116: NOP4
32120: PPUSH
32121: NOP4
32125: PPUSH
32126: NOP4
32130: PPUSH
32131: LD_INT 99999
32133: PPUSH
32134: NOP4
32138: GO 32113
32140: POP
32141: POP
32142: GO 32097
32144: POP
32145: POP
// end ;
32146: LD_VAR 0 1
32150: RET
// export function hHackSetLevel10 ; var i , j ; begin
32151: LD_INT 0
32153: PPUSH
32154: PPUSH
32155: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
32156: NOP4
32160: PUSH
32161: LD_INT 21
32163: PUSH
32164: LD_INT 1
32166: PUSH
32167: EMPTY
32168: LIST
32169: LIST
32170: PPUSH
32171: NOP4
32175: PUSH
32176: FOR_IN
32177: IFFALSE 32229
// if IsSelected ( i ) then
32179: NOP4
32183: PPUSH
32184: NOP4
32188: IFFALSE 32227
// begin for j := 1 to 4 do
32190: NOP4
32194: PUSH
32195: DOUBLE
32196: LD_INT 1
32198: DEC
32199: ST_TO_ADDR
32200: LD_INT 4
32202: PUSH
32203: FOR_TO
32204: IFFALSE 32225
// SetSkill ( i , j , 10 ) ;
32206: NOP4
32210: PPUSH
32211: NOP4
32215: PPUSH
32216: LD_INT 10
32218: PPUSH
32219: NOP4
32223: GO 32203
32225: POP
32226: POP
// end ;
32227: GO 32176
32229: POP
32230: POP
// end ;
32231: LD_VAR 0 1
32235: RET
// export function hHackSetLevel10YourUnits ; var i , j ; begin
32236: LD_INT 0
32238: PPUSH
32239: PPUSH
32240: PPUSH
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) do
32241: NOP4
32245: PUSH
32246: LD_INT 22
32248: PUSH
32249: NOP4
32253: PUSH
32254: EMPTY
32255: LIST
32256: LIST
32257: PUSH
32258: LD_INT 21
32260: PUSH
32261: LD_INT 1
32263: PUSH
32264: EMPTY
32265: LIST
32266: LIST
32267: PUSH
32268: EMPTY
32269: LIST
32270: LIST
32271: PPUSH
32272: NOP4
32276: PUSH
32277: FOR_IN
32278: IFFALSE 32319
// begin for j := 1 to 4 do
32280: NOP4
32284: PUSH
32285: DOUBLE
32286: LD_INT 1
32288: DEC
32289: ST_TO_ADDR
32290: LD_INT 4
32292: PUSH
32293: FOR_TO
32294: IFFALSE 32315
// SetSkill ( i , j , 10 ) ;
32296: NOP4
32300: PPUSH
32301: NOP4
32305: PPUSH
32306: LD_INT 10
32308: PPUSH
32309: NOP4
32313: GO 32293
32315: POP
32316: POP
// end ;
32317: GO 32277
32319: POP
32320: POP
// end ;
32321: LD_VAR 0 1
32325: RET
// export function hHackSpawnHuman ( nation , class , skill ) ; begin
32326: LD_INT 0
32328: PPUSH
// uc_side := your_side ;
32329: LD_ADDR_OWVAR 20
32333: PUSH
32334: NOP4
32338: ST_TO_ADDR
// uc_nation := nation ;
32339: LD_ADDR_OWVAR 21
32343: PUSH
32344: NOP4
32348: ST_TO_ADDR
// InitHc ;
32349: NOP4
// PrepareHuman ( false , class , skill ) ;
32353: LD_INT 0
32355: PPUSH
32356: NOP4
32360: PPUSH
32361: NOP4
32365: PPUSH
32366: NOP4
// PlaceUnitAnywhere ( CreateHuman , true ) ;
32370: NOP4
32374: PPUSH
32375: LD_INT 1
32377: PPUSH
32378: NOP4
// end ;
32382: LD_VAR 0 4
32386: RET
// export function hHackSpawnVehicle ; begin
32387: LD_INT 0
32389: PPUSH
// uc_side := your_side ;
32390: LD_ADDR_OWVAR 20
32394: PUSH
32395: NOP4
32399: ST_TO_ADDR
// uc_nation := rand ( 1 , 3 ) ;
32400: LD_ADDR_OWVAR 21
32404: PUSH
32405: LD_INT 1
32407: PPUSH
32408: LD_INT 3
32410: PPUSH
32411: NOP4
32415: ST_TO_ADDR
// InitVc ;
32416: NOP4
// case uc_nation of 1 :
32420: NOP4
32424: PUSH
32425: LD_INT 1
32427: DOUBLE
32428: EQUAL
32429: IFTRUE 32433
32431: GO 32577
32433: POP
// begin vc_chassis := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] [ rand ( 1 , 5 ) ] ;
32434: LD_ADDR_OWVAR 37
32438: PUSH
32439: LD_INT 1
32441: PUSH
32442: LD_INT 2
32444: PUSH
32445: LD_INT 3
32447: PUSH
32448: LD_INT 4
32450: PUSH
32451: LD_INT 5
32453: PUSH
32454: EMPTY
32455: LIST
32456: LIST
32457: LIST
32458: LIST
32459: LIST
32460: PUSH
32461: LD_INT 1
32463: PPUSH
32464: LD_INT 5
32466: PPUSH
32467: NOP4
32471: ARRAY
32472: ST_TO_ADDR
// vc_engine := rand ( 1 , 3 ) ;
32473: LD_ADDR_OWVAR 39
32477: PUSH
32478: LD_INT 1
32480: PPUSH
32481: LD_INT 3
32483: PPUSH
32484: NOP4
32488: ST_TO_ADDR
// vc_control := [ control_manual , control_remote , control_computer ] [ rand ( 1 , 3 ) ] ;
32489: LD_ADDR_OWVAR 38
32493: PUSH
32494: LD_INT 1
32496: PUSH
32497: LD_INT 2
32499: PUSH
32500: LD_INT 3
32502: PUSH
32503: EMPTY
32504: LIST
32505: LIST
32506: LIST
32507: PUSH
32508: LD_INT 1
32510: PPUSH
32511: LD_INT 3
32513: PPUSH
32514: NOP4
32518: ARRAY
32519: ST_TO_ADDR
// vc_weapon := [ us_machine_gun , us_gatling_gun , us_double_gun , us_light_gun , us_rocket_launcher , us_siberium_rocket , us_laser , us_double_laser , us_heavy_gun ] [ rand ( 1 , 9 ) ] ;
32520: LD_ADDR_OWVAR 40
32524: PUSH
32525: LD_INT 2
32527: PUSH
32528: LD_INT 4
32530: PUSH
32531: LD_INT 5
32533: PUSH
32534: LD_INT 3
32536: PUSH
32537: LD_INT 7
32539: PUSH
32540: LD_INT 8
32542: PUSH
32543: LD_INT 9
32545: PUSH
32546: LD_INT 10
32548: PUSH
32549: LD_INT 6
32551: PUSH
32552: EMPTY
32553: LIST
32554: LIST
32555: LIST
32556: LIST
32557: LIST
32558: LIST
32559: LIST
32560: LIST
32561: LIST
32562: PUSH
32563: LD_INT 1
32565: PPUSH
32566: LD_INT 9
32568: PPUSH
32569: NOP4
32573: ARRAY
32574: ST_TO_ADDR
// end ; 2 :
32575: GO 32842
32577: LD_INT 2
32579: DOUBLE
32580: EQUAL
32581: IFTRUE 32585
32583: GO 32709
32585: POP
// begin vc_chassis := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] [ rand ( 1 , 4 ) ] ;
32586: LD_ADDR_OWVAR 37
32590: PUSH
32591: LD_INT 11
32593: PUSH
32594: LD_INT 12
32596: PUSH
32597: LD_INT 13
32599: PUSH
32600: LD_INT 14
32602: PUSH
32603: EMPTY
32604: LIST
32605: LIST
32606: LIST
32607: LIST
32608: PUSH
32609: LD_INT 1
32611: PPUSH
32612: LD_INT 4
32614: PPUSH
32615: NOP4
32619: ARRAY
32620: ST_TO_ADDR
// vc_engine := rand ( 1 , 3 ) ;
32621: LD_ADDR_OWVAR 39
32625: PUSH
32626: LD_INT 1
32628: PPUSH
32629: LD_INT 3
32631: PPUSH
32632: NOP4
32636: ST_TO_ADDR
// vc_control := [ control_manual , control_remote , control_apeman ] [ rand ( 1 , 3 ) ] ;
32637: LD_ADDR_OWVAR 38
32641: PUSH
32642: LD_INT 1
32644: PUSH
32645: LD_INT 2
32647: PUSH
32648: LD_INT 5
32650: PUSH
32651: EMPTY
32652: LIST
32653: LIST
32654: LIST
32655: PUSH
32656: LD_INT 1
32658: PPUSH
32659: LD_INT 3
32661: PPUSH
32662: NOP4
32666: ARRAY
32667: ST_TO_ADDR
// vc_weapon := [ ar_double_machine_gun , ar_flame_thrower , ar_gun , ar_rocket_launcher , ar_selfpropelled_bomb ] [ rand ( 1 , 5 ) ] ;
32668: LD_ADDR_OWVAR 40
32672: PUSH
32673: LD_INT 24
32675: PUSH
32676: LD_INT 26
32678: PUSH
32679: LD_INT 27
32681: PUSH
32682: LD_INT 28
32684: PUSH
32685: LD_INT 29
32687: PUSH
32688: EMPTY
32689: LIST
32690: LIST
32691: LIST
32692: LIST
32693: LIST
32694: PUSH
32695: LD_INT 1
32697: PPUSH
32698: LD_INT 5
32700: PPUSH
32701: NOP4
32705: ARRAY
32706: ST_TO_ADDR
// end ; 3 :
32707: GO 32842
32709: LD_INT 3
32711: DOUBLE
32712: EQUAL
32713: IFTRUE 32717
32715: GO 32841
32717: POP
// begin vc_chassis := [ ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] [ rand ( 1 , 4 ) ] ;
32718: LD_ADDR_OWVAR 37
32722: PUSH
32723: LD_INT 21
32725: PUSH
32726: LD_INT 23
32728: PUSH
32729: LD_INT 22
32731: PUSH
32732: LD_INT 24
32734: PUSH
32735: EMPTY
32736: LIST
32737: LIST
32738: LIST
32739: LIST
32740: PUSH
32741: LD_INT 1
32743: PPUSH
32744: LD_INT 4
32746: PPUSH
32747: NOP4
32751: ARRAY
32752: ST_TO_ADDR
// vc_engine := rand ( 1 , 3 ) ;
32753: LD_ADDR_OWVAR 39
32757: PUSH
32758: LD_INT 1
32760: PPUSH
32761: LD_INT 3
32763: PPUSH
32764: NOP4
32768: ST_TO_ADDR
// vc_control := [ control_manual , control_computer ] [ rand ( 1 , 2 ) ] ;
32769: LD_ADDR_OWVAR 38
32773: PUSH
32774: LD_INT 1
32776: PUSH
32777: LD_INT 3
32779: PUSH
32780: EMPTY
32781: LIST
32782: LIST
32783: PUSH
32784: LD_INT 1
32786: PPUSH
32787: LD_INT 2
32789: PPUSH
32790: NOP4
32794: ARRAY
32795: ST_TO_ADDR
// vc_weapon := [ ru_heavy_machine_gun , ru_gatling_gun , ru_gun , ru_heavy_gun , ru_siberium_rocket , ru_rocket ] [ rand ( 1 , 6 ) ] ;
32796: LD_ADDR_OWVAR 40
32800: PUSH
32801: LD_INT 42
32803: PUSH
32804: LD_INT 43
32806: PUSH
32807: LD_INT 44
32809: PUSH
32810: LD_INT 46
32812: PUSH
32813: LD_INT 48
32815: PUSH
32816: LD_INT 47
32818: PUSH
32819: EMPTY
32820: LIST
32821: LIST
32822: LIST
32823: LIST
32824: LIST
32825: LIST
32826: PUSH
32827: LD_INT 1
32829: PPUSH
32830: LD_INT 6
32832: PPUSH
32833: NOP4
32837: ARRAY
32838: ST_TO_ADDR
// end ; end ;
32839: GO 32842
32841: POP
// PlaceUnitAnywhere ( CreateVehicle , true ) ;
32842: NOP4
32846: PPUSH
32847: LD_INT 1
32849: PPUSH
32850: NOP4
// end ;
32854: LD_VAR 0 1
32858: RET
// export hInvincible ; every 1 do
32859: GO 32861
32861: DISABLE
// hInvincible := [ ] ;
32862: NOP4
32866: PUSH
32867: EMPTY
32868: ST_TO_ADDR
32869: END
// every 10 do var i ;
32870: GO 32872
32872: DISABLE
32873: LD_INT 0
32875: PPUSH
// begin enable ;
32876: ENABLE
// if not hInvincible then
32877: NOP4
32881: NOT
32882: IFFALSE 32886
// exit ;
32884: GO 32930
// for i in hInvincible do
32886: NOP4
32890: PUSH
32891: NOP4
32895: PUSH
32896: FOR_IN
32897: IFFALSE 32928
// if GetLives ( i ) < 1000 then
32899: NOP4
32903: PPUSH
32904: NOP4
32908: PUSH
32909: LD_INT 1000
32911: LESS
32912: IFFALSE 32926
// SetLives ( i , 1000 ) ;
32914: NOP4
32918: PPUSH
32919: LD_INT 1000
32921: PPUSH
32922: NOP4
32926: GO 32896
32928: POP
32929: POP
// end ;
32930: PPOPN 1
32932: END
// export function hHackInvincible ; var i ; begin
32933: LD_INT 0
32935: PPUSH
32936: PPUSH
// for i in FilterAllUnits ( [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ) do
32937: NOP4
32941: PUSH
32942: LD_INT 2
32944: PUSH
32945: LD_INT 21
32947: PUSH
32948: LD_INT 1
32950: PUSH
32951: EMPTY
32952: LIST
32953: LIST
32954: PUSH
32955: LD_INT 21
32957: PUSH
32958: LD_INT 2
32960: PUSH
32961: EMPTY
32962: LIST
32963: LIST
32964: PUSH
32965: EMPTY
32966: LIST
32967: LIST
32968: LIST
32969: PPUSH
32970: NOP4
32974: PUSH
32975: FOR_IN
32976: IFFALSE 33037
// if IsSelected ( i ) then
32978: NOP4
32982: PPUSH
32983: NOP4
32987: IFFALSE 33035
// begin if i in hInvincible then
32989: NOP4
32993: PUSH
32994: NOP4
32998: IN
32999: IFFALSE 33019
// hInvincible := hInvincible diff i else
33001: NOP4
33005: PUSH
33006: NOP4
33010: PUSH
33011: NOP4
33015: DIFF
33016: ST_TO_ADDR
33017: GO 33035
// hInvincible := hInvincible union i ;
33019: NOP4
33023: PUSH
33024: NOP4
33028: PUSH
33029: NOP4
33033: UNION
33034: ST_TO_ADDR
// end ;
33035: GO 32975
33037: POP
33038: POP
// end ;
33039: LD_VAR 0 1
33043: RET
// export function hHackInvisible ; var i , j ; begin
33044: LD_INT 0
33046: PPUSH
33047: PPUSH
33048: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
33049: NOP4
33053: PUSH
33054: LD_INT 21
33056: PUSH
33057: LD_INT 1
33059: PUSH
33060: EMPTY
33061: LIST
33062: LIST
33063: PPUSH
33064: NOP4
33068: PUSH
33069: FOR_IN
33070: IFFALSE 33094
// if IsSelected ( i ) then
33072: NOP4
33076: PPUSH
33077: NOP4
33081: IFFALSE 33092
// ComForceInvisible ( i ) ;
33083: NOP4
33087: PPUSH
33088: NOP4
33092: GO 33069
33094: POP
33095: POP
// end ;
33096: LD_VAR 0 1
33100: RET
// export function hHackChangeYourSide ; begin
33101: LD_INT 0
33103: PPUSH
// if your_side = 8 then
33104: NOP4
33108: PUSH
33109: LD_INT 8
33111: EQUAL
33112: IFFALSE 33124
// your_side := 0 else
33114: LD_ADDR_OWVAR 2
33118: PUSH
33119: LD_INT 0
33121: ST_TO_ADDR
33122: GO 33138
// your_side := your_side + 1 ;
33124: LD_ADDR_OWVAR 2
33128: PUSH
33129: NOP4
33133: PUSH
33134: LD_INT 1
33136: PLUS
33137: ST_TO_ADDR
// end ;
33138: LD_VAR 0 1
33142: RET
// export function hHackChangeUnitSide ; var i , j ; begin
33143: LD_INT 0
33145: PPUSH
33146: PPUSH
33147: PPUSH
// for i in all_units do
33148: NOP4
33152: PUSH
33153: NOP4
33157: PUSH
33158: FOR_IN
33159: IFFALSE 33237
// if IsSelected ( i ) then
33161: NOP4
33165: PPUSH
33166: NOP4
33170: IFFALSE 33235
// begin j := GetSide ( i ) ;
33172: NOP4
33176: PUSH
33177: NOP4
33181: PPUSH
33182: NOP4
33186: ST_TO_ADDR
// if j = 8 then
33187: NOP4
33191: PUSH
33192: LD_INT 8
33194: EQUAL
33195: IFFALSE 33207
// j := 0 else
33197: NOP4
33201: PUSH
33202: LD_INT 0
33204: ST_TO_ADDR
33205: GO 33221
// j := j + 1 ;
33207: NOP4
33211: PUSH
33212: NOP4
33216: PUSH
33217: LD_INT 1
33219: PLUS
33220: ST_TO_ADDR
// SetSide ( i , j ) ;
33221: NOP4
33225: PPUSH
33226: NOP4
33230: PPUSH
33231: NOP4
// end ;
33235: GO 33158
33237: POP
33238: POP
// end ;
33239: LD_VAR 0 1
33243: RET
// export function hHackFog ; begin
33244: LD_INT 0
33246: PPUSH
// FogOff ( true ) ;
33247: LD_INT 1
33249: PPUSH
33250: NOP4
// end ;
33254: LD_VAR 0 1
33258: RET
// export function hHackApeman ; begin
33259: LD_INT 0
33261: PPUSH
// uc_side := your_side ;
33262: LD_ADDR_OWVAR 20
33266: PUSH
33267: NOP4
33271: ST_TO_ADDR
// uc_nation := 0 ;
33272: LD_ADDR_OWVAR 21
33276: PUSH
33277: LD_INT 0
33279: ST_TO_ADDR
// hc_name :=  ;
33280: LD_ADDR_OWVAR 26
33284: PUSH
33285: LD_STRING 
33287: ST_TO_ADDR
// hc_gallery :=  ;
33288: LD_ADDR_OWVAR 33
33292: PUSH
33293: LD_STRING 
33295: ST_TO_ADDR
// hc_skills := [ 0 , 0 , 0 , 0 ] ;
33296: LD_ADDR_OWVAR 31
33300: PUSH
33301: LD_INT 0
33303: PUSH
33304: LD_INT 0
33306: PUSH
33307: LD_INT 0
33309: PUSH
33310: LD_INT 0
33312: PUSH
33313: EMPTY
33314: LIST
33315: LIST
33316: LIST
33317: LIST
33318: ST_TO_ADDR
// hc_class := class_apeman ;
33319: LD_ADDR_OWVAR 28
33323: PUSH
33324: LD_INT 12
33326: ST_TO_ADDR
// PlaceUnitAnywhere ( CreateHuman , true ) ;
33327: NOP4
33331: PPUSH
33332: LD_INT 1
33334: PPUSH
33335: NOP4
// end ;
33339: LD_VAR 0 1
33343: RET
// export function hHackBoom ; begin
33344: LD_INT 0
33346: PPUSH
// uc_side := your_side ;
33347: LD_ADDR_OWVAR 20
33351: PUSH
33352: NOP4
33356: ST_TO_ADDR
// uc_nation := 1 ;
33357: LD_ADDR_OWVAR 21
33361: PUSH
33362: LD_INT 1
33364: ST_TO_ADDR
// vc_chassis := us_morphling ;
33365: LD_ADDR_OWVAR 37
33369: PUSH
33370: LD_INT 5
33372: ST_TO_ADDR
// vc_engine := engine_siberite ;
33373: LD_ADDR_OWVAR 39
33377: PUSH
33378: LD_INT 3
33380: ST_TO_ADDR
// vc_control := control_computer ;
33381: LD_ADDR_OWVAR 38
33385: PUSH
33386: LD_INT 3
33388: ST_TO_ADDR
// vc_weapon := us_siberium_rocket ;
33389: LD_ADDR_OWVAR 40
33393: PUSH
33394: LD_INT 8
33396: ST_TO_ADDR
// PlaceUnitAnywhere ( CreateVehicle , true ) ;
33397: NOP4
33401: PPUSH
33402: LD_INT 1
33404: PPUSH
33405: NOP4
// end ;
33409: LD_VAR 0 1
33413: RET
